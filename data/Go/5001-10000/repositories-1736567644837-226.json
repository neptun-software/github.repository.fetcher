{
  "metadata": {
    "timestamp": 1736567644837,
    "page": 226,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjIzMA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "shopspring/decimal",
      "stars": 6503,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.0625,
          "content": ".git\n*.swp\n\n# IntelliJ\n.idea/\n*.iml\n\n# VS code\n*.code-workspace\n"
        },
        {
          "name": "CHANGELOG.md",
          "type": "blob",
          "size": 5.0107421875,
          "content": "## Decimal v1.4.0\n#### BREAKING\n- Drop support for Go version older than 1.10 [#361](https://github.com/shopspring/decimal/pull/361)\n\n#### FEATURES\n- Add implementation of natural logarithm [#339](https://github.com/shopspring/decimal/pull/339) [#357](https://github.com/shopspring/decimal/pull/357)\n- Add improved implementation of power operation [#358](https://github.com/shopspring/decimal/pull/358)\n- Add Compare method which forwards calls to Cmp [#346](https://github.com/shopspring/decimal/pull/346)\n- Add NewFromBigRat constructor [#288](https://github.com/shopspring/decimal/pull/288)\n- Add NewFromUint64 constructor [#352](https://github.com/shopspring/decimal/pull/352)\n\n#### ENHANCEMENTS\n- Migrate to Github Actions [#245](https://github.com/shopspring/decimal/pull/245) [#340](https://github.com/shopspring/decimal/pull/340)\n- Fix examples for RoundDown, RoundFloor, RoundUp, and RoundCeil [#285](https://github.com/shopspring/decimal/pull/285) [#328](https://github.com/shopspring/decimal/pull/328) [#341](https://github.com/shopspring/decimal/pull/341)\n- Use Godoc standard to mark deprecated Equals and StringScaled methods [#342](https://github.com/shopspring/decimal/pull/342)\n- Removed unnecessary min function for RescalePair method [#265](https://github.com/shopspring/decimal/pull/265)\n- Avoid reallocation of initial slice in MarshalBinary (GobEncode) [#355](https://github.com/shopspring/decimal/pull/355)\n- Optimize NumDigits method [#301](https://github.com/shopspring/decimal/pull/301) [#356](https://github.com/shopspring/decimal/pull/356)\n- Optimize BigInt method [#359](https://github.com/shopspring/decimal/pull/359)\n- Support scanning uint64 [#131](https://github.com/shopspring/decimal/pull/131) [#364](https://github.com/shopspring/decimal/pull/364)\n- Add docs section with alternative libraries [#363](https://github.com/shopspring/decimal/pull/363)\n\n#### BUGFIXES\n- Fix incorrect calculation of decimal modulo [#258](https://github.com/shopspring/decimal/pull/258) [#317](https://github.com/shopspring/decimal/pull/317)\n- Allocate new(big.Int) in Copy method to deeply clone it [#278](https://github.com/shopspring/decimal/pull/278)\n- Fix overflow edge case in QuoRem method [#322](https://github.com/shopspring/decimal/pull/322)\n\n## Decimal v1.3.1\n\n#### ENHANCEMENTS\n- Reduce memory allocation in case of initialization from big.Int [#252](https://github.com/shopspring/decimal/pull/252)\n\n#### BUGFIXES\n- Fix binary marshalling of decimal zero value  [#253](https://github.com/shopspring/decimal/pull/253)\n\n## Decimal v1.3.0\n\n#### FEATURES\n- Add NewFromFormattedString initializer [#184](https://github.com/shopspring/decimal/pull/184)\n- Add NewNullDecimal initializer [#234](https://github.com/shopspring/decimal/pull/234)\n- Add implementation of natural exponent function (Taylor, Hull-Abraham) [#229](https://github.com/shopspring/decimal/pull/229)\n- Add RoundUp, RoundDown, RoundCeil, RoundFloor methods [#196](https://github.com/shopspring/decimal/pull/196) [#202](https://github.com/shopspring/decimal/pull/202) [#220](https://github.com/shopspring/decimal/pull/220)\n- Add XML support for NullDecimal [#192](https://github.com/shopspring/decimal/pull/192)\n- Add IsInteger method [#179](https://github.com/shopspring/decimal/pull/179)\n- Add Copy helper method [#123](https://github.com/shopspring/decimal/pull/123)\n- Add InexactFloat64 helper method [#205](https://github.com/shopspring/decimal/pull/205)\n- Add CoefficientInt64 helper method [#244](https://github.com/shopspring/decimal/pull/244)\n\n#### ENHANCEMENTS\n- Performance optimization of NewFromString init method [#198](https://github.com/shopspring/decimal/pull/198)\n- Performance optimization of Abs and Round methods [#240](https://github.com/shopspring/decimal/pull/240)\n- Additional tests (CI) for ppc64le architecture [#188](https://github.com/shopspring/decimal/pull/188)\n\n#### BUGFIXES\n- Fix rounding in FormatFloat fallback path (roundShortest method, fix taken from Go main repository) [#161](https://github.com/shopspring/decimal/pull/161)\n- Add slice range checks to UnmarshalBinary method [#232](https://github.com/shopspring/decimal/pull/232)\n\n## Decimal v1.2.0\n\n#### BREAKING\n- Drop support for Go version older than 1.7 [#172](https://github.com/shopspring/decimal/pull/172)\n\n#### FEATURES\n- Add NewFromInt and NewFromInt32 initializers [#72](https://github.com/shopspring/decimal/pull/72)\n- Add support for Go modules [#157](https://github.com/shopspring/decimal/pull/157)\n- Add BigInt, BigFloat helper methods [#171](https://github.com/shopspring/decimal/pull/171)\n\n#### ENHANCEMENTS\n- Memory usage optimization [#160](https://github.com/shopspring/decimal/pull/160)\n- Updated travis CI golang versions [#156](https://github.com/shopspring/decimal/pull/156)\n- Update documentation [#173](https://github.com/shopspring/decimal/pull/173)\n- Improve code quality [#174](https://github.com/shopspring/decimal/pull/174)\n\n#### BUGFIXES\n- Revert remove insignificant digits [#159](https://github.com/shopspring/decimal/pull/159)\n- Remove 15 interval for RoundCash [#166](https://github.com/shopspring/decimal/pull/166)\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 2.1923828125,
          "content": "The MIT License (MIT)\n\nCopyright (c) 2015 Spring, Inc.\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n\n- Based on https://github.com/oguzbilgic/fpd, which has the following license:\n\"\"\"\nThe MIT License (MIT)\n\nCopyright (c) 2013 Oguz Bilgic\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of\nthis software and associated documentation files (the \"Software\"), to deal in\nthe Software without restriction, including without limitation the rights to\nuse, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of\nthe Software, and to permit persons to whom the Software is furnished to do so,\nsubject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS\nFOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR\nCOPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER\nIN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\nCONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\"\"\"\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 5.44921875,
          "content": "# decimal\n\n[![ci](https://github.com/shopspring/decimal/actions/workflows/ci.yml/badge.svg?branch=master)](https://github.com/shopspring/decimal/actions/workflows/ci.yml)\n[![GoDoc](https://godoc.org/github.com/shopspring/decimal?status.svg)](https://godoc.org/github.com/shopspring/decimal) \n[![Go Report Card](https://goreportcard.com/badge/github.com/shopspring/decimal)](https://goreportcard.com/report/github.com/shopspring/decimal)\n\nArbitrary-precision fixed-point decimal numbers in go.\n\n_Note:_ Decimal library can \"only\" represent numbers with a maximum of 2^31 digits after the decimal point.\n\n## Features\n\n * The zero-value is 0, and is safe to use without initialization\n * Addition, subtraction, multiplication with no loss of precision\n * Division with specified precision\n * Database/sql serialization/deserialization\n * JSON and XML serialization/deserialization\n\n## Install\n\nRun `go get github.com/shopspring/decimal`\n\n## Requirements \n\nDecimal library requires Go version `>=1.10`\n\n## Documentation\n\nhttp://godoc.org/github.com/shopspring/decimal\n\n\n## Usage\n\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"github.com/shopspring/decimal\"\n)\n\nfunc main() {\n\tprice, err := decimal.NewFromString(\"136.02\")\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\tquantity := decimal.NewFromInt(3)\n\n\tfee, _ := decimal.NewFromString(\".035\")\n\ttaxRate, _ := decimal.NewFromString(\".08875\")\n\n\tsubtotal := price.Mul(quantity)\n\n\tpreTax := subtotal.Mul(fee.Add(decimal.NewFromFloat(1)))\n\n\ttotal := preTax.Mul(taxRate.Add(decimal.NewFromFloat(1)))\n\n\tfmt.Println(\"Subtotal:\", subtotal)                      // Subtotal: 408.06\n\tfmt.Println(\"Pre-tax:\", preTax)                         // Pre-tax: 422.3421\n\tfmt.Println(\"Taxes:\", total.Sub(preTax))                // Taxes: 37.482861375\n\tfmt.Println(\"Total:\", total)                            // Total: 459.824961375\n\tfmt.Println(\"Tax rate:\", total.Sub(preTax).Div(preTax)) // Tax rate: 0.08875\n}\n```\n\n## Alternative libraries\n\nWhen working with decimal numbers, you might face problems this library is not perfectly suited for. \nFortunately, thanks to the wonderful community we have a dozen other libraries that you can choose from.  \nExplore other alternatives to find the one that best fits your needs :)  \n\n* [cockroachdb/apd](https://github.com/cockroachdb/apd) - arbitrary precision, mutable and rich API similar to `big.Int`, more performant than this library \n* [alpacahq/alpacadecimal](https://github.com/alpacahq/alpacadecimal) - high performance, low precision (12 digits), fully compatible API with this library \n* [govalues/decimal](https://github.com/govalues/decimal) - high performance, zero-allocation, low precision (19 digits)\n* [greatcloak/decimal](https://github.com/greatcloak/decimal) - fork focusing on billing and e-commerce web application related use cases, includes out-of-the-box BSON marshaling support\n\n## FAQ\n\n#### Why don't you just use float64?\n\nBecause float64 (or any binary floating point type, actually) can't represent\nnumbers such as `0.1` exactly.\n\nConsider this code: http://play.golang.org/p/TQBd4yJe6B You might expect that\nit prints out `10`, but it actually prints `9.999999999999831`. Over time,\nthese small errors can really add up!\n\n#### Why don't you just use big.Rat?\n\nbig.Rat is fine for representing rational numbers, but Decimal is better for\nrepresenting money. Why? Here's a (contrived) example:\n\nLet's say you use big.Rat, and you have two numbers, x and y, both\nrepresenting 1/3, and you have `z = 1 - x - y = 1/3`. If you print each one\nout, the string output has to stop somewhere (let's say it stops at 3 decimal\ndigits, for simplicity), so you'll get 0.333, 0.333, and 0.333. But where did\nthe other 0.001 go?\n\nHere's the above example as code: http://play.golang.org/p/lCZZs0w9KE\n\nWith Decimal, the strings being printed out represent the number exactly. So,\nif you have `x = y = 1/3` (with precision 3), they will actually be equal to\n0.333, and when you do `z = 1 - x - y`, `z` will be equal to .334. No money is\nunaccounted for!\n\nYou still have to be careful. If you want to split a number `N` 3 ways, you\ncan't just send `N/3` to three different people. You have to pick one to send\n`N - (2/3*N)` to. That person will receive the fraction of a penny remainder.\n\nBut, it is much easier to be careful with Decimal than with big.Rat.\n\n#### Why isn't the API similar to big.Int's?\n\nbig.Int's API is built to reduce the number of memory allocations for maximal\nperformance. This makes sense for its use-case, but the trade-off is that the\nAPI is awkward and easy to misuse.\n\nFor example, to add two big.Ints, you do: `z := new(big.Int).Add(x, y)`. A\ndeveloper unfamiliar with this API might try to do `z := a.Add(a, b)`. This\nmodifies `a` and sets `z` as an alias for `a`, which they might not expect. It\nalso modifies any other aliases to `a`.\n\nHere's an example of the subtle bugs you can introduce with big.Int's API:\nhttps://play.golang.org/p/x2R_78pa8r\n\nIn contrast, it's difficult to make such mistakes with decimal. Decimals\nbehave like other go numbers types: even though `a = b` will not deep copy\n`b` into `a`, it is impossible to modify a Decimal, since all Decimal methods\nreturn new Decimals and do not modify the originals. The downside is that\nthis causes extra allocations, so Decimal is less performant.  My assumption\nis that if you're using Decimals, you probably care more about correctness\nthan performance.\n\n## License\n\nThe MIT License (MIT)\n\nThis is a heavily modified fork of [fpd.Decimal](https://github.com/oguzbilgic/fpd), which was also released under the MIT License.\n"
        },
        {
          "name": "const.go",
          "type": "blob",
          "size": 4.0087890625,
          "content": "package decimal\n\nimport (\n\t\"strings\"\n)\n\nconst (\n\tstrLn10 = \"2.302585092994045684017991454684364207601101488628772976033327900967572609677352480235997205089598298341967784042286248633409525465082806756666287369098781689482907208325554680843799894826233198528393505308965377732628846163366222287698219886746543667474404243274365155048934314939391479619404400222105101714174800368808401264708068556774321622835522011480466371565912137345074785694768346361679210180644507064800027750268491674655058685693567342067058113642922455440575892572420824131469568901675894025677631135691929203337658714166023010570308963457207544037084746994016826928280848118428931484852494864487192780967627127577539702766860595249671667418348570442250719796500471495105049221477656763693866297697952211071826454973477266242570942932258279850258550978526538320760672631716430950599508780752371033310119785754733154142180842754386359177811705430982748238504564801909561029929182431823752535770975053956518769751037497088869218020518933950723853920514463419726528728696511086257149219884997874887377134568620916705849807828059751193854445009978131146915934666241071846692310107598438319191292230792503747298650929009880391941702654416816335727555703151596113564846546190897042819763365836983716328982174407366009162177850541779276367731145041782137660111010731042397832521894898817597921798666394319523936855916447118246753245630912528778330963604262982153040874560927760726641354787576616262926568298704957954913954918049209069438580790032763017941503117866862092408537949861264933479354871737451675809537088281067452440105892444976479686075120275724181874989395971643105518848195288330746699317814634930000321200327765654130472621883970596794457943468343218395304414844803701305753674262153675579814770458031413637793236291560128185336498466942261465206459942072917119370602444929358037007718981097362533224548366988505528285966192805098447175198503666680874970496982273220244823343097169111136813588418696549323714996941979687803008850408979618598756579894836445212043698216415292987811742973332588607915912510967187510929248475023930572665446276200923068791518135803477701295593646298412366497023355174586195564772461857717369368404676577047874319780573853271810933883496338813069945569399346101090745616033312247949360455361849123333063704751724871276379140924398331810164737823379692265637682071706935846394531616949411701841938119405416449466111274712819705817783293841742231409930022911502362192186723337268385688273533371925103412930705632544426611429765388301822384091026198582888433587455960453004548370789052578473166283701953392231047527564998119228742789713715713228319641003422124210082180679525276689858180956119208391760721080919923461516952599099473782780648128058792731993893453415320185969711021407542282796298237068941764740642225757212455392526179373652434440560595336591539160312524480149313234572453879524389036839236450507881731359711238145323701508413491122324390927681724749607955799151363982881058285740538000653371655553014196332241918087621018204919492651483892\"\n)\n\nvar (\n\tln10 = newConstApproximation(strLn10)\n)\n\ntype constApproximation struct {\n\texact          Decimal\n\tapproximations []Decimal\n}\n\nfunc newConstApproximation(value string) constApproximation {\n\tparts := strings.Split(value, \".\")\n\tcoeff, fractional := parts[0], parts[1]\n\n\tcoeffLen := len(coeff)\n\tmaxPrecision := len(fractional)\n\n\tvar approximations []Decimal\n\tfor p := 1; p < maxPrecision; p *= 2 {\n\t\tr := RequireFromString(value[:coeffLen+p])\n\t\tapproximations = append(approximations, r)\n\t}\n\n\treturn constApproximation{\n\t\tRequireFromString(value),\n\t\tapproximations,\n\t}\n}\n\n// Returns the smallest approximation available that's at least as precise\n// as the passed precision (places after decimal point), i.e. Floor[ log2(precision) ] + 1\nfunc (c constApproximation) withPrecision(precision int32) Decimal {\n\ti := 0\n\n\tif precision >= 1 {\n\t\ti++\n\t}\n\n\tfor precision >= 16 {\n\t\tprecision /= 16\n\t\ti += 4\n\t}\n\n\tfor precision >= 2 {\n\t\tprecision /= 2\n\t\ti++\n\t}\n\n\tif i >= len(c.approximations) {\n\t\treturn c.exact\n\t}\n\n\treturn c.approximations[i]\n}\n"
        },
        {
          "name": "const_test.go",
          "type": "blob",
          "size": 1.181640625,
          "content": "package decimal\n\nimport \"testing\"\n\nfunc TestConstApproximation(t *testing.T) {\n\tfor _, testCase := range []struct {\n\t\tConst                 string\n\t\tPrecision             int32\n\t\tExpectedApproximation string\n\t}{\n\t\t{\"2.3025850929940456840179914546\", 0, \"2\"},\n\t\t{\"2.3025850929940456840179914546\", 1, \"2.3\"},\n\t\t{\"2.3025850929940456840179914546\", 3, \"2.302\"},\n\t\t{\"2.3025850929940456840179914546\", 5, \"2.302585\"},\n\t\t{\"2.3025850929940456840179914546\", 10, \"2.302585092994045\"},\n\t\t{\"2.3025850929940456840179914546\", 100, \"2.3025850929940456840179914546\"},\n\t\t{\"2.3025850929940456840179914546\", -1, \"2\"},\n\t\t{\"2.3025850929940456840179914546\", -5, \"2\"},\n\t\t{\"3.14159265359\", 0, \"3\"},\n\t\t{\"3.14159265359\", 1, \"3.1\"},\n\t\t{\"3.14159265359\", 2, \"3.141\"},\n\t\t{\"3.14159265359\", 4, \"3.1415926\"},\n\t\t{\"3.14159265359\", 13, \"3.14159265359\"},\n\t} {\n\t\tca := newConstApproximation(testCase.Const)\n\t\texpected, _ := NewFromString(testCase.ExpectedApproximation)\n\n\t\tapproximation := ca.withPrecision(testCase.Precision)\n\n\t\tif approximation.Cmp(expected) != 0 {\n\t\t\tt.Errorf(\"expected approximation %s, got %s - for const with %s precision %d\", testCase.ExpectedApproximation, approximation.String(), testCase.Const, testCase.Precision)\n\t\t}\n\t}\n}\n"
        },
        {
          "name": "decimal-go.go",
          "type": "blob",
          "size": 11.0341796875,
          "content": "// Copyright 2009 The Go Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\n// Multiprecision decimal numbers.\n// For floating-point formatting only; not general purpose.\n// Only operations are assign and (binary) left/right shift.\n// Can do binary floating point in multiprecision decimal precisely\n// because 2 divides 10; cannot do decimal floating point\n// in multiprecision binary precisely.\n\npackage decimal\n\ntype decimal struct {\n\td     [800]byte // digits, big-endian representation\n\tnd    int       // number of digits used\n\tdp    int       // decimal point\n\tneg   bool      // negative flag\n\ttrunc bool      // discarded nonzero digits beyond d[:nd]\n}\n\nfunc (a *decimal) String() string {\n\tn := 10 + a.nd\n\tif a.dp > 0 {\n\t\tn += a.dp\n\t}\n\tif a.dp < 0 {\n\t\tn += -a.dp\n\t}\n\n\tbuf := make([]byte, n)\n\tw := 0\n\tswitch {\n\tcase a.nd == 0:\n\t\treturn \"0\"\n\n\tcase a.dp <= 0:\n\t\t// zeros fill space between decimal point and digits\n\t\tbuf[w] = '0'\n\t\tw++\n\t\tbuf[w] = '.'\n\t\tw++\n\t\tw += digitZero(buf[w : w+-a.dp])\n\t\tw += copy(buf[w:], a.d[0:a.nd])\n\n\tcase a.dp < a.nd:\n\t\t// decimal point in middle of digits\n\t\tw += copy(buf[w:], a.d[0:a.dp])\n\t\tbuf[w] = '.'\n\t\tw++\n\t\tw += copy(buf[w:], a.d[a.dp:a.nd])\n\n\tdefault:\n\t\t// zeros fill space between digits and decimal point\n\t\tw += copy(buf[w:], a.d[0:a.nd])\n\t\tw += digitZero(buf[w : w+a.dp-a.nd])\n\t}\n\treturn string(buf[0:w])\n}\n\nfunc digitZero(dst []byte) int {\n\tfor i := range dst {\n\t\tdst[i] = '0'\n\t}\n\treturn len(dst)\n}\n\n// trim trailing zeros from number.\n// (They are meaningless; the decimal point is tracked\n// independent of the number of digits.)\nfunc trim(a *decimal) {\n\tfor a.nd > 0 && a.d[a.nd-1] == '0' {\n\t\ta.nd--\n\t}\n\tif a.nd == 0 {\n\t\ta.dp = 0\n\t}\n}\n\n// Assign v to a.\nfunc (a *decimal) Assign(v uint64) {\n\tvar buf [24]byte\n\n\t// Write reversed decimal in buf.\n\tn := 0\n\tfor v > 0 {\n\t\tv1 := v / 10\n\t\tv -= 10 * v1\n\t\tbuf[n] = byte(v + '0')\n\t\tn++\n\t\tv = v1\n\t}\n\n\t// Reverse again to produce forward decimal in a.d.\n\ta.nd = 0\n\tfor n--; n >= 0; n-- {\n\t\ta.d[a.nd] = buf[n]\n\t\ta.nd++\n\t}\n\ta.dp = a.nd\n\ttrim(a)\n}\n\n// Maximum shift that we can do in one pass without overflow.\n// A uint has 32 or 64 bits, and we have to be able to accommodate 9<<k.\nconst uintSize = 32 << (^uint(0) >> 63)\nconst maxShift = uintSize - 4\n\n// Binary shift right (/ 2) by k bits.  k <= maxShift to avoid overflow.\nfunc rightShift(a *decimal, k uint) {\n\tr := 0 // read pointer\n\tw := 0 // write pointer\n\n\t// Pick up enough leading digits to cover first shift.\n\tvar n uint\n\tfor ; n>>k == 0; r++ {\n\t\tif r >= a.nd {\n\t\t\tif n == 0 {\n\t\t\t\t// a == 0; shouldn't get here, but handle anyway.\n\t\t\t\ta.nd = 0\n\t\t\t\treturn\n\t\t\t}\n\t\t\tfor n>>k == 0 {\n\t\t\t\tn = n * 10\n\t\t\t\tr++\n\t\t\t}\n\t\t\tbreak\n\t\t}\n\t\tc := uint(a.d[r])\n\t\tn = n*10 + c - '0'\n\t}\n\ta.dp -= r - 1\n\n\tvar mask uint = (1 << k) - 1\n\n\t// Pick up a digit, put down a digit.\n\tfor ; r < a.nd; r++ {\n\t\tc := uint(a.d[r])\n\t\tdig := n >> k\n\t\tn &= mask\n\t\ta.d[w] = byte(dig + '0')\n\t\tw++\n\t\tn = n*10 + c - '0'\n\t}\n\n\t// Put down extra digits.\n\tfor n > 0 {\n\t\tdig := n >> k\n\t\tn &= mask\n\t\tif w < len(a.d) {\n\t\t\ta.d[w] = byte(dig + '0')\n\t\t\tw++\n\t\t} else if dig > 0 {\n\t\t\ta.trunc = true\n\t\t}\n\t\tn = n * 10\n\t}\n\n\ta.nd = w\n\ttrim(a)\n}\n\n// Cheat sheet for left shift: table indexed by shift count giving\n// number of new digits that will be introduced by that shift.\n//\n// For example, leftcheats[4] = {2, \"625\"}.  That means that\n// if we are shifting by 4 (multiplying by 16), it will add 2 digits\n// when the string prefix is \"625\" through \"999\", and one fewer digit\n// if the string prefix is \"000\" through \"624\".\n//\n// Credit for this trick goes to Ken.\n\ntype leftCheat struct {\n\tdelta  int    // number of new digits\n\tcutoff string // minus one digit if original < a.\n}\n\nvar leftcheats = []leftCheat{\n\t// Leading digits of 1/2^i = 5^i.\n\t// 5^23 is not an exact 64-bit floating point number,\n\t// so have to use bc for the math.\n\t// Go up to 60 to be large enough for 32bit and 64bit platforms.\n\t/*\n\t\tseq 60 | sed 's/^/5^/' | bc |\n\t\tawk 'BEGIN{ print \"\\t{ 0, \\\"\\\" },\" }\n\t\t{\n\t\t\tlog2 = log(2)/log(10)\n\t\t\tprintf(\"\\t{ %d, \\\"%s\\\" },\\t// * %d\\n\",\n\t\t\t\tint(log2*NR+1), $0, 2**NR)\n\t\t}'\n\t*/\n\t{0, \"\"},\n\t{1, \"5\"},                                           // * 2\n\t{1, \"25\"},                                          // * 4\n\t{1, \"125\"},                                         // * 8\n\t{2, \"625\"},                                         // * 16\n\t{2, \"3125\"},                                        // * 32\n\t{2, \"15625\"},                                       // * 64\n\t{3, \"78125\"},                                       // * 128\n\t{3, \"390625\"},                                      // * 256\n\t{3, \"1953125\"},                                     // * 512\n\t{4, \"9765625\"},                                     // * 1024\n\t{4, \"48828125\"},                                    // * 2048\n\t{4, \"244140625\"},                                   // * 4096\n\t{4, \"1220703125\"},                                  // * 8192\n\t{5, \"6103515625\"},                                  // * 16384\n\t{5, \"30517578125\"},                                 // * 32768\n\t{5, \"152587890625\"},                                // * 65536\n\t{6, \"762939453125\"},                                // * 131072\n\t{6, \"3814697265625\"},                               // * 262144\n\t{6, \"19073486328125\"},                              // * 524288\n\t{7, \"95367431640625\"},                              // * 1048576\n\t{7, \"476837158203125\"},                             // * 2097152\n\t{7, \"2384185791015625\"},                            // * 4194304\n\t{7, \"11920928955078125\"},                           // * 8388608\n\t{8, \"59604644775390625\"},                           // * 16777216\n\t{8, \"298023223876953125\"},                          // * 33554432\n\t{8, \"1490116119384765625\"},                         // * 67108864\n\t{9, \"7450580596923828125\"},                         // * 134217728\n\t{9, \"37252902984619140625\"},                        // * 268435456\n\t{9, \"186264514923095703125\"},                       // * 536870912\n\t{10, \"931322574615478515625\"},                      // * 1073741824\n\t{10, \"4656612873077392578125\"},                     // * 2147483648\n\t{10, \"23283064365386962890625\"},                    // * 4294967296\n\t{10, \"116415321826934814453125\"},                   // * 8589934592\n\t{11, \"582076609134674072265625\"},                   // * 17179869184\n\t{11, \"2910383045673370361328125\"},                  // * 34359738368\n\t{11, \"14551915228366851806640625\"},                 // * 68719476736\n\t{12, \"72759576141834259033203125\"},                 // * 137438953472\n\t{12, \"363797880709171295166015625\"},                // * 274877906944\n\t{12, \"1818989403545856475830078125\"},               // * 549755813888\n\t{13, \"9094947017729282379150390625\"},               // * 1099511627776\n\t{13, \"45474735088646411895751953125\"},              // * 2199023255552\n\t{13, \"227373675443232059478759765625\"},             // * 4398046511104\n\t{13, \"1136868377216160297393798828125\"},            // * 8796093022208\n\t{14, \"5684341886080801486968994140625\"},            // * 17592186044416\n\t{14, \"28421709430404007434844970703125\"},           // * 35184372088832\n\t{14, \"142108547152020037174224853515625\"},          // * 70368744177664\n\t{15, \"710542735760100185871124267578125\"},          // * 140737488355328\n\t{15, \"3552713678800500929355621337890625\"},         // * 281474976710656\n\t{15, \"17763568394002504646778106689453125\"},        // * 562949953421312\n\t{16, \"88817841970012523233890533447265625\"},        // * 1125899906842624\n\t{16, \"444089209850062616169452667236328125\"},       // * 2251799813685248\n\t{16, \"2220446049250313080847263336181640625\"},      // * 4503599627370496\n\t{16, \"11102230246251565404236316680908203125\"},     // * 9007199254740992\n\t{17, \"55511151231257827021181583404541015625\"},     // * 18014398509481984\n\t{17, \"277555756156289135105907917022705078125\"},    // * 36028797018963968\n\t{17, \"1387778780781445675529539585113525390625\"},   // * 72057594037927936\n\t{18, \"6938893903907228377647697925567626953125\"},   // * 144115188075855872\n\t{18, \"34694469519536141888238489627838134765625\"},  // * 288230376151711744\n\t{18, \"173472347597680709441192448139190673828125\"}, // * 576460752303423488\n\t{19, \"867361737988403547205962240695953369140625\"}, // * 1152921504606846976\n}\n\n// Is the leading prefix of b lexicographically less than s?\nfunc prefixIsLessThan(b []byte, s string) bool {\n\tfor i := 0; i < len(s); i++ {\n\t\tif i >= len(b) {\n\t\t\treturn true\n\t\t}\n\t\tif b[i] != s[i] {\n\t\t\treturn b[i] < s[i]\n\t\t}\n\t}\n\treturn false\n}\n\n// Binary shift left (* 2) by k bits.  k <= maxShift to avoid overflow.\nfunc leftShift(a *decimal, k uint) {\n\tdelta := leftcheats[k].delta\n\tif prefixIsLessThan(a.d[0:a.nd], leftcheats[k].cutoff) {\n\t\tdelta--\n\t}\n\n\tr := a.nd         // read index\n\tw := a.nd + delta // write index\n\n\t// Pick up a digit, put down a digit.\n\tvar n uint\n\tfor r--; r >= 0; r-- {\n\t\tn += (uint(a.d[r]) - '0') << k\n\t\tquo := n / 10\n\t\trem := n - 10*quo\n\t\tw--\n\t\tif w < len(a.d) {\n\t\t\ta.d[w] = byte(rem + '0')\n\t\t} else if rem != 0 {\n\t\t\ta.trunc = true\n\t\t}\n\t\tn = quo\n\t}\n\n\t// Put down extra digits.\n\tfor n > 0 {\n\t\tquo := n / 10\n\t\trem := n - 10*quo\n\t\tw--\n\t\tif w < len(a.d) {\n\t\t\ta.d[w] = byte(rem + '0')\n\t\t} else if rem != 0 {\n\t\t\ta.trunc = true\n\t\t}\n\t\tn = quo\n\t}\n\n\ta.nd += delta\n\tif a.nd >= len(a.d) {\n\t\ta.nd = len(a.d)\n\t}\n\ta.dp += delta\n\ttrim(a)\n}\n\n// Binary shift left (k > 0) or right (k < 0).\nfunc (a *decimal) Shift(k int) {\n\tswitch {\n\tcase a.nd == 0:\n\t\t// nothing to do: a == 0\n\tcase k > 0:\n\t\tfor k > maxShift {\n\t\t\tleftShift(a, maxShift)\n\t\t\tk -= maxShift\n\t\t}\n\t\tleftShift(a, uint(k))\n\tcase k < 0:\n\t\tfor k < -maxShift {\n\t\t\trightShift(a, maxShift)\n\t\t\tk += maxShift\n\t\t}\n\t\trightShift(a, uint(-k))\n\t}\n}\n\n// If we chop a at nd digits, should we round up?\nfunc shouldRoundUp(a *decimal, nd int) bool {\n\tif nd < 0 || nd >= a.nd {\n\t\treturn false\n\t}\n\tif a.d[nd] == '5' && nd+1 == a.nd { // exactly halfway - round to even\n\t\t// if we truncated, a little higher than what's recorded - always round up\n\t\tif a.trunc {\n\t\t\treturn true\n\t\t}\n\t\treturn nd > 0 && (a.d[nd-1]-'0')%2 != 0\n\t}\n\t// not halfway - digit tells all\n\treturn a.d[nd] >= '5'\n}\n\n// Round a to nd digits (or fewer).\n// If nd is zero, it means we're rounding\n// just to the left of the digits, as in\n// 0.09 -> 0.1.\nfunc (a *decimal) Round(nd int) {\n\tif nd < 0 || nd >= a.nd {\n\t\treturn\n\t}\n\tif shouldRoundUp(a, nd) {\n\t\ta.RoundUp(nd)\n\t} else {\n\t\ta.RoundDown(nd)\n\t}\n}\n\n// Round a down to nd digits (or fewer).\nfunc (a *decimal) RoundDown(nd int) {\n\tif nd < 0 || nd >= a.nd {\n\t\treturn\n\t}\n\ta.nd = nd\n\ttrim(a)\n}\n\n// Round a up to nd digits (or fewer).\nfunc (a *decimal) RoundUp(nd int) {\n\tif nd < 0 || nd >= a.nd {\n\t\treturn\n\t}\n\n\t// round up\n\tfor i := nd - 1; i >= 0; i-- {\n\t\tc := a.d[i]\n\t\tif c < '9' { // can stop after this digit\n\t\t\ta.d[i]++\n\t\t\ta.nd = i + 1\n\t\t\treturn\n\t\t}\n\t}\n\n\t// Number is all 9s.\n\t// Change to single 1 with adjusted decimal point.\n\ta.d[0] = '1'\n\ta.nd = 1\n\ta.dp++\n}\n\n// Extract integer part, rounded appropriately.\n// No guarantees about overflow.\nfunc (a *decimal) RoundedInteger() uint64 {\n\tif a.dp > 20 {\n\t\treturn 0xFFFFFFFFFFFFFFFF\n\t}\n\tvar i int\n\tn := uint64(0)\n\tfor i = 0; i < a.dp && i < a.nd; i++ {\n\t\tn = n*10 + uint64(a.d[i]-'0')\n\t}\n\tfor ; i < a.dp; i++ {\n\t\tn *= 10\n\t}\n\tif shouldRoundUp(a, a.dp) {\n\t\tn++\n\t}\n\treturn n\n}\n"
        },
        {
          "name": "decimal.go",
          "type": "blob",
          "size": 62.9140625,
          "content": "// Package decimal implements an arbitrary precision fixed-point decimal.\n//\n// The zero-value of a Decimal is 0, as you would expect.\n//\n// The best way to create a new Decimal is to use decimal.NewFromString, ex:\n//\n//\tn, err := decimal.NewFromString(\"-123.4567\")\n//\tn.String() // output: \"-123.4567\"\n//\n// To use Decimal as part of a struct:\n//\n//\ttype StructName struct {\n//\t    Number Decimal\n//\t}\n//\n// Note: This can \"only\" represent numbers with a maximum of 2^31 digits after the decimal point.\npackage decimal\n\nimport (\n\t\"database/sql/driver\"\n\t\"encoding/binary\"\n\t\"fmt\"\n\t\"math\"\n\t\"math/big\"\n\t\"regexp\"\n\t\"strconv\"\n\t\"strings\"\n)\n\n// DivisionPrecision is the number of decimal places in the result when it\n// doesn't divide exactly.\n//\n// Example:\n//\n//\td1 := decimal.NewFromFloat(2).Div(decimal.NewFromFloat(3))\n//\td1.String() // output: \"0.6666666666666667\"\n//\td2 := decimal.NewFromFloat(2).Div(decimal.NewFromFloat(30000))\n//\td2.String() // output: \"0.0000666666666667\"\n//\td3 := decimal.NewFromFloat(20000).Div(decimal.NewFromFloat(3))\n//\td3.String() // output: \"6666.6666666666666667\"\n//\tdecimal.DivisionPrecision = 3\n//\td4 := decimal.NewFromFloat(2).Div(decimal.NewFromFloat(3))\n//\td4.String() // output: \"0.667\"\nvar DivisionPrecision = 16\n\n// PowPrecisionNegativeExponent specifies the maximum precision of the result (digits after decimal point)\n// when calculating decimal power. Only used for cases where the exponent is a negative number.\n// This constant applies to Pow, PowInt32 and PowBigInt methods, PowWithPrecision method is not constrained by it.\n//\n// Example:\n//\n//\td1, err := decimal.NewFromFloat(15.2).PowInt32(-2)\n//\td1.String() // output: \"0.0043282548476454\"\n//\n//\tdecimal.PowPrecisionNegativeExponent = 24\n//\td2, err := decimal.NewFromFloat(15.2).PowInt32(-2)\n//\td2.String() // output: \"0.004328254847645429362881\"\nvar PowPrecisionNegativeExponent = 16\n\n// MarshalJSONWithoutQuotes should be set to true if you want the decimal to\n// be JSON marshaled as a number, instead of as a string.\n// WARNING: this is dangerous for decimals with many digits, since many JSON\n// unmarshallers (ex: Javascript's) will unmarshal JSON numbers to IEEE 754\n// double-precision floating point numbers, which means you can potentially\n// silently lose precision.\nvar MarshalJSONWithoutQuotes = false\n\n// ExpMaxIterations specifies the maximum number of iterations needed to calculate\n// precise natural exponent value using ExpHullAbrham method.\nvar ExpMaxIterations = 1000\n\n// Zero constant, to make computations faster.\n// Zero should never be compared with == or != directly, please use decimal.Equal or decimal.Cmp instead.\nvar Zero = New(0, 1)\n\nvar zeroInt = big.NewInt(0)\nvar oneInt = big.NewInt(1)\nvar twoInt = big.NewInt(2)\nvar fourInt = big.NewInt(4)\nvar fiveInt = big.NewInt(5)\nvar tenInt = big.NewInt(10)\nvar twentyInt = big.NewInt(20)\n\nvar factorials = []Decimal{New(1, 0)}\n\n// Decimal represents a fixed-point decimal. It is immutable.\n// number = value * 10 ^ exp\ntype Decimal struct {\n\tvalue *big.Int\n\n\t// NOTE(vadim): this must be an int32, because we cast it to float64 during\n\t// calculations. If exp is 64 bit, we might lose precision.\n\t// If we cared about being able to represent every possible decimal, we\n\t// could make exp a *big.Int but it would hurt performance and numbers\n\t// like that are unrealistic.\n\texp int32\n}\n\n// New returns a new fixed-point decimal, value * 10 ^ exp.\nfunc New(value int64, exp int32) Decimal {\n\treturn Decimal{\n\t\tvalue: big.NewInt(value),\n\t\texp:   exp,\n\t}\n}\n\n// NewFromInt converts an int64 to Decimal.\n//\n// Example:\n//\n//\tNewFromInt(123).String() // output: \"123\"\n//\tNewFromInt(-10).String() // output: \"-10\"\nfunc NewFromInt(value int64) Decimal {\n\treturn Decimal{\n\t\tvalue: big.NewInt(value),\n\t\texp:   0,\n\t}\n}\n\n// NewFromInt32 converts an int32 to Decimal.\n//\n// Example:\n//\n//\tNewFromInt(123).String() // output: \"123\"\n//\tNewFromInt(-10).String() // output: \"-10\"\nfunc NewFromInt32(value int32) Decimal {\n\treturn Decimal{\n\t\tvalue: big.NewInt(int64(value)),\n\t\texp:   0,\n\t}\n}\n\n// NewFromUint64 converts an uint64 to Decimal.\n//\n// Example:\n//\n//\tNewFromUint64(123).String() // output: \"123\"\nfunc NewFromUint64(value uint64) Decimal {\n\treturn Decimal{\n\t\tvalue: new(big.Int).SetUint64(value),\n\t\texp:   0,\n\t}\n}\n\n// NewFromBigInt returns a new Decimal from a big.Int, value * 10 ^ exp\nfunc NewFromBigInt(value *big.Int, exp int32) Decimal {\n\treturn Decimal{\n\t\tvalue: new(big.Int).Set(value),\n\t\texp:   exp,\n\t}\n}\n\n// NewFromBigRat returns a new Decimal from a big.Rat. The numerator and\n// denominator are divided and rounded to the given precision.\n//\n// Example:\n//\n//\td1 := NewFromBigRat(big.NewRat(0, 1), 0)    // output: \"0\"\n//\td2 := NewFromBigRat(big.NewRat(4, 5), 1)    // output: \"0.8\"\n//\td3 := NewFromBigRat(big.NewRat(1000, 3), 3) // output: \"333.333\"\n//\td4 := NewFromBigRat(big.NewRat(2, 7), 4)    // output: \"0.2857\"\nfunc NewFromBigRat(value *big.Rat, precision int32) Decimal {\n\treturn Decimal{\n\t\tvalue: new(big.Int).Set(value.Num()),\n\t\texp:   0,\n\t}.DivRound(Decimal{\n\t\tvalue: new(big.Int).Set(value.Denom()),\n\t\texp:   0,\n\t}, precision)\n}\n\n// NewFromString returns a new Decimal from a string representation.\n// Trailing zeroes are not trimmed.\n//\n// Example:\n//\n//\td, err := NewFromString(\"-123.45\")\n//\td2, err := NewFromString(\".0001\")\n//\td3, err := NewFromString(\"1.47000\")\nfunc NewFromString(value string) (Decimal, error) {\n\toriginalInput := value\n\tvar intString string\n\tvar exp int64\n\n\t// Check if number is using scientific notation\n\teIndex := strings.IndexAny(value, \"Ee\")\n\tif eIndex != -1 {\n\t\texpInt, err := strconv.ParseInt(value[eIndex+1:], 10, 32)\n\t\tif err != nil {\n\t\t\tif e, ok := err.(*strconv.NumError); ok && e.Err == strconv.ErrRange {\n\t\t\t\treturn Decimal{}, fmt.Errorf(\"can't convert %s to decimal: fractional part too long\", value)\n\t\t\t}\n\t\t\treturn Decimal{}, fmt.Errorf(\"can't convert %s to decimal: exponent is not numeric\", value)\n\t\t}\n\t\tvalue = value[:eIndex]\n\t\texp = expInt\n\t}\n\n\tpIndex := -1\n\tvLen := len(value)\n\tfor i := 0; i < vLen; i++ {\n\t\tif value[i] == '.' {\n\t\t\tif pIndex > -1 {\n\t\t\t\treturn Decimal{}, fmt.Errorf(\"can't convert %s to decimal: too many .s\", value)\n\t\t\t}\n\t\t\tpIndex = i\n\t\t}\n\t}\n\n\tif pIndex == -1 {\n\t\t// There is no decimal point, we can just parse the original string as\n\t\t// an int\n\t\tintString = value\n\t} else {\n\t\tif pIndex+1 < vLen {\n\t\t\tintString = value[:pIndex] + value[pIndex+1:]\n\t\t} else {\n\t\t\tintString = value[:pIndex]\n\t\t}\n\t\texpInt := -len(value[pIndex+1:])\n\t\texp += int64(expInt)\n\t}\n\n\tvar dValue *big.Int\n\t// strconv.ParseInt is faster than new(big.Int).SetString so this is just a shortcut for strings we know won't overflow\n\tif len(intString) <= 18 {\n\t\tparsed64, err := strconv.ParseInt(intString, 10, 64)\n\t\tif err != nil {\n\t\t\treturn Decimal{}, fmt.Errorf(\"can't convert %s to decimal\", value)\n\t\t}\n\t\tdValue = big.NewInt(parsed64)\n\t} else {\n\t\tdValue = new(big.Int)\n\t\t_, ok := dValue.SetString(intString, 10)\n\t\tif !ok {\n\t\t\treturn Decimal{}, fmt.Errorf(\"can't convert %s to decimal\", value)\n\t\t}\n\t}\n\n\tif exp < math.MinInt32 || exp > math.MaxInt32 {\n\t\t// NOTE(vadim): I doubt a string could realistically be this long\n\t\treturn Decimal{}, fmt.Errorf(\"can't convert %s to decimal: fractional part too long\", originalInput)\n\t}\n\n\treturn Decimal{\n\t\tvalue: dValue,\n\t\texp:   int32(exp),\n\t}, nil\n}\n\n// NewFromFormattedString returns a new Decimal from a formatted string representation.\n// The second argument - replRegexp, is a regular expression that is used to find characters that should be\n// removed from given decimal string representation. All matched characters will be replaced with an empty string.\n//\n// Example:\n//\n//\tr := regexp.MustCompile(\"[$,]\")\n//\td1, err := NewFromFormattedString(\"$5,125.99\", r)\n//\n//\tr2 := regexp.MustCompile(\"[_]\")\n//\td2, err := NewFromFormattedString(\"1_000_000\", r2)\n//\n//\tr3 := regexp.MustCompile(\"[USD\\\\s]\")\n//\td3, err := NewFromFormattedString(\"5000 USD\", r3)\nfunc NewFromFormattedString(value string, replRegexp *regexp.Regexp) (Decimal, error) {\n\tparsedValue := replRegexp.ReplaceAllString(value, \"\")\n\td, err := NewFromString(parsedValue)\n\tif err != nil {\n\t\treturn Decimal{}, err\n\t}\n\treturn d, nil\n}\n\n// RequireFromString returns a new Decimal from a string representation\n// or panics if NewFromString had returned an error.\n//\n// Example:\n//\n//\td := RequireFromString(\"-123.45\")\n//\td2 := RequireFromString(\".0001\")\nfunc RequireFromString(value string) Decimal {\n\tdec, err := NewFromString(value)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\treturn dec\n}\n\n// NewFromFloat converts a float64 to Decimal.\n//\n// The converted number will contain the number of significant digits that can be\n// represented in a float with reliable roundtrip.\n// This is typically 15 digits, but may be more in some cases.\n// See https://www.exploringbinary.com/decimal-precision-of-binary-floating-point-numbers/ for more information.\n//\n// For slightly faster conversion, use NewFromFloatWithExponent where you can specify the precision in absolute terms.\n//\n// NOTE: this will panic on NaN, +/-inf\nfunc NewFromFloat(value float64) Decimal {\n\tif value == 0 {\n\t\treturn New(0, 0)\n\t}\n\treturn newFromFloat(value, math.Float64bits(value), &float64info)\n}\n\n// NewFromFloat32 converts a float32 to Decimal.\n//\n// The converted number will contain the number of significant digits that can be\n// represented in a float with reliable roundtrip.\n// This is typically 6-8 digits depending on the input.\n// See https://www.exploringbinary.com/decimal-precision-of-binary-floating-point-numbers/ for more information.\n//\n// For slightly faster conversion, use NewFromFloatWithExponent where you can specify the precision in absolute terms.\n//\n// NOTE: this will panic on NaN, +/-inf\nfunc NewFromFloat32(value float32) Decimal {\n\tif value == 0 {\n\t\treturn New(0, 0)\n\t}\n\t// XOR is workaround for https://github.com/golang/go/issues/26285\n\ta := math.Float32bits(value) ^ 0x80808080\n\treturn newFromFloat(float64(value), uint64(a)^0x80808080, &float32info)\n}\n\nfunc newFromFloat(val float64, bits uint64, flt *floatInfo) Decimal {\n\tif math.IsNaN(val) || math.IsInf(val, 0) {\n\t\tpanic(fmt.Sprintf(\"Cannot create a Decimal from %v\", val))\n\t}\n\texp := int(bits>>flt.mantbits) & (1<<flt.expbits - 1)\n\tmant := bits & (uint64(1)<<flt.mantbits - 1)\n\n\tswitch exp {\n\tcase 0:\n\t\t// denormalized\n\t\texp++\n\n\tdefault:\n\t\t// add implicit top bit\n\t\tmant |= uint64(1) << flt.mantbits\n\t}\n\texp += flt.bias\n\n\tvar d decimal\n\td.Assign(mant)\n\td.Shift(exp - int(flt.mantbits))\n\td.neg = bits>>(flt.expbits+flt.mantbits) != 0\n\n\troundShortest(&d, mant, exp, flt)\n\t// If less than 19 digits, we can do calculation in an int64.\n\tif d.nd < 19 {\n\t\ttmp := int64(0)\n\t\tm := int64(1)\n\t\tfor i := d.nd - 1; i >= 0; i-- {\n\t\t\ttmp += m * int64(d.d[i]-'0')\n\t\t\tm *= 10\n\t\t}\n\t\tif d.neg {\n\t\t\ttmp *= -1\n\t\t}\n\t\treturn Decimal{value: big.NewInt(tmp), exp: int32(d.dp) - int32(d.nd)}\n\t}\n\tdValue := new(big.Int)\n\tdValue, ok := dValue.SetString(string(d.d[:d.nd]), 10)\n\tif ok {\n\t\treturn Decimal{value: dValue, exp: int32(d.dp) - int32(d.nd)}\n\t}\n\n\treturn NewFromFloatWithExponent(val, int32(d.dp)-int32(d.nd))\n}\n\n// NewFromFloatWithExponent converts a float64 to Decimal, with an arbitrary\n// number of fractional digits.\n//\n// Example:\n//\n//\tNewFromFloatWithExponent(123.456, -2).String() // output: \"123.46\"\nfunc NewFromFloatWithExponent(value float64, exp int32) Decimal {\n\tif math.IsNaN(value) || math.IsInf(value, 0) {\n\t\tpanic(fmt.Sprintf(\"Cannot create a Decimal from %v\", value))\n\t}\n\n\tbits := math.Float64bits(value)\n\tmant := bits & (1<<52 - 1)\n\texp2 := int32((bits >> 52) & (1<<11 - 1))\n\tsign := bits >> 63\n\n\tif exp2 == 0 {\n\t\t// specials\n\t\tif mant == 0 {\n\t\t\treturn Decimal{}\n\t\t}\n\t\t// subnormal\n\t\texp2++\n\t} else {\n\t\t// normal\n\t\tmant |= 1 << 52\n\t}\n\n\texp2 -= 1023 + 52\n\n\t// normalizing base-2 values\n\tfor mant&1 == 0 {\n\t\tmant = mant >> 1\n\t\texp2++\n\t}\n\n\t// maximum number of fractional base-10 digits to represent 2^N exactly cannot be more than -N if N<0\n\tif exp < 0 && exp < exp2 {\n\t\tif exp2 < 0 {\n\t\t\texp = exp2\n\t\t} else {\n\t\t\texp = 0\n\t\t}\n\t}\n\n\t// representing 10^M * 2^N as 5^M * 2^(M+N)\n\texp2 -= exp\n\n\ttemp := big.NewInt(1)\n\tdMant := big.NewInt(int64(mant))\n\n\t// applying 5^M\n\tif exp > 0 {\n\t\ttemp = temp.SetInt64(int64(exp))\n\t\ttemp = temp.Exp(fiveInt, temp, nil)\n\t} else if exp < 0 {\n\t\ttemp = temp.SetInt64(-int64(exp))\n\t\ttemp = temp.Exp(fiveInt, temp, nil)\n\t\tdMant = dMant.Mul(dMant, temp)\n\t\ttemp = temp.SetUint64(1)\n\t}\n\n\t// applying 2^(M+N)\n\tif exp2 > 0 {\n\t\tdMant = dMant.Lsh(dMant, uint(exp2))\n\t} else if exp2 < 0 {\n\t\ttemp = temp.Lsh(temp, uint(-exp2))\n\t}\n\n\t// rounding and downscaling\n\tif exp > 0 || exp2 < 0 {\n\t\thalfDown := new(big.Int).Rsh(temp, 1)\n\t\tdMant = dMant.Add(dMant, halfDown)\n\t\tdMant = dMant.Quo(dMant, temp)\n\t}\n\n\tif sign == 1 {\n\t\tdMant = dMant.Neg(dMant)\n\t}\n\n\treturn Decimal{\n\t\tvalue: dMant,\n\t\texp:   exp,\n\t}\n}\n\n// Copy returns a copy of decimal with the same value and exponent, but a different pointer to value.\nfunc (d Decimal) Copy() Decimal {\n\td.ensureInitialized()\n\treturn Decimal{\n\t\tvalue: new(big.Int).Set(d.value),\n\t\texp:   d.exp,\n\t}\n}\n\n// rescale returns a rescaled version of the decimal. Returned\n// decimal may be less precise if the given exponent is bigger\n// than the initial exponent of the Decimal.\n// NOTE: this will truncate, NOT round\n//\n// Example:\n//\n//\td := New(12345, -4)\n//\td2 := d.rescale(-1)\n//\td3 := d2.rescale(-4)\n//\tprintln(d1)\n//\tprintln(d2)\n//\tprintln(d3)\n//\n// Output:\n//\n//\t1.2345\n//\t1.2\n//\t1.2000\nfunc (d Decimal) rescale(exp int32) Decimal {\n\td.ensureInitialized()\n\n\tif d.exp == exp {\n\t\treturn Decimal{\n\t\t\tnew(big.Int).Set(d.value),\n\t\t\td.exp,\n\t\t}\n\t}\n\n\t// NOTE(vadim): must convert exps to float64 before - to prevent overflow\n\tdiff := math.Abs(float64(exp) - float64(d.exp))\n\tvalue := new(big.Int).Set(d.value)\n\n\texpScale := new(big.Int).Exp(tenInt, big.NewInt(int64(diff)), nil)\n\tif exp > d.exp {\n\t\tvalue = value.Quo(value, expScale)\n\t} else if exp < d.exp {\n\t\tvalue = value.Mul(value, expScale)\n\t}\n\n\treturn Decimal{\n\t\tvalue: value,\n\t\texp:   exp,\n\t}\n}\n\n// Abs returns the absolute value of the decimal.\nfunc (d Decimal) Abs() Decimal {\n\tif !d.IsNegative() {\n\t\treturn d\n\t}\n\td.ensureInitialized()\n\td2Value := new(big.Int).Abs(d.value)\n\treturn Decimal{\n\t\tvalue: d2Value,\n\t\texp:   d.exp,\n\t}\n}\n\n// Add returns d + d2.\nfunc (d Decimal) Add(d2 Decimal) Decimal {\n\trd, rd2 := RescalePair(d, d2)\n\n\td3Value := new(big.Int).Add(rd.value, rd2.value)\n\treturn Decimal{\n\t\tvalue: d3Value,\n\t\texp:   rd.exp,\n\t}\n}\n\n// Sub returns d - d2.\nfunc (d Decimal) Sub(d2 Decimal) Decimal {\n\trd, rd2 := RescalePair(d, d2)\n\n\td3Value := new(big.Int).Sub(rd.value, rd2.value)\n\treturn Decimal{\n\t\tvalue: d3Value,\n\t\texp:   rd.exp,\n\t}\n}\n\n// Neg returns -d.\nfunc (d Decimal) Neg() Decimal {\n\td.ensureInitialized()\n\tval := new(big.Int).Neg(d.value)\n\treturn Decimal{\n\t\tvalue: val,\n\t\texp:   d.exp,\n\t}\n}\n\n// Mul returns d * d2.\nfunc (d Decimal) Mul(d2 Decimal) Decimal {\n\td.ensureInitialized()\n\td2.ensureInitialized()\n\n\texpInt64 := int64(d.exp) + int64(d2.exp)\n\tif expInt64 > math.MaxInt32 || expInt64 < math.MinInt32 {\n\t\t// NOTE(vadim): better to panic than give incorrect results, as\n\t\t// Decimals are usually used for money\n\t\tpanic(fmt.Sprintf(\"exponent %v overflows an int32!\", expInt64))\n\t}\n\n\td3Value := new(big.Int).Mul(d.value, d2.value)\n\treturn Decimal{\n\t\tvalue: d3Value,\n\t\texp:   int32(expInt64),\n\t}\n}\n\n// Shift shifts the decimal in base 10.\n// It shifts left when shift is positive and right if shift is negative.\n// In simpler terms, the given value for shift is added to the exponent\n// of the decimal.\nfunc (d Decimal) Shift(shift int32) Decimal {\n\td.ensureInitialized()\n\treturn Decimal{\n\t\tvalue: new(big.Int).Set(d.value),\n\t\texp:   d.exp + shift,\n\t}\n}\n\n// Div returns d / d2. If it doesn't divide exactly, the result will have\n// DivisionPrecision digits after the decimal point.\nfunc (d Decimal) Div(d2 Decimal) Decimal {\n\treturn d.DivRound(d2, int32(DivisionPrecision))\n}\n\n// QuoRem does division with remainder\n// d.QuoRem(d2,precision) returns quotient q and remainder r such that\n//\n//\td = d2 * q + r, q an integer multiple of 10^(-precision)\n//\t0 <= r < abs(d2) * 10 ^(-precision) if d>=0\n//\t0 >= r > -abs(d2) * 10 ^(-precision) if d<0\n//\n// Note that precision<0 is allowed as input.\nfunc (d Decimal) QuoRem(d2 Decimal, precision int32) (Decimal, Decimal) {\n\td.ensureInitialized()\n\td2.ensureInitialized()\n\tif d2.value.Sign() == 0 {\n\t\tpanic(\"decimal division by 0\")\n\t}\n\tscale := -precision\n\te := int64(d.exp) - int64(d2.exp) - int64(scale)\n\tif e > math.MaxInt32 || e < math.MinInt32 {\n\t\tpanic(\"overflow in decimal QuoRem\")\n\t}\n\tvar aa, bb, expo big.Int\n\tvar scalerest int32\n\t// d = a 10^ea\n\t// d2 = b 10^eb\n\tif e < 0 {\n\t\taa = *d.value\n\t\texpo.SetInt64(-e)\n\t\tbb.Exp(tenInt, &expo, nil)\n\t\tbb.Mul(d2.value, &bb)\n\t\tscalerest = d.exp\n\t\t// now aa = a\n\t\t//     bb = b 10^(scale + eb - ea)\n\t} else {\n\t\texpo.SetInt64(e)\n\t\taa.Exp(tenInt, &expo, nil)\n\t\taa.Mul(d.value, &aa)\n\t\tbb = *d2.value\n\t\tscalerest = scale + d2.exp\n\t\t// now aa = a ^ (ea - eb - scale)\n\t\t//     bb = b\n\t}\n\tvar q, r big.Int\n\tq.QuoRem(&aa, &bb, &r)\n\tdq := Decimal{value: &q, exp: scale}\n\tdr := Decimal{value: &r, exp: scalerest}\n\treturn dq, dr\n}\n\n// DivRound divides and rounds to a given precision\n// i.e. to an integer multiple of 10^(-precision)\n//\n//\tfor a positive quotient digit 5 is rounded up, away from 0\n//\tif the quotient is negative then digit 5 is rounded down, away from 0\n//\n// Note that precision<0 is allowed as input.\nfunc (d Decimal) DivRound(d2 Decimal, precision int32) Decimal {\n\t// QuoRem already checks initialization\n\tq, r := d.QuoRem(d2, precision)\n\t// the actual rounding decision is based on comparing r*10^precision and d2/2\n\t// instead compare 2 r 10 ^precision and d2\n\tvar rv2 big.Int\n\trv2.Abs(r.value)\n\trv2.Lsh(&rv2, 1)\n\t// now rv2 = abs(r.value) * 2\n\tr2 := Decimal{value: &rv2, exp: r.exp + precision}\n\t// r2 is now 2 * r * 10 ^ precision\n\tvar c = r2.Cmp(d2.Abs())\n\n\tif c < 0 {\n\t\treturn q\n\t}\n\n\tif d.value.Sign()*d2.value.Sign() < 0 {\n\t\treturn q.Sub(New(1, -precision))\n\t}\n\n\treturn q.Add(New(1, -precision))\n}\n\n// Mod returns d % d2.\nfunc (d Decimal) Mod(d2 Decimal) Decimal {\n\t_, r := d.QuoRem(d2, 0)\n\treturn r\n}\n\n// Pow returns d to the power of d2.\n// When exponent is negative the returned decimal will have maximum precision of PowPrecisionNegativeExponent places after decimal point.\n//\n// Pow returns 0 (zero-value of Decimal) instead of error for power operation edge cases, to handle those edge cases use PowWithPrecision\n// Edge cases not handled by Pow:\n//   - 0 ** 0 => undefined value\n//   - 0 ** y, where y < 0 => infinity\n//   - x ** y, where x < 0 and y is non-integer decimal => imaginary value\n//\n// Example:\n//\n//\td1 := decimal.NewFromFloat(4.0)\n//\td2 := decimal.NewFromFloat(4.0)\n//\tres1 := d1.Pow(d2)\n//\tres1.String() // output: \"256\"\n//\n//\td3 := decimal.NewFromFloat(5.0)\n//\td4 := decimal.NewFromFloat(5.73)\n//\tres2 := d3.Pow(d4)\n//\tres2.String() // output: \"10118.08037125\"\nfunc (d Decimal) Pow(d2 Decimal) Decimal {\n\tbaseSign := d.Sign()\n\texpSign := d2.Sign()\n\n\tif baseSign == 0 {\n\t\tif expSign == 0 {\n\t\t\treturn Decimal{}\n\t\t}\n\t\tif expSign == 1 {\n\t\t\treturn Decimal{zeroInt, 0}\n\t\t}\n\t\tif expSign == -1 {\n\t\t\treturn Decimal{}\n\t\t}\n\t}\n\n\tif expSign == 0 {\n\t\treturn Decimal{oneInt, 0}\n\t}\n\n\t// TODO: optimize extraction of fractional part\n\tone := Decimal{oneInt, 0}\n\texpIntPart, expFracPart := d2.QuoRem(one, 0)\n\n\tif baseSign == -1 && !expFracPart.IsZero() {\n\t\treturn Decimal{}\n\t}\n\n\tintPartPow, _ := d.PowBigInt(expIntPart.value)\n\n\t// if exponent is an integer we don't need to calculate d1**frac(d2)\n\tif expFracPart.value.Sign() == 0 {\n\t\treturn intPartPow\n\t}\n\n\t// TODO: optimize NumDigits for more performant precision adjustment\n\tdigitsBase := d.NumDigits()\n\tdigitsExponent := d2.NumDigits()\n\n\tprecision := digitsBase\n\n\tif digitsExponent > precision {\n\t\tprecision += digitsExponent\n\t}\n\n\tprecision += 6\n\n\t// Calculate x ** frac(y), where\n\t// x ** frac(y) = exp(ln(x ** frac(y)) = exp(ln(x) * frac(y))\n\tfracPartPow, err := d.Abs().Ln(-d.exp + int32(precision))\n\tif err != nil {\n\t\treturn Decimal{}\n\t}\n\n\tfracPartPow = fracPartPow.Mul(expFracPart)\n\n\tfracPartPow, err = fracPartPow.ExpTaylor(-d.exp + int32(precision))\n\tif err != nil {\n\t\treturn Decimal{}\n\t}\n\n\t// Join integer and fractional part,\n\t// base ** (expBase + expFrac) = base ** expBase * base ** expFrac\n\tres := intPartPow.Mul(fracPartPow)\n\n\treturn res\n}\n\n// PowWithPrecision returns d to the power of d2.\n// Precision parameter specifies minimum precision of the result (digits after decimal point).\n// Returned decimal is not rounded to 'precision' places after decimal point.\n//\n// PowWithPrecision returns error when:\n//   - 0 ** 0 => undefined value\n//   - 0 ** y, where y < 0 => infinity\n//   - x ** y, where x < 0 and y is non-integer decimal => imaginary value\n//\n// Example:\n//\n//\td1 := decimal.NewFromFloat(4.0)\n//\td2 := decimal.NewFromFloat(4.0)\n//\tres1, err := d1.PowWithPrecision(d2, 2)\n//\tres1.String() // output: \"256\"\n//\n//\td3 := decimal.NewFromFloat(5.0)\n//\td4 := decimal.NewFromFloat(5.73)\n//\tres2, err := d3.PowWithPrecision(d4, 5)\n//\tres2.String() // output: \"10118.080371595015625\"\n//\n//\td5 := decimal.NewFromFloat(-3.0)\n//\td6 := decimal.NewFromFloat(-6.0)\n//\tres3, err := d5.PowWithPrecision(d6, 10)\n//\tres3.String() // output: \"0.0013717421\"\nfunc (d Decimal) PowWithPrecision(d2 Decimal, precision int32) (Decimal, error) {\n\tbaseSign := d.Sign()\n\texpSign := d2.Sign()\n\n\tif baseSign == 0 {\n\t\tif expSign == 0 {\n\t\t\treturn Decimal{}, fmt.Errorf(\"cannot represent undefined value of 0**0\")\n\t\t}\n\t\tif expSign == 1 {\n\t\t\treturn Decimal{zeroInt, 0}, nil\n\t\t}\n\t\tif expSign == -1 {\n\t\t\treturn Decimal{}, fmt.Errorf(\"cannot represent infinity value of 0 ** y, where y < 0\")\n\t\t}\n\t}\n\n\tif expSign == 0 {\n\t\treturn Decimal{oneInt, 0}, nil\n\t}\n\n\t// TODO: optimize extraction of fractional part\n\tone := Decimal{oneInt, 0}\n\texpIntPart, expFracPart := d2.QuoRem(one, 0)\n\n\tif baseSign == -1 && !expFracPart.IsZero() {\n\t\treturn Decimal{}, fmt.Errorf(\"cannot represent imaginary value of x ** y, where x < 0 and y is non-integer decimal\")\n\t}\n\n\tintPartPow, _ := d.powBigIntWithPrecision(expIntPart.value, precision)\n\n\t// if exponent is an integer we don't need to calculate d1**frac(d2)\n\tif expFracPart.value.Sign() == 0 {\n\t\treturn intPartPow, nil\n\t}\n\n\t// TODO: optimize NumDigits for more performant precision adjustment\n\tdigitsBase := d.NumDigits()\n\tdigitsExponent := d2.NumDigits()\n\n\tif int32(digitsBase) > precision {\n\t\tprecision = int32(digitsBase)\n\t}\n\tif int32(digitsExponent) > precision {\n\t\tprecision += int32(digitsExponent)\n\t}\n\t// increase precision by 10 to compensate for errors in further calculations\n\tprecision += 10\n\n\t// Calculate x ** frac(y), where\n\t// x ** frac(y) = exp(ln(x ** frac(y)) = exp(ln(x) * frac(y))\n\tfracPartPow, err := d.Abs().Ln(precision)\n\tif err != nil {\n\t\treturn Decimal{}, err\n\t}\n\n\tfracPartPow = fracPartPow.Mul(expFracPart)\n\n\tfracPartPow, err = fracPartPow.ExpTaylor(precision)\n\tif err != nil {\n\t\treturn Decimal{}, err\n\t}\n\n\t// Join integer and fractional part,\n\t// base ** (expBase + expFrac) = base ** expBase * base ** expFrac\n\tres := intPartPow.Mul(fracPartPow)\n\n\treturn res, nil\n}\n\n// PowInt32 returns d to the power of exp, where exp is int32.\n// Only returns error when d and exp is 0, thus result is undefined.\n//\n// When exponent is negative the returned decimal will have maximum precision of PowPrecisionNegativeExponent places after decimal point.\n//\n// Example:\n//\n//\td1, err := decimal.NewFromFloat(4.0).PowInt32(4)\n//\td1.String() // output: \"256\"\n//\n//\td2, err := decimal.NewFromFloat(3.13).PowInt32(5)\n//\td2.String() // output: \"300.4150512793\"\nfunc (d Decimal) PowInt32(exp int32) (Decimal, error) {\n\tif d.IsZero() && exp == 0 {\n\t\treturn Decimal{}, fmt.Errorf(\"cannot represent undefined value of 0**0\")\n\t}\n\n\tisExpNeg := exp < 0\n\texp = abs(exp)\n\n\tn, result := d, New(1, 0)\n\n\tfor exp > 0 {\n\t\tif exp%2 == 1 {\n\t\t\tresult = result.Mul(n)\n\t\t}\n\t\texp /= 2\n\n\t\tif exp > 0 {\n\t\t\tn = n.Mul(n)\n\t\t}\n\t}\n\n\tif isExpNeg {\n\t\treturn New(1, 0).DivRound(result, int32(PowPrecisionNegativeExponent)), nil\n\t}\n\n\treturn result, nil\n}\n\n// PowBigInt returns d to the power of exp, where exp is big.Int.\n// Only returns error when d and exp is 0, thus result is undefined.\n//\n// When exponent is negative the returned decimal will have maximum precision of PowPrecisionNegativeExponent places after decimal point.\n//\n// Example:\n//\n//\td1, err := decimal.NewFromFloat(3.0).PowBigInt(big.NewInt(3))\n//\td1.String() // output: \"27\"\n//\n//\td2, err := decimal.NewFromFloat(629.25).PowBigInt(big.NewInt(5))\n//\td2.String() // output: \"98654323103449.5673828125\"\nfunc (d Decimal) PowBigInt(exp *big.Int) (Decimal, error) {\n\treturn d.powBigIntWithPrecision(exp, int32(PowPrecisionNegativeExponent))\n}\n\nfunc (d Decimal) powBigIntWithPrecision(exp *big.Int, precision int32) (Decimal, error) {\n\tif d.IsZero() && exp.Sign() == 0 {\n\t\treturn Decimal{}, fmt.Errorf(\"cannot represent undefined value of 0**0\")\n\t}\n\n\ttmpExp := new(big.Int).Set(exp)\n\tisExpNeg := exp.Sign() < 0\n\n\tif isExpNeg {\n\t\ttmpExp.Abs(tmpExp)\n\t}\n\n\tn, result := d, New(1, 0)\n\n\tfor tmpExp.Sign() > 0 {\n\t\tif tmpExp.Bit(0) == 1 {\n\t\t\tresult = result.Mul(n)\n\t\t}\n\t\ttmpExp.Rsh(tmpExp, 1)\n\n\t\tif tmpExp.Sign() > 0 {\n\t\t\tn = n.Mul(n)\n\t\t}\n\t}\n\n\tif isExpNeg {\n\t\treturn New(1, 0).DivRound(result, precision), nil\n\t}\n\n\treturn result, nil\n}\n\n// ExpHullAbrham calculates the natural exponent of decimal (e to the power of d) using Hull-Abraham algorithm.\n// OverallPrecision argument specifies the overall precision of the result (integer part + decimal part).\n//\n// ExpHullAbrham is faster than ExpTaylor for small precision values, but it is much slower for large precision values.\n//\n// Example:\n//\n//\tNewFromFloat(26.1).ExpHullAbrham(2).String()    // output: \"220000000000\"\n//\tNewFromFloat(26.1).ExpHullAbrham(20).String()   // output: \"216314672147.05767284\"\nfunc (d Decimal) ExpHullAbrham(overallPrecision uint32) (Decimal, error) {\n\t// Algorithm based on Variable precision exponential function.\n\t// ACM Transactions on Mathematical Software by T. E. Hull & A. Abrham.\n\tif d.IsZero() {\n\t\treturn Decimal{oneInt, 0}, nil\n\t}\n\n\tcurrentPrecision := overallPrecision\n\n\t// Algorithm does not work if currentPrecision * 23 < |x|.\n\t// Precision is automatically increased in such cases, so the value can be calculated precisely.\n\t// If newly calculated precision is higher than ExpMaxIterations the currentPrecision will not be changed.\n\tf := d.Abs().InexactFloat64()\n\tif ncp := f / 23; ncp > float64(currentPrecision) && ncp < float64(ExpMaxIterations) {\n\t\tcurrentPrecision = uint32(math.Ceil(ncp))\n\t}\n\n\t// fail if abs(d) beyond an over/underflow threshold\n\toverflowThreshold := New(23*int64(currentPrecision), 0)\n\tif d.Abs().Cmp(overflowThreshold) > 0 {\n\t\treturn Decimal{}, fmt.Errorf(\"over/underflow threshold, exp(x) cannot be calculated precisely\")\n\t}\n\n\t// Return 1 if abs(d) small enough; this also avoids later over/underflow\n\toverflowThreshold2 := New(9, -int32(currentPrecision)-1)\n\tif d.Abs().Cmp(overflowThreshold2) <= 0 {\n\t\treturn Decimal{oneInt, d.exp}, nil\n\t}\n\n\t// t is the smallest integer >= 0 such that the corresponding abs(d/k) < 1\n\tt := d.exp + int32(d.NumDigits()) // Add d.NumDigits because the paper assumes that d.value [0.1, 1)\n\n\tif t < 0 {\n\t\tt = 0\n\t}\n\n\tk := New(1, t)                                     // reduction factor\n\tr := Decimal{new(big.Int).Set(d.value), d.exp - t} // reduced argument\n\tp := int32(currentPrecision) + t + 2               // precision for calculating the sum\n\n\t// Determine n, the number of therms for calculating sum\n\t// use first Newton step (1.435p - 1.182) / log10(p/abs(r))\n\t// for solving appropriate equation, along with directed\n\t// roundings and simple rational bound for log10(p/abs(r))\n\trf := r.Abs().InexactFloat64()\n\tpf := float64(p)\n\tnf := math.Ceil((1.453*pf - 1.182) / math.Log10(pf/rf))\n\tif nf > float64(ExpMaxIterations) || math.IsNaN(nf) {\n\t\treturn Decimal{}, fmt.Errorf(\"exact value cannot be calculated in <=ExpMaxIterations iterations\")\n\t}\n\tn := int64(nf)\n\n\ttmp := New(0, 0)\n\tsum := New(1, 0)\n\tone := New(1, 0)\n\tfor i := n - 1; i > 0; i-- {\n\t\ttmp.value.SetInt64(i)\n\t\tsum = sum.Mul(r.DivRound(tmp, p))\n\t\tsum = sum.Add(one)\n\t}\n\n\tki := k.IntPart()\n\tres := New(1, 0)\n\tfor i := ki; i > 0; i-- {\n\t\tres = res.Mul(sum)\n\t}\n\n\tresNumDigits := int32(res.NumDigits())\n\n\tvar roundDigits int32\n\tif resNumDigits > abs(res.exp) {\n\t\troundDigits = int32(currentPrecision) - resNumDigits - res.exp\n\t} else {\n\t\troundDigits = int32(currentPrecision)\n\t}\n\n\tres = res.Round(roundDigits)\n\n\treturn res, nil\n}\n\n// ExpTaylor calculates the natural exponent of decimal (e to the power of d) using Taylor series expansion.\n// Precision argument specifies how precise the result must be (number of digits after decimal point).\n// Negative precision is allowed.\n//\n// ExpTaylor is much faster for large precision values than ExpHullAbrham.\n//\n// Example:\n//\n//\td, err := NewFromFloat(26.1).ExpTaylor(2).String()\n//\td.String()  // output: \"216314672147.06\"\n//\n//\tNewFromFloat(26.1).ExpTaylor(20).String()\n//\td.String()  // output: \"216314672147.05767284062928674083\"\n//\n//\tNewFromFloat(26.1).ExpTaylor(-10).String()\n//\td.String()  // output: \"220000000000\"\nfunc (d Decimal) ExpTaylor(precision int32) (Decimal, error) {\n\t// Note(mwoss): Implementation can be optimized by exclusively using big.Int API only\n\tif d.IsZero() {\n\t\treturn Decimal{oneInt, 0}.Round(precision), nil\n\t}\n\n\tvar epsilon Decimal\n\tvar divPrecision int32\n\tif precision < 0 {\n\t\tepsilon = New(1, -1)\n\t\tdivPrecision = 8\n\t} else {\n\t\tepsilon = New(1, -precision-1)\n\t\tdivPrecision = precision + 1\n\t}\n\n\tdecAbs := d.Abs()\n\tpow := d.Abs()\n\tfactorial := New(1, 0)\n\n\tresult := New(1, 0)\n\n\tfor i := int64(1); ; {\n\t\tstep := pow.DivRound(factorial, divPrecision)\n\t\tresult = result.Add(step)\n\n\t\t// Stop Taylor series when current step is smaller than epsilon\n\t\tif step.Cmp(epsilon) < 0 {\n\t\t\tbreak\n\t\t}\n\n\t\tpow = pow.Mul(decAbs)\n\n\t\ti++\n\n\t\t// Calculate next factorial number or retrieve cached value\n\t\tif len(factorials) >= int(i) && !factorials[i-1].IsZero() {\n\t\t\tfactorial = factorials[i-1]\n\t\t} else {\n\t\t\t// To avoid any race conditions, firstly the zero value is appended to a slice to create\n\t\t\t// a spot for newly calculated factorial. After that, the zero value is replaced by calculated\n\t\t\t// factorial using the index notation.\n\t\t\tfactorial = factorials[i-2].Mul(New(i, 0))\n\t\t\tfactorials = append(factorials, Zero)\n\t\t\tfactorials[i-1] = factorial\n\t\t}\n\t}\n\n\tif d.Sign() < 0 {\n\t\tresult = New(1, 0).DivRound(result, precision+1)\n\t}\n\n\tresult = result.Round(precision)\n\treturn result, nil\n}\n\n// Ln calculates natural logarithm of d.\n// Precision argument specifies how precise the result must be (number of digits after decimal point).\n// Negative precision is allowed.\n//\n// Example:\n//\n//\td1, err := NewFromFloat(13.3).Ln(2)\n//\td1.String()  // output: \"2.59\"\n//\n//\td2, err := NewFromFloat(579.161).Ln(10)\n//\td2.String()  // output: \"6.3615805046\"\nfunc (d Decimal) Ln(precision int32) (Decimal, error) {\n\t// Algorithm based on The Use of Iteration Methods for Approximating the Natural Logarithm,\n\t// James F. Epperson, The American Mathematical Monthly, Vol. 96, No. 9, November 1989, pp. 831-835.\n\tif d.IsNegative() {\n\t\treturn Decimal{}, fmt.Errorf(\"cannot calculate natural logarithm for negative decimals\")\n\t}\n\n\tif d.IsZero() {\n\t\treturn Decimal{}, fmt.Errorf(\"cannot represent natural logarithm of 0, result: -infinity\")\n\t}\n\n\tcalcPrecision := precision + 2\n\tz := d.Copy()\n\n\tvar comp1, comp3, comp2, comp4, reduceAdjust Decimal\n\tcomp1 = z.Sub(Decimal{oneInt, 0})\n\tcomp3 = Decimal{oneInt, -1}\n\n\t// for decimal in range [0.9, 1.1] where ln(d) is close to 0\n\tusePowerSeries := false\n\n\tif comp1.Abs().Cmp(comp3) <= 0 {\n\t\tusePowerSeries = true\n\t} else {\n\t\t// reduce input decimal to range [0.1, 1)\n\t\texpDelta := int32(z.NumDigits()) + z.exp\n\t\tz.exp -= expDelta\n\n\t\t// Input decimal was reduced by factor of 10^expDelta, thus we will need to add\n\t\t// ln(10^expDelta) = expDelta * ln(10)\n\t\t// to the result to compensate that\n\t\tln10 := ln10.withPrecision(calcPrecision)\n\t\treduceAdjust = NewFromInt32(expDelta)\n\t\treduceAdjust = reduceAdjust.Mul(ln10)\n\n\t\tcomp1 = z.Sub(Decimal{oneInt, 0})\n\n\t\tif comp1.Abs().Cmp(comp3) <= 0 {\n\t\t\tusePowerSeries = true\n\t\t} else {\n\t\t\t// initial estimate using floats\n\t\t\tzFloat := z.InexactFloat64()\n\t\t\tcomp1 = NewFromFloat(math.Log(zFloat))\n\t\t}\n\t}\n\n\tepsilon := Decimal{oneInt, -calcPrecision}\n\n\tif usePowerSeries {\n\t\t// Power Series - https://en.wikipedia.org/wiki/Logarithm#Power_series\n\t\t// Calculating n-th term of formula: ln(z+1) = 2 sum [ 1 / (2n+1) * (z / (z+2))^(2n+1) ]\n\t\t// until the difference between current and next term is smaller than epsilon.\n\t\t// Coverage quite fast for decimals close to 1.0\n\n\t\t// z + 2\n\t\tcomp2 = comp1.Add(Decimal{twoInt, 0})\n\t\t// z / (z + 2)\n\t\tcomp3 = comp1.DivRound(comp2, calcPrecision)\n\t\t// 2 * (z / (z + 2))\n\t\tcomp1 = comp3.Add(comp3)\n\t\tcomp2 = comp1.Copy()\n\n\t\tfor n := 1; ; n++ {\n\t\t\t// 2 * (z / (z+2))^(2n+1)\n\t\t\tcomp2 = comp2.Mul(comp3).Mul(comp3)\n\n\t\t\t// 1 / (2n+1) * 2 * (z / (z+2))^(2n+1)\n\t\t\tcomp4 = NewFromInt(int64(2*n + 1))\n\t\t\tcomp4 = comp2.DivRound(comp4, calcPrecision)\n\n\t\t\t// comp1 = 2 sum [ 1 / (2n+1) * (z / (z+2))^(2n+1) ]\n\t\t\tcomp1 = comp1.Add(comp4)\n\n\t\t\tif comp4.Abs().Cmp(epsilon) <= 0 {\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t} else {\n\t\t// Halley's Iteration.\n\t\t// Calculating n-th term of formula: a_(n+1) = a_n - 2 * (exp(a_n) - z) / (exp(a_n) + z),\n\t\t// until the difference between current and next term is smaller than epsilon\n\t\tvar prevStep Decimal\n\t\tmaxIters := calcPrecision*2 + 10\n\n\t\tfor i := int32(0); i < maxIters; i++ {\n\t\t\t// exp(a_n)\n\t\t\tcomp3, _ = comp1.ExpTaylor(calcPrecision)\n\t\t\t// exp(a_n) - z\n\t\t\tcomp2 = comp3.Sub(z)\n\t\t\t// 2 * (exp(a_n) - z)\n\t\t\tcomp2 = comp2.Add(comp2)\n\t\t\t// exp(a_n) + z\n\t\t\tcomp4 = comp3.Add(z)\n\t\t\t// 2 * (exp(a_n) - z) / (exp(a_n) + z)\n\t\t\tcomp3 = comp2.DivRound(comp4, calcPrecision)\n\t\t\t// comp1 = a_(n+1) = a_n - 2 * (exp(a_n) - z) / (exp(a_n) + z)\n\t\t\tcomp1 = comp1.Sub(comp3)\n\n\t\t\tif prevStep.Add(comp3).IsZero() {\n\t\t\t\t// If iteration steps oscillate we should return early and prevent an infinity loop\n\t\t\t\t// NOTE(mwoss): This should be quite a rare case, returning error is not necessary\n\t\t\t\tbreak\n\t\t\t}\n\n\t\t\tif comp3.Abs().Cmp(epsilon) <= 0 {\n\t\t\t\tbreak\n\t\t\t}\n\n\t\t\tprevStep = comp3\n\t\t}\n\t}\n\n\tcomp1 = comp1.Add(reduceAdjust)\n\n\treturn comp1.Round(precision), nil\n}\n\n// NumDigits returns the number of digits of the decimal coefficient (d.Value)\nfunc (d Decimal) NumDigits() int {\n\tif d.value == nil {\n\t\treturn 1\n\t}\n\n\tif d.value.IsInt64() {\n\t\ti64 := d.value.Int64()\n\t\t// restrict fast path to integers with exact conversion to float64\n\t\tif i64 <= (1<<53) && i64 >= -(1<<53) {\n\t\t\tif i64 == 0 {\n\t\t\t\treturn 1\n\t\t\t}\n\t\t\treturn int(math.Log10(math.Abs(float64(i64)))) + 1\n\t\t}\n\t}\n\n\testimatedNumDigits := int(float64(d.value.BitLen()) / math.Log2(10))\n\n\t// estimatedNumDigits (lg10) may be off by 1, need to verify\n\tdigitsBigInt := big.NewInt(int64(estimatedNumDigits))\n\terrorCorrectionUnit := digitsBigInt.Exp(tenInt, digitsBigInt, nil)\n\n\tif d.value.CmpAbs(errorCorrectionUnit) >= 0 {\n\t\treturn estimatedNumDigits + 1\n\t}\n\n\treturn estimatedNumDigits\n}\n\n// IsInteger returns true when decimal can be represented as an integer value, otherwise, it returns false.\nfunc (d Decimal) IsInteger() bool {\n\t// The most typical case, all decimal with exponent higher or equal 0 can be represented as integer\n\tif d.exp >= 0 {\n\t\treturn true\n\t}\n\t// When the exponent is negative we have to check every number after the decimal place\n\t// If all of them are zeroes, we are sure that given decimal can be represented as an integer\n\tvar r big.Int\n\tq := new(big.Int).Set(d.value)\n\tfor z := abs(d.exp); z > 0; z-- {\n\t\tq.QuoRem(q, tenInt, &r)\n\t\tif r.Cmp(zeroInt) != 0 {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\n// Abs calculates absolute value of any int32. Used for calculating absolute value of decimal's exponent.\nfunc abs(n int32) int32 {\n\tif n < 0 {\n\t\treturn -n\n\t}\n\treturn n\n}\n\n// Cmp compares the numbers represented by d and d2 and returns:\n//\n//\t-1 if d <  d2\n//\t 0 if d == d2\n//\t+1 if d >  d2\nfunc (d Decimal) Cmp(d2 Decimal) int {\n\td.ensureInitialized()\n\td2.ensureInitialized()\n\n\tif d.exp == d2.exp {\n\t\treturn d.value.Cmp(d2.value)\n\t}\n\n\trd, rd2 := RescalePair(d, d2)\n\n\treturn rd.value.Cmp(rd2.value)\n}\n\n// Compare compares the numbers represented by d and d2 and returns:\n//\n//\t-1 if d <  d2\n//\t 0 if d == d2\n//\t+1 if d >  d2\nfunc (d Decimal) Compare(d2 Decimal) int {\n\treturn d.Cmp(d2)\n}\n\n// Equal returns whether the numbers represented by d and d2 are equal.\nfunc (d Decimal) Equal(d2 Decimal) bool {\n\treturn d.Cmp(d2) == 0\n}\n\n// Deprecated: Equals is deprecated, please use Equal method instead.\nfunc (d Decimal) Equals(d2 Decimal) bool {\n\treturn d.Equal(d2)\n}\n\n// GreaterThan (GT) returns true when d is greater than d2.\nfunc (d Decimal) GreaterThan(d2 Decimal) bool {\n\treturn d.Cmp(d2) == 1\n}\n\n// GreaterThanOrEqual (GTE) returns true when d is greater than or equal to d2.\nfunc (d Decimal) GreaterThanOrEqual(d2 Decimal) bool {\n\tcmp := d.Cmp(d2)\n\treturn cmp == 1 || cmp == 0\n}\n\n// LessThan (LT) returns true when d is less than d2.\nfunc (d Decimal) LessThan(d2 Decimal) bool {\n\treturn d.Cmp(d2) == -1\n}\n\n// LessThanOrEqual (LTE) returns true when d is less than or equal to d2.\nfunc (d Decimal) LessThanOrEqual(d2 Decimal) bool {\n\tcmp := d.Cmp(d2)\n\treturn cmp == -1 || cmp == 0\n}\n\n// Sign returns:\n//\n//\t-1 if d <  0\n//\t 0 if d == 0\n//\t+1 if d >  0\nfunc (d Decimal) Sign() int {\n\tif d.value == nil {\n\t\treturn 0\n\t}\n\treturn d.value.Sign()\n}\n\n// IsPositive return\n//\n//\ttrue if d > 0\n//\tfalse if d == 0\n//\tfalse if d < 0\nfunc (d Decimal) IsPositive() bool {\n\treturn d.Sign() == 1\n}\n\n// IsNegative return\n//\n//\ttrue if d < 0\n//\tfalse if d == 0\n//\tfalse if d > 0\nfunc (d Decimal) IsNegative() bool {\n\treturn d.Sign() == -1\n}\n\n// IsZero return\n//\n//\ttrue if d == 0\n//\tfalse if d > 0\n//\tfalse if d < 0\nfunc (d Decimal) IsZero() bool {\n\treturn d.Sign() == 0\n}\n\n// Exponent returns the exponent, or scale component of the decimal.\nfunc (d Decimal) Exponent() int32 {\n\treturn d.exp\n}\n\n// Coefficient returns the coefficient of the decimal. It is scaled by 10^Exponent()\nfunc (d Decimal) Coefficient() *big.Int {\n\td.ensureInitialized()\n\t// we copy the coefficient so that mutating the result does not mutate the Decimal.\n\treturn new(big.Int).Set(d.value)\n}\n\n// CoefficientInt64 returns the coefficient of the decimal as int64. It is scaled by 10^Exponent()\n// If coefficient cannot be represented in an int64, the result will be undefined.\nfunc (d Decimal) CoefficientInt64() int64 {\n\td.ensureInitialized()\n\treturn d.value.Int64()\n}\n\n// IntPart returns the integer component of the decimal.\nfunc (d Decimal) IntPart() int64 {\n\tscaledD := d.rescale(0)\n\treturn scaledD.value.Int64()\n}\n\n// BigInt returns integer component of the decimal as a BigInt.\nfunc (d Decimal) BigInt() *big.Int {\n\tscaledD := d.rescale(0)\n\treturn scaledD.value\n}\n\n// BigFloat returns decimal as BigFloat.\n// Be aware that casting decimal to BigFloat might cause a loss of precision.\nfunc (d Decimal) BigFloat() *big.Float {\n\tf := &big.Float{}\n\tf.SetString(d.String())\n\treturn f\n}\n\n// Rat returns a rational number representation of the decimal.\nfunc (d Decimal) Rat() *big.Rat {\n\td.ensureInitialized()\n\tif d.exp <= 0 {\n\t\t// NOTE(vadim): must negate after casting to prevent int32 overflow\n\t\tdenom := new(big.Int).Exp(tenInt, big.NewInt(-int64(d.exp)), nil)\n\t\treturn new(big.Rat).SetFrac(d.value, denom)\n\t}\n\n\tmul := new(big.Int).Exp(tenInt, big.NewInt(int64(d.exp)), nil)\n\tnum := new(big.Int).Mul(d.value, mul)\n\treturn new(big.Rat).SetFrac(num, oneInt)\n}\n\n// Float64 returns the nearest float64 value for d and a bool indicating\n// whether f represents d exactly.\n// For more details, see the documentation for big.Rat.Float64\nfunc (d Decimal) Float64() (f float64, exact bool) {\n\treturn d.Rat().Float64()\n}\n\n// InexactFloat64 returns the nearest float64 value for d.\n// It doesn't indicate if the returned value represents d exactly.\nfunc (d Decimal) InexactFloat64() float64 {\n\tf, _ := d.Float64()\n\treturn f\n}\n\n// String returns the string representation of the decimal\n// with the fixed point.\n//\n// Example:\n//\n//\td := New(-12345, -3)\n//\tprintln(d.String())\n//\n// Output:\n//\n//\t-12.345\nfunc (d Decimal) String() string {\n\treturn d.string(true)\n}\n\n// StringFixed returns a rounded fixed-point string with places digits after\n// the decimal point.\n//\n// Example:\n//\n//\tNewFromFloat(0).StringFixed(2) // output: \"0.00\"\n//\tNewFromFloat(0).StringFixed(0) // output: \"0\"\n//\tNewFromFloat(5.45).StringFixed(0) // output: \"5\"\n//\tNewFromFloat(5.45).StringFixed(1) // output: \"5.5\"\n//\tNewFromFloat(5.45).StringFixed(2) // output: \"5.45\"\n//\tNewFromFloat(5.45).StringFixed(3) // output: \"5.450\"\n//\tNewFromFloat(545).StringFixed(-1) // output: \"550\"\nfunc (d Decimal) StringFixed(places int32) string {\n\trounded := d.Round(places)\n\treturn rounded.string(false)\n}\n\n// StringFixedBank returns a banker rounded fixed-point string with places digits\n// after the decimal point.\n//\n// Example:\n//\n//\tNewFromFloat(0).StringFixedBank(2) // output: \"0.00\"\n//\tNewFromFloat(0).StringFixedBank(0) // output: \"0\"\n//\tNewFromFloat(5.45).StringFixedBank(0) // output: \"5\"\n//\tNewFromFloat(5.45).StringFixedBank(1) // output: \"5.4\"\n//\tNewFromFloat(5.45).StringFixedBank(2) // output: \"5.45\"\n//\tNewFromFloat(5.45).StringFixedBank(3) // output: \"5.450\"\n//\tNewFromFloat(545).StringFixedBank(-1) // output: \"540\"\nfunc (d Decimal) StringFixedBank(places int32) string {\n\trounded := d.RoundBank(places)\n\treturn rounded.string(false)\n}\n\n// StringFixedCash returns a Swedish/Cash rounded fixed-point string. For\n// more details see the documentation at function RoundCash.\nfunc (d Decimal) StringFixedCash(interval uint8) string {\n\trounded := d.RoundCash(interval)\n\treturn rounded.string(false)\n}\n\n// Round rounds the decimal to places decimal places.\n// If places < 0, it will round the integer part to the nearest 10^(-places).\n//\n// Example:\n//\n//\tNewFromFloat(5.45).Round(1).String() // output: \"5.5\"\n//\tNewFromFloat(545).Round(-1).String() // output: \"550\"\nfunc (d Decimal) Round(places int32) Decimal {\n\tif d.exp == -places {\n\t\treturn d\n\t}\n\t// truncate to places + 1\n\tret := d.rescale(-places - 1)\n\n\t// add sign(d) * 0.5\n\tif ret.value.Sign() < 0 {\n\t\tret.value.Sub(ret.value, fiveInt)\n\t} else {\n\t\tret.value.Add(ret.value, fiveInt)\n\t}\n\n\t// floor for positive numbers, ceil for negative numbers\n\t_, m := ret.value.DivMod(ret.value, tenInt, new(big.Int))\n\tret.exp++\n\tif ret.value.Sign() < 0 && m.Cmp(zeroInt) != 0 {\n\t\tret.value.Add(ret.value, oneInt)\n\t}\n\n\treturn ret\n}\n\n// RoundCeil rounds the decimal towards +infinity.\n//\n// Example:\n//\n//\tNewFromFloat(545).RoundCeil(-2).String()   // output: \"600\"\n//\tNewFromFloat(500).RoundCeil(-2).String()   // output: \"500\"\n//\tNewFromFloat(1.1001).RoundCeil(2).String() // output: \"1.11\"\n//\tNewFromFloat(-1.454).RoundCeil(1).String() // output: \"-1.4\"\nfunc (d Decimal) RoundCeil(places int32) Decimal {\n\tif d.exp >= -places {\n\t\treturn d\n\t}\n\n\trescaled := d.rescale(-places)\n\tif d.Equal(rescaled) {\n\t\treturn d\n\t}\n\n\tif d.value.Sign() > 0 {\n\t\trescaled.value.Add(rescaled.value, oneInt)\n\t}\n\n\treturn rescaled\n}\n\n// RoundFloor rounds the decimal towards -infinity.\n//\n// Example:\n//\n//\tNewFromFloat(545).RoundFloor(-2).String()   // output: \"500\"\n//\tNewFromFloat(-500).RoundFloor(-2).String()   // output: \"-500\"\n//\tNewFromFloat(1.1001).RoundFloor(2).String() // output: \"1.1\"\n//\tNewFromFloat(-1.454).RoundFloor(1).String() // output: \"-1.5\"\nfunc (d Decimal) RoundFloor(places int32) Decimal {\n\tif d.exp >= -places {\n\t\treturn d\n\t}\n\n\trescaled := d.rescale(-places)\n\tif d.Equal(rescaled) {\n\t\treturn d\n\t}\n\n\tif d.value.Sign() < 0 {\n\t\trescaled.value.Sub(rescaled.value, oneInt)\n\t}\n\n\treturn rescaled\n}\n\n// RoundUp rounds the decimal away from zero.\n//\n// Example:\n//\n//\tNewFromFloat(545).RoundUp(-2).String()   // output: \"600\"\n//\tNewFromFloat(500).RoundUp(-2).String()   // output: \"500\"\n//\tNewFromFloat(1.1001).RoundUp(2).String() // output: \"1.11\"\n//\tNewFromFloat(-1.454).RoundUp(1).String() // output: \"-1.5\"\nfunc (d Decimal) RoundUp(places int32) Decimal {\n\tif d.exp >= -places {\n\t\treturn d\n\t}\n\n\trescaled := d.rescale(-places)\n\tif d.Equal(rescaled) {\n\t\treturn d\n\t}\n\n\tif d.value.Sign() > 0 {\n\t\trescaled.value.Add(rescaled.value, oneInt)\n\t} else if d.value.Sign() < 0 {\n\t\trescaled.value.Sub(rescaled.value, oneInt)\n\t}\n\n\treturn rescaled\n}\n\n// RoundDown rounds the decimal towards zero.\n//\n// Example:\n//\n//\tNewFromFloat(545).RoundDown(-2).String()   // output: \"500\"\n//\tNewFromFloat(-500).RoundDown(-2).String()   // output: \"-500\"\n//\tNewFromFloat(1.1001).RoundDown(2).String() // output: \"1.1\"\n//\tNewFromFloat(-1.454).RoundDown(1).String() // output: \"-1.4\"\nfunc (d Decimal) RoundDown(places int32) Decimal {\n\tif d.exp >= -places {\n\t\treturn d\n\t}\n\n\trescaled := d.rescale(-places)\n\tif d.Equal(rescaled) {\n\t\treturn d\n\t}\n\treturn rescaled\n}\n\n// RoundBank rounds the decimal to places decimal places.\n// If the final digit to round is equidistant from the nearest two integers the\n// rounded value is taken as the even number\n//\n// If places < 0, it will round the integer part to the nearest 10^(-places).\n//\n// Examples:\n//\n//\tNewFromFloat(5.45).RoundBank(1).String() // output: \"5.4\"\n//\tNewFromFloat(545).RoundBank(-1).String() // output: \"540\"\n//\tNewFromFloat(5.46).RoundBank(1).String() // output: \"5.5\"\n//\tNewFromFloat(546).RoundBank(-1).String() // output: \"550\"\n//\tNewFromFloat(5.55).RoundBank(1).String() // output: \"5.6\"\n//\tNewFromFloat(555).RoundBank(-1).String() // output: \"560\"\nfunc (d Decimal) RoundBank(places int32) Decimal {\n\n\tround := d.Round(places)\n\tremainder := d.Sub(round).Abs()\n\n\thalf := New(5, -places-1)\n\tif remainder.Cmp(half) == 0 && round.value.Bit(0) != 0 {\n\t\tif round.value.Sign() < 0 {\n\t\t\tround.value.Add(round.value, oneInt)\n\t\t} else {\n\t\t\tround.value.Sub(round.value, oneInt)\n\t\t}\n\t}\n\n\treturn round\n}\n\n// RoundCash aka Cash/Penny/re rounding rounds decimal to a specific\n// interval. The amount payable for a cash transaction is rounded to the nearest\n// multiple of the minimum currency unit available. The following intervals are\n// available: 5, 10, 25, 50 and 100; any other number throws a panic.\n//\n//\t  5:   5 cent rounding 3.43 => 3.45\n//\t 10:  10 cent rounding 3.45 => 3.50 (5 gets rounded up)\n//\t 25:  25 cent rounding 3.41 => 3.50\n//\t 50:  50 cent rounding 3.75 => 4.00\n//\t100: 100 cent rounding 3.50 => 4.00\n//\n// For more details: https://en.wikipedia.org/wiki/Cash_rounding\nfunc (d Decimal) RoundCash(interval uint8) Decimal {\n\tvar iVal *big.Int\n\tswitch interval {\n\tcase 5:\n\t\tiVal = twentyInt\n\tcase 10:\n\t\tiVal = tenInt\n\tcase 25:\n\t\tiVal = fourInt\n\tcase 50:\n\t\tiVal = twoInt\n\tcase 100:\n\t\tiVal = oneInt\n\tdefault:\n\t\tpanic(fmt.Sprintf(\"Decimal does not support this Cash rounding interval `%d`. Supported: 5, 10, 25, 50, 100\", interval))\n\t}\n\tdVal := Decimal{\n\t\tvalue: iVal,\n\t}\n\n\t// TODO: optimize those calculations to reduce the high allocations (~29 allocs).\n\treturn d.Mul(dVal).Round(0).Div(dVal).Truncate(2)\n}\n\n// Floor returns the nearest integer value less than or equal to d.\nfunc (d Decimal) Floor() Decimal {\n\td.ensureInitialized()\n\n\tif d.exp >= 0 {\n\t\treturn d\n\t}\n\n\texp := big.NewInt(10)\n\n\t// NOTE(vadim): must negate after casting to prevent int32 overflow\n\texp.Exp(exp, big.NewInt(-int64(d.exp)), nil)\n\n\tz := new(big.Int).Div(d.value, exp)\n\treturn Decimal{value: z, exp: 0}\n}\n\n// Ceil returns the nearest integer value greater than or equal to d.\nfunc (d Decimal) Ceil() Decimal {\n\td.ensureInitialized()\n\n\tif d.exp >= 0 {\n\t\treturn d\n\t}\n\n\texp := big.NewInt(10)\n\n\t// NOTE(vadim): must negate after casting to prevent int32 overflow\n\texp.Exp(exp, big.NewInt(-int64(d.exp)), nil)\n\n\tz, m := new(big.Int).DivMod(d.value, exp, new(big.Int))\n\tif m.Cmp(zeroInt) != 0 {\n\t\tz.Add(z, oneInt)\n\t}\n\treturn Decimal{value: z, exp: 0}\n}\n\n// Truncate truncates off digits from the number, without rounding.\n//\n// NOTE: precision is the last digit that will not be truncated (must be >= 0).\n//\n// Example:\n//\n//\tdecimal.NewFromString(\"123.456\").Truncate(2).String() // \"123.45\"\nfunc (d Decimal) Truncate(precision int32) Decimal {\n\td.ensureInitialized()\n\tif precision >= 0 && -precision > d.exp {\n\t\treturn d.rescale(-precision)\n\t}\n\treturn d\n}\n\n// UnmarshalJSON implements the json.Unmarshaler interface.\nfunc (d *Decimal) UnmarshalJSON(decimalBytes []byte) error {\n\tif string(decimalBytes) == \"null\" {\n\t\treturn nil\n\t}\n\n\tstr, err := unquoteIfQuoted(decimalBytes)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"error decoding string '%s': %s\", decimalBytes, err)\n\t}\n\n\tdecimal, err := NewFromString(str)\n\t*d = decimal\n\tif err != nil {\n\t\treturn fmt.Errorf(\"error decoding string '%s': %s\", str, err)\n\t}\n\treturn nil\n}\n\n// MarshalJSON implements the json.Marshaler interface.\nfunc (d Decimal) MarshalJSON() ([]byte, error) {\n\tvar str string\n\tif MarshalJSONWithoutQuotes {\n\t\tstr = d.String()\n\t} else {\n\t\tstr = \"\\\"\" + d.String() + \"\\\"\"\n\t}\n\treturn []byte(str), nil\n}\n\n// UnmarshalBinary implements the encoding.BinaryUnmarshaler interface. As a string representation\n// is already used when encoding to text, this method stores that string as []byte\nfunc (d *Decimal) UnmarshalBinary(data []byte) error {\n\t// Verify we have at least 4 bytes for the exponent. The GOB encoded value\n\t// may be empty.\n\tif len(data) < 4 {\n\t\treturn fmt.Errorf(\"error decoding binary %v: expected at least 4 bytes, got %d\", data, len(data))\n\t}\n\n\t// Extract the exponent\n\td.exp = int32(binary.BigEndian.Uint32(data[:4]))\n\n\t// Extract the value\n\td.value = new(big.Int)\n\tif err := d.value.GobDecode(data[4:]); err != nil {\n\t\treturn fmt.Errorf(\"error decoding binary %v: %s\", data, err)\n\t}\n\n\treturn nil\n}\n\n// MarshalBinary implements the encoding.BinaryMarshaler interface.\nfunc (d Decimal) MarshalBinary() (data []byte, err error) {\n\t// exp is written first, but encode value first to know output size\n\tvar valueData []byte\n\tif valueData, err = d.value.GobEncode(); err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Write the exponent in front, since it's a fixed size\n\texpData := make([]byte, 4, len(valueData)+4)\n\tbinary.BigEndian.PutUint32(expData, uint32(d.exp))\n\n\t// Return the byte array\n\treturn append(expData, valueData...), nil\n}\n\n// Scan implements the sql.Scanner interface for database deserialization.\nfunc (d *Decimal) Scan(value interface{}) error {\n\t// first try to see if the data is stored in database as a Numeric datatype\n\tswitch v := value.(type) {\n\n\tcase float32:\n\t\t*d = NewFromFloat(float64(v))\n\t\treturn nil\n\n\tcase float64:\n\t\t// numeric in sqlite3 sends us float64\n\t\t*d = NewFromFloat(v)\n\t\treturn nil\n\n\tcase int64:\n\t\t// at least in sqlite3 when the value is 0 in db, the data is sent\n\t\t// to us as an int64 instead of a float64 ...\n\t\t*d = New(v, 0)\n\t\treturn nil\n\n\tcase uint64:\n\t\t// while clickhouse may send 0 in db as uint64\n\t\t*d = NewFromUint64(v)\n\t\treturn nil\n\n\tdefault:\n\t\t// default is trying to interpret value stored as string\n\t\tstr, err := unquoteIfQuoted(v)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t*d, err = NewFromString(str)\n\t\treturn err\n\t}\n}\n\n// Value implements the driver.Valuer interface for database serialization.\nfunc (d Decimal) Value() (driver.Value, error) {\n\treturn d.String(), nil\n}\n\n// UnmarshalText implements the encoding.TextUnmarshaler interface for XML\n// deserialization.\nfunc (d *Decimal) UnmarshalText(text []byte) error {\n\tstr := string(text)\n\n\tdec, err := NewFromString(str)\n\t*d = dec\n\tif err != nil {\n\t\treturn fmt.Errorf(\"error decoding string '%s': %s\", str, err)\n\t}\n\n\treturn nil\n}\n\n// MarshalText implements the encoding.TextMarshaler interface for XML\n// serialization.\nfunc (d Decimal) MarshalText() (text []byte, err error) {\n\treturn []byte(d.String()), nil\n}\n\n// GobEncode implements the gob.GobEncoder interface for gob serialization.\nfunc (d Decimal) GobEncode() ([]byte, error) {\n\treturn d.MarshalBinary()\n}\n\n// GobDecode implements the gob.GobDecoder interface for gob serialization.\nfunc (d *Decimal) GobDecode(data []byte) error {\n\treturn d.UnmarshalBinary(data)\n}\n\n// StringScaled first scales the decimal then calls .String() on it.\n//\n// Deprecated: buggy and unintuitive. Use StringFixed instead.\nfunc (d Decimal) StringScaled(exp int32) string {\n\treturn d.rescale(exp).String()\n}\n\nfunc (d Decimal) string(trimTrailingZeros bool) string {\n\tif d.exp >= 0 {\n\t\treturn d.rescale(0).value.String()\n\t}\n\n\tabs := new(big.Int).Abs(d.value)\n\tstr := abs.String()\n\n\tvar intPart, fractionalPart string\n\n\t// NOTE(vadim): this cast to int will cause bugs if d.exp == INT_MIN\n\t// and you are on a 32-bit machine. Won't fix this super-edge case.\n\tdExpInt := int(d.exp)\n\tif len(str) > -dExpInt {\n\t\tintPart = str[:len(str)+dExpInt]\n\t\tfractionalPart = str[len(str)+dExpInt:]\n\t} else {\n\t\tintPart = \"0\"\n\n\t\tnum0s := -dExpInt - len(str)\n\t\tfractionalPart = strings.Repeat(\"0\", num0s) + str\n\t}\n\n\tif trimTrailingZeros {\n\t\ti := len(fractionalPart) - 1\n\t\tfor ; i >= 0; i-- {\n\t\t\tif fractionalPart[i] != '0' {\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tfractionalPart = fractionalPart[:i+1]\n\t}\n\n\tnumber := intPart\n\tif len(fractionalPart) > 0 {\n\t\tnumber += \".\" + fractionalPart\n\t}\n\n\tif d.value.Sign() < 0 {\n\t\treturn \"-\" + number\n\t}\n\n\treturn number\n}\n\nfunc (d *Decimal) ensureInitialized() {\n\tif d.value == nil {\n\t\td.value = new(big.Int)\n\t}\n}\n\n// Min returns the smallest Decimal that was passed in the arguments.\n//\n// To call this function with an array, you must do:\n//\n//\tMin(arr[0], arr[1:]...)\n//\n// This makes it harder to accidentally call Min with 0 arguments.\nfunc Min(first Decimal, rest ...Decimal) Decimal {\n\tans := first\n\tfor _, item := range rest {\n\t\tif item.Cmp(ans) < 0 {\n\t\t\tans = item\n\t\t}\n\t}\n\treturn ans\n}\n\n// Max returns the largest Decimal that was passed in the arguments.\n//\n// To call this function with an array, you must do:\n//\n//\tMax(arr[0], arr[1:]...)\n//\n// This makes it harder to accidentally call Max with 0 arguments.\nfunc Max(first Decimal, rest ...Decimal) Decimal {\n\tans := first\n\tfor _, item := range rest {\n\t\tif item.Cmp(ans) > 0 {\n\t\t\tans = item\n\t\t}\n\t}\n\treturn ans\n}\n\n// Sum returns the combined total of the provided first and rest Decimals\nfunc Sum(first Decimal, rest ...Decimal) Decimal {\n\ttotal := first\n\tfor _, item := range rest {\n\t\ttotal = total.Add(item)\n\t}\n\n\treturn total\n}\n\n// Avg returns the average value of the provided first and rest Decimals\nfunc Avg(first Decimal, rest ...Decimal) Decimal {\n\tcount := New(int64(len(rest)+1), 0)\n\tsum := Sum(first, rest...)\n\treturn sum.Div(count)\n}\n\n// RescalePair rescales two decimals to common exponential value (minimal exp of both decimals)\nfunc RescalePair(d1 Decimal, d2 Decimal) (Decimal, Decimal) {\n\td1.ensureInitialized()\n\td2.ensureInitialized()\n\n\tif d1.exp < d2.exp {\n\t\treturn d1, d2.rescale(d1.exp)\n\t} else if d1.exp > d2.exp {\n\t\treturn d1.rescale(d2.exp), d2\n\t}\n\n\treturn d1, d2\n}\n\nfunc unquoteIfQuoted(value interface{}) (string, error) {\n\tvar bytes []byte\n\n\tswitch v := value.(type) {\n\tcase string:\n\t\tbytes = []byte(v)\n\tcase []byte:\n\t\tbytes = v\n\tdefault:\n\t\treturn \"\", fmt.Errorf(\"could not convert value '%+v' to byte array of type '%T'\", value, value)\n\t}\n\n\t// If the amount is quoted, strip the quotes\n\tif len(bytes) > 2 && bytes[0] == '\"' && bytes[len(bytes)-1] == '\"' {\n\t\tbytes = bytes[1 : len(bytes)-1]\n\t}\n\treturn string(bytes), nil\n}\n\n// NullDecimal represents a nullable decimal with compatibility for\n// scanning null values from the database.\ntype NullDecimal struct {\n\tDecimal Decimal\n\tValid   bool\n}\n\nfunc NewNullDecimal(d Decimal) NullDecimal {\n\treturn NullDecimal{\n\t\tDecimal: d,\n\t\tValid:   true,\n\t}\n}\n\n// Scan implements the sql.Scanner interface for database deserialization.\nfunc (d *NullDecimal) Scan(value interface{}) error {\n\tif value == nil {\n\t\td.Valid = false\n\t\treturn nil\n\t}\n\td.Valid = true\n\treturn d.Decimal.Scan(value)\n}\n\n// Value implements the driver.Valuer interface for database serialization.\nfunc (d NullDecimal) Value() (driver.Value, error) {\n\tif !d.Valid {\n\t\treturn nil, nil\n\t}\n\treturn d.Decimal.Value()\n}\n\n// UnmarshalJSON implements the json.Unmarshaler interface.\nfunc (d *NullDecimal) UnmarshalJSON(decimalBytes []byte) error {\n\tif string(decimalBytes) == \"null\" {\n\t\td.Valid = false\n\t\treturn nil\n\t}\n\td.Valid = true\n\treturn d.Decimal.UnmarshalJSON(decimalBytes)\n}\n\n// MarshalJSON implements the json.Marshaler interface.\nfunc (d NullDecimal) MarshalJSON() ([]byte, error) {\n\tif !d.Valid {\n\t\treturn []byte(\"null\"), nil\n\t}\n\treturn d.Decimal.MarshalJSON()\n}\n\n// UnmarshalText implements the encoding.TextUnmarshaler interface for XML\n// deserialization\nfunc (d *NullDecimal) UnmarshalText(text []byte) error {\n\tstr := string(text)\n\n\t// check for empty XML or XML without body e.g., <tag></tag>\n\tif str == \"\" {\n\t\td.Valid = false\n\t\treturn nil\n\t}\n\tif err := d.Decimal.UnmarshalText(text); err != nil {\n\t\td.Valid = false\n\t\treturn err\n\t}\n\td.Valid = true\n\treturn nil\n}\n\n// MarshalText implements the encoding.TextMarshaler interface for XML\n// serialization.\nfunc (d NullDecimal) MarshalText() (text []byte, err error) {\n\tif !d.Valid {\n\t\treturn []byte{}, nil\n\t}\n\treturn d.Decimal.MarshalText()\n}\n\n// Trig functions\n\n// Atan returns the arctangent, in radians, of x.\nfunc (d Decimal) Atan() Decimal {\n\tif d.Equal(NewFromFloat(0.0)) {\n\t\treturn d\n\t}\n\tif d.GreaterThan(NewFromFloat(0.0)) {\n\t\treturn d.satan()\n\t}\n\treturn d.Neg().satan().Neg()\n}\n\nfunc (d Decimal) xatan() Decimal {\n\tP0 := NewFromFloat(-8.750608600031904122785e-01)\n\tP1 := NewFromFloat(-1.615753718733365076637e+01)\n\tP2 := NewFromFloat(-7.500855792314704667340e+01)\n\tP3 := NewFromFloat(-1.228866684490136173410e+02)\n\tP4 := NewFromFloat(-6.485021904942025371773e+01)\n\tQ0 := NewFromFloat(2.485846490142306297962e+01)\n\tQ1 := NewFromFloat(1.650270098316988542046e+02)\n\tQ2 := NewFromFloat(4.328810604912902668951e+02)\n\tQ3 := NewFromFloat(4.853903996359136964868e+02)\n\tQ4 := NewFromFloat(1.945506571482613964425e+02)\n\tz := d.Mul(d)\n\tb1 := P0.Mul(z).Add(P1).Mul(z).Add(P2).Mul(z).Add(P3).Mul(z).Add(P4).Mul(z)\n\tb2 := z.Add(Q0).Mul(z).Add(Q1).Mul(z).Add(Q2).Mul(z).Add(Q3).Mul(z).Add(Q4)\n\tz = b1.Div(b2)\n\tz = d.Mul(z).Add(d)\n\treturn z\n}\n\n// satan reduces its argument (known to be positive)\n// to the range [0, 0.66] and calls xatan.\nfunc (d Decimal) satan() Decimal {\n\tMorebits := NewFromFloat(6.123233995736765886130e-17) // pi/2 = PIO2 + Morebits\n\tTan3pio8 := NewFromFloat(2.41421356237309504880)      // tan(3*pi/8)\n\tpi := NewFromFloat(3.14159265358979323846264338327950288419716939937510582097494459)\n\n\tif d.LessThanOrEqual(NewFromFloat(0.66)) {\n\t\treturn d.xatan()\n\t}\n\tif d.GreaterThan(Tan3pio8) {\n\t\treturn pi.Div(NewFromFloat(2.0)).Sub(NewFromFloat(1.0).Div(d).xatan()).Add(Morebits)\n\t}\n\treturn pi.Div(NewFromFloat(4.0)).Add((d.Sub(NewFromFloat(1.0)).Div(d.Add(NewFromFloat(1.0)))).xatan()).Add(NewFromFloat(0.5).Mul(Morebits))\n}\n\n// sin coefficients\nvar _sin = [...]Decimal{\n\tNewFromFloat(1.58962301576546568060e-10), // 0x3de5d8fd1fd19ccd\n\tNewFromFloat(-2.50507477628578072866e-8), // 0xbe5ae5e5a9291f5d\n\tNewFromFloat(2.75573136213857245213e-6),  // 0x3ec71de3567d48a1\n\tNewFromFloat(-1.98412698295895385996e-4), // 0xbf2a01a019bfdf03\n\tNewFromFloat(8.33333333332211858878e-3),  // 0x3f8111111110f7d0\n\tNewFromFloat(-1.66666666666666307295e-1), // 0xbfc5555555555548\n}\n\n// Sin returns the sine of the radian argument x.\nfunc (d Decimal) Sin() Decimal {\n\tPI4A := NewFromFloat(7.85398125648498535156e-1)                             // 0x3fe921fb40000000, Pi/4 split into three parts\n\tPI4B := NewFromFloat(3.77489470793079817668e-8)                             // 0x3e64442d00000000,\n\tPI4C := NewFromFloat(2.69515142907905952645e-15)                            // 0x3ce8469898cc5170,\n\tM4PI := NewFromFloat(1.273239544735162542821171882678754627704620361328125) // 4/pi\n\n\tif d.Equal(NewFromFloat(0.0)) {\n\t\treturn d\n\t}\n\t// make argument positive but save the sign\n\tsign := false\n\tif d.LessThan(NewFromFloat(0.0)) {\n\t\td = d.Neg()\n\t\tsign = true\n\t}\n\n\tj := d.Mul(M4PI).IntPart()    // integer part of x/(Pi/4), as integer for tests on the phase angle\n\ty := NewFromFloat(float64(j)) // integer part of x/(Pi/4), as float\n\n\t// map zeros to origin\n\tif j&1 == 1 {\n\t\tj++\n\t\ty = y.Add(NewFromFloat(1.0))\n\t}\n\tj &= 7 // octant modulo 2Pi radians (360 degrees)\n\t// reflect in x axis\n\tif j > 3 {\n\t\tsign = !sign\n\t\tj -= 4\n\t}\n\tz := d.Sub(y.Mul(PI4A)).Sub(y.Mul(PI4B)).Sub(y.Mul(PI4C)) // Extended precision modular arithmetic\n\tzz := z.Mul(z)\n\n\tif j == 1 || j == 2 {\n\t\tw := zz.Mul(zz).Mul(_cos[0].Mul(zz).Add(_cos[1]).Mul(zz).Add(_cos[2]).Mul(zz).Add(_cos[3]).Mul(zz).Add(_cos[4]).Mul(zz).Add(_cos[5]))\n\t\ty = NewFromFloat(1.0).Sub(NewFromFloat(0.5).Mul(zz)).Add(w)\n\t} else {\n\t\ty = z.Add(z.Mul(zz).Mul(_sin[0].Mul(zz).Add(_sin[1]).Mul(zz).Add(_sin[2]).Mul(zz).Add(_sin[3]).Mul(zz).Add(_sin[4]).Mul(zz).Add(_sin[5])))\n\t}\n\tif sign {\n\t\ty = y.Neg()\n\t}\n\treturn y\n}\n\n// cos coefficients\nvar _cos = [...]Decimal{\n\tNewFromFloat(-1.13585365213876817300e-11), // 0xbda8fa49a0861a9b\n\tNewFromFloat(2.08757008419747316778e-9),   // 0x3e21ee9d7b4e3f05\n\tNewFromFloat(-2.75573141792967388112e-7),  // 0xbe927e4f7eac4bc6\n\tNewFromFloat(2.48015872888517045348e-5),   // 0x3efa01a019c844f5\n\tNewFromFloat(-1.38888888888730564116e-3),  // 0xbf56c16c16c14f91\n\tNewFromFloat(4.16666666666665929218e-2),   // 0x3fa555555555554b\n}\n\n// Cos returns the cosine of the radian argument x.\nfunc (d Decimal) Cos() Decimal {\n\n\tPI4A := NewFromFloat(7.85398125648498535156e-1)                             // 0x3fe921fb40000000, Pi/4 split into three parts\n\tPI4B := NewFromFloat(3.77489470793079817668e-8)                             // 0x3e64442d00000000,\n\tPI4C := NewFromFloat(2.69515142907905952645e-15)                            // 0x3ce8469898cc5170,\n\tM4PI := NewFromFloat(1.273239544735162542821171882678754627704620361328125) // 4/pi\n\n\t// make argument positive\n\tsign := false\n\tif d.LessThan(NewFromFloat(0.0)) {\n\t\td = d.Neg()\n\t}\n\n\tj := d.Mul(M4PI).IntPart()    // integer part of x/(Pi/4), as integer for tests on the phase angle\n\ty := NewFromFloat(float64(j)) // integer part of x/(Pi/4), as float\n\n\t// map zeros to origin\n\tif j&1 == 1 {\n\t\tj++\n\t\ty = y.Add(NewFromFloat(1.0))\n\t}\n\tj &= 7 // octant modulo 2Pi radians (360 degrees)\n\t// reflect in x axis\n\tif j > 3 {\n\t\tsign = !sign\n\t\tj -= 4\n\t}\n\tif j > 1 {\n\t\tsign = !sign\n\t}\n\n\tz := d.Sub(y.Mul(PI4A)).Sub(y.Mul(PI4B)).Sub(y.Mul(PI4C)) // Extended precision modular arithmetic\n\tzz := z.Mul(z)\n\n\tif j == 1 || j == 2 {\n\t\ty = z.Add(z.Mul(zz).Mul(_sin[0].Mul(zz).Add(_sin[1]).Mul(zz).Add(_sin[2]).Mul(zz).Add(_sin[3]).Mul(zz).Add(_sin[4]).Mul(zz).Add(_sin[5])))\n\t} else {\n\t\tw := zz.Mul(zz).Mul(_cos[0].Mul(zz).Add(_cos[1]).Mul(zz).Add(_cos[2]).Mul(zz).Add(_cos[3]).Mul(zz).Add(_cos[4]).Mul(zz).Add(_cos[5]))\n\t\ty = NewFromFloat(1.0).Sub(NewFromFloat(0.5).Mul(zz)).Add(w)\n\t}\n\tif sign {\n\t\ty = y.Neg()\n\t}\n\treturn y\n}\n\nvar _tanP = [...]Decimal{\n\tNewFromFloat(-1.30936939181383777646e+4), // 0xc0c992d8d24f3f38\n\tNewFromFloat(1.15351664838587416140e+6),  // 0x413199eca5fc9ddd\n\tNewFromFloat(-1.79565251976484877988e+7), // 0xc1711fead3299176\n}\nvar _tanQ = [...]Decimal{\n\tNewFromFloat(1.00000000000000000000e+0),\n\tNewFromFloat(1.36812963470692954678e+4),  //0x40cab8a5eeb36572\n\tNewFromFloat(-1.32089234440210967447e+6), //0xc13427bc582abc96\n\tNewFromFloat(2.50083801823357915839e+7),  //0x4177d98fc2ead8ef\n\tNewFromFloat(-5.38695755929454629881e+7), //0xc189afe03cbe5a31\n}\n\n// Tan returns the tangent of the radian argument x.\nfunc (d Decimal) Tan() Decimal {\n\n\tPI4A := NewFromFloat(7.85398125648498535156e-1)                             // 0x3fe921fb40000000, Pi/4 split into three parts\n\tPI4B := NewFromFloat(3.77489470793079817668e-8)                             // 0x3e64442d00000000,\n\tPI4C := NewFromFloat(2.69515142907905952645e-15)                            // 0x3ce8469898cc5170,\n\tM4PI := NewFromFloat(1.273239544735162542821171882678754627704620361328125) // 4/pi\n\n\tif d.Equal(NewFromFloat(0.0)) {\n\t\treturn d\n\t}\n\n\t// make argument positive but save the sign\n\tsign := false\n\tif d.LessThan(NewFromFloat(0.0)) {\n\t\td = d.Neg()\n\t\tsign = true\n\t}\n\n\tj := d.Mul(M4PI).IntPart()    // integer part of x/(Pi/4), as integer for tests on the phase angle\n\ty := NewFromFloat(float64(j)) // integer part of x/(Pi/4), as float\n\n\t// map zeros to origin\n\tif j&1 == 1 {\n\t\tj++\n\t\ty = y.Add(NewFromFloat(1.0))\n\t}\n\n\tz := d.Sub(y.Mul(PI4A)).Sub(y.Mul(PI4B)).Sub(y.Mul(PI4C)) // Extended precision modular arithmetic\n\tzz := z.Mul(z)\n\n\tif zz.GreaterThan(NewFromFloat(1e-14)) {\n\t\tw := zz.Mul(_tanP[0].Mul(zz).Add(_tanP[1]).Mul(zz).Add(_tanP[2]))\n\t\tx := zz.Add(_tanQ[1]).Mul(zz).Add(_tanQ[2]).Mul(zz).Add(_tanQ[3]).Mul(zz).Add(_tanQ[4])\n\t\ty = z.Add(z.Mul(w.Div(x)))\n\t} else {\n\t\ty = z\n\t}\n\tif j&2 == 2 {\n\t\ty = NewFromFloat(-1.0).Div(y)\n\t}\n\tif sign {\n\t\ty = y.Neg()\n\t}\n\treturn y\n}\n"
        },
        {
          "name": "decimal_bench_test.go",
          "type": "blob",
          "size": 5.9091796875,
          "content": "package decimal\n\nimport (\n\t\"fmt\"\n\t\"math\"\n\t\"math/big\"\n\t\"math/rand\"\n\t\"sort\"\n\t\"strconv\"\n\t\"testing\"\n)\n\ntype DecimalSlice []Decimal\n\nfunc (p DecimalSlice) Len() int           { return len(p) }\nfunc (p DecimalSlice) Swap(i, j int)      { p[i], p[j] = p[j], p[i] }\nfunc (p DecimalSlice) Less(i, j int) bool { return p[i].Cmp(p[j]) < 0 }\n\nfunc BenchmarkNewFromFloatWithExponent(b *testing.B) {\n\trng := rand.New(rand.NewSource(0xdead1337))\n\tin := make([]float64, b.N)\n\tfor i := range in {\n\t\tin[i] = rng.NormFloat64() * 10e20\n\t}\n\tb.ReportAllocs()\n\tb.StartTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\tin := rng.NormFloat64() * 10e20\n\t\t_ = NewFromFloatWithExponent(in, math.MinInt32)\n\t}\n}\n\nfunc BenchmarkNewFromFloat(b *testing.B) {\n\trng := rand.New(rand.NewSource(0xdead1337))\n\tin := make([]float64, b.N)\n\tfor i := range in {\n\t\tin[i] = rng.NormFloat64() * 10e20\n\t}\n\tb.ReportAllocs()\n\tb.StartTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\t_ = NewFromFloat(in[i])\n\t}\n}\n\nfunc BenchmarkNewFromStringFloat(b *testing.B) {\n\trng := rand.New(rand.NewSource(0xdead1337))\n\tin := make([]float64, b.N)\n\tfor i := range in {\n\t\tin[i] = rng.NormFloat64() * 10e20\n\t}\n\tb.ReportAllocs()\n\tb.StartTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\tin := strconv.FormatFloat(in[i], 'f', -1, 64)\n\t\t_, _ = NewFromString(in)\n\t}\n}\n\nfunc Benchmark_FloorFast(b *testing.B) {\n\tinput := New(200, 2)\n\tb.ResetTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\tinput.Floor()\n\t}\n}\n\nfunc Benchmark_FloorRegular(b *testing.B) {\n\tinput := New(200, -2)\n\tb.ResetTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\tinput.Floor()\n\t}\n}\n\nfunc Benchmark_DivideOriginal(b *testing.B) {\n\ttcs := createDivTestCases()\n\tb.ResetTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\tfor _, tc := range tcs {\n\t\t\td := tc.d\n\t\t\tif sign(tc.d2) == 0 {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\td2 := tc.d2\n\t\t\tprec := tc.prec\n\t\t\ta := d.DivOld(d2, int(prec))\n\t\t\tif sign(a) > 2 {\n\t\t\t\tpanic(\"dummy panic\")\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc Benchmark_DivideNew(b *testing.B) {\n\ttcs := createDivTestCases()\n\tb.ResetTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\tfor _, tc := range tcs {\n\t\t\td := tc.d\n\t\t\tif sign(tc.d2) == 0 {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\td2 := tc.d2\n\t\t\tprec := tc.prec\n\t\t\ta := d.DivRound(d2, prec)\n\t\t\tif sign(a) > 2 {\n\t\t\t\tpanic(\"dummy panic\")\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc BenchmarkDecimal_RoundCash_Five(b *testing.B) {\n\tconst want = \"3.50\"\n\tfor i := 0; i < b.N; i++ {\n\t\tval := New(3478, -3)\n\t\tif have := val.StringFixedCash(5); have != want {\n\t\t\tb.Fatalf(\"\\nHave: %q\\nWant: %q\", have, want)\n\t\t}\n\t}\n}\n\nfunc numDigits(b *testing.B, want int, val Decimal) {\n\tb.Helper()\n\tfor i := 0; i < b.N; i++ {\n\t\tif have := val.NumDigits(); have != want {\n\t\t\tb.Fatalf(\"\\nHave: %d\\nWant: %d\", have, want)\n\t\t}\n\t}\n}\n\nfunc BenchmarkDecimal_NumDigits10(b *testing.B) {\n\tnumDigits(b, 10, New(3478512345, -3))\n}\n\nfunc BenchmarkDecimal_NumDigits100(b *testing.B) {\n\ts := make([]byte, 102)\n\tfor i := range s {\n\t\ts[i] = byte('0' + i%10)\n\t}\n\ts[0] = '-'\n\ts[100] = '.'\n\td, err := NewFromString(string(s))\n\tif err != nil {\n\t\tb.Log(d)\n\t\tb.Error(err)\n\t}\n\tnumDigits(b, 100, d)\n}\n\nfunc Benchmark_Cmp(b *testing.B) {\n\tdecimals := DecimalSlice([]Decimal{})\n\tfor i := 0; i < 1000000; i++ {\n\t\tdecimals = append(decimals, New(int64(i), 0))\n\t}\n\tb.ResetTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\tsort.Sort(decimals)\n\t}\n}\n\nfunc BenchmarkDecimal_Add_different_precision(b *testing.B) {\n\td1 := NewFromFloat(1000.123)\n\td2 := NewFromFloat(500).Mul(NewFromFloat(0.12))\n\n\tb.ReportAllocs()\n\tb.StartTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\td1.Add(d2)\n\t}\n}\n\nfunc BenchmarkDecimal_Sub_different_precision(b *testing.B) {\n\td1 := NewFromFloat(1000.123)\n\td2 := NewFromFloat(500).Mul(NewFromFloat(0.12))\n\n\tb.ReportAllocs()\n\tb.StartTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\td1.Sub(d2)\n\t}\n}\n\nfunc BenchmarkDecimal_Add_same_precision(b *testing.B) {\n\td1 := NewFromFloat(1000.123)\n\td2 := NewFromFloat(500.123)\n\n\tb.ReportAllocs()\n\tb.StartTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\td1.Add(d2)\n\t}\n}\n\nfunc BenchmarkDecimal_Sub_same_precision(b *testing.B) {\n\td1 := NewFromFloat(1000.123)\n\td2 := NewFromFloat(500.123)\n\n\tb.ReportAllocs()\n\tb.StartTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\td1.Add(d2)\n\t}\n}\n\nfunc BenchmarkDecimal_IsInteger(b *testing.B) {\n\td := RequireFromString(\"12.000\")\n\n\tb.ReportAllocs()\n\tb.StartTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\td.IsInteger()\n\t}\n}\n\nfunc BenchmarkDecimal_Pow(b *testing.B) {\n\td1 := RequireFromString(\"5.2\")\n\td2 := RequireFromString(\"6.3\")\n\n\tfor i := 0; i < b.N; i++ {\n\t\td1.Pow(d2)\n\t}\n}\n\nfunc BenchmarkDecimal_PowWithPrecision(b *testing.B) {\n\td1 := RequireFromString(\"5.2\")\n\td2 := RequireFromString(\"6.3\")\n\n\tfor i := 0; i < b.N; i++ {\n\t\t_, _ = d1.PowWithPrecision(d2, 8)\n\t}\n}\nfunc BenchmarkDecimal_PowInt32(b *testing.B) {\n\td1 := RequireFromString(\"5.2\")\n\td2 := int32(10)\n\n\tfor i := 0; i < b.N; i++ {\n\t\t_, _ = d1.PowInt32(d2)\n\t}\n}\n\nfunc BenchmarkDecimal_PowBigInt(b *testing.B) {\n\td1 := RequireFromString(\"5.2\")\n\td2 := big.NewInt(10)\n\n\tfor i := 0; i < b.N; i++ {\n\t\t_, _ = d1.PowBigInt(d2)\n\t}\n}\n\nfunc BenchmarkDecimal_NewFromString(b *testing.B) {\n\tcount := 72\n\tprices := make([]string, 0, count)\n\tfor i := 1; i <= count; i++ {\n\t\tprices = append(prices, fmt.Sprintf(\"%d.%d\", i*100, i))\n\t}\n\n\tb.ReportAllocs()\n\tb.ResetTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\tfor _, p := range prices {\n\t\t\td, err := NewFromString(p)\n\t\t\tif err != nil {\n\t\t\t\tb.Log(d)\n\t\t\t\tb.Error(err)\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc BenchmarkDecimal_NewFromString_large_number(b *testing.B) {\n\tcount := 72\n\tprices := make([]string, 0, count)\n\tfor i := 1; i <= count; i++ {\n\t\tprices = append(prices, \"9323372036854775807.9223372036854775807\")\n\t}\n\n\tb.ReportAllocs()\n\tb.ResetTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\tfor _, p := range prices {\n\t\t\td, err := NewFromString(p)\n\t\t\tif err != nil {\n\t\t\t\tb.Log(d)\n\t\t\t\tb.Error(err)\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc BenchmarkDecimal_ExpHullAbraham(b *testing.B) {\n\tb.ResetTimer()\n\n\td := RequireFromString(\"30.412346346346\")\n\n\tb.ReportAllocs()\n\tb.ResetTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\t_, _ = d.ExpHullAbrham(10)\n\t}\n}\n\nfunc BenchmarkDecimal_ExpTaylor(b *testing.B) {\n\tb.ResetTimer()\n\n\td := RequireFromString(\"30.412346346346\")\n\n\tb.ReportAllocs()\n\tb.ResetTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\t_, _ = d.ExpTaylor(10)\n\t}\n}\n"
        },
        {
          "name": "decimal_test.go",
          "type": "blob",
          "size": 103.6904296875,
          "content": "package decimal\n\nimport (\n\t\"database/sql/driver\"\n\t\"encoding/json\"\n\t\"encoding/xml\"\n\t\"fmt\"\n\t\"math\"\n\t\"math/big\"\n\t\"math/rand\"\n\t\"reflect\"\n\t\"regexp\"\n\t\"strconv\"\n\t\"strings\"\n\t\"testing\"\n\t\"testing/quick\"\n\t\"time\"\n)\n\ntype testEnt struct {\n\tfloat   float64\n\tshort   string\n\texact   string\n\tinexact string\n}\n\nvar testTable = []*testEnt{\n\t{3.141592653589793, \"3.141592653589793\", \"\", \"3.14159265358979300000000000000000000000000000000000004\"},\n\t{3, \"3\", \"\", \"3.0000000000000000000000002\"},\n\t{1234567890123456, \"1234567890123456\", \"\", \"1234567890123456.00000000000000002\"},\n\t{1234567890123456000, \"1234567890123456000\", \"\", \"1234567890123456000.0000000000000008\"},\n\t{1234.567890123456, \"1234.567890123456\", \"\", \"1234.5678901234560000000000000009\"},\n\t{.1234567890123456, \"0.1234567890123456\", \"\", \"0.12345678901234560000000000006\"},\n\t{0, \"0\", \"\", \"0.000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001\"},\n\t{.1111111111111110, \"0.111111111111111\", \"\", \"0.111111111111111000000000000000009\"},\n\t{.1111111111111111, \"0.1111111111111111\", \"\", \"0.111111111111111100000000000000000000023423545644534234\"},\n\t{.1111111111111119, \"0.1111111111111119\", \"\", \"0.111111111111111900000000000000000000000000000000000134123984192834\"},\n\t{.000000000000000001, \"0.000000000000000001\", \"\", \"0.00000000000000000100000000000000000000000000000000012341234\"},\n\t{.000000000000000002, \"0.000000000000000002\", \"\", \"0.0000000000000000020000000000000000000012341234123\"},\n\t{.000000000000000003, \"0.000000000000000003\", \"\", \"0.00000000000000000299999999999999999999999900000000000123412341234\"},\n\t{.000000000000000005, \"0.000000000000000005\", \"\", \"0.00000000000000000500000000000000000023412341234\"},\n\t{.000000000000000008, \"0.000000000000000008\", \"\", \"0.0000000000000000080000000000000000001241234432\"},\n\t{.1000000000000001, \"0.1000000000000001\", \"\", \"0.10000000000000010000000000000012341234\"},\n\t{.1000000000000002, \"0.1000000000000002\", \"\", \"0.10000000000000020000000000001234123412\"},\n\t{.1000000000000003, \"0.1000000000000003\", \"\", \"0.1000000000000003000000000000001234123412\"},\n\t{.1000000000000005, \"0.1000000000000005\", \"\", \"0.1000000000000005000000000000000006441234\"},\n\t{.1000000000000008, \"0.1000000000000008\", \"\", \"0.100000000000000800000000000000000009999999999999999999999999999\"},\n\t{1e25, \"10000000000000000000000000\", \"\", \"\"},\n\t{1.5e14, \"150000000000000\", \"\", \"\"},\n\t{1.5e15, \"1500000000000000\", \"\", \"\"},\n\t{1.5e16, \"15000000000000000\", \"\", \"\"},\n\t{1.0001e25, \"10001000000000000000000000\", \"\", \"\"},\n\t{1.0001000000000000033e25, \"10001000000000000000000000\", \"\", \"\"},\n\t{2e25, \"20000000000000000000000000\", \"\", \"\"},\n\t{4e25, \"40000000000000000000000000\", \"\", \"\"},\n\t{8e25, \"80000000000000000000000000\", \"\", \"\"},\n\t{1e250, \"10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\", \"\", \"\"},\n\t{2e250, \"20000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\", \"\", \"\"},\n\t{math.MaxInt64, strconv.FormatFloat(float64(math.MaxInt64), 'f', -1, 64), \"\", strconv.FormatInt(math.MaxInt64, 10)},\n\t{1.29067116156722e-309, \"0.00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000129067116156722\", \"\", \"0.000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001290671161567218558822290567835270536800098852722416870074139002112543896676308448335063375297788379444685193974290737962187240854947838776604607190387984577130572928111657710645015086812756013489109884753559084166516937690932698276436869274093950997935137476803610007959500457935217950764794724766740819156974617155861568214427828145972181876775307023388139991104942469299524961281641158436752347582767153796914843896176260096039358494077706152272661453132497761307744086665088096215425146090058519888494342944692629602847826300550628670375451325582843627504604013541465361435761965354140678551369499812124085312128659002910905639984075064968459581691226705666561364681985266583563078466180095375402399087817404368974165082030458595596655868575908243656158447265625000000000000000000000000000000000000004440000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\"},\n\t// go Issue 29491.\n\t{498484681984085570, \"498484681984085570\", \"\", \"\"},\n\t{5.8339553793802237e+23, \"583395537938022370000000\", \"\", \"\"},\n}\n\nvar testTableScientificNotation = map[string]string{\n\t\"1e9\":        \"1000000000\",\n\t\"2.41E-3\":    \"0.00241\",\n\t\"24.2E-4\":    \"0.00242\",\n\t\"243E-5\":     \"0.00243\",\n\t\"1e-5\":       \"0.00001\",\n\t\"245E3\":      \"245000\",\n\t\"1.2345E-1\":  \"0.12345\",\n\t\"0e5\":        \"0\",\n\t\"0e-5\":       \"0\",\n\t\"0.e0\":       \"0\",\n\t\".0e0\":       \"0\",\n\t\"123.456e0\":  \"123.456\",\n\t\"123.456e2\":  \"12345.6\",\n\t\"123.456e10\": \"1234560000000\",\n}\n\nfunc init() {\n\tfor _, s := range testTable {\n\t\ts.exact = strconv.FormatFloat(s.float, 'f', 1500, 64)\n\t\tif strings.ContainsRune(s.exact, '.') {\n\t\t\ts.exact = strings.TrimRight(s.exact, \"0\")\n\t\t\ts.exact = strings.TrimRight(s.exact, \".\")\n\t\t}\n\t}\n\n\t// add negatives\n\twithNeg := testTable[:]\n\tfor _, s := range testTable {\n\t\tif s.float > 0 && s.short != \"0\" && s.exact != \"0\" {\n\t\t\twithNeg = append(withNeg, &testEnt{-s.float, \"-\" + s.short, \"-\" + s.exact, \"-\" + s.inexact})\n\t\t}\n\t}\n\ttestTable = withNeg\n\n\tfor e, s := range testTableScientificNotation {\n\t\tif string(e[0]) != \"-\" && s != \"0\" {\n\t\t\ttestTableScientificNotation[\"-\"+e] = \"-\" + s\n\t\t}\n\t}\n}\n\nfunc TestNewFromFloat(t *testing.T) {\n\tfor _, x := range testTable {\n\t\ts := x.short\n\t\td := NewFromFloat(x.float)\n\t\tif d.String() != s {\n\t\t\tt.Errorf(\"expected %s, got %s (float: %v) (%s, %d)\",\n\t\t\t\ts, d.String(), x.float,\n\t\t\t\td.value.String(), d.exp)\n\t\t}\n\t}\n\n\tshouldPanicOn := []float64{\n\t\tmath.NaN(),\n\t\tmath.Inf(1),\n\t\tmath.Inf(-1),\n\t}\n\n\tfor _, n := range shouldPanicOn {\n\t\tvar d Decimal\n\t\tif !didPanic(func() { d = NewFromFloat(n) }) {\n\t\t\tt.Fatalf(\"Expected panic when creating a Decimal from %v, got %v instead\", n, d.String())\n\t\t}\n\t}\n}\n\nfunc TestNewFromFloatRandom(t *testing.T) {\n\tn := 0\n\trng := rand.New(rand.NewSource(0xdead1337))\n\tfor {\n\t\tn++\n\t\tif n == 10 {\n\t\t\tbreak\n\t\t}\n\t\tin := (rng.Float64() - 0.5) * math.MaxFloat64 * 2\n\t\twant, err := NewFromString(strconv.FormatFloat(in, 'f', -1, 64))\n\t\tif err != nil {\n\t\t\tt.Error(err)\n\t\t\tcontinue\n\t\t}\n\t\tgot := NewFromFloat(in)\n\t\tif !want.Equal(got) {\n\t\t\tt.Errorf(\"in: %v, expected %s (%s, %d), got %s (%s, %d) \",\n\t\t\t\tin, want.String(), want.value.String(), want.exp,\n\t\t\t\tgot.String(), got.value.String(), got.exp)\n\t\t}\n\t}\n}\n\nfunc TestNewFromFloatQuick(t *testing.T) {\n\terr := quick.Check(func(f float64) bool {\n\t\twant, werr := NewFromString(strconv.FormatFloat(f, 'f', -1, 64))\n\t\tif werr != nil {\n\t\t\treturn true\n\t\t}\n\t\tgot := NewFromFloat(f)\n\t\treturn got.Equal(want)\n\t}, &quick.Config{})\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n}\n\nfunc TestNewFromFloat32Random(t *testing.T) {\n\tn := 0\n\trng := rand.New(rand.NewSource(0xdead1337))\n\tfor {\n\t\tn++\n\t\tif n == 10 {\n\t\t\tbreak\n\t\t}\n\t\tin := float32((rng.Float64() - 0.5) * math.MaxFloat32 * 2)\n\t\twant, err := NewFromString(strconv.FormatFloat(float64(in), 'f', -1, 32))\n\t\tif err != nil {\n\t\t\tt.Error(err)\n\t\t\tcontinue\n\t\t}\n\t\tgot := NewFromFloat32(in)\n\t\tif !want.Equal(got) {\n\t\t\tt.Errorf(\"in: %v, expected %s (%s, %d), got %s (%s, %d) \",\n\t\t\t\tin, want.String(), want.value.String(), want.exp,\n\t\t\t\tgot.String(), got.value.String(), got.exp)\n\t\t}\n\t}\n}\n\nfunc TestNewFromFloat32Quick(t *testing.T) {\n\terr := quick.Check(func(f float32) bool {\n\t\twant, werr := NewFromString(strconv.FormatFloat(float64(f), 'f', -1, 32))\n\t\tif werr != nil {\n\t\t\treturn true\n\t\t}\n\t\tgot := NewFromFloat32(f)\n\t\treturn got.Equal(want)\n\t}, &quick.Config{})\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n}\n\nfunc TestNewFromString(t *testing.T) {\n\tfor _, x := range testTable {\n\t\ts := x.short\n\t\td, err := NewFromString(s)\n\t\tif err != nil {\n\t\t\tt.Errorf(\"error while parsing %s\", s)\n\t\t} else if d.String() != s {\n\t\t\tt.Errorf(\"expected %s, got %s (%s, %d)\",\n\t\t\t\ts, d.String(),\n\t\t\t\td.value.String(), d.exp)\n\t\t}\n\t}\n\n\tfor _, x := range testTable {\n\t\ts := x.exact\n\t\td, err := NewFromString(s)\n\t\tif err != nil {\n\t\t\tt.Errorf(\"error while parsing %s\", s)\n\t\t} else if d.String() != s {\n\t\t\tt.Errorf(\"expected %s, got %s (%s, %d)\",\n\t\t\t\ts, d.String(),\n\t\t\t\td.value.String(), d.exp)\n\t\t}\n\t}\n\n\tfor e, s := range testTableScientificNotation {\n\t\td, err := NewFromString(e)\n\t\tif err != nil {\n\t\t\tt.Errorf(\"error while parsing %s\", e)\n\t\t} else if d.String() != s {\n\t\t\tt.Errorf(\"expected %s, got %s (%s, %d)\",\n\t\t\t\ts, d.String(),\n\t\t\t\td.value.String(), d.exp)\n\t\t}\n\t}\n}\n\nfunc TestNewFromFormattedString(t *testing.T) {\n\tfor _, testCase := range []struct {\n\t\tFormatted string\n\t\tExpected  string\n\t\tReplRegex *regexp.Regexp\n\t}{\n\t\t{\"$10.99\", \"10.99\", regexp.MustCompile(\"[$]\")},\n\t\t{\"$ 12.1\", \"12.1\", regexp.MustCompile(\"[$\\\\s]\")},\n\t\t{\"$61,690.99\", \"61690.99\", regexp.MustCompile(\"[$,]\")},\n\t\t{\"1_000_000.00\", \"1000000.00\", regexp.MustCompile(\"[_]\")},\n\t\t{\"41,410.00\", \"41410.00\", regexp.MustCompile(\"[,]\")},\n\t\t{\"5200 USD\", \"5200\", regexp.MustCompile(\"[USD\\\\s]\")},\n\t} {\n\t\tdFormatted, err := NewFromFormattedString(testCase.Formatted, testCase.ReplRegex)\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\n\t\tdExact, err := NewFromString(testCase.Expected)\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\n\t\tif !dFormatted.Equal(dExact) {\n\t\t\tt.Errorf(\"expect %s, got %s\", dExact, dFormatted)\n\t\t}\n\t}\n}\n\nfunc TestFloat64(t *testing.T) {\n\tfor _, x := range testTable {\n\t\tif x.inexact == \"\" || x.inexact == \"-\" {\n\t\t\tcontinue\n\t\t}\n\t\ts := x.exact\n\t\td, err := NewFromString(s)\n\t\tif err != nil {\n\t\t\tt.Errorf(\"error while parsing %s\", s)\n\t\t} else if f, exact := d.Float64(); !exact || f != x.float {\n\t\t\tt.Errorf(\"cannot represent exactly %s\", s)\n\t\t}\n\t\ts = x.inexact\n\t\td, err = NewFromString(s)\n\t\tif err != nil {\n\t\t\tt.Errorf(\"error while parsing %s\", s)\n\t\t} else if f, exact := d.Float64(); exact || f != x.float {\n\t\t\tt.Errorf(\"%s should be represented inexactly\", s)\n\t\t}\n\t}\n}\n\nfunc TestNewFromStringErrs(t *testing.T) {\n\ttests := []string{\n\t\t\"\",\n\t\t\"qwert\",\n\t\t\"-\",\n\t\t\".\",\n\t\t\"-.\",\n\t\t\".-\",\n\t\t\"234-.56\",\n\t\t\"234-56\",\n\t\t\"2-\",\n\t\t\"..\",\n\t\t\"2..\",\n\t\t\"..2\",\n\t\t\".5.2\",\n\t\t\"8..2\",\n\t\t\"8.1.\",\n\t\t\"1e\",\n\t\t\"1-e\",\n\t\t\"1e9e\",\n\t\t\"1ee9\",\n\t\t\"1ee\",\n\t\t\"1eE\",\n\t\t\"1e-\",\n\t\t\"1e-.\",\n\t\t\"1e1.2\",\n\t\t\"123.456e1.3\",\n\t\t\"1e-1.2\",\n\t\t\"123.456e-1.3\",\n\t\t\"123.456Easdf\",\n\t\t\"123.456e\" + strconv.FormatInt(math.MinInt64, 10),\n\t\t\"123.456e\" + strconv.FormatInt(math.MinInt32, 10),\n\t\t\"512.99 USD\",\n\t\t\"$99.99\",\n\t\t\"51,850.00\",\n\t\t\"20_000_000.00\",\n\t\t\"$20_000_000.00\",\n\t}\n\n\tfor _, s := range tests {\n\t\t_, err := NewFromString(s)\n\n\t\tif err == nil {\n\t\t\tt.Errorf(\"error expected when parsing %s\", s)\n\t\t}\n\t}\n}\n\nfunc TestNewFromStringDeepEquals(t *testing.T) {\n\ttype StrCmp struct {\n\t\tstr1     string\n\t\tstr2     string\n\t\texpected bool\n\t}\n\ttests := []StrCmp{\n\t\t{\"1\", \"1\", true},\n\t\t{\"1.0\", \"1.0\", true},\n\t\t{\"10\", \"10.0\", false},\n\t\t{\"1.1\", \"1.10\", false},\n\t\t{\"1.001\", \"1.01\", false},\n\t}\n\n\tfor _, cmp := range tests {\n\t\td1, err1 := NewFromString(cmp.str1)\n\t\td2, err2 := NewFromString(cmp.str2)\n\n\t\tif err1 != nil || err2 != nil {\n\t\t\tt.Errorf(\"error parsing strings to decimals\")\n\t\t}\n\n\t\tif reflect.DeepEqual(d1, d2) != cmp.expected {\n\t\t\tt.Errorf(\"comparison result is different from expected results for %s and %s\",\n\t\t\t\tcmp.str1, cmp.str2)\n\t\t}\n\t}\n}\n\nfunc TestRequireFromString(t *testing.T) {\n\ts := \"1.23\"\n\tdefer func() {\n\t\terr := recover()\n\t\tif err != nil {\n\t\t\tt.Errorf(\"error while parsing %s\", s)\n\t\t}\n\t}()\n\n\td := RequireFromString(s)\n\tif d.String() != s {\n\t\tt.Errorf(\"expected %s, got %s (%s, %d)\",\n\t\t\ts, d.String(),\n\t\t\td.value.String(), d.exp)\n\t}\n}\n\nfunc TestRequireFromStringErrs(t *testing.T) {\n\ts := \"qwert\"\n\tvar d Decimal\n\tvar err interface{}\n\n\tfunc(d Decimal) {\n\t\tdefer func() {\n\t\t\terr = recover()\n\t\t}()\n\n\t\tRequireFromString(s)\n\t}(d)\n\n\tif err == nil {\n\t\tt.Errorf(\"panic expected when parsing %s\", s)\n\t}\n}\n\nfunc TestNewFromFloatWithExponent(t *testing.T) {\n\ttype Inp struct {\n\t\tfloat float64\n\t\texp   int32\n\t}\n\t// some tests are taken from here https://www.cockroachlabs.com/blog/rounding-implementations-in-go/\n\ttests := map[Inp]string{\n\t\tInp{123.4, -3}:                 \"123.4\",\n\t\tInp{123.4, -1}:                 \"123.4\",\n\t\tInp{123.412345, 1}:             \"120\",\n\t\tInp{123.412345, 0}:             \"123\",\n\t\tInp{123.412345, -5}:            \"123.41235\",\n\t\tInp{123.412345, -6}:            \"123.412345\",\n\t\tInp{123.412345, -7}:            \"123.412345\",\n\t\tInp{123.412345, -28}:           \"123.4123450000000019599610823207\",\n\t\tInp{1230000000, 3}:             \"1230000000\",\n\t\tInp{123.9999999999999999, -7}:  \"124\",\n\t\tInp{123.8989898999999999, -7}:  \"123.8989899\",\n\t\tInp{0.49999999999999994, 0}:    \"0\",\n\t\tInp{0.5, 0}:                    \"1\",\n\t\tInp{0., -1000}:                 \"0\",\n\t\tInp{0.5000000000000001, 0}:     \"1\",\n\t\tInp{1.390671161567e-309, 0}:    \"0\",\n\t\tInp{4.503599627370497e+15, 0}:  \"4503599627370497\",\n\t\tInp{4.503599627370497e+60, 0}:  \"4503599627370497110902645731364739935039854989106233267453952\",\n\t\tInp{4.503599627370497e+60, 1}:  \"4503599627370497110902645731364739935039854989106233267453950\",\n\t\tInp{4.503599627370497e+60, -1}: \"4503599627370497110902645731364739935039854989106233267453952\",\n\t\tInp{50, 2}:                     \"100\",\n\t\tInp{49, 2}:                     \"0\",\n\t\tInp{50, 3}:                     \"0\",\n\t\t// subnormals\n\t\tInp{1.390671161567e-309, -2000}: \"0.000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001390671161567000864431395448332752540137009987788957394095829635554502771758698872408926974382819387852542087331897381878220271350970912568035007740861074263206736245957501456549756342151614772544950978154339064833880234531754156635411349342950306987480369774780312897442981323940546749863054846093718407237782253156822124910364044261653195961209878120072488178603782495270845071470243842997312255994555557251870400944414666445871039673491570643357351279578519863428540219295076767898526278029257129758694673164251056158277568765100904638511604478844087596428177947970563689475826736810456067108202083804368114484417399279328807983736233036662284338182105684628835292230438999173947056675615385756827890872955322265625\",\n\t\tInp{1.390671161567e-309, -862}:  \"0.0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000013906711615670008644313954483327525401370099877889573940958296355545027717586988724089269743828193878525420873318973818782202713509709125680350077408610742632067362459575014565497563421516147725449509781543390648338802345317541566354113493429503069874803697747803128974429813239405467498630548460937184072377822531568221249103640442616531959612098781200724881786037824952708450714702438429973122559945555572518704009444146664458710396734915706433573512795785198634285402192950767678985262780292571297586946731642510561582775687651009046385116044788440876\",\n\t\tInp{1.390671161567e-309, -863}:  \"0.0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000013906711615670008644313954483327525401370099877889573940958296355545027717586988724089269743828193878525420873318973818782202713509709125680350077408610742632067362459575014565497563421516147725449509781543390648338802345317541566354113493429503069874803697747803128974429813239405467498630548460937184072377822531568221249103640442616531959612098781200724881786037824952708450714702438429973122559945555572518704009444146664458710396734915706433573512795785198634285402192950767678985262780292571297586946731642510561582775687651009046385116044788440876\",\n\t}\n\n\t// add negatives\n\tfor p, s := range tests {\n\t\tif p.float > 0 {\n\t\t\tif s != \"0\" {\n\t\t\t\ttests[Inp{-p.float, p.exp}] = \"-\" + s\n\t\t\t} else {\n\t\t\t\ttests[Inp{-p.float, p.exp}] = \"0\"\n\t\t\t}\n\t\t}\n\t}\n\n\tfor input, s := range tests {\n\t\td := NewFromFloatWithExponent(input.float, input.exp)\n\t\tif d.String() != s {\n\t\t\tt.Errorf(\"expected %s, got %s (%s, %d)\",\n\t\t\t\ts, d.String(),\n\t\t\t\td.value.String(), d.exp)\n\t\t}\n\t}\n\n\tshouldPanicOn := []float64{\n\t\tmath.NaN(),\n\t\tmath.Inf(1),\n\t\tmath.Inf(-1),\n\t}\n\n\tfor _, n := range shouldPanicOn {\n\t\tvar d Decimal\n\t\tif !didPanic(func() { d = NewFromFloatWithExponent(n, 0) }) {\n\t\t\tt.Fatalf(\"Expected panic when creating a Decimal from %v, got %v instead\", n, d.String())\n\t\t}\n\t}\n}\n\nfunc TestNewFromInt(t *testing.T) {\n\ttests := map[int64]string{\n\t\t0:                    \"0\",\n\t\t1:                    \"1\",\n\t\t323412345:            \"323412345\",\n\t\t9223372036854775807:  \"9223372036854775807\",\n\t\t-9223372036854775808: \"-9223372036854775808\",\n\t}\n\n\t// add negatives\n\tfor p, s := range tests {\n\t\tif p > 0 {\n\t\t\ttests[-p] = \"-\" + s\n\t\t}\n\t}\n\n\tfor input, s := range tests {\n\t\td := NewFromInt(input)\n\t\tif d.String() != s {\n\t\t\tt.Errorf(\"expected %s, got %s (%s, %d)\",\n\t\t\t\ts, d.String(),\n\t\t\t\td.value.String(), d.exp)\n\t\t}\n\t}\n}\n\nfunc TestNewFromInt32(t *testing.T) {\n\ttests := map[int32]string{\n\t\t0:           \"0\",\n\t\t1:           \"1\",\n\t\t323412345:   \"323412345\",\n\t\t2147483647:  \"2147483647\",\n\t\t-2147483648: \"-2147483648\",\n\t}\n\n\t// add negatives\n\tfor p, s := range tests {\n\t\tif p > 0 {\n\t\t\ttests[-p] = \"-\" + s\n\t\t}\n\t}\n\n\tfor input, s := range tests {\n\t\td := NewFromInt32(input)\n\t\tif d.String() != s {\n\t\t\tt.Errorf(\"expected %s, got %s (%s, %d)\",\n\t\t\t\ts, d.String(),\n\t\t\t\td.value.String(), d.exp)\n\t\t}\n\t}\n}\n\nfunc TestNewFromUint64(t *testing.T) {\n\ttests := map[uint64]string{\n\t\t0:                    \"0\",\n\t\t1:                    \"1\",\n\t\t323412345:            \"323412345\",\n\t\t9223372036854775807:  \"9223372036854775807\",\n\t\t18446744073709551615: \"18446744073709551615\",\n\t}\n\n\tfor input, s := range tests {\n\t\td := NewFromUint64(input)\n\t\tif d.String() != s {\n\t\t\tt.Errorf(\"expected %s, got %s (%s, %d)\",\n\t\t\t\ts, d.String(),\n\t\t\t\td.value.String(), d.exp)\n\t\t}\n\t}\n}\n\nfunc TestNewFromBigIntWithExponent(t *testing.T) {\n\ttype Inp struct {\n\t\tval *big.Int\n\t\texp int32\n\t}\n\ttests := map[Inp]string{\n\t\tInp{big.NewInt(123412345), -3}: \"123412.345\",\n\t\tInp{big.NewInt(2234), -1}:      \"223.4\",\n\t\tInp{big.NewInt(323412345), 1}:  \"3234123450\",\n\t\tInp{big.NewInt(423412345), 0}:  \"423412345\",\n\t\tInp{big.NewInt(52341235), -5}:  \"523.41235\",\n\t\tInp{big.NewInt(623412345), -6}: \"623.412345\",\n\t\tInp{big.NewInt(723412345), -7}: \"72.3412345\",\n\t}\n\n\t// add negatives\n\tfor p, s := range tests {\n\t\tif p.val.Cmp(Zero.value) > 0 {\n\t\t\ttests[Inp{p.val.Neg(p.val), p.exp}] = \"-\" + s\n\t\t}\n\t}\n\n\tfor input, s := range tests {\n\t\td := NewFromBigInt(input.val, input.exp)\n\t\tif d.String() != s {\n\t\t\tt.Errorf(\"expected %s, got %s (%s, %d)\",\n\t\t\t\ts, d.String(),\n\t\t\t\td.value.String(), d.exp)\n\t\t}\n\t}\n}\n\nfunc TestNewFromBigRat(t *testing.T) {\n\tmustParseRat := func(val string) *big.Rat {\n\t\tnum, _ := new(big.Rat).SetString(val)\n\t\treturn num\n\t}\n\n\ttype Inp struct {\n\t\tval  *big.Rat\n\t\tprec int32\n\t}\n\n\ttests := map[Inp]string{\n\t\tInp{big.NewRat(0, 1), 16}:                                                     \"0\",\n\t\tInp{big.NewRat(4, 5), 16}:                                                     \"0.8\",\n\t\tInp{big.NewRat(10, 2), 16}:                                                    \"5\",\n\t\tInp{big.NewRat(1023427554493, 43432632), 16}:                                  \"23563.5628642767953828\", // rounded\n\t\tInp{big.NewRat(1, 434324545566634), 16}:                                       \"0.0000000000000023\",\n\t\tInp{big.NewRat(1, 3), 16}:                                                     \"0.3333333333333333\",\n\t\tInp{big.NewRat(2, 3), 2}:                                                      \"0.67\",               // rounded\n\t\tInp{big.NewRat(2, 3), 16}:                                                     \"0.6666666666666667\", // rounded\n\t\tInp{big.NewRat(10000, 3), 16}:                                                 \"3333.3333333333333333\",\n\t\tInp{mustParseRat(\"30702832066636633479\"), 16}:                                 \"30702832066636633479\",\n\t\tInp{mustParseRat(\"487028320159896636679.1827512895753\"), 16}:                  \"487028320159896636679.1827512895753\",\n\t\tInp{mustParseRat(\"127028320612589896636633479.173582751289575278357832\"), -2}: \"127028320612589896636633500\",                  // rounded\n\t\tInp{mustParseRat(\"127028320612589896636633479.173582751289575278357832\"), 16}: \"127028320612589896636633479.1735827512895753\", // rounded\n\t\tInp{mustParseRat(\"127028320612589896636633479.173582751289575278357832\"), 32}: \"127028320612589896636633479.173582751289575278357832\",\n\t}\n\n\t// add negatives\n\tfor p, s := range tests {\n\t\tif p.val.Cmp(new(big.Rat)) > 0 {\n\t\t\ttests[Inp{p.val.Neg(p.val), p.prec}] = \"-\" + s\n\t\t}\n\t}\n\n\tfor input, s := range tests {\n\t\td := NewFromBigRat(input.val, input.prec)\n\t\tif d.String() != s {\n\t\t\tt.Errorf(\"expected %s, got %s (%s, %d)\",\n\t\t\t\ts, d.String(),\n\t\t\t\td.value.String(), d.exp)\n\t\t}\n\t}\n}\n\nfunc TestCopy(t *testing.T) {\n\torigin := New(1, 0)\n\tcpy := origin.Copy()\n\n\tif origin.value == cpy.value {\n\t\tt.Error(\"expecting copy and origin to have different value pointers\")\n\t}\n\n\tif cpy.Cmp(origin) != 0 {\n\t\tt.Error(\"expecting copy and origin to be equals, but they are not\")\n\t}\n\n\t//change value\n\tcpy = cpy.Add(New(1, 0))\n\n\tif cpy.Cmp(origin) == 0 {\n\t\tt.Error(\"expecting copy and origin to have different values, but they are equal\")\n\t}\n}\n\nfunc TestJSON(t *testing.T) {\n\tfor _, x := range testTable {\n\t\ts := x.short\n\t\tvar doc struct {\n\t\t\tAmount Decimal `json:\"amount\"`\n\t\t}\n\t\tdocStr := `{\"amount\":\"` + s + `\"}`\n\t\tdocStrNumber := `{\"amount\":` + s + `}`\n\t\terr := json.Unmarshal([]byte(docStr), &doc)\n\t\tif err != nil {\n\t\t\tt.Errorf(\"error unmarshaling %s: %v\", docStr, err)\n\t\t} else if doc.Amount.String() != s {\n\t\t\tt.Errorf(\"expected %s, got %s (%s, %d)\",\n\t\t\t\ts, doc.Amount.String(),\n\t\t\t\tdoc.Amount.value.String(), doc.Amount.exp)\n\t\t}\n\n\t\tout, err := json.Marshal(&doc)\n\t\tif err != nil {\n\t\t\tt.Errorf(\"error marshaling %+v: %v\", doc, err)\n\t\t} else if string(out) != docStr {\n\t\t\tt.Errorf(\"expected %s, got %s\", docStr, string(out))\n\t\t}\n\n\t\t// make sure unquoted marshalling works too\n\t\tMarshalJSONWithoutQuotes = true\n\t\tout, err = json.Marshal(&doc)\n\t\tif err != nil {\n\t\t\tt.Errorf(\"error marshaling %+v: %v\", doc, err)\n\t\t} else if string(out) != docStrNumber {\n\t\t\tt.Errorf(\"expected %s, got %s\", docStrNumber, string(out))\n\t\t}\n\t\tMarshalJSONWithoutQuotes = false\n\t}\n}\n\nfunc TestUnmarshalJSONNull(t *testing.T) {\n\tvar doc struct {\n\t\tAmount Decimal `json:\"amount\"`\n\t}\n\tdocStr := `{\"amount\": null}`\n\terr := json.Unmarshal([]byte(docStr), &doc)\n\tif err != nil {\n\t\tt.Errorf(\"error unmarshaling %s: %v\", docStr, err)\n\t} else if !doc.Amount.Equal(Zero) {\n\t\tt.Errorf(\"expected Zero, got %s (%s, %d)\",\n\t\t\tdoc.Amount.String(),\n\t\t\tdoc.Amount.value.String(), doc.Amount.exp)\n\t}\n}\n\nfunc TestBadJSON(t *testing.T) {\n\tfor _, testCase := range []string{\n\t\t\"]o_o[\",\n\t\t\"{\",\n\t\t`{\"amount\":\"\"`,\n\t\t`{\"amount\":\"\"}`,\n\t\t`{\"amount\":\"nope\"}`,\n\t\t`0.333`,\n\t} {\n\t\tvar doc struct {\n\t\t\tAmount Decimal `json:\"amount\"`\n\t\t}\n\t\terr := json.Unmarshal([]byte(testCase), &doc)\n\t\tif err == nil {\n\t\t\tt.Errorf(\"expected error, got %+v\", doc)\n\t\t}\n\t}\n}\n\nfunc TestNullDecimalJSON(t *testing.T) {\n\tfor _, x := range testTable {\n\t\ts := x.short\n\t\tvar doc struct {\n\t\t\tAmount NullDecimal `json:\"amount\"`\n\t\t}\n\t\tdocStr := `{\"amount\":\"` + s + `\"}`\n\t\tdocStrNumber := `{\"amount\":` + s + `}`\n\t\terr := json.Unmarshal([]byte(docStr), &doc)\n\t\tif err != nil {\n\t\t\tt.Errorf(\"error unmarshaling %s: %v\", docStr, err)\n\t\t} else {\n\t\t\tif !doc.Amount.Valid {\n\t\t\t\tt.Errorf(\"expected %s to be valid (not NULL), got Valid = false\", s)\n\t\t\t}\n\t\t\tif doc.Amount.Decimal.String() != s {\n\t\t\t\tt.Errorf(\"expected %s, got %s (%s, %d)\",\n\t\t\t\t\ts, doc.Amount.Decimal.String(),\n\t\t\t\t\tdoc.Amount.Decimal.value.String(), doc.Amount.Decimal.exp)\n\t\t\t}\n\t\t}\n\n\t\tout, err := json.Marshal(&doc)\n\t\tif err != nil {\n\t\t\tt.Errorf(\"error marshaling %+v: %v\", doc, err)\n\t\t} else if string(out) != docStr {\n\t\t\tt.Errorf(\"expected %s, got %s\", docStr, string(out))\n\t\t}\n\n\t\t// make sure unquoted marshalling works too\n\t\tMarshalJSONWithoutQuotes = true\n\t\tout, err = json.Marshal(&doc)\n\t\tif err != nil {\n\t\t\tt.Errorf(\"error marshaling %+v: %v\", doc, err)\n\t\t} else if string(out) != docStrNumber {\n\t\t\tt.Errorf(\"expected %s, got %s\", docStrNumber, string(out))\n\t\t}\n\t\tMarshalJSONWithoutQuotes = false\n\t}\n\n\tvar doc struct {\n\t\tAmount NullDecimal `json:\"amount\"`\n\t}\n\tdocStr := `{\"amount\": null}`\n\terr := json.Unmarshal([]byte(docStr), &doc)\n\tif err != nil {\n\t\tt.Errorf(\"error unmarshaling %s: %v\", docStr, err)\n\t} else if doc.Amount.Valid {\n\t\tt.Errorf(\"expected null value to have Valid = false, got Valid = true and Decimal = %s (%s, %d)\",\n\t\t\tdoc.Amount.Decimal.String(),\n\t\t\tdoc.Amount.Decimal.value.String(), doc.Amount.Decimal.exp)\n\t}\n\n\texpected := `{\"amount\":null}`\n\tout, err := json.Marshal(&doc)\n\tif err != nil {\n\t\tt.Errorf(\"error marshaling %+v: %v\", doc, err)\n\t} else if string(out) != expected {\n\t\tt.Errorf(\"expected %s, got %s\", expected, string(out))\n\t}\n\n\t// make sure unquoted marshalling works too\n\tMarshalJSONWithoutQuotes = true\n\texpectedUnquoted := `{\"amount\":null}`\n\tout, err = json.Marshal(&doc)\n\tif err != nil {\n\t\tt.Errorf(\"error marshaling %+v: %v\", doc, err)\n\t} else if string(out) != expectedUnquoted {\n\t\tt.Errorf(\"expected %s, got %s\", expectedUnquoted, string(out))\n\t}\n\tMarshalJSONWithoutQuotes = false\n}\n\nfunc TestNullDecimalBadJSON(t *testing.T) {\n\tfor _, testCase := range []string{\n\t\t\"]o_o[\",\n\t\t\"{\",\n\t\t`{\"amount\":\"\"`,\n\t\t`{\"amount\":\"\"}`,\n\t\t`{\"amount\":\"nope\"}`,\n\t\t`{\"amount\":nope}`,\n\t\t`0.333`,\n\t} {\n\t\tvar doc struct {\n\t\t\tAmount NullDecimal `json:\"amount\"`\n\t\t}\n\t\terr := json.Unmarshal([]byte(testCase), &doc)\n\t\tif err == nil {\n\t\t\tt.Errorf(\"expected error, got %+v\", doc)\n\t\t}\n\t}\n}\n\nfunc TestXML(t *testing.T) {\n\tfor _, x := range testTable {\n\t\ts := x.short\n\t\tvar doc struct {\n\t\t\tXMLName xml.Name `xml:\"account\"`\n\t\t\tAmount  Decimal  `xml:\"amount\"`\n\t\t}\n\t\tdocStr := `<account><amount>` + s + `</amount></account>`\n\t\terr := xml.Unmarshal([]byte(docStr), &doc)\n\t\tif err != nil {\n\t\t\tt.Errorf(\"error unmarshaling %s: %v\", docStr, err)\n\t\t} else if doc.Amount.String() != s {\n\t\t\tt.Errorf(\"expected %s, got %s (%s, %d)\",\n\t\t\t\ts, doc.Amount.String(),\n\t\t\t\tdoc.Amount.value.String(), doc.Amount.exp)\n\t\t}\n\n\t\tout, err := xml.Marshal(&doc)\n\t\tif err != nil {\n\t\t\tt.Errorf(\"error marshaling %+v: %v\", doc, err)\n\t\t} else if string(out) != docStr {\n\t\t\tt.Errorf(\"expected %s, got %s\", docStr, string(out))\n\t\t}\n\t}\n}\n\nfunc TestBadXML(t *testing.T) {\n\tfor _, testCase := range []string{\n\t\t\"o_o\",\n\t\t\"<abc\",\n\t\t\"<account><amount>7\",\n\t\t`<html><body></body></html>`,\n\t\t`<account><amount></amount></account>`,\n\t\t`<account><amount>nope</amount></account>`,\n\t\t`0.333`,\n\t} {\n\t\tvar doc struct {\n\t\t\tXMLName xml.Name `xml:\"account\"`\n\t\t\tAmount  Decimal  `xml:\"amount\"`\n\t\t}\n\t\terr := xml.Unmarshal([]byte(testCase), &doc)\n\t\tif err == nil {\n\t\t\tt.Errorf(\"expected error, got %+v\", doc)\n\t\t}\n\t}\n}\n\nfunc TestNullDecimalXML(t *testing.T) {\n\t// test valid values\n\tfor _, x := range testTable {\n\t\ts := x.short\n\t\tvar doc struct {\n\t\t\tXMLName xml.Name    `xml:\"account\"`\n\t\t\tAmount  NullDecimal `xml:\"amount\"`\n\t\t}\n\t\tdocStr := `<account><amount>` + s + `</amount></account>`\n\t\terr := xml.Unmarshal([]byte(docStr), &doc)\n\t\tif err != nil {\n\t\t\tt.Errorf(\"error unmarshaling %s: %v\", docStr, err)\n\t\t} else if doc.Amount.Decimal.String() != s {\n\t\t\tt.Errorf(\"expected %s, got %s (%s, %d)\",\n\t\t\t\ts, doc.Amount.Decimal.String(),\n\t\t\t\tdoc.Amount.Decimal.value.String(), doc.Amount.Decimal.exp)\n\t\t}\n\n\t\tout, err := xml.Marshal(&doc)\n\t\tif err != nil {\n\t\t\tt.Errorf(\"error marshaling %+v: %v\", doc, err)\n\t\t} else if string(out) != docStr {\n\t\t\tt.Errorf(\"expected %s, got %s\", docStr, string(out))\n\t\t}\n\t}\n\n\tvar doc struct {\n\t\tXMLName xml.Name    `xml:\"account\"`\n\t\tAmount  NullDecimal `xml:\"amount\"`\n\t}\n\n\t// test for XML with empty body\n\tdocStr := `<account><amount></amount></account>`\n\terr := xml.Unmarshal([]byte(docStr), &doc)\n\tif err != nil {\n\t\tt.Errorf(\"error unmarshaling: %s: %v\", docStr, err)\n\t} else if doc.Amount.Valid {\n\t\tt.Errorf(\"expected null value to have Valid = false, got Valid = true and Decimal = %s (%s, %d)\",\n\t\t\tdoc.Amount.Decimal.String(),\n\t\t\tdoc.Amount.Decimal.value.String(), doc.Amount.Decimal.exp)\n\t}\n\n\texpected := `<account><amount></amount></account>`\n\tout, err := xml.Marshal(&doc)\n\tif err != nil {\n\t\tt.Errorf(\"error marshaling %+v: %v\", doc, err)\n\t} else if string(out) != expected {\n\t\tt.Errorf(\"expected %s, got %s\", expected, string(out))\n\t}\n\n\t// test for empty XML\n\tdocStr = `<account></account>`\n\terr = xml.Unmarshal([]byte(docStr), &doc)\n\tif err != nil {\n\t\tt.Errorf(\"error unmarshaling: %s: %v\", docStr, err)\n\t} else if doc.Amount.Valid {\n\t\tt.Errorf(\"expected null value to have Valid = false, got Valid = true and Decimal = %s (%s, %d)\",\n\t\t\tdoc.Amount.Decimal.String(),\n\t\t\tdoc.Amount.Decimal.value.String(), doc.Amount.Decimal.exp)\n\t}\n\n\texpected = `<account><amount></amount></account>`\n\tout, err = xml.Marshal(&doc)\n\tif err != nil {\n\t\tt.Errorf(\"error marshaling %+v: %v\", doc, err)\n\t} else if string(out) != expected {\n\t\tt.Errorf(\"expected %s, got %s\", expected, string(out))\n\t}\n}\n\nfunc TestNullDecimalBadXML(t *testing.T) {\n\tfor _, testCase := range []string{\n\t\t\"o_o\",\n\t\t\"<abc\",\n\t\t\"<account><amount>7\",\n\t\t`<html><body></body></html>`,\n\t\t`<account><amount>nope</amount></account>`,\n\t\t`0.333`,\n\t} {\n\t\tvar doc struct {\n\t\t\tXMLName xml.Name    `xml:\"account\"`\n\t\t\tAmount  NullDecimal `xml:\"amount\"`\n\t\t}\n\t\terr := xml.Unmarshal([]byte(testCase), &doc)\n\t\tif err == nil {\n\t\t\tt.Errorf(\"expected error, got %+v\", doc)\n\t\t}\n\t}\n}\n\nfunc TestDecimal_rescale(t *testing.T) {\n\ttype Inp struct {\n\t\tint     int64\n\t\texp     int32\n\t\trescale int32\n\t}\n\ttests := map[Inp]string{\n\t\tInp{1234, -3, -5}: \"1.234\",\n\t\tInp{1234, -3, 0}:  \"1\",\n\t\tInp{1234, 3, 0}:   \"1234000\",\n\t\tInp{1234, -4, -4}: \"0.1234\",\n\t}\n\n\t// add negatives\n\tfor p, s := range tests {\n\t\tif p.int > 0 {\n\t\t\ttests[Inp{-p.int, p.exp, p.rescale}] = \"-\" + s\n\t\t}\n\t}\n\n\tfor input, s := range tests {\n\t\td := New(input.int, input.exp).rescale(input.rescale)\n\n\t\tif d.String() != s {\n\t\t\tt.Errorf(\"expected %s, got %s (%s, %d)\",\n\t\t\t\ts, d.String(),\n\t\t\t\td.value.String(), d.exp)\n\t\t}\n\n\t\t// test StringScaled\n\t\ts2 := New(input.int, input.exp).StringScaled(input.rescale)\n\t\tif s2 != s {\n\t\t\tt.Errorf(\"expected %s, got %s\", s, s2)\n\t\t}\n\t}\n}\n\nfunc TestDecimal_Floor(t *testing.T) {\n\tassertFloor := func(input, expected Decimal) {\n\t\tgot := input.Floor()\n\t\tif !got.Equal(expected) {\n\t\t\tt.Errorf(\"Floor(%s): got %s, expected %s\", input, got, expected)\n\t\t}\n\t}\n\ttype testDataString struct {\n\t\tinput    string\n\t\texpected string\n\t}\n\ttestsWithStrings := []testDataString{\n\t\t{\"1.999\", \"1\"},\n\t\t{\"1\", \"1\"},\n\t\t{\"1.01\", \"1\"},\n\t\t{\"0\", \"0\"},\n\t\t{\"0.9\", \"0\"},\n\t\t{\"0.1\", \"0\"},\n\t\t{\"-0.9\", \"-1\"},\n\t\t{\"-0.1\", \"-1\"},\n\t\t{\"-1.00\", \"-1\"},\n\t\t{\"-1.01\", \"-2\"},\n\t\t{\"-1.999\", \"-2\"},\n\t}\n\tfor _, test := range testsWithStrings {\n\t\texpected, _ := NewFromString(test.expected)\n\t\tinput, _ := NewFromString(test.input)\n\t\tassertFloor(input, expected)\n\t}\n\n\ttype testDataDecimal struct {\n\t\tinput    Decimal\n\t\texpected string\n\t}\n\ttestsWithDecimals := []testDataDecimal{\n\t\t{New(100, -1), \"10\"},\n\t\t{New(10, 0), \"10\"},\n\t\t{New(1, 1), \"10\"},\n\t\t{New(1999, -3), \"1\"},\n\t\t{New(101, -2), \"1\"},\n\t\t{New(1, 0), \"1\"},\n\t\t{New(0, 0), \"0\"},\n\t\t{New(9, -1), \"0\"},\n\t\t{New(1, -1), \"0\"},\n\t\t{New(-1, -1), \"-1\"},\n\t\t{New(-9, -1), \"-1\"},\n\t\t{New(-1, 0), \"-1\"},\n\t\t{New(-101, -2), \"-2\"},\n\t\t{New(-1999, -3), \"-2\"},\n\t}\n\tfor _, test := range testsWithDecimals {\n\t\texpected, _ := NewFromString(test.expected)\n\t\tassertFloor(test.input, expected)\n\t}\n}\n\nfunc TestDecimal_Ceil(t *testing.T) {\n\tassertCeil := func(input, expected Decimal) {\n\t\tgot := input.Ceil()\n\t\tif !got.Equal(expected) {\n\t\t\tt.Errorf(\"Ceil(%s): got %s, expected %s\", input, got, expected)\n\t\t}\n\t}\n\ttype testDataString struct {\n\t\tinput    string\n\t\texpected string\n\t}\n\ttestsWithStrings := []testDataString{\n\t\t{\"1.999\", \"2\"},\n\t\t{\"1\", \"1\"},\n\t\t{\"1.01\", \"2\"},\n\t\t{\"0\", \"0\"},\n\t\t{\"0.9\", \"1\"},\n\t\t{\"0.1\", \"1\"},\n\t\t{\"-0.9\", \"0\"},\n\t\t{\"-0.1\", \"0\"},\n\t\t{\"-1.00\", \"-1\"},\n\t\t{\"-1.01\", \"-1\"},\n\t\t{\"-1.999\", \"-1\"},\n\t}\n\tfor _, test := range testsWithStrings {\n\t\texpected, _ := NewFromString(test.expected)\n\t\tinput, _ := NewFromString(test.input)\n\t\tassertCeil(input, expected)\n\t}\n\n\ttype testDataDecimal struct {\n\t\tinput    Decimal\n\t\texpected string\n\t}\n\ttestsWithDecimals := []testDataDecimal{\n\t\t{New(100, -1), \"10\"},\n\t\t{New(10, 0), \"10\"},\n\t\t{New(1, 1), \"10\"},\n\t\t{New(1999, -3), \"2\"},\n\t\t{New(101, -2), \"2\"},\n\t\t{New(1, 0), \"1\"},\n\t\t{New(0, 0), \"0\"},\n\t\t{New(9, -1), \"1\"},\n\t\t{New(1, -1), \"1\"},\n\t\t{New(-1, -1), \"0\"},\n\t\t{New(-9, -1), \"0\"},\n\t\t{New(-1, 0), \"-1\"},\n\t\t{New(-101, -2), \"-1\"},\n\t\t{New(-1999, -3), \"-1\"},\n\t}\n\tfor _, test := range testsWithDecimals {\n\t\texpected, _ := NewFromString(test.expected)\n\t\tassertCeil(test.input, expected)\n\t}\n}\n\nfunc TestDecimal_RoundAndStringFixed(t *testing.T) {\n\ttype testData struct {\n\t\tinput         string\n\t\tplaces        int32\n\t\texpected      string\n\t\texpectedFixed string\n\t}\n\ttests := []testData{\n\t\t{\"1.454\", 0, \"1\", \"\"},\n\t\t{\"1.454\", 1, \"1.5\", \"\"},\n\t\t{\"1.454\", 2, \"1.45\", \"\"},\n\t\t{\"1.454\", 3, \"1.454\", \"\"},\n\t\t{\"1.454\", 4, \"1.454\", \"1.4540\"},\n\t\t{\"1.454\", 5, \"1.454\", \"1.45400\"},\n\t\t{\"1.554\", 0, \"2\", \"\"},\n\t\t{\"1.554\", 1, \"1.6\", \"\"},\n\t\t{\"1.554\", 2, \"1.55\", \"\"},\n\t\t{\"0.554\", 0, \"1\", \"\"},\n\t\t{\"0.454\", 0, \"0\", \"\"},\n\t\t{\"0.454\", 5, \"0.454\", \"0.45400\"},\n\t\t{\"0\", 0, \"0\", \"\"},\n\t\t{\"0\", 1, \"0\", \"0.0\"},\n\t\t{\"0\", 2, \"0\", \"0.00\"},\n\t\t{\"0\", -1, \"0\", \"\"},\n\t\t{\"5\", 2, \"5\", \"5.00\"},\n\t\t{\"5\", 1, \"5\", \"5.0\"},\n\t\t{\"5\", 0, \"5\", \"\"},\n\t\t{\"500\", 2, \"500\", \"500.00\"},\n\t\t{\"545\", -1, \"550\", \"\"},\n\t\t{\"545\", -2, \"500\", \"\"},\n\t\t{\"545\", -3, \"1000\", \"\"},\n\t\t{\"545\", -4, \"0\", \"\"},\n\t\t{\"499\", -3, \"0\", \"\"},\n\t\t{\"499\", -4, \"0\", \"\"},\n\t}\n\n\t// add negative number tests\n\tfor _, test := range tests {\n\t\texpected := test.expected\n\t\tif expected != \"0\" {\n\t\t\texpected = \"-\" + expected\n\t\t}\n\t\texpectedStr := test.expectedFixed\n\t\tif strings.ContainsAny(expectedStr, \"123456789\") && expectedStr != \"\" {\n\t\t\texpectedStr = \"-\" + expectedStr\n\t\t}\n\t\ttests = append(tests,\n\t\t\ttestData{\"-\" + test.input, test.places, expected, expectedStr})\n\t}\n\n\tfor _, test := range tests {\n\t\td, err := NewFromString(test.input)\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\n\t\t// test Round\n\t\texpected, err := NewFromString(test.expected)\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tgot := d.Round(test.places)\n\t\tif !got.Equal(expected) {\n\t\t\tt.Errorf(\"Rounding %s to %d places, got %s, expected %s\",\n\t\t\t\td, test.places, got, expected)\n\t\t}\n\n\t\t// test StringFixed\n\t\tif test.expectedFixed == \"\" {\n\t\t\ttest.expectedFixed = test.expected\n\t\t}\n\t\tgotStr := d.StringFixed(test.places)\n\t\tif gotStr != test.expectedFixed {\n\t\t\tt.Errorf(\"(%s).StringFixed(%d): got %s, expected %s\",\n\t\t\t\td, test.places, gotStr, test.expectedFixed)\n\t\t}\n\t}\n}\n\nfunc TestDecimal_RoundCeilAndStringFixed(t *testing.T) {\n\ttype testData struct {\n\t\tinput         string\n\t\tplaces        int32\n\t\texpected      string\n\t\texpectedFixed string\n\t}\n\ttests := []testData{\n\t\t{\"1.454\", 0, \"2\", \"\"},\n\t\t{\"1.454\", 1, \"1.5\", \"\"},\n\t\t{\"1.454\", 2, \"1.46\", \"\"},\n\t\t{\"1.454\", 3, \"1.454\", \"\"},\n\t\t{\"1.454\", 4, \"1.454\", \"1.4540\"},\n\t\t{\"1.454\", 5, \"1.454\", \"1.45400\"},\n\t\t{\"1.554\", 0, \"2\", \"\"},\n\t\t{\"1.554\", 1, \"1.6\", \"\"},\n\t\t{\"1.554\", 2, \"1.56\", \"\"},\n\t\t{\"0.554\", 0, \"1\", \"\"},\n\t\t{\"0.454\", 0, \"1\", \"\"},\n\t\t{\"0.454\", 5, \"0.454\", \"0.45400\"},\n\t\t{\"0\", 0, \"0\", \"\"},\n\t\t{\"0\", 1, \"0\", \"0.0\"},\n\t\t{\"0\", 2, \"0\", \"0.00\"},\n\t\t{\"0\", -1, \"0\", \"\"},\n\t\t{\"5\", 2, \"5\", \"5.00\"},\n\t\t{\"5\", 1, \"5\", \"5.0\"},\n\t\t{\"5\", 0, \"5\", \"\"},\n\t\t{\"500\", 2, \"500\", \"500.00\"},\n\t\t{\"500\", -2, \"500\", \"\"},\n\t\t{\"545\", -1, \"550\", \"\"},\n\t\t{\"545\", -2, \"600\", \"\"},\n\t\t{\"545\", -3, \"1000\", \"\"},\n\t\t{\"545\", -4, \"10000\", \"\"},\n\t\t{\"499\", -3, \"1000\", \"\"},\n\t\t{\"499\", -4, \"10000\", \"\"},\n\t\t{\"1.1001\", 2, \"1.11\", \"\"},\n\t\t{\"-1.1001\", 2, \"-1.10\", \"\"},\n\t\t{\"-1.454\", 0, \"-1\", \"\"},\n\t\t{\"-1.454\", 1, \"-1.4\", \"\"},\n\t\t{\"-1.454\", 2, \"-1.45\", \"\"},\n\t\t{\"-1.454\", 3, \"-1.454\", \"\"},\n\t\t{\"-1.454\", 4, \"-1.454\", \"-1.4540\"},\n\t\t{\"-1.454\", 5, \"-1.454\", \"-1.45400\"},\n\t\t{\"-1.554\", 0, \"-1\", \"\"},\n\t\t{\"-1.554\", 1, \"-1.5\", \"\"},\n\t\t{\"-1.554\", 2, \"-1.55\", \"\"},\n\t\t{\"-0.554\", 0, \"0\", \"\"},\n\t\t{\"-0.454\", 0, \"0\", \"\"},\n\t\t{\"-0.454\", 5, \"-0.454\", \"-0.45400\"},\n\t\t{\"-5\", 2, \"-5\", \"-5.00\"},\n\t\t{\"-5\", 1, \"-5\", \"-5.0\"},\n\t\t{\"-5\", 0, \"-5\", \"\"},\n\t\t{\"-500\", 2, \"-500\", \"-500.00\"},\n\t\t{\"-500\", -2, \"-500\", \"\"},\n\t\t{\"-545\", -1, \"-540\", \"\"},\n\t\t{\"-545\", -2, \"-500\", \"\"},\n\t\t{\"-545\", -3, \"0\", \"\"},\n\t\t{\"-545\", -4, \"0\", \"\"},\n\t\t{\"-499\", -3, \"0\", \"\"},\n\t\t{\"-499\", -4, \"0\", \"\"},\n\t}\n\n\tfor _, test := range tests {\n\t\td, err := NewFromString(test.input)\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\n\t\t// test Round\n\t\texpected, err := NewFromString(test.expected)\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tgot := d.RoundCeil(test.places)\n\t\tif !got.Equal(expected) {\n\t\t\tt.Errorf(\"Rounding ceil %s to %d places, got %s, expected %s\",\n\t\t\t\td, test.places, got, expected)\n\t\t}\n\n\t\t// test StringFixed\n\t\tif test.expectedFixed == \"\" {\n\t\t\ttest.expectedFixed = test.expected\n\t\t}\n\t\tgotStr := got.StringFixed(test.places)\n\t\tif gotStr != test.expectedFixed {\n\t\t\tt.Errorf(\"(%s).StringFixed(%d): got %s, expected %s\",\n\t\t\t\td, test.places, gotStr, test.expectedFixed)\n\t\t}\n\t}\n}\n\nfunc TestDecimal_RoundFloorAndStringFixed(t *testing.T) {\n\ttype testData struct {\n\t\tinput         string\n\t\tplaces        int32\n\t\texpected      string\n\t\texpectedFixed string\n\t}\n\ttests := []testData{\n\t\t{\"1.454\", 0, \"1\", \"\"},\n\t\t{\"1.454\", 1, \"1.4\", \"\"},\n\t\t{\"1.454\", 2, \"1.45\", \"\"},\n\t\t{\"1.454\", 3, \"1.454\", \"\"},\n\t\t{\"1.454\", 4, \"1.454\", \"1.4540\"},\n\t\t{\"1.454\", 5, \"1.454\", \"1.45400\"},\n\t\t{\"1.554\", 0, \"1\", \"\"},\n\t\t{\"1.554\", 1, \"1.5\", \"\"},\n\t\t{\"1.554\", 2, \"1.55\", \"\"},\n\t\t{\"0.554\", 0, \"0\", \"\"},\n\t\t{\"0.454\", 0, \"0\", \"\"},\n\t\t{\"0.454\", 5, \"0.454\", \"0.45400\"},\n\t\t{\"0\", 0, \"0\", \"\"},\n\t\t{\"0\", 1, \"0\", \"0.0\"},\n\t\t{\"0\", 2, \"0\", \"0.00\"},\n\t\t{\"0\", -1, \"0\", \"\"},\n\t\t{\"5\", 2, \"5\", \"5.00\"},\n\t\t{\"5\", 1, \"5\", \"5.0\"},\n\t\t{\"5\", 0, \"5\", \"\"},\n\t\t{\"500\", 2, \"500\", \"500.00\"},\n\t\t{\"500\", -2, \"500\", \"\"},\n\t\t{\"545\", -1, \"540\", \"\"},\n\t\t{\"545\", -2, \"500\", \"\"},\n\t\t{\"545\", -3, \"0\", \"\"},\n\t\t{\"545\", -4, \"0\", \"\"},\n\t\t{\"499\", -3, \"0\", \"\"},\n\t\t{\"499\", -4, \"0\", \"\"},\n\t\t{\"1.1001\", 2, \"1.10\", \"\"},\n\t\t{\"-1.1001\", 2, \"-1.11\", \"\"},\n\t\t{\"-1.454\", 0, \"-2\", \"\"},\n\t\t{\"-1.454\", 1, \"-1.5\", \"\"},\n\t\t{\"-1.454\", 2, \"-1.46\", \"\"},\n\t\t{\"-1.454\", 3, \"-1.454\", \"\"},\n\t\t{\"-1.454\", 4, \"-1.454\", \"-1.4540\"},\n\t\t{\"-1.454\", 5, \"-1.454\", \"-1.45400\"},\n\t\t{\"-1.554\", 0, \"-2\", \"\"},\n\t\t{\"-1.554\", 1, \"-1.6\", \"\"},\n\t\t{\"-1.554\", 2, \"-1.56\", \"\"},\n\t\t{\"-0.554\", 0, \"-1\", \"\"},\n\t\t{\"-0.454\", 0, \"-1\", \"\"},\n\t\t{\"-0.454\", 5, \"-0.454\", \"-0.45400\"},\n\t\t{\"-5\", 2, \"-5\", \"-5.00\"},\n\t\t{\"-5\", 1, \"-5\", \"-5.0\"},\n\t\t{\"-5\", 0, \"-5\", \"\"},\n\t\t{\"-500\", 2, \"-500\", \"-500.00\"},\n\t\t{\"-500\", -2, \"-500\", \"\"},\n\t\t{\"-545\", -1, \"-550\", \"\"},\n\t\t{\"-545\", -2, \"-600\", \"\"},\n\t\t{\"-545\", -3, \"-1000\", \"\"},\n\t\t{\"-545\", -4, \"-10000\", \"\"},\n\t\t{\"-499\", -3, \"-1000\", \"\"},\n\t\t{\"-499\", -4, \"-10000\", \"\"},\n\t}\n\n\tfor _, test := range tests {\n\t\td, err := NewFromString(test.input)\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\n\t\t// test Round\n\t\texpected, err := NewFromString(test.expected)\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tgot := d.RoundFloor(test.places)\n\t\tif !got.Equal(expected) {\n\t\t\tt.Errorf(\"Rounding floor %s to %d places, got %s, expected %s\",\n\t\t\t\td, test.places, got, expected)\n\t\t}\n\n\t\t// test StringFixed\n\t\tif test.expectedFixed == \"\" {\n\t\t\ttest.expectedFixed = test.expected\n\t\t}\n\t\tgotStr := got.StringFixed(test.places)\n\t\tif gotStr != test.expectedFixed {\n\t\t\tt.Errorf(\"(%s).StringFixed(%d): got %s, expected %s\",\n\t\t\t\td, test.places, gotStr, test.expectedFixed)\n\t\t}\n\t}\n}\n\nfunc TestDecimal_RoundUpAndStringFixed(t *testing.T) {\n\ttype testData struct {\n\t\tinput         string\n\t\tplaces        int32\n\t\texpected      string\n\t\texpectedFixed string\n\t}\n\ttests := []testData{\n\t\t{\"1.454\", 0, \"2\", \"\"},\n\t\t{\"1.454\", 1, \"1.5\", \"\"},\n\t\t{\"1.454\", 2, \"1.46\", \"\"},\n\t\t{\"1.454\", 3, \"1.454\", \"\"},\n\t\t{\"1.454\", 4, \"1.454\", \"1.4540\"},\n\t\t{\"1.454\", 5, \"1.454\", \"1.45400\"},\n\t\t{\"1.554\", 0, \"2\", \"\"},\n\t\t{\"1.554\", 1, \"1.6\", \"\"},\n\t\t{\"1.554\", 2, \"1.56\", \"\"},\n\t\t{\"0.554\", 0, \"1\", \"\"},\n\t\t{\"0.454\", 0, \"1\", \"\"},\n\t\t{\"0.454\", 5, \"0.454\", \"0.45400\"},\n\t\t{\"0\", 0, \"0\", \"\"},\n\t\t{\"0\", 1, \"0\", \"0.0\"},\n\t\t{\"0\", 2, \"0\", \"0.00\"},\n\t\t{\"0\", -1, \"0\", \"\"},\n\t\t{\"5\", 2, \"5\", \"5.00\"},\n\t\t{\"5\", 1, \"5\", \"5.0\"},\n\t\t{\"5\", 0, \"5\", \"\"},\n\t\t{\"500\", 2, \"500\", \"500.00\"},\n\t\t{\"500\", -2, \"500\", \"\"},\n\t\t{\"545\", -1, \"550\", \"\"},\n\t\t{\"545\", -2, \"600\", \"\"},\n\t\t{\"545\", -3, \"1000\", \"\"},\n\t\t{\"545\", -4, \"10000\", \"\"},\n\t\t{\"499\", -3, \"1000\", \"\"},\n\t\t{\"499\", -4, \"10000\", \"\"},\n\t\t{\"1.1001\", 2, \"1.11\", \"\"},\n\t\t{\"-1.1001\", 2, \"-1.11\", \"\"},\n\t\t{\"-1.454\", 0, \"-2\", \"\"},\n\t\t{\"-1.454\", 1, \"-1.5\", \"\"},\n\t\t{\"-1.454\", 2, \"-1.46\", \"\"},\n\t\t{\"-1.454\", 3, \"-1.454\", \"\"},\n\t\t{\"-1.454\", 4, \"-1.454\", \"-1.4540\"},\n\t\t{\"-1.454\", 5, \"-1.454\", \"-1.45400\"},\n\t\t{\"-1.554\", 0, \"-2\", \"\"},\n\t\t{\"-1.554\", 1, \"-1.6\", \"\"},\n\t\t{\"-1.554\", 2, \"-1.56\", \"\"},\n\t\t{\"-0.554\", 0, \"-1\", \"\"},\n\t\t{\"-0.454\", 0, \"-1\", \"\"},\n\t\t{\"-0.454\", 5, \"-0.454\", \"-0.45400\"},\n\t\t{\"-5\", 2, \"-5\", \"-5.00\"},\n\t\t{\"-5\", 1, \"-5\", \"-5.0\"},\n\t\t{\"-5\", 0, \"-5\", \"\"},\n\t\t{\"-500\", 2, \"-500\", \"-500.00\"},\n\t\t{\"-500\", -2, \"-500\", \"\"},\n\t\t{\"-545\", -1, \"-550\", \"\"},\n\t\t{\"-545\", -2, \"-600\", \"\"},\n\t\t{\"-545\", -3, \"-1000\", \"\"},\n\t\t{\"-545\", -4, \"-10000\", \"\"},\n\t\t{\"-499\", -3, \"-1000\", \"\"},\n\t\t{\"-499\", -4, \"-10000\", \"\"},\n\t}\n\n\tfor _, test := range tests {\n\t\td, err := NewFromString(test.input)\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\n\t\t// test Round\n\t\texpected, err := NewFromString(test.expected)\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tgot := d.RoundUp(test.places)\n\t\tif !got.Equal(expected) {\n\t\t\tt.Errorf(\"Rounding up %s to %d places, got %s, expected %s\",\n\t\t\t\td, test.places, got, expected)\n\t\t}\n\n\t\t// test StringFixed\n\t\tif test.expectedFixed == \"\" {\n\t\t\ttest.expectedFixed = test.expected\n\t\t}\n\t\tgotStr := got.StringFixed(test.places)\n\t\tif gotStr != test.expectedFixed {\n\t\t\tt.Errorf(\"(%s).StringFixed(%d): got %s, expected %s\",\n\t\t\t\td, test.places, gotStr, test.expectedFixed)\n\t\t}\n\t}\n}\n\nfunc TestDecimal_RoundDownAndStringFixed(t *testing.T) {\n\ttype testData struct {\n\t\tinput         string\n\t\tplaces        int32\n\t\texpected      string\n\t\texpectedFixed string\n\t}\n\ttests := []testData{\n\t\t{\"1.454\", 0, \"1\", \"\"},\n\t\t{\"1.454\", 1, \"1.4\", \"\"},\n\t\t{\"1.454\", 2, \"1.45\", \"\"},\n\t\t{\"1.454\", 3, \"1.454\", \"\"},\n\t\t{\"1.454\", 4, \"1.454\", \"1.4540\"},\n\t\t{\"1.454\", 5, \"1.454\", \"1.45400\"},\n\t\t{\"1.554\", 0, \"1\", \"\"},\n\t\t{\"1.554\", 1, \"1.5\", \"\"},\n\t\t{\"1.554\", 2, \"1.55\", \"\"},\n\t\t{\"0.554\", 0, \"0\", \"\"},\n\t\t{\"0.454\", 0, \"0\", \"\"},\n\t\t{\"0.454\", 5, \"0.454\", \"0.45400\"},\n\t\t{\"0\", 0, \"0\", \"\"},\n\t\t{\"0\", 1, \"0\", \"0.0\"},\n\t\t{\"0\", 2, \"0\", \"0.00\"},\n\t\t{\"0\", -1, \"0\", \"\"},\n\t\t{\"5\", 2, \"5\", \"5.00\"},\n\t\t{\"5\", 1, \"5\", \"5.0\"},\n\t\t{\"5\", 0, \"5\", \"\"},\n\t\t{\"500\", 2, \"500\", \"500.00\"},\n\t\t{\"500\", -2, \"500\", \"\"},\n\t\t{\"545\", -1, \"540\", \"\"},\n\t\t{\"545\", -2, \"500\", \"\"},\n\t\t{\"545\", -3, \"0\", \"\"},\n\t\t{\"545\", -4, \"0\", \"\"},\n\t\t{\"499\", -3, \"0\", \"\"},\n\t\t{\"499\", -4, \"0\", \"\"},\n\t\t{\"1.1001\", 2, \"1.10\", \"\"},\n\t\t{\"-1.1001\", 2, \"-1.10\", \"\"},\n\t\t{\"-1.454\", 0, \"-1\", \"\"},\n\t\t{\"-1.454\", 1, \"-1.4\", \"\"},\n\t\t{\"-1.454\", 2, \"-1.45\", \"\"},\n\t\t{\"-1.454\", 3, \"-1.454\", \"\"},\n\t\t{\"-1.454\", 4, \"-1.454\", \"-1.4540\"},\n\t\t{\"-1.454\", 5, \"-1.454\", \"-1.45400\"},\n\t\t{\"-1.554\", 0, \"-1\", \"\"},\n\t\t{\"-1.554\", 1, \"-1.5\", \"\"},\n\t\t{\"-1.554\", 2, \"-1.55\", \"\"},\n\t\t{\"-0.554\", 0, \"0\", \"\"},\n\t\t{\"-0.454\", 0, \"0\", \"\"},\n\t\t{\"-0.454\", 5, \"-0.454\", \"-0.45400\"},\n\t\t{\"-5\", 2, \"-5\", \"-5.00\"},\n\t\t{\"-5\", 1, \"-5\", \"-5.0\"},\n\t\t{\"-5\", 0, \"-5\", \"\"},\n\t\t{\"-500\", 2, \"-500\", \"-500.00\"},\n\t\t{\"-500\", -2, \"-500\", \"\"},\n\t\t{\"-545\", -1, \"-540\", \"\"},\n\t\t{\"-545\", -2, \"-500\", \"\"},\n\t\t{\"-545\", -3, \"0\", \"\"},\n\t\t{\"-545\", -4, \"0\", \"\"},\n\t\t{\"-499\", -3, \"0\", \"\"},\n\t\t{\"-499\", -4, \"0\", \"\"},\n\t}\n\n\tfor _, test := range tests {\n\t\td, err := NewFromString(test.input)\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\n\t\t// test Round\n\t\texpected, err := NewFromString(test.expected)\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tgot := d.RoundDown(test.places)\n\t\tif !got.Equal(expected) {\n\t\t\tt.Errorf(\"Rounding down %s to %d places, got %s, expected %s\",\n\t\t\t\td, test.places, got, expected)\n\t\t}\n\n\t\t// test StringFixed\n\t\tif test.expectedFixed == \"\" {\n\t\t\ttest.expectedFixed = test.expected\n\t\t}\n\t\tgotStr := got.StringFixed(test.places)\n\t\tif gotStr != test.expectedFixed {\n\t\t\tt.Errorf(\"(%s).StringFixed(%d): got %s, expected %s\",\n\t\t\t\td, test.places, gotStr, test.expectedFixed)\n\t\t}\n\t}\n}\n\nfunc TestDecimal_BankRoundAndStringFixed(t *testing.T) {\n\ttype testData struct {\n\t\tinput         string\n\t\tplaces        int32\n\t\texpected      string\n\t\texpectedFixed string\n\t}\n\ttests := []testData{\n\t\t{\"1.454\", 0, \"1\", \"\"},\n\t\t{\"1.454\", 1, \"1.5\", \"\"},\n\t\t{\"1.454\", 2, \"1.45\", \"\"},\n\t\t{\"1.454\", 3, \"1.454\", \"\"},\n\t\t{\"1.454\", 4, \"1.454\", \"1.4540\"},\n\t\t{\"1.454\", 5, \"1.454\", \"1.45400\"},\n\t\t{\"1.554\", 0, \"2\", \"\"},\n\t\t{\"1.554\", 1, \"1.6\", \"\"},\n\t\t{\"1.554\", 2, \"1.55\", \"\"},\n\t\t{\"0.554\", 0, \"1\", \"\"},\n\t\t{\"0.454\", 0, \"0\", \"\"},\n\t\t{\"0.454\", 5, \"0.454\", \"0.45400\"},\n\t\t{\"0\", 0, \"0\", \"\"},\n\t\t{\"0\", 1, \"0\", \"0.0\"},\n\t\t{\"0\", 2, \"0\", \"0.00\"},\n\t\t{\"0\", -1, \"0\", \"\"},\n\t\t{\"5\", 2, \"5\", \"5.00\"},\n\t\t{\"5\", 1, \"5\", \"5.0\"},\n\t\t{\"5\", 0, \"5\", \"\"},\n\t\t{\"500\", 2, \"500\", \"500.00\"},\n\t\t{\"545\", -2, \"500\", \"\"},\n\t\t{\"545\", -3, \"1000\", \"\"},\n\t\t{\"545\", -4, \"0\", \"\"},\n\t\t{\"499\", -3, \"0\", \"\"},\n\t\t{\"499\", -4, \"0\", \"\"},\n\t\t{\"1.45\", 1, \"1.4\", \"\"},\n\t\t{\"1.55\", 1, \"1.6\", \"\"},\n\t\t{\"1.65\", 1, \"1.6\", \"\"},\n\t\t{\"545\", -1, \"540\", \"\"},\n\t\t{\"565\", -1, \"560\", \"\"},\n\t\t{\"555\", -1, \"560\", \"\"},\n\t}\n\n\t// add negative number tests\n\tfor _, test := range tests {\n\t\texpected := test.expected\n\t\tif expected != \"0\" {\n\t\t\texpected = \"-\" + expected\n\t\t}\n\t\texpectedStr := test.expectedFixed\n\t\tif strings.ContainsAny(expectedStr, \"123456789\") && expectedStr != \"\" {\n\t\t\texpectedStr = \"-\" + expectedStr\n\t\t}\n\t\ttests = append(tests,\n\t\t\ttestData{\"-\" + test.input, test.places, expected, expectedStr})\n\t}\n\n\tfor _, test := range tests {\n\t\td, err := NewFromString(test.input)\n\t\tif err != nil {\n\t\t\tpanic(err)\n\t\t}\n\n\t\t// test Round\n\t\texpected, err := NewFromString(test.expected)\n\t\tif err != nil {\n\t\t\tpanic(err)\n\t\t}\n\t\tgot := d.RoundBank(test.places)\n\t\tif !got.Equal(expected) {\n\t\t\tt.Errorf(\"Bank Rounding %s to %d places, got %s, expected %s\",\n\t\t\t\td, test.places, got, expected)\n\t\t}\n\n\t\t// test StringFixed\n\t\tif test.expectedFixed == \"\" {\n\t\t\ttest.expectedFixed = test.expected\n\t\t}\n\t\tgotStr := d.StringFixedBank(test.places)\n\t\tif gotStr != test.expectedFixed {\n\t\t\tt.Errorf(\"(%s).StringFixed(%d): got %s, expected %s\",\n\t\t\t\td, test.places, gotStr, test.expectedFixed)\n\t\t}\n\t}\n}\n\nfunc TestDecimal_Uninitialized(t *testing.T) {\n\ta := Decimal{}\n\tb := Decimal{}\n\n\tdecs := []Decimal{\n\t\ta,\n\t\ta.rescale(10),\n\t\ta.Abs(),\n\t\ta.Add(b),\n\t\ta.Sub(b),\n\t\ta.Mul(b),\n\t\ta.Shift(0),\n\t\ta.Div(New(1, -1)),\n\t\ta.Round(2),\n\t\ta.Floor(),\n\t\ta.Ceil(),\n\t\ta.Truncate(2),\n\t}\n\n\tfor _, d := range decs {\n\t\tif d.String() != \"0\" {\n\t\t\tt.Errorf(\"expected 0, got %s\", d.String())\n\t\t}\n\t\tif d.StringFixed(3) != \"0.000\" {\n\t\t\tt.Errorf(\"expected 0, got %s\", d.StringFixed(3))\n\t\t}\n\t\tif d.StringScaled(-2) != \"0\" {\n\t\t\tt.Errorf(\"expected 0, got %s\", d.StringScaled(-2))\n\t\t}\n\t}\n\n\tif a.Cmp(b) != 0 {\n\t\tt.Errorf(\"a != b\")\n\t}\n\tif a.Sign() != 0 {\n\t\tt.Errorf(\"a.Sign() != 0\")\n\t}\n\tif a.Exponent() != 0 {\n\t\tt.Errorf(\"a.Exponent() != 0\")\n\t}\n\tif a.IntPart() != 0 {\n\t\tt.Errorf(\"a.IntPar() != 0\")\n\t}\n\tf, _ := a.Float64()\n\tif f != 0 {\n\t\tt.Errorf(\"a.Float64() != 0\")\n\t}\n\tif a.Rat().RatString() != \"0\" {\n\t\tt.Errorf(\"a.Rat() != 0, got %s\", a.Rat().RatString())\n\t}\n}\n\nfunc TestDecimal_Add(t *testing.T) {\n\ttype Inp struct {\n\t\ta string\n\t\tb string\n\t}\n\n\tinputs := map[Inp]string{\n\t\tInp{\"2\", \"3\"}:                     \"5\",\n\t\tInp{\"2454495034\", \"3451204593\"}:   \"5905699627\",\n\t\tInp{\"24544.95034\", \".3451204593\"}: \"24545.2954604593\",\n\t\tInp{\".1\", \".1\"}:                   \"0.2\",\n\t\tInp{\".1\", \"-.1\"}:                  \"0\",\n\t\tInp{\"0\", \"1.001\"}:                 \"1.001\",\n\t}\n\n\tfor inp, res := range inputs {\n\t\ta, err := NewFromString(inp.a)\n\t\tif err != nil {\n\t\t\tt.FailNow()\n\t\t}\n\t\tb, err := NewFromString(inp.b)\n\t\tif err != nil {\n\t\t\tt.FailNow()\n\t\t}\n\t\tc := a.Add(b)\n\t\tif c.String() != res {\n\t\t\tt.Errorf(\"expected %s, got %s\", res, c.String())\n\t\t}\n\t}\n}\n\nfunc TestDecimal_Sub(t *testing.T) {\n\ttype Inp struct {\n\t\ta string\n\t\tb string\n\t}\n\n\tinputs := map[Inp]string{\n\t\tInp{\"2\", \"3\"}:                     \"-1\",\n\t\tInp{\"12\", \"3\"}:                    \"9\",\n\t\tInp{\"-2\", \"9\"}:                    \"-11\",\n\t\tInp{\"2454495034\", \"3451204593\"}:   \"-996709559\",\n\t\tInp{\"24544.95034\", \".3451204593\"}: \"24544.6052195407\",\n\t\tInp{\".1\", \"-.1\"}:                  \"0.2\",\n\t\tInp{\".1\", \".1\"}:                   \"0\",\n\t\tInp{\"0\", \"1.001\"}:                 \"-1.001\",\n\t\tInp{\"1.001\", \"0\"}:                 \"1.001\",\n\t\tInp{\"2.3\", \".3\"}:                  \"2\",\n\t}\n\n\tfor inp, res := range inputs {\n\t\ta, err := NewFromString(inp.a)\n\t\tif err != nil {\n\t\t\tt.FailNow()\n\t\t}\n\t\tb, err := NewFromString(inp.b)\n\t\tif err != nil {\n\t\t\tt.FailNow()\n\t\t}\n\t\tc := a.Sub(b)\n\t\tif c.String() != res {\n\t\t\tt.Errorf(\"expected %s, got %s\", res, c.String())\n\t\t}\n\t}\n}\n\nfunc TestDecimal_Neg(t *testing.T) {\n\tinputs := map[string]string{\n\t\t\"0\":     \"0\",\n\t\t\"10\":    \"-10\",\n\t\t\"5.56\":  \"-5.56\",\n\t\t\"-10\":   \"10\",\n\t\t\"-5.56\": \"5.56\",\n\t}\n\n\tfor inp, res := range inputs {\n\t\ta, err := NewFromString(inp)\n\t\tif err != nil {\n\t\t\tt.FailNow()\n\t\t}\n\t\tb := a.Neg()\n\t\tif b.String() != res {\n\t\t\tt.Errorf(\"expected %s, got %s\", res, b.String())\n\t\t}\n\t}\n}\n\nfunc TestDecimal_NegFromEmpty(t *testing.T) {\n\ta := Decimal{}\n\tb := a.Neg()\n\tif b.String() != \"0\" {\n\t\tt.Errorf(\"expected %s, got %s\", \"0\", b)\n\t}\n}\n\nfunc TestDecimal_Mul(t *testing.T) {\n\ttype Inp struct {\n\t\ta string\n\t\tb string\n\t}\n\n\tinputs := map[Inp]string{\n\t\tInp{\"2\", \"3\"}:                     \"6\",\n\t\tInp{\"2454495034\", \"3451204593\"}:   \"8470964534836491162\",\n\t\tInp{\"24544.95034\", \".3451204593\"}: \"8470.964534836491162\",\n\t\tInp{\".1\", \".1\"}:                   \"0.01\",\n\t\tInp{\"0\", \"1.001\"}:                 \"0\",\n\t}\n\n\tfor inp, res := range inputs {\n\t\ta, err := NewFromString(inp.a)\n\t\tif err != nil {\n\t\t\tt.FailNow()\n\t\t}\n\t\tb, err := NewFromString(inp.b)\n\t\tif err != nil {\n\t\t\tt.FailNow()\n\t\t}\n\t\tc := a.Mul(b)\n\t\tif c.String() != res {\n\t\t\tt.Errorf(\"expected %s, got %s\", res, c.String())\n\t\t}\n\t}\n\n\t// positive scale\n\tc := New(1234, 5).Mul(New(45, -1))\n\tif c.String() != \"555300000\" {\n\t\tt.Errorf(\"Expected %s, got %s\", \"555300000\", c.String())\n\t}\n}\n\nfunc TestDecimal_Shift(t *testing.T) {\n\ttype Inp struct {\n\t\ta string\n\t\tb int32\n\t}\n\n\tinputs := map[Inp]string{\n\t\tInp{\"6\", 3}:                         \"6000\",\n\t\tInp{\"10\", -2}:                       \"0.1\",\n\t\tInp{\"2.2\", 1}:                       \"22\",\n\t\tInp{\"-2.2\", -1}:                     \"-0.22\",\n\t\tInp{\"12.88\", 5}:                     \"1288000\",\n\t\tInp{\"-10234274355545544493\", -3}:    \"-10234274355545544.493\",\n\t\tInp{\"-4612301402398.4753343454\", 5}: \"-461230140239847533.43454\",\n\t}\n\n\tfor inp, expectedStr := range inputs {\n\t\tnum, _ := NewFromString(inp.a)\n\n\t\tgot := num.Shift(inp.b)\n\t\texpected, _ := NewFromString(expectedStr)\n\t\tif !got.Equal(expected) {\n\t\t\tt.Errorf(\"expected %v when shifting %v by %v, got %v\",\n\t\t\t\texpected, num, inp.b, got)\n\t\t}\n\t}\n}\n\nfunc TestDecimal_Div(t *testing.T) {\n\ttype Inp struct {\n\t\ta string\n\t\tb string\n\t}\n\n\tinputs := map[Inp]string{\n\t\tInp{\"6\", \"3\"}:                            \"2\",\n\t\tInp{\"10\", \"2\"}:                           \"5\",\n\t\tInp{\"2.2\", \"1.1\"}:                        \"2\",\n\t\tInp{\"-2.2\", \"-1.1\"}:                      \"2\",\n\t\tInp{\"12.88\", \"5.6\"}:                      \"2.3\",\n\t\tInp{\"1023427554493\", \"43432632\"}:         \"23563.5628642767953828\", // rounded\n\t\tInp{\"1\", \"434324545566634\"}:              \"0.0000000000000023\",\n\t\tInp{\"1\", \"3\"}:                            \"0.3333333333333333\",\n\t\tInp{\"2\", \"3\"}:                            \"0.6666666666666667\", // rounded\n\t\tInp{\"10000\", \"3\"}:                        \"3333.3333333333333333\",\n\t\tInp{\"10234274355545544493\", \"-3\"}:        \"-3411424785181848164.3333333333333333\",\n\t\tInp{\"-4612301402398.4753343454\", \"23.5\"}: \"-196268144782.9138440146978723\",\n\t}\n\n\tfor inp, expectedStr := range inputs {\n\t\tnum, err := NewFromString(inp.a)\n\t\tif err != nil {\n\t\t\tt.FailNow()\n\t\t}\n\t\tdenom, err := NewFromString(inp.b)\n\t\tif err != nil {\n\t\t\tt.FailNow()\n\t\t}\n\t\tgot := num.Div(denom)\n\t\texpected, _ := NewFromString(expectedStr)\n\t\tif !got.Equal(expected) {\n\t\t\tt.Errorf(\"expected %v when dividing %v by %v, got %v\",\n\t\t\t\texpected, num, denom, got)\n\t\t}\n\t\tgot2 := num.DivRound(denom, int32(DivisionPrecision))\n\t\tif !got2.Equal(expected) {\n\t\t\tt.Errorf(\"expected %v on DivRound (%v,%v), got %v\", expected, num, denom, got2)\n\t\t}\n\t}\n\n\ttype Inp2 struct {\n\t\tn    int64\n\t\texp  int32\n\t\tn2   int64\n\t\texp2 int32\n\t}\n\n\t// test code path where exp > 0\n\tinputs2 := map[Inp2]string{\n\t\tInp2{124, 10, 3, 1}: \"41333333333.3333333333333333\",\n\t\tInp2{124, 10, 3, 0}: \"413333333333.3333333333333333\",\n\t\tInp2{124, 10, 6, 1}: \"20666666666.6666666666666667\",\n\t\tInp2{124, 10, 6, 0}: \"206666666666.6666666666666667\",\n\t\tInp2{10, 10, 10, 1}: \"1000000000\",\n\t}\n\n\tfor inp, expectedAbs := range inputs2 {\n\t\tfor i := -1; i <= 1; i += 2 {\n\t\t\tfor j := -1; j <= 1; j += 2 {\n\t\t\t\tn := inp.n * int64(i)\n\t\t\t\tn2 := inp.n2 * int64(j)\n\t\t\t\tnum := New(n, inp.exp)\n\t\t\t\tdenom := New(n2, inp.exp2)\n\t\t\t\texpected := expectedAbs\n\t\t\t\tif i != j {\n\t\t\t\t\texpected = \"-\" + expectedAbs\n\t\t\t\t}\n\t\t\t\tgot := num.Div(denom)\n\t\t\t\tif got.String() != expected {\n\t\t\t\t\tt.Errorf(\"expected %s when dividing %v by %v, got %v\",\n\t\t\t\t\t\texpected, num, denom, got)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc TestDecimal_QuoRem(t *testing.T) {\n\ttype Inp4 struct {\n\t\td   string\n\t\td2  string\n\t\texp int32\n\t\tq   string\n\t\tr   string\n\t}\n\tcases := []Inp4{\n\t\t{\"10\", \"1\", 0, \"10\", \"0\"},\n\t\t{\"1\", \"10\", 0, \"0\", \"1\"},\n\t\t{\"1\", \"4\", 2, \"0.25\", \"0\"},\n\t\t{\"1\", \"8\", 2, \"0.12\", \"0.04\"},\n\t\t{\"10\", \"3\", 1, \"3.3\", \"0.1\"},\n\t\t{\"100\", \"3\", 1, \"33.3\", \"0.1\"},\n\t\t{\"1000\", \"10\", -3, \"0\", \"1000\"},\n\t\t{\"1e-3\", \"2e-5\", 0, \"50\", \"0\"},\n\t\t{\"1e-3\", \"2e-3\", 1, \"0.5\", \"0\"},\n\t\t{\"4e-3\", \"0.8\", 4, \"5e-3\", \"0\"},\n\t\t{\"4.1e-3\", \"0.8\", 3, \"5e-3\", \"1e-4\"},\n\t\t{\"-4\", \"-3\", 0, \"1\", \"-1\"},\n\t\t{\"-4\", \"3\", 0, \"-1\", \"-1\"},\n\t}\n\n\tfor _, inp4 := range cases {\n\t\td, _ := NewFromString(inp4.d)\n\t\td2, _ := NewFromString(inp4.d2)\n\t\tprec := inp4.exp\n\t\tq, r := d.QuoRem(d2, prec)\n\t\texpectedQ, _ := NewFromString(inp4.q)\n\t\texpectedR, _ := NewFromString(inp4.r)\n\t\tif !q.Equal(expectedQ) || !r.Equal(expectedR) {\n\t\t\tt.Errorf(\"bad QuoRem division %s , %s , %d got %v, %v expected %s , %s\",\n\t\t\t\tinp4.d, inp4.d2, prec, q, r, inp4.q, inp4.r)\n\t\t}\n\t\tif !d.Equal(d2.Mul(q).Add(r)) {\n\t\t\tt.Errorf(\"not fitting: d=%v, d2= %v, prec=%d, q=%v, r=%v\",\n\t\t\t\td, d2, prec, q, r)\n\t\t}\n\t\tif !q.Equal(q.Truncate(prec)) {\n\t\t\tt.Errorf(\"quotient wrong precision: d=%v, d2= %v, prec=%d, q=%v, r=%v\",\n\t\t\t\td, d2, prec, q, r)\n\t\t}\n\t\tif r.Abs().Cmp(d2.Abs().Mul(New(1, -prec))) >= 0 {\n\t\t\tt.Errorf(\"remainder too large: d=%v, d2= %v, prec=%d, q=%v, r=%v\",\n\t\t\t\td, d2, prec, q, r)\n\t\t}\n\t\tif r.value.Sign()*d.value.Sign() < 0 {\n\t\t\tt.Errorf(\"signum of divisor and rest do not match: d=%v, d2= %v, prec=%d, q=%v, r=%v\",\n\t\t\t\td, d2, prec, q, r)\n\t\t}\n\t}\n}\n\ntype DivTestCase struct {\n\td    Decimal\n\td2   Decimal\n\tprec int32\n}\n\nfunc createDivTestCases() []DivTestCase {\n\tres := make([]DivTestCase, 0)\n\tvar n int32 = 5\n\ta := []int{1, 2, 3, 6, 7, 10, 100, 14, 5, 400, 0, 1000000, 1000000 + 1, 1000000 - 1}\n\tfor s := -1; s < 2; s = s + 2 { // 2\n\t\tfor s2 := -1; s2 < 2; s2 = s2 + 2 { // 2\n\t\t\tfor e1 := -n; e1 <= n; e1++ { // 2n+1\n\t\t\t\tfor e2 := -n; e2 <= n; e2++ { // 2n+1\n\t\t\t\t\tvar prec int32\n\t\t\t\t\tfor prec = -n; prec <= n; prec++ { // 2n+1\n\t\t\t\t\t\tfor _, v1 := range a { // 11\n\t\t\t\t\t\t\tfor _, v2 := range a { // 11, even if 0 is skipped\n\t\t\t\t\t\t\t\tsign1 := New(int64(s), 0)\n\t\t\t\t\t\t\t\tsign2 := New(int64(s2), 0)\n\t\t\t\t\t\t\t\td := sign1.Mul(New(int64(v1), e1))\n\t\t\t\t\t\t\t\td2 := sign2.Mul(New(int64(v2), e2))\n\t\t\t\t\t\t\t\tres = append(res, DivTestCase{d, d2, prec})\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn res\n}\n\nfunc TestDecimal_QuoRem2(t *testing.T) {\n\tfor _, tc := range createDivTestCases() {\n\t\td := tc.d\n\t\tif sign(tc.d2) == 0 {\n\t\t\tcontinue\n\t\t}\n\t\td2 := tc.d2\n\t\tprec := tc.prec\n\t\tq, r := d.QuoRem(d2, prec)\n\t\t// rule 1: d = d2*q +r\n\t\tif !d.Equal(d2.Mul(q).Add(r)) {\n\t\t\tt.Errorf(\"not fitting, d=%v, d2=%v, prec=%d, q=%v, r=%v\",\n\t\t\t\td, d2, prec, q, r)\n\t\t}\n\t\t// rule 2: q is integral multiple of 10^(-prec)\n\t\tif !q.Equal(q.Truncate(prec)) {\n\t\t\tt.Errorf(\"quotient wrong precision, d=%v, d2=%v, prec=%d, q=%v, r=%v\",\n\t\t\t\td, d2, prec, q, r)\n\t\t}\n\t\t// rule 3: abs(r)<abs(d) * 10^(-prec)\n\t\tif r.Abs().Cmp(d2.Abs().Mul(New(1, -prec))) >= 0 {\n\t\t\tt.Errorf(\"remainder too large, d=%v, d2=%v, prec=%d, q=%v, r=%v\",\n\t\t\t\td, d2, prec, q, r)\n\t\t}\n\t\t// rule 4: r and d have the same sign\n\t\tif r.value.Sign()*d.value.Sign() < 0 {\n\t\t\tt.Errorf(\"signum of divisor and rest do not match, \"+\n\t\t\t\t\"d=%v, d2=%v, prec=%d, q=%v, r=%v\",\n\t\t\t\td, d2, prec, q, r)\n\t\t}\n\t}\n}\n\n// this is the old Div method from decimal\n// Div returns d / d2. If it doesn't divide exactly, the result will have\n// DivisionPrecision digits after the decimal point.\nfunc (d Decimal) DivOld(d2 Decimal, prec int) Decimal {\n\t// NOTE(vadim): division is hard, use Rat to do it\n\tratNum := d.Rat()\n\tratDenom := d2.Rat()\n\n\tquoRat := big.NewRat(0, 1).Quo(ratNum, ratDenom)\n\n\t// HACK(vadim): converting from Rat to Decimal inefficiently for now\n\tret, err := NewFromString(quoRat.FloatString(prec))\n\tif err != nil {\n\t\tpanic(err) // this should never happen\n\t}\n\treturn ret\n}\n\nfunc sign(d Decimal) int {\n\treturn d.value.Sign()\n}\n\n// rules for rounded divide, rounded to integer\n// rounded_divide(d,d2) = q\n// sign q * sign (d/d2) >= 0\n// for d and d2 >0 :\n// q is already rounded\n// q = d/d2 + r , with r > -0.5 and r <= 0.5\n// thus q-d/d2 = r, with r > -0.5 and r <= 0.5\n// and d2 q -d = r d2 with r d2 > -d2/2 and r d2 <= d2/2\n// and 2 (d2 q -d) = x with x > -d2 and x <= d2\n// if we factor in precision then x > -d2 * 10^(-precision) and x <= d2 * 10(-precision)\n\nfunc TestDecimal_DivRound(t *testing.T) {\n\tcases := []struct {\n\t\td      string\n\t\td2     string\n\t\tprec   int32\n\t\tresult string\n\t}{\n\t\t{\"2\", \"2\", 0, \"1\"},\n\t\t{\"1\", \"2\", 0, \"1\"},\n\t\t{\"-1\", \"2\", 0, \"-1\"},\n\t\t{\"-1\", \"-2\", 0, \"1\"},\n\t\t{\"1\", \"-2\", 0, \"-1\"},\n\t\t{\"1\", \"-20\", 1, \"-0.1\"},\n\t\t{\"1\", \"-20\", 2, \"-0.05\"},\n\t\t{\"1\", \"20.0000000000000000001\", 1, \"0\"},\n\t\t{\"1\", \"19.9999999999999999999\", 1, \"0.1\"},\n\t}\n\tfor _, s := range cases {\n\t\td, _ := NewFromString(s.d)\n\t\td2, _ := NewFromString(s.d2)\n\t\tresult, _ := NewFromString(s.result)\n\t\tprec := s.prec\n\t\tq := d.DivRound(d2, prec)\n\t\tif sign(q)*sign(d)*sign(d2) < 0 {\n\t\t\tt.Errorf(\"sign of quotient wrong, got: %v/%v is about %v\", d, d2, q)\n\t\t}\n\t\tx := q.Mul(d2).Abs().Sub(d.Abs()).Mul(New(2, 0))\n\t\tif x.Cmp(d2.Abs().Mul(New(1, -prec))) > 0 {\n\t\t\tt.Errorf(\"wrong rounding, got: %v/%v prec=%d is about %v\", d, d2, prec, q)\n\t\t}\n\t\tif x.Cmp(d2.Abs().Mul(New(-1, -prec))) <= 0 {\n\t\t\tt.Errorf(\"wrong rounding, got: %v/%v prec=%d is about %v\", d, d2, prec, q)\n\t\t}\n\t\tif !q.Equal(result) {\n\t\t\tt.Errorf(\"rounded division wrong %s / %s scale %d = %s, got %v\", s.d, s.d2, prec, s.result, q)\n\t\t}\n\t}\n}\n\nfunc TestDecimal_DivRound2(t *testing.T) {\n\tfor _, tc := range createDivTestCases() {\n\t\td := tc.d\n\t\tif sign(tc.d2) == 0 {\n\t\t\tcontinue\n\t\t}\n\t\td2 := tc.d2\n\t\tprec := tc.prec\n\t\tq := d.DivRound(d2, prec)\n\t\tif sign(q)*sign(d)*sign(d2) < 0 {\n\t\t\tt.Errorf(\"sign of quotient wrong, got: %v/%v is about %v\", d, d2, q)\n\t\t}\n\t\tx := q.Mul(d2).Abs().Sub(d.Abs()).Mul(New(2, 0))\n\t\tif x.Cmp(d2.Abs().Mul(New(1, -prec))) > 0 {\n\t\t\tt.Errorf(\"wrong rounding, got: %v/%v prec=%d is about %v\", d, d2, prec, q)\n\t\t}\n\t\tif x.Cmp(d2.Abs().Mul(New(-1, -prec))) <= 0 {\n\t\t\tt.Errorf(\"wrong rounding, got: %v/%v prec=%d is about %v\", d, d2, prec, q)\n\t\t}\n\t}\n}\n\nfunc TestDecimal_RoundCash(t *testing.T) {\n\ttests := []struct {\n\t\td        string\n\t\tinterval uint8\n\t\tresult   string\n\t}{\n\t\t{\"3.44\", 5, \"3.45\"},\n\t\t{\"3.43\", 5, \"3.45\"},\n\t\t{\"3.42\", 5, \"3.40\"},\n\t\t{\"3.425\", 5, \"3.45\"},\n\t\t{\"3.47\", 5, \"3.45\"},\n\t\t{\"3.478\", 5, \"3.50\"},\n\t\t{\"3.48\", 5, \"3.50\"},\n\t\t{\"348\", 5, \"348\"},\n\n\t\t{\"3.23\", 10, \"3.20\"},\n\t\t{\"3.33\", 10, \"3.30\"},\n\t\t{\"3.53\", 10, \"3.50\"},\n\t\t{\"3.949\", 10, \"3.90\"},\n\t\t{\"3.95\", 10, \"4.00\"},\n\t\t{\"395\", 10, \"395\"},\n\n\t\t{\"3.23\", 25, \"3.25\"},\n\t\t{\"3.33\", 25, \"3.25\"},\n\t\t{\"3.53\", 25, \"3.50\"},\n\t\t{\"3.93\", 25, \"4.00\"},\n\t\t{\"3.41\", 25, \"3.50\"},\n\n\t\t{\"3.249\", 50, \"3.00\"},\n\t\t{\"3.33\", 50, \"3.50\"},\n\t\t{\"3.749999999\", 50, \"3.50\"},\n\t\t{\"3.75\", 50, \"4.00\"},\n\t\t{\"3.93\", 50, \"4.00\"},\n\t\t{\"393\", 50, \"393\"},\n\n\t\t{\"3.249\", 100, \"3.00\"},\n\t\t{\"3.49999\", 100, \"3.00\"},\n\t\t{\"3.50\", 100, \"4.00\"},\n\t\t{\"3.75\", 100, \"4.00\"},\n\t\t{\"3.93\", 100, \"4.00\"},\n\t\t{\"393\", 100, \"393\"},\n\t}\n\tfor i, test := range tests {\n\t\td, _ := NewFromString(test.d)\n\t\thaveRounded := d.RoundCash(test.interval)\n\t\tresult, _ := NewFromString(test.result)\n\n\t\tif !haveRounded.Equal(result) {\n\t\t\tt.Errorf(\"Index %d: Cash rounding for %q interval %d want %q, have %q\", i, test.d, test.interval, test.result, haveRounded)\n\t\t}\n\t}\n}\n\nfunc TestDecimal_RoundCash_Panic(t *testing.T) {\n\tdefer func() {\n\t\tif r := recover(); r != nil {\n\t\t\tif have, ok := r.(string); ok {\n\t\t\t\tconst want = \"Decimal does not support this Cash rounding interval `231`. Supported: 5, 10, 25, 50, 100\"\n\t\t\t\tif want != have {\n\t\t\t\t\tt.Errorf(\"\\nWant: %q\\nHave: %q\", want, have)\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tt.Errorf(\"Panic should contain an error string but got:\\n%+v\", r)\n\t\t\t}\n\t\t} else {\n\t\t\tt.Error(\"Expecting a panic but got nothing\")\n\t\t}\n\t}()\n\td, _ := NewFromString(\"1\")\n\td.RoundCash(231)\n}\n\nfunc TestDecimal_Mod(t *testing.T) {\n\ttype Inp struct {\n\t\ta string\n\t\tb string\n\t}\n\n\tinputs := map[Inp]string{\n\t\tInp{\"3\", \"2\"}:                           \"1\",\n\t\tInp{\"3451204593\", \"2454495034\"}:         \"996709559\",\n\t\tInp{\"9999999999\", \"1275\"}:               \"324\",\n\t\tInp{\"9999999999.9999998\", \"1275.49\"}:    \"239.2399998\",\n\t\tInp{\"24544.95034\", \"0.3451204593\"}:      \"0.3283950433\",\n\t\tInp{\"0.499999999999999999\", \"0.25\"}:     \"0.249999999999999999\",\n\t\tInp{\"0.989512958912895912\", \"0.000001\"}: \"0.000000958912895912\",\n\t\tInp{\"0.1\", \"0.1\"}:                       \"0\",\n\t\tInp{\"0\", \"1.001\"}:                       \"0\",\n\t\tInp{\"-7.5\", \"2\"}:                        \"-1.5\",\n\t\tInp{\"7.5\", \"-2\"}:                        \"1.5\",\n\t\tInp{\"-7.5\", \"-2\"}:                       \"-1.5\",\n\t\tInp{\"41\", \"21\"}:                         \"20\",\n\t\tInp{\"400000000001\", \"200000000001\"}:     \"200000000000\",\n\t}\n\n\tfor inp, res := range inputs {\n\t\ta, err := NewFromString(inp.a)\n\t\tif err != nil {\n\t\t\tt.FailNow()\n\t\t}\n\t\tb, err := NewFromString(inp.b)\n\t\tif err != nil {\n\t\t\tt.FailNow()\n\t\t}\n\t\tc := a.Mod(b)\n\t\tif c.String() != res {\n\t\t\tt.Errorf(\"expected %s, got %s\", res, c.String())\n\t\t}\n\t}\n}\n\nfunc TestDecimal_Overflow(t *testing.T) {\n\tif !didPanic(func() { New(1, math.MinInt32).Mul(New(1, math.MinInt32)) }) {\n\t\tt.Fatalf(\"should have gotten an overflow panic\")\n\t}\n\tif !didPanic(func() { New(1, math.MaxInt32).Mul(New(1, math.MaxInt32)) }) {\n\t\tt.Fatalf(\"should have gotten an overflow panic\")\n\t}\n}\n\nfunc TestDecimal_ExtremeValues(t *testing.T) {\n\t// NOTE(vadim): this test takes pretty much forever\n\tif testing.Short() {\n\t\tt.Skip()\n\t}\n\n\t// NOTE(vadim): Seriously, the numbers involved are so large that this\n\t// test will take way too long, so mark it as success if it takes over\n\t// 1 second. The way this test typically fails (integer overflow) is that\n\t// a wrong result appears quickly, so if it takes a long time then it is\n\t// probably working properly.\n\t// Why even bother testing this? Completeness, I guess. -Vadim\n\tconst timeLimit = 1 * time.Second\n\ttest := func(f func()) {\n\t\tc := make(chan bool)\n\t\tgo func() {\n\t\t\tf()\n\t\t\tclose(c)\n\t\t}()\n\t\tselect {\n\t\tcase <-c:\n\t\tcase <-time.After(timeLimit):\n\t\t}\n\t}\n\n\ttest(func() {\n\t\tgot := New(123, math.MinInt32).Floor()\n\t\tif !got.Equal(NewFromFloat(0)) {\n\t\t\tt.Errorf(\"Error: got %s, expected 0\", got)\n\t\t}\n\t})\n\ttest(func() {\n\t\tgot := New(123, math.MinInt32).Ceil()\n\t\tif !got.Equal(NewFromFloat(1)) {\n\t\t\tt.Errorf(\"Error: got %s, expected 1\", got)\n\t\t}\n\t})\n\ttest(func() {\n\t\tgot := New(123, math.MinInt32).Rat().FloatString(10)\n\t\texpected := \"0.0000000000\"\n\t\tif got != expected {\n\t\t\tt.Errorf(\"Error: got %s, expected %s\", got, expected)\n\t\t}\n\t})\n}\n\nfunc TestIntPart(t *testing.T) {\n\tfor _, testCase := range []struct {\n\t\tDec     string\n\t\tIntPart int64\n\t}{\n\t\t{\"0.01\", 0},\n\t\t{\"12.1\", 12},\n\t\t{\"9999.999\", 9999},\n\t\t{\"-32768.01234\", -32768},\n\t} {\n\t\td, err := NewFromString(testCase.Dec)\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tif d.IntPart() != testCase.IntPart {\n\t\t\tt.Errorf(\"expect %d, got %d\", testCase.IntPart, d.IntPart())\n\t\t}\n\t}\n}\n\nfunc TestBigInt(t *testing.T) {\n\ttestCases := []struct {\n\t\tDec       string\n\t\tBigIntRep string\n\t}{\n\t\t{\"0.0\", \"0\"},\n\t\t{\"0.00000\", \"0\"},\n\t\t{\"0.01\", \"0\"},\n\t\t{\"12.1\", \"12\"},\n\t\t{\"9999.999\", \"9999\"},\n\t\t{\"-32768.01234\", \"-32768\"},\n\t\t{\"-572372.0000000001\", \"-572372\"},\n\t}\n\n\tfor _, testCase := range testCases {\n\t\td, err := NewFromString(testCase.Dec)\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tif d.BigInt().String() != testCase.BigIntRep {\n\t\t\tt.Errorf(\"expect %s, got %s\", testCase.BigIntRep, d.BigInt())\n\t\t}\n\t}\n}\n\nfunc TestBigFloat(t *testing.T) {\n\ttestCases := []struct {\n\t\tDec         string\n\t\tBigFloatRep string\n\t}{\n\t\t{\"0.0\", \"0\"},\n\t\t{\"0.00000\", \"0\"},\n\t\t{\"0.01\", \"0.01\"},\n\t\t{\"12.1\", \"12.1\"},\n\t\t{\"9999.999\", \"9999.999\"},\n\t\t{\"-32768.01234\", \"-32768.01234\"},\n\t\t{\"-572372.0000000001\", \"-572372\"},\n\t\t{\"512.012345123451234512345\", \"512.0123451\"},\n\t\t{\"1.010101010101010101010101010101\", \"1.01010101\"},\n\t\t{\"55555555.555555555555555555555\", \"55555555.56\"},\n\t}\n\n\tfor _, testCase := range testCases {\n\t\td, err := NewFromString(testCase.Dec)\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tif d.BigFloat().String() != testCase.BigFloatRep {\n\t\t\tt.Errorf(\"expect %s, got %s\", testCase.BigFloatRep, d.BigFloat())\n\t\t}\n\t}\n}\n\nfunc TestDecimal_Min(t *testing.T) {\n\t// the first element in the array is the expected answer, rest are inputs\n\ttestCases := [][]float64{\n\t\t{0, 0},\n\t\t{1, 1},\n\t\t{-1, -1},\n\t\t{1, 1, 2},\n\t\t{-2, 1, 2, -2},\n\t\t{-3, 0, 2, -2, -3},\n\t}\n\n\tfor _, test := range testCases {\n\t\texpected, input := test[0], test[1:]\n\t\texpectedDecimal := NewFromFloat(expected)\n\t\tdecimalInput := []Decimal{}\n\t\tfor _, inp := range input {\n\t\t\td := NewFromFloat(inp)\n\t\t\tdecimalInput = append(decimalInput, d)\n\t\t}\n\t\tgot := Min(decimalInput[0], decimalInput[1:]...)\n\t\tif !got.Equal(expectedDecimal) {\n\t\t\tt.Errorf(\"Expected %v, got %v, input=%+v\", expectedDecimal, got,\n\t\t\t\tdecimalInput)\n\t\t}\n\t}\n}\n\nfunc TestDecimal_Max(t *testing.T) {\n\t// the first element in the array is the expected answer, rest are inputs\n\ttestCases := [][]float64{\n\t\t{0, 0},\n\t\t{1, 1},\n\t\t{-1, -1},\n\t\t{2, 1, 2},\n\t\t{2, 1, 2, -2},\n\t\t{3, 0, 3, -2},\n\t\t{-2, -3, -2},\n\t}\n\n\tfor _, test := range testCases {\n\t\texpected, input := test[0], test[1:]\n\t\texpectedDecimal := NewFromFloat(expected)\n\t\tdecimalInput := []Decimal{}\n\t\tfor _, inp := range input {\n\t\t\td := NewFromFloat(inp)\n\t\t\tdecimalInput = append(decimalInput, d)\n\t\t}\n\t\tgot := Max(decimalInput[0], decimalInput[1:]...)\n\t\tif !got.Equal(expectedDecimal) {\n\t\t\tt.Errorf(\"Expected %v, got %v, input=%+v\", expectedDecimal, got,\n\t\t\t\tdecimalInput)\n\t\t}\n\t}\n}\n\nfunc scanHelper(t *testing.T, dbval interface{}, expected Decimal) {\n\tt.Helper()\n\n\ta := Decimal{}\n\tif err := a.Scan(dbval); err != nil {\n\t\t// Scan failed... no need to test result value\n\t\tt.Errorf(\"a.Scan(%v) failed with message: %s\", dbval, err)\n\t} else if !a.Equal(expected) {\n\t\t// Scan succeeded... test resulting values\n\t\tt.Errorf(\"%s does not equal to %s\", a, expected)\n\t}\n}\n\nfunc TestDecimal_Scan(t *testing.T) {\n\t// test the Scan method that implements the sql.Scanner interface\n\t// check different types received from various database drivers\n\n\tdbvalue := 54.33\n\texpected := NewFromFloat(dbvalue)\n\tscanHelper(t, dbvalue, expected)\n\n\t// apparently MySQL 5.7.16 and returns these as float32 so we need\n\t// to handle these as well\n\tdbvalueFloat32 := float32(54.33)\n\texpected = NewFromFloat(float64(dbvalueFloat32))\n\tscanHelper(t, dbvalueFloat32, expected)\n\n\t// at least SQLite returns an int64 when 0 is stored in the db\n\t// and you specified a numeric format on the schema\n\tdbvalueInt := int64(0)\n\texpected = New(dbvalueInt, 0)\n\tscanHelper(t, dbvalueInt, expected)\n\n\t// also test uint64\n\tdbvalueUint64 := uint64(2)\n\texpected = New(2, 0)\n\tscanHelper(t, dbvalueUint64, expected)\n\n\t// in case you specified a varchar in your SQL schema,\n\t// the database driver may return either []byte or string\n\tvalueStr := \"535.666\"\n\tdbvalueStr := []byte(valueStr)\n\texpected, err := NewFromString(valueStr)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tscanHelper(t, dbvalueStr, expected)\n\tscanHelper(t, valueStr, expected)\n\n\ttype foo struct{}\n\ta := Decimal{}\n\terr = a.Scan(foo{})\n\tif err == nil {\n\t\tt.Errorf(\"a.Scan(Foo{}) should have thrown an error but did not\")\n\t}\n}\n\nfunc TestDecimal_Value(t *testing.T) {\n\t// Make sure this does implement the database/sql's driver.Valuer interface\n\tvar d Decimal\n\tif _, ok := interface{}(d).(driver.Valuer); !ok {\n\t\tt.Error(\"Decimal does not implement driver.Valuer\")\n\t}\n\n\t// check that normal case is handled appropriately\n\ta := New(1234, -2)\n\texpected := \"12.34\"\n\tvalue, err := a.Value()\n\tif err != nil {\n\t\tt.Errorf(\"Decimal(12.34).Value() failed with message: %s\", err)\n\t} else if value.(string) != expected {\n\t\tt.Errorf(\"%s does not equal to %s\", a, expected)\n\t}\n}\n\n// old tests after this line\n\nfunc TestDecimal_Scale(t *testing.T) {\n\ta := New(1234, -3)\n\tif a.Exponent() != -3 {\n\t\tt.Errorf(\"error\")\n\t}\n}\n\nfunc TestDecimal_Abs1(t *testing.T) {\n\ta := New(-1234, -4)\n\tb := New(1234, -4)\n\n\tc := a.Abs()\n\tif c.Cmp(b) != 0 {\n\t\tt.Errorf(\"error\")\n\t}\n}\n\nfunc TestDecimal_Abs2(t *testing.T) {\n\ta := New(-1234, -4)\n\tb := New(1234, -4)\n\n\tc := b.Abs()\n\tif c.Cmp(a) == 0 {\n\t\tt.Errorf(\"error\")\n\t}\n}\n\nfunc TestDecimal_Equalities(t *testing.T) {\n\ta := New(1234, 3)\n\tb := New(1234, 3)\n\tc := New(1234, 4)\n\n\tif !a.Equal(b) {\n\t\tt.Errorf(\"%q should equal %q\", a, b)\n\t}\n\tif a.Equal(c) {\n\t\tt.Errorf(\"%q should not equal %q\", a, c)\n\t}\n\n\t// note, this block should be deprecated, here for backwards compatibility\n\tif !a.Equals(b) {\n\t\tt.Errorf(\"%q should equal %q\", a, b)\n\t}\n\n\tif !c.GreaterThan(b) {\n\t\tt.Errorf(\"%q should be greater than  %q\", c, b)\n\t}\n\tif b.GreaterThan(c) {\n\t\tt.Errorf(\"%q should not be greater than  %q\", b, c)\n\t}\n\tif !a.GreaterThanOrEqual(b) {\n\t\tt.Errorf(\"%q should be greater or equal %q\", a, b)\n\t}\n\tif !c.GreaterThanOrEqual(b) {\n\t\tt.Errorf(\"%q should be greater or equal %q\", c, b)\n\t}\n\tif b.GreaterThanOrEqual(c) {\n\t\tt.Errorf(\"%q should not be greater or equal %q\", b, c)\n\t}\n\tif !b.LessThan(c) {\n\t\tt.Errorf(\"%q should be less than %q\", a, b)\n\t}\n\tif c.LessThan(b) {\n\t\tt.Errorf(\"%q should not be less than  %q\", a, b)\n\t}\n\tif !a.LessThanOrEqual(b) {\n\t\tt.Errorf(\"%q should be less than or equal %q\", a, b)\n\t}\n\tif !b.LessThanOrEqual(c) {\n\t\tt.Errorf(\"%q should be less than or equal  %q\", a, b)\n\t}\n\tif c.LessThanOrEqual(b) {\n\t\tt.Errorf(\"%q should not be less than or equal %q\", a, b)\n\t}\n}\n\nfunc TestDecimal_ScalesNotEqual(t *testing.T) {\n\ta := New(1234, 2)\n\tb := New(1234, 3)\n\tif a.Equal(b) {\n\t\tt.Errorf(\"%q should not equal %q\", a, b)\n\t}\n}\n\nfunc TestDecimal_Cmp1(t *testing.T) {\n\ta := New(123, 3)\n\tb := New(-1234, 2)\n\n\tif a.Cmp(b) != 1 {\n\t\tt.Errorf(\"Error\")\n\t}\n}\n\nfunc TestDecimal_Cmp2(t *testing.T) {\n\ta := New(123, 3)\n\tb := New(1234, 2)\n\n\tif a.Cmp(b) != -1 {\n\t\tt.Errorf(\"Error\")\n\t}\n}\n\nfunc TestDecimal_Pow(t *testing.T) {\n\tfor _, testCase := range []struct {\n\t\tBase     string\n\t\tExponent string\n\t\tExpected string\n\t}{\n\t\t{\"0.0\", \"1.0\", \"0.0\"},\n\t\t{\"0.0\", \"5.7\", \"0.0\"},\n\t\t{\"0.0\", \"-3.2\", \"0.0\"},\n\t\t{\"3.13\", \"0.0\", \"1.0\"},\n\t\t{\"-591.5\", \"0.0\", \"1.0\"},\n\t\t{\"3.0\", \"3.0\", \"27.0\"},\n\t\t{\"3.0\", \"10.0\", \"59049.0\"},\n\t\t{\"3.13\", \"5.0\", \"300.4150512793\"},\n\t\t{\"4.0\", \"2.0\", \"16.0\"},\n\t\t{\"4.0\", \"-2.0\", \"0.0625\"},\n\t\t{\"629.25\", \"5.0\", \"98654323103449.5673828125\"},\n\t\t{\"5.0\", \"5.73\", \"10118.08037159375\"},\n\t\t{\"962.0\", \"3.2791\", \"6055212360.0000044205714144\"},\n\t\t{\"5.69169126\", \"5.18515912\", \"8242.26344757948412597909547972726268869189399260047793106028930864\"},\n\t\t{\"13.1337\", \"3.5196719618391835\", \"8636.856220644773844815693636723928750940666269885\"},\n\t\t{\"67762386.283696923\", \"4.85917691669163916681738\", \"112761146905370140621385730157437443321.91755738117317148674362233906499698561022574811238435007575701773212242750262081945556470501\"},\n\t\t{\"-3.0\", \"6.0\", \"729\"},\n\t\t{\"-13.757\", \"5.0\", \"-492740.983929899460557\"},\n\t\t{\"3.0\", \"-6.0\", \"0.0013717421124829\"},\n\t\t{\"13.757\", \"-5.0\", \"0.000002029463821\"},\n\t\t{\"66.12\", \"-7.61313\", \"0.000000000000013854086588876805036\"},\n\t\t{\"6696871.12\", \"-2.61313\", \"0.000000000000000001455988684546983\"},\n\t\t{\"-3.0\", \"-6.0\", \"0.0013717421124829\"},\n\t\t{\"-13.757\", \"-5.0\", \"-0.000002029463821\"},\n\t} {\n\t\tbase, _ := NewFromString(testCase.Base)\n\t\texp, _ := NewFromString(testCase.Exponent)\n\t\texpected, _ := NewFromString(testCase.Expected)\n\n\t\tresult := base.Pow(exp)\n\n\t\tif result.Cmp(expected) != 0 {\n\t\t\tt.Errorf(\"expected %s, got %s, for %s^%s\", testCase.Expected, result.String(), testCase.Base, testCase.Exponent)\n\t\t}\n\t}\n}\n\nfunc TestDecimal_PowWithPrecision(t *testing.T) {\n\tfor _, testCase := range []struct {\n\t\tBase      string\n\t\tExponent  string\n\t\tPrecision int32\n\t\tExpected  string\n\t}{\n\t\t{\"0.0\", \"1.0\", 2, \"0.0\"},\n\t\t{\"0.0\", \"5.7\", 2, \"0.0\"},\n\t\t{\"0.0\", \"-3.2\", 2, \"0.0\"},\n\t\t{\"3.13\", \"0.0\", 2, \"1.0\"},\n\t\t{\"-591.5\", \"0.0\", 2, \"1.0\"},\n\t\t{\"3.0\", \"3.0\", 2, \"27.0\"},\n\t\t{\"3.0\", \"10.0\", 2, \"59049.0\"},\n\t\t{\"3.13\", \"5.0\", 5, \"300.4150512793\"},\n\t\t{\"4.0\", \"2.0\", 2, \"16.0\"},\n\t\t{\"4.0\", \"-2.0\", 2, \"0.06\"},\n\t\t{\"4.0\", \"-2.0\", 4, \"0.0625\"},\n\t\t{\"629.25\", \"5.0\", 6, \"98654323103449.5673828125\"},\n\t\t{\"5.0\", \"5.73\", 20, \"10118.080371595019317118681359884375\"},\n\t\t{\"962.0\", \"3.2791\", 15, \"6055212360.000004406551603058195732\"},\n\t\t{\"5.69169126\", \"5.18515912\", 4, \"8242.26344757948412587366859330429895955552280978668983459852256\"},\n\t\t{\"13.1337\", \"3.5196719618391835\", 8, \"8636.85622064477384481569363672392591908386390769375\"},\n\t\t{\"67762386.283696923\", \"4.85917691669163916681738\", 10, \"112761146905370140621385730157437443321.917557381173174638304347353880676293576708009282115993465286373470882947470198597518762\"},\n\t\t{\"-3.0\", \"6.0\", 2, \"729\"},\n\t\t{\"-13.757\", \"5.0\", 4, \"-492740.983929899460557\"},\n\t\t{\"3.0\", \"-6.0\", 10, \"0.0013717421\"},\n\t\t{\"13.757\", \"-5.0\", 20, \"0.00000202946382098037\"},\n\t\t{\"66.12\", \"-7.61313\", 20, \"0.00000000000001385381563049821591633907104023700216\"},\n\t\t{\"6696871.12\", \"-2.61313\", 24, \"0.0000000000000000014558252733872790626400278983397459207418\"},\n\t\t{\"-3.0\", \"-6.0\", 8, \"0.00137174\"},\n\t\t{\"-13.757\", \"-5.0\", 16, \"-0.000002029463821\"},\n\t} {\n\t\tbase, _ := NewFromString(testCase.Base)\n\t\texp, _ := NewFromString(testCase.Exponent)\n\t\texpected, _ := NewFromString(testCase.Expected)\n\n\t\tresult, _ := base.PowWithPrecision(exp, testCase.Precision)\n\n\t\tif result.Cmp(expected) != 0 {\n\t\t\tt.Errorf(\"expected %s, got %s, for %s^%s\", testCase.Expected, result.String(), testCase.Base, testCase.Exponent)\n\t\t}\n\t}\n}\n\nfunc TestDecimal_PowWithPrecision_Infinity(t *testing.T) {\n\tfor _, testCase := range []struct {\n\t\tBase     string\n\t\tExponent string\n\t}{\n\t\t{\"0.0\", \"0.0\"},\n\t\t{\"0.0\", \"-2.0\"},\n\t\t{\"0.0\", \"-4.6\"},\n\t\t{\"-66.12\", \"7.61313\"},      // Imaginary value\n\t\t{\"-5696871.12\", \"5.61313\"}, // Imaginary value\n\t} {\n\t\tbase, _ := NewFromString(testCase.Base)\n\t\texp, _ := NewFromString(testCase.Exponent)\n\n\t\t_, err := base.PowWithPrecision(exp, 5)\n\n\t\tif err == nil {\n\t\t\tt.Errorf(\"lool it should be error\")\n\t\t}\n\t}\n}\n\nfunc TestDecimal_PowWithPrecision_UndefinedResult(t *testing.T) {\n\tbase := RequireFromString(\"0\")\n\texponent := RequireFromString(\"0\")\n\n\t_, err := base.PowWithPrecision(exponent, 4)\n\n\tif err == nil {\n\t\tt.Errorf(\"expected error, cannot be represent undefined value of 0**0\")\n\t}\n}\n\nfunc TestDecimal_PowWithPrecision_InfinityResult(t *testing.T) {\n\tfor _, testCase := range []struct {\n\t\tBase     string\n\t\tExponent string\n\t}{\n\t\t{\"0.0\", \"-2.0\"},\n\t\t{\"0.0\", \"-4.6\"},\n\t\t{\"0.0\", \"-9239.671333\"},\n\t} {\n\t\tbase, _ := NewFromString(testCase.Base)\n\t\texp, _ := NewFromString(testCase.Exponent)\n\n\t\t_, err := base.PowWithPrecision(exp, 4)\n\n\t\tif err == nil {\n\t\t\tt.Errorf(\"expected error, cannot represent infinity value of 0 ** y, where y < 0\")\n\t\t}\n\t}\n}\n\nfunc TestDecimal_PowWithPrecision_ImaginaryResult(t *testing.T) {\n\tfor _, testCase := range []struct {\n\t\tBase     string\n\t\tExponent string\n\t}{\n\t\t{\"-0.2261\", \"106.12\"},\n\t\t{\"-66.12\", \"7.61313\"},\n\t\t{\"-5696871.12\", \"5.61313\"},\n\t} {\n\t\tbase, _ := NewFromString(testCase.Base)\n\t\texp, _ := NewFromString(testCase.Exponent)\n\n\t\t_, err := base.PowWithPrecision(exp, 4)\n\n\t\tif err == nil {\n\t\t\tt.Errorf(\"expected error, cannot represent imaginary value of x ** y, where x < 0 and y is non-integer decimal\")\n\t\t}\n\t}\n}\n\nfunc TestDecimal_PowInt32(t *testing.T) {\n\tfor _, testCase := range []struct {\n\t\tDecimal  string\n\t\tExponent int32\n\t\tExpected string\n\t}{\n\t\t{\"0.0\", 1, \"0.0\"},\n\t\t{\"3.13\", 0, \"1.0\"},\n\t\t{\"-591.5\", 0, \"1.0\"},\n\t\t{\"3.0\", 3, \"27.0\"},\n\t\t{\"3.0\", 10, \"59049.0\"},\n\t\t{\"3.13\", 5, \"300.4150512793\"},\n\t\t{\"629.25\", 5, \"98654323103449.5673828125\"},\n\t\t{\"-3.0\", 6, \"729\"},\n\t\t{\"-13.757\", 5, \"-492740.983929899460557\"},\n\t\t{\"3.0\", -6, \"0.0013717421124829\"},\n\t\t{\"-13.757\", -5, \"-0.000002029463821\"},\n\t} {\n\t\tbase, _ := NewFromString(testCase.Decimal)\n\t\texpected, _ := NewFromString(testCase.Expected)\n\n\t\tresult, _ := base.PowInt32(testCase.Exponent)\n\n\t\tif result.Cmp(expected) != 0 {\n\t\t\tt.Errorf(\"expected %s, got %s, for %s**%d\", testCase.Expected, result.String(), testCase.Decimal, testCase.Exponent)\n\t\t}\n\t}\n}\n\nfunc TestDecimal_PowInt32_UndefinedResult(t *testing.T) {\n\tbase := RequireFromString(\"0\")\n\n\t_, err := base.PowInt32(0)\n\n\tif err == nil {\n\t\tt.Errorf(\"expected error, cannot be represent undefined value of 0**0\")\n\t}\n}\n\nfunc TestDecimal_PowBigInt(t *testing.T) {\n\tfor _, testCase := range []struct {\n\t\tDecimal  string\n\t\tExponent *big.Int\n\t\tExpected string\n\t}{\n\t\t{\"3.13\", big.NewInt(0), \"1.0\"},\n\t\t{\"-591.5\", big.NewInt(0), \"1.0\"},\n\t\t{\"3.0\", big.NewInt(3), \"27.0\"},\n\t\t{\"3.0\", big.NewInt(10), \"59049.0\"},\n\t\t{\"3.13\", big.NewInt(5), \"300.4150512793\"},\n\t\t{\"629.25\", big.NewInt(5), \"98654323103449.5673828125\"},\n\t\t{\"-3.0\", big.NewInt(6), \"729\"},\n\t\t{\"-13.757\", big.NewInt(5), \"-492740.983929899460557\"},\n\t\t{\"3.0\", big.NewInt(-6), \"0.0013717421124829\"},\n\t\t{\"-13.757\", big.NewInt(-5), \"-0.000002029463821\"},\n\t} {\n\t\tbase, _ := NewFromString(testCase.Decimal)\n\t\texpected, _ := NewFromString(testCase.Expected)\n\n\t\tresult, _ := base.PowBigInt(testCase.Exponent)\n\n\t\tif result.Cmp(expected) != 0 {\n\t\t\tt.Errorf(\"expected %s, got %s, for %s**%d\", testCase.Expected, result.String(), testCase.Decimal, testCase.Exponent)\n\t\t}\n\t}\n}\n\nfunc TestDecimal_PowBigInt_UndefinedResult(t *testing.T) {\n\tbase := RequireFromString(\"0\")\n\n\t_, err := base.PowBigInt(big.NewInt(0))\n\n\tif err == nil {\n\t\tt.Errorf(\"expected error, undefined value of 0**0 cannot be represented\")\n\t}\n}\n\nfunc TestDecimal_IsInteger(t *testing.T) {\n\tfor _, testCase := range []struct {\n\t\tDec       string\n\t\tIsInteger bool\n\t}{\n\t\t{\"0\", true},\n\t\t{\"0.0000\", true},\n\t\t{\"0.01\", false},\n\t\t{\"0.01010101010000\", false},\n\t\t{\"12.0\", true},\n\t\t{\"12.00000000000000\", true},\n\t\t{\"12.10000\", false},\n\t\t{\"9999.0000\", true},\n\t\t{\"99999999.000000000\", true},\n\t\t{\"-656323444.0000000000000\", true},\n\t\t{\"-32768.01234\", false},\n\t\t{\"-32768.0123423562623600000\", false},\n\t} {\n\t\td, err := NewFromString(testCase.Dec)\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tif d.IsInteger() != testCase.IsInteger {\n\t\t\tt.Errorf(\"expect %t, got %t, for %s\", testCase.IsInteger, d.IsInteger(), testCase.Dec)\n\t\t}\n\t}\n}\n\nfunc TestDecimal_ExpHullAbrham(t *testing.T) {\n\tfor _, testCase := range []struct {\n\t\tDec              string\n\t\tOverallPrecision uint32\n\t\tExpectedDec      string\n\t}{\n\t\t{\"0\", 1, \"1\"},\n\t\t{\"0.00\", 5, \"1\"},\n\t\t{\"0.5\", 5, \"1.6487\"},\n\t\t{\"0.569297\", 10, \"1.767024397\"},\n\t\t{\"0.569297\", 16, \"1.76702439654095\"},\n\t\t{\"0.569297\", 20, \"1.7670243965409496521\"},\n\t\t{\"1.0\", 0, \"3\"},\n\t\t{\"1.0\", 1, \"3\"},\n\t\t{\"1.0\", 5, \"2.7183\"},\n\t\t{\"1.0\", 10, \"2.718281828\"},\n\t\t{\"3.0\", 0, \"20\"},\n\t\t{\"3.0\", 2, \"20\"},\n\t\t{\"5.26\", 0, \"200\"},\n\t\t{\"5.26\", 2, \"190\"},\n\t\t{\"5.26\", 10, \"192.4814913\"},\n\t\t{\"5.2663117716\", 2, \"190\"},\n\t\t{\"5.2663117716\", 10, \"193.7002327\"},\n\t\t{\"26.1\", 2, \"220000000000\"},\n\t\t{\"26.1\", 10, \"216314672100\"},\n\t\t{\"26.1\", 20, \"216314672147.05767284\"},\n\t\t{\"50.1591\", 10, \"6078834887000000000000\"},\n\t\t{\"50.1591\", 30, \"6078834886623434464595.07937141\"},\n\t\t{\"-0.5\", 5, \"0.60653\"},\n\t\t{\"-0.569297\", 10, \"0.5659231429\"},\n\t\t{\"-0.569297\", 16, \"0.565923142859576\"},\n\t\t{\"-0.569297\", 20, \"0.56592314285957604443\"},\n\t\t{\"-1.0\", 1, \"0.4\"},\n\t\t{\"-1.0\", 5, \"0.36788\"},\n\t\t{\"-3.0\", 1, \"0\"},\n\t\t{\"-3.0\", 2, \"0.05\"},\n\t\t{\"-3.0\", 10, \"0.0497870684\"},\n\t\t{\"-5.26\", 2, \"0.01\"},\n\t\t{\"-5.26\", 10, \"0.0051953047\"},\n\t\t{\"-5.2663117716\", 2, \"0.01\"},\n\t\t{\"-5.2663117716\", 10, \"0.0051626164\"},\n\t\t{\"-26.1\", 2, \"0\"},\n\t\t{\"-26.1\", 15, \"0.000000000004623\"},\n\t\t{\"-50.1591\", 10, \"0\"},\n\t\t{\"-50.1591\", 30, \"0.000000000000000000000164505208\"},\n\t} {\n\t\td, _ := NewFromString(testCase.Dec)\n\t\texpected, _ := NewFromString(testCase.ExpectedDec)\n\n\t\texp, err := d.ExpHullAbrham(testCase.OverallPrecision)\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\n\t\tif exp.Cmp(expected) != 0 {\n\t\t\tt.Errorf(\"expected %s, got %s, for decimal %s\", testCase.ExpectedDec, exp.String(), testCase.Dec)\n\t\t}\n\n\t}\n}\n\nfunc TestDecimal_ExpTaylor(t *testing.T) {\n\tfor _, testCase := range []struct {\n\t\tDec         string\n\t\tPrecision   int32\n\t\tExpectedDec string\n\t}{\n\t\t{\"0\", 1, \"1\"},\n\t\t{\"0.00\", 5, \"1\"},\n\t\t{\"0\", -1, \"0\"},\n\t\t{\"0.5\", 5, \"1.64872\"},\n\t\t{\"0.569297\", 10, \"1.7670243965\"},\n\t\t{\"0.569297\", 16, \"1.7670243965409497\"},\n\t\t{\"0.569297\", 20, \"1.76702439654094965215\"},\n\t\t{\"1.0\", 0, \"3\"},\n\t\t{\"1.0\", 1, \"2.7\"},\n\t\t{\"1.0\", 5, \"2.71828\"},\n\t\t{\"1.0\", -1, \"0\"},\n\t\t{\"1.0\", -5, \"0\"},\n\t\t{\"3.0\", 1, \"20.1\"},\n\t\t{\"3.0\", 2, \"20.09\"},\n\t\t{\"5.26\", 0, \"192\"},\n\t\t{\"5.26\", 2, \"192.48\"},\n\t\t{\"5.26\", 10, \"192.4814912972\"},\n\t\t{\"5.26\", -2, \"200\"},\n\t\t{\"5.2663117716\", 2, \"193.70\"},\n\t\t{\"5.2663117716\", 10, \"193.7002326701\"},\n\t\t{\"26.1\", 2, \"216314672147.06\"},\n\t\t{\"26.1\", 20, \"216314672147.05767284062928674083\"},\n\t\t{\"26.1\", -2, \"216314672100\"},\n\t\t{\"26.1\", -10, \"220000000000\"},\n\t\t{\"50.1591\", 10, \"6078834886623434464595.0793714061\"},\n\t\t{\"-0.5\", 5, \"0.60653\"},\n\t\t{\"-0.569297\", 10, \"0.5659231429\"},\n\t\t{\"-0.569297\", 16, \"0.565923142859576\"},\n\t\t{\"-0.569297\", 20, \"0.56592314285957604443\"},\n\t\t{\"-1.0\", 1, \"0.4\"},\n\t\t{\"-1.0\", 5, \"0.36788\"},\n\t\t{\"-1.0\", -1, \"0\"},\n\t\t{\"-1.0\", -5, \"0\"},\n\t\t{\"-3.0\", 1, \"0.1\"},\n\t\t{\"-3.0\", 2, \"0.05\"},\n\t\t{\"-3.0\", 10, \"0.0497870684\"},\n\t\t{\"-5.26\", 2, \"0.01\"},\n\t\t{\"-5.26\", 10, \"0.0051953047\"},\n\t\t{\"-5.26\", -2, \"0\"},\n\t\t{\"-5.2663117716\", 2, \"0.01\"},\n\t\t{\"-5.2663117716\", 10, \"0.0051626164\"},\n\t\t{\"-26.1\", 2, \"0\"},\n\t\t{\"-26.1\", 15, \"0.000000000004623\"},\n\t\t{\"-26.1\", -2, \"0\"},\n\t\t{\"-26.1\", -10, \"0\"},\n\t\t{\"-50.1591\", 10, \"0\"},\n\t\t{\"-50.1591\", 30, \"0.000000000000000000000164505208\"},\n\t} {\n\t\td, _ := NewFromString(testCase.Dec)\n\t\texpected, _ := NewFromString(testCase.ExpectedDec)\n\n\t\texp, err := d.ExpTaylor(testCase.Precision)\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\n\t\tif exp.Cmp(expected) != 0 {\n\t\t\tt.Errorf(\"expected %s, got %s\", testCase.ExpectedDec, exp.String())\n\t\t}\n\t}\n}\n\nfunc TestDecimal_Ln(t *testing.T) {\n\tfor _, testCase := range []struct {\n\t\tDec       string\n\t\tPrecision int32\n\t\tExpected  string\n\t}{\n\t\t{\"0.1\", 25, \"-2.3025850929940456840179915\"},\n\t\t{\"0.01\", 25, \"-4.6051701859880913680359829\"},\n\t\t{\"0.001\", 25, \"-6.9077552789821370520539744\"},\n\t\t{\"0.00000001\", 25, \"-18.4206807439523654721439316\"},\n\t\t{\"1.0\", 10, \"0.0\"},\n\t\t{\"1.01\", 25, \"0.0099503308531680828482154\"},\n\t\t{\"1.001\", 25, \"0.0009995003330835331668094\"},\n\t\t{\"1.0001\", 25, \"0.0000999950003333083353332\"},\n\t\t{\"1.1\", 25, \"0.0953101798043248600439521\"},\n\t\t{\"1.13\", 25, \"0.1222176327242492005461486\"},\n\t\t{\"3.13\", 10, \"1.1410330046\"},\n\t\t{\"3.13\", 25, \"1.1410330045520618486427824\"},\n\t\t{\"3.13\", 50, \"1.14103300455206184864278239988848193837089629107972\"},\n\t\t{\"3.13\", 100, \"1.1410330045520618486427823998884819383708962910797239760817078430268177216960996098918971117211892839\"},\n\t\t{\"5.71\", 25, \"1.7422190236679188486939833\"},\n\t\t{\"5.7185108151957193571930205\", 50, \"1.74370842450178929149992165925283704012576949094645\"},\n\t\t{\"839101.0351\", 25, \"13.6400864014410013994397240\"},\n\t\t{\"839101.0351094726488848490572028502\", 50, \"13.64008640145229044389152437468283605382056561604272\"},\n\t\t{\"5023583755703750094849.03519358513093500275017501750602739169823\", 25, \"49.9684305274348922267409953\"},\n\t\t{\"5023583755703750094849.03519358513093500275017501750602739169823\", -1, \"50.0\"},\n\t\t{\"66.12\", 18, \"4.191471272952823429\"},\n\t} {\n\t\td, _ := NewFromString(testCase.Dec)\n\t\texpected, _ := NewFromString(testCase.Expected)\n\n\t\tln, err := d.Ln(testCase.Precision)\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\n\t\tif ln.Cmp(expected) != 0 {\n\t\t\tt.Errorf(\"expected %s, got %s, for decimal %s\", testCase.Expected, ln.String(), testCase.Dec)\n\t\t}\n\t}\n}\n\nfunc TestDecimal_LnZero(t *testing.T) {\n\td := New(0, 0)\n\n\t_, err := d.Ln(5)\n\n\tif err == nil {\n\t\tt.Errorf(\"expected error, natural logarithm of 0 cannot be represented (-infinity)\")\n\t}\n}\n\nfunc TestDecimal_LnNegative(t *testing.T) {\n\td := New(-20, 2)\n\n\t_, err := d.Ln(5)\n\n\tif err == nil {\n\t\tt.Errorf(\"expected error, natural logarithm cannot be calculated for nagative decimals\")\n\t}\n}\n\nfunc TestDecimal_NumDigits(t *testing.T) {\n\tfor _, testCase := range []struct {\n\t\tDec               string\n\t\tExpectedNumDigits int\n\t}{\n\t\t{\"0\", 1},\n\t\t{\"0.00\", 1},\n\t\t{\"1.0\", 2},\n\t\t{\"3.0\", 2},\n\t\t{\"5.26\", 3},\n\t\t{\"5.2663117716\", 11},\n\t\t{\"3164836416948884.2162426426426267863\", 35},\n\t\t{\"26.1\", 3},\n\t\t{\"529.1591\", 7},\n\t\t{\"-1.0\", 2},\n\t\t{\"-3.0\", 2},\n\t\t{\"-5.26\", 3},\n\t\t{\"-5.2663117716\", 11},\n\t\t{\"-26.1\", 3},\n\t\t{\"\", 1},\n\t} {\n\t\td, _ := NewFromString(testCase.Dec)\n\n\t\tnums := d.NumDigits()\n\t\tif nums != testCase.ExpectedNumDigits {\n\t\t\tt.Errorf(\"expected %d digits for decimal %s, got %d\", testCase.ExpectedNumDigits, testCase.Dec, nums)\n\t\t}\n\t}\n}\n\nfunc TestDecimal_Sign(t *testing.T) {\n\tif Zero.Sign() != 0 {\n\t\tt.Errorf(\"%q should have sign 0\", Zero)\n\t}\n\n\tone := New(1, 0)\n\tif one.Sign() != 1 {\n\t\tt.Errorf(\"%q should have sign 1\", one)\n\t}\n\n\tmone := New(-1, 0)\n\tif mone.Sign() != -1 {\n\t\tt.Errorf(\"%q should have sign -1\", mone)\n\t}\n}\n\nfunc didPanic(f func()) bool {\n\tret := false\n\tfunc() {\n\n\t\tdefer func() {\n\t\t\tif message := recover(); message != nil {\n\t\t\t\tret = true\n\t\t\t}\n\t\t}()\n\n\t\t// call the target function\n\t\tf()\n\n\t}()\n\n\treturn ret\n\n}\n\nfunc TestDecimal_Coefficient(t *testing.T) {\n\td := New(123, 0)\n\tco := d.Coefficient()\n\tif co.Int64() != 123 {\n\t\tt.Error(\"Coefficient should be 123; Got:\", co)\n\t}\n\tco.Set(big.NewInt(0))\n\tif d.IntPart() != 123 {\n\t\tt.Error(\"Modifying coefficient modified Decimal; Got:\", d)\n\t}\n}\n\nfunc TestDecimal_CoefficientInt64(t *testing.T) {\n\ttype Inp struct {\n\t\tDec         string\n\t\tCoefficient int64\n\t}\n\n\ttestCases := []Inp{\n\t\t{\"1\", 1},\n\t\t{\"1.111\", 1111},\n\t\t{\"1.000000\", 1000000},\n\t\t{\"1.121215125511\", 1121215125511},\n\t\t{\"100000000000000000\", 100000000000000000},\n\t\t{\"9223372036854775807\", 9223372036854775807},\n\t\t{\"10000000000000000000\", -8446744073709551616}, // undefined value\n\t}\n\n\t// add negative cases\n\tfor _, tc := range testCases {\n\t\ttestCases = append(testCases, Inp{\"-\" + tc.Dec, -tc.Coefficient})\n\t}\n\n\tfor _, tc := range testCases {\n\t\td := RequireFromString(tc.Dec)\n\t\tcoefficient := d.CoefficientInt64()\n\t\tif coefficient != tc.Coefficient {\n\t\t\tt.Errorf(\"expect coefficient %d, got %d, for decimal %s\", tc.Coefficient, coefficient, tc.Dec)\n\t\t}\n\t}\n}\n\nfunc TestNullDecimal_Scan(t *testing.T) {\n\t// test the Scan method that implements the\n\t// sql.Scanner interface\n\t// check for the for different type of values\n\t// that are possible to be received from the database\n\t// drivers\n\n\t// in normal operations the db driver (sqlite at least)\n\t// will return an int64 if you specified a numeric format\n\n\t// Make sure handles nil values\n\ta := NullDecimal{}\n\tvar dbvaluePtr interface{}\n\terr := a.Scan(dbvaluePtr)\n\tif err != nil {\n\t\t// Scan failed... no need to test result value\n\t\tt.Errorf(\"a.Scan(nil) failed with message: %s\", err)\n\t} else {\n\t\tif a.Valid {\n\t\t\tt.Errorf(\"%s is not null\", a.Decimal)\n\t\t}\n\t}\n\n\tdbvalue := 54.33\n\texpected := NewFromFloat(dbvalue)\n\n\terr = a.Scan(dbvalue)\n\tif err != nil {\n\t\t// Scan failed... no need to test result value\n\t\tt.Errorf(\"a.Scan(54.33) failed with message: %s\", err)\n\n\t} else {\n\t\t// Scan succeeded... test resulting values\n\t\tif !a.Valid {\n\t\t\tt.Errorf(\"%s is null\", a.Decimal)\n\t\t} else if !a.Decimal.Equals(expected) {\n\t\t\tt.Errorf(\"%s does not equal to %s\", a.Decimal, expected)\n\t\t}\n\t}\n\n\t// at least SQLite returns an int64 when 0 is stored in the db\n\t// and you specified a numeric format on the schema\n\tdbvalueInt := int64(0)\n\texpected = New(dbvalueInt, 0)\n\n\terr = a.Scan(dbvalueInt)\n\tif err != nil {\n\t\t// Scan failed... no need to test result value\n\t\tt.Errorf(\"a.Scan(0) failed with message: %s\", err)\n\n\t} else {\n\t\t// Scan succeeded... test resulting values\n\t\tif !a.Valid {\n\t\t\tt.Errorf(\"%s is null\", a.Decimal)\n\t\t} else if !a.Decimal.Equals(expected) {\n\t\t\tt.Errorf(\"%v does not equal %v\", a, expected)\n\t\t}\n\t}\n\n\t// in case you specified a varchar in your SQL schema,\n\t// the database driver will return byte slice []byte\n\tvalueStr := \"535.666\"\n\tdbvalueStr := []byte(valueStr)\n\texpected, err = NewFromString(valueStr)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\terr = a.Scan(dbvalueStr)\n\tif err != nil {\n\t\t// Scan failed... no need to test result value\n\t\tt.Errorf(\"a.Scan('535.666') failed with message: %s\", err)\n\n\t} else {\n\t\t// Scan succeeded... test resulting values\n\t\tif !a.Valid {\n\t\t\tt.Errorf(\"%s is null\", a.Decimal)\n\t\t} else if !a.Decimal.Equals(expected) {\n\t\t\tt.Errorf(\"%v does not equal %v\", a, expected)\n\t\t}\n\t}\n\n\t// lib/pq can also return strings\n\texpected, err = NewFromString(valueStr)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\terr = a.Scan(valueStr)\n\tif err != nil {\n\t\t// Scan failed... no need to test result value\n\t\tt.Errorf(\"a.Scan('535.666') failed with message: %s\", err)\n\t} else {\n\t\t// Scan succeeded... test resulting values\n\t\tif !a.Valid {\n\t\t\tt.Errorf(\"%s is null\", a.Decimal)\n\t\t} else if !a.Decimal.Equals(expected) {\n\t\t\tt.Errorf(\"%v does not equal %v\", a, expected)\n\t\t}\n\t}\n}\n\nfunc TestNullDecimal_Value(t *testing.T) {\n\t// Make sure this does implement the database/sql's driver.Valuer interface\n\tvar nullDecimal NullDecimal\n\tif _, ok := interface{}(nullDecimal).(driver.Valuer); !ok {\n\t\tt.Error(\"NullDecimal does not implement driver.Valuer\")\n\t}\n\n\t// check that null is handled appropriately\n\tvalue, err := nullDecimal.Value()\n\tif err != nil {\n\t\tt.Errorf(\"NullDecimal{}.Valid() failed with message: %s\", err)\n\t} else if value != nil {\n\t\tt.Errorf(\"%v is not nil\", value)\n\t}\n\n\t// check that normal case is handled appropriately\n\ta := NullDecimal{Decimal: New(1234, -2), Valid: true}\n\texpected := \"12.34\"\n\tvalue, err = a.Value()\n\tif err != nil {\n\t\tt.Errorf(\"NullDecimal(12.34).Value() failed with message: %s\", err)\n\t} else if value.(string) != expected {\n\t\tt.Errorf(\"%v does not equal %v\", a, expected)\n\t}\n}\n\nfunc TestBinary(t *testing.T) {\n\tfor _, y := range testTable {\n\t\tx := y.float\n\n\t\t// Create the decimal\n\t\td1 := NewFromFloat(x)\n\n\t\t// Encode to binary\n\t\tb, err := d1.MarshalBinary()\n\t\tif err != nil {\n\t\t\tt.Errorf(\"error marshalling %v to binary: %v\", d1, err)\n\t\t}\n\n\t\t// Restore from binary\n\t\tvar d2 Decimal\n\t\terr = (&d2).UnmarshalBinary(b)\n\t\tif err != nil {\n\t\t\tt.Errorf(\"error unmarshalling from binary: %v\", err)\n\t\t}\n\n\t\t// The restored decimal should equal the original\n\t\tif !d1.Equals(d2) {\n\t\t\tt.Errorf(\"expected %v when restoring, got %v\", d1, d2)\n\t\t}\n\t}\n}\n\nfunc TestBinary_Zero(t *testing.T) {\n\tvar d1 Decimal\n\n\tb, err := d1.MarshalBinary()\n\tif err != nil {\n\t\tt.Fatalf(\"error marshalling %v to binary: %v\", d1, err)\n\t}\n\n\tvar d2 Decimal\n\terr = (&d2).UnmarshalBinary(b)\n\tif err != nil {\n\t\tt.Errorf(\"error unmarshalling from binary: %v\", err)\n\t}\n\n\tif !d1.Equals(d2) {\n\t\tt.Errorf(\"expected %v when restoring, got %v\", d1, d2)\n\t}\n}\n\nfunc TestBinary_DataTooShort(t *testing.T) {\n\tvar d Decimal\n\n\terr := d.UnmarshalBinary(nil) // nil slice has length 0\n\tif err == nil {\n\t\tt.Fatalf(\"expected error, got %v\", d)\n\t}\n}\n\nfunc TestBinary_InvalidValue(t *testing.T) {\n\tvar d Decimal\n\n\terr := d.UnmarshalBinary([]byte{0, 0, 0, 0, 'x'}) // valid exponent, invalid value\n\tif err == nil {\n\t\tt.Fatalf(\"expected error, got %v\", d)\n\t}\n}\n\nfunc slicesEqual(a, b []byte) bool {\n\tfor i, val := range a {\n\t\tif b[i] != val {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\nfunc TestGobEncode(t *testing.T) {\n\tfor _, y := range testTable {\n\t\tx := y.float\n\t\td1 := NewFromFloat(x)\n\n\t\tb1, err := d1.GobEncode()\n\t\tif err != nil {\n\t\t\tt.Errorf(\"error encoding %v to binary: %v\", d1, err)\n\t\t}\n\n\t\td2 := NewFromFloat(x)\n\n\t\tb2, err := d2.GobEncode()\n\t\tif err != nil {\n\t\t\tt.Errorf(\"error encoding %v to binary: %v\", d2, err)\n\t\t}\n\n\t\tif !slicesEqual(b1, b2) {\n\t\t\tt.Errorf(\"something about the gobencode is not working properly \\n%v\\n%v\", b1, b2)\n\t\t}\n\n\t\tvar d3 Decimal\n\t\terr = d3.GobDecode(b1)\n\t\tif err != nil {\n\t\t\tt.Errorf(\"Error gobdecoding %v, got %v\", b1, d3)\n\t\t}\n\t\tvar d4 Decimal\n\t\terr = d4.GobDecode(b2)\n\t\tif err != nil {\n\t\t\tt.Errorf(\"Error gobdecoding %v, got %v\", b2, d4)\n\t\t}\n\n\t\teq := d3.Equal(d4)\n\t\tif eq != true {\n\t\t\tt.Errorf(\"Encoding then decoding mutated Decimal\")\n\t\t}\n\n\t\teq = d1.Equal(d3)\n\t\tif eq != true {\n\t\t\tt.Errorf(\"Error gobencoding/decoding %v, got %v\", d1, d3)\n\t\t}\n\t}\n}\n\nfunc TestSum(t *testing.T) {\n\tvals := make([]Decimal, 10)\n\tvar i = int64(0)\n\n\tfor key := range vals {\n\t\tvals[key] = New(i, 0)\n\t\ti++\n\t}\n\n\tsum := Sum(vals[0], vals[1:]...)\n\tif !sum.Equal(New(45, 0)) {\n\t\tt.Errorf(\"Failed to calculate sum, expected %s got %s\", New(45, 0), sum)\n\t}\n}\n\nfunc TestAvg(t *testing.T) {\n\tvals := make([]Decimal, 10)\n\tvar i = int64(0)\n\n\tfor key := range vals {\n\t\tvals[key] = New(i, 0)\n\t\ti++\n\t}\n\n\tavg := Avg(vals[0], vals[1:]...)\n\tif !avg.Equal(NewFromFloat(4.5)) {\n\t\tt.Errorf(\"Failed to calculate average, expected %s got %s\", NewFromFloat(4.5).String(), avg.String())\n\t}\n}\n\nfunc TestRoundBankAnomaly(t *testing.T) {\n\ta := New(25, -1)\n\tb := New(250, -2)\n\n\tif !a.Equal(b) {\n\t\tt.Errorf(\"Expected %s to equal %s\", a, b)\n\t}\n\n\texpected := New(2, 0)\n\n\taRounded := a.RoundBank(0)\n\tif !aRounded.Equal(expected) {\n\t\tt.Errorf(\"Expected bank rounding %s to equal %s, but it was %s\", a, expected, aRounded)\n\t}\n\n\tbRounded := b.RoundBank(0)\n\tif !bRounded.Equal(expected) {\n\t\tt.Errorf(\"Expected bank rounding %s to equal %s, but it was %s\", b, expected, bRounded)\n\t}\n}\n\n// Trig tests\n\n// For Atan\nfunc TestAtan(t *testing.T) {\n\tinps := []string{\n\t\t\"-2.91919191919191919\",\n\t\t\"-1.0\",\n\t\t\"-0.25\",\n\t\t\"0.0\",\n\t\t\"0.33\",\n\t\t\"1.0\",\n\t\t\"5.0\",\n\t\t\"10\",\n\t\t\"11000020.2407442310156021090304691671842603586882014729198302312846062338790031898128063403419218957424\",\n\t}\n\tsols := []string{\n\t\t\"-1.24076438822058001027437062753106\",\n\t\t\"-0.78539816339744833061616997868383\",\n\t\t\"-0.24497866312686415\",\n\t\t\"0.0\",\n\t\t\"0.318747560420644443\",\n\t\t\"0.78539816339744833061616997868383\",\n\t\t\"1.37340076694501580123233995736766\",\n\t\t\"1.47112767430373453123233995736766\",\n\t\t\"1.57079623588597296123259450235374\",\n\t}\n\tfor i, inp := range inps {\n\t\td, err := NewFromString(inp)\n\t\tif err != nil {\n\t\t\tt.FailNow()\n\t\t}\n\t\ts, err := NewFromString(sols[i])\n\t\tif err != nil {\n\t\t\tt.FailNow()\n\t\t}\n\t\ta := d.Atan()\n\t\tif !a.Equal(s) {\n\t\t\tt.Errorf(\"expected %s, got %s\", s, a)\n\t\t}\n\t}\n}\n\n// For Sin\nfunc TestSin(t *testing.T) {\n\tinps := []string{\n\t\t\"-2.91919191919191919\",\n\t\t\"-1.0\",\n\t\t\"-0.25\",\n\t\t\"0.0\",\n\t\t\"0.33\",\n\t\t\"1.0\",\n\t\t\"5.0\",\n\t\t\"10\",\n\t\t\"11000020.2407442310156021090304691671842603586882014729198302312846062338790031898128063403419218957424\",\n\t}\n\tsols := []string{\"-0.22057186252002995641471297726318877448242875710373383657841216606788849153474483300147427943530288911869356126149550184271061369789963810497434594683859566879253561990821788142048867910104964466745284318577343435957806286762494529983369776697504436326725441516925396488258485248699247367113416543705253919473126183478178486954138205996912770183192357029798618739277146694040778731661407420114923656224752540889120768\",\n\t\t\"-0.841470984807896544828551915928318375739843472469519282898610111931110319333748010828751784005573402229699531838022117989945539661588502120624574802425114599802714611508860519655182175315926637327774878594985045816542706701485174683683726979309922117859910272413672784175028365607893544855897795184024100973080880074046886009375162838756876336134083638363801171409953672944184918309063800980214873465660723218405962257950683415203634506166523593278\",\n\t\t\"-0.2474039592545229296662577977006816864013671875\",\n\t\t\"0\",\n\t\t\"0.3240430283948683457891331120415701894104386268737728\",\n\t\t\"0.841470984807896544828551915928318375739843472469519282898610111931110319333748010828751784005573402229699531838022117989945539661588502120624574802425114599802714611508860519655182175315926637327774878594985045816542706701485174683683726979309922117859910272413672784175028365607893544855897795184024100973080880074046886009375162838756876336134083638363801171409953672944184918309063800980214873465660723218405962257950683415203634506166523593278\",\n\t\t\"-0.958924274663138409032065951037351417114444405831206421994322505831797734568720303321152847999323782235893449831846516332891972309733806145798957570823292783131379570446989311599459252931842975162373777189193072018951049969744350662993214861042908755303566670204873618202680865638534865944483058650517380292320436016362659617294570185140789829574277032406195741535138712427510938542219940873171248862329526140744770994303733112530324791184417282382\",\n\t\t\"-0.54402111088937016772477554483765124109312606762621462357463994520238396180161585438877562935656067241573063207614488370477645194661241525080677431257416988398683714890165970942834453391033857378247849486306346743023618509617104937236345831462093934032592562972419977883837745736210439651143668255744843041350221801750331646628192115694352540293150183983357476391787825596543270240461102629075832777618592034309799936\",\n\t\t\"-0.564291758480422881634770440632390475980828840253516895637281099241819037882007239070203007530085741820184955492382572029153491807930868879341091067301689987699567034024159005627332722089169680203292567574310010066799858914647295684974242359142300929248173166551428537696685165964880390889406578530338963341989826231514301546476672476399906348023294571001061677668735117509440368611093448917120819545826797975989350435900286332895885871219875665471968941335407351099209738417818747252638912592184093301853338763294381446907254104878969784040526201729163408095795934201105630182851806342356035203279670146684553491616847294749721014579109870396804713831114709372638323643327823671187472335866664108658093206409882794958673673978956925250261545083579947618620746006004554405785185537391110314728988164693223775249484198058394348289545771967707968288542718255197272633789792059019367104377340604030147471453833808674013259696102003732963091159662478879760121731138091114134586544668859915547568540172541576138084166990547345181184322550297604278946942918844039406876827936831612756344331500301118652183156052728447906384772901595431751550607818380262138322673253023464533931883787069611052589166000316238423939491520880451263927981787175602294299295744\",\n\t}\n\tfor i, inp := range inps {\n\t\td, err := NewFromString(inp)\n\t\tif err != nil {\n\t\t\tt.FailNow()\n\t\t}\n\t\ts, err := NewFromString(sols[i])\n\t\tif err != nil {\n\t\t\tt.FailNow()\n\t\t}\n\t\ta := d.Sin()\n\t\tif !a.Equal(s) {\n\t\t\tt.Errorf(\"expected %s, got %s\", s, a)\n\t\t}\n\t}\n}\n\n// For Cos\nfunc TestCos(t *testing.T) {\n\tinps := []string{\n\t\t\"-2.91919191919191919\",\n\t\t\"-1.0\",\n\t\t\"-0.25\",\n\t\t\"0.0\",\n\t\t\"0.33\",\n\t\t\"1.0\",\n\t\t\"5.0\",\n\t\t\"10\",\n\t\t\"11000020.2407442310156021090304691671842603586882014729198302312846062338790031898128063403419218957424\",\n\t}\n\tsols := []string{\n\t\t\"-0.975370726167463467746508538219884948528729295145689640359666742268127382748782064668565276308334226452812521220478854320025773591423493734486361306323829818426063430805234608660356853863442937297855742231573288105774823103008774355455799906250461848079705023428527473474556899228935370709945979509634251305018978306493011197513482210179171510947538040406781879762352211326273272515279567525396877609653501706919545667682725671944948392322552266752\",\n\t\t\"0.54030230586813965874561515067176071767603141150991567490927772778673118786033739102174242337864109186439207498973007363884202112942385976796862442063752663646870430360736682397798633852405003167527051283327366631405990604840629657123985368031838052877290142895506386796217551784101265975360960112885444847880134909594560331781699767647860744559228420471946006511861233129745921297270844542687374552066388998112901504\",\n\t\t\"0.968912421710644784099084544806854121387004852294921875\",\n\t\t\"1\",\n\t\t\"0.9460423435283869715490383692051286742343482760977712222\",\n\t\t\"0.54030230586813965874561515067176071767603141150991567490927772778673118786033739102174242337864109186439207498973007363884202112942385976796862442063752663646870430360736682397798633852405003167527051283327366631405990604840629657123985368031838052877290142895506386796217551784101265975360960112885444847880134909594560331781699767647860744559228420471946006511861233129745921297270844542687374552066388998112901504\",\n\t\t\"0.28366218546322646623291670213892426815646045792775066552057877370468842342090306560693620285882975471913545189522117672866861003904575909174769890684057564495184019705963607555427518763375472432216131070235796577209064861003009894615394882021220247535890708789312783718414424224334988974848162884228012265684775651099758365989567444515619764427493598258393280941942356912304265535918025036942025858493361644535438208\",\n\t\t\"-0.839071529076452222947082170022504835457755803801719612447629165523199043803440231769716865070163209041973184176293170330332317060558438085478980463542480791358920580076809381102480339018809694514100495572097422057215638383077242523713704127605770444906854175870243452753002238589530499630034663296166308443155999957196346563161387705205277189957388653461251461388391745795979375660087266037741360406956289962327970672363315696841378765492754546688\",\n\t\t\"-0.82557544253149396284458404188071504476091346830440347376462206521981928020803354950315062147200396866217255527509254080721982393941347365824137698491042935894213870423296625749297033966815252917361266452901192457318047750698424190124169875103436588397415032138037063155981648677895645409699825582226442363080800781881653440538927704569142007751338851079530521979429507520541625303794665680584709171813053216867014700596866196844144286737568957809383224972108999354839705480223052622003994027222120126949093911643497423100187973906980635670000034664323357488815820848035808846624518774608931622703631130673844138378087837990739103263093532314835289302930152150130664948083902949999427848344301686172490282395687167681679607401220592559832932068966455384902377056623736013617949634746332323529256184776892339963173795176200590119077305668901887229709592836744082027738666294887303249770621722032438202753270710379312736193201366287952361100525126056993039858894987153270630277483613793395809214871734783742285495171911648254647287555645360520115341268930844095156502348405343740866836850201634640011708462641462047870611041595707018966032206807675586825362640000739202116391403514629284000986232673698892843586989003952425039512325844566790376383098534975022847888104706525937115931692008959513984157709954859352131323440787667052399474107219968\",\n\t}\n\tfor i, inp := range inps {\n\t\td, err := NewFromString(inp)\n\t\tif err != nil {\n\t\t\tt.FailNow()\n\t\t}\n\t\ts, err := NewFromString(sols[i])\n\t\tif err != nil {\n\t\t\tt.FailNow()\n\t\t}\n\t\ta := d.Cos()\n\t\tif !a.Equal(s) {\n\t\t\tt.Errorf(\"expected %s, got %s\", s, a)\n\t\t}\n\t}\n}\n\n// For Tan\nfunc TestTan(t *testing.T) {\n\tinps := []string{\n\t\t\"-2.91919191919191919\",\n\t\t\"-1.0\",\n\t\t\"-0.25\",\n\t\t\"0.0\",\n\t\t\"0.33\",\n\t\t\"1.0\",\n\t\t\"5.0\",\n\t\t\"10\",\n\t\t\"11000020.2407442310156021090304691671842603586882014729198302312846062338790031898128063403419218957424\",\n\t}\n\tsols := []string{\n\t\t\"0.2261415650505790298980791606748881031998682652\",\n\t\t\"-1.5574077246549025\",\n\t\t\"-0.255341921221036275\",\n\t\t\"0.0\",\n\t\t\"0.342524867530038963\",\n\t\t\"1.5574077246549025\",\n\t\t\"-3.3805150062465829\",\n\t\t\"0.6483608274590872485524085572681343280321117494\",\n\t\t\"0.68351325561491170753499935023939368502774607234006019034769919811202010905597996164029250820702097041244539696\",\n\t}\n\tfor i, inp := range inps {\n\t\td, err := NewFromString(inp)\n\t\tif err != nil {\n\t\t\tt.FailNow()\n\t\t}\n\t\ts, err := NewFromString(sols[i])\n\t\tif err != nil {\n\t\t\tt.FailNow()\n\t\t}\n\t\ta := d.Tan()\n\t\tif !a.Equal(s) {\n\t\t\tt.Errorf(\"expected %s, got %s\", s, a)\n\t\t}\n\t}\n}\n\nfunc TestNewNullDecimal(t *testing.T) {\n\td := NewFromInt(1)\n\tnd := NewNullDecimal(d)\n\n\tif !nd.Valid {\n\t\tt.Errorf(\"expected NullDecimal to be valid\")\n\t}\n\tif nd.Decimal != d {\n\t\tt.Errorf(\"expected NullDecimal to hold the provided Decimal\")\n\t}\n}\n\nfunc ExampleNewFromFloat32() {\n\tfmt.Println(NewFromFloat32(123.123123123123).String())\n\tfmt.Println(NewFromFloat32(.123123123123123).String())\n\tfmt.Println(NewFromFloat32(-1e13).String())\n\t// OUTPUT:\n\t//123.12312\n\t//0.123123124\n\t//-10000000000000\n}\n\nfunc ExampleNewFromFloat() {\n\tfmt.Println(NewFromFloat(123.123123123123).String())\n\tfmt.Println(NewFromFloat(.123123123123123).String())\n\tfmt.Println(NewFromFloat(-1e13).String())\n\t// OUTPUT:\n\t//123.123123123123\n\t//0.123123123123123\n\t//-10000000000000\n}\n"
        },
        {
          "name": "go.mod",
          "type": "blob",
          "size": 0.044921875,
          "content": "module github.com/shopspring/decimal\n\ngo 1.10\n"
        },
        {
          "name": "rounding.go",
          "type": "blob",
          "size": 5.0693359375,
          "content": "// Copyright 2009 The Go Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\n// Multiprecision decimal numbers.\n// For floating-point formatting only; not general purpose.\n// Only operations are assign and (binary) left/right shift.\n// Can do binary floating point in multiprecision decimal precisely\n// because 2 divides 10; cannot do decimal floating point\n// in multiprecision binary precisely.\n\npackage decimal\n\ntype floatInfo struct {\n\tmantbits uint\n\texpbits  uint\n\tbias     int\n}\n\nvar float32info = floatInfo{23, 8, -127}\nvar float64info = floatInfo{52, 11, -1023}\n\n// roundShortest rounds d (= mant * 2^exp) to the shortest number of digits\n// that will let the original floating point value be precisely reconstructed.\nfunc roundShortest(d *decimal, mant uint64, exp int, flt *floatInfo) {\n\t// If mantissa is zero, the number is zero; stop now.\n\tif mant == 0 {\n\t\td.nd = 0\n\t\treturn\n\t}\n\n\t// Compute upper and lower such that any decimal number\n\t// between upper and lower (possibly inclusive)\n\t// will round to the original floating point number.\n\n\t// We may see at once that the number is already shortest.\n\t//\n\t// Suppose d is not denormal, so that 2^exp <= d < 10^dp.\n\t// The closest shorter number is at least 10^(dp-nd) away.\n\t// The lower/upper bounds computed below are at distance\n\t// at most 2^(exp-mantbits).\n\t//\n\t// So the number is already shortest if 10^(dp-nd) > 2^(exp-mantbits),\n\t// or equivalently log2(10)*(dp-nd) > exp-mantbits.\n\t// It is true if 332/100*(dp-nd) >= exp-mantbits (log2(10) > 3.32).\n\tminexp := flt.bias + 1 // minimum possible exponent\n\tif exp > minexp && 332*(d.dp-d.nd) >= 100*(exp-int(flt.mantbits)) {\n\t\t// The number is already shortest.\n\t\treturn\n\t}\n\n\t// d = mant << (exp - mantbits)\n\t// Next highest floating point number is mant+1 << exp-mantbits.\n\t// Our upper bound is halfway between, mant*2+1 << exp-mantbits-1.\n\tupper := new(decimal)\n\tupper.Assign(mant*2 + 1)\n\tupper.Shift(exp - int(flt.mantbits) - 1)\n\n\t// d = mant << (exp - mantbits)\n\t// Next lowest floating point number is mant-1 << exp-mantbits,\n\t// unless mant-1 drops the significant bit and exp is not the minimum exp,\n\t// in which case the next lowest is mant*2-1 << exp-mantbits-1.\n\t// Either way, call it mantlo << explo-mantbits.\n\t// Our lower bound is halfway between, mantlo*2+1 << explo-mantbits-1.\n\tvar mantlo uint64\n\tvar explo int\n\tif mant > 1<<flt.mantbits || exp == minexp {\n\t\tmantlo = mant - 1\n\t\texplo = exp\n\t} else {\n\t\tmantlo = mant*2 - 1\n\t\texplo = exp - 1\n\t}\n\tlower := new(decimal)\n\tlower.Assign(mantlo*2 + 1)\n\tlower.Shift(explo - int(flt.mantbits) - 1)\n\n\t// The upper and lower bounds are possible outputs only if\n\t// the original mantissa is even, so that IEEE round-to-even\n\t// would round to the original mantissa and not the neighbors.\n\tinclusive := mant%2 == 0\n\n\t// As we walk the digits we want to know whether rounding up would fall\n\t// within the upper bound. This is tracked by upperdelta:\n\t//\n\t// If upperdelta == 0, the digits of d and upper are the same so far.\n\t//\n\t// If upperdelta == 1, we saw a difference of 1 between d and upper on a\n\t// previous digit and subsequently only 9s for d and 0s for upper.\n\t// (Thus rounding up may fall outside the bound, if it is exclusive.)\n\t//\n\t// If upperdelta == 2, then the difference is greater than 1\n\t// and we know that rounding up falls within the bound.\n\tvar upperdelta uint8\n\n\t// Now we can figure out the minimum number of digits required.\n\t// Walk along until d has distinguished itself from upper and lower.\n\tfor ui := 0; ; ui++ {\n\t\t// lower, d, and upper may have the decimal points at different\n\t\t// places. In this case upper is the longest, so we iterate from\n\t\t// ui==0 and start li and mi at (possibly) -1.\n\t\tmi := ui - upper.dp + d.dp\n\t\tif mi >= d.nd {\n\t\t\tbreak\n\t\t}\n\t\tli := ui - upper.dp + lower.dp\n\t\tl := byte('0') // lower digit\n\t\tif li >= 0 && li < lower.nd {\n\t\t\tl = lower.d[li]\n\t\t}\n\t\tm := byte('0') // middle digit\n\t\tif mi >= 0 {\n\t\t\tm = d.d[mi]\n\t\t}\n\t\tu := byte('0') // upper digit\n\t\tif ui < upper.nd {\n\t\t\tu = upper.d[ui]\n\t\t}\n\n\t\t// Okay to round down (truncate) if lower has a different digit\n\t\t// or if lower is inclusive and is exactly the result of rounding\n\t\t// down (i.e., and we have reached the final digit of lower).\n\t\tokdown := l != m || inclusive && li+1 == lower.nd\n\n\t\tswitch {\n\t\tcase upperdelta == 0 && m+1 < u:\n\t\t\t// Example:\n\t\t\t// m = 12345xxx\n\t\t\t// u = 12347xxx\n\t\t\tupperdelta = 2\n\t\tcase upperdelta == 0 && m != u:\n\t\t\t// Example:\n\t\t\t// m = 12345xxx\n\t\t\t// u = 12346xxx\n\t\t\tupperdelta = 1\n\t\tcase upperdelta == 1 && (m != '9' || u != '0'):\n\t\t\t// Example:\n\t\t\t// m = 1234598x\n\t\t\t// u = 1234600x\n\t\t\tupperdelta = 2\n\t\t}\n\t\t// Okay to round up if upper has a different digit and either upper\n\t\t// is inclusive or upper is bigger than the result of rounding up.\n\t\tokup := upperdelta > 0 && (inclusive || upperdelta > 1 || ui+1 < upper.nd)\n\n\t\t// If it's okay to do either, then round to the nearest one.\n\t\t// If it's okay to do only one, do it.\n\t\tswitch {\n\t\tcase okdown && okup:\n\t\t\td.Round(mi + 1)\n\t\t\treturn\n\t\tcase okdown:\n\t\t\td.RoundDown(mi + 1)\n\t\t\treturn\n\t\tcase okup:\n\t\t\td.RoundUp(mi + 1)\n\t\t\treturn\n\t\t}\n\t}\n}\n"
        }
      ]
    }
  ]
}