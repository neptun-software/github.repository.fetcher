{
  "metadata": {
    "timestamp": 1736567130939,
    "page": 728,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjczMA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "soheilhy/cmux",
      "stars": 2599,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.259765625,
          "content": "# Compiled Object files, Static and Dynamic libs (Shared Objects)\n*.o\n*.a\n*.so\n\n# Folders\n_obj\n_test\n\n# Architecture specific extensions/prefixes\n*.[568vq]\n[568vq].out\n\n*.cgo1.go\n*.cgo2.c\n_cgo_defun.c\n_cgo_gotypes.go\n_cgo_export.*\n\n_testmain.go\n\n*.exe\n*.test\n*.prof\n"
        },
        {
          "name": ".travis.yml",
          "type": "blob",
          "size": 0.6982421875,
          "content": "language: go\n\ngo:\n  - 1.6\n  - 1.7\n  - 1.8\n  - tip\n\nmatrix:\n  allow_failures:\n    - go: tip\n\ngobuild_args: -race\n\nbefore_install:\n  - if [[ $TRAVIS_GO_VERSION == 1.6* ]]; then go get -u github.com/kisielk/errcheck; fi\n  - if [[ $TRAVIS_GO_VERSION == 1.6* ]]; then go get -u golang.org/x/lint/golint; fi\n\nbefore_script:\n  - '! gofmt -s -l . | read'\n  - echo $TRAVIS_GO_VERSION\n  - if [[ $TRAVIS_GO_VERSION == 1.6* ]]; then golint ./...; fi\n  - if [[ $TRAVIS_GO_VERSION == 1.6* ]]; then errcheck ./...; fi\n  - if [[ $TRAVIS_GO_VERSION == 1.6* ]]; then go tool vet .; fi\n  - if [[ $TRAVIS_GO_VERSION == 1.6* ]]; then go tool vet --shadow .; fi\n\nscript:\n  - go test -bench . -v ./...\n  - go test -race -bench . -v ./...\n"
        },
        {
          "name": "CONTRIBUTORS",
          "type": "blob",
          "size": 0.427734375,
          "content": "# The list of people who have contributed code to the cmux repository.\n#\n# Auto-generated with:\n#\t\tgit log --oneline --pretty=format:'%an <%aE>' | sort -u\n#\nAndreas Jaekle <andreas@jaekle.net>\nDmitri Shuralyov <shurcooL@gmail.com>\nEthan Mosbaugh <emosbaugh@gmail.com>\nSoheil Hassas Yeganeh <soheil.h.y@gmail.com>\nSoheil Hassas Yeganeh <soheil@cs.toronto.edu>\nTamir Duberstein <tamir@cockroachlabs.com>\nTamir Duberstein <tamird@gmail.com>\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 11.091796875,
          "content": "\n                                 Apache License\n                           Version 2.0, January 2004\n                        http://www.apache.org/licenses/\n\n   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION\n\n   1. Definitions.\n\n      \"License\" shall mean the terms and conditions for use, reproduction,\n      and distribution as defined by Sections 1 through 9 of this document.\n\n      \"Licensor\" shall mean the copyright owner or entity authorized by\n      the copyright owner that is granting the License.\n\n      \"Legal Entity\" shall mean the union of the acting entity and all\n      other entities that control, are controlled by, or are under common\n      control with that entity. For the purposes of this definition,\n      \"control\" means (i) the power, direct or indirect, to cause the\n      direction or management of such entity, whether by contract or\n      otherwise, or (ii) ownership of fifty percent (50%) or more of the\n      outstanding shares, or (iii) beneficial ownership of such entity.\n\n      \"You\" (or \"Your\") shall mean an individual or Legal Entity\n      exercising permissions granted by this License.\n\n      \"Source\" form shall mean the preferred form for making modifications,\n      including but not limited to software source code, documentation\n      source, and configuration files.\n\n      \"Object\" form shall mean any form resulting from mechanical\n      transformation or translation of a Source form, including but\n      not limited to compiled object code, generated documentation,\n      and conversions to other media types.\n\n      \"Work\" shall mean the work of authorship, whether in Source or\n      Object form, made available under the License, as indicated by a\n      copyright notice that is included in or attached to the work\n      (an example is provided in the Appendix below).\n\n      \"Derivative Works\" shall mean any work, whether in Source or Object\n      form, that is based on (or derived from) the Work and for which the\n      editorial revisions, annotations, elaborations, or other modifications\n      represent, as a whole, an original work of authorship. For the purposes\n      of this License, Derivative Works shall not include works that remain\n      separable from, or merely link (or bind by name) to the interfaces of,\n      the Work and Derivative Works thereof.\n\n      \"Contribution\" shall mean any work of authorship, including\n      the original version of the Work and any modifications or additions\n      to that Work or Derivative Works thereof, that is intentionally\n      submitted to Licensor for inclusion in the Work by the copyright owner\n      or by an individual or Legal Entity authorized to submit on behalf of\n      the copyright owner. For the purposes of this definition, \"submitted\"\n      means any form of electronic, verbal, or written communication sent\n      to the Licensor or its representatives, including but not limited to\n      communication on electronic mailing lists, source code control systems,\n      and issue tracking systems that are managed by, or on behalf of, the\n      Licensor for the purpose of discussing and improving the Work, but\n      excluding communication that is conspicuously marked or otherwise\n      designated in writing by the copyright owner as \"Not a Contribution.\"\n\n      \"Contributor\" shall mean Licensor and any individual or Legal Entity\n      on behalf of whom a Contribution has been received by Licensor and\n      subsequently incorporated within the Work.\n\n   2. Grant of Copyright License. Subject to the terms and conditions of\n      this License, each Contributor hereby grants to You a perpetual,\n      worldwide, non-exclusive, no-charge, royalty-free, irrevocable\n      copyright license to reproduce, prepare Derivative Works of,\n      publicly display, publicly perform, sublicense, and distribute the\n      Work and such Derivative Works in Source or Object form.\n\n   3. Grant of Patent License. Subject to the terms and conditions of\n      this License, each Contributor hereby grants to You a perpetual,\n      worldwide, non-exclusive, no-charge, royalty-free, irrevocable\n      (except as stated in this section) patent license to make, have made,\n      use, offer to sell, sell, import, and otherwise transfer the Work,\n      where such license applies only to those patent claims licensable\n      by such Contributor that are necessarily infringed by their\n      Contribution(s) alone or by combination of their Contribution(s)\n      with the Work to which such Contribution(s) was submitted. If You\n      institute patent litigation against any entity (including a\n      cross-claim or counterclaim in a lawsuit) alleging that the Work\n      or a Contribution incorporated within the Work constitutes direct\n      or contributory patent infringement, then any patent licenses\n      granted to You under this License for that Work shall terminate\n      as of the date such litigation is filed.\n\n   4. Redistribution. You may reproduce and distribute copies of the\n      Work or Derivative Works thereof in any medium, with or without\n      modifications, and in Source or Object form, provided that You\n      meet the following conditions:\n\n      (a) You must give any other recipients of the Work or\n          Derivative Works a copy of this License; and\n\n      (b) You must cause any modified files to carry prominent notices\n          stating that You changed the files; and\n\n      (c) You must retain, in the Source form of any Derivative Works\n          that You distribute, all copyright, patent, trademark, and\n          attribution notices from the Source form of the Work,\n          excluding those notices that do not pertain to any part of\n          the Derivative Works; and\n\n      (d) If the Work includes a \"NOTICE\" text file as part of its\n          distribution, then any Derivative Works that You distribute must\n          include a readable copy of the attribution notices contained\n          within such NOTICE file, excluding those notices that do not\n          pertain to any part of the Derivative Works, in at least one\n          of the following places: within a NOTICE text file distributed\n          as part of the Derivative Works; within the Source form or\n          documentation, if provided along with the Derivative Works; or,\n          within a display generated by the Derivative Works, if and\n          wherever such third-party notices normally appear. The contents\n          of the NOTICE file are for informational purposes only and\n          do not modify the License. You may add Your own attribution\n          notices within Derivative Works that You distribute, alongside\n          or as an addendum to the NOTICE text from the Work, provided\n          that such additional attribution notices cannot be construed\n          as modifying the License.\n\n      You may add Your own copyright statement to Your modifications and\n      may provide additional or different license terms and conditions\n      for use, reproduction, or distribution of Your modifications, or\n      for any such Derivative Works as a whole, provided Your use,\n      reproduction, and distribution of the Work otherwise complies with\n      the conditions stated in this License.\n\n   5. Submission of Contributions. Unless You explicitly state otherwise,\n      any Contribution intentionally submitted for inclusion in the Work\n      by You to the Licensor shall be under the terms and conditions of\n      this License, without any additional terms or conditions.\n      Notwithstanding the above, nothing herein shall supersede or modify\n      the terms of any separate license agreement you may have executed\n      with Licensor regarding such Contributions.\n\n   6. Trademarks. This License does not grant permission to use the trade\n      names, trademarks, service marks, or product names of the Licensor,\n      except as required for reasonable and customary use in describing the\n      origin of the Work and reproducing the content of the NOTICE file.\n\n   7. Disclaimer of Warranty. Unless required by applicable law or\n      agreed to in writing, Licensor provides the Work (and each\n      Contributor provides its Contributions) on an \"AS IS\" BASIS,\n      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n      implied, including, without limitation, any warranties or conditions\n      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A\n      PARTICULAR PURPOSE. You are solely responsible for determining the\n      appropriateness of using or redistributing the Work and assume any\n      risks associated with Your exercise of permissions under this License.\n\n   8. Limitation of Liability. In no event and under no legal theory,\n      whether in tort (including negligence), contract, or otherwise,\n      unless required by applicable law (such as deliberate and grossly\n      negligent acts) or agreed to in writing, shall any Contributor be\n      liable to You for damages, including any direct, indirect, special,\n      incidental, or consequential damages of any character arising as a\n      result of this License or out of the use or inability to use the\n      Work (including but not limited to damages for loss of goodwill,\n      work stoppage, computer failure or malfunction, or any and all\n      other commercial damages or losses), even if such Contributor\n      has been advised of the possibility of such damages.\n\n   9. Accepting Warranty or Additional Liability. While redistributing\n      the Work or Derivative Works thereof, You may choose to offer,\n      and charge a fee for, acceptance of support, warranty, indemnity,\n      or other liability obligations and/or rights consistent with this\n      License. However, in accepting such obligations, You may act only\n      on Your own behalf and on Your sole responsibility, not on behalf\n      of any other Contributor, and only if You agree to indemnify,\n      defend, and hold each Contributor harmless for any liability\n      incurred by, or claims asserted against, such Contributor by reason\n      of your accepting any such warranty or additional liability.\n\n   END OF TERMS AND CONDITIONS\n\n   APPENDIX: How to apply the Apache License to your work.\n\n      To apply the Apache License to your work, attach the following\n      boilerplate notice, with the fields enclosed by brackets \"[]\"\n      replaced with your own identifying information. (Don't include\n      the brackets!)  The text should be enclosed in the appropriate\n      comment syntax for the file format. We also recommend that a\n      file or class name and description of purpose be included on the\n      same \"printed page\" as the copyright notice for easier\n      identification within third-party archives.\n\n   Copyright [yyyy] [name of copyright owner]\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n       http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 2.82421875,
          "content": "# cmux: Connection Mux ![Travis Build Status](https://api.travis-ci.org/soheilhy/args.svg?branch=master \"Travis Build Status\") [![GoDoc](https://godoc.org/github.com/soheilhy/cmux?status.svg)](http://godoc.org/github.com/soheilhy/cmux)\n\ncmux is a generic Go library to multiplex connections based on\ntheir payload. Using cmux, you can serve gRPC, SSH, HTTPS, HTTP,\nGo RPC, and pretty much any other protocol on the same TCP listener.\n\n## How-To\nSimply create your main listener, create a cmux for that listener,\nand then match connections:\n```go\n// Create the main listener.\nl, err := net.Listen(\"tcp\", \":23456\")\nif err != nil {\n\tlog.Fatal(err)\n}\n\n// Create a cmux.\nm := cmux.New(l)\n\n// Match connections in order:\n// First grpc, then HTTP, and otherwise Go RPC/TCP.\ngrpcL := m.Match(cmux.HTTP2HeaderField(\"content-type\", \"application/grpc\"))\nhttpL := m.Match(cmux.HTTP1Fast())\ntrpcL := m.Match(cmux.Any()) // Any means anything that is not yet matched.\n\n// Create your protocol servers.\ngrpcS := grpc.NewServer()\ngrpchello.RegisterGreeterServer(grpcS, &server{})\n\nhttpS := &http.Server{\n\tHandler: &helloHTTP1Handler{},\n}\n\ntrpcS := rpc.NewServer()\ntrpcS.Register(&ExampleRPCRcvr{})\n\n// Use the muxed listeners for your servers.\ngo grpcS.Serve(grpcL)\ngo httpS.Serve(httpL)\ngo trpcS.Accept(trpcL)\n\n// Start serving!\nm.Serve()\n```\n\nTake a look at [other examples in the GoDoc](http://godoc.org/github.com/soheilhy/cmux/#pkg-examples).\n\n## Docs\n* [GoDocs](https://godoc.org/github.com/soheilhy/cmux)\n\n## Performance\nThere is room for improvment but, since we are only matching\nthe very first bytes of a connection, the performance overheads on\nlong-lived connections (i.e., RPCs and pipelined HTTP streams)\nis negligible.\n\n*TODO(soheil)*: Add benchmarks.\n\n## Limitations\n* *TLS*: `net/http` uses a type assertion to identify TLS connections; since\ncmux's lookahead-implementing connection wraps the underlying TLS connection,\nthis type assertion fails.\nBecause of that, you can serve HTTPS using cmux but `http.Request.TLS`\nwould not be set in your handlers.\n\n* *Different Protocols on The Same Connection*: `cmux` matches the connection\nwhen it's accepted. For example, one connection can be either gRPC or REST, but\nnot both. That is, we assume that a client connection is either used for gRPC\nor REST.\n\n* *Java gRPC Clients*: Java gRPC client blocks until it receives a SETTINGS\nframe from the server. If you are using the Java client to connect to a cmux'ed\ngRPC server please match with writers:\n```go\ngrpcl := m.MatchWithWriters(cmux.HTTP2MatchHeaderFieldSendSettings(\"content-type\", \"application/grpc\"))\n```\n\n# Copyright and License\nCopyright 2016 The CMux Authors. All rights reserved.\n\nSee [CONTRIBUTORS](https://github.com/soheilhy/cmux/blob/master/CONTRIBUTORS)\nfor the CMux Authors. Code is released under\n[the Apache 2 license](https://github.com/soheilhy/cmux/blob/master/LICENSE).\n"
        },
        {
          "name": "bench_test.go",
          "type": "blob",
          "size": 2.65234375,
          "content": "// Copyright 2016 The CMux Authors. All rights reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied. See the License for the specific language governing\n// permissions and limitations under the License.\n\npackage cmux\n\nimport (\n\t\"bytes\"\n\t\"io\"\n\t\"net\"\n\t\"sync\"\n\t\"testing\"\n\t\"time\"\n\n\t\"golang.org/x/net/http2\"\n)\n\nvar (\n\tbenchHTTP1Payload = make([]byte, 4096)\n\tbenchHTTP2Payload = make([]byte, 4096)\n)\n\nfunc init() {\n\tcopy(benchHTTP1Payload, []byte(\"GET http://www.w3.org/ HTTP/1.1\"))\n\tcopy(benchHTTP2Payload, http2.ClientPreface)\n}\n\ntype mockConn struct {\n\tnet.Conn\n\tr io.Reader\n}\n\nfunc (c *mockConn) Read(b []byte) (n int, err error) {\n\treturn c.r.Read(b)\n}\n\nfunc (c *mockConn) SetReadDeadline(time.Time) error {\n\treturn nil\n}\n\nfunc discard(l net.Listener) {\n\tfor {\n\t\tif _, err := l.Accept(); err != nil {\n\t\t\treturn\n\t\t}\n\t}\n}\n\nfunc BenchmarkCMuxConnHTTP1(b *testing.B) {\n\tm := New(nil).(*cMux)\n\tl := m.Match(HTTP1Fast())\n\n\tgo discard(l)\n\n\tdonec := make(chan struct{})\n\tvar wg sync.WaitGroup\n\twg.Add(b.N)\n\n\tb.ResetTimer()\n\tb.RunParallel(func(pb *testing.PB) {\n\t\tfor pb.Next() {\n\t\t\twg.Add(1)\n\t\t\tm.serve(&mockConn{\n\t\t\t\tr: bytes.NewReader(benchHTTP1Payload),\n\t\t\t}, donec, &wg)\n\t\t}\n\t})\n}\n\nfunc BenchmarkCMuxConnHTTP2(b *testing.B) {\n\tm := New(nil).(*cMux)\n\tl := m.Match(HTTP2())\n\tgo discard(l)\n\n\tdonec := make(chan struct{})\n\tvar wg sync.WaitGroup\n\twg.Add(b.N)\n\n\tb.ResetTimer()\n\tb.RunParallel(func(pb *testing.PB) {\n\t\tfor pb.Next() {\n\t\t\twg.Add(1)\n\t\t\tm.serve(&mockConn{\n\t\t\t\tr: bytes.NewReader(benchHTTP2Payload),\n\t\t\t}, donec, &wg)\n\t\t}\n\t})\n}\n\nfunc BenchmarkCMuxConnHTTP1n2(b *testing.B) {\n\tm := New(nil).(*cMux)\n\tl1 := m.Match(HTTP1Fast())\n\tl2 := m.Match(HTTP2())\n\n\tgo discard(l1)\n\tgo discard(l2)\n\n\tdonec := make(chan struct{})\n\tvar wg sync.WaitGroup\n\n\tb.ResetTimer()\n\tb.RunParallel(func(pb *testing.PB) {\n\t\tfor pb.Next() {\n\t\t\twg.Add(1)\n\t\t\tm.serve(&mockConn{\n\t\t\t\tr: bytes.NewReader(benchHTTP2Payload),\n\t\t\t}, donec, &wg)\n\t\t}\n\t})\n}\n\nfunc BenchmarkCMuxConnHTTP2n1(b *testing.B) {\n\tm := New(nil).(*cMux)\n\tl2 := m.Match(HTTP2())\n\tl1 := m.Match(HTTP1Fast())\n\n\tgo discard(l1)\n\tgo discard(l2)\n\n\tdonec := make(chan struct{})\n\tvar wg sync.WaitGroup\n\n\tb.ResetTimer()\n\tb.RunParallel(func(pb *testing.PB) {\n\t\tfor pb.Next() {\n\t\t\twg.Add(1)\n\t\t\tm.serve(&mockConn{\n\t\t\t\tr: bytes.NewReader(benchHTTP1Payload),\n\t\t\t}, donec, &wg)\n\t\t}\n\t})\n}\n"
        },
        {
          "name": "buffer.go",
          "type": "blob",
          "size": 1.9638671875,
          "content": "// Copyright 2016 The CMux Authors. All rights reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied. See the License for the specific language governing\n// permissions and limitations under the License.\n\npackage cmux\n\nimport (\n\t\"bytes\"\n\t\"io\"\n)\n\n// bufferedReader is an optimized implementation of io.Reader that behaves like\n// ```\n// io.MultiReader(bytes.NewReader(buffer.Bytes()), io.TeeReader(source, buffer))\n// ```\n// without allocating.\ntype bufferedReader struct {\n\tsource     io.Reader\n\tbuffer     bytes.Buffer\n\tbufferRead int\n\tbufferSize int\n\tsniffing   bool\n\tlastErr    error\n}\n\nfunc (s *bufferedReader) Read(p []byte) (int, error) {\n\tif s.bufferSize > s.bufferRead {\n\t\t// If we have already read something from the buffer before, we return the\n\t\t// same data and the last error if any. We need to immediately return,\n\t\t// otherwise we may block for ever, if we try to be smart and call\n\t\t// source.Read() seeking a little bit of more data.\n\t\tbn := copy(p, s.buffer.Bytes()[s.bufferRead:s.bufferSize])\n\t\ts.bufferRead += bn\n\t\treturn bn, s.lastErr\n\t} else if !s.sniffing && s.buffer.Cap() != 0 {\n\t\t// We don't need the buffer anymore.\n\t\t// Reset it to release the internal slice.\n\t\ts.buffer = bytes.Buffer{}\n\t}\n\n\t// If there is nothing more to return in the sniffed buffer, read from the\n\t// source.\n\tsn, sErr := s.source.Read(p)\n\tif sn > 0 && s.sniffing {\n\t\ts.lastErr = sErr\n\t\tif wn, wErr := s.buffer.Write(p[:sn]); wErr != nil {\n\t\t\treturn wn, wErr\n\t\t}\n\t}\n\treturn sn, sErr\n}\n\nfunc (s *bufferedReader) reset(snif bool) {\n\ts.sniffing = snif\n\ts.bufferRead = 0\n\ts.bufferSize = s.buffer.Len()\n}\n"
        },
        {
          "name": "cmux.go",
          "type": "blob",
          "size": 7.21484375,
          "content": "// Copyright 2016 The CMux Authors. All rights reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied. See the License for the specific language governing\n// permissions and limitations under the License.\n\npackage cmux\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"net\"\n\t\"sync\"\n\t\"time\"\n)\n\n// Matcher matches a connection based on its content.\ntype Matcher func(io.Reader) bool\n\n// MatchWriter is a match that can also write response (say to do handshake).\ntype MatchWriter func(io.Writer, io.Reader) bool\n\n// ErrorHandler handles an error and returns whether\n// the mux should continue serving the listener.\ntype ErrorHandler func(error) bool\n\nvar _ net.Error = ErrNotMatched{}\n\n// ErrNotMatched is returned whenever a connection is not matched by any of\n// the matchers registered in the multiplexer.\ntype ErrNotMatched struct {\n\tc net.Conn\n}\n\nfunc (e ErrNotMatched) Error() string {\n\treturn fmt.Sprintf(\"mux: connection %v not matched by an matcher\",\n\t\te.c.RemoteAddr())\n}\n\n// Temporary implements the net.Error interface.\nfunc (e ErrNotMatched) Temporary() bool { return true }\n\n// Timeout implements the net.Error interface.\nfunc (e ErrNotMatched) Timeout() bool { return false }\n\ntype errListenerClosed string\n\nfunc (e errListenerClosed) Error() string   { return string(e) }\nfunc (e errListenerClosed) Temporary() bool { return false }\nfunc (e errListenerClosed) Timeout() bool   { return false }\n\n// ErrListenerClosed is returned from muxListener.Accept when the underlying\n// listener is closed.\nvar ErrListenerClosed = errListenerClosed(\"mux: listener closed\")\n\n// ErrServerClosed is returned from muxListener.Accept when mux server is closed.\nvar ErrServerClosed = errors.New(\"mux: server closed\")\n\n// for readability of readTimeout\nvar noTimeout time.Duration\n\n// New instantiates a new connection multiplexer.\nfunc New(l net.Listener) CMux {\n\treturn &cMux{\n\t\troot:        l,\n\t\tbufLen:      1024,\n\t\terrh:        func(_ error) bool { return true },\n\t\tdonec:       make(chan struct{}),\n\t\treadTimeout: noTimeout,\n\t}\n}\n\n// CMux is a multiplexer for network connections.\ntype CMux interface {\n\t// Match returns a net.Listener that sees (i.e., accepts) only\n\t// the connections matched by at least one of the matcher.\n\t//\n\t// The order used to call Match determines the priority of matchers.\n\tMatch(...Matcher) net.Listener\n\t// MatchWithWriters returns a net.Listener that accepts only the\n\t// connections that matched by at least of the matcher writers.\n\t//\n\t// Prefer Matchers over MatchWriters, since the latter can write on the\n\t// connection before the actual handler.\n\t//\n\t// The order used to call Match determines the priority of matchers.\n\tMatchWithWriters(...MatchWriter) net.Listener\n\t// Serve starts multiplexing the listener. Serve blocks and perhaps\n\t// should be invoked concurrently within a go routine.\n\tServe() error\n\t// Closes cmux server and stops accepting any connections on listener\n\tClose()\n\t// HandleError registers an error handler that handles listener errors.\n\tHandleError(ErrorHandler)\n\t// sets a timeout for the read of matchers\n\tSetReadTimeout(time.Duration)\n}\n\ntype matchersListener struct {\n\tss []MatchWriter\n\tl  muxListener\n}\n\ntype cMux struct {\n\troot        net.Listener\n\tbufLen      int\n\terrh        ErrorHandler\n\tsls         []matchersListener\n\treadTimeout time.Duration\n\tdonec       chan struct{}\n\tmu          sync.Mutex\n}\n\nfunc matchersToMatchWriters(matchers []Matcher) []MatchWriter {\n\tmws := make([]MatchWriter, 0, len(matchers))\n\tfor _, m := range matchers {\n\t\tcm := m\n\t\tmws = append(mws, func(w io.Writer, r io.Reader) bool {\n\t\t\treturn cm(r)\n\t\t})\n\t}\n\treturn mws\n}\n\nfunc (m *cMux) Match(matchers ...Matcher) net.Listener {\n\tmws := matchersToMatchWriters(matchers)\n\treturn m.MatchWithWriters(mws...)\n}\n\nfunc (m *cMux) MatchWithWriters(matchers ...MatchWriter) net.Listener {\n\tml := muxListener{\n\t\tListener: m.root,\n\t\tconnc:    make(chan net.Conn, m.bufLen),\n\t\tdonec:    make(chan struct{}),\n\t}\n\tm.sls = append(m.sls, matchersListener{ss: matchers, l: ml})\n\treturn ml\n}\n\nfunc (m *cMux) SetReadTimeout(t time.Duration) {\n\tm.readTimeout = t\n}\n\nfunc (m *cMux) Serve() error {\n\tvar wg sync.WaitGroup\n\n\tdefer func() {\n\t\tm.closeDoneChans()\n\t\twg.Wait()\n\n\t\tfor _, sl := range m.sls {\n\t\t\tclose(sl.l.connc)\n\t\t\t// Drain the connections enqueued for the listener.\n\t\t\tfor c := range sl.l.connc {\n\t\t\t\t_ = c.Close()\n\t\t\t}\n\t\t}\n\t}()\n\n\tfor {\n\t\tc, err := m.root.Accept()\n\t\tif err != nil {\n\t\t\tif !m.handleErr(err) {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tcontinue\n\t\t}\n\n\t\twg.Add(1)\n\t\tgo m.serve(c, m.donec, &wg)\n\t}\n}\n\nfunc (m *cMux) serve(c net.Conn, donec <-chan struct{}, wg *sync.WaitGroup) {\n\tdefer wg.Done()\n\n\tmuc := newMuxConn(c)\n\tif m.readTimeout > noTimeout {\n\t\t_ = c.SetReadDeadline(time.Now().Add(m.readTimeout))\n\t}\n\tfor _, sl := range m.sls {\n\t\tfor _, s := range sl.ss {\n\t\t\tmatched := s(muc.Conn, muc.startSniffing())\n\t\t\tif matched {\n\t\t\t\tmuc.doneSniffing()\n\t\t\t\tif m.readTimeout > noTimeout {\n\t\t\t\t\t_ = c.SetReadDeadline(time.Time{})\n\t\t\t\t}\n\t\t\t\tselect {\n\t\t\t\tcase sl.l.connc <- muc:\n\t\t\t\tcase <-donec:\n\t\t\t\t\t_ = c.Close()\n\t\t\t\t}\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t}\n\n\t_ = c.Close()\n\terr := ErrNotMatched{c: c}\n\tif !m.handleErr(err) {\n\t\t_ = m.root.Close()\n\t}\n}\n\nfunc (m *cMux) Close() {\n\tm.closeDoneChans()\n}\n\nfunc (m *cMux) closeDoneChans() {\n\tm.mu.Lock()\n\tdefer m.mu.Unlock()\n\n\tselect {\n\tcase <-m.donec:\n\t\t// Already closed. Don't close again\n\tdefault:\n\t\tclose(m.donec)\n\t}\n\tfor _, sl := range m.sls {\n\t\tselect {\n\t\tcase <-sl.l.donec:\n\t\t\t// Already closed. Don't close again\n\t\tdefault:\n\t\t\tclose(sl.l.donec)\n\t\t}\n\t}\n}\n\nfunc (m *cMux) HandleError(h ErrorHandler) {\n\tm.errh = h\n}\n\nfunc (m *cMux) handleErr(err error) bool {\n\tif !m.errh(err) {\n\t\treturn false\n\t}\n\n\tif ne, ok := err.(net.Error); ok {\n\t\treturn ne.Temporary()\n\t}\n\n\treturn false\n}\n\ntype muxListener struct {\n\tnet.Listener\n\tconnc chan net.Conn\n\tdonec chan struct{}\n}\n\nfunc (l muxListener) Accept() (net.Conn, error) {\n\tselect {\n\tcase c, ok := <-l.connc:\n\t\tif !ok {\n\t\t\treturn nil, ErrListenerClosed\n\t\t}\n\t\treturn c, nil\n\tcase <-l.donec:\n\t\treturn nil, ErrServerClosed\n\t}\n}\n\n// MuxConn wraps a net.Conn and provides transparent sniffing of connection data.\ntype MuxConn struct {\n\tnet.Conn\n\tbuf bufferedReader\n}\n\nfunc newMuxConn(c net.Conn) *MuxConn {\n\treturn &MuxConn{\n\t\tConn: c,\n\t\tbuf:  bufferedReader{source: c},\n\t}\n}\n\n// From the io.Reader documentation:\n//\n// When Read encounters an error or end-of-file condition after\n// successfully reading n > 0 bytes, it returns the number of\n// bytes read.  It may return the (non-nil) error from the same call\n// or return the error (and n == 0) from a subsequent call.\n// An instance of this general case is that a Reader returning\n// a non-zero number of bytes at the end of the input stream may\n// return either err == EOF or err == nil.  The next Read should\n// return 0, EOF.\nfunc (m *MuxConn) Read(p []byte) (int, error) {\n\treturn m.buf.Read(p)\n}\n\nfunc (m *MuxConn) startSniffing() io.Reader {\n\tm.buf.reset(true)\n\treturn &m.buf\n}\n\nfunc (m *MuxConn) doneSniffing() {\n\tm.buf.reset(false)\n}\n"
        },
        {
          "name": "cmux_test.go",
          "type": "blob",
          "size": 16.6015625,
          "content": "// Copyright 2016 The CMux Authors. All rights reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied. See the License for the specific language governing\n// permissions and limitations under the License.\n\npackage cmux\n\nimport (\n\t\"bytes\"\n\t\"crypto/rand\"\n\t\"crypto/tls\"\n\t\"errors\"\n\t\"fmt\"\n\t\"go/build\"\n\t\"io\"\n\t\"io/ioutil\"\n\t\"log\"\n\t\"net\"\n\t\"net/http\"\n\t\"net/rpc\"\n\t\"os\"\n\t\"os/exec\"\n\t\"runtime\"\n\t\"sort\"\n\t\"strings\"\n\t\"sync\"\n\t\"sync/atomic\"\n\t\"testing\"\n\t\"time\"\n\n\t\"golang.org/x/net/http2\"\n\t\"golang.org/x/net/http2/hpack\"\n)\n\nconst (\n\ttestHTTP1Resp = \"http1\"\n\trpcVal        = 1234\n)\n\nfunc safeServe(errCh chan<- error, muxl CMux) {\n\tif err := muxl.Serve(); !strings.Contains(err.Error(), \"use of closed\") {\n\t\terrCh <- err\n\t}\n}\n\nfunc safeDial(t *testing.T, addr net.Addr) (*rpc.Client, func()) {\n\tc, err := rpc.Dial(addr.Network(), addr.String())\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\treturn c, func() {\n\t\tif err := c.Close(); err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t}\n}\n\ntype chanListener struct {\n\tnet.Listener\n\tconnCh chan net.Conn\n}\n\nfunc newChanListener() *chanListener {\n\treturn &chanListener{connCh: make(chan net.Conn, 1)}\n}\n\nfunc (l *chanListener) Accept() (net.Conn, error) {\n\tif c, ok := <-l.connCh; ok {\n\t\treturn c, nil\n\t}\n\treturn nil, errors.New(\"use of closed network connection\")\n}\n\nfunc testListener(t *testing.T) (net.Listener, func()) {\n\tl, err := net.Listen(\"tcp\", \"127.0.0.1:0\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tvar once sync.Once\n\treturn l, func() {\n\t\tonce.Do(func() {\n\t\t\tif err := l.Close(); err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\t\t})\n\t}\n}\n\ntype testHTTP1Handler struct{}\n\nfunc (h *testHTTP1Handler) ServeHTTP(w http.ResponseWriter, r *http.Request) {\n\tfmt.Fprintf(w, testHTTP1Resp)\n}\n\nfunc runTestHTTPServer(errCh chan<- error, l net.Listener) {\n\tvar mu sync.Mutex\n\tconns := make(map[net.Conn]struct{})\n\n\tdefer func() {\n\t\tmu.Lock()\n\t\tfor c := range conns {\n\t\t\tif err := c.Close(); err != nil {\n\t\t\t\terrCh <- err\n\t\t\t}\n\t\t}\n\t\tmu.Unlock()\n\t}()\n\n\ts := &http.Server{\n\t\tHandler: &testHTTP1Handler{},\n\t\tConnState: func(c net.Conn, state http.ConnState) {\n\t\t\tmu.Lock()\n\t\t\tswitch state {\n\t\t\tcase http.StateNew:\n\t\t\t\tconns[c] = struct{}{}\n\t\t\tcase http.StateClosed:\n\t\t\t\tdelete(conns, c)\n\t\t\t}\n\t\t\tmu.Unlock()\n\t\t},\n\t}\n\tif err := s.Serve(l); err != ErrListenerClosed && err != ErrServerClosed {\n\t\terrCh <- err\n\t}\n}\n\nfunc generateTLSCert(t *testing.T) {\n\terr := exec.Command(\"go\", \"run\", build.Default.GOROOT+\"/src/crypto/tls/generate_cert.go\", \"--host\", \"*\").Run()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n}\n\nfunc cleanupTLSCert(t *testing.T) {\n\terr := os.Remove(\"cert.pem\")\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n\terr = os.Remove(\"key.pem\")\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n}\n\nfunc runTestTLSServer(errCh chan<- error, l net.Listener) {\n\tcertificate, err := tls.LoadX509KeyPair(\"cert.pem\", \"key.pem\")\n\tif err != nil {\n\t\terrCh <- err\n\t\tlog.Printf(\"1\")\n\t\treturn\n\t}\n\n\tconfig := &tls.Config{\n\t\tCertificates: []tls.Certificate{certificate},\n\t\tRand:         rand.Reader,\n\t}\n\n\ttlsl := tls.NewListener(l, config)\n\trunTestHTTPServer(errCh, tlsl)\n}\n\nfunc runTestHTTP1Client(t *testing.T, addr net.Addr) {\n\trunTestHTTPClient(t, \"http\", addr)\n}\n\nfunc runTestTLSClient(t *testing.T, addr net.Addr) {\n\trunTestHTTPClient(t, \"https\", addr)\n}\n\nfunc runTestHTTPClient(t *testing.T, proto string, addr net.Addr) {\n\tclient := http.Client{\n\t\tTimeout: 5 * time.Second,\n\t\tTransport: &http.Transport{\n\t\t\tTLSClientConfig: &tls.Config{InsecureSkipVerify: true},\n\t\t},\n\t}\n\tr, err := client.Get(proto + \"://\" + addr.String())\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tdefer func() {\n\t\tif err = r.Body.Close(); err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t}()\n\n\tb, err := ioutil.ReadAll(r.Body)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif string(b) != testHTTP1Resp {\n\t\tt.Fatalf(\"invalid response: want=%s got=%s\", testHTTP1Resp, b)\n\t}\n}\n\ntype TestRPCRcvr struct{}\n\nfunc (r TestRPCRcvr) Test(i int, j *int) error {\n\t*j = i\n\treturn nil\n}\n\nfunc runTestRPCServer(errCh chan<- error, l net.Listener) {\n\ts := rpc.NewServer()\n\tif err := s.Register(TestRPCRcvr{}); err != nil {\n\t\terrCh <- err\n\t}\n\tfor {\n\t\tc, err := l.Accept()\n\t\tif err != nil {\n\t\t\tif err != ErrListenerClosed && err != ErrServerClosed {\n\t\t\t\terrCh <- err\n\t\t\t}\n\t\t\treturn\n\t\t}\n\t\tgo s.ServeConn(c)\n\t}\n}\n\nfunc runTestRPCClient(t *testing.T, addr net.Addr) {\n\tc, cleanup := safeDial(t, addr)\n\tdefer cleanup()\n\n\tvar num int\n\tif err := c.Call(\"TestRPCRcvr.Test\", rpcVal, &num); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tif num != rpcVal {\n\t\tt.Errorf(\"wrong rpc response: want=%d got=%v\", rpcVal, num)\n\t}\n}\n\nconst (\n\thandleHTTP1Close   = 1\n\thandleHTTP1Request = 2\n\thandleAnyClose     = 3\n\thandleAnyRequest   = 4\n)\n\nfunc TestTimeout(t *testing.T) {\n\tdefer leakCheck(t)()\n\tlis, Close := testListener(t)\n\tdefer Close()\n\tresult := make(chan int, 5)\n\ttestDuration := time.Millisecond * 500\n\tm := New(lis)\n\tm.SetReadTimeout(testDuration)\n\thttp1 := m.Match(HTTP1Fast())\n\tany := m.Match(Any())\n\tgo func() {\n\t\t_ = m.Serve()\n\t}()\n\tgo func() {\n\t\tcon, err := http1.Accept()\n\t\tif err != nil {\n\t\t\tresult <- handleHTTP1Close\n\t\t} else {\n\t\t\t_, _ = con.Write([]byte(\"http1\"))\n\t\t\t_ = con.Close()\n\t\t\tresult <- handleHTTP1Request\n\t\t}\n\t}()\n\tgo func() {\n\t\tcon, err := any.Accept()\n\t\tif err != nil {\n\t\t\tresult <- handleAnyClose\n\t\t} else {\n\t\t\t_, _ = con.Write([]byte(\"any\"))\n\t\t\t_ = con.Close()\n\t\t\tresult <- handleAnyRequest\n\t\t}\n\t}()\n\ttime.Sleep(testDuration) // wait to prevent timeouts on slow test-runners\n\tclient, err := net.Dial(\"tcp\", lis.Addr().String())\n\tif err != nil {\n\t\tlog.Fatal(\"testTimeout client failed: \", err)\n\t}\n\tdefer func() {\n\t\t_ = client.Close()\n\t}()\n\ttime.Sleep(testDuration / 2)\n\tif len(result) != 0 {\n\t\tlog.Print(\"tcp \")\n\t\tt.Fatal(\"testTimeout failed: accepted to fast: \", len(result))\n\t}\n\t_ = client.SetReadDeadline(time.Now().Add(testDuration * 3))\n\tbuffer := make([]byte, 10)\n\trl, err := client.Read(buffer)\n\tif err != nil {\n\t\tt.Fatal(\"testTimeout failed: client error: \", err, rl)\n\t}\n\tClose()\n\tif rl != 3 {\n\t\tlog.Print(\"testTimeout failed: response from wrong sevice \", rl)\n\t}\n\tif string(buffer[0:3]) != \"any\" {\n\t\tlog.Print(\"testTimeout failed: response from wrong sevice \")\n\t}\n\ttime.Sleep(testDuration * 2)\n\tif len(result) != 2 {\n\t\tt.Fatal(\"testTimeout failed: accepted to less: \", len(result))\n\t}\n\tif a := <-result; a != handleAnyRequest {\n\t\tt.Fatal(\"testTimeout failed: any rule did not match\")\n\t}\n\tif a := <-result; a != handleHTTP1Close {\n\t\tt.Fatal(\"testTimeout failed: no close an http rule\")\n\t}\n}\n\nfunc TestRead(t *testing.T) {\n\tdefer leakCheck(t)()\n\terrCh := make(chan error)\n\tdefer func() {\n\t\tselect {\n\t\tcase err := <-errCh:\n\t\t\tt.Fatal(err)\n\t\tdefault:\n\t\t}\n\t}()\n\tconst payload = \"hello world\\r\\n\"\n\tconst mult = 2\n\n\twriter, reader := net.Pipe()\n\tgo func() {\n\t\tif _, err := io.WriteString(writer, strings.Repeat(payload, mult)); err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tif err := writer.Close(); err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t}()\n\n\tl := newChanListener()\n\tdefer close(l.connCh)\n\tl.connCh <- reader\n\tmuxl := New(l)\n\t// Register a bogus matcher to force buffering exactly the right amount.\n\t// Before this fix, this would trigger a bug where `Read` would incorrectly\n\t// report `io.EOF` when only the buffer had been consumed.\n\tmuxl.Match(func(r io.Reader) bool {\n\t\tvar b [len(payload)]byte\n\t\t_, _ = r.Read(b[:])\n\t\treturn false\n\t})\n\tanyl := muxl.Match(Any())\n\tgo safeServe(errCh, muxl)\n\tmuxedConn, err := anyl.Accept()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tfor i := 0; i < mult; i++ {\n\t\tvar b [len(payload)]byte\n\t\tn, err := muxedConn.Read(b[:])\n\t\tif err != nil {\n\t\t\tt.Error(err)\n\t\t\tcontinue\n\t\t}\n\t\tif e := len(b); n != e {\n\t\t\tt.Errorf(\"expected to read %d bytes, but read %d bytes\", e, n)\n\t\t}\n\t}\n\tvar b [1]byte\n\tif _, err := muxedConn.Read(b[:]); err != io.EOF {\n\t\tt.Errorf(\"unexpected error %v, expected %v\", err, io.EOF)\n\t}\n}\n\nfunc TestAny(t *testing.T) {\n\tdefer leakCheck(t)()\n\terrCh := make(chan error)\n\tdefer func() {\n\t\tselect {\n\t\tcase err := <-errCh:\n\t\t\tt.Fatal(err)\n\t\tdefault:\n\t\t}\n\t}()\n\tl, cleanup := testListener(t)\n\tdefer cleanup()\n\n\tmuxl := New(l)\n\thttpl := muxl.Match(Any())\n\n\tgo runTestHTTPServer(errCh, httpl)\n\tgo safeServe(errCh, muxl)\n\n\trunTestHTTP1Client(t, l.Addr())\n}\n\nfunc TestTLS(t *testing.T) {\n\tgenerateTLSCert(t)\n\tdefer cleanupTLSCert(t)\n\tdefer leakCheck(t)()\n\terrCh := make(chan error)\n\tdefer func() {\n\t\tselect {\n\t\tcase err := <-errCh:\n\t\t\tt.Fatal(err)\n\t\tdefault:\n\t\t}\n\t}()\n\tl, cleanup := testListener(t)\n\tdefer cleanup()\n\n\tmuxl := New(l)\n\ttlsl := muxl.Match(TLS())\n\thttpl := muxl.Match(Any())\n\n\tgo runTestTLSServer(errCh, tlsl)\n\tgo runTestHTTPServer(errCh, httpl)\n\tgo safeServe(errCh, muxl)\n\n\trunTestHTTP1Client(t, l.Addr())\n\trunTestTLSClient(t, l.Addr())\n}\n\nfunc TestHTTP2(t *testing.T) {\n\tdefer leakCheck(t)()\n\terrCh := make(chan error)\n\tdefer func() {\n\t\tselect {\n\t\tcase err := <-errCh:\n\t\t\tt.Fatal(err)\n\t\tdefault:\n\t\t}\n\t}()\n\twriter, reader := net.Pipe()\n\tgo func() {\n\t\tif _, err := io.WriteString(writer, http2.ClientPreface); err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tif err := writer.Close(); err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t}()\n\n\tl := newChanListener()\n\tl.connCh <- reader\n\tmuxl := New(l)\n\t// Register a bogus matcher that only reads one byte.\n\tmuxl.Match(func(r io.Reader) bool {\n\t\tvar b [1]byte\n\t\t_, _ = r.Read(b[:])\n\t\treturn false\n\t})\n\th2l := muxl.Match(HTTP2())\n\tgo safeServe(errCh, muxl)\n\tmuxedConn, err := h2l.Accept()\n\tclose(l.connCh)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tvar b [len(http2.ClientPreface)]byte\n\tvar n int\n\t// We have the sniffed buffer first...\n\tif n, err = muxedConn.Read(b[:]); err == io.EOF {\n\t\tt.Fatal(err)\n\t}\n\t// and then we read from the source.\n\tif _, err = muxedConn.Read(b[n:]); err != io.EOF {\n\t\tt.Fatal(err)\n\t}\n\tif string(b[:]) != http2.ClientPreface {\n\t\tt.Errorf(\"got unexpected read %s, expected %s\", b, http2.ClientPreface)\n\t}\n}\n\nfunc TestHTTP2MatchHeaderField(t *testing.T) {\n\ttestHTTP2MatchHeaderField(t, HTTP2HeaderField, \"value\", \"value\", \"anothervalue\")\n}\n\nfunc TestHTTP2MatchHeaderFieldPrefix(t *testing.T) {\n\ttestHTTP2MatchHeaderField(t, HTTP2HeaderFieldPrefix, \"application/grpc+proto\", \"application/grpc\", \"application/json\")\n}\n\nfunc testHTTP2MatchHeaderField(\n\tt *testing.T,\n\tmatcherConstructor func(string, string) Matcher,\n\theaderValue string,\n\tmatchValue string,\n\tnotMatchValue string,\n) {\n\tdefer leakCheck(t)()\n\terrCh := make(chan error)\n\tdefer func() {\n\t\tselect {\n\t\tcase err := <-errCh:\n\t\t\tt.Fatal(err)\n\t\tdefault:\n\t\t}\n\t}()\n\tname := \"name\"\n\twriter, reader := net.Pipe()\n\tgo func() {\n\t\tif _, err := io.WriteString(writer, http2.ClientPreface); err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tvar buf bytes.Buffer\n\t\tenc := hpack.NewEncoder(&buf)\n\t\tif err := enc.WriteField(hpack.HeaderField{Name: name, Value: headerValue}); err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tframer := http2.NewFramer(writer, nil)\n\t\terr := framer.WriteHeaders(http2.HeadersFrameParam{\n\t\t\tStreamID:      1,\n\t\t\tBlockFragment: buf.Bytes(),\n\t\t\tEndStream:     true,\n\t\t\tEndHeaders:    true,\n\t\t})\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tif err := writer.Close(); err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t}()\n\n\tl := newChanListener()\n\tl.connCh <- reader\n\tmuxl := New(l)\n\t// Register a bogus matcher that only reads one byte.\n\tmuxl.Match(func(r io.Reader) bool {\n\t\tvar b [1]byte\n\t\t_, _ = r.Read(b[:])\n\t\treturn false\n\t})\n\t// Create a matcher that cannot match the response.\n\tmuxl.Match(matcherConstructor(name, notMatchValue))\n\t// Then match with the expected field.\n\th2l := muxl.Match(matcherConstructor(name, matchValue))\n\tgo safeServe(errCh, muxl)\n\tmuxedConn, err := h2l.Accept()\n\tclose(l.connCh)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tvar b [len(http2.ClientPreface)]byte\n\t// We have the sniffed buffer first...\n\tif _, err := muxedConn.Read(b[:]); err == io.EOF {\n\t\tt.Fatal(err)\n\t}\n\tif string(b[:]) != http2.ClientPreface {\n\t\tt.Errorf(\"got unexpected read %s, expected %s\", b, http2.ClientPreface)\n\t}\n}\n\nfunc TestHTTPGoRPC(t *testing.T) {\n\tdefer leakCheck(t)()\n\terrCh := make(chan error)\n\tdefer func() {\n\t\tselect {\n\t\tcase err := <-errCh:\n\t\t\tt.Fatal(err)\n\t\tdefault:\n\t\t}\n\t}()\n\tl, cleanup := testListener(t)\n\tdefer cleanup()\n\n\tmuxl := New(l)\n\thttpl := muxl.Match(HTTP2(), HTTP1Fast())\n\trpcl := muxl.Match(Any())\n\n\tgo runTestHTTPServer(errCh, httpl)\n\tgo runTestRPCServer(errCh, rpcl)\n\tgo safeServe(errCh, muxl)\n\n\trunTestHTTP1Client(t, l.Addr())\n\trunTestRPCClient(t, l.Addr())\n}\n\nfunc TestErrorHandler(t *testing.T) {\n\tdefer leakCheck(t)()\n\terrCh := make(chan error)\n\tdefer func() {\n\t\tselect {\n\t\tcase err := <-errCh:\n\t\t\tt.Fatal(err)\n\t\tdefault:\n\t\t}\n\t}()\n\tl, cleanup := testListener(t)\n\tdefer cleanup()\n\n\tmuxl := New(l)\n\thttpl := muxl.Match(HTTP2(), HTTP1Fast())\n\n\tgo runTestHTTPServer(errCh, httpl)\n\tgo safeServe(errCh, muxl)\n\n\tvar errCount uint32\n\tmuxl.HandleError(func(err error) bool {\n\t\tif atomic.AddUint32(&errCount, 1) == 1 {\n\t\t\tif _, ok := err.(ErrNotMatched); !ok {\n\t\t\t\tt.Errorf(\"unexpected error: %v\", err)\n\t\t\t}\n\t\t}\n\t\treturn true\n\t})\n\n\tc, cleanup := safeDial(t, l.Addr())\n\tdefer cleanup()\n\n\tvar num int\n\tfor atomic.LoadUint32(&errCount) == 0 {\n\t\tif err := c.Call(\"TestRPCRcvr.Test\", rpcVal, &num); err == nil {\n\t\t\t// The connection is simply closed.\n\t\t\tt.Errorf(\"unexpected rpc success after %d errors\", atomic.LoadUint32(&errCount))\n\t\t}\n\t}\n}\n\nfunc TestMultipleMatchers(t *testing.T) {\n\tdefer leakCheck(t)()\n\terrCh := make(chan error)\n\tdefer func() {\n\t\tselect {\n\t\tcase err := <-errCh:\n\t\t\tt.Fatal(err)\n\t\tdefault:\n\t\t}\n\t}()\n\tl, cleanup := testListener(t)\n\tdefer cleanup()\n\n\tmatcher := func(r io.Reader) bool {\n\t\treturn true\n\t}\n\tunmatcher := func(r io.Reader) bool {\n\t\treturn false\n\t}\n\n\tmuxl := New(l)\n\tlis := muxl.Match(unmatcher, matcher, unmatcher)\n\n\tgo runTestHTTPServer(errCh, lis)\n\tgo safeServe(errCh, muxl)\n\n\trunTestHTTP1Client(t, l.Addr())\n}\n\nfunc TestListenerClose(t *testing.T) {\n\tdefer leakCheck(t)()\n\terrCh := make(chan error)\n\tdefer func() {\n\t\tselect {\n\t\tcase err := <-errCh:\n\t\t\tt.Fatal(err)\n\t\tdefault:\n\t\t}\n\t}()\n\tl := newChanListener()\n\n\tc1, c2 := net.Pipe()\n\n\tmuxl := New(l)\n\tanyl := muxl.Match(Any())\n\n\tgo safeServe(errCh, muxl)\n\n\tl.connCh <- c1\n\n\t// First connection goes through.\n\tif _, err := anyl.Accept(); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t// Second connection is sent\n\tl.connCh <- c2\n\n\t// Listener is closed.\n\tclose(l.connCh)\n\n\t// Second connection either goes through or it is closed.\n\tif _, err := anyl.Accept(); err != nil {\n\t\tif err != ErrListenerClosed && err != ErrServerClosed {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\t// The error is either io.ErrClosedPipe or net.OpError wrapping\n\t\t// a net.pipeError depending on the go version.\n\t\tif _, err := c2.Read([]byte{}); !strings.Contains(err.Error(), \"closed\") {\n\t\t\tt.Fatalf(\"connection is not closed and is leaked: %v\", err)\n\t\t}\n\t}\n}\n\nfunc TestClose(t *testing.T) {\n\tdefer leakCheck(t)()\n\terrCh := make(chan error)\n\tdefer func() {\n\t\tselect {\n\t\tcase err := <-errCh:\n\t\t\tt.Fatal(err)\n\t\tdefault:\n\t\t}\n\t}()\n\tl, cleanup := testListener(t)\n\tdefer cleanup()\n\n\tmuxl := New(l)\n\tanyl := muxl.Match(Any())\n\n\tgo safeServe(errCh, muxl)\n\n\tmuxl.Close()\n\n\tif _, err := anyl.Accept(); err != ErrServerClosed {\n\t\tt.Fatal(err)\n\t}\n}\n\n// Cribbed from google.golang.org/grpc/test/end2end_test.go.\n\n// interestingGoroutines returns all goroutines we care about for the purpose\n// of leak checking. It excludes testing or runtime ones.\nfunc interestingGoroutines() (gs []string) {\n\tbuf := make([]byte, 2<<20)\n\tbuf = buf[:runtime.Stack(buf, true)]\n\tfor _, g := range strings.Split(string(buf), \"\\n\\n\") {\n\t\tsl := strings.SplitN(g, \"\\n\", 2)\n\t\tif len(sl) != 2 {\n\t\t\tcontinue\n\t\t}\n\t\tstack := strings.TrimSpace(sl[1])\n\t\tif strings.HasPrefix(stack, \"testing.RunTests\") {\n\t\t\tcontinue\n\t\t}\n\n\t\tif stack == \"\" ||\n\t\t\tstrings.Contains(stack, \"main.main()\") ||\n\t\t\tstrings.Contains(stack, \"testing.Main(\") ||\n\t\t\tstrings.Contains(stack, \"runtime.goexit\") ||\n\t\t\tstrings.Contains(stack, \"created by runtime.gc\") ||\n\t\t\tstrings.Contains(stack, \"interestingGoroutines\") ||\n\t\t\tstrings.Contains(stack, \"runtime.MHeap_Scavenger\") {\n\t\t\tcontinue\n\t\t}\n\t\tgs = append(gs, g)\n\t}\n\tsort.Strings(gs)\n\treturn\n}\n\n// leakCheck snapshots the currently-running goroutines and returns a\n// function to be run at the end of tests to see whether any\n// goroutines leaked.\nfunc leakCheck(t testing.TB) func() {\n\torig := map[string]bool{}\n\tfor _, g := range interestingGoroutines() {\n\t\torig[g] = true\n\t}\n\treturn func() {\n\t\t// Loop, waiting for goroutines to shut down.\n\t\t// Wait up to 5 seconds, but finish as quickly as possible.\n\t\tdeadline := time.Now().Add(5 * time.Second)\n\t\tfor {\n\t\t\tvar leaked []string\n\t\t\tfor _, g := range interestingGoroutines() {\n\t\t\t\tif !orig[g] {\n\t\t\t\t\tleaked = append(leaked, g)\n\t\t\t\t}\n\t\t\t}\n\t\t\tif len(leaked) == 0 {\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif time.Now().Before(deadline) {\n\t\t\t\ttime.Sleep(50 * time.Millisecond)\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tfor _, g := range leaked {\n\t\t\t\tt.Errorf(\"Leaked goroutine: %v\", g)\n\t\t\t}\n\t\t\treturn\n\t\t}\n\t}\n}\n"
        },
        {
          "name": "doc.go",
          "type": "blob",
          "size": 0.7724609375,
          "content": "// Copyright 2016 The CMux Authors. All rights reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied. See the License for the specific language governing\n// permissions and limitations under the License.\n\n// Package cmux is a library to multiplex network connections based on\n// their payload. Using cmux, you can serve different protocols from the\n// same listener.\npackage cmux\n"
        },
        {
          "name": "example",
          "type": "tree",
          "content": null
        },
        {
          "name": "go.mod",
          "type": "blob",
          "size": 0.099609375,
          "content": "module github.com/soheilhy/cmux\n\ngo 1.11\n\nrequire golang.org/x/net v0.0.0-20201202161906-c7110b5ffcbb\n"
        },
        {
          "name": "go.sum",
          "type": "blob",
          "size": 1.1689453125,
          "content": "golang.org/x/crypto v0.0.0-20190308221718-c2843e01d9a2/go.mod h1:djNgcEr1/C05ACkg1iLfiJU5Ep61QUkGW8qpdssI0+w=\ngolang.org/x/crypto v0.0.0-20200622213623-75b288015ac9/go.mod h1:LzIPMQfyMNhhGPhUkYOs5KpL4U8rLKemX1yGLhDgUto=\ngolang.org/x/net v0.0.0-20190404232315-eb5bcb51f2a3/go.mod h1:t9HGtf8HONx5eT2rtn7q6eTqICYqUVnKs3thJo3Qplg=\ngolang.org/x/net v0.0.0-20201202161906-c7110b5ffcbb h1:eBmm0M9fYhWpKZLjQUUKka/LtIxf46G4fxeEz5KJr9U=\ngolang.org/x/net v0.0.0-20201202161906-c7110b5ffcbb/go.mod h1:sp8m0HH+o8qH0wwXwYZr8TS3Oi6o0r6Gce1SSxlDquU=\ngolang.org/x/sys v0.0.0-20190215142949-d0b11bdaac8a/go.mod h1:STP8DvDyc/dI5b8T5hshtkjS+E42TnysNCUPdjciGhY=\ngolang.org/x/sys v0.0.0-20190412213103-97732733099d/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20200930185726-fdedc70b468f/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/text v0.3.0/go.mod h1:NqM8EUOU14njkJ3fqMW+pc6Ldnwhi/IjpwHt7yyuwOQ=\ngolang.org/x/text v0.3.3 h1:cokOdA+Jmi5PJGXLlLllQSgYigAEfHXJAERHVMaCc2k=\ngolang.org/x/text v0.3.3/go.mod h1:5Zoc/QRtKVWzQhOtBMvqHzDpF6irO9z98xDceosuGiQ=\ngolang.org/x/tools v0.0.0-20180917221912-90fa682c2a6e/go.mod h1:n7NCudcB/nEzxVGmLbDWY5pfWTLqBcC2KZ6jyYvM4mQ=\n"
        },
        {
          "name": "matchers.go",
          "type": "blob",
          "size": 7.0556640625,
          "content": "// Copyright 2016 The CMux Authors. All rights reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied. See the License for the specific language governing\n// permissions and limitations under the License.\n\npackage cmux\n\nimport (\n\t\"bufio\"\n\t\"crypto/tls\"\n\t\"io\"\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"strings\"\n\n\t\"golang.org/x/net/http2\"\n\t\"golang.org/x/net/http2/hpack\"\n)\n\n// Any is a Matcher that matches any connection.\nfunc Any() Matcher {\n\treturn func(r io.Reader) bool { return true }\n}\n\n// PrefixMatcher returns a matcher that matches a connection if it\n// starts with any of the strings in strs.\nfunc PrefixMatcher(strs ...string) Matcher {\n\tpt := newPatriciaTreeString(strs...)\n\treturn pt.matchPrefix\n}\n\nfunc prefixByteMatcher(list ...[]byte) Matcher {\n\tpt := newPatriciaTree(list...)\n\treturn pt.matchPrefix\n}\n\nvar defaultHTTPMethods = []string{\n\t\"OPTIONS\",\n\t\"GET\",\n\t\"HEAD\",\n\t\"POST\",\n\t\"PUT\",\n\t\"DELETE\",\n\t\"TRACE\",\n\t\"CONNECT\",\n}\n\n// HTTP1Fast only matches the methods in the HTTP request.\n//\n// This matcher is very optimistic: if it returns true, it does not mean that\n// the request is a valid HTTP response. If you want a correct but slower HTTP1\n// matcher, use HTTP1 instead.\nfunc HTTP1Fast(extMethods ...string) Matcher {\n\treturn PrefixMatcher(append(defaultHTTPMethods, extMethods...)...)\n}\n\n// TLS matches HTTPS requests.\n//\n// By default, any TLS handshake packet is matched. An optional whitelist\n// of versions can be passed in to restrict the matcher, for example:\n//  TLS(tls.VersionTLS11, tls.VersionTLS12)\nfunc TLS(versions ...int) Matcher {\n\tif len(versions) == 0 {\n\t\tversions = []int{\n\t\t\ttls.VersionSSL30,\n\t\t\ttls.VersionTLS10,\n\t\t\ttls.VersionTLS11,\n\t\t\ttls.VersionTLS12,\n\t\t}\n\t}\n\tprefixes := [][]byte{}\n\tfor _, v := range versions {\n\t\tprefixes = append(prefixes, []byte{22, byte(v >> 8 & 0xff), byte(v & 0xff)})\n\t}\n\treturn prefixByteMatcher(prefixes...)\n}\n\nconst maxHTTPRead = 4096\n\n// HTTP1 parses the first line or upto 4096 bytes of the request to see if\n// the conection contains an HTTP request.\nfunc HTTP1() Matcher {\n\treturn func(r io.Reader) bool {\n\t\tbr := bufio.NewReader(&io.LimitedReader{R: r, N: maxHTTPRead})\n\t\tl, part, err := br.ReadLine()\n\t\tif err != nil || part {\n\t\t\treturn false\n\t\t}\n\n\t\t_, _, proto, ok := parseRequestLine(string(l))\n\t\tif !ok {\n\t\t\treturn false\n\t\t}\n\n\t\tv, _, ok := http.ParseHTTPVersion(proto)\n\t\treturn ok && v == 1\n\t}\n}\n\n// grabbed from net/http.\nfunc parseRequestLine(line string) (method, uri, proto string, ok bool) {\n\ts1 := strings.Index(line, \" \")\n\ts2 := strings.Index(line[s1+1:], \" \")\n\tif s1 < 0 || s2 < 0 {\n\t\treturn\n\t}\n\ts2 += s1 + 1\n\treturn line[:s1], line[s1+1 : s2], line[s2+1:], true\n}\n\n// HTTP2 parses the frame header of the first frame to detect whether the\n// connection is an HTTP2 connection.\nfunc HTTP2() Matcher {\n\treturn hasHTTP2Preface\n}\n\n// HTTP1HeaderField returns a matcher matching the header fields of the first\n// request of an HTTP 1 connection.\nfunc HTTP1HeaderField(name, value string) Matcher {\n\treturn func(r io.Reader) bool {\n\t\treturn matchHTTP1Field(r, name, func(gotValue string) bool {\n\t\t\treturn gotValue == value\n\t\t})\n\t}\n}\n\n// HTTP1HeaderFieldPrefix returns a matcher matching the header fields of the\n// first request of an HTTP 1 connection. If the header with key name has a\n// value prefixed with valuePrefix, this will match.\nfunc HTTP1HeaderFieldPrefix(name, valuePrefix string) Matcher {\n\treturn func(r io.Reader) bool {\n\t\treturn matchHTTP1Field(r, name, func(gotValue string) bool {\n\t\t\treturn strings.HasPrefix(gotValue, valuePrefix)\n\t\t})\n\t}\n}\n\n// HTTP2HeaderField returns a matcher matching the header fields of the first\n// headers frame.\nfunc HTTP2HeaderField(name, value string) Matcher {\n\treturn func(r io.Reader) bool {\n\t\treturn matchHTTP2Field(ioutil.Discard, r, name, func(gotValue string) bool {\n\t\t\treturn gotValue == value\n\t\t})\n\t}\n}\n\n// HTTP2HeaderFieldPrefix returns a matcher matching the header fields of the\n// first headers frame. If the header with key name has a value prefixed with\n// valuePrefix, this will match.\nfunc HTTP2HeaderFieldPrefix(name, valuePrefix string) Matcher {\n\treturn func(r io.Reader) bool {\n\t\treturn matchHTTP2Field(ioutil.Discard, r, name, func(gotValue string) bool {\n\t\t\treturn strings.HasPrefix(gotValue, valuePrefix)\n\t\t})\n\t}\n}\n\n// HTTP2MatchHeaderFieldSendSettings matches the header field and writes the\n// settings to the server. Prefer HTTP2HeaderField over this one, if the client\n// does not block on receiving a SETTING frame.\nfunc HTTP2MatchHeaderFieldSendSettings(name, value string) MatchWriter {\n\treturn func(w io.Writer, r io.Reader) bool {\n\t\treturn matchHTTP2Field(w, r, name, func(gotValue string) bool {\n\t\t\treturn gotValue == value\n\t\t})\n\t}\n}\n\n// HTTP2MatchHeaderFieldPrefixSendSettings matches the header field prefix\n// and writes the settings to the server. Prefer HTTP2HeaderFieldPrefix over\n// this one, if the client does not block on receiving a SETTING frame.\nfunc HTTP2MatchHeaderFieldPrefixSendSettings(name, valuePrefix string) MatchWriter {\n\treturn func(w io.Writer, r io.Reader) bool {\n\t\treturn matchHTTP2Field(w, r, name, func(gotValue string) bool {\n\t\t\treturn strings.HasPrefix(gotValue, valuePrefix)\n\t\t})\n\t}\n}\n\nfunc hasHTTP2Preface(r io.Reader) bool {\n\tvar b [len(http2.ClientPreface)]byte\n\tlast := 0\n\n\tfor {\n\t\tn, err := r.Read(b[last:])\n\t\tif err != nil {\n\t\t\treturn false\n\t\t}\n\n\t\tlast += n\n\t\teq := string(b[:last]) == http2.ClientPreface[:last]\n\t\tif last == len(http2.ClientPreface) {\n\t\t\treturn eq\n\t\t}\n\t\tif !eq {\n\t\t\treturn false\n\t\t}\n\t}\n}\n\nfunc matchHTTP1Field(r io.Reader, name string, matches func(string) bool) (matched bool) {\n\treq, err := http.ReadRequest(bufio.NewReader(r))\n\tif err != nil {\n\t\treturn false\n\t}\n\n\treturn matches(req.Header.Get(name))\n}\n\nfunc matchHTTP2Field(w io.Writer, r io.Reader, name string, matches func(string) bool) (matched bool) {\n\tif !hasHTTP2Preface(r) {\n\t\treturn false\n\t}\n\n\tdone := false\n\tframer := http2.NewFramer(w, r)\n\thdec := hpack.NewDecoder(uint32(4<<10), func(hf hpack.HeaderField) {\n\t\tif hf.Name == name {\n\t\t\tdone = true\n\t\t\tif matches(hf.Value) {\n\t\t\t\tmatched = true\n\t\t\t}\n\t\t}\n\t})\n\tfor {\n\t\tf, err := framer.ReadFrame()\n\t\tif err != nil {\n\t\t\treturn false\n\t\t}\n\n\t\tswitch f := f.(type) {\n\t\tcase *http2.SettingsFrame:\n\t\t\t// Sender acknoweldged the SETTINGS frame. No need to write\n\t\t\t// SETTINGS again.\n\t\t\tif f.IsAck() {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tif err := framer.WriteSettings(); err != nil {\n\t\t\t\treturn false\n\t\t\t}\n\t\tcase *http2.ContinuationFrame:\n\t\t\tif _, err := hdec.Write(f.HeaderBlockFragment()); err != nil {\n\t\t\t\treturn false\n\t\t\t}\n\t\t\tdone = done || f.FrameHeader.Flags&http2.FlagHeadersEndHeaders != 0\n\t\tcase *http2.HeadersFrame:\n\t\t\tif _, err := hdec.Write(f.HeaderBlockFragment()); err != nil {\n\t\t\t\treturn false\n\t\t\t}\n\t\t\tdone = done || f.FrameHeader.Flags&http2.FlagHeadersEndHeaders != 0\n\t\t}\n\n\t\tif done {\n\t\t\treturn matched\n\t\t}\n\t}\n}\n"
        },
        {
          "name": "patricia.go",
          "type": "blob",
          "size": 3.1591796875,
          "content": "// Copyright 2016 The CMux Authors. All rights reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied. See the License for the specific language governing\n// permissions and limitations under the License.\n\npackage cmux\n\nimport (\n\t\"bytes\"\n\t\"io\"\n)\n\n// patriciaTree is a simple patricia tree that handles []byte instead of string\n// and cannot be changed after instantiation.\ntype patriciaTree struct {\n\troot     *ptNode\n\tmaxDepth int // max depth of the tree.\n}\n\nfunc newPatriciaTree(bs ...[]byte) *patriciaTree {\n\tmax := 0\n\tfor _, b := range bs {\n\t\tif max < len(b) {\n\t\t\tmax = len(b)\n\t\t}\n\t}\n\treturn &patriciaTree{\n\t\troot:     newNode(bs),\n\t\tmaxDepth: max + 1,\n\t}\n}\n\nfunc newPatriciaTreeString(strs ...string) *patriciaTree {\n\tb := make([][]byte, len(strs))\n\tfor i, s := range strs {\n\t\tb[i] = []byte(s)\n\t}\n\treturn newPatriciaTree(b...)\n}\n\nfunc (t *patriciaTree) matchPrefix(r io.Reader) bool {\n\tbuf := make([]byte, t.maxDepth)\n\tn, _ := io.ReadFull(r, buf)\n\treturn t.root.match(buf[:n], true)\n}\n\nfunc (t *patriciaTree) match(r io.Reader) bool {\n\tbuf := make([]byte, t.maxDepth)\n\tn, _ := io.ReadFull(r, buf)\n\treturn t.root.match(buf[:n], false)\n}\n\ntype ptNode struct {\n\tprefix   []byte\n\tnext     map[byte]*ptNode\n\tterminal bool\n}\n\nfunc newNode(strs [][]byte) *ptNode {\n\tif len(strs) == 0 {\n\t\treturn &ptNode{\n\t\t\tprefix:   []byte{},\n\t\t\tterminal: true,\n\t\t}\n\t}\n\n\tif len(strs) == 1 {\n\t\treturn &ptNode{\n\t\t\tprefix:   strs[0],\n\t\t\tterminal: true,\n\t\t}\n\t}\n\n\tp, strs := splitPrefix(strs)\n\tn := &ptNode{\n\t\tprefix: p,\n\t}\n\n\tnexts := make(map[byte][][]byte)\n\tfor _, s := range strs {\n\t\tif len(s) == 0 {\n\t\t\tn.terminal = true\n\t\t\tcontinue\n\t\t}\n\t\tnexts[s[0]] = append(nexts[s[0]], s[1:])\n\t}\n\n\tn.next = make(map[byte]*ptNode)\n\tfor first, rests := range nexts {\n\t\tn.next[first] = newNode(rests)\n\t}\n\n\treturn n\n}\n\nfunc splitPrefix(bss [][]byte) (prefix []byte, rest [][]byte) {\n\tif len(bss) == 0 || len(bss[0]) == 0 {\n\t\treturn prefix, bss\n\t}\n\n\tif len(bss) == 1 {\n\t\treturn bss[0], [][]byte{{}}\n\t}\n\n\tfor i := 0; ; i++ {\n\t\tvar cur byte\n\t\teq := true\n\t\tfor j, b := range bss {\n\t\t\tif len(b) <= i {\n\t\t\t\teq = false\n\t\t\t\tbreak\n\t\t\t}\n\n\t\t\tif j == 0 {\n\t\t\t\tcur = b[i]\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tif cur != b[i] {\n\t\t\t\teq = false\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\n\t\tif !eq {\n\t\t\tbreak\n\t\t}\n\n\t\tprefix = append(prefix, cur)\n\t}\n\n\trest = make([][]byte, 0, len(bss))\n\tfor _, b := range bss {\n\t\trest = append(rest, b[len(prefix):])\n\t}\n\n\treturn prefix, rest\n}\n\nfunc (n *ptNode) match(b []byte, prefix bool) bool {\n\tl := len(n.prefix)\n\tif l > 0 {\n\t\tif l > len(b) {\n\t\t\tl = len(b)\n\t\t}\n\t\tif !bytes.Equal(b[:l], n.prefix) {\n\t\t\treturn false\n\t\t}\n\t}\n\n\tif n.terminal && (prefix || len(n.prefix) == len(b)) {\n\t\treturn true\n\t}\n\n\tif l >= len(b) {\n\t\treturn false\n\t}\n\n\tnextN, ok := n.next[b[l]]\n\tif !ok {\n\t\treturn false\n\t}\n\n\tif l == len(b) {\n\t\tb = b[l:l]\n\t} else {\n\t\tb = b[l+1:]\n\t}\n\treturn nextN.match(b, prefix)\n}\n"
        },
        {
          "name": "patricia_test.go",
          "type": "blob",
          "size": 1.5869140625,
          "content": "// Copyright 2016 The CMux Authors. All rights reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied. See the License for the specific language governing\n// permissions and limitations under the License.\n\npackage cmux\n\nimport (\n\t\"strings\"\n\t\"testing\"\n)\n\nfunc testPTree(t *testing.T, strs ...string) {\n\tpt := newPatriciaTreeString(strs...)\n\tfor _, s := range strs {\n\t\tif !pt.match(strings.NewReader(s)) {\n\t\t\tt.Errorf(\"%s is not matched by %s\", s, s)\n\t\t}\n\n\t\tif !pt.matchPrefix(strings.NewReader(s + s)) {\n\t\t\tt.Errorf(\"%s is not matched as a prefix by %s\", s+s, s)\n\t\t}\n\n\t\tif pt.match(strings.NewReader(s + s)) {\n\t\t\tt.Errorf(\"%s matches %s\", s+s, s)\n\t\t}\n\n\t\t// The following tests are just to catch index out of\n\t\t// range and off-by-one errors and not the functionality.\n\t\tpt.matchPrefix(strings.NewReader(s[:len(s)-1]))\n\t\tpt.match(strings.NewReader(s[:len(s)-1]))\n\t\tpt.matchPrefix(strings.NewReader(s + \"$\"))\n\t\tpt.match(strings.NewReader(s + \"$\"))\n\t}\n}\n\nfunc TestPatriciaOnePrefix(t *testing.T) {\n\ttestPTree(t, \"prefix\")\n}\n\nfunc TestPatriciaNonOverlapping(t *testing.T) {\n\ttestPTree(t, \"foo\", \"bar\", \"dummy\")\n}\n\nfunc TestPatriciaOverlapping(t *testing.T) {\n\ttestPTree(t, \"foo\", \"far\", \"farther\", \"boo\", \"ba\", \"bar\")\n}\n"
        }
      ]
    }
  ]
}