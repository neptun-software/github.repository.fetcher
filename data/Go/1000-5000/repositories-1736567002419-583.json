{
  "metadata": {
    "timestamp": 1736567002419,
    "page": 583,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjU5MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "darccio/mergo",
      "stars": 2913,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".deepsource.toml",
          "type": "blob",
          "size": 0.138671875,
          "content": "version = 1\n\ntest_patterns = [\n  \"*_test.go\"\n]\n\n[[analyzers]]\nname = \"go\"\nenabled = true\n\n  [analyzers.meta]\n  import_path = \"dario.cat/mergo\""
        },
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.5048828125,
          "content": "#### joe made this: http://goel.io/joe\n\n#### go ####\n# Binaries for programs and plugins\n*.exe\n*.dll\n*.so\n*.dylib\n\n# Test binary, build with `go test -c`\n*.test\n\n# Output of the go coverage tool, specifically when used with LiteIDE\n*.out\n\n# Golang/Intellij\n.idea\n\n# Project-local glide cache, RE: https://github.com/Masterminds/glide/issues/736\n.glide/\n\n#### vim ####\n# Swap\n[._]*.s[a-v][a-z]\n[._]*.sw[a-p]\n[._]s[a-v][a-z]\n[._]sw[a-p]\n\n# Session\nSession.vim\n\n# Temporary\n.netrwhist\n*~\n# Auto-generated tag files\ntags\n"
        },
        {
          "name": ".travis.yml",
          "type": "blob",
          "size": 0.2666015625,
          "content": "language: go\narch:\n    - amd64\n    - ppc64le\ninstall:\n  - go get -t\n  - go get golang.org/x/tools/cmd/cover\n  - go get github.com/mattn/goveralls\nscript:\n  - go test -race -v ./...\nafter_script:\n  - $HOME/gopath/bin/goveralls -service=travis-ci -repotoken $COVERALLS_TOKEN\n"
        },
        {
          "name": ".vscode",
          "type": "tree",
          "content": null
        },
        {
          "name": "CODE_OF_CONDUCT.md",
          "type": "blob",
          "size": 3.1318359375,
          "content": "# Contributor Covenant Code of Conduct\n\n## Our Pledge\n\nIn the interest of fostering an open and welcoming environment, we as contributors and maintainers pledge to making participation in our project and our community a harassment-free experience for everyone, regardless of age, body size, disability, ethnicity, gender identity and expression, level of experience, nationality, personal appearance, race, religion, or sexual identity and orientation.\n\n## Our Standards\n\nExamples of behavior that contributes to creating a positive environment include:\n\n* Using welcoming and inclusive language\n* Being respectful of differing viewpoints and experiences\n* Gracefully accepting constructive criticism\n* Focusing on what is best for the community\n* Showing empathy towards other community members\n\nExamples of unacceptable behavior by participants include:\n\n* The use of sexualized language or imagery and unwelcome sexual attention or advances\n* Trolling, insulting/derogatory comments, and personal or political attacks\n* Public or private harassment\n* Publishing others' private information, such as a physical or electronic address, without explicit permission\n* Other conduct which could reasonably be considered inappropriate in a professional setting\n\n## Our Responsibilities\n\nProject maintainers are responsible for clarifying the standards of acceptable behavior and are expected to take appropriate and fair corrective action in response to any instances of unacceptable behavior.\n\nProject maintainers have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, or to ban temporarily or permanently any contributor for other behaviors that they deem inappropriate, threatening, offensive, or harmful.\n\n## Scope\n\nThis Code of Conduct applies both within project spaces and in public spaces when an individual is representing the project or its community. Examples of representing a project or community include using an official project e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event. Representation of a project may be further defined and clarified by project maintainers.\n\n## Enforcement\n\nInstances of abusive, harassing, or otherwise unacceptable behavior may be reported by contacting the project team at i@dario.im. The project team will review and investigate all complaints, and will respond in a way that it deems appropriate to the circumstances. The project team is obligated to maintain confidentiality with regard to the reporter of an incident. Further details of specific enforcement policies may be posted separately.\n\nProject maintainers who do not follow or enforce the Code of Conduct in good faith may face temporary or permanent repercussions as determined by other members of the project's leadership.\n\n## Attribution\n\nThis Code of Conduct is adapted from the [Contributor Covenant][homepage], version 1.4, available at [http://contributor-covenant.org/version/1/4][version]\n\n[homepage]: http://contributor-covenant.org\n[version]: http://contributor-covenant.org/version/1/4/\n"
        },
        {
          "name": "CONTRIBUTING.md",
          "type": "blob",
          "size": 7.8828125,
          "content": "<!-- omit in toc -->\n# Contributing to mergo\n\nFirst off, thanks for taking the time to contribute! ❤️\n\nAll types of contributions are encouraged and valued. See the [Table of Contents](#table-of-contents) for different ways to help and details about how this project handles them. Please make sure to read the relevant section before making your contribution. It will make it a lot easier for us maintainers and smooth out the experience for all involved. The community looks forward to your contributions. 🎉\n\n> And if you like the project, but just don't have time to contribute, that's fine. There are other easy ways to support the project and show your appreciation, which we would also be very happy about:\n> - Star the project\n> - Tweet about it\n> - Refer this project in your project's readme\n> - Mention the project at local meetups and tell your friends/colleagues\n\n<!-- omit in toc -->\n## Table of Contents\n\n- [Code of Conduct](#code-of-conduct)\n- [I Have a Question](#i-have-a-question)\n- [I Want To Contribute](#i-want-to-contribute)\n- [Reporting Bugs](#reporting-bugs)\n- [Suggesting Enhancements](#suggesting-enhancements)\n\n## Code of Conduct\n\nThis project and everyone participating in it is governed by the\n[mergo Code of Conduct](https://github.com/imdario/mergoblob/master/CODE_OF_CONDUCT.md).\nBy participating, you are expected to uphold this code. Please report unacceptable behavior\nto <>.\n\n\n## I Have a Question\n\n> If you want to ask a question, we assume that you have read the available [Documentation](https://pkg.go.dev/github.com/imdario/mergo).\n\nBefore you ask a question, it is best to search for existing [Issues](https://github.com/imdario/mergo/issues) that might help you. In case you have found a suitable issue and still need clarification, you can write your question in this issue. It is also advisable to search the internet for answers first.\n\nIf you then still feel the need to ask a question and need clarification, we recommend the following:\n\n- Open an [Issue](https://github.com/imdario/mergo/issues/new).\n- Provide as much context as you can about what you're running into.\n- Provide project and platform versions (nodejs, npm, etc), depending on what seems relevant.\n\nWe will then take care of the issue as soon as possible.\n\n## I Want To Contribute\n\n> ### Legal Notice <!-- omit in toc -->\n> When contributing to this project, you must agree that you have authored 100% of the content, that you have the necessary rights to the content and that the content you contribute may be provided under the project license.\n\n### Reporting Bugs\n\n<!-- omit in toc -->\n#### Before Submitting a Bug Report\n\nA good bug report shouldn't leave others needing to chase you up for more information. Therefore, we ask you to investigate carefully, collect information and describe the issue in detail in your report. Please complete the following steps in advance to help us fix any potential bug as fast as possible.\n\n- Make sure that you are using the latest version.\n- Determine if your bug is really a bug and not an error on your side e.g. using incompatible environment components/versions (Make sure that you have read the [documentation](). If you are looking for support, you might want to check [this section](#i-have-a-question)).\n- To see if other users have experienced (and potentially already solved) the same issue you are having, check if there is not already a bug report existing for your bug or error in the [bug tracker](https://github.com/imdario/mergoissues?q=label%3Abug).\n- Also make sure to search the internet (including Stack Overflow) to see if users outside of the GitHub community have discussed the issue.\n- Collect information about the bug:\n- Stack trace (Traceback)\n- OS, Platform and Version (Windows, Linux, macOS, x86, ARM)\n- Version of the interpreter, compiler, SDK, runtime environment, package manager, depending on what seems relevant.\n- Possibly your input and the output\n- Can you reliably reproduce the issue? And can you also reproduce it with older versions?\n\n<!-- omit in toc -->\n#### How Do I Submit a Good Bug Report?\n\n> You must never report security related issues, vulnerabilities or bugs including sensitive information to the issue tracker, or elsewhere in public. Instead sensitive bugs must be sent by email to .\n<!-- You may add a PGP key to allow the messages to be sent encrypted as well. -->\n\nWe use GitHub issues to track bugs and errors. If you run into an issue with the project:\n\n- Open an [Issue](https://github.com/imdario/mergo/issues/new). (Since we can't be sure at this point whether it is a bug or not, we ask you not to talk about a bug yet and not to label the issue.)\n- Explain the behavior you would expect and the actual behavior.\n- Please provide as much context as possible and describe the *reproduction steps* that someone else can follow to recreate the issue on their own. This usually includes your code. For good bug reports you should isolate the problem and create a reduced test case.\n- Provide the information you collected in the previous section.\n\nOnce it's filed:\n\n- The project team will label the issue accordingly.\n- A team member will try to reproduce the issue with your provided steps. If there are no reproduction steps or no obvious way to reproduce the issue, the team will ask you for those steps and mark the issue as `needs-repro`. Bugs with the `needs-repro` tag will not be addressed until they are reproduced.\n- If the team is able to reproduce the issue, it will be marked `needs-fix`, as well as possibly other tags (such as `critical`), and the issue will be left to be implemented by someone.\n\n### Suggesting Enhancements\n\nThis section guides you through submitting an enhancement suggestion for mergo, **including completely new features and minor improvements to existing functionality**. Following these guidelines will help maintainers and the community to understand your suggestion and find related suggestions.\n\n<!-- omit in toc -->\n#### Before Submitting an Enhancement\n\n- Make sure that you are using the latest version.\n- Read the [documentation]() carefully and find out if the functionality is already covered, maybe by an individual configuration.\n- Perform a [search](https://github.com/imdario/mergo/issues) to see if the enhancement has already been suggested. If it has, add a comment to the existing issue instead of opening a new one.\n- Find out whether your idea fits with the scope and aims of the project. It's up to you to make a strong case to convince the project's developers of the merits of this feature. Keep in mind that we want features that will be useful to the majority of our users and not just a small subset. If you're just targeting a minority of users, consider writing an add-on/plugin library.\n\n<!-- omit in toc -->\n#### How Do I Submit a Good Enhancement Suggestion?\n\nEnhancement suggestions are tracked as [GitHub issues](https://github.com/imdario/mergo/issues).\n\n- Use a **clear and descriptive title** for the issue to identify the suggestion.\n- Provide a **step-by-step description of the suggested enhancement** in as many details as possible.\n- **Describe the current behavior** and **explain which behavior you expected to see instead** and why. At this point you can also tell which alternatives do not work for you.\n- You may want to **include screenshots and animated GIFs** which help you demonstrate the steps or point out the part which the suggestion is related to. You can use [this tool](https://www.cockos.com/licecap/) to record GIFs on macOS and Windows, and [this tool](https://github.com/colinkeenan/silentcast) or [this tool](https://github.com/GNOME/byzanz) on Linux. <!-- this should only be included if the project has a GUI -->\n- **Explain why this enhancement would be useful** to most mergo users. You may also want to point out the other projects that solved it better and which could serve as inspiration.\n\n<!-- omit in toc -->\n## Attribution\nThis guide is based on the **contributing-gen**. [Make your own](https://github.com/bttger/contributing-gen)!\n"
        },
        {
          "name": "FUNDING.json",
          "type": "blob",
          "size": 0.1044921875,
          "content": "{\n  \"drips\": {\n    \"ethereum\": {\n      \"ownedBy\": \"0x6160020e7102237aC41bdb156e94401692D76930\"\n    }\n  }\n}\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.5,
          "content": "Copyright (c) 2013 Dario Castañé. All rights reserved.\nCopyright (c) 2012 The Go Authors. All rights reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are\nmet:\n\n   * Redistributions of source code must retain the above copyright\nnotice, this list of conditions and the following disclaimer.\n   * Redistributions in binary form must reproduce the above\ncopyright notice, this list of conditions and the following disclaimer\nin the documentation and/or other materials provided with the\ndistribution.\n   * Neither the name of Google Inc. nor the names of its\ncontributors may be used to endorse or promote products derived from\nthis software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n\"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\nLIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\nA PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\nOWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\nSPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\nLIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\nTHEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 8.953125,
          "content": "# Mergo\n\n[![GitHub release][5]][6]\n[![GoCard][7]][8]\n[![Test status][1]][2]\n[![OpenSSF Scorecard][21]][22]\n[![OpenSSF Best Practices][19]][20]\n[![Coverage status][9]][10]\n[![Sourcegraph][11]][12]\n[![FOSSA status][13]][14]\n\n[![GoDoc][3]][4]\n[![Become my sponsor][15]][16]\n[![Tidelift][17]][18]\n\n[1]: https://github.com/imdario/mergo/workflows/tests/badge.svg?branch=master\n[2]: https://github.com/imdario/mergo/actions/workflows/tests.yml\n[3]: https://godoc.org/github.com/imdario/mergo?status.svg\n[4]: https://godoc.org/github.com/imdario/mergo\n[5]: https://img.shields.io/github/release/imdario/mergo.svg\n[6]: https://github.com/imdario/mergo/releases\n[7]: https://goreportcard.com/badge/imdario/mergo\n[8]: https://goreportcard.com/report/github.com/imdario/mergo\n[9]: https://coveralls.io/repos/github/imdario/mergo/badge.svg?branch=master\n[10]: https://coveralls.io/github/imdario/mergo?branch=master\n[11]: https://sourcegraph.com/github.com/imdario/mergo/-/badge.svg\n[12]: https://sourcegraph.com/github.com/imdario/mergo?badge\n[13]: https://app.fossa.io/api/projects/git%2Bgithub.com%2Fimdario%2Fmergo.svg?type=shield\n[14]: https://app.fossa.io/projects/git%2Bgithub.com%2Fimdario%2Fmergo?ref=badge_shield\n[15]: https://img.shields.io/github/sponsors/imdario\n[16]: https://github.com/sponsors/imdario\n[17]: https://tidelift.com/badges/package/go/github.com%2Fimdario%2Fmergo\n[18]: https://tidelift.com/subscription/pkg/go-github.com-imdario-mergo\n[19]: https://bestpractices.coreinfrastructure.org/projects/7177/badge\n[20]: https://bestpractices.coreinfrastructure.org/projects/7177\n[21]: https://api.securityscorecards.dev/projects/github.com/imdario/mergo/badge\n[22]: https://api.securityscorecards.dev/projects/github.com/imdario/mergo\n\nA helper to merge structs and maps in Golang. Useful for configuration default values, avoiding messy if-statements.\n\nMergo merges same-type structs and maps by setting default values in zero-value fields. Mergo won't merge unexported (private) fields. It will do recursively any exported one. It also won't merge structs inside maps (because they are not addressable using Go reflection).\n\nAlso a lovely [comune](http://en.wikipedia.org/wiki/Mergo) (municipality) in the Province of Ancona in the Italian region of Marche.\n\n## Status\n\nMergo is stable and frozen, ready for production. Check a short list of the projects using at large scale it [here](https://github.com/imdario/mergo#mergo-in-the-wild).\n\nNo new features are accepted. They will be considered for a future v2 that improves the implementation and fixes bugs for corner cases.\n\n### Important notes\n\n#### 1.0.0\n\nIn [1.0.0](//github.com/imdario/mergo/releases/tag/1.0.0) Mergo moves to a vanity URL `dario.cat/mergo`. No more v1 versions will be released.\n\nIf the vanity URL is causing issues in your project due to a dependency pulling Mergo - it isn't a direct dependency in your project - it is recommended to use [replace](https://github.com/golang/go/wiki/Modules#when-should-i-use-the-replace-directive) to pin the version to the last one with the old import URL:\n\n```\nreplace github.com/imdario/mergo => github.com/imdario/mergo v0.3.16\n```\n\n#### 0.3.9\n\nPlease keep in mind that a problematic PR broke [0.3.9](//github.com/imdario/mergo/releases/tag/0.3.9). I reverted it in [0.3.10](//github.com/imdario/mergo/releases/tag/0.3.10), and I consider it stable but not bug-free. Also, this version adds support for go modules.\n\nKeep in mind that in [0.3.2](//github.com/imdario/mergo/releases/tag/0.3.2), Mergo changed `Merge()`and `Map()` signatures to support [transformers](#transformers). I added an optional/variadic argument so that it won't break the existing code.\n\nIf you were using Mergo before April 6th, 2015, please check your project works as intended after updating your local copy with ```go get -u dario.cat/mergo```. I apologize for any issue caused by its previous behavior and any future bug that Mergo could cause in existing projects after the change (release 0.2.0).\n\n### Donations\n\nIf Mergo is useful to you, consider buying me a coffee, a beer, or making a monthly donation to allow me to keep building great free software. :heart_eyes:\n\n<a href=\"https://liberapay.com/dario/donate\"><img alt=\"Donate using Liberapay\" src=\"https://liberapay.com/assets/widgets/donate.svg\"></a>\n<a href='https://github.com/sponsors/imdario' target='_blank'><img alt=\"Become my sponsor\" src=\"https://img.shields.io/github/sponsors/imdario?style=for-the-badge\" /></a>\n\n### Mergo in the wild\n\nMergo is used by [thousands](https://deps.dev/go/dario.cat%2Fmergo/v1.0.0/dependents) [of](https://deps.dev/go/github.com%2Fimdario%2Fmergo/v0.3.16/dependents) [projects](https://deps.dev/go/github.com%2Fimdario%2Fmergo/v0.3.12), including:\n\n* [containerd/containerd](https://github.com/containerd/containerd)\n* [datadog/datadog-agent](https://github.com/datadog/datadog-agent)\n* [docker/cli/](https://github.com/docker/cli/)\n* [goreleaser/goreleaser](https://github.com/goreleaser/goreleaser)\n* [go-micro/go-micro](https://github.com/go-micro/go-micro)\n* [grafana/loki](https://github.com/grafana/loki)\n* [kubernetes/kubernetes](https://github.com/kubernetes/kubernetes)\n* [masterminds/sprig](github.com/Masterminds/sprig)\n* [moby/moby](https://github.com/moby/moby)\n* [slackhq/nebula](https://github.com/slackhq/nebula)\n* [volcano-sh/volcano](https://github.com/volcano-sh/volcano)\n\n## Install\n\n    go get dario.cat/mergo\n\n    // use in your .go code\n    import (\n        \"dario.cat/mergo\"\n    )\n\n## Usage\n\nYou can only merge same-type structs with exported fields initialized as zero value of their type and same-types maps. Mergo won't merge unexported (private) fields but will do recursively any exported one. It won't merge empty structs value as [they are zero values](https://golang.org/ref/spec#The_zero_value) too. Also, maps will be merged recursively except for structs inside maps (because they are not addressable using Go reflection).\n\n```go\nif err := mergo.Merge(&dst, src); err != nil {\n    // ...\n}\n```\n\nAlso, you can merge overwriting values using the transformer `WithOverride`.\n\n```go\nif err := mergo.Merge(&dst, src, mergo.WithOverride); err != nil {\n    // ...\n}\n```\n\nIf you need to override pointers, so the source pointer's value is assigned to the destination's pointer, you must use `WithoutDereference`:\n\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\n\t\"dario.cat/mergo\"\n)\n\ntype Foo struct {\n\tA *string\n\tB int64\n}\n\nfunc main() {\n\tfirst := \"first\"\n\tsecond := \"second\"\n\tsrc := Foo{\n\t\tA: &first,\n\t\tB: 2,\n\t}\n\n\tdest := Foo{\n\t\tA: &second,\n\t\tB: 1,\n\t}\n\n\tmergo.Merge(&dest, src, mergo.WithOverride, mergo.WithoutDereference)\n}\n```\n\nAdditionally, you can map a `map[string]interface{}` to a struct (and otherwise, from struct to map), following the same restrictions as in `Merge()`. Keys are capitalized to find each corresponding exported field.\n\n```go\nif err := mergo.Map(&dst, srcMap); err != nil {\n    // ...\n}\n```\n\nWarning: if you map a struct to map, it won't do it recursively. Don't expect Mergo to map struct members of your struct as `map[string]interface{}`. They will be just assigned as values.\n\nHere is a nice example:\n\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"dario.cat/mergo\"\n)\n\ntype Foo struct {\n\tA string\n\tB int64\n}\n\nfunc main() {\n\tsrc := Foo{\n\t\tA: \"one\",\n\t\tB: 2,\n\t}\n\tdest := Foo{\n\t\tA: \"two\",\n\t}\n\tmergo.Merge(&dest, src)\n\tfmt.Println(dest)\n\t// Will print\n\t// {two 2}\n}\n```\n\nNote: if test are failing due missing package, please execute:\n\n    go get gopkg.in/yaml.v3\n\n### Transformers\n\nTransformers allow to merge specific types differently than in the default behavior. In other words, now you can customize how some types are merged. For example, `time.Time` is a struct; it doesn't have zero value but IsZero can return true because it has fields with zero value. How can we merge a non-zero `time.Time`?\n\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"dario.cat/mergo\"\n    \"reflect\"\n    \"time\"\n)\n\ntype timeTransformer struct {\n}\n\nfunc (t timeTransformer) Transformer(typ reflect.Type) func(dst, src reflect.Value) error {\n\tif typ == reflect.TypeOf(time.Time{}) {\n\t\treturn func(dst, src reflect.Value) error {\n\t\t\tif dst.CanSet() {\n\t\t\t\tisZero := dst.MethodByName(\"IsZero\")\n\t\t\t\tresult := isZero.Call([]reflect.Value{})\n\t\t\t\tif result[0].Bool() {\n\t\t\t\t\tdst.Set(src)\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn nil\n\t\t}\n\t}\n\treturn nil\n}\n\ntype Snapshot struct {\n\tTime time.Time\n\t// ...\n}\n\nfunc main() {\n\tsrc := Snapshot{time.Now()}\n\tdest := Snapshot{}\n\tmergo.Merge(&dest, src, mergo.WithTransformers(timeTransformer{}))\n\tfmt.Println(dest)\n\t// Will print\n\t// { 2018-01-12 01:15:00 +0000 UTC m=+0.000000001 }\n}\n```\n\n## Contact me\n\nIf I can help you, you have an idea or you are using Mergo in your projects, don't hesitate to drop me a line (or a pull request): [@im_dario](https://twitter.com/im_dario)\n\n## About\n\nWritten by [Dario Castañé](http://dario.im).\n\n## License\n\n[BSD 3-Clause](http://opensource.org/licenses/BSD-3-Clause) license, as [Go language](http://golang.org/LICENSE).\n\n[![FOSSA Status](https://app.fossa.io/api/projects/git%2Bgithub.com%2Fimdario%2Fmergo.svg?type=large)](https://app.fossa.io/projects/git%2Bgithub.com%2Fimdario%2Fmergo?ref=badge_large)\n"
        },
        {
          "name": "SECURITY.md",
          "type": "blob",
          "size": 0.359375,
          "content": "# Security Policy\n\n## Supported Versions\n\n| Version | Supported          |\n| ------- | ------------------ |\n| 0.3.x   | :white_check_mark: |\n| < 0.3   | :x:                |\n\n## Security contact information\n\nTo report a security vulnerability, please use the\n[Tidelift security contact](https://tidelift.com/security).\nTidelift will coordinate the fix and disclosure.\n"
        },
        {
          "name": "doc.go",
          "type": "blob",
          "size": 4.333984375,
          "content": "// Copyright 2013 Dario Castañé. All rights reserved.\n// Copyright 2009 The Go Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\n/*\nA helper to merge structs and maps in Golang. Useful for configuration default values, avoiding messy if-statements.\n\nMergo merges same-type structs and maps by setting default values in zero-value fields. Mergo won't merge unexported (private) fields. It will do recursively any exported one. It also won't merge structs inside maps (because they are not addressable using Go reflection).\n\n# Status\n\nIt is ready for production use. It is used in several projects by Docker, Google, The Linux Foundation, VMWare, Shopify, etc.\n\n# Important notes\n\n1.0.0\n\nIn 1.0.0 Mergo moves to a vanity URL `dario.cat/mergo`.\n\n0.3.9\n\nPlease keep in mind that a problematic PR broke 0.3.9. We reverted it in 0.3.10. We consider 0.3.10 as stable but not bug-free. . Also, this version adds suppot for go modules.\n\nKeep in mind that in 0.3.2, Mergo changed Merge() and Map() signatures to support transformers. We added an optional/variadic argument so that it won't break the existing code.\n\nIf you were using Mergo before April 6th, 2015, please check your project works as intended after updating your local copy with go get -u dario.cat/mergo. I apologize for any issue caused by its previous behavior and any future bug that Mergo could cause in existing projects after the change (release 0.2.0).\n\n# Install\n\nDo your usual installation procedure:\n\n\tgo get dario.cat/mergo\n\n\t// use in your .go code\n\timport (\n\t    \"dario.cat/mergo\"\n\t)\n\n# Usage\n\nYou can only merge same-type structs with exported fields initialized as zero value of their type and same-types maps. Mergo won't merge unexported (private) fields but will do recursively any exported one. It won't merge empty structs value as they are zero values too. Also, maps will be merged recursively except for structs inside maps (because they are not addressable using Go reflection).\n\n\tif err := mergo.Merge(&dst, src); err != nil {\n\t\t// ...\n\t}\n\nAlso, you can merge overwriting values using the transformer WithOverride.\n\n\tif err := mergo.Merge(&dst, src, mergo.WithOverride); err != nil {\n\t\t// ...\n\t}\n\nAdditionally, you can map a map[string]interface{} to a struct (and otherwise, from struct to map), following the same restrictions as in Merge(). Keys are capitalized to find each corresponding exported field.\n\n\tif err := mergo.Map(&dst, srcMap); err != nil {\n\t\t// ...\n\t}\n\nWarning: if you map a struct to map, it won't do it recursively. Don't expect Mergo to map struct members of your struct as map[string]interface{}. They will be just assigned as values.\n\nHere is a nice example:\n\n\tpackage main\n\n\timport (\n\t\t\"fmt\"\n\t\t\"dario.cat/mergo\"\n\t)\n\n\ttype Foo struct {\n\t\tA string\n\t\tB int64\n\t}\n\n\tfunc main() {\n\t\tsrc := Foo{\n\t\t\tA: \"one\",\n\t\t\tB: 2,\n\t\t}\n\t\tdest := Foo{\n\t\t\tA: \"two\",\n\t\t}\n\t\tmergo.Merge(&dest, src)\n\t\tfmt.Println(dest)\n\t\t// Will print\n\t\t// {two 2}\n\t}\n\n# Transformers\n\nTransformers allow to merge specific types differently than in the default behavior. In other words, now you can customize how some types are merged. For example, time.Time is a struct; it doesn't have zero value but IsZero can return true because it has fields with zero value. How can we merge a non-zero time.Time?\n\n\tpackage main\n\n\timport (\n\t\t\"fmt\"\n\t\t\"dario.cat/mergo\"\n\t\t\"reflect\"\n\t\t\"time\"\n\t)\n\n\ttype timeTransformer struct {\n\t}\n\n\tfunc (t timeTransformer) Transformer(typ reflect.Type) func(dst, src reflect.Value) error {\n\t\tif typ == reflect.TypeOf(time.Time{}) {\n\t\t\treturn func(dst, src reflect.Value) error {\n\t\t\t\tif dst.CanSet() {\n\t\t\t\t\tisZero := dst.MethodByName(\"IsZero\")\n\t\t\t\t\tresult := isZero.Call([]reflect.Value{})\n\t\t\t\t\tif result[0].Bool() {\n\t\t\t\t\t\tdst.Set(src)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn nil\n\t\t\t}\n\t\t}\n\t\treturn nil\n\t}\n\n\ttype Snapshot struct {\n\t\tTime time.Time\n\t\t// ...\n\t}\n\n\tfunc main() {\n\t\tsrc := Snapshot{time.Now()}\n\t\tdest := Snapshot{}\n\t\tmergo.Merge(&dest, src, mergo.WithTransformers(timeTransformer{}))\n\t\tfmt.Println(dest)\n\t\t// Will print\n\t\t// { 2018-01-12 01:15:00 +0000 UTC m=+0.000000001 }\n\t}\n\n# Contact me\n\nIf I can help you, you have an idea or you are using Mergo in your projects, don't hesitate to drop me a line (or a pull request): https://twitter.com/im_dario\n\n# About\n\nWritten by Dario Castañé: https://da.rio.hn\n\n# License\n\nBSD 3-Clause license, as Go language.\n*/\npackage mergo\n"
        },
        {
          "name": "go.mod",
          "type": "blob",
          "size": 0.0634765625,
          "content": "module dario.cat/mergo\n\ngo 1.13\n\nrequire gopkg.in/yaml.v3 v3.0.1\n"
        },
        {
          "name": "go.sum",
          "type": "blob",
          "size": 0.3515625,
          "content": "gopkg.in/check.v1 v0.0.0-20161208181325-20d25e280405 h1:yhCVgyC4o1eVCa2tZl7eS0r+SDo693bJlVdllGtEeKM=\ngopkg.in/check.v1 v0.0.0-20161208181325-20d25e280405/go.mod h1:Co6ibVJAznAaIkqp8huTwlJQCZ016jof/cbN4VW5Yz0=\ngopkg.in/yaml.v3 v3.0.1 h1:fxVm/GzAzEWqLHuvctI91KS9hhNmmWOoWu0XTYJS7CA=\ngopkg.in/yaml.v3 v3.0.1/go.mod h1:K4uyk7z7BCEPqu6E+C64Yfv1cQ7kz7rIZviUmN+EgEM=\n"
        },
        {
          "name": "issue100_test.go",
          "type": "blob",
          "size": 0.28125,
          "content": "package mergo_test\n\nimport (\n\t\"testing\"\n\n\t\"dario.cat/mergo\"\n)\n\ntype issue100s struct {\n\tMember interface{}\n}\n\nfunc TestIssue100(t *testing.T) {\n\tm := make(map[string]interface{})\n\tm[\"Member\"] = \"anything\"\n\n\tst := &issue100s{}\n\tif err := mergo.Map(st, m); err != nil {\n\t\tt.Error(err)\n\t}\n}\n"
        },
        {
          "name": "issue104_test.go",
          "type": "blob",
          "size": 0.9814453125,
          "content": "package mergo_test\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n\n\t\"dario.cat/mergo\"\n)\n\ntype Record struct {\n\tData    map[string]interface{}\n\tMapping map[string]string\n}\n\nfunc StructToRecord(in interface{}) *Record {\n\trec := Record{}\n\trec.Data = make(map[string]interface{})\n\trec.Mapping = make(map[string]string)\n\ttyp := reflect.TypeOf(in)\n\tfor i := 0; i < typ.NumField(); i++ {\n\t\tfield := typ.Field(i)\n\t\tdbFieldName := field.Tag.Get(\"db\")\n\t\tif dbFieldName != \"\" {\n\t\t\trec.Mapping[field.Name] = dbFieldName\n\t\t}\n\t}\n\n\tif err := mergo.Map(&rec.Data, in); err != nil {\n\t\tpanic(err)\n\t}\n\treturn &rec\n}\n\nfunc TestStructToRecord(t *testing.T) {\n\ttype A struct {\n\t\tName string `json:\"name\" db:\"name\"`\n\t\tCIDR string `json:\"cidr\" db:\"cidr\"`\n\t}\n\ttype Record struct {\n\t\tData    map[string]interface{}\n\t\tMapping map[string]string\n\t}\n\ta := A{Name: \"David\", CIDR: \"10.0.0.0/8\"}\n\trec := StructToRecord(a)\n\tif len(rec.Mapping) < 2 {\n\t\tt.Fatalf(\"struct to record failed, no mapping, struct missing tags?, rec: %+v, a: %+v \", rec, a)\n\t}\n}\n"
        },
        {
          "name": "issue121_test.go",
          "type": "blob",
          "size": 0.640625,
          "content": "package mergo_test\n\nimport (\n\t\"testing\"\n\n\t\"dario.cat/mergo\"\n)\n\nfunc TestIssue121WithSliceDeepCopy(t *testing.T) {\n\tdst := map[string]interface{}{\n\t\t\"inter\": map[string]interface{}{\n\t\t\t\"a\": \"1\",\n\t\t\t\"b\": \"2\",\n\t\t},\n\t}\n\n\tsrc := map[string]interface{}{\n\t\t\"inter\": map[string]interface{}{\n\t\t\t\"a\": \"3\",\n\t\t\t\"c\": \"4\",\n\t\t},\n\t}\n\n\tif err := mergo.Merge(&dst, src, mergo.WithSliceDeepCopy); err != nil {\n\t\tt.Errorf(\"Error during the merge: %v\", err)\n\t}\n\n\tif dst[\"inter\"].(map[string]interface{})[\"a\"].(string) != \"3\" {\n\t\tt.Error(\"inter.a should equal '3'\")\n\t}\n\n\tif dst[\"inter\"].(map[string]interface{})[\"c\"].(string) != \"4\" {\n\t\tt.Error(\"inter.c should equal '4'\")\n\t}\n}\n"
        },
        {
          "name": "issue123_test.go",
          "type": "blob",
          "size": 0.65234375,
          "content": "package mergo_test\n\nimport (\n\t\"testing\"\n\n\t\"dario.cat/mergo\"\n)\n\nfunc TestIssue123(t *testing.T) {\n\tsrc := map[string]interface{}{\n\t\t\"col1\": nil,\n\t\t\"col2\": 4,\n\t\t\"col3\": nil,\n\t}\n\tdst := map[string]interface{}{\n\t\t\"col1\": 2,\n\t\t\"col2\": 3,\n\t\t\"col3\": 3,\n\t}\n\n\t// Expected behavior\n\tif err := mergo.Merge(&dst, src, mergo.WithOverride); err != nil {\n\t\tt.Fatal(err)\n\t}\n\ttestCases := []struct {\n\t\texpected interface{}\n\t\tkey      string\n\t}{\n\t\t{\n\t\t\tnil,\n\t\t\t\"col1\",\n\t\t},\n\t\t{\n\t\t\t4,\n\t\t\t\"col2\",\n\t\t},\n\t\t{\n\t\t\tnil,\n\t\t\t\"col3\",\n\t\t},\n\t}\n\tfor _, tC := range testCases {\n\t\tif dst[tC.key] != tC.expected {\n\t\t\tt.Fatalf(\"expected %v in dst[%q], got %v\", tC.expected, tC.key, dst[tC.key])\n\t\t}\n\t}\n}\n"
        },
        {
          "name": "issue125_test.go",
          "type": "blob",
          "size": 0.833984375,
          "content": "package mergo_test\n\nimport (\n\t\"encoding/json\"\n\t\"testing\"\n\n\t\"dario.cat/mergo\"\n)\n\ntype settings struct {\n\tFirstSlice  []string `json:\"FirstSlice\"`\n\tSecondSlice []string `json:\"SecondSlice\"`\n}\n\nfunc TestIssue125MergeWithOverwrite(t *testing.T) {\n\tvar (\n\t\tdefaultSettings = settings{\n\t\t\tFirstSlice:  []string{},\n\t\t\tSecondSlice: []string{},\n\t\t}\n\t\tsomething settings\n\t\tdata      = `{\"FirstSlice\":[], \"SecondSlice\": null}`\n\t)\n\n\tif err := json.Unmarshal([]byte(data), &something); err != nil {\n\t\tt.Errorf(\"Error while Unmarshalling maprequest: %s\", err)\n\t}\n\n\tif err := mergo.Merge(&something, defaultSettings, mergo.WithOverrideEmptySlice); err != nil {\n\t\tt.Errorf(\"Error while merging: %s\", err)\n\t}\n\n\tif something.FirstSlice == nil {\n\t\tt.Error(\"Invalid merging first slice\")\n\t}\n\n\tif something.SecondSlice == nil {\n\t\tt.Error(\"Invalid merging second slice\")\n\t}\n}\n"
        },
        {
          "name": "issue129_test.go",
          "type": "blob",
          "size": 0.7080078125,
          "content": "package mergo_test\n\nimport (\n\t\"testing\"\n\n\t\"dario.cat/mergo\"\n)\n\nfunc TestIssue129Boolean(t *testing.T) {\n\ttype Foo struct {\n\t\tA bool\n\t\tB bool\n\t}\n\n\tsrc := Foo{\n\t\tA: true,\n\t\tB: false,\n\t}\n\tdst := Foo{\n\t\tA: false,\n\t\tB: true,\n\t}\n\n\t// Standard behavior\n\tif err := mergo.Merge(&dst, src); err != nil {\n\t\tt.Error(err)\n\t}\n\tif dst.A != true {\n\t\tt.Errorf(\"expected true, got false\")\n\t}\n\tif dst.B != true {\n\t\tt.Errorf(\"expected true, got false\")\n\t}\n\n\t// Expected behavior\n\tdst = Foo{\n\t\tA: false,\n\t\tB: true,\n\t}\n\tif err := mergo.Merge(&dst, src, mergo.WithOverwriteWithEmptyValue); err != nil {\n\t\tt.Error(err)\n\t}\n\tif dst.A != true {\n\t\tt.Errorf(\"expected true, got false\")\n\t}\n\tif dst.B != false {\n\t\tt.Errorf(\"expected false, got true\")\n\t}\n}\n"
        },
        {
          "name": "issue131_test.go",
          "type": "blob",
          "size": 2.9140625,
          "content": "package mergo_test\n\nimport (\n\t\"testing\"\n\n\t\"dario.cat/mergo\"\n)\n\ntype foz struct {\n\tA *bool\n\tB string\n\tC *bool\n\tD *bool\n\tE *bool\n\tF *baz\n}\n\ntype baz struct {\n\tA *bool\n}\n\nfunc TestIssue131MergeWithOverwriteWithEmptyValue(t *testing.T) {\n\tsrc := foz{\n\t\tA: func(v bool) *bool { return &v }(false),\n\t\tB: \"src\",\n\t}\n\tdest := foz{\n\t\tA: func(v bool) *bool { return &v }(true),\n\t\tB: \"dest\",\n\t}\n\tif err := mergo.Merge(&dest, src, mergo.WithOverwriteWithEmptyValue); err != nil {\n\t\tt.Error(err)\n\t}\n\tif *src.A != *dest.A {\n\t\tt.Errorf(\"dest.A not merged in properly: %v != %v\", *src.A, *dest.A)\n\t}\n\tif src.B != dest.B {\n\t\tt.Errorf(\"dest.B not merged in properly: %v != %v\", src.B, dest.B)\n\t}\n}\n\nfunc TestIssue131MergeWithoutDereferenceWithOverride(t *testing.T) {\n\tsrc := foz{\n\t\tA: func(v bool) *bool { return &v }(false),\n\t\tB: \"src\",\n\t\tC: nil,\n\t\tD: func(v bool) *bool { return &v }(false),\n\t\tE: func(v bool) *bool { return &v }(true),\n\t}\n\tdest := foz{\n\t\tA: func(v bool) *bool { return &v }(true),\n\t\tB: \"dest\",\n\t\tC: func(v bool) *bool { return &v }(false),\n\t\tD: nil,\n\t\tE: func(v bool) *bool { return &v }(false),\n\t}\n\tif err := mergo.Merge(&dest, src, mergo.WithoutDereference, mergo.WithOverride); err != nil {\n\t\tt.Error(err)\n\t}\n\tif *src.A != *dest.A {\n\t\tt.Errorf(\"dest.A not merged in properly: %v != %v\", *src.A, *dest.A)\n\t}\n\tif src.B != dest.B {\n\t\tt.Errorf(\"dest.B not merged in properly: %v != %v\", src.B, dest.B)\n\t}\n\tif *dest.C != false {\n\t\tt.Errorf(\"dest.C not merged in properly: %v != %v\", *src.C, *dest.C)\n\t}\n\tif *dest.D != false {\n\t\tt.Errorf(\"dest.D not merged in properly: %v != %v\", src.D, *dest.D)\n\t}\n\tif *dest.E != true {\n\t\tt.Errorf(\"dest.E not merged in properly: %v != %v\", *src.E, *dest.E)\n\t}\n}\n\nfunc TestIssue131MergeWithoutDereference(t *testing.T) {\n\tsrc := foz{\n\t\tA: func(v bool) *bool { return &v }(false),\n\t\tB: \"src\",\n\t\tC: nil,\n\t\tD: func(v bool) *bool { return &v }(false),\n\t\tE: func(v bool) *bool { return &v }(true),\n\t\tF: &baz{\n\t\t\tA: func(v bool) *bool { return &v }(true),\n\t\t},\n\t}\n\tdest := foz{\n\t\tA: func(v bool) *bool { return &v }(true),\n\t\tB: \"dest\",\n\t\tC: func(v bool) *bool { return &v }(false),\n\t\tD: nil,\n\t\tE: func(v bool) *bool { return &v }(false),\n\t\tF: nil,\n\t}\n\tif err := mergo.Merge(&dest, src, mergo.WithoutDereference); err != nil {\n\t\tt.Error(err)\n\t}\n\tif *src.A == *dest.A {\n\t\tt.Errorf(\"dest.A should not have been merged: %v == %v\", *src.A, *dest.A)\n\t}\n\tif src.B == dest.B {\n\t\tt.Errorf(\"dest.B should not have been merged: %v == %v\", src.B, dest.B)\n\t}\n\tif *dest.C != false {\n\t\tt.Errorf(\"dest.C not merged in properly: %v != %v\", *src.C, *dest.C)\n\t}\n\tif *dest.D != false {\n\t\tt.Errorf(\"dest.D not merged in properly: %v != %v\", src.D, *dest.D)\n\t}\n\tif *dest.E == true {\n\t\tt.Errorf(\"dest.E should not have been merged: %v == %v\", *src.E, *dest.E)\n\t}\n\n\tif dest.F == nil {\n\t\tt.Errorf(\"dest.F should not have be overriden with nil: %v == %v\", src.F, dest.F)\n\t}\n\n\tif *dest.F.A == false {\n\t\tt.Errorf(\"dest.F.A not merged in properly: %v != %v\", *src.F.A, *dest.F.A)\n\t}\n}\n"
        },
        {
          "name": "issue136_test.go",
          "type": "blob",
          "size": 0.439453125,
          "content": "package mergo_test\n\nimport (\n\t\"testing\"\n\n\t\"dario.cat/mergo\"\n)\n\ntype embeddedTestA struct {\n\tName string\n\tAge  uint8\n}\n\ntype embeddedTestB struct {\n\tAddress string\n\tembeddedTestA\n}\n\nfunc TestMergeEmbedded(t *testing.T) {\n\tvar (\n\t\terr error\n\t\ta   = &embeddedTestA{\n\t\t\t\"Suwon\", 16,\n\t\t}\n\t\tb = &embeddedTestB{}\n\t)\n\n\tif err := mergo.Merge(&b.embeddedTestA, *a); err != nil {\n\t\tt.Error(err)\n\t}\n\n\tif b.Name != \"Suwon\" {\n\t\tt.Errorf(\"%v %v\", b.Name, err)\n\t}\n}\n"
        },
        {
          "name": "issue138_test.go",
          "type": "blob",
          "size": 0.7841796875,
          "content": "package mergo_test\n\nimport (\n\t\"encoding/json\"\n\t\"testing\"\n\n\t\"dario.cat/mergo\"\n)\n\nconst issue138configuration string = `\n{\n\t\"Port\": 80\n}\n`\n\nfunc TestIssue138(t *testing.T) {\n\ttype config struct {\n\t\tPort uint16\n\t}\n\ttype compatibleConfig struct {\n\t\tPort float64\n\t}\n\n\tfoo := make(map[string]interface{})\n\t// encoding/json unmarshals numbers as float64\n\t// https://golang.org/pkg/encoding/json/#Unmarshal\n\tjson.Unmarshal([]byte(issue138configuration), &foo)\n\n\terr := mergo.Map(&config{}, foo)\n\tif err == nil {\n\t\tt.Error(\"expected type mismatch error, got nil\")\n\t} else {\n\t\tif err.Error() != \"type mismatch on Port field: found float64, expected uint16\" {\n\t\t\tt.Errorf(\"expected type mismatch error, got %q\", err)\n\t\t}\n\t}\n\n\tc := compatibleConfig{}\n\tif err := mergo.Map(&c, foo); err != nil {\n\t\tt.Error(err)\n\t}\n}\n"
        },
        {
          "name": "issue143_test.go",
          "type": "blob",
          "size": 1.2373046875,
          "content": "package mergo_test\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n\n\t\"dario.cat/mergo\"\n)\n\nfunc TestIssue143(t *testing.T) {\n\ttestCases := []struct {\n\t\texpected func(map[string]interface{}) error\n\t\toptions  []func(*mergo.Config)\n\t}{\n\t\t{\n\t\t\toptions: []func(*mergo.Config){mergo.WithOverride},\n\t\t\texpected: func(m map[string]interface{}) error {\n\t\t\t\tproperties := m[\"properties\"].(map[string]interface{})\n\t\t\t\tif properties[\"field1\"] != \"wrong\" {\n\t\t\t\t\treturn fmt.Errorf(\"expected %q, got %v\", \"wrong\", properties[\"field1\"])\n\t\t\t\t}\n\t\t\t\treturn nil\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\toptions: []func(*mergo.Config){},\n\t\t\texpected: func(m map[string]interface{}) error {\n\t\t\t\tproperties := m[\"properties\"].(map[string]interface{})\n\t\t\t\tif properties[\"field1\"] == \"wrong\" {\n\t\t\t\t\treturn fmt.Errorf(\"expected a map, got %v\", \"wrong\")\n\t\t\t\t}\n\t\t\t\treturn nil\n\t\t\t},\n\t\t},\n\t}\n\tfor _, tC := range testCases {\n\t\tbase := map[string]interface{}{\n\t\t\t\"properties\": map[string]interface{}{\n\t\t\t\t\"field1\": map[string]interface{}{\n\t\t\t\t\t\"type\": \"text\",\n\t\t\t\t},\n\t\t\t},\n\t\t}\n\n\t\terr := mergo.Map(\n\t\t\t&base,\n\t\t\tmap[string]interface{}{\n\t\t\t\t\"properties\": map[string]interface{}{\n\t\t\t\t\t\"field1\": \"wrong\",\n\t\t\t\t},\n\t\t\t},\n\t\t\ttC.options...,\n\t\t)\n\t\tif err != nil {\n\t\t\tt.Error(err)\n\t\t}\n\t\tif err := tC.expected(base); err != nil {\n\t\t\tt.Error(err)\n\t\t}\n\t}\n}\n"
        },
        {
          "name": "issue149_test.go",
          "type": "blob",
          "size": 0.5927734375,
          "content": "package mergo_test\n\nimport (\n\t\"testing\"\n\n\t\"dario.cat/mergo\"\n)\n\ntype user struct {\n\tName string\n}\n\ntype token struct {\n\tUser  *user\n\tToken *string\n}\n\nfunc TestIssue149(t *testing.T) {\n\tdest := &token{\n\t\tUser: &user{\n\t\t\tName: \"destination\",\n\t\t},\n\t\tToken: nil,\n\t}\n\ttokenValue := \"Issue149\"\n\tsrc := &token{\n\t\tUser:  nil,\n\t\tToken: &tokenValue,\n\t}\n\tif err := mergo.Merge(dest, src, mergo.WithOverwriteWithEmptyValue); err != nil {\n\t\tt.Error(err)\n\t}\n\tif dest.User != nil {\n\t\tt.Errorf(\"expected nil User, got %q\", dest.User)\n\t}\n\tif dest.Token == nil {\n\t\tt.Errorf(\"expected not nil Token, got %q\", *dest.Token)\n\t}\n}\n"
        },
        {
          "name": "issue174_test.go",
          "type": "blob",
          "size": 0.302734375,
          "content": "package mergo_test\n\nimport (\n\t\"testing\"\n\n\t\"dario.cat/mergo\"\n)\n\ntype structWithBlankField struct {\n\t_ struct{}\n\tA struct{}\n}\n\nfunc TestIssue174(t *testing.T) {\n\tdst := structWithBlankField{}\n\tsrc := structWithBlankField{}\n\n\tif err := mergo.Merge(&dst, src, mergo.WithOverride); err != nil {\n\t\tt.Error(err)\n\t}\n}\n"
        },
        {
          "name": "issue17_test.go",
          "type": "blob",
          "size": 0.58203125,
          "content": "package mergo_test\n\nimport (\n\t\"encoding/json\"\n\t\"testing\"\n\n\t\"dario.cat/mergo\"\n)\n\nfunc TestIssue17MergeWithOverwrite(t *testing.T) {\n\tvar (\n\t\trequest    = `{\"timestamp\":null, \"name\": \"foo\"}`\n\t\tmaprequest = map[string]interface{}{\n\t\t\t\"timestamp\": nil,\n\t\t\t\"name\":      \"foo\",\n\t\t\t\"newStuff\":  \"foo\",\n\t\t}\n\t)\n\n\tvar something map[string]interface{}\n\tif err := json.Unmarshal([]byte(request), &something); err != nil {\n\t\tt.Errorf(\"Error while Unmarshalling maprequest: %s\", err)\n\t}\n\n\tif err := mergo.MergeWithOverwrite(&something, maprequest); err != nil {\n\t\tt.Errorf(\"Error while merging: %s\", err)\n\t}\n}\n"
        },
        {
          "name": "issue187_test.go",
          "type": "blob",
          "size": 1.6279296875,
          "content": "package mergo_test\n\nimport (\n\t\"dario.cat/mergo\"\n\t\"testing\"\n)\n\nfunc TestIssue187MergeStructToMap(t *testing.T) {\n\tdst := map[string]interface{}{\n\t\t\"empty\": \"data\",\n\t}\n\n\tsrc := struct {\n\t\tFoo   string\n\t\tBar   int\n\t\tEmpty string\n\t}{\n\t\tFoo: \"hello\",\n\t\tBar: 42,\n\t}\n\tif err := mergo.Map(&dst, src); err != nil {\n\t\tt.Error(err)\n\t}\n\tif dst[\"foo\"] != \"hello\" || dst[\"bar\"] != 42 || dst[\"empty\"] != \"data\" {\n\t\tt.Errorf(\"expected dst to be {foo: hello, bar: 42, empty: data}, got {foo: %v, bar: %v, empty: %v}\", dst[\"foo\"], dst[\"bar\"], dst[\"empty\"])\n\t}\n}\n\nfunc TestIssue187MergeStructToMapWithOverwrite(t *testing.T) {\n\tdst := map[string]interface{}{\n\t\t\"foo\":   \"initial\",\n\t\t\"bar\":   1,\n\t\t\"empty\": \"data\",\n\t}\n\tsrc := struct {\n\t\tFoo   string\n\t\tBar   int\n\t\tEmpty string\n\t}{\n\t\tFoo: \"hello\",\n\t\tBar: 42,\n\t}\n\tif err := mergo.Map(&dst, src, mergo.WithOverride); err != nil {\n\t\tt.Error(err)\n\t}\n\tif dst[\"foo\"] != \"hello\" || dst[\"bar\"] != 42 || dst[\"empty\"] != \"data\" {\n\t\tt.Errorf(\"expected dst to be {foo: hello, bar: 42, empty: data}, got {foo: %v, bar: %v, empty: %v}\", dst[\"foo\"], dst[\"bar\"], dst[\"empty\"])\n\t}\n}\n\nfunc TestIssue187MergeStructToMapWithOverwriteWithEmptyValue(t *testing.T) {\n\tdst := map[string]interface{}{\n\t\t\"foo\":   \"initial\",\n\t\t\"bar\":   1,\n\t\t\"empty\": \"data\",\n\t}\n\tsrc := struct {\n\t\tFoo   string\n\t\tBar   int\n\t\tEmpty string\n\t}{\n\t\tFoo: \"hello\",\n\t\tBar: 42,\n\t}\n\tif err := mergo.Map(&dst, src, mergo.WithOverwriteWithEmptyValue); err != nil {\n\t\tt.Error(err)\n\t}\n\tif dst[\"foo\"] != \"hello\" || dst[\"bar\"] != 42 || dst[\"empty\"] != \"\" {\n\t\tt.Errorf(\"expected dst to be {foo: hello, bar: 42, empty: }, got {foo: %v, bar: %v, empty: %v}\", dst[\"foo\"], dst[\"bar\"], dst[\"empty\"])\n\t}\n}\n"
        },
        {
          "name": "issue202_test.go",
          "type": "blob",
          "size": 2.3623046875,
          "content": "package mergo_test\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n\n\t\"dario.cat/mergo\"\n)\n\nfunc TestIssue202(t *testing.T) {\n\ttests := []struct {\n\t\tname           string\n\t\tdst, src, want map[string]interface{}\n\t}{\n\t\t{\n\t\t\tname: \"slice override string\",\n\t\t\tdst: map[string]interface{}{\n\t\t\t\t\"x\": 456,\n\t\t\t\t\"y\": \"foo\",\n\t\t\t},\n\t\t\tsrc: map[string]interface{}{\n\t\t\t\t\"x\": \"123\",\n\t\t\t\t\"y\": []int{1, 2, 3},\n\t\t\t},\n\t\t\twant: map[string]interface{}{\n\t\t\t\t\"x\": \"123\",\n\t\t\t\t\"y\": []int{1, 2, 3},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"string override slice\",\n\t\t\tdst: map[string]interface{}{\n\t\t\t\t\"x\": 456,\n\t\t\t\t\"y\": []int{1, 2, 3},\n\t\t\t},\n\t\t\tsrc: map[string]interface{}{\n\t\t\t\t\"x\": \"123\",\n\t\t\t\t\"y\": \"foo\",\n\t\t\t},\n\t\t\twant: map[string]interface{}{\n\t\t\t\t\"x\": \"123\",\n\t\t\t\t\"y\": \"foo\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"map override string\",\n\t\t\tdst: map[string]interface{}{\n\t\t\t\t\"x\": 456,\n\t\t\t\t\"y\": \"foo\",\n\t\t\t},\n\t\t\tsrc: map[string]interface{}{\n\t\t\t\t\"x\": \"123\",\n\t\t\t\t\"y\": map[string]interface{}{\n\t\t\t\t\t\"a\": true,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: map[string]interface{}{\n\t\t\t\t\"x\": \"123\",\n\t\t\t\t\"y\": map[string]interface{}{\n\t\t\t\t\t\"a\": true,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"string override map\",\n\t\t\tdst: map[string]interface{}{\n\t\t\t\t\"x\": 456,\n\t\t\t\t\"y\": map[string]interface{}{\n\t\t\t\t\t\"a\": true,\n\t\t\t\t},\n\t\t\t},\n\t\t\tsrc: map[string]interface{}{\n\t\t\t\t\"x\": \"123\",\n\t\t\t\t\"y\": \"foo\",\n\t\t\t},\n\t\t\twant: map[string]interface{}{\n\t\t\t\t\"x\": \"123\",\n\t\t\t\t\"y\": \"foo\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"map override map\",\n\t\t\tdst: map[string]interface{}{\n\t\t\t\t\"x\": 456,\n\t\t\t\t\"y\": map[string]interface{}{\n\t\t\t\t\t\"a\": 10,\n\t\t\t\t},\n\t\t\t},\n\t\t\tsrc: map[string]interface{}{\n\t\t\t\t\"x\": \"123\",\n\t\t\t\t\"y\": map[string]interface{}{\n\t\t\t\t\t\"a\": true,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: map[string]interface{}{\n\t\t\t\t\"x\": \"123\",\n\t\t\t\t\"y\": map[string]interface{}{\n\t\t\t\t\t\"a\": true,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"map override map with merge\",\n\t\t\tdst: map[string]interface{}{\n\t\t\t\t\"x\": 456,\n\t\t\t\t\"y\": map[string]interface{}{\n\t\t\t\t\t\"a\": 10,\n\t\t\t\t\t\"b\": 100,\n\t\t\t\t},\n\t\t\t},\n\t\t\tsrc: map[string]interface{}{\n\t\t\t\t\"x\": \"123\",\n\t\t\t\t\"y\": map[string]interface{}{\n\t\t\t\t\t\"a\": true,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: map[string]interface{}{\n\t\t\t\t\"x\": \"123\",\n\t\t\t\t\"y\": map[string]interface{}{\n\t\t\t\t\t\"a\": true,\n\t\t\t\t\t\"b\": 100,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif err := mergo.Merge(&tt.dst, tt.src, mergo.WithOverride); err != nil {\n\t\t\t\tt.Error(err)\n\t\t\t}\n\n\t\t\tif !reflect.DeepEqual(tt.dst, tt.want) {\n\t\t\t\tt.Errorf(\"maps not equal.\\nwant:\\n%v\\ngot:\\n%v\\n\", tt.want, tt.dst)\n\t\t\t}\n\t\t})\n\t}\n}\n"
        },
        {
          "name": "issue209_test.go",
          "type": "blob",
          "size": 0.4638671875,
          "content": "package mergo_test\n\nimport (\n\t\"testing\"\n\n\t\"dario.cat/mergo\"\n)\n\nfunc TestIssue209(t *testing.T) {\n\tdst := []string{\"a\", \"b\"}\n\tsrc := []string{\"c\", \"d\"}\n\n\tif err := mergo.Merge(&dst, src, mergo.WithAppendSlice); err != nil {\n\t\tt.Error(err)\n\t}\n\n\texpected := []string{\"a\", \"b\", \"c\", \"d\"}\n\tif len(dst) != len(expected) {\n\t\tt.Errorf(\"arrays not equal length\")\n\t}\n\tfor i := range expected {\n\t\tif dst[i] != expected[i] {\n\t\t\tt.Errorf(\"array elements at %d are not equal\", i)\n\t\t}\n\t}\n}\n"
        },
        {
          "name": "issue220_test.go",
          "type": "blob",
          "size": 0.4716796875,
          "content": "package mergo_test\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n\n\t\"dario.cat/mergo\"\n)\n\nfunc TestIssue220(t *testing.T) {\n\tdst := []interface{}{\n\t\tmap[string]int{\n\t\t\t\"a\": 1,\n\t\t},\n\t}\n\tsrc := []interface{}{\n\t\t\"nil\",\n\t}\n\texpected := []interface{}{\n\t\tmap[string]int{\n\t\t\t\"a\": 1,\n\t\t},\n\t}\n\n\terr := mergo.Merge(&dst, src, mergo.WithSliceDeepCopy)\n\tif err != nil {\n\t\tt.Errorf(\"unexpected error %v\", err)\n\t}\n\n\tif !reflect.DeepEqual(dst, expected) {\n\t\tt.Errorf(\"expected: %#v\\ngot: %#v\", expected, dst)\n\t}\n}\n"
        },
        {
          "name": "issue230_test.go",
          "type": "blob",
          "size": 1.66796875,
          "content": "package mergo_test\n\nimport (\n\t\"testing\"\n\n\t\"dario.cat/mergo\"\n)\n\nvar testDataM = []struct {\n\tM1                     mapTest\n\tM2                     mapTest\n\tWithOverrideEmptyValue bool\n\tExpectedMap            map[int]int\n}{\n\t{\n\t\tM1: mapTest{\n\t\t\tM: map[int]int{1: 1, 3: 3},\n\t\t},\n\t\tM2: mapTest{\n\t\t\tM: map[int]int{1: 2, 2: 2},\n\t\t},\n\t\tWithOverrideEmptyValue: true,\n\t\tExpectedMap:            map[int]int{1: 1, 3: 3},\n\t},\n\t{\n\t\tM1: mapTest{\n\t\t\tM: map[int]int{1: 1, 3: 3},\n\t\t},\n\t\tM2: mapTest{\n\t\t\tM: map[int]int{1: 2, 2: 2},\n\t\t},\n\t\tWithOverrideEmptyValue: false,\n\t\tExpectedMap:            map[int]int{1: 1, 2: 2, 3: 3},\n\t},\n\t{\n\t\tM1: mapTest{\n\t\t\tM: map[int]int{},\n\t\t},\n\t\tM2: mapTest{\n\t\t\tM: map[int]int{1: 2, 2: 2},\n\t\t},\n\t\tWithOverrideEmptyValue: true,\n\t\tExpectedMap:            map[int]int{},\n\t},\n\t{\n\t\tM1: mapTest{\n\t\t\tM: map[int]int{},\n\t\t},\n\t\tM2: mapTest{\n\t\t\tM: map[int]int{1: 2, 2: 2},\n\t\t},\n\t\tWithOverrideEmptyValue: false,\n\t\tExpectedMap:            map[int]int{1: 2, 2: 2},\n\t},\n}\n\nfunc withOverrideEmptyValue(enable bool) func(*mergo.Config) {\n\tif enable {\n\t\treturn mergo.WithOverwriteWithEmptyValue\n\t}\n\n\treturn mergo.WithOverride\n}\n\nfunc TestMergeMapWithOverride(t *testing.T) {\n\tt.Parallel()\n\n\tfor _, data := range testDataM {\n\t\terr := mergo.Merge(&data.M2, data.M1, withOverrideEmptyValue(data.WithOverrideEmptyValue))\n\t\tif err != nil {\n\t\t\tt.Errorf(\"Error while merging %s\", err)\n\t\t}\n\n\t\tif len(data.M2.M) != len(data.ExpectedMap) {\n\t\t\tt.Errorf(\"Got %d elements in map, but expected %d\", len(data.M2.M), len(data.ExpectedMap))\n\t\t\treturn\n\t\t}\n\n\t\tfor i, val := range data.M2.M {\n\t\t\tif val != data.ExpectedMap[i] {\n\t\t\t\tt.Errorf(\"Expected value: %d, but got %d while merging map\", data.ExpectedMap[i], val)\n\t\t\t}\n\t\t}\n\t}\n}\n"
        },
        {
          "name": "issue23_test.go",
          "type": "blob",
          "size": 0.61328125,
          "content": "package mergo_test\n\nimport (\n\t\"testing\"\n\t\"time\"\n\n\t\"dario.cat/mergo\"\n)\n\ntype document struct {\n\tCreated *time.Time\n}\n\nfunc TestIssue23MergeWithOverwrite(t *testing.T) {\n\tnow := time.Now()\n\tdst := document{\n\t\t&now,\n\t}\n\texpected := time.Date(2009, time.November, 10, 23, 0, 0, 0, time.UTC)\n\tsrc := document{\n\t\t&expected,\n\t}\n\n\tif err := mergo.MergeWithOverwrite(&dst, src); err != nil {\n\t\tt.Errorf(\"Error while merging %s\", err)\n\t}\n\n\tif !dst.Created.Equal(*src.Created) { //--> https://golang.org/pkg/time/#pkg-overview\n\t\tt.Errorf(\"Created not merged in properly: dst.Created(%v) != src.Created(%v)\", dst.Created, src.Created)\n\t}\n}\n"
        },
        {
          "name": "issue33_test.go",
          "type": "blob",
          "size": 0.93359375,
          "content": "package mergo_test\n\nimport (\n\t\"testing\"\n\n\t\"dario.cat/mergo\"\n)\n\ntype Foo struct {\n\tStr    string\n\tBslice []byte\n}\n\nfunc TestIssue33Merge(t *testing.T) {\n\tdest := Foo{Str: \"a\"}\n\ttoMerge := Foo{\n\t\tStr:    \"b\",\n\t\tBslice: []byte{1, 2},\n\t}\n\n\tif err := mergo.Merge(&dest, toMerge); err != nil {\n\t\tt.Errorf(\"Error while merging: %s\", err)\n\t}\n\t// Merge doesn't overwrite an attribute if in destination it doesn't have a zero value.\n\t// In this case, Str isn't a zero value string.\n\tif dest.Str != \"a\" {\n\t\tt.Errorf(\"dest.Str should have not been override as it has a non-zero value: dest.Str(%v) != 'a'\", dest.Str)\n\t}\n\t// If we want to override, we must use MergeWithOverwrite or Merge using WithOverride.\n\tif err := mergo.Merge(&dest, toMerge, mergo.WithOverride); err != nil {\n\t\tt.Errorf(\"Error while merging: %s\", err)\n\t}\n\n\tif dest.Str != toMerge.Str {\n\t\tt.Errorf(\"dest.Str should have been override: dest.Str(%v) != toMerge.Str(%v)\", dest.Str, toMerge.Str)\n\t}\n}\n"
        },
        {
          "name": "issue38_test.go",
          "type": "blob",
          "size": 1.4638671875,
          "content": "package mergo_test\n\nimport (\n\t\"testing\"\n\t\"time\"\n\n\t\"dario.cat/mergo\"\n)\n\ntype structWithoutTimePointer struct {\n\tCreated time.Time\n}\n\nfunc TestIssue38Merge(t *testing.T) {\n\tdst := structWithoutTimePointer{\n\t\ttime.Now(),\n\t}\n\n\texpected := time.Date(2009, time.November, 10, 23, 0, 0, 0, time.UTC)\n\tsrc := structWithoutTimePointer{\n\t\texpected,\n\t}\n\n\tif err := mergo.Merge(&dst, src); err != nil {\n\t\tt.Errorf(\"Error while merging %s\", err)\n\t}\n\n\tif dst.Created == src.Created {\n\t\tt.Errorf(\"Created merged unexpectedly: dst.Created(%v) == src.Created(%v)\", dst.Created, src.Created)\n\t}\n}\n\nfunc TestIssue38MergeEmptyStruct(t *testing.T) {\n\tdst := structWithoutTimePointer{}\n\n\texpected := time.Date(2009, time.November, 10, 23, 0, 0, 0, time.UTC)\n\tsrc := structWithoutTimePointer{\n\t\texpected,\n\t}\n\n\tif err := mergo.Merge(&dst, src); err != nil {\n\t\tt.Errorf(\"Error while merging %s\", err)\n\t}\n\n\tif dst.Created == src.Created {\n\t\tt.Errorf(\"Created merged unexpectedly: dst.Created(%v) == src.Created(%v)\", dst.Created, src.Created)\n\t}\n}\n\nfunc TestIssue38MergeWithOverwrite(t *testing.T) {\n\tdst := structWithoutTimePointer{\n\t\ttime.Now(),\n\t}\n\n\texpected := time.Date(2009, time.November, 10, 23, 0, 0, 0, time.UTC)\n\tsrc := structWithoutTimePointer{\n\t\texpected,\n\t}\n\n\tif err := mergo.MergeWithOverwrite(&dst, src); err != nil {\n\t\tt.Errorf(\"Error while merging %s\", err)\n\t}\n\n\tif dst.Created != src.Created {\n\t\tt.Errorf(\"Created not merged in properly: dst.Created(%v) != src.Created(%v)\", dst.Created, src.Created)\n\t}\n}\n"
        },
        {
          "name": "issue50_test.go",
          "type": "blob",
          "size": 0.2529296875,
          "content": "package mergo_test\n\nimport (\n\t\"testing\"\n\t\"time\"\n\n\t\"dario.cat/mergo\"\n)\n\ntype testStruct struct {\n\ttime.Duration\n}\n\nfunc TestIssue50Merge(t *testing.T) {\n\tto := testStruct{}\n\tfrom := testStruct{}\n\n\tif err := mergo.Merge(&to, from); err != nil {\n\t\tt.Fail()\n\t}\n}\n"
        },
        {
          "name": "issue52_test.go",
          "type": "blob",
          "size": 2.3779296875,
          "content": "package mergo_test\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n\t\"time\"\n\n\t\"dario.cat/mergo\"\n)\n\ntype structWithTime struct {\n\tBirth time.Time\n}\n\ntype timeTransfomer struct {\n\toverwrite bool\n}\n\nfunc (t timeTransfomer) Transformer(typ reflect.Type) func(dst, src reflect.Value) error {\n\tif typ == reflect.TypeOf(time.Time{}) {\n\t\treturn func(dst, src reflect.Value) error {\n\t\t\tif dst.CanSet() {\n\t\t\t\tif t.overwrite {\n\t\t\t\t\tisZero := src.MethodByName(\"IsZero\")\n\n\t\t\t\t\tresult := isZero.Call([]reflect.Value{})\n\t\t\t\t\tif !result[0].Bool() {\n\t\t\t\t\t\tdst.Set(src)\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tisZero := dst.MethodByName(\"IsZero\")\n\n\t\t\t\t\tresult := isZero.Call([]reflect.Value{})\n\t\t\t\t\tif result[0].Bool() {\n\t\t\t\t\t\tdst.Set(src)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn nil\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc TestOverwriteZeroSrcTime(t *testing.T) {\n\tnow := time.Now()\n\tdst := structWithTime{now}\n\tsrc := structWithTime{}\n\n\tif err := mergo.MergeWithOverwrite(&dst, src); err != nil {\n\t\tt.FailNow()\n\t}\n\n\tif !dst.Birth.IsZero() {\n\t\tt.Errorf(\"dst should have been overwritten: dst.Birth(%v) != now(%v)\", dst.Birth, now)\n\t}\n}\n\nfunc TestOverwriteZeroSrcTimeWithTransformer(t *testing.T) {\n\tnow := time.Now()\n\tdst := structWithTime{now}\n\tsrc := structWithTime{}\n\n\tif err := mergo.MergeWithOverwrite(&dst, src, mergo.WithTransformers(timeTransfomer{true})); err != nil {\n\t\tt.FailNow()\n\t}\n\n\tif dst.Birth.IsZero() {\n\t\tt.Errorf(\"dst should not have been overwritten: dst.Birth(%v) != now(%v)\", dst.Birth, now)\n\t}\n}\n\nfunc TestOverwriteZeroDstTime(t *testing.T) {\n\tnow := time.Now()\n\tdst := structWithTime{}\n\tsrc := structWithTime{now}\n\n\tif err := mergo.MergeWithOverwrite(&dst, src); err != nil {\n\t\tt.FailNow()\n\t}\n\n\tif dst.Birth.IsZero() {\n\t\tt.Errorf(\"dst should have been overwritten: dst.Birth(%v) != zero(%v)\", dst.Birth, time.Time{})\n\t}\n}\n\nfunc TestZeroDstTime(t *testing.T) {\n\tnow := time.Now()\n\tdst := structWithTime{}\n\tsrc := structWithTime{now}\n\n\tif err := mergo.Merge(&dst, src); err != nil {\n\t\tt.FailNow()\n\t}\n\n\tif !dst.Birth.IsZero() {\n\t\tt.Errorf(\"dst should not have been overwritten: dst.Birth(%v) != zero(%v)\", dst.Birth, time.Time{})\n\t}\n}\n\nfunc TestZeroDstTimeWithTransformer(t *testing.T) {\n\tnow := time.Now()\n\tdst := structWithTime{}\n\tsrc := structWithTime{now}\n\n\tif err := mergo.Merge(&dst, src, mergo.WithTransformers(timeTransfomer{})); err != nil {\n\t\tt.FailNow()\n\t}\n\n\tif dst.Birth.IsZero() {\n\t\tt.Errorf(\"dst should have been overwritten: dst.Birth(%v) != now(%v)\", dst.Birth, now)\n\t}\n}\n"
        },
        {
          "name": "issue61_test.go",
          "type": "blob",
          "size": 0.3681640625,
          "content": "package mergo_test\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n\n\t\"dario.cat/mergo\"\n)\n\nfunc TestIssue61MergeNilMap(t *testing.T) {\n\ttype T struct {\n\t\tI map[string][]string\n\t}\n\tt1 := T{}\n\tt2 := T{I: map[string][]string{\"hi\": {\"there\"}}}\n\n\tif err := mergo.Merge(&t1, t2); err != nil {\n\t\tt.Fail()\n\t}\n\n\tif !reflect.DeepEqual(t2, T{I: map[string][]string{\"hi\": {\"there\"}}}) {\n\t\tt.FailNow()\n\t}\n}\n"
        },
        {
          "name": "issue64_test.go",
          "type": "blob",
          "size": 1.16796875,
          "content": "package mergo_test\n\nimport (\n\t\"testing\"\n\n\t\"dario.cat/mergo\"\n)\n\ntype Student struct {\n\tName  string\n\tBooks []string\n}\n\ntype issue64TestData struct {\n\tS1            Student\n\tS2            Student\n\tExpectedSlice []string\n}\n\nfunc issue64Data() []issue64TestData {\n\treturn []issue64TestData{\n\t\t{Student{\"Jack\", []string{\"a\", \"B\"}}, Student{\"Tom\", []string{\"1\"}}, []string{\"a\", \"B\"}},\n\t\t{Student{\"Jack\", []string{\"a\", \"B\"}}, Student{\"Tom\", []string{}}, []string{\"a\", \"B\"}},\n\t\t{Student{\"Jack\", []string{}}, Student{\"Tom\", []string{\"1\"}}, []string{\"1\"}},\n\t\t{Student{\"Jack\", []string{}}, Student{\"Tom\", []string{}}, []string{}},\n\t}\n}\n\nfunc TestIssue64MergeSliceWithOverride(t *testing.T) {\n\tfor _, data := range issue64Data() {\n\t\terr := mergo.Merge(&data.S2, data.S1, mergo.WithOverride)\n\t\tif err != nil {\n\t\t\tt.Errorf(\"Error while merging %s\", err)\n\t\t}\n\n\t\tif len(data.S2.Books) != len(data.ExpectedSlice) {\n\t\t\tt.Errorf(\"Got %d elements in slice, but expected %d\", len(data.S2.Books), len(data.ExpectedSlice))\n\t\t}\n\n\t\tfor i, val := range data.S2.Books {\n\t\t\tif val != data.ExpectedSlice[i] {\n\t\t\t\tt.Errorf(\"Expected %s, but got %s while merging slice with override\", data.ExpectedSlice[i], val)\n\t\t\t}\n\t\t}\n\t}\n}\n"
        },
        {
          "name": "issue66_test.go",
          "type": "blob",
          "size": 1.23046875,
          "content": "package mergo_test\n\nimport (\n\t\"testing\"\n\n\t\"dario.cat/mergo\"\n)\n\ntype PrivateSliceTest66 struct {\n\tPublicStrings  []string\n\tprivateStrings []string\n}\n\nfunc TestPrivateSlice(t *testing.T) {\n\tp1 := PrivateSliceTest66{\n\t\tPublicStrings:  []string{\"one\", \"two\", \"three\"},\n\t\tprivateStrings: []string{\"four\", \"five\"},\n\t}\n\tp2 := PrivateSliceTest66{\n\t\tPublicStrings: []string{\"six\", \"seven\"},\n\t}\n\n\tif err := mergo.Merge(&p1, p2); err != nil {\n\t\tt.Errorf(\"Error during the merge: %v\", err)\n\t}\n\n\tif len(p1.PublicStrings) != 3 {\n\t\tt.Error(\"3 elements should be in 'PublicStrings' field, when no append\")\n\t}\n\n\tif len(p1.privateStrings) != 2 {\n\t\tt.Error(\"2 elements should be in 'privateStrings' field\")\n\t}\n}\n\nfunc TestPrivateSliceWithAppendSlice(t *testing.T) {\n\tp1 := PrivateSliceTest66{\n\t\tPublicStrings:  []string{\"one\", \"two\", \"three\"},\n\t\tprivateStrings: []string{\"four\", \"five\"},\n\t}\n\tp2 := PrivateSliceTest66{\n\t\tPublicStrings: []string{\"six\", \"seven\"},\n\t}\n\n\tif err := mergo.Merge(&p1, p2, mergo.WithAppendSlice); err != nil {\n\t\tt.Errorf(\"Error during the merge: %v\", err)\n\t}\n\n\tif len(p1.PublicStrings) != 5 {\n\t\tt.Error(\"5 elements should be in 'PublicStrings' field\")\n\t}\n\n\tif len(p1.privateStrings) != 2 {\n\t\tt.Error(\"2 elements should be in 'privateStrings' field\")\n\t}\n}\n"
        },
        {
          "name": "issue83_test.go",
          "type": "blob",
          "size": 0.369140625,
          "content": "package mergo_test\n\nimport (\n\t\"testing\"\n\n\t\"dario.cat/mergo\"\n)\n\ntype issue83My struct {\n\tData []int\n}\n\nfunc TestIssue83(t *testing.T) {\n\tdst := issue83My{Data: []int{1, 2, 3}}\n\tnew := issue83My{}\n\tif err := mergo.Merge(&dst, new, mergo.WithOverwriteWithEmptyValue); err != nil {\n\t\tt.Error(err)\n\t}\n\tif len(dst.Data) > 0 {\n\t\tt.Errorf(\"expected empty slice, got %v\", dst.Data)\n\t}\n}\n"
        },
        {
          "name": "issue84_test.go",
          "type": "blob",
          "size": 1.5126953125,
          "content": "package mergo_test\n\nimport (\n\t\"testing\"\n\n\t\"dario.cat/mergo\"\n)\n\ntype DstStructIssue84 struct {\n\tA int\n\tB int\n\tC int\n}\n\ntype DstNestedStructIssue84 struct {\n\tA struct {\n\t\tA int\n\t\tB int\n\t\tC int\n\t}\n\tB int\n\tC int\n}\n\nfunc TestIssue84MergeMapWithNilValueToStructWithOverride(t *testing.T) {\n\tp1 := DstStructIssue84{\n\t\tA: 0, B: 1, C: 2,\n\t}\n\tp2 := map[string]interface{}{\n\t\t\"A\": 3, \"B\": 4, \"C\": 0,\n\t}\n\n\tif err := mergo.Map(&p1, p2, mergo.WithOverride); err != nil {\n\t\tt.Errorf(\"Error during the merge: %v\", err)\n\t}\n\n\tif p1.C != 0 {\n\t\tt.Error(\"C field should become '0'\")\n\t}\n}\n\nfunc TestIssue84MergeMapWithoutKeyExistsToStructWithOverride(t *testing.T) {\n\tp1 := DstStructIssue84{\n\t\tA: 0, B: 1, C: 2,\n\t}\n\tp2 := map[string]interface{}{\n\t\t\"A\": 3, \"B\": 4,\n\t}\n\n\tif err := mergo.Map(&p1, p2, mergo.WithOverride); err != nil {\n\t\tt.Errorf(\"Error during the merge: %v\", err)\n\t}\n\n\tif p1.C != 2 {\n\t\tt.Error(\"C field should be '2'\")\n\t}\n}\n\nfunc TestIssue84MergeNestedMapWithNilValueToStructWithOverride(t *testing.T) {\n\tp1 := DstNestedStructIssue84{\n\t\tA: struct {\n\t\t\tA int\n\t\t\tB int\n\t\t\tC int\n\t\t}{A: 1, B: 2, C: 0},\n\t\tB: 0,\n\t\tC: 2,\n\t}\n\tp2 := map[string]interface{}{\n\t\t\"A\": map[string]interface{}{\n\t\t\t\"A\": 0, \"B\": 0, \"C\": 5,\n\t\t}, \"B\": 4, \"C\": 0,\n\t}\n\n\tif err := mergo.Map(&p1, p2, mergo.WithOverride); err != nil {\n\t\tt.Errorf(\"Error during the merge: %v\", err)\n\t}\n\n\tif p1.B != 4 {\n\t\tt.Error(\"A.C field should become '4'\")\n\t}\n\n\tif p1.A.C != 5 {\n\t\tt.Error(\"A.C field should become '5'\")\n\t}\n\n\tif p1.A.B != 0 || p1.A.A != 0 {\n\t\tt.Error(\"A.A and A.B field should become '0'\")\n\t}\n}\n"
        },
        {
          "name": "issue89_test.go",
          "type": "blob",
          "size": 0.86328125,
          "content": "package mergo_test\n\nimport (\n\t\"testing\"\n\n\t\"dario.cat/mergo\"\n)\n\nfunc TestIssue89Boolean(t *testing.T) {\n\ttype Foo struct {\n\t\tBar bool `json:\"bar\"`\n\t}\n\n\tsrc := Foo{Bar: true}\n\tdst := Foo{Bar: false}\n\n\tif err := mergo.Merge(&dst, src); err != nil {\n\t\tt.Error(err)\n\t}\n\tif dst.Bar == false {\n\t\tt.Errorf(\"expected true, got false\")\n\t}\n}\n\nfunc TestIssue89MergeWithEmptyValue(t *testing.T) {\n\tp1 := map[string]interface{}{\n\t\t\"A\": 3, \"B\": \"note\", \"C\": true,\n\t}\n\tp2 := map[string]interface{}{\n\t\t\"B\": \"\", \"C\": false,\n\t}\n\tif err := mergo.Merge(&p1, p2, mergo.WithOverwriteWithEmptyValue); err != nil {\n\t\tt.Error(err)\n\t}\n\ttestCases := []struct {\n\t\texpected interface{}\n\t\tkey      string\n\t}{\n\t\t{\n\t\t\t\"\",\n\t\t\t\"B\",\n\t\t},\n\t\t{\n\t\t\tfalse,\n\t\t\t\"C\",\n\t\t},\n\t}\n\tfor _, tC := range testCases {\n\t\tif p1[tC.key] != tC.expected {\n\t\t\tt.Errorf(\"expected %v in p1[%q], got %v\", tC.expected, tC.key, p1[tC.key])\n\t\t}\n\t}\n}\n"
        },
        {
          "name": "issue90_test.go",
          "type": "blob",
          "size": 0.6708984375,
          "content": "package mergo_test\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n\n\t\"dario.cat/mergo\"\n)\n\ntype structWithStringMap struct {\n\tData map[string]string\n}\n\nfunc TestIssue90(t *testing.T) {\n\tdst := map[string]structWithStringMap{\n\t\t\"struct\": {\n\t\t\tData: nil,\n\t\t},\n\t}\n\tsrc := map[string]structWithStringMap{\n\t\t\"struct\": {\n\t\t\tData: map[string]string{\n\t\t\t\t\"foo\": \"bar\",\n\t\t\t},\n\t\t},\n\t}\n\texpected := map[string]structWithStringMap{\n\t\t\"struct\": {\n\t\t\tData: map[string]string{\n\t\t\t\t\"foo\": \"bar\",\n\t\t\t},\n\t\t},\n\t}\n\n\terr := mergo.Merge(&dst, src, mergo.WithOverride)\n\tif err != nil {\n\t\tt.Errorf(\"unexpected error %v\", err)\n\t}\n\n\tif !reflect.DeepEqual(dst, expected) {\n\t\tt.Errorf(\"expected: %#v\\ngot: %#v\", expected, dst)\n\t}\n}\n"
        },
        {
          "name": "issueXXX_test.go",
          "type": "blob",
          "size": 1.0712890625,
          "content": "package mergo_test\n\nimport (\n\t\"testing\"\n\n\t\"dario.cat/mergo\"\n)\n\nvar testDataS = []struct {\n\tS1            Student\n\tS2            Student\n\tExpectedSlice []string\n}{\n\t{Student{\"Jack\", []string{\"a\", \"B\"}}, Student{\"Tom\", []string{\"1\"}}, []string{\"1\", \"a\", \"B\"}},\n\t{Student{\"Jack\", []string{\"a\", \"B\"}}, Student{\"Tom\", []string{}}, []string{\"a\", \"B\"}},\n\t{Student{\"Jack\", []string{}}, Student{\"Tom\", []string{\"1\"}}, []string{\"1\"}},\n\t{Student{\"Jack\", []string{}}, Student{\"Tom\", []string{}}, []string{}},\n}\n\nfunc TestMergeSliceWithOverrideWithAppendSlice(t *testing.T) {\n\tfor _, data := range testDataS {\n\t\terr := mergo.Merge(&data.S2, data.S1, mergo.WithOverride, mergo.WithAppendSlice)\n\t\tif err != nil {\n\t\t\tt.Errorf(\"Error while merging %s\", err)\n\t\t}\n\n\t\tif len(data.S2.Books) != len(data.ExpectedSlice) {\n\t\t\tt.Errorf(\"Got %d elements in slice, but expected %d\", len(data.S2.Books), len(data.ExpectedSlice))\n\t\t}\n\n\t\tfor i, val := range data.S2.Books {\n\t\t\tif val != data.ExpectedSlice[i] {\n\t\t\t\tt.Errorf(\"Expected %s, but got %s while merging slice with override\", data.ExpectedSlice[i], val)\n\t\t\t}\n\t\t}\n\t}\n}\n"
        },
        {
          "name": "map.go",
          "type": "blob",
          "size": 5.3779296875,
          "content": "// Copyright 2014 Dario Castañé. All rights reserved.\n// Copyright 2009 The Go Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\n// Based on src/pkg/reflect/deepequal.go from official\n// golang's stdlib.\n\npackage mergo\n\nimport (\n\t\"fmt\"\n\t\"reflect\"\n\t\"unicode\"\n\t\"unicode/utf8\"\n)\n\nfunc changeInitialCase(s string, mapper func(rune) rune) string {\n\tif s == \"\" {\n\t\treturn s\n\t}\n\tr, n := utf8.DecodeRuneInString(s)\n\treturn string(mapper(r)) + s[n:]\n}\n\nfunc isExported(field reflect.StructField) bool {\n\tr, _ := utf8.DecodeRuneInString(field.Name)\n\treturn r >= 'A' && r <= 'Z'\n}\n\n// Traverses recursively both values, assigning src's fields values to dst.\n// The map argument tracks comparisons that have already been seen, which allows\n// short circuiting on recursive types.\nfunc deepMap(dst, src reflect.Value, visited map[uintptr]*visit, depth int, config *Config) (err error) {\n\toverwrite := config.Overwrite\n\tif dst.CanAddr() {\n\t\taddr := dst.UnsafeAddr()\n\t\th := 17 * addr\n\t\tseen := visited[h]\n\t\ttyp := dst.Type()\n\t\tfor p := seen; p != nil; p = p.next {\n\t\t\tif p.ptr == addr && p.typ == typ {\n\t\t\t\treturn nil\n\t\t\t}\n\t\t}\n\t\t// Remember, remember...\n\t\tvisited[h] = &visit{typ, seen, addr}\n\t}\n\tzeroValue := reflect.Value{}\n\tswitch dst.Kind() {\n\tcase reflect.Map:\n\t\tdstMap := dst.Interface().(map[string]interface{})\n\t\tfor i, n := 0, src.NumField(); i < n; i++ {\n\t\t\tsrcType := src.Type()\n\t\t\tfield := srcType.Field(i)\n\t\t\tif !isExported(field) {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tfieldName := field.Name\n\t\t\tfieldName = changeInitialCase(fieldName, unicode.ToLower)\n\t\t\tif _, ok := dstMap[fieldName]; !ok || (!isEmptyValue(reflect.ValueOf(src.Field(i).Interface()), !config.ShouldNotDereference) && overwrite) || config.overwriteWithEmptyValue {\n\t\t\t\tdstMap[fieldName] = src.Field(i).Interface()\n\t\t\t}\n\t\t}\n\tcase reflect.Ptr:\n\t\tif dst.IsNil() {\n\t\t\tv := reflect.New(dst.Type().Elem())\n\t\t\tdst.Set(v)\n\t\t}\n\t\tdst = dst.Elem()\n\t\tfallthrough\n\tcase reflect.Struct:\n\t\tsrcMap := src.Interface().(map[string]interface{})\n\t\tfor key := range srcMap {\n\t\t\tconfig.overwriteWithEmptyValue = true\n\t\t\tsrcValue := srcMap[key]\n\t\t\tfieldName := changeInitialCase(key, unicode.ToUpper)\n\t\t\tdstElement := dst.FieldByName(fieldName)\n\t\t\tif dstElement == zeroValue {\n\t\t\t\t// We discard it because the field doesn't exist.\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tsrcElement := reflect.ValueOf(srcValue)\n\t\t\tdstKind := dstElement.Kind()\n\t\t\tsrcKind := srcElement.Kind()\n\t\t\tif srcKind == reflect.Ptr && dstKind != reflect.Ptr {\n\t\t\t\tsrcElement = srcElement.Elem()\n\t\t\t\tsrcKind = reflect.TypeOf(srcElement.Interface()).Kind()\n\t\t\t} else if dstKind == reflect.Ptr {\n\t\t\t\t// Can this work? I guess it can't.\n\t\t\t\tif srcKind != reflect.Ptr && srcElement.CanAddr() {\n\t\t\t\t\tsrcPtr := srcElement.Addr()\n\t\t\t\t\tsrcElement = reflect.ValueOf(srcPtr)\n\t\t\t\t\tsrcKind = reflect.Ptr\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif !srcElement.IsValid() {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif srcKind == dstKind {\n\t\t\t\tif err = deepMerge(dstElement, srcElement, visited, depth+1, config); err != nil {\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t} else if dstKind == reflect.Interface && dstElement.Kind() == reflect.Interface {\n\t\t\t\tif err = deepMerge(dstElement, srcElement, visited, depth+1, config); err != nil {\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t} else if srcKind == reflect.Map {\n\t\t\t\tif err = deepMap(dstElement, srcElement, visited, depth+1, config); err != nil {\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\treturn fmt.Errorf(\"type mismatch on %s field: found %v, expected %v\", fieldName, srcKind, dstKind)\n\t\t\t}\n\t\t}\n\t}\n\treturn\n}\n\n// Map sets fields' values in dst from src.\n// src can be a map with string keys or a struct. dst must be the opposite:\n// if src is a map, dst must be a valid pointer to struct. If src is a struct,\n// dst must be map[string]interface{}.\n// It won't merge unexported (private) fields and will do recursively\n// any exported field.\n// If dst is a map, keys will be src fields' names in lower camel case.\n// Missing key in src that doesn't match a field in dst will be skipped. This\n// doesn't apply if dst is a map.\n// This is separated method from Merge because it is cleaner and it keeps sane\n// semantics: merging equal types, mapping different (restricted) types.\nfunc Map(dst, src interface{}, opts ...func(*Config)) error {\n\treturn _map(dst, src, opts...)\n}\n\n// MapWithOverwrite will do the same as Map except that non-empty dst attributes will be overridden by\n// non-empty src attribute values.\n// Deprecated: Use Map(…) with WithOverride\nfunc MapWithOverwrite(dst, src interface{}, opts ...func(*Config)) error {\n\treturn _map(dst, src, append(opts, WithOverride)...)\n}\n\nfunc _map(dst, src interface{}, opts ...func(*Config)) error {\n\tif dst != nil && reflect.ValueOf(dst).Kind() != reflect.Ptr {\n\t\treturn ErrNonPointerArgument\n\t}\n\tvar (\n\t\tvDst, vSrc reflect.Value\n\t\terr        error\n\t)\n\tconfig := &Config{}\n\n\tfor _, opt := range opts {\n\t\topt(config)\n\t}\n\n\tif vDst, vSrc, err = resolveValues(dst, src); err != nil {\n\t\treturn err\n\t}\n\t// To be friction-less, we redirect equal-type arguments\n\t// to deepMerge. Only because arguments can be anything.\n\tif vSrc.Kind() == vDst.Kind() {\n\t\treturn deepMerge(vDst, vSrc, make(map[uintptr]*visit), 0, config)\n\t}\n\tswitch vSrc.Kind() {\n\tcase reflect.Struct:\n\t\tif vDst.Kind() != reflect.Map {\n\t\t\treturn ErrExpectedMapAsDestination\n\t\t}\n\tcase reflect.Map:\n\t\tif vDst.Kind() != reflect.Struct {\n\t\t\treturn ErrExpectedStructAsDestination\n\t\t}\n\tdefault:\n\t\treturn ErrNotSupported\n\t}\n\treturn deepMap(vDst, vSrc, make(map[uintptr]*visit), 0, config)\n}\n"
        },
        {
          "name": "merge.go",
          "type": "blob",
          "size": 11.9326171875,
          "content": "// Copyright 2013 Dario Castañé. All rights reserved.\n// Copyright 2009 The Go Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\n// Based on src/pkg/reflect/deepequal.go from official\n// golang's stdlib.\n\npackage mergo\n\nimport (\n\t\"fmt\"\n\t\"reflect\"\n)\n\nfunc hasMergeableFields(dst reflect.Value) (exported bool) {\n\tfor i, n := 0, dst.NumField(); i < n; i++ {\n\t\tfield := dst.Type().Field(i)\n\t\tif field.Anonymous && dst.Field(i).Kind() == reflect.Struct {\n\t\t\texported = exported || hasMergeableFields(dst.Field(i))\n\t\t} else if isExportedComponent(&field) {\n\t\t\texported = exported || len(field.PkgPath) == 0\n\t\t}\n\t}\n\treturn\n}\n\nfunc isExportedComponent(field *reflect.StructField) bool {\n\tpkgPath := field.PkgPath\n\tif len(pkgPath) > 0 {\n\t\treturn false\n\t}\n\tc := field.Name[0]\n\tif 'a' <= c && c <= 'z' || c == '_' {\n\t\treturn false\n\t}\n\treturn true\n}\n\ntype Config struct {\n\tTransformers                 Transformers\n\tOverwrite                    bool\n\tShouldNotDereference         bool\n\tAppendSlice                  bool\n\tTypeCheck                    bool\n\toverwriteWithEmptyValue      bool\n\toverwriteSliceWithEmptyValue bool\n\tsliceDeepCopy                bool\n\tdebug                        bool\n}\n\ntype Transformers interface {\n\tTransformer(reflect.Type) func(dst, src reflect.Value) error\n}\n\n// Traverses recursively both values, assigning src's fields values to dst.\n// The map argument tracks comparisons that have already been seen, which allows\n// short circuiting on recursive types.\nfunc deepMerge(dst, src reflect.Value, visited map[uintptr]*visit, depth int, config *Config) (err error) {\n\toverwrite := config.Overwrite\n\ttypeCheck := config.TypeCheck\n\toverwriteWithEmptySrc := config.overwriteWithEmptyValue\n\toverwriteSliceWithEmptySrc := config.overwriteSliceWithEmptyValue\n\tsliceDeepCopy := config.sliceDeepCopy\n\n\tif !src.IsValid() {\n\t\treturn\n\t}\n\tif dst.CanAddr() {\n\t\taddr := dst.UnsafeAddr()\n\t\th := 17 * addr\n\t\tseen := visited[h]\n\t\ttyp := dst.Type()\n\t\tfor p := seen; p != nil; p = p.next {\n\t\t\tif p.ptr == addr && p.typ == typ {\n\t\t\t\treturn nil\n\t\t\t}\n\t\t}\n\t\t// Remember, remember...\n\t\tvisited[h] = &visit{typ, seen, addr}\n\t}\n\n\tif config.Transformers != nil && !isReflectNil(dst) && dst.IsValid() {\n\t\tif fn := config.Transformers.Transformer(dst.Type()); fn != nil {\n\t\t\terr = fn(dst, src)\n\t\t\treturn\n\t\t}\n\t}\n\n\tswitch dst.Kind() {\n\tcase reflect.Struct:\n\t\tif hasMergeableFields(dst) {\n\t\t\tfor i, n := 0, dst.NumField(); i < n; i++ {\n\t\t\t\tif err = deepMerge(dst.Field(i), src.Field(i), visited, depth+1, config); err != nil {\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tif dst.CanSet() && (isReflectNil(dst) || overwrite) && (!isEmptyValue(src, !config.ShouldNotDereference) || overwriteWithEmptySrc) {\n\t\t\t\tdst.Set(src)\n\t\t\t}\n\t\t}\n\tcase reflect.Map:\n\t\tif dst.IsNil() && !src.IsNil() {\n\t\t\tif dst.CanSet() {\n\t\t\t\tdst.Set(reflect.MakeMap(dst.Type()))\n\t\t\t} else {\n\t\t\t\tdst = src\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\n\t\tif src.Kind() != reflect.Map {\n\t\t\tif overwrite && dst.CanSet() {\n\t\t\t\tdst.Set(src)\n\t\t\t}\n\t\t\treturn\n\t\t}\n\n\t\tfor _, key := range src.MapKeys() {\n\t\t\tsrcElement := src.MapIndex(key)\n\t\t\tif !srcElement.IsValid() {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tdstElement := dst.MapIndex(key)\n\t\t\tswitch srcElement.Kind() {\n\t\t\tcase reflect.Chan, reflect.Func, reflect.Map, reflect.Interface, reflect.Slice:\n\t\t\t\tif srcElement.IsNil() {\n\t\t\t\t\tif overwrite {\n\t\t\t\t\t\tdst.SetMapIndex(key, srcElement)\n\t\t\t\t\t}\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\tfallthrough\n\t\t\tdefault:\n\t\t\t\tif !srcElement.CanInterface() {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\tswitch reflect.TypeOf(srcElement.Interface()).Kind() {\n\t\t\t\tcase reflect.Struct:\n\t\t\t\t\tfallthrough\n\t\t\t\tcase reflect.Ptr:\n\t\t\t\t\tfallthrough\n\t\t\t\tcase reflect.Map:\n\t\t\t\t\tsrcMapElm := srcElement\n\t\t\t\t\tdstMapElm := dstElement\n\t\t\t\t\tif srcMapElm.CanInterface() {\n\t\t\t\t\t\tsrcMapElm = reflect.ValueOf(srcMapElm.Interface())\n\t\t\t\t\t\tif dstMapElm.IsValid() {\n\t\t\t\t\t\t\tdstMapElm = reflect.ValueOf(dstMapElm.Interface())\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif err = deepMerge(dstMapElm, srcMapElm, visited, depth+1, config); err != nil {\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\tcase reflect.Slice:\n\t\t\t\t\tsrcSlice := reflect.ValueOf(srcElement.Interface())\n\n\t\t\t\t\tvar dstSlice reflect.Value\n\t\t\t\t\tif !dstElement.IsValid() || dstElement.IsNil() {\n\t\t\t\t\t\tdstSlice = reflect.MakeSlice(srcSlice.Type(), 0, srcSlice.Len())\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdstSlice = reflect.ValueOf(dstElement.Interface())\n\t\t\t\t\t}\n\n\t\t\t\t\tif (!isEmptyValue(src, !config.ShouldNotDereference) || overwriteWithEmptySrc || overwriteSliceWithEmptySrc) && (overwrite || isEmptyValue(dst, !config.ShouldNotDereference)) && !config.AppendSlice && !sliceDeepCopy {\n\t\t\t\t\t\tif typeCheck && srcSlice.Type() != dstSlice.Type() {\n\t\t\t\t\t\t\treturn fmt.Errorf(\"cannot override two slices with different type (%s, %s)\", srcSlice.Type(), dstSlice.Type())\n\t\t\t\t\t\t}\n\t\t\t\t\t\tdstSlice = srcSlice\n\t\t\t\t\t} else if config.AppendSlice {\n\t\t\t\t\t\tif srcSlice.Type() != dstSlice.Type() {\n\t\t\t\t\t\t\treturn fmt.Errorf(\"cannot append two slices with different type (%s, %s)\", srcSlice.Type(), dstSlice.Type())\n\t\t\t\t\t\t}\n\t\t\t\t\t\tdstSlice = reflect.AppendSlice(dstSlice, srcSlice)\n\t\t\t\t\t} else if sliceDeepCopy {\n\t\t\t\t\t\ti := 0\n\t\t\t\t\t\tfor ; i < srcSlice.Len() && i < dstSlice.Len(); i++ {\n\t\t\t\t\t\t\tsrcElement := srcSlice.Index(i)\n\t\t\t\t\t\t\tdstElement := dstSlice.Index(i)\n\n\t\t\t\t\t\t\tif srcElement.CanInterface() {\n\t\t\t\t\t\t\t\tsrcElement = reflect.ValueOf(srcElement.Interface())\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif dstElement.CanInterface() {\n\t\t\t\t\t\t\t\tdstElement = reflect.ValueOf(dstElement.Interface())\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif err = deepMerge(dstElement, srcElement, visited, depth+1, config); err != nil {\n\t\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\t\t\t\t\tdst.SetMapIndex(key, dstSlice)\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif dstElement.IsValid() && !isEmptyValue(dstElement, !config.ShouldNotDereference) {\n\t\t\t\tif reflect.TypeOf(srcElement.Interface()).Kind() == reflect.Slice {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\tif reflect.TypeOf(srcElement.Interface()).Kind() == reflect.Map && reflect.TypeOf(dstElement.Interface()).Kind() == reflect.Map {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif srcElement.IsValid() && ((srcElement.Kind() != reflect.Ptr && overwrite) || !dstElement.IsValid() || isEmptyValue(dstElement, !config.ShouldNotDereference)) {\n\t\t\t\tif dst.IsNil() {\n\t\t\t\t\tdst.Set(reflect.MakeMap(dst.Type()))\n\t\t\t\t}\n\t\t\t\tdst.SetMapIndex(key, srcElement)\n\t\t\t}\n\t\t}\n\n\t\t// Ensure that all keys in dst are deleted if they are not in src.\n\t\tif overwriteWithEmptySrc {\n\t\t\tfor _, key := range dst.MapKeys() {\n\t\t\t\tsrcElement := src.MapIndex(key)\n\t\t\t\tif !srcElement.IsValid() {\n\t\t\t\t\tdst.SetMapIndex(key, reflect.Value{})\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\tcase reflect.Slice:\n\t\tif !dst.CanSet() {\n\t\t\tbreak\n\t\t}\n\t\tif (!isEmptyValue(src, !config.ShouldNotDereference) || overwriteWithEmptySrc || overwriteSliceWithEmptySrc) && (overwrite || isEmptyValue(dst, !config.ShouldNotDereference)) && !config.AppendSlice && !sliceDeepCopy {\n\t\t\tdst.Set(src)\n\t\t} else if config.AppendSlice {\n\t\t\tif src.Type() != dst.Type() {\n\t\t\t\treturn fmt.Errorf(\"cannot append two slice with different type (%s, %s)\", src.Type(), dst.Type())\n\t\t\t}\n\t\t\tdst.Set(reflect.AppendSlice(dst, src))\n\t\t} else if sliceDeepCopy {\n\t\t\tfor i := 0; i < src.Len() && i < dst.Len(); i++ {\n\t\t\t\tsrcElement := src.Index(i)\n\t\t\t\tdstElement := dst.Index(i)\n\t\t\t\tif srcElement.CanInterface() {\n\t\t\t\t\tsrcElement = reflect.ValueOf(srcElement.Interface())\n\t\t\t\t}\n\t\t\t\tif dstElement.CanInterface() {\n\t\t\t\t\tdstElement = reflect.ValueOf(dstElement.Interface())\n\t\t\t\t}\n\n\t\t\t\tif err = deepMerge(dstElement, srcElement, visited, depth+1, config); err != nil {\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\tcase reflect.Ptr:\n\t\tfallthrough\n\tcase reflect.Interface:\n\t\tif isReflectNil(src) {\n\t\t\tif overwriteWithEmptySrc && dst.CanSet() && src.Type().AssignableTo(dst.Type()) {\n\t\t\t\tdst.Set(src)\n\t\t\t}\n\t\t\tbreak\n\t\t}\n\n\t\tif src.Kind() != reflect.Interface {\n\t\t\tif dst.IsNil() || (src.Kind() != reflect.Ptr && overwrite) {\n\t\t\t\tif dst.CanSet() && (overwrite || isEmptyValue(dst, !config.ShouldNotDereference)) {\n\t\t\t\t\tdst.Set(src)\n\t\t\t\t}\n\t\t\t} else if src.Kind() == reflect.Ptr {\n\t\t\t\tif !config.ShouldNotDereference {\n\t\t\t\t\tif err = deepMerge(dst.Elem(), src.Elem(), visited, depth+1, config); err != nil {\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t} else if src.Elem().Kind() != reflect.Struct {\n\t\t\t\t\tif overwriteWithEmptySrc || (overwrite && !src.IsNil()) || dst.IsNil() {\n\t\t\t\t\t\tdst.Set(src)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if dst.Elem().Type() == src.Type() {\n\t\t\t\tif err = deepMerge(dst.Elem(), src, visited, depth+1, config); err != nil {\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\treturn ErrDifferentArgumentsTypes\n\t\t\t}\n\t\t\tbreak\n\t\t}\n\n\t\tif dst.IsNil() || overwrite {\n\t\t\tif dst.CanSet() && (overwrite || isEmptyValue(dst, !config.ShouldNotDereference)) {\n\t\t\t\tdst.Set(src)\n\t\t\t}\n\t\t\tbreak\n\t\t}\n\n\t\tif dst.Elem().Kind() == src.Elem().Kind() {\n\t\t\tif err = deepMerge(dst.Elem(), src.Elem(), visited, depth+1, config); err != nil {\n\t\t\t\treturn\n\t\t\t}\n\t\t\tbreak\n\t\t}\n\tdefault:\n\t\tmustSet := (isEmptyValue(dst, !config.ShouldNotDereference) || overwrite) && (!isEmptyValue(src, !config.ShouldNotDereference) || overwriteWithEmptySrc)\n\t\tif mustSet {\n\t\t\tif dst.CanSet() {\n\t\t\t\tdst.Set(src)\n\t\t\t} else {\n\t\t\t\tdst = src\n\t\t\t}\n\t\t}\n\t}\n\n\treturn\n}\n\n// Merge will fill any empty for value type attributes on the dst struct using corresponding\n// src attributes if they themselves are not empty. dst and src must be valid same-type structs\n// and dst must be a pointer to struct.\n// It won't merge unexported (private) fields and will do recursively any exported field.\nfunc Merge(dst, src interface{}, opts ...func(*Config)) error {\n\treturn merge(dst, src, opts...)\n}\n\n// MergeWithOverwrite will do the same as Merge except that non-empty dst attributes will be overridden by\n// non-empty src attribute values.\n// Deprecated: use Merge(…) with WithOverride\nfunc MergeWithOverwrite(dst, src interface{}, opts ...func(*Config)) error {\n\treturn merge(dst, src, append(opts, WithOverride)...)\n}\n\n// WithTransformers adds transformers to merge, allowing to customize the merging of some types.\nfunc WithTransformers(transformers Transformers) func(*Config) {\n\treturn func(config *Config) {\n\t\tconfig.Transformers = transformers\n\t}\n}\n\n// WithOverride will make merge override non-empty dst attributes with non-empty src attributes values.\nfunc WithOverride(config *Config) {\n\tconfig.Overwrite = true\n}\n\n// WithOverwriteWithEmptyValue will make merge override non empty dst attributes with empty src attributes values.\nfunc WithOverwriteWithEmptyValue(config *Config) {\n\tconfig.Overwrite = true\n\tconfig.overwriteWithEmptyValue = true\n}\n\n// WithOverrideEmptySlice will make merge override empty dst slice with empty src slice.\nfunc WithOverrideEmptySlice(config *Config) {\n\tconfig.overwriteSliceWithEmptyValue = true\n}\n\n// WithoutDereference prevents dereferencing pointers when evaluating whether they are empty\n// (i.e. a non-nil pointer is never considered empty).\nfunc WithoutDereference(config *Config) {\n\tconfig.ShouldNotDereference = true\n}\n\n// WithAppendSlice will make merge append slices instead of overwriting it.\nfunc WithAppendSlice(config *Config) {\n\tconfig.AppendSlice = true\n}\n\n// WithTypeCheck will make merge check types while overwriting it (must be used with WithOverride).\nfunc WithTypeCheck(config *Config) {\n\tconfig.TypeCheck = true\n}\n\n// WithSliceDeepCopy will merge slice element one by one with Overwrite flag.\nfunc WithSliceDeepCopy(config *Config) {\n\tconfig.sliceDeepCopy = true\n\tconfig.Overwrite = true\n}\n\nfunc merge(dst, src interface{}, opts ...func(*Config)) error {\n\tif dst != nil && reflect.ValueOf(dst).Kind() != reflect.Ptr {\n\t\treturn ErrNonPointerArgument\n\t}\n\tvar (\n\t\tvDst, vSrc reflect.Value\n\t\terr        error\n\t)\n\n\tconfig := &Config{}\n\n\tfor _, opt := range opts {\n\t\topt(config)\n\t}\n\n\tif vDst, vSrc, err = resolveValues(dst, src); err != nil {\n\t\treturn err\n\t}\n\tif vDst.Type() != vSrc.Type() {\n\t\treturn ErrDifferentArgumentsTypes\n\t}\n\treturn deepMerge(vDst, vSrc, make(map[uintptr]*visit), 0, config)\n}\n\n// IsReflectNil is the reflect value provided nil\nfunc isReflectNil(v reflect.Value) bool {\n\tk := v.Kind()\n\tswitch k {\n\tcase reflect.Interface, reflect.Slice, reflect.Chan, reflect.Func, reflect.Map, reflect.Ptr:\n\t\t// Both interface and slice are nil if first word is 0.\n\t\t// Both are always bigger than a word; assume flagIndir.\n\t\treturn v.IsNil()\n\tdefault:\n\t\treturn false\n\t}\n}\n"
        },
        {
          "name": "merge_test.go",
          "type": "blob",
          "size": 1.609375,
          "content": "package mergo_test\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n\n\t\"dario.cat/mergo\"\n)\n\ntype transformer struct {\n\tm map[reflect.Type]func(dst, src reflect.Value) error\n}\n\nfunc (s *transformer) Transformer(t reflect.Type) func(dst, src reflect.Value) error {\n\tif fn, ok := s.m[t]; ok {\n\t\treturn fn\n\t}\n\treturn nil\n}\n\ntype foo struct {\n\tBar *bar\n\ts   string\n}\n\ntype bar struct {\n\ts map[string]string\n\ti int\n}\n\nfunc TestMergeWithTransformerNilStruct(t *testing.T) {\n\ta := foo{s: \"foo\"}\n\tb := foo{Bar: &bar{i: 2, s: map[string]string{\"foo\": \"bar\"}}}\n\n\tif err := mergo.Merge(&a, &b, mergo.WithOverride, mergo.WithTransformers(&transformer{\n\t\tm: map[reflect.Type]func(dst, src reflect.Value) error{\n\t\t\treflect.TypeOf(&bar{}): func(dst, src reflect.Value) error {\n\t\t\t\t// Do sthg with Elem\n\t\t\t\tt.Log(dst.Elem().FieldByName(\"i\"))\n\t\t\t\tt.Log(src.Elem())\n\t\t\t\treturn nil\n\t\t\t},\n\t\t},\n\t})); err != nil {\n\t\tt.Error(err)\n\t}\n\n\tif a.s != \"foo\" {\n\t\tt.Errorf(\"b not merged in properly: a.s.Value(%s) != expected(%s)\", a.s, \"foo\")\n\t}\n\n\tif a.Bar == nil {\n\t\tt.Errorf(\"b not merged in properly: a.Bar shouldn't be nil\")\n\t}\n}\n\nfunc TestMergeNonPointer(t *testing.T) {\n\tdst := bar{\n\t\ti: 1,\n\t}\n\tsrc := bar{\n\t\ti: 2,\n\t\ts: map[string]string{\n\t\t\t\"a\": \"1\",\n\t\t},\n\t}\n\twant := mergo.ErrNonPointerArgument\n\n\tif got := mergo.Merge(dst, src); got != want {\n\t\tt.Errorf(\"want: %s, got: %s\", want, got)\n\t}\n}\n\nfunc TestMapNonPointer(t *testing.T) {\n\tdst := make(map[string]bar)\n\tsrc := map[string]bar{\n\t\t\"a\": {\n\t\t\ti: 2,\n\t\t\ts: map[string]string{\n\t\t\t\t\"a\": \"1\",\n\t\t\t},\n\t\t},\n\t}\n\twant := mergo.ErrNonPointerArgument\n\tif got := mergo.Merge(dst, src); got != want {\n\t\tt.Errorf(\"want: %s, got: %s\", want, got)\n\t}\n}\n"
        },
        {
          "name": "mergo.go",
          "type": "blob",
          "size": 2.3994140625,
          "content": "// Copyright 2013 Dario Castañé. All rights reserved.\n// Copyright 2009 The Go Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\n// Based on src/pkg/reflect/deepequal.go from official\n// golang's stdlib.\n\npackage mergo\n\nimport (\n\t\"errors\"\n\t\"reflect\"\n)\n\n// Errors reported by Mergo when it finds invalid arguments.\nvar (\n\tErrNilArguments                = errors.New(\"src and dst must not be nil\")\n\tErrDifferentArgumentsTypes     = errors.New(\"src and dst must be of same type\")\n\tErrNotSupported                = errors.New(\"only structs, maps, and slices are supported\")\n\tErrExpectedMapAsDestination    = errors.New(\"dst was expected to be a map\")\n\tErrExpectedStructAsDestination = errors.New(\"dst was expected to be a struct\")\n\tErrNonPointerArgument          = errors.New(\"dst must be a pointer\")\n)\n\n// During deepMerge, must keep track of checks that are\n// in progress.  The comparison algorithm assumes that all\n// checks in progress are true when it reencounters them.\n// Visited are stored in a map indexed by 17 * a1 + a2;\ntype visit struct {\n\ttyp  reflect.Type\n\tnext *visit\n\tptr  uintptr\n}\n\n// From src/pkg/encoding/json/encode.go.\nfunc isEmptyValue(v reflect.Value, shouldDereference bool) bool {\n\tswitch v.Kind() {\n\tcase reflect.Array, reflect.Map, reflect.Slice, reflect.String:\n\t\treturn v.Len() == 0\n\tcase reflect.Bool:\n\t\treturn !v.Bool()\n\tcase reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:\n\t\treturn v.Int() == 0\n\tcase reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64, reflect.Uintptr:\n\t\treturn v.Uint() == 0\n\tcase reflect.Float32, reflect.Float64:\n\t\treturn v.Float() == 0\n\tcase reflect.Interface, reflect.Ptr:\n\t\tif v.IsNil() {\n\t\t\treturn true\n\t\t}\n\t\tif shouldDereference {\n\t\t\treturn isEmptyValue(v.Elem(), shouldDereference)\n\t\t}\n\t\treturn false\n\tcase reflect.Func:\n\t\treturn v.IsNil()\n\tcase reflect.Invalid:\n\t\treturn true\n\t}\n\treturn false\n}\n\nfunc resolveValues(dst, src interface{}) (vDst, vSrc reflect.Value, err error) {\n\tif dst == nil || src == nil {\n\t\terr = ErrNilArguments\n\t\treturn\n\t}\n\tvDst = reflect.ValueOf(dst).Elem()\n\tif vDst.Kind() != reflect.Struct && vDst.Kind() != reflect.Map && vDst.Kind() != reflect.Slice {\n\t\terr = ErrNotSupported\n\t\treturn\n\t}\n\tvSrc = reflect.ValueOf(src)\n\t// We check if vSrc is a pointer to dereference it.\n\tif vSrc.Kind() == reflect.Ptr {\n\t\tvSrc = vSrc.Elem()\n\t}\n\treturn\n}\n"
        },
        {
          "name": "mergo_test.go",
          "type": "blob",
          "size": 20.978515625,
          "content": "// Copyright 2013 Dario Castañé. All rights reserved.\n// Copyright 2009 The Go Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage mergo_test\n\nimport (\n\t\"io/ioutil\"\n\t\"reflect\"\n\t\"strings\"\n\t\"testing\"\n\t\"time\"\n\n\t\"dario.cat/mergo\"\n\t\"gopkg.in/yaml.v3\"\n)\n\ntype simpleTest struct {\n\tValue int\n}\n\ntype complexTest struct {\n\tID string\n\tSt simpleTest\n\tsz int\n}\n\ntype mapTest struct {\n\tM map[int]int\n}\n\ntype ifcTest struct {\n\tI interface{}\n}\n\ntype moreComplextText struct {\n\tCt complexTest\n\tSt simpleTest\n\tNt simpleTest\n}\n\ntype pointerTest struct {\n\tC *simpleTest\n}\n\ntype sliceTest struct {\n\tS []int\n}\n\nfunc TestKb(t *testing.T) {\n\ttype testStruct struct {\n\t\tKeyValue map[string]interface{}\n\t\tName     string\n\t}\n\n\takv := make(map[string]interface{})\n\takv[\"Key1\"] = \"not value 1\"\n\takv[\"Key2\"] = \"value2\"\n\ta := testStruct{}\n\ta.Name = \"A\"\n\ta.KeyValue = akv\n\n\tbkv := make(map[string]interface{})\n\tbkv[\"Key1\"] = \"value1\"\n\tbkv[\"Key3\"] = \"value3\"\n\tb := testStruct{}\n\tb.Name = \"B\"\n\tb.KeyValue = bkv\n\n\tekv := make(map[string]interface{})\n\tekv[\"Key1\"] = \"value1\"\n\tekv[\"Key2\"] = \"value2\"\n\tekv[\"Key3\"] = \"value3\"\n\texpected := testStruct{}\n\texpected.Name = \"B\"\n\texpected.KeyValue = ekv\n\n\tif err := mergo.Merge(&b, a); err != nil {\n\t\tt.Error(err)\n\t}\n\n\tif !reflect.DeepEqual(b, expected) {\n\t\tt.Errorf(\"Actual: %#v did not match \\nExpected: %#v\", b, expected)\n\t}\n}\n\nfunc TestNil(t *testing.T) {\n\tif err := mergo.Merge(nil, nil); err != mergo.ErrNilArguments {\n\t\tt.Fail()\n\t}\n}\n\nfunc TestDifferentTypes(t *testing.T) {\n\ta := simpleTest{42}\n\tb := 42\n\tif err := mergo.Merge(&a, b); err != mergo.ErrDifferentArgumentsTypes {\n\t\tt.Fail()\n\t}\n}\n\nfunc TestSimpleStruct(t *testing.T) {\n\ta := simpleTest{}\n\tb := simpleTest{42}\n\tif err := mergo.Merge(&a, b); err != nil {\n\t\tt.FailNow()\n\t}\n\tif a.Value != 42 {\n\t\tt.Errorf(\"b not merged in properly: a.Value(%d) != b.Value(%d)\", a.Value, b.Value)\n\t}\n\tif !reflect.DeepEqual(a, b) {\n\t\tt.FailNow()\n\t}\n}\n\nfunc TestComplexStruct(t *testing.T) {\n\ta := complexTest{}\n\ta.ID = \"athing\"\n\tb := complexTest{\"bthing\", simpleTest{42}, 1}\n\tif err := mergo.Merge(&a, b); err != nil {\n\t\tt.FailNow()\n\t}\n\tif a.St.Value != 42 {\n\t\tt.Errorf(\"b not merged in properly: a.St.Value(%d) != b.St.Value(%d)\", a.St.Value, b.St.Value)\n\t}\n\tif a.sz == 1 {\n\t\tt.Errorf(\"a's private field sz not preserved from merge: a.sz(%d) == b.sz(%d)\", a.sz, b.sz)\n\t}\n\tif a.ID == b.ID {\n\t\tt.Errorf(\"a's field ID merged unexpectedly: a.ID(%s) == b.ID(%s)\", a.ID, b.ID)\n\t}\n}\n\nfunc TestComplexStructWithOverwrite(t *testing.T) {\n\ta := complexTest{\"do-not-overwrite-with-empty-value\", simpleTest{1}, 1}\n\tb := complexTest{\"\", simpleTest{42}, 2}\n\n\texpect := complexTest{\"do-not-overwrite-with-empty-value\", simpleTest{42}, 1}\n\tif err := mergo.MergeWithOverwrite(&a, b); err != nil {\n\t\tt.FailNow()\n\t}\n\n\tif !reflect.DeepEqual(a, expect) {\n\t\tt.Errorf(\"Test failed:\\ngot  :\\n%#v\\n\\nwant :\\n%#v\\n\\n\", a, expect)\n\t}\n}\n\nfunc TestPointerStruct(t *testing.T) {\n\ts1 := simpleTest{}\n\ts2 := simpleTest{19}\n\ta := pointerTest{&s1}\n\tb := pointerTest{&s2}\n\tif err := mergo.Merge(&a, b); err != nil {\n\t\tt.FailNow()\n\t}\n\tif a.C.Value != b.C.Value {\n\t\tt.Errorf(\"b not merged in properly: a.C.Value(%d) != b.C.Value(%d)\", a.C.Value, b.C.Value)\n\t}\n}\n\ntype embeddingStruct struct {\n\tembeddedStruct\n}\n\ntype embeddedStruct struct {\n\tA string\n}\n\nfunc TestEmbeddedStruct(t *testing.T) {\n\ttests := []struct {\n\t\tsrc      embeddingStruct\n\t\tdst      embeddingStruct\n\t\texpected embeddingStruct\n\t}{\n\t\t{\n\t\t\tsrc: embeddingStruct{\n\t\t\t\tembeddedStruct{\"foo\"},\n\t\t\t},\n\t\t\tdst: embeddingStruct{\n\t\t\t\tembeddedStruct{\"\"},\n\t\t\t},\n\t\t\texpected: embeddingStruct{\n\t\t\t\tembeddedStruct{\"foo\"},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tsrc: embeddingStruct{\n\t\t\t\tembeddedStruct{\"\"},\n\t\t\t},\n\t\t\tdst: embeddingStruct{\n\t\t\t\tembeddedStruct{\"bar\"},\n\t\t\t},\n\t\t\texpected: embeddingStruct{\n\t\t\t\tembeddedStruct{\"bar\"},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tsrc: embeddingStruct{\n\t\t\t\tembeddedStruct{\"foo\"},\n\t\t\t},\n\t\t\tdst: embeddingStruct{\n\t\t\t\tembeddedStruct{\"bar\"},\n\t\t\t},\n\t\t\texpected: embeddingStruct{\n\t\t\t\tembeddedStruct{\"bar\"},\n\t\t\t},\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\terr := mergo.Merge(&test.dst, test.src)\n\t\tif err != nil {\n\t\t\tt.Errorf(\"unexpected error: %v\", err)\n\t\t\tcontinue\n\t\t}\n\t\tif !reflect.DeepEqual(test.dst, test.expected) {\n\t\t\tt.Errorf(\"unexpected output\\nexpected:\\n%+v\\nsaw:\\n%+v\\n\", test.expected, test.dst)\n\t\t}\n\t}\n}\n\nfunc TestPointerStructNil(t *testing.T) {\n\ta := pointerTest{nil}\n\tb := pointerTest{&simpleTest{19}}\n\tif err := mergo.Merge(&a, b); err != nil {\n\t\tt.FailNow()\n\t}\n\tif a.C.Value != b.C.Value {\n\t\tt.Errorf(\"b not merged in a properly: a.C.Value(%d) != b.C.Value(%d)\", a.C.Value, b.C.Value)\n\t}\n}\n\nfunc testSlice(t *testing.T, a []int, b []int, e []int, opts ...func(*mergo.Config)) {\n\tt.Helper()\n\tbc := b\n\n\tsa := sliceTest{a}\n\tsb := sliceTest{b}\n\tif err := mergo.Merge(&sa, sb, opts...); err != nil {\n\t\tt.FailNow()\n\t}\n\tif !reflect.DeepEqual(sb.S, bc) {\n\t\tt.Errorf(\"Source slice was modified %d != %d\", sb.S, bc)\n\t}\n\tif !reflect.DeepEqual(sa.S, e) {\n\t\tt.Errorf(\"b not merged in a proper way %d != %d\", sa.S, e)\n\t}\n\n\tma := map[string][]int{\"S\": a}\n\tmb := map[string][]int{\"S\": b}\n\tif err := mergo.Merge(&ma, mb, opts...); err != nil {\n\t\tt.FailNow()\n\t}\n\tif !reflect.DeepEqual(mb[\"S\"], bc) {\n\t\tt.Errorf(\"map value: Source slice was modified %d != %d\", mb[\"S\"], bc)\n\t}\n\tif !reflect.DeepEqual(ma[\"S\"], e) {\n\t\tt.Errorf(\"map value: b not merged in a proper way %d != %d\", ma[\"S\"], e)\n\t}\n\n\tif a == nil {\n\t\t// test case with missing dst key\n\t\tma := map[string][]int{}\n\t\tmb := map[string][]int{\"S\": b}\n\t\tif err := mergo.Merge(&ma, mb); err != nil {\n\t\t\tt.FailNow()\n\t\t}\n\t\tif !reflect.DeepEqual(mb[\"S\"], bc) {\n\t\t\tt.Errorf(\"missing dst key: Source slice was modified %d != %d\", mb[\"S\"], bc)\n\t\t}\n\t\tif !reflect.DeepEqual(ma[\"S\"], e) {\n\t\t\tt.Errorf(\"missing dst key: b not merged in a proper way %d != %d\", ma[\"S\"], e)\n\t\t}\n\t}\n\n\tif b == nil {\n\t\t// test case with missing src key\n\t\tma := map[string][]int{\"S\": a}\n\t\tmb := map[string][]int{}\n\t\tif err := mergo.Merge(&ma, mb); err != nil {\n\t\t\tt.FailNow()\n\t\t}\n\t\tif !reflect.DeepEqual(mb[\"S\"], bc) {\n\t\t\tt.Errorf(\"missing src key: Source slice was modified %d != %d\", mb[\"S\"], bc)\n\t\t}\n\t\tif !reflect.DeepEqual(ma[\"S\"], e) {\n\t\t\tt.Errorf(\"missing src key: b not merged in a proper way %d != %d\", ma[\"S\"], e)\n\t\t}\n\t}\n}\n\nfunc TestSlice(t *testing.T) {\n\ttestSlice(t, nil, []int{1, 2, 3}, []int{1, 2, 3})\n\ttestSlice(t, []int{}, []int{1, 2, 3}, []int{1, 2, 3})\n\ttestSlice(t, []int{1}, []int{2, 3}, []int{1})\n\ttestSlice(t, []int{1}, []int{}, []int{1})\n\ttestSlice(t, []int{1}, nil, []int{1})\n\ttestSlice(t, nil, []int{1, 2, 3}, []int{1, 2, 3}, mergo.WithAppendSlice)\n\ttestSlice(t, []int{}, []int{1, 2, 3}, []int{1, 2, 3}, mergo.WithAppendSlice)\n\ttestSlice(t, []int{1}, []int{2, 3}, []int{1, 2, 3}, mergo.WithAppendSlice)\n\ttestSlice(t, []int{1}, []int{2, 3}, []int{1, 2, 3}, mergo.WithAppendSlice, mergo.WithOverride)\n\ttestSlice(t, []int{1}, []int{}, []int{1}, mergo.WithAppendSlice)\n\ttestSlice(t, []int{1}, nil, []int{1}, mergo.WithAppendSlice)\n}\n\nfunc TestEmptyMaps(t *testing.T) {\n\ta := mapTest{}\n\tb := mapTest{\n\t\tmap[int]int{},\n\t}\n\tif err := mergo.Merge(&a, b); err != nil {\n\t\tt.Fail()\n\t}\n\tif !reflect.DeepEqual(a, b) {\n\t\tt.FailNow()\n\t}\n}\n\nfunc TestEmptyToEmptyMaps(t *testing.T) {\n\ta := mapTest{}\n\tb := mapTest{}\n\tif err := mergo.Merge(&a, b); err != nil {\n\t\tt.Fail()\n\t}\n\tif !reflect.DeepEqual(a, b) {\n\t\tt.FailNow()\n\t}\n}\n\nfunc TestEmptyToNotEmptyMaps(t *testing.T) {\n\ta := mapTest{map[int]int{\n\t\t1: 2,\n\t\t3: 4,\n\t}}\n\taa := mapTest{map[int]int{\n\t\t1: 2,\n\t\t3: 4,\n\t}}\n\tb := mapTest{\n\t\tmap[int]int{},\n\t}\n\tif err := mergo.Merge(&a, b); err != nil {\n\t\tt.Fail()\n\t}\n\tif !reflect.DeepEqual(a, aa) {\n\t\tt.FailNow()\n\t}\n}\n\nfunc TestMapsWithOverwrite(t *testing.T) {\n\tm := map[string]simpleTest{\n\t\t\"a\": {},   // overwritten by 16\n\t\t\"b\": {42}, // overwritten by 0, as map Value is not addressable and it doesn't check for b is set or not set in `n`\n\t\t\"c\": {13}, // overwritten by 12\n\t\t\"d\": {61},\n\t}\n\tn := map[string]simpleTest{\n\t\t\"a\": {16},\n\t\t\"b\": {},\n\t\t\"c\": {12},\n\t\t\"e\": {14},\n\t}\n\texpect := map[string]simpleTest{\n\t\t\"a\": {16},\n\t\t\"b\": {},\n\t\t\"c\": {12},\n\t\t\"d\": {61},\n\t\t\"e\": {14},\n\t}\n\n\tif err := mergo.MergeWithOverwrite(&m, n); err != nil {\n\t\tt.Errorf(err.Error())\n\t}\n\n\tif !reflect.DeepEqual(m, expect) {\n\t\tt.Errorf(\"Test failed:\\ngot  :\\n%#v\\n\\nwant :\\n%#v\\n\\n\", m, expect)\n\t}\n}\n\nfunc TestMapWithEmbeddedStructPointer(t *testing.T) {\n\tm := map[string]*simpleTest{\n\t\t\"a\": {},   // overwritten by 16\n\t\t\"b\": {42}, // not overwritten by empty value\n\t\t\"c\": {13}, // overwritten by 12\n\t\t\"d\": {61},\n\t}\n\tn := map[string]*simpleTest{\n\t\t\"a\": {16},\n\t\t\"b\": {},\n\t\t\"c\": {12},\n\t\t\"e\": {14},\n\t}\n\texpect := map[string]*simpleTest{\n\t\t\"a\": {16},\n\t\t\"b\": {42},\n\t\t\"c\": {12},\n\t\t\"d\": {61},\n\t\t\"e\": {14},\n\t}\n\n\tif err := mergo.Merge(&m, n, mergo.WithOverride); err != nil {\n\t\tt.Errorf(err.Error())\n\t}\n\n\tif !reflect.DeepEqual(m, expect) {\n\t\tt.Errorf(\"Test failed:\\ngot  :\\n%#v\\n\\nwant :\\n%#v\\n\\n\", m, expect)\n\t}\n}\n\nfunc TestMergeUsingStructAndMap(t *testing.T) {\n\ttype multiPtr struct {\n\t\tText   string\n\t\tNumber int\n\t}\n\ttype final struct {\n\t\tMsg1 string\n\t\tMsg2 string\n\t}\n\ttype params struct {\n\t\tMulti *multiPtr\n\t\tFinal *final\n\t\tName  string\n\t}\n\ttype config struct {\n\t\tParams *params\n\t\tFoo    string\n\t\tBar    string\n\t}\n\n\tcases := []struct {\n\t\tchanges   *config\n\t\ttarget    *config\n\t\toutput    *config\n\t\tname      string\n\t\toverwrite bool\n\t}{\n\t\t{\n\t\t\tname:      \"Should overwrite values in target for non-nil values in source\",\n\t\t\toverwrite: true,\n\t\t\tchanges: &config{\n\t\t\t\tBar: \"from changes\",\n\t\t\t\tParams: &params{\n\t\t\t\t\tFinal: &final{\n\t\t\t\t\t\tMsg1: \"from changes\",\n\t\t\t\t\t\tMsg2: \"from changes\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\ttarget: &config{\n\t\t\t\tFoo: \"from target\",\n\t\t\t\tParams: &params{\n\t\t\t\t\tName: \"from target\",\n\t\t\t\t\tMulti: &multiPtr{\n\t\t\t\t\t\tText:   \"from target\",\n\t\t\t\t\t\tNumber: 5,\n\t\t\t\t\t},\n\t\t\t\t\tFinal: &final{\n\t\t\t\t\t\tMsg1: \"from target\",\n\t\t\t\t\t\tMsg2: \"\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\toutput: &config{\n\t\t\t\tFoo: \"from target\",\n\t\t\t\tBar: \"from changes\",\n\t\t\t\tParams: &params{\n\t\t\t\t\tName: \"from target\",\n\t\t\t\t\tMulti: &multiPtr{\n\t\t\t\t\t\tText:   \"from target\",\n\t\t\t\t\t\tNumber: 5,\n\t\t\t\t\t},\n\t\t\t\t\tFinal: &final{\n\t\t\t\t\t\tMsg1: \"from changes\",\n\t\t\t\t\t\tMsg2: \"from changes\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname:      \"Should not overwrite values in target for non-nil values in source\",\n\t\t\toverwrite: false,\n\t\t\tchanges: &config{\n\t\t\t\tBar: \"from changes\",\n\t\t\t\tParams: &params{\n\t\t\t\t\tFinal: &final{\n\t\t\t\t\t\tMsg1: \"from changes\",\n\t\t\t\t\t\tMsg2: \"from changes\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\ttarget: &config{\n\t\t\t\tFoo: \"from target\",\n\t\t\t\tParams: &params{\n\t\t\t\t\tName: \"from target\",\n\t\t\t\t\tMulti: &multiPtr{\n\t\t\t\t\t\tText:   \"from target\",\n\t\t\t\t\t\tNumber: 5,\n\t\t\t\t\t},\n\t\t\t\t\tFinal: &final{\n\t\t\t\t\t\tMsg1: \"from target\",\n\t\t\t\t\t\tMsg2: \"\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\toutput: &config{\n\t\t\t\tFoo: \"from target\",\n\t\t\t\tBar: \"from changes\",\n\t\t\t\tParams: &params{\n\t\t\t\t\tName: \"from target\",\n\t\t\t\t\tMulti: &multiPtr{\n\t\t\t\t\t\tText:   \"from target\",\n\t\t\t\t\t\tNumber: 5,\n\t\t\t\t\t},\n\t\t\t\t\tFinal: &final{\n\t\t\t\t\t\tMsg1: \"from target\",\n\t\t\t\t\t\tMsg2: \"from changes\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}\n\n\tfor _, tc := range cases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tvar err error\n\t\t\tif tc.overwrite {\n\t\t\t\terr = mergo.Merge(tc.target, *tc.changes, mergo.WithOverride)\n\t\t\t} else {\n\t\t\t\terr = mergo.Merge(tc.target, *tc.changes)\n\t\t\t}\n\t\t\tif err != nil {\n\t\t\t\tt.Error(err)\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(tc.target, tc.output) {\n\t\t\t\tt.Errorf(\"Test failed:\\ngot  :\\n%+v\\n\\nwant :\\n%+v\\n\\n\", tc.target.Params, tc.output.Params)\n\t\t\t}\n\t\t})\n\t}\n}\nfunc TestMaps(t *testing.T) {\n\tm := map[string]simpleTest{\n\t\t\"a\": {},\n\t\t\"b\": {42},\n\t\t\"c\": {13},\n\t\t\"d\": {61},\n\t}\n\tn := map[string]simpleTest{\n\t\t\"a\": {16},\n\t\t\"b\": {},\n\t\t\"c\": {12},\n\t\t\"e\": {14},\n\t}\n\texpect := map[string]simpleTest{\n\t\t\"a\": {0},\n\t\t\"b\": {42},\n\t\t\"c\": {13},\n\t\t\"d\": {61},\n\t\t\"e\": {14},\n\t}\n\n\tif err := mergo.Merge(&m, n); err != nil {\n\t\tt.Errorf(err.Error())\n\t}\n\n\tif !reflect.DeepEqual(m, expect) {\n\t\tt.Errorf(\"Test failed:\\ngot  :\\n%#v\\n\\nwant :\\n%#v\\n\\n\", m, expect)\n\t}\n\tif m[\"a\"].Value != 0 {\n\t\tt.Errorf(`n merged in m because I solved non-addressable map values TODO: m[\"a\"].Value(%d) != n[\"a\"].Value(%d)`, m[\"a\"].Value, n[\"a\"].Value)\n\t}\n\tif m[\"b\"].Value != 42 {\n\t\tt.Errorf(`n wrongly merged in m: m[\"b\"].Value(%d) != n[\"b\"].Value(%d)`, m[\"b\"].Value, n[\"b\"].Value)\n\t}\n\tif m[\"c\"].Value != 13 {\n\t\tt.Errorf(`n overwritten in m: m[\"c\"].Value(%d) != n[\"c\"].Value(%d)`, m[\"c\"].Value, n[\"c\"].Value)\n\t}\n}\n\nfunc TestMapsWithNilPointer(t *testing.T) {\n\tm := map[string]*simpleTest{\n\t\t\"a\": nil,\n\t\t\"b\": nil,\n\t}\n\tn := map[string]*simpleTest{\n\t\t\"b\": nil,\n\t\t\"c\": nil,\n\t}\n\texpect := map[string]*simpleTest{\n\t\t\"a\": nil,\n\t\t\"b\": nil,\n\t\t\"c\": nil,\n\t}\n\n\tif err := mergo.Merge(&m, n, mergo.WithOverride); err != nil {\n\t\tt.Errorf(err.Error())\n\t}\n\n\tif !reflect.DeepEqual(m, expect) {\n\t\tt.Errorf(\"Test failed:\\ngot   :\\n%#v\\n\\nwant :\\n%#v\\n\\n\", m, expect)\n\t}\n}\n\nfunc TestYAMLMaps(t *testing.T) {\n\tthing := loadYAML(\"testdata/thing.yml\")\n\tlicense := loadYAML(\"testdata/license.yml\")\n\tft := thing[\"fields\"].(map[string]interface{})\n\tfl := license[\"fields\"].(map[string]interface{})\n\t// license has one extra field (site) and another already existing in thing (author) that Mergo won't override.\n\texpectedLength := len(ft) + len(fl) - 1\n\tif err := mergo.Merge(&license, thing); err != nil {\n\t\tt.Error(err.Error())\n\t}\n\tcurrentLength := len(license[\"fields\"].(map[string]interface{}))\n\tif currentLength != expectedLength {\n\t\tt.Errorf(`thing not merged in license properly, license must have %d elements instead of %d`, expectedLength, currentLength)\n\t}\n\tfields := license[\"fields\"].(map[string]interface{})\n\tif _, ok := fields[\"id\"]; !ok {\n\t\tt.Errorf(`thing not merged in license properly, license must have a new id field from thing`)\n\t}\n}\n\nfunc TestTwoPointerValues(t *testing.T) {\n\ta := &simpleTest{}\n\tb := &simpleTest{42}\n\tif err := mergo.Merge(a, b); err != nil {\n\t\tt.Errorf(`Boom. You crossed the streams: %s`, err)\n\t}\n}\n\nfunc TestMap(t *testing.T) {\n\ta := complexTest{}\n\ta.ID = \"athing\"\n\tc := moreComplextText{a, simpleTest{}, simpleTest{}}\n\tb := map[string]interface{}{\n\t\t\"ct\": map[string]interface{}{\n\t\t\t\"st\": map[string]interface{}{\n\t\t\t\t\"value\": 42,\n\t\t\t},\n\t\t\t\"sz\": 1,\n\t\t\t\"id\": \"bthing\",\n\t\t},\n\t\t\"st\": &simpleTest{144}, // Mapping a reference\n\t\t\"zt\": simpleTest{299},  // Mapping a missing field (zt doesn't exist)\n\t\t\"nt\": simpleTest{3},\n\t}\n\tif err := mergo.Map(&c, b); err != nil {\n\t\tt.FailNow()\n\t}\n\tm := b[\"ct\"].(map[string]interface{})\n\tn := m[\"st\"].(map[string]interface{})\n\to := b[\"st\"].(*simpleTest)\n\tp := b[\"nt\"].(simpleTest)\n\tif c.Ct.St.Value != 42 {\n\t\tt.Errorf(\"b not merged in properly: c.Ct.St.Value(%d) != b.Ct.St.Value(%d)\", c.Ct.St.Value, n[\"value\"])\n\t}\n\tif c.St.Value != 144 {\n\t\tt.Errorf(\"b not merged in properly: c.St.Value(%d) != b.St.Value(%d)\", c.St.Value, o.Value)\n\t}\n\tif c.Nt.Value != 3 {\n\t\tt.Errorf(\"b not merged in properly: c.Nt.Value(%d) != b.Nt.Value(%d)\", c.St.Value, p.Value)\n\t}\n\tif c.Ct.sz == 1 {\n\t\tt.Errorf(\"a's private field sz not preserved from merge: c.Ct.sz(%d) == b.Ct.sz(%d)\", c.Ct.sz, m[\"sz\"])\n\t}\n\tif c.Ct.ID == m[\"id\"] {\n\t\tt.Errorf(\"a's field ID merged unexpectedly: c.Ct.ID(%s) == b.Ct.ID(%s)\", c.Ct.ID, m[\"id\"])\n\t}\n}\n\nfunc TestSimpleMap(t *testing.T) {\n\ta := simpleTest{}\n\tb := map[string]interface{}{\n\t\t\"value\": 42,\n\t}\n\tif err := mergo.Map(&a, b); err != nil {\n\t\tt.FailNow()\n\t}\n\tif a.Value != 42 {\n\t\tt.Errorf(\"b not merged in properly: a.Value(%d) != b.Value(%v)\", a.Value, b[\"value\"])\n\t}\n}\n\nfunc TestIfcMap(t *testing.T) {\n\ta := ifcTest{}\n\tb := ifcTest{42}\n\tif err := mergo.Map(&a, b); err != nil {\n\t\tt.FailNow()\n\t}\n\tif a.I != 42 {\n\t\tt.Errorf(\"b not merged in properly: a.I(%d) != b.I(%d)\", a.I, b.I)\n\t}\n\tif !reflect.DeepEqual(a, b) {\n\t\tt.FailNow()\n\t}\n}\n\nfunc TestIfcMapNoOverwrite(t *testing.T) {\n\ta := ifcTest{13}\n\tb := ifcTest{42}\n\tif err := mergo.Map(&a, b); err != nil {\n\t\tt.FailNow()\n\t}\n\tif a.I != 13 {\n\t\tt.Errorf(\"a not left alone: a.I(%d) == b.I(%d)\", a.I, b.I)\n\t}\n}\n\nfunc TestIfcMapWithOverwrite(t *testing.T) {\n\ta := ifcTest{13}\n\tb := ifcTest{42}\n\tif err := mergo.MapWithOverwrite(&a, b); err != nil {\n\t\tt.FailNow()\n\t}\n\tif a.I != 42 {\n\t\tt.Errorf(\"b not merged in properly: a.I(%d) != b.I(%d)\", a.I, b.I)\n\t}\n\tif !reflect.DeepEqual(a, b) {\n\t\tt.FailNow()\n\t}\n}\n\ntype pointerMapTest struct {\n\tB      *simpleTest\n\tA      int\n\thidden int\n}\n\nfunc TestBackAndForth(t *testing.T) {\n\tpt := pointerMapTest{&simpleTest{66}, 42, 1}\n\tm := make(map[string]interface{})\n\tif err := mergo.Map(&m, pt); err != nil {\n\t\tt.FailNow()\n\t}\n\tvar (\n\t\tv  interface{}\n\t\tok bool\n\t)\n\tif v, ok = m[\"a\"]; v.(int) != pt.A || !ok {\n\t\tt.Errorf(\"pt not merged in properly: m[`a`](%d) != pt.A(%d)\", v, pt.A)\n\t}\n\tif v, ok = m[\"b\"]; !ok {\n\t\tt.Errorf(\"pt not merged in properly: B is missing in m\")\n\t}\n\tvar st *simpleTest\n\tif st = v.(*simpleTest); st.Value != 66 {\n\t\tt.Errorf(\"something went wrong while mapping pt on m, B wasn't copied\")\n\t}\n\tbpt := pointerMapTest{}\n\tif err := mergo.Map(&bpt, m); err != nil {\n\t\tt.Error(err)\n\t}\n\tif bpt.A != pt.A {\n\t\tt.Errorf(\"pt not merged in properly: bpt.A(%d) != pt.A(%d)\", bpt.A, pt.A)\n\t}\n\tif bpt.hidden == pt.hidden {\n\t\tt.Errorf(\"pt unexpectedly merged: bpt.hidden(%d) == pt.hidden(%d)\", bpt.hidden, pt.hidden)\n\t}\n\tif bpt.B.Value != pt.B.Value {\n\t\tt.Errorf(\"pt not merged in properly: bpt.B.Value(%d) != pt.B.Value(%d)\", bpt.B.Value, pt.B.Value)\n\t}\n}\n\nfunc TestEmbeddedPointerUnpacking(t *testing.T) {\n\ttests := []struct{ input pointerMapTest }{\n\t\t{pointerMapTest{nil, 42, 1}},\n\t\t{pointerMapTest{&simpleTest{66}, 42, 1}},\n\t}\n\tnewValue := 77\n\tm := map[string]interface{}{\n\t\t\"b\": map[string]interface{}{\n\t\t\t\"value\": newValue,\n\t\t},\n\t}\n\tfor _, test := range tests {\n\t\tpt := test.input\n\t\tif err := mergo.MapWithOverwrite(&pt, m); err != nil {\n\t\t\tt.FailNow()\n\t\t}\n\t\tif pt.B.Value != newValue {\n\t\t\tt.Errorf(\"pt not mapped properly: pt.A.Value(%d) != m[`b`][`value`](%d)\", pt.B.Value, newValue)\n\t\t}\n\n\t}\n}\n\ntype structWithTimePointer struct {\n\tBirth *time.Time\n}\n\nfunc TestTime(t *testing.T) {\n\tnow := time.Now()\n\tdataStruct := structWithTimePointer{\n\t\tBirth: &now,\n\t}\n\tdataMap := map[string]interface{}{\n\t\t\"Birth\": &now,\n\t}\n\tb := structWithTimePointer{}\n\tif err := mergo.Merge(&b, dataStruct); err != nil {\n\t\tt.FailNow()\n\t}\n\tif b.Birth.IsZero() {\n\t\tt.Errorf(\"time.Time not merged in properly: b.Birth(%v) != dataStruct['Birth'](%v)\", b.Birth, dataStruct.Birth)\n\t}\n\tif b.Birth != dataStruct.Birth {\n\t\tt.Errorf(\"time.Time not merged in properly: b.Birth(%v) != dataStruct['Birth'](%v)\", b.Birth, dataStruct.Birth)\n\t}\n\tb = structWithTimePointer{}\n\tif err := mergo.Map(&b, dataMap); err != nil {\n\t\tt.FailNow()\n\t}\n\tif b.Birth.IsZero() {\n\t\tt.Errorf(\"time.Time not merged in properly: b.Birth(%v) != dataMap['Birth'](%v)\", b.Birth, dataMap[\"Birth\"])\n\t}\n}\n\ntype simpleNested struct {\n\tA int\n}\n\ntype structWithNestedPtrValueMap struct {\n\tNestedPtrValue map[string]*simpleNested\n}\n\nfunc TestNestedPtrValueInMap(t *testing.T) {\n\tsrc := &structWithNestedPtrValueMap{\n\t\tNestedPtrValue: map[string]*simpleNested{\n\t\t\t\"x\": {\n\t\t\t\tA: 1,\n\t\t\t},\n\t\t},\n\t}\n\tdst := &structWithNestedPtrValueMap{\n\t\tNestedPtrValue: map[string]*simpleNested{\n\t\t\t\"x\": {},\n\t\t},\n\t}\n\tif err := mergo.Map(dst, src); err != nil {\n\t\tt.FailNow()\n\t}\n\tif dst.NestedPtrValue[\"x\"].A == 0 {\n\t\tt.Errorf(\"Nested Ptr value not merged in properly: dst.NestedPtrValue[\\\"x\\\"].A(%v) != src.NestedPtrValue[\\\"x\\\"].A(%v)\", dst.NestedPtrValue[\"x\"].A, src.NestedPtrValue[\"x\"].A)\n\t}\n}\n\nfunc loadYAML(path string) (m map[string]interface{}) {\n\tm = make(map[string]interface{})\n\traw, _ := ioutil.ReadFile(path)\n\t_ = yaml.Unmarshal(raw, &m)\n\treturn\n}\n\ntype structWithMap struct {\n\tm map[string]structWithUnexportedProperty\n}\n\ntype structWithUnexportedProperty struct {\n\ts string\n}\n\nfunc TestUnexportedProperty(t *testing.T) {\n\ta := structWithMap{map[string]structWithUnexportedProperty{\n\t\t\"key\": {\"hello\"},\n\t}}\n\tb := structWithMap{map[string]structWithUnexportedProperty{\n\t\t\"key\": {\"hi\"},\n\t}}\n\tdefer func() {\n\t\tif r := recover(); r != nil {\n\t\t\tt.Errorf(\"Should not have panicked\")\n\t\t}\n\t}()\n\tmergo.Merge(&a, b)\n}\n\ntype structWithBoolPointer struct {\n\tC *bool\n}\n\nfunc TestBooleanPointer(t *testing.T) {\n\tbt, bf := true, false\n\tsrc := structWithBoolPointer{\n\t\t&bt,\n\t}\n\tdst := structWithBoolPointer{\n\t\t&bf,\n\t}\n\tif err := mergo.Merge(&dst, src); err != nil {\n\t\tt.FailNow()\n\t}\n\tif dst.C == src.C {\n\t\tt.Errorf(\"dst.C should be a different pointer than src.C\")\n\t}\n\tif *dst.C != *src.C {\n\t\tt.Errorf(\"dst.C should be true\")\n\t}\n}\n\nfunc TestMergeMapWithInnerSliceOfDifferentType(t *testing.T) {\n\ttestCases := []struct {\n\t\tname    string\n\t\terr     string\n\t\toptions []func(*mergo.Config)\n\t}{\n\t\t{\n\t\t\t\"With override and append slice\",\n\t\t\t\"cannot append two slices with different type\",\n\t\t\t[]func(*mergo.Config){mergo.WithOverride, mergo.WithAppendSlice},\n\t\t},\n\t\t{\n\t\t\t\"With override and type check\",\n\t\t\t\"cannot override two slices with different type\",\n\t\t\t[]func(*mergo.Config){mergo.WithOverride, mergo.WithTypeCheck},\n\t\t},\n\t}\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tsrc := map[string]interface{}{\n\t\t\t\t\"foo\": []string{\"a\", \"b\"},\n\t\t\t}\n\t\t\tdst := map[string]interface{}{\n\t\t\t\t\"foo\": []int{1, 2},\n\t\t\t}\n\n\t\t\tif err := mergo.Merge(&src, &dst, tc.options...); err == nil || !strings.Contains(err.Error(), tc.err) {\n\t\t\t\tt.Errorf(\"expected %q, got %q\", tc.err, err)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestMergeDifferentSlicesIsNotSupported(t *testing.T) {\n\tsrc := []string{\"a\", \"b\"}\n\tdst := []int{1, 2}\n\n\tif err := mergo.Merge(&src, &dst, mergo.WithOverride, mergo.WithAppendSlice); err != mergo.ErrDifferentArgumentsTypes {\n\t\tt.Errorf(\"expected %q, got %q\", mergo.ErrNotSupported, err)\n\t}\n}\n"
        },
        {
          "name": "pr211_2_test.go",
          "type": "blob",
          "size": 0.576171875,
          "content": "package mergo\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n\t\"time\"\n)\n\ntype transformer struct {\n}\n\nfunc (s *transformer) Transformer(t reflect.Type) func(dst, src reflect.Value) error {\n\treturn nil\n}\n\nfunc Test_deepMergeTransformerInvalidDestination(t *testing.T) {\n\tfoo := time.Time{}\n\tsrc := reflect.ValueOf(foo)\n\tdeepMerge(reflect.Value{}, src, make(map[uintptr]*visit), 0, &Config{\n\t\tTransformers: &transformer{},\n\t})\n\t// this test is intentionally not asserting on anything, it's sole\n\t// purpose to verify deepMerge doesn't panic when a transformer is\n\t// passed and the destination is invalid.\n}\n"
        },
        {
          "name": "pr211_test.go",
          "type": "blob",
          "size": 0.8486328125,
          "content": "package mergo_test\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n\n\t\"dario.cat/mergo\"\n)\n\nfunc TestMergeWithTransformerZeroValue(t *testing.T) {\n\t// This test specifically tests that a transformer can be used to\n\t// prevent overwriting a zero value (in this case a bool). This would fail prior to #211\n\ttype fooWithBoolPtr struct {\n\t\tb *bool\n\t}\n\tvar Bool = func(b bool) *bool { return &b }\n\ta := fooWithBoolPtr{b: Bool(false)}\n\tb := fooWithBoolPtr{b: Bool(true)}\n\n\tif err := mergo.Merge(&a, &b, mergo.WithTransformers(&transformer{\n\t\tm: map[reflect.Type]func(dst, src reflect.Value) error{\n\t\t\treflect.TypeOf(Bool(false)): func(dst, src reflect.Value) error {\n\t\t\t\tif dst.CanSet() && dst.IsNil() {\n\t\t\t\t\tdst.Set(src)\n\t\t\t\t}\n\t\t\t\treturn nil\n\t\t\t},\n\t\t},\n\t})); err != nil {\n\t\tt.Error(err)\n\t}\n\n\tif *a.b != false {\n\t\tt.Errorf(\"b not merged in properly: a.b(%v) != expected(%v)\", a.b, false)\n\t}\n}\n"
        },
        {
          "name": "pr80_test.go",
          "type": "blob",
          "size": 0.375,
          "content": "package mergo_test\n\nimport (\n\t\"testing\"\n\n\t\"dario.cat/mergo\"\n)\n\ntype mapInterface map[string]interface{}\n\nfunc TestMergeMapsEmptyString(t *testing.T) {\n\ta := mapInterface{\"s\": \"\"}\n\tb := mapInterface{\"s\": \"foo\"}\n\tif err := mergo.Merge(&a, b); err != nil {\n\t\tt.Error(err)\n\t}\n\tif a[\"s\"] != \"foo\" {\n\t\tt.Errorf(\"b not merged in properly: a.s.Value(%s) != expected(%s)\", a[\"s\"], \"foo\")\n\t}\n}\n"
        },
        {
          "name": "pr81_test.go",
          "type": "blob",
          "size": 0.802734375,
          "content": "package mergo_test\n\nimport (\n\t\"testing\"\n\n\t\"dario.cat/mergo\"\n)\n\nfunc TestMapInterfaceWithMultipleLayer(t *testing.T) {\n\tm1 := map[string]interface{}{\n\t\t\"k1\": map[string]interface{}{\n\t\t\t\"k1.1\": \"v1\",\n\t\t},\n\t}\n\n\tm2 := map[string]interface{}{\n\t\t\"k1\": map[string]interface{}{\n\t\t\t\"k1.1\": \"v2\",\n\t\t\t\"k1.2\": \"v3\",\n\t\t},\n\t}\n\n\tif err := mergo.Map(&m1, m2, mergo.WithOverride); err != nil {\n\t\tt.Errorf(\"Error merging: %v\", err)\n\t}\n\n\t// Check overwrite of sub map works\n\texpected := \"v2\"\n\tactual := m1[\"k1\"].(map[string]interface{})[\"k1.1\"].(string)\n\tif actual != expected {\n\t\tt.Errorf(\"Expected %v but got %v\",\n\t\t\texpected,\n\t\t\tactual)\n\t}\n\n\t// Check new key is merged\n\texpected = \"v3\"\n\tactual = m1[\"k1\"].(map[string]interface{})[\"k1.2\"].(string)\n\tif actual != expected {\n\t\tt.Errorf(\"Expected %v but got %v\",\n\t\t\texpected,\n\t\t\tactual)\n\t}\n}\n"
        },
        {
          "name": "testdata",
          "type": "tree",
          "content": null
        },
        {
          "name": "v039_bugs_test.go",
          "type": "blob",
          "size": 1.35546875,
          "content": "package mergo_test\n\nimport (\n\t\"testing\"\n\n\t\"dario.cat/mergo\"\n)\n\ntype inner struct {\n\tA int\n}\n\ntype outer struct {\n\tinner\n\tB int\n}\n\nfunc TestV039Issue139(t *testing.T) {\n\tdst := outer{\n\t\tinner: inner{A: 1},\n\t\tB:     2,\n\t}\n\tsrc := outer{\n\t\tinner: inner{A: 10},\n\t\tB:     20,\n\t}\n\terr := mergo.MergeWithOverwrite(&dst, src)\n\tif err != nil {\n\t\tpanic(err.Error())\n\t}\n\tif dst.inner.A == 1 {\n\t\tt.Errorf(\"expected %d, got %d\", src.inner.A, dst.inner.A)\n\t}\n}\n\nfunc TestV039Issue152(t *testing.T) {\n\tdst := map[string]interface{}{\n\t\t\"properties\": map[string]interface{}{\n\t\t\t\"field1\": map[string]interface{}{\n\t\t\t\t\"type\": \"text\",\n\t\t\t},\n\t\t\t\"field2\": \"ohai\",\n\t\t},\n\t}\n\tsrc := map[string]interface{}{\n\t\t\"properties\": map[string]interface{}{\n\t\t\t\"field1\": \"wrong\",\n\t\t},\n\t}\n\tif err := mergo.Map(&dst, src, mergo.WithOverride); err != nil {\n\t\tt.Error(err)\n\t}\n}\n\ntype issue146Foo struct {\n\tB map[string]issue146Bar\n\tA string\n}\n\ntype issue146Bar struct {\n\tC *string\n\tD *string\n}\n\nfunc TestV039Issue146(t *testing.T) {\n\tvar (\n\t\ts1 = \"asd\"\n\t\ts2 = \"sdf\"\n\t)\n\tdst := issue146Foo{\n\t\tA: \"two\",\n\t\tB: map[string]issue146Bar{\n\t\t\t\"foo\": {\n\t\t\t\tC: &s1,\n\t\t\t},\n\t\t},\n\t}\n\tsrc := issue146Foo{\n\t\tA: \"one\",\n\t\tB: map[string]issue146Bar{\n\t\t\t\"foo\": {\n\t\t\t\tD: &s2,\n\t\t\t},\n\t\t},\n\t}\n\tif err := mergo.Merge(&dst, src, mergo.WithOverride); err != nil {\n\t\tt.Error(err)\n\t}\n\tif dst.B[\"foo\"].D == nil {\n\t\tt.Errorf(\"expected %v, got nil\", &s2)\n\t}\n}\n"
        }
      ]
    }
  ]
}