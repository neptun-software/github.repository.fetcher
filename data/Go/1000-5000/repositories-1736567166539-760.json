{
  "metadata": {
    "timestamp": 1736567166539,
    "page": 760,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjc2MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "andeya/erpc",
      "stars": 2518,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 1.0126953125,
          "content": "*.o\n*.a\n*.so\n_obj\n_test\n*.[568vq]\n[568vq].out\n*.cgo1.go\n*.cgo2.c\n_cgo_defun.c\n_cgo_gotypes.go\n_cgo_export.*\n_testmain.go\n*.exe\n*.exe~\n*.test\n*.prof\n*.rar\n*.zip\n*.gz\n*.psd\n*.bmd\n*.cfg\n*.pptx\n*.log\n*nohup.out\n*.sublime-project\n*.sublime-workspace\n_*\n.DS_Store\n.idea\n.vscode\n\nsocket/example/client\nsocket/example/server\n\nexamples/*/*_server\nexamples/*/*_mserver\nexamples/*/*_client\nexamples/*/*_mclient\nexamples/ab/frame_client_ab\n/examples/proxy_and_seq/proxy_and_seq\n/examples/plugin-tps/tps\n/proto/rawproto/rawproto_test\n/proto/httproto/httproto_test\n/proto/jsonproto/jsonproto_test\n/xfer/md5/md5_test\n/proto/pbproto/pbproto_test\n/proto/thriftproto/thriftproto_test\n/mixer/evio/bench/evio_bench_client\n/mixer/evio/bench/evio_bench_server\n/mixer/evio/evio_test\n/mixer/multiclient/multiclient_test\n/mixer/websocket/websocket_test\n/plugin/auth/auth_test\n/plugin/binder/binder_test\n/plugin/heartbeat/heartbeat_test\n/plugin/ignorecase/ignorecase_test\n/plugin/overloader/overloader\n/plugin/secure/secure_test\n/erpc_test\n/cover.out\n/cover.html\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 11.26953125,
          "content": "                                 Apache License\r\n                           Version 2.0, January 2004\r\n                        http://www.apache.org/licenses/\r\n\r\n   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION\r\n\r\n   1. Definitions.\r\n\r\n      \"License\" shall mean the terms and conditions for use, reproduction,\r\n      and distribution as defined by Sections 1 through 9 of this document.\r\n\r\n      \"Licensor\" shall mean the copyright owner or entity authorized by\r\n      the copyright owner that is granting the License.\r\n\r\n      \"Legal Entity\" shall mean the union of the acting entity and all\r\n      other entities that control, are controlled by, or are under common\r\n      control with that entity. For the purposes of this definition,\r\n      \"control\" means (i) the power, direct or indirect, to cause the\r\n      direction or management of such entity, whether by contract or\r\n      otherwise, or (ii) ownership of fifty percent (50%) or more of the\r\n      outstanding shares, or (iii) beneficial ownership of such entity.\r\n\r\n      \"You\" (or \"Your\") shall mean an individual or Legal Entity\r\n      exercising permissions granted by this License.\r\n\r\n      \"Source\" form shall mean the preferred form for making modifications,\r\n      including but not limited to software source code, documentation\r\n      source, and configuration files.\r\n\r\n      \"Object\" form shall mean any form resulting from mechanical\r\n      transformation or translation of a Source form, including but\r\n      not limited to compiled object code, generated documentation,\r\n      and conversions to other media types.\r\n\r\n      \"Work\" shall mean the work of authorship, whether in Source or\r\n      Object form, made available under the License, as indicated by a\r\n      copyright notice that is included in or attached to the work\r\n      (an example is provided in the Appendix below).\r\n\r\n      \"Derivative Works\" shall mean any work, whether in Source or Object\r\n      form, that is based on (or derived from) the Work and for which the\r\n      editorial revisions, annotations, elaborations, or other modifications\r\n      represent, as a whole, an original work of authorship. For the purposes\r\n      of this License, Derivative Works shall not include works that remain\r\n      separable from, or merely link (or bind by name) to the interfaces of,\r\n      the Work and Derivative Works thereof.\r\n\r\n      \"Contribution\" shall mean any work of authorship, including\r\n      the original version of the Work and any modifications or additions\r\n      to that Work or Derivative Works thereof, that is intentionally\r\n      submitted to Licensor for inclusion in the Work by the copyright owner\r\n      or by an individual or Legal Entity authorized to submit on behalf of\r\n      the copyright owner. For the purposes of this definition, \"submitted\"\r\n      means any form of electronic, verbal, or written communication sent\r\n      to the Licensor or its representatives, including but not limited to\r\n      communication on electronic mailing lists, source code control systems,\r\n      and issue tracking systems that are managed by, or on behalf of, the\r\n      Licensor for the purpose of discussing and improving the Work, but\r\n      excluding communication that is conspicuously marked or otherwise\r\n      designated in writing by the copyright owner as \"Not a Contribution.\"\r\n\r\n      \"Contributor\" shall mean Licensor and any individual or Legal Entity\r\n      on behalf of whom a Contribution has been received by Licensor and\r\n      subsequently incorporated within the Work.\r\n\r\n   2. Grant of Copyright License. Subject to the terms and conditions of\r\n      this License, each Contributor hereby grants to You a perpetual,\r\n      worldwide, non-exclusive, no-charge, royalty-free, irrevocable\r\n      copyright license to reproduce, prepare Derivative Works of,\r\n      publicly display, publicly perform, sublicense, and distribute the\r\n      Work and such Derivative Works in Source or Object form.\r\n\r\n   3. Grant of Patent License. Subject to the terms and conditions of\r\n      this License, each Contributor hereby grants to You a perpetual,\r\n      worldwide, non-exclusive, no-charge, royalty-free, irrevocable\r\n      (except as stated in this section) patent license to make, have made,\r\n      use, offer to sell, sell, import, and otherwise transfer the Work,\r\n      where such license applies only to those patent claims licensable\r\n      by such Contributor that are necessarily infringed by their\r\n      Contribution(s) alone or by combination of their Contribution(s)\r\n      with the Work to which such Contribution(s) was submitted. If You\r\n      institute patent litigation against any entity (including a\r\n      cross-claim or counterclaim in a lawsuit) alleging that the Work\r\n      or a Contribution incorporated within the Work constitutes direct\r\n      or contributory patent infringement, then any patent licenses\r\n      granted to You under this License for that Work shall terminate\r\n      as of the date such litigation is filed.\r\n\r\n   4. Redistribution. You may reproduce and distribute copies of the\r\n      Work or Derivative Works thereof in any medium, with or without\r\n      modifications, and in Source or Object form, provided that You\r\n      meet the following conditions:\r\n\r\n      (a) You must give any other recipients of the Work or\r\n          Derivative Works a copy of this License; and\r\n\r\n      (b) You must cause any modified files to carry prominent notices\r\n          stating that You changed the files; and\r\n\r\n      (c) You must retain, in the Source form of any Derivative Works\r\n          that You distribute, all copyright, patent, trademark, and\r\n          attribution notices from the Source form of the Work,\r\n          excluding those notices that do not pertain to any part of\r\n          the Derivative Works; and\r\n\r\n      (d) If the Work includes a \"NOTICE\" text file as part of its\r\n          distribution, then any Derivative Works that You distribute must\r\n          include a readable copy of the attribution notices contained\r\n          within such NOTICE file, excluding those notices that do not\r\n          pertain to any part of the Derivative Works, in at least one\r\n          of the following places: within a NOTICE text file distributed\r\n          as part of the Derivative Works; within the Source form or\r\n          documentation, if provided along with the Derivative Works; or,\r\n          within a display generated by the Derivative Works, if and\r\n          wherever such third-party notices normally appear. The contents\r\n          of the NOTICE file are for informational purposes only and\r\n          do not modify the License. You may add Your own attribution\r\n          notices within Derivative Works that You distribute, alongside\r\n          or as an addendum to the NOTICE text from the Work, provided\r\n          that such additional attribution notices cannot be construed\r\n          as modifying the License.\r\n\r\n      You may add Your own copyright statement to Your modifications and\r\n      may provide additional or different license terms and conditions\r\n      for use, reproduction, or distribution of Your modifications, or\r\n      for any such Derivative Works as a whole, provided Your use,\r\n      reproduction, and distribution of the Work otherwise complies with\r\n      the conditions stated in this License.\r\n\r\n   5. Submission of Contributions. Unless You explicitly state otherwise,\r\n      any Contribution intentionally submitted for inclusion in the Work\r\n      by You to the Licensor shall be under the terms and conditions of\r\n      this License, without any additional terms or conditions.\r\n      Notwithstanding the above, nothing herein shall supersede or modify\r\n      the terms of any separate license agreement you may have executed\r\n      with Licensor regarding such Contributions.\r\n\r\n   6. Trademarks. This License does not grant permission to use the trade\r\n      names, trademarks, service marks, or product names of the Licensor,\r\n      except as required for reasonable and customary use in describing the\r\n      origin of the Work and reproducing the content of the NOTICE file.\r\n\r\n   7. Disclaimer of Warranty. Unless required by applicable law or\r\n      agreed to in writing, Licensor provides the Work (and each\r\n      Contributor provides its Contributions) on an \"AS IS\" BASIS,\r\n      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\r\n      implied, including, without limitation, any warranties or conditions\r\n      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A\r\n      PARTICULAR PURPOSE. You are solely responsible for determining the\r\n      appropriateness of using or redistributing the Work and assume any\r\n      risks associated with Your exercise of permissions under this License.\r\n\r\n   8. Limitation of Liability. In no event and under no legal theory,\r\n      whether in tort (including negligence), contract, or otherwise,\r\n      unless required by applicable law (such as deliberate and grossly\r\n      negligent acts) or agreed to in writing, shall any Contributor be\r\n      liable to You for damages, including any direct, indirect, special,\r\n      incidental, or consequential damages of any character arising as a\r\n      result of this License or out of the use or inability to use the\r\n      Work (including but not limited to damages for loss of goodwill,\r\n      work stoppage, computer failure or malfunction, or any and all\r\n      other commercial damages or losses), even if such Contributor\r\n      has been advised of the possibility of such damages.\r\n\r\n   9. Accepting Warranty or Additional Liability. While redistributing\r\n      the Work or Derivative Works thereof, You may choose to offer,\r\n      and charge a fee for, acceptance of support, warranty, indemnity,\r\n      or other liability obligations and/or rights consistent with this\r\n      License. However, in accepting such obligations, You may act only\r\n      on Your own behalf and on Your sole responsibility, not on behalf\r\n      of any other Contributor, and only if You agree to indemnify,\r\n      defend, and hold each Contributor harmless for any liability\r\n      incurred by, or claims asserted against, such Contributor by reason\r\n      of your accepting any such warranty or additional liability.\r\n\r\n   END OF TERMS AND CONDITIONS\r\n\r\n   APPENDIX: How to apply the Apache License to your work.\r\n\r\n      To apply the Apache License to your work, attach the following\r\n      boilerplate notice, with the fields enclosed by brackets \"{}\"\r\n      replaced with your own identifying information. (Don't include\r\n      the brackets!)  The text should be enclosed in the appropriate\r\n      comment syntax for the file format. We also recommend that a\r\n      file or class name and description of purpose be included on the\r\n      same \"printed page\" as the copyright notice for easier\r\n      identification within third-party archives.\r\n\r\n   Copyright 2022 AndeyaLee\r\n\r\n   Licensed under the Apache License, Version 2.0 (the \"License\");\r\n   you may not use this file except in compliance with the License.\r\n   You may obtain a copy of the License at\r\n\r\n       http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n   Unless required by applicable law or agreed to in writing, software\r\n   distributed under the License is distributed on an \"AS IS\" BASIS,\r\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n   See the License for the specific language governing permissions and\r\n   limitations under the License.\r\n"
        },
        {
          "name": "Makefile",
          "type": "blob",
          "size": 1.1552734375,
          "content": "\nBIN=go\n\nbuild:\n\t${BIN} build -v ./...\n\ntest:\n\tgo test -v ./...\nwatch-test:\n\treflex -t 50ms -s -- sh -c 'gotest -v ./...'\n\nbench:\n\tgo test -benchmem -count 3 -bench ./...\nwatch-bench:\n\treflex -t 50ms -s -- sh -c 'go test -benchmem -count 3 -bench ./...'\n\ncoverage:\n\t${BIN} test -v -coverprofile=cover.out -covermode=atomic ./...\n\t${BIN} tool cover -html=cover.out -o cover.html\n\n# tools\ntools:\n\t${BIN} install github.com/cespare/reflex@latest\n\t${BIN} install github.com/rakyll/gotest@latest\n\t${BIN} install github.com/psampaz/go-mod-outdated@latest\n\t${BIN} install github.com/jondot/goweight@latest\n\t${BIN} install github.com/golangci/golangci-lint/cmd/golangci-lint@latest\n\t${BIN} get -t -u golang.org/x/tools/cmd/cover\n\t${BIN} install github.com/sonatype-nexus-community/nancy@latest\n\tgo mod tidy\n\nlint:\n\tgolangci-lint run --print-resources-usage --fast --timeout 20m0s --max-same-issues 50 ./...\nlint-fix:\n\tgolangci-lint run --print-resources-usage --fast --timeout 20m0s --max-same-issues 50 --fix ./...\n\naudit:\n\t${BIN} mod tidy\n\t${BIN} list -json -m all | nancy sleuth\n\noutdated:\n\t${BIN} mod tidy\n\t${BIN} list -u -m -json all | go-mod-outdated -update -direct\n\nweight:\n\tgoweight"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 20.8857421875,
          "content": "# eRPC\n\n[![tag](https://img.shields.io/github/tag/andeya/erpc.svg)](https://github.com/andeya/erpc/releases)\n![Go Version](https://img.shields.io/badge/Go-%3E%3D%201.18-%23007d9c)\n[![GoDoc](https://godoc.org/github.com/andeya/erpc?status.svg)](https://pkg.go.dev/github.com/andeya/erpc/v7)\n![Build Status](https://github.com/andeya/erpc/actions/workflows/go-ci.yml/badge.svg)\n[![Go report](https://goreportcard.com/badge/github.com/andeya/erpc/v7)](https://goreportcard.com/report/github.com/andeya/erpc/v7)\n[![License](https://img.shields.io/github/license/andeya/erpc)](./LICENSE)\n\neRPC is an efficient, extensible and easy-to-use RPC framework.\n\nSuitable for RPC, Microservice, Peer-to-Peer, IM, Game and other fields.\n\n[简体中文](https://github.com/andeya/erpc/tree/master/README_ZH.md)\n\n\n![eRPC-Framework](https://github.com/andeya/erpc/raw/master/doc/erpc_module_diagram.png)\n\n\n## Install\n\n\n- go vesion ≥ 1.18\n\n- install\n```sh\nGO111MODULE=on go get -u -v -insecure github.com/andeya/erpc/v7\n```\n\n- import\n```go\nimport \"github.com/andeya/erpc/v7\"\n```\n\n## Feature\n\n- Use peer to provide the same API package for the server and client\n- Provide multi-layout abstractions such as:\n  - peer\n  - session/socket\n  - router\n  - handle/context\n  - message\n  - protocol\n  - codec\n  - transfer filter\n  - plugin\n- Support reboot and shutdown gracefully\n- HTTP-compatible message format:\n  - Composed of two parts, the `Header` and the `Body`\n  - `Header` contains metadata in the same format as HTTP header\n  - `Body` supports for custom codec of Content Type-Like, already implemented:\n    - Protobuf\n    - Thrift\n    - JSON\n    - XML\n    - Form\n    - Plain\n  - Support push, call-reply and more message types\n- Support custom message protocol, and provide some common implementations:\n  - `rawproto` - Default high performance binary protocol\n  - `jsonproto` - JSON message protocol\n  - `pbproto` - Ptotobuf message protocol\n  - `thriftproto` - Thrift message protocol\n  - `httproto` - HTTP message protocol\n- Optimized high performance transport layer\n  - Use Non-block socket and I/O multiplexing technology\n  - Support setting the size of socket I/O buffer\n  - Support setting the size of the reading message (if exceed disconnect it)\n  - Support controling the connection file descriptor\n- Support a variety of network types:\n  - `tcp`\n  - `tcp4`\n  - `tcp6`\n  - `unix`\n  - `unixpacket`\n  - `kcp`\n  - `quic`\n  - other\n    - websocket\n    - evio\n- Provide a rich plug-in point, and already implemented:\n  - auth\n  - binder\n  - heartbeat\n  - ignorecase(service method)\n  - overloader\n  - proxy(for unknown service method)\n  - secure\n- Powerful and flexible logging system:\n  - Detailed log information, support print input and output details\n  - Support setting slow operation alarm threshold\n  - Support for custom implementation log component\n- Client session support automatically redials after disconnection\n\n\n## Benchmark\n\n**Self Test**\n\n- A server and a client process, running on the same machine\n- CPU:    Intel Xeon E312xx (Sandy Bridge) 16 cores 2.53GHz\n- Memory: 16G\n- OS:     Linux 2.6.32-696.16.1.el6.centos.plus.x86_64, CentOS 6.4\n- Go:     1.9.2\n- Message size: 581 bytes\n- Message codec: protobuf\n- Sent total 1000000 messages\n\n- erpc\n\n| client concurrency | mean(ms) | median(ms) | max(ms) | min(ms) | throughput(TPS) |\n| ------------------ | -------- | ---------- | ------- | ------- | --------------- |\n| 100                | 1        | 0          | 16      | 0       | 75505           |\n| 500                | 9        | 11         | 97      | 0       | 52192           |\n| 1000               | 19       | 24         | 187     | 0       | 50040           |\n| 2000               | 39       | 54         | 409     | 0       | 42551           |\n| 5000               | 96       | 128        | 1148    | 0       | 46367           |\n\n- erpc/socket\n\n| client concurrency | mean(ms) | median(ms) | max(ms) | min(ms) | throughput(TPS) |\n| ------------------ | -------- | ---------- | ------- | ------- | --------------- |\n| 100                | 0        | 0          | 14      | 0       | 225682          |\n| 500                | 2        | 1          | 24      | 0       | 212630          |\n| 1000               | 4        | 3          | 51      | 0       | 180733          |\n| 2000               | 8        | 6          | 64      | 0       | 183351          |\n| 5000               | 21       | 18         | 651     | 0       | 133886          |\n\n**Comparison Test**\n\n<table>\n<tr><th>Environment</th><th>Throughputs</th><th>Mean Latency</th><th>P99 Latency</th></tr>\n<tr>\n<td width=\"10%\"><img src=\"https://github.com/andeya/rpc-benchmark/raw/master/result/env.png\"></td>\n<td width=\"30%\"><img src=\"https://github.com/andeya/rpc-benchmark/raw/master/result/throughput.png\"></td>\n<td width=\"30%\"><img src=\"https://github.com/andeya/rpc-benchmark/raw/master/result/mean_latency.png\"></td>\n<td width=\"30%\"><img src=\"https://github.com/andeya/rpc-benchmark/raw/master/result/p99_latency.png\"></td>\n</tr>\n</table>\n\n**[More Detail](https://github.com/andeya/rpc-benchmark)**\n\n- Profile torch of erpc/socket\n\n![erpc_socket_profile_torch](https://github.com/andeya/erpc/raw/master/doc/erpc_socket_profile_torch.png)\n\n**[svg file](https://github.com/andeya/erpc/raw/master/doc/erpc_socket_profile_torch.svg)**\n\n- Heap torch of erpc/socket\n\n![erpc_socket_heap_torch](https://github.com/andeya/erpc/raw/master/doc/erpc_socket_heap_torch.png)\n\n**[svg file](https://github.com/andeya/erpc/raw/master/doc/erpc_socket_heap_torch.svg)**\n\n\n## Example\n\n### server.go\n\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"time\"\n\n\t\"github.com/andeya/erpc/v7\"\n)\n\nfunc main() {\n\tdefer erpc.FlushLogger()\n\t// graceful\n\tgo erpc.GraceSignal()\n\n\t// server peer\n\tsrv := erpc.NewPeer(erpc.PeerConfig{\n\t\tCountTime:   true,\n\t\tListenPort:  9090,\n\t\tPrintDetail: true,\n\t})\n\t// srv.SetTLSConfig(erpc.GenerateTLSConfigForServer())\n\n\t// router\n\tsrv.RouteCall(new(Math))\n\n\t// broadcast per 5s\n\tgo func() {\n\t\tfor {\n\t\t\ttime.Sleep(time.Second * 5)\n\t\t\tsrv.RangeSession(func(sess erpc.Session) bool {\n\t\t\t\tsess.Push(\n\t\t\t\t\t\"/push/status\",\n\t\t\t\t\tfmt.Sprintf(\"this is a broadcast, server time: %v\", time.Now()),\n\t\t\t\t)\n\t\t\t\treturn true\n\t\t\t})\n\t\t}\n\t}()\n\n\t// listen and serve\n\tsrv.ListenAndServe()\n}\n\n// Math handler\ntype Math struct {\n\terpc.CallCtx\n}\n\n// Add handles addition request\nfunc (m *Math) Add(arg *[]int) (int, *erpc.Status) {\n\t// test meta\n\terpc.Infof(\"author: %s\", m.PeekMeta(\"author\"))\n\t// add\n\tvar r int\n\tfor _, a := range *arg {\n\t\tr += a\n\t}\n\t// response\n\treturn r, nil\n}\n```\n\n### client.go\n\n```go\npackage main\n\nimport (\n  \"time\"\n\n  \"github.com/andeya/erpc/v7\"\n)\n\nfunc main() {\n  defer erpc.SetLoggerLevel(\"ERROR\")()\n\n  cli := erpc.NewPeer(erpc.PeerConfig{})\n  defer cli.Close()\n  // cli.SetTLSConfig(&tls.Config{InsecureSkipVerify: true})\n\n  cli.RoutePush(new(Push))\n\n  sess, stat := cli.Dial(\":9090\")\n  if !stat.OK() {\n    erpc.Fatalf(\"%v\", stat)\n  }\n\n  var result int\n  stat = sess.Call(\"/math/add\",\n    []int{1, 2, 3, 4, 5},\n    &result,\n    erpc.WithAddMeta(\"author\", \"andeya\"),\n  ).Status()\n  if !stat.OK() {\n    erpc.Fatalf(\"%v\", stat)\n  }\n  erpc.Printf(\"result: %d\", result)\n  erpc.Printf(\"Wait 10 seconds to receive the push...\")\n  time.Sleep(time.Second * 10)\n}\n\n// Push push handler\ntype Push struct {\n  erpc.PushCtx\n}\n\n// Push handles '/push/status' message\nfunc (p *Push) Status(arg *string) *erpc.Status {\n  erpc.Printf(\"%s\", *arg)\n  return nil\n}\n```\n\n[More Examples](https://github.com/andeya/erpc/tree/master/examples)\n\n## Usage\n\n**NOTE:**\n\n- It is best to set the packet size when reading: `SetReadLimit`\n- The default packet size limit when reading is 1 GB\n\n### Peer(server or client) Demo\n\n```go\n// Start a server\nvar peer1 = erpc.NewPeer(erpc.PeerConfig{\nListenPort: 9090, // for server role\n})\npeer1.Listen()\n\n...\n\n// Start a client\nvar peer2 = erpc.NewPeer(erpc.PeerConfig{})\nvar sess, err = peer2.Dial(\"127.0.0.1:8080\")\n```\n\n### Call-Struct API template\n\n```go\ntype Aaa struct {\n    erpc.CallCtx\n}\nfunc (x *Aaa) XxZz(arg *<T>) (<T>, *erpc.Status) {\n    ...\n    return r, nil\n}\n```\n\n- register it to root router:\n\n```go\n// register the call route\n// HTTP mapping: /aaa/xx_zz\n// RPC mapping: Aaa.XxZz\npeer.RouteCall(new(Aaa))\n\n// or register the call route\n// HTTP mapping: /xx_zz\n// RPC mapping: XxZz\npeer.RouteCallFunc((*Aaa).XxZz)\n```\n\n### Service method mapping\n\n- The default mapping(HTTPServiceMethodMapper) of struct(func) name to service methods:\n    - `AaBb` -> `/aa_bb`\n    - `ABcXYz` -> `/abc_xyz`\n    - `Aa__Bb` -> `/aa_bb`\n    - `aa__bb` -> `/aa_bb`\n    - `ABC__XYZ` -> `/abc_xyz`\n    - `Aa_Bb` -> `/aa/bb`\n    - `aa_bb` -> `/aa/bb`\n    - `ABC_XYZ` -> `/abc/xyz`\n    ```go\n    erpc.SetServiceMethodMapper(erpc.HTTPServiceMethodMapper)\n    ```\n\n- The mapping(RPCServiceMethodMapper) of struct(func) name to service methods:\n    - `AaBb` -> `AaBb`\n    - `ABcXYz` -> `ABcXYz`\n    - `Aa__Bb` -> `Aa_Bb`\n    - `aa__bb` -> `aa_bb`\n    - `ABC__XYZ` -> `ABC_XYZ`\n    - `Aa_Bb` -> `Aa.Bb`\n    - `aa_bb` -> `aa.bb`\n    - `ABC_XYZ` -> `ABC.XYZ`\n    ```go\n    erpc.SetServiceMethodMapper(erpc.RPCServiceMethodMapper)\n    ```\n\n### Call-Function API template\n\n```go\nfunc XxZz(ctx erpc.CallCtx, arg *<T>) (<T>, *erpc.Status) {\n    ...\n    return r, nil\n}\n```\n\n- register it to root router:\n\n```go\n// register the call route\n// HTTP mapping: /xx_zz\n// RPC mapping: XxZz\npeer.RouteCallFunc(XxZz)\n```\n\n### Push-Struct API template\n\n```go\ntype Bbb struct {\n    erpc.PushCtx\n}\nfunc (b *Bbb) YyZz(arg *<T>) *erpc.Status {\n    ...\n    return nil\n}\n```\n\n- register it to root router:\n\n```go\n// register the push handler\n// HTTP mapping: /bbb/yy_zz\n// RPC mapping: Bbb.YyZz\npeer.RoutePush(new(Bbb))\n\n// or register the push handler\n// HTTP mapping: /yy_zz\n// RPC mapping: YyZz\npeer.RoutePushFunc((*Bbb).YyZz)\n```\n\n### Push-Function API template\n\n```go\n// YyZz register the handler\nfunc YyZz(ctx erpc.PushCtx, arg *<T>) *erpc.Status {\n    ...\n    return nil\n}\n```\n\n- register it to root router:\n\n```go\n// register the push handler\n// HTTP mapping: /yy_zz\n// RPC mapping: YyZz\npeer.RoutePushFunc(YyZz)\n```\n\n### Unknown-Call-Function API template\n\n```go\nfunc XxxUnknownCall (ctx erpc.UnknownCallCtx) (interface{}, *erpc.Status) {\n    ...\n    return r, nil\n}\n```\n\n- register it to root router:\n\n```go\n// register the unknown call route: /*\npeer.SetUnknownCall(XxxUnknownCall)\n```\n\n### Unknown-Push-Function API template\n\n```go\nfunc XxxUnknownPush(ctx erpc.UnknownPushCtx) *erpc.Status {\n    ...\n    return nil\n}\n```\n\n- register it to root router:\n\n```go\n// register the unknown push route: /*\npeer.SetUnknownPush(XxxUnknownPush)\n```\n\n### Plugin Demo\n\n```go\n// NewIgnoreCase Returns a ignoreCase plugin.\nfunc NewIgnoreCase() *ignoreCase {\n    return &ignoreCase{}\n}\n\ntype ignoreCase struct{}\n\nvar (\n    _ erpc.PostReadCallHeaderPlugin = new(ignoreCase)\n    _ erpc.PostReadPushHeaderPlugin = new(ignoreCase)\n)\n\nfunc (i *ignoreCase) Name() string {\n    return \"ignoreCase\"\n}\n\nfunc (i *ignoreCase) PostReadCallHeader(ctx erpc.ReadCtx) *erpc.Status {\n    // Dynamic transformation path is lowercase\n    ctx.UriObject().Path = strings.ToLower(ctx.UriObject().Path)\n    return nil\n}\n\nfunc (i *ignoreCase) PostReadPushHeader(ctx erpc.ReadCtx) *erpc.Status {\n    // Dynamic transformation path is lowercase\n    ctx.UriObject().Path = strings.ToLower(ctx.UriObject().Path)\n    return nil\n}\n```\n\n### Register above handler and plugin\n\n```go\n// add router group\ngroup := peer.SubRoute(\"test\")\n// register to test group\ngroup.RouteCall(new(Aaa), NewIgnoreCase())\npeer.RouteCallFunc(XxZz, NewIgnoreCase())\ngroup.RoutePush(new(Bbb))\npeer.RoutePushFunc(YyZz)\npeer.SetUnknownCall(XxxUnknownCall)\npeer.SetUnknownPush(XxxUnknownPush)\n```\n\n### Config\n\n```go\ntype PeerConfig struct {\n    Network            string        `yaml:\"network\"              ini:\"network\"              comment:\"Network; tcp, tcp4, tcp6, unix, unixpacket, kcp or quic\"`\n    LocalIP            string        `yaml:\"local_ip\"             ini:\"local_ip\"             comment:\"Local IP\"`\n    ListenPort         uint16        `yaml:\"listen_port\"          ini:\"listen_port\"          comment:\"Listen port; for server role\"`\n    DialTimeout time.Duration `yaml:\"dial_timeout\" ini:\"dial_timeout\" comment:\"Default maximum duration for dialing; for client role; ns,µs,ms,s,m,h\"`\n    RedialTimes        int32         `yaml:\"redial_times\"         ini:\"redial_times\"         comment:\"The maximum times of attempts to redial, after the connection has been unexpectedly broken; Unlimited when <0; for client role\"`\n\tRedialInterval     time.Duration `yaml:\"redial_interval\"      ini:\"redial_interval\"      comment:\"Interval of redialing each time, default 100ms; for client role; ns,µs,ms,s,m,h\"`\n    DefaultBodyCodec   string        `yaml:\"default_body_codec\"   ini:\"default_body_codec\"   comment:\"Default body codec type id\"`\n    DefaultSessionAge  time.Duration `yaml:\"default_session_age\"  ini:\"default_session_age\"  comment:\"Default session max age, if less than or equal to 0, no time limit; ns,µs,ms,s,m,h\"`\n    DefaultContextAge  time.Duration `yaml:\"default_context_age\"  ini:\"default_context_age\"  comment:\"Default CALL or PUSH context max age, if less than or equal to 0, no time limit; ns,µs,ms,s,m,h\"`\n    SlowCometDuration  time.Duration `yaml:\"slow_comet_duration\"  ini:\"slow_comet_duration\"  comment:\"Slow operation alarm threshold; ns,µs,ms,s ...\"`\n    PrintDetail        bool          `yaml:\"print_detail\"         ini:\"print_detail\"         comment:\"Is print body and metadata or not\"`\n    CountTime          bool          `yaml:\"count_time\"           ini:\"count_time\"           comment:\"Is count cost time or not\"`\n}\n```\n\n### Optimize\n\n- SetMessageSizeLimit sets max message size.\n  If maxSize<=0, set it to max uint32.\n\n    ```go\n    func SetMessageSizeLimit(maxMessageSize uint32)\n    ```\n\n- SetSocketKeepAlive sets whether the operating system should send\n  keepalive messages on the connection.\n\n    ```go\n    func SetSocketKeepAlive(keepalive bool)\n    ```\n\n- SetSocketKeepAlivePeriod sets period between keep alives.\n\n    ```go\n    func SetSocketKeepAlivePeriod(d time.Duration)\n    ```\n\n- SetSocketNoDelay controls whether the operating system should delay\n  message transmission in hopes of sending fewer messages (Nagle's\n  algorithm).  The default is true (no delay), meaning that data is\n  sent as soon as possible after a Write.\n\n    ```go\n    func SetSocketNoDelay(_noDelay bool)\n    ```\n\n- SetSocketReadBuffer sets the size of the operating system's\n  receive buffer associated with the connection.\n\n    ```go\n    func SetSocketReadBuffer(bytes int)\n    ```\n\n- SetSocketWriteBuffer sets the size of the operating system's\n  transmit buffer associated with the connection.\n\n    ```go\n    func SetSocketWriteBuffer(bytes int)\n    ```\n\n\n## Extensions\n\n### Codec\n\n| package                                  | import                                   | description                  |\n| ---------------------------------------- | ---------------------------------------- | ---------------------------- |\n| [json](https://github.com/andeya/erpc/blob/master/codec/json_codec.go) | `\"github.com/andeya/erpc/v7/codec\"` | JSON codec(erpc own)     |\n| [protobuf](https://github.com/andeya/erpc/blob/master/codec/protobuf_codec.go) | `\"github.com/andeya/erpc/v7/codec\"` | Protobuf codec(erpc own) |\n| [thrift](https://github.com/andeya/erpc/blob/master/codec/thrift_codec.go) | `\"github.com/andeya/erpc/v7/codec\"` | Form(url encode) codec(erpc own)   |\n| [xml](https://github.com/andeya/erpc/blob/master/codec/xml_codec.go) | `\"github.com/andeya/erpc/v7/codec\"` | Form(url encode) codec(erpc own)   |\n| [plain](https://github.com/andeya/erpc/blob/master/codec/plain_codec.go) | `\"github.com/andeya/erpc/v7/codec\"` | Plain text codec(erpc own)   |\n| [form](https://github.com/andeya/erpc/blob/master/codec/form_codec.go) | `\"github.com/andeya/erpc/v7/codec\"` | Form(url encode) codec(erpc own)   |\n\n### Plugin\n\n| package                                  | import                                   | description                              |\n| ---------------------------------------- | ---------------------------------------- | ---------------------------------------- |\n| [auth](https://github.com/andeya/erpc/tree/master/plugin/auth) | `\"github.com/andeya/erpc/v7/plugin/auth\"` | An auth plugin for verifying peer at the first time |\n| [binder](https://github.com/andeya/erpc/tree/master/plugin/binder) | `\"github.com/andeya/erpc/v7/plugin/binder\"` | Parameter Binding Verification for Struct Handler |\n| [heartbeat](https://github.com/andeya/erpc/tree/master/plugin/heartbeat) | `\"github.com/andeya/erpc/v7/plugin/heartbeat\"` | A generic timing heartbeat plugin        |\n| [proxy](https://github.com/andeya/erpc/tree/master/plugin/proxy) | `\"github.com/andeya/erpc/v7/plugin/proxy\"` | A proxy plugin for handling unknown calling or pushing |\n[secure](https://github.com/andeya/erpc/tree/master/plugin/secure)|`\"github.com/andeya/erpc/v7/plugin/secure\"` | Encrypting/decrypting the message body\n[overloader](https://github.com/andeya/erpc/tree/master/plugin/overloader)|`\"github.com/andeya/erpc/v7/plugin/overloader\"` | A plugin to protect erpc from overload\n\n### Protocol\n\n| package                                  | import                                   | description                              |\n| ---------------------------------------- | ---------------------------------------- | ---------------------------------------- |\n| [rawproto](https://github.com/andeya/erpc/tree/master/proto/rawproto) | `\"github.com/andeya/erpc/v7/proto/rawproto` | A fast socket communication protocol(erpc default protocol) |\n| [jsonproto](https://github.com/andeya/erpc/tree/master/proto/jsonproto) | `\"github.com/andeya/erpc/v7/proto/jsonproto\"` | A JSON socket communication protocol     |\n| [pbproto](https://github.com/andeya/erpc/tree/master/proto/pbproto) | `\"github.com/andeya/erpc/v7/proto/pbproto\"` | A Protobuf socket communication protocol     |\n| [thriftproto](https://github.com/andeya/erpc/tree/master/proto/thriftproto) | `\"github.com/andeya/erpc/v7/proto/thriftproto\"` | A Thrift communication protocol     |\n| [httproto](https://github.com/andeya/erpc/tree/master/proto/httproto) | `\"github.com/andeya/erpc/v7/proto/httproto\"` | A HTTP style socket communication protocol     |\n\n### Transfer-Filter\n\n| package                                  | import                                   | description                              |\n| ---------------------------------------- | ---------------------------------------- | ---------------------------------------- |\n| [gzip](https://github.com/andeya/erpc/tree/master/xfer/gzip) | `\"github.com/andeya/erpc/v7/xfer/gzip\"` | Gzip(erpc own)                       |\n| [md5](https://github.com/andeya/erpc/tree/master/xfer/md5) | `\"github.com/andeya/erpc/v7/xfer/md5\"` | Provides a integrity check transfer filter |\n\n### Mixer\n\n| package                                  | import                                   | description                              |\n| ---------------------------------------- | ---------------------------------------- | ---------------------------------------- |\n| [multiclient](https://github.com/andeya/erpc/tree/master/mixer/multiclient) | `\"github.com/andeya/erpc/v7/mixer/multiclient\"` | Higher throughput client connection pool when transferring large messages (such as downloading files) |\n| [websocket](https://github.com/andeya/erpc/tree/master/mixer/websocket) | `\"github.com/andeya/erpc/v7/mixer/websocket\"` | Makes the eRPC framework compatible with websocket protocol as specified in RFC 6455 |\n| [evio](https://github.com/andeya/erpc/tree/master/mixer/evio) | `\"github.com/andeya/erpc/v7/mixer/evio\"` | A fast event-loop networking framework that uses the erpc API layer |\n| [html](https://github.com/xiaoenai/tp-micro/tree/master/helper/mod-html) | `html \"github.com/xiaoenai/tp-micro/helper/mod-html\"` | HTML render for http client |\n\n## Projects based on eRPC\n\n| project                                  | description                              |\n| ---------------------------------------- | ---------------------------------------- |\n| [TP-Micro](https://github.com/xiaoenai/tp-micro) | TP-Micro is a simple, powerful micro service framework based on eRPC |\n| [Pholcus](https://github.com/andeya/pholcus) | Pholcus is a distributed, high concurrency and powerful web crawler software |\n\n## Business Users\n\n<a href=\"http://www.xiaoenai.com\"><img src=\"https://raw.githubusercontent.com/andeya/imgs-repo/master/xiaoenai.png\" height=\"50\" alt=\"深圳市梦之舵信息技术有限公司\"/></a>\n&nbsp;&nbsp;\n<a href=\"https://tech.pingan.com/index.html\"><img src=\"http://pa-tech.hirede.com/templates/pa-tech/Images/logo.png\" height=\"50\" alt=\"平安科技\"/></a>\n<br/>\n<a href=\"http://www.fun.tv\"><img src=\"http://static.funshion.com/open/static/img/logo.gif\" height=\"70\" alt=\"北京风行在线技术有限公司\"/></a>\n&nbsp;&nbsp;\n<a href=\"http://www.kejishidai.cn\"><img src=\"http://simg.ktvms.com/picture/logo.png\" height=\"70\" alt=\"北京可即时代网络公司\"/></a>\n<a href=\"https://www.kuaishou.com/\"><img src=\"https://inews.gtimg.com/newsapp_bt/0/4400789257/1000\" height=\"70\" alt=\"快手短视频平台\"/></a>\n\n## License\n\neRPC is under Apache v2 License. See the [LICENSE](https://github.com/andeya/erpc/raw/master/LICENSE) file for the full license text\n"
        },
        {
          "name": "README_ZH.md",
          "type": "blob",
          "size": 21.109375,
          "content": "# eRPC\r\n\r\n[![tag](https://img.shields.io/github/tag/andeya/erpc.svg)](https://github.com/andeya/erpc/releases)\r\n![Go Version](https://img.shields.io/badge/Go-%3E%3D%201.18-%23007d9c)\r\n[![GoDoc](https://godoc.org/github.com/andeya/erpc?status.svg)](https://pkg.go.dev/github.com/andeya/erpc/v7)\r\n![Build Status](https://github.com/andeya/erpc/actions/workflows/go-ci.yml/badge.svg)\r\n[![Go report](https://goreportcard.com/badge/github.com/andeya/erpc/v7)](https://goreportcard.com/report/github.com/andeya/erpc/v7)\r\n[![License](https://img.shields.io/github/license/andeya/erpc)](./LICENSE)\r\n\r\n[![view Go网络编程群](https://img.shields.io/badge/官方QQ群-Go网络编程(42730308)-27a5ea.svg?style=flat-square)](http://jq.qq.com/?_wv=1027&k=fzi4p1)\r\n\r\n\r\neRPC 是一个高效、可扩展且简单易用的 RPC 框架。\r\n\r\n适用于 RPC、微服务、点对点长连接、IM 和游戏等领域。\r\n\r\n\r\n![eRPC-Framework](https://github.com/andeya/erpc/raw/master/doc/erpc_module_diagram.png)\r\n\r\n\r\n## 安装\r\n\r\n- go vesion ≥ 1.18\r\n\r\n- install\r\n```sh\r\nGO111MODULE=on go get -u -v -insecure github.com/andeya/erpc/v7\r\n```\r\n\r\n- import\r\n```go\r\nimport \"github.com/andeya/erpc/v7\"\r\n```\r\n\r\n## 特性\r\n\r\n- 使用 peer 为 server 和 client 提供相同的 API 封装\r\n- 提供多层抽象，如：\r\n  - peer\r\n  - session/socket\r\n  - router\r\n  - handle/context\r\n  - message\r\n  - protocol\r\n  - codec\r\n  - transfer filter\r\n  - plugin\r\n- 支持平滑重启和关闭\r\n- 兼容 HTTP 的消息格式：\r\n  - 由 `Header` 和 `Body` 两部分组成\r\n  - `Header` 包含与 HTTP header 格式相同的 metadata\r\n  - `Body` 支持类似 Content Type 的自定义编解码器，已经实现的：\r\n    - Protobuf\r\n    - Thrift\r\n    - JSON\r\n    - XML\r\n    - Form\r\n    - Plain\r\n  - 支持 push、call-reply 和更多的消息类型\r\n- 支持自定义消息协议，并提供了一些常见实现：\r\n  - `rawproto` - 默认的高性能二进制协议\r\n  - `jsonproto` - JSON 消息协议\r\n  - `pbproto` - Ptotobuf 消息协议\r\n  - `thriftproto` - Thrift 消息协议\r\n  - `httproto` - HTTP 消息协议\r\n- 可优化的高性能传输层\r\n  - 使用 Non-block socket 和 I/O 多路复用技术\r\n  - 支持设置套接字 I/O 的缓冲区大小\r\n  - 支持设置读取消息的大小（如果超过则断开连接）\r\n  - 支持控制连接的文件描述符\r\n- 支持多种网络类型：\r\n  - `tcp`\r\n  - `tcp4`\r\n  - `tcp6`\r\n  - `unix`\r\n  - `unixpacket`\r\n  - `kcp`\r\n  - `quic`\r\n  - 其他\r\n    - websocket\r\n    - evio\r\n- 提供丰富的插件埋点，并已实现：\r\n  - auth\r\n  - binder\r\n  - heartbeat\r\n  - ignorecase(service method)\r\n  - overloader\r\n  - proxy(for unknown service method)\r\n  - secure\r\n- 强大灵活的日志系统：\r\n  - 详细的日志信息，支持打印输入和输出详细信息\r\n  - 支持设置慢操作警报阈值\r\n  - 支持自定义实现日志组件\r\n- 客户端会话支持在断开连接后自动重拨\r\n\r\n\r\n## 性能测试\r\n\r\n**自测**\r\n\r\n- 一个服务端与一个客户端进程，在同一台机器上运行\r\n- CPU:    Intel Xeon E312xx (Sandy Bridge) 16 cores 2.53GHz\r\n- Memory: 16G\r\n- OS:     Linux 2.6.32-696.16.1.el6.centos.plus.x86_64, CentOS 6.4\r\n- Go:     1.9.2\r\n- 信息大小: 581 bytes\r\n- 信息编码：protobuf\r\n- 发送 1000000 条信息\r\n\r\n- erpc\r\n\r\n| 并发client | 平均值(ms) | 中位数(ms) | 最大值(ms) | 最小值(ms) | 吞吐率(TPS) |\r\n| -------- | ------- | ------- | ------- | ------- | -------- |\r\n| 100      | 1       | 0       | 16      | 0       | 75505    |\r\n| 500      | 9       | 11      | 97      | 0       | 52192    |\r\n| 1000     | 19      | 24      | 187     | 0       | 50040    |\r\n| 2000     | 39      | 54      | 409     | 0       | 42551    |\r\n| 5000     | 96      | 128     | 1148    | 0       | 46367    |\r\n\r\n- erpc/socket\r\n\r\n| 并发client | 平均值(ms) | 中位数(ms) | 最大值(ms) | 最小值(ms) | 吞吐率(TPS) |\r\n| -------- | ------- | ------- | ------- | ------- | -------- |\r\n| 100      | 0       | 0       | 14      | 0       | 225682   |\r\n| 500      | 2       | 1       | 24      | 0       | 212630   |\r\n| 1000     | 4       | 3       | 51      | 0       | 180733   |\r\n| 2000     | 8       | 6       | 64      | 0       | 183351   |\r\n| 5000     | 21      | 18      | 651     | 0       | 133886   |\r\n\r\n**对比测试**\r\n\r\n<table>\r\n<tr><th>Environment</th><th>Throughputs</th><th>Mean Latency</th><th>P99 Latency</th></tr>\r\n<tr>\r\n<td width=\"10%\"><img src=\"https://github.com/andeya/rpc-benchmark/raw/master/result/env.png\"></td>\r\n<td width=\"30%\"><img src=\"https://github.com/andeya/rpc-benchmark/raw/master/result/throughput.png\"></td>\r\n<td width=\"30%\"><img src=\"https://github.com/andeya/rpc-benchmark/raw/master/result/mean_latency.png\"></td>\r\n<td width=\"30%\"><img src=\"https://github.com/andeya/rpc-benchmark/raw/master/result/p99_latency.png\"></td>\r\n</tr>\r\n</table>\r\n\r\n**[More Detail](https://github.com/andeya/rpc-benchmark)**\r\n\r\n- CPU耗时火焰图 erpc/socket\r\n\r\n![erpc_socket_profile_torch](https://github.com/andeya/erpc/raw/master/doc/erpc_socket_profile_torch.png)\r\n\r\n**[svg file](https://github.com/andeya/erpc/raw/master/doc/erpc_socket_profile_torch.svg)**\r\n\r\n- 堆栈信息火焰图 erpc/socket\r\n\r\n![erpc_socket_heap_torch](https://github.com/andeya/erpc/raw/master/doc/erpc_socket_heap_torch.png)\r\n\r\n**[svg file](https://github.com/andeya/erpc/raw/master/doc/erpc_socket_heap_torch.svg)**\r\n\r\n\r\n## 代码示例\r\n\r\n### server.go\r\n\r\n```go\r\npackage main\r\n\r\nimport (\r\n\t\"fmt\"\r\n\t\"time\"\r\n\r\n\t\"github.com/andeya/erpc/v7\"\r\n)\r\n\r\nfunc main() {\r\n\tdefer erpc.FlushLogger()\r\n\t// graceful\r\n\tgo erpc.GraceSignal()\r\n\r\n\t// server peer\r\n\tsrv := erpc.NewPeer(erpc.PeerConfig{\r\n\t\tCountTime:   true,\r\n\t\tListenPort:  9090,\r\n\t\tPrintDetail: true,\r\n\t})\r\n\t// srv.SetTLSConfig(erpc.GenerateTLSConfigForServer())\r\n\r\n\t// router\r\n\tsrv.RouteCall(new(Math))\r\n\r\n\t// broadcast per 5s\r\n\tgo func() {\r\n\t\tfor {\r\n\t\t\ttime.Sleep(time.Second * 5)\r\n\t\t\tsrv.RangeSession(func(sess erpc.Session) bool {\r\n\t\t\t\tsess.Push(\r\n\t\t\t\t\t\"/push/status\",\r\n\t\t\t\t\tfmt.Sprintf(\"this is a broadcast, server time: %v\", time.Now()),\r\n\t\t\t\t)\r\n\t\t\t\treturn true\r\n\t\t\t})\r\n\t\t}\r\n\t}()\r\n\r\n\t// listen and serve\r\n\tsrv.ListenAndServe()\r\n}\r\n\r\n// Math handler\r\ntype Math struct {\r\n\terpc.CallCtx\r\n}\r\n\r\n// Add handles addition request\r\nfunc (m *Math) Add(arg *[]int) (int, *erpc.Status) {\r\n\t// test meta\r\n\terpc.Infof(\"author: %s\", m.PeekMeta(\"author\"))\r\n\t// add\r\n\tvar r int\r\n\tfor _, a := range *arg {\r\n\t\tr += a\r\n\t}\r\n\t// response\r\n\treturn r, nil\r\n}\r\n```\r\n\r\n### client.go\r\n\r\n```go\r\npackage main\r\n\r\nimport (\r\n\t\"time\"\r\n\r\n\t\"github.com/andeya/erpc/v7\"\r\n)\r\n\r\nfunc main() {\r\n\tdefer erpc.SetLoggerLevel(\"ERROR\")()\r\n\r\n\tcli := erpc.NewPeer(erpc.PeerConfig{})\r\n\tdefer cli.Close()\r\n\t// cli.SetTLSConfig(&tls.Config{InsecureSkipVerify: true})\r\n\r\n\tcli.RoutePush(new(Push))\r\n\r\n\tsess, stat := cli.Dial(\":9090\")\r\n\tif !stat.OK() {\r\n\t\terpc.Fatalf(\"%v\", stat)\r\n\t}\r\n\r\n\tvar result int\r\n\tstat = sess.Call(\"/math/add\",\r\n\t\t[]int{1, 2, 3, 4, 5},\r\n\t\t&result,\r\n\t\terpc.WithAddMeta(\"author\", \"andeya\"),\r\n\t).Status()\r\n\tif !stat.OK() {\r\n\t\terpc.Fatalf(\"%v\", stat)\r\n\t}\r\n\terpc.Printf(\"result: %d\", result)\r\n\terpc.Printf(\"Wait 10 seconds to receive the push...\")\r\n  time.Sleep(time.Second * 10)\r\n}\r\n\r\n// Push push handler\r\ntype Push struct {\r\n  erpc.PushCtx\r\n}\r\n\r\n// Push handles '/push/status' message\r\nfunc (p *Push) Status(arg *string) *erpc.Status {\r\n  erpc.Printf(\"%s\", *arg)\r\n  return nil\r\n}\r\n```\r\n\r\n[更多示例](https://github.com/andeya/erpc/blob/master/examples)\r\n\r\n## 用法\r\n\r\n**NOTE:**\r\n\r\n- 最好设置读包时大小限制: `SetReadLimit`\r\n- 默认读包时大小限制为 1 GB\r\n\r\n### Peer端点（服务端或客户端）示例\r\n\r\n```go\r\n// Start a server\r\nvar peer1 = erpc.NewPeer(erpc.PeerConfig{\r\nListenPort: 9090, // for server role\r\n})\r\npeer1.Listen()\r\n\r\n...\r\n\r\n// Start a client\r\nvar peer2 = erpc.NewPeer(erpc.PeerConfig{})\r\nvar sess, err = peer2.Dial(\"127.0.0.1:8080\")\r\n```\r\n\r\n### 自带ServiceMethod映射规则\r\n\r\n- 结构体或方法名称到服务方法名称的默认映射（HTTPServiceMethodMapper）：\r\n    - `AaBb` -> `/aa_bb`\r\n    - `ABcXYz` -> `/abc_xyz`\r\n    - `Aa__Bb` -> `/aa_bb`\r\n    - `aa__bb` -> `/aa_bb`\r\n    - `ABC__XYZ` -> `/abc_xyz`\r\n    - `Aa_Bb` -> `/aa/bb`\r\n    - `aa_bb` -> `/aa/bb`\r\n    - `ABC_XYZ` -> `/abc/xyz`\r\n    ```go\r\n    erpc.SetServiceMethodMapper(erpc.HTTPServiceMethodMapper)\r\n    ```\r\n\r\n- 结构体或方法名称到服务方法名称的映射（RPCServiceMethodMapper）：\r\n    - `AaBb` -> `AaBb`\r\n    - `ABcXYz` -> `ABcXYz`\r\n    - `Aa__Bb` -> `Aa_Bb`\r\n    - `aa__bb` -> `aa_bb`\r\n    - `ABC__XYZ` -> `ABC_XYZ`\r\n    - `Aa_Bb` -> `Aa.Bb`\r\n    - `aa_bb` -> `aa.bb`\r\n    - `ABC_XYZ` -> `ABC.XYZ`\r\n    ```go\r\n    erpc.SetServiceMethodMapper(erpc.RPCServiceMethodMapper)\r\n    ```\r\n\r\n### Call-Struct 接口模版\r\n\r\n```go\r\ntype Aaa struct {\r\n    erpc.CallCtx\r\n}\r\nfunc (x *Aaa) XxZz(arg *<T>) (<T>, *erpc.Status) {\r\n    ...\r\n    return r, nil\r\n}\r\n```\r\n\r\n- 注册到根路由：\r\n\r\n```go\r\n// register the call route\r\n// HTTP mapping: /aaa/xx_zz\r\n// RPC mapping: Aaa.XxZz\r\npeer.RouteCall(new(Aaa))\r\n\r\n// or register the call route\r\n// HTTP mapping: /xx_zz\r\n// RPC mapping: XxZz\r\npeer.RouteCallFunc((*Aaa).XxZz)\r\n```\r\n\r\n### Call-Function 接口模板\r\n\r\n```go\r\nfunc XxZz(ctx erpc.CallCtx, arg *<T>) (<T>, *erpc.Status) {\r\n    ...\r\n    return r, nil\r\n}\r\n```\r\n\r\n- 注册到根路由：\r\n\r\n```go\r\n// register the call route\r\n// HTTP mapping: /xx_zz\r\n// RPC mapping: XxZz\r\npeer.RouteCallFunc(XxZz)\r\n```\r\n\r\n### Push-Struct 接口模板\r\n\r\n```go\r\ntype Bbb struct {\r\n    erpc.PushCtx\r\n}\r\nfunc (b *Bbb) YyZz(arg *<T>) *erpc.Status {\r\n    ...\r\n    return nil\r\n}\r\n```\r\n\r\n- 注册到根路由：\r\n\r\n```go\r\n// register the push handler\r\n// HTTP mapping: /bbb/yy_zz\r\n// RPC mapping: Bbb.YyZz\r\npeer.RoutePush(new(Bbb))\r\n\r\n// or register the push handler\r\n// HTTP mapping: /yy_zz\r\n// RPC mapping: YyZz\r\npeer.RoutePushFunc((*Bbb).YyZz)\r\n```\r\n\r\n### Push-Function 接口模板\r\n\r\n```go\r\n// YyZz register the handler\r\nfunc YyZz(ctx erpc.PushCtx, arg *<T>) *erpc.Status {\r\n    ...\r\n    return nil\r\n}\r\n```\r\n\r\n- 注册到根路由：\r\n\r\n```go\r\n// register the push handler\r\n// HTTP mapping: /yy_zz\r\n// RPC mapping: YyZz\r\npeer.RoutePushFunc(YyZz)\r\n```\r\n\r\n### Unknown-Call-Function 接口模板\r\n\r\n```go\r\nfunc XxxUnknownCall (ctx erpc.UnknownCallCtx) (interface{}, *erpc.Status) {\r\n    ...\r\n    return r, nil\r\n}\r\n```\r\n\r\n- 注册到根路由：\r\n\r\n```go\r\n// register the unknown pull route: /*\r\npeer.SetUnknownCall(XxxUnknownCall)\r\n```\r\n\r\n### Unknown-Push-Function 接口模板\r\n\r\n```go\r\nfunc XxxUnknownPush(ctx erpc.UnknownPushCtx) *erpc.Status {\r\n    ...\r\n    return nil\r\n}\r\n```\r\n\r\n- 注册到根路由：\r\n\r\n```go\r\n// register the unknown push route: /*\r\npeer.SetUnknownPush(XxxUnknownPush)\r\n```\r\n\r\n### 插件示例\r\n\r\n```go\r\n// NewIgnoreCase Returns a ignoreCase plugin.\r\nfunc NewIgnoreCase() *ignoreCase {\r\n    return &ignoreCase{}\r\n}\r\n\r\ntype ignoreCase struct{}\r\n\r\nvar (\r\n    _ erpc.PostReadCallHeaderPlugin = new(ignoreCase)\r\n    _ erpc.PostReadPushHeaderPlugin = new(ignoreCase)\r\n)\r\n\r\nfunc (i *ignoreCase) Name() string {\r\n    return \"ignoreCase\"\r\n}\r\n\r\nfunc (i *ignoreCase) PostReadCallHeader(ctx erpc.ReadCtx) *erpc.Status {\r\n    // Dynamic transformation path is lowercase\r\n    ctx.UriObject().Path = strings.ToLower(ctx.UriObject().Path)\r\n    return nil\r\n}\r\n\r\nfunc (i *ignoreCase) PostReadPushHeader(ctx erpc.ReadCtx) *erpc.Status {\r\n    // Dynamic transformation path is lowercase\r\n    ctx.UriObject().Path = strings.ToLower(ctx.UriObject().Path)\r\n    return nil\r\n}\r\n```\r\n\r\n### 注册以上操作和插件示例到路由\r\n\r\n```go\r\n// add router group\r\ngroup := peer.SubRoute(\"test\")\r\n// register to test group\r\ngroup.RouteCall(new(Aaa), NewIgnoreCase())\r\npeer.RouteCallFunc(XxZz, NewIgnoreCase())\r\ngroup.RoutePush(new(Bbb))\r\npeer.RoutePushFunc(YyZz)\r\npeer.SetUnknownCall(XxxUnknownCall)\r\npeer.SetUnknownPush(XxxUnknownPush)\r\n```\r\n\r\n### 配置信息\r\n\r\n```go\r\ntype PeerConfig struct {\r\n    Network            string        `yaml:\"network\"              ini:\"network\"              comment:\"Network; tcp, tcp4, tcp6, unix, unixpacket, kcp or quic\"`\r\n    LocalIP            string        `yaml:\"local_ip\"             ini:\"local_ip\"             comment:\"Local IP\"`\r\n    ListenPort         uint16        `yaml:\"listen_port\"          ini:\"listen_port\"          comment:\"Listen port; for server role\"`\r\n    DialTimeout time.Duration `yaml:\"dial_timeout\" ini:\"dial_timeout\" comment:\"Default maximum duration for dialing; for client role; ns,µs,ms,s,m,h\"`\r\n    RedialTimes        int32         `yaml:\"redial_times\"         ini:\"redial_times\"         comment:\"The maximum times of attempts to redial, after the connection has been unexpectedly broken; Unlimited when <0; for client role\"`\r\n\tRedialInterval     time.Duration `yaml:\"redial_interval\"      ini:\"redial_interval\"      comment:\"Interval of redialing each time, default 100ms; for client role; ns,µs,ms,s,m,h\"`\r\n    DefaultBodyCodec   string        `yaml:\"default_body_codec\"   ini:\"default_body_codec\"   comment:\"Default body codec type id\"`\r\n    DefaultSessionAge  time.Duration `yaml:\"default_session_age\"  ini:\"default_session_age\"  comment:\"Default session max age, if less than or equal to 0, no time limit; ns,µs,ms,s,m,h\"`\r\n    DefaultContextAge  time.Duration `yaml:\"default_context_age\"  ini:\"default_context_age\"  comment:\"Default PULL or PUSH context max age, if less than or equal to 0, no time limit; ns,µs,ms,s,m,h\"`\r\n    SlowCometDuration  time.Duration `yaml:\"slow_comet_duration\"  ini:\"slow_comet_duration\"  comment:\"Slow operation alarm threshold; ns,µs,ms,s ...\"`\r\n    PrintDetail        bool          `yaml:\"print_detail\"         ini:\"print_detail\"         comment:\"Is print body and metadata or not\"`\r\n    CountTime          bool          `yaml:\"count_time\"           ini:\"count_time\"           comment:\"Is count cost time or not\"`\r\n}\r\n```\r\n\r\n### 通信优化\r\n\r\n- SetMessageSizeLimit 设置报文大小的上限，\r\n  如果 maxSize<=0，上限默认为最大 uint32\r\n\r\n    ```go\r\n    func SetMessageSizeLimit(maxMessageSize uint32)\r\n    ```\r\n\r\n- SetSocketKeepAlive 是否允许操作系统的发送TCP的keepalive探测包\r\n\r\n    ```go\r\n    func SetSocketKeepAlive(keepalive bool)\r\n    ```\r\n\r\n\r\n- SetSocketKeepAlivePeriod 设置操作系统的TCP发送keepalive探测包的频度\r\n\r\n    ```go\r\n    func SetSocketKeepAlivePeriod(d time.Duration)\r\n    ```\r\n\r\n- SetSocketNoDelay 是否禁用Nagle算法，禁用后将不在合并较小数据包进行批量发送，默认为禁用\r\n\r\n    ```go\r\n    func SetSocketNoDelay(_noDelay bool)\r\n    ```\r\n\r\n- SetSocketReadBuffer 设置操作系统的TCP读缓存区的大小\r\n\r\n    ```go\r\n    func SetSocketReadBuffer(bytes int)\r\n    ```\r\n\r\n- SetSocketWriteBuffer 设置操作系统的TCP写缓存区的大小\r\n\r\n    ```go\r\n    func SetSocketWriteBuffer(bytes int)\r\n    ```\r\n\r\n\r\n## 扩展包\r\n\r\n### 编解码器\r\n| package                                  | import                                   | description                  |\r\n| ---------------------------------------- | ---------------------------------------- | ---------------------------- |\r\n| [json](https://github.com/andeya/erpc/blob/master/codec/json_codec.go) | `\"github.com/andeya/erpc/v7/codec\"` | JSON codec(erpc own)     |\r\n| [protobuf](https://github.com/andeya/erpc/blob/master/codec/protobuf_codec.go) | `\"github.com/andeya/erpc/v7/codec\"` | Protobuf codec(erpc own) |\r\n| [thrift](https://github.com/andeya/erpc/blob/master/codec/thrift_codec.go) | `\"github.com/andeya/erpc/v7/codec\"` | Form(url encode) codec(erpc own)   |\r\n| [xml](https://github.com/andeya/erpc/blob/master/codec/xml_codec.go) | `\"github.com/andeya/erpc/v7/codec\"` | Form(url encode) codec(erpc own)   |\r\n| [plain](https://github.com/andeya/erpc/blob/master/codec/plain_codec.go) | `\"github.com/andeya/erpc/v7/codec\"` | Plain text codec(erpc own)   |\r\n| [form](https://github.com/andeya/erpc/blob/master/codec/form_codec.go) | `\"github.com/andeya/erpc/v7/codec\"` | Form(url encode) codec(erpc own)   |\r\n\r\n### 插件\r\n\r\n| package                                  | import                                   | description                              |\r\n| ---------------------------------------- | ---------------------------------------- | ---------------------------------------- |\r\n| [auth](https://github.com/andeya/erpc/tree/master/plugin/auth) | `\"github.com/andeya/erpc/v7/plugin/auth\"` | An auth plugin for verifying peer at the first time |\r\n| [binder](https://github.com/andeya/erpc/tree/master/plugin/binder) | `\"github.com/andeya/erpc/v7/plugin/binder\"` | Parameter Binding Verification for Struct Handler |\r\n| [heartbeat](https://github.com/andeya/erpc/tree/master/plugin/heartbeat) | `\"github.com/andeya/erpc/v7/plugin/heartbeat\"` | A generic timing heartbeat plugin        |\r\n| [proxy](https://github.com/andeya/erpc/tree/master/plugin/proxy) | `\"github.com/andeya/erpc/v7/plugin/proxy\"` | A proxy plugin for handling unknown calling or pushing |\r\n[secure](https://github.com/andeya/erpc/tree/master/plugin/secure)|`\"github.com/andeya/erpc/v7/plugin/secure\"` | Encrypting/decrypting the message body\r\n[overloader](https://github.com/andeya/erpc/tree/master/plugin/overloader)|`\"github.com/andeya/erpc/v7/plugin/overloader\"` | A plugin to protect erpc from overload\r\n\r\n### 协议\r\n\r\n| package                                  | import                                   | description                              |\r\n| ---------------------------------------- | ---------------------------------------- | ---------------------------------------- |\r\n| [rawproto](https://github.com/andeya/erpc/tree/master/proto/rawproto) | `\"github.com/andeya/erpc/v7/proto/rawproto` | 一个高性能的通信协议（erpc默认）|\r\n| [jsonproto](https://github.com/andeya/erpc/tree/master/proto/jsonproto) | `\"github.com/andeya/erpc/v7/proto/jsonproto\"` | JSON 格式的通信协议     |\r\n| [pbproto](https://github.com/andeya/erpc/tree/master/proto/pbproto) | `\"github.com/andeya/erpc/v7/proto/pbproto\"` | Protobuf 格式的通信协议     |\r\n| [thriftproto](https://github.com/andeya/erpc/tree/master/proto/thriftproto) | `\"github.com/andeya/erpc/v7/proto/thriftproto\"` | Thrift 格式的通信协议     |\r\n| [httproto](https://github.com/andeya/erpc/tree/master/proto/httproto) | `\"github.com/andeya/erpc/v7/proto/httproto\"` | HTTP 格式的通信协议     |\r\n\r\n### 传输过滤器\r\n\r\n| package                                  | import                                   | description                              |\r\n| ---------------------------------------- | ---------------------------------------- | ---------------------------------------- |\r\n| [gzip](https://github.com/andeya/erpc/tree/master/xfer/gzip) | `\"github.com/andeya/erpc/v7/xfer/gzip\"` | Gzip(erpc own)                       |\r\n| [md5](https://github.com/andeya/erpc/tree/master/xfer/md5) | `\"github.com/andeya/erpc/v7/xfer/md5\"` | Provides a integrity check transfer filter |\r\n\r\n### 其他模块\r\n\r\n| package                                  | import                                   | description                              |\r\n| ---------------------------------------- | ---------------------------------------- | ---------------------------------------- |\r\n| [multiclient](https://github.com/andeya/erpc/tree/master/mixer/multiclient) | `\"github.com/andeya/erpc/v7/mixer/multiclient\"` | Higher throughput client connection pool when transferring large messages (such as downloading files) |\r\n| [websocket](https://github.com/andeya/erpc/tree/master/mixer/websocket) | `\"github.com/andeya/erpc/v7/mixer/websocket\"` | Makes the eRPC framework compatible with websocket protocol as specified in RFC 6455 |\r\n| [evio](https://github.com/andeya/erpc/tree/master/mixer/evio) | `\"github.com/andeya/erpc/v7/mixer/evio\"` | A fast event-loop networking framework that uses the erpc API layer |\r\n| [html](https://github.com/xiaoenai/tp-micro/tree/master/helper/mod-html) | `html \"github.com/xiaoenai/tp-micro/helper/mod-html\"` | HTML render for http client |\r\n\r\n## 基于eRPC的项目\r\n\r\n| project                                  | description                              |\r\n| ---------------------------------------- | ---------------------------------------- |\r\n| [TP-Micro](https://github.com/xiaoenai/tp-micro) | TP-Micro 是一个基于 eRPC 定制的、简约而强大的微服务框架          |\r\n| [Pholcus](https://github.com/andeya/pholcus) | Pholcus（幽灵蛛）是一款纯Go语言编写的支持分布式的高并发、重量级爬虫软件，定位于互联网数据采集，为具备一定Go或JS编程基础的人提供一个只需关注规则定制的功能强大的爬虫工具 |\r\n\r\n## 企业用户\r\n\r\n<a href=\"http://www.xiaoenai.com\"><img src=\"https://raw.githubusercontent.com/andeya/imgs-repo/master/xiaoenai.png\" height=\"50\" alt=\"深圳市梦之舵信息技术有限公司\"/></a>\r\n&nbsp;&nbsp;\r\n<a href=\"https://tech.pingan.com/index.html\"><img src=\"http://pa-tech.hirede.com/templates/pa-tech/Images/logo.png\" height=\"50\" alt=\"平安科技\"/></a>\r\n<br/>\r\n<a href=\"http://www.fun.tv\"><img src=\"http://static.funshion.com/open/static/img/logo.gif\" height=\"70\" alt=\"北京风行在线技术有限公司\"/></a>\r\n&nbsp;&nbsp;\r\n<a href=\"http://www.kejishidai.cn\"><img src=\"http://simg.ktvms.com/picture/logo.png\" height=\"70\" alt=\"北京可即时代网络公司\"/></a>\r\n<a href=\"https://www.kuaishou.com/\"><img src=\"https://inews.gtimg.com/newsapp_bt/0/4400789257/1000\" height=\"70\" alt=\"快手短视频平台\"/></a>\r\n\r\n## 开源协议\r\n\r\neRPC 项目采用商业应用友好的 [Apache2.0](https://github.com/andeya/erpc/raw/master/LICENSE) 协议发布\r\n"
        },
        {
          "name": "codec",
          "type": "tree",
          "content": null
        },
        {
          "name": "config.go",
          "type": "blob",
          "size": 8.0869140625,
          "content": "// Copyright 2015-2019 HenryLee. All Rights Reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage erpc\n\nimport (\n\t\"errors\"\n\t\"math\"\n\t\"net\"\n\t\"strconv\"\n\t\"time\"\n\n\t\"github.com/andeya/cfgo\"\n\t\"github.com/andeya/erpc/v7/codec\"\n\t\"github.com/andeya/erpc/v7/socket\"\n)\n\n// PeerConfig peer config\n// NOTE:\n//\n//\tyaml tag is used for github.com/andeya/cfgo\n//\tini tag is used for github.com/andeya/ini\ntype PeerConfig struct {\n\tNetwork           string        `yaml:\"network\"              ini:\"network\"              comment:\"Network; tcp, tcp4, tcp6, unix, unixpacket, kcp or quic\"`\n\tLocalIP           string        `yaml:\"local_ip\"             ini:\"local_ip\"             comment:\"Local IP\"`\n\tLocalPort         uint16        `yaml:\"local_port\"           ini:\"local_port\"           comment:\"Local port; for client role\"`\n\tListenPort        uint16        `yaml:\"listen_port\"          ini:\"listen_port\"          comment:\"Listen port; for server role\"`\n\tDialTimeout       time.Duration `yaml:\"dial_timeout\"         ini:\"dial_timeout\"         comment:\"Maximum duration for dialing; for client role; ns,µs,ms,s,m,h\"`\n\tRedialTimes       int32         `yaml:\"redial_times\"         ini:\"redial_times\"         comment:\"The maximum times of attempts to redial, after the connection has been unexpectedly broken; Unlimited when <0; for client role\"`\n\tRedialInterval    time.Duration `yaml:\"redial_interval\"      ini:\"redial_interval\"      comment:\"Interval of redialing each time, default 100ms; for client role; ns,µs,ms,s,m,h\"`\n\tDefaultBodyCodec  string        `yaml:\"default_body_codec\"   ini:\"default_body_codec\"   comment:\"Default body codec type id\"`\n\tDefaultSessionAge time.Duration `yaml:\"default_session_age\"  ini:\"default_session_age\"  comment:\"Default session max age, if less than or equal to 0, no time limit; ns,µs,ms,s,m,h\"`\n\tDefaultContextAge time.Duration `yaml:\"default_context_age\"  ini:\"default_context_age\"  comment:\"Default CALL or PUSH context max age, if less than or equal to 0, no time limit; ns,µs,ms,s,m,h\"`\n\tSlowCometDuration time.Duration `yaml:\"slow_comet_duration\"  ini:\"slow_comet_duration\"  comment:\"Slow operation alarm threshold; ns,µs,ms,s ...\"`\n\tPrintDetail       bool          `yaml:\"print_detail\"         ini:\"print_detail\"         comment:\"Is print body and metadata or not\"`\n\tCountTime         bool          `yaml:\"count_time\"           ini:\"count_time\"           comment:\"Is count cost time or not\"`\n\n\tlocalAddr         net.Addr\n\tlistenAddr        net.Addr\n\tslowCometDuration time.Duration\n\tchecked           bool\n}\n\nvar _ cfgo.Config = new(PeerConfig)\n\n// ListenAddr returns the listener address.\nfunc (p *PeerConfig) ListenAddr() net.Addr {\n\tp.check()\n\treturn p.listenAddr\n}\n\n// LocalAddr returns the local address.\nfunc (p *PeerConfig) LocalAddr() net.Addr {\n\tp.check()\n\treturn p.localAddr\n}\n\n// Reload Bi-directionally synchronizes config between YAML file and memory.\nfunc (p *PeerConfig) Reload(bind cfgo.BindFunc) error {\n\terr := bind()\n\tif err != nil {\n\t\treturn err\n\t}\n\tp.checked = false\n\treturn p.check()\n}\n\nfunc (p *PeerConfig) check() (err error) {\n\tif p.checked {\n\t\treturn nil\n\t}\n\tp.checked = true\n\tif p.Network == \"\" {\n\t\tp.Network = \"tcp\"\n\t}\n\tif p.LocalIP == \"\" {\n\t\tp.LocalIP = \"0.0.0.0\"\n\t}\n\tp.localAddr, err = p.newAddr(strconv.Itoa(int(p.LocalPort)))\n\tif err != nil {\n\t\treturn err\n\t}\n\tlistenPort := strconv.FormatUint(uint64(p.ListenPort), 10)\n\tp.listenAddr = NewFakeAddr(p.Network, p.LocalIP, listenPort)\n\tp.slowCometDuration = math.MaxInt64\n\tif p.SlowCometDuration > 0 {\n\t\tp.slowCometDuration = p.SlowCometDuration\n\t}\n\tif len(p.DefaultBodyCodec) == 0 {\n\t\tp.DefaultBodyCodec = DefaultBodyCodec().Name()\n\t}\n\tif p.RedialInterval <= 0 {\n\t\tp.RedialInterval = time.Millisecond * 100\n\t}\n\treturn nil\n}\n\nfunc (p *PeerConfig) newAddr(port string) (net.Addr, error) {\n\tswitch p.Network {\n\tdefault:\n\t\treturn nil, errors.New(\"Invalid network config, refer to the following: tcp, tcp4, tcp6, unix, unixpacket, kcp or quic\")\n\tcase \"tcp\", \"tcp4\", \"tcp6\":\n\t\treturn net.ResolveTCPAddr(p.Network, net.JoinHostPort(p.LocalIP, port))\n\tcase \"unix\", \"unixpacket\":\n\t\treturn net.ResolveUnixAddr(p.Network, net.JoinHostPort(p.LocalIP, port))\n\tcase \"kcp\", \"udp\", \"udp4\", \"udp6\", \"quic\":\n\t\tudpAddr, err := net.ResolveUDPAddr(\"udp\", net.JoinHostPort(p.LocalIP, port))\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tnetwork := \"kcp\"\n\t\tif p.Network == \"quic\" {\n\t\t\tnetwork = \"quic\"\n\t\t}\n\t\treturn &FakeAddr{\n\t\t\tnetwork: network,\n\t\t\taddr:    udpAddr.String(),\n\t\t\thost:    p.LocalIP,\n\t\t\tport:    strconv.Itoa(udpAddr.Port),\n\t\t\tudpAddr: udpAddr,\n\t\t}, nil\n\t}\n}\n\nfunc asQUIC(network string) string {\n\tswitch network {\n\tcase \"quic\":\n\t\treturn \"udp\"\n\tdefault:\n\t\treturn \"\"\n\t}\n}\n\nfunc asKCP(network string) string {\n\tswitch network {\n\tcase \"kcp\":\n\t\treturn \"udp\"\n\tcase \"udp\", \"udp4\", \"udp6\":\n\t\treturn network\n\tdefault:\n\t\treturn \"\"\n\t}\n}\n\nvar defaultBodyCodec codec.Codec = new(codec.JSONCodec)\n\n// DefaultBodyCodec gets the default body codec.\nfunc DefaultBodyCodec() codec.Codec {\n\treturn defaultBodyCodec\n}\n\n// SetDefaultBodyCodec sets the default body codec.\nfunc SetDefaultBodyCodec(codecID byte) error {\n\tc, err := codec.Get(codecID)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefaultBodyCodec = c\n\treturn nil\n}\n\n// DefaultProtoFunc gets the default builder of socket communication protocol\n//\n//\tfunc DefaultProtoFunc() erpc.ProtoFunc\nvar DefaultProtoFunc = socket.DefaultProtoFunc\n\n// SetDefaultProtoFunc sets the default builder of socket communication protocol\n//\n//\tfunc SetDefaultProtoFunc(protoFunc erpc.ProtoFunc)\nvar SetDefaultProtoFunc = socket.SetDefaultProtoFunc\n\n// GetReadLimit gets the message size upper limit of reading.\n//\n//\tGetReadLimit() uint32\nvar GetReadLimit = socket.MessageSizeLimit\n\n// SetReadLimit sets max message size.\n// If maxSize<=0, set it to 1GB.\n//\n//\tfunc SetReadLimit(maxMessageSize uint32)\nvar SetReadLimit = socket.SetMessageSizeLimit\n\n// SetSocketKeepAlive sets whether the operating system should send\n// keepalive messages on the connection.\n// NOTE: If have not called the function, the system defaults are used.\n//\n//\tfunc SetSocketKeepAlive(keepalive bool)\nvar SetSocketKeepAlive = socket.SetKeepAlive\n\n// SetSocketKeepAlivePeriod sets period between keep alives.\n// NOTE: if d<0, don't change the value.\n//\n//\tfunc SetSocketKeepAlivePeriod(d time.Duration)\nvar SetSocketKeepAlivePeriod = socket.SetKeepAlivePeriod\n\n// SocketReadBuffer returns the size of the operating system's\n// receive buffer associated with the connection.\n// NOTE: if using the system default value, bytes=-1 and isDefault=true.\n//\n//\tfunc SocketReadBuffer() (bytes int, isDefault bool)\nvar SocketReadBuffer = socket.ReadBuffer\n\n// SetSocketReadBuffer sets the size of the operating system's\n// receive buffer associated with the connection.\n// NOTE: if bytes<0, don't change the value.\n//\n//\tfunc SetSocketReadBuffer(bytes int)\nvar SetSocketReadBuffer = socket.SetReadBuffer\n\n// SocketWriteBuffer returns the size of the operating system's\n// transmit buffer associated with the connection.\n// NOTE: if using the system default value, bytes=-1 and isDefault=true.\n//\n//\tfunc SocketWriteBuffer() (bytes int, isDefault bool)\nvar SocketWriteBuffer = socket.WriteBuffer\n\n// SetSocketWriteBuffer sets the size of the operating system's\n// transmit buffer associated with the connection.\n// NOTE: if bytes<0, don't change the value.\n//\n//\tfunc SetSocketWriteBuffer(bytes int)\nvar SetSocketWriteBuffer = socket.SetWriteBuffer\n\n// SetSocketNoDelay controls whether the operating system should delay\n// packet transmission in hopes of sending fewer packets (Nagle's\n// algorithm).  The default is true (no delay), meaning that data is\n// sent as soon as possible after a Write.\n//\n//\tfunc SetSocketNoDelay(noDelay bool)\nvar SetSocketNoDelay = socket.SetNoDelay\n"
        },
        {
          "name": "context.go",
          "type": "blob",
          "size": 21.9140625,
          "content": "// Copyright 2015-2019 HenryLee. All Rights Reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage erpc\n\nimport (\n\t\"context\"\n\t\"reflect\"\n\t\"sync\"\n\t\"time\"\n\n\t\"github.com/andeya/erpc/v7/codec\"\n\t\"github.com/andeya/erpc/v7/socket\"\n\t\"github.com/andeya/erpc/v7/utils\"\n\t\"github.com/andeya/goutil\"\n)\n\ntype (\n\t// PreCtx context method set used before reading message header.\n\tPreCtx interface {\n\t\t// Peer returns the peer.\n\t\tPeer() Peer\n\t\t// Session returns the session.\n\t\tSession() CtxSession\n\t\t// IP returns the remote addr.\n\t\tIP() string\n\t\t// RealIP returns the current real remote addr.\n\t\tRealIP() string\n\t\t// Swap returns custom data swap of context.\n\t\tSwap() goutil.Map\n\t\t// Context carries a deadline, a cancelation signal, and other values across\n\t\t// API boundaries.\n\t\tContext() context.Context\n\t\t// Logger logger interface\n\t\tLogger\n\t}\n\t// WriteCtx context method set for writing message.\n\tWriteCtx interface {\n\t\tPreCtx\n\t\t// Output returns wrote message.\n\t\tOutput() Message\n\t\t// StatusOK returns the handle status is OK or not.\n\t\tStatusOK() bool\n\t\t// Status returns the handle status.\n\t\tStatus() *Status\n\t}\n\t// inputCtx common context method set.\n\tinputCtx interface {\n\t\tPreCtx\n\t\t// Seq returns the input message sequence.\n\t\tSeq() int32\n\t\t// PeekMeta peeks the header metadata for the input message.\n\t\tPeekMeta(key string) []byte\n\t\t// VisitMeta calls f for each existing metadata.\n\t\t//\n\t\t// f must not retain references to key and value after returning.\n\t\t// Make key and/or value copies if you need storing them after returning.\n\t\tVisitMeta(f func(key, value []byte))\n\t\t// CopyMeta returns the input message metadata copy.\n\t\tCopyMeta() *utils.Args\n\t\t// ServiceMethod returns the input message service method.\n\t\tServiceMethod() string\n\t\t// ResetServiceMethod resets the input message service method.\n\t\tResetServiceMethod(string)\n\t}\n\t// ReadCtx context method set for reading message.\n\tReadCtx interface {\n\t\tinputCtx\n\t\t// Input returns readed message.\n\t\tInput() Message\n\t\t// StatusOK returns the handle status is OK or not.\n\t\tStatusOK() bool\n\t\t// Status returns the handle status.\n\t\tStatus() *Status\n\t}\n\t// PushCtx context method set for handling the pushed message.\n\t// For example:\n\t//  type HomePush struct{ PushCtx }\n\tPushCtx interface {\n\t\tinputCtx\n\t\t// GetBodyCodec gets the body codec type of the input message.\n\t\tGetBodyCodec() byte\n\t}\n\t// CallCtx context method set for handling the called message.\n\t// For example:\n\t//  type HomeCall struct{ CallCtx }\n\tCallCtx interface {\n\t\tinputCtx\n\t\t// Input returns readed message.\n\t\tInput() Message\n\t\t// GetBodyCodec gets the body codec type of the input message.\n\t\tGetBodyCodec() byte\n\t\t// Output returns writed message.\n\t\tOutput() Message\n\t\t// ReplyBodyCodec initializes and returns the reply message body codec id.\n\t\tReplyBodyCodec() byte\n\t\t// SetBodyCodec sets the body codec for reply message.\n\t\tSetBodyCodec(byte)\n\t\t// AddMeta adds the header metadata 'key=value' for reply message.\n\t\t// Multiple values for the same key may be added.\n\t\tAddMeta(key, value string)\n\t\t// SetMeta sets the header metadata 'key=value' for reply message.\n\t\tSetMeta(key, value string)\n\t\t// AddXferPipe appends transfer filter pipe of reply message.\n\t\tAddXferPipe(filterID ...byte)\n\t}\n\t// UnknownPushCtx context method set for handling the unknown pushed message.\n\tUnknownPushCtx interface {\n\t\tinputCtx\n\t\t// GetBodyCodec gets the body codec type of the input message.\n\t\tGetBodyCodec() byte\n\t\t// InputBodyBytes if the input body binder is []byte type, returns it, else returns nil.\n\t\tInputBodyBytes() []byte\n\t\t// Bind when the raw body binder is []byte type, now binds the input body to v.\n\t\tBind(v interface{}) (bodyCodec byte, err error)\n\t}\n\t// UnknownCallCtx context method set for handling the unknown called message.\n\tUnknownCallCtx interface {\n\t\tinputCtx\n\t\t// GetBodyCodec gets the body codec type of the input message.\n\t\tGetBodyCodec() byte\n\t\t// InputBodyBytes if the input body binder is []byte type, returns it, else returns nil.\n\t\tInputBodyBytes() []byte\n\t\t// Bind when the raw body binder is []byte type, now binds the input body to v.\n\t\tBind(v interface{}) (bodyCodec byte, err error)\n\t\t// SetBodyCodec sets the body codec for reply message.\n\t\tSetBodyCodec(byte)\n\t\t// AddMeta adds the header metadata 'key=value' for reply message.\n\t\t// Multiple values for the same key may be added.\n\t\tAddMeta(key, value string)\n\t\t// SetMeta sets the header metadata 'key=value' for reply message.\n\t\tSetMeta(key, value string)\n\t\t// AddXferPipe appends transfer filter pipe of reply message.\n\t\tAddXferPipe(filterID ...byte)\n\t}\n)\n\nvar (\n\t_ Logger         = new(handlerCtx)\n\t_ PreCtx         = new(handlerCtx)\n\t_ inputCtx       = new(handlerCtx)\n\t_ WriteCtx       = new(handlerCtx)\n\t_ ReadCtx        = new(handlerCtx)\n\t_ PushCtx        = new(handlerCtx)\n\t_ CallCtx        = new(handlerCtx)\n\t_ UnknownPushCtx = new(handlerCtx)\n\t_ UnknownCallCtx = new(handlerCtx)\n)\n\n// handlerCtx the underlying common instance of CallCtx and PushCtx.\ntype handlerCtx struct {\n\tsess            *session\n\tinput           Message\n\toutput          Message\n\thandler         *Handler\n\targ             reflect.Value\n\tcallCmd         *callCmd\n\tswap            goutil.Map\n\tstart           int64\n\tcost            time.Duration\n\tpluginContainer *PluginContainer\n\tstat            *Status\n\tcontext         context.Context\n}\n\nvar (\n\temptyValue  = reflect.Value{}\n\temptyMethod = reflect.Method{}\n)\n\n// newReadHandleCtx creates a handlerCtx for one request/response or push.\nfunc newReadHandleCtx() *handlerCtx {\n\tc := new(handlerCtx)\n\tc.input = socket.NewMessage()\n\tc.input.SetNewBody(c.binding)\n\tc.output = socket.NewMessage()\n\treturn c\n}\n\nfunc (c *handlerCtx) reInit(s *session) {\n\tc.sess = s\n\tcount := s.socket.SwapLen()\n\tc.swap = goutil.RwMap(count)\n\tif count > 0 {\n\t\ts.socket.Swap().Range(func(key, value interface{}) bool {\n\t\t\tc.swap.Store(key, value)\n\t\t\treturn true\n\t\t})\n\t}\n}\n\nfunc (c *handlerCtx) clean() {\n\tc.sess = nil\n\tc.handler = nil\n\tc.arg = emptyValue\n\tc.callCmd = nil\n\tc.swap = nil\n\tc.cost = 0\n\tc.pluginContainer = nil\n\tc.stat = nil\n\tc.context = nil\n\tc.input.Reset(socket.WithNewBody(c.binding))\n\tc.output.Reset()\n}\n\n// Peer returns the peer.\nfunc (c *handlerCtx) Peer() Peer {\n\treturn c.sess.peer\n}\n\n// Session returns the session.\nfunc (c *handlerCtx) Session() CtxSession {\n\treturn c.sess\n}\n\n// Input returns readed message.\nfunc (c *handlerCtx) Input() Message {\n\treturn c.input\n}\n\n// Output returns writed message.\nfunc (c *handlerCtx) Output() Message {\n\treturn c.output\n}\n\n// Swap returns custom data swap of context.\nfunc (c *handlerCtx) Swap() goutil.Map {\n\treturn c.swap\n}\n\n// Seq returns the input message sequence.\nfunc (c *handlerCtx) Seq() int32 {\n\treturn c.input.Seq()\n}\n\n// ServiceMethod returns the input message service method.\nfunc (c *handlerCtx) ServiceMethod() string {\n\treturn c.input.ServiceMethod()\n}\n\n// ResetServiceMethod resets the input message service method.\nfunc (c *handlerCtx) ResetServiceMethod(serviceMethod string) {\n\tc.input.SetServiceMethod(serviceMethod)\n}\n\n// PeekMeta peeks the header metadata for the input message.\nfunc (c *handlerCtx) PeekMeta(key string) []byte {\n\treturn c.input.Meta().Peek(key)\n}\n\n// VisitMeta calls f for each existing metadata.\n//\n// f must not retain references to key and value after returning.\n// Make key and/or value copies if you need storing them after returning.\nfunc (c *handlerCtx) VisitMeta(f func(key, value []byte)) {\n\tc.input.Meta().VisitAll(f)\n}\n\n// CopyMeta returns the input message metadata copy.\nfunc (c *handlerCtx) CopyMeta() *utils.Args {\n\tdst := utils.AcquireArgs()\n\tc.input.Meta().CopyTo(dst)\n\treturn dst\n}\n\n// AddMeta adds the header metadata 'key=value' for reply message.\n// Multiple values for the same key may be added.\nfunc (c *handlerCtx) AddMeta(key, value string) {\n\tc.output.Meta().Add(key, value)\n}\n\n// SetMeta sets the header metadata 'key=value' for reply message.\nfunc (c *handlerCtx) SetMeta(key, value string) {\n\tc.output.Meta().Set(key, value)\n}\n\n// GetBodyCodec gets the body codec type of the input message.\nfunc (c *handlerCtx) GetBodyCodec() byte {\n\treturn c.input.BodyCodec()\n}\n\n// SetBodyCodec sets the body codec for reply message.\nfunc (c *handlerCtx) SetBodyCodec(bodyCodec byte) {\n\tc.output.SetBodyCodec(bodyCodec)\n}\n\n// AddXferPipe appends transfer filter pipe of reply message.\nfunc (c *handlerCtx) AddXferPipe(filterID ...byte) {\n\tc.output.XferPipe().Append(filterID...)\n}\n\n// IP returns the remote addr.\nfunc (c *handlerCtx) IP() string {\n\treturn c.sess.RemoteAddr().String()\n}\n\n// RealIP returns the the current real remote addr.\nfunc (c *handlerCtx) RealIP() string {\n\trealIP := c.PeekMeta(MetaRealIP)\n\tif len(realIP) > 0 {\n\t\treturn string(realIP)\n\t}\n\treturn c.sess.RemoteAddr().String()\n}\n\n// Context carries a deadline, a cancelation signal, and other values across\n// API boundaries.\nfunc (c *handlerCtx) Context() context.Context {\n\tif c.context == nil {\n\t\treturn c.input.Context()\n\t}\n\treturn c.context\n}\n\n// setContext sets the context for timeout.\nfunc (c *handlerCtx) setContext(ctx context.Context) {\n\tc.context = ctx\n}\n\n// Be executed synchronously when reading message\nfunc (c *handlerCtx) binding(header Header) (body interface{}) {\n\tc.start = c.sess.timeNow()\n\tc.pluginContainer = c.sess.peer.pluginContainer\n\tswitch header.Mtype() {\n\tcase TypeReply:\n\t\treturn c.bindReply(header)\n\tcase TypePush:\n\t\treturn c.bindPush(header)\n\tcase TypeCall:\n\t\treturn c.bindCall(header)\n\tdefault:\n\t\tc.stat = statCodeMtypeNotAllowed\n\t\treturn nil\n\t}\n}\n\nconst logFormatDisconnected = \"disconnected due to unsupported message type: %d %s %s %q RECV(%s)\"\n\n// Be executed asynchronously after readed message\nfunc (c *handlerCtx) handle() {\n\tif c.stat.Code() == CodeMtypeNotAllowed {\n\t\tgoto E\n\t}\n\tswitch c.input.Mtype() {\n\tcase TypeReply:\n\t\t// handles call reply\n\t\tc.handleReply()\n\t\treturn\n\n\tcase TypePush:\n\t\t//  handles push\n\t\tc.handlePush()\n\t\treturn\n\n\tcase TypeCall:\n\t\t// handles and replies call\n\t\tc.handleCall()\n\t\treturn\n\n\tdefault:\n\t}\nE:\n\t// if unsupported, disconnected.\n\tc.output.SetStatus(statCodeMtypeNotAllowed)\n\tErrorf(logFormatDisconnected,\n\t\tc.input.Mtype(), c.IP(), c.input.ServiceMethod(), c.input.Seq(),\n\t\tmessageLogBytes(c.input, c.sess.peer.printDetail))\n\tgo c.sess.Close()\n}\n\nfunc (c *handlerCtx) bindPush(header Header) interface{} {\n\tc.stat = c.pluginContainer.postReadPushHeader(c)\n\tif !c.stat.OK() {\n\t\treturn nil\n\t}\n\n\tif len(header.ServiceMethod()) == 0 {\n\t\tc.stat = statBadMessage.Copy(\"invalid service method for message\")\n\t\treturn nil\n\t}\n\n\tvar ok bool\n\tc.handler, ok = c.sess.getPushHandler(header.ServiceMethod())\n\tif !ok {\n\t\tc.stat = statNotFound\n\t\treturn nil\n\t}\n\n\t// reset plugin container\n\tc.pluginContainer = c.handler.pluginContainer\n\n\tc.arg = c.handler.NewArgValue()\n\tc.input.SetBody(c.arg.Interface())\n\tc.stat = c.pluginContainer.preReadPushBody(c)\n\tif !c.stat.OK() {\n\t\treturn nil\n\t}\n\n\treturn c.input.Body()\n}\n\nfunc (c *handlerCtx) recordCost() {\n\tc.cost = time.Duration(c.sess.timeNow() - c.start)\n}\n\n// handlePush handles push.\nfunc (c *handlerCtx) handlePush() {\n\tif age := c.sess.ContextAge(); age > 0 {\n\t\tctxTimout, _ := context.WithTimeout(context.Background(), age)\n\t\tc.setContext(ctxTimout)\n\t}\n\tdefer func() {\n\t\tif p := recover(); p != nil {\n\t\t\tErrorf(\"panic:%v\\n%s\", p, goutil.PanicTrace(2))\n\t\t}\n\t\tc.recordCost()\n\t\tif enablePrintRunLog() {\n\t\t\tc.sess.printRunLog(c.RealIP(), c.cost, c.input, nil, typePushHandle)\n\t\t}\n\t}()\n\tif c.stat.OK() && c.handler != nil {\n\t\tif c.pluginContainer.postReadPushBody(c) == nil {\n\t\t\tif c.handler.isUnknown {\n\t\t\t\tc.handler.unknownHandleFunc(c)\n\t\t\t} else {\n\t\t\t\tc.handler.handleFunc(c, c.arg)\n\t\t\t}\n\t\t}\n\t}\n\tif !c.stat.OK() {\n\t\tWarnf(\"%s\", c.stat.String())\n\t}\n}\n\nfunc (c *handlerCtx) bindCall(header Header) interface{} {\n\tc.stat = c.pluginContainer.postReadCallHeader(c)\n\tif !c.stat.OK() {\n\t\treturn nil\n\t}\n\n\tif len(header.ServiceMethod()) == 0 {\n\t\tc.stat = statBadMessage.Copy(\"invalid service method for message\")\n\t\treturn nil\n\t}\n\n\tvar ok bool\n\tc.handler, ok = c.sess.getCallHandler(header.ServiceMethod())\n\tif !ok {\n\t\tc.stat = statNotFound\n\t\treturn nil\n\t}\n\n\t// reset plugin container\n\tc.pluginContainer = c.handler.pluginContainer\n\n\tif c.handler.isUnknown {\n\t\tc.input.SetBody(new([]byte))\n\t} else {\n\t\tc.arg = c.handler.NewArgValue()\n\t\tc.input.SetBody(c.arg.Interface())\n\t}\n\n\tc.stat = c.pluginContainer.preReadCallBody(c)\n\tif !c.stat.OK() {\n\t\treturn nil\n\t}\n\n\treturn c.input.Body()\n}\n\n// handleCall handles and replies call.\nfunc (c *handlerCtx) handleCall() {\n\tvar writed bool\n\tdefer func() {\n\t\tif p := recover(); p != nil {\n\t\t\tErrorf(\"panic:%v\\n%s\", p, goutil.PanicTrace(2))\n\t\t\tif !writed {\n\t\t\t\tif c.stat.OK() {\n\t\t\t\t\tc.stat = statInternalServerError.Copy(p)\n\t\t\t\t}\n\t\t\t\tc.writeReply(c.stat)\n\t\t\t}\n\t\t}\n\t\tc.recordCost()\n\t\tif enablePrintRunLog() {\n\t\t\tc.sess.printRunLog(c.RealIP(), c.cost, c.input, c.output, typeCallHandle)\n\t\t}\n\t}()\n\n\tc.output.SetMtype(TypeReply)\n\tc.output.SetSeq(c.input.Seq())\n\tc.output.SetServiceMethod(c.input.ServiceMethod())\n\tc.output.XferPipe().AppendFrom(c.input.XferPipe())\n\n\tif age := c.sess.ContextAge(); age > 0 {\n\t\tctxTimout, _ := context.WithTimeout(c.input.Context(), age)\n\t\tc.setContext(ctxTimout)\n\t\tsocket.WithContext(ctxTimout)(c.output)\n\t}\n\n\tif c.stat.OK() {\n\t\tc.stat = c.output.Status()\n\t}\n\n\t// handle call\n\tif c.stat.OK() {\n\t\tc.stat = c.pluginContainer.postReadCallBody(c)\n\t\tif c.stat.OK() {\n\t\t\tif c.handler.isUnknown {\n\t\t\t\tc.handler.unknownHandleFunc(c)\n\t\t\t} else {\n\t\t\t\tc.handler.handleFunc(c, c.arg)\n\t\t\t}\n\t\t}\n\t}\n\n\t// reply call\n\tc.setReplyBodyCodec(!c.stat.OK())\n\tc.pluginContainer.preWriteReply(c)\n\tstat := c.writeReply(c.stat)\n\tif !stat.OK() {\n\t\tif c.stat.OK() {\n\t\t\tc.stat = stat\n\t\t}\n\t\tif stat.Code() != CodeConnClosed {\n\t\t\tc.writeReply(statInternalServerError.Copy(stat.Cause()))\n\t\t}\n\t\treturn\n\t}\n\twrited = true\n\tc.pluginContainer.postWriteReply(c)\n}\n\n// ReplyBodyCodec initializes and returns the reply message body codec id.\nfunc (c *handlerCtx) ReplyBodyCodec() byte {\n\tid := c.output.BodyCodec()\n\tif id != codec.NilCodecID {\n\t\treturn id\n\t}\n\tid, ok := GetAcceptBodyCodec(c.input.Meta())\n\tif ok {\n\t\tif _, err := codec.Get(id); err == nil {\n\t\t\tc.output.SetBodyCodec(id)\n\t\t\treturn id\n\t\t}\n\t}\n\tid = c.input.BodyCodec()\n\tc.output.SetBodyCodec(id)\n\treturn id\n}\n\nfunc (c *handlerCtx) setReplyBodyCodec(hasError bool) {\n\tif hasError {\n\t\treturn\n\t}\n\tc.ReplyBodyCodec()\n}\n\nfunc (c *handlerCtx) writeReply(stat *Status) *Status {\n\tif !stat.OK() {\n\t\tc.output.SetStatus(stat)\n\t\tc.output.SetBody(nil)\n\t\tc.output.SetBodyCodec(codec.NilCodecID)\n\t}\n\tserviceMethod := c.output.ServiceMethod()\n\tc.output.SetServiceMethod(\"\")\n\t_, stat = c.sess.write(c.output)\n\tc.output.SetServiceMethod(serviceMethod)\n\treturn stat\n}\n\nfunc (c *handlerCtx) bindReply(header Header) interface{} {\n\t_callCmd, ok := c.sess.callCmdMap.Load(header.Seq())\n\tif !ok {\n\t\tWarnf(\"not found call cmd: %v\", c.input)\n\t\treturn nil\n\t}\n\tc.callCmd = _callCmd.(*callCmd)\n\n\t// unlock: handleReply\n\tc.callCmd.mu.Lock()\n\tc.input.SetServiceMethod(c.callCmd.output.ServiceMethod())\n\tc.swap = c.callCmd.swap\n\tc.callCmd.inputBodyCodec = c.GetBodyCodec()\n\t// if c.callCmd.inputMeta!=nil, means the callCmd is replyed.\n\tc.callCmd.inputMeta = utils.AcquireArgs()\n\tc.input.Meta().CopyTo(c.callCmd.inputMeta)\n\tc.setContext(c.callCmd.output.Context())\n\tc.input.SetBody(c.callCmd.result)\n\n\tstat := c.pluginContainer.postReadReplyHeader(c)\n\tif !stat.OK() {\n\t\tc.callCmd.stat = stat\n\t\treturn nil\n\t}\n\tstat = c.pluginContainer.preReadReplyBody(c)\n\tif !stat.OK() {\n\t\tc.callCmd.stat = stat\n\t\treturn nil\n\t}\n\treturn c.input.Body()\n}\n\n// handleReply handles call reply.\nfunc (c *handlerCtx) handleReply() {\n\tif c.callCmd == nil {\n\t\treturn\n\t}\n\tdefer func() {\n\t\tif p := recover(); p != nil {\n\t\t\tErrorf(\"panic:%v\\n%s\", p, goutil.PanicTrace(2))\n\t\t}\n\t\tc.callCmd.result = c.input.Body()\n\t\tc.stat = c.callCmd.stat\n\t\tc.callCmd.done()\n\t\tc.callCmd.cost = time.Duration(c.sess.timeNow() - c.callCmd.start)\n\t\tif enablePrintRunLog() {\n\t\t\tc.sess.printRunLog(c.RealIP(), c.callCmd.cost, c.input, c.callCmd.output, typeCallLaunch)\n\t\t}\n\t\t// lock: bindReply\n\t\tc.callCmd.mu.Unlock()\n\t}()\n\tif c.callCmd.stat.OK() {\n\t\tstat := c.input.Status()\n\t\tif stat.OK() {\n\t\t\tstat = c.pluginContainer.postReadReplyBody(c)\n\t\t}\n\t\tc.callCmd.stat = stat\n\t}\n}\n\n// StatusOK returns the handle status is OK or not.\nfunc (c *handlerCtx) StatusOK() bool {\n\treturn c.stat.OK()\n}\n\n// Status returns the handle status.\nfunc (c *handlerCtx) Status() *Status {\n\treturn c.stat\n}\n\n// InputBodyBytes if the input body binder is []byte type, returns it, else returns nil.\nfunc (c *handlerCtx) InputBodyBytes() []byte {\n\tb, ok := c.input.Body().(*[]byte)\n\tif !ok {\n\t\treturn nil\n\t}\n\treturn *b\n}\n\n// Bind when the raw body binder is []byte type, now binds the input body to v.\nfunc (c *handlerCtx) Bind(v interface{}) (byte, error) {\n\tb := c.InputBodyBytes()\n\tif b == nil {\n\t\treturn codec.NilCodecID, nil\n\t}\n\tc.input.SetBody(v)\n\terr := c.input.UnmarshalBody(b)\n\treturn c.input.BodyCodec(), err\n}\n\ntype (\n\t// CallCmd the command of the calling operation's response.\n\tCallCmd interface {\n\t\t// TracePeer trace back the peer.\n\t\tTracePeer() (peer Peer, found bool)\n\t\t// TraceSession trace back the session.\n\t\tTraceSession() (sess Session, found bool)\n\t\t// Context carries a deadline, a cancelation signal, and other values across\n\t\t// API boundaries.\n\t\tContext() context.Context\n\t\t// Output returns writed message.\n\t\tOutput() Message\n\t\t// StatusOK returns the call status is OK or not.\n\t\tStatusOK() bool\n\t\t// Status returns the call status.\n\t\tStatus() *Status\n\t\t// Done returns the chan that indicates whether it has been completed.\n\t\tDone() <-chan struct{}\n\t\t// Reply returns the call reply.\n\t\t// NOTE:\n\t\t//  Inside, <-Done() is automatically called and blocked,\n\t\t//  until the call is completed!\n\t\tReply() (interface{}, *Status)\n\t\t// InputBodyCodec gets the body codec type of the input message.\n\t\t// NOTE:\n\t\t//  Inside, <-Done() is automatically called and blocked,\n\t\t//  until the call is completed!\n\t\tInputBodyCodec() byte\n\t\t// InputMeta returns the header metadata of input message.\n\t\t// NOTE:\n\t\t//  Inside, <-Done() is automatically called and blocked,\n\t\t//  until the call is completed!\n\t\tInputMeta() *utils.Args\n\t\t// CostTime returns the called cost time.\n\t\t// If PeerConfig.CountTime=false, always returns 0.\n\t\t// NOTE:\n\t\t//  Inside, <-Done() is automatically called and blocked,\n\t\t//  until the call is completed!\n\t\tCostTime() time.Duration\n\t}\n\tcallCmd struct {\n\t\tstart          int64\n\t\tcost           time.Duration\n\t\tsess           *session\n\t\toutput         Message\n\t\tresult         interface{}\n\t\tstat           *Status\n\t\tinputMeta      *utils.Args\n\t\tswap           goutil.Map\n\t\tmu             sync.Mutex\n\t\tcallCmdChan    chan<- CallCmd // Send itself to the public channel when call is complete.\n\t\tdoneChan       chan struct{}  // Strobes when call is complete.\n\t\tinputBodyCodec byte\n\t}\n)\n\nvar _ WriteCtx = new(callCmd)\n\n// TracePeer trace back the peer.\nfunc (c *callCmd) TracePeer() (Peer, bool) {\n\treturn c.Peer(), true\n}\n\n// Peer returns the peer.\nfunc (c *callCmd) Peer() Peer {\n\treturn c.sess.peer\n}\n\n// TraceSession trace back the session.\nfunc (c *callCmd) TraceSession() (Session, bool) {\n\treturn c.sess, true\n}\n\n// Session returns the session.\nfunc (c *callCmd) Session() CtxSession {\n\treturn c.sess\n}\n\n// IP returns the remote addr.\nfunc (c *callCmd) IP() string {\n\treturn c.sess.RemoteAddr().String()\n}\n\n// RealIP returns the the current real remote addr.\nfunc (c *callCmd) RealIP() string {\n\trealIP := c.inputMeta.Peek(MetaRealIP)\n\tif len(realIP) > 0 {\n\t\treturn string(realIP)\n\t}\n\treturn c.sess.RemoteAddr().String()\n}\n\n// Swap returns custom data swap of context.\nfunc (c *callCmd) Swap() goutil.Map {\n\treturn c.swap\n}\n\n// SwapLen returns the amount of recorded custom data of context.\nfunc (c *callCmd) SwapLen() int {\n\treturn c.swap.Len()\n}\n\n// Output returns writed message.\nfunc (c *callCmd) Output() Message {\n\treturn c.output\n}\n\n// Context carries a deadline, a cancelation signal, and other values across\n// API boundaries.\nfunc (c *callCmd) Context() context.Context {\n\treturn c.output.Context()\n}\n\n// StatusOK returns the call status is OK or not.\nfunc (c *callCmd) StatusOK() bool {\n\treturn c.stat.OK()\n}\n\n// Status returns the call status.\nfunc (c *callCmd) Status() *Status {\n\treturn c.stat\n}\n\n// Done returns the chan that indicates whether it has been completed.\nfunc (c *callCmd) Done() <-chan struct{} {\n\treturn c.doneChan\n}\n\n// Reply returns the call reply.\n// NOTE:\n//\n//\tInside, <-Done() is automatically called and blocked,\n//\tuntil the call is completed!\nfunc (c *callCmd) Reply() (interface{}, *Status) {\n\t<-c.Done()\n\treturn c.result, c.stat\n}\n\n// InputBodyCodec gets the body codec type of the input message.\n// NOTE:\n//\n//\tInside, <-Done() is automatically called and blocked,\n//\tuntil the call is completed!\nfunc (c *callCmd) InputBodyCodec() byte {\n\t<-c.Done()\n\treturn c.inputBodyCodec\n}\n\n// InputMeta returns the header metadata of input message.\n// NOTE:\n//\n//\tInside, <-Done() is automatically called and blocked,\n//\tuntil the call is completed!\nfunc (c *callCmd) InputMeta() *utils.Args {\n\t<-c.Done()\n\treturn c.inputMeta\n}\n\n// CostTime returns the called cost time.\n// If PeerConfig.CountTime=false, always returns 0.\n// NOTE:\n//\n//\tInside, <-Done() is automatically called and blocked,\n//\tuntil the call is completed!\nfunc (c *callCmd) CostTime() time.Duration {\n\t<-c.Done()\n\treturn c.cost\n}\n\nfunc (c *callCmd) done() {\n\tc.sess.callCmdMap.Delete(c.output.Seq())\n\tc.callCmdChan <- c\n\tclose(c.doneChan)\n\t// free count call-launch\n\tc.sess.graceCallCmdWaitGroup.Done()\n}\n\nfunc (c *callCmd) cancel(reason string) {\n\tc.sess.callCmdMap.Delete(c.output.Seq())\n\tif reason != \"\" {\n\t\tc.stat = statConnClosed.Copy(reason)\n\t} else {\n\t\tc.stat = statConnClosed\n\t}\n\tc.callCmdChan <- c\n\tclose(c.doneChan)\n\t// free count call-launch\n\tc.sess.graceCallCmdWaitGroup.Done()\n}\n\n// if callCmd.inputMeta!=nil, means the callCmd is replyed.\nfunc (c *callCmd) hasReply() bool {\n\treturn c.inputMeta != nil\n}\n"
        },
        {
          "name": "dialer.go",
          "type": "blob",
          "size": 4.1640625,
          "content": "// Copyright 2015-2019 HenryLee. All Rights Reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage erpc\n\nimport (\n\t\"context\"\n\t\"crypto/tls\"\n\t\"net\"\n\t\"time\"\n\n\t\"github.com/andeya/erpc/v7/kcp\"\n\t\"github.com/andeya/erpc/v7/quic\"\n)\n\n// Dialer dial-up connection\ntype Dialer struct {\n\tnetwork        string\n\tlocalAddr      net.Addr\n\ttlsConfig      *tls.Config\n\tdialTimeout    time.Duration\n\tredialInterval time.Duration\n\tredialTimes    int32\n}\n\n// NewDialer creates a dialer.\nfunc NewDialer(localAddr net.Addr, tlsConfig *tls.Config,\n\tdialTimeout, redialInterval time.Duration, redialTimes int32,\n) *Dialer {\n\treturn &Dialer{\n\t\tnetwork:        localAddr.Network(),\n\t\tlocalAddr:      localAddr,\n\t\ttlsConfig:      tlsConfig,\n\t\tdialTimeout:    dialTimeout,\n\t\tredialInterval: redialInterval,\n\t\tredialTimes:    redialTimes,\n\t}\n}\n\n// Network returns the network.\nfunc (d *Dialer) Network() string {\n\treturn d.network\n}\n\n// LocalAddr returns the local address.\nfunc (d *Dialer) LocalAddr() net.Addr {\n\treturn d.localAddr\n}\n\n// TLSConfig returns the TLS config.\nfunc (d *Dialer) TLSConfig() *tls.Config {\n\treturn d.tlsConfig\n}\n\n// DialTimeout returns the dial timeout.\nfunc (d *Dialer) DialTimeout() time.Duration {\n\treturn d.dialTimeout\n}\n\n// RedialInterval returns the redial interval.\nfunc (d *Dialer) RedialInterval() time.Duration {\n\treturn d.redialInterval\n}\n\n// RedialTimes returns the redial times.\nfunc (d *Dialer) RedialTimes() int32 {\n\treturn d.redialTimes\n}\n\n// Dial dials the connection, and try again if it fails.\nfunc (d *Dialer) Dial(addr string) (net.Conn, error) {\n\treturn d.dialWithRetry(addr, \"\", nil)\n}\n\n// dialWithRetry dials the connection, and try again if it fails.\n// NOTE:\n//\n//\tsessID is not empty only when the disconnection is redialing\nfunc (d *Dialer) dialWithRetry(addr, sessID string, fn func(conn net.Conn) error) (net.Conn, error) {\n\tconn, err := d.dialOne(addr)\n\tif err == nil {\n\t\tif fn == nil {\n\t\t\treturn conn, nil\n\t\t}\n\t\terr = fn(conn)\n\t\tif err == nil {\n\t\t\treturn conn, nil\n\t\t}\n\t}\n\tredialTimes := d.newRedialCounter()\n\tfor redialTimes.Next() {\n\t\ttime.Sleep(d.redialInterval)\n\t\tif sessID == \"\" {\n\t\t\tDebugf(\"trying to redial... (network:%s, addr:%s)\", d.network, addr)\n\t\t} else {\n\t\t\tDebugf(\"trying to redial... (network:%s, addr:%s, id:%s)\", d.network, addr, sessID)\n\t\t}\n\t\tconn, err = d.dialOne(addr)\n\t\tif err == nil {\n\t\t\tif fn == nil {\n\t\t\t\treturn conn, nil\n\t\t\t}\n\t\t\terr = fn(conn)\n\t\t\tif err == nil {\n\t\t\t\treturn conn, nil\n\t\t\t}\n\t\t}\n\t}\n\treturn nil, err\n}\n\nconst (\n\tdataShards   = 10\n\tparityShards = 3\n)\n\n// dialOne dials the connection once.\nfunc (d *Dialer) dialOne(addr string) (net.Conn, error) {\n\tif network := asQUIC(d.network); network != \"\" {\n\t\tctx := context.Background()\n\t\tif d.dialTimeout > 0 {\n\t\t\tctx, _ = context.WithTimeout(ctx, d.dialTimeout)\n\t\t}\n\t\tvar tlsConf = d.tlsConfig\n\t\tif tlsConf == nil {\n\t\t\ttlsConf = GenerateTLSConfigForClient()\n\t\t}\n\t\treturn quic.DialAddrContext(ctx, network, d.localAddr.(*FakeAddr).udpAddr, addr, tlsConf, nil)\n\t}\n\n\tif network := asKCP(d.network); network != \"\" {\n\t\treturn kcp.DialAddrContext(network, d.localAddr.(*FakeAddr).udpAddr, addr, d.tlsConfig, dataShards, parityShards)\n\t}\n\tdialer := &net.Dialer{\n\t\tLocalAddr: d.localAddr,\n\t\tTimeout:   d.dialTimeout,\n\t}\n\tif d.tlsConfig != nil {\n\t\treturn tls.DialWithDialer(dialer, d.network, addr, d.tlsConfig)\n\t}\n\treturn dialer.Dial(d.network, addr)\n}\n\n// newRedialCounter creates a new redial counter.\nfunc (d *Dialer) newRedialCounter() *redialCounter {\n\tr := redialCounter(d.redialTimes)\n\treturn &r\n}\n\n// redialCounter redial counter\ntype redialCounter int32\n\n// Next returns whether there are still more redial times.\nfunc (r *redialCounter) Next() bool {\n\tt := *r\n\tif t == 0 {\n\t\treturn false\n\t}\n\tif t > 0 {\n\t\t*r--\n\t}\n\treturn true\n}\n"
        },
        {
          "name": "doc.go",
          "type": "blob",
          "size": 0.69140625,
          "content": "// Package erpc is an efficient, extensible and easy-to-use RPC framework.\n//\n// Copyright 2015-2019 HenryLee. All Rights Reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//\thttp://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\npackage documentation\n"
        },
        {
          "name": "doc",
          "type": "tree",
          "content": null
        },
        {
          "name": "docker-compose.yml",
          "type": "blob",
          "size": 0.193359375,
          "content": "version: '3'\n\nservices:\n  dev:\n    build: .\n    volumes:\n      - ./:/go/src/github.com/andeya/erpc\n    working_dir: /go/src/github.com/andeya/erpc\n    command: bash -c 'make tools ; make watch-test'"
        },
        {
          "name": "erpc_test.go",
          "type": "blob",
          "size": 1.0234375,
          "content": "package erpc_test\n\nimport (\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/andeya/erpc/v7\"\n\t\"github.com/andeya/goutil\"\n)\n\nfunc panic_call(erpc.CallCtx, *interface{}) (interface{}, *erpc.Status) {\n\tpanic(\"panic_call\")\n}\n\nfunc panic_push(erpc.PushCtx, *interface{}) *erpc.Status {\n\tpanic(\"panic_push\")\n}\n\n//go:generate go test -v -c -o \"${GOPACKAGE}\" $GOFILE\n\nfunc TestPanic(t *testing.T) {\n\tif goutil.IsGoTest() {\n\t\tt.Log(\"skip test in go test\")\n\t\treturn\n\t}\n\n\tsrv := erpc.NewPeer(erpc.PeerConfig{\n\t\tCountTime:  true,\n\t\tListenPort: 9090,\n\t})\n\tsrv.RouteCallFunc(panic_call)\n\tsrv.RoutePushFunc(panic_push)\n\tgo srv.ListenAndServe()\n\n\ttime.Sleep(2 * time.Second)\n\n\tcli := erpc.NewPeer(erpc.PeerConfig{})\n\tdefer cli.Close()\n\tsess, stat := cli.Dial(\":9090\")\n\tif !stat.OK() {\n\t\tt.Fatal(stat)\n\t}\n\tstat = sess.Call(\"/panic/call\", nil, nil).Status()\n\tif stat.OK() {\n\t\tt.Fatalf(\"/panic/call: expect error!\")\n\t}\n\tt.Logf(\"/panic/call error: %v\", stat)\n\tstat = sess.Push(\"/panic/push\", nil)\n\tif !stat.OK() {\n\t\tt.Fatalf(\"/panic/push: expect ok!\")\n\t}\n\tt.Logf(\"/panic/push: ok\")\n}\n"
        },
        {
          "name": "examples",
          "type": "tree",
          "content": null
        },
        {
          "name": "go.mod",
          "type": "blob",
          "size": 1.6982421875,
          "content": "module github.com/andeya/erpc/v7\n\ngo 1.18\n\nrequire (\n\tgithub.com/andeya/cfgo v0.0.0-20220626152948-7980c5d761c8\n\tgithub.com/andeya/goutil v1.0.0\n\tgithub.com/apache/thrift v0.17.0\n\tgithub.com/gogo/protobuf v1.3.2\n\tgithub.com/golang/protobuf v1.5.3\n\tgithub.com/montanaflynn/stats v0.5.0\n\tgithub.com/quic-go/quic-go v0.38.1\n\tgithub.com/stretchr/testify v1.7.5\n\tgithub.com/tidwall/evio v1.0.8\n\tgithub.com/tidwall/gjson v1.14.1\n\tgithub.com/xtaci/kcp-go/v5 v5.6.1\n\tgolang.org/x/sys v0.8.0\n)\n\nrequire (\n\tgithub.com/davecgh/go-spew v1.1.1 // indirect\n\tgithub.com/go-task/slim-sprig v0.0.0-20230315185526-52ccab3ef572 // indirect\n\tgithub.com/golang/mock v1.6.0 // indirect\n\tgithub.com/google/pprof v0.0.0-20221203041831-ce31453925ec // indirect\n\tgithub.com/henrylee2cn/ameda v1.5.1 // indirect\n\tgithub.com/kavu/go_reuseport v1.5.0 // indirect\n\tgithub.com/klauspost/cpuid/v2 v2.2.2 // indirect\n\tgithub.com/klauspost/reedsolomon v1.11.3 // indirect\n\tgithub.com/kr/pretty v0.3.1 // indirect\n\tgithub.com/onsi/ginkgo/v2 v2.9.5 // indirect\n\tgithub.com/pkg/errors v0.9.1 // indirect\n\tgithub.com/pmezard/go-difflib v1.0.0 // indirect\n\tgithub.com/quic-go/qtls-go1-20 v0.3.3 // indirect\n\tgithub.com/templexxx/cpu v0.0.9 // indirect\n\tgithub.com/templexxx/xorsimd v0.4.1 // indirect\n\tgithub.com/tidwall/match v1.1.1 // indirect\n\tgithub.com/tidwall/pretty v1.2.0 // indirect\n\tgithub.com/tjfoc/gmsm v1.4.1 // indirect\n\tgolang.org/x/crypto v0.4.0 // indirect\n\tgolang.org/x/exp v0.0.0-20221205204356-47842c84f3db // indirect\n\tgolang.org/x/mod v0.10.0 // indirect\n\tgolang.org/x/net v0.10.0 // indirect\n\tgolang.org/x/tools v0.9.1 // indirect\n\tgoogle.golang.org/protobuf v1.28.0 // indirect\n\tgopkg.in/yaml.v2 v2.4.0 // indirect\n\tgopkg.in/yaml.v3 v3.0.1 // indirect\n)\n"
        },
        {
          "name": "go.sum",
          "type": "blob",
          "size": 20.025390625,
          "content": "cloud.google.com/go v0.26.0/go.mod h1:aQUYkXzVsufM+DwF1aE+0xfcU+56JwCaLick0ClmMTw=\ngithub.com/BurntSushi/toml v0.3.1/go.mod h1:xHWCNGjB5oqiDr8zfno3MHue2Ht5sIBksp03qcyfWMU=\ngithub.com/andeya/cfgo v0.0.0-20220626152948-7980c5d761c8 h1:2+qycdjXX/+EOQ3Rxkt39P5Vy5aQ0GeidW/6L4YWxtA=\ngithub.com/andeya/cfgo v0.0.0-20220626152948-7980c5d761c8/go.mod h1:tVXGyZHyEkmXSzfmP5P3r4ymUI70sKFMaVqEsRnYtBE=\ngithub.com/andeya/goutil v1.0.0 h1:ZBF/1dParfzTTiZ3SivkrV3Rd50SnXPqqf4IRvULvNQ=\ngithub.com/andeya/goutil v1.0.0/go.mod h1:jEG5/QnnhG7yGxwFUX6Q+JGMif7sjdHmmNVjn7nhJDo=\ngithub.com/apache/thrift v0.17.0 h1:cMd2aj52n+8VoAtvSvLn4kDC3aZ6IAkBuqWQ2IDu7wo=\ngithub.com/apache/thrift v0.17.0/go.mod h1:OLxhMRJxomX+1I/KUw03qoV3mMz16BwaKI+d4fPBx7Q=\ngithub.com/census-instrumentation/opencensus-proto v0.2.1/go.mod h1:f6KPmirojxKA12rnyqOA5BBL4O983OfeGPqjHWSTneU=\ngithub.com/client9/misspell v0.3.4/go.mod h1:qj6jICC3Q7zFZvVWo7KLAzC3yx5G7kyvSDkc90ppPyw=\ngithub.com/cncf/udpa/go v0.0.0-20191209042840-269d4d468f6f/go.mod h1:M8M6+tZqaGXZJjfX53e64911xZQV5JYwmTeXPW+k8Sc=\ngithub.com/creack/pty v1.1.9/go.mod h1:oKZEueFk5CKHvIhNR5MUki03XCEU+Q6VDXinZuGJ33E=\ngithub.com/davecgh/go-spew v1.1.0/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=\ngithub.com/davecgh/go-spew v1.1.1 h1:vj9j/u1bqnvCEfJOwUhtlOARqs3+rkHYY13jYWTU97c=\ngithub.com/davecgh/go-spew v1.1.1/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=\ngithub.com/envoyproxy/go-control-plane v0.9.0/go.mod h1:YTl/9mNaCwkRvm6d1a2C3ymFceY/DCBVvsKhRF0iEA4=\ngithub.com/envoyproxy/go-control-plane v0.9.4/go.mod h1:6rpuAdCZL397s3pYoYcLgu1mIlRU8Am5FuJP05cCM98=\ngithub.com/envoyproxy/protoc-gen-validate v0.1.0/go.mod h1:iSmxcyjqTsJpI2R4NaDN7+kN2VEUnK/pcBlmesArF7c=\ngithub.com/go-logr/logr v1.2.4 h1:g01GSCwiDw2xSZfjJ2/T9M+S6pFdcNtFYsp+Y43HYDQ=\ngithub.com/go-task/slim-sprig v0.0.0-20230315185526-52ccab3ef572 h1:tfuBGBXKqDEevZMzYi5KSi8KkcZtzBcTgAUUtapy0OI=\ngithub.com/go-task/slim-sprig v0.0.0-20230315185526-52ccab3ef572/go.mod h1:9Pwr4B2jHnOSGXyyzV8ROjYa2ojvAY6HCGYYfMoC3Ls=\ngithub.com/gogo/protobuf v1.3.2 h1:Ov1cvc58UF3b5XjBnZv7+opcTcQFZebYjWzi34vdm4Q=\ngithub.com/gogo/protobuf v1.3.2/go.mod h1:P1XiOD3dCwIKUDQYPy72D8LYyHL2YPYrpS2s69NZV8Q=\ngithub.com/golang/glog v0.0.0-20160126235308-23def4e6c14b/go.mod h1:SBH7ygxi8pfUlaOkMMuAQtPIUF8ecWP5IEl/CR7VP2Q=\ngithub.com/golang/mock v1.1.1/go.mod h1:oTYuIxOrZwtPieC+H1uAHpcLFnEyAGVDL/k47Jfbm0A=\ngithub.com/golang/mock v1.6.0 h1:ErTB+efbowRARo13NNdxyJji2egdxLGQhRaY+DUumQc=\ngithub.com/golang/mock v1.6.0/go.mod h1:p6yTPP+5HYm5mzsMV8JkE6ZKdX+/wYM6Hr+LicevLPs=\ngithub.com/golang/protobuf v1.2.0/go.mod h1:6lQm79b+lXiMfvg/cZm0SGofjICqVBUtrP5yJMmIC1U=\ngithub.com/golang/protobuf v1.3.2/go.mod h1:6lQm79b+lXiMfvg/cZm0SGofjICqVBUtrP5yJMmIC1U=\ngithub.com/golang/protobuf v1.3.3/go.mod h1:vzj43D7+SQXF/4pzW/hwtAqwc6iTitCiVSaWz5lYuqw=\ngithub.com/golang/protobuf v1.4.0-rc.1/go.mod h1:ceaxUfeHdC40wWswd/P6IGgMaK3YpKi5j83Wpe3EHw8=\ngithub.com/golang/protobuf v1.4.0-rc.1.0.20200221234624-67d41d38c208/go.mod h1:xKAWHe0F5eneWXFV3EuXVDTCmh+JuBKY0li0aMyXATA=\ngithub.com/golang/protobuf v1.4.0-rc.2/go.mod h1:LlEzMj4AhA7rCAGe4KMBDvJI+AwstrUpVNzEA03Pprs=\ngithub.com/golang/protobuf v1.4.0-rc.4.0.20200313231945-b860323f09d0/go.mod h1:WU3c8KckQ9AFe+yFwt9sWVRKCVIyN9cPHBJSNnbL67w=\ngithub.com/golang/protobuf v1.4.0/go.mod h1:jodUvKwWbYaEsadDk5Fwe5c77LiNKVO9IDvqG2KuDX0=\ngithub.com/golang/protobuf v1.4.2/go.mod h1:oDoupMAO8OvCJWAcko0GGGIgR6R6ocIYbsSw735rRwI=\ngithub.com/golang/protobuf v1.5.0/go.mod h1:FsONVRAS9T7sI+LIUmWTfcYkHO4aIWwzhcaSAoJOfIk=\ngithub.com/golang/protobuf v1.5.3 h1:KhyjKVUg7Usr/dYsdSqoFveMYd5ko72D+zANwlG1mmg=\ngithub.com/golang/protobuf v1.5.3/go.mod h1:XVQd3VNwM+JqD3oG2Ue2ip4fOMUkwXdXDdiuN0vRsmY=\ngithub.com/google/go-cmp v0.2.0/go.mod h1:oXzfMopK8JAjlY9xF4vHSVASa0yLyX7SntLO5aqRK0M=\ngithub.com/google/go-cmp v0.3.0/go.mod h1:8QqcDgzrUqlUb/G2PQTWiueGozuR1884gddMywk6iLU=\ngithub.com/google/go-cmp v0.3.1/go.mod h1:8QqcDgzrUqlUb/G2PQTWiueGozuR1884gddMywk6iLU=\ngithub.com/google/go-cmp v0.4.0/go.mod h1:v8dTdLbMG2kIc/vJvl+f65V22dbkXbowE6jgT/gNBxE=\ngithub.com/google/go-cmp v0.5.5/go.mod h1:v8dTdLbMG2kIc/vJvl+f65V22dbkXbowE6jgT/gNBxE=\ngithub.com/google/go-cmp v0.5.9 h1:O2Tfq5qg4qc4AmwVlvv0oLiVAGB7enBSJ2x2DqQFi38=\ngithub.com/google/pprof v0.0.0-20221203041831-ce31453925ec h1:fR20TYVVwhK4O7r7y+McjRYyaTH6/vjwJOajE+XhlzM=\ngithub.com/google/pprof v0.0.0-20221203041831-ce31453925ec/go.mod h1:dDKJzRmX4S37WGHujM7tX//fmj1uioxKzKxz3lo4HJo=\ngithub.com/henrylee2cn/ameda v1.5.1 h1:4n25dZyVSAgRCJ4DLLYF65ynwr9RYO92oFbdyUJWAFk=\ngithub.com/henrylee2cn/ameda v1.5.1/go.mod h1:wnTERseg26LtcSrHOPlV3pBGnNwQiz3TNIeMEgNoNlg=\ngithub.com/kavu/go_reuseport v1.5.0 h1:UNuiY2OblcqAtVDE8Gsg1kZz8zbBWg907sP1ceBV+bk=\ngithub.com/kavu/go_reuseport v1.5.0/go.mod h1:CG8Ee7ceMFSMnx/xr25Vm0qXaj2Z4i5PWoUx+JZ5/CU=\ngithub.com/kisielk/errcheck v1.5.0/go.mod h1:pFxgyoBC7bSaBwPgfKdkLd5X25qrDl4LWUI2bnpBCr8=\ngithub.com/kisielk/gotool v1.0.0/go.mod h1:XhKaO+MFFWcvkIS/tQcRk01m1F5IRFswLeQ+oQHNcck=\ngithub.com/klauspost/cpuid v1.2.4/go.mod h1:Pj4uuM528wm8OyEC2QMXAi2YiTZ96dNQPGgoMS4s3ek=\ngithub.com/klauspost/cpuid v1.3.1/go.mod h1:bYW4mA6ZgKPob1/Dlai2LviZJO7KGI3uoWLd42rAQw4=\ngithub.com/klauspost/cpuid/v2 v2.2.2 h1:xPMwiykqNK9VK0NYC3+jTMYv9I6Vl3YdjZgPZKG3zO0=\ngithub.com/klauspost/cpuid/v2 v2.2.2/go.mod h1:RVVoqg1df56z8g3pUjL/3lE5UfnlrJX8tyFgg4nqhuY=\ngithub.com/klauspost/reedsolomon v1.9.9/go.mod h1:O7yFFHiQwDR6b2t63KPUpccPtNdp5ADgh1gg4fd12wo=\ngithub.com/klauspost/reedsolomon v1.11.3 h1:rX9UNNvDhJ0Bq45y6uBy/eYehcjyz5faokTuZmu1Q9U=\ngithub.com/klauspost/reedsolomon v1.11.3/go.mod h1:FXLZzlJIdfqEnQLdUKWNRuMZg747hZ4oYp2Ml60Lb/k=\ngithub.com/kr/pretty v0.3.1 h1:flRD4NNwYAUpkphVc1HcthR4KEIFJ65n8Mw5qdRn3LE=\ngithub.com/kr/pretty v0.3.1/go.mod h1:hoEshYVHaxMs3cyo3Yncou5ZscifuDolrwPKZanG3xk=\ngithub.com/kr/text v0.2.0 h1:5Nx0Ya0ZqY2ygV366QzturHI13Jq95ApcVaJBhpS+AY=\ngithub.com/kr/text v0.2.0/go.mod h1:eLer722TekiGuMkidMxC/pM04lWEeraHUUmBw8l2grE=\ngithub.com/mmcloughlin/avo v0.0.0-20200803215136-443f81d77104/go.mod h1:wqKykBG2QzQDJEzvRkcS8x6MiSJkF52hXZsXcjaB3ls=\ngithub.com/montanaflynn/stats v0.5.0 h1:2EkzeTSqBB4V4bJwWrt5gIIrZmpJBcoIRGS2kWLgzmk=\ngithub.com/montanaflynn/stats v0.5.0/go.mod h1:wL8QJuTMNUDYhXwkmfOly8iTdp5TEcJFWZD2D7SIkUc=\ngithub.com/onsi/ginkgo/v2 v2.9.5 h1:+6Hr4uxzP4XIUyAkg61dWBw8lb/gc4/X5luuxN/EC+Q=\ngithub.com/onsi/ginkgo/v2 v2.9.5/go.mod h1:tvAoo1QUJwNEU2ITftXTpR7R1RbCzoZUOs3RonqW57k=\ngithub.com/onsi/gomega v1.27.6 h1:ENqfyGeS5AX/rlXDd/ETokDz93u0YufY1Pgxuy/PvWE=\ngithub.com/pkg/diff v0.0.0-20210226163009-20ebb0f2a09e/go.mod h1:pJLUxLENpZxwdsKMEsNbx1VGcRFpLqf3715MtcvvzbA=\ngithub.com/pkg/errors v0.9.1 h1:FEBLx1zS214owpjy7qsBeixbURkuhQAwrK5UwLGTwt4=\ngithub.com/pkg/errors v0.9.1/go.mod h1:bwawxfHBFNV+L2hUp1rHADufV3IMtnDRdf1r5NINEl0=\ngithub.com/pmezard/go-difflib v1.0.0 h1:4DBwDE0NGyQoBHbLQYPwSUPoCMWR5BEzIk/f1lZbAQM=\ngithub.com/pmezard/go-difflib v1.0.0/go.mod h1:iKH77koFhYxTK1pcRnkKkqfTogsbg7gZNVY4sRDYZ/4=\ngithub.com/prometheus/client_model v0.0.0-20190812154241-14fe0d1b01d4/go.mod h1:xMI15A0UPsDsEKsMN9yxemIoYk6Tm2C1GtYGdfGttqA=\ngithub.com/quic-go/qtls-go1-20 v0.3.3 h1:17/glZSLI9P9fDAeyCHBFSWSqJcwx1byhLwP5eUIDCM=\ngithub.com/quic-go/qtls-go1-20 v0.3.3/go.mod h1:X9Nh97ZL80Z+bX/gUXMbipO6OxdiDi58b/fMC9mAL+k=\ngithub.com/quic-go/quic-go v0.38.1 h1:M36YWA5dEhEeT+slOu/SwMEucbYd0YFidxG3KlGPZaE=\ngithub.com/quic-go/quic-go v0.38.1/go.mod h1:ijnZM7JsFIkp4cRyjxJNIzdSfCLmUMg9wdyhGmg+SN4=\ngithub.com/rogpeppe/go-internal v1.9.0 h1:73kH8U+JUqXU8lRuOHeVHaa/SZPifC7BkcraZVejAe8=\ngithub.com/rogpeppe/go-internal v1.9.0/go.mod h1:WtVeX8xhTBvf0smdhujwtBcq4Qrzq/fJaraNFVN+nFs=\ngithub.com/stretchr/objx v0.1.0/go.mod h1:HFkY916IF+rwdDfMAkV7OtwuqBVzrE8GR6GFx+wExME=\ngithub.com/stretchr/objx v0.4.0/go.mod h1:YvHI0jy2hoMjB+UWwv71VJQ9isScKT/TqJzVSSt89Yw=\ngithub.com/stretchr/testify v1.6.1/go.mod h1:6Fq8oRcR53rry900zMqJjRRixrwX3KX962/h/Wwjteg=\ngithub.com/stretchr/testify v1.7.1/go.mod h1:6Fq8oRcR53rry900zMqJjRRixrwX3KX962/h/Wwjteg=\ngithub.com/stretchr/testify v1.7.5 h1:s5PTfem8p8EbKQOctVV53k6jCJt3UX4IEJzwh+C324Q=\ngithub.com/stretchr/testify v1.7.5/go.mod h1:yNjHg4UonilssWZ8iaSj1OCr/vHnekPRkoO+kdMU+MU=\ngithub.com/templexxx/cpu v0.0.1/go.mod h1:w7Tb+7qgcAlIyX4NhLuDKt78AHA5SzPmq0Wj6HiEnnk=\ngithub.com/templexxx/cpu v0.0.7/go.mod h1:w7Tb+7qgcAlIyX4NhLuDKt78AHA5SzPmq0Wj6HiEnnk=\ngithub.com/templexxx/cpu v0.0.9 h1:cGGLK8twbc1J1S/fHnZW7BylXYaFP+0fR2s+nzsFDiU=\ngithub.com/templexxx/cpu v0.0.9/go.mod h1:w7Tb+7qgcAlIyX4NhLuDKt78AHA5SzPmq0Wj6HiEnnk=\ngithub.com/templexxx/xorsimd v0.4.1 h1:iUZcywbOYDRAZUasAs2eSCUW8eobuZDy0I9FJiORkVg=\ngithub.com/templexxx/xorsimd v0.4.1/go.mod h1:W+ffZz8jJMH2SXwuKu9WhygqBMbFnp14G2fqEr8qaNo=\ngithub.com/tidwall/evio v1.0.8 h1:+M7lh83rL4KwEObDGtXP3J1wE5utH80LeaAhrKCGVfE=\ngithub.com/tidwall/evio v1.0.8/go.mod h1:MJhRp4iVVqx/n/5mJk77oKmSABVhC7yYykcJiKaFYYw=\ngithub.com/tidwall/gjson v1.14.1 h1:iymTbGkQBhveq21bEvAQ81I0LEBork8BFe1CUZXdyuo=\ngithub.com/tidwall/gjson v1.14.1/go.mod h1:/wbyibRr2FHMks5tjHJ5F8dMZh3AcwJEMf5vlfC0lxk=\ngithub.com/tidwall/match v1.1.1 h1:+Ho715JplO36QYgwN9PGYNhgZvoUSc9X2c80KVTi+GA=\ngithub.com/tidwall/match v1.1.1/go.mod h1:eRSPERbgtNPcGhD8UCthc6PmLEQXEWd3PRB5JTxsfmM=\ngithub.com/tidwall/pretty v1.2.0 h1:RWIZEg2iJ8/g6fDDYzMpobmaoGh5OLl4AXtGUGPcqCs=\ngithub.com/tidwall/pretty v1.2.0/go.mod h1:ITEVvHYasfjBbM0u2Pg8T2nJnzm8xPwvNhhsoaGGjNU=\ngithub.com/tjfoc/gmsm v1.3.2/go.mod h1:HaUcFuY0auTiaHB9MHFGCPx5IaLhTUd2atbCFBQXn9w=\ngithub.com/tjfoc/gmsm v1.4.1 h1:aMe1GlZb+0bLjn+cKTPEvvn9oUEBlJitaZiiBwsbgho=\ngithub.com/tjfoc/gmsm v1.4.1/go.mod h1:j4INPkHWMrhJb38G+J6W4Tw0AbuN8Thu3PbdVYhVcTE=\ngithub.com/xtaci/kcp-go/v5 v5.6.1 h1:Pwn0aoeNSPF9dTS7IgiPXn0HEtaIlVb6y5UKWPsx8bI=\ngithub.com/xtaci/kcp-go/v5 v5.6.1/go.mod h1:W3kVPyNYwZ06p79dNwFWQOVFrdcBpDBsdyvK8moQrYo=\ngithub.com/xtaci/lossyconn v0.0.0-20190602105132-8df528c0c9ae h1:J0GxkO96kL4WF+AIT3M4mfUVinOCPgf2uUWYFUzN0sM=\ngithub.com/xtaci/lossyconn v0.0.0-20190602105132-8df528c0c9ae/go.mod h1:gXtu8J62kEgmN++bm9BVICuT/e8yiLI2KFobd/TRFsE=\ngithub.com/yuin/goldmark v1.1.27/go.mod h1:3hX8gzYuyVAZsxl0MRgGTJEmQBFcNTphYh9decYSb74=\ngithub.com/yuin/goldmark v1.1.32/go.mod h1:3hX8gzYuyVAZsxl0MRgGTJEmQBFcNTphYh9decYSb74=\ngithub.com/yuin/goldmark v1.2.1/go.mod h1:3hX8gzYuyVAZsxl0MRgGTJEmQBFcNTphYh9decYSb74=\ngithub.com/yuin/goldmark v1.3.5/go.mod h1:mwnBkeHKe2W/ZEtQ+71ViKU8L12m81fl3OWwC1Zlc8k=\ngolang.org/x/arch v0.0.0-20190909030613-46d78d1859ac/go.mod h1:flIaEI6LNU6xOCD5PaJvn9wGP0agmIOqjrtsKGRguv4=\ngolang.org/x/crypto v0.0.0-20190308221718-c2843e01d9a2/go.mod h1:djNgcEr1/C05ACkg1iLfiJU5Ep61QUkGW8qpdssI0+w=\ngolang.org/x/crypto v0.0.0-20191011191535-87dc89f01550/go.mod h1:yigFU9vqHzYiE8UmvKecakEJjdnWj3jj499lnFckfCI=\ngolang.org/x/crypto v0.0.0-20191219195013-becbf705a915/go.mod h1:LzIPMQfyMNhhGPhUkYOs5KpL4U8rLKemX1yGLhDgUto=\ngolang.org/x/crypto v0.0.0-20200622213623-75b288015ac9/go.mod h1:LzIPMQfyMNhhGPhUkYOs5KpL4U8rLKemX1yGLhDgUto=\ngolang.org/x/crypto v0.0.0-20200728195943-123391ffb6de/go.mod h1:LzIPMQfyMNhhGPhUkYOs5KpL4U8rLKemX1yGLhDgUto=\ngolang.org/x/crypto v0.0.0-20201012173705-84dcc777aaee/go.mod h1:LzIPMQfyMNhhGPhUkYOs5KpL4U8rLKemX1yGLhDgUto=\ngolang.org/x/crypto v0.4.0 h1:UVQgzMY87xqpKNgb+kDsll2Igd33HszWHFLmpaRMq/8=\ngolang.org/x/crypto v0.4.0/go.mod h1:3quD/ATkf6oY+rnes5c3ExXTbLc8mueNue5/DoinL80=\ngolang.org/x/exp v0.0.0-20190121172915-509febef88a4/go.mod h1:CJ0aWSM057203Lf6IL+f9T1iT9GByDxfZKAQTCR3kQA=\ngolang.org/x/exp v0.0.0-20221205204356-47842c84f3db h1:D/cFflL63o2KSLJIwjlcIt8PR064j/xsmdEJL/YvY/o=\ngolang.org/x/exp v0.0.0-20221205204356-47842c84f3db/go.mod h1:CxIveKay+FTh1D0yPZemJVgC/95VzuuOLq5Qi4xnoYc=\ngolang.org/x/lint v0.0.0-20181026193005-c67002cb31c3/go.mod h1:UVdnD1Gm6xHRNCYTkRU2/jEulfH38KcIWyp/GAMgvoE=\ngolang.org/x/lint v0.0.0-20190227174305-5b3e6a55c961/go.mod h1:wehouNa3lNwaWXcvxsM5YxQ5yQlVC4a0KAMCusXpPoU=\ngolang.org/x/lint v0.0.0-20190313153728-d0100b6bd8b3/go.mod h1:6SW0HCj/g11FgYtHlgUYUwCkIfeOF89ocIRzGO/8vkc=\ngolang.org/x/mod v0.2.0/go.mod h1:s0Qsj1ACt9ePp/hMypM3fl4fZqREWJwdYDEqhRiZZUA=\ngolang.org/x/mod v0.3.0/go.mod h1:s0Qsj1ACt9ePp/hMypM3fl4fZqREWJwdYDEqhRiZZUA=\ngolang.org/x/mod v0.4.2/go.mod h1:s0Qsj1ACt9ePp/hMypM3fl4fZqREWJwdYDEqhRiZZUA=\ngolang.org/x/mod v0.10.0 h1:lFO9qtOdlre5W1jxS3r/4szv2/6iXxScdzjoBMXNhYk=\ngolang.org/x/mod v0.10.0/go.mod h1:iBbtSCu2XBx23ZKBPSOrRkjjQPZFPuis4dIYUhu/chs=\ngolang.org/x/net v0.0.0-20180724234803-3673e40ba225/go.mod h1:mL1N/T3taQHkDXs73rZJwtUhF3w3ftmwwsq0BUmARs4=\ngolang.org/x/net v0.0.0-20180826012351-8a410e7b638d/go.mod h1:mL1N/T3taQHkDXs73rZJwtUhF3w3ftmwwsq0BUmARs4=\ngolang.org/x/net v0.0.0-20190213061140-3a22650c66bd/go.mod h1:mL1N/T3taQHkDXs73rZJwtUhF3w3ftmwwsq0BUmARs4=\ngolang.org/x/net v0.0.0-20190311183353-d8887717615a/go.mod h1:t9HGtf8HONx5eT2rtn7q6eTqICYqUVnKs3thJo3Qplg=\ngolang.org/x/net v0.0.0-20190404232315-eb5bcb51f2a3/go.mod h1:t9HGtf8HONx5eT2rtn7q6eTqICYqUVnKs3thJo3Qplg=\ngolang.org/x/net v0.0.0-20190620200207-3b0461eec859/go.mod h1:z5CRVTTTmAJ677TzLLGU+0bjPO0LkuOLi4/5GtJWs/s=\ngolang.org/x/net v0.0.0-20200226121028-0de0cce0169b/go.mod h1:z5CRVTTTmAJ677TzLLGU+0bjPO0LkuOLi4/5GtJWs/s=\ngolang.org/x/net v0.0.0-20200625001655-4c5254603344/go.mod h1:/O7V0waA8r7cgGh81Ro3o1hOxt32SMVPicZroKQ2sZA=\ngolang.org/x/net v0.0.0-20200707034311-ab3426394381/go.mod h1:/O7V0waA8r7cgGh81Ro3o1hOxt32SMVPicZroKQ2sZA=\ngolang.org/x/net v0.0.0-20201010224723-4f7140c49acb/go.mod h1:sp8m0HH+o8qH0wwXwYZr8TS3Oi6o0r6Gce1SSxlDquU=\ngolang.org/x/net v0.0.0-20201021035429-f5854403a974/go.mod h1:sp8m0HH+o8qH0wwXwYZr8TS3Oi6o0r6Gce1SSxlDquU=\ngolang.org/x/net v0.0.0-20210405180319-a5a99cb37ef4/go.mod h1:p54w0d4576C0XHj96bSt6lcn1PtDYWL6XObtHCRCNQM=\ngolang.org/x/net v0.10.0 h1:X2//UzNDwYmtCLn7To6G58Wr6f5ahEAQgKNzv9Y951M=\ngolang.org/x/net v0.10.0/go.mod h1:0qNGK6F8kojg2nk9dLZ2mShWaEBan6FAoqfSigmmuDg=\ngolang.org/x/oauth2 v0.0.0-20180821212333-d2e6202438be/go.mod h1:N/0e6XlmueqKjAGxoOufVs8QHGRruUQn6yWY3a++T0U=\ngolang.org/x/sync v0.0.0-20180314180146-1d60e4601c6f/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=\ngolang.org/x/sync v0.0.0-20181108010431-42b317875d0f/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=\ngolang.org/x/sync v0.0.0-20190423024810-112230192c58/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=\ngolang.org/x/sync v0.0.0-20190911185100-cd5d95a43a6e/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=\ngolang.org/x/sync v0.0.0-20200625203802-6e8e738ad208/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=\ngolang.org/x/sync v0.0.0-20201020160332-67f06af15bc9/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=\ngolang.org/x/sync v0.0.0-20210220032951-036812b2e83c/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=\ngolang.org/x/sys v0.0.0-20180830151530-49385e6e1522/go.mod h1:STP8DvDyc/dI5b8T5hshtkjS+E42TnysNCUPdjciGhY=\ngolang.org/x/sys v0.0.0-20190215142949-d0b11bdaac8a/go.mod h1:STP8DvDyc/dI5b8T5hshtkjS+E42TnysNCUPdjciGhY=\ngolang.org/x/sys v0.0.0-20190412213103-97732733099d/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20200323222414-85ca7c5b95cd/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20200808120158-1030fc2bf1d9/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20200930185726-fdedc70b468f/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20201119102817-f84b799fce68/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20210330210617-4fbd30eecc44/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20210510120138-977fb7262007/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\ngolang.org/x/sys v0.0.0-20220704084225-05e143d24a9e/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\ngolang.org/x/sys v0.8.0 h1:EBmGv8NaZBZTWvrbjNoL6HVt+IVy3QDQpJs7VRIw3tU=\ngolang.org/x/sys v0.8.0/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\ngolang.org/x/term v0.0.0-20201126162022-7de9c90e9dd1/go.mod h1:bj7SfCRtBDWHUb9snDiAeCFNEtKQo2Wmx5Cou7ajbmo=\ngolang.org/x/text v0.3.0/go.mod h1:NqM8EUOU14njkJ3fqMW+pc6Ldnwhi/IjpwHt7yyuwOQ=\ngolang.org/x/text v0.3.3/go.mod h1:5Zoc/QRtKVWzQhOtBMvqHzDpF6irO9z98xDceosuGiQ=\ngolang.org/x/text v0.9.0 h1:2sjJmO8cDvYveuX97RDLsxlyUxLl+GHoLxBiRdHllBE=\ngolang.org/x/tools v0.0.0-20180917221912-90fa682c2a6e/go.mod h1:n7NCudcB/nEzxVGmLbDWY5pfWTLqBcC2KZ6jyYvM4mQ=\ngolang.org/x/tools v0.0.0-20190114222345-bf090417da8b/go.mod h1:n7NCudcB/nEzxVGmLbDWY5pfWTLqBcC2KZ6jyYvM4mQ=\ngolang.org/x/tools v0.0.0-20190226205152-f727befe758c/go.mod h1:9Yl7xja0Znq3iFh3HoIrodX9oNMXvdceNzlUR8zjMvY=\ngolang.org/x/tools v0.0.0-20190311212946-11955173bddd/go.mod h1:LCzVGOaR6xXOjkQ3onu1FJEFr0SW1gC7cKk1uF8kGRs=\ngolang.org/x/tools v0.0.0-20190524140312-2c0ae7006135/go.mod h1:RgjU9mgBXZiqYHBnxXauZ1Gv1EHHAz9KjViQ78xBX0Q=\ngolang.org/x/tools v0.0.0-20191119224855-298f0cb1881e/go.mod h1:b+2E5dAYhXwXZwtnZ6UAqBI28+e2cm9otk0dWdXHAEo=\ngolang.org/x/tools v0.0.0-20200425043458-8463f397d07c/go.mod h1:EkVYQZoAsY45+roYkvgYkIh4xh/qjgUK9TdY2XT94GE=\ngolang.org/x/tools v0.0.0-20200619180055-7c47624df98f/go.mod h1:EkVYQZoAsY45+roYkvgYkIh4xh/qjgUK9TdY2XT94GE=\ngolang.org/x/tools v0.0.0-20200808161706-5bf02b21f123/go.mod h1:njjCfa9FT2d7l9Bc6FUM5FLjQPp3cFF28FI3qnDFljA=\ngolang.org/x/tools v0.0.0-20210106214847-113979e3529a/go.mod h1:emZCQorbCU4vsT4fOWvOPXz4eW1wZW4PmDk9uLelYpA=\ngolang.org/x/tools v0.1.1/go.mod h1:o0xws9oXOQQZyjljx8fwUC0k7L1pTE6eaCbjGeHmOkk=\ngolang.org/x/tools v0.9.1 h1:8WMNJAz3zrtPmnYC7ISf5dEn3MT0gY7jBJfw27yrrLo=\ngolang.org/x/tools v0.9.1/go.mod h1:owI94Op576fPu3cIGQeHs3joujW/2Oc6MtlxbF5dfNc=\ngolang.org/x/xerrors v0.0.0-20190717185122-a985d3407aa7/go.mod h1:I/5z698sn9Ka8TeJc9MKroUUfqBBauWjQqLJ2OPfmY0=\ngolang.org/x/xerrors v0.0.0-20191011141410-1b5146add898/go.mod h1:I/5z698sn9Ka8TeJc9MKroUUfqBBauWjQqLJ2OPfmY0=\ngolang.org/x/xerrors v0.0.0-20191204190536-9bdfabe68543/go.mod h1:I/5z698sn9Ka8TeJc9MKroUUfqBBauWjQqLJ2OPfmY0=\ngolang.org/x/xerrors v0.0.0-20200804184101-5ec99f83aff1/go.mod h1:I/5z698sn9Ka8TeJc9MKroUUfqBBauWjQqLJ2OPfmY0=\ngoogle.golang.org/appengine v1.1.0/go.mod h1:EbEs0AVv82hx2wNQdGPgUI5lhzA/G0D9YwlJXL52JkM=\ngoogle.golang.org/appengine v1.4.0/go.mod h1:xpcJRLb0r/rnEns0DIKYYv+WjYCduHsrkT7/EB5XEv4=\ngoogle.golang.org/genproto v0.0.0-20180817151627-c66870c02cf8/go.mod h1:JiN7NxoALGmiZfu7CAH4rXhgtRTLTxftemlI0sWmxmc=\ngoogle.golang.org/genproto v0.0.0-20190819201941-24fa4b261c55/go.mod h1:DMBHOl98Agz4BDEuKkezgsaosCRResVns1a3J2ZsMNc=\ngoogle.golang.org/grpc v1.19.0/go.mod h1:mqu4LbDTu4XGKhr4mRzUsmM4RtVoemTSY81AxZiDr8c=\ngoogle.golang.org/grpc v1.23.0/go.mod h1:Y5yQAOtifL1yxbo5wqy6BxZv8vAUGQwXBOALyacEbxg=\ngoogle.golang.org/grpc v1.25.1/go.mod h1:c3i+UQWmh7LiEpx4sFZnkU36qjEYZ0imhYfXVyQciAY=\ngoogle.golang.org/grpc v1.31.0/go.mod h1:N36X2cJ7JwdamYAgDz+s+rVMFjt3numwzf/HckM8pak=\ngoogle.golang.org/protobuf v0.0.0-20200109180630-ec00e32a8dfd/go.mod h1:DFci5gLYBciE7Vtevhsrf46CRTquxDuWsQurQQe4oz8=\ngoogle.golang.org/protobuf v0.0.0-20200221191635-4d8936d0db64/go.mod h1:kwYJMbMJ01Woi6D6+Kah6886xMZcty6N08ah7+eCXa0=\ngoogle.golang.org/protobuf v0.0.0-20200228230310-ab0ca4ff8a60/go.mod h1:cfTl7dwQJ+fmap5saPgwCLgHXTUD7jkjRqWcaiX5VyM=\ngoogle.golang.org/protobuf v1.20.1-0.20200309200217-e05f789c0967/go.mod h1:A+miEFZTKqfCUM6K7xSMQL9OKL/b6hQv+e19PK+JZNE=\ngoogle.golang.org/protobuf v1.21.0/go.mod h1:47Nbq4nVaFHyn7ilMalzfO3qCViNmqZ2kzikPIcrTAo=\ngoogle.golang.org/protobuf v1.23.0/go.mod h1:EGpADcykh3NcUnDUJcl1+ZksZNG86OlYog2l/sGQquU=\ngoogle.golang.org/protobuf v1.26.0-rc.1/go.mod h1:jlhhOSvTdKEhbULTjvd4ARK9grFBp09yW+WbY/TyQbw=\ngoogle.golang.org/protobuf v1.26.0/go.mod h1:9q0QmTI4eRPtz6boOQmLYwt+qCgq0jsYwAQnmE0givc=\ngoogle.golang.org/protobuf v1.28.0 h1:w43yiav+6bVFTBQFZX0r7ipe9JQ1QsbMgHwbBziscLw=\ngoogle.golang.org/protobuf v1.28.0/go.mod h1:HV8QOd/L58Z+nl8r43ehVNZIU/HEI6OcFqwMG9pJV4I=\ngopkg.in/check.v1 v0.0.0-20161208181325-20d25e280405/go.mod h1:Co6ibVJAznAaIkqp8huTwlJQCZ016jof/cbN4VW5Yz0=\ngopkg.in/check.v1 v1.0.0-20180628173108-788fd7840127 h1:qIbj1fsPNlZgppZ+VLlY7N33q108Sa+fhmuc+sWQYwY=\ngopkg.in/yaml.v2 v2.4.0 h1:D8xgwECY7CYvx+Y2n4sBz93Jn9JRvxdiyyo8CTfuKaY=\ngopkg.in/yaml.v2 v2.4.0/go.mod h1:RDklbk79AGWmwhnvt/jBztapEOGDOx6ZbXqjP6csGnQ=\ngopkg.in/yaml.v3 v3.0.0-20200313102051-9f266ea9e77c/go.mod h1:K4uyk7z7BCEPqu6E+C64Yfv1cQ7kz7rIZviUmN+EgEM=\ngopkg.in/yaml.v3 v3.0.1 h1:fxVm/GzAzEWqLHuvctI91KS9hhNmmWOoWu0XTYJS7CA=\ngopkg.in/yaml.v3 v3.0.1/go.mod h1:K4uyk7z7BCEPqu6E+C64Yfv1cQ7kz7rIZviUmN+EgEM=\nhonnef.co/go/tools v0.0.0-20190102054323-c2f93a96b099/go.mod h1:rf3lG4BRIbNafJWhAfAdb/ePZxsR/4RtNHQocxwk9r4=\nhonnef.co/go/tools v0.0.0-20190523083050-ea95bdfd59fc/go.mod h1:rf3lG4BRIbNafJWhAfAdb/ePZxsR/4RtNHQocxwk9r4=\nrsc.io/pdf v0.1.1/go.mod h1:n8OzWcQ6Sp37PL01nO98y4iUCRdTGarVfzxY20ICaU4=\n"
        },
        {
          "name": "graceful.go",
          "type": "blob",
          "size": 4.37890625,
          "content": "// Copyright 2015-2019 HenryLee. All Rights Reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage erpc\n\nimport (\n\t\"encoding/json\"\n\t\"os\"\n\t\"sync\"\n\t\"time\"\n\n\t\"github.com/andeya/erpc/v7/quic\"\n\t\"github.com/andeya/goutil\"\n\t\"github.com/andeya/goutil/errors\"\n\t\"github.com/andeya/goutil/graceful\"\n\t\"github.com/andeya/goutil/graceful/inherit_net\"\n)\n\nvar peers = struct {\n\tlist map[*peer]struct{}\n\trwmu sync.RWMutex\n}{\n\tlist: make(map[*peer]struct{}),\n}\n\nfunc addPeer(p *peer) {\n\tpeers.rwmu.Lock()\n\tpeers.list[p] = struct{}{}\n\tpeers.rwmu.Unlock()\n}\n\nfunc deletePeer(p *peer) {\n\tpeers.rwmu.Lock()\n\tdelete(peers.list, p)\n\tpeers.rwmu.Unlock()\n}\n\nfunc shutdown() error {\n\tpeers.rwmu.RLock()\n\tvar (\n\t\tlist  []*peer\n\t\tcount int\n\t\terrCh = make(chan error, len(list))\n\t)\n\tfor p := range peers.list {\n\t\tlist = append(list, p)\n\t}\n\tpeers.rwmu.RUnlock()\n\tfor _, p := range list {\n\t\tcount++\n\t\tgo func(peer *peer) {\n\t\t\terrCh <- peer.Close()\n\t\t}(p)\n\t}\n\tvar err error\n\tfor i := 0; i < count; i++ {\n\t\terr = errors.Merge(err, <-errCh)\n\t}\n\tclose(errCh)\n\treturn err\n}\n\nfunc init() {\n\tgraceful.SetLog(logger)\n\tinitParentLaddrList()\n\tSetShutdown(5*time.Second, nil, nil)\n}\n\n// GraceSignal open graceful shutdown or reboot signal.\nfunc GraceSignal() {\n\tgraceful.GraceSignal()\n}\n\nvar (\n\t// FirstSweep is first executed.\n\t// Usage: share github.com/andeya/goutil/graceful with other project.\n\tFirstSweep func() error\n\t// BeforeExiting is executed before process exiting.\n\t// Usage: share github.com/andeya/goutil/graceful with other project.\n\tBeforeExiting func() error\n)\n\n// SetShutdown sets the function which is called after the process shutdown,\n// and the time-out period for the process shutdown.\n// If 0<=timeout<5s, automatically use 'MinShutdownTimeout'(5s).\n// If timeout<0, indefinite period.\n// 'firstSweep' is first executed.\n// 'beforeExiting' is executed before process exiting.\nfunc SetShutdown(timeout time.Duration, firstSweep, beforeExiting func() error) {\n\tif firstSweep == nil {\n\t\tfirstSweep = func() error { return nil }\n\t}\n\tif beforeExiting == nil {\n\t\tbeforeExiting = func() error { return nil }\n\t}\n\tFirstSweep = func() error {\n\t\tsetParentLaddrList()\n\t\treturn errors.Merge(firstSweep(), inherit_net.SetInherited(), quic.SetInherited())\n\t}\n\tBeforeExiting = func() error {\n\t\treturn errors.Merge(shutdown(), beforeExiting())\n\t}\n\tgraceful.SetShutdown(timeout, FirstSweep, BeforeExiting)\n}\n\n// Shutdown closes all the frame process gracefully.\n// Parameter timeout is used to reset time-out period for the process shutdown.\nfunc Shutdown(timeout ...time.Duration) {\n\tgraceful.Shutdown(timeout...)\n}\n\n// Reboot all the frame process gracefully.\n// NOTE: Windows system are not supported!\nfunc Reboot(timeout ...time.Duration) {\n\tgraceful.Reboot(timeout...)\n}\n\nconst parentLaddrsKey = \"LISTEN_PARENT_ADDRS\"\n\nvar parentAddrList = make(map[string]map[string][]string, 2) // network:host:[host:port]\nvar parentAddrListMutex sync.Mutex\n\nfunc initParentLaddrList() {\n\tparentLaddr := os.Getenv(parentLaddrsKey)\n\tjson.Unmarshal(goutil.StringToBytes(parentLaddr), &parentAddrList)\n}\n\nfunc setParentLaddrList() {\n\tb, _ := json.Marshal(parentAddrList)\n\tgraceful.AddInherited(nil, []*graceful.Env{\n\t\t{K: parentLaddrsKey, V: goutil.BytesToString(b)},\n\t})\n}\n\nfunc pushParentLaddr(network, host, addr string) {\n\tparentAddrListMutex.Lock()\n\tdefer parentAddrListMutex.Unlock()\n\tunifyLocalhost(&host)\n\tm, ok := parentAddrList[network]\n\tif !ok {\n\t\tm = make(map[string][]string)\n\t\tparentAddrList[network] = m\n\t}\n\tm[host] = append(m[host], addr)\n}\n\nfunc popParentLaddr(network, host, laddr string) string {\n\tparentAddrListMutex.Lock()\n\tdefer parentAddrListMutex.Unlock()\n\tunifyLocalhost(&host)\n\tm, ok := parentAddrList[network]\n\tif !ok {\n\t\treturn laddr\n\t}\n\th, ok := m[host]\n\tif !ok {\n\t\treturn laddr\n\t}\n\tif len(h) == 0 {\n\t\treturn laddr\n\t}\n\tm[host] = h[1:]\n\treturn h[0]\n}\n\nfunc unifyLocalhost(host *string) {\n\tswitch *host {\n\tcase \"localhost\":\n\t\t*host = \"127.0.0.1\"\n\tcase \"0.0.0.0\":\n\t\t*host = \"::\"\n\t}\n}\n"
        },
        {
          "name": "helper.go",
          "type": "blob",
          "size": 8.4150390625,
          "content": "// Copyright 2015-2019 HenryLee. All Rights Reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage erpc\n\nimport (\n\t\"context\"\n\t\"crypto/rand\"\n\t\"crypto/rsa\"\n\t\"crypto/tls\"\n\t\"crypto/x509\"\n\t\"encoding/pem\"\n\t\"math/big\"\n\t\"net\"\n\t\"os\"\n\t\"sync\"\n\t\"time\"\n\n\t\"github.com/andeya/erpc/v7/codec\"\n\t\"github.com/andeya/erpc/v7/socket\"\n\t\"github.com/andeya/erpc/v7/utils\"\n\t\"github.com/andeya/goutil/pool\"\n)\n\nvar (\n\t_maxGoroutinesAmount      = (1024 * 1024 * 8) / 8 // max memory 8GB (8KB/goroutine)\n\t_maxGoroutineIdleDuration time.Duration\n\t_gopool                   = pool.NewGoPool(_maxGoroutinesAmount, _maxGoroutineIdleDuration)\n)\n\n// SetGopool set or reset go pool config.\n// NOTE: Make sure to call it before calling NewPeer() and Go()\nfunc SetGopool(maxGoroutinesAmount int, maxGoroutineIdleDuration time.Duration) {\n\t_maxGoroutinesAmount, _maxGoroutineIdleDuration := maxGoroutinesAmount, maxGoroutineIdleDuration\n\tif _gopool != nil {\n\t\t_gopool.Stop()\n\t}\n\t_gopool = pool.NewGoPool(_maxGoroutinesAmount, _maxGoroutineIdleDuration)\n}\n\n// Go similar to go func, but return false if insufficient resources.\nfunc Go(fn func()) bool {\n\tif err := _gopool.Go(fn); err != nil {\n\t\tWarnf(\"%s\", err.Error())\n\t\treturn false\n\t}\n\treturn true\n}\n\n// AnywayGo similar to go func, but concurrent resources are limited.\nfunc AnywayGo(fn func()) {\n\t_gopool.MustGo(fn)\n}\n\n// MustGo always try to use goroutine callbacks\n// until execution is complete or the context is canceled.\nfunc MustGo(fn func(), ctx ...context.Context) error {\n\treturn _gopool.MustGo(fn, ctx...)\n}\n\n// TryGo tries to execute the function via goroutine.\n// If there are no concurrent resources, execute it synchronously.\nfunc TryGo(fn func()) {\n\t_gopool.TryGo(fn)\n}\n\nvar printPidOnce sync.Once\n\nfunc doPrintPid() {\n\tprintPidOnce.Do(func() {\n\t\tPrintf(\"The current process PID: %d\", os.Getpid())\n\t})\n}\n\ntype fakeCallCmd struct {\n\toutput    Message\n\tresult    interface{}\n\tstat      *Status\n\tinputMeta *utils.Args\n}\n\n// NewFakeCallCmd creates a fake CallCmd.\nfunc NewFakeCallCmd(serviceMethod string, arg, result interface{}, stat *Status) CallCmd {\n\treturn &fakeCallCmd{\n\t\toutput: socket.NewMessage(\n\t\t\twithMtype(TypeCall),\n\t\t\tsocket.WithServiceMethod(serviceMethod),\n\t\t\tsocket.WithBody(arg),\n\t\t),\n\t\tresult: result,\n\t\tstat:   stat,\n\t}\n}\n\nvar closedChan = func() <-chan struct{} {\n\tch := make(chan struct{})\n\tclose(ch)\n\treturn ch\n}()\n\n// TracePeer trace back the peer.\nfunc (f *fakeCallCmd) TracePeer() (Peer, bool) {\n\treturn nil, false\n}\n\n// TraceSession trace back the session.\nfunc (f *fakeCallCmd) TraceSession() (Session, bool) {\n\treturn nil, false\n}\n\n// Done returns the chan that indicates whether it has been completed.\nfunc (f *fakeCallCmd) Done() <-chan struct{} {\n\treturn closedChan\n}\n\n// Output returns writed message.\nfunc (f *fakeCallCmd) Output() Message {\n\treturn f.output\n}\n\n// Context carries a deadline, a cancelation signal, and other values across\n// API boundaries.\nfunc (f *fakeCallCmd) Context() context.Context {\n\treturn f.output.Context()\n}\n\n// Reply returns the call reply.\nfunc (f *fakeCallCmd) Reply() (interface{}, *Status) {\n\treturn f.result, f.stat\n}\n\n// StatusOK returns the call status is OK or not.\nfunc (f *fakeCallCmd) StatusOK() bool {\n\treturn f.stat.OK()\n}\n\n// Status returns the call error.\nfunc (f *fakeCallCmd) Status() *Status {\n\treturn f.stat\n}\n\n// InputBodyCodec gets the body codec type of the input message.\nfunc (f *fakeCallCmd) InputBodyCodec() byte {\n\treturn codec.NilCodecID\n}\n\n// InputMeta returns the header metadata of input message.\nfunc (f *fakeCallCmd) InputMeta() *utils.Args {\n\tif f.inputMeta == nil {\n\t\tf.inputMeta = utils.AcquireArgs()\n\t}\n\treturn f.inputMeta\n}\n\n// CostTime returns the called cost time.\n// If PeerConfig.CountTime=false, always returns 0.\nfunc (f *fakeCallCmd) CostTime() time.Duration {\n\treturn 0\n}\n\n// NewTLSConfigFromFile creates a new TLS config.\nfunc NewTLSConfigFromFile(tlsCertFile, tlsKeyFile string, insecureSkipVerifyForClient ...bool) (*tls.Config, error) {\n\tcert, err := tls.LoadX509KeyPair(tlsCertFile, tlsKeyFile)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn newTLSConfig(cert, insecureSkipVerifyForClient...), nil\n}\n\n// GenerateTLSConfigForClient setup a bare-bones(skip verify) TLS config for client.\nfunc GenerateTLSConfigForClient() *tls.Config {\n\treturn &tls.Config{InsecureSkipVerify: true}\n}\n\n// GenerateTLSConfigForServer setup a bare-bones TLS config for server.\nfunc GenerateTLSConfigForServer() *tls.Config {\n\tkey, err := rsa.GenerateKey(rand.Reader, 1024)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\ttemplate := x509.Certificate{SerialNumber: big.NewInt(1)}\n\tcertDER, err := x509.CreateCertificate(rand.Reader, &template, &template, &key.PublicKey, key)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tkeyPEM := pem.EncodeToMemory(&pem.Block{Type: \"RSA PRIVATE KEY\", Bytes: x509.MarshalPKCS1PrivateKey(key)})\n\tcertPEM := pem.EncodeToMemory(&pem.Block{Type: \"CERTIFICATE\", Bytes: certDER})\n\n\tcert, err := tls.X509KeyPair(certPEM, keyPEM)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\treturn newTLSConfig(cert)\n}\n\nfunc newTLSConfig(cert tls.Certificate, insecureSkipVerifyForClient ...bool) *tls.Config {\n\tvar insecureSkipVerify bool\n\tif len(insecureSkipVerifyForClient) > 0 {\n\t\tinsecureSkipVerify = insecureSkipVerifyForClient[0]\n\t}\n\treturn &tls.Config{\n\t\tInsecureSkipVerify:       insecureSkipVerify,\n\t\tCertificates:             []tls.Certificate{cert},\n\t\tNextProtos:               []string{\"http/1.1\", \"h2\"},\n\t\tPreferServerCipherSuites: true,\n\t\tCurvePreferences: []tls.CurveID{\n\t\t\ttls.CurveP256,\n\t\t\ttls.X25519,\n\t\t},\n\t\tMinVersion: tls.VersionTLS12,\n\t\tCipherSuites: []uint16{\n\t\t\ttls.TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384,\n\t\t\ttls.TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384,\n\t\t\ttls.TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305,\n\t\t\ttls.TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305,\n\t\t\ttls.TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256,\n\t\t\ttls.TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256,\n\t\t\ttls.TLS_RSA_WITH_AES_256_GCM_SHA384,\n\t\t\ttls.TLS_RSA_WITH_AES_128_GCM_SHA256,\n\t\t},\n\t}\n}\n\n// ListenerAddress a listener address plugin\ntype ListenerAddress struct {\n\taddr net.Addr\n\thost string\n\tport string\n}\n\nvar _ PostListenPlugin = new(ListenerAddress)\n\n// Addr returns the address object.\nfunc (la *ListenerAddress) Addr() net.Addr {\n\treturn la.addr\n}\n\n// Port returns the port.\nfunc (la *ListenerAddress) Port() string {\n\treturn la.port\n}\n\n// Host returns the host.\nfunc (la *ListenerAddress) Host() string {\n\treturn la.host\n}\n\n// String returns the address string.\nfunc (la *ListenerAddress) String() string {\n\treturn la.addr.String()\n}\n\n// Name returns plugin name.\nfunc (la *ListenerAddress) Name() string {\n\treturn \"ListenerAddress\"\n}\n\n// PostListen gets the listener address.\nfunc (la *ListenerAddress) PostListen(addr net.Addr) (err error) {\n\tla.addr = addr\n\tla.host, la.port, err = net.SplitHostPort(addr.String())\n\treturn\n}\n\n// FakeAddr is a fake address object that implements net.Add interface\ntype FakeAddr struct {\n\tnetwork string\n\taddr    string\n\thost    string\n\tport    string\n\tudpAddr *net.UDPAddr\n}\n\nvar _ net.Addr = (*FakeAddr)(nil)\n\n// NewFakeAddr creates an object that implements net.Add interface.\nfunc NewFakeAddr(network, host, port string) *FakeAddr {\n\tif network == \"\" {\n\t\tnetwork = \"tcp\"\n\t}\n\tif host == \"\" {\n\t\thost = \"0.0.0.0\"\n\t}\n\tif port == \"\" {\n\t\tport = \"0\"\n\t}\n\taddr := net.JoinHostPort(host, port)\n\treturn &FakeAddr{\n\t\tnetwork: network,\n\t\taddr:    addr,\n\t\thost:    host,\n\t\tport:    port,\n\t}\n}\n\n// NewFakeAddr2 creates an object that implements net.Add interface.\nfunc NewFakeAddr2(network, addr string) (*FakeAddr, error) {\n\tif addr == \"\" {\n\t\treturn NewFakeAddr(network, \"\", \"\"), nil\n\t}\n\thost, port, err := net.SplitHostPort(addr)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn NewFakeAddr(network, host, port), nil\n}\n\n// Network returns the address's network name.\nfunc (f *FakeAddr) Network() string {\n\treturn f.network\n}\n\n// String returns the string form of address.\nfunc (f *FakeAddr) String() string {\n\treturn f.addr\n}\n\n// Host returns the address's host(ip).\nfunc (f *FakeAddr) Host() string {\n\treturn f.host\n}\n\n// Port returns the address's port.\nfunc (f *FakeAddr) Port() string {\n\treturn f.port\n}\n"
        },
        {
          "name": "helper_test.go",
          "type": "blob",
          "size": 1.9951171875,
          "content": "package erpc_test\n\nimport (\n\t\"testing\"\n\n\t\"github.com/andeya/erpc/v7\"\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestHTTPServiceMethodMapper(t *testing.T) {\n\tvar cases = []struct{ src, dst string }{\n\t\t{\"AaBb\", \"/aa_bb\"},\n\t\t{\"ABcXYz\", \"/abc_xyz\"},\n\t\t{\"Aa__Bb\", \"/aa_bb\"},\n\t\t{\"Aa________Bb\", \"/aa_bb\"},\n\t\t{\"aa__bb\", \"/aa_bb\"},\n\t\t{\"ABC__XYZ\", \"/abc_xyz\"},\n\t\t{\"Aa_Bb\", \"/aa/bb\"},\n\t\t{\"aa_bb\", \"/aa/bb\"},\n\t\t{\"ABC_XYZ\", \"/abc/xyz\"},\n\t}\n\tfor _, c := range cases {\n\t\tgot := erpc.HTTPServiceMethodMapper(\"\", c.src)\n\t\tif got != c.dst {\n\t\t\tt.Fatalf(\"%s: got: %s, expect: %s\", c.src, got, c.dst)\n\t\t}\n\t}\n}\n\nfunc TestRPCServiceMethodMapper(t *testing.T) {\n\tvar cases = []struct{ src, dst string }{\n\t\t{\"AaBb\", \"AaBb\"},\n\t\t{\"ABcXYz\", \"ABcXYz\"},\n\t\t{\"Aa__Bb\", \"Aa_Bb\"},\n\t\t{\"Aa________Bb\", \"Aa_Bb\"},\n\t\t{\"aa__bb\", \"aa_bb\"},\n\t\t{\"ABC__XYZ\", \"ABC_XYZ\"},\n\t\t{\"Aa_Bb\", \"Aa.Bb\"},\n\t\t{\"aa_bb\", \"aa.bb\"},\n\t\t{\"ABC_XYZ\", \"ABC.XYZ\"},\n\t}\n\tfor _, c := range cases {\n\t\tgot := erpc.RPCServiceMethodMapper(\"\", c.src)\n\t\tif got != c.dst {\n\t\t\tt.Fatalf(\"%s: got: %s, expect: %s\", c.src, got, c.dst)\n\t\t}\n\t}\n}\n\nfunc TestFakeAddr(t *testing.T) {\n\taddr := erpc.NewFakeAddr(\"\", \"\", \"\")\n\tassert.Equal(t, \"0.0.0.0:0\", addr.String())\n\tassert.Equal(t, \"tcp\", addr.Network())\n\n\taddr = erpc.NewFakeAddr(\"tcp\", \"\", \"1234\")\n\tassert.Equal(t, \"0.0.0.0:1234\", addr.String())\n\n\taddr, err := erpc.NewFakeAddr2(\"\", \"\")\n\tassert.NoError(t, err)\n\tassert.Equal(t, \"0.0.0.0:0\", addr.String())\n\tassert.Equal(t, \"tcp\", addr.Network())\n\tassert.Equal(t, \"0.0.0.0\", addr.Host())\n\tassert.Equal(t, \"0\", addr.Port())\n\n\taddr, err = erpc.NewFakeAddr2(\"tcp6\", \":1234\")\n\tassert.NoError(t, err)\n\tassert.Equal(t, \"0.0.0.0:1234\", addr.String())\n\tassert.Equal(t, \"tcp6\", addr.Network())\n\tassert.Equal(t, \"0.0.0.0\", addr.Host())\n\tassert.Equal(t, \"1234\", addr.Port())\n\n\taddr, err = erpc.NewFakeAddr2(\"tcp6\", \"192.0.0.10:1234\")\n\tassert.NoError(t, err)\n\tassert.Equal(t, \"192.0.0.10:1234\", addr.String())\n\tassert.Equal(t, \"tcp6\", addr.Network())\n\tassert.Equal(t, \"192.0.0.10\", addr.Host())\n\tassert.Equal(t, \"1234\", addr.Port())\n}\n"
        },
        {
          "name": "kcp",
          "type": "tree",
          "content": null
        },
        {
          "name": "listener.go",
          "type": "blob",
          "size": 1.9912109375,
          "content": "// Copyright 2015-2019 HenryLee. All Rights Reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage erpc\n\nimport (\n\t\"crypto/tls\"\n\t\"errors\"\n\t\"net\"\n\n\t\"github.com/andeya/erpc/v7/kcp\"\n\t\"github.com/andeya/erpc/v7/quic\"\n\t\"github.com/andeya/goutil/graceful/inherit_net\"\n)\n\nvar testTLSConfig = GenerateTLSConfigForServer()\n\n// NewInheritedListener creates a inherited listener.\nfunc NewInheritedListener(addr net.Addr, tlsConfig *tls.Config) (lis net.Listener, err error) {\n\tladdr := addr.String()\n\tnetwork := addr.Network()\n\tvar host, port string\n\tswitch raddr := addr.(type) {\n\tcase *FakeAddr:\n\t\thost, port = raddr.Host(), raddr.Port()\n\tdefault:\n\t\thost, port, err = net.SplitHostPort(laddr)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\tif port == \"0\" {\n\t\tladdr = popParentLaddr(network, host, laddr)\n\t}\n\n\tif _network := asQUIC(network); _network != \"\" {\n\t\tif tlsConfig == nil {\n\t\t\ttlsConfig = testTLSConfig\n\t\t}\n\t\tlis, err = quic.InheritedListen(_network, laddr, tlsConfig, nil)\n\n\t} else if _network := asKCP(network); _network != \"\" {\n\t\tlis, err = kcp.InheritedListen(_network, laddr, tlsConfig, dataShards, parityShards)\n\n\t} else {\n\t\tlis, err = inherit_net.Listen(network, laddr)\n\t\tif err == nil && tlsConfig != nil {\n\t\t\tif len(tlsConfig.Certificates) == 0 && tlsConfig.GetCertificate == nil {\n\t\t\t\treturn nil, errors.New(\"tls: neither Certificates nor GetCertificate set in Config\")\n\t\t\t}\n\t\t\tlis = tls.NewListener(lis, tlsConfig)\n\t\t}\n\t}\n\n\tif err == nil {\n\t\tpushParentLaddr(network, host, lis.Addr().String())\n\t}\n\treturn\n}\n"
        },
        {
          "name": "log.go",
          "type": "blob",
          "size": 25.3603515625,
          "content": "// Copyright 2015-2019 HenryLee. All Rights Reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage erpc\n\nimport (\n\t\"fmt\"\n\t\"log\"\n\t\"os\"\n\t\"runtime\"\n\t\"strings\"\n\t\"sync\"\n\t\"time\"\n\n\t\"github.com/andeya/goutil/graceful\"\n\n\t\"github.com/andeya/erpc/v7/utils\"\n\t\"github.com/andeya/erpc/v7/utils/color\"\n\t\"github.com/andeya/goutil\"\n)\n\ntype (\n\t// LoggerOutputter writes log.\n\tLoggerOutputter interface {\n\t\t// Output writes log, can append time, line and so on information.\n\t\tOutput(calldepth int, msgBytes []byte, loggerLevel LoggerLevel)\n\t\t// Flush writes any buffered log to the underlying io.Writer.\n\t\tFlush() error\n\t}\n\t// LoggerLevel defines all available log levels for log messages.\n\tLoggerLevel int\n\t// Logger logger interface\n\tLogger interface {\n\t\t// Printf formats according to a format specifier and writes to standard output.\n\t\t// It returns the number of bytes written and any write error encountered.\n\t\tPrintf(format string, a ...interface{})\n\t\t// LazyPrintf get message from @getMsg and write to stdout when log level is met.\n\t\tLazyPrintf(getMsg func() string)\n\t\t// Fatalf is equivalent to Criticalf followed by a call to os.Exit(1).\n\t\tFatalf(format string, a ...interface{})\n\t\t// LazyFatalf get message from @getMsg and write to stdout when log level is met.\n\t\tLazyFatalf(getMsg func() string)\n\t\t// Panicf is equivalent to Criticalf followed by a call to panic().\n\t\tPanicf(format string, a ...interface{})\n\t\t// LazyPanicf get message from @getMsg and write to stdout when log level is met.\n\t\tLazyPanicf(getMsg func() string)\n\t\t// Criticalf logs a message using CRITICAL as log level.\n\t\tCriticalf(format string, a ...interface{})\n\t\t// LazyCriticalf get message from @getMsg and write to stdout when log level is met.\n\t\tLazyCriticalf(getMsg func() string)\n\t\t// Errorf logs a message using ERROR as log level.\n\t\tErrorf(format string, a ...interface{})\n\t\t// LazyErrorf get message from @getMsg and write to stdout when log level is met.\n\t\tLazyErrorf(getMsg func() string)\n\t\t// Warnf logs a message using WARNING as log level.\n\t\tWarnf(format string, a ...interface{})\n\t\t// LazyWarnf get message from @getMsg and write to stdout when log level is met.\n\t\tLazyWarnf(getMsg func() string)\n\t\t// Noticef logs a message using NOTICE as log level.\n\t\tNoticef(format string, a ...interface{})\n\t\t// LazyNoticef get message from @getMsg and write to stdout when log level is met.\n\t\tLazyNoticef(getMsg func() string)\n\t\t// Infof logs a message using INFO as log level.\n\t\tInfof(format string, a ...interface{})\n\t\t// LazyInfof get message from @getMsg and write to stdout when log level is met.\n\t\tLazyInfof(getMsg func() string)\n\t\t// Debugf logs a message using DEBUG as log level.\n\t\tDebugf(format string, a ...interface{})\n\t\t// LazyDebugf get message from @getMsg and write to stdout when log level is met.\n\t\tLazyDebugf(getMsg func() string)\n\t\t// Tracef logs a message using TRACE as log level.\n\t\tTracef(format string, a ...interface{})\n\t\t// LazyTracef get message from @getMsg and write to stdout when log level is met.\n\t\tLazyTracef(getMsg func() string)\n\t}\n)\n\n// Logger levels.\nconst (\n\tOFF LoggerLevel = iota\n\tPRINT\n\tCRITICAL\n\tERROR\n\tWARNING\n\tNOTICE\n\tINFO\n\tDEBUG\n\tTRACE\n)\n\nvar loggerLevelMap = map[LoggerLevel]string{\n\tOFF:      \"OFF\",\n\tPRINT:    \"PRINT\",\n\tCRITICAL: \"CRITICAL\",\n\tERROR:    \"ERROR\",\n\tWARNING:  \"WARNING\",\n\tNOTICE:   \"NOTICE\",\n\tINFO:     \"INFO\",\n\tDEBUG:    \"DEBUG\",\n\tTRACE:    \"TRACE\",\n}\n\nvar loggerLevel = DEBUG\n\nfunc (l LoggerLevel) String() string {\n\ts, ok := loggerLevelMap[l]\n\tif !ok {\n\t\treturn \"unknown\"\n\t}\n\treturn s\n}\n\ntype easyLoggerOutputter struct {\n\toutput func(calldepth int, msgBytes []byte, loggerLevel LoggerLevel)\n\tflush  func() error\n}\n\n// Output writes log.\nfunc (e *easyLoggerOutputter) Output(calldepth int, msgBytes []byte, loggerLevel LoggerLevel) {\n\te.output(calldepth, msgBytes, loggerLevel)\n}\n\n// Flush writes any buffered log to the underlying io.Writer.\nfunc (e *easyLoggerOutputter) Flush() error {\n\treturn e.flush()\n}\n\nvar loggerOutputter = func() LoggerOutputter {\n\ttype msg struct {\n\t\tlogBytes    []byte\n\t\tloggerLevel LoggerLevel\n\t}\n\tvar p = sync.Pool{\n\t\tNew: func() interface{} {\n\t\t\treturn new(msg)\n\t\t},\n\t}\n\tvar loggerLevelTagMap = map[LoggerLevel]string{\n\t\tOFF:      color.Bold(\"OFF\"),\n\t\tPRINT:    color.Bold(\"PRIN\"),\n\t\tCRITICAL: color.Magenta(color.Bold(\"CRIT\")),\n\t\tERROR:    color.Red(color.Bold(\"ERRO\")),\n\t\tWARNING:  color.Yellow(color.Bold(\"WARN\")),\n\t\tNOTICE:   color.Green(color.Bold(\"NOTI\")),\n\t\tINFO:     color.Green(color.Bold(\"INFO\")),\n\t\tDEBUG:    color.Cyan(color.Bold(\"DEBU\")),\n\t\tTRACE:    color.Cyan(color.Bold(\"TRAC\")),\n\t}\n\tvar c = make(chan *msg, 1024)\n\tgo func() {\n\t\tfor m := range c {\n\t\t\tif m == nil {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif m.loggerLevel > ERROR || m.loggerLevel == PRINT {\n\t\t\t\tcolor.Stderr.Write(m.logBytes)\n\t\t\t} else {\n\t\t\t\tcolor.Stdout.Write(m.logBytes)\n\t\t\t}\n\t\t\tp.Put(m)\n\t\t}\n\t}()\n\treturn &easyLoggerOutputter{\n\t\toutput: func(calldepth int, msgBytes []byte, loggerLevel LoggerLevel) {\n\t\t\tm := p.Get().(*msg)\n\t\t\tbuf := utils.AcquireByteBuffer()\n\t\t\tbuf.WriteString(\"[\" + time.Now().Format(\"2006/01/02 15:04:05.000\") + \"]\")\n\t\t\tbuf.WriteString(\" [\" + loggerLevelTagMap[loggerLevel] + \"] \")\n\t\t\tbuf.Write(msgBytes)\n\t\t\tline := goutil.GetCallLine(calldepth + 1)\n\t\t\tif !strings.Contains(line, \"github.com/andeya/erpc\") &&\n\t\t\t\t!strings.Contains(line, \"github.com/andeya/goutil/graceful\") {\n\t\t\t\tbuf.WriteString(\" <\" + line + \">\\n\")\n\t\t\t} else {\n\t\t\t\tbuf.WriteByte('\\n')\n\t\t\t}\n\t\t\tm.logBytes = goutil.StringToBytes(buf.String())\n\t\t\tm.loggerLevel = loggerLevel\n\t\t\tc <- m\n\t\t},\n\t\tflush: func() error {\n\t\t\tc <- nil\n\t\t\tfor len(c) > 0 {\n\t\t\t\truntime.Gosched()\n\t\t\t}\n\t\t\treturn nil\n\t\t},\n\t}\n}()\n\n// FlushLogger writes any buffered log to the underlying io.Writer.\nfunc FlushLogger() error {\n\treturn loggerOutputter.Flush()\n}\n\n// SetLoggerOutputter sets logger outputter.\n// NOTE: Concurrent is not safe!\nfunc SetLoggerOutputter(outputter LoggerOutputter) (flusher func() error) {\n\tloggerOutputter = outputter\n\treturn FlushLogger\n}\n\n// SetLoggerLevel sets the logger's level by string.\nfunc SetLoggerLevel(level string) (flusher func() error) {\n\tfor k, v := range loggerLevelMap {\n\t\tif v == level {\n\t\t\tloggerLevel = k\n\t\t\treturn FlushLogger\n\t\t}\n\t}\n\tlog.Printf(\"Unknown level string: %s\", level)\n\treturn FlushLogger\n}\n\n// SetLoggerLevel2 sets the logger's level by number.\nfunc SetLoggerLevel2(level LoggerLevel) (flusher func() error) {\n\t_, ok := loggerLevelMap[level]\n\tif !ok {\n\t\tlog.Printf(\"Unknown level number: %d\", level)\n\t\treturn FlushLogger\n\t}\n\tloggerLevel = level\n\treturn FlushLogger\n}\n\n// GetLoggerLevel gets the logger's level.\nfunc GetLoggerLevel() LoggerLevel {\n\treturn loggerLevel\n}\n\n// EnableLoggerLevel returns if can print the level of log.\nfunc EnableLoggerLevel(level LoggerLevel) bool {\n\tif level <= loggerLevel {\n\t\treturn level != OFF\n\t}\n\treturn false\n}\n\n// GetLogger returns the global logger object.\nfunc GetLogger() Logger {\n\treturn logger\n}\n\nfunc loggerOutput(loggerLevel LoggerLevel, format string, a ...interface{}) {\n\tif !EnableLoggerLevel(loggerLevel) {\n\t\treturn\n\t}\n\tloggerOutputter.Output(3, goutil.StringToBytes(fmt.Sprintf(format, a...)), loggerLevel)\n}\n\nfunc lazyLoggerOutput(targetLevel LoggerLevel, getMsg func() string) {\n\tif !EnableLoggerLevel(targetLevel) {\n\t\treturn\n\t}\n\tloggerOutputter.Output(3, goutil.StringToBytes(getMsg()), targetLevel)\n}\n\n// ************ global logger functions ************\n\n// Printf formats according to a format specifier and writes to standard output.\n// It returns the number of bytes written and any write error encountered.\nfunc Printf(format string, a ...interface{}) {\n\tloggerOutput(PRINT, format, a...)\n}\n\n// LazyPrintf get message from @getMsg and write to stdout when log level is met.\nfunc LazyPrintf(getMsg func() string) {\n\tlazyLoggerOutput(PRINT, getMsg)\n}\n\n// Fatalf is equivalent to l.Criticalf followed by a call to os.Exit(1).\nfunc Fatalf(format string, a ...interface{}) {\n\tloggerOutput(CRITICAL, format, a...)\n\tloggerOutputter.Flush()\n\tos.Exit(1)\n}\n\n// LazyFatalf get message from @getMsg and write to stdout when log level is met.\nfunc LazyFatalf(getMsg func() string) {\n\tlazyLoggerOutput(CRITICAL, getMsg)\n\tloggerOutputter.Flush()\n\tos.Exit(1)\n}\n\n// Panicf is equivalent to l.Criticalf followed by a call to panic().\nfunc Panicf(format string, a ...interface{}) {\n\tloggerOutput(CRITICAL, format, a...)\n\tloggerOutputter.Flush()\n\tpanic(fmt.Sprintf(format, a...))\n}\n\n// LazyPanicf get message from @getMsg and write to stdout when log level is met.\nfunc LazyPanicf(getMsg func() string) {\n\tlazyLoggerOutput(CRITICAL, getMsg)\n\tloggerOutputter.Flush()\n\tpanic(getMsg())\n}\n\n// Criticalf logs a message using CRITICAL as log level.\nfunc Criticalf(format string, a ...interface{}) {\n\tloggerOutput(CRITICAL, format, a...)\n}\n\n// LazyCriticalf get message from @getMsg and write to stdout when log level is met.\nfunc LazyCriticalf(getMsg func() string) {\n\tlazyLoggerOutput(CRITICAL, getMsg)\n}\n\n// Errorf logs a message using ERROR as log level.\nfunc Errorf(format string, a ...interface{}) {\n\tloggerOutput(ERROR, format, a...)\n}\n\n// LazyErrorf get message from @getMsg and write to stdout when log level is met.\nfunc LazyErrorf(getMsg func() string) {\n\tlazyLoggerOutput(ERROR, getMsg)\n}\n\n// Warnf logs a message using WARNING as log level.\nfunc Warnf(format string, a ...interface{}) {\n\tloggerOutput(WARNING, format, a...)\n}\n\n// LazyWarnf get message from @getMsg and write to stdout when log level is met.\nfunc LazyWarnf(getMsg func() string) {\n\tlazyLoggerOutput(WARNING, getMsg)\n}\n\n// Noticef logs a message using NOTICE as log level.\nfunc Noticef(format string, a ...interface{}) {\n\tloggerOutput(NOTICE, format, a...)\n}\n\n// LazyNoticef get message from @getMsg and write to stdout when log level is met.\nfunc LazyNoticef(getMsg func() string) {\n\tlazyLoggerOutput(NOTICE, getMsg)\n}\n\n// Infof logs a message using INFO as log level.\nfunc Infof(format string, a ...interface{}) {\n\tloggerOutput(INFO, format, a...)\n}\n\n// LazyInfof get message from @getMsg and write to stdout when log level is met.\nfunc LazyInfof(getMsg func() string) {\n\tlazyLoggerOutput(INFO, getMsg)\n}\n\n// Debugf logs a message using DEBUG as log level.\nfunc Debugf(format string, a ...interface{}) {\n\tloggerOutput(DEBUG, format, a...)\n}\n\n// LazyDebugf get message from @getMsg and write to stdout when log level is met.\nfunc LazyDebugf(getMsg func() string) {\n\tlazyLoggerOutput(DEBUG, getMsg)\n}\n\n// Tracef logs a message using TRACE as log level.\nfunc Tracef(format string, a ...interface{}) {\n\tloggerOutput(TRACE, format, a...)\n}\n\n// LazyTracef get message from @getMsg and write to stdout when log level is met.\nfunc LazyTracef(getMsg func() string) {\n\tlazyLoggerOutput(TRACE, getMsg)\n}\n\n// ************ globalLogger logger methods ************\n\ntype globalLogger struct{}\n\nvar (\n\tlogger                            = new(globalLogger)\n\t_      Logger                     = logger\n\t_      graceful.LoggerWithFlusher = logger\n)\n\nfunc (globalLogger) Flush() error {\n\treturn FlushLogger()\n}\n\n// Printf formats according to a format specifier and writes to standard output.\n// It returns the number of bytes written and any write error encountered.\nfunc (globalLogger) Printf(format string, a ...interface{}) {\n\tloggerOutput(PRINT, format, a...)\n}\n\n// LazyPrintf get message from @getMsg and write to stdout when log level is met.\nfunc (globalLogger) LazyPrintf(getMsg func() string) {\n\tlazyLoggerOutput(PRINT, getMsg)\n}\n\n// Fatalf is equivalent to l.Criticalf followed by a call to os.Exit(1).\nfunc (globalLogger) Fatalf(format string, a ...interface{}) {\n\tloggerOutput(CRITICAL, format, a...)\n\tloggerOutputter.Flush()\n\tos.Exit(1)\n}\n\n// LazyFatalf get message from @getMsg and write to stdout when log level is met.\nfunc (globalLogger) LazyFatalf(getMsg func() string) {\n\tlazyLoggerOutput(CRITICAL, getMsg)\n\tloggerOutputter.Flush()\n\tos.Exit(1)\n}\n\n// Panicf is equivalent to l.Criticalf followed by a call to panic().\nfunc (globalLogger) Panicf(format string, a ...interface{}) {\n\tloggerOutput(CRITICAL, format, a...)\n\tloggerOutputter.Flush()\n\tpanic(fmt.Sprintf(format, a...))\n}\n\n// LazyPanicf get message from @getMsg and write to stdout when log level is met.\nfunc (globalLogger) LazyPanicf(getMsg func() string) {\n\tlazyLoggerOutput(CRITICAL, getMsg)\n\tloggerOutputter.Flush()\n\tpanic(getMsg())\n}\n\n// Criticalf logs a message using CRITICAL as log level.\nfunc (globalLogger) Criticalf(format string, a ...interface{}) {\n\tloggerOutput(CRITICAL, format, a...)\n}\n\n// LazyCriticalf get message from @getMsg and write to stdout when log level is met.\nfunc (globalLogger) LazyCriticalf(getMsg func() string) {\n\tlazyLoggerOutput(CRITICAL, getMsg)\n}\n\n// Errorf logs a message using ERROR as log level.\nfunc (globalLogger) Errorf(format string, a ...interface{}) {\n\tloggerOutput(ERROR, format, a...)\n}\n\n// LazyErrorf get message from @getMsg and write to stdout when log level is met.\nfunc (globalLogger) LazyErrorf(getMsg func() string) {\n\tlazyLoggerOutput(ERROR, getMsg)\n}\n\n// Warnf logs a message using WARNING as log level.\nfunc (globalLogger) Warnf(format string, a ...interface{}) {\n\tloggerOutput(WARNING, format, a...)\n}\n\n// LazyWarnf get message from @getMsg and write to stdout when log level is met.\nfunc (globalLogger) LazyWarnf(getMsg func() string) {\n\tlazyLoggerOutput(WARNING, getMsg)\n}\n\n// Noticef logs a message using NOTICE as log level.\nfunc (globalLogger) Noticef(format string, a ...interface{}) {\n\tloggerOutput(NOTICE, format, a...)\n}\n\n// LazyNoticef get message from @getMsg and write to stdout when log level is met.\nfunc (globalLogger) LazyNoticef(getMsg func() string) {\n\tlazyLoggerOutput(NOTICE, getMsg)\n}\n\n// Infof logs a message using INFO as log level.\nfunc (globalLogger) Infof(format string, a ...interface{}) {\n\tloggerOutput(INFO, format, a...)\n}\n\n// LazyInfof get message from @getMsg and write to stdout when log level is met.\nfunc (globalLogger) LazyInfof(getMsg func() string) {\n\tlazyLoggerOutput(INFO, getMsg)\n}\n\n// Debugf logs a message using DEBUG as log level.\nfunc (globalLogger) Debugf(format string, a ...interface{}) {\n\tloggerOutput(DEBUG, format, a...)\n}\n\n// LazyDebugf get message from @getMsg and write to stdout when log level is met.\nfunc (globalLogger) LazyDebugf(getMsg func() string) {\n\tlazyLoggerOutput(DEBUG, getMsg)\n}\n\n// Tracef logs a message using TRACE as log level.\nfunc (globalLogger) Tracef(format string, a ...interface{}) {\n\tloggerOutput(TRACE, format, a...)\n}\n\n// LazyTracef get message from @getMsg and write to stdout when log level is met.\nfunc (globalLogger) LazyTracef(getMsg func() string) {\n\tlazyLoggerOutput(TRACE, getMsg)\n}\n\n// ************ *session logger methods ************\n\n// Printf formats according to a format specifier and writes to standard output.\n// It returns the number of bytes written and any write error encountered.\nfunc (s *session) Printf(format string, a ...interface{}) {\n\tloggerOutput(PRINT, format, a...)\n}\n\n// LazyPrintf get message from @getMsg and write to stdout when log level is met.\nfunc (s *session) LazyPrintf(getMsg func() string) {\n\tlazyLoggerOutput(PRINT, getMsg)\n}\n\n// Fatalf is equivalent to l.Criticalf followed by a call to os.Exit(1).\nfunc (s *session) Fatalf(format string, a ...interface{}) {\n\tloggerOutput(CRITICAL, format, a...)\n\tloggerOutputter.Flush()\n\tos.Exit(1)\n}\n\n// LazyFatalf get message from @getMsg and write to stdout when log level is met.\nfunc (s *session) LazyFatalf(getMsg func() string) {\n\tlazyLoggerOutput(CRITICAL, getMsg)\n\tloggerOutputter.Flush()\n\tos.Exit(1)\n}\n\n// Panicf is equivalent to l.Criticalf followed by a call to panic().\nfunc (s *session) Panicf(format string, a ...interface{}) {\n\tloggerOutput(CRITICAL, format, a...)\n\tloggerOutputter.Flush()\n\tpanic(fmt.Sprintf(format, a...))\n}\n\n// LazyPanicf get message from @getMsg and write to stdout when log level is met.\nfunc (s *session) LazyPanicf(getMsg func() string) {\n\tlazyLoggerOutput(CRITICAL, getMsg)\n\tloggerOutputter.Flush()\n\tpanic(getMsg())\n}\n\n// Criticalf logs a message using CRITICAL as log level.\nfunc (s *session) Criticalf(format string, a ...interface{}) {\n\tloggerOutput(CRITICAL, format, a...)\n}\n\n// LazyCriticalf get message from @getMsg and write to stdout when log level is met.\nfunc (s *session) LazyCriticalf(getMsg func() string) {\n\tlazyLoggerOutput(CRITICAL, getMsg)\n}\n\n// Errorf logs a message using ERROR as log level.\nfunc (s *session) Errorf(format string, a ...interface{}) {\n\tloggerOutput(ERROR, format, a...)\n}\n\n// LazyErrorf get message from @getMsg and write to stdout when log level is met.\nfunc (s *session) LazyErrorf(getMsg func() string) {\n\tlazyLoggerOutput(ERROR, getMsg)\n}\n\n// Warnf logs a message using WARNING as log level.\nfunc (s *session) Warnf(format string, a ...interface{}) {\n\tloggerOutput(WARNING, format, a...)\n}\n\n// LazyWarnf get message from @getMsg and write to stdout when log level is met.\nfunc (s *session) LazyWarnf(getMsg func() string) {\n\tlazyLoggerOutput(WARNING, getMsg)\n}\n\n// Noticef logs a message using NOTICE as log level.\nfunc (s *session) Noticef(format string, a ...interface{}) {\n\tloggerOutput(NOTICE, format, a...)\n}\n\n// LazyNoticef get message from @getMsg and write to stdout when log level is met.\nfunc (s *session) LazyNoticef(getMsg func() string) {\n\tlazyLoggerOutput(NOTICE, getMsg)\n}\n\n// Infof logs a message using INFO as log level.\nfunc (s *session) Infof(format string, a ...interface{}) {\n\tloggerOutput(INFO, format, a...)\n}\n\n// LazyInfof get message from @getMsg and write to stdout when log level is met.\nfunc (s *session) LazyInfof(getMsg func() string) {\n\tlazyLoggerOutput(INFO, getMsg)\n}\n\n// Debugf logs a message using DEBUG as log level.\nfunc (s *session) Debugf(format string, a ...interface{}) {\n\tloggerOutput(DEBUG, format, a...)\n}\n\n// LazyDebugf get message from @getMsg and write to stdout when log level is met.\nfunc (s *session) LazyDebugf(getMsg func() string) {\n\tlazyLoggerOutput(DEBUG, getMsg)\n}\n\n// Tracef logs a message using TRACE as log level.\nfunc (s *session) Tracef(format string, a ...interface{}) {\n\tloggerOutput(TRACE, format, a...)\n}\n\n// LazyTracef get message from @getMsg and write to stdout when log level is met.\nfunc (s *session) LazyTracef(getMsg func() string) {\n\tlazyLoggerOutput(TRACE, getMsg)\n}\n\n// ************ *handlerCtx Pure Logger Methods ************\n\n// Printf formats according to a format specifier and writes to standard output.\n// It returns the number of bytes written and any write error encountered.\nfunc (c *handlerCtx) Printf(format string, a ...interface{}) {\n\tloggerOutput(PRINT, format, a...)\n}\n\n// LazyPrintf get message from @getMsg and write to stdout when log level is met.\nfunc (c *handlerCtx) LazyPrintf(getMsg func() string) {\n\tlazyLoggerOutput(PRINT, getMsg)\n}\n\n// Fatalf is equivalent to l.Criticalf followed by a call to os.Exit(1).\nfunc (c *handlerCtx) Fatalf(format string, a ...interface{}) {\n\tloggerOutput(CRITICAL, format, a...)\n\tloggerOutputter.Flush()\n\tos.Exit(1)\n}\n\n// LazyFatalf get message from @getMsg and write to stdout when log level is met.\nfunc (c *handlerCtx) LazyFatalf(getMsg func() string) {\n\tlazyLoggerOutput(CRITICAL, getMsg)\n\tloggerOutputter.Flush()\n\tos.Exit(1)\n}\n\n// Panicf is equivalent to l.Criticalf followed by a call to panic().\nfunc (c *handlerCtx) Panicf(format string, a ...interface{}) {\n\tloggerOutput(CRITICAL, format, a...)\n\tloggerOutputter.Flush()\n\tpanic(fmt.Sprintf(format, a...))\n}\n\n// LazyPanicf get message from @getMsg and write to stdout when log level is met.\nfunc (c *handlerCtx) LazyPanicf(getMsg func() string) {\n\tlazyLoggerOutput(CRITICAL, getMsg)\n\tloggerOutputter.Flush()\n\tpanic(getMsg())\n}\n\n// Criticalf logs a message using CRITICAL as log level.\nfunc (c *handlerCtx) Criticalf(format string, a ...interface{}) {\n\tloggerOutput(CRITICAL, format, a...)\n}\n\n// LazyCriticalf get message from @getMsg and write to stdout when log level is met.\nfunc (c *handlerCtx) LazyCriticalf(getMsg func() string) {\n\tlazyLoggerOutput(CRITICAL, getMsg)\n}\n\n// Errorf logs a message using ERROR as log level.\nfunc (c *handlerCtx) Errorf(format string, a ...interface{}) {\n\tloggerOutput(ERROR, format, a...)\n}\n\n// LazyErrorf get message from @getMsg and write to stdout when log level is met.\nfunc (c *handlerCtx) LazyErrorf(getMsg func() string) {\n\tlazyLoggerOutput(ERROR, getMsg)\n}\n\n// Warnf logs a message using WARNING as log level.\nfunc (c *handlerCtx) Warnf(format string, a ...interface{}) {\n\tloggerOutput(WARNING, format, a...)\n}\n\n// LazyWarnf get message from @getMsg and write to stdout when log level is met.\nfunc (c *handlerCtx) LazyWarnf(getMsg func() string) {\n\tlazyLoggerOutput(WARNING, getMsg)\n}\n\n// Noticef logs a message using NOTICE as log level.\nfunc (c *handlerCtx) Noticef(format string, a ...interface{}) {\n\tloggerOutput(NOTICE, format, a...)\n}\n\n// LazyNoticef get message from @getMsg and write to stdout when log level is met.\nfunc (c *handlerCtx) LazyNoticef(getMsg func() string) {\n\tlazyLoggerOutput(NOTICE, getMsg)\n}\n\n// Infof logs a message using INFO as log level.\nfunc (c *handlerCtx) Infof(format string, a ...interface{}) {\n\tloggerOutput(INFO, format, a...)\n}\n\n// LazyInfof get message from @getMsg and write to stdout when log level is met.\nfunc (c *handlerCtx) LazyInfof(getMsg func() string) {\n\tlazyLoggerOutput(INFO, getMsg)\n}\n\n// Debugf logs a message using DEBUG as log level.\nfunc (c *handlerCtx) Debugf(format string, a ...interface{}) {\n\tloggerOutput(DEBUG, format, a...)\n}\n\n// LazyDebugf get message from @getMsg and write to stdout when log level is met.\nfunc (c *handlerCtx) LazyDebugf(getMsg func() string) {\n\tlazyLoggerOutput(DEBUG, getMsg)\n}\n\n// Tracef logs a message using TRACE as log level.\nfunc (c *handlerCtx) Tracef(format string, a ...interface{}) {\n\tloggerOutput(TRACE, format, a...)\n}\n\n// LazyTracef get message from @getMsg and write to stdout when log level is met.\nfunc (c *handlerCtx) LazyTracef(getMsg func() string) {\n\tlazyLoggerOutput(TRACE, getMsg)\n}\n\n// ************ *callCmd Pure Logger Methods ************\n\n// Printf formats according to a format specifier and writes to standard output.\n// It returns the number of bytes written and any write error encountered.\nfunc (c *callCmd) Printf(format string, a ...interface{}) {\n\tloggerOutput(PRINT, format, a...)\n}\n\n// LazyPrintf get message from @getMsg and write to stdout when log level is met.\nfunc (c *callCmd) LazyPrintf(getMsg func() string) {\n\tlazyLoggerOutput(PRINT, getMsg)\n}\n\n// Fatalf is equivalent to l.Criticalf followed by a call to os.Exit(1).\nfunc (c *callCmd) Fatalf(format string, a ...interface{}) {\n\tloggerOutput(CRITICAL, format, a...)\n\tloggerOutputter.Flush()\n\tos.Exit(1)\n}\n\n// LazyFatalf get message from @getMsg and write to stdout when log level is met.\nfunc (c *callCmd) LazyFatalf(getMsg func() string) {\n\tlazyLoggerOutput(CRITICAL, getMsg)\n\tloggerOutputter.Flush()\n\tos.Exit(1)\n}\n\n// Panicf is equivalent to l.Criticalf followed by a call to panic().\nfunc (c *callCmd) Panicf(format string, a ...interface{}) {\n\tloggerOutput(CRITICAL, format, a...)\n\tloggerOutputter.Flush()\n\tpanic(fmt.Sprintf(format, a...))\n}\n\n// LazyPanicf get message from @getMsg and write to stdout when log level is met.\nfunc (c *callCmd) LazyPanicf(getMsg func() string) {\n\tlazyLoggerOutput(CRITICAL, getMsg)\n\tloggerOutputter.Flush()\n\tpanic(getMsg())\n}\n\n// Criticalf logs a message using CRITICAL as log level.\nfunc (c *callCmd) Criticalf(format string, a ...interface{}) {\n\tloggerOutput(CRITICAL, format, a...)\n}\n\n// LazyCriticalf get message from @getMsg and write to stdout when log level is met.\nfunc (c *callCmd) LazyCriticalf(getMsg func() string) {\n\tlazyLoggerOutput(CRITICAL, getMsg)\n}\n\n// Errorf logs a message using ERROR as log level.\nfunc (c *callCmd) Errorf(format string, a ...interface{}) {\n\tloggerOutput(ERROR, format, a...)\n}\n\n// LazyErrorf get message from @getMsg and write to stdout when log level is met.\nfunc (c *callCmd) LazyErrorf(getMsg func() string) {\n\tlazyLoggerOutput(ERROR, getMsg)\n}\n\n// Warnf logs a message using WARNING as log level.\nfunc (c *callCmd) Warnf(format string, a ...interface{}) {\n\tloggerOutput(WARNING, format, a...)\n}\n\n// LazyWarnf get message from @getMsg and write to stdout when log level is met.\nfunc (c *callCmd) LazyWarnf(getMsg func() string) {\n\tlazyLoggerOutput(WARNING, getMsg)\n}\n\n// Noticef logs a message using NOTICE as log level.\nfunc (c *callCmd) Noticef(format string, a ...interface{}) {\n\tloggerOutput(NOTICE, format, a...)\n}\n\n// LazyNoticef get message from @getMsg and write to stdout when log level is met.\nfunc (c *callCmd) LazyNoticef(getMsg func() string) {\n\tlazyLoggerOutput(NOTICE, getMsg)\n}\n\n// Infof logs a message using INFO as log level.\nfunc (c *callCmd) Infof(format string, a ...interface{}) {\n\tloggerOutput(INFO, format, a...)\n}\n\n// LazyInfof get message from @getMsg and write to stdout when log level is met.\nfunc (c *callCmd) LazyInfof(getMsg func() string) {\n\tlazyLoggerOutput(INFO, getMsg)\n}\n\n// Debugf logs a message using DEBUG as log level.\nfunc (c *callCmd) Debugf(format string, a ...interface{}) {\n\tloggerOutput(DEBUG, format, a...)\n}\n\n// LazyDebugf get message from @getMsg and write to stdout when log level is met.\nfunc (c *callCmd) LazyDebugf(getMsg func() string) {\n\tlazyLoggerOutput(DEBUG, getMsg)\n}\n\n// Tracef logs a message using TRACE as log level.\nfunc (c *callCmd) Tracef(format string, a ...interface{}) {\n\tloggerOutput(TRACE, format, a...)\n}\n\n// LazyTracef get message from @getMsg and write to stdout when log level is met.\nfunc (c *callCmd) LazyTracef(getMsg func() string) {\n\tlazyLoggerOutput(TRACE, getMsg)\n}\n"
        },
        {
          "name": "log_test.go",
          "type": "blob",
          "size": 0.3203125,
          "content": "package erpc\n\nimport (\n\t\"testing\"\n)\n\nfunc TestLog(t *testing.T) {\n\tPrintf(\"test: %s\", \"Printf()\")\n\tCriticalf(\"test: %s\", \"Criticalf()\")\n\tErrorf(\"test: %s\", \"Errorf()\")\n\tWarnf(\"test: %s\", \"Warnf()\")\n\tNoticef(\"test: %s\", \"Noticef()\")\n\tInfof(\"test: %s\", \"Infof()\")\n\tDebugf(\"test: %s\", \"Debugf()\")\n\tTracef(\"test: %s\", \"Tracef()\")\n}\n"
        },
        {
          "name": "message.go",
          "type": "blob",
          "size": 4.939453125,
          "content": "package erpc\n\nimport (\n\t\"strconv\"\n\n\t\"github.com/andeya/erpc/v7/codec\"\n\t\"github.com/andeya/erpc/v7/socket\"\n\t\"github.com/andeya/erpc/v7/utils\"\n\t\"github.com/andeya/goutil\"\n)\n\n// Message types\nconst (\n\tTypeUndefined byte = 0\n\tTypeCall      byte = 1\n\tTypeReply     byte = 2 // reply to call\n\tTypePush      byte = 3\n\tTypeAuthCall  byte = 4\n\tTypeAuthReply byte = 5\n)\n\n// TypeText returns the message type text.\n// If the type is undefined returns 'Undefined'.\nfunc TypeText(typ byte) string {\n\tswitch typ {\n\tcase TypeCall:\n\t\treturn \"CALL\"\n\tcase TypeReply:\n\t\treturn \"REPLY\"\n\tcase TypePush:\n\t\treturn \"PUSH\"\n\tcase TypeAuthCall:\n\t\treturn \"AUTH_CALL\"\n\tcase TypeAuthReply:\n\t\treturn \"AUTH_REPLY\"\n\tdefault:\n\t\treturn \"Undefined\"\n\t}\n}\n\ntype (\n\t// Socket is a generic stream-oriented network connection.\n\t// NOTE:\n\t//  Multiple goroutines may invoke methods on a Socket simultaneously.\n\tSocket = socket.Socket\n\t// Proto pack/unpack protocol scheme of socket message.\n\tProto = socket.Proto\n\t// ProtoFunc function used to create a custom Proto interface.\n\tProtoFunc = socket.ProtoFunc\n\t// IOWithReadBuffer implements buffered I/O with buffered reader.\n\tIOWithReadBuffer = socket.IOWithReadBuffer\n)\n\ntype (\n\t// Message a socket message data.\n\tMessage = socket.Message\n\t// Header message header interface\n\tHeader = socket.Header\n\t// Body message body interface\n\tBody = socket.Body\n\t// NewBodyFunc creates a new body by header.\n\tNewBodyFunc = socket.NewBodyFunc\n\t// MessageSetting is a pipe function type for setting message.\n\tMessageSetting = socket.MessageSetting\n)\n\nconst (\n\t// MetaRealIP real IP metadata key\n\tMetaRealIP = \"X-Real-IP\"\n\t// MetaAcceptBodyCodec the key of body codec that the sender wishes to accept\n\tMetaAcceptBodyCodec = \"X-Accept-Body-Codec\"\n)\n\nvar (\n\t// GetMessage gets a Message form message pool.\n\t// NOTE:\n\t//  newBodyFunc is only for reading form connection;\n\t//  settings are only for writing to connection.\n\t//  func GetMessage(settings ...MessageSetting) Message\n\tGetMessage = socket.GetMessage\n\t// PutMessage puts a Message to message pool.\n\t//  func PutMessage(m Message)\n\tPutMessage = socket.PutMessage\n)\n\nvar (\n\t// WithNothing nothing to do.\n\t//  func WithNothing() MessageSetting\n\tWithNothing = socket.WithNothing\n\t// WithStatus sets the message status.\n\t// TYPE:\n\t//  func WithStatus(stat *Status) MessageSetting\n\tWithStatus = socket.WithStatus\n\t// WithContext sets the message handling context.\n\t//  func WithContext(ctx context.Context) MessageSetting\n\tWithContext = socket.WithContext\n\t// WithServiceMethod sets the message service method.\n\t// SUGGEST: max len ≤ 255!\n\t//  func WithServiceMethod(serviceMethod string) MessageSetting\n\tWithServiceMethod = socket.WithServiceMethod\n\t// WithAddMeta adds 'key=value' metadata argument.\n\t// Multiple values for the same key may be added.\n\t// SUGGEST: urlencoded string max len ≤ 65535!\n\t//  func WithAddMeta(key, value string) MessageSetting\n\tWithAddMeta = socket.WithAddMeta\n\t// WithSetMeta sets 'key=value' metadata argument.\n\t// SUGGEST: urlencoded string max len ≤ 65535!\n\t//  func WithSetMeta(key, value string) MessageSetting\n\tWithSetMeta = socket.WithSetMeta\n\t// WithDelMeta deletes metadata argument.\n\t//   func WithDelMeta(key string) MessageSetting\n\tWithDelMeta = socket.WithDelMeta\n\t// WithBodyCodec sets the body codec.\n\t//  func WithBodyCodec(bodyCodec byte) MessageSetting\n\tWithBodyCodec = socket.WithBodyCodec\n\t// WithBody sets the body object.\n\t//  func WithBody(body interface{}) MessageSetting\n\tWithBody = socket.WithBody\n\t// WithNewBody resets the function of geting body.\n\t//  NOTE: newBodyFunc is only for reading form connection.\n\t//  func WithNewBody(newBodyFunc socket.NewBodyFunc) MessageSetting\n\tWithNewBody = socket.WithNewBody\n\t// WithXferPipe sets transfer filter pipe.\n\t// NOTE: Panic if the filterID is not registered.\n\t// SUGGEST: The length can not be bigger than 255!\n\t//  func WithXferPipe(filterID ...byte) MessageSetting\n\tWithXferPipe = socket.WithXferPipe\n)\n\n// WithRealIP sets the real IP to metadata.\nfunc WithRealIP(ip string) MessageSetting {\n\treturn socket.WithAddMeta(MetaRealIP, ip)\n}\n\n// WithAcceptBodyCodec sets the body codec that the sender wishes to accept.\n// NOTE: If the specified codec is invalid, the receiver will ignore the mate data.\nfunc WithAcceptBodyCodec(bodyCodec byte) MessageSetting {\n\tif bodyCodec == codec.NilCodecID {\n\t\treturn WithNothing()\n\t}\n\treturn socket.WithAddMeta(MetaAcceptBodyCodec, strconv.FormatUint(uint64(bodyCodec), 10))\n}\n\n// withMtype sets the message type.\nfunc withMtype(mtype byte) MessageSetting {\n\treturn func(m Message) {\n\t\tm.SetMtype(mtype)\n\t}\n}\n\n// GetAcceptBodyCodec gets the body codec that the sender wishes to accept.\n// NOTE: If the specified codec is invalid, the receiver will ignore the mate data.\nfunc GetAcceptBodyCodec(meta *utils.Args) (byte, bool) {\n\ts := meta.Peek(MetaAcceptBodyCodec)\n\tif len(s) == 0 || len(s) > 3 {\n\t\treturn 0, false\n\t}\n\tb, err := strconv.ParseUint(goutil.BytesToString(s), 10, 8)\n\tif err != nil {\n\t\treturn 0, false\n\t}\n\tc := byte(b)\n\treturn c, c != codec.NilCodecID\n}\n"
        },
        {
          "name": "mixer",
          "type": "tree",
          "content": null
        },
        {
          "name": "peer.go",
          "type": "blob",
          "size": 14.865234375,
          "content": "// Copyright 2015-2019 HenryLee. All Rights Reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage erpc\n\nimport (\n\t\"crypto/tls\"\n\t\"fmt\"\n\t\"net\"\n\t\"sync\"\n\t\"time\"\n\n\t\"github.com/andeya/erpc/v7/codec\"\n\t\"github.com/andeya/erpc/v7/kcp\"\n\t\"github.com/andeya/erpc/v7/quic\"\n\t\"github.com/andeya/goutil\"\n\t\"github.com/andeya/goutil/coarsetime\"\n\t\"github.com/andeya/goutil/errors\"\n)\n\ntype (\n\t// BasePeer peer with the common method set\n\tBasePeer interface {\n\t\t// Close closes peer.\n\t\tClose() (err error)\n\t\t// CountSession returns the number of sessions.\n\t\tCountSession() int\n\t\t// GetSession gets the session by id.\n\t\tGetSession(sessionID string) (Session, bool)\n\t\t// RangeSession ranges all sessions. If fn returns false, stop traversing.\n\t\tRangeSession(fn func(sess Session) bool)\n\t\t// SetTLSConfig sets the TLS config.\n\t\tSetTLSConfig(tlsConfig *tls.Config)\n\t\t// SetTLSConfigFromFile sets the TLS config from file.\n\t\tSetTLSConfigFromFile(tlsCertFile, tlsKeyFile string, insecureSkipVerifyForClient ...bool) error\n\t\t// TLSConfig returns the TLS config.\n\t\tTLSConfig() *tls.Config\n\t\t// PluginContainer returns the global plugin container.\n\t\tPluginContainer() *PluginContainer\n\t}\n\t// EarlyPeer the communication peer that has just been created\n\tEarlyPeer interface {\n\t\tBasePeer\n\t\t// Router returns the root router of call or push handlers.\n\t\tRouter() *Router\n\t\t// SubRoute adds handler group.\n\t\tSubRoute(pathPrefix string, plugin ...Plugin) *SubRouter\n\t\t// RouteCall registers CALL handlers, and returns the paths.\n\t\tRouteCall(ctrlStructOrPoolFunc interface{}, plugin ...Plugin) []string\n\t\t// RouteCallFunc registers CALL handler, and returns the path.\n\t\tRouteCallFunc(callHandleFunc interface{}, plugin ...Plugin) string\n\t\t// RoutePush registers PUSH handlers, and returns the paths.\n\t\tRoutePush(ctrlStructOrPoolFunc interface{}, plugin ...Plugin) []string\n\t\t// RoutePushFunc registers PUSH handler, and returns the path.\n\t\tRoutePushFunc(pushHandleFunc interface{}, plugin ...Plugin) string\n\t\t// SetUnknownCall sets the default handler, which is called when no handler for CALL is found.\n\t\tSetUnknownCall(fn func(UnknownCallCtx) (interface{}, *Status), plugin ...Plugin)\n\t\t// SetUnknownPush sets the default handler, which is called when no handler for PUSH is found.\n\t\tSetUnknownPush(fn func(UnknownPushCtx) *Status, plugin ...Plugin)\n\t}\n\t// Peer the communication peer which is server or client role\n\tPeer interface {\n\t\tEarlyPeer\n\t\t// ListenAndServe turns on the listening service.\n\t\tListenAndServe(protoFunc ...ProtoFunc) error\n\t\t// Dial connects with the peer of the destination address.\n\t\tDial(addr string, protoFunc ...ProtoFunc) (Session, *Status)\n\t\t// ServeConn serves the connection and returns a session.\n\t\t// NOTE:\n\t\t//  Not support automatically redials after disconnection;\n\t\t//  Not check TLS;\n\t\t//  Execute the PostAcceptPlugin plugins.\n\t\tServeConn(conn net.Conn, protoFunc ...ProtoFunc) (Session, *Status)\n\t}\n)\n\nvar (\n\t_ BasePeer  = new(peer)\n\t_ EarlyPeer = new(peer)\n\t_ Peer      = new(peer)\n)\n\ntype peer struct {\n\trouter            *Router\n\tpluginContainer   *PluginContainer\n\tsessHub           *SessionHub\n\tcloseCh           chan struct{}\n\tdefaultSessionAge time.Duration // Default session max age, if less than or equal to 0, no time limit\n\tdefaultContextAge time.Duration // Default CALL or PUSH context max age, if less than or equal to 0, no time limit\n\ttlsConfig         *tls.Config\n\tslowCometDuration time.Duration\n\ttimeNow           func() int64\n\tmu                sync.Mutex\n\tnetwork           string\n\tdefaultBodyCodec  byte\n\tprintDetail       bool\n\tcountTime         bool\n\n\t// only for server role\n\tlistenAddr net.Addr\n\tlisteners  map[net.Listener]struct{}\n\n\t// only for client role\n\tdialer *Dialer\n}\n\n// NewPeer creates a new peer.\nfunc NewPeer(cfg PeerConfig, globalLeftPlugin ...Plugin) Peer {\n\tdoPrintPid()\n\tpluginContainer := newPluginContainer()\n\tpluginContainer.AppendLeft(globalLeftPlugin...)\n\tpluginContainer.preNewPeer(&cfg)\n\tif err := cfg.check(); err != nil {\n\t\tFatalf(\"%v\", err)\n\t}\n\n\tvar p = &peer{\n\t\trouter:            newRouter(pluginContainer),\n\t\tpluginContainer:   pluginContainer,\n\t\tsessHub:           newSessionHub(),\n\t\tdefaultSessionAge: cfg.DefaultSessionAge,\n\t\tdefaultContextAge: cfg.DefaultContextAge,\n\t\tcloseCh:           make(chan struct{}),\n\t\tslowCometDuration: cfg.slowCometDuration,\n\t\tnetwork:           cfg.Network,\n\t\tlistenAddr:        cfg.listenAddr,\n\t\tprintDetail:       cfg.PrintDetail,\n\t\tcountTime:         cfg.CountTime,\n\t\tlisteners:         make(map[net.Listener]struct{}),\n\t\tdialer: &Dialer{\n\t\t\tnetwork:        cfg.Network,\n\t\t\tdialTimeout:    cfg.DialTimeout,\n\t\t\tlocalAddr:      cfg.localAddr,\n\t\t\tredialInterval: cfg.RedialInterval,\n\t\t\tredialTimes:    cfg.RedialTimes,\n\t\t},\n\t}\n\n\tif c, err := codec.GetByName(cfg.DefaultBodyCodec); err != nil {\n\t\tFatalf(\"%v\", err)\n\t} else {\n\t\tp.defaultBodyCodec = c.ID()\n\t}\n\tif p.countTime {\n\t\tp.timeNow = func() int64 { return time.Now().UnixNano() }\n\t} else {\n\t\tp.timeNow = func() int64 { return 0 }\n\t}\n\taddPeer(p)\n\tp.pluginContainer.postNewPeer(p)\n\treturn p\n}\n\n// PluginContainer returns the global plugin container.\nfunc (p *peer) PluginContainer() *PluginContainer {\n\treturn p.pluginContainer\n}\n\n// TLSConfig returns the TLS config.\nfunc (p *peer) TLSConfig() *tls.Config {\n\treturn p.tlsConfig\n}\n\n// SetTLSConfig sets the TLS config.\nfunc (p *peer) SetTLSConfig(tlsConfig *tls.Config) {\n\tp.tlsConfig = tlsConfig\n\tp.dialer.tlsConfig = tlsConfig\n}\n\n// SetTLSConfigFromFile sets the TLS config from file.\nfunc (p *peer) SetTLSConfigFromFile(tlsCertFile, tlsKeyFile string, insecureSkipVerifyForClient ...bool) error {\n\ttlsConfig, err := NewTLSConfigFromFile(tlsCertFile, tlsKeyFile, insecureSkipVerifyForClient...)\n\tif err == nil {\n\t\tp.SetTLSConfig(tlsConfig)\n\t}\n\treturn err\n}\n\n// GetSession gets the session by id.\nfunc (p *peer) GetSession(sessionID string) (Session, bool) {\n\treturn p.sessHub.get(sessionID)\n}\n\n// RangeSession ranges all sessions.\n// If fn returns false, stop traversing.\nfunc (p *peer) RangeSession(fn func(sess Session) bool) {\n\tp.sessHub.sessions.Range(func(key, value interface{}) bool {\n\t\treturn fn(value.(*session))\n\t})\n}\n\n// CountSession returns the number of sessions.\nfunc (p *peer) CountSession() int {\n\treturn p.sessHub.len()\n}\n\n// Dial connects with the peer of the destination address.\nfunc (p *peer) Dial(addr string, protoFunc ...ProtoFunc) (Session, *Status) {\n\tstat := p.pluginContainer.preDial(p.dialer.localAddr, addr)\n\tif !stat.OK() {\n\t\treturn nil, stat\n\t}\n\tvar sess = newSession(p, nil, protoFunc)\n\t_, err := p.dialer.dialWithRetry(addr, \"\", func(conn net.Conn) error {\n\t\tsess.socket.Reset(conn, protoFunc...)\n\t\tsess.socket.SetID(sess.LocalAddr().String())\n\t\tif stat = p.pluginContainer.postDial(sess, false); !stat.OK() {\n\t\t\tconn.Close()\n\t\t\treturn stat.Cause()\n\t\t}\n\t\treturn nil\n\t})\n\tif err != nil {\n\t\treturn nil, statDialFailed.Copy(err)\n\t}\n\n\t// create redial func\n\tif p.dialer.RedialTimes() != 0 {\n\t\tsess.redialForClientLocked = func() bool {\n\t\t\toldID := sess.ID()\n\t\t\toldIP := sess.LocalAddr().String()\n\t\t\toldConn := sess.getConn()\n\t\t\tvar err error\n\t\t\tif stat := p.pluginContainer.preDial(p.dialer.localAddr, addr); stat.OK() {\n\t\t\t\t_, err = p.dialer.dialWithRetry(addr, oldID, func(conn net.Conn) error {\n\t\t\t\t\tsess.socket.Reset(conn, protoFunc...)\n\t\t\t\t\tif oldIP == oldID {\n\t\t\t\t\t\tsess.socket.SetID(sess.LocalAddr().String())\n\t\t\t\t\t} else {\n\t\t\t\t\t\tsess.socket.SetID(oldID)\n\t\t\t\t\t}\n\t\t\t\t\tsess.changeStatus(statusPreparing)\n\t\t\t\t\tif stat := p.pluginContainer.postDial(sess, true); !stat.OK() {\n\t\t\t\t\t\tconn.Close()\n\t\t\t\t\t\tsess.changeStatus(statusRedialing)\n\t\t\t\t\t\treturn stat.Cause()\n\t\t\t\t\t}\n\t\t\t\t\treturn nil\n\t\t\t\t})\n\t\t\t} else {\n\t\t\t\terr = stat.Cause()\n\t\t\t}\n\t\t\tif err != nil {\n\t\t\t\tsess.closeLocked()\n\t\t\t\tsess.tryChangeStatus(statusRedialFailed, statusRedialing)\n\t\t\t\tErrorf(\"redial fail (network:%s, addr:%s, id:%s): %s\", p.network, addr, oldID, err.Error())\n\t\t\t\treturn false\n\t\t\t}\n\n\t\t\tif oldConn != nil {\n\t\t\t\toldConn.Close()\n\t\t\t}\n\t\t\tsess.changeStatus(statusOk)\n\t\t\tAnywayGo(sess.startReadAndHandle)\n\t\t\tp.sessHub.set(sess)\n\t\t\tInfof(\"redial ok (network:%s, addr:%s, id:%s)\", p.network, addr, sess.ID())\n\t\t\treturn true\n\t\t}\n\t}\n\n\tInfof(\"dial ok (network:%s, addr:%s, id:%s)\", p.network, addr, sess.ID())\n\tsess.changeStatus(statusOk)\n\tAnywayGo(sess.startReadAndHandle)\n\tp.sessHub.set(sess)\n\treturn sess, nil\n}\n\n// ServeConn serves the connection and returns a session.\n// NOTE:\n//\n//\tNot support automatically redials after disconnection;\n//\tNot check TLS;\n//\tExecute the PostAcceptPlugin plugins.\nfunc (p *peer) ServeConn(conn net.Conn, protoFunc ...ProtoFunc) (Session, *Status) {\n\tnetwork := conn.LocalAddr().Network()\n\tif asQUIC(network) != \"\" {\n\t\tif _, ok := conn.(*quic.Conn); !ok {\n\t\t\treturn nil, NewStatus(CodeWrongConn, \"not support \"+network, \"network must be one of the following: tcp, tcp4, tcp6, unix, unixpacket, kcp or quic\")\n\t\t}\n\t\tnetwork = \"quic\"\n\t} else if asKCP(network) != \"\" {\n\t\tif _, ok := conn.(*kcp.UDPSession); !ok {\n\t\t\treturn nil, NewStatus(CodeWrongConn, \"not support \"+network, \"network must be one of the following: tcp, tcp4, tcp6, unix, unixpacket, kcp or quic\")\n\t\t}\n\t\tnetwork = \"kcp\"\n\t}\n\tvar sess = newSession(p, conn, protoFunc)\n\tif stat := p.pluginContainer.postAccept(sess); !stat.OK() {\n\t\tsess.Close()\n\t\treturn nil, stat\n\t}\n\tInfof(\"serve ok (network:%s, addr:%s, id:%s)\", network, sess.RemoteAddr().String(), sess.ID())\n\tsess.changeStatus(statusOk)\n\tAnywayGo(sess.startReadAndHandle)\n\tp.sessHub.set(sess)\n\treturn sess, nil\n}\n\n// ErrListenClosed listener is closed error.\nvar ErrListenClosed = errors.New(\"listener is closed\")\n\n// serveListener serves the listener.\n// NOTE: The caller ensures that the listener supports graceful shutdown.\nfunc (p *peer) serveListener(lis net.Listener, protoFunc ...ProtoFunc) error {\n\tdefer lis.Close()\n\tp.listeners[lis] = struct{}{}\n\n\tnetwork := lis.Addr().Network()\n\tswitch lis.(type) {\n\tcase *quic.Listener:\n\t\tnetwork = \"quic\"\n\tcase *kcp.Listener:\n\t\tnetwork = \"kcp\"\n\t}\n\n\taddr := lis.Addr().String()\n\tPrintf(\"listen and serve (network:%s, addr:%s)\", network, addr)\n\n\tp.pluginContainer.postListen(lis.Addr())\n\n\tvar (\n\t\ttempDelay time.Duration // how long to sleep on accept failure\n\t\tcloseCh   = p.closeCh\n\t)\n\tfor {\n\t\tconn, e := lis.Accept()\n\t\tif e != nil {\n\t\t\tselect {\n\t\t\tcase <-closeCh:\n\t\t\t\treturn ErrListenClosed\n\t\t\tdefault:\n\t\t\t}\n\t\t\tif ne, ok := e.(net.Error); ok && ne.Temporary() {\n\t\t\t\tif tempDelay == 0 {\n\t\t\t\t\ttempDelay = 5 * time.Millisecond\n\t\t\t\t} else {\n\t\t\t\t\ttempDelay *= 2\n\t\t\t\t}\n\t\t\t\tif max := 1 * time.Second; tempDelay > max {\n\t\t\t\t\ttempDelay = max\n\t\t\t\t}\n\n\t\t\t\tTracef(\"accept error: %s; retrying in %v\", e.Error(), tempDelay)\n\n\t\t\t\ttime.Sleep(tempDelay)\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\treturn e\n\t\t}\n\t\ttempDelay = 0\n\t\tAnywayGo(func() {\n\t\t\tif c, ok := conn.(*tls.Conn); ok {\n\t\t\t\tif p.defaultSessionAge > 0 {\n\t\t\t\t\tc.SetReadDeadline(coarsetime.CeilingTimeNow().Add(p.defaultSessionAge))\n\t\t\t\t}\n\t\t\t\tif p.defaultContextAge > 0 {\n\t\t\t\t\tc.SetReadDeadline(coarsetime.CeilingTimeNow().Add(p.defaultContextAge))\n\t\t\t\t}\n\t\t\t\tif err := c.Handshake(); err != nil {\n\t\t\t\t\tErrorf(\"TLS handshake error from %s: %s\", c.RemoteAddr(), err.Error())\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}\n\t\t\tvar sess = newSession(p, conn, protoFunc)\n\t\t\tif stat := p.pluginContainer.postAccept(sess); !stat.OK() {\n\t\t\t\tsess.Close()\n\t\t\t\treturn\n\t\t\t}\n\t\t\tInfof(\"accept ok (network:%s, addr:%s, id:%s)\", network, sess.RemoteAddr().String(), sess.ID())\n\t\t\tp.sessHub.set(sess)\n\t\t\tsess.changeStatus(statusOk)\n\t\t\tsess.startReadAndHandle()\n\t\t})\n\t}\n}\n\n// ListenAndServe turns on the listening service.\nfunc (p *peer) ListenAndServe(protoFunc ...ProtoFunc) error {\n\tlis, err := NewInheritedListener(p.listenAddr, p.tlsConfig)\n\tif err != nil {\n\t\tFatalf(\"%v\", err)\n\t}\n\treturn p.serveListener(lis, protoFunc...)\n}\n\n// Close closes peer.\nfunc (p *peer) Close() (err error) {\n\tdefer func() {\n\t\tif p := recover(); p != nil {\n\t\t\terr = fmt.Errorf(\"panic:%v\\n%s\", p, goutil.PanicTrace(2))\n\t\t}\n\t}()\n\tclose(p.closeCh)\n\tfor lis := range p.listeners {\n\t\tif _, ok := lis.(*quic.Listener); !ok {\n\t\t\tlis.Close()\n\t\t}\n\t}\n\tdeletePeer(p)\n\tvar (\n\t\tcount int\n\t\terrCh = make(chan error, 1024)\n\t)\n\tp.sessHub.rangeCallback(func(sess *session) bool {\n\t\tcount++\n\t\tMustGo(func() {\n\t\t\terrCh <- sess.Close()\n\t\t})\n\t\treturn true\n\t})\n\tfor i := 0; i < count; i++ {\n\t\terr = errors.Merge(err, <-errCh)\n\t}\n\tclose(errCh)\n\tfor lis := range p.listeners {\n\t\tif qlis, ok := lis.(*quic.Listener); ok {\n\t\t\terr = errors.Merge(err, qlis.Close())\n\t\t}\n\t}\n\treturn err\n}\n\nvar ctxPool = sync.Pool{\n\tNew: func() interface{} {\n\t\treturn newReadHandleCtx()\n\t},\n}\n\nfunc (p *peer) getContext(s *session, withWg bool) *handlerCtx {\n\tif withWg {\n\t\t// count get context\n\t\ts.graceCtxWaitGroup.Add(1)\n\t}\n\tctx := ctxPool.Get().(*handlerCtx)\n\tctx.clean()\n\tctx.reInit(s)\n\treturn ctx\n}\n\nfunc (p *peer) putContext(ctx *handlerCtx, withWg bool) {\n\tif withWg {\n\t\t// count get context\n\t\tctx.sess.graceCtxWaitGroup.Done()\n\t}\n\tctxPool.Put(ctx)\n}\n\n// Router returns the root router of call or push handlers.\nfunc (p *peer) Router() *Router {\n\treturn p.router\n}\n\n// SubRoute adds handler group.\nfunc (p *peer) SubRoute(pathPrefix string, plugin ...Plugin) *SubRouter {\n\treturn p.router.SubRoute(pathPrefix, plugin...)\n}\n\n// RouteCall registers CALL handlers, and returns the paths.\nfunc (p *peer) RouteCall(callCtrlStructOrPoolFunc interface{}, plugin ...Plugin) []string {\n\treturn p.router.RouteCall(callCtrlStructOrPoolFunc, plugin...)\n}\n\n// RouteCallFunc registers CALL handler, and returns the path.\nfunc (p *peer) RouteCallFunc(callHandleFunc interface{}, plugin ...Plugin) string {\n\treturn p.router.RouteCallFunc(callHandleFunc, plugin...)\n}\n\n// RoutePush registers PUSH handlers, and returns the paths.\nfunc (p *peer) RoutePush(pushCtrlStructOrPoolFunc interface{}, plugin ...Plugin) []string {\n\treturn p.router.RoutePush(pushCtrlStructOrPoolFunc, plugin...)\n}\n\n// RoutePushFunc registers PUSH handler, and returns the path.\nfunc (p *peer) RoutePushFunc(pushHandleFunc interface{}, plugin ...Plugin) string {\n\treturn p.router.RoutePushFunc(pushHandleFunc, plugin...)\n}\n\n// SetUnknownCall sets the default handler,\n// which is called when no handler for CALL is found.\nfunc (p *peer) SetUnknownCall(fn func(UnknownCallCtx) (interface{}, *Status), plugin ...Plugin) {\n\tp.router.SetUnknownCall(fn, plugin...)\n}\n\n// SetUnknownPush sets the default handler,\n// which is called when no handler for PUSH is found.\nfunc (p *peer) SetUnknownPush(fn func(UnknownPushCtx) *Status, plugin ...Plugin) {\n\tp.router.SetUnknownPush(fn, plugin...)\n}\n\n// maybe useful\n\nfunc (p *peer) getCallHandler(uriPath string) (*Handler, bool) {\n\treturn p.router.subRouter.getCall(uriPath)\n}\n\nfunc (p *peer) getPushHandler(uriPath string) (*Handler, bool) {\n\treturn p.router.subRouter.getPush(uriPath)\n}\n"
        },
        {
          "name": "plugin.go",
          "type": "blob",
          "size": 21.5703125,
          "content": "// Copyright 2015-2019 HenryLee. All Rights Reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage erpc\n\nimport (\n\t\"fmt\"\n\t\"net\"\n\n\t\"github.com/andeya/goutil\"\n\t\"github.com/andeya/goutil/errors\"\n)\n\n// Plug-ins during runtime\n\ntype (\n\t// Plugin plugin background\n\tPlugin interface {\n\t\tName() string\n\t}\n\t// PreNewPeerPlugin is executed before creating peer.\n\tPreNewPeerPlugin interface {\n\t\tPlugin\n\t\tPreNewPeer(*PeerConfig, *PluginContainer) error\n\t}\n\t// PostNewPeerPlugin is executed after creating peer.\n\tPostNewPeerPlugin interface {\n\t\tPlugin\n\t\tPostNewPeer(EarlyPeer) error\n\t}\n\t// PostRegPlugin is executed after registering handler.\n\tPostRegPlugin interface {\n\t\tPlugin\n\t\tPostReg(*Handler) error\n\t}\n\t// PostListenPlugin is executed between listening and accepting.\n\tPostListenPlugin interface {\n\t\tPlugin\n\t\tPostListen(net.Addr) error\n\t}\n\t// PreDialPlugin is executed before dialing.\n\tPreDialPlugin interface {\n\t\tPlugin\n\t\tPreDial(localAddr net.Addr, remoteAddr string) *Status\n\t}\n\t// PostDialPlugin is executed after dialing.\n\tPostDialPlugin interface {\n\t\tPlugin\n\t\tPostDial(sess PreSession, isRedial bool) *Status\n\t}\n\t// PostAcceptPlugin is executed after accepting connection.\n\tPostAcceptPlugin interface {\n\t\tPlugin\n\t\tPostAccept(PreSession) *Status\n\t}\n\t// PreWriteCallPlugin is executed before writing CALL message.\n\tPreWriteCallPlugin interface {\n\t\tPlugin\n\t\tPreWriteCall(WriteCtx) *Status\n\t}\n\t// PostWriteCallPlugin is executed after successful writing CALL message.\n\tPostWriteCallPlugin interface {\n\t\tPlugin\n\t\tPostWriteCall(WriteCtx) *Status\n\t}\n\t// PreWriteReplyPlugin is executed before writing REPLY message.\n\tPreWriteReplyPlugin interface {\n\t\tPlugin\n\t\tPreWriteReply(WriteCtx) *Status\n\t}\n\t// PostWriteReplyPlugin is executed after successful writing REPLY message.\n\tPostWriteReplyPlugin interface {\n\t\tPlugin\n\t\tPostWriteReply(WriteCtx) *Status\n\t}\n\t// PreWritePushPlugin is executed before writing PUSH message.\n\tPreWritePushPlugin interface {\n\t\tPlugin\n\t\tPreWritePush(WriteCtx) *Status\n\t}\n\t// PostWritePushPlugin is executed after successful writing PUSH message.\n\tPostWritePushPlugin interface {\n\t\tPlugin\n\t\tPostWritePush(WriteCtx) *Status\n\t}\n\t// PreReadHeaderPlugin is executed before reading message header.\n\tPreReadHeaderPlugin interface {\n\t\tPlugin\n\t\tPreReadHeader(PreCtx) error\n\t}\n\t// PostReadCallHeaderPlugin is executed after reading CALL message header.\n\tPostReadCallHeaderPlugin interface {\n\t\tPlugin\n\t\tPostReadCallHeader(ReadCtx) *Status\n\t}\n\t// PreReadCallBodyPlugin is executed before reading CALL message body.\n\tPreReadCallBodyPlugin interface {\n\t\tPlugin\n\t\tPreReadCallBody(ReadCtx) *Status\n\t}\n\t// PostReadCallBodyPlugin is executed after reading CALL message body.\n\tPostReadCallBodyPlugin interface {\n\t\tPlugin\n\t\tPostReadCallBody(ReadCtx) *Status\n\t}\n\t// PostReadPushHeaderPlugin is executed after reading PUSH message header.\n\tPostReadPushHeaderPlugin interface {\n\t\tPlugin\n\t\tPostReadPushHeader(ReadCtx) *Status\n\t}\n\t// PreReadPushBodyPlugin is executed before reading PUSH message body.\n\tPreReadPushBodyPlugin interface {\n\t\tPlugin\n\t\tPreReadPushBody(ReadCtx) *Status\n\t}\n\t// PostReadPushBodyPlugin is executed after reading PUSH message body.\n\tPostReadPushBodyPlugin interface {\n\t\tPlugin\n\t\tPostReadPushBody(ReadCtx) *Status\n\t}\n\t// PostReadReplyHeaderPlugin is executed after reading REPLY message header.\n\tPostReadReplyHeaderPlugin interface {\n\t\tPlugin\n\t\tPostReadReplyHeader(ReadCtx) *Status\n\t}\n\t// PreReadReplyBodyPlugin is executed before reading REPLY message body.\n\tPreReadReplyBodyPlugin interface {\n\t\tPlugin\n\t\tPreReadReplyBody(ReadCtx) *Status\n\t}\n\t// PostReadReplyBodyPlugin is executed after reading REPLY message body.\n\tPostReadReplyBodyPlugin interface {\n\t\tPlugin\n\t\tPostReadReplyBody(ReadCtx) *Status\n\t}\n\t// PostDisconnectPlugin is executed after disconnection.\n\tPostDisconnectPlugin interface {\n\t\tPlugin\n\t\tPostDisconnect(BaseSession) *Status\n\t}\n)\n\n// PluginContainer a plugin container\ntype PluginContainer struct {\n\t*pluginSingleContainer\n\tleft        *pluginSingleContainer\n\tmiddle      *pluginSingleContainer\n\tright       *pluginSingleContainer\n\trefreshTree func()\n}\n\n// newPluginContainer new a plugin container.\nfunc newPluginContainer() *PluginContainer {\n\tp := &PluginContainer{\n\t\tpluginSingleContainer: newPluginSingleContainer(),\n\t\tleft:                  newPluginSingleContainer(),\n\t\tmiddle:                newPluginSingleContainer(),\n\t\tright:                 newPluginSingleContainer(),\n\t}\n\tp.refreshTree = func() { p.refresh() }\n\treturn p\n}\n\nfunc (p *PluginContainer) cloneAndAppendMiddle(plugins ...Plugin) *PluginContainer {\n\tmiddle := newPluginSingleContainer()\n\tmiddle.plugins = append(p.middle.GetAll(), plugins...)\n\n\tnewPluginContainer := newPluginContainer()\n\tnewPluginContainer.middle = middle\n\tnewPluginContainer.left = p.left\n\tnewPluginContainer.right = p.right\n\tnewPluginContainer.refresh()\n\n\toldRefreshTree := p.refreshTree\n\tp.refreshTree = func() {\n\t\toldRefreshTree()\n\t\tnewPluginContainer.refresh()\n\t}\n\treturn newPluginContainer\n}\n\n// AppendLeft appends plugins on the left side of the pluginContainer.\nfunc (p *PluginContainer) AppendLeft(plugins ...Plugin) {\n\tp.left.appendLeft(plugins...)\n\tp.refreshTree()\n}\n\n// AppendRight appends plugins on the right side of the pluginContainer.\nfunc (p *PluginContainer) AppendRight(plugins ...Plugin) {\n\tp.right.appendRight(plugins...)\n\tp.refreshTree()\n}\n\n// Remove removes a plugin by its name.\nfunc (p *PluginContainer) Remove(pluginName string) error {\n\terr := p.pluginSingleContainer.remove(pluginName)\n\tif err != nil {\n\t\treturn err\n\t}\n\terr = p.left.remove(pluginName)\n\tif err != nil {\n\t\treturn err\n\t}\n\terr = p.middle.remove(pluginName)\n\tif err != nil {\n\t\treturn err\n\t}\n\terr = p.right.remove(pluginName)\n\tif err != nil {\n\t\treturn err\n\t}\n\tp.refreshTree()\n\treturn nil\n}\n\nfunc (p *PluginContainer) refresh() {\n\tcount := len(p.left.plugins) + len(p.middle.plugins) + len(p.right.plugins)\n\tallPlugins := make([]Plugin, count)\n\tcopy(allPlugins[0:], p.left.plugins)\n\tcopy(allPlugins[0+len(p.left.plugins):], p.middle.plugins)\n\tcopy(allPlugins[0+len(p.left.plugins)+len(p.middle.plugins):], p.right.plugins)\n\tm := make(map[string]bool, count)\n\tfor _, plugin := range allPlugins {\n\t\tif plugin == nil {\n\t\t\tFatalf(\"plugin cannot be nil!\")\n\t\t\treturn\n\t\t}\n\t\tif m[plugin.Name()] {\n\t\t\tFatalf(\"repeat add plugin: %s\", plugin.Name())\n\t\t\treturn\n\t\t}\n\t\tm[plugin.Name()] = true\n\t}\n\tp.pluginSingleContainer.plugins = allPlugins\n}\n\n// pluginSingleContainer plugins container.\ntype pluginSingleContainer struct {\n\tplugins []Plugin\n}\n\n// newPluginSingleContainer new a plugin container.\nfunc newPluginSingleContainer() *pluginSingleContainer {\n\treturn &pluginSingleContainer{\n\t\tplugins: make([]Plugin, 0),\n\t}\n}\n\n// appendLeft appends plugins on the left side of the pluginContainer.\nfunc (p *pluginSingleContainer) appendLeft(plugins ...Plugin) {\n\tif len(plugins) == 0 {\n\t\treturn\n\t}\n\tp.plugins = append(plugins, p.plugins...)\n}\n\n// appendRight appends plugins on the right side of the pluginContainer.\nfunc (p *pluginSingleContainer) appendRight(plugins ...Plugin) {\n\tif len(plugins) == 0 {\n\t\treturn\n\t}\n\tp.plugins = append(p.plugins, plugins...)\n}\n\n// GetByName returns a plugin instance by its name.\nfunc (p *pluginSingleContainer) GetByName(pluginName string) Plugin {\n\tif p.plugins == nil {\n\t\treturn nil\n\t}\n\tfor _, plugin := range p.plugins {\n\t\tif plugin.Name() == pluginName {\n\t\t\treturn plugin\n\t\t}\n\t}\n\treturn nil\n}\n\n// GetAll returns all activated plugins.\nfunc (p *pluginSingleContainer) GetAll() []Plugin {\n\treturn p.plugins\n}\n\n// remove removes a plugin by its name.\nfunc (p *pluginSingleContainer) remove(pluginName string) error {\n\tif p.plugins == nil {\n\t\treturn errors.New(\"no plugins are registered yet\")\n\t}\n\tif len(pluginName) == 0 {\n\t\t// return error: cannot delete an unamed plugin\n\t\treturn errors.New(\"plugin with an empty name cannot be removed\")\n\t}\n\tindexToRemove := -1\n\tfor i, plugin := range p.plugins {\n\t\tif plugin.Name() == pluginName {\n\t\t\tindexToRemove = i\n\t\t\tbreak\n\t\t}\n\t}\n\tif indexToRemove == -1 {\n\t\treturn errors.New(\"cannot remove a plugin which isn't exists\")\n\t}\n\tp.plugins = append(p.plugins[:indexToRemove], p.plugins[indexToRemove+1:]...)\n\treturn nil\n}\n\n// PreNewPeer executes the defined plugins before creating peer.\nfunc (p *PluginContainer) preNewPeer(peerConfig *PeerConfig) {\n\tvar err error\n\tfor _, plugin := range p.plugins {\n\t\tif _plugin, ok := plugin.(PreNewPeerPlugin); ok {\n\t\t\tif err = _plugin.PreNewPeer(peerConfig, p); err != nil {\n\t\t\t\tFatalf(\"[PreNewPeerPlugin:%s] %s\", plugin.Name(), err.Error())\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t}\n}\n\n// PostNewPeer executes the defined plugins after creating peer.\nfunc (p *pluginSingleContainer) postNewPeer(peer EarlyPeer) {\n\tvar err error\n\tfor _, plugin := range p.plugins {\n\t\tif _plugin, ok := plugin.(PostNewPeerPlugin); ok {\n\t\t\tif err = _plugin.PostNewPeer(peer); err != nil {\n\t\t\t\tFatalf(\"[PostNewPeerPlugin:%s] %s\", plugin.Name(), err.Error())\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t}\n}\n\n// PostReg executes the defined plugins before registering handler.\nfunc (p *pluginSingleContainer) postReg(h *Handler) {\n\tvar err error\n\tfor _, plugin := range p.plugins {\n\t\tif _plugin, ok := plugin.(PostRegPlugin); ok {\n\t\t\tif err = _plugin.PostReg(h); err != nil {\n\t\t\t\tFatalf(\"[PostRegPlugin:%s] register handler:%s %s, error:%s\", plugin.Name(), h.RouterTypeName(), h.Name(), err.Error())\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t}\n}\n\n// PostListen is executed between listening and accepting.\nfunc (p *pluginSingleContainer) postListen(addr net.Addr) {\n\tvar err error\n\tfor _, plugin := range p.plugins {\n\t\tif _plugin, ok := plugin.(PostListenPlugin); ok {\n\t\t\tif err = _plugin.PostListen(addr); err != nil {\n\t\t\t\tFatalf(\"[PostListenPlugin:%s] network:%s, addr:%s, error:%s\", plugin.Name(), addr.Network(), addr.String(), err.Error())\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t}\n\treturn\n}\n\n// preDial executes the defined plugins before dialing.\nfunc (p *pluginSingleContainer) preDial(localAddr net.Addr, remoteAddr string) (stat *Status) {\n\tvar pluginName string\n\tdefer func() {\n\t\tif p := recover(); p != nil {\n\t\t\tErrorf(\"[PreDialPlugin:%s] network:%s, localAddr%s ,remoteAddr:%s, panic:%v\\n%s\", pluginName, localAddr.Network(), localAddr.String(), remoteAddr, p, goutil.PanicTrace(2))\n\t\t\tstat = statDialFailed.Copy(p)\n\t\t}\n\t}()\n\tfor _, plugin := range p.plugins {\n\t\tif _plugin, ok := plugin.(PreDialPlugin); ok {\n\t\t\tpluginName = plugin.Name()\n\t\t\tif stat = _plugin.PreDial(localAddr, remoteAddr); !stat.OK() {\n\t\t\t\tLazyDebugf(func() string {\n\t\t\t\t\treturn fmt.Sprintf(\"[PreDialPlugin:%s] network:%s, localAddr%s ,remoteAddr:%s, error:%s\",\n\t\t\t\t\t\tpluginName, localAddr.Network(), localAddr.String(), remoteAddr, stat.String(),\n\t\t\t\t\t)\n\t\t\t\t})\n\t\t\t\treturn stat\n\t\t\t}\n\t\t}\n\t}\n\treturn nil\n}\n\n// postDial executes the defined plugins after dialing.\nfunc (p *pluginSingleContainer) postDial(sess PreSession, isRedial bool) (stat *Status) {\n\tvar pluginName string\n\tdefer func() {\n\t\tif p := recover(); p != nil {\n\t\t\tErrorf(\"[PostDialPlugin:%s] network:%s, addr:%s, panic:%v\\n%s\", pluginName, sess.RemoteAddr().Network(), sess.RemoteAddr().String(), p, goutil.PanicTrace(2))\n\t\t\tstat = statDialFailed.Copy(p)\n\t\t}\n\t}()\n\tfor _, plugin := range p.plugins {\n\t\tif _plugin, ok := plugin.(PostDialPlugin); ok {\n\t\t\tpluginName = plugin.Name()\n\t\t\tif stat = _plugin.PostDial(sess, isRedial); !stat.OK() {\n\t\t\t\tLazyDebugf(func() string {\n\t\t\t\t\treturn fmt.Sprintf(\"[PostDialPlugin:%s] network:%s, addr:%s, is_redial:%v, error:%s\",\n\t\t\t\t\t\tpluginName, sess.RemoteAddr().Network(), sess.RemoteAddr().String(), isRedial, stat.String(),\n\t\t\t\t\t)\n\t\t\t\t})\n\t\t\t\treturn stat\n\t\t\t}\n\t\t}\n\t}\n\treturn nil\n}\n\n// PostAccept executes the defined plugins after accepting connection.\nfunc (p *pluginSingleContainer) postAccept(sess PreSession) (stat *Status) {\n\tvar pluginName string\n\tdefer func() {\n\t\tif p := recover(); p != nil {\n\t\t\tErrorf(\"[PostAcceptPlugin:%s] network:%s, addr:%s, panic:%v\\n%s\", pluginName, sess.RemoteAddr().Network(), sess.RemoteAddr().String(), p, goutil.PanicTrace(2))\n\t\t\tstat = statInternalServerError.Copy(p)\n\t\t}\n\t}()\n\tfor _, plugin := range p.plugins {\n\t\tif _plugin, ok := plugin.(PostAcceptPlugin); ok {\n\t\t\tpluginName = plugin.Name()\n\t\t\tif stat = _plugin.PostAccept(sess); !stat.OK() {\n\t\t\t\tLazyDebugf(func() string {\n\t\t\t\t\treturn fmt.Sprintf(\"[PostAcceptPlugin:%s] network:%s, addr:%s, error:%s\", pluginName, sess.RemoteAddr().Network(), sess.RemoteAddr().String(), stat.String())\n\t\t\t\t})\n\t\t\t\treturn stat\n\t\t\t}\n\t\t}\n\t}\n\treturn nil\n}\n\n// PreWriteCall executes the defined plugins before writing CALL message.\nfunc (p *pluginSingleContainer) preWriteCall(ctx WriteCtx) *Status {\n\tvar stat *Status\n\tfor _, plugin := range p.plugins {\n\t\tif _plugin, ok := plugin.(PreWriteCallPlugin); ok {\n\t\t\tif stat = _plugin.PreWriteCall(ctx); !stat.OK() {\n\t\t\t\tLazyDebugf(func() string {\n\t\t\t\t\treturn fmt.Sprintf(\"[PreWriteCallPlugin:%s] %s\", plugin.Name(), stat.String())\n\t\t\t\t})\n\t\t\t\treturn stat\n\t\t\t}\n\t\t}\n\t}\n\treturn nil\n}\n\n// PostWriteCall executes the defined plugins after successful writing CALL message.\nfunc (p *pluginSingleContainer) postWriteCall(ctx WriteCtx) *Status {\n\tvar stat *Status\n\tfor _, plugin := range p.plugins {\n\t\tif _plugin, ok := plugin.(PostWriteCallPlugin); ok {\n\t\t\tif stat = _plugin.PostWriteCall(ctx); !stat.OK() {\n\t\t\t\tErrorf(\"[PostWriteCallPlugin:%s] %s\", plugin.Name(), stat.String())\n\t\t\t\treturn stat\n\t\t\t}\n\t\t}\n\t}\n\treturn nil\n}\n\n// PreWriteReply executes the defined plugins before writing REPLY message.\nfunc (p *pluginSingleContainer) preWriteReply(ctx WriteCtx) {\n\tvar stat *Status\n\tfor _, plugin := range p.plugins {\n\t\tif _plugin, ok := plugin.(PreWriteReplyPlugin); ok {\n\t\t\tif stat = _plugin.PreWriteReply(ctx); !stat.OK() {\n\t\t\t\tErrorf(\"[PreWriteReplyPlugin:%s] %s\", plugin.Name(), stat.String())\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t}\n}\n\n// PostWriteReply executes the defined plugins after successful writing REPLY message.\nfunc (p *pluginSingleContainer) postWriteReply(ctx WriteCtx) {\n\tvar stat *Status\n\tfor _, plugin := range p.plugins {\n\t\tif _plugin, ok := plugin.(PostWriteReplyPlugin); ok {\n\t\t\tif stat = _plugin.PostWriteReply(ctx); !stat.OK() {\n\t\t\t\tErrorf(\"[PostWriteReplyPlugin:%s] %s\", plugin.Name(), stat.String())\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t}\n}\n\n// PreWritePush executes the defined plugins before writing PUSH message.\nfunc (p *pluginSingleContainer) preWritePush(ctx WriteCtx) *Status {\n\tvar stat *Status\n\tfor _, plugin := range p.plugins {\n\t\tif _plugin, ok := plugin.(PreWritePushPlugin); ok {\n\t\t\tif stat = _plugin.PreWritePush(ctx); !stat.OK() {\n\t\t\t\tLazyDebugf(func() string {\n\t\t\t\t\treturn fmt.Sprintf(\"[PreWritePushPlugin:%s] %s\", plugin.Name(), stat.String())\n\t\t\t\t})\n\t\t\t\treturn stat\n\t\t\t}\n\t\t}\n\t}\n\treturn nil\n}\n\n// PostWritePush executes the defined plugins after successful writing PUSH message.\nfunc (p *pluginSingleContainer) postWritePush(ctx WriteCtx) *Status {\n\tvar stat *Status\n\tfor _, plugin := range p.plugins {\n\t\tif _plugin, ok := plugin.(PostWritePushPlugin); ok {\n\t\t\tif stat = _plugin.PostWritePush(ctx); !stat.OK() {\n\t\t\t\tErrorf(\"[PostWritePushPlugin:%s] %s\", plugin.Name(), stat.String())\n\t\t\t\treturn stat\n\t\t\t}\n\t\t}\n\t}\n\treturn nil\n}\n\n// PreReadHeader executes the defined plugins before reading message header.\nfunc (p *pluginSingleContainer) preReadHeader(ctx PreCtx) error {\n\tvar err error\n\tfor _, plugin := range p.plugins {\n\t\tif _plugin, ok := plugin.(PreReadHeaderPlugin); ok {\n\t\t\tif err = _plugin.PreReadHeader(ctx); err != nil {\n\t\t\t\tLazyDebugf(func() string {\n\t\t\t\t\treturn fmt.Sprintf(\"[PreReadHeaderPlugin:%s] disconnected when reading: %s\", plugin.Name(), err.Error())\n\t\t\t\t})\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t}\n\treturn nil\n}\n\n// PostReadCallHeader executes the defined plugins after reading CALL message header.\nfunc (p *pluginSingleContainer) postReadCallHeader(ctx ReadCtx) *Status {\n\tvar stat *Status\n\tfor _, plugin := range p.plugins {\n\t\tif _plugin, ok := plugin.(PostReadCallHeaderPlugin); ok {\n\t\t\tif stat = _plugin.PostReadCallHeader(ctx); !stat.OK() {\n\t\t\t\tErrorf(\"[PostReadCallHeaderPlugin:%s] %s\", plugin.Name(), stat.String())\n\t\t\t\treturn stat\n\t\t\t}\n\t\t}\n\t}\n\treturn nil\n}\n\n// PreReadCallBody executes the defined plugins before reading CALL message body.\nfunc (p *pluginSingleContainer) preReadCallBody(ctx ReadCtx) *Status {\n\tvar stat *Status\n\tfor _, plugin := range p.plugins {\n\t\tif _plugin, ok := plugin.(PreReadCallBodyPlugin); ok {\n\t\t\tif stat = _plugin.PreReadCallBody(ctx); !stat.OK() {\n\t\t\t\tErrorf(\"[PreReadCallBodyPlugin:%s] %s\", plugin.Name(), stat.String())\n\t\t\t\treturn stat\n\t\t\t}\n\t\t}\n\t}\n\treturn nil\n}\n\n// PostReadCallBody executes the defined plugins after reading CALL message body.\nfunc (p *pluginSingleContainer) postReadCallBody(ctx ReadCtx) *Status {\n\tvar stat *Status\n\tfor _, plugin := range p.plugins {\n\t\tif _plugin, ok := plugin.(PostReadCallBodyPlugin); ok {\n\t\t\tif stat = _plugin.PostReadCallBody(ctx); !stat.OK() {\n\t\t\t\tErrorf(\"[PostReadCallBodyPlugin:%s] %s\", plugin.Name(), stat.String())\n\t\t\t\treturn stat\n\t\t\t}\n\t\t}\n\t}\n\treturn nil\n}\n\n// PostReadPushHeader executes the defined plugins after reading PUSH message header.\nfunc (p *pluginSingleContainer) postReadPushHeader(ctx ReadCtx) *Status {\n\tvar stat *Status\n\tfor _, plugin := range p.plugins {\n\t\tif _plugin, ok := plugin.(PostReadPushHeaderPlugin); ok {\n\t\t\tif stat = _plugin.PostReadPushHeader(ctx); !stat.OK() {\n\t\t\t\tErrorf(\"[PostReadPushHeaderPlugin:%s] %s\", plugin.Name(), stat.String())\n\t\t\t\treturn stat\n\t\t\t}\n\t\t}\n\t}\n\treturn nil\n}\n\n// PreReadPushBody executes the defined plugins before reading PUSH message body.\nfunc (p *pluginSingleContainer) preReadPushBody(ctx ReadCtx) *Status {\n\tvar stat *Status\n\tfor _, plugin := range p.plugins {\n\t\tif _plugin, ok := plugin.(PreReadPushBodyPlugin); ok {\n\t\t\tif stat = _plugin.PreReadPushBody(ctx); !stat.OK() {\n\t\t\t\tErrorf(\"[PreReadPushBodyPlugin:%s] %s\", plugin.Name(), stat.String())\n\t\t\t\treturn stat\n\t\t\t}\n\t\t}\n\t}\n\treturn nil\n}\n\n// PostReadPushBody executes the defined plugins after reading PUSH message body.\nfunc (p *pluginSingleContainer) postReadPushBody(ctx ReadCtx) *Status {\n\tvar stat *Status\n\tfor _, plugin := range p.plugins {\n\t\tif _plugin, ok := plugin.(PostReadPushBodyPlugin); ok {\n\t\t\tif stat = _plugin.PostReadPushBody(ctx); !stat.OK() {\n\t\t\t\tErrorf(\"[PostReadPushBodyPlugin:%s] %s\", plugin.Name(), stat.String())\n\t\t\t\treturn stat\n\t\t\t}\n\t\t}\n\t}\n\treturn nil\n}\n\n// PostReadReplyHeader executes the defined plugins after reading REPLY message header.\nfunc (p *pluginSingleContainer) postReadReplyHeader(ctx ReadCtx) *Status {\n\tvar stat *Status\n\tfor _, plugin := range p.plugins {\n\t\tif _plugin, ok := plugin.(PostReadReplyHeaderPlugin); ok {\n\t\t\tif stat = _plugin.PostReadReplyHeader(ctx); !stat.OK() {\n\t\t\t\tErrorf(\"[PostReadReplyHeaderPlugin:%s] %s\", plugin.Name(), stat.String())\n\t\t\t\treturn stat\n\t\t\t}\n\t\t}\n\t}\n\treturn nil\n}\n\n// PreReadReplyBody executes the defined plugins before reading REPLY message body.\nfunc (p *pluginSingleContainer) preReadReplyBody(ctx ReadCtx) *Status {\n\tvar stat *Status\n\tfor _, plugin := range p.plugins {\n\t\tif _plugin, ok := plugin.(PreReadReplyBodyPlugin); ok {\n\t\t\tif stat = _plugin.PreReadReplyBody(ctx); !stat.OK() {\n\t\t\t\tErrorf(\"[PreReadReplyBodyPlugin:%s] %s\", plugin.Name(), stat.String())\n\t\t\t\treturn stat\n\t\t\t}\n\t\t}\n\t}\n\treturn nil\n}\n\n// PostReadReplyBody executes the defined plugins after reading REPLY message body.\nfunc (p *pluginSingleContainer) postReadReplyBody(ctx ReadCtx) *Status {\n\tvar stat *Status\n\tfor _, plugin := range p.plugins {\n\t\tif _plugin, ok := plugin.(PostReadReplyBodyPlugin); ok {\n\t\t\tif stat = _plugin.PostReadReplyBody(ctx); !stat.OK() {\n\t\t\t\tErrorf(\"[PostReadReplyBodyPlugin:%s] %s\", plugin.Name(), stat.String())\n\t\t\t\treturn stat\n\t\t\t}\n\t\t}\n\t}\n\treturn nil\n}\n\n// PostDisconnect executes the defined plugins after disconnection.\nfunc (p *pluginSingleContainer) postDisconnect(sess BaseSession) *Status {\n\tvar stat *Status\n\tfor _, plugin := range p.plugins {\n\t\tif _plugin, ok := plugin.(PostDisconnectPlugin); ok {\n\t\t\tif stat = _plugin.PostDisconnect(sess); !stat.OK() {\n\t\t\t\tErrorf(\"[PostDisconnectPlugin:%s] %s\", plugin.Name(), stat.String())\n\t\t\t\treturn stat\n\t\t\t}\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc warnInvalidHandlerHooks(plugin []Plugin) {\n\tfor _, p := range plugin {\n\t\tswitch p.(type) {\n\t\tcase PreNewPeerPlugin:\n\t\t\tLazyDebugf(func() string {\n\t\t\t\treturn fmt.Sprintf(\"invalid PreNewPeerPlugin in router: %s\", p.Name())\n\t\t\t})\n\t\tcase PostNewPeerPlugin:\n\t\t\tLazyDebugf(func() string {\n\t\t\t\treturn fmt.Sprintf(\"invalid PostNewPeerPlugin in router: %s\", p.Name())\n\t\t\t})\n\t\tcase PostDialPlugin:\n\t\t\tLazyDebugf(func() string {\n\t\t\t\treturn fmt.Sprintf(\"invalid PostDialPlugin in router: %s\", p.Name())\n\t\t\t})\n\t\tcase PostAcceptPlugin:\n\t\t\tLazyDebugf(func() string {\n\t\t\t\treturn fmt.Sprintf(\"invalid PostAcceptPlugin in router: %s\", p.Name())\n\t\t\t})\n\t\tcase PreWriteCallPlugin:\n\t\t\tLazyDebugf(func() string {\n\t\t\t\treturn fmt.Sprintf(\"invalid PreWriteCallPlugin in router: %s\", p.Name())\n\t\t\t})\n\t\tcase PostWriteCallPlugin:\n\t\t\tLazyDebugf(func() string {\n\t\t\t\treturn fmt.Sprintf(\"invalid PostWriteCallPlugin in router: %s\", p.Name())\n\t\t\t})\n\t\tcase PreWritePushPlugin:\n\t\t\tLazyDebugf(func() string {\n\t\t\t\treturn fmt.Sprintf(\"invalid PreWritePushPlugin in router: %s\", p.Name())\n\t\t\t})\n\t\tcase PostWritePushPlugin:\n\t\t\tLazyDebugf(func() string {\n\t\t\t\treturn fmt.Sprintf(\"invalid PostWritePushPlugin in router: %s\", p.Name())\n\t\t\t})\n\t\tcase PreReadHeaderPlugin:\n\t\t\tLazyDebugf(func() string {\n\t\t\t\treturn fmt.Sprintf(\"invalid PreReadHeaderPlugin in router: %s\", p.Name())\n\t\t\t})\n\t\tcase PostReadCallHeaderPlugin:\n\t\t\tLazyDebugf(func() string {\n\t\t\t\treturn fmt.Sprintf(\"invalid PostReadCallHeaderPlugin in router: %s\", p.Name())\n\t\t\t})\n\t\tcase PostReadPushHeaderPlugin:\n\t\t\tLazyDebugf(func() string {\n\t\t\t\treturn fmt.Sprintf(\"invalid PostReadPushHeaderPlugin in router: %s\", p.Name())\n\t\t\t})\n\t\t}\n\t}\n}\n"
        },
        {
          "name": "plugin",
          "type": "tree",
          "content": null
        },
        {
          "name": "plugin_impl.go",
          "type": "blob",
          "size": 8.7060546875,
          "content": "package erpc\n\nimport \"net\"\n\nvar (\n\t_ Plugin                    = (*PluginImpl)(nil)\n\t_ PreNewPeerPlugin          = (*PluginImpl)(nil)\n\t_ PostNewPeerPlugin         = (*PluginImpl)(nil)\n\t_ PostRegPlugin             = (*PluginImpl)(nil)\n\t_ PostListenPlugin          = (*PluginImpl)(nil)\n\t_ PreDialPlugin             = (*PluginImpl)(nil)\n\t_ PostDialPlugin            = (*PluginImpl)(nil)\n\t_ PostAcceptPlugin          = (*PluginImpl)(nil)\n\t_ PreWriteCallPlugin        = (*PluginImpl)(nil)\n\t_ PostWriteCallPlugin       = (*PluginImpl)(nil)\n\t_ PreWriteReplyPlugin       = (*PluginImpl)(nil)\n\t_ PostWriteReplyPlugin      = (*PluginImpl)(nil)\n\t_ PreWritePushPlugin        = (*PluginImpl)(nil)\n\t_ PostWritePushPlugin       = (*PluginImpl)(nil)\n\t_ PreReadHeaderPlugin       = (*PluginImpl)(nil)\n\t_ PostReadCallHeaderPlugin  = (*PluginImpl)(nil)\n\t_ PreReadCallBodyPlugin     = (*PluginImpl)(nil)\n\t_ PostReadCallBodyPlugin    = (*PluginImpl)(nil)\n\t_ PostReadPushHeaderPlugin  = (*PluginImpl)(nil)\n\t_ PreReadPushBodyPlugin     = (*PluginImpl)(nil)\n\t_ PostReadPushBodyPlugin    = (*PluginImpl)(nil)\n\t_ PostReadReplyHeaderPlugin = (*PluginImpl)(nil)\n\t_ PreReadReplyBodyPlugin    = (*PluginImpl)(nil)\n\t_ PostReadReplyBodyPlugin   = (*PluginImpl)(nil)\n\t_ PostDisconnectPlugin      = (*PluginImpl)(nil)\n)\n\n// PluginImpl implemented all plug-in interfaces.\ntype PluginImpl struct {\n\t// PluginName is required field\n\tPluginName string\n\t// OnPreNewPeer is called before a new peer is created.\n\tOnPreNewPeer func(*PeerConfig, *PluginContainer) error\n\t// OnPostNewPeer is called after a new peer is created.\n\tOnPostNewPeer func(EarlyPeer) error\n\t// OnPostReg is called after a handler is registered.\n\tOnPostReg func(*Handler) error\n\t// OnPostListen is called after a listener is created.\n\tOnPostListen func(net.Addr) error\n\t// OnPreDial is called before a dial is created.\n\tOnPreDial func(localAddr net.Addr, remoteAddr string) *Status\n\t// OnPostDial is called after a dial is created.\n\tOnPostDial func(sess PreSession, isRedial bool) *Status\n\t// OnPostAccept is called after a session is accepted.\n\tOnPostAccept func(PreSession) *Status\n\t// OnPreWriteCall is called before a call is written.\n\tOnPreWriteCall func(WriteCtx) *Status\n\t// OnPostWriteCall is called after a call is written.\n\tOnPostWriteCall func(WriteCtx) *Status\n\t// OnPreWriteReply is called before a reply is written.\n\tOnPreWriteReply func(WriteCtx) *Status\n\t// OnPostWriteReply is called after a reply is written.\n\tOnPostWriteReply func(WriteCtx) *Status\n\t// OnPreWritePush is called before a push is written.\n\tOnPreWritePush func(WriteCtx) *Status\n\t// OnPostWritePush is called after a push is written.\n\tOnPostWritePush func(WriteCtx) *Status\n\t// OnPreReadHeader is called before a header is read.\n\tOnPreReadHeader func(PreCtx) error\n\t// OnPostReadCallHeader is called after a call header is read.\n\tOnPostReadCallHeader func(ReadCtx) *Status\n\t// OnPreReadCallBody is called before a call body is read.\n\tOnPreReadCallBody func(ReadCtx) *Status\n\t// OnPostReadCallBody is called after a call body is read.\n\tOnPostReadCallBody func(ReadCtx) *Status\n\t// OnPostReadPushHeader is called after a push header is read.\n\tOnPostReadPushHeader func(ReadCtx) *Status\n\t// OnPreReadPushBody is called before a push body is read.\n\tOnPreReadPushBody func(ReadCtx) *Status\n\t// OnPostReadPushBody is called after a push body is read.\n\tOnPostReadPushBody func(ReadCtx) *Status\n\t// OnPostReadReplyHeader is called after a reply header is read.\n\tOnPostReadReplyHeader func(ReadCtx) *Status\n\t// OnPreReadReplyBody is called before a reply body is read.\n\tOnPreReadReplyBody func(ReadCtx) *Status\n\t// OnPostReadReplyBody is called after a reply body is read.\n\tOnPostReadReplyBody func(ReadCtx) *Status\n\t// OnPostDisconnect is called after a session is disconnected.\n\tOnPostDisconnect func(BaseSession) *Status\n}\n\n// Name returns the name of the plugin.\nfunc (p *PluginImpl) Name() string {\n\treturn p.PluginName\n}\n\n// PreNewPeer is called before a new peer is created.\nfunc (p *PluginImpl) PreNewPeer(peerConfig *PeerConfig, pluginContainer *PluginContainer) error {\n\tif p.OnPreNewPeer == nil {\n\t\treturn nil\n\t}\n\treturn p.OnPreNewPeer(peerConfig, pluginContainer)\n}\n\n// PostNewPeer is called after a new peer is created.\nfunc (p *PluginImpl) PostNewPeer(earlyPeer EarlyPeer) error {\n\tif p.OnPostNewPeer == nil {\n\t\treturn nil\n\t}\n\treturn p.OnPostNewPeer(earlyPeer)\n}\n\n// PostReg is called after a handler is registered.\nfunc (p *PluginImpl) PostReg(handler *Handler) error {\n\tif p.OnPostReg == nil {\n\t\treturn nil\n\t}\n\treturn p.OnPostReg(handler)\n}\n\n// PostListen is called after a listener is created.\nfunc (p *PluginImpl) PostListen(addr net.Addr) error {\n\tif p.OnPostListen == nil {\n\t\treturn nil\n\t}\n\treturn p.OnPostListen(addr)\n}\n\n// PreDial is called before a dial is created.\nfunc (p *PluginImpl) PreDial(localAddr net.Addr, remoteAddr string) *Status {\n\tif p.OnPreDial == nil {\n\t\treturn nil\n\t}\n\treturn p.OnPreDial(localAddr, remoteAddr)\n}\n\n// PostDial is called after a dial is created.\nfunc (p *PluginImpl) PostDial(sess PreSession, isRedial bool) *Status {\n\tif p.OnPostDial == nil {\n\t\treturn nil\n\t}\n\treturn p.OnPostDial(sess, isRedial)\n}\n\n// PostAccept is called after a session is accepted.\nfunc (p *PluginImpl) PostAccept(sess PreSession) *Status {\n\tif p.OnPostAccept == nil {\n\t\treturn nil\n\t}\n\treturn p.OnPostAccept(sess)\n}\n\n// PreWriteCall is called before a call is written.\nfunc (p *PluginImpl) PreWriteCall(writeCtx WriteCtx) *Status {\n\tif p.OnPreWriteCall == nil {\n\t\treturn nil\n\t}\n\treturn p.OnPreWriteCall(writeCtx)\n}\n\n// PostWriteCall is called after a call is written.\nfunc (p *PluginImpl) PostWriteCall(writeCtx WriteCtx) *Status {\n\tif p.OnPostWriteCall == nil {\n\t\treturn nil\n\t}\n\treturn p.OnPostWriteCall(writeCtx)\n}\n\n// PreWriteReply is called before a reply is written.\nfunc (p *PluginImpl) PreWriteReply(writeCtx WriteCtx) *Status {\n\tif p.OnPreWriteReply == nil {\n\t\treturn nil\n\t}\n\treturn p.OnPreWriteReply(writeCtx)\n}\n\n// PostWriteReply is called after a reply is written.\nfunc (p *PluginImpl) PostWriteReply(writeCtx WriteCtx) *Status {\n\tif p.OnPostWriteReply == nil {\n\t\treturn nil\n\t}\n\treturn p.OnPostWriteReply(writeCtx)\n}\n\n// PreWritePush is called before a push is written.\nfunc (p *PluginImpl) PreWritePush(writeCtx WriteCtx) *Status {\n\tif p.OnPreWritePush == nil {\n\t\treturn nil\n\t}\n\treturn p.OnPreWritePush(writeCtx)\n}\n\n// PostWritePush is called after a push is written.\nfunc (p *PluginImpl) PostWritePush(writeCtx WriteCtx) *Status {\n\tif p.OnPostWritePush == nil {\n\t\treturn nil\n\t}\n\treturn p.OnPostWritePush(writeCtx)\n}\n\n// PreReadHeader is called before a header is read.\nfunc (p *PluginImpl) PreReadHeader(preCtx PreCtx) error {\n\tif p.OnPreReadHeader == nil {\n\t\treturn nil\n\t}\n\treturn p.OnPreReadHeader(preCtx)\n}\n\n// PostReadCallHeader is called after a call header is read.\nfunc (p *PluginImpl) PostReadCallHeader(readCtx ReadCtx) *Status {\n\tif p.OnPostReadCallHeader == nil {\n\t\treturn nil\n\t}\n\treturn p.OnPostReadCallHeader(readCtx)\n}\n\n// PreReadCallBody is called before a call body is read.\nfunc (p *PluginImpl) PreReadCallBody(readCtx ReadCtx) *Status {\n\tif p.OnPreReadCallBody == nil {\n\t\treturn nil\n\t}\n\treturn p.OnPreReadCallBody(readCtx)\n}\n\n// PostReadCallBody is called after a call body is read.\nfunc (p *PluginImpl) PostReadCallBody(readCtx ReadCtx) *Status {\n\tif p.OnPostReadCallBody == nil {\n\t\treturn nil\n\t}\n\treturn p.OnPostReadCallBody(readCtx)\n}\n\n// PostReadPushHeader is called after a push header is read.\nfunc (p *PluginImpl) PostReadPushHeader(readCtx ReadCtx) *Status {\n\tif p.OnPostReadPushHeader == nil {\n\t\treturn nil\n\t}\n\treturn p.OnPostReadPushHeader(readCtx)\n}\n\n// PreReadPushBody is called before a push body is read.\nfunc (p *PluginImpl) PreReadPushBody(readCtx ReadCtx) *Status {\n\tif p.OnPreReadPushBody == nil {\n\t\treturn nil\n\t}\n\treturn p.OnPreReadPushBody(readCtx)\n}\n\n// PostReadPushBody is called after a push body is read.\nfunc (p *PluginImpl) PostReadPushBody(readCtx ReadCtx) *Status {\n\tif p.OnPostReadPushBody == nil {\n\t\treturn nil\n\t}\n\treturn p.OnPostReadPushBody(readCtx)\n}\n\n// PostReadReplyHeader is called after a reply header is read.\nfunc (p *PluginImpl) PostReadReplyHeader(readCtx ReadCtx) *Status {\n\tif p.OnPostReadReplyHeader == nil {\n\t\treturn nil\n\t}\n\treturn p.OnPostReadReplyHeader(readCtx)\n}\n\n// PreReadReplyBody is called before a reply body is read.\nfunc (p *PluginImpl) PreReadReplyBody(readCtx ReadCtx) *Status {\n\tif p.OnPreReadReplyBody == nil {\n\t\treturn nil\n\t}\n\treturn p.OnPreReadReplyBody(readCtx)\n}\n\n// PostReadReplyBody is called after a reply body is read.\nfunc (p *PluginImpl) PostReadReplyBody(readCtx ReadCtx) *Status {\n\tif p.OnPostReadReplyBody == nil {\n\t\treturn nil\n\t}\n\treturn p.OnPostReadReplyBody(readCtx)\n}\n\n// PostDisconnect is called after a session is disconnected.\nfunc (p *PluginImpl) PostDisconnect(sess BaseSession) *Status {\n\tif p.OnPostDisconnect == nil {\n\t\treturn nil\n\t}\n\treturn p.OnPostDisconnect(sess)\n}\n"
        },
        {
          "name": "proto",
          "type": "tree",
          "content": null
        },
        {
          "name": "quic",
          "type": "tree",
          "content": null
        },
        {
          "name": "router.go",
          "type": "blob",
          "size": 28.5908203125,
          "content": "// Copyright 2015-2019 HenryLee. All Rights Reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage erpc\n\nimport (\n\t\"fmt\"\n\t\"path\"\n\t\"reflect\"\n\t\"runtime\"\n\t\"strings\"\n\t\"sync\"\n\t\"unsafe\"\n\n\t\"github.com/andeya/goutil\"\n)\n\n// ServiceMethodMapper mapper service method from prefix, recvName and funcName.\n// NOTE:\n//\n//\t@prefix is optional;\n//\t@name is required.\ntype ServiceMethodMapper func(prefix, name string) (serviceMethod string)\n\n// SetServiceMethodMapper customizes your own service method mapper.\nfunc SetServiceMethodMapper(mapper ServiceMethodMapper) {\n\tglobalServiceMethodMapper = mapper\n}\n\n// HTTPServiceMethodMapper like the service method mapper for most RPC servers.\n// Such as: user/get\n// It is the default mapper.\n// The mapping rule of struct(func) name to service methods:\n//\n//\t`AaBb` -> `/aa_bb`\n//\t`ABcXYz` -> `/abc_xyz`\n//\t`Aa__Bb` -> `/aa_bb`\n//\t`aa__bb` -> `/aa_bb`\n//\t`ABC__XYZ` -> `/abc_xyz`\n//\t`Aa_Bb` -> `/aa/bb`\n//\t`aa_bb` -> `/aa/bb`\n//\t`ABC_XYZ` -> `/abc/xyz`\nfunc HTTPServiceMethodMapper(prefix, name string) string {\n\treturn path.Join(\"/\", prefix, toServiceMethods(name, '/', true))\n}\n\n// RPCServiceMethodMapper like the service method mapper for most RPC servers.\n// Such as: User.Get\n// The mapping rule of struct(func) name to service methods:\n//\n//\t`AaBb` -> `AaBb`\n//\t`ABcXYz` -> `ABcXYz`\n//\t`Aa__Bb` -> `Aa_Bb`\n//\t`aa__bb` -> `aa_bb`\n//\t`ABC__XYZ` -> `ABC_XYZ`\n//\t`Aa_Bb` -> `Aa.Bb`\n//\t`aa_bb` -> `aa.bb`\n//\t`ABC_XYZ` -> `ABC.XYZ`\nfunc RPCServiceMethodMapper(prefix, name string) string {\n\tp := prefix + \".\" + toServiceMethods(name, '.', false)\n\treturn strings.Trim(p, \".\")\n}\n\n// toServiceMethods maps struct(func) name to service methods.\nfunc toServiceMethods(name string, sep rune, toSnake bool) string {\n\tvar a = []rune{}\n\tvar last rune\n\tfor _, r := range name {\n\t\tif last == '_' {\n\t\t\tif r == '_' {\n\t\t\t\tlast = '\\x00'\n\t\t\t\tcontinue\n\t\t\t} else {\n\t\t\t\ta[len(a)-1] = sep\n\t\t\t}\n\t\t}\n\t\tif last == '\\x00' && r == '_' {\n\t\t\tcontinue\n\t\t}\n\t\ta = append(a, r)\n\t\tlast = r\n\t}\n\tname = string(a)\n\tif toSnake {\n\t\tname = goutil.SnakeString(name)\n\t\tname = strings.Replace(name, \"__\", \"_\", -1)\n\t\tname = strings.Replace(name, string(sep)+\"_\", string(sep), -1)\n\t}\n\treturn name\n}\n\n/**\n * Router the router of call or push handlers.\n *\n * 1. Call-Controller-Struct API template\n *\n *  type Aaa struct {\n *      erpc.CallCtx\n *  }\n *  func (x *Aaa) XxZz(arg *<T>) (<T>, *erpc.Status) {\n *      ...\n *      return r, nil\n *  }\n *\n * - register it to root router:\n *\n *  // register the call route: /aaa/xx_zz\n *  peer.RouteCall(new(Aaa))\n *\n *  // or register the call route: /xx_zz\n *  peer.RouteCallFunc((*Aaa).XxZz)\n *\n * 2. Call-Handler-Function API template\n *\n *  func XxZz(ctx erpc.CallCtx, arg *<T>) (<T>, *erpc.Status) {\n *      ...\n *      return r, nil\n *  }\n *\n * - register it to root router:\n *\n *  // register the call route: /xx_zz\n *  peer.RouteCallFunc(XxZz)\n *\n * 3. Push-Controller-Struct API template\n *\n *  type Bbb struct {\n *      erpc.PushCtx\n *  }\n *  func (b *Bbb) YyZz(arg *<T>) *erpc.Status {\n *      ...\n *      return nil\n *  }\n *\n * - register it to root router:\n *\n *  // register the push route: /bbb/yy_zz\n *  peer.RoutePush(new(Bbb))\n *\n *  // or register the push route: /yy_zz\n *  peer.RoutePushFunc((*Bbb).YyZz)\n *\n * 4. Push-Handler-Function API template\n *\n *  // YyZz register the route: /yy_zz\n *  func YyZz(ctx erpc.PushCtx, arg *<T>) *erpc.Status {\n *      ...\n *      return nil\n *  }\n *\n * - register it to root router:\n *\n *  // register the push route: /yy_zz\n *  peer.RoutePushFunc(YyZz)\n *\n * 5. Unknown-Call-Handler-Function API template\n *\n *  func XxxUnknownCall (ctx erpc.UnknownCallCtx) (interface{}, *erpc.Status) {\n *      ...\n *      return r, nil\n *  }\n *\n * - register it to root router:\n *\n *  // register the unknown call route: /*\n *  peer.SetUnknownCall(XxxUnknownCall)\n *\n * 6. Unknown-Push-Handler-Function API template\n *\n *  func XxxUnknownPush(ctx erpc.UnknownPushCtx) *erpc.Status {\n *      ...\n *      return nil\n *  }\n *\n * - register it to root router:\n *\n *  // register the unknown push route: /*\n *  peer.SetUnknownPush(XxxUnknownPush)\n *\n * 7. The default mapping rule(HTTPServiceMethodMapper) of struct(func) name to service methods:\n *\n * - `AaBb` -> `/aa_bb`\n * - `ABcXYz` -> `/abc_xyz`\n * - `Aa__Bb` -> `/aa_bb`\n * - `aa__bb` -> `/aa_bb`\n * - `ABC__XYZ` -> `/abc_xyz`\n * - `Aa_Bb` -> `/aa/bb`\n * - `aa_bb` -> `/aa/bb`\n * - `ABC_XYZ` -> `/abc/xyz`\n *\n * 8. The mapping rule(RPCServiceMethodMapper) of struct(func) name to service methods:\n *\n * - `AaBb` -> `AaBb`\n * - `ABcXYz` -> `ABcXYz`\n * - `Aa__Bb` -> `Aa_Bb`\n * - `aa__bb` -> `aa_bb`\n * - `ABC__XYZ` -> `ABC_XYZ`\n * - `Aa_Bb` -> `Aa.Bb`\n * - `aa_bb` -> `aa.bb`\n * - `ABC_XYZ` -> `ABC.XYZ`\n **/\n\ntype (\n\t// Router the router of call or push handlers.\n\tRouter struct {\n\t\tsubRouter *SubRouter\n\t}\n\t// SubRouter without the SetUnknownCall and SetUnknownPush methods\n\tSubRouter struct {\n\t\troot         *Router\n\t\tcallHandlers map[string]*Handler\n\t\tpushHandlers map[string]*Handler\n\t\tunknownCall  **Handler\n\t\tunknownPush  **Handler\n\t\t// only for register router\n\t\tprefix          string\n\t\tpluginContainer *PluginContainer\n\t}\n\t// Handler call or push handler type info\n\tHandler struct {\n\t\tname              string\n\t\targElem           reflect.Type\n\t\treply             reflect.Type // only for call handler doc\n\t\thandleFunc        func(*handlerCtx, reflect.Value)\n\t\tunknownHandleFunc func(*handlerCtx)\n\t\tpluginContainer   *PluginContainer\n\t\trouterTypeName    string\n\t\tisUnknown         bool\n\t}\n\t// HandlersMaker makes []*Handler\n\tHandlersMaker func(string, interface{}, *PluginContainer) ([]*Handler, error)\n)\n\nvar globalServiceMethodMapper = HTTPServiceMethodMapper\n\nconst (\n\tpnPush        = \"PUSH\"\n\tpnCall        = \"CALL\"\n\tpnUnknownPush = \"UNKNOWN_PUSH\"\n\tpnUnknownCall = \"UNKNOWN_CALL\"\n)\n\n// newRouter creates root router.\nfunc newRouter(pluginContainer *PluginContainer) *Router {\n\trootGroup := globalServiceMethodMapper(\"\", \"\")\n\troot := &Router{\n\t\tsubRouter: &SubRouter{\n\t\t\tcallHandlers:    make(map[string]*Handler),\n\t\t\tpushHandlers:    make(map[string]*Handler),\n\t\t\tunknownCall:     new(*Handler),\n\t\t\tunknownPush:     new(*Handler),\n\t\t\tprefix:          rootGroup,\n\t\t\tpluginContainer: pluginContainer,\n\t\t},\n\t}\n\troot.subRouter.root = root\n\treturn root\n}\n\n// Root returns the root router.\nfunc (r *SubRouter) Root() *Router {\n\treturn r.root\n}\n\n// ToRouter converts to the router which is added the SetUnknownCall and SetUnknownPush methods.\nfunc (r *SubRouter) ToRouter() *Router {\n\treturn &Router{subRouter: r}\n}\n\n// SubRoute adds handler group.\nfunc (r *Router) SubRoute(prefix string, plugin ...Plugin) *SubRouter {\n\treturn r.subRouter.SubRoute(prefix, plugin...)\n}\n\n// SubRoute adds handler group.\nfunc (r *SubRouter) SubRoute(prefix string, plugin ...Plugin) *SubRouter {\n\tpluginContainer := r.pluginContainer.cloneAndAppendMiddle(plugin...)\n\twarnInvalidHandlerHooks(plugin)\n\treturn &SubRouter{\n\t\troot:            r.root,\n\t\tcallHandlers:    r.callHandlers,\n\t\tpushHandlers:    r.pushHandlers,\n\t\tunknownCall:     r.unknownCall,\n\t\tunknownPush:     r.unknownPush,\n\t\tprefix:          globalServiceMethodMapper(r.prefix, prefix),\n\t\tpluginContainer: pluginContainer,\n\t}\n}\n\n// RouteCall registers CALL handlers, and returns the paths.\nfunc (r *Router) RouteCall(callCtrlStruct interface{}, plugin ...Plugin) []string {\n\treturn r.subRouter.RouteCall(callCtrlStruct, plugin...)\n}\n\n// RouteCall registers CALL handlers, and returns the paths.\nfunc (r *SubRouter) RouteCall(callCtrlStruct interface{}, plugin ...Plugin) []string {\n\treturn r.reg(pnCall, makeCallHandlersFromStruct, callCtrlStruct, plugin)\n}\n\n// RouteCallFunc registers CALL handler, and returns the path.\nfunc (r *Router) RouteCallFunc(callHandleFunc interface{}, plugin ...Plugin) string {\n\treturn r.subRouter.RouteCallFunc(callHandleFunc, plugin...)\n}\n\n// RouteCallFunc registers CALL handler, and returns the path.\nfunc (r *SubRouter) RouteCallFunc(callHandleFunc interface{}, plugin ...Plugin) string {\n\treturn r.reg(pnCall, makeCallHandlersFromFunc, callHandleFunc, plugin)[0]\n}\n\n// RoutePush registers PUSH handlers, and returns the paths.\nfunc (r *Router) RoutePush(pushCtrlStruct interface{}, plugin ...Plugin) []string {\n\treturn r.subRouter.RoutePush(pushCtrlStruct, plugin...)\n}\n\n// RoutePush registers PUSH handlers, and returns the paths.\nfunc (r *SubRouter) RoutePush(pushCtrlStruct interface{}, plugin ...Plugin) []string {\n\treturn r.reg(pnPush, makePushHandlersFromStruct, pushCtrlStruct, plugin)\n}\n\n// RoutePushFunc registers PUSH handler, and returns the path.\nfunc (r *Router) RoutePushFunc(pushHandleFunc interface{}, plugin ...Plugin) string {\n\treturn r.subRouter.RoutePushFunc(pushHandleFunc, plugin...)\n}\n\n// RoutePushFunc registers PUSH handler, and returns the path.\nfunc (r *SubRouter) RoutePushFunc(pushHandleFunc interface{}, plugin ...Plugin) string {\n\treturn r.reg(pnPush, makePushHandlersFromFunc, pushHandleFunc, plugin)[0]\n}\n\nfunc (r *SubRouter) reg(\n\trouterTypeName string,\n\thandlerMaker func(string, interface{}, *PluginContainer) ([]*Handler, error),\n\tctrlStruct interface{},\n\tplugins []Plugin,\n) []string {\n\tpluginContainer := r.pluginContainer.cloneAndAppendMiddle(plugins...)\n\twarnInvalidHandlerHooks(plugins)\n\thandlers, err := handlerMaker(\n\t\tr.prefix,\n\t\tctrlStruct,\n\t\tpluginContainer,\n\t)\n\tif err != nil {\n\t\tFatalf(\"%v\", err)\n\t}\n\tvar names []string\n\tvar hadHandlers map[string]*Handler\n\tif routerTypeName == pnCall {\n\t\thadHandlers = r.callHandlers\n\t} else {\n\t\thadHandlers = r.pushHandlers\n\t}\n\tfor _, h := range handlers {\n\t\tif _, ok := hadHandlers[h.name]; ok {\n\t\t\tFatalf(\"there is a handler conflict: %s\", h.name)\n\t\t}\n\t\th.routerTypeName = routerTypeName\n\t\thadHandlers[h.name] = h\n\t\tpluginContainer.postReg(h)\n\t\tPrintf(\"register %s handler: %s\", routerTypeName, h.name)\n\t\tnames = append(names, h.name)\n\t}\n\treturn names\n}\n\n// SetUnknownCall sets the default handler,\n// which is called when no handler for CALL is found.\nfunc (r *Router) SetUnknownCall(fn func(UnknownCallCtx) (interface{}, *Status), plugin ...Plugin) {\n\tpluginContainer := r.subRouter.pluginContainer.cloneAndAppendMiddle(plugin...)\n\twarnInvalidHandlerHooks(plugin)\n\n\tvar h = &Handler{\n\t\tname:            pnUnknownCall,\n\t\tisUnknown:       true,\n\t\targElem:         reflect.TypeOf([]byte{}),\n\t\tpluginContainer: pluginContainer,\n\t\tunknownHandleFunc: func(ctx *handlerCtx) {\n\t\t\tbody, stat := fn(ctx)\n\t\t\tif !stat.OK() {\n\t\t\t\tctx.stat = stat\n\t\t\t\tctx.output.SetStatus(stat)\n\t\t\t} else {\n\t\t\t\tctx.output.SetBody(body)\n\t\t\t}\n\t\t},\n\t}\n\n\tif *r.subRouter.unknownCall == nil {\n\t\tPrintf(\"set %s handler\", h.name)\n\t} else {\n\t\tWarnf(\"covered %s handler\", h.name)\n\t}\n\tr.subRouter.unknownCall = &h\n}\n\n// SetUnknownPush sets the default handler,\n// which is called when no handler for PUSH is found.\nfunc (r *Router) SetUnknownPush(fn func(UnknownPushCtx) *Status, plugin ...Plugin) {\n\tpluginContainer := r.subRouter.pluginContainer.cloneAndAppendMiddle(plugin...)\n\twarnInvalidHandlerHooks(plugin)\n\n\tvar h = &Handler{\n\t\tname:            pnUnknownPush,\n\t\tisUnknown:       true,\n\t\targElem:         reflect.TypeOf([]byte{}),\n\t\tpluginContainer: pluginContainer,\n\t\tunknownHandleFunc: func(ctx *handlerCtx) {\n\t\t\tctx.stat = fn(ctx)\n\t\t},\n\t}\n\n\tif *r.subRouter.unknownPush == nil {\n\t\tPrintf(\"set %s handler\", h.name)\n\t} else {\n\t\tWarnf(\"covered %s handler\", h.name)\n\t}\n\tr.subRouter.unknownPush = &h\n}\n\nfunc (r *SubRouter) getCall(uriPath string) (*Handler, bool) {\n\tt, ok := r.callHandlers[uriPath]\n\tif ok {\n\t\treturn t, true\n\t}\n\tif unknown := *r.unknownCall; unknown != nil {\n\t\treturn unknown, true\n\t}\n\treturn nil, false\n}\n\nfunc (r *SubRouter) getPush(uriPath string) (*Handler, bool) {\n\tt, ok := r.pushHandlers[uriPath]\n\tif ok {\n\t\treturn t, true\n\t}\n\tif unknown := *r.unknownPush; unknown != nil {\n\t\treturn unknown, true\n\t}\n\treturn nil, false\n}\n\ntype (\n\t// CtrlStructPtr should be a struct pointer that contains handler methods.\n\tCtrlStructPtr interface{}\n\n\t// CtrlPoolFunc new a struct pointer for controller pool.\n\tCtrlPoolFunc = func() CtrlStructPtr\n)\n\nfunc resolveCtrlStructOrPoolFunc(ctrlStructOrPoolFunc interface{}) (ctlPtrBuilder func() reflect.Value, err error) {\n\tbuilder, isCtrlBuilder := ctrlStructOrPoolFunc.(CtrlPoolFunc)\n\tif isCtrlBuilder {\n\t\tctlPtrBuilder = func() reflect.Value {\n\t\t\treturn reflect.ValueOf(builder())\n\t\t}\n\t} else {\n\t\tctrlValue := reflect.ValueOf(ctrlStructOrPoolFunc)\n\t\tfor ctrlValue.Kind() == reflect.Ptr {\n\t\t\tctrlValue = ctrlValue.Elem()\n\t\t}\n\t\tctrlType := ctrlValue.Type()\n\t\tctlPtrBuilder = func() reflect.Value {\n\t\t\treturn reflect.New(ctrlType)\n\t\t}\n\t}\n\tctrlValue := ctlPtrBuilder()\n\tif ctrlValue.Kind() != reflect.Ptr {\n\t\treturn nil, fmt.Errorf(\"ctrlStruct is not struct pointer: %s\", ctrlValue.Type().Name())\n\t}\n\tctrlValue = ctrlValue.Elem()\n\tif ctrlValue.Kind() != reflect.Struct {\n\t\treturn nil, fmt.Errorf(\"ctrlStruct is not struct pointer: %s\", ctrlValue.Type().Name())\n\t}\n\treturn ctlPtrBuilder, nil\n}\n\n// NOTE: callCtrlStruct needs to implement CallCtx interface.\nfunc makeCallHandlersFromStruct(prefix string, callCtrlStructOrPoolFunc interface{}, pluginContainer *PluginContainer) ([]*Handler, error) {\n\tif pluginContainer == nil {\n\t\tpluginContainer = newPluginContainer()\n\t}\n\tvar handlers = make([]*Handler, 0, 1)\n\n\tvar ctlPtrBuilder, err = resolveCtrlStructOrPoolFunc(callCtrlStructOrPoolFunc)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"call-handler: %w\", err)\n\t}\n\tvar ctype = ctlPtrBuilder().Type()\n\tiType, ok := ctype.Elem().FieldByName(\"CallCtx\")\n\tif !ok || !iType.Anonymous {\n\t\treturn nil, fmt.Errorf(\"call-handler: the struct do not have anonymous field erpc.CallCtx: %s\", ctype.String())\n\t}\n\n\tvar callCtxOffset = iType.Offset\n\n\ttype CallCtrlValue struct {\n\t\tctrl   reflect.Value\n\t\tctxPtr *CallCtx\n\t}\n\tvar pool = &sync.Pool{\n\t\tNew: func() interface{} {\n\t\t\tctrl := ctlPtrBuilder()\n\t\t\treturn &CallCtrlValue{\n\t\t\t\tctrl:   ctrl,\n\t\t\t\tctxPtr: (*CallCtx)(unsafe.Pointer(ctrl.Pointer() + callCtxOffset)),\n\t\t\t}\n\t\t},\n\t}\n\n\tfor m := 0; m < ctype.NumMethod(); m++ {\n\t\tmethod := ctype.Method(m)\n\t\t// Skip private methods and methods inherited from composition.\n\t\tif method.PkgPath != \"\" || goutil.IsCompositionMethod(method) {\n\t\t\tcontinue\n\t\t}\n\t\tmtype := method.Type\n\t\tmname := method.Name\n\t\t// Method needs two ins: receiver, *<T>.\n\t\tif mtype.NumIn() != 2 {\n\t\t\treturn nil, fmt.Errorf(\"call-handler: %s.%s needs one in argument, but have %d\", ctype.String(), mname, mtype.NumIn())\n\t\t}\n\t\t// Receiver need be a struct pointer.\n\t\tstructType := mtype.In(0)\n\t\tif structType.Kind() != reflect.Ptr || structType.Elem().Kind() != reflect.Struct {\n\t\t\treturn nil, fmt.Errorf(\"call-handler: %s.%s receiver need be a struct pointer: %s\", ctype.String(), mname, structType)\n\t\t}\n\t\t// First arg need be exported or builtin, and need be a pointer.\n\t\targType := mtype.In(1)\n\t\tif !goutil.IsExportedOrBuiltinType(argType) {\n\t\t\treturn nil, fmt.Errorf(\"call-handler: %s.%s arg type not exported: %s\", ctype.String(), mname, argType)\n\t\t}\n\t\tif argType.Kind() != reflect.Ptr {\n\t\t\treturn nil, fmt.Errorf(\"call-handler: %s.%s arg type need be a pointer: %s\", ctype.String(), mname, argType)\n\t\t}\n\t\t// Method needs two outs: reply, *Status.\n\t\tif mtype.NumOut() != 2 {\n\t\t\treturn nil, fmt.Errorf(\"call-handler: %s.%s needs two out arguments, but have %d\", ctype.String(), mname, mtype.NumOut())\n\t\t}\n\t\t// Reply type must be exported.\n\t\treplyType := mtype.Out(0)\n\t\tif !goutil.IsExportedOrBuiltinType(replyType) {\n\t\t\treturn nil, fmt.Errorf(\"call-handler: %s.%s first reply type not exported: %s\", ctype.String(), mname, replyType)\n\t\t}\n\n\t\t// The return type of the method must be *Status.\n\t\tif returnType := mtype.Out(1); !isStatusType(returnType.String()) {\n\t\t\treturn nil, fmt.Errorf(\"call-handler: %s.%s second out argument %s is not *erpc.Status\", ctype.String(), mname, returnType)\n\t\t}\n\n\t\tvar methodFunc = method.Func\n\t\tvar handleFunc = func(ctx *handlerCtx, argValue reflect.Value) {\n\t\t\tobj := pool.Get().(*CallCtrlValue)\n\t\t\t*obj.ctxPtr = ctx\n\t\t\trets := methodFunc.Call([]reflect.Value{obj.ctrl, argValue})\n\t\t\tstat := (*Status)(unsafe.Pointer(rets[1].Pointer()))\n\t\t\tif !stat.OK() {\n\t\t\t\tctx.stat = stat\n\t\t\t\tctx.output.SetStatus(stat)\n\t\t\t} else {\n\t\t\t\tctx.output.SetBody(rets[0].Interface())\n\t\t\t}\n\t\t\tpool.Put(obj)\n\t\t}\n\n\t\thandlers = append(handlers, &Handler{\n\t\t\thandleFunc:      handleFunc,\n\t\t\targElem:         argType.Elem(),\n\t\t\treply:           replyType,\n\t\t\tpluginContainer: pluginContainer,\n\t\t\tname: globalServiceMethodMapper(\n\t\t\t\tglobalServiceMethodMapper(prefix, ctrlStructName(ctype)),\n\t\t\t\tmname,\n\t\t\t),\n\t\t})\n\t}\n\treturn handlers, nil\n}\n\nfunc makeCallHandlersFromFunc(prefix string, callHandleFunc interface{}, pluginContainer *PluginContainer) ([]*Handler, error) {\n\tvar (\n\t\tctype      = reflect.TypeOf(callHandleFunc)\n\t\tcValue     = reflect.ValueOf(callHandleFunc)\n\t\ttypeString = objectName(cValue)\n\t)\n\n\tif ctype.Kind() != reflect.Func {\n\t\treturn nil, fmt.Errorf(\"call-handler: the type is not function: %s\", typeString)\n\t}\n\n\t// needs two outs: reply, *Status.\n\tif ctype.NumOut() != 2 {\n\t\treturn nil, fmt.Errorf(\"call-handler: %s needs two out arguments, but have %d\", typeString, ctype.NumOut())\n\t}\n\n\t// Reply type must be exported.\n\treplyType := ctype.Out(0)\n\tif !goutil.IsExportedOrBuiltinType(replyType) {\n\t\treturn nil, fmt.Errorf(\"call-handler: %s first reply type not exported: %s\", typeString, replyType)\n\t}\n\n\t// The return type of the method must be *Status.\n\tif returnType := ctype.Out(1); !isStatusType(returnType.String()) {\n\t\treturn nil, fmt.Errorf(\"call-handler: %s second out argument %s is not *erpc.Status\", typeString, returnType)\n\t}\n\n\t// needs two ins: CallCtx, *<T>.\n\tif ctype.NumIn() != 2 {\n\t\treturn nil, fmt.Errorf(\"call-handler: %s needs two in argument, but have %d\", typeString, ctype.NumIn())\n\t}\n\n\t// First arg need be exported or builtin, and need be a pointer.\n\targType := ctype.In(1)\n\tif !goutil.IsExportedOrBuiltinType(argType) {\n\t\treturn nil, fmt.Errorf(\"call-handler: %s arg type not exported: %s\", typeString, argType)\n\t}\n\tif argType.Kind() != reflect.Ptr {\n\t\treturn nil, fmt.Errorf(\"call-handler: %s arg type need be a pointer: %s\", typeString, argType)\n\t}\n\n\t// first agr need be a CallCtx (struct pointer or CallCtx).\n\tctxType := ctype.In(0)\n\n\tvar handleFunc func(*handlerCtx, reflect.Value)\n\n\tswitch ctxType.Kind() {\n\tdefault:\n\t\treturn nil, fmt.Errorf(\"call-handler: %s's first arg must be erpc.CallCtx type or struct pointer: %s\", typeString, ctxType)\n\n\tcase reflect.Interface:\n\t\tiface := reflect.TypeOf((*CallCtx)(nil)).Elem()\n\t\tif !ctxType.Implements(iface) ||\n\t\t\t!iface.Implements(reflect.New(ctxType).Type().Elem()) {\n\t\t\treturn nil, fmt.Errorf(\"call-handler: %s's first arg must be erpc.CallCtx type or struct pointer: %s\", typeString, ctxType)\n\t\t}\n\n\t\thandleFunc = func(ctx *handlerCtx, argValue reflect.Value) {\n\t\t\trets := cValue.Call([]reflect.Value{reflect.ValueOf(ctx), argValue})\n\t\t\tstat := (*Status)(unsafe.Pointer(rets[1].Pointer()))\n\t\t\tif !stat.OK() {\n\t\t\t\tctx.stat = stat\n\t\t\t\tctx.output.SetStatus(stat)\n\t\t\t} else {\n\t\t\t\tctx.output.SetBody(rets[0].Interface())\n\t\t\t}\n\t\t}\n\n\tcase reflect.Ptr:\n\t\tvar ctxTypeElem = ctxType.Elem()\n\t\tif ctxTypeElem.Kind() != reflect.Struct {\n\t\t\treturn nil, fmt.Errorf(\"call-handler: %s's first arg must be erpc.CallCtx type or struct pointer: %s\", typeString, ctxType)\n\t\t}\n\n\t\tiType, ok := ctxTypeElem.FieldByName(\"CallCtx\")\n\t\tif !ok || !iType.Anonymous {\n\t\t\treturn nil, fmt.Errorf(\"call-handler: %s's first arg do not have anonymous field erpc.CallCtx: %s\", typeString, ctxType)\n\t\t}\n\n\t\ttype CallCtrlValue struct {\n\t\t\tctrl   reflect.Value\n\t\t\tctxPtr *CallCtx\n\t\t}\n\t\tvar callCtxOffset = iType.Offset\n\t\tvar pool = &sync.Pool{\n\t\t\tNew: func() interface{} {\n\t\t\t\tctrl := reflect.New(ctxTypeElem)\n\t\t\t\treturn &CallCtrlValue{\n\t\t\t\t\tctrl:   ctrl,\n\t\t\t\t\tctxPtr: (*CallCtx)(unsafe.Pointer(uintptr(unsafe.Pointer(ctrl.Pointer())) + callCtxOffset)),\n\t\t\t\t}\n\t\t\t},\n\t\t}\n\n\t\thandleFunc = func(ctx *handlerCtx, argValue reflect.Value) {\n\t\t\tobj := pool.Get().(*CallCtrlValue)\n\t\t\t*obj.ctxPtr = ctx\n\t\t\trets := cValue.Call([]reflect.Value{obj.ctrl, argValue})\n\t\t\tstat := (*Status)(unsafe.Pointer(rets[1].Pointer()))\n\t\t\tif !stat.OK() {\n\t\t\t\tctx.stat = stat\n\t\t\t\tctx.output.SetStatus(stat)\n\t\t\t} else {\n\t\t\t\tctx.output.SetBody(rets[0].Interface())\n\t\t\t}\n\t\t\tpool.Put(obj)\n\t\t}\n\t}\n\n\tif pluginContainer == nil {\n\t\tpluginContainer = newPluginContainer()\n\t}\n\treturn []*Handler{{\n\t\tname:            globalServiceMethodMapper(prefix, handlerFuncName(cValue)),\n\t\thandleFunc:      handleFunc,\n\t\targElem:         argType.Elem(),\n\t\treply:           replyType,\n\t\tpluginContainer: pluginContainer,\n\t}}, nil\n}\n\n// NOTE: pushCtrlStruct needs to implement PushCtx interface.\nfunc makePushHandlersFromStruct(prefix string, pushCtrlStructOrPoolFunc interface{}, pluginContainer *PluginContainer) ([]*Handler, error) {\n\tif pluginContainer == nil {\n\t\tpluginContainer = newPluginContainer()\n\t}\n\tvar handlers = make([]*Handler, 0, 1)\n\n\tvar ctlPtrBuilder, err = resolveCtrlStructOrPoolFunc(pushCtrlStructOrPoolFunc)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"push-handler: %w\", err)\n\t}\n\tvar ctype = ctlPtrBuilder().Type()\n\tiType, ok := ctype.Elem().FieldByName(\"PushCtx\")\n\tif !ok || !iType.Anonymous {\n\t\treturn nil, fmt.Errorf(\"push-handler: the struct do not have anonymous field erpc.PushCtx: %s\", ctype.String())\n\t}\n\n\tvar pushCtxOffset = iType.Offset\n\n\tif pluginContainer == nil {\n\t\tpluginContainer = newPluginContainer()\n\t}\n\ttype PushCtrlValue struct {\n\t\tctrl   reflect.Value\n\t\tctxPtr *PushCtx\n\t}\n\tvar pool = &sync.Pool{\n\t\tNew: func() interface{} {\n\t\t\tctrl := ctlPtrBuilder()\n\t\t\treturn &PushCtrlValue{\n\t\t\t\tctrl:   ctrl,\n\t\t\t\tctxPtr: (*PushCtx)(unsafe.Pointer(ctrl.Pointer() + pushCtxOffset)),\n\t\t\t}\n\t\t},\n\t}\n\tfor m := 0; m < ctype.NumMethod(); m++ {\n\t\tmethod := ctype.Method(m)\n\t\t// Skip private methods and methods inherited from composition.\n\t\tif method.PkgPath != \"\" || goutil.IsCompositionMethod(method) {\n\t\t\tcontinue\n\t\t}\n\t\tmtype := method.Type\n\t\tmname := method.Name\n\t\t// Method needs two ins: receiver, *<T>.\n\t\tif mtype.NumIn() != 2 {\n\t\t\treturn nil, fmt.Errorf(\"push-handler: %s.%s needs one in argument, but have %d\", ctype.String(), mname, mtype.NumIn())\n\t\t}\n\t\t// Receiver need be a struct pointer.\n\t\tstructType := mtype.In(0)\n\t\tif structType.Kind() != reflect.Ptr || structType.Elem().Kind() != reflect.Struct {\n\t\t\treturn nil, fmt.Errorf(\"push-handler: %s.%s receiver need be a struct pointer: %s\", ctype.String(), mname, structType)\n\t\t}\n\t\t// First arg need be exported or builtin, and need be a pointer.\n\t\targType := mtype.In(1)\n\t\tif !goutil.IsExportedOrBuiltinType(argType) {\n\t\t\treturn nil, fmt.Errorf(\"push-handler: %s.%s arg type not exported: %s\", ctype.String(), mname, argType)\n\t\t}\n\t\tif argType.Kind() != reflect.Ptr {\n\t\t\treturn nil, fmt.Errorf(\"push-handler: %s.%s arg type need be a pointer: %s\", ctype.String(), mname, argType)\n\t\t}\n\n\t\t// Method needs one out: *Status.\n\t\tif mtype.NumOut() != 1 {\n\t\t\treturn nil, fmt.Errorf(\"push-handler: %s.%s needs one out arguments, but have %d\", ctype.String(), mname, mtype.NumOut())\n\t\t}\n\n\t\t// The return type of the method must be *Status.\n\t\tif returnType := mtype.Out(0); !isStatusType(returnType.String()) {\n\t\t\treturn nil, fmt.Errorf(\"push-handler: %s.%s out argument %s is not *erpc.Status\", ctype.String(), mname, returnType)\n\t\t}\n\n\t\tvar methodFunc = method.Func\n\t\tvar handleFunc = func(ctx *handlerCtx, argValue reflect.Value) {\n\t\t\tobj := pool.Get().(*PushCtrlValue)\n\t\t\t*obj.ctxPtr = ctx\n\t\t\trets := methodFunc.Call([]reflect.Value{obj.ctrl, argValue})\n\t\t\tctx.stat = (*Status)(unsafe.Pointer(rets[0].Pointer()))\n\t\t\tpool.Put(obj)\n\t\t}\n\t\thandlers = append(handlers, &Handler{\n\t\t\thandleFunc:      handleFunc,\n\t\t\targElem:         argType.Elem(),\n\t\t\tpluginContainer: pluginContainer,\n\t\t\tname: globalServiceMethodMapper(\n\t\t\t\tglobalServiceMethodMapper(prefix, ctrlStructName(ctype)),\n\t\t\t\tmname,\n\t\t\t),\n\t\t})\n\t}\n\treturn handlers, nil\n}\n\nfunc makePushHandlersFromFunc(prefix string, pushHandleFunc interface{}, pluginContainer *PluginContainer) ([]*Handler, error) {\n\tvar (\n\t\tctype      = reflect.TypeOf(pushHandleFunc)\n\t\tcValue     = reflect.ValueOf(pushHandleFunc)\n\t\ttypeString = objectName(cValue)\n\t)\n\n\tif ctype.Kind() != reflect.Func {\n\t\treturn nil, fmt.Errorf(\"push-handler: the type is not function: %s\", typeString)\n\t}\n\n\t// needs one out: *Status.\n\tif ctype.NumOut() != 1 {\n\t\treturn nil, fmt.Errorf(\"push-handler: %s needs one out arguments, but have %d\", typeString, ctype.NumOut())\n\t}\n\n\t// The return type of the method must be *Status.\n\tif returnType := ctype.Out(0); !isStatusType(returnType.String()) {\n\t\treturn nil, fmt.Errorf(\"push-handler: %s out argument %s is not *erpc.Status\", typeString, returnType)\n\t}\n\n\t// needs two ins: PushCtx, *<T>.\n\tif ctype.NumIn() != 2 {\n\t\treturn nil, fmt.Errorf(\"push-handler: %s needs two in argument, but have %d\", typeString, ctype.NumIn())\n\t}\n\n\t// First arg need be exported or builtin, and need be a pointer.\n\targType := ctype.In(1)\n\tif !goutil.IsExportedOrBuiltinType(argType) {\n\t\treturn nil, fmt.Errorf(\"push-handler: %s arg type not exported: %s\", typeString, argType)\n\t}\n\tif argType.Kind() != reflect.Ptr {\n\t\treturn nil, fmt.Errorf(\"push-handler: %s arg type need be a pointer: %s\", typeString, argType)\n\t}\n\n\t// first agr need be a PushCtx (struct pointer or PushCtx).\n\tctxType := ctype.In(0)\n\n\tvar handleFunc func(*handlerCtx, reflect.Value)\n\n\tswitch ctxType.Kind() {\n\tdefault:\n\t\treturn nil, fmt.Errorf(\"push-handler: %s's first arg must be erpc.PushCtx type or struct pointer: %s\", typeString, ctxType)\n\n\tcase reflect.Interface:\n\t\tiface := reflect.TypeOf((*PushCtx)(nil)).Elem()\n\t\tif !ctxType.Implements(iface) ||\n\t\t\t!iface.Implements(reflect.New(ctxType).Type().Elem()) {\n\t\t\treturn nil, fmt.Errorf(\"push-handler: %s's first arg need implement erpc.PushCtx: %s\", typeString, ctxType)\n\t\t}\n\n\t\thandleFunc = func(ctx *handlerCtx, argValue reflect.Value) {\n\t\t\trets := cValue.Call([]reflect.Value{reflect.ValueOf(ctx), argValue})\n\t\t\tctx.stat = (*Status)(unsafe.Pointer(rets[0].Pointer()))\n\t\t}\n\n\tcase reflect.Ptr:\n\t\tvar ctxTypeElem = ctxType.Elem()\n\t\tif ctxTypeElem.Kind() != reflect.Struct {\n\t\t\treturn nil, fmt.Errorf(\"push-handler: %s's first arg must be erpc.PushCtx type or struct pointer: %s\", typeString, ctxType)\n\t\t}\n\n\t\tiType, ok := ctxTypeElem.FieldByName(\"PushCtx\")\n\t\tif !ok || !iType.Anonymous {\n\t\t\treturn nil, fmt.Errorf(\"push-handler: %s's first arg do not have anonymous field erpc.PushCtx: %s\", typeString, ctxType)\n\t\t}\n\n\t\ttype PushCtrlValue struct {\n\t\t\tctrl   reflect.Value\n\t\t\tctxPtr *PushCtx\n\t\t}\n\t\tvar pushCtxOffset = iType.Offset\n\t\tvar pool = &sync.Pool{\n\t\t\tNew: func() interface{} {\n\t\t\t\tctrl := reflect.New(ctxTypeElem)\n\t\t\t\treturn &PushCtrlValue{\n\t\t\t\t\tctrl:   ctrl,\n\t\t\t\t\tctxPtr: (*PushCtx)(unsafe.Pointer(uintptr(unsafe.Pointer(ctrl.Pointer())) + pushCtxOffset)),\n\t\t\t\t}\n\t\t\t},\n\t\t}\n\n\t\thandleFunc = func(ctx *handlerCtx, argValue reflect.Value) {\n\t\t\tobj := pool.Get().(*PushCtrlValue)\n\t\t\t*obj.ctxPtr = ctx\n\t\t\trets := cValue.Call([]reflect.Value{obj.ctrl, argValue})\n\t\t\tctx.stat = (*Status)(unsafe.Pointer(rets[0].Pointer()))\n\t\t\tpool.Put(obj)\n\t\t}\n\t}\n\n\tif pluginContainer == nil {\n\t\tpluginContainer = newPluginContainer()\n\t}\n\treturn []*Handler{{\n\t\tname:            globalServiceMethodMapper(prefix, handlerFuncName(cValue)),\n\t\thandleFunc:      handleFunc,\n\t\targElem:         argType.Elem(),\n\t\tpluginContainer: pluginContainer,\n\t}}, nil\n}\n\nfunc isStatusType(s string) bool {\n\treturn strings.HasPrefix(s, \"*\") && strings.HasSuffix(s, \".Status\")\n}\n\nfunc ctrlStructName(ctype reflect.Type) string {\n\tsplit := strings.Split(ctype.String(), \".\")\n\treturn split[len(split)-1]\n}\n\nfunc handlerFuncName(v reflect.Value) string {\n\tstr := objectName(v)\n\tsplit := strings.Split(str, \".\")\n\treturn split[len(split)-1]\n}\n\nfunc objectName(v reflect.Value) string {\n\tt := v.Type()\n\tif t.Kind() == reflect.Func {\n\t\treturn runtime.FuncForPC(v.Pointer()).Name()\n\t}\n\treturn t.String()\n}\n\n// Name returns the handler name.\nfunc (h *Handler) Name() string {\n\treturn h.name\n}\n\n// ArgElemType returns the handler arg elem type.\nfunc (h *Handler) ArgElemType() reflect.Type {\n\treturn h.argElem\n}\n\n// NewArgValue creates a new arg elem value.\nfunc (h *Handler) NewArgValue() reflect.Value {\n\treturn reflect.New(h.argElem)\n}\n\n// ReplyType returns the handler reply type\nfunc (h *Handler) ReplyType() reflect.Type {\n\treturn h.reply\n}\n\n// IsCall checks if it is call handler or not.\nfunc (h *Handler) IsCall() bool {\n\treturn h.routerTypeName == pnCall || h.routerTypeName == pnUnknownCall\n}\n\n// IsPush checks if it is push handler or not.\nfunc (h *Handler) IsPush() bool {\n\treturn h.routerTypeName == pnPush || h.routerTypeName == pnUnknownPush\n}\n\n// IsUnknown checks if it is unknown handler(call/push) or not.\nfunc (h *Handler) IsUnknown() bool {\n\treturn h.isUnknown\n}\n\n// RouterTypeName returns the router type name.\nfunc (h *Handler) RouterTypeName() string {\n\treturn h.routerTypeName\n}\n"
        },
        {
          "name": "router_test.go",
          "type": "blob",
          "size": 1.21875,
          "content": "package erpc\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n\n\t\"github.com/andeya/goutil\"\n\t\"github.com/stretchr/testify/assert\"\n)\n\ntype A struct {\n\tB\n}\n\nfunc (A) X0()  {}\nfunc (*A) X1() {}\n\ntype B struct {\n}\n\nfunc (B) Y0()  {}\nfunc (*B) Y1() {}\n\nfunc TestIsCompositionMethod(t *testing.T) {\n\tassert.False(t, goutil.IsCompositionMethod(reflect.TypeOf(A{}).Method(0)))\n\tassert.True(t, goutil.IsCompositionMethod(reflect.TypeOf(A{}).Method(1)))\n\n\tassert.False(t, goutil.IsCompositionMethod(reflect.TypeOf(&A{}).Method(0)), reflect.TypeOf(&A{}).Method(0))\n\tassert.False(t, goutil.IsCompositionMethod(reflect.TypeOf(&A{}).Method(1)))\n\tassert.True(t, goutil.IsCompositionMethod(reflect.TypeOf(&A{}).Method(2)))\n\tassert.True(t, goutil.IsCompositionMethod(reflect.TypeOf(&A{}).Method(3)))\n\n\tassert.False(t, goutil.IsCompositionMethod(reflect.TypeOf(B{}).Method(0)))\n\n\tassert.False(t, goutil.IsCompositionMethod(reflect.TypeOf(&B{}).Method(0)))\n\tassert.False(t, goutil.IsCompositionMethod(reflect.TypeOf(&B{}).Method(1)))\n}\n\nfunc TestResolveCtrlStructOrPoolFunc(t *testing.T) {\n\tbuilder, err := resolveCtrlStructOrPoolFunc(func() CtrlStructPtr { return new(A) })\n\tassert.NoError(t, err)\n\tassert.NotNil(t, builder)\n\tassert.Equal(t, reflect.TypeOf(&A{}), builder().Type())\n}\n"
        },
        {
          "name": "session.go",
          "type": "blob",
          "size": 31.1669921875,
          "content": "// Copyright 2015-2019 HenryLee. All Rights Reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage erpc\n\nimport (\n\t\"context\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"io\"\n\t\"net\"\n\t\"strconv\"\n\t\"sync\"\n\t\"sync/atomic\"\n\t\"time\"\n\n\t\"github.com/andeya/erpc/v7/codec\"\n\t\"github.com/andeya/erpc/v7/socket\"\n\t\"github.com/andeya/erpc/v7/utils\"\n\t\"github.com/andeya/goutil\"\n\t\"github.com/andeya/goutil/coarsetime\"\n)\n\ntype (\n\t// PreSession a connection session that has not started reading goroutine.\n\tPreSession interface {\n\t\t// Peer returns the peer.\n\t\tPeer() Peer\n\t\t// LocalAddr returns the local network address.\n\t\tLocalAddr() net.Addr\n\t\t// RemoteAddr returns the remote network address.\n\t\tRemoteAddr() net.Addr\n\t\t// Swap returns custom data swap of the session(socket).\n\t\tSwap() goutil.Map\n\t\t// SetID sets the session id.\n\t\tSetID(newID string)\n\t\t// ControlFD invokes f on the underlying connection's file\n\t\t// descriptor or handle.\n\t\t// The file descriptor fd is guaranteed to remain valid while\n\t\t// f executes but not after f returns.\n\t\tControlFD(f func(fd uintptr)) error\n\t\t// ModifySocket modifies the socket.\n\t\t// NOTE:\n\t\t// The connection fd is not allowed to change!\n\t\t// Inherit the previous session id and custom data swap;\n\t\t// If modifiedConn!=nil, reset the net.Conn of the socket;\n\t\t// If newProtoFunc!=nil, reset the ProtoFunc of the socket.\n\t\tModifySocket(fn func(conn net.Conn) (modifiedConn net.Conn, newProtoFunc ProtoFunc))\n\t\t// GetProtoFunc returns the ProtoFunc\n\t\tGetProtoFunc() ProtoFunc\n\t\t// PreSend temporarily sends message when the session is just builded,\n\t\t// do not execute other plugins.\n\t\t// NOTE:\n\t\t//  Cannot be called during the Non-PostDial and Non-PostAccept phase;\n\t\t//  Does not support automatic redial after disconnection;\n\t\t//  Recommend to reuse unused Message: PutMessage(input).\n\t\tPreSend(mtype byte, serviceMethod string, body interface{}, stat *Status, setting ...MessageSetting) (opStat *Status)\n\t\t// PreReceive temporarily receives message when the session is just builded,\n\t\t// do not execute other plugins.\n\t\t// NOTE:\n\t\t//  Cannot be called during the Non-PostDial and Non-PostAccept phase;\n\t\t//  Does not support automatic redial after disconnection;\n\t\t//  Recommend to reuse unused Message: PutMessage(input).\n\t\tPreReceive(newArgs NewBodyFunc, ctx ...context.Context) (input Message)\n\t\t// PreCall temporarily sends TypeCall message and receives message,\n\t\t// when the session is just builded, do not execute other plugins.\n\t\t// NOTE:\n\t\t//  Cannot be called during the Non-PostDial and Non-PostAccept phase;\n\t\t//  The reply parameter is the body receiver;\n\t\t//  The external setting seq is invalid, the internal will be forced to set;\n\t\t//  Does not support automatic redial after disconnection.\n\t\tPreCall(serviceMethod string, args, reply interface{}, callSetting ...MessageSetting) (opStat *Status)\n\t\t// PreReply temporarily sends TypeReply message when the session is just builded,\n\t\t// do not execute other plugins.\n\t\t// NOTE:\n\t\t//  Cannot be called during the Non-PostDial and Non-PostAccept phase;\n\t\t//  The external setting seq is invalid, the internal will be forced to set;\n\t\t//  Does not support automatic redial after disconnection.\n\t\tPreReply(req Message, body interface{}, stat *Status, setting ...MessageSetting) (opStat *Status)\n\t\t// RawPush sends a TypePush message without executing other plugins.\n\t\t// NOTE:\n\t\t//  The external setting seq is invalid, the internal will be forced to set;\n\t\t//  Does not support automatic redial after disconnection.\n\t\tRawPush(serviceMethod string, args interface{}, setting ...MessageSetting) (opStat *Status)\n\t\t// SessionAge returns the session max age.\n\t\tSessionAge() time.Duration\n\t\t// ContextAge returns CALL or PUSH context max age.\n\t\tContextAge() time.Duration\n\t\t// SetSessionAge sets the session max age.\n\t\tSetSessionAge(duration time.Duration)\n\t\t// SetContextAge sets CALL or PUSH context max age.\n\t\tSetContextAge(duration time.Duration)\n\t\t// Logger logger interface\n\t\tLogger\n\t}\n\t// BaseSession a connection session with the common method set.\n\tBaseSession interface {\n\t\t// Peer returns the peer.\n\t\tPeer() Peer\n\t\t// ID returns the session id.\n\t\tID() string\n\t\t// LocalAddr returns the local network address.\n\t\tLocalAddr() net.Addr\n\t\t// RemoteAddr returns the remote network address.\n\t\tRemoteAddr() net.Addr\n\t\t// Swap returns custom data swap of the session(socket).\n\t\tSwap() goutil.Map\n\t\t// Logger logger interface\n\t\tLogger\n\t}\n\t// CtxSession a connection session that can be used in the handler context.\n\tCtxSession interface {\n\t\t// ID returns the session id.\n\t\tID() string\n\t\t// LocalAddr returns the local network address.\n\t\tLocalAddr() net.Addr\n\t\t// RemoteAddr returns the remote network address.\n\t\tRemoteAddr() net.Addr\n\t\t// Swap returns custom data swap of the session(socket).\n\t\tSwap() goutil.Map\n\t\t// CloseNotify returns a channel that closes when the connection has gone away.\n\t\tCloseNotify() <-chan struct{}\n\t\t// Health checks if the session is usable.\n\t\tHealth() bool\n\t\t// AsyncCall sends a message and receives reply asynchronously.\n\t\t// If the  is []byte or *[]byte type, it can automatically fill in the body codec name.\n\t\tAsyncCall(\n\t\t\tserviceMethod string,\n\t\t\targs interface{},\n\t\t\tresult interface{},\n\t\t\tcallCmdChan chan<- CallCmd,\n\t\t\tsetting ...MessageSetting,\n\t\t) CallCmd\n\t\t// Call sends a message and receives reply.\n\t\t// NOTE:\n\t\t// If the args is []byte or *[]byte type, it can automatically fill in the body codec name;\n\t\t// If the session is a client role and PeerConfig.RedialTimes>0, it is automatically re-called once after a failure.\n\t\tCall(serviceMethod string, args interface{}, result interface{}, setting ...MessageSetting) CallCmd\n\t\t// Push sends a message of TypePush type, but do not receives reply.\n\t\t// NOTE:\n\t\t// If the args is []byte or *[]byte type, it can automatically fill in the body codec name;\n\t\t// If the session is a client role and PeerConfig.RedialTimes>0, it is automatically re-called once after a failure.\n\t\tPush(serviceMethod string, args interface{}, setting ...MessageSetting) *Status\n\t\t// SessionAge returns the session max age.\n\t\tSessionAge() time.Duration\n\t\t// ContextAge returns CALL or PUSH context max age.\n\t\tContextAge() time.Duration\n\t\t// Logger logger interface\n\t\tLogger\n\t}\n\t// Session a connection session.\n\tSession interface {\n\t\t// Peer returns the peer.\n\t\tPeer() Peer\n\t\t// SetID sets the session id.\n\t\tSetID(newID string)\n\t\t// Close closes the session.\n\t\tClose() error\n\t\tCtxSession\n\t}\n)\n\nvar (\n\t_ PreSession  = new(session)\n\t_ BaseSession = new(session)\n\t_ CtxSession  = new(session)\n\t_ Session     = new(session)\n)\n\ntype session struct {\n\tpeer                           *peer\n\tgetCallHandler, getPushHandler func(serviceMethodPath string) (*Handler, bool)\n\ttimeNow                        func() int64\n\tcallCmdMap                     goutil.Map\n\tprotoFuncs                     []ProtoFunc\n\tsocket                         socket.Socket\n\tcloseNotifyCh                  chan struct{} // closeNotifyCh is the channel returned by CloseNotify.\n\twriteLock                      sync.Mutex\n\tgraceCtxWaitGroup              sync.WaitGroup\n\tgraceCtxMutex                  sync.Mutex\n\tgraceCallCmdWaitGroup          sync.WaitGroup\n\tsessionAge                     time.Duration\n\tcontextAge                     time.Duration\n\tsessionAgeLock                 sync.RWMutex\n\tcontextAgeLock                 sync.RWMutex\n\tlock                           sync.RWMutex\n\tredialForClientLocked          func() bool // only for client role\n\tseq                            int32\n\tstatus                         int32\n\tdidCloseNotify                 int32\n}\n\nfunc newSession(peer *peer, conn net.Conn, protoFuncs []ProtoFunc) *session {\n\tvar s = &session{\n\t\tpeer:           peer,\n\t\tgetCallHandler: peer.router.subRouter.getCall,\n\t\tgetPushHandler: peer.router.subRouter.getPush,\n\t\ttimeNow:        peer.timeNow,\n\t\tprotoFuncs:     protoFuncs,\n\t\tstatus:         statusPreparing,\n\t\tsocket:         socket.NewSocket(conn, protoFuncs...),\n\t\tcloseNotifyCh:  make(chan struct{}),\n\t\tcallCmdMap:     goutil.AtomicMap(),\n\t\tsessionAge:     peer.defaultSessionAge,\n\t\tcontextAge:     peer.defaultContextAge,\n\t}\n\treturn s\n}\n\n// NOTE: Do not change the order\nconst (\n\tstatusPreparing int32 = iota\n\tstatusOk\n\tstatusActiveClosing\n\tstatusActiveClosed\n\tstatusPassiveClosing\n\tstatusPassiveClosed\n\tstatusRedialing\n\tstatusRedialFailed\n)\n\nfunc (s *session) changeStatus(stat int32) {\n\tatomic.StoreInt32(&s.status, stat)\n}\n\nfunc (s *session) tryChangeStatus(to int32, fromList ...int32) (changed bool) {\n\tfor _, from := range fromList {\n\t\tif atomic.CompareAndSwapInt32(&s.status, from, to) {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\nfunc (s *session) checkStatus(checkList ...int32) bool {\n\tstat := atomic.LoadInt32(&s.status)\n\tfor _, v := range checkList {\n\t\tif v == stat {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\nfunc (s *session) getStatus() int32 {\n\treturn atomic.LoadInt32(&s.status)\n}\n\nfunc (s *session) goonRead() bool {\n\treturn s.checkStatus(statusOk, statusActiveClosing)\n}\n\nfunc (s *session) notifyClosed() {\n\tif atomic.CompareAndSwapInt32(&s.didCloseNotify, 0, 1) {\n\t\tclose(s.closeNotifyCh)\n\t}\n}\n\n// CloseNotify returns a channel that closes when the connection has gone away.\nfunc (s *session) CloseNotify() <-chan struct{} {\n\treturn s.closeNotifyCh\n}\n\n// IsActiveClosed returns whether the connection has been closed, and is actively closed.\nfunc (s *session) IsActiveClosed() bool {\n\treturn s.checkStatus(statusActiveClosed)\n}\n\n// IsPassiveClosed returns whether the connection has been closed, and is passively closed.\nfunc (s *session) IsPassiveClosed() bool {\n\treturn s.checkStatus(statusPassiveClosed)\n}\n\n// Health checks if the session is usable.\nfunc (s *session) Health() bool {\n\tstatus := s.getStatus()\n\tif status == statusOk {\n\t\treturn true\n\t}\n\tif s.redialForClientLocked == nil {\n\t\treturn false\n\t}\n\tif status == statusPassiveClosed {\n\t\treturn true\n\t}\n\treturn false\n}\n\nfunc (s *session) graceCtxWait() {\n\ts.graceCtxMutex.Lock()\n\ts.graceCtxWaitGroup.Wait()\n\ts.graceCtxMutex.Unlock()\n}\n\n// Peer returns the peer.\nfunc (s *session) Peer() Peer {\n\treturn s.peer\n}\n\n// ID returns the session id.\nfunc (s *session) ID() string {\n\treturn s.socket.ID()\n}\n\n// SetID sets the session id.\nfunc (s *session) SetID(newID string) {\n\toldID := s.ID()\n\tif oldID == newID {\n\t\treturn\n\t}\n\ts.socket.SetID(newID)\n\thub := s.peer.sessHub\n\thub.set(s)\n\thub.delete(oldID)\n\tTracef(\"session changes id: %s -> %s\", oldID, newID)\n}\n\n// ControlFD invokes f on the underlying connection's file\n// descriptor or handle.\n// The file descriptor fd is guaranteed to remain valid while\n// f executes but not after f returns.\nfunc (s *session) ControlFD(f func(fd uintptr)) error {\n\ts.lock.RLock()\n\tdefer s.lock.RUnlock()\n\treturn s.socket.ControlFD(f)\n}\n\nfunc (s *session) getConn() net.Conn {\n\treturn s.socket.Raw()\n}\n\n// ModifySocket modifies the socket.\n// NOTE:\n// The connection fd is not allowed to change!\n// Inherit the previous session id and custom data swap;\n// If modifiedConn!=nil, reset the net.Conn of the socket;\n// If newProtoFunc!=nil, reset the ProtoFunc of the socket.\nfunc (s *session) ModifySocket(fn func(conn net.Conn) (modifiedConn net.Conn, newProtoFunc ProtoFunc)) {\n\tconn := s.getConn()\n\tmodifiedConn, newProtoFunc := fn(conn)\n\tisModifiedConn := modifiedConn != nil\n\tisNewProtoFunc := newProtoFunc != nil\n\tif isNewProtoFunc {\n\t\ts.protoFuncs = s.protoFuncs[:0]\n\t\ts.protoFuncs = append(s.protoFuncs, newProtoFunc)\n\t}\n\tif !isModifiedConn && !isNewProtoFunc {\n\t\treturn\n\t}\n\tvar pub goutil.Map\n\tif s.socket.SwapLen() > 0 {\n\t\tpub = s.socket.Swap()\n\t}\n\tid := s.ID()\n\ts.socket.Reset(modifiedConn, s.protoFuncs...)\n\ts.socket.Swap(pub) // set the old swap\n\ts.socket.SetID(id)\n}\n\n// GetProtoFunc returns the ProtoFunc\nfunc (s *session) GetProtoFunc() ProtoFunc {\n\tif len(s.protoFuncs) > 0 && s.protoFuncs[0] != nil {\n\t\treturn s.protoFuncs[0]\n\t}\n\treturn socket.DefaultProtoFunc()\n}\n\n// LocalAddr returns the local network address.\nfunc (s *session) LocalAddr() net.Addr {\n\treturn s.socket.LocalAddr()\n}\n\n// RemoteAddr returns the remote network address.\nfunc (s *session) RemoteAddr() net.Addr {\n\treturn s.socket.RemoteAddr()\n}\n\n// SessionAge returns the session max age.\nfunc (s *session) SessionAge() time.Duration {\n\ts.sessionAgeLock.RLock()\n\tage := s.sessionAge\n\ts.sessionAgeLock.RUnlock()\n\treturn age\n}\n\n// SetSessionAge sets the session max age.\nfunc (s *session) SetSessionAge(duration time.Duration) {\n\ts.sessionAgeLock.Lock()\n\ts.sessionAge = duration\n\tif duration > 0 {\n\t\ts.socket.SetReadDeadline(coarsetime.CeilingTimeNow().Add(duration))\n\t} else {\n\t\ts.socket.SetReadDeadline(time.Time{})\n\t}\n\ts.sessionAgeLock.Unlock()\n}\n\n// ContextAge returns CALL or PUSH context max age.\nfunc (s *session) ContextAge() time.Duration {\n\ts.contextAgeLock.RLock()\n\tage := s.contextAge\n\ts.contextAgeLock.RUnlock()\n\treturn age\n}\n\n// SetContextAge sets CALL or PUSH context max age.\nfunc (s *session) SetContextAge(duration time.Duration) {\n\ts.contextAgeLock.Lock()\n\ts.contextAge = duration\n\ts.contextAgeLock.Unlock()\n}\n\n// PreSend temporarily sends message when the session is just builded,\n// do not execute other plugins.\n// NOTE:\n//\n//\tCannot be called during the Non-PostDial and Non-PostAccept phase;\n//\tDoes not support automatic redial after disconnection;\n//\tRecommend to reuse unused Message: PutMessage(input).\nfunc (s *session) PreSend(mtype byte, serviceMethod string, body interface{}, stat *Status, setting ...MessageSetting) (opStat *Status) {\n\tif !s.checkStatus(statusPreparing) {\n\t\treturn statUnpreparedError\n\t}\n\tvar output Message\n\tdefer func() {\n\t\tif output != nil {\n\t\t\tsocket.PutMessage(output)\n\t\t}\n\t\tif p := recover(); p != nil {\n\t\t\topStat = statBadMessage.Copy(p, 3)\n\t\t}\n\t}()\n\toutput, opStat = s.send(mtype, 0, serviceMethod, body, stat, setting)\n\treturn opStat\n}\n\nfunc (s *session) send(mtype byte, seq int32, serviceMethod string, body interface{}, stat *Status, setting []MessageSetting) (Message, *Status) {\n\toutput := socket.GetMessage(setting...)\n\toutput.SetMtype(mtype)\n\tif seq == 0 {\n\t\tseq = atomic.AddInt32(&s.seq, 1)\n\t}\n\toutput.SetSeq(seq)\n\tif output.BodyCodec() == codec.NilCodecID {\n\t\toutput.SetBodyCodec(s.peer.defaultBodyCodec)\n\t}\n\tif len(serviceMethod) > 0 {\n\t\toutput.SetServiceMethod(serviceMethod)\n\t}\n\tif body != nil {\n\t\toutput.SetBody(body)\n\t}\n\tif !stat.OK() {\n\t\toutput.SetStatus(stat)\n\t}\n\treturn output, s.doSend(output)\n}\n\nfunc (s *session) doSend(output Message) *Status {\n\tif age := s.ContextAge(); age > 0 {\n\t\tctxTimout, _ := context.WithTimeout(output.Context(), age)\n\t\tsocket.WithContext(ctxTimout)(output)\n\t}\n\n\ts.writeLock.Lock()\n\tdefer s.writeLock.Unlock()\n\n\tctx := output.Context()\n\tselect {\n\tcase <-ctx.Done():\n\t\treturn statWriteFailed.Copy(ctx.Err())\n\tdefault:\n\t\tdeadline, _ := ctx.Deadline()\n\t\ts.socket.SetWriteDeadline(deadline)\n\t\terr := s.socket.WriteMessage(output)\n\t\tif err == nil {\n\t\t\treturn nil\n\t\t}\n\t\tif err == io.EOF || err == socket.ErrProactivelyCloseSocket {\n\t\t\treturn statConnClosed\n\t\t}\n\t\tDebugf(\"write error: %s\", err.Error())\n\t\treturn statWriteFailed.Copy(err)\n\t}\n}\n\nvar statUnpreparedError = statInvalidOpError.Copy(\"Cannot be called during the Non-PostDial and Non-PostAccept phase\")\n\n// PreReceive temporarily receives message when the session is just builded,\n// do not execute other plugins.\n// NOTE:\n//\n//\tCannot be called during the Non-PostDial and Non-PostAccept phase;\n//\tDoes not support automatic redial after disconnection;\n//\tRecommend to reuse unused Message: PutMessage(input).\nfunc (s *session) PreReceive(newArgs NewBodyFunc, ctx ...context.Context) (input Message) {\n\tif len(ctx) > 0 {\n\t\tinput = socket.GetMessage(WithContext(ctx[0]))\n\t} else {\n\t\tinput = socket.GetMessage()\n\t}\n\tif !s.checkStatus(statusPreparing) {\n\t\tinput.SetStatus(statUnpreparedError)\n\t\treturn input\n\t}\n\tinput.SetNewBody(newArgs)\n\tdefer func() {\n\t\tif p := recover(); p != nil {\n\t\t\tinput.SetStatus(statBadMessage.Copy(p, 3))\n\t\t}\n\t}()\n\n\tif age := s.ContextAge(); age > 0 {\n\t\tctxTimout, _ := context.WithTimeout(input.Context(), age)\n\t\tsocket.WithContext(ctxTimout)(input)\n\t}\n\tdeadline, _ := input.Context().Deadline()\n\ts.socket.SetReadDeadline(deadline)\n\n\tif err := s.socket.ReadMessage(input); err != nil {\n\t\tinput.SetStatus(statConnClosed.Copy(err))\n\t}\n\treturn input\n}\n\n// PreCall temporarily sends TypeCall message and receives message,\n// when the session is just builded, do not execute other plugins.\n// NOTE:\n//\n//\tCannot be called during the Non-PostDial and Non-PostAccept phase;\n//\tThe reply parameter is the body receiver;\n//\tThe external setting seq is invalid, the internal will be forced to set;\n//\tDoes not support automatic redial after disconnection.\nfunc (s *session) PreCall(serviceMethod string, args, reply interface{}, callSetting ...MessageSetting) (opStat *Status) {\n\tif !s.checkStatus(statusPreparing) {\n\t\treturn statUnpreparedError\n\t}\n\tdefer func() {\n\t\tif p := recover(); p != nil {\n\t\t\topStat = statBadMessage.Copy(p, 3)\n\t\t}\n\t}()\n\toutput, opStat := s.send(TypeCall, 0, serviceMethod, args, nil, callSetting)\n\tif !opStat.OK() {\n\t\tsocket.PutMessage(output)\n\t\treturn opStat\n\t}\n\tctx := output.Context()\n\tsocket.PutMessage(output)\n\treturn s.PreReceive(func(Header) interface{} { return reply }, ctx).Status()\n}\n\n// PreReply temporarily sends TypeReply message when the session is just builded,\n// do not execute other plugins.\n// NOTE:\n//\n//\tCannot be called during the Non-PostDial and Non-PostAccept phase;\n//\tThe external setting seq is invalid, the internal will be forced to set;\n//\tDoes not support automatic redial after disconnection.\nfunc (s *session) PreReply(req Message, body interface{}, stat *Status, setting ...MessageSetting) (opStat *Status) {\n\tif !s.checkStatus(statusPreparing) {\n\t\treturn statUnpreparedError\n\t}\n\tvar output Message\n\tdefer func() {\n\t\tif output != nil {\n\t\t\tsocket.PutMessage(output)\n\t\t}\n\t\tif p := recover(); p != nil {\n\t\t\topStat = statBadMessage.Copy(p, 3)\n\t\t}\n\t}()\n\toutput, opStat = s.send(TypeReply, req.Seq(), req.ServiceMethod(), body, stat, setting)\n\treturn opStat\n}\n\n// RawPush sends a TypePush message without executing other plugins.\n// NOTE:\n//\n//\tThe external setting seq is invalid, the internal will be forced to set;\n//\tDoes not support automatic redial after disconnection.\nfunc (s *session) RawPush(serviceMethod string, args interface{}, setting ...MessageSetting) (opStat *Status) {\n\tvar output Message\n\tdefer func() {\n\t\tif output != nil {\n\t\t\tsocket.PutMessage(output)\n\t\t}\n\t\tif p := recover(); p != nil {\n\t\t\topStat = statBadMessage.Copy(p, 3)\n\t\t}\n\t}()\n\toutput, opStat = s.send(TypePush, 0, serviceMethod, args, nil, setting)\n\treturn opStat\n}\n\n// Push sends a message of TypePush type, but do not receives reply.\n// NOTE:\n// If the args is []byte or *[]byte type, it can automatically fill in the body codec name;\n// If the session is a client role and PeerConfig.RedialTimes>0, it is automatically re-called once after a failure.\nfunc (s *session) Push(serviceMethod string, args interface{}, setting ...MessageSetting) *Status {\n\tctx := s.peer.getContext(s, true)\n\tdefer func() {\n\t\ts.peer.putContext(ctx, true)\n\t\tif p := recover(); p != nil {\n\t\t\tErrorf(\"panic:%v\\n%s\", p, goutil.PanicTrace(2))\n\t\t}\n\t}()\n\n\tctx.start = s.timeNow()\n\toutput := ctx.output\n\toutput.SetMtype(TypePush)\n\toutput.SetServiceMethod(serviceMethod)\n\toutput.SetBody(args)\n\n\tfor _, fn := range setting {\n\t\tif fn != nil {\n\t\t\tfn(output)\n\t\t}\n\t}\n\toutput.SetSeq(atomic.AddInt32(&s.seq, 1))\n\n\tif output.BodyCodec() == codec.NilCodecID {\n\t\toutput.SetBodyCodec(s.peer.defaultBodyCodec)\n\t}\n\tif age := s.ContextAge(); age > 0 {\n\t\tctxTimout, _ := context.WithTimeout(output.Context(), age)\n\t\tsocket.WithContext(ctxTimout)(output)\n\t}\n\n\tstat := s.peer.pluginContainer.preWritePush(ctx)\n\tif !stat.OK() {\n\t\treturn stat\n\t}\n\n\tvar usedConn net.Conn\nW:\n\tif usedConn, stat = s.write(output); !stat.OK() {\n\t\tif stat == statConnClosed && s.redialForClient(usedConn) {\n\t\t\tgoto W\n\t\t}\n\t\treturn stat\n\t}\n\tif enablePrintRunLog() {\n\t\ts.printRunLog(\"\", time.Duration(s.timeNow()-ctx.start), nil, output, typePushLaunch)\n\t}\n\ts.peer.pluginContainer.postWritePush(ctx)\n\treturn nil\n}\n\n// AsyncCall sends a message and receives reply asynchronously.\n// NOTE:\n// If the args is []byte or *[]byte type, it can automatically fill in the body codec name;\n// If the session is a client role and PeerConfig.RedialTimes>0, it is automatically re-called once after a failure.\nfunc (s *session) AsyncCall(\n\tserviceMethod string,\n\targs interface{},\n\tresult interface{},\n\tcallCmdChan chan<- CallCmd,\n\tsetting ...MessageSetting,\n) CallCmd {\n\tif callCmdChan == nil {\n\t\tcallCmdChan = make(chan CallCmd, 10) // buffered.\n\t} else {\n\t\t// If caller passes callCmdChan != nil, it must arrange that\n\t\t// callCmdChan has enough buffer for the number of simultaneous\n\t\t// RPCs that will be using that channel. If the channel\n\t\t// is totally unbuffered, it's best not to run at all.\n\t\tif cap(callCmdChan) == 0 {\n\t\t\tPanicf(\"*session.AsyncCall(): callCmdChan channel is unbuffered\")\n\t\t}\n\t}\n\toutput := socket.NewMessage()\n\toutput.SetServiceMethod(serviceMethod)\n\toutput.SetBody(args)\n\toutput.SetMtype(TypeCall)\n\tfor _, fn := range setting {\n\t\tif fn != nil {\n\t\t\tfn(output)\n\t\t}\n\t}\n\n\tseq := atomic.AddInt32(&s.seq, 1)\n\toutput.SetSeq(seq)\n\n\tif output.BodyCodec() == codec.NilCodecID {\n\t\toutput.SetBodyCodec(s.peer.defaultBodyCodec)\n\t}\n\tif age := s.ContextAge(); age > 0 {\n\t\tctxTimout, _ := context.WithTimeout(output.Context(), age)\n\t\tsocket.WithContext(ctxTimout)(output)\n\t}\n\n\tcmd := &callCmd{\n\t\tsess:        s,\n\t\toutput:      output,\n\t\tresult:      result,\n\t\tcallCmdChan: callCmdChan,\n\t\tdoneChan:    make(chan struct{}),\n\t\tstart:       s.timeNow(),\n\t\tswap:        goutil.RwMap(),\n\t}\n\n\t// count call-launch\n\ts.graceCallCmdWaitGroup.Add(1)\n\n\tif s.socket.SwapLen() > 0 {\n\t\ts.socket.Swap().Range(func(key, value interface{}) bool {\n\t\t\tcmd.swap.Store(key, value)\n\t\t\treturn true\n\t\t})\n\t}\n\n\tcmd.mu.Lock()\n\tdefer cmd.mu.Unlock()\n\n\ts.callCmdMap.Store(seq, cmd)\n\n\tdefer func() {\n\t\tif p := recover(); p != nil {\n\t\t\tErrorf(\"panic:%v\\n%s\", p, goutil.PanicTrace(2))\n\t\t}\n\t}()\n\n\tcmd.stat = s.peer.pluginContainer.preWriteCall(cmd)\n\tif !cmd.stat.OK() {\n\t\tcmd.done()\n\t\treturn cmd\n\t}\n\tvar usedConn net.Conn\nW:\n\tif usedConn, cmd.stat = s.write(output); !cmd.stat.OK() {\n\t\tif cmd.stat == statConnClosed && s.redialForClient(usedConn) {\n\t\t\tgoto W\n\t\t}\n\t\tcmd.done()\n\t\treturn cmd\n\t}\n\n\ts.peer.pluginContainer.postWriteCall(cmd)\n\treturn cmd\n}\n\n// Call sends a message and receives reply.\n// NOTE:\n// If the args is []byte or *[]byte type, it can automatically fill in the body codec name;\n// If the session is a client role and PeerConfig.RedialTimes>0, it is automatically re-called once after a failure.\nfunc (s *session) Call(serviceMethod string, args interface{}, result interface{}, setting ...MessageSetting) CallCmd {\n\tcallCmd := s.AsyncCall(serviceMethod, args, result, make(chan CallCmd, 1), setting...)\n\t<-callCmd.Done()\n\treturn callCmd\n}\n\n// Swap returns custom data swap of the session(socket).\nfunc (s *session) Swap() goutil.Map {\n\treturn s.socket.Swap()\n}\n\n// Close closes the session.\nfunc (s *session) Close() error {\n\ts.lock.Lock()\n\tdefer s.lock.Unlock()\n\treturn s.closeLocked()\n}\n\nfunc (s *session) closeLocked() error {\n\tif !s.tryChangeStatus(statusActiveClosing, statusOk, statusPreparing) {\n\t\treturn nil\n\t} // readDisconnected is being called\n\ts.peer.sessHub.delete(s.ID())\n\ts.notifyClosed()\n\ts.graceCtxWait()\n\ts.graceCallCmdWaitGroup.Wait()\n\ts.changeStatus(statusActiveClosed)\n\terr := s.socket.Close()\n\ts.peer.pluginContainer.postDisconnect(s)\n\treturn err\n}\n\nfunc (s *session) readDisconnected(oldConn net.Conn, err error) {\n\tstatus := s.getStatus()\n\tswitch status {\n\tcase statusPassiveClosed, statusActiveClosed, statusPassiveClosing:\n\t\treturn\n\tcase statusActiveClosing:\n\tdefault:\n\t\ts.changeStatus(statusPassiveClosing)\n\t}\n\n\ts.peer.sessHub.delete(s.ID())\n\n\tvar reason string\n\tif err != nil && err != socket.ErrProactivelyCloseSocket {\n\t\tif errStr := err.Error(); errStr != \"EOF\" {\n\t\t\treason = errStr\n\t\t\tDebugf(\"disconnect(%s) when reading: %T %s\", s.RemoteAddr().String(), err, errStr)\n\t\t}\n\t}\n\ts.graceCtxWait()\n\n\t// cancel the callCmd that is waiting for a reply\n\ts.callCmdMap.Range(func(_, v interface{}) bool {\n\t\tcallCmd := v.(*callCmd)\n\t\tcallCmd.mu.Lock()\n\t\tif !callCmd.hasReply() && callCmd.stat.OK() {\n\t\t\tcallCmd.cancel(reason)\n\t\t}\n\t\tcallCmd.mu.Unlock()\n\t\treturn true\n\t})\n\n\tif status == statusActiveClosing {\n\t\treturn\n\t}\n\n\ts.socket.Close()\n\tif !s.redialForClient(oldConn) {\n\t\ts.changeStatus(statusPassiveClosed)\n\t\ts.notifyClosed()\n\t\ts.peer.pluginContainer.postDisconnect(s)\n\t}\n}\n\nfunc (s *session) redialForClient(oldConn net.Conn) bool {\n\tif s.redialForClientLocked == nil {\n\t\treturn false\n\t}\n\ts.lock.Lock()\n\tdefer s.lock.Unlock()\n\t// Avoid repeated calls from write and readDisconnected methods\n\tif oldConn != s.getConn() {\n\t\treturn true\n\t}\n\tif s.tryChangeStatus(statusRedialing, statusOk, statusPassiveClosing, statusPassiveClosed, statusRedialFailed) {\n\t\treturn s.redialForClientLocked()\n\t}\n\treturn false\n}\n\nfunc (s *session) startReadAndHandle() {\n\tvar withContext MessageSetting\n\tif readTimeout := s.SessionAge(); readTimeout > 0 {\n\t\ts.socket.SetReadDeadline(coarsetime.CeilingTimeNow().Add(readTimeout))\n\t\tctxTimout, _ := context.WithTimeout(context.Background(), readTimeout)\n\t\twithContext = socket.WithContext(ctxTimout)\n\t} else {\n\t\ts.socket.SetReadDeadline(time.Time{})\n\t\twithContext = socket.WithContext(nil)\n\t}\n\n\tvar (\n\t\terr      error\n\t\tusedConn = s.getConn()\n\t)\n\tdefer func() {\n\t\tif p := recover(); p != nil {\n\t\t\terr = fmt.Errorf(\"panic:%v\\n%s\", p, goutil.PanicTrace(2))\n\t\t}\n\t\ts.readDisconnected(usedConn, err)\n\t}()\n\t// read call, call reply or push\n\tfor s.goonRead() {\n\t\tvar ctx = s.peer.getContext(s, false)\n\t\twithContext(ctx.input)\n\t\tif s.peer.pluginContainer.preReadHeader(ctx) != nil {\n\t\t\ts.peer.putContext(ctx, false)\n\t\t\treturn\n\t\t}\n\t\terr = s.socket.ReadMessage(ctx.input)\n\t\tif (err != nil && ctx.GetBodyCodec() == codec.NilCodecID) || !s.goonRead() {\n\t\t\ts.peer.putContext(ctx, false)\n\t\t\treturn\n\t\t}\n\t\tif err != nil {\n\t\t\tctx.stat = statBadMessage.Copy(err)\n\t\t}\n\t\ts.graceCtxWaitGroup.Add(1)\n\t\tif !Go(func() {\n\t\t\tdefer s.peer.putContext(ctx, true)\n\t\t\tctx.handle()\n\t\t}) {\n\t\t\ts.peer.putContext(ctx, true)\n\t\t}\n\t}\n}\n\nfunc (s *session) write(message Message) (net.Conn, *Status) {\n\tusedConn := s.getConn()\n\tstatus := s.getStatus()\n\tif !(status == statusOk || (status == statusActiveClosing && message.Mtype() == TypeReply)) {\n\t\treturn usedConn, statConnClosed\n\t}\n\n\tvar (\n\t\terr         error\n\t\tctx         = message.Context()\n\t\tdeadline, _ = ctx.Deadline()\n\t)\n\tselect {\n\tcase <-ctx.Done():\n\t\terr = ctx.Err()\n\t\tgoto ERR\n\tdefault:\n\t}\n\n\ts.writeLock.Lock()\n\tdefer s.writeLock.Unlock()\n\n\tselect {\n\tcase <-ctx.Done():\n\t\terr = ctx.Err()\n\t\tgoto ERR\n\tdefault:\n\t\ts.socket.SetWriteDeadline(deadline)\n\t\terr = s.socket.WriteMessage(message)\n\t}\n\n\tif err == nil {\n\t\treturn usedConn, nil\n\t}\n\n\tif err == io.EOF || err == socket.ErrProactivelyCloseSocket {\n\t\treturn usedConn, statConnClosed\n\t}\n\n\tDebugf(\"write error: %s\", err.Error())\n\nERR:\n\treturn usedConn, statWriteFailed.Copy(err)\n}\n\n// SessionHub sessions hub\ntype SessionHub struct {\n\t// key: session id (ip, name and so on)\n\t// value: *session\n\tsessions goutil.Map\n}\n\n// newSessionHub creates a new sessions hub.\nfunc newSessionHub() *SessionHub {\n\tchub := &SessionHub{\n\t\tsessions: goutil.AtomicMap(),\n\t}\n\treturn chub\n}\n\n// set sets a *session.\nfunc (sh *SessionHub) set(sess *session) {\n\t_sess, loaded := sh.sessions.LoadOrStore(sess.ID(), sess)\n\tif !loaded {\n\t\treturn\n\t}\n\tsh.sessions.Store(sess.ID(), sess)\n\tif oldSess := _sess.(*session); sess != oldSess {\n\t\toldSess.Close()\n\t}\n}\n\n// get gets *session by id.\n// If second returned arg is false, mean the *session is not found.\nfunc (sh *SessionHub) get(id string) (*session, bool) {\n\t_sess, ok := sh.sessions.Load(id)\n\tif !ok {\n\t\treturn nil, false\n\t}\n\treturn _sess.(*session), true\n}\n\n// rangeCallback calls f sequentially for each id and *session present in the session hub.\n// If fn returns false, stop traversing.\nfunc (sh *SessionHub) rangeCallback(fn func(*session) bool) {\n\tsh.sessions.Range(func(key, value interface{}) bool {\n\t\treturn fn(value.(*session))\n\t})\n}\n\n// random gets a *session randomly.\n// If second returned arg is false, mean no *session is exist.\nfunc (sh *SessionHub) random() (*session, bool) {\n\t_, sess, exist := sh.sessions.Random()\n\tif !exist {\n\t\treturn nil, false\n\t}\n\treturn sess.(*session), true\n}\n\n// len returns the length of the session hub.\n// NOTE: the count implemented using sync.Map may be inaccurate.\nfunc (sh *SessionHub) len() int {\n\treturn sh.sessions.Len()\n}\n\n// delete deletes the *session for a id.\nfunc (sh *SessionHub) delete(id string) {\n\tsh.sessions.Delete(id)\n}\n\nconst (\n\ttypePushLaunch int8 = 1\n\ttypePushHandle int8 = 2\n\ttypeCallLaunch int8 = 3\n\ttypeCallHandle int8 = 4\n)\n\nconst (\n\tlogFormatPushLaunch = \"PUSH-> %s %s %q SEND(%s)\"\n\tlogFormatPushHandle = \"PUSH<- %s %s %q RECV(%s)\"\n\tlogFormatCallLaunch = \"CALL-> %s %s %q SEND(%s) RECV(%s)\"\n\tlogFormatCallHandle = \"CALL<- %s %s %q RECV(%s) SEND(%s)\"\n)\n\nfunc enablePrintRunLog() bool {\n\treturn EnableLoggerLevel(WARNING)\n}\n\nfunc (s *session) printRunLog(realIP string, costTime time.Duration, input, output Message, logType int8) {\n\tvar addr = s.RemoteAddr().String()\n\tif realIP != \"\" && realIP == addr {\n\t\trealIP = \"same\"\n\t}\n\tif realIP == \"\" {\n\t\trealIP = \"-\"\n\t}\n\taddr += \"(real:\" + realIP + \")\"\n\tvar (\n\t\tcostTimeStr string\n\t\tprintFunc   = Infof\n\t)\n\tif s.peer.countTime {\n\t\tif costTime >= s.peer.slowCometDuration {\n\t\t\tcostTimeStr = costTime.String() + \"(slow)\"\n\t\t\tprintFunc = Warnf\n\t\t} else {\n\t\t\tif GetLoggerLevel() < INFO {\n\t\t\t\treturn\n\t\t\t}\n\t\t\tcostTimeStr = costTime.String() + \"(fast)\"\n\t\t}\n\t} else {\n\t\tif GetLoggerLevel() < INFO {\n\t\t\treturn\n\t\t}\n\t\tcostTimeStr = \"(-)\"\n\t}\n\n\tswitch logType {\n\tcase typePushLaunch:\n\t\tprintFunc(logFormatPushLaunch, addr, costTimeStr, output.ServiceMethod(), messageLogBytes(output, s.peer.printDetail))\n\tcase typePushHandle:\n\t\tprintFunc(logFormatPushHandle, addr, costTimeStr, input.ServiceMethod(), messageLogBytes(input, s.peer.printDetail))\n\tcase typeCallLaunch:\n\t\tprintFunc(logFormatCallLaunch, addr, costTimeStr, output.ServiceMethod(), messageLogBytes(output, s.peer.printDetail), messageLogBytes(input, s.peer.printDetail))\n\tcase typeCallHandle:\n\t\tprintFunc(logFormatCallHandle, addr, costTimeStr, input.ServiceMethod(), messageLogBytes(input, s.peer.printDetail), messageLogBytes(output, s.peer.printDetail))\n\t}\n}\n\nfunc messageLogBytes(message Message, printDetail bool) []byte {\n\tvar b = make([]byte, 0, 128)\n\tb = append(b, '{')\n\tb = append(b, '\"', 's', 'i', 'z', 'e', '\"', ':')\n\tb = append(b, strconv.FormatUint(uint64(message.Size()), 10)...)\n\tif statBytes := message.Status().EncodeQuery(); len(statBytes) > 0 {\n\t\tb = append(b, ',', '\"', 's', 't', 'a', 't', 'u', 's', '\"', ':')\n\t\tb = append(b, statBytes...)\n\t}\n\tif printDetail {\n\t\tif message.Meta().Len() > 0 {\n\t\t\tb = append(b, ',', '\"', 'm', 'e', 't', 'a', '\"', ':')\n\t\t\tb = append(b, utils.ToJSONStr(message.Meta().QueryString(), false)...)\n\t\t}\n\t\tif bodyBytes := bodyLogBytes(message); len(bodyBytes) > 0 {\n\t\t\tb = append(b, ',', '\"', 'b', 'o', 'd', 'y', '\"', ':')\n\t\t\tb = append(b, bodyBytes...)\n\t\t}\n\t}\n\tb = append(b, '}')\n\treturn b\n}\n\nfunc bodyLogBytes(message Message) []byte {\n\tswitch v := message.Body().(type) {\n\tcase nil:\n\t\treturn nil\n\tcase []byte:\n\t\treturn utils.ToJSONStr(v, false)\n\tcase *[]byte:\n\t\treturn utils.ToJSONStr(*v, false)\n\t}\n\tb, _ := json.Marshal(message.Body())\n\treturn b\n}\n"
        },
        {
          "name": "socket",
          "type": "tree",
          "content": null
        },
        {
          "name": "status.go",
          "type": "blob",
          "size": 5.1689453125,
          "content": "package erpc\n\nimport (\n\t\"github.com/andeya/goutil/status\"\n)\n\n// Status a handling status with code, msg, cause and stack.\ntype Status = status.Status\n\nvar (\n\t// NewStatus creates a message status with code, msg and cause.\n\t// NOTE:\n\t//  code=0 means no error\n\t// TYPE:\n\t//  func NewStatus(code int32, msg string, cause interface{}) *Status\n\tNewStatus = status.New\n\n\t// NewStatusWithStack creates a message status with code, msg and cause and stack.\n\t// NOTE:\n\t//  code=0 means no error\n\t// TYPE:\n\t//  func NewStatusWithStack(code int32, msg string, cause interface{}) *Status\n\tNewStatusWithStack = status.NewWithStack\n\n\t// NewStatusFromQuery parses the query bytes to a status object.\n\t// TYPE:\n\t//  func NewStatusFromQuery(b []byte, tagStack bool) *Status\n\tNewStatusFromQuery = status.FromQuery\n\t// CheckStatus if err!=nil, create a status with stack, and panic.\n\t// NOTE:\n\t//  If err!=nil and msg==\"\", error text is set to msg\n\t// TYPE:\n\t//  func Check(err error, code int32, msg string, whenError ...func())\n\tCheckStatus = status.Check\n\t// ThrowStatus creates a status with stack, and panic.\n\t// TYPE:\n\t//  func Throw(code int32, msg string, cause interface{})\n\tThrowStatus = status.Throw\n\t// PanicStatus panic with stack trace.\n\t// TYPE:\n\t//  func Panic(stat *Status)\n\tPanicStatus = status.Panic\n\t// CatchStatus recovers the panic and returns status.\n\t// NOTE:\n\t//  Set `realStat` to true if a `Status` type is recovered\n\t// Example:\n\t//  var stat *Status\n\t//  defer Catch(&stat)\n\t// TYPE:\n\t//  func Catch(statPtr **Status, realStat ...*bool)\n\tCatchStatus = status.Catch\n)\n\n// NewStatusByCodeText creates a message status with code, msg, cause or stack.\n// NOTE:\n//\n//\tThe msg comes from the CodeText(code) value.\nfunc NewStatusByCodeText(code int32, cause interface{}, tagStack bool) *Status {\n\tstat := NewStatus(code, CodeText(code), cause)\n\tif tagStack {\n\t\tstat.TagStack(1)\n\t}\n\treturn stat\n}\n\n// Internal Framework Status code.\n// NOTE: Recommended custom code is greater than 1000.\n//\n//\tunknown error code: -1.\n//\tsender peer error code range: [100,199].\n//\tmessage handling error code range: [400,499].\n//\treceiver peer error code range: [500,599].\nconst (\n\tCodeUnknownError        int32 = -1\n\tCodeOK                  int32 = 0      // nil error (ok)\n\tCodeNoError             int32 = CodeOK // nil error (ok)\n\tCodeInvalidOp           int32 = 1\n\tCodeWrongConn           int32 = 100\n\tCodeConnClosed          int32 = 102\n\tCodeWriteFailed         int32 = 104\n\tCodeDialFailed          int32 = 105\n\tCodeBadMessage          int32 = 400\n\tCodeUnauthorized        int32 = 401\n\tCodeNotFound            int32 = 404\n\tCodeMtypeNotAllowed     int32 = 405\n\tCodeHandleTimeout       int32 = 408\n\tCodeInternalServerError int32 = 500\n\tCodeBadGateway          int32 = 502\n\n\t// CodeConflict                      int32 = 409\n\t// CodeUnsupportedTx                 int32 = 410\n\t// CodeUnsupportedCodecType          int32 = 415\n\t// CodeServiceUnavailable            int32 = 503\n\t// CodeGatewayTimeout                int32 = 504\n\t// CodeVariantAlsoNegotiates         int32 = 506\n\t// CodeInsufficientStorage           int32 = 507\n\t// CodeLoopDetected                  int32 = 508\n\t// CodeNotExtended                   int32 = 510\n\t// CodeNetworkAuthenticationRequired int32 = 511\n)\n\n// CodeText returns the reply error code text.\n// If the type is undefined returns 'Unknown Error'.\nfunc CodeText(statCode int32) string {\n\tswitch statCode {\n\tcase CodeNoError:\n\t\treturn \"\"\n\tcase CodeInvalidOp:\n\t\treturn \"Invalid Operation\"\n\tcase CodeBadMessage:\n\t\treturn \"Bad Message\"\n\tcase CodeUnauthorized:\n\t\treturn \"Unauthorized\"\n\tcase CodeDialFailed:\n\t\treturn \"Dial Failed\"\n\tcase CodeWrongConn:\n\t\treturn \"Wrong Connection\"\n\tcase CodeConnClosed:\n\t\treturn \"Connection Closed\"\n\tcase CodeWriteFailed:\n\t\treturn \"Write Failed\"\n\tcase CodeNotFound:\n\t\treturn \"Not Found\"\n\tcase CodeHandleTimeout:\n\t\treturn \"Handle Timeout\"\n\tcase CodeMtypeNotAllowed:\n\t\treturn \"Message Type Not Allowed\"\n\tcase CodeInternalServerError:\n\t\treturn \"Internal Server Error\"\n\tcase CodeBadGateway:\n\t\treturn \"Bad Gateway\"\n\tcase CodeUnknownError:\n\t\tfallthrough\n\tdefault:\n\t\treturn \"Unknown Error\"\n\t}\n}\n\n// Internal Framework Status string.\nvar (\n\tstatInvalidOpError      = NewStatus(CodeInvalidOp, CodeText(CodeInvalidOp), \"\")\n\tstatUnknownError        = NewStatus(CodeUnknownError, CodeText(CodeUnknownError), \"\")\n\tstatDialFailed          = NewStatus(CodeDialFailed, CodeText(CodeDialFailed), \"\")\n\tstatConnClosed          = NewStatus(CodeConnClosed, CodeText(CodeConnClosed), \"\")\n\tstatWriteFailed         = NewStatus(CodeWriteFailed, CodeText(CodeWriteFailed), \"\")\n\tstatBadMessage          = NewStatus(CodeBadMessage, CodeText(CodeBadMessage), \"\")\n\tstatNotFound            = NewStatus(CodeNotFound, CodeText(CodeNotFound), \"\")\n\tstatCodeMtypeNotAllowed = NewStatus(CodeMtypeNotAllowed, CodeText(CodeMtypeNotAllowed), \"\")\n\tstatHandleTimeout       = NewStatus(CodeHandleTimeout, CodeText(CodeHandleTimeout), \"\")\n\tstatInternalServerError = NewStatus(CodeInternalServerError, CodeText(CodeInternalServerError), \"\")\n)\n\n// IsConnError determines whether the status is a connection error.\nfunc IsConnError(stat *Status) bool {\n\tif stat == nil {\n\t\treturn false\n\t}\n\tcode := stat.Code()\n\tif code == CodeDialFailed || code == CodeConnClosed {\n\t\treturn true\n\t}\n\treturn false\n}\n"
        },
        {
          "name": "utils",
          "type": "tree",
          "content": null
        },
        {
          "name": "xfer",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}