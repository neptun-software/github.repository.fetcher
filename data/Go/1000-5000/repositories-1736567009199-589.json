{
  "metadata": {
    "timestamp": 1736567009199,
    "page": 589,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjU5MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "looplab/fsm",
      "stars": 2905,
      "defaultBranch": "main",
      "files": [
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.3359375,
          "content": "# Compiled Object files, Static and Dynamic libs (Shared Objects)\n*.o\n*.a\n*.so\n\n# Folders\n_obj\n_test\n\n# Architecture specific extensions/prefixes\n*.[568vq]\n[568vq].out\n\n*.cgo1.go\n*.cgo2.c\n_cgo_defun.c\n_cgo_gotypes.go\n_cgo_export.*\n\n_testmain.go\n\n*.exe\n\n*.sublime-project\n*.sublime-workspace\n\n.DS_Store\n.wercker\n\n# Testing\n.coverprofile\n\n.vscode"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 10.0322265625,
          "content": "Apache License\nVersion 2.0, January 2004\nhttp://www.apache.org/licenses/\n\nTERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION\n\n1. Definitions.\n\n\"License\" shall mean the terms and conditions for use, reproduction, and\ndistribution as defined by Sections 1 through 9 of this document.\n\n\"Licensor\" shall mean the copyright owner or entity authorized by the copyright\nowner that is granting the License.\n\n\"Legal Entity\" shall mean the union of the acting entity and all other entities\nthat control, are controlled by, or are under common control with that entity.\nFor the purposes of this definition, \"control\" means (i) the power, direct or\nindirect, to cause the direction or management of such entity, whether by\ncontract or otherwise, or (ii) ownership of fifty percent (50%) or more of the\noutstanding shares, or (iii) beneficial ownership of such entity.\n\n\"You\" (or \"Your\") shall mean an individual or Legal Entity exercising\npermissions granted by this License.\n\n\"Source\" form shall mean the preferred form for making modifications, including\nbut not limited to software source code, documentation source, and configuration\nfiles.\n\n\"Object\" form shall mean any form resulting from mechanical transformation or\ntranslation of a Source form, including but not limited to compiled object code,\ngenerated documentation, and conversions to other media types.\n\n\"Work\" shall mean the work of authorship, whether in Source or Object form, made\navailable under the License, as indicated by a copyright notice that is included\nin or attached to the work (an example is provided in the Appendix below).\n\n\"Derivative Works\" shall mean any work, whether in Source or Object form, that\nis based on (or derived from) the Work and for which the editorial revisions,\nannotations, elaborations, or other modifications represent, as a whole, an\noriginal work of authorship. For the purposes of this License, Derivative Works\nshall not include works that remain separable from, or merely link (or bind by\nname) to the interfaces of, the Work and Derivative Works thereof.\n\n\"Contribution\" shall mean any work of authorship, including the original version\nof the Work and any modifications or additions to that Work or Derivative Works\nthereof, that is intentionally submitted to Licensor for inclusion in the Work\nby the copyright owner or by an individual or Legal Entity authorized to submit\non behalf of the copyright owner. For the purposes of this definition,\n\"submitted\" means any form of electronic, verbal, or written communication sent\nto the Licensor or its representatives, including but not limited to\ncommunication on electronic mailing lists, source code control systems, and\nissue tracking systems that are managed by, or on behalf of, the Licensor for\nthe purpose of discussing and improving the Work, but excluding communication\nthat is conspicuously marked or otherwise designated in writing by the copyright\nowner as \"Not a Contribution.\"\n\n\"Contributor\" shall mean Licensor and any individual or Legal Entity on behalf\nof whom a Contribution has been received by Licensor and subsequently\nincorporated within the Work.\n\n2. Grant of Copyright License.\n\nSubject to the terms and conditions of this License, each Contributor hereby\ngrants to You a perpetual, worldwide, non-exclusive, no-charge, royalty-free,\nirrevocable copyright license to reproduce, prepare Derivative Works of,\npublicly display, publicly perform, sublicense, and distribute the Work and such\nDerivative Works in Source or Object form.\n\n3. Grant of Patent License.\n\nSubject to the terms and conditions of this License, each Contributor hereby\ngrants to You a perpetual, worldwide, non-exclusive, no-charge, royalty-free,\nirrevocable (except as stated in this section) patent license to make, have\nmade, use, offer to sell, sell, import, and otherwise transfer the Work, where\nsuch license applies only to those patent claims licensable by such Contributor\nthat are necessarily infringed by their Contribution(s) alone or by combination\nof their Contribution(s) with the Work to which such Contribution(s) was\nsubmitted. If You institute patent litigation against any entity (including a\ncross-claim or counterclaim in a lawsuit) alleging that the Work or a\nContribution incorporated within the Work constitutes direct or contributory\npatent infringement, then any patent licenses granted to You under this License\nfor that Work shall terminate as of the date such litigation is filed.\n\n4. Redistribution.\n\nYou may reproduce and distribute copies of the Work or Derivative Works thereof\nin any medium, with or without modifications, and in Source or Object form,\nprovided that You meet the following conditions:\n\nYou must give any other recipients of the Work or Derivative Works a copy of\nthis License; and\nYou must cause any modified files to carry prominent notices stating that You\nchanged the files; and\nYou must retain, in the Source form of any Derivative Works that You distribute,\nall copyright, patent, trademark, and attribution notices from the Source form\nof the Work, excluding those notices that do not pertain to any part of the\nDerivative Works; and\nIf the Work includes a \"NOTICE\" text file as part of its distribution, then any\nDerivative Works that You distribute must include a readable copy of the\nattribution notices contained within such NOTICE file, excluding those notices\nthat do not pertain to any part of the Derivative Works, in at least one of the\nfollowing places: within a NOTICE text file distributed as part of the\nDerivative Works; within the Source form or documentation, if provided along\nwith the Derivative Works; or, within a display generated by the Derivative\nWorks, if and wherever such third-party notices normally appear. The contents of\nthe NOTICE file are for informational purposes only and do not modify the\nLicense. You may add Your own attribution notices within Derivative Works that\nYou distribute, alongside or as an addendum to the NOTICE text from the Work,\nprovided that such additional attribution notices cannot be construed as\nmodifying the License.\nYou may add Your own copyright statement to Your modifications and may provide\nadditional or different license terms and conditions for use, reproduction, or\ndistribution of Your modifications, or for any such Derivative Works as a whole,\nprovided Your use, reproduction, and distribution of the Work otherwise complies\nwith the conditions stated in this License.\n\n5. Submission of Contributions.\n\nUnless You explicitly state otherwise, any Contribution intentionally submitted\nfor inclusion in the Work by You to the Licensor shall be under the terms and\nconditions of this License, without any additional terms or conditions.\nNotwithstanding the above, nothing herein shall supersede or modify the terms of\nany separate license agreement you may have executed with Licensor regarding\nsuch Contributions.\n\n6. Trademarks.\n\nThis License does not grant permission to use the trade names, trademarks,\nservice marks, or product names of the Licensor, except as required for\nreasonable and customary use in describing the origin of the Work and\nreproducing the content of the NOTICE file.\n\n7. Disclaimer of Warranty.\n\nUnless required by applicable law or agreed to in writing, Licensor provides the\nWork (and each Contributor provides its Contributions) on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied,\nincluding, without limitation, any warranties or conditions of TITLE,\nNON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A PARTICULAR PURPOSE. You are\nsolely responsible for determining the appropriateness of using or\nredistributing the Work and assume any risks associated with Your exercise of\npermissions under this License.\n\n8. Limitation of Liability.\n\nIn no event and under no legal theory, whether in tort (including negligence),\ncontract, or otherwise, unless required by applicable law (such as deliberate\nand grossly negligent acts) or agreed to in writing, shall any Contributor be\nliable to You for damages, including any direct, indirect, special, incidental,\nor consequential damages of any character arising as a result of this License or\nout of the use or inability to use the Work (including but not limited to\ndamages for loss of goodwill, work stoppage, computer failure or malfunction, or\nany and all other commercial damages or losses), even if such Contributor has\nbeen advised of the possibility of such damages.\n\n9. Accepting Warranty or Additional Liability.\n\nWhile redistributing the Work or Derivative Works thereof, You may choose to\noffer, and charge a fee for, acceptance of support, warranty, indemnity, or\nother liability obligations and/or rights consistent with this License. However,\nin accepting such obligations, You may act only on Your own behalf and on Your\nsole responsibility, not on behalf of any other Contributor, and only if You\nagree to indemnify, defend, and hold each Contributor harmless for any liability\nincurred by, or claims asserted against, such Contributor by reason of your\naccepting any such warranty or additional liability.\n\nEND OF TERMS AND CONDITIONS\n\nAPPENDIX: How to apply the Apache License to your work\n\nTo apply the Apache License to your work, attach the following boilerplate\nnotice, with the fields enclosed by brackets \"[]\" replaced with your own\nidentifying information. (Don't include the brackets!) The text should be\nenclosed in the appropriate comment syntax for the file format. We also\nrecommend that a file or class name and description of purpose be included on\nthe same \"printed page\" as the copyright notice for easier identification within\nthird-party archives.\n\n   Copyright [yyyy] [name of copyright owner]\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n     http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n"
        },
        {
          "name": "Makefile",
          "type": "blob",
          "size": 0.5927734375,
          "content": "default: services test\n\n.PHONY: test\ntest:\n\tgo test -race ./...\n\n.PHONY: lint\nlint:\n\tgolangci-lint run\n\n.PHONY: cover\ncover:\n\tgo list -f '{{if len .TestGoFiles}}\"go test -coverprofile={{.Dir}}/.coverprofile {{.ImportPath}}\"{{end}}' ./... | xargs -L 1 sh -c\n\n.PHONY: publish_cover\npublish_cover: cover\n\tgo get -d golang.org/x/tools/cmd/cover\n\tgo get github.com/modocache/gover\n\tgo get github.com/mattn/goveralls\n\tgover\n\t@goveralls -coverprofile=gover.coverprofile -service=travis-ci -repotoken=$(COVERALLS_TOKEN)\n\n.PHONY: clean\nclean:\n\t@find . -name \\.coverprofile -type f -delete\n\t@rm -f gover.coverprofile\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 2.4736328125,
          "content": "[![PkgGoDev](https://pkg.go.dev/badge/github.com/looplab/fsm)](https://pkg.go.dev/github.com/looplab/fsm)\n![Bulid Status](https://github.com/looplab/fsm/actions/workflows/main.yml/badge.svg)\n[![Coverage Status](https://img.shields.io/coveralls/looplab/fsm.svg)](https://coveralls.io/r/looplab/fsm)\n[![Go Report Card](https://goreportcard.com/badge/looplab/fsm)](https://goreportcard.com/report/looplab/fsm)\n\n# FSM for Go\n\nFSM is a finite state machine for Go.\n\nIt is heavily based on two FSM implementations:\n\n- Javascript Finite State Machine, https://github.com/jakesgordon/javascript-state-machine\n\n- Fysom for Python, https://github.com/oxplot/fysom (forked at https://github.com/mriehl/fysom)\n\nFor API docs and examples see http://godoc.org/github.com/looplab/fsm\n\n# Basic Example\n\nFrom examples/simple.go:\n\n```go\npackage main\n\nimport (\n    \"context\"\n    \"fmt\"\n\n    \"github.com/looplab/fsm\"\n)\n\nfunc main() {\n    fsm := fsm.NewFSM(\n        \"closed\",\n        fsm.Events{\n            {Name: \"open\", Src: []string{\"closed\"}, Dst: \"open\"},\n            {Name: \"close\", Src: []string{\"open\"}, Dst: \"closed\"},\n        },\n        fsm.Callbacks{},\n    )\n\n    fmt.Println(fsm.Current())\n\n    err := fsm.Event(context.Background(), \"open\")\n    if err != nil {\n        fmt.Println(err)\n    }\n\n    fmt.Println(fsm.Current())\n\n    err = fsm.Event(context.Background(), \"close\")\n    if err != nil {\n        fmt.Println(err)\n    }\n\n    fmt.Println(fsm.Current())\n}\n```\n\n# Usage as a struct field\n\nFrom examples/struct.go:\n\n```go\npackage main\n\nimport (\n    \"context\"\n    \"fmt\"\n\n    \"github.com/looplab/fsm\"\n)\n\ntype Door struct {\n    To  string\n    FSM *fsm.FSM\n}\n\nfunc NewDoor(to string) *Door {\n    d := &Door{\n        To: to,\n    }\n\n    d.FSM = fsm.NewFSM(\n        \"closed\",\n        fsm.Events{\n            {Name: \"open\", Src: []string{\"closed\"}, Dst: \"open\"},\n            {Name: \"close\", Src: []string{\"open\"}, Dst: \"closed\"},\n        },\n        fsm.Callbacks{\n            \"enter_state\": func(_ context.Context, e *fsm.Event) { d.enterState(e) },\n        },\n    )\n\n    return d\n}\n\nfunc (d *Door) enterState(e *fsm.Event) {\n    fmt.Printf(\"The door to %s is %s\\n\", d.To, e.Dst)\n}\n\nfunc main() {\n    door := NewDoor(\"heaven\")\n\n    err := door.FSM.Event(context.Background(), \"open\")\n    if err != nil {\n        fmt.Println(err)\n    }\n\n    err = door.FSM.Event(context.Background(), \"close\")\n    if err != nil {\n        fmt.Println(err)\n    }\n}\n```\n\n# License\n\nFSM is licensed under Apache License 2.0\n\nhttp://www.apache.org/licenses/LICENSE-2.0\n"
        },
        {
          "name": "errors.go",
          "type": "blob",
          "size": 2.8515625,
          "content": "// Copyright (c) 2013 - Max Persson <max@looplab.se>\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage fsm\n\nimport (\n\t\"context\"\n)\n\n// InvalidEventError is returned by FSM.Event() when the event cannot be called\n// in the current state.\ntype InvalidEventError struct {\n\tEvent string\n\tState string\n}\n\nfunc (e InvalidEventError) Error() string {\n\treturn \"event \" + e.Event + \" inappropriate in current state \" + e.State\n}\n\n// UnknownEventError is returned by FSM.Event() when the event is not defined.\ntype UnknownEventError struct {\n\tEvent string\n}\n\nfunc (e UnknownEventError) Error() string {\n\treturn \"event \" + e.Event + \" does not exist\"\n}\n\n// InTransitionError is returned by FSM.Event() when an asynchronous transition\n// is already in progress.\ntype InTransitionError struct {\n\tEvent string\n}\n\nfunc (e InTransitionError) Error() string {\n\treturn \"event \" + e.Event + \" inappropriate because previous transition did not complete\"\n}\n\n// NotInTransitionError is returned by FSM.Transition() when an asynchronous\n// transition is not in progress.\ntype NotInTransitionError struct{}\n\nfunc (e NotInTransitionError) Error() string {\n\treturn \"transition inappropriate because no state change in progress\"\n}\n\n// NoTransitionError is returned by FSM.Event() when no transition have happened,\n// for example if the source and destination states are the same.\ntype NoTransitionError struct {\n\tErr error\n}\n\nfunc (e NoTransitionError) Error() string {\n\tif e.Err != nil {\n\t\treturn \"no transition with error: \" + e.Err.Error()\n\t}\n\treturn \"no transition\"\n}\n\n// CanceledError is returned by FSM.Event() when a callback have canceled a\n// transition.\ntype CanceledError struct {\n\tErr error\n}\n\nfunc (e CanceledError) Error() string {\n\tif e.Err != nil {\n\t\treturn \"transition canceled with error: \" + e.Err.Error()\n\t}\n\treturn \"transition canceled\"\n}\n\n// AsyncError is returned by FSM.Event() when a callback have initiated an\n// asynchronous state transition.\ntype AsyncError struct {\n\tErr error\n\n\tCtx              context.Context\n\tCancelTransition func()\n}\n\nfunc (e AsyncError) Error() string {\n\tif e.Err != nil {\n\t\treturn \"async started with error: \" + e.Err.Error()\n\t}\n\treturn \"async started\"\n}\n\n// InternalError is returned by FSM.Event() and should never occur. It is a\n// probably because of a bug.\ntype InternalError struct{}\n\nfunc (e InternalError) Error() string {\n\treturn \"internal error on state transition\"\n}\n"
        },
        {
          "name": "errors_test.go",
          "type": "blob",
          "size": 2.58984375,
          "content": "// Copyright (c) 2013 - Max Persson <max@looplab.se>\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage fsm\n\nimport (\n\t\"errors\"\n\t\"testing\"\n)\n\nfunc TestInvalidEventError(t *testing.T) {\n\tevent := \"invalid event\"\n\tstate := \"state\"\n\te := InvalidEventError{Event: event, State: state}\n\tif e.Error() != \"event \"+e.Event+\" inappropriate in current state \"+e.State {\n\t\tt.Error(\"InvalidEventError string mismatch\")\n\t}\n}\n\nfunc TestUnknownEventError(t *testing.T) {\n\tevent := \"invalid event\"\n\te := UnknownEventError{Event: event}\n\tif e.Error() != \"event \"+e.Event+\" does not exist\" {\n\t\tt.Error(\"UnknownEventError string mismatch\")\n\t}\n}\n\nfunc TestInTransitionError(t *testing.T) {\n\tevent := \"in transition\"\n\te := InTransitionError{Event: event}\n\tif e.Error() != \"event \"+e.Event+\" inappropriate because previous transition did not complete\" {\n\t\tt.Error(\"InTransitionError string mismatch\")\n\t}\n}\n\nfunc TestNotInTransitionError(t *testing.T) {\n\te := NotInTransitionError{}\n\tif e.Error() != \"transition inappropriate because no state change in progress\" {\n\t\tt.Error(\"NotInTransitionError string mismatch\")\n\t}\n}\n\nfunc TestNoTransitionError(t *testing.T) {\n\te := NoTransitionError{}\n\tif e.Error() != \"no transition\" {\n\t\tt.Error(\"NoTransitionError string mismatch\")\n\t}\n\te.Err = errors.New(\"no transition\")\n\tif e.Error() != \"no transition with error: \"+e.Err.Error() {\n\t\tt.Error(\"NoTransitionError string mismatch\")\n\t}\n}\n\nfunc TestCanceledError(t *testing.T) {\n\te := CanceledError{}\n\tif e.Error() != \"transition canceled\" {\n\t\tt.Error(\"CanceledError string mismatch\")\n\t}\n\te.Err = errors.New(\"canceled\")\n\tif e.Error() != \"transition canceled with error: \"+e.Err.Error() {\n\t\tt.Error(\"CanceledError string mismatch\")\n\t}\n}\n\nfunc TestAsyncError(t *testing.T) {\n\te := AsyncError{}\n\tif e.Error() != \"async started\" {\n\t\tt.Error(\"AsyncError string mismatch\")\n\t}\n\te.Err = errors.New(\"async\")\n\tif e.Error() != \"async started with error: \"+e.Err.Error() {\n\t\tt.Error(\"AsyncError string mismatch\")\n\t}\n}\n\nfunc TestInternalError(t *testing.T) {\n\te := InternalError{}\n\tif e.Error() != \"internal error on state transition\" {\n\t\tt.Error(\"InternalError string mismatch\")\n\t}\n}\n"
        },
        {
          "name": "event.go",
          "type": "blob",
          "size": 1.9140625,
          "content": "// Copyright (c) 2013 - Max Persson <max@looplab.se>\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage fsm\n\n// Event is the info that get passed as a reference in the callbacks.\ntype Event struct {\n\t// FSM is an reference to the current FSM.\n\tFSM *FSM\n\n\t// Event is the event name.\n\tEvent string\n\n\t// Src is the state before the transition.\n\tSrc string\n\n\t// Dst is the state after the transition.\n\tDst string\n\n\t// Err is an optional error that can be returned from a callback.\n\tErr error\n\n\t// Args is an optional list of arguments passed to the callback.\n\tArgs []interface{}\n\n\t// canceled is an internal flag set if the transition is canceled.\n\tcanceled bool\n\n\t// async is an internal flag set if the transition should be asynchronous\n\tasync bool\n\n\t// cancelFunc is called in case the event is canceled.\n\tcancelFunc func()\n}\n\n// Cancel can be called in before_<EVENT> or leave_<STATE> to cancel the\n// current transition before it happens. It takes an optional error, which will\n// overwrite e.Err if set before.\nfunc (e *Event) Cancel(err ...error) {\n\te.canceled = true\n\te.cancelFunc()\n\n\tif len(err) > 0 {\n\t\te.Err = err[0]\n\t}\n}\n\n// Async can be called in leave_<STATE> to do an asynchronous state transition.\n//\n// The current state transition will be on hold in the old state until a final\n// call to Transition is made. This will complete the transition and possibly\n// call the other callbacks.\nfunc (e *Event) Async() {\n\te.async = true\n}\n"
        },
        {
          "name": "examples",
          "type": "tree",
          "content": null
        },
        {
          "name": "fsm.go",
          "type": "blob",
          "size": 14.5849609375,
          "content": "// Copyright (c) 2013 - Max Persson <max@looplab.se>\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n// Package fsm implements a finite state machine.\n//\n// It is heavily based on two FSM implementations:\n//\n// Javascript Finite State Machine\n// https://github.com/jakesgordon/javascript-state-machine\n//\n// Fysom for Python\n// https://github.com/oxplot/fysom (forked at https://github.com/mriehl/fysom)\npackage fsm\n\nimport (\n\t\"context\"\n\t\"strings\"\n\t\"sync\"\n)\n\n// transitioner is an interface for the FSM's transition function.\ntype transitioner interface {\n\ttransition(*FSM) error\n}\n\n// FSM is the state machine that holds the current state.\n//\n// It has to be created with NewFSM to function properly.\ntype FSM struct {\n\t// current is the state that the FSM is currently in.\n\tcurrent string\n\n\t// transitions maps events and source states to destination states.\n\ttransitions map[eKey]string\n\n\t// callbacks maps events and targets to callback functions.\n\tcallbacks map[cKey]Callback\n\n\t// transition is the internal transition functions used either directly\n\t// or when Transition is called in an asynchronous state transition.\n\ttransition func()\n\t// transitionerObj calls the FSM's transition() function.\n\ttransitionerObj transitioner\n\n\t// stateMu guards access to the current state.\n\tstateMu sync.RWMutex\n\t// eventMu guards access to Event() and Transition().\n\teventMu sync.Mutex\n\t// metadata can be used to store and load data that maybe used across events\n\t// use methods SetMetadata() and Metadata() to store and load data\n\tmetadata map[string]interface{}\n\n\tmetadataMu sync.RWMutex\n}\n\n// EventDesc represents an event when initializing the FSM.\n//\n// The event can have one or more source states that is valid for performing\n// the transition. If the FSM is in one of the source states it will end up in\n// the specified destination state, calling all defined callbacks as it goes.\ntype EventDesc struct {\n\t// Name is the event name used when calling for a transition.\n\tName string\n\n\t// Src is a slice of source states that the FSM must be in to perform a\n\t// state transition.\n\tSrc []string\n\n\t// Dst is the destination state that the FSM will be in if the transition\n\t// succeeds.\n\tDst string\n}\n\n// Callback is a function type that callbacks should use. Event is the current\n// event info as the callback happens.\ntype Callback func(context.Context, *Event)\n\n// Events is a shorthand for defining the transition map in NewFSM.\ntype Events []EventDesc\n\n// Callbacks is a shorthand for defining the callbacks in NewFSM.\ntype Callbacks map[string]Callback\n\n// NewFSM constructs a FSM from events and callbacks.\n//\n// The events and transitions are specified as a slice of Event structs\n// specified as Events. Each Event is mapped to one or more internal\n// transitions from Event.Src to Event.Dst.\n//\n// Callbacks are added as a map specified as Callbacks where the key is parsed\n// as the callback event as follows, and called in the same order:\n//\n// 1. before_<EVENT> - called before event named <EVENT>\n//\n// 2. before_event - called before all events\n//\n// 3. leave_<OLD_STATE> - called before leaving <OLD_STATE>\n//\n// 4. leave_state - called before leaving all states\n//\n// 5. enter_<NEW_STATE> - called after entering <NEW_STATE>\n//\n// 6. enter_state - called after entering all states\n//\n// 7. after_<EVENT> - called after event named <EVENT>\n//\n// 8. after_event - called after all events\n//\n// There are also two short form versions for the most commonly used callbacks.\n// They are simply the name of the event or state:\n//\n// 1. <NEW_STATE> - called after entering <NEW_STATE>\n//\n// 2. <EVENT> - called after event named <EVENT>\n//\n// If both a shorthand version and a full version is specified it is undefined\n// which version of the callback will end up in the internal map. This is due\n// to the pseudo random nature of Go maps. No checking for multiple keys is\n// currently performed.\nfunc NewFSM(initial string, events []EventDesc, callbacks map[string]Callback) *FSM {\n\tf := &FSM{\n\t\ttransitionerObj: &transitionerStruct{},\n\t\tcurrent:         initial,\n\t\ttransitions:     make(map[eKey]string),\n\t\tcallbacks:       make(map[cKey]Callback),\n\t\tmetadata:        make(map[string]interface{}),\n\t}\n\n\t// Build transition map and store sets of all events and states.\n\tallEvents := make(map[string]bool)\n\tallStates := make(map[string]bool)\n\tfor _, e := range events {\n\t\tfor _, src := range e.Src {\n\t\t\tf.transitions[eKey{e.Name, src}] = e.Dst\n\t\t\tallStates[src] = true\n\t\t\tallStates[e.Dst] = true\n\t\t}\n\t\tallEvents[e.Name] = true\n\t}\n\n\t// Map all callbacks to events/states.\n\tfor name, fn := range callbacks {\n\t\tvar target string\n\t\tvar callbackType int\n\n\t\tswitch {\n\t\tcase strings.HasPrefix(name, \"before_\"):\n\t\t\ttarget = strings.TrimPrefix(name, \"before_\")\n\t\t\tif target == \"event\" {\n\t\t\t\ttarget = \"\"\n\t\t\t\tcallbackType = callbackBeforeEvent\n\t\t\t} else if _, ok := allEvents[target]; ok {\n\t\t\t\tcallbackType = callbackBeforeEvent\n\t\t\t}\n\t\tcase strings.HasPrefix(name, \"leave_\"):\n\t\t\ttarget = strings.TrimPrefix(name, \"leave_\")\n\t\t\tif target == \"state\" {\n\t\t\t\ttarget = \"\"\n\t\t\t\tcallbackType = callbackLeaveState\n\t\t\t} else if _, ok := allStates[target]; ok {\n\t\t\t\tcallbackType = callbackLeaveState\n\t\t\t}\n\t\tcase strings.HasPrefix(name, \"enter_\"):\n\t\t\ttarget = strings.TrimPrefix(name, \"enter_\")\n\t\t\tif target == \"state\" {\n\t\t\t\ttarget = \"\"\n\t\t\t\tcallbackType = callbackEnterState\n\t\t\t} else if _, ok := allStates[target]; ok {\n\t\t\t\tcallbackType = callbackEnterState\n\t\t\t}\n\t\tcase strings.HasPrefix(name, \"after_\"):\n\t\t\ttarget = strings.TrimPrefix(name, \"after_\")\n\t\t\tif target == \"event\" {\n\t\t\t\ttarget = \"\"\n\t\t\t\tcallbackType = callbackAfterEvent\n\t\t\t} else if _, ok := allEvents[target]; ok {\n\t\t\t\tcallbackType = callbackAfterEvent\n\t\t\t}\n\t\tdefault:\n\t\t\ttarget = name\n\t\t\tif _, ok := allStates[target]; ok {\n\t\t\t\tcallbackType = callbackEnterState\n\t\t\t} else if _, ok := allEvents[target]; ok {\n\t\t\t\tcallbackType = callbackAfterEvent\n\t\t\t}\n\t\t}\n\n\t\tif callbackType != callbackNone {\n\t\t\tf.callbacks[cKey{target, callbackType}] = fn\n\t\t}\n\t}\n\n\treturn f\n}\n\n// Current returns the current state of the FSM.\nfunc (f *FSM) Current() string {\n\tf.stateMu.RLock()\n\tdefer f.stateMu.RUnlock()\n\treturn f.current\n}\n\n// Is returns true if state is the current state.\nfunc (f *FSM) Is(state string) bool {\n\tf.stateMu.RLock()\n\tdefer f.stateMu.RUnlock()\n\treturn state == f.current\n}\n\n// SetState allows the user to move to the given state from current state.\n// The call does not trigger any callbacks, if defined.\nfunc (f *FSM) SetState(state string) {\n\tf.stateMu.Lock()\n\tdefer f.stateMu.Unlock()\n\tf.current = state\n}\n\n// Can returns true if event can occur in the current state.\nfunc (f *FSM) Can(event string) bool {\n\tf.eventMu.Lock()\n\tdefer f.eventMu.Unlock()\n\tf.stateMu.RLock()\n\tdefer f.stateMu.RUnlock()\n\t_, ok := f.transitions[eKey{event, f.current}]\n\treturn ok && (f.transition == nil)\n}\n\n// AvailableTransitions returns a list of transitions available in the\n// current state.\nfunc (f *FSM) AvailableTransitions() []string {\n\tf.stateMu.RLock()\n\tdefer f.stateMu.RUnlock()\n\tvar transitions []string\n\tfor key := range f.transitions {\n\t\tif key.src == f.current {\n\t\t\ttransitions = append(transitions, key.event)\n\t\t}\n\t}\n\treturn transitions\n}\n\n// Cannot returns true if event can not occur in the current state.\n// It is a convenience method to help code read nicely.\nfunc (f *FSM) Cannot(event string) bool {\n\treturn !f.Can(event)\n}\n\n// Metadata returns the value stored in metadata\nfunc (f *FSM) Metadata(key string) (interface{}, bool) {\n\tf.metadataMu.RLock()\n\tdefer f.metadataMu.RUnlock()\n\tdataElement, ok := f.metadata[key]\n\treturn dataElement, ok\n}\n\n// SetMetadata stores the dataValue in metadata indexing it with key\nfunc (f *FSM) SetMetadata(key string, dataValue interface{}) {\n\tf.metadataMu.Lock()\n\tdefer f.metadataMu.Unlock()\n\tf.metadata[key] = dataValue\n}\n\n// DeleteMetadata deletes the dataValue in metadata by key\nfunc (f *FSM) DeleteMetadata(key string) {\n\tf.metadataMu.Lock()\n\tdelete(f.metadata, key)\n\tf.metadataMu.Unlock()\n}\n\n// Event initiates a state transition with the named event.\n//\n// The call takes a variable number of arguments that will be passed to the\n// callback, if defined.\n//\n// It will return nil if the state change is ok or one of these errors:\n//\n// - event X inappropriate because previous transition did not complete\n//\n// - event X inappropriate in current state Y\n//\n// - event X does not exist\n//\n// - internal error on state transition\n//\n// The last error should never occur in this situation and is a sign of an\n// internal bug.\nfunc (f *FSM) Event(ctx context.Context, event string, args ...interface{}) error {\n\tf.eventMu.Lock()\n\t// in order to always unlock the event mutex, the defer is added\n\t// in case the state transition goes through and enter/after callbacks\n\t// are called; because these must be able to trigger new state\n\t// transitions, it is explicitly unlocked in the code below\n\tvar unlocked bool\n\tdefer func() {\n\t\tif !unlocked {\n\t\t\tf.eventMu.Unlock()\n\t\t}\n\t}()\n\n\tf.stateMu.RLock()\n\tdefer f.stateMu.RUnlock()\n\n\tif f.transition != nil {\n\t\treturn InTransitionError{event}\n\t}\n\n\tdst, ok := f.transitions[eKey{event, f.current}]\n\tif !ok {\n\t\tfor ekey := range f.transitions {\n\t\t\tif ekey.event == event {\n\t\t\t\treturn InvalidEventError{event, f.current}\n\t\t\t}\n\t\t}\n\t\treturn UnknownEventError{event}\n\t}\n\n\tctx, cancel := context.WithCancel(ctx)\n\tdefer cancel()\n\te := &Event{f, event, f.current, dst, nil, args, false, false, cancel}\n\n\terr := f.beforeEventCallbacks(ctx, e)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif f.current == dst {\n\t\tf.stateMu.RUnlock()\n\t\tdefer f.stateMu.RLock()\n\t\tf.eventMu.Unlock()\n\t\tunlocked = true\n\t\tf.afterEventCallbacks(ctx, e)\n\t\treturn NoTransitionError{e.Err}\n\t}\n\n\t// Setup the transition, call it later.\n\ttransitionFunc := func(ctx context.Context, async bool) func() {\n\t\treturn func() {\n\t\t\tif ctx.Err() != nil {\n\t\t\t\tif e.Err == nil {\n\t\t\t\t\te.Err = ctx.Err()\n\t\t\t\t}\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tf.stateMu.Lock()\n\t\t\tf.current = dst\n\t\t\tf.transition = nil // treat the state transition as done\n\t\t\tf.stateMu.Unlock()\n\n\t\t\t// at this point, we unlock the event mutex in order to allow\n\t\t\t// enter state callbacks to trigger another transition\n\t\t\t// for aynchronous state transitions this doesn't happen because\n\t\t\t// the event mutex has already been unlocked\n\t\t\tif !async {\n\t\t\t\tf.eventMu.Unlock()\n\t\t\t\tunlocked = true\n\t\t\t}\n\t\t\tf.enterStateCallbacks(ctx, e)\n\t\t\tf.afterEventCallbacks(ctx, e)\n\t\t}\n\t}\n\n\tf.transition = transitionFunc(ctx, false)\n\n\tif err = f.leaveStateCallbacks(ctx, e); err != nil {\n\t\tif _, ok := err.(CanceledError); ok {\n\t\t\tf.transition = nil\n\t\t} else if asyncError, ok := err.(AsyncError); ok {\n\t\t\t// setup a new context in order for async state transitions to work correctly\n\t\t\t// this \"uncancels\" the original context which ignores its cancelation\n\t\t\t// but keeps the values of the original context available to callers\n\t\t\tctx, cancel := uncancelContext(ctx)\n\t\t\te.cancelFunc = cancel\n\t\t\tasyncError.Ctx = ctx\n\t\t\tasyncError.CancelTransition = cancel\n\t\t\tf.transition = transitionFunc(ctx, true)\n\t\t\treturn asyncError\n\t\t}\n\t\treturn err\n\t}\n\n\t// Perform the rest of the transition, if not asynchronous.\n\tf.stateMu.RUnlock()\n\tdefer f.stateMu.RLock()\n\terr = f.doTransition()\n\tif err != nil {\n\t\treturn InternalError{}\n\t}\n\n\treturn e.Err\n}\n\n// Transition wraps transitioner.transition.\nfunc (f *FSM) Transition() error {\n\tf.eventMu.Lock()\n\tdefer f.eventMu.Unlock()\n\treturn f.doTransition()\n}\n\n// doTransition wraps transitioner.transition.\nfunc (f *FSM) doTransition() error {\n\treturn f.transitionerObj.transition(f)\n}\n\n// transitionerStruct is the default implementation of the transitioner\n// interface. Other implementations can be swapped in for testing.\ntype transitionerStruct struct{}\n\n// Transition completes an asynchronous state change.\n//\n// The callback for leave_<STATE> must previously have called Async on its\n// event to have initiated an asynchronous state transition.\nfunc (t transitionerStruct) transition(f *FSM) error {\n\tif f.transition == nil {\n\t\treturn NotInTransitionError{}\n\t}\n\tf.transition()\n\treturn nil\n}\n\n// beforeEventCallbacks calls the before_ callbacks, first the named then the\n// general version.\nfunc (f *FSM) beforeEventCallbacks(ctx context.Context, e *Event) error {\n\tif fn, ok := f.callbacks[cKey{e.Event, callbackBeforeEvent}]; ok {\n\t\tfn(ctx, e)\n\t\tif e.canceled {\n\t\t\treturn CanceledError{e.Err}\n\t\t}\n\t}\n\tif fn, ok := f.callbacks[cKey{\"\", callbackBeforeEvent}]; ok {\n\t\tfn(ctx, e)\n\t\tif e.canceled {\n\t\t\treturn CanceledError{e.Err}\n\t\t}\n\t}\n\treturn nil\n}\n\n// leaveStateCallbacks calls the leave_ callbacks, first the named then the\n// general version.\nfunc (f *FSM) leaveStateCallbacks(ctx context.Context, e *Event) error {\n\tif fn, ok := f.callbacks[cKey{f.current, callbackLeaveState}]; ok {\n\t\tfn(ctx, e)\n\t\tif e.canceled {\n\t\t\treturn CanceledError{e.Err}\n\t\t} else if e.async {\n\t\t\treturn AsyncError{Err: e.Err}\n\t\t}\n\t}\n\tif fn, ok := f.callbacks[cKey{\"\", callbackLeaveState}]; ok {\n\t\tfn(ctx, e)\n\t\tif e.canceled {\n\t\t\treturn CanceledError{e.Err}\n\t\t} else if e.async {\n\t\t\treturn AsyncError{Err: e.Err}\n\t\t}\n\t}\n\treturn nil\n}\n\n// enterStateCallbacks calls the enter_ callbacks, first the named then the\n// general version.\nfunc (f *FSM) enterStateCallbacks(ctx context.Context, e *Event) {\n\tif fn, ok := f.callbacks[cKey{f.current, callbackEnterState}]; ok {\n\t\tfn(ctx, e)\n\t}\n\tif fn, ok := f.callbacks[cKey{\"\", callbackEnterState}]; ok {\n\t\tfn(ctx, e)\n\t}\n}\n\n// afterEventCallbacks calls the after_ callbacks, first the named then the\n// general version.\nfunc (f *FSM) afterEventCallbacks(ctx context.Context, e *Event) {\n\tif fn, ok := f.callbacks[cKey{e.Event, callbackAfterEvent}]; ok {\n\t\tfn(ctx, e)\n\t}\n\tif fn, ok := f.callbacks[cKey{\"\", callbackAfterEvent}]; ok {\n\t\tfn(ctx, e)\n\t}\n}\n\nconst (\n\tcallbackNone int = iota\n\tcallbackBeforeEvent\n\tcallbackLeaveState\n\tcallbackEnterState\n\tcallbackAfterEvent\n)\n\n// cKey is a struct key used for keeping the callbacks mapped to a target.\ntype cKey struct {\n\t// target is either the name of a state or an event depending on which\n\t// callback type the key refers to. It can also be \"\" for a non-targeted\n\t// callback like before_event.\n\ttarget string\n\n\t// callbackType is the situation when the callback will be run.\n\tcallbackType int\n}\n\n// eKey is a struct key used for storing the transition map.\ntype eKey struct {\n\t// event is the name of the event that the keys refers to.\n\tevent string\n\n\t// src is the source from where the event can transition.\n\tsrc string\n}\n"
        },
        {
          "name": "fsm_test.go",
          "type": "blob",
          "size": 23.755859375,
          "content": "// Copyright (c) 2013 - Max Persson <max@looplab.se>\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage fsm\n\nimport (\n\t\"context\"\n\t\"errors\"\n\t\"fmt\"\n\t\"sort\"\n\t\"sync\"\n\t\"testing\"\n\t\"time\"\n)\n\ntype fakeTransitionerObj struct {\n}\n\nfunc (t fakeTransitionerObj) transition(f *FSM) error {\n\treturn &InternalError{}\n}\n\nfunc TestSameState(t *testing.T) {\n\tfsm := NewFSM(\n\t\t\"start\",\n\t\tEvents{\n\t\t\t{Name: \"run\", Src: []string{\"start\"}, Dst: \"start\"},\n\t\t},\n\t\tCallbacks{},\n\t)\n\t_ = fsm.Event(context.Background(), \"run\")\n\tif fsm.Current() != \"start\" {\n\t\tt.Error(\"expected state to be 'start'\")\n\t}\n}\n\nfunc TestSetState(t *testing.T) {\n\tfsm := NewFSM(\n\t\t\"walking\",\n\t\tEvents{\n\t\t\t{Name: \"walk\", Src: []string{\"start\"}, Dst: \"walking\"},\n\t\t},\n\t\tCallbacks{},\n\t)\n\tfsm.SetState(\"start\")\n\tif fsm.Current() != \"start\" {\n\t\tt.Error(\"expected state to be 'walking'\")\n\t}\n\terr := fsm.Event(context.Background(), \"walk\")\n\tif err != nil {\n\t\tt.Error(\"transition is expected no error\")\n\t}\n}\n\nfunc TestBadTransition(t *testing.T) {\n\tfsm := NewFSM(\n\t\t\"start\",\n\t\tEvents{\n\t\t\t{Name: \"run\", Src: []string{\"start\"}, Dst: \"running\"},\n\t\t},\n\t\tCallbacks{},\n\t)\n\tfsm.transitionerObj = new(fakeTransitionerObj)\n\terr := fsm.Event(context.Background(), \"run\")\n\tif err == nil {\n\t\tt.Error(\"bad transition should give an error\")\n\t}\n}\n\nfunc TestInappropriateEvent(t *testing.T) {\n\tfsm := NewFSM(\n\t\t\"closed\",\n\t\tEvents{\n\t\t\t{Name: \"open\", Src: []string{\"closed\"}, Dst: \"open\"},\n\t\t\t{Name: \"close\", Src: []string{\"open\"}, Dst: \"closed\"},\n\t\t},\n\t\tCallbacks{},\n\t)\n\terr := fsm.Event(context.Background(), \"close\")\n\tif e, ok := err.(InvalidEventError); !ok && e.Event != \"close\" && e.State != \"closed\" {\n\t\tt.Error(\"expected 'InvalidEventError' with correct state and event\")\n\t}\n}\n\nfunc TestInvalidEvent(t *testing.T) {\n\tfsm := NewFSM(\n\t\t\"closed\",\n\t\tEvents{\n\t\t\t{Name: \"open\", Src: []string{\"closed\"}, Dst: \"open\"},\n\t\t\t{Name: \"close\", Src: []string{\"open\"}, Dst: \"closed\"},\n\t\t},\n\t\tCallbacks{},\n\t)\n\terr := fsm.Event(context.Background(), \"lock\")\n\tif e, ok := err.(UnknownEventError); !ok && e.Event != \"close\" {\n\t\tt.Error(\"expected 'UnknownEventError' with correct event\")\n\t}\n}\n\nfunc TestMultipleSources(t *testing.T) {\n\tfsm := NewFSM(\n\t\t\"one\",\n\t\tEvents{\n\t\t\t{Name: \"first\", Src: []string{\"one\"}, Dst: \"two\"},\n\t\t\t{Name: \"second\", Src: []string{\"two\"}, Dst: \"three\"},\n\t\t\t{Name: \"reset\", Src: []string{\"one\", \"two\", \"three\"}, Dst: \"one\"},\n\t\t},\n\t\tCallbacks{},\n\t)\n\n\terr := fsm.Event(context.Background(), \"first\")\n\tif err != nil {\n\t\tt.Errorf(\"transition failed %v\", err)\n\t}\n\tif fsm.Current() != \"two\" {\n\t\tt.Error(\"expected state to be 'two'\")\n\t}\n\terr = fsm.Event(context.Background(), \"reset\")\n\tif err != nil {\n\t\tt.Errorf(\"transition failed %v\", err)\n\t}\n\tif fsm.Current() != \"one\" {\n\t\tt.Error(\"expected state to be 'one'\")\n\t}\n\terr = fsm.Event(context.Background(), \"first\")\n\tif err != nil {\n\t\tt.Errorf(\"transition failed %v\", err)\n\t}\n\terr = fsm.Event(context.Background(), \"second\")\n\tif err != nil {\n\t\tt.Errorf(\"transition failed %v\", err)\n\t}\n\tif fsm.Current() != \"three\" {\n\t\tt.Error(\"expected state to be 'three'\")\n\t}\n\terr = fsm.Event(context.Background(), \"reset\")\n\tif err != nil {\n\t\tt.Errorf(\"transition failed %v\", err)\n\t}\n\tif fsm.Current() != \"one\" {\n\t\tt.Error(\"expected state to be 'one'\")\n\t}\n}\n\nfunc TestMultipleEvents(t *testing.T) {\n\tfsm := NewFSM(\n\t\t\"start\",\n\t\tEvents{\n\t\t\t{Name: \"first\", Src: []string{\"start\"}, Dst: \"one\"},\n\t\t\t{Name: \"second\", Src: []string{\"start\"}, Dst: \"two\"},\n\t\t\t{Name: \"reset\", Src: []string{\"one\"}, Dst: \"reset_one\"},\n\t\t\t{Name: \"reset\", Src: []string{\"two\"}, Dst: \"reset_two\"},\n\t\t\t{Name: \"reset\", Src: []string{\"reset_one\", \"reset_two\"}, Dst: \"start\"},\n\t\t},\n\t\tCallbacks{},\n\t)\n\n\terr := fsm.Event(context.Background(), \"first\")\n\tif err != nil {\n\t\tt.Errorf(\"transition failed %v\", err)\n\t}\n\terr = fsm.Event(context.Background(), \"reset\")\n\tif err != nil {\n\t\tt.Errorf(\"transition failed %v\", err)\n\t}\n\tif fsm.Current() != \"reset_one\" {\n\t\tt.Error(\"expected state to be 'reset_one'\")\n\t}\n\terr = fsm.Event(context.Background(), \"reset\")\n\tif err != nil {\n\t\tt.Errorf(\"transition failed %v\", err)\n\t}\n\tif fsm.Current() != \"start\" {\n\t\tt.Error(\"expected state to be 'start'\")\n\t}\n\n\terr = fsm.Event(context.Background(), \"second\")\n\tif err != nil {\n\t\tt.Errorf(\"transition failed %v\", err)\n\t}\n\terr = fsm.Event(context.Background(), \"reset\")\n\tif err != nil {\n\t\tt.Errorf(\"transition failed %v\", err)\n\t}\n\tif fsm.Current() != \"reset_two\" {\n\t\tt.Error(\"expected state to be 'reset_two'\")\n\t}\n\terr = fsm.Event(context.Background(), \"reset\")\n\tif err != nil {\n\t\tt.Errorf(\"transition failed %v\", err)\n\t}\n\tif fsm.Current() != \"start\" {\n\t\tt.Error(\"expected state to be 'start'\")\n\t}\n}\n\nfunc TestGenericCallbacks(t *testing.T) {\n\tbeforeEvent := false\n\tleaveState := false\n\tenterState := false\n\tafterEvent := false\n\n\tfsm := NewFSM(\n\t\t\"start\",\n\t\tEvents{\n\t\t\t{Name: \"run\", Src: []string{\"start\"}, Dst: \"end\"},\n\t\t},\n\t\tCallbacks{\n\t\t\t\"before_event\": func(_ context.Context, e *Event) {\n\t\t\t\tbeforeEvent = true\n\t\t\t},\n\t\t\t\"leave_state\": func(_ context.Context, e *Event) {\n\t\t\t\tleaveState = true\n\t\t\t},\n\t\t\t\"enter_state\": func(_ context.Context, e *Event) {\n\t\t\t\tenterState = true\n\t\t\t},\n\t\t\t\"after_event\": func(_ context.Context, e *Event) {\n\t\t\t\tafterEvent = true\n\t\t\t},\n\t\t},\n\t)\n\n\terr := fsm.Event(context.Background(), \"run\")\n\tif err != nil {\n\t\tt.Errorf(\"transition failed %v\", err)\n\t}\n\tif !(beforeEvent && leaveState && enterState && afterEvent) {\n\t\tt.Error(\"expected all callbacks to be called\")\n\t}\n}\n\nfunc TestSpecificCallbacks(t *testing.T) {\n\tbeforeEvent := false\n\tleaveState := false\n\tenterState := false\n\tafterEvent := false\n\n\tfsm := NewFSM(\n\t\t\"start\",\n\t\tEvents{\n\t\t\t{Name: \"run\", Src: []string{\"start\"}, Dst: \"end\"},\n\t\t},\n\t\tCallbacks{\n\t\t\t\"before_run\": func(_ context.Context, e *Event) {\n\t\t\t\tbeforeEvent = true\n\t\t\t},\n\t\t\t\"leave_start\": func(_ context.Context, e *Event) {\n\t\t\t\tleaveState = true\n\t\t\t},\n\t\t\t\"enter_end\": func(_ context.Context, e *Event) {\n\t\t\t\tenterState = true\n\t\t\t},\n\t\t\t\"after_run\": func(_ context.Context, e *Event) {\n\t\t\t\tafterEvent = true\n\t\t\t},\n\t\t},\n\t)\n\n\terr := fsm.Event(context.Background(), \"run\")\n\tif err != nil {\n\t\tt.Errorf(\"transition failed %v\", err)\n\t}\n\tif !(beforeEvent && leaveState && enterState && afterEvent) {\n\t\tt.Error(\"expected all callbacks to be called\")\n\t}\n}\n\nfunc TestSpecificCallbacksShortform(t *testing.T) {\n\tenterState := false\n\tafterEvent := false\n\n\tfsm := NewFSM(\n\t\t\"start\",\n\t\tEvents{\n\t\t\t{Name: \"run\", Src: []string{\"start\"}, Dst: \"end\"},\n\t\t},\n\t\tCallbacks{\n\t\t\t\"end\": func(_ context.Context, e *Event) {\n\t\t\t\tenterState = true\n\t\t\t},\n\t\t\t\"run\": func(_ context.Context, e *Event) {\n\t\t\t\tafterEvent = true\n\t\t\t},\n\t\t},\n\t)\n\n\terr := fsm.Event(context.Background(), \"run\")\n\tif err != nil {\n\t\tt.Errorf(\"transition failed %v\", err)\n\t}\n\tif !(enterState && afterEvent) {\n\t\tt.Error(\"expected all callbacks to be called\")\n\t}\n}\n\nfunc TestBeforeEventWithoutTransition(t *testing.T) {\n\tbeforeEvent := true\n\n\tfsm := NewFSM(\n\t\t\"start\",\n\t\tEvents{\n\t\t\t{Name: \"dontrun\", Src: []string{\"start\"}, Dst: \"start\"},\n\t\t},\n\t\tCallbacks{\n\t\t\t\"before_event\": func(_ context.Context, e *Event) {\n\t\t\t\tbeforeEvent = true\n\t\t\t},\n\t\t},\n\t)\n\n\terr := fsm.Event(context.Background(), \"dontrun\")\n\tif e, ok := err.(NoTransitionError); !ok && e.Err != nil {\n\t\tt.Error(\"expected 'NoTransitionError' without custom error\")\n\t}\n\n\tif fsm.Current() != \"start\" {\n\t\tt.Error(\"expected state to be 'start'\")\n\t}\n\tif !beforeEvent {\n\t\tt.Error(\"expected callback to be called\")\n\t}\n}\n\nfunc TestCancelBeforeGenericEvent(t *testing.T) {\n\tfsm := NewFSM(\n\t\t\"start\",\n\t\tEvents{\n\t\t\t{Name: \"run\", Src: []string{\"start\"}, Dst: \"end\"},\n\t\t},\n\t\tCallbacks{\n\t\t\t\"before_event\": func(_ context.Context, e *Event) {\n\t\t\t\te.Cancel()\n\t\t\t},\n\t\t},\n\t)\n\t_ = fsm.Event(context.Background(), \"run\")\n\tif fsm.Current() != \"start\" {\n\t\tt.Error(\"expected state to be 'start'\")\n\t}\n}\n\nfunc TestCancelBeforeSpecificEvent(t *testing.T) {\n\tfsm := NewFSM(\n\t\t\"start\",\n\t\tEvents{\n\t\t\t{Name: \"run\", Src: []string{\"start\"}, Dst: \"end\"},\n\t\t},\n\t\tCallbacks{\n\t\t\t\"before_run\": func(_ context.Context, e *Event) {\n\t\t\t\te.Cancel()\n\t\t\t},\n\t\t},\n\t)\n\t_ = fsm.Event(context.Background(), \"run\")\n\tif fsm.Current() != \"start\" {\n\t\tt.Error(\"expected state to be 'start'\")\n\t}\n}\n\nfunc TestCancelLeaveGenericState(t *testing.T) {\n\tfsm := NewFSM(\n\t\t\"start\",\n\t\tEvents{\n\t\t\t{Name: \"run\", Src: []string{\"start\"}, Dst: \"end\"},\n\t\t},\n\t\tCallbacks{\n\t\t\t\"leave_state\": func(_ context.Context, e *Event) {\n\t\t\t\te.Cancel()\n\t\t\t},\n\t\t},\n\t)\n\t_ = fsm.Event(context.Background(), \"run\")\n\tif fsm.Current() != \"start\" {\n\t\tt.Error(\"expected state to be 'start'\")\n\t}\n}\n\nfunc TestCancelLeaveSpecificState(t *testing.T) {\n\tfsm := NewFSM(\n\t\t\"start\",\n\t\tEvents{\n\t\t\t{Name: \"run\", Src: []string{\"start\"}, Dst: \"end\"},\n\t\t},\n\t\tCallbacks{\n\t\t\t\"leave_start\": func(_ context.Context, e *Event) {\n\t\t\t\te.Cancel()\n\t\t\t},\n\t\t},\n\t)\n\t_ = fsm.Event(context.Background(), \"run\")\n\tif fsm.Current() != \"start\" {\n\t\tt.Error(\"expected state to be 'start'\")\n\t}\n}\n\nfunc TestCancelWithError(t *testing.T) {\n\tfsm := NewFSM(\n\t\t\"start\",\n\t\tEvents{\n\t\t\t{Name: \"run\", Src: []string{\"start\"}, Dst: \"end\"},\n\t\t},\n\t\tCallbacks{\n\t\t\t\"before_event\": func(_ context.Context, e *Event) {\n\t\t\t\te.Cancel(fmt.Errorf(\"error\"))\n\t\t\t},\n\t\t},\n\t)\n\terr := fsm.Event(context.Background(), \"run\")\n\tif _, ok := err.(CanceledError); !ok {\n\t\tt.Error(\"expected only 'CanceledError'\")\n\t}\n\n\tif e, ok := err.(CanceledError); ok && e.Err.Error() != \"error\" {\n\t\tt.Error(\"expected 'CanceledError' with correct custom error\")\n\t}\n\n\tif fsm.Current() != \"start\" {\n\t\tt.Error(\"expected state to be 'start'\")\n\t}\n}\n\nfunc TestAsyncTransitionGenericState(t *testing.T) {\n\tfsm := NewFSM(\n\t\t\"start\",\n\t\tEvents{\n\t\t\t{Name: \"run\", Src: []string{\"start\"}, Dst: \"end\"},\n\t\t},\n\t\tCallbacks{\n\t\t\t\"leave_state\": func(_ context.Context, e *Event) {\n\t\t\t\te.Async()\n\t\t\t},\n\t\t},\n\t)\n\t_ = fsm.Event(context.Background(), \"run\")\n\tif fsm.Current() != \"start\" {\n\t\tt.Error(\"expected state to be 'start'\")\n\t}\n\terr := fsm.Transition()\n\tif err != nil {\n\t\tt.Errorf(\"transition failed %v\", err)\n\t}\n\tif fsm.Current() != \"end\" {\n\t\tt.Error(\"expected state to be 'end'\")\n\t}\n}\n\nfunc TestAsyncTransitionSpecificState(t *testing.T) {\n\tfsm := NewFSM(\n\t\t\"start\",\n\t\tEvents{\n\t\t\t{Name: \"run\", Src: []string{\"start\"}, Dst: \"end\"},\n\t\t},\n\t\tCallbacks{\n\t\t\t\"leave_start\": func(_ context.Context, e *Event) {\n\t\t\t\te.Async()\n\t\t\t},\n\t\t},\n\t)\n\t_ = fsm.Event(context.Background(), \"run\")\n\tif fsm.Current() != \"start\" {\n\t\tt.Error(\"expected state to be 'start'\")\n\t}\n\terr := fsm.Transition()\n\tif err != nil {\n\t\tt.Errorf(\"transition failed %v\", err)\n\t}\n\tif fsm.Current() != \"end\" {\n\t\tt.Error(\"expected state to be 'end'\")\n\t}\n}\n\nfunc TestAsyncTransitionInProgress(t *testing.T) {\n\tfsm := NewFSM(\n\t\t\"start\",\n\t\tEvents{\n\t\t\t{Name: \"run\", Src: []string{\"start\"}, Dst: \"end\"},\n\t\t\t{Name: \"reset\", Src: []string{\"end\"}, Dst: \"start\"},\n\t\t},\n\t\tCallbacks{\n\t\t\t\"leave_start\": func(_ context.Context, e *Event) {\n\t\t\t\te.Async()\n\t\t\t},\n\t\t},\n\t)\n\t_ = fsm.Event(context.Background(), \"run\")\n\terr := fsm.Event(context.Background(), \"reset\")\n\tif e, ok := err.(InTransitionError); !ok && e.Event != \"reset\" {\n\t\tt.Error(\"expected 'InTransitionError' with correct state\")\n\t}\n\terr = fsm.Transition()\n\tif err != nil {\n\t\tt.Errorf(\"transition failed %v\", err)\n\t}\n\terr = fsm.Event(context.Background(), \"reset\")\n\tif err != nil {\n\t\tt.Errorf(\"transition failed %v\", err)\n\t}\n\tif fsm.Current() != \"start\" {\n\t\tt.Error(\"expected state to be 'start'\")\n\t}\n}\n\nfunc TestAsyncTransitionNotInProgress(t *testing.T) {\n\tfsm := NewFSM(\n\t\t\"start\",\n\t\tEvents{\n\t\t\t{Name: \"run\", Src: []string{\"start\"}, Dst: \"end\"},\n\t\t\t{Name: \"reset\", Src: []string{\"end\"}, Dst: \"start\"},\n\t\t},\n\t\tCallbacks{},\n\t)\n\terr := fsm.Transition()\n\tif _, ok := err.(NotInTransitionError); !ok {\n\t\tt.Error(\"expected 'NotInTransitionError'\")\n\t}\n}\n\nfunc TestCancelAsyncTransition(t *testing.T) {\n\tfsm := NewFSM(\n\t\t\"start\",\n\t\tEvents{\n\t\t\t{Name: \"run\", Src: []string{\"start\"}, Dst: \"end\"},\n\t\t},\n\t\tCallbacks{\n\t\t\t\"leave_start\": func(_ context.Context, e *Event) {\n\t\t\t\te.Async()\n\t\t\t},\n\t\t},\n\t)\n\terr := fsm.Event(context.Background(), \"run\")\n\tasyncError, ok := err.(AsyncError)\n\tif !ok {\n\t\tt.Errorf(\"expected error to be 'AsyncError', got %v\", err)\n\t}\n\tvar asyncStateTransitionWasCanceled = make(chan struct{})\n\tgo func() {\n\t\t<-asyncError.Ctx.Done()\n\t\tclose(asyncStateTransitionWasCanceled)\n\t}()\n\tasyncError.CancelTransition()\n\t<-asyncStateTransitionWasCanceled\n\n\tif err = fsm.Transition(); err != nil {\n\t\tt.Errorf(\"expected no error, got %v\", err)\n\t}\n\tif fsm.Current() != \"start\" {\n\t\tt.Error(\"expected state to be 'start'\")\n\t}\n}\n\nfunc TestCallbackNoError(t *testing.T) {\n\tfsm := NewFSM(\n\t\t\"start\",\n\t\tEvents{\n\t\t\t{Name: \"run\", Src: []string{\"start\"}, Dst: \"end\"},\n\t\t},\n\t\tCallbacks{\n\t\t\t\"run\": func(_ context.Context, e *Event) {\n\t\t\t},\n\t\t},\n\t)\n\te := fsm.Event(context.Background(), \"run\")\n\tif e != nil {\n\t\tt.Error(\"expected no error\")\n\t}\n}\n\nfunc TestCallbackError(t *testing.T) {\n\tfsm := NewFSM(\n\t\t\"start\",\n\t\tEvents{\n\t\t\t{Name: \"run\", Src: []string{\"start\"}, Dst: \"end\"},\n\t\t},\n\t\tCallbacks{\n\t\t\t\"run\": func(_ context.Context, e *Event) {\n\t\t\t\te.Err = fmt.Errorf(\"error\")\n\t\t\t},\n\t\t},\n\t)\n\te := fsm.Event(context.Background(), \"run\")\n\tif e.Error() != \"error\" {\n\t\tt.Error(\"expected error to be 'error'\")\n\t}\n}\n\nfunc TestCallbackArgs(t *testing.T) {\n\tfsm := NewFSM(\n\t\t\"start\",\n\t\tEvents{\n\t\t\t{Name: \"run\", Src: []string{\"start\"}, Dst: \"end\"},\n\t\t},\n\t\tCallbacks{\n\t\t\t\"run\": func(_ context.Context, e *Event) {\n\t\t\t\tif len(e.Args) != 1 {\n\t\t\t\t\tt.Error(\"too few arguments\")\n\t\t\t\t}\n\t\t\t\targ, ok := e.Args[0].(string)\n\t\t\t\tif !ok {\n\t\t\t\t\tt.Error(\"not a string argument\")\n\t\t\t\t}\n\t\t\t\tif arg != \"test\" {\n\t\t\t\t\tt.Error(\"incorrect argument\")\n\t\t\t\t}\n\t\t\t},\n\t\t},\n\t)\n\terr := fsm.Event(context.Background(), \"run\", \"test\")\n\tif err != nil {\n\t\tt.Errorf(\"transition failed %v\", err)\n\t}\n}\n\nfunc TestCallbackPanic(t *testing.T) {\n\tpanicMsg := \"unexpected panic\"\n\tdefer func() {\n\t\tr := recover()\n\t\tif r == nil || r != panicMsg {\n\t\t\tt.Errorf(\"expected panic message to be '%s', got %v\", panicMsg, r)\n\t\t}\n\t}()\n\tfsm := NewFSM(\n\t\t\"start\",\n\t\tEvents{\n\t\t\t{Name: \"run\", Src: []string{\"start\"}, Dst: \"end\"},\n\t\t},\n\t\tCallbacks{\n\t\t\t\"run\": func(_ context.Context, e *Event) {\n\t\t\t\tpanic(panicMsg)\n\t\t\t},\n\t\t},\n\t)\n\te := fsm.Event(context.Background(), \"run\")\n\tif e.Error() != \"error\" {\n\t\tt.Error(\"expected error to be 'error'\")\n\t}\n}\n\nfunc TestNoDeadLock(t *testing.T) {\n\tvar fsm *FSM\n\tfsm = NewFSM(\n\t\t\"start\",\n\t\tEvents{\n\t\t\t{Name: \"run\", Src: []string{\"start\"}, Dst: \"end\"},\n\t\t},\n\t\tCallbacks{\n\t\t\t\"run\": func(_ context.Context, e *Event) {\n\t\t\t\tfsm.Current() // Should not result in a panic / deadlock\n\t\t\t},\n\t\t},\n\t)\n\terr := fsm.Event(context.Background(), \"run\")\n\tif err != nil {\n\t\tt.Errorf(\"transition failed %v\", err)\n\t}\n}\n\nfunc TestThreadSafetyRaceCondition(t *testing.T) {\n\tfsm := NewFSM(\n\t\t\"start\",\n\t\tEvents{\n\t\t\t{Name: \"run\", Src: []string{\"start\"}, Dst: \"end\"},\n\t\t},\n\t\tCallbacks{\n\t\t\t\"run\": func(_ context.Context, e *Event) {\n\t\t\t},\n\t\t},\n\t)\n\tvar wg sync.WaitGroup\n\twg.Add(1)\n\tgo func() {\n\t\tdefer wg.Done()\n\t\t_ = fsm.Current()\n\t}()\n\terr := fsm.Event(context.Background(), \"run\")\n\tif err != nil {\n\t\tt.Errorf(\"transition failed %v\", err)\n\t}\n\twg.Wait()\n}\n\nfunc TestDoubleTransition(t *testing.T) {\n\tvar fsm *FSM\n\tvar wg sync.WaitGroup\n\twg.Add(2)\n\tfsm = NewFSM(\n\t\t\"start\",\n\t\tEvents{\n\t\t\t{Name: \"run\", Src: []string{\"start\"}, Dst: \"end\"},\n\t\t},\n\t\tCallbacks{\n\t\t\t\"before_run\": func(_ context.Context, e *Event) {\n\t\t\t\twg.Done()\n\t\t\t\t// Imagine a concurrent event coming in of the same type while\n\t\t\t\t// the data access mutex is unlocked because the current transition\n\t\t\t\t// is running its event callbacks, getting around the \"active\"\n\t\t\t\t// transition checks\n\t\t\t\tif len(e.Args) == 0 {\n\t\t\t\t\t// Must be concurrent so the test may pass when we add a mutex that synchronizes\n\t\t\t\t\t// calls to Event(...). It will then fail as an inappropriate transition as we\n\t\t\t\t\t// have changed state.\n\t\t\t\t\tgo func() {\n\t\t\t\t\t\tif err := fsm.Event(context.Background(), \"run\", \"second run\"); err != nil {\n\t\t\t\t\t\t\tfmt.Println(err)\n\t\t\t\t\t\t\twg.Done() // It should fail, and then we unfreeze the test.\n\t\t\t\t\t\t}\n\t\t\t\t\t}()\n\t\t\t\t\ttime.Sleep(20 * time.Millisecond)\n\t\t\t\t} else {\n\t\t\t\t\tpanic(\"Was able to reissue an event mid-transition\")\n\t\t\t\t}\n\t\t\t},\n\t\t},\n\t)\n\tif err := fsm.Event(context.Background(), \"run\"); err != nil {\n\t\tfmt.Println(err)\n\t}\n\twg.Wait()\n}\n\nfunc TestTransitionInCallbacks(t *testing.T) {\n\tvar fsm *FSM\n\tvar afterFinishCalled bool\n\tfsm = NewFSM(\n\t\t\"start\",\n\t\tEvents{\n\t\t\t{Name: \"run\", Src: []string{\"start\"}, Dst: \"end\"},\n\t\t\t{Name: \"finish\", Src: []string{\"end\"}, Dst: \"finished\"},\n\t\t\t{Name: \"reset\", Src: []string{\"end\", \"finished\"}, Dst: \"start\"},\n\t\t},\n\t\tCallbacks{\n\t\t\t\"enter_end\": func(ctx context.Context, e *Event) {\n\t\t\t\tif err := e.FSM.Event(ctx, \"finish\"); err != nil {\n\t\t\t\t\tfmt.Println(err)\n\t\t\t\t}\n\t\t\t},\n\t\t\t\"after_finish\": func(ctx context.Context, e *Event) {\n\t\t\t\tafterFinishCalled = true\n\t\t\t\tif e.Src != \"end\" {\n\t\t\t\t\tpanic(fmt.Sprintf(\"source should have been 'end' but was '%s'\", e.Src))\n\t\t\t\t}\n\t\t\t\tif err := e.FSM.Event(ctx, \"reset\"); err != nil {\n\t\t\t\t\tfmt.Println(err)\n\t\t\t\t}\n\t\t\t},\n\t\t},\n\t)\n\n\tif err := fsm.Event(context.Background(), \"run\"); err != nil {\n\t\tt.Errorf(\"expected no error, got %v\", err)\n\t}\n\tif !afterFinishCalled {\n\t\tt.Error(\"expected after_finish callback to have been executed but it wasn't\")\n\t}\n\n\tcurrentState := fsm.Current()\n\tif currentState != \"start\" {\n\t\tt.Errorf(\"expected state to be 'start', was '%s'\", currentState)\n\t}\n}\n\nfunc TestContextInCallbacks(t *testing.T) {\n\tvar fsm *FSM\n\tvar enterEndAsyncWorkDone = make(chan struct{})\n\tfsm = NewFSM(\n\t\t\"start\",\n\t\tEvents{\n\t\t\t{Name: \"run\", Src: []string{\"start\"}, Dst: \"end\"},\n\t\t\t{Name: \"finish\", Src: []string{\"end\"}, Dst: \"finished\"},\n\t\t\t{Name: \"reset\", Src: []string{\"end\", \"finished\"}, Dst: \"start\"},\n\t\t},\n\t\tCallbacks{\n\t\t\t\"enter_end\": func(ctx context.Context, e *Event) {\n\t\t\t\tgo func() {\n\t\t\t\t\t<-ctx.Done()\n\t\t\t\t\tclose(enterEndAsyncWorkDone)\n\t\t\t\t}()\n\n\t\t\t\t<-ctx.Done()\n\t\t\t\tif err := e.FSM.Event(ctx, \"finish\"); err != nil {\n\t\t\t\t\te.Err = fmt.Errorf(\"transitioning to the finished state failed: %w\", err)\n\t\t\t\t}\n\t\t\t},\n\t\t},\n\t)\n\n\tctx, cancel := context.WithCancel(context.Background())\n\tgo func() {\n\t\tcancel()\n\t}()\n\terr := fsm.Event(ctx, \"run\")\n\tif !errors.Is(err, context.Canceled) {\n\t\tt.Errorf(\"expected 'context canceled' error, got %v\", err)\n\t}\n\t<-enterEndAsyncWorkDone\n\n\tcurrentState := fsm.Current()\n\tif currentState != \"end\" {\n\t\tt.Errorf(\"expected state to be 'end', was '%s'\", currentState)\n\t}\n}\n\nfunc TestNoTransition(t *testing.T) {\n\tfsm := NewFSM(\n\t\t\"start\",\n\t\tEvents{\n\t\t\t{Name: \"run\", Src: []string{\"start\"}, Dst: \"start\"},\n\t\t},\n\t\tCallbacks{},\n\t)\n\terr := fsm.Event(context.Background(), \"run\")\n\tif _, ok := err.(NoTransitionError); !ok {\n\t\tt.Error(\"expected 'NoTransitionError'\")\n\t}\n}\n\nfunc TestNoTransitionAfterEventCallbackTransition(t *testing.T) {\n\tvar fsm *FSM\n\tfsm = NewFSM(\n\t\t\"start\",\n\t\tEvents{\n\t\t\t{Name: \"run\", Src: []string{\"start\"}, Dst: \"start\"},\n\t\t\t{Name: \"finish\", Src: []string{\"start\"}, Dst: \"finished\"},\n\t\t},\n\t\tCallbacks{\n\t\t\t\"after_event\": func(_ context.Context, e *Event) {\n\t\t\t\tfsm.Event(context.Background(), \"finish\")\n\t\t\t},\n\t\t},\n\t)\n\terr := fsm.Event(context.Background(), \"run\")\n\tif _, ok := err.(NoTransitionError); !ok {\n\t\tt.Error(\"expected 'NoTransitionError'\")\n\t}\n\n\tcurrentState := fsm.Current()\n\tif currentState != \"finished\" {\n\t\tt.Errorf(\"expected state to be 'finished', was '%s'\", currentState)\n\t}\n}\n\nfunc ExampleNewFSM() {\n\tfsm := NewFSM(\n\t\t\"green\",\n\t\tEvents{\n\t\t\t{Name: \"warn\", Src: []string{\"green\"}, Dst: \"yellow\"},\n\t\t\t{Name: \"panic\", Src: []string{\"yellow\"}, Dst: \"red\"},\n\t\t\t{Name: \"panic\", Src: []string{\"green\"}, Dst: \"red\"},\n\t\t\t{Name: \"calm\", Src: []string{\"red\"}, Dst: \"yellow\"},\n\t\t\t{Name: \"clear\", Src: []string{\"yellow\"}, Dst: \"green\"},\n\t\t},\n\t\tCallbacks{\n\t\t\t\"before_warn\": func(_ context.Context, e *Event) {\n\t\t\t\tfmt.Println(\"before_warn\")\n\t\t\t},\n\t\t\t\"before_event\": func(_ context.Context, e *Event) {\n\t\t\t\tfmt.Println(\"before_event\")\n\t\t\t},\n\t\t\t\"leave_green\": func(_ context.Context, e *Event) {\n\t\t\t\tfmt.Println(\"leave_green\")\n\t\t\t},\n\t\t\t\"leave_state\": func(_ context.Context, e *Event) {\n\t\t\t\tfmt.Println(\"leave_state\")\n\t\t\t},\n\t\t\t\"enter_yellow\": func(_ context.Context, e *Event) {\n\t\t\t\tfmt.Println(\"enter_yellow\")\n\t\t\t},\n\t\t\t\"enter_state\": func(_ context.Context, e *Event) {\n\t\t\t\tfmt.Println(\"enter_state\")\n\t\t\t},\n\t\t\t\"after_warn\": func(_ context.Context, e *Event) {\n\t\t\t\tfmt.Println(\"after_warn\")\n\t\t\t},\n\t\t\t\"after_event\": func(_ context.Context, e *Event) {\n\t\t\t\tfmt.Println(\"after_event\")\n\t\t\t},\n\t\t},\n\t)\n\tfmt.Println(fsm.Current())\n\terr := fsm.Event(context.Background(), \"warn\")\n\tif err != nil {\n\t\tfmt.Println(err)\n\t}\n\tfmt.Println(fsm.Current())\n\t// Output:\n\t// green\n\t// before_warn\n\t// before_event\n\t// leave_green\n\t// leave_state\n\t// enter_yellow\n\t// enter_state\n\t// after_warn\n\t// after_event\n\t// yellow\n}\n\nfunc ExampleFSM_Current() {\n\tfsm := NewFSM(\n\t\t\"closed\",\n\t\tEvents{\n\t\t\t{Name: \"open\", Src: []string{\"closed\"}, Dst: \"open\"},\n\t\t\t{Name: \"close\", Src: []string{\"open\"}, Dst: \"closed\"},\n\t\t},\n\t\tCallbacks{},\n\t)\n\tfmt.Println(fsm.Current())\n\t// Output: closed\n}\n\nfunc ExampleFSM_Is() {\n\tfsm := NewFSM(\n\t\t\"closed\",\n\t\tEvents{\n\t\t\t{Name: \"open\", Src: []string{\"closed\"}, Dst: \"open\"},\n\t\t\t{Name: \"close\", Src: []string{\"open\"}, Dst: \"closed\"},\n\t\t},\n\t\tCallbacks{},\n\t)\n\tfmt.Println(fsm.Is(\"closed\"))\n\tfmt.Println(fsm.Is(\"open\"))\n\t// Output:\n\t// true\n\t// false\n}\n\nfunc ExampleFSM_Can() {\n\tfsm := NewFSM(\n\t\t\"closed\",\n\t\tEvents{\n\t\t\t{Name: \"open\", Src: []string{\"closed\"}, Dst: \"open\"},\n\t\t\t{Name: \"close\", Src: []string{\"open\"}, Dst: \"closed\"},\n\t\t},\n\t\tCallbacks{},\n\t)\n\tfmt.Println(fsm.Can(\"open\"))\n\tfmt.Println(fsm.Can(\"close\"))\n\t// Output:\n\t// true\n\t// false\n}\n\nfunc ExampleFSM_AvailableTransitions() {\n\tfsm := NewFSM(\n\t\t\"closed\",\n\t\tEvents{\n\t\t\t{Name: \"open\", Src: []string{\"closed\"}, Dst: \"open\"},\n\t\t\t{Name: \"close\", Src: []string{\"open\"}, Dst: \"closed\"},\n\t\t\t{Name: \"kick\", Src: []string{\"closed\"}, Dst: \"broken\"},\n\t\t},\n\t\tCallbacks{},\n\t)\n\t// sort the results ordering is consistent for the output checker\n\ttransitions := fsm.AvailableTransitions()\n\tsort.Strings(transitions)\n\tfmt.Println(transitions)\n\t// Output:\n\t// [kick open]\n}\n\nfunc ExampleFSM_Cannot() {\n\tfsm := NewFSM(\n\t\t\"closed\",\n\t\tEvents{\n\t\t\t{Name: \"open\", Src: []string{\"closed\"}, Dst: \"open\"},\n\t\t\t{Name: \"close\", Src: []string{\"open\"}, Dst: \"closed\"},\n\t\t},\n\t\tCallbacks{},\n\t)\n\tfmt.Println(fsm.Cannot(\"open\"))\n\tfmt.Println(fsm.Cannot(\"close\"))\n\t// Output:\n\t// false\n\t// true\n}\n\nfunc ExampleFSM_Event() {\n\tfsm := NewFSM(\n\t\t\"closed\",\n\t\tEvents{\n\t\t\t{Name: \"open\", Src: []string{\"closed\"}, Dst: \"open\"},\n\t\t\t{Name: \"close\", Src: []string{\"open\"}, Dst: \"closed\"},\n\t\t},\n\t\tCallbacks{},\n\t)\n\tfmt.Println(fsm.Current())\n\terr := fsm.Event(context.Background(), \"open\")\n\tif err != nil {\n\t\tfmt.Println(err)\n\t}\n\tfmt.Println(fsm.Current())\n\terr = fsm.Event(context.Background(), \"close\")\n\tif err != nil {\n\t\tfmt.Println(err)\n\t}\n\tfmt.Println(fsm.Current())\n\t// Output:\n\t// closed\n\t// open\n\t// closed\n}\n\nfunc ExampleFSM_Transition() {\n\tfsm := NewFSM(\n\t\t\"closed\",\n\t\tEvents{\n\t\t\t{Name: \"open\", Src: []string{\"closed\"}, Dst: \"open\"},\n\t\t\t{Name: \"close\", Src: []string{\"open\"}, Dst: \"closed\"},\n\t\t},\n\t\tCallbacks{\n\t\t\t\"leave_closed\": func(_ context.Context, e *Event) {\n\t\t\t\te.Async()\n\t\t\t},\n\t\t},\n\t)\n\terr := fsm.Event(context.Background(), \"open\")\n\tif e, ok := err.(AsyncError); !ok && e.Err != nil {\n\t\tfmt.Println(err)\n\t}\n\tfmt.Println(fsm.Current())\n\terr = fsm.Transition()\n\tif err != nil {\n\t\tfmt.Println(err)\n\t}\n\tfmt.Println(fsm.Current())\n\t// Output:\n\t// closed\n\t// open\n}\n\nfunc TestEventAndCanInGoroutines(t *testing.T) {\n\tfsm := NewFSM(\n\t\t\"closed\",\n\t\tEvents{\n\t\t\t{Name: \"open\", Src: []string{\"closed\"}, Dst: \"open\"},\n\t\t\t{Name: \"close\", Src: []string{\"open\"}, Dst: \"closed\"},\n\t\t},\n\t\tCallbacks{},\n\t)\n\twg := sync.WaitGroup{}\n\tfor i := 0; i < 10; i++ {\n\t\twg.Add(2)\n\t\tgo func(n int) {\n\t\t\tdefer wg.Done()\n\t\t\tif n%2 == 0 {\n\t\t\t\t_ = fsm.Event(context.Background(), \"open\")\n\t\t\t} else {\n\t\t\t\t_ = fsm.Event(context.Background(), \"close\")\n\t\t\t}\n\t\t}(i)\n\t\tgo func() {\n\t\t\tdefer wg.Done()\n\t\t\tfsm.Can(\"close\")\n\t\t}()\n\t}\n\twg.Wait()\n}\n"
        },
        {
          "name": "go.mod",
          "type": "blob",
          "size": 0.0380859375,
          "content": "module github.com/looplab/fsm\n\ngo 1.16\n"
        },
        {
          "name": "graphviz_visualizer.go",
          "type": "blob",
          "size": 1.25,
          "content": "package fsm\n\nimport (\n\t\"bytes\"\n\t\"fmt\"\n)\n\n// Visualize outputs a visualization of a FSM in Graphviz format.\nfunc Visualize(fsm *FSM) string {\n\tvar buf bytes.Buffer\n\n\t// we sort the key alphabetically to have a reproducible graph output\n\tsortedEKeys := getSortedTransitionKeys(fsm.transitions)\n\tsortedStateKeys, _ := getSortedStates(fsm.transitions)\n\n\twriteHeaderLine(&buf)\n\twriteTransitions(&buf, sortedEKeys, fsm.transitions)\n\twriteStates(&buf, fsm.current, sortedStateKeys)\n\twriteFooter(&buf)\n\n\treturn buf.String()\n}\n\nfunc writeHeaderLine(buf *bytes.Buffer) {\n\tbuf.WriteString(`digraph fsm {`)\n\tbuf.WriteString(\"\\n\")\n}\n\nfunc writeTransitions(buf *bytes.Buffer, sortedEKeys []eKey, transitions map[eKey]string) {\n\tfor _, k := range sortedEKeys {\n\t\tv := transitions[k]\n\t\tbuf.WriteString(fmt.Sprintf(`    \"%s\" -> \"%s\" [ label = \"%s\" ];`, k.src, v, k.event))\n\t\tbuf.WriteString(\"\\n\")\n\t}\n\n\tbuf.WriteString(\"\\n\")\n}\n\nfunc writeStates(buf *bytes.Buffer, current string, sortedStateKeys []string) {\n\tfor _, k := range sortedStateKeys {\n\t\tif k == current {\n\t\t\tbuf.WriteString(fmt.Sprintf(`    \"%s\" [color = \"red\"];`, k))\n\t\t} else {\n\t\t\tbuf.WriteString(fmt.Sprintf(`    \"%s\";`, k))\n\t\t}\n\t\tbuf.WriteString(\"\\n\")\n\t}\n}\n\nfunc writeFooter(buf *bytes.Buffer) {\n\tbuf.WriteString(fmt.Sprintln(\"}\"))\n}\n"
        },
        {
          "name": "graphviz_visualizer_test.go",
          "type": "blob",
          "size": 0.916015625,
          "content": "package fsm\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\t\"testing\"\n)\n\nfunc TestGraphvizOutput(t *testing.T) {\n\tfsmUnderTest := NewFSM(\n\t\t\"closed\",\n\t\tEvents{\n\t\t\t{Name: \"open\", Src: []string{\"closed\"}, Dst: \"open\"},\n\t\t\t{Name: \"close\", Src: []string{\"open\"}, Dst: \"closed\"},\n\t\t\t{Name: \"part-close\", Src: []string{\"intermediate\"}, Dst: \"closed\"},\n\t\t},\n\t\tCallbacks{},\n\t)\n\n\tgot := Visualize(fsmUnderTest)\n\twanted := `\ndigraph fsm {\n    \"closed\" -> \"open\" [ label = \"open\" ];\n    \"intermediate\" -> \"closed\" [ label = \"part-close\" ];\n    \"open\" -> \"closed\" [ label = \"close\" ];\n\n    \"closed\" [color = \"red\"];\n    \"intermediate\";\n    \"open\";\n}`\n\tnormalizedGot := strings.ReplaceAll(got, \"\\n\", \"\")\n\tnormalizedWanted := strings.ReplaceAll(wanted, \"\\n\", \"\")\n\tif normalizedGot != normalizedWanted {\n\t\tt.Errorf(\"build graphivz graph failed. \\nwanted \\n%s\\nand got \\n%s\\n\", wanted, got)\n\t\tfmt.Println([]byte(normalizedGot))\n\t\tfmt.Println([]byte(normalizedWanted))\n\t}\n}\n"
        },
        {
          "name": "mermaid_visualizer.go",
          "type": "blob",
          "size": 2.951171875,
          "content": "package fsm\n\nimport (\n\t\"bytes\"\n\t\"fmt\"\n)\n\nconst highlightingColor = \"#00AA00\"\n\n// MermaidDiagramType the type of the mermaid diagram type\ntype MermaidDiagramType string\n\nconst (\n\t// FlowChart the diagram type for output in flowchart style (https://mermaid-js.github.io/mermaid/#/flowchart) (including current state)\n\tFlowChart MermaidDiagramType = \"flowChart\"\n\t// StateDiagram the diagram type for output in stateDiagram style (https://mermaid-js.github.io/mermaid/#/stateDiagram)\n\tStateDiagram MermaidDiagramType = \"stateDiagram\"\n)\n\n// VisualizeForMermaidWithGraphType outputs a visualization of a FSM in Mermaid format as specified by the graphType.\nfunc VisualizeForMermaidWithGraphType(fsm *FSM, graphType MermaidDiagramType) (string, error) {\n\tswitch graphType {\n\tcase FlowChart:\n\t\treturn visualizeForMermaidAsFlowChart(fsm), nil\n\tcase StateDiagram:\n\t\treturn visualizeForMermaidAsStateDiagram(fsm), nil\n\tdefault:\n\t\treturn \"\", fmt.Errorf(\"unknown MermaidDiagramType: %s\", graphType)\n\t}\n}\n\nfunc visualizeForMermaidAsStateDiagram(fsm *FSM) string {\n\tvar buf bytes.Buffer\n\n\tsortedTransitionKeys := getSortedTransitionKeys(fsm.transitions)\n\n\tbuf.WriteString(\"stateDiagram-v2\\n\")\n\tbuf.WriteString(fmt.Sprintln(`    [*] -->`, fsm.current))\n\n\tfor _, k := range sortedTransitionKeys {\n\t\tv := fsm.transitions[k]\n\t\tbuf.WriteString(fmt.Sprintf(`    %s --> %s: %s`, k.src, v, k.event))\n\t\tbuf.WriteString(\"\\n\")\n\t}\n\n\treturn buf.String()\n}\n\n// visualizeForMermaidAsFlowChart outputs a visualization of a FSM in Mermaid format (including highlighting of current state).\nfunc visualizeForMermaidAsFlowChart(fsm *FSM) string {\n\tvar buf bytes.Buffer\n\n\tsortedTransitionKeys := getSortedTransitionKeys(fsm.transitions)\n\tsortedStates, statesToIDMap := getSortedStates(fsm.transitions)\n\n\twriteFlowChartGraphType(&buf)\n\twriteFlowChartStates(&buf, sortedStates, statesToIDMap)\n\twriteFlowChartTransitions(&buf, fsm.transitions, sortedTransitionKeys, statesToIDMap)\n\twriteFlowChartHighlightCurrent(&buf, fsm.current, statesToIDMap)\n\n\treturn buf.String()\n}\n\nfunc writeFlowChartGraphType(buf *bytes.Buffer) {\n\tbuf.WriteString(\"graph LR\\n\")\n}\n\nfunc writeFlowChartStates(buf *bytes.Buffer, sortedStates []string, statesToIDMap map[string]string) {\n\tfor _, state := range sortedStates {\n\t\tbuf.WriteString(fmt.Sprintf(`    %s[%s]`, statesToIDMap[state], state))\n\t\tbuf.WriteString(\"\\n\")\n\t}\n\n\tbuf.WriteString(\"\\n\")\n}\n\nfunc writeFlowChartTransitions(buf *bytes.Buffer, transitions map[eKey]string, sortedTransitionKeys []eKey, statesToIDMap map[string]string) {\n\tfor _, transition := range sortedTransitionKeys {\n\t\ttarget := transitions[transition]\n\t\tbuf.WriteString(fmt.Sprintf(`    %s --> |%s| %s`, statesToIDMap[transition.src], transition.event, statesToIDMap[target]))\n\t\tbuf.WriteString(\"\\n\")\n\t}\n\tbuf.WriteString(\"\\n\")\n}\n\nfunc writeFlowChartHighlightCurrent(buf *bytes.Buffer, current string, statesToIDMap map[string]string) {\n\tbuf.WriteString(fmt.Sprintf(`    style %s fill:%s`, statesToIDMap[current], highlightingColor))\n\tbuf.WriteString(\"\\n\")\n}\n"
        },
        {
          "name": "mermaid_visualizer_test.go",
          "type": "blob",
          "size": 2.0771484375,
          "content": "package fsm\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\t\"testing\"\n)\n\nfunc TestMermaidOutput(t *testing.T) {\n\tfsmUnderTest := NewFSM(\n\t\t\"closed\",\n\t\tEvents{\n\t\t\t{Name: \"open\", Src: []string{\"closed\"}, Dst: \"open\"},\n\t\t\t{Name: \"close\", Src: []string{\"open\"}, Dst: \"closed\"},\n\t\t\t{Name: \"part-close\", Src: []string{\"intermediate\"}, Dst: \"closed\"},\n\t\t},\n\t\tCallbacks{},\n\t)\n\n\tgot, err := VisualizeForMermaidWithGraphType(fsmUnderTest, StateDiagram)\n\tif err != nil {\n\t\tt.Errorf(\"got error for visualizing with type MERMAID: %s\", err)\n\t}\n\twanted := `\nstateDiagram-v2\n    [*] --> closed\n    closed --> open: open\n    intermediate --> closed: part-close\n    open --> closed: close\n`\n\tnormalizedGot := strings.ReplaceAll(got, \"\\n\", \"\")\n\tnormalizedWanted := strings.ReplaceAll(wanted, \"\\n\", \"\")\n\tif normalizedGot != normalizedWanted {\n\t\tt.Errorf(\"build mermaid graph failed. \\nwanted \\n%s\\nand got \\n%s\\n\", wanted, got)\n\t\tfmt.Println([]byte(normalizedGot))\n\t\tfmt.Println([]byte(normalizedWanted))\n\t}\n}\n\nfunc TestMermaidFlowChartOutput(t *testing.T) {\n\tfsmUnderTest := NewFSM(\n\t\t\"closed\",\n\t\tEvents{\n\t\t\t{Name: \"open\", Src: []string{\"closed\"}, Dst: \"open\"},\n\t\t\t{Name: \"part-open\", Src: []string{\"closed\"}, Dst: \"intermediate\"},\n\t\t\t{Name: \"part-open\", Src: []string{\"intermediate\"}, Dst: \"open\"},\n\t\t\t{Name: \"close\", Src: []string{\"open\"}, Dst: \"closed\"},\n\t\t\t{Name: \"part-close\", Src: []string{\"intermediate\"}, Dst: \"closed\"},\n\t\t},\n\t\tCallbacks{},\n\t)\n\n\tgot, err := VisualizeForMermaidWithGraphType(fsmUnderTest, FlowChart)\n\tif err != nil {\n\t\tt.Errorf(\"got error for visualizing with type MERMAID: %s\", err)\n\t}\n\twanted := `\ngraph LR\n    id0[closed]\n    id1[intermediate]\n    id2[open]\n\n    id0 --> |open| id2\n    id0 --> |part-open| id1\n    id1 --> |part-close| id0\n    id1 --> |part-open| id2\n    id2 --> |close| id0\n\n    style id0 fill:#00AA00\n`\n\tnormalizedGot := strings.ReplaceAll(got, \"\\n\", \"\")\n\tnormalizedWanted := strings.ReplaceAll(wanted, \"\\n\", \"\")\n\tif normalizedGot != normalizedWanted {\n\t\tt.Errorf(\"build mermaid graph failed. \\nwanted \\n%s\\nand got \\n%s\\n\", wanted, got)\n\t\tfmt.Println([]byte(normalizedGot))\n\t\tfmt.Println([]byte(normalizedWanted))\n\t}\n}\n"
        },
        {
          "name": "uncancel_context.go",
          "type": "blob",
          "size": 0.6533203125,
          "content": "package fsm\n\nimport (\n\t\"context\"\n\t\"time\"\n)\n\ntype uncancel struct {\n\tcontext.Context\n}\n\nfunc (*uncancel) Deadline() (deadline time.Time, ok bool) { return }\nfunc (*uncancel) Done() <-chan struct{}                   { return nil }\nfunc (*uncancel) Err() error                              { return nil }\n\n// uncancelContext returns a context which ignores the cancellation of the parent and only keeps the values.\n// Also returns a new cancel function.\n// This is useful to keep a background task running while the initial request is finished.\nfunc uncancelContext(ctx context.Context) (context.Context, context.CancelFunc) {\n\treturn context.WithCancel(&uncancel{ctx})\n}\n"
        },
        {
          "name": "uncancel_context_test.go",
          "type": "blob",
          "size": 2.23046875,
          "content": "package fsm\n\nimport (\n\t\"context\"\n\t\"testing\"\n)\n\nfunc TestUncancel(t *testing.T) {\n\tt.Run(\"create a new context\", func(t *testing.T) {\n\t\tt.Run(\"and cancel it\", func(t *testing.T) {\n\t\t\tctx := context.Background()\n\t\t\tctx = context.WithValue(ctx, \"key1\", \"value1\")\n\t\t\tctx, cancelFunc := context.WithCancel(ctx)\n\t\t\tcancelFunc()\n\n\t\t\tif ctx.Err() != context.Canceled {\n\t\t\t\tt.Errorf(\"expected context error 'context canceled', got %v\", ctx.Err())\n\t\t\t}\n\t\t\tselect {\n\t\t\tcase <-ctx.Done():\n\t\t\tdefault:\n\t\t\t\tt.Error(\"expected context to be done but it wasn't\")\n\t\t\t}\n\n\t\t\tt.Run(\"and uncancel it\", func(t *testing.T) {\n\t\t\t\tctx, newCancelFunc := uncancelContext(ctx)\n\t\t\t\tif ctx.Err() != nil {\n\t\t\t\t\tt.Errorf(\"expected context error to be nil, got %v\", ctx.Err())\n\t\t\t\t}\n\t\t\t\tselect {\n\t\t\t\tcase <-ctx.Done():\n\t\t\t\t\tt.Fail()\n\t\t\t\tdefault:\n\t\t\t\t}\n\n\t\t\t\tt.Run(\"now it should still contain the values\", func(t *testing.T) {\n\t\t\t\t\tif ctx.Value(\"key1\") != \"value1\" {\n\t\t\t\t\t\tt.Errorf(\"expected context value of key 'key1' to be 'value1', got %v\", ctx.Value(\"key1\"))\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t\tt.Run(\"and cancel the child\", func(t *testing.T) {\n\t\t\t\t\tnewCancelFunc()\n\t\t\t\t\tif ctx.Err() != context.Canceled {\n\t\t\t\t\t\tt.Errorf(\"expected context error 'context canceled', got %v\", ctx.Err())\n\t\t\t\t\t}\n\t\t\t\t\tselect {\n\t\t\t\t\tcase <-ctx.Done():\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tt.Error(\"expected context to be done but it wasn't\")\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t})\n\t\t})\n\t\tt.Run(\"and uncancel it\", func(t *testing.T) {\n\t\t\tctx := context.Background()\n\t\t\tparent := ctx\n\t\t\tctx, newCancelFunc := uncancelContext(ctx)\n\t\t\tif ctx.Err() != nil {\n\t\t\t\tt.Errorf(\"expected context error to be nil, got %v\", ctx.Err())\n\t\t\t}\n\t\t\tselect {\n\t\t\tcase <-ctx.Done():\n\t\t\t\tt.Fail()\n\t\t\tdefault:\n\t\t\t}\n\n\t\t\tt.Run(\"and cancel the child\", func(t *testing.T) {\n\t\t\t\tnewCancelFunc()\n\t\t\t\tif ctx.Err() != context.Canceled {\n\t\t\t\t\tt.Errorf(\"expected context error 'context canceled', got %v\", ctx.Err())\n\t\t\t\t}\n\t\t\t\tselect {\n\t\t\t\tcase <-ctx.Done():\n\t\t\t\tdefault:\n\t\t\t\t\tt.Error(\"expected context to be done but it wasn't\")\n\t\t\t\t}\n\n\t\t\t\tt.Run(\"and ensure the parent is not affected\", func(t *testing.T) {\n\t\t\t\t\tif parent.Err() != nil {\n\t\t\t\t\t\tt.Errorf(\"expected parent context error to be nil, got %v\", ctx.Err())\n\t\t\t\t\t}\n\t\t\t\t\tselect {\n\t\t\t\t\tcase <-parent.Done():\n\t\t\t\t\t\tt.Fail()\n\t\t\t\t\tdefault:\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t})\n\t\t})\n\t})\n}\n"
        },
        {
          "name": "visualizer.go",
          "type": "blob",
          "size": 2.53515625,
          "content": "package fsm\n\nimport (\n\t\"fmt\"\n\t\"sort\"\n)\n\n// VisualizeType the type of the visualization\ntype VisualizeType string\n\nconst (\n\t// GRAPHVIZ the type for graphviz output (http://www.webgraphviz.com/)\n\tGRAPHVIZ VisualizeType = \"graphviz\"\n\t// MERMAID the type for mermaid output (https://mermaid-js.github.io/mermaid/#/stateDiagram) in the stateDiagram form\n\tMERMAID VisualizeType = \"mermaid\"\n\t// MermaidStateDiagram the type for mermaid output (https://mermaid-js.github.io/mermaid/#/stateDiagram) in the stateDiagram form\n\tMermaidStateDiagram VisualizeType = \"mermaid-state-diagram\"\n\t// MermaidFlowChart the type for mermaid output (https://mermaid-js.github.io/mermaid/#/flowchart) in the flow chart form\n\tMermaidFlowChart VisualizeType = \"mermaid-flow-chart\"\n)\n\n// VisualizeWithType outputs a visualization of a FSM in the desired format.\n// If the type is not given it defaults to GRAPHVIZ\nfunc VisualizeWithType(fsm *FSM, visualizeType VisualizeType) (string, error) {\n\tswitch visualizeType {\n\tcase GRAPHVIZ:\n\t\treturn Visualize(fsm), nil\n\tcase MERMAID:\n\t\treturn VisualizeForMermaidWithGraphType(fsm, StateDiagram)\n\tcase MermaidStateDiagram:\n\t\treturn VisualizeForMermaidWithGraphType(fsm, StateDiagram)\n\tcase MermaidFlowChart:\n\t\treturn VisualizeForMermaidWithGraphType(fsm, FlowChart)\n\tdefault:\n\t\treturn \"\", fmt.Errorf(\"unknown VisualizeType: %s\", visualizeType)\n\t}\n}\n\nfunc getSortedTransitionKeys(transitions map[eKey]string) []eKey {\n\t// we sort the key alphabetically to have a reproducible graph output\n\tsortedTransitionKeys := make([]eKey, 0)\n\n\tfor transition := range transitions {\n\t\tsortedTransitionKeys = append(sortedTransitionKeys, transition)\n\t}\n\tsort.Slice(sortedTransitionKeys, func(i, j int) bool {\n\t\tif sortedTransitionKeys[i].src == sortedTransitionKeys[j].src {\n\t\t\treturn sortedTransitionKeys[i].event < sortedTransitionKeys[j].event\n\t\t}\n\t\treturn sortedTransitionKeys[i].src < sortedTransitionKeys[j].src\n\t})\n\n\treturn sortedTransitionKeys\n}\n\nfunc getSortedStates(transitions map[eKey]string) ([]string, map[string]string) {\n\tstatesToIDMap := make(map[string]string)\n\tfor transition, target := range transitions {\n\t\tif _, ok := statesToIDMap[transition.src]; !ok {\n\t\t\tstatesToIDMap[transition.src] = \"\"\n\t\t}\n\t\tif _, ok := statesToIDMap[target]; !ok {\n\t\t\tstatesToIDMap[target] = \"\"\n\t\t}\n\t}\n\n\tsortedStates := make([]string, 0, len(statesToIDMap))\n\tfor state := range statesToIDMap {\n\t\tsortedStates = append(sortedStates, state)\n\t}\n\tsort.Strings(sortedStates)\n\n\tfor i, state := range sortedStates {\n\t\tstatesToIDMap[state] = fmt.Sprintf(\"id%d\", i)\n\t}\n\treturn sortedStates, statesToIDMap\n}\n"
        }
      ]
    }
  ]
}