{
  "metadata": {
    "timestamp": 1736567149798,
    "page": 747,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjc1MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "tebeka/selenium",
      "stars": 2546,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.140625,
          "content": "README.html\n_testmain.go\nsauce.json\nt.go\nselenium-server-standalone-*.jar\nchromedriver*\nvendor/*\n!vendor/*.go\ncoverage.txt\ncoverage.out\n.idea/*\n"
        },
        {
          "name": ".travis.yml",
          "type": "blob",
          "size": 0.8125,
          "content": "language: go\ngo:\n    - 1.12.x\n\njdk:\n    # The Java JRE is a requirement for Selenium and HTMLUnit.\n    - openjdk11\n\nbefore_script:\n  # Download all of the binary dependencies needed to run the tests.\n  - cd vendor && go run init.go --alsologtostderr --download_browsers --download_latest && cd ..\n\nenv:\n  # For 1.12, this environment variable still defaults to auto. This can\n  # be removed in some future Go release.\n  - GO111MODULE=on\n\n# Use Go's module support to install dependencies instead of Travis's\n# travis_install_go_dependencies.\ninstall: true\n\nscript:\n  # Ensure that the code has been formatted with gofmt.\n  - ./testing/travis-ci-gofmt.sh\n  # Run the tests.\n  - ./testing/travis-ci-test.sh\n\nafter_success:\n  # Upload the code coverage report to Codecov.\n  - bash <(curl -s https://codecov.io/bash) -- -v\n\nsudo: false\n"
        },
        {
          "name": "AUTHORS",
          "type": "blob",
          "size": 0.3955078125,
          "content": "# This is the list of Selenium Go Client authors for copyright purposes.\n#\n# This does not necessarily list everyone who has contributed code, since in\n# some cases, their employer may be the copyright holder.  To see the full list\n# of contributors, see the revision history in source control.\nDaniel Skora\nGoogle Inc.\nHakon Eide\nHiroaki Nakamura\nIan Wetherbee\nMiki Tebeka\nNikolai\nRaviTeju\nRodrigo Lessa\n"
        },
        {
          "name": "ChangeLog",
          "type": "blob",
          "size": 1.94921875,
          "content": "2016-11-22 version 0.9.3\n* Pretty printing of JSON reponse (@crantok  in PR #44)\n\n2016-08-31 version 0.9.2\n* SwithFrame with nil id (@exjimsk in PR #34)\n\n2016-02-23 version 0.9.1\n* Log method (@wetherbeei in PR #21)\n\n2016-02-11 version 0.9.0\n* Testing on docker with go 1.5.3\n* Testing with Selenium 2.51.0\n* SwitchSession (@minusnine in PR #27)\n* KeyUp and KeyDown (@minusnine in PR #26)\n* Capability type (@minusnine in PR #25)\n\n2015-06-16 version 0.8.5\n* Fix URL in go.doc (@RaviTezu  in PR #15)\n\n2015-06-16 version 0.8.4\n* Make SetDebug visible (github PR #8 by dskora)\n\n2015-02-10 version 0.8.3\n* ResizeWindow (MR #3 by eide)\n\n2014-08-14 version 0.8.2\n* Fixed errors found by \"go vet\"\n\n2014-02-04 version 0.8.1\n* MaximizeWindow (issue #9)\n* VERSION -> Version\n    \n2014-01-28 version 0.8.0\n* GetHTTPClient for AppEngine support (issue #8)\n\n2013-11-02 version 0.7.0\n* Added SessionId to Selenium interface\n    \n2013-10-09 version 0.6.1\n* Fix panic when stringCommand return value is nil (issue #6)\n\n2012-04-10 version 0.6.0\n* ExecuteScriptRaw, ExecuteScriptAsyncRaw (Naitik Shah)\n* DecodeElement in API (Naitik Shah)\n\n2012-04-07 version 0.5.0\n* IsDiaplayed -> IsDisplayed (thanks Naitik Shah)\n* VERSION is a const now\n\n2012-03-29 version 0.4.0\n* Fix bug in /status\n* timeouts are in time.Duration\n\n2012-02-13 version 0.3.0\n* Go 1\n* Compatible with `go get`\n* README teaks\n\n2011-09-27 version 0.2.2\n* All keys from http://bit.ly/p8SIrD\n\n2011-09-27 version 0.2.1\n* Capabilities, SetAsyncScriptTimeout, SetImplicitWaitTimeout, CloseWindow\n* IME commands\n* Use selenium 2.7.0 for testing\n\n2011-09-21 version 0.2.0\n* Moved profileDir out of NewRemote\n\n2011-09-07 version 0.1.3\n* Local test server, SauceLabs disabled\n* Added run-tests.sh\n* Stop tests on first error (t.Error -> t.Fatal)\n\n2011-09-06 version 0.1.2\n* Tests running on SauceLabs\n* More lax content-type checking\n* Pass Capabilities (not *Capabilties)\n\n2011-09-04 version 0.1.1\n* Screenshot\n\n2011-09-04 version 0.1.0\n* Initial release\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.0556640625,
          "content": "Copyright (c) 2012-2016 The Selenium Go Client Authors.\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of\nthis software and associated documentation files (the \"Software\"), to deal in\nthe Software without restriction, including without limitation the rights to\nuse, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of\nthe Software, and to permit persons to whom the Software is furnished to do so,\nsubject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS\nFOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR\nCOPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER\nIN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\nCONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 6.9931640625,
          "content": "# The most complete, best-tested WebDriver client for Go\n\n[![GoDoc](https://godoc.org/github.com/tebeka/selenium?status.svg)](https://godoc.org/github.com/tebeka/selenium)\n[![Travis](https://travis-ci.org/tebeka/selenium.svg?branch=master)](https://travis-ci.org/tebeka/selenium)\n[![Go Report Card](https://goreportcard.com/badge/github.com/tebeka/selenium)](https://goreportcard.com/report/github.com/tebeka/selenium)\n\n## About\n\nThis is a [WebDriver][selenium] client for [Go][go]. It supports the\n[WebDriver protocol][webdriver] and has been tested with various versions of\n[Selenium WebDriver][selenium], Firefox and [Geckodriver][geckodriver], and\nChrome and [ChromeDriver][chromedriver],\n\n`selenium` is currently maintained by Eric Garrido ([@minusnine][minusnine]).\n\n[selenium]: http://seleniumhq.org/\n[webdriver]: https://www.w3.org/TR/webdriver/\n[go]: http://golang.org/\n[server]: http://seleniumhq.org/download/\n[geckodriver]: https://github.com/mozilla/geckodriver\n[chromedriver]: https://sites.google.com/a/chromium.org/chromedriver/\n[minusnine]: http://github.com/minusnine\n\n## Installing\n\nRun\n\n    go get -t -d github.com/tebeka/selenium\n\nto fetch the package.\n\nThe package requires a working WebDriver installation, which can include recent\nversions of a web browser being driven by Selenium WebDriver.\n\n### Downloading Dependencies\n\nWe provide a means to download the ChromeDriver binary, the Firefox binary, the\nSelenium WebDriver JARs, and the Sauce Connect proxy binary. This is primarily\nintended for testing.\n\n    $ cd vendor\n    $ go run init.go --alsologtostderr  --download_browsers --download_latest\n    $ cd ..\n\nRe-run this periodically to get up-to-date versions of these binaries.\n\n## Documentation\n\nThe API documentation is at https://godoc.org/github.com/tebeka/selenium. See [the example](https://github.com/tebeka/selenium/blob/master/example_test.go) and unit tests(for [sauce](https://github.com/tebeka/selenium/blob/master/sauce_test.go), [selenium](https://github.com/tebeka/selenium/blob/master/selenium_test.go) and [service](https://github.com/tebeka/selenium/blob/master/service_test.go)) for better usage information.\n\n## Known Issues\n\nAny issues are usually because the underlying browser automation framework has a\nbug or inconsistency. Where possible, we try to cover up these underlying\nproblems in the client, but sometimes workarounds require higher-level\nintervention.\n\nPlease feel free to [file an issue][issue] if this client doesn't work as\nexpected.\n\n[issue]: https://github.com/tebeka/selenium/issues/new\n\nBelow are known issues that affect the usage of this API. There are likely\nothers filed on the respective issue trackers.\n\n### Selenium 2\n\nNo longer supported.\n\n### Selenium 3\n\n1.  [Selenium 3 NewSession does not implement the W3C-specified parameters](https://github.com/SeleniumHQ/selenium/issues/2827).\n\n### Geckodriver (Standalone)\n\n1.  [Geckodriver does not support the Log API](https://github.com/mozilla/geckodriver/issues/284)\n    because it\n    [hasn't been defined in the spec yet](https://github.com/w3c/webdriver/issues/406).\n2.  Firefox via Geckodriver (and also through Selenium)\n    [doesn't handle clicking on an element](https://github.com/mozilla/geckodriver/issues/1007).\n3.  Firefox via Geckodriver doesn't handle sending control characters\n    [without appending a terminating null key](https://github.com/mozilla/geckodriver/issues/665).\n\n### Chromedriver\n\n1. [Headless Chrome does not support running extensions](https://crbug.com/706008).\n\n## Breaking Changes\n\nThere are a number of upcoming changes that break backward compatibility in an\neffort to improve and adapt the existing API. They are listed here:\n\n### 22 August 2017\n\nThe `Version` constant was removed as it is unused.\n\n### 18 April 2017\n\nThe Log method was changed to accept a typed constant for the type of log to\nretrieve, instead of a raw string. The return value was also changed to provide\na more idiomatic type.\n\n## Hacking\n\nPatches are encouraged through GitHub pull requests. Please ensure that:\n\n1.  A test is added for anything more than a trivial change and that the\n    existing tests pass. See below for instructions on setting up your test\n    environment.\n2.  Please ensure that `gofmt` has been run on the changed files before\n    committing. Install a pre-commit hook with the following command:\n\n    $ ln -s ../../misc/git/pre-commit .git/hooks/pre-commit\n\nSee [the issue tracker][issues] for features that need implementing.\n\n[issues]: https://github.com/tebeka/selenium/issues\n\n### Testing Locally\n\nInstall `xvfb` and Java if they is not already installed, e.g.:\n\n    sudo apt-get install xvfb openjdk-11-jre\n\nRun the tests:\n\n    $ go test\n\n*   There is one top-level test for each of:\n\n    1.  Chromium and ChromeDriver.\n    2.  A new version of Firefox and Selenium 3.\n    3.  HTMLUnit, a Java-based lightweight headless browser implementation.\n    4.  A new version of Firefox directly against Geckodriver.\n\n    There are subtests that are shared between both top-level tests.\n\n*   To run only one of the top-level tests, pass one of:\n\n    *   `-test.run=TestFirefoxSelenium3`,\n    *   `-test.run=TestFirefoxGeckoDriver`,\n    *   `-test.run=TestHTMLUnit`, or\n    *   `-test.run=TestChrome`.\n\n    To run a specific subtest, pass `-test.run=Test<Browser>/<subtest>` as\n    appropriate. This flag supports regular expressions.\n\n*   If the Chrome or Firefox binaries, the Selenium JAR, the Geckodriver binary,\n    or the ChromeDriver binary cannot be found, the corresponding tests will be\n    skipped.\n\n*   The binaries and JAR under test can be configured by passing flags to `go\n    test`. See the available flags with `go test --arg --help`.\n\n*   Add the argument `-test.v` to see detailed output from the test automation\n    framework.\n\n### Testing With Docker\n\nTo ensure hermeticity, we also have tests that run under Docker. You will need\nan installed and running Docker system.\n\nTo run the tests under Docker, run:\n\n    $ go test --docker\n\nThis will create a new Docker container and run the tests in it. (Note: flags\nsupplied to this invocation are not curried through to the `go test` invocation\nwithin the Docker container).\n\nFor debugging Docker directly, run the following commands:\n\n    $ docker build -t go-selenium testing/\n    $ docker run --volume=$(pwd):/code --workdir=/code -it go-selenium bash\n    root@6c7951e41db6:/code# testing/docker-test.sh\n    ... lots of testing output ...\n\n### Testing With Sauce Labs\n\nTests can be run using a browser located in the cloud via Sauce Labs.\n\nTo run the tests under Sauce, run:\n\n    $ go test --test.run=TestSauce --test.timeout=20m \\\n      --experimental_enable_sauce \\\n      --sauce_user_name=[username goes here] \\\n      --sauce_access_key=[access key goes here]\n\nThe Sauce access key can be obtained via\n[the Sauce Labs user settings page](https://saucelabs.com/beta/user-settings).\n\nTest results can be viewed through the\n[Sauce Labs Dashboard](https://saucelabs.com/beta/dashboard/tests).\n\n## License\n\nThis project is licensed under the [MIT][mit] license.\n\n[mit]: https://raw.githubusercontent.com/tebeka/selenium/master/LICENSE\n"
        },
        {
          "name": "chrome",
          "type": "tree",
          "content": null
        },
        {
          "name": "common.go",
          "type": "blob",
          "size": 0.5888671875,
          "content": "package selenium\n\nimport (\n\t\"log\"\n\t\"net/url\"\n)\n\nvar debugFlag = false\n\n// SetDebug sets debug mode\nfunc SetDebug(debug bool) {\n\tdebugFlag = debug\n}\n\nfunc debugLog(format string, args ...interface{}) {\n\tif !debugFlag {\n\t\treturn\n\t}\n\tlog.Printf(format+\"\\n\", args...)\n}\n\n// filteredURL replaces existing password from the given URL.\nfunc filteredURL(u string) string {\n\t// Hide password if set in URL\n\tm, err := url.Parse(u)\n\tif err != nil {\n\t\treturn \"\"\n\t}\n\tif m.User != nil {\n\t\tif _, ok := m.User.Password(); ok {\n\t\t\tm.User = url.UserPassword(m.User.Username(), \"__password__\")\n\t\t}\n\t}\n\treturn m.String()\n}\n"
        },
        {
          "name": "doc.go",
          "type": "blob",
          "size": 0.5400390625,
          "content": "/*\nPackage selenium provides a client to drive web browser-based automation and\ntesting.\n\nSee the example below for how to get started with this API.\n\nThis package can depend on several binaries being available, depending on which\nbrowsers will be used and how. To avoid needing to manage these dependencies,\nuse a cloud-based browser testing environment, like Sauce Labs, BrowserStack\nor similar. Otherwise, use the methods provided by this API to specify the\npaths to the dependencies, which will have to be downloaded separately.\n*/\npackage selenium\n"
        },
        {
          "name": "example_test.go",
          "type": "blob",
          "size": 5.0166015625,
          "content": "package selenium_test\n\nimport (\n\t\"fmt\"\n\t\"os\"\n\t\"strings\"\n\t\"time\"\n\n\t\"github.com/tebeka/selenium\"\n)\n\n// This example shows how to navigate to a http://play.golang.org page, input a\n// short program, run it, and inspect its output.\n//\n// If you want to actually run this example:\n//\n//   1. Ensure the file paths at the top of the function are correct.\n//   2. Remove the word \"Example\" from the comment at the bottom of the\n//      function.\n//   3. Run:\n//      go test -test.run=Example$ github.com/tebeka/selenium\nfunc Example() {\n\t// Start a Selenium WebDriver server instance (if one is not already\n\t// running).\n\tconst (\n\t\t// These paths will be different on your system.\n\t\tseleniumPath    = \"vendor/selenium-server-standalone-3.4.jar\"\n\t\tgeckoDriverPath = \"vendor/geckodriver-v0.18.0-linux64\"\n\t\tport            = 8080\n\t)\n\topts := []selenium.ServiceOption{\n\t\tselenium.StartFrameBuffer(),           // Start an X frame buffer for the browser to run in.\n\t\tselenium.GeckoDriver(geckoDriverPath), // Specify the path to GeckoDriver in order to use Firefox.\n\t\tselenium.Output(os.Stderr),            // Output debug information to STDERR.\n\t}\n\tselenium.SetDebug(true)\n\tservice, err := selenium.NewSeleniumService(seleniumPath, port, opts...)\n\tif err != nil {\n\t\tpanic(err) // panic is used only as an example and is not otherwise recommended.\n\t}\n\tdefer service.Stop()\n\n\t// Connect to the WebDriver instance running locally.\n\tcaps := selenium.Capabilities{\"browserName\": \"firefox\"}\n\twd, err := selenium.NewRemote(caps, fmt.Sprintf(\"http://localhost:%d/wd/hub\", port))\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tdefer wd.Quit()\n\n\t// Navigate to the simple playground interface.\n\tif err := wd.Get(\"http://play.golang.org/?simple=1\"); err != nil {\n\t\tpanic(err)\n\t}\n\n\t// Get a reference to the text box containing code.\n\telem, err := wd.FindElement(selenium.ByCSSSelector, \"#code\")\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\t// Remove the boilerplate code already in the text box.\n\tif err := elem.Clear(); err != nil {\n\t\tpanic(err)\n\t}\n\n\t// Enter some new code in text box.\n\terr = elem.SendKeys(`\n\t\tpackage main\n\t\timport \"fmt\"\n\n\t\tfunc main() {\n\t\t\tfmt.Println(\"Hello WebDriver!\")\n\t\t}\n\t`)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\t// Click the run button.\n\tbtn, err := wd.FindElement(selenium.ByCSSSelector, \"#run\")\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tif err := btn.Click(); err != nil {\n\t\tpanic(err)\n\t}\n\n\t// Wait for the program to finish running and get the output.\n\toutputDiv, err := wd.FindElement(selenium.ByCSSSelector, \"#output\")\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\tvar output string\n\tfor {\n\t\toutput, err = outputDiv.Text()\n\t\tif err != nil {\n\t\t\tpanic(err)\n\t\t}\n\t\tif output != \"Waiting for remote server...\" {\n\t\t\tbreak\n\t\t}\n\t\ttime.Sleep(time.Millisecond * 100)\n\t}\n\n\tfmt.Printf(\"%s\", strings.Replace(output, \"\\n\\n\", \"\\n\", -1))\n\t// Example Output:\n\t// Hello WebDriver!\n\t//\n\t// Program exited.\n\n\t// The following shows an example of using the Actions API.\n\t// Please refer to the WC3 Actions spec for more detailed information.\n\tif err := wd.Get(\"http://play.golang.org/?simple=1\"); err != nil {\n\t\tpanic(err)\n\t}\n\n\t// Create a point which will be used as an offset to click on the\n\t// code editor text box element on the page.\n\toffset := selenium.Point{X: 100, Y: 100}\n\n\t// Call StorePointerActions to store a number of Pointer actions which\n\t// will be executed sequentially.\n\t// \"mouse1\" is used as a unique virtual device identifier for this\n\t// and future actions.\n\t// selenium.MousePointer is used to identify the type of the pointer.\n\t// The stored action chain will move the pointer and click on the code\n\t// editor text box on the page.\n\tselenium.StorePointerActions(\"mouse1\",\n\t\tselenium.MousePointer,\n\t\t// using selenium.FromViewport as the move origin\n\t\t// which calculates the offset from 0,0.\n\t\t// the other valid option is selenium.FromPointer.\n\t\tselenium.PointerMoveAction(0, offset, selenium.FromViewport),\n\t\tselenium.PointerPauseAction(250),\n\t\tselenium.PointerDownAction(selenium.LeftButton),\n\t\tselenium.PointerPauseAction(250),\n\t\tselenium.PointerUpAction(selenium.LeftButton),\n\t)\n\n\t// Call StoreKeyActions to store a number of Key actions which\n\t// will be executed sequentially.\n\t// \"keyboard1\" is used as a unique virtual device identifier\n\t// for this and future actions.\n\t// The stored action chain will send keyboard inputs to the browser.\n\tselenium.StoreKeyActions(\"keyboard1\",\n\t\tselenium.KeyDownAction(selenium.ControlKey),\n\t\tselenium.KeyPauseAction(50),\n\t\tselenium.KeyDownAction(\"a\"),\n\t\tselenium.KeyPauseAction(50),\n\t\tselenium.KeyUpAction(\"a\"),\n\t\tselenium.KeyUpAction(selenium.ControlKey),\n\t\tselenium.KeyDownAction(\"h\"),\n\t\tselenium.KeyDownAction(\"e\"),\n\t\tselenium.KeyDownAction(\"l\"),\n\t\tselenium.KeyDownAction(\"l\"),\n\t\tselenium.KeyDownAction(\"o\"),\n\t)\n\n\t// Call PerformActions to execute stored action - based on\n\t// the order of the previous calls, PointerActions will be\n\t// executed first and then KeyActions.\n\tif err := wd.PerformActions(); err != nil {\n\t\tpanic(err)\n\t}\n\n\t// Call ReleaseActions to release any PointerDown or\n\t// KeyDown Actions that haven't been released through an Action.\n\tif err := wd.ReleaseActions(); err != nil {\n\t\tpanic(err)\n\t}\n\n}\n"
        },
        {
          "name": "firefox",
          "type": "tree",
          "content": null
        },
        {
          "name": "go.mod",
          "type": "blob",
          "size": 0.4853515625,
          "content": "module github.com/tebeka/selenium\n\ngo 1.12\n\nrequire (\n\tcloud.google.com/go v0.41.0\n\tgithub.com/BurntSushi/xgbutil v0.0.0-20160919175755-f7c97cef3b4e\n\tgithub.com/armon/go-socks5 v0.0.0-20160902184237-e75332964ef5\n\tgithub.com/blang/semver v3.5.1+incompatible\n\tgithub.com/golang/glog v0.0.0-20160126235308-23def4e6c14b\n\tgithub.com/golang/protobuf v1.3.4\n\tgithub.com/google/go-cmp v0.3.0\n\tgithub.com/google/go-github/v27 v27.0.4\n\tgithub.com/mediabuyerbot/go-crx3 v1.3.1\n\tgoogle.golang.org/api v0.7.0\n)"
        },
        {
          "name": "go.sum",
          "type": "blob",
          "size": 22.474609375,
          "content": "cloud.google.com/go v0.26.0/go.mod h1:aQUYkXzVsufM+DwF1aE+0xfcU+56JwCaLick0ClmMTw=\ncloud.google.com/go v0.34.0/go.mod h1:aQUYkXzVsufM+DwF1aE+0xfcU+56JwCaLick0ClmMTw=\ncloud.google.com/go v0.38.0/go.mod h1:990N+gfupTy94rShfmMCWGDn0LpTmnzTp2qbd1dvSRU=\ncloud.google.com/go v0.41.0 h1:NFvqUTDnSNYPX5oReekmB+D+90jrJIcVImxQ3qrBVgM=\ncloud.google.com/go v0.41.0/go.mod h1:OauMR7DV8fzvZIl2qg6rkaIhD/vmgk4iwEw/h6ercmg=\ngithub.com/BurntSushi/toml v0.3.1/go.mod h1:xHWCNGjB5oqiDr8zfno3MHue2Ht5sIBksp03qcyfWMU=\ngithub.com/BurntSushi/xgb v0.0.0-20160522181843-27f122750802 h1:1BDTz0u9nC3//pOCMdNH+CiXJVYJh5UQNCOBG7jbELc=\ngithub.com/BurntSushi/xgb v0.0.0-20160522181843-27f122750802/go.mod h1:IVnqGOEym/WlBOVXweHU+Q+/VP0lqqI8lqeDx9IjBqo=\ngithub.com/BurntSushi/xgbutil v0.0.0-20160919175755-f7c97cef3b4e h1:4ZrkT/RzpnROylmoQL57iVUL57wGKTR5O6KpVnbm2tA=\ngithub.com/BurntSushi/xgbutil v0.0.0-20160919175755-f7c97cef3b4e/go.mod h1:uw9h2sd4WWHOPdJ13MQpwK5qYWKYDumDqxWWIknEQ+k=\ngithub.com/OneOfOne/xxhash v1.2.2/go.mod h1:HSdplMjZKSmBqAxg5vPj2TmRDmfkzw+cTzAElWljhcU=\ngithub.com/alecthomas/template v0.0.0-20160405071501-a0175ee3bccc/go.mod h1:LOuyumcjzFXgccqObfd/Ljyb9UuFJ6TxHnclSeseNhc=\ngithub.com/alecthomas/units v0.0.0-20151022065526-2efee857e7cf/go.mod h1:ybxpYRFXyAe+OPACYpWeL0wqObRcbAqCMya13uyzqw0=\ngithub.com/armon/consul-api v0.0.0-20180202201655-eb2c6b5be1b6/go.mod h1:grANhF5doyWs3UAsr3K4I6qtAmlQcZDesFNEHPZAzj8=\ngithub.com/armon/go-socks5 v0.0.0-20160902184237-e75332964ef5 h1:0CwZNZbxp69SHPdPJAN/hZIm0C4OItdklCFmMRWYpio=\ngithub.com/armon/go-socks5 v0.0.0-20160902184237-e75332964ef5/go.mod h1:wHh0iHkYZB8zMSxRWpUBQtwG5a7fFgvEO+odwuTv2gs=\ngithub.com/beorn7/perks v0.0.0-20180321164747-3a771d992973/go.mod h1:Dwedo/Wpr24TaqPxmxbtue+5NUziq4I4S80YR8gNf3Q=\ngithub.com/beorn7/perks v1.0.0/go.mod h1:KWe93zE9D1o94FZ5RNwFwVgaQK1VOXiVxmqh+CedLV8=\ngithub.com/blang/semver v3.5.1+incompatible h1:cQNTCjp13qL8KC3Nbxr/y2Bqb63oX6wdnnjpJbkM4JQ=\ngithub.com/blang/semver v3.5.1+incompatible/go.mod h1:kRBLl5iJ+tD4TcOOxsy/0fnwebNt5EWlYSAyrTnjyyk=\ngithub.com/cespare/xxhash v1.1.0/go.mod h1:XrSqR1VqqWfGrhpAt58auRo0WTKS1nRRg3ghfAqPWnc=\ngithub.com/chromedp/cdproto v0.0.0-20200209033844-7e00b02ea7d2/go.mod h1:PfAWWKJqjlGFYJEidUM6aVIWPr0EpobeyVWEEmplX7g=\ngithub.com/client9/misspell v0.3.4/go.mod h1:qj6jICC3Q7zFZvVWo7KLAzC3yx5G7kyvSDkc90ppPyw=\ngithub.com/coreos/bbolt v1.3.2/go.mod h1:iRUV2dpdMOn7Bo10OQBFzIJO9kkE559Wcmn+qkEiiKk=\ngithub.com/coreos/etcd v3.3.10+incompatible/go.mod h1:uF7uidLiAD3TWHmW31ZFd/JWoc32PjwdhPthX9715RE=\ngithub.com/coreos/go-semver v0.2.0/go.mod h1:nnelYz7RCh+5ahJtPPxZlU+153eP4D4r3EedlOD2RNk=\ngithub.com/coreos/go-systemd v0.0.0-20190321100706-95778dfbb74e/go.mod h1:F5haX7vjVVG0kc13fIWeqUViNPyEJxv/OmvnBo0Yme4=\ngithub.com/coreos/pkg v0.0.0-20180928190104-399ea9e2e55f/go.mod h1:E3G3o1h8I7cfcXa63jLwjI0eiQQMgzzUDFVpN/nH/eA=\ngithub.com/cpuguy83/go-md2man/v2 v2.0.0/go.mod h1:maD7wRr/U5Z6m/iR4s+kqSMx2CaBsrgA7czyZG/E6dU=\ngithub.com/davecgh/go-spew v1.1.0/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=\ngithub.com/davecgh/go-spew v1.1.1/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=\ngithub.com/dgrijalva/jwt-go v3.2.0+incompatible/go.mod h1:E3ru+11k8xSBh+hMPgOLZmtrrCbhqsmaPHjLKYnJCaQ=\ngithub.com/dgryski/go-sip13 v0.0.0-20181026042036-e10d5fee7954/go.mod h1:vAd38F8PWV+bWy6jNmig1y/TA+kYO4g3RSRF0IAv0no=\ngithub.com/fsnotify/fsnotify v1.4.7/go.mod h1:jwhsz4b93w/PPRr/qN1Yymfu8t87LnFCMoQvtojpjFo=\ngithub.com/ghodss/yaml v1.0.0/go.mod h1:4dBDuWmgqj2HViK6kFavaiC9ZROes6MMH2rRYeMEF04=\ngithub.com/go-kit/kit v0.8.0/go.mod h1:xBxKIO96dXMWWy0MnWVtmwkA9/13aqxPnvrjFYMA2as=\ngithub.com/go-logfmt/logfmt v0.3.0/go.mod h1:Qt1PoO58o5twSAckw1HlFXLmHsOX5/0LbT9GBnD5lWE=\ngithub.com/go-logfmt/logfmt v0.4.0/go.mod h1:3RMwSq7FuexP4Kalkev3ejPJsZTpXXBr9+V4qmtdjCk=\ngithub.com/go-stack/stack v1.8.0/go.mod h1:v0f6uXyyMGvRgIKkXu+yp6POWl0qKG85gN/melR3HDY=\ngithub.com/gogo/protobuf v1.1.1/go.mod h1:r8qH/GZQm5c6nD/R0oafs1akxWv10x8SbQlK7atdtwQ=\ngithub.com/gogo/protobuf v1.2.1/go.mod h1:hp+jE20tsWTFYpLwKvXlhS1hjn+gTNwPg2I6zVXpSg4=\ngithub.com/golang/glog v0.0.0-20160126235308-23def4e6c14b h1:VKtxabqXZkF25pY9ekfRL6a582T4P37/31XEstQ5p58=\ngithub.com/golang/glog v0.0.0-20160126235308-23def4e6c14b/go.mod h1:SBH7ygxi8pfUlaOkMMuAQtPIUF8ecWP5IEl/CR7VP2Q=\ngithub.com/golang/groupcache v0.0.0-20190129154638-5b532d6fd5ef/go.mod h1:cIg4eruTrX1D+g88fzRXU5OdNfaM+9IcxsU14FzY7Hc=\ngithub.com/golang/mock v1.1.1/go.mod h1:oTYuIxOrZwtPieC+H1uAHpcLFnEyAGVDL/k47Jfbm0A=\ngithub.com/golang/mock v1.2.0/go.mod h1:oTYuIxOrZwtPieC+H1uAHpcLFnEyAGVDL/k47Jfbm0A=\ngithub.com/golang/mock v1.3.1/go.mod h1:sBzyDLLjw3U8JLTeZvSv8jJB+tU5PVekmnlKIyFUx0Y=\ngithub.com/golang/protobuf v1.2.0/go.mod h1:6lQm79b+lXiMfvg/cZm0SGofjICqVBUtrP5yJMmIC1U=\ngithub.com/golang/protobuf v1.3.1 h1:YF8+flBXS5eO826T4nzqPrxfhQThhXl0YzfuUPu4SBg=\ngithub.com/golang/protobuf v1.3.1/go.mod h1:6lQm79b+lXiMfvg/cZm0SGofjICqVBUtrP5yJMmIC1U=\ngithub.com/golang/protobuf v1.3.4 h1:87PNWwrRvUSnqS4dlcBU/ftvOIBep4sYuBLlh6rX2wk=\ngithub.com/golang/protobuf v1.3.4/go.mod h1:vzj43D7+SQXF/4pzW/hwtAqwc6iTitCiVSaWz5lYuqw=\ngithub.com/google/btree v0.0.0-20180813153112-4030bb1f1f0c/go.mod h1:lNA+9X1NB3Zf8V7Ke586lFgjr2dZNuvo3lPJSGZ5JPQ=\ngithub.com/google/btree v1.0.0/go.mod h1:lNA+9X1NB3Zf8V7Ke586lFgjr2dZNuvo3lPJSGZ5JPQ=\ngithub.com/google/go-cmp v0.2.0/go.mod h1:oXzfMopK8JAjlY9xF4vHSVASa0yLyX7SntLO5aqRK0M=\ngithub.com/google/go-cmp v0.3.0 h1:crn/baboCvb5fXaQ0IJ1SGTsTVrWpDsCWC8EGETZijY=\ngithub.com/google/go-cmp v0.3.0/go.mod h1:8QqcDgzrUqlUb/G2PQTWiueGozuR1884gddMywk6iLU=\ngithub.com/google/go-github/v27 v27.0.4 h1:N/EEqsvJLgqTbepTiMBz+12KhwLovv6YvwpRezd+4Fg=\ngithub.com/google/go-github/v27 v27.0.4/go.mod h1:/0Gr8pJ55COkmv+S/yPKCczSkUPIM/LnFyubufRNIS0=\ngithub.com/google/go-querystring v1.0.0 h1:Xkwi/a1rcvNg1PPYe5vI8GbeBY/jrVuDX5ASuANWTrk=\ngithub.com/google/go-querystring v1.0.0/go.mod h1:odCYkC5MyYFN7vkCjXpyrEuKhc/BUO6wN/zVPAxq5ck=\ngithub.com/google/martian v2.1.0+incompatible h1:/CP5g8u/VJHijgedC/Legn3BAbAaWPgecwXBIDzw5no=\ngithub.com/google/martian v2.1.0+incompatible/go.mod h1:9I4somxYTbIHy5NJKHRl3wXiIaQGbYVAs8BPL6v8lEs=\ngithub.com/google/pprof v0.0.0-20181206194817-3ea8567a2e57/go.mod h1:zfwlbNMJ+OItoe0UupaVj+oy1omPYYDuagoSzA8v9mc=\ngithub.com/google/pprof v0.0.0-20190515194954-54271f7e092f/go.mod h1:zfwlbNMJ+OItoe0UupaVj+oy1omPYYDuagoSzA8v9mc=\ngithub.com/googleapis/gax-go/v2 v2.0.4/go.mod h1:0Wqv26UfaUD9n4G6kQubkQ+KchISgw+vpHVxEJEs9eg=\ngithub.com/googleapis/gax-go/v2 v2.0.5 h1:sjZBwGj9Jlw33ImPtvFviGYvseOtDM7hkSKB7+Tv3SM=\ngithub.com/googleapis/gax-go/v2 v2.0.5/go.mod h1:DWXyrwAJ9X0FpwwEdw+IPEYBICEFu5mhpdKc/us6bOk=\ngithub.com/gorilla/websocket v1.4.0/go.mod h1:E7qHFY5m1UJ88s3WnNqhKjPHQ0heANvMoAMk2YaljkQ=\ngithub.com/grpc-ecosystem/go-grpc-middleware v1.0.0/go.mod h1:FiyG127CGDf3tlThmgyCl78X/SZQqEOJBCDaAfeWzPs=\ngithub.com/grpc-ecosystem/go-grpc-prometheus v1.2.0/go.mod h1:8NvIoxWQoOIhqOTXgfV/d3M/q6VIi02HzZEHgUlZvzk=\ngithub.com/grpc-ecosystem/grpc-gateway v1.9.0/go.mod h1:vNeuVxBJEsws4ogUvrchl83t/GYV9WGTSLVdBhOQFDY=\ngithub.com/hashicorp/golang-lru v0.5.0/go.mod h1:/m3WP610KZHVQ1SGc6re/UDhFvYD7pJ4Ao+sR/qLZy8=\ngithub.com/hashicorp/golang-lru v0.5.1 h1:0hERBMJE1eitiLkihrMvRVBYAkpHzc/J3QdDN+dAcgU=\ngithub.com/hashicorp/golang-lru v0.5.1/go.mod h1:/m3WP610KZHVQ1SGc6re/UDhFvYD7pJ4Ao+sR/qLZy8=\ngithub.com/hashicorp/hcl v1.0.0/go.mod h1:E5yfLk+7swimpb2L/Alb/PJmXilQ/rhwaUYs4T20WEQ=\ngithub.com/inconshreveable/mousetrap v1.0.0/go.mod h1:PxqpIevigyE2G7u3NXJIT2ANytuPF1OarO4DADm73n8=\ngithub.com/jonboulle/clockwork v0.1.0/go.mod h1:Ii8DK3G1RaLaWxj9trq07+26W01tbo22gdxWY5EU2bo=\ngithub.com/jstemmer/go-junit-report v0.0.0-20190106144839-af01ea7f8024/go.mod h1:6v2b51hI/fHJwM22ozAgKL4VKDeJcHhJFhtBdhmNjmU=\ngithub.com/julienschmidt/httprouter v1.2.0/go.mod h1:SYymIcj16QtmaHHD7aYtjjsJG7VTCxuUUipMqKk8s4w=\ngithub.com/kisielk/errcheck v1.1.0/go.mod h1:EZBBE59ingxPouuu3KfxchcWSUPOHkagtvWXihfKN4Q=\ngithub.com/kisielk/gotool v1.0.0/go.mod h1:XhKaO+MFFWcvkIS/tQcRk01m1F5IRFswLeQ+oQHNcck=\ngithub.com/knq/sysutil v0.0.0-20191005231841-15668db23d08/go.mod h1:dFWs1zEqDjFtnBXsd1vPOZaLsESovai349994nHx3e0=\ngithub.com/konsorten/go-windows-terminal-sequences v1.0.1/go.mod h1:T0+1ngSBFLxvqU3pZ+m/2kptfBszLMUkC4ZK/EgS/cQ=\ngithub.com/kr/logfmt v0.0.0-20140226030751-b84e30acd515/go.mod h1:+0opPa2QZZtGFBFZlji/RkVcI2GknAs/DXo4wKdlNEc=\ngithub.com/kr/pretty v0.1.0/go.mod h1:dAy3ld7l9f0ibDNOQOHHMYYIIbhfbHSm3C4ZsoJORNo=\ngithub.com/kr/pty v1.1.1/go.mod h1:pFQYn66WHrOpPYNljwOMqo10TkYh1fy3cYio2l3bCsQ=\ngithub.com/kr/text v0.1.0/go.mod h1:4Jbv+DJW3UT/LiOwJeYQe1efqtUx/iVham/4vfdArNI=\ngithub.com/magiconair/properties v1.8.0/go.mod h1:PppfXfuXeibc/6YijjN8zIbojt8czPbwD3XqdrwzmxQ=\ngithub.com/mailru/easyjson v0.7.0/go.mod h1:KAzv3t3aY1NaHWoQz1+4F1ccyAH66Jk7yos7ldAVICs=\ngithub.com/matttproud/golang_protobuf_extensions v1.0.1/go.mod h1:D8He9yQNgCq6Z5Ld7szi9bcBfOoFv/3dc6xSMkL2PC0=\ngithub.com/mediabuyerbot/go-crx3 v1.3.1 h1:JG3Hlaf7FsMhTJHBt+iEO5bK1GTh/Ms/cBT2aR2kBUE=\ngithub.com/mediabuyerbot/go-crx3 v1.3.1/go.mod h1:ecvIxF/Jv0jTy1JSx7YTuMlYpV49ayyW/pPxMl8o3P8=\ngithub.com/mitchellh/go-homedir v1.1.0/go.mod h1:SfyaCUpYCn1Vlf4IUYiD9fPX4A5wJrkLzIz1N1q0pr0=\ngithub.com/mitchellh/mapstructure v1.1.2/go.mod h1:FVVH3fgwuzCH5S8UJGiWEs2h04kUh9fWfEaFds41c1Y=\ngithub.com/mwitkow/go-conntrack v0.0.0-20161129095857-cc309e4a2223/go.mod h1:qRWi+5nqEBWmkhHvq77mSJWrCKwh8bxhgT7d/eI7P4U=\ngithub.com/oklog/ulid v1.3.1/go.mod h1:CirwcVhetQ6Lv90oh/F+FBtV6XMibvdAFo93nm5qn4U=\ngithub.com/pelletier/go-toml v1.2.0/go.mod h1:5z9KED0ma1S8pY6P1sdut58dfprrGBbd/94hg7ilaic=\ngithub.com/pkg/errors v0.8.0/go.mod h1:bwawxfHBFNV+L2hUp1rHADufV3IMtnDRdf1r5NINEl0=\ngithub.com/pmezard/go-difflib v1.0.0/go.mod h1:iKH77koFhYxTK1pcRnkKkqfTogsbg7gZNVY4sRDYZ/4=\ngithub.com/prometheus/client_golang v0.9.1/go.mod h1:7SWBe2y4D6OKWSNQJUaRYU/AaXPKyh/dDVn+NZz0KFw=\ngithub.com/prometheus/client_golang v0.9.3/go.mod h1:/TN21ttK/J9q6uSwhBd54HahCDft0ttaMvbicHlPoso=\ngithub.com/prometheus/client_model v0.0.0-20180712105110-5c3871d89910/go.mod h1:MbSGuTsp3dbXC40dX6PRTWyKYBIrTGTE9sqQNg2J8bo=\ngithub.com/prometheus/client_model v0.0.0-20190129233127-fd36f4220a90/go.mod h1:xMI15A0UPsDsEKsMN9yxemIoYk6Tm2C1GtYGdfGttqA=\ngithub.com/prometheus/common v0.0.0-20181113130724-41aa239b4cce/go.mod h1:daVV7qP5qjZbuso7PdcryaAu0sAZbrN9i7WWcTMWvro=\ngithub.com/prometheus/common v0.4.0/go.mod h1:TNfzLD0ON7rHzMJeJkieUDPYmFC7Snx/y86RQel1bk4=\ngithub.com/prometheus/procfs v0.0.0-20181005140218-185b4288413d/go.mod h1:c3At6R/oaqEKCNdg8wHV1ftS6bRYblBhIjjI8uT2IGk=\ngithub.com/prometheus/procfs v0.0.0-20190507164030-5867b95ac084/go.mod h1:TjEm7ze935MbeOT/UhFTIMYKhuLP4wbCsTZCD3I8kEA=\ngithub.com/prometheus/tsdb v0.7.1/go.mod h1:qhTCs0VvXwvX/y3TZrWD7rabWM+ijKTux40TwIPHuXU=\ngithub.com/rogpeppe/fastuuid v0.0.0-20150106093220-6724a57986af/go.mod h1:XWv6SoW27p1b0cqNHllgS5HIMJraePCO15w5zCzIWYg=\ngithub.com/russross/blackfriday/v2 v2.0.1/go.mod h1:+Rmxgy9KzJVeS9/2gXHxylqXiyQDYRxCVz55jmeOWTM=\ngithub.com/shurcooL/sanitized_anchor_name v1.0.0/go.mod h1:1NzhyTcUVG4SuEtjjoZeVRXNmyL/1OwPU0+IJeTBvfc=\ngithub.com/sirupsen/logrus v1.2.0/go.mod h1:LxeOpSwHxABJmUn/MG1IvRgCAasNZTLOkJPxbbu5VWo=\ngithub.com/soheilhy/cmux v0.1.4/go.mod h1:IM3LyeVVIOuxMH7sFAkER9+bJ4dT7Ms6E4xg4kGIyLM=\ngithub.com/spaolacci/murmur3 v0.0.0-20180118202830-f09979ecbc72/go.mod h1:JwIasOWyU6f++ZhiEuf87xNszmSA2myDM2Kzu9HwQUA=\ngithub.com/spf13/afero v1.1.2/go.mod h1:j4pytiNVoe2o6bmDsKpLACNPDBIoEAkihy7loJ1B0CQ=\ngithub.com/spf13/cast v1.3.0/go.mod h1:Qx5cxh0v+4UWYiBimWS+eyWzqEqokIECu5etghLkUJE=\ngithub.com/spf13/cobra v0.0.6/go.mod h1:/6GTrnGXV9HjY+aR4k0oJ5tcvakLuG6EuKReYlHNrgE=\ngithub.com/spf13/jwalterweatherman v1.0.0/go.mod h1:cQK4TGJAtQXfYWX+Ddv3mKDzgVb68N+wFjFa4jdeBTo=\ngithub.com/spf13/pflag v1.0.3/go.mod h1:DYY7MBk1bdzusC3SYhjObp+wFpr4gzcvqqNjLnInEg4=\ngithub.com/spf13/viper v1.4.0/go.mod h1:PTJ7Z/lr49W6bUbkmS1V3by4uWynFiR9p7+dSq/yZzE=\ngithub.com/stretchr/objx v0.1.0/go.mod h1:HFkY916IF+rwdDfMAkV7OtwuqBVzrE8GR6GFx+wExME=\ngithub.com/stretchr/objx v0.1.1/go.mod h1:HFkY916IF+rwdDfMAkV7OtwuqBVzrE8GR6GFx+wExME=\ngithub.com/stretchr/testify v1.2.2/go.mod h1:a8OnRcib4nhh0OaRAV+Yts87kKdq0PP7pXfy6kDkUVs=\ngithub.com/stretchr/testify v1.5.1/go.mod h1:5W2xD1RspED5o8YsWQXVCued0rvSQ+mT+I5cxcmMvtA=\ngithub.com/tmc/grpc-websocket-proxy v0.0.0-20190109142713-0ad062ec5ee5/go.mod h1:ncp9v5uamzpCO7NfCPTXjqaC+bZgJeR0sMTm6dMHP7U=\ngithub.com/ugorji/go v1.1.4/go.mod h1:uQMGLiO92mf5W77hV/PUCpI3pbzQx3CRekS0kk+RGrc=\ngithub.com/xiang90/probing v0.0.0-20190116061207-43a291ad63a2/go.mod h1:UETIi67q53MR2AWcXfiuqkDkRtnGDLqkBTpCHuJHxtU=\ngithub.com/xordataexchange/crypt v0.0.3-0.20170626215501-b2862e3d0a77/go.mod h1:aYKd//L2LvnjZzWKhF00oedf4jCCReLcmhLdhm1A27Q=\ngo.etcd.io/bbolt v1.3.2/go.mod h1:IbVyRI1SCnLcuJnV2u8VeU0CEYM7e686BmAb1XKL+uU=\ngo.opencensus.io v0.21.0/go.mod h1:mSImk1erAIZhrmZN+AvHh14ztQfjbGwt4TtuofqLduU=\ngo.opencensus.io v0.22.0 h1:C9hSCOW830chIVkdja34wa6Ky+IzWllkUinR+BtRZd4=\ngo.opencensus.io v0.22.0/go.mod h1:+kGneAE2xo2IficOXnaByMWTGM9T73dGwxeWcUqIpI8=\ngo.uber.org/atomic v1.4.0/go.mod h1:gD2HeocX3+yG+ygLZcrzQJaqmWj9AIm7n08wl/qW/PE=\ngo.uber.org/multierr v1.1.0/go.mod h1:wR5kodmAFQ0UK8QlbwjlSNy0Z68gJhDJUG5sjR94q/0=\ngo.uber.org/zap v1.10.0/go.mod h1:vwi/ZaCAaUcBkycHslxD9B2zi4UTXhF60s6SWpuDF0Q=\ngolang.org/x/crypto v0.0.0-20180904163835-0709b304e793/go.mod h1:6SG95UA2DQfeDnfUPMdvaQW0Q7yPrPDi9nlGo2tz2b4=\ngolang.org/x/crypto v0.0.0-20190308221718-c2843e01d9a2/go.mod h1:djNgcEr1/C05ACkg1iLfiJU5Ep61QUkGW8qpdssI0+w=\ngolang.org/x/crypto v0.0.0-20190605123033-f99c8df09eb5 h1:58fnuSXlxZmFdJyvtTFVmVhcMLU6v5fEb/ok4wyqtNU=\ngolang.org/x/crypto v0.0.0-20190605123033-f99c8df09eb5/go.mod h1:yigFU9vqHzYiE8UmvKecakEJjdnWj3jj499lnFckfCI=\ngolang.org/x/exp v0.0.0-20190121172915-509febef88a4/go.mod h1:CJ0aWSM057203Lf6IL+f9T1iT9GByDxfZKAQTCR3kQA=\ngolang.org/x/exp v0.0.0-20190510132918-efd6b22b2522/go.mod h1:ZjyILWgesfNpC6sMxTJOJm9Kp84zZh5NQWvqDGG3Qr8=\ngolang.org/x/image v0.0.0-20190227222117-0694c2d4d067/go.mod h1:kZ7UVZpmo3dzQBMxlp+ypCbDeSB+sBbTgSJuh5dn5js=\ngolang.org/x/lint v0.0.0-20181026193005-c67002cb31c3/go.mod h1:UVdnD1Gm6xHRNCYTkRU2/jEulfH38KcIWyp/GAMgvoE=\ngolang.org/x/lint v0.0.0-20190227174305-5b3e6a55c961/go.mod h1:wehouNa3lNwaWXcvxsM5YxQ5yQlVC4a0KAMCusXpPoU=\ngolang.org/x/lint v0.0.0-20190301231843-5614ed5bae6f/go.mod h1:UVdnD1Gm6xHRNCYTkRU2/jEulfH38KcIWyp/GAMgvoE=\ngolang.org/x/lint v0.0.0-20190313153728-d0100b6bd8b3/go.mod h1:6SW0HCj/g11FgYtHlgUYUwCkIfeOF89ocIRzGO/8vkc=\ngolang.org/x/lint v0.0.0-20190409202823-959b441ac422/go.mod h1:6SW0HCj/g11FgYtHlgUYUwCkIfeOF89ocIRzGO/8vkc=\ngolang.org/x/mobile v0.0.0-20190312151609-d3739f865fa6/go.mod h1:z+o9i4GpDbdi3rU15maQ/Ox0txvL9dWGYEHz965HBQE=\ngolang.org/x/net v0.0.0-20180724234803-3673e40ba225/go.mod h1:mL1N/T3taQHkDXs73rZJwtUhF3w3ftmwwsq0BUmARs4=\ngolang.org/x/net v0.0.0-20180826012351-8a410e7b638d/go.mod h1:mL1N/T3taQHkDXs73rZJwtUhF3w3ftmwwsq0BUmARs4=\ngolang.org/x/net v0.0.0-20181114220301-adae6a3d119a/go.mod h1:mL1N/T3taQHkDXs73rZJwtUhF3w3ftmwwsq0BUmARs4=\ngolang.org/x/net v0.0.0-20181220203305-927f97764cc3/go.mod h1:mL1N/T3taQHkDXs73rZJwtUhF3w3ftmwwsq0BUmARs4=\ngolang.org/x/net v0.0.0-20190108225652-1e06a53dbb7e/go.mod h1:mL1N/T3taQHkDXs73rZJwtUhF3w3ftmwwsq0BUmARs4=\ngolang.org/x/net v0.0.0-20190213061140-3a22650c66bd/go.mod h1:mL1N/T3taQHkDXs73rZJwtUhF3w3ftmwwsq0BUmARs4=\ngolang.org/x/net v0.0.0-20190311183353-d8887717615a/go.mod h1:t9HGtf8HONx5eT2rtn7q6eTqICYqUVnKs3thJo3Qplg=\ngolang.org/x/net v0.0.0-20190404232315-eb5bcb51f2a3/go.mod h1:t9HGtf8HONx5eT2rtn7q6eTqICYqUVnKs3thJo3Qplg=\ngolang.org/x/net v0.0.0-20190501004415-9ce7a6920f09/go.mod h1:t9HGtf8HONx5eT2rtn7q6eTqICYqUVnKs3thJo3Qplg=\ngolang.org/x/net v0.0.0-20190503192946-f4e77d36d62c/go.mod h1:t9HGtf8HONx5eT2rtn7q6eTqICYqUVnKs3thJo3Qplg=\ngolang.org/x/net v0.0.0-20190522155817-f3200d17e092/go.mod h1:HSz+uSET+XFnRR8LxR5pz3Of3rY3CfYBVs4xY44aLks=\ngolang.org/x/net v0.0.0-20190603091049-60506f45cf65/go.mod h1:HSz+uSET+XFnRR8LxR5pz3Of3rY3CfYBVs4xY44aLks=\ngolang.org/x/net v0.0.0-20190620200207-3b0461eec859 h1:R/3boaszxrf1GEUWTVDzSKVwLmSJpwZ1yqXm8j0v2QI=\ngolang.org/x/net v0.0.0-20190620200207-3b0461eec859/go.mod h1:z5CRVTTTmAJ677TzLLGU+0bjPO0LkuOLi4/5GtJWs/s=\ngolang.org/x/oauth2 v0.0.0-20180821212333-d2e6202438be/go.mod h1:N/0e6XlmueqKjAGxoOufVs8QHGRruUQn6yWY3a++T0U=\ngolang.org/x/oauth2 v0.0.0-20190226205417-e64efc72b421/go.mod h1:gOpvHmFTYa4IltrdGE7lF6nIHvwfUNPOp7c8zoXwtLw=\ngolang.org/x/oauth2 v0.0.0-20190604053449-0f29369cfe45 h1:SVwTIAaPC2U/AvvLNZ2a7OVsmBpC8L5BlwK1whH3hm0=\ngolang.org/x/oauth2 v0.0.0-20190604053449-0f29369cfe45/go.mod h1:gOpvHmFTYa4IltrdGE7lF6nIHvwfUNPOp7c8zoXwtLw=\ngolang.org/x/sync v0.0.0-20180314180146-1d60e4601c6f/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=\ngolang.org/x/sync v0.0.0-20181108010431-42b317875d0f/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=\ngolang.org/x/sync v0.0.0-20181221193216-37e7f081c4d4/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=\ngolang.org/x/sync v0.0.0-20190227155943-e225da77a7e6/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=\ngolang.org/x/sync v0.0.0-20190423024810-112230192c58/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=\ngolang.org/x/sys v0.0.0-20180830151530-49385e6e1522/go.mod h1:STP8DvDyc/dI5b8T5hshtkjS+E42TnysNCUPdjciGhY=\ngolang.org/x/sys v0.0.0-20180905080454-ebe1bf3edb33/go.mod h1:STP8DvDyc/dI5b8T5hshtkjS+E42TnysNCUPdjciGhY=\ngolang.org/x/sys v0.0.0-20181107165924-66b7b1311ac8/go.mod h1:STP8DvDyc/dI5b8T5hshtkjS+E42TnysNCUPdjciGhY=\ngolang.org/x/sys v0.0.0-20181116152217-5ac8a444bdc5/go.mod h1:STP8DvDyc/dI5b8T5hshtkjS+E42TnysNCUPdjciGhY=\ngolang.org/x/sys v0.0.0-20190215142949-d0b11bdaac8a/go.mod h1:STP8DvDyc/dI5b8T5hshtkjS+E42TnysNCUPdjciGhY=\ngolang.org/x/sys v0.0.0-20190312061237-fead79001313/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20190412213103-97732733099d/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20190502145724-3ef323f4f1fd/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20190507160741-ecd444e8653b/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20190606165138-5da285871e9c/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20190624142023-c5567b49c5d0 h1:HyfiK1WMnHj5FXFXatD+Qs1A/xC2Run6RzeW1SyHxpc=\ngolang.org/x/sys v0.0.0-20190624142023-c5567b49c5d0/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/text v0.3.0/go.mod h1:NqM8EUOU14njkJ3fqMW+pc6Ldnwhi/IjpwHt7yyuwOQ=\ngolang.org/x/text v0.3.1-0.20180807135948-17ff2d5776d2/go.mod h1:NqM8EUOU14njkJ3fqMW+pc6Ldnwhi/IjpwHt7yyuwOQ=\ngolang.org/x/text v0.3.2 h1:tW2bmiBqwgJj/UpqtC8EpXEZVYOwU0yG4iWbprSVAcs=\ngolang.org/x/text v0.3.2/go.mod h1:bEr9sfX3Q8Zfm5fL9x+3itogRgK3+ptLWKqgva+5dAk=\ngolang.org/x/time v0.0.0-20181108054448-85acf8d2951c/go.mod h1:tRJNPiyCQ0inRvYxbN9jk5I+vvW/OXSQhTDSoE431IQ=\ngolang.org/x/time v0.0.0-20190308202827-9d24e82272b4/go.mod h1:tRJNPiyCQ0inRvYxbN9jk5I+vvW/OXSQhTDSoE431IQ=\ngolang.org/x/tools v0.0.0-20180221164845-07fd8470d635/go.mod h1:n7NCudcB/nEzxVGmLbDWY5pfWTLqBcC2KZ6jyYvM4mQ=\ngolang.org/x/tools v0.0.0-20180917221912-90fa682c2a6e/go.mod h1:n7NCudcB/nEzxVGmLbDWY5pfWTLqBcC2KZ6jyYvM4mQ=\ngolang.org/x/tools v0.0.0-20190114222345-bf090417da8b/go.mod h1:n7NCudcB/nEzxVGmLbDWY5pfWTLqBcC2KZ6jyYvM4mQ=\ngolang.org/x/tools v0.0.0-20190226205152-f727befe758c/go.mod h1:9Yl7xja0Znq3iFh3HoIrodX9oNMXvdceNzlUR8zjMvY=\ngolang.org/x/tools v0.0.0-20190311212946-11955173bddd/go.mod h1:LCzVGOaR6xXOjkQ3onu1FJEFr0SW1gC7cKk1uF8kGRs=\ngolang.org/x/tools v0.0.0-20190312151545-0bb0c0a6e846/go.mod h1:LCzVGOaR6xXOjkQ3onu1FJEFr0SW1gC7cKk1uF8kGRs=\ngolang.org/x/tools v0.0.0-20190312170243-e65039ee4138/go.mod h1:LCzVGOaR6xXOjkQ3onu1FJEFr0SW1gC7cKk1uF8kGRs=\ngolang.org/x/tools v0.0.0-20190425150028-36563e24a262/go.mod h1:RgjU9mgBXZiqYHBnxXauZ1Gv1EHHAz9KjViQ78xBX0Q=\ngolang.org/x/tools v0.0.0-20190506145303-2d16b83fe98c/go.mod h1:RgjU9mgBXZiqYHBnxXauZ1Gv1EHHAz9KjViQ78xBX0Q=\ngolang.org/x/tools v0.0.0-20190606124116-d0a3d012864b/go.mod h1:/rFqwRUd4F7ZHNgwSSTFct+R/Kf4OFW1sUzUTQQTgfc=\ngolang.org/x/tools v0.0.0-20190624190245-7f2218787638/go.mod h1:/rFqwRUd4F7ZHNgwSSTFct+R/Kf4OFW1sUzUTQQTgfc=\ngoogle.golang.org/api v0.4.0/go.mod h1:8k5glujaEP+g9n7WNsDg8QP6cUVNI86fCNMcbazEtwE=\ngoogle.golang.org/api v0.7.0 h1:9sdfJOzWlkqPltHAuzT2Cp+yrBeY1KRVYgms8soxMwM=\ngoogle.golang.org/api v0.7.0/go.mod h1:WtwebWUNSVBH/HAw79HIFXZNqEvBhG+Ra+ax0hx3E3M=\ngoogle.golang.org/appengine v1.1.0/go.mod h1:EbEs0AVv82hx2wNQdGPgUI5lhzA/G0D9YwlJXL52JkM=\ngoogle.golang.org/appengine v1.4.0/go.mod h1:xpcJRLb0r/rnEns0DIKYYv+WjYCduHsrkT7/EB5XEv4=\ngoogle.golang.org/appengine v1.5.0/go.mod h1:xpcJRLb0r/rnEns0DIKYYv+WjYCduHsrkT7/EB5XEv4=\ngoogle.golang.org/appengine v1.6.1 h1:QzqyMA1tlu6CgqCDUtU9V+ZKhLFT2dkJuANu5QaxI3I=\ngoogle.golang.org/appengine v1.6.1/go.mod h1:i06prIuMbXzDqacNJfV5OdTW448YApPu5ww/cMBSeb0=\ngoogle.golang.org/genproto v0.0.0-20180817151627-c66870c02cf8/go.mod h1:JiN7NxoALGmiZfu7CAH4rXhgtRTLTxftemlI0sWmxmc=\ngoogle.golang.org/genproto v0.0.0-20190307195333-5fe7a883aa19/go.mod h1:VzzqZJRnGkLBvHegQrXjBqPurQTc5/KpmUdxsrq26oE=\ngoogle.golang.org/genproto v0.0.0-20190418145605-e7d98fc518a7/go.mod h1:VzzqZJRnGkLBvHegQrXjBqPurQTc5/KpmUdxsrq26oE=\ngoogle.golang.org/genproto v0.0.0-20190425155659-357c62f0e4bb/go.mod h1:VzzqZJRnGkLBvHegQrXjBqPurQTc5/KpmUdxsrq26oE=\ngoogle.golang.org/genproto v0.0.0-20190502173448-54afdca5d873/go.mod h1:VzzqZJRnGkLBvHegQrXjBqPurQTc5/KpmUdxsrq26oE=\ngoogle.golang.org/genproto v0.0.0-20190626174449-989357319d63 h1:UsSJe9fhWNSz6emfIGPpH5DF23t7ALo2Pf3sC+/hsdg=\ngoogle.golang.org/genproto v0.0.0-20190626174449-989357319d63/go.mod h1:z3L6/3dTEVtUr6QSP8miRzeRqwQOioJ9I66odjN4I7s=\ngoogle.golang.org/grpc v1.19.0/go.mod h1:mqu4LbDTu4XGKhr4mRzUsmM4RtVoemTSY81AxZiDr8c=\ngoogle.golang.org/grpc v1.20.1/go.mod h1:10oTOabMzJvdu6/UiuZezV6QK5dSlG84ov/aaiqXj38=\ngoogle.golang.org/grpc v1.21.0/go.mod h1:oYelfM1adQP15Ek0mdvEgi9Df8B9CZIaU1084ijfRaM=\ngoogle.golang.org/grpc v1.21.1 h1:j6XxA85m/6txkUCHvzlV5f+HBNl/1r5cZ2A/3IEFOO8=\ngoogle.golang.org/grpc v1.21.1/go.mod h1:oYelfM1adQP15Ek0mdvEgi9Df8B9CZIaU1084ijfRaM=\ngopkg.in/alecthomas/kingpin.v2 v2.2.6/go.mod h1:FMv+mEhP44yOT+4EoQTLFTRgOQ1FBLkstjWtayDeSgw=\ngopkg.in/check.v1 v0.0.0-20161208181325-20d25e280405/go.mod h1:Co6ibVJAznAaIkqp8huTwlJQCZ016jof/cbN4VW5Yz0=\ngopkg.in/check.v1 v1.0.0-20180628173108-788fd7840127/go.mod h1:Co6ibVJAznAaIkqp8huTwlJQCZ016jof/cbN4VW5Yz0=\ngopkg.in/resty.v1 v1.12.0/go.mod h1:mDo4pnntr5jdWRML875a/NmxYqAlA73dVijT2AXvQQo=\ngopkg.in/yaml.v2 v2.0.0-20170812160011-eb3733d160e7/go.mod h1:JAlM8MvJe8wmxCU4Bli9HhUf9+ttbYbLASfIpnQbh74=\ngopkg.in/yaml.v2 v2.2.1/go.mod h1:hI93XBmqTisBFMUTm0b8Fm+jr3Dg1NNxqwp+5A1VGuI=\ngopkg.in/yaml.v2 v2.2.2/go.mod h1:hI93XBmqTisBFMUTm0b8Fm+jr3Dg1NNxqwp+5A1VGuI=\nhonnef.co/go/tools v0.0.0-20190102054323-c2f93a96b099/go.mod h1:rf3lG4BRIbNafJWhAfAdb/ePZxsR/4RtNHQocxwk9r4=\nhonnef.co/go/tools v0.0.0-20190106161140-3f1c8253044a/go.mod h1:rf3lG4BRIbNafJWhAfAdb/ePZxsR/4RtNHQocxwk9r4=\nhonnef.co/go/tools v0.0.0-20190418001031-e561f6794a2a/go.mod h1:rf3lG4BRIbNafJWhAfAdb/ePZxsR/4RtNHQocxwk9r4=\nrsc.io/binaryregexp v0.2.0/go.mod h1:qTv7/COck+e2FymRvadv62gMdZztPaShugOCi3I+8D8=\n"
        },
        {
          "name": "internal",
          "type": "tree",
          "content": null
        },
        {
          "name": "log",
          "type": "tree",
          "content": null
        },
        {
          "name": "misc",
          "type": "tree",
          "content": null
        },
        {
          "name": "remote.go",
          "type": "blob",
          "size": 40.7490234375,
          "content": "// Remote Selenium client implementation.\n// See https://www.w3.org/TR/webdriver for the protocol.\n\npackage selenium\n\nimport (\n\t\"bytes\"\n\t\"encoding/base64\"\n\t\"encoding/json\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"mime\"\n\t\"net/http\"\n\t\"net/url\"\n\t\"path\"\n\t\"strings\"\n\t\"time\"\n\n\t\"github.com/blang/semver\"\n\t\"github.com/tebeka/selenium/firefox\"\n\t\"github.com/tebeka/selenium/log\"\n)\n\n// Errors returned by Selenium server.\nvar remoteErrors = map[int]string{\n\t6:  \"invalid session ID\",\n\t7:  \"no such element\",\n\t8:  \"no such frame\",\n\t9:  \"unknown command\",\n\t10: \"stale element reference\",\n\t11: \"element not visible\",\n\t12: \"invalid element state\",\n\t13: \"unknown error\",\n\t15: \"element is not selectable\",\n\t17: \"javascript error\",\n\t19: \"xpath lookup error\",\n\t21: \"timeout\",\n\t23: \"no such window\",\n\t24: \"invalid cookie domain\",\n\t25: \"unable to set cookie\",\n\t26: \"unexpected alert open\",\n\t27: \"no alert open\",\n\t28: \"script timeout\",\n\t29: \"invalid element coordinates\",\n\t32: \"invalid selector\",\n}\n\ntype remoteWD struct {\n\tid, urlPrefix string\n\tcapabilities  Capabilities\n\tw3cCompatible bool\n\t// storedActions stores KeyActions and PointerActions for later execution.\n\tstoredActions  Actions\n\tbrowser        string\n\tbrowserVersion semver.Version\n}\n\n// HTTPClient is the default client to use to communicate with the WebDriver\n// server.\nvar HTTPClient = http.DefaultClient\n\n// jsonContentType is JSON content type.\nconst jsonContentType = \"application/json\"\n\nfunc newRequest(method string, url string, data []byte) (*http.Request, error) {\n\trequest, err := http.NewRequest(method, url, bytes.NewBuffer(data))\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\trequest.Header.Add(\"Accept\", jsonContentType)\n\n\treturn request, nil\n}\n\nfunc (wd *remoteWD) requestURL(template string, args ...interface{}) string {\n\treturn wd.urlPrefix + fmt.Sprintf(template, args...)\n}\n\n// TODO(minusnine): provide a \"sessionURL\" function that prepends the\n// /session/<id> URL prefix and replace most requestURL (and voidCommand) calls\n// with it.\n\ntype serverReply struct {\n\tSessionID *string // SessionID can be nil.\n\tValue     json.RawMessage\n\n\t// The following fields were used prior to Selenium 3.0 for error state and\n\t// in ChromeDriver for additional information.\n\tStatus int\n\tState  string\n\n\tError\n}\n\n// Error contains information about a failure of a command. See the table of\n// these strings at https://www.w3.org/TR/webdriver/#handling-errors .\n//\n// This error type is only returned by servers that implement the W3C\n// specification.\ntype Error struct {\n\t// Err contains a general error string provided by the server.\n\tErr string `json:\"error\"`\n\t// Message is a detailed, human-readable message specific to the failure.\n\tMessage string `json:\"message\"`\n\t// Stacktrace may contain the server-side stacktrace where the error occurred.\n\tStacktrace string `json:\"stacktrace\"`\n\t// HTTPCode is the HTTP status code returned by the server.\n\tHTTPCode int\n\t// LegacyCode is the \"Response Status Code\" defined in the legacy Selenium\n\t// WebDriver JSON wire protocol. This code is only produced by older\n\t// Selenium WebDriver versions, Chromedriver, and InternetExplorerDriver.\n\tLegacyCode int\n}\n\n// TODO(minusnine): Make Stacktrace more descriptive. Selenium emits a list of\n// objects that enumerate various fields. This is not standard, though.\n\n// Error implements the error interface.\nfunc (e *Error) Error() string {\n\treturn fmt.Sprintf(\"%s: %s\", e.Err, e.Message)\n}\n\n// execute performs an HTTP request and inspects the returned data for an error\n// encoded by the remote end in a JSON structure. If no error is present, the\n// entire, raw request payload is returned.\nfunc (wd *remoteWD) execute(method, url string, data []byte) (json.RawMessage, error) {\n\treturn executeCommand(method, url, data)\n}\n\nfunc executeCommand(method, url string, data []byte) (json.RawMessage, error) {\n\tdebugLog(\"-> %s %s\\n%s\", method, filteredURL(url), data)\n\trequest, err := newRequest(method, url, data)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tresponse, err := HTTPClient.Do(request)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tbuf, err := ioutil.ReadAll(response.Body)\n\tif debugFlag {\n\t\tif err == nil {\n\t\t\t// Pretty print the JSON response\n\t\t\tvar prettyBuf bytes.Buffer\n\t\t\tif err = json.Indent(&prettyBuf, buf, \"\", \"    \"); err == nil && prettyBuf.Len() > 0 {\n\t\t\t\tbuf = prettyBuf.Bytes()\n\t\t\t}\n\t\t}\n\t\tdebugLog(\"<- %s [%s]\\n%s\", response.Status, response.Header[\"Content-Type\"], buf)\n\t}\n\tif err != nil {\n\t\treturn nil, errors.New(response.Status)\n\t}\n\n\tfullCType := response.Header.Get(\"Content-Type\")\n\tcType, _, err := mime.ParseMediaType(fullCType)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"got content type header %q, expected %q\", fullCType, jsonContentType)\n\t}\n\tif cType != jsonContentType {\n\t\treturn nil, fmt.Errorf(\"got content type %q, expected %q\", cType, jsonContentType)\n\t}\n\n\treply := new(serverReply)\n\tif err := json.Unmarshal(buf, reply); err != nil {\n\t\tif response.StatusCode != http.StatusOK {\n\t\t\treturn nil, fmt.Errorf(\"bad server reply status: %s\", response.Status)\n\t\t}\n\t\treturn nil, err\n\t}\n\tif reply.Err != \"\" {\n\t\treturn nil, &reply.Error\n\t}\n\n\t// Handle the W3C-compliant error format. In the W3C spec, the error is\n\t// embedded in the 'value' field.\n\tif len(reply.Value) > 0 {\n\t\trespErr := new(Error)\n\t\tif err := json.Unmarshal(reply.Value, respErr); err == nil && respErr.Err != \"\" {\n\t\t\trespErr.HTTPCode = response.StatusCode\n\t\t\treturn nil, respErr\n\t\t}\n\t}\n\n\t// Handle the legacy error format.\n\tconst success = 0\n\tif reply.Status != success {\n\t\tshortMsg, ok := remoteErrors[reply.Status]\n\t\tif !ok {\n\t\t\tshortMsg = fmt.Sprintf(\"unknown error - %d\", reply.Status)\n\t\t}\n\n\t\tlongMsg := new(struct {\n\t\t\tMessage string\n\t\t})\n\t\tif err := json.Unmarshal(reply.Value, longMsg); err != nil {\n\t\t\treturn nil, errors.New(shortMsg)\n\t\t}\n\t\treturn nil, &Error{\n\t\t\tErr:        shortMsg,\n\t\t\tMessage:    longMsg.Message,\n\t\t\tHTTPCode:   response.StatusCode,\n\t\t\tLegacyCode: reply.Status,\n\t\t}\n\t}\n\n\treturn buf, nil\n}\n\n// DefaultURLPrefix is the default HTTP endpoint that offers the WebDriver API.\nconst DefaultURLPrefix = \"http://127.0.0.1:4444/wd/hub\"\n\n// NewRemote creates new remote client, this will also start a new session.\n// capabilities provides the desired capabilities. urlPrefix is the URL to the\n// Selenium server, must be prefixed with protocol (http, https, ...).\n//\n// Providing an empty string for urlPrefix causes the DefaultURLPrefix to be\n// used.\nfunc NewRemote(capabilities Capabilities, urlPrefix string) (WebDriver, error) {\n\tif urlPrefix == \"\" {\n\t\turlPrefix = DefaultURLPrefix\n\t}\n\n\twd := &remoteWD{\n\t\turlPrefix:    urlPrefix,\n\t\tcapabilities: capabilities,\n\t}\n\tif b := capabilities[\"browserName\"]; b != nil {\n\t\twd.browser = b.(string)\n\t}\n\n\tif _, err := wd.NewSession(); err != nil {\n\t\treturn nil, err\n\t}\n\treturn wd, nil\n}\n\n// DeleteSession deletes an existing session at the WebDriver instance\n// specified by the urlPrefix and the session ID.\nfunc DeleteSession(urlPrefix, id string) error {\n\tu, err := url.Parse(urlPrefix)\n\tif err != nil {\n\t\treturn err\n\t}\n\tu.Path = path.Join(u.Path, \"session\", id)\n\treturn voidCommand(\"DELETE\", u.String(), nil)\n}\n\nfunc (wd *remoteWD) stringCommand(urlTemplate string) (string, error) {\n\turl := wd.requestURL(urlTemplate, wd.id)\n\tresponse, err := wd.execute(\"GET\", url, nil)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\treply := new(struct{ Value *string })\n\tif err := json.Unmarshal(response, reply); err != nil {\n\t\treturn \"\", err\n\t}\n\n\tif reply.Value == nil {\n\t\treturn \"\", fmt.Errorf(\"nil return value\")\n\t}\n\n\treturn *reply.Value, nil\n}\n\nfunc voidCommand(method, url string, params interface{}) error {\n\tif params == nil {\n\t\tparams = make(map[string]interface{})\n\t}\n\tdata, err := json.Marshal(params)\n\tif err != nil {\n\t\treturn err\n\t}\n\t_, err = executeCommand(method, url, data)\n\treturn err\n}\n\nfunc (wd *remoteWD) voidCommand(urlTemplate string, params interface{}) error {\n\treturn voidCommand(\"POST\", wd.requestURL(urlTemplate, wd.id), params)\n}\n\nfunc (wd remoteWD) stringsCommand(urlTemplate string) ([]string, error) {\n\turl := wd.requestURL(urlTemplate, wd.id)\n\tresponse, err := wd.execute(\"GET\", url, nil)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treply := new(struct{ Value []string })\n\tif err := json.Unmarshal(response, reply); err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn reply.Value, nil\n}\n\nfunc (wd *remoteWD) boolCommand(urlTemplate string) (bool, error) {\n\turl := wd.requestURL(urlTemplate, wd.id)\n\tresponse, err := wd.execute(\"GET\", url, nil)\n\tif err != nil {\n\t\treturn false, err\n\t}\n\n\treply := new(struct{ Value bool })\n\tif err := json.Unmarshal(response, reply); err != nil {\n\t\treturn false, err\n\t}\n\n\treturn reply.Value, nil\n}\n\nfunc (wd *remoteWD) Status() (*Status, error) {\n\turl := wd.requestURL(\"/status\")\n\treply, err := wd.execute(\"GET\", url, nil)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tstatus := new(struct{ Value Status })\n\tif err := json.Unmarshal(reply, status); err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn &status.Value, nil\n}\n\n// parseVersion sanitizes the browser version enough for semver.ParseTolerant\n// to parse it.\nfunc parseVersion(v string) (semver.Version, error) {\n\tparts := strings.Split(v, \".\")\n\tvar err error\n\tfor i := len(parts); i > 0; i-- {\n\t\tvar ver semver.Version\n\t\tver, err = semver.ParseTolerant(strings.Join(parts[:i], \".\"))\n\t\tif err == nil {\n\t\t\treturn ver, nil\n\t\t}\n\t}\n\treturn semver.Version{}, err\n}\n\n// The list of valid, top-level capability names, according to the W3C\n// specification.\n//\n// This must be kept in sync with the specification:\n// https://www.w3.org/TR/webdriver/#capabilities\nvar w3cCapabilityNames = []string{\n\t\"acceptInsecureCerts\",\n\t\"browserName\",\n\t\"browserVersion\",\n\t\"platformName\",\n\t\"pageLoadStrategy\",\n\t\"proxy\",\n\t\"setWindowRect\",\n\t\"timeouts\",\n\t\"unhandledPromptBehavior\",\n}\n\nvar chromeCapabilityNames = []string{\n\t// This is not a standardized top-level capability name, but Chromedriver\n\t// expects this capability here.\n\t// https://cs.chromium.org/chromium/src/chrome/test/chromedriver/capabilities.cc?rcl=0754b5d0aad903439a628618f0e41845f1988f0c&l=759\n\t\"loggingPrefs\",\n}\n\n// Create a W3C-compatible capabilities instance.\nfunc newW3CCapabilities(caps Capabilities) Capabilities {\n\tisValidW3CCapability := map[string]bool{}\n\tfor _, name := range w3cCapabilityNames {\n\t\tisValidW3CCapability[name] = true\n\t}\n\tif b, ok := caps[\"browserName\"]; ok && b == \"chrome\" {\n\t\tfor _, name := range chromeCapabilityNames {\n\t\t\tisValidW3CCapability[name] = true\n\t\t}\n\t}\n\n\talwaysMatch := make(Capabilities)\n\tfor name, value := range caps {\n\t\tif isValidW3CCapability[name] || strings.Contains(name, \":\") {\n\t\t\talwaysMatch[name] = value\n\t\t}\n\t}\n\n\t// Move the Firefox profile setting from the old location to the new\n\t// location.\n\tif prof, ok := caps[\"firefox_profile\"]; ok {\n\t\tif c, ok := alwaysMatch[firefox.CapabilitiesKey]; ok {\n\t\t\tfirefoxCaps := c.(firefox.Capabilities)\n\t\t\tif firefoxCaps.Profile == \"\" {\n\t\t\t\tfirefoxCaps.Profile = prof.(string)\n\t\t\t}\n\t\t} else {\n\t\t\talwaysMatch[firefox.CapabilitiesKey] = firefox.Capabilities{\n\t\t\t\tProfile: prof.(string),\n\t\t\t}\n\t\t}\n\t}\n\n\treturn Capabilities{\n\t\t\"alwaysMatch\": alwaysMatch,\n\t}\n}\n\nfunc (wd *remoteWD) NewSession() (string, error) {\n\t// Detect whether the remote end complies with the W3C specification:\n\t// non-compliant implementations use the top-level 'desiredCapabilities' JSON\n\t// key, whereas the specification mandates the 'capabilities' key.\n\t//\n\t// However, Selenium 3 currently does not implement this part of the specification.\n\t// https://github.com/SeleniumHQ/selenium/issues/2827\n\t//\n\t// TODO(minusnine): audit which ones of these are still relevant. The W3C\n\t// standard switched to the \"alwaysMatch\" version in February 2017.\n\tattempts := []struct {\n\t\tparams map[string]interface{}\n\t}{\n\t\t{map[string]interface{}{\n\t\t\t\"capabilities\":        newW3CCapabilities(wd.capabilities),\n\t\t\t\"desiredCapabilities\": wd.capabilities,\n\t\t}},\n\t\t{map[string]interface{}{\n\t\t\t\"capabilities\": map[string]interface{}{\n\t\t\t\t\"desiredCapabilities\": wd.capabilities,\n\t\t\t},\n\t\t}},\n\t\t{map[string]interface{}{\n\t\t\t\"desiredCapabilities\": wd.capabilities,\n\t\t}}}\n\n\tfor i, s := range attempts {\n\t\tdata, err := json.Marshal(s.params)\n\t\tif err != nil {\n\t\t\treturn \"\", err\n\t\t}\n\n\t\tresponse, err := wd.execute(\"POST\", wd.requestURL(\"/session\"), data)\n\t\tif err != nil {\n\t\t\treturn \"\", err\n\t\t}\n\n\t\treply := new(serverReply)\n\t\tif err := json.Unmarshal(response, reply); err != nil {\n\t\t\tif i < len(attempts) {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\treturn \"\", err\n\t\t}\n\t\tif reply.Status != 0 && i < len(attempts) {\n\t\t\tcontinue\n\t\t}\n\t\tif reply.SessionID != nil {\n\t\t\twd.id = *reply.SessionID\n\t\t}\n\n\t\tif len(reply.Value) > 0 {\n\t\t\ttype returnedCapabilities struct {\n\t\t\t\t// firefox via geckodriver: 55.0a1\n\t\t\t\tBrowserVersion string\n\t\t\t\t// chrome via chromedriver: 61.0.3116.0\n\t\t\t\t// firefox via selenium 2: 45.9.0\n\t\t\t\t// htmlunit: 9.4.3.v20170317\n\t\t\t\tVersion          string\n\t\t\t\tPageLoadStrategy string\n\t\t\t\tProxy            Proxy\n\t\t\t\tTimeouts         struct {\n\t\t\t\t\tImplicit       float32\n\t\t\t\t\tPageLoadLegacy float32 `json:\"page load\"`\n\t\t\t\t\tPageLoad       float32\n\t\t\t\t\tScript         float32\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tvalue := struct {\n\t\t\t\tSessionID string\n\n\t\t\t\t// The W3C specification moved most of the returned data into the\n\t\t\t\t// \"capabilities\" field.\n\t\t\t\tCapabilities *returnedCapabilities\n\n\t\t\t\t// Legacy implementations returned most data directly in the \"values\"\n\t\t\t\t// key.\n\t\t\t\treturnedCapabilities\n\t\t\t}{}\n\n\t\t\tif err := json.Unmarshal(reply.Value, &value); err != nil {\n\t\t\t\treturn \"\", fmt.Errorf(\"error unmarshalling value: %v\", err)\n\t\t\t}\n\t\t\tif value.SessionID != \"\" && wd.id == \"\" {\n\t\t\t\twd.id = value.SessionID\n\t\t\t}\n\t\t\tvar caps returnedCapabilities\n\t\t\tif value.Capabilities != nil {\n\t\t\t\tcaps = *value.Capabilities\n\t\t\t\twd.w3cCompatible = true\n\t\t\t} else {\n\t\t\t\tcaps = value.returnedCapabilities\n\t\t\t}\n\n\t\t\tfor _, s := range []string{caps.Version, caps.BrowserVersion} {\n\t\t\t\tif s == \"\" {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\tv, err := parseVersion(s)\n\t\t\t\tif err != nil {\n\t\t\t\t\tdebugLog(\"error parsing version: %v\\n\", err)\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\twd.browserVersion = v\n\t\t\t}\n\t\t}\n\n\t\treturn wd.id, nil\n\t}\n\tpanic(\"unreachable\")\n}\n\n// SessionId returns the current session ID\n//\n// Deprecated: This identifier is not Go-style correct. Use SessionID instead.\nfunc (wd *remoteWD) SessionId() string {\n\treturn wd.SessionID()\n}\n\n// SessionID returns the current session ID\nfunc (wd *remoteWD) SessionID() string {\n\treturn wd.id\n}\n\nfunc (wd *remoteWD) SwitchSession(sessionID string) error {\n\twd.id = sessionID\n\treturn nil\n}\n\nfunc (wd *remoteWD) Capabilities() (Capabilities, error) {\n\turl := wd.requestURL(\"/session/%s\", wd.id)\n\tresponse, err := wd.execute(\"GET\", url, nil)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tc := new(struct{ Value Capabilities })\n\tif err := json.Unmarshal(response, c); err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn c.Value, nil\n}\n\nfunc (wd *remoteWD) SetAsyncScriptTimeout(timeout time.Duration) error {\n\tif !wd.w3cCompatible {\n\t\treturn wd.voidCommand(\"/session/%s/timeouts/async_script\", map[string]uint{\n\t\t\t\"ms\": uint(timeout / time.Millisecond),\n\t\t})\n\t}\n\treturn wd.voidCommand(\"/session/%s/timeouts\", map[string]uint{\n\t\t\"script\": uint(timeout / time.Millisecond),\n\t})\n}\n\nfunc (wd *remoteWD) SetImplicitWaitTimeout(timeout time.Duration) error {\n\tif !wd.w3cCompatible {\n\t\treturn wd.voidCommand(\"/session/%s/timeouts/implicit_wait\", map[string]uint{\n\t\t\t\"ms\": uint(timeout / time.Millisecond),\n\t\t})\n\t}\n\treturn wd.voidCommand(\"/session/%s/timeouts\", map[string]uint{\n\t\t\"implicit\": uint(timeout / time.Millisecond),\n\t})\n}\n\nfunc (wd *remoteWD) SetPageLoadTimeout(timeout time.Duration) error {\n\tif !wd.w3cCompatible {\n\t\treturn wd.voidCommand(\"/session/%s/timeouts\", map[string]interface{}{\n\t\t\t\"ms\":   uint(timeout / time.Millisecond),\n\t\t\t\"type\": \"page load\",\n\t\t})\n\t}\n\treturn wd.voidCommand(\"/session/%s/timeouts\", map[string]uint{\n\t\t\"pageLoad\": uint(timeout / time.Millisecond),\n\t})\n}\n\nfunc (wd *remoteWD) Quit() error {\n\tif wd.id == \"\" {\n\t\treturn nil\n\t}\n\t_, err := wd.execute(\"DELETE\", wd.requestURL(\"/session/%s\", wd.id), nil)\n\tif err == nil {\n\t\twd.id = \"\"\n\t}\n\treturn err\n}\n\nfunc (wd *remoteWD) CurrentWindowHandle() (string, error) {\n\tif !wd.w3cCompatible {\n\t\treturn wd.stringCommand(\"/session/%s/window_handle\")\n\t}\n\treturn wd.stringCommand(\"/session/%s/window\")\n}\n\nfunc (wd *remoteWD) WindowHandles() ([]string, error) {\n\tif !wd.w3cCompatible {\n\t\treturn wd.stringsCommand(\"/session/%s/window_handles\")\n\t}\n\treturn wd.stringsCommand(\"/session/%s/window/handles\")\n}\n\nfunc (wd *remoteWD) CurrentURL() (string, error) {\n\turl := wd.requestURL(\"/session/%s/url\", wd.id)\n\tresponse, err := wd.execute(\"GET\", url, nil)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\treply := new(struct{ Value *string })\n\tif err := json.Unmarshal(response, reply); err != nil {\n\t\treturn \"\", err\n\t}\n\n\treturn *reply.Value, nil\n}\n\nfunc (wd *remoteWD) Get(url string) error {\n\trequestURL := wd.requestURL(\"/session/%s/url\", wd.id)\n\tparams := map[string]string{\n\t\t\"url\": url,\n\t}\n\tdata, err := json.Marshal(params)\n\tif err != nil {\n\t\treturn err\n\t}\n\t_, err = wd.execute(\"POST\", requestURL, data)\n\treturn err\n}\n\nfunc (wd *remoteWD) Forward() error {\n\treturn wd.voidCommand(\"/session/%s/forward\", nil)\n}\n\nfunc (wd *remoteWD) Back() error {\n\treturn wd.voidCommand(\"/session/%s/back\", nil)\n}\n\nfunc (wd *remoteWD) Refresh() error {\n\treturn wd.voidCommand(\"/session/%s/refresh\", nil)\n}\n\nfunc (wd *remoteWD) Title() (string, error) {\n\treturn wd.stringCommand(\"/session/%s/title\")\n}\n\nfunc (wd *remoteWD) PageSource() (string, error) {\n\treturn wd.stringCommand(\"/session/%s/source\")\n}\n\nfunc (wd *remoteWD) find(by, value, suffix, url string) ([]byte, error) {\n\t// The W3C specification removed the specific ID and Name locator strategies,\n\t// instead only providing a CSS-based strategy. Emulate the old behavior to\n\t// maintain API compatibility.\n\tif wd.w3cCompatible {\n\t\tswitch by {\n\t\tcase ByID:\n\t\t\tby = ByCSSSelector\n\t\t\tvalue = \"#\" + value\n\t\tcase ByName:\n\t\t\tby = ByCSSSelector\n\t\t\tvalue = fmt.Sprintf(\"input[name=%q]\", value)\n\t\t}\n\t}\n\n\tparams := map[string]string{\n\t\t\"using\": by,\n\t\t\"value\": value,\n\t}\n\tdata, err := json.Marshal(params)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif len(url) == 0 {\n\t\turl = \"/session/%s/element\"\n\t}\n\n\treturn wd.execute(\"POST\", wd.requestURL(url+suffix, wd.id), data)\n}\n\nfunc (wd *remoteWD) DecodeElement(data []byte) (WebElement, error) {\n\treply := new(struct{ Value map[string]string })\n\tif err := json.Unmarshal(data, &reply); err != nil {\n\t\treturn nil, err\n\t}\n\n\tid := elementIDFromValue(reply.Value)\n\tif id == \"\" {\n\t\treturn nil, fmt.Errorf(\"invalid element returned: %+v\", reply)\n\t}\n\treturn &remoteWE{\n\t\tparent: wd,\n\t\tid:     id,\n\t}, nil\n}\n\nconst (\n\t// legacyWebElementIdentifier is the string constant used in the old\n\t// WebDriver JSON protocol that is the key for the map that contains an\n\t// unique element identifier.\n\tlegacyWebElementIdentifier = \"ELEMENT\"\n\n\t// webElementIdentifier is the string constant defined by the W3C\n\t// specification that is the key for the map that contains a unique element identifier.\n\twebElementIdentifier = \"element-6066-11e4-a52e-4f735466cecf\"\n)\n\nfunc elementIDFromValue(v map[string]string) string {\n\tfor _, key := range []string{webElementIdentifier, legacyWebElementIdentifier} {\n\t\tv, ok := v[key]\n\t\tif !ok || v == \"\" {\n\t\t\tcontinue\n\t\t}\n\t\treturn v\n\t}\n\treturn \"\"\n}\n\nfunc (wd *remoteWD) DecodeElements(data []byte) ([]WebElement, error) {\n\treply := new(struct{ Value []map[string]string })\n\tif err := json.Unmarshal(data, reply); err != nil {\n\t\treturn nil, err\n\t}\n\n\telems := make([]WebElement, len(reply.Value))\n\tfor i, elem := range reply.Value {\n\t\tid := elementIDFromValue(elem)\n\t\tif id == \"\" {\n\t\t\treturn nil, fmt.Errorf(\"invalid element returned: %+v\", reply)\n\t\t}\n\t\telems[i] = &remoteWE{\n\t\t\tparent: wd,\n\t\t\tid:     id,\n\t\t}\n\t}\n\n\treturn elems, nil\n}\n\nfunc (wd *remoteWD) FindElement(by, value string) (WebElement, error) {\n\tresponse, err := wd.find(by, value, \"\", \"\")\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn wd.DecodeElement(response)\n}\n\nfunc (wd *remoteWD) FindElements(by, value string) ([]WebElement, error) {\n\tresponse, err := wd.find(by, value, \"s\", \"\")\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn wd.DecodeElements(response)\n}\n\nfunc (wd *remoteWD) Close() error {\n\turl := wd.requestURL(\"/session/%s/window\", wd.id)\n\t_, err := wd.execute(\"DELETE\", url, nil)\n\treturn err\n}\n\nfunc (wd *remoteWD) SwitchWindow(name string) error {\n\tparams := make(map[string]string)\n\tif !wd.w3cCompatible {\n\t\tparams[\"name\"] = name\n\t} else {\n\t\tparams[\"handle\"] = name\n\t}\n\treturn wd.voidCommand(\"/session/%s/window\", params)\n}\n\nfunc (wd *remoteWD) CloseWindow(name string) error {\n\treturn wd.modifyWindow(name, \"DELETE\", \"\", nil)\n}\n\nfunc (wd *remoteWD) MaximizeWindow(name string) error {\n\tif !wd.w3cCompatible {\n\t\tif name != \"\" {\n\t\t\tvar err error\n\t\t\tname, err = wd.CurrentWindowHandle()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t\turl := wd.requestURL(\"/session/%s/window/%s/maximize\", wd.id, name)\n\t\t_, err := wd.execute(\"POST\", url, nil)\n\t\treturn err\n\t}\n\treturn wd.modifyWindow(name, \"POST\", \"maximize\", map[string]string{})\n}\n\nfunc (wd *remoteWD) MinimizeWindow(name string) error {\n\treturn wd.modifyWindow(name, \"POST\", \"minimize\", map[string]string{})\n}\n\nfunc (wd *remoteWD) modifyWindow(name, verb, command string, params interface{}) error {\n\t// The original protocol allowed for maximizing any named window. The W3C\n\t// specification only allows the current window be be modified. Emulate the\n\t// previous behavior by switching to the target window, maximizing the\n\t// current window, and switching back to the original window.\n\tvar startWindow string\n\tif name != \"\" && wd.w3cCompatible {\n\t\tvar err error\n\t\tstartWindow, err = wd.CurrentWindowHandle()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif name != startWindow {\n\t\t\tif err := wd.SwitchWindow(name); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t}\n\n\turl := wd.requestURL(\"/session/%s/window\", wd.id)\n\tif command != \"\" {\n\t\tif wd.w3cCompatible {\n\t\t\turl = wd.requestURL(\"/session/%s/window/%s\", wd.id, command)\n\t\t} else {\n\t\t\turl = wd.requestURL(\"/session/%s/window/%s/%s\", wd.id, name, command)\n\t\t}\n\t}\n\n\tvar data []byte\n\tif params != nil {\n\t\tvar err error\n\t\tif data, err = json.Marshal(params); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\tif _, err := wd.execute(verb, url, data); err != nil {\n\t\treturn err\n\t}\n\n\t// TODO(minusnine): add a test for switching back to the original window.\n\tif name != startWindow && wd.w3cCompatible {\n\t\tif err := wd.SwitchWindow(startWindow); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\treturn nil\n}\n\nfunc (wd *remoteWD) ResizeWindow(name string, width, height int) error {\n\tif !wd.w3cCompatible {\n\t\treturn wd.modifyWindow(name, \"POST\", \"size\", map[string]int{\n\t\t\t\"width\":  width,\n\t\t\t\"height\": height,\n\t\t})\n\t}\n\treturn wd.modifyWindow(name, \"POST\", \"rect\", map[string]float64{\n\t\t\"width\":  float64(width),\n\t\t\"height\": float64(height),\n\t})\n}\n\nfunc (wd *remoteWD) SwitchFrame(frame interface{}) error {\n\tparams := map[string]interface{}{}\n\tswitch f := frame.(type) {\n\tcase WebElement, int, nil:\n\t\tparams[\"id\"] = f\n\tcase string:\n\t\tif f == \"\" {\n\t\t\tparams[\"id\"] = nil\n\t\t} else if wd.w3cCompatible {\n\t\t\te, err := wd.FindElement(ByID, f)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tparams[\"id\"] = e\n\t\t} else { // Legacy, non W3C-spec behavior.\n\t\t\tparams[\"id\"] = f\n\t\t}\n\tdefault:\n\t\treturn fmt.Errorf(\"invalid type %T\", frame)\n\t}\n\treturn wd.voidCommand(\"/session/%s/frame\", params)\n}\n\nfunc (wd *remoteWD) ActiveElement() (WebElement, error) {\n\tverb := \"GET\"\n\tif wd.browser == \"firefox\" && wd.browserVersion.Major < 47 {\n\t\tverb = \"POST\"\n\t}\n\turl := wd.requestURL(\"/session/%s/element/active\", wd.id)\n\tresponse, err := wd.execute(verb, url, nil)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn wd.DecodeElement(response)\n}\n\n// ChromeDriver returns the expiration date as a float. Handle both formats\n// via a type switch.\ntype cookie struct {\n\tName     string      `json:\"name\"`\n\tValue    string      `json:\"value\"`\n\tPath     string      `json:\"path\"`\n\tDomain   string      `json:\"domain\"`\n\tSecure   bool        `json:\"secure\"`\n\tExpiry   interface{} `json:\"expiry\"`\n\tHTTPOnly bool        `json:\"httpOnly\"`\n\tSameSite string      `json:\"sameSite\",omitempty`\n}\n\nfunc (c cookie) sanitize() Cookie {\n\tparseExpiry := func(e interface{}) uint {\n\t\tswitch expiry := c.Expiry.(type) {\n\t\tcase int:\n\t\t\tif expiry > 0 {\n\t\t\t\treturn uint(expiry)\n\t\t\t}\n\t\tcase float64:\n\t\t\treturn uint(expiry)\n\t\t}\n\t\treturn 0\n\t}\n\n\tparseSameSite := func(s string) SameSite {\n\t\tif s == \"\" {\n\t\t\treturn \"\"\n\t\t}\n\t\tfor _, v := range []SameSite{SameSiteNone, SameSiteLax, SameSiteStrict} {\n\t\t\tif strings.EqualFold(string(v), s) {\n\t\t\t\treturn v\n\t\t\t}\n\t\t}\n\t\treturn SameSiteLax\n\t}\n\n\treturn Cookie{\n\t\tName:     c.Name,\n\t\tValue:    c.Value,\n\t\tPath:     c.Path,\n\t\tDomain:   c.Domain,\n\t\tSecure:   c.Secure,\n\t\tExpiry:   parseExpiry(c.Expiry),\n\t\tHTTPOnly: c.HTTPOnly,\n\t\tSameSite: parseSameSite(c.SameSite),\n\t}\n}\n\nfunc (wd *remoteWD) GetCookie(name string) (Cookie, error) {\n\tif wd.browser == \"chrome\" {\n\t\tcs, err := wd.GetCookies()\n\t\tif err != nil {\n\t\t\treturn Cookie{}, err\n\t\t}\n\t\tfor _, c := range cs {\n\t\t\tif c.Name == name {\n\t\t\t\treturn c, nil\n\t\t\t}\n\t\t}\n\t\treturn Cookie{}, errors.New(\"cookie not found\")\n\t}\n\turl := wd.requestURL(\"/session/%s/cookie/%s\", wd.id, name)\n\tdata, err := wd.execute(\"GET\", url, nil)\n\tif err != nil {\n\t\treturn Cookie{}, err\n\t}\n\n\t// GeckoDriver returns a list of cookies for this method. Try both a single\n\t// cookie and a list.\n\t//\n\t// https://github.com/mozilla/geckodriver/issues/761\n\treply := new(struct{ Value cookie })\n\tif err := json.Unmarshal(data, reply); err == nil {\n\t\treturn reply.Value.sanitize(), nil\n\t}\n\tlistReply := new(struct{ Value []cookie })\n\tif err := json.Unmarshal(data, listReply); err != nil {\n\t\treturn Cookie{}, err\n\t}\n\tif len(listReply.Value) == 0 {\n\t\treturn Cookie{}, errors.New(\"no cookies returned\")\n\t}\n\treturn listReply.Value[0].sanitize(), nil\n}\n\nfunc (wd *remoteWD) GetCookies() ([]Cookie, error) {\n\turl := wd.requestURL(\"/session/%s/cookie\", wd.id)\n\tdata, err := wd.execute(\"GET\", url, nil)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treply := new(struct{ Value []cookie })\n\tif err := json.Unmarshal(data, reply); err != nil {\n\t\treturn nil, err\n\t}\n\n\tcookies := make([]Cookie, len(reply.Value))\n\tfor i, c := range reply.Value {\n\t\tcookies[i] = c.sanitize()\n\t}\n\treturn cookies, nil\n}\n\nfunc (wd *remoteWD) AddCookie(cookie *Cookie) error {\n\treturn wd.voidCommand(\"/session/%s/cookie\", map[string]*Cookie{\n\t\t\"cookie\": cookie,\n\t})\n}\n\nfunc (wd *remoteWD) DeleteAllCookies() error {\n\turl := wd.requestURL(\"/session/%s/cookie\", wd.id)\n\t_, err := wd.execute(\"DELETE\", url, nil)\n\treturn err\n}\n\nfunc (wd *remoteWD) DeleteCookie(name string) error {\n\turl := wd.requestURL(\"/session/%s/cookie/%s\", wd.id, name)\n\t_, err := wd.execute(\"DELETE\", url, nil)\n\treturn err\n}\n\n// TODO(minusnine): add a test for Click.\nfunc (wd *remoteWD) Click(button int) error {\n\treturn wd.voidCommand(\"/session/%s/click\", map[string]int{\n\t\t\"button\": button,\n\t})\n}\n\n// TODO(minusnine): add a test for DoubleClick.\nfunc (wd *remoteWD) DoubleClick() error {\n\treturn wd.voidCommand(\"/session/%s/doubleclick\", nil)\n}\n\n// TODO(minusnine): add a test for ButtonDown.\nfunc (wd *remoteWD) ButtonDown() error {\n\treturn wd.voidCommand(\"/session/%s/buttondown\", nil)\n}\n\n// TODO(minusnine): add a test for ButtonUp.\nfunc (wd *remoteWD) ButtonUp() error {\n\treturn wd.voidCommand(\"/session/%s/buttonup\", nil)\n}\n\nfunc (wd *remoteWD) SendModifier(modifier string, isDown bool) error {\n\tif isDown {\n\t\treturn wd.KeyDown(modifier)\n\t}\n\treturn wd.KeyUp(modifier)\n}\n\nfunc (wd *remoteWD) keyAction(action, keys string) error {\n\ttype keyAction struct {\n\t\tType string `json:\"type\"`\n\t\tKey  string `json:\"value\"`\n\t}\n\tactions := make([]keyAction, 0, len(keys))\n\tfor _, key := range keys {\n\t\tactions = append(actions, keyAction{\n\t\t\tType: action,\n\t\t\tKey:  string(key),\n\t\t})\n\t}\n\treturn wd.voidCommand(\"/session/%s/actions\", map[string]interface{}{\n\t\t\"actions\": []interface{}{\n\t\t\tmap[string]interface{}{\n\t\t\t\t\"type\":    \"key\",\n\t\t\t\t\"id\":      \"default keyboard\",\n\t\t\t\t\"actions\": actions,\n\t\t\t}},\n\t})\n}\n\nfunc (wd *remoteWD) KeyDown(keys string) error {\n\t// Selenium implemented the actions API but has not yet updated its new\n\t// session response.\n\tif !wd.w3cCompatible && !(wd.browser == \"firefox\" && wd.browserVersion.Major > 47) {\n\t\treturn wd.voidCommand(\"/session/%s/keys\", wd.processKeyString(keys))\n\t}\n\treturn wd.keyAction(\"keyDown\", keys)\n}\n\nfunc (wd *remoteWD) KeyUp(keys string) error {\n\t// Selenium implemented the actions API but has not yet updated its new\n\t// session response.\n\tif !wd.w3cCompatible && !(wd.browser == \"firefox\" && wd.browserVersion.Major > 47) {\n\t\treturn wd.KeyDown(keys)\n\t}\n\treturn wd.keyAction(\"keyUp\", keys)\n}\n\n// KeyPauseAction builds a KeyAction which pauses for the supplied duration.\nfunc KeyPauseAction(duration time.Duration) KeyAction {\n\treturn KeyAction{\n\t\t\"type\":     \"pause\",\n\t\t\"duration\": uint(duration / time.Millisecond),\n\t}\n}\n\n// KeyUpAction builds a KeyAction press.\nfunc KeyUpAction(key string) KeyAction {\n\treturn KeyAction{\n\t\t\"type\":  \"keyUp\",\n\t\t\"value\": key,\n\t}\n}\n\n// KeyDownAction builds a KeyAction which presses and holds\n// the specified key.\nfunc KeyDownAction(key string) KeyAction {\n\treturn KeyAction{\n\t\t\"type\":  \"keyDown\",\n\t\t\"value\": key,\n\t}\n}\n\n// PointerPause builds a PointerAction which pauses for the supplied duration.\nfunc PointerPauseAction(duration time.Duration) PointerAction {\n\treturn PointerAction{\n\t\t\"type\":     \"pause\",\n\t\t\"duration\": uint(duration / time.Millisecond),\n\t}\n}\n\n// PointerMove builds a PointerAction which moves the pointer.\nfunc PointerMoveAction(duration time.Duration, offset Point, origin PointerMoveOrigin) PointerAction {\n\treturn PointerAction{\n\t\t\"type\":     \"pointerMove\",\n\t\t\"duration\": uint(duration / time.Millisecond),\n\t\t\"origin\":   origin,\n\t\t\"x\":        offset.X,\n\t\t\"y\":        offset.Y,\n\t}\n}\n\n// PointerUp builds an action which releases the specified pointer key.\nfunc PointerUpAction(button MouseButton) PointerAction {\n\treturn PointerAction{\n\t\t\"type\":   \"pointerUp\",\n\t\t\"button\": button,\n\t}\n}\n\n// PointerDown builds a PointerAction which presses\n// and holds the specified pointer key.\nfunc PointerDownAction(button MouseButton) PointerAction {\n\treturn PointerAction{\n\t\t\"type\":   \"pointerDown\",\n\t\t\"button\": button,\n\t}\n}\n\nfunc (wd *remoteWD) StoreKeyActions(inputID string, actions ...KeyAction) {\n\trawActions := []map[string]interface{}{}\n\tfor _, action := range actions {\n\t\trawActions = append(rawActions, action)\n\t}\n\twd.storedActions = append(wd.storedActions, map[string]interface{}{\n\t\t\"type\":    \"key\",\n\t\t\"id\":      inputID,\n\t\t\"actions\": rawActions,\n\t})\n}\n\nfunc (wd *remoteWD) StorePointerActions(inputID string, pointer PointerType, actions ...PointerAction) {\n\trawActions := []map[string]interface{}{}\n\tfor _, action := range actions {\n\t\trawActions = append(rawActions, action)\n\t}\n\twd.storedActions = append(wd.storedActions, map[string]interface{}{\n\t\t\"type\":       \"pointer\",\n\t\t\"id\":         inputID,\n\t\t\"parameters\": map[string]string{\"pointerType\": string(pointer)},\n\t\t\"actions\":    rawActions,\n\t})\n}\n\nfunc (wd *remoteWD) PerformActions() error {\n\terr := wd.voidCommand(\"/session/%s/actions\", map[string]interface{}{\n\t\t\"actions\": wd.storedActions,\n\t})\n\twd.storedActions = nil\n\treturn err\n}\n\nfunc (wd *remoteWD) ReleaseActions() error {\n\treturn voidCommand(\"DELETE\", wd.requestURL(\"/session/%s/actions\", wd.id), nil)\n}\n\nfunc (wd *remoteWD) DismissAlert() error {\n\treturn wd.voidCommand(\"/session/%s/alert/dismiss\", nil)\n}\n\nfunc (wd *remoteWD) AcceptAlert() error {\n\treturn wd.voidCommand(\"/session/%s/alert/accept\", nil)\n}\n\nfunc (wd *remoteWD) AlertText() (string, error) {\n\treturn wd.stringCommand(\"/session/%s/alert/text\")\n}\n\nfunc (wd *remoteWD) SetAlertText(text string) error {\n\tdata := map[string]string{\"text\": text}\n\treturn wd.voidCommand(\"/session/%s/alert/text\", data)\n}\n\nfunc (wd *remoteWD) execScriptRaw(script string, args []interface{}, suffix string) ([]byte, error) {\n\tif args == nil {\n\t\targs = make([]interface{}, 0)\n\t}\n\n\tdata, err := json.Marshal(map[string]interface{}{\n\t\t\"script\": script,\n\t\t\"args\":   args,\n\t})\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn wd.execute(\"POST\", wd.requestURL(\"/session/%s/execute\"+suffix, wd.id), data)\n}\n\nfunc (wd *remoteWD) execScript(script string, args []interface{}, suffix string) (interface{}, error) {\n\tresponse, err := wd.execScriptRaw(script, args, suffix)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treply := new(struct{ Value interface{} })\n\tif err = json.Unmarshal(response, reply); err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn reply.Value, nil\n}\n\nfunc (wd *remoteWD) ExecuteScript(script string, args []interface{}) (interface{}, error) {\n\tif !wd.w3cCompatible {\n\t\treturn wd.execScript(script, args, \"\")\n\t}\n\treturn wd.execScript(script, args, \"/sync\")\n}\n\nfunc (wd *remoteWD) ExecuteScriptAsync(script string, args []interface{}) (interface{}, error) {\n\tif !wd.w3cCompatible {\n\t\treturn wd.execScript(script, args, \"_async\")\n\t}\n\treturn wd.execScript(script, args, \"/async\")\n}\n\nfunc (wd *remoteWD) ExecuteScriptRaw(script string, args []interface{}) ([]byte, error) {\n\tif !wd.w3cCompatible {\n\t\treturn wd.execScriptRaw(script, args, \"\")\n\t}\n\treturn wd.execScriptRaw(script, args, \"/sync\")\n}\n\nfunc (wd *remoteWD) ExecuteScriptAsyncRaw(script string, args []interface{}) ([]byte, error) {\n\tif !wd.w3cCompatible {\n\t\treturn wd.execScriptRaw(script, args, \"_async\")\n\t}\n\treturn wd.execScriptRaw(script, args, \"/async\")\n}\n\nfunc (wd *remoteWD) Screenshot() ([]byte, error) {\n\tdata, err := wd.stringCommand(\"/session/%s/screenshot\")\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Selenium returns a base64 encoded image.\n\tbuf := []byte(data)\n\tdecoder := base64.NewDecoder(base64.StdEncoding, bytes.NewBuffer(buf))\n\treturn ioutil.ReadAll(decoder)\n}\n\n// Condition is an alias for a type that is passed as an argument\n// for selenium.Wait(cond Condition) (error) function.\ntype Condition func(wd WebDriver) (bool, error)\n\nconst (\n\t// DefaultWaitInterval is the default polling interval for selenium.Wait\n\t// function.\n\tDefaultWaitInterval = 100 * time.Millisecond\n\n\t// DefaultWaitTimeout is the default timeout for selenium.Wait function.\n\tDefaultWaitTimeout = 60 * time.Second\n)\n\nfunc (wd *remoteWD) WaitWithTimeoutAndInterval(condition Condition, timeout, interval time.Duration) error {\n\tstartTime := time.Now()\n\n\tfor {\n\t\tdone, err := condition(wd)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif done {\n\t\t\treturn nil\n\t\t}\n\n\t\tif elapsed := time.Since(startTime); elapsed > timeout {\n\t\t\treturn fmt.Errorf(\"timeout after %v\", elapsed)\n\t\t}\n\t\ttime.Sleep(interval)\n\t}\n}\n\nfunc (wd *remoteWD) WaitWithTimeout(condition Condition, timeout time.Duration) error {\n\treturn wd.WaitWithTimeoutAndInterval(condition, timeout, DefaultWaitInterval)\n}\n\nfunc (wd *remoteWD) Wait(condition Condition) error {\n\treturn wd.WaitWithTimeoutAndInterval(condition, DefaultWaitTimeout, DefaultWaitInterval)\n}\n\nfunc (wd *remoteWD) Log(typ log.Type) ([]log.Message, error) {\n\turl := wd.requestURL(\"/session/%s/log\", wd.id)\n\tparams := map[string]log.Type{\n\t\t\"type\": typ,\n\t}\n\tdata, err := json.Marshal(params)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tresponse, err := wd.execute(\"POST\", url, data)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tc := new(struct {\n\t\tValue []struct {\n\t\t\tTimestamp int64\n\t\t\tLevel     string\n\t\t\tMessage   string\n\t\t}\n\t})\n\tif err = json.Unmarshal(response, c); err != nil {\n\t\treturn nil, err\n\t}\n\n\tval := make([]log.Message, len(c.Value))\n\tfor i, v := range c.Value {\n\t\tval[i] = log.Message{\n\t\t\t// n.b.: Chrome, which is the only browser that supports this API,\n\t\t\t// supplies timestamps in milliseconds since the Epoch.\n\t\t\tTimestamp: time.Unix(0, v.Timestamp*int64(time.Millisecond)),\n\t\t\tLevel:     log.Level(v.Level),\n\t\t\tMessage:   v.Message,\n\t\t}\n\t}\n\n\treturn val, nil\n}\n\ntype remoteWE struct {\n\tparent *remoteWD\n\t// Prior to the W3C specification, elements would be returned as a map with\n\t// the literal key \"ELEMENT\" and a value of a UUID. The W3C specification\n\t// specifies that this key has changed to an UUID-based string constant and\n\t// that the value is called a \"reference\". For ease of transition, we store\n\t// the \"reference\" in this now misnamed field.\n\tid string\n}\n\nfunc (elem *remoteWE) Click() error {\n\turlTemplate := fmt.Sprintf(\"/session/%%s/element/%s/click\", elem.id)\n\treturn elem.parent.voidCommand(urlTemplate, nil)\n}\n\nfunc (elem *remoteWE) SendKeys(keys string) error {\n\turlTemplate := fmt.Sprintf(\"/session/%%s/element/%s/value\", elem.id)\n\treturn elem.parent.voidCommand(urlTemplate, elem.parent.processKeyString(keys))\n}\n\nfunc (wd *remoteWD) processKeyString(keys string) interface{} {\n\tif !wd.w3cCompatible {\n\t\tchars := make([]string, len(keys))\n\t\tfor i, c := range keys {\n\t\t\tchars[i] = string(c)\n\t\t}\n\t\treturn map[string][]string{\"value\": chars}\n\t}\n\treturn map[string]string{\"text\": keys}\n}\n\nfunc (elem *remoteWE) TagName() (string, error) {\n\turlTemplate := fmt.Sprintf(\"/session/%%s/element/%s/name\", elem.id)\n\treturn elem.parent.stringCommand(urlTemplate)\n}\n\nfunc (elem *remoteWE) Text() (string, error) {\n\turlTemplate := fmt.Sprintf(\"/session/%%s/element/%s/text\", elem.id)\n\treturn elem.parent.stringCommand(urlTemplate)\n}\n\nfunc (elem *remoteWE) Submit() error {\n\turlTemplate := fmt.Sprintf(\"/session/%%s/element/%s/submit\", elem.id)\n\treturn elem.parent.voidCommand(urlTemplate, nil)\n}\n\nfunc (elem *remoteWE) Clear() error {\n\turlTemplate := fmt.Sprintf(\"/session/%%s/element/%s/clear\", elem.id)\n\treturn elem.parent.voidCommand(urlTemplate, nil)\n}\n\nfunc (elem *remoteWE) MoveTo(xOffset, yOffset int) error {\n\treturn elem.parent.voidCommand(\"/session/%s/moveto\", map[string]interface{}{\n\t\t\"element\": elem.id,\n\t\t\"xoffset\": xOffset,\n\t\t\"yoffset\": yOffset,\n\t})\n}\n\nfunc (elem *remoteWE) FindElement(by, value string) (WebElement, error) {\n\turl := fmt.Sprintf(\"/session/%%s/element/%s/element\", elem.id)\n\tresponse, err := elem.parent.find(by, value, \"\", url)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn elem.parent.DecodeElement(response)\n}\n\nfunc (elem *remoteWE) FindElements(by, value string) ([]WebElement, error) {\n\turl := fmt.Sprintf(\"/session/%%s/element/%s/element\", elem.id)\n\tresponse, err := elem.parent.find(by, value, \"s\", url)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn elem.parent.DecodeElements(response)\n}\n\nfunc (elem *remoteWE) boolQuery(urlTemplate string) (bool, error) {\n\treturn elem.parent.boolCommand(fmt.Sprintf(urlTemplate, elem.id))\n}\n\nfunc (elem *remoteWE) IsSelected() (bool, error) {\n\treturn elem.boolQuery(\"/session/%%s/element/%s/selected\")\n}\n\nfunc (elem *remoteWE) IsEnabled() (bool, error) {\n\treturn elem.boolQuery(\"/session/%%s/element/%s/enabled\")\n}\n\nfunc (elem *remoteWE) IsDisplayed() (bool, error) {\n\treturn elem.boolQuery(\"/session/%%s/element/%s/displayed\")\n}\n\nfunc (elem *remoteWE) GetProperty(name string) (string, error) {\n\ttemplate := \"/session/%%s/element/%s/property/%s\"\n\turlTemplate := fmt.Sprintf(template, elem.id, name)\n\n\treturn elem.parent.stringCommand(urlTemplate)\n}\n\nfunc (elem *remoteWE) GetAttribute(name string) (string, error) {\n\ttemplate := \"/session/%%s/element/%s/attribute/%s\"\n\turlTemplate := fmt.Sprintf(template, elem.id, name)\n\n\treturn elem.parent.stringCommand(urlTemplate)\n}\n\nfunc round(f float64) int {\n\tif f < -0.5 {\n\t\treturn int(f - 0.5)\n\t}\n\tif f > 0.5 {\n\t\treturn int(f + 0.5)\n\t}\n\treturn 0\n}\n\nfunc (elem *remoteWE) location(suffix string) (*Point, error) {\n\tif !elem.parent.w3cCompatible {\n\t\twd := elem.parent\n\t\tpath := \"/session/%s/element/%s/location\" + suffix\n\t\turl := wd.requestURL(path, wd.id, elem.id)\n\t\tresponse, err := wd.execute(\"GET\", url, nil)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\treply := new(struct{ Value rect })\n\t\tif err := json.Unmarshal(response, reply); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\treturn &Point{round(reply.Value.X), round(reply.Value.Y)}, nil\n\t}\n\n\trect, err := elem.rect()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn &Point{round(rect.X), round(rect.Y)}, nil\n}\n\nfunc (elem *remoteWE) Location() (*Point, error) {\n\treturn elem.location(\"\")\n}\n\nfunc (elem *remoteWE) LocationInView() (*Point, error) {\n\treturn elem.location(\"_in_view\")\n}\n\nfunc (elem *remoteWE) Size() (*Size, error) {\n\tif !elem.parent.w3cCompatible {\n\t\twd := elem.parent\n\t\turl := wd.requestURL(\"/session/%s/element/%s/size\", wd.id, elem.id)\n\t\tresponse, err := wd.execute(\"GET\", url, nil)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\treply := new(struct{ Value rect })\n\t\tif err := json.Unmarshal(response, reply); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\treturn &Size{round(reply.Value.Width), round(reply.Value.Height)}, nil\n\t}\n\n\trect, err := elem.rect()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn &Size{round(rect.Width), round(rect.Height)}, nil\n}\n\ntype rect struct {\n\tX      float64 `json:\"x\"`\n\tY      float64 `json:\"y\"`\n\tWidth  float64 `json:\"width\"`\n\tHeight float64 `json:\"height\"`\n}\n\n// rect implements the \"Get Element Rect\" method of the W3C standard.\nfunc (elem *remoteWE) rect() (*rect, error) {\n\twd := elem.parent\n\turl := wd.requestURL(\"/session/%s/element/%s/rect\", wd.id, elem.id)\n\tresponse, err := wd.execute(\"GET\", url, nil)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tr := new(struct{ Value rect })\n\tif err := json.Unmarshal(response, r); err != nil {\n\t\treturn nil, err\n\t}\n\treturn &r.Value, nil\n}\n\nfunc (elem *remoteWE) CSSProperty(name string) (string, error) {\n\twd := elem.parent\n\treturn wd.stringCommand(fmt.Sprintf(\"/session/%%s/element/%s/css/%s\", elem.id, name))\n}\n\nfunc (elem *remoteWE) MarshalJSON() ([]byte, error) {\n\treturn json.Marshal(map[string]string{\n\t\t\"ELEMENT\":            elem.id,\n\t\twebElementIdentifier: elem.id,\n\t})\n}\n\nfunc (elem *remoteWE) Screenshot(scroll bool) ([]byte, error) {\n\tdata, err := elem.parent.stringCommand(fmt.Sprintf(\"/session/%%s/element/%s/screenshot\", elem.id))\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Selenium returns a base64 encoded image.\n\tbuf := []byte(data)\n\tdecoder := base64.NewDecoder(base64.StdEncoding, bytes.NewBuffer(buf))\n\treturn ioutil.ReadAll(decoder)\n}\n"
        },
        {
          "name": "sauce",
          "type": "tree",
          "content": null
        },
        {
          "name": "sauce_test.go",
          "type": "blob",
          "size": 2.400390625,
          "content": "package selenium_test\n\nimport (\n\t\"flag\"\n\t\"fmt\"\n\t\"strings\"\n\t\"testing\"\n\n\t\"github.com/blang/semver\"\n\t\"github.com/tebeka/selenium\"\n\t\"github.com/tebeka/selenium/internal/seleniumtest\"\n\t\"github.com/tebeka/selenium/sauce\"\n)\n\nvar (\n\tenableSauce      = flag.Bool(\"experimental_enable_sauce\", false, \"If true, perform integration tests on SauceLabs remote infrastructure.\")\n\tsauceUserName    = flag.String(\"sauce_user_name\", \"\", \"The username to use for SauceLabs.\")\n\tsauceAccessKey   = flag.String(\"sauce_access_key\", \"\", \"The access key to use for SauceLabs.\")\n\tsauceConnectPath = flag.String(\"sauce_connect_path\", \"vendor/sauce-connect/bin/sc\", \"The path to the Sauce Connect binary.\")\n)\n\nfunc TestSauce(t *testing.T) {\n\tif !*enableSauce {\n\t\tt.Skip(\"Skipping Sauce tests. Enable via --experimental_sauce_tests\")\n\t}\n\tif testing.Verbose() {\n\t\tselenium.SetDebug(true)\n\t}\n\tif *sauceUserName == \"\" {\n\t\tt.Fatalf(\"--sauce_user_name is required.\")\n\t}\n\tif *sauceAccessKey == \"\" {\n\t\tt.Fatalf(\"--sauce_access_key is required.\")\n\t}\n\n\taddr := sauce.Addr(*sauceUserName, *sauceAccessKey)\n\tif *sauceConnectPath != \"\" {\n\t\tport, err := pickUnusedPort()\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"pickUnusedPort() returned error: %s\", err)\n\t\t}\n\t\tsc := sauce.Connect{\n\t\t\tPath:                *sauceConnectPath,\n\t\t\tUserName:            *sauceUserName,\n\t\t\tAccessKey:           *sauceAccessKey,\n\t\t\tSeleniumPort:        port,\n\t\t\tQuitProcessUponExit: true,\n\t\t}\n\t\tif testing.Verbose() {\n\t\t\tsc.ExtraVerbose = true\n\t\t}\n\t\tif err := sc.Start(); err != nil {\n\t\t\tt.Fatalf(\"sc.Start() returned error: %s\", err)\n\t\t}\n\t\tdefer func() {\n\t\t\tif err := sc.Stop(); err != nil {\n\t\t\t\tt.Fatalf(\"sc.Stop() returned error: %s\", err)\n\t\t\t}\n\t\t}()\n\t\taddr = sc.Addr()\n\t}\n\n\tconst browser = \"Firefox\"\n\tfor _, tc := range []struct {\n\t\tversion, platform, selenium string\n\t}{\n\t\t{\"Latest\", \"Windows 10\", \"3.4.0\"},\n\t\t{\"45.0\", \"Linux\", \"2.53.1\"},\n\t} {\n\t\tname := fmt.Sprintf(\"%s/%s/%s/%s\", browser, tc.version, tc.platform, tc.selenium)\n\t\tbrowser, version := strings.ToLower(browser), strings.ToLower(tc.version)\n\n\t\tt.Run(name, func(t *testing.T) {\n\t\t\tc := seleniumtest.Config{\n\t\t\t\tBrowser:         browser,\n\t\t\t\tSeleniumVersion: semver.MustParse(tc.selenium),\n\t\t\t\tSauce: &sauce.Capabilities{\n\t\t\t\t\tBrowser:         browser,\n\t\t\t\t\tVersion:         version,\n\t\t\t\t\tPlatform:        tc.platform,\n\t\t\t\t\tSeleniumVersion: tc.selenium,\n\t\t\t\t},\n\t\t\t\tAddr: addr,\n\t\t\t}\n\t\t\tseleniumtest.RunCommonTests(t, c)\n\t\t\tseleniumtest.RunFirefoxTests(t, c)\n\t\t})\n\t}\n}\n"
        },
        {
          "name": "selenium.go",
          "type": "blob",
          "size": 16.6728515625,
          "content": "package selenium\n\nimport (\n\t\"time\"\n\n\t\"github.com/tebeka/selenium/chrome\"\n\t\"github.com/tebeka/selenium/firefox\"\n\t\"github.com/tebeka/selenium/log\"\n)\n\n// TODO(minusnine): make an enum type called FindMethod.\n\n// Methods by which to find elements.\nconst (\n\tByID              = \"id\"\n\tByXPATH           = \"xpath\"\n\tByLinkText        = \"link text\"\n\tByPartialLinkText = \"partial link text\"\n\tByName            = \"name\"\n\tByTagName         = \"tag name\"\n\tByClassName       = \"class name\"\n\tByCSSSelector     = \"css selector\"\n)\n\ntype MouseButton int\n\n// Mouse buttons.\nconst (\n\tLeftButton MouseButton = iota\n\tMiddleButton\n\tRightButton\n)\n\n// Special keyboard keys, for SendKeys.\nconst (\n\tNullKey       = string('\\ue000')\n\tCancelKey     = string('\\ue001')\n\tHelpKey       = string('\\ue002')\n\tBackspaceKey  = string('\\ue003')\n\tTabKey        = string('\\ue004')\n\tClearKey      = string('\\ue005')\n\tReturnKey     = string('\\ue006')\n\tEnterKey      = string('\\ue007')\n\tShiftKey      = string('\\ue008')\n\tControlKey    = string('\\ue009')\n\tAltKey        = string('\\ue00a')\n\tPauseKey      = string('\\ue00b')\n\tEscapeKey     = string('\\ue00c')\n\tSpaceKey      = string('\\ue00d')\n\tPageUpKey     = string('\\ue00e')\n\tPageDownKey   = string('\\ue00f')\n\tEndKey        = string('\\ue010')\n\tHomeKey       = string('\\ue011')\n\tLeftArrowKey  = string('\\ue012')\n\tUpArrowKey    = string('\\ue013')\n\tRightArrowKey = string('\\ue014')\n\tDownArrowKey  = string('\\ue015')\n\tInsertKey     = string('\\ue016')\n\tDeleteKey     = string('\\ue017')\n\tSemicolonKey  = string('\\ue018')\n\tEqualsKey     = string('\\ue019')\n\tNumpad0Key    = string('\\ue01a')\n\tNumpad1Key    = string('\\ue01b')\n\tNumpad2Key    = string('\\ue01c')\n\tNumpad3Key    = string('\\ue01d')\n\tNumpad4Key    = string('\\ue01e')\n\tNumpad5Key    = string('\\ue01f')\n\tNumpad6Key    = string('\\ue020')\n\tNumpad7Key    = string('\\ue021')\n\tNumpad8Key    = string('\\ue022')\n\tNumpad9Key    = string('\\ue023')\n\tMultiplyKey   = string('\\ue024')\n\tAddKey        = string('\\ue025')\n\tSeparatorKey  = string('\\ue026')\n\tSubstractKey  = string('\\ue027')\n\tDecimalKey    = string('\\ue028')\n\tDivideKey     = string('\\ue029')\n\tF1Key         = string('\\ue031')\n\tF2Key         = string('\\ue032')\n\tF3Key         = string('\\ue033')\n\tF4Key         = string('\\ue034')\n\tF5Key         = string('\\ue035')\n\tF6Key         = string('\\ue036')\n\tF7Key         = string('\\ue037')\n\tF8Key         = string('\\ue038')\n\tF9Key         = string('\\ue039')\n\tF10Key        = string('\\ue03a')\n\tF11Key        = string('\\ue03b')\n\tF12Key        = string('\\ue03c')\n\tMetaKey       = string('\\ue03d')\n)\n\n// Capabilities configures both the WebDriver process and the target browsers,\n// with standard and browser-specific options.\ntype Capabilities map[string]interface{}\n\n// AddChrome adds Chrome-specific capabilities.\nfunc (c Capabilities) AddChrome(f chrome.Capabilities) {\n\tc[chrome.CapabilitiesKey] = f\n\tc[chrome.DeprecatedCapabilitiesKey] = f\n}\n\n// AddFirefox adds Firefox-specific capabilities.\nfunc (c Capabilities) AddFirefox(f firefox.Capabilities) {\n\tc[firefox.CapabilitiesKey] = f\n}\n\n// AddProxy adds proxy configuration to the capabilities.\nfunc (c Capabilities) AddProxy(p Proxy) {\n\tc[\"proxy\"] = p\n}\n\n// AddLogging adds logging configuration to the capabilities.\nfunc (c Capabilities) AddLogging(l log.Capabilities) {\n\tc[log.CapabilitiesKey] = l\n}\n\n// SetLogLevel sets the logging level of a component. It is a shortcut for\n// passing a log.Capabilities instance to AddLogging.\nfunc (c Capabilities) SetLogLevel(typ log.Type, level log.Level) {\n\tif _, ok := c[log.CapabilitiesKey]; !ok {\n\t\tc[log.CapabilitiesKey] = make(log.Capabilities)\n\t}\n\tm := c[log.CapabilitiesKey].(log.Capabilities)\n\tm[typ] = level\n}\n\n// Proxy specifies configuration for proxies in the browser. Set the key\n// \"proxy\" in Capabilities to an instance of this type.\ntype Proxy struct {\n\t// Type is the type of proxy to use. This is required to be populated.\n\tType ProxyType `json:\"proxyType\"`\n\n\t// AutoconfigURL is the URL to be used for proxy auto configuration. This is\n\t// required if Type is set to PAC.\n\tAutoconfigURL string `json:\"proxyAutoconfigUrl,omitempty\"`\n\n\t// The following are used when Type is set to Manual.\n\t//\n\t// Note that in Firefox, connections to localhost are not proxied by default,\n\t// even if a proxy is set. This can be overridden via a preference setting.\n\tFTP           string   `json:\"ftpProxy,omitempty\"`\n\tHTTP          string   `json:\"httpProxy,omitempty\"`\n\tSSL           string   `json:\"sslProxy,omitempty\"`\n\tSOCKS         string   `json:\"socksProxy,omitempty\"`\n\tSOCKSVersion  int      `json:\"socksVersion,omitempty\"`\n\tSOCKSUsername string   `json:\"socksUsername,omitempty\"`\n\tSOCKSPassword string   `json:\"socksPassword,omitempty\"`\n\tNoProxy       []string `json:\"noProxy,omitempty\"`\n\n\t// The W3C draft spec includes port fields as well. According to the\n\t// specification, ports can also be included in the above addresses. However,\n\t// in the Geckodriver implementation, the ports must be specified by these\n\t// additional fields.\n\tHTTPPort  int `json:\"httpProxyPort,omitempty\"`\n\tSSLPort   int `json:\"sslProxyPort,omitempty\"`\n\tSocksPort int `json:\"socksProxyPort,omitempty\"`\n}\n\n// ProxyType is an enumeration of the types of proxies available.\ntype ProxyType string\n\nconst (\n\t// Direct connection - no proxy in use.\n\tDirect ProxyType = \"direct\"\n\t// Manual proxy settings configured, e.g. setting a proxy for HTTP, a proxy\n\t// for FTP, etc.\n\tManual = \"manual\"\n\t// Autodetect proxy, probably with WPAD\n\tAutodetect = \"autodetect\"\n\t// System settings used.\n\tSystem = \"system\"\n\t// PAC - Proxy autoconfiguration from a URL.\n\tPAC = \"pac\"\n)\n\n// Status contains information returned by the Status method.\ntype Status struct {\n\t// The following fields are used by Selenium and ChromeDriver.\n\tJava struct {\n\t\tVersion string\n\t}\n\tBuild struct {\n\t\tVersion, Revision, Time string\n\t}\n\tOS struct {\n\t\tArch, Name, Version string\n\t}\n\n\t// The following fields are specified by the W3C WebDriver specification and\n\t// are used by GeckoDriver.\n\tReady   bool\n\tMessage string\n}\n\n// Point is a 2D point.\ntype Point struct {\n\tX, Y int\n}\n\n// Size is a size of HTML element.\ntype Size struct {\n\tWidth, Height int\n}\n\n// Cookie represents an HTTP cookie.\ntype Cookie struct {\n\tName     string   `json:\"name\"`\n\tValue    string   `json:\"value\"`\n\tPath     string   `json:\"path\"`\n\tDomain   string   `json:\"domain\"`\n\tSecure   bool     `json:\"secure\"`\n\tExpiry   uint     `json:\"expiry\"`\n\tHTTPOnly bool     `json:\"httpOnly\"`\n\tSameSite SameSite `json:\"sameSite,omitempty\"`\n}\n\n// SameSite is the type for the SameSite field in Cookie.\ntype SameSite string\n\nconst (\n\tSameSiteNone   SameSite = \"None\"\n\tSameSiteLax    SameSite = \"Lax\"\n\tSameSiteStrict SameSite = \"Strict\"\n\tSameSiteEmpty  SameSite = \"\"\n)\n\n// PointerType is the type of pointer used by StorePointerActions.\n// There are 3 different types according to the WC3 implementation.\ntype PointerType string\n\nconst (\n\tMousePointer PointerType = \"mouse\"\n\tPenPointer               = \"pen\"\n\tTouchPointer             = \"touch\"\n)\n\n// PointerMoveOrigin controls how the offset for\n// the pointer move action is calculated.\ntype PointerMoveOrigin string\n\nconst (\n\t// FromViewport calculates the offset from the viewport at 0,0.\n\tFromViewport PointerMoveOrigin = \"viewport\"\n\t// FromPointer calculates the offset from the current pointer position.\n\tFromPointer = \"pointer\"\n)\n\n// KeyAction represents an activity involving a keyboard key.\ntype KeyAction map[string]interface{}\n\n// PointerAction represents an activity involving a pointer.\ntype PointerAction map[string]interface{}\n\n// Actions stores KeyActions and PointerActions for later execution.\ntype Actions []map[string]interface{}\n\n// WebDriver defines methods supported by WebDriver drivers.\ntype WebDriver interface {\n\t// Status returns various pieces of information about the server environment.\n\tStatus() (*Status, error)\n\n\t// NewSession starts a new session and returns the session ID.\n\tNewSession() (string, error)\n\n\t// SessionId returns the current session ID\n\t//\n\t// Deprecated: This identifier is not Go-style correct. Use SessionID\n\t// instead.\n\tSessionId() string\n\n\t// SessionID returns the current session ID.\n\tSessionID() string\n\n\t// SwitchSession switches to the given session ID.\n\tSwitchSession(sessionID string) error\n\n\t// Capabilities returns the current session's capabilities.\n\tCapabilities() (Capabilities, error)\n\n\t// SetAsyncScriptTimeout sets the amount of time that asynchronous scripts\n\t// are permitted to run before they are aborted. The timeout will be rounded\n\t// to nearest millisecond.\n\tSetAsyncScriptTimeout(timeout time.Duration) error\n\t// SetImplicitWaitTimeout sets the amount of time the driver should wait when\n\t// searching for elements. The timeout will be rounded to nearest millisecond.\n\tSetImplicitWaitTimeout(timeout time.Duration) error\n\t// SetPageLoadTimeout sets the amount of time the driver should wait when\n\t// loading a page. The timeout will be rounded to nearest millisecond.\n\tSetPageLoadTimeout(timeout time.Duration) error\n\n\t// Quit ends the current session. The browser instance will be closed.\n\tQuit() error\n\n\t// CurrentWindowHandle returns the ID of current window handle.\n\tCurrentWindowHandle() (string, error)\n\t// WindowHandles returns the IDs of current open windows.\n\tWindowHandles() ([]string, error)\n\t// CurrentURL returns the browser's current URL.\n\tCurrentURL() (string, error)\n\t// Title returns the current page's title.\n\tTitle() (string, error)\n\t// PageSource returns the current page's source.\n\tPageSource() (string, error)\n\t// Close closes the current window.\n\tClose() error\n\t// SwitchFrame switches to the given frame. The frame parameter can be the\n\t// frame's ID as a string, its WebElement instance as returned by\n\t// GetElement, or nil to switch to the current top-level browsing context.\n\tSwitchFrame(frame interface{}) error\n\t// SwitchWindow switches the context to the specified window.\n\tSwitchWindow(name string) error\n\t// CloseWindow closes the specified window.\n\tCloseWindow(name string) error\n\t// MaximizeWindow maximizes a window. If the name is empty, the current\n\t// window will be maximized.\n\tMaximizeWindow(name string) error\n\t// ResizeWindow changes the dimensions of a window. If the name is empty, the\n\t// current window will be maximized.\n\tResizeWindow(name string, width, height int) error\n\n\t// Get navigates the browser to the provided URL.\n\tGet(url string) error\n\t// Forward moves forward in history.\n\tForward() error\n\t// Back moves backward in history.\n\tBack() error\n\t// Refresh refreshes the page.\n\tRefresh() error\n\n\t// FindElement finds exactly one element in the current page's DOM.\n\tFindElement(by, value string) (WebElement, error)\n\t// FindElement finds potentially many elements in the current page's DOM.\n\tFindElements(by, value string) ([]WebElement, error)\n\t// ActiveElement returns the currently active element on the page.\n\tActiveElement() (WebElement, error)\n\n\t// DecodeElement decodes a single element response.\n\tDecodeElement([]byte) (WebElement, error)\n\t// DecodeElements decodes a multi-element response.\n\tDecodeElements([]byte) ([]WebElement, error)\n\n\t// GetCookies returns all of the cookies in the browser's jar.\n\tGetCookies() ([]Cookie, error)\n\t// GetCookie returns the named cookie in the jar, if present. This method is\n\t// only implemented for Firefox.\n\tGetCookie(name string) (Cookie, error)\n\t// AddCookie adds a cookie to the browser's jar.\n\tAddCookie(cookie *Cookie) error\n\t// DeleteAllCookies deletes all of the cookies in the browser's jar.\n\tDeleteAllCookies() error\n\t// DeleteCookie deletes a cookie to the browser's jar.\n\tDeleteCookie(name string) error\n\n\t// Click clicks a mouse button. The button should be one of RightButton,\n\t// MiddleButton or LeftButton.\n\tClick(button int) error\n\t// DoubleClick clicks the left mouse button twice.\n\tDoubleClick() error\n\t// ButtonDown causes the left mouse button to be held down.\n\tButtonDown() error\n\t// ButtonUp causes the left mouse button to be released.\n\tButtonUp() error\n\n\t// StoreKeyActions store provided actions until they are executed\n\t// by PerformActions or released by ReleaseActions.\n\t// inputID is a string used as a unique virtual device identifier for this\n\t// and future actions, the value can be set to any valid string\n\t// and used to refer to this specific device in future calls.\n\tStoreKeyActions(inputID string, actions ...KeyAction)\n\n\t// StorePointerActions store provided actions until they are executed\n\t// by PerformActions or released by ReleaseActions.\n\t// inputID is a string used as a unique virtual device identifier for this\n\t// and future actions, the value can be set to any valid string\n\t// and used to refer to this specific device in future calls.\n\tStorePointerActions(inputID string, pointer PointerType, actions ...PointerAction)\n\n\t// PerformActions executes actions previously stored by calls to StorePointerActions and StoreKeyActions.\n\tPerformActions() error\n\t// ReleaseActions releases keys and pointer buttons if they are pressed,\n\t// triggering any events as if they were performed by a regular action.\n\tReleaseActions() error\n\n\t// SendModifier sends the modifier key to the active element. The modifier\n\t// can be one of ShiftKey, ControlKey, AltKey, MetaKey.\n\t//\n\t// Deprecated: Use KeyDown or KeyUp instead.\n\tSendModifier(modifier string, isDown bool) error\n\t// KeyDown sends a sequence of keystrokes to the active element. This method\n\t// is similar to SendKeys but without the implicit termination. Modifiers are\n\t// not released at the end of each call.\n\tKeyDown(keys string) error\n\t// KeyUp indicates that a previous keystroke sent by KeyDown should be\n\t// released.\n\tKeyUp(keys string) error\n\t// Screenshot takes a screenshot of the browser window.\n\tScreenshot() ([]byte, error)\n\t// Log fetches the logs. Log types must be previously configured in the\n\t// capabilities.\n\t//\n\t// NOTE: will return an error (not implemented) on IE11 or Edge drivers.\n\tLog(typ log.Type) ([]log.Message, error)\n\n\t// DismissAlert dismisses current alert.\n\tDismissAlert() error\n\t// AcceptAlert accepts the current alert.\n\tAcceptAlert() error\n\t// AlertText returns the current alert text.\n\tAlertText() (string, error)\n\t// SetAlertText sets the current alert text.\n\tSetAlertText(text string) error\n\n\t// ExecuteScript executes a script.\n\tExecuteScript(script string, args []interface{}) (interface{}, error)\n\t// ExecuteScriptAsync asynchronously executes a script.\n\tExecuteScriptAsync(script string, args []interface{}) (interface{}, error)\n\n\t// ExecuteScriptRaw executes a script but does not perform JSON decoding.\n\tExecuteScriptRaw(script string, args []interface{}) ([]byte, error)\n\t// ExecuteScriptAsyncRaw asynchronously executes a script but does not\n\t// perform JSON decoding.\n\tExecuteScriptAsyncRaw(script string, args []interface{}) ([]byte, error)\n\n\t// WaitWithTimeoutAndInterval waits for the condition to evaluate to true.\n\tWaitWithTimeoutAndInterval(condition Condition, timeout, interval time.Duration) error\n\n\t// WaitWithTimeout works like WaitWithTimeoutAndInterval, but with default polling interval.\n\tWaitWithTimeout(condition Condition, timeout time.Duration) error\n\n\t//Wait works like WaitWithTimeoutAndInterval, but using the default timeout and polling interval.\n\tWait(condition Condition) error\n}\n\n// WebElement defines method supported by web elements.\ntype WebElement interface {\n\t// Click clicks on the element.\n\tClick() error\n\t// SendKeys types into the element.\n\tSendKeys(keys string) error\n\t// Submit submits the button.\n\tSubmit() error\n\t// Clear clears the element.\n\tClear() error\n\t// MoveTo moves the mouse to relative coordinates from center of element, If\n\t// the element is not visible, it will be scrolled into view.\n\tMoveTo(xOffset, yOffset int) error\n\n\t// FindElement finds a child element.\n\tFindElement(by, value string) (WebElement, error)\n\t// FindElement finds multiple children elements.\n\tFindElements(by, value string) ([]WebElement, error)\n\n\t// TagName returns the element's name.\n\tTagName() (string, error)\n\t// Text returns the text of the element.\n\tText() (string, error)\n\t// IsSelected returns true if element is selected.\n\tIsSelected() (bool, error)\n\t// IsEnabled returns true if the element is enabled.\n\tIsEnabled() (bool, error)\n\t// IsDisplayed returns true if the element is displayed.\n\tIsDisplayed() (bool, error)\n\t// GetAttribute returns the named HTML attribute of the element.\n\tGetAttribute(name string) (string, error)\n\t// GetProperty returns the DOM property of the element. The DOM property\n\t// values can change (e.g. input value), the HTML attributes can't.\n\tGetProperty(name string) (string, error)\n\t// Location returns the element's location.\n\tLocation() (*Point, error)\n\t// LocationInView returns the element's location once it has been scrolled\n\t// into view.\n\tLocationInView() (*Point, error)\n\t// Size returns the element's size.\n\tSize() (*Size, error)\n\t// CSSProperty returns the value of the specified CSS property of the\n\t// element.\n\tCSSProperty(name string) (string, error)\n\t// Screenshot takes a screenshot of the attribute scroll'ing if necessary.\n\tScreenshot(scroll bool) ([]byte, error)\n}\n"
        },
        {
          "name": "selenium_test.go",
          "type": "blob",
          "size": 10.32421875,
          "content": "package selenium_test\n\nimport (\n\t\"flag\"\n\t\"fmt\"\n\t\"net\"\n\t\"net/http/httptest\"\n\t\"os\"\n\t\"os/exec\"\n\t\"path/filepath\"\n\t\"sort\"\n\t\"strings\"\n\t\"testing\"\n\n\t\"github.com/blang/semver\"\n\t\"github.com/golang/glog\"\n\t\"github.com/tebeka/selenium\"\n\t\"github.com/tebeka/selenium/internal/seleniumtest\"\n)\n\nvar (\n\tselenium3Path          = flag.String(\"selenium3_path\", \"\", \"The path to the Selenium 3 server JAR. If empty or the file is not present, Firefox tests using Selenium 3 will not be run.\")\n\tfirefoxBinarySelenium3 = flag.String(\"firefox_binary_for_selenium3\", \"vendor/firefox/firefox\", \"The name of the Firefox binary for Selenium 3 tests or the path to it. If the name does not contain directory separators, the PATH will be searched.\")\n\tgeckoDriverPath        = flag.String(\"geckodriver_path\", \"\", \"The path to the geckodriver binary. If empty or the file is not present, the Geckodriver tests will not be run.\")\n\tjavaPath               = flag.String(\"java_path\", \"\", \"The path to the Java runtime binary to invoke. If not specified, 'java' will be used.\")\n\n\tchromeDriverPath = flag.String(\"chrome_driver_path\", \"\", \"The path to the ChromeDriver binary. If empty or the file is not present, Chrome tests will not be run.\")\n\tchromeBinary     = flag.String(\"chrome_binary\", \"vendor/chrome-linux/chrome\", \"The name of the Chrome binary or the path to it. If name is not an exact path, the PATH will be searched.\")\n\n\thtmlUnitDriverPath = flag.String(\"htmlunit_driver_path\", \"vendor/htmlunit-driver.jar\", \"The path to the HTMLUnit Driver JAR.\")\n\n\tuseDocker          = flag.Bool(\"docker\", false, \"If set, run the tests in a Docker container.\")\n\trunningUnderDocker = flag.Bool(\"running_under_docker\", false, \"This is set by the Docker test harness and should not be needed otherwise.\")\n\n\tstartFrameBuffer = flag.Bool(\"start_frame_buffer\", false, \"If true, start an Xvfb subprocess and run the browsers in that X server.\")\n\theadless         = flag.Bool(\"headless\", true, \"If true, run Chrome and Firefox in headless mode, not requiring a frame buffer.\")\n)\n\nfunc TestMain(m *testing.M) {\n\tflag.Parse()\n\tif err := setDriverPaths(); err != nil {\n\t\tfmt.Fprintf(os.Stderr, \"Exiting early: unable to get the driver paths -- %s\", err.Error())\n\t\tos.Exit(1)\n\t}\n\tos.Exit(m.Run())\n}\n\nfunc findBestPath(glob string, binary bool) string {\n\tmatches, err := filepath.Glob(glob)\n\tif err != nil {\n\t\tglog.Warningf(\"Error globbing %q: %s\", glob, err)\n\t\treturn \"\"\n\t}\n\tif len(matches) == 0 {\n\t\treturn \"\"\n\t}\n\t// Iterate backwards: newer versions should be sorted to the end.\n\tsort.Strings(matches)\n\tfor i := len(matches) - 1; i >= 0; i-- {\n\t\tpath := matches[i]\n\t\tfi, err := os.Stat(path)\n\t\tif err != nil {\n\t\t\tglog.Warningf(\"Error statting %q: %s\", path, err)\n\t\t\tcontinue\n\t\t}\n\t\tif !fi.Mode().IsRegular() {\n\t\t\tcontinue\n\t\t}\n\t\tif binary && fi.Mode().Perm()&0111 == 0 {\n\t\t\tcontinue\n\t\t}\n\t\treturn path\n\t}\n\treturn \"\"\n}\n\nfunc setDriverPaths() error {\n\tif *selenium3Path == \"\" {\n\t\t*selenium3Path = findBestPath(\"vendor/selenium-server*\" /*binary=*/, false)\n\t}\n\n\tif *geckoDriverPath == \"\" {\n\t\t*geckoDriverPath = findBestPath(\"vendor/geckodriver*\" /*binary=*/, true)\n\t}\n\n\tif *chromeDriverPath == \"\" {\n\t\t*chromeDriverPath = findBestPath(\"vendor/chromedriver*\" /*binary=*/, true)\n\t}\n\n\treturn nil\n}\n\nfunc pickUnusedPort() (int, error) {\n\taddr, err := net.ResolveTCPAddr(\"tcp\", \"127.0.0.1:0\")\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\n\tl, err := net.ListenTCP(\"tcp\", addr)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\tport := l.Addr().(*net.TCPAddr).Port\n\tif err := l.Close(); err != nil {\n\t\treturn 0, err\n\t}\n\treturn port, nil\n}\n\nfunc TestChrome(t *testing.T) {\n\tif *useDocker {\n\t\tt.Skip(\"Skipping Chrome tests because they will be run under a Docker container\")\n\t}\n\tif _, err := os.Stat(*chromeBinary); err != nil {\n\t\tpath, err := exec.LookPath(*chromeBinary)\n\t\tif err != nil {\n\t\t\tt.Skipf(\"Skipping Chrome tests because binary %q not found\", *chromeBinary)\n\t\t}\n\t\t*chromeBinary = path\n\t}\n\tif _, err := os.Stat(*chromeDriverPath); err != nil {\n\t\tt.Skipf(\"Skipping Chrome tests because ChromeDriver not found at path %q\", *chromeDriverPath)\n\t}\n\n\tt.Run(\"Chromedriver\", func(t *testing.T) {\n\t\trunChromeTests(t, seleniumtest.Config{\n\t\t\tPath: *chromeBinary,\n\t\t})\n\t})\n\n\tt.Run(\"Selenium3\", func(t *testing.T) {\n\t\trunChromeTests(t, seleniumtest.Config{\n\t\t\tPath:            *chromeBinary,\n\t\t\tSeleniumVersion: semver.MustParse(\"3.0.0\"),\n\t\t})\n\t})\n}\n\nfunc runChromeTests(t *testing.T, c seleniumtest.Config) {\n\tc.Browser = \"chrome\"\n\tc.Headless = *headless\n\n\tif *startFrameBuffer {\n\t\tc.ServiceOptions = append(c.ServiceOptions, selenium.StartFrameBuffer())\n\t}\n\tif testing.Verbose() {\n\t\tselenium.SetDebug(true)\n\t\tc.ServiceOptions = append(c.ServiceOptions, selenium.Output(os.Stderr))\n\t}\n\n\tport, err := pickUnusedPort()\n\tif err != nil {\n\t\tt.Fatalf(\"pickUnusedPort() returned error: %v\", err)\n\t}\n\tc.Addr = fmt.Sprintf(\"http://127.0.0.1:%d/wd/hub\", port)\n\n\tvar s *selenium.Service\n\tif c.SeleniumVersion.Major == 3 {\n\t\tc.ServiceOptions = append(c.ServiceOptions, selenium.ChromeDriver(*chromeDriverPath))\n\t\ts, err = selenium.NewSeleniumService(*selenium3Path, port, c.ServiceOptions...)\n\t} else {\n\t\ts, err = selenium.NewChromeDriverService(*chromeDriverPath, port, c.ServiceOptions...)\n\t}\n\tif err != nil {\n\t\tt.Fatalf(\"Error starting the server: %v\", err)\n\t}\n\n\ths := httptest.NewServer(seleniumtest.Handler)\n\tdefer hs.Close()\n\tc.ServerURL = hs.URL\n\n\tseleniumtest.RunCommonTests(t, c)\n\tseleniumtest.RunChromeTests(t, c)\n\n\tif err := s.Stop(); err != nil {\n\t\tt.Fatalf(\"Error stopping the ChromeDriver service: %v\", err)\n\t}\n}\n\nfunc TestFirefox(t *testing.T) {\n\tif *useDocker {\n\t\tt.Skip(\"Skipping tests because they will be run under a Docker container\")\n\t}\n\tif _, err := os.Stat(*geckoDriverPath); err != nil {\n\t\tt.Skipf(\"Skipping Firefox tests on Selenium 3 because geckodriver binary %q not found\", *geckoDriverPath)\n\t}\n\n\tif s, err := os.Stat(*firefoxBinarySelenium3); err != nil || !s.Mode().IsRegular() {\n\t\tif p, err := exec.LookPath(*firefoxBinarySelenium3); err == nil {\n\t\t\t*firefoxBinarySelenium3 = p\n\t\t} else {\n\t\t\tt.Skipf(\"Skipping Firefox tests because binary %q not found\", *firefoxBinarySelenium3)\n\t\t}\n\t}\n\n\tt.Run(\"Selenium3\", func(t *testing.T) {\n\t\trunFirefoxTests(t, *selenium3Path, seleniumtest.Config{\n\t\t\tSeleniumVersion: semver.MustParse(\"3.0.0\"),\n\t\t\tServiceOptions:  []selenium.ServiceOption{selenium.GeckoDriver(*geckoDriverPath)},\n\t\t\tPath:            *firefoxBinarySelenium3,\n\t\t})\n\t})\n\tt.Run(\"Geckodriver\", func(t *testing.T) {\n\t\trunFirefoxTests(t, *geckoDriverPath, seleniumtest.Config{\n\t\t\tPath: *firefoxBinarySelenium3,\n\t\t})\n\t})\n}\n\nfunc TestHTMLUnit(t *testing.T) {\n\tif *useDocker {\n\t\tt.Skip(\"Skipping tests because they will be run under a Docker container\")\n\t}\n\tif _, err := os.Stat(*selenium3Path); err != nil {\n\t\tt.Skipf(\"Skipping HTMLUnit tests because the Selenium WebDriver JAR was not found at path %q\", *selenium3Path)\n\t}\n\tif _, err := os.Stat(*htmlUnitDriverPath); err != nil {\n\t\tt.Skipf(\"Skipping HTMLUnit tests because the HTMLUnit Driver JAR not found at path %q\", *htmlUnitDriverPath)\n\t}\n\n\tif testing.Verbose() {\n\t\tselenium.SetDebug(true)\n\t}\n\n\tc := seleniumtest.Config{\n\t\tBrowser:         \"htmlunit\",\n\t\tSeleniumVersion: semver.MustParse(\"3.0.0\"),\n\t\tServiceOptions:  []selenium.ServiceOption{selenium.HTMLUnit(*htmlUnitDriverPath)},\n\t\t// HTMLUnit-Driver currently does not support the sameSite attribute\n\t\t// See: https://github.com/SeleniumHQ/htmlunit-driver/issues/97\n\t\tSameSiteUnsupported: true,\n\t}\n\n\tport, err := pickUnusedPort()\n\tif err != nil {\n\t\tt.Fatalf(\"pickUnusedPort() returned error: %v\", err)\n\t}\n\ts, err := selenium.NewSeleniumService(*selenium3Path, port, c.ServiceOptions...)\n\tif err != nil {\n\t\tt.Fatalf(\"Error starting the WebDriver server with binary %q: %v\", *selenium3Path, err)\n\t}\n\tc.Addr = fmt.Sprintf(\"http://127.0.0.1:%d/wd/hub\", port)\n\n\ths := httptest.NewServer(seleniumtest.Handler)\n\tdefer hs.Close()\n\tc.ServerURL = hs.URL\n\n\tseleniumtest.RunCommonTests(t, c)\n\n\tif err := s.Stop(); err != nil {\n\t\tt.Fatalf(\"Error stopping the Selenium service: %v\", err)\n\t}\n}\n\nfunc runFirefoxTests(t *testing.T, webDriverPath string, c seleniumtest.Config) {\n\tc.Browser = \"firefox\"\n\n\tif *startFrameBuffer {\n\t\tc.ServiceOptions = append(c.ServiceOptions, selenium.StartFrameBuffer())\n\t}\n\tif testing.Verbose() {\n\t\tselenium.SetDebug(true)\n\t\tc.ServiceOptions = append(c.ServiceOptions, selenium.Output(os.Stderr))\n\t}\n\tif *javaPath != \"\" {\n\t\tc.ServiceOptions = append(c.ServiceOptions, selenium.JavaPath(*javaPath))\n\t}\n\n\tport, err := pickUnusedPort()\n\tif err != nil {\n\t\tt.Fatalf(\"pickUnusedPort() returned error: %v\", err)\n\t}\n\n\tvar s *selenium.Service\n\tif c.SeleniumVersion.Major == 0 {\n\t\tc.Addr = fmt.Sprintf(\"http://127.0.0.1:%d\", port)\n\t\ts, err = selenium.NewGeckoDriverService(webDriverPath, port, c.ServiceOptions...)\n\t} else {\n\t\tc.Addr = fmt.Sprintf(\"http://127.0.0.1:%d/wd/hub\", port)\n\t\tif _, err := os.Stat(*selenium3Path); err != nil {\n\t\t\tt.Skipf(\"Skipping Firefox tests using Selenium 3 because Selenium WebDriver JAR not found at path %q\", *selenium3Path)\n\t\t}\n\n\t\ts, err = selenium.NewSeleniumService(webDriverPath, port, c.ServiceOptions...)\n\t}\n\tif err != nil {\n\t\tt.Fatalf(\"Error starting the WebDriver server with binary %q: %v\", webDriverPath, err)\n\t}\n\n\ths := httptest.NewServer(seleniumtest.Handler)\n\tdefer hs.Close()\n\tc.ServerURL = hs.URL\n\n\tif c.SeleniumVersion.Major == 0 {\n\t\tc.Addr = fmt.Sprintf(\"http://127.0.0.1:%d\", port)\n\t} else {\n\t\tc.Addr = fmt.Sprintf(\"http://127.0.0.1:%d/wd/hub\", port)\n\t}\n\n\tc.Headless = *headless\n\n\tseleniumtest.RunCommonTests(t, c)\n\tseleniumtest.RunFirefoxTests(t, c)\n\n\tif err := s.Stop(); err != nil {\n\t\tt.Fatalf(\"Error stopping the Selenium service: %v\", err)\n\t}\n}\n\nfunc TestDocker(t *testing.T) {\n\tif *runningUnderDocker {\n\t\treturn\n\t}\n\tif !*useDocker {\n\t\tt.Skip(\"Skipping Docker tests because --docker was not specified.\")\n\t}\n\n\targs := []string{\"build\", \"-t\", \"go-selenium\", \"testing/\"}\n\tif out, err := exec.Command(\"docker\", args...).CombinedOutput(); err != nil {\n\t\tt.Logf(\"Output from `docker %s`:\\n%s\", strings.Join(args, \" \"), string(out))\n\t\tt.Fatalf(\"Building Docker container failed: %v\", err)\n\t}\n\n\tcwd, err := os.Getwd()\n\tif err != nil {\n\t\tt.Fatalf(\"os.Getwd() returned error: %v\", err)\n\t}\n\n\t// TODO(minusnine): pass through relevant flags to docker-test.sh to be\n\t// passed to go test.\n\tcmd := exec.Command(\"docker\", \"run\", fmt.Sprintf(\"--volume=%s:/code\", cwd), \"--workdir=/code/\", \"go-selenium\", \"testing/docker-test.sh\")\n\tif testing.Verbose() {\n\t\tcmd.Stdout = os.Stdout\n\t\tcmd.Stderr = os.Stderr\n\t}\n\tif err := cmd.Run(); err != nil {\n\t\tt.Fatalf(\"docker run failed: %v\", err)\n\t}\n}\n"
        },
        {
          "name": "service.go",
          "type": "blob",
          "size": 11.205078125,
          "content": "package selenium\n\nimport (\n\t\"bufio\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"os\"\n\t\"os/exec\"\n\t\"regexp\"\n\t\"strconv\"\n\t\"strings\"\n\t\"time\"\n)\n\n// ServiceOption configures a Service instance.\ntype ServiceOption func(*Service) error\n\n// Display specifies the value to which set the DISPLAY environment variable,\n// as well as the path to the Xauthority file containing credentials needed to\n// write to that X server.\nfunc Display(d, xauthPath string) ServiceOption {\n\treturn func(s *Service) error {\n\t\tif s.display != \"\" {\n\t\t\treturn fmt.Errorf(\"service display already set: %v\", s.display)\n\t\t}\n\t\tif s.xauthPath != \"\" {\n\t\t\treturn fmt.Errorf(\"service xauth path already set: %v\", s.xauthPath)\n\t\t}\n\t\tif !isDisplay(d) {\n\t\t\treturn fmt.Errorf(\"supplied display %q must be of the format 'x' or 'x.y' where x and y are integers\", d)\n\t\t}\n\t\ts.display = d\n\t\ts.xauthPath = xauthPath\n\t\treturn nil\n\t}\n}\n\n// isDisplay validates that the given disp is in the format \"x\" or \"x.y\", where\n// x and y are both integers.\nfunc isDisplay(disp string) bool {\n\tds := strings.Split(disp, \".\")\n\tif len(ds) > 2 {\n\t\treturn false\n\t}\n\n\tfor _, d := range ds {\n\t\tif _, err := strconv.Atoi(d); err != nil {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\n// StartFrameBuffer causes an X virtual frame buffer to start before the\n// WebDriver service. The frame buffer process will be terminated when the\n// service itself is stopped.\n//\n// This is equivalent to calling StartFrameBufferWithOptions with an empty\n// map.\nfunc StartFrameBuffer() ServiceOption {\n\treturn StartFrameBufferWithOptions(FrameBufferOptions{})\n}\n\n// FrameBufferOptions describes the options that can be used to create a frame buffer.\ntype FrameBufferOptions struct {\n\t// ScreenSize is the option for the frame buffer screen size.\n\t// This is of the form \"{width}x{height}[x{depth}]\".  For example: \"1024x768x24\"\n\tScreenSize string\n}\n\n// StartFrameBufferWithOptions causes an X virtual frame buffer to start before\n// the WebDriver service. The frame buffer process will be terminated when the\n// service itself is stopped.\nfunc StartFrameBufferWithOptions(options FrameBufferOptions) ServiceOption {\n\treturn func(s *Service) error {\n\t\tif s.display != \"\" {\n\t\t\treturn fmt.Errorf(\"service display already set: %v\", s.display)\n\t\t}\n\t\tif s.xauthPath != \"\" {\n\t\t\treturn fmt.Errorf(\"service xauth path already set: %v\", s.xauthPath)\n\t\t}\n\t\tif s.xvfb != nil {\n\t\t\treturn fmt.Errorf(\"service Xvfb instance already running\")\n\t\t}\n\t\tfb, err := NewFrameBufferWithOptions(options)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"error starting frame buffer: %v\", err)\n\t\t}\n\t\ts.xvfb = fb\n\t\treturn Display(fb.Display, fb.AuthPath)(s)\n\t}\n}\n\n// Output specifies that the WebDriver service should log to the provided\n// writer.\nfunc Output(w io.Writer) ServiceOption {\n\treturn func(s *Service) error {\n\t\ts.output = w\n\t\treturn nil\n\t}\n}\n\n// GeckoDriver sets the path to the geckodriver binary for the Selenium Server.\n// Unlike other drivers, Selenium Server does not support specifying the\n// geckodriver path at runtime. This ServiceOption is only useful when calling\n// NewSeleniumService.\nfunc GeckoDriver(path string) ServiceOption {\n\treturn func(s *Service) error {\n\t\ts.geckoDriverPath = path\n\t\treturn nil\n\t}\n}\n\n// ChromeDriver sets the path for Chromedriver for the Selenium Server.  This\n// ServiceOption is only useful when calling NewSeleniumService.\nfunc ChromeDriver(path string) ServiceOption {\n\treturn func(s *Service) error {\n\t\ts.chromeDriverPath = path\n\t\treturn nil\n\t}\n}\n\n// JavaPath specifies the path to the JRE.\nfunc JavaPath(path string) ServiceOption {\n\treturn func(s *Service) error {\n\t\ts.javaPath = path\n\t\treturn nil\n\t}\n}\n\n// HTMLUnit specifies the path to the JAR for the HTMLUnit driver (compiled\n// with its dependencies).\n//\n// https://github.com/SeleniumHQ/htmlunit-driver/releases\nfunc HTMLUnit(path string) ServiceOption {\n\treturn func(s *Service) error {\n\t\ts.htmlUnitPath = path\n\t\treturn nil\n\t}\n}\n\n// Service controls a locally-running Selenium subprocess.\ntype Service struct {\n\tport            int\n\taddr            string\n\tcmd             *exec.Cmd\n\tshutdownURLPath string\n\n\tdisplay, xauthPath string\n\txvfb               *FrameBuffer\n\n\tgeckoDriverPath, javaPath string\n\tchromeDriverPath          string\n\thtmlUnitPath              string\n\n\toutput io.Writer\n}\n\n// FrameBuffer returns the FrameBuffer if one was started by the service and nil otherwise.\nfunc (s Service) FrameBuffer() *FrameBuffer {\n\treturn s.xvfb\n}\n\n// NewSeleniumService starts a Selenium instance in the background.\nfunc NewSeleniumService(jarPath string, port int, opts ...ServiceOption) (*Service, error) {\n\ts, err := newService(exec.Command(\"java\"), \"/wd/hub\", port, opts...)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif s.javaPath != \"\" {\n\t\ts.cmd.Path = s.javaPath\n\t}\n\tif s.geckoDriverPath != \"\" {\n\t\ts.cmd.Args = append([]string{\"java\", \"-Dwebdriver.gecko.driver=\" + s.geckoDriverPath}, s.cmd.Args[1:]...)\n\t}\n\tif s.chromeDriverPath != \"\" {\n\t\ts.cmd.Args = append([]string{\"java\", \"-Dwebdriver.chrome.driver=\" + s.chromeDriverPath}, s.cmd.Args[1:]...)\n\t}\n\n\tvar classpath []string\n\tif s.htmlUnitPath != \"\" {\n\t\tclasspath = append(classpath, s.htmlUnitPath)\n\t}\n\tclasspath = append(classpath, jarPath)\n\ts.cmd.Args = append(s.cmd.Args, \"-cp\", strings.Join(classpath, \":\"))\n\ts.cmd.Args = append(s.cmd.Args, \"org.openqa.grid.selenium.GridLauncherV3\", \"-port\", strconv.Itoa(port), \"-debug\")\n\n\tif err := s.start(port); err != nil {\n\t\treturn nil, err\n\t}\n\treturn s, nil\n}\n\n// NewChromeDriverService starts a ChromeDriver instance in the background.\nfunc NewChromeDriverService(path string, port int, opts ...ServiceOption) (*Service, error) {\n\tcmd := exec.Command(path, \"--port=\"+strconv.Itoa(port), \"--url-base=wd/hub\", \"--verbose\")\n\ts, err := newService(cmd, \"/wd/hub\", port, opts...)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\ts.shutdownURLPath = \"/shutdown\"\n\tif err := s.start(port); err != nil {\n\t\treturn nil, err\n\t}\n\treturn s, nil\n}\n\n// NewGeckoDriverService starts a GeckoDriver instance in the background.\nfunc NewGeckoDriverService(path string, port int, opts ...ServiceOption) (*Service, error) {\n\tcmd := exec.Command(path, \"--port\", strconv.Itoa(port))\n\ts, err := newService(cmd, \"\", port, opts...)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif err := s.start(port); err != nil {\n\t\treturn nil, err\n\t}\n\treturn s, nil\n}\n\nfunc newService(cmd *exec.Cmd, urlPrefix string, port int, opts ...ServiceOption) (*Service, error) {\n\ts := &Service{\n\t\tport: port,\n\t\taddr: fmt.Sprintf(\"http://localhost:%d%s\", port, urlPrefix),\n\t}\n\tfor _, opt := range opts {\n\t\tif err := opt(s); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\tcmd.Stderr = s.output\n\tcmd.Stdout = s.output\n\tcmd.Env = os.Environ()\n\t// TODO(minusnine): Pdeathsig is only supported on Linux. Somehow, make sure\n\t// process cleanup happens as gracefully as possible.\n\tif s.display != \"\" {\n\t\tcmd.Env = append(cmd.Env, \"DISPLAY=:\"+s.display)\n\t}\n\tif s.xauthPath != \"\" {\n\t\tcmd.Env = append(cmd.Env, \"XAUTHORITY=\"+s.xauthPath)\n\t}\n\ts.cmd = cmd\n\treturn s, nil\n}\n\nfunc (s *Service) start(port int) error {\n\tif err := s.cmd.Start(); err != nil {\n\t\treturn err\n\t}\n\n\tfor i := 0; i < 30; i++ {\n\t\ttime.Sleep(time.Second)\n\t\tresp, err := http.Get(s.addr + \"/status\")\n\t\tif err == nil {\n\t\t\tresp.Body.Close()\n\t\t\tswitch resp.StatusCode {\n\t\t\t// Selenium <3 returned Forbidden and BadRequest. ChromeDriver and\n\t\t\t// Selenium 3 return OK.\n\t\t\tcase http.StatusForbidden, http.StatusBadRequest, http.StatusOK:\n\t\t\t\treturn nil\n\t\t\t}\n\t\t}\n\t}\n\treturn fmt.Errorf(\"server did not respond on port %d\", port)\n}\n\n// Stop shuts down the WebDriver service, and the X virtual frame buffer\n// if one was started.\nfunc (s *Service) Stop() error {\n\t// Selenium 3 stopped supporting the shutdown URL by default.\n\t// https://github.com/SeleniumHQ/selenium/issues/2852\n\tif s.shutdownURLPath == \"\" {\n\t\tif err := s.cmd.Process.Kill(); err != nil {\n\t\t\treturn err\n\t\t}\n\t} else {\n\t\tresp, err := http.Get(s.addr + s.shutdownURLPath)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tresp.Body.Close()\n\t}\n\tif err := s.cmd.Wait(); err != nil && err.Error() != \"signal: killed\" {\n\t\treturn err\n\t}\n\tif s.xvfb != nil {\n\t\treturn s.xvfb.Stop()\n\t}\n\treturn nil\n}\n\n// FrameBuffer controls an X virtual frame buffer running as a background\n// process.\ntype FrameBuffer struct {\n\t// Display is the X11 display number that the Xvfb process is hosting\n\t// (without the preceding colon).\n\tDisplay string\n\t// AuthPath is the path to the X11 authorization file that permits X clients\n\t// to use the X server. This is typically provided to the client via the\n\t// XAUTHORITY environment variable.\n\tAuthPath string\n\n\tcmd *exec.Cmd\n}\n\n// NewFrameBuffer starts an X virtual frame buffer running in the background.\n//\n// This is equivalent to calling NewFrameBufferWithOptions with an empty NewFrameBufferWithOptions.\nfunc NewFrameBuffer() (*FrameBuffer, error) {\n\treturn NewFrameBufferWithOptions(FrameBufferOptions{})\n}\n\n// NewFrameBufferWithOptions starts an X virtual frame buffer running in the background.\n// FrameBufferOptions may be populated to change the behavior of the frame buffer.\nfunc NewFrameBufferWithOptions(options FrameBufferOptions) (*FrameBuffer, error) {\n\tr, w, err := os.Pipe()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer r.Close()\n\n\tauth, err := ioutil.TempFile(\"\", \"selenium-xvfb\")\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tauthPath := auth.Name()\n\tif err := auth.Close(); err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Xvfb will print the display on which it is listening to file descriptor 3,\n\t// for which we provide a pipe.\n\targuments := []string{\"-displayfd\", \"3\", \"-nolisten\", \"tcp\"}\n\tif options.ScreenSize != \"\" {\n\t\tvar screenSizeExpression = regexp.MustCompile(`^\\d+x\\d+(?:x\\d+)$`)\n\t\tif !screenSizeExpression.MatchString(options.ScreenSize) {\n\t\t\treturn nil, fmt.Errorf(\"invalid screen size: expected 'WxH[xD]', got %q\", options.ScreenSize)\n\t\t}\n\t\targuments = append(arguments, \"-screen\", \"0\", options.ScreenSize)\n\t}\n\txvfb := exec.Command(\"Xvfb\", arguments...)\n\txvfb.ExtraFiles = []*os.File{w}\n\n\t// TODO(minusnine): plumb a way to set xvfb.Std{err,out} conditionally.\n\t// TODO(minusnine): Pdeathsig is only supported on Linux. Somehow, make sure\n\t// process cleanup happens as gracefully as possible.\n\txvfb.Env = append(xvfb.Env, \"XAUTHORITY=\"+authPath)\n\tif err := xvfb.Start(); err != nil {\n\t\treturn nil, err\n\t}\n\tw.Close()\n\n\ttype resp struct {\n\t\tdisplay string\n\t\terr     error\n\t}\n\tch := make(chan resp)\n\tgo func() {\n\t\tbufr := bufio.NewReader(r)\n\t\ts, err := bufr.ReadString('\\n')\n\t\tch <- resp{s, err}\n\t}()\n\n\tvar display string\n\tselect {\n\tcase resp := <-ch:\n\t\tif resp.err != nil {\n\t\t\treturn nil, resp.err\n\t\t}\n\t\tdisplay = strings.TrimSpace(resp.display)\n\t\tif _, err := strconv.Atoi(display); err != nil {\n\t\t\treturn nil, errors.New(\"Xvfb did not print the display number\")\n\t\t}\n\tcase <-time.After(3 * time.Second):\n\t\treturn nil, errors.New(\"timeout waiting for Xvfb\")\n\t}\n\n\txauth := exec.Command(\"xauth\", \"generate\", \":\"+display, \".\", \"trusted\")\n\txauth.Stderr = os.Stderr\n\txauth.Stdout = os.Stdout\n\txauth.Env = append(xauth.Env, \"XAUTHORITY=\"+authPath)\n\n\tif err := xauth.Run(); err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn &FrameBuffer{display, authPath, xvfb}, nil\n}\n\n// Stop kills the background frame buffer process and removes the X\n// authorization file.\nfunc (f FrameBuffer) Stop() error {\n\tif err := f.cmd.Process.Kill(); err != nil {\n\t\treturn err\n\t}\n\tos.Remove(f.AuthPath) // best effort removal; ignore error\n\tif err := f.cmd.Wait(); err != nil && err.Error() != \"signal: killed\" {\n\t\treturn err\n\t}\n\treturn nil\n}\n"
        },
        {
          "name": "service_test.go",
          "type": "blob",
          "size": 3.513671875,
          "content": "package selenium\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/BurntSushi/xgbutil\"\n\t\"github.com/google/go-cmp/cmp\"\n)\n\nfunc TestIsDisplay(t *testing.T) {\n\ttests := []struct {\n\t\tdesc  string\n\t\tin    string\n\t\tvalid bool\n\t}{\n\t\t{\n\t\t\tdesc:  \"valid with just display\",\n\t\t\tin:    \"2\",\n\t\t\tvalid: true,\n\t\t},\n\t\t{\n\t\t\tdesc:  \"valid with display and screen\",\n\t\t\tin:    \"2.5\",\n\t\t\tvalid: true,\n\t\t},\n\t\t{\n\t\t\tdesc:  \"invalid with non-numeric display\",\n\t\t\tin:    \"a\",\n\t\t\tvalid: false,\n\t\t},\n\t\t{\n\t\t\tdesc:  \"invalid with non-numeric display and screen\",\n\t\t\tin:    \"a.5\",\n\t\t\tvalid: false,\n\t\t},\n\t\t{\n\t\t\tdesc:  \"invalid with display and non-numeric screen\",\n\t\t\tin:    \"2.b\",\n\t\t\tvalid: false,\n\t\t},\n\t\t{\n\t\t\tdesc:  \"invalid with display and blank screen\",\n\t\t\tin:    \"2.\",\n\t\t\tvalid: false,\n\t\t},\n\t\t{\n\t\t\tdesc:  \"invalid with blank display and screen\",\n\t\t\tin:    \".3\",\n\t\t\tvalid: false,\n\t\t},\n\t\t{\n\t\t\tdesc:  \"invalid with blank display and blank screen\",\n\t\t\tin:    \".\",\n\t\t\tvalid: false,\n\t\t},\n\t\t{\n\t\t\tdesc:  \"blank string is invalid\",\n\t\t\tin:    \"\",\n\t\t\tvalid: false,\n\t\t},\n\t\t{\n\t\t\tdesc:  \"malformed input\",\n\t\t\tin:    \"2.5.7\",\n\t\t\tvalid: false,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tif got, want := isDisplay(test.in), test.valid; got != want {\n\t\t\tt.Errorf(\"%s: isDisplay = %t, want %t\", test.desc, got, want)\n\t\t}\n\t}\n}\n\nfunc TestFrameBuffer(t *testing.T) {\n\t// Note on FrameBuffer and xgb.Conn:\n\t// There appears to be a race condition when closing a Conn instance before\n\t// a FrameBuffer instance.  A short sleep solves the problem.\n\tt.Run(\"Default behavior\", func(t *testing.T) {\n\t\t// The default Xvfb screen size is \"1280x1024x8\".\n\t\tframeBuffer, err := NewFrameBuffer()\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"Could not create frame buffer: %s\", err.Error())\n\t\t}\n\t\tdefer frameBuffer.Stop()\n\n\t\tif frameBuffer.Display == \"\" {\n\t\t\tt.Fatalf(\"frameBuffer.Display is empty\")\n\t\t}\n\n\t\td, err := xgbutil.NewConnDisplay(\":\" + frameBuffer.Display)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"could not connect to display %q: %s\", frameBuffer.Display, err.Error())\n\t\t}\n\t\tdefer time.Sleep(time.Second * 2)\n\t\tdefer d.Conn().Close()\n\t\ts := d.Screen()\n\t\tif diff := cmp.Diff(1280, int(s.WidthInPixels)); diff != \"\" {\n\t\t\tt.Fatalf(\"args returned diff (-want/+got):\\n%s\", diff)\n\t\t}\n\t\tif diff := cmp.Diff(1024, int(s.HeightInPixels)); diff != \"\" {\n\t\t\tt.Fatalf(\"args returned diff (-want/+got):\\n%s\", diff)\n\t\t}\n\t})\n\tt.Run(\"With bad screen size\", func(t *testing.T) {\n\t\toptions := FrameBufferOptions{\n\t\t\tScreenSize: \"not a screen size\",\n\t\t}\n\t\t_, err := NewFrameBufferWithOptions(options)\n\t\tif err == nil {\n\t\t\tt.Fatalf(\"Expected an error about the screen size\")\n\t\t}\n\t})\n\tt.Run(\"With screen size\", func(t *testing.T) {\n\t\tdesiredWidth := 1024\n\t\tdesiredHeight := 768\n\t\tdesiredDepth := 24\n\t\toptions := FrameBufferOptions{\n\t\t\tScreenSize: fmt.Sprintf(\"%dx%dx%d\", desiredWidth, desiredHeight, desiredDepth),\n\t\t}\n\t\tframeBuffer, err := NewFrameBufferWithOptions(options)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"Could not create frame buffer: %s\", err.Error())\n\t\t}\n\t\tdefer frameBuffer.Stop()\n\n\t\tif frameBuffer.Display == \"\" {\n\t\t\tt.Fatalf(\"frameBuffer.Display is empty\")\n\t\t}\n\n\t\td, err := xgbutil.NewConnDisplay(\":\" + frameBuffer.Display)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"could not connect to display %q: %s\", frameBuffer.Display, err.Error())\n\t\t}\n\t\tdefer time.Sleep(time.Second * 2)\n\t\tdefer d.Conn().Close()\n\t\ts := d.Screen()\n\t\tif diff := cmp.Diff(desiredWidth, int(s.WidthInPixels)); diff != \"\" {\n\t\t\tt.Fatalf(\"args returned diff (-want/+got):\\n%s\", diff)\n\t\t}\n\t\tif diff := cmp.Diff(desiredHeight, int(s.HeightInPixels)); diff != \"\" {\n\t\t\tt.Fatalf(\"args returned diff (-want/+got):\\n%s\", diff)\n\t\t}\n\t})\n}\n"
        },
        {
          "name": "testing",
          "type": "tree",
          "content": null
        },
        {
          "name": "vendor",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}