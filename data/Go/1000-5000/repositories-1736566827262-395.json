{
  "metadata": {
    "timestamp": 1736566827262,
    "page": 395,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjQwMA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "cespare/reflex",
      "stars": 3424,
      "defaultBranch": "main",
      "files": [
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.029296875,
          "content": "/reflex\n/Reflexfile\n/release/\n"
        },
        {
          "name": "CONTRIBUTING.md",
          "type": "blob",
          "size": 0.9912109375,
          "content": "## Contributing to Reflex\n\nThere are just a few simple guidelines for reporting issues or submitting\npatches.\n\n### Issues\n\n* For bugs:\n  - Make sure you're using the latest version of Reflex\n  - Describe the expected and actual behavior\n  - Include your operating system with the bug report\n* Feature requests are unlikely to be implemented unless you're willing to\n  contribute the code.\n\n### Pull Requests\n\n* For nontrivial new features, open an issue to describe the change first so we\n  can all be on the same page about whether it's a good fit for Reflex.\n  Tiny improvements and bug fixes don't need this.\n* Make a branch just for the bugfix/feature. Split it up into reasonably-sized\n  commits. Make one new branch/pull request for each logically distinct\n  bugfix/feature.\n* If you're not already on the list, add your name to the authors list in\n  README.md (in a commit by itself with your pull request).\n\n### Code style\n\n* Run `gofmt` on any code before committing.\n* Stick to the code style around you.\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.03515625,
          "content": "Copyright (c) 2013-2014 Caleb Spare\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 12.6552734375,
          "content": "# Reflex\n\nReflex is a small tool to watch a directory and rerun a command when certain\nfiles change. It's great for automatically running compile/lint/test tasks and\nfor reloading your application when the code changes.\n\n## A simple example\n\n    # Rerun make whenever a .c file changes\n    reflex -r '\\.c$' make\n\n## Installation\n\nYou can download binaries from the\n[Releases page](https://github.com/cespare/reflex/releases).\n\nTo compile from source, you'll need Go 1.13+ installed.\n\nIf you have Go 1.16 or later, you can download and install the latest module\nversion directly with\n\n    go install github.com/cespare/reflex@latest\n\nReflex is only tested on Linux and macOS.\n\n## Usage\n\nThe following is given by running `reflex -h`:\n\n```\nUsage: reflex [OPTIONS] [COMMAND]\n\nCOMMAND is any command you'd like to run. Any instance of {} will be replaced\nwith the filename of the changed file. (The symbol may be changed with the\n--substitute flag.)\n\nOPTIONS are given below:\n      --all=false:\n            Include normally ignored files (VCS and editor special files).\n  -c, --config=\"\":\n            A configuration file that describes how to run reflex\n            (or '-' to read the configuration from stdin).\n  -d, --decoration=\"plain\":\n            How to decorate command output. Choices: none, plain, fancy.\n  -g, --glob=[]:\n            A shell glob expression to match filenames. (May be repeated.)\n  -G, --inverse-glob=[]:\n            A shell glob expression to exclude matching filenames.\n            (May be repeated.)\n  -R, --inverse-regex=[]:\n            A regular expression to exclude matching filenames.\n            (May be repeated.)\n      --only-dirs=false:\n            Only match directories (not files).\n      --only-files=false:\n            Only match files (not directories).\n  -r, --regex=[]:\n            A regular expression to match filenames. (May be repeated.)\n  -e, --sequential=false:\n            Don't run multiple commands at the same time.\n  -t, --shutdown-timeout=500ms:\n            Allow services this long to shut down.\n  -s, --start-service=false:\n            Indicates that the command is a long-running process to be\n            restarted on matching changes.\n      --substitute=\"{}\":\n            The substitution symbol that is replaced with the filename\n            in a command.\n  -v, --verbose=false:\n            Verbose mode: print out more information about what reflex is doing.\n\nExamples:\n\n    # Print each .txt file if it changes\n    $ reflex -r '\\.txt$' echo {}\n\n    # Run 'make' if any of the .c files in this directory change:\n    $ reflex -g '*.c' make\n\n    # Build and run a server; rebuild and restart when .java files change:\n    $ reflex -r '\\.java$' -s -- sh -c 'make && java bin/Server'\n```\n\n### Overview\n\nReflex watches file changes in the current working directory and re-runs the\ncommand that you specify. The flags change what changes cause the command to be\nrerun and other behavior.\n\n### Patterns\n\nYou can specify files to match using either shell glob patterns (`-g`) or\nregular expressions (`-r`). If you don't specify either, reflex will run your\ncommand after any file changes. (Reflex ignores some common editor and version\ncontrol files; see Ignored files, below.)\n\nYou can specify inverse matches by using the `--inverse-glob` (`-G`) and\n`--inverse-regex` (`-R`) flags.\n\nIf you specify multiple globs/regexes (e.g. `-r foo -r bar -R baz -G x/*/y`),\nonly files that match all patterns and none of the inverse patterns are\nselected.\n\nThe shell glob syntax is described\n[here](http://golang.org/pkg/path/filepath/#Match), while the regular expression\nsyntax is described [here](https://code.google.com/p/re2/wiki/Syntax).\n\nThe path that is matched against the glob or regular expression does not have a\nleading `./`. For example, if there is a file `./foobar.txt` that changes, then\nit will be matched by the regular expression `^foobar`. If the path is a\ndirectory, it has a trailing `/`.\n\n### --start-service\n\nThe `--start-service` flag (short version: `-s`) inverts the behavior of command\nrunning: it runs the command when reflex starts and kills/restarts it each time\nfiles change. This is expected to be used with an indefinitely-running command,\nsuch as a server. You can use this flag to relaunch the server when the code is\nchanged.\n\n### Substitution\n\nReflex provides a way for you to determine, inside your command, what file\nchanged. This is via a substitution symbol. The default is `{}`. Every instance\nof the substitution symbol inside your command is replaced by the filename.\n\nAs a simple example, suppose you're writing Coffeescript and you wish to compile\nthe CS files to Javascript when they change. You can do this with:\n\n    reflex -r '\\.coffee$' -- coffee -c {}\n\nIn case you need to use `{}` for something else in your command, you can change\nthe substitution symbol with the `--substitute` flag.\n\n### Configuration file\n\nWhat if you want to run many watches at once? For example, when writing web\napplications I often want to rebuild/rerun the server when my code changes, but\nalso build SCSS and Coffeescript when those change as well. Instead of running\nmultiple reflex instances, which is cumbersome (and inefficient), you can give\nreflex a configuration file.\n\nThe configuration file syntax is simple: each line is a command, and each\ncommand is composed of flags and arguments -- just like calling reflex but\nwithout the initial `reflex`. Lines that start with `#` are ignored. Commands\ncan span multiple lines if they're \\\\-continued, or include multi-line strings.\nHere's an example:\n\n    # Rebuild SCSS when it changes\n    -r '\\.scss$' -- \\\n       sh -c 'sass {} `basename {} .scss`.css'\n\n    # Restart server when ruby code changes\n    -sr '\\.rb$' -- \\\n        ./bin/run_server.sh\n\nIf you want to change the configuration file and have reflex reload it on the\nfly, you can run reflex inside reflex:\n\n    reflex -s -g reflex.conf -- reflex -c reflex.conf\n\nThis tells reflex to run another reflex process as a service that's restarted\nwhenever `reflex.conf` changes.\n\n### --sequential\n\nWhen using a config file to run multiple simultaneous commands, reflex will run\nthem at the same time (if appropriate). That is, a particular command can only\nbe run once a previous run of that command finishes, but two different commands\nmay run at the same time. This is usually what you want (for speed).\n\nAs a concrete example, consider this config file:\n\n    -- sh -c 'for i in `seq 1 5`; do sleep 0.1; echo first; done'\n    -- sh -c 'for i in `seq 1 5`; do sleep 0.1; echo second; done'\n\nWhen this runs, you'll see something like this:\n\n    [01] second\n    [00] first\n    [01] second\n    [00] first\n    [00] first\n    [01] second\n    [01] second\n    [00] first\n    [01] second\n    [00] first\n\nNote that the output is interleaved. (Reflex does ensure that each line of\noutput is not interleaved with a different line.) If, for some reason, you need\nto ensure that your commands don't run at the same time, you can do this with\nthe `--sequential` (`-e`) flag. Then the output would look like (for example):\n\n    [01] second\n    [01] second\n    [01] second\n    [01] second\n    [01] second\n    [00] first\n    [00] first\n    [00] first\n    [00] first\n    [00] first\n\n### Decoration\n\nBy default, each line of output from your command is prefixed with something\nlike `[00]`, which is simply an id that reflex assigns to each command. You can\nuse `--decoration` (`-d`) to change this output: `--decoration=none` will print\nthe output as is; `--decoration=fancy` will color each line differently\ndepending on which command it is, making it easier to distinguish the output.\n\n### Ignored files\n\nReflex ignores a variety of version control and editor metadata files by\ndefault. If you wish for these to be included, you can provide reflex with the\n`--all` flag.\n\nYou can see a list of regular expressions that match the files that reflex\nignores by default\n[here](https://github.com/cespare/reflex/blob/master/defaultexclude.go#L5).\n\n## Notes and Tips\n\nIf you don't use `-r` or `-g`, reflex will match every file.\n\nReflex only considers file creation and modification changes. It does not report\nattribute changes nor deletions.\n\nFor ignoring directories, it's easiest to use a regular expression: `-R '^dir/'`.\n\nMany regex and glob characters are interpreted specially by various shells.\nYou'll generally want to minimize this effect by putting the regex and glob\npatterns in single quotes.\n\nIf your command has options, you'll probably need to use `--` to separate the\nreflex flags from your command flags. For example: `reflex -r '.*\\.txt' -- ls\n-l`.\n\nIf you're going to use shell things, you need to invoke a shell as a parent\nprocess:\n\n    reflex -- sh -c 'sleep 1 && echo {}'\n\nIf your command is running with sudo, you'll need a passwordless sudo, because\nyou cannot enter your password in through reflex.\n\nIt's not difficult to accidentally make an infinite loop with certain commands.\nFor example, consider this command: `reflex -r '\\.txt' cp {} {}.bak`. If\n`foo.txt` changes, then this will create `foo.txt.bak`, `foo.txt.bak.bak`, and\nso forth, because the regex `\\.txt` matches each file. Reflex doesn't have any\nkind of infinite loop detection, so be careful with commands like `cp`.\n\nThe restart behavior works as follows: if your program is still running, reflex\nsends it SIGINT; after 1 second if it's still alive, it gets SIGKILL. The new\nprocess won't be started up until the old process is dead.\n\n### Batching\n\nPart of what reflex does is apply some heuristics to batch together file\nchanges. There are many reasons that files change on disk, and these changes\nfrequently come in large bursts. For instance, when you save a file in your\neditor, it probably makes a tempfile and then copies it over the target, leading\nto several different changes. Reflex hides this from you by batching some\nchanges together.\n\nOne thing to note, though, is that the the batching is a little different\ndepending on whether or not you have a substitution symbol in your command. If\nyou do not, then updates for different files that all match your pattern can be\nbatched together in a single update that only causes your command to be run\nonce.\n\nIf you are using a substitution symbol, however, each unique matching file will\nbe batched separately.\n\n### Argument list splitting\n\nWhen you give reflex a command from the commandline (i.e., not in a config\nfile), that command is split into pieces by whatever shell you happen to be\nusing. When reflex parses the config file, however, it must do that splitting\nitself. For this purpose, it uses [this library](https://github.com/kballard/go-shellquote)\nwhich attempts to match `sh`'s argument splitting rules.\n\nThis difference can lead to slightly different behavior when running commands\nfrom a config file. If you're confused, it can help to use `--verbose` (`-v`)\nwhich will print out each command as interpreted by reflex.\n\n### Open file limits\n\nReflex currently must hold an open file descriptor for every directory it's\nwatching, recursively. If you run reflex at the top of a big directory tree, you\ncan easily run into file descriptor limits. You might see an error like this:\n\n    open some/path: too many open files\n\nThere are several things you can do to get around this problem.\n\n1. Run reflex in the most specific directory possible. Don't run\n   `reflex -g path/to/project/*.c ...` from `$HOME`; instead run reflex in\n   `path/to/project`.\n2. Ignore large subdirectories. Reflex already ignores, for instance, `.git/`.\n   If you have other large subdirectories, you can ignore those yourself:\n   `reflex -R '^third_party/' ...` ignores everything under `third_party/` in\n   your project directory.\n3. Raise the fd limit using `ulimit` or some other tool. On some systems, this\n   might default to a restrictively small value like 256.\n\nSee [issue #6](https://github.com/cespare/reflex/issues/6) for some more\nbackground on this issue.\n\n## The competition\n\n* https://github.com/guard/guard\n* https://github.com/alexch/rerun\n* https://github.com/mynyml/watchr\n* https://github.com/eaburns/Watch\n* https://github.com/alloy/kicker\n* https://github.com/eradman/entr\n\n### Why you should use reflex instead\n\n* Reflex has no dependencies. No need to install Ruby or anything like that.\n* Reflex uses an appropriate file watching mechanism to watch for changes\n  efficiently on your platform.\n* Reflex gives your command the name of the file that changed.\n* No DSL to learn -- just give it a shell command.\n* No plugins.\n* Not tied to any language, framework, workflow, or editor.\n\n## Authors\n\n* Benedikt Böhm ([hollow](https://github.com/hollow))\n* Caleb Spare ([cespare](https://github.com/cespare))\n* PJ Eby ([pjeby](https://github.com/pjeby))\n* Rich Liebling ([rliebling](https://github.com/rliebling))\n* Seth W. Klein ([sethwklein](https://github.com/sethwklein))\n* Vincent Vanackere ([vanackere](https://github.com/vanackere))\n"
        },
        {
          "name": "backlog.go",
          "type": "blob",
          "size": 2.384765625,
          "content": "package main\n\n// A Backlog represents a queue of file paths that may be received while we're\n// still running a command. There are a couple of different policies for how to\n// handle this. If there are no {} (substitution sequences) in the command, then\n// we only need to preserve one of the paths. If there is a {}, then we need to\n// preserve each unique path in the backlog.\ntype Backlog interface {\n\t// Add a path to the backlog.\n\tAdd(path string)\n\t// Show what path should be processed next.\n\tNext() string\n\t// Remove the next path from the backlog and return whether\n\t// the backlog is now empty.\n\tRemoveOne() (empty bool)\n}\n\n// A UnifiedBacklog only remembers one backlog item at a time.\ntype UnifiedBacklog struct {\n\ts     string\n\tempty bool\n}\n\nfunc NewUnifiedBacklog() *UnifiedBacklog {\n\treturn &UnifiedBacklog{empty: true}\n}\n\n// Add adds path to b if there is not a path there currently.\n// Otherwise it discards it.\nfunc (b *UnifiedBacklog) Add(path string) {\n\tif b.empty {\n\t\tb.s = path\n\t\tb.empty = false\n\t}\n}\n\n// Next returns the path in b.\nfunc (b *UnifiedBacklog) Next() string {\n\tif b.empty {\n\t\tpanic(\"Next() called on empty backlog\")\n\t}\n\treturn b.s\n}\n\n// RemoveOne removes the path in b.\nfunc (b *UnifiedBacklog) RemoveOne() bool {\n\tif b.empty {\n\t\tpanic(\"RemoveOne() called on empty backlog\")\n\t}\n\tb.empty = true\n\tb.s = \"\"\n\treturn true\n}\n\n// A UniqueFilesBacklog keeps a set of the paths it has received.\ntype UniqueFilesBacklog struct {\n\tempty bool\n\tnext  string\n\trest  map[string]struct{}\n}\n\nfunc NewUniqueFilesBacklog() *UniqueFilesBacklog {\n\treturn &UniqueFilesBacklog{\n\t\tempty: true,\n\t\tnext:  \"\",\n\t\trest:  make(map[string]struct{}),\n\t}\n}\n\n// Add adds path to the set of files in b.\nfunc (b *UniqueFilesBacklog) Add(path string) {\n\tdefer func() { b.empty = false }()\n\tif b.empty {\n\t\tb.next = path\n\t\treturn\n\t}\n\tif path == b.next {\n\t\treturn\n\t}\n\tb.rest[path] = struct{}{}\n}\n\n// Next returns one of the paths in b.\nfunc (b *UniqueFilesBacklog) Next() string {\n\tif b.empty {\n\t\tpanic(\"Next() called on empty backlog\")\n\t}\n\treturn b.next\n}\n\n// RemoveOne removes one of the paths from b (the same path that was returned by\n// a preceding call to Next).\nfunc (b *UniqueFilesBacklog) RemoveOne() bool {\n\tif b.empty {\n\t\tpanic(\"RemoveOne() called on empty backlog\")\n\t}\n\tif len(b.rest) == 0 {\n\t\tb.next = \"\"\n\t\tb.empty = true\n\t\treturn true\n\t}\n\tfor next := range b.rest {\n\t\tb.next = next\n\t\tbreak\n\t}\n\tdelete(b.rest, b.next)\n\treturn false\n}\n"
        },
        {
          "name": "backlog_test.go",
          "type": "blob",
          "size": 0.75,
          "content": "package main\n\nimport (\n\t\"reflect\"\n\t\"sort\"\n\t\"testing\"\n)\n\nfunc TestUnifiedBacklog(t *testing.T) {\n\tb := NewUnifiedBacklog()\n\tb.Add(\"foo\")\n\tb.Add(\"bar\")\n\tif got, want := b.Next(), \"foo\"; got != want {\n\t\tt.Errorf(\"Next(): got %q; want %q\", got, want)\n\t}\n\tif got := b.RemoveOne(); !got {\n\t\tt.Error(\"RemoveOne(): got !empty\")\n\t}\n}\n\nfunc TestUniqueFilesBacklog(t *testing.T) {\n\tb := NewUniqueFilesBacklog()\n\tb.Add(\"foo\")\n\tb.Add(\"bar\")\n\ts := []string{b.Next()}\n\tif got := b.RemoveOne(); got {\n\t\tt.Error(\"RemoveOne(): got empty\")\n\t}\n\ts = append(s, b.Next())\n\tif got := b.RemoveOne(); !got {\n\t\tt.Error(\"RemoveOne(): got !empty\")\n\t}\n\tsort.Strings(s)\n\tif want := []string{\"bar\", \"foo\"}; !reflect.DeepEqual(s, want) {\n\t\tt.Errorf(\"Next() result set: got %v; want %v\", s, want)\n\t}\n}\n"
        },
        {
          "name": "config.go",
          "type": "blob",
          "size": 4.44140625,
          "content": "package main\n\nimport (\n\t\"bufio\"\n\t\"fmt\"\n\t\"io\"\n\t\"io/ioutil\"\n\t\"os\"\n\t\"strings\"\n\t\"time\"\n\n\t\"github.com/kballard/go-shellquote\"\n\tflag \"github.com/ogier/pflag\"\n)\n\ntype Config struct {\n\tcommand         []string\n\tsource          string\n\tregexes         []string\n\tglobs           []string\n\tinverseRegexes  []string\n\tinverseGlobs    []string\n\tsubSymbol       string\n\tstartService    bool\n\tshutdownTimeout time.Duration\n\tonlyFiles       bool\n\tonlyDirs        bool\n\tallFiles        bool\n}\n\nfunc (c *Config) registerFlags(f *flag.FlagSet) {\n\tf.VarP(newMultiString(nil, &c.regexes), \"regex\", \"r\", `\n            A regular expression to match filenames. (May be repeated.)`)\n\tf.VarP(newMultiString(nil, &c.inverseRegexes), \"inverse-regex\", \"R\", `\n            A regular expression to exclude matching filenames.\n            (May be repeated.)`)\n\tf.VarP(newMultiString(nil, &c.globs), \"glob\", \"g\", `\n            A shell glob expression to match filenames. (May be repeated.)`)\n\tf.VarP(newMultiString(nil, &c.inverseGlobs), \"inverse-glob\", \"G\", `\n            A shell glob expression to exclude matching filenames.\n            (May be repeated.)`)\n\tf.StringVar(&c.subSymbol, \"substitute\", defaultSubSymbol, `\n            The substitution symbol that is replaced with the filename\n            in a command.`)\n\tf.BoolVarP(&c.startService, \"start-service\", \"s\", false, `\n            Indicates that the command is a long-running process to be\n            restarted on matching changes.`)\n\tf.DurationVarP(&c.shutdownTimeout, \"shutdown-timeout\", \"t\", 500*time.Millisecond, `\n            Allow services this long to shut down.`)\n\tf.BoolVar(&c.onlyFiles, \"only-files\", false, `\n            Only match files (not directories).`)\n\tf.BoolVar(&c.onlyDirs, \"only-dirs\", false, `\n            Only match directories (not files).`)\n\tf.BoolVar(&c.allFiles, \"all\", false, `\n            Include normally ignored files (VCS and editor special files).`)\n}\n\n// ReadConfigs reads configurations from either a file or, as a special case,\n// stdin if \"-\" is given for path.\nfunc ReadConfigs(path string) ([]*Config, error) {\n\tvar r io.Reader\n\tname := path\n\tif path == \"-\" {\n\t\tr = os.Stdin\n\t\tname = \"standard input\"\n\t} else {\n\t\tf, err := os.Open(flagConf)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tdefer f.Close()\n\t\tr = f\n\t}\n\treturn readConfigsFromReader(r, name)\n}\n\nfunc readConfigsFromReader(r io.Reader, name string) ([]*Config, error) {\n\tscanner := bufio.NewScanner(r)\n\tlineNo := 0\n\tvar configs []*Config\nparseFile:\n\tfor scanner.Scan() {\n\t\tlineNo++\n\t\t// Skip empty lines and comments (lines starting with #).\n\t\ttrimmed := strings.TrimSpace(scanner.Text())\n\t\tif len(trimmed) == 0 || strings.HasPrefix(trimmed, \"#\") {\n\t\t\tcontinue\n\t\t}\n\n\t\t// Found a command line; begin parsing it\n\t\terrorf := fmt.Sprintf(\"error on line %d of %s: %%s\", lineNo, name)\n\n\t\tc := &Config{}\n\t\tc.source = fmt.Sprintf(\"%s, line %d\", name, lineNo)\n\n\t\tline := scanner.Text()\n\t\tparts, err := shellquote.Split(line)\n\n\t\t// Loop while the input line ends with \\ or an unfinished quoted string\n\t\tfor err != nil {\n\t\t\tif err == shellquote.UnterminatedEscapeError {\n\t\t\t\t// Strip the trailing backslash\n\t\t\t\tline = line[:len(line)-1]\n\t\t\t}\n\t\t\tif !scanner.Scan() {\n\t\t\t\tif scanner.Err() != nil {\n\t\t\t\t\t// Error reading the file, not EOF, so return that\n\t\t\t\t\tbreak parseFile\n\t\t\t\t}\n\t\t\t\t// EOF, return the most recent error with the line where the command started\n\t\t\t\treturn nil, fmt.Errorf(errorf, err)\n\t\t\t}\n\t\t\t// append the next line and parse again\n\t\t\tlineNo++\n\t\t\tline += \"\\n\" + scanner.Text()\n\t\t\tparts, err = shellquote.Split(line)\n\t\t}\n\n\t\tflags := flag.NewFlagSet(\"\", flag.ContinueOnError)\n\t\tflags.SetOutput(ioutil.Discard)\n\t\tc.registerFlags(flags)\n\t\tif err := flags.Parse(parts); err != nil {\n\t\t\treturn nil, fmt.Errorf(errorf, err)\n\t\t}\n\t\tc.command = flags.Args()\n\t\tconfigs = append(configs, c)\n\t}\n\tif err := scanner.Err(); err != nil {\n\t\treturn nil, fmt.Errorf(\"error reading config from %s: %s\", name, err)\n\t}\n\treturn configs, nil\n}\n\n// A multiString is a flag.Getter which collects repeated string flags.\ntype multiString struct {\n\tvals *[]string\n\tset  bool // If false, then vals contains the defaults.\n}\n\nfunc newMultiString(vals []string, p *[]string) *multiString {\n\t*p = vals\n\treturn &multiString{vals: p}\n}\n\nfunc (s *multiString) Set(val string) error {\n\tif s.set {\n\t\t*s.vals = append(*s.vals, val)\n\t} else {\n\t\t*s.vals = []string{val}\n\t\ts.set = true\n\t}\n\treturn nil\n}\n\nfunc (s *multiString) Get() interface{} {\n\treturn s.vals\n}\n\nfunc (s *multiString) String() string {\n\treturn fmt.Sprintf(\"[%s]\", strings.Join(*s.vals, \" \"))\n}\n"
        },
        {
          "name": "config_test.go",
          "type": "blob",
          "size": 2.0537109375,
          "content": "package main\n\nimport (\n\t\"reflect\"\n\t\"strings\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/kr/pretty\"\n)\n\nfunc TestReadConfigs(t *testing.T) {\n\tconst in = `-g '*.go' echo {}\n\n# Some comment here\n-r '^a[0-9]+\\.txt$' --only-dirs --substitute='[]' echo []\n\n-g '*.go' -s --only-files echo hi\n\n-r foo -r bar -R baz -g a \\\n\t-G b -G c echo \"hello\nworld\"\n`\n\n\tgot, err := readConfigsFromReader(strings.NewReader(in), \"test input\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\twant := []*Config{\n\t\t{\n\t\t\tcommand:         []string{\"echo\", \"{}\"},\n\t\t\tsource:          \"test input, line 1\",\n\t\t\tglobs:           []string{\"*.go\"},\n\t\t\tsubSymbol:       \"{}\",\n\t\t\tshutdownTimeout: 500 * time.Millisecond,\n\t\t},\n\t\t{\n\t\t\tcommand:         []string{\"echo\", \"[]\"},\n\t\t\tsource:          \"test input, line 4\",\n\t\t\tregexes:         []string{`^a[0-9]+\\.txt$`},\n\t\t\tsubSymbol:       \"[]\",\n\t\t\tshutdownTimeout: 500 * time.Millisecond,\n\t\t\tonlyDirs:        true,\n\t\t},\n\t\t{\n\t\t\tcommand:         []string{\"echo\", \"hi\"},\n\t\t\tsource:          \"test input, line 6\",\n\t\t\tglobs:           []string{\"*.go\"},\n\t\t\tsubSymbol:       \"{}\",\n\t\t\tstartService:    true,\n\t\t\tshutdownTimeout: 500 * time.Millisecond,\n\t\t\tonlyFiles:       true,\n\t\t},\n\t\t{\n\t\t\tcommand:         []string{\"echo\", \"hello\\nworld\"},\n\t\t\tsource:          \"test input, line 8\",\n\t\t\tregexes:         []string{\"foo\", \"bar\"},\n\t\t\tglobs:           []string{\"a\"},\n\t\t\tinverseRegexes:  []string{\"baz\"},\n\t\t\tinverseGlobs:    []string{\"b\", \"c\"},\n\t\t\tsubSymbol:       \"{}\",\n\t\t\tshutdownTimeout: 500 * time.Millisecond,\n\t\t},\n\t}\n\tif !reflect.DeepEqual(got, want) {\n\t\tt.Errorf(\"readConfigsFromReader: got diffs:\\n%s\",\n\t\t\tstrings.Join(pretty.Diff(got, want), \"\\n\"))\n\t}\n}\n\nfunc TestReadConfigsBad(t *testing.T) {\n\tfor _, in := range []string{\n\t\t\"\",\n\t\t\"--abc echo hi\",\n\t\t\"-g '*.go'\",\n\t\t\"--substitute='' echo hi\",\n\t\t\"-s echo {}\",\n\t\t\"--only-files --only-dirs echo hi\",\n\t} {\n\t\tr := strings.NewReader(in)\n\t\tif configs, err := readConfigsFromReader(r, \"test input\"); err == nil {\n\t\t\tfor _, config := range configs {\n\t\t\t\tif _, err := NewReflex(config); err == nil {\n\t\t\t\t\tt.Errorf(\"readConfigsFromReader(%q): got nil error\", in)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n"
        },
        {
          "name": "defaultexclude.go",
          "type": "blob",
          "size": 0.408203125,
          "content": "package main\n\nimport \"regexp\"\n\nvar defaultExcludes = []string{\n\t// VCS dirs\n\t`(^|/)\\.git/`,\n\t`(^|/)\\.hg/`,\n\t// Vim\n\t`~$`,\n\t`\\.swp$`,\n\t// Emacs\n\t`\\.#`,\n\t`(^|/)#.*#$`,\n\t// OS X\n\t`(^|/)\\.DS_Store$`,\n}\n\nvar defaultExcludeMatcher multiMatcher\n\nfunc init() {\n\tfor _, pattern := range defaultExcludes {\n\t\tm := newRegexMatcher(regexp.MustCompile(pattern), true)\n\t\tdefaultExcludeMatcher = append(defaultExcludeMatcher, m)\n\t}\n}\n"
        },
        {
          "name": "go.mod",
          "type": "blob",
          "size": 0.310546875,
          "content": "module github.com/cespare/reflex\n\ngo 1.15\n\nrequire (\n\tgithub.com/creack/pty v1.1.11\n\tgithub.com/fsnotify/fsnotify v1.4.7\n\tgithub.com/kballard/go-shellquote v0.0.0-20180428030007-95032a82bc51\n\tgithub.com/kr/pretty v0.1.0\n\tgithub.com/ogier/pflag v0.0.1\n\tgolang.org/x/sys v0.0.0-20180909124046-d0be0721c37e // indirect\n)\n"
        },
        {
          "name": "go.sum",
          "type": "blob",
          "size": 1.3115234375,
          "content": "github.com/creack/pty v1.1.11 h1:07n33Z8lZxZ2qwegKbObQohDhXDQxiMMz1NOUGYlesw=\ngithub.com/creack/pty v1.1.11/go.mod h1:oKZEueFk5CKHvIhNR5MUki03XCEU+Q6VDXinZuGJ33E=\ngithub.com/fsnotify/fsnotify v1.4.7 h1:IXs+QLmnXW2CcXuY+8Mzv/fWEsPGWxqefPtCP5CnV9I=\ngithub.com/fsnotify/fsnotify v1.4.7/go.mod h1:jwhsz4b93w/PPRr/qN1Yymfu8t87LnFCMoQvtojpjFo=\ngithub.com/kballard/go-shellquote v0.0.0-20180428030007-95032a82bc51 h1:Z9n2FFNUXsshfwJMBgNA0RU6/i7WVaAegv3PtuIHPMs=\ngithub.com/kballard/go-shellquote v0.0.0-20180428030007-95032a82bc51/go.mod h1:CzGEWj7cYgsdH8dAjBGEr58BoE7ScuLd+fwFZ44+/x8=\ngithub.com/kr/pretty v0.1.0 h1:L/CwN0zerZDmRFUapSPitk6f+Q3+0za1rQkzVuMiMFI=\ngithub.com/kr/pretty v0.1.0/go.mod h1:dAy3ld7l9f0ibDNOQOHHMYYIIbhfbHSm3C4ZsoJORNo=\ngithub.com/kr/pty v1.1.1/go.mod h1:pFQYn66WHrOpPYNljwOMqo10TkYh1fy3cYio2l3bCsQ=\ngithub.com/kr/text v0.1.0 h1:45sCR5RtlFHMR4UwH9sdQ5TC8v0qDQCHnXt+kaKSTVE=\ngithub.com/kr/text v0.1.0/go.mod h1:4Jbv+DJW3UT/LiOwJeYQe1efqtUx/iVham/4vfdArNI=\ngithub.com/ogier/pflag v0.0.1 h1:RW6JSWSu/RkSatfcLtogGfFgpim5p7ARQ10ECk5O750=\ngithub.com/ogier/pflag v0.0.1/go.mod h1:zkFki7tvTa0tafRvTBIZTvzYyAu6kQhPZFnshFFPE+g=\ngolang.org/x/sys v0.0.0-20180909124046-d0be0721c37e h1:o3PsSEY8E4eXWkXrIP9YJALUkVZqzHJT5DOasTyn8Vs=\ngolang.org/x/sys v0.0.0-20180909124046-d0be0721c37e/go.mod h1:STP8DvDyc/dI5b8T5hshtkjS+E42TnysNCUPdjciGhY=\n"
        },
        {
          "name": "main.go",
          "type": "blob",
          "size": 4.85546875,
          "content": "package main\n\nimport (\n\t\"fmt\"\n\t\"log\"\n\t\"os\"\n\t\"os/signal\"\n\t\"strings\"\n\t\"sync\"\n\t\"syscall\"\n\t\"time\"\n\n\t\"github.com/fsnotify/fsnotify\"\n\tflag \"github.com/ogier/pflag\"\n)\n\nconst defaultSubSymbol = \"{}\"\n\nvar (\n\treflexes []*Reflex\n\n\tflagConf       string\n\tflagSequential bool\n\tflagDecoration string\n\tdecoration     Decoration\n\tverbose        bool\n\tglobalFlags    = flag.NewFlagSet(\"\", flag.ContinueOnError)\n\tglobalConfig   = &Config{}\n\n\treflexID = 0\n\tstdout   = make(chan OutMsg, 1)\n\n\tcleanupMu = &sync.Mutex{}\n)\n\nfunc usage() {\n\tfmt.Fprintf(os.Stderr, `Usage: %s [OPTIONS] [COMMAND]\n\nCOMMAND is any command you'd like to run. Any instance of {} will be replaced\nwith the filename of the changed file. (The symbol may be changed with the\n--substitute flag.)\n\nOPTIONS are given below:\n`, os.Args[0])\n\n\tglobalFlags.PrintDefaults()\n\n\tfmt.Fprint(os.Stderr, `\nExamples:\n\n    # Print each .txt file if it changes\n    $ reflex -r '\\.txt$' echo {}\n\n    # Run 'make' if any of the .c files in this directory change:\n    $ reflex -g '*.c' make\n\n    # Build and run a server; rebuild and restart when .java files change:\n    $ reflex -r '\\.java$' -s -- sh -c 'make && java bin/Server'\n\n`)\n}\n\nfunc init() {\n\tglobalFlags.Usage = usage\n\tglobalFlags.StringVarP(&flagConf, \"config\", \"c\", \"\", `\n            A configuration file that describes how to run reflex\n            (or '-' to read the configuration from stdin).`)\n\tglobalFlags.BoolVarP(&verbose, \"verbose\", \"v\", false, `\n            Verbose mode: print out more information about what reflex is doing.`)\n\tglobalFlags.BoolVarP(&flagSequential, \"sequential\", \"e\", false, `\n            Don't run multiple commands at the same time.`)\n\tglobalFlags.StringVarP(&flagDecoration, \"decoration\", \"d\", \"plain\", `\n            How to decorate command output. Choices: none, plain, fancy.`)\n\tglobalConfig.registerFlags(globalFlags)\n}\n\nfunc anyNonGlobalsRegistered() bool {\n\tany := false\n\twalkFn := func(f *flag.Flag) {\n\t\tswitch f.Name {\n\t\tcase \"config\", \"verbose\", \"sequential\", \"decoration\":\n\t\tdefault:\n\t\t\tany = true\n\t\t}\n\t}\n\tglobalFlags.Visit(walkFn)\n\treturn any\n}\n\nfunc printGlobals() {\n\tfmt.Println(\"Globals set at commandline\")\n\twalkFn := func(f *flag.Flag) {\n\t\tfmt.Printf(\"| --%s (-%s) '%s' (default: '%s')\\n\",\n\t\t\tf.Name, f.Shorthand, f.Value, f.DefValue)\n\t}\n\tglobalFlags.Visit(walkFn)\n\tfmt.Println(\"+---------\")\n}\n\nfunc cleanup(reason string) {\n\tcleanupMu.Lock()\n\tfmt.Println(reason)\n\twg := &sync.WaitGroup{}\n\tfor _, reflex := range reflexes {\n\t\tif reflex.Running() {\n\t\t\twg.Add(1)\n\t\t\tgo func(reflex *Reflex) {\n\t\t\t\treflex.terminate()\n\t\t\t\twg.Done()\n\t\t\t}(reflex)\n\t\t}\n\t}\n\twg.Wait()\n\t// Give just a little time to finish printing output.\n\ttime.Sleep(10 * time.Millisecond)\n\tos.Exit(0)\n}\n\nfunc main() {\n\tlog.SetFlags(0)\n\tif err := globalFlags.Parse(os.Args[1:]); err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tglobalConfig.command = globalFlags.Args()\n\tglobalConfig.source = \"[commandline]\"\n\tif verbose {\n\t\tprintGlobals()\n\t}\n\tswitch strings.ToLower(flagDecoration) {\n\tcase \"none\":\n\t\tdecoration = DecorationNone\n\tcase \"plain\":\n\t\tdecoration = DecorationPlain\n\tcase \"fancy\":\n\t\tdecoration = DecorationFancy\n\tdefault:\n\t\tlog.Fatalf(\"Invalid decoration %s. Choices: none, plain, fancy.\", flagDecoration)\n\t}\n\n\tvar configs []*Config\n\tif flagConf == \"\" {\n\t\tif flagSequential {\n\t\t\tlog.Fatal(\"Cannot set --sequential without --config (because you cannot specify multiple commands).\")\n\t\t}\n\t\tconfigs = []*Config{globalConfig}\n\t} else {\n\t\tif anyNonGlobalsRegistered() {\n\t\t\tlog.Fatal(\"Cannot set other flags along with --config other than --sequential, --verbose, and --decoration.\")\n\t\t}\n\t\tvar err error\n\t\tconfigs, err = ReadConfigs(flagConf)\n\t\tif err != nil {\n\t\t\tlog.Fatalln(\"Could not parse configs:\", err)\n\t\t}\n\t\tif len(configs) == 0 {\n\t\t\tlog.Fatal(\"No configurations found\")\n\t\t}\n\t}\n\n\tfor _, config := range configs {\n\t\treflex, err := NewReflex(config)\n\t\tif err != nil {\n\t\t\tlog.Fatalln(\"Could not make reflex for config:\", err)\n\t\t}\n\t\tif verbose {\n\t\t\tfmt.Println(reflex)\n\t\t}\n\t\treflexes = append(reflexes, reflex)\n\t}\n\n\t// Catch ctrl-c and make sure to kill off children.\n\tsignals := make(chan os.Signal, 1)\n\tsignal.Notify(signals, os.Interrupt)\n\tsignal.Notify(signals, os.Signal(syscall.SIGTERM))\n\tgo func() {\n\t\ts := <-signals\n\t\treason := fmt.Sprintf(\"Interrupted (%s). Cleaning up children...\", s)\n\t\tcleanup(reason)\n\t}()\n\tdefer cleanup(\"Cleaning up.\")\n\n\twatcher, err := fsnotify.NewWatcher()\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tdefer watcher.Close()\n\n\tchanges := make(chan string)\n\tbroadcastChanges := make([]chan string, len(reflexes))\n\tdone := make(chan error)\n\tfor i := range reflexes {\n\t\tbroadcastChanges[i] = make(chan string)\n\t}\n\tgo watch(\".\", watcher, changes, done, reflexes)\n\tgo broadcast(broadcastChanges, changes)\n\tgo printOutput(stdout, os.Stdout)\n\n\tfor i, reflex := range reflexes {\n\t\treflex.Start(broadcastChanges[i])\n\t}\n\n\tlog.Fatal(<-done)\n}\n\nfunc broadcast(outs []chan string, in <-chan string) {\n\tfor e := range in {\n\t\tfor _, out := range outs {\n\t\t\tout <- e\n\t\t}\n\t}\n}\n"
        },
        {
          "name": "match.go",
          "type": "blob",
          "size": 5.1103515625,
          "content": "package main\n\nimport (\n\t\"fmt\"\n\t\"path/filepath\"\n\t\"regexp\"\n\t\"regexp/syntax\"\n\t\"strings\"\n\t\"sync\"\n)\n\n// A Matcher decides whether some filename matches its set of patterns.\ntype Matcher interface {\n\t// Match returns whether a filename matches.\n\tMatch(name string) bool\n\t// ExcludePrefix returns whether all paths with this prefix cannot match.\n\t// It is allowed to return false negatives but not false positives.\n\t// This is used as an optimization for skipping directory watches with\n\t// inverted matches.\n\tExcludePrefix(prefix string) bool\n\tString() string\n}\n\n// ParseMatchers combines multiple (possibly inverse) regex and glob patterns\n// into a single Matcher.\nfunc ParseMatchers(regexes, inverseRegexes, globs, inverseGlobs []string) (m Matcher, err error) {\n\tvar matchers multiMatcher\n\tif len(regexes) == 0 && len(globs) == 0 {\n\t\tmatchers = multiMatcher{matchAll{}}\n\t}\n\tfor _, r := range regexes {\n\t\tregex, err := regexp.Compile(r)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tmatchers = append(matchers, newRegexMatcher(regex, false))\n\t}\n\tfor _, r := range inverseRegexes {\n\t\tregex, err := regexp.Compile(r)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tmatchers = append(matchers, newRegexMatcher(regex, true))\n\t}\n\tfor _, g := range globs {\n\t\tmatchers = append(matchers, &globMatcher{glob: g})\n\t}\n\tfor _, g := range inverseGlobs {\n\t\tmatchers = append(matchers, &globMatcher{\n\t\t\tglob:    g,\n\t\t\tinverse: true,\n\t\t})\n\t}\n\treturn matchers, nil\n}\n\n// matchAll is an all-accepting Matcher.\ntype matchAll struct{}\n\nfunc (matchAll) Match(name string) bool           { return true }\nfunc (matchAll) ExcludePrefix(prefix string) bool { return false }\nfunc (matchAll) String() string                   { return \"(Implicitly matching all non-excluded files)\" }\n\ntype globMatcher struct {\n\tglob    string\n\tinverse bool\n}\n\nfunc (m *globMatcher) Match(name string) bool {\n\tmatches, err := filepath.Match(m.glob, name)\n\tif err != nil {\n\t\treturn false\n\t}\n\treturn matches != m.inverse\n}\n\nfunc (m *globMatcher) ExcludePrefix(prefix string) bool { return false }\n\nfunc (m *globMatcher) String() string {\n\ts := \"Glob\"\n\tif m.inverse {\n\t\ts = \"Inverted glob\"\n\t}\n\treturn fmt.Sprintf(\"%s match: %q\", s, m.glob)\n}\n\ntype regexMatcher struct {\n\tregex   *regexp.Regexp\n\tinverse bool\n\n\tmu               *sync.Mutex // protects following\n\tcanExcludePrefix bool        // This regex has no $, \\z, or \\b -- see ExcludePrefix\n\texcludeChecked   bool\n}\n\nfunc (m *regexMatcher) Match(name string) bool {\n\treturn m.regex.MatchString(name) != m.inverse\n}\n\nfunc newRegexMatcher(regex *regexp.Regexp, inverse bool) *regexMatcher {\n\treturn &regexMatcher{\n\t\tregex:   regex,\n\t\tinverse: inverse,\n\t\tmu:      new(sync.Mutex),\n\t}\n}\n\n// ExcludePrefix returns whether this matcher cannot possibly match any path\n// with a particular prefix. The question is: given a regex r and some prefix p\n// which r accepts, is there any string s that has p as a prefix that r does not\n// accept?\n//\n// With a classic regular expression from CS, this can only be the case if r\n// ends with $, the end-of-input token (because once the NFA is in an accepting\n// state, adding more input will not change that). In Go's regular expressions,\n// I think the only way to construct a regex that would not meet this criteria\n// is by using zero-width lookahead. There is no arbitrary lookahead in Go, so\n// the only zero-width lookahead is provided by $, \\z, and \\b. For instance, the\n// following regular expressions match the \"foo\", but not \"foobar\":\n//\n//   foo$\n//   foo\\b\n//   (foo$)|(baz$)\n//\n// Thus, to choose whether we can exclude this prefix, m must be an inverse\n// matcher that does not contain the zero-width ops $, \\z, and \\b.\nfunc (m *regexMatcher) ExcludePrefix(prefix string) bool {\n\tif !m.inverse {\n\t\treturn false\n\t}\n\tif !m.regex.MatchString(prefix) || m.regex.String() == \"\" {\n\t\treturn false\n\t}\n\n\tm.mu.Lock()\n\tdefer m.mu.Unlock()\n\tif !m.excludeChecked {\n\t\tr, err := syntax.Parse(m.regex.String(), syntax.Perl)\n\t\tif err != nil {\n\t\t\tpanic(\"Cannot compile regex, but it was previously compiled!?!\")\n\t\t}\n\t\tr = r.Simplify()\n\t\tstack := []*syntax.Regexp{r}\n\t\tfor len(stack) > 0 {\n\t\t\tcur := stack[len(stack)-1]\n\t\t\tstack = stack[:len(stack)-1]\n\t\t\tswitch cur.Op {\n\t\t\tcase syntax.OpEndLine, syntax.OpEndText, syntax.OpWordBoundary:\n\t\t\t\tm.canExcludePrefix = false\n\t\t\t\tgoto after\n\t\t\t}\n\t\t\tif cur.Sub0[0] != nil {\n\t\t\t\tstack = append(stack, cur.Sub0[0])\n\t\t\t}\n\t\t\tstack = append(stack, cur.Sub...)\n\t\t}\n\t\tm.canExcludePrefix = true\n\tafter:\n\t\tm.excludeChecked = true\n\t}\n\treturn m.canExcludePrefix\n}\n\nfunc (m *regexMatcher) String() string {\n\ts := \"Regex\"\n\tif m.inverse {\n\t\ts = \"Inverted regex\"\n\t}\n\treturn fmt.Sprintf(\"%s match: %q\", s, m.regex.String())\n}\n\n// A multiMatcher returns the logical AND of its sub-matchers.\ntype multiMatcher []Matcher\n\nfunc (m multiMatcher) Match(name string) bool {\n\tfor _, matcher := range m {\n\t\tif !matcher.Match(name) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\nfunc (m multiMatcher) ExcludePrefix(prefix string) bool {\n\tfor _, matcher := range m {\n\t\tif matcher.ExcludePrefix(prefix) {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\nfunc (m multiMatcher) String() string {\n\tvar s []string\n\tfor _, matcher := range m {\n\t\ts = append(s, matcher.String())\n\t}\n\treturn strings.Join(s, \"\\n\")\n}\n"
        },
        {
          "name": "match_test.go",
          "type": "blob",
          "size": 2.5087890625,
          "content": "package main\n\nimport (\n\t\"regexp\"\n\t\"testing\"\n)\n\nfunc TestMatchers(t *testing.T) {\n\tvar (\n\t\tglob    = &globMatcher{glob: \"foo*\"}\n\t\tglobInv = &globMatcher{glob: \"foo*\", inverse: true}\n\n\t\tregex    = newRegexMatcher(regexp.MustCompile(\"foo.*\"), false)\n\t\tregexInv = newRegexMatcher(regexp.MustCompile(\"foo.*\"), true)\n\n\t\tmulti = multiMatcher{\n\t\t\tnewRegexMatcher(regexp.MustCompile(\"foo\"), false),\n\t\t\tnewRegexMatcher(regexp.MustCompile(`\\.go$`), false),\n\t\t\tnewRegexMatcher(regexp.MustCompile(\"foobar\"), true),\n\t\t}\n\t)\n\tfor _, tt := range []struct {\n\t\tm    Matcher\n\t\ts    string\n\t\twant bool\n\t}{\n\t\t{glob, \"foo\", true},\n\t\t{glob, \"foobar\", true},\n\t\t{glob, \"bar\", false},\n\t\t{globInv, \"foo\", false},\n\t\t{globInv, \"foobar\", false},\n\t\t{globInv, \"bar\", true},\n\n\t\t{regex, \"foo\", true},\n\t\t{regex, \"foobar\", true},\n\t\t{regex, \"bar\", false},\n\t\t{regexInv, \"foo\", false},\n\t\t{regexInv, \"foobar\", false},\n\t\t{regexInv, \"bar\", true},\n\n\t\t{multi, \"foo.go\", true},\n\t\t{multi, \"foo/bar.go\", true},\n\t\t{multi, \"foobar/blah.go\", false},\n\t} {\n\t\tif got := tt.m.Match(tt.s); got != tt.want {\n\t\t\tt.Errorf(\"(%v).Match(%q): got %t; want %t\",\n\t\t\t\ttt.m, tt.s, got, tt.want)\n\t\t}\n\t}\n}\n\nfunc TestExcludePrefix(t *testing.T) {\n\tm := newRegexMatcher(regexp.MustCompile(\"foo\"), false)\n\tif m.ExcludePrefix(\"bar\") {\n\t\tt.Error(\"m.ExcludePrefix gave true for a non-inverted matcher\")\n\t}\n\n\tfor _, tt := range []struct {\n\t\tre     string\n\t\tprefix string\n\t\twant   bool\n\t}{\n\t\t{\"foo\", \"foo\", true},\n\t\t{\"((foo{3,4})|abc*)+|foo\", \"foo\", true},\n\t\t{\"foo$\", \"foo\", false},\n\t\t{`foo\\b`, \"foo\", false},\n\t\t{`(foo\\b)|(baz$)`, \"foo\", false},\n\t} {\n\t\tm := newRegexMatcher(regexp.MustCompile(tt.re), true)\n\t\tif got := m.ExcludePrefix(tt.prefix); got != tt.want {\n\t\t\tt.Errorf(\"(%v).ExcludePrefix(%q): got %t; want %t\",\n\t\t\t\tm, tt.prefix, got, tt.want)\n\t\t}\n\t}\n}\n\nfunc TestDefaultExcludes(t *testing.T) {\n\tfor _, tt := range []struct {\n\t\tname string\n\t\twant bool\n\t}{\n\t\t{\".git/HEAD\", false},\n\t\t{\"foo.git\", true},\n\t\t{\"foo/bar.git\", true},\n\t\t{\"foo/bar/.git/HEAD\", false},\n\t\t{\"foo~\", false},\n\t\t{\"foo/bar~\", false},\n\t\t{\"~foo\", true},\n\t\t{\"foo~bar\", true},\n\t\t{\"foo.swp\", false},\n\t\t{\"foo.swp.bar\", true},\n\t\t{\"foo/bar.swp\", false},\n\t\t{\"foo.#123\", false},\n\t\t{\"foo#123\", true},\n\t\t{\"foo/bar.#123\", false},\n\t\t{\"#foo#\", false},\n\t\t{\"foo/#bar#\", false},\n\t\t{\".DS_Store\", false},\n\t\t{\"foo/.DS_Store\", false},\n\t} {\n\t\tif got := defaultExcludeMatcher.Match(tt.name); got != tt.want {\n\t\t\tif got {\n\t\t\t\tt.Errorf(\"%q was excluded by the default excludes matcher\", tt.name)\n\t\t\t} else {\n\t\t\t\tt.Errorf(\"%q was not excluded by the default excludes matcher\", tt.name)\n\t\t\t}\n\t\t}\n\t}\n}\n"
        },
        {
          "name": "print.go",
          "type": "blob",
          "size": 1.2626953125,
          "content": "package main\n\nimport (\n\t\"fmt\"\n\t\"io\"\n\t\"strings\"\n)\n\ntype Decoration int\n\nconst (\n\tDecorationNone = iota\n\tDecorationPlain\n\tDecorationFancy\n)\n\nconst (\n\tcolorRed = 31\n\t// ANSI colors -- using 32 - 36\n\tcolorStart = 32\n\tnumColors  = 5\n)\n\ntype OutMsg struct {\n\treflexID int\n\tmsg      string\n}\n\nfunc infoPrintln(id int, args ...interface{}) {\n\tstdout <- OutMsg{id, strings.TrimSpace(fmt.Sprintln(args...))}\n}\nfunc infoPrintf(id int, format string, args ...interface{}) {\n\tstdout <- OutMsg{id, fmt.Sprintf(format, args...)}\n}\n\nfunc printMsg(msg OutMsg, writer io.Writer) {\n\ttag := \"\"\n\tif decoration == DecorationFancy || decoration == DecorationPlain {\n\t\tif msg.reflexID < 0 {\n\t\t\ttag = \"[info]\"\n\t\t} else {\n\t\t\ttag = fmt.Sprintf(\"[%02d]\", msg.reflexID)\n\t\t}\n\t}\n\n\tif decoration == DecorationFancy {\n\t\tcolor := (msg.reflexID % numColors) + colorStart\n\t\tif reflexID < 0 {\n\t\t\tcolor = colorRed\n\t\t}\n\t\tfmt.Fprintf(writer, \"\\x1b[01;%dm%s \", color, tag)\n\t} else if decoration == DecorationPlain {\n\t\tfmt.Fprintf(writer, tag+\" \")\n\t}\n\tfmt.Fprint(writer, msg.msg)\n\tif decoration == DecorationFancy {\n\t\tfmt.Fprintf(writer, \"\\x1b[m\")\n\t}\n\tif !strings.HasSuffix(msg.msg, \"\\n\") {\n\t\tfmt.Fprintln(writer)\n\t}\n}\n\nfunc printOutput(out <-chan OutMsg, outWriter io.Writer) {\n\tfor msg := range out {\n\t\tprintMsg(msg, outWriter)\n\t}\n}\n"
        },
        {
          "name": "reflex.go",
          "type": "blob",
          "size": 8.189453125,
          "content": "package main\n\nimport (\n\t\"bufio\"\n\t\"bytes\"\n\t\"errors\"\n\t\"fmt\"\n\t\"os\"\n\t\"os/exec\"\n\t\"os/signal\"\n\t\"strings\"\n\t\"sync\"\n\t\"syscall\"\n\t\"time\"\n\n\t\"github.com/creack/pty\"\n)\n\n// A Reflex is a single watch + command to execute.\ntype Reflex struct {\n\tid           int\n\tsource       string // Describes what config/line defines this Reflex\n\tstartService bool\n\tbacklog      Backlog\n\tmatcher      Matcher\n\tonlyFiles    bool\n\tonlyDirs     bool\n\tcommand      []string\n\tsubSymbol    string\n\tdone         chan struct{}\n\n\tmu      *sync.Mutex // protects killed and running\n\tkilled  bool\n\trunning bool\n\ttimeout time.Duration\n\n\t// Used for services (startService = true)\n\tcmd *exec.Cmd\n\ttty *os.File\n}\n\n// NewReflex prepares a Reflex from a Config, with sanity checking.\nfunc NewReflex(c *Config) (*Reflex, error) {\n\tmatcher, err := ParseMatchers(c.regexes, c.inverseRegexes, c.globs, c.inverseGlobs)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"error parsing glob/regex: %s\", err)\n\t}\n\tif !c.allFiles {\n\t\tmatcher = multiMatcher{defaultExcludeMatcher, matcher}\n\t}\n\tif len(c.command) == 0 {\n\t\treturn nil, errors.New(\"must give command to execute\")\n\t}\n\n\tif c.subSymbol == \"\" {\n\t\treturn nil, errors.New(\"substitution symbol must be non-empty\")\n\t}\n\n\tsubstitution := false\n\tfor _, part := range c.command {\n\t\tif strings.Contains(part, c.subSymbol) {\n\t\t\tsubstitution = true\n\t\t\tbreak\n\t\t}\n\t}\n\n\tvar backlog Backlog\n\tif substitution {\n\t\tif c.startService {\n\t\t\treturn nil, errors.New(\"using --start-service does not work with a command that has a substitution symbol\")\n\t\t}\n\t\tbacklog = NewUniqueFilesBacklog()\n\t} else {\n\t\tbacklog = NewUnifiedBacklog()\n\t}\n\n\tif c.onlyFiles && c.onlyDirs {\n\t\treturn nil, errors.New(\"cannot specify both --only-files and --only-dirs\")\n\t}\n\n\tif c.shutdownTimeout <= 0 {\n\t\treturn nil, errors.New(\"shutdown timeout cannot be <= 0\")\n\t}\n\n\treflex := &Reflex{\n\t\tid:           reflexID,\n\t\tsource:       c.source,\n\t\tstartService: c.startService,\n\t\tbacklog:      backlog,\n\t\tmatcher:      matcher,\n\t\tonlyFiles:    c.onlyFiles,\n\t\tonlyDirs:     c.onlyDirs,\n\t\tcommand:      c.command,\n\t\tsubSymbol:    c.subSymbol,\n\t\tdone:         make(chan struct{}),\n\t\ttimeout:      c.shutdownTimeout,\n\t\tmu:           &sync.Mutex{},\n\t}\n\treflexID++\n\n\treturn reflex, nil\n}\n\nfunc (r *Reflex) String() string {\n\tvar buf bytes.Buffer\n\tfmt.Fprintln(&buf, \"Reflex from\", r.source)\n\tfmt.Fprintln(&buf, \"| ID:\", r.id)\n\tfor _, matcherInfo := range strings.Split(r.matcher.String(), \"\\n\") {\n\t\tfmt.Fprintln(&buf, \"|\", matcherInfo)\n\t}\n\tif r.onlyFiles {\n\t\tfmt.Fprintln(&buf, \"| Only matching files.\")\n\t} else if r.onlyDirs {\n\t\tfmt.Fprintln(&buf, \"| Only matching directories.\")\n\t}\n\tif !r.startService {\n\t\tfmt.Fprintln(&buf, \"| Substitution symbol\", r.subSymbol)\n\t}\n\treplacer := strings.NewReplacer(r.subSymbol, \"<filename>\")\n\tcommand := make([]string, len(r.command))\n\tfor i, part := range r.command {\n\t\tcommand[i] = replacer.Replace(part)\n\t}\n\tfmt.Fprintln(&buf, \"| Command:\", command)\n\tfmt.Fprintln(&buf, \"+---------\")\n\treturn buf.String()\n}\n\n// filterMatching passes on messages matching the regex/glob.\nfunc (r *Reflex) filterMatching(out chan<- string, in <-chan string) {\n\tfor name := range in {\n\t\tif !r.matcher.Match(name) {\n\t\t\tcontinue\n\t\t}\n\n\t\tif r.onlyFiles || r.onlyDirs {\n\t\t\tstat, err := os.Stat(name)\n\t\t\tif err != nil {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif (r.onlyFiles && stat.IsDir()) || (r.onlyDirs && !stat.IsDir()) {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t}\n\t\tout <- name\n\t}\n}\n\n// batch receives file notification events and batches them up. It's a bit\n// tricky, but here's what it accomplishes:\n// * When we initially get a message, wait a bit and batch messages before\n//   trying to send anything. This is because the file events come in bursts.\n// * Once it's time to send, don't do it until the out channel is unblocked.\n//   In the meantime, keep batching. When we've sent off all the batched\n//   messages, go back to the beginning.\nfunc (r *Reflex) batch(out chan<- string, in <-chan string) {\n\n\tconst silenceInterval = 300 * time.Millisecond\n\n\tfor name := range in {\n\t\tr.backlog.Add(name)\n\t\ttimer := time.NewTimer(silenceInterval)\n\touter:\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase name := <-in:\n\t\t\t\tr.backlog.Add(name)\n\t\t\t\tif !timer.Stop() {\n\t\t\t\t\t<-timer.C\n\t\t\t\t}\n\t\t\t\ttimer.Reset(silenceInterval)\n\t\t\tcase <-timer.C:\n\t\t\t\tfor {\n\t\t\t\t\tselect {\n\t\t\t\t\tcase name := <-in:\n\t\t\t\t\t\tr.backlog.Add(name)\n\t\t\t\t\tcase out <- r.backlog.Next():\n\t\t\t\t\t\tif r.backlog.RemoveOne() {\n\t\t\t\t\t\t\tbreak outer\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n// runEach runs the command on each name that comes through the names channel.\n// Each {} is replaced by the name of the file. The output of the command is\n// passed line-by-line to the stdout chan.\nfunc (r *Reflex) runEach(names <-chan string) {\n\tfor name := range names {\n\t\tif r.startService {\n\t\t\tif r.Running() {\n\t\t\t\tinfoPrintln(r.id, \"Killing service\")\n\t\t\t\tr.terminate()\n\t\t\t}\n\t\t\tinfoPrintln(r.id, \"Starting service\")\n\t\t\tr.runCommand(name, stdout)\n\t\t} else {\n\t\t\tr.runCommand(name, stdout)\n\t\t\t<-r.done\n\t\t\tr.mu.Lock()\n\t\t\tr.running = false\n\t\t\tr.mu.Unlock()\n\t\t}\n\t}\n}\n\nfunc (r *Reflex) terminate() {\n\tr.mu.Lock()\n\tr.killed = true\n\tr.mu.Unlock()\n\t// Write ascii 3 (what you get from ^C) to the controlling pty.\n\t// (This won't do anything if the process already died as the write will\n\t// simply fail.)\n\tr.tty.Write([]byte{3})\n\n\ttimer := time.NewTimer(r.timeout)\n\tsig := syscall.SIGINT\n\tfor {\n\t\tselect {\n\t\tcase <-r.done:\n\t\t\treturn\n\t\tcase <-timer.C:\n\t\t\tif sig == syscall.SIGINT {\n\t\t\t\tinfoPrintln(r.id, \"Sending SIGINT signal...\")\n\t\t\t} else {\n\t\t\t\tinfoPrintln(r.id, \"Sending SIGKILL signal...\")\n\t\t\t}\n\n\t\t\t// Instead of killing the process, we want to kill its\n\t\t\t// whole pgroup in order to clean up any children the\n\t\t\t// process may have created.\n\t\t\tif err := syscall.Kill(-1*r.cmd.Process.Pid, sig); err != nil {\n\t\t\t\tinfoPrintln(r.id, \"Error killing:\", err)\n\t\t\t\tif err.(syscall.Errno) == syscall.ESRCH { // no such process\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}\n\t\t\t// After SIGINT doesn't do anything, try SIGKILL next.\n\t\t\ttimer.Reset(r.timeout)\n\t\t\tsig = syscall.SIGKILL\n\t\t}\n\t}\n}\n\nfunc replaceSubSymbol(command []string, subSymbol string, name string) []string {\n\treplacer := strings.NewReplacer(subSymbol, name)\n\tnewCommand := make([]string, len(command))\n\tfor i, c := range command {\n\t\tnewCommand[i] = replacer.Replace(c)\n\t}\n\treturn newCommand\n}\n\nvar seqCommands = &sync.Mutex{}\n\n// runCommand runs the given Command. All output is passed line-by-line to the\n// stdout channel.\nfunc (r *Reflex) runCommand(name string, stdout chan<- OutMsg) {\n\tcommand := replaceSubSymbol(r.command, r.subSymbol, name)\n\tcmd := exec.Command(command[0], command[1:]...)\n\tr.cmd = cmd\n\n\tif flagSequential {\n\t\tseqCommands.Lock()\n\t}\n\n\ttty, err := pty.Start(cmd)\n\tif err != nil {\n\t\tinfoPrintln(r.id, err)\n\t\treturn\n\t}\n\tr.tty = tty\n\n\t// Handle pty size.\n\tchResize := make(chan os.Signal, 1)\n\tsignal.Notify(chResize, syscall.SIGWINCH)\n\tgo func() {\n\t\tfor range chResize {\n\t\t\t// Intentionally ignore errors in case stdout is not a tty\n\t\t\tpty.InheritSize(os.Stdout, tty)\n\t\t}\n\t}()\n\tchResize <- syscall.SIGWINCH // Initial resize.\n\n\tgo func() {\n\t\tscanner := bufio.NewScanner(tty)\n\t\t// Allow for lines up to 100 MB.\n\t\tscanner.Buffer(nil, 100e6)\n\t\tfor scanner.Scan() {\n\t\t\tstdout <- OutMsg{r.id, scanner.Text()}\n\t\t}\n\t\tif err := scanner.Err(); errors.Is(err, bufio.ErrTooLong) {\n\t\t\tinfoPrintln(r.id, \"Error: subprocess emitted a line longer than 100 MB\")\n\t\t}\n\t\t// Intentionally ignore other scanner errors. Unfortunately,\n\t\t// the pty returns a read error when the child dies naturally,\n\t\t// so I'm just going to ignore errors here unless I can find a\n\t\t// better way to handle it.\n\t}()\n\n\tr.mu.Lock()\n\tr.running = true\n\tr.mu.Unlock()\n\tgo func() {\n\t\terr := cmd.Wait()\n\t\tif !r.Killed() && err != nil {\n\t\t\tstdout <- OutMsg{r.id, fmt.Sprintf(\"(error exit: %s)\", err)}\n\t\t}\n\t\tr.done <- struct{}{}\n\n\t\tsignal.Stop(chResize)\n\t\tclose(chResize)\n\n\t\tif flagSequential {\n\t\t\tseqCommands.Unlock()\n\t\t}\n\t}()\n}\n\nfunc (r *Reflex) Start(changes <-chan string) {\n\tfiltered := make(chan string)\n\tbatched := make(chan string)\n\tgo r.filterMatching(filtered, changes)\n\tgo r.batch(batched, filtered)\n\tgo r.runEach(batched)\n\tif r.startService {\n\t\t// Easy hack to kick off the initial start.\n\t\tinfoPrintln(r.id, \"Starting service\")\n\t\tr.runCommand(\"\", stdout)\n\t}\n}\n\nfunc (r *Reflex) Killed() bool {\n\tr.mu.Lock()\n\tdefer r.mu.Unlock()\n\treturn r.killed\n}\n\nfunc (r *Reflex) Running() bool {\n\tr.mu.Lock()\n\tdefer r.mu.Unlock()\n\treturn r.running\n}\n"
        },
        {
          "name": "release.sh",
          "type": "blob",
          "size": 0.720703125,
          "content": "#!/bin/bash\nset -eu -o pipefail\n\ncd \"$(dirname \"$0\")\"\n\nversion=\"$1\"\n\nif [[ \"$(git rev-parse $version)\" != \"$(git rev-parse HEAD)\" ]]; then\n  echo \"Not currently on version $version\" 2>&1\n  exit 1\nfi\n\nrm -rf release\nmkdir release\n\nfor goos in linux darwin; do\n  for goarch in amd64 arm64; do\n    dir=\"release/reflex_${goos}_${goarch}\"\n    mkdir \"$dir\"\n    cp LICENSE \"${dir}/LICENSE\"\n    GOOS=$goos GOARCH=$goarch CGO_ENABLED=0 go build -o \"${dir}/reflex\"\n    tar -c -f - -C release \"$(basename \"$dir\")\" | gzip -9 >\"${dir}.tar.gz\"\n    rm -rf \"${dir}\"\n    sha256sum \"${dir}.tar.gz\" >\"${dir}.tar.gz.sha256\"\n  done\ndone\n\nexec gh release create \"$version\" \\\n  --title \"Reflex ${version#v}\" \\\n  ./release/*.tar.gz \\\n  ./release/*.tar.gz.sha256\n"
        },
        {
          "name": "watch.go",
          "type": "blob",
          "size": 2.1083984375,
          "content": "package main\n\nimport (\n\t\"os\"\n\t\"path/filepath\"\n\t\"strings\"\n\n\t\"github.com/fsnotify/fsnotify\"\n)\n\nconst chmodMask fsnotify.Op = ^fsnotify.Op(0) ^ fsnotify.Chmod\n\n// watch recursively watches changes in root and reports the filenames to names.\n// It sends an error on the done chan.\n// As an optimization, any dirs we encounter that meet the ExcludePrefix\n// criteria of all reflexes can be ignored.\nfunc watch(root string, watcher *fsnotify.Watcher, names chan<- string, done chan<- error, reflexes []*Reflex) {\n\tif err := filepath.Walk(root, walker(watcher, reflexes)); err != nil {\n\t\tinfoPrintf(-1, \"Error while walking path %s: %s\", root, err)\n\t}\n\n\tfor {\n\t\tselect {\n\t\tcase e := <-watcher.Events:\n\t\t\tif verbose {\n\t\t\t\tinfoPrintln(-1, \"fsnotify event:\", e)\n\t\t\t}\n\t\t\tstat, err := os.Stat(e.Name)\n\t\t\tif err != nil {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tpath := normalize(e.Name, stat.IsDir())\n\t\t\tif e.Op&chmodMask == 0 {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tnames <- path\n\t\t\tif e.Op&fsnotify.Create > 0 && stat.IsDir() {\n\t\t\t\tif err := filepath.Walk(path, walker(watcher, reflexes)); err != nil {\n\t\t\t\t\tinfoPrintf(-1, \"Error while walking path %s: %s\", path, err)\n\t\t\t\t}\n\t\t\t}\n\t\t\t// TODO: Cannot currently remove fsnotify watches\n\t\t\t// recursively, or for deleted files. See:\n\t\t\t// https://github.com/cespare/reflex/issues/13\n\t\t\t// https://github.com/go-fsnotify/fsnotify/issues/40\n\t\t\t// https://github.com/go-fsnotify/fsnotify/issues/41\n\t\tcase err := <-watcher.Errors:\n\t\t\tdone <- err\n\t\t\treturn\n\t\t}\n\t}\n}\n\nfunc walker(watcher *fsnotify.Watcher, reflexes []*Reflex) filepath.WalkFunc {\n\treturn func(path string, f os.FileInfo, err error) error {\n\t\tif err != nil || !f.IsDir() {\n\t\t\treturn nil\n\t\t}\n\t\tpath = normalize(path, f.IsDir())\n\t\tignore := true\n\t\tfor _, r := range reflexes {\n\t\t\tif !r.matcher.ExcludePrefix(path) {\n\t\t\t\tignore = false\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif ignore {\n\t\t\treturn filepath.SkipDir\n\t\t}\n\t\tif err := watcher.Add(path); err != nil {\n\t\t\tinfoPrintf(-1, \"Error while watching new path %s: %s\", path, err)\n\t\t}\n\t\treturn nil\n\t}\n}\n\nfunc normalize(path string, dir bool) string {\n\tpath = strings.TrimPrefix(path, \"./\")\n\tif dir && !strings.HasSuffix(path, \"/\") {\n\t\tpath = path + \"/\"\n\t}\n\treturn path\n}\n"
        }
      ]
    }
  ]
}