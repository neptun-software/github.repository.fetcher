{
  "metadata": {
    "timestamp": 1736567392426,
    "page": 999,
    "hasNextPage": false,
    "endCursor": "Y3Vyc29yOjEwMDA=",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "francoispqt/gojay",
      "stars": 2130,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.033203125,
          "content": "vendor\n*.out\n*.log\n*.test\n.vscode\n"
        },
        {
          "name": ".travis.yml",
          "type": "blob",
          "size": 0.32421875,
          "content": "language: go\n\ngo:\n  - \"1.10.x\"\n  - \"1.11.x\"\n  - \"1.12.x\"\n\nscript:\n  - go get github.com/golang/dep/cmd/dep github.com/stretchr/testify\n  - dep ensure -v -vendor-only\n  - go test ./gojay/codegen/test/... -race\n  - go test -race -coverprofile=coverage.txt -covermode=atomic\n\nafter_success:\n  - bash <(curl -s https://codecov.io/bash)\n"
        },
        {
          "name": "Gopkg.lock",
          "type": "blob",
          "size": 4.1591796875,
          "content": "# This file is autogenerated, do not edit; changes may be undone by the next 'dep ensure'.\n\n\n[[projects]]\n  digest = \"1:1a37f9f2ae10d161d9688fb6008ffa14e1631e5068cc3e9698008b9e8d40d575\"\n  name = \"cloud.google.com/go\"\n  packages = [\"compute/metadata\"]\n  pruneopts = \"\"\n  revision = \"457ea5c15ccf3b87db582c450e80101989da35f7\"\n  version = \"v0.40.0\"\n\n[[projects]]\n  digest = \"1:968d8903d598e3fae738325d3410f33f07ea6a2b9ee5591e9c262ee37df6845a\"\n  name = \"github.com/go-errors/errors\"\n  packages = [\".\"]\n  pruneopts = \"\"\n  revision = \"a6af135bd4e28680facf08a3d206b454abc877a4\"\n  version = \"v1.0.1\"\n\n[[projects]]\n  digest = \"1:529d738b7976c3848cae5cf3a8036440166835e389c1f617af701eeb12a0518d\"\n  name = \"github.com/golang/protobuf\"\n  packages = [\"proto\"]\n  pruneopts = \"\"\n  revision = \"b5d812f8a3706043e23a9cd5babf2e5423744d30\"\n  version = \"v1.3.1\"\n\n[[projects]]\n  branch = \"master\"\n  digest = \"1:cae59d7b8243c671c9f544965522ba35c0fec48ee80adb9f1400cd2f33abbbec\"\n  name = \"github.com/mailru/easyjson\"\n  packages = [\n    \".\",\n    \"buffer\",\n    \"jlexer\",\n    \"jwriter\",\n  ]\n  pruneopts = \"\"\n  revision = \"1ea4449da9834f4d333f1cc461c374aea217d249\"\n\n[[projects]]\n  digest = \"1:1d7e1867c49a6dd9856598ef7c3123604ea3daabf5b83f303ff457bcbc410b1d\"\n  name = \"github.com/pkg/errors\"\n  packages = [\".\"]\n  pruneopts = \"\"\n  revision = \"ba968bfe8b2f7e042a574c888954fccecfa385b4\"\n  version = \"v0.8.1\"\n\n[[projects]]\n  digest = \"1:8d4bbd8ab012efc77ab6b97286f2aff262bcdeac9803bb57d75cf7d0a5e6a877\"\n  name = \"github.com/viant/assertly\"\n  packages = [\".\"]\n  pruneopts = \"\"\n  revision = \"04f45e0aeb6f3455884877b047a97bcc95dc9493\"\n  version = \"v0.4.8\"\n\n[[projects]]\n  digest = \"1:5913451bc2d274673c0716efe226a137625740cd9380641f4d8300ff4f2d82a0\"\n  name = \"github.com/viant/toolbox\"\n  packages = [\n    \".\",\n    \"cred\",\n    \"data\",\n    \"storage\",\n    \"url\",\n  ]\n  pruneopts = \"\"\n  revision = \"1be8e4d172138324f40d55ea61a2aeab0c5ce864\"\n  version = \"v0.24.0\"\n\n[[projects]]\n  branch = \"master\"\n  digest = \"1:9d150270ca2c3356f2224a0878daa1652e4d0b25b345f18b4f6e156cc4b8ec5e\"\n  name = \"golang.org/x/crypto\"\n  packages = [\n    \"blowfish\",\n    \"curve25519\",\n    \"ed25519\",\n    \"ed25519/internal/edwards25519\",\n    \"internal/chacha20\",\n    \"internal/subtle\",\n    \"poly1305\",\n    \"ssh\",\n  ]\n  pruneopts = \"\"\n  revision = \"f99c8df09eb5bff426315721bfa5f16a99cad32c\"\n\n[[projects]]\n  branch = \"master\"\n  digest = \"1:5a56f211e7c12a65c5585c629457a2fb91d8719844ee8fab92727ea8adb5721c\"\n  name = \"golang.org/x/net\"\n  packages = [\n    \"context\",\n    \"context/ctxhttp\",\n    \"websocket\",\n  ]\n  pruneopts = \"\"\n  revision = \"461777fb6f67e8cb9d70cda16573678d085a74cf\"\n\n[[projects]]\n  branch = \"master\"\n  digest = \"1:01bdbbc604dcd5afb6f66a717f69ad45e9643c72d5bc11678d44ffa5c50f9e42\"\n  name = \"golang.org/x/oauth2\"\n  packages = [\n    \".\",\n    \"google\",\n    \"internal\",\n    \"jws\",\n    \"jwt\",\n  ]\n  pruneopts = \"\"\n  revision = \"0f29369cfe4552d0e4bcddc57cc75f4d7e672a33\"\n\n[[projects]]\n  branch = \"master\"\n  digest = \"1:8ddb956f67d4c176abbbc42b7514aaeaf9ea30daa24e27d2cf30ad82f9334a2c\"\n  name = \"golang.org/x/sys\"\n  packages = [\"cpu\"]\n  pruneopts = \"\"\n  revision = \"1e42afee0f762ed3d76e6dd942e4181855fd1849\"\n\n[[projects]]\n  digest = \"1:47f391ee443f578f01168347818cb234ed819521e49e4d2c8dd2fb80d48ee41a\"\n  name = \"google.golang.org/appengine\"\n  packages = [\n    \".\",\n    \"internal\",\n    \"internal/app_identity\",\n    \"internal/base\",\n    \"internal/datastore\",\n    \"internal/log\",\n    \"internal/modules\",\n    \"internal/remote_api\",\n    \"internal/urlfetch\",\n    \"urlfetch\",\n  ]\n  pruneopts = \"\"\n  revision = \"b2f4a3cf3c67576a2ee09e1fe62656a5086ce880\"\n  version = \"v1.6.1\"\n\n[[projects]]\n  digest = \"1:cedccf16b71e86db87a24f8d4c70b0a855872eb967cb906a66b95de56aefbd0d\"\n  name = \"gopkg.in/yaml.v2\"\n  packages = [\".\"]\n  pruneopts = \"\"\n  revision = \"51d6538a90f86fe93ac480b35f37b2be17fef232\"\n  version = \"v2.2.2\"\n\n[solve-meta]\n  analyzer-name = \"dep\"\n  analyzer-version = 1\n  input-imports = [\n    \"github.com/go-errors/errors\",\n    \"github.com/mailru/easyjson\",\n    \"github.com/mailru/easyjson/jlexer\",\n    \"github.com/mailru/easyjson/jwriter\",\n    \"github.com/viant/assertly\",\n    \"github.com/viant/toolbox\",\n    \"github.com/viant/toolbox/url\",\n    \"golang.org/x/net/websocket\",\n  ]\n  solver-name = \"gps-cdcl\"\n  solver-version = 1\n"
        },
        {
          "name": "Gopkg.toml",
          "type": "blob",
          "size": 0.6884765625,
          "content": "# Gopkg.toml example\n#\n# Refer to https://github.com/golang/dep/blob/master/docs/Gopkg.toml.md\n# for detailed Gopkg.toml documentation.\n#\n# required = [\"github.com/user/thing/cmd/thing\"]\n# ignored = [\"github.com/user/project/pkgX\", \"bitbucket.org/user/project/pkgA/pkgY\"]\n#\n# [[constraint]]\n#   name = \"github.com/user/project\"\n#   version = \"1.0.0\"\n#\n# [[constraint]]\n#   name = \"github.com/user/project2\"\n#   branch = \"dev\"\n#   source = \"github.com/myfork/project2\"\n#\n# [[override]]\n#  name = \"github.com/x/y\"\n#  version = \"2.4.0\"\n\n\nignored = [\"github.com/francoispqt/benchmarks*\",\"github.com/stretchr/testify*\",\"github.com/stretchr/testify\",\"github.com/json-iterator/go\",\"github.com/buger/jsonparser\"]\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.0361328125,
          "content": "MIT License\n\nCopyright (c) 2016 gojay\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE."
        },
        {
          "name": "Makefile",
          "type": "blob",
          "size": 0.1845703125,
          "content": ".PHONY: test\ntest:\n\tgo test -race -run=^Test -v\n\n.PHONY: cover\ncover: \n\tgo test -coverprofile=coverage.out -covermode=atomic\n\n.PHONY: coverhtml\ncoverhtml: \n\tgo tool cover -html=coverage.out"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 24.76953125,
          "content": "[![Build Status](https://travis-ci.org/francoispqt/gojay.svg?branch=master)](https://travis-ci.org/francoispqt/gojay)\n[![codecov](https://codecov.io/gh/francoispqt/gojay/branch/master/graph/badge.svg)](https://codecov.io/gh/francoispqt/gojay)\n[![Go Report Card](https://goreportcard.com/badge/github.com/francoispqt/gojay)](https://goreportcard.com/report/github.com/francoispqt/gojay)\n[![Go doc](http://img.shields.io/badge/go-documentation-blue.svg?style=flat-square\n)](https://godoc.org/github.com/francoispqt/gojay)\n![MIT License](https://img.shields.io/badge/license-mit-blue.svg?style=flat-square)\n[![Sourcegraph](https://sourcegraph.com/github.com/francoispqt/gojay/-/badge.svg)](https://sourcegraph.com/github.com/francoispqt/gojay)\n![stability-stable](https://img.shields.io/badge/stability-stable-green.svg)\n\n# GoJay\n\n<img src=\"https://github.com/francoispqt/gojay/raw/master/gojay.png\" width=\"200px\">\n\nGoJay is a performant JSON encoder/decoder for Golang (currently the most performant, [see benchmarks](#benchmark-results)).\n\nIt has a simple API and doesn't use reflection. It relies on small interfaces to decode/encode structures and slices.\n\nGojay also comes with powerful stream decoding features and an even faster [Unsafe](#unsafe-api) API.\n\nThere is also a [code generation tool](https://github.com/francoispqt/gojay/tree/master/gojay) to make usage easier and faster.\n\n# Why another JSON parser?\n\nI looked at other fast decoder/encoder and realised it was mostly hardly readable static code generation or a lot of reflection, poor streaming features, and not so fast in the end.\n\nAlso, I wanted to build a decoder that could consume an io.Reader of line or comma delimited JSON, in a JIT way. To consume a flow of JSON objects from a TCP connection for example or from a standard output. Same way I wanted to build an encoder that could encode a flow of data to a io.Writer.\n\nThis is how GoJay aims to be a very fast, JIT stream parser with 0 reflection, low allocation with a friendly API.\n\n# Get started\n\n```bash\ngo get github.com/francoispqt/gojay\n```\n\n* [Encoder](#encoding)\n* [Decoder](#decoding)\n* [Stream API](#stream-api)\n* [Code Generation](https://github.com/francoispqt/gojay/tree/master/gojay)\n\n## Decoding\n\nDecoding is done through two different API similar to standard `encoding/json`:\n* [Unmarshal](#unmarshal-api)\n* [Decode](#decode-api)\n\n\nExample of basic stucture decoding with Unmarshal:\n```go\nimport \"github.com/francoispqt/gojay\"\n\ntype user struct {\n    id int\n    name string\n    email string\n}\n// implement gojay.UnmarshalerJSONObject\nfunc (u *user) UnmarshalJSONObject(dec *gojay.Decoder, key string) error {\n    switch key {\n    case \"id\":\n        return dec.Int(&u.id)\n    case \"name\":\n        return dec.String(&u.name)\n    case \"email\":\n        return dec.String(&u.email)\n    }\n    return nil\n}\nfunc (u *user) NKeys() int {\n    return 3\n}\n\nfunc main() {\n    u := &user{}\n    d := []byte(`{\"id\":1,\"name\":\"gojay\",\"email\":\"gojay@email.com\"}`)\n    err := gojay.UnmarshalJSONObject(d, u)\n    if err != nil {\n        log.Fatal(err)\n    }\n}\n```\n\nwith Decode:\n```go\nfunc main() {\n    u := &user{}\n    dec := gojay.NewDecoder(bytes.NewReader([]byte(`{\"id\":1,\"name\":\"gojay\",\"email\":\"gojay@email.com\"}`)))\n    err := dec.DecodeObject(d, u)\n    if err != nil {\n        log.Fatal(err)\n    }\n}\n```\n\n### Unmarshal API\n\nUnmarshal API decodes a `[]byte` to a given pointer with a single function.\n\nBehind the doors, Unmarshal API borrows a `*gojay.Decoder` resets its settings and decodes the data to the given pointer and releases the `*gojay.Decoder` to the pool when it finishes, whether it encounters an error or not.\n\nIf it cannot find the right Decoding strategy for the type of the given pointer, it returns an `InvalidUnmarshalError`. You can test the error returned by doing `if ok := err.(InvalidUnmarshalError); ok {}`.\n\nUnmarshal API comes with three functions:\n* Unmarshal\n```go\nfunc Unmarshal(data []byte, v interface{}) error\n```\n\n* UnmarshalJSONObject\n```go\nfunc UnmarshalJSONObject(data []byte, v gojay.UnmarshalerJSONObject) error\n```\n\n* UnmarshalJSONArray\n```go\nfunc UnmarshalJSONArray(data []byte, v gojay.UnmarshalerJSONArray) error\n```\n\n\n### Decode API\n\nDecode API decodes a `[]byte` to a given pointer by creating or borrowing a `*gojay.Decoder` with an `io.Reader` and calling `Decode` methods.\n\n__Getting a *gojay.Decoder or Borrowing__\n\nYou can either get a fresh `*gojay.Decoder` calling `dec := gojay.NewDecoder(io.Reader)` or borrow one from the pool by calling `dec := gojay.BorrowDecoder(io.Reader)`.\n\nAfter using a decoder, you can release it by calling `dec.Release()`. Beware, if you reuse the decoder after releasing it, it will panic with an error of type `InvalidUsagePooledDecoderError`. If you want to fully benefit from the pooling, you must release your decoders after using.\n\nExample getting a fresh an releasing:\n```go\nstr := \"\"\ndec := gojay.NewDecoder(strings.NewReader(`\"test\"`))\ndefer dec.Release()\nif err := dec.Decode(&str); err != nil {\n    log.Fatal(err)\n}\n```\nExample borrowing a decoder and releasing:\n```go\nstr := \"\"\ndec := gojay.BorrowDecoder(strings.NewReader(`\"test\"`))\ndefer dec.Release()\nif err := dec.Decode(&str); err != nil {\n    log.Fatal(err)\n}\n```\n\n`*gojay.Decoder` has multiple methods to decode to specific types:\n* Decode\n```go\nfunc (dec *gojay.Decoder) Decode(v interface{}) error\n```\n* DecodeObject\n```go\nfunc (dec *gojay.Decoder) DecodeObject(v gojay.UnmarshalerJSONObject) error\n```\n* DecodeArray\n```go\nfunc (dec *gojay.Decoder) DecodeArray(v gojay.UnmarshalerJSONArray) error\n```\n* DecodeInt\n```go\nfunc (dec *gojay.Decoder) DecodeInt(v *int) error\n```\n* DecodeBool\n```go\nfunc (dec *gojay.Decoder) DecodeBool(v *bool) error\n```\n* DecodeString\n```go\nfunc (dec *gojay.Decoder) DecodeString(v *string) error\n```\n\nAll DecodeXxx methods are used to decode top level JSON values. If you are decoding keys or items of a JSON object or array, don't use the Decode methods.\n\nExample:\n```go\nreader := strings.NewReader(`\"John Doe\"`)\ndec := NewDecoder(reader)\n\nvar str string\nerr := dec.DecodeString(&str)\nif err != nil {\n    log.Fatal(err)\n}\n\nfmt.Println(str) // John Doe\n```\n\n### Structs and Maps\n#### UnmarshalerJSONObject Interface\n\nTo unmarshal a JSON object to a structure, the structure must implement the `UnmarshalerJSONObject` interface:\n```go\ntype UnmarshalerJSONObject interface {\n\tUnmarshalJSONObject(*gojay.Decoder, string) error\n\tNKeys() int\n}\n```\n`UnmarshalJSONObject` method takes two arguments, the first one is a pointer to the Decoder (*gojay.Decoder) and the second one is the string value of the current key being parsed. If the JSON data is not an object, the UnmarshalJSONObject method will never be called.\n\n`NKeys` method must return the number of keys to Unmarshal in the JSON object or 0. If zero is returned, all keys will be parsed.\n\nExample of implementation for a struct:\n```go\ntype user struct {\n    id int\n    name string\n    email string\n}\n// implement UnmarshalerJSONObject\nfunc (u *user) UnmarshalJSONObject(dec *gojay.Decoder, key string) error {\n    switch key {\n    case \"id\":\n        return dec.Int(&u.id)\n    case \"name\":\n        return dec.String(&u.name)\n    case \"email\":\n        return dec.String(&u.email)\n    }\n    return nil\n}\nfunc (u *user) NKeys() int {\n    return 3\n}\n```\n\nExample of implementation for a `map[string]string`:\n```go\n// define our custom map type implementing UnmarshalerJSONObject\ntype message map[string]string\n\n// Implementing Unmarshaler\nfunc (m message) UnmarshalJSONObject(dec *gojay.Decoder, k string) error {\n\tstr := \"\"\n\terr := dec.String(&str)\n\tif err != nil {\n\t\treturn err\n\t}\n\tm[k] = str\n\treturn nil\n}\n\n// we return 0, it tells the Decoder to decode all keys\nfunc (m message) NKeys() int {\n\treturn 0\n}\n```\n\n### Arrays, Slices and Channels\n\nTo unmarshal a JSON object to a slice an array or a channel, it must implement the UnmarshalerJSONArray interface:\n```go\ntype UnmarshalerJSONArray interface {\n\tUnmarshalJSONArray(*gojay.Decoder) error\n}\n```\nUnmarshalJSONArray method takes one argument, a pointer to the Decoder (*gojay.Decoder). If the JSON data is not an array, the Unmarshal method will never be called.\n\nExample of implementation with a slice:\n```go\ntype testSlice []string\n// implement UnmarshalerJSONArray\nfunc (t *testSlice) UnmarshalJSONArray(dec *gojay.Decoder) error {\n\tstr := \"\"\n\tif err := dec.String(&str); err != nil {\n\t\treturn err\n\t}\n\t*t = append(*t, str)\n\treturn nil\n}\n\nfunc main() {\n\tdec := gojay.BorrowDecoder(strings.NewReader(`[\"Tom\", \"Jim\"]`))\n\tvar slice testSlice\n\terr := dec.DecodeArray(&slice)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tfmt.Println(slice) // [Tom Jim]\n\tdec.Release()\n}\n```\n\nExample of implementation with a channel:\n```go\ntype testChannel chan string\n// implement UnmarshalerJSONArray\nfunc (c testChannel) UnmarshalJSONArray(dec *gojay.Decoder) error {\n\tstr := \"\"\n\tif err := dec.String(&str); err != nil {\n\t\treturn err\n\t}\n\tc <- str\n\treturn nil\n}\n\nfunc main() {\n\tdec := gojay.BorrowDecoder(strings.NewReader(`[\"Tom\", \"Jim\"]`))\n\tc := make(testChannel, 2)\n\terr := dec.DecodeArray(c)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tfor i := 0; i < 2; i++ {\n\t\tfmt.Println(<-c)\n\t}\n\tclose(c)\n\tdec.Release()\n}\n```\n\nExample of implementation with an array:\n```go\ntype testArray [3]string\n// implement UnmarshalerJSONArray\nfunc (a *testArray) UnmarshalJSONArray(dec *Decoder) error {\n\tvar str string\n\tif err := dec.String(&str); err != nil {\n\t\treturn err\n\t}\n\ta[dec.Index()] = str\n\treturn nil\n}\n\nfunc main() {\n\tdec := gojay.BorrowDecoder(strings.NewReader(`[\"Tom\", \"Jim\", \"Bob\"]`))\n\tvar a testArray\n\terr := dec.DecodeArray(&a)\n\tfmt.Println(a) // [Tom Jim Bob]\n\tdec.Release()\n}\n```\n\n### Other types\nTo decode other types (string, int, int32, int64, uint32, uint64, float, booleans), you don't need to implement any interface.\n\nExample of encoding strings:\n```go\nfunc main() {\n    json := []byte(`\"Jay\"`)\n    var v string\n    err := gojay.Unmarshal(json, &v)\n    if err != nil {\n        log.Fatal(err)\n    }\n    fmt.Println(v) // Jay\n}\n```\n\n### Decode values methods\nWhen decoding a JSON object of a JSON array using `UnmarshalerJSONObject` or `UnmarshalerJSONArray` interface, the `gojay.Decoder` provides dozens of methods to Decode multiple types.\n\nNon exhaustive list of methods available (to see all methods, check the godoc):\n```go\ndec.Int\ndec.Int8\ndec.Int16\ndec.Int32\ndec.Int64\ndec.Uint8\ndec.Uint16\ndec.Uint32\ndec.Uint64\ndec.String\ndec.Time\ndec.Bool\ndec.SQLNullString\ndec.SQLNullInt64\n```\n\n\n## Encoding\n\nEncoding is done through two different API similar to standard `encoding/json`:\n* [Marshal](#marshal-api)\n* [Encode](#encode-api)\n\nExample of basic structure encoding with Marshal:\n```go\nimport \"github.com/francoispqt/gojay\"\n\ntype user struct {\n\tid    int\n\tname  string\n\temail string\n}\n\n// implement MarshalerJSONObject\nfunc (u *user) MarshalJSONObject(enc *gojay.Encoder) {\n\tenc.IntKey(\"id\", u.id)\n\tenc.StringKey(\"name\", u.name)\n\tenc.StringKey(\"email\", u.email)\n}\nfunc (u *user) IsNil() bool {\n\treturn u == nil\n}\n\nfunc main() {\n\tu := &user{1, \"gojay\", \"gojay@email.com\"}\n\tb, err := gojay.MarshalJSONObject(u)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tfmt.Println(string(b)) // {\"id\":1,\"name\":\"gojay\",\"email\":\"gojay@email.com\"}\n}\n```\n\nwith Encode:\n```go\nfunc main() {\n\tu := &user{1, \"gojay\", \"gojay@email.com\"}\n\tb := strings.Builder{}\n\tenc := gojay.NewEncoder(&b)\n\tif err := enc.Encode(u); err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tfmt.Println(b.String()) // {\"id\":1,\"name\":\"gojay\",\"email\":\"gojay@email.com\"}\n}\n```\n\n### Marshal API\n\nMarshal API encodes a value to a JSON `[]byte` with a single function.\n\nBehind the doors, Marshal API borrows a `*gojay.Encoder` resets its settings and encodes the data to an internal byte buffer and releases the `*gojay.Encoder` to the pool when it finishes, whether it encounters an error or not.\n\nIf it cannot find the right Encoding strategy for the type of the given value, it returns an `InvalidMarshalError`. You can test the error returned by doing `if ok := err.(InvalidMarshalError); ok {}`.\n\nMarshal API comes with three functions:\n* Marshal\n```go\nfunc Marshal(v interface{}) ([]byte, error)\n```\n\n* MarshalJSONObject\n```go\nfunc MarshalJSONObject(v gojay.MarshalerJSONObject) ([]byte, error)\n```\n\n* MarshalJSONArray\n```go\nfunc MarshalJSONArray(v gojay.MarshalerJSONArray) ([]byte, error)\n```\n\n### Encode API\n\nEncode API decodes a value to JSON by creating or borrowing a `*gojay.Encoder` sending it to an `io.Writer` and calling `Encode` methods.\n\n__Getting a *gojay.Encoder or Borrowing__\n\nYou can either get a fresh `*gojay.Encoder` calling `enc := gojay.NewEncoder(io.Writer)` or borrow one from the pool by calling `enc := gojay.BorrowEncoder(io.Writer)`.\n\nAfter using an encoder, you can release it by calling `enc.Release()`. Beware, if you reuse the encoder after releasing it, it will panic with an error of type `InvalidUsagePooledEncoderError`. If you want to fully benefit from the pooling, you must release your encoders after using.\n\nExample getting a fresh encoder an releasing:\n```go\nstr := \"test\"\nb := strings.Builder{}\nenc := gojay.NewEncoder(&b)\ndefer enc.Release()\nif err := enc.Encode(str); err != nil {\n    log.Fatal(err)\n}\n```\nExample borrowing an encoder and releasing:\n```go\nstr := \"test\"\nb := strings.Builder{}\nenc := gojay.BorrowEncoder(b)\ndefer enc.Release()\nif err := enc.Encode(str); err != nil {\n    log.Fatal(err)\n}\n```\n\n`*gojay.Encoder` has multiple methods to encoder specific types to JSON:\n* Encode\n```go\nfunc (enc *gojay.Encoder) Encode(v interface{}) error\n```\n* EncodeObject\n```go\nfunc (enc *gojay.Encoder) EncodeObject(v gojay.MarshalerJSONObject) error\n```\n* EncodeArray\n```go\nfunc (enc *gojay.Encoder) EncodeArray(v gojay.MarshalerJSONArray) error\n```\n* EncodeInt\n```go\nfunc (enc *gojay.Encoder) EncodeInt(n int) error\n```\n* EncodeInt64\n```go\nfunc (enc *gojay.Encoder) EncodeInt64(n int64) error\n```\n* EncodeFloat\n```go\nfunc (enc *gojay.Encoder) EncodeFloat(n float64) error\n```\n* EncodeBool\n```go\nfunc (enc *gojay.Encoder) EncodeBool(v bool) error\n```\n* EncodeString\n```go\nfunc (enc *gojay.Encoder) EncodeString(s string) error\n```\n\n### Structs and Maps\n\nTo encode a structure, the structure must implement the MarshalerJSONObject interface:\n```go\ntype MarshalerJSONObject interface {\n\tMarshalJSONObject(enc *gojay.Encoder)\n\tIsNil() bool\n}\n```\n`MarshalJSONObject` method takes one argument, a pointer to the Encoder (*gojay.Encoder). The method must add all the keys in the JSON Object by calling Decoder's methods.\n\nIsNil method returns a boolean indicating if the interface underlying value is nil or not. It is used to safely ensure that the underlying value is not nil without using Reflection.\n\nExample of implementation for a struct:\n```go\ntype user struct {\n\tid    int\n\tname  string\n\temail string\n}\n\n// implement MarshalerJSONObject\nfunc (u *user) MarshalJSONObject(enc *gojay.Encoder) {\n\tenc.IntKey(\"id\", u.id)\n\tenc.StringKey(\"name\", u.name)\n\tenc.StringKey(\"email\", u.email)\n}\nfunc (u *user) IsNil() bool {\n\treturn u == nil\n}\n```\n\nExample of implementation for a `map[string]string`:\n```go\n// define our custom map type implementing MarshalerJSONObject\ntype message map[string]string\n\n// Implementing Marshaler\nfunc (m message) MarshalJSONObject(enc *gojay.Encoder) {\n\tfor k, v := range m {\n\t\tenc.StringKey(k, v)\n\t}\n}\n\nfunc (m message) IsNil() bool {\n\treturn m == nil\n}\n```\n\n### Arrays and Slices\nTo encode an array or a slice, the slice/array must implement the MarshalerJSONArray interface:\n```go\ntype MarshalerJSONArray interface {\n\tMarshalJSONArray(enc *gojay.Encoder)\n\tIsNil() bool\n}\n```\n`MarshalJSONArray` method takes one argument, a pointer to the Encoder (*gojay.Encoder). The method must add all element in the JSON Array by calling Decoder's methods.\n\n`IsNil` method returns a boolean indicating if the interface underlying value is nil(empty) or not. It is used to safely ensure that the underlying value is not nil without using Reflection and also to in `OmitEmpty` feature.\n\nExample of implementation:\n```go\ntype users []*user\n// implement MarshalerJSONArray\nfunc (u *users) MarshalJSONArray(enc *gojay.Encoder) {\n\tfor _, e := range u {\n\t\tenc.Object(e)\n\t}\n}\nfunc (u *users) IsNil() bool {\n\treturn len(u) == 0\n}\n```\n\n### Other types\nTo encode other types (string, int, float, booleans), you don't need to implement any interface.\n\nExample of encoding strings:\n```go\nfunc main() {\n\tname := \"Jay\"\n\tb, err := gojay.Marshal(name)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tfmt.Println(string(b)) // \"Jay\"\n}\n```\n\n# Stream API\n\n### Stream Decoding\nGoJay ships with a powerful stream decoder.\n\nIt allows to read continuously from an io.Reader stream and do JIT decoding writing unmarshalled JSON to a channel to allow async consuming.\n\nWhen using the Stream API, the Decoder implements context.Context to provide graceful cancellation.\n\nTo decode a stream of JSON, you must call `gojay.Stream.DecodeStream` and pass it a `UnmarshalerStream` implementation.\n\n```go\ntype UnmarshalerStream interface {\n\tUnmarshalStream(*StreamDecoder) error\n}\n```\n\nExample of implementation of stream reading from a WebSocket connection:\n```go\n// implement UnmarshalerStream\ntype ChannelStream chan *user\n\nfunc (c ChannelStream) UnmarshalStream(dec *gojay.StreamDecoder) error {\n\tu := &user{}\n\tif err := dec.Object(u); err != nil {\n\t\treturn err\n\t}\n\tc <- u\n\treturn nil\n}\n\nfunc main() {\n\t// get our websocket connection\n\torigin := \"http://localhost/\"\n\turl := \"ws://localhost:12345/ws\"\n\tws, err := websocket.Dial(url, \"\", origin)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\t// create our channel which will receive our objects\n\tstreamChan := ChannelStream(make(chan *user))\n\t// borrow a decoder\n\tdec := gojay.Stream.BorrowDecoder(ws)\n\t// start decoding, it will block until a JSON message is decoded from the WebSocket\n\t// or until Done channel is closed\n\tgo dec.DecodeStream(streamChan)\n\tfor {\n\t\tselect {\n\t\tcase v := <-streamChan:\n\t\t\t// Got something from my websocket!\n\t\t\tlog.Println(v)\n\t\tcase <-dec.Done():\n\t\t\tlog.Println(\"finished reading from WebSocket\")\n\t\t\tos.Exit(0)\n\t\t}\n\t}\n}\n```\n\n### Stream Encoding\nGoJay ships with a powerful stream encoder part of the Stream API.\n\nIt allows to write continuously to an io.Writer and do JIT encoding of data fed to a channel to allow async consuming. You can set multiple consumers on the channel to be as performant as possible. Consumers are non blocking and are scheduled individually in their own go routine.\n\nWhen using the Stream API, the Encoder implements context.Context to provide graceful cancellation.\n\nTo encode a stream of data, you must call `EncodeStream` and pass it a `MarshalerStream` implementation.\n\n```go\ntype MarshalerStream interface {\n\tMarshalStream(enc *gojay.StreamEncoder)\n}\n```\n\nExample of implementation of stream writing to a WebSocket:\n```go\n// Our structure which will be pushed to our stream\ntype user struct {\n\tid    int\n\tname  string\n\temail string\n}\n\nfunc (u *user) MarshalJSONObject(enc *gojay.Encoder) {\n\tenc.IntKey(\"id\", u.id)\n\tenc.StringKey(\"name\", u.name)\n\tenc.StringKey(\"email\", u.email)\n}\nfunc (u *user) IsNil() bool {\n\treturn u == nil\n}\n\n// Our MarshalerStream implementation\ntype StreamChan chan *user\n\nfunc (s StreamChan) MarshalStream(enc *gojay.StreamEncoder) {\n\tselect {\n\tcase <-enc.Done():\n\t\treturn\n\tcase o := <-s:\n\t\tenc.Object(o)\n\t}\n}\n\n// Our main function\nfunc main() {\n\t// get our websocket connection\n\torigin := \"http://localhost/\"\n\turl := \"ws://localhost:12345/ws\"\n\tws, err := websocket.Dial(url, \"\", origin)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\t// we borrow an encoder set stdout as the writer,\n\t// set the number of consumer to 10\n\t// and tell the encoder to separate each encoded element\n\t// added to the channel by a new line character\n\tenc := gojay.Stream.BorrowEncoder(ws).NConsumer(10).LineDelimited()\n\t// instantiate our MarshalerStream\n\ts := StreamChan(make(chan *user))\n\t// start the stream encoder\n\t// will block its goroutine until enc.Cancel(error) is called\n\t// or until something is written to the channel\n\tgo enc.EncodeStream(s)\n\t// write to our MarshalerStream\n\tfor i := 0; i < 1000; i++ {\n\t\ts <- &user{i, \"username\", \"user@email.com\"}\n\t}\n\t// Wait\n\t<-enc.Done()\n}\n```\n\n# Unsafe API\n\nUnsafe API has the same functions than the regular API, it only has `Unmarshal API` for now. It is unsafe because it makes assumptions on the quality of the given JSON.\n\nIf you are not sure if your JSON is valid, don't use the Unsafe API.\n\nAlso, the `Unsafe` API does not copy the buffer when using Unmarshal API, which, in case of string decoding, can lead to data corruption if a byte buffer is reused. Using the `Decode` API makes `Unsafe` API safer as the io.Reader relies on `copy` builtin method and `Decoder` will have its own internal buffer :)\n\nAccess the `Unsafe` API this way:\n```go\ngojay.Unsafe.Unmarshal(b, v)\n```\n\n\n# Benchmarks\n\nBenchmarks encode and decode three different data based on size (small, medium, large).\n\nTo run benchmark for decoder:\n```bash\ncd $GOPATH/src/github.com/francoispqt/gojay/benchmarks/decoder && make bench\n```\n\nTo run benchmark for encoder:\n```bash\ncd $GOPATH/src/github.com/francoispqt/gojay/benchmarks/encoder && make bench\n```\n\n# Benchmark Results\n## Decode\n\n<img src=\"https://images2.imgbox.com/78/01/49OExcPh_o.png\" width=\"500px\">\n\n### Small Payload\n[benchmark code is here](https://github.com/francoispqt/gojay/blob/master/benchmarks/decoder/decoder_bench_small_test.go)\n\n[benchmark data is here](https://github.com/francoispqt/gojay/blob/master/benchmarks/benchmarks_small.go)\n\n|                 | ns/op     | bytes/op     | allocs/op |\n|-----------------|-----------|--------------|-----------|\n| Std Library     | 2547      | 496          | 4         |\n| JsonIter        | 2046      | 312          | 12        |\n| JsonParser      | 1408      | 0            | 0         |\n| EasyJson        | 929       | 240          | 2         |\n| **GoJay**       | **807**   | **256**      | **2**     |\n| **GoJay-unsafe**| **712**   | **112**      | **1**     |\n\n### Medium Payload\n[benchmark code is here](https://github.com/francoispqt/gojay/blob/master/benchmarks/decoder/decoder_bench_medium_test.go)\n\n[benchmark data is here](https://github.com/francoispqt/gojay/blob/master/benchmarks/benchmarks_medium.go)\n\n|                 | ns/op     | bytes/op | allocs/op |\n|-----------------|-----------|----------|-----------|\n| Std Library     | 30148     | 2152     | 496       |\n| JsonIter        | 16309     | 2976     | 80        |\n| JsonParser      | 7793      | 0        | 0         |\n| EasyJson        | 7957      | 232      | 6         |\n| **GoJay**       | **4984**  | **2448** | **8**     |\n| **GoJay-unsafe**| **4809**  | **144**  | **7**     |\n\n### Large Payload\n[benchmark code is here](https://github.com/francoispqt/gojay/blob/master/benchmarks/decoder/decoder_bench_large_test.go)\n\n[benchmark data is here](https://github.com/francoispqt/gojay/blob/master/benchmarks/benchmarks_large.go)\n\n|                 | ns/op     | bytes/op    | allocs/op |\n|-----------------|-----------|-------------|-----------|\n| JsonIter        | 210078    | 41712       | 1136      |\n| EasyJson        | 106626    | 160         | 2         |\n| JsonParser      | 66813     | 0           | 0         |\n| **GoJay**       | **52153** | **31241**   | **77**    |\n| **GoJay-unsafe**| **48277** | **2561**    | **76**    |\n\n## Encode\n\n<img src=\"https://images2.imgbox.com/e9/cc/pnM8c7Gf_o.png\" width=\"500px\">\n\n### Small Struct\n[benchmark code is here](https://github.com/francoispqt/gojay/blob/master/benchmarks/encoder/encoder_bench_small_test.go)\n\n[benchmark data is here](https://github.com/francoispqt/gojay/blob/master/benchmarks/benchmarks_small.go)\n\n|                | ns/op    | bytes/op     | allocs/op |\n|----------------|----------|--------------|-----------|\n| Std Library    | 1280     | 464          | 3         |\n| EasyJson       | 871      | 944          | 6         |\n| JsonIter       | 866      | 272          | 3         |\n| **GoJay**      | **543**  | **112**      | **1**     |\n| **GoJay-func** | **347**  | **0**        | **0**     |\n\n### Medium Struct\n[benchmark code is here](https://github.com/francoispqt/gojay/blob/master/benchmarks/encoder/encoder_bench_medium_test.go)\n\n[benchmark data is here](https://github.com/francoispqt/gojay/blob/master/benchmarks/benchmarks_medium.go)\n\n|             | ns/op    | bytes/op     | allocs/op |\n|-------------|----------|--------------|-----------|\n| Std Library | 5006     | 1496         | 25        |\n| JsonIter    | 2232     | 1544         | 20        |\n| EasyJson    | 1997     | 1544         | 19        |\n| **GoJay**   | **1522** | **312**      | **14**    |\n\n### Large Struct\n[benchmark code is here](https://github.com/francoispqt/gojay/blob/master/benchmarks/encoder/encoder_bench_large_test.go)\n\n[benchmark data is here](https://github.com/francoispqt/gojay/blob/master/benchmarks/benchmarks_large.go)\n\n|             | ns/op     | bytes/op     | allocs/op |\n|-------------|-----------|--------------|-----------|\n| Std Library | 66441     | 20576        | 332       |\n| JsonIter    | 35247     | 20255        | 328       |\n| EasyJson    | 32053     | 15474        | 327       |\n| **GoJay**   | **27847** | **9802**     | **318**   |\n\n# Contributing\n\nContributions are welcome :)\n\nIf you encounter issues please report it in Github and/or send an email at [francois@parquet.ninja](mailto:francois@parquet.ninja)\n\n"
        },
        {
          "name": "benchmarks",
          "type": "tree",
          "content": null
        },
        {
          "name": "decode.go",
          "type": "blob",
          "size": 9.8828125,
          "content": "package gojay\n\nimport (\n\t\"fmt\"\n\t\"io\"\n)\n\n// UnmarshalJSONArray parses the JSON-encoded data and stores the result in the value pointed to by v.\n//\n// v must implement UnmarshalerJSONArray.\n//\n// If a JSON value is not appropriate for a given target type, or if a JSON number\n// overflows the target type, UnmarshalJSONArray skips that field and completes the unmarshaling as best it can.\nfunc UnmarshalJSONArray(data []byte, v UnmarshalerJSONArray) error {\n\tdec := borrowDecoder(nil, 0)\n\tdefer dec.Release()\n\tdec.data = make([]byte, len(data))\n\tcopy(dec.data, data)\n\tdec.length = len(data)\n\t_, err := dec.decodeArray(v)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif dec.err != nil {\n\t\treturn dec.err\n\t}\n\treturn nil\n}\n\n// UnmarshalJSONObject parses the JSON-encoded data and stores the result in the value pointed to by v.\n//\n// v must implement UnmarshalerJSONObject.\n//\n// If a JSON value is not appropriate for a given target type, or if a JSON number\n// overflows the target type, UnmarshalJSONObject skips that field and completes the unmarshaling as best it can.\nfunc UnmarshalJSONObject(data []byte, v UnmarshalerJSONObject) error {\n\tdec := borrowDecoder(nil, 0)\n\tdefer dec.Release()\n\tdec.data = make([]byte, len(data))\n\tcopy(dec.data, data)\n\tdec.length = len(data)\n\t_, err := dec.decodeObject(v)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif dec.err != nil {\n\t\treturn dec.err\n\t}\n\treturn nil\n}\n\n// Unmarshal parses the JSON-encoded data and stores the result in the value pointed to by v.\n// If v is nil, not an implementation of UnmarshalerJSONObject or UnmarshalerJSONArray or not one of the following types:\n// \t*string, **string, *int, **int, *int8, **int8, *int16, **int16, *int32, **int32, *int64, **int64, *uint8, **uint8, *uint16, **uint16,\n// \t*uint32, **uint32, *uint64, **uint64, *float64, **float64, *float32, **float32, *bool, **bool\n// Unmarshal returns an InvalidUnmarshalError.\n//\n//\n// If a JSON value is not appropriate for a given target type, or if a JSON number\n// overflows the target type, Unmarshal skips that field and completes the unmarshaling as best it can.\n// If no more serious errors are encountered, Unmarshal returns an UnmarshalTypeError describing the earliest such error.\n// In any case, it's not guaranteed that all the remaining fields following the problematic one will be unmarshaled into the target object.\nfunc Unmarshal(data []byte, v interface{}) error {\n\tvar err error\n\tvar dec *Decoder\n\tswitch vt := v.(type) {\n\tcase *string:\n\t\tdec = borrowDecoder(nil, 0)\n\t\tdec.length = len(data)\n\t\tdec.data = data\n\t\terr = dec.decodeString(vt)\n\tcase **string:\n\t\tdec = borrowDecoder(nil, 0)\n\t\tdec.length = len(data)\n\t\tdec.data = data\n\t\terr = dec.decodeStringNull(vt)\n\tcase *int:\n\t\tdec = borrowDecoder(nil, 0)\n\t\tdec.length = len(data)\n\t\tdec.data = data\n\t\terr = dec.decodeInt(vt)\n\tcase **int:\n\t\tdec = borrowDecoder(nil, 0)\n\t\tdec.length = len(data)\n\t\tdec.data = data\n\t\terr = dec.decodeIntNull(vt)\n\tcase *int8:\n\t\tdec = borrowDecoder(nil, 0)\n\t\tdec.length = len(data)\n\t\tdec.data = data\n\t\terr = dec.decodeInt8(vt)\n\tcase **int8:\n\t\tdec = borrowDecoder(nil, 0)\n\t\tdec.length = len(data)\n\t\tdec.data = data\n\t\terr = dec.decodeInt8Null(vt)\n\tcase *int16:\n\t\tdec = borrowDecoder(nil, 0)\n\t\tdec.length = len(data)\n\t\tdec.data = data\n\t\terr = dec.decodeInt16(vt)\n\tcase **int16:\n\t\tdec = borrowDecoder(nil, 0)\n\t\tdec.length = len(data)\n\t\tdec.data = data\n\t\terr = dec.decodeInt16Null(vt)\n\tcase *int32:\n\t\tdec = borrowDecoder(nil, 0)\n\t\tdec.length = len(data)\n\t\tdec.data = data\n\t\terr = dec.decodeInt32(vt)\n\tcase **int32:\n\t\tdec = borrowDecoder(nil, 0)\n\t\tdec.length = len(data)\n\t\tdec.data = data\n\t\terr = dec.decodeInt32Null(vt)\n\tcase *int64:\n\t\tdec = borrowDecoder(nil, 0)\n\t\tdec.length = len(data)\n\t\tdec.data = data\n\t\terr = dec.decodeInt64(vt)\n\tcase **int64:\n\t\tdec = borrowDecoder(nil, 0)\n\t\tdec.length = len(data)\n\t\tdec.data = data\n\t\terr = dec.decodeInt64Null(vt)\n\tcase *uint8:\n\t\tdec = borrowDecoder(nil, 0)\n\t\tdec.length = len(data)\n\t\tdec.data = data\n\t\terr = dec.decodeUint8(vt)\n\tcase **uint8:\n\t\tdec = borrowDecoder(nil, 0)\n\t\tdec.length = len(data)\n\t\tdec.data = data\n\t\terr = dec.decodeUint8Null(vt)\n\tcase *uint16:\n\t\tdec = borrowDecoder(nil, 0)\n\t\tdec.length = len(data)\n\t\tdec.data = data\n\t\terr = dec.decodeUint16(vt)\n\tcase **uint16:\n\t\tdec = borrowDecoder(nil, 0)\n\t\tdec.length = len(data)\n\t\tdec.data = data\n\t\terr = dec.decodeUint16Null(vt)\n\tcase *uint32:\n\t\tdec = borrowDecoder(nil, 0)\n\t\tdec.length = len(data)\n\t\tdec.data = data\n\t\terr = dec.decodeUint32(vt)\n\tcase **uint32:\n\t\tdec = borrowDecoder(nil, 0)\n\t\tdec.length = len(data)\n\t\tdec.data = data\n\t\terr = dec.decodeUint32Null(vt)\n\tcase *uint64:\n\t\tdec = borrowDecoder(nil, 0)\n\t\tdec.length = len(data)\n\t\tdec.data = data\n\t\terr = dec.decodeUint64(vt)\n\tcase **uint64:\n\t\tdec = borrowDecoder(nil, 0)\n\t\tdec.length = len(data)\n\t\tdec.data = data\n\t\terr = dec.decodeUint64Null(vt)\n\tcase *float64:\n\t\tdec = borrowDecoder(nil, 0)\n\t\tdec.length = len(data)\n\t\tdec.data = data\n\t\terr = dec.decodeFloat64(vt)\n\tcase **float64:\n\t\tdec = borrowDecoder(nil, 0)\n\t\tdec.length = len(data)\n\t\tdec.data = data\n\t\terr = dec.decodeFloat64Null(vt)\n\tcase *float32:\n\t\tdec = borrowDecoder(nil, 0)\n\t\tdec.length = len(data)\n\t\tdec.data = data\n\t\terr = dec.decodeFloat32(vt)\n\tcase **float32:\n\t\tdec = borrowDecoder(nil, 0)\n\t\tdec.length = len(data)\n\t\tdec.data = data\n\t\terr = dec.decodeFloat32Null(vt)\n\tcase *bool:\n\t\tdec = borrowDecoder(nil, 0)\n\t\tdec.length = len(data)\n\t\tdec.data = data\n\t\terr = dec.decodeBool(vt)\n\tcase **bool:\n\t\tdec = borrowDecoder(nil, 0)\n\t\tdec.length = len(data)\n\t\tdec.data = data\n\t\terr = dec.decodeBoolNull(vt)\n\tcase UnmarshalerJSONObject:\n\t\tdec = borrowDecoder(nil, 0)\n\t\tdec.length = len(data)\n\t\tdec.data = make([]byte, len(data))\n\t\tcopy(dec.data, data)\n\t\t_, err = dec.decodeObject(vt)\n\tcase UnmarshalerJSONArray:\n\t\tdec = borrowDecoder(nil, 0)\n\t\tdec.length = len(data)\n\t\tdec.data = make([]byte, len(data))\n\t\tcopy(dec.data, data)\n\t\t_, err = dec.decodeArray(vt)\n\tcase *interface{}:\n\t\tdec = borrowDecoder(nil, 0)\n\t\tdec.length = len(data)\n\t\tdec.data = make([]byte, len(data))\n\t\tcopy(dec.data, data)\n\t\terr = dec.decodeInterface(vt)\n\tdefault:\n\t\treturn InvalidUnmarshalError(fmt.Sprintf(invalidUnmarshalErrorMsg, vt))\n\t}\n\tdefer dec.Release()\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn dec.err\n}\n\n// UnmarshalerJSONObject is the interface to implement to decode a JSON Object.\ntype UnmarshalerJSONObject interface {\n\tUnmarshalJSONObject(*Decoder, string) error\n\tNKeys() int\n}\n\n// UnmarshalerJSONArray is the interface to implement to decode a JSON Array.\ntype UnmarshalerJSONArray interface {\n\tUnmarshalJSONArray(*Decoder) error\n}\n\n// A Decoder reads and decodes JSON values from an input stream.\ntype Decoder struct {\n\tr          io.Reader\n\tdata       []byte\n\terr        error\n\tisPooled   byte\n\tcalled     byte\n\tchild      byte\n\tcursor     int\n\tlength     int\n\tkeysDone   int\n\tarrayIndex int\n}\n\n// Decode reads the next JSON-encoded value from the decoder's input (io.Reader) and stores it in the value pointed to by v.\n//\n// See the documentation for Unmarshal for details about the conversion of JSON into a Go value.\n// The differences between Decode and Unmarshal are:\n// \t- Decode reads from an io.Reader in the Decoder, whereas Unmarshal reads from a []byte\n// \t- Decode leaves to the user the option of borrowing and releasing a Decoder, whereas Unmarshal internally always borrows a Decoder and releases it when the unmarshaling is completed\nfunc (dec *Decoder) Decode(v interface{}) error {\n\tif dec.isPooled == 1 {\n\t\tpanic(InvalidUsagePooledDecoderError(\"Invalid usage of pooled decoder\"))\n\t}\n\tvar err error\n\tswitch vt := v.(type) {\n\tcase *string:\n\t\terr = dec.decodeString(vt)\n\tcase **string:\n\t\terr = dec.decodeStringNull(vt)\n\tcase *int:\n\t\terr = dec.decodeInt(vt)\n\tcase **int:\n\t\terr = dec.decodeIntNull(vt)\n\tcase *int8:\n\t\terr = dec.decodeInt8(vt)\n\tcase **int8:\n\t\terr = dec.decodeInt8Null(vt)\n\tcase *int16:\n\t\terr = dec.decodeInt16(vt)\n\tcase **int16:\n\t\terr = dec.decodeInt16Null(vt)\n\tcase *int32:\n\t\terr = dec.decodeInt32(vt)\n\tcase **int32:\n\t\terr = dec.decodeInt32Null(vt)\n\tcase *int64:\n\t\terr = dec.decodeInt64(vt)\n\tcase **int64:\n\t\terr = dec.decodeInt64Null(vt)\n\tcase *uint8:\n\t\terr = dec.decodeUint8(vt)\n\tcase **uint8:\n\t\terr = dec.decodeUint8Null(vt)\n\tcase *uint16:\n\t\terr = dec.decodeUint16(vt)\n\tcase **uint16:\n\t\terr = dec.decodeUint16Null(vt)\n\tcase *uint32:\n\t\terr = dec.decodeUint32(vt)\n\tcase **uint32:\n\t\terr = dec.decodeUint32Null(vt)\n\tcase *uint64:\n\t\terr = dec.decodeUint64(vt)\n\tcase **uint64:\n\t\terr = dec.decodeUint64Null(vt)\n\tcase *float64:\n\t\terr = dec.decodeFloat64(vt)\n\tcase **float64:\n\t\terr = dec.decodeFloat64Null(vt)\n\tcase *float32:\n\t\terr = dec.decodeFloat32(vt)\n\tcase **float32:\n\t\terr = dec.decodeFloat32Null(vt)\n\tcase *bool:\n\t\terr = dec.decodeBool(vt)\n\tcase **bool:\n\t\terr = dec.decodeBoolNull(vt)\n\tcase UnmarshalerJSONObject:\n\t\t_, err = dec.decodeObject(vt)\n\tcase UnmarshalerJSONArray:\n\t\t_, err = dec.decodeArray(vt)\n\tcase *EmbeddedJSON:\n\t\terr = dec.decodeEmbeddedJSON(vt)\n\tcase *interface{}:\n\t\terr = dec.decodeInterface(vt)\n\tdefault:\n\t\treturn InvalidUnmarshalError(fmt.Sprintf(invalidUnmarshalErrorMsg, vt))\n\t}\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn dec.err\n}\n\n// Non exported\n\nfunc isDigit(b byte) bool {\n\tswitch b {\n\tcase '0', '1', '2', '3', '4', '5', '6', '7', '8', '9':\n\t\treturn true\n\tdefault:\n\t\treturn false\n\t}\n}\n\nfunc (dec *Decoder) read() bool {\n\tif dec.r != nil {\n\t\t// if we reach the end, double the buffer to ensure there's always more space\n\t\tif len(dec.data) == dec.length {\n\t\t\tnLen := dec.length * 2\n\t\t\tif nLen == 0 {\n\t\t\t\tnLen = 512\n\t\t\t}\n\t\t\tBuf := make([]byte, nLen, nLen)\n\t\t\tcopy(Buf, dec.data)\n\t\t\tdec.data = Buf\n\t\t}\n\t\tvar n int\n\t\tvar err error\n\t\tfor n == 0 {\n\t\t\tn, err = dec.r.Read(dec.data[dec.length:])\n\t\t\tif err != nil {\n\t\t\t\tif err != io.EOF {\n\t\t\t\t\tdec.err = err\n\t\t\t\t\treturn false\n\t\t\t\t}\n\t\t\t\tif n == 0 {\n\t\t\t\t\treturn false\n\t\t\t\t}\n\t\t\t\tdec.length = dec.length + n\n\t\t\t\treturn true\n\t\t\t}\n\t\t}\n\t\tdec.length = dec.length + n\n\t\treturn true\n\t}\n\treturn false\n}\n\nfunc (dec *Decoder) nextChar() byte {\n\tfor ; dec.cursor < dec.length || dec.read(); dec.cursor++ {\n\t\tswitch dec.data[dec.cursor] {\n\t\tcase ' ', '\\n', '\\t', '\\r', ',':\n\t\t\tcontinue\n\t\t}\n\t\td := dec.data[dec.cursor]\n\t\treturn d\n\t}\n\treturn 0\n}\n"
        },
        {
          "name": "decode_array.go",
          "type": "blob",
          "size": 6.541015625,
          "content": "package gojay\n\nimport \"reflect\"\n\n// DecodeArray reads the next JSON-encoded value from the decoder's input (io.Reader)\n// and stores it in the value pointed to by v.\n//\n// v must implement UnmarshalerJSONArray.\n//\n// See the documentation for Unmarshal for details about the conversion of JSON into a Go value.\nfunc (dec *Decoder) DecodeArray(v UnmarshalerJSONArray) error {\n\tif dec.isPooled == 1 {\n\t\tpanic(InvalidUsagePooledDecoderError(\"Invalid usage of pooled decoder\"))\n\t}\n\t_, err := dec.decodeArray(v)\n\treturn err\n}\nfunc (dec *Decoder) decodeArray(arr UnmarshalerJSONArray) (int, error) {\n\t// remember last array index in case of nested arrays\n\tlastArrayIndex := dec.arrayIndex\n\tdec.arrayIndex = 0\n\tdefer func() {\n\t\tdec.arrayIndex = lastArrayIndex\n\t}()\n\tfor ; dec.cursor < dec.length || dec.read(); dec.cursor++ {\n\t\tswitch dec.data[dec.cursor] {\n\t\tcase ' ', '\\n', '\\t', '\\r', ',':\n\t\t\tcontinue\n\t\tcase '[':\n\t\t\tdec.cursor = dec.cursor + 1\n\t\t\t// array is open, char is not space start readings\n\t\t\tfor dec.nextChar() != 0 {\n\t\t\t\t// closing array\n\t\t\t\tif dec.data[dec.cursor] == ']' {\n\t\t\t\t\tdec.cursor = dec.cursor + 1\n\t\t\t\t\treturn dec.cursor, nil\n\t\t\t\t}\n\t\t\t\t// calling unmarshall function for each element of the slice\n\t\t\t\terr := arr.UnmarshalJSONArray(dec)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn 0, err\n\t\t\t\t}\n\t\t\t\tdec.arrayIndex++\n\t\t\t}\n\t\t\treturn 0, dec.raiseInvalidJSONErr(dec.cursor)\n\t\tcase 'n':\n\t\t\t// is null\n\t\t\tdec.cursor++\n\t\t\terr := dec.assertNull()\n\t\t\tif err != nil {\n\t\t\t\treturn 0, err\n\t\t\t}\n\t\t\treturn dec.cursor, nil\n\t\tcase '{', '\"', 'f', 't', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9':\n\t\t\t// can't unmarshall to struct\n\t\t\t// we skip array and set Error\n\t\t\tdec.err = dec.makeInvalidUnmarshalErr(arr)\n\t\t\terr := dec.skipData()\n\t\t\tif err != nil {\n\t\t\t\treturn 0, err\n\t\t\t}\n\t\t\treturn dec.cursor, nil\n\t\tdefault:\n\t\t\treturn 0, dec.raiseInvalidJSONErr(dec.cursor)\n\t\t}\n\t}\n\treturn 0, dec.raiseInvalidJSONErr(dec.cursor)\n}\nfunc (dec *Decoder) decodeArrayNull(v interface{}) (int, error) {\n\t// remember last array index in case of nested arrays\n\tlastArrayIndex := dec.arrayIndex\n\tdec.arrayIndex = 0\n\tdefer func() {\n\t\tdec.arrayIndex = lastArrayIndex\n\t}()\n\tvv := reflect.ValueOf(v)\n\tvvt := vv.Type()\n\tif vvt.Kind() != reflect.Ptr || vvt.Elem().Kind() != reflect.Ptr {\n\t\tdec.err = ErrUnmarshalPtrExpected\n\t\treturn 0, dec.err\n\t}\n\t// not an array not an error, but do not know what to do\n\t// do not check syntax\n\tfor ; dec.cursor < dec.length || dec.read(); dec.cursor++ {\n\t\tswitch dec.data[dec.cursor] {\n\t\tcase ' ', '\\n', '\\t', '\\r', ',':\n\t\t\tcontinue\n\t\tcase '[':\n\t\t\tdec.cursor = dec.cursor + 1\n\t\t\t// create our new type\n\t\t\telt := vv.Elem()\n\t\t\tn := reflect.New(elt.Type().Elem())\n\t\t\tvar arr UnmarshalerJSONArray\n\t\t\tvar ok bool\n\t\t\tif arr, ok = n.Interface().(UnmarshalerJSONArray); !ok {\n\t\t\t\tdec.err = dec.makeInvalidUnmarshalErr((UnmarshalerJSONArray)(nil))\n\t\t\t\treturn 0, dec.err\n\t\t\t}\n\t\t\t// array is open, char is not space start readings\n\t\t\tfor dec.nextChar() != 0 {\n\t\t\t\t// closing array\n\t\t\t\tif dec.data[dec.cursor] == ']' {\n\t\t\t\t\telt.Set(n)\n\t\t\t\t\tdec.cursor = dec.cursor + 1\n\t\t\t\t\treturn dec.cursor, nil\n\t\t\t\t}\n\t\t\t\t// calling unmarshall function for each element of the slice\n\t\t\t\terr := arr.UnmarshalJSONArray(dec)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn 0, err\n\t\t\t\t}\n\t\t\t\tdec.arrayIndex++\n\t\t\t}\n\t\t\treturn 0, dec.raiseInvalidJSONErr(dec.cursor)\n\t\tcase 'n':\n\t\t\t// is null\n\t\t\tdec.cursor++\n\t\t\terr := dec.assertNull()\n\t\t\tif err != nil {\n\t\t\t\treturn 0, err\n\t\t\t}\n\t\t\treturn dec.cursor, nil\n\t\tcase '{', '\"', 'f', 't', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9':\n\t\t\t// can't unmarshall to struct\n\t\t\t// we skip array and set Error\n\t\t\tdec.err = dec.makeInvalidUnmarshalErr((UnmarshalerJSONArray)(nil))\n\t\t\terr := dec.skipData()\n\t\t\tif err != nil {\n\t\t\t\treturn 0, err\n\t\t\t}\n\t\t\treturn dec.cursor, nil\n\t\tdefault:\n\t\t\treturn 0, dec.raiseInvalidJSONErr(dec.cursor)\n\t\t}\n\t}\n\treturn 0, dec.raiseInvalidJSONErr(dec.cursor)\n}\n\nfunc (dec *Decoder) skipArray() (int, error) {\n\tvar arraysOpen = 1\n\tvar arraysClosed = 0\n\t// var stringOpen byte = 0\n\tfor j := dec.cursor; j < dec.length || dec.read(); j++ {\n\t\tswitch dec.data[j] {\n\t\tcase ']':\n\t\t\tarraysClosed++\n\t\t\t// everything is closed return\n\t\t\tif arraysOpen == arraysClosed {\n\t\t\t\t// add char to object data\n\t\t\t\treturn j + 1, nil\n\t\t\t}\n\t\tcase '[':\n\t\t\tarraysOpen++\n\t\tcase '\"':\n\t\t\tj++\n\t\t\tvar isInEscapeSeq bool\n\t\t\tvar isFirstQuote = true\n\t\t\tfor ; j < dec.length || dec.read(); j++ {\n\t\t\t\tif dec.data[j] != '\"' {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\tif dec.data[j-1] != '\\\\' || (!isInEscapeSeq && !isFirstQuote) {\n\t\t\t\t\tbreak\n\t\t\t\t} else {\n\t\t\t\t\tisInEscapeSeq = false\n\t\t\t\t}\n\t\t\t\tif isFirstQuote {\n\t\t\t\t\tisFirstQuote = false\n\t\t\t\t}\n\t\t\t\t// loop backward and count how many anti slash found\n\t\t\t\t// to see if string is effectively escaped\n\t\t\t\tct := 0\n\t\t\t\tfor i := j - 1; i > 0; i-- {\n\t\t\t\t\tif dec.data[i] != '\\\\' {\n\t\t\t\t\t\tbreak\n\t\t\t\t\t}\n\t\t\t\t\tct++\n\t\t\t\t}\n\t\t\t\t// is pair number of slashes, quote is not escaped\n\t\t\t\tif ct&1 == 0 {\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t\tisInEscapeSeq = true\n\t\t\t}\n\t\tdefault:\n\t\t\tcontinue\n\t\t}\n\t}\n\treturn 0, dec.raiseInvalidJSONErr(dec.cursor)\n}\n\n// DecodeArrayFunc is a func type implementing UnmarshalerJSONArray.\n// Use it to cast a `func(*Decoder) error` to Unmarshal an array on the fly.\n\ntype DecodeArrayFunc func(*Decoder) error\n\n// UnmarshalJSONArray implements UnmarshalerJSONArray.\nfunc (f DecodeArrayFunc) UnmarshalJSONArray(dec *Decoder) error {\n\treturn f(dec)\n}\n\n// IsNil implements UnmarshalerJSONArray.\nfunc (f DecodeArrayFunc) IsNil() bool {\n\treturn f == nil\n}\n\n// Add Values functions\n\n// AddArray decodes the JSON value within an object or an array to a UnmarshalerJSONArray.\nfunc (dec *Decoder) AddArray(v UnmarshalerJSONArray) error {\n\treturn dec.Array(v)\n}\n\n// AddArrayNull decodes the JSON value within an object or an array to a UnmarshalerJSONArray.\nfunc (dec *Decoder) AddArrayNull(v interface{}) error {\n\treturn dec.ArrayNull(v)\n}\n\n// Array decodes the JSON value within an object or an array to a UnmarshalerJSONArray.\nfunc (dec *Decoder) Array(v UnmarshalerJSONArray) error {\n\tnewCursor, err := dec.decodeArray(v)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdec.cursor = newCursor\n\tdec.called |= 1\n\treturn nil\n}\n\n// ArrayNull decodes the JSON value within an object or an array to a UnmarshalerJSONArray.\n// v should be a pointer to an UnmarshalerJSONArray,\n// if `null` value is encountered in JSON, it will leave the value v untouched,\n// else it will create a new instance of the UnmarshalerJSONArray behind v.\nfunc (dec *Decoder) ArrayNull(v interface{}) error {\n\tnewCursor, err := dec.decodeArrayNull(v)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdec.cursor = newCursor\n\tdec.called |= 1\n\treturn nil\n}\n\n// Index returns the index of an array being decoded.\nfunc (dec *Decoder) Index() int {\n\treturn dec.arrayIndex\n}\n"
        },
        {
          "name": "decode_array_test.go",
          "type": "blob",
          "size": 19.2578125,
          "content": "package gojay\n\nimport (\n\t\"strings\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\ntype testSliceInts []int\n\nfunc (t *testSliceInts) UnmarshalJSONArray(dec *Decoder) error {\n\ti := 0\n\tif err := dec.AddInt(&i); err != nil {\n\t\treturn err\n\t}\n\t*t = append(*t, i)\n\treturn nil\n}\n\nfunc TestSliceInts(t *testing.T) {\n\ttestCases := []struct {\n\t\tname           string\n\t\tjson           string\n\t\texpectedResult testSliceInts\n\t\terr            bool\n\t\terrType        interface{}\n\t}{\n\t\t{\n\t\t\tname:           \"basic-test\",\n\t\t\tjson:           \"[1,2,3,43567788543,45777655,432,0]\",\n\t\t\texpectedResult: testSliceInts{1, 2, 3, 43567788543, 45777655, 432, 0},\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-test\",\n\t\t\tjson:           \"[1,2,3,43567788543,null,432,0]\",\n\t\t\texpectedResult: testSliceInts{1, 2, 3, 43567788543, 0, 432, 0},\n\t\t},\n\t\t{\n\t\t\tname:           \"empty\",\n\t\t\tjson:           \"[]\",\n\t\t\texpectedResult: testSliceInts{},\n\t\t},\n\t\t{\n\t\t\tname:           \"invalid-json\",\n\t\t\tjson:           \"[\",\n\t\t\texpectedResult: testSliceInts{},\n\t\t\terr:            true,\n\t\t},\n\t\t{\n\t\t\tname:           \"floats\",\n\t\t\tjson:           \"[1,2,3,43567788543,457.7765,432,0,0.45]\",\n\t\t\texpectedResult: testSliceInts{1, 2, 3, 43567788543, 457, 432, 0, 0},\n\t\t},\n\t\t{\n\t\t\tname:           \"invalid-type\",\n\t\t\tjson:           `[1,2,3,43567788543,457.7765,432,0,\"test\"]`,\n\t\t\texpectedResult: testSliceInts{1, 2, 3, 43567788543, 457, 432, 0, 0},\n\t\t\terr:            true,\n\t\t\terrType:        InvalidUnmarshalError(\"\"),\n\t\t},\n\t\t{\n\t\t\tname:           \"invalid-json\",\n\t\t\tjson:           `[1,2,3\",43567788543,457.7765,432,0,\"test\"]`,\n\t\t\texpectedResult: testSliceInts{1, 2, 3, 43567788543, 457, 432, 0, 0},\n\t\t\terr:            true,\n\t\t\terrType:        InvalidJSONError(\"\"),\n\t\t},\n\t}\n\n\tfor _, testCase := range testCases {\n\t\ts := make(testSliceInts, 0)\n\t\tdec := BorrowDecoder(strings.NewReader(testCase.json))\n\t\tdefer dec.Release()\n\t\terr := dec.Decode(&s)\n\t\tif testCase.err {\n\t\t\tassert.NotNil(t, err, \"err should not be nil\")\n\t\t\tif testCase.errType != nil {\n\t\t\t\tassert.IsType(t, testCase.errType, err, \"err should be of the given type\")\n\t\t\t}\n\t\t\tcontinue\n\t\t}\n\t\tfor k, v := range testCase.expectedResult {\n\t\t\tassert.Equal(t, v, s[k], \"value at given index should be the same as expected results\")\n\t\t}\n\t}\n}\n\ntype testSliceStrings []string\n\nfunc (t *testSliceStrings) UnmarshalJSONArray(dec *Decoder) error {\n\tstr := \"\"\n\tif err := dec.AddString(&str); err != nil {\n\t\treturn err\n\t}\n\t*t = append(*t, str)\n\treturn nil\n}\n\nfunc TestSliceStrings(t *testing.T) {\n\ttestCases := []struct {\n\t\tname           string\n\t\tjson           string\n\t\texpectedResult testSliceStrings\n\t\terr            bool\n\t\terrType        interface{}\n\t}{\n\t\t{\n\t\t\tname:           \"basic-test\",\n\t\t\tjson:           `[\"hello world\", \"hey\" , \"foo\",\"bar\"]`,\n\t\t\texpectedResult: testSliceStrings{\"hello world\", \"hey\", \"foo\", \"bar\"},\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-test\",\n\t\t\tjson:           `[\"hello world\", \"hey\" , \"foo\",\"bar \\n escape\"]`,\n\t\t\texpectedResult: testSliceStrings{\"hello world\", \"hey\", \"foo\", \"bar \\n escape\"},\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-test\",\n\t\t\tjson:           `[\"hello world\", \"hey\" , null,\"bar \\n escape\"]`,\n\t\t\texpectedResult: testSliceStrings{\"hello world\", \"hey\", \"\", \"bar \\n escape\"},\n\t\t},\n\t\t{\n\t\t\tname:           \"invalid-type\",\n\t\t\tjson:           `[\"foo\",1,2,3,\"test\"]`,\n\t\t\texpectedResult: testSliceStrings{},\n\t\t\terr:            true,\n\t\t\terrType:        InvalidUnmarshalError(\"\"),\n\t\t},\n\t\t{\n\t\t\tname:           \"invalid-json\",\n\t\t\tjson:           `[\"hello world]`,\n\t\t\texpectedResult: testSliceStrings{},\n\t\t\terr:            true,\n\t\t\terrType:        InvalidJSONError(\"\"),\n\t\t},\n\t}\n\n\tfor _, testCase := range testCases {\n\t\tt.Run(testCase.name, func(t *testing.T) {\n\t\t\ts := make(testSliceStrings, 0)\n\t\t\tdec := BorrowDecoder(strings.NewReader(testCase.json))\n\t\t\tdefer dec.Release()\n\t\t\terr := dec.Decode(&s)\n\t\t\tif testCase.err {\n\t\t\t\tassert.NotNil(t, err, \"err should not be nil\")\n\t\t\t\tif testCase.errType != nil {\n\t\t\t\t\tassert.IsType(t, testCase.errType, err, \"err should be of the given type\")\n\t\t\t\t}\n\t\t\t\treturn\n\t\t\t}\n\t\t\tassert.Nil(t, err, \"err should be nil\")\n\t\t\tfor k, v := range testCase.expectedResult {\n\t\t\t\tassert.Equal(t, v, s[k], \"value at given index should be the same as expected results\")\n\t\t\t}\n\t\t})\n\t}\n}\n\ntype testSliceBools []bool\n\nfunc (t *testSliceBools) UnmarshalJSONArray(dec *Decoder) error {\n\tb := false\n\tif err := dec.AddBool(&b); err != nil {\n\t\treturn err\n\t}\n\t*t = append(*t, b)\n\treturn nil\n}\n\nfunc TestSliceBools(t *testing.T) {\n\ttestCases := []struct {\n\t\tname           string\n\t\tjson           string\n\t\texpectedResult testSliceBools\n\t\terr            bool\n\t\terrType        interface{}\n\t}{\n\t\t{\n\t\t\tname:           \"basic-test\",\n\t\t\tjson:           `[true, false, false, true, true, false]`,\n\t\t\texpectedResult: testSliceBools{true, false, false, true, true, false},\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-test2\",\n\t\t\tjson:           `[true, false, false, true, null,null,true,false]`,\n\t\t\texpectedResult: testSliceBools{true, false, false, true, false, false, true, false},\n\t\t},\n\t\t{\n\t\t\tname:           \"invalid-type\",\n\t\t\tjson:           `[\"foo\",1,2,3,\"test\"]`,\n\t\t\texpectedResult: testSliceBools{},\n\t\t\terr:            true,\n\t\t\terrType:        InvalidUnmarshalError(\"\"),\n\t\t},\n\t\t{\n\t\t\tname:           \"invalid-json\",\n\t\t\tjson:           `[\"hello world]`,\n\t\t\texpectedResult: testSliceBools{},\n\t\t\terr:            true,\n\t\t\terrType:        InvalidJSONError(\"\"),\n\t\t},\n\t}\n\n\tfor _, testCase := range testCases {\n\t\tt.Run(testCase.name, func(t *testing.T) {\n\t\t\ts := make(testSliceBools, 0)\n\t\t\tdec := BorrowDecoder(strings.NewReader(testCase.json))\n\t\t\tdefer dec.Release()\n\t\t\terr := dec.Decode(&s)\n\t\t\tif testCase.err {\n\t\t\t\tassert.NotNil(t, err, \"err should not be nil\")\n\t\t\t\tif testCase.errType != nil {\n\t\t\t\t\tassert.IsType(t, testCase.errType, err, \"err should be of the given type\")\n\t\t\t\t}\n\t\t\t\treturn\n\t\t\t}\n\t\t\tassert.Nil(t, err, \"err should be nil\")\n\t\t\tfor k, v := range testCase.expectedResult {\n\t\t\t\tassert.Equal(t, v, s[k], \"value at given index should be the same as expected results\")\n\t\t\t}\n\t\t})\n\t}\n}\n\ntype testSliceSlicesSlices []testSliceInts\n\nfunc (t *testSliceSlicesSlices) UnmarshalJSONArray(dec *Decoder) error {\n\tsl := make(testSliceInts, 0)\n\tif err := dec.AddArray(&sl); err != nil {\n\t\treturn err\n\t}\n\t*t = append(*t, sl)\n\treturn nil\n}\n\nfunc TestSliceSlices(t *testing.T) {\n\ttestCases := []struct {\n\t\tname           string\n\t\tjson           string\n\t\texpectedResult testSliceSlicesSlices\n\t\terr            bool\n\t\terrType        interface{}\n\t}{\n\t\t{\n\t\t\tname:           \"basic-test\",\n\t\t\tjson:           `[[1,2],[1,2],[1,2]]`,\n\t\t\texpectedResult: testSliceSlicesSlices{testSliceInts{1, 2}, testSliceInts{1, 2}, testSliceInts{1, 2}},\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-test\",\n\t\t\tjson:           `[[1,2],null,[1,2]]`,\n\t\t\texpectedResult: testSliceSlicesSlices{testSliceInts{1, 2}, testSliceInts{}, testSliceInts{1, 2}},\n\t\t},\n\t\t{\n\t\t\tname:           \"invalid-type\",\n\t\t\tjson:           `[\"foo\",1,2,3,\"test\"]`,\n\t\t\texpectedResult: testSliceSlicesSlices{},\n\t\t\terr:            true,\n\t\t\terrType:        InvalidUnmarshalError(\"\"),\n\t\t},\n\t\t{\n\t\t\tname:           \"invalid-json\",\n\t\t\tjson:           `[\"hello world]`,\n\t\t\texpectedResult: testSliceSlicesSlices{},\n\t\t\terr:            true,\n\t\t\terrType:        InvalidJSONError(\"\"),\n\t\t},\n\t}\n\n\tfor _, testCase := range testCases {\n\t\tt.Run(testCase.name, func(t *testing.T) {\n\t\t\ts := make(testSliceSlicesSlices, 0)\n\t\t\tdec := BorrowDecoder(strings.NewReader(testCase.json))\n\t\t\tdefer dec.Release()\n\t\t\terr := dec.Decode(&s)\n\t\t\tif testCase.err {\n\t\t\t\tassert.NotNil(t, err, \"err should not be nil\")\n\t\t\t\tif testCase.errType != nil {\n\t\t\t\t\tassert.IsType(t, testCase.errType, err, \"err should be of the given type\")\n\t\t\t\t}\n\t\t\t\treturn\n\t\t\t}\n\t\t\tassert.Nil(t, err, \"err should be nil\")\n\t\t\tfor k, v := range testCase.expectedResult {\n\t\t\t\tassert.Equal(t, v, s[k], \"value at given index should be the same as expected results\")\n\t\t\t}\n\t\t})\n\t}\n}\n\ntype testSliceObjects []*testObject\n\nfunc (t *testSliceObjects) UnmarshalJSONArray(dec *Decoder) error {\n\tobj := &testObject{}\n\t*t = append(*t, obj)\n\treturn dec.AddObject(obj)\n}\n\nfunc TestSliceObjects(t *testing.T) {\n\ttestCases := []struct {\n\t\tname           string\n\t\tjson           string\n\t\texpectedResult testSliceObjects\n\t\terr            bool\n\t\terrType        interface{}\n\t}{\n\t\t{\n\t\t\tname: \"basic-test\",\n\t\t\tjson: `[{\"testStr\":\"foo bar\",\"testInt\":123},{\"testStr\":\"foo bar\",\"testInt\":123}]`,\n\t\t\texpectedResult: testSliceObjects{\n\t\t\t\t&testObject{\n\t\t\t\t\ttestStr: \"foo bar\",\n\t\t\t\t\ttestInt: 123,\n\t\t\t\t},\n\t\t\t\t&testObject{\n\t\t\t\t\ttestStr: \"foo bar\",\n\t\t\t\t\ttestInt: 123,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"basic-test\",\n\t\t\tjson: `[{\"testStr\":\"foo bar\",\"testInt\":123},null,{\"testStr\":\"foo bar\",\"testInt\":123}]`,\n\t\t\texpectedResult: testSliceObjects{\n\t\t\t\t&testObject{\n\t\t\t\t\ttestStr: \"foo bar\",\n\t\t\t\t\ttestInt: 123,\n\t\t\t\t},\n\t\t\t\t&testObject{},\n\t\t\t\t&testObject{\n\t\t\t\t\ttestStr: \"foo bar\",\n\t\t\t\t\ttestInt: 123,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname:           \"invalid-type\",\n\t\t\tjson:           `[\"foo\",1,2,3,\"test\"]`,\n\t\t\texpectedResult: testSliceObjects{},\n\t\t\terr:            true,\n\t\t\terrType:        InvalidUnmarshalError(\"\"),\n\t\t},\n\t\t{\n\t\t\tname:           \"invalid-json\",\n\t\t\tjson:           `[\"hello world]`,\n\t\t\texpectedResult: testSliceObjects{},\n\t\t\terr:            true,\n\t\t\terrType:        InvalidJSONError(\"\"),\n\t\t},\n\t}\n\n\tfor _, testCase := range testCases {\n\t\tt.Run(testCase.name, func(t *testing.T) {\n\t\t\ts := make(testSliceObjects, 0)\n\t\t\tdec := BorrowDecoder(strings.NewReader(testCase.json))\n\t\t\tdefer dec.Release()\n\t\t\terr := dec.Decode(&s)\n\t\t\tif testCase.err {\n\t\t\t\tassert.NotNil(t, err, \"err should not be nil\")\n\t\t\t\tif testCase.errType != nil {\n\t\t\t\t\tassert.IsType(t, testCase.errType, err, \"err should be of the given type\")\n\t\t\t\t}\n\t\t\t\treturn\n\t\t\t}\n\t\t\tassert.Nil(t, err, \"err should be nil\")\n\t\t\tfor k, v := range testCase.expectedResult {\n\t\t\t\tassert.Equal(t, *v, *s[k], \"value at given index should be the same as expected results\")\n\t\t\t}\n\t\t})\n\t}\n}\n\ntype ArrayNull []string\n\nfunc (a *ArrayNull) UnmarshalJSONArray(dec *Decoder) error {\n\tvar str string\n\tif err := dec.String(&str); err != nil {\n\t\treturn err\n\t}\n\t*a = append(*a, str)\n\treturn nil\n}\n\ntype ObjectArrayNull struct {\n\tSubArray *ArrayNull\n}\n\nfunc (o *ObjectArrayNull) UnmarshalJSONObject(dec *Decoder, k string) error {\n\tswitch k {\n\tcase \"subarray\":\n\t\treturn dec.ArrayNull(&o.SubArray)\n\t}\n\treturn nil\n}\n\nfunc (o *ObjectArrayNull) NKeys() int {\n\treturn 1\n}\n\nfunc TestDecodeArrayNullPtr(t *testing.T) {\n\tt.Run(\"sub obj should not be nil\", func(t *testing.T) {\n\t\tvar o = &ObjectArrayNull{}\n\t\tvar err = UnmarshalJSONObject([]byte(`{\"subarray\": [\"test\"]}`), o)\n\t\tassert.Nil(t, err)\n\t\tassert.NotNil(t, o.SubArray)\n\t\tassert.Len(t, *o.SubArray, 1)\n\t})\n\tt.Run(\"sub array should be nil\", func(t *testing.T) {\n\t\tvar o = &ObjectArrayNull{}\n\t\tvar err = UnmarshalJSONObject([]byte(`{\"subarray\": null}`), o)\n\t\tassert.Nil(t, err)\n\t\tassert.Nil(t, o.SubArray)\n\t})\n\tt.Run(\"sub array err, not closing arr\", func(t *testing.T) {\n\t\tvar o = &ObjectArrayNull{}\n\t\tvar err = UnmarshalJSONObject([]byte(`{\"subarray\": [    `), o)\n\t\tassert.NotNil(t, err)\n\t})\n\tt.Run(\"sub array err, invalid string\", func(t *testing.T) {\n\t\tvar o = &ObjectArrayNull{}\n\t\tvar err = UnmarshalJSONObject([]byte(`{\"subarray\":[\",]}`), o)\n\t\tassert.NotNil(t, err)\n\t})\n\tt.Run(\"sub array err, invalid null\", func(t *testing.T) {\n\t\tvar o = &ObjectArrayNull{}\n\t\tvar err = UnmarshalJSONObject([]byte(`{\"subarray\":nll}`), o)\n\t\tassert.NotNil(t, err)\n\t})\n\tt.Run(\"sub array err, empty\", func(t *testing.T) {\n\t\tvar o = &ObjectArrayNull{}\n\t\tvar err = UnmarshalJSONObject([]byte(`{\"subarray\":`), o)\n\t\tassert.NotNil(t, err)\n\t})\n}\n\ntype testChannelArray chan *TestObj\n\nfunc (c *testChannelArray) UnmarshalJSONArray(dec *Decoder) error {\n\tobj := &TestObj{}\n\tif err := dec.AddObject(obj); err != nil {\n\t\treturn err\n\t}\n\t*c <- obj\n\treturn nil\n}\n\nfunc TestDecoderSliceNull(t *testing.T) {\n\tjson := []byte(`null`)\n\tv := &testSliceStrings{}\n\terr := Unmarshal(json, v)\n\tassert.Nil(t, err, \"Err must be nil\")\n\tassert.Equal(t, len(*v), 0, \"v must be of len 0\")\n}\n\nfunc TestDecodeSliceInvalidType(t *testing.T) {\n\tresult := testSliceObjects{}\n\terr := UnmarshalJSONArray([]byte(`{}`), &result)\n\tassert.NotNil(t, err, \"err should not be nil\")\n\tassert.IsType(t, InvalidUnmarshalError(\"\"), err, \"err should be of type InvalidUnmarshalError\")\n\tassert.Equal(t, \"Cannot unmarshal JSON to type '*gojay.testSliceObjects'\", err.Error(), \"err should not be nil\")\n}\n\nfunc TestDecoderChannelOfObjectsBasic(t *testing.T) {\n\tjson := []byte(`[\n\t\t{\n\t\t\t\"test\": 245,\n\t\t\t\"test2\": -246,\n\t\t\t\"test3\": \"string\"\n\t\t},\n\t\t{\n\t\t\t\"test\": 247,\n\t\t\t\"test2\": 248,\n\t\t\t\"test3\": \"string\"\n\t\t},\n\t\t{\n\t\t\t\"test\": 777,\n\t\t\t\"test2\": 456,\n\t\t\t\"test3\": \"string\"\n\t\t}\n\t]`)\n\ttestChan := testChannelArray(make(chan *TestObj, 3))\n\terr := UnmarshalJSONArray(json, &testChan)\n\tassert.Nil(t, err, \"Err must be nil\")\n\tct := 0\n\tl := len(testChan)\n\tfor range testChan {\n\t\tct++\n\t\tif ct == l {\n\t\t\tbreak\n\t\t}\n\t}\n\tassert.Equal(t, ct, 3)\n}\n\nfunc TestDecoderSliceInvalidJSON(t *testing.T) {\n\tjson := []byte(`hello`)\n\ttestArr := testSliceInts{}\n\terr := UnmarshalJSONArray(json, &testArr)\n\tassert.NotNil(t, err, \"Err must not be nil as JSON is invalid\")\n\tassert.IsType(t, InvalidJSONError(\"\"), err, \"err message must be 'Invalid JSON'\")\n}\n\nfunc TestDecoderSliceDecoderAPI(t *testing.T) {\n\tjson := `[\"string\",\"string1\"]`\n\ttestArr := testSliceStrings{}\n\tdec := NewDecoder(strings.NewReader(json))\n\terr := dec.DecodeArray(&testArr)\n\tassert.Nil(t, err, \"Err must be nil\")\n\tassert.Len(t, testArr, 2, \"testArr should be of len 2\")\n\tassert.Equal(t, \"string\", testArr[0], \"testArr[0] should be 'string'\")\n\tassert.Equal(t, \"string1\", testArr[1], \"testArr[1] should be 'string1'\")\n}\n\nfunc TestDecoderSliceDecoderAPIError(t *testing.T) {\n\ttestArr := testSliceInts{}\n\tdec := NewDecoder(strings.NewReader(`hello`))\n\terr := dec.DecodeArray(&testArr)\n\tassert.NotNil(t, err, \"Err must not be nil as JSON is invalid\")\n\tassert.IsType(t, InvalidJSONError(\"\"), err, \"err message must be 'Invalid JSON'\")\n}\n\nfunc TestUnmarshalJSONArrays(t *testing.T) {\n\ttestCases := []struct {\n\t\tname         string\n\t\tv            UnmarshalerJSONArray\n\t\td            []byte\n\t\texpectations func(err error, v interface{}, t *testing.T)\n\t}{\n\t\t{\n\t\t\tv:    new(testDecodeSlice),\n\t\t\td:    []byte(`[{\"test\":\"test\"}]`),\n\t\t\tname: \"test decode slice\",\n\t\t\texpectations: func(err error, v interface{}, t *testing.T) {\n\t\t\t\tvtPtr := v.(*testDecodeSlice)\n\t\t\t\tvt := *vtPtr\n\t\t\t\tassert.Nil(t, err, \"err must be nil\")\n\t\t\t\tassert.Len(t, vt, 1, \"len of vt must be 1\")\n\t\t\t\tassert.Equal(t, \"test\", vt[0].test, \"vt[0].test must be equal to 'test'\")\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tv:    new(testDecodeSlice),\n\t\t\td:    []byte(`[{\"test\":\"test\"},{\"test\":\"test2\"}]`),\n\t\t\tname: \"test decode slice\",\n\t\t\texpectations: func(err error, v interface{}, t *testing.T) {\n\t\t\t\tvtPtr := v.(*testDecodeSlice)\n\t\t\t\tvt := *vtPtr\n\t\t\t\tassert.Nil(t, err, \"err must be nil\")\n\t\t\t\tassert.Len(t, vt, 2, \"len of vt must be 2\")\n\t\t\t\tassert.Equal(t, \"test\", vt[0].test, \"vt[0].test must be equal to 'test'\")\n\t\t\t\tassert.Equal(t, \"test2\", vt[1].test, \"vt[1].test must be equal to 'test2'\")\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tv:    new(testDecodeSlice),\n\t\t\td:    []byte(`invalid json`),\n\t\t\tname: \"test decode object null\",\n\t\t\texpectations: func(err error, v interface{}, t *testing.T) {\n\t\t\t\tassert.NotNil(t, err, \"err must not be nil\")\n\t\t\t\tassert.IsType(t, InvalidJSONError(\"\"), err, \"err must be of type InvalidJSONError\")\n\t\t\t},\n\t\t},\n\t}\n\tfor _, testCase := range testCases {\n\t\ttestCase := testCase\n\t\tt.Run(testCase.name, func(*testing.T) {\n\t\t\terr := UnmarshalJSONArray(testCase.d, testCase.v)\n\t\t\ttestCase.expectations(err, testCase.v, t)\n\t\t})\n\t}\n}\n\nfunc TestSkipArray(t *testing.T) {\n\ttestCases := []struct {\n\t\tname         string\n\t\tjson         string\n\t\texpectations func(*testing.T, int, error)\n\t}{\n\t\t{\n\t\t\tname: \"basic\",\n\t\t\tjson: `\"testbasic\"]`,\n\t\t\texpectations: func(t *testing.T, i int, err error) {\n\t\t\t\tassert.Equal(t, len(`\"testbasic\"]`), i)\n\t\t\t\tassert.Nil(t, err)\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"complex escape string\",\n\t\t\tjson: `\"test \\\\\\\\\\\" escape\"]`,\n\t\t\texpectations: func(t *testing.T, i int, err error) {\n\t\t\t\tassert.Equal(t, len(`\"test \\\\\\\\\\\" escape\"]`), i)\n\t\t\t\tassert.Nil(t, err)\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"complex escape slash\",\n\t\t\tjson: `\"test \\\\\\\\\\\\\"]`,\n\t\t\texpectations: func(t *testing.T, i int, err error) {\n\t\t\t\tassert.Equal(t, len(`\"test \\\\\\\\\\\\\"]`), i)\n\t\t\t\tassert.Nil(t, err)\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tjson: `\"test \\n\"]`,\n\t\t\texpectations: func(t *testing.T, i int, err error) {\n\t\t\t\tassert.Equal(t, len(`\"test \\n\"]`), i)\n\t\t\t\tassert.Nil(t, err)\n\t\t\t},\n\t\t},\n\t}\n\n\tfor _, test := range testCases {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tdec := NewDecoder(strings.NewReader(test.json))\n\t\t\ti, err := dec.skipArray()\n\t\t\ttest.expectations(t, i, err)\n\t\t})\n\t}\n}\n\nfunc TestDecodeArrayEmpty(t *testing.T) {\n\tv := new(testDecodeSlice)\n\tdec := NewDecoder(strings.NewReader(\"\"))\n\terr := dec.Decode(v)\n\tassert.NotNil(t, err, \"err should not be nil\")\n\tassert.IsType(t, InvalidJSONError(\"\"), err, \"err should be of type InvalidJSONError\")\n}\n\nfunc TestDecodeArraySkipError(t *testing.T) {\n\tv := new(testDecodeSlice)\n\tdec := NewDecoder(strings.NewReader(\"34fef\"))\n\terr := dec.Decode(v)\n\tassert.NotNil(t, err, \"err should not be nil\")\n\tassert.IsType(t, InvalidJSONError(\"\"), err, \"err should be of type InvalidJSONError\")\n}\n\nfunc TestDecodeArrayNullError(t *testing.T) {\n\tv := new(testDecodeSlice)\n\tdec := NewDecoder(strings.NewReader(\"nall\"))\n\terr := dec.Decode(v)\n\tassert.NotNil(t, err, \"err should not be nil\")\n\tassert.IsType(t, InvalidJSONError(\"\"), err, \"err should be of type InvalidJSONError\")\n}\n\nfunc TestDecoderArrayFunc(t *testing.T) {\n\tvar f DecodeArrayFunc\n\tassert.True(t, f.IsNil())\n}\n\ntype testArrayStrings [3]string\n\nfunc (a *testArrayStrings) UnmarshalJSONArray(dec *Decoder) error {\n\tvar str string\n\tif err := dec.String(&str); err != nil {\n\t\treturn err\n\t}\n\ta[dec.Index()] = str\n\treturn nil\n}\n\nfunc TestArrayStrings(t *testing.T) {\n\tdata := []byte(`[\"a\", \"b\", \"c\"]`)\n\tarr := testArrayStrings{}\n\terr := Unmarshal(data, &arr)\n\tassert.Nil(t, err, \"err must be nil\")\n\tassert.Equal(t, \"a\", arr[0], \"arr[0] must be equal to 'a'\")\n\tassert.Equal(t, \"b\", arr[1], \"arr[1] must be equal to 'b'\")\n\tassert.Equal(t, \"c\", arr[2], \"arr[2] must be equal to 'c'\")\n}\n\ntype testSliceArraysStrings struct {\n\tarrays []testArrayStrings\n\tt      *testing.T\n}\n\nfunc (s *testSliceArraysStrings) UnmarshalJSONArray(dec *Decoder) error {\n\tvar a testArrayStrings\n\tassert.Equal(s.t, len(s.arrays), dec.Index(), \"decoded array index must be equal to current slice len\")\n\tif err := dec.AddArray(&a); err != nil {\n\t\treturn err\n\t}\n\tassert.Equal(s.t, len(s.arrays), dec.Index(), \"decoded array index must be equal to current slice len\")\n\ts.arrays = append(s.arrays, a)\n\treturn nil\n}\n\nfunc TestIndex(t *testing.T) {\n\ttestCases := []struct {\n\t\tname           string\n\t\tjson           string\n\t\texpectedResult []testArrayStrings\n\t}{\n\t\t{\n\t\t\tname:           \"basic-test\",\n\t\t\tjson:           `[[\"a\",\"b\",\"c\"],[\"1\",\"2\",\"3\"],[\"x\",\"y\",\"z\"]]`,\n\t\t\texpectedResult: []testArrayStrings{{\"a\", \"b\", \"c\"}, {\"1\", \"2\", \"3\"}, {\"x\", \"y\", \"z\"}},\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-test-null\",\n\t\t\tjson:           `[[\"a\",\"b\",\"c\"],null,[\"x\",\"y\",\"z\"]]`,\n\t\t\texpectedResult: []testArrayStrings{{\"a\", \"b\", \"c\"}, {\"\", \"\", \"\"}, {\"x\", \"y\", \"z\"}},\n\t\t},\n\t}\n\n\tfor _, testCase := range testCases {\n\t\tt.Run(testCase.name, func(t *testing.T) {\n\t\t\ts := make([]testArrayStrings, 0)\n\t\t\tdec := BorrowDecoder(strings.NewReader(testCase.json))\n\t\t\tdefer dec.Release()\n\t\t\ta := testSliceArraysStrings{arrays: s, t: t}\n\t\t\terr := dec.Decode(&a)\n\t\t\tassert.Nil(t, err, \"err should be nil\")\n\t\t\tassert.Zero(t, dec.Index(), \"Index() must return zero after decoding\")\n\t\t\tfor k, v := range testCase.expectedResult {\n\t\t\t\tassert.Equal(t, v, a.arrays[k], \"value at given index should be the same as expected results\")\n\t\t\t}\n\t\t})\n\t}\n}\n"
        },
        {
          "name": "decode_bool.go",
          "type": "blob",
          "size": 5.3388671875,
          "content": "package gojay\n\n// DecodeBool reads the next JSON-encoded value from the decoder's input (io.Reader)\n// and stores it in the boolean pointed to by v.\n//\n// See the documentation for Unmarshal for details about the conversion of JSON into a Go value.\nfunc (dec *Decoder) DecodeBool(v *bool) error {\n\tif dec.isPooled == 1 {\n\t\tpanic(InvalidUsagePooledDecoderError(\"Invalid usage of pooled decoder\"))\n\t}\n\treturn dec.decodeBool(v)\n}\nfunc (dec *Decoder) decodeBool(v *bool) error {\n\tfor ; dec.cursor < dec.length || dec.read(); dec.cursor++ {\n\t\tswitch dec.data[dec.cursor] {\n\t\tcase ' ', '\\n', '\\t', '\\r', ',':\n\t\t\tcontinue\n\t\tcase 't':\n\t\t\tdec.cursor++\n\t\t\terr := dec.assertTrue()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\t*v = true\n\t\t\treturn nil\n\t\tcase 'f':\n\t\t\tdec.cursor++\n\t\t\terr := dec.assertFalse()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\t*v = false\n\t\t\treturn nil\n\t\tcase 'n':\n\t\t\tdec.cursor++\n\t\t\terr := dec.assertNull()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\t*v = false\n\t\t\treturn nil\n\t\tdefault:\n\t\t\tdec.err = dec.makeInvalidUnmarshalErr(v)\n\t\t\terr := dec.skipData()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\treturn nil\n\t\t}\n\t}\n\treturn nil\n}\nfunc (dec *Decoder) decodeBoolNull(v **bool) error {\n\tfor ; dec.cursor < dec.length || dec.read(); dec.cursor++ {\n\t\tswitch dec.data[dec.cursor] {\n\t\tcase ' ', '\\n', '\\t', '\\r', ',':\n\t\t\tcontinue\n\t\tcase 't':\n\t\t\tdec.cursor++\n\t\t\terr := dec.assertTrue()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif *v == nil {\n\t\t\t\t*v = new(bool)\n\t\t\t}\n\t\t\t**v = true\n\t\t\treturn nil\n\t\tcase 'f':\n\t\t\tdec.cursor++\n\t\t\terr := dec.assertFalse()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif *v == nil {\n\t\t\t\t*v = new(bool)\n\t\t\t}\n\t\t\t**v = false\n\t\t\treturn nil\n\t\tcase 'n':\n\t\t\tdec.cursor++\n\t\t\terr := dec.assertNull()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\treturn nil\n\t\tdefault:\n\t\t\tdec.err = dec.makeInvalidUnmarshalErr(v)\n\t\t\terr := dec.skipData()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\treturn nil\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc (dec *Decoder) assertTrue() error {\n\ti := 0\n\tfor ; dec.cursor < dec.length || dec.read(); dec.cursor++ {\n\t\tswitch i {\n\t\tcase 0:\n\t\t\tif dec.data[dec.cursor] != 'r' {\n\t\t\t\treturn dec.raiseInvalidJSONErr(dec.cursor)\n\t\t\t}\n\t\tcase 1:\n\t\t\tif dec.data[dec.cursor] != 'u' {\n\t\t\t\treturn dec.raiseInvalidJSONErr(dec.cursor)\n\t\t\t}\n\t\tcase 2:\n\t\t\tif dec.data[dec.cursor] != 'e' {\n\t\t\t\treturn dec.raiseInvalidJSONErr(dec.cursor)\n\t\t\t}\n\t\tcase 3:\n\t\t\tswitch dec.data[dec.cursor] {\n\t\t\tcase ' ', '\\b', '\\t', '\\n', ',', ']', '}':\n\t\t\t\t// dec.cursor--\n\t\t\t\treturn nil\n\t\t\tdefault:\n\t\t\t\treturn dec.raiseInvalidJSONErr(dec.cursor)\n\t\t\t}\n\t\t}\n\t\ti++\n\t}\n\tif i == 3 {\n\t\treturn nil\n\t}\n\treturn dec.raiseInvalidJSONErr(dec.cursor)\n}\n\nfunc (dec *Decoder) assertNull() error {\n\ti := 0\n\tfor ; dec.cursor < dec.length || dec.read(); dec.cursor++ {\n\t\tswitch i {\n\t\tcase 0:\n\t\t\tif dec.data[dec.cursor] != 'u' {\n\t\t\t\treturn dec.raiseInvalidJSONErr(dec.cursor)\n\t\t\t}\n\t\tcase 1:\n\t\t\tif dec.data[dec.cursor] != 'l' {\n\t\t\t\treturn dec.raiseInvalidJSONErr(dec.cursor)\n\t\t\t}\n\t\tcase 2:\n\t\t\tif dec.data[dec.cursor] != 'l' {\n\t\t\t\treturn dec.raiseInvalidJSONErr(dec.cursor)\n\t\t\t}\n\t\tcase 3:\n\t\t\tswitch dec.data[dec.cursor] {\n\t\t\tcase ' ', '\\t', '\\n', ',', ']', '}':\n\t\t\t\t// dec.cursor--\n\t\t\t\treturn nil\n\t\t\tdefault:\n\t\t\t\treturn dec.raiseInvalidJSONErr(dec.cursor)\n\t\t\t}\n\t\t}\n\t\ti++\n\t}\n\tif i == 3 {\n\t\treturn nil\n\t}\n\treturn dec.raiseInvalidJSONErr(dec.cursor)\n}\n\nfunc (dec *Decoder) assertFalse() error {\n\ti := 0\n\tfor ; dec.cursor < dec.length || dec.read(); dec.cursor++ {\n\t\tswitch i {\n\t\tcase 0:\n\t\t\tif dec.data[dec.cursor] != 'a' {\n\t\t\t\treturn dec.raiseInvalidJSONErr(dec.cursor)\n\t\t\t}\n\t\tcase 1:\n\t\t\tif dec.data[dec.cursor] != 'l' {\n\t\t\t\treturn dec.raiseInvalidJSONErr(dec.cursor)\n\t\t\t}\n\t\tcase 2:\n\t\t\tif dec.data[dec.cursor] != 's' {\n\t\t\t\treturn dec.raiseInvalidJSONErr(dec.cursor)\n\t\t\t}\n\t\tcase 3:\n\t\t\tif dec.data[dec.cursor] != 'e' {\n\t\t\t\treturn dec.raiseInvalidJSONErr(dec.cursor)\n\t\t\t}\n\t\tcase 4:\n\t\t\tswitch dec.data[dec.cursor] {\n\t\t\tcase ' ', '\\t', '\\n', ',', ']', '}':\n\t\t\t\t// dec.cursor--\n\t\t\t\treturn nil\n\t\t\tdefault:\n\t\t\t\treturn dec.raiseInvalidJSONErr(dec.cursor)\n\t\t\t}\n\t\t}\n\t\ti++\n\t}\n\tif i == 4 {\n\t\treturn nil\n\t}\n\treturn dec.raiseInvalidJSONErr(dec.cursor)\n}\n\n// Add Values functions\n\n// AddBool decodes the JSON value within an object or an array to a *bool.\n// If next key is neither null nor a JSON boolean, an InvalidUnmarshalError will be returned.\n// If next key is null, bool will be false.\nfunc (dec *Decoder) AddBool(v *bool) error {\n\treturn dec.Bool(v)\n}\n\n// AddBoolNull decodes the JSON value within an object or an array to a *bool.\n// If next key is neither null nor a JSON boolean, an InvalidUnmarshalError will be returned.\n// If next key is null, bool will be false.\n// If a `null` is encountered, gojay does not change the value of the pointer.\nfunc (dec *Decoder) AddBoolNull(v **bool) error {\n\treturn dec.BoolNull(v)\n}\n\n// Bool decodes the JSON value within an object or an array to a *bool.\n// If next key is neither null nor a JSON boolean, an InvalidUnmarshalError will be returned.\n// If next key is null, bool will be false.\nfunc (dec *Decoder) Bool(v *bool) error {\n\terr := dec.decodeBool(v)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdec.called |= 1\n\treturn nil\n}\n\n// BoolNull decodes the JSON value within an object or an array to a *bool.\n// If next key is neither null nor a JSON boolean, an InvalidUnmarshalError will be returned.\n// If next key is null, bool will be false.\nfunc (dec *Decoder) BoolNull(v **bool) error {\n\terr := dec.decodeBoolNull(v)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdec.called |= 1\n\treturn nil\n}\n"
        },
        {
          "name": "decode_bool_test.go",
          "type": "blob",
          "size": 15.041015625,
          "content": "package gojay\n\nimport (\n\t\"strings\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestDecoderBool(t *testing.T) {\n\ttestCases := []struct {\n\t\tname           string\n\t\tjson           string\n\t\texpectedResult bool\n\t\texpectations   func(t *testing.T, v bool, err error)\n\t}{\n\t\t{\n\t\t\tname: \"true-basic\",\n\t\t\tjson: \"true\",\n\t\t\texpectations: func(t *testing.T, v bool, err error) {\n\t\t\t\tassert.Nil(t, err, \"err should be nil\")\n\t\t\t\tassert.True(t, v, \"result should be true\")\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"false-basic\",\n\t\t\tjson: \"false\",\n\t\t\texpectations: func(t *testing.T, v bool, err error) {\n\t\t\t\tassert.Nil(t, err, \"err should be nil\")\n\t\t\t\tassert.False(t, v, \"result should be false\")\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"null-basic\",\n\t\t\tjson: \"null\",\n\t\t\texpectations: func(t *testing.T, v bool, err error) {\n\t\t\t\tassert.Nil(t, err, \"err should be nil\")\n\t\t\t\tassert.False(t, v, \"result should be false\")\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"true-error\",\n\t\t\tjson: \"taue\",\n\t\t\texpectations: func(t *testing.T, v bool, err error) {\n\t\t\t\tassert.NotNil(t, err, \"err should be nil\")\n\t\t\t\tassert.IsType(t, InvalidJSONError(\"\"), err, \"err should be of type InvalidJSONError\")\n\t\t\t\tassert.False(t, v, \"result should be false\")\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"true-error2\",\n\t\t\tjson: \"trae\",\n\t\t\texpectations: func(t *testing.T, v bool, err error) {\n\t\t\t\tassert.NotNil(t, err, \"err should be nil\")\n\t\t\t\tassert.IsType(t, InvalidJSONError(\"\"), err, \"err should be of type InvalidJSONError\")\n\t\t\t\tassert.False(t, v, \"result should be false\")\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"true-error3\",\n\t\t\tjson: \"trua\",\n\t\t\texpectations: func(t *testing.T, v bool, err error) {\n\t\t\t\tassert.NotNil(t, err, \"err should be nil\")\n\t\t\t\tassert.IsType(t, InvalidJSONError(\"\"), err, \"err should be of type InvalidJSONError\")\n\t\t\t\tassert.False(t, v, \"result should be false\")\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"true-error4\",\n\t\t\tjson: \"truea\",\n\t\t\texpectations: func(t *testing.T, v bool, err error) {\n\t\t\t\tassert.NotNil(t, err, \"err should be nil\")\n\t\t\t\tassert.IsType(t, InvalidJSONError(\"\"), err, \"err should be of type InvalidJSONError\")\n\t\t\t\tassert.False(t, v, \"result should be false\")\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"true-error5\",\n\t\t\tjson: \"t\",\n\t\t\texpectations: func(t *testing.T, v bool, err error) {\n\t\t\t\tassert.NotNil(t, err, \"err should be nil\")\n\t\t\t\tassert.IsType(t, InvalidJSONError(\"\"), err, \"err should be of type InvalidJSONError\")\n\t\t\t\tassert.False(t, v, \"result should be false\")\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"true-error6\",\n\t\t\tjson: \"a\",\n\t\t\texpectations: func(t *testing.T, v bool, err error) {\n\t\t\t\tassert.NotNil(t, err, \"err should be nil\")\n\t\t\t\tassert.IsType(t, InvalidJSONError(\"\"), err, \"err should be of type InvalidJSONError\")\n\t\t\t\tassert.False(t, v, \"result should be false\")\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"false-error\",\n\t\t\tjson: \"fulse\",\n\t\t\texpectations: func(t *testing.T, v bool, err error) {\n\t\t\t\tassert.NotNil(t, err, \"err should be nil\")\n\t\t\t\tassert.IsType(t, InvalidJSONError(\"\"), err, \"err should be of type InvalidJSONError\")\n\t\t\t\tassert.False(t, v, \"result should be false\")\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"false-error2\",\n\t\t\tjson: \"fause\",\n\t\t\texpectations: func(t *testing.T, v bool, err error) {\n\t\t\t\tassert.NotNil(t, err, \"err should be nil\")\n\t\t\t\tassert.IsType(t, InvalidJSONError(\"\"), err, \"err should be of type InvalidJSONError\")\n\t\t\t\tassert.False(t, v, \"result should be false\")\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"false-error3\",\n\t\t\tjson: \"falze\",\n\t\t\texpectations: func(t *testing.T, v bool, err error) {\n\t\t\t\tassert.NotNil(t, err, \"err should be nil\")\n\t\t\t\tassert.IsType(t, InvalidJSONError(\"\"), err, \"err should be of type InvalidJSONError\")\n\t\t\t\tassert.False(t, v, \"result should be false\")\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"false-error4\",\n\t\t\tjson: \"falso\",\n\t\t\texpectations: func(t *testing.T, v bool, err error) {\n\t\t\t\tassert.NotNil(t, err, \"err should be nil\")\n\t\t\t\tassert.IsType(t, InvalidJSONError(\"\"), err, \"err should be of type InvalidJSONError\")\n\t\t\t\tassert.False(t, v, \"result should be false\")\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"false-error5\",\n\t\t\tjson: \"falsea\",\n\t\t\texpectations: func(t *testing.T, v bool, err error) {\n\t\t\t\tassert.NotNil(t, err, \"err should be nil\")\n\t\t\t\tassert.IsType(t, InvalidJSONError(\"\"), err, \"err should be of type InvalidJSONError\")\n\t\t\t\tassert.False(t, v, \"result should be false\")\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"false-error6\",\n\t\t\tjson: \"f\",\n\t\t\texpectations: func(t *testing.T, v bool, err error) {\n\t\t\t\tassert.NotNil(t, err, \"err should be nil\")\n\t\t\t\tassert.IsType(t, InvalidJSONError(\"\"), err, \"err should be of type InvalidJSONError\")\n\t\t\t\tassert.False(t, v, \"result should be false\")\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"false-error7\",\n\t\t\tjson: \"a\",\n\t\t\texpectations: func(t *testing.T, v bool, err error) {\n\t\t\t\tassert.NotNil(t, err, \"err should be nil\")\n\t\t\t\tassert.IsType(t, InvalidJSONError(\"\"), err, \"err should be of type InvalidJSONError\")\n\t\t\t\tassert.False(t, v, \"result should be false\")\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"null-error\",\n\t\t\tjson: \"nall\",\n\t\t\texpectations: func(t *testing.T, v bool, err error) {\n\t\t\t\tassert.NotNil(t, err, \"err should be nil\")\n\t\t\t\tassert.IsType(t, InvalidJSONError(\"\"), err, \"err should be of type InvalidJSONError\")\n\t\t\t\tassert.False(t, v, \"result should be false\")\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"null-error2\",\n\t\t\tjson: \"nual\",\n\t\t\texpectations: func(t *testing.T, v bool, err error) {\n\t\t\t\tassert.NotNil(t, err, \"err should be nil\")\n\t\t\t\tassert.IsType(t, InvalidJSONError(\"\"), err, \"err should be of type InvalidJSONError\")\n\t\t\t\tassert.False(t, v, \"result should be false\")\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"null-error3\",\n\t\t\tjson: \"nula\",\n\t\t\texpectations: func(t *testing.T, v bool, err error) {\n\t\t\t\tassert.NotNil(t, err, \"err should be nil\")\n\t\t\t\tassert.IsType(t, InvalidJSONError(\"\"), err, \"err should be of type InvalidJSONError\")\n\t\t\t\tassert.False(t, v, \"result should be false\")\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"null-error4\",\n\t\t\tjson: \"nulle\",\n\t\t\texpectations: func(t *testing.T, v bool, err error) {\n\t\t\t\tassert.NotNil(t, err, \"err should be nil\")\n\t\t\t\tassert.IsType(t, InvalidJSONError(\"\"), err, \"err should be of type InvalidJSONError\")\n\t\t\t\tassert.False(t, v, \"result should be false\")\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"null-error5\",\n\t\t\tjson: \"n\",\n\t\t\texpectations: func(t *testing.T, v bool, err error) {\n\t\t\t\tassert.NotNil(t, err, \"err should be nil\")\n\t\t\t\tassert.IsType(t, InvalidJSONError(\"\"), err, \"err should be of type InvalidJSONError\")\n\t\t\t\tassert.False(t, v, \"result should be false\")\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"null-error6\",\n\t\t\tjson: \"a\",\n\t\t\texpectations: func(t *testing.T, v bool, err error) {\n\t\t\t\tassert.NotNil(t, err, \"err should be nil\")\n\t\t\t\tassert.IsType(t, InvalidJSONError(\"\"), err, \"err should be of type InvalidJSONError\")\n\t\t\t\tassert.False(t, v, \"result should be false\")\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"null-skip\",\n\t\t\tjson: \"{}\",\n\t\t\texpectations: func(t *testing.T, v bool, err error) {\n\t\t\t\tassert.NotNil(t, err, \"err should not be nil\")\n\t\t\t\tassert.IsType(t, InvalidUnmarshalError(\"\"), err, \"err should be of type InvalidUnmarshalError\")\n\t\t\t\tassert.False(t, v, \"result should be false\")\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"null-skip\",\n\t\t\tjson: \"\",\n\t\t\texpectations: func(t *testing.T, v bool, err error) {\n\t\t\t\tassert.Nil(t, err, \"err should not be nil\")\n\t\t\t\tassert.False(t, v, \"result should be false\")\n\t\t\t},\n\t\t},\n\t}\n\n\tfor _, testCase := range testCases {\n\t\tt.Run(testCase.name, func(t *testing.T) {\n\t\t\tjson := []byte(testCase.json)\n\t\t\tvar v bool\n\t\t\terr := Unmarshal(json, &v)\n\t\t\ttestCase.expectations(t, v, err)\n\t\t})\n\t}\n}\n\nfunc TestDecoderBoolNull(t *testing.T) {\n\ttestCases := []struct {\n\t\tname           string\n\t\tjson           string\n\t\texpectedResult bool\n\t\texpectations   func(t *testing.T, v *bool, err error)\n\t}{\n\t\t{\n\t\t\tname: \"true-basic\",\n\t\t\tjson: \"true\",\n\t\t\texpectations: func(t *testing.T, v *bool, err error) {\n\t\t\t\tassert.Nil(t, err, \"err should be nil\")\n\t\t\t\tassert.True(t, *v, \"result should be true\")\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"false-basic\",\n\t\t\tjson: \"false\",\n\t\t\texpectations: func(t *testing.T, v *bool, err error) {\n\t\t\t\tassert.Nil(t, err, \"err should be nil\")\n\t\t\t\tassert.False(t, *v, \"result should be false\")\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"null-basic\",\n\t\t\tjson: \"null\",\n\t\t\texpectations: func(t *testing.T, v *bool, err error) {\n\t\t\t\tassert.Nil(t, err, \"err should be nil\")\n\t\t\t\tassert.Nil(t, v, \"result should be nil\")\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"true-error\",\n\t\t\tjson: \"taue\",\n\t\t\texpectations: func(t *testing.T, v *bool, err error) {\n\t\t\t\tassert.NotNil(t, err, \"err should be nil\")\n\t\t\t\tassert.IsType(t, InvalidJSONError(\"\"), err, \"err should be of type InvalidJSONError\")\n\t\t\t\tassert.Nil(t, v, \"result should be false\")\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"true-error2\",\n\t\t\tjson: \"trae\",\n\t\t\texpectations: func(t *testing.T, v *bool, err error) {\n\t\t\t\tassert.NotNil(t, err, \"err should be nil\")\n\t\t\t\tassert.IsType(t, InvalidJSONError(\"\"), err, \"err should be of type InvalidJSONError\")\n\t\t\t\tassert.Nil(t, v, \"result should be nil\")\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"true-error3\",\n\t\t\tjson: \"trua\",\n\t\t\texpectations: func(t *testing.T, v *bool, err error) {\n\t\t\t\tassert.NotNil(t, err, \"err should be nil\")\n\t\t\t\tassert.IsType(t, InvalidJSONError(\"\"), err, \"err should be of type InvalidJSONError\")\n\t\t\t\tassert.Nil(t, v, \"result should be nil\")\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"true-error4\",\n\t\t\tjson: \"truea\",\n\t\t\texpectations: func(t *testing.T, v *bool, err error) {\n\t\t\t\tassert.NotNil(t, err, \"err should be nil\")\n\t\t\t\tassert.IsType(t, InvalidJSONError(\"\"), err, \"err should be of type InvalidJSONError\")\n\t\t\t\tassert.Nil(t, v, \"result should be nil\")\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"true-error5\",\n\t\t\tjson: \"t\",\n\t\t\texpectations: func(t *testing.T, v *bool, err error) {\n\t\t\t\tassert.NotNil(t, err, \"err should be nil\")\n\t\t\t\tassert.IsType(t, InvalidJSONError(\"\"), err, \"err should be of type InvalidJSONError\")\n\t\t\t\tassert.Nil(t, v, \"result should be nil\")\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"true-error6\",\n\t\t\tjson: \"a\",\n\t\t\texpectations: func(t *testing.T, v *bool, err error) {\n\t\t\t\tassert.NotNil(t, err, \"err should be nil\")\n\t\t\t\tassert.IsType(t, InvalidJSONError(\"\"), err, \"err should be of type InvalidJSONError\")\n\t\t\t\tassert.Nil(t, v, \"result should be nil\")\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"false-error\",\n\t\t\tjson: \"fulse\",\n\t\t\texpectations: func(t *testing.T, v *bool, err error) {\n\t\t\t\tassert.NotNil(t, err, \"err should be nil\")\n\t\t\t\tassert.IsType(t, InvalidJSONError(\"\"), err, \"err should be of type InvalidJSONError\")\n\t\t\t\tassert.Nil(t, v, \"result should be nil\")\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"false-error2\",\n\t\t\tjson: \"fause\",\n\t\t\texpectations: func(t *testing.T, v *bool, err error) {\n\t\t\t\tassert.NotNil(t, err, \"err should be nil\")\n\t\t\t\tassert.IsType(t, InvalidJSONError(\"\"), err, \"err should be of type InvalidJSONError\")\n\t\t\t\tassert.Nil(t, v, \"result should be nil\")\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"false-error3\",\n\t\t\tjson: \"falze\",\n\t\t\texpectations: func(t *testing.T, v *bool, err error) {\n\t\t\t\tassert.NotNil(t, err, \"err should be nil\")\n\t\t\t\tassert.IsType(t, InvalidJSONError(\"\"), err, \"err should be of type InvalidJSONError\")\n\t\t\t\tassert.Nil(t, v, \"result should be nil\")\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"false-error4\",\n\t\t\tjson: \"falso\",\n\t\t\texpectations: func(t *testing.T, v *bool, err error) {\n\t\t\t\tassert.NotNil(t, err, \"err should be nil\")\n\t\t\t\tassert.IsType(t, InvalidJSONError(\"\"), err, \"err should be of type InvalidJSONError\")\n\t\t\t\tassert.Nil(t, v, \"result should be nil\")\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"false-error5\",\n\t\t\tjson: \"falsea\",\n\t\t\texpectations: func(t *testing.T, v *bool, err error) {\n\t\t\t\tassert.NotNil(t, err, \"err should be nil\")\n\t\t\t\tassert.IsType(t, InvalidJSONError(\"\"), err, \"err should be of type InvalidJSONError\")\n\t\t\t\tassert.Nil(t, v, \"result should be nil\")\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"false-error6\",\n\t\t\tjson: \"f\",\n\t\t\texpectations: func(t *testing.T, v *bool, err error) {\n\t\t\t\tassert.NotNil(t, err, \"err should be nil\")\n\t\t\t\tassert.IsType(t, InvalidJSONError(\"\"), err, \"err should be of type InvalidJSONError\")\n\t\t\t\tassert.Nil(t, v, \"result should be nil\")\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"false-error7\",\n\t\t\tjson: \"a\",\n\t\t\texpectations: func(t *testing.T, v *bool, err error) {\n\t\t\t\tassert.NotNil(t, err, \"err should be nil\")\n\t\t\t\tassert.IsType(t, InvalidJSONError(\"\"), err, \"err should be of type InvalidJSONError\")\n\t\t\t\tassert.Nil(t, v, \"result should be nil\")\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"null-error\",\n\t\t\tjson: \"nall\",\n\t\t\texpectations: func(t *testing.T, v *bool, err error) {\n\t\t\t\tassert.NotNil(t, err, \"err should be nil\")\n\t\t\t\tassert.IsType(t, InvalidJSONError(\"\"), err, \"err should be of type InvalidJSONError\")\n\t\t\t\tassert.Nil(t, v, \"result should be nil\")\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"null-error2\",\n\t\t\tjson: \"nual\",\n\t\t\texpectations: func(t *testing.T, v *bool, err error) {\n\t\t\t\tassert.NotNil(t, err, \"err should be nil\")\n\t\t\t\tassert.IsType(t, InvalidJSONError(\"\"), err, \"err should be of type InvalidJSONError\")\n\t\t\t\tassert.Nil(t, v, \"result should be nil\")\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"null-error3\",\n\t\t\tjson: \"nula\",\n\t\t\texpectations: func(t *testing.T, v *bool, err error) {\n\t\t\t\tassert.NotNil(t, err, \"err should be nil\")\n\t\t\t\tassert.IsType(t, InvalidJSONError(\"\"), err, \"err should be of type InvalidJSONError\")\n\t\t\t\tassert.Nil(t, v, \"result should be nil\")\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"null-error4\",\n\t\t\tjson: \"nulle\",\n\t\t\texpectations: func(t *testing.T, v *bool, err error) {\n\t\t\t\tassert.NotNil(t, err, \"err should be nil\")\n\t\t\t\tassert.IsType(t, InvalidJSONError(\"\"), err, \"err should be of type InvalidJSONError\")\n\t\t\t\tassert.Nil(t, v, \"result should be nil\")\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"null-error5\",\n\t\t\tjson: \"n\",\n\t\t\texpectations: func(t *testing.T, v *bool, err error) {\n\t\t\t\tassert.NotNil(t, err, \"err should be nil\")\n\t\t\t\tassert.IsType(t, InvalidJSONError(\"\"), err, \"err should be of type InvalidJSONError\")\n\t\t\t\tassert.Nil(t, v, \"result should be nil\")\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"null-error6\",\n\t\t\tjson: \"a\",\n\t\t\texpectations: func(t *testing.T, v *bool, err error) {\n\t\t\t\tassert.NotNil(t, err, \"err should be nil\")\n\t\t\t\tassert.IsType(t, InvalidJSONError(\"\"), err, \"err should be of type InvalidJSONError\")\n\t\t\t\tassert.Nil(t, v, \"result should be nil\")\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"null-skip\",\n\t\t\tjson: \"{}\",\n\t\t\texpectations: func(t *testing.T, v *bool, err error) {\n\t\t\t\tassert.NotNil(t, err, \"err should not be nil\")\n\t\t\t\tassert.IsType(t, InvalidUnmarshalError(\"\"), err, \"err should be of type InvalidUnmarshalError\")\n\t\t\t\tassert.Nil(t, v, \"result should be nil\")\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"null-skip\",\n\t\t\tjson: \"\",\n\t\t\texpectations: func(t *testing.T, v *bool, err error) {\n\t\t\t\tassert.Nil(t, err, \"err should not be nil\")\n\t\t\t\tassert.Nil(t, v, \"result should be nil\")\n\t\t\t},\n\t\t},\n\t}\n\n\tfor _, testCase := range testCases {\n\t\tt.Run(testCase.name, func(t *testing.T) {\n\t\t\tvar v = struct {\n\t\t\t\tb *bool\n\t\t\t}{}\n\t\t\terr := Unmarshal([]byte(testCase.json), &v.b)\n\t\t\ttestCase.expectations(t, v.b, err)\n\t\t})\n\t}\n\tt.Run(\"decoder-api-invalid-json2\", func(t *testing.T) {\n\t\tvar v = new(bool)\n\t\tvar dec = NewDecoder(strings.NewReader(`folse`))\n\t\terr := dec.BoolNull(&v)\n\t\tassert.NotNil(t, err, \"Err must not be nil\")\n\t\tassert.IsType(t, InvalidJSONError(\"\"), err, \"err should be of type InvalidJSONError\")\n\t})\n}\n\nfunc TestDecoderBoolDecoderAPI(t *testing.T) {\n\tvar v bool\n\tdec := BorrowDecoder(strings.NewReader(\"true\"))\n\tdefer dec.Release()\n\terr := dec.DecodeBool(&v)\n\tassert.Nil(t, err, \"Err must be nil\")\n\tassert.Equal(t, true, v, \"v must be equal to true\")\n}\n\nfunc TestDecoderBoolPoolError(t *testing.T) {\n\tv := true\n\tdec := NewDecoder(nil)\n\tdec.Release()\n\tdefer func() {\n\t\terr := recover()\n\t\tassert.NotNil(t, err, \"err shouldnt be nil\")\n\t\tassert.IsType(t, InvalidUsagePooledDecoderError(\"\"), err, \"err should be of type InvalidUsagePooledDecoderError\")\n\t}()\n\t_ = dec.DecodeBool(&v)\n\tassert.True(t, false, \"should not be called as decoder should have panicked\")\n}\n"
        },
        {
          "name": "decode_embedded_json.go",
          "type": "blob",
          "size": 2.1162109375,
          "content": "package gojay\n\n// EmbeddedJSON is a raw encoded JSON value.\n// It can be used to delay JSON decoding or precompute a JSON encoding.\ntype EmbeddedJSON []byte\n\nfunc (dec *Decoder) decodeEmbeddedJSON(ej *EmbeddedJSON) error {\n\tvar err error\n\tif ej == nil {\n\t\treturn InvalidUnmarshalError(\"Invalid nil pointer given\")\n\t}\n\tvar beginOfEmbeddedJSON int\n\tfor ; dec.cursor < dec.length || dec.read(); dec.cursor++ {\n\t\tswitch dec.data[dec.cursor] {\n\t\tcase ' ', '\\n', '\\t', '\\r', ',':\n\t\t\tcontinue\n\t\t// is null\n\t\tcase 'n':\n\t\t\tbeginOfEmbeddedJSON = dec.cursor\n\t\t\tdec.cursor++\n\t\t\terr := dec.assertNull()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\tcase 't':\n\t\t\tbeginOfEmbeddedJSON = dec.cursor\n\t\t\tdec.cursor++\n\t\t\terr := dec.assertTrue()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t// is false\n\t\tcase 'f':\n\t\t\tbeginOfEmbeddedJSON = dec.cursor\n\t\t\tdec.cursor++\n\t\t\terr := dec.assertFalse()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t// is an object\n\t\tcase '{':\n\t\t\tbeginOfEmbeddedJSON = dec.cursor\n\t\t\tdec.cursor = dec.cursor + 1\n\t\t\tdec.cursor, err = dec.skipObject()\n\t\t// is string\n\t\tcase '\"':\n\t\t\tbeginOfEmbeddedJSON = dec.cursor\n\t\t\tdec.cursor = dec.cursor + 1\n\t\t\terr = dec.skipString() // why no new dec.cursor in result?\n\t\t// is array\n\t\tcase '[':\n\t\t\tbeginOfEmbeddedJSON = dec.cursor\n\t\t\tdec.cursor = dec.cursor + 1\n\t\t\tdec.cursor, err = dec.skipArray()\n\t\tcase '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '-':\n\t\t\tbeginOfEmbeddedJSON = dec.cursor\n\t\t\tdec.cursor, err = dec.skipNumber()\n\t\t}\n\t\tbreak\n\t}\n\tif err == nil {\n\t\tif dec.cursor-1 >= beginOfEmbeddedJSON {\n\t\t\t*ej = append(*ej, dec.data[beginOfEmbeddedJSON:dec.cursor]...)\n\t\t}\n\t\tdec.called |= 1\n\t}\n\treturn err\n}\n\n// AddEmbeddedJSON adds an EmbeddedsJSON to the value pointed by v.\n// It can be used to delay JSON decoding or precompute a JSON encoding.\nfunc (dec *Decoder) AddEmbeddedJSON(v *EmbeddedJSON) error {\n\treturn dec.EmbeddedJSON(v)\n}\n\n// EmbeddedJSON adds an EmbeddedsJSON to the value pointed by v.\n// It can be used to delay JSON decoding or precompute a JSON encoding.\nfunc (dec *Decoder) EmbeddedJSON(v *EmbeddedJSON) error {\n\terr := dec.decodeEmbeddedJSON(v)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdec.called |= 1\n\treturn nil\n}\n"
        },
        {
          "name": "decode_embedded_json_test.go",
          "type": "blob",
          "size": 5.388671875,
          "content": "package gojay\n\nimport (\n\t\"bytes\"\n\t\"strings\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\ntype Request struct {\n\tid     string\n\tmethod string\n\tparams EmbeddedJSON\n\tmore   int\n}\n\nfunc (r *Request) UnmarshalJSONObject(dec *Decoder, key string) error {\n\tswitch key {\n\tcase \"id\":\n\t\treturn dec.AddString(&r.id)\n\tcase \"method\":\n\t\treturn dec.AddString(&r.method)\n\tcase \"params\":\n\t\treturn dec.AddEmbeddedJSON(&r.params)\n\tcase \"more\":\n\t\tdec.AddInt(&r.more)\n\t}\n\treturn nil\n}\n\nfunc (r *Request) NKeys() int {\n\treturn 4\n}\n\nfunc TestDecodeEmbeddedJSONUnmarshalAPI(t *testing.T) {\n\ttestCases := []struct {\n\t\tname             string\n\t\tjson             []byte\n\t\texpectedEmbedded string\n\t\terr              bool\n\t}{\n\t\t{\n\t\t\tname:             \"decode-basic-string\",\n\t\t\tjson:             []byte(`{\"id\":\"someid\",\"method\":\"getmydata\",\"params\":\"raw data\", \"more\":123}`),\n\t\t\texpectedEmbedded: `\"raw data\"`,\n\t\t},\n\t\t{\n\t\t\tname:             \"decode-basic-int\",\n\t\t\tjson:             []byte(`{\"id\":\"someid\",\"method\":\"getmydata\",\"params\":12345, \"more\":123}`),\n\t\t\texpectedEmbedded: `12345`,\n\t\t},\n\t\t{\n\t\t\tname:             \"decode-basic-int\",\n\t\t\tjson:             []byte(`{\"id\":\"someid\",\"method\":\"getmydata\",\"params\":true, \"more\":123}`),\n\t\t\texpectedEmbedded: `true`,\n\t\t},\n\t\t{\n\t\t\tname:             \"decode-basic-int\",\n\t\t\tjson:             []byte(`{\"id\":\"someid\",\"method\":\"getmydata\",\"params\": false, \"more\":123}`),\n\t\t\texpectedEmbedded: `false`,\n\t\t},\n\t\t{\n\t\t\tname:             \"decode-basic-int\",\n\t\t\tjson:             []byte(`{\"id\":\"someid\",\"method\":\"getmydata\",\"params\":null, \"more\":123}`),\n\t\t\texpectedEmbedded: `null`,\n\t\t},\n\t\t{\n\t\t\tname:             \"decode-basic-object\",\n\t\t\tjson:             []byte(`{\"id\":\"someid\",\"method\":\"getmydata\",\"params\":{\"example\":\"of raw data\"}, \"more\":123}`),\n\t\t\texpectedEmbedded: `{\"example\":\"of raw data\"}`,\n\t\t},\n\t\t{\n\t\t\tname:             \"decode-basic-object\",\n\t\t\tjson:             []byte(`{\"id\":\"someid\",\"method\":\"getmydata\",\"params\":[1,2,3], \"more\":123}`),\n\t\t\texpectedEmbedded: `[1,2,3]`,\n\t\t},\n\t\t{\n\t\t\tname:             \"decode-null-err\",\n\t\t\tjson:             []byte(`{\"id\":\"someid\",\"method\":\"getmydata\",\"params\":nil, \"more\":123}`),\n\t\t\texpectedEmbedded: ``,\n\t\t\terr:              true,\n\t\t},\n\t\t{\n\t\t\tname:             \"decode-bool-false-err\",\n\t\t\tjson:             []byte(`{\"id\":\"someid\",\"method\":\"getmydata\",\"params\":faulse, \"more\":123}`),\n\t\t\texpectedEmbedded: ``,\n\t\t\terr:              true,\n\t\t},\n\t\t{\n\t\t\tname:             \"decode-bool-true-err\",\n\t\t\tjson:             []byte(`{\"id\":\"someid\",\"method\":\"getmydata\",\"params\":trou, \"more\":123}`),\n\t\t\texpectedEmbedded: ``,\n\t\t\terr:              true,\n\t\t},\n\t}\n\tfor _, testCase := range testCases {\n\t\tt.Run(testCase.name, func(t *testing.T) {\n\t\t\treq := &Request{}\n\t\t\terr := Unmarshal(testCase.json, req)\n\t\t\tt.Log(req)\n\t\t\tt.Log(string(req.params))\n\t\t\tif testCase.err {\n\t\t\t\tassert.NotNil(t, err, \"err should not be nil\")\n\t\t\t} else {\n\t\t\t\tassert.Nil(t, err, \"err should be nil\")\n\t\t\t}\n\t\t\tassert.Equal(t, testCase.expectedEmbedded, string(req.params), \"r.params should be equal to expectedEmbeddedResult\")\n\t\t})\n\t}\n}\n\nfunc TestDecodeEmbeddedJSONDecodeAPI(t *testing.T) {\n\ttestCases := []struct {\n\t\tname             string\n\t\tjson             []byte\n\t\texpectedEmbedded string\n\t}{\n\t\t{\n\t\t\tname:             \"decode-basic-string\",\n\t\t\tjson:             []byte(`{\"id\":\"someid\",\"method\":\"getmydata\",\"params\":\"raw data\", \"more\":123}`),\n\t\t\texpectedEmbedded: `\"raw data\"`,\n\t\t},\n\t\t{\n\t\t\tname:             \"decode-basic-int\",\n\t\t\tjson:             []byte(`{\"id\":\"someid\",\"method\":\"getmydata\",\"params\":12345, \"more\":123}`),\n\t\t\texpectedEmbedded: `12345`,\n\t\t},\n\t\t{\n\t\t\tname:             \"decode-basic-int\",\n\t\t\tjson:             []byte(`{\"id\":\"someid\",\"method\":\"getmydata\",\"params\":true, \"more\":123}`),\n\t\t\texpectedEmbedded: `true`,\n\t\t},\n\t\t{\n\t\t\tname:             \"decode-basic-int\",\n\t\t\tjson:             []byte(`{\"id\":\"someid\",\"method\":\"getmydata\",\"params\": false, \"more\":123}`),\n\t\t\texpectedEmbedded: `false`,\n\t\t},\n\t\t{\n\t\t\tname:             \"decode-basic-int\",\n\t\t\tjson:             []byte(`{\"id\":\"someid\",\"method\":\"getmydata\",\"params\":null, \"more\":123}`),\n\t\t\texpectedEmbedded: `null`,\n\t\t},\n\t\t{\n\t\t\tname:             \"decode-basic-object\",\n\t\t\tjson:             []byte(`{\"id\":\"someid\",\"method\":\"getmydata\",\"params\":{\"example\":\"of raw data\"}, \"more\":123}`),\n\t\t\texpectedEmbedded: `{\"example\":\"of raw data\"}`,\n\t\t},\n\t\t{\n\t\t\tname:             \"decode-basic-object\",\n\t\t\tjson:             []byte(`{\"id\":\"someid\",\"method\":\"getmydata\",\"params\":[1,2,3], \"more\":123}`),\n\t\t\texpectedEmbedded: `[1,2,3]`,\n\t\t},\n\t}\n\tfor _, testCase := range testCases {\n\t\tt.Run(testCase.name, func(t *testing.T) {\n\t\t\tej := EmbeddedJSON([]byte{})\n\t\t\tdec := BorrowDecoder(bytes.NewReader(testCase.json))\n\t\t\terr := dec.Decode(&ej)\n\t\t\tassert.Nil(t, err, \"err should be nil\")\n\t\t\tassert.Equal(t, string(testCase.json), string(ej), \"r.params should be equal to expectedEmbeddedResult\")\n\t\t})\n\t}\n}\n\nfunc TestDecodeEmbeededJSONNil(t *testing.T) {\n\tdec := BorrowDecoder(strings.NewReader(`\"bar\"`))\n\tvar ej *EmbeddedJSON\n\terr := dec.decodeEmbeddedJSON(ej)\n\tassert.NotNil(t, err, `err should not be nil a nil pointer is given`)\n\tassert.IsType(t, InvalidUnmarshalError(\"\"), err, `err should not be of type InvalidUnmarshalError`)\n}\n\nfunc TestDecodeEmbeededJSONNil2(t *testing.T) {\n\tdec := BorrowDecoder(strings.NewReader(`\"bar\"`))\n\tvar ej *EmbeddedJSON\n\terr := dec.AddEmbeddedJSON(ej)\n\tassert.NotNil(t, err, `err should not be nil a nil pointer is given`)\n\tassert.IsType(t, InvalidUnmarshalError(\"\"), err, `err should not be of type InvalidUnmarshalError`)\n}\n"
        },
        {
          "name": "decode_example_test.go",
          "type": "blob",
          "size": 2.525390625,
          "content": "package gojay_test\n\nimport (\n\t\"fmt\"\n\t\"log\"\n\t\"strings\"\n\n\t\"github.com/francoispqt/gojay\"\n)\n\nfunc ExampleUnmarshal_string() {\n\tdata := []byte(`\"gojay\"`)\n\tvar str string\n\terr := gojay.Unmarshal(data, &str)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tfmt.Println(str) // true\n}\n\nfunc ExampleUnmarshal_bool() {\n\tdata := []byte(`true`)\n\tvar b bool\n\terr := gojay.Unmarshal(data, &b)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tfmt.Println(b) // true\n}\n\nfunc ExampleUnmarshal_invalidType() {\n\tdata := []byte(`\"gojay\"`)\n\tsomeStruct := struct{}{}\n\terr := gojay.Unmarshal(data, &someStruct)\n\n\tfmt.Println(err) // \"Cannot unmarshal JSON to type '*struct{}'\"\n}\n\nfunc ExampleDecoder_Decode_string() {\n\tvar str string\n\tdec := gojay.BorrowDecoder(strings.NewReader(`\"gojay\"`))\n\terr := dec.Decode(&str)\n\tdec.Release()\n\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tfmt.Println(str) // \"gojay\"\n}\n\nfunc ExampleDecodeObjectFunc() {\n\treader := strings.NewReader(`{\n\t\t\"name\": \"John Doe\",\n\t\t\"email\": \"john.doe@email.com\" \n\t}`)\n\tdec := gojay.NewDecoder(reader)\n\n\tuser := struct {\n\t\tname  string\n\t\temail string\n\t}{}\n\tdec.DecodeObject(gojay.DecodeObjectFunc(func(dec *gojay.Decoder, k string) error {\n\t\tswitch k {\n\t\tcase \"name\":\n\t\t\treturn dec.String(&user.name)\n\t\tcase \"email\":\n\t\t\treturn dec.String(&user.email)\n\t\t}\n\t\treturn nil\n\t}))\n\n\tfmt.Printf(\"User\\nname: %s\\nemail: %s\", user.name, user.email)\n\n\t// Output:\n\t// User\n\t// name: John Doe\n\t// email: john.doe@email.com\n}\n\nfunc ExampleDecodeArrayFunc() {\n\treader := strings.NewReader(`[\n\t\t\"foo\",\n\t\t\"bar\"\n\t]`)\n\tdec := gojay.NewDecoder(reader)\n\n\tstrSlice := make([]string, 0)\n\terr := dec.DecodeArray(gojay.DecodeArrayFunc(func(dec *gojay.Decoder) error {\n\t\tvar str string\n\t\tif err := dec.AddString(&str); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tstrSlice = append(strSlice, str)\n\t\treturn nil\n\t}))\n\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\tfmt.Print(strSlice)\n\t// Output:\n\t// [foo bar]\n}\n\nfunc ExampleNewDecoder() {\n\treader := strings.NewReader(`\"gojay\"`)\n\tdec := gojay.NewDecoder(reader)\n\n\tvar str string\n\terr := dec.DecodeString(&str)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\tfmt.Println(str)\n\t// Output:\n\t// gojay\n}\n\nfunc ExampleBorrowDecoder() {\n\treader := strings.NewReader(`\"gojay\"`)\n\tdec := gojay.BorrowDecoder(reader)\n\tdefer dec.Release()\n\n\tvar str string\n\terr := dec.DecodeString(&str)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\tfmt.Println(str)\n\t// Output:\n\t// gojay\n}\n\nfunc ExampleDecoder_DecodeBool() {\n\treader := strings.NewReader(`true`)\n\tdec := gojay.NewDecoder(reader)\n\n\tvar b bool\n\terr := dec.DecodeBool(&b)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\tfmt.Println(b)\n\t// Output:\n\t// true\n}\n"
        },
        {
          "name": "decode_interface.go",
          "type": "blob",
          "size": 2.8408203125,
          "content": "package gojay\n\n// TODO @afiune for now we are using the standard json unmarshaling but in\n// the future it would be great to implement one here inside this repo\nimport \"encoding/json\"\n\n// DecodeInterface reads the next JSON-encoded value from the decoder's input (io.Reader) and stores it in the value pointed to by i.\n//\n// i must be an interface poiter\nfunc (dec *Decoder) DecodeInterface(i *interface{}) error {\n\tif dec.isPooled == 1 {\n\t\tpanic(InvalidUsagePooledDecoderError(\"Invalid usage of pooled decoder\"))\n\t}\n\terr := dec.decodeInterface(i)\n\treturn err\n}\n\nfunc (dec *Decoder) decodeInterface(i *interface{}) error {\n\tstart, end, err := dec.getObject()\n\tif err != nil {\n\t\tdec.cursor = start\n\t\treturn err\n\t}\n\n\t// if start & end are equal the object is a null, don't unmarshal\n\tif start == end {\n\t\treturn nil\n\t}\n\n\tobject := dec.data[start:end]\n\tif err = json.Unmarshal(object, i); err != nil {\n\t\treturn err\n\t}\n\n\tdec.cursor = end\n\treturn nil\n}\n\n// @afiune Maybe return the type as well?\nfunc (dec *Decoder) getObject() (start int, end int, err error) {\n\t// start cursor\n\tfor ; dec.cursor < dec.length || dec.read(); dec.cursor++ {\n\t\tswitch dec.data[dec.cursor] {\n\t\tcase ' ', '\\n', '\\t', '\\r', ',':\n\t\t\tcontinue\n\t\t// is null\n\t\tcase 'n':\n\t\t\tdec.cursor++\n\t\t\terr = dec.assertNull()\n\t\t\tif err != nil {\n\t\t\t\treturn\n\t\t\t}\n\t\t\t// Set start & end to the same cursor to indicate the object\n\t\t\t// is a null and should not be unmarshal\n\t\t\tstart = dec.cursor\n\t\t\tend = dec.cursor\n\t\t\treturn\n\t\tcase 't':\n\t\t\tstart = dec.cursor\n\t\t\tdec.cursor++\n\t\t\terr = dec.assertTrue()\n\t\t\tif err != nil {\n\t\t\t\treturn\n\t\t\t}\n\t\t\tend = dec.cursor\n\t\t\tdec.cursor++\n\t\t\treturn\n\t\t// is false\n\t\tcase 'f':\n\t\t\tstart = dec.cursor\n\t\t\tdec.cursor++\n\t\t\terr = dec.assertFalse()\n\t\t\tif err != nil {\n\t\t\t\treturn\n\t\t\t}\n\t\t\tend = dec.cursor\n\t\t\tdec.cursor++\n\t\t\treturn\n\t\t// is an object\n\t\tcase '{':\n\t\t\tstart = dec.cursor\n\t\t\tdec.cursor++\n\t\t\tend, err = dec.skipObject()\n\t\t\tdec.cursor = end\n\t\t\treturn\n\t\t// is string\n\t\tcase '\"':\n\t\t\tstart = dec.cursor\n\t\t\tdec.cursor++\n\t\t\tstart, end, err = dec.getString()\n\t\t\tstart--\n\t\t\tdec.cursor = end\n\t\t\treturn\n\t\t// is array\n\t\tcase '[':\n\t\t\tstart = dec.cursor\n\t\t\tdec.cursor++\n\t\t\tend, err = dec.skipArray()\n\t\t\tdec.cursor = end\n\t\t\treturn\n\t\tcase '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '-':\n\t\t\tstart = dec.cursor\n\t\t\tend, err = dec.skipNumber()\n\t\t\tdec.cursor = end\n\t\t\treturn\n\t\tdefault:\n\t\t\terr = dec.raiseInvalidJSONErr(dec.cursor)\n\t\t\treturn\n\t\t}\n\t}\n\terr = dec.raiseInvalidJSONErr(dec.cursor)\n\treturn\n}\n\n// Add Values functions\n\n// AddInterface decodes the JSON value within an object or an array to a interface{}.\nfunc (dec *Decoder) AddInterface(v *interface{}) error {\n\treturn dec.Interface(v)\n}\n\n// Interface decodes the JSON value within an object or an array to an interface{}.\nfunc (dec *Decoder) Interface(value *interface{}) error {\n\terr := dec.decodeInterface(value)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdec.called |= 1\n\treturn nil\n}\n"
        },
        {
          "name": "decode_interface_test.go",
          "type": "blob",
          "size": 12.88671875,
          "content": "package gojay\n\nimport (\n\t\"encoding/json\"\n\t\"strings\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestDecodeInterfaceBasic(t *testing.T) {\n\ttestCases := []struct {\n\t\tname            string\n\t\tjson            string\n\t\texpectedResult  interface{}\n\t\terr             bool\n\t\terrType         interface{}\n\t\tskipCheckResult bool\n\t}{\n\t\t{\n\t\t\tname:           \"array\",\n\t\t\tjson:           `[1,2,3]`,\n\t\t\texpectedResult: []interface{}([]interface{}{float64(1), float64(2), float64(3)}),\n\t\t\terr:            false,\n\t\t},\n\t\t{\n\t\t\tname:           \"object\",\n\t\t\tjson:           `{\"testStr\": \"hello world!\"}`,\n\t\t\texpectedResult: map[string]interface{}(map[string]interface{}{\"testStr\": \"hello world!\"}),\n\t\t\terr:            false,\n\t\t},\n\t\t{\n\t\t\tname:           \"string\",\n\t\t\tjson:           `\"hola amigos!\"`,\n\t\t\texpectedResult: interface{}(\"hola amigos!\"),\n\t\t\terr:            false,\n\t\t},\n\t\t{\n\t\t\tname:           \"bool-true\",\n\t\t\tjson:           `true`,\n\t\t\texpectedResult: interface{}(true),\n\t\t\terr:            false,\n\t\t},\n\t\t{\n\t\t\tname:           \"bool-false\",\n\t\t\tjson:           `false`,\n\t\t\texpectedResult: interface{}(false),\n\t\t\terr:            false,\n\t\t},\n\t\t{\n\t\t\tname:           \"null\",\n\t\t\tjson:           `null`,\n\t\t\texpectedResult: interface{}(nil),\n\t\t\terr:            false,\n\t\t},\n\t\t{\n\t\t\tname:           \"number\",\n\t\t\tjson:           `1234`,\n\t\t\texpectedResult: interface{}(float64(1234)),\n\t\t\terr:            false,\n\t\t},\n\t\t{\n\t\t\tname:            \"array-error\",\n\t\t\tjson:            `[\"h\"\"o\",\"l\",\"a\"]`,\n\t\t\terr:             true,\n\t\t\terrType:         &json.SyntaxError{},\n\t\t\tskipCheckResult: true,\n\t\t},\n\t\t{\n\t\t\tname:            \"object-error\",\n\t\t\tjson:            `{\"testStr\" \"hello world!\"}`,\n\t\t\terr:             true,\n\t\t\terrType:         &json.SyntaxError{},\n\t\t\tskipCheckResult: true,\n\t\t},\n\t\t{\n\t\t\tname:            \"string-error\",\n\t\t\tjson:            `\"hola amigos!`,\n\t\t\terr:             true,\n\t\t\terrType:         InvalidJSONError(\"\"),\n\t\t\tskipCheckResult: true,\n\t\t},\n\t\t{\n\t\t\tname:            \"bool-true-error\",\n\t\t\tjson:            `truee`,\n\t\t\terr:             true,\n\t\t\terrType:         InvalidJSONError(\"\"),\n\t\t\tskipCheckResult: true,\n\t\t},\n\t\t{\n\t\t\tname:            \"bool-false-error\",\n\t\t\tjson:            `fase`,\n\t\t\texpectedResult:  interface{}(false),\n\t\t\terr:             true,\n\t\t\terrType:         InvalidJSONError(\"\"),\n\t\t\tskipCheckResult: true,\n\t\t},\n\t\t{\n\t\t\tname:            \"null-error\",\n\t\t\tjson:            `nulllll`,\n\t\t\terr:             true,\n\t\t\terrType:         InvalidJSONError(\"\"),\n\t\t\tskipCheckResult: true,\n\t\t},\n\t\t{\n\t\t\tname:            \"number-error\",\n\t\t\tjson:            `1234\"`,\n\t\t\terr:             true,\n\t\t\terrType:         InvalidJSONError(\"\"),\n\t\t\tskipCheckResult: true,\n\t\t},\n\t\t{\n\t\t\tname:            \"unknown-error\",\n\t\t\tjson:            `?`,\n\t\t\terr:             true,\n\t\t\terrType:         InvalidJSONError(\"\"),\n\t\t\tskipCheckResult: true,\n\t\t},\n\t\t{\n\t\t\tname:            \"empty-json-error\",\n\t\t\tjson:            ``,\n\t\t\terr:             true,\n\t\t\terrType:         InvalidJSONError(\"\"),\n\t\t\tskipCheckResult: true,\n\t\t},\n\t}\n\n\tfor _, testCase := range testCases {\n\t\tt.Run(\"DecodeInterface()\"+testCase.name, func(t *testing.T) {\n\t\t\tvar i interface{}\n\t\t\tdec := BorrowDecoder(strings.NewReader(testCase.json))\n\t\t\tdefer dec.Release()\n\t\t\terr := dec.DecodeInterface(&i)\n\t\t\tif testCase.err {\n\t\t\t\tt.Log(err)\n\t\t\t\tassert.NotNil(t, err, \"err should not be nil\")\n\t\t\t\tif testCase.errType != nil {\n\t\t\t\t\tassert.IsType(t, testCase.errType, err, \"err should be of the given type\")\n\t\t\t\t}\n\t\t\t\treturn\n\t\t\t}\n\t\t\tassert.Nil(t, err, \"err should be nil\")\n\t\t\tif !testCase.skipCheckResult {\n\t\t\t\tassert.Equal(t, testCase.expectedResult, i, \"value at given index should be the same as expected results\")\n\t\t\t}\n\t\t})\n\t}\n\n\tfor _, testCase := range testCases {\n\t\tt.Run(\"Decode()\"+testCase.name, func(t *testing.T) {\n\t\t\tvar i interface{}\n\t\t\tdec := BorrowDecoder(strings.NewReader(testCase.json))\n\t\t\tdefer dec.Release()\n\t\t\terr := dec.Decode(&i)\n\t\t\tif testCase.err {\n\t\t\t\tt.Log(err)\n\t\t\t\tassert.NotNil(t, err, \"err should not be nil\")\n\t\t\t\tif testCase.errType != nil {\n\t\t\t\t\tassert.IsType(t, testCase.errType, err, \"err should be of the given type\")\n\t\t\t\t}\n\t\t\t\treturn\n\t\t\t}\n\t\t\tassert.Nil(t, err, \"err should be nil\")\n\t\t\tif !testCase.skipCheckResult {\n\t\t\t\tassert.Equal(t, testCase.expectedResult, i, \"value at given index should be the same as expected results\")\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestDecodeInterfaceAsInterface(t *testing.T) {\n\ttestCases := []struct {\n\t\tname            string\n\t\tjson            string\n\t\texpectedResult  interface{}\n\t\terr             bool\n\t\terrType         interface{}\n\t\tskipCheckResult bool\n\t}{\n\t\t{\n\t\t\tname: \"basic-array\",\n\t\t\tjson: `{\n        \"testStr\": \"hola\",\n        \"testInterface\": [\"h\",\"o\",\"l\",\"a\"]\n      }`,\n\t\t\texpectedResult: map[string]interface{}(\n\t\t\t\tmap[string]interface{}{\n\t\t\t\t\t\"testStr\":       \"hola\",\n\t\t\t\t\t\"testInterface\": []interface{}{\"h\", \"o\", \"l\", \"a\"},\n\t\t\t\t}),\n\t\t\terr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"basic-string\",\n\t\t\tjson: `{\n        \"testInterface\": \"漢字\"\n      }`,\n\t\t\texpectedResult: map[string]interface{}(\n\t\t\t\tmap[string]interface{}{\n\t\t\t\t\t\"testInterface\": \"漢字\",\n\t\t\t\t}),\n\t\t\terr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"basic-error\",\n\t\t\tjson: `{\n        \"testInterface\": [\"a\"\"d\",\"i\",\"o\",\"s\"]\n      }`,\n\t\t\terr:             true,\n\t\t\terrType:         &json.SyntaxError{},\n\t\t\tskipCheckResult: true,\n\t\t},\n\t\t{\n\t\t\tname: \"basic-interface\",\n\t\t\tjson: `{\n        \"testInterface\": {\n          \"string\": \"prost\"\n        }\n      }`,\n\t\t\texpectedResult: map[string]interface{}(\n\t\t\t\tmap[string]interface{}{\n\t\t\t\t\t\"testInterface\": map[string]interface{}{\"string\": \"prost\"},\n\t\t\t\t}),\n\t\t\terr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"complex-interface\",\n\t\t\tjson: `{\n        \"testInterface\": {\n          \"number\": 1988,\n          \"string\": \"prost\",\n          \"array\": [\"h\",\"o\",\"l\",\"a\"],\n          \"object\": {\n            \"k\": \"v\",\n            \"a\": [1,2,3]\n          },\n          \"array-of-objects\": [\n            {\"k\": \"v\"},\n            {\"a\": \"b\"}\n          ]\n        }\n      }`,\n\t\t\texpectedResult: map[string]interface{}(\n\t\t\t\tmap[string]interface{}{\n\t\t\t\t\t\"testInterface\": map[string]interface{}{\n\t\t\t\t\t\t\"array-of-objects\": []interface{}{\n\t\t\t\t\t\t\tmap[string]interface{}{\"k\": \"v\"},\n\t\t\t\t\t\t\tmap[string]interface{}{\"a\": \"b\"},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t\"number\": float64(1988),\n\t\t\t\t\t\t\"string\": \"prost\",\n\t\t\t\t\t\t\"array\":  []interface{}{\"h\", \"o\", \"l\", \"a\"},\n\t\t\t\t\t\t\"object\": map[string]interface{}{\n\t\t\t\t\t\t\t\"k\": \"v\",\n\t\t\t\t\t\t\t\"a\": []interface{}{float64(1), float64(2), float64(3)},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t}),\n\t\t\terr: false,\n\t\t},\n\t}\n\n\tfor _, testCase := range testCases {\n\t\tt.Run(\"Decode()\"+testCase.name, func(t *testing.T) {\n\t\t\tvar s interface{}\n\t\t\tdec := BorrowDecoder(strings.NewReader(testCase.json))\n\t\t\tdefer dec.Release()\n\t\t\terr := dec.Decode(&s)\n\t\t\tif testCase.err {\n\t\t\t\tt.Log(err)\n\t\t\t\tassert.NotNil(t, err, \"err should not be nil\")\n\t\t\t\tif testCase.errType != nil {\n\t\t\t\t\tassert.IsType(t, testCase.errType, err, \"err should be of the given type\")\n\t\t\t\t}\n\t\t\t\treturn\n\t\t\t}\n\t\t\tassert.Nil(t, err, \"err should be nil\")\n\t\t\tif !testCase.skipCheckResult {\n\t\t\t\tassert.Equal(t, testCase.expectedResult, s, \"value at given index should be the same as expected results\")\n\t\t\t}\n\t\t})\n\t}\n\n\tfor _, testCase := range testCases {\n\t\tt.Run(\"DecodeInterface()\"+testCase.name, func(t *testing.T) {\n\t\t\tvar s interface{}\n\t\t\tdec := BorrowDecoder(strings.NewReader(testCase.json))\n\t\t\tdefer dec.Release()\n\t\t\terr := dec.DecodeInterface(&s)\n\t\t\tif testCase.err {\n\t\t\t\tt.Log(err)\n\t\t\t\tassert.NotNil(t, err, \"err should not be nil\")\n\t\t\t\tif testCase.errType != nil {\n\t\t\t\t\tassert.IsType(t, testCase.errType, err, \"err should be of the given type\")\n\t\t\t\t}\n\t\t\t\treturn\n\t\t\t}\n\t\t\tassert.Nil(t, err, \"err should be nil\")\n\t\t\tif !testCase.skipCheckResult {\n\t\t\t\tassert.Equal(t, testCase.expectedResult, s, \"value at given index should be the same as expected results\")\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestDecodeAsTestObject(t *testing.T) {\n\ttestCases := []struct {\n\t\tname            string\n\t\tjson            string\n\t\texpectedResult  testObject\n\t\terr             bool\n\t\terrType         interface{}\n\t\tskipCheckResult bool\n\t}{\n\t\t{\n\t\t\tname: \"basic-array\",\n\t\t\tjson: `{\n        \"testStr\": \"hola\",\n        \"testInterface\": [\"h\",\"o\",\"l\",\"a\"]\n      }`,\n\t\t\texpectedResult: testObject{\n\t\t\t\ttestStr:       \"hola\",\n\t\t\t\ttestInterface: []interface{}([]interface{}{\"h\", \"o\", \"l\", \"a\"}),\n\t\t\t},\n\t\t\terr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"basic-string\",\n\t\t\tjson: `{\n        \"testInterface\": \"漢字\"\n      }`,\n\t\t\texpectedResult: testObject{\n\t\t\t\ttestInterface: interface{}(\"漢字\"),\n\t\t\t},\n\t\t\terr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"basic-error\",\n\t\t\tjson: `{\n        \"testInterface\": [\"a\"\"d\",\"i\",\"o\",\"s\"]\n      }`,\n\t\t\terr:             true,\n\t\t\terrType:         &json.SyntaxError{},\n\t\t\tskipCheckResult: true,\n\t\t},\n\t\t{\n\t\t\tname: \"mull-interface\",\n\t\t\tjson: `{\n        \"testInterface\": null,\n        \"testStr\": \"adios\"\n      }`,\n\t\t\texpectedResult: testObject{\n\t\t\t\ttestInterface: interface{}(nil),\n\t\t\t\ttestStr:       \"adios\",\n\t\t\t},\n\t\t\terr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"basic-interface\",\n\t\t\tjson: `{\n        \"testInterface\": {\n          \"string\": \"prost\"\n        },\n      }`,\n\t\t\texpectedResult: testObject{\n\t\t\t\ttestInterface: map[string]interface{}{\"string\": \"prost\"},\n\t\t\t},\n\t\t\terr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"complex-interface\",\n\t\t\tjson: `{\n        \"testInterface\": {\n          \"number\": 1988,\n          \"string\": \"prost\",\n          \"array\": [\"h\",\"o\",\"l\",\"a\"],\n          \"object\": {\n            \"k\": \"v\",\n            \"a\": [1,2,3]\n          },\n          \"array-of-objects\": [\n            {\"k\": \"v\"},\n            {\"a\": \"b\"}\n          ]\n        },\n      }`,\n\t\t\texpectedResult: testObject{\n\t\t\t\ttestInterface: map[string]interface{}{\n\t\t\t\t\t\"array-of-objects\": []interface{}{\n\t\t\t\t\t\tmap[string]interface{}{\"k\": \"v\"},\n\t\t\t\t\t\tmap[string]interface{}{\"a\": \"b\"},\n\t\t\t\t\t},\n\t\t\t\t\t\"number\": float64(1988),\n\t\t\t\t\t\"string\": \"prost\",\n\t\t\t\t\t\"array\":  []interface{}{\"h\", \"o\", \"l\", \"a\"},\n\t\t\t\t\t\"object\": map[string]interface{}{\n\t\t\t\t\t\t\"k\": \"v\",\n\t\t\t\t\t\t\"a\": []interface{}{float64(1), float64(2), float64(3)},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\terr: false,\n\t\t},\n\t}\n\tfor _, testCase := range testCases {\n\t\tt.Run(testCase.name, func(t *testing.T) {\n\t\t\ts := testObject{}\n\t\t\tdec := BorrowDecoder(strings.NewReader(testCase.json))\n\t\t\tdefer dec.Release()\n\t\t\terr := dec.Decode(&s)\n\t\t\tif testCase.err {\n\t\t\t\tt.Log(err)\n\t\t\t\tassert.NotNil(t, err, \"err should not be nil\")\n\t\t\t\tif testCase.errType != nil {\n\t\t\t\t\tassert.IsType(t, testCase.errType, err, \"err should be of the given type\")\n\t\t\t\t}\n\t\t\t\treturn\n\t\t\t}\n\t\t\tassert.Nil(t, err, \"err should be nil\")\n\t\t\tif !testCase.skipCheckResult {\n\t\t\t\tassert.Equal(t, testCase.expectedResult, s, \"value at given index should be the same as expected results\")\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestUnmarshalInterface(t *testing.T) {\n\tjson := []byte(`{\n    \"testInterface\": {\n      \"number\": 1988,\n      \"null\": null,\n      \"string\": \"prost\",\n      \"array\": [\"h\",\"o\",\"l\",\"a\"],\n      \"object\": {\n        \"k\": \"v\",\n        \"a\": [1,2,3]\n      },\n      \"array-of-objects\": [\n        {\"k\": \"v\"},\n        {\"a\": \"b\"}\n      ]\n    }\n\t}`)\n\tv := &testObject{}\n\terr := Unmarshal(json, v)\n\tassert.Nil(t, err, \"Err must be nil\")\n\texpectedInterface := map[string]interface{}{\n\t\t\"array-of-objects\": []interface{}{\n\t\t\tmap[string]interface{}{\"k\": \"v\"},\n\t\t\tmap[string]interface{}{\"a\": \"b\"},\n\t\t},\n\t\t\"number\": float64(1988),\n\t\t\"string\": \"prost\",\n\t\t\"null\":   interface{}(nil),\n\t\t\"array\":  []interface{}{\"h\", \"o\", \"l\", \"a\"},\n\t\t\"object\": map[string]interface{}{\n\t\t\t\"k\": \"v\",\n\t\t\t\"a\": []interface{}{float64(1), float64(2), float64(3)},\n\t\t},\n\t}\n\tassert.Equal(t, expectedInterface, v.testInterface, \"v.testInterface must be equal to the expected one\")\n}\n\nfunc TestUnmarshalInterfaceError(t *testing.T) {\n\ttestCases := []struct {\n\t\tname string\n\t\tjson []byte\n\t}{\n\t\t{\n\t\t\tname: \"basic\",\n\t\t\tjson: []byte(`{\"testInterface\": {\"number\": 1bc4}}`),\n\t\t},\n\t\t{\n\t\t\tname: \"syntax\",\n\t\t\tjson: []byte(`{\n        \"testInterface\": {\n          \"array?\": [1,\"a\", ?]\n        }\n      }`),\n\t\t},\n\t\t{\n\t\t\tname: \"complex\",\n\t\t\tjson: []byte(`{\n        \"testInterface\": {\n          \"number\": 1988,\n          \"string\": \"prost\",\n          \"array\": [\"h\"\"o\",\"l\",\"a\"],\n          \"object\": {\n            \"k\": \"v\",\n            \"a\": [1,2,3]\n          },\n          \"array-of-objects\": [\n            {\"k\": \"v\"},\n            {\"a\": \"b\"}\n          ]\n        }\n      }`),\n\t\t},\n\t}\n\tfor _, testCase := range testCases {\n\t\tt.Run(testCase.name, func(t *testing.T) {\n\t\t\tv := &testObject{}\n\t\t\terr := Unmarshal(testCase.json, v)\n\t\t\tassert.NotNil(t, err, \"Err must be not nil\")\n\t\t\tt.Log(err)\n\t\t\tassert.IsType(t, &json.SyntaxError{}, err, \"err should be a json.SyntaxError{}\")\n\t\t})\n\t}\n}\n\nfunc TestDecodeInterfacePoolError(t *testing.T) {\n\tresult := interface{}(1)\n\tdec := NewDecoder(nil)\n\tdec.Release()\n\tdefer func() {\n\t\terr := recover()\n\t\tassert.NotNil(t, err, \"err shouldnt be nil\")\n\t\tassert.IsType(t, InvalidUsagePooledDecoderError(\"\"), err, \"err should be of type InvalidUsagePooledDecoderError\")\n\t}()\n\t_ = dec.DecodeInterface(&result)\n\tassert.True(t, false, \"should not be called as decoder should have panicked\")\n}\n\nfunc TestDecodeNull(t *testing.T) {\n\tvar i interface{}\n\tdec := BorrowDecoder(strings.NewReader(\"null\"))\n\tdefer dec.Release()\n\terr := dec.DecodeInterface(&i)\n\tassert.Nil(t, err, \"err should be nil\")\n\tassert.Equal(t, interface{}(nil), i, \"value at given index should be the same as expected results\")\n}\n"
        },
        {
          "name": "decode_number.go",
          "type": "blob",
          "size": 2.580078125,
          "content": "package gojay\n\nimport (\n\t\"math\"\n)\n\nvar digits []int8\n\nconst maxInt64toMultiply = math.MaxInt64 / 10\nconst maxInt32toMultiply = math.MaxInt32 / 10\nconst maxInt16toMultiply = math.MaxInt16 / 10\nconst maxInt8toMultiply = math.MaxInt8 / 10\nconst maxUint8toMultiply = math.MaxUint8 / 10\nconst maxUint16toMultiply = math.MaxUint16 / 10\nconst maxUint32toMultiply = math.MaxUint32 / 10\nconst maxUint64toMultiply = math.MaxUint64 / 10\nconst maxUint32Length = 10\nconst maxUint64Length = 20\nconst maxUint16Length = 5\nconst maxUint8Length = 3\nconst maxInt32Length = 10\nconst maxInt64Length = 19\nconst maxInt16Length = 5\nconst maxInt8Length = 3\nconst invalidNumber = int8(-1)\n\nvar pow10uint64 = [21]uint64{\n\t0,\n\t1,\n\t10,\n\t100,\n\t1000,\n\t10000,\n\t100000,\n\t1000000,\n\t10000000,\n\t100000000,\n\t1000000000,\n\t10000000000,\n\t100000000000,\n\t1000000000000,\n\t10000000000000,\n\t100000000000000,\n\t1000000000000000,\n\t10000000000000000,\n\t100000000000000000,\n\t1000000000000000000,\n\t10000000000000000000,\n}\n\nvar skipNumberEndCursorIncrement [256]int\n\nfunc init() {\n\tdigits = make([]int8, 256)\n\tfor i := 0; i < len(digits); i++ {\n\t\tdigits[i] = invalidNumber\n\t}\n\tfor i := int8('0'); i <= int8('9'); i++ {\n\t\tdigits[i] = i - int8('0')\n\t}\n\n\tfor i := 0; i < 256; i++ {\n\t\tswitch i {\n\t\tcase '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '.', 'e', 'E', '+', '-':\n\t\t\tskipNumberEndCursorIncrement[i] = 1\n\t\t}\n\t}\n}\n\nfunc (dec *Decoder) skipNumber() (int, error) {\n\tend := dec.cursor + 1\n\t// look for following numbers\n\tfor j := dec.cursor + 1; j < dec.length || dec.read(); j++ {\n\t\tend += skipNumberEndCursorIncrement[dec.data[j]]\n\n\t\tswitch dec.data[j] {\n\t\tcase '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '.', 'e', 'E', '+', '-', ' ', '\\n', '\\t', '\\r':\n\t\t\tcontinue\n\t\tcase ',', '}', ']':\n\t\t\treturn end, nil\n\t\tdefault:\n\t\t\t// invalid json we expect numbers, dot (single one), comma, or spaces\n\t\t\treturn end, dec.raiseInvalidJSONErr(dec.cursor)\n\t\t}\n\t}\n\n\treturn end, nil\n}\n\nfunc (dec *Decoder) getExponent() (int64, error) {\n\tstart := dec.cursor\n\tend := dec.cursor\n\tfor ; dec.cursor < dec.length || dec.read(); dec.cursor++ {\n\t\tswitch dec.data[dec.cursor] { // is positive\n\t\tcase '0', '1', '2', '3', '4', '5', '6', '7', '8', '9':\n\t\t\tend = dec.cursor + 1\n\t\tcase '-':\n\t\t\tdec.cursor++\n\t\t\texp, err := dec.getExponent()\n\t\t\treturn -exp, err\n\t\tcase '+':\n\t\t\tdec.cursor++\n\t\t\treturn dec.getExponent()\n\t\tdefault:\n\t\t\t// if nothing return 0\n\t\t\t// could raise error\n\t\t\tif start == end {\n\t\t\t\treturn 0, dec.raiseInvalidJSONErr(dec.cursor)\n\t\t\t}\n\t\t\treturn dec.atoi64(start, end-1), nil\n\t\t}\n\t}\n\tif start == end {\n\n\t\treturn 0, dec.raiseInvalidJSONErr(dec.cursor)\n\t}\n\treturn dec.atoi64(start, end-1), nil\n}\n"
        },
        {
          "name": "decode_number_float.go",
          "type": "blob",
          "size": 15.150390625,
          "content": "package gojay\n\n// DecodeFloat64 reads the next JSON-encoded value from the decoder's input (io.Reader) and stores it in the float64 pointed to by v.\n//\n// See the documentation for Unmarshal for details about the conversion of JSON into a Go value.\nfunc (dec *Decoder) DecodeFloat64(v *float64) error {\n\tif dec.isPooled == 1 {\n\t\tpanic(InvalidUsagePooledDecoderError(\"Invalid usage of pooled decoder\"))\n\t}\n\treturn dec.decodeFloat64(v)\n}\nfunc (dec *Decoder) decodeFloat64(v *float64) error {\n\tfor ; dec.cursor < dec.length || dec.read(); dec.cursor++ {\n\t\tswitch c := dec.data[dec.cursor]; c {\n\t\tcase ' ', '\\n', '\\t', '\\r', ',':\n\t\t\tcontinue\n\t\tcase '0', '1', '2', '3', '4', '5', '6', '7', '8', '9':\n\t\t\tval, err := dec.getFloat()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\t*v = val\n\t\t\treturn nil\n\t\tcase '-':\n\t\t\tdec.cursor = dec.cursor + 1\n\t\t\tval, err := dec.getFloatNegative()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\t*v = -val\n\t\t\treturn nil\n\t\tcase 'n':\n\t\t\tdec.cursor++\n\t\t\terr := dec.assertNull()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\treturn nil\n\t\tdefault:\n\t\t\tdec.err = dec.makeInvalidUnmarshalErr(v)\n\t\t\terr := dec.skipData()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\treturn nil\n\t\t}\n\t}\n\treturn dec.raiseInvalidJSONErr(dec.cursor)\n}\nfunc (dec *Decoder) decodeFloat64Null(v **float64) error {\n\tfor ; dec.cursor < dec.length || dec.read(); dec.cursor++ {\n\t\tswitch c := dec.data[dec.cursor]; c {\n\t\tcase ' ', '\\n', '\\t', '\\r', ',':\n\t\t\tcontinue\n\t\tcase '0', '1', '2', '3', '4', '5', '6', '7', '8', '9':\n\t\t\tval, err := dec.getFloat()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif *v == nil {\n\t\t\t\t*v = new(float64)\n\t\t\t}\n\t\t\t**v = val\n\t\t\treturn nil\n\t\tcase '-':\n\t\t\tdec.cursor = dec.cursor + 1\n\t\t\tval, err := dec.getFloatNegative()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif *v == nil {\n\t\t\t\t*v = new(float64)\n\t\t\t}\n\t\t\t**v = -val\n\t\t\treturn nil\n\t\tcase 'n':\n\t\t\tdec.cursor++\n\t\t\terr := dec.assertNull()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\treturn nil\n\t\tdefault:\n\t\t\tdec.err = dec.makeInvalidUnmarshalErr(v)\n\t\t\terr := dec.skipData()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\treturn nil\n\t\t}\n\t}\n\treturn dec.raiseInvalidJSONErr(dec.cursor)\n}\n\nfunc (dec *Decoder) getFloatNegative() (float64, error) {\n\t// look for following numbers\n\tfor ; dec.cursor < dec.length || dec.read(); dec.cursor++ {\n\t\tswitch dec.data[dec.cursor] {\n\t\tcase '0', '1', '2', '3', '4', '5', '6', '7', '8', '9':\n\t\t\treturn dec.getFloat()\n\t\tdefault:\n\t\t\treturn 0, dec.raiseInvalidJSONErr(dec.cursor)\n\t\t}\n\t}\n\treturn 0, dec.raiseInvalidJSONErr(dec.cursor)\n}\n\nfunc (dec *Decoder) getFloat() (float64, error) {\n\tvar end = dec.cursor\n\tvar start = dec.cursor\n\t// look for following numbers\n\tfor j := dec.cursor + 1; j < dec.length || dec.read(); j++ {\n\t\tswitch dec.data[j] {\n\t\tcase '0', '1', '2', '3', '4', '5', '6', '7', '8', '9':\n\t\t\tend = j\n\t\t\tcontinue\n\t\tcase '.':\n\t\t\t// we get part before decimal as integer\n\t\t\tbeforeDecimal := dec.atoi64(start, end)\n\t\t\t// then we get part after decimal as integer\n\t\t\tstart = j + 1\n\t\t\t// get number after the decimal point\n\t\t\tfor i := j + 1; i < dec.length || dec.read(); i++ {\n\t\t\t\tc := dec.data[i]\n\t\t\t\tif isDigit(c) {\n\t\t\t\t\tend = i\n\t\t\t\t\t// multiply the before decimal point portion by 10 using bitwise\n\t\t\t\t\t// make sure it doesn't overflow\n\t\t\t\t\tif end-start < 18 {\n\t\t\t\t\t\tbeforeDecimal = (beforeDecimal << 3) + (beforeDecimal << 1)\n\t\t\t\t\t}\n\t\t\t\t\tcontinue\n\t\t\t\t} else if (c == 'e' || c == 'E') && j < i-1 {\n\t\t\t\t\t// we have an exponent, convert first the value we got before the exponent\n\t\t\t\t\tvar afterDecimal int64\n\t\t\t\t\texpI := end - start + 2\n\t\t\t\t\t// if exp is too long, it means number is too long, just truncate the number\n\t\t\t\t\tif expI >= len(pow10uint64) || expI < 0 {\n\t\t\t\t\t\texpI = len(pow10uint64) - 2\n\t\t\t\t\t\tafterDecimal = dec.atoi64(start, start+expI-2)\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// then we add both integers\n\t\t\t\t\t\t// then we divide the number by the power found\n\t\t\t\t\t\tafterDecimal = dec.atoi64(start, end)\n\t\t\t\t\t}\n\t\t\t\t\tdec.cursor = i + 1\n\t\t\t\t\tpow := pow10uint64[expI]\n\t\t\t\t\tfloatVal := float64(beforeDecimal+afterDecimal) / float64(pow)\n\t\t\t\t\texp, err := dec.getExponent()\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\treturn 0, err\n\t\t\t\t\t}\n\t\t\t\t\tpExp := (exp + (exp >> 31)) ^ (exp >> 31) + 1 // absolute exponent\n\t\t\t\t\tif pExp >= int64(len(pow10uint64)) || pExp < 0 {\n\t\t\t\t\t\treturn 0, dec.raiseInvalidJSONErr(dec.cursor)\n\t\t\t\t\t}\n\t\t\t\t\t// if exponent is negative\n\t\t\t\t\tif exp < 0 {\n\t\t\t\t\t\treturn float64(floatVal) * (1 / float64(pow10uint64[pExp])), nil\n\t\t\t\t\t}\n\t\t\t\t\treturn float64(floatVal) * float64(pow10uint64[pExp]), nil\n\t\t\t\t}\n\t\t\t\tdec.cursor = i\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tif end >= dec.length || end < start {\n\t\t\t\treturn 0, dec.raiseInvalidJSONErr(dec.cursor)\n\t\t\t}\n\t\t\tvar afterDecimal int64\n\t\t\texpI := end - start + 2\n\t\t\t// if exp is too long, it means number is too long, just truncate the number\n\t\t\tif expI >= len(pow10uint64) || expI < 0 {\n\t\t\t\texpI = 19\n\t\t\t\tafterDecimal = dec.atoi64(start, start+expI-2)\n\t\t\t} else {\n\t\t\t\tafterDecimal = dec.atoi64(start, end)\n\t\t\t}\n\n\t\t\tpow := pow10uint64[expI]\n\t\t\t// then we add both integers\n\t\t\t// then we divide the number by the power found\n\t\t\treturn float64(beforeDecimal+afterDecimal) / float64(pow), nil\n\t\tcase 'e', 'E':\n\t\t\tdec.cursor = j + 1\n\t\t\t// we get part before decimal as integer\n\t\t\tbeforeDecimal := uint64(dec.atoi64(start, end))\n\t\t\t// get exponent\n\t\t\texp, err := dec.getExponent()\n\t\t\tif err != nil {\n\t\t\t\treturn 0, err\n\t\t\t}\n\t\t\tpExp := (exp + (exp >> 31)) ^ (exp >> 31) + 1 // abs\n\t\t\tif pExp >= int64(len(pow10uint64)) || pExp < 0 {\n\t\t\t\treturn 0, dec.raiseInvalidJSONErr(dec.cursor)\n\t\t\t}\n\t\t\t// if exponent is negative\n\t\t\tif exp < 0 {\n\t\t\t\treturn float64(beforeDecimal) * (1 / float64(pow10uint64[pExp])), nil\n\t\t\t}\n\t\t\treturn float64(beforeDecimal) * float64(pow10uint64[pExp]), nil\n\t\tcase ' ', '\\n', '\\t', '\\r', ',', '}', ']': // does not have decimal\n\t\t\tdec.cursor = j\n\t\t\treturn float64(dec.atoi64(start, end)), nil\n\t\t}\n\t\t// invalid json we expect numbers, dot (single one), comma, or spaces\n\t\treturn 0, dec.raiseInvalidJSONErr(dec.cursor)\n\t}\n\treturn float64(dec.atoi64(start, end)), nil\n}\n\n// DecodeFloat32 reads the next JSON-encoded value from the decoder's input (io.Reader) and stores it in the float32 pointed to by v.\n//\n// See the documentation for Unmarshal for details about the conversion of JSON into a Go value.\nfunc (dec *Decoder) DecodeFloat32(v *float32) error {\n\tif dec.isPooled == 1 {\n\t\tpanic(InvalidUsagePooledDecoderError(\"Invalid usage of pooled decoder\"))\n\t}\n\treturn dec.decodeFloat32(v)\n}\nfunc (dec *Decoder) decodeFloat32(v *float32) error {\n\tfor ; dec.cursor < dec.length || dec.read(); dec.cursor++ {\n\t\tswitch c := dec.data[dec.cursor]; c {\n\t\tcase ' ', '\\n', '\\t', '\\r', ',':\n\t\t\tcontinue\n\t\tcase '0', '1', '2', '3', '4', '5', '6', '7', '8', '9':\n\t\t\tval, err := dec.getFloat32()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\t*v = val\n\t\t\treturn nil\n\t\tcase '-':\n\t\t\tdec.cursor = dec.cursor + 1\n\t\t\tval, err := dec.getFloat32Negative()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\t*v = -val\n\t\t\treturn nil\n\t\tcase 'n':\n\t\t\tdec.cursor++\n\t\t\terr := dec.assertNull()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\treturn nil\n\t\tdefault:\n\t\t\tdec.err = dec.makeInvalidUnmarshalErr(v)\n\t\t\terr := dec.skipData()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\treturn nil\n\t\t}\n\t}\n\treturn dec.raiseInvalidJSONErr(dec.cursor)\n}\nfunc (dec *Decoder) decodeFloat32Null(v **float32) error {\n\tfor ; dec.cursor < dec.length || dec.read(); dec.cursor++ {\n\t\tswitch c := dec.data[dec.cursor]; c {\n\t\tcase ' ', '\\n', '\\t', '\\r', ',':\n\t\t\tcontinue\n\t\tcase '0', '1', '2', '3', '4', '5', '6', '7', '8', '9':\n\t\t\tval, err := dec.getFloat32()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif *v == nil {\n\t\t\t\t*v = new(float32)\n\t\t\t}\n\t\t\t**v = val\n\t\t\treturn nil\n\t\tcase '-':\n\t\t\tdec.cursor = dec.cursor + 1\n\t\t\tval, err := dec.getFloat32Negative()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif *v == nil {\n\t\t\t\t*v = new(float32)\n\t\t\t}\n\t\t\t**v = -val\n\t\t\treturn nil\n\t\tcase 'n':\n\t\t\tdec.cursor++\n\t\t\terr := dec.assertNull()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\treturn nil\n\t\tdefault:\n\t\t\tdec.err = dec.makeInvalidUnmarshalErr(v)\n\t\t\terr := dec.skipData()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\treturn nil\n\t\t}\n\t}\n\treturn dec.raiseInvalidJSONErr(dec.cursor)\n}\n\nfunc (dec *Decoder) getFloat32Negative() (float32, error) {\n\t// look for following numbers\n\tfor ; dec.cursor < dec.length || dec.read(); dec.cursor++ {\n\t\tswitch dec.data[dec.cursor] {\n\t\tcase '0', '1', '2', '3', '4', '5', '6', '7', '8', '9':\n\t\t\treturn dec.getFloat32()\n\t\tdefault:\n\t\t\treturn 0, dec.raiseInvalidJSONErr(dec.cursor)\n\t\t}\n\t}\n\treturn 0, dec.raiseInvalidJSONErr(dec.cursor)\n}\n\nfunc (dec *Decoder) getFloat32() (float32, error) {\n\tvar end = dec.cursor\n\tvar start = dec.cursor\n\t// look for following numbers\n\tfor j := dec.cursor + 1; j < dec.length || dec.read(); j++ {\n\t\tswitch dec.data[j] {\n\t\tcase '0', '1', '2', '3', '4', '5', '6', '7', '8', '9':\n\t\t\tend = j\n\t\t\tcontinue\n\t\tcase '.':\n\t\t\t// we get part before decimal as integer\n\t\t\tbeforeDecimal := dec.atoi64(start, end)\n\t\t\t// then we get part after decimal as integer\n\t\t\tstart = j + 1\n\t\t\t// get number after the decimal point\n\t\t\t// multiple the before decimal point portion by 10 using bitwise\n\t\t\tfor i := j + 1; i < dec.length || dec.read(); i++ {\n\t\t\t\tc := dec.data[i]\n\t\t\t\tif isDigit(c) {\n\t\t\t\t\tend = i\n\t\t\t\t\t// multiply the before decimal point portion by 10 using bitwise\n\t\t\t\t\t// make sure it desn't overflow\n\t\t\t\t\tif end-start < 9 {\n\t\t\t\t\t\tbeforeDecimal = (beforeDecimal << 3) + (beforeDecimal << 1)\n\t\t\t\t\t}\n\t\t\t\t\tcontinue\n\t\t\t\t} else if (c == 'e' || c == 'E') && j < i-1 {\n\t\t\t\t\t// we get the number before decimal\n\t\t\t\t\tvar afterDecimal int64\n\t\t\t\t\texpI := end - start + 2\n\t\t\t\t\t// if exp is too long, it means number is too long, just truncate the number\n\t\t\t\t\tif expI >= 12 || expI < 0 {\n\t\t\t\t\t\texpI = 10\n\t\t\t\t\t\tafterDecimal = dec.atoi64(start, start+expI-2)\n\t\t\t\t\t} else {\n\t\t\t\t\t\tafterDecimal = dec.atoi64(start, end)\n\t\t\t\t\t}\n\t\t\t\t\tdec.cursor = i + 1\n\t\t\t\t\tpow := pow10uint64[expI]\n\t\t\t\t\t// then we add both integers\n\t\t\t\t\t// then we divide the number by the power found\n\t\t\t\t\tfloatVal := float32(beforeDecimal+afterDecimal) / float32(pow)\n\t\t\t\t\texp, err := dec.getExponent()\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\treturn 0, err\n\t\t\t\t\t}\n\t\t\t\t\tpExp := (exp + (exp >> 31)) ^ (exp >> 31) + 1 // abs\n\t\t\t\t\tif pExp >= int64(len(pow10uint64)) || pExp < 0 {\n\t\t\t\t\t\treturn 0, dec.raiseInvalidJSONErr(dec.cursor)\n\t\t\t\t\t}\n\t\t\t\t\t// if exponent is negative\n\t\t\t\t\tif exp < 0 {\n\t\t\t\t\t\treturn float32(floatVal) * (1 / float32(pow10uint64[pExp])), nil\n\t\t\t\t\t}\n\t\t\t\t\treturn float32(floatVal) * float32(pow10uint64[pExp]), nil\n\t\t\t\t}\n\t\t\t\tdec.cursor = i\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tif end >= dec.length || end < start {\n\t\t\t\treturn 0, dec.raiseInvalidJSONErr(dec.cursor)\n\t\t\t}\n\t\t\t// then we add both integers\n\t\t\t// then we divide the number by the power found\n\t\t\tvar afterDecimal int64\n\t\t\texpI := end - start + 2\n\t\t\t// if exp is too long, it means number is too long, just truncate the number\n\t\t\tif expI >= 12 || expI < 0 {\n\t\t\t\texpI = 10\n\t\t\t\tafterDecimal = dec.atoi64(start, start+expI-2)\n\t\t\t} else {\n\t\t\t\t// then we add both integers\n\t\t\t\t// then we divide the number by the power found\n\t\t\t\tafterDecimal = dec.atoi64(start, end)\n\t\t\t}\n\t\t\tpow := pow10uint64[expI]\n\t\t\treturn float32(beforeDecimal+afterDecimal) / float32(pow), nil\n\t\tcase 'e', 'E':\n\t\t\tdec.cursor = j + 1\n\t\t\t// we get part before decimal as integer\n\t\t\tbeforeDecimal := dec.atoi64(start, end)\n\t\t\t// get exponent\n\t\t\texp, err := dec.getExponent()\n\t\t\tif err != nil {\n\t\t\t\treturn 0, err\n\t\t\t}\n\t\t\tpExp := (exp + (exp >> 31)) ^ (exp >> 31) + 1\n\t\t\tif pExp >= int64(len(pow10uint64)) || pExp < 0 {\n\t\t\t\treturn 0, dec.raiseInvalidJSONErr(dec.cursor)\n\t\t\t}\n\t\t\t// if exponent is negative\n\t\t\tif exp < 0 {\n\t\t\t\treturn float32(beforeDecimal) * (1 / float32(pow10uint64[pExp])), nil\n\t\t\t}\n\t\t\treturn float32(beforeDecimal) * float32(pow10uint64[pExp]), nil\n\t\tcase ' ', '\\n', '\\t', '\\r', ',', '}', ']': // does not have decimal\n\t\t\tdec.cursor = j\n\t\t\treturn float32(dec.atoi64(start, end)), nil\n\t\t}\n\t\t// invalid json we expect numbers, dot (single one), comma, or spaces\n\t\treturn 0, dec.raiseInvalidJSONErr(dec.cursor)\n\t}\n\treturn float32(dec.atoi64(start, end)), nil\n}\n\n// Add Values functions\n\n// AddFloat decodes the JSON value within an object or an array to a *float64.\n// If next key value overflows float64, an InvalidUnmarshalError error will be returned.\nfunc (dec *Decoder) AddFloat(v *float64) error {\n\treturn dec.Float64(v)\n}\n\n// AddFloatNull decodes the JSON value within an object or an array to a *float64.\n// If next key value overflows float64, an InvalidUnmarshalError error will be returned.\n// If a `null` is encountered, gojay does not change the value of the pointer.\nfunc (dec *Decoder) AddFloatNull(v **float64) error {\n\treturn dec.Float64Null(v)\n}\n\n// AddFloat64 decodes the JSON value within an object or an array to a *float64.\n// If next key value overflows float64, an InvalidUnmarshalError error will be returned.\nfunc (dec *Decoder) AddFloat64(v *float64) error {\n\treturn dec.Float64(v)\n}\n\n// AddFloat64Null decodes the JSON value within an object or an array to a *float64.\n// If next key value overflows float64, an InvalidUnmarshalError error will be returned.\n// If a `null` is encountered, gojay does not change the value of the pointer.\nfunc (dec *Decoder) AddFloat64Null(v **float64) error {\n\treturn dec.Float64Null(v)\n}\n\n// AddFloat32 decodes the JSON value within an object or an array to a *float64.\n// If next key value overflows float64, an InvalidUnmarshalError error will be returned.\nfunc (dec *Decoder) AddFloat32(v *float32) error {\n\treturn dec.Float32(v)\n}\n\n// AddFloat32Null decodes the JSON value within an object or an array to a *float64.\n// If next key value overflows float64, an InvalidUnmarshalError error will be returned.\n// If a `null` is encountered, gojay does not change the value of the pointer.\nfunc (dec *Decoder) AddFloat32Null(v **float32) error {\n\treturn dec.Float32Null(v)\n}\n\n// Float decodes the JSON value within an object or an array to a *float64.\n// If next key value overflows float64, an InvalidUnmarshalError error will be returned.\nfunc (dec *Decoder) Float(v *float64) error {\n\treturn dec.Float64(v)\n}\n\n// FloatNull decodes the JSON value within an object or an array to a *float64.\n// If next key value overflows float64, an InvalidUnmarshalError error will be returned.\nfunc (dec *Decoder) FloatNull(v **float64) error {\n\treturn dec.Float64Null(v)\n}\n\n// Float64 decodes the JSON value within an object or an array to a *float64.\n// If next key value overflows float64, an InvalidUnmarshalError error will be returned.\nfunc (dec *Decoder) Float64(v *float64) error {\n\terr := dec.decodeFloat64(v)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdec.called |= 1\n\treturn nil\n}\n\n// Float64Null decodes the JSON value within an object or an array to a *float64.\n// If next key value overflows float64, an InvalidUnmarshalError error will be returned.\nfunc (dec *Decoder) Float64Null(v **float64) error {\n\terr := dec.decodeFloat64Null(v)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdec.called |= 1\n\treturn nil\n}\n\n// Float32 decodes the JSON value within an object or an array to a *float64.\n// If next key value overflows float64, an InvalidUnmarshalError error will be returned.\nfunc (dec *Decoder) Float32(v *float32) error {\n\terr := dec.decodeFloat32(v)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdec.called |= 1\n\treturn nil\n}\n\n// Float32Null decodes the JSON value within an object or an array to a *float64.\n// If next key value overflows float64, an InvalidUnmarshalError error will be returned.\nfunc (dec *Decoder) Float32Null(v **float32) error {\n\terr := dec.decodeFloat32Null(v)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdec.called |= 1\n\treturn nil\n}\n"
        },
        {
          "name": "decode_number_float_test.go",
          "type": "blob",
          "size": 30.6796875,
          "content": "package gojay\n\nimport (\n\t\"fmt\"\n\t\"math\"\n\t\"reflect\"\n\t\"strings\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestDecoderFloat64(t *testing.T) {\n\ttestCases := []struct {\n\t\tname           string\n\t\tjson           string\n\t\texpectedResult float64\n\t\tskipResult     bool\n\t\terr            bool\n\t\terrType        interface{}\n\t}{\n\t\t{\n\t\t\tname:           \"basic-float\",\n\t\t\tjson:           \"1.1\",\n\t\t\texpectedResult: 1.1,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-exponent-positive-positive-exp\",\n\t\t\tjson:           \"1e2\",\n\t\t\texpectedResult: 100,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-exponent-positive-positive-exp2\",\n\t\t\tjson:           \"5e+06\",\n\t\t\texpectedResult: 5000000,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-exponent-positive-positive-exp3\",\n\t\t\tjson:           \"3e+3\",\n\t\t\texpectedResult: 3000,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-null\",\n\t\t\tjson:           \"null\",\n\t\t\texpectedResult: 0,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-null-err\",\n\t\t\tjson:           \"nxll\",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t\terrType:        InvalidJSONError(\"\"),\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-negative-err\",\n\t\t\tjson:           \"-\",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t\terrType:        InvalidJSONError(\"\"),\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-negative-err\",\n\t\t\tjson:           \"-q\",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t\terrType:        InvalidJSONError(\"\"),\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-null-err\",\n\t\t\tjson:           \"trua\",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t\terrType:        InvalidJSONError(\"\"),\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-err1\",\n\t\t\tjson:           \"0.\",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-err2\",\n\t\t\tjson:           \"-1.\",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t},\n\t\t{\n\t\t\tname:           \"exponent-err-\",\n\t\t\tjson:           \"0.1e\",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t},\n\t\t{\n\t\t\tname:           \"exp-err\",\n\t\t\tjson:           \"0e-20\",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t},\n\t\t{\n\t\t\tname:           \"exp-err3\",\n\t\t\tjson:           \"-9e-60\",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t},\n\t\t{\n\t\t\tname:       \"exp-err4\",\n\t\t\tjson:       \"0.e-2\",\n\t\t\tskipResult: true,\n\t\t\terr:        true,\n\t\t},\n\t\t{\n\t\t\tname:       \"exp-err5\",\n\t\t\tjson:       \"-5.E-2\",\n\t\t\tskipResult: true,\n\t\t\terr:        true,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-exponent-positive-positive-exp4\",\n\t\t\tjson:           \"8e+005\",\n\t\t\texpectedResult: 800000,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-exponent-positive-negative-exp\",\n\t\t\tjson:           \"1e-2\",\n\t\t\texpectedResult: 0.01,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-exponent-positive-negative-exp2\",\n\t\t\tjson:           \"5e-6\",\n\t\t\texpectedResult: 0.000005,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-exponent-positive-negative-exp3\",\n\t\t\tjson:           \"3e-3\",\n\t\t\texpectedResult: 0.003,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-exponent-positive-negative-exp4\",\n\t\t\tjson:           \"8e-005\",\n\t\t\texpectedResult: 0.00008,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-exponent-negative-positive-exp\",\n\t\t\tjson:           \"-1e2\",\n\t\t\texpectedResult: -100,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-exponent-negative-positive-exp2\",\n\t\t\tjson:           \"-5e+06\",\n\t\t\texpectedResult: -5000000,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-exponent-negative-positive-exp3\",\n\t\t\tjson:           \"-3e03\",\n\t\t\texpectedResult: -3000,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-float2\",\n\t\t\tjson:           \"877 \",\n\t\t\texpectedResult: 877,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-exponent-negative-positive-exp4\",\n\t\t\tjson:           \"-8e+005\",\n\t\t\texpectedResult: -800000,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-exponent-negative-positive-exp4\",\n\t\t\tjson:           \"-8.2e-005\",\n\t\t\texpectedResult: -0.000082,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-float\",\n\t\t\tjson:           \"2.4595\",\n\t\t\texpectedResult: 2.4595,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-float2\",\n\t\t\tjson:           \"877\",\n\t\t\texpectedResult: 877,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-float2\",\n\t\t\tjson:           \"-7.8876\",\n\t\t\texpectedResult: -7.8876,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-float\",\n\t\t\tjson:           \"2.4595e1\",\n\t\t\texpectedResult: 24.595,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-float2\",\n\t\t\tjson:           \"-7.8876e002\",\n\t\t\texpectedResult: -788.76,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-float3\",\n\t\t\tjson:           \"-0.1234\",\n\t\t\texpectedResult: -0.1234,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-exp-too-big\",\n\t\t\tjson:           \"1e10000000000 \",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-exp-too-big\",\n\t\t\tjson:           \"1.002e10000000000 \",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-exp-too-big\",\n\t\t\tjson:           \"0e9223372036000000000 \",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t},\n\t\t{\n\t\t\tname:           \"big float\",\n\t\t\tjson:           \"1.00232492420002423545849009\",\n\t\t\texpectedResult: 1.002325,\n\t\t},\n\t\t{\n\t\t\tname:           \"big float\",\n\t\t\tjson:           \"5620.1400000000003\",\n\t\t\texpectedResult: 5620.14,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-exp-too-big\",\n\t\t\tjson:           \"1.00232492420002423545849009e10000000000 \",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t},\n\t\t{\n\t\t\tname:           \"error\",\n\t\t\tjson:           \"83zez4\",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t\terrType:        InvalidJSONError(\"\"),\n\t\t},\n\t\t{\n\t\t\tname:           \"exponent-err\",\n\t\t\tjson:           \"0.1e\",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t},\n\t\t{\n\t\t\tname:           \"exponent-err\",\n\t\t\tjson:           \"0e\",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t},\n\t\t{\n\t\t\tname:           \"error\",\n\t\t\tjson:           \"-83zez4\",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t\terrType:        InvalidJSONError(\"\"),\n\t\t},\n\t\t{\n\t\t\tname:           \"invalid-type\",\n\t\t\tjson:           `\"string\"`,\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t\terrType:        InvalidUnmarshalError(\"\"),\n\t\t},\n\t\t{\n\t\t\tname:           \"big float\",\n\t\t\tjson:           \"5620.1400000000003\",\n\t\t\texpectedResult: 5620.1400000000003,\n\t\t},\n\t}\n\tfor _, testCase := range testCases {\n\t\tt.Run(testCase.name, func(t *testing.T) {\n\t\t\tjson := []byte(testCase.json)\n\t\t\tvar v float64\n\t\t\terr := Unmarshal(json, &v)\n\t\t\tif testCase.err {\n\t\t\t\tassert.NotNil(t, err, \"Err must not be nil\")\n\t\t\t\tif testCase.errType != nil {\n\t\t\t\t\tassert.IsType(\n\t\t\t\t\t\tt,\n\t\t\t\t\t\ttestCase.errType,\n\t\t\t\t\t\terr,\n\t\t\t\t\t\tfmt.Sprintf(\"err should be of type %s\", reflect.TypeOf(err).String()),\n\t\t\t\t\t)\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tassert.Nil(t, err, \"Err must be nil\")\n\t\t\t}\n\t\t\tif !testCase.skipResult {\n\t\t\t\tassert.Equal(t, math.Round(testCase.expectedResult*1000000), math.Round(v*1000000), fmt.Sprintf(\"v must be equal to %f\", testCase.expectedResult))\n\t\t\t}\n\t\t})\n\t}\n\tt.Run(\"pool-error\", func(t *testing.T) {\n\t\tresult := float64(1)\n\t\tdec := NewDecoder(nil)\n\t\tdec.Release()\n\t\tdefer func() {\n\t\t\terr := recover()\n\t\t\tassert.NotNil(t, err, \"err shouldnt be nil\")\n\t\t\tassert.IsType(t, InvalidUsagePooledDecoderError(\"\"), err, \"err should be of type InvalidUsagePooledDecoderError\")\n\t\t}()\n\t\t_ = dec.DecodeFloat64(&result)\n\t\tassert.True(t, false, \"should not be called as decoder should have panicked\")\n\t})\n\tt.Run(\"decoder-api\", func(t *testing.T) {\n\t\tvar v float64\n\t\tdec := NewDecoder(strings.NewReader(`1.25`))\n\t\tdefer dec.Release()\n\t\terr := dec.DecodeFloat64(&v)\n\t\tassert.Nil(t, err, \"Err must be nil\")\n\t\tassert.Equal(t, 1.25, v, \"v must be equal to 1.25\")\n\t})\n\tt.Run(\"decoder-api2\", func(t *testing.T) {\n\t\tvar v float64\n\t\tdec := NewDecoder(strings.NewReader(`1.25`))\n\t\tdefer dec.Release()\n\t\terr := dec.DecodeFloat64(&v)\n\t\tassert.Nil(t, err, \"Err must be nil\")\n\t\tassert.Equal(t, 1.25, v, \"v must be equal to 1.25\")\n\t})\n\tt.Run(\"decoder-api-json-error\", func(t *testing.T) {\n\t\tvar v float64\n\t\tdec := NewDecoder(strings.NewReader(``))\n\t\tdefer dec.Release()\n\t\terr := dec.DecodeFloat64(&v)\n\t\tassert.NotNil(t, err, \"Err must not be nil\")\n\t\tassert.IsType(t, InvalidJSONError(\"\"), err, \"err should be of type InvalidJSONError\")\n\t})\n}\n\nfunc TestDecoderFloat64Null(t *testing.T) {\n\ttestCases := []struct {\n\t\tname           string\n\t\tjson           string\n\t\texpectedResult float64\n\t\tresultIsNil    bool\n\t\terr            bool\n\t\terrType        interface{}\n\t}{\n\t\t{\n\t\t\tname:           \"basic-float\",\n\t\t\tjson:           \"1.1\",\n\t\t\texpectedResult: 1.1,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-exponent-positive-positive-exp\",\n\t\t\tjson:           \" 1e2\",\n\t\t\texpectedResult: 100,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-exponent-positive-positive-exp2\",\n\t\t\tjson:           \"5e+06\",\n\t\t\texpectedResult: 5000000,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-exponent-positive-positive-exp3\",\n\t\t\tjson:           \"3e+3\",\n\t\t\texpectedResult: 3000,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-null\",\n\t\t\tjson:           \"null\",\n\t\t\texpectedResult: 0,\n\t\t\tresultIsNil:    true,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-null-err\",\n\t\t\tjson:           \"nxll\",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t\terrType:        InvalidJSONError(\"\"),\n\t\t\tresultIsNil:    true,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-negative-err\",\n\t\t\tjson:           \"-\",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t\terrType:        InvalidJSONError(\"\"),\n\t\t\tresultIsNil:    true,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-negative-err\",\n\t\t\tjson:           \"-q\",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t\terrType:        InvalidJSONError(\"\"),\n\t\t\tresultIsNil:    true,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-null-err\",\n\t\t\tjson:           \"trua\",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t\terrType:        InvalidJSONError(\"\"),\n\t\t\tresultIsNil:    true,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-err1\",\n\t\t\tjson:           \"0.\",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t\tresultIsNil:    true,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-err2\",\n\t\t\tjson:           \"-1.\",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t\tresultIsNil:    true,\n\t\t},\n\t\t{\n\t\t\tname:           \"exponent-err-\",\n\t\t\tjson:           \"0.1e\",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t\tresultIsNil:    true,\n\t\t},\n\t\t{\n\t\t\tname:           \"exp-err\",\n\t\t\tjson:           \"0e-20\",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t\tresultIsNil:    true,\n\t\t},\n\t\t{\n\t\t\tname:           \"exp-err3\",\n\t\t\tjson:           \"-9e-60\",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t\tresultIsNil:    true,\n\t\t},\n\t\t{\n\t\t\tname:        \"exp-err4\",\n\t\t\tjson:        \"0.e-2\",\n\t\t\terr:         true,\n\t\t\tresultIsNil: true,\n\t\t},\n\t\t{\n\t\t\tname:        \"exp-err5\",\n\t\t\tjson:        \"-5.E-2\",\n\t\t\terr:         true,\n\t\t\tresultIsNil: true,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-exponent-positive-positive-exp4\",\n\t\t\tjson:           \"8e+005\",\n\t\t\texpectedResult: 800000,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-exponent-positive-negative-exp\",\n\t\t\tjson:           \"1e-2\",\n\t\t\texpectedResult: 0.01,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-exponent-positive-negative-exp2\",\n\t\t\tjson:           \"5e-6\",\n\t\t\texpectedResult: 0.000005,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-exponent-positive-negative-exp3\",\n\t\t\tjson:           \"3e-3\",\n\t\t\texpectedResult: 0.003,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-exponent-positive-negative-exp4\",\n\t\t\tjson:           \"8e-005\",\n\t\t\texpectedResult: 0.00008,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-exponent-negative-positive-exp\",\n\t\t\tjson:           \"-1e2\",\n\t\t\texpectedResult: -100,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-exponent-negative-positive-exp2\",\n\t\t\tjson:           \"-5e+06\",\n\t\t\texpectedResult: -5000000,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-exponent-negative-positive-exp3\",\n\t\t\tjson:           \"-3e03\",\n\t\t\texpectedResult: -3000,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-float2\",\n\t\t\tjson:           \"877 \",\n\t\t\texpectedResult: 877,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-exponent-negative-positive-exp4\",\n\t\t\tjson:           \"-8e+005\",\n\t\t\texpectedResult: -800000,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-exponent-negative-positive-exp4\",\n\t\t\tjson:           \"-8.2e-005\",\n\t\t\texpectedResult: -0.000082,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-float\",\n\t\t\tjson:           \"2.4595\",\n\t\t\texpectedResult: 2.4595,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-float2\",\n\t\t\tjson:           \"877\",\n\t\t\texpectedResult: 877,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-float2\",\n\t\t\tjson:           \"-7.8876\",\n\t\t\texpectedResult: -7.8876,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-float\",\n\t\t\tjson:           \"2.4595e1\",\n\t\t\texpectedResult: 24.595,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-float2\",\n\t\t\tjson:           \"-7.8876e002\",\n\t\t\texpectedResult: -788.76,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-float3\",\n\t\t\tjson:           \"-0.1234\",\n\t\t\texpectedResult: -0.1234,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-exp-too-big\",\n\t\t\tjson:           \"1e10000000000 \",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t\tresultIsNil:    true,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-exp-too-big\",\n\t\t\tjson:           \"1.002e10000000000 \",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t\tresultIsNil:    true,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-exp-too-big\",\n\t\t\tjson:           \"0e9223372036000000000 \",\n\t\t\texpectedResult: 1,\n\t\t\terr:            true,\n\t\t\tresultIsNil:    true,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-exp-too-big\",\n\t\t\tjson:           \"1.00232492420002423545849009\",\n\t\t\texpectedResult: 1.002325,\n\t\t\tresultIsNil:    false,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-exp-too-big\",\n\t\t\tjson:           \"1.00232492420002423545849009e10000000000 \",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t\tresultIsNil:    true,\n\t\t},\n\t\t{\n\t\t\tname:           \"error\",\n\t\t\tjson:           \"83zez4\",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t\terrType:        InvalidJSONError(\"\"),\n\t\t\tresultIsNil:    true,\n\t\t},\n\t\t{\n\t\t\tname:           \"exponent-err\",\n\t\t\tjson:           \"0.1e \",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t\tresultIsNil:    true,\n\t\t},\n\t\t{\n\t\t\tname:           \"exponent-err\",\n\t\t\tjson:           \"0e\",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t\tresultIsNil:    true,\n\t\t},\n\t\t{\n\t\t\tname:           \"error\",\n\t\t\tjson:           \"-83zez4\",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t\terrType:        InvalidJSONError(\"\"),\n\t\t\tresultIsNil:    true,\n\t\t},\n\t\t{\n\t\t\tname:           \"invalid-type\",\n\t\t\tjson:           `\"string\"`,\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t\terrType:        InvalidUnmarshalError(\"\"),\n\t\t\tresultIsNil:    true,\n\t\t},\n\t}\n\tfor _, testCase := range testCases {\n\t\tt.Run(testCase.name, func(t *testing.T) {\n\t\t\tjson := []byte(testCase.json)\n\t\t\tvar v = (*float64)(nil)\n\t\t\terr := Unmarshal(json, &v)\n\t\t\tif testCase.err {\n\t\t\t\tassert.NotNil(t, err, \"Err must not be nil\")\n\t\t\t\tif testCase.errType != nil {\n\t\t\t\t\tassert.IsType(\n\t\t\t\t\t\tt,\n\t\t\t\t\t\ttestCase.errType,\n\t\t\t\t\t\terr,\n\t\t\t\t\t\tfmt.Sprintf(\"err should be of type %s\", reflect.TypeOf(err).String()),\n\t\t\t\t\t)\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tassert.Nil(t, err, \"Err must be nil\")\n\t\t\t}\n\t\t\tif testCase.resultIsNil {\n\t\t\t\tassert.Nil(t, v)\n\t\t\t} else {\n\t\t\t\tassert.Equal(t, math.Round(testCase.expectedResult*1000000), math.Round(*v*1000000), fmt.Sprintf(\"v must be equal to %f\", testCase.expectedResult))\n\t\t\t}\n\t\t})\n\t}\n\tt.Run(\"decoder-api-invalid-json\", func(t *testing.T) {\n\t\tvar v = new(float64)\n\t\terr := Unmarshal([]byte(``), &v)\n\t\tassert.NotNil(t, err, \"Err must not be nil\")\n\t\tassert.IsType(t, InvalidJSONError(\"\"), err, \"err should be of type InvalidJSONError\")\n\t})\n\tt.Run(\"decoder-api-invalid-json2\", func(t *testing.T) {\n\t\tvar v = new(float64)\n\t\tvar dec = NewDecoder(strings.NewReader(``))\n\t\terr := dec.FloatNull(&v)\n\t\tassert.NotNil(t, err, \"Err must not be nil\")\n\t\tassert.IsType(t, InvalidJSONError(\"\"), err, \"err should be of type InvalidJSONError\")\n\t})\n\tt.Run(\"decoder-api-invalid-json2\", func(t *testing.T) {\n\t\tvar v = new(float64)\n\t\tvar dec = NewDecoder(strings.NewReader(``))\n\t\terr := dec.AddFloat64Null(&v)\n\t\tassert.NotNil(t, err, \"Err must not be nil\")\n\t\tassert.IsType(t, InvalidJSONError(\"\"), err, \"err should be of type InvalidJSONError\")\n\t})\n}\n\nfunc TestDecoderFloat32(t *testing.T) {\n\ttestCases := []struct {\n\t\tname           string\n\t\tjson           string\n\t\texpectedResult float32\n\t\tskipResult     bool\n\t\terr            bool\n\t\terrType        interface{}\n\t}{\n\t\t{\n\t\t\tname:           \"basic-float\",\n\t\t\tjson:           \"1.1\",\n\t\t\texpectedResult: 1.1,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-exponent-positive-positive-exp\",\n\t\t\tjson:           \"1e2\",\n\t\t\texpectedResult: 100,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-exponent-positive-positive-exp2\",\n\t\t\tjson:           \"5e+06\",\n\t\t\texpectedResult: 5000000,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-exponent-positive-positive-exp3\",\n\t\t\tjson:           \"3e+3\",\n\t\t\texpectedResult: 3000,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-null\",\n\t\t\tjson:           \"null\",\n\t\t\texpectedResult: 0,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-err1\",\n\t\t\tjson:           \"0.\",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-err2\",\n\t\t\tjson:           \"-1.\",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t},\n\t\t{\n\t\t\tname:           \"exp-err\",\n\t\t\tjson:           \"0e-20\",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t},\n\t\t{\n\t\t\tname:           \"exp-err3\",\n\t\t\tjson:           \"-9e-60\",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t},\n\t\t{\n\t\t\tname: \"exp-err4\",\n\t\t\tjson: \"0.e-2\",\n\t\t\terr:  true,\n\t\t},\n\t\t{\n\t\t\tname: \"exp-err5\",\n\t\t\tjson: \"-5.E-2\",\n\t\t\terr:  true,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-null\",\n\t\t\tjson:           \"null\",\n\t\t\texpectedResult: 0,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-null-err\",\n\t\t\tjson:           \"trua\",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t\terrType:        InvalidJSONError(\"\"),\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-null-err\",\n\t\t\tjson:           \"nxll\",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t\terrType:        InvalidJSONError(\"\"),\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-negative-err\",\n\t\t\tjson:           \"-\",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t\terrType:        InvalidJSONError(\"\"),\n\t\t},\n\t\t{\n\t\t\tname:           \"exponent-err-\",\n\t\t\tjson:           \"0.1e\",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-negative-err\",\n\t\t\tjson:           \"-q\",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t\terrType:        InvalidJSONError(\"\"),\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-exponent-positive-positive-exp4\",\n\t\t\tjson:           \"8e+005\",\n\t\t\texpectedResult: 800000,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-exponent-positive-negative-exp\",\n\t\t\tjson:           \"1e-2\",\n\t\t\texpectedResult: 0.01,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-exponent-positive-negative-exp2\",\n\t\t\tjson:           \"5e-6\",\n\t\t\texpectedResult: 0.000005,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-exponent-positive-negative-exp3\",\n\t\t\tjson:           \"3e-3\",\n\t\t\texpectedResult: 0.003,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-exponent-positive-negative-exp4\",\n\t\t\tjson:           \"8e-005\",\n\t\t\texpectedResult: 0.00008,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-exponent-negative-positive-exp\",\n\t\t\tjson:           \"-1e2\",\n\t\t\texpectedResult: -100,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-exponent-negative-positive-exp2\",\n\t\t\tjson:           \"-5e+06\",\n\t\t\texpectedResult: -5000000,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-exponent-negative-positive-exp3\",\n\t\t\tjson:           \"-3e03\",\n\t\t\texpectedResult: -3000,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-exponent-negative-positive-exp4\",\n\t\t\tjson:           \"-8e+005\",\n\t\t\texpectedResult: -800000,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-exponent-negative-positive-exp4\",\n\t\t\tjson:           \"-8.2e-005\",\n\t\t\texpectedResult: -0.000082,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-exp-too-big\",\n\t\t\tjson:           \"1e10000000000 \",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-exp-too-big\",\n\t\t\tjson:           \"1.0023249242000242e10000000000 \",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-exp-too-big\",\n\t\t\tjson:           \"1.002e10000000000 \",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-exp-too-big\",\n\t\t\tjson:           \"1.00232492420002423545849009\",\n\t\t\texpectedResult: 1.0023249,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-exp-too-big\",\n\t\t\tjson:           \"1.00232492420002423545849009e10000000000 \",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-float\",\n\t\t\tjson:           \"2.4595\",\n\t\t\texpectedResult: 2.4595,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-float2\",\n\t\t\tjson:           \"877\",\n\t\t\texpectedResult: 877,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-float2\",\n\t\t\tjson:           \"877 \",\n\t\t\texpectedResult: 877,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-float2\",\n\t\t\tjson:           \"-7.8876\",\n\t\t\texpectedResult: -7.8876,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-float\",\n\t\t\tjson:           \"2.459e1\",\n\t\t\texpectedResult: 24.59,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-float2\",\n\t\t\tjson:           \"-7.8876e002\",\n\t\t\texpectedResult: -788.76,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-float3\",\n\t\t\tjson:           \"-0.1234\",\n\t\t\texpectedResult: -0.1234,\n\t\t},\n\t\t{\n\t\t\tname:           \"float10-digit-decimal\",\n\t\t\tjson:           \"0.9833984375\",\n\t\t\texpectedResult: 0.9833984,\n\t\t},\n\t\t{\n\t\t\tname:           \"error\",\n\t\t\tjson:           \"83zez4\",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t\terrType:        InvalidJSONError(\"\"),\n\t\t},\n\t\t{\n\t\t\tname:           \"error\",\n\t\t\tjson:           \"-83zez4\",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t\terrType:        InvalidJSONError(\"\"),\n\t\t},\n\t\t{\n\t\t\tname:           \"exponent-err\",\n\t\t\tjson:           \"0e\",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t},\n\t\t{\n\t\t\tname:           \"invalid-type\",\n\t\t\tjson:           `\"string\"`,\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t\terrType:        InvalidUnmarshalError(\"\"),\n\t\t},\n\t}\n\tfor _, testCase := range testCases {\n\t\tt.Run(testCase.name, func(t *testing.T) {\n\t\t\tjson := []byte(testCase.json)\n\t\t\tvar v float32\n\t\t\terr := Unmarshal(json, &v)\n\t\t\tif testCase.err {\n\t\t\t\tassert.NotNil(t, err, \"Err must not be nil\")\n\t\t\t\tif testCase.errType != nil {\n\t\t\t\t\tassert.IsType(\n\t\t\t\t\t\tt,\n\t\t\t\t\t\ttestCase.errType,\n\t\t\t\t\t\terr,\n\t\t\t\t\t\tfmt.Sprintf(\"err should be of type %s\", reflect.TypeOf(err).String()),\n\t\t\t\t\t)\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tassert.Nil(t, err, \"Err must be nil\")\n\t\t\t}\n\t\t\tif !testCase.skipResult {\n\t\t\t\tassert.Equal(\n\t\t\t\t\tt,\n\t\t\t\t\tmath.Round(float64(testCase.expectedResult*1000000)), math.Round(float64(v*1000000)),\n\t\t\t\t\tfmt.Sprintf(\"v must be equal to %f\", testCase.expectedResult),\n\t\t\t\t)\n\t\t\t}\n\t\t})\n\t}\n\tt.Run(\"pool-error\", func(t *testing.T) {\n\t\tresult := float32(1)\n\t\tdec := NewDecoder(nil)\n\t\tdec.Release()\n\t\tdefer func() {\n\t\t\terr := recover()\n\t\t\tassert.NotNil(t, err, \"err shouldnt be nil\")\n\t\t\tassert.IsType(t, InvalidUsagePooledDecoderError(\"\"), err, \"err should be of type InvalidUsagePooledDecoderError\")\n\t\t}()\n\t\t_ = dec.DecodeFloat32(&result)\n\t\tassert.True(t, false, \"should not be called as decoder should have panicked\")\n\t})\n\tt.Run(\"decoder-api\", func(t *testing.T) {\n\t\tvar v float32\n\t\tdec := NewDecoder(strings.NewReader(`1.25`))\n\t\tdefer dec.Release()\n\t\terr := dec.DecodeFloat32(&v)\n\t\tassert.Nil(t, err, \"Err must be nil\")\n\t\tassert.Equal(t, float32(1.25), v, \"v must be equal to 1.25\")\n\t})\n\tt.Run(\"decoder-api2\", func(t *testing.T) {\n\t\tvar v float32\n\t\tdec := NewDecoder(strings.NewReader(`1.25`))\n\t\tdefer dec.Release()\n\t\terr := dec.Decode(&v)\n\t\tassert.Nil(t, err, \"Err must be nil\")\n\t\tassert.Equal(t, float32(1.25), v, \"v must be equal to 1.25\")\n\t})\n\tt.Run(\"decoder-api-json-error\", func(t *testing.T) {\n\t\tvar v float32\n\t\tdec := NewDecoder(strings.NewReader(``))\n\t\tdefer dec.Release()\n\t\terr := dec.DecodeFloat32(&v)\n\t\tassert.NotNil(t, err, \"Err must not be nil\")\n\t\tassert.IsType(t, InvalidJSONError(\"\"), err, \"err should be of type InvalidJSONError\")\n\t})\n}\n\nfunc TestDecoderFloat32Null(t *testing.T) {\n\ttestCases := []struct {\n\t\tname           string\n\t\tjson           string\n\t\texpectedResult float32\n\t\tresultIsNil    bool\n\t\terr            bool\n\t\terrType        interface{}\n\t}{\n\t\t{\n\t\t\tname:           \"basic-float\",\n\t\t\tjson:           \"1.1\",\n\t\t\texpectedResult: 1.1,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-exponent-positive-positive-exp\",\n\t\t\tjson:           \"1e2\",\n\t\t\texpectedResult: 100,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-exponent-positive-positive-exp2\",\n\t\t\tjson:           \"5e+06 \",\n\t\t\texpectedResult: 5000000,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-exponent-positive-positive-exp3\",\n\t\t\tjson:           \" 3e+3\",\n\t\t\texpectedResult: 3000,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-null\",\n\t\t\tjson:           \"null\",\n\t\t\texpectedResult: 0,\n\t\t\tresultIsNil:    true,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-err1\",\n\t\t\tjson:           \"0.\",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t\tresultIsNil:    true,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-err2\",\n\t\t\tjson:           \"-1.\",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t\tresultIsNil:    true,\n\t\t},\n\t\t{\n\t\t\tname:           \"exp-err\",\n\t\t\tjson:           \"0e-20\",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t\tresultIsNil:    true,\n\t\t},\n\t\t{\n\t\t\tname:           \"exp-err3\",\n\t\t\tjson:           \"-9e-60\",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t\tresultIsNil:    true,\n\t\t},\n\t\t{\n\t\t\tname:        \"exp-err4\",\n\t\t\tjson:        \"0.e-2\",\n\t\t\terr:         true,\n\t\t\tresultIsNil: true,\n\t\t},\n\t\t{\n\t\t\tname:        \"exp-err5\",\n\t\t\tjson:        \"-5.E-2\",\n\t\t\terr:         true,\n\t\t\tresultIsNil: true,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-null\",\n\t\t\tjson:           \"null\",\n\t\t\texpectedResult: 0,\n\t\t\tresultIsNil:    true,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-null-err\",\n\t\t\tjson:           \"trua\",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t\terrType:        InvalidJSONError(\"\"),\n\t\t\tresultIsNil:    true,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-null-err\",\n\t\t\tjson:           \"nxll\",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t\terrType:        InvalidJSONError(\"\"),\n\t\t\tresultIsNil:    true,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-negative-err\",\n\t\t\tjson:           \"-\",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t\terrType:        InvalidJSONError(\"\"),\n\t\t\tresultIsNil:    true,\n\t\t},\n\t\t{\n\t\t\tname:           \"exponent-err-\",\n\t\t\tjson:           \"0.1e\",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t\tresultIsNil:    true,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-negative-err\",\n\t\t\tjson:           \"-q\",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t\terrType:        InvalidJSONError(\"\"),\n\t\t\tresultIsNil:    true,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-exponent-positive-positive-exp4\",\n\t\t\tjson:           \"8e+005\",\n\t\t\texpectedResult: 800000,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-exponent-positive-negative-exp\",\n\t\t\tjson:           \" 1e-2\",\n\t\t\texpectedResult: 0.01,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-exponent-positive-negative-exp2\",\n\t\t\tjson:           \"5e-6\",\n\t\t\texpectedResult: 0.000005,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-exponent-positive-negative-exp3\",\n\t\t\tjson:           \"3e-3\",\n\t\t\texpectedResult: 0.003,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-exponent-positive-negative-exp4\",\n\t\t\tjson:           \"8e-005\",\n\t\t\texpectedResult: 0.00008,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-exponent-negative-positive-exp\",\n\t\t\tjson:           \"-1e2\",\n\t\t\texpectedResult: -100,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-exponent-negative-positive-exp2\",\n\t\t\tjson:           \"-5e+06\",\n\t\t\texpectedResult: -5000000,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-exponent-negative-positive-exp3\",\n\t\t\tjson:           \"-3e03\",\n\t\t\texpectedResult: -3000,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-exponent-negative-positive-exp4\",\n\t\t\tjson:           \"-8e+005\",\n\t\t\texpectedResult: -800000,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-exponent-negative-positive-exp4\",\n\t\t\tjson:           \"-8.2e-005\",\n\t\t\texpectedResult: -0.000082,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-exp-too-big\",\n\t\t\tjson:           \"1e10000000000 \",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t\tresultIsNil:    true,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-exp-too-big\",\n\t\t\tjson:           \"1.0023249242000242e10000000000 \",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t\tresultIsNil:    true,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-exp-too-big\",\n\t\t\tjson:           \"1.002e10000000000 \",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t\tresultIsNil:    true,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-exp-too-big\",\n\t\t\tjson:           \"1.00232492420002423545849009\",\n\t\t\texpectedResult: 1.0023249,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-exp-too-big\",\n\t\t\tjson:           \"1.00232492420002423545849009e10000000000 \",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t\tresultIsNil:    true,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-float\",\n\t\t\tjson:           \"2.4595\",\n\t\t\texpectedResult: 2.4595,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-float2\",\n\t\t\tjson:           \"877\",\n\t\t\texpectedResult: 877,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-float2\",\n\t\t\tjson:           \"877 \",\n\t\t\texpectedResult: 877,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-float2\",\n\t\t\tjson:           \"-7.8876\",\n\t\t\texpectedResult: -7.8876,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-float\",\n\t\t\tjson:           \"2.459e1\",\n\t\t\texpectedResult: 24.59,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-float2\",\n\t\t\tjson:           \"-7.8876e002\",\n\t\t\texpectedResult: -788.76,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-float3\",\n\t\t\tjson:           \"-0.1234\",\n\t\t\texpectedResult: -0.1234,\n\t\t},\n\t\t{\n\t\t\tname:           \"error\",\n\t\t\tjson:           \"83zez4\",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t\terrType:        InvalidJSONError(\"\"),\n\t\t\tresultIsNil:    true,\n\t\t},\n\t\t{\n\t\t\tname:           \"error\",\n\t\t\tjson:           \"-83zez4\",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t\terrType:        InvalidJSONError(\"\"),\n\t\t\tresultIsNil:    true,\n\t\t},\n\t\t{\n\t\t\tname:           \"exponent-err\",\n\t\t\tjson:           \"0e\",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t\tresultIsNil:    true,\n\t\t},\n\t\t{\n\t\t\tname:           \"invalid-type\",\n\t\t\tjson:           `\"string\"`,\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t\terrType:        InvalidUnmarshalError(\"\"),\n\t\t\tresultIsNil:    true,\n\t\t},\n\t}\n\tfor _, testCase := range testCases {\n\t\tt.Run(testCase.name, func(t *testing.T) {\n\t\t\tjson := []byte(testCase.json)\n\t\t\tvar v = (*float32)(nil)\n\t\t\terr := Unmarshal(json, &v)\n\t\t\tif testCase.err {\n\t\t\t\tassert.NotNil(t, err, \"Err must not be nil\")\n\t\t\t\tif testCase.errType != nil {\n\t\t\t\t\tassert.IsType(\n\t\t\t\t\t\tt,\n\t\t\t\t\t\ttestCase.errType,\n\t\t\t\t\t\terr,\n\t\t\t\t\t\tfmt.Sprintf(\"err should be of type %s\", reflect.TypeOf(err).String()),\n\t\t\t\t\t)\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tassert.Nil(t, err, \"Err must be nil\")\n\t\t\t}\n\t\t\tif testCase.resultIsNil {\n\t\t\t\tassert.Nil(t, v)\n\t\t\t} else {\n\t\t\t\tassert.Equal(\n\t\t\t\t\tt,\n\t\t\t\t\tmath.Round(float64(testCase.expectedResult*1000000)), math.Round(float64(*v*1000000)),\n\t\t\t\t\tfmt.Sprintf(\"v must be equal to %f\", testCase.expectedResult),\n\t\t\t\t)\n\t\t\t}\n\t\t})\n\t}\n\tt.Run(\"decoder-api-invalid-json\", func(t *testing.T) {\n\t\tvar v = new(float32)\n\t\terr := Unmarshal([]byte(``), &v)\n\t\tassert.NotNil(t, err, \"Err must not be nil\")\n\t\tassert.IsType(t, InvalidJSONError(\"\"), err, \"err should be of type InvalidJSONError\")\n\t})\n\tt.Run(\"decoder-api-invalid-json2\", func(t *testing.T) {\n\t\tvar v = new(float32)\n\t\tvar dec = NewDecoder(strings.NewReader(``))\n\t\terr := dec.Float32Null(&v)\n\t\tassert.NotNil(t, err, \"Err must not be nil\")\n\t\tassert.IsType(t, InvalidJSONError(\"\"), err, \"err should be of type InvalidJSONError\")\n\t})\n}\n\nfunc TestDecoderFloat64Field(t *testing.T) {\n\tvar testCasesBasic = []struct {\n\t\tname  string\n\t\tjson  string\n\t\tvalue float64\n\t}{\n\t\t{\n\t\t\tname:  \"basic\",\n\t\t\tjson:  \"[1]\",\n\t\t\tvalue: float64(1),\n\t\t},\n\t\t{\n\t\t\tname:  \"big\",\n\t\t\tjson:  \"[0]\",\n\t\t\tvalue: float64(0),\n\t\t},\n\t}\n\tfor _, testCase := range testCasesBasic {\n\t\tt.Run(testCase.name, func(t *testing.T) {\n\t\t\tvar dec = NewDecoder(strings.NewReader(testCase.json))\n\t\t\tvar v float64\n\t\t\tdec.DecodeArray(DecodeArrayFunc(func(dec *Decoder) error {\n\t\t\t\treturn dec.AddFloat64(&v)\n\t\t\t}))\n\t\t\tassert.Equal(t, testCase.value, v)\n\t\t})\n\t}\n\tvar testCasesBasicAlt = []struct {\n\t\tname  string\n\t\tjson  string\n\t\tvalue float64\n\t}{\n\t\t{\n\t\t\tname:  \"basic\",\n\t\t\tjson:  \"[1]\",\n\t\t\tvalue: float64(1),\n\t\t},\n\t\t{\n\t\t\tname:  \"big\",\n\t\t\tjson:  \"[0]\",\n\t\t\tvalue: float64(0),\n\t\t},\n\t}\n\tfor _, testCase := range testCasesBasicAlt {\n\t\tt.Run(testCase.name, func(t *testing.T) {\n\t\t\tvar dec = NewDecoder(strings.NewReader(testCase.json))\n\t\t\tvar v float64\n\t\t\tdec.DecodeArray(DecodeArrayFunc(func(dec *Decoder) error {\n\t\t\t\treturn dec.Float(&v)\n\t\t\t}))\n\t\t\tassert.Equal(t, testCase.value, v)\n\t\t})\n\t}\n}\n"
        },
        {
          "name": "decode_number_int.go",
          "type": "blob",
          "size": 36.7646484375,
          "content": "package gojay\n\nimport (\n\t\"fmt\"\n\t\"math\"\n)\n\n// DecodeInt reads the next JSON-encoded value from the decoder's input (io.Reader) and stores it in the int pointed to by v.\n//\n// See the documentation for Unmarshal for details about the conversion of JSON into a Go value.\nfunc (dec *Decoder) DecodeInt(v *int) error {\n\tif dec.isPooled == 1 {\n\t\tpanic(InvalidUsagePooledDecoderError(\"Invalid usage of pooled decoder\"))\n\t}\n\treturn dec.decodeInt(v)\n}\nfunc (dec *Decoder) decodeInt(v *int) error {\n\tfor ; dec.cursor < dec.length || dec.read(); dec.cursor++ {\n\t\tswitch c := dec.data[dec.cursor]; c {\n\t\tcase ' ', '\\n', '\\t', '\\r', ',':\n\t\t\tcontinue\n\t\t// we don't look for 0 as leading zeros are invalid per RFC\n\t\tcase '0', '1', '2', '3', '4', '5', '6', '7', '8', '9':\n\t\t\tval, err := dec.getInt64()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\t*v = int(val)\n\t\t\treturn nil\n\t\tcase '-':\n\t\t\tdec.cursor = dec.cursor + 1\n\t\t\tval, err := dec.getInt64Negative()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\t*v = -int(val)\n\t\t\treturn nil\n\t\tcase 'n':\n\t\t\tdec.cursor++\n\t\t\terr := dec.assertNull()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\treturn nil\n\t\tdefault:\n\t\t\tdec.err = InvalidUnmarshalError(\n\t\t\t\tfmt.Sprintf(\n\t\t\t\t\t\"Cannot unmarshall to int, wrong char '%s' found at pos %d\",\n\t\t\t\t\tstring(dec.data[dec.cursor]),\n\t\t\t\t\tdec.cursor,\n\t\t\t\t),\n\t\t\t)\n\t\t\terr := dec.skipData()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\treturn nil\n\t\t}\n\t}\n\treturn dec.raiseInvalidJSONErr(dec.cursor)\n}\n\nfunc (dec *Decoder) decodeIntNull(v **int) error {\n\tfor ; dec.cursor < dec.length || dec.read(); dec.cursor++ {\n\t\tswitch c := dec.data[dec.cursor]; c {\n\t\tcase ' ', '\\n', '\\t', '\\r', ',':\n\t\t\tcontinue\n\t\t// we don't look for 0 as leading zeros are invalid per RFC\n\t\tcase '0', '1', '2', '3', '4', '5', '6', '7', '8', '9':\n\t\t\tval, err := dec.getInt64()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif *v == nil {\n\t\t\t\t*v = new(int)\n\t\t\t}\n\t\t\t**v = int(val)\n\t\t\treturn nil\n\t\tcase '-':\n\t\t\tdec.cursor = dec.cursor + 1\n\t\t\tval, err := dec.getInt64Negative()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif *v == nil {\n\t\t\t\t*v = new(int)\n\t\t\t}\n\t\t\t**v = -int(val)\n\t\t\treturn nil\n\t\tcase 'n':\n\t\t\tdec.cursor++\n\t\t\terr := dec.assertNull()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\treturn nil\n\t\tdefault:\n\t\t\tdec.err = InvalidUnmarshalError(\n\t\t\t\tfmt.Sprintf(\n\t\t\t\t\t\"Cannot unmarshall to int, wrong char '%s' found at pos %d\",\n\t\t\t\t\tstring(dec.data[dec.cursor]),\n\t\t\t\t\tdec.cursor,\n\t\t\t\t),\n\t\t\t)\n\t\t\terr := dec.skipData()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\treturn nil\n\t\t}\n\t}\n\treturn dec.raiseInvalidJSONErr(dec.cursor)\n}\n\n// DecodeInt16 reads the next JSON-encoded value from the decoder's input (io.Reader) and stores it in the int16 pointed to by v.\n//\n// See the documentation for Unmarshal for details about the conversion of JSON into a Go value.\nfunc (dec *Decoder) DecodeInt16(v *int16) error {\n\tif dec.isPooled == 1 {\n\t\tpanic(InvalidUsagePooledDecoderError(\"Invalid usage of pooled decoder\"))\n\t}\n\treturn dec.decodeInt16(v)\n}\nfunc (dec *Decoder) decodeInt16(v *int16) error {\n\tfor ; dec.cursor < dec.length || dec.read(); dec.cursor++ {\n\t\tswitch c := dec.data[dec.cursor]; c {\n\t\tcase ' ', '\\n', '\\t', '\\r', ',':\n\t\t\tcontinue\n\t\t// we don't look for 0 as leading zeros are invalid per RFC\n\t\tcase '0', '1', '2', '3', '4', '5', '6', '7', '8', '9':\n\t\t\tval, err := dec.getInt16()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\t*v = val\n\t\t\treturn nil\n\t\tcase '-':\n\t\t\tdec.cursor = dec.cursor + 1\n\t\t\tval, err := dec.getInt16Negative()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\t*v = -val\n\t\t\treturn nil\n\t\tcase 'n':\n\t\t\tdec.cursor++\n\t\t\terr := dec.assertNull()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\treturn nil\n\t\tdefault:\n\t\t\tdec.err = dec.makeInvalidUnmarshalErr(v)\n\t\t\terr := dec.skipData()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\treturn nil\n\t\t}\n\t}\n\treturn dec.raiseInvalidJSONErr(dec.cursor)\n}\nfunc (dec *Decoder) decodeInt16Null(v **int16) error {\n\tfor ; dec.cursor < dec.length || dec.read(); dec.cursor++ {\n\t\tswitch c := dec.data[dec.cursor]; c {\n\t\tcase ' ', '\\n', '\\t', '\\r', ',':\n\t\t\tcontinue\n\t\t// we don't look for 0 as leading zeros are invalid per RFC\n\t\tcase '0', '1', '2', '3', '4', '5', '6', '7', '8', '9':\n\t\t\tval, err := dec.getInt16()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif *v == nil {\n\t\t\t\t*v = new(int16)\n\t\t\t}\n\t\t\t**v = val\n\t\t\treturn nil\n\t\tcase '-':\n\t\t\tdec.cursor = dec.cursor + 1\n\t\t\tval, err := dec.getInt16Negative()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif *v == nil {\n\t\t\t\t*v = new(int16)\n\t\t\t}\n\t\t\t**v = -val\n\t\t\treturn nil\n\t\tcase 'n':\n\t\t\tdec.cursor++\n\t\t\terr := dec.assertNull()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\treturn nil\n\t\tdefault:\n\t\t\tdec.err = dec.makeInvalidUnmarshalErr(v)\n\t\t\terr := dec.skipData()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\treturn nil\n\t\t}\n\t}\n\treturn dec.raiseInvalidJSONErr(dec.cursor)\n}\n\nfunc (dec *Decoder) getInt16Negative() (int16, error) {\n\t// look for following numbers\n\tfor ; dec.cursor < dec.length || dec.read(); dec.cursor++ {\n\t\tswitch dec.data[dec.cursor] {\n\t\tcase '1', '2', '3', '4', '5', '6', '7', '8', '9':\n\t\t\treturn dec.getInt16()\n\t\tdefault:\n\t\t\treturn 0, dec.raiseInvalidJSONErr(dec.cursor)\n\t\t}\n\t}\n\treturn 0, dec.raiseInvalidJSONErr(dec.cursor)\n}\n\nfunc (dec *Decoder) getInt16() (int16, error) {\n\tvar end = dec.cursor\n\tvar start = dec.cursor\n\t// look for following numbers\n\tfor j := dec.cursor + 1; j < dec.length || dec.read(); j++ {\n\t\tswitch dec.data[j] {\n\t\tcase '0', '1', '2', '3', '4', '5', '6', '7', '8', '9':\n\t\t\tend = j\n\t\t\tcontinue\n\t\tcase '.':\n\t\t\t// if dot is found\n\t\t\t// look for exponent (e,E) as exponent can change the\n\t\t\t// way number should be parsed to int.\n\t\t\t// if no exponent found, just unmarshal the number before decimal point\n\t\t\tj++\n\t\t\tstartDecimal := j\n\t\t\tendDecimal := j - 1\n\t\t\tfor ; j < dec.length || dec.read(); j++ {\n\t\t\t\tswitch dec.data[j] {\n\t\t\t\tcase '0', '1', '2', '3', '4', '5', '6', '7', '8', '9':\n\t\t\t\t\tendDecimal = j\n\t\t\t\t\tcontinue\n\t\t\t\tcase 'e', 'E':\n\t\t\t\t\tif startDecimal > endDecimal {\n\t\t\t\t\t\treturn 0, dec.raiseInvalidJSONErr(dec.cursor)\n\t\t\t\t\t}\n\t\t\t\t\tdec.cursor = j + 1\n\t\t\t\t\t// can try unmarshalling to int as Exponent might change decimal number to non decimal\n\t\t\t\t\t// let's get the float value first\n\t\t\t\t\t// we get part before decimal as integer\n\t\t\t\t\tbeforeDecimal := dec.atoi16(start, end)\n\t\t\t\t\t// get number after the decimal point\n\t\t\t\t\t// multiple the before decimal point portion by 10 using bitwise\n\t\t\t\t\tfor i := startDecimal; i <= endDecimal; i++ {\n\t\t\t\t\t\tbeforeDecimal = (beforeDecimal << 3) + (beforeDecimal << 1)\n\t\t\t\t\t}\n\t\t\t\t\t// then we add both integers\n\t\t\t\t\t// then we divide the number by the power found\n\t\t\t\t\tafterDecimal := dec.atoi16(startDecimal, endDecimal)\n\t\t\t\t\texpI := endDecimal - startDecimal + 2\n\t\t\t\t\tif expI >= len(pow10uint64) || expI < 0 {\n\t\t\t\t\t\treturn 0, dec.raiseInvalidJSONErr(dec.cursor)\n\t\t\t\t\t}\n\t\t\t\t\tpow := pow10uint64[expI]\n\t\t\t\t\tfloatVal := float64(beforeDecimal+afterDecimal) / float64(pow)\n\t\t\t\t\t// we have the floating value, now multiply by the exponent\n\t\t\t\t\texp, err := dec.getExponent()\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\treturn 0, err\n\t\t\t\t\t}\n\t\t\t\t\tpExp := (exp + (exp >> 31)) ^ (exp >> 31) + 1 // abs\n\t\t\t\t\tif pExp >= int64(len(pow10uint64)) || pExp < 0 {\n\t\t\t\t\t\treturn 0, dec.raiseInvalidJSONErr(dec.cursor)\n\t\t\t\t\t}\n\t\t\t\t\tval := floatVal * float64(pow10uint64[pExp])\n\t\t\t\t\treturn int16(val), nil\n\t\t\t\tcase ' ', '\\t', '\\n', ',', ']', '}':\n\t\t\t\t\tdec.cursor = j\n\t\t\t\t\treturn dec.atoi16(start, end), nil\n\t\t\t\tdefault:\n\t\t\t\t\tdec.cursor = j\n\t\t\t\t\treturn 0, dec.raiseInvalidJSONErr(dec.cursor)\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn dec.atoi16(start, end), nil\n\t\tcase 'e', 'E':\n\t\t\t// get init n\n\t\t\tdec.cursor = j + 1\n\t\t\treturn dec.getInt16WithExp(dec.atoi16(start, end))\n\t\tcase ' ', '\\n', '\\t', '\\r', ',', '}', ']':\n\t\t\tdec.cursor = j\n\t\t\treturn dec.atoi16(start, end), nil\n\t\t}\n\t\t// invalid json we expect numbers, dot (single one), comma, or spaces\n\t\treturn 0, dec.raiseInvalidJSONErr(dec.cursor)\n\t}\n\treturn dec.atoi16(start, end), nil\n}\n\nfunc (dec *Decoder) getInt16WithExp(init int16) (int16, error) {\n\tvar exp uint16\n\tvar sign = int16(1)\n\tfor ; dec.cursor < dec.length || dec.read(); dec.cursor++ {\n\t\tswitch dec.data[dec.cursor] {\n\t\tcase '+':\n\t\t\tcontinue\n\t\tcase '-':\n\t\t\tsign = -1\n\t\tcase '0', '1', '2', '3', '4', '5', '6', '7', '8', '9':\n\t\t\tuintv := uint16(digits[dec.data[dec.cursor]])\n\t\t\texp = (exp << 3) + (exp << 1) + uintv\n\t\t\tdec.cursor++\n\t\t\tfor ; dec.cursor < dec.length || dec.read(); dec.cursor++ {\n\t\t\t\tswitch dec.data[dec.cursor] {\n\t\t\t\tcase '0', '1', '2', '3', '4', '5', '6', '7', '8', '9':\n\t\t\t\t\tuintv := uint16(digits[dec.data[dec.cursor]])\n\t\t\t\t\texp = (exp << 3) + (exp << 1) + uintv\n\t\t\t\tcase ' ', '\\t', '\\n', '}', ',', ']':\n\t\t\t\t\texp = exp + 1\n\t\t\t\t\tif exp >= uint16(len(pow10uint64)) {\n\t\t\t\t\t\treturn 0, dec.raiseInvalidJSONErr(dec.cursor)\n\t\t\t\t\t}\n\t\t\t\t\tif sign == -1 {\n\t\t\t\t\t\treturn init * (1 / int16(pow10uint64[exp])), nil\n\t\t\t\t\t}\n\t\t\t\t\treturn init * int16(pow10uint64[exp]), nil\n\t\t\t\tdefault:\n\t\t\t\t\treturn 0, dec.raiseInvalidJSONErr(dec.cursor)\n\t\t\t\t}\n\t\t\t}\n\t\t\texp = exp + 1\n\t\t\tif exp >= uint16(len(pow10uint64)) {\n\t\t\t\treturn 0, dec.raiseInvalidJSONErr(dec.cursor)\n\t\t\t}\n\t\t\tif sign == -1 {\n\t\t\t\treturn init * (1 / int16(pow10uint64[exp])), nil\n\t\t\t}\n\t\t\treturn init * int16(pow10uint64[exp]), nil\n\t\tdefault:\n\t\t\treturn 0, dec.raiseInvalidJSONErr(dec.cursor)\n\t\t}\n\t}\n\treturn 0, dec.raiseInvalidJSONErr(dec.cursor)\n}\n\n// DecodeInt8 reads the next JSON-encoded value from the decoder's input (io.Reader) and stores it in the int8 pointed to by v.\n//\n// See the documentation for Unmarshal for details about the conversion of JSON into a Go value.\nfunc (dec *Decoder) DecodeInt8(v *int8) error {\n\tif dec.isPooled == 1 {\n\t\tpanic(InvalidUsagePooledDecoderError(\"Invalid usage of pooled decoder\"))\n\t}\n\treturn dec.decodeInt8(v)\n}\nfunc (dec *Decoder) decodeInt8(v *int8) error {\n\tfor ; dec.cursor < dec.length || dec.read(); dec.cursor++ {\n\t\tswitch c := dec.data[dec.cursor]; c {\n\t\tcase ' ', '\\n', '\\t', '\\r', ',':\n\t\t\tcontinue\n\t\t// we don't look for 0 as leading zeros are invalid per RFC\n\t\tcase '0', '1', '2', '3', '4', '5', '6', '7', '8', '9':\n\t\t\tval, err := dec.getInt8()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\t*v = val\n\t\t\treturn nil\n\t\tcase '-':\n\t\t\tdec.cursor = dec.cursor + 1\n\t\t\tval, err := dec.getInt8Negative()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\t*v = -val\n\t\t\treturn nil\n\t\tcase 'n':\n\t\t\tdec.cursor++\n\t\t\terr := dec.assertNull()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\treturn nil\n\t\tdefault:\n\t\t\tdec.err = dec.makeInvalidUnmarshalErr(v)\n\t\t\terr := dec.skipData()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\treturn nil\n\t\t}\n\t}\n\treturn dec.raiseInvalidJSONErr(dec.cursor)\n}\nfunc (dec *Decoder) decodeInt8Null(v **int8) error {\n\tfor ; dec.cursor < dec.length || dec.read(); dec.cursor++ {\n\t\tswitch c := dec.data[dec.cursor]; c {\n\t\tcase ' ', '\\n', '\\t', '\\r', ',':\n\t\t\tcontinue\n\t\t// we don't look for 0 as leading zeros are invalid per RFC\n\t\tcase '0', '1', '2', '3', '4', '5', '6', '7', '8', '9':\n\t\t\tval, err := dec.getInt8()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif *v == nil {\n\t\t\t\t*v = new(int8)\n\t\t\t}\n\t\t\t**v = val\n\t\t\treturn nil\n\t\tcase '-':\n\t\t\tdec.cursor = dec.cursor + 1\n\t\t\tval, err := dec.getInt8Negative()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif *v == nil {\n\t\t\t\t*v = new(int8)\n\t\t\t}\n\t\t\t**v = -val\n\t\t\treturn nil\n\t\tcase 'n':\n\t\t\tdec.cursor++\n\t\t\terr := dec.assertNull()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\treturn nil\n\t\tdefault:\n\t\t\tdec.err = dec.makeInvalidUnmarshalErr(v)\n\t\t\terr := dec.skipData()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\treturn nil\n\t\t}\n\t}\n\treturn dec.raiseInvalidJSONErr(dec.cursor)\n}\n\nfunc (dec *Decoder) getInt8Negative() (int8, error) {\n\t// look for following numbers\n\tfor ; dec.cursor < dec.length || dec.read(); dec.cursor++ {\n\t\tswitch dec.data[dec.cursor] {\n\t\tcase '1', '2', '3', '4', '5', '6', '7', '8', '9':\n\t\t\treturn dec.getInt8()\n\t\tdefault:\n\t\t\treturn 0, dec.raiseInvalidJSONErr(dec.cursor)\n\t\t}\n\t}\n\treturn 0, dec.raiseInvalidJSONErr(dec.cursor)\n}\n\nfunc (dec *Decoder) getInt8() (int8, error) {\n\tvar end = dec.cursor\n\tvar start = dec.cursor\n\t// look for following numbers\n\tfor j := dec.cursor + 1; j < dec.length || dec.read(); j++ {\n\t\tswitch dec.data[j] {\n\t\tcase '0', '1', '2', '3', '4', '5', '6', '7', '8', '9':\n\t\t\tend = j\n\t\t\tcontinue\n\t\tcase '.':\n\t\t\t// if dot is found\n\t\t\t// look for exponent (e,E) as exponent can change the\n\t\t\t// way number should be parsed to int.\n\t\t\t// if no exponent found, just unmarshal the number before decimal point\n\t\t\tj++\n\t\t\tstartDecimal := j\n\t\t\tendDecimal := j - 1\n\t\t\tfor ; j < dec.length || dec.read(); j++ {\n\t\t\t\tswitch dec.data[j] {\n\t\t\t\tcase '0', '1', '2', '3', '4', '5', '6', '7', '8', '9':\n\t\t\t\t\tendDecimal = j\n\t\t\t\t\tcontinue\n\t\t\t\tcase 'e', 'E':\n\t\t\t\t\tif startDecimal > endDecimal {\n\t\t\t\t\t\treturn 0, dec.raiseInvalidJSONErr(dec.cursor)\n\t\t\t\t\t}\n\t\t\t\t\tdec.cursor = j + 1\n\t\t\t\t\t// can try unmarshalling to int as Exponent might change decimal number to non decimal\n\t\t\t\t\t// let's get the float value first\n\t\t\t\t\t// we get part before decimal as integer\n\t\t\t\t\tbeforeDecimal := dec.atoi8(start, end)\n\t\t\t\t\t// get number after the decimal point\n\t\t\t\t\t// multiple the before decimal point portion by 10 using bitwise\n\t\t\t\t\tfor i := startDecimal; i <= endDecimal; i++ {\n\t\t\t\t\t\tbeforeDecimal = (beforeDecimal << 3) + (beforeDecimal << 1)\n\t\t\t\t\t}\n\t\t\t\t\t// then we add both integers\n\t\t\t\t\t// then we divide the number by the power found\n\t\t\t\t\tafterDecimal := dec.atoi8(startDecimal, endDecimal)\n\t\t\t\t\texpI := endDecimal - startDecimal + 2\n\t\t\t\t\tif expI >= len(pow10uint64) || expI < 0 {\n\t\t\t\t\t\treturn 0, dec.raiseInvalidJSONErr(dec.cursor)\n\t\t\t\t\t}\n\t\t\t\t\tpow := pow10uint64[expI]\n\t\t\t\t\tfloatVal := float64(beforeDecimal+afterDecimal) / float64(pow)\n\t\t\t\t\t// we have the floating value, now multiply by the exponent\n\t\t\t\t\texp, err := dec.getExponent()\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\treturn 0, err\n\t\t\t\t\t}\n\t\t\t\t\tpExp := (exp + (exp >> 31)) ^ (exp >> 31) + 1 // abs\n\t\t\t\t\tif pExp >= int64(len(pow10uint64)) || pExp < 0 {\n\t\t\t\t\t\treturn 0, dec.raiseInvalidJSONErr(dec.cursor)\n\t\t\t\t\t}\n\t\t\t\t\tval := floatVal * float64(pow10uint64[pExp])\n\t\t\t\t\treturn int8(val), nil\n\t\t\t\tcase ' ', '\\t', '\\n', ',', ']', '}':\n\t\t\t\t\tdec.cursor = j\n\t\t\t\t\treturn dec.atoi8(start, end), nil\n\t\t\t\tdefault:\n\t\t\t\t\tdec.cursor = j\n\t\t\t\t\treturn 0, dec.raiseInvalidJSONErr(dec.cursor)\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn dec.atoi8(start, end), nil\n\t\tcase 'e', 'E':\n\t\t\t// get init n\n\t\t\tdec.cursor = j + 1\n\t\t\treturn dec.getInt8WithExp(dec.atoi8(start, end))\n\t\tcase ' ', '\\n', '\\t', '\\r', ',', '}', ']':\n\t\t\tdec.cursor = j\n\t\t\treturn dec.atoi8(start, end), nil\n\t\t}\n\t\t// invalid json we expect numbers, dot (single one), comma, or spaces\n\t\treturn 0, dec.raiseInvalidJSONErr(dec.cursor)\n\t}\n\treturn dec.atoi8(start, end), nil\n}\n\nfunc (dec *Decoder) getInt8WithExp(init int8) (int8, error) {\n\tvar exp uint8\n\tvar sign = int8(1)\n\tfor ; dec.cursor < dec.length || dec.read(); dec.cursor++ {\n\t\tswitch dec.data[dec.cursor] {\n\t\tcase '+':\n\t\t\tcontinue\n\t\tcase '-':\n\t\t\tsign = -1\n\t\tcase '0', '1', '2', '3', '4', '5', '6', '7', '8', '9':\n\t\t\tuintv := uint8(digits[dec.data[dec.cursor]])\n\t\t\texp = (exp << 3) + (exp << 1) + uintv\n\t\t\tdec.cursor++\n\t\t\tfor ; dec.cursor < dec.length || dec.read(); dec.cursor++ {\n\t\t\t\tswitch dec.data[dec.cursor] {\n\t\t\t\tcase '0', '1', '2', '3', '4', '5', '6', '7', '8', '9':\n\t\t\t\t\tuintv := uint8(digits[dec.data[dec.cursor]])\n\t\t\t\t\texp = (exp << 3) + (exp << 1) + uintv\n\t\t\t\tcase ' ', '\\t', '\\n', '}', ',', ']':\n\t\t\t\t\tif exp+1 >= uint8(len(pow10uint64)) {\n\t\t\t\t\t\treturn 0, dec.raiseInvalidJSONErr(dec.cursor)\n\t\t\t\t\t}\n\t\t\t\t\tif sign == -1 {\n\t\t\t\t\t\treturn init * (1 / int8(pow10uint64[exp+1])), nil\n\t\t\t\t\t}\n\t\t\t\t\treturn init * int8(pow10uint64[exp+1]), nil\n\t\t\t\tdefault:\n\t\t\t\t\treturn 0, dec.raiseInvalidJSONErr(dec.cursor)\n\t\t\t\t}\n\t\t\t}\n\t\t\tif exp+1 >= uint8(len(pow10uint64)) {\n\t\t\t\treturn 0, dec.raiseInvalidJSONErr(dec.cursor)\n\t\t\t}\n\t\t\tif sign == -1 {\n\t\t\t\treturn init * (1 / int8(pow10uint64[exp+1])), nil\n\t\t\t}\n\t\t\treturn init * int8(pow10uint64[exp+1]), nil\n\t\tdefault:\n\t\t\tdec.err = dec.raiseInvalidJSONErr(dec.cursor)\n\t\t\treturn 0, dec.err\n\t\t}\n\t}\n\treturn 0, dec.raiseInvalidJSONErr(dec.cursor)\n}\n\n// DecodeInt32 reads the next JSON-encoded value from the decoder's input (io.Reader) and stores it in the int32 pointed to by v.\n//\n// See the documentation for Unmarshal for details about the conversion of JSON into a Go value.\nfunc (dec *Decoder) DecodeInt32(v *int32) error {\n\tif dec.isPooled == 1 {\n\t\tpanic(InvalidUsagePooledDecoderError(\"Invalid usage of pooled decoder\"))\n\t}\n\treturn dec.decodeInt32(v)\n}\nfunc (dec *Decoder) decodeInt32(v *int32) error {\n\tfor ; dec.cursor < dec.length || dec.read(); dec.cursor++ {\n\t\tswitch c := dec.data[dec.cursor]; c {\n\t\tcase ' ', '\\n', '\\t', '\\r', ',':\n\t\t\tcontinue\n\t\tcase '0', '1', '2', '3', '4', '5', '6', '7', '8', '9':\n\t\t\tval, err := dec.getInt32()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\t*v = val\n\t\t\treturn nil\n\t\tcase '-':\n\t\t\tdec.cursor = dec.cursor + 1\n\t\t\tval, err := dec.getInt32Negative()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\t*v = -val\n\t\t\treturn nil\n\t\tcase 'n':\n\t\t\tdec.cursor++\n\t\t\terr := dec.assertNull()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\treturn nil\n\t\tdefault:\n\t\t\tdec.err = dec.makeInvalidUnmarshalErr(v)\n\t\t\terr := dec.skipData()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\treturn nil\n\t\t}\n\t}\n\treturn dec.raiseInvalidJSONErr(dec.cursor)\n}\nfunc (dec *Decoder) decodeInt32Null(v **int32) error {\n\tfor ; dec.cursor < dec.length || dec.read(); dec.cursor++ {\n\t\tswitch c := dec.data[dec.cursor]; c {\n\t\tcase ' ', '\\n', '\\t', '\\r', ',':\n\t\t\tcontinue\n\t\tcase '0', '1', '2', '3', '4', '5', '6', '7', '8', '9':\n\t\t\tval, err := dec.getInt32()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif *v == nil {\n\t\t\t\t*v = new(int32)\n\t\t\t}\n\t\t\t**v = val\n\t\t\treturn nil\n\t\tcase '-':\n\t\t\tdec.cursor = dec.cursor + 1\n\t\t\tval, err := dec.getInt32Negative()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif *v == nil {\n\t\t\t\t*v = new(int32)\n\t\t\t}\n\t\t\t**v = -val\n\t\t\treturn nil\n\t\tcase 'n':\n\t\t\tdec.cursor++\n\t\t\terr := dec.assertNull()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\treturn nil\n\t\tdefault:\n\t\t\tdec.err = dec.makeInvalidUnmarshalErr(v)\n\t\t\terr := dec.skipData()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\treturn nil\n\t\t}\n\t}\n\treturn dec.raiseInvalidJSONErr(dec.cursor)\n}\n\nfunc (dec *Decoder) getInt32Negative() (int32, error) {\n\t// look for following numbers\n\tfor ; dec.cursor < dec.length || dec.read(); dec.cursor++ {\n\t\tswitch dec.data[dec.cursor] {\n\t\tcase '1', '2', '3', '4', '5', '6', '7', '8', '9':\n\t\t\treturn dec.getInt32()\n\t\tdefault:\n\t\t\treturn 0, dec.raiseInvalidJSONErr(dec.cursor)\n\t\t}\n\t}\n\treturn 0, dec.raiseInvalidJSONErr(dec.cursor)\n}\n\nfunc (dec *Decoder) getInt32() (int32, error) {\n\tvar end = dec.cursor\n\tvar start = dec.cursor\n\t// look for following numbers\n\tfor j := dec.cursor + 1; j < dec.length || dec.read(); j++ {\n\t\tswitch dec.data[j] {\n\t\tcase '0', '1', '2', '3', '4', '5', '6', '7', '8', '9':\n\t\t\tend = j\n\t\t\tcontinue\n\t\tcase '.':\n\t\t\t// if dot is found\n\t\t\t// look for exponent (e,E) as exponent can change the\n\t\t\t// way number should be parsed to int.\n\t\t\t// if no exponent found, just unmarshal the number before decimal point\n\t\t\tj++\n\t\t\tstartDecimal := j\n\t\t\tendDecimal := j - 1\n\t\t\tfor ; j < dec.length || dec.read(); j++ {\n\t\t\t\tswitch dec.data[j] {\n\t\t\t\tcase '0', '1', '2', '3', '4', '5', '6', '7', '8', '9':\n\t\t\t\t\tendDecimal = j\n\t\t\t\t\tcontinue\n\t\t\t\tcase 'e', 'E':\n\t\t\t\t\t// if eg 1.E\n\t\t\t\t\tif startDecimal > endDecimal {\n\t\t\t\t\t\treturn 0, dec.raiseInvalidJSONErr(dec.cursor)\n\t\t\t\t\t}\n\t\t\t\t\tdec.cursor = j + 1\n\t\t\t\t\t// can try unmarshalling to int as Exponent might change decimal number to non decimal\n\t\t\t\t\t// let's get the float value first\n\t\t\t\t\t// we get part before decimal as integer\n\t\t\t\t\tbeforeDecimal := dec.atoi64(start, end)\n\t\t\t\t\t// get number after the decimal point\n\t\t\t\t\t// multiple the before decimal point portion by 10 using bitwise\n\t\t\t\t\tfor i := startDecimal; i <= endDecimal; i++ {\n\t\t\t\t\t\tbeforeDecimal = (beforeDecimal << 3) + (beforeDecimal << 1)\n\t\t\t\t\t}\n\t\t\t\t\t// then we add both integers\n\t\t\t\t\t// then we divide the number by the power found\n\t\t\t\t\tafterDecimal := dec.atoi64(startDecimal, endDecimal)\n\t\t\t\t\texpI := endDecimal - startDecimal + 2\n\t\t\t\t\tif expI >= len(pow10uint64) || expI < 0 {\n\t\t\t\t\t\treturn 0, dec.raiseInvalidJSONErr(dec.cursor)\n\t\t\t\t\t}\n\t\t\t\t\tpow := pow10uint64[expI]\n\t\t\t\t\tfloatVal := float64(beforeDecimal+afterDecimal) / float64(pow)\n\t\t\t\t\t// we have the floating value, now multiply by the exponent\n\t\t\t\t\texp, err := dec.getExponent()\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\treturn 0, err\n\t\t\t\t\t}\n\t\t\t\t\tpExp := (exp + (exp >> 31)) ^ (exp >> 31) + 1 // abs\n\t\t\t\t\tif pExp >= int64(len(pow10uint64)) || pExp < 0 {\n\t\t\t\t\t\treturn 0, dec.raiseInvalidJSONErr(dec.cursor)\n\t\t\t\t\t}\n\t\t\t\t\tval := floatVal * float64(pow10uint64[pExp])\n\t\t\t\t\treturn int32(val), nil\n\t\t\t\tcase ' ', '\\t', '\\n', ',', ']', '}':\n\t\t\t\t\tdec.cursor = j\n\t\t\t\t\treturn dec.atoi32(start, end), nil\n\t\t\t\tdefault:\n\t\t\t\t\tdec.cursor = j\n\t\t\t\t\treturn 0, dec.raiseInvalidJSONErr(dec.cursor)\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn dec.atoi32(start, end), nil\n\t\tcase 'e', 'E':\n\t\t\t// get init n\n\t\t\tdec.cursor = j + 1\n\t\t\treturn dec.getInt32WithExp(dec.atoi32(start, end))\n\t\tcase ' ', '\\n', '\\t', '\\r', ',', '}', ']':\n\t\t\tdec.cursor = j\n\t\t\treturn dec.atoi32(start, end), nil\n\t\t}\n\t\t// invalid json we expect numbers, dot (single one), comma, or spaces\n\t\treturn 0, dec.raiseInvalidJSONErr(dec.cursor)\n\t}\n\treturn dec.atoi32(start, end), nil\n}\n\nfunc (dec *Decoder) getInt32WithExp(init int32) (int32, error) {\n\tvar exp uint32\n\tvar sign = int32(1)\n\tfor ; dec.cursor < dec.length || dec.read(); dec.cursor++ {\n\t\tswitch dec.data[dec.cursor] {\n\t\tcase '+':\n\t\t\tcontinue\n\t\tcase '-':\n\t\t\tsign = -1\n\t\tcase '0', '1', '2', '3', '4', '5', '6', '7', '8', '9':\n\t\t\tuintv := uint32(digits[dec.data[dec.cursor]])\n\t\t\texp = (exp << 3) + (exp << 1) + uintv\n\t\t\tdec.cursor++\n\t\t\tfor ; dec.cursor < dec.length || dec.read(); dec.cursor++ {\n\t\t\t\tswitch dec.data[dec.cursor] {\n\t\t\t\tcase '0', '1', '2', '3', '4', '5', '6', '7', '8', '9':\n\t\t\t\t\tuintv := uint32(digits[dec.data[dec.cursor]])\n\t\t\t\t\texp = (exp << 3) + (exp << 1) + uintv\n\t\t\t\tcase ' ', '\\t', '\\n', '}', ',', ']':\n\t\t\t\t\tif exp+1 >= uint32(len(pow10uint64)) {\n\t\t\t\t\t\treturn 0, dec.raiseInvalidJSONErr(dec.cursor)\n\t\t\t\t\t}\n\t\t\t\t\tif sign == -1 {\n\t\t\t\t\t\treturn init * (1 / int32(pow10uint64[exp+1])), nil\n\t\t\t\t\t}\n\t\t\t\t\treturn init * int32(pow10uint64[exp+1]), nil\n\t\t\t\tdefault:\n\t\t\t\t\treturn 0, dec.raiseInvalidJSONErr(dec.cursor)\n\t\t\t\t}\n\t\t\t}\n\t\t\tif exp+1 >= uint32(len(pow10uint64)) {\n\t\t\t\treturn 0, dec.raiseInvalidJSONErr(dec.cursor)\n\t\t\t}\n\t\t\tif sign == -1 {\n\t\t\t\treturn init * (1 / int32(pow10uint64[exp+1])), nil\n\t\t\t}\n\t\t\treturn init * int32(pow10uint64[exp+1]), nil\n\t\tdefault:\n\t\t\tdec.err = dec.raiseInvalidJSONErr(dec.cursor)\n\t\t\treturn 0, dec.err\n\t\t}\n\t}\n\treturn 0, dec.raiseInvalidJSONErr(dec.cursor)\n}\n\n// DecodeInt64 reads the next JSON-encoded value from the decoder's input (io.Reader) and stores it in the int64 pointed to by v.\n//\n// See the documentation for Unmarshal for details about the conversion of JSON into a Go value.\nfunc (dec *Decoder) DecodeInt64(v *int64) error {\n\tif dec.isPooled == 1 {\n\t\tpanic(InvalidUsagePooledDecoderError(\"Invalid usage of pooled decoder\"))\n\t}\n\treturn dec.decodeInt64(v)\n}\n\nfunc (dec *Decoder) decodeInt64(v *int64) error {\n\tfor ; dec.cursor < dec.length || dec.read(); dec.cursor++ {\n\t\tswitch c := dec.data[dec.cursor]; c {\n\t\tcase ' ', '\\n', '\\t', '\\r', ',':\n\t\t\tcontinue\n\t\tcase '0', '1', '2', '3', '4', '5', '6', '7', '8', '9':\n\t\t\tval, err := dec.getInt64()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\t*v = val\n\t\t\treturn nil\n\t\tcase '-':\n\t\t\tdec.cursor = dec.cursor + 1\n\t\t\tval, err := dec.getInt64Negative()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\t*v = -val\n\t\t\treturn nil\n\t\tcase 'n':\n\t\t\tdec.cursor++\n\t\t\terr := dec.assertNull()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\treturn nil\n\t\tdefault:\n\t\t\tdec.err = dec.makeInvalidUnmarshalErr(v)\n\t\t\terr := dec.skipData()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\treturn nil\n\t\t}\n\t}\n\treturn dec.raiseInvalidJSONErr(dec.cursor)\n}\nfunc (dec *Decoder) decodeInt64Null(v **int64) error {\n\tfor ; dec.cursor < dec.length || dec.read(); dec.cursor++ {\n\t\tswitch c := dec.data[dec.cursor]; c {\n\t\tcase ' ', '\\n', '\\t', '\\r', ',':\n\t\t\tcontinue\n\t\tcase '0', '1', '2', '3', '4', '5', '6', '7', '8', '9':\n\t\t\tval, err := dec.getInt64()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif *v == nil {\n\t\t\t\t*v = new(int64)\n\t\t\t}\n\t\t\t**v = val\n\t\t\treturn nil\n\t\tcase '-':\n\t\t\tdec.cursor = dec.cursor + 1\n\t\t\tval, err := dec.getInt64Negative()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif *v == nil {\n\t\t\t\t*v = new(int64)\n\t\t\t}\n\t\t\t**v = -val\n\t\t\treturn nil\n\t\tcase 'n':\n\t\t\tdec.cursor++\n\t\t\terr := dec.assertNull()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\treturn nil\n\t\tdefault:\n\t\t\tdec.err = dec.makeInvalidUnmarshalErr(v)\n\t\t\terr := dec.skipData()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\treturn nil\n\t\t}\n\t}\n\treturn dec.raiseInvalidJSONErr(dec.cursor)\n}\n\nfunc (dec *Decoder) getInt64Negative() (int64, error) {\n\t// look for following numbers\n\tfor ; dec.cursor < dec.length || dec.read(); dec.cursor++ {\n\t\tswitch dec.data[dec.cursor] {\n\t\tcase '1', '2', '3', '4', '5', '6', '7', '8', '9':\n\t\t\treturn dec.getInt64()\n\t\tdefault:\n\t\t\treturn 0, dec.raiseInvalidJSONErr(dec.cursor)\n\t\t}\n\t}\n\treturn 0, dec.raiseInvalidJSONErr(dec.cursor)\n}\n\nfunc (dec *Decoder) getInt64() (int64, error) {\n\tvar end = dec.cursor\n\tvar start = dec.cursor\n\t// look for following numbers\n\tfor j := dec.cursor + 1; j < dec.length || dec.read(); j++ {\n\t\tswitch dec.data[j] {\n\t\tcase '0', '1', '2', '3', '4', '5', '6', '7', '8', '9':\n\t\t\tend = j\n\t\t\tcontinue\n\t\tcase ' ', '\\t', '\\n', ',', '}', ']':\n\t\t\tdec.cursor = j\n\t\t\treturn dec.atoi64(start, end), nil\n\t\tcase '.':\n\t\t\t// if dot is found\n\t\t\t// look for exponent (e,E) as exponent can change the\n\t\t\t// way number should be parsed to int.\n\t\t\t// if no exponent found, just unmarshal the number before decimal point\n\t\t\tj++\n\t\t\tstartDecimal := j\n\t\t\tendDecimal := j - 1\n\t\t\tfor ; j < dec.length || dec.read(); j++ {\n\t\t\t\tswitch dec.data[j] {\n\t\t\t\tcase '0', '1', '2', '3', '4', '5', '6', '7', '8', '9':\n\t\t\t\t\tendDecimal = j\n\t\t\t\t\tcontinue\n\t\t\t\tcase 'e', 'E':\n\t\t\t\t\t// if eg 1.E\n\t\t\t\t\tif startDecimal > endDecimal {\n\t\t\t\t\t\treturn 0, dec.raiseInvalidJSONErr(dec.cursor)\n\t\t\t\t\t}\n\t\t\t\t\tdec.cursor = j + 1\n\t\t\t\t\t// can try unmarshalling to int as Exponent might change decimal number to non decimal\n\t\t\t\t\t// let's get the float value first\n\t\t\t\t\t// we get part before decimal as integer\n\t\t\t\t\tbeforeDecimal := dec.atoi64(start, end)\n\t\t\t\t\t// get number after the decimal point\n\t\t\t\t\t// multiple the before decimal point portion by 10 using bitwise\n\t\t\t\t\tfor i := startDecimal; i <= endDecimal; i++ {\n\t\t\t\t\t\tbeforeDecimal = (beforeDecimal << 3) + (beforeDecimal << 1)\n\t\t\t\t\t}\n\t\t\t\t\t// then we add both integers\n\t\t\t\t\t// then we divide the number by the power found\n\t\t\t\t\tafterDecimal := dec.atoi64(startDecimal, endDecimal)\n\t\t\t\t\texpI := endDecimal - startDecimal + 2\n\t\t\t\t\tif expI >= len(pow10uint64) || expI < 0 {\n\t\t\t\t\t\treturn 0, dec.raiseInvalidJSONErr(dec.cursor)\n\t\t\t\t\t}\n\t\t\t\t\tpow := pow10uint64[expI]\n\t\t\t\t\tfloatVal := float64(beforeDecimal+afterDecimal) / float64(pow)\n\t\t\t\t\t// we have the floating value, now multiply by the exponent\n\t\t\t\t\texp, err := dec.getExponent()\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\treturn 0, err\n\t\t\t\t\t}\n\t\t\t\t\tpExp := (exp + (exp >> 31)) ^ (exp >> 31) + 1 // abs\n\t\t\t\t\tif pExp >= int64(len(pow10uint64)) || pExp < 0 {\n\t\t\t\t\t\treturn 0, dec.raiseInvalidJSONErr(dec.cursor)\n\t\t\t\t\t}\n\t\t\t\t\tval := floatVal * float64(pow10uint64[pExp])\n\t\t\t\t\treturn int64(val), nil\n\t\t\t\tcase ' ', '\\t', '\\n', ',', ']', '}':\n\t\t\t\t\tdec.cursor = j\n\t\t\t\t\treturn dec.atoi64(start, end), nil\n\t\t\t\tdefault:\n\t\t\t\t\tdec.cursor = j\n\t\t\t\t\treturn 0, dec.raiseInvalidJSONErr(dec.cursor)\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn dec.atoi64(start, end), nil\n\t\tcase 'e', 'E':\n\t\t\t// get init n\n\t\t\tdec.cursor = j + 1\n\t\t\treturn dec.getInt64WithExp(dec.atoi64(start, end))\n\t\t}\n\t\t// invalid json we expect numbers, dot (single one), comma, or spaces\n\t\treturn 0, dec.raiseInvalidJSONErr(dec.cursor)\n\t}\n\treturn dec.atoi64(start, end), nil\n}\n\nfunc (dec *Decoder) getInt64WithExp(init int64) (int64, error) {\n\tvar exp uint64\n\tvar sign = int64(1)\n\tfor ; dec.cursor < dec.length || dec.read(); dec.cursor++ {\n\t\tswitch dec.data[dec.cursor] {\n\t\tcase '+':\n\t\t\tcontinue\n\t\tcase '-':\n\t\t\tsign = -1\n\t\tcase '0', '1', '2', '3', '4', '5', '6', '7', '8', '9':\n\t\t\tuintv := uint64(digits[dec.data[dec.cursor]])\n\t\t\texp = (exp << 3) + (exp << 1) + uintv\n\t\t\tdec.cursor++\n\t\t\tfor ; dec.cursor < dec.length || dec.read(); dec.cursor++ {\n\t\t\t\tswitch dec.data[dec.cursor] {\n\t\t\t\tcase '0', '1', '2', '3', '4', '5', '6', '7', '8', '9':\n\t\t\t\t\tuintv := uint64(digits[dec.data[dec.cursor]])\n\t\t\t\t\texp = (exp << 3) + (exp << 1) + uintv\n\t\t\t\tcase ' ', '\\t', '\\n', '}', ',', ']':\n\t\t\t\t\tif exp+1 >= uint64(len(pow10uint64)) {\n\t\t\t\t\t\treturn 0, dec.raiseInvalidJSONErr(dec.cursor)\n\t\t\t\t\t}\n\t\t\t\t\tif sign == -1 {\n\t\t\t\t\t\treturn init * (1 / int64(pow10uint64[exp+1])), nil\n\t\t\t\t\t}\n\t\t\t\t\treturn init * int64(pow10uint64[exp+1]), nil\n\t\t\t\tdefault:\n\t\t\t\t\treturn 0, dec.raiseInvalidJSONErr(dec.cursor)\n\t\t\t\t}\n\t\t\t}\n\t\t\tif exp+1 >= uint64(len(pow10uint64)) {\n\t\t\t\treturn 0, dec.raiseInvalidJSONErr(dec.cursor)\n\t\t\t}\n\t\t\tif sign == -1 {\n\t\t\t\treturn init * (1 / int64(pow10uint64[exp+1])), nil\n\t\t\t}\n\t\t\treturn init * int64(pow10uint64[exp+1]), nil\n\t\tdefault:\n\t\t\treturn 0, dec.raiseInvalidJSONErr(dec.cursor)\n\t\t}\n\t}\n\treturn 0, dec.raiseInvalidJSONErr(dec.cursor)\n}\n\nfunc (dec *Decoder) atoi64(start, end int) int64 {\n\tvar ll = end + 1 - start\n\tvar val = int64(digits[dec.data[start]])\n\tend = end + 1\n\tif ll < maxInt64Length {\n\t\tfor i := start + 1; i < end; i++ {\n\t\t\tintv := int64(digits[dec.data[i]])\n\t\t\tval = (val << 3) + (val << 1) + intv\n\t\t}\n\t\treturn val\n\t} else if ll == maxInt64Length {\n\t\tfor i := start + 1; i < end; i++ {\n\t\t\tintv := int64(digits[dec.data[i]])\n\t\t\tif val > maxInt64toMultiply {\n\t\t\t\tdec.err = dec.makeInvalidUnmarshalErr(val)\n\t\t\t\treturn 0\n\t\t\t}\n\t\t\tval = (val << 3) + (val << 1)\n\t\t\tif math.MaxInt64-val < intv {\n\t\t\t\tdec.err = dec.makeInvalidUnmarshalErr(val)\n\t\t\t\treturn 0\n\t\t\t}\n\t\t\tval += intv\n\t\t}\n\t} else {\n\t\tdec.err = dec.makeInvalidUnmarshalErr(val)\n\t\treturn 0\n\t}\n\treturn val\n}\n\nfunc (dec *Decoder) atoi32(start, end int) int32 {\n\tvar ll = end + 1 - start\n\tvar val = int32(digits[dec.data[start]])\n\tend = end + 1\n\n\t// overflowing\n\tif ll < maxInt32Length {\n\t\tfor i := start + 1; i < end; i++ {\n\t\t\tintv := int32(digits[dec.data[i]])\n\t\t\tval = (val << 3) + (val << 1) + intv\n\t\t}\n\t} else if ll == maxInt32Length {\n\t\tfor i := start + 1; i < end; i++ {\n\t\t\tintv := int32(digits[dec.data[i]])\n\t\t\tif val > maxInt32toMultiply {\n\t\t\t\tdec.err = dec.makeInvalidUnmarshalErr(val)\n\t\t\t\treturn 0\n\t\t\t}\n\t\t\tval = (val << 3) + (val << 1)\n\t\t\tif math.MaxInt32-val < intv {\n\t\t\t\tdec.err = dec.makeInvalidUnmarshalErr(val)\n\t\t\t\treturn 0\n\t\t\t}\n\t\t\tval += intv\n\t\t}\n\t} else {\n\t\tdec.err = dec.makeInvalidUnmarshalErr(val)\n\t\treturn 0\n\t}\n\treturn val\n}\n\nfunc (dec *Decoder) atoi16(start, end int) int16 {\n\tvar ll = end + 1 - start\n\tvar val = int16(digits[dec.data[start]])\n\tend = end + 1\n\t// overflowing\n\tif ll < maxInt16Length {\n\t\tfor i := start + 1; i < end; i++ {\n\t\t\tintv := int16(digits[dec.data[i]])\n\t\t\tval = (val << 3) + (val << 1) + intv\n\t\t}\n\t} else if ll == maxInt16Length {\n\t\tfor i := start + 1; i < end; i++ {\n\t\t\tintv := int16(digits[dec.data[i]])\n\t\t\tif val > maxInt16toMultiply {\n\t\t\t\tdec.err = dec.makeInvalidUnmarshalErr(val)\n\t\t\t\treturn 0\n\t\t\t}\n\t\t\tval = (val << 3) + (val << 1)\n\t\t\tif math.MaxInt16-val < intv {\n\t\t\t\tdec.err = dec.makeInvalidUnmarshalErr(val)\n\t\t\t\treturn 0\n\t\t\t}\n\t\t\tval += intv\n\t\t}\n\t} else {\n\t\tdec.err = dec.makeInvalidUnmarshalErr(val)\n\t\treturn 0\n\t}\n\treturn val\n}\n\nfunc (dec *Decoder) atoi8(start, end int) int8 {\n\tvar ll = end + 1 - start\n\tvar val = int8(digits[dec.data[start]])\n\tend = end + 1\n\t// overflowing\n\tif ll < maxInt8Length {\n\t\tfor i := start + 1; i < end; i++ {\n\t\t\tintv := int8(digits[dec.data[i]])\n\t\t\tval = (val << 3) + (val << 1) + intv\n\t\t}\n\t} else if ll == maxInt8Length {\n\t\tfor i := start + 1; i < end; i++ {\n\t\t\tintv := int8(digits[dec.data[i]])\n\t\t\tif val > maxInt8toMultiply {\n\t\t\t\tdec.err = dec.makeInvalidUnmarshalErr(val)\n\t\t\t\treturn 0\n\t\t\t}\n\t\t\tval = (val << 3) + (val << 1)\n\t\t\tif math.MaxInt8-val < intv {\n\t\t\t\tdec.err = dec.makeInvalidUnmarshalErr(val)\n\t\t\t\treturn 0\n\t\t\t}\n\t\t\tval += intv\n\t\t}\n\t} else {\n\t\tdec.err = dec.makeInvalidUnmarshalErr(val)\n\t\treturn 0\n\t}\n\treturn val\n}\n\n// Add Values functions\n\n// AddInt decodes the JSON value within an object or an array to an *int.\n// If next key value overflows int, an InvalidUnmarshalError error will be returned.\nfunc (dec *Decoder) AddInt(v *int) error {\n\treturn dec.Int(v)\n}\n\n// AddIntNull decodes the JSON value within an object or an array to an *int.\n// If next key value overflows int, an InvalidUnmarshalError error will be returned.\n// If a `null` is encountered, gojay does not change the value of the pointer.\nfunc (dec *Decoder) AddIntNull(v **int) error {\n\treturn dec.IntNull(v)\n}\n\n// AddInt8 decodes the JSON value within an object or an array to an *int.\n// If next key value overflows int8, an InvalidUnmarshalError error will be returned.\nfunc (dec *Decoder) AddInt8(v *int8) error {\n\treturn dec.Int8(v)\n}\n\n// AddInt8Null decodes the JSON value within an object or an array to an *int.\n// If next key value overflows int8, an InvalidUnmarshalError error will be returned.\n// If a `null` is encountered, gojay does not change the value of the pointer.\nfunc (dec *Decoder) AddInt8Null(v **int8) error {\n\treturn dec.Int8Null(v)\n}\n\n// AddInt16 decodes the JSON value within an object or an array to an *int.\n// If next key value overflows int16, an InvalidUnmarshalError error will be returned.\nfunc (dec *Decoder) AddInt16(v *int16) error {\n\treturn dec.Int16(v)\n}\n\n// AddInt16Null decodes the JSON value within an object or an array to an *int.\n// If next key value overflows int16, an InvalidUnmarshalError error will be returned.\n// If a `null` is encountered, gojay does not change the value of the pointer.\nfunc (dec *Decoder) AddInt16Null(v **int16) error {\n\treturn dec.Int16Null(v)\n}\n\n// AddInt32 decodes the JSON value within an object or an array to an *int.\n// If next key value overflows int32, an InvalidUnmarshalError error will be returned.\nfunc (dec *Decoder) AddInt32(v *int32) error {\n\treturn dec.Int32(v)\n}\n\n// AddInt32Null decodes the JSON value within an object or an array to an *int.\n// If next key value overflows int32, an InvalidUnmarshalError error will be returned.\n// If a `null` is encountered, gojay does not change the value of the pointer.\nfunc (dec *Decoder) AddInt32Null(v **int32) error {\n\treturn dec.Int32Null(v)\n}\n\n// AddInt64 decodes the JSON value within an object or an array to an *int.\n// If next key value overflows int64, an InvalidUnmarshalError error will be returned.\nfunc (dec *Decoder) AddInt64(v *int64) error {\n\treturn dec.Int64(v)\n}\n\n// AddInt64Null decodes the JSON value within an object or an array to an *int.\n// If next key value overflows int64, an InvalidUnmarshalError error will be returned.\n// If a `null` is encountered, gojay does not change the value of the pointer.\nfunc (dec *Decoder) AddInt64Null(v **int64) error {\n\treturn dec.Int64Null(v)\n}\n\n// Int decodes the JSON value within an object or an array to an *int.\n// If next key value overflows int, an InvalidUnmarshalError error will be returned.\nfunc (dec *Decoder) Int(v *int) error {\n\terr := dec.decodeInt(v)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdec.called |= 1\n\treturn nil\n}\n\n// IntNull decodes the JSON value within an object or an array to an *int.\n// If next key value overflows int, an InvalidUnmarshalError error will be returned.\nfunc (dec *Decoder) IntNull(v **int) error {\n\terr := dec.decodeIntNull(v)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdec.called |= 1\n\treturn nil\n}\n\n// Int8 decodes the JSON value within an object or an array to an *int.\n// If next key value overflows int8, an InvalidUnmarshalError error will be returned.\nfunc (dec *Decoder) Int8(v *int8) error {\n\terr := dec.decodeInt8(v)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdec.called |= 1\n\treturn nil\n}\n\n// Int8Null decodes the JSON value within an object or an array to an *int.\n// If next key value overflows int8, an InvalidUnmarshalError error will be returned.\nfunc (dec *Decoder) Int8Null(v **int8) error {\n\terr := dec.decodeInt8Null(v)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdec.called |= 1\n\treturn nil\n}\n\n// Int16 decodes the JSON value within an object or an array to an *int.\n// If next key value overflows int16, an InvalidUnmarshalError error will be returned.\nfunc (dec *Decoder) Int16(v *int16) error {\n\terr := dec.decodeInt16(v)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdec.called |= 1\n\treturn nil\n}\n\n// Int16Null decodes the JSON value within an object or an array to an *int.\n// If next key value overflows int16, an InvalidUnmarshalError error will be returned.\nfunc (dec *Decoder) Int16Null(v **int16) error {\n\terr := dec.decodeInt16Null(v)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdec.called |= 1\n\treturn nil\n}\n\n// Int32 decodes the JSON value within an object or an array to an *int.\n// If next key value overflows int32, an InvalidUnmarshalError error will be returned.\nfunc (dec *Decoder) Int32(v *int32) error {\n\terr := dec.decodeInt32(v)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdec.called |= 1\n\treturn nil\n}\n\n// Int32Null decodes the JSON value within an object or an array to an *int.\n// If next key value overflows int32, an InvalidUnmarshalError error will be returned.\nfunc (dec *Decoder) Int32Null(v **int32) error {\n\terr := dec.decodeInt32Null(v)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdec.called |= 1\n\treturn nil\n}\n\n// Int64 decodes the JSON value within an object or an array to an *int.\n// If next key value overflows int64, an InvalidUnmarshalError error will be returned.\nfunc (dec *Decoder) Int64(v *int64) error {\n\terr := dec.decodeInt64(v)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdec.called |= 1\n\treturn nil\n}\n\n// Int64Null decodes the JSON value within an object or an array to an *int.\n// If next key value overflows int64, an InvalidUnmarshalError error will be returned.\nfunc (dec *Decoder) Int64Null(v **int64) error {\n\terr := dec.decodeInt64Null(v)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdec.called |= 1\n\treturn nil\n}\n"
        },
        {
          "name": "decode_number_int_test.go",
          "type": "blob",
          "size": 76.2783203125,
          "content": "package gojay\n\nimport (\n\t\"fmt\"\n\t\"reflect\"\n\t\"strings\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestDecoderInt(t *testing.T) {\n\ttestCases := []struct {\n\t\tname           string\n\t\tjson           string\n\t\texpectedResult int\n\t\terr            bool\n\t\terrType        interface{}\n\t}{\n\t\t{\n\t\t\tname:           \"basic-positive\",\n\t\t\tjson:           \"100\",\n\t\t\texpectedResult: 100,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-positive2\",\n\t\t\tjson:           \"1039405\",\n\t\t\texpectedResult: 1039405,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-negative\",\n\t\t\tjson:           \"-2\",\n\t\t\texpectedResult: -2,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-null\",\n\t\t\tjson:           \"null\",\n\t\t\texpectedResult: 0,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-negative-err\",\n\t\t\tjson:           \"-\",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t\terrType:        InvalidJSONError(\"\"),\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-negative-err\",\n\t\t\tjson:           \"-q\",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t\terrType:        InvalidJSONError(\"\"),\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-null-err\",\n\t\t\tjson:           \"nxll\",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t\terrType:        InvalidJSONError(\"\"),\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-skip-data-err\",\n\t\t\tjson:           \"trua\",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t\terrType:        InvalidJSONError(\"\"),\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-big\",\n\t\t\tjson:           \"9223372036854775807\",\n\t\t\texpectedResult: 9223372036854775807,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-big-overflow\",\n\t\t\tjson:           \"9223372036854775808\",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t\terrType:        InvalidUnmarshalError(\"\"),\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-big-overflow2\",\n\t\t\tjson:           \"92233720368547758089\",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t\terrType:        InvalidUnmarshalError(\"\"),\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-big-overflow3\",\n\t\t\tjson:           \"92233720368547758089 \",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t\terrType:        InvalidUnmarshalError(\"\"),\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-negative2\",\n\t\t\tjson:           \"-2349557\",\n\t\t\texpectedResult: -2349557,\n\t\t},\n\t\t{\n\t\t\tname:           \"exponent-err-too-big\",\n\t\t\tjson:           \"0e10000000000000000000\",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-float\",\n\t\t\tjson:           \"2.4595\",\n\t\t\texpectedResult: 2,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-float2\",\n\t\t\tjson:           \"-7.8876\",\n\t\t\texpectedResult: -7,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-float2\",\n\t\t\tjson:           \"-7.8876 \",\n\t\t\texpectedResult: -7,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-float2\",\n\t\t\tjson:           \"-7.8876a\",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-exponent-positive-positive-exp\",\n\t\t\tjson:           \"1e2\",\n\t\t\texpectedResult: 100,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-exponent-positive-positive-exp2\",\n\t\t\tjson:           \"5e+06\",\n\t\t\texpectedResult: 5000000,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-exponent-positive-positive-exp2\",\n\t\t\tjson:           \"5.01e+10\",\n\t\t\texpectedResult: 50100000000,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-exponent-positive-positive-exp3\",\n\t\t\tjson:           \"3e+3\",\n\t\t\texpectedResult: 3000,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-exponent-positive-positive-exp4\",\n\t\t\tjson:           \"8e+005\",\n\t\t\texpectedResult: 800000,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-exponent-positive-negative-exp\",\n\t\t\tjson:           \"1e-2\",\n\t\t\texpectedResult: 0,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-exponent-positive-negative-exp2\",\n\t\t\tjson:           \"5e-6\",\n\t\t\texpectedResult: 0,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-exponent-positive-negative-exp3\",\n\t\t\tjson:           \"3e-3\",\n\t\t\texpectedResult: 0,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-exponent-positive-negative-exp4\",\n\t\t\tjson:           \"8e-005\",\n\t\t\texpectedResult: 0,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-exponent-negative-positive-exp\",\n\t\t\tjson:           \"-1e2\",\n\t\t\texpectedResult: -100,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-exponent-negative-positive-exp2\",\n\t\t\tjson:           \"-5e+06\",\n\t\t\texpectedResult: -5000000,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-exponent-negative-positive-exp3\",\n\t\t\tjson:           \"-3e03\",\n\t\t\texpectedResult: -3000,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-exponent-negative-positive-exp4\",\n\t\t\tjson:           \"-8e+005\",\n\t\t\texpectedResult: -800000,\n\t\t},\n\t\t{\n\t\t\tname:           \"error1\",\n\t\t\tjson:           \"132zz4\",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t},\n\t\t{\n\t\t\tname:           \"negative-error2\",\n\t\t\tjson:           \" -1213xdde2323 \",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t\terrType:        InvalidJSONError(\"\"),\n\t\t},\n\t\t{\n\t\t\tname:           \"error3\",\n\t\t\tjson:           \"-8e+00$aa5\",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t\terrType:        InvalidJSONError(\"\"),\n\t\t},\n\t\t{\n\t\t\tname:           \"error4\",\n\t\t\tjson:           \"0.E----\",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t\terrType:        InvalidJSONError(\"\"),\n\t\t},\n\t\t{\n\t\t\tname:           \"exponent-err-\",\n\t\t\tjson:           \"0.1e\",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t},\n\t\t{\n\t\t\tname:           \"error5\",\n\t\t\tjson:           \"0E40\",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t\terrType:        InvalidJSONError(\"\"),\n\t\t},\n\t\t{\n\t\t\tname:           \"error6\",\n\t\t\tjson:           \"0.e-9\",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t\terrType:        InvalidJSONError(\"\"),\n\t\t},\n\n\t\t{\n\t\t\tname:           \"error7\",\n\t\t\tjson:           \"-5.e-2\",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t\terrType:        InvalidJSONError(\"\"),\n\t\t},\n\t\t{\n\t\t\tname:           \"invalid-type\",\n\t\t\tjson:           `\"string\"`,\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t\terrType:        InvalidUnmarshalError(\"\"),\n\t\t},\n\t}\n\tfor _, testCase := range testCases {\n\t\tt.Run(testCase.name, func(t *testing.T) {\n\t\t\tjson := []byte(testCase.json)\n\t\t\tvar v int\n\t\t\terr := Unmarshal(json, &v)\n\t\t\tif testCase.err {\n\t\t\t\tassert.NotNil(t, err, \"Err must not be nil\")\n\t\t\t\tif testCase.errType != nil && err != nil {\n\t\t\t\t\tassert.IsType(\n\t\t\t\t\t\tt,\n\t\t\t\t\t\ttestCase.errType,\n\t\t\t\t\t\terr,\n\t\t\t\t\t\tfmt.Sprintf(\"err should be of type %s\", reflect.TypeOf(err).String()),\n\t\t\t\t\t)\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tassert.Nil(t, err, \"Err must be nil\")\n\t\t\t}\n\t\t\tassert.Equal(t, testCase.expectedResult, v, fmt.Sprintf(\"v must be equal to %d\", testCase.expectedResult))\n\t\t})\n\t}\n\tt.Run(\"pool-error\", func(t *testing.T) {\n\t\tresult := int(1)\n\t\tdec := NewDecoder(nil)\n\t\tdec.Release()\n\t\tdefer func() {\n\t\t\terr := recover()\n\t\t\tassert.NotNil(t, err, \"err shouldnt be nil\")\n\t\t\tassert.IsType(t, InvalidUsagePooledDecoderError(\"\"), err, \"err should be of type InvalidUsagePooledDecoderError\")\n\t\t}()\n\t\t_ = dec.DecodeInt(&result)\n\t\tassert.True(t, false, \"should not be called as decoder should have panicked\")\n\t})\n\tt.Run(\"decoder-api\", func(t *testing.T) {\n\t\tvar v int\n\t\tdec := NewDecoder(strings.NewReader(`33`))\n\t\tdefer dec.Release()\n\t\terr := dec.DecodeInt(&v)\n\t\tassert.Nil(t, err, \"Err must be nil\")\n\t\tassert.Equal(t, int(33), v, \"v must be equal to 33\")\n\t})\n\tt.Run(\"decoder-api2\", func(t *testing.T) {\n\t\tvar v int\n\t\tdec := NewDecoder(strings.NewReader(`33`))\n\t\tdefer dec.Release()\n\t\terr := dec.Decode(&v)\n\t\tassert.Nil(t, err, \"Err must be nil\")\n\t\tassert.Equal(t, int(33), v, \"v must be equal to 33\")\n\t})\n\tt.Run(\"decoder-api-invalid-json\", func(t *testing.T) {\n\t\tvar v int\n\t\tdec := NewDecoder(strings.NewReader(``))\n\t\tdefer dec.Release()\n\t\terr := dec.DecodeInt(&v)\n\t\tassert.NotNil(t, err, \"Err must not be nil\")\n\t\tassert.IsType(t, InvalidJSONError(\"\"), err, \"err should be of type InvalidJSONError\")\n\t})\n}\nfunc TestDecoderIntNull(t *testing.T) {\n\ttestCases := []struct {\n\t\tname           string\n\t\tjson           string\n\t\texpectedResult int\n\t\terr            bool\n\t\terrType        interface{}\n\t\tresultIsNil    bool\n\t}{\n\t\t{\n\t\t\tname:           \"basic-positive\",\n\t\t\tjson:           \"100\",\n\t\t\texpectedResult: 100,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-positive2\",\n\t\t\tjson:           \"1039405\",\n\t\t\texpectedResult: 1039405,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-negative\",\n\t\t\tjson:           \"-2\",\n\t\t\texpectedResult: -2,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-null\",\n\t\t\tjson:           \"null\",\n\t\t\texpectedResult: 0,\n\t\t\tresultIsNil:    true,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-negative-err\",\n\t\t\tjson:           \"-\",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t\terrType:        InvalidJSONError(\"\"),\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-negative-err\",\n\t\t\tjson:           \"-q\",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t\terrType:        InvalidJSONError(\"\"),\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-null-err\",\n\t\t\tjson:           \"nxll\",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t\terrType:        InvalidJSONError(\"\"),\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-skip-data-err\",\n\t\t\tjson:           \"trua\",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t\terrType:        InvalidJSONError(\"\"),\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-big\",\n\t\t\tjson:           \"9223372036854775807\",\n\t\t\texpectedResult: 9223372036854775807,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-big-overflow\",\n\t\t\tjson:           \"9223372036854775808\",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t\terrType:        InvalidUnmarshalError(\"\"),\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-big-overflow2\",\n\t\t\tjson:           \"92233720368547758089\",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t\terrType:        InvalidUnmarshalError(\"\"),\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-big-overflow3\",\n\t\t\tjson:           \"92233720368547758089 \",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t\terrType:        InvalidUnmarshalError(\"\"),\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-negative2\",\n\t\t\tjson:           \"-2349557\",\n\t\t\texpectedResult: -2349557,\n\t\t},\n\t\t{\n\t\t\tname:           \"exponent-err-too-big\",\n\t\t\tjson:           \"0e10000000000000000000\",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-float\",\n\t\t\tjson:           \"2.4595\",\n\t\t\texpectedResult: 2,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-float2\",\n\t\t\tjson:           \"-7.8876\",\n\t\t\texpectedResult: -7,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-float2\",\n\t\t\tjson:           \"-7.8876 \",\n\t\t\texpectedResult: -7,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-float2\",\n\t\t\tjson:           \"-7.8876a\",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-exponent-positive-positive-exp\",\n\t\t\tjson:           \"1e2\",\n\t\t\texpectedResult: 100,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-exponent-positive-positive-exp2\",\n\t\t\tjson:           \"5e+06\",\n\t\t\texpectedResult: 5000000,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-exponent-positive-positive-exp2\",\n\t\t\tjson:           \"5.01e+10\",\n\t\t\texpectedResult: 50100000000,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-exponent-positive-positive-exp3\",\n\t\t\tjson:           \"3e+3\",\n\t\t\texpectedResult: 3000,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-exponent-positive-positive-exp4\",\n\t\t\tjson:           \"8e+005\",\n\t\t\texpectedResult: 800000,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-exponent-positive-negative-exp\",\n\t\t\tjson:           \"1e-2\",\n\t\t\texpectedResult: 0,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-exponent-positive-negative-exp2\",\n\t\t\tjson:           \"5e-6\",\n\t\t\texpectedResult: 0,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-exponent-positive-negative-exp3\",\n\t\t\tjson:           \"3e-3\",\n\t\t\texpectedResult: 0,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-exponent-positive-negative-exp4\",\n\t\t\tjson:           \"8e-005\",\n\t\t\texpectedResult: 0,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-exponent-negative-positive-exp\",\n\t\t\tjson:           \"-1e2\",\n\t\t\texpectedResult: -100,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-exponent-negative-positive-exp2\",\n\t\t\tjson:           \"-5e+06\",\n\t\t\texpectedResult: -5000000,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-exponent-negative-positive-exp3\",\n\t\t\tjson:           \"-3e03\",\n\t\t\texpectedResult: -3000,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-exponent-negative-positive-exp4\",\n\t\t\tjson:           \"-8e+005\",\n\t\t\texpectedResult: -800000,\n\t\t},\n\t\t{\n\t\t\tname:           \"error1\",\n\t\t\tjson:           \"132zz4\",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t},\n\t\t{\n\t\t\tname:           \"negative-error2\",\n\t\t\tjson:           \" -1213xdde2323 \",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t\terrType:        InvalidJSONError(\"\"),\n\t\t},\n\t\t{\n\t\t\tname:           \"error3\",\n\t\t\tjson:           \"-8e+00$aa5\",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t\terrType:        InvalidJSONError(\"\"),\n\t\t},\n\t\t{\n\t\t\tname:           \"error4\",\n\t\t\tjson:           \"0.E----\",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t\terrType:        InvalidJSONError(\"\"),\n\t\t},\n\t\t{\n\t\t\tname:           \"exponent-err-\",\n\t\t\tjson:           \"0.1e\",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t},\n\t\t{\n\t\t\tname:           \"error5\",\n\t\t\tjson:           \"0E40\",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t\terrType:        InvalidJSONError(\"\"),\n\t\t},\n\t\t{\n\t\t\tname:           \"error6\",\n\t\t\tjson:           \"0.e-9\",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t\terrType:        InvalidJSONError(\"\"),\n\t\t},\n\n\t\t{\n\t\t\tname:           \"error7\",\n\t\t\tjson:           \"-5.e-2\",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t\terrType:        InvalidJSONError(\"\"),\n\t\t},\n\t\t{\n\t\t\tname:           \"invalid-type\",\n\t\t\tjson:           `\"string\"`,\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t\terrType:        InvalidUnmarshalError(\"\"),\n\t\t},\n\t}\n\tfor _, testCase := range testCases {\n\t\tt.Run(testCase.name, func(t *testing.T) {\n\t\t\tjson := []byte(testCase.json)\n\t\t\tvar v = (*int)(nil)\n\t\t\terr := Unmarshal(json, &v)\n\t\t\tif testCase.err {\n\t\t\t\tassert.NotNil(t, err, \"Err must not be nil\")\n\t\t\t\tif testCase.errType != nil && err != nil {\n\t\t\t\t\tassert.IsType(\n\t\t\t\t\t\tt,\n\t\t\t\t\t\ttestCase.errType,\n\t\t\t\t\t\terr,\n\t\t\t\t\t\tfmt.Sprintf(\"err should be of type %s\", reflect.TypeOf(err).String()),\n\t\t\t\t\t)\n\t\t\t\t}\n\t\t\t\treturn\n\t\t\t}\n\t\t\tassert.Nil(t, err, \"Err must be nil\")\n\t\t\tif testCase.resultIsNil {\n\t\t\t\tassert.Nil(t, v)\n\t\t\t} else {\n\t\t\t\tassert.Equal(t, testCase.expectedResult, *v, fmt.Sprintf(\"v must be equal to %d\", testCase.expectedResult))\n\t\t\t}\n\t\t})\n\t}\n\tt.Run(\"decoder-api-invalid-json\", func(t *testing.T) {\n\t\tvar v = new(int)\n\t\terr := Unmarshal([]byte(``), &v)\n\t\tassert.NotNil(t, err, \"Err must not be nil\")\n\t\tassert.IsType(t, InvalidJSONError(\"\"), err, \"err should be of type InvalidJSONError\")\n\t})\n\tt.Run(\"decoder-api-invalid-json2\", func(t *testing.T) {\n\t\tvar v = new(int)\n\t\tvar dec = NewDecoder(strings.NewReader(``))\n\t\terr := dec.IntNull(&v)\n\t\tassert.NotNil(t, err, \"Err must not be nil\")\n\t\tassert.IsType(t, InvalidJSONError(\"\"), err, \"err should be of type InvalidJSONError\")\n\t})\n}\n\nfunc TestDecoderInt64(t *testing.T) {\n\ttestCases := []struct {\n\t\tname           string\n\t\tjson           string\n\t\texpectedResult int64\n\t\terr            bool\n\t\terrType        interface{}\n\t}{\n\t\t{\n\t\t\tname:           \"basic-positive\",\n\t\t\tjson:           \"100\",\n\t\t\texpectedResult: 100,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-positive2\",\n\t\t\tjson:           \" 1039405\",\n\t\t\texpectedResult: 1039405,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-negative\",\n\t\t\tjson:           \"-2\",\n\t\t\texpectedResult: -2,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-null\",\n\t\t\tjson:           \"null\",\n\t\t\texpectedResult: 0,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-null-err\",\n\t\t\tjson:           \"nxll\",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t\terrType:        InvalidJSONError(\"\"),\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-negative-err\",\n\t\t\tjson:           \"-\",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t\terrType:        InvalidJSONError(\"\"),\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-negative-err\",\n\t\t\tjson:           \"-q\",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t\terrType:        InvalidJSONError(\"\"),\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-skip-data-err\",\n\t\t\tjson:           \"trua\",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t\terrType:        InvalidJSONError(\"\"),\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-big\",\n\t\t\tjson:           \"9223372036854775807\",\n\t\t\texpectedResult: 9223372036854775807,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-big-overflow\",\n\t\t\tjson:           \" 9223372036854775808\",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-big-overflow\",\n\t\t\tjson:           \" 9223372036854775827\",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-big-overflow2\",\n\t\t\tjson:           \"92233720368547758089\",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-big-overflow3\",\n\t\t\tjson:           \"92233720368547758089 \",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-negative2\",\n\t\t\tjson:           \"-2349557\",\n\t\t\texpectedResult: -2349557,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-float\",\n\t\t\tjson:           \"2.4595\",\n\t\t\texpectedResult: 2,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-float2\",\n\t\t\tjson:           \"-7.8876\",\n\t\t\texpectedResult: -7,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-float2\",\n\t\t\tjson:           \"-7.8876a\",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-exponent-positive-positive-exp\",\n\t\t\tjson:           \"1e2\",\n\t\t\texpectedResult: 100,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-exponent-positive-positive-exp2\",\n\t\t\tjson:           \"5e+06 \",\n\t\t\texpectedResult: 5000000,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-exponent-positive-positive-exp3\",\n\t\t\tjson:           \"3e+3\",\n\t\t\texpectedResult: 3000,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-exponent-positive-positive-exp4\",\n\t\t\tjson:           \"8e+005\",\n\t\t\texpectedResult: 800000,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-exponent-positive-negative-exp\",\n\t\t\tjson:           \"1e-2 \",\n\t\t\texpectedResult: 0,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-exponent-positive-negative-exp2\",\n\t\t\tjson:           \"5e-6\",\n\t\t\texpectedResult: 0,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-exponent-positive-negative-exp3\",\n\t\t\tjson:           \"3e-3\",\n\t\t\texpectedResult: 0,\n\t\t},\n\t\t{\n\t\t\tname:           \"before-exp-err-too-big\",\n\t\t\tjson:           \"10.11231242345325435464364643e1\",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t},\n\t\t{\n\t\t\tname:           \"error3\",\n\t\t\tjson:           \"0E40\",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t\terrType:        InvalidJSONError(\"\"),\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-exponent-positive-negative-exp4\",\n\t\t\tjson:           \"8e-005\",\n\t\t\texpectedResult: 0,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-exponent-negative-positive-exp\",\n\t\t\tjson:           \"-1e2\",\n\t\t\texpectedResult: -100,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-exponent-negative-positive-exp2\",\n\t\t\tjson:           \"-5e+06\",\n\t\t\texpectedResult: -5000000,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-exponent-negative-positive-exp2\",\n\t\t\tjson:           \"-5.4e+06\",\n\t\t\texpectedResult: -5400000,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-exponent-negative-positive-exp3\",\n\t\t\tjson:           \"-3e03\",\n\t\t\texpectedResult: -3000,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-exponent-negative-positive-exp4\",\n\t\t\tjson:           \"-8e+005\",\n\t\t\texpectedResult: -800000,\n\t\t},\n\t\t{\n\t\t\tname:           \"exponent-err-too-big\",\n\t\t\tjson:           \"0e10000000000000000000\",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t},\n\t\t{\n\t\t\tname:           \"exponent-err-too-big\",\n\t\t\tjson:           \"0e1000000000000000000000000 \",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t},\n\t\t{\n\t\t\tname:           \"exponent-err-too-big\",\n\t\t\tjson:           \"0.1e1000000000\",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t},\n\t\t{\n\t\t\tname:           \"exponent-err-too-big\",\n\t\t\tjson:           \"0.1932242242424244244e1000000000000000000000000\",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-exponent-negative-positive-exp4\",\n\t\t\tjson:           \"8ea+00a5\",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t\terrType:        InvalidJSONError(\"\"),\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-exponent-err\",\n\t\t\tjson:           \"3e\",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t},\n\t\t{\n\t\t\tname:           \"error1\",\n\t\t\tjson:           \"132zz4\",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t},\n\t\t{\n\t\t\tname:           \"error4\",\n\t\t\tjson:           \"0.E----\",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t\terrType:        InvalidJSONError(\"\"),\n\t\t},\n\t\t{\n\t\t\tname:           \"error5\",\n\t\t\tjson:           \"0E40\",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t\terrType:        InvalidJSONError(\"\"),\n\t\t},\n\t\t{\n\t\t\tname:           \"exponent-err-\",\n\t\t\tjson:           \"0.1e\",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t},\n\t\t{\n\t\t\tname:           \"error6\",\n\t\t\tjson:           \"0.e-9\",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t\terrType:        InvalidJSONError(\"\"),\n\t\t},\n\t\t{\n\t\t\tname:           \"error7\",\n\t\t\tjson:           \"-5.e-2\",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t\terrType:        InvalidJSONError(\"\"),\n\t\t},\n\t\t{\n\t\t\tname:           \"invalid-type\",\n\t\t\tjson:           `\"string\"`,\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t\terrType:        InvalidUnmarshalError(\"\"),\n\t\t},\n\t}\n\tfor _, testCase := range testCases {\n\t\tt.Run(testCase.name, func(t *testing.T) {\n\t\t\tjson := []byte(testCase.json)\n\t\t\tvar v int64\n\t\t\terr := Unmarshal(json, &v)\n\t\t\tif testCase.err {\n\t\t\t\tassert.NotNil(t, err, \"Err must not be nil\")\n\t\t\t\tif testCase.errType != nil {\n\t\t\t\t\tassert.IsType(\n\t\t\t\t\t\tt,\n\t\t\t\t\t\ttestCase.errType,\n\t\t\t\t\t\terr,\n\t\t\t\t\t\tfmt.Sprintf(\"err should be of type %s\", reflect.TypeOf(err).String()),\n\t\t\t\t\t)\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tassert.Nil(t, err, \"Err must be nil\")\n\t\t\t}\n\t\t\tassert.Equal(t, testCase.expectedResult, v, fmt.Sprintf(\"v must be equal to %d\", testCase.expectedResult))\n\t\t})\n\t}\n\tt.Run(\"pool-error\", func(t *testing.T) {\n\t\tresult := int64(1)\n\t\tdec := NewDecoder(nil)\n\t\tdec.Release()\n\t\tdefer func() {\n\t\t\terr := recover()\n\t\t\tassert.NotNil(t, err, \"err shouldnt be nil\")\n\t\t\tassert.IsType(t, InvalidUsagePooledDecoderError(\"\"), err, \"err should be of type InvalidUsagePooledDecoderError\")\n\t\t}()\n\t\t_ = dec.DecodeInt64(&result)\n\t\tassert.True(t, false, \"should not be called as decoder should have panicked\")\n\t})\n\tt.Run(\"decoder-api\", func(t *testing.T) {\n\t\tvar v int64\n\t\tdec := NewDecoder(strings.NewReader(`33`))\n\t\tdefer dec.Release()\n\t\terr := dec.DecodeInt64(&v)\n\t\tassert.Nil(t, err, \"Err must be nil\")\n\t\tassert.Equal(t, int64(33), v, \"v must be equal to 33\")\n\t})\n\tt.Run(\"decoder-api2\", func(t *testing.T) {\n\t\tvar v int64\n\t\tdec := NewDecoder(strings.NewReader(`33`))\n\t\tdefer dec.Release()\n\t\terr := dec.Decode(&v)\n\t\tassert.Nil(t, err, \"Err must be nil\")\n\t\tassert.Equal(t, int64(33), v, \"v must be equal to 33\")\n\t})\n\tt.Run(\"decoder-api-invalid-json\", func(t *testing.T) {\n\t\tvar v int64\n\t\tdec := NewDecoder(strings.NewReader(``))\n\t\tdefer dec.Release()\n\t\terr := dec.DecodeInt64(&v)\n\t\tassert.NotNil(t, err, \"Err must not be nil\")\n\t\tassert.IsType(t, InvalidJSONError(\"\"), err, \"err should be of type InvalidJSONError\")\n\t})\n}\nfunc TestDecoderInt64Null(t *testing.T) {\n\ttestCases := []struct {\n\t\tname           string\n\t\tjson           string\n\t\texpectedResult int64\n\t\terr            bool\n\t\terrType        interface{}\n\t\tresultIsNil    bool\n\t}{\n\t\t{\n\t\t\tname:           \"basic-positive\",\n\t\t\tjson:           \"100\",\n\t\t\texpectedResult: 100,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-positive2\",\n\t\t\tjson:           \" 1039405\",\n\t\t\texpectedResult: 1039405,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-negative\",\n\t\t\tjson:           \"-2\",\n\t\t\texpectedResult: -2,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-null\",\n\t\t\tjson:           \"null\",\n\t\t\texpectedResult: 0,\n\t\t\tresultIsNil:    true,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-null-err\",\n\t\t\tjson:           \"nxll\",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t\terrType:        InvalidJSONError(\"\"),\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-negative-err\",\n\t\t\tjson:           \"-\",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t\terrType:        InvalidJSONError(\"\"),\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-negative-err\",\n\t\t\tjson:           \"-q\",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t\terrType:        InvalidJSONError(\"\"),\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-skip-data-err\",\n\t\t\tjson:           \"trua\",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t\terrType:        InvalidJSONError(\"\"),\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-big\",\n\t\t\tjson:           \"9223372036854775807\",\n\t\t\texpectedResult: 9223372036854775807,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-big-overflow\",\n\t\t\tjson:           \" 9223372036854775808\",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-big-overflow\",\n\t\t\tjson:           \" 9223372036854775827\",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-big-overflow2\",\n\t\t\tjson:           \"92233720368547758089\",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-big-overflow3\",\n\t\t\tjson:           \"92233720368547758089 \",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-negative2\",\n\t\t\tjson:           \"-2349557\",\n\t\t\texpectedResult: -2349557,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-float\",\n\t\t\tjson:           \"2.4595\",\n\t\t\texpectedResult: 2,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-float2\",\n\t\t\tjson:           \"-7.8876\",\n\t\t\texpectedResult: -7,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-float2\",\n\t\t\tjson:           \"-7.8876a\",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-exponent-positive-positive-exp\",\n\t\t\tjson:           \"1e2\",\n\t\t\texpectedResult: 100,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-exponent-positive-positive-exp2\",\n\t\t\tjson:           \"5e+06 \",\n\t\t\texpectedResult: 5000000,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-exponent-positive-positive-exp3\",\n\t\t\tjson:           \"3e+3\",\n\t\t\texpectedResult: 3000,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-exponent-positive-positive-exp4\",\n\t\t\tjson:           \"8e+005\",\n\t\t\texpectedResult: 800000,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-exponent-positive-negative-exp\",\n\t\t\tjson:           \"1e-2 \",\n\t\t\texpectedResult: 0,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-exponent-positive-negative-exp2\",\n\t\t\tjson:           \"5e-6\",\n\t\t\texpectedResult: 0,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-exponent-positive-negative-exp3\",\n\t\t\tjson:           \"3e-3\",\n\t\t\texpectedResult: 0,\n\t\t},\n\t\t{\n\t\t\tname:           \"error3\",\n\t\t\tjson:           \"0E40\",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t\terrType:        InvalidJSONError(\"\"),\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-exponent-positive-negative-exp4\",\n\t\t\tjson:           \"8e-005\",\n\t\t\texpectedResult: 0,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-exponent-negative-positive-exp\",\n\t\t\tjson:           \"-1e2\",\n\t\t\texpectedResult: -100,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-exponent-negative-positive-exp2\",\n\t\t\tjson:           \"-5e+06\",\n\t\t\texpectedResult: -5000000,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-exponent-negative-positive-exp2\",\n\t\t\tjson:           \"-5.4e+06\",\n\t\t\texpectedResult: -5400000,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-exponent-negative-positive-exp3\",\n\t\t\tjson:           \"-3e03\",\n\t\t\texpectedResult: -3000,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-exponent-negative-positive-exp4\",\n\t\t\tjson:           \"-8e+005\",\n\t\t\texpectedResult: -800000,\n\t\t},\n\t\t{\n\t\t\tname:           \"exponent-err-too-big\",\n\t\t\tjson:           \"0e10000000000000000000\",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t},\n\t\t{\n\t\t\tname:           \"exponent-err-too-big\",\n\t\t\tjson:           \"0e1000000000000000000000000 \",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t},\n\t\t{\n\t\t\tname:           \"exponent-err-too-big\",\n\t\t\tjson:           \"0.1e1000000000\",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t},\n\t\t{\n\t\t\tname:           \"exponent-err-too-big\",\n\t\t\tjson:           \"0.1932242242424244244e1000000000000000000000000\",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-exponent-negative-positive-exp4\",\n\t\t\tjson:           \"8ea+00a5\",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t\terrType:        InvalidJSONError(\"\"),\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-exponent-err\",\n\t\t\tjson:           \"3e\",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t},\n\t\t{\n\t\t\tname:           \"error1\",\n\t\t\tjson:           \"132zz4\",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t},\n\t\t{\n\t\t\tname:           \"error4\",\n\t\t\tjson:           \"0.E----\",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t\terrType:        InvalidJSONError(\"\"),\n\t\t},\n\t\t{\n\t\t\tname:           \"error5\",\n\t\t\tjson:           \"0E40\",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t\terrType:        InvalidJSONError(\"\"),\n\t\t},\n\t\t{\n\t\t\tname:           \"exponent-err-\",\n\t\t\tjson:           \"0.1e\",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t},\n\t\t{\n\t\t\tname:           \"error6\",\n\t\t\tjson:           \"0.e-9\",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t\terrType:        InvalidJSONError(\"\"),\n\t\t},\n\t\t{\n\t\t\tname:           \"error7\",\n\t\t\tjson:           \"-5.e-2\",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t\terrType:        InvalidJSONError(\"\"),\n\t\t},\n\t\t{\n\t\t\tname:           \"invalid-type\",\n\t\t\tjson:           `\"string\"`,\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t\terrType:        InvalidUnmarshalError(\"\"),\n\t\t},\n\t}\n\tfor _, testCase := range testCases {\n\t\tt.Run(testCase.name, func(t *testing.T) {\n\t\t\tjson := []byte(testCase.json)\n\t\t\tvar v = (*int64)(nil)\n\t\t\terr := Unmarshal(json, &v)\n\t\t\tif testCase.err {\n\t\t\t\tassert.NotNil(t, err, \"Err must not be nil\")\n\t\t\t\tif testCase.errType != nil {\n\t\t\t\t\tassert.IsType(\n\t\t\t\t\t\tt,\n\t\t\t\t\t\ttestCase.errType,\n\t\t\t\t\t\terr,\n\t\t\t\t\t\tfmt.Sprintf(\"err should be of type %s\", reflect.TypeOf(err).String()),\n\t\t\t\t\t)\n\t\t\t\t}\n\t\t\t\treturn\n\t\t\t}\n\t\t\tassert.Nil(t, err, \"Err must be nil\")\n\t\t\tif testCase.resultIsNil {\n\t\t\t\tassert.Nil(t, v)\n\t\t\t} else {\n\t\t\t\tassert.Equal(t, testCase.expectedResult, *v, fmt.Sprintf(\"v must be equal to %d\", testCase.expectedResult))\n\t\t\t}\n\t\t})\n\t}\n\tt.Run(\"decoder-api-invalid-json\", func(t *testing.T) {\n\t\tvar v = new(int64)\n\t\terr := Unmarshal([]byte(``), &v)\n\t\tassert.NotNil(t, err, \"Err must not be nil\")\n\t\tassert.IsType(t, InvalidJSONError(\"\"), err, \"err should be of type InvalidJSONError\")\n\t})\n\tt.Run(\"decoder-api-invalid-json2\", func(t *testing.T) {\n\t\tvar v = new(int64)\n\t\tvar dec = NewDecoder(strings.NewReader(``))\n\t\terr := dec.Int64Null(&v)\n\t\tassert.NotNil(t, err, \"Err must not be nil\")\n\t\tassert.IsType(t, InvalidJSONError(\"\"), err, \"err should be of type InvalidJSONError\")\n\t})\n}\n\nfunc TestDecoderInt32(t *testing.T) {\n\ttestCases := []struct {\n\t\tname           string\n\t\tjson           string\n\t\texpectedResult int32\n\t\terr            bool\n\t\terrType        interface{}\n\t}{\n\t\t{\n\t\t\tname:           \"basic-positive\",\n\t\t\tjson:           \"100\",\n\t\t\texpectedResult: 100,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-positive2\",\n\t\t\tjson:           \" 1039405\",\n\t\t\texpectedResult: 1039405,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-negative\",\n\t\t\tjson:           \"-2\",\n\t\t\texpectedResult: -2,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-null\",\n\t\t\tjson:           \"null\",\n\t\t\texpectedResult: 0,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-null-err\",\n\t\t\tjson:           \"nxll\",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t\terrType:        InvalidJSONError(\"\"),\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-negative-err\",\n\t\t\tjson:           \"-\",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t\terrType:        InvalidJSONError(\"\"),\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-negative-err\",\n\t\t\tjson:           \"-q\",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t\terrType:        InvalidJSONError(\"\"),\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-skip-data-err\",\n\t\t\tjson:           \"trua\",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t\terrType:        InvalidJSONError(\"\"),\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-negative2\",\n\t\t\tjson:           \"-2349557\",\n\t\t\texpectedResult: -2349557,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-big\",\n\t\t\tjson:           \" 2147483647\",\n\t\t\texpectedResult: 2147483647,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-big-overflow\",\n\t\t\tjson:           \" 2147483648\",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-big-overflow\",\n\t\t\tjson:           \" 2147483657\",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-big-overflow2\",\n\t\t\tjson:           \"21474836483\",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-float\",\n\t\t\tjson:           \"2.4595\",\n\t\t\texpectedResult: 2,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-float2\",\n\t\t\tjson:           \"-7.8876\",\n\t\t\texpectedResult: -7,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-float2\",\n\t\t\tjson:           \"-7.8876a\",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-exponent-positive-positive-exp\",\n\t\t\tjson:           \"1.2E2\",\n\t\t\texpectedResult: 120,\n\t\t},\n\t\t{\n\t\t\tname:           \"exponent-err-too-big\",\n\t\t\tjson:           \"0e10000000000000000000\",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t},\n\t\t{\n\t\t\tname:           \"exponent-err-too-big\",\n\t\t\tjson:           \"0.1932242242424244244e1000000000000000000000000\",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-exponent-positive-positive-exp1\",\n\t\t\tjson:           \"3.5e+005 \",\n\t\t\texpectedResult: 350000,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-exponent-positive-positive-exp1\",\n\t\t\tjson:           \"3.5e+005\",\n\t\t\texpectedResult: 350000,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-exponent-positive-positive-exp2\",\n\t\t\tjson:           \"5e+06\",\n\t\t\texpectedResult: 5000000,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-exponent-positive-positive-exp3\",\n\t\t\tjson:           \"3e+3\",\n\t\t\texpectedResult: 3000,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-exponent-positive-positive-exp4\",\n\t\t\tjson:           \"8e+005 \",\n\t\t\texpectedResult: 800000,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-exponent-positive-negative-exp\",\n\t\t\tjson:           \"1e-2 \",\n\t\t\texpectedResult: 0,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-exponent-positive-negative-exp2\",\n\t\t\tjson:           \"5E-6\",\n\t\t\texpectedResult: 0,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-exponent-positive-negative-exp3\",\n\t\t\tjson:           \"3e-3\",\n\t\t\texpectedResult: 0,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-exponent-positive-negative-exp4\",\n\t\t\tjson:           \"8e-005\",\n\t\t\texpectedResult: 0,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-exponent-negative-positive-exp\",\n\t\t\tjson:           \"-1e2\",\n\t\t\texpectedResult: -100,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-exponent-negative-positive-exp2\",\n\t\t\tjson:           \"-5e+06\",\n\t\t\texpectedResult: -5000000,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-exponent-negative-positive-exp3\",\n\t\t\tjson:           \"-3e03\",\n\t\t\texpectedResult: -3000,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-exponent-negative-positive-exp4\",\n\t\t\tjson:           \"-8e+005\",\n\t\t\texpectedResult: -800000,\n\t\t},\n\t\t{\n\t\t\tname:           \"before-exp-err-too-big\",\n\t\t\tjson:           \"10.11231242345325435464364643e1\",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t},\n\t\t{\n\t\t\tname:           \"exponent-err-\",\n\t\t\tjson:           \"0.1e\",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t},\n\t\t{\n\t\t\tname:           \"exponent-err-too-big\",\n\t\t\tjson:           \"0.1e10000000000000000000\",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t},\n\t\t{\n\t\t\tname:           \"exponent-err-too-big\",\n\t\t\tjson:           \"0.1e1000000000\",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t},\n\t\t{\n\t\t\tname:           \"exponent-err-too-big\",\n\t\t\tjson:           \"0.1e1000000000 \",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t},\n\t\t{\n\t\t\tname:           \"exponent-err-too-big\",\n\t\t\tjson:           \"0e100000000000\",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t},\n\t\t{\n\t\t\tname:           \"exponent-err-too-big\",\n\t\t\tjson:           \"0e100000000000 \",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-exponent-err\",\n\t\t\tjson:           \"3e\",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t},\n\t\t{\n\t\t\tname:           \"error3\",\n\t\t\tjson:           \"0E40\",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t\terrType:        InvalidJSONError(\"\"),\n\t\t},\n\t\t{\n\t\t\tname:           \"error4\",\n\t\t\tjson:           \"0.E----\",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t\terrType:        InvalidJSONError(\"\"),\n\t\t},\n\t\t{\n\t\t\tname:           \"error5\",\n\t\t\tjson:           \"0E40\",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t\terrType:        InvalidJSONError(\"\"),\n\t\t},\n\t\t{\n\t\t\tname:           \"error6\",\n\t\t\tjson:           \"0.e-9\",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t\terrType:        InvalidJSONError(\"\"),\n\t\t},\n\t\t{\n\t\t\tname:           \"error7\",\n\t\t\tjson:           \"-5.e-2\",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t\terrType:        InvalidJSONError(\"\"),\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-float\",\n\t\t\tjson:           \"8.32 \",\n\t\t\texpectedResult: 8,\n\t\t},\n\t\t{\n\t\t\tname:           \"error\",\n\t\t\tjson:           \"83zez4\",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t\terrType:        InvalidJSONError(\"\"),\n\t\t},\n\t\t{\n\t\t\tname:           \"error\",\n\t\t\tjson:           \"8ea00$aa5\",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t\terrType:        InvalidJSONError(\"\"),\n\t\t},\n\t\t{\n\t\t\tname:           \"error2\",\n\t\t\tjson:           \"-8e+00$aa5\",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t},\n\t\t{\n\t\t\tname:           \"invalid-type\",\n\t\t\tjson:           `\"string\"`,\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t\terrType:        InvalidUnmarshalError(\"\"),\n\t\t},\n\t}\n\tfor _, testCase := range testCases {\n\t\tt.Run(testCase.name, func(t *testing.T) {\n\t\t\tjson := []byte(testCase.json)\n\t\t\tvar v int32\n\t\t\terr := Unmarshal(json, &v)\n\t\t\tif testCase.err {\n\t\t\t\tassert.NotNil(t, err, \"Err must not be nil\")\n\t\t\t\tif testCase.errType != nil {\n\t\t\t\t\tassert.IsType(\n\t\t\t\t\t\tt,\n\t\t\t\t\t\ttestCase.errType,\n\t\t\t\t\t\terr,\n\t\t\t\t\t\tfmt.Sprintf(\"err should be of type %s\", reflect.TypeOf(err).String()),\n\t\t\t\t\t)\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tassert.Nil(t, err, \"Err must be nil\")\n\t\t\t}\n\t\t\tassert.Equal(t, testCase.expectedResult, v, fmt.Sprintf(\"v must be equal to %d\", testCase.expectedResult))\n\t\t})\n\t}\n\tt.Run(\"pool-error\", func(t *testing.T) {\n\t\tresult := int32(1)\n\t\tdec := NewDecoder(nil)\n\t\tdec.Release()\n\t\tdefer func() {\n\t\t\terr := recover()\n\t\t\tassert.NotNil(t, err, \"err shouldnt be nil\")\n\t\t\tassert.IsType(t, InvalidUsagePooledDecoderError(\"\"), err, \"err should be of type InvalidUsagePooledDecoderError\")\n\t\t}()\n\t\t_ = dec.DecodeInt32(&result)\n\t\tassert.True(t, false, \"should not be called as decoder should have panicked\")\n\n\t})\n\tt.Run(\"decoder-api\", func(t *testing.T) {\n\t\tvar v int32\n\t\tdec := NewDecoder(strings.NewReader(`33`))\n\t\tdefer dec.Release()\n\t\terr := dec.DecodeInt32(&v)\n\t\tassert.Nil(t, err, \"Err must be nil\")\n\t\tassert.Equal(t, int32(33), v, \"v must be equal to 33\")\n\t})\n\tt.Run(\"decoder-api2\", func(t *testing.T) {\n\t\tvar v int32\n\t\tdec := NewDecoder(strings.NewReader(`33`))\n\t\tdefer dec.Release()\n\t\terr := dec.Decode(&v)\n\t\tassert.Nil(t, err, \"Err must be nil\")\n\t\tassert.Equal(t, int32(33), v, \"v must be equal to 33\")\n\t})\n\tt.Run(\"decoder-api-invalid-json\", func(t *testing.T) {\n\t\tvar v int32\n\t\tdec := NewDecoder(strings.NewReader(``))\n\t\tdefer dec.Release()\n\t\terr := dec.DecodeInt32(&v)\n\t\tassert.NotNil(t, err, \"Err must not be nil\")\n\t\tassert.IsType(t, InvalidJSONError(\"\"), err, \"err should be of type InvalidJSONError\")\n\t})\n}\nfunc TestDecoderInt32Null(t *testing.T) {\n\ttestCases := []struct {\n\t\tname           string\n\t\tjson           string\n\t\texpectedResult int32\n\t\terr            bool\n\t\terrType        interface{}\n\t\tresultIsNil    bool\n\t}{\n\t\t{\n\t\t\tname:           \"basic-positive\",\n\t\t\tjson:           \"100\",\n\t\t\texpectedResult: 100,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-positive2\",\n\t\t\tjson:           \" 1039405\",\n\t\t\texpectedResult: 1039405,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-negative\",\n\t\t\tjson:           \"-2\",\n\t\t\texpectedResult: -2,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-null\",\n\t\t\tjson:           \"null\",\n\t\t\texpectedResult: 0,\n\t\t\tresultIsNil:    true,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-null-err\",\n\t\t\tjson:           \"nxll\",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t\terrType:        InvalidJSONError(\"\"),\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-negative-err\",\n\t\t\tjson:           \"-\",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t\terrType:        InvalidJSONError(\"\"),\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-negative-err\",\n\t\t\tjson:           \"-q\",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t\terrType:        InvalidJSONError(\"\"),\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-skip-data-err\",\n\t\t\tjson:           \"trua\",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t\terrType:        InvalidJSONError(\"\"),\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-negative2\",\n\t\t\tjson:           \"-2349557\",\n\t\t\texpectedResult: -2349557,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-big\",\n\t\t\tjson:           \" 2147483647\",\n\t\t\texpectedResult: 2147483647,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-big-overflow\",\n\t\t\tjson:           \" 2147483648\",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-big-overflow\",\n\t\t\tjson:           \" 2147483657\",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-big-overflow2\",\n\t\t\tjson:           \"21474836483\",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-float\",\n\t\t\tjson:           \"2.4595\",\n\t\t\texpectedResult: 2,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-float2\",\n\t\t\tjson:           \"-7.8876\",\n\t\t\texpectedResult: -7,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-float2\",\n\t\t\tjson:           \"-7.8876a\",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-exponent-positive-positive-exp\",\n\t\t\tjson:           \"1.2E2\",\n\t\t\texpectedResult: 120,\n\t\t},\n\t\t{\n\t\t\tname:           \"exponent-err-too-big\",\n\t\t\tjson:           \"0e10000000000000000000\",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t},\n\t\t{\n\t\t\tname:           \"exponent-err-too-big\",\n\t\t\tjson:           \"0.1932242242424244244e1000000000000000000000000\",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-exponent-positive-positive-exp1\",\n\t\t\tjson:           \"3.5e+005 \",\n\t\t\texpectedResult: 350000,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-exponent-positive-positive-exp1\",\n\t\t\tjson:           \"3.5e+005\",\n\t\t\texpectedResult: 350000,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-exponent-positive-positive-exp2\",\n\t\t\tjson:           \"5e+06\",\n\t\t\texpectedResult: 5000000,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-exponent-positive-positive-exp3\",\n\t\t\tjson:           \"3e+3\",\n\t\t\texpectedResult: 3000,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-exponent-positive-positive-exp4\",\n\t\t\tjson:           \"8e+005 \",\n\t\t\texpectedResult: 800000,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-exponent-positive-negative-exp\",\n\t\t\tjson:           \"1e-2 \",\n\t\t\texpectedResult: 0,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-exponent-positive-negative-exp2\",\n\t\t\tjson:           \"5E-6\",\n\t\t\texpectedResult: 0,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-exponent-positive-negative-exp3\",\n\t\t\tjson:           \"3e-3\",\n\t\t\texpectedResult: 0,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-exponent-positive-negative-exp4\",\n\t\t\tjson:           \"8e-005\",\n\t\t\texpectedResult: 0,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-exponent-negative-positive-exp\",\n\t\t\tjson:           \"-1e2\",\n\t\t\texpectedResult: -100,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-exponent-negative-positive-exp2\",\n\t\t\tjson:           \"-5e+06\",\n\t\t\texpectedResult: -5000000,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-exponent-negative-positive-exp3\",\n\t\t\tjson:           \"-3e03\",\n\t\t\texpectedResult: -3000,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-exponent-negative-positive-exp4\",\n\t\t\tjson:           \"-8e+005\",\n\t\t\texpectedResult: -800000,\n\t\t},\n\t\t{\n\t\t\tname:           \"exponent-err-\",\n\t\t\tjson:           \"0.1e\",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t},\n\t\t{\n\t\t\tname:           \"exponent-err-too-big\",\n\t\t\tjson:           \"0.1e10000000000000000000\",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t},\n\t\t{\n\t\t\tname:           \"exponent-err-too-big\",\n\t\t\tjson:           \"0.1e1000000000\",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t},\n\t\t{\n\t\t\tname:           \"exponent-err-too-big\",\n\t\t\tjson:           \"0.1e1000000000 \",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t},\n\t\t{\n\t\t\tname:           \"exponent-err-too-big\",\n\t\t\tjson:           \"0e100000000000\",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t},\n\t\t{\n\t\t\tname:           \"exponent-err-too-big\",\n\t\t\tjson:           \"0e100000000000 \",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-exponent-err\",\n\t\t\tjson:           \"3e\",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t},\n\t\t{\n\t\t\tname:           \"error3\",\n\t\t\tjson:           \"0E40\",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t\terrType:        InvalidJSONError(\"\"),\n\t\t},\n\t\t{\n\t\t\tname:           \"error4\",\n\t\t\tjson:           \"0.E----\",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t\terrType:        InvalidJSONError(\"\"),\n\t\t},\n\t\t{\n\t\t\tname:           \"error5\",\n\t\t\tjson:           \"0E40\",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t\terrType:        InvalidJSONError(\"\"),\n\t\t},\n\t\t{\n\t\t\tname:           \"error6\",\n\t\t\tjson:           \"0.e-9\",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t\terrType:        InvalidJSONError(\"\"),\n\t\t},\n\t\t{\n\t\t\tname:           \"error7\",\n\t\t\tjson:           \"-5.e-2\",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t\terrType:        InvalidJSONError(\"\"),\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-float\",\n\t\t\tjson:           \"8.32 \",\n\t\t\texpectedResult: 8,\n\t\t},\n\t\t{\n\t\t\tname:           \"error\",\n\t\t\tjson:           \"83zez4\",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t\terrType:        InvalidJSONError(\"\"),\n\t\t},\n\t\t{\n\t\t\tname:           \"error\",\n\t\t\tjson:           \"8ea00$aa5\",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t\terrType:        InvalidJSONError(\"\"),\n\t\t},\n\t\t{\n\t\t\tname:           \"error2\",\n\t\t\tjson:           \"-8e+00$aa5\",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t},\n\t\t{\n\t\t\tname:           \"invalid-type\",\n\t\t\tjson:           `\"string\"`,\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t\terrType:        InvalidUnmarshalError(\"\"),\n\t\t},\n\t}\n\tfor _, testCase := range testCases {\n\t\tt.Run(testCase.name, func(t *testing.T) {\n\t\t\tjson := []byte(testCase.json)\n\t\t\tvar v = (*int32)(nil)\n\t\t\terr := Unmarshal(json, &v)\n\t\t\tif testCase.err {\n\t\t\t\tassert.NotNil(t, err, \"Err must not be nil\")\n\t\t\t\tif testCase.errType != nil {\n\t\t\t\t\tassert.IsType(\n\t\t\t\t\t\tt,\n\t\t\t\t\t\ttestCase.errType,\n\t\t\t\t\t\terr,\n\t\t\t\t\t\tfmt.Sprintf(\"err should be of type %s\", reflect.TypeOf(err).String()),\n\t\t\t\t\t)\n\t\t\t\t}\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tassert.Nil(t, err, \"Err must be nil\")\n\t\t\tif testCase.resultIsNil {\n\t\t\t\tassert.Nil(t, v)\n\t\t\t} else {\n\t\t\t\tassert.Equal(t, testCase.expectedResult, *v, fmt.Sprintf(\"v must be equal to %d\", testCase.expectedResult))\n\t\t\t}\n\t\t})\n\t}\n\tt.Run(\"decoder-api-invalid-json\", func(t *testing.T) {\n\t\tvar v = new(int32)\n\t\terr := Unmarshal([]byte(``), &v)\n\t\tassert.NotNil(t, err, \"Err must not be nil\")\n\t\tassert.IsType(t, InvalidJSONError(\"\"), err, \"err should be of type InvalidJSONError\")\n\t})\n\tt.Run(\"decoder-api-invalid-json2\", func(t *testing.T) {\n\t\tvar v = new(int32)\n\t\tvar dec = NewDecoder(strings.NewReader(``))\n\t\terr := dec.Int32Null(&v)\n\t\tassert.NotNil(t, err, \"Err must not be nil\")\n\t\tassert.IsType(t, InvalidJSONError(\"\"), err, \"err should be of type InvalidJSONError\")\n\t})\n}\n\nfunc TestDecoderInt16(t *testing.T) {\n\ttestCases := []struct {\n\t\tname           string\n\t\tjson           string\n\t\texpectedResult int16\n\t\terr            bool\n\t\terrType        interface{}\n\t}{\n\t\t{\n\t\t\tname:           \"basic-positive\",\n\t\t\tjson:           \"100\",\n\t\t\texpectedResult: 100,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-positive2\",\n\t\t\tjson:           \" 5321\",\n\t\t\texpectedResult: 5321,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-negative\",\n\t\t\tjson:           \"-2\",\n\t\t\texpectedResult: -2,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-null\",\n\t\t\tjson:           \"null\",\n\t\t\texpectedResult: 0,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-null-err\",\n\t\t\tjson:           \"nxll\",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t\terrType:        InvalidJSONError(\"\"),\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-negative-err\",\n\t\t\tjson:           \"-\",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t\terrType:        InvalidJSONError(\"\"),\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-negative-err\",\n\t\t\tjson:           \"-q\",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t\terrType:        InvalidJSONError(\"\"),\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-skip-data-err\",\n\t\t\tjson:           \"trua\",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t\terrType:        InvalidJSONError(\"\"),\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-negative2\",\n\t\t\tjson:           \"-2456\",\n\t\t\texpectedResult: -2456,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-big\",\n\t\t\tjson:           \" 24566\",\n\t\t\texpectedResult: 24566,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-big-overflow\",\n\t\t\tjson:           \"66535\",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-big-overflow\",\n\t\t\tjson:           \"32768\",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-big-overflow\",\n\t\t\tjson:           \" 2147483648\",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-big-overflow2\",\n\t\t\tjson:           \"21474836483\",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-float\",\n\t\t\tjson:           \"2.4595\",\n\t\t\texpectedResult: 2,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-float2\",\n\t\t\tjson:           \"-7.8876\",\n\t\t\texpectedResult: -7,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-float2\",\n\t\t\tjson:           \"-7.8876a\",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-exponent-positive-positive-exp\",\n\t\t\tjson:           \"1.2E2\",\n\t\t\texpectedResult: 120,\n\t\t},\n\t\t{\n\t\t\tname: \"exponent too big\",\n\t\t\tjson: \"1000.202302302422324435342E2\",\n\t\t\terr:  true,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-exponent-positive-positive-exp1\",\n\t\t\tjson:           \"3.5e+001 \",\n\t\t\texpectedResult: 35,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-exponent-positive-positive-exp1\",\n\t\t\tjson:           \"3.5e+002\",\n\t\t\texpectedResult: 350,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-exponent-positive-positive-exp2\",\n\t\t\tjson:           \"5e+03\",\n\t\t\texpectedResult: 5000,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-exponent-positive-positive-exp3\",\n\t\t\tjson:           \"3e+3\",\n\t\t\texpectedResult: 3000,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-exponent-positive-positive-exp4\",\n\t\t\tjson:           \"8e+02 \",\n\t\t\texpectedResult: 800,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-exponent-positive-negative-exp\",\n\t\t\tjson:           \"1e-2 \",\n\t\t\texpectedResult: 0,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-exponent-positive-negative-exp2\",\n\t\t\tjson:           \"5E-6\",\n\t\t\texpectedResult: 0,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-exponent-positive-negative-exp3\",\n\t\t\tjson:           \"3e-3\",\n\t\t\texpectedResult: 0,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-exponent-positive-negative-exp4\",\n\t\t\tjson:           \"8e-005\",\n\t\t\texpectedResult: 0,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-exponent-negative-positive-exp\",\n\t\t\tjson:           \"-1e2\",\n\t\t\texpectedResult: -100,\n\t\t},\n\t\t{\n\t\t\tname:           \"exponent-err-\",\n\t\t\tjson:           \"0.1e\",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t},\n\t\t{\n\t\t\tname:           \"exponent-err-too-big\",\n\t\t\tjson:           \"0.1e10000000000000000000\",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t},\n\t\t{\n\t\t\tname:           \"exponent-err-too-big\",\n\t\t\tjson:           \"0.1e10000000000 \",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t},\n\t\t{\n\t\t\tname:           \"exponent-err-too-big\",\n\t\t\tjson:           \"0e10000000000 \",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t},\n\t\t{\n\t\t\tname:           \"exponent-err-too-big\",\n\t\t\tjson:           \"0.1932242242424244244e1000000000000000000000000\",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-exponent-negative-positive-exp2\",\n\t\t\tjson:           \"-5e+03\",\n\t\t\texpectedResult: -5000,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-exponent-negative-positive-exp3\",\n\t\t\tjson:           \"-3e03\",\n\t\t\texpectedResult: -3000,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-exponent-negative-positive-exp4\",\n\t\t\tjson:           \"-8e+003\",\n\t\t\texpectedResult: -8000,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-exponent-err\",\n\t\t\tjson:           \"3e\",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-float\",\n\t\t\tjson:           \"8.32 \",\n\t\t\texpectedResult: 8,\n\t\t},\n\t\t{\n\t\t\tname:           \"error\",\n\t\t\tjson:           \"83zez4\",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t\terrType:        InvalidJSONError(\"\"),\n\t\t},\n\t\t{\n\t\t\tname:           \"error\",\n\t\t\tjson:           \"8ea00$aa5\",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t\terrType:        InvalidJSONError(\"\"),\n\t\t},\n\t\t{\n\t\t\tname:           \"error2\",\n\t\t\tjson:           \"-8e+00$aa5\",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t},\n\t\t{\n\t\t\tname:           \"error3\",\n\t\t\tjson:           \"0E40\",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t\terrType:        InvalidJSONError(\"\"),\n\t\t},\n\t\t{\n\t\t\tname:           \"error4\",\n\t\t\tjson:           \"0.E----\",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t\terrType:        InvalidJSONError(\"\"),\n\t\t},\n\t\t{\n\t\t\tname:           \"error5\",\n\t\t\tjson:           \"0E40\",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t\terrType:        InvalidJSONError(\"\"),\n\t\t},\n\t\t{\n\t\t\tname:           \"error6\",\n\t\t\tjson:           \"0.e-9\",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t\terrType:        InvalidJSONError(\"\"),\n\t\t},\n\t\t{\n\t\t\tname:           \"error7\",\n\t\t\tjson:           \"0.e\",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t\terrType:        InvalidJSONError(\"\"),\n\t\t},\n\t\t{\n\t\t\tname:           \"error8\",\n\t\t\tjson:           \"-5.e-2\",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t\terrType:        InvalidJSONError(\"\"),\n\t\t},\n\t\t{\n\t\t\tname:           \"invalid-type\",\n\t\t\tjson:           `\"string\"`,\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t\terrType:        InvalidUnmarshalError(\"\"),\n\t\t},\n\t}\n\tfor _, testCase := range testCases {\n\t\tt.Run(testCase.name, func(t *testing.T) {\n\t\t\tjson := []byte(testCase.json)\n\t\t\tvar v int16\n\t\t\terr := Unmarshal(json, &v)\n\t\t\tif testCase.err {\n\t\t\t\tassert.NotNil(t, err, \"Err must not be nil\")\n\t\t\t\tif testCase.errType != nil {\n\t\t\t\t\tassert.IsType(\n\t\t\t\t\t\tt,\n\t\t\t\t\t\ttestCase.errType,\n\t\t\t\t\t\terr,\n\t\t\t\t\t\tfmt.Sprintf(\"err should be of type %s\", reflect.TypeOf(err).String()),\n\t\t\t\t\t)\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tassert.Nil(t, err, \"Err must be nil\")\n\t\t\t}\n\t\t\tassert.Equal(t, testCase.expectedResult, v, fmt.Sprintf(\"v must be equal to %d\", testCase.expectedResult))\n\t\t})\n\t}\n\tt.Run(\"pool-error\", func(t *testing.T) {\n\t\tresult := int16(1)\n\t\tdec := NewDecoder(nil)\n\t\tdec.Release()\n\t\tdefer func() {\n\t\t\terr := recover()\n\t\t\tassert.NotNil(t, err, \"err shouldnt be nil\")\n\t\t\tassert.IsType(t, InvalidUsagePooledDecoderError(\"\"), err, \"err should be of type InvalidUsagePooledDecoderError\")\n\t\t}()\n\t\t_ = dec.DecodeInt16(&result)\n\t\tassert.True(t, false, \"should not be called as decoder should have panicked\")\n\n\t})\n\tt.Run(\"decoder-api\", func(t *testing.T) {\n\t\tvar v int16\n\t\tdec := NewDecoder(strings.NewReader(`33`))\n\t\tdefer dec.Release()\n\t\terr := dec.DecodeInt16(&v)\n\t\tassert.Nil(t, err, \"Err must be nil\")\n\t\tassert.Equal(t, int16(33), v, \"v must be equal to 33\")\n\t})\n\tt.Run(\"decoder-api2\", func(t *testing.T) {\n\t\tvar v int16\n\t\tdec := NewDecoder(strings.NewReader(`33`))\n\t\tdefer dec.Release()\n\t\terr := dec.Decode(&v)\n\t\tassert.Nil(t, err, \"Err must be nil\")\n\t\tassert.Equal(t, int16(33), v, \"v must be equal to 33\")\n\t})\n\tt.Run(\"decoder-api-invalid-json\", func(t *testing.T) {\n\t\tvar v int16\n\t\tdec := NewDecoder(strings.NewReader(``))\n\t\tdefer dec.Release()\n\t\terr := dec.DecodeInt16(&v)\n\t\tassert.NotNil(t, err, \"Err must not be nil\")\n\t\tassert.IsType(t, InvalidJSONError(\"\"), err, \"err should be of type InvalidJSONError\")\n\t})\n}\nfunc TestDecoderInt16Null(t *testing.T) {\n\ttestCases := []struct {\n\t\tname           string\n\t\tjson           string\n\t\texpectedResult int16\n\t\terr            bool\n\t\terrType        interface{}\n\t\tresultIsNil    bool\n\t}{\n\t\t{\n\t\t\tname:           \"basic-positive\",\n\t\t\tjson:           \"100\",\n\t\t\texpectedResult: 100,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-positive2\",\n\t\t\tjson:           \" 5321\",\n\t\t\texpectedResult: 5321,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-negative\",\n\t\t\tjson:           \"-2\",\n\t\t\texpectedResult: -2,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-null\",\n\t\t\tjson:           \"null\",\n\t\t\texpectedResult: 0,\n\t\t\tresultIsNil:    true,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-null-err\",\n\t\t\tjson:           \"nxll\",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t\terrType:        InvalidJSONError(\"\"),\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-negative-err\",\n\t\t\tjson:           \"-\",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t\terrType:        InvalidJSONError(\"\"),\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-negative-err\",\n\t\t\tjson:           \"-q\",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t\terrType:        InvalidJSONError(\"\"),\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-skip-data-err\",\n\t\t\tjson:           \"trua\",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t\terrType:        InvalidJSONError(\"\"),\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-negative2\",\n\t\t\tjson:           \"-2456\",\n\t\t\texpectedResult: -2456,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-big\",\n\t\t\tjson:           \" 24566\",\n\t\t\texpectedResult: 24566,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-big-overflow\",\n\t\t\tjson:           \"66535\",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-big-overflow\",\n\t\t\tjson:           \"32768\",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-big-overflow\",\n\t\t\tjson:           \" 2147483648\",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-big-overflow2\",\n\t\t\tjson:           \"21474836483\",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-float\",\n\t\t\tjson:           \"2.4595\",\n\t\t\texpectedResult: 2,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-float2\",\n\t\t\tjson:           \"-7.8876\",\n\t\t\texpectedResult: -7,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-float2\",\n\t\t\tjson:           \"-7.8876a\",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-exponent-positive-positive-exp\",\n\t\t\tjson:           \"1.2E2\",\n\t\t\texpectedResult: 120,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-exponent-positive-positive-exp1\",\n\t\t\tjson:           \"3.5e+001 \",\n\t\t\texpectedResult: 35,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-exponent-positive-positive-exp1\",\n\t\t\tjson:           \"3.5e+002\",\n\t\t\texpectedResult: 350,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-exponent-positive-positive-exp2\",\n\t\t\tjson:           \"5e+03\",\n\t\t\texpectedResult: 5000,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-exponent-positive-positive-exp3\",\n\t\t\tjson:           \"3e+3\",\n\t\t\texpectedResult: 3000,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-exponent-positive-positive-exp4\",\n\t\t\tjson:           \"8e+02 \",\n\t\t\texpectedResult: 800,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-exponent-positive-negative-exp\",\n\t\t\tjson:           \"1e-2 \",\n\t\t\texpectedResult: 0,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-exponent-positive-negative-exp2\",\n\t\t\tjson:           \"5E-6\",\n\t\t\texpectedResult: 0,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-exponent-positive-negative-exp3\",\n\t\t\tjson:           \"3e-3\",\n\t\t\texpectedResult: 0,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-exponent-positive-negative-exp4\",\n\t\t\tjson:           \"8e-005\",\n\t\t\texpectedResult: 0,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-exponent-negative-positive-exp\",\n\t\t\tjson:           \"-1e2\",\n\t\t\texpectedResult: -100,\n\t\t},\n\t\t{\n\t\t\tname:           \"exponent-err-\",\n\t\t\tjson:           \"0.1e\",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t},\n\t\t{\n\t\t\tname:           \"exponent-err-too-big\",\n\t\t\tjson:           \"0.1e10000000000000000000\",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t},\n\t\t{\n\t\t\tname:           \"exponent-err-too-big\",\n\t\t\tjson:           \"0.1e10000000000 \",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t},\n\t\t{\n\t\t\tname:           \"exponent-err-too-big\",\n\t\t\tjson:           \"0e10000000000 \",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t},\n\t\t{\n\t\t\tname:           \"exponent-err-too-big\",\n\t\t\tjson:           \"0.1932242242424244244e1000000000000000000000000\",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-exponent-negative-positive-exp2\",\n\t\t\tjson:           \"-5e+03\",\n\t\t\texpectedResult: -5000,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-exponent-negative-positive-exp3\",\n\t\t\tjson:           \"-3e03\",\n\t\t\texpectedResult: -3000,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-exponent-negative-positive-exp4\",\n\t\t\tjson:           \"-8e+003\",\n\t\t\texpectedResult: -8000,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-exponent-err\",\n\t\t\tjson:           \"3e\",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-float\",\n\t\t\tjson:           \"8.32 \",\n\t\t\texpectedResult: 8,\n\t\t},\n\t\t{\n\t\t\tname:           \"error\",\n\t\t\tjson:           \"83zez4\",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t\terrType:        InvalidJSONError(\"\"),\n\t\t},\n\t\t{\n\t\t\tname:           \"error\",\n\t\t\tjson:           \"8ea00$aa5\",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t\terrType:        InvalidJSONError(\"\"),\n\t\t},\n\t\t{\n\t\t\tname:           \"error2\",\n\t\t\tjson:           \"-8e+00$aa5\",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t},\n\t\t{\n\t\t\tname:           \"error3\",\n\t\t\tjson:           \"0E40\",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t\terrType:        InvalidJSONError(\"\"),\n\t\t},\n\t\t{\n\t\t\tname:           \"error4\",\n\t\t\tjson:           \"0.E----\",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t\terrType:        InvalidJSONError(\"\"),\n\t\t},\n\t\t{\n\t\t\tname:           \"error5\",\n\t\t\tjson:           \"0E40\",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t\terrType:        InvalidJSONError(\"\"),\n\t\t},\n\t\t{\n\t\t\tname:           \"error6\",\n\t\t\tjson:           \"0.e-9\",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t\terrType:        InvalidJSONError(\"\"),\n\t\t},\n\t\t{\n\t\t\tname:           \"error7\",\n\t\t\tjson:           \"0.e\",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t\terrType:        InvalidJSONError(\"\"),\n\t\t},\n\t\t{\n\t\t\tname:           \"error8\",\n\t\t\tjson:           \"-5.e-2\",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t\terrType:        InvalidJSONError(\"\"),\n\t\t},\n\t\t{\n\t\t\tname:           \"invalid-type\",\n\t\t\tjson:           `\"string\"`,\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t\terrType:        InvalidUnmarshalError(\"\"),\n\t\t},\n\t}\n\tfor _, testCase := range testCases {\n\t\tt.Run(testCase.name, func(t *testing.T) {\n\t\t\tjson := []byte(testCase.json)\n\t\t\tvar v = (*int16)(nil)\n\t\t\terr := Unmarshal(json, &v)\n\t\t\tif testCase.err {\n\t\t\t\tassert.NotNil(t, err, \"Err must not be nil\")\n\t\t\t\tif testCase.errType != nil {\n\t\t\t\t\tassert.IsType(\n\t\t\t\t\t\tt,\n\t\t\t\t\t\ttestCase.errType,\n\t\t\t\t\t\terr,\n\t\t\t\t\t\tfmt.Sprintf(\"err should be of type %s\", reflect.TypeOf(err).String()),\n\t\t\t\t\t)\n\t\t\t\t}\n\t\t\t\treturn\n\t\t\t}\n\t\t\tassert.Nil(t, err, \"Err must be nil\")\n\t\t\tif testCase.resultIsNil {\n\t\t\t\tassert.Nil(t, v)\n\t\t\t} else {\n\t\t\t\tassert.Equal(t, testCase.expectedResult, *v, fmt.Sprintf(\"v must be equal to %d\", testCase.expectedResult))\n\t\t\t}\n\t\t})\n\t}\n\tt.Run(\"decoder-api-invalid-json\", func(t *testing.T) {\n\t\tvar v = new(int16)\n\t\terr := Unmarshal([]byte(``), &v)\n\t\tassert.NotNil(t, err, \"Err must not be nil\")\n\t\tassert.IsType(t, InvalidJSONError(\"\"), err, \"err should be of type InvalidJSONError\")\n\t})\n\tt.Run(\"decoder-api-invalid-json2\", func(t *testing.T) {\n\t\tvar v = new(int16)\n\t\tvar dec = NewDecoder(strings.NewReader(``))\n\t\terr := dec.Int16Null(&v)\n\t\tassert.NotNil(t, err, \"Err must not be nil\")\n\t\tassert.IsType(t, InvalidJSONError(\"\"), err, \"err should be of type InvalidJSONError\")\n\t})\n}\n\nfunc TestDecoderInt8(t *testing.T) {\n\ttestCases := []struct {\n\t\tname           string\n\t\tjson           string\n\t\texpectedResult int8\n\t\terr            bool\n\t\terrType        interface{}\n\t}{\n\t\t{\n\t\t\tname:           \"basic-positive\",\n\t\t\tjson:           \"100\",\n\t\t\texpectedResult: 100,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-positive2\",\n\t\t\tjson:           \" 127\",\n\t\t\texpectedResult: 127,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-negative\",\n\t\t\tjson:           \"-2\",\n\t\t\texpectedResult: -2,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-null\",\n\t\t\tjson:           \"null\",\n\t\t\texpectedResult: 0,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-negative-err\",\n\t\t\tjson:           \"-\",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t\terrType:        InvalidJSONError(\"\"),\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-negative-err\",\n\t\t\tjson:           \"-q\",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t\terrType:        InvalidJSONError(\"\"),\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-null-err\",\n\t\t\tjson:           \"nxll\",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t\terrType:        InvalidJSONError(\"\"),\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-skip-data-err\",\n\t\t\tjson:           \"trua\",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t\terrType:        InvalidJSONError(\"\"),\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-negative2\",\n\t\t\tjson:           \"-123\",\n\t\t\texpectedResult: -123,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-big\",\n\t\t\tjson:           \" 43\",\n\t\t\texpectedResult: 43,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-big-overflow\",\n\t\t\tjson:           \" 2147483648\",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-big-overflow\",\n\t\t\tjson:           \"137\",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-big-overflow\",\n\t\t\tjson:           \"128\",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-big-overflow2\",\n\t\t\tjson:           \"21474836483\",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-float\",\n\t\t\tjson:           \"2.4595\",\n\t\t\texpectedResult: 2,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-float2\",\n\t\t\tjson:           \"-7.8876\",\n\t\t\texpectedResult: -7,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-float2\",\n\t\t\tjson:           \"-7.8876a\",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-exponent-positive-positive-exp\",\n\t\t\tjson:           \"1.2E2\",\n\t\t\texpectedResult: 120,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-exponent-positive-positive-exp1\",\n\t\t\tjson:           \"3.5e+001 \",\n\t\t\texpectedResult: 35,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-exponent-positive-positive-exp1\",\n\t\t\tjson:           \"3.5e+001\",\n\t\t\texpectedResult: 35,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-exponent-positive-positive-exp2\",\n\t\t\tjson:           \"5e+01\",\n\t\t\texpectedResult: 50,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-exponent-positive-negative-exp\",\n\t\t\tjson:           \"1e-2 \",\n\t\t\texpectedResult: 0,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-exponent-positive-negative-exp2\",\n\t\t\tjson:           \"5E-6\",\n\t\t\texpectedResult: 0,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-exponent-positive-negative-exp3\",\n\t\t\tjson:           \"3e-3\",\n\t\t\texpectedResult: 0,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-exponent-positive-negative-exp4\",\n\t\t\tjson:           \"8e-1 \",\n\t\t\texpectedResult: 0,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-exponent-positive-negative-exp4\",\n\t\t\tjson:           \"8e1 \",\n\t\t\texpectedResult: 80,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-exponent-positive-negative-exp4\",\n\t\t\tjson:           \"8e-1\",\n\t\t\texpectedResult: 0,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-exponent-negative-positive-exp\",\n\t\t\tjson:           \"-1e2\",\n\t\t\texpectedResult: -100,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-exponent-negative-positive-exp2\",\n\t\t\tjson:           \"-5e+01\",\n\t\t\texpectedResult: -50,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-exponent-negative-positive-exp3\",\n\t\t\tjson:           \"-3e01\",\n\t\t\texpectedResult: -30,\n\t\t},\n\n\t\t{\n\t\t\tname:           \"error3\",\n\t\t\tjson:           \"0E40\",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t\terrType:        InvalidJSONError(\"\"),\n\t\t},\n\t\t{\n\t\t\tname:           \"exponent-err-\",\n\t\t\tjson:           \"0.1e\",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t},\n\t\t{\n\t\t\tname:           \"before-exp-err-too-big\",\n\t\t\tjson:           \"10.11231242345325435464364643e1\",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t},\n\t\t{\n\t\t\tname:           \"exponent-err-too-big\",\n\t\t\tjson:           \"0.1e10000000000000000000\",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t},\n\t\t{\n\t\t\tname:           \"exponent-err-too-big\",\n\t\t\tjson:           \"0.1932242242424244244e1000000000000000000000000\",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-exponent-negative-positive-exp4\",\n\t\t\tjson:           \"-8e+001\",\n\t\t\texpectedResult: -80,\n\t\t},\n\t\t{\n\t\t\tname:           \"exponent-err-too-big2\",\n\t\t\tjson:           \"0e100 \",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t},\n\t\t{\n\t\t\tname:           \"exponent-err-too-big2\",\n\t\t\tjson:           \"0.1e100 \",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-exponent-err\",\n\t\t\tjson:           \"3e\",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-float\",\n\t\t\tjson:           \"8.32 \",\n\t\t\texpectedResult: 8,\n\t\t},\n\t\t{\n\t\t\tname:           \"error\",\n\t\t\tjson:           \"83zez4\",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t\terrType:        InvalidJSONError(\"\"),\n\t\t},\n\t\t{\n\t\t\tname:           \"error\",\n\t\t\tjson:           \"8ea00$aa5\",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t\terrType:        InvalidJSONError(\"\"),\n\t\t},\n\t\t{\n\t\t\tname:           \"error2\",\n\t\t\tjson:           \"-8e+00$aa5\",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t},\n\t\t{\n\t\t\tname:           \"error4\",\n\t\t\tjson:           \"0.E----\",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t\terrType:        InvalidJSONError(\"\"),\n\t\t},\n\t\t{\n\t\t\tname:           \"error5\",\n\t\t\tjson:           \"0E40\",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t\terrType:        InvalidJSONError(\"\"),\n\t\t},\n\t\t{\n\t\t\tname:           \"error6\",\n\t\t\tjson:           \"0.e-9\",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t\terrType:        InvalidJSONError(\"\"),\n\t\t},\n\t\t{\n\t\t\tname:           \"error7\",\n\t\t\tjson:           \"0.e\",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t\terrType:        InvalidJSONError(\"\"),\n\t\t},\n\t\t{\n\t\t\tname:           \"error8\",\n\t\t\tjson:           \"-5.e-2\",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t\terrType:        InvalidJSONError(\"\"),\n\t\t},\n\t\t{\n\t\t\tname:           \"error8\",\n\t\t\tjson:           \"-5.01e\",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t\terrType:        InvalidJSONError(\"\"),\n\t\t},\n\t\t{\n\t\t\tname:           \"invalid-type\",\n\t\t\tjson:           `\"string\"`,\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t\terrType:        InvalidUnmarshalError(\"\"),\n\t\t},\n\t}\n\tfor _, testCase := range testCases {\n\t\tt.Run(testCase.name, func(t *testing.T) {\n\t\t\tjson := []byte(testCase.json)\n\t\t\tvar v int8\n\t\t\terr := Unmarshal(json, &v)\n\t\t\tif testCase.err {\n\t\t\t\tassert.NotNil(t, err, \"Err must not be nil\")\n\t\t\t\tif testCase.errType != nil {\n\t\t\t\t\tassert.IsType(\n\t\t\t\t\t\tt,\n\t\t\t\t\t\ttestCase.errType,\n\t\t\t\t\t\terr,\n\t\t\t\t\t\tfmt.Sprintf(\"err should be of type %s\", reflect.TypeOf(err).String()),\n\t\t\t\t\t)\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tassert.Nil(t, err, \"Err must be nil\")\n\t\t\t}\n\t\t\tassert.Equal(t, testCase.expectedResult, v, fmt.Sprintf(\"v must be equal to %d\", testCase.expectedResult))\n\t\t})\n\t}\n\tt.Run(\"pool-error\", func(t *testing.T) {\n\t\tresult := int8(1)\n\t\tdec := NewDecoder(nil)\n\t\tdec.Release()\n\t\tdefer func() {\n\t\t\terr := recover()\n\t\t\tassert.NotNil(t, err, \"err shouldnt be nil\")\n\t\t\tassert.IsType(t, InvalidUsagePooledDecoderError(\"\"), err, \"err should be of type InvalidUsagePooledDecoderError\")\n\t\t}()\n\t\t_ = dec.DecodeInt8(&result)\n\t\tassert.True(t, false, \"should not be called as decoder should have panicked\")\n\n\t})\n\tt.Run(\"decoder-api\", func(t *testing.T) {\n\t\tvar v int8\n\t\tdec := NewDecoder(strings.NewReader(`33`))\n\t\tdefer dec.Release()\n\t\terr := dec.DecodeInt8(&v)\n\t\tassert.Nil(t, err, \"Err must be nil\")\n\t\tassert.Equal(t, int8(33), v, \"v must be equal to 33\")\n\t})\n\tt.Run(\"decoder-api2\", func(t *testing.T) {\n\t\tvar v int8\n\t\tdec := NewDecoder(strings.NewReader(`33`))\n\t\tdefer dec.Release()\n\t\terr := dec.Decode(&v)\n\t\tassert.Nil(t, err, \"Err must be nil\")\n\t\tassert.Equal(t, int8(33), v, \"v must be equal to 33\")\n\t})\n\tt.Run(\"decoder-api-invalid-json\", func(t *testing.T) {\n\t\tvar v int8\n\t\tdec := NewDecoder(strings.NewReader(``))\n\t\tdefer dec.Release()\n\t\terr := dec.DecodeInt8(&v)\n\t\tassert.NotNil(t, err, \"Err must not be nil\")\n\t\tassert.IsType(t, InvalidJSONError(\"\"), err, \"err should be of type InvalidJSONError\")\n\t})\n}\nfunc TestDecoderInt8Null(t *testing.T) {\n\ttestCases := []struct {\n\t\tname           string\n\t\tjson           string\n\t\texpectedResult int8\n\t\terr            bool\n\t\terrType        interface{}\n\t\tresultIsNil    bool\n\t}{\n\t\t{\n\t\t\tname:           \"basic-positive\",\n\t\t\tjson:           \"100\",\n\t\t\texpectedResult: 100,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-positive2\",\n\t\t\tjson:           \" 127\",\n\t\t\texpectedResult: 127,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-negative\",\n\t\t\tjson:           \"-2\",\n\t\t\texpectedResult: -2,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-null\",\n\t\t\tjson:           \"null\",\n\t\t\texpectedResult: 0,\n\t\t\tresultIsNil:    true,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-negative-err\",\n\t\t\tjson:           \"-\",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t\terrType:        InvalidJSONError(\"\"),\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-negative-err\",\n\t\t\tjson:           \"-q\",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t\terrType:        InvalidJSONError(\"\"),\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-null-err\",\n\t\t\tjson:           \"nxll\",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t\terrType:        InvalidJSONError(\"\"),\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-skip-data-err\",\n\t\t\tjson:           \"trua\",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t\terrType:        InvalidJSONError(\"\"),\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-negative2\",\n\t\t\tjson:           \"-123\",\n\t\t\texpectedResult: -123,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-big\",\n\t\t\tjson:           \" 43\",\n\t\t\texpectedResult: 43,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-big-overflow\",\n\t\t\tjson:           \" 2147483648\",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-big-overflow\",\n\t\t\tjson:           \"137\",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-big-overflow\",\n\t\t\tjson:           \"128\",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-big-overflow2\",\n\t\t\tjson:           \"21474836483\",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-float\",\n\t\t\tjson:           \"2.4595\",\n\t\t\texpectedResult: 2,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-float2\",\n\t\t\tjson:           \"-7.8876\",\n\t\t\texpectedResult: -7,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-float2\",\n\t\t\tjson:           \"-7.8876a\",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-exponent-positive-positive-exp\",\n\t\t\tjson:           \"1.2E2\",\n\t\t\texpectedResult: 120,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-exponent-positive-positive-exp1\",\n\t\t\tjson:           \"3.5e+001 \",\n\t\t\texpectedResult: 35,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-exponent-positive-positive-exp1\",\n\t\t\tjson:           \"3.5e+001\",\n\t\t\texpectedResult: 35,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-exponent-positive-positive-exp2\",\n\t\t\tjson:           \"5e+01\",\n\t\t\texpectedResult: 50,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-exponent-positive-negative-exp\",\n\t\t\tjson:           \"1e-2 \",\n\t\t\texpectedResult: 0,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-exponent-positive-negative-exp2\",\n\t\t\tjson:           \"5E-6\",\n\t\t\texpectedResult: 0,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-exponent-positive-negative-exp3\",\n\t\t\tjson:           \"3e-3\",\n\t\t\texpectedResult: 0,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-exponent-positive-negative-exp4\",\n\t\t\tjson:           \"8e-1 \",\n\t\t\texpectedResult: 0,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-exponent-positive-negative-exp4\",\n\t\t\tjson:           \"8e1 \",\n\t\t\texpectedResult: 80,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-exponent-positive-negative-exp4\",\n\t\t\tjson:           \"8e-1\",\n\t\t\texpectedResult: 0,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-exponent-negative-positive-exp\",\n\t\t\tjson:           \"-1e2\",\n\t\t\texpectedResult: -100,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-exponent-negative-positive-exp2\",\n\t\t\tjson:           \"-5e+01\",\n\t\t\texpectedResult: -50,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-exponent-negative-positive-exp3\",\n\t\t\tjson:           \"-3e01\",\n\t\t\texpectedResult: -30,\n\t\t},\n\t\t{\n\t\t\tname:           \"error3\",\n\t\t\tjson:           \"0E40\",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t\terrType:        InvalidJSONError(\"\"),\n\t\t},\n\t\t{\n\t\t\tname:           \"exponent-err-\",\n\t\t\tjson:           \"0.1e\",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t},\n\t\t{\n\t\t\tname:           \"exponent-err-too-big\",\n\t\t\tjson:           \"0.1e10000000000000000000\",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t},\n\t\t{\n\t\t\tname:           \"exponent-err-too-big\",\n\t\t\tjson:           \"0.1932242242424244244e1000000000000000000000000\",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-exponent-negative-positive-exp4\",\n\t\t\tjson:           \"-8e+001\",\n\t\t\texpectedResult: -80,\n\t\t},\n\t\t{\n\t\t\tname:           \"exponent-err-too-big2\",\n\t\t\tjson:           \"0e100 \",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t},\n\t\t{\n\t\t\tname:           \"exponent-err-too-big2\",\n\t\t\tjson:           \"0.1e100 \",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-exponent-err\",\n\t\t\tjson:           \"3e\",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-float\",\n\t\t\tjson:           \"8.32 \",\n\t\t\texpectedResult: 8,\n\t\t},\n\t\t{\n\t\t\tname:           \"error\",\n\t\t\tjson:           \"83zez4\",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t\terrType:        InvalidJSONError(\"\"),\n\t\t},\n\t\t{\n\t\t\tname:           \"error\",\n\t\t\tjson:           \"8ea00$aa5\",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t\terrType:        InvalidJSONError(\"\"),\n\t\t},\n\t\t{\n\t\t\tname:           \"error2\",\n\t\t\tjson:           \"-8e+00$aa5\",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t},\n\t\t{\n\t\t\tname:           \"error4\",\n\t\t\tjson:           \"0.E----\",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t\terrType:        InvalidJSONError(\"\"),\n\t\t},\n\t\t{\n\t\t\tname:           \"error5\",\n\t\t\tjson:           \"0E40\",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t\terrType:        InvalidJSONError(\"\"),\n\t\t},\n\t\t{\n\t\t\tname:           \"error6\",\n\t\t\tjson:           \"0.e-9\",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t\terrType:        InvalidJSONError(\"\"),\n\t\t},\n\t\t{\n\t\t\tname:           \"error7\",\n\t\t\tjson:           \"0.e\",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t\terrType:        InvalidJSONError(\"\"),\n\t\t},\n\t\t{\n\t\t\tname:           \"error8\",\n\t\t\tjson:           \"-5.e-2\",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t\terrType:        InvalidJSONError(\"\"),\n\t\t},\n\t\t{\n\t\t\tname:           \"error8\",\n\t\t\tjson:           \"-5.01e\",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t\terrType:        InvalidJSONError(\"\"),\n\t\t},\n\t\t{\n\t\t\tname:           \"invalid-type\",\n\t\t\tjson:           `\"string\"`,\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t\terrType:        InvalidUnmarshalError(\"\"),\n\t\t},\n\t}\n\tfor _, testCase := range testCases {\n\t\tt.Run(testCase.name, func(t *testing.T) {\n\t\t\tjson := []byte(testCase.json)\n\t\t\tvar v = (*int8)(nil)\n\t\t\terr := Unmarshal(json, &v)\n\t\t\tif testCase.err {\n\t\t\t\tassert.NotNil(t, err, \"Err must not be nil\")\n\t\t\t\tif testCase.errType != nil {\n\t\t\t\t\tassert.IsType(\n\t\t\t\t\t\tt,\n\t\t\t\t\t\ttestCase.errType,\n\t\t\t\t\t\terr,\n\t\t\t\t\t\tfmt.Sprintf(\"err should be of type %s\", reflect.TypeOf(err).String()),\n\t\t\t\t\t)\n\t\t\t\t}\n\t\t\t\treturn\n\t\t\t}\n\t\t\tassert.Nil(t, err, \"Err must be nil\")\n\t\t\tif testCase.resultIsNil {\n\t\t\t\tassert.Nil(t, v)\n\t\t\t} else {\n\t\t\t\tassert.Equal(t, testCase.expectedResult, *v, fmt.Sprintf(\"v must be equal to %d\", testCase.expectedResult))\n\t\t\t}\n\t\t})\n\t}\n\tt.Run(\"decoder-api-invalid-json\", func(t *testing.T) {\n\t\tvar v = new(int8)\n\t\terr := Unmarshal([]byte(``), &v)\n\t\tassert.NotNil(t, err, \"Err must not be nil\")\n\t\tassert.IsType(t, InvalidJSONError(\"\"), err, \"err should be of type InvalidJSONError\")\n\t})\n\tt.Run(\"decoder-api-invalid-json2\", func(t *testing.T) {\n\t\tvar v = new(int8)\n\t\tvar dec = NewDecoder(strings.NewReader(``))\n\t\terr := dec.Int8Null(&v)\n\t\tassert.NotNil(t, err, \"Err must not be nil\")\n\t\tassert.IsType(t, InvalidJSONError(\"\"), err, \"err should be of type InvalidJSONError\")\n\t})\n}\n"
        },
        {
          "name": "decode_number_test.go",
          "type": "blob",
          "size": 0.66015625,
          "content": "package gojay\n\nimport (\n\t\"strings\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestDecodeNumberExra(t *testing.T) {\n\tt.Run(\"skip-number-err\", func(t *testing.T) {\n\t\tdec := NewDecoder(strings.NewReader(\"123456afzfz343\"))\n\t\t_, err := dec.skipNumber()\n\t\tassert.NotNil(t, err, \"err should not be nil\")\n\t\tassert.IsType(t, InvalidJSONError(\"\"), err, \"err should be of type InvalidJSONError\")\n\t})\n\tt.Run(\"get-exponent-err\", func(t *testing.T) {\n\t\tv := 0\n\t\tdec := NewDecoder(strings.NewReader(\"1.2Ea\"))\n\t\terr := dec.Decode(&v)\n\t\tassert.NotNil(t, err, \"err should not be nil\")\n\t\tassert.IsType(t, InvalidJSONError(\"\"), err, \"err should be of type InvalidJSONError\")\n\t})\n}\n"
        },
        {
          "name": "decode_number_uint.go",
          "type": "blob",
          "size": 18.07421875,
          "content": "package gojay\n\nimport (\n\t\"math\"\n)\n\n// DecodeUint8 reads the next JSON-encoded value from the decoder's input (io.Reader) and stores it in the uint8 pointed to by v.\n//\n// See the documentation for Unmarshal for details about the conversion of JSON into a Go value.\nfunc (dec *Decoder) DecodeUint8(v *uint8) error {\n\tif dec.isPooled == 1 {\n\t\tpanic(InvalidUsagePooledDecoderError(\"Invalid usage of pooled decoder\"))\n\t}\n\treturn dec.decodeUint8(v)\n}\n\nfunc (dec *Decoder) decodeUint8(v *uint8) error {\n\tfor ; dec.cursor < dec.length || dec.read(); dec.cursor++ {\n\t\tswitch c := dec.data[dec.cursor]; c {\n\t\tcase ' ', '\\n', '\\t', '\\r', ',':\n\t\t\tcontinue\n\t\tcase '0', '1', '2', '3', '4', '5', '6', '7', '8', '9':\n\t\t\tval, err := dec.getUint8()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\t*v = val\n\t\t\treturn nil\n\t\tcase '-': // if negative, we just set it to 0 and set error\n\t\t\tdec.err = dec.makeInvalidUnmarshalErr(v)\n\t\t\terr := dec.skipData()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\treturn nil\n\t\tcase 'n':\n\t\t\tdec.cursor++\n\t\t\terr := dec.assertNull()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\treturn nil\n\t\tdefault:\n\t\t\tdec.err = dec.makeInvalidUnmarshalErr(v)\n\t\t\terr := dec.skipData()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\treturn nil\n\t\t}\n\t}\n\treturn dec.raiseInvalidJSONErr(dec.cursor)\n}\nfunc (dec *Decoder) decodeUint8Null(v **uint8) error {\n\tfor ; dec.cursor < dec.length || dec.read(); dec.cursor++ {\n\t\tswitch c := dec.data[dec.cursor]; c {\n\t\tcase ' ', '\\n', '\\t', '\\r', ',':\n\t\t\tcontinue\n\t\tcase '0', '1', '2', '3', '4', '5', '6', '7', '8', '9':\n\t\t\tval, err := dec.getUint8()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif *v == nil {\n\t\t\t\t*v = new(uint8)\n\t\t\t}\n\t\t\t**v = val\n\t\t\treturn nil\n\t\tcase '-': // if negative, we just set it to 0 and set error\n\t\t\tdec.err = dec.makeInvalidUnmarshalErr(v)\n\t\t\terr := dec.skipData()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif *v == nil {\n\t\t\t\t*v = new(uint8)\n\t\t\t}\n\t\t\treturn nil\n\t\tcase 'n':\n\t\t\tdec.cursor++\n\t\t\terr := dec.assertNull()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\treturn nil\n\t\tdefault:\n\t\t\tdec.err = dec.makeInvalidUnmarshalErr(v)\n\t\t\terr := dec.skipData()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\treturn nil\n\t\t}\n\t}\n\treturn dec.raiseInvalidJSONErr(dec.cursor)\n}\n\nfunc (dec *Decoder) getUint8() (uint8, error) {\n\tvar end = dec.cursor\n\tvar start = dec.cursor\n\t// look for following numbers\n\tfor j := dec.cursor + 1; j < dec.length || dec.read(); j++ {\n\t\tswitch dec.data[j] {\n\t\tcase '0', '1', '2', '3', '4', '5', '6', '7', '8', '9':\n\t\t\tend = j\n\t\t\tcontinue\n\t\tcase ' ', '\\n', '\\t', '\\r':\n\t\t\tcontinue\n\t\tcase '.', ',', '}', ']':\n\t\t\tdec.cursor = j\n\t\t\treturn dec.atoui8(start, end), nil\n\t\t}\n\t\t// invalid json we expect numbers, dot (single one), comma, or spaces\n\t\treturn 0, dec.raiseInvalidJSONErr(dec.cursor)\n\t}\n\treturn dec.atoui8(start, end), nil\n}\n\n// DecodeUint16 reads the next JSON-encoded value from the decoder's input (io.Reader) and stores it in the uint16 pointed to by v.\n//\n// See the documentation for Unmarshal for details about the conversion of JSON into a Go value.\nfunc (dec *Decoder) DecodeUint16(v *uint16) error {\n\tif dec.isPooled == 1 {\n\t\tpanic(InvalidUsagePooledDecoderError(\"Invalid usage of pooled decoder\"))\n\t}\n\treturn dec.decodeUint16(v)\n}\n\nfunc (dec *Decoder) decodeUint16(v *uint16) error {\n\tfor ; dec.cursor < dec.length || dec.read(); dec.cursor++ {\n\t\tswitch c := dec.data[dec.cursor]; c {\n\t\tcase ' ', '\\n', '\\t', '\\r', ',':\n\t\t\tcontinue\n\t\tcase '0', '1', '2', '3', '4', '5', '6', '7', '8', '9':\n\t\t\tval, err := dec.getUint16()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\t*v = val\n\t\t\treturn nil\n\t\tcase '-':\n\t\t\tdec.err = dec.makeInvalidUnmarshalErr(v)\n\t\t\terr := dec.skipData()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\treturn nil\n\t\tcase 'n':\n\t\t\tdec.cursor++\n\t\t\terr := dec.assertNull()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\treturn nil\n\t\tdefault:\n\t\t\tdec.err = dec.makeInvalidUnmarshalErr(v)\n\t\t\terr := dec.skipData()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\treturn nil\n\t\t}\n\t}\n\treturn dec.raiseInvalidJSONErr(dec.cursor)\n}\nfunc (dec *Decoder) decodeUint16Null(v **uint16) error {\n\tfor ; dec.cursor < dec.length || dec.read(); dec.cursor++ {\n\t\tswitch c := dec.data[dec.cursor]; c {\n\t\tcase ' ', '\\n', '\\t', '\\r', ',':\n\t\t\tcontinue\n\t\tcase '0', '1', '2', '3', '4', '5', '6', '7', '8', '9':\n\t\t\tval, err := dec.getUint16()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif *v == nil {\n\t\t\t\t*v = new(uint16)\n\t\t\t}\n\t\t\t**v = val\n\t\t\treturn nil\n\t\tcase '-':\n\t\t\tdec.err = dec.makeInvalidUnmarshalErr(v)\n\t\t\terr := dec.skipData()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif *v == nil {\n\t\t\t\t*v = new(uint16)\n\t\t\t}\n\t\t\treturn nil\n\t\tcase 'n':\n\t\t\tdec.cursor++\n\t\t\terr := dec.assertNull()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\treturn nil\n\t\tdefault:\n\t\t\tdec.err = dec.makeInvalidUnmarshalErr(v)\n\t\t\terr := dec.skipData()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\treturn nil\n\t\t}\n\t}\n\treturn dec.raiseInvalidJSONErr(dec.cursor)\n}\n\nfunc (dec *Decoder) getUint16() (uint16, error) {\n\tvar end = dec.cursor\n\tvar start = dec.cursor\n\t// look for following numbers\n\tfor j := dec.cursor + 1; j < dec.length || dec.read(); j++ {\n\t\tswitch dec.data[j] {\n\t\tcase '0', '1', '2', '3', '4', '5', '6', '7', '8', '9':\n\t\t\tend = j\n\t\t\tcontinue\n\t\tcase ' ', '\\n', '\\t', '\\r':\n\t\t\tcontinue\n\t\tcase '.', ',', '}', ']':\n\t\t\tdec.cursor = j\n\t\t\treturn dec.atoui16(start, end), nil\n\t\t}\n\t\t// invalid json we expect numbers, dot (single one), comma, or spaces\n\t\treturn 0, dec.raiseInvalidJSONErr(dec.cursor)\n\t}\n\treturn dec.atoui16(start, end), nil\n}\n\n// DecodeUint32 reads the next JSON-encoded value from the decoder's input (io.Reader) and stores it in the uint32 pointed to by v.\n//\n// See the documentation for Unmarshal for details about the conversion of JSON into a Go value.\nfunc (dec *Decoder) DecodeUint32(v *uint32) error {\n\tif dec.isPooled == 1 {\n\t\tpanic(InvalidUsagePooledDecoderError(\"Invalid usage of pooled decoder\"))\n\t}\n\treturn dec.decodeUint32(v)\n}\n\nfunc (dec *Decoder) decodeUint32(v *uint32) error {\n\tfor ; dec.cursor < dec.length || dec.read(); dec.cursor++ {\n\t\tswitch c := dec.data[dec.cursor]; c {\n\t\tcase ' ', '\\n', '\\t', '\\r', ',':\n\t\t\tcontinue\n\t\tcase '0', '1', '2', '3', '4', '5', '6', '7', '8', '9':\n\t\t\tval, err := dec.getUint32()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\t*v = val\n\t\t\treturn nil\n\t\tcase '-':\n\t\t\tdec.err = dec.makeInvalidUnmarshalErr(v)\n\t\t\terr := dec.skipData()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\treturn nil\n\t\tcase 'n':\n\t\t\tdec.cursor++\n\t\t\terr := dec.assertNull()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\treturn nil\n\t\tdefault:\n\t\t\tdec.err = dec.makeInvalidUnmarshalErr(v)\n\t\t\terr := dec.skipData()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\treturn nil\n\t\t}\n\t}\n\treturn dec.raiseInvalidJSONErr(dec.cursor)\n}\nfunc (dec *Decoder) decodeUint32Null(v **uint32) error {\n\tfor ; dec.cursor < dec.length || dec.read(); dec.cursor++ {\n\t\tswitch c := dec.data[dec.cursor]; c {\n\t\tcase ' ', '\\n', '\\t', '\\r', ',':\n\t\t\tcontinue\n\t\tcase '0', '1', '2', '3', '4', '5', '6', '7', '8', '9':\n\t\t\tval, err := dec.getUint32()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif *v == nil {\n\t\t\t\t*v = new(uint32)\n\t\t\t}\n\t\t\t**v = val\n\t\t\treturn nil\n\t\tcase '-':\n\t\t\tdec.err = dec.makeInvalidUnmarshalErr(v)\n\t\t\terr := dec.skipData()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif *v == nil {\n\t\t\t\t*v = new(uint32)\n\t\t\t}\n\t\t\treturn nil\n\t\tcase 'n':\n\t\t\tdec.cursor++\n\t\t\terr := dec.assertNull()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\treturn nil\n\t\tdefault:\n\t\t\tdec.err = dec.makeInvalidUnmarshalErr(v)\n\t\t\terr := dec.skipData()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\treturn nil\n\t\t}\n\t}\n\treturn dec.raiseInvalidJSONErr(dec.cursor)\n}\n\nfunc (dec *Decoder) getUint32() (uint32, error) {\n\tvar end = dec.cursor\n\tvar start = dec.cursor\n\t// look for following numbers\n\tfor j := dec.cursor + 1; j < dec.length || dec.read(); j++ {\n\t\tswitch dec.data[j] {\n\t\tcase '0', '1', '2', '3', '4', '5', '6', '7', '8', '9':\n\t\t\tend = j\n\t\t\tcontinue\n\t\tcase ' ', '\\n', '\\t', '\\r':\n\t\t\tcontinue\n\t\tcase '.', ',', '}', ']':\n\t\t\tdec.cursor = j\n\t\t\treturn dec.atoui32(start, end), nil\n\t\t}\n\t\t// invalid json we expect numbers, dot (single one), comma, or spaces\n\t\treturn 0, dec.raiseInvalidJSONErr(dec.cursor)\n\t}\n\treturn dec.atoui32(start, end), nil\n}\n\n// DecodeUint64 reads the next JSON-encoded value from the decoder's input (io.Reader) and stores it in the uint64 pointed to by v.\n//\n// See the documentation for Unmarshal for details about the conversion of JSON into a Go value.\nfunc (dec *Decoder) DecodeUint64(v *uint64) error {\n\tif dec.isPooled == 1 {\n\t\tpanic(InvalidUsagePooledDecoderError(\"Invalid usage of pooled decoder\"))\n\t}\n\treturn dec.decodeUint64(v)\n}\nfunc (dec *Decoder) decodeUint64(v *uint64) error {\n\tfor ; dec.cursor < dec.length || dec.read(); dec.cursor++ {\n\t\tswitch c := dec.data[dec.cursor]; c {\n\t\tcase ' ', '\\n', '\\t', '\\r', ',':\n\t\t\tcontinue\n\t\tcase '0', '1', '2', '3', '4', '5', '6', '7', '8', '9':\n\t\t\tval, err := dec.getUint64()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\t*v = val\n\t\t\treturn nil\n\t\tcase '-':\n\t\t\tdec.err = dec.makeInvalidUnmarshalErr(v)\n\t\t\terr := dec.skipData()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\treturn nil\n\t\tcase 'n':\n\t\t\tdec.cursor++\n\t\t\terr := dec.assertNull()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\treturn nil\n\t\tdefault:\n\t\t\tdec.err = dec.makeInvalidUnmarshalErr(v)\n\t\t\terr := dec.skipData()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\treturn nil\n\t\t}\n\t}\n\treturn dec.raiseInvalidJSONErr(dec.cursor)\n}\nfunc (dec *Decoder) decodeUint64Null(v **uint64) error {\n\tfor ; dec.cursor < dec.length || dec.read(); dec.cursor++ {\n\t\tswitch c := dec.data[dec.cursor]; c {\n\t\tcase ' ', '\\n', '\\t', '\\r', ',':\n\t\t\tcontinue\n\t\tcase '0', '1', '2', '3', '4', '5', '6', '7', '8', '9':\n\t\t\tval, err := dec.getUint64()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif *v == nil {\n\t\t\t\t*v = new(uint64)\n\t\t\t}\n\t\t\t**v = val\n\t\t\treturn nil\n\t\tcase '-':\n\t\t\tdec.err = dec.makeInvalidUnmarshalErr(v)\n\t\t\terr := dec.skipData()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif *v == nil {\n\t\t\t\t*v = new(uint64)\n\t\t\t}\n\t\t\treturn nil\n\t\tcase 'n':\n\t\t\tdec.cursor++\n\t\t\terr := dec.assertNull()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\treturn nil\n\t\tdefault:\n\t\t\tdec.err = dec.makeInvalidUnmarshalErr(v)\n\t\t\terr := dec.skipData()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\treturn nil\n\t\t}\n\t}\n\treturn dec.raiseInvalidJSONErr(dec.cursor)\n}\n\nfunc (dec *Decoder) getUint64() (uint64, error) {\n\tvar end = dec.cursor\n\tvar start = dec.cursor\n\t// look for following numbers\n\tfor j := dec.cursor + 1; j < dec.length || dec.read(); j++ {\n\t\tswitch dec.data[j] {\n\t\tcase '0', '1', '2', '3', '4', '5', '6', '7', '8', '9':\n\t\t\tend = j\n\t\t\tcontinue\n\t\tcase ' ', '\\n', '\\t', '\\r', '.', ',', '}', ']':\n\t\t\tdec.cursor = j\n\t\t\treturn dec.atoui64(start, end), nil\n\t\t}\n\t\t// invalid json we expect numbers, dot (single one), comma, or spaces\n\t\treturn 0, dec.raiseInvalidJSONErr(dec.cursor)\n\t}\n\treturn dec.atoui64(start, end), nil\n}\n\nfunc (dec *Decoder) atoui64(start, end int) uint64 {\n\tvar ll = end + 1 - start\n\tvar val = uint64(digits[dec.data[start]])\n\tend = end + 1\n\tif ll < maxUint64Length {\n\t\tfor i := start + 1; i < end; i++ {\n\t\t\tuintv := uint64(digits[dec.data[i]])\n\t\t\tval = (val << 3) + (val << 1) + uintv\n\t\t}\n\t} else if ll == maxUint64Length {\n\t\tfor i := start + 1; i < end; i++ {\n\t\t\tuintv := uint64(digits[dec.data[i]])\n\t\t\tif val > maxUint64toMultiply {\n\t\t\t\tdec.err = dec.makeInvalidUnmarshalErr(val)\n\t\t\t\treturn 0\n\t\t\t}\n\t\t\tval = (val << 3) + (val << 1)\n\t\t\tif math.MaxUint64-val < uintv {\n\t\t\t\tdec.err = dec.makeInvalidUnmarshalErr(val)\n\t\t\t\treturn 0\n\t\t\t}\n\t\t\tval += uintv\n\t\t}\n\t} else {\n\t\tdec.err = dec.makeInvalidUnmarshalErr(val)\n\t\treturn 0\n\t}\n\treturn val\n}\n\nfunc (dec *Decoder) atoui32(start, end int) uint32 {\n\tvar ll = end + 1 - start\n\tvar val uint32\n\tval = uint32(digits[dec.data[start]])\n\tend = end + 1\n\tif ll < maxUint32Length {\n\t\tfor i := start + 1; i < end; i++ {\n\t\t\tuintv := uint32(digits[dec.data[i]])\n\t\t\tval = (val << 3) + (val << 1) + uintv\n\t\t}\n\t} else if ll == maxUint32Length {\n\t\tfor i := start + 1; i < end; i++ {\n\t\t\tuintv := uint32(digits[dec.data[i]])\n\t\t\tif val > maxUint32toMultiply {\n\t\t\t\tdec.err = dec.makeInvalidUnmarshalErr(val)\n\t\t\t\treturn 0\n\t\t\t}\n\t\t\tval = (val << 3) + (val << 1)\n\t\t\tif math.MaxUint32-val < uintv {\n\t\t\t\tdec.err = dec.makeInvalidUnmarshalErr(val)\n\t\t\t\treturn 0\n\t\t\t}\n\t\t\tval += uintv\n\t\t}\n\t} else if ll > maxUint32Length {\n\t\tdec.err = dec.makeInvalidUnmarshalErr(val)\n\t\tval = 0\n\t}\n\treturn val\n}\n\nfunc (dec *Decoder) atoui16(start, end int) uint16 {\n\tvar ll = end + 1 - start\n\tvar val uint16\n\tval = uint16(digits[dec.data[start]])\n\tend = end + 1\n\tif ll < maxUint16Length {\n\t\tfor i := start + 1; i < end; i++ {\n\t\t\tuintv := uint16(digits[dec.data[i]])\n\t\t\tval = (val << 3) + (val << 1) + uintv\n\t\t}\n\t} else if ll == maxUint16Length {\n\t\tfor i := start + 1; i < end; i++ {\n\t\t\tuintv := uint16(digits[dec.data[i]])\n\t\t\tif val > maxUint16toMultiply {\n\t\t\t\tdec.err = dec.makeInvalidUnmarshalErr(val)\n\t\t\t\treturn 0\n\t\t\t}\n\t\t\tval = (val << 3) + (val << 1)\n\t\t\tif math.MaxUint16-val < uintv {\n\t\t\t\tdec.err = dec.makeInvalidUnmarshalErr(val)\n\t\t\t\treturn 0\n\t\t\t}\n\t\t\tval += uintv\n\t\t}\n\t} else if ll > maxUint16Length {\n\t\tdec.err = dec.makeInvalidUnmarshalErr(val)\n\t\tval = 0\n\t}\n\treturn val\n}\n\nfunc (dec *Decoder) atoui8(start, end int) uint8 {\n\tvar ll = end + 1 - start\n\tvar val uint8\n\tval = uint8(digits[dec.data[start]])\n\tend = end + 1\n\tif ll < maxUint8Length {\n\t\tfor i := start + 1; i < end; i++ {\n\t\t\tuintv := uint8(digits[dec.data[i]])\n\t\t\tval = (val << 3) + (val << 1) + uintv\n\t\t}\n\t} else if ll == maxUint8Length {\n\t\tfor i := start + 1; i < end; i++ {\n\t\t\tuintv := uint8(digits[dec.data[i]])\n\t\t\tif val > maxUint8toMultiply {\n\t\t\t\tdec.err = dec.makeInvalidUnmarshalErr(val)\n\t\t\t\treturn 0\n\t\t\t}\n\t\t\tval = (val << 3) + (val << 1)\n\t\t\tif math.MaxUint8-val < uintv {\n\t\t\t\tdec.err = dec.makeInvalidUnmarshalErr(val)\n\t\t\t\treturn 0\n\t\t\t}\n\t\t\tval += uintv\n\t\t}\n\t} else if ll > maxUint8Length {\n\t\tdec.err = dec.makeInvalidUnmarshalErr(val)\n\t\tval = 0\n\t}\n\treturn val\n}\n\n// Add Values functions\n\n// AddUint8 decodes the JSON value within an object or an array to an *int.\n// If next key value overflows uint8, an InvalidUnmarshalError error will be returned.\nfunc (dec *Decoder) AddUint8(v *uint8) error {\n\treturn dec.Uint8(v)\n}\n\n// AddUint8Null decodes the JSON value within an object or an array to an *int.\n// If next key value overflows uint8, an InvalidUnmarshalError error will be returned.\n// If a `null` is encountered, gojay does not change the value of the pointer.\nfunc (dec *Decoder) AddUint8Null(v **uint8) error {\n\treturn dec.Uint8Null(v)\n}\n\n// AddUint16 decodes the JSON value within an object or an array to an *int.\n// If next key value overflows uint16, an InvalidUnmarshalError error will be returned.\nfunc (dec *Decoder) AddUint16(v *uint16) error {\n\treturn dec.Uint16(v)\n}\n\n// AddUint16Null decodes the JSON value within an object or an array to an *int.\n// If next key value overflows uint16, an InvalidUnmarshalError error will be returned.\n// If a `null` is encountered, gojay does not change the value of the pointer.\nfunc (dec *Decoder) AddUint16Null(v **uint16) error {\n\treturn dec.Uint16Null(v)\n}\n\n// AddUint32 decodes the JSON value within an object or an array to an *int.\n// If next key value overflows uint32, an InvalidUnmarshalError error will be returned.\nfunc (dec *Decoder) AddUint32(v *uint32) error {\n\treturn dec.Uint32(v)\n}\n\n// AddUint32Null decodes the JSON value within an object or an array to an *int.\n// If next key value overflows uint32, an InvalidUnmarshalError error will be returned.\n// If a `null` is encountered, gojay does not change the value of the pointer.\nfunc (dec *Decoder) AddUint32Null(v **uint32) error {\n\treturn dec.Uint32Null(v)\n}\n\n// AddUint64 decodes the JSON value within an object or an array to an *int.\n// If next key value overflows uint64, an InvalidUnmarshalError error will be returned.\nfunc (dec *Decoder) AddUint64(v *uint64) error {\n\treturn dec.Uint64(v)\n}\n\n// AddUint64Null decodes the JSON value within an object or an array to an *int.\n// If next key value overflows uint64, an InvalidUnmarshalError error will be returned.\n// If a `null` is encountered, gojay does not change the value of the pointer.\nfunc (dec *Decoder) AddUint64Null(v **uint64) error {\n\treturn dec.Uint64Null(v)\n}\n\n// Uint8 decodes the JSON value within an object or an array to an *int.\n// If next key value overflows uint8, an InvalidUnmarshalError error will be returned.\nfunc (dec *Decoder) Uint8(v *uint8) error {\n\terr := dec.decodeUint8(v)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdec.called |= 1\n\treturn nil\n}\n\n// Uint8Null decodes the JSON value within an object or an array to an *int.\n// If next key value overflows uint8, an InvalidUnmarshalError error will be returned.\nfunc (dec *Decoder) Uint8Null(v **uint8) error {\n\terr := dec.decodeUint8Null(v)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdec.called |= 1\n\treturn nil\n}\n\n// Uint16 decodes the JSON value within an object or an array to an *int.\n// If next key value overflows uint16, an InvalidUnmarshalError error will be returned.\nfunc (dec *Decoder) Uint16(v *uint16) error {\n\terr := dec.decodeUint16(v)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdec.called |= 1\n\treturn nil\n}\n\n// Uint16Null decodes the JSON value within an object or an array to an *int.\n// If next key value overflows uint16, an InvalidUnmarshalError error will be returned.\nfunc (dec *Decoder) Uint16Null(v **uint16) error {\n\terr := dec.decodeUint16Null(v)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdec.called |= 1\n\treturn nil\n}\n\n// Uint32 decodes the JSON value within an object or an array to an *int.\n// If next key value overflows uint32, an InvalidUnmarshalError error will be returned.\nfunc (dec *Decoder) Uint32(v *uint32) error {\n\terr := dec.decodeUint32(v)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdec.called |= 1\n\treturn nil\n}\n\n// Uint32Null decodes the JSON value within an object or an array to an *int.\n// If next key value overflows uint32, an InvalidUnmarshalError error will be returned.\nfunc (dec *Decoder) Uint32Null(v **uint32) error {\n\terr := dec.decodeUint32Null(v)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdec.called |= 1\n\treturn nil\n}\n\n// Uint64 decodes the JSON value within an object or an array to an *int.\n// If next key value overflows uint64, an InvalidUnmarshalError error will be returned.\nfunc (dec *Decoder) Uint64(v *uint64) error {\n\terr := dec.decodeUint64(v)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdec.called |= 1\n\treturn nil\n}\n\n// Uint64Null decodes the JSON value within an object or an array to an *int.\n// If next key value overflows uint64, an InvalidUnmarshalError error will be returned.\nfunc (dec *Decoder) Uint64Null(v **uint64) error {\n\terr := dec.decodeUint64Null(v)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdec.called |= 1\n\treturn nil\n}\n"
        },
        {
          "name": "decode_number_uint_test.go",
          "type": "blob",
          "size": 31.48046875,
          "content": "package gojay\n\nimport (\n\t\"fmt\"\n\t\"reflect\"\n\t\"strings\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestDecoderUint64(t *testing.T) {\n\ttestCases := []struct {\n\t\tname           string\n\t\tjson           string\n\t\texpectedResult uint64\n\t\terr            bool\n\t\terrType        interface{}\n\t}{\n\t\t{\n\t\t\tname:           \"basic-positive\",\n\t\t\tjson:           \"100\",\n\t\t\texpectedResult: 100,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-positive2\",\n\t\t\tjson:           \" 1039405\",\n\t\t\texpectedResult: 1039405,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-negative\",\n\t\t\tjson:           \"-2\",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-null\",\n\t\t\tjson:           \"null\",\n\t\t\texpectedResult: 0,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-null-err\",\n\t\t\tjson:           \"nxll\",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t\terrType:        InvalidJSONError(\"\"),\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-skip-data-err\",\n\t\t\tjson:           \"trua\",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t\terrType:        InvalidJSONError(\"\"),\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-big\",\n\t\t\tjson:           \"18446744073709551615\",\n\t\t\texpectedResult: 18446744073709551615,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-big-overflow\",\n\t\t\tjson:           \"18446744073709551616\",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-big-overflow\",\n\t\t\tjson:           \"18446744073709551625\",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-big-overflow2\",\n\t\t\tjson:           \"184467440737095516161\",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-negative2\",\n\t\t\tjson:           \"-2349557\",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-float\",\n\t\t\tjson:           \"2.4595\",\n\t\t\texpectedResult: 2,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-float2\",\n\t\t\tjson:           \"-7.8876\",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t},\n\t\t{\n\t\t\tname:           \"error1\",\n\t\t\tjson:           \"132zz4\",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t},\n\t\t{\n\t\t\tname:           \"error\",\n\t\t\tjson:           \"-83zez4\",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t\terrType:        InvalidJSONError(\"\"),\n\t\t},\n\t\t{\n\t\t\tname:           \"invalid-type\",\n\t\t\tjson:           `\"string\"`,\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t\terrType:        InvalidUnmarshalError(\"\"),\n\t\t},\n\t}\n\tfor _, testCase := range testCases {\n\t\tt.Run(testCase.name, func(t *testing.T) {\n\t\t\tjson := []byte(testCase.json)\n\t\t\tvar v uint64\n\t\t\terr := Unmarshal(json, &v)\n\t\t\tif testCase.err {\n\t\t\t\tassert.NotNil(t, err, \"Err must not be nil\")\n\t\t\t\tif testCase.errType != nil {\n\t\t\t\t\tassert.IsType(\n\t\t\t\t\t\tt,\n\t\t\t\t\t\ttestCase.errType,\n\t\t\t\t\t\terr,\n\t\t\t\t\t\tfmt.Sprintf(\"err should be of type %s\", reflect.TypeOf(err).String()),\n\t\t\t\t\t)\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tassert.Nil(t, err, \"Err must be nil\")\n\t\t\t}\n\t\t\tassert.Equal(t, testCase.expectedResult, v, fmt.Sprintf(\"v must be equal to %d\", testCase.expectedResult))\n\t\t})\n\t}\n\tt.Run(\"pool-error\", func(t *testing.T) {\n\t\tresult := uint64(1)\n\t\tdec := NewDecoder(nil)\n\t\tdec.Release()\n\t\tdefer func() {\n\t\t\terr := recover()\n\t\t\tassert.NotNil(t, err, \"err shouldnt be nil\")\n\t\t\tassert.IsType(t, InvalidUsagePooledDecoderError(\"\"), err, \"err should be of type InvalidUsagePooledDecoderError\")\n\t\t}()\n\t\t_ = dec.DecodeUint64(&result)\n\t\tassert.True(t, false, \"should not be called as decoder should have panicked\")\n\t})\n\tt.Run(\"decoder-api\", func(t *testing.T) {\n\t\tvar v uint64\n\t\tdec := NewDecoder(strings.NewReader(`33`))\n\t\tdefer dec.Release()\n\t\terr := dec.DecodeUint64(&v)\n\t\tassert.Nil(t, err, \"Err must be nil\")\n\t\tassert.Equal(t, uint64(33), v, \"v must be equal to 33\")\n\t})\n\tt.Run(\"decoder-api-json-error\", func(t *testing.T) {\n\t\tvar v uint64\n\t\tdec := NewDecoder(strings.NewReader(``))\n\t\tdefer dec.Release()\n\t\terr := dec.DecodeUint64(&v)\n\t\tassert.NotNil(t, err, \"Err must not be nil\")\n\t\tassert.IsType(t, InvalidJSONError(\"\"), err, \"err should be of type InvalidJSONError\")\n\t})\n}\nfunc TestDecoderUint64Null(t *testing.T) {\n\ttestCases := []struct {\n\t\tname           string\n\t\tjson           string\n\t\texpectedResult uint64\n\t\terr            bool\n\t\terrType        interface{}\n\t\tresultIsNil    bool\n\t}{\n\t\t{\n\t\t\tname:           \"basic-positive\",\n\t\t\tjson:           \"100\",\n\t\t\texpectedResult: 100,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-positive2\",\n\t\t\tjson:           \" 1039405\",\n\t\t\texpectedResult: 1039405,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-negative\",\n\t\t\tjson:           \"-2\",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-null\",\n\t\t\tjson:           \"null\",\n\t\t\texpectedResult: 0,\n\t\t\tresultIsNil:    true,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-null-err\",\n\t\t\tjson:           \"nxll\",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t\terrType:        InvalidJSONError(\"\"),\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-skip-data-err\",\n\t\t\tjson:           \"trua\",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t\terrType:        InvalidJSONError(\"\"),\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-big\",\n\t\t\tjson:           \"18446744073709551615\",\n\t\t\texpectedResult: 18446744073709551615,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-big-overflow\",\n\t\t\tjson:           \"18446744073709551616\",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-big-overflow\",\n\t\t\tjson:           \"18446744073709551625\",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-big-overflow2\",\n\t\t\tjson:           \"184467440737095516161\",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-negative2\",\n\t\t\tjson:           \"-2349557\",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-float\",\n\t\t\tjson:           \"2.4595\",\n\t\t\texpectedResult: 2,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-float2\",\n\t\t\tjson:           \"-7.8876\",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t},\n\t\t{\n\t\t\tname:           \"error1\",\n\t\t\tjson:           \"132zz4\",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t},\n\t\t{\n\t\t\tname:           \"error\",\n\t\t\tjson:           \"-83zez4\",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t\terrType:        InvalidJSONError(\"\"),\n\t\t},\n\t\t{\n\t\t\tname:           \"invalid-type\",\n\t\t\tjson:           `\"string\"`,\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t\terrType:        InvalidUnmarshalError(\"\"),\n\t\t},\n\t}\n\tfor _, testCase := range testCases {\n\t\tt.Run(testCase.name, func(t *testing.T) {\n\t\t\tjson := []byte(testCase.json)\n\t\t\tvar v = (*uint64)(nil)\n\t\t\terr := Unmarshal(json, &v)\n\t\t\tif testCase.err {\n\t\t\t\tassert.NotNil(t, err, \"Err must not be nil\")\n\t\t\t\tif testCase.errType != nil {\n\t\t\t\t\tassert.IsType(\n\t\t\t\t\t\tt,\n\t\t\t\t\t\ttestCase.errType,\n\t\t\t\t\t\terr,\n\t\t\t\t\t\tfmt.Sprintf(\"err should be of type %s\", reflect.TypeOf(err).String()),\n\t\t\t\t\t)\n\t\t\t\t}\n\t\t\t\treturn\n\t\t\t}\n\t\t\tassert.Nil(t, err, \"Err must be nil\")\n\t\t\tif testCase.resultIsNil {\n\t\t\t\tassert.Nil(t, v)\n\t\t\t} else {\n\t\t\t\tassert.Equal(t, testCase.expectedResult, *v, fmt.Sprintf(\"v must be equal to %d\", testCase.expectedResult))\n\t\t\t}\n\t\t})\n\t}\n\tt.Run(\"decoder-api-invalid-json\", func(t *testing.T) {\n\t\tvar v = new(uint64)\n\t\terr := Unmarshal([]byte(``), &v)\n\t\tassert.NotNil(t, err, \"Err must not be nil\")\n\t\tassert.IsType(t, InvalidJSONError(\"\"), err, \"err should be of type InvalidJSONError\")\n\t})\n\tt.Run(\"decoder-api-invalid-json2\", func(t *testing.T) {\n\t\tvar v = new(uint64)\n\t\tvar dec = NewDecoder(strings.NewReader(``))\n\t\terr := dec.Uint64Null(&v)\n\t\tassert.NotNil(t, err, \"Err must not be nil\")\n\t\tassert.IsType(t, InvalidJSONError(\"\"), err, \"err should be of type InvalidJSONError\")\n\t})\n}\n\nfunc TestDecoderUint32(t *testing.T) {\n\ttestCases := []struct {\n\t\tname           string\n\t\tjson           string\n\t\texpectedResult uint32\n\t\terr            bool\n\t\terrType        interface{}\n\t}{\n\t\t{\n\t\t\tname:           \"basic-positive\",\n\t\t\tjson:           \"100\",\n\t\t\texpectedResult: 100,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-positive2\",\n\t\t\tjson:           \" 1039405 \",\n\t\t\texpectedResult: 1039405,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-negative\",\n\t\t\tjson:           \"-2\",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-null\",\n\t\t\tjson:           \"null\",\n\t\t\texpectedResult: 0,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-null-err\",\n\t\t\tjson:           \"nxll\",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t\terrType:        InvalidJSONError(\"\"),\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-skip-data-err\",\n\t\t\tjson:           \"trua\",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t\terrType:        InvalidJSONError(\"\"),\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-negative2\",\n\t\t\tjson:           \"-2349557\",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-big\",\n\t\t\tjson:           \"4294967295\",\n\t\t\texpectedResult: 4294967295,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-big-overflow\",\n\t\t\tjson:           \" 4294967298\",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-big-overflow\",\n\t\t\tjson:           \"4294967395\",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-big-overflow2\",\n\t\t\tjson:           \"42949672983\",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-float\",\n\t\t\tjson:           \"2.4595\",\n\t\t\texpectedResult: 2,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-float2\",\n\t\t\tjson:           \"-7.8876\",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t},\n\t\t{\n\t\t\tname:           \"error\",\n\t\t\tjson:           \"83zez4\",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t\terrType:        InvalidJSONError(\"\"),\n\t\t},\n\t\t{\n\t\t\tname:           \"error\",\n\t\t\tjson:           \"-83zez4\",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t\terrType:        InvalidJSONError(\"\"),\n\t\t},\n\t\t{\n\t\t\tname:           \"invalid-type\",\n\t\t\tjson:           `\"string\"`,\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t\terrType:        InvalidUnmarshalError(\"\"),\n\t\t},\n\t\t{\n\t\t\tname:           \"invalid-json\",\n\t\t\tjson:           `123invalid`,\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t\terrType:        InvalidJSONError(\"\"),\n\t\t},\n\t}\n\tfor _, testCase := range testCases {\n\t\tt.Run(testCase.name, func(t *testing.T) {\n\t\t\tjson := []byte(testCase.json)\n\t\t\tvar v uint32\n\t\t\terr := Unmarshal(json, &v)\n\t\t\tif testCase.err {\n\t\t\t\tassert.NotNil(t, err, \"Err must not be nil\")\n\t\t\t\tif testCase.errType != nil {\n\t\t\t\t\tassert.IsType(\n\t\t\t\t\t\tt,\n\t\t\t\t\t\ttestCase.errType,\n\t\t\t\t\t\terr,\n\t\t\t\t\t\tfmt.Sprintf(\"err should be of type %s\", reflect.TypeOf(err).String()),\n\t\t\t\t\t)\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tassert.Nil(t, err, \"Err must be nil\")\n\t\t\t}\n\t\t\tassert.Equal(t, testCase.expectedResult, v, fmt.Sprintf(\"v must be equal to %d\", testCase.expectedResult))\n\t\t})\n\t}\n\tt.Run(\"pool-error\", func(t *testing.T) {\n\t\tresult := uint32(1)\n\t\tdec := NewDecoder(nil)\n\t\tdec.Release()\n\t\tdefer func() {\n\t\t\terr := recover()\n\t\t\tassert.NotNil(t, err, \"err shouldnt be nil\")\n\t\t\tassert.IsType(t, InvalidUsagePooledDecoderError(\"\"), err, \"err should be of type InvalidUsagePooledDecoderError\")\n\t\t}()\n\t\t_ = dec.DecodeUint32(&result)\n\t\tassert.True(t, false, \"should not be called as decoder should have panicked\")\n\t})\n\tt.Run(\"decoder-api\", func(t *testing.T) {\n\t\tvar v uint32\n\t\tdec := NewDecoder(strings.NewReader(`33`))\n\t\tdefer dec.Release()\n\t\terr := dec.DecodeUint32(&v)\n\t\tassert.Nil(t, err, \"Err must be nil\")\n\t\tassert.Equal(t, uint32(33), v, \"v must be equal to 33\")\n\t})\n\tt.Run(\"decoder-api-json-error\", func(t *testing.T) {\n\t\tvar v uint32\n\t\tdec := NewDecoder(strings.NewReader(``))\n\t\tdefer dec.Release()\n\t\terr := dec.DecodeUint32(&v)\n\t\tassert.NotNil(t, err, \"Err must not be nil\")\n\t\tassert.IsType(t, InvalidJSONError(\"\"), err, \"err should be of type InvalidJSONError\")\n\t})\n}\nfunc TestDecoderUint32Null(t *testing.T) {\n\ttestCases := []struct {\n\t\tname           string\n\t\tjson           string\n\t\texpectedResult uint32\n\t\terr            bool\n\t\terrType        interface{}\n\t\tresultIsNil    bool\n\t}{\n\t\t{\n\t\t\tname:           \"basic-positive\",\n\t\t\tjson:           \"100\",\n\t\t\texpectedResult: 100,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-positive2\",\n\t\t\tjson:           \" 1039405 \",\n\t\t\texpectedResult: 1039405,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-negative\",\n\t\t\tjson:           \"-2\",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-null\",\n\t\t\tjson:           \"null\",\n\t\t\texpectedResult: 0,\n\t\t\tresultIsNil:    true,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-null-err\",\n\t\t\tjson:           \"nxll\",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t\terrType:        InvalidJSONError(\"\"),\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-skip-data-err\",\n\t\t\tjson:           \"trua\",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t\terrType:        InvalidJSONError(\"\"),\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-negative2\",\n\t\t\tjson:           \"-2349557\",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-big\",\n\t\t\tjson:           \"4294967295\",\n\t\t\texpectedResult: 4294967295,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-big-overflow\",\n\t\t\tjson:           \" 4294967298\",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-big-overflow\",\n\t\t\tjson:           \"4294967395\",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-big-overflow2\",\n\t\t\tjson:           \"42949672983\",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-float\",\n\t\t\tjson:           \"2.4595\",\n\t\t\texpectedResult: 2,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-float2\",\n\t\t\tjson:           \"-7.8876\",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t},\n\t\t{\n\t\t\tname:           \"error\",\n\t\t\tjson:           \"83zez4\",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t\terrType:        InvalidJSONError(\"\"),\n\t\t},\n\t\t{\n\t\t\tname:           \"error\",\n\t\t\tjson:           \"-83zez4\",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t\terrType:        InvalidJSONError(\"\"),\n\t\t},\n\t\t{\n\t\t\tname:           \"invalid-type\",\n\t\t\tjson:           `\"string\"`,\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t\terrType:        InvalidUnmarshalError(\"\"),\n\t\t},\n\t\t{\n\t\t\tname:           \"invalid-json\",\n\t\t\tjson:           `123invalid`,\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t\terrType:        InvalidJSONError(\"\"),\n\t\t},\n\t}\n\tfor _, testCase := range testCases {\n\t\tt.Run(testCase.name, func(t *testing.T) {\n\t\t\tjson := []byte(testCase.json)\n\t\t\tvar v = (*uint32)(nil)\n\t\t\terr := Unmarshal(json, &v)\n\t\t\tif testCase.err {\n\t\t\t\tassert.NotNil(t, err, \"Err must not be nil\")\n\t\t\t\tif testCase.errType != nil {\n\t\t\t\t\tassert.IsType(\n\t\t\t\t\t\tt,\n\t\t\t\t\t\ttestCase.errType,\n\t\t\t\t\t\terr,\n\t\t\t\t\t\tfmt.Sprintf(\"err should be of type %s\", reflect.TypeOf(err).String()),\n\t\t\t\t\t)\n\t\t\t\t}\n\t\t\t\treturn\n\t\t\t}\n\t\t\tassert.Nil(t, err, \"Err must be nil\")\n\t\t\tif testCase.resultIsNil {\n\t\t\t\tassert.Nil(t, v)\n\t\t\t} else {\n\t\t\t\tassert.Equal(t, testCase.expectedResult, *v, fmt.Sprintf(\"v must be equal to %d\", testCase.expectedResult))\n\t\t\t}\n\t\t})\n\t}\n\tt.Run(\"decoder-api-invalid-json\", func(t *testing.T) {\n\t\tvar v = new(uint32)\n\t\terr := Unmarshal([]byte(``), &v)\n\t\tassert.NotNil(t, err, \"Err must not be nil\")\n\t\tassert.IsType(t, InvalidJSONError(\"\"), err, \"err should be of type InvalidJSONError\")\n\t})\n\tt.Run(\"decoder-api-invalid-json2\", func(t *testing.T) {\n\t\tvar v = new(uint32)\n\t\tvar dec = NewDecoder(strings.NewReader(``))\n\t\terr := dec.Uint32Null(&v)\n\t\tassert.NotNil(t, err, \"Err must not be nil\")\n\t\tassert.IsType(t, InvalidJSONError(\"\"), err, \"err should be of type InvalidJSONError\")\n\t})\n}\n\nfunc TestDecoderUint16(t *testing.T) {\n\ttestCases := []struct {\n\t\tname           string\n\t\tjson           string\n\t\texpectedResult uint16\n\t\terr            bool\n\t\terrType        interface{}\n\t}{\n\t\t{\n\t\t\tname:           \"basic-positive\",\n\t\t\tjson:           \"100\",\n\t\t\texpectedResult: 100,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-positive2\",\n\t\t\tjson:           \" 3224 \",\n\t\t\texpectedResult: 3224,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-negative\",\n\t\t\tjson:           \"-2\",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-null\",\n\t\t\tjson:           \"null\",\n\t\t\texpectedResult: 0,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-null-err\",\n\t\t\tjson:           \"nxll\",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t\terrType:        InvalidJSONError(\"\"),\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-skip-data-err\",\n\t\t\tjson:           \"trua\",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t\terrType:        InvalidJSONError(\"\"),\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-skip-data-err\",\n\t\t\tjson:           \"trua\",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t\terrType:        InvalidJSONError(\"\"),\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-overflow\",\n\t\t\tjson:           \"335346564\",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t\terrType:        InvalidUnmarshalError(\"\"),\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-negative2\",\n\t\t\tjson:           \"-24467\",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-big\",\n\t\t\tjson:           \"54546\",\n\t\t\texpectedResult: 54546,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-big-overflow\",\n\t\t\tjson:           \" 4294967298\",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-big-overflow\",\n\t\t\tjson:           \" 65537\",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-big-overflow\",\n\t\t\tjson:           \" 66537\",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-big-overflow2\",\n\t\t\tjson:           \"42949672983\",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-float\",\n\t\t\tjson:           \"2.4595\",\n\t\t\texpectedResult: 2,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-float2\",\n\t\t\tjson:           \"-7.8876\",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t},\n\t\t{\n\t\t\tname:           \"error\",\n\t\t\tjson:           \"83zez4\",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t\terrType:        InvalidJSONError(\"\"),\n\t\t},\n\t\t{\n\t\t\tname:           \"error\",\n\t\t\tjson:           \"-83zez4\",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t\terrType:        InvalidJSONError(\"\"),\n\t\t},\n\t\t{\n\t\t\tname:           \"invalid-type\",\n\t\t\tjson:           `\"string\"`,\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t\terrType:        InvalidUnmarshalError(\"\"),\n\t\t},\n\t\t{\n\t\t\tname:           \"invalid-json\",\n\t\t\tjson:           `123invalid`,\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t\terrType:        InvalidJSONError(\"\"),\n\t\t},\n\t}\n\tfor _, testCase := range testCases {\n\t\tt.Run(testCase.name, func(t *testing.T) {\n\t\t\tjson := []byte(testCase.json)\n\t\t\tvar v uint16\n\t\t\terr := Unmarshal(json, &v)\n\t\t\tif testCase.err {\n\t\t\t\tassert.NotNil(t, err, \"Err must not be nil\")\n\t\t\t\tif testCase.errType != nil {\n\t\t\t\t\tassert.IsType(\n\t\t\t\t\t\tt,\n\t\t\t\t\t\ttestCase.errType,\n\t\t\t\t\t\terr,\n\t\t\t\t\t\tfmt.Sprintf(\"err should be of type %s\", reflect.TypeOf(err).String()),\n\t\t\t\t\t)\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tassert.Nil(t, err, \"Err must be nil\")\n\t\t\t}\n\t\t\tassert.Equal(t, testCase.expectedResult, v, fmt.Sprintf(\"v must be equal to %d\", testCase.expectedResult))\n\t\t})\n\t}\n\tt.Run(\"pool-error\", func(t *testing.T) {\n\t\tresult := uint16(1)\n\t\tdec := NewDecoder(nil)\n\t\tdec.Release()\n\t\tdefer func() {\n\t\t\terr := recover()\n\t\t\tassert.NotNil(t, err, \"err shouldnt be nil\")\n\t\t\tassert.IsType(t, InvalidUsagePooledDecoderError(\"\"), err, \"err should be of type InvalidUsagePooledDecoderError\")\n\t\t}()\n\t\t_ = dec.DecodeUint16(&result)\n\t\tassert.True(t, false, \"should not be called as decoder should have panicked\")\n\t})\n\tt.Run(\"decoder-api\", func(t *testing.T) {\n\t\tvar v uint16\n\t\tdec := NewDecoder(strings.NewReader(`33`))\n\t\tdefer dec.Release()\n\t\terr := dec.DecodeUint16(&v)\n\t\tassert.Nil(t, err, \"Err must be nil\")\n\t\tassert.Equal(t, uint16(33), v, \"v must be equal to 33\")\n\t})\n\tt.Run(\"decoder-api2\", func(t *testing.T) {\n\t\tvar v uint16\n\t\tdec := NewDecoder(strings.NewReader(`33`))\n\t\tdefer dec.Release()\n\t\terr := dec.Decode(&v)\n\t\tassert.Nil(t, err, \"Err must be nil\")\n\t\tassert.Equal(t, uint16(33), v, \"v must be equal to 33\")\n\t})\n\tt.Run(\"decoder-api-json-error\", func(t *testing.T) {\n\t\tvar v uint16\n\t\tdec := NewDecoder(strings.NewReader(``))\n\t\tdefer dec.Release()\n\t\terr := dec.DecodeUint16(&v)\n\t\tassert.NotNil(t, err, \"Err must not be nil\")\n\t\tassert.IsType(t, InvalidJSONError(\"\"), err, \"err should be of type InvalidJSONError\")\n\t})\n}\nfunc TestDecoderUint16Null(t *testing.T) {\n\ttestCases := []struct {\n\t\tname           string\n\t\tjson           string\n\t\texpectedResult uint16\n\t\terr            bool\n\t\terrType        interface{}\n\t\tresultIsNil    bool\n\t}{\n\t\t{\n\t\t\tname:           \"basic-positive\",\n\t\t\tjson:           \"100\",\n\t\t\texpectedResult: 100,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-positive2\",\n\t\t\tjson:           \" 3224 \",\n\t\t\texpectedResult: 3224,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-negative\",\n\t\t\tjson:           \"-2\",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-null\",\n\t\t\tjson:           \"null\",\n\t\t\texpectedResult: 0,\n\t\t\tresultIsNil:    true,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-null-err\",\n\t\t\tjson:           \"nxll\",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t\terrType:        InvalidJSONError(\"\"),\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-skip-data-err\",\n\t\t\tjson:           \"trua\",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t\terrType:        InvalidJSONError(\"\"),\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-skip-data-err\",\n\t\t\tjson:           \"trua\",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t\terrType:        InvalidJSONError(\"\"),\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-overflow\",\n\t\t\tjson:           \"335346564\",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t\terrType:        InvalidUnmarshalError(\"\"),\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-negative2\",\n\t\t\tjson:           \"-24467\",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-big\",\n\t\t\tjson:           \"54546\",\n\t\t\texpectedResult: 54546,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-big-overflow\",\n\t\t\tjson:           \" 4294967298\",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-big-overflow\",\n\t\t\tjson:           \" 65537\",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-big-overflow\",\n\t\t\tjson:           \" 66537\",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-big-overflow2\",\n\t\t\tjson:           \"42949672983\",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-float\",\n\t\t\tjson:           \"2.4595\",\n\t\t\texpectedResult: 2,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-float2\",\n\t\t\tjson:           \"-7.8876\",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t},\n\t\t{\n\t\t\tname:           \"error\",\n\t\t\tjson:           \"83zez4\",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t\terrType:        InvalidJSONError(\"\"),\n\t\t},\n\t\t{\n\t\t\tname:           \"error\",\n\t\t\tjson:           \"-83zez4\",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t\terrType:        InvalidJSONError(\"\"),\n\t\t},\n\t\t{\n\t\t\tname:           \"invalid-type\",\n\t\t\tjson:           `\"string\"`,\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t\terrType:        InvalidUnmarshalError(\"\"),\n\t\t},\n\t\t{\n\t\t\tname:           \"invalid-json\",\n\t\t\tjson:           `123invalid`,\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t\terrType:        InvalidJSONError(\"\"),\n\t\t},\n\t}\n\tfor _, testCase := range testCases {\n\t\tt.Run(testCase.name, func(t *testing.T) {\n\t\t\tjson := []byte(testCase.json)\n\t\t\tvar v = (*uint16)(nil)\n\t\t\terr := Unmarshal(json, &v)\n\t\t\tif testCase.err {\n\t\t\t\tassert.NotNil(t, err, \"Err must not be nil\")\n\t\t\t\tif testCase.errType != nil {\n\t\t\t\t\tassert.IsType(\n\t\t\t\t\t\tt,\n\t\t\t\t\t\ttestCase.errType,\n\t\t\t\t\t\terr,\n\t\t\t\t\t\tfmt.Sprintf(\"err should be of type %s\", reflect.TypeOf(err).String()),\n\t\t\t\t\t)\n\t\t\t\t}\n\t\t\t\treturn\n\t\t\t}\n\t\t\tassert.Nil(t, err, \"Err must be nil\")\n\t\t\tif testCase.resultIsNil {\n\t\t\t\tassert.Nil(t, v)\n\t\t\t} else {\n\t\t\t\tassert.Equal(t, testCase.expectedResult, *v, fmt.Sprintf(\"v must be equal to %d\", testCase.expectedResult))\n\t\t\t}\n\t\t})\n\t}\n\tt.Run(\"decoder-api-invalid-json\", func(t *testing.T) {\n\t\tvar v = new(uint16)\n\t\terr := Unmarshal([]byte(``), &v)\n\t\tassert.NotNil(t, err, \"Err must not be nil\")\n\t\tassert.IsType(t, InvalidJSONError(\"\"), err, \"err should be of type InvalidJSONError\")\n\t})\n\tt.Run(\"decoder-api-invalid-json2\", func(t *testing.T) {\n\t\tvar v = new(uint16)\n\t\tvar dec = NewDecoder(strings.NewReader(``))\n\t\terr := dec.Uint16Null(&v)\n\t\tassert.NotNil(t, err, \"Err must not be nil\")\n\t\tassert.IsType(t, InvalidJSONError(\"\"), err, \"err should be of type InvalidJSONError\")\n\t})\n}\n\nfunc TestDecoderUint8(t *testing.T) {\n\ttestCases := []struct {\n\t\tname           string\n\t\tjson           string\n\t\texpectedResult uint8\n\t\terr            bool\n\t\terrType        interface{}\n\t}{\n\t\t{\n\t\t\tname:           \"basic-positive\",\n\t\t\tjson:           \"100\",\n\t\t\texpectedResult: 100,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-positive2\",\n\t\t\tjson:           \" 255 \",\n\t\t\texpectedResult: 255,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-negative\",\n\t\t\tjson:           \"-2\",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-null\",\n\t\t\tjson:           \"null\",\n\t\t\texpectedResult: 0,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-null-err\",\n\t\t\tjson:           \"nxll\",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t\terrType:        InvalidJSONError(\"\"),\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-skip-data-err\",\n\t\t\tjson:           \"trua\",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t\terrType:        InvalidJSONError(\"\"),\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-negative2\",\n\t\t\tjson:           \"-234\",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-big\",\n\t\t\tjson:           \"200\",\n\t\t\texpectedResult: 200,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-overflow\",\n\t\t\tjson:           \"256\",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t\terrType:        InvalidUnmarshalError(\"\"),\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-overflow\",\n\t\t\tjson:           \"274\",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t\terrType:        InvalidUnmarshalError(\"\"),\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-big-overflow\",\n\t\t\tjson:           \" 4294967298\",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-big-overflow2\",\n\t\t\tjson:           \"42949672983\",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-float\",\n\t\t\tjson:           \"2.4595\",\n\t\t\texpectedResult: 2,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-float2\",\n\t\t\tjson:           \"-7.8876\",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t},\n\t\t{\n\t\t\tname:           \"error\",\n\t\t\tjson:           \"83zez4\",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t\terrType:        InvalidJSONError(\"\"),\n\t\t},\n\t\t{\n\t\t\tname:           \"error\",\n\t\t\tjson:           \"-83zez4\",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t\terrType:        InvalidJSONError(\"\"),\n\t\t},\n\t\t{\n\t\t\tname:           \"invalid-type\",\n\t\t\tjson:           `\"string\"`,\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t\terrType:        InvalidUnmarshalError(\"\"),\n\t\t},\n\t\t{\n\t\t\tname:           \"invalid-json\",\n\t\t\tjson:           `123invalid`,\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t\terrType:        InvalidJSONError(\"\"),\n\t\t},\n\t}\n\tfor _, testCase := range testCases {\n\t\tt.Run(testCase.name, func(t *testing.T) {\n\t\t\tjson := []byte(testCase.json)\n\t\t\tvar v uint8\n\t\t\terr := Unmarshal(json, &v)\n\t\t\tif testCase.err {\n\t\t\t\tassert.NotNil(t, err, \"Err must not be nil\")\n\t\t\t\tif testCase.errType != nil {\n\t\t\t\t\tassert.IsType(\n\t\t\t\t\t\tt,\n\t\t\t\t\t\ttestCase.errType,\n\t\t\t\t\t\terr,\n\t\t\t\t\t\tfmt.Sprintf(\"err should be of type %s\", reflect.TypeOf(err).String()),\n\t\t\t\t\t)\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tassert.Nil(t, err, \"Err must be nil\")\n\t\t\t}\n\t\t\tassert.Equal(t, testCase.expectedResult, v, fmt.Sprintf(\"v must be equal to %d\", testCase.expectedResult))\n\t\t})\n\t}\n\tt.Run(\"pool-error\", func(t *testing.T) {\n\t\tresult := uint8(1)\n\t\tdec := NewDecoder(nil)\n\t\tdec.Release()\n\t\tdefer func() {\n\t\t\terr := recover()\n\t\t\tassert.NotNil(t, err, \"err shouldnt be nil\")\n\t\t\tassert.IsType(t, InvalidUsagePooledDecoderError(\"\"), err, \"err should be of type InvalidUsagePooledDecoderError\")\n\t\t}()\n\t\t_ = dec.DecodeUint8(&result)\n\t\tassert.True(t, false, \"should not be called as decoder should have panicked\")\n\t})\n\tt.Run(\"decoder-api\", func(t *testing.T) {\n\t\tvar v uint8\n\t\tdec := NewDecoder(strings.NewReader(`33`))\n\t\tdefer dec.Release()\n\t\terr := dec.DecodeUint8(&v)\n\t\tassert.Nil(t, err, \"Err must be nil\")\n\t\tassert.Equal(t, uint8(33), v, \"v must be equal to 33\")\n\t})\n\tt.Run(\"decoder-api2\", func(t *testing.T) {\n\t\tvar v uint8\n\t\tdec := NewDecoder(strings.NewReader(`33`))\n\t\tdefer dec.Release()\n\t\terr := dec.Decode(&v)\n\t\tassert.Nil(t, err, \"Err must be nil\")\n\t\tassert.Equal(t, uint8(33), v, \"v must be equal to 33\")\n\t})\n\tt.Run(\"decoder-api-json-error\", func(t *testing.T) {\n\t\tvar v uint8\n\t\tdec := NewDecoder(strings.NewReader(``))\n\t\tdefer dec.Release()\n\t\terr := dec.DecodeUint8(&v)\n\t\tassert.NotNil(t, err, \"Err must not be nil\")\n\t\tassert.IsType(t, InvalidJSONError(\"\"), err, \"err should be of type InvalidJSONError\")\n\t})\n}\n\nfunc TestDecoderUint8Null(t *testing.T) {\n\ttestCases := []struct {\n\t\tname           string\n\t\tjson           string\n\t\texpectedResult uint8\n\t\terr            bool\n\t\terrType        interface{}\n\t\tresultIsNil    bool\n\t}{\n\t\t{\n\t\t\tname:           \"basic-positive\",\n\t\t\tjson:           \"100\",\n\t\t\texpectedResult: 100,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-positive2\",\n\t\t\tjson:           \" 255 \",\n\t\t\texpectedResult: 255,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-negative\",\n\t\t\tjson:           \"-2\",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-null\",\n\t\t\tjson:           \"null\",\n\t\t\texpectedResult: 0,\n\t\t\tresultIsNil:    true,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-null-err\",\n\t\t\tjson:           \"nxll\",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t\terrType:        InvalidJSONError(\"\"),\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-skip-data-err\",\n\t\t\tjson:           \"trua\",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t\terrType:        InvalidJSONError(\"\"),\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-negative2\",\n\t\t\tjson:           \"-234\",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-big\",\n\t\t\tjson:           \"200\",\n\t\t\texpectedResult: 200,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-overflow\",\n\t\t\tjson:           \"256\",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t\terrType:        InvalidUnmarshalError(\"\"),\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-overflow\",\n\t\t\tjson:           \"274\",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t\terrType:        InvalidUnmarshalError(\"\"),\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-big-overflow\",\n\t\t\tjson:           \" 4294967298\",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-big-overflow2\",\n\t\t\tjson:           \"42949672983\",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-float\",\n\t\t\tjson:           \"2.4595\",\n\t\t\texpectedResult: 2,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-float2\",\n\t\t\tjson:           \"-7.8876\",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t},\n\t\t{\n\t\t\tname:           \"error\",\n\t\t\tjson:           \"83zez4\",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t\terrType:        InvalidJSONError(\"\"),\n\t\t},\n\t\t{\n\t\t\tname:           \"error\",\n\t\t\tjson:           \"-83zez4\",\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t\terrType:        InvalidJSONError(\"\"),\n\t\t},\n\t\t{\n\t\t\tname:           \"invalid-type\",\n\t\t\tjson:           `\"string\"`,\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t\terrType:        InvalidUnmarshalError(\"\"),\n\t\t},\n\t\t{\n\t\t\tname:           \"invalid-json\",\n\t\t\tjson:           `123invalid`,\n\t\t\texpectedResult: 0,\n\t\t\terr:            true,\n\t\t\terrType:        InvalidJSONError(\"\"),\n\t\t},\n\t}\n\tfor _, testCase := range testCases {\n\t\tt.Run(testCase.name, func(t *testing.T) {\n\t\t\tjson := []byte(testCase.json)\n\t\t\tvar v = (*uint8)(nil)\n\t\t\terr := Unmarshal(json, &v)\n\t\t\tif testCase.err {\n\t\t\t\tassert.NotNil(t, err, \"Err must not be nil\")\n\t\t\t\tif testCase.errType != nil {\n\t\t\t\t\tassert.IsType(\n\t\t\t\t\t\tt,\n\t\t\t\t\t\ttestCase.errType,\n\t\t\t\t\t\terr,\n\t\t\t\t\t\tfmt.Sprintf(\"err should be of type %s\", reflect.TypeOf(err).String()),\n\t\t\t\t\t)\n\t\t\t\t}\n\t\t\t\treturn\n\t\t\t}\n\t\t\tassert.Nil(t, err, \"Err must be nil\")\n\t\t\tif testCase.resultIsNil {\n\t\t\t\tassert.Nil(t, v)\n\t\t\t} else {\n\t\t\t\tassert.Equal(t, testCase.expectedResult, *v, fmt.Sprintf(\"v must be equal to %d\", testCase.expectedResult))\n\t\t\t}\n\t\t})\n\t}\n\tt.Run(\"decoder-api-invalid-json\", func(t *testing.T) {\n\t\tvar v = new(uint8)\n\t\terr := Unmarshal([]byte(``), &v)\n\t\tassert.NotNil(t, err, \"Err must not be nil\")\n\t\tassert.IsType(t, InvalidJSONError(\"\"), err, \"err should be of type InvalidJSONError\")\n\t})\n\tt.Run(\"decoder-api-invalid-json2\", func(t *testing.T) {\n\t\tvar v = new(uint8)\n\t\tvar dec = NewDecoder(strings.NewReader(``))\n\t\terr := dec.Uint8Null(&v)\n\t\tassert.NotNil(t, err, \"Err must not be nil\")\n\t\tassert.IsType(t, InvalidJSONError(\"\"), err, \"err should be of type InvalidJSONError\")\n\t})\n}\n"
        },
        {
          "name": "decode_object.go",
          "type": "blob",
          "size": 9.935546875,
          "content": "package gojay\n\nimport (\n\t\"reflect\"\n\t\"unsafe\"\n)\n\n// DecodeObject reads the next JSON-encoded value from the decoder's input (io.Reader) and stores it in the value pointed to by v.\n//\n// v must implement UnmarshalerJSONObject.\n//\n// See the documentation for Unmarshal for details about the conversion of JSON into a Go value.\nfunc (dec *Decoder) DecodeObject(j UnmarshalerJSONObject) error {\n\tif dec.isPooled == 1 {\n\t\tpanic(InvalidUsagePooledDecoderError(\"Invalid usage of pooled decoder\"))\n\t}\n\t_, err := dec.decodeObject(j)\n\treturn err\n}\nfunc (dec *Decoder) decodeObject(j UnmarshalerJSONObject) (int, error) {\n\tkeys := j.NKeys()\n\tfor ; dec.cursor < dec.length || dec.read(); dec.cursor++ {\n\t\tswitch dec.data[dec.cursor] {\n\t\tcase ' ', '\\n', '\\t', '\\r', ',':\n\t\tcase '{':\n\t\t\tdec.cursor = dec.cursor + 1\n\t\t\t// if keys is zero we will parse all keys\n\t\t\t// we run two loops for micro optimization\n\t\t\tif keys == 0 {\n\t\t\t\tfor dec.cursor < dec.length || dec.read() {\n\t\t\t\t\tk, done, err := dec.nextKey()\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\treturn 0, err\n\t\t\t\t\t} else if done {\n\t\t\t\t\t\treturn dec.cursor, nil\n\t\t\t\t\t}\n\t\t\t\t\terr = j.UnmarshalJSONObject(dec, k)\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\tdec.err = err\n\t\t\t\t\t\treturn 0, err\n\t\t\t\t\t} else if dec.called&1 == 0 {\n\t\t\t\t\t\terr := dec.skipData()\n\t\t\t\t\t\tif err != nil {\n\t\t\t\t\t\t\treturn 0, err\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdec.keysDone++\n\t\t\t\t\t}\n\t\t\t\t\tdec.called &= 0\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfor (dec.cursor < dec.length || dec.read()) && dec.keysDone < keys {\n\t\t\t\t\tk, done, err := dec.nextKey()\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\treturn 0, err\n\t\t\t\t\t} else if done {\n\t\t\t\t\t\treturn dec.cursor, nil\n\t\t\t\t\t}\n\t\t\t\t\terr = j.UnmarshalJSONObject(dec, k)\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\tdec.err = err\n\t\t\t\t\t\treturn 0, err\n\t\t\t\t\t} else if dec.called&1 == 0 {\n\t\t\t\t\t\terr := dec.skipData()\n\t\t\t\t\t\tif err != nil {\n\t\t\t\t\t\t\treturn 0, err\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdec.keysDone++\n\t\t\t\t\t}\n\t\t\t\t\tdec.called &= 0\n\t\t\t\t}\n\t\t\t}\n\t\t\t// will get to that point when keysDone is not lower than keys anymore\n\t\t\t// in that case, we make sure cursor goes to the end of object, but we skip\n\t\t\t// unmarshalling\n\t\t\tif dec.child&1 != 0 {\n\t\t\t\tend, err := dec.skipObject()\n\t\t\t\tdec.cursor = end\n\t\t\t\treturn dec.cursor, err\n\t\t\t}\n\t\t\treturn dec.cursor, nil\n\t\tcase 'n':\n\t\t\tdec.cursor++\n\t\t\terr := dec.assertNull()\n\t\t\tif err != nil {\n\t\t\t\treturn 0, err\n\t\t\t}\n\t\t\treturn dec.cursor, nil\n\t\tdefault:\n\t\t\t// can't unmarshal to struct\n\t\t\tdec.err = dec.makeInvalidUnmarshalErr(j)\n\t\t\terr := dec.skipData()\n\t\t\tif err != nil {\n\t\t\t\treturn 0, err\n\t\t\t}\n\t\t\treturn dec.cursor, nil\n\t\t}\n\t}\n\treturn 0, dec.raiseInvalidJSONErr(dec.cursor)\n}\n\nfunc (dec *Decoder) decodeObjectNull(v interface{}) (int, error) {\n\t// make sure the value is a pointer\n\tvv := reflect.ValueOf(v)\n\tvvt := vv.Type()\n\tif vvt.Kind() != reflect.Ptr || vvt.Elem().Kind() != reflect.Ptr {\n\t\tdec.err = ErrUnmarshalPtrExpected\n\t\treturn 0, dec.err\n\t}\n\tfor ; dec.cursor < dec.length || dec.read(); dec.cursor++ {\n\t\tswitch dec.data[dec.cursor] {\n\t\tcase ' ', '\\n', '\\t', '\\r', ',':\n\t\tcase '{':\n\t\t\telt := vv.Elem()\n\t\t\tn := reflect.New(elt.Type().Elem())\n\t\t\telt.Set(n)\n\t\t\tvar j UnmarshalerJSONObject\n\t\t\tvar ok bool\n\t\t\tif j, ok = n.Interface().(UnmarshalerJSONObject); !ok {\n\t\t\t\tdec.err = dec.makeInvalidUnmarshalErr((UnmarshalerJSONObject)(nil))\n\t\t\t\treturn 0, dec.err\n\t\t\t}\n\t\t\tkeys := j.NKeys()\n\t\t\tdec.cursor = dec.cursor + 1\n\t\t\t// if keys is zero we will parse all keys\n\t\t\t// we run two loops for micro optimization\n\t\t\tif keys == 0 {\n\t\t\t\tfor dec.cursor < dec.length || dec.read() {\n\t\t\t\t\tk, done, err := dec.nextKey()\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\treturn 0, err\n\t\t\t\t\t} else if done {\n\t\t\t\t\t\treturn dec.cursor, nil\n\t\t\t\t\t}\n\t\t\t\t\terr = j.UnmarshalJSONObject(dec, k)\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\tdec.err = err\n\t\t\t\t\t\treturn 0, err\n\t\t\t\t\t} else if dec.called&1 == 0 {\n\t\t\t\t\t\terr := dec.skipData()\n\t\t\t\t\t\tif err != nil {\n\t\t\t\t\t\t\treturn 0, err\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdec.keysDone++\n\t\t\t\t\t}\n\t\t\t\t\tdec.called &= 0\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfor (dec.cursor < dec.length || dec.read()) && dec.keysDone < keys {\n\t\t\t\t\tk, done, err := dec.nextKey()\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\treturn 0, err\n\t\t\t\t\t} else if done {\n\t\t\t\t\t\treturn dec.cursor, nil\n\t\t\t\t\t}\n\t\t\t\t\terr = j.UnmarshalJSONObject(dec, k)\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\tdec.err = err\n\t\t\t\t\t\treturn 0, err\n\t\t\t\t\t} else if dec.called&1 == 0 {\n\t\t\t\t\t\terr := dec.skipData()\n\t\t\t\t\t\tif err != nil {\n\t\t\t\t\t\t\treturn 0, err\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdec.keysDone++\n\t\t\t\t\t}\n\t\t\t\t\tdec.called &= 0\n\t\t\t\t}\n\t\t\t}\n\t\t\t// will get to that point when keysDone is not lower than keys anymore\n\t\t\t// in that case, we make sure cursor goes to the end of object, but we skip\n\t\t\t// unmarshalling\n\t\t\tif dec.child&1 != 0 {\n\t\t\t\tend, err := dec.skipObject()\n\t\t\t\tdec.cursor = end\n\t\t\t\treturn dec.cursor, err\n\t\t\t}\n\t\t\treturn dec.cursor, nil\n\t\tcase 'n':\n\t\t\tdec.cursor++\n\t\t\terr := dec.assertNull()\n\t\t\tif err != nil {\n\t\t\t\treturn 0, err\n\t\t\t}\n\t\t\treturn dec.cursor, nil\n\t\tdefault:\n\t\t\t// can't unmarshal to struct\n\t\t\tdec.err = dec.makeInvalidUnmarshalErr((UnmarshalerJSONObject)(nil))\n\t\t\terr := dec.skipData()\n\t\t\tif err != nil {\n\t\t\t\treturn 0, err\n\t\t\t}\n\t\t\treturn dec.cursor, nil\n\t\t}\n\t}\n\treturn 0, dec.raiseInvalidJSONErr(dec.cursor)\n}\n\nfunc (dec *Decoder) skipObject() (int, error) {\n\tvar objectsOpen = 1\n\tvar objectsClosed = 0\n\tfor j := dec.cursor; j < dec.length || dec.read(); j++ {\n\t\tswitch dec.data[j] {\n\t\tcase '}':\n\t\t\tobjectsClosed++\n\t\t\t// everything is closed return\n\t\t\tif objectsOpen == objectsClosed {\n\t\t\t\t// add char to object data\n\t\t\t\treturn j + 1, nil\n\t\t\t}\n\t\tcase '{':\n\t\t\tobjectsOpen++\n\t\tcase '\"':\n\t\t\tj++\n\t\t\tvar isInEscapeSeq bool\n\t\t\tvar isFirstQuote = true\n\t\t\tfor ; j < dec.length || dec.read(); j++ {\n\t\t\t\tif dec.data[j] != '\"' {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\tif dec.data[j-1] != '\\\\' || (!isInEscapeSeq && !isFirstQuote) {\n\t\t\t\t\tbreak\n\t\t\t\t} else {\n\t\t\t\t\tisInEscapeSeq = false\n\t\t\t\t}\n\t\t\t\tif isFirstQuote {\n\t\t\t\t\tisFirstQuote = false\n\t\t\t\t}\n\t\t\t\t// loop backward and count how many anti slash found\n\t\t\t\t// to see if string is effectively escaped\n\t\t\t\tct := 0\n\t\t\t\tfor i := j - 1; i > 0; i-- {\n\t\t\t\t\tif dec.data[i] != '\\\\' {\n\t\t\t\t\t\tbreak\n\t\t\t\t\t}\n\t\t\t\t\tct++\n\t\t\t\t}\n\t\t\t\t// is pair number of slashes, quote is not escaped\n\t\t\t\tif ct&1 == 0 {\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t\tisInEscapeSeq = true\n\t\t\t}\n\t\tdefault:\n\t\t\tcontinue\n\t\t}\n\t}\n\treturn 0, dec.raiseInvalidJSONErr(dec.cursor)\n}\n\nfunc (dec *Decoder) nextKey() (string, bool, error) {\n\tfor ; dec.cursor < dec.length || dec.read(); dec.cursor++ {\n\t\tswitch dec.data[dec.cursor] {\n\t\tcase ' ', '\\n', '\\t', '\\r', ',':\n\t\t\tcontinue\n\t\tcase '\"':\n\t\t\tdec.cursor = dec.cursor + 1\n\t\t\tstart, end, err := dec.getString()\n\t\t\tif err != nil {\n\t\t\t\treturn \"\", false, err\n\t\t\t}\n\t\t\tvar found byte\n\t\t\tfor ; dec.cursor < dec.length || dec.read(); dec.cursor++ {\n\t\t\t\tif dec.data[dec.cursor] == ':' {\n\t\t\t\t\tfound |= 1\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t\tif found&1 != 0 {\n\t\t\t\tdec.cursor++\n\t\t\t\td := dec.data[start : end-1]\n\t\t\t\treturn *(*string)(unsafe.Pointer(&d)), false, nil\n\t\t\t}\n\t\t\treturn \"\", false, dec.raiseInvalidJSONErr(dec.cursor)\n\t\tcase '}':\n\t\t\tdec.cursor = dec.cursor + 1\n\t\t\treturn \"\", true, nil\n\t\tdefault:\n\t\t\t// can't unmarshall to struct\n\t\t\treturn \"\", false, dec.raiseInvalidJSONErr(dec.cursor)\n\t\t}\n\t}\n\treturn \"\", false, dec.raiseInvalidJSONErr(dec.cursor)\n}\n\nfunc (dec *Decoder) skipData() error {\n\tfor ; dec.cursor < dec.length || dec.read(); dec.cursor++ {\n\t\tswitch dec.data[dec.cursor] {\n\t\tcase ' ', '\\n', '\\t', '\\r', ',':\n\t\t\tcontinue\n\t\t// is null\n\t\tcase 'n':\n\t\t\tdec.cursor++\n\t\t\terr := dec.assertNull()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\treturn nil\n\t\tcase 't':\n\t\t\tdec.cursor++\n\t\t\terr := dec.assertTrue()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\treturn nil\n\t\t// is false\n\t\tcase 'f':\n\t\t\tdec.cursor++\n\t\t\terr := dec.assertFalse()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\treturn nil\n\t\t// is an object\n\t\tcase '{':\n\t\t\tdec.cursor = dec.cursor + 1\n\t\t\tend, err := dec.skipObject()\n\t\t\tdec.cursor = end\n\t\t\treturn err\n\t\t// is string\n\t\tcase '\"':\n\t\t\tdec.cursor = dec.cursor + 1\n\t\t\terr := dec.skipString()\n\t\t\treturn err\n\t\t// is array\n\t\tcase '[':\n\t\t\tdec.cursor = dec.cursor + 1\n\t\t\tend, err := dec.skipArray()\n\t\t\tdec.cursor = end\n\t\t\treturn err\n\t\tcase '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '-':\n\t\t\tend, err := dec.skipNumber()\n\t\t\tdec.cursor = end\n\t\t\treturn err\n\t\t}\n\t\treturn dec.raiseInvalidJSONErr(dec.cursor)\n\t}\n\treturn dec.raiseInvalidJSONErr(dec.cursor)\n}\n\n// DecodeObjectFunc is a func type implementing UnmarshalerJSONObject.\n// Use it to cast a `func(*Decoder, k string) error` to Unmarshal an object on the fly.\ntype DecodeObjectFunc func(*Decoder, string) error\n\n// UnmarshalJSONObject implements UnmarshalerJSONObject.\nfunc (f DecodeObjectFunc) UnmarshalJSONObject(dec *Decoder, k string) error {\n\treturn f(dec, k)\n}\n\n// NKeys implements UnmarshalerJSONObject.\nfunc (f DecodeObjectFunc) NKeys() int {\n\treturn 0\n}\n\n// Add Values functions\n\n// AddObject decodes the JSON value within an object or an array to a UnmarshalerJSONObject.\nfunc (dec *Decoder) AddObject(v UnmarshalerJSONObject) error {\n\treturn dec.Object(v)\n}\n\n// AddObjectNull decodes the JSON value within an object or an array to a UnmarshalerJSONObject.\nfunc (dec *Decoder) AddObjectNull(v interface{}) error {\n\treturn dec.ObjectNull(v)\n}\n\n// Object decodes the JSON value within an object or an array to a UnmarshalerJSONObject.\nfunc (dec *Decoder) Object(value UnmarshalerJSONObject) error {\n\tinitialKeysDone := dec.keysDone\n\tinitialChild := dec.child\n\tdec.keysDone = 0\n\tdec.called = 0\n\tdec.child |= 1\n\tnewCursor, err := dec.decodeObject(value)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdec.cursor = newCursor\n\tdec.keysDone = initialKeysDone\n\tdec.child = initialChild\n\tdec.called |= 1\n\treturn nil\n}\n\n// ObjectNull decodes the JSON value within an object or an array to a UnmarshalerJSONObject.\n// v should be a pointer to an UnmarshalerJSONObject,\n// if `null` value is encountered in JSON, it will leave the value v untouched,\n// else it will create a new instance of the UnmarshalerJSONObject behind v.\nfunc (dec *Decoder) ObjectNull(v interface{}) error {\n\tinitialKeysDone := dec.keysDone\n\tinitialChild := dec.child\n\tdec.keysDone = 0\n\tdec.called = 0\n\tdec.child |= 1\n\tnewCursor, err := dec.decodeObjectNull(v)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdec.cursor = newCursor\n\tdec.keysDone = initialKeysDone\n\tdec.child = initialChild\n\tdec.called |= 1\n\treturn nil\n}\n"
        },
        {
          "name": "decode_object_test.go",
          "type": "blob",
          "size": 46.955078125,
          "content": "package gojay\n\nimport (\n\t\"fmt\"\n\t\"io\"\n\t\"reflect\"\n\t\"strings\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc makePointer(v interface{}) interface{} {\n\tvar ptr = reflect.New(reflect.TypeOf(v))\n\tptr.Elem().Set(reflect.ValueOf(v))\n\treturn ptr.Interface()\n}\n\nfunc TestDecodeObjectBasic(t *testing.T) {\n\ttestCases := []struct {\n\t\tname            string\n\t\tjson            string\n\t\texpectedResult  testObject\n\t\terr             bool\n\t\terrType         interface{}\n\t\tskipCheckResult bool\n\t}{\n\t\t{\n\t\t\tname: \"basic\",\n\t\t\tjson: `{\n\t\t\t\t\t\t\"testStr\": \"hello world!\",\n\t\t\t\t\t\t\"testStrNull\":  \"hello world!\",\n\t\t\t\t\t\t\"testInt\": 4535,\n\t\t\t\t\t\t\"testIntNull\": 4535,\n\t\t\t\t\t\t\"testBool\": true,\n\t\t\t\t\t\t\"testBoolNull\": true,\n\t\t\t\t\t\t\"testFloat32\": 2.345,\n\t\t\t\t\t\t\"testFloat32Null\": 2.345,\n\t\t\t\t\t\t\"testFloat64\": 123.677,\n\t\t\t\t\t\t\"testFloat64Null\": 123.677,\n\t\t\t\t\t\t\"testInt8\": 23,\n\t\t\t\t\t\t\"testInt8Null\": 23,\n\t\t\t\t\t\t\"testInt16\": 1245,\n\t\t\t\t\t\t\"testInt16Null\": 1245,\n\t\t\t\t\t\t\"testInt32\": 456778,\n\t\t\t\t\t\t\"testInt32Null\": 456778,\n\t\t\t\t\t\t\"testInt64\": 1446685358,\n\t\t\t\t\t\t\"testInt64Null\": 1446685358,\n\t\t\t\t\t\t\"testUint8\": 255,\n\t\t\t\t\t\t\"testUint8Null\": 255,\n\t\t\t\t\t\t\"testUint16\": 3455,\n\t\t\t\t\t\t\"testUint16Null\": 3455,\n\t\t\t\t\t\t\"testUint32\": 343443,\n\t\t\t\t\t\t\"testUint32Null\": 343443,\n\t\t\t\t\t\t\"testUint64\": 545665757,\n\t\t\t\t\t\t\"testUint64Null\": 545665757,\n\t\t\t\t\t\t\"testSubObjectNull\": {\n\t\t\t\t\t\t\t\"testStr\": \"1\"\n\t\t\t\t\t\t}\n\t\t\t\t\t}`,\n\t\t\texpectedResult: testObject{\n\t\t\t\ttestStr:         \"hello world!\",\n\t\t\t\ttestStrNull:     makePointer(\"hello world!\").(*string),\n\t\t\t\ttestInt:         4535,\n\t\t\t\ttestIntNull:     makePointer(4535).(*int),\n\t\t\t\ttestBool:        true,\n\t\t\t\ttestBoolNull:    makePointer(true).(*bool),\n\t\t\t\ttestFloat32:     2.345,\n\t\t\t\ttestFloat32Null: makePointer(float32(2.345)).(*float32),\n\t\t\t\ttestFloat64:     123.677,\n\t\t\t\ttestFloat64Null: makePointer(float64(123.677)).(*float64),\n\t\t\t\ttestInt8:        23,\n\t\t\t\ttestInt8Null:    makePointer(int8(23)).(*int8),\n\t\t\t\ttestInt16:       1245,\n\t\t\t\ttestInt16Null:   makePointer(int16(1245)).(*int16),\n\t\t\t\ttestInt32:       456778,\n\t\t\t\ttestInt32Null:   makePointer(int32(456778)).(*int32),\n\t\t\t\ttestInt64:       1446685358,\n\t\t\t\ttestInt64Null:   makePointer(int64(1446685358)).(*int64),\n\t\t\t\ttestUint8:       255,\n\t\t\t\ttestUint8Null:   makePointer(uint8(255)).(*uint8),\n\t\t\t\ttestUint16:      3455,\n\t\t\t\ttestUint16Null:  makePointer(uint16(3455)).(*uint16),\n\t\t\t\ttestUint32:      343443,\n\t\t\t\ttestUint32Null:  makePointer(uint32(343443)).(*uint32),\n\t\t\t\ttestUint64:      545665757,\n\t\t\t\ttestUint64Null:  makePointer(uint64(545665757)).(*uint64),\n\t\t\t},\n\t\t\terr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"basic-with-exponent\",\n\t\t\tjson: `{\n\t\t\t\t\t\t\"testStr\": \"hello world!\",\n\t\t\t\t\t\t\"testInt\": 3e3,\n\t\t\t\t\t\t\"testBool\": true,\n\t\t\t\t\t\t\"testFloat32\": 2.345,\n\t\t\t\t\t\t\"testFloat64\": 123.677,\n\t\t\t\t\t\t\"testInt8\": 23,\n\t\t\t\t\t\t\"testInt16\": 1245,\n\t\t\t\t\t\t\"testInt32\": 456778,\n\t\t\t\t\t\t\"testInt64\": 1446685358,\n\t\t\t\t\t\t\"testUint8\": 255,\n\t\t\t\t\t\t\"testUint16\": 3455,\n\t\t\t\t\t\t\"testUint32\": 343443,\n\t\t\t\t\t\t\"testUint64\": 545665757\n\t\t\t\t\t}`,\n\t\t\texpectedResult: testObject{\n\t\t\t\ttestStr:     \"hello world!\",\n\t\t\t\ttestInt:     3000,\n\t\t\t\ttestBool:    true,\n\t\t\t\ttestFloat32: 2.345,\n\t\t\t\ttestFloat64: 123.677,\n\t\t\t\ttestInt8:    23,\n\t\t\t\ttestInt16:   1245,\n\t\t\t\ttestInt32:   456778,\n\t\t\t\ttestInt64:   1446685358,\n\t\t\t\ttestUint8:   255,\n\t\t\t\ttestUint16:  3455,\n\t\t\t\ttestUint32:  343443,\n\t\t\t\ttestUint64:  545665757,\n\t\t\t},\n\t\t\terr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"basic-with-exponent3\",\n\t\t\tjson: `{\n\t\t\t\t\t\t\"testStr\": \"hello world!\",\n\t\t\t\t\t\t\"testInt\": 3e-3,\n\t\t\t\t\t\t\"testBool\": true,\n\t\t\t\t\t\t\"testFloat32\": 2.345,\n\t\t\t\t\t\t\"testFloat64\": 12e-3,\n\t\t\t\t\t\t\"testInt8\": 23,\n\t\t\t\t\t\t\"testInt16\": 1245,\n\t\t\t\t\t\t\"testInt32\": 456778,\n\t\t\t\t\t\t\"testInt64\": 1446685358,\n\t\t\t\t\t\t\"testUint8\": 255,\n\t\t\t\t\t\t\"testUint16\": 3455,\n\t\t\t\t\t\t\"testUint32\": 343443,\n\t\t\t\t\t\t\"testUint64\": 545665757\n\t\t\t\t\t}`,\n\t\t\texpectedResult: testObject{\n\t\t\t\ttestStr:     \"hello world!\",\n\t\t\t\ttestInt:     0,\n\t\t\t\ttestBool:    true,\n\t\t\t\ttestFloat32: 2.345,\n\t\t\t\ttestFloat64: 0.012,\n\t\t\t\ttestInt8:    23,\n\t\t\t\ttestInt16:   1245,\n\t\t\t\ttestInt32:   456778,\n\t\t\t\ttestInt64:   1446685358,\n\t\t\t\ttestUint8:   255,\n\t\t\t\ttestUint16:  3455,\n\t\t\t\ttestUint32:  343443,\n\t\t\t\ttestUint64:  545665757,\n\t\t\t},\n\t\t\terr: false,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-err-invalid-type\",\n\t\t\tjson:           `1`,\n\t\t\texpectedResult: testObject{},\n\t\t\terr:            true,\n\t\t\terrType:        InvalidUnmarshalError(\"\"),\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-err-invalid-json\",\n\t\t\tjson:           `hello`,\n\t\t\texpectedResult: testObject{},\n\t\t\terr:            true,\n\t\t\terrType:        InvalidJSONError(\"\"),\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-err-invalid-json\",\n\t\t\tjson:           `nall`,\n\t\t\texpectedResult: testObject{},\n\t\t\terr:            true,\n\t\t\terrType:        InvalidJSONError(\"\"),\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-err-invalid-type\",\n\t\t\tjson:           ``,\n\t\t\texpectedResult: testObject{},\n\t\t\terr:            true,\n\t\t\terrType:        InvalidJSONError(\"\"),\n\t\t},\n\t\t{\n\t\t\tname: \"basic-err\",\n\t\t\tjson: `{\n\t\t\t\t\t\t\"testStr\": \"hello world!\",\n\t\t\t\t\t\t\"testInt\": 453q5,\n\t\t\t\t\t\t\"testBool\": trae,\n\t\t\t\t\t\t\"testFloat32\": 2q.345,\n\t\t\t\t\t\t\"testFloat64\": 12x3.677,\n\t\t\t\t\t\t\"testInt8\": 2s3,\n\t\t\t\t\t\t\"testInt16\": 1245,\n\t\t\t\t\t\t\"testInt32\": 4567q78,\n\t\t\t\t\t\t\"testInt64\": 14466e85358,\n\t\t\t\t\t\t\"testUint8\": 2s55,\n\t\t\t\t\t\t\"testUint16\": 345i5,\n\t\t\t\t\t\t\"testUint32\": 343q443,\n\t\t\t\t\t\t\"testUint64\": 5456657z57\n\t\t\t\t\t}`,\n\t\t\texpectedResult: testObject{},\n\t\t\terr:            true,\n\t\t},\n\t\t{\n\t\t\tname: \"basic-err2\",\n\t\t\tjson: `{\n\t\t\t\t\t\t\"testStr\": \"hello world!\",\n\t\t\t\t\t\t\"testInt\": 4535,\n\t\t\t\t\t\t\"testBool\": true,\n\t\t\t\t\t\t\"testFloat32\": 2.345,\n\t\t\t\t\t\t\"testFloat64\": 123.677,\n\t\t\t\t\t\t\"testInt8\": 23,\n\t\t\t\t\t\t\"testInt16\": 1245,\n\t\t\t\t\t\t\"testInt32\": 4567x78,\n\t\t\t\t\t\t\"testInt64\": 1446685358,\n\t\t\t\t\t\t\"testUint8\": 255,\n\t\t\t\t\t\t\"testUint16\": 3455,\n\t\t\t\t\t\t\"testUint32\": 343443,\n\t\t\t\t\t\t\"testUint64\": 545665757\n\t\t\t\t\t}`,\n\t\t\texpectedResult: testObject{},\n\t\t\terr:            true,\n\t\t},\n\t\t{\n\t\t\tname: \"basic-err-float32\",\n\t\t\tjson: `{\n\t\t\t\t\t\t\"testStr\": \"hello world!\",\n\t\t\t\t\t\t\"testInt\": 4535,\n\t\t\t\t\t\t\"testBool\": true,\n\t\t\t\t\t\t\"testFloat32\": 2q.345,\n\t\t\t\t\t\t\"testFloat64\": 123.677,\n\t\t\t\t\t\t\"testInt8\": 23,\n\t\t\t\t\t\t\"testInt16\": 1245,\n\t\t\t\t\t\t\"testInt32\": 456778,\n\t\t\t\t\t\t\"testInt64\": 1446685358,\n\t\t\t\t\t\t\"testUint8\": 255,\n\t\t\t\t\t\t\"testUint16\": 3455,\n\t\t\t\t\t\t\"testUint32\": 343443,\n\t\t\t\t\t\t\"testUint64\": 545665757\n\t\t\t\t\t}`,\n\t\t\texpectedResult: testObject{},\n\t\t\terr:            true,\n\t\t},\n\t\t{\n\t\t\tname: \"basic-err-float64\",\n\t\t\tjson: `{\n\t\t\t\t\t\t\"testStr\": \"hello world!\",\n\t\t\t\t\t\t\"testInt\": 4535,\n\t\t\t\t\t\t\"testBool\": true,\n\t\t\t\t\t\t\"testFloat32\": 2.345,\n\t\t\t\t\t\t\"testFloat64\": 1x23.677,\n\t\t\t\t\t\t\"testInt8\": 23,\n\t\t\t\t\t\t\"testInt16\": 1245,\n\t\t\t\t\t\t\"testInt32\": 456778,\n\t\t\t\t\t\t\"testInt64\": 1446685358,\n\t\t\t\t\t\t\"testUint8\": 255,\n\t\t\t\t\t\t\"testUint16\": 3455,\n\t\t\t\t\t\t\"testUint32\": 343443,\n\t\t\t\t\t\t\"testUint64\": 545665757\n\t\t\t\t\t}`,\n\t\t\texpectedResult: testObject{},\n\t\t\terr:            true,\n\t\t},\n\t\t{\n\t\t\tname: \"basic-err3\",\n\t\t\tjson: `{\n\t\t\t\t\t\t\"testStr\": \"hello world!\",\n\t\t\t\t\t\t\"testInt\": 4535,\n\t\t\t\t\t\t\"testBool\": true,\n\t\t\t\t\t\t\"testFloat32\": 2.345,\n\t\t\t\t\t\t\"testFloat64\": 123.677,\n\t\t\t\t\t\t\"testInt8\": 2q3,\n\t\t\t\t\t\t\"testInt16\": 1245,\n\t\t\t\t\t\t\"testInt32\": 456778,\n\t\t\t\t\t\t\"testInt64\": 1446685358,\n\t\t\t\t\t\t\"testUint8\": 255,\n\t\t\t\t\t\t\"testUint16\": 3455,\n\t\t\t\t\t\t\"testUint32\": 343443,\n\t\t\t\t\t\t\"testUint64\": 545665757\n\t\t\t\t\t}`,\n\t\t\texpectedResult: testObject{},\n\t\t\terr:            true,\n\t\t},\n\t\t{\n\t\t\tname: \"basic-err-int16\",\n\t\t\tjson: `{\n\t\t\t\t\t\t\"testStr\": \"hello world!\",\n\t\t\t\t\t\t\"testInt\": 4535,\n\t\t\t\t\t\t\"testBool\": true,\n\t\t\t\t\t\t\"testFloat32\": 2.345,\n\t\t\t\t\t\t\"testFloat64\": 123.677,\n\t\t\t\t\t\t\"testInt8\": 23,\n\t\t\t\t\t\t\"testInt16\": 1x245,\n\t\t\t\t\t\t\"testInt32\": 456778,\n\t\t\t\t\t\t\"testInt64\": 1446685358,\n\t\t\t\t\t\t\"testUint8\": 255,\n\t\t\t\t\t\t\"testUint16\": 3455,\n\t\t\t\t\t\t\"testUint32\": 343443,\n\t\t\t\t\t\t\"testUint64\": 545665757\n\t\t\t\t\t}`,\n\t\t\texpectedResult: testObject{},\n\t\t\terr:            true,\n\t\t},\n\t\t{\n\t\t\tname: \"basic-err-int64\",\n\t\t\tjson: `{\n\t\t\t\t\t\t\"testStr\": \"hello world!\",\n\t\t\t\t\t\t\"testInt\": 4535,\n\t\t\t\t\t\t\"testBool\": true,\n\t\t\t\t\t\t\"testFloat32\": 2.345,\n\t\t\t\t\t\t\"testFloat64\": 123.677,\n\t\t\t\t\t\t\"testInt8\": 23,\n\t\t\t\t\t\t\"testInt16\": 1245,\n\t\t\t\t\t\t\"testInt32\": 456778,\n\t\t\t\t\t\t\"testInt64\": 1446q685358,\n\t\t\t\t\t\t\"testUint8\": 255,\n\t\t\t\t\t\t\"testUint16\": 3455,\n\t\t\t\t\t\t\"testUint32\": 343443,\n\t\t\t\t\t\t\"testUint64\": 545665757\n\t\t\t\t\t}`,\n\t\t\texpectedResult: testObject{},\n\t\t\terr:            true,\n\t\t},\n\t\t{\n\t\t\tname: \"basic-err-uint8\",\n\t\t\tjson: `{\n\t\t\t\t\t\t\"testStr\": \"hello world!\",\n\t\t\t\t\t\t\"testInt\": 4535,\n\t\t\t\t\t\t\"testBool\": true,\n\t\t\t\t\t\t\"testFloat32\": 2.345,\n\t\t\t\t\t\t\"testFloat64\": 123.677,\n\t\t\t\t\t\t\"testInt8\": 23,\n\t\t\t\t\t\t\"testInt16\": 1245,\n\t\t\t\t\t\t\"testInt32\": 456778,\n\t\t\t\t\t\t\"testInt64\": 1446685358,\n\t\t\t\t\t\t\"testUint8\": 2x55,\n\t\t\t\t\t\t\"testUint16\": 3455,\n\t\t\t\t\t\t\"testUint32\": 343443,\n\t\t\t\t\t\t\"testUint64\": 545665757\n\t\t\t\t\t}`,\n\t\t\texpectedResult: testObject{},\n\t\t\terr:            true,\n\t\t},\n\t\t{\n\t\t\tname: \"basic-err-uint16\",\n\t\t\tjson: `{\n\t\t\t\t\t\t\"testStr\": \"hello world!\",\n\t\t\t\t\t\t\"testInt\": 4535,\n\t\t\t\t\t\t\"testBool\": true,\n\t\t\t\t\t\t\"testFloat32\": 2.345,\n\t\t\t\t\t\t\"testFloat64\": 123.677,\n\t\t\t\t\t\t\"testInt8\": 23,\n\t\t\t\t\t\t\"testInt16\": 1245,\n\t\t\t\t\t\t\"testInt32\": 456778,\n\t\t\t\t\t\t\"testInt64\": 1446685358,\n\t\t\t\t\t\t\"testUint8\": 255,\n\t\t\t\t\t\t\"testUint16\": 3x455,\n\t\t\t\t\t\t\"testUint32\": 343443,\n\t\t\t\t\t\t\"testUint64\": 545665757\n\t\t\t\t\t}`,\n\t\t\texpectedResult: testObject{},\n\t\t\terr:            true,\n\t\t},\n\t\t{\n\t\t\tname: \"basic-err-uint32\",\n\t\t\tjson: `{\n\t\t\t\t\t\t\"testStr\": \"hello world!\",\n\t\t\t\t\t\t\"testInt\": 4535,\n\t\t\t\t\t\t\"testBool\": true,\n\t\t\t\t\t\t\"testFloat32\": 2.345,\n\t\t\t\t\t\t\"testFloat64\": 123.677,\n\t\t\t\t\t\t\"testInt8\": 23,\n\t\t\t\t\t\t\"testInt16\": 1245,\n\t\t\t\t\t\t\"testInt32\": 456778,\n\t\t\t\t\t\t\"testInt64\": 1446685358,\n\t\t\t\t\t\t\"testUint8\": 255,\n\t\t\t\t\t\t\"testUint16\": 3455,\n\t\t\t\t\t\t\"testUint32\": 3x43443,\n\t\t\t\t\t\t\"testUint64\": 545665757\n\t\t\t\t\t}`,\n\t\t\texpectedResult: testObject{},\n\t\t\terr:            true,\n\t\t},\n\t\t{\n\t\t\tname: \"basic-err-uint64\",\n\t\t\tjson: `{\n\t\t\t\t\t\t\"testStr\": \"hello world!\",\n\t\t\t\t\t\t\"testInt\": 4535,\n\t\t\t\t\t\t\"testBool\": true,\n\t\t\t\t\t\t\"testFloat32\": 2.345,\n\t\t\t\t\t\t\"testFloat64\": 123.677,\n\t\t\t\t\t\t\"testInt8\": 23,\n\t\t\t\t\t\t\"testInt16\": 1245,\n\t\t\t\t\t\t\"testInt32\": 456778,\n\t\t\t\t\t\t\"testInt64\": 1446685358,\n\t\t\t\t\t\t\"testUint8\": 255,\n\t\t\t\t\t\t\"testUint16\": 3455,\n\t\t\t\t\t\t\"testUint32\": 343443,\n\t\t\t\t\t\t\"testUint64\": 5456x65757\n\t\t\t\t\t}`,\n\t\t\texpectedResult: testObject{},\n\t\t\terr:            true,\n\t\t},\n\t\t{\n\t\t\tname: \"basic-skip-data\",\n\t\t\tjson: `{\n\t\t\t\t\"testStr\": \"hello world!\",\n\t\t\t\t\"testInt\": 4535,\n\t\t\t\t\"testBool\": true,\n\t\t\t\t\"testFloat32\": 2.345,\n\t\t\t\t\"testFloat64\": 123.677,\n\t\t\t\t\"testInt8\": 23,\n\t\t\t\t\"skipObject\": {\n\t\t\t\t\t\"escapedString\": \"string with escaped \\\\n new line\"\n\t\t\t\t},\n\t\t\t\t\"testInt16\": 1245,\n\t\t\t\t\"testInt32\": 456778,\n\t\t\t\t\"testInt64\": 1446685358,\n\t\t\t\t\"testUint8\": 255,\n\t\t\t\t\"skipArray\": [[],[],{}],\n\t\t\t\t\"testUint16\": 3455,\n\t\t\t\t\"skipBool\": true,\n\t\t\t\t\"skipNull\": null,\n\t\t\t\t\"testUint32\": 343443,\n\t\t\t\t\"testUint64\": 545665757,\n\t\t\t\t\"skipString\": \"skipping string with escaped \\\\n new line\",\n\t\t\t\t\"skipInt\": 3,\n\t\t\t}`,\n\t\t\texpectedResult: testObject{\n\t\t\t\ttestStr:     \"hello world!\",\n\t\t\t\ttestInt:     4535,\n\t\t\t\ttestBool:    true,\n\t\t\t\ttestFloat32: 2.345,\n\t\t\t\ttestFloat64: 123.677,\n\t\t\t\ttestInt8:    23,\n\t\t\t\ttestInt16:   1245,\n\t\t\t\ttestInt32:   456778,\n\t\t\t\ttestInt64:   1446685358,\n\t\t\t\ttestUint8:   255,\n\t\t\t\ttestUint16:  3455,\n\t\t\t\ttestUint32:  343443,\n\t\t\t\ttestUint64:  545665757,\n\t\t\t},\n\t\t\terr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"basic-skip-data-error-uint8-negative\",\n\t\t\tjson: `{\n\t\t\t\t\"testStr\": \"hello world!\",\n\t\t\t\t\"testInt\": 4535,\n\t\t\t\t\"testBool\": true,\n\t\t\t\t\"testFloat32\": 2.345,\n\t\t\t\t\"testFloat64\": 123.677,\n\t\t\t\t\"testInt8\": 23,\n\t\t\t\t\"skipObject\": {\n\t\t\t\t\t\"escapedString\": \"string with escaped \\\\n new line\"\n\t\t\t\t},\n\t\t\t\t\"testInt16\": 1245,\n\t\t\t\t\"testInt32\": 456778,\n\t\t\t\t\"testInt64\": 1446685358,\n\t\t\t\t\"testUint8\": -255,\n\t\t\t\t\"skipArray\": [[],[],{}],\n\t\t\t\t\"testUint16\": 3455,\n\t\t\t\t\"skipBool\": true,\n\t\t\t\t\"skipNull\": null,\n\t\t\t\t\"testUint32\": 343443,\n\t\t\t\t\"testUint64\": 545665757,\n\t\t\t\t\"skipString\": \"skipping string with escaped \\\\n new line\",\n\t\t\t\t\"skipInt\": 3\n\t\t\t}`,\n\t\t\texpectedResult: testObject{\n\t\t\t\ttestStr:     \"hello world!\",\n\t\t\t\ttestInt:     4535,\n\t\t\t\ttestBool:    true,\n\t\t\t\ttestFloat32: 2.345,\n\t\t\t\ttestFloat64: 123.677,\n\t\t\t\ttestInt8:    23,\n\t\t\t\ttestInt16:   1245,\n\t\t\t\ttestInt32:   456778,\n\t\t\t\ttestInt64:   1446685358,\n\t\t\t\ttestUint8:   0,\n\t\t\t\ttestUint16:  3455,\n\t\t\t\ttestUint32:  343443,\n\t\t\t\ttestUint64:  545665757,\n\t\t\t},\n\t\t\terr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"skip-data-with-unicode\",\n\t\t\tjson: `{\n\t\t\t\t\"skipString\": \"hello\\u1234\\u2123\",\n\t\t\t\t\"testStr\": \"hello world!\",\n\t\t\t\t\"testInt\": 4535,\n\t\t\t\t\"testBool\": true,\n\t\t\t\t\"testFloat32\": 2.345,\n\t\t\t\t\"testFloat64\": 123.677,\n\t\t\t\t\"testInt8\": 23,\n\t\t\t\t\"skipObject\": {\n\t\t\t\t\t\"escapedString\": \"string with unicode \\u1234\\u1234\\u1234\"\n\t\t\t\t},\n\t\t\t\t\"testInt16\": 1245,\n\t\t\t\t\"testInt32\": 456778,\n\t\t\t\t\"testInt64\": 1446685358,\n\t\t\t\t\"testUint8\": 255,\n\t\t\t\t\"skipArray\": [[],[],{}],\n\t\t\t\t\"testUint16\": 3455,\n\t\t\t\t\"skipBool\": true,\n\t\t\t\t\"skipNull\": null,\n\t\t\t\t\"testUint32\": 343443,\n\t\t\t\t\"testUint64\": 545665757,\n\t\t\t\t\"skipInt\": 3\n\t\t\t}`,\n\t\t\texpectedResult: testObject{\n\t\t\t\ttestStr:     \"hello world!\",\n\t\t\t\ttestInt:     4535,\n\t\t\t\ttestBool:    true,\n\t\t\t\ttestFloat32: 2.345,\n\t\t\t\ttestFloat64: 123.677,\n\t\t\t\ttestInt8:    23,\n\t\t\t\ttestInt16:   1245,\n\t\t\t\ttestInt32:   456778,\n\t\t\t\ttestInt64:   1446685358,\n\t\t\t\ttestUint8:   255,\n\t\t\t\ttestUint16:  3455,\n\t\t\t\ttestUint32:  343443,\n\t\t\t\ttestUint64:  545665757,\n\t\t\t},\n\t\t\terr: false,\n\t\t},\n\t}\n\n\tfor _, testCase := range testCases {\n\t\tt.Run(testCase.name, func(t *testing.T) {\n\t\t\ts := testObject{}\n\t\t\tdec := BorrowDecoder(strings.NewReader(testCase.json))\n\t\t\tdefer dec.Release()\n\t\t\terr := dec.Decode(&s)\n\t\t\tif testCase.err {\n\t\t\t\tt.Log(err)\n\t\t\t\tassert.NotNil(t, err, \"err should not be nil\")\n\t\t\t\tif testCase.errType != nil {\n\t\t\t\t\tassert.IsType(t, testCase.errType, err, \"err should be of the given type\")\n\t\t\t\t}\n\t\t\t\treturn\n\t\t\t}\n\t\t\tassert.Nil(t, err, \"err should be nil\")\n\t\t\tif !testCase.skipCheckResult {\n\t\t\t\tassert.Equal(t, testCase.expectedResult, s, \"value at given index should be the same as expected results\")\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestDecodeObjectBasic0Keys(t *testing.T) {\n\ttestCases := []struct {\n\t\tname            string\n\t\tjson            string\n\t\texpectedResult  testObject0Keys\n\t\terr             bool\n\t\terrType         interface{}\n\t\tskipCheckResult bool\n\t}{\n\t\t{\n\t\t\tname: \"basic\",\n\t\t\tjson: `{\n\t\t\t\t\t\t\"testStr\": \"hello world!\",\n\t\t\t\t\t\t\"testInt\": 4535,\n\t\t\t\t\t\t\"testBool\": true,\n\t\t\t\t\t\t\"testFloat32\": 2.345,\n\t\t\t\t\t\t\"testFloat64\": 123.677,\n\t\t\t\t\t\t\"testInt8\": 23,\n\t\t\t\t\t\t\"testInt16\": 1245,\n\t\t\t\t\t\t\"testInt32\": 456778,\n\t\t\t\t\t\t\"testInt64\": 1446685358,\n\t\t\t\t\t\t\"testUint8\": 255,\n\t\t\t\t\t\t\"testUint16\": 3455,\n\t\t\t\t\t\t\"testUint32\": 343443,\n\t\t\t\t\t\t\"testUint64\": 545665757\n\t\t\t\t\t}`,\n\t\t\texpectedResult: testObject0Keys{\n\t\t\t\ttestStr:     \"hello world!\",\n\t\t\t\ttestInt:     4535,\n\t\t\t\ttestBool:    true,\n\t\t\t\ttestFloat32: 2.345,\n\t\t\t\ttestFloat64: 123.677,\n\t\t\t\ttestInt8:    23,\n\t\t\t\ttestInt16:   1245,\n\t\t\t\ttestInt32:   456778,\n\t\t\t\ttestInt64:   1446685358,\n\t\t\t\ttestUint8:   255,\n\t\t\t\ttestUint16:  3455,\n\t\t\t\ttestUint32:  343443,\n\t\t\t\ttestUint64:  545665757,\n\t\t\t},\n\t\t\terr: false,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-err-invalid-type\",\n\t\t\tjson:           `1`,\n\t\t\texpectedResult: testObject0Keys{},\n\t\t\terr:            true,\n\t\t\terrType:        InvalidUnmarshalError(\"\"),\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-err-invalid-json\",\n\t\t\tjson:           `hello`,\n\t\t\texpectedResult: testObject0Keys{},\n\t\t\terr:            true,\n\t\t\terrType:        InvalidJSONError(\"\"),\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-err-invalid-json\",\n\t\t\tjson:           `nall`,\n\t\t\texpectedResult: testObject0Keys{},\n\t\t\terr:            true,\n\t\t\terrType:        InvalidJSONError(\"\"),\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-err-invalid-type\",\n\t\t\tjson:           ``,\n\t\t\texpectedResult: testObject0Keys{},\n\t\t\terr:            true,\n\t\t\terrType:        InvalidJSONError(\"\"),\n\t\t},\n\t\t{\n\t\t\tname: \"basic-err\",\n\t\t\tjson: `{\n\t\t\t\t\t\t\"testStr\": \"hello world!\",\n\t\t\t\t\t\t\"testInt\": 453q5,\n\t\t\t\t\t\t\"testBool\": trae,\n\t\t\t\t\t\t\"testFloat32\": 2q.345,\n\t\t\t\t\t\t\"testFloat64\": 12x3.677,\n\t\t\t\t\t\t\"testInt8\": 2s3,\n\t\t\t\t\t\t\"testInt16\": 1245,\n\t\t\t\t\t\t\"testInt32\": 4567q78,\n\t\t\t\t\t\t\"testInt64\": 14466e85358,\n\t\t\t\t\t\t\"testUint8\": 2s55,\n\t\t\t\t\t\t\"testUint16\": 345i5,\n\t\t\t\t\t\t\"testUint32\": 343q443,\n\t\t\t\t\t\t\"testUint64\": 5456657z57\n\t\t\t\t\t}`,\n\t\t\texpectedResult: testObject0Keys{},\n\t\t\terr:            true,\n\t\t},\n\t\t{\n\t\t\tname: \"basic-err2\",\n\t\t\tjson: `{\n\t\t\t\t\t\t\"testStr\": \"hello world!\",\n\t\t\t\t\t\t\"testInt\": 4535,\n\t\t\t\t\t\t\"testBool\": true,\n\t\t\t\t\t\t\"testFloat32\": 2.345,\n\t\t\t\t\t\t\"testFloat64\": 123.677,\n\t\t\t\t\t\t\"testInt8\": 23,\n\t\t\t\t\t\t\"testInt16\": 1245,\n\t\t\t\t\t\t\"testInt32\": 4567x78,\n\t\t\t\t\t\t\"testInt64\": 1446685358,\n\t\t\t\t\t\t\"testUint8\": 255,\n\t\t\t\t\t\t\"testUint16\": 3455,\n\t\t\t\t\t\t\"testUint32\": 343443,\n\t\t\t\t\t\t\"testUint64\": 545665757\n\t\t\t\t\t}`,\n\t\t\texpectedResult: testObject0Keys{},\n\t\t\terr:            true,\n\t\t},\n\t\t{\n\t\t\tname: \"basic-err-float32\",\n\t\t\tjson: `{\n\t\t\t\t\t\t\"testStr\": \"hello world!\",\n\t\t\t\t\t\t\"testInt\": 4535,\n\t\t\t\t\t\t\"testBool\": true,\n\t\t\t\t\t\t\"testFloat32\": 2q.345,\n\t\t\t\t\t\t\"testFloat64\": 123.677,\n\t\t\t\t\t\t\"testInt8\": 23,\n\t\t\t\t\t\t\"testInt16\": 1245,\n\t\t\t\t\t\t\"testInt32\": 456778,\n\t\t\t\t\t\t\"testInt64\": 1446685358,\n\t\t\t\t\t\t\"testUint8\": 255,\n\t\t\t\t\t\t\"testUint16\": 3455,\n\t\t\t\t\t\t\"testUint32\": 343443,\n\t\t\t\t\t\t\"testUint64\": 545665757\n\t\t\t\t\t}`,\n\t\t\texpectedResult: testObject0Keys{},\n\t\t\terr:            true,\n\t\t},\n\t\t{\n\t\t\tname: \"basic-err-float64\",\n\t\t\tjson: `{\n\t\t\t\t\t\t\"testStr\": \"hello world!\",\n\t\t\t\t\t\t\"testInt\": 4535,\n\t\t\t\t\t\t\"testBool\": true,\n\t\t\t\t\t\t\"testFloat32\": 2.345,\n\t\t\t\t\t\t\"testFloat64\": 1x23.677,\n\t\t\t\t\t\t\"testInt8\": 23,\n\t\t\t\t\t\t\"testInt16\": 1245,\n\t\t\t\t\t\t\"testInt32\": 456778,\n\t\t\t\t\t\t\"testInt64\": 1446685358,\n\t\t\t\t\t\t\"testUint8\": 255,\n\t\t\t\t\t\t\"testUint16\": 3455,\n\t\t\t\t\t\t\"testUint32\": 343443,\n\t\t\t\t\t\t\"testUint64\": 545665757\n\t\t\t\t\t}`,\n\t\t\texpectedResult: testObject0Keys{},\n\t\t\terr:            true,\n\t\t},\n\t\t{\n\t\t\tname: \"basic-err3\",\n\t\t\tjson: `{\n\t\t\t\t\t\t\"testStr\": \"hello world!\",\n\t\t\t\t\t\t\"testInt\": 4535,\n\t\t\t\t\t\t\"testBool\": true,\n\t\t\t\t\t\t\"testFloat32\": 2.345,\n\t\t\t\t\t\t\"testFloat64\": 123.677,\n\t\t\t\t\t\t\"testInt8\": 2q3,\n\t\t\t\t\t\t\"testInt16\": 1245,\n\t\t\t\t\t\t\"testInt32\": 456778,\n\t\t\t\t\t\t\"testInt64\": 1446685358,\n\t\t\t\t\t\t\"testUint8\": 255,\n\t\t\t\t\t\t\"testUint16\": 3455,\n\t\t\t\t\t\t\"testUint32\": 343443,\n\t\t\t\t\t\t\"testUint64\": 545665757\n\t\t\t\t\t}`,\n\t\t\texpectedResult: testObject0Keys{},\n\t\t\terr:            true,\n\t\t},\n\t\t{\n\t\t\tname: \"basic-err-int16\",\n\t\t\tjson: `{\n\t\t\t\t\t\t\"testStr\": \"hello world!\",\n\t\t\t\t\t\t\"testInt\": 4535,\n\t\t\t\t\t\t\"testBool\": true,\n\t\t\t\t\t\t\"testFloat32\": 2.345,\n\t\t\t\t\t\t\"testFloat64\": 123.677,\n\t\t\t\t\t\t\"testInt8\": 23,\n\t\t\t\t\t\t\"testInt16\": 1x245,\n\t\t\t\t\t\t\"testInt32\": 456778,\n\t\t\t\t\t\t\"testInt64\": 1446685358,\n\t\t\t\t\t\t\"testUint8\": 255,\n\t\t\t\t\t\t\"testUint16\": 3455,\n\t\t\t\t\t\t\"testUint32\": 343443,\n\t\t\t\t\t\t\"testUint64\": 545665757\n\t\t\t\t\t}`,\n\t\t\texpectedResult: testObject0Keys{},\n\t\t\terr:            true,\n\t\t},\n\t\t{\n\t\t\tname: \"basic-err-int64\",\n\t\t\tjson: `{\n\t\t\t\t\t\t\"testStr\": \"hello world!\",\n\t\t\t\t\t\t\"testInt\": 4535,\n\t\t\t\t\t\t\"testBool\": true,\n\t\t\t\t\t\t\"testFloat32\": 2.345,\n\t\t\t\t\t\t\"testFloat64\": 123.677,\n\t\t\t\t\t\t\"testInt8\": 23,\n\t\t\t\t\t\t\"testInt16\": 1245,\n\t\t\t\t\t\t\"testInt32\": 456778,\n\t\t\t\t\t\t\"testInt64\": 1446q685358,\n\t\t\t\t\t\t\"testUint8\": 255,\n\t\t\t\t\t\t\"testUint16\": 3455,\n\t\t\t\t\t\t\"testUint32\": 343443,\n\t\t\t\t\t\t\"testUint64\": 545665757\n\t\t\t\t\t}`,\n\t\t\texpectedResult: testObject0Keys{},\n\t\t\terr:            true,\n\t\t},\n\t\t{\n\t\t\tname: \"basic-err-uint8\",\n\t\t\tjson: `{\n\t\t\t\t\t\t\"testStr\": \"hello world!\",\n\t\t\t\t\t\t\"testInt\": 4535,\n\t\t\t\t\t\t\"testBool\": true,\n\t\t\t\t\t\t\"testFloat32\": 2.345,\n\t\t\t\t\t\t\"testFloat64\": 123.677,\n\t\t\t\t\t\t\"testInt8\": 23,\n\t\t\t\t\t\t\"testInt16\": 1245,\n\t\t\t\t\t\t\"testInt32\": 456778,\n\t\t\t\t\t\t\"testInt64\": 1446685358,\n\t\t\t\t\t\t\"testUint8\": 2x55,\n\t\t\t\t\t\t\"testUint16\": 3455,\n\t\t\t\t\t\t\"testUint32\": 343443,\n\t\t\t\t\t\t\"testUint64\": 545665757\n\t\t\t\t\t}`,\n\t\t\texpectedResult: testObject0Keys{},\n\t\t\terr:            true,\n\t\t},\n\t\t{\n\t\t\tname: \"basic-err-uint16\",\n\t\t\tjson: `{\n\t\t\t\t\t\t\"testStr\": \"hello world!\",\n\t\t\t\t\t\t\"testInt\": 4535,\n\t\t\t\t\t\t\"testBool\": true,\n\t\t\t\t\t\t\"testFloat32\": 2.345,\n\t\t\t\t\t\t\"testFloat64\": 123.677,\n\t\t\t\t\t\t\"testInt8\": 23,\n\t\t\t\t\t\t\"testInt16\": 1245,\n\t\t\t\t\t\t\"testInt32\": 456778,\n\t\t\t\t\t\t\"testInt64\": 1446685358,\n\t\t\t\t\t\t\"testUint8\": 255,\n\t\t\t\t\t\t\"testUint16\": 3x455,\n\t\t\t\t\t\t\"testUint32\": 343443,\n\t\t\t\t\t\t\"testUint64\": 545665757\n\t\t\t\t\t}`,\n\t\t\texpectedResult: testObject0Keys{},\n\t\t\terr:            true,\n\t\t},\n\t\t{\n\t\t\tname: \"basic-err-uint32\",\n\t\t\tjson: `{\n\t\t\t\t\t\t\"testStr\": \"hello world!\",\n\t\t\t\t\t\t\"testInt\": 4535,\n\t\t\t\t\t\t\"testBool\": true,\n\t\t\t\t\t\t\"testFloat32\": 2.345,\n\t\t\t\t\t\t\"testFloat64\": 123.677,\n\t\t\t\t\t\t\"testInt8\": 23,\n\t\t\t\t\t\t\"testInt16\": 1245,\n\t\t\t\t\t\t\"testInt32\": 456778,\n\t\t\t\t\t\t\"testInt64\": 1446685358,\n\t\t\t\t\t\t\"testUint8\": 255,\n\t\t\t\t\t\t\"testUint16\": 3455,\n\t\t\t\t\t\t\"testUint32\": 3x43443,\n\t\t\t\t\t\t\"testUint64\": 545665757\n\t\t\t\t\t}`,\n\t\t\texpectedResult: testObject0Keys{},\n\t\t\terr:            true,\n\t\t},\n\t\t{\n\t\t\tname: \"basic-err-uint64\",\n\t\t\tjson: `{\n\t\t\t\t\t\t\"testStr\": \"hello world!\",\n\t\t\t\t\t\t\"testInt\": 4535,\n\t\t\t\t\t\t\"testBool\": true,\n\t\t\t\t\t\t\"testFloat32\": 2.345,\n\t\t\t\t\t\t\"testFloat64\": 123.677,\n\t\t\t\t\t\t\"testInt8\": 23,\n\t\t\t\t\t\t\"testInt16\": 1245,\n\t\t\t\t\t\t\"testInt32\": 456778,\n\t\t\t\t\t\t\"testInt64\": 1446685358,\n\t\t\t\t\t\t\"testUint8\": 255,\n\t\t\t\t\t\t\"testUint16\": 3455,\n\t\t\t\t\t\t\"testUint32\": 343443,\n\t\t\t\t\t\t\"testUint64\": 5456x65757\n\t\t\t\t\t}`,\n\t\t\texpectedResult: testObject0Keys{},\n\t\t\terr:            true,\n\t\t},\n\t\t{\n\t\t\tname: \"basic-skip-data\",\n\t\t\tjson: `{\n\t\t\t\t\"testStr\": \"hello world!\",\n\t\t\t\t\"testInt\": 4535,\n\t\t\t\t\"testBool\": true,\n\t\t\t\t\"testFloat32\": 2.345,\n\t\t\t\t\"testFloat64\": 123.677,\n\t\t\t\t\"testInt8\": 23,\n\t\t\t\t\"skipObject\": {\n\t\t\t\t\t\"escapedString\": \"string with escaped \\\\n new line\"\n\t\t\t\t},\n\t\t\t\t\"testInt16\": 1245,\n\t\t\t\t\"testInt32\": 456778,\n\t\t\t\t\"testInt64\": 1446685358,\n\t\t\t\t\"testUint8\": 255,\n\t\t\t\t\"skipArray\": [[],[],{}],\n\t\t\t\t\"testUint16\": 3455,\n\t\t\t\t\"skipBool\": true,\n\t\t\t\t\"skipNull\": null,\n\t\t\t\t\"testUint32\": 343443,\n\t\t\t\t\"testUint64\": 545665757,\n\t\t\t\t\"skipString\": \"skipping string with escaped \\\\n new line\",\n\t\t\t\t\"skipInt\": 3,\n\t\t\t}`,\n\t\t\texpectedResult: testObject0Keys{\n\t\t\t\ttestStr:     \"hello world!\",\n\t\t\t\ttestInt:     4535,\n\t\t\t\ttestBool:    true,\n\t\t\t\ttestFloat32: 2.345,\n\t\t\t\ttestFloat64: 123.677,\n\t\t\t\ttestInt8:    23,\n\t\t\t\ttestInt16:   1245,\n\t\t\t\ttestInt32:   456778,\n\t\t\t\ttestInt64:   1446685358,\n\t\t\t\ttestUint8:   255,\n\t\t\t\ttestUint16:  3455,\n\t\t\t\ttestUint32:  343443,\n\t\t\t\ttestUint64:  545665757,\n\t\t\t},\n\t\t\terr: false,\n\t\t},\n\t}\n\n\tfor _, testCase := range testCases {\n\t\tt.Run(testCase.name, func(t *testing.T) {\n\t\t\ts := testObject0Keys{}\n\t\t\tdec := BorrowDecoder(strings.NewReader(testCase.json))\n\t\t\tdefer dec.Release()\n\t\t\terr := dec.Decode(&s)\n\t\t\tif testCase.err {\n\t\t\t\tt.Log(err)\n\t\t\t\tassert.NotNil(t, err, \"err should not be nil\")\n\t\t\t\tif testCase.errType != nil {\n\t\t\t\t\tassert.IsType(t, testCase.errType, err, \"err should be of the given type\")\n\t\t\t\t}\n\t\t\t\treturn\n\t\t\t}\n\t\t\tassert.Nil(t, err, \"err should be nil\")\n\t\t\tif !testCase.skipCheckResult {\n\t\t\t\tassert.Equal(t, testCase.expectedResult, s, \"value at given index should be the same as expected results\")\n\t\t\t}\n\t\t})\n\t}\n\tfor _, testCase := range testCases {\n\t\tt.Run(testCase.name, func(t *testing.T) {\n\t\t\ts := testObject0Keys{}\n\t\t\terr := UnmarshalJSONObject([]byte(testCase.json), &s)\n\t\t\tif testCase.err {\n\t\t\t\tt.Log(err)\n\t\t\t\tassert.NotNil(t, err, \"err should not be nil\")\n\t\t\t\tif testCase.errType != nil {\n\t\t\t\t\tassert.IsType(t, testCase.errType, err, \"err should be of the given type\")\n\t\t\t\t}\n\t\t\t\treturn\n\t\t\t}\n\t\t\tassert.Nil(t, err, \"err should be nil\")\n\t\t\tif !testCase.skipCheckResult {\n\t\t\t\tassert.Equal(t, testCase.expectedResult, s, \"value at given index should be the same as expected results\")\n\t\t\t}\n\t\t})\n\t}\n}\n\ntype ObjectNull struct {\n\tSubObject *ObjectNull\n\tSubArray  *testSliceBools\n}\n\nfunc (o *ObjectNull) UnmarshalJSONObject(dec *Decoder, k string) error {\n\tswitch k {\n\tcase \"subobject\":\n\t\treturn dec.ObjectNull(&o.SubObject)\n\tcase \"subarray\":\n\t\treturn dec.AddArrayNull(&o.SubArray)\n\t}\n\treturn nil\n}\n\nfunc (o *ObjectNull) NKeys() int {\n\treturn 2\n}\n\ntype ObjectNullZeroNKeys struct {\n\tSubObject *ObjectNullZeroNKeys\n\tSubArray  *testSliceBools\n}\n\nfunc (o *ObjectNullZeroNKeys) UnmarshalJSONObject(dec *Decoder, k string) error {\n\tswitch k {\n\tcase \"subobject\":\n\t\treturn dec.AddObjectNull(&o.SubObject)\n\tcase \"subarray\":\n\t\treturn dec.AddArrayNull(&o.SubArray)\n\t}\n\treturn nil\n}\n\nfunc (o *ObjectNullZeroNKeys) NKeys() int {\n\treturn 0\n}\n\nfunc TestDecodeObjectNull(t *testing.T) {\n\tt.Run(\"sub obj should not be nil\", func(t *testing.T) {\n\t\tvar o = &ObjectNull{}\n\t\tvar err = UnmarshalJSONObject([]byte(`{\"subobject\": {},\"subarray\":[true]}`), o)\n\t\tassert.Nil(t, err)\n\t\tassert.NotNil(t, o.SubObject)\n\t\tassert.NotNil(t, o.SubArray)\n\t})\n\tt.Run(\"sub obj and sub array should be nil\", func(t *testing.T) {\n\t\tvar o = &ObjectNull{}\n\t\tvar err = UnmarshalJSONObject([]byte(`{\"subobject\": null,\"subarray\": null}`), o)\n\t\tassert.Nil(t, err)\n\t\tassert.Nil(t, o.SubObject)\n\t\tassert.Nil(t, o.SubArray)\n\t})\n\tt.Run(\n\t\t\"sub obj should not be be nil\",\n\t\tfunc(t *testing.T) {\n\t\t\tvar o = &ObjectNull{}\n\t\t\tvar err = UnmarshalJSONObject([]byte(`{\"subobject\":{\"subobject\":{}}}`), DecodeObjectFunc(func(dec *Decoder, k string) error {\n\t\t\t\treturn dec.ObjectNull(&o.SubObject)\n\t\t\t}))\n\t\t\tassert.Nil(t, err)\n\t\t\tassert.NotNil(t, o.SubObject)\n\t\t},\n\t)\n\tt.Run(\n\t\t\"sub obj should be nil\",\n\t\tfunc(t *testing.T) {\n\t\t\tvar o = &ObjectNull{}\n\t\t\tvar err = UnmarshalJSONObject([]byte(`{\"subobject\":null}`), DecodeObjectFunc(func(dec *Decoder, k string) error {\n\t\t\t\treturn dec.ObjectNull(&o.SubObject)\n\t\t\t}))\n\t\t\tassert.Nil(t, err)\n\t\t\tassert.Nil(t, o.SubObject)\n\t\t},\n\t)\n\tt.Run(\n\t\t\"skip data\",\n\t\tfunc(t *testing.T) {\n\t\t\tvar o = &ObjectNull{}\n\t\t\tvar err = UnmarshalJSONObject([]byte(`{\n\t\t\t\t\"subobject\": {\n\t\t\t\t\t\"subobject\": {},\n\t\t\t\t\t\"subarray\": [],\n\t\t\t\t\t\"subarray\": [],\n\t\t\t\t\t\"skipped\": \"\"\n\t\t\t\t}\n\t\t\t}`), DecodeObjectFunc(func(dec *Decoder, k string) error {\n\t\t\t\treturn dec.ObjectNull(&o.SubObject)\n\t\t\t}))\n\t\t\tassert.Nil(t, err)\n\t\t\tassert.NotNil(t, o.SubObject)\n\t\t\tassert.Nil(t, o.SubArray)\n\t\t},\n\t)\n\tt.Run(\n\t\t\"skip data not child\",\n\t\tfunc(t *testing.T) {\n\t\t\tvar o = &ObjectNull{}\n\t\t\tvar dec = NewDecoder(strings.NewReader(`{\n\t\t\t\t\t\"subobject\": {},\n\t\t\t\t\t\"subarray\": [],\n\t\t\t\t\t\"subarray\": [],\n\t\t\t\t\t\"skipped\": \"\"\n\t\t\t}`))\n\t\t\tvar _, err = dec.decodeObjectNull(&o)\n\t\t\tassert.Nil(t, err)\n\t\t\tassert.NotNil(t, o.SubObject)\n\t\t},\n\t)\n\tt.Run(\n\t\t\"err empty json\",\n\t\tfunc(t *testing.T) {\n\t\t\tvar o = &ObjectNull{}\n\t\t\tvar dec = NewDecoder(strings.NewReader(``))\n\t\t\tvar _, err = dec.decodeObjectNull(&o)\n\t\t\tassert.NotNil(t, err)\n\t\t},\n\t)\n\tt.Run(\n\t\t\"should return an error as type is not ptr\",\n\t\tfunc(t *testing.T) {\n\t\t\tvar err = UnmarshalJSONObject([]byte(`{\"key\":{}}`), DecodeObjectFunc(func(dec *Decoder, k string) error {\n\t\t\t\treturn dec.ObjectNull(\"\")\n\t\t\t}))\n\t\t\tassert.NotNil(t, err)\n\t\t\tassert.Equal(t, ErrUnmarshalPtrExpected, err)\n\t\t},\n\t)\n\tt.Run(\n\t\t\"should return an error as type is not ptr\",\n\t\tfunc(t *testing.T) {\n\t\t\tvar err = UnmarshalJSONObject([]byte(`{\"key\":[]}`), DecodeObjectFunc(func(dec *Decoder, k string) error {\n\t\t\t\treturn dec.ArrayNull(\"\")\n\t\t\t}))\n\t\t\tassert.NotNil(t, err)\n\t\t\tassert.Equal(t, ErrUnmarshalPtrExpected, err)\n\t\t},\n\t)\n\tt.Run(\n\t\t\"should return an error as type is not ptr to UnmarshalerJSONObject\",\n\t\tfunc(t *testing.T) {\n\t\t\tvar err = UnmarshalJSONObject([]byte(`{\"key\":{}}`), DecodeObjectFunc(func(dec *Decoder, k string) error {\n\t\t\t\tvar strPtr = new(string)\n\t\t\t\treturn dec.ObjectNull(&strPtr)\n\t\t\t}))\n\t\t\tassert.NotNil(t, err)\n\t\t\tassert.IsType(t, InvalidUnmarshalError(\"\"), err)\n\t\t},\n\t)\n\tt.Run(\n\t\t\"should return an error as type is not ptr to UnmarshalerJSONObject\",\n\t\tfunc(t *testing.T) {\n\t\t\tvar err = UnmarshalJSONObject([]byte(`{\"key\":[]}`), DecodeObjectFunc(func(dec *Decoder, k string) error {\n\t\t\t\tvar strPtr = new(string)\n\t\t\t\treturn dec.ArrayNull(&strPtr)\n\t\t\t}))\n\t\t\tassert.NotNil(t, err)\n\t\t\tassert.IsType(t, InvalidUnmarshalError(\"\"), err)\n\t\t},\n\t)\n\tt.Run(\n\t\t\"should return an error as type is not ptr to UnmarshalerJSONObject\",\n\t\tfunc(t *testing.T) {\n\t\t\tvar err = UnmarshalJSONObject([]byte(`{\"key\":{}}`), DecodeObjectFunc(func(dec *Decoder, k string) error {\n\t\t\t\tvar strPtr = new(string)\n\t\t\t\treturn dec.ArrayNull(&strPtr)\n\t\t\t}))\n\t\t\tassert.NotNil(t, err)\n\t\t\tassert.IsType(t, InvalidUnmarshalError(\"\"), err)\n\t\t},\n\t)\n\tt.Run(\n\t\t\"should return an error as type is not ptr to UnmarshalerJSONObject\",\n\t\tfunc(t *testing.T) {\n\t\t\tvar err = UnmarshalJSONObject([]byte(`{\"key\":\"`), DecodeObjectFunc(func(dec *Decoder, k string) error {\n\t\t\t\tvar strPtr = new(string)\n\t\t\t\treturn dec.ArrayNull(&strPtr)\n\t\t\t}))\n\t\t\tassert.NotNil(t, err)\n\t\t\tassert.IsType(t, InvalidJSONError(\"\"), err)\n\t\t},\n\t)\n\tt.Run(\n\t\t\"skip data\",\n\t\tfunc(t *testing.T) {\n\t\t\tvar err = UnmarshalJSONObject([]byte(`{\"key\": \"\"}`), DecodeObjectFunc(func(dec *Decoder, k string) error {\n\t\t\t\tvar strPtr = new(string)\n\t\t\t\treturn dec.ObjectNull(&strPtr)\n\t\t\t}))\n\t\t\tassert.NotNil(t, err)\n\t\t\tassert.IsType(t, InvalidUnmarshalError(\"\"), err)\n\t\t},\n\t)\n\tt.Run(\n\t\t\"invalid JSON for object\",\n\t\tfunc(t *testing.T) {\n\t\t\tvar o = &ObjectNull{}\n\t\t\tvar err = UnmarshalJSONObject([]byte(`{\"subobject\":{\"subobject\":{\"a\":a}`), DecodeObjectFunc(func(dec *Decoder, k string) error {\n\t\t\t\treturn dec.ObjectNull(&o.SubObject)\n\t\t\t}))\n\t\t\tassert.NotNil(t, err)\n\t\t\tassert.IsType(t, InvalidJSONError(\"\"), err)\n\t\t},\n\t)\n\tt.Run(\n\t\t\"invalid JSON for object\",\n\t\tfunc(t *testing.T) {\n\t\t\tvar o = &ObjectNull{}\n\t\t\tvar err = UnmarshalJSONObject([]byte(`{\"subobject\":{\"subobject\":a}`), DecodeObjectFunc(func(dec *Decoder, k string) error {\n\t\t\t\treturn dec.ObjectNull(&o.SubObject)\n\t\t\t}))\n\t\t\tassert.NotNil(t, err)\n\t\t\tassert.IsType(t, InvalidJSONError(\"\"), err)\n\t\t},\n\t)\n\tt.Run(\n\t\t\"invalid JSON for object\",\n\t\tfunc(t *testing.T) {\n\t\t\tvar o = &ObjectNull{}\n\t\t\tvar err = UnmarshalJSONObject([]byte(`{\"subobject\":{\"subobject\":{\"sub}}`), DecodeObjectFunc(func(dec *Decoder, k string) error {\n\t\t\t\treturn dec.ObjectNull(&o.SubObject)\n\t\t\t}))\n\t\t\tassert.NotNil(t, err)\n\t\t\tassert.IsType(t, InvalidJSONError(\"\"), err)\n\t\t},\n\t)\n\tt.Run(\n\t\t\"invalid JSON for object\",\n\t\tfunc(t *testing.T) {\n\t\t\tvar o = &testSliceBools{}\n\t\t\tvar err = UnmarshalJSONObject([]byte(`{\"subobject\":a`), DecodeObjectFunc(func(dec *Decoder, k string) error {\n\t\t\t\treturn dec.ArrayNull(&o)\n\t\t\t}))\n\t\t\tassert.NotNil(t, err)\n\t\t\tassert.IsType(t, InvalidJSONError(\"\"), err)\n\t\t},\n\t)\n\tt.Run(\n\t\t\"invalid JSON for object\",\n\t\tfunc(t *testing.T) {\n\t\t\tvar err = UnmarshalJSONObject([]byte(`{\"key\":a`), DecodeObjectFunc(func(dec *Decoder, k string) error {\n\t\t\t\tvar strPtr = new(string)\n\t\t\t\treturn dec.ObjectNull(&strPtr)\n\t\t\t}))\n\t\t\tassert.NotNil(t, err)\n\t\t\tassert.IsType(t, InvalidJSONError(\"\"), err)\n\t\t},\n\t)\n\tt.Run(\n\t\t\"invalid JSON for object\",\n\t\tfunc(t *testing.T) {\n\t\t\tvar err = UnmarshalJSONObject([]byte(`{\"subobject\": {},\"}`), DecodeObjectFunc(func(dec *Decoder, k string) error {\n\t\t\t\tvar o = &ObjectNull{}\n\t\t\t\treturn dec.ObjectNull(&o)\n\t\t\t}))\n\t\t\tassert.NotNil(t, err)\n\t\t\tassert.IsType(t, InvalidJSONError(\"\"), err)\n\t\t},\n\t)\n\tt.Run(\n\t\t\"invalid JSON for object\",\n\t\tfunc(t *testing.T) {\n\t\t\tvar o = &ObjectNull{}\n\t\t\tvar err = UnmarshalJSONObject([]byte(`{\"subobject\": a`), o)\n\t\t\tassert.NotNil(t, err)\n\t\t\tassert.IsType(t, InvalidJSONError(\"\"), err)\n\t\t},\n\t)\n\tt.Run(\n\t\t\"invalid JSON for object\",\n\t\tfunc(t *testing.T) {\n\t\t\tvar o = &ObjectNull{}\n\t\t\tvar err = UnmarshalJSONObject([]byte(`{\"subobject\": na`), o)\n\t\t\tassert.NotNil(t, err)\n\t\t\tassert.IsType(t, InvalidJSONError(\"\"), err)\n\t\t},\n\t)\n\tt.Run(\n\t\t\"zero nkeys, no error, two keys\",\n\t\tfunc(t *testing.T) {\n\t\t\tvar o = &ObjectNullZeroNKeys{}\n\t\t\tvar err = UnmarshalJSONObject([]byte(`{\n\t\t\t\t\"subobject\": {\n\t\t\t\t\t\"subobject\": {\n\t\t\t\t\t\t\"subobject\":{}\n\t\t\t\t\t},\n\t\t\t\t\t\"subarray\": []\n\t\t\t\t}\n\t\t\t}`), DecodeObjectFunc(func(dec *Decoder, k string) error {\n\t\t\t\treturn dec.ObjectNull(&o.SubObject)\n\t\t\t}))\n\t\t\tassert.Nil(t, err)\n\t\t},\n\t)\n\tt.Run(\n\t\t\"zero nkeys, no error, two keys, skip data\",\n\t\tfunc(t *testing.T) {\n\t\t\tvar o = &ObjectNullZeroNKeys{}\n\t\t\tvar err = UnmarshalJSONObject([]byte(`{\n\t\t\t\t\"subobject\": {\n\t\t\t\t\t\"subobject\": {\n\t\t\t\t\t\t\"subobject\":{}\n\t\t\t\t\t},\n\t\t\t\t\t\"subarray\": [],\n\t\t\t\t\t\"skipped\": 1\n\t\t\t\t}\n\t\t\t}`), DecodeObjectFunc(func(dec *Decoder, k string) error {\n\t\t\t\treturn dec.ObjectNull(&o.SubObject)\n\t\t\t}))\n\t\t\tassert.Nil(t, err)\n\t\t},\n\t)\n\tt.Run(\n\t\t\"zero nkeys, error skip data\",\n\t\tfunc(t *testing.T) {\n\t\t\tvar o = &ObjectNullZeroNKeys{}\n\t\t\tvar err = UnmarshalJSONObject([]byte(`{\n\t\t\t\t\"subobject\": {\n\t\t\t\t\t\"subobject\": {\n\t\t\t\t\t\t\"subobject\":{}\n\t\t\t\t\t},\n\t\t\t\t\t\"subarray\": [],\n\t\t\t\t\t\"skippedInvalid\": \"q\n\t\t\t\t}\n\t\t\t}`), DecodeObjectFunc(func(dec *Decoder, k string) error {\n\t\t\t\treturn dec.ObjectNull(&o.SubObject)\n\t\t\t}))\n\t\t\tassert.NotNil(t, err)\n\t\t\tassert.IsType(t, InvalidJSONError(\"\"), err)\n\t\t},\n\t)\n\tt.Run(\n\t\t\"zero nkeys, error invalid json in keys\",\n\t\tfunc(t *testing.T) {\n\t\t\tvar o = &ObjectNullZeroNKeys{}\n\t\t\tvar err = UnmarshalJSONObject([]byte(`{\n\t\t\t\t\"subobject\": {\n\t\t\t\t\t\"subobj\n\t\t\t\t}\n\t\t\t}`), DecodeObjectFunc(func(dec *Decoder, k string) error {\n\t\t\t\treturn dec.ObjectNull(&o.SubObject)\n\t\t\t}))\n\t\t\tassert.NotNil(t, err)\n\t\t\tassert.IsType(t, InvalidJSONError(\"\"), err)\n\t\t},\n\t)\n\tt.Run(\n\t\t\"zero nkeys, error invalid json, sub object\",\n\t\tfunc(t *testing.T) {\n\t\t\tvar o = &ObjectNullZeroNKeys{}\n\t\t\tvar err = UnmarshalJSONObject([]byte(`{\n\t\t\t\t\"subobject\": {\n\t\t\t\t\t\"subobject\": {\n\t\t\t\t\t\t\"subobj\n\t\t\t\t\t}\t\n\t\t\t\t}\n\t\t\t}`), DecodeObjectFunc(func(dec *Decoder, k string) error {\n\t\t\t\treturn dec.ObjectNull(&o.SubObject)\n\t\t\t}))\n\t\t\tassert.NotNil(t, err)\n\t\t\tassert.IsType(t, InvalidJSONError(\"\"), err)\n\t\t},\n\t)\n}\n\nfunc TestDecodeObjectComplex(t *testing.T) {\n\ttestCases := []struct {\n\t\tname            string\n\t\tjson            string\n\t\texpectedResult  testObjectComplex\n\t\terr             bool\n\t\terrType         interface{}\n\t\tskipCheckResult bool\n\t}{\n\t\t{\n\t\t\tname: \"basic\",\n\t\t\tjson: `{\n\t\t\t\t\"testSubObject\": {},\n\t\t\t\t\"testSubSliceInts\": [1,2]\n\t\t\t}`,\n\t\t\texpectedResult: testObjectComplex{\n\t\t\t\ttestSubObject:    &testObject{},\n\t\t\t\ttestSubSliceInts: &testSliceInts{1, 2},\n\t\t\t},\n\t\t\terr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"complex\",\n\t\t\tjson: `{\n\t\t\t\t\"testSubObject\": {\n\t\t\t\t\t\"testStr\": \"some string\",\n\t\t\t\t\t\"testInt\":124465,\n\t\t\t\t\t\"testUint16\":120,\n\t\t\t\t\t\"testUint8\":15,\n\t\t\t\t\t\"testInt16\":-135,\n\t\t\t\t\t\"testInt8\":-23\n\t\t\t\t},\n\t\t\t\t\"testSubSliceInts\": [1,2,3,4,5],\n\t\t\t\t\"testStr\": \"some \\n string\"\n\t\t\t}`,\n\t\t\texpectedResult: testObjectComplex{\n\t\t\t\ttestSubObject: &testObject{\n\t\t\t\t\ttestStr:    \"some string\",\n\t\t\t\t\ttestInt:    124465,\n\t\t\t\t\ttestUint16: 120,\n\t\t\t\t\ttestUint8:  15,\n\t\t\t\t\ttestInt16:  -135,\n\t\t\t\t\ttestInt8:   -23,\n\t\t\t\t},\n\t\t\t\ttestSubSliceInts: &testSliceInts{1, 2, 3, 4, 5},\n\t\t\t\ttestStr:          \"some \\n string\",\n\t\t\t},\n\t\t\terr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"complex-json-err\",\n\t\t\tjson: `{\"testSubObject\":{\"testStr\":\"some string,\"testInt\":124465,\"testUint16\":120, \"testUint8\":15,\"testInt16\":-135,\"testInt8\":-23},\"testSubSliceInts\":[1,2],\"testStr\":\"some \\n string\"}`,\n\t\t\texpectedResult: testObjectComplex{\n\t\t\t\ttestSubObject: &testObject{},\n\t\t\t},\n\t\t\terr: true,\n\t\t},\n\t}\n\n\tfor _, testCase := range testCases {\n\t\tt.Run(testCase.name, func(t *testing.T) {\n\t\t\ts := testObjectComplex{\n\t\t\t\ttestSubObject:    &testObject{},\n\t\t\t\ttestSubSliceInts: &testSliceInts{},\n\t\t\t}\n\t\t\tdec := BorrowDecoder(strings.NewReader(testCase.json))\n\t\t\tdefer dec.Release()\n\t\t\terr := dec.Decode(&s)\n\t\t\tif testCase.err {\n\t\t\t\tt.Log(err)\n\t\t\t\tassert.NotNil(t, err, \"err should not be nil\")\n\t\t\t\tif testCase.errType != nil {\n\t\t\t\t\tassert.IsType(t, testCase.errType, err, \"err should be of the given type\")\n\t\t\t\t}\n\t\t\t\treturn\n\t\t\t}\n\t\t\tassert.Nil(t, err, \"err should be nil\")\n\t\t\tif !testCase.skipCheckResult {\n\t\t\t\tassert.Equal(t, testCase.expectedResult, s, \"value at given index should be the same as expected results\")\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc assertResult(t *testing.T, v *TestObj, err error) {\n\tassert.Nil(t, err, \"Err must be nil\")\n\tassert.Equal(t, 245, v.test, \"v.test must be equal to 245\")\n\tassert.Equal(t, 246, v.test2, \"v.test2 must be equal to 246\")\n\tassert.Equal(t, \"string\", v.test3, \"v.test3 must be equal to 'string'\")\n\tassert.Equal(t, \"complex string with spaces and some slashes\\\"\", v.test4, \"v.test4 must be equal to 'string'\")\n\tassert.Equal(t, -1.15657654376543, v.test5, \"v.test5 must be equal to 1.15\")\n\tassert.Len(t, v.testArr, 2, \"v.testArr must be of len 2\")\n\n\tassert.Equal(t, 121, v.testSubObj.test3, \"v.testSubObj.test3 must be equal to 121\")\n\tassert.Equal(t, 122, v.testSubObj.test4, \"v.testSubObj.test4 must be equal to 122\")\n\tassert.Equal(t, \"string\", v.testSubObj.test5, \"v.testSubObj.test5 must be equal to 'string'\")\n\tassert.Equal(t, 150, v.testSubObj.testSubSubObj.test3, \"v.testSubObj.testSubSubObj.test3 must be equal to 150\")\n\tassert.Equal(t, 150, v.testSubObj.testSubSubObj2.test3, \"v.testSubObj.testSubSubObj2.test3 must be equal to 150\")\n\n\tassert.Equal(t, 122, v.testSubObj2.test3, \"v.testSubObj2.test3 must be equal to 121\")\n\tassert.Equal(t, 123, v.testSubObj2.test4, \"v.testSubObj2.test4 must be equal to 122\")\n\tassert.Equal(t, \"string\", v.testSubObj2.test5, \"v.testSubObj2.test5 must be equal to 'string'\")\n\tassert.Equal(t, 151, v.testSubObj2.testSubSubObj.test3, \"v.testSubObj2.testSubSubObj.test must be equal to 150\")\n}\n\nfunc TestDecoderObject(t *testing.T) {\n\tjson := []byte(`{\n\t\t\"test\": 245,\n\t\t\"test2\": 246,\n\t\t\"test3\": \"string\",\n\t\t\"test4\": \"complex string with spaces and some slashes\\\"\",\n\t\t\"test5\": -1.15657654376543,\n\t\t\"testNull\": null,\n\t\t\"testArr\": [\n\t\t\t{\n\t\t\t\t\"test\": 245,\n\t\t\t\t\"test2\": 246\n\t\t\t},\n\t\t\t{\n\t\t\t\t\"test\": 245,\n\t\t\t\t\"test2\": 246\n\t\t\t}\n\t\t],\n\t\t\"testSubObj\": {\n\t\t\t\"test\": 121,\n\t\t\t\"test2\": 122,\n\t\t\t\"testNull\": null,\n\t\t\t\"testSubSubObj\": {\n\t\t\t\t\"test\": 150,\n\t\t\t\t\"testNull\": null\n\t\t\t},\n\t\t\t\"testSubSubObj2\": {\n\t\t\t\t\"test\": 150\n\t\t\t},\n\t\t\t\"test3\": \"string\"\n\t\t\t\"testNull\": null,\n\t\t},\n\t\t\"testSubObj2\": {\n\t\t\t\"test\": 122,\n\t\t\t\"test3\": \"string\"\n\t\t\t\"testSubSubObj\": {\n\t\t\t\t\"test\": 151\n\t\t\t},\n\t\t\t\"test2\": 123\n\t\t}\n\t}`)\n\tv := &TestObj{}\n\terr := Unmarshal(json, v)\n\tassertResult(t, v, err)\n}\n\nfunc TestDecodeObjectJSONNull(t *testing.T) {\n\tjson := []byte(`null`)\n\tv := &TestObj{}\n\terr := Unmarshal(json, v)\n\tassert.Nil(t, err, \"Err must be nil\")\n\tassert.Equal(t, v.test, 0, \"v.test must be 0 val\")\n}\n\nvar jsonComplex = []byte(`{\n\t\"test\": \"{\\\"test\\\":\\\"1\\\",\\\"test1\\\":2}\",\n\t\"test2\\n\": \"\\\\\\\\\\\\\\\\\\n\",\n\t\"testArrSkip\": [\"testString with escaped \\\\\\\" quotes\"],\n\t\"testSkipString\": \"skip \\\\ string with \\n escaped char \\\" \",\n\t\"testSkipObject\": {\n\t\t\"testSkipSubObj\": {\n\t\t\t\"test\": \"test\"\n\t\t}\n\t},\n\t\"testSkipNumber\": 123.23,\n\t\"testSkipNumber2\": 123.23 ,\n\t\"testBool\": true,\n\t\"testSkipBoolTrue\": true,\n\t\"testSkipBoolFalse\": false,\n\t\"testSkipBoolNull\": null,\n\t\"testSub\": {\n\t\t\"test\": \"{\\\"test\\\":\\\"1\\\",\\\"test1\\\":2}\",\n\t\t\"test2\\n\": \"[1,2,3]\",\n\t\t\"test3\": 1,\n\t\t\"testObjSkip\": {\n\t\t\t\"test\": \"test string with escaped \\\" quotes\"\n\t\t},\n\t\t\"testStrSkip\" : \"test\"\n\t},\n\t\"testBoolSkip\": false,\n\t\"testObjInvalidType\": \"somestring\",\n\t\"testArrSkip2\": [[],[\"someString\"]],\n\t\"test3\": 1\n}`)\n\ntype jsonObjectComplex struct {\n\tTest               string\n\tTest2              string\n\tTest3              int\n\tTest4              bool\n\ttestSub            *jsonObjectComplex\n\ttestObjInvalidType *jsonObjectComplex\n}\n\nfunc (j *jsonObjectComplex) UnmarshalJSONObject(dec *Decoder, key string) error {\n\tswitch key {\n\tcase \"test\":\n\t\treturn dec.AddString(&j.Test)\n\tcase \"test2\\n\":\n\t\treturn dec.AddString(&j.Test2)\n\tcase \"test3\":\n\t\treturn dec.AddInt(&j.Test3)\n\tcase \"testBool\":\n\t\treturn dec.AddBool(&j.Test4)\n\tcase \"testSub\":\n\t\tj.testSub = &jsonObjectComplex{}\n\t\treturn dec.AddObject(j.testSub)\n\tcase \"testObjInvalidType\":\n\t\tj.testObjInvalidType = &jsonObjectComplex{}\n\t\treturn dec.AddObject(j.testObjInvalidType)\n\t}\n\treturn nil\n}\n\nfunc (j *jsonObjectComplex) NKeys() int {\n\treturn 6\n}\n\nfunc TestDecodeObjComplex(t *testing.T) {\n\tresult := jsonObjectComplex{}\n\terr := UnmarshalJSONObject(jsonComplex, &result)\n\tassert.NotNil(t, err, \"err should not be as invalid type as been encountered nil\")\n\tassert.Equal(t, `Cannot unmarshal JSON to type '*gojay.jsonObjectComplex'`, err.Error(), \"err should not be as invalid type as been encountered nil\")\n\tassert.Equal(t, `{\"test\":\"1\",\"test1\":2}`, result.Test, \"result.Test is not expected value\")\n\tassert.Equal(t, \"\\\\\\\\\\\\\\\\\\n\", result.Test2, \"result.Test2 is not expected value\")\n\tassert.Equal(t, 1, result.Test3, \"result.test3 is not expected value\")\n\tassert.Equal(t, `{\"test\":\"1\",\"test1\":2}`, result.testSub.Test, \"result.testSub.test is not expected value\")\n\tassert.Equal(t, `[1,2,3]`, result.testSub.Test2, \"result.testSub.test2 is not expected value\")\n\tassert.Equal(t, 1, result.testSub.Test3, \"result.testSub.test3 is not expected value\")\n\tassert.Equal(t, true, result.Test4, \"result.Test4 is not expected value, should be true\")\n}\n\ntype jsonDecodePartial struct {\n\tTest  string\n\tTest2 string\n}\n\nfunc (j *jsonDecodePartial) UnmarshalJSONObject(dec *Decoder, key string) error {\n\tswitch key {\n\tcase \"test\":\n\t\treturn dec.AddString(&j.Test)\n\tcase `test2`:\n\t\treturn dec.AddString(&j.Test2)\n\t}\n\treturn nil\n}\n\nfunc (j *jsonDecodePartial) NKeys() int {\n\treturn 2\n}\n\nfunc TestDecodeObjectPartial(t *testing.T) {\n\tresult := jsonDecodePartial{}\n\tdec := NewDecoder(nil)\n\tdec.data = []byte(`{\n\t\t\"test\": \"test\",\n\t\t\"test2\": \"test\",\n\t\t\"testArrSkip\": [\"test\"],\n\t\t\"testSkipString\": \"test\",\n\t\t\"testSkipNumber\": 123.23\n\t}`)\n\tdec.length = len(dec.data)\n\terr := dec.DecodeObject(&result)\n\tassert.Nil(t, err, \"err should be nil\")\n\tassert.NotEqual(t, len(dec.data), dec.cursor)\n}\n\nfunc TestDecoderObjectInvalidJSON(t *testing.T) {\n\tresult := jsonDecodePartial{}\n\tdec := NewDecoder(nil)\n\tdec.data = []byte(`{\n\t\t\"test2\": \"test\",\n\t\t\"testArrSkip\": [\"test\"],\n\t\t\"testSkipString\": \"testInvalidJSON\\\\\\\\\n\t}`)\n\tdec.length = len(dec.data)\n\terr := dec.DecodeObject(&result)\n\tassert.NotNil(t, err, \"Err must not be nil as JSON is invalid\")\n\tassert.IsType(t, InvalidJSONError(\"\"), err, \"err message must be 'Invalid JSON'\")\n}\n\ntype myMap map[string]string\n\nfunc (m myMap) UnmarshalJSONObject(dec *Decoder, k string) error {\n\tstr := \"\"\n\terr := dec.AddString(&str)\n\tif err != nil {\n\t\treturn err\n\t}\n\tm[k] = str\n\treturn nil\n}\n\n// return 0 to parse all keys\nfunc (m myMap) NKeys() int {\n\treturn 0\n}\n\nfunc TestDecoderObjectMap(t *testing.T) {\n\tjson := `{\n\t\t\"test\": \"string\",\n\t\t\"test2\": \"string\",\n\t\t\"test3\": \"string\",\n\t\t\"test4\": \"string\",\n\t\t\"test5\": \"string\",\n\t}`\n\tm := myMap(make(map[string]string))\n\tdec := BorrowDecoder(strings.NewReader(json))\n\terr := dec.Decode(m)\n\n\tassert.Nil(t, err, \"err should be nil\")\n\tassert.Len(t, m, 5, \"len of m should be 5\")\n}\n\nfunc TestDecoderObjectDecoderAPI(t *testing.T) {\n\tjson := `{\n\t\t\"test\": 245,\n\t\t\"test2\": 246,\n\t\t\"test3\": \"string\",\n\t\t\"test4\": \"complex string with spaces and some slashes\\\"\",\n\t\t\"test5\": -1.15657654376543,\n\t\t\"testNull\": null,\n\t\t\"testArr\": [\n\t\t\t{\n\t\t\t\t\"test\": 245,\n\t\t\t\t\"test2\": 246\n\t\t\t},\n\t\t\t{\n\t\t\t\t\"test\": 245,\n\t\t\t\t\"test2\": 246\n\t\t\t}\n\t\t],\n\t\t\"testSubObj\": {\n\t\t\t\"test\": 121,\n\t\t\t\"test2\": 122,\n\t\t\t\"testNull\": null,\n\t\t\t\"testSubSubObj\": {\n\t\t\t\t\"test\": 150,\n\t\t\t\t\"testNull\": null\n\t\t\t},\n\t\t\t\"testSubSubObj2\": {\n\t\t\t\t\"test\": 150\n\t\t\t},\n\t\t\t\"test3\": \"string\"\n\t\t\t\"testNull\": null,\n\t\t},\n\t\t\"testSubObj2\": {\n\t\t\t\"test\": 122,\n\t\t\t\"test3\": \"string\"\n\t\t\t\"testSubSubObj\": {\n\t\t\t\t\"test\": 151\n\t\t\t},\n\t\t\t\"test2\": 123\n\t\t}\n\t}`\n\tv := &TestObj{}\n\tdec := NewDecoder(strings.NewReader(json))\n\terr := dec.DecodeObject(v)\n\tassertResult(t, v, err)\n}\n\ntype ReadCloser struct {\n\tjson []byte\n}\n\nfunc (r *ReadCloser) Read(b []byte) (int, error) {\n\tcopy(b, r.json)\n\treturn len(r.json), io.EOF\n}\n\nfunc TestDecoderObjectDecoderAPIReadCloser(t *testing.T) {\n\treadCloser := ReadCloser{\n\t\tjson: []byte(`{\n\t\t\t\"test\": \"string\",\n\t\t\t\"test2\": \"string\",\n\t\t\t\"test3\": \"string\",\n\t\t\t\"test4\": \"string\",\n\t\t\t\"test5\": \"string\",\n\t\t}`),\n\t}\n\tm := myMap(make(map[string]string))\n\tdec := NewDecoder(&readCloser)\n\terr := dec.DecodeObject(m)\n\tassert.Nil(t, err, \"err should be nil\")\n\tassert.Len(t, m, 5, \"len of m should be 5\")\n}\n\nfunc TestDecoderObjectDecoderAPIFuncReadCloser(t *testing.T) {\n\treadCloser := ReadCloser{\n\t\tjson: []byte(`{\n\t\t\t\"test\": \"string\",\n\t\t\t\"test2\": \"string\",\n\t\t\t\"test3\": \"string\",\n\t\t\t\"test4\": \"string\",\n\t\t\t\"test5\": \"string\",\n\t\t}`),\n\t}\n\tm := myMap(make(map[string]string))\n\tdec := NewDecoder(&readCloser)\n\terr := dec.DecodeObject(DecodeObjectFunc(func(dec *Decoder, k string) error {\n\t\tstr := \"\"\n\t\terr := dec.AddString(&str)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tm[k] = str\n\t\treturn nil\n\t}))\n\tassert.Nil(t, err, \"err should be nil\")\n\tassert.Len(t, m, 5, \"len of m should be 5\")\n}\n\nfunc TestDecoderObjectDecoderInvalidJSONError(t *testing.T) {\n\tv := &TestObj{}\n\tdec := NewDecoder(strings.NewReader(`{\"err:}`))\n\terr := dec.DecodeObject(v)\n\tassert.NotNil(t, err, \"Err must not be nil as JSON is invalid\")\n\tassert.IsType(t, InvalidJSONError(\"\"), err, \"err message must be 'Invalid JSON'\")\n}\n\nfunc TestDecoderObjectDecoderInvalidJSONError2(t *testing.T) {\n\tv := &TestSubObj{}\n\tdec := NewDecoder(strings.NewReader(`{\"err:}`))\n\terr := dec.DecodeObject(v)\n\tassert.NotNil(t, err, \"Err must not be nil as JSON is invalid\")\n\tassert.IsType(t, InvalidJSONError(\"\"), err, \"err message must be 'Invalid JSON'\")\n}\n\nfunc TestDecoderObjectDecoderInvalidJSONError3(t *testing.T) {\n\tv := &TestSubObj{}\n\tdec := NewDecoder(strings.NewReader(`{\"err\":\"test}`))\n\terr := dec.DecodeObject(v)\n\tassert.NotNil(t, err, \"Err must not be nil as JSON is invalid\")\n\tassert.IsType(t, InvalidJSONError(\"\"), err, \"err message must be 'Invalid JSON'\")\n}\n\nfunc TestDecoderObjectDecoderInvalidJSONError4(t *testing.T) {\n\ttestArr := testSliceInts{}\n\tdec := NewDecoder(strings.NewReader(`hello`))\n\terr := dec.DecodeArray(&testArr)\n\tassert.NotNil(t, err, \"Err must not be nil as JSON is invalid\")\n\tassert.IsType(t, InvalidJSONError(\"\"), err, \"err message must be 'Invalid JSON'\")\n}\n\nfunc TestDecoderObjectPoolError(t *testing.T) {\n\tresult := jsonDecodePartial{}\n\tdec := NewDecoder(nil)\n\tdec.Release()\n\tdefer func() {\n\t\terr := recover()\n\t\tassert.NotNil(t, err, \"err shouldnt be nil\")\n\t\tassert.IsType(t, InvalidUsagePooledDecoderError(\"\"), err, \"err should be of type InvalidUsagePooledDecoderError\")\n\t}()\n\t_ = dec.DecodeObject(&result)\n\tassert.True(t, false, \"should not be called as decoder should have panicked\")\n}\n\nfunc TestNextKey(t *testing.T) {\n\ttestCases := []struct {\n\t\tname          string\n\t\tjson          string\n\t\texpectedValue string\n\t\terr           bool\n\t}{\n\t\t{\n\t\t\tname:          \"basic\",\n\t\t\tjson:          `\"key\":\"value\"`,\n\t\t\texpectedValue: \"key\",\n\t\t},\n\t\t{\n\t\t\tname:          \"basic-err\",\n\t\t\tjson:          ``,\n\t\t\texpectedValue: \"\",\n\t\t\terr:           true,\n\t\t},\n\t\t{\n\t\t\tname:          \"basic-err2\",\n\t\t\tjson:          `\"key\"`,\n\t\t\texpectedValue: \"\",\n\t\t\terr:           true,\n\t\t},\n\t\t{\n\t\t\tname:          \"basic-err3\",\n\t\t\tjson:          `\"key`,\n\t\t\texpectedValue: \"\",\n\t\t\terr:           true,\n\t\t},\n\t}\n\tfor _, testCase := range testCases {\n\t\tt.Run(testCase.name, func(t *testing.T) {\n\t\t\tdec := BorrowDecoder(strings.NewReader(testCase.json))\n\t\t\ts, _, err := dec.nextKey()\n\t\t\tif testCase.err {\n\t\t\t\tassert.NotNil(t, err, \"err should not be nil\")\n\t\t\t\treturn\n\t\t\t}\n\t\t\tassert.Nil(t, err, \"err should be nil\")\n\t\t\tassert.Equal(t, testCase.expectedValue, s, fmt.Sprintf(\"s should be '%s'\", testCase.expectedValue))\n\t\t})\n\t}\n}\n\nfunc TestSkipObject(t *testing.T) {\n\ttestCases := []struct {\n\t\tname string\n\t\tjson string\n\t\terr  bool\n\t}{\n\t\t{\n\t\t\tname: \"basic\",\n\t\t\tjson: `\"key\":\"value\"}`,\n\t\t},\n\t\t{\n\t\t\tname: \"basic-escape-solidus\",\n\t\t\tjson: `\"key\":\"value\\/solidus\"}`,\n\t\t},\n\t\t{\n\t\t\tname: \"basic-escaped\",\n\t\t\tjson: `\"key\":\"value\\\\\\\\\\\\\\\" hello\"}`,\n\t\t},\n\t\t{\n\t\t\tname: \"basic-escaped\",\n\t\t\tjson: `\"key\":\"value\\\\\\\\\\\\\\\\\"}`,\n\t\t},\n\t\t{\n\t\t\tname: \"basic-err\",\n\t\t\tjson: ``,\n\t\t\terr:  true,\n\t\t},\n\t\t{\n\t\t\tname: \"basic-err2\",\n\t\t\tjson: `{\"key\":\"value\"`,\n\t\t\terr:  true,\n\t\t},\n\t\t{\n\t\t\tname: \"basic-err2\",\n\t\t\tjson: `\"key\":\"value\\n\"}`,\n\t\t\terr:  false,\n\t\t},\n\t}\n\tfor _, testCase := range testCases {\n\t\tt.Run(testCase.name, func(t *testing.T) {\n\t\t\tdec := BorrowDecoder(strings.NewReader(testCase.json))\n\t\t\tdefer dec.Release()\n\t\t\t_, err := dec.skipObject()\n\t\t\tif testCase.err {\n\t\t\t\tassert.NotNil(t, err, \"err should not be nil\")\n\t\t\t\treturn\n\t\t\t}\n\t\t\tassert.Nil(t, err, \"err should be nil\")\n\t\t})\n\t}\n}\n\nfunc TestSkipData(t *testing.T) {\n\ttestCases := []struct {\n\t\tname string\n\t\terr  bool\n\t\tjson string\n\t}{\n\t\t{\n\t\t\tname: \"skip-bool-false-err\",\n\t\t\tjson: `fulse`,\n\t\t\terr:  true,\n\t\t},\n\t\t{\n\t\t\tname: \"skip-bool-true-err\",\n\t\t\tjson: `trou`,\n\t\t\terr:  true,\n\t\t},\n\t\t{\n\t\t\tname: \"skip-bool-null-err\",\n\t\t\tjson: `nil`,\n\t\t\terr:  true,\n\t\t},\n\t}\n\n\tfor _, testCase := range testCases {\n\t\tt.Run(testCase.name, func(t *testing.T) {\n\t\t\tdec := NewDecoder(strings.NewReader(testCase.json))\n\t\t\terr := dec.skipData()\n\t\t\tif testCase.err {\n\t\t\t\tassert.NotNil(t, err, \"err should not be nil\")\n\t\t\t} else {\n\t\t\t\tassert.Nil(t, err, \"err should be nil\")\n\t\t\t}\n\t\t})\n\t}\n\tt.Run(\"error-invalid-json\", func(t *testing.T) {\n\t\tdec := NewDecoder(strings.NewReader(\"\"))\n\t\terr := dec.skipData()\n\t\tassert.NotNil(t, err, \"err should not be nil as data is empty\")\n\t\tassert.IsType(t, InvalidJSONError(\"\"), err, \"err should of type InvalidJSONError\")\n\t})\n\tt.Run(\"skip-array-error-invalid-json\", func(t *testing.T) {\n\t\tdec := NewDecoder(strings.NewReader(\"\"))\n\t\t_, err := dec.skipArray()\n\t\tassert.NotNil(t, err, \"err should not be nil as data is empty\")\n\t\tassert.IsType(t, InvalidJSONError(\"\"), err, \"err should of type InvalidJSONError\")\n\t})\n}\n"
        },
        {
          "name": "decode_pool.go",
          "type": "blob",
          "size": 1.267578125,
          "content": "package gojay\n\nimport (\n\t\"io\"\n\t\"sync\"\n)\n\nvar decPool = sync.Pool{\n\tNew: newDecoderPool,\n}\n\nfunc init() {\n\tfor i := 0; i < 32; i++ {\n\t\tdecPool.Put(NewDecoder(nil))\n\t}\n}\n\n// NewDecoder returns a new decoder.\n// It takes an io.Reader implementation as data input.\nfunc NewDecoder(r io.Reader) *Decoder {\n\treturn &Decoder{\n\t\tcalled:   0,\n\t\tcursor:   0,\n\t\tkeysDone: 0,\n\t\terr:      nil,\n\t\tr:        r,\n\t\tdata:     make([]byte, 512),\n\t\tlength:   0,\n\t\tisPooled: 0,\n\t}\n}\nfunc newDecoderPool() interface{} {\n\treturn NewDecoder(nil)\n}\n\n// BorrowDecoder borrows a Decoder from the pool.\n// It takes an io.Reader implementation as data input.\n//\n// In order to benefit from the pool, a borrowed decoder must be released after usage.\nfunc BorrowDecoder(r io.Reader) *Decoder {\n\treturn borrowDecoder(r, 512)\n}\nfunc borrowDecoder(r io.Reader, bufSize int) *Decoder {\n\tdec := decPool.Get().(*Decoder)\n\tdec.called = 0\n\tdec.keysDone = 0\n\tdec.cursor = 0\n\tdec.err = nil\n\tdec.r = r\n\tdec.length = 0\n\tdec.isPooled = 0\n\tif bufSize > 0 {\n\t\tdec.data = make([]byte, bufSize)\n\t}\n\treturn dec\n}\n\n// Release sends back a Decoder to the pool.\n// If a decoder is used after calling Release\n// a panic will be raised with an InvalidUsagePooledDecoderError error.\nfunc (dec *Decoder) Release() {\n\tdec.isPooled = 1\n\tdecPool.Put(dec)\n}\n"
        },
        {
          "name": "decode_pool_test.go",
          "type": "blob",
          "size": 0.357421875,
          "content": "package gojay\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestDecoderBorrowFromPoolSetBuffSize(t *testing.T) {\n\tdec := borrowDecoder(nil, 512)\n\tassert.Len(t, dec.data, 512, \"data buffer should be of len 512\")\n}\n\nfunc TestDecoderNewPool(t *testing.T) {\n\tdec := newDecoderPool()\n\tassert.IsType(t, &Decoder{}, dec, \"dec should be a *Decoder\")\n}\n"
        },
        {
          "name": "decode_slice.go",
          "type": "blob",
          "size": 2.037109375,
          "content": "package gojay\n\n// AddSliceString unmarshals the next JSON array of strings to the given *[]string s\nfunc (dec *Decoder) AddSliceString(s *[]string) error {\n\treturn dec.SliceString(s)\n}\n\n// SliceString unmarshals the next JSON array of strings to the given *[]string s\nfunc (dec *Decoder) SliceString(s *[]string) error {\n\terr := dec.Array(DecodeArrayFunc(func(dec *Decoder) error {\n\t\tvar str string\n\t\tif err := dec.String(&str); err != nil {\n\t\t\treturn err\n\t\t}\n\t\t*s = append(*s, str)\n\t\treturn nil\n\t}))\n\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}\n\n// AddSliceInt unmarshals the next JSON array of integers to the given *[]int s\nfunc (dec *Decoder) AddSliceInt(s *[]int) error {\n\treturn dec.SliceInt(s)\n}\n\n// SliceInt unmarshals the next JSON array of integers to the given *[]int s\nfunc (dec *Decoder) SliceInt(s *[]int) error {\n\terr := dec.Array(DecodeArrayFunc(func(dec *Decoder) error {\n\t\tvar i int\n\t\tif err := dec.Int(&i); err != nil {\n\t\t\treturn err\n\t\t}\n\t\t*s = append(*s, i)\n\t\treturn nil\n\t}))\n\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}\n\n// AddFloat64 unmarshals the next JSON array of floats to the given *[]float64 s\nfunc (dec *Decoder) AddSliceFloat64(s *[]float64) error {\n\treturn dec.SliceFloat64(s)\n}\n\n// SliceFloat64 unmarshals the next JSON array of floats to the given *[]float64 s\nfunc (dec *Decoder) SliceFloat64(s *[]float64) error {\n\terr := dec.Array(DecodeArrayFunc(func(dec *Decoder) error {\n\t\tvar i float64\n\t\tif err := dec.Float64(&i); err != nil {\n\t\t\treturn err\n\t\t}\n\t\t*s = append(*s, i)\n\t\treturn nil\n\t}))\n\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}\n\n// AddBool unmarshals the next JSON array of boolegers to the given *[]bool s\nfunc (dec *Decoder) AddSliceBool(s *[]bool) error {\n\treturn dec.SliceBool(s)\n}\n\n// SliceBool unmarshals the next JSON array of boolegers to the given *[]bool s\nfunc (dec *Decoder) SliceBool(s *[]bool) error {\n\terr := dec.Array(DecodeArrayFunc(func(dec *Decoder) error {\n\t\tvar b bool\n\t\tif err := dec.Bool(&b); err != nil {\n\t\t\treturn err\n\t\t}\n\t\t*s = append(*s, b)\n\t\treturn nil\n\t}))\n\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}\n"
        },
        {
          "name": "decode_slice_test.go",
          "type": "blob",
          "size": 2.216796875,
          "content": "package gojay\n\nimport (\n\t\"strings\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/require\"\n)\n\ntype slicesTestObject struct {\n\tsliceString  []string\n\tsliceInt     []int\n\tsliceFloat64 []float64\n\tsliceBool    []bool\n}\n\nfunc (s *slicesTestObject) UnmarshalJSONObject(dec *Decoder, k string) error {\n\tswitch k {\n\tcase \"sliceString\":\n\t\treturn dec.AddSliceString(&s.sliceString)\n\tcase \"sliceInt\":\n\t\treturn dec.AddSliceInt(&s.sliceInt)\n\tcase \"sliceFloat64\":\n\t\treturn dec.AddSliceFloat64(&s.sliceFloat64)\n\tcase \"sliceBool\":\n\t\treturn dec.AddSliceBool(&s.sliceBool)\n\t}\n\treturn nil\n}\n\nfunc (s *slicesTestObject) NKeys() int {\n\treturn 4\n}\n\nfunc TestDecodeSlices(t *testing.T) {\n\ttestCases := []struct {\n\t\tname           string\n\t\tjson           string\n\t\texpectedResult slicesTestObject\n\t\terr            bool\n\t}{\n\t\t{\n\t\t\tname: \"basic slice string\",\n\t\t\tjson: `{\n\t\t\t\t\"sliceString\": [\"foo\",\"bar\"]\n\t\t\t}`,\n\t\t\texpectedResult: slicesTestObject{\n\t\t\t\tsliceString: []string{\"foo\", \"bar\"},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"basic slice bool\",\n\t\t\tjson: `{\n\t\t\t\t\"sliceBool\": [true,false]\n\t\t\t}`,\n\t\t\texpectedResult: slicesTestObject{\n\t\t\t\tsliceBool: []bool{true, false},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"basic slice int\",\n\t\t\tjson: `{\n\t\t\t\t\"sliceInt\": [1,2,3]\n\t\t\t}`,\n\t\t\texpectedResult: slicesTestObject{\n\t\t\t\tsliceInt: []int{1, 2, 3},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"basic slice float64\",\n\t\t\tjson: `{\n\t\t\t\t\"sliceFloat64\": [1.3,2.4,3.1]\n\t\t\t}`,\n\t\t\texpectedResult: slicesTestObject{\n\t\t\t\tsliceFloat64: []float64{1.3, 2.4, 3.1},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"err slice float64\",\n\t\t\tjson: `{\n\t\t\t\t\"sliceFloat64\": [1.3\",2.4,3.1]\n\t\t\t}`,\n\t\t\terr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"err slice str\",\n\t\t\tjson: `{\n\t\t\t\t\"sliceString\": [\",\"\"]\n\t\t\t}`,\n\t\t\terr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"err slice int\",\n\t\t\tjson: `{\n\t\t\t\t\"sliceInt\": [1t,2,3]\n\t\t\t}`,\n\t\t\terr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"err slice bool\",\n\t\t\tjson: `{\n\t\t\t\t\"sliceBool\": [truo,false]\n\t\t\t}`,\n\t\t\terr: true,\n\t\t},\n\t}\n\n\tfor _, testCase := range testCases {\n\t\tt.Run(\n\t\t\ttestCase.name,\n\t\t\tfunc(t *testing.T) {\n\t\t\t\tdec := BorrowDecoder(strings.NewReader(testCase.json))\n\t\t\t\tvar o slicesTestObject\n\t\t\t\terr := dec.Decode(&o)\n\n\t\t\t\tif testCase.err {\n\t\t\t\t\trequire.NotNil(t, err, \"err should not be nil\")\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\trequire.Nil(t, err, \"err should be nil\")\n\t\t\t\trequire.Equal(t, testCase.expectedResult, o)\n\t\t\t},\n\t\t)\n\t}\n}\n"
        },
        {
          "name": "decode_sqlnull.go",
          "type": "blob",
          "size": 3.7939453125,
          "content": "package gojay\n\nimport \"database/sql\"\n\n// DecodeSQLNullString decodes a sql.NullString\nfunc (dec *Decoder) DecodeSQLNullString(v *sql.NullString) error {\n\tif dec.isPooled == 1 {\n\t\tpanic(InvalidUsagePooledDecoderError(\"Invalid usage of pooled decoder\"))\n\t}\n\treturn dec.decodeSQLNullString(v)\n}\n\nfunc (dec *Decoder) decodeSQLNullString(v *sql.NullString) error {\n\tvar str string\n\tif err := dec.decodeString(&str); err != nil {\n\t\treturn err\n\t}\n\tv.String = str\n\tv.Valid = true\n\treturn nil\n}\n\n// DecodeSQLNullInt64 decodes a sql.NullInt64\nfunc (dec *Decoder) DecodeSQLNullInt64(v *sql.NullInt64) error {\n\tif dec.isPooled == 1 {\n\t\tpanic(InvalidUsagePooledDecoderError(\"Invalid usage of pooled decoder\"))\n\t}\n\treturn dec.decodeSQLNullInt64(v)\n}\n\nfunc (dec *Decoder) decodeSQLNullInt64(v *sql.NullInt64) error {\n\tvar i int64\n\tif err := dec.decodeInt64(&i); err != nil {\n\t\treturn err\n\t}\n\tv.Int64 = i\n\tv.Valid = true\n\treturn nil\n}\n\n// DecodeSQLNullFloat64 decodes a sql.NullString with the given format\nfunc (dec *Decoder) DecodeSQLNullFloat64(v *sql.NullFloat64) error {\n\tif dec.isPooled == 1 {\n\t\tpanic(InvalidUsagePooledDecoderError(\"Invalid usage of pooled decoder\"))\n\t}\n\treturn dec.decodeSQLNullFloat64(v)\n}\n\nfunc (dec *Decoder) decodeSQLNullFloat64(v *sql.NullFloat64) error {\n\tvar i float64\n\tif err := dec.decodeFloat64(&i); err != nil {\n\t\treturn err\n\t}\n\tv.Float64 = i\n\tv.Valid = true\n\treturn nil\n}\n\n// DecodeSQLNullBool decodes a sql.NullString with the given format\nfunc (dec *Decoder) DecodeSQLNullBool(v *sql.NullBool) error {\n\tif dec.isPooled == 1 {\n\t\tpanic(InvalidUsagePooledDecoderError(\"Invalid usage of pooled decoder\"))\n\t}\n\treturn dec.decodeSQLNullBool(v)\n}\n\nfunc (dec *Decoder) decodeSQLNullBool(v *sql.NullBool) error {\n\tvar b bool\n\tif err := dec.decodeBool(&b); err != nil {\n\t\treturn err\n\t}\n\tv.Bool = b\n\tv.Valid = true\n\treturn nil\n}\n\n// Add Values functions\n\n// AddSQLNullString decodes the JSON value within an object or an array to qn *sql.NullString\nfunc (dec *Decoder) AddSQLNullString(v *sql.NullString) error {\n\treturn dec.SQLNullString(v)\n}\n\n// SQLNullString decodes the JSON value within an object or an array to an *sql.NullString\nfunc (dec *Decoder) SQLNullString(v *sql.NullString) error {\n\tvar b *string\n\tif err := dec.StringNull(&b); err != nil {\n\t\treturn err\n\t}\n\tif b == nil {\n\t\tv.Valid = false\n\t} else {\n\t\tv.String = *b\n\t\tv.Valid = true\n\t}\n\treturn nil\n}\n\n// AddSQLNullInt64 decodes the JSON value within an object or an array to qn *sql.NullInt64\nfunc (dec *Decoder) AddSQLNullInt64(v *sql.NullInt64) error {\n\treturn dec.SQLNullInt64(v)\n}\n\n// SQLNullInt64 decodes the JSON value within an object or an array to an *sql.NullInt64\nfunc (dec *Decoder) SQLNullInt64(v *sql.NullInt64) error {\n\tvar b *int64\n\tif err := dec.Int64Null(&b); err != nil {\n\t\treturn err\n\t}\n\tif b == nil {\n\t\tv.Valid = false\n\t} else {\n\t\tv.Int64 = *b\n\t\tv.Valid = true\n\t}\n\treturn nil\n}\n\n// AddSQLNullFloat64 decodes the JSON value within an object or an array to qn *sql.NullFloat64\nfunc (dec *Decoder) AddSQLNullFloat64(v *sql.NullFloat64) error {\n\treturn dec.SQLNullFloat64(v)\n}\n\n// SQLNullFloat64 decodes the JSON value within an object or an array to an *sql.NullFloat64\nfunc (dec *Decoder) SQLNullFloat64(v *sql.NullFloat64) error {\n\tvar b *float64\n\tif err := dec.Float64Null(&b); err != nil {\n\t\treturn err\n\t}\n\tif b == nil {\n\t\tv.Valid = false\n\t} else {\n\t\tv.Float64 = *b\n\t\tv.Valid = true\n\t}\n\treturn nil\n}\n\n// AddSQLNullBool decodes the JSON value within an object or an array to an *sql.NullBool\nfunc (dec *Decoder) AddSQLNullBool(v *sql.NullBool) error {\n\treturn dec.SQLNullBool(v)\n}\n\n// SQLNullBool decodes the JSON value within an object or an array to an *sql.NullBool\nfunc (dec *Decoder) SQLNullBool(v *sql.NullBool) error {\n\tvar b *bool\n\tif err := dec.BoolNull(&b); err != nil {\n\t\treturn err\n\t}\n\tif b == nil {\n\t\tv.Valid = false\n\t} else {\n\t\tv.Bool = *b\n\t\tv.Valid = true\n\t}\n\treturn nil\n}\n"
        },
        {
          "name": "decode_sqlnull_test.go",
          "type": "blob",
          "size": 8.66015625,
          "content": "package gojay\n\nimport (\n\t\"database/sql\"\n\t\"strings\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n\t\"github.com/stretchr/testify/require\"\n)\n\nfunc TestDecodeSQLNullString(t *testing.T) {\n\ttestCases := []struct {\n\t\tname               string\n\t\tjson               string\n\t\texpectedNullString sql.NullString\n\t\terr                bool\n\t}{\n\t\t{\n\t\t\tname:               \"basic\",\n\t\t\tjson:               `\"test\"`,\n\t\t\texpectedNullString: sql.NullString{String: \"test\", Valid: true},\n\t\t},\n\t\t{\n\t\t\tname:               \"basic\",\n\t\t\tjson:               `\"test`,\n\t\t\texpectedNullString: sql.NullString{String: \"test\", Valid: true},\n\t\t\terr:                true,\n\t\t},\n\t}\n\tfor _, testCase := range testCases {\n\t\tt.Run(testCase.name, func(t *testing.T) {\n\t\t\tnullString := sql.NullString{}\n\t\t\tdec := NewDecoder(strings.NewReader(testCase.json))\n\t\t\terr := dec.DecodeSQLNullString(&nullString)\n\t\t\tif testCase.err {\n\t\t\t\tassert.NotNil(t, err)\n\t\t\t} else {\n\t\t\t\tassert.Nil(t, err)\n\t\t\t\tassert.Equal(t, testCase.expectedNullString, nullString)\n\t\t\t}\n\t\t})\n\t}\n\tt.Run(\n\t\t\"should panic because decoder is pooled\",\n\t\tfunc(t *testing.T) {\n\t\t\tdec := NewDecoder(nil)\n\t\t\tdec.Release()\n\t\t\tdefer func() {\n\t\t\t\terr := recover()\n\t\t\t\tassert.NotNil(t, err, \"err shouldnt be nil\")\n\t\t\t\tassert.IsType(t, InvalidUsagePooledDecoderError(\"\"), err, \"err should be of type InvalidUsagePooledDecoderError\")\n\t\t\t}()\n\t\t\t_ = dec.DecodeSQLNullString(&sql.NullString{})\n\t\t\tassert.True(t, false, \"should not be called as decoder should have panicked\")\n\t\t},\n\t)\n}\n\nfunc TestDecodeSQLNullInt64(t *testing.T) {\n\ttestCases := []struct {\n\t\tname              string\n\t\tjson              string\n\t\texpectedNullInt64 sql.NullInt64\n\t\terr               bool\n\t}{\n\t\t{\n\t\t\tname:              \"basic\",\n\t\t\tjson:              `1`,\n\t\t\texpectedNullInt64: sql.NullInt64{Int64: 1, Valid: true},\n\t\t},\n\t\t{\n\t\t\tname:              \"basic\",\n\t\t\tjson:              `\"test`,\n\t\t\texpectedNullInt64: sql.NullInt64{Int64: 1, Valid: true},\n\t\t\terr:               true,\n\t\t},\n\t}\n\tfor _, testCase := range testCases {\n\t\tt.Run(testCase.name, func(t *testing.T) {\n\t\t\tnullInt64 := sql.NullInt64{}\n\t\t\tdec := NewDecoder(strings.NewReader(testCase.json))\n\t\t\terr := dec.DecodeSQLNullInt64(&nullInt64)\n\t\t\tif testCase.err {\n\t\t\t\tassert.NotNil(t, err)\n\t\t\t} else {\n\t\t\t\tassert.Nil(t, err)\n\t\t\t\tassert.Equal(t, testCase.expectedNullInt64, nullInt64)\n\t\t\t}\n\t\t})\n\t}\n\tt.Run(\n\t\t\"should panic because decoder is pooled\",\n\t\tfunc(t *testing.T) {\n\t\t\tdec := NewDecoder(nil)\n\t\t\tdec.Release()\n\t\t\tdefer func() {\n\t\t\t\terr := recover()\n\t\t\t\tassert.NotNil(t, err, \"err shouldnt be nil\")\n\t\t\t\tassert.IsType(t, InvalidUsagePooledDecoderError(\"\"), err, \"err should be of type InvalidUsagePooledDecoderError\")\n\t\t\t}()\n\t\t\t_ = dec.DecodeSQLNullInt64(&sql.NullInt64{})\n\t\t\tassert.True(t, false, \"should not be called as decoder should have panicked\")\n\t\t},\n\t)\n}\n\nfunc TestDecodeSQLNullFloat64(t *testing.T) {\n\ttestCases := []struct {\n\t\tname                string\n\t\tjson                string\n\t\texpectedNullFloat64 sql.NullFloat64\n\t\terr                 bool\n\t}{\n\t\t{\n\t\t\tname:                \"basic\",\n\t\t\tjson:                `1`,\n\t\t\texpectedNullFloat64: sql.NullFloat64{Float64: 1, Valid: true},\n\t\t},\n\t\t{\n\t\t\tname:                \"basic\",\n\t\t\tjson:                `\"test`,\n\t\t\texpectedNullFloat64: sql.NullFloat64{Float64: 1, Valid: true},\n\t\t\terr:                 true,\n\t\t},\n\t}\n\tfor _, testCase := range testCases {\n\t\tt.Run(testCase.name, func(t *testing.T) {\n\t\t\tnullFloat64 := sql.NullFloat64{}\n\t\t\tdec := NewDecoder(strings.NewReader(testCase.json))\n\t\t\terr := dec.DecodeSQLNullFloat64(&nullFloat64)\n\t\t\tif testCase.err {\n\t\t\t\tassert.NotNil(t, err)\n\t\t\t} else {\n\t\t\t\tassert.Nil(t, err)\n\t\t\t\tassert.Equal(t, testCase.expectedNullFloat64, nullFloat64)\n\t\t\t}\n\t\t})\n\t}\n\tt.Run(\n\t\t\"should panic because decoder is pooled\",\n\t\tfunc(t *testing.T) {\n\t\t\tdec := NewDecoder(nil)\n\t\t\tdec.Release()\n\t\t\tdefer func() {\n\t\t\t\terr := recover()\n\t\t\t\tassert.NotNil(t, err, \"err shouldnt be nil\")\n\t\t\t\tassert.IsType(t, InvalidUsagePooledDecoderError(\"\"), err, \"err should be of type InvalidUsagePooledDecoderError\")\n\t\t\t}()\n\t\t\t_ = dec.DecodeSQLNullFloat64(&sql.NullFloat64{})\n\t\t\tassert.True(t, false, \"should not be called as decoder should have panicked\")\n\t\t},\n\t)\n}\n\nfunc TestDecodeSQLNullBool(t *testing.T) {\n\ttestCases := []struct {\n\t\tname             string\n\t\tjson             string\n\t\texpectedNullBool sql.NullBool\n\t\terr              bool\n\t}{\n\t\t{\n\t\t\tname:             \"basic\",\n\t\t\tjson:             `true`,\n\t\t\texpectedNullBool: sql.NullBool{Bool: true, Valid: true},\n\t\t},\n\t\t{\n\t\t\tname:             \"basic\",\n\t\t\tjson:             `\"&`,\n\t\t\texpectedNullBool: sql.NullBool{Bool: true, Valid: true},\n\t\t\terr:              true,\n\t\t},\n\t}\n\tfor _, testCase := range testCases {\n\t\tt.Run(testCase.name, func(t *testing.T) {\n\t\t\tnullBool := sql.NullBool{}\n\t\t\tdec := NewDecoder(strings.NewReader(testCase.json))\n\t\t\terr := dec.DecodeSQLNullBool(&nullBool)\n\t\t\tif testCase.err {\n\t\t\t\tassert.NotNil(t, err)\n\t\t\t} else {\n\t\t\t\tassert.Nil(t, err)\n\t\t\t\tassert.Equal(t, testCase.expectedNullBool, nullBool)\n\t\t\t}\n\t\t})\n\t}\n\tt.Run(\n\t\t\"should panic because decoder is pooled\",\n\t\tfunc(t *testing.T) {\n\t\t\tdec := NewDecoder(nil)\n\t\t\tdec.Release()\n\t\t\tdefer func() {\n\t\t\t\terr := recover()\n\t\t\t\tassert.NotNil(t, err, \"err shouldnt be nil\")\n\t\t\t\tassert.IsType(t, InvalidUsagePooledDecoderError(\"\"), err, \"err should be of type InvalidUsagePooledDecoderError\")\n\t\t\t}()\n\t\t\t_ = dec.DecodeSQLNullBool(&sql.NullBool{})\n\t\t\tassert.True(t, false, \"should not be called as decoder should have panicked\")\n\t\t},\n\t)\n}\n\ntype SQLDecodeObject struct {\n\tS sql.NullString\n\tF sql.NullFloat64\n\tI sql.NullInt64\n\tB sql.NullBool\n}\n\nfunc (s *SQLDecodeObject) UnmarshalJSONObject(dec *Decoder, k string) error {\n\tswitch k {\n\tcase \"s\":\n\t\treturn dec.AddSQLNullString(&s.S)\n\tcase \"f\":\n\t\treturn dec.AddSQLNullFloat64(&s.F)\n\tcase \"i\":\n\t\treturn dec.AddSQLNullInt64(&s.I)\n\tcase \"b\":\n\t\treturn dec.AddSQLNullBool(&s.B)\n\t}\n\treturn nil\n}\n\nfunc (s *SQLDecodeObject) NKeys() int {\n\treturn 0\n}\n\nfunc TestDecodeSQLNullKeys(t *testing.T) {\n\tvar testCases = []struct {\n\t\tname           string\n\t\tjson           string\n\t\texpectedResult *SQLDecodeObject\n\t\terr            bool\n\t}{\n\t\t{\n\t\t\tname: \"basic all valid\",\n\t\t\tjson: `{\n\t\t\t\t\"s\": \"foo\",\n\t\t\t\t\"f\": 0.3,\n\t\t\t\t\"i\": 3,\n\t\t\t\t\"b\": true\n\t\t\t}`,\n\t\t\texpectedResult: &SQLDecodeObject{\n\t\t\t\tS: sql.NullString{\n\t\t\t\t\tString: \"foo\",\n\t\t\t\t\tValid:  true,\n\t\t\t\t},\n\t\t\t\tF: sql.NullFloat64{\n\t\t\t\t\tFloat64: 0.3,\n\t\t\t\t\tValid:   true,\n\t\t\t\t},\n\t\t\t\tI: sql.NullInt64{\n\t\t\t\t\tInt64: 3,\n\t\t\t\t\tValid: true,\n\t\t\t\t},\n\t\t\t\tB: sql.NullBool{\n\t\t\t\t\tBool:  true,\n\t\t\t\t\tValid: true,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"string not valid\",\n\t\t\tjson: `{\n\t\t\t\t\"s\": null,\n\t\t\t\t\"f\": 0.3,\n\t\t\t\t\"i\": 3,\n\t\t\t\t\"b\": true\n\t\t\t}`,\n\t\t\texpectedResult: &SQLDecodeObject{\n\t\t\t\tS: sql.NullString{\n\t\t\t\t\tValid: false,\n\t\t\t\t},\n\t\t\t\tF: sql.NullFloat64{\n\t\t\t\t\tFloat64: 0.3,\n\t\t\t\t\tValid:   true,\n\t\t\t\t},\n\t\t\t\tI: sql.NullInt64{\n\t\t\t\t\tInt64: 3,\n\t\t\t\t\tValid: true,\n\t\t\t\t},\n\t\t\t\tB: sql.NullBool{\n\t\t\t\t\tBool:  true,\n\t\t\t\t\tValid: true,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"string not valid, int not valid\",\n\t\t\tjson: `{\n\t\t\t\t\"s\": null,\n\t\t\t\t\"f\": 0.3,\n\t\t\t\t\"i\": null,\n\t\t\t\t\"b\": true\n\t\t\t}`,\n\t\t\texpectedResult: &SQLDecodeObject{\n\t\t\t\tS: sql.NullString{\n\t\t\t\t\tValid: false,\n\t\t\t\t},\n\t\t\t\tF: sql.NullFloat64{\n\t\t\t\t\tFloat64: 0.3,\n\t\t\t\t\tValid:   true,\n\t\t\t\t},\n\t\t\t\tI: sql.NullInt64{\n\t\t\t\t\tValid: false,\n\t\t\t\t},\n\t\t\t\tB: sql.NullBool{\n\t\t\t\t\tBool:  true,\n\t\t\t\t\tValid: true,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"keys absent\",\n\t\t\tjson: `{\n\t\t\t\t\"f\": 0.3,\n\t\t\t\t\"i\": 3,\n\t\t\t\t\"b\": true\n\t\t\t}`,\n\t\t\texpectedResult: &SQLDecodeObject{\n\t\t\t\tS: sql.NullString{\n\t\t\t\t\tValid: false,\n\t\t\t\t},\n\t\t\t\tF: sql.NullFloat64{\n\t\t\t\t\tFloat64: 0.3,\n\t\t\t\t\tValid:   true,\n\t\t\t\t},\n\t\t\t\tI: sql.NullInt64{\n\t\t\t\t\tValid: true,\n\t\t\t\t\tInt64: 3,\n\t\t\t\t},\n\t\t\t\tB: sql.NullBool{\n\t\t\t\t\tBool:  true,\n\t\t\t\t\tValid: true,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"keys all null\",\n\t\t\tjson: `{\n\t\t\t\t\"s\": null,\n\t\t\t\t\"f\": null,\n\t\t\t\t\"i\": null,\n\t\t\t\t\"b\": null\n\t\t\t}`,\n\t\t\texpectedResult: &SQLDecodeObject{\n\t\t\t\tS: sql.NullString{\n\t\t\t\t\tValid: false,\n\t\t\t\t},\n\t\t\t\tF: sql.NullFloat64{\n\t\t\t\t\tValid: false,\n\t\t\t\t},\n\t\t\t\tI: sql.NullInt64{\n\t\t\t\t\tValid: false,\n\t\t\t\t},\n\t\t\t\tB: sql.NullBool{\n\t\t\t\t\tValid: false,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"err string key\",\n\t\t\tjson: `{\n\t\t\t\t\"s\": \"`,\n\t\t\terr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"err float key\",\n\t\t\tjson: `{\n\t\t\t\t\"s\": null,\n\t\t\t\t\"f\": 1\",\n\t\t\t\t\"i\": null,\n\t\t\t\t\"b\": null\n\t\t\t}`,\n\t\t\terr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"err int key\",\n\t\t\tjson: `{\n\t\t\t\t\"s\": null,\n\t\t\t\t\"f\": null,\n\t\t\t\t\"i\": 1\",\n\t\t\t\t\"b\": null\n\t\t\t}`,\n\t\t\terr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"err bool key\",\n\t\t\tjson: `{\n\t\t\t\t\"s\": null,\n\t\t\t\t\"f\": null,\n\t\t\t\t\"i\": null,\n\t\t\t\t\"b\": tra\n\t\t\t}`,\n\t\t\terr: true,\n\t\t},\n\t}\n\n\tfor _, testCase := range testCases {\n\t\tt.Run(testCase.name, func(t *testing.T) {\n\t\t\tvar o = &SQLDecodeObject{}\n\t\t\tvar dec = NewDecoder(strings.NewReader(testCase.json))\n\t\t\tvar err = dec.Decode(o)\n\n\t\t\tif testCase.err {\n\t\t\t\trequire.NotNil(t, err)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\trequire.Nil(t, err)\n\t\t\trequire.Equal(\n\t\t\t\tt,\n\t\t\t\ttestCase.expectedResult,\n\t\t\t\to,\n\t\t\t)\n\t\t})\n\t}\n\n}\n"
        },
        {
          "name": "decode_stream.go",
          "type": "blob",
          "size": 2.978515625,
          "content": "package gojay\n\nimport (\n\t\"sync\"\n\t\"time\"\n)\n\n// UnmarshalerStream is the interface to implement for a slice, an array or a slice\n// to decode a line delimited JSON to.\ntype UnmarshalerStream interface {\n\tUnmarshalStream(*StreamDecoder) error\n}\n\n// Stream is a struct holding the Stream api\nvar Stream = stream{}\n\ntype stream struct{}\n\n// A StreamDecoder reads and decodes JSON values from an input stream.\n//\n// It implements conext.Context and provide a channel to notify interruption.\ntype StreamDecoder struct {\n\tmux sync.RWMutex\n\t*Decoder\n\tdone     chan struct{}\n\tdeadline *time.Time\n}\n\n// DecodeStream reads the next line delimited JSON-encoded value from the decoder's input (io.Reader) and stores it in the value pointed to by c.\n//\n// c must implement UnmarshalerStream. Ideally c is a channel. See example for implementation.\n//\n// See the documentation for Unmarshal for details about the conversion of JSON into a Go value.\nfunc (dec *StreamDecoder) DecodeStream(c UnmarshalerStream) error {\n\tif dec.isPooled == 1 {\n\t\tpanic(InvalidUsagePooledDecoderError(\"Invalid usage of pooled decoder\"))\n\t}\n\tif dec.r == nil {\n\t\tdec.err = NoReaderError(\"No reader given to decode stream\")\n\t\tclose(dec.done)\n\t\treturn dec.err\n\t}\n\tfor ; dec.cursor < dec.length || dec.read(); dec.cursor++ {\n\t\tswitch dec.data[dec.cursor] {\n\t\tcase ' ', '\\n', '\\t', '\\r', ',':\n\t\t\tcontinue\n\t\tdefault:\n\t\t\t// char is not space start reading\n\t\t\tfor dec.nextChar() != 0 {\n\t\t\t\t// calling unmarshal stream\n\t\t\t\terr := c.UnmarshalStream(dec)\n\t\t\t\tif err != nil {\n\t\t\t\t\tdec.err = err\n\t\t\t\t\tclose(dec.done)\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t\t// garbage collects buffer\n\t\t\t\t// we don't want the buffer to grow extensively\n\t\t\t\tdec.data = dec.data[dec.cursor:]\n\t\t\t\tdec.length = dec.length - dec.cursor\n\t\t\t\tdec.cursor = 0\n\t\t\t}\n\t\t\t// close the done channel to signal the end of the job\n\t\t\tclose(dec.done)\n\t\t\treturn nil\n\t\t}\n\t}\n\tclose(dec.done)\n\tdec.mux.Lock()\n\terr := dec.raiseInvalidJSONErr(dec.cursor)\n\tdec.mux.Unlock()\n\treturn err\n}\n\n// context.Context implementation\n\n// Done returns a channel that's closed when work is done.\n// It implements context.Context\nfunc (dec *StreamDecoder) Done() <-chan struct{} {\n\treturn dec.done\n}\n\n// Deadline returns the time when work done on behalf of this context\n// should be canceled. Deadline returns ok==false when no deadline is\n// set. Successive calls to Deadline return the same results.\nfunc (dec *StreamDecoder) Deadline() (time.Time, bool) {\n\tif dec.deadline != nil {\n\t\treturn *dec.deadline, true\n\t}\n\treturn time.Time{}, false\n}\n\n// SetDeadline sets the deadline\nfunc (dec *StreamDecoder) SetDeadline(t time.Time) {\n\tdec.deadline = &t\n}\n\n// Err returns nil if Done is not yet closed.\n// If Done is closed, Err returns a non-nil error explaining why.\n// It implements context.Context\nfunc (dec *StreamDecoder) Err() error {\n\tselect {\n\tcase <-dec.done:\n\t\tdec.mux.RLock()\n\t\tdefer dec.mux.RUnlock()\n\t\treturn dec.err\n\tdefault:\n\t\treturn nil\n\t}\n}\n\n// Value implements context.Context\nfunc (dec *StreamDecoder) Value(key interface{}) interface{} {\n\treturn nil\n}\n"
        },
        {
          "name": "decode_stream_pool.go",
          "type": "blob",
          "size": 1.4833984375,
          "content": "package gojay\n\nimport (\n\t\"io\"\n\t\"sync\"\n)\n\nvar streamDecPool = sync.Pool{\n\tNew: newStreamDecoderPool,\n}\n\n// NewDecoder returns a new StreamDecoder.\n// It takes an io.Reader implementation as data input.\n// It initiates the done channel returned by Done().\nfunc (s stream) NewDecoder(r io.Reader) *StreamDecoder {\n\tdec := NewDecoder(r)\n\tstreamDec := &StreamDecoder{\n\t\tDecoder: dec,\n\t\tdone:    make(chan struct{}, 1),\n\t\tmux:     sync.RWMutex{},\n\t}\n\treturn streamDec\n}\nfunc newStreamDecoderPool() interface{} {\n\treturn Stream.NewDecoder(nil)\n}\n\n// BorrowDecoder borrows a StreamDecoder from the pool.\n// It takes an io.Reader implementation as data input.\n// It initiates the done channel returned by Done().\n//\n// If no StreamEncoder is available in the pool, it returns a fresh one\nfunc (s stream) BorrowDecoder(r io.Reader) *StreamDecoder {\n\treturn s.borrowDecoder(r, 512)\n}\n\nfunc (s stream) borrowDecoder(r io.Reader, bufSize int) *StreamDecoder {\n\tstreamDec := streamDecPool.Get().(*StreamDecoder)\n\tstreamDec.called = 0\n\tstreamDec.keysDone = 0\n\tstreamDec.cursor = 0\n\tstreamDec.err = nil\n\tstreamDec.r = r\n\tstreamDec.length = 0\n\tstreamDec.isPooled = 0\n\tstreamDec.done = make(chan struct{}, 1)\n\tif bufSize > 0 {\n\t\tstreamDec.data = make([]byte, bufSize)\n\t}\n\treturn streamDec\n}\n\n// Release sends back a Decoder to the pool.\n// If a decoder is used after calling Release\n// a panic will be raised with an InvalidUsagePooledDecoderError error.\nfunc (dec *StreamDecoder) Release() {\n\tdec.isPooled = 1\n\tstreamDecPool.Put(dec)\n}\n"
        },
        {
          "name": "decode_stream_pool_test.go",
          "type": "blob",
          "size": 1.8349609375,
          "content": "package gojay\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestDecodeStreamDecodePooledDecoderError(t *testing.T) {\n\t// we override the pool chan\n\tdec := Stream.NewDecoder(nil)\n\tdec.Release()\n\tdefer func() {\n\t\terr := recover()\n\t\tassert.NotNil(t, err, \"err shouldnt be nil\")\n\t\tassert.IsType(t, InvalidUsagePooledDecoderError(\"\"), err, \"err should be of type InvalidUsagePooledDecoderError\")\n\t}()\n\tvar v = 0\n\tdec.Decode(&v)\n\t// make sure it fails if this is called\n\tassert.True(t, false, \"should not be called as decoder should have panicked\")\n}\n\nfunc TestDecodeStreamDecodePooledDecoderError1(t *testing.T) {\n\t// we override the pool chan\n\tdec := Stream.NewDecoder(nil)\n\tdec.Release()\n\tdefer func() {\n\t\terr := recover()\n\t\tassert.NotNil(t, err, \"err shouldnt be nil\")\n\t\tassert.IsType(t, InvalidUsagePooledDecoderError(\"\"), err, \"err should be of type InvalidUsagePooledDecoderError\")\n\t}()\n\tvar v = testSliceStrings{}\n\tdec.DecodeArray(&v)\n\t// make sure they are the same\n\tassert.True(t, false, \"should not be called as decoder should have panicked\")\n}\n\nfunc TestDecodeStreamDecodePooledDecoderError2(t *testing.T) {\n\t// we override the pool chan\n\tdec := Stream.NewDecoder(nil)\n\tdec.Release()\n\tdefer func() {\n\t\terr := recover()\n\t\tassert.NotNil(t, err, \"err shouldnt be nil\")\n\t\tassert.IsType(t, InvalidUsagePooledDecoderError(\"\"), err, \"err should be of type InvalidUsagePooledDecoderError\")\n\t\tassert.Equal(t, \"Invalid usage of pooled decoder\", err.(InvalidUsagePooledDecoderError).Error(), \"err should be of type InvalidUsagePooledDecoderError\")\n\t}()\n\tvar v = TestObj{}\n\tdec.DecodeObject(&v)\n\t// make sure they are the same\n\tassert.True(t, false, \"should not be called as decoder should have panicked\")\n}\n\nfunc TestStreamDecoderNewPool(t *testing.T) {\n\tdec := newStreamDecoderPool()\n\tassert.IsType(t, &StreamDecoder{}, dec, \"dec should be a *StreamDecoder\")\n}\n"
        },
        {
          "name": "decode_stream_test.go",
          "type": "blob",
          "size": 13.6103515625,
          "content": "package gojay\n\nimport (\n\t\"context\"\n\t\"errors\"\n\t\"io\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\n// Basic Behaviour Tests\n//\nfunc TestDecoderImplementsContext(t *testing.T) {\n\tvar dec interface{} = &StreamDecoder{}\n\t_ = dec.(context.Context)\n}\n\nfunc TestDecodeStreamNoReader(t *testing.T) {\n\tdec := Stream.NewDecoder(nil)\n\tdec.done = make(chan struct{}, 1)\n\ttestChan := ChannelStreamObjects(make(chan *TestObj))\n\tgo dec.DecodeStream(&testChan)\n\n\tselect {\n\tcase <-dec.Done():\n\t\tassert.NotNil(t, dec.Err(), \"dec.Err() should not be nil\")\n\t\tassert.Equal(t, \"No reader given to decode stream\", dec.Err().Error(), \"dec.Err().Error() should not be 'No reader given to decode stream'\")\n\tcase <-testChan:\n\t\tassert.True(t, false, \"should not be called as decoder should not return error right away\")\n\t}\n}\n\n//  Table Tests\n\n// Objects\n\ntype StreamTestObject struct {\n\tname         string\n\tstreamReader *StreamReader\n\texpectations func(error, []*TestObj, *testing.T)\n}\n\nfunc TestStreamDecodingObjectsParallel(t *testing.T) {\n\tvar tests = []StreamTestObject{\n\t\t{\n\t\t\tname: \"Stream objects\",\n\t\t\tstreamReader: &StreamReader{\n\t\t\t\treadChan: make(chan string),\n\t\t\t\tdone:     make(chan struct{}),\n\t\t\t\tdata: `\n\t\t\t\t\t{\"test\":246,\"test2\":-246,\"test3\":\"string\"}\n\t\t\t\t\t{\"test\":247,\"test2\":248,\"test3\":\"string\"}\n\t\t\t\t\t{\"test\":777,\"test2\":456,\"test3\":\"string\"}\n\t\t\t\t\t{\"test\":777,\"test2\":456,\"test3\":\"string\"}\n\t\t\t\t\t{\"test\":777,\"test2\":456,\"test3\":\"string\"}\n\t\t\t\t\t{\"test\":777,\"test2\":456,\"test3\":\"string\"}\n\t\t\t\t`,\n\t\t\t},\n\t\t\texpectations: func(err error, result []*TestObj, t *testing.T) {\n\t\t\t\tassert.Nil(t, err, \"err should be nil\")\n\n\t\t\t\tassert.Equal(t, 246, result[0].test, \"v[0].test should be equal to 246\")\n\t\t\t\tassert.Equal(t, -246, result[0].test2, \"v[0].test2 should be equal to -247\")\n\t\t\t\tassert.Equal(t, \"string\", result[0].test3, \"v[0].test3 should be equal to \\\"string\\\"\")\n\n\t\t\t\tassert.Equal(t, 247, result[1].test, \"result[1].test should be equal to 246\")\n\t\t\t\tassert.Equal(t, 248, result[1].test2, \"result[1].test2 should be equal to 248\")\n\t\t\t\tassert.Equal(t, \"string\", result[1].test3, \"result[1].test3 should be equal to \\\"string\\\"\")\n\n\t\t\t\tassert.Equal(t, 777, result[2].test, \"result[2].test should be equal to 777\")\n\t\t\t\tassert.Equal(t, 456, result[2].test2, \"result[2].test2 should be equal to 456\")\n\t\t\t\tassert.Equal(t, \"string\", result[2].test3, \"result[2].test3 should be equal to \\\"string\\\"\")\n\n\t\t\t\tassert.Equal(t, 777, result[3].test, \"result[3].test should be equal to 777\")\n\t\t\t\tassert.Equal(t, 456, result[3].test2, \"result[3].test2 should be equal to 456\")\n\t\t\t\tassert.Equal(t, \"string\", result[3].test3, \"result[3].test3 should be equal to \\\"string\\\"\")\n\n\t\t\t\tassert.Equal(t, 777, result[4].test, \"result[4].test should be equal to 777\")\n\t\t\t\tassert.Equal(t, 456, result[4].test2, \"result[4].test2 should be equal to 456\")\n\t\t\t\tassert.Equal(t, \"string\", result[4].test3, \"result[4].test3 should be equal to \\\"string\\\"\")\n\n\t\t\t\tassert.Equal(t, 777, result[5].test, \"result[5].test should be equal to 777\")\n\t\t\t\tassert.Equal(t, 456, result[5].test2, \"result[5].test2 should be equal to 456\")\n\t\t\t\tassert.Equal(t, \"string\", result[5].test3, \"result[5].test3 should be equal to \\\"string\\\"\")\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"Stream test objects with null values\",\n\t\t\tstreamReader: &StreamReader{\n\t\t\t\treadChan: make(chan string),\n\t\t\t\tdone:     make(chan struct{}),\n\t\t\t\tdata: `\n\t\t\t\t\t{\"test\":246,\"test2\":-246,\"test3\":\"string\"}\n\t\t\t\t\t{\"test\":247,\"test2\":248,\"test3\":\"string\"}\n\t\t\t\t\tnull\n\t\t\t\t\t{\"test\":777,\"test2\":456,\"test3\":\"string\"}\n\t\t\t\t\t{\"test\":777,\"test2\":456,\"test3\":\"string\"}\n\t\t\t\t\t{\"test\":777,\"test2\":456,\"test3\":\"string\"}\n\t\t\t\t`,\n\t\t\t},\n\t\t\texpectations: func(err error, result []*TestObj, t *testing.T) {\n\t\t\t\tassert.Nil(t, err, \"err should be nil\")\n\n\t\t\t\tassert.Equal(t, 246, result[0].test, \"v[0].test should be equal to 246\")\n\t\t\t\tassert.Equal(t, -246, result[0].test2, \"v[0].test2 should be equal to -247\")\n\t\t\t\tassert.Equal(t, \"string\", result[0].test3, \"v[0].test3 should be equal to \\\"string\\\"\")\n\n\t\t\t\tassert.Equal(t, 247, result[1].test, \"result[1].test should be equal to 246\")\n\t\t\t\tassert.Equal(t, 248, result[1].test2, \"result[1].test2 should be equal to 248\")\n\t\t\t\tassert.Equal(t, \"string\", result[1].test3, \"result[1].test3 should be equal to \\\"string\\\"\")\n\n\t\t\t\tassert.Equal(t, 0, result[2].test, \"result[2].test should be equal to 0 as input is null\")\n\t\t\t\tassert.Equal(t, 0, result[2].test2, \"result[2].test2 should be equal to 0 as input is null\")\n\t\t\t\tassert.Equal(t, \"\", result[2].test3, \"result[2].test3 should be equal to \\\"\\\" as input is null\")\n\n\t\t\t\tassert.Equal(t, 777, result[3].test, \"result[3].test should be equal to 777\")\n\t\t\t\tassert.Equal(t, 456, result[3].test2, \"result[3].test2 should be equal to 456\")\n\t\t\t\tassert.Equal(t, \"string\", result[3].test3, \"result[3].test3 should be equal to \\\"string\\\"\")\n\n\t\t\t\tassert.Equal(t, 777, result[4].test, \"result[4].test should be equal to 777\")\n\t\t\t\tassert.Equal(t, 456, result[4].test2, \"result[4].test2 should be equal to 456\")\n\t\t\t\tassert.Equal(t, \"string\", result[4].test3, \"result[4].test3 should be equal to \\\"string\\\"\")\n\n\t\t\t\tassert.Equal(t, 777, result[5].test, \"result[5].test should be equal to 777\")\n\t\t\t\tassert.Equal(t, 456, result[5].test2, \"result[5].test2 should be equal to 456\")\n\t\t\t\tassert.Equal(t, \"string\", result[5].test3, \"result[5].test3 should be equal to \\\"string\\\"\")\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"Stream test starting with null values\",\n\t\t\tstreamReader: &StreamReader{\n\t\t\t\treadChan: make(chan string),\n\t\t\t\tdone:     make(chan struct{}),\n\t\t\t\tdata: `\n\t\t\t\t\tnull\n\t\t\t\t\t{\"test\":246,\"test2\":-246,\"test3\":\"string\"}\n\t\t\t\t\t{\"test\":247,\"test2\":248,\"test3\":\"string\"}\n\t\t\t\t`,\n\t\t\t},\n\t\t\texpectations: func(err error, result []*TestObj, t *testing.T) {\n\t\t\t\tassert.Nil(t, err, \"err should be nil\")\n\t\t\t\tassert.Equal(t, 0, result[0].test, \"result[0].test should be equal to 0 as input is null\")\n\t\t\t\tassert.Equal(t, 0, result[0].test2, \"result[0].test2 should be equal to 0 as input is null\")\n\t\t\t\tassert.Equal(t, \"\", result[0].test3, \"result[0].test3 should be equal to \\\"\\\" as input is null\")\n\n\t\t\t\tassert.Equal(t, 246, result[1].test, \"v[1].test should be equal to 246\")\n\t\t\t\tassert.Equal(t, -246, result[1].test2, \"v[1].test2 should be equal to -247\")\n\t\t\t\tassert.Equal(t, \"string\", result[1].test3, \"v[1].test3 should be equal to \\\"string\\\"\")\n\n\t\t\t\tassert.Equal(t, 247, result[2].test, \"result[2].test should be equal to 246\")\n\t\t\t\tassert.Equal(t, 248, result[2].test2, \"result[2].test2 should be equal to 248\")\n\t\t\t\tassert.Equal(t, \"string\", result[2].test3, \"result[2].test3 should be equal to \\\"string\\\"\")\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"Stream test invalid JSON\",\n\t\t\tstreamReader: &StreamReader{\n\t\t\t\treadChan: make(chan string),\n\t\t\t\tdone:     make(chan struct{}),\n\t\t\t\tdata: `\n\t\t\t\t\tinvalid json\n\t\t\t\t\t{\"test\":246,\"test2\":-246,\"test3\":\"string\"}\n\t\t\t\t\t{\"test\":247,\"test2\":248,\"test3\":\"string\"}\n\t\t\t\t`,\n\t\t\t},\n\t\t\texpectations: func(err error, result []*TestObj, t *testing.T) {\n\t\t\t\tassert.NotNil(t, err, \"err is not nil as JSON is invalid\")\n\t\t\t\tassert.IsType(t, InvalidJSONError(\"\"), err, \"err is of type InvalidJSONError\")\n\t\t\t\tassert.Equal(t, \"Invalid JSON, wrong char 'i' found at position 6\", err.Error(), \"err message is Invalid JSON\")\n\t\t\t},\n\t\t},\n\t}\n\tfor _, testCase := range tests {\n\t\ttestCase := testCase\n\t\tt.Run(testCase.name, func(t *testing.T) {\n\t\t\tt.Parallel()\n\t\t\trunStreamTestCaseObjects(t, testCase)\n\t\t})\n\t}\n}\n\nfunc runStreamTestCaseObjects(t *testing.T, testCase StreamTestObject) {\n\t// create our channel which will receive our objects\n\ttestChan := ChannelStreamObjects(make(chan *TestObj))\n\tdec := Stream.NewDecoder(testCase.streamReader)\n\t// start decoding (will block the goroutine until something is written to the ReadWriter)\n\tgo dec.DecodeStream(&testChan)\n\t// start writing to the ReadWriter\n\tgo testCase.streamReader.Write()\n\t// prepare our result\n\tresult := []*TestObj{}\nloop:\n\tfor {\n\t\tselect {\n\t\tcase v := <-testChan:\n\t\t\tresult = append(result, v)\n\t\tcase <-dec.Done():\n\t\t\tbreak loop\n\t\t}\n\t}\n\ttestCase.expectations(dec.Err(), result, t)\n}\n\ntype ChannelStreamObjects chan *TestObj\n\nfunc (c *ChannelStreamObjects) UnmarshalStream(dec *StreamDecoder) error {\n\tobj := &TestObj{}\n\tif err := dec.AddObject(obj); err != nil {\n\t\treturn err\n\t}\n\t*c <- obj\n\treturn nil\n}\n\n// Strings\ntype StreamTestString struct {\n\tname         string\n\tstreamReader *StreamReader\n\texpectations func(error, []*string, *testing.T)\n}\n\nfunc TestStreamDecodingStringsParallel(t *testing.T) {\n\tvar tests = []StreamTestString{\n\t\t{\n\t\t\tname: \"Stream strings basic\",\n\t\t\tstreamReader: &StreamReader{\n\t\t\t\treadChan: make(chan string),\n\t\t\t\tdone:     make(chan struct{}),\n\t\t\t\tdata: `\n\t\t\t\t\t\"hello\"\n\t\t\t\t\t\"world\"\n\t\t\t\t\t\"!\"\n\t\t\t\t`,\n\t\t\t},\n\t\t\texpectations: func(err error, result []*string, t *testing.T) {\n\t\t\t\tassert.Nil(t, err, \"err should be nil\")\n\n\t\t\t\tassert.Equal(t, \"hello\", *result[0], \"v[0] should be equal to 'hello'\")\n\t\t\t\tassert.Equal(t, \"world\", *result[1], \"v[1] should be equal to 'world'\")\n\t\t\t\tassert.Equal(t, \"!\", *result[2], \"v[2] should be equal to '!'\")\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"Stream strings with null\",\n\t\t\tstreamReader: &StreamReader{\n\t\t\t\treadChan: make(chan string),\n\t\t\t\tdone:     make(chan struct{}),\n\t\t\t\tdata: `\n\t\t\t\t\t\"hello\"\n\t\t\t\t\tnull\n\t\t\t\t\t\"!\"\n\t\t\t\t`,\n\t\t\t},\n\t\t\texpectations: func(err error, result []*string, t *testing.T) {\n\t\t\t\tassert.Nil(t, err, \"err should be nil\")\n\n\t\t\t\tassert.Equal(t, \"hello\", *result[0], \"v[0] should be equal to 'hello'\")\n\t\t\t\tassert.Equal(t, \"\", *result[1], \"v[1] should be equal to ''\")\n\t\t\t\tassert.Equal(t, \"!\", *result[2], \"v[2] should be equal to '!'\")\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"Stream strings invalid JSON\",\n\t\t\tstreamReader: &StreamReader{\n\t\t\t\treadChan: make(chan string),\n\t\t\t\tdone:     make(chan struct{}),\n\t\t\t\tdata: `\n\t\t\t\t\t\"hello\"\n\t\t\t\t\tworld\n\t\t\t\t\t\"!\"\n\t\t\t\t`,\n\t\t\t},\n\t\t\texpectations: func(err error, result []*string, t *testing.T) {\n\t\t\t\tassert.NotNil(t, err, \"err should not be nil\")\n\n\t\t\t\tassert.IsType(t, InvalidJSONError(\"\"), err, \"err is of type InvalidJSONError\")\n\t\t\t\tassert.Equal(t, \"Invalid JSON, wrong char 'w' found at position 6\", err.Error(), \"err message is Invalid JSON\")\n\t\t\t},\n\t\t},\n\t}\n\tfor _, testCase := range tests {\n\t\ttestCase := testCase\n\t\tt.Run(testCase.name, func(t *testing.T) {\n\t\t\tt.Parallel()\n\t\t\trunStreamTestCaseStrings(t, testCase)\n\t\t})\n\t}\n}\n\nfunc runStreamTestCaseStrings(t *testing.T, testCase StreamTestString) {\n\t// create our channel which will receive our objects\n\ttestChan := ChannelStreamStrings(make(chan *string))\n\tdec := Stream.NewDecoder(testCase.streamReader)\n\t// start decoding (will block the goroutine until something is written to the ReadWriter)\n\tgo dec.DecodeStream(testChan)\n\t// start writing to the ReadWriter\n\tgo testCase.streamReader.Write()\n\t// prepare our result\n\tresult := []*string{}\nloop:\n\tfor {\n\t\tselect {\n\t\tcase v := <-testChan:\n\t\t\tresult = append(result, v)\n\t\tcase <-dec.Done():\n\t\t\tbreak loop\n\t\t}\n\t}\n\ttestCase.expectations(dec.Err(), result, t)\n}\n\nfunc TestStreamDecodingErr(t *testing.T) {\n\ttestChan := ChannelStreamStrings(make(chan *string))\n\tdec := Stream.NewDecoder(&StreamReaderErr{})\n\t// start decoding (will block the goroutine until something is written to the ReadWriter)\n\tgo dec.DecodeStream(testChan)\n\tselect {\n\tcase <-dec.Done():\n\t\tassert.NotNil(t, dec.Err(), \"dec.Err() should not be nil\")\n\tcase <-testChan:\n\t\tassert.True(t, false, \"should not be called\")\n\t}\n\n}\n\ntype ChannelStreamStrings chan *string\n\nfunc (c ChannelStreamStrings) UnmarshalStream(dec *StreamDecoder) error {\n\tstr := \"\"\n\tif err := dec.AddString(&str); err != nil {\n\t\treturn err\n\t}\n\tc <- &str\n\treturn nil\n}\n\n// StreamReader mocks a stream reading chunks of data\ntype StreamReader struct {\n\twriteCounter int\n\treadChan     chan string\n\tdone         chan struct{}\n\tdata         string\n}\n\nfunc (r *StreamReader) Write() {\n\tl := len(r.data)\n\tt := 4\n\tchunkSize := l / t\n\tcarry := 0\n\tlastWrite := 0\n\tfor r.writeCounter < t {\n\t\ttime.Sleep(time.Duration(r.writeCounter*100) * time.Millisecond)\n\t\tcurrentChunkStart := (chunkSize) * r.writeCounter\n\t\tlastWrite = currentChunkStart + chunkSize\n\t\tr.readChan <- r.data[currentChunkStart:lastWrite]\n\t\tcarry = l - lastWrite\n\t\tr.writeCounter++\n\t}\n\tif carry > 0 {\n\t\tr.readChan <- r.data[lastWrite:]\n\t}\n\tr.done <- struct{}{}\n}\n\nfunc (r *StreamReader) Read(b []byte) (int, error) {\n\tselect {\n\tcase v := <-r.readChan:\n\t\tn := copy(b, v)\n\t\treturn n, nil\n\tcase <-r.done:\n\t\treturn 0, io.EOF\n\t}\n}\n\ntype StreamReaderErr struct{}\n\nfunc (r *StreamReaderErr) Read(b []byte) (int, error) {\n\treturn 0, errors.New(\"Test Error\")\n}\n\n// Deadline test\nfunc TestStreamDecodingDeadline(t *testing.T) {\n\tdec := Stream.NewDecoder(&StreamReader{})\n\tnow := time.Now()\n\tdec.SetDeadline(now)\n\tdeadline, _ := dec.Deadline()\n\tassert.Equal(t, now.String(), deadline.String(), \"dec.now and now should be equal\")\n\tassert.Equal(t, now.String(), dec.deadline.String(), \"dec.now and now should be equal\")\n}\n\nfunc TestStreamDecodingDeadlineNotSet(t *testing.T) {\n\tdec := Stream.NewDecoder(&StreamReader{})\n\t_, isSet := dec.Deadline()\n\tassert.Equal(t, false, isSet, \"isSet should be false as deadline is not set\")\n}\n\n// this test is only relevant for coverage\nfunc TestStreamDecodingValue(t *testing.T) {\n\tdec := Stream.NewDecoder(&StreamReader{})\n\tv := dec.Value(\"\")\n\tassert.Nil(t, v, \"v should be nil\")\n}\n\nfunc TestStreamDecodingErrNotSet(t *testing.T) {\n\tdec := Stream.NewDecoder(&StreamReader{})\n\tassert.Nil(t, dec.Err(), \"dec.Err should be nim\")\n}\n\nfunc TestStreamDecodingPoolError(t *testing.T) {\n\tdec := Stream.BorrowDecoder(nil)\n\tdec.Release()\n\tdefer func() {\n\t\terr := recover()\n\t\tassert.NotNil(t, err, \"err shouldnt be nil\")\n\t\tassert.IsType(t, InvalidUsagePooledDecoderError(\"\"), err, \"err should be of type InvalidUsagePooledEncoderError\")\n\t\tassert.Equal(t, \"Invalid usage of pooled decoder\", err.(InvalidUsagePooledDecoderError).Error(), \"err should be of type InvalidUsagePooledDecoderError\")\n\t}()\n\ttestChan := ChannelStreamStrings(make(chan *string))\n\t_ = dec.DecodeStream(testChan)\n\tassert.True(t, false, \"should not be called as it should have panicked\")\n}\n"
        },
        {
          "name": "decode_string.go",
          "type": "blob",
          "size": 6.1787109375,
          "content": "package gojay\n\nimport (\n\t\"unsafe\"\n)\n\n// DecodeString reads the next JSON-encoded value from the decoder's input (io.Reader) and stores it in the string pointed to by v.\n//\n// See the documentation for Unmarshal for details about the conversion of JSON into a Go value.\nfunc (dec *Decoder) DecodeString(v *string) error {\n\tif dec.isPooled == 1 {\n\t\tpanic(InvalidUsagePooledDecoderError(\"Invalid usage of pooled decoder\"))\n\t}\n\treturn dec.decodeString(v)\n}\nfunc (dec *Decoder) decodeString(v *string) error {\n\tfor ; dec.cursor < dec.length || dec.read(); dec.cursor++ {\n\t\tswitch dec.data[dec.cursor] {\n\t\tcase ' ', '\\n', '\\t', '\\r', ',':\n\t\t\t// is string\n\t\t\tcontinue\n\t\tcase '\"':\n\t\t\tdec.cursor++\n\t\t\tstart, end, err := dec.getString()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\t// we do minus one to remove the last quote\n\t\t\td := dec.data[start : end-1]\n\t\t\t*v = *(*string)(unsafe.Pointer(&d))\n\t\t\tdec.cursor = end\n\t\t\treturn nil\n\t\t// is nil\n\t\tcase 'n':\n\t\t\tdec.cursor++\n\t\t\terr := dec.assertNull()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\treturn nil\n\t\tdefault:\n\t\t\tdec.err = dec.makeInvalidUnmarshalErr(v)\n\t\t\terr := dec.skipData()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\treturn nil\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc (dec *Decoder) decodeStringNull(v **string) error {\n\tfor ; dec.cursor < dec.length || dec.read(); dec.cursor++ {\n\t\tswitch dec.data[dec.cursor] {\n\t\tcase ' ', '\\n', '\\t', '\\r', ',':\n\t\t\t// is string\n\t\t\tcontinue\n\t\tcase '\"':\n\t\t\tdec.cursor++\n\t\t\tstart, end, err := dec.getString()\n\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif *v == nil {\n\t\t\t\t*v = new(string)\n\t\t\t}\n\t\t\t// we do minus one to remove the last quote\n\t\t\td := dec.data[start : end-1]\n\t\t\t**v = *(*string)(unsafe.Pointer(&d))\n\t\t\tdec.cursor = end\n\t\t\treturn nil\n\t\t// is nil\n\t\tcase 'n':\n\t\t\tdec.cursor++\n\t\t\terr := dec.assertNull()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\treturn nil\n\t\tdefault:\n\t\t\tdec.err = dec.makeInvalidUnmarshalErr(v)\n\t\t\terr := dec.skipData()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\treturn nil\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc (dec *Decoder) parseEscapedString() error {\n\tif dec.cursor >= dec.length && !dec.read() {\n\t\treturn dec.raiseInvalidJSONErr(dec.cursor)\n\t}\n\tswitch dec.data[dec.cursor] {\n\tcase '\"':\n\t\tdec.data[dec.cursor] = '\"'\n\tcase '\\\\':\n\t\tdec.data[dec.cursor] = '\\\\'\n\tcase '/':\n\t\tdec.data[dec.cursor] = '/'\n\tcase 'b':\n\t\tdec.data[dec.cursor] = '\\b'\n\tcase 'f':\n\t\tdec.data[dec.cursor] = '\\f'\n\tcase 'n':\n\t\tdec.data[dec.cursor] = '\\n'\n\tcase 'r':\n\t\tdec.data[dec.cursor] = '\\r'\n\tcase 't':\n\t\tdec.data[dec.cursor] = '\\t'\n\tcase 'u':\n\t\tstart := dec.cursor\n\t\tdec.cursor++\n\t\tstr, err := dec.parseUnicode()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tdiff := dec.cursor - start\n\t\tdec.data = append(append(dec.data[:start-1], str...), dec.data[dec.cursor:]...)\n\t\tdec.length = len(dec.data)\n\t\tdec.cursor += len(str) - diff - 1\n\n\t\treturn nil\n\tdefault:\n\t\treturn dec.raiseInvalidJSONErr(dec.cursor)\n\t}\n\n\tdec.data = append(dec.data[:dec.cursor-1], dec.data[dec.cursor:]...)\n\tdec.length--\n\n\t// Since we've lost a character, our dec.cursor offset is now\n\t// 1 past the escaped character which is precisely where we\n\t// want it.\n\n\treturn nil\n}\n\nfunc (dec *Decoder) getString() (int, int, error) {\n\t// extract key\n\tvar keyStart = dec.cursor\n\t// var str *Builder\n\tfor dec.cursor < dec.length || dec.read() {\n\t\tswitch dec.data[dec.cursor] {\n\t\t// string found\n\t\tcase '\"':\n\t\t\tdec.cursor = dec.cursor + 1\n\t\t\treturn keyStart, dec.cursor, nil\n\t\t// slash found\n\t\tcase '\\\\':\n\t\t\tdec.cursor = dec.cursor + 1\n\t\t\terr := dec.parseEscapedString()\n\t\t\tif err != nil {\n\t\t\t\treturn 0, 0, err\n\t\t\t}\n\t\tdefault:\n\t\t\tdec.cursor = dec.cursor + 1\n\t\t\tcontinue\n\t\t}\n\t}\n\treturn 0, 0, dec.raiseInvalidJSONErr(dec.cursor)\n}\n\nfunc (dec *Decoder) skipEscapedString() error {\n\tstart := dec.cursor\n\tfor ; dec.cursor < dec.length || dec.read(); dec.cursor++ {\n\t\tif dec.data[dec.cursor] != '\\\\' {\n\t\t\td := dec.data[dec.cursor]\n\t\t\tdec.cursor = dec.cursor + 1\n\t\t\tnSlash := dec.cursor - start\n\t\t\tswitch d {\n\t\t\tcase '\"':\n\t\t\t\t// nSlash must be odd\n\t\t\t\tif nSlash&1 != 1 {\n\t\t\t\t\treturn dec.raiseInvalidJSONErr(dec.cursor)\n\t\t\t\t}\n\t\t\t\treturn nil\n\t\t\tcase 'u': // is unicode, we skip the following characters and place the cursor one one byte backward to avoid it breaking when returning to skipString\n\t\t\t\tif err := dec.skipString(); err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t\tdec.cursor--\n\t\t\t\treturn nil\n\t\t\tcase 'n', 'r', 't', '/', 'f', 'b':\n\t\t\t\treturn nil\n\t\t\tdefault:\n\t\t\t\t// nSlash must be even\n\t\t\t\tif nSlash&1 == 1 {\n\t\t\t\t\treturn dec.raiseInvalidJSONErr(dec.cursor)\n\t\t\t\t}\n\t\t\t\treturn nil\n\t\t\t}\n\t\t}\n\t}\n\treturn dec.raiseInvalidJSONErr(dec.cursor)\n}\n\nfunc (dec *Decoder) skipString() error {\n\tfor dec.cursor < dec.length || dec.read() {\n\t\tswitch dec.data[dec.cursor] {\n\t\t// found the closing quote\n\t\t// let's return\n\t\tcase '\"':\n\t\t\tdec.cursor = dec.cursor + 1\n\t\t\treturn nil\n\t\t// solidus found start parsing an escaped string\n\t\tcase '\\\\':\n\t\t\tdec.cursor = dec.cursor + 1\n\t\t\terr := dec.skipEscapedString()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\tdefault:\n\t\t\tdec.cursor = dec.cursor + 1\n\t\t\tcontinue\n\t\t}\n\t}\n\treturn dec.raiseInvalidJSONErr(len(dec.data) - 1)\n}\n\n// Add Values functions\n\n// AddString decodes the JSON value within an object or an array to a *string.\n// If next key is not a JSON string nor null, InvalidUnmarshalError will be returned.\nfunc (dec *Decoder) AddString(v *string) error {\n\treturn dec.String(v)\n}\n\n// AddStringNull decodes the JSON value within an object or an array to a *string.\n// If next key is not a JSON string nor null, InvalidUnmarshalError will be returned.\n// If a `null` is encountered, gojay does not change the value of the pointer.\nfunc (dec *Decoder) AddStringNull(v **string) error {\n\treturn dec.StringNull(v)\n}\n\n// String decodes the JSON value within an object or an array to a *string.\n// If next key is not a JSON string nor null, InvalidUnmarshalError will be returned.\nfunc (dec *Decoder) String(v *string) error {\n\terr := dec.decodeString(v)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdec.called |= 1\n\treturn nil\n}\n\n// StringNull decodes the JSON value within an object or an array to a **string.\n// If next key is not a JSON string nor null, InvalidUnmarshalError will be returned.\n// If a `null` is encountered, gojay does not change the value of the pointer.\nfunc (dec *Decoder) StringNull(v **string) error {\n\terr := dec.decodeStringNull(v)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdec.called |= 1\n\treturn nil\n}\n"
        },
        {
          "name": "decode_string_test.go",
          "type": "blob",
          "size": 18.9677734375,
          "content": "package gojay\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\t\"sync\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestDecoderString(t *testing.T) {\n\ttestCases := []struct {\n\t\tname           string\n\t\tjson           string\n\t\texpectedResult string\n\t\terr            bool\n\t\terrType        interface{}\n\t}{\n\t\t{\n\t\t\tname:           \"basic-string\",\n\t\t\tjson:           `\"string\"`,\n\t\t\texpectedResult: \"string\",\n\t\t\terr:            false,\n\t\t},\n\t\t{\n\t\t\tname:           \"string-solidus\",\n\t\t\tjson:           `\"\\/\"`,\n\t\t\texpectedResult: \"/\",\n\t\t\terr:            false,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-string\",\n\t\t\tjson:           ``,\n\t\t\texpectedResult: \"\",\n\t\t\terr:            false,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-string\",\n\t\t\tjson:           `\"\"`,\n\t\t\texpectedResult: \"\",\n\t\t\terr:            false,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-string2\",\n\t\t\tjson:           `\"hello world!\"`,\n\t\t\texpectedResult: \"hello world!\",\n\t\t\terr:            false,\n\t\t},\n\t\t{\n\t\t\tname:           \"escape-control-char\",\n\t\t\tjson:           `\"\\n\"`,\n\t\t\texpectedResult: \"\\n\",\n\t\t\terr:            false,\n\t\t},\n\t\t{\n\t\t\tname:           \"escape-control-char\",\n\t\t\tjson:           `\"\\\\n\"`,\n\t\t\texpectedResult: `\\n`,\n\t\t\terr:            false,\n\t\t},\n\t\t{\n\t\t\tname:           \"escape-control-char\",\n\t\t\tjson:           `\"\\t\"`,\n\t\t\texpectedResult: \"\\t\",\n\t\t\terr:            false,\n\t\t},\n\t\t{\n\t\t\tname:           \"escape-control-char\",\n\t\t\tjson:           `\"\\\\t\"`,\n\t\t\texpectedResult: `\\t`,\n\t\t\terr:            false,\n\t\t},\n\t\t{\n\t\t\tname:           \"escape-control-char\",\n\t\t\tjson:           `\"\\b\"`,\n\t\t\texpectedResult: \"\\b\",\n\t\t\terr:            false,\n\t\t},\n\t\t{\n\t\t\tname:           \"escape-control-char\",\n\t\t\tjson:           `\"\\\\b\"`,\n\t\t\texpectedResult: `\\b`,\n\t\t\terr:            false,\n\t\t},\n\t\t{\n\t\t\tname:           \"escape-control-char\",\n\t\t\tjson:           `\"\\f\"`,\n\t\t\texpectedResult: \"\\f\",\n\t\t\terr:            false,\n\t\t},\n\t\t{\n\t\t\tname:           \"escape-control-char\",\n\t\t\tjson:           `\"\\\\f\"`,\n\t\t\texpectedResult: `\\f`,\n\t\t\terr:            false,\n\t\t},\n\t\t{\n\t\t\tname:           \"escape-control-char\",\n\t\t\tjson:           `\"\\r\"`,\n\t\t\texpectedResult: \"\\r\",\n\t\t\terr:            false,\n\t\t},\n\t\t{\n\t\t\tname:           \"escape-control-char\",\n\t\t\tjson:           `\"\\`,\n\t\t\texpectedResult: \"\",\n\t\t\terr:            true,\n\t\t},\n\t\t{\n\t\t\tname:           \"escape-control-char-solidus\",\n\t\t\tjson:           `\"\\/\"`,\n\t\t\texpectedResult: \"/\",\n\t\t\terr:            false,\n\t\t},\n\t\t{\n\t\t\tname:           \"escape-control-char-solidus\",\n\t\t\tjson:           `\"/\"`,\n\t\t\texpectedResult: \"/\",\n\t\t\terr:            false,\n\t\t},\n\t\t{\n\t\t\tname:           \"escape-control-char-solidus-escape-char\",\n\t\t\tjson:           `\"\\\\/\"`,\n\t\t\texpectedResult: `\\/`,\n\t\t\terr:            false,\n\t\t},\n\t\t{\n\t\t\tname:           \"escape-control-char\",\n\t\t\tjson:           `\"\\\\r\"`,\n\t\t\texpectedResult: `\\r`,\n\t\t\terr:            false,\n\t\t},\n\t\t{\n\t\t\tname:           \"utf8\",\n\t\t\tjson:           `\"𠜎 𠜱 𠝹 𠱓 𠱸 𠲖 𠳏 𠳕 𠴕 𠵼 𠵿\"`,\n\t\t\texpectedResult: \"𠜎 𠜱 𠝹 𠱓 𠱸 𠲖 𠳏 𠳕 𠴕 𠵼 𠵿\",\n\t\t\terr:            false,\n\t\t},\n\t\t{\n\t\t\tname:           \"utf8-code-point\",\n\t\t\tjson:           `\"\\u06fc\"`,\n\t\t\texpectedResult: `ۼ`,\n\t\t\terr:            false,\n\t\t},\n\t\t{\n\t\t\tname:           \"utf8-code-point-escaped\",\n\t\t\tjson:           `\"\\\\u2070\"`,\n\t\t\texpectedResult: `\\u2070`,\n\t\t\terr:            false,\n\t\t},\n\t\t{\n\t\t\tname:           \"utf8-code-point-err\",\n\t\t\tjson:           `\"\\u2Z70\"`,\n\t\t\texpectedResult: ``,\n\t\t\terr:            true,\n\t\t},\n\t\t{\n\t\t\tname:           \"utf16-surrogate\",\n\t\t\tjson:           `\"\\uD834\\uDD1E\"`,\n\t\t\texpectedResult: `𝄞`,\n\t\t\terr:            false,\n\t\t},\n\t\t{\n\t\t\tname:           \"utf16-surrogate\",\n\t\t\tjson:           `\"\\uD834\\\\\"`,\n\t\t\texpectedResult: `�\\`,\n\t\t\terr:            false,\n\t\t},\n\t\t{\n\t\t\tname:           \"utf16-surrogate\",\n\t\t\tjson:           `\"\\uD834\\uD834\"`,\n\t\t\texpectedResult: \"�\\x00\\x00\\x00\",\n\t\t\terr:            false,\n\t\t},\n\t\t{\n\t\t\tname:           \"utf16-surrogate\",\n\t\t\tjson:           `\"\\uD834\"`,\n\t\t\texpectedResult: `�`,\n\t\t\terr:            false,\n\t\t},\n\t\t{\n\t\t\tname:           \"utf16-surrogate-err\",\n\t\t\tjson:           `\"\\uD834\\`,\n\t\t\texpectedResult: ``,\n\t\t\terr:            true,\n\t\t},\n\t\t{\n\t\t\tname:           \"utf16-surrogate-err2\",\n\t\t\tjson:           `\"\\uD834\\uDZ1E`,\n\t\t\texpectedResult: ``,\n\t\t\terr:            true,\n\t\t},\n\t\t{\n\t\t\tname:           \"utf16-surrogate-err3\",\n\t\t\tjson:           `\"\\uD834`,\n\t\t\texpectedResult: ``,\n\t\t\terr:            true,\n\t\t},\n\t\t{\n\t\t\tname:           \"utf16-surrogate-followed-by-control-char\",\n\t\t\tjson:           `\"\\uD834\\t\"`,\n\t\t\texpectedResult: \"�\\t\",\n\t\t\terr:            false,\n\t\t},\n\t\t{\n\t\t\tname:           \"utf16-surrogate-followed-by-control-char\",\n\t\t\tjson:           `\"\\uD834\\n\"`,\n\t\t\texpectedResult: \"�\\n\",\n\t\t\terr:            false,\n\t\t},\n\t\t{\n\t\t\tname:           \"utf16-surrogate-followed-by-control-char\",\n\t\t\tjson:           `\"\\uD834\\f\"`,\n\t\t\texpectedResult: \"�\\f\",\n\t\t\terr:            false,\n\t\t},\n\t\t{\n\t\t\tname:           \"utf16-surrogate-followed-by-control-char\",\n\t\t\tjson:           `\"\\uD834\\b\"`,\n\t\t\texpectedResult: \"�\\b\",\n\t\t\terr:            false,\n\t\t},\n\t\t{\n\t\t\tname:           \"utf16-surrogate-followed-by-control-char\",\n\t\t\tjson:           `\"\\uD834\\r\"`,\n\t\t\texpectedResult: \"�\\r\",\n\t\t\terr:            false,\n\t\t},\n\t\t{\n\t\t\tname:           \"utf16-surrogate-followed-by-control-char\",\n\t\t\tjson:           `\"\\uD834\\h\"`,\n\t\t\texpectedResult: \"\",\n\t\t\terr:            true,\n\t\t},\n\t\t{\n\t\t\tname:           \"null\",\n\t\t\tjson:           `null`,\n\t\t\texpectedResult: \"\",\n\t\t},\n\t\t{\n\t\t\tname:           \"null-err\",\n\t\t\tjson:           `nall`,\n\t\t\texpectedResult: \"\",\n\t\t\terr:            true,\n\t\t},\n\t\t{\n\t\t\tname:           \"escape quote err\",\n\t\t\tjson:           `\"test string \\\" escaped\"`,\n\t\t\texpectedResult: `test string \" escaped`,\n\t\t\terr:            false,\n\t\t},\n\t\t{\n\t\t\tname:           \"escape quote err2\",\n\t\t\tjson:           `\"test string \\t escaped\"`,\n\t\t\texpectedResult: \"test string \\t escaped\",\n\t\t\terr:            false,\n\t\t},\n\t\t{\n\t\t\tname:           \"escape quote err2\",\n\t\t\tjson:           `\"test string \\r escaped\"`,\n\t\t\texpectedResult: \"test string \\r escaped\",\n\t\t\terr:            false,\n\t\t},\n\t\t{\n\t\t\tname:           \"escape quote err2\",\n\t\t\tjson:           `\"test string \\b escaped\"`,\n\t\t\texpectedResult: \"test string \\b escaped\",\n\t\t\terr:            false,\n\t\t},\n\t\t{\n\t\t\tname:           \"escape quote err\",\n\t\t\tjson:           `\"test string \\n escaped\"`,\n\t\t\texpectedResult: \"test string \\n escaped\",\n\t\t\terr:            false,\n\t\t},\n\t\t{\n\t\t\tname:           \"escape quote err\",\n\t\t\tjson:           `\"test string \\\\\\\" escaped`,\n\t\t\texpectedResult: ``,\n\t\t\terr:            true,\n\t\t\terrType:        InvalidJSONError(\"\"),\n\t\t},\n\t\t{\n\t\t\tname:           \"escape quote err\",\n\t\t\tjson:           `\"test string \\\\\\l escaped\"`,\n\t\t\texpectedResult: ``,\n\t\t\terr:            true,\n\t\t\terrType:        InvalidJSONError(\"\"),\n\t\t},\n\t\t{\n\t\t\tname:           \"invalid-json\",\n\t\t\tjson:           `invalid`,\n\t\t\texpectedResult: ``,\n\t\t\terr:            true,\n\t\t\terrType:        InvalidJSONError(\"\"),\n\t\t},\n\t\t{\n\t\t\tname:           \"string-complex\",\n\t\t\tjson:           `  \"string with spaces and \\\"escape\\\"d \\\"quotes\\\" and escaped line returns \\n and escaped \\\\\\\\ escaped char\"`,\n\t\t\texpectedResult: \"string with spaces and \\\"escape\\\"d \\\"quotes\\\" and escaped line returns \\n and escaped \\\\\\\\ escaped char\",\n\t\t},\n\t}\n\n\tfor _, testCase := range testCases {\n\t\tt.Run(testCase.name, func(t *testing.T) {\n\t\t\tstr := \"\"\n\t\t\tdec := NewDecoder(strings.NewReader(testCase.json))\n\t\t\terr := dec.Decode(&str)\n\t\t\tif testCase.err {\n\t\t\t\tassert.NotNil(t, err, \"err should not be nil\")\n\t\t\t\tif testCase.errType != nil {\n\t\t\t\t\tassert.IsType(t, testCase.errType, err, \"err should of the given type\")\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tassert.Nil(t, err, \"err should be nil\")\n\t\t\t}\n\t\t\tassert.Equal(t, testCase.expectedResult, str, fmt.Sprintf(\"'%s' should be equal to expectedResult\", str))\n\t\t})\n\t}\n}\nfunc TestDecoderStringNull(t *testing.T) {\n\ttestCases := []struct {\n\t\tname           string\n\t\tjson           string\n\t\texpectedResult string\n\t\terr            bool\n\t\terrType        interface{}\n\t\tresultIsNil    bool\n\t}{\n\t\t{\n\t\t\tname:           \"basic-string\",\n\t\t\tjson:           `\"string\"`,\n\t\t\texpectedResult: \"string\",\n\t\t\terr:            false,\n\t\t},\n\t\t{\n\t\t\tname:           \"string-solidus\",\n\t\t\tjson:           `\"\\/\"`,\n\t\t\texpectedResult: \"/\",\n\t\t\terr:            false,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-string\",\n\t\t\tjson:           ``,\n\t\t\texpectedResult: \"\",\n\t\t\terr:            false,\n\t\t\tresultIsNil:    true,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-string\",\n\t\t\tjson:           `\"\"`,\n\t\t\texpectedResult: \"\",\n\t\t\terr:            false,\n\t\t},\n\t\t{\n\t\t\tname:           \"basic-string2\",\n\t\t\tjson:           `\"hello world!\"`,\n\t\t\texpectedResult: \"hello world!\",\n\t\t\terr:            false,\n\t\t},\n\t\t{\n\t\t\tname:           \"escape-control-char\",\n\t\t\tjson:           `\"\\n\"`,\n\t\t\texpectedResult: \"\\n\",\n\t\t\terr:            false,\n\t\t},\n\t\t{\n\t\t\tname:           \"escape-control-char\",\n\t\t\tjson:           `\"\\\\n\"`,\n\t\t\texpectedResult: `\\n`,\n\t\t\terr:            false,\n\t\t},\n\t\t{\n\t\t\tname:           \"escape-control-char\",\n\t\t\tjson:           `\"\\t\"`,\n\t\t\texpectedResult: \"\\t\",\n\t\t\terr:            false,\n\t\t},\n\t\t{\n\t\t\tname:           \"escape-control-char\",\n\t\t\tjson:           `\"\\\\t\"`,\n\t\t\texpectedResult: `\\t`,\n\t\t\terr:            false,\n\t\t},\n\t\t{\n\t\t\tname:           \"escape-control-char\",\n\t\t\tjson:           `\"\\b\"`,\n\t\t\texpectedResult: \"\\b\",\n\t\t\terr:            false,\n\t\t},\n\t\t{\n\t\t\tname:           \"escape-control-char\",\n\t\t\tjson:           `\"\\\\b\"`,\n\t\t\texpectedResult: `\\b`,\n\t\t\terr:            false,\n\t\t},\n\t\t{\n\t\t\tname:           \"escape-control-char\",\n\t\t\tjson:           `\"\\f\"`,\n\t\t\texpectedResult: \"\\f\",\n\t\t\terr:            false,\n\t\t},\n\t\t{\n\t\t\tname:           \"escape-control-char\",\n\t\t\tjson:           `\"\\\\f\"`,\n\t\t\texpectedResult: `\\f`,\n\t\t\terr:            false,\n\t\t},\n\t\t{\n\t\t\tname:           \"escape-control-char\",\n\t\t\tjson:           `\"\\r\"`,\n\t\t\texpectedResult: \"\\r\",\n\t\t\terr:            false,\n\t\t},\n\t\t{\n\t\t\tname:           \"escape-control-char\",\n\t\t\tjson:           `\"\\`,\n\t\t\texpectedResult: \"\",\n\t\t\terr:            true,\n\t\t},\n\t\t{\n\t\t\tname:           \"escape-control-char-solidus\",\n\t\t\tjson:           `\"\\/\"`,\n\t\t\texpectedResult: \"/\",\n\t\t\terr:            false,\n\t\t},\n\t\t{\n\t\t\tname:           \"escape-control-char-solidus\",\n\t\t\tjson:           `\"/\"`,\n\t\t\texpectedResult: \"/\",\n\t\t\terr:            false,\n\t\t},\n\t\t{\n\t\t\tname:           \"escape-control-char-solidus-escape-char\",\n\t\t\tjson:           `\"\\\\/\"`,\n\t\t\texpectedResult: `\\/`,\n\t\t\terr:            false,\n\t\t},\n\t\t{\n\t\t\tname:           \"escape-control-char\",\n\t\t\tjson:           `\"\\\\r\"`,\n\t\t\texpectedResult: `\\r`,\n\t\t\terr:            false,\n\t\t},\n\t\t{\n\t\t\tname:           \"utf8\",\n\t\t\tjson:           `\"𠜎 𠜱 𠝹 𠱓 𠱸 𠲖 𠳏 𠳕 𠴕 𠵼 𠵿\"`,\n\t\t\texpectedResult: \"𠜎 𠜱 𠝹 𠱓 𠱸 𠲖 𠳏 𠳕 𠴕 𠵼 𠵿\",\n\t\t\terr:            false,\n\t\t},\n\t\t{\n\t\t\tname:           \"utf8-code-point\",\n\t\t\tjson:           `\"\\u06fc\"`,\n\t\t\texpectedResult: `ۼ`,\n\t\t\terr:            false,\n\t\t},\n\t\t{\n\t\t\tname:           \"utf8-code-point-escaped\",\n\t\t\tjson:           `\"\\\\u2070\"`,\n\t\t\texpectedResult: `\\u2070`,\n\t\t\terr:            false,\n\t\t},\n\t\t{\n\t\t\tname:           \"utf8-code-point-err\",\n\t\t\tjson:           `\"\\u2Z70\"`,\n\t\t\texpectedResult: ``,\n\t\t\terr:            true,\n\t\t},\n\t\t{\n\t\t\tname:           \"utf16-surrogate\",\n\t\t\tjson:           `\"\\uD834\\uDD1E\"`,\n\t\t\texpectedResult: `𝄞`,\n\t\t\terr:            false,\n\t\t},\n\t\t{\n\t\t\tname:           \"utf16-surrogate\",\n\t\t\tjson:           `\"\\uD834\\\\\"`,\n\t\t\texpectedResult: `�\\`,\n\t\t\terr:            false,\n\t\t},\n\t\t{\n\t\t\tname:           \"utf16-surrogate\",\n\t\t\tjson:           `\"\\uD834\\uD834\"`,\n\t\t\texpectedResult: \"�\\x00\\x00\\x00\",\n\t\t\terr:            false,\n\t\t},\n\t\t{\n\t\t\tname:           \"utf16-surrogate\",\n\t\t\tjson:           `\"\\uD834\"`,\n\t\t\texpectedResult: `�`,\n\t\t\terr:            false,\n\t\t},\n\t\t{\n\t\t\tname:           \"utf16-surrogate-err\",\n\t\t\tjson:           `\"\\uD834\\`,\n\t\t\texpectedResult: ``,\n\t\t\terr:            true,\n\t\t},\n\t\t{\n\t\t\tname:           \"utf16-surrogate-err2\",\n\t\t\tjson:           `\"\\uD834\\uDZ1E`,\n\t\t\texpectedResult: ``,\n\t\t\terr:            true,\n\t\t},\n\t\t{\n\t\t\tname:           \"utf16-surrogate-err3\",\n\t\t\tjson:           `\"\\uD834`,\n\t\t\texpectedResult: ``,\n\t\t\terr:            true,\n\t\t},\n\t\t{\n\t\t\tname:           \"utf16-surrogate-followed-by-control-char\",\n\t\t\tjson:           `\"\\uD834\\t\"`,\n\t\t\texpectedResult: \"�\\t\",\n\t\t\terr:            false,\n\t\t},\n\t\t{\n\t\t\tname:           \"utf16-surrogate-followed-by-control-char\",\n\t\t\tjson:           `\"\\uD834\\n\"`,\n\t\t\texpectedResult: \"�\\n\",\n\t\t\terr:            false,\n\t\t},\n\t\t{\n\t\t\tname:           \"utf16-surrogate-followed-by-control-char\",\n\t\t\tjson:           `\"\\uD834\\f\"`,\n\t\t\texpectedResult: \"�\\f\",\n\t\t\terr:            false,\n\t\t},\n\t\t{\n\t\t\tname:           \"utf16-surrogate-followed-by-control-char\",\n\t\t\tjson:           `\"\\uD834\\b\"`,\n\t\t\texpectedResult: \"�\\b\",\n\t\t\terr:            false,\n\t\t},\n\t\t{\n\t\t\tname:           \"utf16-surrogate-followed-by-control-char\",\n\t\t\tjson:           `\"\\uD834\\r\"`,\n\t\t\texpectedResult: \"�\\r\",\n\t\t\terr:            false,\n\t\t},\n\t\t{\n\t\t\tname:           \"utf16-surrogate-followed-by-control-char\",\n\t\t\tjson:           `\"\\uD834\\h\"`,\n\t\t\texpectedResult: \"\",\n\t\t\terr:            true,\n\t\t},\n\t\t{\n\t\t\tname:           \"null\",\n\t\t\tjson:           `null`,\n\t\t\texpectedResult: \"\",\n\t\t\tresultIsNil:    true,\n\t\t},\n\t\t{\n\t\t\tname:           \"null-err\",\n\t\t\tjson:           `nall`,\n\t\t\texpectedResult: \"\",\n\t\t\terr:            true,\n\t\t},\n\t\t{\n\t\t\tname:           \"escape quote err\",\n\t\t\tjson:           `\"test string \\\" escaped\"`,\n\t\t\texpectedResult: `test string \" escaped`,\n\t\t\terr:            false,\n\t\t},\n\t\t{\n\t\t\tname:           \"escape quote err2\",\n\t\t\tjson:           `\"test string \\t escaped\"`,\n\t\t\texpectedResult: \"test string \\t escaped\",\n\t\t\terr:            false,\n\t\t},\n\t\t{\n\t\t\tname:           \"escape quote err2\",\n\t\t\tjson:           `\"test string \\r escaped\"`,\n\t\t\texpectedResult: \"test string \\r escaped\",\n\t\t\terr:            false,\n\t\t},\n\t\t{\n\t\t\tname:           \"escape quote err2\",\n\t\t\tjson:           `\"test string \\b escaped\"`,\n\t\t\texpectedResult: \"test string \\b escaped\",\n\t\t\terr:            false,\n\t\t},\n\t\t{\n\t\t\tname:           \"escape quote err\",\n\t\t\tjson:           `\"test string \\n escaped\"`,\n\t\t\texpectedResult: \"test string \\n escaped\",\n\t\t\terr:            false,\n\t\t},\n\t\t{\n\t\t\tname:           \"escape quote err\",\n\t\t\tjson:           `\"test string \\\\\\\" escaped`,\n\t\t\texpectedResult: ``,\n\t\t\terr:            true,\n\t\t\terrType:        InvalidJSONError(\"\"),\n\t\t},\n\t\t{\n\t\t\tname:           \"escape quote err\",\n\t\t\tjson:           `\"test string \\\\\\l escaped\"`,\n\t\t\texpectedResult: ``,\n\t\t\terr:            true,\n\t\t\terrType:        InvalidJSONError(\"\"),\n\t\t},\n\t\t{\n\t\t\tname:           \"invalid-json\",\n\t\t\tjson:           `invalid`,\n\t\t\texpectedResult: ``,\n\t\t\terr:            true,\n\t\t\terrType:        InvalidJSONError(\"\"),\n\t\t},\n\t\t{\n\t\t\tname:           \"string-complex\",\n\t\t\tjson:           `  \"string with spaces and \\\"escape\\\"d \\\"quotes\\\" and escaped line returns \\n and escaped \\\\\\\\ escaped char\"`,\n\t\t\texpectedResult: \"string with spaces and \\\"escape\\\"d \\\"quotes\\\" and escaped line returns \\n and escaped \\\\\\\\ escaped char\",\n\t\t},\n\t}\n\n\tfor _, testCase := range testCases {\n\t\tt.Run(testCase.name, func(t *testing.T) {\n\t\t\tstr := (*string)(nil)\n\t\t\terr := Unmarshal([]byte(testCase.json), &str)\n\t\t\tif testCase.err {\n\t\t\t\tassert.NotNil(t, err, \"err should not be nil\")\n\t\t\t\tif testCase.errType != nil {\n\t\t\t\t\tassert.IsType(t, testCase.errType, err, \"err should of the given type\")\n\t\t\t\t}\n\t\t\t\treturn\n\t\t\t}\n\t\t\tassert.Nil(t, err, \"Err must be nil\")\n\t\t\tif testCase.resultIsNil {\n\t\t\t\tassert.Nil(t, str)\n\t\t\t} else {\n\t\t\t\tassert.Equal(t, testCase.expectedResult, *str, fmt.Sprintf(\"v must be equal to %s\", testCase.expectedResult))\n\t\t\t}\n\t\t})\n\t}\n\tt.Run(\"decoder-api-invalid-json2\", func(t *testing.T) {\n\t\tvar v = new(string)\n\t\tvar dec = NewDecoder(strings.NewReader(`a`))\n\t\terr := dec.StringNull(&v)\n\t\tassert.NotNil(t, err, \"Err must not be nil\")\n\t\tassert.IsType(t, InvalidJSONError(\"\"), err, \"err should be of type InvalidJSONError\")\n\t})\n}\nfunc TestDecoderStringInvalidType(t *testing.T) {\n\tjson := []byte(`1`)\n\tvar v string\n\terr := Unmarshal(json, &v)\n\tassert.NotNil(t, err, \"Err must not be nil as JSON is invalid\")\n\tassert.IsType(t, InvalidUnmarshalError(\"\"), err, \"err message must be 'Invalid JSON'\")\n}\n\nfunc TestDecoderStringDecoderAPI(t *testing.T) {\n\tvar v string\n\tdec := NewDecoder(strings.NewReader(`\"hello world!\"`))\n\tdefer dec.Release()\n\terr := dec.DecodeString(&v)\n\tassert.Nil(t, err, \"Err must be nil\")\n\tassert.Equal(t, \"hello world!\", v, \"v must be equal to 'hello world!'\")\n}\n\nfunc TestDecoderStringPoolError(t *testing.T) {\n\t// reset the pool to make sure it's not full\n\tdecPool = sync.Pool{\n\t\tNew: func() interface{} {\n\t\t\treturn NewDecoder(nil)\n\t\t},\n\t}\n\tresult := \"\"\n\tdec := NewDecoder(nil)\n\tdec.Release()\n\tdefer func() {\n\t\terr := recover()\n\t\tassert.NotNil(t, err, \"err shouldnt be nil\")\n\t\tassert.IsType(t, InvalidUsagePooledDecoderError(\"\"), err, \"err should be of type InvalidUsagePooledDecoderError\")\n\t}()\n\t_ = dec.DecodeString(&result)\n\tassert.True(t, false, \"should not be called as decoder should have panicked\")\n}\n\nfunc TestDecoderSkipEscapedStringError(t *testing.T) {\n\tdec := NewDecoder(strings.NewReader(``))\n\tdefer dec.Release()\n\terr := dec.skipEscapedString()\n\tassert.NotNil(t, err, \"Err must be nil\")\n\tassert.IsType(t, InvalidJSONError(\"\"), err, \"err must be of type InvalidJSONError\")\n}\n\nfunc TestDecoderSkipEscapedStringError2(t *testing.T) {\n\tdec := NewDecoder(strings.NewReader(`\\\"`))\n\tdefer dec.Release()\n\terr := dec.skipEscapedString()\n\tassert.NotNil(t, err, \"Err must be nil\")\n\tassert.IsType(t, InvalidJSONError(\"\"), err, \"err must be of type InvalidJSONError\")\n}\n\nfunc TestDecoderSkipEscapedStringError3(t *testing.T) {\n\tdec := NewDecoder(strings.NewReader(`invalid`))\n\tdefer dec.Release()\n\terr := dec.skipEscapedString()\n\tassert.NotNil(t, err, \"Err must be nil\")\n\tassert.IsType(t, InvalidJSONError(\"\"), err, \"err must be of type InvalidJSONError\")\n}\n\nfunc TestDecoderSkipEscapedStringError4(t *testing.T) {\n\tdec := NewDecoder(strings.NewReader(`\\u12`))\n\tdefer dec.Release()\n\terr := dec.skipEscapedString()\n\tassert.NotNil(t, err, \"Err must be nil\")\n\tassert.IsType(t, InvalidJSONError(\"\"), err, \"err must be of type InvalidJSONError\")\n}\n\nfunc TestDecoderSkipStringError(t *testing.T) {\n\tdec := NewDecoder(strings.NewReader(`invalid`))\n\tdefer dec.Release()\n\terr := dec.skipString()\n\tassert.NotNil(t, err, \"Err must be nil\")\n\tassert.IsType(t, InvalidJSONError(\"\"), err, \"err must be of type InvalidJSONError\")\n}\n\nfunc TestSkipString(t *testing.T) {\n\ttestCases := []struct {\n\t\tname           string\n\t\tjson           string\n\t\texpectedResult string\n\t\terr            bool\n\t\terrType        interface{}\n\t}{\n\t\t{\n\t\t\tname:           \"escape quote err\",\n\t\t\tjson:           `test string \\\\\" escaped\"`,\n\t\t\texpectedResult: ``,\n\t\t\terr:            true,\n\t\t\terrType:        InvalidJSONError(\"\"),\n\t\t},\n\t\t{\n\t\t\tname:           \"escape quote err\",\n\t\t\tjson:           `test string \\\\\\l escaped\"`,\n\t\t\texpectedResult: ``,\n\t\t\terr:            true,\n\t\t\terrType:        InvalidJSONError(\"\"),\n\t\t},\n\t\t{\n\t\t\tname:           \"string-solidus\",\n\t\t\tjson:           `Asia\\/Bangkok\",\"enable\":true}\"`,\n\t\t\texpectedResult: \"\",\n\t\t\terr:            false,\n\t\t},\n\t\t{\n\t\t\tname:           \"string-unicode\",\n\t\t\tjson:           `[2]\\u66fe\\u5b97\\u5357\"`,\n\t\t\texpectedResult: \"\",\n\t\t\terr:            false,\n\t\t},\n\t}\n\n\tfor _, testCase := range testCases {\n\t\tdec := NewDecoder(strings.NewReader(testCase.json))\n\t\terr := dec.skipString()\n\t\tif testCase.err {\n\t\t\tassert.NotNil(t, err, \"err should not be nil\")\n\t\t\tif testCase.errType != nil {\n\t\t\t\tassert.IsType(t, testCase.errType, err, \"err should be of expected type\")\n\t\t\t}\n\t\t\treturn\n\t\t}\n\t\tassert.Nil(t, err, \"err should be nil\")\n\t}\n}\n"
        },
        {
          "name": "decode_string_unicode.go",
          "type": "blob",
          "size": 2.048828125,
          "content": "package gojay\n\nimport (\n\t\"unicode/utf16\"\n\t\"unicode/utf8\"\n)\n\nfunc (dec *Decoder) getUnicode() (rune, error) {\n\ti := 0\n\tr := rune(0)\n\tfor ; (dec.cursor < dec.length || dec.read()) && i < 4; dec.cursor++ {\n\t\tc := dec.data[dec.cursor]\n\t\tif c >= '0' && c <= '9' {\n\t\t\tr = r*16 + rune(c-'0')\n\t\t} else if c >= 'a' && c <= 'f' {\n\t\t\tr = r*16 + rune(c-'a'+10)\n\t\t} else if c >= 'A' && c <= 'F' {\n\t\t\tr = r*16 + rune(c-'A'+10)\n\t\t} else {\n\t\t\treturn 0, InvalidJSONError(\"Invalid unicode code point\")\n\t\t}\n\t\ti++\n\t}\n\treturn r, nil\n}\n\nfunc (dec *Decoder) appendEscapeChar(str []byte, c byte) ([]byte, error) {\n\tswitch c {\n\tcase 't':\n\t\tstr = append(str, '\\t')\n\tcase 'n':\n\t\tstr = append(str, '\\n')\n\tcase 'r':\n\t\tstr = append(str, '\\r')\n\tcase 'b':\n\t\tstr = append(str, '\\b')\n\tcase 'f':\n\t\tstr = append(str, '\\f')\n\tcase '\\\\':\n\t\tstr = append(str, '\\\\')\n\tdefault:\n\t\treturn nil, InvalidJSONError(\"Invalid JSON\")\n\t}\n\treturn str, nil\n}\n\nfunc (dec *Decoder) parseUnicode() ([]byte, error) {\n\t// get unicode after u\n\tr, err := dec.getUnicode()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\t// no error start making new string\n\tstr := make([]byte, 16, 16)\n\ti := 0\n\t// check if code can be a surrogate utf16\n\tif utf16.IsSurrogate(r) {\n\t\tif dec.cursor >= dec.length && !dec.read() {\n\t\t\treturn nil, dec.raiseInvalidJSONErr(dec.cursor)\n\t\t}\n\t\tc := dec.data[dec.cursor]\n\t\tif c != '\\\\' {\n\t\t\ti += utf8.EncodeRune(str, r)\n\t\t\treturn str[:i], nil\n\t\t}\n\t\tdec.cursor++\n\t\tif dec.cursor >= dec.length && !dec.read() {\n\t\t\treturn nil, dec.raiseInvalidJSONErr(dec.cursor)\n\t\t}\n\t\tc = dec.data[dec.cursor]\n\t\tif c != 'u' {\n\t\t\ti += utf8.EncodeRune(str, r)\n\t\t\tstr, err = dec.appendEscapeChar(str[:i], c)\n\t\t\tif err != nil {\n\t\t\t\tdec.err = err\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\ti++\n\t\t\tdec.cursor++\n\t\t\treturn str[:i], nil\n\t\t}\n\t\tdec.cursor++\n\t\tr2, err := dec.getUnicode()\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tcombined := utf16.DecodeRune(r, r2)\n\t\tif combined == '\\uFFFD' {\n\t\t\ti += utf8.EncodeRune(str, r)\n\t\t\ti += utf8.EncodeRune(str, r2)\n\t\t} else {\n\t\t\ti += utf8.EncodeRune(str, combined)\n\t\t}\n\t\treturn str[:i], nil\n\t}\n\ti += utf8.EncodeRune(str, r)\n\treturn str[:i], nil\n}\n"
        },
        {
          "name": "decode_test.go",
          "type": "blob",
          "size": 14.642578125,
          "content": "package gojay\n\nimport (\n\t\"bytes\"\n\t\"fmt\"\n\t\"reflect\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\ntype testDecodeObj struct {\n\ttest string\n}\n\nfunc (t *testDecodeObj) UnmarshalJSONObject(dec *Decoder, key string) error {\n\tswitch key {\n\tcase \"test\":\n\t\treturn dec.AddString(&t.test)\n\t}\n\treturn nil\n}\nfunc (t *testDecodeObj) NKeys() int {\n\treturn 1\n}\n\ntype testDecodeSlice []*testDecodeObj\n\nfunc (t *testDecodeSlice) UnmarshalJSONArray(dec *Decoder) error {\n\tobj := &testDecodeObj{}\n\tif err := dec.AddObject(obj); err != nil {\n\t\treturn err\n\t}\n\t*t = append(*t, obj)\n\treturn nil\n}\n\ntype allTypeDecodeTestCase struct {\n\tname         string\n\tv            interface{}\n\td            []byte\n\texpectations func(err error, v interface{}, t *testing.T)\n}\n\nfunc allTypesTestCases() []allTypeDecodeTestCase {\n\treturn []allTypeDecodeTestCase{\n\t\t{\n\t\t\tv:    new(string),\n\t\t\td:    []byte(`\"test string\"`),\n\t\t\tname: \"test decode string\",\n\t\t\texpectations: func(err error, v interface{}, t *testing.T) {\n\t\t\t\tvt := v.(*string)\n\t\t\t\tassert.Nil(t, err, \"err must be nil\")\n\t\t\t\tassert.Equal(t, \"test string\", *vt, \"v must be equal to 1\")\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tv:    new(*string),\n\t\t\td:    []byte(`\"test string\"`),\n\t\t\tname: \"test decode string\",\n\t\t\texpectations: func(err error, v interface{}, t *testing.T) {\n\t\t\t\tvt := v.(**string)\n\t\t\t\tassert.Nil(t, err, \"err must be nil\")\n\t\t\t\tassert.Equal(t, \"test string\", **vt, \"v must be equal to 1\")\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tv:    new(string),\n\t\t\td:    []byte(`null`),\n\t\t\tname: \"test decode string null\",\n\t\t\texpectations: func(err error, v interface{}, t *testing.T) {\n\t\t\t\tvt := v.(*string)\n\t\t\t\tassert.Nil(t, err, \"err must be nil\")\n\t\t\t\tassert.Equal(t, \"\", *vt, \"v must be equal to 1\")\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tv:    new(*string),\n\t\t\td:    []byte(`null`),\n\t\t\tname: \"test decode string null\",\n\t\t\texpectations: func(err error, v interface{}, t *testing.T) {\n\t\t\t\tvt := v.(**string)\n\t\t\t\tassert.Nil(t, err, \"err must be nil\")\n\t\t\t\tassert.Nil(t, *vt, \"v must be nil\")\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tv:    new(*string),\n\t\t\td:    []byte(`1`),\n\t\t\tname: \"test decode string null\",\n\t\t\texpectations: func(err error, v interface{}, t *testing.T) {\n\t\t\t\tvt := v.(**string)\n\t\t\t\tassert.NotNil(t, err, \"err must be nil\")\n\t\t\t\tassert.Nil(t, *vt, \"v must be nil\")\n\t\t\t},\n\t\t},\n\t\t{\n\n\t\t\tv:    new(int),\n\t\t\td:    []byte(`1`),\n\t\t\tname: \"test decode int\",\n\t\t\texpectations: func(err error, v interface{}, t *testing.T) {\n\t\t\t\tvt := v.(*int)\n\t\t\t\tassert.Nil(t, err, \"err must be nil\")\n\t\t\t\tassert.Equal(t, 1, *vt, \"v must be equal to 1\")\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tv:    new(*int),\n\t\t\td:    []byte(`1`),\n\t\t\tname: \"test decode int\",\n\t\t\texpectations: func(err error, v interface{}, t *testing.T) {\n\t\t\t\tvt := v.(**int)\n\t\t\t\tassert.Nil(t, err, \"err must be nil\")\n\t\t\t\tassert.Equal(t, 1, **vt, \"v must be equal to 1\")\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tv:    new(*int),\n\t\t\td:    []byte(`\"\"`),\n\t\t\tname: \"test decode int\",\n\t\t\texpectations: func(err error, v interface{}, t *testing.T) {\n\t\t\t\tassert.NotNil(t, err, \"err must be nil\")\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tv:    new(*int8),\n\t\t\td:    []byte(`1`),\n\t\t\tname: \"test decode int\",\n\t\t\texpectations: func(err error, v interface{}, t *testing.T) {\n\t\t\t\tvt := v.(**int8)\n\t\t\t\tassert.Nil(t, err, \"err must be nil\")\n\t\t\t\tassert.Equal(t, int8(1), **vt, \"v must be equal to 1\")\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tv:    new(*int8),\n\t\t\td:    []byte(`\"\"`),\n\t\t\tname: \"test decode int\",\n\t\t\texpectations: func(err error, v interface{}, t *testing.T) {\n\t\t\t\tassert.NotNil(t, err, \"err must be nil\")\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tv:    new(*int16),\n\t\t\td:    []byte(`1`),\n\t\t\tname: \"test decode int\",\n\t\t\texpectations: func(err error, v interface{}, t *testing.T) {\n\t\t\t\tvt := v.(**int16)\n\t\t\t\tassert.Nil(t, err, \"err must be nil\")\n\t\t\t\tassert.Equal(t, int16(1), **vt, \"v must be equal to 1\")\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tv:    new(*int16),\n\t\t\td:    []byte(`\"\"`),\n\t\t\tname: \"test decode int\",\n\t\t\texpectations: func(err error, v interface{}, t *testing.T) {\n\t\t\t\tassert.NotNil(t, err, \"err must be nil\")\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tv:    new(int64),\n\t\t\td:    []byte(`1`),\n\t\t\tname: \"test decode int64\",\n\t\t\texpectations: func(err error, v interface{}, t *testing.T) {\n\t\t\t\tvt := v.(*int64)\n\t\t\t\tassert.Nil(t, err, \"err must be nil\")\n\t\t\t\tassert.Equal(t, int64(1), *vt, \"v must be equal to 1\")\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tv:    new(*int64),\n\t\t\td:    []byte(`1`),\n\t\t\tname: \"test decode int64\",\n\t\t\texpectations: func(err error, v interface{}, t *testing.T) {\n\t\t\t\tvt := v.(**int64)\n\t\t\t\tassert.Nil(t, err, \"err must be nil\")\n\t\t\t\tassert.Equal(t, int64(1), **vt, \"v must be equal to 1\")\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tv:    new(*int64),\n\t\t\td:    []byte(`\"\"`),\n\t\t\tname: \"test decode int64\",\n\t\t\texpectations: func(err error, v interface{}, t *testing.T) {\n\t\t\t\tassert.NotNil(t, err, \"err must be nil\")\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tv:    new(uint64),\n\t\t\td:    []byte(`1`),\n\t\t\tname: \"test decode uint64\",\n\t\t\texpectations: func(err error, v interface{}, t *testing.T) {\n\t\t\t\tvt := v.(*uint64)\n\t\t\t\tassert.Nil(t, err, \"err must be nil\")\n\t\t\t\tassert.Equal(t, uint64(1), *vt, \"v must be equal to 1\")\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tv:    new(*uint64),\n\t\t\td:    []byte(`1`),\n\t\t\tname: \"test decode uint64\",\n\t\t\texpectations: func(err error, v interface{}, t *testing.T) {\n\t\t\t\tvt := v.(**uint64)\n\t\t\t\tassert.Nil(t, err, \"err must be nil\")\n\t\t\t\tassert.Equal(t, uint64(1), **vt, \"v must be equal to 1\")\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tv:    new(interface{}),\n\t\t\td:    []byte(`[{\"test\":\"test\"},{\"test\":\"test2\"}]`),\n\t\t\tname: \"test decode interface\",\n\t\t\texpectations: func(err error, v interface{}, t *testing.T) {\n\t\t\t\tassert.Nil(t, err, \"err must be nil\")\n\t\t\t\t// v is a pointer to an interface{}, we need to extract the content\n\t\t\t\tvCont := reflect.ValueOf(v).Elem().Interface()\n\t\t\t\tvt := vCont.([]interface{})\n\t\t\t\tassert.Len(t, vt, 2, \"len of vt must be 2\")\n\t\t\t\tvt1 := vt[0].(map[string]interface{})\n\t\t\t\tassert.Equal(t, \"test\", vt1[\"test\"], \"vt1['test'] must be equal to 'test'\")\n\t\t\t\tvt2 := vt[1].(map[string]interface{})\n\t\t\t\tassert.Equal(t, \"test2\", vt2[\"test\"], \"vt2['test'] must be equal to 'test2'\")\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tv:    new(uint64),\n\t\t\td:    []byte(`-1`),\n\t\t\tname: \"test decode uint64 negative\",\n\t\t\texpectations: func(err error, v interface{}, t *testing.T) {\n\t\t\t\tvt := v.(*uint64)\n\t\t\t\tassert.NotNil(t, err, \"err must not be nil\")\n\t\t\t\tassert.Equal(t, uint64(0), *vt, \"v must be equal to 1\")\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tv:    new(int32),\n\t\t\td:    []byte(`1`),\n\t\t\tname: \"test decode int32\",\n\t\t\texpectations: func(err error, v interface{}, t *testing.T) {\n\t\t\t\tvt := v.(*int32)\n\t\t\t\tassert.Nil(t, err, \"err must be nil\")\n\t\t\t\tassert.Equal(t, int32(1), *vt, \"v must be equal to 1\")\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tv:    new(*int32),\n\t\t\td:    []byte(`1`),\n\t\t\tname: \"test decode int32\",\n\t\t\texpectations: func(err error, v interface{}, t *testing.T) {\n\t\t\t\tvt := v.(**int32)\n\t\t\t\tassert.Nil(t, err, \"err must be nil\")\n\t\t\t\tassert.Equal(t, int32(1), **vt, \"v must be equal to 1\")\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tv:    new(uint32),\n\t\t\td:    []byte(`1`),\n\t\t\tname: \"test decode uint32\",\n\t\t\texpectations: func(err error, v interface{}, t *testing.T) {\n\t\t\t\tvt := v.(*uint32)\n\t\t\t\tassert.Nil(t, err, \"err must be nil\")\n\t\t\t\tassert.Equal(t, uint32(1), *vt, \"v must be equal to 1\")\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tv:    new(*uint32),\n\t\t\td:    []byte(`1`),\n\t\t\tname: \"test decode uint32\",\n\t\t\texpectations: func(err error, v interface{}, t *testing.T) {\n\t\t\t\tvt := v.(**uint32)\n\t\t\t\tassert.Nil(t, err, \"err must be nil\")\n\t\t\t\tassert.Equal(t, uint32(1), **vt, \"v must be equal to 1\")\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tv:    new(uint32),\n\t\t\td:    []byte(`-1`),\n\t\t\tname: \"test decode uint32 negative\",\n\t\t\texpectations: func(err error, v interface{}, t *testing.T) {\n\t\t\t\tvt := v.(*uint32)\n\t\t\t\tassert.NotNil(t, err, \"err must not be nil\")\n\t\t\t\tassert.Equal(t, uint32(0), *vt, \"v must be equal to 1\")\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tv:    new(*uint16),\n\t\t\td:    []byte(`1`),\n\t\t\tname: \"test decode uint16\",\n\t\t\texpectations: func(err error, v interface{}, t *testing.T) {\n\t\t\t\tvt := v.(**uint16)\n\t\t\t\tassert.Nil(t, err, \"err must be nil\")\n\t\t\t\tassert.Equal(t, uint16(1), **vt, \"v must be equal to 1\")\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tv:    new(*uint8),\n\t\t\td:    []byte(`1`),\n\t\t\tname: \"test decode uint8\",\n\t\t\texpectations: func(err error, v interface{}, t *testing.T) {\n\t\t\t\tvt := v.(**uint8)\n\t\t\t\tassert.Nil(t, err, \"err must be nil\")\n\t\t\t\tassert.Equal(t, uint8(1), **vt, \"v must be equal to 1\")\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tv:    new(float64),\n\t\t\td:    []byte(`1.15`),\n\t\t\tname: \"test decode float64\",\n\t\t\texpectations: func(err error, v interface{}, t *testing.T) {\n\t\t\t\tvt := v.(*float64)\n\t\t\t\tassert.Nil(t, err, \"err must be nil\")\n\t\t\t\tassert.Equal(t, float64(1.15), *vt, \"v must be equal to 1\")\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tv:    new(*float64),\n\t\t\td:    []byte(`1.15`),\n\t\t\tname: \"test decode float64\",\n\t\t\texpectations: func(err error, v interface{}, t *testing.T) {\n\t\t\t\tvt := v.(**float64)\n\t\t\t\tassert.Nil(t, err, \"err must be nil\")\n\t\t\t\tassert.Equal(t, float64(1.15), **vt, \"v must be equal to 1\")\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tv:    new(float64),\n\t\t\td:    []byte(`null`),\n\t\t\tname: \"test decode float64 null\",\n\t\t\texpectations: func(err error, v interface{}, t *testing.T) {\n\t\t\t\tvt := v.(*float64)\n\t\t\t\tassert.Nil(t, err, \"err must be nil\")\n\t\t\t\tassert.Equal(t, float64(0), *vt, \"v must be equal to 1\")\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tv:    new(*float32),\n\t\t\td:    []byte(`1.15`),\n\t\t\tname: \"test decode float64 null\",\n\t\t\texpectations: func(err error, v interface{}, t *testing.T) {\n\t\t\t\tvt := v.(**float32)\n\t\t\t\tassert.Nil(t, err, \"err must be nil\")\n\t\t\t\tassert.Equal(t, float32(1.15), **vt, \"v must be equal to 1\")\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tv:    new(bool),\n\t\t\td:    []byte(`true`),\n\t\t\tname: \"test decode bool true\",\n\t\t\texpectations: func(err error, v interface{}, t *testing.T) {\n\t\t\t\tvt := v.(*bool)\n\t\t\t\tassert.Nil(t, err, \"err must be nil\")\n\t\t\t\tassert.Equal(t, true, *vt, \"v must be equal to 1\")\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tv:    new(*bool),\n\t\t\td:    []byte(`true`),\n\t\t\tname: \"test decode bool true\",\n\t\t\texpectations: func(err error, v interface{}, t *testing.T) {\n\t\t\t\tvt := v.(**bool)\n\t\t\t\tassert.Nil(t, err, \"err must be nil\")\n\t\t\t\tassert.Equal(t, true, **vt, \"v must be equal to 1\")\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tv:    new(bool),\n\t\t\td:    []byte(`false`),\n\t\t\tname: \"test decode bool false\",\n\t\t\texpectations: func(err error, v interface{}, t *testing.T) {\n\t\t\t\tvt := v.(*bool)\n\t\t\t\tassert.Nil(t, err, \"err must be nil\")\n\t\t\t\tassert.Equal(t, false, *vt, \"v must be equal to 1\")\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tv:    new(bool),\n\t\t\td:    []byte(`null`),\n\t\t\tname: \"test decode bool null\",\n\t\t\texpectations: func(err error, v interface{}, t *testing.T) {\n\t\t\t\tvt := v.(*bool)\n\t\t\t\tassert.Nil(t, err, \"err must be nil\")\n\t\t\t\tassert.Equal(t, false, *vt, \"v must be equal to 1\")\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tv:    new(testDecodeObj),\n\t\t\td:    []byte(`{\"test\":\"test\"}`),\n\t\t\tname: \"test decode object\",\n\t\t\texpectations: func(err error, v interface{}, t *testing.T) {\n\t\t\t\tvt := v.(*testDecodeObj)\n\t\t\t\tassert.Nil(t, err, \"err must be nil\")\n\t\t\t\tassert.Equal(t, \"test\", vt.test, \"v.test must be equal to 'test'\")\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tv:    new(testDecodeObj),\n\t\t\td:    []byte(`{\"test\":null}`),\n\t\t\tname: \"test decode object null key\",\n\t\t\texpectations: func(err error, v interface{}, t *testing.T) {\n\t\t\t\tvt := v.(*testDecodeObj)\n\t\t\t\tassert.Nil(t, err, \"err must be nil\")\n\t\t\t\tassert.Equal(t, \"\", vt.test, \"v.test must be equal to 'test'\")\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tv:    new(testDecodeObj),\n\t\t\td:    []byte(`null`),\n\t\t\tname: \"test decode object null\",\n\t\t\texpectations: func(err error, v interface{}, t *testing.T) {\n\t\t\t\tvt := v.(*testDecodeObj)\n\t\t\t\tassert.Nil(t, err, \"err must be nil\")\n\t\t\t\tassert.Equal(t, \"\", vt.test, \"v.test must be equal to 'test'\")\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tv:    new(testDecodeSlice),\n\t\t\td:    []byte(`[{\"test\":\"test\"}]`),\n\t\t\tname: \"test decode slice\",\n\t\t\texpectations: func(err error, v interface{}, t *testing.T) {\n\t\t\t\tvtPtr := v.(*testDecodeSlice)\n\t\t\t\tvt := *vtPtr\n\t\t\t\tassert.Nil(t, err, \"err must be nil\")\n\t\t\t\tassert.Len(t, vt, 1, \"len of vt must be 1\")\n\t\t\t\tassert.Equal(t, \"test\", vt[0].test, \"vt[0].test must be equal to 'test'\")\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tv:    new(testDecodeSlice),\n\t\t\td:    []byte(`[{\"test\":\"test\"},{\"test\":\"test2\"}]`),\n\t\t\tname: \"test decode slice\",\n\t\t\texpectations: func(err error, v interface{}, t *testing.T) {\n\t\t\t\tvtPtr := v.(*testDecodeSlice)\n\t\t\t\tvt := *vtPtr\n\t\t\t\tassert.Nil(t, err, \"err must be nil\")\n\t\t\t\tassert.Len(t, vt, 2, \"len of vt must be 2\")\n\t\t\t\tassert.Equal(t, \"test\", vt[0].test, \"vt[0].test must be equal to 'test'\")\n\t\t\t\tassert.Equal(t, \"test2\", vt[1].test, \"vt[1].test must be equal to 'test2'\")\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tv:    new(struct{}),\n\t\t\td:    []byte(`{\"test\":\"test\"}`),\n\t\t\tname: \"test decode invalid type\",\n\t\t\texpectations: func(err error, v interface{}, t *testing.T) {\n\t\t\t\tassert.NotNil(t, err, \"err must not be nil\")\n\t\t\t\tassert.IsType(t, InvalidUnmarshalError(\"\"), err, \"err must be of type InvalidUnmarshalError\")\n\t\t\t\tassert.Equal(t, fmt.Sprintf(invalidUnmarshalErrorMsg, v), err.Error(), \"err message should be equal to invalidUnmarshalErrorMsg\")\n\t\t\t},\n\t\t},\n\t}\n}\n\n// Unmarshal tests\nfunc TestUnmarshalAllTypes(t *testing.T) {\n\tfor _, testCase := range allTypesTestCases() {\n\t\ttestCase := testCase\n\t\tt.Run(testCase.name, func(*testing.T) {\n\t\t\terr := Unmarshal(testCase.d, testCase.v)\n\t\t\ttestCase.expectations(err, testCase.v, t)\n\t\t})\n\t}\n}\n\n// Decode tests\nfunc TestDecodeAllTypes(t *testing.T) {\n\tfor _, testCase := range allTypesTestCases() {\n\t\ttestCase := testCase\n\t\tt.Run(testCase.name, func(*testing.T) {\n\t\t\tdec := NewDecoder(bytes.NewReader(testCase.d))\n\t\t\terr := dec.Decode(testCase.v)\n\t\t\ttestCase.expectations(err, testCase.v, t)\n\t\t})\n\t}\n}\n\nfunc TestUnmarshalJSONObjects(t *testing.T) {\n\ttestCases := []struct {\n\t\tname         string\n\t\tv            UnmarshalerJSONObject\n\t\td            []byte\n\t\texpectations func(err error, v interface{}, t *testing.T)\n\t}{\n\t\t{\n\t\t\tv:    new(testDecodeObj),\n\t\t\td:    []byte(`{\"test\":\"test\"}`),\n\t\t\tname: \"test decode object\",\n\t\t\texpectations: func(err error, v interface{}, t *testing.T) {\n\t\t\t\tvt := v.(*testDecodeObj)\n\t\t\t\tassert.Nil(t, err, \"err must be nil\")\n\t\t\t\tassert.Equal(t, \"test\", vt.test, \"v.test must be equal to 'test'\")\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tv:    new(testDecodeObj),\n\t\t\td:    []byte(`{\"test\":null}`),\n\t\t\tname: \"test decode object null key\",\n\t\t\texpectations: func(err error, v interface{}, t *testing.T) {\n\t\t\t\tvt := v.(*testDecodeObj)\n\t\t\t\tassert.Nil(t, err, \"err must be nil\")\n\t\t\t\tassert.Equal(t, \"\", vt.test, \"v.test must be equal to 'test'\")\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tv:    new(testDecodeObj),\n\t\t\td:    []byte(`null`),\n\t\t\tname: \"test decode object null\",\n\t\t\texpectations: func(err error, v interface{}, t *testing.T) {\n\t\t\t\tvt := v.(*testDecodeObj)\n\t\t\t\tassert.Nil(t, err, \"err must be nil\")\n\t\t\t\tassert.Equal(t, \"\", vt.test, \"v.test must be equal to 'test'\")\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tv:    new(testDecodeObj),\n\t\t\td:    []byte(`invalid json`),\n\t\t\tname: \"test decode object null\",\n\t\t\texpectations: func(err error, v interface{}, t *testing.T) {\n\t\t\t\tassert.NotNil(t, err, \"err must not be nil\")\n\t\t\t\tassert.IsType(t, InvalidJSONError(\"\"), err, \"err must be of type InvalidJSONError\")\n\t\t\t},\n\t\t},\n\t}\n\tfor _, testCase := range testCases {\n\t\ttestCase := testCase\n\t\tt.Run(testCase.name, func(*testing.T) {\n\t\t\terr := UnmarshalJSONObject(testCase.d, testCase.v)\n\t\t\ttestCase.expectations(err, testCase.v, t)\n\t\t})\n\t}\n}\n"
        },
        {
          "name": "decode_time.go",
          "type": "blob",
          "size": 1.201171875,
          "content": "package gojay\n\nimport (\n\t\"time\"\n)\n\n// DecodeTime decodes time with the given format\nfunc (dec *Decoder) DecodeTime(v *time.Time, format string) error {\n\tif dec.isPooled == 1 {\n\t\tpanic(InvalidUsagePooledDecoderError(\"Invalid usage of pooled decoder\"))\n\t}\n\treturn dec.decodeTime(v, format)\n}\n\nfunc (dec *Decoder) decodeTime(v *time.Time, format string) error {\n\tif format == time.RFC3339 {\n\t\tvar ej = make(EmbeddedJSON, 0, 20)\n\t\tif err := dec.decodeEmbeddedJSON(&ej); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif err := v.UnmarshalJSON(ej); err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t}\n\tvar str string\n\tif err := dec.decodeString(&str); err != nil {\n\t\treturn err\n\t}\n\ttt, err := time.Parse(format, str)\n\tif err != nil {\n\t\treturn err\n\t}\n\t*v = tt\n\treturn nil\n}\n\n// Add Values functions\n\n// AddTime decodes the JSON value within an object or an array to a *time.Time with the given format\nfunc (dec *Decoder) AddTime(v *time.Time, format string) error {\n\treturn dec.Time(v, format)\n}\n\n// Time decodes the JSON value within an object or an array to a *time.Time with the given format\nfunc (dec *Decoder) Time(v *time.Time, format string) error {\n\terr := dec.decodeTime(v, format)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdec.called |= 1\n\treturn nil\n}\n"
        },
        {
          "name": "decode_time_test.go",
          "type": "blob",
          "size": 3.1318359375,
          "content": "package gojay\n\nimport (\n\t\"strings\"\n\t\"sync\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestDecodeTime(t *testing.T) {\n\ttestCases := []struct {\n\t\tname         string\n\t\tjson         string\n\t\tformat       string\n\t\terr          bool\n\t\texpectedTime string\n\t}{\n\t\t{\n\t\t\tname:         \"basic\",\n\t\t\tjson:         `\"2018-02-18\"`,\n\t\t\tformat:       `2006-01-02`,\n\t\t\terr:          false,\n\t\t\texpectedTime: \"2018-02-18\",\n\t\t},\n\t\t{\n\t\t\tname:         \"basic\",\n\t\t\tjson:         `\"2017-01-02T15:04:05Z\"`,\n\t\t\tformat:       time.RFC3339,\n\t\t\terr:          false,\n\t\t\texpectedTime: \"2017-01-02T15:04:05Z\",\n\t\t},\n\t\t{\n\t\t\tname:         \"basic\",\n\t\t\tjson:         `\"2017-01-02T15:04:05ZINVALID\"`,\n\t\t\tformat:       time.RFC3339,\n\t\t\terr:          true,\n\t\t\texpectedTime: \"\",\n\t\t},\n\t\t{\n\t\t\tname:         \"basic\",\n\t\t\tjson:         `\"2017-01-02T15:04:05ZINVALID`,\n\t\t\tformat:       time.RFC1123,\n\t\t\terr:          true,\n\t\t\texpectedTime: \"\",\n\t\t},\n\t\t{\n\t\t\tname:         \"basic\",\n\t\t\tjson:         `\"2017-01-02T15:04:05ZINVALID\"`,\n\t\t\tformat:       time.RFC1123,\n\t\t\terr:          true,\n\t\t\texpectedTime: \"\",\n\t\t},\n\t\t{\n\t\t\tname:         \"basic\",\n\t\t\tjson:         `\"2017-01-02T15:04:05ZINVALID`,\n\t\t\tformat:       time.RFC3339,\n\t\t\terr:          true,\n\t\t\texpectedTime: \"\",\n\t\t},\n\t}\n\n\tfor _, testCase := range testCases {\n\t\tt.Run(testCase.name, func(t *testing.T) {\n\t\t\ttm := time.Time{}\n\t\t\tdec := NewDecoder(strings.NewReader(testCase.json))\n\t\t\terr := dec.DecodeTime(&tm, testCase.format)\n\t\t\tif !testCase.err {\n\t\t\t\tassert.Nil(t, err)\n\t\t\t\tassert.Equal(t, testCase.expectedTime, tm.Format(testCase.format))\n\t\t\t\treturn\n\t\t\t}\n\t\t\tassert.NotNil(t, err)\n\t\t})\n\t}\n}\n\nfunc TestDecodeAddTime(t *testing.T) {\n\ttestCases := []struct {\n\t\tname         string\n\t\tjson         string\n\t\tformat       string\n\t\terr          bool\n\t\texpectedTime string\n\t}{\n\t\t{\n\t\t\tname:         \"basic\",\n\t\t\tjson:         `\"2018-02-18\"`,\n\t\t\tformat:       `2006-01-02`,\n\t\t\terr:          false,\n\t\t\texpectedTime: \"2018-02-18\",\n\t\t},\n\t\t{\n\t\t\tname:         \"basic\",\n\t\t\tjson:         ` \"2017-01-02T15:04:05Z\"`,\n\t\t\tformat:       time.RFC3339,\n\t\t\terr:          false,\n\t\t\texpectedTime: \"2017-01-02T15:04:05Z\",\n\t\t},\n\t\t{\n\t\t\tname:         \"basic\",\n\t\t\tjson:         ` \"2017-01-02T15:04:05ZINVALID\"`,\n\t\t\tformat:       time.RFC3339,\n\t\t\terr:          true,\n\t\t\texpectedTime: \"\",\n\t\t},\n\t}\n\n\tfor _, testCase := range testCases {\n\t\tt.Run(testCase.name, func(t *testing.T) {\n\t\t\ttm := time.Time{}\n\t\t\tdec := NewDecoder(strings.NewReader(testCase.json))\n\t\t\terr := dec.AddTime(&tm, testCase.format)\n\t\t\tif !testCase.err {\n\t\t\t\tassert.Nil(t, err)\n\t\t\t\tassert.Equal(t, testCase.expectedTime, tm.Format(testCase.format))\n\t\t\t\treturn\n\t\t\t}\n\t\t\tassert.NotNil(t, err)\n\t\t})\n\t}\n}\n\nfunc TestDecoderTimePoolError(t *testing.T) {\n\t// reset the pool to make sure it's not full\n\tdecPool = sync.Pool{\n\t\tNew: func() interface{} {\n\t\t\treturn NewDecoder(nil)\n\t\t},\n\t}\n\tdec := NewDecoder(nil)\n\tdec.Release()\n\tdefer func() {\n\t\terr := recover()\n\t\tassert.NotNil(t, err, \"err shouldnt be nil\")\n\t\tassert.IsType(t, InvalidUsagePooledDecoderError(\"\"), err, \"err should be of type InvalidUsagePooledDecoderError\")\n\t}()\n\t_ = dec.DecodeTime(&time.Time{}, time.RFC3339)\n\tassert.True(t, false, \"should not be called as decoder should have panicked\")\n}\n"
        },
        {
          "name": "decode_unsafe.go",
          "type": "blob",
          "size": 2.837890625,
          "content": "package gojay\n\nimport (\n\t\"fmt\"\n)\n\n// Unsafe is the structure holding the unsafe version of the API.\n// The difference between unsafe api and regular api is that the regular API\n// copies the buffer passed to Unmarshal functions to a new internal buffer.\n// Making it safer because internally GoJay uses unsafe.Pointer to transform slice of bytes into a string.\nvar Unsafe = decUnsafe{}\n\ntype decUnsafe struct{}\n\nfunc (u decUnsafe) UnmarshalJSONArray(data []byte, v UnmarshalerJSONArray) error {\n\tdec := borrowDecoder(nil, 0)\n\tdefer dec.Release()\n\tdec.data = data\n\tdec.length = len(data)\n\t_, err := dec.decodeArray(v)\n\treturn err\n}\n\nfunc (u decUnsafe) UnmarshalJSONObject(data []byte, v UnmarshalerJSONObject) error {\n\tdec := borrowDecoder(nil, 0)\n\tdefer dec.Release()\n\tdec.data = data\n\tdec.length = len(data)\n\t_, err := dec.decodeObject(v)\n\treturn err\n}\n\nfunc (u decUnsafe) Unmarshal(data []byte, v interface{}) error {\n\tvar err error\n\tvar dec *Decoder\n\tswitch vt := v.(type) {\n\tcase *string:\n\t\tdec = borrowDecoder(nil, 0)\n\t\tdec.length = len(data)\n\t\tdec.data = data\n\t\terr = dec.decodeString(vt)\n\tcase *int:\n\t\tdec = borrowDecoder(nil, 0)\n\t\tdec.length = len(data)\n\t\tdec.data = data\n\t\terr = dec.decodeInt(vt)\n\tcase *int8:\n\t\tdec = borrowDecoder(nil, 0)\n\t\tdec.length = len(data)\n\t\tdec.data = data\n\t\terr = dec.decodeInt8(vt)\n\tcase *int16:\n\t\tdec = borrowDecoder(nil, 0)\n\t\tdec.length = len(data)\n\t\tdec.data = data\n\t\terr = dec.decodeInt16(vt)\n\tcase *int32:\n\t\tdec = borrowDecoder(nil, 0)\n\t\tdec.length = len(data)\n\t\tdec.data = data\n\t\terr = dec.decodeInt32(vt)\n\tcase *int64:\n\t\tdec = borrowDecoder(nil, 0)\n\t\tdec.length = len(data)\n\t\tdec.data = data\n\t\terr = dec.decodeInt64(vt)\n\tcase *uint8:\n\t\tdec = borrowDecoder(nil, 0)\n\t\tdec.length = len(data)\n\t\tdec.data = data\n\t\terr = dec.decodeUint8(vt)\n\tcase *uint16:\n\t\tdec = borrowDecoder(nil, 0)\n\t\tdec.length = len(data)\n\t\tdec.data = data\n\t\terr = dec.decodeUint16(vt)\n\tcase *uint32:\n\t\tdec = borrowDecoder(nil, 0)\n\t\tdec.length = len(data)\n\t\tdec.data = data\n\t\terr = dec.decodeUint32(vt)\n\tcase *uint64:\n\t\tdec = borrowDecoder(nil, 0)\n\t\tdec.length = len(data)\n\t\tdec.data = data\n\t\terr = dec.decodeUint64(vt)\n\tcase *float64:\n\t\tdec = borrowDecoder(nil, 0)\n\t\tdec.length = len(data)\n\t\tdec.data = data\n\t\terr = dec.decodeFloat64(vt)\n\tcase *float32:\n\t\tdec = borrowDecoder(nil, 0)\n\t\tdec.length = len(data)\n\t\tdec.data = data\n\t\terr = dec.decodeFloat32(vt)\n\tcase *bool:\n\t\tdec = borrowDecoder(nil, 0)\n\t\tdec.length = len(data)\n\t\tdec.data = data\n\t\terr = dec.decodeBool(vt)\n\tcase UnmarshalerJSONObject:\n\t\tdec = borrowDecoder(nil, 0)\n\t\tdec.length = len(data)\n\t\tdec.data = data\n\t\t_, err = dec.decodeObject(vt)\n\tcase UnmarshalerJSONArray:\n\t\tdec = borrowDecoder(nil, 0)\n\t\tdec.length = len(data)\n\t\tdec.data = data\n\t\t_, err = dec.decodeArray(vt)\n\tdefault:\n\t\treturn InvalidUnmarshalError(fmt.Sprintf(invalidUnmarshalErrorMsg, vt))\n\t}\n\tdefer dec.Release()\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn dec.err\n}\n"
        },
        {
          "name": "decode_unsafe_test.go",
          "type": "blob",
          "size": 11.7470703125,
          "content": "package gojay\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestUnmarshalUnsafeAllTypes(t *testing.T) {\n\ttestCases := []struct {\n\t\tname         string\n\t\tv            interface{}\n\t\td            []byte\n\t\texpectations func(err error, v interface{}, t *testing.T)\n\t}{\n\t\t{\n\t\t\tv:    new(string),\n\t\t\td:    []byte(`\"test string\"`),\n\t\t\tname: \"test decode string\",\n\t\t\texpectations: func(err error, v interface{}, t *testing.T) {\n\t\t\t\tvt := v.(*string)\n\t\t\t\tassert.Nil(t, err, \"err must be nil\")\n\t\t\t\tassert.Equal(t, \"test string\", *vt, \"v must be equal to 1\")\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tv:    new(string),\n\t\t\td:    []byte(`null`),\n\t\t\tname: \"test decode string null\",\n\t\t\texpectations: func(err error, v interface{}, t *testing.T) {\n\t\t\t\tvt := v.(*string)\n\t\t\t\tassert.Nil(t, err, \"err must be nil\")\n\t\t\t\tassert.Equal(t, \"\", *vt, \"v must be equal to 1\")\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tv:    new(int),\n\t\t\td:    []byte(`1`),\n\t\t\tname: \"test decode int\",\n\t\t\texpectations: func(err error, v interface{}, t *testing.T) {\n\t\t\t\tvt := v.(*int)\n\t\t\t\tassert.Nil(t, err, \"err must be nil\")\n\t\t\t\tassert.Equal(t, 1, *vt, \"v must be equal to 1\")\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tv:    new(int8),\n\t\t\td:    []byte(`1`),\n\t\t\tname: \"test decode int8\",\n\t\t\texpectations: func(err error, v interface{}, t *testing.T) {\n\t\t\t\tvt := v.(*int8)\n\t\t\t\tassert.Nil(t, err, \"err must be nil\")\n\t\t\t\tassert.Equal(t, int8(1), *vt, \"v must be equal to 1\")\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tv:    new(int16),\n\t\t\td:    []byte(`1`),\n\t\t\tname: \"test decode int16\",\n\t\t\texpectations: func(err error, v interface{}, t *testing.T) {\n\t\t\t\tvt := v.(*int16)\n\t\t\t\tassert.Nil(t, err, \"err must be nil\")\n\t\t\t\tassert.Equal(t, int16(1), *vt, \"v must be equal to 1\")\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tv:    new(int32),\n\t\t\td:    []byte(`1`),\n\t\t\tname: \"test decode int32\",\n\t\t\texpectations: func(err error, v interface{}, t *testing.T) {\n\t\t\t\tvt := v.(*int32)\n\t\t\t\tassert.Nil(t, err, \"err must be nil\")\n\t\t\t\tassert.Equal(t, int32(1), *vt, \"v must be equal to 1\")\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tv:    new(int64),\n\t\t\td:    []byte(`1`),\n\t\t\tname: \"test decode int64\",\n\t\t\texpectations: func(err error, v interface{}, t *testing.T) {\n\t\t\t\tvt := v.(*int64)\n\t\t\t\tassert.Nil(t, err, \"err must be nil\")\n\t\t\t\tassert.Equal(t, int64(1), *vt, \"v must be equal to 1\")\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tv:    new(uint64),\n\t\t\td:    []byte(`1`),\n\t\t\tname: \"test decode uint64\",\n\t\t\texpectations: func(err error, v interface{}, t *testing.T) {\n\t\t\t\tvt := v.(*uint64)\n\t\t\t\tassert.Nil(t, err, \"err must be nil\")\n\t\t\t\tassert.Equal(t, uint64(1), *vt, \"v must be equal to 1\")\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tv:    new(uint64),\n\t\t\td:    []byte(`-1`),\n\t\t\tname: \"test decode uint64 negative\",\n\t\t\texpectations: func(err error, v interface{}, t *testing.T) {\n\t\t\t\tvt := v.(*uint64)\n\t\t\t\tassert.NotNil(t, err, \"err must not be nil\")\n\t\t\t\tassert.Equal(t, uint64(0), *vt, \"v must be equal to 1\")\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tv:    new(int32),\n\t\t\td:    []byte(`1`),\n\t\t\tname: \"test decode int32\",\n\t\t\texpectations: func(err error, v interface{}, t *testing.T) {\n\t\t\t\tvt := v.(*int32)\n\t\t\t\tassert.Nil(t, err, \"err must be nil\")\n\t\t\t\tassert.Equal(t, int32(1), *vt, \"v must be equal to 1\")\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tv:    new(uint32),\n\t\t\td:    []byte(`1`),\n\t\t\tname: \"test decode uint32\",\n\t\t\texpectations: func(err error, v interface{}, t *testing.T) {\n\t\t\t\tvt := v.(*uint32)\n\t\t\t\tassert.Nil(t, err, \"err must be nil\")\n\t\t\t\tassert.Equal(t, uint32(1), *vt, \"v must be equal to 1\")\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tv:    new(uint32),\n\t\t\td:    []byte(`-1`),\n\t\t\tname: \"test decode uint32 negative\",\n\t\t\texpectations: func(err error, v interface{}, t *testing.T) {\n\t\t\t\tvt := v.(*uint32)\n\t\t\t\tassert.NotNil(t, err, \"err must not be nil\")\n\t\t\t\tassert.Equal(t, uint32(0), *vt, \"v must be equal to 1\")\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tv:    new(uint8),\n\t\t\td:    []byte(`1`),\n\t\t\tname: \"test decode int8\",\n\t\t\texpectations: func(err error, v interface{}, t *testing.T) {\n\t\t\t\tvt := v.(*uint8)\n\t\t\t\tassert.Nil(t, err, \"err must be nil\")\n\t\t\t\tassert.Equal(t, uint8(1), *vt, \"v must be equal to 1\")\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tv:    new(uint16),\n\t\t\td:    []byte(`1`),\n\t\t\tname: \"test decode uint16\",\n\t\t\texpectations: func(err error, v interface{}, t *testing.T) {\n\t\t\t\tvt := v.(*uint16)\n\t\t\t\tassert.Nil(t, err, \"err must be nil\")\n\t\t\t\tassert.Equal(t, uint16(1), *vt, \"v must be equal to 1\")\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tv:    new(float64),\n\t\t\td:    []byte(`1.15`),\n\t\t\tname: \"test decode float64\",\n\t\t\texpectations: func(err error, v interface{}, t *testing.T) {\n\t\t\t\tvt := v.(*float64)\n\t\t\t\tassert.Nil(t, err, \"err must be nil\")\n\t\t\t\tassert.Equal(t, float64(1.15), *vt, \"v must be equal to 1\")\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tv:    new(float64),\n\t\t\td:    []byte(`null`),\n\t\t\tname: \"test decode float64 null\",\n\t\t\texpectations: func(err error, v interface{}, t *testing.T) {\n\t\t\t\tvt := v.(*float64)\n\t\t\t\tassert.Nil(t, err, \"err must be nil\")\n\t\t\t\tassert.Equal(t, float64(0), *vt, \"v must be equal to 1\")\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tv:    new(float32),\n\t\t\td:    []byte(`1.15`),\n\t\t\tname: \"test decode float64\",\n\t\t\texpectations: func(err error, v interface{}, t *testing.T) {\n\t\t\t\tvt := v.(*float32)\n\t\t\t\tassert.Nil(t, err, \"err must be nil\")\n\t\t\t\tassert.Equal(t, float32(1.15), *vt, \"v must be equal to 1\")\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tv:    new(bool),\n\t\t\td:    []byte(`true`),\n\t\t\tname: \"test decode bool true\",\n\t\t\texpectations: func(err error, v interface{}, t *testing.T) {\n\t\t\t\tvt := v.(*bool)\n\t\t\t\tassert.Nil(t, err, \"err must be nil\")\n\t\t\t\tassert.Equal(t, true, *vt, \"v must be equal to 1\")\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tv:    new(bool),\n\t\t\td:    []byte(`false`),\n\t\t\tname: \"test decode bool false\",\n\t\t\texpectations: func(err error, v interface{}, t *testing.T) {\n\t\t\t\tvt := v.(*bool)\n\t\t\t\tassert.Nil(t, err, \"err must be nil\")\n\t\t\t\tassert.Equal(t, false, *vt, \"v must be equal to 1\")\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tv:    new(bool),\n\t\t\td:    []byte(`null`),\n\t\t\tname: \"test decode bool null\",\n\t\t\texpectations: func(err error, v interface{}, t *testing.T) {\n\t\t\t\tvt := v.(*bool)\n\t\t\t\tassert.Nil(t, err, \"err must be nil\")\n\t\t\t\tassert.Equal(t, false, *vt, \"v must be equal to 1\")\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tv:    new(testDecodeObj),\n\t\t\td:    []byte(`{\"test\":\"test\"}`),\n\t\t\tname: \"test decode object\",\n\t\t\texpectations: func(err error, v interface{}, t *testing.T) {\n\t\t\t\tvt := v.(*testDecodeObj)\n\t\t\t\tassert.Nil(t, err, \"err must be nil\")\n\t\t\t\tassert.Equal(t, \"test\", vt.test, \"v.test must be equal to 'test'\")\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tv:    new(testDecodeObj),\n\t\t\td:    []byte(`{\"test\":null}`),\n\t\t\tname: \"test decode object null key\",\n\t\t\texpectations: func(err error, v interface{}, t *testing.T) {\n\t\t\t\tvt := v.(*testDecodeObj)\n\t\t\t\tassert.Nil(t, err, \"err must be nil\")\n\t\t\t\tassert.Equal(t, \"\", vt.test, \"v.test must be equal to 'test'\")\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tv:    new(testDecodeObj),\n\t\t\td:    []byte(`null`),\n\t\t\tname: \"test decode object null\",\n\t\t\texpectations: func(err error, v interface{}, t *testing.T) {\n\t\t\t\tvt := v.(*testDecodeObj)\n\t\t\t\tassert.Nil(t, err, \"err must be nil\")\n\t\t\t\tassert.Equal(t, \"\", vt.test, \"v.test must be equal to 'test'\")\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tv:    new(testDecodeSlice),\n\t\t\td:    []byte(`[{\"test\":\"test\"}]`),\n\t\t\tname: \"test decode slice\",\n\t\t\texpectations: func(err error, v interface{}, t *testing.T) {\n\t\t\t\tvtPtr := v.(*testDecodeSlice)\n\t\t\t\tvt := *vtPtr\n\t\t\t\tassert.Nil(t, err, \"err must be nil\")\n\t\t\t\tassert.Len(t, vt, 1, \"len of vt must be 1\")\n\t\t\t\tassert.Equal(t, \"test\", vt[0].test, \"vt[0].test must be equal to 'test'\")\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tv:    new(testDecodeSlice),\n\t\t\td:    []byte(`[{\"test\":\"test\"},{\"test\":\"test2\"}]`),\n\t\t\tname: \"test decode slice\",\n\t\t\texpectations: func(err error, v interface{}, t *testing.T) {\n\t\t\t\tvtPtr := v.(*testDecodeSlice)\n\t\t\t\tvt := *vtPtr\n\t\t\t\tassert.Nil(t, err, \"err must be nil\")\n\t\t\t\tassert.Len(t, vt, 2, \"len of vt must be 2\")\n\t\t\t\tassert.Equal(t, \"test\", vt[0].test, \"vt[0].test must be equal to 'test'\")\n\t\t\t\tassert.Equal(t, \"test2\", vt[1].test, \"vt[1].test must be equal to 'test2'\")\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tv:    new(struct{}),\n\t\t\td:    []byte(`{\"test\":\"test\"}`),\n\t\t\tname: \"test decode invalid type\",\n\t\t\texpectations: func(err error, v interface{}, t *testing.T) {\n\t\t\t\tassert.NotNil(t, err, \"err must not be nil\")\n\t\t\t\tassert.IsType(t, InvalidUnmarshalError(\"\"), err, \"err must be of type InvalidUnmarshalError\")\n\t\t\t\tassert.Equal(t, fmt.Sprintf(invalidUnmarshalErrorMsg, v), err.Error(), \"err message should be equal to invalidUnmarshalErrorMsg\")\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tv:    new(int),\n\t\t\td:    []byte(`1a2`),\n\t\t\tname: \"test decode invalid json\",\n\t\t\texpectations: func(err error, v interface{}, t *testing.T) {\n\t\t\t\tassert.NotNil(t, err, \"err must not be nil\")\n\t\t\t\tassert.IsType(t, InvalidJSONError(\"\"), err, \"err must be of type InvalidJSONError\")\n\t\t\t},\n\t\t},\n\t}\n\tfor _, testCase := range testCases {\n\t\ttestCase := testCase\n\t\tt.Run(testCase.name, func(*testing.T) {\n\t\t\terr := Unsafe.Unmarshal(testCase.d, testCase.v)\n\t\t\ttestCase.expectations(err, testCase.v, t)\n\t\t})\n\t}\n}\n\nfunc TestUnmarshalUnsafeObjects(t *testing.T) {\n\ttestCases := []struct {\n\t\tname         string\n\t\tv            UnmarshalerJSONObject\n\t\td            []byte\n\t\texpectations func(err error, v interface{}, t *testing.T)\n\t}{\n\t\t{\n\t\t\tv:    new(testDecodeObj),\n\t\t\td:    []byte(`{\"test\":\"test\"}`),\n\t\t\tname: \"test decode object\",\n\t\t\texpectations: func(err error, v interface{}, t *testing.T) {\n\t\t\t\tvt := v.(*testDecodeObj)\n\t\t\t\tassert.Nil(t, err, \"err must be nil\")\n\t\t\t\tassert.Equal(t, \"test\", vt.test, \"v.test must be equal to 'test'\")\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tv:    new(testDecodeObj),\n\t\t\td:    []byte(`{\"test\":null}`),\n\t\t\tname: \"test decode object null key\",\n\t\t\texpectations: func(err error, v interface{}, t *testing.T) {\n\t\t\t\tvt := v.(*testDecodeObj)\n\t\t\t\tassert.Nil(t, err, \"err must be nil\")\n\t\t\t\tassert.Equal(t, \"\", vt.test, \"v.test must be equal to 'test'\")\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tv:    new(testDecodeObj),\n\t\t\td:    []byte(`null`),\n\t\t\tname: \"test decode object null\",\n\t\t\texpectations: func(err error, v interface{}, t *testing.T) {\n\t\t\t\tvt := v.(*testDecodeObj)\n\t\t\t\tassert.Nil(t, err, \"err must be nil\")\n\t\t\t\tassert.Equal(t, \"\", vt.test, \"v.test must be equal to 'test'\")\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tv:    new(testDecodeObj),\n\t\t\td:    []byte(`invalid json`),\n\t\t\tname: \"test decode object null\",\n\t\t\texpectations: func(err error, v interface{}, t *testing.T) {\n\t\t\t\tassert.NotNil(t, err, \"err must not be nil\")\n\t\t\t\tassert.IsType(t, InvalidJSONError(\"\"), err, \"err must be of type InvalidJSONError\")\n\t\t\t},\n\t\t},\n\t}\n\tfor _, testCase := range testCases {\n\t\ttestCase := testCase\n\t\tt.Run(testCase.name, func(*testing.T) {\n\t\t\terr := Unsafe.UnmarshalJSONObject(testCase.d, testCase.v)\n\t\t\ttestCase.expectations(err, testCase.v, t)\n\t\t})\n\t}\n}\n\nfunc TestUnmarshalUnsafeArrays(t *testing.T) {\n\ttestCases := []struct {\n\t\tname         string\n\t\tv            UnmarshalerJSONArray\n\t\td            []byte\n\t\texpectations func(err error, v interface{}, t *testing.T)\n\t}{\n\t\t{\n\t\t\tv:    new(testDecodeSlice),\n\t\t\td:    []byte(`[{\"test\":\"test\"}]`),\n\t\t\tname: \"test decode slice\",\n\t\t\texpectations: func(err error, v interface{}, t *testing.T) {\n\t\t\t\tvtPtr := v.(*testDecodeSlice)\n\t\t\t\tvt := *vtPtr\n\t\t\t\tassert.Nil(t, err, \"err must be nil\")\n\t\t\t\tassert.Len(t, vt, 1, \"len of vt must be 1\")\n\t\t\t\tassert.Equal(t, \"test\", vt[0].test, \"vt[0].test must be equal to 'test'\")\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tv:    new(testDecodeSlice),\n\t\t\td:    []byte(`[{\"test\":\"test\"},{\"test\":\"test2\"}]`),\n\t\t\tname: \"test decode slice\",\n\t\t\texpectations: func(err error, v interface{}, t *testing.T) {\n\t\t\t\tvtPtr := v.(*testDecodeSlice)\n\t\t\t\tvt := *vtPtr\n\t\t\t\tassert.Nil(t, err, \"err must be nil\")\n\t\t\t\tassert.Len(t, vt, 2, \"len of vt must be 2\")\n\t\t\t\tassert.Equal(t, \"test\", vt[0].test, \"vt[0].test must be equal to 'test'\")\n\t\t\t\tassert.Equal(t, \"test2\", vt[1].test, \"vt[1].test must be equal to 'test2'\")\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tv:    new(testDecodeSlice),\n\t\t\td:    []byte(`invalid json`),\n\t\t\tname: \"test decode object null\",\n\t\t\texpectations: func(err error, v interface{}, t *testing.T) {\n\t\t\t\tassert.NotNil(t, err, \"err must not be nil\")\n\t\t\t\tassert.IsType(t, InvalidJSONError(\"\"), err, \"err must be of type InvalidJSONError\")\n\t\t\t},\n\t\t},\n\t}\n\tfor _, testCase := range testCases {\n\t\ttestCase := testCase\n\t\tt.Run(testCase.name, func(*testing.T) {\n\t\t\terr := Unsafe.UnmarshalJSONArray(testCase.d, testCase.v)\n\t\t\ttestCase.expectations(err, testCase.v, t)\n\t\t})\n\t}\n}\n"
        },
        {
          "name": "encode.go",
          "type": "blob",
          "size": 4.5576171875,
          "content": "package gojay\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"io\"\n)\n\nvar nullBytes = []byte(\"null\")\n\n// MarshalJSONArray returns the JSON encoding of v, an implementation of MarshalerJSONArray.\n//\n//\n// Example:\n// \ttype TestSlice []*TestStruct\n//\n// \tfunc (t TestSlice) MarshalJSONArray(enc *Encoder) {\n//\t\tfor _, e := range t {\n//\t\t\tenc.AddObject(e)\n//\t\t}\n//\t}\n//\n//\tfunc main() {\n//\t\ttest := &TestSlice{\n//\t\t\t&TestStruct{123456},\n//\t\t\t&TestStruct{7890},\n// \t\t}\n// \t\tb, _ := Marshal(test)\n//\t\tfmt.Println(b) // [{\"id\":123456},{\"id\":7890}]\n//\t}\nfunc MarshalJSONArray(v MarshalerJSONArray) ([]byte, error) {\n\tenc := BorrowEncoder(nil)\n\tenc.grow(512)\n\tenc.writeByte('[')\n\tv.(MarshalerJSONArray).MarshalJSONArray(enc)\n\tenc.writeByte(']')\n\n\tdefer func() {\n\t\tenc.buf = make([]byte, 0, 512)\n\t\tenc.Release()\n\t}()\n\n\treturn enc.buf, nil\n}\n\n// MarshalJSONObject returns the JSON encoding of v, an implementation of MarshalerJSONObject.\n//\n// Example:\n//\ttype Object struct {\n//\t\tid int\n//\t}\n//\tfunc (s *Object) MarshalJSONObject(enc *gojay.Encoder) {\n//\t\tenc.IntKey(\"id\", s.id)\n//\t}\n//\tfunc (s *Object) IsNil() bool {\n//\t\treturn s == nil\n//\t}\n//\n// \tfunc main() {\n//\t\ttest := &Object{\n//\t\t\tid: 123456,\n//\t\t}\n//\t\tb, _ := gojay.Marshal(test)\n// \t\tfmt.Println(b) // {\"id\":123456}\n//\t}\nfunc MarshalJSONObject(v MarshalerJSONObject) ([]byte, error) {\n\tenc := BorrowEncoder(nil)\n\tenc.grow(512)\n\n\tdefer func() {\n\t\tenc.buf = make([]byte, 0, 512)\n\t\tenc.Release()\n\t}()\n\n\treturn enc.encodeObject(v)\n}\n\n// Marshal returns the JSON encoding of v.\n//\n// If v is nil, not an implementation MarshalerJSONObject or MarshalerJSONArray or not one of the following types:\n//\tstring, int, int8, int16, int32, int64, uint8, uint16, uint32, uint64, float64, float32, bool\n// Marshal returns an InvalidMarshalError.\nfunc Marshal(v interface{}) ([]byte, error) {\n\treturn marshal(v, false)\n}\n\n// MarshalAny returns the JSON encoding of v.\n//\n// If v is nil, not an implementation MarshalerJSONObject or MarshalerJSONArray or not one of the following types:\n//\tstring, int, int8, int16, int32, int64, uint8, uint16, uint32, uint64, float64, float32, bool\n// MarshalAny falls back to \"json/encoding\" package to marshal the value.\nfunc MarshalAny(v interface{}) ([]byte, error) {\n\treturn marshal(v, true)\n}\n\nfunc marshal(v interface{}, any bool) ([]byte, error) {\n\tvar (\n\t\tenc = BorrowEncoder(nil)\n\n\t\tbuf []byte\n\t\terr error\n\t)\n\n\tdefer func() {\n\t\tenc.buf = make([]byte, 0, 512)\n\t\tenc.Release()\n\t}()\n\n\tbuf, err = func() ([]byte, error) {\n\t\tswitch vt := v.(type) {\n\t\tcase MarshalerJSONObject:\n\t\t\treturn enc.encodeObject(vt)\n\t\tcase MarshalerJSONArray:\n\t\t\treturn enc.encodeArray(vt)\n\t\tcase string:\n\t\t\treturn enc.encodeString(vt)\n\t\tcase bool:\n\t\t\treturn enc.encodeBool(vt)\n\t\tcase int:\n\t\t\treturn enc.encodeInt(vt)\n\t\tcase int64:\n\t\t\treturn enc.encodeInt64(vt)\n\t\tcase int32:\n\t\t\treturn enc.encodeInt(int(vt))\n\t\tcase int16:\n\t\t\treturn enc.encodeInt(int(vt))\n\t\tcase int8:\n\t\t\treturn enc.encodeInt(int(vt))\n\t\tcase uint64:\n\t\t\treturn enc.encodeInt(int(vt))\n\t\tcase uint32:\n\t\t\treturn enc.encodeInt(int(vt))\n\t\tcase uint16:\n\t\t\treturn enc.encodeInt(int(vt))\n\t\tcase uint8:\n\t\t\treturn enc.encodeInt(int(vt))\n\t\tcase float64:\n\t\t\treturn enc.encodeFloat(vt)\n\t\tcase float32:\n\t\t\treturn enc.encodeFloat32(vt)\n\t\tcase *EmbeddedJSON:\n\t\t\treturn enc.encodeEmbeddedJSON(vt)\n\t\tdefault:\n\t\t\tif any {\n\t\t\t\treturn json.Marshal(vt)\n\t\t\t}\n\n\t\t\treturn nil, InvalidMarshalError(fmt.Sprintf(invalidMarshalErrorMsg, vt))\n\t\t}\n\t}()\n\treturn buf, err\n}\n\n// MarshalerJSONObject is the interface to implement for struct to be encoded\ntype MarshalerJSONObject interface {\n\tMarshalJSONObject(enc *Encoder)\n\tIsNil() bool\n}\n\n// MarshalerJSONArray is the interface to implement\n// for a slice or an array to be encoded\ntype MarshalerJSONArray interface {\n\tMarshalJSONArray(enc *Encoder)\n\tIsNil() bool\n}\n\n// An Encoder writes JSON values to an output stream.\ntype Encoder struct {\n\tbuf      []byte\n\tisPooled byte\n\tw        io.Writer\n\terr      error\n\thasKeys  bool\n\tkeys     []string\n}\n\n// AppendBytes allows a modular usage by appending bytes manually to the current state of the buffer.\nfunc (enc *Encoder) AppendBytes(b []byte) {\n\tenc.writeBytes(b)\n}\n\n// AppendByte allows a modular usage by appending a single byte manually to the current state of the buffer.\nfunc (enc *Encoder) AppendByte(b byte) {\n\tenc.writeByte(b)\n}\n\n// Buf returns the Encoder's buffer.\nfunc (enc *Encoder) Buf() []byte {\n\treturn enc.buf\n}\n\n// Write writes to the io.Writer and resets the buffer.\nfunc (enc *Encoder) Write() (int, error) {\n\ti, err := enc.w.Write(enc.buf)\n\tenc.buf = enc.buf[:0]\n\treturn i, err\n}\n\nfunc (enc *Encoder) getPreviousRune() byte {\n\tlast := len(enc.buf) - 1\n\treturn enc.buf[last]\n}\n"
        },
        {
          "name": "encode_array.go",
          "type": "blob",
          "size": 5.6513671875,
          "content": "package gojay\n\n// EncodeArray encodes an implementation of MarshalerJSONArray to JSON\nfunc (enc *Encoder) EncodeArray(v MarshalerJSONArray) error {\n\tif enc.isPooled == 1 {\n\t\tpanic(InvalidUsagePooledEncoderError(\"Invalid usage of pooled encoder\"))\n\t}\n\t_, _ = enc.encodeArray(v)\n\t_, err := enc.Write()\n\tif err != nil {\n\t\tenc.err = err\n\t\treturn err\n\t}\n\treturn nil\n}\nfunc (enc *Encoder) encodeArray(v MarshalerJSONArray) ([]byte, error) {\n\tenc.grow(200)\n\tenc.writeByte('[')\n\tv.MarshalJSONArray(enc)\n\tenc.writeByte(']')\n\treturn enc.buf, enc.err\n}\n\n// AddArray adds an implementation of MarshalerJSONArray to be encoded, must be used inside a slice or array encoding (does not encode a key)\n// value must implement Marshaler\nfunc (enc *Encoder) AddArray(v MarshalerJSONArray) {\n\tenc.Array(v)\n}\n\n// AddArrayOmitEmpty adds an array or slice to be encoded, must be used inside a slice or array encoding (does not encode a key)\n// value must implement MarshalerAddArrayOmitEmpty\nfunc (enc *Encoder) AddArrayOmitEmpty(v MarshalerJSONArray) {\n\tenc.ArrayOmitEmpty(v)\n}\n\n// AddArrayNullEmpty adds an array or slice to be encoded, must be used inside a slice or array encoding (does not encode a key)\n// value must implement Marshaler, if v is empty, `null` will be encoded`\nfunc (enc *Encoder) AddArrayNullEmpty(v MarshalerJSONArray) {\n\tenc.ArrayNullEmpty(v)\n}\n\n// AddArrayKey adds an array or slice to be encoded, must be used inside an object as it will encode a key\n// value must implement Marshaler\nfunc (enc *Encoder) AddArrayKey(key string, v MarshalerJSONArray) {\n\tenc.ArrayKey(key, v)\n}\n\n// AddArrayKeyOmitEmpty adds an array or slice to be encoded and skips it if it is nil.\n// Must be called inside an object as it will encode a key.\nfunc (enc *Encoder) AddArrayKeyOmitEmpty(key string, v MarshalerJSONArray) {\n\tenc.ArrayKeyOmitEmpty(key, v)\n}\n\n// AddArrayKeyNullEmpty adds an array or slice to be encoded and skips it if it is nil.\n// Must be called inside an object as it will encode a key. `null` will be encoded`\nfunc (enc *Encoder) AddArrayKeyNullEmpty(key string, v MarshalerJSONArray) {\n\tenc.ArrayKeyNullEmpty(key, v)\n}\n\n// Array adds an implementation of MarshalerJSONArray to be encoded, must be used inside a slice or array encoding (does not encode a key)\n// value must implement Marshaler\nfunc (enc *Encoder) Array(v MarshalerJSONArray) {\n\tif v.IsNil() {\n\t\tenc.grow(3)\n\t\tr := enc.getPreviousRune()\n\t\tif r != '[' {\n\t\t\tenc.writeByte(',')\n\t\t}\n\t\tenc.writeByte('[')\n\t\tenc.writeByte(']')\n\t\treturn\n\t}\n\tenc.grow(100)\n\tr := enc.getPreviousRune()\n\tif r != '[' {\n\t\tenc.writeByte(',')\n\t}\n\tenc.writeByte('[')\n\tv.MarshalJSONArray(enc)\n\tenc.writeByte(']')\n}\n\n// ArrayOmitEmpty adds an array or slice to be encoded, must be used inside a slice or array encoding (does not encode a key)\n// value must implement Marshaler\nfunc (enc *Encoder) ArrayOmitEmpty(v MarshalerJSONArray) {\n\tif v.IsNil() {\n\t\treturn\n\t}\n\tenc.grow(4)\n\tr := enc.getPreviousRune()\n\tif r != '[' {\n\t\tenc.writeByte(',')\n\t}\n\tenc.writeByte('[')\n\tv.MarshalJSONArray(enc)\n\tenc.writeByte(']')\n}\n\n// ArrayNullEmpty adds an array or slice to be encoded, must be used inside a slice or array encoding (does not encode a key)\n// value must implement Marshaler\nfunc (enc *Encoder) ArrayNullEmpty(v MarshalerJSONArray) {\n\tenc.grow(4)\n\tr := enc.getPreviousRune()\n\tif r != '[' {\n\t\tenc.writeByte(',')\n\t}\n\tif v.IsNil() {\n\t\tenc.writeBytes(nullBytes)\n\t\treturn\n\t}\n\tenc.writeByte('[')\n\tv.MarshalJSONArray(enc)\n\tenc.writeByte(']')\n}\n\n// ArrayKey adds an array or slice to be encoded, must be used inside an object as it will encode a key\n// value must implement Marshaler\nfunc (enc *Encoder) ArrayKey(key string, v MarshalerJSONArray) {\n\tif enc.hasKeys {\n\t\tif !enc.keyExists(key) {\n\t\t\treturn\n\t\t}\n\t}\n\tif v.IsNil() {\n\t\tenc.grow(2 + len(key))\n\t\tr := enc.getPreviousRune()\n\t\tif r != '{' {\n\t\t\tenc.writeByte(',')\n\t\t}\n\t\tenc.writeByte('\"')\n\t\tenc.writeStringEscape(key)\n\t\tenc.writeBytes(objKeyArr)\n\t\tenc.writeByte(']')\n\t\treturn\n\t}\n\tenc.grow(5 + len(key))\n\tr := enc.getPreviousRune()\n\tif r != '{' {\n\t\tenc.writeByte(',')\n\t}\n\tenc.writeByte('\"')\n\tenc.writeStringEscape(key)\n\tenc.writeBytes(objKeyArr)\n\tv.MarshalJSONArray(enc)\n\tenc.writeByte(']')\n}\n\n// ArrayKeyOmitEmpty adds an array or slice to be encoded and skips if it is nil.\n// Must be called inside an object as it will encode a key.\nfunc (enc *Encoder) ArrayKeyOmitEmpty(key string, v MarshalerJSONArray) {\n\tif enc.hasKeys {\n\t\tif !enc.keyExists(key) {\n\t\t\treturn\n\t\t}\n\t}\n\tif v.IsNil() {\n\t\treturn\n\t}\n\tenc.grow(5 + len(key))\n\tr := enc.getPreviousRune()\n\tif r != '{' {\n\t\tenc.writeByte(',')\n\t}\n\tenc.writeByte('\"')\n\tenc.writeStringEscape(key)\n\tenc.writeBytes(objKeyArr)\n\tv.MarshalJSONArray(enc)\n\tenc.writeByte(']')\n}\n\n// ArrayKeyNullEmpty adds an array or slice to be encoded and encodes `null`` if it is nil.\n// Must be called inside an object as it will encode a key.\nfunc (enc *Encoder) ArrayKeyNullEmpty(key string, v MarshalerJSONArray) {\n\tif enc.hasKeys {\n\t\tif !enc.keyExists(key) {\n\t\t\treturn\n\t\t}\n\t}\n\tenc.grow(5 + len(key))\n\tr := enc.getPreviousRune()\n\tif r != '{' {\n\t\tenc.writeByte(',')\n\t}\n\tif v.IsNil() {\n\t\tenc.writeBytes(nullBytes)\n\t\treturn\n\t}\n\tenc.writeByte('\"')\n\tenc.writeStringEscape(key)\n\tenc.writeBytes(objKeyArr)\n\tv.MarshalJSONArray(enc)\n\tenc.writeByte(']')\n}\n\n// EncodeArrayFunc is a custom func type implementing MarshaleArray.\n// Use it to cast a func(*Encoder) to Marshal an object.\n//\n//\tenc := gojay.NewEncoder(io.Writer)\n//\tenc.EncodeArray(gojay.EncodeArrayFunc(func(enc *gojay.Encoder) {\n//\t\tenc.AddStringKey(\"hello\", \"world\")\n//\t}))\ntype EncodeArrayFunc func(*Encoder)\n\n// MarshalJSONArray implements MarshalerJSONArray.\nfunc (f EncodeArrayFunc) MarshalJSONArray(enc *Encoder) {\n\tf(enc)\n}\n\n// IsNil implements MarshalerJSONArray.\nfunc (f EncodeArrayFunc) IsNil() bool {\n\treturn f == nil\n}\n"
        },
        {
          "name": "encode_array_test.go",
          "type": "blob",
          "size": 10.1728515625,
          "content": "package gojay\n\nimport (\n\t\"strings\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\ntype TestEncodingArrStrings []string\n\nfunc (t TestEncodingArrStrings) MarshalJSONArray(enc *Encoder) {\n\tfor _, e := range t {\n\t\tenc.AddString(e)\n\t}\n}\nfunc (t TestEncodingArrStrings) IsNil() bool {\n\treturn len(t) == 0\n}\n\ntype TestEncodingArr []*TestEncoding\n\nfunc (t TestEncodingArr) MarshalJSONArray(enc *Encoder) {\n\tfor _, e := range t {\n\t\tenc.AddObject(e)\n\t}\n}\nfunc (t TestEncodingArr) IsNil() bool {\n\treturn t == nil\n}\n\ntype testEncodingArrInterfaces []interface{}\n\nfunc (t testEncodingArrInterfaces) MarshalJSONArray(enc *Encoder) {\n\tfor _, e := range t {\n\t\tenc.AddInterface(e)\n\t}\n}\nfunc (t testEncodingArrInterfaces) IsNil() bool {\n\treturn t == nil\n}\n\nfunc TestEncoderArrayMarshalAPI(t *testing.T) {\n\tt.Run(\"array-objects\", func(t *testing.T) {\n\t\tv := &TestEncodingArr{\n\t\t\t&TestEncoding{\n\t\t\t\ttest:          \"hello world\",\n\t\t\t\ttest2:         \"漢字\",\n\t\t\t\ttestInt:       1,\n\t\t\t\ttestBool:      true,\n\t\t\t\ttestInterface: 1,\n\t\t\t\tsub: &SubObject{\n\t\t\t\t\ttest1:    10,\n\t\t\t\t\ttest2:    \"hello world\",\n\t\t\t\t\ttest3:    1.23543,\n\t\t\t\t\ttestBool: true,\n\t\t\t\t\tsub: &SubObject{\n\t\t\t\t\t\ttest1:    10,\n\t\t\t\t\t\ttestBool: false,\n\t\t\t\t\t\ttest2:    \"hello world\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\t&TestEncoding{\n\t\t\t\ttest:     \"hello world\",\n\t\t\t\ttest2:    \"漢字\",\n\t\t\t\ttestInt:  1,\n\t\t\t\ttestBool: true,\n\t\t\t\tsub: &SubObject{\n\t\t\t\t\ttest1:    10,\n\t\t\t\t\ttest2:    \"hello world\",\n\t\t\t\t\ttest3:    1.23543,\n\t\t\t\t\ttestBool: true,\n\t\t\t\t\tsub: &SubObject{\n\t\t\t\t\t\ttest1:    10,\n\t\t\t\t\t\ttestBool: false,\n\t\t\t\t\t\ttest2:    \"hello world\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tnil,\n\t\t}\n\t\tr, err := Marshal(v)\n\t\tassert.Nil(t, err, \"Error should be nil\")\n\t\tassert.Equal(\n\t\t\tt,\n\t\t\t`[{\"test\":\"hello world\",\"test2\":\"漢字\",\"testInt\":1,\"testBool\":true,`+\n\t\t\t\t`\"testArr\":[],\"testF64\":0,\"testF32\":0,\"testInterface\":1,\"sub\":{\"test1\":10,\"test2\":\"hello world\",`+\n\t\t\t\t`\"test3\":1.23543,\"testBool\":true,\"sub\":{\"test1\":10,\"test2\":\"hello world\",`+\n\t\t\t\t`\"test3\":0,\"testBool\":false,\"sub\":{}}}},{\"test\":\"hello world\",\"test2\":\"漢字\",\"testInt\":1,`+\n\t\t\t\t`\"testBool\":true,\"testArr\":[],\"testF64\":0,\"testF32\":0,\"sub\":{\"test1\":10,\"test2\":\"hello world\",\"test3\":1.23543,`+\n\t\t\t\t`\"testBool\":true,\"sub\":{\"test1\":10,\"test2\":\"hello world\",\"test3\":0,\"testBool\":false,\"sub\":{}}}},{}]`,\n\t\t\tstring(r),\n\t\t\t\"Result of marshalling is different as the one expected\")\n\t})\n\tt.Run(\"array-interfaces\", func(t *testing.T) {\n\t\tv := &testEncodingArrInterfaces{\n\t\t\t1,\n\t\t\tint64(1),\n\t\t\tint32(1),\n\t\t\tint16(1),\n\t\t\tint8(1),\n\t\t\tuint64(1),\n\t\t\tuint32(1),\n\t\t\tuint16(1),\n\t\t\tuint8(1),\n\t\t\tfloat64(1.31),\n\t\t\tfloat32(1.31),\n\t\t\t&TestEncodingArr{},\n\t\t\t&TestEncodingArrStrings{},\n\t\t\ttrue,\n\t\t\tfalse,\n\t\t\t\"test\",\n\t\t\t&TestEncoding{\n\t\t\t\ttest:     \"hello world\",\n\t\t\t\ttest2:    \"foobar\",\n\t\t\t\ttestInt:  1,\n\t\t\t\ttestBool: true,\n\t\t\t},\n\t\t}\n\t\tr, err := MarshalJSONArray(v)\n\t\tassert.Nil(t, err, \"Error should be nil\")\n\t\tassert.Equal(\n\t\t\tt,\n\t\t\t`[1,1,1,1,1,1,1,1,1.31,1.31,[],[],true,false,\"test\",{\"test\":\"hello world\",\"test2\":\"foobar\",\"testInt\":1,\"testBool\":true,\"testArr\":[],\"testF64\":0,\"testF32\":0,\"sub\":{}}]`,\n\t\t\tstring(r),\n\t\t\t\"Result of marshalling is different as the one expected\")\n\t})\n}\n\nfunc TestEncoderArrayEncodeAPI(t *testing.T) {\n\tt.Run(\"array-interfaces\", func(t *testing.T) {\n\t\tv := &testEncodingArrInterfaces{\n\t\t\t1,\n\t\t\tint64(1),\n\t\t\tint32(1),\n\t\t\tint16(1),\n\t\t\tint8(1),\n\t\t\tuint64(1),\n\t\t\tuint32(1),\n\t\t\tuint16(1),\n\t\t\tuint8(1),\n\t\t\tfloat64(1.31),\n\t\t\t// float32(1.31),\n\t\t\t&TestEncodingArr{},\n\t\t\ttrue,\n\t\t\t\"test\",\n\t\t\t&TestEncoding{\n\t\t\t\ttest:     \"hello world\",\n\t\t\t\ttest2:    \"foobar\",\n\t\t\t\ttestInt:  1,\n\t\t\t\ttestBool: true,\n\t\t\t},\n\t\t}\n\t\tbuilder := &strings.Builder{}\n\t\tenc := BorrowEncoder(builder)\n\t\tdefer enc.Release()\n\t\terr := enc.EncodeArray(v)\n\t\tassert.Nil(t, err, \"Error should be nil\")\n\t\tassert.Equal(\n\t\t\tt,\n\t\t\t`[1,1,1,1,1,1,1,1,1.31,[],true,\"test\",{\"test\":\"hello world\",\"test2\":\"foobar\",\"testInt\":1,\"testBool\":true,\"testArr\":[],\"testF64\":0,\"testF32\":0,\"sub\":{}}]`,\n\t\t\tbuilder.String(),\n\t\t\t\"Result of marshalling is different as the one expected\")\n\t})\n\n\tt.Run(\"array-interfaces-write-error\", func(t *testing.T) {\n\t\tv := &testEncodingArrInterfaces{}\n\t\tw := TestWriterError(\"\")\n\t\tenc := BorrowEncoder(w)\n\t\tdefer enc.Release()\n\t\terr := enc.EncodeArray(v)\n\t\tassert.NotNil(t, err, \"err should not be nil\")\n\t})\n}\n\n// Array add with omit key tests\n\ntype TestEncodingIntOmitEmpty []int\n\nfunc (t TestEncodingIntOmitEmpty) MarshalJSONArray(enc *Encoder) {\n\tfor _, e := range t {\n\t\tenc.AddIntOmitEmpty(e)\n\t}\n}\nfunc (t TestEncodingIntOmitEmpty) IsNil() bool {\n\treturn t == nil\n}\n\ntype TestEncodingStringOmitEmpty []string\n\nfunc (t TestEncodingStringOmitEmpty) MarshalJSONArray(enc *Encoder) {\n\tfor _, e := range t {\n\t\tenc.AddStringOmitEmpty(e)\n\t}\n}\nfunc (t TestEncodingStringOmitEmpty) IsNil() bool {\n\treturn t == nil\n}\n\ntype TestEncodingFloatOmitEmpty []float64\n\nfunc (t TestEncodingFloatOmitEmpty) MarshalJSONArray(enc *Encoder) {\n\tfor _, e := range t {\n\t\tenc.AddFloatOmitEmpty(e)\n\t}\n}\nfunc (t TestEncodingFloatOmitEmpty) IsNil() bool {\n\treturn t == nil\n}\n\ntype TestEncodingFloat32OmitEmpty []float32\n\nfunc (t TestEncodingFloat32OmitEmpty) MarshalJSONArray(enc *Encoder) {\n\tfor _, e := range t {\n\t\tenc.AddFloat32OmitEmpty(e)\n\t}\n}\nfunc (t TestEncodingFloat32OmitEmpty) IsNil() bool {\n\treturn t == nil\n}\n\ntype TestEncodingBoolOmitEmpty []bool\n\nfunc (t TestEncodingBoolOmitEmpty) MarshalJSONArray(enc *Encoder) {\n\tfor _, e := range t {\n\t\tenc.AddBoolOmitEmpty(e)\n\t}\n}\nfunc (t TestEncodingBoolOmitEmpty) IsNil() bool {\n\treturn len(t) == 0\n}\n\ntype TestEncodingArrOmitEmpty []TestEncodingBoolOmitEmpty\n\nfunc (t TestEncodingArrOmitEmpty) MarshalJSONArray(enc *Encoder) {\n\tfor _, e := range t {\n\t\tenc.AddArrayOmitEmpty(e)\n\t}\n}\nfunc (t TestEncodingArrOmitEmpty) IsNil() bool {\n\treturn len(t) == 0\n}\n\ntype TestObjEmpty struct {\n\tempty bool\n}\n\nfunc (t *TestObjEmpty) MarshalJSONObject(enc *Encoder) {\n}\n\nfunc (t *TestObjEmpty) IsNil() bool {\n\treturn !t.empty\n}\n\ntype TestEncodingObjOmitEmpty []*TestObjEmpty\n\nfunc (t TestEncodingObjOmitEmpty) MarshalJSONArray(enc *Encoder) {\n\tfor _, e := range t {\n\t\tenc.AddObjectOmitEmpty(e)\n\t}\n}\nfunc (t TestEncodingObjOmitEmpty) IsNil() bool {\n\treturn t == nil\n}\n\nfunc TestEncoderArrayOmitEmpty(t *testing.T) {\n\tt.Run(\"omit-int\", func(t *testing.T) {\n\t\tintArr := TestEncodingIntOmitEmpty{0, 1, 0, 1}\n\t\tb, err := Marshal(intArr)\n\t\tassert.Nil(t, err, \"err must be nil\")\n\t\tassert.Equal(t, `[1,1]`, string(b), \"string(b) must be equal to `[1,1]`\")\n\t})\n\tt.Run(\"omit-float\", func(t *testing.T) {\n\t\tfloatArr := TestEncodingFloatOmitEmpty{0, 1, 0, 1}\n\t\tb, err := Marshal(floatArr)\n\t\tassert.Nil(t, err, \"err must be nil\")\n\t\tassert.Equal(t, `[1,1]`, string(b), \"string(b) must be equal to `[1,1]`\")\n\t})\n\tt.Run(\"omit-float32\", func(t *testing.T) {\n\t\tfloat32Arr := TestEncodingFloat32OmitEmpty{0, 1, 0, 1}\n\t\tb, err := Marshal(float32Arr)\n\t\tassert.Nil(t, err, \"err must be nil\")\n\t\tassert.Equal(t, `[1,1]`, string(b), \"string(b) must be equal to `[1,1]`\")\n\t})\n\tt.Run(\"omit-string\", func(t *testing.T) {\n\t\tstringArr := TestEncodingStringOmitEmpty{\"\", \"hello\", \"\", \"world\"}\n\t\tb, err := Marshal(stringArr)\n\t\tassert.Nil(t, err, \"err must be nil\")\n\t\tassert.Equal(t, `[\"hello\",\"world\"]`, string(b), \"string(b) must be equal to `[\\\"hello\\\",\\\"world\\\"]`\")\n\t})\n\tt.Run(\"omit-bool\", func(t *testing.T) {\n\t\tboolArr := TestEncodingBoolOmitEmpty{false, true, false, true}\n\t\tb, err := Marshal(boolArr)\n\t\tassert.Nil(t, err, \"err must be nil\")\n\t\tassert.Equal(t, `[true,true]`, string(b), \"string(b) must be equal to `[true,true]`\")\n\t})\n\tt.Run(\"omit-arr\", func(t *testing.T) {\n\t\tarrArr := TestEncodingArrOmitEmpty{TestEncodingBoolOmitEmpty{true}, nil, TestEncodingBoolOmitEmpty{true}, nil}\n\t\tb, err := Marshal(arrArr)\n\t\tassert.Nil(t, err, \"err must be nil\")\n\t\tassert.Equal(t, `[[true],[true]]`, string(b), \"string(b) must be equal to `[[true],[true]]`\")\n\t})\n\tt.Run(\"omit-obj\", func(t *testing.T) {\n\t\tobjArr := TestEncodingObjOmitEmpty{&TestObjEmpty{true}, &TestObjEmpty{false}, &TestObjEmpty{true}, &TestObjEmpty{false}}\n\t\tb, err := Marshal(objArr)\n\t\tassert.Nil(t, err, \"err must be nil\")\n\t\tassert.Equal(t, `[{},{}]`, string(b), \"string(b) must be equal to `[{},{}]`\")\n\t})\n}\n\nfunc TestEncoderArrErrors(t *testing.T) {\n\tt.Run(\"add-interface-error\", func(t *testing.T) {\n\t\tbuilder := &strings.Builder{}\n\t\tenc := NewEncoder(builder)\n\t\tenc.AddInterface(nil)\n\t\tassert.Nil(t, enc.err, \"enc.Err() should not be nil\")\n\t\tassert.Equal(t, \"\", builder.String(), \"builder.String() should not be ''\")\n\t})\n\tt.Run(\"array-pooled-error\", func(t *testing.T) {\n\t\tv := &testEncodingArrInterfaces{}\n\t\tenc := BorrowEncoder(nil)\n\t\tenc.Release()\n\t\tdefer func() {\n\t\t\terr := recover()\n\t\t\tassert.NotNil(t, err, \"err shouldnt be nil\")\n\t\t\tassert.IsType(t, InvalidUsagePooledEncoderError(\"\"), err, \"err should be of type InvalidUsagePooledEncoderError\")\n\t\t\tassert.Equal(t, \"Invalid usage of pooled encoder\", err.(InvalidUsagePooledEncoderError).Error(), \"err should be of type InvalidUsagePooledDecoderError\")\n\t\t}()\n\t\t_ = enc.EncodeArray(v)\n\t\tassert.True(t, false, \"should not be called as it should have panicked\")\n\t})\n}\n\nfunc TestEncoderArrayFunc(t *testing.T) {\n\tvar f EncodeArrayFunc\n\tassert.True(t, f.IsNil())\n}\n\nfunc TestEncodeArrayNullEmpty(t *testing.T) {\n\tvar testCases = []struct {\n\t\tname, baseJSON, expectedJSON string\n\t}{\n\t\t{\n\t\t\tname:         \"basic 1st elem\",\n\t\t\tbaseJSON:     \"[\",\n\t\t\texpectedJSON: `[null,[\"foo\"]`,\n\t\t},\n\t\t{\n\t\t\tname:         \"basic 1st elem\",\n\t\t\tbaseJSON:     `[\"test\"`,\n\t\t\texpectedJSON: `[\"test\",null,[\"foo\"]`,\n\t\t},\n\t}\n\n\tfor _, testCase := range testCases {\n\t\tt.Run(testCase.name, func(t *testing.T) {\n\t\t\tvar b strings.Builder\n\t\t\tvar enc = NewEncoder(&b)\n\t\t\tenc.writeString(testCase.baseJSON)\n\t\t\tenc.AddArrayNullEmpty(&TestEncodingArrStrings{})\n\t\t\tenc.ArrayNullEmpty(&TestEncodingArrStrings{\"foo\"})\n\t\t})\n\t}\n}\n\nfunc TestEncodeArrayKeyNullEmpty(t *testing.T) {\n\tvar testCases = []struct {\n\t\tname, baseJSON, expectedJSON string\n\t}{\n\t\t{\n\t\t\tname:         \"basic 1st elem\",\n\t\t\tbaseJSON:     \"{\",\n\t\t\texpectedJSON: `{\"foo\":null,\"bar\":[\"foo\"]`,\n\t\t},\n\t\t{\n\t\t\tname:         \"basic 1st elem\",\n\t\t\tbaseJSON:     `{\"test\":\"test\"`,\n\t\t\texpectedJSON: `{\"test\":\"test\",\"foo\":null,\"bar\":[\"foo\"]`,\n\t\t},\n\t}\n\n\tfor _, testCase := range testCases {\n\t\tt.Run(testCase.name, func(t *testing.T) {\n\t\t\tvar b strings.Builder\n\t\t\tvar enc = NewEncoder(&b)\n\t\t\tenc.writeString(testCase.baseJSON)\n\t\t\tenc.AddArrayKeyNullEmpty(\"foo\", &TestEncodingArrStrings{})\n\t\t\tenc.ArrayKeyNullEmpty(\"bar\", &TestEncodingArrStrings{\"foo\"})\n\t\t})\n\t}\n}\n"
        },
        {
          "name": "encode_bool.go",
          "type": "blob",
          "size": 3.98828125,
          "content": "package gojay\n\nimport \"strconv\"\n\n// EncodeBool encodes a bool to JSON\nfunc (enc *Encoder) EncodeBool(v bool) error {\n\tif enc.isPooled == 1 {\n\t\tpanic(InvalidUsagePooledEncoderError(\"Invalid usage of pooled encoder\"))\n\t}\n\t_, _ = enc.encodeBool(v)\n\t_, err := enc.Write()\n\tif err != nil {\n\t\tenc.err = err\n\t\treturn err\n\t}\n\treturn nil\n}\n\n// encodeBool encodes a bool to JSON\nfunc (enc *Encoder) encodeBool(v bool) ([]byte, error) {\n\tenc.grow(5)\n\tif v {\n\t\tenc.writeString(\"true\")\n\t} else {\n\t\tenc.writeString(\"false\")\n\t}\n\treturn enc.buf, enc.err\n}\n\n// AddBool adds a bool to be encoded, must be used inside a slice or array encoding (does not encode a key)\nfunc (enc *Encoder) AddBool(v bool) {\n\tenc.Bool(v)\n}\n\n// AddBoolOmitEmpty adds a bool to be encoded, must be used inside a slice or array encoding (does not encode a key)\nfunc (enc *Encoder) AddBoolOmitEmpty(v bool) {\n\tenc.BoolOmitEmpty(v)\n}\n\n// AddBoolNullEmpty adds a bool to be encoded, must be used inside a slice or array encoding (does not encode a key)\nfunc (enc *Encoder) AddBoolNullEmpty(v bool) {\n\tenc.BoolNullEmpty(v)\n}\n\n// AddBoolKey adds a bool to be encoded, must be used inside an object as it will encode a key.\nfunc (enc *Encoder) AddBoolKey(key string, v bool) {\n\tenc.BoolKey(key, v)\n}\n\n// AddBoolKeyOmitEmpty adds a bool to be encoded and skips if it is zero value.\n// Must be used inside an object as it will encode a key.\nfunc (enc *Encoder) AddBoolKeyOmitEmpty(key string, v bool) {\n\tenc.BoolKeyOmitEmpty(key, v)\n}\n\n// AddBoolKeyNullEmpty adds a bool to be encoded and encodes `null` if it is zero value.\n// Must be used inside an object as it will encode a key.\nfunc (enc *Encoder) AddBoolKeyNullEmpty(key string, v bool) {\n\tenc.BoolKeyNullEmpty(key, v)\n}\n\n// Bool adds a bool to be encoded, must be used inside a slice or array encoding (does not encode a key)\nfunc (enc *Encoder) Bool(v bool) {\n\tenc.grow(5)\n\tr := enc.getPreviousRune()\n\tif r != '[' {\n\t\tenc.writeByte(',')\n\t}\n\tif v {\n\t\tenc.writeString(\"true\")\n\t} else {\n\t\tenc.writeString(\"false\")\n\t}\n}\n\n// BoolOmitEmpty adds a bool to be encoded, must be used inside a slice or array encoding (does not encode a key)\nfunc (enc *Encoder) BoolOmitEmpty(v bool) {\n\tif v == false {\n\t\treturn\n\t}\n\tenc.grow(5)\n\tr := enc.getPreviousRune()\n\tif r != '[' {\n\t\tenc.writeByte(',')\n\t}\n\tenc.writeString(\"true\")\n}\n\n// BoolNullEmpty adds a bool to be encoded, must be used inside a slice or array encoding (does not encode a key)\nfunc (enc *Encoder) BoolNullEmpty(v bool) {\n\tenc.grow(5)\n\tr := enc.getPreviousRune()\n\tif r != '[' {\n\t\tenc.writeByte(',')\n\t}\n\tif v == false {\n\t\tenc.writeBytes(nullBytes)\n\t\treturn\n\t}\n\tenc.writeString(\"true\")\n}\n\n// BoolKey adds a bool to be encoded, must be used inside an object as it will encode a key.\nfunc (enc *Encoder) BoolKey(key string, value bool) {\n\tif enc.hasKeys {\n\t\tif !enc.keyExists(key) {\n\t\t\treturn\n\t\t}\n\t}\n\tenc.grow(5 + len(key))\n\tr := enc.getPreviousRune()\n\tif r != '{' {\n\t\tenc.writeByte(',')\n\t}\n\tenc.writeByte('\"')\n\tenc.writeStringEscape(key)\n\tenc.writeBytes(objKey)\n\tenc.buf = strconv.AppendBool(enc.buf, value)\n}\n\n// BoolKeyOmitEmpty adds a bool to be encoded and skips it if it is zero value.\n// Must be used inside an object as it will encode a key.\nfunc (enc *Encoder) BoolKeyOmitEmpty(key string, v bool) {\n\tif enc.hasKeys {\n\t\tif !enc.keyExists(key) {\n\t\t\treturn\n\t\t}\n\t}\n\tif v == false {\n\t\treturn\n\t}\n\tenc.grow(5 + len(key))\n\tr := enc.getPreviousRune()\n\tif r != '{' {\n\t\tenc.writeByte(',')\n\t}\n\tenc.writeByte('\"')\n\tenc.writeStringEscape(key)\n\tenc.writeBytes(objKey)\n\tenc.buf = strconv.AppendBool(enc.buf, v)\n}\n\n// BoolKeyNullEmpty adds a bool to be encoded and skips it if it is zero value.\n// Must be used inside an object as it will encode a key.\nfunc (enc *Encoder) BoolKeyNullEmpty(key string, v bool) {\n\tif enc.hasKeys {\n\t\tif !enc.keyExists(key) {\n\t\t\treturn\n\t\t}\n\t}\n\tenc.grow(5 + len(key))\n\tr := enc.getPreviousRune()\n\tif r != '{' {\n\t\tenc.writeByte(',')\n\t}\n\tenc.writeByte('\"')\n\tenc.writeStringEscape(key)\n\tenc.writeBytes(objKey)\n\tif v == false {\n\t\tenc.writeBytes(nullBytes)\n\t\treturn\n\t}\n\tenc.buf = strconv.AppendBool(enc.buf, v)\n}\n"
        },
        {
          "name": "encode_bool_test.go",
          "type": "blob",
          "size": 3.26953125,
          "content": "package gojay\n\nimport (\n\t\"strings\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestEncoderBoolMarshalAPI(t *testing.T) {\n\tt.Run(\"true\", func(t *testing.T) {\n\t\tb, err := Marshal(true)\n\t\tassert.Nil(t, err, \"err must be nil\")\n\t\tassert.Equal(t, \"true\", string(b), \"string(b) must be equal to 'true'\")\n\t})\n\tt.Run(\"false\", func(t *testing.T) {\n\t\tb, err := Marshal(false)\n\t\tassert.Nil(t, err, \"err must be nil\")\n\t\tassert.Equal(t, \"false\", string(b), \"string(b) must be equal to 'false'\")\n\t})\n}\n\nfunc TestEncoderBoolEncodeAPI(t *testing.T) {\n\tt.Run(\"true\", func(t *testing.T) {\n\t\tbuilder := &strings.Builder{}\n\t\tenc := BorrowEncoder(builder)\n\t\tdefer enc.Release()\n\t\terr := enc.EncodeBool(true)\n\t\tassert.Nil(t, err, \"err must be nil\")\n\t\tassert.Equal(t, \"true\", builder.String(), \"string(b) must be equal to 'true'\")\n\t})\n\tt.Run(\"false\", func(t *testing.T) {\n\t\tbuilder := &strings.Builder{}\n\t\tenc := BorrowEncoder(builder)\n\t\tdefer enc.Release()\n\t\terr := enc.EncodeBool(false)\n\t\tassert.Nil(t, err, \"err must be nil\")\n\t\tassert.Equal(t, \"false\", builder.String(), \"string(b) must be equal to 'false'\")\n\t})\n}\n\nfunc TestEncoderBoolErrors(t *testing.T) {\n\tt.Run(\"pool-error\", func(t *testing.T) {\n\t\tbuilder := &strings.Builder{}\n\t\tenc := BorrowEncoder(builder)\n\t\tenc.isPooled = 1\n\t\tdefer func() {\n\t\t\terr := recover()\n\t\t\tassert.NotNil(t, err, \"err shouldnt be nil\")\n\t\t\tassert.IsType(t, InvalidUsagePooledEncoderError(\"\"), err, \"err should be of type InvalidUsagePooledEncoderError\")\n\t\t\tassert.Equal(t, \"Invalid usage of pooled encoder\", err.(InvalidUsagePooledEncoderError).Error(), \"err should be of type InvalidUsagePooledEncoderError\")\n\t\t}()\n\t\t_ = enc.EncodeBool(false)\n\t\tassert.True(t, false, \"should not be called as it should have panicked\")\n\t})\n\tt.Run(\"encode-api-write-error\", func(t *testing.T) {\n\t\tv := true\n\t\tw := TestWriterError(\"\")\n\t\tenc := BorrowEncoder(w)\n\t\tdefer enc.Release()\n\t\terr := enc.EncodeBool(v)\n\t\tassert.NotNil(t, err, \"err should not be nil\")\n\t})\n}\n\nfunc TestEncoderBoolNullEmpty(t *testing.T) {\n\tvar testCases = []struct {\n\t\tname         string\n\t\tbaseJSON     string\n\t\texpectedJSON string\n\t}{\n\t\t{\n\t\t\tname:         \"basic 1st elem\",\n\t\t\tbaseJSON:     \"[\",\n\t\t\texpectedJSON: \"[null,true\",\n\t\t},\n\t\t{\n\t\t\tname:         \"basic 2nd elem\",\n\t\t\tbaseJSON:     `[\"test\"`,\n\t\t\texpectedJSON: `[\"test\",null,true`,\n\t\t},\n\t}\n\tfor _, testCase := range testCases {\n\t\tt.Run(\"true\", func(t *testing.T) {\n\t\t\tvar b strings.Builder\n\t\t\tvar enc = NewEncoder(&b)\n\t\t\tenc.writeString(testCase.baseJSON)\n\t\t\tenc.BoolNullEmpty(false)\n\t\t\tenc.AddBoolNullEmpty(true)\n\t\t\tenc.Write()\n\t\t\tassert.Equal(t, testCase.expectedJSON, b.String())\n\t\t})\n\t}\n}\n\nfunc TestEncoderBoolNullKeyEmpty(t *testing.T) {\n\tvar testCases = []struct {\n\t\tname         string\n\t\tbaseJSON     string\n\t\texpectedJSON string\n\t}{\n\t\t{\n\t\t\tname:         \"basic 1st elem\",\n\t\t\tbaseJSON:     \"{\",\n\t\t\texpectedJSON: `{\"foo\":null,\"bar\":true`,\n\t\t},\n\t\t{\n\t\t\tname:         \"basic 2nd elem\",\n\t\t\tbaseJSON:     `{\"test\":\"test\"`,\n\t\t\texpectedJSON: `{\"test\":\"test\",\"foo\":null,\"bar\":true`,\n\t\t},\n\t}\n\tfor _, testCase := range testCases {\n\t\tt.Run(\"true\", func(t *testing.T) {\n\t\t\tvar b strings.Builder\n\t\t\tvar enc = NewEncoder(&b)\n\t\t\tenc.writeString(testCase.baseJSON)\n\t\t\tenc.BoolKeyNullEmpty(\"foo\", false)\n\t\t\tenc.AddBoolKeyNullEmpty(\"bar\", true)\n\t\t\tenc.Write()\n\t\t\tassert.Equal(t, testCase.expectedJSON, b.String())\n\t\t})\n\t}\n}\n"
        },
        {
          "name": "encode_builder.go",
          "type": "blob",
          "size": 1.541015625,
          "content": "package gojay\n\nconst hex = \"0123456789abcdef\"\n\n// grow grows b's capacity, if necessary, to guarantee space for\n// another n bytes. After grow(n), at least n bytes can be written to b\n// without another allocation. If n is negative, grow panics.\nfunc (enc *Encoder) grow(n int) {\n\tif cap(enc.buf)-len(enc.buf) < n {\n\t\tBuf := make([]byte, len(enc.buf), 2*cap(enc.buf)+n)\n\t\tcopy(Buf, enc.buf)\n\t\tenc.buf = Buf\n\t}\n}\n\n// Write appends the contents of p to b's Buffer.\n// Write always returns len(p), nil.\nfunc (enc *Encoder) writeBytes(p []byte) {\n\tenc.buf = append(enc.buf, p...)\n}\n\nfunc (enc *Encoder) writeTwoBytes(b1 byte, b2 byte) {\n\tenc.buf = append(enc.buf, b1, b2)\n}\n\n// WriteByte appends the byte c to b's Buffer.\n// The returned error is always nil.\nfunc (enc *Encoder) writeByte(c byte) {\n\tenc.buf = append(enc.buf, c)\n}\n\n// WriteString appends the contents of s to b's Buffer.\n// It returns the length of s and a nil error.\nfunc (enc *Encoder) writeString(s string) {\n\tenc.buf = append(enc.buf, s...)\n}\n\nfunc (enc *Encoder) writeStringEscape(s string) {\n\tl := len(s)\n\tfor i := 0; i < l; i++ {\n\t\tc := s[i]\n\t\tif c >= 0x20 && c != '\\\\' && c != '\"' {\n\t\t\tenc.writeByte(c)\n\t\t\tcontinue\n\t\t}\n\t\tswitch c {\n\t\tcase '\\\\', '\"':\n\t\t\tenc.writeTwoBytes('\\\\', c)\n\t\tcase '\\n':\n\t\t\tenc.writeTwoBytes('\\\\', 'n')\n\t\tcase '\\f':\n\t\t\tenc.writeTwoBytes('\\\\', 'f')\n\t\tcase '\\b':\n\t\t\tenc.writeTwoBytes('\\\\', 'b')\n\t\tcase '\\r':\n\t\t\tenc.writeTwoBytes('\\\\', 'r')\n\t\tcase '\\t':\n\t\t\tenc.writeTwoBytes('\\\\', 't')\n\t\tdefault:\n\t\t\tenc.writeString(`\\u00`)\n\t\t\tenc.writeTwoBytes(hex[c>>4], hex[c&0xF])\n\t\t}\n\t\tcontinue\n\t}\n}\n"
        },
        {
          "name": "encode_builder_test.go",
          "type": "blob",
          "size": 0.013671875,
          "content": "package gojay\n"
        },
        {
          "name": "encode_embedded_json.go",
          "type": "blob",
          "size": 2.37109375,
          "content": "package gojay\n\n// EncodeEmbeddedJSON encodes an embedded JSON.\n// is basically sets the internal buf as the value pointed by v and calls the io.Writer.Write()\nfunc (enc *Encoder) EncodeEmbeddedJSON(v *EmbeddedJSON) error {\n\tif enc.isPooled == 1 {\n\t\tpanic(InvalidUsagePooledEncoderError(\"Invalid usage of pooled encoder\"))\n\t}\n\tenc.buf = *v\n\t_, err := enc.Write()\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}\n\nfunc (enc *Encoder) encodeEmbeddedJSON(v *EmbeddedJSON) ([]byte, error) {\n\tenc.writeBytes(*v)\n\treturn enc.buf, nil\n}\n\n// AddEmbeddedJSON adds an EmbeddedJSON to be encoded.\n//\n// It basically blindly writes the bytes to the final buffer. Therefore,\n// it expects the JSON to be of proper format.\nfunc (enc *Encoder) AddEmbeddedJSON(v *EmbeddedJSON) {\n\tenc.grow(len(*v) + 4)\n\tr := enc.getPreviousRune()\n\tif r != '[' {\n\t\tenc.writeByte(',')\n\t}\n\tenc.writeBytes(*v)\n}\n\n// AddEmbeddedJSONOmitEmpty adds an EmbeddedJSON to be encoded or skips it if nil pointer or empty.\n//\n// It basically blindly writes the bytes to the final buffer. Therefore,\n// it expects the JSON to be of proper format.\nfunc (enc *Encoder) AddEmbeddedJSONOmitEmpty(v *EmbeddedJSON) {\n\tif v == nil || len(*v) == 0 {\n\t\treturn\n\t}\n\tr := enc.getPreviousRune()\n\tif r != '[' {\n\t\tenc.writeByte(',')\n\t}\n\tenc.writeBytes(*v)\n}\n\n// AddEmbeddedJSONKey adds an EmbeddedJSON and a key to be encoded.\n//\n// It basically blindly writes the bytes to the final buffer. Therefore,\n// it expects the JSON to be of proper format.\nfunc (enc *Encoder) AddEmbeddedJSONKey(key string, v *EmbeddedJSON) {\n\tif enc.hasKeys {\n\t\tif !enc.keyExists(key) {\n\t\t\treturn\n\t\t}\n\t}\n\tenc.grow(len(key) + len(*v) + 5)\n\tr := enc.getPreviousRune()\n\tif r != '{' {\n\t\tenc.writeByte(',')\n\t}\n\tenc.writeByte('\"')\n\tenc.writeStringEscape(key)\n\tenc.writeBytes(objKey)\n\tenc.writeBytes(*v)\n}\n\n// AddEmbeddedJSONKeyOmitEmpty adds an EmbeddedJSON and a key to be encoded or skips it if nil pointer or empty.\n//\n// It basically blindly writes the bytes to the final buffer. Therefore,\n// it expects the JSON to be of proper format.\nfunc (enc *Encoder) AddEmbeddedJSONKeyOmitEmpty(key string, v *EmbeddedJSON) {\n\tif enc.hasKeys {\n\t\tif !enc.keyExists(key) {\n\t\t\treturn\n\t\t}\n\t}\n\tif v == nil || len(*v) == 0 {\n\t\treturn\n\t}\n\tenc.grow(len(key) + len(*v) + 5)\n\tr := enc.getPreviousRune()\n\tif r != '{' {\n\t\tenc.writeByte(',')\n\t}\n\tenc.writeByte('\"')\n\tenc.writeStringEscape(key)\n\tenc.writeBytes(objKey)\n\tenc.writeBytes(*v)\n}\n"
        },
        {
          "name": "encode_embedded_json_test.go",
          "type": "blob",
          "size": 3.748046875,
          "content": "package gojay\n\nimport (\n\t\"strings\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc (r *Request) MarshalJSONObject(enc *Encoder) {\n\tenc.AddStringKey(\"id\", r.id)\n\tenc.AddStringKey(\"method\", r.method)\n\tenc.AddEmbeddedJSONKey(\"params\", &r.params)\n\tparams2 := EmbeddedJSON([]byte(``))\n\tenc.AddEmbeddedJSONKeyOmitEmpty(\"params2\", &params2)\n\tparams3 := EmbeddedJSON([]byte(`\"test\"`))\n\tenc.AddEmbeddedJSONKeyOmitEmpty(\"params3\", &params3)\n\tenc.AddIntKey(\"more\", r.more)\n}\n\nfunc (r *Request) IsNil() bool {\n\treturn r == nil\n}\n\ntype EmbeddedJSONArr []EmbeddedJSON\n\nfunc (ear EmbeddedJSONArr) MarshalJSONArray(enc *Encoder) {\n\tfor _, e := range ear {\n\t\tenc.AddEmbeddedJSON(&e)\n\t}\n}\n\nfunc (ear EmbeddedJSONArr) IsNil() bool {\n\treturn len(ear) == 0\n}\n\ntype EmbeddedJSONOmitEmptyArr []EmbeddedJSON\n\nfunc (ear EmbeddedJSONOmitEmptyArr) MarshalJSONArray(enc *Encoder) {\n\tfor _, e := range ear {\n\t\tenc.AddEmbeddedJSONOmitEmpty(&e)\n\t}\n}\n\nfunc (ear EmbeddedJSONOmitEmptyArr) IsNil() bool {\n\treturn len(ear) == 0\n}\n\nfunc TestEncodingEmbeddedJSON(t *testing.T) {\n\tt.Run(\"basic-embedded-json\", func(t *testing.T) {\n\t\tej := EmbeddedJSON([]byte(`\"test\"`))\n\t\tb := &strings.Builder{}\n\t\tenc := BorrowEncoder(b)\n\t\terr := enc.Encode(&ej)\n\t\tassert.Nil(t, err, \"err should be nil\")\n\t\tassert.Equal(t, b.String(), `\"test\"`, \"b should be equal to content of EmbeddedJSON\")\n\t})\n\tt.Run(\"basic-embedded-json-marshal-api\", func(t *testing.T) {\n\t\tej := EmbeddedJSON([]byte(`\"test\"`))\n\t\tb, err := Marshal(&ej)\n\t\tassert.Nil(t, err, \"err should be nil\")\n\t\tassert.Equal(t, string(b), `\"test\"`, \"b should be equal to content of EmbeddedJSON\")\n\t})\n\tt.Run(\"object-embedded-json\", func(t *testing.T) {\n\t\treq := Request{\n\t\t\tid:     \"test\",\n\t\t\tmethod: \"GET\",\n\t\t\tparams: EmbeddedJSON([]byte(`\"test\"`)),\n\t\t}\n\t\tb := &strings.Builder{}\n\t\tenc := BorrowEncoder(b)\n\t\terr := enc.EncodeObject(&req)\n\t\tassert.Nil(t, err, \"err should be nil\")\n\t\tassert.Equal(\n\t\t\tt,\n\t\t\tb.String(),\n\t\t\t`{\"id\":\"test\",\"method\":\"GET\",\"params\":\"test\",\"params3\":\"test\",\"more\":0}`,\n\t\t\t\"b should be equal to content of EmbeddedJSON\",\n\t\t)\n\t})\n\tt.Run(\"array-embedded-json\", func(t *testing.T) {\n\t\tear := EmbeddedJSONArr{\n\t\t\t[]byte(`\"test\"`),\n\t\t\t[]byte(`{\"test\":\"test\"}`),\n\t\t}\n\t\tb := &strings.Builder{}\n\t\tenc := BorrowEncoder(b)\n\t\terr := enc.EncodeArray(ear)\n\t\tassert.Nil(t, err, \"err should be nil\")\n\t\tassert.Equal(\n\t\t\tt,\n\t\t\tb.String(),\n\t\t\t`[\"test\",{\"test\":\"test\"}]`,\n\t\t\t\"b should be equal to content of EmbeddedJSON\",\n\t\t)\n\t})\n\tt.Run(\"array-embedded-json-omit-empty\", func(t *testing.T) {\n\t\tear := EmbeddedJSONOmitEmptyArr{\n\t\t\t[]byte(`\"test\"`),\n\t\t\t[]byte(``),\n\t\t\t[]byte(`{\"test\":\"test\"}`),\n\t\t\t[]byte(``),\n\t\t\t[]byte(`{\"test\":\"test\"}`),\n\t\t}\n\t\tb := &strings.Builder{}\n\t\tenc := BorrowEncoder(b)\n\t\terr := enc.EncodeArray(ear)\n\t\tassert.Nil(t, err, \"err should be nil\")\n\t\tassert.Equal(\n\t\t\tt,\n\t\t\tb.String(),\n\t\t\t`[\"test\",{\"test\":\"test\"},{\"test\":\"test\"}]`,\n\t\t\t\"b should be equal to content of EmbeddedJSON\",\n\t\t)\n\t})\n\tt.Run(\"write-error\", func(t *testing.T) {\n\t\tw := TestWriterError(\"\")\n\t\tv := EmbeddedJSON([]byte(`\"test\"`))\n\t\tenc := NewEncoder(w)\n\t\terr := enc.EncodeEmbeddedJSON(&v)\n\t\tassert.NotNil(t, err, \"Error should not be nil\")\n\t\tassert.Equal(t, \"Test Error\", err.Error(), \"err.Error() should be 'Test Error'\")\n\t})\n\tt.Run(\"pool-error\", func(t *testing.T) {\n\t\tv := EmbeddedJSON([]byte(`\"test\"`))\n\t\tenc := BorrowEncoder(nil)\n\t\tenc.isPooled = 1\n\t\tdefer func() {\n\t\t\terr := recover()\n\t\t\tassert.NotNil(t, err, \"err shouldnt be nil\")\n\t\t\tassert.IsType(t, InvalidUsagePooledEncoderError(\"\"), err, \"err should be of type InvalidUsagePooledEncoderError\")\n\t\t\tassert.Equal(t, \"Invalid usage of pooled encoder\", err.(InvalidUsagePooledEncoderError).Error(), \"err should be of type InvalidUsagePooledDecoderError\")\n\t\t}()\n\t\t_ = enc.EncodeEmbeddedJSON(&v)\n\t\tassert.True(t, false, \"should not be called as it should have panicked\")\n\t})\n}\n"
        },
        {
          "name": "encode_example_test.go",
          "type": "blob",
          "size": 0.9482421875,
          "content": "package gojay_test\n\nimport (\n\t\"fmt\"\n\t\"log\"\n\t\"os\"\n\n\t\"github.com/francoispqt/gojay\"\n)\n\nfunc ExampleMarshal_string() {\n\tstr := \"gojay\"\n\td, err := gojay.Marshal(str)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tfmt.Println(string(d)) // \"gojay\"\n}\n\nfunc ExampleMarshal_bool() {\n\tb := true\n\td, err := gojay.Marshal(b)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tfmt.Println(string(d)) // true\n}\n\nfunc ExampleNewEncoder() {\n\tenc := gojay.BorrowEncoder(os.Stdout)\n\n\tvar str = \"gojay\"\n\terr := enc.EncodeString(str)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\t// Output:\n\t// \"gojay\"\n}\n\nfunc ExampleBorrowEncoder() {\n\tenc := gojay.BorrowEncoder(os.Stdout)\n\tdefer enc.Release()\n\n\tvar str = \"gojay\"\n\terr := enc.EncodeString(str)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\t// Output:\n\t// \"gojay\"\n}\n\nfunc ExampleEncoder_EncodeString() {\n\tenc := gojay.BorrowEncoder(os.Stdout)\n\tdefer enc.Release()\n\n\tvar str = \"gojay\"\n\terr := enc.EncodeString(str)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\t// Output:\n\t// \"gojay\"\n}\n"
        },
        {
          "name": "encode_interface.go",
          "type": "blob",
          "size": 3.9931640625,
          "content": "package gojay\n\nimport (\n\t\"fmt\"\n)\n\n// Encode encodes a value to JSON.\n//\n// If Encode cannot find a way to encode the type to JSON\n// it will return an InvalidMarshalError.\nfunc (enc *Encoder) Encode(v interface{}) error {\n\tif enc.isPooled == 1 {\n\t\tpanic(InvalidUsagePooledEncoderError(\"Invalid usage of pooled encoder\"))\n\t}\n\tswitch vt := v.(type) {\n\tcase string:\n\t\treturn enc.EncodeString(vt)\n\tcase bool:\n\t\treturn enc.EncodeBool(vt)\n\tcase MarshalerJSONArray:\n\t\treturn enc.EncodeArray(vt)\n\tcase MarshalerJSONObject:\n\t\treturn enc.EncodeObject(vt)\n\tcase int:\n\t\treturn enc.EncodeInt(vt)\n\tcase int64:\n\t\treturn enc.EncodeInt64(vt)\n\tcase int32:\n\t\treturn enc.EncodeInt(int(vt))\n\tcase int8:\n\t\treturn enc.EncodeInt(int(vt))\n\tcase uint64:\n\t\treturn enc.EncodeUint64(vt)\n\tcase uint32:\n\t\treturn enc.EncodeInt(int(vt))\n\tcase uint16:\n\t\treturn enc.EncodeInt(int(vt))\n\tcase uint8:\n\t\treturn enc.EncodeInt(int(vt))\n\tcase float64:\n\t\treturn enc.EncodeFloat(vt)\n\tcase float32:\n\t\treturn enc.EncodeFloat32(vt)\n\tcase *EmbeddedJSON:\n\t\treturn enc.EncodeEmbeddedJSON(vt)\n\tdefault:\n\t\treturn InvalidMarshalError(fmt.Sprintf(invalidMarshalErrorMsg, vt))\n\t}\n}\n\n// AddInterface adds an interface{} to be encoded, must be used inside a slice or array encoding (does not encode a key)\nfunc (enc *Encoder) AddInterface(value interface{}) {\n\tswitch vt := value.(type) {\n\tcase string:\n\t\tenc.AddString(vt)\n\tcase bool:\n\t\tenc.AddBool(vt)\n\tcase MarshalerJSONArray:\n\t\tenc.AddArray(vt)\n\tcase MarshalerJSONObject:\n\t\tenc.AddObject(vt)\n\tcase int:\n\t\tenc.AddInt(vt)\n\tcase int64:\n\t\tenc.AddInt(int(vt))\n\tcase int32:\n\t\tenc.AddInt(int(vt))\n\tcase int8:\n\t\tenc.AddInt(int(vt))\n\tcase uint64:\n\t\tenc.AddUint64(vt)\n\tcase uint32:\n\t\tenc.AddInt(int(vt))\n\tcase uint16:\n\t\tenc.AddInt(int(vt))\n\tcase uint8:\n\t\tenc.AddInt(int(vt))\n\tcase float64:\n\t\tenc.AddFloat(vt)\n\tcase float32:\n\t\tenc.AddFloat32(vt)\n\tdefault:\n\t\tif vt != nil {\n\t\t\tenc.err = InvalidMarshalError(fmt.Sprintf(invalidMarshalErrorMsg, vt))\n\t\t\treturn\n\t\t}\n\t\treturn\n\t}\n}\n\n// AddInterfaceKey adds an interface{} to be encoded, must be used inside an object as it will encode a key\nfunc (enc *Encoder) AddInterfaceKey(key string, value interface{}) {\n\tswitch vt := value.(type) {\n\tcase string:\n\t\tenc.AddStringKey(key, vt)\n\tcase bool:\n\t\tenc.AddBoolKey(key, vt)\n\tcase MarshalerJSONArray:\n\t\tenc.AddArrayKey(key, vt)\n\tcase MarshalerJSONObject:\n\t\tenc.AddObjectKey(key, vt)\n\tcase int:\n\t\tenc.AddIntKey(key, vt)\n\tcase int64:\n\t\tenc.AddIntKey(key, int(vt))\n\tcase int32:\n\t\tenc.AddIntKey(key, int(vt))\n\tcase int16:\n\t\tenc.AddIntKey(key, int(vt))\n\tcase int8:\n\t\tenc.AddIntKey(key, int(vt))\n\tcase uint64:\n\t\tenc.AddIntKey(key, int(vt))\n\tcase uint32:\n\t\tenc.AddIntKey(key, int(vt))\n\tcase uint16:\n\t\tenc.AddIntKey(key, int(vt))\n\tcase uint8:\n\t\tenc.AddIntKey(key, int(vt))\n\tcase float64:\n\t\tenc.AddFloatKey(key, vt)\n\tcase float32:\n\t\tenc.AddFloat32Key(key, vt)\n\tdefault:\n\t\tif vt != nil {\n\t\t\tenc.err = InvalidMarshalError(fmt.Sprintf(invalidMarshalErrorMsg, vt))\n\t\t\treturn\n\t\t}\n\t\treturn\n\t}\n}\n\n// AddInterfaceKeyOmitEmpty adds an interface{} to be encoded, must be used inside an object as it will encode a key\nfunc (enc *Encoder) AddInterfaceKeyOmitEmpty(key string, v interface{}) {\n\tswitch vt := v.(type) {\n\tcase string:\n\t\tenc.AddStringKeyOmitEmpty(key, vt)\n\tcase bool:\n\t\tenc.AddBoolKeyOmitEmpty(key, vt)\n\tcase MarshalerJSONArray:\n\t\tenc.AddArrayKeyOmitEmpty(key, vt)\n\tcase MarshalerJSONObject:\n\t\tenc.AddObjectKeyOmitEmpty(key, vt)\n\tcase int:\n\t\tenc.AddIntKeyOmitEmpty(key, vt)\n\tcase int64:\n\t\tenc.AddIntKeyOmitEmpty(key, int(vt))\n\tcase int32:\n\t\tenc.AddIntKeyOmitEmpty(key, int(vt))\n\tcase int16:\n\t\tenc.AddIntKeyOmitEmpty(key, int(vt))\n\tcase int8:\n\t\tenc.AddIntKeyOmitEmpty(key, int(vt))\n\tcase uint64:\n\t\tenc.AddIntKeyOmitEmpty(key, int(vt))\n\tcase uint32:\n\t\tenc.AddIntKeyOmitEmpty(key, int(vt))\n\tcase uint16:\n\t\tenc.AddIntKeyOmitEmpty(key, int(vt))\n\tcase uint8:\n\t\tenc.AddIntKeyOmitEmpty(key, int(vt))\n\tcase float64:\n\t\tenc.AddFloatKeyOmitEmpty(key, vt)\n\tcase float32:\n\t\tenc.AddFloat32KeyOmitEmpty(key, vt)\n\tdefault:\n\t\tif vt != nil {\n\t\t\tenc.err = InvalidMarshalError(fmt.Sprintf(invalidMarshalErrorMsg, vt))\n\t\t\treturn\n\t\t}\n\t\treturn\n\t}\n}\n"
        },
        {
          "name": "encode_interface_test.go",
          "type": "blob",
          "size": 5.123046875,
          "content": "package gojay\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nvar encoderTestCases = []struct {\n\tv            interface{}\n\texpectations func(t *testing.T, b string, err error)\n}{\n\t{\n\t\tv: 100,\n\t\texpectations: func(t *testing.T, b string, err error) {\n\t\t\tassert.Nil(t, err, \"err should be nil\")\n\t\t\tassert.Equal(t, \"100\", b, \"b should equal 100\")\n\t\t},\n\t},\n\t{\n\t\tv: int64(100),\n\t\texpectations: func(t *testing.T, b string, err error) {\n\t\t\tassert.Nil(t, err, \"err should be nil\")\n\t\t\tassert.Equal(t, \"100\", b, \"b should equal 100\")\n\t\t},\n\t},\n\t{\n\t\tv: int32(100),\n\t\texpectations: func(t *testing.T, b string, err error) {\n\t\t\tassert.Nil(t, err, \"err should be nil\")\n\t\t\tassert.Equal(t, \"100\", b, \"b should equal 100\")\n\t\t},\n\t},\n\t{\n\t\tv: int8(100),\n\t\texpectations: func(t *testing.T, b string, err error) {\n\t\t\tassert.Nil(t, err, \"err should be nil\")\n\t\t\tassert.Equal(t, \"100\", b, \"b should equal 100\")\n\t\t},\n\t},\n\t{\n\t\tv: uint64(100),\n\t\texpectations: func(t *testing.T, b string, err error) {\n\t\t\tassert.Nil(t, err, \"err should be nil\")\n\t\t\tassert.Equal(t, \"100\", b, \"b should equal 100\")\n\t\t},\n\t},\n\t{\n\t\tv: uint32(100),\n\t\texpectations: func(t *testing.T, b string, err error) {\n\t\t\tassert.Nil(t, err, \"err should be nil\")\n\t\t\tassert.Equal(t, \"100\", b, \"b should equal 100\")\n\t\t},\n\t},\n\t{\n\t\tv: uint16(100),\n\t\texpectations: func(t *testing.T, b string, err error) {\n\t\t\tassert.Nil(t, err, \"err should be nil\")\n\t\t\tassert.Equal(t, \"100\", b, \"b should equal 100\")\n\t\t},\n\t},\n\t{\n\t\tv: uint8(100),\n\t\texpectations: func(t *testing.T, b string, err error) {\n\t\t\tassert.Nil(t, err, \"err should be nil\")\n\t\t\tassert.Equal(t, \"100\", b, \"b should equal 100\")\n\t\t},\n\t},\n\t{\n\t\tv: float64(100.12),\n\t\texpectations: func(t *testing.T, b string, err error) {\n\t\t\tassert.Nil(t, err, \"err should be nil\")\n\t\t\tassert.Equal(t, \"100.12\", b, \"b should equal 100.12\")\n\t\t},\n\t},\n\t{\n\t\tv: float32(100.12),\n\t\texpectations: func(t *testing.T, b string, err error) {\n\t\t\tassert.Nil(t, err, \"err should be nil\")\n\t\t\tassert.Equal(t, \"100.12\", b, \"b should equal 100.12\")\n\t\t},\n\t},\n\t{\n\t\tv: true,\n\t\texpectations: func(t *testing.T, b string, err error) {\n\t\t\tassert.Nil(t, err, \"err should be nil\")\n\t\t\tassert.Equal(t, \"true\", b, \"b should equal true\")\n\t\t},\n\t},\n\t{\n\t\tv: \"hello world\",\n\t\texpectations: func(t *testing.T, b string, err error) {\n\t\t\tassert.Nil(t, err, \"err should be nil\")\n\t\t\tassert.Equal(t, `\"hello world\"`, b, `b should equal \"hello world\"`)\n\t\t},\n\t},\n\t{\n\t\tv: \"hello world\",\n\t\texpectations: func(t *testing.T, b string, err error) {\n\t\t\tassert.Nil(t, err, \"err should be nil\")\n\t\t\tassert.Equal(t, `\"hello world\"`, b, `b should equal \"hello world\"`)\n\t\t},\n\t},\n\t{\n\t\tv: &TestEncodingArrStrings{\"hello world\", \"foo bar\"},\n\t\texpectations: func(t *testing.T, b string, err error) {\n\t\t\tassert.Nil(t, err, \"err should be nil\")\n\t\t\tassert.Equal(t, `[\"hello world\",\"foo bar\"]`, b, `b should equal [\"hello world\",\"foo bar\"]`)\n\t\t},\n\t},\n\t{\n\t\tv: &testObject{\n\t\t\t\"漢字\", nil, 1, nil, 1, nil, 1, nil, 1, nil, 1, nil,\n\t\t\t1, nil, 1, nil, 1, nil, 1, nil, 1.1, nil, 1.1, nil, true, nil,\n\t\t\t&testObject{}, testSliceInts{}, []interface{}{\"h\", \"o\", \"l\", \"a\"},\n\t\t},\n\t\texpectations: func(t *testing.T, b string, err error) {\n\t\t\tassert.Nil(t, err, \"err should be nil\")\n\t\t\tassert.Equal(t, `{\"testStr\":\"漢字\",\"testInt\":1,\"testInt64\":1,\"testInt32\":1,\"testInt16\":1,\"testInt8\":1,\"testUint64\":1,\"testUint32\":1,\"testUint16\":1,\"testUint8\":1,\"testFloat64\":1.1,\"testFloat32\":1.1,\"testBool\":true}`, string(b), `string(b) should equal {\"testStr\":\"漢字\",\"testInt\":1,\"testInt64\":1,\"testInt32\":1,\"testInt16\":1,\"testInt8\":1,\"testUint64\":1,\"testUint32\":1,\"testUint16\":1,\"testUint8\":1,\"testFloat64\":1.1,\"testFloat32\":1.1,\"testBool\":true}`)\n\t\t},\n\t},\n\t{\n\t\tv: &struct{}{},\n\t\texpectations: func(t *testing.T, b string, err error) {\n\t\t\tassert.NotNil(t, err, \"err should be nil\")\n\t\t\tassert.IsType(t, InvalidMarshalError(\"\"), err, \"err should be of type InvalidMarshalError\")\n\t\t\tvar s = struct{}{}\n\t\t\tassert.Equal(t, fmt.Sprintf(invalidMarshalErrorMsg, &s), err.Error(), \"err message should be equal to invalidMarshalErrorMsg\")\n\t\t},\n\t},\n}\n\nfunc TestEncoderInterfaceEncodeAPI(t *testing.T) {\n\tt.Run(\"encode-all-types\", func(t *testing.T) {\n\t\tfor _, test := range encoderTestCases {\n\t\t\tbuilder := &strings.Builder{}\n\t\t\tenc := BorrowEncoder(builder)\n\t\t\terr := enc.Encode(test.v)\n\t\t\tenc.Release()\n\t\t\ttest.expectations(t, builder.String(), err)\n\t\t}\n\t})\n\tt.Run(\"encode-all-types-write-error\", func(t *testing.T) {\n\t\tv := \"\"\n\t\tw := TestWriterError(\"\")\n\t\tenc := BorrowEncoder(w)\n\t\terr := enc.Encode(v)\n\t\tassert.NotNil(t, err, \"err should not be nil\")\n\t})\n\tt.Run(\"encode-all-types-pool-error\", func(t *testing.T) {\n\t\tv := \"\"\n\t\tw := TestWriterError(\"\")\n\t\tenc := BorrowEncoder(w)\n\t\tenc.isPooled = 1\n\t\tdefer func() {\n\t\t\terr := recover()\n\t\t\tassert.NotNil(t, err, \"err should not be nil\")\n\t\t\tassert.IsType(t, InvalidUsagePooledEncoderError(\"\"), err, \"err should be of type InvalidUsagePooledEncoderError\")\n\t\t}()\n\t\t_ = enc.Encode(v)\n\t\tassert.True(t, false, \"should not be called as decoder should have panicked\")\n\t})\n}\n\nfunc TestEncoderInterfaceMarshalAPI(t *testing.T) {\n\tt.Run(\"marshal-all-types\", func(t *testing.T) {\n\t\tfor _, test := range encoderTestCases {\n\t\t\tb, err := Marshal(test.v)\n\t\t\ttest.expectations(t, string(b), err)\n\t\t}\n\t})\n}\n"
        },
        {
          "name": "encode_null.go",
          "type": "blob",
          "size": 0.8583984375,
          "content": "package gojay\n\n// AddNull adds a `null` to be encoded. Must be used while encoding an array.`\nfunc (enc *Encoder) AddNull() {\n\tenc.Null()\n}\n\n// Null adds a `null` to be encoded. Must be used while encoding an array.`\nfunc (enc *Encoder) Null() {\n\tenc.grow(5)\n\tr := enc.getPreviousRune()\n\tif r != '[' {\n\t\tenc.writeByte(',')\n\t}\n\tenc.writeBytes(nullBytes)\n}\n\n// AddNullKey adds a `null` to be encoded. Must be used while encoding an array.`\nfunc (enc *Encoder) AddNullKey(key string) {\n\tenc.NullKey(key)\n}\n\n// NullKey adds a `null` to be encoded. Must be used while encoding an array.`\nfunc (enc *Encoder) NullKey(key string) {\n\tif enc.hasKeys {\n\t\tif !enc.keyExists(key) {\n\t\t\treturn\n\t\t}\n\t}\n\tenc.grow(5 + len(key))\n\tr := enc.getPreviousRune()\n\tif r != '{' {\n\t\tenc.writeByte(',')\n\t}\n\tenc.writeByte('\"')\n\tenc.writeStringEscape(key)\n\tenc.writeBytes(objKey)\n\tenc.writeBytes(nullBytes)\n}\n"
        },
        {
          "name": "encode_null_test.go",
          "type": "blob",
          "size": 1.3828125,
          "content": "package gojay\n\nimport (\n\t\"strings\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestEncodeNull(t *testing.T) {\n\tvar testCases = []struct {\n\t\tname         string\n\t\tbaseJSON     string\n\t\texpectedJSON string\n\t}{\n\t\t{\n\t\t\tname:         \"basic 1st element\",\n\t\t\tbaseJSON:     `[`,\n\t\t\texpectedJSON: `[null,null`,\n\t\t},\n\t\t{\n\t\t\tname:         \"basic last element\",\n\t\t\tbaseJSON:     `[\"test\"`,\n\t\t\texpectedJSON: `[\"test\",null,null`,\n\t\t},\n\t}\n\n\tfor _, testCase := range testCases {\n\t\tt.Run(testCase.name, func(t *testing.T) {\n\t\t\tvar b strings.Builder\n\t\t\tvar enc = NewEncoder(&b)\n\t\t\tenc.writeString(testCase.baseJSON)\n\t\t\tenc.Null()\n\t\t\tenc.AddNull()\n\t\t\tenc.Write()\n\t\t\tassert.Equal(t, testCase.expectedJSON, b.String())\n\t\t})\n\t}\n}\n\nfunc TestEncodeNullKey(t *testing.T) {\n\tvar testCases = []struct {\n\t\tname         string\n\t\tbaseJSON     string\n\t\texpectedJSON string\n\t}{\n\t\t{\n\t\t\tname:         \"basic 1st element\",\n\t\t\tbaseJSON:     `{`,\n\t\t\texpectedJSON: `{\"foo\":null,\"bar\":null`,\n\t\t},\n\t\t{\n\t\t\tname:         \"basic last element\",\n\t\t\tbaseJSON:     `{\"test\":\"test\"`,\n\t\t\texpectedJSON: `{\"test\":\"test\",\"foo\":null,\"bar\":null`,\n\t\t},\n\t}\n\n\tfor _, testCase := range testCases {\n\t\tt.Run(testCase.name, func(t *testing.T) {\n\t\t\tvar b strings.Builder\n\t\t\tvar enc = NewEncoder(&b)\n\t\t\tenc.writeString(testCase.baseJSON)\n\t\t\tenc.NullKey(\"foo\")\n\t\t\tenc.AddNullKey(\"bar\")\n\t\t\tenc.Write()\n\t\t\tassert.Equal(t, testCase.expectedJSON, b.String())\n\t\t})\n\t}\n}\n"
        },
        {
          "name": "encode_number.go",
          "type": "blob",
          "size": 0.013671875,
          "content": "package gojay\n"
        },
        {
          "name": "encode_number_float.go",
          "type": "blob",
          "size": 10.6494140625,
          "content": "package gojay\n\nimport \"strconv\"\n\n// EncodeFloat encodes a float64 to JSON\nfunc (enc *Encoder) EncodeFloat(n float64) error {\n\tif enc.isPooled == 1 {\n\t\tpanic(InvalidUsagePooledEncoderError(\"Invalid usage of pooled encoder\"))\n\t}\n\t_, _ = enc.encodeFloat(n)\n\t_, err := enc.Write()\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}\n\n// encodeFloat encodes a float64 to JSON\nfunc (enc *Encoder) encodeFloat(n float64) ([]byte, error) {\n\tenc.buf = strconv.AppendFloat(enc.buf, n, 'f', -1, 64)\n\treturn enc.buf, nil\n}\n\n// EncodeFloat32 encodes a float32 to JSON\nfunc (enc *Encoder) EncodeFloat32(n float32) error {\n\tif enc.isPooled == 1 {\n\t\tpanic(InvalidUsagePooledEncoderError(\"Invalid usage of pooled encoder\"))\n\t}\n\t_, _ = enc.encodeFloat32(n)\n\t_, err := enc.Write()\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}\n\nfunc (enc *Encoder) encodeFloat32(n float32) ([]byte, error) {\n\tenc.buf = strconv.AppendFloat(enc.buf, float64(n), 'f', -1, 32)\n\treturn enc.buf, nil\n}\n\n// AddFloat adds a float64 to be encoded, must be used inside a slice or array encoding (does not encode a key)\nfunc (enc *Encoder) AddFloat(v float64) {\n\tenc.Float64(v)\n}\n\n// AddFloatOmitEmpty adds a float64 to be encoded and skips it if its value is 0,\n// must be used inside a slice or array encoding (does not encode a key).\nfunc (enc *Encoder) AddFloatOmitEmpty(v float64) {\n\tenc.Float64OmitEmpty(v)\n}\n\n// AddFloatNullEmpty adds a float64 to be encoded and skips it if its value is 0,\n// must be used inside a slice or array encoding (does not encode a key).\nfunc (enc *Encoder) AddFloatNullEmpty(v float64) {\n\tenc.Float64NullEmpty(v)\n}\n\n// Float adds a float64 to be encoded, must be used inside a slice or array encoding (does not encode a key)\nfunc (enc *Encoder) Float(v float64) {\n\tenc.Float64(v)\n}\n\n// FloatOmitEmpty adds a float64 to be encoded and skips it if its value is 0,\n// must be used inside a slice or array encoding (does not encode a key).\nfunc (enc *Encoder) FloatOmitEmpty(v float64) {\n\tenc.Float64OmitEmpty(v)\n}\n\n// FloatNullEmpty adds a float64 to be encoded and skips it if its value is 0,\n// must be used inside a slice or array encoding (does not encode a key).\nfunc (enc *Encoder) FloatNullEmpty(v float64) {\n\tenc.Float64NullEmpty(v)\n}\n\n// AddFloatKey adds a float64 to be encoded, must be used inside an object as it will encode a key\nfunc (enc *Encoder) AddFloatKey(key string, v float64) {\n\tenc.Float64Key(key, v)\n}\n\n// AddFloatKeyOmitEmpty adds a float64 to be encoded and skips it if its value is 0.\n// Must be used inside an object as it will encode a key\nfunc (enc *Encoder) AddFloatKeyOmitEmpty(key string, v float64) {\n\tenc.Float64KeyOmitEmpty(key, v)\n}\n\n// AddFloatKeyNullEmpty adds a float64 to be encoded and skips it if its value is 0.\n// Must be used inside an object as it will encode a key\nfunc (enc *Encoder) AddFloatKeyNullEmpty(key string, v float64) {\n\tenc.Float64KeyNullEmpty(key, v)\n}\n\n// FloatKey adds a float64 to be encoded, must be used inside an object as it will encode a key\nfunc (enc *Encoder) FloatKey(key string, v float64) {\n\tenc.Float64Key(key, v)\n}\n\n// FloatKeyOmitEmpty adds a float64 to be encoded and skips it if its value is 0.\n// Must be used inside an object as it will encode a key\nfunc (enc *Encoder) FloatKeyOmitEmpty(key string, v float64) {\n\tenc.Float64KeyOmitEmpty(key, v)\n}\n\n// FloatKeyNullEmpty adds a float64 to be encoded and skips it if its value is 0.\n// Must be used inside an object as it will encode a key\nfunc (enc *Encoder) FloatKeyNullEmpty(key string, v float64) {\n\tenc.Float64KeyNullEmpty(key, v)\n}\n\n// AddFloat64 adds a float64 to be encoded, must be used inside a slice or array encoding (does not encode a key)\nfunc (enc *Encoder) AddFloat64(v float64) {\n\tenc.Float(v)\n}\n\n// AddFloat64OmitEmpty adds a float64 to be encoded and skips it if its value is 0,\n// must be used inside a slice or array encoding (does not encode a key).\nfunc (enc *Encoder) AddFloat64OmitEmpty(v float64) {\n\tenc.FloatOmitEmpty(v)\n}\n\n// Float64 adds a float64 to be encoded, must be used inside a slice or array encoding (does not encode a key)\nfunc (enc *Encoder) Float64(v float64) {\n\tenc.grow(10)\n\tr := enc.getPreviousRune()\n\tif r != '[' {\n\t\tenc.writeByte(',')\n\t}\n\tenc.buf = strconv.AppendFloat(enc.buf, v, 'f', -1, 64)\n}\n\n// Float64OmitEmpty adds a float64 to be encoded and skips it if its value is 0,\n// must be used inside a slice or array encoding (does not encode a key).\nfunc (enc *Encoder) Float64OmitEmpty(v float64) {\n\tif v == 0 {\n\t\treturn\n\t}\n\tenc.grow(10)\n\tr := enc.getPreviousRune()\n\tif r != '[' {\n\t\tenc.writeByte(',')\n\t}\n\tenc.buf = strconv.AppendFloat(enc.buf, v, 'f', -1, 64)\n}\n\n// Float64NullEmpty adds a float64 to be encoded and skips it if its value is 0,\n// must be used inside a slice or array encoding (does not encode a key).\nfunc (enc *Encoder) Float64NullEmpty(v float64) {\n\tenc.grow(10)\n\tr := enc.getPreviousRune()\n\tif r != '[' {\n\t\tenc.writeByte(',')\n\t}\n\tif v == 0 {\n\t\tenc.writeBytes(nullBytes)\n\t\treturn\n\t}\n\tenc.buf = strconv.AppendFloat(enc.buf, v, 'f', -1, 64)\n}\n\n// AddFloat64Key adds a float64 to be encoded, must be used inside an object as it will encode a key\nfunc (enc *Encoder) AddFloat64Key(key string, v float64) {\n\tenc.FloatKey(key, v)\n}\n\n// AddFloat64KeyOmitEmpty adds a float64 to be encoded and skips it if its value is 0.\n// Must be used inside an object as it will encode a key\nfunc (enc *Encoder) AddFloat64KeyOmitEmpty(key string, v float64) {\n\tenc.FloatKeyOmitEmpty(key, v)\n}\n\n// Float64Key adds a float64 to be encoded, must be used inside an object as it will encode a key\nfunc (enc *Encoder) Float64Key(key string, value float64) {\n\tif enc.hasKeys {\n\t\tif !enc.keyExists(key) {\n\t\t\treturn\n\t\t}\n\t}\n\tr := enc.getPreviousRune()\n\tif r != '{' {\n\t\tenc.writeByte(',')\n\t}\n\tenc.grow(10)\n\tenc.writeByte('\"')\n\tenc.writeStringEscape(key)\n\tenc.writeBytes(objKey)\n\tenc.buf = strconv.AppendFloat(enc.buf, value, 'f', -1, 64)\n}\n\n// Float64KeyOmitEmpty adds a float64 to be encoded and skips it if its value is 0.\n// Must be used inside an object as it will encode a key\nfunc (enc *Encoder) Float64KeyOmitEmpty(key string, v float64) {\n\tif enc.hasKeys {\n\t\tif !enc.keyExists(key) {\n\t\t\treturn\n\t\t}\n\t}\n\tif v == 0 {\n\t\treturn\n\t}\n\tenc.grow(10 + len(key))\n\tr := enc.getPreviousRune()\n\tif r != '{' {\n\t\tenc.writeByte(',')\n\t}\n\tenc.writeByte('\"')\n\tenc.writeStringEscape(key)\n\tenc.writeBytes(objKey)\n\tenc.buf = strconv.AppendFloat(enc.buf, v, 'f', -1, 64)\n}\n\n// Float64KeyNullEmpty adds a float64 to be encoded and skips it if its value is 0,\n// must be used inside a slice or array encoding (does not encode a key).\nfunc (enc *Encoder) Float64KeyNullEmpty(key string, v float64) {\n\tif enc.hasKeys {\n\t\tif !enc.keyExists(key) {\n\t\t\treturn\n\t\t}\n\t}\n\tenc.grow(10 + len(key))\n\tr := enc.getPreviousRune()\n\tif r != '{' {\n\t\tenc.writeByte(',')\n\t}\n\tenc.writeByte('\"')\n\tenc.writeStringEscape(key)\n\tenc.writeBytes(objKey)\n\tif v == 0 {\n\t\tenc.writeBytes(nullBytes)\n\t\treturn\n\t}\n\tenc.buf = strconv.AppendFloat(enc.buf, v, 'f', -1, 64)\n}\n\n// AddFloat32 adds a float32 to be encoded, must be used inside a slice or array encoding (does not encode a key)\nfunc (enc *Encoder) AddFloat32(v float32) {\n\tenc.Float32(v)\n}\n\n// AddFloat32OmitEmpty adds an int to be encoded and skips it if its value is 0,\n// must be used inside a slice or array encoding (does not encode a key).\nfunc (enc *Encoder) AddFloat32OmitEmpty(v float32) {\n\tenc.Float32OmitEmpty(v)\n}\n\n// AddFloat32NullEmpty adds an int to be encoded and skips it if its value is 0,\n// must be used inside a slice or array encoding (does not encode a key).\nfunc (enc *Encoder) AddFloat32NullEmpty(v float32) {\n\tenc.Float32NullEmpty(v)\n}\n\n// Float32 adds a float32 to be encoded, must be used inside a slice or array encoding (does not encode a key)\nfunc (enc *Encoder) Float32(v float32) {\n\tr := enc.getPreviousRune()\n\tif r != '[' {\n\t\tenc.writeByte(',')\n\t}\n\tenc.buf = strconv.AppendFloat(enc.buf, float64(v), 'f', -1, 32)\n}\n\n// Float32OmitEmpty adds an int to be encoded and skips it if its value is 0,\n// must be used inside a slice or array encoding (does not encode a key).\nfunc (enc *Encoder) Float32OmitEmpty(v float32) {\n\tif v == 0 {\n\t\treturn\n\t}\n\tenc.grow(10)\n\tr := enc.getPreviousRune()\n\tif r != '[' {\n\t\tenc.writeByte(',')\n\t}\n\tenc.buf = strconv.AppendFloat(enc.buf, float64(v), 'f', -1, 32)\n}\n\n// Float32NullEmpty adds an int to be encoded and skips it if its value is 0,\n// must be used inside a slice or array encoding (does not encode a key).\nfunc (enc *Encoder) Float32NullEmpty(v float32) {\n\tenc.grow(10)\n\tr := enc.getPreviousRune()\n\tif r != '[' {\n\t\tenc.writeByte(',')\n\t}\n\tif v == 0 {\n\t\tenc.writeBytes(nullBytes)\n\t\treturn\n\t}\n\tenc.buf = strconv.AppendFloat(enc.buf, float64(v), 'f', -1, 32)\n}\n\n// AddFloat32Key adds a float32 to be encoded, must be used inside an object as it will encode a key\nfunc (enc *Encoder) AddFloat32Key(key string, v float32) {\n\tenc.Float32Key(key, v)\n}\n\n// AddFloat32KeyOmitEmpty adds a float64 to be encoded and skips it if its value is 0.\n// Must be used inside an object as it will encode a key\nfunc (enc *Encoder) AddFloat32KeyOmitEmpty(key string, v float32) {\n\tenc.Float32KeyOmitEmpty(key, v)\n}\n\n// AddFloat32KeyNullEmpty adds a float64 to be encoded and skips it if its value is 0.\n// Must be used inside an object as it will encode a key\nfunc (enc *Encoder) AddFloat32KeyNullEmpty(key string, v float32) {\n\tenc.Float32KeyNullEmpty(key, v)\n}\n\n// Float32Key adds a float32 to be encoded, must be used inside an object as it will encode a key\nfunc (enc *Encoder) Float32Key(key string, v float32) {\n\tif enc.hasKeys {\n\t\tif !enc.keyExists(key) {\n\t\t\treturn\n\t\t}\n\t}\n\tenc.grow(10 + len(key))\n\tr := enc.getPreviousRune()\n\tif r != '{' {\n\t\tenc.writeByte(',')\n\t}\n\tenc.writeByte('\"')\n\tenc.writeStringEscape(key)\n\tenc.writeByte('\"')\n\tenc.writeByte(':')\n\tenc.buf = strconv.AppendFloat(enc.buf, float64(v), 'f', -1, 32)\n}\n\n// Float32KeyOmitEmpty adds a float64 to be encoded and skips it if its value is 0.\n// Must be used inside an object as it will encode a key\nfunc (enc *Encoder) Float32KeyOmitEmpty(key string, v float32) {\n\tif enc.hasKeys {\n\t\tif !enc.keyExists(key) {\n\t\t\treturn\n\t\t}\n\t}\n\tif v == 0 {\n\t\treturn\n\t}\n\tenc.grow(10 + len(key))\n\tr := enc.getPreviousRune()\n\tif r != '{' {\n\t\tenc.writeByte(',')\n\t}\n\tenc.writeByte('\"')\n\tenc.writeStringEscape(key)\n\tenc.writeBytes(objKey)\n\tenc.buf = strconv.AppendFloat(enc.buf, float64(v), 'f', -1, 32)\n}\n\n// Float32KeyNullEmpty adds a float64 to be encoded and skips it if its value is 0.\n// Must be used inside an object as it will encode a key\nfunc (enc *Encoder) Float32KeyNullEmpty(key string, v float32) {\n\tif enc.hasKeys {\n\t\tif !enc.keyExists(key) {\n\t\t\treturn\n\t\t}\n\t}\n\tenc.grow(10 + len(key))\n\tr := enc.getPreviousRune()\n\tif r != '{' {\n\t\tenc.writeByte(',')\n\t}\n\tenc.writeByte('\"')\n\tenc.writeStringEscape(key)\n\tenc.writeBytes(objKey)\n\tif v == 0 {\n\t\tenc.writeBytes(nullBytes)\n\t\treturn\n\t}\n\tenc.buf = strconv.AppendFloat(enc.buf, float64(v), 'f', -1, 32)\n}\n"
        },
        {
          "name": "encode_number_float_test.go",
          "type": "blob",
          "size": 5.314453125,
          "content": "package gojay\n\nimport (\n\t\"strings\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestEncoderFloat64(t *testing.T) {\n\tvar testCasesBasic = []struct {\n\t\tname         string\n\t\tv            float64\n\t\texpectedJSON string\n\t}{\n\t\t{\n\t\t\tname:         \"basic\",\n\t\t\tv:            float64(1),\n\t\t\texpectedJSON: \"[1,1]\",\n\t\t},\n\t\t{\n\t\t\tname:         \"big\",\n\t\t\tv:            float64(0),\n\t\t\texpectedJSON: \"[0,0]\",\n\t\t},\n\t}\n\tfor _, testCase := range testCasesBasic {\n\t\tt.Run(testCase.name, func(t *testing.T) {\n\t\t\tvar b = &strings.Builder{}\n\t\t\tvar enc = NewEncoder(b)\n\t\t\tenc.Encode(EncodeArrayFunc(func(enc *Encoder) {\n\t\t\t\tenc.Float64(testCase.v)\n\t\t\t\tenc.AddFloat64(testCase.v)\n\t\t\t}))\n\t\t\tassert.Equal(t, testCase.expectedJSON, b.String())\n\t\t})\n\t}\n\tvar testCasesOmitEmpty = []struct {\n\t\tname         string\n\t\tv            float64\n\t\texpectedJSON string\n\t}{\n\t\t{\n\t\t\tname:         \"basic\",\n\t\t\tv:            float64(1),\n\t\t\texpectedJSON: \"[1,1]\",\n\t\t},\n\t\t{\n\t\t\tname:         \"big\",\n\t\t\tv:            float64(0),\n\t\t\texpectedJSON: \"[]\",\n\t\t},\n\t}\n\tfor _, testCase := range testCasesOmitEmpty {\n\t\tt.Run(testCase.name, func(t *testing.T) {\n\t\t\tvar b = &strings.Builder{}\n\t\t\tvar enc = NewEncoder(b)\n\t\t\tenc.Encode(EncodeArrayFunc(func(enc *Encoder) {\n\t\t\t\tenc.Float64OmitEmpty(testCase.v)\n\t\t\t\tenc.AddFloat64OmitEmpty(testCase.v)\n\t\t\t}))\n\t\t\tassert.Equal(t, testCase.expectedJSON, b.String())\n\t\t})\n\t}\n\tvar testCasesKeyBasic = []struct {\n\t\tname         string\n\t\tv            float64\n\t\texpectedJSON string\n\t}{\n\t\t{\n\t\t\tname:         \"basic\",\n\t\t\tv:            float64(1),\n\t\t\texpectedJSON: `{\"foo\":1,\"bar\":1}`,\n\t\t},\n\t\t{\n\t\t\tname:         \"big\",\n\t\t\tv:            float64(0),\n\t\t\texpectedJSON: `{\"foo\":0,\"bar\":0}`,\n\t\t},\n\t}\n\tfor _, testCase := range testCasesKeyBasic {\n\t\tt.Run(testCase.name, func(t *testing.T) {\n\t\t\tvar b = &strings.Builder{}\n\t\t\tvar enc = NewEncoder(b)\n\t\t\tenc.Encode(EncodeObjectFunc(func(enc *Encoder) {\n\t\t\t\tenc.Float64Key(\"foo\", testCase.v)\n\t\t\t\tenc.AddFloat64Key(\"bar\", testCase.v)\n\t\t\t}))\n\t\t\tassert.Equal(t, testCase.expectedJSON, b.String())\n\t\t})\n\t}\n\tvar testCasesKeyOmitEmpty = []struct {\n\t\tname         string\n\t\tv            float64\n\t\texpectedJSON string\n\t}{\n\t\t{\n\t\t\tname:         \"basic\",\n\t\t\tv:            float64(1),\n\t\t\texpectedJSON: `{\"foo\":1,\"bar\":1}`,\n\t\t},\n\t\t{\n\t\t\tname:         \"big\",\n\t\t\tv:            float64(0),\n\t\t\texpectedJSON: \"{}\",\n\t\t},\n\t}\n\tfor _, testCase := range testCasesKeyOmitEmpty {\n\t\tt.Run(testCase.name, func(t *testing.T) {\n\t\t\tvar b = &strings.Builder{}\n\t\t\tvar enc = NewEncoder(b)\n\t\t\tenc.Encode(EncodeObjectFunc(func(enc *Encoder) {\n\t\t\t\tenc.Float64KeyOmitEmpty(\"foo\", testCase.v)\n\t\t\t\tenc.AddFloat64KeyOmitEmpty(\"bar\", testCase.v)\n\t\t\t}))\n\t\t\tassert.Equal(t, testCase.expectedJSON, b.String())\n\t\t})\n\t}\n}\n\nfunc TestEncoderFloat64NullEmpty(t *testing.T) {\n\tvar testCases = []struct {\n\t\tname         string\n\t\tbaseJSON     string\n\t\texpectedJSON string\n\t}{\n\t\t{\n\t\t\tname:         \"basic 1st elem\",\n\t\t\tbaseJSON:     \"[\",\n\t\t\texpectedJSON: `[null,1`,\n\t\t},\n\t\t{\n\t\t\tname:         \"basic 2nd elem\",\n\t\t\tbaseJSON:     `[\"test\"`,\n\t\t\texpectedJSON: `[\"test\",null,1`,\n\t\t},\n\t}\n\tfor _, testCase := range testCases {\n\t\tt.Run(\"true\", func(t *testing.T) {\n\t\t\tvar b strings.Builder\n\t\t\tvar enc = NewEncoder(&b)\n\t\t\tenc.writeString(testCase.baseJSON)\n\t\t\tenc.FloatNullEmpty(0)\n\t\t\tenc.AddFloatNullEmpty(1)\n\t\t\tenc.Write()\n\t\t\tassert.Equal(t, testCase.expectedJSON, b.String())\n\t\t})\n\t}\n}\n\nfunc TestEncoderFloat64KeyNullEmpty(t *testing.T) {\n\tvar testCases = []struct {\n\t\tname         string\n\t\tbaseJSON     string\n\t\texpectedJSON string\n\t}{\n\t\t{\n\t\t\tname:         \"basic 1st elem\",\n\t\t\tbaseJSON:     \"{\",\n\t\t\texpectedJSON: `{\"foo\":null,\"bar\":1`,\n\t\t},\n\t\t{\n\t\t\tname:         \"basic 2nd elem\",\n\t\t\tbaseJSON:     `{\"test\":\"test\"`,\n\t\t\texpectedJSON: `{\"test\":\"test\",\"foo\":null,\"bar\":1`,\n\t\t},\n\t}\n\tfor _, testCase := range testCases {\n\t\tt.Run(testCase.name, func(t *testing.T) {\n\t\t\tvar b strings.Builder\n\t\t\tvar enc = NewEncoder(&b)\n\t\t\tenc.writeString(testCase.baseJSON)\n\t\t\tenc.FloatKeyNullEmpty(\"foo\", 0)\n\t\t\tenc.AddFloatKeyNullEmpty(\"bar\", 1)\n\t\t\tenc.Write()\n\t\t\tassert.Equal(t, testCase.expectedJSON, b.String())\n\t\t})\n\t}\n}\n\nfunc TestEncoderFloat32NullEmpty(t *testing.T) {\n\tvar testCases = []struct {\n\t\tname         string\n\t\tbaseJSON     string\n\t\texpectedJSON string\n\t}{\n\t\t{\n\t\t\tname:         \"basic 1st elem\",\n\t\t\tbaseJSON:     \"[\",\n\t\t\texpectedJSON: `[null,1`,\n\t\t},\n\t\t{\n\t\t\tname:         \"basic 2nd elem\",\n\t\t\tbaseJSON:     `[\"test\"`,\n\t\t\texpectedJSON: `[\"test\",null,1`,\n\t\t},\n\t}\n\tfor _, testCase := range testCases {\n\t\tt.Run(\"true\", func(t *testing.T) {\n\t\t\tvar b strings.Builder\n\t\t\tvar enc = NewEncoder(&b)\n\t\t\tenc.writeString(testCase.baseJSON)\n\t\t\tenc.Float32NullEmpty(0)\n\t\t\tenc.AddFloat32NullEmpty(1)\n\t\t\tenc.Write()\n\t\t\tassert.Equal(t, testCase.expectedJSON, b.String())\n\t\t})\n\t}\n}\n\nfunc TestEncoderFloat32KeyNullEmpty(t *testing.T) {\n\tvar testCases = []struct {\n\t\tname         string\n\t\tbaseJSON     string\n\t\texpectedJSON string\n\t}{\n\t\t{\n\t\t\tname:         \"basic 1st elem\",\n\t\t\tbaseJSON:     \"{\",\n\t\t\texpectedJSON: `{\"foo\":null,\"bar\":1`,\n\t\t},\n\t\t{\n\t\t\tname:         \"basic 2nd elem\",\n\t\t\tbaseJSON:     `{\"test\":\"test\"`,\n\t\t\texpectedJSON: `{\"test\":\"test\",\"foo\":null,\"bar\":1`,\n\t\t},\n\t}\n\tfor _, testCase := range testCases {\n\t\tt.Run(testCase.name, func(t *testing.T) {\n\t\t\tvar b strings.Builder\n\t\t\tvar enc = NewEncoder(&b)\n\t\t\tenc.writeString(testCase.baseJSON)\n\t\t\tenc.Float32KeyNullEmpty(\"foo\", 0)\n\t\t\tenc.AddFloat32KeyNullEmpty(\"bar\", 1)\n\t\t\tenc.Write()\n\t\t\tassert.Equal(t, testCase.expectedJSON, b.String())\n\t\t})\n\t}\n}\n"
        },
        {
          "name": "encode_number_int.go",
          "type": "blob",
          "size": 15.2294921875,
          "content": "package gojay\n\nimport \"strconv\"\n\n// EncodeInt encodes an int to JSON\nfunc (enc *Encoder) EncodeInt(n int) error {\n\tif enc.isPooled == 1 {\n\t\tpanic(InvalidUsagePooledEncoderError(\"Invalid usage of pooled encoder\"))\n\t}\n\t_, _ = enc.encodeInt(n)\n\t_, err := enc.Write()\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}\n\n// encodeInt encodes an int to JSON\nfunc (enc *Encoder) encodeInt(n int) ([]byte, error) {\n\tenc.buf = strconv.AppendInt(enc.buf, int64(n), 10)\n\treturn enc.buf, nil\n}\n\n// EncodeInt64 encodes an int64 to JSON\nfunc (enc *Encoder) EncodeInt64(n int64) error {\n\tif enc.isPooled == 1 {\n\t\tpanic(InvalidUsagePooledEncoderError(\"Invalid usage of pooled encoder\"))\n\t}\n\t_, _ = enc.encodeInt64(n)\n\t_, err := enc.Write()\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}\n\n// encodeInt64 encodes an int to JSON\nfunc (enc *Encoder) encodeInt64(n int64) ([]byte, error) {\n\tenc.buf = strconv.AppendInt(enc.buf, n, 10)\n\treturn enc.buf, nil\n}\n\n// AddInt adds an int to be encoded, must be used inside a slice or array encoding (does not encode a key)\nfunc (enc *Encoder) AddInt(v int) {\n\tenc.Int(v)\n}\n\n// AddIntOmitEmpty adds an int to be encoded and skips it if its value is 0,\n// must be used inside a slice or array encoding (does not encode a key).\nfunc (enc *Encoder) AddIntOmitEmpty(v int) {\n\tenc.IntOmitEmpty(v)\n}\n\n// AddIntNullEmpty adds an int to be encoded and skips it if its value is 0,\n// must be used inside a slice or array encoding (does not encode a key).\nfunc (enc *Encoder) AddIntNullEmpty(v int) {\n\tenc.IntNullEmpty(v)\n}\n\n// Int adds an int to be encoded, must be used inside a slice or array encoding (does not encode a key)\nfunc (enc *Encoder) Int(v int) {\n\tenc.grow(10)\n\tr := enc.getPreviousRune()\n\tif r != '[' {\n\t\tenc.writeByte(',')\n\t}\n\tenc.buf = strconv.AppendInt(enc.buf, int64(v), 10)\n}\n\n// IntOmitEmpty adds an int to be encoded and skips it if its value is 0,\n// must be used inside a slice or array encoding (does not encode a key).\nfunc (enc *Encoder) IntOmitEmpty(v int) {\n\tif v == 0 {\n\t\treturn\n\t}\n\tenc.grow(10)\n\tr := enc.getPreviousRune()\n\tif r != '[' {\n\t\tenc.writeByte(',')\n\t}\n\tenc.buf = strconv.AppendInt(enc.buf, int64(v), 10)\n}\n\n// IntNullEmpty adds an int to be encoded and skips it if its value is 0,\n// must be used inside a slice or array encoding (does not encode a key).\nfunc (enc *Encoder) IntNullEmpty(v int) {\n\tenc.grow(10)\n\tr := enc.getPreviousRune()\n\tif r != '[' {\n\t\tenc.writeByte(',')\n\t}\n\tif v == 0 {\n\t\tenc.writeBytes(nullBytes)\n\t\treturn\n\t}\n\tenc.buf = strconv.AppendInt(enc.buf, int64(v), 10)\n}\n\n// AddIntKey adds an int to be encoded, must be used inside an object as it will encode a key\nfunc (enc *Encoder) AddIntKey(key string, v int) {\n\tenc.IntKey(key, v)\n}\n\n// AddIntKeyOmitEmpty adds an int to be encoded and skips it if its value is 0.\n// Must be used inside an object as it will encode a key.\nfunc (enc *Encoder) AddIntKeyOmitEmpty(key string, v int) {\n\tenc.IntKeyOmitEmpty(key, v)\n}\n\n// AddIntKeyNullEmpty adds an int to be encoded and skips it if its value is 0.\n// Must be used inside an object as it will encode a key.\nfunc (enc *Encoder) AddIntKeyNullEmpty(key string, v int) {\n\tenc.IntKeyNullEmpty(key, v)\n}\n\n// IntKey adds an int to be encoded, must be used inside an object as it will encode a key\nfunc (enc *Encoder) IntKey(key string, v int) {\n\tif enc.hasKeys {\n\t\tif !enc.keyExists(key) {\n\t\t\treturn\n\t\t}\n\t}\n\tenc.grow(10 + len(key))\n\tr := enc.getPreviousRune()\n\tif r != '{' {\n\t\tenc.writeByte(',')\n\t}\n\tenc.writeByte('\"')\n\tenc.writeStringEscape(key)\n\tenc.writeBytes(objKey)\n\tenc.buf = strconv.AppendInt(enc.buf, int64(v), 10)\n}\n\n// IntKeyOmitEmpty adds an int to be encoded and skips it if its value is 0.\n// Must be used inside an object as it will encode a key.\nfunc (enc *Encoder) IntKeyOmitEmpty(key string, v int) {\n\tif enc.hasKeys {\n\t\tif !enc.keyExists(key) {\n\t\t\treturn\n\t\t}\n\t}\n\tif v == 0 {\n\t\treturn\n\t}\n\tenc.grow(10 + len(key))\n\tr := enc.getPreviousRune()\n\tif r != '{' && r != '[' {\n\t\tenc.writeByte(',')\n\t}\n\tenc.writeByte('\"')\n\tenc.writeStringEscape(key)\n\tenc.writeBytes(objKey)\n\tenc.buf = strconv.AppendInt(enc.buf, int64(v), 10)\n}\n\n// IntKeyNullEmpty adds an int to be encoded and skips it if its value is 0.\n// Must be used inside an object as it will encode a key.\nfunc (enc *Encoder) IntKeyNullEmpty(key string, v int) {\n\tif enc.hasKeys {\n\t\tif !enc.keyExists(key) {\n\t\t\treturn\n\t\t}\n\t}\n\tenc.grow(10 + len(key))\n\tr := enc.getPreviousRune()\n\tif r != '{' && r != '[' {\n\t\tenc.writeByte(',')\n\t}\n\tenc.writeByte('\"')\n\tenc.writeStringEscape(key)\n\tenc.writeBytes(objKey)\n\tif v == 0 {\n\t\tenc.writeBytes(nullBytes)\n\t\treturn\n\t}\n\tenc.buf = strconv.AppendInt(enc.buf, int64(v), 10)\n}\n\n// AddInt64 adds an int to be encoded, must be used inside a slice or array encoding (does not encode a key)\nfunc (enc *Encoder) AddInt64(v int64) {\n\tenc.Int64(v)\n}\n\n// AddInt64OmitEmpty adds an int to be encoded and skips it if its value is 0,\n// must be used inside a slice or array encoding (does not encode a key).\nfunc (enc *Encoder) AddInt64OmitEmpty(v int64) {\n\tenc.Int64OmitEmpty(v)\n}\n\n// AddInt64NullEmpty adds an int to be encoded and skips it if its value is 0,\n// must be used inside a slice or array encoding (does not encode a key).\nfunc (enc *Encoder) AddInt64NullEmpty(v int64) {\n\tenc.Int64NullEmpty(v)\n}\n\n// Int64 adds an int to be encoded, must be used inside a slice or array encoding (does not encode a key)\nfunc (enc *Encoder) Int64(v int64) {\n\tenc.grow(10)\n\tr := enc.getPreviousRune()\n\tif r != '[' {\n\t\tenc.writeByte(',')\n\t}\n\tenc.buf = strconv.AppendInt(enc.buf, v, 10)\n}\n\n// Int64OmitEmpty adds an int to be encoded and skips it if its value is 0,\n// must be used inside a slice or array encoding (does not encode a key).\nfunc (enc *Encoder) Int64OmitEmpty(v int64) {\n\tif v == 0 {\n\t\treturn\n\t}\n\tenc.grow(10)\n\tr := enc.getPreviousRune()\n\tif r != '[' {\n\t\tenc.writeByte(',')\n\t}\n\tenc.buf = strconv.AppendInt(enc.buf, v, 10)\n}\n\n// Int64NullEmpty adds an int to be encoded and skips it if its value is 0,\n// must be used inside a slice or array encoding (does not encode a key).\nfunc (enc *Encoder) Int64NullEmpty(v int64) {\n\tenc.grow(10)\n\tr := enc.getPreviousRune()\n\tif r != '[' {\n\t\tenc.writeByte(',')\n\t}\n\tif v == 0 {\n\t\tenc.writeBytes(nullBytes)\n\t\treturn\n\t}\n\tenc.buf = strconv.AppendInt(enc.buf, v, 10)\n}\n\n// AddInt64Key adds an int64 to be encoded, must be used inside an object as it will encode a key\nfunc (enc *Encoder) AddInt64Key(key string, v int64) {\n\tenc.Int64Key(key, v)\n}\n\n// AddInt64KeyOmitEmpty adds an int64 to be encoded and skips it if its value is 0.\n// Must be used inside an object as it will encode a key.\nfunc (enc *Encoder) AddInt64KeyOmitEmpty(key string, v int64) {\n\tenc.Int64KeyOmitEmpty(key, v)\n}\n\n// AddInt64KeyNullEmpty adds an int64 to be encoded and skips it if its value is 0.\n// Must be used inside an object as it will encode a key.\nfunc (enc *Encoder) AddInt64KeyNullEmpty(key string, v int64) {\n\tenc.Int64KeyNullEmpty(key, v)\n}\n\n// Int64Key adds an int64 to be encoded, must be used inside an object as it will encode a key\nfunc (enc *Encoder) Int64Key(key string, v int64) {\n\tif enc.hasKeys {\n\t\tif !enc.keyExists(key) {\n\t\t\treturn\n\t\t}\n\t}\n\tenc.grow(10 + len(key))\n\tr := enc.getPreviousRune()\n\tif r != '{' {\n\t\tenc.writeByte(',')\n\t}\n\tenc.writeByte('\"')\n\tenc.writeStringEscape(key)\n\tenc.writeBytes(objKey)\n\tenc.buf = strconv.AppendInt(enc.buf, v, 10)\n}\n\n// Int64KeyOmitEmpty adds an int64 to be encoded and skips it if its value is 0.\n// Must be used inside an object as it will encode a key.\nfunc (enc *Encoder) Int64KeyOmitEmpty(key string, v int64) {\n\tif v == 0 {\n\t\treturn\n\t}\n\tenc.grow(10 + len(key))\n\tr := enc.getPreviousRune()\n\tif r != '{' {\n\t\tenc.writeByte(',')\n\t}\n\tenc.writeByte('\"')\n\tenc.writeStringEscape(key)\n\tenc.writeBytes(objKey)\n\tenc.buf = strconv.AppendInt(enc.buf, v, 10)\n}\n\n// Int64KeyNullEmpty adds an int64 to be encoded and skips it if its value is 0.\n// Must be used inside an object as it will encode a key.\nfunc (enc *Encoder) Int64KeyNullEmpty(key string, v int64) {\n\tif enc.hasKeys {\n\t\tif !enc.keyExists(key) {\n\t\t\treturn\n\t\t}\n\t}\n\tenc.grow(10 + len(key))\n\tr := enc.getPreviousRune()\n\tif r != '{' {\n\t\tenc.writeByte(',')\n\t}\n\tenc.writeByte('\"')\n\tenc.writeStringEscape(key)\n\tenc.writeBytes(objKey)\n\tif v == 0 {\n\t\tenc.writeBytes(nullBytes)\n\t\treturn\n\t}\n\tenc.buf = strconv.AppendInt(enc.buf, v, 10)\n}\n\n// AddInt32 adds an int to be encoded, must be used inside a slice or array encoding (does not encode a key)\nfunc (enc *Encoder) AddInt32(v int32) {\n\tenc.Int64(int64(v))\n}\n\n// AddInt32OmitEmpty adds an int to be encoded and skips it if its value is 0,\n// must be used inside a slice or array encoding (does not encode a key).\nfunc (enc *Encoder) AddInt32OmitEmpty(v int32) {\n\tenc.Int64OmitEmpty(int64(v))\n}\n\n// AddInt32NullEmpty adds an int to be encoded and skips it if its value is 0,\n// must be used inside a slice or array encoding (does not encode a key).\nfunc (enc *Encoder) AddInt32NullEmpty(v int32) {\n\tenc.Int64NullEmpty(int64(v))\n}\n\n// Int32 adds an int to be encoded, must be used inside a slice or array encoding (does not encode a key)\nfunc (enc *Encoder) Int32(v int32) {\n\tenc.Int64(int64(v))\n}\n\n// Int32OmitEmpty adds an int to be encoded and skips it if its value is 0,\n// must be used inside a slice or array encoding (does not encode a key).\nfunc (enc *Encoder) Int32OmitEmpty(v int32) {\n\tenc.Int64OmitEmpty(int64(v))\n}\n\n// Int32NullEmpty adds an int to be encoded and skips it if its value is 0,\n// must be used inside a slice or array encoding (does not encode a key).\nfunc (enc *Encoder) Int32NullEmpty(v int32) {\n\tenc.Int64NullEmpty(int64(v))\n}\n\n// AddInt32Key adds an int32 to be encoded, must be used inside an object as it will encode a key\nfunc (enc *Encoder) AddInt32Key(key string, v int32) {\n\tenc.Int64Key(key, int64(v))\n}\n\n// AddInt32KeyOmitEmpty adds an int32 to be encoded and skips it if its value is 0.\n// Must be used inside an object as it will encode a key.\nfunc (enc *Encoder) AddInt32KeyOmitEmpty(key string, v int32) {\n\tenc.Int64KeyOmitEmpty(key, int64(v))\n}\n\n// Int32Key adds an int32 to be encoded, must be used inside an object as it will encode a key\nfunc (enc *Encoder) Int32Key(key string, v int32) {\n\tenc.Int64Key(key, int64(v))\n}\n\n// Int32KeyOmitEmpty adds an int32 to be encoded and skips it if its value is 0.\n// Must be used inside an object as it will encode a key.\nfunc (enc *Encoder) Int32KeyOmitEmpty(key string, v int32) {\n\tenc.Int64KeyOmitEmpty(key, int64(v))\n}\n\n// Int32KeyNullEmpty adds an int32 to be encoded and skips it if its value is 0.\n// Must be used inside an object as it will encode a key.\nfunc (enc *Encoder) Int32KeyNullEmpty(key string, v int32) {\n\tenc.Int64KeyNullEmpty(key, int64(v))\n}\n\n// AddInt16 adds an int to be encoded, must be used inside a slice or array encoding (does not encode a key)\nfunc (enc *Encoder) AddInt16(v int16) {\n\tenc.Int64(int64(v))\n}\n\n// AddInt16OmitEmpty adds an int to be encoded and skips it if its value is 0,\n// must be used inside a slice or array encoding (does not encode a key).\nfunc (enc *Encoder) AddInt16OmitEmpty(v int16) {\n\tenc.Int64OmitEmpty(int64(v))\n}\n\n// Int16 adds an int to be encoded, must be used inside a slice or array encoding (does not encode a key)\nfunc (enc *Encoder) Int16(v int16) {\n\tenc.Int64(int64(v))\n}\n\n// Int16OmitEmpty adds an int to be encoded and skips it if its value is 0,\n// must be used inside a slice or array encoding (does not encode a key).\nfunc (enc *Encoder) Int16OmitEmpty(v int16) {\n\tenc.Int64OmitEmpty(int64(v))\n}\n\n// Int16NullEmpty adds an int to be encoded and skips it if its value is 0,\n// must be used inside a slice or array encoding (does not encode a key).\nfunc (enc *Encoder) Int16NullEmpty(v int16) {\n\tenc.Int64NullEmpty(int64(v))\n}\n\n// AddInt16Key adds an int16 to be encoded, must be used inside an object as it will encode a key\nfunc (enc *Encoder) AddInt16Key(key string, v int16) {\n\tenc.Int64Key(key, int64(v))\n}\n\n// AddInt16KeyOmitEmpty adds an int16 to be encoded and skips it if its value is 0.\n// Must be used inside an object as it will encode a key.\nfunc (enc *Encoder) AddInt16KeyOmitEmpty(key string, v int16) {\n\tenc.Int64KeyOmitEmpty(key, int64(v))\n}\n\n// AddInt16KeyNullEmpty adds an int16 to be encoded and skips it if its value is 0.\n// Must be used inside an object as it will encode a key.\nfunc (enc *Encoder) AddInt16KeyNullEmpty(key string, v int16) {\n\tenc.Int64KeyNullEmpty(key, int64(v))\n}\n\n// Int16Key adds an int16 to be encoded, must be used inside an object as it will encode a key\nfunc (enc *Encoder) Int16Key(key string, v int16) {\n\tenc.Int64Key(key, int64(v))\n}\n\n// Int16KeyOmitEmpty adds an int16 to be encoded and skips it if its value is 0.\n// Must be used inside an object as it will encode a key.\nfunc (enc *Encoder) Int16KeyOmitEmpty(key string, v int16) {\n\tenc.Int64KeyOmitEmpty(key, int64(v))\n}\n\n// Int16KeyNullEmpty adds an int16 to be encoded and skips it if its value is 0.\n// Must be used inside an object as it will encode a key.\nfunc (enc *Encoder) Int16KeyNullEmpty(key string, v int16) {\n\tenc.Int64KeyNullEmpty(key, int64(v))\n}\n\n// AddInt8 adds an int to be encoded, must be used inside a slice or array encoding (does not encode a key)\nfunc (enc *Encoder) AddInt8(v int8) {\n\tenc.Int64(int64(v))\n}\n\n// AddInt8OmitEmpty adds an int to be encoded and skips it if its value is 0,\n// must be used inside a slice or array encoding (does not encode a key).\nfunc (enc *Encoder) AddInt8OmitEmpty(v int8) {\n\tenc.Int64OmitEmpty(int64(v))\n}\n\n// AddInt8NullEmpty adds an int to be encoded and skips it if its value is 0,\n// must be used inside a slice or array encoding (does not encode a key).\nfunc (enc *Encoder) AddInt8NullEmpty(v int8) {\n\tenc.Int64NullEmpty(int64(v))\n}\n\n// Int8 adds an int to be encoded, must be used inside a slice or array encoding (does not encode a key)\nfunc (enc *Encoder) Int8(v int8) {\n\tenc.Int64(int64(v))\n}\n\n// Int8OmitEmpty adds an int to be encoded and skips it if its value is 0,\n// must be used inside a slice or array encoding (does not encode a key).\nfunc (enc *Encoder) Int8OmitEmpty(v int8) {\n\tenc.Int64OmitEmpty(int64(v))\n}\n\n// Int8NullEmpty adds an int to be encoded and skips it if its value is 0,\n// must be used inside a slice or array encoding (does not encode a key).\nfunc (enc *Encoder) Int8NullEmpty(v int8) {\n\tenc.Int64NullEmpty(int64(v))\n}\n\n// AddInt8Key adds an int8 to be encoded, must be used inside an object as it will encode a key\nfunc (enc *Encoder) AddInt8Key(key string, v int8) {\n\tenc.Int64Key(key, int64(v))\n}\n\n// AddInt8KeyOmitEmpty adds an int8 to be encoded and skips it if its value is 0.\n// Must be used inside an object as it will encode a key.\nfunc (enc *Encoder) AddInt8KeyOmitEmpty(key string, v int8) {\n\tenc.Int64KeyOmitEmpty(key, int64(v))\n}\n\n// AddInt8KeyNullEmpty adds an int8 to be encoded and skips it if its value is 0.\n// Must be used inside an object as it will encode a key.\nfunc (enc *Encoder) AddInt8KeyNullEmpty(key string, v int8) {\n\tenc.Int64KeyNullEmpty(key, int64(v))\n}\n\n// Int8Key adds an int8 to be encoded, must be used inside an object as it will encode a key\nfunc (enc *Encoder) Int8Key(key string, v int8) {\n\tenc.Int64Key(key, int64(v))\n}\n\n// Int8KeyOmitEmpty adds an int8 to be encoded and skips it if its value is 0.\n// Must be used inside an object as it will encode a key.\nfunc (enc *Encoder) Int8KeyOmitEmpty(key string, v int8) {\n\tenc.Int64KeyOmitEmpty(key, int64(v))\n}\n\n// Int8KeyNullEmpty adds an int8 to be encoded and skips it if its value is 0.\n// Must be used inside an object as it will encode a key.\nfunc (enc *Encoder) Int8KeyNullEmpty(key string, v int8) {\n\tenc.Int64KeyNullEmpty(key, int64(v))\n}\n"
        },
        {
          "name": "encode_number_int_test.go",
          "type": "blob",
          "size": 18.5380859375,
          "content": "package gojay\n\nimport (\n\t\"math\"\n\t\"strings\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestEncoderInt64(t *testing.T) {\n\tvar testCasesBasic = []struct {\n\t\tname         string\n\t\tv            int64\n\t\texpectedJSON string\n\t}{\n\t\t{\n\t\t\tname:         \"basic\",\n\t\t\tv:            int64(1),\n\t\t\texpectedJSON: \"[1,1]\",\n\t\t},\n\t\t{\n\t\t\tname:         \"big\",\n\t\t\tv:            math.MaxInt64,\n\t\t\texpectedJSON: \"[9223372036854775807,9223372036854775807]\",\n\t\t},\n\t\t{\n\t\t\tname:         \"big\",\n\t\t\tv:            int64(0),\n\t\t\texpectedJSON: \"[0,0]\",\n\t\t},\n\t}\n\tfor _, testCase := range testCasesBasic {\n\t\tt.Run(testCase.name, func(t *testing.T) {\n\t\t\tvar b = &strings.Builder{}\n\t\t\tvar enc = NewEncoder(b)\n\t\t\tenc.Encode(EncodeArrayFunc(func(enc *Encoder) {\n\t\t\t\tenc.Int64(testCase.v)\n\t\t\t\tenc.AddInt64(testCase.v)\n\t\t\t}))\n\t\t\tassert.Equal(t, testCase.expectedJSON, b.String())\n\t\t})\n\t}\n\n\tvar testCasesOmitEmpty = []struct {\n\t\tname         string\n\t\tv            int64\n\t\texpectedJSON string\n\t}{\n\t\t{\n\t\t\tname:         \"basic\",\n\t\t\tv:            int64(1),\n\t\t\texpectedJSON: \"[1,1]\",\n\t\t},\n\t\t{\n\t\t\tname:         \"big\",\n\t\t\tv:            math.MaxInt64,\n\t\t\texpectedJSON: \"[9223372036854775807,9223372036854775807]\",\n\t\t},\n\t\t{\n\t\t\tname:         \"big\",\n\t\t\tv:            int64(0),\n\t\t\texpectedJSON: \"[]\",\n\t\t},\n\t}\n\tfor _, testCase := range testCasesOmitEmpty {\n\t\tt.Run(testCase.name, func(t *testing.T) {\n\t\t\tvar b = &strings.Builder{}\n\t\t\tvar enc = NewEncoder(b)\n\t\t\tenc.Encode(EncodeArrayFunc(func(enc *Encoder) {\n\t\t\t\tenc.Int64OmitEmpty(testCase.v)\n\t\t\t\tenc.AddInt64OmitEmpty(testCase.v)\n\t\t\t}))\n\t\t\tassert.Equal(t, testCase.expectedJSON, b.String())\n\t\t})\n\t}\n\tvar testCasesKeyBasic = []struct {\n\t\tname         string\n\t\tv            int64\n\t\texpectedJSON string\n\t}{\n\t\t{\n\t\t\tname:         \"basic\",\n\t\t\tv:            int64(1),\n\t\t\texpectedJSON: `{\"foo\":1,\"bar\":1}`,\n\t\t},\n\t\t{\n\t\t\tname:         \"big\",\n\t\t\tv:            math.MaxInt64,\n\t\t\texpectedJSON: `{\"foo\":9223372036854775807,\"bar\":9223372036854775807}`,\n\t\t},\n\t\t{\n\t\t\tname:         \"big\",\n\t\t\tv:            int64(0),\n\t\t\texpectedJSON: `{\"foo\":0,\"bar\":0}`,\n\t\t},\n\t}\n\tfor _, testCase := range testCasesKeyBasic {\n\t\tt.Run(testCase.name, func(t *testing.T) {\n\t\t\tvar b = &strings.Builder{}\n\t\t\tvar enc = NewEncoder(b)\n\t\t\tenc.Encode(EncodeObjectFunc(func(enc *Encoder) {\n\t\t\t\tenc.Int64Key(\"foo\", testCase.v)\n\t\t\t\tenc.AddInt64Key(\"bar\", testCase.v)\n\t\t\t}))\n\t\t\tassert.Equal(t, testCase.expectedJSON, b.String())\n\t\t})\n\t}\n\n\tvar testCasesKeyOmitEmpty = []struct {\n\t\tname         string\n\t\tv            int64\n\t\texpectedJSON string\n\t}{\n\t\t{\n\t\t\tname:         \"basic\",\n\t\t\tv:            int64(1),\n\t\t\texpectedJSON: `{\"foo\":1,\"bar\":1}`,\n\t\t},\n\t\t{\n\t\t\tname:         \"big\",\n\t\t\tv:            math.MaxInt64,\n\t\t\texpectedJSON: `{\"foo\":9223372036854775807,\"bar\":9223372036854775807}`,\n\t\t},\n\t\t{\n\t\t\tname:         \"big\",\n\t\t\tv:            int64(0),\n\t\t\texpectedJSON: `{}`,\n\t\t},\n\t}\n\tfor _, testCase := range testCasesKeyOmitEmpty {\n\t\tt.Run(testCase.name, func(t *testing.T) {\n\t\t\tvar b = &strings.Builder{}\n\t\t\tvar enc = NewEncoder(b)\n\t\t\tenc.Encode(EncodeObjectFunc(func(enc *Encoder) {\n\t\t\t\tenc.Int64KeyOmitEmpty(\"foo\", testCase.v)\n\t\t\t\tenc.AddInt64KeyOmitEmpty(\"bar\", testCase.v)\n\t\t\t}))\n\t\t\tassert.Equal(t, testCase.expectedJSON, b.String())\n\t\t})\n\t}\n}\n\nfunc TestEncoderInt32(t *testing.T) {\n\tvar testCasesBasic = []struct {\n\t\tname         string\n\t\tv            int32\n\t\texpectedJSON string\n\t}{\n\t\t{\n\t\t\tname:         \"basic\",\n\t\t\tv:            int32(1),\n\t\t\texpectedJSON: \"[1,1]\",\n\t\t},\n\t\t{\n\t\t\tname:         \"big\",\n\t\t\tv:            math.MaxInt32,\n\t\t\texpectedJSON: \"[2147483647,2147483647]\",\n\t\t},\n\t\t{\n\t\t\tname:         \"big\",\n\t\t\tv:            int32(0),\n\t\t\texpectedJSON: \"[0,0]\",\n\t\t},\n\t}\n\tfor _, testCase := range testCasesBasic {\n\t\tt.Run(testCase.name, func(t *testing.T) {\n\t\t\tvar b = &strings.Builder{}\n\t\t\tvar enc = NewEncoder(b)\n\t\t\tenc.Encode(EncodeArrayFunc(func(enc *Encoder) {\n\t\t\t\tenc.Int32(testCase.v)\n\t\t\t\tenc.AddInt32(testCase.v)\n\t\t\t}))\n\t\t\tassert.Equal(t, testCase.expectedJSON, b.String())\n\t\t})\n\t}\n\tvar testCasesOmitEmpty = []struct {\n\t\tname         string\n\t\tv            int32\n\t\texpectedJSON string\n\t}{\n\t\t{\n\t\t\tname:         \"basic\",\n\t\t\tv:            int32(1),\n\t\t\texpectedJSON: \"[1,1]\",\n\t\t},\n\t\t{\n\t\t\tname:         \"big\",\n\t\t\tv:            math.MaxInt32,\n\t\t\texpectedJSON: \"[2147483647,2147483647]\",\n\t\t},\n\t\t{\n\t\t\tname:         \"big\",\n\t\t\tv:            int32(0),\n\t\t\texpectedJSON: \"[]\",\n\t\t},\n\t}\n\tfor _, testCase := range testCasesOmitEmpty {\n\t\tt.Run(testCase.name, func(t *testing.T) {\n\t\t\tvar b = &strings.Builder{}\n\t\t\tvar enc = NewEncoder(b)\n\t\t\tenc.Encode(EncodeArrayFunc(func(enc *Encoder) {\n\t\t\t\tenc.Int32OmitEmpty(testCase.v)\n\t\t\t\tenc.AddInt32OmitEmpty(testCase.v)\n\t\t\t}))\n\t\t\tassert.Equal(t, testCase.expectedJSON, b.String())\n\t\t})\n\t}\n\tvar testCasesKeyBasic = []struct {\n\t\tname         string\n\t\tv            int32\n\t\texpectedJSON string\n\t}{\n\t\t{\n\t\t\tname:         \"basic\",\n\t\t\tv:            int32(1),\n\t\t\texpectedJSON: `{\"foo\":1,\"bar\":1}`,\n\t\t},\n\t\t{\n\t\t\tname:         \"big\",\n\t\t\tv:            math.MaxInt32,\n\t\t\texpectedJSON: `{\"foo\":2147483647,\"bar\":2147483647}`,\n\t\t},\n\t\t{\n\t\t\tname:         \"big\",\n\t\t\tv:            int32(0),\n\t\t\texpectedJSON: `{\"foo\":0,\"bar\":0}`,\n\t\t},\n\t}\n\tfor _, testCase := range testCasesKeyBasic {\n\t\tt.Run(testCase.name, func(t *testing.T) {\n\t\t\tvar b = &strings.Builder{}\n\t\t\tvar enc = NewEncoder(b)\n\t\t\tenc.Encode(EncodeObjectFunc(func(enc *Encoder) {\n\t\t\t\tenc.Int32Key(\"foo\", testCase.v)\n\t\t\t\tenc.AddInt32Key(\"bar\", testCase.v)\n\t\t\t}))\n\t\t\tassert.Equal(t, testCase.expectedJSON, b.String())\n\t\t})\n\t}\n\n\tvar testCasesKeyOmitEmpty = []struct {\n\t\tname         string\n\t\tv            int32\n\t\texpectedJSON string\n\t}{\n\t\t{\n\t\t\tname:         \"basic\",\n\t\t\tv:            int32(1),\n\t\t\texpectedJSON: `{\"foo\":1,\"bar\":1}`,\n\t\t},\n\t\t{\n\t\t\tname:         \"big\",\n\t\t\tv:            math.MaxInt32,\n\t\t\texpectedJSON: `{\"foo\":2147483647,\"bar\":2147483647}`,\n\t\t},\n\t\t{\n\t\t\tname:         \"big\",\n\t\t\tv:            int32(0),\n\t\t\texpectedJSON: `{}`,\n\t\t},\n\t}\n\tfor _, testCase := range testCasesKeyOmitEmpty {\n\t\tt.Run(testCase.name, func(t *testing.T) {\n\t\t\tvar b = &strings.Builder{}\n\t\t\tvar enc = NewEncoder(b)\n\t\t\tenc.Encode(EncodeObjectFunc(func(enc *Encoder) {\n\t\t\t\tenc.Int32KeyOmitEmpty(\"foo\", testCase.v)\n\t\t\t\tenc.AddInt32KeyOmitEmpty(\"bar\", testCase.v)\n\t\t\t}))\n\t\t\tassert.Equal(t, testCase.expectedJSON, b.String())\n\t\t})\n\t}\n}\n\nfunc TestEncoderInt16(t *testing.T) {\n\tvar testCasesBasic = []struct {\n\t\tname         string\n\t\tv            int16\n\t\texpectedJSON string\n\t}{\n\t\t{\n\t\t\tname:         \"basic\",\n\t\t\tv:            int16(1),\n\t\t\texpectedJSON: \"[1,1]\",\n\t\t},\n\t\t{\n\t\t\tname:         \"big\",\n\t\t\tv:            math.MaxInt16,\n\t\t\texpectedJSON: \"[32767,32767]\",\n\t\t},\n\t\t{\n\t\t\tname:         \"big\",\n\t\t\tv:            int16(0),\n\t\t\texpectedJSON: \"[0,0]\",\n\t\t},\n\t}\n\tfor _, testCase := range testCasesBasic {\n\t\tt.Run(testCase.name, func(t *testing.T) {\n\t\t\tvar b = &strings.Builder{}\n\t\t\tvar enc = NewEncoder(b)\n\t\t\tenc.Encode(EncodeArrayFunc(func(enc *Encoder) {\n\t\t\t\tenc.Int16(testCase.v)\n\t\t\t\tenc.AddInt16(testCase.v)\n\t\t\t}))\n\t\t\tassert.Equal(t, testCase.expectedJSON, b.String())\n\t\t})\n\t}\n\tvar testCasesOmitEmpty = []struct {\n\t\tname         string\n\t\tv            int16\n\t\texpectedJSON string\n\t}{\n\t\t{\n\t\t\tname:         \"basic\",\n\t\t\tv:            int16(1),\n\t\t\texpectedJSON: \"[1,1]\",\n\t\t},\n\t\t{\n\t\t\tname:         \"big\",\n\t\t\tv:            math.MaxInt16,\n\t\t\texpectedJSON: \"[32767,32767]\",\n\t\t},\n\t\t{\n\t\t\tname:         \"big\",\n\t\t\tv:            int16(0),\n\t\t\texpectedJSON: \"[]\",\n\t\t},\n\t}\n\tfor _, testCase := range testCasesOmitEmpty {\n\t\tt.Run(testCase.name, func(t *testing.T) {\n\t\t\tvar b = &strings.Builder{}\n\t\t\tvar enc = NewEncoder(b)\n\t\t\tenc.Encode(EncodeArrayFunc(func(enc *Encoder) {\n\t\t\t\tenc.Int16OmitEmpty(testCase.v)\n\t\t\t\tenc.AddInt16OmitEmpty(testCase.v)\n\t\t\t}))\n\t\t\tassert.Equal(t, testCase.expectedJSON, b.String())\n\t\t})\n\t}\n\tvar testCasesKeyBasic = []struct {\n\t\tname         string\n\t\tv            int16\n\t\texpectedJSON string\n\t}{\n\t\t{\n\t\t\tname:         \"basic\",\n\t\t\tv:            int16(1),\n\t\t\texpectedJSON: `{\"foo\":1,\"bar\":1}`,\n\t\t},\n\t\t{\n\t\t\tname:         \"big\",\n\t\t\tv:            math.MaxInt16,\n\t\t\texpectedJSON: `{\"foo\":32767,\"bar\":32767}`,\n\t\t},\n\t\t{\n\t\t\tname:         \"big\",\n\t\t\tv:            int16(0),\n\t\t\texpectedJSON: `{\"foo\":0,\"bar\":0}`,\n\t\t},\n\t}\n\tfor _, testCase := range testCasesKeyBasic {\n\t\tt.Run(testCase.name, func(t *testing.T) {\n\t\t\tvar b = &strings.Builder{}\n\t\t\tvar enc = NewEncoder(b)\n\t\t\tenc.Encode(EncodeObjectFunc(func(enc *Encoder) {\n\t\t\t\tenc.Int16Key(\"foo\", testCase.v)\n\t\t\t\tenc.AddInt16Key(\"bar\", testCase.v)\n\t\t\t}))\n\t\t\tassert.Equal(t, testCase.expectedJSON, b.String())\n\t\t})\n\t}\n\n\tvar testCasesKeyOmitEmpty = []struct {\n\t\tname         string\n\t\tv            int16\n\t\texpectedJSON string\n\t}{\n\t\t{\n\t\t\tname:         \"basic\",\n\t\t\tv:            int16(1),\n\t\t\texpectedJSON: `{\"foo\":1,\"bar\":1}`,\n\t\t},\n\t\t{\n\t\t\tname:         \"big\",\n\t\t\tv:            math.MaxInt16,\n\t\t\texpectedJSON: `{\"foo\":32767,\"bar\":32767}`,\n\t\t},\n\t\t{\n\t\t\tname:         \"big\",\n\t\t\tv:            int16(0),\n\t\t\texpectedJSON: `{}`,\n\t\t},\n\t}\n\tfor _, testCase := range testCasesKeyOmitEmpty {\n\t\tt.Run(testCase.name, func(t *testing.T) {\n\t\t\tvar b = &strings.Builder{}\n\t\t\tvar enc = NewEncoder(b)\n\t\t\tenc.Encode(EncodeObjectFunc(func(enc *Encoder) {\n\t\t\t\tenc.Int16KeyOmitEmpty(\"foo\", testCase.v)\n\t\t\t\tenc.AddInt16KeyOmitEmpty(\"bar\", testCase.v)\n\t\t\t}))\n\t\t\tassert.Equal(t, testCase.expectedJSON, b.String())\n\t\t})\n\t}\n}\n\nfunc TestEncoderInt8(t *testing.T) {\n\tvar testCasesBasic = []struct {\n\t\tname         string\n\t\tv            int8\n\t\texpectedJSON string\n\t}{\n\t\t{\n\t\t\tname:         \"basic\",\n\t\t\tv:            int8(1),\n\t\t\texpectedJSON: \"[1,1]\",\n\t\t},\n\t\t{\n\t\t\tname:         \"big\",\n\t\t\tv:            math.MaxInt8,\n\t\t\texpectedJSON: \"[127,127]\",\n\t\t},\n\t\t{\n\t\t\tname:         \"big\",\n\t\t\tv:            int8(0),\n\t\t\texpectedJSON: \"[0,0]\",\n\t\t},\n\t}\n\tfor _, testCase := range testCasesBasic {\n\t\tt.Run(testCase.name, func(t *testing.T) {\n\t\t\tvar b = &strings.Builder{}\n\t\t\tvar enc = NewEncoder(b)\n\t\t\tenc.Encode(EncodeArrayFunc(func(enc *Encoder) {\n\t\t\t\tenc.Int8(testCase.v)\n\t\t\t\tenc.AddInt8(testCase.v)\n\t\t\t}))\n\t\t\tassert.Equal(t, testCase.expectedJSON, b.String())\n\t\t})\n\t}\n\tvar testCasesOmitEmpty = []struct {\n\t\tname         string\n\t\tv            int8\n\t\texpectedJSON string\n\t}{\n\t\t{\n\t\t\tname:         \"basic\",\n\t\t\tv:            int8(1),\n\t\t\texpectedJSON: \"[1,1]\",\n\t\t},\n\t\t{\n\t\t\tname:         \"big\",\n\t\t\tv:            math.MaxInt8,\n\t\t\texpectedJSON: \"[127,127]\",\n\t\t},\n\t\t{\n\t\t\tname:         \"big\",\n\t\t\tv:            int8(0),\n\t\t\texpectedJSON: \"[]\",\n\t\t},\n\t}\n\tfor _, testCase := range testCasesOmitEmpty {\n\t\tt.Run(testCase.name, func(t *testing.T) {\n\t\t\tvar b = &strings.Builder{}\n\t\t\tvar enc = NewEncoder(b)\n\t\t\tenc.Encode(EncodeArrayFunc(func(enc *Encoder) {\n\t\t\t\tenc.Int8OmitEmpty(testCase.v)\n\t\t\t\tenc.AddInt8OmitEmpty(testCase.v)\n\t\t\t}))\n\t\t\tassert.Equal(t, testCase.expectedJSON, b.String())\n\t\t})\n\t}\n\tvar testCasesKeyBasic = []struct {\n\t\tname         string\n\t\tv            int8\n\t\texpectedJSON string\n\t}{\n\t\t{\n\t\t\tname:         \"basic\",\n\t\t\tv:            int8(1),\n\t\t\texpectedJSON: `{\"foo\":1,\"bar\":1}`,\n\t\t},\n\t\t{\n\t\t\tname:         \"big\",\n\t\t\tv:            math.MaxInt8,\n\t\t\texpectedJSON: `{\"foo\":127,\"bar\":127}`,\n\t\t},\n\t\t{\n\t\t\tname:         \"big\",\n\t\t\tv:            int8(0),\n\t\t\texpectedJSON: `{\"foo\":0,\"bar\":0}`,\n\t\t},\n\t}\n\tfor _, testCase := range testCasesKeyBasic {\n\t\tt.Run(testCase.name, func(t *testing.T) {\n\t\t\tvar b = &strings.Builder{}\n\t\t\tvar enc = NewEncoder(b)\n\t\t\tenc.Encode(EncodeObjectFunc(func(enc *Encoder) {\n\t\t\t\tenc.Int8Key(\"foo\", testCase.v)\n\t\t\t\tenc.AddInt8Key(\"bar\", testCase.v)\n\t\t\t}))\n\t\t\tassert.Equal(t, testCase.expectedJSON, b.String())\n\t\t})\n\t}\n\n\tvar testCasesKeyOmitEmpty = []struct {\n\t\tname         string\n\t\tv            int8\n\t\texpectedJSON string\n\t}{\n\t\t{\n\t\t\tname:         \"basic\",\n\t\t\tv:            int8(1),\n\t\t\texpectedJSON: `{\"foo\":1,\"bar\":1}`,\n\t\t},\n\t\t{\n\t\t\tname:         \"big\",\n\t\t\tv:            math.MaxInt8,\n\t\t\texpectedJSON: `{\"foo\":127,\"bar\":127}`,\n\t\t},\n\t\t{\n\t\t\tname:         \"big\",\n\t\t\tv:            int8(0),\n\t\t\texpectedJSON: `{}`,\n\t\t},\n\t}\n\tfor _, testCase := range testCasesKeyOmitEmpty {\n\t\tt.Run(testCase.name, func(t *testing.T) {\n\t\t\tvar b = &strings.Builder{}\n\t\t\tvar enc = NewEncoder(b)\n\t\t\tenc.Encode(EncodeObjectFunc(func(enc *Encoder) {\n\t\t\t\tenc.Int8KeyOmitEmpty(\"foo\", testCase.v)\n\t\t\t\tenc.AddInt8KeyOmitEmpty(\"bar\", testCase.v)\n\t\t\t}))\n\t\t\tassert.Equal(t, testCase.expectedJSON, b.String())\n\t\t})\n\t}\n}\n\nfunc TestEncoderIntNullEmpty(t *testing.T) {\n\tvar testCases = []struct {\n\t\tname         string\n\t\tbaseJSON     string\n\t\texpectedJSON string\n\t}{\n\t\t{\n\t\t\tname:         \"basic 1st elem\",\n\t\t\tbaseJSON:     \"[\",\n\t\t\texpectedJSON: `[null,1`,\n\t\t},\n\t\t{\n\t\t\tname:         \"basic 2nd elem\",\n\t\t\tbaseJSON:     `[\"test\"`,\n\t\t\texpectedJSON: `[\"test\",null,1`,\n\t\t},\n\t}\n\tfor _, testCase := range testCases {\n\t\tt.Run(\"true\", func(t *testing.T) {\n\t\t\tvar b strings.Builder\n\t\t\tvar enc = NewEncoder(&b)\n\t\t\tenc.writeString(testCase.baseJSON)\n\t\t\tenc.IntNullEmpty(0)\n\t\t\tenc.AddIntNullEmpty(1)\n\t\t\tenc.Write()\n\t\t\tassert.Equal(t, testCase.expectedJSON, b.String())\n\t\t})\n\t}\n}\n\nfunc TestEncoderIntKeyNullEmpty(t *testing.T) {\n\tvar testCases = []struct {\n\t\tname         string\n\t\tbaseJSON     string\n\t\texpectedJSON string\n\t}{\n\t\t{\n\t\t\tname:         \"basic 1st elem\",\n\t\t\tbaseJSON:     \"{\",\n\t\t\texpectedJSON: `{\"foo\":null,\"bar\":1`,\n\t\t},\n\t\t{\n\t\t\tname:         \"basic 2nd elem\",\n\t\t\tbaseJSON:     `{\"test\":\"test\"`,\n\t\t\texpectedJSON: `{\"test\":\"test\",\"foo\":null,\"bar\":1`,\n\t\t},\n\t}\n\tfor _, testCase := range testCases {\n\t\tt.Run(testCase.name, func(t *testing.T) {\n\t\t\tvar b strings.Builder\n\t\t\tvar enc = NewEncoder(&b)\n\t\t\tenc.writeString(testCase.baseJSON)\n\t\t\tenc.IntKeyNullEmpty(\"foo\", 0)\n\t\t\tenc.AddIntKeyNullEmpty(\"bar\", 1)\n\t\t\tenc.Write()\n\t\t\tassert.Equal(t, testCase.expectedJSON, b.String())\n\t\t})\n\t}\n}\n\nfunc TestEncoderInt64NullEmpty(t *testing.T) {\n\tvar testCases = []struct {\n\t\tname         string\n\t\tbaseJSON     string\n\t\texpectedJSON string\n\t}{\n\t\t{\n\t\t\tname:         \"basic 1st elem\",\n\t\t\tbaseJSON:     \"[\",\n\t\t\texpectedJSON: `[null,1`,\n\t\t},\n\t\t{\n\t\t\tname:         \"basic 2nd elem\",\n\t\t\tbaseJSON:     `[\"test\"`,\n\t\t\texpectedJSON: `[\"test\",null,1`,\n\t\t},\n\t}\n\tfor _, testCase := range testCases {\n\t\tt.Run(\"true\", func(t *testing.T) {\n\t\t\tvar b strings.Builder\n\t\t\tvar enc = NewEncoder(&b)\n\t\t\tenc.writeString(testCase.baseJSON)\n\t\t\tenc.Int64NullEmpty(0)\n\t\t\tenc.AddInt64NullEmpty(1)\n\t\t\tenc.Write()\n\t\t\tassert.Equal(t, testCase.expectedJSON, b.String())\n\t\t})\n\t}\n}\n\nfunc TestEncoderInt64KeyNullEmpty(t *testing.T) {\n\tvar testCases = []struct {\n\t\tname         string\n\t\tbaseJSON     string\n\t\texpectedJSON string\n\t}{\n\t\t{\n\t\t\tname:         \"basic 1st elem\",\n\t\t\tbaseJSON:     \"{\",\n\t\t\texpectedJSON: `{\"foo\":null,\"bar\":1`,\n\t\t},\n\t\t{\n\t\t\tname:         \"basic 2nd elem\",\n\t\t\tbaseJSON:     `{\"test\":\"test\"`,\n\t\t\texpectedJSON: `{\"test\":\"test\",\"foo\":null,\"bar\":1`,\n\t\t},\n\t}\n\tfor _, testCase := range testCases {\n\t\tt.Run(testCase.name, func(t *testing.T) {\n\t\t\tvar b strings.Builder\n\t\t\tvar enc = NewEncoder(&b)\n\t\t\tenc.writeString(testCase.baseJSON)\n\t\t\tenc.Int64KeyNullEmpty(\"foo\", 0)\n\t\t\tenc.AddInt64KeyNullEmpty(\"bar\", 1)\n\t\t\tenc.Write()\n\t\t\tassert.Equal(t, testCase.expectedJSON, b.String())\n\t\t})\n\t}\n}\n\nfunc TestEncoderInt32NullEmpty(t *testing.T) {\n\tvar testCases = []struct {\n\t\tname         string\n\t\tbaseJSON     string\n\t\texpectedJSON string\n\t}{\n\t\t{\n\t\t\tname:         \"basic 1st elem\",\n\t\t\tbaseJSON:     \"[\",\n\t\t\texpectedJSON: `[null,1`,\n\t\t},\n\t\t{\n\t\t\tname:         \"basic 2nd elem\",\n\t\t\tbaseJSON:     `[\"test\"`,\n\t\t\texpectedJSON: `[\"test\",null,1`,\n\t\t},\n\t}\n\tfor _, testCase := range testCases {\n\t\tt.Run(\"true\", func(t *testing.T) {\n\t\t\tvar b strings.Builder\n\t\t\tvar enc = NewEncoder(&b)\n\t\t\tenc.writeString(testCase.baseJSON)\n\t\t\tenc.Int32NullEmpty(0)\n\t\t\tenc.AddInt32NullEmpty(1)\n\t\t\tenc.Write()\n\t\t\tassert.Equal(t, testCase.expectedJSON, b.String())\n\t\t})\n\t}\n}\n\nfunc TestEncoderInt32KeyNullEmpty(t *testing.T) {\n\tvar testCases = []struct {\n\t\tname         string\n\t\tbaseJSON     string\n\t\texpectedJSON string\n\t}{\n\t\t{\n\t\t\tname:         \"basic 1st elem\",\n\t\t\tbaseJSON:     \"{\",\n\t\t\texpectedJSON: `{\"foo\":null,\"bar\":1`,\n\t\t},\n\t\t{\n\t\t\tname:         \"basic 2nd elem\",\n\t\t\tbaseJSON:     `{\"test\":\"test\"`,\n\t\t\texpectedJSON: `{\"test\":\"test\",\"foo\":null,\"bar\":1`,\n\t\t},\n\t}\n\tfor _, testCase := range testCases {\n\t\tt.Run(testCase.name, func(t *testing.T) {\n\t\t\tvar b strings.Builder\n\t\t\tvar enc = NewEncoder(&b)\n\t\t\tenc.writeString(testCase.baseJSON)\n\t\t\tenc.Int32KeyNullEmpty(\"foo\", 0)\n\t\t\tenc.Int32KeyNullEmpty(\"bar\", int32(1))\n\t\t\tenc.Write()\n\t\t\tassert.Equal(t, testCase.expectedJSON, b.String())\n\t\t})\n\t}\n}\n\nfunc TestEncoderInt16NullEmpty(t *testing.T) {\n\tvar testCases = []struct {\n\t\tname         string\n\t\tbaseJSON     string\n\t\texpectedJSON string\n\t}{\n\t\t{\n\t\t\tname:         \"basic 1st elem\",\n\t\t\tbaseJSON:     \"[\",\n\t\t\texpectedJSON: `[null,1`,\n\t\t},\n\t\t{\n\t\t\tname:         \"basic 2nd elem\",\n\t\t\tbaseJSON:     `[\"test\"`,\n\t\t\texpectedJSON: `[\"test\",null,1`,\n\t\t},\n\t}\n\tfor _, testCase := range testCases {\n\t\tt.Run(\"true\", func(t *testing.T) {\n\t\t\tvar b strings.Builder\n\t\t\tvar enc = NewEncoder(&b)\n\t\t\tenc.writeString(testCase.baseJSON)\n\t\t\tenc.Int16NullEmpty(0)\n\t\t\tenc.Int16NullEmpty(1)\n\t\t\tenc.Write()\n\t\t\tassert.Equal(t, testCase.expectedJSON, b.String())\n\t\t})\n\t}\n}\n\nfunc TestEncoderInt16KeyNullEmpty(t *testing.T) {\n\tvar testCases = []struct {\n\t\tname         string\n\t\tbaseJSON     string\n\t\texpectedJSON string\n\t}{\n\t\t{\n\t\t\tname:         \"basic 1st elem\",\n\t\t\tbaseJSON:     \"{\",\n\t\t\texpectedJSON: `{\"foo\":null,\"bar\":1`,\n\t\t},\n\t\t{\n\t\t\tname:         \"basic 2nd elem\",\n\t\t\tbaseJSON:     `{\"test\":\"test\"`,\n\t\t\texpectedJSON: `{\"test\":\"test\",\"foo\":null,\"bar\":1`,\n\t\t},\n\t}\n\tfor _, testCase := range testCases {\n\t\tt.Run(testCase.name, func(t *testing.T) {\n\t\t\tvar b strings.Builder\n\t\t\tvar enc = NewEncoder(&b)\n\t\t\tenc.writeString(testCase.baseJSON)\n\t\t\tenc.AddInt16KeyNullEmpty(\"foo\", 0)\n\t\t\tenc.Int16KeyNullEmpty(\"bar\", int16(1))\n\t\t\tenc.Write()\n\t\t\tassert.Equal(t, testCase.expectedJSON, b.String())\n\t\t})\n\t}\n}\n\nfunc TestEncoderInt8NullEmpty(t *testing.T) {\n\tvar testCases = []struct {\n\t\tname         string\n\t\tbaseJSON     string\n\t\texpectedJSON string\n\t}{\n\t\t{\n\t\t\tname:         \"basic 1st elem\",\n\t\t\tbaseJSON:     \"[\",\n\t\t\texpectedJSON: `[null,1`,\n\t\t},\n\t\t{\n\t\t\tname:         \"basic 2nd elem\",\n\t\t\tbaseJSON:     `[\"test\"`,\n\t\t\texpectedJSON: `[\"test\",null,1`,\n\t\t},\n\t}\n\tfor _, testCase := range testCases {\n\t\tt.Run(\"true\", func(t *testing.T) {\n\t\t\tvar b strings.Builder\n\t\t\tvar enc = NewEncoder(&b)\n\t\t\tenc.writeString(testCase.baseJSON)\n\t\t\tenc.AddInt8NullEmpty(0)\n\t\t\tenc.Int8NullEmpty(1)\n\t\t\tenc.Write()\n\t\t\tassert.Equal(t, testCase.expectedJSON, b.String())\n\t\t})\n\t}\n}\n\nfunc TestEncoderInt8KeyNullEmpty(t *testing.T) {\n\tvar testCases = []struct {\n\t\tname         string\n\t\tbaseJSON     string\n\t\texpectedJSON string\n\t}{\n\t\t{\n\t\t\tname:         \"basic 1st elem\",\n\t\t\tbaseJSON:     \"{\",\n\t\t\texpectedJSON: `{\"foo\":null,\"bar\":1`,\n\t\t},\n\t\t{\n\t\t\tname:         \"basic 2nd elem\",\n\t\t\tbaseJSON:     `{\"test\":\"test\"`,\n\t\t\texpectedJSON: `{\"test\":\"test\",\"foo\":null,\"bar\":1`,\n\t\t},\n\t}\n\tfor _, testCase := range testCases {\n\t\tt.Run(testCase.name, func(t *testing.T) {\n\t\t\tvar b strings.Builder\n\t\t\tvar enc = NewEncoder(&b)\n\t\t\tenc.writeString(testCase.baseJSON)\n\t\t\tenc.AddInt8KeyNullEmpty(\"foo\", 0)\n\t\t\tenc.Int8KeyNullEmpty(\"bar\", int8(1))\n\t\t\tenc.Write()\n\t\t\tassert.Equal(t, testCase.expectedJSON, b.String())\n\t\t})\n\t}\n}\n"
        },
        {
          "name": "encode_number_test.go",
          "type": "blob",
          "size": 14.52734375,
          "content": "package gojay\n\nimport (\n\t\"strings\"\n\t\"testing\"\n\n\t\"fmt\"\n\t\"math\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestEncoderNumberEncodeAPI(t *testing.T) {\n\tt.Run(\"encoder-int\", func(t *testing.T) {\n\t\tbuilder := &strings.Builder{}\n\t\tenc := NewEncoder(builder)\n\t\terr := enc.EncodeInt(1)\n\t\tassert.Nil(t, err, \"Error should be nil\")\n\t\tassert.Equal(\n\t\t\tt,\n\t\t\t`1`,\n\t\t\tbuilder.String(),\n\t\t\t\"Result of marshalling is different as the one expected\")\n\t})\n\tt.Run(\"encode-int64\", func(t *testing.T) {\n\t\tbuilder := &strings.Builder{}\n\t\tenc := NewEncoder(builder)\n\t\terr := enc.EncodeInt64(math.MaxInt64)\n\t\tassert.Nil(t, err, \"Error should be nil\")\n\t\tassert.Equal(\n\t\t\tt,\n\t\t\tfmt.Sprintf(\"%d\", math.MaxInt64),\n\t\t\tbuilder.String(),\n\t\t\t\"Result of marshalling is different as the one expected\")\n\t})\n\tt.Run(\"encode-uint64\", func(t *testing.T) {\n\t\tbuilder := &strings.Builder{}\n\t\tenc := NewEncoder(builder)\n\t\terr := enc.EncodeUint64(uint64(math.MaxUint64))\n\t\tassert.Nil(t, err, \"Error should be nil\")\n\t\tassert.Equal(\n\t\t\tt,\n\t\t\tfmt.Sprintf(\"%d\", uint64(math.MaxUint64)),\n\t\t\tbuilder.String(),\n\t\t\t\"Result of marshalling is different as the one expected\")\n\t})\n\tt.Run(\"encode-float64\", func(t *testing.T) {\n\t\tbuilder := &strings.Builder{}\n\t\tenc := NewEncoder(builder)\n\t\terr := enc.EncodeFloat(float64(1.1))\n\t\tassert.Nil(t, err, \"Error should be nil\")\n\t\tassert.Equal(\n\t\t\tt,\n\t\t\t`1.1`,\n\t\t\tbuilder.String(),\n\t\t\t\"Result of marshalling is different as the one expected\")\n\t})\n\tt.Run(\"encode-float32\", func(t *testing.T) {\n\t\tbuilder := &strings.Builder{}\n\t\tenc := NewEncoder(builder)\n\t\terr := enc.EncodeFloat32(float32(1.12))\n\t\tassert.Nil(t, err, \"Error should be nil\")\n\t\tassert.Equal(\n\t\t\tt,\n\t\t\t`1.12`,\n\t\t\tbuilder.String(),\n\t\t\t\"Result of marshalling is different as the one expected\")\n\n\t})\n}\n\nfunc TestEncoderNumberEncodeAPIErrors(t *testing.T) {\n\tt.Run(\"encode-int-pool-error\", func(t *testing.T) {\n\t\tbuilder := &strings.Builder{}\n\t\tenc := NewEncoder(builder)\n\t\tenc.isPooled = 1\n\t\tdefer func() {\n\t\t\terr := recover()\n\t\t\tassert.NotNil(t, err, \"err should not be nil\")\n\t\t\tassert.IsType(t, InvalidUsagePooledEncoderError(\"\"), err, \"err should be of type InvalidUsagePooledEncoderError\")\n\t\t}()\n\t\t_ = enc.EncodeInt(1)\n\t\tassert.True(t, false, \"should not be called as encoder should have panicked\")\n\t})\n\tt.Run(\"encode-int-write-error\", func(t *testing.T) {\n\t\tw := TestWriterError(\"\")\n\t\tenc := NewEncoder(w)\n\t\terr := enc.EncodeInt(1)\n\t\tassert.NotNil(t, err, \"err should not be nil\")\n\t\tassert.Equal(t, \"Test Error\", err.Error(), \"err should be of type InvalidUsagePooledEncoderError\")\n\t})\n\tt.Run(\"encode-int64-pool-error\", func(t *testing.T) {\n\t\tbuilder := &strings.Builder{}\n\t\tenc := NewEncoder(builder)\n\t\tenc.isPooled = 1\n\t\tdefer func() {\n\t\t\terr := recover()\n\t\t\tassert.NotNil(t, err, \"err should not be nil\")\n\t\t\tassert.IsType(t, InvalidUsagePooledEncoderError(\"\"), err, \"err should be of type InvalidUsagePooledEncoderError\")\n\t\t}()\n\t\t_ = enc.EncodeInt64(1)\n\t\tassert.True(t, false, \"should not be called as encoder should have panicked\")\n\t})\n\tt.Run(\"encode-int64-write-error\", func(t *testing.T) {\n\t\tw := TestWriterError(\"\")\n\t\tenc := NewEncoder(w)\n\t\terr := enc.EncodeInt64(1)\n\t\tassert.NotNil(t, err, \"err should not be nil\")\n\t\tassert.Equal(t, \"Test Error\", err.Error(), \"err should be of type InvalidUsagePooledEncoderError\")\n\n\t})\n\tt.Run(\"encode-uint64-pool-error\", func(t *testing.T) {\n\t\tbuilder := &strings.Builder{}\n\t\tenc := NewEncoder(builder)\n\t\tenc.isPooled = 1\n\t\tdefer func() {\n\t\t\terr := recover()\n\t\t\tassert.NotNil(t, err, \"err should not be nil\")\n\t\t\tassert.IsType(t, InvalidUsagePooledEncoderError(\"\"), err, \"err should be of type InvalidUsagePooledEncoderError\")\n\t\t}()\n\t\t_ = enc.EncodeUint64(1)\n\t\tassert.True(t, false, \"should not be called as encoder should have panicked\")\n\t})\n\tt.Run(\"encode-unt64-write-error\", func(t *testing.T) {\n\t\tw := TestWriterError(\"\")\n\t\tenc := NewEncoder(w)\n\t\terr := enc.EncodeUint64(1)\n\t\tassert.NotNil(t, err, \"err should not be nil\")\n\t\tassert.Equal(t, \"Test Error\", err.Error(), \"err should be of type InvalidUsagePooledEncoderError\")\n\n\t})\n\tt.Run(\"encode-float64-pool-error\", func(t *testing.T) {\n\t\tbuilder := &strings.Builder{}\n\t\tenc := NewEncoder(builder)\n\t\tenc.isPooled = 1\n\t\tdefer func() {\n\t\t\terr := recover()\n\t\t\tassert.NotNil(t, err, \"err should not be nil\")\n\t\t\tassert.IsType(t, InvalidUsagePooledEncoderError(\"\"), err, \"err should be of type InvalidUsagePooledEncoderError\")\n\t\t}()\n\t\t_ = enc.EncodeFloat(1.1)\n\t\tassert.True(t, false, \"should not be called as encoder should have panicked\")\n\t})\n\tt.Run(\"encode-float64-write-error\", func(t *testing.T) {\n\t\tw := TestWriterError(\"\")\n\t\tenc := NewEncoder(w)\n\t\terr := enc.EncodeFloat(1.1)\n\t\tassert.NotNil(t, err, \"err should not be nil\")\n\t\tassert.Equal(t, \"Test Error\", err.Error(), \"err should be of type InvalidUsagePooledEncoderError\")\n\t})\n\tt.Run(\"encode-float32-pool-error\", func(t *testing.T) {\n\t\tbuilder := &strings.Builder{}\n\t\tenc := NewEncoder(builder)\n\t\tenc.isPooled = 1\n\t\tdefer func() {\n\t\t\terr := recover()\n\t\t\tassert.NotNil(t, err, \"err should not be nil\")\n\t\t\tassert.IsType(t, InvalidUsagePooledEncoderError(\"\"), err, \"err should be of type InvalidUsagePooledEncoderError\")\n\t\t}()\n\t\t_ = enc.EncodeFloat32(float32(1.1))\n\t\tassert.True(t, false, \"should not be called as encoder should have panicked\")\n\t})\n\tt.Run(\"encode-float32-write-error\", func(t *testing.T) {\n\t\tw := TestWriterError(\"\")\n\t\tenc := NewEncoder(w)\n\t\terr := enc.EncodeFloat32(float32(1.1))\n\t\tassert.NotNil(t, err, \"err should not be nil\")\n\t\tassert.Equal(t, \"Test Error\", err.Error(), \"err should be of type InvalidUsagePooledEncoderError\")\n\t})\n}\n\nfunc TestEncoderNumberMarshalAPI(t *testing.T) {\n\tt.Run(\"int\", func(t *testing.T) {\n\t\tr, err := Marshal(1)\n\t\tassert.Nil(t, err, \"Error should be nil\")\n\t\tassert.Equal(\n\t\t\tt,\n\t\t\t`1`,\n\t\t\tstring(r),\n\t\t\t\"Result of marshalling is different as the one expected\")\n\t})\n\tt.Run(\"int64\", func(t *testing.T) {\n\t\tr, err := Marshal(int64(1))\n\t\tassert.Nil(t, err, \"Error should be nil\")\n\t\tassert.Equal(\n\t\t\tt,\n\t\t\t`1`,\n\t\t\tstring(r),\n\t\t\t\"Result of marshalling is different as the one expected\")\n\t})\n\tt.Run(\"int32\", func(t *testing.T) {\n\t\tr, err := Marshal(int32(1))\n\t\tassert.Nil(t, err, \"Error should be nil\")\n\t\tassert.Equal(\n\t\t\tt,\n\t\t\t`1`,\n\t\t\tstring(r),\n\t\t\t\"Result of marshalling is different as the one expected\")\n\t})\n\tt.Run(\"int16\", func(t *testing.T) {\n\t\tr, err := Marshal(int16(1))\n\t\tassert.Nil(t, err, \"Error should be nil\")\n\t\tassert.Equal(\n\t\t\tt,\n\t\t\t`1`,\n\t\t\tstring(r),\n\t\t\t\"Result of marshalling is different as the one expected\")\n\t})\n\tt.Run(\"int8\", func(t *testing.T) {\n\t\tr, err := Marshal(int8(1))\n\t\tassert.Nil(t, err, \"Error should be nil\")\n\t\tassert.Equal(\n\t\t\tt,\n\t\t\t`1`,\n\t\t\tstring(r),\n\t\t\t\"Result of marshalling is different as the one expected\")\n\t})\n\tt.Run(\"uint64\", func(t *testing.T) {\n\t\tr, err := Marshal(uint64(1))\n\t\tassert.Nil(t, err, \"Error should be nil\")\n\t\tassert.Equal(\n\t\t\tt,\n\t\t\t`1`,\n\t\t\tstring(r),\n\t\t\t\"Result of marshalling is different as the one expected\")\n\t})\n\tt.Run(\"uint32\", func(t *testing.T) {\n\t\tr, err := Marshal(uint32(1))\n\t\tassert.Nil(t, err, \"Error should be nil\")\n\t\tassert.Equal(\n\t\t\tt,\n\t\t\t`1`,\n\t\t\tstring(r),\n\t\t\t\"Result of marshalling is different as the one expected\")\n\t})\n\tt.Run(\"uint16\", func(t *testing.T) {\n\t\tr, err := Marshal(uint16(1))\n\t\tassert.Nil(t, err, \"Error should be nil\")\n\t\tassert.Equal(\n\t\t\tt,\n\t\t\t`1`,\n\t\t\tstring(r),\n\t\t\t\"Result of marshalling is different as the one expected\")\n\t})\n\tt.Run(\"uint8\", func(t *testing.T) {\n\t\tr, err := Marshal(uint8(1))\n\t\tassert.Nil(t, err, \"Error should be nil\")\n\t\tassert.Equal(\n\t\t\tt,\n\t\t\t`1`,\n\t\t\tstring(r),\n\t\t\t\"Result of marshalling is different as the one expected\")\n\t})\n\tt.Run(\"float64\", func(t *testing.T) {\n\t\tr, err := Marshal(1.1)\n\t\tassert.Nil(t, err, \"Error should be nil\")\n\t\tassert.Equal(\n\t\t\tt,\n\t\t\t`1.1`,\n\t\t\tstring(r),\n\t\t\t\"Result of marshalling is different as the one expected\")\n\t})\n}\n\nfunc TestAddNumberFunc(t *testing.T) {\n\tt.Run(\"int64-key\", func(t *testing.T) {\n\t\tbuilder := &strings.Builder{}\n\t\tenc := BorrowEncoder(builder)\n\t\tenc.writeByte('{')\n\t\tenc.AddInt64Key(\"test\", 10)\n\t\t_, err := enc.Write()\n\t\tassert.Nil(t, err, \"err should be nil\")\n\t\tassert.Equal(t, `{\"test\":10`, builder.String(), `builder.String() should be equal to {\"test\":10\"`)\n\t})\n\tt.Run(\"int64-key-2\", func(t *testing.T) {\n\t\tbuilder := &strings.Builder{}\n\t\tenc := BorrowEncoder(builder)\n\t\tenc.writeBytes([]byte(`{\"test\":1`))\n\t\tenc.AddInt64Key(\"test\", 10)\n\t\t_, err := enc.Write()\n\t\tassert.Nil(t, err, \"err should be nil\")\n\t\tassert.Equal(t, `{\"test\":1,\"test\":10`, builder.String(), `builder.String() should be equal to {\"test\":10\"`)\n\t})\n\n\tt.Run(\"int64-key-omit-empty\", func(t *testing.T) {\n\t\tbuilder := &strings.Builder{}\n\t\tenc := BorrowEncoder(builder)\n\t\tenc.writeByte('{')\n\t\tenc.AddInt64KeyOmitEmpty(\"test\", 10)\n\t\t_, err := enc.Write()\n\t\tassert.Nil(t, err, \"err should be nil\")\n\t\tassert.Equal(t, `{\"test\":10`, builder.String(), `builder.String() should be equal to {\"test\":10\"`)\n\t})\n\tt.Run(\"int64-key-omit-empty-2\", func(t *testing.T) {\n\t\tbuilder := &strings.Builder{}\n\t\tenc := BorrowEncoder(builder)\n\t\tenc.writeBytes([]byte(`{\"test\":1`))\n\t\tenc.AddInt64KeyOmitEmpty(\"test\", 10)\n\t\t_, err := enc.Write()\n\t\tassert.Nil(t, err, \"err should be nil\")\n\t\tassert.Equal(t, `{\"test\":1,\"test\":10`, builder.String(), `builder.String() should be equal to {\"test\":10\"`)\n\t})\n\tt.Run(\"int64-key-omit-empty-3\", func(t *testing.T) {\n\t\tbuilder := &strings.Builder{}\n\t\tenc := BorrowEncoder(builder)\n\t\tenc.writeByte('{')\n\t\tenc.AddInt64KeyOmitEmpty(\"test\", 0)\n\t\t_, err := enc.Write()\n\t\tassert.Nil(t, err, \"err should be nil\")\n\t\tassert.Equal(t, `{`, builder.String(), `builder.String() should be equal to {\"test\":10\"`)\n\t})\n\tt.Run(\"int64\", func(t *testing.T) {\n\t\tbuilder := &strings.Builder{}\n\t\tenc := BorrowEncoder(builder)\n\t\tenc.writeByte('[')\n\t\tenc.AddInt64(10)\n\t\t_, err := enc.Write()\n\t\tassert.Nil(t, err, \"err should be nil\")\n\t\tassert.Equal(t, `[10`, builder.String(), `builder.String() should be equal to {\"test\":10\"`)\n\t})\n\tt.Run(\"int64-2\", func(t *testing.T) {\n\t\tbuilder := &strings.Builder{}\n\t\tenc := BorrowEncoder(builder)\n\t\tenc.writeBytes([]byte(`[1`))\n\t\tenc.AddInt64(10)\n\t\t_, err := enc.Write()\n\t\tassert.Nil(t, err, \"err should be nil\")\n\t\tassert.Equal(t, `[1,10`, builder.String(), `builder.String() should be equal to {\"test\":10\"`)\n\t})\n\n\tt.Run(\"int64-omit-empty\", func(t *testing.T) {\n\t\tbuilder := &strings.Builder{}\n\t\tenc := BorrowEncoder(builder)\n\t\tenc.writeByte('[')\n\t\tenc.AddInt64OmitEmpty(10)\n\t\t_, err := enc.Write()\n\t\tassert.Nil(t, err, \"err should be nil\")\n\t\tassert.Equal(t, `[10`, builder.String(), `builder.String() should be equal to {\"test\":10\"`)\n\t})\n\tt.Run(\"int64-omit-empty-2\", func(t *testing.T) {\n\t\tbuilder := &strings.Builder{}\n\t\tenc := BorrowEncoder(builder)\n\t\tenc.writeBytes([]byte(`[1`))\n\t\tenc.AddInt64OmitEmpty(10)\n\t\t_, err := enc.Write()\n\t\tassert.Nil(t, err, \"err should be nil\")\n\t\tassert.Equal(t, `[1,10`, builder.String(), `builder.String() should be equal to {\"test\":10\"`)\n\t})\n\tt.Run(\"int64-omit-empty-3\", func(t *testing.T) {\n\t\tbuilder := &strings.Builder{}\n\t\tenc := BorrowEncoder(builder)\n\t\tenc.writeByte('[')\n\t\tenc.AddInt64OmitEmpty(0)\n\t\t_, err := enc.Write()\n\t\tassert.Nil(t, err, \"err should be nil\")\n\t\tassert.Equal(t, `[`, builder.String(), `builder.String() should be equal to {\"test\":10\"`)\n\t})\n}\n\nfunc TestEncodeUint64(t *testing.T) {\n\tbuilder := &strings.Builder{}\n\tenc := BorrowEncoder(builder)\n\terr := enc.Encode(uint64(145509))\n\tassert.Nil(t, err, \"err should be nil\")\n\tassert.Equal(t, \"145509\", builder.String(), \"builder.String() should be 145509\")\n}\n\nfunc TestUint64Add(t *testing.T) {\n\tt.Run(\"uint64-key\", func(t *testing.T) {\n\t\tbuilder := &strings.Builder{}\n\t\tenc := BorrowEncoder(builder)\n\t\tenc.writeByte('{')\n\t\tenc.AddUint64Key(\"test\", 10)\n\t\t_, err := enc.Write()\n\t\tassert.Nil(t, err, \"err should be nil\")\n\t\tassert.Equal(t, `{\"test\":10`, builder.String(), `builder.String() should be equal to {\"test\":10\"`)\n\t})\n\tt.Run(\"uint64-key-2\", func(t *testing.T) {\n\t\tbuilder := &strings.Builder{}\n\t\tenc := BorrowEncoder(builder)\n\t\tenc.writeBytes([]byte(`{\"test\":1`))\n\t\tenc.AddUint64Key(\"test\", 10)\n\t\t_, err := enc.Write()\n\t\tassert.Nil(t, err, \"err should be nil\")\n\t\tassert.Equal(t, `{\"test\":1,\"test\":10`, builder.String(), `builder.String() should be equal to {\"test\":10\"`)\n\t})\n\n\tt.Run(\"uint64-key-omit-empty\", func(t *testing.T) {\n\t\tbuilder := &strings.Builder{}\n\t\tenc := BorrowEncoder(builder)\n\t\tenc.writeByte('{')\n\t\tenc.AddUint64KeyOmitEmpty(\"test\", 10)\n\t\t_, err := enc.Write()\n\t\tassert.Nil(t, err, \"err should be nil\")\n\t\tassert.Equal(t, `{\"test\":10`, builder.String(), `builder.String() should be equal to {\"test\":10\"`)\n\t})\n\tt.Run(\"uint64-key-omit-empty-2\", func(t *testing.T) {\n\t\tbuilder := &strings.Builder{}\n\t\tenc := BorrowEncoder(builder)\n\t\tenc.writeBytes([]byte(`{\"test\":1`))\n\t\tenc.AddUint64KeyOmitEmpty(\"test\", 10)\n\t\t_, err := enc.Write()\n\t\tassert.Nil(t, err, \"err should be nil\")\n\t\tassert.Equal(t, `{\"test\":1,\"test\":10`, builder.String(), `builder.String() should be equal to {\"test\":10\"`)\n\t})\n\tt.Run(\"uint64-key-omit-empty-3\", func(t *testing.T) {\n\t\tbuilder := &strings.Builder{}\n\t\tenc := BorrowEncoder(builder)\n\t\tenc.writeByte('{')\n\t\tenc.AddUint64KeyOmitEmpty(\"test\", 0)\n\t\t_, err := enc.Write()\n\t\tassert.Nil(t, err, \"err should be nil\")\n\t\tassert.Equal(t, `{`, builder.String(), `builder.String() should be equal to {\"test\":10\"`)\n\t})\n\tt.Run(\"uint64\", func(t *testing.T) {\n\t\tbuilder := &strings.Builder{}\n\t\tenc := BorrowEncoder(builder)\n\t\tenc.writeByte('[')\n\t\tenc.AddUint64(10)\n\t\t_, err := enc.Write()\n\t\tassert.Nil(t, err, \"err should be nil\")\n\t\tassert.Equal(t, `[10`, builder.String(), `builder.String() should be equal to {\"test\":10\"`)\n\t})\n\tt.Run(\"uint64-2\", func(t *testing.T) {\n\t\tbuilder := &strings.Builder{}\n\t\tenc := BorrowEncoder(builder)\n\t\tenc.writeBytes([]byte(`[1`))\n\t\tenc.AddUint64(10)\n\t\t_, err := enc.Write()\n\t\tassert.Nil(t, err, \"err should be nil\")\n\t\tassert.Equal(t, `[1,10`, builder.String(), `builder.String() should be equal to {\"test\":10\"`)\n\t})\n\n\tt.Run(\"uint64-omit-empty\", func(t *testing.T) {\n\t\tbuilder := &strings.Builder{}\n\t\tenc := BorrowEncoder(builder)\n\t\tenc.writeByte('[')\n\t\tenc.AddUint64OmitEmpty(10)\n\t\t_, err := enc.Write()\n\t\tassert.Nil(t, err, \"err should be nil\")\n\t\tassert.Equal(t, `[10`, builder.String(), `builder.String() should be equal to {\"test\":10\"`)\n\t})\n\tt.Run(\"uint64-omit-empty-2\", func(t *testing.T) {\n\t\tbuilder := &strings.Builder{}\n\t\tenc := BorrowEncoder(builder)\n\t\tenc.writeBytes([]byte(`[1`))\n\t\tenc.AddUint64OmitEmpty(10)\n\t\t_, err := enc.Write()\n\t\tassert.Nil(t, err, \"err should be nil\")\n\t\tassert.Equal(t, `[1,10`, builder.String(), `builder.String() should be equal to {\"test\":10\"`)\n\t})\n\tt.Run(\"uint64-omit-empty-3\", func(t *testing.T) {\n\t\tbuilder := &strings.Builder{}\n\t\tenc := BorrowEncoder(builder)\n\t\tenc.writeByte('[')\n\t\tenc.AddUint64OmitEmpty(0)\n\t\t_, err := enc.Write()\n\t\tassert.Nil(t, err, \"err should be nil\")\n\t\tassert.Equal(t, `[`, builder.String(), `builder.String() should be equal to {\"test\":10\"`)\n\t})\n}\n"
        },
        {
          "name": "encode_number_uint.go",
          "type": "blob",
          "size": 11.927734375,
          "content": "package gojay\n\nimport \"strconv\"\n\n// EncodeUint64 encodes an int64 to JSON\nfunc (enc *Encoder) EncodeUint64(n uint64) error {\n\tif enc.isPooled == 1 {\n\t\tpanic(InvalidUsagePooledEncoderError(\"Invalid usage of pooled encoder\"))\n\t}\n\t_, _ = enc.encodeUint64(n)\n\t_, err := enc.Write()\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}\n\n// encodeUint64 encodes an int to JSON\nfunc (enc *Encoder) encodeUint64(n uint64) ([]byte, error) {\n\tenc.buf = strconv.AppendUint(enc.buf, n, 10)\n\treturn enc.buf, nil\n}\n\n// AddUint64 adds an int to be encoded, must be used inside a slice or array encoding (does not encode a key)\nfunc (enc *Encoder) AddUint64(v uint64) {\n\tenc.Uint64(v)\n}\n\n// AddUint64OmitEmpty adds an int to be encoded and skips it if its value is 0,\n// must be used inside a slice or array encoding (does not encode a key).\nfunc (enc *Encoder) AddUint64OmitEmpty(v uint64) {\n\tenc.Uint64OmitEmpty(v)\n}\n\n// AddUint64NullEmpty adds an int to be encoded and skips it if its value is 0,\n// must be used inside a slice or array encoding (does not encode a key).\nfunc (enc *Encoder) AddUint64NullEmpty(v uint64) {\n\tenc.Uint64NullEmpty(v)\n}\n\n// Uint64 adds an int to be encoded, must be used inside a slice or array encoding (does not encode a key)\nfunc (enc *Encoder) Uint64(v uint64) {\n\tenc.grow(10)\n\tr := enc.getPreviousRune()\n\tif r != '[' {\n\t\tenc.writeByte(',')\n\t}\n\tenc.buf = strconv.AppendUint(enc.buf, v, 10)\n}\n\n// Uint64OmitEmpty adds an int to be encoded and skips it if its value is 0,\n// must be used inside a slice or array encoding (does not encode a key).\nfunc (enc *Encoder) Uint64OmitEmpty(v uint64) {\n\tif v == 0 {\n\t\treturn\n\t}\n\tenc.grow(10)\n\tr := enc.getPreviousRune()\n\tif r != '[' {\n\t\tenc.writeByte(',')\n\t}\n\tenc.buf = strconv.AppendUint(enc.buf, v, 10)\n}\n\n// Uint64NullEmpty adds an int to be encoded and skips it if its value is 0,\n// must be used inside a slice or array encoding (does not encode a key).\nfunc (enc *Encoder) Uint64NullEmpty(v uint64) {\n\tenc.grow(10)\n\tr := enc.getPreviousRune()\n\tif r != '[' {\n\t\tenc.writeByte(',')\n\t}\n\tif v == 0 {\n\t\tenc.writeBytes(nullBytes)\n\t\treturn\n\t}\n\tenc.buf = strconv.AppendUint(enc.buf, v, 10)\n}\n\n// AddUint64Key adds an int to be encoded, must be used inside an object as it will encode a key\nfunc (enc *Encoder) AddUint64Key(key string, v uint64) {\n\tenc.Uint64Key(key, v)\n}\n\n// AddUint64KeyOmitEmpty adds an int to be encoded and skips it if its value is 0.\n// Must be used inside an object as it will encode a key.\nfunc (enc *Encoder) AddUint64KeyOmitEmpty(key string, v uint64) {\n\tenc.Uint64KeyOmitEmpty(key, v)\n}\n\n// AddUint64KeyNullEmpty adds an int to be encoded and skips it if its value is 0.\n// Must be used inside an object as it will encode a key.\nfunc (enc *Encoder) AddUint64KeyNullEmpty(key string, v uint64) {\n\tenc.Uint64KeyNullEmpty(key, v)\n}\n\n// Uint64Key adds an int to be encoded, must be used inside an object as it will encode a key\nfunc (enc *Encoder) Uint64Key(key string, v uint64) {\n\tif enc.hasKeys {\n\t\tif !enc.keyExists(key) {\n\t\t\treturn\n\t\t}\n\t}\n\tenc.grow(10 + len(key))\n\tr := enc.getPreviousRune()\n\tif r != '{' {\n\t\tenc.writeByte(',')\n\t}\n\tenc.writeByte('\"')\n\tenc.writeStringEscape(key)\n\tenc.writeBytes(objKey)\n\tenc.buf = strconv.AppendUint(enc.buf, v, 10)\n}\n\n// Uint64KeyOmitEmpty adds an int to be encoded and skips it if its value is 0.\n// Must be used inside an object as it will encode a key.\nfunc (enc *Encoder) Uint64KeyOmitEmpty(key string, v uint64) {\n\tif enc.hasKeys {\n\t\tif !enc.keyExists(key) {\n\t\t\treturn\n\t\t}\n\t}\n\tif v == 0 {\n\t\treturn\n\t}\n\tenc.grow(10 + len(key))\n\tr := enc.getPreviousRune()\n\tif r != '{' && r != '[' {\n\t\tenc.writeByte(',')\n\t}\n\tenc.writeByte('\"')\n\tenc.writeStringEscape(key)\n\tenc.writeBytes(objKey)\n\tenc.buf = strconv.AppendUint(enc.buf, v, 10)\n}\n\n// Uint64KeyNullEmpty adds an int to be encoded and skips it if its value is 0.\n// Must be used inside an object as it will encode a key.\nfunc (enc *Encoder) Uint64KeyNullEmpty(key string, v uint64) {\n\tif enc.hasKeys {\n\t\tif !enc.keyExists(key) {\n\t\t\treturn\n\t\t}\n\t}\n\tenc.grow(10 + len(key))\n\tr := enc.getPreviousRune()\n\tif r != '{' && r != '[' {\n\t\tenc.writeByte(',')\n\t}\n\tenc.writeByte('\"')\n\tenc.writeStringEscape(key)\n\tenc.writeBytes(objKey)\n\tif v == 0 {\n\t\tenc.writeBytes(nullBytes)\n\t\treturn\n\t}\n\tenc.buf = strconv.AppendUint(enc.buf, v, 10)\n}\n\n// AddUint32 adds an int to be encoded, must be used inside a slice or array encoding (does not encode a key)\nfunc (enc *Encoder) AddUint32(v uint32) {\n\tenc.Uint64(uint64(v))\n}\n\n// AddUint32OmitEmpty adds an int to be encoded and skips it if its value is 0,\n// must be used inside a slice or array encoding (does not encode a key).\nfunc (enc *Encoder) AddUint32OmitEmpty(v uint32) {\n\tenc.Uint64OmitEmpty(uint64(v))\n}\n\n// AddUint32NullEmpty adds an int to be encoded and skips it if its value is 0,\n// must be used inside a slice or array encoding (does not encode a key).\nfunc (enc *Encoder) AddUint32NullEmpty(v uint32) {\n\tenc.Uint64NullEmpty(uint64(v))\n}\n\n// Uint32 adds an int to be encoded, must be used inside a slice or array encoding (does not encode a key)\nfunc (enc *Encoder) Uint32(v uint32) {\n\tenc.Uint64(uint64(v))\n}\n\n// Uint32OmitEmpty adds an int to be encoded and skips it if its value is 0,\n// must be used inside a slice or array encoding (does not encode a key).\nfunc (enc *Encoder) Uint32OmitEmpty(v uint32) {\n\tenc.Uint64OmitEmpty(uint64(v))\n}\n\n// Uint32NullEmpty adds an int to be encoded and skips it if its value is 0,\n// must be used inside a slice or array encoding (does not encode a key).\nfunc (enc *Encoder) Uint32NullEmpty(v uint32) {\n\tenc.Uint64NullEmpty(uint64(v))\n}\n\n// AddUint32Key adds an int to be encoded, must be used inside an object as it will encode a key\nfunc (enc *Encoder) AddUint32Key(key string, v uint32) {\n\tenc.Uint64Key(key, uint64(v))\n}\n\n// AddUint32KeyOmitEmpty adds an int to be encoded and skips it if its value is 0.\n// Must be used inside an object as it will encode a key.\nfunc (enc *Encoder) AddUint32KeyOmitEmpty(key string, v uint32) {\n\tenc.Uint64KeyOmitEmpty(key, uint64(v))\n}\n\n// AddUint32KeyNullEmpty adds an int to be encoded and skips it if its value is 0.\n// Must be used inside an object as it will encode a key.\nfunc (enc *Encoder) AddUint32KeyNullEmpty(key string, v uint32) {\n\tenc.Uint64KeyNullEmpty(key, uint64(v))\n}\n\n// Uint32Key adds an int to be encoded, must be used inside an object as it will encode a key\nfunc (enc *Encoder) Uint32Key(key string, v uint32) {\n\tenc.Uint64Key(key, uint64(v))\n}\n\n// Uint32KeyOmitEmpty adds an int to be encoded and skips it if its value is 0.\n// Must be used inside an object as it will encode a key.\nfunc (enc *Encoder) Uint32KeyOmitEmpty(key string, v uint32) {\n\tenc.Uint64KeyOmitEmpty(key, uint64(v))\n}\n\n// Uint32KeyNullEmpty adds an int to be encoded and skips it if its value is 0.\n// Must be used inside an object as it will encode a key.\nfunc (enc *Encoder) Uint32KeyNullEmpty(key string, v uint32) {\n\tenc.Uint64KeyNullEmpty(key, uint64(v))\n}\n\n// AddUint16 adds an int to be encoded, must be used inside a slice or array encoding (does not encode a key)\nfunc (enc *Encoder) AddUint16(v uint16) {\n\tenc.Uint64(uint64(v))\n}\n\n// AddUint16OmitEmpty adds an int to be encoded and skips it if its value is 0,\n// must be used inside a slice or array encoding (does not encode a key).\nfunc (enc *Encoder) AddUint16OmitEmpty(v uint16) {\n\tenc.Uint64OmitEmpty(uint64(v))\n}\n\n// AddUint16NullEmpty adds an int to be encoded and skips it if its value is 0,\n// must be used inside a slice or array encoding (does not encode a key).\nfunc (enc *Encoder) AddUint16NullEmpty(v uint16) {\n\tenc.Uint64NullEmpty(uint64(v))\n}\n\n// Uint16 adds an int to be encoded, must be used inside a slice or array encoding (does not encode a key)\nfunc (enc *Encoder) Uint16(v uint16) {\n\tenc.Uint64(uint64(v))\n}\n\n// Uint16OmitEmpty adds an int to be encoded and skips it if its value is 0,\n// must be used inside a slice or array encoding (does not encode a key).\nfunc (enc *Encoder) Uint16OmitEmpty(v uint16) {\n\tenc.Uint64OmitEmpty(uint64(v))\n}\n\n// Uint16NullEmpty adds an int to be encoded and skips it if its value is 0,\n// must be used inside a slice or array encoding (does not encode a key).\nfunc (enc *Encoder) Uint16NullEmpty(v uint16) {\n\tenc.Uint64NullEmpty(uint64(v))\n}\n\n// AddUint16Key adds an int to be encoded, must be used inside an object as it will encode a key\nfunc (enc *Encoder) AddUint16Key(key string, v uint16) {\n\tenc.Uint64Key(key, uint64(v))\n}\n\n// AddUint16KeyOmitEmpty adds an int to be encoded and skips it if its value is 0.\n// Must be used inside an object as it will encode a key.\nfunc (enc *Encoder) AddUint16KeyOmitEmpty(key string, v uint16) {\n\tenc.Uint64KeyOmitEmpty(key, uint64(v))\n}\n\n// AddUint16KeyNullEmpty adds an int to be encoded and skips it if its value is 0.\n// Must be used inside an object as it will encode a key.\nfunc (enc *Encoder) AddUint16KeyNullEmpty(key string, v uint16) {\n\tenc.Uint64KeyNullEmpty(key, uint64(v))\n}\n\n// Uint16Key adds an int to be encoded, must be used inside an object as it will encode a key\nfunc (enc *Encoder) Uint16Key(key string, v uint16) {\n\tenc.Uint64Key(key, uint64(v))\n}\n\n// Uint16KeyOmitEmpty adds an int to be encoded and skips it if its value is 0.\n// Must be used inside an object as it will encode a key.\nfunc (enc *Encoder) Uint16KeyOmitEmpty(key string, v uint16) {\n\tenc.Uint64KeyOmitEmpty(key, uint64(v))\n}\n\n// Uint16KeyNullEmpty adds an int to be encoded and skips it if its value is 0.\n// Must be used inside an object as it will encode a key.\nfunc (enc *Encoder) Uint16KeyNullEmpty(key string, v uint16) {\n\tenc.Uint64KeyNullEmpty(key, uint64(v))\n}\n\n// AddUint8 adds an int to be encoded, must be used inside a slice or array encoding (does not encode a key)\nfunc (enc *Encoder) AddUint8(v uint8) {\n\tenc.Uint64(uint64(v))\n}\n\n// AddUint8OmitEmpty adds an int to be encoded and skips it if its value is 0,\n// must be used inside a slice or array encoding (does not encode a key).\nfunc (enc *Encoder) AddUint8OmitEmpty(v uint8) {\n\tenc.Uint64OmitEmpty(uint64(v))\n}\n\n// AddUint8NullEmpty adds an int to be encoded and skips it if its value is 0,\n// must be used inside a slice or array encoding (does not encode a key).\nfunc (enc *Encoder) AddUint8NullEmpty(v uint8) {\n\tenc.Uint64NullEmpty(uint64(v))\n}\n\n// Uint8 adds an int to be encoded, must be used inside a slice or array encoding (does not encode a key)\nfunc (enc *Encoder) Uint8(v uint8) {\n\tenc.Uint64(uint64(v))\n}\n\n// Uint8OmitEmpty adds an int to be encoded and skips it if its value is 0,\n// must be used inside a slice or array encoding (does not encode a key).\nfunc (enc *Encoder) Uint8OmitEmpty(v uint8) {\n\tenc.Uint64OmitEmpty(uint64(v))\n}\n\n// Uint8NullEmpty adds an int to be encoded and skips it if its value is 0,\n// must be used inside a slice or array encoding (does not encode a key).\nfunc (enc *Encoder) Uint8NullEmpty(v uint8) {\n\tenc.Uint64NullEmpty(uint64(v))\n}\n\n// AddUint8Key adds an int to be encoded, must be used inside an object as it will encode a key\nfunc (enc *Encoder) AddUint8Key(key string, v uint8) {\n\tenc.Uint64Key(key, uint64(v))\n}\n\n// AddUint8KeyOmitEmpty adds an int to be encoded and skips it if its value is 0.\n// Must be used inside an object as it will encode a key.\nfunc (enc *Encoder) AddUint8KeyOmitEmpty(key string, v uint8) {\n\tenc.Uint64KeyOmitEmpty(key, uint64(v))\n}\n\n// AddUint8KeyNullEmpty adds an int to be encoded and skips it if its value is 0.\n// Must be used inside an object as it will encode a key.\nfunc (enc *Encoder) AddUint8KeyNullEmpty(key string, v uint8) {\n\tenc.Uint64KeyNullEmpty(key, uint64(v))\n}\n\n// Uint8Key adds an int to be encoded, must be used inside an object as it will encode a key\nfunc (enc *Encoder) Uint8Key(key string, v uint8) {\n\tenc.Uint64Key(key, uint64(v))\n}\n\n// Uint8KeyOmitEmpty adds an int to be encoded and skips it if its value is 0.\n// Must be used inside an object as it will encode a key.\nfunc (enc *Encoder) Uint8KeyOmitEmpty(key string, v uint8) {\n\tenc.Uint64KeyOmitEmpty(key, uint64(v))\n}\n\n// Uint8KeyNullEmpty adds an int to be encoded and skips it if its value is 0.\n// Must be used inside an object as it will encode a key.\nfunc (enc *Encoder) Uint8KeyNullEmpty(key string, v uint8) {\n\tenc.Uint64KeyNullEmpty(key, uint64(v))\n}\n"
        },
        {
          "name": "encode_number_uint_test.go",
          "type": "blob",
          "size": 17.3505859375,
          "content": "package gojay\n\nimport (\n\t\"math\"\n\t\"strings\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestEncoderUint64(t *testing.T) {\n\tvar testCasesBasic = []struct {\n\t\tname         string\n\t\tv            uint64\n\t\texpectedJSON string\n\t}{\n\t\t{\n\t\t\tname:         \"basic\",\n\t\t\tv:            uint64(1),\n\t\t\texpectedJSON: \"[1,1]\",\n\t\t},\n\t\t{\n\t\t\tname:         \"big\",\n\t\t\tv:            math.MaxUint64,\n\t\t\texpectedJSON: \"[18446744073709551615,18446744073709551615]\",\n\t\t},\n\t\t{\n\t\t\tname:         \"big\",\n\t\t\tv:            uint64(0),\n\t\t\texpectedJSON: \"[0,0]\",\n\t\t},\n\t}\n\tfor _, testCase := range testCasesBasic {\n\t\tt.Run(testCase.name, func(t *testing.T) {\n\t\t\tvar b = &strings.Builder{}\n\t\t\tvar enc = NewEncoder(b)\n\t\t\tenc.Encode(EncodeArrayFunc(func(enc *Encoder) {\n\t\t\t\tenc.Uint64(testCase.v)\n\t\t\t\tenc.AddUint64(testCase.v)\n\t\t\t}))\n\t\t\tassert.Equal(t, testCase.expectedJSON, b.String())\n\t\t})\n\t}\n\tvar testCasesOmitEmpty = []struct {\n\t\tname         string\n\t\tv            uint64\n\t\texpectedJSON string\n\t}{\n\t\t{\n\t\t\tname:         \"basic\",\n\t\t\tv:            uint64(1),\n\t\t\texpectedJSON: \"[1,1]\",\n\t\t},\n\t\t{\n\t\t\tname:         \"big\",\n\t\t\tv:            math.MaxUint64,\n\t\t\texpectedJSON: \"[18446744073709551615,18446744073709551615]\",\n\t\t},\n\t\t{\n\t\t\tname:         \"big\",\n\t\t\tv:            uint64(0),\n\t\t\texpectedJSON: \"[]\",\n\t\t},\n\t}\n\tfor _, testCase := range testCasesOmitEmpty {\n\t\tt.Run(testCase.name, func(t *testing.T) {\n\t\t\tvar b = &strings.Builder{}\n\t\t\tvar enc = NewEncoder(b)\n\t\t\tenc.Encode(EncodeArrayFunc(func(enc *Encoder) {\n\t\t\t\tenc.Uint64OmitEmpty(testCase.v)\n\t\t\t\tenc.AddUint64OmitEmpty(testCase.v)\n\t\t\t}))\n\t\t\tassert.Equal(t, testCase.expectedJSON, b.String())\n\t\t})\n\t}\n\tvar testCasesKeyBasic = []struct {\n\t\tname         string\n\t\tv            uint64\n\t\texpectedJSON string\n\t}{\n\t\t{\n\t\t\tname:         \"basic\",\n\t\t\tv:            uint64(1),\n\t\t\texpectedJSON: `{\"foo\":1,\"bar\":1}`,\n\t\t},\n\t\t{\n\t\t\tname:         \"big\",\n\t\t\tv:            math.MaxUint64,\n\t\t\texpectedJSON: `{\"foo\":18446744073709551615,\"bar\":18446744073709551615}`,\n\t\t},\n\t\t{\n\t\t\tname:         \"big\",\n\t\t\tv:            uint64(0),\n\t\t\texpectedJSON: `{\"foo\":0,\"bar\":0}`,\n\t\t},\n\t}\n\tfor _, testCase := range testCasesKeyBasic {\n\t\tt.Run(testCase.name, func(t *testing.T) {\n\t\t\tvar b = &strings.Builder{}\n\t\t\tvar enc = NewEncoder(b)\n\t\t\tenc.Encode(EncodeObjectFunc(func(enc *Encoder) {\n\t\t\t\tenc.Uint64Key(\"foo\", testCase.v)\n\t\t\t\tenc.AddUint64Key(\"bar\", testCase.v)\n\t\t\t}))\n\t\t\tassert.Equal(t, testCase.expectedJSON, b.String())\n\t\t})\n\t}\n\tvar testCasesKeyOmitEmpty = []struct {\n\t\tname         string\n\t\tv            uint64\n\t\texpectedJSON string\n\t}{\n\t\t{\n\t\t\tname:         \"basic\",\n\t\t\tv:            uint64(1),\n\t\t\texpectedJSON: `{\"foo\":1,\"bar\":1}`,\n\t\t},\n\t\t{\n\t\t\tname:         \"big\",\n\t\t\tv:            math.MaxUint64,\n\t\t\texpectedJSON: `{\"foo\":18446744073709551615,\"bar\":18446744073709551615}`,\n\t\t},\n\t\t{\n\t\t\tname:         \"big\",\n\t\t\tv:            uint64(0),\n\t\t\texpectedJSON: \"{}\",\n\t\t},\n\t}\n\tfor _, testCase := range testCasesKeyOmitEmpty {\n\t\tt.Run(testCase.name, func(t *testing.T) {\n\t\t\tvar b = &strings.Builder{}\n\t\t\tvar enc = NewEncoder(b)\n\t\t\tenc.Encode(EncodeObjectFunc(func(enc *Encoder) {\n\t\t\t\tenc.Uint64KeyOmitEmpty(\"foo\", testCase.v)\n\t\t\t\tenc.AddUint64KeyOmitEmpty(\"bar\", testCase.v)\n\t\t\t}))\n\t\t\tassert.Equal(t, testCase.expectedJSON, b.String())\n\t\t})\n\t}\n}\n\nfunc TestEncoderUint32(t *testing.T) {\n\tvar testCasesBasic = []struct {\n\t\tname         string\n\t\tv            uint32\n\t\texpectedJSON string\n\t}{\n\t\t{\n\t\t\tname:         \"basic\",\n\t\t\tv:            uint32(1),\n\t\t\texpectedJSON: \"[1,1]\",\n\t\t},\n\t\t{\n\t\t\tname:         \"big\",\n\t\t\tv:            math.MaxUint32,\n\t\t\texpectedJSON: \"[4294967295,4294967295]\",\n\t\t},\n\t\t{\n\t\t\tname:         \"big\",\n\t\t\tv:            uint32(0),\n\t\t\texpectedJSON: \"[0,0]\",\n\t\t},\n\t}\n\tfor _, testCase := range testCasesBasic {\n\t\tt.Run(testCase.name, func(t *testing.T) {\n\t\t\tvar b = &strings.Builder{}\n\t\t\tvar enc = NewEncoder(b)\n\t\t\tenc.Encode(EncodeArrayFunc(func(enc *Encoder) {\n\t\t\t\tenc.Uint32(testCase.v)\n\t\t\t\tenc.AddUint32(testCase.v)\n\t\t\t}))\n\t\t\tassert.Equal(t, testCase.expectedJSON, b.String())\n\t\t})\n\t}\n\tvar testCasesOmitEmpty = []struct {\n\t\tname         string\n\t\tv            uint32\n\t\texpectedJSON string\n\t}{\n\t\t{\n\t\t\tname:         \"basic\",\n\t\t\tv:            uint32(1),\n\t\t\texpectedJSON: \"[1,1]\",\n\t\t},\n\t\t{\n\t\t\tname:         \"big\",\n\t\t\tv:            math.MaxUint32,\n\t\t\texpectedJSON: \"[4294967295,4294967295]\",\n\t\t},\n\t\t{\n\t\t\tname:         \"big\",\n\t\t\tv:            uint32(0),\n\t\t\texpectedJSON: \"[]\",\n\t\t},\n\t}\n\tfor _, testCase := range testCasesOmitEmpty {\n\t\tt.Run(testCase.name, func(t *testing.T) {\n\t\t\tvar b = &strings.Builder{}\n\t\t\tvar enc = NewEncoder(b)\n\t\t\tenc.Encode(EncodeArrayFunc(func(enc *Encoder) {\n\t\t\t\tenc.Uint32OmitEmpty(testCase.v)\n\t\t\t\tenc.AddUint32OmitEmpty(testCase.v)\n\t\t\t}))\n\t\t\tassert.Equal(t, testCase.expectedJSON, b.String())\n\t\t})\n\t}\n\tvar testCasesKeyBasic = []struct {\n\t\tname         string\n\t\tv            uint32\n\t\texpectedJSON string\n\t}{\n\t\t{\n\t\t\tname:         \"basic\",\n\t\t\tv:            uint32(1),\n\t\t\texpectedJSON: `{\"foo\":1,\"bar\":1}`,\n\t\t},\n\t\t{\n\t\t\tname:         \"big\",\n\t\t\tv:            math.MaxUint32,\n\t\t\texpectedJSON: `{\"foo\":4294967295,\"bar\":4294967295}`,\n\t\t},\n\t\t{\n\t\t\tname:         \"big\",\n\t\t\tv:            uint32(0),\n\t\t\texpectedJSON: `{\"foo\":0,\"bar\":0}`,\n\t\t},\n\t}\n\tfor _, testCase := range testCasesKeyBasic {\n\t\tt.Run(testCase.name, func(t *testing.T) {\n\t\t\tvar b = &strings.Builder{}\n\t\t\tvar enc = NewEncoder(b)\n\t\t\tenc.Encode(EncodeObjectFunc(func(enc *Encoder) {\n\t\t\t\tenc.Uint32Key(\"foo\", testCase.v)\n\t\t\t\tenc.AddUint32Key(\"bar\", testCase.v)\n\t\t\t}))\n\t\t\tassert.Equal(t, testCase.expectedJSON, b.String())\n\t\t})\n\t}\n\tvar testCasesKeyOmitEmpty = []struct {\n\t\tname         string\n\t\tv            uint32\n\t\texpectedJSON string\n\t}{\n\t\t{\n\t\t\tname:         \"basic\",\n\t\t\tv:            uint32(1),\n\t\t\texpectedJSON: `{\"foo\":1,\"bar\":1}`,\n\t\t},\n\t\t{\n\t\t\tname:         \"big\",\n\t\t\tv:            math.MaxUint32,\n\t\t\texpectedJSON: `{\"foo\":4294967295,\"bar\":4294967295}`,\n\t\t},\n\t\t{\n\t\t\tname:         \"big\",\n\t\t\tv:            uint32(0),\n\t\t\texpectedJSON: `{}`,\n\t\t},\n\t}\n\tfor _, testCase := range testCasesKeyOmitEmpty {\n\t\tt.Run(testCase.name, func(t *testing.T) {\n\t\t\tvar b = &strings.Builder{}\n\t\t\tvar enc = NewEncoder(b)\n\t\t\tenc.Encode(EncodeObjectFunc(func(enc *Encoder) {\n\t\t\t\tenc.Uint32KeyOmitEmpty(\"foo\", testCase.v)\n\t\t\t\tenc.AddUint32KeyOmitEmpty(\"bar\", testCase.v)\n\t\t\t}))\n\t\t\tassert.Equal(t, testCase.expectedJSON, b.String())\n\t\t})\n\t}\n}\n\nfunc TestEncoderUint16(t *testing.T) {\n\tvar testCasesBasic = []struct {\n\t\tname         string\n\t\tv            uint16\n\t\texpectedJSON string\n\t}{\n\t\t{\n\t\t\tname:         \"basic\",\n\t\t\tv:            uint16(1),\n\t\t\texpectedJSON: \"[1,1]\",\n\t\t},\n\t\t{\n\t\t\tname:         \"big\",\n\t\t\tv:            math.MaxUint16,\n\t\t\texpectedJSON: \"[65535,65535]\",\n\t\t},\n\t\t{\n\t\t\tname:         \"big\",\n\t\t\tv:            uint16(0),\n\t\t\texpectedJSON: \"[0,0]\",\n\t\t},\n\t}\n\tfor _, testCase := range testCasesBasic {\n\t\tt.Run(testCase.name, func(t *testing.T) {\n\t\t\tvar b = &strings.Builder{}\n\t\t\tvar enc = NewEncoder(b)\n\t\t\tenc.Encode(EncodeArrayFunc(func(enc *Encoder) {\n\t\t\t\tenc.Uint16(testCase.v)\n\t\t\t\tenc.AddUint16(testCase.v)\n\t\t\t}))\n\t\t\tassert.Equal(t, testCase.expectedJSON, b.String())\n\t\t})\n\t}\n\tvar testCasesOmitEmpty = []struct {\n\t\tname         string\n\t\tv            uint16\n\t\texpectedJSON string\n\t}{\n\t\t{\n\t\t\tname:         \"basic\",\n\t\t\tv:            uint16(1),\n\t\t\texpectedJSON: \"[1,1]\",\n\t\t},\n\t\t{\n\t\t\tname:         \"big\",\n\t\t\tv:            math.MaxUint16,\n\t\t\texpectedJSON: \"[65535,65535]\",\n\t\t},\n\t\t{\n\t\t\tname:         \"big\",\n\t\t\tv:            uint16(0),\n\t\t\texpectedJSON: \"[]\",\n\t\t},\n\t}\n\tfor _, testCase := range testCasesOmitEmpty {\n\t\tt.Run(testCase.name, func(t *testing.T) {\n\t\t\tvar b = &strings.Builder{}\n\t\t\tvar enc = NewEncoder(b)\n\t\t\tenc.Encode(EncodeArrayFunc(func(enc *Encoder) {\n\t\t\t\tenc.Uint16OmitEmpty(testCase.v)\n\t\t\t\tenc.AddUint16OmitEmpty(testCase.v)\n\t\t\t}))\n\t\t\tassert.Equal(t, testCase.expectedJSON, b.String())\n\t\t})\n\t}\n\tvar testCasesKeyBasic = []struct {\n\t\tname         string\n\t\tv            uint16\n\t\texpectedJSON string\n\t}{\n\t\t{\n\t\t\tname:         \"basic\",\n\t\t\tv:            uint16(1),\n\t\t\texpectedJSON: `{\"foo\":1,\"bar\":1}`,\n\t\t},\n\t\t{\n\t\t\tname:         \"big\",\n\t\t\tv:            math.MaxUint16,\n\t\t\texpectedJSON: `{\"foo\":65535,\"bar\":65535}`,\n\t\t},\n\t\t{\n\t\t\tname:         \"big\",\n\t\t\tv:            uint16(0),\n\t\t\texpectedJSON: `{\"foo\":0,\"bar\":0}`,\n\t\t},\n\t}\n\tfor _, testCase := range testCasesKeyBasic {\n\t\tt.Run(testCase.name, func(t *testing.T) {\n\t\t\tvar b = &strings.Builder{}\n\t\t\tvar enc = NewEncoder(b)\n\t\t\tenc.Encode(EncodeObjectFunc(func(enc *Encoder) {\n\t\t\t\tenc.Uint16Key(\"foo\", testCase.v)\n\t\t\t\tenc.AddUint16Key(\"bar\", testCase.v)\n\t\t\t}))\n\t\t\tassert.Equal(t, testCase.expectedJSON, b.String())\n\t\t})\n\t}\n\tvar testCasesKeyOmitEmpty = []struct {\n\t\tname         string\n\t\tv            uint16\n\t\texpectedJSON string\n\t}{\n\t\t{\n\t\t\tname:         \"basic\",\n\t\t\tv:            uint16(1),\n\t\t\texpectedJSON: `{\"foo\":1,\"bar\":1}`,\n\t\t},\n\t\t{\n\t\t\tname:         \"big\",\n\t\t\tv:            math.MaxUint16,\n\t\t\texpectedJSON: `{\"foo\":65535,\"bar\":65535}`,\n\t\t},\n\t\t{\n\t\t\tname:         \"big\",\n\t\t\tv:            uint16(0),\n\t\t\texpectedJSON: `{}`,\n\t\t},\n\t}\n\tfor _, testCase := range testCasesKeyOmitEmpty {\n\t\tt.Run(testCase.name, func(t *testing.T) {\n\t\t\tvar b = &strings.Builder{}\n\t\t\tvar enc = NewEncoder(b)\n\t\t\tenc.Encode(EncodeObjectFunc(func(enc *Encoder) {\n\t\t\t\tenc.Uint16KeyOmitEmpty(\"foo\", testCase.v)\n\t\t\t\tenc.AddUint16KeyOmitEmpty(\"bar\", testCase.v)\n\t\t\t}))\n\t\t\tassert.Equal(t, testCase.expectedJSON, b.String())\n\t\t})\n\t}\n}\n\nfunc TestEncoderUint8(t *testing.T) {\n\tvar testCasesBasic = []struct {\n\t\tname         string\n\t\tv            uint8\n\t\texpectedJSON string\n\t}{\n\t\t{\n\t\t\tname:         \"basic\",\n\t\t\tv:            uint8(1),\n\t\t\texpectedJSON: \"[1,1]\",\n\t\t},\n\t\t{\n\t\t\tname:         \"big\",\n\t\t\tv:            math.MaxUint8,\n\t\t\texpectedJSON: \"[255,255]\",\n\t\t},\n\t\t{\n\t\t\tname:         \"big\",\n\t\t\tv:            uint8(0),\n\t\t\texpectedJSON: \"[0,0]\",\n\t\t},\n\t}\n\tfor _, testCase := range testCasesBasic {\n\t\tt.Run(testCase.name, func(t *testing.T) {\n\t\t\tvar b = &strings.Builder{}\n\t\t\tvar enc = NewEncoder(b)\n\t\t\tenc.Encode(EncodeArrayFunc(func(enc *Encoder) {\n\t\t\t\tenc.Uint8(testCase.v)\n\t\t\t\tenc.AddUint8(testCase.v)\n\t\t\t}))\n\t\t\tassert.Equal(t, testCase.expectedJSON, b.String())\n\t\t})\n\t}\n\tvar testCasesOmitEmpty = []struct {\n\t\tname         string\n\t\tv            uint8\n\t\texpectedJSON string\n\t}{\n\t\t{\n\t\t\tname:         \"basic\",\n\t\t\tv:            uint8(1),\n\t\t\texpectedJSON: \"[1,1]\",\n\t\t},\n\t\t{\n\t\t\tname:         \"big\",\n\t\t\tv:            math.MaxUint8,\n\t\t\texpectedJSON: \"[255,255]\",\n\t\t},\n\t\t{\n\t\t\tname:         \"big\",\n\t\t\tv:            uint8(0),\n\t\t\texpectedJSON: \"[]\",\n\t\t},\n\t}\n\tfor _, testCase := range testCasesOmitEmpty {\n\t\tt.Run(testCase.name, func(t *testing.T) {\n\t\t\tvar b = &strings.Builder{}\n\t\t\tvar enc = NewEncoder(b)\n\t\t\tenc.Encode(EncodeArrayFunc(func(enc *Encoder) {\n\t\t\t\tenc.Uint8OmitEmpty(testCase.v)\n\t\t\t\tenc.AddUint8OmitEmpty(testCase.v)\n\t\t\t}))\n\t\t\tassert.Equal(t, testCase.expectedJSON, b.String())\n\t\t})\n\t}\n\tvar testCasesKeyBasic = []struct {\n\t\tname         string\n\t\tv            uint8\n\t\texpectedJSON string\n\t}{\n\t\t{\n\t\t\tname:         \"basic\",\n\t\t\tv:            uint8(1),\n\t\t\texpectedJSON: `{\"foo\":1,\"bar\":1}`,\n\t\t},\n\t\t{\n\t\t\tname:         \"big\",\n\t\t\tv:            math.MaxUint8,\n\t\t\texpectedJSON: `{\"foo\":255,\"bar\":255}`,\n\t\t},\n\t\t{\n\t\t\tname:         \"big\",\n\t\t\tv:            uint8(0),\n\t\t\texpectedJSON: `{\"foo\":0,\"bar\":0}`,\n\t\t},\n\t}\n\tfor _, testCase := range testCasesKeyBasic {\n\t\tt.Run(testCase.name, func(t *testing.T) {\n\t\t\tvar b = &strings.Builder{}\n\t\t\tvar enc = NewEncoder(b)\n\t\t\tenc.Encode(EncodeObjectFunc(func(enc *Encoder) {\n\t\t\t\tenc.Uint8Key(\"foo\", testCase.v)\n\t\t\t\tenc.AddUint8Key(\"bar\", testCase.v)\n\t\t\t}))\n\t\t\tassert.Equal(t, testCase.expectedJSON, b.String())\n\t\t})\n\t}\n\tvar testCasesKeyOmitEmpty = []struct {\n\t\tname         string\n\t\tv            uint8\n\t\texpectedJSON string\n\t}{\n\t\t{\n\t\t\tname:         \"basic\",\n\t\t\tv:            uint8(1),\n\t\t\texpectedJSON: `{\"foo\":1,\"bar\":1}`,\n\t\t},\n\t\t{\n\t\t\tname:         \"big\",\n\t\t\tv:            math.MaxUint8,\n\t\t\texpectedJSON: `{\"foo\":255,\"bar\":255}`,\n\t\t},\n\t\t{\n\t\t\tname:         \"big\",\n\t\t\tv:            uint8(0),\n\t\t\texpectedJSON: `{}`,\n\t\t},\n\t}\n\tfor _, testCase := range testCasesKeyOmitEmpty {\n\t\tt.Run(testCase.name, func(t *testing.T) {\n\t\t\tvar b = &strings.Builder{}\n\t\t\tvar enc = NewEncoder(b)\n\t\t\tenc.Encode(EncodeObjectFunc(func(enc *Encoder) {\n\t\t\t\tenc.Uint8KeyOmitEmpty(\"foo\", testCase.v)\n\t\t\t\tenc.AddUint8KeyOmitEmpty(\"bar\", testCase.v)\n\t\t\t}))\n\t\t\tassert.Equal(t, testCase.expectedJSON, b.String())\n\t\t})\n\t}\n}\n\nfunc TestEncoderUint64NullEmpty(t *testing.T) {\n\tvar testCases = []struct {\n\t\tname         string\n\t\tbaseJSON     string\n\t\texpectedJSON string\n\t}{\n\t\t{\n\t\t\tname:         \"basic 1st elem\",\n\t\t\tbaseJSON:     \"[\",\n\t\t\texpectedJSON: `[null,1`,\n\t\t},\n\t\t{\n\t\t\tname:         \"basic 2nd elem\",\n\t\t\tbaseJSON:     `[\"test\"`,\n\t\t\texpectedJSON: `[\"test\",null,1`,\n\t\t},\n\t}\n\tfor _, testCase := range testCases {\n\t\tt.Run(\"true\", func(t *testing.T) {\n\t\t\tvar b strings.Builder\n\t\t\tvar enc = NewEncoder(&b)\n\t\t\tenc.writeString(testCase.baseJSON)\n\t\t\tenc.Uint64NullEmpty(0)\n\t\t\tenc.AddUint64NullEmpty(1)\n\t\t\tenc.Write()\n\t\t\tassert.Equal(t, testCase.expectedJSON, b.String())\n\t\t})\n\t}\n}\n\nfunc TestEncoderUint64KeyNullEmpty(t *testing.T) {\n\tvar testCases = []struct {\n\t\tname         string\n\t\tbaseJSON     string\n\t\texpectedJSON string\n\t}{\n\t\t{\n\t\t\tname:         \"basic 1st elem\",\n\t\t\tbaseJSON:     \"{\",\n\t\t\texpectedJSON: `{\"foo\":null,\"bar\":1`,\n\t\t},\n\t\t{\n\t\t\tname:         \"basic 2nd elem\",\n\t\t\tbaseJSON:     `{\"test\":\"test\"`,\n\t\t\texpectedJSON: `{\"test\":\"test\",\"foo\":null,\"bar\":1`,\n\t\t},\n\t}\n\tfor _, testCase := range testCases {\n\t\tt.Run(testCase.name, func(t *testing.T) {\n\t\t\tvar b strings.Builder\n\t\t\tvar enc = NewEncoder(&b)\n\t\t\tenc.writeString(testCase.baseJSON)\n\t\t\tenc.Uint64KeyNullEmpty(\"foo\", 0)\n\t\t\tenc.AddUint64KeyNullEmpty(\"bar\", 1)\n\t\t\tenc.Write()\n\t\t\tassert.Equal(t, testCase.expectedJSON, b.String())\n\t\t})\n\t}\n}\n\nfunc TestEncoderUint32NullEmpty(t *testing.T) {\n\tvar testCases = []struct {\n\t\tname         string\n\t\tbaseJSON     string\n\t\texpectedJSON string\n\t}{\n\t\t{\n\t\t\tname:         \"basic 1st elem\",\n\t\t\tbaseJSON:     \"[\",\n\t\t\texpectedJSON: `[null,1`,\n\t\t},\n\t\t{\n\t\t\tname:         \"basic 2nd elem\",\n\t\t\tbaseJSON:     `[\"test\"`,\n\t\t\texpectedJSON: `[\"test\",null,1`,\n\t\t},\n\t}\n\tfor _, testCase := range testCases {\n\t\tt.Run(\"true\", func(t *testing.T) {\n\t\t\tvar b strings.Builder\n\t\t\tvar enc = NewEncoder(&b)\n\t\t\tenc.writeString(testCase.baseJSON)\n\t\t\tenc.Uint32NullEmpty(0)\n\t\t\tenc.AddUint32NullEmpty(1)\n\t\t\tenc.Write()\n\t\t\tassert.Equal(t, testCase.expectedJSON, b.String())\n\t\t})\n\t}\n}\n\nfunc TestEncoderUint32KeyNullEmpty(t *testing.T) {\n\tvar testCases = []struct {\n\t\tname         string\n\t\tbaseJSON     string\n\t\texpectedJSON string\n\t}{\n\t\t{\n\t\t\tname:         \"basic 1st elem\",\n\t\t\tbaseJSON:     \"{\",\n\t\t\texpectedJSON: `{\"foo\":null,\"bar\":1`,\n\t\t},\n\t\t{\n\t\t\tname:         \"basic 2nd elem\",\n\t\t\tbaseJSON:     `{\"test\":\"test\"`,\n\t\t\texpectedJSON: `{\"test\":\"test\",\"foo\":null,\"bar\":1`,\n\t\t},\n\t}\n\tfor _, testCase := range testCases {\n\t\tt.Run(testCase.name, func(t *testing.T) {\n\t\t\tvar b strings.Builder\n\t\t\tvar enc = NewEncoder(&b)\n\t\t\tenc.writeString(testCase.baseJSON)\n\t\t\tenc.AddUint32KeyNullEmpty(\"foo\", 0)\n\t\t\tenc.Uint32KeyNullEmpty(\"bar\", uint32(1))\n\t\t\tenc.Write()\n\t\t\tassert.Equal(t, testCase.expectedJSON, b.String())\n\t\t})\n\t}\n}\n\nfunc TestEncoderUint16NullEmpty(t *testing.T) {\n\tvar testCases = []struct {\n\t\tname         string\n\t\tbaseJSON     string\n\t\texpectedJSON string\n\t}{\n\t\t{\n\t\t\tname:         \"basic 1st elem\",\n\t\t\tbaseJSON:     \"[\",\n\t\t\texpectedJSON: `[null,1`,\n\t\t},\n\t\t{\n\t\t\tname:         \"basic 2nd elem\",\n\t\t\tbaseJSON:     `[\"test\"`,\n\t\t\texpectedJSON: `[\"test\",null,1`,\n\t\t},\n\t}\n\tfor _, testCase := range testCases {\n\t\tt.Run(\"true\", func(t *testing.T) {\n\t\t\tvar b strings.Builder\n\t\t\tvar enc = NewEncoder(&b)\n\t\t\tenc.writeString(testCase.baseJSON)\n\t\t\tenc.AddUint16NullEmpty(0)\n\t\t\tenc.Uint16NullEmpty(1)\n\t\t\tenc.Write()\n\t\t\tassert.Equal(t, testCase.expectedJSON, b.String())\n\t\t})\n\t}\n}\n\nfunc TestEncoderUint16KeyNullEmpty(t *testing.T) {\n\tvar testCases = []struct {\n\t\tname         string\n\t\tbaseJSON     string\n\t\texpectedJSON string\n\t}{\n\t\t{\n\t\t\tname:         \"basic 1st elem\",\n\t\t\tbaseJSON:     \"{\",\n\t\t\texpectedJSON: `{\"foo\":null,\"bar\":1`,\n\t\t},\n\t\t{\n\t\t\tname:         \"basic 2nd elem\",\n\t\t\tbaseJSON:     `{\"test\":\"test\"`,\n\t\t\texpectedJSON: `{\"test\":\"test\",\"foo\":null,\"bar\":1`,\n\t\t},\n\t}\n\tfor _, testCase := range testCases {\n\t\tt.Run(testCase.name, func(t *testing.T) {\n\t\t\tvar b strings.Builder\n\t\t\tvar enc = NewEncoder(&b)\n\t\t\tenc.writeString(testCase.baseJSON)\n\t\t\tenc.AddUint16KeyNullEmpty(\"foo\", 0)\n\t\t\tenc.Uint16KeyNullEmpty(\"bar\", uint16(1))\n\t\t\tenc.Write()\n\t\t\tassert.Equal(t, testCase.expectedJSON, b.String())\n\t\t})\n\t}\n}\n\nfunc TestEncoderUint8NullEmpty(t *testing.T) {\n\tvar testCases = []struct {\n\t\tname         string\n\t\tbaseJSON     string\n\t\texpectedJSON string\n\t}{\n\t\t{\n\t\t\tname:         \"basic 1st elem\",\n\t\t\tbaseJSON:     \"[\",\n\t\t\texpectedJSON: `[null,1`,\n\t\t},\n\t\t{\n\t\t\tname:         \"basic 2nd elem\",\n\t\t\tbaseJSON:     `[\"test\"`,\n\t\t\texpectedJSON: `[\"test\",null,1`,\n\t\t},\n\t}\n\tfor _, testCase := range testCases {\n\t\tt.Run(\"true\", func(t *testing.T) {\n\t\t\tvar b strings.Builder\n\t\t\tvar enc = NewEncoder(&b)\n\t\t\tenc.writeString(testCase.baseJSON)\n\t\t\tenc.AddUint8NullEmpty(0)\n\t\t\tenc.Uint8NullEmpty(1)\n\t\t\tenc.Write()\n\t\t\tassert.Equal(t, testCase.expectedJSON, b.String())\n\t\t})\n\t}\n}\n\nfunc TestEncoderUint8KeyNullEmpty(t *testing.T) {\n\tvar testCases = []struct {\n\t\tname         string\n\t\tbaseJSON     string\n\t\texpectedJSON string\n\t}{\n\t\t{\n\t\t\tname:         \"basic 1st elem\",\n\t\t\tbaseJSON:     \"{\",\n\t\t\texpectedJSON: `{\"foo\":null,\"bar\":1`,\n\t\t},\n\t\t{\n\t\t\tname:         \"basic 2nd elem\",\n\t\t\tbaseJSON:     `{\"test\":\"test\"`,\n\t\t\texpectedJSON: `{\"test\":\"test\",\"foo\":null,\"bar\":1`,\n\t\t},\n\t}\n\tfor _, testCase := range testCases {\n\t\tt.Run(testCase.name, func(t *testing.T) {\n\t\t\tvar b strings.Builder\n\t\t\tvar enc = NewEncoder(&b)\n\t\t\tenc.writeString(testCase.baseJSON)\n\t\t\tenc.AddUint8KeyNullEmpty(\"foo\", 0)\n\t\t\tenc.Uint8KeyNullEmpty(\"bar\", uint8(1))\n\t\t\tenc.Write()\n\t\t\tassert.Equal(t, testCase.expectedJSON, b.String())\n\t\t})\n\t}\n}\n"
        },
        {
          "name": "encode_object.go",
          "type": "blob",
          "size": 9.2841796875,
          "content": "package gojay\n\nvar objKeyStr = []byte(`\":\"`)\nvar objKeyObj = []byte(`\":{`)\nvar objKeyArr = []byte(`\":[`)\nvar objKey = []byte(`\":`)\n\n// EncodeObject encodes an object to JSON\nfunc (enc *Encoder) EncodeObject(v MarshalerJSONObject) error {\n\tif enc.isPooled == 1 {\n\t\tpanic(InvalidUsagePooledEncoderError(\"Invalid usage of pooled encoder\"))\n\t}\n\t_, err := enc.encodeObject(v)\n\tif err != nil {\n\t\tenc.err = err\n\t\treturn err\n\t}\n\t_, err = enc.Write()\n\tif err != nil {\n\t\tenc.err = err\n\t\treturn err\n\t}\n\treturn nil\n}\n\n// EncodeObjectKeys encodes an object to JSON\nfunc (enc *Encoder) EncodeObjectKeys(v MarshalerJSONObject, keys []string) error {\n\tif enc.isPooled == 1 {\n\t\tpanic(InvalidUsagePooledEncoderError(\"Invalid usage of pooled encoder\"))\n\t}\n\tenc.hasKeys = true\n\tenc.keys = keys\n\t_, err := enc.encodeObject(v)\n\tif err != nil {\n\t\tenc.err = err\n\t\treturn err\n\t}\n\t_, err = enc.Write()\n\tif err != nil {\n\t\tenc.err = err\n\t\treturn err\n\t}\n\treturn nil\n}\n\nfunc (enc *Encoder) encodeObject(v MarshalerJSONObject) ([]byte, error) {\n\tenc.grow(512)\n\tenc.writeByte('{')\n\tif !v.IsNil() {\n\t\tv.MarshalJSONObject(enc)\n\t}\n\tif enc.hasKeys {\n\t\tenc.hasKeys = false\n\t\tenc.keys = nil\n\t}\n\tenc.writeByte('}')\n\treturn enc.buf, enc.err\n}\n\n// AddObject adds an object to be encoded, must be used inside a slice or array encoding (does not encode a key)\n// value must implement MarshalerJSONObject\nfunc (enc *Encoder) AddObject(v MarshalerJSONObject) {\n\tenc.Object(v)\n}\n\n// AddObjectOmitEmpty adds an object to be encoded or skips it if IsNil returns true.\n// Must be used inside a slice or array encoding (does not encode a key)\n// value must implement MarshalerJSONObject\nfunc (enc *Encoder) AddObjectOmitEmpty(v MarshalerJSONObject) {\n\tenc.ObjectOmitEmpty(v)\n}\n\n// AddObjectNullEmpty adds an object to be encoded or skips it if IsNil returns true.\n// Must be used inside a slice or array encoding (does not encode a key)\n// value must implement MarshalerJSONObject\nfunc (enc *Encoder) AddObjectNullEmpty(v MarshalerJSONObject) {\n\tenc.ObjectNullEmpty(v)\n}\n\n// AddObjectKey adds a struct to be encoded, must be used inside an object as it will encode a key\n// value must implement MarshalerJSONObject\nfunc (enc *Encoder) AddObjectKey(key string, v MarshalerJSONObject) {\n\tenc.ObjectKey(key, v)\n}\n\n// AddObjectKeyOmitEmpty adds an object to be encoded or skips it if IsNil returns true.\n// Must be used inside a slice or array encoding (does not encode a key)\n// value must implement MarshalerJSONObject\nfunc (enc *Encoder) AddObjectKeyOmitEmpty(key string, v MarshalerJSONObject) {\n\tenc.ObjectKeyOmitEmpty(key, v)\n}\n\n// AddObjectKeyNullEmpty adds an object to be encoded or skips it if IsNil returns true.\n// Must be used inside a slice or array encoding (does not encode a key)\n// value must implement MarshalerJSONObject\nfunc (enc *Encoder) AddObjectKeyNullEmpty(key string, v MarshalerJSONObject) {\n\tenc.ObjectKeyNullEmpty(key, v)\n}\n\n// Object adds an object to be encoded, must be used inside a slice or array encoding (does not encode a key)\n// value must implement MarshalerJSONObject\nfunc (enc *Encoder) Object(v MarshalerJSONObject) {\n\tif v.IsNil() {\n\t\tenc.grow(2)\n\t\tr := enc.getPreviousRune()\n\t\tif r != '{' && r != '[' {\n\t\t\tenc.writeByte(',')\n\t\t}\n\t\tenc.writeByte('{')\n\t\tenc.writeByte('}')\n\t\treturn\n\t}\n\tenc.grow(4)\n\tr := enc.getPreviousRune()\n\tif r != '[' {\n\t\tenc.writeByte(',')\n\t}\n\tenc.writeByte('{')\n\n\tvar origHasKeys = enc.hasKeys\n\tvar origKeys = enc.keys\n\tenc.hasKeys = false\n\tenc.keys = nil\n\n\tv.MarshalJSONObject(enc)\n\n\tenc.hasKeys = origHasKeys\n\tenc.keys = origKeys\n\n\tenc.writeByte('}')\n}\n\n// ObjectWithKeys adds an object to be encoded, must be used inside a slice or array encoding (does not encode a key)\n// value must implement MarshalerJSONObject. It will only encode the keys in keys.\nfunc (enc *Encoder) ObjectWithKeys(v MarshalerJSONObject, keys []string) {\n\tif v.IsNil() {\n\t\tenc.grow(2)\n\t\tr := enc.getPreviousRune()\n\t\tif r != '{' && r != '[' {\n\t\t\tenc.writeByte(',')\n\t\t}\n\t\tenc.writeByte('{')\n\t\tenc.writeByte('}')\n\t\treturn\n\t}\n\tenc.grow(4)\n\tr := enc.getPreviousRune()\n\tif r != '[' {\n\t\tenc.writeByte(',')\n\t}\n\tenc.writeByte('{')\n\n\tvar origKeys = enc.keys\n\tvar origHasKeys = enc.hasKeys\n\tenc.hasKeys = true\n\tenc.keys = keys\n\n\tv.MarshalJSONObject(enc)\n\n\tenc.hasKeys = origHasKeys\n\tenc.keys = origKeys\n\n\tenc.writeByte('}')\n}\n\n// ObjectOmitEmpty adds an object to be encoded or skips it if IsNil returns true.\n// Must be used inside a slice or array encoding (does not encode a key)\n// value must implement MarshalerJSONObject\nfunc (enc *Encoder) ObjectOmitEmpty(v MarshalerJSONObject) {\n\tif v.IsNil() {\n\t\treturn\n\t}\n\tenc.grow(2)\n\tr := enc.getPreviousRune()\n\tif r != '[' {\n\t\tenc.writeByte(',')\n\t}\n\tenc.writeByte('{')\n\n\tvar origHasKeys = enc.hasKeys\n\tvar origKeys = enc.keys\n\tenc.hasKeys = false\n\tenc.keys = nil\n\n\tv.MarshalJSONObject(enc)\n\n\tenc.hasKeys = origHasKeys\n\tenc.keys = origKeys\n\n\tenc.writeByte('}')\n}\n\n// ObjectNullEmpty adds an object to be encoded or skips it if IsNil returns true.\n// Must be used inside a slice or array encoding (does not encode a key)\n// value must implement MarshalerJSONObject\nfunc (enc *Encoder) ObjectNullEmpty(v MarshalerJSONObject) {\n\tenc.grow(2)\n\tr := enc.getPreviousRune()\n\tif r != '[' {\n\t\tenc.writeByte(',')\n\t}\n\tif v.IsNil() {\n\t\tenc.writeBytes(nullBytes)\n\t\treturn\n\t}\n\tenc.writeByte('{')\n\n\tvar origHasKeys = enc.hasKeys\n\tvar origKeys = enc.keys\n\tenc.hasKeys = false\n\tenc.keys = nil\n\n\tv.MarshalJSONObject(enc)\n\n\tenc.hasKeys = origHasKeys\n\tenc.keys = origKeys\n\n\tenc.writeByte('}')\n}\n\n// ObjectKey adds a struct to be encoded, must be used inside an object as it will encode a key\n// value must implement MarshalerJSONObject\nfunc (enc *Encoder) ObjectKey(key string, v MarshalerJSONObject) {\n\tif enc.hasKeys {\n\t\tif !enc.keyExists(key) {\n\t\t\treturn\n\t\t}\n\t}\n\tif v.IsNil() {\n\t\tenc.grow(2 + len(key))\n\t\tr := enc.getPreviousRune()\n\t\tif r != '{' {\n\t\t\tenc.writeByte(',')\n\t\t}\n\t\tenc.writeByte('\"')\n\t\tenc.writeStringEscape(key)\n\t\tenc.writeBytes(objKeyObj)\n\t\tenc.writeByte('}')\n\t\treturn\n\t}\n\tenc.grow(5 + len(key))\n\tr := enc.getPreviousRune()\n\tif r != '{' {\n\t\tenc.writeByte(',')\n\t}\n\tenc.writeByte('\"')\n\tenc.writeStringEscape(key)\n\tenc.writeBytes(objKeyObj)\n\n\tvar origHasKeys = enc.hasKeys\n\tvar origKeys = enc.keys\n\tenc.hasKeys = false\n\tenc.keys = nil\n\n\tv.MarshalJSONObject(enc)\n\n\tenc.hasKeys = origHasKeys\n\tenc.keys = origKeys\n\n\tenc.writeByte('}')\n}\n\n// ObjectKeyWithKeys adds a struct to be encoded, must be used inside an object as it will encode a key.\n// Value must implement MarshalerJSONObject. It will only encode the keys in keys.\nfunc (enc *Encoder) ObjectKeyWithKeys(key string, value MarshalerJSONObject, keys []string) {\n\tif enc.hasKeys {\n\t\tif !enc.keyExists(key) {\n\t\t\treturn\n\t\t}\n\t}\n\tif value.IsNil() {\n\t\tenc.grow(2 + len(key))\n\t\tr := enc.getPreviousRune()\n\t\tif r != '{' {\n\t\t\tenc.writeByte(',')\n\t\t}\n\t\tenc.writeByte('\"')\n\t\tenc.writeStringEscape(key)\n\t\tenc.writeBytes(objKeyObj)\n\t\tenc.writeByte('}')\n\t\treturn\n\t}\n\tenc.grow(5 + len(key))\n\tr := enc.getPreviousRune()\n\tif r != '{' {\n\t\tenc.writeByte(',')\n\t}\n\tenc.writeByte('\"')\n\tenc.writeStringEscape(key)\n\tenc.writeBytes(objKeyObj)\n\tvar origKeys = enc.keys\n\tvar origHasKeys = enc.hasKeys\n\tenc.hasKeys = true\n\tenc.keys = keys\n\tvalue.MarshalJSONObject(enc)\n\tenc.hasKeys = origHasKeys\n\tenc.keys = origKeys\n\tenc.writeByte('}')\n}\n\n// ObjectKeyOmitEmpty adds an object to be encoded or skips it if IsNil returns true.\n// Must be used inside a slice or array encoding (does not encode a key)\n// value must implement MarshalerJSONObject\nfunc (enc *Encoder) ObjectKeyOmitEmpty(key string, v MarshalerJSONObject) {\n\tif enc.hasKeys {\n\t\tif !enc.keyExists(key) {\n\t\t\treturn\n\t\t}\n\t}\n\tif v.IsNil() {\n\t\treturn\n\t}\n\tenc.grow(5 + len(key))\n\tr := enc.getPreviousRune()\n\tif r != '{' {\n\t\tenc.writeByte(',')\n\t}\n\tenc.writeByte('\"')\n\tenc.writeStringEscape(key)\n\tenc.writeBytes(objKeyObj)\n\n\tvar origHasKeys = enc.hasKeys\n\tvar origKeys = enc.keys\n\tenc.hasKeys = false\n\tenc.keys = nil\n\n\tv.MarshalJSONObject(enc)\n\n\tenc.hasKeys = origHasKeys\n\tenc.keys = origKeys\n\n\tenc.writeByte('}')\n}\n\n// ObjectKeyNullEmpty adds an object to be encoded or skips it if IsNil returns true.\n// Must be used inside a slice or array encoding (does not encode a key)\n// value must implement MarshalerJSONObject\nfunc (enc *Encoder) ObjectKeyNullEmpty(key string, v MarshalerJSONObject) {\n\tif enc.hasKeys {\n\t\tif !enc.keyExists(key) {\n\t\t\treturn\n\t\t}\n\t}\n\tenc.grow(5 + len(key))\n\tr := enc.getPreviousRune()\n\tif r != '{' {\n\t\tenc.writeByte(',')\n\t}\n\tenc.writeByte('\"')\n\tenc.writeStringEscape(key)\n\tenc.writeBytes(objKey)\n\tif v.IsNil() {\n\t\tenc.writeBytes(nullBytes)\n\t\treturn\n\t}\n\tenc.writeByte('{')\n\n\tvar origHasKeys = enc.hasKeys\n\tvar origKeys = enc.keys\n\tenc.hasKeys = false\n\tenc.keys = nil\n\n\tv.MarshalJSONObject(enc)\n\n\tenc.hasKeys = origHasKeys\n\tenc.keys = origKeys\n\n\tenc.writeByte('}')\n}\n\n// EncodeObjectFunc is a custom func type implementing MarshaleObject.\n// Use it to cast a func(*Encoder) to Marshal an object.\n//\n//\tenc := gojay.NewEncoder(io.Writer)\n//\tenc.EncodeObject(gojay.EncodeObjectFunc(func(enc *gojay.Encoder) {\n//\t\tenc.AddStringKey(\"hello\", \"world\")\n//\t}))\ntype EncodeObjectFunc func(*Encoder)\n\n// MarshalJSONObject implements MarshalerJSONObject.\nfunc (f EncodeObjectFunc) MarshalJSONObject(enc *Encoder) {\n\tf(enc)\n}\n\n// IsNil implements MarshalerJSONObject.\nfunc (f EncodeObjectFunc) IsNil() bool {\n\treturn f == nil\n}\n\nfunc (enc *Encoder) keyExists(k string) bool {\n\tif enc.keys == nil {\n\t\treturn false\n\t}\n\tfor _, key := range enc.keys {\n\t\tif key == k {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n"
        },
        {
          "name": "encode_object_test.go",
          "type": "blob",
          "size": 23.37109375,
          "content": "package gojay\n\nimport (\n\t\"strings\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\ntype testObjectWithUnknownType struct {\n\tunknownType struct{}\n}\n\nfunc (t *testObjectWithUnknownType) IsNil() bool {\n\treturn t == nil\n}\n\nfunc (t *testObjectWithUnknownType) MarshalJSONObject(enc *Encoder) {\n\tenc.AddInterfaceKey(\"unknownType\", t.unknownType)\n}\n\ntype TestEncoding struct {\n\ttest          string\n\ttest2         string\n\ttestInt       int\n\ttestBool      bool\n\ttestF32       float32\n\ttestF64       float64\n\ttestInterface interface{}\n\ttestArr       TestEncodingArr\n\tsub           *SubObject\n}\n\nfunc (t *TestEncoding) IsNil() bool {\n\treturn t == nil\n}\n\nfunc (t *TestEncoding) MarshalJSONObject(enc *Encoder) {\n\tenc.AddStringKey(\"test\", t.test)\n\tenc.AddStringKey(\"test2\", t.test2)\n\tenc.AddIntKey(\"testInt\", t.testInt)\n\tenc.AddBoolKey(\"testBool\", t.testBool)\n\tenc.AddInterfaceKey(\"testArr\", t.testArr)\n\tenc.AddInterfaceKey(\"testF64\", t.testF64)\n\tenc.AddInterfaceKey(\"testF32\", t.testF32)\n\tenc.AddInterfaceKey(\"testInterface\", t.testInterface)\n\tenc.AddInterfaceKey(\"sub\", t.sub)\n}\n\ntype SubObject struct {\n\ttest1    int\n\ttest2    string\n\ttest3    float64\n\ttestBool bool\n\tsub      *SubObject\n}\n\nfunc (t *SubObject) IsNil() bool {\n\treturn t == nil\n}\n\nfunc (t *SubObject) MarshalJSONObject(enc *Encoder) {\n\tenc.AddIntKey(\"test1\", t.test1)\n\tenc.AddStringKey(\"test2\", t.test2)\n\tenc.AddFloatKey(\"test3\", t.test3)\n\tenc.AddBoolKey(\"testBool\", t.testBool)\n\tenc.AddObjectKey(\"sub\", t.sub)\n}\n\ntype testEncodingObjInterfaces struct {\n\tinterfaceVal interface{}\n}\n\nfunc (t *testEncodingObjInterfaces) IsNil() bool {\n\treturn t == nil\n}\n\nfunc (t *testEncodingObjInterfaces) MarshalJSONObject(enc *Encoder) {\n\tenc.AddInterfaceKey(\"interfaceVal\", t.interfaceVal)\n}\n\nfunc TestEncoderObjectEncodeAPI(t *testing.T) {\n\tt.Run(\"encode-basic\", func(t *testing.T) {\n\t\tbuilder := &strings.Builder{}\n\t\tenc := NewEncoder(builder)\n\t\terr := enc.EncodeObject(&testObject{\n\t\t\t\"漢字\", nil, 1, nil, 1, nil, 1, nil, 1, nil, 1, nil, 1, nil, 1, nil,\n\t\t\t1, nil, 1, nil, 1.1, nil, 1.1, nil, true, nil,\n\t\t\t&testObject{}, testSliceInts{}, interface{}(\"test\"),\n\t\t})\n\t\tassert.Nil(t, err, \"Error should be nil\")\n\t\tassert.Equal(\n\t\t\tt,\n\t\t\t`{\"testStr\":\"漢字\",\"testInt\":1,\"testInt64\":1,\"testInt32\":1,\"testInt16\":1,\"testInt8\":1,\"testUint64\":1,\"testUint32\":1,\"testUint16\":1,\"testUint8\":1,\"testFloat64\":1.1,\"testFloat32\":1.1,\"testBool\":true}`,\n\t\t\tbuilder.String(),\n\t\t\t\"Result of marshalling is different as the one expected\",\n\t\t)\n\t})\n}\n\nfunc TestEncoderObjectMarshalAPI(t *testing.T) {\n\tt.Run(\"marshal-basic\", func(t *testing.T) {\n\t\tr, err := Marshal(&testObject{\n\t\t\t\"漢字\", nil, 1, nil, 1, nil, 1, nil, 1, nil, 1, nil, 1, nil, 1,\n\t\t\tnil, 1, nil, 1, nil, 1.1, nil, 1.1, nil, true, nil,\n\t\t\t&testObject{}, testSliceInts{}, []interface{}{\"h\", \"o\", \"l\", \"a\"},\n\t\t})\n\t\tassert.Nil(t, err, \"Error should be nil\")\n\t\tassert.Equal(\n\t\t\tt,\n\t\t\t`{\"testStr\":\"漢字\",\"testInt\":1,\"testInt64\":1,\"testInt32\":1,\"testInt16\":1,\"testInt8\":1,\"testUint64\":1,\"testUint32\":1,\"testUint16\":1,\"testUint8\":1,\"testFloat64\":1.1,\"testFloat32\":1.1,\"testBool\":true}`,\n\t\t\tstring(r),\n\t\t\t\"Result of marshalling is different as the one expected\",\n\t\t)\n\t})\n\n\tt.Run(\"marshal-complex\", func(t *testing.T) {\n\t\tv := &TestEncoding{\n\t\t\ttest:          \"hello world\",\n\t\t\ttest2:         \"foobar\",\n\t\t\ttestInt:       1,\n\t\t\ttestBool:      true,\n\t\t\ttestF32:       120.53,\n\t\t\ttestF64:       120.15,\n\t\t\ttestInterface: true,\n\t\t\ttestArr: TestEncodingArr{\n\t\t\t\t&TestEncoding{\n\t\t\t\t\ttest: \"1\",\n\t\t\t\t},\n\t\t\t},\n\t\t\tsub: &SubObject{\n\t\t\t\ttest1:    10,\n\t\t\t\ttest2:    \"hello world\",\n\t\t\t\ttest3:    1.23543,\n\t\t\t\ttestBool: true,\n\t\t\t\tsub: &SubObject{\n\t\t\t\t\ttest1:    10,\n\t\t\t\t\ttestBool: false,\n\t\t\t\t\ttest2:    \"hello world\",\n\t\t\t\t},\n\t\t\t},\n\t\t}\n\t\tr, err := MarshalJSONObject(v)\n\t\tassert.Nil(t, err, \"Error should be nil\")\n\t\tassert.Equal(\n\t\t\tt,\n\t\t\t`{\"test\":\"hello world\",\"test2\":\"foobar\",\"testInt\":1,\"testBool\":true,\"testArr\":[{\"test\":\"1\",\"test2\":\"\",\"testInt\":0,\"testBool\":false,\"testArr\":[],\"testF64\":0,\"testF32\":0,\"sub\":{}}],\"testF64\":120.15,\"testF32\":120.53,\"testInterface\":true,\"sub\":{\"test1\":10,\"test2\":\"hello world\",\"test3\":1.23543,\"testBool\":true,\"sub\":{\"test1\":10,\"test2\":\"hello world\",\"test3\":0,\"testBool\":false,\"sub\":{}}}}`,\n\t\t\tstring(r),\n\t\t\t\"Result of marshalling is different as the one expected\",\n\t\t)\n\t})\n\n\tt.Run(\"marshal-interface-string\", func(t *testing.T) {\n\t\tv := testEncodingObjInterfaces{\"string\"}\n\t\tr, err := Marshal(&v)\n\t\tassert.Nil(t, err, \"Error should be nil\")\n\t\tassert.Equal(\n\t\t\tt,\n\t\t\t`{\"interfaceVal\":\"string\"}`,\n\t\t\tstring(r),\n\t\t\t\"Result of marshalling is different as the one expected\")\n\t})\n\tt.Run(\"marshal-interface-int\", func(t *testing.T) {\n\t\tv := testEncodingObjInterfaces{1}\n\t\tr, err := Marshal(&v)\n\t\tassert.Nil(t, err, \"Error should be nil\")\n\t\tassert.Equal(\n\t\t\tt,\n\t\t\t`{\"interfaceVal\":1}`,\n\t\t\tstring(r),\n\t\t\t\"Result of marshalling is different as the one expected\")\n\t})\n\tt.Run(\"marshal-interface-int64\", func(t *testing.T) {\n\t\tv := testEncodingObjInterfaces{int64(1)}\n\t\tr, err := Marshal(&v)\n\t\tassert.Nil(t, err, \"Error should be nil\")\n\t\tassert.Equal(\n\t\t\tt,\n\t\t\t`{\"interfaceVal\":1}`,\n\t\t\tstring(r),\n\t\t\t\"Result of marshalling is different as the one expected\")\n\t})\n\tt.Run(\"marshal-interface-int32\", func(t *testing.T) {\n\t\tv := testEncodingObjInterfaces{int32(1)}\n\t\tr, err := Marshal(&v)\n\t\tassert.Nil(t, err, \"Error should be nil\")\n\t\tassert.Equal(\n\t\t\tt,\n\t\t\t`{\"interfaceVal\":1}`,\n\t\t\tstring(r),\n\t\t\t\"Result of marshalling is different as the one expected\")\n\t})\n\tt.Run(\"marshal-interface-int16\", func(t *testing.T) {\n\t\tv := testEncodingObjInterfaces{int16(1)}\n\t\tr, err := Marshal(&v)\n\t\tassert.Nil(t, err, \"Error should be nil\")\n\t\tassert.Equal(\n\t\t\tt,\n\t\t\t`{\"interfaceVal\":1}`,\n\t\t\tstring(r),\n\t\t\t\"Result of marshalling is different as the one expected\")\n\t})\n\tt.Run(\"marshal-interface-int8\", func(t *testing.T) {\n\t\tv := testEncodingObjInterfaces{int8(1)}\n\t\tr, err := Marshal(&v)\n\t\tassert.Nil(t, err, \"Error should be nil\")\n\t\tassert.Equal(\n\t\t\tt,\n\t\t\t`{\"interfaceVal\":1}`,\n\t\t\tstring(r),\n\t\t\t\"Result of marshalling is different as the one expected\")\n\t})\n\tt.Run(\"marshal-interface-uint64\", func(t *testing.T) {\n\t\tv := testEncodingObjInterfaces{uint64(1)}\n\t\tr, err := Marshal(&v)\n\t\tassert.Nil(t, err, \"Error should be nil\")\n\t\tassert.Equal(\n\t\t\tt,\n\t\t\t`{\"interfaceVal\":1}`,\n\t\t\tstring(r),\n\t\t\t\"Result of marshalling is different as the one expected\")\n\t})\n\tt.Run(\"marshal-interface-uint32\", func(t *testing.T) {\n\t\tv := testEncodingObjInterfaces{uint32(1)}\n\t\tr, err := Marshal(&v)\n\t\tassert.Nil(t, err, \"Error should be nil\")\n\t\tassert.Equal(\n\t\t\tt,\n\t\t\t`{\"interfaceVal\":1}`,\n\t\t\tstring(r),\n\t\t\t\"Result of marshalling is different as the one expected\")\n\t})\n\tt.Run(\"marshal-interface-uint16\", func(t *testing.T) {\n\t\tv := testEncodingObjInterfaces{uint16(1)}\n\t\tr, err := Marshal(&v)\n\t\tassert.Nil(t, err, \"Error should be nil\")\n\t\tassert.Equal(\n\t\t\tt,\n\t\t\t`{\"interfaceVal\":1}`,\n\t\t\tstring(r),\n\t\t\t\"Result of marshalling is different as the one expected\")\n\t})\n\tt.Run(\"marshal-interface-uint8\", func(t *testing.T) {\n\t\tv := testEncodingObjInterfaces{uint8(1)}\n\t\tr, err := Marshal(&v)\n\t\tassert.Nil(t, err, \"Error should be nil\")\n\t\tassert.Equal(\n\t\t\tt,\n\t\t\t`{\"interfaceVal\":1}`,\n\t\t\tstring(r),\n\t\t\t\"Result of marshalling is different as the one expected\")\n\t})\n\tt.Run(\"marshal-interface-float64\", func(t *testing.T) {\n\t\tv := testEncodingObjInterfaces{float64(1.1)}\n\t\tr, err := Marshal(&v)\n\t\tassert.Nil(t, err, \"Error should be nil\")\n\t\tassert.Equal(\n\t\t\tt,\n\t\t\t`{\"interfaceVal\":1.1}`,\n\t\t\tstring(r),\n\t\t\t\"Result of marshalling is different as the one expected\")\n\t})\n\tt.Run(\"marshal-interface-float32\", func(t *testing.T) {\n\t\tv := testEncodingObjInterfaces{float32(1.1)}\n\t\tr, err := Marshal(&v)\n\t\tassert.Nil(t, err, \"Error should be nil\")\n\t\tassert.Equal(\n\t\t\tt,\n\t\t\t`{\"interfaceVal\":1.1}`,\n\t\t\tstring(r),\n\t\t\t\"Result of marshalling is different as the one expected\")\n\t})\n\tt.Run(\"marshal-object-func\", func(t *testing.T) {\n\t\tf := EncodeObjectFunc(func(enc *Encoder) {\n\t\t\tenc.AddStringKeyOmitEmpty(\"test\", \"test\")\n\t\t})\n\t\tr, err := Marshal(f)\n\t\tassert.Nil(t, err, \"Error should be nil\")\n\t\tassert.Equal(\n\t\t\tt,\n\t\t\t`{\"test\":\"test\"}`,\n\t\t\tstring(r),\n\t\t\t\"Result of marshalling is different as the one expected\")\n\t})\n\tt.Run(\"marshal-any-object\", func(t *testing.T) {\n\t\ttest := struct {\n\t\t\tFoo string\n\t\t\tBar int\n\t\t}{\n\t\t\t\"test\",\n\t\t\t100,\n\t\t}\n\t\tr, err := MarshalAny(test)\n\t\tassert.Nil(t, err, \"Error should be nil\")\n\t\tassert.Equal(\n\t\t\tt,\n\t\t\t`{\"Foo\":\"test\",\"Bar\":100}`,\n\t\t\tstring(r),\n\t\t\t\"Result of marshalling is different as the one expected\")\n\t})\n}\n\ntype TestObectOmitEmpty struct {\n\tnonNiler           int\n\ttestInt            int\n\ttestFloat          float64\n\ttestFloat32        float32\n\ttestString         string\n\ttestBool           bool\n\ttestObectOmitEmpty *TestObectOmitEmpty\n\ttestObect          *TestObectOmitEmpty\n}\n\nfunc (t *TestObectOmitEmpty) IsNil() bool {\n\treturn t == nil\n}\n\nfunc (t *TestObectOmitEmpty) MarshalJSONObject(enc *Encoder) {\n\tenc.AddIntKeyOmitEmpty(\"testInt\", t.testInt)\n\tenc.AddIntKeyOmitEmpty(\"testIntNotEmpty\", 1)\n\tenc.AddFloatKeyOmitEmpty(\"testFloat\", t.testFloat)\n\tenc.AddFloatKeyOmitEmpty(\"testFloatNotEmpty\", 1.1)\n\tenc.AddFloat32KeyOmitEmpty(\"testFloat32\", t.testFloat32)\n\tenc.AddFloat32KeyOmitEmpty(\"testFloat32NotEmpty\", 1.1)\n\tenc.AddStringKeyOmitEmpty(\"testString\", t.testString)\n\tenc.AddStringKeyOmitEmpty(\"testStringNotEmpty\", \"foo\")\n\tenc.AddBoolKeyOmitEmpty(\"testBool\", t.testBool)\n\tenc.AddBoolKeyOmitEmpty(\"testBoolNotEmpty\", true)\n\tenc.AddObjectKeyOmitEmpty(\"testObect\", t.testObect)\n\tenc.AddObjectKeyOmitEmpty(\"testObectOmitEmpty\", t.testObectOmitEmpty)\n\tenc.AddArrayKeyOmitEmpty(\"testArrayOmitEmpty\", TestEncodingArrStrings{})\n\tenc.AddArrayKeyOmitEmpty(\"testArray\", TestEncodingArrStrings{\"foo\"})\n}\n\ntype TestObectOmitEmptyInterface struct{}\n\nfunc (t *TestObectOmitEmptyInterface) IsNil() bool {\n\treturn t == nil\n}\n\nfunc (t *TestObectOmitEmptyInterface) MarshalJSONObject(enc *Encoder) {\n\tenc.AddInterfaceKeyOmitEmpty(\"testInt\", 0)\n\tenc.AddInterfaceKeyOmitEmpty(\"testInt64\", int64(0))\n\tenc.AddInterfaceKeyOmitEmpty(\"testInt32\", int32(0))\n\tenc.AddInterfaceKeyOmitEmpty(\"testInt16\", int16(0))\n\tenc.AddInterfaceKeyOmitEmpty(\"testInt8\", int8(0))\n\tenc.AddInterfaceKeyOmitEmpty(\"testUint8\", uint8(0))\n\tenc.AddInterfaceKeyOmitEmpty(\"testUint16\", uint16(0))\n\tenc.AddInterfaceKeyOmitEmpty(\"testUint32\", uint32(0))\n\tenc.AddInterfaceKeyOmitEmpty(\"testUint64\", uint64(0))\n\tenc.AddInterfaceKeyOmitEmpty(\"testIntNotEmpty\", 1)\n\tenc.AddInterfaceKeyOmitEmpty(\"testFloat\", 0)\n\tenc.AddInterfaceKeyOmitEmpty(\"testFloatNotEmpty\", 1.1)\n\tenc.AddInterfaceKeyOmitEmpty(\"testFloat32\", float32(0))\n\tenc.AddInterfaceKeyOmitEmpty(\"testFloat32NotEmpty\", float32(1.1))\n\tenc.AddInterfaceKeyOmitEmpty(\"testString\", \"\")\n\tenc.AddInterfaceKeyOmitEmpty(\"testStringNotEmpty\", \"foo\")\n\tenc.AddInterfaceKeyOmitEmpty(\"testBool\", false)\n\tenc.AddInterfaceKeyOmitEmpty(\"testBoolNotEmpty\", true)\n\tenc.AddInterfaceKeyOmitEmpty(\"testObectOmitEmpty\", nil)\n\tenc.AddInterfaceKeyOmitEmpty(\"testObect\", &TestEncoding{})\n\tenc.AddInterfaceKeyOmitEmpty(\"testArr\", &TestEncodingArrStrings{})\n}\n\nfunc TestEncoderObjectOmitEmpty(t *testing.T) {\n\tt.Run(\"encoder-omit-empty-all-types\", func(t *testing.T) {\n\t\tv := &TestObectOmitEmpty{\n\t\t\tnonNiler:  1,\n\t\t\ttestInt:   0,\n\t\t\ttestObect: &TestObectOmitEmpty{testInt: 1},\n\t\t}\n\t\tr, err := MarshalJSONObject(v)\n\t\tassert.Nil(t, err, \"Error should be nil\")\n\t\tassert.Equal(\n\t\t\tt,\n\t\t\t`{\"testIntNotEmpty\":1,\"testFloatNotEmpty\":1.1,\"testFloat32NotEmpty\":1.1,\"testStringNotEmpty\":\"foo\",\"testBoolNotEmpty\":true,\"testObect\":{\"testInt\":1,\"testIntNotEmpty\":1,\"testFloatNotEmpty\":1.1,\"testFloat32NotEmpty\":1.1,\"testStringNotEmpty\":\"foo\",\"testBoolNotEmpty\":true,\"testArray\":[\"foo\"]},\"testArray\":[\"foo\"]}`,\n\t\t\tstring(r),\n\t\t\t\"Result of marshalling is different as the one expected\",\n\t\t)\n\t})\n\n\tt.Run(\"encoder-omit-empty-interface\", func(t *testing.T) {\n\t\tv := &TestObectOmitEmptyInterface{}\n\t\tr, err := MarshalJSONObject(v)\n\t\tassert.Nil(t, err, \"Error should be nil\")\n\t\tassert.Equal(\n\t\t\tt,\n\t\t\t`{\"testIntNotEmpty\":1,\"testFloatNotEmpty\":1.1,\"testFloat32NotEmpty\":1.1,\"testStringNotEmpty\":\"foo\",\"testBoolNotEmpty\":true,\"testObect\":{\"test\":\"\",\"test2\":\"\",\"testInt\":0,\"testBool\":false,\"testArr\":[],\"testF64\":0,\"testF32\":0,\"sub\":{}}}`,\n\t\t\tstring(r),\n\t\t\t\"Result of marshalling is different as the one expected\",\n\t\t)\n\t})\n}\n\nfunc TestEncoderObjectEncodeAPIError(t *testing.T) {\n\tt.Run(\"interface-key-error\", func(t *testing.T) {\n\t\tbuilder := &strings.Builder{}\n\t\tenc := NewEncoder(builder)\n\t\terr := enc.EncodeObject(&testObjectWithUnknownType{struct{}{}})\n\t\tassert.NotNil(t, err, \"Error should not be nil\")\n\t\tassert.Equal(t, \"Invalid type struct {} provided to Marshal\", err.Error(), \"err.Error() should be 'Invalid type struct {} provided to Marshal'\")\n\t})\n\tt.Run(\"write-error\", func(t *testing.T) {\n\t\tw := TestWriterError(\"\")\n\t\tenc := NewEncoder(w)\n\t\terr := enc.EncodeObject(&testObject{})\n\t\tassert.NotNil(t, err, \"Error should not be nil\")\n\t\tassert.Equal(t, \"Test Error\", err.Error(), \"err.Error() should be 'Test Error'\")\n\t})\n\tt.Run(\"interface-error\", func(t *testing.T) {\n\t\tbuilder := &strings.Builder{}\n\t\tenc := NewEncoder(builder)\n\t\tenc.AddInterfaceKeyOmitEmpty(\"test\", struct{}{})\n\t\tassert.NotNil(t, enc.err, \"enc.Err() should not be nil\")\n\t})\n\tt.Run(\"pool-error\", func(t *testing.T) {\n\t\tv := &TestEncoding{}\n\t\tenc := BorrowEncoder(nil)\n\t\tenc.isPooled = 1\n\t\tdefer func() {\n\t\t\terr := recover()\n\t\t\tassert.NotNil(t, err, \"err shouldnt be nil\")\n\t\t\tassert.IsType(t, InvalidUsagePooledEncoderError(\"\"), err, \"err should be of type InvalidUsagePooledEncoderError\")\n\t\t\tassert.Equal(t, \"Invalid usage of pooled encoder\", err.(InvalidUsagePooledEncoderError).Error(), \"err should be of type InvalidUsagePooledDecoderError\")\n\t\t}()\n\t\t_ = enc.EncodeObject(v)\n\t\tassert.True(t, false, \"should not be called as it should have panicked\")\n\t})\n}\n\nfunc TestEncoderObjectKeyNullEmpty(t *testing.T) {\n\tvar testCases = []struct {\n\t\tname         string\n\t\tbaseJSON     string\n\t\texpectedJSON string\n\t}{\n\t\t{\n\t\t\tname:         \"basic 1st elem\",\n\t\t\tbaseJSON:     \"{\",\n\t\t\texpectedJSON: `{\"foo\":null,\"bar\":{\"test\":\"\",\"test2\":\"\",\"testInt\":0,\"testBool\":false,\"testArr\":[],\"testF64\":0,\"testF32\":0,\"sub\":{}}`,\n\t\t},\n\t\t{\n\t\t\tname:         \"basic 2nd elem\",\n\t\t\tbaseJSON:     `{\"test\":\"test\"`,\n\t\t\texpectedJSON: `{\"test\":\"test\",\"foo\":null,\"bar\":{\"test\":\"\",\"test2\":\"\",\"testInt\":0,\"testBool\":false,\"testArr\":[],\"testF64\":0,\"testF32\":0,\"sub\":{}}`,\n\t\t},\n\t}\n\tfor _, testCase := range testCases {\n\t\tt.Run(testCase.name, func(t *testing.T) {\n\t\t\tvar b strings.Builder\n\t\t\tvar enc = NewEncoder(&b)\n\t\t\tenc.writeString(testCase.baseJSON)\n\t\t\tenc.AddObjectKeyNullEmpty(\"foo\", (*TestEncoding)(nil))\n\t\t\tenc.ObjectKeyNullEmpty(\"bar\", &TestEncoding{})\n\t\t\tenc.Write()\n\t\t\tassert.Equal(t, testCase.expectedJSON, b.String())\n\t\t})\n\t}\n}\n\nfunc TestEncoderObjectNullEmpty(t *testing.T) {\n\tvar testCases = []struct {\n\t\tname         string\n\t\tbaseJSON     string\n\t\texpectedJSON string\n\t}{\n\t\t{\n\t\t\tname:         \"basic 1st elem\",\n\t\t\tbaseJSON:     \"[\",\n\t\t\texpectedJSON: `[null,{\"test\":\"\",\"test2\":\"\",\"testInt\":0,\"testBool\":false,\"testArr\":[],\"testF64\":0,\"testF32\":0,\"sub\":{}}`,\n\t\t},\n\t\t{\n\t\t\tname:         \"basic 2nd elem\",\n\t\t\tbaseJSON:     `[\"test\"`,\n\t\t\texpectedJSON: `[\"test\",null,{\"test\":\"\",\"test2\":\"\",\"testInt\":0,\"testBool\":false,\"testArr\":[],\"testF64\":0,\"testF32\":0,\"sub\":{}}`,\n\t\t},\n\t}\n\tfor _, testCase := range testCases {\n\t\tt.Run(testCase.name, func(t *testing.T) {\n\t\t\tvar b strings.Builder\n\t\t\tvar enc = NewEncoder(&b)\n\t\t\tenc.writeString(testCase.baseJSON)\n\t\t\tenc.AddObjectNullEmpty((*TestEncoding)(nil))\n\t\t\tenc.ObjectNullEmpty(&TestEncoding{})\n\t\t\tenc.Write()\n\t\t\tassert.Equal(t, testCase.expectedJSON, b.String())\n\t\t})\n\t}\n}\n\ntype ObjectWithKeys struct {\n\tStr          string\n\tInt          int\n\tInt64        int64\n\tInt32        int32\n\tInt16        int16\n\tInt8         int8\n\tUint64       uint64\n\tUint32       uint32\n\tUint16       uint16\n\tUint8        uint8\n\tFloat64      float64\n\tFloat32      float32\n\tBool         bool\n\tObj          *ObjectWithKeys\n\tSlice        TestEncodingArrStrings\n\tTime         *time.Time\n\tEmbeddedJSON *EmbeddedJSON\n}\n\nfunc (o *ObjectWithKeys) MarshalJSONObject(enc *Encoder) {\n\tenc.StringKey(\"string\", o.Str)\n\tenc.StringKeyOmitEmpty(\"string\", o.Str)\n\tenc.StringKeyNullEmpty(\"string\", o.Str)\n\tenc.IntKey(\"int\", o.Int)\n\tenc.IntKeyOmitEmpty(\"int\", o.Int)\n\tenc.IntKeyNullEmpty(\"int\", o.Int)\n\tenc.Int64Key(\"int64\", o.Int64)\n\tenc.Int64KeyOmitEmpty(\"int64\", o.Int64)\n\tenc.Int64KeyNullEmpty(\"int64\", o.Int64)\n\tenc.Int32Key(\"int32\", o.Int32)\n\tenc.Int32KeyOmitEmpty(\"int32\", o.Int32)\n\tenc.Int32KeyNullEmpty(\"int32\", o.Int32)\n\tenc.Int16Key(\"int16\", o.Int16)\n\tenc.Int16KeyOmitEmpty(\"int16\", o.Int16)\n\tenc.Int16KeyNullEmpty(\"int16\", o.Int16)\n\tenc.Int8Key(\"int8\", o.Int8)\n\tenc.Int8KeyOmitEmpty(\"int8\", o.Int8)\n\tenc.Int8KeyNullEmpty(\"int8\", o.Int8)\n\tenc.Uint64KeyOmitEmpty(\"uint64\", o.Uint64)\n\tenc.Uint64KeyNullEmpty(\"uint64\", o.Uint64)\n\tenc.Uint64Key(\"uint64\", o.Uint64)\n\tenc.Uint32Key(\"uint32\", o.Uint32)\n\tenc.Uint32KeyOmitEmpty(\"uint32\", o.Uint32)\n\tenc.Uint32KeyNullEmpty(\"uint32\", o.Uint32)\n\tenc.Uint16KeyOmitEmpty(\"uint16\", o.Uint16)\n\tenc.Uint16KeyNullEmpty(\"uint16\", o.Uint16)\n\tenc.Uint16Key(\"uint16\", o.Uint16)\n\tenc.Uint8Key(\"uint8\", o.Uint8)\n\tenc.Uint8KeyOmitEmpty(\"uint8\", o.Uint8)\n\tenc.Uint8KeyNullEmpty(\"uint8\", o.Uint8)\n\tenc.Float64Key(\"float64\", o.Float64)\n\tenc.Float64KeyOmitEmpty(\"float64\", o.Float64)\n\tenc.Float64KeyNullEmpty(\"float64\", o.Float64)\n\tenc.Float32Key(\"float32\", o.Float32)\n\tenc.Float32KeyOmitEmpty(\"float32\", o.Float32)\n\tenc.Float32KeyNullEmpty(\"float32\", o.Float32)\n\tenc.BoolKey(\"bool\", o.Bool)\n\tenc.BoolKeyOmitEmpty(\"bool\", o.Bool)\n\tenc.BoolKeyNullEmpty(\"bool\", o.Bool)\n\tenc.ObjectKeyOmitEmpty(\"object\", o.Obj)\n\tenc.ObjectKeyNullEmpty(\"object\", o.Obj)\n\tenc.ObjectKey(\"object\", o.Obj)\n\tenc.ArrayKey(\"array\", o.Slice)\n\tenc.ArrayKeyOmitEmpty(\"array\", o.Slice)\n\tenc.ArrayKeyNullEmpty(\"array\", o.Slice)\n\tenc.TimeKey(\"time\", o.Time, time.RFC3339)\n\tenc.AddEmbeddedJSONKey(\"ejson\", o.EmbeddedJSON)\n\tenc.AddEmbeddedJSONKeyOmitEmpty(\"ejson\", o.EmbeddedJSON)\n\tenc.NullKey(\"null\")\n}\n\nfunc (o *ObjectWithKeys) IsNil() bool {\n\treturn o == nil\n}\n\ntype NilObject struct{}\n\nfunc (n *NilObject) MarshalJSONObject(enc *Encoder) {}\nfunc (n *NilObject) IsNil() bool                    { return true }\n\nfunc TestEncodeObjectWithKeys(t *testing.T) {\n\tt.Run(\n\t\t\"should not encode any key\",\n\t\tfunc(t *testing.T) {\n\t\t\tvar b strings.Builder\n\t\t\tvar enc = NewEncoder(&b)\n\t\t\tvar o = &ObjectWithKeys{}\n\t\t\tvar err = enc.EncodeObjectKeys(o, []string{})\n\t\t\tassert.Nil(t, err)\n\t\t\tassert.Equal(t, `{}`, b.String())\n\t\t},\n\t)\n\tt.Run(\n\t\t\"should encode some keys\",\n\t\tfunc(t *testing.T) {\n\t\t\tvar b strings.Builder\n\t\t\tvar enc = NewEncoder(&b)\n\t\t\tvar o = &ObjectWithKeys{Str: \"hello\", Int: 420}\n\t\t\tvar err = enc.EncodeObjectKeys(o, []string{\"string\", \"int\"})\n\t\t\tassert.Nil(t, err)\n\t\t\tassert.Equal(\n\t\t\t\tt,\n\t\t\t\t`{\"string\":\"hello\",\"string\":\"hello\",\"string\":\"hello\",\"int\":420,\"int\":420,\"int\":420}`,\n\t\t\t\tb.String(),\n\t\t\t)\n\t\t},\n\t)\n\tt.Run(\"write-error\", func(t *testing.T) {\n\t\tw := TestWriterError(\"\")\n\t\tenc := NewEncoder(w)\n\t\to := &ObjectWithKeys{Str: \"hello\", Int: 420}\n\t\terr := enc.EncodeObjectKeys(o, []string{\"string\", \"int\"})\n\t\tassert.NotNil(t, err, \"Error should not be nil\")\n\t\tassert.Equal(t, \"Test Error\", err.Error(), \"err.Error() should be 'Test Error'\")\n\t})\n\tt.Run(\"pool-error\", func(t *testing.T) {\n\t\tv := &TestEncoding{}\n\t\tenc := BorrowEncoder(nil)\n\t\tenc.isPooled = 1\n\t\tdefer func() {\n\t\t\terr := recover()\n\t\t\tassert.NotNil(t, err, \"err shouldnt be nil\")\n\t\t\tassert.IsType(t, InvalidUsagePooledEncoderError(\"\"), err, \"err should be of type InvalidUsagePooledEncoderError\")\n\t\t\tassert.Equal(t, \"Invalid usage of pooled encoder\", err.(InvalidUsagePooledEncoderError).Error(), \"err should be of type InvalidUsagePooledDecoderError\")\n\t\t}()\n\t\t_ = enc.EncodeObjectKeys(v, []string{})\n\t\tassert.True(t, false, \"should not be called as it should have panicked\")\n\t})\n\tt.Run(\"interface-key-error\", func(t *testing.T) {\n\t\tbuilder := &strings.Builder{}\n\t\tenc := NewEncoder(builder)\n\t\terr := enc.EncodeObjectKeys(&testObjectWithUnknownType{struct{}{}}, []string{})\n\t\tassert.NotNil(t, err, \"Error should not be nil\")\n\t\tassert.Equal(t, \"Invalid type struct {} provided to Marshal\", err.Error(), \"err.Error() should be 'Invalid type struct {} provided to Marshal'\")\n\t})\n\tt.Run(\"encode-object-with-keys\", func(t *testing.T) {\n\t\tb := &strings.Builder{}\n\t\tenc := NewEncoder(b)\n\t\terr := enc.EncodeObjectKeys(EncodeObjectFunc(func(enc *Encoder) {\n\t\t\tenc.ObjectKeyWithKeys(\"test\", EncodeObjectFunc(func(enc *Encoder) {\n\t\t\t\tenc.StringKey(\"test\", \"hello\")\n\t\t\t\tenc.StringKey(\"test2\", \"hello\")\n\t\t\t}), []string{\"test\"})\n\t\t}), []string{})\n\t\tassert.Nil(t, err, \"Error should not be nil\")\n\t\tassert.Equal(t, `{}`, b.String())\n\t})\n\tt.Run(\"encode-object-with-keys\", func(t *testing.T) {\n\t\tb := &strings.Builder{}\n\t\tenc := NewEncoder(b)\n\t\terr := enc.EncodeObject(EncodeObjectFunc(func(enc *Encoder) {\n\t\t\tenc.ObjectKeyWithKeys(\"test\", EncodeObjectFunc(func(enc *Encoder) {\n\t\t\t\tenc.keys = nil\n\t\t\t\tenc.StringKey(\"test\", \"hello\")\n\t\t\t\tenc.StringKey(\"test2\", \"hello\")\n\t\t\t}), []string{\"test\"})\n\t\t}))\n\t\tassert.Nil(t, err, \"Error should not be nil\")\n\t\tassert.Equal(t, `{\"test\":{}}`, b.String())\n\t})\n\tt.Run(\"encode-object-with-keys\", func(t *testing.T) {\n\t\tb := &strings.Builder{}\n\t\tenc := NewEncoder(b)\n\t\terr := enc.EncodeObject(EncodeObjectFunc(func(enc *Encoder) {\n\t\t\tenc.ObjectKeyWithKeys(\"test\", EncodeObjectFunc(func(enc *Encoder) {\n\t\t\t\tenc.StringKey(\"test\", \"hello\")\n\t\t\t\tenc.StringKey(\"test2\", \"hello\")\n\t\t\t}), []string{\"test\"})\n\t\t}))\n\t\tassert.Nil(t, err, \"Error should not be nil\")\n\t\tassert.Equal(t, `{\"test\":{\"test\":\"hello\"}}`, b.String())\n\t})\n\tt.Run(\"encode-object-with-keys\", func(t *testing.T) {\n\t\tb := &strings.Builder{}\n\t\tenc := NewEncoder(b)\n\t\terr := enc.EncodeObject(EncodeObjectFunc(func(enc *Encoder) {\n\t\t\tenc.writeByte(' ')\n\t\t\tenc.ObjectKeyWithKeys(\"test\", EncodeObjectFunc(func(enc *Encoder) {\n\t\t\t\tenc.StringKey(\"test\", \"hello\")\n\t\t\t\tenc.StringKey(\"test2\", \"hello\")\n\t\t\t}), []string{\"test\"})\n\t\t}))\n\t\tassert.Nil(t, err, \"Error should not be nil\")\n\t\tassert.Equal(t, `{ ,\"test\":{\"test\":\"hello\"}}`, b.String())\n\t})\n\tt.Run(\"encode-object-with-keys\", func(t *testing.T) {\n\t\tb := &strings.Builder{}\n\t\tenc := NewEncoder(b)\n\t\terr := enc.EncodeObject(EncodeObjectFunc(func(enc *Encoder) {\n\t\t\tenc.writeByte(' ')\n\t\t\tenc.ObjectKeyWithKeys(\"test\", &NilObject{}, []string{})\n\t\t}))\n\t\tassert.Nil(t, err, \"Error should not be nil\")\n\t\tassert.Equal(t, `{ ,\"test\":{}}`, b.String())\n\t})\n\tt.Run(\"encode-object-with-keys\", func(t *testing.T) {\n\t\tb := &strings.Builder{}\n\t\tenc := NewEncoder(b)\n\t\terr := enc.EncodeArray(EncodeArrayFunc(func(enc *Encoder) {\n\t\t\tenc.ObjectWithKeys(EncodeObjectFunc(func(enc *Encoder) {\n\t\t\t\tenc.StringKey(\"test\", \"hello\")\n\t\t\t\tenc.StringKey(\"test2\", \"hello\")\n\t\t\t}), []string{\"test\"})\n\t\t}))\n\t\tassert.Nil(t, err, \"Error should not be nil\")\n\t\tassert.Equal(t, `[{\"test\":\"hello\"}]`, b.String())\n\t})\n\tt.Run(\"encode-object-with-keys\", func(t *testing.T) {\n\t\tb := &strings.Builder{}\n\t\tenc := NewEncoder(b)\n\t\terr := enc.EncodeArray(EncodeArrayFunc(func(enc *Encoder) {\n\t\t\tenc.writeByte(' ')\n\t\t\tenc.ObjectWithKeys(EncodeObjectFunc(func(enc *Encoder) {\n\t\t\t\tenc.StringKey(\"test\", \"hello\")\n\t\t\t\tenc.StringKey(\"test2\", \"hello\")\n\t\t\t}), []string{\"test\"})\n\t\t}))\n\t\tassert.Nil(t, err, \"Error should not be nil\")\n\t\tassert.Equal(t, `[ ,{\"test\":\"hello\"}]`, b.String())\n\t})\n\tt.Run(\"encode-object-with-keys\", func(t *testing.T) {\n\t\tb := &strings.Builder{}\n\t\tenc := NewEncoder(b)\n\t\terr := enc.EncodeArray(EncodeArrayFunc(func(enc *Encoder) {\n\t\t\tenc.ObjectWithKeys(&NilObject{}, []string{})\n\t\t}))\n\t\tassert.Nil(t, err, \"Error should not be nil\")\n\t\tassert.Equal(t, `[{}]`, b.String())\n\t})\n\tt.Run(\"encode-object-with-keys\", func(t *testing.T) {\n\t\tb := &strings.Builder{}\n\t\tenc := NewEncoder(b)\n\t\terr := enc.EncodeArray(EncodeArrayFunc(func(enc *Encoder) {\n\t\t\tenc.writeByte(' ')\n\t\t\tenc.ObjectWithKeys(&NilObject{}, []string{})\n\t\t}))\n\t\tassert.Nil(t, err, \"Error should not be nil\")\n\t\tassert.Equal(t, `[ ,{}]`, b.String())\n\t})\n}\n"
        },
        {
          "name": "encode_pool.go",
          "type": "blob",
          "size": 0.845703125,
          "content": "package gojay\n\nimport (\n\t\"io\"\n\t\"sync\"\n)\n\nvar encPool = sync.Pool{\n\tNew: func() interface{} {\n\t\treturn NewEncoder(nil)\n\t},\n}\n\nvar streamEncPool = sync.Pool{\n\tNew: func() interface{} {\n\t\treturn Stream.NewEncoder(nil)\n\t},\n}\n\nfunc init() {\n\tfor i := 0; i < 32; i++ {\n\t\tencPool.Put(NewEncoder(nil))\n\t}\n\tfor i := 0; i < 32; i++ {\n\t\tstreamEncPool.Put(Stream.NewEncoder(nil))\n\t}\n}\n\n// NewEncoder returns a new encoder or borrows one from the pool\nfunc NewEncoder(w io.Writer) *Encoder {\n\treturn &Encoder{w: w}\n}\n\n// BorrowEncoder borrows an Encoder from the pool.\nfunc BorrowEncoder(w io.Writer) *Encoder {\n\tenc := encPool.Get().(*Encoder)\n\tenc.w = w\n\tenc.buf = enc.buf[:0]\n\tenc.isPooled = 0\n\tenc.err = nil\n\tenc.hasKeys = false\n\tenc.keys = nil\n\treturn enc\n}\n\n// Release sends back a Encoder to the pool.\nfunc (enc *Encoder) Release() {\n\tenc.isPooled = 1\n\tencPool.Put(enc)\n}\n"
        },
        {
          "name": "encode_pool_test.go",
          "type": "blob",
          "size": 0.451171875,
          "content": "package gojay\n\nimport (\n\t\"fmt\"\n\t\"log\"\n\t\"strconv\"\n\t\"testing\"\n\t\"time\"\n)\n\nfunc TestConcurrencyMarshal(t *testing.T) {\n\tvar f = func(num int, t *testing.T) {\n\t\tfor {\n\t\t\tb, err := Marshal(num)\n\t\t\tif err != nil {\n\t\t\t\tlog.Fatal(err)\n\t\t\t}\n\n\t\t\ts := string(b)\n\t\t\tif n, err := strconv.Atoi(s); err != nil || n != num {\n\t\t\t\tt.Error(fmt.Errorf(\n\t\t\t\t\t\"caught race: %v %v\", s, num,\n\t\t\t\t))\n\t\t\t}\n\t\t}\n\t}\n\n\tfor i := 0; i < 100; i++ {\n\t\tgo f(i, t)\n\t}\n\ttime.Sleep(2 * time.Second)\n}\n"
        },
        {
          "name": "encode_slice.go",
          "type": "blob",
          "size": 2.552734375,
          "content": "package gojay\n\n// AddSliceString marshals the given []string s\nfunc (enc *Encoder) AddSliceString(s []string) {\n\tenc.SliceString(s)\n}\n\n// SliceString marshals the given []string s\nfunc (enc *Encoder) SliceString(s []string) {\n\tenc.Array(EncodeArrayFunc(func(enc *Encoder) {\n\t\tfor _, str := range s {\n\t\t\tenc.String(str)\n\t\t}\n\t}))\n}\n\n// AddSliceStringKey marshals the given []string s\nfunc (enc *Encoder) AddSliceStringKey(k string, s []string) {\n\tenc.SliceStringKey(k, s)\n}\n\n// SliceStringKey marshals the given []string s\nfunc (enc *Encoder) SliceStringKey(k string, s []string) {\n\tenc.ArrayKey(k, EncodeArrayFunc(func(enc *Encoder) {\n\t\tfor _, str := range s {\n\t\t\tenc.String(str)\n\t\t}\n\t}))\n}\n\n// AddSliceInt marshals the given []int s\nfunc (enc *Encoder) AddSliceInt(s []int) {\n\tenc.SliceInt(s)\n}\n\n// SliceInt marshals the given []int s\nfunc (enc *Encoder) SliceInt(s []int) {\n\tenc.Array(EncodeArrayFunc(func(enc *Encoder) {\n\t\tfor _, i := range s {\n\t\t\tenc.Int(i)\n\t\t}\n\t}))\n}\n\n// AddSliceIntKey marshals the given []int s\nfunc (enc *Encoder) AddSliceIntKey(k string, s []int) {\n\tenc.SliceIntKey(k, s)\n}\n\n// SliceIntKey marshals the given []int s\nfunc (enc *Encoder) SliceIntKey(k string, s []int) {\n\tenc.ArrayKey(k, EncodeArrayFunc(func(enc *Encoder) {\n\t\tfor _, i := range s {\n\t\t\tenc.Int(i)\n\t\t}\n\t}))\n}\n\n// AddSliceFloat64 marshals the given []float64 s\nfunc (enc *Encoder) AddSliceFloat64(s []float64) {\n\tenc.SliceFloat64(s)\n}\n\n// SliceFloat64 marshals the given []float64 s\nfunc (enc *Encoder) SliceFloat64(s []float64) {\n\tenc.Array(EncodeArrayFunc(func(enc *Encoder) {\n\t\tfor _, i := range s {\n\t\t\tenc.Float64(i)\n\t\t}\n\t}))\n}\n\n// AddSliceFloat64Key marshals the given []float64 s\nfunc (enc *Encoder) AddSliceFloat64Key(k string, s []float64) {\n\tenc.SliceFloat64Key(k, s)\n}\n\n// SliceFloat64Key marshals the given []float64 s\nfunc (enc *Encoder) SliceFloat64Key(k string, s []float64) {\n\tenc.ArrayKey(k, EncodeArrayFunc(func(enc *Encoder) {\n\t\tfor _, i := range s {\n\t\t\tenc.Float64(i)\n\t\t}\n\t}))\n}\n\n// AddSliceBool marshals the given []bool s\nfunc (enc *Encoder) AddSliceBool(s []bool) {\n\tenc.SliceBool(s)\n}\n\n// SliceBool marshals the given []bool s\nfunc (enc *Encoder) SliceBool(s []bool) {\n\tenc.Array(EncodeArrayFunc(func(enc *Encoder) {\n\t\tfor _, i := range s {\n\t\t\tenc.Bool(i)\n\t\t}\n\t}))\n}\n\n// AddSliceBoolKey marshals the given []bool s\nfunc (enc *Encoder) AddSliceBoolKey(k string, s []bool) {\n\tenc.SliceBoolKey(k, s)\n}\n\n// SliceBoolKey marshals the given []bool s\nfunc (enc *Encoder) SliceBoolKey(k string, s []bool) {\n\tenc.ArrayKey(k, EncodeArrayFunc(func(enc *Encoder) {\n\t\tfor _, i := range s {\n\t\t\tenc.Bool(i)\n\t\t}\n\t}))\n}\n"
        },
        {
          "name": "encode_slice_test.go",
          "type": "blob",
          "size": 3.388671875,
          "content": "package gojay\n\nimport (\n\t\"strings\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/require\"\n)\n\nfunc (s *slicesTestObject) MarshalJSONObject(enc *Encoder) {\n\tenc.AddSliceStringKey(\"sliceString\", s.sliceString)\n\tenc.AddSliceIntKey(\"sliceInt\", s.sliceInt)\n\tenc.AddSliceFloat64Key(\"sliceFloat64\", s.sliceFloat64)\n\tenc.AddSliceBoolKey(\"sliceBool\", s.sliceBool)\n}\n\nfunc (s *slicesTestObject) IsNil() bool {\n\treturn s == nil\n}\n\nfunc TestEncodeSlices(t *testing.T) {\n\ttestCases := []struct {\n\t\tname string\n\t\tjson string\n\t\tobj  slicesTestObject\n\t}{\n\t\t{\n\t\t\tname: \"basic slice string\",\n\t\t\tjson: `{\n\t\t\t\t\"sliceString\": [\"foo\",\"bar\"],\n\t\t\t\t\"sliceInt\": [],\n\t\t\t\t\"sliceFloat64\": [],\n\t\t\t\t\"sliceBool\": []\n\t\t\t}`,\n\t\t\tobj: slicesTestObject{\n\t\t\t\tsliceString: []string{\"foo\", \"bar\"},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"basic slice bool\",\n\t\t\tjson: `{\n\t\t\t\t\"sliceString\": [],\n\t\t\t\t\"sliceInt\": [],\n\t\t\t\t\"sliceFloat64\": [],\n\t\t\t\t\"sliceBool\": [true,false]\n\t\t\t}`,\n\t\t\tobj: slicesTestObject{\n\t\t\t\tsliceBool: []bool{true, false},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"basic slice int\",\n\t\t\tjson: `{\n\t\t\t\t\"sliceString\": [],\n\t\t\t\t\"sliceFloat64\": [],\n\t\t\t\t\"sliceInt\": [1,2,3],\n\t\t\t\t\"sliceBool\": []\n\t\t\t}`,\n\t\t\tobj: slicesTestObject{\n\t\t\t\tsliceInt: []int{1, 2, 3},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"basic slice float64\",\n\t\t\tjson: `{\n\t\t\t\t\"sliceString\": [],\n\t\t\t\t\"sliceFloat64\": [1.3,2.4,3.1],\n\t\t\t\t\"sliceInt\": [],\n\t\t\t\t\"sliceBool\": []\n\t\t\t}`,\n\t\t\tobj: slicesTestObject{\n\t\t\t\tsliceFloat64: []float64{1.3, 2.4, 3.1},\n\t\t\t},\n\t\t},\n\t}\n\n\tfor _, testCase := range testCases {\n\t\tt.Run(\n\t\t\ttestCase.name,\n\t\t\tfunc(t *testing.T) {\n\t\t\t\tb := strings.Builder{}\n\t\t\t\tenc := BorrowEncoder(&b)\n\t\t\t\terr := enc.Encode(&testCase.obj)\n\t\t\t\trequire.Nil(t, err, \"err should be nil\")\n\t\t\t\trequire.JSONEq(t, testCase.json, b.String())\n\t\t\t},\n\t\t)\n\t}\n}\n\ntype testSliceSliceString [][]string\n\nfunc (t testSliceSliceString) MarshalJSONArray(enc *Encoder) {\n\tfor _, s := range t {\n\t\tenc.AddSliceString(s)\n\t}\n}\n\nfunc (t testSliceSliceString) IsNil() bool {\n\treturn t == nil\n}\n\ntype testSliceSliceBool [][]bool\n\nfunc (t testSliceSliceBool) MarshalJSONArray(enc *Encoder) {\n\tfor _, s := range t {\n\t\tenc.AddSliceBool(s)\n\t}\n}\n\nfunc (t testSliceSliceBool) IsNil() bool {\n\treturn t == nil\n}\n\ntype testSliceSliceInt [][]int\n\nfunc (t testSliceSliceInt) MarshalJSONArray(enc *Encoder) {\n\tfor _, s := range t {\n\t\tenc.AddSliceInt(s)\n\t}\n}\n\nfunc (t testSliceSliceInt) IsNil() bool {\n\treturn t == nil\n}\n\ntype testSliceSliceFloat64 [][]float64\n\nfunc (t testSliceSliceFloat64) MarshalJSONArray(enc *Encoder) {\n\tfor _, s := range t {\n\t\tenc.AddSliceFloat64(s)\n\t}\n}\n\nfunc (t testSliceSliceFloat64) IsNil() bool {\n\treturn t == nil\n}\n\nfunc TestEncodeSliceSlices(t *testing.T) {\n\ttestCases := []struct {\n\t\tname string\n\t\ts    MarshalerJSONArray\n\t\tjson string\n\t}{\n\t\t{\n\t\t\tname: \"slice of strings\",\n\t\t\ts: testSliceSliceString{\n\t\t\t\t[]string{\"foo\", \"bar\"},\n\t\t\t},\n\t\t\tjson: `[[\"foo\",\"bar\"]]`,\n\t\t},\n\t\t{\n\t\t\tname: \"slice of ints\",\n\t\t\ts: testSliceSliceInt{\n\t\t\t\t[]int{1, 2},\n\t\t\t},\n\t\t\tjson: `[[1,2]]`,\n\t\t},\n\t\t{\n\t\t\tname: \"slice of float\",\n\t\t\ts: testSliceSliceFloat64{\n\t\t\t\t[]float64{1.1, 1.2},\n\t\t\t},\n\t\t\tjson: `[[1.1,1.2]]`,\n\t\t},\n\t\t{\n\t\t\tname: \"slice of bool\",\n\t\t\ts: testSliceSliceBool{\n\t\t\t\t[]bool{true, false},\n\t\t\t},\n\t\t\tjson: `[[true,false]]`,\n\t\t},\n\t}\n\n\tfor _, testCase := range testCases {\n\t\tt.Run(\n\t\t\ttestCase.name,\n\t\t\tfunc(t *testing.T) {\n\t\t\t\tb := strings.Builder{}\n\t\t\t\tenc := BorrowEncoder(&b)\n\t\t\t\terr := enc.Encode(testCase.s)\n\t\t\t\trequire.Nil(t, err, \"err should be nil\")\n\t\t\t\trequire.JSONEq(t, testCase.json, b.String())\n\t\t\t},\n\t\t)\n\t}\n}\n"
        },
        {
          "name": "encode_sqlnull.go",
          "type": "blob",
          "size": 12.8984375,
          "content": "package gojay\n\nimport \"database/sql\"\n\n// EncodeSQLNullString encodes a string to\nfunc (enc *Encoder) EncodeSQLNullString(v *sql.NullString) error {\n\tif enc.isPooled == 1 {\n\t\tpanic(InvalidUsagePooledEncoderError(\"Invalid usage of pooled encoder\"))\n\t}\n\t_, _ = enc.encodeString(v.String)\n\t_, err := enc.Write()\n\tif err != nil {\n\t\tenc.err = err\n\t\treturn err\n\t}\n\treturn nil\n}\n\n// AddSQLNullString adds a string to be encoded, must be used inside a slice or array encoding (does not encode a key)\nfunc (enc *Encoder) AddSQLNullString(v *sql.NullString) {\n\tenc.String(v.String)\n}\n\n// AddSQLNullStringOmitEmpty adds a string to be encoded or skips it if it is zero value.\n// Must be used inside a slice or array encoding (does not encode a key)\nfunc (enc *Encoder) AddSQLNullStringOmitEmpty(v *sql.NullString) {\n\tif v != nil && v.Valid && v.String != \"\" {\n\t\tenc.StringOmitEmpty(v.String)\n\t}\n}\n\n// AddSQLNullStringNullEmpty adds a string to be encoded or skips it if it is zero value.\n// Must be used inside a slice or array encoding (does not encode a key)\nfunc (enc *Encoder) AddSQLNullStringNullEmpty(v *sql.NullString) {\n\tif v != nil && v.Valid {\n\t\tenc.StringNullEmpty(v.String)\n\t}\n}\n\n// AddSQLNullStringKey adds a string to be encoded, must be used inside an object as it will encode a key\nfunc (enc *Encoder) AddSQLNullStringKey(key string, v *sql.NullString) {\n\tenc.StringKey(key, v.String)\n}\n\n// AddSQLNullStringKeyOmitEmpty adds a string to be encoded or skips it if it is zero value.\n// Must be used inside an object as it will encode a key\nfunc (enc *Encoder) AddSQLNullStringKeyOmitEmpty(key string, v *sql.NullString) {\n\tif v != nil && v.Valid && v.String != \"\" {\n\t\tenc.StringKeyOmitEmpty(key, v.String)\n\t}\n}\n\n// SQLNullString adds a string to be encoded, must be used inside an object as it will encode a key\nfunc (enc *Encoder) SQLNullString(v *sql.NullString) {\n\tenc.String(v.String)\n}\n\n// SQLNullStringOmitEmpty adds a string to be encoded, must be used inside an object as it will encode a key\nfunc (enc *Encoder) SQLNullStringOmitEmpty(v *sql.NullString) {\n\tif v != nil && v.Valid && v.String != \"\" {\n\t\tenc.String(v.String)\n\t}\n}\n\n// SQLNullStringNullEmpty adds a string to be encoded, must be used inside an object as it will encode a key\nfunc (enc *Encoder) SQLNullStringNullEmpty(v *sql.NullString) {\n\tif v != nil && v.Valid {\n\t\tenc.StringNullEmpty(v.String)\n\t}\n}\n\n// SQLNullStringKey adds a string to be encoded, must be used inside an object as it will encode a key\nfunc (enc *Encoder) SQLNullStringKey(key string, v *sql.NullString) {\n\tenc.StringKey(key, v.String)\n}\n\n// SQLNullStringKeyOmitEmpty adds a string to be encoded or skips it if it is zero value.\n// Must be used inside an object as it will encode a key\nfunc (enc *Encoder) SQLNullStringKeyOmitEmpty(key string, v *sql.NullString) {\n\tif v != nil && v.Valid && v.String != \"\" {\n\t\tenc.StringKeyOmitEmpty(key, v.String)\n\t}\n}\n\n// SQLNullStringKeyNullEmpty adds a string to be encoded or skips it if it is zero value.\n// Must be used inside an object as it will encode a key\nfunc (enc *Encoder) SQLNullStringKeyNullEmpty(key string, v *sql.NullString) {\n\tif v != nil && v.Valid {\n\t\tenc.StringKeyNullEmpty(key, v.String)\n\t}\n}\n\n// NullInt64\n\n// EncodeSQLNullInt64 encodes a string to\nfunc (enc *Encoder) EncodeSQLNullInt64(v *sql.NullInt64) error {\n\tif enc.isPooled == 1 {\n\t\tpanic(InvalidUsagePooledEncoderError(\"Invalid usage of pooled encoder\"))\n\t}\n\t_, _ = enc.encodeInt64(v.Int64)\n\t_, err := enc.Write()\n\tif err != nil {\n\t\tenc.err = err\n\t\treturn err\n\t}\n\treturn nil\n}\n\n// AddSQLNullInt64 adds a string to be encoded, must be used inside a slice or array encoding (does not encode a key)\nfunc (enc *Encoder) AddSQLNullInt64(v *sql.NullInt64) {\n\tenc.Int64(v.Int64)\n}\n\n// AddSQLNullInt64OmitEmpty adds a string to be encoded or skips it if it is zero value.\n// Must be used inside a slice or array encoding (does not encode a key)\nfunc (enc *Encoder) AddSQLNullInt64OmitEmpty(v *sql.NullInt64) {\n\tif v != nil && v.Valid && v.Int64 != 0 {\n\t\tenc.Int64OmitEmpty(v.Int64)\n\t}\n}\n\n// AddSQLNullInt64NullEmpty adds a string to be encoded or skips it if it is zero value.\n// Must be used inside a slice or array encoding (does not encode a key)\nfunc (enc *Encoder) AddSQLNullInt64NullEmpty(v *sql.NullInt64) {\n\tif v != nil && v.Valid {\n\t\tenc.Int64NullEmpty(v.Int64)\n\t}\n}\n\n// AddSQLNullInt64Key adds a string to be encoded, must be used inside an object as it will encode a key\nfunc (enc *Encoder) AddSQLNullInt64Key(key string, v *sql.NullInt64) {\n\tenc.Int64Key(key, v.Int64)\n}\n\n// AddSQLNullInt64KeyOmitEmpty adds a string to be encoded or skips it if it is zero value.\n// Must be used inside an object as it will encode a key\nfunc (enc *Encoder) AddSQLNullInt64KeyOmitEmpty(key string, v *sql.NullInt64) {\n\tif v != nil && v.Valid && v.Int64 != 0 {\n\t\tenc.Int64KeyOmitEmpty(key, v.Int64)\n\t}\n}\n\n// AddSQLNullInt64KeyNullEmpty adds a string to be encoded or skips it if it is zero value.\n// Must be used inside an object as it will encode a key\nfunc (enc *Encoder) AddSQLNullInt64KeyNullEmpty(key string, v *sql.NullInt64) {\n\tif v != nil && v.Valid {\n\t\tenc.Int64KeyNullEmpty(key, v.Int64)\n\t}\n}\n\n// SQLNullInt64 adds a string to be encoded, must be used inside an object as it will encode a key\nfunc (enc *Encoder) SQLNullInt64(v *sql.NullInt64) {\n\tenc.Int64(v.Int64)\n}\n\n// SQLNullInt64OmitEmpty adds a string to be encoded, must be used inside an object as it will encode a key\nfunc (enc *Encoder) SQLNullInt64OmitEmpty(v *sql.NullInt64) {\n\tif v != nil && v.Valid && v.Int64 != 0 {\n\t\tenc.Int64(v.Int64)\n\t}\n}\n\n// SQLNullInt64NullEmpty adds a string to be encoded, must be used inside an object as it will encode a key\nfunc (enc *Encoder) SQLNullInt64NullEmpty(v *sql.NullInt64) {\n\tif v != nil && v.Valid {\n\t\tenc.Int64NullEmpty(v.Int64)\n\t}\n}\n\n// SQLNullInt64Key adds a string to be encoded, must be used inside an object as it will encode a key\nfunc (enc *Encoder) SQLNullInt64Key(key string, v *sql.NullInt64) {\n\tenc.Int64Key(key, v.Int64)\n}\n\n// SQLNullInt64KeyOmitEmpty adds a string to be encoded or skips it if it is zero value.\n// Must be used inside an object as it will encode a key\nfunc (enc *Encoder) SQLNullInt64KeyOmitEmpty(key string, v *sql.NullInt64) {\n\tif v != nil && v.Valid && v.Int64 != 0 {\n\t\tenc.Int64KeyOmitEmpty(key, v.Int64)\n\t}\n}\n\n// SQLNullInt64KeyNullEmpty adds a string to be encoded or skips it if it is zero value.\n// Must be used inside an object as it will encode a key\nfunc (enc *Encoder) SQLNullInt64KeyNullEmpty(key string, v *sql.NullInt64) {\n\tif v != nil && v.Valid {\n\t\tenc.Int64KeyNullEmpty(key, v.Int64)\n\t}\n}\n\n// NullFloat64\n\n// EncodeSQLNullFloat64 encodes a string to\nfunc (enc *Encoder) EncodeSQLNullFloat64(v *sql.NullFloat64) error {\n\tif enc.isPooled == 1 {\n\t\tpanic(InvalidUsagePooledEncoderError(\"Invalid usage of pooled encoder\"))\n\t}\n\t_, _ = enc.encodeFloat(v.Float64)\n\t_, err := enc.Write()\n\tif err != nil {\n\t\tenc.err = err\n\t\treturn err\n\t}\n\treturn nil\n}\n\n// AddSQLNullFloat64 adds a string to be encoded, must be used inside a slice or array encoding (does not encode a key)\nfunc (enc *Encoder) AddSQLNullFloat64(v *sql.NullFloat64) {\n\tenc.Float64(v.Float64)\n}\n\n// AddSQLNullFloat64OmitEmpty adds a string to be encoded or skips it if it is zero value.\n// Must be used inside a slice or array encoding (does not encode a key)\nfunc (enc *Encoder) AddSQLNullFloat64OmitEmpty(v *sql.NullFloat64) {\n\tif v != nil && v.Valid && v.Float64 != 0 {\n\t\tenc.Float64OmitEmpty(v.Float64)\n\t}\n}\n\n// AddSQLNullFloat64NullEmpty adds a string to be encoded or skips it if it is zero value.\n// Must be used inside a slice or array encoding (does not encode a key)\nfunc (enc *Encoder) AddSQLNullFloat64NullEmpty(v *sql.NullFloat64) {\n\tif v != nil && v.Valid {\n\t\tenc.Float64NullEmpty(v.Float64)\n\t}\n}\n\n// AddSQLNullFloat64Key adds a string to be encoded, must be used inside an object as it will encode a key\nfunc (enc *Encoder) AddSQLNullFloat64Key(key string, v *sql.NullFloat64) {\n\tenc.Float64Key(key, v.Float64)\n}\n\n// AddSQLNullFloat64KeyOmitEmpty adds a string to be encoded or skips it if it is zero value.\n// Must be used inside an object as it will encode a key\nfunc (enc *Encoder) AddSQLNullFloat64KeyOmitEmpty(key string, v *sql.NullFloat64) {\n\tif v != nil && v.Valid && v.Float64 != 0 {\n\t\tenc.Float64KeyOmitEmpty(key, v.Float64)\n\t}\n}\n\n// AddSQLNullFloat64KeyNullEmpty adds a string to be encoded or skips it if it is zero value.\n// Must be used inside an object as it will encode a key\nfunc (enc *Encoder) AddSQLNullFloat64KeyNullEmpty(key string, v *sql.NullFloat64) {\n\tif v != nil && v.Valid {\n\t\tenc.Float64KeyNullEmpty(key, v.Float64)\n\t}\n}\n\n// SQLNullFloat64 adds a string to be encoded, must be used inside an object as it will encode a key\nfunc (enc *Encoder) SQLNullFloat64(v *sql.NullFloat64) {\n\tenc.Float64(v.Float64)\n}\n\n// SQLNullFloat64OmitEmpty adds a string to be encoded, must be used inside an object as it will encode a key\nfunc (enc *Encoder) SQLNullFloat64OmitEmpty(v *sql.NullFloat64) {\n\tif v != nil && v.Valid && v.Float64 != 0 {\n\t\tenc.Float64(v.Float64)\n\t}\n}\n\n// SQLNullFloat64NullEmpty adds a string to be encoded, must be used inside an object as it will encode a key\nfunc (enc *Encoder) SQLNullFloat64NullEmpty(v *sql.NullFloat64) {\n\tif v != nil && v.Valid {\n\t\tenc.Float64NullEmpty(v.Float64)\n\t}\n}\n\n// SQLNullFloat64Key adds a string to be encoded, must be used inside an object as it will encode a key\nfunc (enc *Encoder) SQLNullFloat64Key(key string, v *sql.NullFloat64) {\n\tenc.Float64Key(key, v.Float64)\n}\n\n// SQLNullFloat64KeyOmitEmpty adds a string to be encoded or skips it if it is zero value.\n// Must be used inside an object as it will encode a key\nfunc (enc *Encoder) SQLNullFloat64KeyOmitEmpty(key string, v *sql.NullFloat64) {\n\tif v != nil && v.Valid && v.Float64 != 0 {\n\t\tenc.Float64KeyOmitEmpty(key, v.Float64)\n\t}\n}\n\n// SQLNullFloat64KeyNullEmpty adds a string to be encoded or skips it if it is zero value.\n// Must be used inside an object as it will encode a key\nfunc (enc *Encoder) SQLNullFloat64KeyNullEmpty(key string, v *sql.NullFloat64) {\n\tif v != nil && v.Valid {\n\t\tenc.Float64KeyNullEmpty(key, v.Float64)\n\t}\n}\n\n// NullBool\n\n// EncodeSQLNullBool encodes a string to\nfunc (enc *Encoder) EncodeSQLNullBool(v *sql.NullBool) error {\n\tif enc.isPooled == 1 {\n\t\tpanic(InvalidUsagePooledEncoderError(\"Invalid usage of pooled encoder\"))\n\t}\n\t_, _ = enc.encodeBool(v.Bool)\n\t_, err := enc.Write()\n\tif err != nil {\n\t\tenc.err = err\n\t\treturn err\n\t}\n\treturn nil\n}\n\n// AddSQLNullBool adds a string to be encoded, must be used inside a slice or array encoding (does not encode a key)\nfunc (enc *Encoder) AddSQLNullBool(v *sql.NullBool) {\n\tenc.Bool(v.Bool)\n}\n\n// AddSQLNullBoolOmitEmpty adds a string to be encoded or skips it if it is zero value.\n// Must be used inside a slice or array encoding (does not encode a key)\nfunc (enc *Encoder) AddSQLNullBoolOmitEmpty(v *sql.NullBool) {\n\tif v != nil && v.Valid && v.Bool != false {\n\t\tenc.BoolOmitEmpty(v.Bool)\n\t}\n}\n\n// AddSQLNullBoolKey adds a string to be encoded, must be used inside an object as it will encode a key\nfunc (enc *Encoder) AddSQLNullBoolKey(key string, v *sql.NullBool) {\n\tenc.BoolKey(key, v.Bool)\n}\n\n// AddSQLNullBoolKeyOmitEmpty adds a string to be encoded or skips it if it is zero value.\n// Must be used inside an object as it will encode a key\nfunc (enc *Encoder) AddSQLNullBoolKeyOmitEmpty(key string, v *sql.NullBool) {\n\tif v != nil && v.Valid && v.Bool != false {\n\t\tenc.BoolKeyOmitEmpty(key, v.Bool)\n\t}\n}\n\n// AddSQLNullBoolKeyNullEmpty adds a string to be encoded or skips it if it is zero value.\n// Must be used inside an object as it will encode a key\nfunc (enc *Encoder) AddSQLNullBoolKeyNullEmpty(key string, v *sql.NullBool) {\n\tif v != nil && v.Valid {\n\t\tenc.BoolKeyNullEmpty(key, v.Bool)\n\t}\n}\n\n// SQLNullBool adds a string to be encoded, must be used inside an object as it will encode a key\nfunc (enc *Encoder) SQLNullBool(v *sql.NullBool) {\n\tenc.Bool(v.Bool)\n}\n\n// SQLNullBoolOmitEmpty adds a string to be encoded, must be used inside an object as it will encode a key\nfunc (enc *Encoder) SQLNullBoolOmitEmpty(v *sql.NullBool) {\n\tif v != nil && v.Valid && v.Bool != false {\n\t\tenc.Bool(v.Bool)\n\t}\n}\n\n// SQLNullBoolNullEmpty adds a string to be encoded, must be used inside an object as it will encode a key\nfunc (enc *Encoder) SQLNullBoolNullEmpty(v *sql.NullBool) {\n\tif v != nil && v.Valid {\n\t\tenc.BoolNullEmpty(v.Bool)\n\t}\n}\n\n// SQLNullBoolKey adds a string to be encoded, must be used inside an object as it will encode a key\nfunc (enc *Encoder) SQLNullBoolKey(key string, v *sql.NullBool) {\n\tenc.BoolKey(key, v.Bool)\n}\n\n// SQLNullBoolKeyOmitEmpty adds a string to be encoded or skips it if it is zero value.\n// Must be used inside an object as it will encode a key\nfunc (enc *Encoder) SQLNullBoolKeyOmitEmpty(key string, v *sql.NullBool) {\n\tif v != nil && v.Valid && v.Bool != false {\n\t\tenc.BoolKeyOmitEmpty(key, v.Bool)\n\t}\n}\n\n// SQLNullBoolKeyNullEmpty adds a string to be encoded or skips it if it is zero value.\n// Must be used inside an object as it will encode a key\nfunc (enc *Encoder) SQLNullBoolKeyNullEmpty(key string, v *sql.NullBool) {\n\tif v != nil && v.Valid {\n\t\tenc.BoolKeyNullEmpty(key, v.Bool)\n\t}\n}\n"
        },
        {
          "name": "encode_sqlnull_test.go",
          "type": "blob",
          "size": 32.78515625,
          "content": "package gojay\n\nimport (\n\t\"database/sql\"\n\t\"strings\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\n// Null String\nfunc TestEncoceSQLNullString(t *testing.T) {\n\ttestCases := []struct {\n\t\tname           string\n\t\tsqlNullString  sql.NullString\n\t\texpectedResult string\n\t\terr            bool\n\t}{\n\t\t{\n\t\t\tname: \"it should encode a null string\",\n\t\t\tsqlNullString: sql.NullString{\n\t\t\t\tString: \"foo bar\",\n\t\t\t},\n\t\t\texpectedResult: `\"foo bar\"`,\n\t\t},\n\t\t{\n\t\t\tname: \"it should return an err as the string is invalid\",\n\t\t\tsqlNullString: sql.NullString{\n\t\t\t\tString: \"foo \\t bar\",\n\t\t\t},\n\t\t\texpectedResult: `\"foo \\t bar\"`,\n\t\t},\n\t}\n\n\tfor _, testCase := range testCases {\n\t\tt.Run(testCase.name, func(t *testing.T) {\n\t\t\tvar b strings.Builder\n\t\t\tenc := NewEncoder(&b)\n\t\t\terr := enc.EncodeSQLNullString(&testCase.sqlNullString)\n\t\t\tif testCase.err {\n\t\t\t\tassert.NotNil(t, err)\n\t\t\t} else {\n\t\t\t\tassert.Nil(t, err)\n\t\t\t\tassert.Equal(t, testCase.expectedResult, b.String())\n\t\t\t}\n\t\t})\n\t}\n\n\tt.Run(\n\t\t\"should panic as the encoder is pooled\",\n\t\tfunc(t *testing.T) {\n\t\t\tbuilder := &strings.Builder{}\n\t\t\tenc := NewEncoder(builder)\n\t\t\tenc.isPooled = 1\n\t\t\tdefer func() {\n\t\t\t\terr := recover()\n\t\t\t\tassert.NotNil(t, err, \"err should not be nil\")\n\t\t\t\tassert.IsType(t, InvalidUsagePooledEncoderError(\"\"), err, \"err should be of type InvalidUsagePooledEncoderError\")\n\t\t\t}()\n\t\t\t_ = enc.EncodeSQLNullString(&sql.NullString{})\n\t\t\tassert.True(t, false, \"should not be called as encoder should have panicked\")\n\t\t},\n\t)\n\n\tt.Run(\n\t\t\"should return an error as the writer encounters an error\",\n\t\tfunc(t *testing.T) {\n\t\t\tbuilder := TestWriterError(\"\")\n\t\t\tenc := NewEncoder(builder)\n\t\t\terr := enc.EncodeSQLNullString(&sql.NullString{})\n\t\t\tassert.NotNil(t, err)\n\t\t},\n\t)\n}\n\nfunc TestAddSQLNullStringKey(t *testing.T) {\n\tt.Run(\n\t\t\"AddSQLNullStringKey\",\n\t\tfunc(t *testing.T) {\n\t\t\ttestCases := []struct {\n\t\t\t\tname           string\n\t\t\t\tsqlNullString  sql.NullString\n\t\t\t\tbaseJSON       string\n\t\t\t\texpectedResult string\n\t\t\t\terr            bool\n\t\t\t}{\n\t\t\t\t{\n\t\t\t\t\tname: \"it should encode a null string\",\n\t\t\t\t\tsqlNullString: sql.NullString{\n\t\t\t\t\t\tString: \"foo bar\",\n\t\t\t\t\t},\n\t\t\t\t\tbaseJSON:       \"{\",\n\t\t\t\t\texpectedResult: `{\"foo\":\"foo bar\"`,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tname: \"it should encode a null string\",\n\t\t\t\t\tsqlNullString: sql.NullString{\n\t\t\t\t\t\tString: \"foo \\t bar\",\n\t\t\t\t\t},\n\t\t\t\t\tbaseJSON:       \"{\",\n\t\t\t\t\texpectedResult: `{\"foo\":\"foo \\t bar\"`,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tname: \"it should encode a null string\",\n\t\t\t\t\tsqlNullString: sql.NullString{\n\t\t\t\t\t\tString: \"foo \\t bar\",\n\t\t\t\t\t},\n\t\t\t\t\tbaseJSON:       \"{\",\n\t\t\t\t\texpectedResult: `{\"foo\":\"foo \\t bar\"`,\n\t\t\t\t},\n\t\t\t}\n\n\t\t\tfor _, testCase := range testCases {\n\t\t\t\tt.Run(testCase.name, func(t *testing.T) {\n\t\t\t\t\tvar b strings.Builder\n\t\t\t\t\tenc := NewEncoder(&b)\n\t\t\t\t\tenc.writeString(testCase.baseJSON)\n\t\t\t\t\tenc.AddSQLNullStringKey(\"foo\", &testCase.sqlNullString)\n\t\t\t\t\tenc.Write()\n\t\t\t\t\tassert.Equal(t, testCase.expectedResult, b.String())\n\n\t\t\t\t\tvar b2 strings.Builder\n\t\t\t\t\tenc = NewEncoder(&b2)\n\t\t\t\t\tenc.writeString(testCase.baseJSON)\n\t\t\t\t\tenc.SQLNullStringKey(\"foo\", &testCase.sqlNullString)\n\t\t\t\t\tenc.Write()\n\t\t\t\t\tassert.Equal(t, testCase.expectedResult, b2.String())\n\t\t\t\t})\n\t\t\t}\n\t\t},\n\t)\n\tt.Run(\n\t\t\"AddSQLNullStringKeyOmitEmpty, is should encode a sql.NullString\",\n\t\tfunc(t *testing.T) {\n\t\t\ttestCases := []struct {\n\t\t\t\tname           string\n\t\t\t\tsqlNullString  sql.NullString\n\t\t\t\tbaseJSON       string\n\t\t\t\texpectedResult string\n\t\t\t\terr            bool\n\t\t\t}{\n\t\t\t\t{\n\t\t\t\t\tname: \"it should encode a null string\",\n\t\t\t\t\tsqlNullString: sql.NullString{\n\t\t\t\t\t\tString: \"foo bar\",\n\t\t\t\t\t\tValid:  true,\n\t\t\t\t\t},\n\t\t\t\t\tbaseJSON:       \"{\",\n\t\t\t\t\texpectedResult: `{\"foo\":\"foo bar\"`,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tname: \"it should not encode anything as null string is invalid\",\n\t\t\t\t\tsqlNullString: sql.NullString{\n\t\t\t\t\t\tString: \"foo \\t bar\",\n\t\t\t\t\t\tValid:  false,\n\t\t\t\t\t},\n\t\t\t\t\tbaseJSON:       \"{\",\n\t\t\t\t\texpectedResult: `{`,\n\t\t\t\t},\n\t\t\t}\n\n\t\t\tfor _, testCase := range testCases {\n\t\t\t\tt.Run(testCase.name, func(t *testing.T) {\n\t\t\t\t\tvar b strings.Builder\n\t\t\t\t\tenc := NewEncoder(&b)\n\t\t\t\t\tenc.writeString(testCase.baseJSON)\n\t\t\t\t\tenc.AddSQLNullStringKeyOmitEmpty(\"foo\", &testCase.sqlNullString)\n\t\t\t\t\tenc.Write()\n\t\t\t\t\tassert.Equal(t, testCase.expectedResult, b.String())\n\n\t\t\t\t\tvar b2 strings.Builder\n\t\t\t\t\tenc = NewEncoder(&b2)\n\t\t\t\t\tenc.writeString(testCase.baseJSON)\n\t\t\t\t\tenc.SQLNullStringKeyOmitEmpty(\"foo\", &testCase.sqlNullString)\n\t\t\t\t\tenc.Write()\n\t\t\t\t\tassert.Equal(t, testCase.expectedResult, b2.String())\n\t\t\t\t})\n\t\t\t}\n\t\t},\n\t)\n}\n\nfunc TestAddSQLNullString(t *testing.T) {\n\tt.Run(\n\t\t\"AddSQLNullString\",\n\t\tfunc(t *testing.T) {\n\t\t\ttestCases := []struct {\n\t\t\t\tname           string\n\t\t\t\tsqlNullString  sql.NullString\n\t\t\t\tbaseJSON       string\n\t\t\t\texpectedResult string\n\t\t\t\terr            bool\n\t\t\t}{\n\t\t\t\t{\n\t\t\t\t\tname: \"it should encode a null string\",\n\t\t\t\t\tsqlNullString: sql.NullString{\n\t\t\t\t\t\tString: \"foo bar\",\n\t\t\t\t\t},\n\t\t\t\t\tbaseJSON:       \"[\",\n\t\t\t\t\texpectedResult: `[\"foo bar\"`,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tname: \"it should encode a null string\",\n\t\t\t\t\tsqlNullString: sql.NullString{\n\t\t\t\t\t\tString: \"foo \\t bar\",\n\t\t\t\t\t},\n\t\t\t\t\tbaseJSON:       \"[\",\n\t\t\t\t\texpectedResult: `[\"foo \\t bar\"`,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tname: \"it should encode a null string\",\n\t\t\t\t\tsqlNullString: sql.NullString{\n\t\t\t\t\t\tString: \"foo \\t bar\",\n\t\t\t\t\t},\n\t\t\t\t\tbaseJSON:       \"[\",\n\t\t\t\t\texpectedResult: `[\"foo \\t bar\"`,\n\t\t\t\t},\n\t\t\t}\n\n\t\t\tfor _, testCase := range testCases {\n\t\t\t\tt.Run(testCase.name, func(t *testing.T) {\n\t\t\t\t\tvar b strings.Builder\n\t\t\t\t\tenc := NewEncoder(&b)\n\t\t\t\t\tenc.writeString(testCase.baseJSON)\n\t\t\t\t\tenc.AddSQLNullString(&testCase.sqlNullString)\n\t\t\t\t\tenc.Write()\n\t\t\t\t\tassert.Equal(t, testCase.expectedResult, b.String())\n\n\t\t\t\t\tvar b2 strings.Builder\n\t\t\t\t\tenc = NewEncoder(&b2)\n\t\t\t\t\tenc.writeString(testCase.baseJSON)\n\t\t\t\t\tenc.SQLNullString(&testCase.sqlNullString)\n\t\t\t\t\tenc.Write()\n\t\t\t\t\tassert.Equal(t, testCase.expectedResult, b2.String())\n\t\t\t\t})\n\t\t\t}\n\t\t},\n\t)\n\tt.Run(\n\t\t\"AddSQLNullStringKeyOmitEmpty, is should encode a sql.NullString\",\n\t\tfunc(t *testing.T) {\n\t\t\ttestCases := []struct {\n\t\t\t\tname           string\n\t\t\t\tsqlNullString  sql.NullString\n\t\t\t\tbaseJSON       string\n\t\t\t\texpectedResult string\n\t\t\t\terr            bool\n\t\t\t}{\n\t\t\t\t{\n\t\t\t\t\tname: \"it should encode a null string\",\n\t\t\t\t\tsqlNullString: sql.NullString{\n\t\t\t\t\t\tString: \"foo bar\",\n\t\t\t\t\t\tValid:  true,\n\t\t\t\t\t},\n\t\t\t\t\tbaseJSON:       \"[\",\n\t\t\t\t\texpectedResult: `[\"foo bar\"`,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tname: \"it should not encode anything as null string is invalid\",\n\t\t\t\t\tsqlNullString: sql.NullString{\n\t\t\t\t\t\tString: \"foo \\t bar\",\n\t\t\t\t\t\tValid:  false,\n\t\t\t\t\t},\n\t\t\t\t\tbaseJSON:       \"[\",\n\t\t\t\t\texpectedResult: `[`,\n\t\t\t\t},\n\t\t\t}\n\n\t\t\tfor _, testCase := range testCases {\n\t\t\t\tt.Run(testCase.name, func(t *testing.T) {\n\t\t\t\t\tvar b strings.Builder\n\t\t\t\t\tenc := NewEncoder(&b)\n\t\t\t\t\tenc.writeString(testCase.baseJSON)\n\t\t\t\t\tenc.AddSQLNullStringOmitEmpty(&testCase.sqlNullString)\n\t\t\t\t\tenc.Write()\n\t\t\t\t\tassert.Equal(t, testCase.expectedResult, b.String())\n\n\t\t\t\t\tvar b2 strings.Builder\n\t\t\t\t\tenc = NewEncoder(&b2)\n\t\t\t\t\tenc.writeString(testCase.baseJSON)\n\t\t\t\t\tenc.SQLNullStringOmitEmpty(&testCase.sqlNullString)\n\t\t\t\t\tenc.Write()\n\t\t\t\t\tassert.Equal(t, testCase.expectedResult, b2.String())\n\t\t\t\t})\n\t\t\t}\n\t\t},\n\t)\n}\n\n// NullInt64\nfunc TestEncoceSQLNullInt64(t *testing.T) {\n\ttestCases := []struct {\n\t\tname           string\n\t\tsqlNullInt64   sql.NullInt64\n\t\texpectedResult string\n\t\terr            bool\n\t}{\n\t\t{\n\t\t\tname: \"it should encode a null string\",\n\t\t\tsqlNullInt64: sql.NullInt64{\n\t\t\t\tInt64: int64(1),\n\t\t\t},\n\t\t\texpectedResult: `1`,\n\t\t},\n\t\t{\n\t\t\tname: \"it should return an err as the string is invalid\",\n\t\t\tsqlNullInt64: sql.NullInt64{\n\t\t\t\tInt64: int64(2),\n\t\t\t},\n\t\t\texpectedResult: `2`,\n\t\t},\n\t}\n\n\tfor _, testCase := range testCases {\n\t\tt.Run(testCase.name, func(t *testing.T) {\n\t\t\tvar b strings.Builder\n\t\t\tenc := NewEncoder(&b)\n\t\t\terr := enc.EncodeSQLNullInt64(&testCase.sqlNullInt64)\n\t\t\tif testCase.err {\n\t\t\t\tassert.NotNil(t, err)\n\t\t\t} else {\n\t\t\t\tassert.Nil(t, err)\n\t\t\t\tassert.Equal(t, testCase.expectedResult, b.String())\n\t\t\t}\n\t\t})\n\t}\n\tt.Run(\n\t\t\"should panic as the encoder is pooled\",\n\t\tfunc(t *testing.T) {\n\t\t\tbuilder := &strings.Builder{}\n\t\t\tenc := NewEncoder(builder)\n\t\t\tenc.isPooled = 1\n\t\t\tdefer func() {\n\t\t\t\terr := recover()\n\t\t\t\tassert.NotNil(t, err, \"err should not be nil\")\n\t\t\t\tassert.IsType(t, InvalidUsagePooledEncoderError(\"\"), err, \"err should be of type InvalidUsagePooledEncoderError\")\n\t\t\t}()\n\t\t\t_ = enc.EncodeSQLNullInt64(&sql.NullInt64{})\n\t\t\tassert.True(t, false, \"should not be called as encoder should have panicked\")\n\t\t},\n\t)\n\tt.Run(\n\t\t\"should return an error as the writer encounters an error\",\n\t\tfunc(t *testing.T) {\n\t\t\tbuilder := TestWriterError(\"\")\n\t\t\tenc := NewEncoder(builder)\n\t\t\terr := enc.EncodeSQLNullInt64(&sql.NullInt64{})\n\t\t\tassert.NotNil(t, err)\n\t\t},\n\t)\n}\n\nfunc TestAddSQLNullInt64Key(t *testing.T) {\n\tt.Run(\n\t\t\"AddSQLNullInt64Key\",\n\t\tfunc(t *testing.T) {\n\t\t\ttestCases := []struct {\n\t\t\t\tname           string\n\t\t\t\tsqlNullInt64   sql.NullInt64\n\t\t\t\tbaseJSON       string\n\t\t\t\texpectedResult string\n\t\t\t\terr            bool\n\t\t\t}{\n\t\t\t\t{\n\t\t\t\t\tname: \"it should encode a null string\",\n\t\t\t\t\tsqlNullInt64: sql.NullInt64{\n\t\t\t\t\t\tInt64: 1,\n\t\t\t\t\t},\n\t\t\t\t\tbaseJSON:       \"{\",\n\t\t\t\t\texpectedResult: `{\"foo\":1`,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tname: \"it should encode a null string\",\n\t\t\t\t\tsqlNullInt64: sql.NullInt64{\n\t\t\t\t\t\tInt64: 2,\n\t\t\t\t\t},\n\t\t\t\t\tbaseJSON:       \"{\",\n\t\t\t\t\texpectedResult: `{\"foo\":2`,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tname: \"it should encode a null string\",\n\t\t\t\t\tsqlNullInt64: sql.NullInt64{\n\t\t\t\t\t\tInt64: 2,\n\t\t\t\t\t},\n\t\t\t\t\tbaseJSON:       \"{\",\n\t\t\t\t\texpectedResult: `{\"foo\":2`,\n\t\t\t\t},\n\t\t\t}\n\n\t\t\tfor _, testCase := range testCases {\n\t\t\t\tt.Run(testCase.name, func(t *testing.T) {\n\t\t\t\t\tvar b strings.Builder\n\t\t\t\t\tenc := NewEncoder(&b)\n\t\t\t\t\tenc.writeString(testCase.baseJSON)\n\t\t\t\t\tenc.AddSQLNullInt64Key(\"foo\", &testCase.sqlNullInt64)\n\t\t\t\t\tenc.Write()\n\t\t\t\t\tassert.Equal(t, testCase.expectedResult, b.String())\n\n\t\t\t\t\tvar b2 strings.Builder\n\t\t\t\t\tenc = NewEncoder(&b2)\n\t\t\t\t\tenc.writeString(testCase.baseJSON)\n\t\t\t\t\tenc.SQLNullInt64Key(\"foo\", &testCase.sqlNullInt64)\n\t\t\t\t\tenc.Write()\n\t\t\t\t\tassert.Equal(t, testCase.expectedResult, b2.String())\n\t\t\t\t})\n\t\t\t}\n\t\t},\n\t)\n\tt.Run(\n\t\t\"AddSQLNullInt64KeyOmitEmpty, is should encode a sql.NullInt64\",\n\t\tfunc(t *testing.T) {\n\t\t\ttestCases := []struct {\n\t\t\t\tname           string\n\t\t\t\tsqlNullInt64   sql.NullInt64\n\t\t\t\tbaseJSON       string\n\t\t\t\texpectedResult string\n\t\t\t\terr            bool\n\t\t\t}{\n\t\t\t\t{\n\t\t\t\t\tname: \"it should encode a null string\",\n\t\t\t\t\tsqlNullInt64: sql.NullInt64{\n\t\t\t\t\t\tInt64: 1,\n\t\t\t\t\t\tValid: true,\n\t\t\t\t\t},\n\t\t\t\t\tbaseJSON:       \"{\",\n\t\t\t\t\texpectedResult: `{\"foo\":1`,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tname: \"it should not encode anything as null string is invalid\",\n\t\t\t\t\tsqlNullInt64: sql.NullInt64{\n\t\t\t\t\t\tInt64: 2,\n\t\t\t\t\t\tValid: false,\n\t\t\t\t\t},\n\t\t\t\t\tbaseJSON:       \"{\",\n\t\t\t\t\texpectedResult: `{`,\n\t\t\t\t},\n\t\t\t}\n\n\t\t\tfor _, testCase := range testCases {\n\t\t\t\tt.Run(testCase.name, func(t *testing.T) {\n\t\t\t\t\tvar b strings.Builder\n\t\t\t\t\tenc := NewEncoder(&b)\n\t\t\t\t\tenc.writeString(testCase.baseJSON)\n\t\t\t\t\tenc.AddSQLNullInt64KeyOmitEmpty(\"foo\", &testCase.sqlNullInt64)\n\t\t\t\t\tenc.Write()\n\t\t\t\t\tassert.Equal(t, testCase.expectedResult, b.String())\n\n\t\t\t\t\tvar b2 strings.Builder\n\t\t\t\t\tenc = NewEncoder(&b2)\n\t\t\t\t\tenc.writeString(testCase.baseJSON)\n\t\t\t\t\tenc.SQLNullInt64KeyOmitEmpty(\"foo\", &testCase.sqlNullInt64)\n\t\t\t\t\tenc.Write()\n\t\t\t\t\tassert.Equal(t, testCase.expectedResult, b2.String())\n\t\t\t\t})\n\t\t\t}\n\t\t},\n\t)\n}\n\nfunc TestAddSQLNullInt64(t *testing.T) {\n\tt.Run(\n\t\t\"AddSQLNullInt64\",\n\t\tfunc(t *testing.T) {\n\t\t\ttestCases := []struct {\n\t\t\t\tname           string\n\t\t\t\tsqlNullInt64   sql.NullInt64\n\t\t\t\tbaseJSON       string\n\t\t\t\texpectedResult string\n\t\t\t\terr            bool\n\t\t\t}{\n\t\t\t\t{\n\t\t\t\t\tname: \"it should encode a null string\",\n\t\t\t\t\tsqlNullInt64: sql.NullInt64{\n\t\t\t\t\t\tInt64: 1,\n\t\t\t\t\t},\n\t\t\t\t\tbaseJSON:       \"[\",\n\t\t\t\t\texpectedResult: `[1`,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tname: \"it should encode a null string\",\n\t\t\t\t\tsqlNullInt64: sql.NullInt64{\n\t\t\t\t\t\tInt64: 2,\n\t\t\t\t\t},\n\t\t\t\t\tbaseJSON:       \"[\",\n\t\t\t\t\texpectedResult: `[2`,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tname: \"it should encode a null string\",\n\t\t\t\t\tsqlNullInt64: sql.NullInt64{\n\t\t\t\t\t\tInt64: 2,\n\t\t\t\t\t},\n\t\t\t\t\tbaseJSON:       \"[\",\n\t\t\t\t\texpectedResult: `[2`,\n\t\t\t\t},\n\t\t\t}\n\n\t\t\tfor _, testCase := range testCases {\n\t\t\t\tt.Run(testCase.name, func(t *testing.T) {\n\t\t\t\t\tvar b strings.Builder\n\t\t\t\t\tenc := NewEncoder(&b)\n\t\t\t\t\tenc.writeString(testCase.baseJSON)\n\t\t\t\t\tenc.AddSQLNullInt64(&testCase.sqlNullInt64)\n\t\t\t\t\tenc.Write()\n\t\t\t\t\tassert.Equal(t, testCase.expectedResult, b.String())\n\n\t\t\t\t\tvar b2 strings.Builder\n\t\t\t\t\tenc = NewEncoder(&b2)\n\t\t\t\t\tenc.writeString(testCase.baseJSON)\n\t\t\t\t\tenc.SQLNullInt64(&testCase.sqlNullInt64)\n\t\t\t\t\tenc.Write()\n\t\t\t\t\tassert.Equal(t, testCase.expectedResult, b2.String())\n\t\t\t\t})\n\t\t\t}\n\t\t},\n\t)\n\tt.Run(\n\t\t\"AddSQLNullInt64KeyOmitEmpty, is should encode a sql.NullInt64\",\n\t\tfunc(t *testing.T) {\n\t\t\ttestCases := []struct {\n\t\t\t\tname           string\n\t\t\t\tsqlNullInt64   sql.NullInt64\n\t\t\t\tbaseJSON       string\n\t\t\t\texpectedResult string\n\t\t\t\terr            bool\n\t\t\t}{\n\t\t\t\t{\n\t\t\t\t\tname: \"it should encode a null string\",\n\t\t\t\t\tsqlNullInt64: sql.NullInt64{\n\t\t\t\t\t\tInt64: 2,\n\t\t\t\t\t\tValid: true,\n\t\t\t\t\t},\n\t\t\t\t\tbaseJSON:       \"[\",\n\t\t\t\t\texpectedResult: `[2`,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tname: \"it should not encode anything as null string is invalid\",\n\t\t\t\t\tsqlNullInt64: sql.NullInt64{\n\t\t\t\t\t\tInt64: 2,\n\t\t\t\t\t\tValid: false,\n\t\t\t\t\t},\n\t\t\t\t\tbaseJSON:       \"[\",\n\t\t\t\t\texpectedResult: `[`,\n\t\t\t\t},\n\t\t\t}\n\n\t\t\tfor _, testCase := range testCases {\n\t\t\t\tt.Run(testCase.name, func(t *testing.T) {\n\t\t\t\t\tvar b strings.Builder\n\t\t\t\t\tenc := NewEncoder(&b)\n\t\t\t\t\tenc.writeString(testCase.baseJSON)\n\t\t\t\t\tenc.AddSQLNullInt64OmitEmpty(&testCase.sqlNullInt64)\n\t\t\t\t\tenc.Write()\n\t\t\t\t\tassert.Equal(t, testCase.expectedResult, b.String())\n\n\t\t\t\t\tvar b2 strings.Builder\n\t\t\t\t\tenc = NewEncoder(&b2)\n\t\t\t\t\tenc.writeString(testCase.baseJSON)\n\t\t\t\t\tenc.SQLNullInt64OmitEmpty(&testCase.sqlNullInt64)\n\t\t\t\t\tenc.Write()\n\t\t\t\t\tassert.Equal(t, testCase.expectedResult, b2.String())\n\t\t\t\t})\n\t\t\t}\n\t\t},\n\t)\n}\n\n// NullFloat64\nfunc TestEncoceSQLNullFloat64(t *testing.T) {\n\ttestCases := []struct {\n\t\tname           string\n\t\tsqlNullFloat64 sql.NullFloat64\n\t\texpectedResult string\n\t\terr            bool\n\t}{\n\t\t{\n\t\t\tname: \"it should encode a null string\",\n\t\t\tsqlNullFloat64: sql.NullFloat64{\n\t\t\t\tFloat64: float64(1),\n\t\t\t},\n\t\t\texpectedResult: `1`,\n\t\t},\n\t\t{\n\t\t\tname: \"it should return an err as the string is invalid\",\n\t\t\tsqlNullFloat64: sql.NullFloat64{\n\t\t\t\tFloat64: float64(2),\n\t\t\t},\n\t\t\texpectedResult: `2`,\n\t\t},\n\t}\n\n\tfor _, testCase := range testCases {\n\t\tt.Run(testCase.name, func(t *testing.T) {\n\t\t\tvar b strings.Builder\n\t\t\tenc := NewEncoder(&b)\n\t\t\terr := enc.EncodeSQLNullFloat64(&testCase.sqlNullFloat64)\n\t\t\tif testCase.err {\n\t\t\t\tassert.NotNil(t, err)\n\t\t\t} else {\n\t\t\t\tassert.Nil(t, err)\n\t\t\t\tassert.Equal(t, testCase.expectedResult, b.String())\n\t\t\t}\n\t\t})\n\t}\n\tt.Run(\n\t\t\"should panic as the encoder is pooled\",\n\t\tfunc(t *testing.T) {\n\t\t\tbuilder := &strings.Builder{}\n\t\t\tenc := NewEncoder(builder)\n\t\t\tenc.isPooled = 1\n\t\t\tdefer func() {\n\t\t\t\terr := recover()\n\t\t\t\tassert.NotNil(t, err, \"err should not be nil\")\n\t\t\t\tassert.IsType(t, InvalidUsagePooledEncoderError(\"\"), err, \"err should be of type InvalidUsagePooledEncoderError\")\n\t\t\t}()\n\t\t\t_ = enc.EncodeSQLNullFloat64(&sql.NullFloat64{})\n\t\t\tassert.True(t, false, \"should not be called as encoder should have panicked\")\n\t\t},\n\t)\n\n\tt.Run(\n\t\t\"should return an error as the writer encounters an error\",\n\t\tfunc(t *testing.T) {\n\t\t\tbuilder := TestWriterError(\"\")\n\t\t\tenc := NewEncoder(builder)\n\t\t\terr := enc.EncodeSQLNullFloat64(&sql.NullFloat64{})\n\t\t\tassert.NotNil(t, err)\n\t\t},\n\t)\n}\n\nfunc TestAddSQLNullFloat64Key(t *testing.T) {\n\tt.Run(\n\t\t\"AddSQLNullFloat64Key\",\n\t\tfunc(t *testing.T) {\n\t\t\ttestCases := []struct {\n\t\t\t\tname           string\n\t\t\t\tsqlNullFloat64 sql.NullFloat64\n\t\t\t\tbaseJSON       string\n\t\t\t\texpectedResult string\n\t\t\t\terr            bool\n\t\t\t}{\n\t\t\t\t{\n\t\t\t\t\tname: \"it should encode a null string\",\n\t\t\t\t\tsqlNullFloat64: sql.NullFloat64{\n\t\t\t\t\t\tFloat64: 1,\n\t\t\t\t\t},\n\t\t\t\t\tbaseJSON:       \"{\",\n\t\t\t\t\texpectedResult: `{\"foo\":1`,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tname: \"it should encode a null string\",\n\t\t\t\t\tsqlNullFloat64: sql.NullFloat64{\n\t\t\t\t\t\tFloat64: 2,\n\t\t\t\t\t},\n\t\t\t\t\tbaseJSON:       \"{\",\n\t\t\t\t\texpectedResult: `{\"foo\":2`,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tname: \"it should encode a null string\",\n\t\t\t\t\tsqlNullFloat64: sql.NullFloat64{\n\t\t\t\t\t\tFloat64: 2,\n\t\t\t\t\t},\n\t\t\t\t\tbaseJSON:       \"{\",\n\t\t\t\t\texpectedResult: `{\"foo\":2`,\n\t\t\t\t},\n\t\t\t}\n\n\t\t\tfor _, testCase := range testCases {\n\t\t\t\tt.Run(testCase.name, func(t *testing.T) {\n\t\t\t\t\tvar b strings.Builder\n\t\t\t\t\tenc := NewEncoder(&b)\n\t\t\t\t\tenc.writeString(testCase.baseJSON)\n\t\t\t\t\tenc.AddSQLNullFloat64Key(\"foo\", &testCase.sqlNullFloat64)\n\t\t\t\t\tenc.Write()\n\t\t\t\t\tassert.Equal(t, testCase.expectedResult, b.String())\n\n\t\t\t\t\tvar b2 strings.Builder\n\t\t\t\t\tenc = NewEncoder(&b2)\n\t\t\t\t\tenc.writeString(testCase.baseJSON)\n\t\t\t\t\tenc.SQLNullFloat64Key(\"foo\", &testCase.sqlNullFloat64)\n\t\t\t\t\tenc.Write()\n\t\t\t\t\tassert.Equal(t, testCase.expectedResult, b2.String())\n\t\t\t\t})\n\t\t\t}\n\t\t},\n\t)\n\tt.Run(\n\t\t\"AddSQLNullFloat64KeyOmitEmpty, is should encode a sql.NullFloat64\",\n\t\tfunc(t *testing.T) {\n\t\t\ttestCases := []struct {\n\t\t\t\tname           string\n\t\t\t\tsqlNullFloat64 sql.NullFloat64\n\t\t\t\tbaseJSON       string\n\t\t\t\texpectedResult string\n\t\t\t\terr            bool\n\t\t\t}{\n\t\t\t\t{\n\t\t\t\t\tname: \"it should encode a null string\",\n\t\t\t\t\tsqlNullFloat64: sql.NullFloat64{\n\t\t\t\t\t\tFloat64: 1,\n\t\t\t\t\t\tValid:   true,\n\t\t\t\t\t},\n\t\t\t\t\tbaseJSON:       \"{\",\n\t\t\t\t\texpectedResult: `{\"foo\":1`,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tname: \"it should not encode anything as null string is invalid\",\n\t\t\t\t\tsqlNullFloat64: sql.NullFloat64{\n\t\t\t\t\t\tFloat64: 2,\n\t\t\t\t\t\tValid:   false,\n\t\t\t\t\t},\n\t\t\t\t\tbaseJSON:       \"{\",\n\t\t\t\t\texpectedResult: `{`,\n\t\t\t\t},\n\t\t\t}\n\n\t\t\tfor _, testCase := range testCases {\n\t\t\t\tt.Run(testCase.name, func(t *testing.T) {\n\t\t\t\t\tvar b strings.Builder\n\t\t\t\t\tenc := NewEncoder(&b)\n\t\t\t\t\tenc.writeString(testCase.baseJSON)\n\t\t\t\t\tenc.AddSQLNullFloat64KeyOmitEmpty(\"foo\", &testCase.sqlNullFloat64)\n\t\t\t\t\tenc.Write()\n\t\t\t\t\tassert.Equal(t, testCase.expectedResult, b.String())\n\n\t\t\t\t\tvar b2 strings.Builder\n\t\t\t\t\tenc = NewEncoder(&b2)\n\t\t\t\t\tenc.writeString(testCase.baseJSON)\n\t\t\t\t\tenc.SQLNullFloat64KeyOmitEmpty(\"foo\", &testCase.sqlNullFloat64)\n\t\t\t\t\tenc.Write()\n\t\t\t\t\tassert.Equal(t, testCase.expectedResult, b2.String())\n\t\t\t\t})\n\t\t\t}\n\t\t},\n\t)\n}\n\nfunc TestAddSQLNullFloat64(t *testing.T) {\n\tt.Run(\n\t\t\"AddSQLNullFloat64\",\n\t\tfunc(t *testing.T) {\n\t\t\ttestCases := []struct {\n\t\t\t\tname           string\n\t\t\t\tsqlNullFloat64 sql.NullFloat64\n\t\t\t\tbaseJSON       string\n\t\t\t\texpectedResult string\n\t\t\t\terr            bool\n\t\t\t}{\n\t\t\t\t{\n\t\t\t\t\tname: \"it should encode a null string\",\n\t\t\t\t\tsqlNullFloat64: sql.NullFloat64{\n\t\t\t\t\t\tFloat64: 1,\n\t\t\t\t\t},\n\t\t\t\t\tbaseJSON:       \"[\",\n\t\t\t\t\texpectedResult: `[1`,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tname: \"it should encode a null string\",\n\t\t\t\t\tsqlNullFloat64: sql.NullFloat64{\n\t\t\t\t\t\tFloat64: 2,\n\t\t\t\t\t},\n\t\t\t\t\tbaseJSON:       \"[\",\n\t\t\t\t\texpectedResult: `[2`,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tname: \"it should encode a null string\",\n\t\t\t\t\tsqlNullFloat64: sql.NullFloat64{\n\t\t\t\t\t\tFloat64: 2,\n\t\t\t\t\t},\n\t\t\t\t\tbaseJSON:       \"[\",\n\t\t\t\t\texpectedResult: `[2`,\n\t\t\t\t},\n\t\t\t}\n\n\t\t\tfor _, testCase := range testCases {\n\t\t\t\tt.Run(testCase.name, func(t *testing.T) {\n\t\t\t\t\tvar b strings.Builder\n\t\t\t\t\tenc := NewEncoder(&b)\n\t\t\t\t\tenc.writeString(testCase.baseJSON)\n\t\t\t\t\tenc.AddSQLNullFloat64(&testCase.sqlNullFloat64)\n\t\t\t\t\tenc.Write()\n\t\t\t\t\tassert.Equal(t, testCase.expectedResult, b.String())\n\n\t\t\t\t\tvar b2 strings.Builder\n\t\t\t\t\tenc = NewEncoder(&b2)\n\t\t\t\t\tenc.writeString(testCase.baseJSON)\n\t\t\t\t\tenc.SQLNullFloat64(&testCase.sqlNullFloat64)\n\t\t\t\t\tenc.Write()\n\t\t\t\t\tassert.Equal(t, testCase.expectedResult, b2.String())\n\t\t\t\t})\n\t\t\t}\n\t\t},\n\t)\n\tt.Run(\n\t\t\"AddSQLNullFloat64KeyOmitEmpty, is should encode a sql.NullFloat64\",\n\t\tfunc(t *testing.T) {\n\t\t\ttestCases := []struct {\n\t\t\t\tname           string\n\t\t\t\tsqlNullFloat64 sql.NullFloat64\n\t\t\t\tbaseJSON       string\n\t\t\t\texpectedResult string\n\t\t\t\terr            bool\n\t\t\t}{\n\t\t\t\t{\n\t\t\t\t\tname: \"it should encode a null string\",\n\t\t\t\t\tsqlNullFloat64: sql.NullFloat64{\n\t\t\t\t\t\tFloat64: 2,\n\t\t\t\t\t\tValid:   true,\n\t\t\t\t\t},\n\t\t\t\t\tbaseJSON:       \"[\",\n\t\t\t\t\texpectedResult: `[2`,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tname: \"it should not encode anything as null string is invalid\",\n\t\t\t\t\tsqlNullFloat64: sql.NullFloat64{\n\t\t\t\t\t\tFloat64: 2,\n\t\t\t\t\t\tValid:   false,\n\t\t\t\t\t},\n\t\t\t\t\tbaseJSON:       \"[\",\n\t\t\t\t\texpectedResult: `[`,\n\t\t\t\t},\n\t\t\t}\n\n\t\t\tfor _, testCase := range testCases {\n\t\t\t\tt.Run(testCase.name, func(t *testing.T) {\n\t\t\t\t\tvar b strings.Builder\n\t\t\t\t\tenc := NewEncoder(&b)\n\t\t\t\t\tenc.writeString(testCase.baseJSON)\n\t\t\t\t\tenc.AddSQLNullFloat64OmitEmpty(&testCase.sqlNullFloat64)\n\t\t\t\t\tenc.Write()\n\t\t\t\t\tassert.Equal(t, testCase.expectedResult, b.String())\n\n\t\t\t\t\tvar b2 strings.Builder\n\t\t\t\t\tenc = NewEncoder(&b2)\n\t\t\t\t\tenc.writeString(testCase.baseJSON)\n\t\t\t\t\tenc.SQLNullFloat64OmitEmpty(&testCase.sqlNullFloat64)\n\t\t\t\t\tenc.Write()\n\t\t\t\t\tassert.Equal(t, testCase.expectedResult, b2.String())\n\t\t\t\t})\n\t\t\t}\n\t\t},\n\t)\n}\n\n// NullBool\nfunc TestEncoceSQLNullBool(t *testing.T) {\n\ttestCases := []struct {\n\t\tname           string\n\t\tsqlNullBool    sql.NullBool\n\t\texpectedResult string\n\t\terr            bool\n\t}{\n\t\t{\n\t\t\tname: \"it should encode a null string\",\n\t\t\tsqlNullBool: sql.NullBool{\n\t\t\t\tBool: true,\n\t\t\t},\n\t\t\texpectedResult: `true`,\n\t\t},\n\t\t{\n\t\t\tname: \"it should return an err as the string is invalid\",\n\t\t\tsqlNullBool: sql.NullBool{\n\t\t\t\tBool: false,\n\t\t\t},\n\t\t\texpectedResult: `false`,\n\t\t},\n\t}\n\n\tfor _, testCase := range testCases {\n\t\tt.Run(testCase.name, func(t *testing.T) {\n\t\t\tvar b strings.Builder\n\t\t\tenc := NewEncoder(&b)\n\t\t\terr := enc.EncodeSQLNullBool(&testCase.sqlNullBool)\n\t\t\tif testCase.err {\n\t\t\t\tassert.NotNil(t, err)\n\t\t\t} else {\n\t\t\t\tassert.Nil(t, err)\n\t\t\t\tassert.Equal(t, testCase.expectedResult, b.String())\n\t\t\t}\n\t\t})\n\t}\n\tt.Run(\n\t\t\"should panic as the encoder is pooled\",\n\t\tfunc(t *testing.T) {\n\t\t\tbuilder := &strings.Builder{}\n\t\t\tenc := NewEncoder(builder)\n\t\t\tenc.isPooled = 1\n\t\t\tdefer func() {\n\t\t\t\terr := recover()\n\t\t\t\tassert.NotNil(t, err, \"err should not be nil\")\n\t\t\t\tassert.IsType(t, InvalidUsagePooledEncoderError(\"\"), err, \"err should be of type InvalidUsagePooledEncoderError\")\n\t\t\t}()\n\t\t\t_ = enc.EncodeSQLNullBool(&sql.NullBool{})\n\t\t\tassert.True(t, false, \"should not be called as encoder should have panicked\")\n\t\t},\n\t)\n\n\tt.Run(\n\t\t\"should return an error as the writer encounters an error\",\n\t\tfunc(t *testing.T) {\n\t\t\tbuilder := TestWriterError(\"\")\n\t\t\tenc := NewEncoder(builder)\n\t\t\terr := enc.EncodeSQLNullBool(&sql.NullBool{})\n\t\t\tassert.NotNil(t, err)\n\t\t},\n\t)\n}\n\nfunc TestAddSQLNullBoolKey(t *testing.T) {\n\tt.Run(\n\t\t\"AddSQLNullBoolKey\",\n\t\tfunc(t *testing.T) {\n\t\t\ttestCases := []struct {\n\t\t\t\tname           string\n\t\t\t\tsqlNullBool    sql.NullBool\n\t\t\t\tbaseJSON       string\n\t\t\t\texpectedResult string\n\t\t\t\terr            bool\n\t\t\t}{\n\t\t\t\t{\n\t\t\t\t\tname: \"it should encode a null string\",\n\t\t\t\t\tsqlNullBool: sql.NullBool{\n\t\t\t\t\t\tBool: true,\n\t\t\t\t\t},\n\t\t\t\t\tbaseJSON:       \"{\",\n\t\t\t\t\texpectedResult: `{\"foo\":true`,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tname: \"it should encode a null string\",\n\t\t\t\t\tsqlNullBool: sql.NullBool{\n\t\t\t\t\t\tBool: false,\n\t\t\t\t\t},\n\t\t\t\t\tbaseJSON:       \"{\",\n\t\t\t\t\texpectedResult: `{\"foo\":false`,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tname: \"it should encode a null string\",\n\t\t\t\t\tsqlNullBool: sql.NullBool{\n\t\t\t\t\t\tBool: true,\n\t\t\t\t\t},\n\t\t\t\t\tbaseJSON:       \"{\",\n\t\t\t\t\texpectedResult: `{\"foo\":true`,\n\t\t\t\t},\n\t\t\t}\n\n\t\t\tfor _, testCase := range testCases {\n\t\t\t\tt.Run(testCase.name, func(t *testing.T) {\n\t\t\t\t\tvar b strings.Builder\n\t\t\t\t\tenc := NewEncoder(&b)\n\t\t\t\t\tenc.writeString(testCase.baseJSON)\n\t\t\t\t\tenc.AddSQLNullBoolKey(\"foo\", &testCase.sqlNullBool)\n\t\t\t\t\tenc.Write()\n\t\t\t\t\tassert.Equal(t, testCase.expectedResult, b.String())\n\n\t\t\t\t\tvar b2 strings.Builder\n\t\t\t\t\tenc = NewEncoder(&b2)\n\t\t\t\t\tenc.writeString(testCase.baseJSON)\n\t\t\t\t\tenc.SQLNullBoolKey(\"foo\", &testCase.sqlNullBool)\n\t\t\t\t\tenc.Write()\n\t\t\t\t\tassert.Equal(t, testCase.expectedResult, b2.String())\n\t\t\t\t})\n\t\t\t}\n\t\t},\n\t)\n\tt.Run(\n\t\t\"AddSQLNullBoolKeyOmitEmpty, is should encode a sql.NullBool\",\n\t\tfunc(t *testing.T) {\n\t\t\ttestCases := []struct {\n\t\t\t\tname           string\n\t\t\t\tsqlNullBool    sql.NullBool\n\t\t\t\tbaseJSON       string\n\t\t\t\texpectedResult string\n\t\t\t\terr            bool\n\t\t\t}{\n\t\t\t\t{\n\t\t\t\t\tname: \"it should encode a null string\",\n\t\t\t\t\tsqlNullBool: sql.NullBool{\n\t\t\t\t\t\tBool:  true,\n\t\t\t\t\t\tValid: true,\n\t\t\t\t\t},\n\t\t\t\t\tbaseJSON:       \"{\",\n\t\t\t\t\texpectedResult: `{\"foo\":true`,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tname: \"it should not encode anything as null string is invalid\",\n\t\t\t\t\tsqlNullBool: sql.NullBool{\n\t\t\t\t\t\tBool:  true,\n\t\t\t\t\t\tValid: false,\n\t\t\t\t\t},\n\t\t\t\t\tbaseJSON:       \"{\",\n\t\t\t\t\texpectedResult: `{`,\n\t\t\t\t},\n\t\t\t}\n\n\t\t\tfor _, testCase := range testCases {\n\t\t\t\tt.Run(testCase.name, func(t *testing.T) {\n\t\t\t\t\tvar b strings.Builder\n\t\t\t\t\tenc := NewEncoder(&b)\n\t\t\t\t\tenc.writeString(testCase.baseJSON)\n\t\t\t\t\tenc.AddSQLNullBoolKeyOmitEmpty(\"foo\", &testCase.sqlNullBool)\n\t\t\t\t\tenc.Write()\n\t\t\t\t\tassert.Equal(t, testCase.expectedResult, b.String())\n\n\t\t\t\t\tvar b2 strings.Builder\n\t\t\t\t\tenc = NewEncoder(&b2)\n\t\t\t\t\tenc.writeString(testCase.baseJSON)\n\t\t\t\t\tenc.SQLNullBoolKeyOmitEmpty(\"foo\", &testCase.sqlNullBool)\n\t\t\t\t\tenc.Write()\n\t\t\t\t\tassert.Equal(t, testCase.expectedResult, b2.String())\n\t\t\t\t})\n\t\t\t}\n\t\t},\n\t)\n}\n\nfunc TestAddSQLNullBool(t *testing.T) {\n\tt.Run(\n\t\t\"AddSQLNullBool\",\n\t\tfunc(t *testing.T) {\n\t\t\ttestCases := []struct {\n\t\t\t\tname           string\n\t\t\t\tsqlNullBool    sql.NullBool\n\t\t\t\tbaseJSON       string\n\t\t\t\texpectedResult string\n\t\t\t\terr            bool\n\t\t\t}{\n\t\t\t\t{\n\t\t\t\t\tname: \"it should encode a null string\",\n\t\t\t\t\tsqlNullBool: sql.NullBool{\n\t\t\t\t\t\tBool: true,\n\t\t\t\t\t},\n\t\t\t\t\tbaseJSON:       \"[\",\n\t\t\t\t\texpectedResult: `[true`,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tname: \"it should encode a null string\",\n\t\t\t\t\tsqlNullBool: sql.NullBool{\n\t\t\t\t\t\tBool: true,\n\t\t\t\t\t},\n\t\t\t\t\tbaseJSON:       \"[\",\n\t\t\t\t\texpectedResult: `[true`,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tname: \"it should encode a null string\",\n\t\t\t\t\tsqlNullBool: sql.NullBool{\n\t\t\t\t\t\tBool: false,\n\t\t\t\t\t},\n\t\t\t\t\tbaseJSON:       \"[\",\n\t\t\t\t\texpectedResult: `[false`,\n\t\t\t\t},\n\t\t\t}\n\n\t\t\tfor _, testCase := range testCases {\n\t\t\t\tt.Run(testCase.name, func(t *testing.T) {\n\t\t\t\t\tvar b strings.Builder\n\t\t\t\t\tenc := NewEncoder(&b)\n\t\t\t\t\tenc.writeString(testCase.baseJSON)\n\t\t\t\t\tenc.AddSQLNullBool(&testCase.sqlNullBool)\n\t\t\t\t\tenc.Write()\n\t\t\t\t\tassert.Equal(t, testCase.expectedResult, b.String())\n\n\t\t\t\t\tvar b2 strings.Builder\n\t\t\t\t\tenc = NewEncoder(&b2)\n\t\t\t\t\tenc.writeString(testCase.baseJSON)\n\t\t\t\t\tenc.SQLNullBool(&testCase.sqlNullBool)\n\t\t\t\t\tenc.Write()\n\t\t\t\t\tassert.Equal(t, testCase.expectedResult, b2.String())\n\t\t\t\t})\n\t\t\t}\n\t\t},\n\t)\n\tt.Run(\n\t\t\"AddSQLNullBoolKeyOmitEmpty, is should encode a sql.NullBool\",\n\t\tfunc(t *testing.T) {\n\t\t\ttestCases := []struct {\n\t\t\t\tname           string\n\t\t\t\tsqlNullBool    sql.NullBool\n\t\t\t\tbaseJSON       string\n\t\t\t\texpectedResult string\n\t\t\t\terr            bool\n\t\t\t}{\n\t\t\t\t{\n\t\t\t\t\tname: \"it should encode a null string\",\n\t\t\t\t\tsqlNullBool: sql.NullBool{\n\t\t\t\t\t\tBool:  true,\n\t\t\t\t\t\tValid: true,\n\t\t\t\t\t},\n\t\t\t\t\tbaseJSON:       \"[\",\n\t\t\t\t\texpectedResult: `[true`,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tname: \"it should not encode anything as null string is invalid\",\n\t\t\t\t\tsqlNullBool: sql.NullBool{\n\t\t\t\t\t\tBool:  true,\n\t\t\t\t\t\tValid: false,\n\t\t\t\t\t},\n\t\t\t\t\tbaseJSON:       \"[\",\n\t\t\t\t\texpectedResult: `[`,\n\t\t\t\t},\n\t\t\t}\n\n\t\t\tfor _, testCase := range testCases {\n\t\t\t\tt.Run(testCase.name, func(t *testing.T) {\n\t\t\t\t\tvar b strings.Builder\n\t\t\t\t\tenc := NewEncoder(&b)\n\t\t\t\t\tenc.writeString(testCase.baseJSON)\n\t\t\t\t\tenc.AddSQLNullBoolOmitEmpty(&testCase.sqlNullBool)\n\t\t\t\t\tenc.Write()\n\t\t\t\t\tassert.Equal(t, testCase.expectedResult, b.String())\n\n\t\t\t\t\tvar b2 strings.Builder\n\t\t\t\t\tenc = NewEncoder(&b2)\n\t\t\t\t\tenc.writeString(testCase.baseJSON)\n\t\t\t\t\tenc.SQLNullBoolOmitEmpty(&testCase.sqlNullBool)\n\t\t\t\t\tenc.Write()\n\t\t\t\t\tassert.Equal(t, testCase.expectedResult, b2.String())\n\t\t\t\t})\n\t\t\t}\n\t\t},\n\t)\n}\n\nfunc TestEncoderSQLNullStringEmpty(t *testing.T) {\n\tvar testCases = []struct {\n\t\tname         string\n\t\tbaseJSON     string\n\t\texpectedJSON string\n\t}{\n\t\t{\n\t\t\tname:         \"basic 1st elem\",\n\t\t\tbaseJSON:     \"[\",\n\t\t\texpectedJSON: `[null,\"bar\"`,\n\t\t},\n\t\t{\n\t\t\tname:         \"basic 2nd elem\",\n\t\t\tbaseJSON:     `[\"test\"`,\n\t\t\texpectedJSON: `[\"test\",null,\"bar\"`,\n\t\t},\n\t}\n\tfor _, testCase := range testCases {\n\t\tt.Run(testCase.name, func(t *testing.T) {\n\t\t\tvar b strings.Builder\n\t\t\tvar enc = NewEncoder(&b)\n\t\t\tenc.writeString(testCase.baseJSON)\n\t\t\tenc.AddSQLNullStringNullEmpty(&sql.NullString{\"\", true})\n\t\t\tenc.SQLNullStringNullEmpty(&sql.NullString{\"bar\", true})\n\t\t\tenc.Write()\n\t\t\tassert.Equal(t, testCase.expectedJSON, b.String())\n\t\t})\n\t}\n}\n\nfunc TestEncoderSQLNullStringKeyNullEmpty(t *testing.T) {\n\tvar testCases = []struct {\n\t\tname         string\n\t\tbaseJSON     string\n\t\texpectedJSON string\n\t}{\n\t\t{\n\t\t\tname:         \"basic 1st elem\",\n\t\t\tbaseJSON:     \"{\",\n\t\t\texpectedJSON: `{\"foo\":null,\"bar\":\"bar\"`,\n\t\t},\n\t\t{\n\t\t\tname:         \"basic 2nd elem\",\n\t\t\tbaseJSON:     `{\"test\":\"test\"`,\n\t\t\texpectedJSON: `{\"test\":\"test\",\"foo\":null,\"bar\":\"bar\"`,\n\t\t},\n\t}\n\tfor _, testCase := range testCases {\n\t\tt.Run(testCase.name, func(t *testing.T) {\n\t\t\tvar b strings.Builder\n\t\t\tvar enc = NewEncoder(&b)\n\t\t\tenc.writeString(testCase.baseJSON)\n\t\t\tenc.SQLNullStringKeyNullEmpty(\"foo\", &sql.NullString{\"\", true})\n\t\t\tenc.SQLNullStringKeyNullEmpty(\"bar\", &sql.NullString{\"bar\", true})\n\t\t\tenc.Write()\n\t\t\tassert.Equal(t, testCase.expectedJSON, b.String())\n\t\t})\n\t}\n}\n\nfunc TestEncoderSQLNullBoolEmpty(t *testing.T) {\n\tvar testCases = []struct {\n\t\tname         string\n\t\tbaseJSON     string\n\t\texpectedJSON string\n\t}{\n\t\t{\n\t\t\tname:         \"basic 1st elem\",\n\t\t\tbaseJSON:     \"[\",\n\t\t\texpectedJSON: `[null,true`,\n\t\t},\n\t\t{\n\t\t\tname:         \"basic 2nd elem\",\n\t\t\tbaseJSON:     `[\"test\"`,\n\t\t\texpectedJSON: `[\"test\",null,true`,\n\t\t},\n\t}\n\tfor _, testCase := range testCases {\n\t\tt.Run(testCase.name, func(t *testing.T) {\n\t\t\tvar b strings.Builder\n\t\t\tvar enc = NewEncoder(&b)\n\t\t\tenc.writeString(testCase.baseJSON)\n\t\t\tenc.SQLNullBoolNullEmpty(&sql.NullBool{false, true})\n\t\t\tenc.SQLNullBoolNullEmpty(&sql.NullBool{true, true})\n\t\t\tenc.Write()\n\t\t\tassert.Equal(t, testCase.expectedJSON, b.String())\n\t\t})\n\t}\n}\n\nfunc TestEncoderSQLNullBoolKeyNullEmpty(t *testing.T) {\n\tvar testCases = []struct {\n\t\tname         string\n\t\tbaseJSON     string\n\t\texpectedJSON string\n\t}{\n\t\t{\n\t\t\tname:         \"basic 1st elem\",\n\t\t\tbaseJSON:     \"{\",\n\t\t\texpectedJSON: `{\"foo\":null,\"bar\":true`,\n\t\t},\n\t\t{\n\t\t\tname:         \"basic 2nd elem\",\n\t\t\tbaseJSON:     `{\"test\":\"test\"`,\n\t\t\texpectedJSON: `{\"test\":\"test\",\"foo\":null,\"bar\":true`,\n\t\t},\n\t}\n\tfor _, testCase := range testCases {\n\t\tt.Run(testCase.name, func(t *testing.T) {\n\t\t\tvar b strings.Builder\n\t\t\tvar enc = NewEncoder(&b)\n\t\t\tenc.writeString(testCase.baseJSON)\n\t\t\tenc.AddSQLNullBoolKeyNullEmpty(\"foo\", &sql.NullBool{false, true})\n\t\t\tenc.SQLNullBoolKeyNullEmpty(\"bar\", &sql.NullBool{true, true})\n\t\t\tenc.Write()\n\t\t\tassert.Equal(t, testCase.expectedJSON, b.String())\n\t\t})\n\t}\n}\n\nfunc TestEncoderSQLNullInt64Empty(t *testing.T) {\n\tvar testCases = []struct {\n\t\tname         string\n\t\tbaseJSON     string\n\t\texpectedJSON string\n\t}{\n\t\t{\n\t\t\tname:         \"basic 1st elem\",\n\t\t\tbaseJSON:     \"[\",\n\t\t\texpectedJSON: `[null,1`,\n\t\t},\n\t\t{\n\t\t\tname:         \"basic 2nd elem\",\n\t\t\tbaseJSON:     `[\"test\"`,\n\t\t\texpectedJSON: `[\"test\",null,1`,\n\t\t},\n\t}\n\tfor _, testCase := range testCases {\n\t\tt.Run(testCase.name, func(t *testing.T) {\n\t\t\tvar b strings.Builder\n\t\t\tvar enc = NewEncoder(&b)\n\t\t\tenc.writeString(testCase.baseJSON)\n\t\t\tenc.AddSQLNullInt64NullEmpty(&sql.NullInt64{0, true})\n\t\t\tenc.SQLNullInt64NullEmpty(&sql.NullInt64{1, true})\n\t\t\tenc.Write()\n\t\t\tassert.Equal(t, testCase.expectedJSON, b.String())\n\t\t})\n\t}\n}\n\nfunc TestEncoderSQLNullInt64KeyNullEmpty(t *testing.T) {\n\tvar testCases = []struct {\n\t\tname         string\n\t\tbaseJSON     string\n\t\texpectedJSON string\n\t}{\n\t\t{\n\t\t\tname:         \"basic 1st elem\",\n\t\t\tbaseJSON:     \"{\",\n\t\t\texpectedJSON: `{\"foo\":null,\"bar\":1`,\n\t\t},\n\t\t{\n\t\t\tname:         \"basic 2nd elem\",\n\t\t\tbaseJSON:     `{\"test\":\"test\"`,\n\t\t\texpectedJSON: `{\"test\":\"test\",\"foo\":null,\"bar\":1`,\n\t\t},\n\t}\n\tfor _, testCase := range testCases {\n\t\tt.Run(testCase.name, func(t *testing.T) {\n\t\t\tvar b strings.Builder\n\t\t\tvar enc = NewEncoder(&b)\n\t\t\tenc.writeString(testCase.baseJSON)\n\t\t\tenc.AddSQLNullInt64KeyNullEmpty(\"foo\", &sql.NullInt64{0, true})\n\t\t\tenc.SQLNullInt64KeyNullEmpty(\"bar\", &sql.NullInt64{1, true})\n\t\t\tenc.Write()\n\t\t\tassert.Equal(t, testCase.expectedJSON, b.String())\n\t\t})\n\t}\n}\n\nfunc TestEncoderSQLNullFloat64Empty(t *testing.T) {\n\tvar testCases = []struct {\n\t\tname         string\n\t\tbaseJSON     string\n\t\texpectedJSON string\n\t}{\n\t\t{\n\t\t\tname:         \"basic 1st elem\",\n\t\t\tbaseJSON:     \"[\",\n\t\t\texpectedJSON: `[null,1`,\n\t\t},\n\t\t{\n\t\t\tname:         \"basic 2nd elem\",\n\t\t\tbaseJSON:     `[\"test\"`,\n\t\t\texpectedJSON: `[\"test\",null,1`,\n\t\t},\n\t}\n\tfor _, testCase := range testCases {\n\t\tt.Run(testCase.name, func(t *testing.T) {\n\t\t\tvar b strings.Builder\n\t\t\tvar enc = NewEncoder(&b)\n\t\t\tenc.writeString(testCase.baseJSON)\n\t\t\tenc.AddSQLNullFloat64NullEmpty(&sql.NullFloat64{0, true})\n\t\t\tenc.SQLNullFloat64NullEmpty(&sql.NullFloat64{1, true})\n\t\t\tenc.Write()\n\t\t\tassert.Equal(t, testCase.expectedJSON, b.String())\n\t\t})\n\t}\n}\n\nfunc TestEncoderSQLNullFloat64KeyNullEmpty(t *testing.T) {\n\tvar testCases = []struct {\n\t\tname         string\n\t\tbaseJSON     string\n\t\texpectedJSON string\n\t}{\n\t\t{\n\t\t\tname:         \"basic 1st elem\",\n\t\t\tbaseJSON:     \"{\",\n\t\t\texpectedJSON: `{\"foo\":null,\"bar\":1`,\n\t\t},\n\t\t{\n\t\t\tname:         \"basic 2nd elem\",\n\t\t\tbaseJSON:     `{\"test\":\"test\"`,\n\t\t\texpectedJSON: `{\"test\":\"test\",\"foo\":null,\"bar\":1`,\n\t\t},\n\t}\n\tfor _, testCase := range testCases {\n\t\tt.Run(testCase.name, func(t *testing.T) {\n\t\t\tvar b strings.Builder\n\t\t\tvar enc = NewEncoder(&b)\n\t\t\tenc.writeString(testCase.baseJSON)\n\t\t\tenc.AddSQLNullFloat64KeyNullEmpty(\"foo\", &sql.NullFloat64{0, true})\n\t\t\tenc.SQLNullFloat64KeyNullEmpty(\"bar\", &sql.NullFloat64{1, true})\n\t\t\tenc.Write()\n\t\t\tassert.Equal(t, testCase.expectedJSON, b.String())\n\t\t})\n\t}\n}\n"
        },
        {
          "name": "encode_stream.go",
          "type": "blob",
          "size": 5.009765625,
          "content": "package gojay\n\nimport (\n\t\"strconv\"\n\t\"sync\"\n\t\"time\"\n)\n\n// MarshalerStream is the interface to implement\n// to continuously encode of stream of data.\ntype MarshalerStream interface {\n\tMarshalStream(enc *StreamEncoder)\n}\n\n// A StreamEncoder reads and encodes values to JSON from an input stream.\n//\n// It implements conext.Context and provide a channel to notify interruption.\ntype StreamEncoder struct {\n\tmux *sync.RWMutex\n\t*Encoder\n\tnConsumer int\n\tdelimiter byte\n\tdeadline  *time.Time\n\tdone      chan struct{}\n}\n\n// EncodeStream spins up a defined number of non blocking consumers of the MarshalerStream m.\n//\n// m must implement MarshalerStream. Ideally m is a channel. See example for implementation.\n//\n// See the documentation for Marshal for details about the conversion of Go value to JSON.\nfunc (s *StreamEncoder) EncodeStream(m MarshalerStream) {\n\t// if a single consumer, just use this encoder\n\tif s.nConsumer == 1 {\n\t\tgo consume(s, s, m)\n\t\treturn\n\t}\n\t// else use this Encoder only for first consumer\n\t// and use new encoders for other consumers\n\t// this is to avoid concurrent writing to same buffer\n\t// resulting in a weird JSON\n\tgo consume(s, s, m)\n\tfor i := 1; i < s.nConsumer; i++ {\n\t\ts.mux.RLock()\n\t\tselect {\n\t\tcase <-s.done:\n\t\tdefault:\n\t\t\tss := Stream.borrowEncoder(s.w)\n\t\t\tss.mux.Lock()\n\t\t\tss.done = s.done\n\t\t\tss.buf = make([]byte, 0, 512)\n\t\t\tss.delimiter = s.delimiter\n\t\t\tgo consume(s, ss, m)\n\t\t\tss.mux.Unlock()\n\t\t}\n\t\ts.mux.RUnlock()\n\t}\n\treturn\n}\n\n// LineDelimited sets the delimiter to a new line character.\n//\n// It will add a new line after each JSON marshaled by the MarshalerStream\nfunc (s *StreamEncoder) LineDelimited() *StreamEncoder {\n\ts.delimiter = '\\n'\n\treturn s\n}\n\n// CommaDelimited sets the delimiter to a comma.\n//\n// It will add a new line after each JSON marshaled by the MarshalerStream\nfunc (s *StreamEncoder) CommaDelimited() *StreamEncoder {\n\ts.delimiter = ','\n\treturn s\n}\n\n// NConsumer sets the number of non blocking go routine to consume the stream.\nfunc (s *StreamEncoder) NConsumer(n int) *StreamEncoder {\n\ts.nConsumer = n\n\treturn s\n}\n\n// Release sends back a Decoder to the pool.\n// If a decoder is used after calling Release\n// a panic will be raised with an InvalidUsagePooledDecoderError error.\nfunc (s *StreamEncoder) Release() {\n\ts.isPooled = 1\n\tstreamEncPool.Put(s)\n}\n\n// Done returns a channel that's closed when work is done.\n// It implements context.Context\nfunc (s *StreamEncoder) Done() <-chan struct{} {\n\treturn s.done\n}\n\n// Err returns nil if Done is not yet closed.\n// If Done is closed, Err returns a non-nil error explaining why.\n// It implements context.Context\nfunc (s *StreamEncoder) Err() error {\n\treturn s.err\n}\n\n// Deadline returns the time when work done on behalf of this context\n// should be canceled. Deadline returns ok==false when no deadline is\n// set. Successive calls to Deadline return the same results.\nfunc (s *StreamEncoder) Deadline() (time.Time, bool) {\n\tif s.deadline != nil {\n\t\treturn *s.deadline, true\n\t}\n\treturn time.Time{}, false\n}\n\n// SetDeadline sets the deadline\nfunc (s *StreamEncoder) SetDeadline(t time.Time) {\n\ts.deadline = &t\n}\n\n// Value implements context.Context\nfunc (s *StreamEncoder) Value(key interface{}) interface{} {\n\treturn nil\n}\n\n// Cancel cancels the consumers of the stream, interrupting the stream encoding.\n//\n// After calling cancel, Done() will return a closed channel.\nfunc (s *StreamEncoder) Cancel(err error) {\n\ts.mux.Lock()\n\tdefer s.mux.Unlock()\n\t\n\tselect {\n\tcase <-s.done:\n\tdefault:\n\t\ts.err = err\n\t\tclose(s.done)\n\t}\n}\n\n// AddObject adds an object to be encoded.\n// value must implement MarshalerJSONObject.\nfunc (s *StreamEncoder) AddObject(v MarshalerJSONObject) {\n\tif v.IsNil() {\n\t\treturn\n\t}\n\ts.Encoder.writeByte('{')\n\tv.MarshalJSONObject(s.Encoder)\n\ts.Encoder.writeByte('}')\n\ts.Encoder.writeByte(s.delimiter)\n}\n\n// AddString adds a string to be encoded.\nfunc (s *StreamEncoder) AddString(v string) {\n\ts.Encoder.writeByte('\"')\n\ts.Encoder.writeString(v)\n\ts.Encoder.writeByte('\"')\n\ts.Encoder.writeByte(s.delimiter)\n}\n\n// AddArray adds an implementation of MarshalerJSONArray to be encoded.\nfunc (s *StreamEncoder) AddArray(v MarshalerJSONArray) {\n\ts.Encoder.writeByte('[')\n\tv.MarshalJSONArray(s.Encoder)\n\ts.Encoder.writeByte(']')\n\ts.Encoder.writeByte(s.delimiter)\n}\n\n// AddInt adds an int to be encoded.\nfunc (s *StreamEncoder) AddInt(value int) {\n\ts.buf = strconv.AppendInt(s.buf, int64(value), 10)\n\ts.Encoder.writeByte(s.delimiter)\n}\n\n// AddFloat64 adds a float64 to be encoded.\nfunc (s *StreamEncoder) AddFloat64(value float64) {\n\ts.buf = strconv.AppendFloat(s.buf, value, 'f', -1, 64)\n\ts.Encoder.writeByte(s.delimiter)\n}\n\n// AddFloat adds a float64 to be encoded.\nfunc (s *StreamEncoder) AddFloat(value float64) {\n\ts.AddFloat64(value)\n}\n\n// Non exposed\n\nfunc consume(init *StreamEncoder, s *StreamEncoder, m MarshalerStream) {\n\tdefer s.Release()\n\tfor {\n\t\tselect {\n\t\tcase <-init.Done():\n\t\t\treturn\n\t\tdefault:\n\t\t\tm.MarshalStream(s)\n\t\t\tif s.Encoder.err != nil {\n\t\t\t\tinit.Cancel(s.Encoder.err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\ti, err := s.Encoder.Write()\n\t\t\tif err != nil || i == 0 {\n\t\t\t\tinit.Cancel(err)\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t}\n}\n"
        },
        {
          "name": "encode_stream_pool.go",
          "type": "blob",
          "size": 1.1064453125,
          "content": "package gojay\n\nimport (\n\t\"io\"\n\t\"sync\"\n)\n\n// NewEncoder returns a new StreamEncoder.\n// It takes an io.Writer implementation to output data.\n// It initiates the done channel returned by Done().\nfunc (s stream) NewEncoder(w io.Writer) *StreamEncoder {\n\tenc := BorrowEncoder(w)\n\treturn &StreamEncoder{Encoder: enc, nConsumer: 1, done: make(chan struct{}, 1), mux: &sync.RWMutex{}}\n}\n\n// BorrowEncoder borrows a StreamEncoder from the pool.\n// It takes an io.Writer implementation to output data.\n// It initiates the done channel returned by Done().\n//\n// If no StreamEncoder is available in the pool, it returns a fresh one\nfunc (s stream) BorrowEncoder(w io.Writer) *StreamEncoder {\n\tstreamEnc := streamEncPool.Get().(*StreamEncoder)\n\tstreamEnc.w = w\n\tstreamEnc.Encoder.err = nil\n\tstreamEnc.done = make(chan struct{}, 1)\n\tstreamEnc.Encoder.buf = streamEnc.buf[:0]\n\tstreamEnc.nConsumer = 1\n\tstreamEnc.isPooled = 0\n\treturn streamEnc\n}\n\nfunc (s stream) borrowEncoder(w io.Writer) *StreamEncoder {\n\tstreamEnc := streamEncPool.Get().(*StreamEncoder)\n\tstreamEnc.isPooled = 0\n\tstreamEnc.w = w\n\tstreamEnc.Encoder.err = nil\n\treturn streamEnc\n}\n"
        },
        {
          "name": "encode_stream_test.go",
          "type": "blob",
          "size": 9.0390625,
          "content": "package gojay\n\nimport (\n\t\"os\"\n\t\"sync\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\ntype StreamChanObject chan *testObject\n\nfunc (s StreamChanObject) MarshalStream(enc *StreamEncoder) {\n\tselect {\n\tcase <-enc.Done():\n\t\treturn\n\tcase o := <-s:\n\t\tenc.AddObject(o)\n\t}\n}\n\ntype StreamChanSlice chan *TestEncodingArrStrings\n\nfunc (s StreamChanSlice) MarshalStream(enc *StreamEncoder) {\n\tselect {\n\tcase <-enc.Done():\n\t\treturn\n\tcase o := <-s:\n\t\tenc.AddArray(o)\n\t}\n}\n\ntype StreamChanString chan string\n\nfunc (s StreamChanString) MarshalStream(enc *StreamEncoder) {\n\tselect {\n\tcase <-enc.Done():\n\t\treturn\n\tcase o := <-s:\n\t\tenc.AddString(o)\n\t}\n}\n\ntype StreamChanInt chan int\n\nfunc (s StreamChanInt) MarshalStream(enc *StreamEncoder) {\n\tselect {\n\tcase <-enc.Done():\n\t\treturn\n\tcase o := <-s:\n\t\tenc.AddInt(o)\n\t}\n}\n\ntype StreamChanFloat chan float64\n\nfunc (s StreamChanFloat) MarshalStream(enc *StreamEncoder) {\n\tselect {\n\tcase <-enc.Done():\n\t\treturn\n\tcase o := <-s:\n\t\tenc.AddFloat(o)\n\t}\n}\n\ntype StreamChanError chan *testObject\n\nfunc (s StreamChanError) MarshalStream(enc *StreamEncoder) {\n\tselect {\n\tcase <-enc.Done():\n\t\treturn\n\tcase <-s:\n\t\tenc.AddInterface(struct{}{})\n\t}\n}\n\n// TestWriter to assert result\ntype TestWriter struct {\n\tnWrite *int\n\ttarget int\n\tenc    *StreamEncoder\n\tresult [][]byte\n\tmux    *sync.RWMutex\n}\n\nfunc (w *TestWriter) Write(b []byte) (int, error) {\n\tif len(b) > 0 {\n\t\tw.mux.Lock()\n\t\tw.result = append(w.result, b)\n\t\tif len(w.result) == w.target {\n\t\t\tw.enc.Cancel(nil)\n\t\t}\n\t\tw.mux.Unlock()\n\t}\n\treturn len(b), nil\n}\n\nfunc feedStreamNil(s chan *testObject, target int) {\n\tfor i := 0; i < target; i++ {\n\t\ts <- nil\n\t}\n}\n\nfunc feedStream(s chan *testObject, target int) {\n\tfor i := 0; i < target; i++ {\n\t\ts <- &testObject{}\n\t}\n}\n\nfunc feedStreamSlices(s chan *TestEncodingArrStrings, target int) {\n\tfor i := 0; i < target; i++ {\n\t\ts <- &TestEncodingArrStrings{\"test\", \"test2\"}\n\t}\n}\n\nfunc feedStreamStrings(s chan string, target int) {\n\tfor i := 0; i < target; i++ {\n\t\ts <- \"hello\"\n\t}\n}\n\nfunc feedStreamInt(s chan int, target int) {\n\tfor i := 0; i < target; i++ {\n\t\ts <- i\n\t}\n}\n\nfunc feedStreamFloat(s chan float64, target int) {\n\tfor i := 0; i < target; i++ {\n\t\ts <- float64(i)\n\t}\n}\n\nfunc TestEncodeStream(t *testing.T) {\n\tt.Run(\"single-consumer-object\", func(t *testing.T) {\n\t\texpectedStr :=\n\t\t\t`{\"testStr\":\"\",\"testInt\":0,\"testInt64\":0,\"testInt32\":0,\"testInt16\":0,\"testInt8\":0,\"testUint64\":0,\"testUint32\":0,\"testUint16\":0,\"testUint8\":0,\"testFloat64\":0,\"testFloat32\":0,\"testBool\":false}\n`\n\t\t// create our writer\n\t\tw := &TestWriter{target: 100, mux: &sync.RWMutex{}}\n\t\tenc := Stream.NewEncoder(w).LineDelimited()\n\t\tw.enc = enc\n\t\ts := StreamChanObject(make(chan *testObject))\n\t\tgo enc.EncodeStream(s)\n\t\tgo feedStream(s, 100)\n\t\tselect {\n\t\tcase <-enc.Done():\n\t\t\tassert.Nil(t, enc.Err(), \"enc.Err() should be nil\")\n\t\t\tassert.Len(t, w.result, 100, \"w.result should be 100\")\n\t\t\tfor _, b := range w.result {\n\t\t\t\tassert.Equal(t, expectedStr, string(b), \"every byte buffer should be equal to expected string\")\n\t\t\t}\n\t\t}\n\t})\n\n\tt.Run(\"single-consumer-slice\", func(t *testing.T) {\n\t\texpectedStr :=\n\t\t\t`[\"test\",\"test2\"]\n`\n\t\t// create our writer\n\t\tw := &TestWriter{target: 100, mux: &sync.RWMutex{}}\n\t\tenc := Stream.NewEncoder(w).LineDelimited()\n\t\tw.enc = enc\n\t\ts := StreamChanSlice(make(chan *TestEncodingArrStrings))\n\t\tgo enc.EncodeStream(s)\n\t\tgo feedStreamSlices(s, 100)\n\t\tselect {\n\t\tcase <-enc.Done():\n\t\t\tassert.Nil(t, enc.Err(), \"enc.Err() should be nil\")\n\t\t\tassert.Len(t, w.result, 100, \"w.result should be 100\")\n\t\t\tfor _, b := range w.result {\n\t\t\t\tassert.Equal(t, expectedStr, string(b), \"every byte buffer should be equal to expected string\")\n\t\t\t}\n\t\t}\n\t})\n\n\tt.Run(\"single-consumer-string\", func(t *testing.T) {\n\t\texpectedStr :=\n\t\t\t`\"hello\"\n`\n\t\t// create our writer\n\t\tw := &TestWriter{target: 100, mux: &sync.RWMutex{}}\n\t\tenc := Stream.NewEncoder(w).LineDelimited()\n\t\tw.enc = enc\n\t\ts := StreamChanString(make(chan string))\n\t\tgo enc.EncodeStream(s)\n\t\tgo feedStreamStrings(s, 100)\n\t\tselect {\n\t\tcase <-enc.Done():\n\t\t\tassert.Nil(t, enc.Err(), \"enc.Err() should be nil\")\n\t\t\tassert.Len(t, w.result, 100, \"w.result should be 100\")\n\t\t\tfor _, b := range w.result {\n\t\t\t\tassert.Equal(t, expectedStr, string(b), \"every byte buffer should be equal to expected string\")\n\t\t\t}\n\t\t}\n\t})\n\n\tt.Run(\"single-consumer-object-nil-value\", func(t *testing.T) {\n\t\texpectedStr := ``\n\t\t// create our writer\n\t\tw := &TestWriter{target: 100, mux: &sync.RWMutex{}}\n\t\tenc := Stream.NewEncoder(w).LineDelimited()\n\t\tw.enc = enc\n\t\ts := StreamChanObject(make(chan *testObject))\n\t\tgo enc.EncodeStream(s)\n\t\tgo feedStreamNil(s, 100)\n\t\tselect {\n\t\tcase <-enc.Done():\n\t\t\tassert.Nil(t, enc.Err(), \"enc.Err() should be nil\")\n\t\t\tassert.Nil(t, enc.Err(), \"enc.Err() should not be nil\")\n\t\t\tfor _, b := range w.result {\n\t\t\t\tassert.Equal(t, expectedStr, string(b), \"every byte buffer should be equal to expected string\")\n\t\t\t}\n\t\t}\n\t})\n\n\tt.Run(\"single-consumer-int\", func(t *testing.T) {\n\t\t// create our writer\n\t\tw := &TestWriter{target: 100, mux: &sync.RWMutex{}}\n\t\tenc := Stream.NewEncoder(w).LineDelimited()\n\t\tw.enc = enc\n\t\ts := StreamChanInt(make(chan int))\n\t\tgo enc.EncodeStream(s)\n\t\tgo feedStreamInt(s, 100)\n\t\tselect {\n\t\tcase <-enc.Done():\n\t\t\tassert.Nil(t, enc.Err(), \"enc.Err() should be nil\")\n\t\t\tassert.Len(t, w.result, 100, \"w.result should be 100\")\n\t\t}\n\t})\n\n\tt.Run(\"single-consumer-float\", func(t *testing.T) {\n\t\t// create our writer\n\t\tw := &TestWriter{target: 100, mux: &sync.RWMutex{}}\n\t\tenc := Stream.NewEncoder(w).LineDelimited()\n\t\tw.enc = enc\n\t\ts := StreamChanFloat(make(chan float64))\n\t\tgo enc.EncodeStream(s)\n\t\tgo feedStreamFloat(s, 100)\n\t\tselect {\n\t\tcase <-enc.Done():\n\t\t\tassert.Nil(t, enc.Err(), \"enc.Err() should be nil\")\n\t\t\tassert.Len(t, w.result, 100, \"w.result should be 100\")\n\t\t}\n\t})\n\n\tt.Run(\"single-consumer-marshal-error\", func(t *testing.T) {\n\t\t// create our writer\n\t\tw := &TestWriter{target: 100, mux: &sync.RWMutex{}}\n\t\tenc := Stream.NewEncoder(w).LineDelimited()\n\t\tw.enc = enc\n\t\ts := StreamChanError(make(chan *testObject))\n\t\tgo enc.EncodeStream(s)\n\t\tgo feedStream(s, 100)\n\t\tselect {\n\t\tcase <-enc.Done():\n\t\t\tassert.NotNil(t, enc.Err(), \"enc.Err() should not be nil\")\n\t\t}\n\t})\n\n\tt.Run(\"single-consumer-write-error\", func(t *testing.T) {\n\t\t// create our writer\n\t\tw := TestWriterError(\"\")\n\t\tenc := Stream.NewEncoder(w).LineDelimited()\n\t\ts := StreamChanObject(make(chan *testObject))\n\t\tgo enc.EncodeStream(s)\n\t\tgo feedStream(s, 100)\n\t\tselect {\n\t\tcase <-enc.Done():\n\t\t\tassert.NotNil(t, enc.Err(), \"enc.Err() should not be nil\")\n\t\t}\n\t})\n\n\tt.Run(\"multiple-consumer-object-comma-delimited\", func(t *testing.T) {\n\t\texpectedStr :=\n\t\t\t`{\"testStr\":\"\",\"testInt\":0,\"testInt64\":0,\"testInt32\":0,\"testInt16\":0,\"testInt8\":0,\"testUint64\":0,\"testUint32\":0,\"testUint16\":0,\"testUint8\":0,\"testFloat64\":0,\"testFloat32\":0,\"testBool\":false},`\n\t\t// create our writer\n\t\tw := &TestWriter{target: 5000, mux: &sync.RWMutex{}}\n\t\tenc := Stream.BorrowEncoder(w).NConsumer(50).CommaDelimited()\n\t\tw.enc = enc\n\t\ts := StreamChanObject(make(chan *testObject))\n\t\tgo enc.EncodeStream(s)\n\t\tgo feedStream(s, 5000)\n\t\tselect {\n\t\tcase <-enc.Done():\n\t\t\tassert.Nil(t, enc.Err(), \"enc.Err() should be nil\")\n\t\t\tassert.Len(t, w.result, 5000, \"w.result should be 100\")\n\t\t\tfor _, b := range w.result {\n\t\t\t\tassert.Equal(t, expectedStr, string(b), \"every byte buffer should be equal to expected string\")\n\t\t\t}\n\t\t}\n\t})\n\n\tt.Run(\"multiple-consumer-object-line-delimited\", func(t *testing.T) {\n\t\texpectedStr :=\n\t\t\t`{\"testStr\":\"\",\"testInt\":0,\"testInt64\":0,\"testInt32\":0,\"testInt16\":0,\"testInt8\":0,\"testUint64\":0,\"testUint32\":0,\"testUint16\":0,\"testUint8\":0,\"testFloat64\":0,\"testFloat32\":0,\"testBool\":false}\n`\n\t\t// create our writer\n\t\tw := &TestWriter{target: 5000, mux: &sync.RWMutex{}}\n\t\tenc := Stream.NewEncoder(w).NConsumer(50).LineDelimited()\n\t\tw.enc = enc\n\t\ts := StreamChanObject(make(chan *testObject))\n\t\tgo feedStream(s, 5000)\n\t\tgo enc.EncodeStream(s)\n\t\tselect {\n\t\tcase <-enc.Done():\n\t\t\tassert.Nil(t, enc.Err(), \"enc.Err() should be nil\")\n\t\t\tassert.Len(t, w.result, 5000, \"w.result should be 100\")\n\t\t\tfor _, b := range w.result {\n\t\t\t\tassert.Equal(t, expectedStr, string(b), \"every byte buffer should be equal to expected string\")\n\t\t\t}\n\t\t}\n\t})\n\n\tt.Run(\"multiple-consumer-object-chan-closed\", func(t *testing.T) {\n\t\t// create our writer\n\t\tw := &TestWriter{target: 5000, mux: &sync.RWMutex{}}\n\t\tenc := Stream.NewEncoder(w).NConsumer(50).LineDelimited()\n\t\tw.enc = enc\n\t\ts := StreamChanObject(make(chan *testObject))\n\t\tclose(enc.done)\n\t\tgo feedStream(s, 5000)\n\t\tgo enc.EncodeStream(s)\n\t\tselect {\n\t\tcase <-enc.Done():\n\t\t\tassert.Nil(t, enc.Err(), \"enc.Err() should be nil\")\n\t\t\tassert.Len(t, w.result, 0, \"w.result should be 0\")\n\t\t}\n\t})\n\n\tt.Run(\"encoder-deadline\", func(t *testing.T) {\n\t\tenc := Stream.NewEncoder(os.Stdout)\n\t\tnow := time.Now()\n\t\tenc.SetDeadline(now)\n\t\td, _ := enc.Deadline()\n\t\tassert.Equal(t, now, d, \"deadline should be the one just set\")\n\t})\n\n\tt.Run(\"encoder-deadline-unset\", func(t *testing.T) {\n\t\tenc := Stream.NewEncoder(os.Stdout)\n\t\td, _ := enc.Deadline()\n\t\tassert.Equal(t, time.Time{}, d, \"deadline should be the one just set\")\n\t})\n\n\t// just for coverage\n\tt.Run(\"encoder-context-value\", func(t *testing.T) {\n\t\tenc := Stream.NewEncoder(os.Stdout)\n\t\tassert.Nil(t, enc.Value(\"\"), \"enc.Value should be nil\")\n\t})\n}\n"
        },
        {
          "name": "encode_string.go",
          "type": "blob",
          "size": 4.619140625,
          "content": "package gojay\n\n// EncodeString encodes a string to\nfunc (enc *Encoder) EncodeString(s string) error {\n\tif enc.isPooled == 1 {\n\t\tpanic(InvalidUsagePooledEncoderError(\"Invalid usage of pooled encoder\"))\n\t}\n\t_, _ = enc.encodeString(s)\n\t_, err := enc.Write()\n\tif err != nil {\n\t\tenc.err = err\n\t\treturn err\n\t}\n\treturn nil\n}\n\n// encodeString encodes a string to\nfunc (enc *Encoder) encodeString(v string) ([]byte, error) {\n\tenc.writeByte('\"')\n\tenc.writeStringEscape(v)\n\tenc.writeByte('\"')\n\treturn enc.buf, nil\n}\n\n// AppendString appends a string to the buffer\nfunc (enc *Encoder) AppendString(v string) {\n\tenc.grow(len(v) + 2)\n\tenc.writeByte('\"')\n\tenc.writeStringEscape(v)\n\tenc.writeByte('\"')\n}\n\n// AddString adds a string to be encoded, must be used inside a slice or array encoding (does not encode a key)\nfunc (enc *Encoder) AddString(v string) {\n\tenc.String(v)\n}\n\n// AddStringOmitEmpty adds a string to be encoded or skips it if it is zero value.\n// Must be used inside a slice or array encoding (does not encode a key)\nfunc (enc *Encoder) AddStringOmitEmpty(v string) {\n\tenc.StringOmitEmpty(v)\n}\n\n// AddStringNullEmpty adds a string to be encoded or skips it if it is zero value.\n// Must be used inside a slice or array encoding (does not encode a key)\nfunc (enc *Encoder) AddStringNullEmpty(v string) {\n\tenc.StringNullEmpty(v)\n}\n\n// AddStringKey adds a string to be encoded, must be used inside an object as it will encode a key\nfunc (enc *Encoder) AddStringKey(key, v string) {\n\tenc.StringKey(key, v)\n}\n\n// AddStringKeyOmitEmpty adds a string to be encoded or skips it if it is zero value.\n// Must be used inside an object as it will encode a key\nfunc (enc *Encoder) AddStringKeyOmitEmpty(key, v string) {\n\tenc.StringKeyOmitEmpty(key, v)\n}\n\n// AddStringKeyNullEmpty adds a string to be encoded or skips it if it is zero value.\n// Must be used inside an object as it will encode a key\nfunc (enc *Encoder) AddStringKeyNullEmpty(key, v string) {\n\tenc.StringKeyNullEmpty(key, v)\n}\n\n// String adds a string to be encoded, must be used inside a slice or array encoding (does not encode a key)\nfunc (enc *Encoder) String(v string) {\n\tenc.grow(len(v) + 4)\n\tr := enc.getPreviousRune()\n\tif r != '[' {\n\t\tenc.writeTwoBytes(',', '\"')\n\t} else {\n\t\tenc.writeByte('\"')\n\t}\n\tenc.writeStringEscape(v)\n\tenc.writeByte('\"')\n}\n\n// StringOmitEmpty adds a string to be encoded or skips it if it is zero value.\n// Must be used inside a slice or array encoding (does not encode a key)\nfunc (enc *Encoder) StringOmitEmpty(v string) {\n\tif v == \"\" {\n\t\treturn\n\t}\n\tr := enc.getPreviousRune()\n\tif r != '[' {\n\t\tenc.writeTwoBytes(',', '\"')\n\t} else {\n\t\tenc.writeByte('\"')\n\t}\n\tenc.writeStringEscape(v)\n\tenc.writeByte('\"')\n}\n\n// StringNullEmpty adds a string to be encoded or skips it if it is zero value.\n// Must be used inside a slice or array encoding (does not encode a key)\nfunc (enc *Encoder) StringNullEmpty(v string) {\n\tr := enc.getPreviousRune()\n\tif v == \"\" {\n\t\tif r != '[' {\n\t\t\tenc.writeByte(',')\n\t\t\tenc.writeBytes(nullBytes)\n\t\t} else {\n\t\t\tenc.writeBytes(nullBytes)\n\t\t}\n\t\treturn\n\t}\n\tif r != '[' {\n\t\tenc.writeTwoBytes(',', '\"')\n\t} else {\n\t\tenc.writeByte('\"')\n\t}\n\tenc.writeStringEscape(v)\n\tenc.writeByte('\"')\n}\n\n// StringKey adds a string to be encoded, must be used inside an object as it will encode a key\nfunc (enc *Encoder) StringKey(key, v string) {\n\tif enc.hasKeys {\n\t\tif !enc.keyExists(key) {\n\t\t\treturn\n\t\t}\n\t}\n\tenc.grow(len(key) + len(v) + 5)\n\tr := enc.getPreviousRune()\n\tif r != '{' {\n\t\tenc.writeTwoBytes(',', '\"')\n\t} else {\n\t\tenc.writeByte('\"')\n\t}\n\tenc.writeStringEscape(key)\n\tenc.writeBytes(objKeyStr)\n\tenc.writeStringEscape(v)\n\tenc.writeByte('\"')\n}\n\n// StringKeyOmitEmpty adds a string to be encoded or skips it if it is zero value.\n// Must be used inside an object as it will encode a key\nfunc (enc *Encoder) StringKeyOmitEmpty(key, v string) {\n\tif enc.hasKeys {\n\t\tif !enc.keyExists(key) {\n\t\t\treturn\n\t\t}\n\t}\n\tif v == \"\" {\n\t\treturn\n\t}\n\tenc.grow(len(key) + len(v) + 5)\n\tr := enc.getPreviousRune()\n\tif r != '{' {\n\t\tenc.writeTwoBytes(',', '\"')\n\t} else {\n\t\tenc.writeByte('\"')\n\t}\n\tenc.writeStringEscape(key)\n\tenc.writeBytes(objKeyStr)\n\tenc.writeStringEscape(v)\n\tenc.writeByte('\"')\n}\n\n// StringKeyNullEmpty adds a string to be encoded or skips it if it is zero value.\n// Must be used inside an object as it will encode a key\nfunc (enc *Encoder) StringKeyNullEmpty(key, v string) {\n\tif enc.hasKeys {\n\t\tif !enc.keyExists(key) {\n\t\t\treturn\n\t\t}\n\t}\n\tenc.grow(len(key) + len(v) + 5)\n\tr := enc.getPreviousRune()\n\tif r != '{' {\n\t\tenc.writeTwoBytes(',', '\"')\n\t} else {\n\t\tenc.writeByte('\"')\n\t}\n\tenc.writeStringEscape(key)\n\tenc.writeBytes(objKey)\n\tif v == \"\" {\n\t\tenc.writeBytes(nullBytes)\n\t\treturn\n\t}\n\tenc.writeByte('\"')\n\tenc.writeStringEscape(v)\n\tenc.writeByte('\"')\n}\n"
        },
        {
          "name": "encode_string_test.go",
          "type": "blob",
          "size": 6.6064453125,
          "content": "package gojay\n\nimport (\n\t\"strings\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestEncoderStringEncodeAPI(t *testing.T) {\n\tt.Run(\"basic\", func(t *testing.T) {\n\t\tbuilder := &strings.Builder{}\n\t\tenc := NewEncoder(builder)\n\t\terr := enc.EncodeString(\"hello world\")\n\t\tassert.Nil(t, err, \"Error should be nil\")\n\t\tassert.Equal(\n\t\t\tt,\n\t\t\t`\"hello world\"`,\n\t\t\tbuilder.String(),\n\t\t\t\"Result of marshalling is different as the one expected\")\n\t})\n\tt.Run(\"utf8\", func(t *testing.T) {\n\t\tbuilder := &strings.Builder{}\n\t\tenc := NewEncoder(builder)\n\t\terr := enc.EncodeString(\"漢字𩸽\")\n\t\tassert.Nil(t, err, \"Error should be nil\")\n\t\tassert.Equal(\n\t\t\tt,\n\t\t\t`\"漢字𩸽\"`,\n\t\t\tbuilder.String(),\n\t\t\t\"Result of marshalling is different as the one expected\")\n\t})\n\tt.Run(\"utf8-multibyte\", func(t *testing.T) {\n\t\tstr := \"テュールスト マーティン ヤコブ 😁\"\n\t\tbuilder := &strings.Builder{}\n\t\tenc := NewEncoder(builder)\n\t\terr := enc.EncodeString(str)\n\t\tassert.Nil(t, err, \"Error should be nil\")\n\t\tassert.Equal(\n\t\t\tt,\n\t\t\t`\"テュールスト マーティン ヤコブ 😁\"`,\n\t\t\tbuilder.String(),\n\t\t\t\"Result of marshalling is different as the one expected\")\n\t})\n\tt.Run(\"escaped-sequence1\", func(t *testing.T) {\n\t\tstr := `テュールスト マ\\ーテ\nィン ヤコブ 😁`\n\t\tbuilder := &strings.Builder{}\n\t\tenc := NewEncoder(builder)\n\t\terr := enc.EncodeString(str)\n\t\tassert.Nil(t, err, \"Error should be nil\")\n\t\tassert.Equal(\n\t\t\tt,\n\t\t\t`\"テュールスト マ\\\\ーテ\\nィン ヤコブ 😁\"`,\n\t\t\tbuilder.String(),\n\t\t\t\"Result of marshalling is different as the one expected\")\n\t})\n\tt.Run(\"escaped-sequence2\", func(t *testing.T) {\n\t\tstr := `テュールスト マ\\ーテ\nィン ヤコブ 😁\t`\n\t\tbuilder := &strings.Builder{}\n\t\tenc := NewEncoder(builder)\n\t\terr := enc.EncodeString(str)\n\t\tassert.Nil(t, err, \"Error should be nil\")\n\t\tassert.Equal(\n\t\t\tt,\n\t\t\t`\"テュールスト マ\\\\ーテ\\nィン ヤコブ 😁\\t\"`,\n\t\t\tbuilder.String(),\n\t\t\t\"Result of marshalling is different as the one expected\")\n\t})\n\tt.Run(\"escaped-sequence3\", func(t *testing.T) {\n\t\tstr := \"hello \\r world 𝄞\"\n\t\tbuilder := &strings.Builder{}\n\t\tenc := NewEncoder(builder)\n\t\terr := enc.EncodeString(str)\n\t\tassert.Nil(t, err, \"Error should be nil\")\n\t\tassert.Equal(\n\t\t\tt,\n\t\t\t`\"hello \\r world 𝄞\"`,\n\t\t\tbuilder.String(),\n\t\t\t\"Result of marshalling is different as the one expected\")\n\t})\n\tt.Run(\"escaped-sequence3\", func(t *testing.T) {\n\t\tstr := \"hello \\b world 𝄞\"\n\t\tbuilder := &strings.Builder{}\n\t\tenc := NewEncoder(builder)\n\t\terr := enc.EncodeString(str)\n\t\tassert.Nil(t, err, \"Error should be nil\")\n\t\tassert.Equal(\n\t\t\tt,\n\t\t\t`\"hello \\b world 𝄞\"`,\n\t\t\tbuilder.String(),\n\t\t\t\"Result of marshalling is different as the one expected\")\n\t})\n\tt.Run(\"escaped-control-char\", func(t *testing.T) {\n\t\tstr := \"\\u001b\"\n\t\tbuilder := &strings.Builder{}\n\t\tenc := NewEncoder(builder)\n\t\terr := enc.EncodeString(str)\n\t\tassert.Nil(t, err, \"Error should be nil\")\n\t\tassert.Equal(\n\t\t\tt,\n\t\t\t`\"\\u001b\"`,\n\t\t\tbuilder.String(),\n\t\t\t\"Result of marshalling is different as the one expected\")\n\t})\n\tt.Run(\"escaped-sequence3\", func(t *testing.T) {\n\t\tstr := \"hello \\f world 𝄞\"\n\t\tbuilder := &strings.Builder{}\n\t\tenc := NewEncoder(builder)\n\t\terr := enc.EncodeString(str)\n\t\tassert.Nil(t, err, \"Error should be nil\")\n\t\tassert.Equal(\n\t\t\tt,\n\t\t\t\"\\\"hello \\\\f world 𝄞\\\"\",\n\t\t\tbuilder.String(),\n\t\t\t\"Result of marshalling is different as the one expected\")\n\t})\n}\n\nfunc TestEncoderStringEncodeAPIErrors(t *testing.T) {\n\tt.Run(\"pool-error\", func(t *testing.T) {\n\t\tv := \"\"\n\t\tenc := BorrowEncoder(nil)\n\t\tenc.isPooled = 1\n\t\tdefer func() {\n\t\t\terr := recover()\n\t\t\tassert.NotNil(t, err, \"err shouldnt be nil\")\n\t\t\tassert.IsType(t, InvalidUsagePooledEncoderError(\"\"), err, \"err should be of type InvalidUsagePooledEncoderError\")\n\t\t\tassert.Equal(t, \"Invalid usage of pooled encoder\", err.(InvalidUsagePooledEncoderError).Error(), \"err should be of type InvalidUsagePooledDecoderError\")\n\t\t}()\n\t\t_ = enc.EncodeString(v)\n\t\tassert.True(t, false, \"should not be called as it should have panicked\")\n\t})\n\tt.Run(\"write-error\", func(t *testing.T) {\n\t\tv := \"test\"\n\t\tw := TestWriterError(\"\")\n\t\tenc := BorrowEncoder(w)\n\t\tdefer enc.Release()\n\t\terr := enc.EncodeString(v)\n\t\tassert.NotNil(t, err, \"err should not be nil\")\n\t})\n}\n\nfunc TestEncoderStringMarshalAPI(t *testing.T) {\n\tt.Run(\"basic\", func(t *testing.T) {\n\t\tr, err := Marshal(\"string\")\n\t\tassert.Nil(t, err, \"Error should be nil\")\n\t\tassert.Equal(\n\t\t\tt,\n\t\t\t`\"string\"`,\n\t\t\tstring(r),\n\t\t\t\"Result of marshalling is different as the one expected\")\n\t})\n\tt.Run(\"utf8\", func(t *testing.T) {\n\t\tr, err := Marshal(\"漢字\")\n\t\tassert.Nil(t, err, \"Error should be nil\")\n\t\tassert.Equal(\n\t\t\tt,\n\t\t\t`\"漢字\"`,\n\t\t\tstring(r),\n\t\t\t\"Result of marshalling is different as the one expected\")\n\t})\n}\n\nfunc TestEncoderStringNullEmpty(t *testing.T) {\n\tvar testCases = []struct {\n\t\tname         string\n\t\tbaseJSON     string\n\t\texpectedJSON string\n\t}{\n\t\t{\n\t\t\tname:         \"basic 1st elem\",\n\t\t\tbaseJSON:     \"[\",\n\t\t\texpectedJSON: `[null,\"true\"`,\n\t\t},\n\t\t{\n\t\t\tname:         \"basic 2nd elem\",\n\t\t\tbaseJSON:     `[\"test\"`,\n\t\t\texpectedJSON: `[\"test\",null,\"true\"`,\n\t\t},\n\t\t{\n\t\t\tname:         \"basic 2nd elem\",\n\t\t\tbaseJSON:     `[\"test\"`,\n\t\t\texpectedJSON: `[\"test\",null,\"true\"`,\n\t\t},\n\t}\n\tfor _, testCase := range testCases {\n\t\tt.Run(\"true\", func(t *testing.T) {\n\t\t\tvar b strings.Builder\n\t\t\tvar enc = NewEncoder(&b)\n\t\t\tenc.writeString(testCase.baseJSON)\n\t\t\tenc.StringNullEmpty(\"\")\n\t\t\tenc.AddStringNullEmpty(\"true\")\n\t\t\tenc.Write()\n\t\t\tassert.Equal(t, testCase.expectedJSON, b.String())\n\t\t})\n\t}\n}\n\nfunc TestEncoderStringNullEmpty2(t *testing.T) {\n\tvar testCases = []struct {\n\t\tname         string\n\t\tbaseJSON     string\n\t\texpectedJSON string\n\t}{\n\t\t{\n\t\t\tname:         \"basic 1st elem\",\n\t\t\tbaseJSON:     \"[\",\n\t\t\texpectedJSON: `[\"test\"`,\n\t\t},\n\t}\n\tfor _, testCase := range testCases {\n\t\tt.Run(\"true\", func(t *testing.T) {\n\t\t\tvar b strings.Builder\n\t\t\tvar enc = NewEncoder(&b)\n\t\t\tenc.writeString(testCase.baseJSON)\n\t\t\tenc.StringNullEmpty(\"test\")\n\t\t\tenc.Write()\n\t\t\tassert.Equal(t, testCase.expectedJSON, b.String())\n\t\t})\n\t}\n}\n\nfunc TestEncoderStringNullKeyEmpty(t *testing.T) {\n\tvar testCases = []struct {\n\t\tname         string\n\t\tbaseJSON     string\n\t\texpectedJSON string\n\t}{\n\t\t{\n\t\t\tname:         \"basic 1st elem\",\n\t\t\tbaseJSON:     \"{\",\n\t\t\texpectedJSON: `{\"foo\":null,\"bar\":\"true\"`,\n\t\t},\n\t\t{\n\t\t\tname:         \"basic 2nd elem\",\n\t\t\tbaseJSON:     `{\"test\":\"test\"`,\n\t\t\texpectedJSON: `{\"test\":\"test\",\"foo\":null,\"bar\":\"true\"`,\n\t\t},\n\t}\n\tfor _, testCase := range testCases {\n\t\tt.Run(\"true\", func(t *testing.T) {\n\t\t\tvar b strings.Builder\n\t\t\tvar enc = NewEncoder(&b)\n\t\t\tenc.writeString(testCase.baseJSON)\n\t\t\tenc.StringKeyNullEmpty(\"foo\", \"\")\n\t\t\tenc.AddStringKeyNullEmpty(\"bar\", \"true\")\n\t\t\tenc.Write()\n\t\t\tassert.Equal(t, testCase.expectedJSON, b.String())\n\t\t})\n\t}\n}\n"
        },
        {
          "name": "encode_test.go",
          "type": "blob",
          "size": 0.9326171875,
          "content": "package gojay\n\nimport (\n\t\"errors\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\ntype TestWriterError string\n\nfunc (t TestWriterError) Write(b []byte) (int, error) {\n\treturn 0, errors.New(\"Test Error\")\n}\n\nfunc TestAppendBytes(t *testing.T) {\n\tb := []byte(``)\n\tenc := NewEncoder(nil)\n\tenc.buf = b\n\tenc.AppendBytes([]byte(`true`))\n\tassert.Equal(t, string(enc.buf), `true`, \"string(enc.buf) should equal to true\")\n}\n\nfunc TestAppendByte(t *testing.T) {\n\tb := []byte(``)\n\tenc := NewEncoder(nil)\n\tenc.buf = b\n\tenc.AppendByte(1)\n\tassert.Equal(t, enc.buf[0], uint8(0x1), \"b[0] should equal to 1\")\n}\n\nfunc TestAppendString(t *testing.T) {\n\tb := []byte(``)\n\tenc := NewEncoder(nil)\n\tenc.buf = b\n\tenc.AppendString(\"true\")\n\tassert.Equal(t, string(enc.buf), `\"true\"`, \"string(enc.buf) should equal to true\")\n}\n\nfunc TestBuf(t *testing.T) {\n\tb := []byte(`test`)\n\tenc := NewEncoder(nil)\n\tenc.buf = b\n\tassert.Equal(t, b, enc.Buf(), \"enc.Buf() should equal to b\")\n}\n"
        },
        {
          "name": "encode_time.go",
          "type": "blob",
          "size": 1.8642578125,
          "content": "package gojay\n\nimport (\n\t\"time\"\n)\n\n// EncodeTime encodes a *time.Time to JSON with the given format\nfunc (enc *Encoder) EncodeTime(t *time.Time, format string) error {\n\tif enc.isPooled == 1 {\n\t\tpanic(InvalidUsagePooledEncoderError(\"Invalid usage of pooled encoder\"))\n\t}\n\t_, _ = enc.encodeTime(t, format)\n\t_, err := enc.Write()\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}\n\n// encodeInt encodes an int to JSON\nfunc (enc *Encoder) encodeTime(t *time.Time, format string) ([]byte, error) {\n\tenc.writeByte('\"')\n\tenc.buf = t.AppendFormat(enc.buf, format)\n\tenc.writeByte('\"')\n\treturn enc.buf, nil\n}\n\n// AddTimeKey adds an *time.Time to be encoded with the given format, must be used inside an object as it will encode a key\nfunc (enc *Encoder) AddTimeKey(key string, t *time.Time, format string) {\n\tenc.TimeKey(key, t, format)\n}\n\n// TimeKey adds an *time.Time to be encoded with the given format, must be used inside an object as it will encode a key\nfunc (enc *Encoder) TimeKey(key string, t *time.Time, format string) {\n\tif enc.hasKeys {\n\t\tif !enc.keyExists(key) {\n\t\t\treturn\n\t\t}\n\t}\n\tenc.grow(10 + len(key))\n\tr := enc.getPreviousRune()\n\tif r != '{' {\n\t\tenc.writeTwoBytes(',', '\"')\n\t} else {\n\t\tenc.writeByte('\"')\n\t}\n\tenc.writeStringEscape(key)\n\tenc.writeBytes(objKeyStr)\n\tenc.buf = t.AppendFormat(enc.buf, format)\n\tenc.writeByte('\"')\n}\n\n// AddTime adds an *time.Time to be encoded with the given format, must be used inside a slice or array encoding (does not encode a key)\nfunc (enc *Encoder) AddTime(t *time.Time, format string) {\n\tenc.Time(t, format)\n}\n\n// Time adds an *time.Time to be encoded with the given format, must be used inside a slice or array encoding (does not encode a key)\nfunc (enc *Encoder) Time(t *time.Time, format string) {\n\tenc.grow(10)\n\tr := enc.getPreviousRune()\n\tif r != '[' {\n\t\tenc.writeByte(',')\n\t}\n\tenc.writeByte('\"')\n\tenc.buf = t.AppendFormat(enc.buf, format)\n\tenc.writeByte('\"')\n}\n"
        },
        {
          "name": "encode_time_test.go",
          "type": "blob",
          "size": 3.5400390625,
          "content": "package gojay\n\nimport (\n\t\"strings\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestEncodeTime(t *testing.T) {\n\ttestCases := []struct {\n\t\tname         string\n\t\ttt           string\n\t\tformat       string\n\t\texpectedJSON string\n\t\terr          bool\n\t}{\n\t\t{\n\t\t\tname:         \"basic\",\n\t\t\ttt:           \"2018-02-01\",\n\t\t\tformat:       \"2006-01-02\",\n\t\t\texpectedJSON: `\"2018-02-01\"`,\n\t\t\terr:          false,\n\t\t},\n\t}\n\n\tfor _, testCase := range testCases {\n\t\tt.Run(testCase.name, func(t *testing.T) {\n\t\t\tb := strings.Builder{}\n\t\t\ttt, err := time.Parse(testCase.format, testCase.tt)\n\t\t\tassert.Nil(t, err)\n\t\t\tenc := NewEncoder(&b)\n\t\t\terr = enc.EncodeTime(&tt, testCase.format)\n\t\t\tif !testCase.err {\n\t\t\t\tassert.Nil(t, err)\n\t\t\t\tassert.Equal(t, testCase.expectedJSON, b.String())\n\t\t\t}\n\t\t})\n\t}\n\tt.Run(\"encode-time-pool-error\", func(t *testing.T) {\n\t\tbuilder := &strings.Builder{}\n\t\tenc := NewEncoder(builder)\n\t\tenc.isPooled = 1\n\t\tdefer func() {\n\t\t\terr := recover()\n\t\t\tassert.NotNil(t, err, \"err should not be nil\")\n\t\t\tassert.IsType(t, InvalidUsagePooledEncoderError(\"\"), err, \"err should be of type InvalidUsagePooledEncoderError\")\n\t\t}()\n\t\t_ = enc.EncodeTime(&time.Time{}, \"\")\n\t\tassert.True(t, false, \"should not be called as encoder should have panicked\")\n\t})\n\tt.Run(\"write-error\", func(t *testing.T) {\n\t\tw := TestWriterError(\"\")\n\t\tenc := BorrowEncoder(w)\n\t\tdefer enc.Release()\n\t\terr := enc.EncodeTime(&time.Time{}, \"\")\n\t\tassert.NotNil(t, err, \"err should not be nil\")\n\t})\n}\n\nfunc TestAddTimeKey(t *testing.T) {\n\ttestCases := []struct {\n\t\tname         string\n\t\ttt           string\n\t\tformat       string\n\t\texpectedJSON string\n\t\tbaseJSON     string\n\t\terr          bool\n\t}{\n\t\t{\n\t\t\tname:         \"basic\",\n\t\t\ttt:           \"2018-02-01\",\n\t\t\tformat:       \"2006-01-02\",\n\t\t\tbaseJSON:     \"{\",\n\t\t\texpectedJSON: `{\"test\":\"2018-02-01\"`,\n\t\t\terr:          false,\n\t\t},\n\t\t{\n\t\t\tname:         \"basic\",\n\t\t\ttt:           \"2018-02-01\",\n\t\t\tformat:       \"2006-01-02\",\n\t\t\tbaseJSON:     `{\"\"`,\n\t\t\texpectedJSON: `{\"\",\"test\":\"2018-02-01\"`,\n\t\t\terr:          false,\n\t\t},\n\t}\n\n\tfor _, testCase := range testCases {\n\t\tt.Run(testCase.name, func(t *testing.T) {\n\t\t\tb := strings.Builder{}\n\t\t\ttt, err := time.Parse(testCase.format, testCase.tt)\n\t\t\tassert.Nil(t, err)\n\t\t\tenc := NewEncoder(&b)\n\t\t\tenc.writeString(testCase.baseJSON)\n\t\t\tenc.AddTimeKey(\"test\", &tt, testCase.format)\n\t\t\tenc.Write()\n\t\t\tif !testCase.err {\n\t\t\t\tassert.Nil(t, err)\n\t\t\t\tassert.Equal(t, testCase.expectedJSON, b.String())\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestAddTime(t *testing.T) {\n\ttestCases := []struct {\n\t\tname         string\n\t\ttt           string\n\t\tformat       string\n\t\texpectedJSON string\n\t\tbaseJSON     string\n\t\terr          bool\n\t}{\n\t\t{\n\t\t\tname:         \"basic\",\n\t\t\ttt:           \"2018-02-01\",\n\t\t\tformat:       \"2006-01-02\",\n\t\t\tbaseJSON:     \"[\",\n\t\t\texpectedJSON: `[\"2018-02-01\"`,\n\t\t\terr:          false,\n\t\t},\n\t\t{\n\t\t\tname:         \"basic\",\n\t\t\ttt:           \"2018-02-01\",\n\t\t\tformat:       \"2006-01-02\",\n\t\t\tbaseJSON:     \"[\",\n\t\t\texpectedJSON: `[\"2018-02-01\"`,\n\t\t\terr:          false,\n\t\t},\n\t\t{\n\t\t\tname:         \"basic\",\n\t\t\ttt:           \"2018-02-01\",\n\t\t\tformat:       \"2006-01-02\",\n\t\t\tbaseJSON:     `[\"\"`,\n\t\t\texpectedJSON: `[\"\",\"2018-02-01\"`,\n\t\t\terr:          false,\n\t\t},\n\t}\n\n\tfor _, testCase := range testCases {\n\t\tt.Run(testCase.name, func(t *testing.T) {\n\t\t\tb := strings.Builder{}\n\t\t\ttt, err := time.Parse(testCase.format, testCase.tt)\n\t\t\tassert.Nil(t, err)\n\t\t\tenc := NewEncoder(&b)\n\t\t\tenc.writeString(testCase.baseJSON)\n\t\t\tenc.AddTime(&tt, testCase.format)\n\t\t\tenc.Write()\n\t\t\tif !testCase.err {\n\t\t\t\tassert.Nil(t, err)\n\t\t\t\tassert.Equal(t, testCase.expectedJSON, b.String())\n\t\t\t}\n\t\t})\n\t}\n}\n"
        },
        {
          "name": "errors.go",
          "type": "blob",
          "size": 2.2490234375,
          "content": "package gojay\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n)\n\nconst invalidJSONCharErrorMsg = \"Invalid JSON, wrong char '%c' found at position %d\"\n\n// InvalidJSONError is a type representing an error returned when\n// Decoding encounters invalid JSON.\ntype InvalidJSONError string\n\nfunc (err InvalidJSONError) Error() string {\n\treturn string(err)\n}\n\nfunc (dec *Decoder) raiseInvalidJSONErr(pos int) error {\n\tvar c byte\n\tif len(dec.data) > pos {\n\t\tc = dec.data[pos]\n\t}\n\tdec.err = InvalidJSONError(\n\t\tfmt.Sprintf(\n\t\t\tinvalidJSONCharErrorMsg,\n\t\t\tc,\n\t\t\tpos,\n\t\t),\n\t)\n\treturn dec.err\n}\n\nconst invalidUnmarshalErrorMsg = \"Cannot unmarshal JSON to type '%T'\"\n\n// InvalidUnmarshalError is a type representing an error returned when\n// Decoding cannot unmarshal JSON to the receiver type for various reasons.\ntype InvalidUnmarshalError string\n\nfunc (err InvalidUnmarshalError) Error() string {\n\treturn string(err)\n}\n\nfunc (dec *Decoder) makeInvalidUnmarshalErr(v interface{}) error {\n\treturn InvalidUnmarshalError(\n\t\tfmt.Sprintf(\n\t\t\tinvalidUnmarshalErrorMsg,\n\t\t\tv,\n\t\t),\n\t)\n}\n\nconst invalidMarshalErrorMsg = \"Invalid type %T provided to Marshal\"\n\n// InvalidMarshalError is a type representing an error returned when\n// Encoding did not find the proper way to encode\ntype InvalidMarshalError string\n\nfunc (err InvalidMarshalError) Error() string {\n\treturn string(err)\n}\n\n// NoReaderError is a type representing an error returned when\n// decoding requires a reader and none was given\ntype NoReaderError string\n\nfunc (err NoReaderError) Error() string {\n\treturn string(err)\n}\n\n// InvalidUsagePooledDecoderError is a type representing an error returned\n// when decoding is called on a still pooled Decoder\ntype InvalidUsagePooledDecoderError string\n\nfunc (err InvalidUsagePooledDecoderError) Error() string {\n\treturn string(err)\n}\n\n// InvalidUsagePooledEncoderError is a type representing an error returned\n// when decoding is called on a still pooled Encoder\ntype InvalidUsagePooledEncoderError string\n\nfunc (err InvalidUsagePooledEncoderError) Error() string {\n\treturn string(err)\n}\n\n// ErrUnmarshalPtrExpected is the error returned when unmarshal expects a pointer value,\n// When using `dec.ObjectNull` or `dec.ArrayNull` for example.\nvar ErrUnmarshalPtrExpected = errors.New(\"Cannot unmarshal to given value, a pointer is expected\")\n"
        },
        {
          "name": "examples",
          "type": "tree",
          "content": null
        },
        {
          "name": "go.mod",
          "type": "blob",
          "size": 0.939453125,
          "content": "module github.com/francoispqt/gojay\n\ngo 1.12\n\nrequire (\n\tcloud.google.com/go v0.37.0 // indirect\n\tgithub.com/buger/jsonparser v0.0.0-20181115193947-bf1c66bbce23\n\tgithub.com/go-errors/errors v1.0.1\n\tgithub.com/golang/protobuf v1.3.1 // indirect\n\tgithub.com/json-iterator/go v1.1.6\n\tgithub.com/lunixbochs/vtclean v1.0.0 // indirect\n\tgithub.com/mailru/easyjson v0.0.0-20190312143242-1de009706dbe\n\tgithub.com/modern-go/concurrent v0.0.0-20180306012644-bacd9c7ef1dd // indirect\n\tgithub.com/modern-go/reflect2 v1.0.1 // indirect\n\tgithub.com/pkg/errors v0.8.1 // indirect\n\tgithub.com/stretchr/testify v1.2.2\n\tgithub.com/viant/assertly v0.4.8\n\tgithub.com/viant/toolbox v0.24.0\n\tgolang.org/x/crypto v0.0.0-20190313024323-a1f597ede03a // indirect\n\tgolang.org/x/net v0.0.0-20190313220215-9f648a60d977\n\tgolang.org/x/oauth2 v0.0.0-20190226205417-e64efc72b421 // indirect\n\tgolang.org/x/sys v0.0.0-20190316082340-a2f829d7f35f // indirect\n\tgopkg.in/yaml.v2 v2.2.2 // indirect\n)\n"
        },
        {
          "name": "go.sum",
          "type": "blob",
          "size": 18.3681640625,
          "content": "cloud.google.com/go v0.26.0/go.mod h1:aQUYkXzVsufM+DwF1aE+0xfcU+56JwCaLick0ClmMTw=\ncloud.google.com/go v0.31.0/go.mod h1:aQUYkXzVsufM+DwF1aE+0xfcU+56JwCaLick0ClmMTw=\ncloud.google.com/go v0.34.0/go.mod h1:aQUYkXzVsufM+DwF1aE+0xfcU+56JwCaLick0ClmMTw=\ncloud.google.com/go v0.37.0 h1:69FNAINiZfsEuwH3fKq8QrAAnHz+2m4XL4kVYi5BX0Q=\ncloud.google.com/go v0.37.0/go.mod h1:TS1dMSSfndXH133OKGwekG838Om/cQT0BUHV3HcBgoo=\ndmitri.shuralyov.com/app/changes v0.0.0-20180602232624-0a106ad413e3/go.mod h1:Yl+fi1br7+Rr3LqpNJf1/uxUdtRUV+Tnj0o93V2B9MU=\ndmitri.shuralyov.com/html/belt v0.0.0-20180602232347-f7d459c86be0/go.mod h1:JLBrvjyP0v+ecvNYvCpyZgu5/xkfAUhi6wJj28eUfSU=\ndmitri.shuralyov.com/service/change v0.0.0-20181023043359-a85b471d5412/go.mod h1:a1inKt/atXimZ4Mv927x+r7UpyzRUf4emIoiiSC2TN4=\ndmitri.shuralyov.com/state v0.0.0-20180228185332-28bcc343414c/go.mod h1:0PRwlb0D6DFvNNtx+9ybjezNCa8XF0xaYcETyp6rHWU=\ngit.apache.org/thrift.git v0.0.0-20180902110319-2566ecd5d999/go.mod h1:fPE2ZNJGynbRyZ4dJvy6G277gSllfV2HJqblrnkyeyg=\ngithub.com/BurntSushi/toml v0.3.1/go.mod h1:xHWCNGjB5oqiDr8zfno3MHue2Ht5sIBksp03qcyfWMU=\ngithub.com/anmitsu/go-shlex v0.0.0-20161002113705-648efa622239/go.mod h1:2FmKhYUyUczH0OGQWaF5ceTx0UBShxjsH6f8oGKYe2c=\ngithub.com/beorn7/perks v0.0.0-20180321164747-3a771d992973/go.mod h1:Dwedo/Wpr24TaqPxmxbtue+5NUziq4I4S80YR8gNf3Q=\ngithub.com/bradfitz/go-smtpd v0.0.0-20170404230938-deb6d6237625/go.mod h1:HYsPBTaaSFSlLx/70C2HPIMNZpVV8+vt/A+FMnYP11g=\ngithub.com/buger/jsonparser v0.0.0-20181115193947-bf1c66bbce23 h1:D21IyuvjDCshj1/qq+pCNd3VZOAEI9jy6Bi131YlXgI=\ngithub.com/buger/jsonparser v0.0.0-20181115193947-bf1c66bbce23/go.mod h1:bbYlZJ7hK1yFx9hf58LP0zeX7UjIGs20ufpu3evjr+s=\ngithub.com/client9/misspell v0.3.4/go.mod h1:qj6jICC3Q7zFZvVWo7KLAzC3yx5G7kyvSDkc90ppPyw=\ngithub.com/coreos/go-systemd v0.0.0-20181012123002-c6f51f82210d/go.mod h1:F5haX7vjVVG0kc13fIWeqUViNPyEJxv/OmvnBo0Yme4=\ngithub.com/davecgh/go-spew v1.1.1 h1:vj9j/u1bqnvCEfJOwUhtlOARqs3+rkHYY13jYWTU97c=\ngithub.com/davecgh/go-spew v1.1.1/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=\ngithub.com/dustin/go-humanize v1.0.0/go.mod h1:HtrtbFcZ19U5GC7JDqmcUSB87Iq5E25KnS6fMYU6eOk=\ngithub.com/flynn/go-shlex v0.0.0-20150515145356-3f9db97f8568/go.mod h1:xEzjJPgXI435gkrCt3MPfRiAkVrwSbHsst4LCFVfpJc=\ngithub.com/fsnotify/fsnotify v1.4.7/go.mod h1:jwhsz4b93w/PPRr/qN1Yymfu8t87LnFCMoQvtojpjFo=\ngithub.com/ghodss/yaml v1.0.0/go.mod h1:4dBDuWmgqj2HViK6kFavaiC9ZROes6MMH2rRYeMEF04=\ngithub.com/gliderlabs/ssh v0.1.1/go.mod h1:U7qILu1NlMHj9FlMhZLlkCdDnU1DBEAqr0aevW3Awn0=\ngithub.com/go-errors/errors v1.0.1 h1:LUHzmkK3GUKUrL/1gfBUxAHzcev3apQlezX/+O7ma6w=\ngithub.com/go-errors/errors v1.0.1/go.mod h1:f4zRHt4oKfwPJE5k8C9vpYG+aDHdBFUsgrm6/TyX73Q=\ngithub.com/gogo/protobuf v1.1.1/go.mod h1:r8qH/GZQm5c6nD/R0oafs1akxWv10x8SbQlK7atdtwQ=\ngithub.com/golang/glog v0.0.0-20160126235308-23def4e6c14b/go.mod h1:SBH7ygxi8pfUlaOkMMuAQtPIUF8ecWP5IEl/CR7VP2Q=\ngithub.com/golang/lint v0.0.0-20180702182130-06c8688daad7/go.mod h1:tluoj9z5200jBnyusfRPU2LqT6J+DAorxEvtC7LHB+E=\ngithub.com/golang/mock v1.1.1/go.mod h1:oTYuIxOrZwtPieC+H1uAHpcLFnEyAGVDL/k47Jfbm0A=\ngithub.com/golang/mock v1.2.0/go.mod h1:oTYuIxOrZwtPieC+H1uAHpcLFnEyAGVDL/k47Jfbm0A=\ngithub.com/golang/protobuf v1.2.0/go.mod h1:6lQm79b+lXiMfvg/cZm0SGofjICqVBUtrP5yJMmIC1U=\ngithub.com/golang/protobuf v1.3.1 h1:YF8+flBXS5eO826T4nzqPrxfhQThhXl0YzfuUPu4SBg=\ngithub.com/golang/protobuf v1.3.1/go.mod h1:6lQm79b+lXiMfvg/cZm0SGofjICqVBUtrP5yJMmIC1U=\ngithub.com/google/btree v0.0.0-20180813153112-4030bb1f1f0c/go.mod h1:lNA+9X1NB3Zf8V7Ke586lFgjr2dZNuvo3lPJSGZ5JPQ=\ngithub.com/google/go-cmp v0.2.0/go.mod h1:oXzfMopK8JAjlY9xF4vHSVASa0yLyX7SntLO5aqRK0M=\ngithub.com/google/go-github v17.0.0+incompatible/go.mod h1:zLgOLi98H3fifZn+44m+umXrS52loVEgC2AApnigrVQ=\ngithub.com/google/go-querystring v1.0.0/go.mod h1:odCYkC5MyYFN7vkCjXpyrEuKhc/BUO6wN/zVPAxq5ck=\ngithub.com/google/martian v2.1.0+incompatible/go.mod h1:9I4somxYTbIHy5NJKHRl3wXiIaQGbYVAs8BPL6v8lEs=\ngithub.com/google/pprof v0.0.0-20181206194817-3ea8567a2e57/go.mod h1:zfwlbNMJ+OItoe0UupaVj+oy1omPYYDuagoSzA8v9mc=\ngithub.com/googleapis/gax-go v2.0.0+incompatible/go.mod h1:SFVmujtThgffbyetf+mdk2eWhX2bMyUtNHzFKcPA9HY=\ngithub.com/googleapis/gax-go/v2 v2.0.3/go.mod h1:LLvjysVCY1JZeum8Z6l8qUty8fiNwE08qbEPm1M08qg=\ngithub.com/gopherjs/gopherjs v0.0.0-20181017120253-0766667cb4d1/go.mod h1:wJfORRmW1u3UXTncJ5qlYoELFm8eSnnEO6hX4iZ3EWY=\ngithub.com/gregjones/httpcache v0.0.0-20180305231024-9cad4c3443a7/go.mod h1:FecbI9+v66THATjSRHfNgh1IVFe/9kFxbXtjV0ctIMA=\ngithub.com/grpc-ecosystem/grpc-gateway v1.5.0/go.mod h1:RSKVYQBd5MCa4OVpNdGskqpgL2+G+NZTnrVHpWWfpdw=\ngithub.com/jellevandenhooff/dkim v0.0.0-20150330215556-f50fe3d243e1/go.mod h1:E0B/fFc00Y+Rasa88328GlI/XbtyysCtTHZS8h7IrBU=\ngithub.com/json-iterator/go v1.1.6 h1:MrUvLMLTMxbqFJ9kzlvat/rYZqZnW3u4wkLzWTaFwKs=\ngithub.com/json-iterator/go v1.1.6/go.mod h1:+SdeFBvtyEkXs7REEP0seUULqWtbJapLOCVDaaPEHmU=\ngithub.com/jstemmer/go-junit-report v0.0.0-20190106144839-af01ea7f8024/go.mod h1:6v2b51hI/fHJwM22ozAgKL4VKDeJcHhJFhtBdhmNjmU=\ngithub.com/kisielk/gotool v1.0.0/go.mod h1:XhKaO+MFFWcvkIS/tQcRk01m1F5IRFswLeQ+oQHNcck=\ngithub.com/kr/pretty v0.1.0/go.mod h1:dAy3ld7l9f0ibDNOQOHHMYYIIbhfbHSm3C4ZsoJORNo=\ngithub.com/kr/pty v1.1.1/go.mod h1:pFQYn66WHrOpPYNljwOMqo10TkYh1fy3cYio2l3bCsQ=\ngithub.com/kr/pty v1.1.3/go.mod h1:pFQYn66WHrOpPYNljwOMqo10TkYh1fy3cYio2l3bCsQ=\ngithub.com/kr/text v0.1.0/go.mod h1:4Jbv+DJW3UT/LiOwJeYQe1efqtUx/iVham/4vfdArNI=\ngithub.com/lunixbochs/vtclean v1.0.0 h1:xu2sLAri4lGiovBDQKxl5mrXyESr3gUr5m5SM5+LVb8=\ngithub.com/lunixbochs/vtclean v1.0.0/go.mod h1:pHhQNgMf3btfWnGBVipUOjRYhoOsdGqdm/+2c2E2WMI=\ngithub.com/mailru/easyjson v0.0.0-20190312143242-1de009706dbe h1:W/GaMY0y69G4cFlmsC6B9sbuo2fP8OFP1ABjt4kPz+w=\ngithub.com/mailru/easyjson v0.0.0-20190312143242-1de009706dbe/go.mod h1:C1wdFJiN94OJF2b5HbByQZoLdCWB1Yqtg26g4irojpc=\ngithub.com/matttproud/golang_protobuf_extensions v1.0.1/go.mod h1:D8He9yQNgCq6Z5Ld7szi9bcBfOoFv/3dc6xSMkL2PC0=\ngithub.com/microcosm-cc/bluemonday v1.0.1/go.mod h1:hsXNsILzKxV+sX77C5b8FSuKF00vh2OMYv+xgHpAMF4=\ngithub.com/modern-go/concurrent v0.0.0-20180306012644-bacd9c7ef1dd h1:TRLaZ9cD/w8PVh93nsPXa1VrQ6jlwL5oN8l14QlcNfg=\ngithub.com/modern-go/concurrent v0.0.0-20180306012644-bacd9c7ef1dd/go.mod h1:6dJC0mAP4ikYIbvyc7fijjWJddQyLn8Ig3JB5CqoB9Q=\ngithub.com/modern-go/reflect2 v1.0.1 h1:9f412s+6RmYXLWZSEzVVgPGK7C2PphHj5RJrvfx9AWI=\ngithub.com/modern-go/reflect2 v1.0.1/go.mod h1:bx2lNnkwVCuqBIxFjflWJWanXIb3RllmbCylyMrvgv0=\ngithub.com/neelance/astrewrite v0.0.0-20160511093645-99348263ae86/go.mod h1:kHJEU3ofeGjhHklVoIGuVj85JJwZ6kWPaJwCIxgnFmo=\ngithub.com/neelance/sourcemap v0.0.0-20151028013722-8c68805598ab/go.mod h1:Qr6/a/Q4r9LP1IltGz7tA7iOK1WonHEYhu1HRBA7ZiM=\ngithub.com/openzipkin/zipkin-go v0.1.1/go.mod h1:NtoC/o8u3JlF1lSlyPNswIbeQH9bJTmOf0Erfk+hxe8=\ngithub.com/pkg/errors v0.8.1 h1:iURUrRGxPUNPdy5/HRSm+Yj6okJ6UtLINN0Q9M4+h3I=\ngithub.com/pkg/errors v0.8.1/go.mod h1:bwawxfHBFNV+L2hUp1rHADufV3IMtnDRdf1r5NINEl0=\ngithub.com/pmezard/go-difflib v1.0.0 h1:4DBwDE0NGyQoBHbLQYPwSUPoCMWR5BEzIk/f1lZbAQM=\ngithub.com/pmezard/go-difflib v1.0.0/go.mod h1:iKH77koFhYxTK1pcRnkKkqfTogsbg7gZNVY4sRDYZ/4=\ngithub.com/prometheus/client_golang v0.8.0/go.mod h1:7SWBe2y4D6OKWSNQJUaRYU/AaXPKyh/dDVn+NZz0KFw=\ngithub.com/prometheus/client_model v0.0.0-20180712105110-5c3871d89910/go.mod h1:MbSGuTsp3dbXC40dX6PRTWyKYBIrTGTE9sqQNg2J8bo=\ngithub.com/prometheus/common v0.0.0-20180801064454-c7de2306084e/go.mod h1:daVV7qP5qjZbuso7PdcryaAu0sAZbrN9i7WWcTMWvro=\ngithub.com/prometheus/procfs v0.0.0-20180725123919-05ee40e3a273/go.mod h1:c3At6R/oaqEKCNdg8wHV1ftS6bRYblBhIjjI8uT2IGk=\ngithub.com/russross/blackfriday v1.5.2/go.mod h1:JO/DiYxRf+HjHt06OyowR9PTA263kcR/rfWxYHBV53g=\ngithub.com/sergi/go-diff v1.0.0/go.mod h1:0CfEIISq7TuYL3j771MWULgwwjU+GofnZX9QAmXWZgo=\ngithub.com/shurcooL/component v0.0.0-20170202220835-f88ec8f54cc4/go.mod h1:XhFIlyj5a1fBNx5aJTbKoIq0mNaPvOagO+HjB3EtxrY=\ngithub.com/shurcooL/events v0.0.0-20181021180414-410e4ca65f48/go.mod h1:5u70Mqkb5O5cxEA8nxTsgrgLehJeAw6Oc4Ab1c/P1HM=\ngithub.com/shurcooL/github_flavored_markdown v0.0.0-20181002035957-2122de532470/go.mod h1:2dOwnU2uBioM+SGy2aZoq1f/Sd1l9OkAeAUvjSyvgU0=\ngithub.com/shurcooL/go v0.0.0-20180423040247-9e1955d9fb6e/go.mod h1:TDJrrUr11Vxrven61rcy3hJMUqaf/CLWYhHNPmT14Lk=\ngithub.com/shurcooL/go-goon v0.0.0-20170922171312-37c2f522c041/go.mod h1:N5mDOmsrJOB+vfqUK+7DmDyjhSLIIBnXo9lvZJj3MWQ=\ngithub.com/shurcooL/gofontwoff v0.0.0-20180329035133-29b52fc0a18d/go.mod h1:05UtEgK5zq39gLST6uB0cf3NEHjETfB4Fgr3Gx5R9Vw=\ngithub.com/shurcooL/gopherjslib v0.0.0-20160914041154-feb6d3990c2c/go.mod h1:8d3azKNyqcHP1GaQE/c6dDgjkgSx2BZ4IoEi4F1reUI=\ngithub.com/shurcooL/highlight_diff v0.0.0-20170515013008-09bb4053de1b/go.mod h1:ZpfEhSmds4ytuByIcDnOLkTHGUI6KNqRNPDLHDk+mUU=\ngithub.com/shurcooL/highlight_go v0.0.0-20181028180052-98c3abbbae20/go.mod h1:UDKB5a1T23gOMUJrI+uSuH0VRDStOiUVSjBTRDVBVag=\ngithub.com/shurcooL/home v0.0.0-20181020052607-80b7ffcb30f9/go.mod h1:+rgNQw2P9ARFAs37qieuu7ohDNQ3gds9msbT2yn85sg=\ngithub.com/shurcooL/htmlg v0.0.0-20170918183704-d01228ac9e50/go.mod h1:zPn1wHpTIePGnXSHpsVPWEktKXHr6+SS6x/IKRb7cpw=\ngithub.com/shurcooL/httperror v0.0.0-20170206035902-86b7830d14cc/go.mod h1:aYMfkZ6DWSJPJ6c4Wwz3QtW22G7mf/PEgaB9k/ik5+Y=\ngithub.com/shurcooL/httpfs v0.0.0-20171119174359-809beceb2371/go.mod h1:ZY1cvUeJuFPAdZ/B6v7RHavJWZn2YPVFQ1OSXhCGOkg=\ngithub.com/shurcooL/httpgzip v0.0.0-20180522190206-b1c53ac65af9/go.mod h1:919LwcH0M7/W4fcZ0/jy0qGght1GIhqyS/EgWGH2j5Q=\ngithub.com/shurcooL/issues v0.0.0-20181008053335-6292fdc1e191/go.mod h1:e2qWDig5bLteJ4fwvDAc2NHzqFEthkqn7aOZAOpj+PQ=\ngithub.com/shurcooL/issuesapp v0.0.0-20180602232740-048589ce2241/go.mod h1:NPpHK2TI7iSaM0buivtFUc9offApnI0Alt/K8hcHy0I=\ngithub.com/shurcooL/notifications v0.0.0-20181007000457-627ab5aea122/go.mod h1:b5uSkrEVM1jQUspwbixRBhaIjIzL2xazXp6kntxYle0=\ngithub.com/shurcooL/octicon v0.0.0-20181028054416-fa4f57f9efb2/go.mod h1:eWdoE5JD4R5UVWDucdOPg1g2fqQRq78IQa9zlOV1vpQ=\ngithub.com/shurcooL/reactions v0.0.0-20181006231557-f2e0b4ca5b82/go.mod h1:TCR1lToEk4d2s07G3XGfz2QrgHXg4RJBvjrOozvoWfk=\ngithub.com/shurcooL/sanitized_anchor_name v0.0.0-20170918181015-86672fcb3f95/go.mod h1:1NzhyTcUVG4SuEtjjoZeVRXNmyL/1OwPU0+IJeTBvfc=\ngithub.com/shurcooL/users v0.0.0-20180125191416-49c67e49c537/go.mod h1:QJTqeLYEDaXHZDBsXlPCDqdhQuJkuw4NOtaxYe3xii4=\ngithub.com/shurcooL/webdavfs v0.0.0-20170829043945-18c3829fa133/go.mod h1:hKmq5kWdCj2z2KEozexVbfEZIWiTjhE0+UjmZgPqehw=\ngithub.com/sourcegraph/annotate v0.0.0-20160123013949-f4cad6c6324d/go.mod h1:UdhH50NIW0fCiwBSr0co2m7BnFLdv4fQTgdqdJTHFeE=\ngithub.com/sourcegraph/syntaxhighlight v0.0.0-20170531221838-bd320f5d308e/go.mod h1:HuIsMU8RRBOtsCgI77wP899iHVBQpCmg4ErYMZB+2IA=\ngithub.com/stretchr/testify v1.2.2 h1:bSDNvY7ZPG5RlJ8otE/7V6gMiyenm9RtJ7IUVIAoJ1w=\ngithub.com/stretchr/testify v1.2.2/go.mod h1:a8OnRcib4nhh0OaRAV+Yts87kKdq0PP7pXfy6kDkUVs=\ngithub.com/tarm/serial v0.0.0-20180830185346-98f6abe2eb07/go.mod h1:kDXzergiv9cbyO7IOYJZWg1U88JhDg3PB6klq9Hg2pA=\ngithub.com/viant/assertly v0.4.8 h1:5x1GzBaRteIwTr5RAGFVG14uNeRFxVNbXPWrK2qAgpc=\ngithub.com/viant/assertly v0.4.8/go.mod h1:aGifi++jvCrUaklKEKT0BU95igDNaqkvz+49uaYMPRU=\ngithub.com/viant/toolbox v0.24.0 h1:6TteTDQ68CjgcCe8wH3D3ZhUQQOJXMTbj/D9rkk2a1k=\ngithub.com/viant/toolbox v0.24.0/go.mod h1:OxMCG57V0PXuIP2HNQrtJf2CjqdmbrOx5EkMILuUhzM=\ngo.opencensus.io v0.18.0/go.mod h1:vKdFvxhtzZ9onBp9VKHK8z/sRpBMnKAsufL7wlDrCOA=\ngo4.org v0.0.0-20180809161055-417644f6feb5/go.mod h1:MkTOUMDaeVYJUOUsaDXIhWPZYa1yOyC1qaOBpL57BhE=\ngolang.org/x/build v0.0.0-20190111050920-041ab4dc3f9d/go.mod h1:OWs+y06UdEOHN4y+MfF/py+xQ/tYqIWW03b70/CG9Rw=\ngolang.org/x/crypto v0.0.0-20181030102418-4d3f4d9ffa16/go.mod h1:6SG95UA2DQfeDnfUPMdvaQW0Q7yPrPDi9nlGo2tz2b4=\ngolang.org/x/crypto v0.0.0-20190308221718-c2843e01d9a2/go.mod h1:djNgcEr1/C05ACkg1iLfiJU5Ep61QUkGW8qpdssI0+w=\ngolang.org/x/crypto v0.0.0-20190313024323-a1f597ede03a h1:YX8ljsm6wXlHZO+aRz9Exqr0evNhKRNe5K/gi+zKh4U=\ngolang.org/x/crypto v0.0.0-20190313024323-a1f597ede03a/go.mod h1:djNgcEr1/C05ACkg1iLfiJU5Ep61QUkGW8qpdssI0+w=\ngolang.org/x/exp v0.0.0-20190121172915-509febef88a4/go.mod h1:CJ0aWSM057203Lf6IL+f9T1iT9GByDxfZKAQTCR3kQA=\ngolang.org/x/lint v0.0.0-20180702182130-06c8688daad7/go.mod h1:UVdnD1Gm6xHRNCYTkRU2/jEulfH38KcIWyp/GAMgvoE=\ngolang.org/x/lint v0.0.0-20181026193005-c67002cb31c3/go.mod h1:UVdnD1Gm6xHRNCYTkRU2/jEulfH38KcIWyp/GAMgvoE=\ngolang.org/x/lint v0.0.0-20190227174305-5b3e6a55c961/go.mod h1:wehouNa3lNwaWXcvxsM5YxQ5yQlVC4a0KAMCusXpPoU=\ngolang.org/x/net v0.0.0-20180724234803-3673e40ba225/go.mod h1:mL1N/T3taQHkDXs73rZJwtUhF3w3ftmwwsq0BUmARs4=\ngolang.org/x/net v0.0.0-20180826012351-8a410e7b638d/go.mod h1:mL1N/T3taQHkDXs73rZJwtUhF3w3ftmwwsq0BUmARs4=\ngolang.org/x/net v0.0.0-20180906233101-161cd47e91fd/go.mod h1:mL1N/T3taQHkDXs73rZJwtUhF3w3ftmwwsq0BUmARs4=\ngolang.org/x/net v0.0.0-20181029044818-c44066c5c816/go.mod h1:mL1N/T3taQHkDXs73rZJwtUhF3w3ftmwwsq0BUmARs4=\ngolang.org/x/net v0.0.0-20181106065722-10aee1819953/go.mod h1:mL1N/T3taQHkDXs73rZJwtUhF3w3ftmwwsq0BUmARs4=\ngolang.org/x/net v0.0.0-20190108225652-1e06a53dbb7e/go.mod h1:mL1N/T3taQHkDXs73rZJwtUhF3w3ftmwwsq0BUmARs4=\ngolang.org/x/net v0.0.0-20190213061140-3a22650c66bd/go.mod h1:mL1N/T3taQHkDXs73rZJwtUhF3w3ftmwwsq0BUmARs4=\ngolang.org/x/net v0.0.0-20190313220215-9f648a60d977 h1:actzWV6iWn3GLqN8dZjzsB+CLt+gaV2+wsxroxiQI8I=\ngolang.org/x/net v0.0.0-20190313220215-9f648a60d977/go.mod h1:t9HGtf8HONx5eT2rtn7q6eTqICYqUVnKs3thJo3Qplg=\ngolang.org/x/oauth2 v0.0.0-20180821212333-d2e6202438be/go.mod h1:N/0e6XlmueqKjAGxoOufVs8QHGRruUQn6yWY3a++T0U=\ngolang.org/x/oauth2 v0.0.0-20181017192945-9dcd33a902f4/go.mod h1:N/0e6XlmueqKjAGxoOufVs8QHGRruUQn6yWY3a++T0U=\ngolang.org/x/oauth2 v0.0.0-20181203162652-d668ce993890/go.mod h1:N/0e6XlmueqKjAGxoOufVs8QHGRruUQn6yWY3a++T0U=\ngolang.org/x/oauth2 v0.0.0-20190226205417-e64efc72b421 h1:Wo7BWFiOk0QRFMLYMqJGFMd9CgUAcGx7V+qEg/h5IBI=\ngolang.org/x/oauth2 v0.0.0-20190226205417-e64efc72b421/go.mod h1:gOpvHmFTYa4IltrdGE7lF6nIHvwfUNPOp7c8zoXwtLw=\ngolang.org/x/perf v0.0.0-20180704124530-6e6d33e29852/go.mod h1:JLpeXjPJfIyPr5TlbXLkXWLhP8nz10XfvxElABhCtcw=\ngolang.org/x/sync v0.0.0-20180314180146-1d60e4601c6f/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=\ngolang.org/x/sync v0.0.0-20181108010431-42b317875d0f/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=\ngolang.org/x/sync v0.0.0-20181221193216-37e7f081c4d4/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=\ngolang.org/x/sync v0.0.0-20190227155943-e225da77a7e6/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=\ngolang.org/x/sys v0.0.0-20180830151530-49385e6e1522/go.mod h1:STP8DvDyc/dI5b8T5hshtkjS+E42TnysNCUPdjciGhY=\ngolang.org/x/sys v0.0.0-20180909124046-d0be0721c37e/go.mod h1:STP8DvDyc/dI5b8T5hshtkjS+E42TnysNCUPdjciGhY=\ngolang.org/x/sys v0.0.0-20181029174526-d69651ed3497/go.mod h1:STP8DvDyc/dI5b8T5hshtkjS+E42TnysNCUPdjciGhY=\ngolang.org/x/sys v0.0.0-20190215142949-d0b11bdaac8a/go.mod h1:STP8DvDyc/dI5b8T5hshtkjS+E42TnysNCUPdjciGhY=\ngolang.org/x/sys v0.0.0-20190316082340-a2f829d7f35f h1:yCrMx/EeIue0+Qca57bWZS7VX6ymEoypmhWyPhz0NHM=\ngolang.org/x/sys v0.0.0-20190316082340-a2f829d7f35f/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/text v0.3.0/go.mod h1:NqM8EUOU14njkJ3fqMW+pc6Ldnwhi/IjpwHt7yyuwOQ=\ngolang.org/x/text v0.3.1-0.20180807135948-17ff2d5776d2/go.mod h1:NqM8EUOU14njkJ3fqMW+pc6Ldnwhi/IjpwHt7yyuwOQ=\ngolang.org/x/time v0.0.0-20180412165947-fbb02b2291d2/go.mod h1:tRJNPiyCQ0inRvYxbN9jk5I+vvW/OXSQhTDSoE431IQ=\ngolang.org/x/time v0.0.0-20181108054448-85acf8d2951c/go.mod h1:tRJNPiyCQ0inRvYxbN9jk5I+vvW/OXSQhTDSoE431IQ=\ngolang.org/x/tools v0.0.0-20180828015842-6cd1fcedba52/go.mod h1:n7NCudcB/nEzxVGmLbDWY5pfWTLqBcC2KZ6jyYvM4mQ=\ngolang.org/x/tools v0.0.0-20181030000716-a0a13e073c7b/go.mod h1:n7NCudcB/nEzxVGmLbDWY5pfWTLqBcC2KZ6jyYvM4mQ=\ngolang.org/x/tools v0.0.0-20190114222345-bf090417da8b/go.mod h1:n7NCudcB/nEzxVGmLbDWY5pfWTLqBcC2KZ6jyYvM4mQ=\ngolang.org/x/tools v0.0.0-20190226205152-f727befe758c/go.mod h1:9Yl7xja0Znq3iFh3HoIrodX9oNMXvdceNzlUR8zjMvY=\ngoogle.golang.org/api v0.0.0-20180910000450-7ca32eb868bf/go.mod h1:4mhQ8q/RsB7i+udVvVy5NUi08OU8ZlA0gRVgrF7VFY0=\ngoogle.golang.org/api v0.0.0-20181030000543-1d582fd0359e/go.mod h1:4mhQ8q/RsB7i+udVvVy5NUi08OU8ZlA0gRVgrF7VFY0=\ngoogle.golang.org/api v0.1.0/go.mod h1:UGEZY7KEX120AnNLIHFMKIo4obdJhkp2tPbaPlQx13Y=\ngoogle.golang.org/appengine v1.1.0/go.mod h1:EbEs0AVv82hx2wNQdGPgUI5lhzA/G0D9YwlJXL52JkM=\ngoogle.golang.org/appengine v1.2.0/go.mod h1:xpcJRLb0r/rnEns0DIKYYv+WjYCduHsrkT7/EB5XEv4=\ngoogle.golang.org/appengine v1.3.0/go.mod h1:xpcJRLb0r/rnEns0DIKYYv+WjYCduHsrkT7/EB5XEv4=\ngoogle.golang.org/appengine v1.4.0 h1:/wp5JvzpHIxhs/dumFmF7BXTf3Z+dd4uXta4kVyO508=\ngoogle.golang.org/appengine v1.4.0/go.mod h1:xpcJRLb0r/rnEns0DIKYYv+WjYCduHsrkT7/EB5XEv4=\ngoogle.golang.org/genproto v0.0.0-20180817151627-c66870c02cf8/go.mod h1:JiN7NxoALGmiZfu7CAH4rXhgtRTLTxftemlI0sWmxmc=\ngoogle.golang.org/genproto v0.0.0-20180831171423-11092d34479b/go.mod h1:JiN7NxoALGmiZfu7CAH4rXhgtRTLTxftemlI0sWmxmc=\ngoogle.golang.org/genproto v0.0.0-20181029155118-b69ba1387ce2/go.mod h1:JiN7NxoALGmiZfu7CAH4rXhgtRTLTxftemlI0sWmxmc=\ngoogle.golang.org/genproto v0.0.0-20181202183823-bd91e49a0898/go.mod h1:7Ep/1NZk928CDR8SjdVbjWNpdIf6nzjE3BTgJDr2Atg=\ngoogle.golang.org/genproto v0.0.0-20190306203927-b5d61aea6440/go.mod h1:VzzqZJRnGkLBvHegQrXjBqPurQTc5/KpmUdxsrq26oE=\ngoogle.golang.org/grpc v1.14.0/go.mod h1:yo6s7OP7yaDglbqo1J04qKzAhqBH6lvTonzMVmEdcZw=\ngoogle.golang.org/grpc v1.16.0/go.mod h1:0JHn/cJsOMiMfNA9+DeHDlAU7KAAB5GDlYFpa9MZMio=\ngoogle.golang.org/grpc v1.17.0/go.mod h1:6QZJwpn2B+Zp71q/5VxRsJ6NXXVCE5NRUHRo+f3cWCs=\ngoogle.golang.org/grpc v1.19.0/go.mod h1:mqu4LbDTu4XGKhr4mRzUsmM4RtVoemTSY81AxZiDr8c=\ngopkg.in/check.v1 v0.0.0-20161208181325-20d25e280405 h1:yhCVgyC4o1eVCa2tZl7eS0r+SDo693bJlVdllGtEeKM=\ngopkg.in/check.v1 v0.0.0-20161208181325-20d25e280405/go.mod h1:Co6ibVJAznAaIkqp8huTwlJQCZ016jof/cbN4VW5Yz0=\ngopkg.in/inf.v0 v0.9.1/go.mod h1:cWUDdTG/fYaXco+Dcufb5Vnc6Gp2YChqWtbxRZE0mXw=\ngopkg.in/yaml.v2 v2.2.1/go.mod h1:hI93XBmqTisBFMUTm0b8Fm+jr3Dg1NNxqwp+5A1VGuI=\ngopkg.in/yaml.v2 v2.2.2 h1:ZCJp+EgiOT7lHqUV2J862kp8Qj64Jo6az82+3Td9dZw=\ngopkg.in/yaml.v2 v2.2.2/go.mod h1:hI93XBmqTisBFMUTm0b8Fm+jr3Dg1NNxqwp+5A1VGuI=\ngrpc.go4.org v0.0.0-20170609214715-11d0a25b4919/go.mod h1:77eQGdRu53HpSqPFJFmuJdjuHRquDANNeA4x7B8WQ9o=\nhonnef.co/go/tools v0.0.0-20180728063816-88497007e858/go.mod h1:rf3lG4BRIbNafJWhAfAdb/ePZxsR/4RtNHQocxwk9r4=\nhonnef.co/go/tools v0.0.0-20190102054323-c2f93a96b099/go.mod h1:rf3lG4BRIbNafJWhAfAdb/ePZxsR/4RtNHQocxwk9r4=\nhonnef.co/go/tools v0.0.0-20190106161140-3f1c8253044a/go.mod h1:rf3lG4BRIbNafJWhAfAdb/ePZxsR/4RtNHQocxwk9r4=\nsourcegraph.com/sourcegraph/go-diff v0.5.0/go.mod h1:kuch7UrkMzY0X+p9CRK03kfuPQ2zzQcaEFbx8wA8rck=\nsourcegraph.com/sqs/pbtypes v0.0.0-20180604144634-d3ebe8f20ae4/go.mod h1:ketZ/q3QxT9HOBeFhu6RdvsftgpsbFHBF5Cas6cDKZ0=\n"
        },
        {
          "name": "gojay.go",
          "type": "blob",
          "size": 0.537109375,
          "content": "// Package gojay implements encoding and decoding of JSON as defined in RFC 7159.\n// The mapping between JSON and Go values is described\n// in the documentation for the Marshal and Unmarshal functions.\n//\n// It aims at performance and usability by relying on simple interfaces\n// to decode and encode structures, slices, arrays and even channels.\n//\n// On top of the simple interfaces to implement, gojay provides lots of helpers to decode and encode\n// multiple of different types natively such as bit.Int, sql.NullString or time.Time\npackage gojay\n"
        },
        {
          "name": "gojay.png",
          "type": "blob",
          "size": 43.1279296875,
          "content": null
        },
        {
          "name": "gojay",
          "type": "tree",
          "content": null
        },
        {
          "name": "gojay_example_test.go",
          "type": "blob",
          "size": 1.171875,
          "content": "package gojay_test\n\nimport (\n\t\"fmt\"\n\t\"log\"\n\t\"os\"\n\t\"strings\"\n\n\t\"github.com/francoispqt/gojay\"\n)\n\ntype User struct {\n\tID    int\n\tName  string\n\tEmail string\n}\n\nfunc (u *User) UnmarshalJSONObject(dec *gojay.Decoder, k string) error {\n\tswitch k {\n\tcase \"id\":\n\t\treturn dec.Int(&u.ID)\n\tcase \"name\":\n\t\treturn dec.String(&u.Name)\n\tcase \"email\":\n\t\treturn dec.String(&u.Email)\n\t}\n\treturn nil\n}\n\nfunc (u *User) NKeys() int {\n\treturn 3\n}\n\nfunc (u *User) MarshalJSONObject(enc *gojay.Encoder) {\n\tenc.IntKey(\"id\", u.ID)\n\tenc.StringKey(\"name\", u.Name)\n\tenc.StringKey(\"email\", u.Email)\n}\n\nfunc (u *User) IsNil() bool {\n\treturn u == nil\n}\n\nfunc Example_decodeEncode() {\n\treader := strings.NewReader(`{\n\t\t\"id\": 1,\n\t\t\"name\": \"John Doe\",\n\t\t\"email\": \"john.doe@email.com\"\n\t}`)\n\tdec := gojay.BorrowDecoder(reader)\n\tdefer dec.Release()\n\n\tu := &User{}\n\terr := dec.Decode(u)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\tenc := gojay.BorrowEncoder(os.Stdout)\n\terr = enc.Encode(u)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\tfmt.Printf(\"\\nUser ID: %d\\nName: %s\\nEmail: %s\\n\",\n\t\tu.ID, u.Name, u.Email)\n\n\t// Output:\n\t// {\"id\":1,\"name\":\"John Doe\",\"email\":\"john.doe@email.com\"}\n\t// User ID: 1\n\t// Name: John Doe\n\t// Email: john.doe@email.com\n}\n"
        },
        {
          "name": "gojay_test.go",
          "type": "blob",
          "size": 7.8671875,
          "content": "package gojay\n\ntype testObject struct {\n\ttestStr         string\n\ttestStrNull     *string\n\ttestInt         int\n\ttestIntNull     *int\n\ttestInt64       int64\n\ttestInt64Null   *int64\n\ttestInt32       int32\n\ttestInt32Null   *int32\n\ttestInt16       int16\n\ttestInt16Null   *int16\n\ttestInt8        int8\n\ttestInt8Null    *int8\n\ttestUint64      uint64\n\ttestUint64Null  *uint64\n\ttestUint32      uint32\n\ttestUint32Null  *uint32\n\ttestUint16      uint16\n\ttestUint16Null  *uint16\n\ttestUint8       uint8\n\ttestUint8Null   *uint8\n\ttestFloat64     float64\n\ttestFloat64Null *float64\n\ttestFloat32     float32\n\ttestFloat32Null *float32\n\ttestBool        bool\n\ttestBoolNull    *bool\n\ttestSubObject   *testObject\n\ttestSubArray    testSliceInts\n\ttestInterface   interface{}\n}\n\n// make sure it implements interfaces\nvar _ MarshalerJSONObject = &testObject{}\nvar _ UnmarshalerJSONObject = &testObject{}\n\nfunc (t *testObject) IsNil() bool {\n\treturn t == nil\n}\n\nfunc (t *testObject) MarshalJSONObject(enc *Encoder) {\n\tenc.AddStringKey(\"testStr\", t.testStr)\n\tenc.AddIntKey(\"testInt\", t.testInt)\n\tenc.AddIntKey(\"testInt64\", int(t.testInt64))\n\tenc.AddIntKey(\"testInt32\", int(t.testInt32))\n\tenc.AddIntKey(\"testInt16\", int(t.testInt16))\n\tenc.AddIntKey(\"testInt8\", int(t.testInt8))\n\tenc.AddIntKey(\"testUint64\", int(t.testUint64))\n\tenc.AddIntKey(\"testUint32\", int(t.testUint32))\n\tenc.AddIntKey(\"testUint16\", int(t.testUint16))\n\tenc.AddIntKey(\"testUint8\", int(t.testUint8))\n\tenc.AddFloatKey(\"testFloat64\", t.testFloat64)\n\tenc.AddFloat32Key(\"testFloat32\", t.testFloat32)\n\tenc.AddBoolKey(\"testBool\", t.testBool)\n}\n\nfunc (t *testObject) UnmarshalJSONObject(dec *Decoder, k string) error {\n\tswitch k {\n\tcase \"testStr\":\n\t\treturn dec.AddString(&t.testStr)\n\tcase \"testStrNull\":\n\t\treturn dec.AddStringNull(&t.testStrNull)\n\tcase \"testInt\":\n\t\treturn dec.AddInt(&t.testInt)\n\tcase \"testIntNull\":\n\t\treturn dec.AddIntNull(&t.testIntNull)\n\tcase \"testInt64\":\n\t\treturn dec.AddInt64(&t.testInt64)\n\tcase \"testInt64Null\":\n\t\treturn dec.AddInt64Null(&t.testInt64Null)\n\tcase \"testInt32\":\n\t\treturn dec.AddInt32(&t.testInt32)\n\tcase \"testInt32Null\":\n\t\treturn dec.AddInt32Null(&t.testInt32Null)\n\tcase \"testInt16\":\n\t\treturn dec.AddInt16(&t.testInt16)\n\tcase \"testInt16Null\":\n\t\treturn dec.AddInt16Null(&t.testInt16Null)\n\tcase \"testInt8\":\n\t\treturn dec.AddInt8(&t.testInt8)\n\tcase \"testInt8Null\":\n\t\treturn dec.AddInt8Null(&t.testInt8Null)\n\tcase \"testUint64\":\n\t\treturn dec.AddUint64(&t.testUint64)\n\tcase \"testUint64Null\":\n\t\treturn dec.AddUint64Null(&t.testUint64Null)\n\tcase \"testUint32\":\n\t\treturn dec.AddUint32(&t.testUint32)\n\tcase \"testUint32Null\":\n\t\treturn dec.AddUint32Null(&t.testUint32Null)\n\tcase \"testUint16\":\n\t\treturn dec.AddUint16(&t.testUint16)\n\tcase \"testUint16Null\":\n\t\treturn dec.AddUint16Null(&t.testUint16Null)\n\tcase \"testUint8\":\n\t\treturn dec.AddUint8(&t.testUint8)\n\tcase \"testUint8Null\":\n\t\treturn dec.AddUint8Null(&t.testUint8Null)\n\tcase \"testFloat64\":\n\t\treturn dec.AddFloat(&t.testFloat64)\n\tcase \"testFloat64Null\":\n\t\treturn dec.AddFloatNull(&t.testFloat64Null)\n\tcase \"testFloat32\":\n\t\treturn dec.AddFloat32(&t.testFloat32)\n\tcase \"testFloat32Null\":\n\t\treturn dec.AddFloat32Null(&t.testFloat32Null)\n\tcase \"testBool\":\n\t\treturn dec.AddBool(&t.testBool)\n\tcase \"testBoolNull\":\n\t\treturn dec.AddBoolNull(&t.testBoolNull)\n\tcase \"testInterface\":\n\t\treturn dec.AddInterface(&t.testInterface)\n\t}\n\treturn nil\n}\n\nfunc (t *testObject) NKeys() int {\n\treturn 29\n}\n\ntype testObject0Keys struct {\n\ttestStr       string\n\ttestInt       int\n\ttestInt64     int64\n\ttestInt32     int32\n\ttestInt16     int16\n\ttestInt8      int8\n\ttestUint64    uint64\n\ttestUint32    uint32\n\ttestUint16    uint16\n\ttestUint8     uint8\n\ttestFloat64   float64\n\ttestFloat32   float32\n\ttestBool      bool\n\ttestSubObject *testObject0Keys\n\ttestSubArray  testSliceInts\n\ttestInterface interface{}\n}\n\n// make sure it implements interfaces\nvar _ MarshalerJSONObject = &testObject0Keys{}\nvar _ UnmarshalerJSONObject = &testObject0Keys{}\n\nfunc (t *testObject0Keys) IsNil() bool {\n\treturn t == nil\n}\n\nfunc (t *testObject0Keys) MarshalJSONObject(enc *Encoder) {\n\tenc.AddStringKey(\"testStr\", t.testStr)\n\tenc.AddIntKey(\"testInt\", t.testInt)\n\tenc.AddIntKey(\"testInt64\", int(t.testInt64))\n\tenc.AddIntKey(\"testInt32\", int(t.testInt32))\n\tenc.AddIntKey(\"testInt16\", int(t.testInt16))\n\tenc.AddIntKey(\"testInt8\", int(t.testInt8))\n\tenc.AddIntKey(\"testUint64\", int(t.testUint64))\n\tenc.AddIntKey(\"testUint32\", int(t.testUint32))\n\tenc.AddIntKey(\"testUint16\", int(t.testUint16))\n\tenc.AddIntKey(\"testUint8\", int(t.testUint8))\n\tenc.AddFloatKey(\"testFloat64\", t.testFloat64)\n\tenc.AddFloat32Key(\"testFloat32\", t.testFloat32)\n\tenc.AddBoolKey(\"testBool\", t.testBool)\n\tenc.AddInterfaceKey(\"testInterface\", t.testInterface)\n}\n\nfunc (t *testObject0Keys) UnmarshalJSONObject(dec *Decoder, k string) error {\n\tswitch k {\n\tcase \"testStr\":\n\t\treturn dec.AddString(&t.testStr)\n\tcase \"testInt\":\n\t\treturn dec.AddInt(&t.testInt)\n\tcase \"testInt64\":\n\t\treturn dec.AddInt64(&t.testInt64)\n\tcase \"testInt32\":\n\t\treturn dec.AddInt32(&t.testInt32)\n\tcase \"testInt16\":\n\t\treturn dec.AddInt16(&t.testInt16)\n\tcase \"testInt8\":\n\t\treturn dec.AddInt8(&t.testInt8)\n\tcase \"testUint64\":\n\t\treturn dec.AddUint64(&t.testUint64)\n\tcase \"testUint32\":\n\t\treturn dec.AddUint32(&t.testUint32)\n\tcase \"testUint16\":\n\t\treturn dec.AddUint16(&t.testUint16)\n\tcase \"testUint8\":\n\t\treturn dec.AddUint8(&t.testUint8)\n\tcase \"testFloat64\":\n\t\treturn dec.AddFloat(&t.testFloat64)\n\tcase \"testFloat32\":\n\t\treturn dec.AddFloat32(&t.testFloat32)\n\tcase \"testBool\":\n\t\treturn dec.AddBool(&t.testBool)\n\tcase \"testInterface\":\n\t\treturn dec.AddInterface(&t.testInterface)\n\t}\n\treturn nil\n}\n\nfunc (t *testObject0Keys) NKeys() int {\n\treturn 0\n}\n\ntype testObjectComplex struct {\n\ttestSubObject    *testObject\n\ttestSubSliceInts *testSliceInts\n\ttestStr          string\n\ttestSubObject2   *testObjectComplex\n}\n\nfunc (t *testObjectComplex) IsNil() bool {\n\treturn t == nil\n}\n\nfunc (t *testObjectComplex) MarshalJSONObject(enc *Encoder) {\n\tenc.AddObjectKey(\"testSubObject\", t.testSubObject)\n\tenc.AddStringKey(\"testStr\", t.testStr)\n\tenc.AddObjectKey(\"testStr\", t.testSubObject2)\n}\n\nfunc (t *testObjectComplex) UnmarshalJSONObject(dec *Decoder, k string) error {\n\tswitch k {\n\tcase \"testSubObject\":\n\t\treturn dec.AddObject(t.testSubObject)\n\tcase \"testSubSliceInts\":\n\t\treturn dec.AddArray(t.testSubSliceInts)\n\tcase \"testStr\":\n\t\treturn dec.AddString(&t.testStr)\n\tcase \"testSubObject2\":\n\t\treturn dec.AddObject(t.testSubObject2)\n\t}\n\treturn nil\n}\n\nfunc (t *testObjectComplex) NKeys() int {\n\treturn 4\n}\n\n// make sure it implements interfaces\nvar _ MarshalerJSONObject = &testObjectComplex{}\nvar _ UnmarshalerJSONObject = &testObjectComplex{}\n\ntype TestObj struct {\n\ttest        int\n\ttest2       int\n\ttest3       string\n\ttest4       string\n\ttest5       float64\n\ttestArr     testSliceObjects\n\ttestSubObj  *TestSubObj\n\ttestSubObj2 *TestSubObj\n}\n\ntype TestSubObj struct {\n\ttest3          int\n\ttest4          int\n\ttest5          string\n\ttestSubSubObj  *TestSubObj\n\ttestSubSubObj2 *TestSubObj\n}\n\nfunc (t *TestSubObj) UnmarshalJSONObject(dec *Decoder, key string) error {\n\tswitch key {\n\tcase \"test\":\n\t\treturn dec.AddInt(&t.test3)\n\tcase \"test2\":\n\t\treturn dec.AddInt(&t.test4)\n\tcase \"test3\":\n\t\treturn dec.AddString(&t.test5)\n\tcase \"testSubSubObj\":\n\t\tt.testSubSubObj = &TestSubObj{}\n\t\treturn dec.AddObject(t.testSubSubObj)\n\tcase \"testSubSubObj2\":\n\t\tt.testSubSubObj2 = &TestSubObj{}\n\t\treturn dec.AddObject(t.testSubSubObj2)\n\t}\n\treturn nil\n}\n\nfunc (t *TestSubObj) NKeys() int {\n\treturn 0\n}\n\nfunc (t *TestObj) UnmarshalJSONObject(dec *Decoder, key string) error {\n\tswitch key {\n\tcase \"test\":\n\t\treturn dec.AddInt(&t.test)\n\tcase \"test2\":\n\t\treturn dec.AddInt(&t.test2)\n\tcase \"test3\":\n\t\treturn dec.AddString(&t.test3)\n\tcase \"test4\":\n\t\treturn dec.AddString(&t.test4)\n\tcase \"test5\":\n\t\treturn dec.AddFloat(&t.test5)\n\tcase \"testSubObj\":\n\t\tt.testSubObj = &TestSubObj{}\n\t\treturn dec.AddObject(t.testSubObj)\n\tcase \"testSubObj2\":\n\t\tt.testSubObj2 = &TestSubObj{}\n\t\treturn dec.AddObject(t.testSubObj2)\n\tcase \"testArr\":\n\t\treturn dec.AddArray(&t.testArr)\n\t}\n\treturn nil\n}\n\nfunc (t *TestObj) NKeys() int {\n\treturn 8\n}\n"
        }
      ]
    }
  ]
}