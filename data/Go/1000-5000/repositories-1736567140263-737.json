{
  "metadata": {
    "timestamp": 1736567140263,
    "page": 737,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjc0MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "RoaringBitmap/roaring",
      "stars": 2585,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".drone.yml",
          "type": "blob",
          "size": 0.3232421875,
          "content": "kind: pipeline\nname: default\n\nworkspace:\n  base: /go\n  path: src/github.com/RoaringBitmap/roaring\n\nsteps:\n- name: test\n  image: golang\n  commands:\n  - go get -t \n  - go test \n  - go build -tags appengine \n  - go test -tags appengine \n  - GOARCH=386 go build\n  - GOARCH=386 go test\n  - GOARCH=arm go build\n  - GOARCH=arm64 go build\n"
        },
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.0615234375,
          "content": "*~\nroaring-fuzz.zip\nworkdir\ncoverage.out\ntestdata/all3.classic\n"
        },
        {
          "name": ".gitmodules",
          "type": "blob",
          "size": 0,
          "content": ""
        },
        {
          "name": "AUTHORS",
          "type": "blob",
          "size": 0.27734375,
          "content": "# This is the official list of roaring authors for copyright purposes. \n\nTodd Gruben (@tgruben),\nDaniel Lemire (@lemire),\nElliot Murphy (@statik),\nBob Potter (@bpot),\nTyson Maly (@tvmaly),\nWill Glynn (@willglynn),\nBrent Pedersen (@brentp)\nMaciej Bi≈Ças (@maciej),\nJoe Nall (@joenall)\n"
        },
        {
          "name": "BitSliceIndexing",
          "type": "tree",
          "content": null
        },
        {
          "name": "CONTRIBUTORS",
          "type": "blob",
          "size": 0.4404296875,
          "content": "# This is the official list of roaring contributors \n\nTodd Gruben (@tgruben),\nDaniel Lemire (@lemire),\nElliot Murphy (@statik),\nBob Potter (@bpot),\nTyson Maly (@tvmaly),\nWill Glynn (@willglynn),\nBrent Pedersen (@brentp),\nJason E. Aten (@glycerine),\nVali Malinoiu (@0x4139),\nForud Ghafouri (@fzerorubigd),\nJoe Nall (@joenall),\n(@fredim),\nEdd Robinson (@e-dard),\nAlexander Petrov (@alldroll),\nGuy Molinari (@guymolinari),\nLing Jin (@JinLingChristopher)\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 12.7197265625,
          "content": "\n                                 Apache License\n                           Version 2.0, January 2004\n                        http://www.apache.org/licenses/\n\n   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION\n\n   1. Definitions.\n\n      \"License\" shall mean the terms and conditions for use, reproduction,\n      and distribution as defined by Sections 1 through 9 of this document.\n\n      \"Licensor\" shall mean the copyright owner or entity authorized by\n      the copyright owner that is granting the License.\n\n      \"Legal Entity\" shall mean the union of the acting entity and all\n      other entities that control, are controlled by, or are under common\n      control with that entity. For the purposes of this definition,\n      \"control\" means (i) the power, direct or indirect, to cause the\n      direction or management of such entity, whether by contract or\n      otherwise, or (ii) ownership of fifty percent (50%) or more of the\n      outstanding shares, or (iii) beneficial ownership of such entity.\n\n      \"You\" (or \"Your\") shall mean an individual or Legal Entity\n      exercising permissions granted by this License.\n\n      \"Source\" form shall mean the preferred form for making modifications,\n      including but not limited to software source code, documentation\n      source, and configuration files.\n\n      \"Object\" form shall mean any form resulting from mechanical\n      transformation or translation of a Source form, including but\n      not limited to compiled object code, generated documentation,\n      and conversions to other media types.\n\n      \"Work\" shall mean the work of authorship, whether in Source or\n      Object form, made available under the License, as indicated by a\n      copyright notice that is included in or attached to the work\n      (an example is provided in the Appendix below).\n\n      \"Derivative Works\" shall mean any work, whether in Source or Object\n      form, that is based on (or derived from) the Work and for which the\n      editorial revisions, annotations, elaborations, or other modifications\n      represent, as a whole, an original work of authorship. For the purposes\n      of this License, Derivative Works shall not include works that remain\n      separable from, or merely link (or bind by name) to the interfaces of,\n      the Work and Derivative Works thereof.\n\n      \"Contribution\" shall mean any work of authorship, including\n      the original version of the Work and any modifications or additions\n      to that Work or Derivative Works thereof, that is intentionally\n      submitted to Licensor for inclusion in the Work by the copyright owner\n      or by an individual or Legal Entity authorized to submit on behalf of\n      the copyright owner. For the purposes of this definition, \"submitted\"\n      means any form of electronic, verbal, or written communication sent\n      to the Licensor or its representatives, including but not limited to\n      communication on electronic mailing lists, source code control systems,\n      and issue tracking systems that are managed by, or on behalf of, the\n      Licensor for the purpose of discussing and improving the Work, but\n      excluding communication that is conspicuously marked or otherwise\n      designated in writing by the copyright owner as \"Not a Contribution.\"\n\n      \"Contributor\" shall mean Licensor and any individual or Legal Entity\n      on behalf of whom a Contribution has been received by Licensor and\n      subsequently incorporated within the Work.\n\n   2. Grant of Copyright License. Subject to the terms and conditions of\n      this License, each Contributor hereby grants to You a perpetual,\n      worldwide, non-exclusive, no-charge, royalty-free, irrevocable\n      copyright license to reproduce, prepare Derivative Works of,\n      publicly display, publicly perform, sublicense, and distribute the\n      Work and such Derivative Works in Source or Object form.\n\n   3. Grant of Patent License. Subject to the terms and conditions of\n      this License, each Contributor hereby grants to You a perpetual,\n      worldwide, non-exclusive, no-charge, royalty-free, irrevocable\n      (except as stated in this section) patent license to make, have made,\n      use, offer to sell, sell, import, and otherwise transfer the Work,\n      where such license applies only to those patent claims licensable\n      by such Contributor that are necessarily infringed by their\n      Contribution(s) alone or by combination of their Contribution(s)\n      with the Work to which such Contribution(s) was submitted. If You\n      institute patent litigation against any entity (including a\n      cross-claim or counterclaim in a lawsuit) alleging that the Work\n      or a Contribution incorporated within the Work constitutes direct\n      or contributory patent infringement, then any patent licenses\n      granted to You under this License for that Work shall terminate\n      as of the date such litigation is filed.\n\n   4. Redistribution. You may reproduce and distribute copies of the\n      Work or Derivative Works thereof in any medium, with or without\n      modifications, and in Source or Object form, provided that You\n      meet the following conditions:\n\n      (a) You must give any other recipients of the Work or\n          Derivative Works a copy of this License; and\n\n      (b) You must cause any modified files to carry prominent notices\n          stating that You changed the files; and\n\n      (c) You must retain, in the Source form of any Derivative Works\n          that You distribute, all copyright, patent, trademark, and\n          attribution notices from the Source form of the Work,\n          excluding those notices that do not pertain to any part of\n          the Derivative Works; and\n\n      (d) If the Work includes a \"NOTICE\" text file as part of its\n          distribution, then any Derivative Works that You distribute must\n          include a readable copy of the attribution notices contained\n          within such NOTICE file, excluding those notices that do not\n          pertain to any part of the Derivative Works, in at least one\n          of the following places: within a NOTICE text file distributed\n          as part of the Derivative Works; within the Source form or\n          documentation, if provided along with the Derivative Works; or,\n          within a display generated by the Derivative Works, if and\n          wherever such third-party notices normally appear. The contents\n          of the NOTICE file are for informational purposes only and\n          do not modify the License. You may add Your own attribution\n          notices within Derivative Works that You distribute, alongside\n          or as an addendum to the NOTICE text from the Work, provided\n          that such additional attribution notices cannot be construed\n          as modifying the License.\n\n      You may add Your own copyright statement to Your modifications and\n      may provide additional or different license terms and conditions\n      for use, reproduction, or distribution of Your modifications, or\n      for any such Derivative Works as a whole, provided Your use,\n      reproduction, and distribution of the Work otherwise complies with\n      the conditions stated in this License.\n\n   5. Submission of Contributions. Unless You explicitly state otherwise,\n      any Contribution intentionally submitted for inclusion in the Work\n      by You to the Licensor shall be under the terms and conditions of\n      this License, without any additional terms or conditions.\n      Notwithstanding the above, nothing herein shall supersede or modify\n      the terms of any separate license agreement you may have executed\n      with Licensor regarding such Contributions.\n\n   6. Trademarks. This License does not grant permission to use the trade\n      names, trademarks, service marks, or product names of the Licensor,\n      except as required for reasonable and customary use in describing the\n      origin of the Work and reproducing the content of the NOTICE file.\n\n   7. Disclaimer of Warranty. Unless required by applicable law or\n      agreed to in writing, Licensor provides the Work (and each\n      Contributor provides its Contributions) on an \"AS IS\" BASIS,\n      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n      implied, including, without limitation, any warranties or conditions\n      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A\n      PARTICULAR PURPOSE. You are solely responsible for determining the\n      appropriateness of using or redistributing the Work and assume any\n      risks associated with Your exercise of permissions under this License.\n\n   8. Limitation of Liability. In no event and under no legal theory,\n      whether in tort (including negligence), contract, or otherwise,\n      unless required by applicable law (such as deliberate and grossly\n      negligent acts) or agreed to in writing, shall any Contributor be\n      liable to You for damages, including any direct, indirect, special,\n      incidental, or consequential damages of any character arising as a\n      result of this License or out of the use or inability to use the\n      Work (including but not limited to damages for loss of goodwill,\n      work stoppage, computer failure or malfunction, or any and all\n      other commercial damages or losses), even if such Contributor\n      has been advised of the possibility of such damages.\n\n   9. Accepting Warranty or Additional Liability. While redistributing\n      the Work or Derivative Works thereof, You may choose to offer,\n      and charge a fee for, acceptance of support, warranty, indemnity,\n      or other liability obligations and/or rights consistent with this\n      License. However, in accepting such obligations, You may act only\n      on Your own behalf and on Your sole responsibility, not on behalf\n      of any other Contributor, and only if You agree to indemnify,\n      defend, and hold each Contributor harmless for any liability\n      incurred by, or claims asserted against, such Contributor by reason\n      of your accepting any such warranty or additional liability.\n\n   END OF TERMS AND CONDITIONS\n\n   APPENDIX: How to apply the Apache License to your work.\n\n      To apply the Apache License to your work, attach the following\n      boilerplate notice, with the fields enclosed by brackets \"[]\"\n      replaced with your own identifying information. (Don't include\n      the brackets!)  The text should be enclosed in the appropriate\n      comment syntax for the file format. We also recommend that a\n      file or class name and description of purpose be included on the\n      same \"printed page\" as the copyright notice for easier\n      identification within third-party archives.\n\n   Copyright 2016 by the authors\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n       http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n\n================================================================================\n\nPortions of runcontainer.go are from the Go standard library, which is licensed\nunder:\n\nCopyright (c) 2009 The Go Authors. All rights reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are\nmet:\n\n   * Redistributions of source code must retain the above copyright\n     notice, this list of conditions and the following disclaimer.\n   * Redistributions in binary form must reproduce the above\n     copyright notice, this list of conditions and the following disclaimer\n     in the documentation and/or other materials provided with the\n     distribution.\n   * Neither the name of Google Inc. nor the names of its\n     contributors may be used to endorse or promote products derived from\n     this software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n\"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\nLIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\nA PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\nOWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\nSPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\nLIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\nTHEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n"
        },
        {
          "name": "LICENSE-2.0.txt",
          "type": "blob",
          "size": 11.0791015625,
          "content": "\n                                 Apache License\n                           Version 2.0, January 2004\n                        http://www.apache.org/licenses/\n\n   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION\n\n   1. Definitions.\n\n      \"License\" shall mean the terms and conditions for use, reproduction,\n      and distribution as defined by Sections 1 through 9 of this document.\n\n      \"Licensor\" shall mean the copyright owner or entity authorized by\n      the copyright owner that is granting the License.\n\n      \"Legal Entity\" shall mean the union of the acting entity and all\n      other entities that control, are controlled by, or are under common\n      control with that entity. For the purposes of this definition,\n      \"control\" means (i) the power, direct or indirect, to cause the\n      direction or management of such entity, whether by contract or\n      otherwise, or (ii) ownership of fifty percent (50%) or more of the\n      outstanding shares, or (iii) beneficial ownership of such entity.\n\n      \"You\" (or \"Your\") shall mean an individual or Legal Entity\n      exercising permissions granted by this License.\n\n      \"Source\" form shall mean the preferred form for making modifications,\n      including but not limited to software source code, documentation\n      source, and configuration files.\n\n      \"Object\" form shall mean any form resulting from mechanical\n      transformation or translation of a Source form, including but\n      not limited to compiled object code, generated documentation,\n      and conversions to other media types.\n\n      \"Work\" shall mean the work of authorship, whether in Source or\n      Object form, made available under the License, as indicated by a\n      copyright notice that is included in or attached to the work\n      (an example is provided in the Appendix below).\n\n      \"Derivative Works\" shall mean any work, whether in Source or Object\n      form, that is based on (or derived from) the Work and for which the\n      editorial revisions, annotations, elaborations, or other modifications\n      represent, as a whole, an original work of authorship. For the purposes\n      of this License, Derivative Works shall not include works that remain\n      separable from, or merely link (or bind by name) to the interfaces of,\n      the Work and Derivative Works thereof.\n\n      \"Contribution\" shall mean any work of authorship, including\n      the original version of the Work and any modifications or additions\n      to that Work or Derivative Works thereof, that is intentionally\n      submitted to Licensor for inclusion in the Work by the copyright owner\n      or by an individual or Legal Entity authorized to submit on behalf of\n      the copyright owner. For the purposes of this definition, \"submitted\"\n      means any form of electronic, verbal, or written communication sent\n      to the Licensor or its representatives, including but not limited to\n      communication on electronic mailing lists, source code control systems,\n      and issue tracking systems that are managed by, or on behalf of, the\n      Licensor for the purpose of discussing and improving the Work, but\n      excluding communication that is conspicuously marked or otherwise\n      designated in writing by the copyright owner as \"Not a Contribution.\"\n\n      \"Contributor\" shall mean Licensor and any individual or Legal Entity\n      on behalf of whom a Contribution has been received by Licensor and\n      subsequently incorporated within the Work.\n\n   2. Grant of Copyright License. Subject to the terms and conditions of\n      this License, each Contributor hereby grants to You a perpetual,\n      worldwide, non-exclusive, no-charge, royalty-free, irrevocable\n      copyright license to reproduce, prepare Derivative Works of,\n      publicly display, publicly perform, sublicense, and distribute the\n      Work and such Derivative Works in Source or Object form.\n\n   3. Grant of Patent License. Subject to the terms and conditions of\n      this License, each Contributor hereby grants to You a perpetual,\n      worldwide, non-exclusive, no-charge, royalty-free, irrevocable\n      (except as stated in this section) patent license to make, have made,\n      use, offer to sell, sell, import, and otherwise transfer the Work,\n      where such license applies only to those patent claims licensable\n      by such Contributor that are necessarily infringed by their\n      Contribution(s) alone or by combination of their Contribution(s)\n      with the Work to which such Contribution(s) was submitted. If You\n      institute patent litigation against any entity (including a\n      cross-claim or counterclaim in a lawsuit) alleging that the Work\n      or a Contribution incorporated within the Work constitutes direct\n      or contributory patent infringement, then any patent licenses\n      granted to You under this License for that Work shall terminate\n      as of the date such litigation is filed.\n\n   4. Redistribution. You may reproduce and distribute copies of the\n      Work or Derivative Works thereof in any medium, with or without\n      modifications, and in Source or Object form, provided that You\n      meet the following conditions:\n\n      (a) You must give any other recipients of the Work or\n          Derivative Works a copy of this License; and\n\n      (b) You must cause any modified files to carry prominent notices\n          stating that You changed the files; and\n\n      (c) You must retain, in the Source form of any Derivative Works\n          that You distribute, all copyright, patent, trademark, and\n          attribution notices from the Source form of the Work,\n          excluding those notices that do not pertain to any part of\n          the Derivative Works; and\n\n      (d) If the Work includes a \"NOTICE\" text file as part of its\n          distribution, then any Derivative Works that You distribute must\n          include a readable copy of the attribution notices contained\n          within such NOTICE file, excluding those notices that do not\n          pertain to any part of the Derivative Works, in at least one\n          of the following places: within a NOTICE text file distributed\n          as part of the Derivative Works; within the Source form or\n          documentation, if provided along with the Derivative Works; or,\n          within a display generated by the Derivative Works, if and\n          wherever such third-party notices normally appear. The contents\n          of the NOTICE file are for informational purposes only and\n          do not modify the License. You may add Your own attribution\n          notices within Derivative Works that You distribute, alongside\n          or as an addendum to the NOTICE text from the Work, provided\n          that such additional attribution notices cannot be construed\n          as modifying the License.\n\n      You may add Your own copyright statement to Your modifications and\n      may provide additional or different license terms and conditions\n      for use, reproduction, or distribution of Your modifications, or\n      for any such Derivative Works as a whole, provided Your use,\n      reproduction, and distribution of the Work otherwise complies with\n      the conditions stated in this License.\n\n   5. Submission of Contributions. Unless You explicitly state otherwise,\n      any Contribution intentionally submitted for inclusion in the Work\n      by You to the Licensor shall be under the terms and conditions of\n      this License, without any additional terms or conditions.\n      Notwithstanding the above, nothing herein shall supersede or modify\n      the terms of any separate license agreement you may have executed\n      with Licensor regarding such Contributions.\n\n   6. Trademarks. This License does not grant permission to use the trade\n      names, trademarks, service marks, or product names of the Licensor,\n      except as required for reasonable and customary use in describing the\n      origin of the Work and reproducing the content of the NOTICE file.\n\n   7. Disclaimer of Warranty. Unless required by applicable law or\n      agreed to in writing, Licensor provides the Work (and each\n      Contributor provides its Contributions) on an \"AS IS\" BASIS,\n      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n      implied, including, without limitation, any warranties or conditions\n      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A\n      PARTICULAR PURPOSE. You are solely responsible for determining the\n      appropriateness of using or redistributing the Work and assume any\n      risks associated with Your exercise of permissions under this License.\n\n   8. Limitation of Liability. In no event and under no legal theory,\n      whether in tort (including negligence), contract, or otherwise,\n      unless required by applicable law (such as deliberate and grossly\n      negligent acts) or agreed to in writing, shall any Contributor be\n      liable to You for damages, including any direct, indirect, special,\n      incidental, or consequential damages of any character arising as a\n      result of this License or out of the use or inability to use the\n      Work (including but not limited to damages for loss of goodwill,\n      work stoppage, computer failure or malfunction, or any and all\n      other commercial damages or losses), even if such Contributor\n      has been advised of the possibility of such damages.\n\n   9. Accepting Warranty or Additional Liability. While redistributing\n      the Work or Derivative Works thereof, You may choose to offer,\n      and charge a fee for, acceptance of support, warranty, indemnity,\n      or other liability obligations and/or rights consistent with this\n      License. However, in accepting such obligations, You may act only\n      on Your own behalf and on Your sole responsibility, not on behalf\n      of any other Contributor, and only if You agree to indemnify,\n      defend, and hold each Contributor harmless for any liability\n      incurred by, or claims asserted against, such Contributor by reason\n      of your accepting any such warranty or additional liability.\n\n   END OF TERMS AND CONDITIONS\n\n   APPENDIX: How to apply the Apache License to your work.\n\n      To apply the Apache License to your work, attach the following\n      boilerplate notice, with the fields enclosed by brackets \"[]\"\n      replaced with your own identifying information. (Don't include\n      the brackets!)  The text should be enclosed in the appropriate\n      comment syntax for the file format. We also recommend that a\n      file or class name and description of purpose be included on the\n      same \"printed page\" as the copyright notice for easier\n      identification within third-party archives.\n\n   Copyright 2016 by the authors\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n       http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 15.638671875,
          "content": "# roaring \n\n[![GoDoc](https://godoc.org/github.com/RoaringBitmap/roaring?status.svg)](https://godoc.org/github.com/RoaringBitmap/roaring) [![Go Report Card](https://goreportcard.com/badge/RoaringBitmap/roaring)](https://goreportcard.com/report/github.com/RoaringBitmap/roaring)\n\n![Go-CI](https://github.com/RoaringBitmap/roaring/workflows/Go-CI/badge.svg)\n![Go-ARM-CI](https://github.com/RoaringBitmap/roaring/workflows/Go-ARM-CI/badge.svg)\n![Go-Windows-CI](https://github.com/RoaringBitmap/roaring/workflows/Go-Windows-CI/badge.svg)\n=============\n\nThis is a go version of the Roaring bitmap data structure. \n\nRoaring bitmaps are used by several major systems such as [Apache Lucene][lucene] and derivative systems such as [Solr][solr] and\n[Elasticsearch][elasticsearch], [Apache Druid (Incubating)][druid], [LinkedIn Pinot][pinot], [Netflix Atlas][atlas],  [Apache Spark][spark], [OpenSearchServer][opensearchserver], [anacrolix/torrent][anacrolix/torrent], [Whoosh][whoosh], [Redpanda](https://github.com/redpanda-data/redpanda), [Pilosa][pilosa],  [Microsoft Visual Studio Team Services (VSTS)][vsts], and eBay's [Apache Kylin][kylin]. The YouTube SQL Engine, [Google Procella](https://research.google/pubs/pub48388/), uses Roaring bitmaps for indexing.\n\n[lucene]: https://lucene.apache.org/\n[solr]: https://lucene.apache.org/solr/\n[elasticsearch]: https://www.elastic.co/products/elasticsearch\n[druid]: https://druid.apache.org/\n[spark]: https://spark.apache.org/\n[opensearchserver]: http://www.opensearchserver.com\n[anacrolix/torrent]: https://github.com/anacrolix/torrent\n[whoosh]: https://bitbucket.org/mchaput/whoosh/wiki/Home\n[pilosa]: https://www.pilosa.com/\n[kylin]: http://kylin.apache.org/\n[pinot]: http://github.com/linkedin/pinot/wiki\n[vsts]: https://www.visualstudio.com/team-services/\n[atlas]: https://github.com/Netflix/atlas\n\nRoaring bitmaps are found to work well in many important applications:\n\n> Use Roaring for bitmap compression whenever possible. Do not use other bitmap compression methods ([Wang et al., SIGMOD 2017](http://db.ucsd.edu/wp-content/uploads/2017/03/sidm338-wangA.pdf))\n\n\nThe ``roaring`` Go library is used by\n* [anacrolix/torrent]\n* [InfluxDB](https://www.influxdata.com)\n* [Pilosa](https://www.pilosa.com/)\n* [Bleve](http://www.blevesearch.com)\n* [Weaviate](https://github.com/weaviate/weaviate)\n* [lindb](https://github.com/lindb/lindb)\n* [Elasticell](https://github.com/deepfabric/elasticell)\n* [SourceGraph](https://github.com/sourcegraph/sourcegraph)\n* [M3](https://github.com/m3db/m3)\n* [trident](https://github.com/NetApp/trident)\n* [Husky](https://www.datadoghq.com/blog/engineering/introducing-husky/)\n* [FrostDB](https://github.com/polarsignals/frostdb)\n\nThis library is used in production in several systems, it is part of the [Awesome Go collection](https://awesome-go.com).\n\n\nThere are also  [Java](https://github.com/RoaringBitmap/RoaringBitmap) and [C/C++](https://github.com/RoaringBitmap/CRoaring) versions.  The Java, C, C++ and Go version are binary compatible: e.g,  you can save bitmaps\nfrom a Java program and load them back in Go, and vice versa. We have a [format specification](https://github.com/RoaringBitmap/RoaringFormatSpec).\n\n\nThis code is licensed under Apache License, Version 2.0 (ASL2.0).\n\nCopyright 2016-... by the authors.\n\nWhen should you use a bitmap?\n===================================\n\n\nSets are a fundamental abstraction in\nsoftware. They can be implemented in various\nways, as hash sets, as trees, and so forth.\nIn databases and search engines, sets are often an integral\npart of indexes. For example, we may need to maintain a set\nof all documents or rows  (represented by numerical identifier)\nthat satisfy some property. Besides adding or removing\nelements from the set, we need fast functions\nto compute the intersection, the union, the difference between sets, and so on.\n\n\nTo implement a set\nof integers, a particularly appealing strategy is the\nbitmap (also called bitset or bit vector). Using n bits,\nwe can represent any set made of the integers from the range\n[0,n): the ith bit is set to one if integer i is present in the set.\nCommodity processors use words of W=32 or W=64 bits. By combining many such words, we can\nsupport large values of n. Intersections, unions and differences can then be implemented\n as bitwise AND, OR and ANDNOT operations.\nMore complicated set functions can also be implemented as bitwise operations.\n\nWhen the bitset approach is applicable, it can be orders of\nmagnitude faster than other possible implementation of a set (e.g., as a hash set)\nwhile using several times less memory.\n\nHowever, a bitset, even a compressed one is not always applicable. For example, if\nyou have 1000 random-looking integers, then a simple array might be the best representation.\nWe refer to this case as the \"sparse\" scenario.\n\nWhen should you use compressed bitmaps?\n===================================\n\nAn uncompressed BitSet can use a lot of memory. For example, if you take a BitSet\nand set the bit at position 1,000,000 to true and you have just over 100kB. That is over 100kB\nto store the position of one bit. This is wasteful  even if you do not care about memory:\nsuppose that you need to compute the intersection between this BitSet and another one\nthat has a bit at position 1,000,001 to true, then you need to go through all these zeroes,\nwhether you like it or not. That can become very wasteful.\n\nThis being said, there are definitively cases where attempting to use compressed bitmaps is wasteful.\nFor example, if you have a small universe size. E.g., your bitmaps represent sets of integers\nfrom [0,n) where n is small (e.g., n=64 or n=128). If you can use uncompressed BitSet and\nit does not blow up your memory usage,  then compressed bitmaps are probably not useful\nto you. In fact, if you do not need compression, then a BitSet offers remarkable speed.\n\nThe sparse scenario is another use case where compressed bitmaps should not be used.\nKeep in mind that random-looking data is usually not compressible. E.g., if you have a small set of\n32-bit random integers, it is not mathematically possible to use far less than 32 bits per integer,\nand attempts at compression can be counterproductive.\n\nHow does Roaring compares with the alternatives?\n==================================================\n\n\nMost alternatives to Roaring are part of a larger family of compressed bitmaps that are run-length-encoded\nbitmaps. They identify long runs of 1s or 0s and they represent them with a marker word.\nIf you have a local mix of 1s and 0, you use an uncompressed word.\n\nThere are many formats in this family:\n\n* Oracle's BBC is an obsolete format at this point: though it may provide good compression,\nit is likely much slower than more recent alternatives due to excessive branching.\n* WAH is a patented variation on BBC that provides better performance.\n* Concise is a variation on the patented WAH. It some specific instances, it can compress\nmuch better than WAH (up to 2x better), but it is generally slower.\n* EWAH is both free of patent, and it is faster than all the above. On the downside, it\ndoes not compress quite as well. It is faster because it allows some form of \"skipping\"\nover uncompressed words. So though none of these formats are great at random access, EWAH\nis better than the alternatives.\n\n\n\nThere is a big problem with these formats however that can hurt you badly in some cases: there is no random access. If you want to check whether a given value is present in the set, you have to start from the beginning and \"uncompress\" the whole thing. This means that if you want to intersect a big set with a large set, you still have to uncompress the whole big set in the worst case...\n\nRoaring solves this problem. It works in the following manner. It divides the data into chunks of 2<sup>16</sup> integers\n(e.g., [0, 2<sup>16</sup>), [2<sup>16</sup>, 2 x 2<sup>16</sup>), ...). Within a chunk, it can use an uncompressed bitmap, a simple list of integers,\nor a list of runs. Whatever format it uses, they all allow you to check for the presence of any one value quickly\n(e.g., with a binary search). The net result is that Roaring can compute many operations much faster than run-length-encoded\nformats like WAH, EWAH, Concise... Maybe surprisingly, Roaring also generally offers better compression ratios.\n\n\n\n\n\n### References\n\n- Daniel Lemire, Owen Kaser, Nathan Kurz, Luca Deri, Chris O'Hara, Fran√ßois Saint-Jacques, Gregory Ssi-Yan-Kai, Roaring Bitmaps: Implementation of an Optimized Software Library, Software: Practice and Experience 48 (4), 2018 [arXiv:1709.07821](https://arxiv.org/abs/1709.07821)\n-  Samy Chambi, Daniel Lemire, Owen Kaser, Robert Godin,\nBetter bitmap performance with Roaring bitmaps,\nSoftware: Practice and Experience 46 (5), 2016.[arXiv:1402.6407](http://arxiv.org/abs/1402.6407) This paper used data from http://lemire.me/data/realroaring2014.html\n- Daniel Lemire, Gregory Ssi-Yan-Kai, Owen Kaser, Consistently faster and smaller compressed bitmaps with Roaring, Software: Practice and Experience 46 (11), 2016. [arXiv:1603.06549](http://arxiv.org/abs/1603.06549)\n\n### Dependencies\n\nDependencies are fetched automatically by giving the `-t` flag to `go get`.\n\nthey include\n  - github.com/bits-and-blooms/bitset\n  - github.com/mschoch/smat\n  - github.com/glycerine/go-unsnap-stream\n  - github.com/philhofer/fwd\n  - github.com/jtolds/gls\n\nNote that the smat library requires Go 1.15 or better.\n\n#### Installation\n\n  - go get -t github.com/RoaringBitmap/roaring\n\n### Instructions for contributors\n\nUsing bash or other common shells:\n```\n$ git clone git@github.com:RoaringBitmap/roaring.git\n$ export GO111MODULE=on \n$ go mod tidy\n$ go test -v\n```\n\n### Example\n\nHere is a simplified but complete example:\n\n```go\npackage main\n\nimport (\n    \"fmt\"\n    \"github.com/RoaringBitmap/roaring/v2\"\n    \"bytes\"\n)\n\n\nfunc main() {\n    // example inspired by https://github.com/fzandona/goroar\n    fmt.Println(\"==roaring==\")\n    rb1 := roaring.BitmapOf(1, 2, 3, 4, 5, 100, 1000)\n    fmt.Println(rb1.String())\n\n    rb2 := roaring.BitmapOf(3, 4, 1000)\n    fmt.Println(rb2.String())\n\n    rb3 := roaring.New()\n    fmt.Println(rb3.String())\n\n    fmt.Println(\"Cardinality: \", rb1.GetCardinality())\n\n    fmt.Println(\"Contains 3? \", rb1.Contains(3))\n\n    rb1.And(rb2)\n\n    rb3.Add(1)\n    rb3.Add(5)\n\n    rb3.Or(rb1)\n\n    // computes union of the three bitmaps in parallel using 4 workers  \n    roaring.ParOr(4, rb1, rb2, rb3)\n    // computes intersection of the three bitmaps in parallel using 4 workers  \n    roaring.ParAnd(4, rb1, rb2, rb3)\n\n\n    // prints 1, 3, 4, 5, 1000\n    i := rb3.Iterator()\n    for i.HasNext() {\n        fmt.Println(i.Next())\n    }\n    fmt.Println()\n\n    // next we include an example of serialization\n    buf := new(bytes.Buffer)\n    rb1.WriteTo(buf) // we omit error handling\n    newrb:= roaring.New()\n    newrb.ReadFrom(buf)\n    if rb1.Equals(newrb) {\n    \tfmt.Println(\"I wrote the content to a byte stream and read it back.\")\n    }\n    // you can iterate over bitmaps using ReverseIterator(), Iterator, ManyIterator()\n}\n```\n\nIf you wish to use serialization and handle errors, you might want to\nconsider the following sample of code:\n\n```go\n\trb := BitmapOf(1, 2, 3, 4, 5, 100, 1000)\n\tbuf := new(bytes.Buffer)\n\tsize,err:=rb.WriteTo(buf)\n\tif err != nil {\n\t\tfmt.Println(\"Failed writing\") // return or panic\n\t}\n\tnewrb:= New()\n\tsize,err=newrb.ReadFrom(buf)\n\tif err != nil {\n\t\tfmt.Println(\"Failed reading\") // return or panic\n\t}\n\t// if buf is an untrusted source, you should validate the result\n\t// (this adds a bit of complexity but it is necessary for security)\n\tif newrb.Validate() != nil {\n\t\tfmt.Println(\"Failed validation\") // return or panic\n\t}\n\tif ! rb.Equals(newrb) {\n\t\tfmt.Println(\"Cannot retrieve serialized version\")\n\t}\n```\n\nGiven N integers in [0,x), then the serialized size in bytes of\na Roaring bitmap should never exceed this bound:\n\n`` 8 + 9 * ((long)x+65535)/65536 + 2 * N ``\n\nThat is, given a fixed overhead for the universe size (x), Roaring\nbitmaps never use more than 2 bytes per integer. You can call\n``BoundSerializedSizeInBytes`` for a more precise estimate.\n\n### 64-bit Roaring\n\nBy default, roaring is used to stored unsigned 32-bit integers. However, we also offer\nan extension dedicated to 64-bit integers. It supports roughly the same functions:\n\n```go\npackage main\n\nimport (\n    \"fmt\"\n    \"github.com/RoaringBitmap/roaring/v2/roaring64\"\n    \"bytes\"\n)\n\n\nfunc main() {\n    // example inspired by https://github.com/fzandona/goroar\n    fmt.Println(\"==roaring64==\")\n    rb1 := roaring64.BitmapOf(1, 2, 3, 4, 5, 100, 1000)\n    fmt.Println(rb1.String())\n\n    rb2 := roaring64.BitmapOf(3, 4, 1000)\n    fmt.Println(rb2.String())\n\n    rb3 := roaring64.New()\n    fmt.Println(rb3.String())\n\n    fmt.Println(\"Cardinality: \", rb1.GetCardinality())\n\n    fmt.Println(\"Contains 3? \", rb1.Contains(3))\n\n    rb1.And(rb2)\n\n    rb3.Add(1)\n    rb3.Add(5)\n\n    rb3.Or(rb1)\n\n\n\n    // prints 1, 3, 4, 5, 1000\n    i := rb3.Iterator()\n    for i.HasNext() {\n        fmt.Println(i.Next())\n    }\n    fmt.Println()\n\n    // next we include an example of serialization\n    buf := new(bytes.Buffer)\n    rb1.WriteTo(buf) // we omit error handling\n    newrb:= roaring64.New()\n    newrb.ReadFrom(buf)\n    if rb1.Equals(newrb) {\n    \tfmt.Println(\"I wrote the content to a byte stream and read it back.\")\n    }\n    // you can iterate over bitmaps using ReverseIterator(), Iterator, ManyIterator()\n}\n```\n\nOnly the 32-bit roaring format is standard and cross-operable between Java, C++, C and Go. There is no guarantee that the 64-bit versions are compatible.\n\n### Documentation\n\nCurrent documentation is available at https://pkg.go.dev/github.com/RoaringBitmap/roaring and https://pkg.go.dev/github.com/RoaringBitmap/roaring/roaring64\n\n### Goroutine safety\n\nIn general, it should not generally be considered safe to access\nthe same bitmaps using different goroutines--they are left\nunsynchronized for performance. Should you want to access\na Bitmap from more than one goroutine, you should\nprovide synchronization. Typically this is done by using channels to pass\nthe *Bitmap around (in Go style; so there is only ever one owner),\nor by using `sync.Mutex` to serialize operations on Bitmaps.\n\n### Coverage\n\nWe test our software. For a report on our test coverage, see\n\nhttps://coveralls.io/github/RoaringBitmap/roaring?branch=master\n\n### Benchmark\n\nType\n\n         go test -bench Benchmark -run -\n\nTo run benchmarks on [Real Roaring Datasets](https://github.com/RoaringBitmap/real-roaring-datasets)\nrun the following:\n\n```sh\ngo get github.com/RoaringBitmap/real-roaring-datasets\nBENCH_REAL_DATA=1 go test -bench BenchmarkRealData -run -\n```\n\n### Iterative use\n\nYou can use roaring with gore:\n\n- go install github.com/x-motemen/gore/cmd/gore@latest\n- Make sure that ``$GOPATH/bin`` is in your ``$PATH``.\n\n```go\n$ gore\ngore version 0.2.6  :help for help\ngore> :import github.com/RoaringBitmap/roaring\ngore> x:=roaring.New()\ngore> x.Add(1)\ngore> x.String()\n\"{1}\"\n```\n\n\n### Fuzzy testing\n\nYou can help us test further the library with fuzzy testing:\n\n         go get github.com/dvyukov/go-fuzz/go-fuzz\n         go get github.com/dvyukov/go-fuzz/go-fuzz-build\n         go test -tags=gofuzz -run=TestGenerateSmatCorpus\n         go-fuzz-build github.com/RoaringBitmap/roaring\n         go-fuzz -bin=./roaring-fuzz.zip -workdir=workdir/ -timeout=200 -func FuzzSmat\n\nLet it run, and if the # of crashers is > 0, check out the reports in\nthe workdir where you should be able to find the panic goroutine stack\ntraces.\n\nYou may also replace `-func FuzzSmat`  by `-func FuzzSerializationBuffer` or `-func FuzzSerializationStream`.\n\n### Alternative in Go\n\nThere is a Go version wrapping the C/C++ implementation https://github.com/RoaringBitmap/gocroaring\n\nFor an alternative implementation in Go, see https://github.com/fzandona/goroar\nThe two versions were written independently.\n\n\n### Mailing list/discussion group\n\nhttps://groups.google.com/forum/#!forum/roaring-bitmaps\n"
        },
        {
          "name": "aggregation_test.go",
          "type": "blob",
          "size": 16.6826171875,
          "content": "package roaring\n\n// to run just these tests: go test -run TestParAggregations\n\nimport (\n\t\"fmt\"\n\t\"sort\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc testAggregations(t *testing.T,\n\tand func(bitmaps ...*Bitmap) *Bitmap,\n\tor func(bitmaps ...*Bitmap) *Bitmap,\n\txor func(bitmaps ...*Bitmap) *Bitmap) {\n\n\tt.Run(\"simple case\", func(t *testing.T) {\n\t\trb1 := NewBitmap()\n\t\trb2 := NewBitmap()\n\t\trb1.Add(1)\n\t\trb2.Add(2)\n\n\t\tassertAggregation(t, 0, and, rb1, rb2)\n\t\tassertAggregation(t, 2, or, rb1, rb2)\n\t\tassertAggregation(t, 2, xor, rb1, rb2)\n\t})\n\n\tt.Run(\"aggregate nothing\", func(t *testing.T) {\n\t\tassertAggregation(t, 0, and)\n\t\tassertAggregation(t, 0, or)\n\t\tassertAggregation(t, 0, xor)\n\t})\n\n\tt.Run(\"single bitmap\", func(t *testing.T) {\n\t\trb := BitmapOf(1, 2, 3)\n\n\t\tassertAggregation(t, 3, and, rb)\n\t\tassertAggregation(t, 3, or, rb)\n\t\tassertAggregation(t, 3, xor, rb)\n\t})\n\n\tt.Run(\"empty and single elem bitmaps\", func(t *testing.T) {\n\t\trb1 := NewBitmap()\n\t\trb2 := BitmapOf(1)\n\n\t\tassertAggregation(t, 0, and, rb1, rb2)\n\t\tassertAggregation(t, 1, or, rb1, rb2)\n\t\tassertAggregation(t, 1, xor, rb1, rb2)\n\t})\n\n\tt.Run(\"two single elem disjoint sets\", func(t *testing.T) {\n\t\trb1 := BitmapOf(1)\n\t\trb2 := BitmapOf(2)\n\n\t\tassertAggregation(t, 0, and, rb1, rb2)\n\t\tassertAggregation(t, 2, or, rb1, rb2)\n\t})\n\n\tt.Run(\"3 bitmaps with CoW set (not in order of definition)\", func(t *testing.T) {\n\t\trb1 := NewBitmap()\n\t\trb2 := NewBitmap()\n\t\trb3 := NewBitmap()\n\t\trb1.SetCopyOnWrite(true)\n\t\trb2.SetCopyOnWrite(true)\n\t\trb3.SetCopyOnWrite(true)\n\t\trb1.Add(1)\n\t\trb1.Add(100000)\n\t\trb2.Add(200000)\n\t\trb3.Add(1)\n\t\trb3.Add(300000)\n\t\tcheckValidity(t, rb1)\n\t\tcheckValidity(t, rb2)\n\t\tcheckValidity(t, rb3)\n\t\tassertAggregation(t, 0, and, rb2, rb1, rb3)\n\t\tassertAggregation(t, 4, or, rb2, rb1, rb3)\n\t\tassertAggregation(t, 3, xor, rb2, rb1, rb3)\n\t})\n\n\tt.Run(\"3 bitmaps (not in order of definition)\", func(t *testing.T) {\n\t\trb1 := NewBitmap()\n\t\trb2 := NewBitmap()\n\t\trb3 := NewBitmap()\n\t\trb1.Add(1)\n\t\trb1.Add(100000)\n\t\trb2.Add(200000)\n\t\trb3.Add(1)\n\t\trb3.Add(300000)\n\t\tcheckValidity(t, rb1)\n\t\tcheckValidity(t, rb2)\n\t\tcheckValidity(t, rb3)\n\t\tassertAggregation(t, 0, and, rb2, rb1, rb3)\n\t\tassertAggregation(t, 4, or, rb2, rb1, rb3)\n\t\tassertAggregation(t, 3, xor, rb2, rb1, rb3)\n\t})\n\n\tt.Run(\"3 bitmaps\", func(t *testing.T) {\n\t\trb1 := NewBitmap()\n\t\trb2 := NewBitmap()\n\t\trb3 := NewBitmap()\n\t\trb1.Add(1)\n\t\trb1.Add(100000)\n\t\trb2.Add(200000)\n\t\trb3.Add(1)\n\t\trb3.Add(300000)\n\t\tcheckValidity(t, rb1)\n\t\tcheckValidity(t, rb2)\n\t\tcheckValidity(t, rb3)\n\t\tassertAggregation(t, 0, and, rb1, rb2, rb3)\n\t\tassertAggregation(t, 4, or, rb1, rb2, rb3)\n\t\tassertAggregation(t, 3, xor, rb1, rb2, rb3)\n\t})\n\n\tt.Run(\"3 bitmaps with CoW set\", func(t *testing.T) {\n\t\trb1 := NewBitmap()\n\t\trb2 := NewBitmap()\n\t\trb3 := NewBitmap()\n\t\trb1.SetCopyOnWrite(true)\n\t\trb2.SetCopyOnWrite(true)\n\t\trb3.SetCopyOnWrite(true)\n\t\trb1.Add(1)\n\t\trb1.Add(100000)\n\t\trb2.Add(200000)\n\t\trb3.Add(1)\n\t\trb3.Add(300000)\n\n\t\tcheckValidity(t, rb1)\n\t\tcheckValidity(t, rb2)\n\t\tcheckValidity(t, rb3)\n\n\t\tassertAggregation(t, 0, and, rb1, rb2, rb3)\n\t\tassertAggregation(t, 4, or, rb1, rb2, rb3)\n\t\tassertAggregation(t, 3, xor, rb1, rb2, rb3)\n\t})\n\n\tt.Run(\"advanced case\", func(t *testing.T) {\n\t\trb1 := NewBitmap()\n\t\trb2 := NewBitmap()\n\t\trb3 := NewBitmap()\n\t\tfor i := uint32(0); i < 1000000; i += 3 {\n\t\t\trb1.Add(i)\n\t\t}\n\t\tfor i := uint32(0); i < 1000000; i += 7 {\n\t\t\trb2.Add(i)\n\t\t}\n\t\tfor i := uint32(0); i < 1000000; i += 1001 {\n\t\t\trb3.Add(i)\n\t\t}\n\t\tfor i := uint32(1000000); i < 2000000; i += 1001 {\n\t\t\trb1.Add(i)\n\t\t}\n\t\tfor i := uint32(1000000); i < 2000000; i += 3 {\n\t\t\trb2.Add(i)\n\t\t}\n\t\tfor i := uint32(1000000); i < 2000000; i += 7 {\n\t\t\trb3.Add(i)\n\t\t}\n\n\t\trb1.Or(rb2)\n\t\trb1.Or(rb3)\n\t\tbigand := And(And(rb1, rb2), rb3)\n\t\tbigxor := Xor(Xor(rb1, rb2), rb3)\n\t\tcheckValidity(t, bigand)\n\t\tcheckValidity(t, bigxor)\n\t\tif or != nil {\n\t\t\tassert.True(t, or(rb1, rb2, rb3).Equals(rb1))\n\t\t}\n\n\t\tif and != nil {\n\t\t\tassert.True(t, and(rb1, rb2, rb3).Equals(bigand))\n\t\t}\n\n\t\tif xor != nil {\n\t\t\tassert.True(t, xor(rb1, rb2, rb3).Equals(bigxor))\n\t\t}\n\t})\n\n\tt.Run(\"advanced case with runs\", func(t *testing.T) {\n\t\trb1 := NewBitmap()\n\t\trb2 := NewBitmap()\n\t\trb3 := NewBitmap()\n\t\tfor i := uint32(500); i < 75000; i++ {\n\t\t\trb1.Add(i)\n\t\t}\n\t\tfor i := uint32(0); i < 1000000; i += 7 {\n\t\t\trb2.Add(i)\n\t\t}\n\t\tfor i := uint32(0); i < 1000000; i += 1001 {\n\t\t\trb3.Add(i)\n\t\t}\n\t\tfor i := uint32(1000000); i < 2000000; i += 1001 {\n\t\t\trb1.Add(i)\n\t\t}\n\t\tfor i := uint32(1000000); i < 2000000; i += 3 {\n\t\t\trb2.Add(i)\n\t\t}\n\t\tfor i := uint32(1000000); i < 2000000; i += 7 {\n\t\t\trb3.Add(i)\n\t\t}\n\t\trb1.RunOptimize()\n\n\t\trb1.Or(rb2)\n\t\trb1.Or(rb3)\n\t\tbigand := And(And(rb1, rb2), rb3)\n\t\tbigxor := Xor(Xor(rb1, rb2), rb3)\n\t\tcheckValidity(t, bigand)\n\t\tcheckValidity(t, bigxor)\n\t\tif or != nil {\n\t\t\tassert.True(t, or(rb1, rb2, rb3).Equals(rb1))\n\t\t}\n\n\t\tif and != nil {\n\t\t\tassert.True(t, and(rb1, rb2, rb3).Equals(bigand))\n\t\t}\n\n\t\tif xor != nil {\n\t\t\tassert.True(t, xor(rb1, rb2, rb3).Equals(bigxor))\n\t\t}\n\t})\n\n\tt.Run(\"issue 178\", func(t *testing.T) {\n\t\tba1 := []uint32{3585028, 65901253, 143441994, 211160474, 286511937, 356744840, 434332509, 502812785, 576097614, 646557334, 714794241, 775083485, 833704249, 889329147, 941367043}\n\t\tba2 := []uint32{17883, 54494426, 113908938, 174519827, 235465665, 296685741, 357644666, 420192495, 476104304, 523046142, 577855081, 634889665, 692460635, 751350463, 809989192, 863494316, 919127240}\n\n\t\tr1 := BitmapOf(ba1...)\n\t\tr2 := BitmapOf(ba2...)\n\n\t\tassertAggregation(t, 32, or, r1, r2)\n\t})\n}\n\nfunc assertAggregation(t *testing.T, expected uint64, aggr func(bitmaps ...*Bitmap) *Bitmap, bitmaps ...*Bitmap) {\n\tif aggr != nil {\n\t\tassert.Equal(t, aggr(bitmaps...).GetCardinality(), expected)\n\t}\n}\n\nfunc TestParAggregations(t *testing.T) {\n\tfor _, p := range [...]int{1, 2, 4} {\n\t\tandFunc := func(bitmaps ...*Bitmap) *Bitmap {\n\t\t\treturn ParAnd(p, bitmaps...)\n\t\t}\n\t\torFunc := func(bitmaps ...*Bitmap) *Bitmap {\n\t\t\treturn ParOr(p, bitmaps...)\n\t\t}\n\n\t\tt.Run(fmt.Sprintf(\"par%d\", p), func(t *testing.T) {\n\t\t\ttestAggregations(t, andFunc, orFunc, nil)\n\t\t})\n\t}\n}\n\nfunc TestParHeapAggregations(t *testing.T) {\n\torFunc := func(bitmaps ...*Bitmap) *Bitmap {\n\t\treturn ParHeapOr(0, bitmaps...)\n\t}\n\n\ttestAggregations(t, nil, orFunc, nil)\n}\n\nfunc TestFastAggregations(t *testing.T) {\n\ttestAggregations(t, FastAnd, FastOr, nil)\n}\n\nfunc TestHeapAggregations(t *testing.T) {\n\ttestAggregations(t, nil, HeapOr, HeapXor)\n}\n\ntype uints []uint32\n\nfunc (u uints) Len() int { return len(u) }\n\nfunc (u uints) Less(i, j int) bool { return u[i] < u[j] }\n\nfunc (u uints) Swap(i, j int) {\n\tu[i], u[j] = u[j], u[i]\n}\n\nfunc TestIssue330(t *testing.T) {\n\tvar values = [][]uint32{\n\t\t{1448147, 1331557, 1166809, 1404655, 1404657, 1448993, 1448994, 1555026, 1568981, 1166795, 1578735, 1456755, 1581128, 1166754, 1357064, 1166799, 1581142, 1166774, 1549034, 1090425, 1061936, 1581118, 1568668, 1456470, 1396063, 1597976, 1458021, 1344102, 1428259, 1166742, 1332378, 1456750, 1313881, 1371860, 1166770, 1513470, 1456761, 1520695, 1322567, 1456765, 1457788, 1166816, 1432713, 1581004, 1451025, 1166729, 1587500, 1581022, 1166707, 1489623, 1581108, 1547596, 1166727, 1345858, 1166741, 1473887, 1581152, 1581114, 1259737, 1434713, 1456740, 1492705, 1316224, 1448997, 1481940, 1456767, 1467183, 1576718, 1458286, 1475626, 1166785, 1428366, 1303084, 1061926, 1388553, 1453950, 1400529, 1581133, 1166713, 1581166, 1279364, 1322319, 1581027, 1166708, 1442325, 1510314, 1166761, 1404658, 1062733, 1166764, 1431819, 1568982, 1322271, 1427065, 1374050, 1166721, 1166714, 1321056, 1303185, 1329366, 1531398, 1071494, 1476413, 1373526, 1166793, 1404659, 1525886, 1166735, 1593361, 1496990, 1166748, 1366912, 1541272, 1166697, 1432913, 1559279, 1456736, 1315451, 1365178, 1068808, 1166768, 1581107, 1345349, 1166792, 1316413, 1449633, 1456758, 1567180, 1448998, 1423954, 1458607, 1480406, 1493217, 1469065, 1581164, 1581024, 1486803, 1550949, 1166803, 1166783, 1072253, 1499822, 1166724, 1559280, 1166732, 1488319, 1166796, 1062666, 1581165, 1507483, 1544041, 1483167, 1315400, 1166762, 1404660, 1581156, 1166786, 1499824, 1340819, 1166775, 1166710, 1473917, 1525946, 1166722, 1457787, 1166752, 1581158, 1500566, 1166736, 1581005, 1525788, 1166700, 1166720, 1341004, 1356523, 1259716, 1166815, 1166734, 1456734, 1393359, 1315351, 1166808, 1589134, 1166749, 1405717, 1386258, 1166733, 1166738, 1316508, 1510168, 1434714, 1341261, 1499823, 1166728, 1089511, 1166790, 1564869, 1316551, 1356413, 1401448, 1166703, 1456762, 1473571, 1405729, 1340780, 1263511, 1464349, 1166810, 1314421, 1519020, 1581006, 1514759, 1468171, 1320091, 1522288, 1456753, 1568393, 1581110, 1530461, 1456744, 1166750, 1518612, 1448325, 1314799, 1166696, 1166813, 1316622, 1489636, 1456741, 1166699, 1529489, 1481939, 1347707, 1448995, 1320330, 1466667, 1166739, 1166787, 1581009, 1323304, 1428380, 1456752, 1450469, 1496415, 1438461, 1450731, 1529496, 1166731, 1581141, 1581103, 1166706, 1064607, 1587650, 1474681, 1064608, 1166756, 1581015, 1573170, 1166801, 1581130, 1549033, 1166694, 1166800, 1593359, 1581155, 1540878, 1599952, 1538583, 1060736, 1166771, 1166711, 1166791, 1475206, 1166755, 1166798, 1455255, 1456751, 1464345, 1370294, 1401160, 1530295, 1573169, 1166804, 1061935, 1090681, 1349316, 1447675, 1449634, 1558271, 1581113, 1587248, 1540108, 1460873, 1562278, 1166788, 1530457, 1493594, 1456754, 1166753, 1320442, 1581153, 1166758, 1166737, 1322566, 1588195, 1166746, 1166777, 1492640, 1322682, 1166698, 1528367, 1445599, 1581026, 1166751, 1445781, 1319119, 1354380, 1581143, 1460447, 1166797, 1500720, 1369579, 1166806, 1581147, 1464393, 1492632, 1166780, 1448996, 1166712, 1593362, 1581151, 1166807, 1478408, 1322672, 1581137, 1581002, 1456764, 1405048, 1166766, 1063491, 1166811, 1296758, 1384972, 1314177, 1166730, 1066109, 1514764, 1567450, 1581119, 1573634, 1415662, 1563521, 1059518, 1456738, 1581157, 1550678, 1166726, 1166719, 1581013, 1495998, 1371312, 1584782, 1456471, 1166778, 1458759, 1060733, 1166784, 1581028, 1166781, 1583260, 1522601, 1491470, 1166717, 1319114, 1541228, 1456756, 1448992, 1166744, 1549031, 1570164, 1489634, 1370005, 1475624, 1514141, 1475625, 1525883, 1166817, 1166759, 1488332, 1313675, 1259957, 1581011, 1166725, 1483313, 1417102, 1166740, 1260680, 1166779, 1581134, 1315627, 1430811, 1525947, 1166763, 1435903, 1389401, 1351767, 1343593, 1537920, 1480377, 1520699, 1319223, 1581148, 1589060, 1060735, 1468871, 1087817, 1259068, 1581146, 1456759, 1404656, 1166776, 1166695, 1324844, 1589473, 1374167, 1166769, 1166789, 1456871, 1477673, 1166805, 1581106, 1379727, 1166723, 1166767, 1166745, 1313278, 1581124, 1451652, 1405710, 1408256, 1360274, 1325001, 1581136, 1166718, 1072246, 1410198, 1456746, 1557149, 1166760, 1308054, 1581159, 1581131, 1467536, 1166757, 1434322, 1541831, 1418436, 1574603, 1437326, 1166814, 1584856, 1388750, 1166743, 1372695, 1593360, 1166765, 1166794, 1474005, 1166782, 1456748, 1539639, 1056239, 1166802, 1166747, 1210989},\n\t\t{1332290, 1447737, 1549291, 1187244, 1598129, 1579851, 1424171, 1538999, 1445358, 1586739, 1575050, 1437657, 1366343, 1062799, 1421550, 1460317, 1474875, 1060737, 1330773, 1447797, 1348633, 1559437, 1556214, 1187305, 1187234, 1187240, 1464660, 1567794, 1187260, 1260646, 1311938, 1573195, 1318525, 1484524, 1456152, 1087954, 1556007, 1187265, 1460920, 1485316, 1447849, 1447744, 1474001, 1537891, 1478211, 1313292, 1488405, 1187239, 1378814, 1343620, 1500498, 1567809, 1435838, 1506575, 1368282, 1447441, 1598101, 1067076, 1572997, 1598102, 1332697, 1324653, 1561437, 1187290, 1059945, 1187278, 1457187, 1430003, 1450643, 1447436, 1260650, 1473393, 1187247, 1087323, 1324967, 1187291, 1480771, 1472729, 1555881, 1187253, 1456481, 1452672, 1447435, 1378603, 1574771, 1187235, 1417857, 1568706, 1576739, 1534662, 1410189, 1587745, 1473791, 1187308, 1447730, 1328158, 1409164, 1506591, 1500147, 1433961, 1483709, 1187227, 1456479, 1562595, 1314333, 1187281, 1598012, 1415200, 1447791, 1371379, 1598019, 1435836, 1457188, 1457351, 1187248, 1417111, 1187289, 1187252, 1187257, 1316665, 1473464, 1187263, 1447732, 1520371, 1525651, 1598177, 1406947, 1465787, 1524659, 1324213, 1418439, 1575816, 1522696, 1187286, 1497821, 1333179, 1187282, 1335988, 1548952, 1556066, 1314993, 1187276, 1420503, 1187301, 1456468, 1423939, 1598089, 1504357, 1343247, 1437659, 1525768, 1539279, 1307385, 1187275, 1524305, 1332938, 1516498, 1303247, 1304237, 1187238, 1385283, 1595495, 1187300, 1187241, 1061740, 1316383, 1187307, 1062037, 1538693, 1454292, 1447731, 1187272, 1561442, 1187268, 1567150, 1597966, 1447745, 1598178, 1187262, 1464067, 1325394, 1537893, 1332693, 1479200, 1522335, 1589378, 1450573, 1399161, 1421274, 1561501, 1187232, 1187302, 1258469, 1331600, 1447740, 1187242, 1328147, 1264069, 1187294, 1299943, 1598013, 1526975, 1260604, 1487518, 1187229, 1487617, 1354087, 1456595, 1462047, 1561438, 1598363, 1332691, 1424655, 1567105, 1574774, 1598035, 1526981, 1384038, 1475987, 1343587, 1447437, 1454912, 1382215, 1447739, 1456512, 1447779, 1187283, 1440988, 1187293, 1187298, 1574754, 1354772, 1598018, 1447429, 1598181, 1447738, 1598273, 1312197, 1574752, 1572995, 1526127, 1473908, 1437660, 1447743, 1362262, 1456513, 1539280, 1348625, 1415878, 1332694, 1471020, 1432462, 1058088, 1526710, 1371788, 1187288, 1537984, 1316874, 1187270, 1333565, 1187292, 1447796, 1187311, 1187237, 1187231, 1574755, 1553822, 1522019, 1447418, 1187269, 1332692, 1447735, 1529638, 1468154, 1328031, 1447733, 1447402, 1593884, 1332696, 1560622, 1564819, 1538967, 1315756, 1328338, 1598113, 1324212, 1449895, 1567793, 1260629, 1430010, 1187266, 1187256, 1312754, 1449417, 1595494, 1529054, 1187261, 1187306, 1526976, 1425490, 1366922, 1527390, 1187299, 1561510, 1319222, 1187250, 1057262, 1457999, 1332937, 1187243, 1556213, 1278602, 1546839, 1187296, 1548950, 1580141, 1187303, 1187255, 1525650, 1572998, 1576740, 1187267, 1464664, 1440427, 1456467, 1187271, 1187258, 1585428, 1548760, 1342254, 1447793, 1406348, 1500177, 1260644, 1416954, 1323722, 1412713, 1187280, 1187310, 1538015, 1537285, 1187285, 1456482, 1260611, 1490508, 1187274, 1585641, 1416648, 1484655, 1421520, 1347485, 1525652, 1568987, 1526974, 1314375, 1187246, 1455623, 1488117, 1445025, 1447401, 1478237, 1561440, 1187287, 1561434, 1509337, 1451859, 1599630, 1348639, 1449436, 1361844, 1464661, 1263064, 1526973, 1187279, 1562080, 1354770, 1454521, 1520719, 1478236, 1526972, 1423948, 1334866, 1325026, 1438275, 1422582, 1437646, 1315530, 1458323, 1447795, 1528218, 1187254, 1598056, 1417853, 1423514, 1187297, 1187245, 1187264, 1524662, 1187251, 1524660, 1328113, 1187304, 1374767, 1474057, 1187284, 1331601, 1598180, 1062814, 1488818, 1187309, 1087494, 1063499, 1458325, 1187295, 1432336, 1260001, 1597982, 1537147, 1445355, 1595491, 1396111, 1546848, 1474048, 1495251, 1447734, 1464071, 1526978, 1187236, 1526977, 1566267, 1187277, 1421549, 1430015, 1316024, 1332695, 1561433, 1435837, 1087250, 1574753, 1476183, 1325395, 1561432, 1447736, 1500181, 1424164, 1456483, 1187228, 1573384, 1273769, 1598085, 1437661, 1306415, 1407257, 1187249, 1338215, 1458047, 1520791, 1447741, 1537263, 1472490, 1524661, 1061729, 1187273, 1417861, 1470196, 1485881, 1260595, 1538846, 1568762, 1315170, 1500469, 1372455, 1558140, 1425202, 1432702, 1472734, 1187230, 1187312, 1598191, 1569680, 1187233, 1263091, 1447417, 1504429, 1430016, 1435839, 1458324, 1546845, 1575027, 1187259, 1464610},\n\t\t{1578810, 1166701, 1335901, 1063397, 1578812, 1526471, 1166702, 1067008, 1412862, 1059750, 1060729, 1166812, 1493768, 1335772, 1336194, 1166772, 1465775, 1166704, 1355314, 1314138, 1060727, 1388260, 1465786, 1565378, 1522096, 1312490, 1319284, 1418573, 1319169, 1060730, 1307995, 1465780, 1060728, 1404061, 1407842, 1326256, 1578754, 1410577, 1060732, 1461338, 1264209, 1166705, 1581273, 1414196, 1565398, 1355106, 1060731, 1412641, 1306618, 1060726, 1356302, 1310896, 1457885, 1497721, 1166709, 1067009, 1310812, 1578800, 1422203, 1484409, 1485278, 1322057, 1369956, 1311089, 1576614, 1355711, 1355798, 1564832, 1304166, 1166773, 1319071, 1578805, 1575869, 1403066},\n\t}\n\n\tbitmaps := []*Bitmap{}\n\n\tfor _, v := range values {\n\t\tbitmap := BitmapOf(v...)\n\t\tbitmap.RunOptimize()\n\t\tbitmaps = append(bitmaps, bitmap)\n\t\tarrayResult := bitmap.ToArray()\n\t\tsort.Sort(uints(v))\n\t\tassert.Equal(t, arrayResult, v)\n\t}\n\tassert.Equal(t, FastAnd(bitmaps[0], bitmaps[1]).GetCardinality(), uint64(0))\n\tassert.Equal(t, FastAnd(bitmaps[0], bitmaps[2]).GetCardinality(), uint64(0))\n\tassert.Equal(t, FastAnd(bitmaps[1], bitmaps[2]).GetCardinality(), uint64(0))\n\tassert.Equal(t, FastOr(bitmaps[0], bitmaps[1], bitmaps[2]).GetCardinality(), uint64(1040))\n\tassert.Equal(t, FastOr(bitmaps[2], bitmaps[1], bitmaps[0]).GetCardinality(), uint64(1040))\n\tagg012 := Or(bitmaps[0], bitmaps[1])\n\tagg012.Or(bitmaps[2])\n\tagg210 := Or(bitmaps[2], bitmaps[1])\n\tagg210.Or(bitmaps[0])\n\tassert.Equal(t, agg012.GetCardinality(), uint64(1040))\n\tassert.Equal(t, agg210.GetCardinality(), uint64(1040))\n\tassert.True(t, agg210.Equals(agg012))\n\tcheckValidity(t, agg210)\n\tcheckValidity(t, agg012)\n\tcheckValidity(t, FastOr(bitmaps[0], bitmaps[1], bitmaps[2]))\n\tcheckValidity(t, FastOr(bitmaps[2], bitmaps[1], bitmaps[0]))\n}\n"
        },
        {
          "name": "arraycontainer.go",
          "type": "blob",
          "size": 33.16796875,
          "content": "package roaring\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n)\n\ntype arrayContainer struct {\n\tcontent []uint16\n}\n\nvar (\n\tErrArrayIncorrectSort = errors.New(\"incorrectly sorted array\")\n\tErrArrayInvalidSize   = errors.New(\"invalid array size\")\n)\n\nfunc (ac *arrayContainer) String() string {\n\ts := \"{\"\n\tfor it := ac.getShortIterator(); it.hasNext(); {\n\t\ts += fmt.Sprintf(\"%v, \", it.next())\n\t}\n\treturn s + \"}\"\n}\n\nfunc (ac *arrayContainer) fillLeastSignificant16bits(x []uint32, i int, mask uint32) int {\n\tif i < 0 {\n\t\tpanic(\"negative index\")\n\t}\n\tif len(ac.content) == 0 {\n\t\treturn i\n\t}\n\t_ = x[len(ac.content)-1+i]\n\t_ = ac.content[len(ac.content)-1]\n\tfor k := 0; k < len(ac.content); k++ {\n\t\tx[k+i] = uint32(ac.content[k]) | mask\n\t}\n\treturn i + len(ac.content)\n}\n\nfunc (ac *arrayContainer) iterate(cb func(x uint16) bool) bool {\n\titerator := shortIterator{ac.content, 0}\n\n\tfor iterator.hasNext() {\n\t\tif !cb(iterator.next()) {\n\t\t\treturn false\n\t\t}\n\t}\n\n\treturn true\n}\n\nfunc (ac *arrayContainer) getShortIterator() shortPeekable {\n\treturn &shortIterator{ac.content, 0}\n}\n\nfunc (ac *arrayContainer) getReverseIterator() shortIterable {\n\treturn &reverseIterator{ac.content, len(ac.content) - 1}\n}\n\nfunc (ac *arrayContainer) getManyIterator() manyIterable {\n\treturn &shortIterator{ac.content, 0}\n}\n\nfunc (ac *arrayContainer) minimum() uint16 {\n\treturn ac.content[0] // assume not empty\n}\n\nfunc (ac *arrayContainer) safeMinimum() (uint16, error) {\n\tif len(ac.content) == 0 {\n\t\treturn 0, errors.New(\"empty array\")\n\t}\n\n\treturn ac.minimum(), nil\n}\n\nfunc (ac *arrayContainer) maximum() uint16 {\n\treturn ac.content[len(ac.content)-1] // assume not empty\n}\n\nfunc (ac *arrayContainer) safeMaximum() (uint16, error) {\n\tif len(ac.content) == 0 {\n\t\treturn 0, errors.New(\"empty array\")\n\t}\n\n\treturn ac.maximum(), nil\n}\n\nfunc (ac *arrayContainer) getSizeInBytes() int {\n\treturn ac.getCardinality() * 2\n}\n\nfunc (ac *arrayContainer) serializedSizeInBytes() int {\n\treturn ac.getCardinality() * 2\n}\n\nfunc arrayContainerSizeInBytes(card int) int {\n\treturn card * 2\n}\n\n// add the values in the range [firstOfRange,endx)\nfunc (ac *arrayContainer) iaddRange(firstOfRange, endx int) container {\n\tif firstOfRange >= endx {\n\t\treturn ac\n\t}\n\tindexstart := binarySearch(ac.content, uint16(firstOfRange))\n\tif indexstart < 0 {\n\t\tindexstart = -indexstart - 1\n\t}\n\tindexend := binarySearch(ac.content, uint16(endx-1))\n\tif indexend < 0 {\n\t\tindexend = -indexend - 1\n\t} else {\n\t\tindexend++\n\t}\n\trangelength := endx - firstOfRange\n\tnewcardinality := indexstart + (ac.getCardinality() - indexend) + rangelength\n\tif newcardinality > arrayDefaultMaxSize {\n\t\ta := ac.toBitmapContainer()\n\t\treturn a.iaddRange(firstOfRange, endx)\n\t}\n\tif cap(ac.content) < newcardinality {\n\t\ttmp := make([]uint16, newcardinality, newcardinality)\n\t\tcopy(tmp[:indexstart], ac.content[:indexstart])\n\t\tcopy(tmp[indexstart+rangelength:], ac.content[indexend:])\n\n\t\tac.content = tmp\n\t} else {\n\t\tac.content = ac.content[:newcardinality]\n\t\tcopy(ac.content[indexstart+rangelength:], ac.content[indexend:])\n\n\t}\n\tfor k := 0; k < rangelength; k++ {\n\t\tac.content[k+indexstart] = uint16(firstOfRange + k)\n\t}\n\treturn ac\n}\n\n// remove the values in the range [firstOfRange,endx)\nfunc (ac *arrayContainer) iremoveRange(firstOfRange, endx int) container {\n\tif firstOfRange >= endx {\n\t\treturn ac\n\t}\n\tindexstart := binarySearch(ac.content, uint16(firstOfRange))\n\tif indexstart < 0 {\n\t\tindexstart = -indexstart - 1\n\t}\n\tindexend := binarySearch(ac.content, uint16(endx-1))\n\tif indexend < 0 {\n\t\tindexend = -indexend - 1\n\t} else {\n\t\tindexend++\n\t}\n\trangelength := indexend - indexstart\n\tanswer := ac\n\tcopy(answer.content[indexstart:], ac.content[indexstart+rangelength:])\n\tanswer.content = answer.content[:ac.getCardinality()-rangelength]\n\treturn answer\n}\n\n// flip the values in the range [firstOfRange,endx)\nfunc (ac *arrayContainer) not(firstOfRange, endx int) container {\n\tif firstOfRange >= endx {\n\t\treturn ac.clone()\n\t}\n\treturn ac.notClose(firstOfRange, endx-1) // remove everything in [firstOfRange,endx-1]\n}\n\n// flip the values in the range [firstOfRange,lastOfRange]\nfunc (ac *arrayContainer) notClose(firstOfRange, lastOfRange int) container {\n\tif firstOfRange > lastOfRange { // unlike add and remove, not uses an inclusive range [firstOfRange,lastOfRange]\n\t\treturn ac.clone()\n\t}\n\n\t// determine the span of array indices to be affected^M\n\tstartIndex := binarySearch(ac.content, uint16(firstOfRange))\n\tif startIndex < 0 {\n\t\tstartIndex = -startIndex - 1\n\t}\n\tlastIndex := binarySearch(ac.content, uint16(lastOfRange))\n\tif lastIndex < 0 {\n\t\tlastIndex = -lastIndex - 2\n\t}\n\tcurrentValuesInRange := lastIndex - startIndex + 1\n\tspanToBeFlipped := lastOfRange - firstOfRange + 1\n\tnewValuesInRange := spanToBeFlipped - currentValuesInRange\n\tcardinalityChange := newValuesInRange - currentValuesInRange\n\tnewCardinality := len(ac.content) + cardinalityChange\n\tif newCardinality > arrayDefaultMaxSize {\n\t\treturn ac.toBitmapContainer().not(firstOfRange, lastOfRange+1)\n\t}\n\tanswer := newArrayContainer()\n\tanswer.content = make([]uint16, newCardinality, newCardinality) // a hack for sure\n\n\tcopy(answer.content, ac.content[:startIndex])\n\toutPos := startIndex\n\tinPos := startIndex\n\tvalInRange := firstOfRange\n\tfor ; valInRange <= lastOfRange && inPos <= lastIndex; valInRange++ {\n\t\tif uint16(valInRange) != ac.content[inPos] {\n\t\t\tanswer.content[outPos] = uint16(valInRange)\n\t\t\toutPos++\n\t\t} else {\n\t\t\tinPos++\n\t\t}\n\t}\n\n\tfor ; valInRange <= lastOfRange; valInRange++ {\n\t\tanswer.content[outPos] = uint16(valInRange)\n\t\toutPos++\n\t}\n\n\tfor i := lastIndex + 1; i < len(ac.content); i++ {\n\t\tanswer.content[outPos] = ac.content[i]\n\t\toutPos++\n\t}\n\tanswer.content = answer.content[:newCardinality]\n\treturn answer\n}\n\nfunc (ac *arrayContainer) equals(o container) bool {\n\tsrb, ok := o.(*arrayContainer)\n\tif ok {\n\t\t// Check if the containers are the same object.\n\t\tif ac == srb {\n\t\t\treturn true\n\t\t}\n\n\t\tif len(srb.content) != len(ac.content) {\n\t\t\treturn false\n\t\t}\n\n\t\tfor i, v := range ac.content {\n\t\t\tif v != srb.content[i] {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\t}\n\n\t// use generic comparison\n\tbCard := o.getCardinality()\n\taCard := ac.getCardinality()\n\tif bCard != aCard {\n\t\treturn false\n\t}\n\n\tait := ac.getShortIterator()\n\tbit := o.getShortIterator()\n\tfor ait.hasNext() {\n\t\tif bit.next() != ait.next() {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\nfunc (ac *arrayContainer) toBitmapContainer() *bitmapContainer {\n\tbc := newBitmapContainer()\n\tbc.loadData(ac)\n\treturn bc\n}\n\nfunc (ac *arrayContainer) iadd(x uint16) (wasNew bool) {\n\t// Special case adding to the end of the container.\n\tl := len(ac.content)\n\tif l > 0 && l < arrayDefaultMaxSize && ac.content[l-1] < x {\n\t\tac.content = append(ac.content, x)\n\t\treturn true\n\t}\n\n\tloc := binarySearch(ac.content, x)\n\n\tif loc < 0 {\n\t\ts := ac.content\n\t\ti := -loc - 1\n\t\ts = append(s, 0)\n\t\tcopy(s[i+1:], s[i:])\n\t\ts[i] = x\n\t\tac.content = s\n\t\treturn true\n\t}\n\treturn false\n}\n\nfunc (ac *arrayContainer) iaddReturnMinimized(x uint16) container {\n\t// Special case adding to the end of the container.\n\tl := len(ac.content)\n\tif l > 0 && l < arrayDefaultMaxSize && ac.content[l-1] < x {\n\t\tac.content = append(ac.content, x)\n\t\treturn ac\n\t}\n\n\tloc := binarySearch(ac.content, x)\n\n\tif loc < 0 {\n\t\tif len(ac.content) >= arrayDefaultMaxSize {\n\t\t\ta := ac.toBitmapContainer()\n\t\t\ta.iadd(x)\n\t\t\treturn a\n\t\t}\n\t\ts := ac.content\n\t\ti := -loc - 1\n\t\ts = append(s, 0)\n\t\tcopy(s[i+1:], s[i:])\n\t\ts[i] = x\n\t\tac.content = s\n\t}\n\treturn ac\n}\n\n// iremoveReturnMinimized is allowed to change the return type to minimize storage.\nfunc (ac *arrayContainer) iremoveReturnMinimized(x uint16) container {\n\tac.iremove(x)\n\treturn ac\n}\n\nfunc (ac *arrayContainer) iremove(x uint16) bool {\n\tloc := binarySearch(ac.content, x)\n\tif loc >= 0 {\n\t\ts := ac.content\n\t\ts = append(s[:loc], s[loc+1:]...)\n\t\tac.content = s\n\t\treturn true\n\t}\n\treturn false\n}\n\nfunc (ac *arrayContainer) remove(x uint16) container {\n\tout := &arrayContainer{make([]uint16, len(ac.content))}\n\tcopy(out.content, ac.content[:])\n\n\tloc := binarySearch(out.content, x)\n\tif loc >= 0 {\n\t\ts := out.content\n\t\ts = append(s[:loc], s[loc+1:]...)\n\t\tout.content = s\n\t}\n\treturn out\n}\n\nfunc (ac *arrayContainer) or(a container) container {\n\tswitch x := a.(type) {\n\tcase *arrayContainer:\n\t\treturn ac.orArray(x)\n\tcase *bitmapContainer:\n\t\treturn x.orArray(ac)\n\tcase *runContainer16:\n\t\tif x.isFull() {\n\t\t\treturn x.clone()\n\t\t}\n\t\treturn x.orArray(ac)\n\t}\n\tpanic(\"unsupported container type\")\n}\n\nfunc (ac *arrayContainer) orCardinality(a container) int {\n\tswitch x := a.(type) {\n\tcase *arrayContainer:\n\t\treturn ac.orArrayCardinality(x)\n\tcase *bitmapContainer:\n\t\treturn x.orArrayCardinality(ac)\n\tcase *runContainer16:\n\t\treturn x.orArrayCardinality(ac)\n\t}\n\tpanic(\"unsupported container type\")\n}\n\nfunc (ac *arrayContainer) ior(a container) container {\n\tswitch x := a.(type) {\n\tcase *arrayContainer:\n\t\treturn ac.iorArray(x)\n\tcase *bitmapContainer:\n\t\treturn a.(*bitmapContainer).orArray(ac)\n\tcase *runContainer16:\n\t\tif x.isFull() {\n\t\t\treturn x.clone()\n\t\t}\n\t\treturn ac.iorRun16(x)\n\t}\n\tpanic(\"unsupported container type\")\n}\n\nfunc (ac *arrayContainer) iorArray(value2 *arrayContainer) container {\n\tvalue1 := ac\n\tlen1 := value1.getCardinality()\n\tlen2 := value2.getCardinality()\n\tmaxPossibleCardinality := len1 + len2\n\tif maxPossibleCardinality > cap(value1.content) {\n\t\t// doubling the capacity reduces new slice allocations in the case of\n\t\t// repeated calls to iorArray().\n\t\tnewSize := 2 * maxPossibleCardinality\n\t\t// the second check is to handle overly large array containers\n\t\t// and should not occur in normal usage,\n\t\t// as all array containers should be at most arrayDefaultMaxSize\n\t\tif newSize > 2*arrayDefaultMaxSize && maxPossibleCardinality <= 2*arrayDefaultMaxSize {\n\t\t\tnewSize = 2 * arrayDefaultMaxSize\n\t\t}\n\t\tnewcontent := make([]uint16, 0, newSize)\n\t\tcopy(newcontent[len2:maxPossibleCardinality], ac.content[0:len1])\n\t\tac.content = newcontent\n\t} else {\n\t\tcopy(ac.content[len2:maxPossibleCardinality], ac.content[0:len1])\n\t}\n\tnl := union2by2(value1.content[len2:maxPossibleCardinality], value2.content, ac.content)\n\tac.content = ac.content[:nl] // reslice to match actual used capacity\n\n\tif nl > arrayDefaultMaxSize {\n\t\t// Only converting to a bitmap when arrayDefaultMaxSize\n\t\t// is actually exceeded minimizes conversions in the case of repeated\n\t\t// calls to iorArray().\n\t\treturn ac.toBitmapContainer()\n\t}\n\treturn ac\n}\n\n// Note: such code does not make practical sense, except for lazy evaluations\nfunc (ac *arrayContainer) iorBitmap(bc2 *bitmapContainer) container {\n\tbc1 := ac.toBitmapContainer()\n\tbc1.iorBitmap(bc2)\n\t*ac = *newArrayContainerFromBitmap(bc1)\n\treturn ac\n}\n\nfunc (ac *arrayContainer) iorRun16(rc *runContainer16) container {\n\trunCardinality := rc.getCardinality()\n\t// heuristic for if the container should maybe be an\n\t// array container.\n\tif runCardinality < ac.getCardinality() &&\n\t\trunCardinality+ac.getCardinality() < arrayDefaultMaxSize {\n\t\tvar result container\n\t\tresult = ac\n\t\tfor _, run := range rc.iv {\n\t\t\tresult = result.iaddRange(int(run.start), int(run.start)+int(run.length)+1)\n\t\t}\n\t\treturn result\n\t}\n\treturn rc.orArray(ac)\n}\n\nfunc (ac *arrayContainer) lazyIOR(a container) container {\n\tswitch x := a.(type) {\n\tcase *arrayContainer:\n\t\treturn ac.lazyIorArray(x)\n\tcase *bitmapContainer:\n\t\treturn ac.lazyIorBitmap(x)\n\tcase *runContainer16:\n\t\tif x.isFull() {\n\t\t\treturn x.clone()\n\t\t}\n\t\treturn ac.lazyIorRun16(x)\n\n\t}\n\tpanic(\"unsupported container type\")\n}\n\nfunc (ac *arrayContainer) lazyIorArray(ac2 *arrayContainer) container {\n\t// TODO actually make this lazy\n\treturn ac.iorArray(ac2)\n}\n\nfunc (ac *arrayContainer) lazyIorBitmap(bc *bitmapContainer) container {\n\t// TODO actually make this lazy\n\treturn ac.iorBitmap(bc)\n}\n\nfunc (ac *arrayContainer) lazyIorRun16(rc *runContainer16) container {\n\t// TODO actually make this lazy\n\treturn ac.iorRun16(rc)\n}\n\nfunc (ac *arrayContainer) lazyOR(a container) container {\n\tswitch x := a.(type) {\n\tcase *arrayContainer:\n\t\treturn ac.lazyorArray(x)\n\tcase *bitmapContainer:\n\t\treturn a.lazyOR(ac)\n\tcase *runContainer16:\n\t\tif x.isFull() {\n\t\t\treturn x.clone()\n\t\t}\n\t\treturn x.orArray(ac)\n\t}\n\tpanic(\"unsupported container type\")\n}\n\nfunc (ac *arrayContainer) orArray(value2 *arrayContainer) container {\n\tvalue1 := ac\n\tmaxPossibleCardinality := value1.getCardinality() + value2.getCardinality()\n\tif maxPossibleCardinality > arrayDefaultMaxSize { // it could be a bitmap!\n\t\tbc := newBitmapContainer()\n\t\tfor k := 0; k < len(value2.content); k++ {\n\t\t\tv := value2.content[k]\n\t\t\ti := uint(v) >> 6\n\t\t\tmask := uint64(1) << (v % 64)\n\t\t\tbc.bitmap[i] |= mask\n\t\t}\n\t\tfor k := 0; k < len(ac.content); k++ {\n\t\t\tv := ac.content[k]\n\t\t\ti := uint(v) >> 6\n\t\t\tmask := uint64(1) << (v % 64)\n\t\t\tbc.bitmap[i] |= mask\n\t\t}\n\t\tbc.cardinality = int(popcntSlice(bc.bitmap))\n\t\tif bc.cardinality <= arrayDefaultMaxSize {\n\t\t\treturn bc.toArrayContainer()\n\t\t}\n\t\treturn bc\n\t}\n\tanswer := newArrayContainerCapacity(maxPossibleCardinality)\n\tnl := union2by2(value1.content, value2.content, answer.content)\n\tanswer.content = answer.content[:nl] // reslice to match actual used capacity\n\treturn answer\n}\n\nfunc (ac *arrayContainer) orArrayCardinality(value2 *arrayContainer) int {\n\treturn union2by2Cardinality(ac.content, value2.content)\n}\n\nfunc (ac *arrayContainer) lazyorArray(value2 *arrayContainer) container {\n\tvalue1 := ac\n\tmaxPossibleCardinality := value1.getCardinality() + value2.getCardinality()\n\tif maxPossibleCardinality > arrayLazyLowerBound { // it could be a bitmap!\n\t\tbc := newBitmapContainer()\n\t\tfor k := 0; k < len(value2.content); k++ {\n\t\t\tv := value2.content[k]\n\t\t\ti := uint(v) >> 6\n\t\t\tmask := uint64(1) << (v % 64)\n\t\t\tbc.bitmap[i] |= mask\n\t\t}\n\t\tfor k := 0; k < len(ac.content); k++ {\n\t\t\tv := ac.content[k]\n\t\t\ti := uint(v) >> 6\n\t\t\tmask := uint64(1) << (v % 64)\n\t\t\tbc.bitmap[i] |= mask\n\t\t}\n\t\tbc.cardinality = invalidCardinality\n\t\treturn bc\n\t}\n\tanswer := newArrayContainerCapacity(maxPossibleCardinality)\n\tnl := union2by2(value1.content, value2.content, answer.content)\n\tanswer.content = answer.content[:nl] // reslice to match actual used capacity\n\treturn answer\n}\n\nfunc (ac *arrayContainer) and(a container) container {\n\tswitch x := a.(type) {\n\tcase *arrayContainer:\n\t\treturn ac.andArray(x)\n\tcase *bitmapContainer:\n\t\treturn x.and(ac)\n\tcase *runContainer16:\n\t\tif x.isFull() {\n\t\t\treturn ac.clone()\n\t\t}\n\t\treturn x.andArray(ac)\n\t}\n\tpanic(\"unsupported container type\")\n}\n\nfunc (ac *arrayContainer) andCardinality(a container) int {\n\tswitch x := a.(type) {\n\tcase *arrayContainer:\n\t\treturn ac.andArrayCardinality(x)\n\tcase *bitmapContainer:\n\t\treturn x.andCardinality(ac)\n\tcase *runContainer16:\n\t\treturn x.andArrayCardinality(ac)\n\t}\n\tpanic(\"unsupported container type\")\n}\n\nfunc (ac *arrayContainer) intersects(a container) bool {\n\tswitch x := a.(type) {\n\tcase *arrayContainer:\n\t\treturn ac.intersectsArray(x)\n\tcase *bitmapContainer:\n\t\treturn x.intersects(ac)\n\tcase *runContainer16:\n\t\treturn x.intersects(ac)\n\t}\n\tpanic(\"unsupported container type\")\n}\n\nfunc (ac *arrayContainer) iand(a container) container {\n\tswitch x := a.(type) {\n\tcase *arrayContainer:\n\t\treturn ac.iandArray(x)\n\tcase *bitmapContainer:\n\t\treturn ac.iandBitmap(x)\n\tcase *runContainer16:\n\t\tif x.isFull() {\n\t\t\treturn ac\n\t\t}\n\t\treturn x.andArray(ac)\n\t}\n\tpanic(\"unsupported container type\")\n}\n\nfunc (ac *arrayContainer) iandBitmap(bc *bitmapContainer) container {\n\tpos := 0\n\tc := ac.getCardinality()\n\tfor k := 0; k < c; k++ {\n\t\t// branchless\n\t\tv := ac.content[k]\n\t\tac.content[pos] = v\n\t\tpos += int(bc.bitValue(v))\n\t}\n\tac.content = ac.content[:pos]\n\treturn ac\n}\n\nfunc (ac *arrayContainer) xor(a container) container {\n\tswitch x := a.(type) {\n\tcase *arrayContainer:\n\t\treturn ac.xorArray(x)\n\tcase *bitmapContainer:\n\t\treturn a.xor(ac)\n\tcase *runContainer16:\n\t\treturn x.xorArray(ac)\n\t}\n\tpanic(\"unsupported container type\")\n}\n\nfunc (ac *arrayContainer) xorArray(value2 *arrayContainer) container {\n\tvalue1 := ac\n\ttotalCardinality := value1.getCardinality() + value2.getCardinality()\n\tif totalCardinality > arrayDefaultMaxSize { // it could be a bitmap!\n\t\tbc := newBitmapContainer()\n\t\tfor k := 0; k < len(value2.content); k++ {\n\t\t\tv := value2.content[k]\n\t\t\ti := uint(v) >> 6\n\t\t\tbc.bitmap[i] ^= (uint64(1) << (v % 64))\n\t\t}\n\t\tfor k := 0; k < len(ac.content); k++ {\n\t\t\tv := ac.content[k]\n\t\t\ti := uint(v) >> 6\n\t\t\tbc.bitmap[i] ^= (uint64(1) << (v % 64))\n\t\t}\n\t\tbc.computeCardinality()\n\t\tif bc.cardinality <= arrayDefaultMaxSize {\n\t\t\treturn bc.toArrayContainer()\n\t\t}\n\t\treturn bc\n\t}\n\tdesiredCapacity := totalCardinality\n\tanswer := newArrayContainerCapacity(desiredCapacity)\n\tlength := exclusiveUnion2by2(value1.content, value2.content, answer.content)\n\tanswer.content = answer.content[:length]\n\treturn answer\n}\n\nfunc (ac *arrayContainer) andNot(a container) container {\n\tswitch x := a.(type) {\n\tcase *arrayContainer:\n\t\treturn ac.andNotArray(x)\n\tcase *bitmapContainer:\n\t\treturn ac.andNotBitmap(x)\n\tcase *runContainer16:\n\t\treturn ac.andNotRun16(x)\n\t}\n\tpanic(\"unsupported container type\")\n}\n\nfunc (ac *arrayContainer) andNotRun16(rc *runContainer16) container {\n\tacb := ac.toBitmapContainer()\n\trcb := rc.toBitmapContainer()\n\treturn acb.andNotBitmap(rcb)\n}\n\nfunc (ac *arrayContainer) iandNot(a container) container {\n\tswitch x := a.(type) {\n\tcase *arrayContainer:\n\t\treturn ac.iandNotArray(x)\n\tcase *bitmapContainer:\n\t\treturn ac.iandNotBitmap(x)\n\tcase *runContainer16:\n\t\treturn ac.iandNotRun16(x)\n\t}\n\tpanic(\"unsupported container type\")\n}\n\nfunc (ac *arrayContainer) iandNotRun16(rc *runContainer16) container {\n\t// Fast path: if either the array container or the run container is empty, the result is the array.\n\tif ac.isEmpty() || rc.isEmpty() {\n\t\t// Empty\n\t\treturn ac\n\t}\n\t// Fast path: if the run container is full, the result is empty.\n\tif rc.isFull() {\n\t\tac.content = ac.content[:0]\n\t\treturn ac\n\t}\n\tcurrent_run := 0\n\t// All values in [start_run, end_end] are part of the run\n\tstart_run := rc.iv[current_run].start\n\tend_end := start_run + rc.iv[current_run].length\n\t// We are going to read values in the array at index i, and we are\n\t// going to write them at index pos. So we do in-place processing.\n\t// We always have that pos <= i by construction. So we can either\n\t// overwrite a value just read, or a value that was previous read.\n\tpos := 0\n\ti := 0\n\tfor ; i < len(ac.content); i++ {\n\t\tif ac.content[i] < start_run {\n\t\t\t// the value in the array appears before the run [start_run, end_end]\n\t\t\tac.content[pos] = ac.content[i]\n\t\t\tpos++\n\t\t} else if ac.content[i] <= end_end {\n\t\t\t// nothing to do, the value is in the array but also in the run.\n\t\t} else {\n\t\t\t// We have the value in the array after the run. We cannot tell\n\t\t\t// whether we need to keep it or not. So let us move to another run.\n\t\t\tif current_run+1 < len(rc.iv) {\n\t\t\t\tcurrent_run++\n\t\t\t\tstart_run = rc.iv[current_run].start\n\t\t\t\tend_end = start_run + rc.iv[current_run].length\n\t\t\t\ti-- // retry with the same i\n\t\t\t} else {\n\t\t\t\t// We have exhausted the number of runs. We can keep the rest of the values\n\t\t\t\t// from i to len(ac.content) - 1 inclusively.\n\t\t\t\tbreak // We are done, the rest of the array will be kept\n\t\t\t}\n\t\t}\n\t}\n\tfor ; i < len(ac.content); i++ {\n\t\tac.content[pos] = ac.content[i]\n\t\tpos++\n\t}\n\t// We 'shink' the slice.\n\tac.content = ac.content[:pos]\n\treturn ac\n}\n\nfunc (ac *arrayContainer) andNotArray(value2 *arrayContainer) container {\n\tvalue1 := ac\n\tdesiredcapacity := value1.getCardinality()\n\tanswer := newArrayContainerCapacity(desiredcapacity)\n\tlength := difference(value1.content, value2.content, answer.content)\n\tanswer.content = answer.content[:length]\n\treturn answer\n}\n\nfunc (ac *arrayContainer) iandNotArray(value2 *arrayContainer) container {\n\tlength := difference(ac.content, value2.content, ac.content)\n\tac.content = ac.content[:length]\n\treturn ac\n}\n\nfunc (ac *arrayContainer) andNotBitmap(value2 *bitmapContainer) container {\n\tdesiredcapacity := ac.getCardinality()\n\tanswer := newArrayContainerCapacity(desiredcapacity)\n\tanswer.content = answer.content[:desiredcapacity]\n\tpos := 0\n\tfor _, v := range ac.content {\n\t\tanswer.content[pos] = v\n\t\tpos += 1 - int(value2.bitValue(v))\n\t}\n\tanswer.content = answer.content[:pos]\n\treturn answer\n}\n\nfunc (ac *arrayContainer) andBitmap(value2 *bitmapContainer) container {\n\tdesiredcapacity := ac.getCardinality()\n\tanswer := newArrayContainerCapacity(desiredcapacity)\n\tanswer.content = answer.content[:desiredcapacity]\n\tpos := 0\n\tfor _, v := range ac.content {\n\t\tanswer.content[pos] = v\n\t\tpos += int(value2.bitValue(v))\n\t}\n\tanswer.content = answer.content[:pos]\n\treturn answer\n}\n\nfunc (ac *arrayContainer) iandNotBitmap(value2 *bitmapContainer) container {\n\tpos := 0\n\tfor _, v := range ac.content {\n\t\tac.content[pos] = v\n\t\tpos += 1 - int(value2.bitValue(v))\n\t}\n\tac.content = ac.content[:pos]\n\treturn ac\n}\n\nfunc copyOf(array []uint16, size int) []uint16 {\n\tresult := make([]uint16, size)\n\tfor i, x := range array {\n\t\tif i == size {\n\t\t\tbreak\n\t\t}\n\t\tresult[i] = x\n\t}\n\treturn result\n}\n\n// flip the values in the range [firstOfRange,endx)\nfunc (ac *arrayContainer) inot(firstOfRange, endx int) container {\n\tif firstOfRange >= endx {\n\t\treturn ac\n\t}\n\treturn ac.inotClose(firstOfRange, endx-1) // remove everything in [firstOfRange,endx-1]\n}\n\n// flip the values in the range [firstOfRange,lastOfRange]\nfunc (ac *arrayContainer) inotClose(firstOfRange, lastOfRange int) container {\n\tif firstOfRange > lastOfRange { // unlike add and remove, not uses an inclusive range [firstOfRange,lastOfRange]\n\t\treturn ac\n\t}\n\t// determine the span of array indices to be affected\n\tstartIndex := binarySearch(ac.content, uint16(firstOfRange))\n\tif startIndex < 0 {\n\t\tstartIndex = -startIndex - 1\n\t}\n\tlastIndex := binarySearch(ac.content, uint16(lastOfRange))\n\tif lastIndex < 0 {\n\t\tlastIndex = -lastIndex - 1 - 1\n\t}\n\tcurrentValuesInRange := lastIndex - startIndex + 1\n\tspanToBeFlipped := lastOfRange - firstOfRange + 1\n\n\tnewValuesInRange := spanToBeFlipped - currentValuesInRange\n\tbuffer := make([]uint16, newValuesInRange)\n\tcardinalityChange := newValuesInRange - currentValuesInRange\n\tnewCardinality := len(ac.content) + cardinalityChange\n\tif cardinalityChange > 0 {\n\t\tif newCardinality > len(ac.content) {\n\t\t\tif newCardinality > arrayDefaultMaxSize {\n\t\t\t\tbcRet := ac.toBitmapContainer()\n\t\t\t\tbcRet.inot(firstOfRange, lastOfRange+1)\n\t\t\t\t*ac = *bcRet.toArrayContainer()\n\t\t\t\treturn bcRet\n\t\t\t}\n\t\t\tac.content = copyOf(ac.content, newCardinality)\n\t\t}\n\t\tbase := lastIndex + 1\n\t\tcopy(ac.content[lastIndex+1+cardinalityChange:], ac.content[base:base+len(ac.content)-1-lastIndex])\n\t\tac.negateRange(buffer, startIndex, lastIndex, firstOfRange, lastOfRange+1)\n\t} else { // no expansion needed\n\t\tac.negateRange(buffer, startIndex, lastIndex, firstOfRange, lastOfRange+1)\n\t\tif cardinalityChange < 0 {\n\t\t\tfor i := startIndex + newValuesInRange; i < newCardinality; i++ {\n\t\t\t\tac.content[i] = ac.content[i-cardinalityChange]\n\t\t\t}\n\t\t}\n\t}\n\tac.content = ac.content[:newCardinality]\n\treturn ac\n}\n\nfunc (ac *arrayContainer) negateRange(buffer []uint16, startIndex, lastIndex, startRange, lastRange int) {\n\t// compute the negation into buffer\n\toutPos := 0\n\tinPos := startIndex // value here always >= valInRange,\n\t// until it is exhausted\n\t// n.b., we can start initially exhausted.\n\n\tvalInRange := startRange\n\tfor ; valInRange < lastRange && inPos <= lastIndex; valInRange++ {\n\t\tif uint16(valInRange) != ac.content[inPos] {\n\t\t\tbuffer[outPos] = uint16(valInRange)\n\t\t\toutPos++\n\t\t} else {\n\t\t\tinPos++\n\t\t}\n\t}\n\n\t// if there are extra items (greater than the biggest\n\t// pre-existing one in range), buffer them\n\tfor ; valInRange < lastRange; valInRange++ {\n\t\tbuffer[outPos] = uint16(valInRange)\n\t\toutPos++\n\t}\n\n\tif outPos != len(buffer) {\n\t\tpanic(\"negateRange: internal bug\")\n\t}\n\n\tfor i, item := range buffer {\n\t\tac.content[i+startIndex] = item\n\t}\n}\n\nfunc (ac *arrayContainer) isFull() bool {\n\treturn false\n}\n\nfunc (ac *arrayContainer) andArray(value2 *arrayContainer) container {\n\tdesiredcapacity := minOfInt(ac.getCardinality(), value2.getCardinality())\n\tanswer := newArrayContainerCapacity(desiredcapacity)\n\tlength := intersection2by2(\n\t\tac.content,\n\t\tvalue2.content,\n\t\tanswer.content)\n\tanswer.content = answer.content[:length]\n\treturn answer\n}\n\nfunc (ac *arrayContainer) andArrayCardinality(value2 *arrayContainer) int {\n\treturn intersection2by2Cardinality(\n\t\tac.content,\n\t\tvalue2.content)\n}\n\nfunc (ac *arrayContainer) intersectsArray(value2 *arrayContainer) bool {\n\treturn intersects2by2(\n\t\tac.content,\n\t\tvalue2.content)\n}\n\nfunc (ac *arrayContainer) iandArray(value2 *arrayContainer) container {\n\tlength := intersection2by2(\n\t\tac.content,\n\t\tvalue2.content,\n\t\tac.content)\n\tac.content = ac.content[:length]\n\treturn ac\n}\n\nfunc (ac *arrayContainer) getCardinality() int {\n\treturn len(ac.content)\n}\n\nfunc (ac *arrayContainer) isEmpty() bool {\n\treturn len(ac.content) == 0\n}\n\nfunc (ac *arrayContainer) rank(x uint16) int {\n\tanswer := binarySearch(ac.content, x)\n\tif answer >= 0 {\n\t\treturn answer + 1\n\t}\n\treturn -answer - 1\n}\n\nfunc (ac *arrayContainer) selectInt(x uint16) int {\n\treturn int(ac.content[x])\n}\n\nfunc (ac *arrayContainer) clone() container {\n\tptr := arrayContainer{make([]uint16, len(ac.content))}\n\tcopy(ptr.content, ac.content[:])\n\treturn &ptr\n}\n\nfunc (ac *arrayContainer) contains(x uint16) bool {\n\treturn binarySearch(ac.content, x) >= 0\n}\n\nfunc (ac *arrayContainer) loadData(bitmapContainer *bitmapContainer) {\n\tac.content = make([]uint16, bitmapContainer.cardinality, bitmapContainer.cardinality)\n\tbitmapContainer.fillArray(ac.content)\n}\n\nfunc (ac *arrayContainer) resetTo(a container) {\n\tswitch x := a.(type) {\n\tcase *arrayContainer:\n\t\tac.realloc(len(x.content))\n\t\tcopy(ac.content, x.content)\n\n\tcase *bitmapContainer:\n\t\tac.realloc(x.cardinality)\n\t\tx.fillArray(ac.content)\n\n\tcase *runContainer16:\n\t\tcard := int(x.getCardinality())\n\t\tac.realloc(card)\n\t\tcur := 0\n\t\tfor _, r := range x.iv {\n\t\t\tfor val := r.start; val <= r.last(); val++ {\n\t\t\t\tac.content[cur] = val\n\t\t\t\tcur++\n\t\t\t}\n\t\t}\n\n\tdefault:\n\t\tpanic(\"unsupported container type\")\n\t}\n}\n\nfunc (ac *arrayContainer) realloc(size int) {\n\tif cap(ac.content) < size {\n\t\tac.content = make([]uint16, size)\n\t} else {\n\t\tac.content = ac.content[:size]\n\t}\n}\n\n// previousValue returns either the target if found or the previous smaller present value.\n// If the target is out of bounds a -1 is returned.\n// Ex: target=4 ac=[2,3,4,6,7] returns 4\n// Ex: target=5 ac=[2,3,4,6,7] returns 4\n// Ex: target=6 ac=[2,3,4,6,7] returns 6\n// Ex: target=8 ac=[2,3,4,6,7] returns 7\n// Ex: target=1 ac=[2,3,4,6,7] returns -1\n// Ex: target=0 ac=[2,3,4,6,7] returns -1\nfunc (ac *arrayContainer) previousValue(target uint16) int {\n\tresult := binarySearchUntil(ac.content, target)\n\n\tif result.index == len(ac.content) {\n\t\treturn int(ac.maximum())\n\t}\n\n\tif result.outOfBounds() {\n\t\treturn -1\n\t}\n\n\treturn int(result.value)\n}\n\n// previousAbsentValue returns either the target if not found or the next larger missing value.\n// If the target is out of bounds a -1 is returned\n// Ex: target=4 ac=[1,2,3,4,6,7] returns 0\n// Ex: target=5 ac=[1,2,3,4,6,7] returns 5\n// Ex: target=6 ac=[1,2,3,4,6,7] returns 5\n// Ex: target=8 ac=[1,2,3,4,6,7] returns 8\nfunc (ac *arrayContainer) previousAbsentValue(target uint16) int {\n\tcardinality := len(ac.content)\n\n\tif cardinality == 0 {\n\t\treturn int(target)\n\t}\n\n\tif target > ac.maximum() {\n\t\treturn int(target)\n\t}\n\n\tresult := binarySearchPast(ac.content, target)\n\n\tif result.notFound() {\n\t\treturn int(target)\n\t}\n\n\t// If the target was found at index 1, then the next value down must be result.value-1\n\tif result.index == 1 {\n\t\tif ac.minimum() != result.value-1 {\n\t\t\treturn int(result.value - 1)\n\t\t}\n\t}\n\n\tlow := -1\n\thigh := result.index\n\n\t// This uses the pigeon-hole principle.\n\t// the if statement compares the difference in indices vs\n\t// the difference in values. Suppose mid = 10 and result.index = 5\n\t// with ac.content[mid] = 100 and target = 10\n\t// then we have 5 slots for values but we need to fit in 90 values\n\t// so some of the values must be missing\n\tfor low+1 < high {\n\t\tmidIndex := (high + low) >> 1\n\t\tindexDifference := result.index - midIndex\n\t\tvalueDifference := target - ac.content[midIndex]\n\t\tif indexDifference < int(valueDifference) {\n\t\t\tlow = midIndex\n\t\t} else {\n\t\t\thigh = midIndex\n\t\t}\n\t}\n\n\tif high == 0 {\n\t\treturn int(ac.minimum()) - 1\n\t}\n\n\treturn int(ac.content[high] - 1)\n}\n\n// nextAbsentValue returns either the target if not found or the next larger missing value.\n// If the target is out of bounds a -1 is returned\n// Ex: target=4 ac=[1,2,3,4,6,7] returns 5\n// Ex: target=5 ac=[1,2,3,4,6,7] returns 5\n// Ex: target=0 ac=[1,2,3,4,6,7] returns 0\n// Ex: target=8 ac=[1,2,3,4,6,7] returns 8\nfunc (ac *arrayContainer) nextAbsentValue(target uint16) int {\n\tcardinality := len(ac.content)\n\n\tif cardinality == 0 {\n\t\treturn int(target)\n\t}\n\tif target < ac.minimum() {\n\t\treturn int(target)\n\t}\n\n\tresult := binarySearchPast(ac.content, target)\n\n\tif result.notFound() {\n\t\treturn int(target)\n\t}\n\n\tif result.index == cardinality-2 {\n\t\tif ac.maximum() != result.value+1 {\n\t\t\treturn int(result.value + 1)\n\t\t}\n\t}\n\n\tlow := result.index\n\thigh := len(ac.content)\n\n\t// This uses the pigeon-hole principle.\n\t// the if statement compares the difference in indices vs\n\t// the difference in values. Suppose mid = 10 and result.index = 5\n\t// with ac.content[mid] = 100 and target = 10\n\t// then we have 5 slots for values but we need to fit in 90 values\n\t// so some of the values must be missing\n\tfor low+1 < high {\n\t\tmidIndex := (high + low) >> 1\n\t\tindexDifference := midIndex - result.index\n\t\tvalueDifference := ac.content[midIndex] - target\n\t\tif indexDifference < int(valueDifference) {\n\t\t\thigh = midIndex\n\t\t} else {\n\t\t\tlow = midIndex\n\t\t}\n\t}\n\n\tif low == cardinality-1 {\n\t\treturn int(ac.content[cardinality-1] + 1)\n\t}\n\n\treturn int(ac.content[low] + 1)\n}\n\n// nextValue returns either the target if found or the next larger value.\n// if the target is out of bounds a -1 is returned\n//\n// Ex: target=4 ac=[1,2,3,4,6,7] returns 4\n// Ex: target=5 ac=[1,2,3,4,6,7] returns 6\n// Ex: target=6 ac=[1,2,3,4,6,7] returns 6\n// Ex: target=0 ac=[1,2,3,4,6,7] returns 1\n// Ex: target=100 ac=[1,2,3,4,6,7] returns -1\nfunc (ac *arrayContainer) nextValue(target uint16) int {\n\tcardinality := len(ac.content)\n\tif cardinality == 0 {\n\t\treturn -1\n\t}\n\n\t//if target < ac.minimum() {\n\t//\treturn -1\n\t//}\n\t//if target > ac.maximum() {\n\t//\t\treturn -1\n\t//\t}\n\n\tresult := binarySearchUntil(ac.content, target)\n\tif result.exactMatch {\n\t\treturn int(result.value)\n\t}\n\n\tif !result.exactMatch && result.index == -1 {\n\t\treturn int(ac.content[0])\n\t}\n\tif result.outOfBounds() {\n\t\treturn -1\n\t}\n\n\tif result.index < len(ac.content)-1 {\n\t\treturn int(ac.content[result.index+1])\n\t}\n\treturn -1\n}\n\nfunc newArrayContainer() *arrayContainer {\n\tp := new(arrayContainer)\n\treturn p\n}\n\nfunc newArrayContainerFromBitmap(bc *bitmapContainer) *arrayContainer {\n\tac := &arrayContainer{}\n\tac.loadData(bc)\n\treturn ac\n}\n\nfunc newArrayContainerCapacity(size int) *arrayContainer {\n\tp := new(arrayContainer)\n\tp.content = make([]uint16, 0, size)\n\treturn p\n}\n\nfunc newArrayContainerSize(size int) *arrayContainer {\n\tp := new(arrayContainer)\n\tp.content = make([]uint16, size, size)\n\treturn p\n}\n\nfunc newArrayContainerRange(firstOfRun, lastOfRun int) *arrayContainer {\n\tvaluesInRange := lastOfRun - firstOfRun + 1\n\tthis := newArrayContainerCapacity(valuesInRange)\n\tfor i := 0; i < valuesInRange; i++ {\n\t\tthis.content = append(this.content, uint16(firstOfRun+i))\n\t}\n\treturn this\n}\n\nfunc (ac *arrayContainer) numberOfRuns() (nr int) {\n\tn := len(ac.content)\n\tvar runlen uint16\n\tvar cur, prev uint16\n\n\tswitch n {\n\tcase 0:\n\t\treturn 0\n\tcase 1:\n\t\treturn 1\n\tdefault:\n\t\tfor i := 1; i < n; i++ {\n\t\t\tprev = ac.content[i-1]\n\t\t\tcur = ac.content[i]\n\n\t\t\tif cur == prev+1 {\n\t\t\t\trunlen++\n\t\t\t} else {\n\t\t\t\tif cur < prev {\n\t\t\t\t\tpanic(\"the fundamental arrayContainer assumption of sorted ac.content was broken\")\n\t\t\t\t}\n\t\t\t\tif cur == prev {\n\t\t\t\t\tpanic(\"the fundamental arrayContainer assumption of deduplicated content was broken\")\n\t\t\t\t} else {\n\t\t\t\t\tnr++\n\t\t\t\t\trunlen = 0\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tnr++\n\t}\n\treturn\n}\n\n// convert to run or array *if needed*\nfunc (ac *arrayContainer) toEfficientContainer() container {\n\tnumRuns := ac.numberOfRuns()\n\tsizeAsRunContainer := runContainer16SerializedSizeInBytes(numRuns)\n\tsizeAsBitmapContainer := bitmapContainerSizeInBytes()\n\tcard := ac.getCardinality()\n\tsizeAsArrayContainer := arrayContainerSizeInBytes(card)\n\tif sizeAsRunContainer < minOfInt(sizeAsBitmapContainer, sizeAsArrayContainer) {\n\t\treturn newRunContainer16FromArray(ac)\n\t}\n\tif card <= arrayDefaultMaxSize {\n\t\treturn ac\n\t}\n\treturn ac.toBitmapContainer()\n}\n\nfunc (ac *arrayContainer) containerType() contype {\n\treturn arrayContype\n}\n\nfunc (ac *arrayContainer) addOffset(x uint16) (container, container) {\n\tvar low, high *arrayContainer\n\n\tif len(ac.content) == 0 {\n\t\treturn nil, nil\n\t}\n\n\tif y := uint32(ac.content[0]) + uint32(x); highbits(y) == 0 {\n\t\t// Some elements will fall into low part, allocate a container.\n\t\t// Checking the first one is enough because they are ordered.\n\t\tlow = &arrayContainer{}\n\t}\n\tif y := uint32(ac.content[len(ac.content)-1]) + uint32(x); highbits(y) > 0 {\n\t\t// Some elements will fall into high part, allocate a container.\n\t\t// Checking the last one is enough because they are ordered.\n\t\thigh = &arrayContainer{}\n\t}\n\n\tfor _, val := range ac.content {\n\t\ty := uint32(val) + uint32(x)\n\t\tif highbits(y) > 0 {\n\t\t\t// OK, if high == nil then highbits(y) == 0 for all y.\n\t\t\thigh.content = append(high.content, lowbits(y))\n\t\t} else {\n\t\t\t// OK, if low == nil then highbits(y) > 0 for all y.\n\t\t\tlow.content = append(low.content, lowbits(y))\n\t\t}\n\t}\n\n\t// Ensure proper nil interface.\n\tif low == nil {\n\t\treturn nil, high\n\t}\n\tif high == nil {\n\t\treturn low, nil\n\t}\n\n\treturn low, high\n}\n\n// validate checks cardinality and sort order of the array container\nfunc (ac *arrayContainer) validate() error {\n\tcardinality := ac.getCardinality()\n\n\tif cardinality <= 0 {\n\t\treturn ErrArrayInvalidSize\n\t}\n\n\tif cardinality > arrayDefaultMaxSize {\n\t\treturn ErrArrayInvalidSize\n\t}\n\n\tprevious := ac.content[0]\n\tfor i := 1; i < len(ac.content); i++ {\n\t\tnext := ac.content[i]\n\t\tif previous > next {\n\t\t\treturn ErrArrayIncorrectSort\n\t\t}\n\t\tprevious = next\n\n\t}\n\n\treturn nil\n}\n"
        },
        {
          "name": "arraycontainer_test.go",
          "type": "blob",
          "size": 18.8037109375,
          "content": "package roaring\n\n// to run just these tests: go test -run TestArrayContainer*\n\nimport (\n\t\"math/rand\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n\t\"github.com/stretchr/testify/require\"\n)\n\nfunc TestArrayContainerTransition(t *testing.T) {\n\tv := container(newArrayContainer())\n\n\tfor i := 0; i < arrayDefaultMaxSize; i++ {\n\t\tv = v.iaddReturnMinimized(uint16(i))\n\t}\n\n\tassert.Equal(t, arrayDefaultMaxSize, v.getCardinality())\n\tassert.IsType(t, newArrayContainer(), v)\n\n\tfor i := 0; i < arrayDefaultMaxSize; i++ {\n\t\tv = v.iaddReturnMinimized(uint16(i))\n\t}\n\n\tassert.Equal(t, arrayDefaultMaxSize, v.getCardinality())\n\tassert.IsType(t, newArrayContainer(), v)\n\n\tv = v.iaddReturnMinimized(uint16(arrayDefaultMaxSize))\n\n\tassert.Equal(t, arrayDefaultMaxSize+1, v.getCardinality())\n\tassert.IsType(t, newBitmapContainer(), v)\n\n\tv = v.iremoveReturnMinimized(uint16(arrayDefaultMaxSize))\n\n\tassert.Equal(t, arrayDefaultMaxSize, v.getCardinality())\n\tassert.IsType(t, newArrayContainer(), v)\n}\n\nfunc TestArrayContainerRank(t *testing.T) {\n\tv := container(newArrayContainer())\n\tv = v.iaddReturnMinimized(10)\n\tv = v.iaddReturnMinimized(100)\n\tv = v.iaddReturnMinimized(1000)\n\n\tassert.Equal(t, 3, v.getCardinality())\n\n\tfor i := 0; i <= arrayDefaultMaxSize; i++ {\n\t\tthisrank := v.rank(uint16(i))\n\n\t\tif i < 10 {\n\t\t\tassert.Equalf(t, 0, thisrank, \"At %d should be zero but is %d\", i, thisrank)\n\t\t} else if i < 100 {\n\t\t\tassert.Equalf(t, 1, thisrank, \"At %d should be one but is %d\", i, thisrank)\n\t\t} else if i < 1000 {\n\t\t\tassert.Equalf(t, 2, thisrank, \"At %d should be two but is %d\", i, thisrank)\n\t\t} else {\n\t\t\tassert.Equalf(t, 3, thisrank, \"At %d should be three but is %d\", i, thisrank)\n\t\t}\n\t}\n}\n\nfunc TestArrayOffset(t *testing.T) {\n\tnums := []uint16{10, 100, 1000}\n\texpected := make([]int, len(nums))\n\tofftest := uint16(65000)\n\tv := container(newArrayContainer())\n\tfor i, n := range nums {\n\t\tv = v.iaddReturnMinimized(n)\n\t\texpected[i] = int(n) + int(offtest)\n\t}\n\tl, h := v.addOffset(offtest)\n\n\tvar w0card, w1card int\n\twout := make([]int, len(nums))\n\n\tif l != nil {\n\t\tw0card = l.getCardinality()\n\n\t\tfor i := 0; i < w0card; i++ {\n\t\t\twout[i] = l.selectInt(uint16(i))\n\t\t}\n\t}\n\n\tif h != nil {\n\t\tw1card = h.getCardinality()\n\n\t\tfor i := 0; i < w1card; i++ {\n\t\t\twout[i+w0card] = h.selectInt(uint16(i)) + 65536\n\t\t}\n\t}\n\n\tassert.Equal(t, 3, w0card+w1card)\n\tfor i, x := range wout {\n\t\tassert.Equal(t, expected[i], x)\n\t}\n}\n\nfunc TestArrayContainerMassiveSetAndGet(t *testing.T) {\n\tv := container(newArrayContainer())\n\n\tfor j := 0; j <= arrayDefaultMaxSize; j++ {\n\t\tv = v.iaddReturnMinimized(uint16(j))\n\t\tassert.Equal(t, 1+j, v.getCardinality())\n\n\t\tsuccess := true\n\t\ti := 0\n\n\t\tfor ; i <= arrayDefaultMaxSize && success; i++ {\n\t\t\tif i <= j {\n\t\t\t\tsuccess = v.contains(uint16(i))\n\t\t\t} else {\n\t\t\t\tsuccess = !v.contains(uint16(i))\n\t\t\t}\n\t\t}\n\n\t\tassert.Truef(t, success, \"failed at %d iteration\", i)\n\t}\n}\n\nfunc TestArrayContainerUnsupportedType(t *testing.T) {\n\ta := container(newArrayContainer())\n\ttestContainerPanics(t, a)\n\n\tb := container(newBitmapContainer())\n\ttestContainerPanics(t, b)\n}\n\nfunc testContainerPanics(t *testing.T, c container) {\n\tf := &struct {\n\t\tarrayContainer\n\t}{}\n\n\tassert.Panics(t, func() { c.or(f) })\n\tassert.Panics(t, func() { c.ior(f) })\n\tassert.Panics(t, func() { c.lazyIOR(f) })\n\tassert.Panics(t, func() { c.lazyOR(f) })\n\tassert.Panics(t, func() { c.and(f) })\n\tassert.Panics(t, func() { c.intersects(f) })\n\tassert.Panics(t, func() { c.iand(f) })\n\tassert.Panics(t, func() { c.xor(f) })\n\tassert.Panics(t, func() { c.andNot(f) })\n\tassert.Panics(t, func() { c.iandNot(f) })\n}\n\nfunc TestArrayContainerNumberOfRuns025(t *testing.T) {\n\tseed := int64(42)\n\trand.Seed(seed)\n\n\ttrials := []trial{\n\t\t{n: 1000, percentFill: .1, ntrial: 10},\n\t\t/*\n\t\t\ttrial{n: 100, percentFill: .5, ntrial: 10},\n\t\t\ttrial{n: 100, percentFill: .01, ntrial: 10},\n\t\t\ttrial{n: 100, percentFill: .99, ntrial: 10},\n\t\t*/\n\t}\n\n\ttester := func(tr trial) {\n\t\tfor j := 0; j < tr.ntrial; j++ {\n\t\t\tma := make(map[int]bool)\n\n\t\t\tn := tr.n\n\t\t\ta := []uint16{}\n\n\t\t\tdraw := int(float64(n) * tr.percentFill)\n\t\t\tfor i := 0; i < draw; i++ {\n\t\t\t\tr0 := rand.Intn(n)\n\t\t\t\ta = append(a, uint16(r0))\n\t\t\t\tma[r0] = true\n\t\t\t}\n\n\t\t\t// RunContainer computes this automatically\n\t\t\trc := newRunContainer16FromVals(false, a...)\n\t\t\trcNr := rc.numberOfRuns()\n\n\t\t\t// vs arrayContainer\n\t\t\tac := newArrayContainer()\n\t\t\tfor k := range ma {\n\t\t\t\tac.iadd(uint16(k))\n\t\t\t}\n\n\t\t\tacNr := ac.numberOfRuns()\n\t\t\tassert.Equal(t, acNr, rcNr)\n\n\t\t\t// get coverage of arrayContainer coners...\n\t\t\tassert.Equal(t, 2*len(ma), ac.serializedSizeInBytes())\n\t\t\tassert.NotPanics(t, func() { ac.iaddRange(2, 1) })\n\t\t\tassert.NotPanics(t, func() { ac.iremoveRange(2, 1) })\n\n\t\t\tac.iremoveRange(0, 2)\n\t\t\tac.iremoveRange(0, 2)\n\t\t\tdelete(ma, 0)\n\t\t\tdelete(ma, 1)\n\n\t\t\tassert.Equal(t, len(ma), ac.getCardinality())\n\n\t\t\tac.iadd(0)\n\t\t\tac.iadd(1)\n\t\t\tac.iadd(2)\n\t\t\tma[0] = true\n\t\t\tma[1] = true\n\t\t\tma[2] = true\n\t\t\tnewguy := ac.not(0, 3).(*arrayContainer)\n\n\t\t\tassert.False(t, newguy.contains(0))\n\t\t\tassert.False(t, newguy.contains(1))\n\t\t\tassert.False(t, newguy.contains(2))\n\n\t\t\tnewguy.notClose(0, 2)\n\t\t\tnewguy.remove(2)\n\t\t\tnewguy.remove(2)\n\t\t\tnewguy.ior(ac)\n\n\t\t\tmessedUp := newArrayContainer()\n\n\t\t\tassert.Equal(t, 0, messedUp.numberOfRuns())\n\n\t\t\t// messed up\n\t\t\tmessedUp.content = []uint16{1, 1}\n\t\t\tassert.Panics(t, func() { messedUp.numberOfRuns() })\n\n\t\t\tmessedUp.content = []uint16{2, 1}\n\t\t\tassert.Panics(t, func() { messedUp.numberOfRuns() })\n\n\t\t\tshouldBeBit := newArrayContainer()\n\t\t\tfor i := 0; i < arrayDefaultMaxSize+1; i++ {\n\t\t\t\tshouldBeBit.iadd(uint16(i * 2))\n\t\t\t}\n\t\t\tbit := shouldBeBit.toEfficientContainer()\n\t\t\t_, isBit := bit.(*bitmapContainer)\n\n\t\t\tassert.True(t, isBit)\n\t\t}\n\t}\n\n\tfor i := range trials {\n\t\ttester(trials[i])\n\t}\n}\n\nfunc TestArrayContainerIaddRangeNearMax068(t *testing.T) {\n\tiv := []interval16{\n\t\tnewInterval16Range(65525, 65527),\n\t\tnewInterval16Range(65530, 65530),\n\t\tnewInterval16Range(65534, 65535),\n\t}\n\trc := newRunContainer16TakeOwnership(iv)\n\n\tac2 := rc.toArrayContainer()\n\n\tassert.True(t, ac2.equals(rc))\n\tassert.True(t, rc.equals(ac2))\n\n\tac := newArrayContainer()\n\tendx := int(MaxUint16) + 1\n\tfirst := endx - 3\n\tac.iaddRange(first-20, endx-20)\n\tac.iaddRange(first-6, endx-6)\n\tac.iaddRange(first, endx)\n\n\tassert.Equal(t, 9, ac.getCardinality())\n}\n\nfunc TestArrayContainerEtc070(t *testing.T) {\n\tiv := []interval16{\n\t\tnewInterval16Range(65525, 65527),\n\t\tnewInterval16Range(65530, 65530),\n\t\tnewInterval16Range(65534, 65535),\n\t}\n\trc := newRunContainer16TakeOwnership(iv)\n\tac := rc.toArrayContainer()\n\n\t// not when nothing to do just returns a clone\n\tassert.True(t, ac.equals(ac.not(0, 0)))\n\tassert.True(t, ac.equals(ac.notClose(1, 0)))\n\n\t// not will promote to bitmapContainer if card is big enough\n\tac = newArrayContainer()\n\tac.inot(0, MaxUint16+1)\n\trc = newRunContainer16Range(0, MaxUint16)\n\n\tassert.True(t, rc.equals(ac))\n\n\t// comparing two array containers with different card\n\tac2 := newArrayContainer()\n\tassert.False(t, ac2.equals(ac))\n\n\t// comparing two arrays with same card but different content\n\tac3 := newArrayContainer()\n\tac4 := newArrayContainer()\n\tac3.iadd(1)\n\tac3.iadd(2)\n\tac4.iadd(1)\n\n\tassert.False(t, ac3.equals(ac4))\n\n\t// compare array vs other with different card\n\tassert.False(t, ac3.equals(rc))\n\n\t// compare array vs other, same card, different content\n\trc = newRunContainer16Range(0, 0)\n\tassert.False(t, ac4.equals(rc))\n\n\t// remove from middle of array\n\tac5 := newArrayContainer()\n\tac5.iaddRange(0, 10)\n\n\tassert.Equal(t, 10, ac5.getCardinality())\n\n\tac6 := ac5.remove(5)\n\tassert.Equal(t, 9, ac6.getCardinality())\n\n\t// lazyorArray that converts to bitmap\n\tac5.iaddRange(0, arrayLazyLowerBound-1)\n\tac6.iaddRange(arrayLazyLowerBound, 2*arrayLazyLowerBound-2)\n\tac6a := ac6.(*arrayContainer)\n\tbc := ac5.lazyorArray(ac6a)\n\t_, isBitmap := bc.(*bitmapContainer)\n\n\tassert.True(t, isBitmap)\n\n\t// andBitmap\n\tac = newArrayContainer()\n\tac.iaddRange(0, 10)\n\tbc9 := newBitmapContainer()\n\tbc9.iaddRange(0, 5)\n\tand := ac.andBitmap(bc9)\n\n\tassert.Equal(t, 5, and.getCardinality())\n\n\t// numberOfRuns with 1 member\n\tac10 := newArrayContainer()\n\tac10.iadd(1)\n\n\tassert.Equal(t, 1, ac10.numberOfRuns())\n}\n\nfunc TestArrayContainerIAndNot(t *testing.T) {\n\tvar ac container\n\tac = newArrayContainer()\n\tac.iadd(12)\n\tac.iadd(27)\n\tac.iadd(32)\n\tac.iadd(88)\n\tac.iadd(188)\n\tac.iadd(289)\n\n\tvar rc container\n\trc = newRunContainer16Range(0, 15)\n\trc = rc.iaddRange(1500, 2000)\n\trc = rc.iaddRange(55, 100)\n\trc = rc.iaddRange(25, 50)\n\tac = ac.iandNot(rc)\n\n\trequire.ElementsMatch(t, []uint16{188, 289}, ac.(*arrayContainer).content)\n\trequire.Equal(t, 2, ac.getCardinality())\n}\n\nfunc TestArrayContainerIand(t *testing.T) {\n\ta := NewBitmap()\n\ta.AddRange(0, 200000)\n\tb := BitmapOf(50, 100000, 150000)\n\tb.And(a)\n\tr := b.ToArray()\n\n\tassert.Len(t, r, 3)\n\tassert.EqualValues(t, 50, r[0])\n\tassert.EqualValues(t, 100000, r[1])\n\tassert.EqualValues(t, 150000, r[2])\n}\n\nfunc TestArrayIteratorPeekNext(t *testing.T) {\n\ttestContainerIteratorPeekNext(t, newArrayContainer())\n}\n\nfunc TestArrayIteratorAdvance(t *testing.T) {\n\ttestContainerIteratorAdvance(t, newArrayContainer())\n}\n\nfunc TestArrayContainerResetTo(t *testing.T) {\n\tarray := newArrayContainer()\n\tfor i := 0; i < 1000; i++ {\n\t\tarray.iadd(uint16(i*1000 + i + 50))\n\t}\n\n\tbitmap := newBitmapContainer()\n\tfor i := 0; i < 10000; i++ {\n\t\tbitmap.iadd(uint16(i*1000 + i + 50))\n\t}\n\n\trun := newRunContainer16()\n\tfor i := 0; i < 10; i++ {\n\t\tstart := i*1000 + i + 50\n\t\trun.iaddRange(start, start+100+i)\n\t}\n\n\tmakeDirty := func() *arrayContainer {\n\t\tret := newArrayContainer()\n\t\tfor i := 0; i < arrayDefaultMaxSize; i += 3 {\n\t\t\tret.iadd(uint16(i))\n\t\t}\n\t\treturn ret\n\t}\n\n\tt.Run(\"to array container\", func(t *testing.T) {\n\t\tclean := newArrayContainer()\n\t\tclean.resetTo(array)\n\t\tassert.True(t, clean.equals(array))\n\n\t\tdirty := makeDirty()\n\t\tdirty.resetTo(array)\n\t\tassert.True(t, dirty.equals(array))\n\t})\n\n\tt.Run(\"to bitmap container\", func(t *testing.T) {\n\t\tclean := newArrayContainer()\n\t\tclean.resetTo(bitmap)\n\t\tassert.True(t, clean.equals(bitmap))\n\n\t\tdirty := makeDirty()\n\t\tdirty.resetTo(bitmap)\n\t\tassert.True(t, dirty.equals(bitmap.toArrayContainer()))\n\t})\n\n\tt.Run(\"to run container\", func(t *testing.T) {\n\t\tclean := newArrayContainer()\n\t\tclean.resetTo(run)\n\t\tassert.True(t, clean.toEfficientContainer().equals(run))\n\n\t\tdirty := makeDirty()\n\t\tdirty.resetTo(run)\n\t\tassert.True(t, dirty.toEfficientContainer().equals(run))\n\t})\n}\n\nfunc TestNextValueArray(t *testing.T) {\n\tt.Run(\"Java Port 1\", func(t *testing.T) {\n\t\t// [Example 1]  https://github.com/RoaringBitmap/RoaringBitmap/blob/5235aa62c32fa3bf7fae40a562e3edc75f61be4e/RoaringBitmap/src/test/java/org/roaringbitmap/buffer/TestMappeableArrayContainer.java#L495\n\t\tac := newArrayContainer()\n\t\tac.iaddRange(64, 129)\n\t\tassert.Equal(t, 64, ac.nextValue(0))\n\t\tassert.Equal(t, 64, ac.nextValue(64))\n\t\tassert.Equal(t, 65, ac.nextValue(65))\n\t\tassert.Equal(t, 128, ac.nextValue(128))\n\t\tassert.Equal(t, -1, ac.nextValue(129))\n\t\tassert.Equal(t, -1, ac.nextValue(5000))\n\t})\n\n\tt.Run(\"Java Port 2\", func(t *testing.T) {\n\t\t// [Example 2]  https://github.com/RoaringBitmap/RoaringBitmap/blob/5235aa62c32fa3bf7fae40a562e3edc75f61be4e/RoaringBitmap/src/test/java/org/roaringbitmap/buffer/TestMappeableArrayContainer.java#L507\n\t\tac := newArrayContainer()\n\t\tac.iaddRange(64, 129)\n\t\tac.iaddRange(256, 321)\n\t\tassert.Equal(t, 64, ac.nextValue(0))\n\t\tassert.Equal(t, 64, ac.nextValue(63))\n\t\tassert.Equal(t, 64, ac.nextValue(64))\n\t\tassert.Equal(t, 65, ac.nextValue(65))\n\t\tassert.Equal(t, 128, ac.nextValue(128))\n\t\tassert.Equal(t, 256, ac.nextValue(129))\n\t\tassert.Equal(t, -1, ac.nextValue(512))\n\t})\n\n\tt.Run(\"Java Port 3\", func(t *testing.T) {\n\t\t// [Example 3]  https://github.com/RoaringBitmap/RoaringBitmap/blob/5235aa62c32fa3bf7fae40a562e3edc75f61be4e/RoaringBitmap/src/test/java/org/roaringbitmap/buffer/TestMappeableArrayContainer.java#L525\n\t\tac := newArrayContainer()\n\t\tac.iaddRange(64, 129)\n\t\tac.iaddRange(200, 501)\n\t\tac.iaddRange(5000, 5201)\n\n\t\tassert.Equal(t, 64, ac.nextValue(0))\n\t\tassert.Equal(t, 64, ac.nextValue(63))\n\t\tassert.Equal(t, 64, ac.nextValue(64))\n\t\tassert.Equal(t, 65, ac.nextValue(65))\n\t\tassert.Equal(t, 128, ac.nextValue(128))\n\t\tassert.Equal(t, 200, ac.nextValue(129))\n\t\tassert.Equal(t, 200, ac.nextValue(199))\n\t\tassert.Equal(t, 200, ac.nextValue(200))\n\t\tassert.Equal(t, 250, ac.nextValue(250))\n\t\tassert.Equal(t, 5000, ac.nextValue(2500))\n\t\tassert.Equal(t, 5000, ac.nextValue(5000))\n\t\tassert.Equal(t, 5200, ac.nextValue(5200))\n\t\tassert.Equal(t, -1, ac.nextValue(5201))\n\t})\n}\n\nfunc TestNextAbsentValueArray(t *testing.T) {\n\tt.Run(\"Java Port 1\", func(t *testing.T) {\n\t\t// [Java 1]  https://github.com/RoaringBitmap/RoaringBitmap/blob/5235aa62c32fa3bf7fae40a562e3edc75f61be4e/RoaringBitmap/src/test/java/org/roaringbitmap/TestArrayContainer.java#L850\n\t\tac := newArrayContainer()\n\t\tac.iaddRange(64, 129)\n\t\tassert.Equal(t, 0, ac.nextAbsentValue(0))\n\t\tassert.Equal(t, 63, ac.nextAbsentValue(63))\n\t\tassert.Equal(t, 129, ac.nextAbsentValue(64))\n\t\tassert.Equal(t, 129, ac.nextAbsentValue(65))\n\t\tassert.Equal(t, 129, ac.nextAbsentValue(128))\n\t\tassert.Equal(t, 129, ac.nextAbsentValue(129))\n\t})\n\n\tt.Run(\"Java Port 2\", func(t *testing.T) {\n\t\t// [Example 2] https://github.com/RoaringBitmap/RoaringBitmap/blob/5235aa62c32fa3bf7fae40a562e3edc75f61be4e/RoaringBitmap/src/test/java/org/roaringbitmap/TestArrayContainer.java#L861\n\t\tac := newArrayContainer()\n\t\tac.iaddRange(64, 129)\n\t\tac.iaddRange(200, 501)\n\t\tac.iaddRange(5000, 5201)\n\t\tassert.Equal(t, 0, ac.nextAbsentValue(0))\n\t\tassert.Equal(t, 63, ac.nextAbsentValue(63))\n\t\tassert.Equal(t, 129, ac.nextAbsentValue(64))\n\t\tassert.Equal(t, 129, ac.nextAbsentValue(65))\n\t\tassert.Equal(t, 129, ac.nextAbsentValue(128))\n\t\tassert.Equal(t, 129, ac.nextAbsentValue(129))\n\t\tassert.Equal(t, 199, ac.nextAbsentValue(199))\n\t\tassert.Equal(t, 501, ac.nextAbsentValue(200))\n\t\tassert.Equal(t, 501, ac.nextAbsentValue(250))\n\t\tassert.Equal(t, 2500, ac.nextAbsentValue(2500))\n\t\tassert.Equal(t, 5201, ac.nextAbsentValue(5000))\n\t\tassert.Equal(t, 5201, ac.nextAbsentValue(5200))\n\t})\n\n\tt.Run(\"Java Port 3\", func(t *testing.T) {\n\t\t// [Java  3]  https://github.com/RoaringBitmap/RoaringBitmap/blob/5235aa62c32fa3bf7fae40a562e3edc75f61be4e/RoaringBitmap/src/test/java/org/roaringbitmap/TestArrayContainer.java#L878\n\t\tac := newArrayContainer()\n\t\tfor i := 0; i < 1000; i++ {\n\t\t\tassert.Equal(t, i, ac.nextAbsentValue(uint16(i)))\n\t\t}\n\t})\n}\n\nfunc TestPreviousValueArray(t *testing.T) {\n\tt.Run(\"Java Port 1\", func(t *testing.T) {\n\t\t// [Example 1] https://github.com/RoaringBitmap/RoaringBitmap/blob/5235aa62c32fa3bf7fae40a562e3edc75f61be4e/RoaringBitmap/src/test/java/org/roaringbitmap/TestArrayContainer.java#L721\n\t\tac := newArrayContainer()\n\t\tac.iaddRange(64, 129)\n\t\tassert.Equal(t, -1, ac.previousValue(0))\n\t\tassert.Equal(t, -1, ac.previousValue(63))\n\t\tassert.Equal(t, 64, ac.previousValue(64))\n\t\tassert.Equal(t, 65, ac.previousValue(65))\n\t\tassert.Equal(t, 128, ac.previousValue(128))\n\t\tassert.Equal(t, 128, ac.previousValue(129))\n\t})\n\n\tt.Run(\"Java Port 2\", func(t *testing.T) {\n\t\t// [Example 2]   https://github.com/RoaringBitmap/RoaringBitmap/blob/5235aa62c32fa3bf7fae40a562e3edc75f61be4e/RoaringBitmap/src/test/java/org/roaringbitmap/TestArrayContainer.java#L733\n\t\tac := newArrayContainer()\n\t\tac.iaddRange(64, 129)\n\t\tac.iaddRange(200, 501)\n\t\tac.iaddRange(5000, 5201)\n\t\tassert.Equal(t, -1, ac.previousValue(0))\n\t\tassert.Equal(t, -1, ac.previousValue(63))\n\t\tassert.Equal(t, 64, ac.previousValue(64))\n\t\tassert.Equal(t, 65, ac.previousValue(65))\n\t\tassert.Equal(t, 128, ac.previousValue(128))\n\t\tassert.Equal(t, 128, ac.previousValue(129))\n\t\tassert.Equal(t, 128, ac.previousValue(199))\n\t\tassert.Equal(t, 200, ac.previousValue(200))\n\t\tassert.Equal(t, 250, ac.previousValue(250))\n\t\tassert.Equal(t, 500, ac.previousValue(2500))\n\t\tassert.Equal(t, 5000, ac.previousValue(5000))\n\t\tassert.Equal(t, 5200, ac.previousValue(5200))\n\t})\n\n\tt.Run(\"Java Port 3\", func(t *testing.T) {\n\t\t// [Example 3] https://github.com/RoaringBitmap/RoaringBitmap/blob/5235aa62c32fa3bf7fae40a562e3edc75f61be4e/RoaringBitmap/src/test/java/org/roaringbitmap/TestArrayContainer.java#L751\n\t\tac := newArrayContainer()\n\t\tac.iaddRange(64, 129)\n\t\tassert.Equal(t, -1, ac.previousValue(5))\n\t})\n}\n\nfunc TestPreviousAbsentValueArray(t *testing.T) {\n\tt.Run(\"Java Port 1\", func(t *testing.T) {\n\t\t// [Example 1] https://github.com/RoaringBitmap/RoaringBitmap/blob/5235aa62c32fa3bf7fae40a562e3edc75f61be4e/RoaringBitmap/src/test/java/org/roaringbitmap/TestArrayContainer.java#L793\n\t\tac := newArrayContainer()\n\t\tac.iaddRange(64, 129)\n\t\tassert.Equal(t, 0, ac.previousAbsentValue(0))\n\t\tassert.Equal(t, 63, ac.previousAbsentValue(63))\n\t\tassert.Equal(t, 63, ac.previousAbsentValue(64))\n\t\tassert.Equal(t, 63, ac.previousAbsentValue(65))\n\t\tassert.Equal(t, 63, ac.previousAbsentValue(128))\n\t\tassert.Equal(t, 129, ac.previousAbsentValue(129))\n\t})\n\n\tt.Run(\"Java Port 2\", func(t *testing.T) {\n\t\t// [Example 2] https://github.com/RoaringBitmap/RoaringBitmap/blob/5235aa62c32fa3bf7fae40a562e3edc75f61be4e/RoaringBitmap/src/test/java/org/roaringbitmap/TestArrayContainer.java#L804\n\t\tac := newArrayContainer()\n\t\tac.iaddRange(64, 129)\n\t\tac.iaddRange(200, 500)\n\t\tac.iaddRange(5000, 5201)\n\t\tassert.Equal(t, 0, ac.previousAbsentValue(0))\n\t\tassert.Equal(t, 63, ac.previousAbsentValue(63))\n\t\tassert.Equal(t, 63, ac.previousAbsentValue(64))\n\t\tassert.Equal(t, 63, ac.previousAbsentValue(65))\n\t\tassert.Equal(t, 63, ac.previousAbsentValue(128))\n\t\tassert.Equal(t, 129, ac.previousAbsentValue(129))\n\t\tassert.Equal(t, 199, ac.previousAbsentValue(199))\n\t\tassert.Equal(t, 199, ac.previousAbsentValue(200))\n\t\tassert.Equal(t, 199, ac.previousAbsentValue(250))\n\t\tassert.Equal(t, 2500, ac.previousAbsentValue(2500))\n\t\tassert.Equal(t, 4999, ac.previousAbsentValue(5000))\n\t\tassert.Equal(t, 4999, ac.previousAbsentValue(5200))\n\t})\n\n\tt.Run(\"Java Port 3\", func(t *testing.T) {\n\t\t// [Example 3] https://github.com/RoaringBitmap/RoaringBitmap/blob/5235aa62c32fa3bf7fae40a562e3edc75f61be4e/RoaringBitmap/src/test/java/org/roaringbitmap/TestArrayContainer.java#L821\n\t\tac := newArrayContainer()\n\t\tfor i := 0; i < 1000; i++ {\n\t\t\tassert.Equal(t, i, ac.previousAbsentValue(uint16(i)))\n\t\t}\n\t})\n}\n\nfunc TestArrayContainerValidation(t *testing.T) {\n\tarray := newArrayContainer()\n\tupperBound := arrayDefaultMaxSize\n\n\terr := array.validate()\n\tassert.Error(t, err)\n\n\tfor i := 0; i < upperBound; i++ {\n\t\tarray.iadd(uint16(i))\n\t}\n\terr = array.validate()\n\tassert.NoError(t, err)\n\n\t// Introduce a sort error\n\t// We know that upperbound is unsorted because we populated up to upperbound\n\tarray.content[500] = uint16(upperBound + upperBound)\n\n\terr = array.validate()\n\tassert.Error(t, err)\n\n\tarray = newArrayContainer()\n\n\t// Technically a run, but make sure the incorrect sort detection handles equal elements\n\tfor i := 0; i < upperBound; i++ {\n\t\tarray.iadd(uint16(1))\n\t}\n\terr = array.validate()\n\tassert.NoError(t, err)\n\n\tarray = newArrayContainer()\n\n\tfor i := 0; i < 2*upperBound; i++ {\n\t\tarray.iadd(uint16(i))\n\t}\n\terr = array.validate()\n\tassert.Error(t, err)\n}\n\n// go test -bench BenchmarkShortIteratorAdvance -run -\nfunc BenchmarkShortIteratorAdvanceArray(b *testing.B) {\n\tbenchmarkContainerIteratorAdvance(b, newArrayContainer())\n}\n\n// go test -bench BenchmarkShortIteratorNext -run -\nfunc BenchmarkShortIteratorNextArray(b *testing.B) {\n\tbenchmarkContainerIteratorNext(b, newArrayContainer())\n}\n"
        },
        {
          "name": "benchmark_memory_test.go",
          "type": "blob",
          "size": 1.6298828125,
          "content": "//go:build go1.13\n// +build go1.13\n\npackage roaring\n\nimport (\n\t\"math/rand\"\n\t\"runtime\"\n\t\"testing\"\n\n\t\"github.com/bits-and-blooms/bitset\"\n)\n\n// go test -bench BenchmarkMemoryUsage -run -\nfunc BenchmarkMemoryUsage(b *testing.B) {\n\tb.StopTimer()\n\tbitmaps := make([]*Bitmap, 0, 10)\n\n\tincr := uint32(1 << 16)\n\tmax := uint32(1<<32 - 1)\n\tfor x := 0; x < 10; x++ {\n\t\trb := NewBitmap()\n\n\t\tvar i uint32\n\t\tfor i = 0; i <= max-incr; i += incr {\n\t\t\trb.Add(i)\n\t\t}\n\n\t\tbitmaps = append(bitmaps, rb)\n\t}\n\n\tvar stats runtime.MemStats\n\truntime.ReadMemStats(&stats)\n\tb.ReportMetric(float64(stats.HeapInuse), \"HeapInUse\")\n\tb.ReportMetric(float64(stats.HeapObjects), \"HeapObjects\")\n\tb.StartTimer()\n}\n\n// go test -bench BenchmarkSize -run -\nfunc BenchmarkSizeBitset(b *testing.B) {\n\tb.StopTimer()\n\tr := rand.New(rand.NewSource(0))\n\ts1 := bitset.New(0)\n\tsz := 150000\n\tinitsize := 65000\n\tfor i := 0; i < initsize; i++ {\n\t\ts1.Set(uint(r.Int31n(int32(sz))))\n\t}\n\ts2 := bitset.New(0)\n\tsz = 100000000\n\tinitsize = 65000\n\tfor i := 0; i < initsize; i++ {\n\t\ts2.Set(uint(r.Int31n(int32(sz))))\n\t}\n\tb.ReportMetric(float64(s1.BinaryStorageSize()+s2.BinaryStorageSize())/(1024.0*1024), \"BitsetSizeInMB\")\n}\n\n// go test -bench BenchmarkSize -run -\nfunc BenchmarkSizeRoaring(b *testing.B) {\n\tb.StopTimer()\n\tr := rand.New(rand.NewSource(0))\n\ts1 := NewBitmap()\n\tsz := 150000\n\tinitsize := 65000\n\tfor i := 0; i < initsize; i++ {\n\t\ts1.Add(uint32(r.Int31n(int32(sz))))\n\t}\n\ts2 := NewBitmap()\n\tsz = 100000000\n\tinitsize = 65000\n\tfor i := 0; i < initsize; i++ {\n\t\ts2.Add(uint32(r.Int31n(int32(sz))))\n\t}\n\tb.ReportMetric(float64(s1.GetSerializedSizeInBytes()+s2.GetSerializedSizeInBytes())/(1024.0*1024), \"RoaringSizeInMB\")\n}\n"
        },
        {
          "name": "benchmark_test.go",
          "type": "blob",
          "size": 26.580078125,
          "content": "package roaring\n\nimport (\n\t\"bytes\"\n\t\"fmt\"\n\t\"math\"\n\t\"math/rand\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/require\"\n\n\t\"github.com/bits-and-blooms/bitset\"\n)\n\n// BENCHMARKS, to run them type \"go test -bench Benchmark -run -\"\n\n// go test -bench BenchmarkIteratorAlloc -benchmem -run -\nfunc BenchmarkIteratorAlloc(b *testing.B) {\n\tbm := NewBitmap()\n\tdomain := 100000000\n\tcount := 10000\n\tfor j := 0; j < count; j++ {\n\t\tv := uint32(rand.Intn(domain))\n\t\tbm.Add(v)\n\t}\n\ti := IntIterator{}\n\texpectedCardinality := bm.GetCardinality()\n\tcounter := uint64(0)\n\tb.Run(\"simple iteration with alloc\", func(b *testing.B) {\n\t\tfor n := 0; n < b.N; n++ {\n\t\t\tcounter = 0\n\t\t\ti := bm.Iterator()\n\t\t\tfor i.HasNext() {\n\t\t\t\ti.Next()\n\t\t\t\tcounter++\n\t\t\t}\n\t\t}\n\t\tb.StopTimer()\n\t})\n\tif counter != expectedCardinality {\n\t\tb.Fatalf(\"Cardinalities don't match: %d, %d\", counter, expectedCardinality)\n\t}\n\tb.Run(\"simple iteration\", func(b *testing.B) {\n\t\tfor n := 0; n < b.N; n++ {\n\t\t\tcounter = 0\n\t\t\ti.Initialize(bm)\n\t\t\tfor i.HasNext() {\n\t\t\t\ti.Next()\n\t\t\t\tcounter++\n\t\t\t}\n\t\t}\n\t\tb.StopTimer()\n\t})\n\tif counter != expectedCardinality {\n\t\tb.Fatalf(\"Cardinalities don't match: %d, %d\", counter, expectedCardinality)\n\t}\n\tb.Run(\"reverse iteration with alloc\", func(b *testing.B) {\n\t\tfor n := 0; n < b.N; n++ {\n\t\t\tcounter = 0\n\t\t\tir := bm.ReverseIterator()\n\t\t\tfor ir.HasNext() {\n\t\t\t\tir.Next()\n\t\t\t\tcounter++\n\t\t\t}\n\t\t}\n\t\tb.StopTimer()\n\t})\n\tif counter != expectedCardinality {\n\t\tb.Fatalf(\"Cardinalities don't match: %d, %d\", counter, expectedCardinality)\n\t}\n\tir := IntReverseIterator{}\n\n\tb.Run(\"reverse iteration\", func(b *testing.B) {\n\t\tfor n := 0; n < b.N; n++ {\n\t\t\tcounter = 0\n\t\t\tir.Initialize(bm)\n\t\t\tfor ir.HasNext() {\n\t\t\t\tir.Next()\n\t\t\t\tcounter++\n\t\t\t}\n\t\t}\n\t\tb.StopTimer()\n\t})\n\tif counter != expectedCardinality {\n\t\tb.Fatalf(\"Cardinalities don't match: %d, %d\", counter, expectedCardinality)\n\t}\n\n\tb.Run(\"many iteration with alloc\", func(b *testing.B) {\n\t\tfor n := 0; n < b.N; n++ {\n\t\t\tcounter = 0\n\t\t\tbuf := make([]uint32, 1024)\n\t\t\tim := bm.ManyIterator()\n\t\t\tfor n := im.NextMany(buf); n != 0; n = im.NextMany(buf) {\n\t\t\t\tcounter += uint64(n)\n\t\t\t}\n\t\t}\n\t\tb.StopTimer()\n\t})\n\tif counter != expectedCardinality {\n\t\tb.Fatalf(\"Cardinalities don't match: %d, %d\", counter, expectedCardinality)\n\t}\n\tim := ManyIntIterator{}\n\tbuf := make([]uint32, 1024)\n\n\tb.Run(\"many iteration\", func(b *testing.B) {\n\t\tfor n := 0; n < b.N; n++ {\n\t\t\tcounter = 0\n\t\t\tim.Initialize(bm)\n\t\t\tfor n := im.NextMany(buf); n != 0; n = im.NextMany(buf) {\n\t\t\t\tcounter += uint64(n)\n\t\t\t}\n\t\t}\n\t\tb.StopTimer()\n\t})\n\tif counter != expectedCardinality {\n\t\tb.Fatalf(\"Cardinalities don't match: %d, %d\", counter, expectedCardinality)\n\t}\n}\n\n// go test -bench BenchmarkOrs -benchmem -run -\nfunc BenchmarkOrs(b *testing.B) {\n\n\tbms := []*Bitmap{}\n\tmaxCount := 50\n\tdomain := 100000000\n\tbitmapCount := 100\n\tfor i := 0; i < bitmapCount; i++ {\n\t\tnewBm := NewBitmap()\n\t\tcount := rand.Intn(maxCount) + 5\n\t\tfor j := 0; j < count; j++ {\n\t\t\tv := uint32(rand.Intn(domain))\n\t\t\tnewBm.Add(v)\n\t\t}\n\t\tbms = append(bms, newBm)\n\t}\n\tvar twotwocard uint64\n\tvar fastcard uint64\n\tvar nextcard uint64\n\n\tb.Run(\"two-by-two\", func(b *testing.B) {\n\t\tfor n := 0; n < b.N; n++ {\n\t\t\tnewBm := NewBitmap()\n\t\t\tfor _, bm := range bms {\n\t\t\t\tnewBm.Or(bm)\n\t\t\t}\n\t\t\ttwotwocard = newBm.GetCardinality()\n\t\t}\n\t\tb.StopTimer()\n\t})\n\n\tb.Run(\"fast\", func(b *testing.B) {\n\t\tfor n := 0; n < b.N; n++ {\n\t\t\tnewBm := FastOr(bms...)\n\t\t\tfastcard = newBm.GetCardinality()\n\t\t}\n\t\tb.StopTimer()\n\t})\n\n\tb.Run(\"next/add\", func(b *testing.B) {\n\t\tbuf := make([]uint32, 100)\n\t\tfor n := 0; n < b.N; n++ {\n\t\t\tnewBm := NewBitmap()\n\t\t\tfor _, bm := range bms {\n\t\t\t\titer := bm.ManyIterator()\n\t\t\t\tfor vs := iter.NextMany(buf); vs != 0; vs = iter.NextMany(buf) {\n\t\t\t\t\tnewBm.AddMany(buf[:vs])\n\t\t\t\t}\n\t\t\t}\n\t\t\tnextcard = newBm.GetCardinality()\n\t\t}\n\t\tb.StopTimer()\n\t})\n\tif fastcard != nextcard {\n\t\tb.Fatalf(\"Cardinalities don't match: %d, %d\", fastcard, nextcard)\n\t}\n\tif fastcard != twotwocard {\n\t\tb.Fatalf(\"Cardinalities don't match: %d, %d\", fastcard, twotwocard)\n\t}\n}\n\nvar Rb *Bitmap\n\nfunc BenchmarkNewBitmap(b *testing.B) {\n\tb.ReportAllocs()\n\tfor i := 0; i < b.N; i++ {\n\t\tRb = New()\n\t}\n}\n\nvar emptyArray []byte\n\nfunc BenchmarkEmptyArray(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\temptyArray = make([]byte, 0)\n\t}\n}\n\nvar c9 uint\n\n// go test -bench BenchmarkIntersection -run -\nfunc BenchmarkIntersectionBitset(b *testing.B) {\n\tb.StopTimer()\n\tr := rand.New(rand.NewSource(0))\n\ts1 := bitset.New(0)\n\tsz := 150000\n\tinitsize := 65000\n\tfor i := 0; i < initsize; i++ {\n\t\ts1.Set(uint(r.Int31n(int32(sz))))\n\t}\n\ts2 := bitset.New(0)\n\tsz = 100000000\n\tinitsize = 65000\n\tfor i := 0; i < initsize; i++ {\n\t\ts2.Set(uint(r.Int31n(int32(sz))))\n\t}\n\tb.StartTimer()\n\tcard := uint(0)\n\tfor j := 0; j < b.N; j++ {\n\t\ts3 := s1.Intersection(s2)\n\t\tcard = card + s3.Count()\n\t}\n}\n\n// go test -bench BenchmarkIntersection -run -\nfunc BenchmarkIntersectionRoaring(b *testing.B) {\n\tb.StopTimer()\n\tr := rand.New(rand.NewSource(0))\n\ts1 := NewBitmap()\n\tsz := 150000\n\tinitsize := 65000\n\tfor i := 0; i < initsize; i++ {\n\t\ts1.Add(uint32(r.Int31n(int32(sz))))\n\t}\n\ts2 := NewBitmap()\n\tsz = 100000000\n\tinitsize = 65000\n\tfor i := 0; i < initsize; i++ {\n\t\ts2.Add(uint32(r.Int31n(int32(sz))))\n\t}\n\tb.StartTimer()\n\tcard := uint64(0)\n\tfor j := 0; j < b.N; j++ {\n\t\ts3 := And(s1, s2)\n\t\tcard = card + s3.GetCardinality()\n\t}\n}\n\n// go test -bench BenchmarkIntersectionCardinalityRoaring -run -\nfunc BenchmarkIntersectionCardinalityRoaring(b *testing.B) {\n\tb.StopTimer()\n\tr := rand.New(rand.NewSource(0))\n\ts1 := NewBitmap()\n\tsz := 150000\n\tinitsize := 65000\n\tfor i := 0; i < initsize; i++ {\n\t\ts1.Add(uint32(r.Int31n(int32(sz))))\n\t}\n\ts2 := NewBitmap()\n\tsz = 100000000\n\tinitsize = 65000\n\tfor i := 0; i < initsize; i++ {\n\t\ts2.Add(uint32(r.Int31n(int32(sz))))\n\t}\n\tb.StartTimer()\n\tcard := uint64(0)\n\tfor j := 0; j < b.N; j++ {\n\t\tcard += s1.AndCardinality(s2)\n\t}\n}\n\n// go test -bench BenchmarkUnion -run -\nfunc BenchmarkUnionBitset(b *testing.B) {\n\tb.StopTimer()\n\tr := rand.New(rand.NewSource(0))\n\ts1 := bitset.New(0)\n\tsz := 150000\n\tinitsize := 65000\n\tfor i := 0; i < initsize; i++ {\n\t\ts1.Set(uint(r.Int31n(int32(sz))))\n\t}\n\ts2 := bitset.New(0)\n\tsz = 100000000\n\tinitsize = 65000\n\tfor i := 0; i < initsize; i++ {\n\t\ts2.Set(uint(r.Int31n(int32(sz))))\n\t}\n\tb.StartTimer()\n\tcard := uint(0)\n\tfor j := 0; j < b.N; j++ {\n\t\ts3 := s1.Union(s2)\n\t\tcard = card + s3.Count()\n\t}\n}\n\n// go test -bench BenchmarkUnion -run -\nfunc BenchmarkUnionRoaring(b *testing.B) {\n\tb.StopTimer()\n\tr := rand.New(rand.NewSource(0))\n\ts1 := NewBitmap()\n\tsz := 150000\n\tinitsize := 65000\n\tfor i := 0; i < initsize; i++ {\n\t\ts1.Add(uint32(r.Int31n(int32(sz))))\n\t}\n\ts2 := NewBitmap()\n\tsz = 100000000\n\tinitsize = 65000\n\tfor i := 0; i < initsize; i++ {\n\t\ts2.Add(uint32(r.Int31n(int32(sz))))\n\t}\n\tb.StartTimer()\n\tcard := uint64(0)\n\tfor j := 0; j < b.N; j++ {\n\t\ts3 := Or(s1, s2)\n\t\tcard = card + s3.GetCardinality()\n\t}\n}\n\n// BenchmarkUnionInPlaceCopyOnWrite tests the performance of bitmap.Or()\n// when the bitmap was generated via FromBuffer.\n// In this case all left containers need to be copied in order to be updated.\n// The nested for-loops test a number of different scenarios\n// with respect to the ranges and densities of bitmaps.\nfunc BenchmarkUnionInPlaceCopyOnWrite(b *testing.B) {\n\t// uint32s to maintain 1.12 compatibility, which requires unsigned shifts.\n\tstartingContainerPower := uint32(4)\n\tfinalContainerPower := uint32(10)\n\tcontainerIncrement := uint32(3)\n\tstartingItemsPower := uint32(3)\n\tfinalItemsPower := uint32(10)\n\titemsIncrement := uint32(7)\n\tfor leftContainerPower := startingContainerPower; leftContainerPower <= finalContainerPower; leftContainerPower += containerIncrement {\n\t\tfor rightContainerPower := startingContainerPower; rightContainerPower <= finalContainerPower; rightContainerPower += containerIncrement {\n\t\t\tfor leftItemsPerContainerPower := startingItemsPower; leftItemsPerContainerPower <= finalItemsPower; leftItemsPerContainerPower += itemsIncrement {\n\t\t\t\tfor rightItemsPerContainerPower := startingItemsPower; rightItemsPerContainerPower <= finalItemsPower; rightItemsPerContainerPower += itemsIncrement {\n\t\t\t\t\tb.Run(fmt.Sprintf(\"%d-%d-%d-%d\", leftContainerPower, rightContainerPower, leftItemsPerContainerPower, rightItemsPerContainerPower),\n\t\t\t\t\t\tfunc(b *testing.B) {\n\t\t\t\t\t\t\tleftMax := (1 << 16) << leftContainerPower\n\t\t\t\t\t\t\trightMax := (1 << 16) << rightContainerPower\n\t\t\t\t\t\t\tleftItems := 1 << (leftContainerPower + leftItemsPerContainerPower)\n\t\t\t\t\t\t\trightItems := 1 << (rightContainerPower + rightItemsPerContainerPower)\n\t\t\t\t\t\t\tleft := make([][]byte, 10)\n\t\t\t\t\t\t\tright := make([]*Bitmap, 10)\n\t\t\t\t\t\t\tfor i := 0; i < 10; i++ {\n\t\t\t\t\t\t\t\tright[i] = NewBitmap()\n\t\t\t\t\t\t\t\tleft[i] = generateRandomBitmap(b, leftMax, leftItems)\n\t\t\t\t\t\t\t\t_, err := right[i].FromBuffer(generateRandomBitmap(b, rightMax, rightItems))\n\t\t\t\t\t\t\t\trequire.NoError(b, err)\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t// This tests a destructive operation, Or() so have to have a fresh bitmap per test.\n\t\t\t\t\t\t\ttargetLefts := make([]*Bitmap, b.N)\n\t\t\t\t\t\t\tfor i := 0; i < b.N; i++ {\n\t\t\t\t\t\t\t\ttargetLefts[i] = NewBitmap()\n\t\t\t\t\t\t\t\t_, err := targetLefts[i].FromBuffer(left[i%10])\n\t\t\t\t\t\t\t\trequire.NoError(b, err)\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\trunActualBenchmark(b, targetLefts, right)\n\t\t\t\t\t\t})\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n// runActualBenchmark is broken out primarily so you can profile the tests,\n// as otherwise the generation overwhelms the actual test.\nfunc runActualBenchmark(b *testing.B, targetLefts []*Bitmap, right []*Bitmap) uint64 {\n\tb.ResetTimer()\n\tb.ReportAllocs()\n\ttotal := uint64(0)\n\tfor i := 0; i < b.N; i++ {\n\t\ttargetLefts[i].Or(right[i%10])\n\t\ttotal += targetLefts[i].GetCardinality()\n\t}\n\treturn total\n}\n\nfunc generateRandomBitmap(b *testing.B, max, terms int) []byte {\n\tbitmap := NewBitmap()\n\tfor i := 0; i < terms; i++ {\n\t\tbitmap.Add(uint32(rand.Intn(max)))\n\t}\n\tresult, err := bitmap.ToBytes()\n\trequire.NoError(b, err)\n\treturn result\n}\n\nfunc BenchmarkChecksum(b *testing.B) {\n\tfor terms := 1; terms <= (1 << 20); terms *= 2 {\n\t\trb1, rb2 := NewBitmap(), NewBitmap()\n\t\tset := map[uint32]struct{}{}\n\t\tfor len(set) < terms {\n\t\t\tv := uint32(rand.Intn(1500000))\n\t\t\tset[v] = struct{}{}\n\t\t\trb1.Add(v)\n\t\t\trb2.AddRange(uint64(v), uint64(v)+100)\n\t\t}\n\t\trb2.RunOptimize()\n\n\t\tb.Run(fmt.Sprintf(\"checksum-%d\", terms), func(b *testing.B) {\n\t\t\tb.ReportAllocs()\n\t\t\trb1.Checksum()\n\t\t})\n\t\tb.Run(fmt.Sprintf(\"checksum-compressed-%d\", terms), func(b *testing.B) {\n\t\t\tb.ReportAllocs()\n\t\t\trb2.Checksum()\n\t\t})\n\t}\n}\n\n// go test -bench BenchmarkSet -run -\nfunc BenchmarkSetRoaring(b *testing.B) {\n\tb.StopTimer()\n\tr := rand.New(rand.NewSource(0))\n\tsz := 1000000\n\ts := NewBitmap()\n\tb.StartTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\ts.Add(uint32(r.Int31n(int32(sz))))\n\t}\n}\n\nfunc BenchmarkSetBitset(b *testing.B) {\n\tb.StopTimer()\n\tr := rand.New(rand.NewSource(0))\n\tsz := 1000000\n\ts := bitset.New(0)\n\tb.StartTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\ts.Set(uint(r.Int31n(int32(sz))))\n\t}\n}\n\n// go test -bench BenchmarkGetTest -run -\nfunc BenchmarkGetTestRoaring(b *testing.B) {\n\tb.StopTimer()\n\tr := rand.New(rand.NewSource(0))\n\tsz := 1000000\n\tinitsize := 50000\n\ts := NewBitmap()\n\tfor i := 0; i < initsize; i++ {\n\t\ts.Add(uint32(r.Int31n(int32(sz))))\n\t}\n\tb.StartTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\ts.Contains(uint32(r.Int31n(int32(sz))))\n\t}\n}\n\nfunc BenchmarkGetTestBitSet(b *testing.B) {\n\tb.StopTimer()\n\tr := rand.New(rand.NewSource(0))\n\tsz := 1000000\n\tinitsize := 50000\n\ts := bitset.New(0)\n\tfor i := 0; i < initsize; i++ {\n\t\ts.Set(uint(r.Int31n(int32(sz))))\n\t}\n\tb.StartTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\ts.Test(uint(r.Int31n(int32(sz))))\n\t}\n}\n\n// go test -bench BenchmarkCount -run -\nfunc BenchmarkCountRoaring(b *testing.B) {\n\tb.StopTimer()\n\tr := rand.New(rand.NewSource(0))\n\ts := NewBitmap()\n\tsz := 1000000\n\tinitsize := 50000\n\tfor i := 0; i < initsize; i++ {\n\t\ts.Add(uint32(r.Int31n(int32(sz))))\n\t}\n\tb.StartTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\ts.GetCardinality()\n\t}\n}\n\nfunc BenchmarkCountBitset(b *testing.B) {\n\tb.StopTimer()\n\tr := rand.New(rand.NewSource(0))\n\ts := bitset.New(0)\n\tsz := 1000000\n\tinitsize := 50000\n\tfor i := 0; i < initsize; i++ {\n\n\t\ts.Set(uint(r.Int31n(int32(sz))))\n\t}\n\tb.StartTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\ts.Count()\n\t}\n}\n\n// go test -bench BenchmarkIterate -run -\nfunc BenchmarkIterateRoaring(b *testing.B) {\n\tnewBitmap := func() *Bitmap {\n\t\tr := rand.New(rand.NewSource(0))\n\t\ts := NewBitmap()\n\t\tsz := 150000\n\t\tinitsize := 65000\n\t\tfor i := 0; i < initsize; i++ {\n\t\t\ts.Add(uint32(r.Int31n(int32(sz))))\n\t\t}\n\t\treturn s\n\t}\n\n\tb.Run(\"iterator-compressed\", func(b *testing.B) {\n\t\tb.ReportAllocs()\n\n\t\ts := newBitmap()\n\t\ts.RunOptimize()\n\n\t\tb.ResetTimer()\n\n\t\tfor j := 0; j < b.N; j++ {\n\t\t\tc9 = uint(0)\n\t\t\ti := s.Iterator()\n\t\t\tfor i.HasNext() {\n\t\t\t\ti.Next()\n\t\t\t\tc9++\n\t\t\t}\n\t\t}\n\t})\n\n\tb.Run(\"iterator\", func(b *testing.B) {\n\t\tb.ReportAllocs()\n\n\t\ts := newBitmap()\n\n\t\tb.ResetTimer()\n\n\t\tfor j := 0; j < b.N; j++ {\n\t\t\tc9 = uint(0)\n\t\t\ti := s.Iterator()\n\t\t\tfor i.HasNext() {\n\t\t\t\ti.Next()\n\t\t\t\tc9++\n\t\t\t}\n\t\t}\n\t})\n\n\tb.Run(\"iterate-compressed\", func(b *testing.B) {\n\t\tb.ReportAllocs()\n\n\t\ts := newBitmap()\n\t\ts.RunOptimize()\n\n\t\tb.ResetTimer()\n\n\t\tfor j := 0; j < b.N; j++ {\n\t\t\tc9 = uint(0)\n\t\t\ts.Iterate(func(x uint32) bool {\n\t\t\t\tc9++\n\t\t\t\treturn true\n\t\t\t})\n\t\t}\n\t})\n\n\tb.Run(\"iterate\", func(b *testing.B) {\n\t\tb.ReportAllocs()\n\n\t\ts := newBitmap()\n\n\t\tb.ResetTimer()\n\n\t\tfor j := 0; j < b.N; j++ {\n\t\t\tc9 = uint(0)\n\t\t\ts.Iterate(func(x uint32) bool {\n\t\t\t\tc9++\n\t\t\t\treturn true\n\t\t\t})\n\t\t}\n\t})\n}\n\n// go test -bench BenchmarkSparseIterate -run -\nfunc BenchmarkSparseIterateRoaring(b *testing.B) {\n\tb.StopTimer()\n\tr := rand.New(rand.NewSource(0))\n\ts := NewBitmap()\n\tsz := 100000000\n\tinitsize := 65000\n\tfor i := 0; i < initsize; i++ {\n\t\ts.Add(uint32(r.Int31n(int32(sz))))\n\t}\n\tb.StartTimer()\n\tfor j := 0; j < b.N; j++ {\n\t\tc9 = uint(0)\n\t\ti := s.Iterator()\n\t\tfor i.HasNext() {\n\t\t\ti.Next()\n\t\t\tc9++\n\t\t}\n\t}\n\n}\n\n// go test -bench BenchmarkSparseAdvance -run -\nfunc BenchmarkSparseAdvanceRoaring(b *testing.B) {\n\tb.StopTimer()\n\n\ts := NewBitmap()\n\tinitsize := 65000\n\n\tfor i := 0; i < initsize; i++ {\n\t\ts.Add(uint32(i))\n\t}\n\n\tfor _, gap := range []int{1, 2, 65, 650} {\n\t\tb.Run(fmt.Sprintf(\"advance from %d\", gap), func(b *testing.B) {\n\t\t\tb.ReportAllocs()\n\t\t\tb.StartTimer()\n\n\t\t\tdiff := uint32(0)\n\n\t\t\tfor n := 0; n < b.N; n++ {\n\t\t\t\tval := uint32((gap * n) % initsize)\n\n\t\t\t\ti := s.Iterator()\n\t\t\t\ti.AdvanceIfNeeded(val)\n\n\t\t\t\tdiff += i.PeekNext() - val\n\t\t\t}\n\n\t\t\tb.StopTimer()\n\n\t\t\tif diff != 0 {\n\t\t\t\tb.Fatalf(\"Expected diff 0, got %d\", diff)\n\t\t\t}\n\t\t})\n\t}\n}\n\n// go test -bench BenchmarkSparseAdvance -run -\nfunc BenchmarkSparseAdvanceOnHugeData(b *testing.B) {\n\tb.ReportAllocs()\n\n\ts := NewBitmap()\n\tinitsize := 6500000\n\tsz := 100000000\n\tr := rand.New(rand.NewSource(0))\n\n\tfor i := 0; i < initsize; i++ {\n\t\ts.Add(uint32(r.Int31n(int32(sz))))\n\t}\n\n\tb.ResetTimer()\n\n\tfor n := 0; n < b.N; n++ {\n\t\tval := uint32(n)\n\n\t\ti := s.Iterator()\n\t\ti.AdvanceIfNeeded(val)\n\t}\n}\n\n// go test -bench BenchmarkSparseAdvance -run -\nfunc BenchmarkSparseAdvanceSequentially(b *testing.B) {\n\tb.StopTimer()\n\n\ts := NewBitmap()\n\tinitsize := 65000\n\n\tfor i := 0; i < initsize; i++ {\n\t\ts.Add(uint32(i))\n\t}\n\n\tfor _, gap := range []int{1, 2, 65, 650} {\n\t\tb.Run(fmt.Sprintf(\"advance from %d\", gap), func(b *testing.B) {\n\t\t\tb.ReportAllocs()\n\t\t\tb.StartTimer()\n\n\t\t\tdiff := uint32(0)\n\n\t\t\tfor n := 0; n < b.N; n++ {\n\t\t\t\tval := uint32((gap * n) % initsize)\n\n\t\t\t\ti := s.Iterator()\n\n\t\t\t\tfor i.HasNext() && i.PeekNext() < val {\n\t\t\t\t\ti.Next()\n\t\t\t\t}\n\n\t\t\t\tdiff += i.PeekNext() - val\n\t\t\t}\n\n\t\t\tb.StopTimer()\n\n\t\t\tif diff != 0 {\n\t\t\t\tb.Fatalf(\"Expected diff 0, got %d\", diff)\n\t\t\t}\n\t\t})\n\t}\n}\n\n// go test -bench BenchmarkIterate -run -\nfunc BenchmarkIterateBitset(b *testing.B) {\n\tb.StopTimer()\n\tr := rand.New(rand.NewSource(0))\n\ts := bitset.New(0)\n\tsz := 150000\n\tinitsize := 65000\n\tfor i := 0; i < initsize; i++ {\n\t\ts.Set(uint(r.Int31n(int32(sz))))\n\t}\n\tb.StartTimer()\n\tfor j := 0; j < b.N; j++ {\n\t\tc9 = uint(0)\n\t\tfor i, e := s.NextSet(0); e; i, e = s.NextSet(i + 1) {\n\t\t\tc9++\n\t\t}\n\t}\n}\n\n// go test -bench BenchmarkSparseContains -run -\nfunc BenchmarkSparseContains(b *testing.B) {\n\tb.StopTimer()\n\tr := rand.New(rand.NewSource(0))\n\ts := NewBitmap()\n\tsz := 10000000\n\tinitsize := 65000\n\tfor i := 0; i < initsize; i++ {\n\t\ts.Add(uint32(r.Int31n(int32(sz))))\n\t}\n\tvar a [1024]uint32\n\tfor i := 0; i < 1024; i++ {\n\t\ta[i] = uint32(r.Int31n(int32(sz)))\n\t}\n\tb.StartTimer()\n\tfor j := 0; j < b.N; j++ {\n\t\tc9 = uint(0)\n\t\tfor i := 0; i < 1024; i++ {\n\t\t\tif s.Contains(a[i]) {\n\t\t\t\tc9++\n\t\t\t}\n\n\t\t}\n\t}\n}\n\n// go test -bench BenchmarkSparseIterate -run -\nfunc BenchmarkSparseIterateBitset(b *testing.B) {\n\tb.StopTimer()\n\tr := rand.New(rand.NewSource(0))\n\ts := bitset.New(0)\n\tsz := 100000000\n\tinitsize := 65000\n\tfor i := 0; i < initsize; i++ {\n\t\ts.Set(uint(r.Int31n(int32(sz))))\n\t}\n\tb.StartTimer()\n\tfor j := 0; j < b.N; j++ {\n\t\tc9 = uint(0)\n\t\tfor i, e := s.NextSet(0); e; i, e = s.NextSet(i + 1) {\n\t\t\tc9++\n\t\t}\n\t}\n}\n\nfunc BenchmarkSerializationSparse(b *testing.B) {\n\tb.ReportAllocs()\n\tb.StopTimer()\n\tr := rand.New(rand.NewSource(0))\n\ts := NewBitmap()\n\tsz := 100000000\n\tinitsize := 65000\n\tfor i := 0; i < initsize; i++ {\n\t\ts.Add(uint32(r.Int31n(int32(sz))))\n\t}\n\tbuf := make([]byte, 0, s.GetSerializedSizeInBytes())\n\tb.StartTimer()\n\n\tfor j := 0; j < b.N; j++ {\n\t\tw := bytes.NewBuffer(buf[:0])\n\t\ts.WriteTo(w)\n\t}\n}\n\nfunc BenchmarkSerializationMid(b *testing.B) {\n\tb.ReportAllocs()\n\tb.StopTimer()\n\tr := rand.New(rand.NewSource(0))\n\ts := NewBitmap()\n\tsz := 10000000\n\tinitsize := 65000\n\tfor i := 0; i < initsize; i++ {\n\t\ts.Add(uint32(r.Int31n(int32(sz))))\n\t}\n\tbuf := make([]byte, 0, s.GetSerializedSizeInBytes())\n\tb.StartTimer()\n\n\tfor j := 0; j < b.N; j++ {\n\t\tw := bytes.NewBuffer(buf[:0])\n\t\ts.WriteTo(w)\n\t}\n}\n\nfunc BenchmarkSerializationDense(b *testing.B) {\n\tb.ReportAllocs()\n\tb.StopTimer()\n\tr := rand.New(rand.NewSource(0))\n\ts := NewBitmap()\n\tsz := 150000\n\tinitsize := 65000\n\tfor i := 0; i < initsize; i++ {\n\t\ts.Add(uint32(r.Int31n(int32(sz))))\n\t}\n\tbuf := make([]byte, 0, s.GetSerializedSizeInBytes())\n\tb.StartTimer()\n\n\tfor j := 0; j < b.N; j++ {\n\t\tw := bytes.NewBuffer(buf[:0])\n\t\ts.WriteTo(w)\n\t}\n}\n\nfunc BenchmarkMarshalBinary(b *testing.B) {\n\tr := rand.New(rand.NewSource(0))\n\ts := NewBitmap()\n\tsz := 10000000\n\tinitsize := 65000\n\tfor i := 0; i < initsize; i++ {\n\t\ts.Add(uint32(r.Int31n(int32(sz))))\n\t}\n\tb.ReportAllocs()\n\tb.ResetTimer()\n\tfor j := 0; j < b.N; j++ {\n\t\ts.MarshalBinary()\n\t}\n}\n\nfunc BenchmarkUnmarshalBinary(b *testing.B) {\n\tr := rand.New(rand.NewSource(0))\n\ts := NewBitmap()\n\tsz := 10000000\n\tinitsize := 65000\n\tfor i := 0; i < initsize; i++ {\n\t\ts.Add(uint32(r.Int31n(int32(sz))))\n\t}\n\tdata, _ := s.MarshalBinary()\n\tb.ReportAllocs()\n\tb.ResetTimer()\n\tfor j := 0; j < b.N; j++ {\n\t\tub := NewBitmap()\n\t\tub.UnmarshalBinary(data)\n\t}\n}\n\nfunc BenchmarkEqualsSparse(b *testing.B) {\n\tb.StopTimer()\n\tr := rand.New(rand.NewSource(0))\n\ts := NewBitmap()\n\tt := NewBitmap()\n\tsz := 100000000\n\tinitsize := 65000\n\tfor i := 0; i < initsize; i++ {\n\t\tn := uint32(r.Int31n(int32(sz)))\n\t\ts.Add(n)\n\t\tt.Add(n)\n\t}\n\tb.StartTimer()\n\n\tfor j := 0; j < b.N; j++ {\n\t\ts.Equals(t)\n\t}\n}\n\nfunc BenchmarkEqualsClone(b *testing.B) {\n\tb.StopTimer()\n\tr := rand.New(rand.NewSource(0))\n\ts := NewBitmap()\n\tsz := 100000000\n\tinitsize := 65000\n\tfor i := 0; i < initsize; i++ {\n\t\ts.Add(uint32(r.Int31n(int32(sz))))\n\t}\n\tt := s.Clone()\n\tb.StartTimer()\n\n\tfor j := 0; j < b.N; j++ {\n\t\ts.Equals(t)\n\t}\n}\n\n// go test -bench BenchmarkNexts -benchmem -run -\nfunc BenchmarkNexts(b *testing.B) {\n\n\tfor _, gap := range []uint32{1, 2, 4, 8, 16, 32, 64, 256, 1024, 8096} {\n\n\t\trrs := make([]uint32, 500000)\n\t\tv := uint32(0)\n\t\tfor i := range rrs {\n\t\t\trrs[i] = v\n\t\t\tv += gap\n\t\t}\n\n\t\tbm := NewBitmap()\n\t\tbm.AddMany(rrs)\n\n\t\tvar totnext uint64\n\t\tvar totnextmany uint64\n\n\t\tdensity := float32(100) / float32(gap)\n\n\t\tdensityStr := fmt.Sprintf(\"__%f%%\", density)\n\n\t\tb.Run(\"next\"+densityStr, func(b *testing.B) {\n\t\t\tfor n := 0; n < b.N; n++ {\n\t\t\t\ttotnext = 0\n\t\t\t\titer := bm.Iterator()\n\t\t\t\tfor iter.HasNext() {\n\t\t\t\t\tv := iter.Next()\n\t\t\t\t\ttotnext += uint64(v)\n\t\t\t\t}\n\t\t\t}\n\t\t\tb.StopTimer()\n\t\t})\n\n\t\tb.Run(\"nextmany\"+densityStr, func(b *testing.B) {\n\t\t\tfor n := 0; n < b.N; n++ {\n\t\t\t\ttotnextmany = 0\n\t\t\t\titer := bm.ManyIterator()\n\t\t\t\t// worst case, in practice will reuse buffers across many roars\n\t\t\t\tbuf := make([]uint32, 4096)\n\t\t\t\tfor j := iter.NextMany(buf); j != 0; j = iter.NextMany(buf) {\n\t\t\t\t\tfor i := 0; i < j; i++ {\n\t\t\t\t\t\ttotnextmany += uint64(buf[i])\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tb.StopTimer()\n\t\t})\n\n\t\tif totnext != totnextmany {\n\t\t\tb.Fatalf(\"Cardinalities don't match: %d, %d\", totnext, totnextmany)\n\t\t}\n\t}\n}\n\n// go test -bench BenchmarkRLENexts -benchmem -run -\nfunc BenchmarkNextsRLE(b *testing.B) {\n\n\tvar totadd uint64\n\tvar totaddmany uint64\n\n\tbm := NewBitmap()\n\tbm.AddRange(0, 1000000)\n\n\tb.Run(\"next\", func(b *testing.B) {\n\t\tfor n := 0; n < b.N; n++ {\n\t\t\ttotadd = 0\n\t\t\titer := bm.Iterator()\n\t\t\tfor iter.HasNext() {\n\t\t\t\tv := iter.Next()\n\t\t\t\ttotadd += uint64(v)\n\t\t\t}\n\t\t}\n\t\tb.StopTimer()\n\t})\n\n\tb.Run(\"nextmany\", func(b *testing.B) {\n\t\tfor n := 0; n < b.N; n++ {\n\t\t\ttotaddmany = 0\n\t\t\titer := bm.ManyIterator()\n\t\t\t// worst case, in practice will reuse buffers across many roars\n\t\t\tbuf := make([]uint32, 2048)\n\t\t\tfor j := iter.NextMany(buf); j != 0; j = iter.NextMany(buf) {\n\t\t\t\tfor i := 0; i < j; i++ {\n\t\t\t\t\ttotaddmany += uint64(buf[i])\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tb.StopTimer()\n\t})\n\tif totadd != totaddmany {\n\t\tb.Fatalf(\"Cardinalities don't match: %d, %d\", totadd, totaddmany)\n\t}\n\n}\n\nfunc BenchmarkXor(b *testing.B) {\n\tb.StopTimer()\n\tr := rand.New(rand.NewSource(0))\n\ts := NewBitmap()\n\tsz := 100000000\n\tinitsize := 65000\n\tfor i := 0; i < initsize; i++ {\n\t\tn := uint32(r.Int31n(int32(sz)))\n\t\ts.Add(n)\n\t}\n\tx2 := NewBitmap()\n\tfor i := 0; i < initsize; i++ {\n\t\tn := uint32(r.Int31n(int32(sz)))\n\t\tx2.Add(n)\n\t}\n\tb.StartTimer()\n\n\tfor j := 0; j < b.N; j++ {\n\t\ts.Clone().Xor(x2)\n\t}\n}\n\nfunc BenchmarkXorLopsided(b *testing.B) {\n\tb.StopTimer()\n\tr := rand.New(rand.NewSource(0))\n\ts := NewBitmap()\n\tsz := 100000000\n\tinitsize := 65000\n\tfor i := 0; i < initsize; i++ {\n\t\tn := uint32(r.Int31n(int32(sz)))\n\t\ts.Add(n)\n\t}\n\tx2 := NewBitmap()\n\tfor i := 0; i < 32; i++ {\n\t\tn := uint32(r.Int31n(int32(sz)))\n\t\tx2.Add(n)\n\t}\n\tb.StartTimer()\n\n\tfor j := 0; j < b.N; j++ {\n\t\ts.Clone().Xor(x2)\n\t}\n}\n\nfunc BenchmarkBitmapReuseWithoutClear(b *testing.B) {\n\tfor j := 0; j < b.N; j++ {\n\t\ts := NewBitmap()\n\t\tfor i := 0; i < 100000; i++ {\n\t\t\ts.Add(uint32(i * 4096))\n\t\t}\n\t}\n}\n\nfunc BenchmarkBitmapReuseWithClear(b *testing.B) {\n\ts := NewBitmap()\n\tfor i := 0; i < 100000; i++ {\n\t\ts.Add(uint32(i * 4096))\n\t}\n\tb.ResetTimer()\n\n\tfor j := 0; j < b.N; j++ {\n\t\ts.Clear() // reuse the same bitmap\n\t\tfor i := 0; i < 100000; i++ {\n\t\t\ts.Add(uint32(i * 4096))\n\t\t}\n\t}\n}\n\nfunc BenchmarkAndAny(b *testing.B) {\n\trunSet := func(name string, base *Bitmap, filters []*Bitmap) {\n\t\tvar (\n\t\t\tandFirstCard, orFirstCard, andAnyCard uint64\n\t\t\tandFirstRan, orFirstRan, andAnyRan    bool\n\t\t)\n\n\t\tb.Run(name+\"_or-first\", func(b *testing.B) {\n\t\t\tandAnyRan = true\n\t\t\tfor n := 0; n < b.N; n++ {\n\t\t\t\tclone := base.Clone()\n\n\t\t\t\tb.StartTimer()\n\t\t\t\tclone.And(FastOr(filters...))\n\t\t\t\torFirstCard = clone.GetCardinality()\n\t\t\t\tb.StopTimer()\n\t\t\t}\n\t\t})\n\n\t\tb.Run(name+\"_and-first\", func(b *testing.B) {\n\t\t\torFirstRan = true\n\t\t\tfor n := 0; n < b.N; n++ {\n\t\t\t\tanded := make([]*Bitmap, 0, len(filters))\n\n\t\t\t\tb.StartTimer()\n\t\t\t\tfor _, f := range filters {\n\t\t\t\t\tanded = append(anded, And(base, f))\n\t\t\t\t}\n\t\t\t\tandFirstCard = FastOr(anded...).GetCardinality()\n\t\t\t\tb.StopTimer()\n\t\t\t}\n\t\t})\n\n\t\tb.Run(name+\"_AndAny\", func(b *testing.B) {\n\t\t\tandAnyRan = true\n\t\t\tfor n := 0; n < b.N; n++ {\n\t\t\t\tclone := base.Clone()\n\n\t\t\t\tb.StartTimer()\n\t\t\t\tclone.AndAny(filters...)\n\t\t\t\tandAnyCard = clone.GetCardinality()\n\t\t\t\tb.StopTimer()\n\t\t\t}\n\t\t})\n\n\t\tif andFirstRan && andAnyRan && andFirstCard != andAnyCard {\n\t\t\tb.Fatalf(\"Cardinalities don't match: %d, %d\", andFirstCard, andAnyCard)\n\t\t}\n\t\tif orFirstRan && andAnyRan && orFirstCard != andAnyCard {\n\t\t\tb.Fatalf(\"Cardinalities don't match: %d, %d\", orFirstCard, andAnyCard)\n\t\t}\n\t}\n\n\tr := rand.New(rand.NewSource(0))\n\n\tgenOne := func(r *rand.Rand, maxCount, domain int) *Bitmap {\n\t\tret := NewBitmap()\n\t\tcount := r.Intn(maxCount) + 5\n\t\tfor j := 0; j < count; j++ {\n\t\t\tv := uint32(r.Intn(domain))\n\t\t\tret.Add(v)\n\t\t}\n\t\treturn ret\n\t}\n\n\tgenMulti := func(r *rand.Rand, num, maxCount, domain int) []*Bitmap {\n\t\tvar ret []*Bitmap\n\t\tfor i := 0; i < num; i++ {\n\t\t\tret = append(ret, genOne(r, maxCount, domain))\n\t\t}\n\t\treturn ret\n\t}\n\n\tfiltersNum := 10\n\tdomain := 100000000\n\n\tsmallSize := 100\n\tdefaultSize := 100000\n\tlargeSize := 1000000\n\n\trunSet(\"small-base\", genOne(r, smallSize, domain), genMulti(r, filtersNum, largeSize, domain))\n\trunSet(\"small-filters\", genOne(r, largeSize, domain), genMulti(r, filtersNum, smallSize, domain))\n\trunSet(\"equal\", genOne(r, defaultSize, domain), genMulti(r, filtersNum, defaultSize, domain))\n}\n\nfunc BenchmarkAndNot(b *testing.B) {\n\ttype generator struct {\n\t\tname string\n\t\tf    func() *Bitmap\n\t}\n\tmakeRunContainer := generator{\n\t\tname: \"run\",\n\t\tf: func() *Bitmap {\n\t\t\trb := NewBitmap()\n\t\t\tfor i := 0; i < 100; i++ {\n\t\t\t\tstart := rand.Intn(math.MaxUint16)\n\t\t\t\tlimit := start + rand.Intn(math.MaxUint16-start)\n\t\t\t\trb.AddRange(uint64(start), uint64(limit))\n\t\t\t}\n\t\t\trb.RunOptimize()\n\t\t\treturn rb\n\t\t},\n\t}\n\n\tmakeArrayContainer := generator{\n\t\tname: \"array\",\n\t\tf: func() *Bitmap {\n\t\t\trb := NewBitmap()\n\t\t\tfor i := 0; i < arrayDefaultMaxSize/2; i++ {\n\t\t\t\trb.Add(uint32(rand.Intn(math.MaxUint16)))\n\t\t\t}\n\t\t\treturn rb\n\t\t},\n\t}\n\tmakeBitmapContainer := generator{\n\t\tname: \"bitmap\",\n\t\tf: func() *Bitmap {\n\t\t\tbuf := make([]uint64, 1024)\n\t\t\tfor i := range buf {\n\t\t\t\tbuf[i] = rand.Uint64()\n\t\t\t}\n\n\t\t\treturn FromDense(buf, false)\n\t\t},\n\t}\n\n\tfor _, inPlace := range []bool{true, false} {\n\t\tb.Run(fmt.Sprintf(\"inPlace=%v\", inPlace), func(b *testing.B) {\n\t\t\tfor _, leftGen := range []generator{makeRunContainer, makeArrayContainer, makeBitmapContainer} {\n\t\t\t\tb.Run(fmt.Sprintf(\"left=%s\", leftGen.name), func(b *testing.B) {\n\t\t\t\t\tfor _, rightGen := range []generator{makeRunContainer, makeArrayContainer, makeBitmapContainer} {\n\t\t\t\t\t\tb.Run(fmt.Sprintf(\"right=%s\", rightGen.name), func(b *testing.B) {\n\t\t\t\t\t\t\tb.ReportAllocs()\n\t\t\t\t\t\t\tb.StopTimer()\n\t\t\t\t\t\t\tserializedLefts := make([][]byte, 1000)\n\t\t\t\t\t\t\tfor i := range serializedLefts {\n\t\t\t\t\t\t\t\tvar err error\n\t\t\t\t\t\t\t\tserializedLefts[i], err = leftGen.f().ToBytes()\n\t\t\t\t\t\t\t\tif err != nil {\n\t\t\t\t\t\t\t\t\tb.Fatal(err)\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tserializedRights := make([][]byte, 1000)\n\t\t\t\t\t\t\tfor i := range serializedRights {\n\t\t\t\t\t\t\t\tvar err error\n\t\t\t\t\t\t\t\tserializedRights[i], err = rightGen.f().ToBytes()\n\t\t\t\t\t\t\t\tif err != nil {\n\t\t\t\t\t\t\t\t\tb.Fatal(err)\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tlefts := make([]*Bitmap, b.N)\n\t\t\t\t\t\t\tfor i := range lefts {\n\t\t\t\t\t\t\t\tbuf := serializedLefts[i%len(serializedLefts)]\n\t\t\t\t\t\t\t\tlefts[i] = NewBitmap()\n\t\t\t\t\t\t\t\tif _, err := lefts[i].FromBuffer(buf); err != nil {\n\t\t\t\t\t\t\t\t\tb.Fatal(err)\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tlefts[i] = lefts[i].Clone()\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\trights := make([]*Bitmap, b.N)\n\t\t\t\t\t\t\tfor i := range rights {\n\t\t\t\t\t\t\t\tbuf := serializedRights[i%len(serializedRights)]\n\t\t\t\t\t\t\t\trights[i] = NewBitmap()\n\t\t\t\t\t\t\t\tif _, err := rights[i].FromBuffer(buf); err != nil {\n\t\t\t\t\t\t\t\t\tb.Fatal(err)\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\trights[i] = rights[i].Clone()\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tb.StartTimer()\n\t\t\t\t\t\t\tfor i := 0; i < b.N; i++ {\n\t\t\t\t\t\t\t\tif inPlace {\n\t\t\t\t\t\t\t\t\tlefts[i].AndNot(rights[i])\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t_ = AndNot(lefts[i], rights[i])\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t})\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t}\n\t\t})\n\t}\n}\n"
        },
        {
          "name": "bitmapcontainer.go",
          "type": "blob",
          "size": 34.2529296875,
          "content": "package roaring\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"math/bits\"\n\t\"unsafe\"\n)\n\ntype bitmapContainer struct {\n\tcardinality int\n\tbitmap      []uint64\n}\n\nfunc (bc bitmapContainer) String() string {\n\tvar s string\n\tfor it := bc.getShortIterator(); it.hasNext(); {\n\t\ts += fmt.Sprintf(\"%v, \", it.next())\n\t}\n\treturn s\n}\n\nfunc newBitmapContainer() *bitmapContainer {\n\tp := new(bitmapContainer)\n\tsize := (1 << 16) / 64\n\tp.bitmap = make([]uint64, size, size)\n\treturn p\n}\n\nfunc newBitmapContainerwithRange(firstOfRun, lastOfRun int) *bitmapContainer {\n\tbc := newBitmapContainer()\n\tbc.cardinality = lastOfRun - firstOfRun + 1\n\tif bc.cardinality == maxCapacity {\n\t\tfill(bc.bitmap, uint64(0xffffffffffffffff))\n\t} else {\n\t\tfirstWord := firstOfRun / 64\n\t\tlastWord := lastOfRun / 64\n\t\tzeroPrefixLength := uint64(firstOfRun & 63)\n\t\tzeroSuffixLength := uint64(63 - (lastOfRun & 63))\n\n\t\tfillRange(bc.bitmap, firstWord, lastWord+1, uint64(0xffffffffffffffff))\n\t\tbc.bitmap[firstWord] ^= ((uint64(1) << zeroPrefixLength) - 1)\n\t\tblockOfOnes := (uint64(1) << zeroSuffixLength) - 1\n\t\tmaskOnLeft := blockOfOnes << (uint64(64) - zeroSuffixLength)\n\t\tbc.bitmap[lastWord] ^= maskOnLeft\n\t}\n\treturn bc\n}\n\nfunc (bc *bitmapContainer) minimum() uint16 {\n\tfor i := 0; i < len(bc.bitmap); i++ {\n\t\tw := bc.bitmap[i]\n\t\tif w != 0 {\n\t\t\tr := countTrailingZeros(w)\n\t\t\treturn uint16(r + i*64)\n\t\t}\n\t}\n\treturn MaxUint16\n}\n\nfunc (bc *bitmapContainer) safeMinimum() (uint16, error) {\n\tif len(bc.bitmap) == 0 {\n\t\treturn 0, errors.New(\"Empty bitmap\")\n\t}\n\tval := bc.minimum()\n\tif val == MaxUint16 {\n\t\treturn 0, errors.New(\"Empty bitmap\")\n\t}\n\treturn val, nil\n}\n\n// i should be non-zero\nfunc clz(i uint64) int {\n\tn := 1\n\tx := uint32(i >> 32)\n\tif x == 0 {\n\t\tn += 32\n\t\tx = uint32(i)\n\t}\n\tif x>>16 == 0 {\n\t\tn += 16\n\t\tx = x << 16\n\t}\n\tif x>>24 == 0 {\n\t\tn += 8\n\t\tx = x << 8\n\t}\n\tif x>>28 == 0 {\n\t\tn += 4\n\t\tx = x << 4\n\t}\n\tif x>>30 == 0 {\n\t\tn += 2\n\t\tx = x << 2\n\t}\n\treturn n - int(x>>31)\n}\n\nfunc (bc *bitmapContainer) maximum() uint16 {\n\tfor i := len(bc.bitmap); i > 0; i-- {\n\t\tw := bc.bitmap[i-1]\n\t\tif w != 0 {\n\t\t\tr := clz(w)\n\t\t\treturn uint16((i-1)*64 + 63 - r)\n\t\t}\n\t}\n\treturn uint16(0)\n}\n\nfunc (bc *bitmapContainer) safeMaximum() (uint16, error) {\n\tif len(bc.bitmap) == 0 {\n\t\treturn 0, errors.New(\"Empty bitmap\")\n\t}\n\tval := bc.maximum()\n\tif val == uint16(0) {\n\t\treturn 0, errors.New(\"Empty bitmap\")\n\t}\n\treturn val, nil\n}\n\nfunc (bc *bitmapContainer) iterate(cb func(x uint16) bool) bool {\n\titerator := bitmapContainerShortIterator{bc, bc.NextSetBit(0)}\n\n\tfor iterator.hasNext() {\n\t\tif !cb(iterator.next()) {\n\t\t\treturn false\n\t\t}\n\t}\n\n\treturn true\n}\n\ntype bitmapContainerShortIterator struct {\n\tptr *bitmapContainer\n\ti   int\n}\n\nfunc (bcsi *bitmapContainerShortIterator) next() uint16 {\n\tj := bcsi.i\n\tbcsi.i = bcsi.ptr.NextSetBit(uint(bcsi.i) + 1)\n\treturn uint16(j)\n}\n\nfunc (bcsi *bitmapContainerShortIterator) hasNext() bool {\n\treturn bcsi.i >= 0\n}\n\nfunc (bcsi *bitmapContainerShortIterator) peekNext() uint16 {\n\treturn uint16(bcsi.i)\n}\n\nfunc (bcsi *bitmapContainerShortIterator) advanceIfNeeded(minval uint16) {\n\tif bcsi.hasNext() && bcsi.peekNext() < minval {\n\t\tbcsi.i = bcsi.ptr.NextSetBit(uint(minval))\n\t}\n}\n\nfunc newBitmapContainerShortIterator(a *bitmapContainer) *bitmapContainerShortIterator {\n\treturn &bitmapContainerShortIterator{a, a.NextSetBit(0)}\n}\n\nfunc (bc *bitmapContainer) getShortIterator() shortPeekable {\n\treturn newBitmapContainerShortIterator(bc)\n}\n\ntype reverseBitmapContainerShortIterator struct {\n\tptr *bitmapContainer\n\ti   int\n}\n\nfunc (bcsi *reverseBitmapContainerShortIterator) next() uint16 {\n\tif bcsi.i == -1 {\n\t\tpanic(\"reverseBitmapContainerShortIterator.next() going beyond what is available\")\n\t}\n\n\tj := bcsi.i\n\tbcsi.i = bcsi.ptr.PrevSetBit(bcsi.i - 1)\n\treturn uint16(j)\n}\n\nfunc (bcsi *reverseBitmapContainerShortIterator) hasNext() bool {\n\treturn bcsi.i >= 0\n}\n\nfunc newReverseBitmapContainerShortIterator(a *bitmapContainer) *reverseBitmapContainerShortIterator {\n\tif a.cardinality == 0 {\n\t\treturn &reverseBitmapContainerShortIterator{a, -1}\n\t}\n\treturn &reverseBitmapContainerShortIterator{a, int(a.maximum())}\n}\n\nfunc (bc *bitmapContainer) getReverseIterator() shortIterable {\n\treturn newReverseBitmapContainerShortIterator(bc)\n}\n\ntype bitmapContainerManyIterator struct {\n\tptr    *bitmapContainer\n\tbase   int\n\tbitset uint64\n}\n\nfunc (bcmi *bitmapContainerManyIterator) nextMany(hs uint32, buf []uint32) int {\n\tn := 0\n\tbase := bcmi.base\n\tbitset := bcmi.bitset\n\n\tfor n < len(buf) {\n\t\tif bitset == 0 {\n\t\t\tbase++\n\t\t\tif base >= len(bcmi.ptr.bitmap) {\n\t\t\t\tbcmi.base = base\n\t\t\t\tbcmi.bitset = bitset\n\t\t\t\treturn n\n\t\t\t}\n\t\t\tbitset = bcmi.ptr.bitmap[base]\n\t\t\tcontinue\n\t\t}\n\t\tt := bitset & -bitset\n\t\tbuf[n] = uint32(((base * 64) + int(popcount(t-1)))) | hs\n\t\tn = n + 1\n\t\tbitset ^= t\n\t}\n\n\tbcmi.base = base\n\tbcmi.bitset = bitset\n\treturn n\n}\n\n// nextMany64 returns the number of values added to the buffer\nfunc (bcmi *bitmapContainerManyIterator) nextMany64(hs uint64, buf []uint64) int {\n\tn := 0\n\tbase := bcmi.base\n\tbitset := bcmi.bitset\n\n\tfor n < len(buf) {\n\t\tif bitset == 0 {\n\t\t\tbase++\n\t\t\tif base >= len(bcmi.ptr.bitmap) {\n\t\t\t\tbcmi.base = base\n\t\t\t\tbcmi.bitset = bitset\n\t\t\t\treturn n\n\t\t\t}\n\t\t\tbitset = bcmi.ptr.bitmap[base]\n\t\t\tcontinue\n\t\t}\n\t\tt := bitset & -bitset\n\t\tbuf[n] = uint64(((base * 64) + int(popcount(t-1)))) | hs\n\t\tn = n + 1\n\t\tbitset ^= t\n\t}\n\n\tbcmi.base = base\n\tbcmi.bitset = bitset\n\treturn n\n}\n\nfunc newBitmapContainerManyIterator(a *bitmapContainer) *bitmapContainerManyIterator {\n\treturn &bitmapContainerManyIterator{a, -1, 0}\n}\n\nfunc (bc *bitmapContainer) getManyIterator() manyIterable {\n\treturn newBitmapContainerManyIterator(bc)\n}\n\nfunc (bc *bitmapContainer) getSizeInBytes() int {\n\treturn len(bc.bitmap) * 8\n}\n\nfunc (bc *bitmapContainer) serializedSizeInBytes() int {\n\treturn len(bc.bitmap) * 8\n}\n\nconst bcBaseBytes = int(unsafe.Sizeof(bitmapContainer{}))\n\n// bitmapContainer doesn't depend on card, always fully allocated\nfunc bitmapContainerSizeInBytes() int {\n\treturn bcBaseBytes + (1<<16)/8\n}\n\nfunc bitmapEquals(a, b []uint64) bool {\n\tif len(a) != len(b) {\n\t\treturn false\n\t}\n\tfor i, v := range a {\n\t\tif v != b[i] {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\nfunc (bc *bitmapContainer) fillLeastSignificant16bits(x []uint32, i int, mask uint32) int {\n\t// TODO: should be written as optimized assembly\n\tpos := i\n\tbase := mask\n\tfor k := 0; k < len(bc.bitmap); k++ {\n\t\tbitset := bc.bitmap[k]\n\t\tfor bitset != 0 {\n\t\t\tt := bitset & -bitset\n\t\t\tx[pos] = base + uint32(popcount(t-1))\n\t\t\tpos++\n\t\t\tbitset ^= t\n\t\t}\n\t\tbase += 64\n\t}\n\treturn pos\n}\n\nfunc (bc *bitmapContainer) equals(o container) bool {\n\tsrb, ok := o.(*bitmapContainer)\n\tif ok {\n\t\tif srb.cardinality != bc.cardinality {\n\t\t\treturn false\n\t\t}\n\t\treturn bitmapEquals(bc.bitmap, srb.bitmap)\n\t}\n\n\t// use generic comparison\n\tif bc.getCardinality() != o.getCardinality() {\n\t\treturn false\n\t}\n\tait := o.getShortIterator()\n\tbit := bc.getShortIterator()\n\n\tfor ait.hasNext() {\n\t\tif bit.next() != ait.next() {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\nfunc (bc *bitmapContainer) iaddReturnMinimized(i uint16) container {\n\tbc.iadd(i)\n\tif bc.isFull() {\n\t\treturn newRunContainer16Range(0, MaxUint16)\n\t}\n\treturn bc\n}\n\n// iadd adds the arg i, returning true if not already present\nfunc (bc *bitmapContainer) iadd(i uint16) bool {\n\tx := int(i)\n\tprevious := bc.bitmap[x/64]\n\tmask := uint64(1) << (uint(x) % 64)\n\tnewb := previous | mask\n\tbc.bitmap[x/64] = newb\n\tbc.cardinality += int((previous ^ newb) >> (uint(x) % 64))\n\treturn newb != previous\n}\n\nfunc (bc *bitmapContainer) iremoveReturnMinimized(i uint16) container {\n\tif bc.iremove(i) {\n\t\tif bc.cardinality == arrayDefaultMaxSize {\n\t\t\treturn bc.toArrayContainer()\n\t\t}\n\t}\n\treturn bc\n}\n\n// iremove returns true if i was found.\nfunc (bc *bitmapContainer) iremove(i uint16) bool {\n\tif bc.contains(i) {\n\t\tbc.cardinality--\n\t\tbc.bitmap[i/64] &^= (uint64(1) << (i % 64))\n\t\treturn true\n\t}\n\treturn false\n}\n\nfunc (bc *bitmapContainer) isFull() bool {\n\treturn bc.cardinality == int(MaxUint16)+1\n}\n\nfunc (bc *bitmapContainer) getCardinality() int {\n\treturn bc.cardinality\n}\n\nfunc (bc *bitmapContainer) isEmpty() bool {\n\treturn bc.cardinality == 0\n}\n\nfunc (bc *bitmapContainer) clone() container {\n\tptr := bitmapContainer{bc.cardinality, make([]uint64, len(bc.bitmap))}\n\tcopy(ptr.bitmap, bc.bitmap[:])\n\treturn &ptr\n}\n\n// add all values in range [firstOfRange,lastOfRange)\nfunc (bc *bitmapContainer) iaddRange(firstOfRange, lastOfRange int) container {\n\tbc.cardinality += setBitmapRangeAndCardinalityChange(bc.bitmap, firstOfRange, lastOfRange)\n\treturn bc\n}\n\n// remove all values in range [firstOfRange,lastOfRange)\nfunc (bc *bitmapContainer) iremoveRange(firstOfRange, lastOfRange int) container {\n\tbc.cardinality += resetBitmapRangeAndCardinalityChange(bc.bitmap, firstOfRange, lastOfRange)\n\tif bc.getCardinality() <= arrayDefaultMaxSize {\n\t\treturn bc.toArrayContainer()\n\t}\n\treturn bc\n}\n\n// flip all values in range [firstOfRange,endx)\nfunc (bc *bitmapContainer) inot(firstOfRange, endx int) container {\n\tif endx-firstOfRange == maxCapacity {\n\t\tflipBitmapRange(bc.bitmap, firstOfRange, endx)\n\t\tbc.cardinality = maxCapacity - bc.cardinality\n\t} else if endx-firstOfRange > maxCapacity/2 {\n\t\tflipBitmapRange(bc.bitmap, firstOfRange, endx)\n\t\tbc.computeCardinality()\n\t} else {\n\t\tbc.cardinality += flipBitmapRangeAndCardinalityChange(bc.bitmap, firstOfRange, endx)\n\t}\n\tif bc.getCardinality() <= arrayDefaultMaxSize {\n\t\treturn bc.toArrayContainer()\n\t}\n\treturn bc\n}\n\n// flip all values in range [firstOfRange,endx)\nfunc (bc *bitmapContainer) not(firstOfRange, endx int) container {\n\tanswer := bc.clone()\n\treturn answer.inot(firstOfRange, endx)\n}\n\nfunc (bc *bitmapContainer) or(a container) container {\n\tswitch x := a.(type) {\n\tcase *arrayContainer:\n\t\treturn bc.orArray(x)\n\tcase *bitmapContainer:\n\t\treturn bc.orBitmap(x)\n\tcase *runContainer16:\n\t\tif x.isFull() {\n\t\t\treturn x.clone()\n\t\t}\n\t\treturn x.orBitmapContainer(bc)\n\t}\n\tpanic(\"unsupported container type\")\n}\n\nfunc (bc *bitmapContainer) orCardinality(a container) int {\n\tswitch x := a.(type) {\n\tcase *arrayContainer:\n\t\treturn bc.orArrayCardinality(x)\n\tcase *bitmapContainer:\n\t\treturn bc.orBitmapCardinality(x)\n\tcase *runContainer16:\n\t\treturn x.orBitmapContainerCardinality(bc)\n\t}\n\tpanic(\"unsupported container type\")\n}\n\nfunc (bc *bitmapContainer) ior(a container) container {\n\tswitch x := a.(type) {\n\tcase *arrayContainer:\n\t\treturn bc.iorArray(x)\n\tcase *bitmapContainer:\n\t\treturn bc.iorBitmap(x)\n\tcase *runContainer16:\n\t\tif x.isFull() {\n\t\t\treturn x.clone()\n\t\t}\n\t\tfor i := range x.iv {\n\t\t\tbc.iaddRange(int(x.iv[i].start), int(x.iv[i].last())+1)\n\t\t}\n\t\tif bc.isFull() {\n\t\t\treturn newRunContainer16Range(0, MaxUint16)\n\t\t}\n\t\t// bc.computeCardinality()\n\t\treturn bc\n\t}\n\tpanic(fmt.Errorf(\"unsupported container type %T\", a))\n}\n\nfunc (bc *bitmapContainer) lazyIOR(a container) container {\n\tswitch x := a.(type) {\n\tcase *arrayContainer:\n\t\treturn bc.lazyIORArray(x)\n\tcase *bitmapContainer:\n\t\treturn bc.lazyIORBitmap(x)\n\tcase *runContainer16:\n\t\tif x.isFull() {\n\t\t\treturn x.clone()\n\t\t}\n\n\t\t// Manually inlined setBitmapRange function\n\t\tbitmap := bc.bitmap\n\t\tfor _, iv := range x.iv {\n\t\t\tstart := int(iv.start)\n\t\t\tend := int(iv.last()) + 1\n\t\t\tif start >= end {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tfirstword := start / 64\n\t\t\tendword := (end - 1) / 64\n\t\t\tif firstword == endword {\n\t\t\t\tbitmap[firstword] |= (^uint64(0) << uint(start%64)) & (^uint64(0) >> (uint(-end) % 64))\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tbitmap[firstword] |= ^uint64(0) << uint(start%64)\n\t\t\tfor i := firstword + 1; i < endword; i++ {\n\t\t\t\tbitmap[i] = ^uint64(0)\n\t\t\t}\n\t\t\tbitmap[endword] |= ^uint64(0) >> (uint(-end) % 64)\n\t\t}\n\t\tbc.cardinality = invalidCardinality\n\t\treturn bc\n\t}\n\tpanic(\"unsupported container type\")\n}\n\nfunc (bc *bitmapContainer) lazyOR(a container) container {\n\tswitch x := a.(type) {\n\tcase *arrayContainer:\n\t\treturn bc.lazyORArray(x)\n\tcase *bitmapContainer:\n\t\treturn bc.lazyORBitmap(x)\n\tcase *runContainer16:\n\t\tif x.isFull() {\n\t\t\treturn x.clone()\n\t\t}\n\t\t// TODO: implement lazy OR\n\t\treturn x.orBitmapContainer(bc)\n\n\t}\n\tpanic(\"unsupported container type\")\n}\n\nfunc (bc *bitmapContainer) orArray(value2 *arrayContainer) container {\n\tanswer := bc.clone().(*bitmapContainer)\n\tc := value2.getCardinality()\n\tfor k := 0; k < c; k++ {\n\t\tv := value2.content[k]\n\t\ti := uint(v) >> 6\n\t\tbef := answer.bitmap[i]\n\t\taft := bef | (uint64(1) << (v % 64))\n\t\tanswer.bitmap[i] = aft\n\t\tanswer.cardinality += int((bef - aft) >> 63)\n\t}\n\treturn answer\n}\n\nfunc (bc *bitmapContainer) orArrayCardinality(value2 *arrayContainer) int {\n\tanswer := bc.getCardinality()\n\tc := value2.getCardinality()\n\tfor k := 0; k < c; k++ {\n\t\t// branchless:\n\t\tv := value2.content[k]\n\t\ti := uint(v) >> 6\n\t\tbef := bc.bitmap[i]\n\t\taft := bef | (uint64(1) << (v % 64))\n\t\tanswer += int((bef - aft) >> 63)\n\t}\n\treturn answer\n}\n\nfunc (bc *bitmapContainer) orBitmap(value2 *bitmapContainer) container {\n\tanswer := newBitmapContainer()\n\tfor k := 0; k < len(answer.bitmap); k++ {\n\t\tanswer.bitmap[k] = bc.bitmap[k] | value2.bitmap[k]\n\t}\n\tanswer.computeCardinality()\n\tif answer.isFull() {\n\t\treturn newRunContainer16Range(0, MaxUint16)\n\t}\n\treturn answer\n}\n\nfunc (bc *bitmapContainer) orBitmapCardinality(value2 *bitmapContainer) int {\n\treturn int(popcntOrSlice(bc.bitmap, value2.bitmap))\n}\n\nfunc (bc *bitmapContainer) andBitmapCardinality(value2 *bitmapContainer) int {\n\treturn int(popcntAndSlice(bc.bitmap, value2.bitmap))\n}\n\nfunc (bc *bitmapContainer) computeCardinality() {\n\tbc.cardinality = int(popcntSlice(bc.bitmap))\n}\n\nfunc (bc *bitmapContainer) iorArray(ac *arrayContainer) container {\n\tfor k := range ac.content {\n\t\tvc := ac.content[k]\n\t\ti := uint(vc) >> 6\n\t\tbef := bc.bitmap[i]\n\t\taft := bef | (uint64(1) << (vc % 64))\n\t\tbc.bitmap[i] = aft\n\t\tbc.cardinality += int((bef - aft) >> 63)\n\t}\n\tif bc.isFull() {\n\t\treturn newRunContainer16Range(0, MaxUint16)\n\t}\n\treturn bc\n}\n\nfunc (bc *bitmapContainer) iorBitmap(value2 *bitmapContainer) container {\n\tanswer := bc\n\tanswer.cardinality = 0\n\tfor k := 0; k < len(answer.bitmap); k++ {\n\t\tanswer.bitmap[k] = bc.bitmap[k] | value2.bitmap[k]\n\t}\n\tanswer.computeCardinality()\n\tif bc.isFull() {\n\t\treturn newRunContainer16Range(0, MaxUint16)\n\t}\n\treturn answer\n}\n\nfunc (bc *bitmapContainer) lazyIORArray(value2 *arrayContainer) container {\n\tanswer := bc\n\tc := value2.getCardinality()\n\tfor k := 0; k+3 < c; k += 4 {\n\t\tcontent := (*[4]uint16)(unsafe.Pointer(&value2.content[k]))\n\t\tvc0 := content[0]\n\t\ti0 := uint(vc0) >> 6\n\t\tanswer.bitmap[i0] = answer.bitmap[i0] | (uint64(1) << (vc0 % 64))\n\n\t\tvc1 := content[1]\n\t\ti1 := uint(vc1) >> 6\n\t\tanswer.bitmap[i1] = answer.bitmap[i1] | (uint64(1) << (vc1 % 64))\n\n\t\tvc2 := content[2]\n\t\ti2 := uint(vc2) >> 6\n\t\tanswer.bitmap[i2] = answer.bitmap[i2] | (uint64(1) << (vc2 % 64))\n\n\t\tvc3 := content[3]\n\t\ti3 := uint(vc3) >> 6\n\t\tanswer.bitmap[i3] = answer.bitmap[i3] | (uint64(1) << (vc3 % 64))\n\t}\n\n\tfor k := c &^ 3; k < c; k++ {\n\t\tvc := value2.content[k]\n\t\ti := uint(vc) >> 6\n\t\tanswer.bitmap[i] = answer.bitmap[i] | (uint64(1) << (vc % 64))\n\t}\n\n\tanswer.cardinality = invalidCardinality\n\treturn answer\n}\n\nfunc (bc *bitmapContainer) lazyORArray(value2 *arrayContainer) container {\n\tanswer := bc.clone().(*bitmapContainer)\n\treturn answer.lazyIORArray(value2)\n}\n\nfunc (bc *bitmapContainer) lazyIORBitmap(value2 *bitmapContainer) container {\n\tanswer := bc\n\tfor k := 0; k < len(answer.bitmap); k++ {\n\t\tanswer.bitmap[k] = bc.bitmap[k] | value2.bitmap[k]\n\t}\n\tbc.cardinality = invalidCardinality\n\treturn answer\n}\n\nfunc (bc *bitmapContainer) lazyORBitmap(value2 *bitmapContainer) container {\n\tanswer := bc.clone().(*bitmapContainer)\n\treturn answer.lazyIORBitmap(value2)\n}\n\nfunc (bc *bitmapContainer) xor(a container) container {\n\tswitch x := a.(type) {\n\tcase *arrayContainer:\n\t\treturn bc.xorArray(x)\n\tcase *bitmapContainer:\n\t\treturn bc.xorBitmap(x)\n\tcase *runContainer16:\n\t\treturn x.xorBitmap(bc)\n\t}\n\tpanic(\"unsupported container type\")\n}\n\nfunc (bc *bitmapContainer) xorArray(value2 *arrayContainer) container {\n\tanswer := bc.clone().(*bitmapContainer)\n\tc := value2.getCardinality()\n\tfor k := 0; k < c; k++ {\n\t\tvc := value2.content[k]\n\t\tindex := uint(vc) >> 6\n\t\tabi := answer.bitmap[index]\n\t\tmask := uint64(1) << (vc % 64)\n\t\tanswer.cardinality += 1 - 2*int((abi&mask)>>(vc%64))\n\t\tanswer.bitmap[index] = abi ^ mask\n\t}\n\tif answer.cardinality <= arrayDefaultMaxSize {\n\t\treturn answer.toArrayContainer()\n\t}\n\treturn answer\n}\n\nfunc (bc *bitmapContainer) rank(x uint16) int {\n\t// TODO: rewrite in assembly\n\tleftover := (uint(x) + 1) & 63\n\tif leftover == 0 {\n\t\treturn int(popcntSlice(bc.bitmap[:(uint(x)+1)/64]))\n\t}\n\treturn int(popcntSlice(bc.bitmap[:(uint(x)+1)/64]) + popcount(bc.bitmap[(uint(x)+1)/64]<<(64-leftover)))\n}\n\nfunc (bc *bitmapContainer) selectInt(x uint16) int {\n\tremaining := x\n\tfor k := 0; k < len(bc.bitmap); k++ {\n\t\tw := popcount(bc.bitmap[k])\n\t\tif uint16(w) > remaining {\n\t\t\treturn k*64 + selectBitPosition(bc.bitmap[k], int(remaining))\n\t\t}\n\t\tremaining -= uint16(w)\n\t}\n\treturn -1\n}\n\nfunc (bc *bitmapContainer) xorBitmap(value2 *bitmapContainer) container {\n\tnewCardinality := int(popcntXorSlice(bc.bitmap, value2.bitmap))\n\n\tif newCardinality > arrayDefaultMaxSize {\n\t\tanswer := newBitmapContainer()\n\t\tfor k := 0; k < len(answer.bitmap); k++ {\n\t\t\tanswer.bitmap[k] = bc.bitmap[k] ^ value2.bitmap[k]\n\t\t}\n\t\tanswer.cardinality = newCardinality\n\t\tif answer.isFull() {\n\t\t\treturn newRunContainer16Range(0, MaxUint16)\n\t\t}\n\t\treturn answer\n\t}\n\tac := newArrayContainerSize(newCardinality)\n\tfillArrayXOR(ac.content, bc.bitmap, value2.bitmap)\n\tac.content = ac.content[:newCardinality]\n\treturn ac\n}\n\nfunc (bc *bitmapContainer) and(a container) container {\n\tswitch x := a.(type) {\n\tcase *arrayContainer:\n\t\treturn bc.andArray(x)\n\tcase *bitmapContainer:\n\t\treturn bc.andBitmap(x)\n\tcase *runContainer16:\n\t\tif x.isFull() {\n\t\t\treturn bc.clone()\n\t\t}\n\t\treturn x.andBitmapContainer(bc)\n\t}\n\tpanic(\"unsupported container type\")\n}\n\nfunc (bc *bitmapContainer) andCardinality(a container) int {\n\tswitch x := a.(type) {\n\tcase *arrayContainer:\n\t\treturn bc.andArrayCardinality(x)\n\tcase *bitmapContainer:\n\t\treturn bc.andBitmapCardinality(x)\n\tcase *runContainer16:\n\t\treturn x.andBitmapContainerCardinality(bc)\n\t}\n\tpanic(\"unsupported container type\")\n}\n\nfunc (bc *bitmapContainer) intersects(a container) bool {\n\tswitch x := a.(type) {\n\tcase *arrayContainer:\n\t\treturn bc.intersectsArray(x)\n\tcase *bitmapContainer:\n\t\treturn bc.intersectsBitmap(x)\n\tcase *runContainer16:\n\t\treturn x.intersects(bc)\n\n\t}\n\tpanic(\"unsupported container type\")\n}\n\nfunc (bc *bitmapContainer) iand(a container) container {\n\tswitch x := a.(type) {\n\tcase *arrayContainer:\n\t\treturn bc.iandArray(x)\n\tcase *bitmapContainer:\n\t\treturn bc.iandBitmap(x)\n\tcase *runContainer16:\n\t\tif x.isFull() {\n\t\t\treturn bc.clone()\n\t\t}\n\t\treturn bc.iandRun16(x)\n\t}\n\tpanic(\"unsupported container type\")\n}\n\nfunc (bc *bitmapContainer) iandRun16(rc *runContainer16) container {\n\trcb := newBitmapContainerFromRun(rc)\n\treturn bc.iandBitmap(rcb)\n}\n\nfunc (bc *bitmapContainer) iandArray(ac *arrayContainer) container {\n\tacb := ac.toBitmapContainer()\n\treturn bc.iandBitmap(acb)\n}\n\nfunc (bc *bitmapContainer) andArray(value2 *arrayContainer) *arrayContainer {\n\tanswer := newArrayContainerCapacity(len(value2.content))\n\tanswer.content = answer.content[:cap(answer.content)]\n\tc := value2.getCardinality()\n\tpos := 0\n\tfor k := 0; k < c; k++ {\n\t\tv := value2.content[k]\n\t\tanswer.content[pos] = v\n\t\tpos += int(bc.bitValue(v))\n\t}\n\tanswer.content = answer.content[:pos]\n\treturn answer\n}\n\nfunc (bc *bitmapContainer) andArrayCardinality(value2 *arrayContainer) int {\n\tc := value2.getCardinality()\n\tpos := 0\n\tfor k := 0; k < c; k++ {\n\t\tv := value2.content[k]\n\t\tpos += int(bc.bitValue(v))\n\t}\n\treturn pos\n}\n\nfunc (bc *bitmapContainer) getCardinalityInRange(start, end uint) int {\n\tif start >= end {\n\t\treturn 0\n\t}\n\tfirstword := start / 64\n\tendword := (end - 1) / 64\n\tconst allones = ^uint64(0)\n\tif firstword == endword {\n\t\treturn int(popcount(bc.bitmap[firstword] & ((allones << (start % 64)) & (allones >> ((64 - end) & 63)))))\n\t}\n\tanswer := popcount(bc.bitmap[firstword] & (allones << (start % 64)))\n\tanswer += popcntSlice(bc.bitmap[firstword+1 : endword])\n\tanswer += popcount(bc.bitmap[endword] & (allones >> ((64 - end) & 63)))\n\treturn int(answer)\n}\n\nfunc (bc *bitmapContainer) andBitmap(value2 *bitmapContainer) container {\n\tnewcardinality := int(popcntAndSlice(bc.bitmap, value2.bitmap))\n\tif newcardinality > arrayDefaultMaxSize {\n\t\tanswer := newBitmapContainer()\n\t\tfor k := 0; k < len(answer.bitmap); k++ {\n\t\t\tanswer.bitmap[k] = bc.bitmap[k] & value2.bitmap[k]\n\t\t}\n\t\tanswer.cardinality = newcardinality\n\t\treturn answer\n\t}\n\tac := newArrayContainerSize(newcardinality)\n\tfillArrayAND(ac.content, bc.bitmap, value2.bitmap)\n\tac.content = ac.content[:newcardinality]\n\treturn ac\n}\n\nfunc (bc *bitmapContainer) intersectsArray(value2 *arrayContainer) bool {\n\tc := value2.getCardinality()\n\tfor k := 0; k < c; k++ {\n\t\tv := value2.content[k]\n\t\tif bc.contains(v) {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\nfunc (bc *bitmapContainer) intersectsBitmap(value2 *bitmapContainer) bool {\n\tfor k := 0; k < len(bc.bitmap); k++ {\n\t\tif (bc.bitmap[k] & value2.bitmap[k]) != 0 {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\nfunc (bc *bitmapContainer) iandBitmap(value2 *bitmapContainer) container {\n\tnewcardinality := int(popcntAndSlice(bc.bitmap, value2.bitmap))\n\tfor k := 0; k < len(bc.bitmap); k++ {\n\t\tbc.bitmap[k] = bc.bitmap[k] & value2.bitmap[k]\n\t}\n\tbc.cardinality = newcardinality\n\n\tif newcardinality <= arrayDefaultMaxSize {\n\t\treturn newArrayContainerFromBitmap(bc)\n\t}\n\treturn bc\n}\n\nfunc (bc *bitmapContainer) andNot(a container) container {\n\tswitch x := a.(type) {\n\tcase *arrayContainer:\n\t\treturn bc.andNotArray(x)\n\tcase *bitmapContainer:\n\t\treturn bc.andNotBitmap(x)\n\tcase *runContainer16:\n\t\treturn bc.andNotRun16(x)\n\t}\n\tpanic(\"unsupported container type\")\n}\n\nfunc (bc *bitmapContainer) andNotRun16(rc *runContainer16) container {\n\trcb := rc.toBitmapContainer()\n\treturn bc.andNotBitmap(rcb)\n}\n\nfunc (bc *bitmapContainer) iandNot(a container) container {\n\tswitch x := a.(type) {\n\tcase *arrayContainer:\n\t\treturn bc.iandNotArray(x)\n\tcase *bitmapContainer:\n\t\treturn bc.iandNotBitmapSurely(x)\n\tcase *runContainer16:\n\t\treturn bc.iandNotRun16(x)\n\t}\n\tpanic(\"unsupported container type\")\n}\n\nfunc (bc *bitmapContainer) iandNotArray(ac *arrayContainer) container {\n\tif ac.isEmpty() || bc.isEmpty() {\n\t\t// Nothing to do.\n\t\treturn bc\n\t}\n\n\t// Word by word, we remove the elements in ac from bc. The approach is to build\n\t// a mask of the elements to remove, and then apply it to the bitmap.\n\twordIdx := uint16(0)\n\tmask := uint64(0)\n\tfor i, v := range ac.content {\n\t\tif v/64 != wordIdx {\n\t\t\t// Flush the current word.\n\t\t\tif i != 0 {\n\t\t\t\t// We're removing bits that are set in the mask and in the current word.\n\t\t\t\t// To figure out the cardinality change, we count the number of bits that\n\t\t\t\t// are set in the mask and in the current word.\n\t\t\t\tmask &= bc.bitmap[wordIdx]\n\t\t\t\tbc.bitmap[wordIdx] &= ^mask\n\t\t\t\tbc.cardinality -= int(popcount(mask))\n\t\t\t}\n\n\t\t\twordIdx = v / 64\n\t\t\tmask = 0\n\t\t}\n\t\tmask |= 1 << (v % 64)\n\t}\n\n\t// Flush the last word.\n\tmask &= bc.bitmap[wordIdx]\n\tbc.bitmap[wordIdx] &= ^mask\n\tbc.cardinality -= int(popcount(mask))\n\n\tif bc.getCardinality() <= arrayDefaultMaxSize {\n\t\treturn bc.toArrayContainer()\n\t}\n\treturn bc\n}\n\nfunc (bc *bitmapContainer) iandNotRun16(rc *runContainer16) container {\n\tif rc.isEmpty() || bc.isEmpty() {\n\t\t// Nothing to do.\n\t\treturn bc\n\t}\n\n\twordRangeStart := rc.iv[0].start / 64\n\twordRangeEnd := (rc.iv[len(rc.iv)-1].last()) / 64 // inclusive\n\n\tcardinalityChange := popcntSlice(bc.bitmap[wordRangeStart : wordRangeEnd+1]) // before cardinality - after cardinality (for word range)\n\n\tfor _, iv := range rc.iv {\n\t\tresetBitmapRange(bc.bitmap, int(iv.start), int(iv.last())+1)\n\t}\n\n\tcardinalityChange -= popcntSlice(bc.bitmap[wordRangeStart : wordRangeEnd+1])\n\n\tbc.cardinality -= int(cardinalityChange)\n\n\tif bc.getCardinality() <= arrayDefaultMaxSize {\n\t\treturn bc.toArrayContainer()\n\t}\n\treturn bc\n}\n\nfunc (bc *bitmapContainer) andNotArray(value2 *arrayContainer) container {\n\tanswer := bc.clone().(*bitmapContainer)\n\tc := value2.getCardinality()\n\tfor k := 0; k < c; k++ {\n\t\tvc := value2.content[k]\n\t\ti := uint(vc) >> 6\n\t\toldv := answer.bitmap[i]\n\t\tnewv := oldv &^ (uint64(1) << (vc % 64))\n\t\tanswer.bitmap[i] = newv\n\t\tanswer.cardinality -= int((oldv ^ newv) >> (vc % 64))\n\t}\n\tif answer.cardinality <= arrayDefaultMaxSize {\n\t\treturn answer.toArrayContainer()\n\t}\n\treturn answer\n}\n\nfunc (bc *bitmapContainer) andNotBitmap(value2 *bitmapContainer) container {\n\tnewCardinality := int(popcntMaskSlice(bc.bitmap, value2.bitmap))\n\tif newCardinality > arrayDefaultMaxSize {\n\t\tanswer := newBitmapContainer()\n\t\tfor k := 0; k < len(answer.bitmap); k++ {\n\t\t\tanswer.bitmap[k] = bc.bitmap[k] &^ value2.bitmap[k]\n\t\t}\n\t\tanswer.cardinality = newCardinality\n\t\treturn answer\n\t}\n\tac := newArrayContainerSize(newCardinality)\n\tfillArrayANDNOT(ac.content, bc.bitmap, value2.bitmap)\n\treturn ac\n}\n\nfunc (bc *bitmapContainer) iandNotBitmapSurely(value2 *bitmapContainer) container {\n\tnewCardinality := int(popcntMaskSlice(bc.bitmap, value2.bitmap))\n\tfor k := 0; k < len(bc.bitmap); k++ {\n\t\tbc.bitmap[k] = bc.bitmap[k] &^ value2.bitmap[k]\n\t}\n\tbc.cardinality = newCardinality\n\tif bc.getCardinality() <= arrayDefaultMaxSize {\n\t\treturn bc.toArrayContainer()\n\t}\n\treturn bc\n}\n\nfunc (bc *bitmapContainer) contains(i uint16) bool { // testbit\n\tx := uint(i)\n\tw := bc.bitmap[x>>6]\n\tmask := uint64(1) << (x & 63)\n\treturn (w & mask) != 0\n}\n\nfunc (bc *bitmapContainer) bitValue(i uint16) uint64 {\n\tx := uint(i)\n\tw := bc.bitmap[x>>6]\n\treturn (w >> (x & 63)) & 1\n}\n\nfunc (bc *bitmapContainer) loadData(arrayContainer *arrayContainer) {\n\tbc.cardinality = arrayContainer.getCardinality()\n\tc := arrayContainer.getCardinality()\n\tfor k := 0; k < c; k++ {\n\t\tx := arrayContainer.content[k]\n\t\ti := int(x) / 64\n\t\tbc.bitmap[i] |= (uint64(1) << uint(x%64))\n\t}\n}\n\nfunc (bc *bitmapContainer) resetTo(a container) {\n\tswitch x := a.(type) {\n\tcase *arrayContainer:\n\t\tfill(bc.bitmap, 0)\n\t\tbc.loadData(x)\n\n\tcase *bitmapContainer:\n\t\tbc.cardinality = x.cardinality\n\t\tcopy(bc.bitmap, x.bitmap)\n\n\tcase *runContainer16:\n\t\tbc.cardinality = len(x.iv)\n\t\tlastEnd := 0\n\t\tfor _, r := range x.iv {\n\t\t\tbc.cardinality += int(r.length)\n\t\t\tresetBitmapRange(bc.bitmap, lastEnd, int(r.start))\n\t\t\tlastEnd = int(r.start+r.length) + 1\n\t\t\tsetBitmapRange(bc.bitmap, int(r.start), lastEnd)\n\t\t}\n\t\tresetBitmapRange(bc.bitmap, lastEnd, maxCapacity)\n\n\tdefault:\n\t\tpanic(\"unsupported container type\")\n\t}\n}\n\nfunc (bc *bitmapContainer) toArrayContainer() *arrayContainer {\n\tac := &arrayContainer{}\n\tac.loadData(bc)\n\treturn ac\n}\n\nfunc (bc *bitmapContainer) fillArray(container []uint16) {\n\t// TODO: rewrite in assembly\n\tpos := 0\n\tbase := 0\n\tfor k := 0; k < len(bc.bitmap); k++ {\n\t\tbitset := bc.bitmap[k]\n\t\tfor bitset != 0 {\n\t\t\tt := bitset & -bitset\n\t\t\tcontainer[pos] = uint16((base + int(popcount(t-1))))\n\t\t\tpos = pos + 1\n\t\t\tbitset ^= t\n\t\t}\n\t\tbase += 64\n\t}\n}\n\n// NextSetBit returns the next set bit e.g the next int packed into the bitmaparray\nfunc (bc *bitmapContainer) NextSetBit(i uint) int {\n\tvar (\n\t\tx      = i / 64\n\t\tlength = uint(len(bc.bitmap))\n\t)\n\tif x >= length {\n\t\treturn -1\n\t}\n\tw := bc.bitmap[x]\n\tw = w >> uint(i%64)\n\tif w != 0 {\n\t\treturn int(i) + countTrailingZeros(w)\n\t}\n\tx++\n\tfor ; x < length; x++ {\n\t\tif bc.bitmap[x] != 0 {\n\t\t\treturn int(x*64) + countTrailingZeros(bc.bitmap[x])\n\t\t}\n\t}\n\treturn -1\n}\n\n// PrevSetBit returns the previous set bit e.g the previous int packed into the bitmaparray\nfunc (bc *bitmapContainer) PrevSetBit(i int) int {\n\tif i < 0 {\n\t\treturn -1\n\t}\n\n\treturn bc.uPrevSetBit(uint(i))\n}\n\nfunc (bc *bitmapContainer) uPrevSetBit(i uint) int {\n\tvar (\n\t\tx      = i >> 6\n\t\tlength = uint(len(bc.bitmap))\n\t)\n\n\tif x >= length {\n\t\treturn -1\n\t}\n\n\tw := bc.bitmap[x]\n\n\tb := i % 64\n\n\tw = w << uint(63-b)\n\tif w != 0 {\n\t\treturn int(i) - countLeadingZeros(w)\n\t}\n\torig := x\n\tx--\n\tif x > orig {\n\t\treturn -1\n\t}\n\tfor ; x < orig; x-- {\n\t\tif bc.bitmap[x] != 0 {\n\t\t\treturn int((x*64)+63) - countLeadingZeros(bc.bitmap[x])\n\t\t}\n\t}\n\treturn -1\n}\n\n// reference the java implementation\n// https://github.com/RoaringBitmap/RoaringBitmap/blob/master/src/main/java/org/roaringbitmap/BitmapContainer.java#L875-L892\nfunc (bc *bitmapContainer) numberOfRuns() int {\n\tif bc.cardinality == 0 {\n\t\treturn 0\n\t}\n\n\tvar numRuns uint64\n\tnextWord := bc.bitmap[0]\n\n\tfor i := 0; i < len(bc.bitmap)-1; i++ {\n\t\tword := nextWord\n\t\tnextWord = bc.bitmap[i+1]\n\t\tnumRuns += popcount((^word)&(word<<1)) + ((word >> 63) &^ nextWord)\n\t}\n\n\tword := nextWord\n\tnumRuns += popcount((^word) & (word << 1))\n\tif (word & 0x8000000000000000) != 0 {\n\t\tnumRuns++\n\t}\n\n\treturn int(numRuns)\n}\n\n// convert to run or array *if needed*\nfunc (bc *bitmapContainer) toEfficientContainer() container {\n\tnumRuns := bc.numberOfRuns()\n\n\tsizeAsRunContainer := runContainer16SerializedSizeInBytes(numRuns)\n\tsizeAsBitmapContainer := bitmapContainerSizeInBytes()\n\tcard := bc.getCardinality()\n\tsizeAsArrayContainer := arrayContainerSizeInBytes(card)\n\n\tif sizeAsRunContainer < minOfInt(sizeAsBitmapContainer, sizeAsArrayContainer) {\n\t\treturn newRunContainer16FromBitmapContainer(bc)\n\t}\n\tif card <= arrayDefaultMaxSize {\n\t\treturn bc.toArrayContainer()\n\t}\n\treturn bc\n}\n\nfunc newBitmapContainerFromRun(rc *runContainer16) *bitmapContainer {\n\tif len(rc.iv) == 1 {\n\t\treturn newBitmapContainerwithRange(int(rc.iv[0].start), int(rc.iv[0].last()))\n\t}\n\n\tbc := newBitmapContainer()\n\tfor i := range rc.iv {\n\t\tsetBitmapRange(bc.bitmap, int(rc.iv[i].start), int(rc.iv[i].last())+1)\n\t\tbc.cardinality += int(rc.iv[i].last()) + 1 - int(rc.iv[i].start)\n\t}\n\t// bc.computeCardinality()\n\treturn bc\n}\n\nfunc (bc *bitmapContainer) containerType() contype {\n\treturn bitmapContype\n}\n\nfunc (bc *bitmapContainer) addOffset(x uint16) (container, container) {\n\tvar low, high *bitmapContainer\n\n\tif bc.cardinality == 0 {\n\t\treturn nil, nil\n\t}\n\n\tb := uint32(x) >> 6\n\ti := uint32(x) % 64\n\tend := uint32(1024) - b\n\n\tlow = newBitmapContainer()\n\tif i == 0 {\n\t\tcopy(low.bitmap[b:], bc.bitmap[:end])\n\t} else {\n\t\tlow.bitmap[b] = bc.bitmap[0] << i\n\t\tfor k := uint32(1); k < end; k++ {\n\t\t\tnewval := bc.bitmap[k] << i\n\t\t\tnewval |= bc.bitmap[k-1] >> (64 - i)\n\t\t\tlow.bitmap[b+k] = newval\n\t\t}\n\t}\n\tlow.computeCardinality()\n\n\tif low.cardinality == bc.cardinality {\n\t\t// All elements from bc ended up in low, meaning high will be empty.\n\t\treturn low, nil\n\t}\n\n\tif low.cardinality == 0 {\n\t\t// low is empty, let's reuse the container for high.\n\t\thigh = low\n\t\tlow = nil\n\t} else {\n\t\t// None of the containers will be empty, so allocate both.\n\t\thigh = newBitmapContainer()\n\t}\n\n\tif i == 0 {\n\t\tcopy(high.bitmap[:b], bc.bitmap[end:])\n\t} else {\n\t\tfor k := end; k < 1024; k++ {\n\t\t\tnewval := bc.bitmap[k] << i\n\t\t\tnewval |= bc.bitmap[k-1] >> (64 - i)\n\t\t\thigh.bitmap[k-end] = newval\n\t\t}\n\t\thigh.bitmap[b] = bc.bitmap[1023] >> (64 - i)\n\t}\n\thigh.computeCardinality()\n\n\t// Ensure proper nil interface.\n\tif low == nil {\n\t\treturn nil, high\n\t}\n\n\treturn low, high\n}\n\n// nextValue returns either the `target` if found or the next largest value.\n// if the target is out of bounds a -1 is returned\n//\n// Example :\n// Suppose the bitmap container represents the following slice\n// [1,2,10,11,100]\n// target=0 returns 1\n// target=1 returns 1\n// target=10 returns 10\n// target=90 returns 100\nfunc (bc *bitmapContainer) nextValue(target uint16) int {\n\tif bc.cardinality == 0 {\n\t\treturn -1\n\t}\n\n\treturn bc.NextSetBit(uint(target))\n}\n\n// nextAbsentValue returns the next absent value.\n// if the target is out of bounds a -1 is returned\nfunc (bc *bitmapContainer) nextAbsentValue(target uint16) int {\n\tif bc.cardinality == 0 {\n\t\treturn -1\n\t}\n\n\tvar (\n\t\tx      = target >> 6\n\t\tlength = uint(len(bc.bitmap))\n\t)\n\tif uint(x) >= length {\n\t\treturn -1\n\t}\n\tw := bc.bitmap[x]\n\tw = w >> uint(target%64)\n\tif w == 0 {\n\t\treturn int(target)\n\t}\n\n\t// Check if all 1's\n\t// if statement - we skip the if we have all ones [1,1,1,1...1]\n\tif ^w != 0 {\n\n\t\tif countTrailingZeros(w) > 0 {\n\t\t\t// we have something like [X,Y,Z, 0,0,0]. This means the target bit is zero\n\t\t\treturn int(target)\n\t\t}\n\n\t\t// other wise something like [X,Y,0,1,1,1..1], where x and y can be either 1 or 0.\n\n\t\ttrailing := countTrailingOnes(w)\n\t\treturn int(target) + trailing\n\n\t}\n\tx++\n\tfor ; uint(x) < length; x++ {\n\t\tif bc.bitmap[x] == 0 {\n\t\t\treturn int(x * 64)\n\t\t}\n\t\tif ^bc.bitmap[x] != 0 {\n\t\t\ttrailing := countTrailingOnes(bc.bitmap[x])\n\t\t\treturn int(x*64) + trailing\n\t\t}\n\n\t}\n\treturn -1\n}\n\n// previousValue returns either the `target` if found or the previous largest value.\n// if the target is out of bounds a -1 is returned\n\n// Example :\n// Suppose the bitmap container represents the following slice\n// [1,2,10,11,100]\n// target=0 returns -1\n// target=1 returns -1\n// target=2 returns -1\n// target=10 returns 9\n// target=50 returns 10\n// target=100 returns 99\nfunc (bc *bitmapContainer) previousValue(target uint16) int {\n\tif bc.cardinality == 0 {\n\t\treturn -1\n\t}\n\treturn bc.uPrevSetBit(uint(target))\n}\n\n// previousAbsentValue returns the next absent value.\nfunc (bc *bitmapContainer) previousAbsentValue(target uint16) int {\n\tif bc.cardinality == 0 {\n\t\treturn -1\n\t}\n\n\tvar (\n\t\tx      = target >> 6\n\t\tlength = uint(len(bc.bitmap))\n\t)\n\tif uint(x) >= length {\n\t\treturn -1\n\t}\n\tw := bc.bitmap[x]\n\tshifted := w >> uint(target%64)\n\tif shifted == 0 {\n\t\treturn int(target)\n\t}\n\n\t// Check if all 1's\n\t// if statement - we skip if we have all ones [1,1,1,1...1] as no value is absent\n\tif ^shifted != 0 {\n\n\t\tif countTrailingZeros(shifted) > 0 {\n\t\t\t// we have something like shifted=[X,Y,Z,..., 0,0,0]. This means the target bit is zero\n\t\t\treturn int(target)\n\t\t}\n\n\t\t// The rotate will rotate the target bit into the leading position.\n\t\t// We know the target bit is not zero because of the countTrailingZero check above\n\t\t// We then shift the target bit out of the way.\n\t\t// Assume a structure like an original structure like [X,Y,Z,..., Target, A, B,C...]\n\t\t// shifted will be [X,Y,Z...Target]\n\t\t// shiftedRotated will be [A,B,C....]\n\t\t// If countLeadingZeros > 0 then A is zero, if not at least A is 1 return\n\t\t// Else count the number of ones's until a 0\n\t\tshiftedRotated := bits.RotateLeft64(w, int(64-uint(target%64))-1) << 1\n\t\tleadingZeros := countLeadingZeros(shiftedRotated)\n\t\tif leadingZeros > 0 {\n\t\t\treturn int(target) - 1\n\t\t}\n\t\tleadingOnes := countLeadingOnes(shiftedRotated)\n\t\tif leadingOnes > 0 {\n\t\t\treturn int(target) - leadingOnes - 1\n\t\t}\n\n\t}\n\tx++\n\tfor ; uint(x) < length; x++ {\n\t\tif bc.bitmap[x] == 0 {\n\t\t\treturn int(x * 64)\n\t\t}\n\t\tif ^bc.bitmap[x] != 0 {\n\t\t\ttrailing := countTrailingOnes(bc.bitmap[x])\n\t\t\treturn int(x*64) + trailing\n\t\t}\n\n\t}\n\treturn -1\n}\n\n// validate checks that the container size is non-negative\nfunc (bc *bitmapContainer) validate() error {\n\tif bc.cardinality < arrayDefaultMaxSize {\n\t\treturn fmt.Errorf(\"bitmap container size was less than: %d\", arrayDefaultMaxSize)\n\t}\n\n\tif maxCapacity < len(bc.bitmap)*64 {\n\t\treturn fmt.Errorf(\"bitmap slize size %d exceeded max capacity %d\", maxCapacity, len(bc.bitmap)*64)\n\t}\n\n\tif bc.cardinality > maxCapacity {\n\t\treturn fmt.Errorf(\"bitmap container size was greater than: %d\", maxCapacity)\n\t}\n\n\tif bc.cardinality != int(popcntSlice(bc.bitmap)) {\n\t\treturn fmt.Errorf(\"bitmap container size %d did not match underlying slice length: %d\", bc.cardinality, int(popcntSlice(bc.bitmap)))\n\t}\n\n\treturn nil\n}\n"
        },
        {
          "name": "bitmapcontainer_test.go",
          "type": "blob",
          "size": 13.564453125,
          "content": "package roaring\n\nimport (\n\t\"math\"\n\t\"math/rand\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n\t\"github.com/stretchr/testify/require\"\n)\n\n// bitmapContainer's numberOfRuns() function should be correct against the runContainer equivalent\nfunc TestBitmapContainerNumberOfRuns024(t *testing.T) {\n\tseed := int64(42)\n\trand.Seed(seed)\n\n\ttrials := []trial{\n\t\t{n: 1000, percentFill: .1, ntrial: 10},\n\t}\n\n\tfor _, tr := range trials {\n\t\tfor j := 0; j < tr.ntrial; j++ {\n\t\t\tma := make(map[int]bool)\n\n\t\t\tn := tr.n\n\t\t\ta := []uint16{}\n\n\t\t\tdraw := int(float64(n) * tr.percentFill)\n\t\t\tfor i := 0; i < draw; i++ {\n\t\t\t\tr0 := rand.Intn(n)\n\t\t\t\ta = append(a, uint16(r0))\n\t\t\t\tma[r0] = true\n\t\t\t}\n\n\t\t\t// RunContainer compute this automatically\n\t\t\trc := newRunContainer16FromVals(false, a...)\n\t\t\trcNr := rc.numberOfRuns()\n\n\t\t\t// vs bitmapContainer\n\t\t\tbc := newBitmapContainer()\n\t\t\tfor k := range ma {\n\t\t\t\tbc.iadd(uint16(k))\n\t\t\t}\n\n\t\t\tbcNr := bc.numberOfRuns()\n\t\t\tassert.Equal(t, rcNr, bcNr)\n\t\t}\n\t}\n}\n\n// bitmap containers get cardinality in range, miss the last index, issue #183\nfunc TestBitmapcontainerAndCardinality(t *testing.T) {\n\tfor r := 0; r <= 65535; r++ {\n\t\tc1 := newRunContainer16Range(0, uint16(r))\n\t\tc2 := newBitmapContainerwithRange(0, int(r))\n\n\t\tassert.Equal(t, r+1, c1.andCardinality(c2))\n\t}\n}\n\nfunc TestIssue181(t *testing.T) {\n\tt.Run(\"Initial issue 181\", func(t *testing.T) {\n\t\ta := New()\n\t\tvar x uint32\n\n\t\t// adding 1M integers\n\t\tfor i := 1; i <= 1000000; i++ {\n\t\t\tx += uint32(rand.Intn(10) + 1)\n\t\t\ta.Add(x)\n\t\t}\n\t\tb := New()\n\t\tfor i := 1; i <= int(x); i++ {\n\t\t\tb.Add(uint32(i))\n\t\t}\n\n\t\tassert.Equal(t, b.AndCardinality(a), a.AndCardinality(b))\n\t\tassert.Equal(t, b.AndCardinality(a), And(a, b).GetCardinality())\n\t})\n\n\tt.Run(\"Second version of issue 181\", func(t *testing.T) {\n\t\ta := New()\n\t\tvar x uint32\n\n\t\t// adding 1M integers\n\t\tfor i := 1; i <= 1000000; i++ {\n\t\t\tx += uint32(rand.Intn(10) + 1)\n\t\t\ta.Add(x)\n\t\t}\n\t\tb := New()\n\t\tb.AddRange(1, uint64(x))\n\n\t\tassert.Equal(t, b.AndCardinality(a), a.AndCardinality(b))\n\t\tassert.Equal(t, b.AndCardinality(a), And(a, b).GetCardinality())\n\t})\n}\n\n// RunReverseIterator16 unit tests for cur, next, hasNext, and remove should pass\nfunc TestBitmapContainerReverseIterator(t *testing.T) {\n\tt.Run(\"reverse iterator on the empty container\", func(t *testing.T) {\n\t\tbc := newBitmapContainer()\n\t\tit := bc.getReverseIterator()\n\n\t\tassert.False(t, it.hasNext())\n\t\tassert.Panics(t, func() { it.next() })\n\t})\n\n\tt.Run(\"reverse iterator on the container with range(0,0)\", func(t *testing.T) {\n\t\tbc := newBitmapContainerwithRange(0, 0)\n\t\tit := bc.getReverseIterator()\n\n\t\tassert.True(t, it.hasNext())\n\t\tassert.EqualValues(t, 0, it.next())\n\t})\n\n\tt.Run(\"reverse iterator on the container with range(4,4)\", func(t *testing.T) {\n\t\tbc := newBitmapContainerwithRange(4, 4)\n\t\tit := bc.getReverseIterator()\n\n\t\tassert.True(t, it.hasNext())\n\t\tassert.EqualValues(t, 4, it.next())\n\t})\n\n\tt.Run(\"reverse iterator on the container with range(4,9)\", func(t *testing.T) {\n\t\tbc := newBitmapContainerwithRange(4, 9)\n\t\tit := bc.getReverseIterator()\n\n\t\tassert.True(t, it.hasNext())\n\n\t\tfor i := 9; i >= 4; i-- {\n\t\t\tassert.EqualValues(t, i, it.next())\n\n\t\t\tif i > 4 {\n\t\t\t\tassert.True(t, it.hasNext())\n\t\t\t} else if i == 4 {\n\t\t\t\tassert.False(t, it.hasNext())\n\t\t\t}\n\t\t}\n\n\t\tassert.False(t, it.hasNext())\n\t\tassert.Panics(t, func() { it.next() })\n\t})\n\n\tt.Run(\"reverse iterator on the container with values\", func(t *testing.T) {\n\t\tvalues := []uint16{0, 2, 15, 16, 31, 32, 33, 9999, MaxUint16}\n\t\tbc := newBitmapContainer()\n\n\t\tfor n := 0; n < len(values); n++ {\n\t\t\tbc.iadd(values[n])\n\t\t}\n\n\t\tit := bc.getReverseIterator()\n\t\tn := len(values)\n\n\t\tassert.True(t, it.hasNext())\n\n\t\tfor it.hasNext() {\n\t\t\tn--\n\t\t\tassert.Equal(t, values[n], it.next())\n\t\t}\n\n\t\tassert.Equal(t, 0, n)\n\t})\n}\n\nfunc TestBitmapNextSet(t *testing.T) {\n\ttestSize := 5000\n\tbc := newBitmapContainer()\n\n\tfor i := 0; i < testSize; i++ {\n\t\tbc.iadd(uint16(i))\n\t}\n\n\tm := 0\n\n\tfor n := 0; m < testSize; n, m = bc.NextSetBit(uint(n)+1), m+1 {\n\t\tassert.Equal(t, m, n)\n\t}\n\n\tassert.Equal(t, 5000, m)\n}\n\nfunc TestBitmapPrevSet(t *testing.T) {\n\ttestSize := 5000\n\tbc := newBitmapContainer()\n\n\tfor i := 0; i < testSize; i++ {\n\t\tbc.iadd(uint16(i))\n\t}\n\n\tm := testSize - 1\n\n\tfor n := testSize - 1; n > 0; n, m = bc.PrevSetBit(n-1), m-1 {\n\t\tassert.Equal(t, m, n)\n\t}\n\n\tassert.Equal(t, 0, m)\n}\n\nfunc TestBitmapIteratorPeekNext(t *testing.T) {\n\ttestContainerIteratorPeekNext(t, newBitmapContainer())\n}\n\nfunc TestBitmapIteratorAdvance(t *testing.T) {\n\ttestContainerIteratorAdvance(t, newBitmapContainer())\n}\n\n// go test -bench BenchmarkShortIteratorAdvance -run -\nfunc BenchmarkShortIteratorAdvanceBitmap(b *testing.B) {\n\tbenchmarkContainerIteratorAdvance(b, newBitmapContainer())\n}\n\n// go test -bench BenchmarkShortIteratorNext -run -\nfunc BenchmarkShortIteratorNextBitmap(b *testing.B) {\n\tbenchmarkContainerIteratorNext(b, newBitmapContainer())\n}\n\nfunc TestBitmapOffset(t *testing.T) {\n\tnums := []uint16{10, 60, 70, 100, 1000}\n\texpected := make([]int, len(nums))\n\tofftest := uint16(65000)\n\tv := container(newBitmapContainer())\n\tfor i, n := range nums {\n\t\tv.iadd(n)\n\t\texpected[i] = int(n) + int(offtest)\n\t}\n\tl, h := v.addOffset(offtest)\n\n\tvar w0card, w1card int\n\twout := make([]int, len(nums))\n\n\tif l != nil {\n\t\tw0card = l.getCardinality()\n\n\t\tfor i := 0; i < w0card; i++ {\n\t\t\twout[i] = l.selectInt(uint16(i))\n\t\t}\n\t}\n\n\tif h != nil {\n\t\tw1card = h.getCardinality()\n\n\t\tfor i := 0; i < w1card; i++ {\n\t\t\twout[i+w0card] = h.selectInt(uint16(i)) + 65536\n\t\t}\n\t}\n\n\tassert.Equal(t, v.getCardinality(), w0card+w1card)\n\tfor i, x := range wout {\n\t\tassert.Equal(t, expected[i], x)\n\t}\n}\n\nfunc TestBitmapContainerResetTo(t *testing.T) {\n\tarray := newArrayContainer()\n\tfor i := 0; i < 1000; i++ {\n\t\tarray.iadd(uint16(i*1000 + i + 50))\n\t}\n\n\tbitmap := newBitmapContainer()\n\tfor i := 0; i < 10000; i++ {\n\t\tbitmap.iadd(uint16(i*1000 + i + 50))\n\t}\n\n\trun := newRunContainer16()\n\tfor i := 0; i < 10; i++ {\n\t\tstart := i*1000 + i + 50\n\t\trun.iaddRange(start, start+100+i)\n\t}\n\n\tmakeDirty := func() *bitmapContainer {\n\t\tret := newBitmapContainer()\n\t\tfor i := 0; i < maxCapacity; i += 42 {\n\t\t\tret.iadd(uint16(i))\n\t\t}\n\t\treturn ret\n\t}\n\n\tt.Run(\"to array container\", func(t *testing.T) {\n\t\tclean := newBitmapContainer()\n\t\tclean.resetTo(array)\n\t\tassert.True(t, clean.toArrayContainer().equals(array))\n\n\t\tdirty := makeDirty()\n\t\tdirty.resetTo(array)\n\t\tassert.True(t, dirty.toArrayContainer().equals(array))\n\t})\n\n\tt.Run(\"to bitmap container\", func(t *testing.T) {\n\t\tclean := newBitmapContainer()\n\t\tclean.resetTo(bitmap)\n\t\tassert.True(t, clean.equals(bitmap))\n\n\t\tdirty := makeDirty()\n\t\tdirty.resetTo(bitmap)\n\t\tassert.True(t, dirty.equals(bitmap))\n\t})\n\n\tt.Run(\"to run container\", func(t *testing.T) {\n\t\tclean := newBitmapContainer()\n\t\tclean.resetTo(run)\n\t\tassert.EqualValues(t, clean.cardinality, run.getCardinality())\n\t\tassert.True(t, clean.toEfficientContainer().equals(run))\n\n\t\tdirty := makeDirty()\n\t\tdirty.resetTo(run)\n\t\tassert.EqualValues(t, dirty.cardinality, run.getCardinality())\n\t\tassert.True(t, dirty.toEfficientContainer().equals(run))\n\t})\n}\n\nfunc TestBitmapContainerIAndNot(t *testing.T) {\n\tvar bc container\n\tbc = newBitmapContainer()\n\tfor i := 0; i < arrayDefaultMaxSize; i++ {\n\t\tbc.iadd(uint16(i * 3))\n\t}\n\tbc.iadd(math.MaxUint16)\n\n\tvar rc container\n\trc = newRunContainer16Range(0, 1)\n\tfor i := 0; i < arrayDefaultMaxSize-3; i++ {\n\t\trc = rc.iaddRange(i*3, i*3+1)\n\t}\n\trc.iaddRange(math.MaxUint16-3, math.MaxUint16+1)\n\n\tbc = bc.iandNot(rc)\n\n\trequire.ElementsMatch(t, []uint16{12279, 12282, 12285}, bc.(*arrayContainer).content)\n\trequire.Equal(t, 3, bc.getCardinality())\n}\n\nfunc TestPreviousNexts(t *testing.T) {\n\tbc := newBitmapContainer()\n\tbc.iadd(10)\n\tbc.iadd(12)\n\tbc.iadd(13)\n\tbc.iaddRange(50, 60)\n\t// Crosses the 64 division mod boundary\n\tbc.iadd(100)\n\t// Another 64 division mod boundary\n\tbc.iadd(129)\n\n\tt.Run(\"Next value\", func(t *testing.T) {\n\t\tassert.Equal(t, 10, bc.nextValue(uint16(0)))\n\t\tassert.Equal(t, 10, bc.nextValue(uint16(5)))\n\t\tassert.Equal(t, 10, bc.nextValue(uint16(10)))\n\t\tassert.Equal(t, 12, bc.nextValue(uint16(11)))\n\t\tassert.Equal(t, 12, bc.nextValue(uint16(12)))\n\t\tassert.Equal(t, 13, bc.nextValue(uint16(13)))\n\t\tassert.Equal(t, 50, bc.nextValue(uint16(14)))\n\t\tassert.Equal(t, 55, bc.nextValue(uint16(55)))\n\t\tassert.Equal(t, 100, bc.nextValue(uint16(61)))\n\t\tassert.Equal(t, 100, bc.nextValue(uint16(100)))\n\t\tassert.Equal(t, 129, bc.nextValue(uint16(101)))\n\t\tassert.Equal(t, 129, bc.nextValue(uint16(129)))\n\t\tassert.Equal(t, -1, bc.nextValue(uint16(130)))\n\t})\n\n\tt.Run(\"Previous value\", func(t *testing.T) {\n\t\tassert.Equal(t, -1, bc.previousValue(uint16(0)))\n\t\tassert.Equal(t, -1, bc.previousValue(uint16(1)))\n\t\tassert.Equal(t, -1, bc.previousValue(uint16(2)))\n\t\tassert.Equal(t, -1, bc.previousValue(uint16(5)))\n\t\tassert.Equal(t, 10, bc.previousValue(uint16(10)))\n\t\tassert.Equal(t, 10, bc.previousValue(uint16(11)))\n\t\tassert.Equal(t, 12, bc.previousValue(uint16(12)))\n\t\tassert.Equal(t, 13, bc.previousValue(uint16(13)))\n\t\tassert.Equal(t, 13, bc.previousValue(uint16(14)))\n\t\tassert.Equal(t, 55, bc.previousValue(uint16(55)))\n\t\tassert.Equal(t, 59, bc.previousValue(uint16(61)))\n\t\tassert.Equal(t, 100, bc.previousValue(uint16(101)))\n\t})\n\n\tt.Run(\"Next Absent value\", func(t *testing.T) {\n\t\tassert.Equal(t, 0, bc.nextAbsentValue(uint16(0)))\n\t\tassert.Equal(t, 5, bc.nextAbsentValue(uint16(5)))\n\t\tassert.Equal(t, 11, bc.nextAbsentValue(uint16(11)))\n\t\tassert.Equal(t, 14, bc.nextAbsentValue(uint16(12)))\n\t\tassert.Equal(t, 14, bc.nextAbsentValue(uint16(13)))\n\t\tassert.Equal(t, 14, bc.nextAbsentValue(uint16(14)))\n\t\tassert.Equal(t, 49, bc.nextAbsentValue(uint16(49)))\n\t\tassert.Equal(t, 60, bc.nextAbsentValue(uint16(50)))\n\t\tassert.Equal(t, 60, bc.nextAbsentValue(uint16(60)))\n\t\tassert.Equal(t, 101, bc.nextAbsentValue(uint16(100)))\n\t\tassert.Equal(t, 101, bc.nextAbsentValue(uint16(101)))\n\t\tassert.Equal(t, 130, bc.nextAbsentValue(uint16(129)))\n\t})\n\n\tt.Run(\"Previous Absent value\", func(t *testing.T) {\n\t\tassert.Equal(t, 0, bc.previousAbsentValue(uint16(0)))\n\t\tassert.Equal(t, 1, bc.previousAbsentValue(uint16(1)))\n\t\tassert.Equal(t, 2, bc.previousAbsentValue(uint16(2)))\n\t\tassert.Equal(t, 5, bc.previousAbsentValue(uint16(5)))\n\t\tassert.Equal(t, 9, bc.previousAbsentValue(uint16(10)))\n\t\tassert.Equal(t, 11, bc.previousAbsentValue(uint16(11)))\n\t\tassert.Equal(t, 11, bc.previousAbsentValue(uint16(12)))\n\t\tassert.Equal(t, 11, bc.previousAbsentValue(uint16(13)))\n\t\tassert.Equal(t, 49, bc.previousAbsentValue(uint16(50)))\n\t\tassert.Equal(t, 49, bc.previousAbsentValue(uint16(51)))\n\t\tassert.Equal(t, 99, bc.previousAbsentValue(uint16(100)))\n\t\tassert.Equal(t, 128, bc.previousAbsentValue(uint16(129)))\n\t\tassert.Equal(t, 130, bc.previousAbsentValue(uint16(130)))\n\t})\n}\n\nfunc TestNextAbsent(t *testing.T) {\n\tbc := newBitmapContainer()\n\tfor i := 0; i < 1<<16; i++ {\n\t\tbc.iadd(uint16(i))\n\t}\n\tv := bc.nextAbsentValue((1 << 16) - 1)\n\tassert.Equal(t, v, 65536)\n}\n\nfunc TestBitMapContainerValidate(t *testing.T) {\n\tbc := newBitmapContainer()\n\n\tfor i := 0; i < arrayDefaultMaxSize-1; i++ {\n\t\tbc.iadd(uint16(i * 3))\n\t}\n\t// bitmap containers should have size arrayDefaultMaxSize or larger\n\tassert.Error(t, bc.validate())\n\tbc.iadd(math.MaxUint16)\n\n\tassert.NoError(t, bc.validate())\n\n\t// Break the max cardinality invariant\n\tbc.cardinality = maxCapacity + 1\n\n\tassert.Error(t, bc.validate())\n\n\t// violate cardinality underlying container size invariant\n\tbc = newBitmapContainer()\n\tfor i := 0; i < arrayDefaultMaxSize+1; i++ {\n\t\tbc.iadd(uint16(i * 3))\n\t}\n\tassert.NoError(t, bc.validate())\n\tbc.cardinality += 1\n\tassert.Error(t, bc.validate())\n\n\t// check that underlying packed slice doesn't exceed maxCapacity\n\tbc = newBitmapContainer()\n\torginalSize := (1 << 16) / 64\n\tfor i := 0; i < orginalSize; i++ {\n\t\tbc.cardinality += 1\n\t\tbc.bitmap[i] = uint64(1)\n\t}\n\n\tappendSize := ((1 << 16) - orginalSize) + 1\n\tfor i := 0; i < appendSize; i++ {\n\t\tbc.cardinality += 1\n\t\tbc.bitmap = append(bc.bitmap, uint64(1))\n\t}\n\n\tassert.Error(t, bc.validate())\n}\n\nfunc TestBitmapcontainerNextHasMany(t *testing.T) {\n\tt.Run(\"Empty Bitmap\", func(t *testing.T) {\n\t\tbc := newBitmapContainer()\n\t\titerator := newBitmapContainerManyIterator(bc)\n\t\thigh := uint64(1024)\n\t\tbuf := []uint64{}\n\t\tresult := iterator.nextMany64(high, buf)\n\t\tassert.Equal(t, 0, result)\n\t})\n\n\tt.Run(\"512 in iterator and buf size 512\", func(t *testing.T) {\n\t\tbc := newBitmapContainer()\n\t\tbc.iaddRange(0, 512)\n\t\titerator := newBitmapContainerManyIterator(bc)\n\t\thigh := uint64(1024)\n\t\tbuf := make([]uint64, 512)\n\t\tresult := iterator.nextMany64(high, buf)\n\t\tassert.Equal(t, 512, result)\n\t})\n\n\tt.Run(\"512 in iterator and buf size 256\", func(t *testing.T) {\n\t\tbc := newBitmapContainer()\n\t\tbc.iaddRange(0, 512)\n\t\titerator := newBitmapContainerManyIterator(bc)\n\t\thigh := uint64(1024)\n\t\tbuf := make([]uint64, 256)\n\t\tresult := iterator.nextMany64(high, buf)\n\t\tassert.Equal(t, 256, result)\n\t})\n}\n\nfunc TestBitmapcontainerOrArrayCardinality(t *testing.T) {\n\tt.Run(\"Empty Bitmap and Empty Array\", func(t *testing.T) {\n\t\tarray := newArrayContainer()\n\t\tbc := newBitmapContainer()\n\t\tresult := bc.orArrayCardinality(array)\n\n\t\tassert.Equal(t, 0, result)\n\t})\n\n\tt.Run(\"Populated Bitmap with Empty Array\", func(t *testing.T) {\n\t\tbc := newBitmapContainer()\n\t\tbc.iaddRange(0, 1024)\n\t\tarray := newArrayContainer()\n\n\t\tresult := bc.orArrayCardinality(array)\n\n\t\tassert.Equal(t, 1024, result)\n\t})\n\n\tt.Run(\"Populated Bitmap with Empty Run Container\", func(t *testing.T) {\n\t\tbc := newBitmapContainer()\n\t\tbc.iaddRange(0, 1024)\n\n\t\trunC := newRunContainer16()\n\n\t\tresult := runC.orBitmapContainerCardinality(bc)\n\n\t\tassert.Equal(t, 1024, result)\n\n\t\tother := newBitmapContainerFromRun(runC)\n\t\tresult = bc.orBitmapCardinality(other)\n\n\t\tassert.Equal(t, 1024, result)\n\t})\n\n\tt.Run(\"Populated Bitmap with Empty Bitmap\", func(t *testing.T) {\n\t\tbc := newBitmapContainer()\n\t\tbc.iaddRange(0, 1024)\n\n\t\tother := newBitmapContainer()\n\n\t\tresult := bc.orBitmapCardinality(other)\n\n\t\tassert.Equal(t, 1024, result)\n\t})\n}\n"
        },
        {
          "name": "byte_input_test.go",
          "type": "blob",
          "size": 1.482421875,
          "content": "package roaring\n\nimport (\n\t\"bytes\"\n\t\"testing\"\n\n\t\"github.com/RoaringBitmap/roaring/v2/internal\"\n\t\"github.com/stretchr/testify/assert\"\n\t\"github.com/stretchr/testify/require\"\n)\n\nfunc TestByteInputFlow(t *testing.T) {\n\tt.Run(\"Test should be an error on empty data\", func(t *testing.T) {\n\t\tbuf := bytes.NewBuffer([]byte{})\n\n\t\tinstances := []internal.ByteInput{\n\t\t\tinternal.NewByteInput(buf.Bytes()),\n\t\t\tinternal.NewByteInputFromReader(buf),\n\t\t}\n\n\t\tfor _, input := range instances {\n\t\t\tn, err := input.ReadUInt16()\n\n\t\t\tassert.EqualValues(t, 0, n)\n\t\t\tassert.Error(t, err)\n\n\t\t\tp, err := input.ReadUInt32()\n\t\t\tassert.EqualValues(t, 0, p)\n\t\t\tassert.Error(t, err)\n\n\t\t\tb, err := input.Next(10)\n\t\t\tassert.Nil(t, b)\n\t\t\tassert.Error(t, err)\n\n\t\t\terr = input.SkipBytes(10)\n\t\t\tassert.Error(t, err)\n\t\t}\n\t})\n\n\tt.Run(\"Test on nonempty data\", func(t *testing.T) {\n\t\tbuf := bytes.NewBuffer(uint16SliceAsByteSlice([]uint16{1, 10, 32, 66, 23}))\n\n\t\tinstances := []internal.ByteInput{\n\t\t\tinternal.NewByteInput(buf.Bytes()),\n\t\t\tinternal.NewByteInputFromReader(buf),\n\t\t}\n\n\t\tfor _, input := range instances {\n\t\t\tn, err := input.ReadUInt16()\n\t\t\tassert.EqualValues(t, 1, n)\n\t\t\trequire.NoError(t, err)\n\n\t\t\tp, err := input.ReadUInt32()\n\t\t\tassert.EqualValues(t, 2097162, p) // 32 << 16 | 10\n\t\t\trequire.NoError(t, err)\n\n\t\t\tb, err := input.Next(2)\n\t\t\tassert.EqualValues(t, []byte{66, 0}, b)\n\t\t\trequire.NoError(t, err)\n\n\t\t\terr = input.SkipBytes(2)\n\t\t\trequire.NoError(t, err)\n\n\t\t\tb, err = input.Next(1)\n\t\t\tassert.Nil(t, b)\n\t\t\tassert.Error(t, err)\n\t\t}\n\t})\n}\n"
        },
        {
          "name": "clz.go",
          "type": "blob",
          "size": 0.49609375,
          "content": "//go:build go1.9\n// +build go1.9\n\n// \"go1.9\", from Go version 1.9 onward\n// See https://golang.org/pkg/go/build/#hdr-Build_Constraints\n\npackage roaring\n\nimport \"math/bits\"\n\n// countLeadingOnes returns the number of leading zeros bits in x; the result is 64 for x == 0.\nfunc countLeadingZeros(x uint64) int {\n\treturn bits.LeadingZeros64(x)\n}\n\n// countLeadingOnes returns the number of leading ones bits in x; the result is 0 for x == 0.\nfunc countLeadingOnes(x uint64) int {\n\treturn bits.LeadingZeros64(^x)\n}\n"
        },
        {
          "name": "clz_compat.go",
          "type": "blob",
          "size": 0.4677734375,
          "content": "//go:build !go1.9\n// +build !go1.9\n\npackage roaring\n\n// LeadingZeroBits returns the number of consecutive most significant zero\n// bits of x.\nfunc countLeadingZeros(i uint64) int {\n\tif i == 0 {\n\t\treturn 64\n\t}\n\tn := 1\n\tx := uint32(i >> 32)\n\tif x == 0 {\n\t\tn += 32\n\t\tx = uint32(i)\n\t}\n\tif (x >> 16) == 0 {\n\t\tn += 16\n\t\tx <<= 16\n\t}\n\tif (x >> 24) == 0 {\n\t\tn += 8\n\t\tx <<= 8\n\t}\n\tif x>>28 == 0 {\n\t\tn += 4\n\t\tx <<= 4\n\t}\n\tif x>>30 == 0 {\n\t\tn += 2\n\t\tx <<= 2\n\n\t}\n\tn -= int(x >> 31)\n\treturn n\n}\n"
        },
        {
          "name": "clz_test.go",
          "type": "blob",
          "size": 0.8525390625,
          "content": "package roaring\n\nimport (\n\t\"github.com/stretchr/testify/assert\"\n\t\"testing\"\n)\n\nfunc numberOfLeadingZeros(i uint64) int {\n\tif i == 0 {\n\t\treturn 64\n\t}\n\tn := 1\n\tx := uint32(i >> 32)\n\tif x == 0 {\n\t\tn += 32\n\t\tx = uint32(i)\n\t}\n\tif (x >> 16) == 0 {\n\t\tn += 16\n\t\tx <<= 16\n\t}\n\tif (x >> 24) == 0 {\n\t\tn += 8\n\t\tx <<= 8\n\t}\n\tif x>>28 == 0 {\n\t\tn += 4\n\t\tx <<= 4\n\t}\n\tif x>>30 == 0 {\n\t\tn += 2\n\t\tx <<= 2\n\n\t}\n\tn -= int(x >> 31)\n\treturn n\n}\n\nfunc TestCountLeadingZeros072(t *testing.T) {\n\tassert.Equal(t, 64, numberOfLeadingZeros(0))\n\tassert.Equal(t, 60, numberOfLeadingZeros(8))\n\tassert.Equal(t, 64-17-1, numberOfLeadingZeros(1<<17))\n\tassert.Equal(t, 0, numberOfLeadingZeros(0xFFFFFFFFFFFFFFFF))\n\tassert.Equal(t, 64, countLeadingZeros(0))\n\tassert.Equal(t, 60, countLeadingZeros(8))\n\tassert.Equal(t, 64-17-1, countLeadingZeros(1<<17))\n\tassert.Equal(t, 0, countLeadingZeros(0xFFFFFFFFFFFFFFFF))\n}\n"
        },
        {
          "name": "container_test.go",
          "type": "blob",
          "size": 5.513671875,
          "content": "package roaring\n\nimport (\n\t\"fmt\"\n\t\"github.com/stretchr/testify/assert\"\n\t\"log\"\n\t\"testing\"\n)\n\nfunc makeContainer(ss []uint16) container {\n\tc := newArrayContainer()\n\tfor _, s := range ss {\n\t\tc.iadd(s)\n\t}\n\treturn c\n}\n\nfunc checkContent(c container, s []uint16) bool {\n\tsi := c.getShortIterator()\n\tctr := 0\n\tfail := false\n\tfor si.hasNext() {\n\t\tif ctr == len(s) {\n\t\t\tlog.Println(\"HERE\")\n\t\t\tfail = true\n\t\t\tbreak\n\t\t}\n\t\ti := si.next()\n\t\tif i != s[ctr] {\n\n\t\t\tlog.Println(\"THERE\", i, s[ctr])\n\t\t\tfail = true\n\t\t\tbreak\n\t\t}\n\t\tctr++\n\t}\n\tif ctr != len(s) {\n\t\tlog.Println(\"LAST\")\n\t\tfail = true\n\t}\n\tif fail {\n\t\tlog.Println(\"fail, found \")\n\t\tsi = c.getShortIterator()\n\t\tz := 0\n\t\tfor si.hasNext() {\n\t\t\tsi.next()\n\t\t\tz++\n\t\t}\n\t\tlog.Println(z, len(s))\n\t}\n\n\treturn !fail\n}\n\nfunc testContainerIteratorPeekNext(t *testing.T, c container) {\n\ttestSize := 5000\n\tfor i := 0; i < testSize; i++ {\n\t\tc.iadd(uint16(i))\n\t}\n\n\ti := c.getShortIterator()\n\tassert.True(t, i.hasNext())\n\n\tfor i.hasNext() {\n\t\tassert.Equal(t, i.peekNext(), i.next())\n\t\ttestSize--\n\t}\n\n\tassert.Equal(t, 0, testSize)\n}\n\nfunc testContainerIteratorAdvance(t *testing.T, con container) {\n\tvalues := []uint16{1, 2, 15, 16, 31, 32, 33, 9999}\n\tfor _, v := range values {\n\t\tcon.iadd(v)\n\t}\n\n\tcases := []struct {\n\t\tminval   uint16\n\t\texpected uint16\n\t}{\n\t\t{0, 1},\n\t\t{1, 1},\n\t\t{2, 2},\n\t\t{3, 15},\n\t\t{15, 15},\n\t\t{30, 31},\n\t\t{31, 31},\n\t\t{33, 33},\n\t\t{34, 9999},\n\t\t{9998, 9999},\n\t\t{9999, 9999},\n\t}\n\n\tt.Run(\"advance by using a new short iterator\", func(t *testing.T) {\n\t\tfor _, c := range cases {\n\t\t\ti := con.getShortIterator()\n\t\t\ti.advanceIfNeeded(c.minval)\n\n\t\t\tassert.True(t, i.hasNext())\n\t\t\tassert.Equal(t, c.expected, i.peekNext())\n\t\t}\n\t})\n\n\tt.Run(\"advance by using the same short iterator\", func(t *testing.T) {\n\t\ti := con.getShortIterator()\n\n\t\tfor _, c := range cases {\n\t\t\ti.advanceIfNeeded(c.minval)\n\n\t\t\tassert.True(t, i.hasNext())\n\t\t\tassert.Equal(t, c.expected, i.peekNext())\n\t\t}\n\t})\n\n\tt.Run(\"advance out of a container value\", func(t *testing.T) {\n\t\ti := con.getShortIterator()\n\n\t\ti.advanceIfNeeded(33)\n\t\tassert.True(t, i.hasNext())\n\t\tassert.EqualValues(t, 33, i.peekNext())\n\n\t\ti.advanceIfNeeded(MaxUint16 - 1)\n\t\tassert.False(t, i.hasNext())\n\n\t\ti.advanceIfNeeded(MaxUint16)\n\t\tassert.False(t, i.hasNext())\n\t})\n\n\tt.Run(\"advance on a value that is less than the pointed value\", func(t *testing.T) {\n\t\ti := con.getShortIterator()\n\t\ti.advanceIfNeeded(29)\n\t\tassert.True(t, i.hasNext())\n\t\tassert.EqualValues(t, 31, i.peekNext())\n\n\t\ti.advanceIfNeeded(13)\n\t\tassert.True(t, i.hasNext())\n\t\tassert.EqualValues(t, 31, i.peekNext())\n\t})\n}\n\nfunc benchmarkContainerIteratorAdvance(b *testing.B, con container) {\n\tfor _, initsize := range []int{1, 650, 6500, MaxUint16} {\n\t\tfor i := 0; i < initsize; i++ {\n\t\t\tcon.iadd(uint16(i))\n\t\t}\n\n\t\tb.Run(fmt.Sprintf(\"init size %d shortIterator advance\", initsize), func(b *testing.B) {\n\t\t\tb.StartTimer()\n\t\t\tdiff := uint16(0)\n\n\t\t\tfor n := 0; n < b.N; n++ {\n\t\t\t\tval := uint16(n % initsize)\n\n\t\t\t\ti := con.getShortIterator()\n\t\t\t\ti.advanceIfNeeded(val)\n\n\t\t\t\tdiff += i.peekNext() - val\n\t\t\t}\n\n\t\t\tb.StopTimer()\n\n\t\t\tif diff != 0 {\n\t\t\t\tb.Fatalf(\"Expected diff 0, got %d\", diff)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc benchmarkContainerIteratorNext(b *testing.B, con container) {\n\tfor _, initsize := range []int{1, 650, 6500, MaxUint16} {\n\t\tfor i := 0; i < initsize; i++ {\n\t\t\tcon.iadd(uint16(i))\n\t\t}\n\n\t\tb.Run(fmt.Sprintf(\"init size %d shortIterator next\", initsize), func(b *testing.B) {\n\t\t\tb.StartTimer()\n\t\t\tdiff := 0\n\n\t\t\tfor n := 0; n < b.N; n++ {\n\t\t\t\ti := con.getShortIterator()\n\t\t\t\tj := 0\n\n\t\t\t\tfor i.hasNext() {\n\t\t\t\t\ti.next()\n\t\t\t\t\tj++\n\t\t\t\t}\n\n\t\t\t\tdiff += j - initsize\n\t\t\t}\n\n\t\t\tb.StopTimer()\n\n\t\t\tif diff != 0 {\n\t\t\t\tb.Fatalf(\"Expected diff 0, got %d\", diff)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestContainerReverseIterator(t *testing.T) {\n\tcontent := []uint16{1, 3, 5, 7, 9}\n\tc := makeContainer(content)\n\tsi := c.getReverseIterator()\n\ti := 4\n\n\tfor si.hasNext() {\n\t\tassert.Equal(t, content[i], si.next())\n\t\ti--\n\t}\n\n\tassert.Equal(t, -1, i)\n}\n\nfunc TestRoaringContainer(t *testing.T) {\n\tt.Run(\"countTrailingZeros\", func(t *testing.T) {\n\t\tx := uint64(0)\n\t\to := countTrailingZeros(x)\n\t\tassert.Equal(t, 64, o)\n\n\t\tx = 1 << 3\n\t\to = countTrailingZeros(x)\n\t\tassert.Equal(t, 3, o)\n\t})\n\n\tt.Run(\"ArrayShortIterator\", func(t *testing.T) {\n\t\tcontent := []uint16{1, 3, 5, 7, 9}\n\t\tc := makeContainer(content)\n\t\tsi := c.getShortIterator()\n\t\ti := 0\n\t\tfor si.hasNext() {\n\t\t\tsi.next()\n\t\t\ti++\n\t\t}\n\n\t\tassert.Equal(t, 5, i)\n\t})\n\n\tt.Run(\"BinarySearch\", func(t *testing.T) {\n\t\tcontent := []uint16{1, 3, 5, 7, 9}\n\t\tres := binarySearch(content, 5)\n\t\tassert.Equal(t, 2, res)\n\n\t\tres = binarySearch(content, 4)\n\t\tassert.Less(t, res, 0)\n\t})\n\n\tt.Run(\"bitmapcontainer\", func(t *testing.T) {\n\t\tcontent := []uint16{1, 3, 5, 7, 9}\n\t\ta := newArrayContainer()\n\t\tb := newBitmapContainer()\n\t\tfor _, v := range content {\n\t\t\ta.iadd(v)\n\t\t\tb.iadd(v)\n\t\t}\n\t\tc := a.toBitmapContainer()\n\n\t\tassert.Equal(t, b.getCardinality(), a.getCardinality())\n\t\tassert.Equal(t, b.getCardinality(), c.getCardinality())\n\t})\n\n\tt.Run(\"inottest0\", func(t *testing.T) {\n\t\tcontent := []uint16{9}\n\t\tc := makeContainer(content)\n\t\tc = c.inot(0, 11)\n\t\tsi := c.getShortIterator()\n\t\ti := 0\n\t\tfor si.hasNext() {\n\t\t\tsi.next()\n\t\t\ti++\n\t\t}\n\n\t\tassert.Equal(t, 10, i)\n\t})\n\n\tt.Run(\"inotTest1\", func(t *testing.T) {\n\t\t// Array container, range is complete\n\t\tcontent := []uint16{1, 3, 5, 7, 9}\n\t\t//content := []uint16{1}\n\t\tedge := 1 << 13\n\t\tc := makeContainer(content)\n\t\tc = c.inot(0, edge+1)\n\t\tsize := edge - len(content)\n\t\ts := make([]uint16, size+1)\n\t\tpos := 0\n\t\tfor i := uint16(0); i < uint16(edge+1); i++ {\n\t\t\tif binarySearch(content, i) < 0 {\n\t\t\t\ts[pos] = i\n\t\t\t\tpos++\n\t\t\t}\n\t\t}\n\n\t\tassert.True(t, checkContent(c, s))\n\t})\n}\n"
        },
        {
          "name": "ctz.go",
          "type": "blob",
          "size": 0.5595703125,
          "content": "//go:build go1.9\n// +build go1.9\n\n// \"go1.9\", from Go version 1.9 onward\n// See https://golang.org/pkg/go/build/#hdr-Build_Constraints\n\npackage roaring\n\nimport \"math/bits\"\n\n// countTrailingZeros returns the number of trailing zero bits in x; the result is 64 for x == 0.\nfunc countTrailingZeros(x uint64) int {\n\treturn bits.TrailingZeros64(x)\n}\n\n// countTrailingOnes returns the number of trailing one bits in x\n// The result is 64 for x == 9,223,372,036,854,775,807.\n// The result is 0 for x == 0.\nfunc countTrailingOnes(x uint64) int {\n\treturn bits.TrailingZeros64(^x)\n}\n"
        },
        {
          "name": "ctz_compat.go",
          "type": "blob",
          "size": 2.9228515625,
          "content": "//go:build !go1.9\n// +build !go1.9\n\npackage roaring\n\n// Reuse of portions of go/src/math/big standard lib code\n// under this license:\n/*\nCopyright (c) 2009 The Go Authors. All rights reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are\nmet:\n\n   * Redistributions of source code must retain the above copyright\nnotice, this list of conditions and the following disclaimer.\n   * Redistributions in binary form must reproduce the above\ncopyright notice, this list of conditions and the following disclaimer\nin the documentation and/or other materials provided with the\ndistribution.\n   * Neither the name of Google Inc. nor the names of its\ncontributors may be used to endorse or promote products derived from\nthis software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n\"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\nLIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\nA PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\nOWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\nSPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\nLIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\nTHEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n*/\n\nconst deBruijn32 = 0x077CB531\n\nvar deBruijn32Lookup = []byte{\n\t0, 1, 28, 2, 29, 14, 24, 3, 30, 22, 20, 15, 25, 17, 4, 8,\n\t31, 27, 13, 23, 21, 19, 16, 7, 26, 12, 18, 6, 11, 5, 10, 9,\n}\n\nconst deBruijn64 = 0x03f79d71b4ca8b09\n\nvar deBruijn64Lookup = []byte{\n\t0, 1, 56, 2, 57, 49, 28, 3, 61, 58, 42, 50, 38, 29, 17, 4,\n\t62, 47, 59, 36, 45, 43, 51, 22, 53, 39, 33, 30, 24, 18, 12, 5,\n\t63, 55, 48, 27, 60, 41, 37, 16, 46, 35, 44, 21, 52, 32, 23, 11,\n\t54, 26, 40, 15, 34, 20, 31, 10, 25, 14, 19, 9, 13, 8, 7, 6,\n}\n\n// trailingZeroBits returns the number of consecutive least significant zero\n// bits of x.\nfunc countTrailingZeros(x uint64) int {\n\t// x & -x leaves only the right-most bit set in the word. Let k be the\n\t// index of that bit. Since only a single bit is set, the value is two\n\t// to the power of k. Multiplying by a power of two is equivalent to\n\t// left shifting, in this case by k bits. The de Bruijn constant is\n\t// such that all six bit, consecutive substrings are distinct.\n\t// Therefore, if we have a left shifted version of this constant we can\n\t// find by how many bits it was shifted by looking at which six bit\n\t// substring ended up at the top of the word.\n\t// (Knuth, volume 4, section 7.3.1)\n\tif x == 0 {\n\t\t// We have to special case 0; the fomula\n\t\t// below doesn't work for 0.\n\t\treturn 64\n\t}\n\treturn int(deBruijn64Lookup[((x&-x)*(deBruijn64))>>58])\n}\n"
        },
        {
          "name": "ctz_test.go",
          "type": "blob",
          "size": 1.935546875,
          "content": "package roaring\n\nimport (\n\t\"encoding/binary\"\n\t\"github.com/stretchr/testify/assert\"\n\t\"math/rand\"\n\t\"testing\"\n)\n\nfunc TestCountTrailingZeros072(t *testing.T) {\n\tassert.Equal(t, 64, numberOfTrailingZeros(0))\n\tassert.Equal(t, 3, numberOfTrailingZeros(8))\n\tassert.Equal(t, 0, numberOfTrailingZeros(7))\n\tassert.Equal(t, 17, numberOfTrailingZeros(1<<17))\n\tassert.Equal(t, 17, numberOfTrailingZeros(7<<17))\n\tassert.Equal(t, 33, numberOfTrailingZeros(255<<33))\n\n\tassert.Equal(t, 64, countTrailingZeros(0))\n\tassert.Equal(t, 3, countTrailingZeros(8))\n\tassert.Equal(t, 0, countTrailingZeros(7))\n\tassert.Equal(t, 17, countTrailingZeros(1<<17))\n\tassert.Equal(t, 17, countTrailingZeros(7<<17))\n\tassert.Equal(t, 33, countTrailingZeros(255<<33))\n}\n\nfunc getRandomUint64Set(n int) []uint64 {\n\tseed := int64(42)\n\trand.Seed(seed)\n\n\tvar buf [8]byte\n\tvar o []uint64\n\tfor i := 0; i < n; i++ {\n\t\trand.Read(buf[:])\n\t\to = append(o, binary.LittleEndian.Uint64(buf[:]))\n\t}\n\treturn o\n}\n\nfunc getAllOneBitUint64Set() []uint64 {\n\tvar o []uint64\n\tfor i := uint(0); i < 64; i++ {\n\t\to = append(o, 1<<i)\n\t}\n\treturn o\n}\n\nfunc Benchmark100OrigNumberOfTrailingZeros(b *testing.B) {\n\tb.StopTimer()\n\n\tr := getRandomUint64Set(64)\n\tr = append(r, getAllOneBitUint64Set()...)\n\n\tb.ResetTimer()\n\tb.StartTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\tfor i := range r {\n\t\t\tnumberOfTrailingZeros(r[i])\n\t\t}\n\t}\n}\n\nfunc Benchmark100CountTrailingZeros(b *testing.B) {\n\tb.StopTimer()\n\n\tr := getRandomUint64Set(64)\n\tr = append(r, getAllOneBitUint64Set()...)\n\n\tb.ResetTimer()\n\tb.StartTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\tfor i := range r {\n\t\t\tcountTrailingZeros(r[i])\n\t\t}\n\t}\n}\n\nfunc numberOfTrailingZeros(i uint64) int {\n\tif i == 0 {\n\t\treturn 64\n\t}\n\tx := i\n\tn := int64(63)\n\ty := x << 32\n\tif y != 0 {\n\t\tn -= 32\n\t\tx = y\n\t}\n\ty = x << 16\n\tif y != 0 {\n\t\tn -= 16\n\t\tx = y\n\t}\n\ty = x << 8\n\tif y != 0 {\n\t\tn -= 8\n\t\tx = y\n\t}\n\ty = x << 4\n\tif y != 0 {\n\t\tn -= 4\n\t\tx = y\n\t}\n\ty = x << 2\n\tif y != 0 {\n\t\tn -= 2\n\t\tx = y\n\t}\n\treturn int(n - int64(uint64(x<<1)>>63))\n}\n"
        },
        {
          "name": "example_roaring_test.go",
          "type": "blob",
          "size": 2.9326171875,
          "content": "package roaring\n\nimport (\n\t\"bytes\"\n\t\"fmt\"\n\t\"testing\"\n)\n\n// Example_roaring demonstrates how to use the roaring library.\nfunc TestExample_roaring060(t *testing.T) {\n\t// example inspired by https://github.com/fzandona/goroar\n\tfmt.Println(\"==roaring==\")\n\trb1 := BitmapOf(1, 2, 3, 4, 5, 100, 1000)\n\tfmt.Println(rb1.String())\n\n\trb2 := BitmapOf(3, 4, 1000)\n\tfmt.Println(rb2.String())\n\n\trb3 := New()\n\tfmt.Println(rb3.String())\n\n\tfmt.Println(\"Cardinality: \", rb1.GetCardinality())\n\tif rb1.GetCardinality() != 7 {\n\t\tt.Errorf(\"Bad cardinality: %v\", rb1.GetCardinality())\n\t}\n\n\tfmt.Println(\"Contains 3? \", rb1.Contains(3))\n\tif !rb1.Contains(3) {\n\t\tt.Errorf(\"Should contain 3.\")\n\t}\n\n\trb1.And(rb2)\n\n\trb3.Add(1)\n\trb3.Add(5)\n\n\trb3.Or(rb1)\n\n\t// prints 1, 3, 4, 5, 1000\n\ti := rb3.Iterator()\n\tfor i.HasNext() {\n\t\tfmt.Println(i.Next())\n\t}\n\tfmt.Println()\n\n\t// next we include an example of serialization\n\tbuf := new(bytes.Buffer)\n\tsize, err := rb1.WriteTo(buf)\n\tif err != nil {\n\t\tfmt.Println(\"Failed writing\")\n\t\tt.Errorf(\"Failed writing\")\n\n\t} else {\n\t\tfmt.Println(\"Wrote \", size, \" bytes\")\n\t}\n\tnewrb := New()\n\t_, err = newrb.ReadFrom(buf)\n\tif err != nil {\n\t\tfmt.Println(\"Failed reading\")\n\t\tt.Errorf(\"Failed reading\")\n\t}\n\t// if buf is an untrusted source, you should validate the result\n\t// (this adds a bit of complexity but it is necessary for security)\n\tif newrb.Validate() != nil {\n\t\tfmt.Println(\"Failed validation\")\n\t}\n\tif !rb1.Equals(newrb) {\n\t\tfmt.Println(\"I did not get back to original bitmap?\")\n\t\tt.Errorf(\"Bad serialization\")\n\n\t} else {\n\t\tfmt.Println(\"I wrote the content to a byte stream and read it back.\")\n\t}\n}\n\n// Example_roaring demonstrates how to use the roaring library with run containers.\nfunc TestExample2_roaring061(t *testing.T) {\n\n\tr1 := New()\n\tfor i := uint32(100); i < 1000; i++ {\n\t\tr1.Add(i)\n\t}\n\tif !r1.Contains(500) {\n\t\tt.Errorf(\"should contain 500\")\n\t}\n\trb2 := r1.Clone()\n\t// compute how many bits there are:\n\tcardinality := r1.GetCardinality()\n\n\t// if your bitmaps have long runs, you can compress them by calling\n\t// run_optimize\n\tsize := r1.GetSizeInBytes()\n\tr1.RunOptimize()\n\tif cardinality != r1.GetCardinality() {\n\t\tt.Errorf(\"RunOptimize should not change cardinality.\")\n\t}\n\tcompactSize := r1.GetSizeInBytes()\n\tif compactSize >= size {\n\t\tt.Errorf(\"Run optimized size should be smaller.\")\n\t}\n\tif !r1.Equals(rb2) {\n\t\tt.Errorf(\"RunOptimize should not affect equality.\")\n\t}\n\tfmt.Print(\"size before run optimize: \", size, \" bytes, and after: \", compactSize, \" bytes.\\n\")\n\trb3 := New()\n\trb3.AddRange(1, 10000000)\n\tr1.Or(rb3)\n\tif !r1.Equals(rb3) {\n\t\tt.Errorf(\"union with large run should give back contained set\")\n\t}\n\trb1 := r1.Clone()\n\trb1.AndNot(rb3)\n\tif !rb1.IsEmpty() {\n\t\tt.Errorf(\"And not with large should clear...\")\n\t}\n\tfor i := uint32(0); i < 10000; i += 3 {\n\t\trb1.Add(i)\n\t}\n\trb1.AndNot(rb3)\n\trb1card := rb1.GetCardinality()\n\tif rb1card != 1 {\n\t\t//rb1.RunOptimize()\n\t\t//fmt.Printf(\"\\n rb1 = %s\\n\", rb1)\n\t\tt.Errorf(\"Only the value 0 should survive the andNot; rb1card = %v\", rb1card)\n\t}\n}\n"
        },
        {
          "name": "fastaggregation.go",
          "type": "blob",
          "size": 8.283203125,
          "content": "package roaring\n\nimport (\n\t\"container/heap\"\n)\n\n// Or function that requires repairAfterLazy\nfunc lazyOR(x1, x2 *Bitmap) *Bitmap {\n\tanswer := NewBitmap()\n\tpos1 := 0\n\tpos2 := 0\n\tlength1 := x1.highlowcontainer.size()\n\tlength2 := x2.highlowcontainer.size()\nmain:\n\tfor (pos1 < length1) && (pos2 < length2) {\n\t\ts1 := x1.highlowcontainer.getKeyAtIndex(pos1)\n\t\ts2 := x2.highlowcontainer.getKeyAtIndex(pos2)\n\n\t\tfor {\n\t\t\tif s1 < s2 {\n\t\t\t\tanswer.highlowcontainer.appendCopy(x1.highlowcontainer, pos1)\n\t\t\t\tpos1++\n\t\t\t\tif pos1 == length1 {\n\t\t\t\t\tbreak main\n\t\t\t\t}\n\t\t\t\ts1 = x1.highlowcontainer.getKeyAtIndex(pos1)\n\t\t\t} else if s1 > s2 {\n\t\t\t\tanswer.highlowcontainer.appendCopy(x2.highlowcontainer, pos2)\n\t\t\t\tpos2++\n\t\t\t\tif pos2 == length2 {\n\t\t\t\t\tbreak main\n\t\t\t\t}\n\t\t\t\ts2 = x2.highlowcontainer.getKeyAtIndex(pos2)\n\t\t\t} else {\n\t\t\t\tc1 := x1.highlowcontainer.getContainerAtIndex(pos1)\n\t\t\t\tanswer.highlowcontainer.appendContainer(s1, c1.lazyOR(x2.highlowcontainer.getContainerAtIndex(pos2)), false)\n\t\t\t\tpos1++\n\t\t\t\tpos2++\n\t\t\t\tif (pos1 == length1) || (pos2 == length2) {\n\t\t\t\t\tbreak main\n\t\t\t\t}\n\t\t\t\ts1 = x1.highlowcontainer.getKeyAtIndex(pos1)\n\t\t\t\ts2 = x2.highlowcontainer.getKeyAtIndex(pos2)\n\t\t\t}\n\t\t}\n\t}\n\tif pos1 == length1 {\n\t\tanswer.highlowcontainer.appendCopyMany(x2.highlowcontainer, pos2, length2)\n\t} else if pos2 == length2 {\n\t\tanswer.highlowcontainer.appendCopyMany(x1.highlowcontainer, pos1, length1)\n\t}\n\treturn answer\n}\n\n// In-place Or function that requires repairAfterLazy\nfunc (x1 *Bitmap) lazyOR(x2 *Bitmap) *Bitmap {\n\tpos1 := 0\n\tpos2 := 0\n\tlength1 := x1.highlowcontainer.size()\n\tlength2 := x2.highlowcontainer.size()\nmain:\n\tfor (pos1 < length1) && (pos2 < length2) {\n\t\ts1 := x1.highlowcontainer.getKeyAtIndex(pos1)\n\t\ts2 := x2.highlowcontainer.getKeyAtIndex(pos2)\n\n\t\tfor {\n\t\t\tif s1 < s2 {\n\t\t\t\tpos1++\n\t\t\t\tif pos1 == length1 {\n\t\t\t\t\tbreak main\n\t\t\t\t}\n\t\t\t\ts1 = x1.highlowcontainer.getKeyAtIndex(pos1)\n\t\t\t} else if s1 > s2 {\n\t\t\t\tx1.highlowcontainer.insertNewKeyValueAt(pos1, s2, x2.highlowcontainer.getContainerAtIndex(pos2).clone())\n\t\t\t\tpos2++\n\t\t\t\tpos1++\n\t\t\t\tlength1++\n\t\t\t\tif pos2 == length2 {\n\t\t\t\t\tbreak main\n\t\t\t\t}\n\t\t\t\ts2 = x2.highlowcontainer.getKeyAtIndex(pos2)\n\t\t\t} else {\n\t\t\t\tc1 := x1.highlowcontainer.getWritableContainerAtIndex(pos1)\n\t\t\t\tx1.highlowcontainer.containers[pos1] = c1.lazyIOR(x2.highlowcontainer.getContainerAtIndex(pos2))\n\t\t\t\tx1.highlowcontainer.needCopyOnWrite[pos1] = false\n\t\t\t\tpos1++\n\t\t\t\tpos2++\n\t\t\t\tif (pos1 == length1) || (pos2 == length2) {\n\t\t\t\t\tbreak main\n\t\t\t\t}\n\t\t\t\ts1 = x1.highlowcontainer.getKeyAtIndex(pos1)\n\t\t\t\ts2 = x2.highlowcontainer.getKeyAtIndex(pos2)\n\t\t\t}\n\t\t}\n\t}\n\tif pos1 == length1 {\n\t\tx1.highlowcontainer.appendCopyMany(x2.highlowcontainer, pos2, length2)\n\t}\n\treturn x1\n}\n\n// to be called after lazy aggregates\nfunc (x1 *Bitmap) repairAfterLazy() {\n\tfor pos := 0; pos < x1.highlowcontainer.size(); pos++ {\n\t\tc := x1.highlowcontainer.getContainerAtIndex(pos)\n\t\tswitch c.(type) {\n\t\tcase *bitmapContainer:\n\t\t\tif c.(*bitmapContainer).cardinality == invalidCardinality {\n\t\t\t\tc = x1.highlowcontainer.getWritableContainerAtIndex(pos)\n\t\t\t\tc.(*bitmapContainer).computeCardinality()\n\t\t\t\tif c.(*bitmapContainer).getCardinality() <= arrayDefaultMaxSize {\n\t\t\t\t\tx1.highlowcontainer.setContainerAtIndex(pos, c.(*bitmapContainer).toArrayContainer())\n\t\t\t\t} else if c.(*bitmapContainer).isFull() {\n\t\t\t\t\tx1.highlowcontainer.setContainerAtIndex(pos, newRunContainer16Range(0, MaxUint16))\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n// FastAnd computes the intersection between many bitmaps quickly\n// Compared to the And function, it can take many bitmaps as input, thus saving the trouble\n// of manually calling \"And\" many times.\n//\n// Performance hints: if you have very large and tiny bitmaps,\n// it may be beneficial performance-wise to put a tiny bitmap\n// in first position.\nfunc FastAnd(bitmaps ...*Bitmap) *Bitmap {\n\tif len(bitmaps) == 0 {\n\t\treturn NewBitmap()\n\t} else if len(bitmaps) == 1 {\n\t\treturn bitmaps[0].Clone()\n\t}\n\tanswer := And(bitmaps[0], bitmaps[1])\n\tfor _, bm := range bitmaps[2:] {\n\t\tanswer.And(bm)\n\t}\n\treturn answer\n}\n\n// FastOr computes the union between many bitmaps quickly, as opposed to having to call Or repeatedly.\n// It might also be faster than calling Or repeatedly.\nfunc FastOr(bitmaps ...*Bitmap) *Bitmap {\n\tif len(bitmaps) == 0 {\n\t\treturn NewBitmap()\n\t} else if len(bitmaps) == 1 {\n\t\treturn bitmaps[0].Clone()\n\t}\n\tanswer := lazyOR(bitmaps[0], bitmaps[1])\n\tfor _, bm := range bitmaps[2:] {\n\t\tanswer = answer.lazyOR(bm)\n\t}\n\t// here is where repairAfterLazy is called.\n\tanswer.repairAfterLazy()\n\treturn answer\n}\n\n// HeapOr computes the union between many bitmaps quickly using a heap.\n// It might be faster than calling Or repeatedly.\nfunc HeapOr(bitmaps ...*Bitmap) *Bitmap {\n\tif len(bitmaps) == 0 {\n\t\treturn NewBitmap()\n\t}\n\t// TODO:  for better speed, we could do the operation lazily, see Java implementation\n\tpq := make(priorityQueue, len(bitmaps))\n\tfor i, bm := range bitmaps {\n\t\tpq[i] = &item{bm, i}\n\t}\n\theap.Init(&pq)\n\n\tfor pq.Len() > 1 {\n\t\tx1 := heap.Pop(&pq).(*item)\n\t\tx2 := heap.Pop(&pq).(*item)\n\t\theap.Push(&pq, &item{Or(x1.value, x2.value), 0})\n\t}\n\treturn heap.Pop(&pq).(*item).value\n}\n\n// HeapXor computes the symmetric difference between many bitmaps quickly (as opposed to calling Xor repeated).\n// Internally, this function uses a heap.\n// It might be faster than calling Xor repeatedly.\nfunc HeapXor(bitmaps ...*Bitmap) *Bitmap {\n\tif len(bitmaps) == 0 {\n\t\treturn NewBitmap()\n\t}\n\n\tpq := make(priorityQueue, len(bitmaps))\n\tfor i, bm := range bitmaps {\n\t\tpq[i] = &item{bm, i}\n\t}\n\theap.Init(&pq)\n\n\tfor pq.Len() > 1 {\n\t\tx1 := heap.Pop(&pq).(*item)\n\t\tx2 := heap.Pop(&pq).(*item)\n\t\theap.Push(&pq, &item{Xor(x1.value, x2.value), 0})\n\t}\n\treturn heap.Pop(&pq).(*item).value\n}\n\n// AndAny provides a result equivalent to x1.And(FastOr(bitmaps)).\n// It's optimized to minimize allocations. It also might be faster than separate calls.\nfunc (x1 *Bitmap) AndAny(bitmaps ...*Bitmap) {\n\tif len(bitmaps) == 0 {\n\t\treturn\n\t} else if len(bitmaps) == 1 {\n\t\tx1.And(bitmaps[0])\n\t\treturn\n\t}\n\n\ttype withPos struct {\n\t\tbitmap *roaringArray\n\t\tpos    int\n\t\tkey    uint16\n\t}\n\tfilters := make([]withPos, 0, len(bitmaps))\n\n\tfor _, b := range bitmaps {\n\t\tif b.highlowcontainer.size() > 0 {\n\t\t\tfilters = append(filters, withPos{\n\t\t\t\tbitmap: &b.highlowcontainer,\n\t\t\t\tpos:    0,\n\t\t\t\tkey:    b.highlowcontainer.getKeyAtIndex(0),\n\t\t\t})\n\t\t}\n\t}\n\n\tbasePos := 0\n\tintersections := 0\n\tkeyContainers := make([]container, 0, len(filters))\n\tvar (\n\t\ttmpArray   *arrayContainer\n\t\ttmpBitmap  *bitmapContainer\n\t\tminNextKey uint16\n\t)\n\n\tfor basePos < x1.highlowcontainer.size() && len(filters) > 0 {\n\t\tbaseKey := x1.highlowcontainer.getKeyAtIndex(basePos)\n\n\t\t// accumulate containers for current key, find next minimal key in filters\n\t\t// and exclude filters that do not have related values anymore\n\t\ti := 0\n\t\tmaxPossibleOr := 0\n\t\tminNextKey = MaxUint16\n\t\tfor _, f := range filters {\n\t\t\tif f.key < baseKey {\n\t\t\t\tf.pos = f.bitmap.advanceUntil(baseKey, f.pos)\n\t\t\t\tif f.pos == f.bitmap.size() {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\tf.key = f.bitmap.getKeyAtIndex(f.pos)\n\t\t\t}\n\n\t\t\tif f.key == baseKey {\n\t\t\t\tcont := f.bitmap.getContainerAtIndex(f.pos)\n\t\t\t\tkeyContainers = append(keyContainers, cont)\n\t\t\t\tmaxPossibleOr += cont.getCardinality()\n\n\t\t\t\tf.pos++\n\t\t\t\tif f.pos == f.bitmap.size() {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\tf.key = f.bitmap.getKeyAtIndex(f.pos)\n\t\t\t}\n\n\t\t\tminNextKey = minOfUint16(minNextKey, f.key)\n\t\t\tfilters[i] = f\n\t\t\ti++\n\t\t}\n\t\tfilters = filters[:i]\n\n\t\tif len(keyContainers) == 0 {\n\t\t\tbasePos = x1.highlowcontainer.advanceUntil(minNextKey, basePos)\n\t\t\tcontinue\n\t\t}\n\n\t\tvar ored container\n\n\t\tif len(keyContainers) == 1 {\n\t\t\tored = keyContainers[0]\n\t\t} else {\n\t\t\t//TODO: special case for run containers?\n\t\t\tif maxPossibleOr > arrayDefaultMaxSize {\n\t\t\t\tif tmpBitmap == nil {\n\t\t\t\t\ttmpBitmap = newBitmapContainer()\n\t\t\t\t}\n\t\t\t\ttmpBitmap.resetTo(keyContainers[0])\n\t\t\t\tored = tmpBitmap\n\t\t\t} else {\n\t\t\t\tif tmpArray == nil {\n\t\t\t\t\ttmpArray = newArrayContainerCapacity(maxPossibleOr)\n\t\t\t\t}\n\t\t\t\ttmpArray.realloc(maxPossibleOr)\n\t\t\t\ttmpArray.resetTo(keyContainers[0])\n\t\t\t\tored = tmpArray\n\t\t\t}\n\t\t\tfor _, c := range keyContainers[1:] {\n\t\t\t\tored = ored.ior(c)\n\t\t\t}\n\t\t}\n\n\t\tresult := x1.highlowcontainer.getWritableContainerAtIndex(basePos).iand(ored)\n\t\tif !result.isEmpty() {\n\t\t\tx1.highlowcontainer.replaceKeyAndContainerAtIndex(intersections, baseKey, result, false)\n\t\t\tintersections++\n\t\t}\n\n\t\tkeyContainers = keyContainers[:0]\n\t\tbasePos = x1.highlowcontainer.advanceUntil(minNextKey, basePos)\n\t}\n\n\tx1.highlowcontainer.resize(intersections)\n}\n"
        },
        {
          "name": "fastaggregation_test.go",
          "type": "blob",
          "size": 6.0712890625,
          "content": "package roaring\n\n// to run just these tests: go test -run TestFastAggregations*\n\nimport (\n\t\"container/heap\"\n\t\"github.com/stretchr/testify/assert\"\n\t\"testing\"\n)\n\nfunc TestFastAggregationsSize(t *testing.T) {\n\trb1 := NewBitmap()\n\trb2 := NewBitmap()\n\trb3 := NewBitmap()\n\tfor i := uint32(0); i < 1000000; i += 3 {\n\t\trb1.Add(i)\n\t}\n\tfor i := uint32(0); i < 1000000; i += 7 {\n\t\trb2.Add(i)\n\t}\n\tfor i := uint32(0); i < 1000000; i += 1001 {\n\t\trb3.Add(i)\n\t}\n\tpq := make(priorityQueue, 3)\n\tpq[0] = &item{rb1, 0}\n\tpq[1] = &item{rb2, 1}\n\tpq[2] = &item{rb3, 2}\n\theap.Init(&pq)\n\n\tassert.Equal(t, rb3.GetSizeInBytes(), heap.Pop(&pq).(*item).value.GetSizeInBytes())\n\tassert.Equal(t, rb2.GetSizeInBytes(), heap.Pop(&pq).(*item).value.GetSizeInBytes())\n\tassert.Equal(t, rb1.GetSizeInBytes(), heap.Pop(&pq).(*item).value.GetSizeInBytes())\n}\n\nfunc TestFastAggregationsCont(t *testing.T) {\n\trb1 := NewBitmap()\n\trb2 := NewBitmap()\n\trb3 := NewBitmap()\n\tfor i := uint32(0); i < 10; i += 3 {\n\t\trb1.Add(i)\n\t}\n\tfor i := uint32(0); i < 10; i += 7 {\n\t\trb2.Add(i)\n\t}\n\tfor i := uint32(0); i < 10; i += 1001 {\n\t\trb3.Add(i)\n\t}\n\tfor i := uint32(1000000); i < 1000000+10; i += 1001 {\n\t\trb1.Add(i)\n\t}\n\tfor i := uint32(1000000); i < 1000000+10; i += 7 {\n\t\trb2.Add(i)\n\t}\n\tfor i := uint32(1000000); i < 1000000+10; i += 3 {\n\t\trb3.Add(i)\n\t}\n\trb1.Add(500000)\n\tpq := make(containerPriorityQueue, 3)\n\tpq[0] = &containeritem{rb1, 0, 0}\n\tpq[1] = &containeritem{rb2, 0, 1}\n\tpq[2] = &containeritem{rb3, 0, 2}\n\theap.Init(&pq)\n\texpected := []int{6, 4, 5, 6, 5, 4, 6}\n\tcounter := 0\n\tfor pq.Len() > 0 {\n\t\tx1 := heap.Pop(&pq).(*containeritem)\n\t\tassert.EqualValues(t, expected[counter], x1.value.GetCardinality())\n\n\t\tcounter++\n\t\tx1.keyindex++\n\t\tif x1.keyindex < x1.value.highlowcontainer.size() {\n\t\t\theap.Push(&pq, x1)\n\t\t}\n\t}\n}\n\nfunc TestFastAggregationsAdvanced_run(t *testing.T) {\n\trb1 := NewBitmap()\n\trb2 := NewBitmap()\n\trb3 := NewBitmap()\n\tfor i := uint32(500); i < 75000; i++ {\n\t\trb1.Add(i)\n\t}\n\tfor i := uint32(0); i < 1000000; i += 7 {\n\t\trb2.Add(i)\n\t}\n\tfor i := uint32(0); i < 1000000; i += 1001 {\n\t\trb3.Add(i)\n\t}\n\tfor i := uint32(1000000); i < 2000000; i += 1001 {\n\t\trb1.Add(i)\n\t}\n\tfor i := uint32(1000000); i < 2000000; i += 3 {\n\t\trb2.Add(i)\n\t}\n\tfor i := uint32(1000000); i < 2000000; i += 7 {\n\t\trb3.Add(i)\n\t}\n\trb1.RunOptimize()\n\trb1.Or(rb2)\n\trb1.Or(rb3)\n\tbigand := And(And(rb1, rb2), rb3)\n\tbigxor := Xor(Xor(rb1, rb2), rb3)\n\n\tassert.True(t, FastOr(rb1, rb2, rb3).Equals(rb1))\n\tassert.True(t, HeapOr(rb1, rb2, rb3).Equals(rb1))\n\tassert.Equal(t, rb1.GetCardinality(), HeapOr(rb1, rb2, rb3).GetCardinality())\n\tassert.True(t, HeapXor(rb1, rb2, rb3).Equals(bigxor))\n\tassert.True(t, FastAnd(rb1, rb2, rb3).Equals(bigand))\n}\n\nfunc TestFastAggregationsXOR(t *testing.T) {\n\trb1 := NewBitmap()\n\trb2 := NewBitmap()\n\trb3 := NewBitmap()\n\n\tfor i := uint32(0); i < 40000; i++ {\n\t\trb1.Add(i)\n\t}\n\tfor i := uint32(0); i < 40000; i += 4000 {\n\t\trb2.Add(i)\n\t}\n\tfor i := uint32(0); i < 40000; i += 5000 {\n\t\trb3.Add(i)\n\t}\n\n\tassert.EqualValues(t, 40000, rb1.GetCardinality())\n\n\txor1 := Xor(rb1, rb2)\n\txor1alt := Xor(rb2, rb1)\n\tassert.True(t, xor1alt.Equals(xor1))\n\tassert.True(t, HeapXor(rb1, rb2).Equals(xor1))\n\n\txor2 := Xor(rb2, rb3)\n\txor2alt := Xor(rb3, rb2)\n\tassert.True(t, xor2alt.Equals(xor2))\n\tassert.True(t, HeapXor(rb2, rb3).Equals(xor2))\n\n\tbigxor := Xor(Xor(rb1, rb2), rb3)\n\tbigxoralt1 := Xor(rb1, Xor(rb2, rb3))\n\tbigxoralt2 := Xor(rb1, Xor(rb3, rb2))\n\tbigxoralt3 := Xor(rb3, Xor(rb1, rb2))\n\tbigxoralt4 := Xor(Xor(rb1, rb2), rb3)\n\n\tassert.True(t, bigxoralt2.Equals(bigxor))\n\tassert.True(t, bigxoralt1.Equals(bigxor))\n\tassert.True(t, bigxoralt3.Equals(bigxor))\n\tassert.True(t, bigxoralt4.Equals(bigxor))\n\n\tassert.True(t, HeapXor(rb1, rb2, rb3).Equals(bigxor))\n}\n\nfunc TestFastAggregationsXOR_run(t *testing.T) {\n\trb1 := NewBitmap()\n\trb2 := NewBitmap()\n\trb3 := NewBitmap()\n\n\tfor i := uint32(0); i < 40000; i++ {\n\t\trb1.Add(i)\n\t}\n\trb1.RunOptimize()\n\tfor i := uint32(0); i < 40000; i += 4000 {\n\t\trb2.Add(i)\n\t}\n\tfor i := uint32(0); i < 40000; i += 5000 {\n\t\trb3.Add(i)\n\t}\n\n\tassert.EqualValues(t, 40000, rb1.GetCardinality())\n\n\txor1 := Xor(rb1, rb2)\n\txor1alt := Xor(rb2, rb1)\n\tassert.True(t, xor1alt.Equals(xor1))\n\tassert.True(t, HeapXor(rb1, rb2).Equals(xor1))\n\n\txor2 := Xor(rb2, rb3)\n\txor2alt := Xor(rb3, rb2)\n\tassert.True(t, xor2alt.Equals(xor2))\n\tassert.True(t, HeapXor(rb2, rb3).Equals(xor2))\n\n\tbigxor := Xor(Xor(rb1, rb2), rb3)\n\tbigxoralt1 := Xor(rb1, Xor(rb2, rb3))\n\tbigxoralt2 := Xor(rb1, Xor(rb3, rb2))\n\tbigxoralt3 := Xor(rb3, Xor(rb1, rb2))\n\tbigxoralt4 := Xor(Xor(rb1, rb2), rb3)\n\n\tassert.True(t, bigxoralt2.Equals(bigxor))\n\tassert.True(t, bigxoralt1.Equals(bigxor))\n\tassert.True(t, bigxoralt3.Equals(bigxor))\n\tassert.True(t, bigxoralt4.Equals(bigxor))\n\n\tassert.True(t, HeapXor(rb1, rb2, rb3).Equals(bigxor))\n}\n\nfunc TestFastAggregationsAndAny(t *testing.T) {\n\tbase := NewBitmap()\n\trb1 := NewBitmap()\n\trb2 := NewBitmap()\n\trb3 := NewBitmap()\n\t// only one filter has some values\n\tfrom := uint32(maxCapacity * 4)\n\tfor i := uint32(from); i < from+100; i += 2 {\n\t\trb1.Add(i)\n\t}\n\t// only base has values\n\tfrom = maxCapacity * 7\n\tfor i := uint32(from); i < from+100; i += 2 {\n\t\tbase.Add(i)\n\t}\n\t// base and one of filters have same values\n\tfrom = maxCapacity * 8\n\tfor i := uint32(from); i < from+100; i += 2 {\n\t\tbase.Add(i)\n\t\trb1.Add(i)\n\t}\n\t// small union\n\tfrom = maxCapacity * 10\n\tfor i := uint32(from); i < from+1000; i += 10 {\n\t\tbase.Add(i)\n\t\tbase.Add(i + i%3)\n\n\t\trb1.Add(i)\n\t\trb1.Add(i + 1)\n\n\t\trb2.Add(i + 2)\n\t\trb2.Add(i + i%7)\n\n\t\trb3.Add(200 + i)\n\t}\n\t// run filters\n\tfrom = maxCapacity * 10\n\tfor i := uint32(from); i < from+1000; i += 3 {\n\t\tbase.Add(i)\n\t}\n\tfor i := uint32(from); i < from+100; i++ {\n\t\trb1.Add(i)\n\t\trb2.Add(i + 333)\n\t\trb3.Add(i + 433)\n\t}\n\t// large union\n\tfrom = maxCapacity * 16\n\tfor i := uint32(from); i < from+arrayDefaultMaxSize*10; i += 3 {\n\t\tbase.Add(i)\n\t\tbase.Add(i + i%2 + 1)\n\t\trb2.Add(i)\n\t\trb3.Add(i + 1)\n\t}\n\n\t// some extra base values\n\tfrom = maxCapacity * 17\n\tfor i := uint32(from); i < from+1000; i++ {\n\t\tbase.Add(i)\n\t}\n\n\tbase.RunOptimize()\n\trb1.RunOptimize()\n\trb2.RunOptimize()\n\trb3.RunOptimize()\n\n\torFirst := base.Clone()\n\torFirst.And(FastOr(rb1, rb2, rb3))\n\n\tfast := base.Clone()\n\tfast.AndAny(rb1, rb2, rb3)\n\n\tassert.True(t, fast.Equals(orFirst))\n}\n"
        },
        {
          "name": "go.mod",
          "type": "blob",
          "size": 0.24609375,
          "content": "module github.com/RoaringBitmap/roaring/v2\n\ngo 1.15\n\nrequire (\n\tgithub.com/bits-and-blooms/bitset v1.12.0\n\tgithub.com/google/uuid v1.6.0\n\tgithub.com/mschoch/smat v0.2.0\n\tgithub.com/stretchr/testify v1.7.0\n)\n\nrequire gopkg.in/yaml.v3 v3.0.0 // indirect\n"
        },
        {
          "name": "go.sum",
          "type": "blob",
          "size": 1.552734375,
          "content": "github.com/bits-and-blooms/bitset v1.12.0 h1:U/q1fAF7xXRhFCrhROzIfffYnu+dlS38vCZtmFVPHmA=\ngithub.com/bits-and-blooms/bitset v1.12.0/go.mod h1:7hO7Gc7Pp1vODcmWvKMRA9BNmbv6a/7QIWpPxHddWR8=\ngithub.com/davecgh/go-spew v1.1.0 h1:ZDRjVQ15GmhC3fiQ8ni8+OwkZQO4DARzQgrnXU1Liz8=\ngithub.com/davecgh/go-spew v1.1.0/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=\ngithub.com/google/uuid v1.6.0 h1:NIvaJDMOsjHA8n1jAhLSgzrAzy1Hgr+hNrb57e+94F0=\ngithub.com/google/uuid v1.6.0/go.mod h1:TIyPZe4MgqvfeYDBFedMoGGpEw/LqOeaOT+nhxU+yHo=\ngithub.com/mschoch/smat v0.2.0 h1:8imxQsjDm8yFEAVBe7azKmKSgzSkZXDuKkSq9374khM=\ngithub.com/mschoch/smat v0.2.0/go.mod h1:kc9mz7DoBKqDyiRL7VZN8KvXQMWeTaVnttLRXOlotKw=\ngithub.com/pmezard/go-difflib v1.0.0 h1:4DBwDE0NGyQoBHbLQYPwSUPoCMWR5BEzIk/f1lZbAQM=\ngithub.com/pmezard/go-difflib v1.0.0/go.mod h1:iKH77koFhYxTK1pcRnkKkqfTogsbg7gZNVY4sRDYZ/4=\ngithub.com/stretchr/objx v0.1.0/go.mod h1:HFkY916IF+rwdDfMAkV7OtwuqBVzrE8GR6GFx+wExME=\ngithub.com/stretchr/testify v1.7.0 h1:nwc3DEeHmmLAfoZucVR881uASk0Mfjw8xYJ99tb5CcY=\ngithub.com/stretchr/testify v1.7.0/go.mod h1:6Fq8oRcR53rry900zMqJjRRixrwX3KX962/h/Wwjteg=\ngopkg.in/check.v1 v0.0.0-20161208181325-20d25e280405 h1:yhCVgyC4o1eVCa2tZl7eS0r+SDo693bJlVdllGtEeKM=\ngopkg.in/check.v1 v0.0.0-20161208181325-20d25e280405/go.mod h1:Co6ibVJAznAaIkqp8huTwlJQCZ016jof/cbN4VW5Yz0=\ngopkg.in/yaml.v3 v3.0.0-20200313102051-9f266ea9e77c/go.mod h1:K4uyk7z7BCEPqu6E+C64Yfv1cQ7kz7rIZviUmN+EgEM=\ngopkg.in/yaml.v3 v3.0.0 h1:hjy8E9ON/egN1tAYqKb61G10WtihqetD4sz2H+8nIeA=\ngopkg.in/yaml.v3 v3.0.0/go.mod h1:K4uyk7z7BCEPqu6E+C64Yfv1cQ7kz7rIZviUmN+EgEM=\n"
        },
        {
          "name": "internal",
          "type": "tree",
          "content": null
        },
        {
          "name": "manyiterator.go",
          "type": "blob",
          "size": 0.5263671875,
          "content": "package roaring\n\ntype manyIterable interface {\n\tnextMany(hs uint32, buf []uint32) int\n\tnextMany64(hs uint64, buf []uint64) int\n}\n\nfunc (si *shortIterator) nextMany(hs uint32, buf []uint32) int {\n\tn := 0\n\tl := si.loc\n\ts := si.slice\n\tfor n < len(buf) && l < len(s) {\n\t\tbuf[n] = uint32(s[l]) | hs\n\t\tl++\n\t\tn++\n\t}\n\tsi.loc = l\n\treturn n\n}\n\nfunc (si *shortIterator) nextMany64(hs uint64, buf []uint64) int {\n\tn := 0\n\tl := si.loc\n\ts := si.slice\n\tfor n < len(buf) && l < len(s) {\n\t\tbuf[n] = uint64(s[l]) | hs\n\t\tl++\n\t\tn++\n\t}\n\tsi.loc = l\n\treturn n\n}\n"
        },
        {
          "name": "manyiterator_test.go",
          "type": "blob",
          "size": 0.70703125,
          "content": "package roaring\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestManyIterator(t *testing.T) {\n\ttype searchTest struct {\n\t\tname          string\n\t\titerator      shortIterator\n\t\thigh          uint64\n\t\tbuf           []uint64\n\t\texpectedValue int\n\t}\n\n\ttests := []searchTest{\n\t\t{\n\t\t\t\"no values\",\n\t\t\tshortIterator{},\n\t\t\tuint64(1024),\n\t\t\t[]uint64{},\n\t\t\t0,\n\t\t},\n\t\t{\n\t\t\t\"1 value \",\n\t\t\tshortIterator{[]uint16{uint16(1)}, 0},\n\t\t\tuint64(1024),\n\t\t\tmake([]uint64, 1),\n\t\t\t1,\n\t\t},\n\t}\n\n\tfor _, testCase := range tests {\n\t\tt.Run(testCase.name, func(t *testing.T) {\n\t\t\titerator := testCase.iterator\n\t\t\tresult := iterator.nextMany64(testCase.high, testCase.buf)\n\t\t\tassert.Equal(t, testCase.expectedValue, result)\n\t\t})\n\t}\n}\n"
        },
        {
          "name": "optimize_test.go",
          "type": "blob",
          "size": 3.3662109375,
          "content": "package roaring_test\n\nimport (\n\t\"github.com/RoaringBitmap/roaring/v2\"\n\t\"testing\"\n)\n\nfunc TestSelectAfterOptimize(t *testing.T) {\n\tr := roaring.New()\n\tintArray := []uint32{438945, 438946, 438947, 438948, 438949, 438950, 438951, 438952, 438953, 438954, 438955, 438956, 438957, 438958, 438959, 438960, 438961, 438962, 438963, 438964, 438965, 438966, 438967, 438968, 438969, 438970, 438971, 438972, 438973, 438974, 438975, 438976, 438977, 438978, 438979, 438980, 438981, 438982, 438983, 438984, 438985, 438986, 438987, 438988, 438989, 438990, 438991, 438992, 438993, 438994, 438995, 438996, 438997, 438998, 438999, 439000, 439001, 439002, 439003, 439004, 439005, 439006, 439007, 439008, 439009, 439010, 439011, 439012, 439013, 439014, 439015, 439016, 439017, 439018, 439019, 439020, 439021, 439022, 439023, 439024, 439025, 439026, 439027, 439028, 439029, 439030, 439031, 439032, 439033, 439034, 439035, 439036, 439037, 439038, 439039, 439040, 439041, 439042, 439043, 439044, 439045, 439046, 439047, 439048, 439049, 439050, 439051, 439052, 439053, 439054, 439055, 439056, 439057, 439058, 439059, 439060, 439061, 439062, 439063, 439064, 439065, 439066, 439067, 439068, 439069, 439070, 439071, 439072, 439073, 439074, 439075, 439076, 439077, 439078, 439079, 439080, 439081, 439082, 439083, 439084, 439085, 439086, 439087, 439088, 439089, 439090, 439091, 439092, 439093, 439094, 439095, 439096, 439097, 439098, 439099, 439100, 439101, 439102, 439103, 439104, 439105, 439106, 439107, 439108, 439109, 439110, 439111, 439112, 439113, 439114, 439115, 439116, 439117, 439118, 439119, 439120, 439121, 439122, 439123, 439124, 439125, 439126, 439127, 439128, 439129, 439130, 439131, 439132, 439133, 439134, 439135, 439136, 439137, 439138, 439139, 439140, 439141, 439142, 439143, 439144, 439145, 439146, 439147, 439148, 439149, 439150, 439151, 439152, 439153, 439154, 439155, 439156, 439157, 439158, 439159, 439160, 439161, 439162, 439163, 439164, 439165, 439166, 439167, 439168, 439169, 439170, 439171, 439172, 439173, 439174, 439175, 439176, 439177, 439178, 439179, 439180, 439181, 439182, 439183, 439184, 439185, 439186, 439187, 439188, 439189, 439190, 439191, 439192, 439193, 439194, 439195, 439196, 439197, 439198, 439199, 439200, 439201, 439202, 439203, 439204, 439205, 439206, 439207, 439208, 439209, 439210, 439211, 439212, 439213, 439214, 439215, 439216, 439217, 439218, 439219, 439220, 439221, 439222, 439223, 439224, 439225, 439226, 439227, 439228, 439229, 439230, 439231, 439232, 439233, 439234, 439235, 439236, 439237, 439238, 439239, 439240, 439241, 439242, 439243, 439244, 439245, 439246, 439248}\n\tfor _, value := range intArray {\n\t\tr.Add(value)\n\t}\n\n\t// save original version as array\n\torigArray := r.ToArray()\n\n\t// comment this out to get a passing test\n\tr.RunOptimize()\n\n\t// get a list of values after optimize\n\toptimized := r.ToArray()\n\n\t// this should be fine in both cases\n\tif diff := len(optimized) - len(origArray); diff != 0 {\n\t\tt.Fatal(\"element count different - diff:\", diff)\n\t}\n\n\t// this is also fine\n\tfor i := range optimized {\n\t\tif optimized[i] != origArray[i] {\n\t\t\tt.Errorf(\"array compare %d\", i)\n\t\t}\n\t}\n\n\t// this produces errors with the optimized version of the bitmap\n\tn := r.GetCardinality()\n\tfor i := uint64(0); i < n; i++ {\n\n\t\tv, err := r.Select(uint32(i))\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\n\t\tif diff := origArray[i] - v; diff != 0 {\n\t\t\tt.Errorf(\"select %03d failed - %d vs %d (diff:%d)\", i, origArray[i], v, diff)\n\t\t}\n\t}\n}\n"
        },
        {
          "name": "parallel.go",
          "type": "blob",
          "size": 13.2119140625,
          "content": "package roaring\n\nimport (\n\t\"container/heap\"\n\t\"fmt\"\n\t\"runtime\"\n\t\"sync\"\n)\n\nvar defaultWorkerCount = runtime.NumCPU()\n\ntype bitmapContainerKey struct {\n\tkey    uint16\n\tidx    int\n\tbitmap *Bitmap\n}\n\ntype multipleContainers struct {\n\tkey        uint16\n\tcontainers []container\n\tidx        int\n}\n\ntype keyedContainer struct {\n\tkey       uint16\n\tcontainer container\n\tidx       int\n}\n\ntype bitmapContainerHeap []bitmapContainerKey\n\nfunc (h bitmapContainerHeap) Len() int           { return len(h) }\nfunc (h bitmapContainerHeap) Less(i, j int) bool { return h[i].key < h[j].key }\nfunc (h bitmapContainerHeap) Swap(i, j int)      { h[i], h[j] = h[j], h[i] }\n\nfunc (h *bitmapContainerHeap) Push(x interface{}) {\n\t// Push and Pop use pointer receivers because they modify the slice's length,\n\t// not just its contents.\n\t*h = append(*h, x.(bitmapContainerKey))\n}\n\nfunc (h *bitmapContainerHeap) Pop() interface{} {\n\told := *h\n\tn := len(old)\n\tx := old[n-1]\n\t*h = old[0 : n-1]\n\treturn x\n}\n\nfunc (h bitmapContainerHeap) Peek() bitmapContainerKey {\n\treturn h[0]\n}\n\nfunc (h *bitmapContainerHeap) popIncrementing() (key uint16, container container) {\n\tk := h.Peek()\n\tkey = k.key\n\tcontainer = k.bitmap.highlowcontainer.containers[k.idx]\n\n\tnewIdx := k.idx + 1\n\tif newIdx < k.bitmap.highlowcontainer.size() {\n\t\tk = bitmapContainerKey{\n\t\t\tk.bitmap.highlowcontainer.keys[newIdx],\n\t\t\tnewIdx,\n\t\t\tk.bitmap,\n\t\t}\n\t\t(*h)[0] = k\n\t\theap.Fix(h, 0)\n\t} else {\n\t\theap.Pop(h)\n\t}\n\n\treturn\n}\n\nfunc (h *bitmapContainerHeap) Next(containers []container) multipleContainers {\n\tif h.Len() == 0 {\n\t\treturn multipleContainers{}\n\t}\n\n\tkey, container := h.popIncrementing()\n\tcontainers = append(containers, container)\n\n\tfor h.Len() > 0 && key == h.Peek().key {\n\t\t_, container = h.popIncrementing()\n\t\tcontainers = append(containers, container)\n\t}\n\n\treturn multipleContainers{\n\t\tkey,\n\t\tcontainers,\n\t\t-1,\n\t}\n}\n\nfunc newBitmapContainerHeap(bitmaps ...*Bitmap) bitmapContainerHeap {\n\t// Initialize heap\n\tvar h bitmapContainerHeap = make([]bitmapContainerKey, 0, len(bitmaps))\n\tfor _, bitmap := range bitmaps {\n\t\tif !bitmap.IsEmpty() {\n\t\t\tkey := bitmapContainerKey{\n\t\t\t\tbitmap.highlowcontainer.keys[0],\n\t\t\t\t0,\n\t\t\t\tbitmap,\n\t\t\t}\n\t\t\th = append(h, key)\n\t\t}\n\t}\n\n\theap.Init(&h)\n\n\treturn h\n}\n\nfunc repairAfterLazy(c container) container {\n\tswitch t := c.(type) {\n\tcase *bitmapContainer:\n\t\tif t.cardinality == invalidCardinality {\n\t\t\tt.computeCardinality()\n\t\t}\n\n\t\tif t.getCardinality() <= arrayDefaultMaxSize {\n\t\t\treturn t.toArrayContainer()\n\t\t} else if c.(*bitmapContainer).isFull() {\n\t\t\treturn newRunContainer16Range(0, MaxUint16)\n\t\t}\n\t}\n\n\treturn c\n}\n\nfunc toBitmapContainer(c container) container {\n\tswitch t := c.(type) {\n\tcase *arrayContainer:\n\t\treturn t.toBitmapContainer()\n\tcase *runContainer16:\n\t\tif !t.isFull() {\n\t\t\treturn t.toBitmapContainer()\n\t\t}\n\t}\n\treturn c\n}\n\nfunc appenderRoutine(bitmapChan chan<- *Bitmap, resultChan <-chan keyedContainer, expectedKeysChan <-chan int) {\n\texpectedKeys := -1\n\tappendedKeys := 0\n\tvar keys []uint16\n\tvar containers []container\n\tfor appendedKeys != expectedKeys {\n\t\tselect {\n\t\tcase item := <-resultChan:\n\t\t\tif len(keys) <= item.idx {\n\t\t\t\tkeys = append(keys, make([]uint16, item.idx-len(keys)+1)...)\n\t\t\t\tcontainers = append(containers, make([]container, item.idx-len(containers)+1)...)\n\t\t\t}\n\t\t\tkeys[item.idx] = item.key\n\t\t\tcontainers[item.idx] = item.container\n\n\t\t\tappendedKeys++\n\t\tcase msg := <-expectedKeysChan:\n\t\t\texpectedKeys = msg\n\t\t}\n\t}\n\tanswer := &Bitmap{\n\t\troaringArray{\n\t\t\tmake([]uint16, 0, expectedKeys),\n\t\t\tmake([]container, 0, expectedKeys),\n\t\t\tmake([]bool, 0, expectedKeys),\n\t\t\tfalse,\n\t\t},\n\t}\n\tfor i := range keys {\n\t\tif containers[i] != nil { // in case a resulting container was empty, see ParAnd function\n\t\t\tanswer.highlowcontainer.appendContainer(keys[i], containers[i], false)\n\t\t}\n\t}\n\n\tbitmapChan <- answer\n}\n\n// ParHeapOr computes the union (OR) of all provided bitmaps in parallel,\n// where the parameter \"parallelism\" determines how many workers are to be used\n// (if it is set to 0, a default number of workers is chosen)\n// ParHeapOr uses a heap to compute the union. For rare cases it might be faster than ParOr\nfunc ParHeapOr(parallelism int, bitmaps ...*Bitmap) *Bitmap {\n\n\tbitmapCount := len(bitmaps)\n\tif bitmapCount == 0 {\n\t\treturn NewBitmap()\n\t} else if bitmapCount == 1 {\n\t\treturn bitmaps[0].Clone()\n\t}\n\n\tif parallelism == 0 {\n\t\tparallelism = defaultWorkerCount\n\t}\n\n\th := newBitmapContainerHeap(bitmaps...)\n\n\tbitmapChan := make(chan *Bitmap)\n\tinputChan := make(chan multipleContainers, 128)\n\tresultChan := make(chan keyedContainer, 32)\n\texpectedKeysChan := make(chan int)\n\n\tpool := sync.Pool{\n\t\tNew: func() interface{} {\n\t\t\treturn make([]container, 0, len(bitmaps))\n\t\t},\n\t}\n\n\torFunc := func() {\n\t\t// Assumes only structs with >=2 containers are passed\n\t\tfor input := range inputChan {\n\t\t\tc := toBitmapContainer(input.containers[0]).lazyOR(input.containers[1])\n\t\t\tfor _, next := range input.containers[2:] {\n\t\t\t\tc = c.lazyIOR(next)\n\t\t\t}\n\t\t\tc = repairAfterLazy(c)\n\t\t\tkx := keyedContainer{\n\t\t\t\tinput.key,\n\t\t\t\tc,\n\t\t\t\tinput.idx,\n\t\t\t}\n\t\t\tresultChan <- kx\n\t\t\tpool.Put(input.containers[:0])\n\t\t}\n\t}\n\n\tgo appenderRoutine(bitmapChan, resultChan, expectedKeysChan)\n\n\tfor i := 0; i < parallelism; i++ {\n\t\tgo orFunc()\n\t}\n\n\tidx := 0\n\tfor h.Len() > 0 {\n\t\tck := h.Next(pool.Get().([]container))\n\t\tif len(ck.containers) == 1 {\n\t\t\tresultChan <- keyedContainer{\n\t\t\t\tck.key,\n\t\t\t\tck.containers[0],\n\t\t\t\tidx,\n\t\t\t}\n\t\t\tpool.Put(ck.containers[:0])\n\t\t} else {\n\t\t\tck.idx = idx\n\t\t\tinputChan <- ck\n\t\t}\n\t\tidx++\n\t}\n\texpectedKeysChan <- idx\n\n\tbitmap := <-bitmapChan\n\n\tclose(inputChan)\n\tclose(resultChan)\n\tclose(expectedKeysChan)\n\n\treturn bitmap\n}\n\n// ParAnd computes the intersection (AND) of all provided bitmaps in parallel,\n// where the parameter \"parallelism\" determines how many workers are to be used\n// (if it is set to 0, a default number of workers is chosen)\nfunc ParAnd(parallelism int, bitmaps ...*Bitmap) *Bitmap {\n\tbitmapCount := len(bitmaps)\n\tif bitmapCount == 0 {\n\t\treturn NewBitmap()\n\t} else if bitmapCount == 1 {\n\t\treturn bitmaps[0].Clone()\n\t}\n\n\tif parallelism == 0 {\n\t\tparallelism = defaultWorkerCount\n\t}\n\n\th := newBitmapContainerHeap(bitmaps...)\n\n\tbitmapChan := make(chan *Bitmap)\n\tinputChan := make(chan multipleContainers, 128)\n\tresultChan := make(chan keyedContainer, 32)\n\texpectedKeysChan := make(chan int)\n\n\tandFunc := func() {\n\t\t// Assumes only structs with >=2 containers are passed\n\t\tfor input := range inputChan {\n\t\t\tc := input.containers[0].and(input.containers[1])\n\t\t\tfor _, next := range input.containers[2:] {\n\t\t\t\tif c.isEmpty() {\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t\tc = c.iand(next)\n\t\t\t}\n\n\t\t\t// Send a nil explicitly if the result of the intersection is an empty container\n\t\t\tif c.isEmpty() {\n\t\t\t\tc = nil\n\t\t\t}\n\n\t\t\tkx := keyedContainer{\n\t\t\t\tinput.key,\n\t\t\t\tc,\n\t\t\t\tinput.idx,\n\t\t\t}\n\t\t\tresultChan <- kx\n\t\t}\n\t}\n\n\tgo appenderRoutine(bitmapChan, resultChan, expectedKeysChan)\n\n\tfor i := 0; i < parallelism; i++ {\n\t\tgo andFunc()\n\t}\n\n\tidx := 0\n\tfor h.Len() > 0 {\n\t\tck := h.Next(make([]container, 0, 4))\n\t\tif len(ck.containers) == bitmapCount {\n\t\t\tck.idx = idx\n\t\t\tinputChan <- ck\n\t\t\tidx++\n\t\t}\n\t}\n\texpectedKeysChan <- idx\n\n\tbitmap := <-bitmapChan\n\n\tclose(inputChan)\n\tclose(resultChan)\n\tclose(expectedKeysChan)\n\n\treturn bitmap\n}\n\n// ParOr computes the union (OR) of all provided bitmaps in parallel,\n// where the parameter \"parallelism\" determines how many workers are to be used\n// (if it is set to 0, a default number of workers is chosen)\nfunc ParOr(parallelism int, bitmaps ...*Bitmap) *Bitmap {\n\tvar lKey uint16 = MaxUint16\n\tvar hKey uint16\n\n\tbitmapsFiltered := bitmaps[:0]\n\tfor _, b := range bitmaps {\n\t\tif !b.IsEmpty() {\n\t\t\tbitmapsFiltered = append(bitmapsFiltered, b)\n\t\t}\n\t}\n\tbitmaps = bitmapsFiltered\n\n\tfor _, b := range bitmaps {\n\t\tlKey = minOfUint16(lKey, b.highlowcontainer.keys[0])\n\t\thKey = maxOfUint16(hKey, b.highlowcontainer.keys[b.highlowcontainer.size()-1])\n\t}\n\n\tif lKey == MaxUint16 && hKey == 0 {\n\t\treturn New()\n\t} else if len(bitmaps) == 1 {\n\t\treturn bitmaps[0].Clone()\n\t}\n\n\tkeyRange := int(hKey) - int(lKey) + 1\n\tif keyRange == 1 {\n\t\t// revert to FastOr. Since the key range is 0\n\t\t// no container-level aggregation parallelism is achievable\n\t\treturn FastOr(bitmaps...)\n\t}\n\n\tif parallelism == 0 {\n\t\tparallelism = defaultWorkerCount\n\t}\n\n\tvar chunkSize int\n\tvar chunkCount int\n\tif parallelism*4 > int(keyRange) {\n\t\tchunkSize = 1\n\t\tchunkCount = int(keyRange)\n\t} else {\n\t\tchunkCount = parallelism * 4\n\t\tchunkSize = (int(keyRange) + chunkCount - 1) / chunkCount\n\t}\n\n\tif chunkCount*chunkSize < int(keyRange) {\n\t\t// it's fine to panic to indicate an implementation error\n\t\tpanic(fmt.Sprintf(\"invariant check failed: chunkCount * chunkSize < keyRange, %d * %d < %d\", chunkCount, chunkSize, keyRange))\n\t}\n\n\tchunks := make([]*roaringArray, chunkCount)\n\n\tchunkSpecChan := make(chan parChunkSpec, minOfInt(maxOfInt(64, 2*parallelism), int(chunkCount)))\n\tchunkChan := make(chan parChunk, minOfInt(32, int(chunkCount)))\n\n\torFunc := func() {\n\t\tfor spec := range chunkSpecChan {\n\t\t\tra := lazyOrOnRange(&bitmaps[0].highlowcontainer, &bitmaps[1].highlowcontainer, spec.start, spec.end)\n\t\t\tfor _, b := range bitmaps[2:] {\n\t\t\t\tra = lazyIOrOnRange(ra, &b.highlowcontainer, spec.start, spec.end)\n\t\t\t}\n\n\t\t\tfor i, c := range ra.containers {\n\t\t\t\tra.containers[i] = repairAfterLazy(c)\n\t\t\t}\n\n\t\t\tchunkChan <- parChunk{ra, spec.idx}\n\t\t}\n\t}\n\n\tfor i := 0; i < parallelism; i++ {\n\t\tgo orFunc()\n\t}\n\n\tgo func() {\n\t\tfor i := 0; i < chunkCount; i++ {\n\t\t\tspec := parChunkSpec{\n\t\t\t\tstart: uint16(int(lKey) + i*chunkSize),\n\t\t\t\tend:   uint16(minOfInt(int(lKey)+(i+1)*chunkSize-1, int(hKey))),\n\t\t\t\tidx:   int(i),\n\t\t\t}\n\t\t\tchunkSpecChan <- spec\n\t\t}\n\t}()\n\n\tchunksRemaining := chunkCount\n\tfor chunk := range chunkChan {\n\t\tchunks[chunk.idx] = chunk.ra\n\t\tchunksRemaining--\n\t\tif chunksRemaining == 0 {\n\t\t\tbreak\n\t\t}\n\t}\n\tclose(chunkChan)\n\tclose(chunkSpecChan)\n\n\tcontainerCount := 0\n\tfor _, chunk := range chunks {\n\t\tcontainerCount += chunk.size()\n\t}\n\n\tresult := Bitmap{\n\t\troaringArray{\n\t\t\tcontainers:      make([]container, containerCount),\n\t\t\tkeys:            make([]uint16, containerCount),\n\t\t\tneedCopyOnWrite: make([]bool, containerCount),\n\t\t},\n\t}\n\n\tresultOffset := 0\n\tfor _, chunk := range chunks {\n\t\tcopy(result.highlowcontainer.containers[resultOffset:], chunk.containers)\n\t\tcopy(result.highlowcontainer.keys[resultOffset:], chunk.keys)\n\t\tcopy(result.highlowcontainer.needCopyOnWrite[resultOffset:], chunk.needCopyOnWrite)\n\t\tresultOffset += chunk.size()\n\t}\n\n\treturn &result\n}\n\ntype parChunkSpec struct {\n\tstart uint16\n\tend   uint16\n\tidx   int\n}\n\ntype parChunk struct {\n\tra  *roaringArray\n\tidx int\n}\n\nfunc (c parChunk) size() int {\n\treturn c.ra.size()\n}\n\nfunc parNaiveStartAt(ra *roaringArray, start uint16, last uint16) int {\n\tfor idx, key := range ra.keys {\n\t\tif key >= start && key <= last {\n\t\t\treturn idx\n\t\t} else if key > last {\n\t\t\tbreak\n\t\t}\n\t}\n\treturn ra.size()\n}\n\nfunc lazyOrOnRange(ra1, ra2 *roaringArray, start, last uint16) *roaringArray {\n\tanswer := newRoaringArray()\n\tlength1 := ra1.size()\n\tlength2 := ra2.size()\n\n\tidx1 := parNaiveStartAt(ra1, start, last)\n\tidx2 := parNaiveStartAt(ra2, start, last)\n\n\tvar key1 uint16\n\tvar key2 uint16\n\tif idx1 < length1 && idx2 < length2 {\n\t\tkey1 = ra1.getKeyAtIndex(idx1)\n\t\tkey2 = ra2.getKeyAtIndex(idx2)\n\n\t\tfor key1 <= last && key2 <= last {\n\n\t\t\tif key1 < key2 {\n\t\t\t\tanswer.appendCopy(*ra1, idx1)\n\t\t\t\tidx1++\n\t\t\t\tif idx1 == length1 {\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t\tkey1 = ra1.getKeyAtIndex(idx1)\n\t\t\t} else if key1 > key2 {\n\t\t\t\tanswer.appendCopy(*ra2, idx2)\n\t\t\t\tidx2++\n\t\t\t\tif idx2 == length2 {\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t\tkey2 = ra2.getKeyAtIndex(idx2)\n\t\t\t} else {\n\t\t\t\tc1 := ra1.getFastContainerAtIndex(idx1, false)\n\n\t\t\t\tanswer.appendContainer(key1, c1.lazyOR(ra2.getContainerAtIndex(idx2)), false)\n\t\t\t\tidx1++\n\t\t\t\tidx2++\n\t\t\t\tif idx1 == length1 || idx2 == length2 {\n\t\t\t\t\tbreak\n\t\t\t\t}\n\n\t\t\t\tkey1 = ra1.getKeyAtIndex(idx1)\n\t\t\t\tkey2 = ra2.getKeyAtIndex(idx2)\n\t\t\t}\n\t\t}\n\t}\n\n\tif idx2 < length2 {\n\t\tkey2 = ra2.getKeyAtIndex(idx2)\n\t\tfor key2 <= last {\n\t\t\tanswer.appendCopy(*ra2, idx2)\n\t\t\tidx2++\n\t\t\tif idx2 == length2 {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tkey2 = ra2.getKeyAtIndex(idx2)\n\t\t}\n\t}\n\n\tif idx1 < length1 {\n\t\tkey1 = ra1.getKeyAtIndex(idx1)\n\t\tfor key1 <= last {\n\t\t\tanswer.appendCopy(*ra1, idx1)\n\t\t\tidx1++\n\t\t\tif idx1 == length1 {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tkey1 = ra1.getKeyAtIndex(idx1)\n\t\t}\n\t}\n\treturn answer\n}\n\nfunc lazyIOrOnRange(ra1, ra2 *roaringArray, start, last uint16) *roaringArray {\n\tlength1 := ra1.size()\n\tlength2 := ra2.size()\n\n\tidx1 := 0\n\tidx2 := parNaiveStartAt(ra2, start, last)\n\n\tvar key1 uint16\n\tvar key2 uint16\n\tif idx1 < length1 && idx2 < length2 {\n\t\tkey1 = ra1.getKeyAtIndex(idx1)\n\t\tkey2 = ra2.getKeyAtIndex(idx2)\n\n\t\tfor key1 <= last && key2 <= last {\n\t\t\tif key1 < key2 {\n\t\t\t\tidx1++\n\t\t\t\tif idx1 >= length1 {\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t\tkey1 = ra1.getKeyAtIndex(idx1)\n\t\t\t} else if key1 > key2 {\n\t\t\t\tra1.insertNewKeyValueAt(idx1, key2, ra2.getContainerAtIndex(idx2))\n\t\t\t\tra1.needCopyOnWrite[idx1] = true\n\t\t\t\tidx2++\n\t\t\t\tidx1++\n\t\t\t\tlength1++\n\t\t\t\tif idx2 >= length2 {\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t\tkey2 = ra2.getKeyAtIndex(idx2)\n\t\t\t} else {\n\t\t\t\tc1 := ra1.getFastContainerAtIndex(idx1, true)\n\n\t\t\t\tra1.containers[idx1] = c1.lazyIOR(ra2.getContainerAtIndex(idx2))\n\t\t\t\tra1.needCopyOnWrite[idx1] = false\n\t\t\t\tidx1++\n\t\t\t\tidx2++\n\t\t\t\tif idx1 >= length1 || idx2 >= length2 {\n\t\t\t\t\tbreak\n\t\t\t\t}\n\n\t\t\t\tkey1 = ra1.getKeyAtIndex(idx1)\n\t\t\t\tkey2 = ra2.getKeyAtIndex(idx2)\n\t\t\t}\n\t\t}\n\t}\n\tif idx2 < length2 {\n\t\tkey2 = ra2.getKeyAtIndex(idx2)\n\t\tfor key2 <= last {\n\t\t\tra1.appendCopy(*ra2, idx2)\n\t\t\tidx2++\n\t\t\tif idx2 >= length2 {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tkey2 = ra2.getKeyAtIndex(idx2)\n\t\t}\n\t}\n\treturn ra1\n}\n"
        },
        {
          "name": "parallel_benchmark_test.go",
          "type": "blob",
          "size": 1.009765625,
          "content": "package roaring\n\nimport (\n\t\"math/rand\"\n\t\"testing\"\n)\n\nfunc BenchmarkIntersectionLargeParallel(b *testing.B) {\n\tb.StopTimer()\n\n\tinitsize := 650000\n\tr := rand.New(rand.NewSource(0))\n\n\ts1 := NewBitmap()\n\tsz := 150 * 1000 * 1000\n\tfor i := 0; i < initsize; i++ {\n\t\ts1.Add(uint32(r.Int31n(int32(sz))))\n\t}\n\n\ts2 := NewBitmap()\n\tsz = 100 * 1000 * 1000\n\tfor i := 0; i < initsize; i++ {\n\t\ts2.Add(uint32(r.Int31n(int32(sz))))\n\t}\n\n\tb.StartTimer()\n\tcard := uint64(0)\n\tfor j := 0; j < b.N; j++ {\n\t\ts3 := ParAnd(0, s1, s2)\n\t\tcard = card + s3.GetCardinality()\n\t}\n}\n\nfunc BenchmarkIntersectionLargeRoaring(b *testing.B) {\n\tb.StopTimer()\n\tinitsize := 650000\n\tr := rand.New(rand.NewSource(0))\n\n\ts1 := NewBitmap()\n\tsz := 150 * 1000 * 1000\n\tfor i := 0; i < initsize; i++ {\n\t\ts1.Add(uint32(r.Int31n(int32(sz))))\n\t}\n\n\ts2 := NewBitmap()\n\tsz = 100 * 1000 * 1000\n\tfor i := 0; i < initsize; i++ {\n\t\ts2.Add(uint32(r.Int31n(int32(sz))))\n\t}\n\n\tb.StartTimer()\n\tcard := uint64(0)\n\tfor j := 0; j < b.N; j++ {\n\t\ts3 := And(s1, s2)\n\t\tcard = card + s3.GetCardinality()\n\t}\n}\n"
        },
        {
          "name": "popcnt.go",
          "type": "blob",
          "size": 0.23828125,
          "content": "//go:build go1.9\n// +build go1.9\n\n// \"go1.9\", from Go version 1.9 onward\n// See https://golang.org/pkg/go/build/#hdr-Build_Constraints\n\npackage roaring\n\nimport \"math/bits\"\n\nfunc popcount(x uint64) uint64 {\n\treturn uint64(bits.OnesCount64(x))\n}\n"
        },
        {
          "name": "popcnt_amd64.s",
          "type": "blob",
          "size": 1.697265625,
          "content": "// +build amd64,!appengine,!go1.9\n\nTEXT ¬∑hasAsm(SB),4,$0-1\nMOVQ $1, AX\nCPUID\nSHRQ $23, CX\nANDQ $1, CX\nMOVB CX, ret+0(FP)\nRET\n\n#define POPCNTQ_DX_DX BYTE $0xf3; BYTE $0x48; BYTE $0x0f; BYTE $0xb8; BYTE $0xd2\n\nTEXT ¬∑popcntSliceAsm(SB),4,$0-32\nXORQ\tAX, AX\nMOVQ\ts+0(FP), SI\nMOVQ\ts_len+8(FP), CX\nTESTQ\tCX, CX\nJZ\t\tpopcntSliceEnd\npopcntSliceLoop:\nBYTE $0xf3; BYTE $0x48; BYTE $0x0f; BYTE $0xb8; BYTE $0x16 // POPCNTQ (SI), DX\nADDQ\tDX, AX\nADDQ\t$8, SI\nLOOP\tpopcntSliceLoop\npopcntSliceEnd:\nMOVQ\tAX, ret+24(FP)\nRET\n\nTEXT ¬∑popcntMaskSliceAsm(SB),4,$0-56\nXORQ\tAX, AX\nMOVQ\ts+0(FP), SI\nMOVQ\ts_len+8(FP), CX\nTESTQ\tCX, CX\nJZ\t\tpopcntMaskSliceEnd\nMOVQ\tm+24(FP), DI\npopcntMaskSliceLoop:\nMOVQ\t(DI), DX\nNOTQ\tDX\nANDQ\t(SI), DX\nPOPCNTQ_DX_DX\nADDQ\tDX, AX\nADDQ\t$8, SI\nADDQ\t$8, DI\nLOOP\tpopcntMaskSliceLoop\npopcntMaskSliceEnd:\nMOVQ\tAX, ret+48(FP)\nRET\n\nTEXT ¬∑popcntAndSliceAsm(SB),4,$0-56\nXORQ\tAX, AX\nMOVQ\ts+0(FP), SI\nMOVQ\ts_len+8(FP), CX\nTESTQ\tCX, CX\nJZ\t\tpopcntAndSliceEnd\nMOVQ\tm+24(FP), DI\npopcntAndSliceLoop:\nMOVQ\t(DI), DX\nANDQ\t(SI), DX\nPOPCNTQ_DX_DX\nADDQ\tDX, AX\nADDQ\t$8, SI\nADDQ\t$8, DI\nLOOP\tpopcntAndSliceLoop\npopcntAndSliceEnd:\nMOVQ\tAX, ret+48(FP)\nRET\n\nTEXT ¬∑popcntOrSliceAsm(SB),4,$0-56\nXORQ\tAX, AX\nMOVQ\ts+0(FP), SI\nMOVQ\ts_len+8(FP), CX\nTESTQ\tCX, CX\nJZ\t\tpopcntOrSliceEnd\nMOVQ\tm+24(FP), DI\npopcntOrSliceLoop:\nMOVQ\t(DI), DX\nORQ\t\t(SI), DX\nPOPCNTQ_DX_DX\nADDQ\tDX, AX\nADDQ\t$8, SI\nADDQ\t$8, DI\nLOOP\tpopcntOrSliceLoop\npopcntOrSliceEnd:\nMOVQ\tAX, ret+48(FP)\nRET\n\nTEXT ¬∑popcntXorSliceAsm(SB),4,$0-56\nXORQ\tAX, AX\nMOVQ\ts+0(FP), SI\nMOVQ\ts_len+8(FP), CX\nTESTQ\tCX, CX\nJZ\t\tpopcntXorSliceEnd\nMOVQ\tm+24(FP), DI\npopcntXorSliceLoop:\nMOVQ\t(DI), DX\nXORQ\t(SI), DX\nPOPCNTQ_DX_DX\nADDQ\tDX, AX\nADDQ\t$8, SI\nADDQ\t$8, DI\nLOOP\tpopcntXorSliceLoop\npopcntXorSliceEnd:\nMOVQ\tAX, ret+48(FP)\nRET\n"
        },
        {
          "name": "popcnt_asm.go",
          "type": "blob",
          "size": 1.1865234375,
          "content": "//go:build amd64 && !appengine && !go1.9\n// +build amd64,!appengine,!go1.9\n\npackage roaring\n\n// *** the following functions are defined in popcnt_amd64.s\n\n//go:noescape\n\nfunc hasAsm() bool\n\n// useAsm is a flag used to select the GO or ASM implementation of the popcnt function\nvar useAsm = hasAsm()\n\n//go:noescape\n\nfunc popcntSliceAsm(s []uint64) uint64\n\n//go:noescape\n\nfunc popcntMaskSliceAsm(s, m []uint64) uint64\n\n//go:noescape\n\nfunc popcntAndSliceAsm(s, m []uint64) uint64\n\n//go:noescape\n\nfunc popcntOrSliceAsm(s, m []uint64) uint64\n\n//go:noescape\n\nfunc popcntXorSliceAsm(s, m []uint64) uint64\n\nfunc popcntSlice(s []uint64) uint64 {\n\tif useAsm {\n\t\treturn popcntSliceAsm(s)\n\t}\n\treturn popcntSliceGo(s)\n}\n\nfunc popcntMaskSlice(s, m []uint64) uint64 {\n\tif useAsm {\n\t\treturn popcntMaskSliceAsm(s, m)\n\t}\n\treturn popcntMaskSliceGo(s, m)\n}\n\nfunc popcntAndSlice(s, m []uint64) uint64 {\n\tif useAsm {\n\t\treturn popcntAndSliceAsm(s, m)\n\t}\n\treturn popcntAndSliceGo(s, m)\n}\n\nfunc popcntOrSlice(s, m []uint64) uint64 {\n\tif useAsm {\n\t\treturn popcntOrSliceAsm(s, m)\n\t}\n\treturn popcntOrSliceGo(s, m)\n}\n\nfunc popcntXorSlice(s, m []uint64) uint64 {\n\tif useAsm {\n\t\treturn popcntXorSliceAsm(s, m)\n\t}\n\treturn popcntXorSliceGo(s, m)\n}\n"
        },
        {
          "name": "popcnt_bench_test.go",
          "type": "blob",
          "size": 0.197265625,
          "content": "package roaring\n\nimport \"testing\"\n\nfunc BenchmarkPopcount(b *testing.B) {\n\tb.StopTimer()\n\n\tr := getRandomUint64Set(64)\n\n\tb.ResetTimer()\n\tb.StartTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\tpopcntSlice(r)\n\t}\n}\n"
        },
        {
          "name": "popcnt_compat.go",
          "type": "blob",
          "size": 0.51953125,
          "content": "//go:build !go1.9\n// +build !go1.9\n\npackage roaring\n\n// bit population count, take from\n// https://code.google.com/p/go/issues/detail?id=4988#c11\n// credit: https://code.google.com/u/arnehormann/\n// credit: https://play.golang.org/p/U7SogJ7psJ\n// credit: http://graphics.stanford.edu/~seander/bithacks.html#CountBitsSetParallel\nfunc popcount(x uint64) uint64 {\n\tx -= (x >> 1) & 0x5555555555555555\n\tx = (x>>2)&0x3333333333333333 + x&0x3333333333333333\n\tx += x >> 4\n\tx &= 0x0f0f0f0f0f0f0f0f\n\tx *= 0x0101010101010101\n\treturn x >> 56\n}\n"
        },
        {
          "name": "popcnt_generic.go",
          "type": "blob",
          "size": 0.45703125,
          "content": "//go:build !amd64 || appengine || go1.9\n// +build !amd64 appengine go1.9\n\npackage roaring\n\nfunc popcntSlice(s []uint64) uint64 {\n\treturn popcntSliceGo(s)\n}\n\nfunc popcntMaskSlice(s, m []uint64) uint64 {\n\treturn popcntMaskSliceGo(s, m)\n}\n\nfunc popcntAndSlice(s, m []uint64) uint64 {\n\treturn popcntAndSliceGo(s, m)\n}\n\nfunc popcntOrSlice(s, m []uint64) uint64 {\n\treturn popcntOrSliceGo(s, m)\n}\n\nfunc popcntXorSlice(s, m []uint64) uint64 {\n\treturn popcntXorSliceGo(s, m)\n}\n"
        },
        {
          "name": "popcnt_slices.go",
          "type": "blob",
          "size": 0.6533203125,
          "content": "package roaring\n\nfunc popcntSliceGo(s []uint64) uint64 {\n\tcnt := uint64(0)\n\tfor _, x := range s {\n\t\tcnt += popcount(x)\n\t}\n\treturn cnt\n}\n\nfunc popcntMaskSliceGo(s, m []uint64) uint64 {\n\tcnt := uint64(0)\n\tfor i := range s {\n\t\tcnt += popcount(s[i] &^ m[i])\n\t}\n\treturn cnt\n}\n\nfunc popcntAndSliceGo(s, m []uint64) uint64 {\n\tcnt := uint64(0)\n\tfor i := range s {\n\t\tcnt += popcount(s[i] & m[i])\n\t}\n\treturn cnt\n}\n\nfunc popcntOrSliceGo(s, m []uint64) uint64 {\n\tcnt := uint64(0)\n\tfor i := range s {\n\t\tcnt += popcount(s[i] | m[i])\n\t}\n\treturn cnt\n}\n\nfunc popcntXorSliceGo(s, m []uint64) uint64 {\n\tcnt := uint64(0)\n\tfor i := range s {\n\t\tcnt += popcount(s[i] ^ m[i])\n\t}\n\treturn cnt\n}\n"
        },
        {
          "name": "popcnt_slices_test.go",
          "type": "blob",
          "size": 1.6201171875,
          "content": "//go:build amd64 && !appengine && !go1.9\n// +build amd64,!appengine,!go1.9\n\n// This file tests the popcnt functions\n\npackage roaring\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestPopcntSlice(t *testing.T) {\n\ts := []uint64{2, 3, 5, 7, 11, 13, 17, 19, 23, 29}\n\tresGo := popcntSliceGo(s)\n\tresAsm := popcntSliceAsm(s)\n\tres := popcntSlice(s)\n\n\tassert.Equal(t, resGo, resAsm)\n\tassert.Equal(t, resGo, res)\n}\n\nfunc TestPopcntMaskSlice(t *testing.T) {\n\ts := []uint64{2, 3, 5, 7, 11, 13, 17, 19, 23, 29}\n\tm := []uint64{31, 37, 41, 43, 47, 53, 59, 61, 67, 71}\n\tresGo := popcntMaskSliceGo(s, m)\n\tresAsm := popcntMaskSliceAsm(s, m)\n\tres := popcntMaskSlice(s, m)\n\n\tassert.Equal(t, resGo, resAsm)\n\tassert.Equal(t, resGo, res)\n}\n\nfunc TestPopcntAndSlice(t *testing.T) {\n\ts := []uint64{2, 3, 5, 7, 11, 13, 17, 19, 23, 29}\n\tm := []uint64{31, 37, 41, 43, 47, 53, 59, 61, 67, 71}\n\tresGo := popcntAndSliceGo(s, m)\n\tresAsm := popcntAndSliceAsm(s, m)\n\tres := popcntAndSlice(s, m)\n\n\tassert.Equal(t, resGo, resAsm)\n\tassert.Equal(t, resGo, res)\n}\n\nfunc TestPopcntOrSlice(t *testing.T) {\n\ts := []uint64{2, 3, 5, 7, 11, 13, 17, 19, 23, 29}\n\tm := []uint64{31, 37, 41, 43, 47, 53, 59, 61, 67, 71}\n\tresGo := popcntOrSliceGo(s, m)\n\tresAsm := popcntOrSliceAsm(s, m)\n\tres := popcntOrSlice(s, m)\n\n\tassert.Equal(t, resGo, resAsm)\n\tassert.Equal(t, resGo, res)\n}\n\nfunc TestPopcntXorSlice(t *testing.T) {\n\ts := []uint64{2, 3, 5, 7, 11, 13, 17, 19, 23, 29}\n\tm := []uint64{31, 37, 41, 43, 47, 53, 59, 61, 67, 71}\n\tresGo := popcntXorSliceGo(s, m)\n\tresAsm := popcntXorSliceAsm(s, m)\n\tres := popcntXorSlice(s, m)\n\n\tassert.Equal(t, resGo, resAsm)\n\tassert.Equal(t, resGo, res)\n}\n"
        },
        {
          "name": "priorityqueue.go",
          "type": "blob",
          "size": 2.1416015625,
          "content": "package roaring\n\nimport \"container/heap\"\n\n/////////////\n// The priorityQueue is used to keep Bitmaps sorted.\n////////////\n\ntype item struct {\n\tvalue *Bitmap\n\tindex int\n}\n\ntype priorityQueue []*item\n\nfunc (pq priorityQueue) Len() int { return len(pq) }\n\nfunc (pq priorityQueue) Less(i, j int) bool {\n\treturn pq[i].value.GetSizeInBytes() < pq[j].value.GetSizeInBytes()\n}\n\nfunc (pq priorityQueue) Swap(i, j int) {\n\tpq[i], pq[j] = pq[j], pq[i]\n\tpq[i].index = i\n\tpq[j].index = j\n}\n\nfunc (pq *priorityQueue) Push(x interface{}) {\n\tn := len(*pq)\n\titem := x.(*item)\n\titem.index = n\n\t*pq = append(*pq, item)\n}\n\nfunc (pq *priorityQueue) Pop() interface{} {\n\told := *pq\n\tn := len(old)\n\titem := old[n-1]\n\titem.index = -1 // for safety\n\t*pq = old[0 : n-1]\n\treturn item\n}\n\nfunc (pq *priorityQueue) update(item *item, value *Bitmap) {\n\titem.value = value\n\theap.Fix(pq, item.index)\n}\n\n/////////////\n// The containerPriorityQueue is used to keep the containers of various Bitmaps sorted.\n////////////\n\ntype containeritem struct {\n\tvalue    *Bitmap\n\tkeyindex int\n\tindex    int\n}\n\ntype containerPriorityQueue []*containeritem\n\nfunc (pq containerPriorityQueue) Len() int { return len(pq) }\n\nfunc (pq containerPriorityQueue) Less(i, j int) bool {\n\tk1 := pq[i].value.highlowcontainer.getKeyAtIndex(pq[i].keyindex)\n\tk2 := pq[j].value.highlowcontainer.getKeyAtIndex(pq[j].keyindex)\n\tif k1 != k2 {\n\t\treturn k1 < k2\n\t}\n\tc1 := pq[i].value.highlowcontainer.getContainerAtIndex(pq[i].keyindex)\n\tc2 := pq[j].value.highlowcontainer.getContainerAtIndex(pq[j].keyindex)\n\n\treturn c1.getCardinality() > c2.getCardinality()\n}\n\nfunc (pq containerPriorityQueue) Swap(i, j int) {\n\tpq[i], pq[j] = pq[j], pq[i]\n\tpq[i].index = i\n\tpq[j].index = j\n}\n\nfunc (pq *containerPriorityQueue) Push(x interface{}) {\n\tn := len(*pq)\n\titem := x.(*containeritem)\n\titem.index = n\n\t*pq = append(*pq, item)\n}\n\nfunc (pq *containerPriorityQueue) Pop() interface{} {\n\told := *pq\n\tn := len(old)\n\titem := old[n-1]\n\titem.index = -1 // for safety\n\t*pq = old[0 : n-1]\n\treturn item\n}\n\n//func (pq *containerPriorityQueue) update(item *containeritem, value *Bitmap, keyindex int) {\n//\titem.value = value\n//\titem.keyindex = keyindex\n//\theap.Fix(pq, item.index)\n//}\n"
        },
        {
          "name": "real_data_benchmark_test.go",
          "type": "blob",
          "size": 4.59765625,
          "content": "package roaring\n\nimport (\n\t\"archive/zip\"\n\t\"bytes\"\n\t\"fmt\"\n\t\"io\"\n\t\"os\"\n\t\"path\"\n\t\"strconv\"\n\t\"strings\"\n\t\"testing\"\n)\n\n// To run these benchmarks, type BENCH_REAL_DATA=1 go test -bench BenchmarkRealData -run -\n\nvar benchRealData = false\n\nvar realDatasets = []string{\n\t\"census-income_srt\", \"census-income\", \"census1881_srt\", \"census1881\",\n\t\"dimension_003\", \"dimension_008\", \"dimension_033\", \"uscensus2000\", \"weather_sept_85_srt\", \"weather_sept_85\",\n\t\"wikileaks-noquotes_srt\", \"wikileaks-noquotes\",\n}\n\nfunc init() {\n\tif envStr, ok := os.LookupEnv(\"BENCH_REAL_DATA\"); ok {\n\t\tv, err := strconv.ParseBool(envStr)\n\t\tif err != nil {\n\t\t\tv = false\n\t\t}\n\t\tbenchRealData = v\n\t}\n}\n\nfunc retrieveRealDataBitmaps(datasetName string, optimize bool) ([]*Bitmap, error) {\n\tgopath, ok := os.LookupEnv(\"GOPATH\")\n\tif !ok {\n\t\treturn nil, fmt.Errorf(\"GOPATH not set. It's required to locate real-roaring-datasets. Set GOPATH or disable BENCH_REAL_DATA\")\n\t}\n\n\tbasePath := path.Join(gopath, \"src\", \"github.com\", \"RoaringBitmap\", \"real-roaring-datasets\")\n\n\tif _, err := os.Stat(basePath); os.IsNotExist(err) {\n\t\treturn nil, fmt.Errorf(\"real-roaring-datasets does not exist. Run `go get github.com/RoaringBitmap/real-roaring-datasets`\")\n\t}\n\n\tdatasetPath := path.Join(basePath, datasetName+\".zip\")\n\n\tif _, err := os.Stat(datasetPath); os.IsNotExist(err) {\n\t\treturn nil, fmt.Errorf(\"dataset %s does not exist, tried path: %s\", datasetName, datasetPath)\n\t}\n\n\tzipFile, err := zip.OpenReader(datasetPath)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"error opening dataset %s zipfile, cause: %v\", datasetPath, err)\n\t}\n\tdefer zipFile.Close()\n\n\tvar largestFileSize uint64\n\tfor _, f := range zipFile.File {\n\t\tif f.UncompressedSize64 > largestFileSize {\n\t\t\tlargestFileSize = f.UncompressedSize64\n\t\t}\n\t}\n\n\tbitmaps := make([]*Bitmap, len(zipFile.File))\n\tbuf := make([]byte, largestFileSize)\n\tvar bufStep uint64 = 32768 // apparently the largest buffer zip can read\n\tfor i, f := range zipFile.File {\n\t\tr, err := f.Open()\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"failed to read bitmap file %s from dataset %s, cause: %v\", f.Name, datasetName, err)\n\t\t}\n\n\t\tvar totalReadBytes uint64\n\n\t\tfor {\n\t\t\tvar endOffset uint64\n\t\t\tif f.UncompressedSize64 < totalReadBytes+bufStep {\n\t\t\t\tendOffset = f.UncompressedSize64\n\t\t\t} else {\n\t\t\t\tendOffset = totalReadBytes + bufStep\n\t\t\t}\n\n\t\t\treadBytes, err := r.Read(buf[totalReadBytes:endOffset])\n\t\t\ttotalReadBytes += uint64(readBytes)\n\n\t\t\tif err == io.EOF {\n\t\t\t\tr.Close()\n\t\t\t\tbreak\n\t\t\t} else if err != nil {\n\t\t\t\tr.Close()\n\t\t\t\treturn nil, fmt.Errorf(\"could not read content of file %s from dataset %s, cause: %v\", f.Name, datasetName, err)\n\t\t\t}\n\t\t}\n\n\t\telemsAsBytes := bytes.Split(buf[:totalReadBytes], []byte{44}) // 44 is a comma\n\n\t\tb := NewBitmap()\n\t\tfor _, elemBytes := range elemsAsBytes {\n\t\t\telemStr := strings.TrimSpace(string(elemBytes))\n\n\t\t\te, err := strconv.ParseUint(elemStr, 10, 32)\n\t\t\tif err != nil {\n\t\t\t\tr.Close()\n\t\t\t\treturn nil, fmt.Errorf(\"could not parse %s as uint32. Reading %s from %s. Cause: %v\", elemStr, f.Name, datasetName, err)\n\t\t\t}\n\n\t\t\tb.Add(uint32(e))\n\t\t}\n\n\t\tif optimize {\n\t\t\tb.RunOptimize()\n\t\t}\n\n\t\tbitmaps[i] = b\n\t}\n\n\treturn bitmaps, nil\n}\n\nfunc benchmarkRealDataAggregate(b *testing.B, aggregator func(b []*Bitmap) uint64) {\n\tif !benchRealData {\n\t\tb.SkipNow()\n\t}\n\n\tfor _, dataset := range realDatasets {\n\t\tb.Run(dataset, func(b *testing.B) {\n\t\t\tbitmaps, err := retrieveRealDataBitmaps(dataset, true)\n\t\t\tif err != nil {\n\t\t\t\tb.Fatal(err)\n\t\t\t}\n\n\t\t\tb.ResetTimer()\n\t\t\tfor i := 0; i < b.N; i++ {\n\t\t\t\taggregator(bitmaps)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc BenchmarkRealDataNext(b *testing.B) {\n\tbenchmarkRealDataAggregate(b, func(bitmaps []*Bitmap) uint64 {\n\t\ttot := uint64(0)\n\t\tfor _, b := range bitmaps {\n\t\t\tit := b.Iterator()\n\t\t\tfor it.HasNext() {\n\t\t\t\ttot += uint64(it.Next())\n\t\t\t}\n\t\t}\n\t\treturn tot\n\t})\n}\n\nfunc BenchmarkRealDataNextMany(b *testing.B) {\n\tbenchmarkRealDataAggregate(b, func(bitmaps []*Bitmap) uint64 {\n\t\ttot := uint64(0)\n\t\tbuf := make([]uint32, 4096)\n\t\tfor _, b := range bitmaps {\n\t\t\tit := b.ManyIterator()\n\t\t\tfor n := it.NextMany(buf); n != 0; n = it.NextMany(buf) {\n\t\t\t\tfor _, v := range buf[:n] {\n\t\t\t\t\ttot += uint64(v)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn tot\n\t})\n}\n\nfunc BenchmarkRealDataParOr(b *testing.B) {\n\tbenchmarkRealDataAggregate(b, func(bitmaps []*Bitmap) uint64 {\n\t\treturn ParOr(0, bitmaps...).GetCardinality()\n\t\t//return ParHeapOr(0, bitmaps...).GetCardinality()\n\t})\n}\n\nfunc BenchmarkRealDataParHeapOr(b *testing.B) {\n\tbenchmarkRealDataAggregate(b, func(bitmaps []*Bitmap) uint64 {\n\t\treturn ParHeapOr(0, bitmaps...).GetCardinality()\n\t})\n}\n\nfunc BenchmarkRealDataFastOr(b *testing.B) {\n\tbenchmarkRealDataAggregate(b, func(bitmaps []*Bitmap) uint64 {\n\t\treturn FastOr(bitmaps...).GetCardinality()\n\t})\n}\n"
        },
        {
          "name": "roaring.go",
          "type": "blob",
          "size": 64.4599609375,
          "content": "// Package roaring is an implementation of Roaring Bitmaps in Go.\n// They provide fast compressed bitmap data structures (also called bitset).\n// They are ideally suited to represent sets of integers over\n// relatively small ranges.\n// See http://roaringbitmap.org for details.\npackage roaring\n\nimport (\n\t\"bytes\"\n\t\"encoding/base64\"\n\t\"fmt\"\n\t\"io\"\n\t\"strconv\"\n\n\t\"github.com/RoaringBitmap/roaring/v2/internal\"\n\t\"github.com/bits-and-blooms/bitset\"\n)\n\n// Bitmap represents a compressed bitmap where you can add integers.\ntype Bitmap struct {\n\thighlowcontainer roaringArray\n}\n\n// ToBase64 serializes a bitmap as Base64\nfunc (rb *Bitmap) ToBase64() (string, error) {\n\tbuf := new(bytes.Buffer)\n\t_, err := rb.WriteTo(buf)\n\treturn base64.StdEncoding.EncodeToString(buf.Bytes()), err\n}\n\n// FromBase64 deserializes a bitmap from Base64\nfunc (rb *Bitmap) FromBase64(str string) (int64, error) {\n\tdata, err := base64.StdEncoding.DecodeString(str)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\tbuf := bytes.NewBuffer(data)\n\n\treturn rb.ReadFrom(buf)\n}\n\n// WriteTo writes a serialized version of this bitmap to stream.\n// The format is compatible with other RoaringBitmap\n// implementations (Java, C) and is documented here:\n// https://github.com/RoaringBitmap/RoaringFormatSpec\nfunc (rb *Bitmap) WriteTo(stream io.Writer) (int64, error) {\n\treturn rb.highlowcontainer.writeTo(stream)\n}\n\n// ToBytes returns an array of bytes corresponding to what is written\n// when calling WriteTo\nfunc (rb *Bitmap) ToBytes() ([]byte, error) {\n\treturn rb.highlowcontainer.toBytes()\n}\n\nconst (\n\twordSize            = uint64(64)\n\tlog2WordSize        = uint64(6)\n\tcapacity            = ^uint64(0)\n\tbitmapContainerSize = (1 << 16) / 64 // bitmap size in words\n)\n\n// DenseSize returns the size of the bitmap when stored as a dense bitmap.\nfunc (rb *Bitmap) DenseSize() uint64 {\n\tif rb.highlowcontainer.size() == 0 {\n\t\treturn 0\n\t}\n\n\tmaximum := 1 + uint64(rb.Maximum())\n\tif maximum > (capacity - wordSize + 1) {\n\t\treturn uint64(capacity >> log2WordSize)\n\t}\n\n\treturn uint64((maximum + (wordSize - 1)) >> log2WordSize)\n}\n\n// ToDense returns a slice of uint64s representing the bitmap as a dense bitmap.\n// Useful to convert a roaring bitmap to a format that can be used by other libraries\n// like https://github.com/bits-and-blooms/bitset or https://github.com/kelindar/bitmap\nfunc (rb *Bitmap) ToDense() []uint64 {\n\tsz := rb.DenseSize()\n\tif sz == 0 {\n\t\treturn nil\n\t}\n\n\tbitmap := make([]uint64, sz)\n\trb.WriteDenseTo(bitmap)\n\treturn bitmap\n}\n\n// FromDense creates a bitmap from a slice of uint64s representing the bitmap as a dense bitmap.\n// Useful to convert bitmaps from libraries like https://github.com/bits-and-blooms/bitset or\n// https://github.com/kelindar/bitmap into roaring bitmaps fast and with convenience.\n//\n// This function will not create any run containers, only array and bitmap containers. It's up to\n// the caller to call RunOptimize if they want to further compress the runs of consecutive values.\n//\n// When doCopy is true, the bitmap is copied into a new slice for each bitmap container.\n// This is useful when the bitmap is going to be modified after this function returns or if it's\n// undesirable to hold references to large bitmaps which the GC would not be able to collect.\n// One copy can still happen even when doCopy is false if the bitmap length is not divisible\n// by bitmapContainerSize.\n//\n// See also FromBitSet.\nfunc FromDense(bitmap []uint64, doCopy bool) *Bitmap {\n\tsz := (len(bitmap) + bitmapContainerSize - 1) / bitmapContainerSize // round up\n\trb := &Bitmap{\n\t\thighlowcontainer: roaringArray{\n\t\t\tcontainers:      make([]container, 0, sz),\n\t\t\tkeys:            make([]uint16, 0, sz),\n\t\t\tneedCopyOnWrite: make([]bool, 0, sz),\n\t\t},\n\t}\n\trb.FromDense(bitmap, doCopy)\n\treturn rb\n}\n\n// FromDense unmarshalls from a slice of uint64s representing the bitmap as a dense bitmap.\n// Useful to convert bitmaps from libraries like https://github.com/bits-and-blooms/bitset or\n// https://github.com/kelindar/bitmap into roaring bitmaps fast and with convenience.\n// Callers are responsible for ensuring that the bitmap is empty before calling this function.\n//\n// This function will not create any run containers, only array and bitmap containers. It is up to\n// the caller to call RunOptimize if they want to further compress the runs of consecutive values.\n//\n// When doCopy is true, the bitmap is copied into a new slice for each bitmap container.\n// This is useful when the bitmap is going to be modified after this function returns or if it's\n// undesirable to hold references to large bitmaps which the GC would not be able to collect.\n// One copy can still happen even when doCopy is false if the bitmap length is not divisible\n// by bitmapContainerSize.\n//\n// See FromBitSet.\nfunc (rb *Bitmap) FromDense(bitmap []uint64, doCopy bool) {\n\tif len(bitmap) == 0 {\n\t\treturn\n\t}\n\n\tvar k uint16\n\tconst size = bitmapContainerSize\n\n\tfor len(bitmap) > 0 {\n\t\thi := size\n\t\tif len(bitmap) < size {\n\t\t\thi = len(bitmap)\n\t\t}\n\n\t\twords := bitmap[:hi]\n\t\tcount := int(popcntSlice(words))\n\n\t\tswitch {\n\t\tcase count > arrayDefaultMaxSize:\n\t\t\tc := &bitmapContainer{cardinality: count, bitmap: words}\n\t\t\tcow := true\n\n\t\t\tif doCopy || len(words) < size {\n\t\t\t\tc.bitmap = make([]uint64, size)\n\t\t\t\tcopy(c.bitmap, words)\n\t\t\t\tcow = false\n\t\t\t}\n\n\t\t\trb.highlowcontainer.appendContainer(k, c, cow)\n\n\t\tcase count > 0:\n\t\t\tc := &arrayContainer{content: make([]uint16, count)}\n\t\t\tvar pos, base int\n\t\t\tfor _, w := range words {\n\t\t\t\tfor w != 0 {\n\t\t\t\t\tt := w & -w\n\t\t\t\t\tc.content[pos] = uint16(base + int(popcount(t-1)))\n\t\t\t\t\tpos++\n\t\t\t\t\tw ^= t\n\t\t\t\t}\n\t\t\t\tbase += 64\n\t\t\t}\n\t\t\trb.highlowcontainer.appendContainer(k, c, false)\n\t\t}\n\n\t\tbitmap = bitmap[hi:]\n\t\tk++\n\t}\n}\n\n// WriteDenseTo writes to a slice of uint64s representing the bitmap as a dense bitmap.\n// Callers are responsible for allocating enough space in the bitmap using DenseSize.\n// Useful to convert a roaring bitmap to a format that can be used by other libraries\n// like https://github.com/bits-and-blooms/bitset or https://github.com/kelindar/bitmap\nfunc (rb *Bitmap) WriteDenseTo(bitmap []uint64) {\n\tfor i, ct := range rb.highlowcontainer.containers {\n\t\thb := uint32(rb.highlowcontainer.keys[i]) << 16\n\n\t\tswitch c := ct.(type) {\n\t\tcase *arrayContainer:\n\t\t\tfor _, x := range c.content {\n\t\t\t\tn := int(hb | uint32(x))\n\t\t\t\tbitmap[n>>log2WordSize] |= uint64(1) << uint(x%64)\n\t\t\t}\n\n\t\tcase *bitmapContainer:\n\t\t\tcopy(bitmap[int(hb)>>log2WordSize:], c.bitmap)\n\n\t\tcase *runContainer16:\n\t\t\tfor j := range c.iv {\n\t\t\t\tstart := uint32(c.iv[j].start)\n\t\t\t\tend := start + uint32(c.iv[j].length) + 1\n\t\t\t\tlo := int(hb|start) >> log2WordSize\n\t\t\t\thi := int(hb|(end-1)) >> log2WordSize\n\n\t\t\t\tif lo == hi {\n\t\t\t\t\tbitmap[lo] |= (^uint64(0) << uint(start%64)) &\n\t\t\t\t\t\t(^uint64(0) >> (uint(-end) % 64))\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\n\t\t\t\tbitmap[lo] |= ^uint64(0) << uint(start%64)\n\t\t\t\tfor n := lo + 1; n < hi; n++ {\n\t\t\t\t\tbitmap[n] = ^uint64(0)\n\t\t\t\t}\n\t\t\t\tbitmap[hi] |= ^uint64(0) >> (uint(-end) % 64)\n\t\t\t}\n\t\tdefault:\n\t\t\tpanic(\"unsupported container type\")\n\t\t}\n\t}\n}\n\n// Checksum computes a hash (currently FNV-1a) for a bitmap that is suitable for\n// using bitmaps as elements in hash sets or as keys in hash maps, as well as\n// generally quicker comparisons.\n// The implementation is biased towards efficiency in little endian machines, so\n// expect some extra CPU cycles and memory to be used if your machine is big endian.\n// Likewise, do not use this to verify integrity unless you are certain you will load\n// the bitmap on a machine with the same endianess used to create it. (Thankfully\n// very few people use big endian machines these days.)\nfunc (rb *Bitmap) Checksum() uint64 {\n\tconst (\n\t\toffset = 14695981039346656037\n\t\tprime  = 1099511628211\n\t)\n\n\tvar bytes []byte\n\n\thash := uint64(offset)\n\n\tbytes = uint16SliceAsByteSlice(rb.highlowcontainer.keys)\n\n\tfor _, b := range bytes {\n\t\thash ^= uint64(b)\n\t\thash *= prime\n\t}\n\n\tfor _, c := range rb.highlowcontainer.containers {\n\t\t// 0 separator\n\t\thash ^= 0\n\t\thash *= prime\n\n\t\tswitch c := c.(type) {\n\t\tcase *bitmapContainer:\n\t\t\tbytes = uint64SliceAsByteSlice(c.bitmap)\n\t\tcase *arrayContainer:\n\t\t\tbytes = uint16SliceAsByteSlice(c.content)\n\t\tcase *runContainer16:\n\t\t\tbytes = interval16SliceAsByteSlice(c.iv)\n\t\tdefault:\n\t\t\tpanic(\"invalid container type\")\n\t\t}\n\n\t\tif len(bytes) == 0 {\n\t\t\tpanic(\"empty containers are not supported\")\n\t\t}\n\n\t\tfor _, b := range bytes {\n\t\t\thash ^= uint64(b)\n\t\t\thash *= prime\n\t\t}\n\t}\n\n\treturn hash\n}\n\n// FromUnsafeBytes reads a serialized version of this bitmap from the byte buffer without copy\n// (for advanced users only, you must be an expert Go programmer!).\n// E.g., you can use this method to read a serialized bitmap from a memory-mapped file written out\n// with the WriteTo method.\n// The format specification is\n// https://github.com/RoaringBitmap/RoaringFormatSpec\n// It is the caller's responsibility to ensure that the input data is not modified and remains valid for the entire lifetime of this bitmap.\n// This method avoids small allocations but holds references to the input data buffer. It is GC-friendly, but it may consume more memory eventually.\n// The containers in the resulting bitmap are immutable containers tied to the provided byte array and they rely on\n// copy-on-write which means that modifying them creates copies. Thus FromUnsafeBytes is more likely to be appropriate for read-only use cases,\n// when the resulting bitmap can be considered immutable.\n//\n// See also the FromBuffer function. We recommend benchmarking both functions to determine which one is more suitable for your use case.\n// See https://github.com/RoaringBitmap/roaring/pull/395 for more details.\nfunc (rb *Bitmap) FromUnsafeBytes(data []byte, cookieHeader ...byte) (p int64, err error) {\n\tstream := internal.NewByteBuffer(data)\n\treturn rb.ReadFrom(stream)\n}\n\n// ReadFrom reads a serialized version of this bitmap from stream.\n// E.g., you can use this method to read a serialized bitmap from a file written\n// with the WriteTo method.\n// The format is compatible with other RoaringBitmap\n// implementations (Java, C) and is documented here:\n// https://github.com/RoaringBitmap/RoaringFormatSpec\n// Since io.Reader is regarded as a stream and cannot be read twice,\n// we add cookieHeader to accept the 4-byte data that has been read in roaring64.ReadFrom.\n// It is not necessary to pass cookieHeader when call roaring.ReadFrom to read the roaring32 data directly.\nfunc (rb *Bitmap) ReadFrom(reader io.Reader, cookieHeader ...byte) (p int64, err error) {\n\tstream, ok := reader.(internal.ByteInput)\n\tif !ok {\n\t\tbyteInputAdapter := internal.ByteInputAdapterPool.Get().(*internal.ByteInputAdapter)\n\t\tbyteInputAdapter.Reset(reader)\n\t\tstream = byteInputAdapter\n\t}\n\n\tp, err = rb.highlowcontainer.readFrom(stream, cookieHeader...)\n\n\tif !ok {\n\t\tinternal.ByteInputAdapterPool.Put(stream.(*internal.ByteInputAdapter))\n\t}\n\treturn\n}\n\n// MustReadFrom calls ReadFrom internally.\n// After deserialization Validate will be called.\n// If the Bitmap fails to validate, a panic with the validation error will be thrown\nfunc (rb *Bitmap) MustReadFrom(reader io.Reader, cookieHeader ...byte) (p int64, err error) {\n\trb.ReadFrom(reader, cookieHeader...)\n\tif err := rb.Validate(); err != nil {\n\t\tpanic(err)\n\t}\n\treturn\n}\n\n// FromBuffer creates a bitmap from its serialized version stored in buffer (E.g., as written by WriteTo).\n//\n// The format specification is available here:\n// https://github.com/RoaringBitmap/RoaringFormatSpec\n//\n// The provided byte array (buf) is expected to be a constant.\n// The function makes the best effort attempt not to copy data.\n// You should take care not to modify buff as it will\n// likely result in unexpected program behavior.\n//\n// Resulting bitmaps are effectively immutable in the following sense:\n// a copy-on-write marker is used so that when you modify the resulting\n// bitmap, copies of selected data (containers) are made.\n// You should *not* change the copy-on-write status of the resulting\n// bitmaps (SetCopyOnWrite).\n//\n// Thus FromBuffer is more likely to be appropriate for read-only use cases,\n// when the resulting bitmap can be considered immutable.\n//\n// If buf becomes unavailable, then a bitmap created with\n// FromBuffer would be effectively broken. Furthermore, any\n// bitmap derived from this bitmap (e.g., via Or, And) might\n// also be broken. Thus, before making buf unavailable, you should\n// call CloneCopyOnWriteContainers on all such bitmaps.\n//\n// See also the FromUnsafeBytes function which can have better performance\n// in some cases.\nfunc (rb *Bitmap) FromBuffer(buf []byte) (p int64, err error) {\n\tstream := internal.ByteBufferPool.Get().(*internal.ByteBuffer)\n\tstream.Reset(buf)\n\n\tp, err = rb.highlowcontainer.readFrom(stream)\n\tinternal.ByteBufferPool.Put(stream)\n\n\treturn\n}\n\n// RunOptimize attempts to further compress the runs of consecutive values found in the bitmap\nfunc (rb *Bitmap) RunOptimize() {\n\trb.highlowcontainer.runOptimize()\n}\n\n// HasRunCompression returns true if the bitmap benefits from run compression\nfunc (rb *Bitmap) HasRunCompression() bool {\n\treturn rb.highlowcontainer.hasRunCompression()\n}\n\n// MarshalBinary implements the encoding.BinaryMarshaler interface for the bitmap\n// (same as ToBytes)\nfunc (rb *Bitmap) MarshalBinary() ([]byte, error) {\n\treturn rb.ToBytes()\n}\n\n// UnmarshalBinary implements the encoding.BinaryUnmarshaler interface for the bitmap\nfunc (rb *Bitmap) UnmarshalBinary(data []byte) error {\n\tr := bytes.NewReader(data)\n\t_, err := rb.ReadFrom(r)\n\treturn err\n}\n\n// NewBitmap creates a new empty Bitmap (see also New)\nfunc NewBitmap() *Bitmap {\n\treturn &Bitmap{}\n}\n\n// New creates a new empty Bitmap (same as NewBitmap)\nfunc New() *Bitmap {\n\treturn &Bitmap{}\n}\n\n// Clear resets the Bitmap to be logically empty, but may retain\n// some memory allocations that may speed up future operations\nfunc (rb *Bitmap) Clear() {\n\trb.highlowcontainer.clear()\n}\n\n// ToBitSet copies the content of the RoaringBitmap into a bitset.BitSet instance\nfunc (rb *Bitmap) ToBitSet() *bitset.BitSet {\n\treturn bitset.From(rb.ToDense())\n}\n\n// FromBitSet creates a new RoaringBitmap from a bitset.BitSet instance\nfunc FromBitSet(bitset *bitset.BitSet) *Bitmap {\n\treturn FromDense(bitset.Bytes(), false)\n}\n\n// ToArray creates a new slice containing all of the integers stored in the Bitmap in sorted order\nfunc (rb *Bitmap) ToArray() []uint32 {\n\tarray := make([]uint32, rb.GetCardinality())\n\tpos := 0\n\tpos2 := 0\n\n\tfor pos < rb.highlowcontainer.size() {\n\t\ths := uint32(rb.highlowcontainer.getKeyAtIndex(pos)) << 16\n\t\tc := rb.highlowcontainer.getContainerAtIndex(pos)\n\t\tpos++\n\t\tpos2 = c.fillLeastSignificant16bits(array, pos2, hs)\n\t}\n\treturn array\n}\n\n// GetSizeInBytes estimates the memory usage of the Bitmap. Note that this\n// might differ slightly from the amount of bytes required for persistent storage\nfunc (rb *Bitmap) GetSizeInBytes() uint64 {\n\tsize := uint64(8)\n\tfor _, c := range rb.highlowcontainer.containers {\n\t\tsize += uint64(2) + uint64(c.getSizeInBytes())\n\t}\n\treturn size\n}\n\n// GetSerializedSizeInBytes computes the serialized size in bytes\n// of the Bitmap. It should correspond to the\n// number of bytes written when invoking WriteTo. You can expect\n// that this function is much cheaper computationally than WriteTo.\nfunc (rb *Bitmap) GetSerializedSizeInBytes() uint64 {\n\treturn rb.highlowcontainer.serializedSizeInBytes()\n}\n\n// BoundSerializedSizeInBytes returns an upper bound on the serialized size in bytes\n// assuming that one wants to store \"cardinality\" integers in [0, universe_size)\nfunc BoundSerializedSizeInBytes(cardinality uint64, universeSize uint64) uint64 {\n\tcontnbr := (universeSize + uint64(65535)) / uint64(65536)\n\tif contnbr > cardinality {\n\t\tcontnbr = cardinality\n\t\t// we cannot have more containers than we have values\n\t}\n\theadermax := 8*contnbr + 4\n\tif 4 > (contnbr+7)/8 {\n\t\theadermax += 4\n\t} else {\n\t\theadermax += (contnbr + 7) / 8\n\t}\n\tvalsarray := uint64(arrayContainerSizeInBytes(int(cardinality)))\n\tvalsbitmap := contnbr * uint64(bitmapContainerSizeInBytes())\n\tvalsbest := valsarray\n\tif valsbest > valsbitmap {\n\t\tvalsbest = valsbitmap\n\t}\n\treturn valsbest + headermax\n}\n\n// IntIterable allows you to iterate over the values in a Bitmap\ntype IntIterable interface {\n\tHasNext() bool\n\tNext() uint32\n}\n\n// IntPeekable allows you to look at the next value without advancing and\n// advance as long as the next value is smaller than minval\ntype IntPeekable interface {\n\tIntIterable\n\t// PeekNext peeks the next value without advancing the iterator\n\tPeekNext() uint32\n\t// AdvanceIfNeeded advances as long as the next value is smaller than minval\n\tAdvanceIfNeeded(minval uint32)\n}\n\ntype intIterator struct {\n\tpos              int\n\ths               uint32\n\titer             shortPeekable\n\thighlowcontainer *roaringArray\n\n\t// These embedded iterators per container type help reduce load in the GC.\n\t// This way, instead of making up-to 64k allocations per full iteration\n\t// we get a single allocation and simply reinitialize the appropriate\n\t// iterator and point to it in the generic `iter` member on each key bound.\n\tshortIter  shortIterator\n\trunIter    runIterator16\n\tbitmapIter bitmapContainerShortIterator\n}\n\n// HasNext returns true if there are more integers to iterate over\nfunc (ii *intIterator) HasNext() bool {\n\treturn ii.pos < ii.highlowcontainer.size()\n}\n\nfunc (ii *intIterator) init() {\n\tif ii.highlowcontainer.size() > ii.pos {\n\t\tii.hs = uint32(ii.highlowcontainer.getKeyAtIndex(ii.pos)) << 16\n\t\tc := ii.highlowcontainer.getContainerAtIndex(ii.pos)\n\t\tswitch t := c.(type) {\n\t\tcase *arrayContainer:\n\t\t\tii.shortIter = shortIterator{t.content, 0}\n\t\t\tii.iter = &ii.shortIter\n\t\tcase *runContainer16:\n\t\t\tii.runIter = runIterator16{rc: t, curIndex: 0, curPosInIndex: 0}\n\t\t\tii.iter = &ii.runIter\n\t\tcase *bitmapContainer:\n\t\t\tii.bitmapIter = bitmapContainerShortIterator{t, t.NextSetBit(0)}\n\t\t\tii.iter = &ii.bitmapIter\n\t\t}\n\t}\n}\n\n// Next returns the next integer\nfunc (ii *intIterator) Next() uint32 {\n\tx := uint32(ii.iter.next()) | ii.hs\n\tif !ii.iter.hasNext() {\n\t\tii.pos = ii.pos + 1\n\t\tii.init()\n\t}\n\treturn x\n}\n\n// PeekNext peeks the next value without advancing the iterator\nfunc (ii *intIterator) PeekNext() uint32 {\n\treturn uint32(ii.iter.peekNext()&maxLowBit) | ii.hs\n}\n\n// AdvanceIfNeeded advances as long as the next value is smaller than minval\nfunc (ii *intIterator) AdvanceIfNeeded(minval uint32) {\n\tto := minval & 0xffff0000\n\n\tfor ii.HasNext() && ii.hs < to {\n\t\tii.pos++\n\t\tii.init()\n\t}\n\n\tif ii.HasNext() && ii.hs == to {\n\t\tii.iter.advanceIfNeeded(lowbits(minval))\n\n\t\tif !ii.iter.hasNext() {\n\t\t\tii.pos++\n\t\t\tii.init()\n\t\t}\n\t}\n}\n\n// IntIterator is meant to allow you to iterate through the values of a bitmap, see Initialize(a *Bitmap)\ntype IntIterator = intIterator\n\n// Initialize configures the existing iterator so that it can iterate through the values of\n// the provided bitmap.\n// The iteration results are undefined if the bitmap is modified (e.g., with Add or Remove).\nfunc (ii *intIterator) Initialize(a *Bitmap) {\n\tii.pos = 0\n\tii.highlowcontainer = &a.highlowcontainer\n\tii.init()\n}\n\ntype intReverseIterator struct {\n\tpos              int\n\ths               uint32\n\titer             shortIterable\n\thighlowcontainer *roaringArray\n\n\tshortIter  reverseIterator\n\trunIter    runReverseIterator16\n\tbitmapIter reverseBitmapContainerShortIterator\n}\n\n// HasNext returns true if there are more integers to iterate over\nfunc (ii *intReverseIterator) HasNext() bool {\n\treturn ii.pos >= 0\n}\n\nfunc (ii *intReverseIterator) init() {\n\tif ii.pos >= 0 {\n\t\tii.hs = uint32(ii.highlowcontainer.getKeyAtIndex(ii.pos)) << 16\n\t\tc := ii.highlowcontainer.getContainerAtIndex(ii.pos)\n\t\tswitch t := c.(type) {\n\t\tcase *arrayContainer:\n\t\t\tii.shortIter = reverseIterator{t.content, len(t.content) - 1}\n\t\t\tii.iter = &ii.shortIter\n\t\tcase *runContainer16:\n\t\t\tindex := int(len(t.iv)) - 1\n\t\t\tpos := uint16(0)\n\n\t\t\tif index >= 0 {\n\t\t\t\tpos = t.iv[index].length\n\t\t\t}\n\n\t\t\tii.runIter = runReverseIterator16{rc: t, curIndex: index, curPosInIndex: pos}\n\t\t\tii.iter = &ii.runIter\n\t\tcase *bitmapContainer:\n\t\t\tpos := -1\n\t\t\tif t.cardinality > 0 {\n\t\t\t\tpos = int(t.maximum())\n\t\t\t}\n\t\t\tii.bitmapIter = reverseBitmapContainerShortIterator{t, pos}\n\t\t\tii.iter = &ii.bitmapIter\n\t\t}\n\t} else {\n\t\tii.iter = nil\n\t}\n}\n\n// Next returns the next integer\nfunc (ii *intReverseIterator) Next() uint32 {\n\tx := uint32(ii.iter.next()) | ii.hs\n\tif !ii.iter.hasNext() {\n\t\tii.pos = ii.pos - 1\n\t\tii.init()\n\t}\n\treturn x\n}\n\n// IntReverseIterator is meant to allow you to iterate through the values of a bitmap, see Initialize(a *Bitmap)\ntype IntReverseIterator = intReverseIterator\n\n// Initialize configures the existing iterator so that it can iterate through the values of\n// the provided bitmap.\n// The iteration results are undefined if the bitmap is modified (e.g., with Add or Remove).\nfunc (ii *intReverseIterator) Initialize(a *Bitmap) {\n\tii.highlowcontainer = &a.highlowcontainer\n\tii.pos = a.highlowcontainer.size() - 1\n\tii.init()\n}\n\n// ManyIntIterable allows you to iterate over the values in a Bitmap\ntype ManyIntIterable interface {\n\t// NextMany fills buf up with values, returns how many values were returned\n\tNextMany(buf []uint32) int\n\t// NextMany64 fills up buf with 64 bit values, uses hs as a mask (OR), returns how many values were returned\n\tNextMany64(hs uint64, buf []uint64) int\n}\n\ntype manyIntIterator struct {\n\tpos              int\n\ths               uint32\n\titer             manyIterable\n\thighlowcontainer *roaringArray\n\n\tshortIter  shortIterator\n\trunIter    runIterator16\n\tbitmapIter bitmapContainerManyIterator\n}\n\nfunc (ii *manyIntIterator) init() {\n\tif ii.highlowcontainer.size() > ii.pos {\n\t\tii.hs = uint32(ii.highlowcontainer.getKeyAtIndex(ii.pos)) << 16\n\t\tc := ii.highlowcontainer.getContainerAtIndex(ii.pos)\n\t\tswitch t := c.(type) {\n\t\tcase *arrayContainer:\n\t\t\tii.shortIter = shortIterator{t.content, 0}\n\t\t\tii.iter = &ii.shortIter\n\t\tcase *runContainer16:\n\t\t\tii.runIter = runIterator16{rc: t, curIndex: 0, curPosInIndex: 0}\n\t\t\tii.iter = &ii.runIter\n\t\tcase *bitmapContainer:\n\t\t\tii.bitmapIter = bitmapContainerManyIterator{t, -1, 0}\n\t\t\tii.iter = &ii.bitmapIter\n\t\t}\n\t} else {\n\t\tii.iter = nil\n\t}\n}\n\nfunc (ii *manyIntIterator) NextMany(buf []uint32) int {\n\tn := 0\n\tfor n < len(buf) {\n\t\tif ii.iter == nil {\n\t\t\tbreak\n\t\t}\n\t\tmoreN := ii.iter.nextMany(ii.hs, buf[n:])\n\t\tn += moreN\n\t\tif moreN == 0 {\n\t\t\tii.pos = ii.pos + 1\n\t\t\tii.init()\n\t\t}\n\t}\n\n\treturn n\n}\n\nfunc (ii *manyIntIterator) NextMany64(hs64 uint64, buf []uint64) int {\n\tn := 0\n\tfor n < len(buf) {\n\t\tif ii.iter == nil {\n\t\t\tbreak\n\t\t}\n\n\t\ths := uint64(ii.hs) | hs64\n\t\tmoreN := ii.iter.nextMany64(hs, buf[n:])\n\t\tn += moreN\n\t\tif moreN == 0 {\n\t\t\tii.pos = ii.pos + 1\n\t\t\tii.init()\n\t\t}\n\t}\n\n\treturn n\n}\n\n// ManyIntIterator is meant to allow you to iterate through the values of a bitmap, see Initialize(a *Bitmap)\ntype ManyIntIterator = manyIntIterator\n\n// Initialize configures the existing iterator so that it can iterate through the values of\n// the provided bitmap.\n// The iteration results are undefined if the bitmap is modified (e.g., with Add or Remove).\nfunc (ii *manyIntIterator) Initialize(a *Bitmap) {\n\tii.pos = 0\n\tii.highlowcontainer = &a.highlowcontainer\n\tii.init()\n}\n\n// String creates a string representation of the Bitmap\nfunc (rb *Bitmap) String() string {\n\t// inspired by https://github.com/fzandona/goroar/\n\tvar buffer bytes.Buffer\n\tstart := []byte(\"{\")\n\tbuffer.Write(start)\n\ti := rb.Iterator()\n\tcounter := 0\n\tif i.HasNext() {\n\t\tcounter = counter + 1\n\t\tbuffer.WriteString(strconv.FormatInt(int64(i.Next()), 10))\n\t}\n\tfor i.HasNext() {\n\t\tbuffer.WriteString(\",\")\n\t\tcounter = counter + 1\n\t\t// to avoid exhausting the memory\n\t\tif counter > 0x40000 {\n\t\t\tbuffer.WriteString(\"...\")\n\t\t\tbreak\n\t\t}\n\t\tbuffer.WriteString(strconv.FormatInt(int64(i.Next()), 10))\n\t}\n\tbuffer.WriteString(\"}\")\n\treturn buffer.String()\n}\n\n// Iterate iterates over the bitmap, calling the given callback with each value in the bitmap.  If the callback returns\n// false, the iteration is halted.\n// The iteration results are undefined if the bitmap is modified (e.g., with Add or Remove).\n// There is no guarantee as to what order the values will be iterated.\nfunc (rb *Bitmap) Iterate(cb func(x uint32) bool) {\n\tfor i := 0; i < rb.highlowcontainer.size(); i++ {\n\t\ths := uint32(rb.highlowcontainer.getKeyAtIndex(i)) << 16\n\t\tc := rb.highlowcontainer.getContainerAtIndex(i)\n\n\t\tvar shouldContinue bool\n\t\t// This is hacky but it avoids allocations from invoking an interface method with a closure\n\t\tswitch t := c.(type) {\n\t\tcase *arrayContainer:\n\t\t\tshouldContinue = t.iterate(func(x uint16) bool {\n\t\t\t\treturn cb(uint32(x) | hs)\n\t\t\t})\n\t\tcase *runContainer16:\n\t\t\tshouldContinue = t.iterate(func(x uint16) bool {\n\t\t\t\treturn cb(uint32(x) | hs)\n\t\t\t})\n\t\tcase *bitmapContainer:\n\t\t\tshouldContinue = t.iterate(func(x uint16) bool {\n\t\t\t\treturn cb(uint32(x) | hs)\n\t\t\t})\n\t\t}\n\n\t\tif !shouldContinue {\n\t\t\tbreak\n\t\t}\n\t}\n}\n\n// Iterator creates a new IntPeekable to iterate over the integers contained in the bitmap, in sorted order;\n// the iterator becomes invalid if the bitmap is modified (e.g., with Add or Remove).\nfunc (rb *Bitmap) Iterator() IntPeekable {\n\tp := new(intIterator)\n\tp.Initialize(rb)\n\treturn p\n}\n\n// ReverseIterator creates a new IntIterable to iterate over the integers contained in the bitmap, in sorted order;\n// the iterator becomes invalid if the bitmap is modified (e.g., with Add or Remove).\nfunc (rb *Bitmap) ReverseIterator() IntIterable {\n\tp := new(intReverseIterator)\n\tp.Initialize(rb)\n\treturn p\n}\n\n// ManyIterator creates a new ManyIntIterable to iterate over the integers contained in the bitmap, in sorted order;\n// the iterator becomes invalid if the bitmap is modified (e.g., with Add or Remove).\nfunc (rb *Bitmap) ManyIterator() ManyIntIterable {\n\tp := new(manyIntIterator)\n\tp.Initialize(rb)\n\treturn p\n}\n\n// Clone creates a copy of the Bitmap\nfunc (rb *Bitmap) Clone() *Bitmap {\n\tptr := new(Bitmap)\n\tptr.highlowcontainer = *rb.highlowcontainer.clone()\n\treturn ptr\n}\n\n// Minimum get the smallest value stored in this roaring bitmap, assumes that it is not empty\nfunc (rb *Bitmap) Minimum() uint32 {\n\tif len(rb.highlowcontainer.containers) == 0 {\n\t\tpanic(\"Empty bitmap\")\n\t}\n\treturn uint32(rb.highlowcontainer.containers[0].minimum()) | (uint32(rb.highlowcontainer.keys[0]) << 16)\n}\n\n// Maximum get the largest value stored in this roaring bitmap, assumes that it is not empty\nfunc (rb *Bitmap) Maximum() uint32 {\n\tif len(rb.highlowcontainer.containers) == 0 {\n\t\tpanic(\"Empty bitmap\")\n\t}\n\tlastindex := len(rb.highlowcontainer.containers) - 1\n\treturn uint32(rb.highlowcontainer.containers[lastindex].maximum()) | (uint32(rb.highlowcontainer.keys[lastindex]) << 16)\n}\n\n// Contains returns true if the integer is contained in the bitmap\nfunc (rb *Bitmap) Contains(x uint32) bool {\n\thb := highbits(x)\n\tc := rb.highlowcontainer.getContainer(hb)\n\treturn c != nil && c.contains(lowbits(x))\n}\n\n// ContainsInt returns true if the integer is contained in the bitmap (this is a convenience method, the parameter is casted to uint32 and Contains is called)\nfunc (rb *Bitmap) ContainsInt(x int) bool {\n\treturn rb.Contains(uint32(x))\n}\n\n// Equals returns true if the two bitmaps contain the same integers\nfunc (rb *Bitmap) Equals(o interface{}) bool {\n\tsrb, ok := o.(*Bitmap)\n\tif ok {\n\t\treturn srb.highlowcontainer.equals(rb.highlowcontainer)\n\t}\n\treturn false\n}\n\n// AddOffset adds the value 'offset' to each and every value in a bitmap, generating a new bitmap in the process\nfunc AddOffset(x *Bitmap, offset uint32) (answer *Bitmap) {\n\treturn AddOffset64(x, int64(offset))\n}\n\n// AddOffset64 adds the value 'offset' to each and every value in a bitmap, generating a new bitmap in the process\n// If offset + element is outside of the range [0,2^32), that the element will be dropped\nfunc AddOffset64(x *Bitmap, offset int64) (answer *Bitmap) {\n\t// we need \"offset\" to be a long because we want to support values\n\t// between -0xFFFFFFFF up to +-0xFFFFFFFF\n\tvar containerOffset64 int64\n\n\tif offset < 0 {\n\t\tcontainerOffset64 = (offset - (1 << 16) + 1) / (1 << 16)\n\t} else {\n\t\tcontainerOffset64 = offset >> 16\n\t}\n\n\tanswer = New()\n\n\tif containerOffset64 >= (1<<16) || containerOffset64 < -(1<<16) {\n\t\treturn answer\n\t}\n\n\tcontainerOffset := int32(containerOffset64)\n\tinOffset := (uint16)(offset - containerOffset64*(1<<16))\n\n\tif inOffset == 0 {\n\t\tfor pos := 0; pos < x.highlowcontainer.size(); pos++ {\n\t\t\tkey := int32(x.highlowcontainer.getKeyAtIndex(pos))\n\t\t\tkey += containerOffset\n\n\t\t\tif key >= 0 && key <= MaxUint16 {\n\t\t\t\tc := x.highlowcontainer.getContainerAtIndex(pos).clone()\n\t\t\t\tanswer.highlowcontainer.appendContainer(uint16(key), c, false)\n\t\t\t}\n\t\t}\n\t} else {\n\t\tfor pos := 0; pos < x.highlowcontainer.size(); pos++ {\n\t\t\tkey := int32(x.highlowcontainer.getKeyAtIndex(pos))\n\t\t\tkey += containerOffset\n\n\t\t\tif key+1 < 0 || key > MaxUint16 {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tc := x.highlowcontainer.getContainerAtIndex(pos)\n\t\t\tlo, hi := c.addOffset(inOffset)\n\n\t\t\tif lo != nil && key >= 0 {\n\t\t\t\tcurSize := answer.highlowcontainer.size()\n\t\t\t\tlastkey := int32(0)\n\n\t\t\t\tif curSize > 0 {\n\t\t\t\t\tlastkey = int32(answer.highlowcontainer.getKeyAtIndex(curSize - 1))\n\t\t\t\t}\n\n\t\t\t\tif curSize > 0 && lastkey == key {\n\t\t\t\t\tprev := answer.highlowcontainer.getContainerAtIndex(curSize - 1)\n\t\t\t\t\torresult := prev.ior(lo)\n\t\t\t\t\tanswer.highlowcontainer.setContainerAtIndex(curSize-1, orresult)\n\t\t\t\t} else {\n\t\t\t\t\tanswer.highlowcontainer.appendContainer(uint16(key), lo, false)\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif hi != nil && key+1 <= MaxUint16 {\n\t\t\t\tanswer.highlowcontainer.appendContainer(uint16(key+1), hi, false)\n\t\t\t}\n\t\t}\n\t}\n\n\treturn answer\n}\n\n// Add the integer x to the bitmap\nfunc (rb *Bitmap) Add(x uint32) {\n\thb := highbits(x)\n\tra := &rb.highlowcontainer\n\ti := ra.getIndex(hb)\n\tif i >= 0 {\n\t\tvar c container\n\t\tc = ra.getWritableContainerAtIndex(i).iaddReturnMinimized(lowbits(x))\n\t\trb.highlowcontainer.setContainerAtIndex(i, c)\n\t} else {\n\t\tnewac := newArrayContainer()\n\t\trb.highlowcontainer.insertNewKeyValueAt(-i-1, hb, newac.iaddReturnMinimized(lowbits(x)))\n\t}\n}\n\n// add the integer x to the bitmap, return the container and its index\nfunc (rb *Bitmap) addwithptr(x uint32) (int, container) {\n\thb := highbits(x)\n\tra := &rb.highlowcontainer\n\ti := ra.getIndex(hb)\n\tvar c container\n\tif i >= 0 {\n\t\tc = ra.getWritableContainerAtIndex(i).iaddReturnMinimized(lowbits(x))\n\t\trb.highlowcontainer.setContainerAtIndex(i, c)\n\t\treturn i, c\n\t}\n\tnewac := newArrayContainer()\n\tc = newac.iaddReturnMinimized(lowbits(x))\n\trb.highlowcontainer.insertNewKeyValueAt(-i-1, hb, c)\n\treturn -i - 1, c\n}\n\n// CheckedAdd adds the integer x to the bitmap and return true  if it was added (false if the integer was already present)\nfunc (rb *Bitmap) CheckedAdd(x uint32) bool {\n\t// TODO: add unit tests for this method\n\thb := highbits(x)\n\ti := rb.highlowcontainer.getIndex(hb)\n\tif i >= 0 {\n\t\tC := rb.highlowcontainer.getWritableContainerAtIndex(i)\n\t\toldcard := C.getCardinality()\n\t\tC = C.iaddReturnMinimized(lowbits(x))\n\t\trb.highlowcontainer.setContainerAtIndex(i, C)\n\t\treturn C.getCardinality() > oldcard\n\t}\n\tnewac := newArrayContainer()\n\trb.highlowcontainer.insertNewKeyValueAt(-i-1, hb, newac.iaddReturnMinimized(lowbits(x)))\n\treturn true\n}\n\n// AddInt adds the integer x to the bitmap (convenience method: the parameter is casted to uint32 and we call Add)\nfunc (rb *Bitmap) AddInt(x int) {\n\trb.Add(uint32(x))\n}\n\n// Remove the integer x from the bitmap\nfunc (rb *Bitmap) Remove(x uint32) {\n\thb := highbits(x)\n\ti := rb.highlowcontainer.getIndex(hb)\n\tif i >= 0 {\n\t\tc := rb.highlowcontainer.getWritableContainerAtIndex(i).iremoveReturnMinimized(lowbits(x))\n\t\trb.highlowcontainer.setContainerAtIndex(i, c)\n\t\tif rb.highlowcontainer.getContainerAtIndex(i).isEmpty() {\n\t\t\trb.highlowcontainer.removeAtIndex(i)\n\t\t}\n\t}\n}\n\n// CheckedRemove removes the integer x from the bitmap and return true if the integer was effectively removed (and false if the integer was not present)\nfunc (rb *Bitmap) CheckedRemove(x uint32) bool {\n\t// TODO: add unit tests for this method\n\thb := highbits(x)\n\ti := rb.highlowcontainer.getIndex(hb)\n\tif i >= 0 {\n\t\tC := rb.highlowcontainer.getWritableContainerAtIndex(i)\n\t\toldcard := C.getCardinality()\n\t\tC = C.iremoveReturnMinimized(lowbits(x))\n\t\trb.highlowcontainer.setContainerAtIndex(i, C)\n\t\tif rb.highlowcontainer.getContainerAtIndex(i).isEmpty() {\n\t\t\trb.highlowcontainer.removeAtIndex(i)\n\t\t\treturn true\n\t\t}\n\t\treturn C.getCardinality() < oldcard\n\t}\n\treturn false\n}\n\n// IsEmpty returns true if the Bitmap is empty (it is faster than doing (GetCardinality() == 0))\nfunc (rb *Bitmap) IsEmpty() bool {\n\treturn rb.highlowcontainer.size() == 0\n}\n\n// GetCardinality returns the number of integers contained in the bitmap\nfunc (rb *Bitmap) GetCardinality() uint64 {\n\tsize := uint64(0)\n\tfor _, c := range rb.highlowcontainer.containers {\n\t\tsize += uint64(c.getCardinality())\n\t}\n\treturn size\n}\n\n// Rank returns the number of integers that are smaller or equal to x (Rank(infinity) would be GetCardinality()).\n// If you pass the smallest value, you get the value 1. If you pass a value that is smaller than the smallest\n// value, you get 0. Note that this function differs in convention from the Select function since it\n// return 1 and not 0 on the smallest value.\nfunc (rb *Bitmap) Rank(x uint32) uint64 {\n\tsize := uint64(0)\n\tfor i := 0; i < rb.highlowcontainer.size(); i++ {\n\t\tkey := rb.highlowcontainer.getKeyAtIndex(i)\n\t\tif key > highbits(x) {\n\t\t\treturn size\n\t\t}\n\t\tif key < highbits(x) {\n\t\t\tsize += uint64(rb.highlowcontainer.getContainerAtIndex(i).getCardinality())\n\t\t} else {\n\t\t\treturn size + uint64(rb.highlowcontainer.getContainerAtIndex(i).rank(lowbits(x)))\n\t\t}\n\t}\n\treturn size\n}\n\n// Select returns the xth integer in the bitmap. If you pass 0, you get\n// the smallest element. Note that this function differs in convention from\n// the Rank function which returns 1 on the smallest value.\nfunc (rb *Bitmap) Select(x uint32) (uint32, error) {\n\tremaining := x\n\tfor i := 0; i < rb.highlowcontainer.size(); i++ {\n\t\tc := rb.highlowcontainer.getContainerAtIndex(i)\n\t\tcard := uint32(c.getCardinality())\n\t\tif remaining >= card {\n\t\t\tremaining -= card\n\t\t} else {\n\t\t\tkey := rb.highlowcontainer.getKeyAtIndex(i)\n\t\t\treturn uint32(key)<<16 + uint32(c.selectInt(uint16(remaining))), nil\n\t\t}\n\t}\n\treturn 0, fmt.Errorf(\"cannot find %dth integer in a bitmap with only %d items\", x, rb.GetCardinality())\n}\n\n// And computes the intersection between two bitmaps and stores the result in the current bitmap\nfunc (rb *Bitmap) And(x2 *Bitmap) {\n\tpos1 := 0\n\tpos2 := 0\n\tintersectionsize := 0\n\tlength1 := rb.highlowcontainer.size()\n\tlength2 := x2.highlowcontainer.size()\n\nmain:\n\tfor {\n\t\tif pos1 < length1 && pos2 < length2 {\n\t\t\ts1 := rb.highlowcontainer.getKeyAtIndex(pos1)\n\t\t\ts2 := x2.highlowcontainer.getKeyAtIndex(pos2)\n\t\t\tfor {\n\t\t\t\tif s1 == s2 {\n\t\t\t\t\tc1 := rb.highlowcontainer.getWritableContainerAtIndex(pos1)\n\t\t\t\t\tc2 := x2.highlowcontainer.getContainerAtIndex(pos2)\n\t\t\t\t\tdiff := c1.iand(c2)\n\t\t\t\t\tif !diff.isEmpty() {\n\t\t\t\t\t\trb.highlowcontainer.replaceKeyAndContainerAtIndex(intersectionsize, s1, diff, false)\n\t\t\t\t\t\tintersectionsize++\n\t\t\t\t\t}\n\t\t\t\t\tpos1++\n\t\t\t\t\tpos2++\n\t\t\t\t\tif (pos1 == length1) || (pos2 == length2) {\n\t\t\t\t\t\tbreak main\n\t\t\t\t\t}\n\t\t\t\t\ts1 = rb.highlowcontainer.getKeyAtIndex(pos1)\n\t\t\t\t\ts2 = x2.highlowcontainer.getKeyAtIndex(pos2)\n\t\t\t\t} else if s1 < s2 {\n\t\t\t\t\tpos1 = rb.highlowcontainer.advanceUntil(s2, pos1)\n\t\t\t\t\tif pos1 == length1 {\n\t\t\t\t\t\tbreak main\n\t\t\t\t\t}\n\t\t\t\t\ts1 = rb.highlowcontainer.getKeyAtIndex(pos1)\n\t\t\t\t} else { // s1 > s2\n\t\t\t\t\tpos2 = x2.highlowcontainer.advanceUntil(s1, pos2)\n\t\t\t\t\tif pos2 == length2 {\n\t\t\t\t\t\tbreak main\n\t\t\t\t\t}\n\t\t\t\t\ts2 = x2.highlowcontainer.getKeyAtIndex(pos2)\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tbreak\n\t\t}\n\t}\n\trb.highlowcontainer.resize(intersectionsize)\n}\n\n// OrCardinality  returns the cardinality of the union between two bitmaps, bitmaps are not modified\nfunc (rb *Bitmap) OrCardinality(x2 *Bitmap) uint64 {\n\tpos1 := 0\n\tpos2 := 0\n\tlength1 := rb.highlowcontainer.size()\n\tlength2 := x2.highlowcontainer.size()\n\tanswer := uint64(0)\nmain:\n\tfor {\n\t\tif (pos1 < length1) && (pos2 < length2) {\n\t\t\ts1 := rb.highlowcontainer.getKeyAtIndex(pos1)\n\t\t\ts2 := x2.highlowcontainer.getKeyAtIndex(pos2)\n\n\t\t\tfor {\n\t\t\t\tif s1 < s2 {\n\t\t\t\t\tanswer += uint64(rb.highlowcontainer.getContainerAtIndex(pos1).getCardinality())\n\t\t\t\t\tpos1++\n\t\t\t\t\tif pos1 == length1 {\n\t\t\t\t\t\tbreak main\n\t\t\t\t\t}\n\t\t\t\t\ts1 = rb.highlowcontainer.getKeyAtIndex(pos1)\n\t\t\t\t} else if s1 > s2 {\n\t\t\t\t\tanswer += uint64(x2.highlowcontainer.getContainerAtIndex(pos2).getCardinality())\n\t\t\t\t\tpos2++\n\t\t\t\t\tif pos2 == length2 {\n\t\t\t\t\t\tbreak main\n\t\t\t\t\t}\n\t\t\t\t\ts2 = x2.highlowcontainer.getKeyAtIndex(pos2)\n\t\t\t\t} else {\n\t\t\t\t\t// TODO: could be faster if we did not have to materialize the container\n\t\t\t\t\tanswer += uint64(rb.highlowcontainer.getContainerAtIndex(pos1).or(x2.highlowcontainer.getContainerAtIndex(pos2)).getCardinality())\n\t\t\t\t\tpos1++\n\t\t\t\t\tpos2++\n\t\t\t\t\tif (pos1 == length1) || (pos2 == length2) {\n\t\t\t\t\t\tbreak main\n\t\t\t\t\t}\n\t\t\t\t\ts1 = rb.highlowcontainer.getKeyAtIndex(pos1)\n\t\t\t\t\ts2 = x2.highlowcontainer.getKeyAtIndex(pos2)\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tbreak\n\t\t}\n\t}\n\tfor ; pos1 < length1; pos1++ {\n\t\tanswer += uint64(rb.highlowcontainer.getContainerAtIndex(pos1).getCardinality())\n\t}\n\tfor ; pos2 < length2; pos2++ {\n\t\tanswer += uint64(x2.highlowcontainer.getContainerAtIndex(pos2).getCardinality())\n\t}\n\treturn answer\n}\n\n// AndCardinality returns the cardinality of the intersection between two bitmaps, bitmaps are not modified\nfunc (rb *Bitmap) AndCardinality(x2 *Bitmap) uint64 {\n\tpos1 := 0\n\tpos2 := 0\n\tanswer := uint64(0)\n\tlength1 := rb.highlowcontainer.size()\n\tlength2 := x2.highlowcontainer.size()\n\nmain:\n\tfor {\n\t\tif pos1 < length1 && pos2 < length2 {\n\t\t\ts1 := rb.highlowcontainer.getKeyAtIndex(pos1)\n\t\t\ts2 := x2.highlowcontainer.getKeyAtIndex(pos2)\n\t\t\tfor {\n\t\t\t\tif s1 == s2 {\n\t\t\t\t\tc1 := rb.highlowcontainer.getContainerAtIndex(pos1)\n\t\t\t\t\tc2 := x2.highlowcontainer.getContainerAtIndex(pos2)\n\t\t\t\t\tanswer += uint64(c1.andCardinality(c2))\n\t\t\t\t\tpos1++\n\t\t\t\t\tpos2++\n\t\t\t\t\tif (pos1 == length1) || (pos2 == length2) {\n\t\t\t\t\t\tbreak main\n\t\t\t\t\t}\n\t\t\t\t\ts1 = rb.highlowcontainer.getKeyAtIndex(pos1)\n\t\t\t\t\ts2 = x2.highlowcontainer.getKeyAtIndex(pos2)\n\t\t\t\t} else if s1 < s2 {\n\t\t\t\t\tpos1 = rb.highlowcontainer.advanceUntil(s2, pos1)\n\t\t\t\t\tif pos1 == length1 {\n\t\t\t\t\t\tbreak main\n\t\t\t\t\t}\n\t\t\t\t\ts1 = rb.highlowcontainer.getKeyAtIndex(pos1)\n\t\t\t\t} else { // s1 > s2\n\t\t\t\t\tpos2 = x2.highlowcontainer.advanceUntil(s1, pos2)\n\t\t\t\t\tif pos2 == length2 {\n\t\t\t\t\t\tbreak main\n\t\t\t\t\t}\n\t\t\t\t\ts2 = x2.highlowcontainer.getKeyAtIndex(pos2)\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tbreak\n\t\t}\n\t}\n\treturn answer\n}\n\n// IntersectsWithInterval checks whether a bitmap 'rb' and an open interval '[x,y)' intersect.\nfunc (rb *Bitmap) IntersectsWithInterval(x, y uint64) bool {\n\tif x >= y {\n\t\treturn false\n\t}\n\tif x > MaxUint32 {\n\t\treturn false\n\t}\n\n\tit := intIterator{}\n\tit.Initialize(rb)\n\tit.AdvanceIfNeeded(uint32(x))\n\tif !it.HasNext() {\n\t\treturn false\n\t}\n\tif uint64(it.Next()) >= y {\n\t\treturn false\n\t}\n\n\treturn true\n}\n\n// Intersects checks whether two bitmap intersects, bitmaps are not modified\nfunc (rb *Bitmap) Intersects(x2 *Bitmap) bool {\n\tpos1 := 0\n\tpos2 := 0\n\tlength1 := rb.highlowcontainer.size()\n\tlength2 := x2.highlowcontainer.size()\n\nmain:\n\tfor {\n\t\tif pos1 < length1 && pos2 < length2 {\n\t\t\ts1 := rb.highlowcontainer.getKeyAtIndex(pos1)\n\t\t\ts2 := x2.highlowcontainer.getKeyAtIndex(pos2)\n\t\t\tfor {\n\t\t\t\tif s1 == s2 {\n\t\t\t\t\tc1 := rb.highlowcontainer.getContainerAtIndex(pos1)\n\t\t\t\t\tc2 := x2.highlowcontainer.getContainerAtIndex(pos2)\n\t\t\t\t\tif c1.intersects(c2) {\n\t\t\t\t\t\treturn true\n\t\t\t\t\t}\n\t\t\t\t\tpos1++\n\t\t\t\t\tpos2++\n\t\t\t\t\tif (pos1 == length1) || (pos2 == length2) {\n\t\t\t\t\t\tbreak main\n\t\t\t\t\t}\n\t\t\t\t\ts1 = rb.highlowcontainer.getKeyAtIndex(pos1)\n\t\t\t\t\ts2 = x2.highlowcontainer.getKeyAtIndex(pos2)\n\t\t\t\t} else if s1 < s2 {\n\t\t\t\t\tpos1 = rb.highlowcontainer.advanceUntil(s2, pos1)\n\t\t\t\t\tif pos1 == length1 {\n\t\t\t\t\t\tbreak main\n\t\t\t\t\t}\n\t\t\t\t\ts1 = rb.highlowcontainer.getKeyAtIndex(pos1)\n\t\t\t\t} else { // s1 > s2\n\t\t\t\t\tpos2 = x2.highlowcontainer.advanceUntil(s1, pos2)\n\t\t\t\t\tif pos2 == length2 {\n\t\t\t\t\t\tbreak main\n\t\t\t\t\t}\n\t\t\t\t\ts2 = x2.highlowcontainer.getKeyAtIndex(pos2)\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tbreak\n\t\t}\n\t}\n\treturn false\n}\n\n// Xor computes the symmetric difference between two bitmaps and stores the result in the current bitmap\nfunc (rb *Bitmap) Xor(x2 *Bitmap) {\n\tpos1 := 0\n\tpos2 := 0\n\tlength1 := rb.highlowcontainer.size()\n\tlength2 := x2.highlowcontainer.size()\n\tfor {\n\t\tif (pos1 < length1) && (pos2 < length2) {\n\t\t\ts1 := rb.highlowcontainer.getKeyAtIndex(pos1)\n\t\t\ts2 := x2.highlowcontainer.getKeyAtIndex(pos2)\n\t\t\tif s1 < s2 {\n\t\t\t\tpos1 = rb.highlowcontainer.advanceUntil(s2, pos1)\n\t\t\t\tif pos1 == length1 {\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t} else if s1 > s2 {\n\t\t\t\tc := x2.highlowcontainer.getWritableContainerAtIndex(pos2)\n\t\t\t\trb.highlowcontainer.insertNewKeyValueAt(pos1, x2.highlowcontainer.getKeyAtIndex(pos2), c)\n\t\t\t\tlength1++\n\t\t\t\tpos1++\n\t\t\t\tpos2++\n\t\t\t} else {\n\t\t\t\t// TODO: couple be computed in-place for reduced memory usage\n\t\t\t\tc := rb.highlowcontainer.getContainerAtIndex(pos1).xor(x2.highlowcontainer.getContainerAtIndex(pos2))\n\t\t\t\tif !c.isEmpty() {\n\t\t\t\t\trb.highlowcontainer.setContainerAtIndex(pos1, c)\n\t\t\t\t\tpos1++\n\t\t\t\t} else {\n\t\t\t\t\trb.highlowcontainer.removeAtIndex(pos1)\n\t\t\t\t\tlength1--\n\t\t\t\t}\n\t\t\t\tpos2++\n\t\t\t}\n\t\t} else {\n\t\t\tbreak\n\t\t}\n\t}\n\tif pos1 == length1 {\n\t\trb.highlowcontainer.appendCopyMany(x2.highlowcontainer, pos2, length2)\n\t}\n}\n\n// Or computes the union between two bitmaps and stores the result in the current bitmap\nfunc (rb *Bitmap) Or(x2 *Bitmap) {\n\tpos1 := 0\n\tpos2 := 0\n\tlength1 := rb.highlowcontainer.size()\n\tlength2 := x2.highlowcontainer.size()\nmain:\n\tfor (pos1 < length1) && (pos2 < length2) {\n\t\ts1 := rb.highlowcontainer.getKeyAtIndex(pos1)\n\t\ts2 := x2.highlowcontainer.getKeyAtIndex(pos2)\n\n\t\tfor {\n\t\t\tif s1 < s2 {\n\t\t\t\tpos1++\n\t\t\t\tif pos1 == length1 {\n\t\t\t\t\tbreak main\n\t\t\t\t}\n\t\t\t\ts1 = rb.highlowcontainer.getKeyAtIndex(pos1)\n\t\t\t} else if s1 > s2 {\n\t\t\t\trb.highlowcontainer.insertNewKeyValueAt(pos1, s2, x2.highlowcontainer.getContainerAtIndex(pos2).clone())\n\t\t\t\tpos1++\n\t\t\t\tlength1++\n\t\t\t\tpos2++\n\t\t\t\tif pos2 == length2 {\n\t\t\t\t\tbreak main\n\t\t\t\t}\n\t\t\t\ts2 = x2.highlowcontainer.getKeyAtIndex(pos2)\n\t\t\t} else {\n\t\t\t\trb.highlowcontainer.replaceKeyAndContainerAtIndex(pos1, s1, rb.highlowcontainer.getUnionedWritableContainer(pos1, x2.highlowcontainer.getContainerAtIndex(pos2)), false)\n\t\t\t\tpos1++\n\t\t\t\tpos2++\n\t\t\t\tif (pos1 == length1) || (pos2 == length2) {\n\t\t\t\t\tbreak main\n\t\t\t\t}\n\t\t\t\ts1 = rb.highlowcontainer.getKeyAtIndex(pos1)\n\t\t\t\ts2 = x2.highlowcontainer.getKeyAtIndex(pos2)\n\t\t\t}\n\t\t}\n\t}\n\tif pos1 == length1 {\n\t\trb.highlowcontainer.appendCopyMany(x2.highlowcontainer, pos2, length2)\n\t}\n}\n\n// AndNot computes the difference between two bitmaps and stores the result in the current bitmap\nfunc (rb *Bitmap) AndNot(x2 *Bitmap) {\n\tpos1 := 0\n\tpos2 := 0\n\tintersectionsize := 0\n\tlength1 := rb.highlowcontainer.size()\n\tlength2 := x2.highlowcontainer.size()\n\nmain:\n\tfor {\n\t\tif pos1 < length1 && pos2 < length2 {\n\t\t\ts1 := rb.highlowcontainer.getKeyAtIndex(pos1)\n\t\t\ts2 := x2.highlowcontainer.getKeyAtIndex(pos2)\n\t\t\tfor {\n\t\t\t\tif s1 == s2 {\n\t\t\t\t\tc1 := rb.highlowcontainer.getWritableContainerAtIndex(pos1)\n\t\t\t\t\tc2 := x2.highlowcontainer.getContainerAtIndex(pos2)\n\t\t\t\t\tdiff := c1.iandNot(c2)\n\t\t\t\t\tif !diff.isEmpty() {\n\t\t\t\t\t\trb.highlowcontainer.replaceKeyAndContainerAtIndex(intersectionsize, s1, diff, false)\n\t\t\t\t\t\tintersectionsize++\n\t\t\t\t\t}\n\t\t\t\t\tpos1++\n\t\t\t\t\tpos2++\n\t\t\t\t\tif (pos1 == length1) || (pos2 == length2) {\n\t\t\t\t\t\tbreak main\n\t\t\t\t\t}\n\t\t\t\t\ts1 = rb.highlowcontainer.getKeyAtIndex(pos1)\n\t\t\t\t\ts2 = x2.highlowcontainer.getKeyAtIndex(pos2)\n\t\t\t\t} else if s1 < s2 {\n\t\t\t\t\tc1 := rb.highlowcontainer.getContainerAtIndex(pos1)\n\t\t\t\t\tmustCopyOnWrite := rb.highlowcontainer.needsCopyOnWrite(pos1)\n\t\t\t\t\trb.highlowcontainer.replaceKeyAndContainerAtIndex(intersectionsize, s1, c1, mustCopyOnWrite)\n\t\t\t\t\tintersectionsize++\n\t\t\t\t\tpos1++\n\t\t\t\t\tif pos1 == length1 {\n\t\t\t\t\t\tbreak main\n\t\t\t\t\t}\n\t\t\t\t\ts1 = rb.highlowcontainer.getKeyAtIndex(pos1)\n\t\t\t\t} else { // s1 > s2\n\t\t\t\t\tpos2 = x2.highlowcontainer.advanceUntil(s1, pos2)\n\t\t\t\t\tif pos2 == length2 {\n\t\t\t\t\t\tbreak main\n\t\t\t\t\t}\n\t\t\t\t\ts2 = x2.highlowcontainer.getKeyAtIndex(pos2)\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tbreak\n\t\t}\n\t}\n\t// TODO:implement as a copy\n\tfor pos1 < length1 {\n\t\tc1 := rb.highlowcontainer.getContainerAtIndex(pos1)\n\t\ts1 := rb.highlowcontainer.getKeyAtIndex(pos1)\n\t\tmustCopyOnWrite := rb.highlowcontainer.needsCopyOnWrite(pos1)\n\t\trb.highlowcontainer.replaceKeyAndContainerAtIndex(intersectionsize, s1, c1, mustCopyOnWrite)\n\t\tintersectionsize++\n\t\tpos1++\n\t}\n\trb.highlowcontainer.resize(intersectionsize)\n}\n\n// Or computes the union between two bitmaps and returns the result\nfunc Or(x1, x2 *Bitmap) *Bitmap {\n\tanswer := NewBitmap()\n\tpos1 := 0\n\tpos2 := 0\n\tlength1 := x1.highlowcontainer.size()\n\tlength2 := x2.highlowcontainer.size()\nmain:\n\tfor (pos1 < length1) && (pos2 < length2) {\n\t\ts1 := x1.highlowcontainer.getKeyAtIndex(pos1)\n\t\ts2 := x2.highlowcontainer.getKeyAtIndex(pos2)\n\n\t\tfor {\n\t\t\tif s1 < s2 {\n\t\t\t\tanswer.highlowcontainer.appendCopy(x1.highlowcontainer, pos1)\n\t\t\t\tpos1++\n\t\t\t\tif pos1 == length1 {\n\t\t\t\t\tbreak main\n\t\t\t\t}\n\t\t\t\ts1 = x1.highlowcontainer.getKeyAtIndex(pos1)\n\t\t\t} else if s1 > s2 {\n\t\t\t\tanswer.highlowcontainer.appendCopy(x2.highlowcontainer, pos2)\n\t\t\t\tpos2++\n\t\t\t\tif pos2 == length2 {\n\t\t\t\t\tbreak main\n\t\t\t\t}\n\t\t\t\ts2 = x2.highlowcontainer.getKeyAtIndex(pos2)\n\t\t\t} else {\n\n\t\t\t\tanswer.highlowcontainer.appendContainer(s1, x1.highlowcontainer.getContainerAtIndex(pos1).or(x2.highlowcontainer.getContainerAtIndex(pos2)), false)\n\t\t\t\tpos1++\n\t\t\t\tpos2++\n\t\t\t\tif (pos1 == length1) || (pos2 == length2) {\n\t\t\t\t\tbreak main\n\t\t\t\t}\n\t\t\t\ts1 = x1.highlowcontainer.getKeyAtIndex(pos1)\n\t\t\t\ts2 = x2.highlowcontainer.getKeyAtIndex(pos2)\n\t\t\t}\n\t\t}\n\t}\n\tif pos1 == length1 {\n\t\tanswer.highlowcontainer.appendCopyMany(x2.highlowcontainer, pos2, length2)\n\t} else if pos2 == length2 {\n\t\tanswer.highlowcontainer.appendCopyMany(x1.highlowcontainer, pos1, length1)\n\t}\n\treturn answer\n}\n\n// And computes the intersection between two bitmaps and returns the result\nfunc And(x1, x2 *Bitmap) *Bitmap {\n\tanswer := NewBitmap()\n\tpos1 := 0\n\tpos2 := 0\n\tlength1 := x1.highlowcontainer.size()\n\tlength2 := x2.highlowcontainer.size()\nmain:\n\tfor pos1 < length1 && pos2 < length2 {\n\t\ts1 := x1.highlowcontainer.getKeyAtIndex(pos1)\n\t\ts2 := x2.highlowcontainer.getKeyAtIndex(pos2)\n\t\tfor {\n\t\t\tif s1 == s2 {\n\t\t\t\tC := x1.highlowcontainer.getContainerAtIndex(pos1)\n\t\t\t\tC = C.and(x2.highlowcontainer.getContainerAtIndex(pos2))\n\n\t\t\t\tif !C.isEmpty() {\n\t\t\t\t\tanswer.highlowcontainer.appendContainer(s1, C, false)\n\t\t\t\t}\n\t\t\t\tpos1++\n\t\t\t\tpos2++\n\t\t\t\tif (pos1 == length1) || (pos2 == length2) {\n\t\t\t\t\tbreak main\n\t\t\t\t}\n\t\t\t\ts1 = x1.highlowcontainer.getKeyAtIndex(pos1)\n\t\t\t\ts2 = x2.highlowcontainer.getKeyAtIndex(pos2)\n\t\t\t} else if s1 < s2 {\n\t\t\t\tpos1 = x1.highlowcontainer.advanceUntil(s2, pos1)\n\t\t\t\tif pos1 == length1 {\n\t\t\t\t\tbreak main\n\t\t\t\t}\n\t\t\t\ts1 = x1.highlowcontainer.getKeyAtIndex(pos1)\n\t\t\t} else { // s1 > s2\n\t\t\t\tpos2 = x2.highlowcontainer.advanceUntil(s1, pos2)\n\t\t\t\tif pos2 == length2 {\n\t\t\t\t\tbreak main\n\t\t\t\t}\n\t\t\t\ts2 = x2.highlowcontainer.getKeyAtIndex(pos2)\n\t\t\t}\n\t\t}\n\t}\n\treturn answer\n}\n\n// Xor computes the symmetric difference between two bitmaps and returns the result\nfunc Xor(x1, x2 *Bitmap) *Bitmap {\n\tanswer := NewBitmap()\n\tpos1 := 0\n\tpos2 := 0\n\tlength1 := x1.highlowcontainer.size()\n\tlength2 := x2.highlowcontainer.size()\n\tfor {\n\t\tif (pos1 < length1) && (pos2 < length2) {\n\t\t\ts1 := x1.highlowcontainer.getKeyAtIndex(pos1)\n\t\t\ts2 := x2.highlowcontainer.getKeyAtIndex(pos2)\n\t\t\tif s1 < s2 {\n\t\t\t\tanswer.highlowcontainer.appendCopy(x1.highlowcontainer, pos1)\n\t\t\t\tpos1++\n\t\t\t} else if s1 > s2 {\n\t\t\t\tanswer.highlowcontainer.appendCopy(x2.highlowcontainer, pos2)\n\t\t\t\tpos2++\n\t\t\t} else {\n\t\t\t\tc := x1.highlowcontainer.getContainerAtIndex(pos1).xor(x2.highlowcontainer.getContainerAtIndex(pos2))\n\t\t\t\tif !c.isEmpty() {\n\t\t\t\t\tanswer.highlowcontainer.appendContainer(s1, c, false)\n\t\t\t\t}\n\t\t\t\tpos1++\n\t\t\t\tpos2++\n\t\t\t}\n\t\t} else {\n\t\t\tbreak\n\t\t}\n\t}\n\tif pos1 == length1 {\n\t\tanswer.highlowcontainer.appendCopyMany(x2.highlowcontainer, pos2, length2)\n\t} else if pos2 == length2 {\n\t\tanswer.highlowcontainer.appendCopyMany(x1.highlowcontainer, pos1, length1)\n\t}\n\treturn answer\n}\n\n// AndNot computes the difference between two bitmaps and returns the result\nfunc AndNot(x1, x2 *Bitmap) *Bitmap {\n\tanswer := NewBitmap()\n\tpos1 := 0\n\tpos2 := 0\n\tlength1 := x1.highlowcontainer.size()\n\tlength2 := x2.highlowcontainer.size()\n\nmain:\n\tfor {\n\t\tif pos1 < length1 && pos2 < length2 {\n\t\t\ts1 := x1.highlowcontainer.getKeyAtIndex(pos1)\n\t\t\ts2 := x2.highlowcontainer.getKeyAtIndex(pos2)\n\t\t\tfor {\n\t\t\t\tif s1 < s2 {\n\t\t\t\t\tanswer.highlowcontainer.appendCopy(x1.highlowcontainer, pos1)\n\t\t\t\t\tpos1++\n\t\t\t\t\tif pos1 == length1 {\n\t\t\t\t\t\tbreak main\n\t\t\t\t\t}\n\t\t\t\t\ts1 = x1.highlowcontainer.getKeyAtIndex(pos1)\n\t\t\t\t} else if s1 == s2 {\n\t\t\t\t\tc1 := x1.highlowcontainer.getContainerAtIndex(pos1)\n\t\t\t\t\tc2 := x2.highlowcontainer.getContainerAtIndex(pos2)\n\t\t\t\t\tdiff := c1.andNot(c2)\n\t\t\t\t\tif !diff.isEmpty() {\n\t\t\t\t\t\tanswer.highlowcontainer.appendContainer(s1, diff, false)\n\t\t\t\t\t}\n\t\t\t\t\tpos1++\n\t\t\t\t\tpos2++\n\t\t\t\t\tif (pos1 == length1) || (pos2 == length2) {\n\t\t\t\t\t\tbreak main\n\t\t\t\t\t}\n\t\t\t\t\ts1 = x1.highlowcontainer.getKeyAtIndex(pos1)\n\t\t\t\t\ts2 = x2.highlowcontainer.getKeyAtIndex(pos2)\n\t\t\t\t} else { // s1 > s2\n\t\t\t\t\tpos2 = x2.highlowcontainer.advanceUntil(s1, pos2)\n\t\t\t\t\tif pos2 == length2 {\n\t\t\t\t\t\tbreak main\n\t\t\t\t\t}\n\t\t\t\t\ts2 = x2.highlowcontainer.getKeyAtIndex(pos2)\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tbreak\n\t\t}\n\t}\n\tif pos2 == length2 {\n\t\tanswer.highlowcontainer.appendCopyMany(x1.highlowcontainer, pos1, length1)\n\t}\n\treturn answer\n}\n\n// AddMany add all of the values in dat\nfunc (rb *Bitmap) AddMany(dat []uint32) {\n\tif len(dat) == 0 {\n\t\treturn\n\t}\n\tprev := dat[0]\n\tidx, c := rb.addwithptr(prev)\n\tfor _, i := range dat[1:] {\n\t\tif highbits(prev) == highbits(i) {\n\t\t\tc = c.iaddReturnMinimized(lowbits(i))\n\t\t\trb.highlowcontainer.setContainerAtIndex(idx, c)\n\t\t} else {\n\t\t\tidx, c = rb.addwithptr(i)\n\t\t}\n\t\tprev = i\n\t}\n}\n\n// BitmapOf generates a new bitmap filled with the specified integers\nfunc BitmapOf(dat ...uint32) *Bitmap {\n\tans := NewBitmap()\n\tans.AddMany(dat)\n\treturn ans\n}\n\n// Flip negates the bits in the given range (i.e., [rangeStart,rangeEnd)), any integer present in this range and in the bitmap is removed,\n// and any integer present in the range and not in the bitmap is added.\n// The function uses 64-bit parameters even though a Bitmap stores 32-bit values because it is allowed and meaningful to use [0,uint64(0x100000000)) as a range\n// while uint64(0x100000000) cannot be represented as a 32-bit value.\nfunc (rb *Bitmap) Flip(rangeStart, rangeEnd uint64) {\n\tif rangeEnd > MaxUint32+1 {\n\t\tpanic(\"rangeEnd > MaxUint32+1\")\n\t}\n\tif rangeStart > MaxUint32+1 {\n\t\tpanic(\"rangeStart > MaxUint32+1\")\n\t}\n\n\tif rangeStart >= rangeEnd {\n\t\treturn\n\t}\n\n\thbStart := uint32(highbits(uint32(rangeStart)))\n\tlbStart := uint32(lowbits(uint32(rangeStart)))\n\thbLast := uint32(highbits(uint32(rangeEnd - 1)))\n\tlbLast := uint32(lowbits(uint32(rangeEnd - 1)))\n\n\tvar max uint32 = maxLowBit\n\tfor hb := hbStart; hb <= hbLast; hb++ {\n\t\tvar containerStart uint32\n\t\tif hb == hbStart {\n\t\t\tcontainerStart = uint32(lbStart)\n\t\t}\n\t\tcontainerLast := max\n\t\tif hb == hbLast {\n\t\t\tcontainerLast = uint32(lbLast)\n\t\t}\n\n\t\ti := rb.highlowcontainer.getIndex(uint16(hb))\n\n\t\tif i >= 0 {\n\t\t\tc := rb.highlowcontainer.getWritableContainerAtIndex(i).inot(int(containerStart), int(containerLast)+1)\n\t\t\tif !c.isEmpty() {\n\t\t\t\trb.highlowcontainer.setContainerAtIndex(i, c)\n\t\t\t} else {\n\t\t\t\trb.highlowcontainer.removeAtIndex(i)\n\t\t\t}\n\t\t} else { // *think* the range of ones must never be\n\t\t\t// empty.\n\t\t\trb.highlowcontainer.insertNewKeyValueAt(-i-1, uint16(hb), rangeOfOnes(int(containerStart), int(containerLast)))\n\t\t}\n\t}\n}\n\n// FlipInt calls Flip after casting the parameters  (convenience method)\nfunc (rb *Bitmap) FlipInt(rangeStart, rangeEnd int) {\n\trb.Flip(uint64(rangeStart), uint64(rangeEnd))\n}\n\n// AddRange adds the integers in [rangeStart, rangeEnd) to the bitmap.\n// The function uses 64-bit parameters even though a Bitmap stores 32-bit values because it is allowed and meaningful to use [0,uint64(0x100000000)) as a range\n// while uint64(0x100000000) cannot be represented as a 32-bit value.\nfunc (rb *Bitmap) AddRange(rangeStart, rangeEnd uint64) {\n\tif rangeStart >= rangeEnd {\n\t\treturn\n\t}\n\tif rangeEnd-1 > MaxUint32 {\n\t\tpanic(\"rangeEnd-1 > MaxUint32\")\n\t}\n\thbStart := uint32(highbits(uint32(rangeStart)))\n\tlbStart := uint32(lowbits(uint32(rangeStart)))\n\thbLast := uint32(highbits(uint32(rangeEnd - 1)))\n\tlbLast := uint32(lowbits(uint32(rangeEnd - 1)))\n\n\tvar max uint32 = maxLowBit\n\tfor hb := hbStart; hb <= hbLast; hb++ {\n\t\tcontainerStart := uint32(0)\n\t\tif hb == hbStart {\n\t\t\tcontainerStart = lbStart\n\t\t}\n\t\tcontainerLast := max\n\t\tif hb == hbLast {\n\t\t\tcontainerLast = lbLast\n\t\t}\n\n\t\ti := rb.highlowcontainer.getIndex(uint16(hb))\n\n\t\tif i >= 0 {\n\t\t\tc := rb.highlowcontainer.getWritableContainerAtIndex(i).iaddRange(int(containerStart), int(containerLast)+1)\n\t\t\trb.highlowcontainer.setContainerAtIndex(i, c)\n\t\t} else { // *think* the range of ones must never be\n\t\t\t// empty.\n\t\t\trb.highlowcontainer.insertNewKeyValueAt(-i-1, uint16(hb), rangeOfOnes(int(containerStart), int(containerLast)))\n\t\t}\n\t}\n}\n\n// RemoveRange removes the integers in [rangeStart, rangeEnd) from the bitmap.\n// The function uses 64-bit parameters even though a Bitmap stores 32-bit values because it is allowed and meaningful to use [0,uint64(0x100000000)) as a range\n// while uint64(0x100000000) cannot be represented as a 32-bit value.\nfunc (rb *Bitmap) RemoveRange(rangeStart, rangeEnd uint64) {\n\tif rangeStart >= rangeEnd {\n\t\treturn\n\t}\n\tif rangeEnd-1 > MaxUint32 {\n\t\t// logically, we should assume that the user wants to\n\t\t// remove all values from rangeStart to infinity\n\t\t// see https://github.com/RoaringBitmap/roaring/issues/141\n\t\trangeEnd = uint64(0x100000000)\n\t}\n\thbStart := uint32(highbits(uint32(rangeStart)))\n\tlbStart := uint32(lowbits(uint32(rangeStart)))\n\thbLast := uint32(highbits(uint32(rangeEnd - 1)))\n\tlbLast := uint32(lowbits(uint32(rangeEnd - 1)))\n\n\tvar max uint32 = maxLowBit\n\n\tif hbStart == hbLast {\n\t\ti := rb.highlowcontainer.getIndex(uint16(hbStart))\n\t\tif i < 0 {\n\t\t\treturn\n\t\t}\n\t\tc := rb.highlowcontainer.getWritableContainerAtIndex(i).iremoveRange(int(lbStart), int(lbLast+1))\n\t\tif !c.isEmpty() {\n\t\t\trb.highlowcontainer.setContainerAtIndex(i, c)\n\t\t} else {\n\t\t\trb.highlowcontainer.removeAtIndex(i)\n\t\t}\n\t\treturn\n\t}\n\tifirst := rb.highlowcontainer.getIndex(uint16(hbStart))\n\tilast := rb.highlowcontainer.getIndex(uint16(hbLast))\n\n\tif ifirst >= 0 {\n\t\tif lbStart != 0 {\n\t\t\tc := rb.highlowcontainer.getWritableContainerAtIndex(ifirst).iremoveRange(int(lbStart), int(max+1))\n\t\t\tif !c.isEmpty() {\n\t\t\t\trb.highlowcontainer.setContainerAtIndex(ifirst, c)\n\t\t\t\tifirst++\n\t\t\t}\n\t\t}\n\t} else {\n\t\tifirst = -ifirst - 1\n\t}\n\tif ilast >= 0 {\n\t\tif lbLast != max {\n\t\t\tc := rb.highlowcontainer.getWritableContainerAtIndex(ilast).iremoveRange(int(0), int(lbLast+1))\n\t\t\tif !c.isEmpty() {\n\t\t\t\trb.highlowcontainer.setContainerAtIndex(ilast, c)\n\t\t\t} else {\n\t\t\t\tilast++\n\t\t\t}\n\t\t} else {\n\t\t\tilast++\n\t\t}\n\t} else {\n\t\tilast = -ilast - 1\n\t}\n\trb.highlowcontainer.removeIndexRange(ifirst, ilast)\n}\n\n// Flip negates the bits in the given range  (i.e., [rangeStart,rangeEnd)), any integer present in this range and in the bitmap is removed,\n// and any integer present in the range and not in the bitmap is added, a new bitmap is returned leaving\n// the current bitmap unchanged.\n// The function uses 64-bit parameters even though a Bitmap stores 32-bit values because it is allowed and meaningful to use [0,uint64(0x100000000)) as a range\n// while uint64(0x100000000) cannot be represented as a 32-bit value.\nfunc Flip(bm *Bitmap, rangeStart, rangeEnd uint64) *Bitmap {\n\tif rangeStart >= rangeEnd {\n\t\treturn bm.Clone()\n\t}\n\n\tif rangeStart > MaxUint32 {\n\t\tpanic(\"rangeStart > MaxUint32\")\n\t}\n\tif rangeEnd-1 > MaxUint32 {\n\t\tpanic(\"rangeEnd-1 > MaxUint32\")\n\t}\n\n\tanswer := NewBitmap()\n\thbStart := uint32(highbits(uint32(rangeStart)))\n\tlbStart := uint32(lowbits(uint32(rangeStart)))\n\thbLast := uint32(highbits(uint32(rangeEnd - 1)))\n\tlbLast := uint32(lowbits(uint32(rangeEnd - 1)))\n\n\t// copy the containers before the active area\n\tanswer.highlowcontainer.appendCopiesUntil(bm.highlowcontainer, uint16(hbStart))\n\n\tvar max uint32 = maxLowBit\n\tfor hb := hbStart; hb <= hbLast; hb++ {\n\t\tvar containerStart uint32\n\t\tif hb == hbStart {\n\t\t\tcontainerStart = uint32(lbStart)\n\t\t}\n\t\tcontainerLast := max\n\t\tif hb == hbLast {\n\t\t\tcontainerLast = uint32(lbLast)\n\t\t}\n\n\t\ti := bm.highlowcontainer.getIndex(uint16(hb))\n\t\tj := answer.highlowcontainer.getIndex(uint16(hb))\n\n\t\tif i >= 0 {\n\t\t\tc := bm.highlowcontainer.getContainerAtIndex(i).not(int(containerStart), int(containerLast)+1)\n\t\t\tif !c.isEmpty() {\n\t\t\t\tanswer.highlowcontainer.insertNewKeyValueAt(-j-1, uint16(hb), c)\n\t\t\t}\n\n\t\t} else { // *think* the range of ones must never be\n\t\t\t// empty.\n\t\t\tanswer.highlowcontainer.insertNewKeyValueAt(-j-1, uint16(hb),\n\t\t\t\trangeOfOnes(int(containerStart), int(containerLast)))\n\t\t}\n\t}\n\t// copy the containers after the active area.\n\tanswer.highlowcontainer.appendCopiesAfter(bm.highlowcontainer, uint16(hbLast))\n\n\treturn answer\n}\n\n// SetCopyOnWrite sets this bitmap to use copy-on-write so that copies are fast and memory conscious\n// if the parameter is true, otherwise we leave the default where hard copies are made\n// (copy-on-write requires extra care in a threaded context).\n// Calling SetCopyOnWrite(true) on a bitmap created with FromBuffer is unsafe.\nfunc (rb *Bitmap) SetCopyOnWrite(val bool) {\n\trb.highlowcontainer.copyOnWrite = val\n}\n\n// GetCopyOnWrite gets this bitmap's copy-on-write property\nfunc (rb *Bitmap) GetCopyOnWrite() (val bool) {\n\treturn rb.highlowcontainer.copyOnWrite\n}\n\n// CloneCopyOnWriteContainers clones all containers which have\n// needCopyOnWrite set to true.\n// This can be used to make sure it is safe to munmap a []byte\n// that the roaring array may still have a reference to, after\n// calling FromBuffer.\n// More generally this function is useful if you call FromBuffer\n// to construct a bitmap with a backing array buf\n// and then later discard the buf array. Note that you should call\n// CloneCopyOnWriteContainers on all bitmaps that were derived\n// from the 'FromBuffer' bitmap since they map have dependencies\n// on the buf array as well.\nfunc (rb *Bitmap) CloneCopyOnWriteContainers() {\n\trb.highlowcontainer.cloneCopyOnWriteContainers()\n}\n\n// NextValue returns the next largest value in the bitmap, or -1\n// if none is present. This function should not be used inside\n// a performance-sensitive loop: prefer iterators if\n// performance is a concern.\nfunc (rb *Bitmap) NextValue(target uint32) int64 {\n\toriginalKey := highbits(target)\n\tquery := lowbits(target)\n\tvar nextValue int64\n\tnextValue = -1\n\tcontainerIndex := rb.highlowcontainer.advanceUntil(originalKey, -1)\n\tfor containerIndex < rb.highlowcontainer.size() && nextValue == -1 {\n\t\tcontainerKey := rb.highlowcontainer.getKeyAtIndex(containerIndex)\n\t\tcontainer := rb.highlowcontainer.getContainer(containerKey)\n\t\t// if containerKey > orginalKey then we are past the container which mapped to the orignal key\n\t\t// in that case we can just return the minimum from that container\n\t\tvar responseBit int64\n\t\tif containerKey > originalKey {\n\t\t\tbit, err := container.safeMinimum()\n\t\t\tif err == nil {\n\t\t\t\tresponseBit = -1\n\t\t\t}\n\t\t\tresponseBit = int64(bit)\n\t\t} else {\n\t\t\tresponseBit = int64(container.nextValue(query))\n\t\t}\n\n\t\tif responseBit == -1 {\n\t\t\tnextValue = -1\n\t\t} else {\n\t\t\tnextValue = int64(combineLoHi32(uint32(responseBit), uint32(containerKey)))\n\t\t}\n\t\tcontainerIndex++\n\t}\n\n\treturn nextValue\n}\n\n// PreviousValue returns the previous largest value in the bitmap, or -1\n// if none is present. This function should not be used inside\n// a performance-sensitive loop: prefer iterators if\n// performance is a concern.\nfunc (rb *Bitmap) PreviousValue(target uint32) int64 {\n\tif rb.IsEmpty() {\n\t\treturn -1\n\t}\n\n\toriginalKey := highbits(uint32(target))\n\tquery := lowbits(uint32(target))\n\tvar prevValue int64\n\tprevValue = -1\n\tcontainerIndex := rb.highlowcontainer.advanceUntil(originalKey, -1)\n\n\tif containerIndex == rb.highlowcontainer.size() {\n\t\treturn int64(rb.Maximum())\n\t}\n\n\tif rb.highlowcontainer.getKeyAtIndex(containerIndex) > originalKey {\n\t\t// target absent, key of first container after target too high\n\t\tcontainerIndex--\n\t}\n\n\tfor containerIndex != -1 && prevValue == -1 {\n\t\tcontainerKey := rb.highlowcontainer.getKeyAtIndex(containerIndex)\n\t\tcontainer := rb.highlowcontainer.getContainer(containerKey)\n\t\t// if containerKey > originalKey then we are past the container which mapped to the original key\n\t\t// in that case we can just return the minimum from that container\n\t\tvar responseBit int\n\t\tif containerKey < originalKey {\n\t\t\tbit, err := container.safeMaximum()\n\n\t\t\tif err == nil {\n\t\t\t\tresponseBit = -1\n\t\t\t}\n\t\t\tresponseBit = int(bit)\n\t\t} else {\n\t\t\tresponseBit = container.previousValue(query)\n\t\t}\n\n\t\tif responseBit == -1 {\n\t\t\tprevValue = -1\n\t\t} else {\n\t\t\tprevValue = int64(combineLoHi32(uint32(responseBit), uint32(containerKey)))\n\t\t}\n\t\tcontainerIndex--\n\t}\n\n\treturn prevValue\n}\n\n// NextAbsentValue returns the next largest missing value in the bitmap, or -1\n// if none is present. This function should not be used inside\n// a performance-sensitive loop: prefer iterators if\n// performance is a concern.\nfunc (rb *Bitmap) NextAbsentValue(target uint32) int64 {\n\toriginalKey := highbits(target)\n\tquery := lowbits(target)\n\tvar nextValue int64\n\tnextValue = -1\n\n\tcontainerIndex := rb.highlowcontainer.advanceUntil(originalKey, -1)\n\tif containerIndex == rb.highlowcontainer.size() {\n\t\t// if we are here it means no container found, just return the target\n\t\treturn int64(target)\n\t}\n\n\tcontainerKey := rb.highlowcontainer.getKeyAtIndex(containerIndex)\n\n\tkeyspace := uint32(containerKey) << 16\n\tif target < keyspace {\n\t\t// target is less than the start of the keyspace start\n\t\t// that means target cannot be in the keyspace\n\t\treturn int64(target)\n\t}\n\n\tcontainer := rb.highlowcontainer.getContainer(containerKey)\n\tnextValue = int64(container.nextAbsentValue(query))\n\tfor {\n\t\tif nextValue != (1 << 16) {\n\t\t\treturn int64(combineLoHi32(uint32(nextValue), keyspace))\n\t\t}\n\n\t\tif containerIndex == rb.highlowcontainer.size()-1 {\n\t\t\tval, err := container.safeMaximum()\n\t\t\tif err == nil {\n\t\t\t\treturn -1\n\t\t\t}\n\t\t\treturn int64(val) + 1\n\t\t}\n\t\tcontainerIndex++\n\t\tnextContainerKey := rb.highlowcontainer.getKeyAtIndex(containerIndex)\n\t\tif containerKey < nextContainerKey {\n\t\t\t// There is a gap between keys\n\t\t\t// Just increment the current key and shift to get HoB\n\t\t\treturn int64(containerKey+1) << 16\n\t\t}\n\t\tcontainerKey = nextContainerKey\n\t\tcontainer = rb.highlowcontainer.getContainer(containerKey)\n\t\tnextValue = int64(container.nextAbsentValue(0))\n\t}\n}\n\n// PreviousAbsentValue returns the previous largest missing value in the bitmap, or -1\n// if none is present. This function should not be used inside\n// a performance-sensitive loop: prefer iterators if\n// performance is a concern.\nfunc (rb *Bitmap) PreviousAbsentValue(target uint32) int64 {\n\toriginalKey := highbits(target)\n\tquery := lowbits(target)\n\tvar prevValue int64\n\tprevValue = -1\n\n\tcontainerIndex := rb.highlowcontainer.advanceUntil(originalKey, -1)\n\n\tif containerIndex == rb.highlowcontainer.size() {\n\t\t// if we are here it means no container found, just return the target\n\t\treturn int64(target)\n\t}\n\n\tif containerIndex == -1 {\n\t\t// if we are here it means no container found, just return the target\n\t\treturn int64(target)\n\t}\n\n\tcontainerKey := rb.highlowcontainer.getKeyAtIndex(containerIndex)\n\tkeyspace := uint32(containerKey) << 16\n\tif target < keyspace {\n\t\t// target is less than the start of the keyspace start\n\t\t// that means target cannot be in the keyspace\n\t\treturn int64(target)\n\t}\n\n\tcontainer := rb.highlowcontainer.getContainer(containerKey)\n\tprevValue = int64(container.previousAbsentValue(query))\n\tfor {\n\t\tif prevValue != -1 {\n\t\t\treturn int64(combineLoHi32(uint32(prevValue), keyspace))\n\t\t}\n\n\t\tif containerIndex == 0 {\n\t\t\tval, err := container.safeMinimum()\n\t\t\tif err == nil {\n\t\t\t\t// OR panic, Java panics\n\t\t\t\treturn -1\n\t\t\t}\n\t\t\treturn int64(val) - 1\n\t\t}\n\t\tcontainerIndex--\n\t\tnextContainerKey := rb.highlowcontainer.getKeyAtIndex(containerIndex)\n\t\tif nextContainerKey < containerKey-1 {\n\t\t\t// There is a gap between keys, eg missing container\n\t\t\t// Just decrement the current key and shift to get HoB of the missing container\n\t\t\treturn (int64(containerKey) << 16) - 1\n\t\t}\n\t\tcontainerKey = nextContainerKey\n\t\tcontainer = rb.highlowcontainer.getContainer(containerKey)\n\t\thighestPossible16 := (1 << 16) - 1\n\t\tprevValue = int64(container.previousAbsentValue(uint16(highestPossible16)))\n\t}\n}\n\n// FlipInt calls Flip after casting the parameters (convenience method)\nfunc FlipInt(bm *Bitmap, rangeStart, rangeEnd int) *Bitmap {\n\treturn Flip(bm, uint64(rangeStart), uint64(rangeEnd))\n}\n\n// Statistics provides details on the container types in use.\ntype Statistics struct {\n\tCardinality uint64\n\tContainers  uint64\n\n\tArrayContainers      uint64\n\tArrayContainerBytes  uint64\n\tArrayContainerValues uint64\n\n\tBitmapContainers      uint64\n\tBitmapContainerBytes  uint64\n\tBitmapContainerValues uint64\n\n\tRunContainers      uint64\n\tRunContainerBytes  uint64\n\tRunContainerValues uint64\n}\n\n// Stats returns details on container type usage in a Statistics struct.\nfunc (rb *Bitmap) Stats() Statistics {\n\tstats := Statistics{}\n\tstats.Containers = uint64(len(rb.highlowcontainer.containers))\n\tfor _, c := range rb.highlowcontainer.containers {\n\t\tstats.Cardinality += uint64(c.getCardinality())\n\n\t\tswitch c.(type) {\n\t\tcase *arrayContainer:\n\t\t\tstats.ArrayContainers++\n\t\t\tstats.ArrayContainerBytes += uint64(c.getSizeInBytes())\n\t\t\tstats.ArrayContainerValues += uint64(c.getCardinality())\n\t\tcase *bitmapContainer:\n\t\t\tstats.BitmapContainers++\n\t\t\tstats.BitmapContainerBytes += uint64(c.getSizeInBytes())\n\t\t\tstats.BitmapContainerValues += uint64(c.getCardinality())\n\t\tcase *runContainer16:\n\t\t\tstats.RunContainers++\n\t\t\tstats.RunContainerBytes += uint64(c.getSizeInBytes())\n\t\t\tstats.RunContainerValues += uint64(c.getCardinality())\n\t\t}\n\t}\n\treturn stats\n}\n\nfunc (rb *Bitmap) Validate() error {\n\treturn rb.highlowcontainer.validate()\n}\n"
        },
        {
          "name": "roaring64",
          "type": "tree",
          "content": null
        },
        {
          "name": "roaring_test.go",
          "type": "blob",
          "size": 73.271484375,
          "content": "package roaring\n\nimport (\n\t\"bytes\"\n\t\"fmt\"\n\t\"math\"\n\t\"math/rand\"\n\t\"strconv\"\n\t\"testing\"\n\n\t\"github.com/bits-and-blooms/bitset\"\n\t\"github.com/stretchr/testify/assert\"\n\t\"github.com/stretchr/testify/require\"\n)\n\nfunc TestIssue440(t *testing.T) {\n\ta := NewBitmap()\n\ta.AddMany([]uint32{1, 2, 3})\n\ta.RunOptimize()\n\tb1, err := a.MarshalBinary()\n\trequire.NoError(t, err)\n\ta.RunOptimize()\n\tb2, err := a.MarshalBinary()\n\trequire.NoError(t, err)\n\trequire.Equal(t, b1, b2)\n}\n\nfunc TestIssue440_2(t *testing.T) {\n\ta := NewBitmap()\n\ta.AddMany([]uint32{1, 2, 3, 4})\n\ta.RunOptimize()\n\tb1, err := a.MarshalBinary()\n\trequire.NoError(t, err)\n\ta.RunOptimize()\n\tb2, err := a.MarshalBinary()\n\trequire.NoError(t, err)\n\trequire.Equal(t, b1, b2)\n}\n\nfunc TestIssue440_3(t *testing.T) {\n\ta := NewBitmap()\n\ta.AddMany([]uint32{1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13})\n\ta.RunOptimize()\n\tb1, err := a.MarshalBinary()\n\trequire.NoError(t, err)\n\ta.RunOptimize()\n\tb2, err := a.MarshalBinary()\n\trequire.NoError(t, err)\n\trequire.Equal(t, b1, b2)\n}\n\nfunc TestIssue440_4(t *testing.T) {\n\ta := NewBitmap()\n\ta.AddMany([]uint32{1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13})\n\ta.RunOptimize()\n\tb1, err := a.MarshalBinary()\n\trequire.NoError(t, err)\n\ta.RunOptimize()\n\tb2, err := a.MarshalBinary()\n\trequire.NoError(t, err)\n\trequire.Equal(t, b1, b2)\n}\n\nfunc TestIssue440_5(t *testing.T) {\n\ta := NewBitmap()\n\ta.AddMany([]uint32{1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14})\n\ta.RunOptimize()\n\tb1, err := a.MarshalBinary()\n\trequire.NoError(t, err)\n\ta.RunOptimize()\n\tb2, err := a.MarshalBinary()\n\trequire.NoError(t, err)\n\trequire.Equal(t, b1, b2)\n}\n\nfunc checkValidity(t *testing.T, rb *Bitmap) {\n\tt.Helper()\n\n\tfor _, c := range rb.highlowcontainer.containers {\n\t\tswitch c.(type) {\n\t\tcase *arrayContainer:\n\t\t\tif c.getCardinality() > arrayDefaultMaxSize {\n\t\t\t\tt.Error(\"Array containers are limited to size \", arrayDefaultMaxSize)\n\t\t\t}\n\t\tcase *bitmapContainer:\n\t\t\tif c.getCardinality() <= arrayDefaultMaxSize {\n\t\t\t\tt.Error(\"Bitmaps would be more concise as an array!\")\n\t\t\t}\n\t\tcase *runContainer16:\n\t\t\tif c.getSizeInBytes() > minOfInt(bitmapContainerSizeInBytes(), arrayContainerSizeInBytes(c.getCardinality())) {\n\t\t\t\tt.Error(\"Inefficient run container!\")\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc hashTest(t *testing.T, N uint64) {\n\thashes := map[uint64]struct{}{}\n\tcount := 0\n\n\tfor gap := uint64(1); gap <= 65536; gap *= 2 {\n\t\trb1, rb2 := NewBitmap(), NewBitmap()\n\t\tfor x := uint64(0); x <= N*gap; x += gap {\n\t\t\trb1.AddInt(int(x))\n\t\t\trb2.AddInt(int(x))\n\t\t}\n\n\t\tassert.EqualValues(t, rb1.Checksum(), rb2.Checksum())\n\t\tcount++\n\t\thashes[rb1.Checksum()] = struct{}{}\n\n\t\trb1, rb2 = NewBitmap(), NewBitmap()\n\t\tfor x := uint64(0); x <= N*gap; x += gap {\n\t\t\t// x+3 guarantees runs, gap/2 guarantees some variety\n\t\t\tif x+3+gap/2 > MaxUint32 {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\trb1.AddRange(uint64(x), uint64(x+3+gap/2))\n\t\t\trb2.AddRange(uint64(x), uint64(x+3+gap/2))\n\t\t}\n\n\t\trb1.RunOptimize()\n\t\trb2.RunOptimize()\n\n\t\tassert.EqualValues(t, rb1.Checksum(), rb2.Checksum())\n\t\tcount++\n\t\thashes[rb1.Checksum()] = struct{}{}\n\t}\n\n\t// Make sure that at least for this reduced set we have no collisions.\n\tassert.Equal(t, count, len(hashes))\n}\n\nfunc buildRuns(includeBroken bool) *runContainer16 {\n\trc := &runContainer16{}\n\tif includeBroken {\n\t\tfor i := 0; i < 100; i++ {\n\t\t\tstart := i * 100\n\t\t\tend := start + 100\n\t\t\trc.iv = append(rc.iv, newInterval16Range(uint16(start), uint16(end)))\n\t\t}\n\t}\n\n\tfor i := 0; i < 100; i++ {\n\t\tstart := i*100 + i*2\n\t\tend := start + 100\n\t\trc.iv = append(rc.iv, newInterval16Range(uint16(start), uint16(end)))\n\t}\n\n\treturn rc\n}\n\nfunc TestReverseIteratorCount(t *testing.T) {\n\tarray := []int{2, 63, 64, 65, 4095, 4096, 4097, 4159, 4160, 4161, 5000, 20000, 66666}\n\tfor _, testSize := range array {\n\t\tb := New()\n\t\tfor i := uint32(0); i < uint32(testSize); i++ {\n\t\t\tb.Add(i)\n\t\t}\n\t\tit := b.ReverseIterator()\n\t\tcount := 0\n\t\tfor it.HasNext() {\n\t\t\tit.Next()\n\t\t\tcount++\n\t\t}\n\n\t\tassert.Equal(t, testSize, count)\n\t}\n}\n\nfunc TestRoaringIntervalCheck(t *testing.T) {\n\tr := BitmapOf(1, 2, 3, 1000)\n\trangeb := New()\n\trangeb.AddRange(10, 1000+1)\n\n\tassert.True(t, r.Intersects(rangeb))\n\n\trangeb2 := New()\n\trangeb2.AddRange(10, 1000)\n\n\tassert.False(t, r.Intersects(rangeb2))\n}\n\nfunc TestRoaringRangeEnd(t *testing.T) {\n\tr := New()\n\tr.Add(MaxUint32)\n\tassert.EqualValues(t, 1, r.GetCardinality())\n\n\tr.RemoveRange(0, MaxUint32)\n\tassert.EqualValues(t, 1, r.GetCardinality())\n\n\tr.RemoveRange(0, math.MaxUint64)\n\tassert.EqualValues(t, 0, r.GetCardinality())\n\n\tr.Add(MaxUint32)\n\tassert.EqualValues(t, 1, r.GetCardinality())\n\n\tr.RemoveRange(0, 0x100000001)\n\tassert.EqualValues(t, 0, r.GetCardinality())\n\n\tr.Add(MaxUint32)\n\tassert.EqualValues(t, 1, r.GetCardinality())\n\n\tr.RemoveRange(0, 0x100000000)\n\tassert.EqualValues(t, 0, r.GetCardinality())\n}\n\nfunc TestMaxPanic(t *testing.T) {\n\tdefer func() {\n\t\tif r := recover(); r != nil {\n\t\t}\n\t}()\n\tbm := New()\n\tbm.Maximum()\n\tt.Errorf(\"The code did not panic\")\n}\n\nfunc TestMinPanic(t *testing.T) {\n\tdefer func() {\n\t\tif r := recover(); r != nil {\n\t\t}\n\t}()\n\tbm := New()\n\tbm.Minimum()\n\tt.Errorf(\"The code did not panic\")\n}\n\nfunc TestFirstLast(t *testing.T) {\n\tbm := New()\n\tbm.AddInt(2)\n\tbm.AddInt(4)\n\tbm.AddInt(8)\n\n\tassert.EqualValues(t, 2, bm.Minimum())\n\tassert.EqualValues(t, 8, bm.Maximum())\n\n\ti := 1 << 5\n\n\tfor ; i < (1 << 17); i++ {\n\t\tbm.AddInt(i)\n\n\t\tassert.EqualValues(t, 2, bm.Minimum())\n\t\tassert.EqualValues(t, i, bm.Maximum())\n\t}\n\n\tbm.RunOptimize()\n\n\tassert.EqualValues(t, 2, bm.Minimum())\n\tassert.EqualValues(t, i-1, bm.Maximum())\n}\n\nfunc TestRoaringBitmapBitmapOf(t *testing.T) {\n\tarray := []uint32{5580, 33722, 44031, 57276, 83097}\n\tbmp := BitmapOf(array...)\n\n\tassert.EqualValues(t, len(array), bmp.GetCardinality())\n\n\tby, _ := bmp.ToBytes()\n\n\tassert.EqualValues(t, len(by), bmp.GetSerializedSizeInBytes())\n}\n\nfunc TestRoaringBitmapAdd(t *testing.T) {\n\tarray := []uint32{5580, 33722, 44031, 57276, 83097}\n\tbmp := New()\n\tfor _, v := range array {\n\t\tbmp.Add(v)\n\t}\n\n\tassert.EqualValues(t, len(array), bmp.GetCardinality())\n}\n\nfunc TestRoaringBitmapAddMany(t *testing.T) {\n\tarray := []uint32{5580, 33722, 44031, 57276, 83097}\n\tbmp := NewBitmap()\n\tbmp.AddMany(array)\n\n\tassert.EqualValues(t, len(array), bmp.GetCardinality())\n}\n\nfunc testAddOffset(t *testing.T, arr []uint32, offset int64) {\n\texpected := make([]uint32, 0, len(arr))\n\tfor _, i := range arr {\n\t\tv := int64(i) + offset\n\t\tif v >= 0 && v <= MaxUint32 {\n\t\t\texpected = append(expected, uint32(v))\n\t\t}\n\t}\n\n\tbmp := NewBitmap()\n\tbmp.AddMany(arr)\n\n\tcop := AddOffset64(bmp, offset)\n\n\tif !assert.EqualValues(t, len(expected), cop.GetCardinality()) {\n\t\tt.Logf(\"Applying offset %d\", offset)\n\t}\n\tif !assert.EqualValues(t, expected, cop.ToArray()) {\n\t\tt.Logf(\"Applying offset %d\", offset)\n\t}\n\n\t// Now check backing off gets us back all non-discarded numbers\n\texpected2 := make([]uint32, 0, len(expected))\n\tfor _, i := range expected {\n\t\tv := int64(i) - offset\n\t\tif v >= 0 && v <= MaxUint32 {\n\t\t\texpected2 = append(expected2, uint32(v))\n\t\t}\n\t}\n\n\tcop2 := AddOffset64(cop, -offset)\n\n\tif !assert.EqualValues(t, len(expected2), cop2.GetCardinality()) {\n\t\tt.Logf(\"Restoring from offset %d\", offset)\n\t}\n\tif !assert.EqualValues(t, expected2, cop2.ToArray()) {\n\t\tt.Logf(\"Restoring from offset %d\", offset)\n\t}\n}\n\nfunc TestRoaringBitmapAddOffset(t *testing.T) {\n\ttype testCase struct {\n\t\tarr    []uint32\n\t\toffset int64\n\t}\n\tcases := []testCase{\n\t\t{\n\t\t\tarr:    []uint32{5580, 33722, 44031, 57276, 83097},\n\t\t\toffset: 25000,\n\t\t},\n\t\t{\n\t\t\tarr:    []uint32{5580, 33722, 44031, 57276, 83097},\n\t\t\toffset: -25000,\n\t\t},\n\t\t{\n\t\t\tarr:    []uint32{5580, 33722, 44031, 57276, 83097},\n\t\t\toffset: -83097,\n\t\t},\n\t\t{\n\t\t\tarr:    []uint32{5580, 33722, 44031, 57276, 83097},\n\t\t\toffset: MaxUint32,\n\t\t},\n\t\t{\n\t\t\tarr:    []uint32{5580, 33722, 44031, 57276, 83097},\n\t\t\toffset: -MaxUint32,\n\t\t},\n\t\t{\n\t\t\tarr:    []uint32{5580, 33722, 44031, 57276, 83097},\n\t\t\toffset: 0,\n\t\t},\n\t\t{\n\t\t\tarr:    []uint32{0},\n\t\t\toffset: 100,\n\t\t},\n\t\t{\n\t\t\tarr:    []uint32{0},\n\t\t\toffset: 0xffff0000,\n\t\t},\n\t\t{\n\t\t\tarr:    []uint32{0},\n\t\t\toffset: 0xffff0001,\n\t\t},\n\t}\n\n\tarr := []uint32{10, 0xffff, 0x010101}\n\tfor i := uint32(100000); i < 200000; i += 4 {\n\t\tarr = append(arr, i)\n\t}\n\tarr = append(arr, 400000)\n\tarr = append(arr, 1400000)\n\tfor offset := int64(3); offset < 1000000; offset *= 3 {\n\t\tc := testCase{arr, offset}\n\t\tcases = append(cases, c)\n\t}\n\tfor offset := int64(1024); offset < 1000000; offset *= 2 {\n\t\tc := testCase{arr, offset}\n\t\tcases = append(cases, c)\n\t}\n\n\tfor _, c := range cases {\n\t\t// Positive offset\n\t\ttestAddOffset(t, c.arr, c.offset)\n\t\t// Negative offset\n\t\ttestAddOffset(t, c.arr, -c.offset)\n\t}\n}\n\nfunc TestRoaringInPlaceAndNotBitmapContainer(t *testing.T) {\n\tbm := NewBitmap()\n\tfor i := 0; i < 8192; i++ {\n\t\tbm.Add(uint32(i))\n\t}\n\ttoRemove := NewBitmap()\n\tfor i := 128; i < 8192; i++ {\n\t\ttoRemove.Add(uint32(i))\n\t}\n\tbm.AndNot(toRemove)\n\n\tvar b bytes.Buffer\n\t_, err := bm.WriteTo(&b)\n\n\trequire.NoError(t, err)\n\n\tbm2 := NewBitmap()\n\tbm2.ReadFrom(bytes.NewBuffer(b.Bytes()))\n\n\tassert.True(t, bm2.Equals(bm))\n}\n\n// https://github.com/RoaringBitmap/roaring/issues/64\nfunc TestFlip64(t *testing.T) {\n\tbm := New()\n\tbm.AddInt(0)\n\tbm.Flip(1, 2)\n\ti := bm.Iterator()\n\n\tassert.False(t, i.Next() != 0 || i.Next() != 1 || i.HasNext())\n}\n\n// https://github.com/RoaringBitmap/roaring/issues/64\nfunc TestFlip64Off(t *testing.T) {\n\tbm := New()\n\tbm.AddInt(10)\n\tbm.Flip(11, 12)\n\ti := bm.Iterator()\n\n\tassert.False(t, i.Next() != 10 || i.Next() != 11 || i.HasNext())\n}\n\nfunc TestStringer(t *testing.T) {\n\tv := NewBitmap()\n\tfor i := uint32(0); i < 10; i++ {\n\t\tv.Add(i)\n\t}\n\n\tassert.Equal(t, \"{0,1,2,3,4,5,6,7,8,9}\", v.String())\n\n\tv.RunOptimize()\n\n\tassert.Equal(t, \"{0,1,2,3,4,5,6,7,8,9}\", v.String())\n}\n\nfunc TestFastCard(t *testing.T) {\n\tbm := NewBitmap()\n\tbm.Add(1)\n\tbm.AddRange(21, 260000)\n\tbm2 := NewBitmap()\n\tbm2.Add(25)\n\n\tassert.EqualValues(t, 1, bm2.AndCardinality(bm))\n\tassert.Equal(t, bm.GetCardinality(), bm2.OrCardinality(bm))\n\tassert.EqualValues(t, 1, bm.AndCardinality(bm2))\n\tassert.Equal(t, bm.GetCardinality(), bm.OrCardinality(bm2))\n\tassert.EqualValues(t, 1, bm2.AndCardinality(bm))\n\tassert.Equal(t, bm.GetCardinality(), bm2.OrCardinality(bm))\n\n\tbm.RunOptimize()\n\n\tassert.EqualValues(t, 1, bm2.AndCardinality(bm))\n\tassert.Equal(t, bm.GetCardinality(), bm2.OrCardinality(bm))\n\tassert.EqualValues(t, 1, bm.AndCardinality(bm2))\n\tassert.Equal(t, bm.GetCardinality(), bm.OrCardinality(bm2))\n\tassert.EqualValues(t, 1, bm2.AndCardinality(bm))\n\tassert.Equal(t, bm.GetCardinality(), bm2.OrCardinality(bm))\n}\n\nfunc TestFastCardUnequalKeys(t *testing.T) {\n\t// These tests will excercise the interior code branches of OrCardinality\n\n\tt.Run(\"Merge small into large\", func(t *testing.T) {\n\t\tbm := NewBitmap()\n\t\tbm.AddRange(0, 1024)\n\t\tbm2 := NewBitmap()\n\t\tstart := uint64(2 << 16)\n\t\tbm2.AddRange(start, start+3)\n\n\t\tassert.Equal(t, uint64(1027), bm2.OrCardinality(bm))\n\t})\n\tt.Run(\"Merge large into small\", func(t *testing.T) {\n\t\tbm := NewBitmap()\n\t\tbm.AddRange(0, 1024)\n\t\tbm2 := NewBitmap()\n\t\tstart := uint64(2 << 16)\n\t\tbm2.AddRange(start, start+3)\n\n\t\tassert.Equal(t, uint64(1027), bm.OrCardinality(bm2))\n\t})\n\n\tt.Run(\"Merge large into small same keyrange start\", func(t *testing.T) {\n\t\tbm := NewBitmap()\n\t\tstart := uint64(2 << 16)\n\t\tbm.AddRange(0, 1024)\n\t\tbm.AddRange(start, start+3)\n\n\t\tbm2 := NewBitmap()\n\t\tbm2.AddRange(0, 512)\n\t\tbm2.AddRange(start, start+3)\n\n\t\tassert.Equal(t, uint64(1027), bm.OrCardinality(bm2))\n\t})\n}\n\nfunc TestIntersects1(t *testing.T) {\n\tbm := NewBitmap()\n\tbm.Add(1)\n\tbm.AddRange(21, 26)\n\tbm2 := NewBitmap()\n\tbm2.Add(25)\n\n\tassert.True(t, bm2.Intersects(bm))\n\n\tbm.Remove(25)\n\tassert.Equal(t, false, bm2.Intersects(bm))\n\n\tbm.AddRange(1, 100000)\n\tassert.True(t, bm2.Intersects(bm))\n}\n\nfunc TestIntersectsWithInterval(t *testing.T) {\n\tbm := NewBitmap()\n\tbm.AddRange(21, 26)\n\n\t// Empty interval in range\n\tassert.False(t, bm.IntersectsWithInterval(22, 22))\n\t// Empty interval out of range\n\tassert.False(t, bm.IntersectsWithInterval(27, 27))\n\n\t// Non-empty interval in range, fully included\n\tassert.True(t, bm.IntersectsWithInterval(22, 23))\n\t// Non-empty intervals partially overlapped\n\tassert.True(t, bm.IntersectsWithInterval(19, 23))\n\tassert.True(t, bm.IntersectsWithInterval(23, 30))\n\t// Non-empty interval covering the full range\n\tassert.True(t, bm.IntersectsWithInterval(19, 30))\n\n\t// Non-empty interval before start of bitmap\n\tassert.False(t, bm.IntersectsWithInterval(19, 20))\n\t// Non-empty interval after end of bitmap\n\tassert.False(t, bm.IntersectsWithInterval(28, 30))\n\n\t// Non-empty interval inside \"hole\" in bitmap\n\tbm.AddRange(30, 40)\n\tassert.False(t, bm.IntersectsWithInterval(28, 29))\n\n\t// Non-empty interval, non-overlapping on the open side\n\tassert.False(t, bm.IntersectsWithInterval(28, 30))\n\t// Non-empty interval, overlapping on the open side\n\tassert.True(t, bm.IntersectsWithInterval(28, 31))\n}\n\nfunc TestRangePanic(t *testing.T) {\n\tbm := NewBitmap()\n\tbm.Add(1)\n\tbm.AddRange(21, 26)\n\tbm.AddRange(9, 14)\n\tbm.AddRange(11, 16)\n}\n\nfunc TestRangeRemoval(t *testing.T) {\n\tbm := NewBitmap()\n\tbm.Add(1)\n\tbm.AddRange(21, 26)\n\tbm.AddRange(9, 14)\n\tbm.RemoveRange(11, 16)\n\tbm.RemoveRange(1, 26)\n\tc := bm.GetCardinality()\n\n\tassert.EqualValues(t, 0, c)\n\n\tbm.AddRange(1, 10000)\n\tc = bm.GetCardinality()\n\n\tassert.EqualValues(t, 10000-1, c)\n\n\tbm.RemoveRange(1, 10000)\n\tc = bm.GetCardinality()\n\n\tassert.EqualValues(t, 0, c)\n}\n\nfunc TestRangeRemovalFromContent(t *testing.T) {\n\tbm := NewBitmap()\n\tfor i := 100; i < 10000; i++ {\n\t\tbm.AddInt(i * 3)\n\t}\n\tbm.AddRange(21, 26)\n\tbm.AddRange(9, 14)\n\tbm.RemoveRange(11, 16)\n\tbm.RemoveRange(0, 30000)\n\tc := bm.GetCardinality()\n\n\tassert.EqualValues(t, 0o0, c)\n}\n\nfunc TestFlipOnEmpty(t *testing.T) {\n\tt.Run(\"TestFlipOnEmpty in-place\", func(t *testing.T) {\n\t\tbm := NewBitmap()\n\t\tbm.Flip(0, 10)\n\t\tc := bm.GetCardinality()\n\n\t\tassert.EqualValues(t, 10, c)\n\t})\n\n\tt.Run(\"TestFlipOnEmpty, generating new result\", func(t *testing.T) {\n\t\tbm := NewBitmap()\n\t\tbm = Flip(bm, 0, 10)\n\t\tc := bm.GetCardinality()\n\n\t\tassert.EqualValues(t, 10, c)\n\t})\n}\n\nfunc TestBitmapRank2(t *testing.T) {\n\tr := NewBitmap()\n\tfor i := uint32(1); i < 8194; i += 2 {\n\t\tr.Add(i)\n\t}\n\n\trank := r.Rank(63)\n\tassert.EqualValues(t, 32, rank)\n}\n\nfunc TestBitmapRank(t *testing.T) {\n\tfor N := uint32(1); N <= 1048576; N *= 2 {\n\t\tt.Run(\"rank tests\"+strconv.Itoa(int(N)), func(t *testing.T) {\n\t\t\tfor gap := uint32(1); gap <= 65536; gap *= 2 {\n\t\t\t\trb1 := NewBitmap()\n\t\t\t\tfor x := uint32(0); x <= N; x += gap {\n\t\t\t\t\trb1.Add(x)\n\t\t\t\t}\n\t\t\t\tfor y := uint32(0); y <= N; y++ {\n\t\t\t\t\tif rb1.Rank(y) != uint64((y+1+gap-1)/gap) {\n\t\t\t\t\t\tassert.Equal(t, (y+1+gap-1)/gap, rb1.Rank(y))\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestBitmapSelect(t *testing.T) {\n\tfor N := uint32(1); N <= 1048576; N *= 2 {\n\t\tt.Run(\"rank tests\"+strconv.Itoa(int(N)), func(t *testing.T) {\n\t\t\tfor gap := uint32(1); gap <= 65536; gap *= 2 {\n\t\t\t\trb1 := NewBitmap()\n\t\t\t\tfor x := uint32(0); x <= N; x += gap {\n\t\t\t\t\trb1.Add(x)\n\t\t\t\t}\n\t\t\t\tfor y := uint32(0); y <= N/gap; y++ {\n\t\t\t\t\texpectedInt := y * gap\n\t\t\t\t\ti, err := rb1.Select(y)\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\tt.Fatal(err)\n\t\t\t\t\t}\n\n\t\t\t\t\tif i != expectedInt {\n\t\t\t\t\t\tassert.Equal(t, expectedInt, i)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}\n\n// some extra tests\nfunc TestBitmapExtra(t *testing.T) {\n\tfor N := uint32(1); N <= 65536; N *= 2 {\n\t\tt.Run(\"extra tests\"+strconv.Itoa(int(N)), func(t *testing.T) {\n\t\t\tfor gap := uint32(1); gap <= 65536; gap *= 2 {\n\t\t\t\tbs1 := bitset.New(0)\n\t\t\t\trb1 := NewBitmap()\n\t\t\t\tfor x := uint32(0); x <= N; x += gap {\n\t\t\t\t\tbs1.Set(uint(x))\n\t\t\t\t\trb1.Add(x)\n\t\t\t\t}\n\n\t\t\t\tassert.EqualValues(t, rb1.GetCardinality(), bs1.Count())\n\t\t\t\tassert.True(t, equalsBitSet(bs1, rb1))\n\n\t\t\t\tfor offset := uint32(1); offset <= gap; offset *= 2 {\n\t\t\t\t\tbs2 := bitset.New(0)\n\t\t\t\t\trb2 := NewBitmap()\n\t\t\t\t\tfor x := uint32(0); x <= N; x += gap {\n\t\t\t\t\t\tbs2.Set(uint(x + offset))\n\t\t\t\t\t\trb2.Add(x + offset)\n\t\t\t\t\t}\n\n\t\t\t\t\tassert.EqualValues(t, rb2.GetCardinality(), bs2.Count())\n\t\t\t\t\tassert.True(t, equalsBitSet(bs2, rb2))\n\n\t\t\t\t\tclonebs1 := bs1.Clone()\n\t\t\t\t\tclonebs1.InPlaceIntersection(bs2)\n\n\t\t\t\t\tif !equalsBitSet(clonebs1, And(rb1, rb2)) {\n\t\t\t\t\t\tv := rb1.Clone()\n\t\t\t\t\t\tv.And(rb2)\n\n\t\t\t\t\t\tassert.True(t, equalsBitSet(clonebs1, v))\n\t\t\t\t\t}\n\n\t\t\t\t\t// testing OR\n\t\t\t\t\tclonebs1 = bs1.Clone()\n\t\t\t\t\tclonebs1.InPlaceUnion(bs2)\n\n\t\t\t\t\tassert.True(t, equalsBitSet(clonebs1, Or(rb1, rb2)))\n\t\t\t\t\t// testing XOR\n\t\t\t\t\tclonebs1 = bs1.Clone()\n\t\t\t\t\tclonebs1.InPlaceSymmetricDifference(bs2)\n\t\t\t\t\tassert.True(t, equalsBitSet(clonebs1, Xor(rb1, rb2)))\n\n\t\t\t\t\t// testing NOTAND\n\t\t\t\t\tclonebs1 = bs1.Clone()\n\t\t\t\t\tclonebs1.InPlaceDifference(bs2)\n\t\t\t\t\tassert.True(t, equalsBitSet(clonebs1, AndNot(rb1, rb2)))\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc FlipRange(start, end int, bs *bitset.BitSet) {\n\tfor i := start; i < end; i++ {\n\t\tbs.Flip(uint(i))\n\t}\n}\n\nfunc TestBitmap(t *testing.T) {\n\tt.Run(\"Test Contains\", func(t *testing.T) {\n\t\trbm1 := NewBitmap()\n\t\tfor k := 0; k < 1000; k++ {\n\t\t\trbm1.AddInt(17 * k)\n\t\t}\n\n\t\tfor k := 0; k < 17*1000; k++ {\n\t\t\tassert.Equal(t, (k/17*17 == k), rbm1.ContainsInt(k))\n\t\t}\n\t})\n\n\tt.Run(\"Test Clone\", func(t *testing.T) {\n\t\trb1 := NewBitmap()\n\t\trb1.Add(10)\n\n\t\trb2 := rb1.Clone()\n\t\trb2.Remove(10)\n\n\t\tassert.True(t, rb1.Contains(10))\n\t})\n\n\tt.Run(\"Test run array not equal\", func(t *testing.T) {\n\t\trb := NewBitmap()\n\t\trb2 := NewBitmap()\n\t\trb.AddRange(0, 1<<16)\n\t\tfor i := 0; i < 10; i++ {\n\t\t\trb2.AddInt(i)\n\t\t}\n\n\t\tassert.EqualValues(t, 1<<16, rb.GetCardinality())\n\t\tassert.EqualValues(t, 10, rb2.GetCardinality())\n\t\tassert.False(t, rb.Equals(rb2))\n\n\t\trb.RunOptimize()\n\t\trb2.RunOptimize()\n\n\t\tassert.EqualValues(t, 1<<16, rb.GetCardinality())\n\t\tassert.EqualValues(t, 10, rb2.GetCardinality())\n\t\tassert.False(t, rb.Equals(rb2))\n\t})\n\n\tt.Run(\"Test ANDNOT4\", func(t *testing.T) {\n\t\trb := NewBitmap()\n\t\trb2 := NewBitmap()\n\n\t\tfor i := 0; i < 200000; i += 4 {\n\t\t\trb2.AddInt(i)\n\t\t}\n\t\tfor i := 200000; i < 400000; i += 14 {\n\t\t\trb2.AddInt(i)\n\t\t}\n\n\t\toff := AndNot(rb2, rb)\n\t\tandNotresult := AndNot(rb, rb2)\n\n\t\tassert.True(t, rb.Equals(andNotresult))\n\t\tassert.True(t, rb2.Equals(off))\n\n\t\trb2.AndNot(rb)\n\t\tassert.True(t, rb2.Equals(off))\n\t})\n\n\tt.Run(\"Test AND\", func(t *testing.T) {\n\t\trr := NewBitmap()\n\t\tfor k := 0; k < 4000; k++ {\n\t\t\trr.AddInt(k)\n\t\t}\n\t\trr.Add(100000)\n\t\trr.Add(110000)\n\t\trr2 := NewBitmap()\n\t\trr2.Add(13)\n\t\trrand := And(rr, rr2)\n\t\tarray := rrand.ToArray()\n\n\t\tassert.Equal(t, 1, len(array))\n\t\tassert.EqualValues(t, 13, array[0])\n\n\t\trr.And(rr2)\n\t\tarray = rr.ToArray()\n\n\t\tassert.Equal(t, 1, len(array))\n\t\tassert.EqualValues(t, 13, array[0])\n\t})\n\n\tt.Run(\"Test AND 2\", func(t *testing.T) {\n\t\trr := NewBitmap()\n\t\tfor k := 4000; k < 4256; k++ {\n\t\t\trr.AddInt(k)\n\t\t}\n\t\tfor k := 65536; k < 65536+4000; k++ {\n\t\t\trr.AddInt(k)\n\t\t}\n\t\tfor k := 3 * 65536; k < 3*65536+9000; k++ {\n\t\t\trr.AddInt(k)\n\t\t}\n\t\tfor k := 4 * 65535; k < 4*65535+7000; k++ {\n\t\t\trr.AddInt(k)\n\t\t}\n\t\tfor k := 6 * 65535; k < 6*65535+10000; k++ {\n\t\t\trr.AddInt(k)\n\t\t}\n\t\tfor k := 8 * 65535; k < 8*65535+1000; k++ {\n\t\t\trr.AddInt(k)\n\t\t}\n\t\tfor k := 9 * 65535; k < 9*65535+30000; k++ {\n\t\t\trr.AddInt(k)\n\t\t}\n\n\t\trr2 := NewBitmap()\n\t\tfor k := 4000; k < 4256; k++ {\n\t\t\trr2.AddInt(k)\n\t\t}\n\t\tfor k := 65536; k < 65536+4000; k++ {\n\t\t\trr2.AddInt(k)\n\t\t}\n\t\tfor k := 3*65536 + 2000; k < 3*65536+6000; k++ {\n\t\t\trr2.AddInt(k)\n\t\t}\n\t\tfor k := 6 * 65535; k < 6*65535+1000; k++ {\n\t\t\trr2.AddInt(k)\n\t\t}\n\t\tfor k := 7 * 65535; k < 7*65535+1000; k++ {\n\t\t\trr2.AddInt(k)\n\t\t}\n\t\tfor k := 10 * 65535; k < 10*65535+5000; k++ {\n\t\t\trr2.AddInt(k)\n\t\t}\n\t\tcorrect := And(rr, rr2)\n\t\trr.And(rr2)\n\n\t\tassert.True(t, correct.Equals(rr))\n\t})\n\n\tt.Run(\"Test AND 2\", func(t *testing.T) {\n\t\trr := NewBitmap()\n\t\tfor k := 0; k < 4000; k++ {\n\t\t\trr.AddInt(k)\n\t\t}\n\t\trr.AddInt(100000)\n\t\trr.AddInt(110000)\n\t\trr2 := NewBitmap()\n\t\trr2.AddInt(13)\n\n\t\trrand := And(rr, rr2)\n\t\tarray := rrand.ToArray()\n\n\t\tassert.Equal(t, 1, len(array))\n\t\tassert.EqualValues(t, 13, array[0])\n\t})\n\n\tt.Run(\"Test AND 3a\", func(t *testing.T) {\n\t\trr := NewBitmap()\n\t\trr2 := NewBitmap()\n\t\tfor k := 6 * 65536; k < 6*65536+10000; k++ {\n\t\t\trr.AddInt(k)\n\t\t}\n\t\tfor k := 6 * 65536; k < 6*65536+1000; k++ {\n\t\t\trr2.AddInt(k)\n\t\t}\n\t\tresult := And(rr, rr2)\n\n\t\tassert.EqualValues(t, 1000, result.GetCardinality())\n\t})\n\n\tt.Run(\"Test AND 3\", func(t *testing.T) {\n\t\tvar arrayand [11256]uint32\n\t\t// 393,216\n\t\tpos := 0\n\t\trr := NewBitmap()\n\t\tfor k := 4000; k < 4256; k++ {\n\t\t\trr.AddInt(k)\n\t\t}\n\t\tfor k := 65536; k < 65536+4000; k++ {\n\t\t\trr.AddInt(k)\n\t\t}\n\t\tfor k := 3 * 65536; k < 3*65536+1000; k++ {\n\t\t\trr.AddInt(k)\n\t\t}\n\t\tfor k := 3*65536 + 1000; k < 3*65536+7000; k++ {\n\t\t\trr.AddInt(k)\n\t\t}\n\t\tfor k := 3*65536 + 7000; k < 3*65536+9000; k++ {\n\t\t\trr.AddInt(k)\n\t\t}\n\t\tfor k := 4 * 65536; k < 4*65536+7000; k++ {\n\t\t\trr.AddInt(k)\n\t\t}\n\t\tfor k := 8 * 65536; k < 8*65536+1000; k++ {\n\t\t\trr.AddInt(k)\n\t\t}\n\t\tfor k := 9 * 65536; k < 9*65536+30000; k++ {\n\t\t\trr.AddInt(k)\n\t\t}\n\n\t\trr2 := NewBitmap()\n\t\tfor k := 4000; k < 4256; k++ {\n\t\t\trr2.AddInt(k)\n\t\t\tarrayand[pos] = uint32(k)\n\t\t\tpos++\n\t\t}\n\t\tfor k := 65536; k < 65536+4000; k++ {\n\t\t\trr2.AddInt(k)\n\t\t\tarrayand[pos] = uint32(k)\n\t\t\tpos++\n\t\t}\n\t\tfor k := 3*65536 + 1000; k < 3*65536+7000; k++ {\n\t\t\trr2.AddInt(k)\n\t\t\tarrayand[pos] = uint32(k)\n\t\t\tpos++\n\t\t}\n\t\tfor k := 6 * 65536; k < 6*65536+10000; k++ {\n\t\t\trr.AddInt(k)\n\t\t}\n\t\tfor k := 6 * 65536; k < 6*65536+1000; k++ {\n\t\t\trr2.AddInt(k)\n\t\t\tarrayand[pos] = uint32(k)\n\t\t\tpos++\n\t\t}\n\n\t\tfor k := 7 * 65536; k < 7*65536+1000; k++ {\n\t\t\trr2.AddInt(k)\n\t\t}\n\t\tfor k := 10 * 65536; k < 10*65536+5000; k++ {\n\t\t\trr2.AddInt(k)\n\t\t}\n\t\trrand := And(rr, rr2)\n\n\t\tarrayres := rrand.ToArray()\n\t\tok := true\n\t\tfor i := range arrayres {\n\t\t\tif i < len(arrayand) {\n\t\t\t\tif arrayres[i] != arrayand[i] {\n\t\t\t\t\tt.Log(i, arrayres[i], arrayand[i])\n\t\t\t\t\tok = false\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tt.Log('x', arrayres[i])\n\t\t\t\tok = false\n\t\t\t}\n\t\t}\n\n\t\tassert.Equal(t, len(arrayres), len(arrayand))\n\t\tassert.True(t, ok)\n\t})\n\n\tt.Run(\"Test AND 4\", func(t *testing.T) {\n\t\trb := NewBitmap()\n\t\trb2 := NewBitmap()\n\n\t\tfor i := 0; i < 200000; i += 4 {\n\t\t\trb2.AddInt(i)\n\t\t}\n\t\tfor i := 200000; i < 400000; i += 14 {\n\t\t\trb2.AddInt(i)\n\t\t}\n\t\t// TODO: Bitmap.And(bm,bm2)\n\t\tandresult := And(rb, rb2)\n\t\toff := And(rb2, rb)\n\n\t\tassert.True(t, andresult.Equals(off))\n\t\tassert.EqualValues(t, 0, andresult.GetCardinality())\n\n\t\tfor i := 500000; i < 600000; i += 14 {\n\t\t\trb.AddInt(i)\n\t\t}\n\t\tfor i := 200000; i < 400000; i += 3 {\n\t\t\trb2.AddInt(i)\n\t\t}\n\t\tandresult2 := And(rb, rb2)\n\n\t\tassert.EqualValues(t, 0, andresult.GetCardinality())\n\t\tassert.EqualValues(t, 0, andresult2.GetCardinality())\n\n\t\tfor i := 0; i < 200000; i += 4 {\n\t\t\trb.AddInt(i)\n\t\t}\n\t\tfor i := 200000; i < 400000; i += 14 {\n\t\t\trb.AddInt(i)\n\t\t}\n\n\t\tassert.EqualValues(t, 0, andresult.GetCardinality())\n\n\t\trc := And(rb, rb2)\n\t\trb.And(rb2)\n\n\t\tassert.Equal(t, rb.GetCardinality(), rc.GetCardinality())\n\t})\n\n\tt.Run(\"ArrayContainerCardinalityTest\", func(t *testing.T) {\n\t\tac := newArrayContainer()\n\t\tfor k := uint16(0); k < 100; k++ {\n\t\t\tac.iadd(k)\n\t\t\tassert.EqualValues(t, k+1, ac.getCardinality())\n\t\t}\n\t\tfor k := uint16(0); k < 100; k++ {\n\t\t\tac.iadd(k)\n\t\t\tassert.EqualValues(t, 100, ac.getCardinality())\n\t\t}\n\t})\n\n\tt.Run(\"or test\", func(t *testing.T) {\n\t\trr := NewBitmap()\n\t\tfor k := 0; k < 4000; k++ {\n\t\t\trr.AddInt(k)\n\t\t}\n\t\trr2 := NewBitmap()\n\t\tfor k := 4000; k < 8000; k++ {\n\t\t\trr2.AddInt(k)\n\t\t}\n\t\tresult := Or(rr, rr2)\n\n\t\tassert.Equal(t, rr.GetCardinality()+rr2.GetCardinality(), result.GetCardinality())\n\t})\n\n\tt.Run(\"basic test\", func(t *testing.T) {\n\t\trr := NewBitmap()\n\t\tvar a [4002]uint32\n\t\tpos := 0\n\t\tfor k := 0; k < 4000; k++ {\n\t\t\trr.AddInt(k)\n\t\t\ta[pos] = uint32(k)\n\t\t\tpos++\n\t\t}\n\t\trr.AddInt(100000)\n\t\ta[pos] = 100000\n\t\tpos++\n\t\trr.AddInt(110000)\n\t\ta[pos] = 110000\n\t\tpos++\n\t\tarray := rr.ToArray()\n\t\tok := true\n\t\tfor i := range a {\n\t\t\tif array[i] != a[i] {\n\t\t\t\tt.Log(\"rr : \", array[i], \" a : \", a[i])\n\t\t\t\tok = false\n\t\t\t}\n\t\t}\n\n\t\tassert.Equal(t, len(a), len(array))\n\t\tassert.True(t, ok)\n\t})\n\n\tt.Run(\"BitmapContainerCardinalityTest\", func(t *testing.T) {\n\t\tac := newBitmapContainer()\n\t\tfor k := uint16(0); k < 100; k++ {\n\t\t\tac.iadd(k)\n\t\t\tassert.EqualValues(t, k+1, ac.getCardinality())\n\t\t}\n\t\tfor k := uint16(0); k < 100; k++ {\n\t\t\tac.iadd(k)\n\t\t\tassert.EqualValues(t, 100, ac.getCardinality())\n\t\t}\n\t})\n\n\tt.Run(\"BitmapContainerTest\", func(t *testing.T) {\n\t\trr := newBitmapContainer()\n\t\trr.iadd(uint16(110))\n\t\trr.iadd(uint16(114))\n\t\trr.iadd(uint16(115))\n\t\tvar array [3]uint16\n\t\tpos := 0\n\t\tfor itr := rr.getShortIterator(); itr.hasNext(); {\n\t\t\tarray[pos] = itr.next()\n\t\t\tpos++\n\t\t}\n\n\t\tassert.EqualValues(t, 110, array[0])\n\t\tassert.EqualValues(t, 114, array[1])\n\t\tassert.EqualValues(t, 115, array[2])\n\t})\n\n\tt.Run(\"cardinality test\", func(t *testing.T) {\n\t\tN := 1024\n\t\tfor gap := 7; gap < 100000; gap *= 10 {\n\t\t\tfor offset := 2; offset <= 1024; offset *= 2 {\n\t\t\t\trb := NewBitmap()\n\t\t\t\tfor k := 0; k < N; k++ {\n\t\t\t\t\trb.AddInt(k * gap)\n\t\t\t\t\tassert.EqualValues(t, k+1, rb.GetCardinality())\n\t\t\t\t}\n\n\t\t\t\tassert.EqualValues(t, N, rb.GetCardinality())\n\n\t\t\t\t// check the add of existing values\n\t\t\t\tfor k := 0; k < N; k++ {\n\t\t\t\t\trb.AddInt(k * gap)\n\t\t\t\t\tassert.EqualValues(t, N, rb.GetCardinality())\n\t\t\t\t}\n\n\t\t\t\trb2 := NewBitmap()\n\n\t\t\t\tfor k := 0; k < N; k++ {\n\t\t\t\t\trb2.AddInt(k * gap * offset)\n\t\t\t\t\tassert.EqualValues(t, k+1, rb2.GetCardinality())\n\t\t\t\t}\n\n\t\t\t\tassert.EqualValues(t, N, rb2.GetCardinality())\n\n\t\t\t\tfor k := 0; k < N; k++ {\n\t\t\t\t\trb2.AddInt(k * gap * offset)\n\t\t\t\t\tassert.EqualValues(t, N, rb2.GetCardinality())\n\t\t\t\t}\n\n\t\t\t\tassert.EqualValues(t, N/offset, And(rb, rb2).GetCardinality())\n\t\t\t\tassert.EqualValues(t, 2*N-2*N/offset, Xor(rb, rb2).GetCardinality())\n\t\t\t\tassert.EqualValues(t, 2*N-N/offset, Or(rb, rb2).GetCardinality())\n\t\t\t}\n\t\t}\n\t})\n\n\tt.Run(\"clear test\", func(t *testing.T) {\n\t\trb := NewBitmap()\n\t\tfor i := 0; i < 200000; i += 7 {\n\t\t\t// dense\n\t\t\trb.AddInt(i)\n\t\t}\n\t\tfor i := 200000; i < 400000; i += 177 {\n\t\t\t// sparse\n\t\t\trb.AddInt(i)\n\t\t}\n\n\t\trb2 := NewBitmap()\n\t\trb3 := NewBitmap()\n\t\tfor i := 0; i < 200000; i += 4 {\n\t\t\trb2.AddInt(i)\n\t\t}\n\t\tfor i := 200000; i < 400000; i += 14 {\n\t\t\trb2.AddInt(i)\n\t\t}\n\n\t\trb.Clear()\n\n\t\tassert.EqualValues(t, 0, rb.GetCardinality())\n\t\tassert.NotEqual(t, 0, rb2.GetCardinality())\n\n\t\trb.AddInt(4)\n\t\trb3.AddInt(4)\n\t\tandresult := And(rb, rb2)\n\t\torresult := Or(rb, rb2)\n\n\t\tassert.EqualValues(t, 1, andresult.GetCardinality())\n\t\tassert.Equal(t, rb2.GetCardinality(), orresult.GetCardinality())\n\n\t\tfor i := 0; i < 200000; i += 4 {\n\t\t\trb.AddInt(i)\n\t\t\trb3.AddInt(i)\n\t\t}\n\t\tfor i := 200000; i < 400000; i += 114 {\n\t\t\trb.AddInt(i)\n\t\t\trb3.AddInt(i)\n\t\t}\n\t\tcheckValidity(t, rb)\n\t\tcheckValidity(t, rb2)\n\t\tcheckValidity(t, rb3)\n\t\tarrayrr := rb.ToArray()\n\t\tarrayrr3 := rb3.ToArray()\n\t\tok := true\n\t\tfor i := range arrayrr {\n\t\t\tif arrayrr[i] != arrayrr3[i] {\n\t\t\t\tok = false\n\t\t\t}\n\t\t}\n\n\t\tassert.Equal(t, len(arrayrr3), len(arrayrr))\n\t\tassert.True(t, ok)\n\t})\n\n\tt.Run(\"container factory \", func(t *testing.T) {\n\t\tbc1 := newBitmapContainer()\n\t\tbc2 := newBitmapContainer()\n\t\tbc3 := newBitmapContainer()\n\t\tac1 := newArrayContainer()\n\t\tac2 := newArrayContainer()\n\t\tac3 := newArrayContainer()\n\n\t\tfor i := 0; i < 5000; i++ {\n\t\t\tbc1.iadd(uint16(i * 70))\n\t\t}\n\t\tfor i := 0; i < 5000; i++ {\n\t\t\tbc2.iadd(uint16(i * 70))\n\t\t}\n\t\tfor i := 0; i < 5000; i++ {\n\t\t\tbc3.iadd(uint16(i * 70))\n\t\t}\n\t\tfor i := 0; i < 4000; i++ {\n\t\t\tac1.iadd(uint16(i * 50))\n\t\t}\n\t\tfor i := 0; i < 4000; i++ {\n\t\t\tac2.iadd(uint16(i * 50))\n\t\t}\n\t\tfor i := 0; i < 4000; i++ {\n\t\t\tac3.iadd(uint16(i * 50))\n\t\t}\n\n\t\trbc := ac1.clone().(*arrayContainer).toBitmapContainer()\n\t\tvalidate(t, rbc, ac1)\n\n\t\trbc = ac2.clone().(*arrayContainer).toBitmapContainer()\n\t\tvalidate(t, rbc, ac2)\n\n\t\trbc = ac3.clone().(*arrayContainer).toBitmapContainer()\n\t\tvalidate(t, rbc, ac3)\n\t})\n\n\tt.Run(\"flipTest1 \", func(t *testing.T) {\n\t\trb := NewBitmap()\n\t\trb.Flip(100000, 200000) // in-place on empty bitmap\n\t\trbcard := rb.GetCardinality()\n\n\t\tassert.EqualValues(t, 100000, rbcard)\n\n\t\tbs := bitset.New(20000 - 10000)\n\t\tfor i := uint(100000); i < 200000; i++ {\n\t\t\tbs.Set(i)\n\t\t}\n\n\t\tassert.True(t, equalsBitSet(bs, rb))\n\t})\n\n\tt.Run(\"flipTest1A\", func(t *testing.T) {\n\t\trb := NewBitmap()\n\t\trb1 := Flip(rb, 100000, 200000)\n\t\trbcard := rb1.GetCardinality()\n\n\t\tassert.EqualValues(t, 100000, rbcard)\n\t\tassert.EqualValues(t, 0, rb.GetCardinality())\n\n\t\tbs := bitset.New(0)\n\t\tassert.True(t, equalsBitSet(bs, rb))\n\n\t\tfor i := uint(100000); i < 200000; i++ {\n\t\t\tbs.Set(i)\n\t\t}\n\t\tcheckValidity(t, rb1)\n\t\tcheckValidity(t, rb)\n\t\tassert.True(t, equalsBitSet(bs, rb1))\n\t})\n\n\tt.Run(\"flipTest2\", func(t *testing.T) {\n\t\trb := NewBitmap()\n\t\trb.Flip(100000, 100000)\n\t\trbcard := rb.GetCardinality()\n\n\t\tassert.EqualValues(t, 0, rbcard)\n\n\t\tbs := bitset.New(0)\n\t\tassert.True(t, equalsBitSet(bs, rb))\n\t})\n\n\tt.Run(\"flipTest2A\", func(t *testing.T) {\n\t\trb := NewBitmap()\n\t\trb1 := Flip(rb, 100000, 100000)\n\n\t\trb.AddInt(1)\n\t\trbcard := rb1.GetCardinality()\n\n\t\tassert.EqualValues(t, 0, rbcard)\n\t\tassert.EqualValues(t, 1, rb.GetCardinality())\n\n\t\tbs := bitset.New(0)\n\t\tassert.True(t, equalsBitSet(bs, rb1))\n\n\t\tbs.Set(1)\n\t\tassert.True(t, equalsBitSet(bs, rb))\n\t})\n\n\tt.Run(\"flipTest3A\", func(t *testing.T) {\n\t\trb := NewBitmap()\n\t\trb.Flip(100000, 200000) // got 100k-199999\n\t\trb.Flip(100000, 199991) // give back 100k-199990\n\t\trbcard := rb.GetCardinality()\n\n\t\tassert.EqualValues(t, 9, rbcard)\n\n\t\tbs := bitset.New(0)\n\t\tfor i := uint(199991); i < 200000; i++ {\n\t\t\tbs.Set(i)\n\t\t}\n\n\t\tassert.True(t, equalsBitSet(bs, rb))\n\t})\n\n\tt.Run(\"flipTest4A\", func(t *testing.T) {\n\t\t// fits evenly on both ends\n\t\trb := NewBitmap()\n\t\trb.Flip(100000, 200000) // got 100k-199999\n\t\trb.Flip(65536, 4*65536)\n\t\trbcard := rb.GetCardinality()\n\n\t\t// 65536 to 99999 are 1s\n\t\t// 200000 to 262143 are 1s: total card\n\n\t\tassert.EqualValues(t, 96608, rbcard)\n\n\t\tbs := bitset.New(0)\n\t\tfor i := uint(65536); i < 100000; i++ {\n\t\t\tbs.Set(i)\n\t\t}\n\t\tfor i := uint(200000); i < 262144; i++ {\n\t\t\tbs.Set(i)\n\t\t}\n\n\t\tassert.True(t, equalsBitSet(bs, rb))\n\t})\n\n\tt.Run(\"flipTest5\", func(t *testing.T) {\n\t\t// fits evenly on small end, multiple\n\t\t// containers\n\t\trb := NewBitmap()\n\t\trb.Flip(100000, 132000)\n\t\trb.Flip(65536, 120000)\n\t\trbcard := rb.GetCardinality()\n\n\t\t// 65536 to 99999 are 1s\n\t\t// 120000 to 131999\n\n\t\tassert.EqualValues(t, 46464, rbcard)\n\n\t\tbs := bitset.New(0)\n\t\tfor i := uint(65536); i < 100000; i++ {\n\t\t\tbs.Set(i)\n\t\t}\n\t\tfor i := uint(120000); i < 132000; i++ {\n\t\t\tbs.Set(i)\n\t\t}\n\n\t\tassert.True(t, equalsBitSet(bs, rb))\n\t})\n\n\tt.Run(\"flipTest6\", func(t *testing.T) {\n\t\trb := NewBitmap()\n\t\trb1 := Flip(rb, 100000, 132000)\n\t\trb2 := Flip(rb1, 65536, 120000)\n\t\t// rbcard := rb2.GetCardinality()\n\n\t\tbs := bitset.New(0)\n\t\tfor i := uint(65536); i < 100000; i++ {\n\t\t\tbs.Set(i)\n\t\t}\n\t\tfor i := uint(120000); i < 132000; i++ {\n\t\t\tbs.Set(i)\n\t\t}\n\n\t\tassert.True(t, equalsBitSet(bs, rb2))\n\t})\n\n\tt.Run(\"flipTest6A\", func(t *testing.T) {\n\t\trb := NewBitmap()\n\t\trb1 := Flip(rb, 100000, 132000)\n\t\trb2 := Flip(rb1, 99000, 2*65536)\n\t\trbcard := rb2.GetCardinality()\n\n\t\tassert.EqualValues(t, rbcard, 1928)\n\n\t\tbs := bitset.New(0)\n\t\tfor i := uint(99000); i < 100000; i++ {\n\t\t\tbs.Set(i)\n\t\t}\n\t\tfor i := uint(2 * 65536); i < 132000; i++ {\n\t\t\tbs.Set(i)\n\t\t}\n\t\tassert.True(t, equalsBitSet(bs, rb2))\n\t})\n\n\tt.Run(\"flipTest7\", func(t *testing.T) {\n\t\t// within 1 word, first container\n\t\trb := NewBitmap()\n\t\trb.Flip(650, 132000)\n\t\trb.Flip(648, 651)\n\t\trbcard := rb.GetCardinality()\n\n\t\t// 648, 649, 651-131999\n\n\t\tassert.EqualValues(t, rbcard, 132000-651+2)\n\n\t\tbs := bitset.New(0)\n\t\tbs.Set(648)\n\t\tbs.Set(649)\n\t\tfor i := uint(651); i < 132000; i++ {\n\t\t\tbs.Set(i)\n\t\t}\n\n\t\tassert.True(t, equalsBitSet(bs, rb))\n\t})\n\n\tt.Run(\"flipTestBig\", func(t *testing.T) {\n\t\tnumCases := 1000\n\t\trb := NewBitmap()\n\t\tbs := bitset.New(0)\n\t\t// Random r = new Random(3333);\n\t\tcheckTime := 2.0\n\n\t\tfor i := 0; i < numCases; i++ {\n\t\t\tstart := rand.Intn(65536 * 20)\n\t\t\tend := rand.Intn(65536 * 20)\n\t\t\tif rand.Float64() < float64(0.1) {\n\t\t\t\tend = start + rand.Intn(100)\n\t\t\t}\n\t\t\trb.Flip(uint64(start), uint64(end))\n\t\t\tif start < end {\n\t\t\t\tFlipRange(start, end, bs) // throws exception\n\t\t\t}\n\t\t\t// otherwise\n\t\t\t// insert some more ANDs to keep things sparser\n\t\t\tif rand.Float64() < 0.2 {\n\t\t\t\tmask := NewBitmap()\n\t\t\t\tmask1 := bitset.New(0)\n\t\t\t\tstartM := rand.Intn(65536 * 20)\n\t\t\t\tendM := startM + 100000\n\t\t\t\tmask.Flip(uint64(startM), uint64(endM))\n\t\t\t\tFlipRange(startM, endM, mask1)\n\t\t\t\tmask.Flip(0, 65536*20+100000)\n\t\t\t\tFlipRange(0, 65536*20+100000, mask1)\n\t\t\t\trb.And(mask)\n\t\t\t\tbs.InPlaceIntersection(mask1)\n\t\t\t}\n\t\t\t// see if we can detect incorrectly shared containers\n\t\t\tif rand.Float64() < 0.1 {\n\t\t\t\tirrelevant := Flip(rb, 10, 100000)\n\t\t\t\tirrelevant.Flip(5, 200000)\n\t\t\t\tirrelevant.Flip(190000, 260000)\n\t\t\t}\n\t\t\tif float64(i) > checkTime {\n\t\t\t\tassert.True(t, equalsBitSet(bs, rb))\n\t\t\t\tcheckTime *= 1.5\n\t\t\t}\n\t\t}\n\t})\n\n\tt.Run(\"ortest\", func(t *testing.T) {\n\t\trr := NewBitmap()\n\t\tfor k := 0; k < 4000; k++ {\n\t\t\trr.AddInt(k)\n\t\t}\n\t\trr.AddInt(100000)\n\t\trr.AddInt(110000)\n\t\trr2 := NewBitmap()\n\t\tfor k := 0; k < 4000; k++ {\n\t\t\trr2.AddInt(k)\n\t\t}\n\n\t\trror := Or(rr, rr2)\n\n\t\tarray := rror.ToArray()\n\n\t\trr.Or(rr2)\n\t\tarrayirr := rr.ToArray()\n\n\t\tassert.True(t, IntsEquals(array, arrayirr))\n\t})\n\n\tt.Run(\"ORtest\", func(t *testing.T) {\n\t\trr := NewBitmap()\n\t\tfor k := 4000; k < 4256; k++ {\n\t\t\trr.AddInt(k)\n\t\t}\n\t\tfor k := 65536; k < 65536+4000; k++ {\n\t\t\trr.AddInt(k)\n\t\t}\n\t\tfor k := 3 * 65536; k < 3*65536+9000; k++ {\n\t\t\trr.AddInt(k)\n\t\t}\n\t\tfor k := 4 * 65535; k < 4*65535+7000; k++ {\n\t\t\trr.AddInt(k)\n\t\t}\n\t\tfor k := 6 * 65535; k < 6*65535+10000; k++ {\n\t\t\trr.AddInt(k)\n\t\t}\n\t\tfor k := 8 * 65535; k < 8*65535+1000; k++ {\n\t\t\trr.AddInt(k)\n\t\t}\n\t\tfor k := 9 * 65535; k < 9*65535+30000; k++ {\n\t\t\trr.AddInt(k)\n\t\t}\n\n\t\trr2 := NewBitmap()\n\t\tfor k := 4000; k < 4256; k++ {\n\t\t\trr2.AddInt(k)\n\t\t}\n\t\tfor k := 65536; k < 65536+4000; k++ {\n\t\t\trr2.AddInt(k)\n\t\t}\n\t\tfor k := 3*65536 + 2000; k < 3*65536+6000; k++ {\n\t\t\trr2.AddInt(k)\n\t\t}\n\t\tfor k := 6 * 65535; k < 6*65535+1000; k++ {\n\t\t\trr2.AddInt(k)\n\t\t}\n\t\tfor k := 7 * 65535; k < 7*65535+1000; k++ {\n\t\t\trr2.AddInt(k)\n\t\t}\n\t\tfor k := 10 * 65535; k < 10*65535+5000; k++ {\n\t\t\trr2.AddInt(k)\n\t\t}\n\t\tcorrect := Or(rr, rr2)\n\t\trr.Or(rr2)\n\n\t\tassert.True(t, correct.Equals(rr))\n\t})\n\n\tt.Run(\"ortest2\", func(t *testing.T) {\n\t\tarrayrr := make([]uint32, 4000+4000+2)\n\t\tpos := 0\n\t\trr := NewBitmap()\n\t\tfor k := 0; k < 4000; k++ {\n\t\t\trr.AddInt(k)\n\t\t\tarrayrr[pos] = uint32(k)\n\t\t\tpos++\n\t\t}\n\t\trr.AddInt(100000)\n\t\trr.AddInt(110000)\n\t\trr2 := NewBitmap()\n\t\tfor k := 4000; k < 8000; k++ {\n\t\t\trr2.AddInt(k)\n\t\t\tarrayrr[pos] = uint32(k)\n\t\t\tpos++\n\t\t}\n\n\t\tarrayrr[pos] = 100000\n\t\tpos++\n\t\tarrayrr[pos] = 110000\n\t\tpos++\n\n\t\trror := Or(rr, rr2)\n\n\t\tcheckValidity(t, rror)\n\t\tarrayor := rror.ToArray()\n\n\t\tassert.True(t, IntsEquals(arrayor, arrayrr))\n\t})\n\n\tt.Run(\"ortest3\", func(t *testing.T) {\n\t\tV1 := make(map[int]bool)\n\t\tV2 := make(map[int]bool)\n\n\t\trr := NewBitmap()\n\t\trr2 := NewBitmap()\n\t\tfor k := 0; k < 4000; k++ {\n\t\t\trr2.AddInt(k)\n\t\t\tV1[k] = true\n\t\t}\n\t\tfor k := 3500; k < 4500; k++ {\n\t\t\trr.AddInt(k)\n\t\t\tV1[k] = true\n\t\t}\n\t\tfor k := 4000; k < 65000; k++ {\n\t\t\trr2.AddInt(k)\n\t\t\tV1[k] = true\n\t\t}\n\n\t\t// In the second node of each roaring bitmap, we have two bitmap\n\t\t// containers.\n\t\t// So, we will check the union between two BitmapContainers\n\t\tfor k := 65536; k < 65536+10000; k++ {\n\t\t\trr.AddInt(k)\n\t\t\tV1[k] = true\n\t\t}\n\n\t\tfor k := 65536; k < 65536+14000; k++ {\n\t\t\trr2.AddInt(k)\n\t\t\tV1[k] = true\n\t\t}\n\n\t\t// In the 3rd node of each Roaring Bitmap, we have an\n\t\t// ArrayContainer, so, we will try the union between two\n\t\t// ArrayContainers.\n\t\tfor k := 4 * 65535; k < 4*65535+1000; k++ {\n\t\t\trr.AddInt(k)\n\t\t\tV1[k] = true\n\t\t}\n\n\t\tfor k := 4 * 65535; k < 4*65535+800; k++ {\n\t\t\trr2.AddInt(k)\n\t\t\tV1[k] = true\n\t\t}\n\n\t\t// For the rest, we will check if the union will take them in\n\t\t// the result\n\t\tfor k := 6 * 65535; k < 6*65535+1000; k++ {\n\t\t\trr.AddInt(k)\n\t\t\tV1[k] = true\n\t\t}\n\n\t\tfor k := 7 * 65535; k < 7*65535+2000; k++ {\n\t\t\trr2.AddInt(k)\n\t\t\tV1[k] = true\n\t\t}\n\n\t\trror := Or(rr, rr2)\n\t\tvalide := true\n\t\tcheckValidity(t, rror)\n\t\tfor _, k := range rror.ToArray() {\n\t\t\t_, found := V1[int(k)]\n\t\t\tif !found {\n\t\t\t\tvalide = false\n\t\t\t}\n\t\t\tV2[int(k)] = true\n\t\t}\n\n\t\tfor k := range V1 {\n\t\t\t_, found := V2[k]\n\t\t\tif !found {\n\t\t\t\tvalide = false\n\t\t\t}\n\t\t}\n\n\t\tassert.True(t, valide)\n\t})\n\n\tt.Run(\"ortest4\", func(t *testing.T) {\n\t\trb := NewBitmap()\n\t\trb2 := NewBitmap()\n\n\t\tfor i := 0; i < 200000; i += 4 {\n\t\t\trb2.AddInt(i)\n\t\t}\n\t\tfor i := 200000; i < 400000; i += 14 {\n\t\t\trb2.AddInt(i)\n\t\t}\n\t\trb2card := rb2.GetCardinality()\n\n\t\t// check or against an empty bitmap\n\t\torresult := Or(rb, rb2)\n\t\toff := Or(rb2, rb)\n\n\t\tassert.True(t, orresult.Equals(off))\n\t\tassert.Equal(t, orresult.GetCardinality(), rb2card)\n\n\t\tfor i := 500000; i < 600000; i += 14 {\n\t\t\trb.AddInt(i)\n\t\t}\n\t\tfor i := 200000; i < 400000; i += 3 {\n\t\t\trb2.AddInt(i)\n\t\t}\n\t\t// check or against an empty bitmap\n\t\torresult2 := Or(rb, rb2)\n\t\tcheckValidity(t, orresult2)\n\t\tassert.Equal(t, orresult.GetCardinality(), rb2card)\n\t\tassert.Equal(t, rb2.GetCardinality()+rb.GetCardinality(), orresult2.GetCardinality())\n\n\t\trb.Or(rb2)\n\t\tassert.True(t, rb.Equals(orresult2))\n\t})\n\n\tt.Run(\"randomTest\", func(t *testing.T) {\n\t\trTest(t, 15)\n\t\trTest(t, 1024)\n\t\trTest(t, 4096)\n\t\trTest(t, 65536)\n\t\trTest(t, 65536*16)\n\t})\n\n\tt.Run(\"SimpleCardinality\", func(t *testing.T) {\n\t\tN := 512\n\t\tgap := 70\n\n\t\trb := NewBitmap()\n\t\tfor k := 0; k < N; k++ {\n\t\t\trb.AddInt(k * gap)\n\t\t\tassert.EqualValues(t, k+1, rb.GetCardinality())\n\t\t}\n\n\t\tassert.EqualValues(t, N, rb.GetCardinality())\n\n\t\tfor k := 0; k < N; k++ {\n\t\t\trb.AddInt(k * gap)\n\t\t\tassert.EqualValues(t, N, rb.GetCardinality())\n\t\t}\n\t})\n\n\tt.Run(\"XORtest\", func(t *testing.T) {\n\t\trr := NewBitmap()\n\t\tfor k := 4000; k < 4256; k++ {\n\t\t\trr.AddInt(k)\n\t\t}\n\t\tfor k := 65536; k < 65536+4000; k++ {\n\t\t\trr.AddInt(k)\n\t\t}\n\t\tfor k := 3 * 65536; k < 3*65536+9000; k++ {\n\t\t\trr.AddInt(k)\n\t\t}\n\t\tfor k := 4 * 65535; k < 4*65535+7000; k++ {\n\t\t\trr.AddInt(k)\n\t\t}\n\t\tfor k := 6 * 65535; k < 6*65535+10000; k++ {\n\t\t\trr.AddInt(k)\n\t\t}\n\t\tfor k := 8 * 65535; k < 8*65535+1000; k++ {\n\t\t\trr.AddInt(k)\n\t\t}\n\t\tfor k := 9 * 65535; k < 9*65535+30000; k++ {\n\t\t\trr.AddInt(k)\n\t\t}\n\n\t\trr2 := NewBitmap()\n\t\tfor k := 4000; k < 4256; k++ {\n\t\t\trr2.AddInt(k)\n\t\t}\n\t\tfor k := 65536; k < 65536+4000; k++ {\n\t\t\trr2.AddInt(k)\n\t\t}\n\t\tfor k := 3*65536 + 2000; k < 3*65536+6000; k++ {\n\t\t\trr2.AddInt(k)\n\t\t}\n\t\tfor k := 6 * 65535; k < 6*65535+1000; k++ {\n\t\t\trr2.AddInt(k)\n\t\t}\n\t\tfor k := 7 * 65535; k < 7*65535+1000; k++ {\n\t\t\trr2.AddInt(k)\n\t\t}\n\t\tfor k := 10 * 65535; k < 10*65535+5000; k++ {\n\t\t\trr2.AddInt(k)\n\t\t}\n\n\t\tcorrect := Xor(rr, rr2)\n\t\tcheckValidity(t, correct)\n\n\t\trr.Xor(rr2)\n\n\t\tassert.True(t, correct.Equals(rr))\n\t})\n\n\tt.Run(\"xortest1\", func(t *testing.T) {\n\t\tV1 := make(map[int]bool)\n\t\tV2 := make(map[int]bool)\n\n\t\trr := NewBitmap()\n\t\trr2 := NewBitmap()\n\t\t// For the first 65536: rr2 has a bitmap container, and rr has\n\t\t// an array container.\n\t\t// We will check the union between a BitmapCintainer and an\n\t\t// arrayContainer\n\t\tfor k := 0; k < 4000; k++ {\n\t\t\trr2.AddInt(k)\n\t\t\tif k < 3500 {\n\t\t\t\tV1[k] = true\n\t\t\t}\n\t\t}\n\t\tfor k := 3500; k < 4500; k++ {\n\t\t\trr.AddInt(k)\n\t\t}\n\t\tfor k := 4000; k < 65000; k++ {\n\t\t\trr2.AddInt(k)\n\t\t\tif k >= 4500 {\n\t\t\t\tV1[k] = true\n\t\t\t}\n\t\t}\n\n\t\tfor k := 65536; k < 65536+30000; k++ {\n\t\t\trr.AddInt(k)\n\t\t}\n\n\t\tfor k := 65536; k < 65536+50000; k++ {\n\t\t\trr2.AddInt(k)\n\t\t\tif k >= 65536+30000 {\n\t\t\t\tV1[k] = true\n\t\t\t}\n\t\t}\n\n\t\t// In the 3rd node of each Roaring Bitmap, we have an\n\t\t// ArrayContainer. So, we will try the union between two\n\t\t// ArrayContainers.\n\t\tfor k := 4 * 65535; k < 4*65535+1000; k++ {\n\t\t\trr.AddInt(k)\n\t\t\tif k >= (4*65535 + 800) {\n\t\t\t\tV1[k] = true\n\t\t\t}\n\t\t}\n\n\t\tfor k := 4 * 65535; k < 4*65535+800; k++ {\n\t\t\trr2.AddInt(k)\n\t\t}\n\n\t\tfor k := 6 * 65535; k < 6*65535+1000; k++ {\n\t\t\trr.AddInt(k)\n\t\t\tV1[k] = true\n\t\t}\n\n\t\tfor k := 7 * 65535; k < 7*65535+2000; k++ {\n\t\t\trr2.AddInt(k)\n\t\t\tV1[k] = true\n\t\t}\n\n\t\trrxor := Xor(rr, rr2)\n\t\tvalide := true\n\n\t\tfor _, i := range rrxor.ToArray() {\n\t\t\t_, found := V1[int(i)]\n\t\t\tif !found {\n\t\t\t\tvalide = false\n\t\t\t}\n\t\t\tV2[int(i)] = true\n\t\t}\n\t\tfor k := range V1 {\n\t\t\t_, found := V2[k]\n\t\t\tif !found {\n\t\t\t\tvalide = false\n\t\t\t}\n\t\t}\n\n\t\tassert.True(t, valide)\n\t})\n}\n\nfunc TestXORtest4(t *testing.T) {\n\tt.Run(\"XORtest 4\", func(t *testing.T) {\n\t\trb := NewBitmap()\n\t\trb2 := NewBitmap()\n\t\tcounter := 0\n\n\t\tfor i := 0; i < 200000; i += 4 {\n\t\t\trb2.AddInt(i)\n\t\t\tcounter++\n\t\t}\n\n\t\tassert.EqualValues(t, counter, rb2.GetCardinality())\n\n\t\tfor i := 200000; i < 400000; i += 14 {\n\t\t\trb2.AddInt(i)\n\t\t\tcounter++\n\t\t}\n\n\t\tassert.EqualValues(t, counter, rb2.GetCardinality())\n\n\t\trb2card := rb2.GetCardinality()\n\t\tassert.EqualValues(t, counter, rb2card)\n\n\t\t// check or against an empty bitmap\n\t\txorresult := Xor(rb, rb2)\n\t\tassert.EqualValues(t, counter, xorresult.GetCardinality())\n\t\toff := Or(rb2, rb)\n\n\t\tassert.EqualValues(t, counter, off.GetCardinality())\n\t\tassert.True(t, xorresult.Equals(off))\n\n\t\tassert.Equal(t, xorresult.GetCardinality(), rb2card)\n\t\tfor i := 500000; i < 600000; i += 14 {\n\t\t\trb.AddInt(i)\n\t\t}\n\t\tfor i := 200000; i < 400000; i += 3 {\n\t\t\trb2.AddInt(i)\n\t\t}\n\t\t// check or against an empty bitmap\n\t\txorresult2 := Xor(rb, rb2)\n\n\t\tassert.EqualValues(t, xorresult.GetCardinality(), rb2card)\n\t\tassert.Equal(t, xorresult2.GetCardinality(), rb2.GetCardinality()+rb.GetCardinality())\n\n\t\trb.Xor(rb2)\n\t\tassert.True(t, xorresult2.Equals(rb))\n\t})\n\t// need to add the massives\n}\n\nfunc TestNextMany(t *testing.T) {\n\tcount := 70000\n\n\tfor _, gap := range []uint32{1, 8, 32, 128} {\n\t\texpected := make([]uint32, count)\n\t\t{\n\t\t\tv := uint32(0)\n\t\t\tfor i := range expected {\n\t\t\t\texpected[i] = v\n\t\t\t\tv += gap\n\t\t\t}\n\t\t}\n\t\tbm := BitmapOf(expected...)\n\t\tfor _, bufSize := range []int{1, 64, 4096, count} {\n\t\t\tbuf := make([]uint32, bufSize)\n\t\t\tit := bm.ManyIterator()\n\t\t\tcur := 0\n\t\t\tfor n := it.NextMany(buf); n != 0; n = it.NextMany(buf) {\n\t\t\t\t// much faster tests... (10s -> 5ms)\n\t\t\t\tif cur+n > count {\n\t\t\t\t\tassert.LessOrEqual(t, count, cur+n)\n\t\t\t\t}\n\n\t\t\t\tfor i, v := range buf[:n] {\n\t\t\t\t\t// much faster tests...\n\t\t\t\t\tif v != expected[cur+i] {\n\t\t\t\t\t\tassert.Equal(t, expected[cur+i], v)\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tcur += n\n\t\t\t}\n\n\t\t\tassert.Equal(t, count, cur)\n\t\t}\n\t}\n}\n\nfunc TestBigRandom(t *testing.T) {\n\trTest(t, 15)\n\trTest(t, 100)\n\trTest(t, 512)\n\trTest(t, 1023)\n\trTest(t, 1025)\n\trTest(t, 4095)\n\trTest(t, 4096)\n\trTest(t, 4097)\n\trTest(t, 65536)\n\trTest(t, 65536*16)\n}\n\nfunc TestHash(t *testing.T) {\n\thashTest(t, 15)\n\thashTest(t, 100)\n\thashTest(t, 512)\n\thashTest(t, 1023)\n\thashTest(t, 1025)\n\thashTest(t, 4095)\n\thashTest(t, 4096)\n\thashTest(t, 4097)\n}\n\nfunc rTest(t *testing.T, N int) {\n\tfor gap := 1; gap <= 65536; gap *= 2 {\n\t\tbs1 := bitset.New(0)\n\t\trb1 := NewBitmap()\n\t\tfor x := 0; x <= N; x += gap {\n\t\t\tbs1.Set(uint(x))\n\t\t\trb1.AddInt(x)\n\t\t}\n\n\t\tassert.EqualValues(t, rb1.GetCardinality(), bs1.Count())\n\t\tassert.True(t, equalsBitSet(bs1, rb1))\n\n\t\tfor offset := 1; offset <= gap; offset *= 2 {\n\t\t\tbs2 := bitset.New(0)\n\t\t\trb2 := NewBitmap()\n\t\t\tfor x := 0; x <= N; x += gap {\n\t\t\t\tbs2.Set(uint(x + offset))\n\t\t\t\trb2.AddInt(x + offset)\n\t\t\t}\n\n\t\t\tassert.EqualValues(t, rb2.GetCardinality(), bs2.Count())\n\t\t\tassert.True(t, equalsBitSet(bs2, rb2))\n\n\t\t\tclonebs1 := bs1.Clone()\n\t\t\tclonebs1.InPlaceIntersection(bs2)\n\n\t\t\tif !equalsBitSet(clonebs1, And(rb1, rb2)) {\n\t\t\t\tv := rb1.Clone()\n\t\t\t\tv.And(rb2)\n\t\t\t\tassert.True(t, equalsBitSet(clonebs1, v))\n\t\t\t}\n\n\t\t\t// testing OR\n\t\t\tclonebs1 = bs1.Clone()\n\t\t\tclonebs1.InPlaceUnion(bs2)\n\n\t\t\tassert.True(t, equalsBitSet(clonebs1, Or(rb1, rb2)))\n\n\t\t\t// testing XOR\n\t\t\tclonebs1 = bs1.Clone()\n\t\t\tclonebs1.InPlaceSymmetricDifference(bs2)\n\n\t\t\tassert.True(t, equalsBitSet(clonebs1, Xor(rb1, rb2)))\n\n\t\t\t// testing NOTAND\n\t\t\tclonebs1 = bs1.Clone()\n\t\t\tclonebs1.InPlaceDifference(bs2)\n\n\t\t\tassert.True(t, equalsBitSet(clonebs1, AndNot(rb1, rb2)))\n\t\t}\n\t}\n}\n\nfunc equalsBitSet(a *bitset.BitSet, b *Bitmap) bool {\n\tfor i, e := a.NextSet(0); e; i, e = a.NextSet(i + 1) {\n\t\tif !b.ContainsInt(int(i)) {\n\t\t\treturn false\n\t\t}\n\t}\n\ti := b.Iterator()\n\tfor i.HasNext() {\n\t\tif !a.Test(uint(i.Next())) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\nfunc equalsArray(a []int, b *Bitmap) bool {\n\tif uint64(len(a)) != b.GetCardinality() {\n\t\treturn false\n\t}\n\tfor _, x := range a {\n\t\tif !b.ContainsInt(x) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\nfunc IntsEquals(a, b []uint32) bool {\n\tif len(a) != len(b) {\n\t\treturn false\n\t}\n\tfor i, v := range a {\n\t\tif v != b[i] {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\nfunc validate(t *testing.T, bc *bitmapContainer, ac *arrayContainer) {\n\t// Checking the cardinalities of each container\n\tt.Helper()\n\n\tif bc.getCardinality() != ac.getCardinality() {\n\t\tt.Error(\"cardinality differs\")\n\t}\n\t// Checking that the two containers contain the same values\n\tcounter := 0\n\n\tfor i := bc.NextSetBit(0); i >= 0; i = bc.NextSetBit(uint(i) + 1) {\n\t\tcounter++\n\t\tif !ac.contains(uint16(i)) {\n\t\t\tt.Log(\"content differs\")\n\t\t\tt.Log(bc)\n\t\t\tt.Log(ac)\n\t\t\tt.Fail()\n\t\t}\n\n\t}\n\n\t// checking the cardinality of the BitmapContainer\n\tassert.Equal(t, counter, bc.getCardinality())\n}\n\nfunc TestRoaringArray(t *testing.T) {\n\ta := newRoaringArray()\n\n\tt.Run(\"Test Init\", func(t *testing.T) {\n\t\tassert.Equal(t, 0, a.size())\n\t})\n\n\tt.Run(\"Test Insert\", func(t *testing.T) {\n\t\ta.appendContainer(0, newArrayContainer(), false)\n\t\tassert.Equal(t, 1, a.size())\n\t})\n\n\tt.Run(\"Test Remove\", func(t *testing.T) {\n\t\ta.remove(0)\n\t\tassert.Equal(t, 0, a.size())\n\t})\n\n\tt.Run(\"Test popcount Full\", func(t *testing.T) {\n\t\tres := popcount(uint64(0xffffffffffffffff))\n\t\tassert.EqualValues(t, 64, res)\n\t})\n\n\tt.Run(\"Test popcount Empty\", func(t *testing.T) {\n\t\tres := popcount(0)\n\t\tassert.EqualValues(t, 0, res)\n\t})\n\n\tt.Run(\"Test popcount 16\", func(t *testing.T) {\n\t\tres := popcount(0xff00ff)\n\t\tassert.EqualValues(t, 16, res)\n\t})\n\n\tt.Run(\"Test ArrayContainer Add\", func(t *testing.T) {\n\t\tar := newArrayContainer()\n\t\tar.iadd(1)\n\n\t\tassert.EqualValues(t, 1, ar.getCardinality())\n\t})\n\n\tt.Run(\"Test ArrayContainer Add wacky\", func(t *testing.T) {\n\t\tar := newArrayContainer()\n\t\tar.iadd(0)\n\t\tar.iadd(5000)\n\n\t\tassert.EqualValues(t, 2, ar.getCardinality())\n\t})\n\n\tt.Run(\"Test ArrayContainer Add Reverse\", func(t *testing.T) {\n\t\tar := newArrayContainer()\n\t\tar.iadd(5000)\n\t\tar.iadd(2048)\n\t\tar.iadd(0)\n\n\t\tassert.EqualValues(t, 3, ar.getCardinality())\n\t})\n\n\tt.Run(\"Test BitmapContainer Add \", func(t *testing.T) {\n\t\tbm := newBitmapContainer()\n\t\tbm.iadd(0)\n\n\t\tassert.EqualValues(t, 1, bm.getCardinality())\n\t})\n}\n\nfunc TestFlipBigA(t *testing.T) {\n\tnumCases := 1000\n\tbs := bitset.New(0)\n\tcheckTime := 2.0\n\trb1 := NewBitmap()\n\trb2 := NewBitmap()\n\n\tfor i := 0; i < numCases; i++ {\n\t\tstart := rand.Intn(65536 * 20)\n\t\tend := rand.Intn(65536 * 20)\n\t\tif rand.Float64() < 0.1 {\n\t\t\tend = start + rand.Intn(100)\n\t\t}\n\n\t\tif (i & 1) == 0 {\n\t\t\trb2 = FlipInt(rb1, start, end)\n\t\t\t// tweak the other, catch bad sharing\n\t\t\trb1.FlipInt(rand.Intn(65536*20), rand.Intn(65536*20))\n\t\t} else {\n\t\t\trb1 = FlipInt(rb2, start, end)\n\t\t\trb2.FlipInt(rand.Intn(65536*20), rand.Intn(65536*20))\n\t\t}\n\n\t\tif start < end {\n\t\t\tFlipRange(start, end, bs) // throws exception\n\t\t}\n\t\t// otherwise\n\t\t// insert some more ANDs to keep things sparser\n\t\tif (rand.Float64() < 0.2) && (i&1) == 0 {\n\t\t\tmask := NewBitmap()\n\t\t\tmask1 := bitset.New(0)\n\t\t\tstartM := rand.Intn(65536 * 20)\n\t\t\tendM := startM + 100000\n\t\t\tmask.FlipInt(startM, endM)\n\t\t\tFlipRange(startM, endM, mask1)\n\t\t\tmask.FlipInt(0, 65536*20+100000)\n\t\t\tFlipRange(0, 65536*20+100000, mask1)\n\t\t\trb2.And(mask)\n\t\t\tbs.InPlaceIntersection(mask1)\n\t\t}\n\n\t\tif float64(i) > checkTime {\n\t\t\tvar rb *Bitmap\n\n\t\t\tif (i & 1) == 0 {\n\t\t\t\trb = rb2\n\t\t\t} else {\n\t\t\t\trb = rb1\n\t\t\t}\n\n\t\t\tassert.True(t, equalsBitSet(bs, rb))\n\t\t\tcheckTime *= 1.5\n\t\t}\n\t}\n}\n\nfunc TestNextManyOfAddRangeAcrossContainers(t *testing.T) {\n\trb := NewBitmap()\n\trb.AddRange(65530, 65540)\n\texpectedCard := 10\n\texpected := []uint32{65530, 65531, 65532, 65533, 65534, 65535, 65536, 65537, 65538, 65539, 0}\n\n\t// test where all values can be returned in a single buffer\n\tit := rb.ManyIterator()\n\tbuf := make([]uint32, 11)\n\tn := it.NextMany(buf)\n\n\tassert.Equal(t, expectedCard, n)\n\n\tfor i, e := range expected {\n\t\tassert.Equal(t, e, buf[i])\n\t}\n\n\t// test where buf is size 1, so many iterations\n\tit = rb.ManyIterator()\n\tn = 0\n\tbuf = make([]uint32, 1)\n\n\tfor i := 0; i < expectedCard; i++ {\n\t\tn = it.NextMany(buf)\n\n\t\tassert.Equal(t, 1, n)\n\t\tassert.Equal(t, expected[i], buf[0])\n\t}\n\n\tn = it.NextMany(buf)\n\tassert.Equal(t, 0, n)\n}\n\nfunc TestDoubleAdd(t *testing.T) {\n\tt.Run(\"doubleadd \", func(t *testing.T) {\n\t\trb := NewBitmap()\n\t\trb.AddRange(65533, 65536)\n\t\trb.AddRange(65530, 65536)\n\t\trb2 := NewBitmap()\n\t\trb2.AddRange(65530, 65536)\n\n\t\tassert.True(t, rb.Equals(rb2))\n\n\t\trb2.RemoveRange(65530, 65536)\n\n\t\tassert.EqualValues(t, 0, rb2.GetCardinality())\n\t})\n\n\tt.Run(\"doubleadd2 \", func(t *testing.T) {\n\t\trb := NewBitmap()\n\t\trb.AddRange(65533, 65536*20)\n\t\trb.AddRange(65530, 65536*20)\n\t\trb2 := NewBitmap()\n\t\trb2.AddRange(65530, 65536*20)\n\n\t\tassert.True(t, rb.Equals(rb2))\n\n\t\trb2.RemoveRange(65530, 65536*20)\n\n\t\tassert.EqualValues(t, 0, rb2.GetCardinality())\n\t})\n\n\tt.Run(\"doubleadd3 \", func(t *testing.T) {\n\t\trb := NewBitmap()\n\t\trb.AddRange(65533, 65536*20+10)\n\t\trb.AddRange(65530, 65536*20+10)\n\t\trb2 := NewBitmap()\n\t\trb2.AddRange(65530, 65536*20+10)\n\n\t\tassert.True(t, rb.Equals(rb2))\n\n\t\trb2.RemoveRange(65530, 65536*20+1)\n\n\t\tassert.EqualValues(t, 9, rb2.GetCardinality())\n\t})\n\n\tt.Run(\"doubleadd4 \", func(t *testing.T) {\n\t\trb := NewBitmap()\n\t\trb.AddRange(65533, 65536*20)\n\t\trb.RemoveRange(65533+5, 65536*20)\n\n\t\tassert.EqualValues(t, 5, rb.GetCardinality())\n\t})\n\n\tt.Run(\"doubleadd5 \", func(t *testing.T) {\n\t\trb := NewBitmap()\n\t\trb.AddRange(65533, 65536*20)\n\t\trb.RemoveRange(65533+5, 65536*20-5)\n\n\t\tassert.EqualValues(t, 10, rb.GetCardinality())\n\t})\n\n\tt.Run(\"doubleadd6 \", func(t *testing.T) {\n\t\trb := NewBitmap()\n\t\trb.AddRange(65533, 65536*20-5)\n\t\trb.RemoveRange(65533+5, 65536*20-10)\n\n\t\tassert.EqualValues(t, 10, rb.GetCardinality())\n\t})\n\n\tt.Run(\"doubleadd7 \", func(t *testing.T) {\n\t\trb := NewBitmap()\n\t\trb.AddRange(65533, 65536*20+1)\n\t\trb.RemoveRange(65533+1, 65536*20)\n\n\t\tassert.EqualValues(t, 2, rb.GetCardinality())\n\t})\n\n\tt.Run(\"AndNotBug01 \", func(t *testing.T) {\n\t\trb1 := NewBitmap()\n\t\trb1.AddRange(0, 60000)\n\t\trb2 := NewBitmap()\n\t\trb2.AddRange(60000-10, 60000+10)\n\t\trb2.AndNot(rb1)\n\t\trb3 := NewBitmap()\n\t\trb3.AddRange(60000, 60000+10)\n\n\t\tassert.True(t, rb2.Equals(rb3))\n\t})\n}\n\nfunc TestAndNot(t *testing.T) {\n\trr := NewBitmap()\n\n\tfor k := 4000; k < 4256; k++ {\n\t\trr.AddInt(k)\n\t}\n\tfor k := 65536; k < 65536+4000; k++ {\n\t\trr.AddInt(k)\n\t}\n\tfor k := 3 * 65536; k < 3*65536+9000; k++ {\n\t\trr.AddInt(k)\n\t}\n\tfor k := 4 * 65535; k < 4*65535+7000; k++ {\n\t\trr.AddInt(k)\n\t}\n\tfor k := 6 * 65535; k < 6*65535+10000; k++ {\n\t\trr.AddInt(k)\n\t}\n\tfor k := 8 * 65535; k < 8*65535+1000; k++ {\n\t\trr.AddInt(k)\n\t}\n\tfor k := 9 * 65535; k < 9*65535+30000; k++ {\n\t\trr.AddInt(k)\n\t}\n\n\trr2 := NewBitmap()\n\n\tfor k := 4000; k < 4256; k++ {\n\t\trr2.AddInt(k)\n\t}\n\tfor k := 65536; k < 65536+4000; k++ {\n\t\trr2.AddInt(k)\n\t}\n\tfor k := 3*65536 + 2000; k < 3*65536+6000; k++ {\n\t\trr2.AddInt(k)\n\t}\n\tfor k := 6 * 65535; k < 6*65535+1000; k++ {\n\t\trr2.AddInt(k)\n\t}\n\tfor k := 7 * 65535; k < 7*65535+1000; k++ {\n\t\trr2.AddInt(k)\n\t}\n\tfor k := 10 * 65535; k < 10*65535+5000; k++ {\n\t\trr2.AddInt(k)\n\t}\n\n\tcorrect := AndNot(rr, rr2)\n\trr.AndNot(rr2)\n\n\tassert.True(t, correct.Equals(rr))\n}\n\nfunc TestStats(t *testing.T) {\n\tt.Run(\"Test Stats with empty bitmap\", func(t *testing.T) {\n\t\texpectedStats := Statistics{}\n\t\trr := NewBitmap()\n\n\t\tassert.EqualValues(t, expectedStats, rr.Stats())\n\t})\n\n\tt.Run(\"Test Stats with bitmap Container\", func(t *testing.T) {\n\t\t// Given a bitmap that should have a single bitmap container\n\t\texpectedStats := Statistics{\n\t\t\tCardinality: 60000,\n\t\t\tContainers:  1,\n\n\t\t\tBitmapContainers:      1,\n\t\t\tBitmapContainerValues: 60000,\n\t\t\tBitmapContainerBytes:  8192,\n\n\t\t\tRunContainers:      0,\n\t\t\tRunContainerBytes:  0,\n\t\t\tRunContainerValues: 0,\n\t\t}\n\n\t\trr := NewBitmap()\n\n\t\tfor i := uint32(0); i < 60000; i++ {\n\t\t\trr.Add(i)\n\t\t}\n\n\t\tassert.EqualValues(t, expectedStats, rr.Stats())\n\t})\n\n\tt.Run(\"Test Stats with Array Container\", func(t *testing.T) {\n\t\t// Given a bitmap that should have a single array container\n\t\texpectedStats := Statistics{\n\t\t\tCardinality: 2,\n\t\t\tContainers:  1,\n\n\t\t\tArrayContainers:      1,\n\t\t\tArrayContainerValues: 2,\n\t\t\tArrayContainerBytes:  4,\n\t\t}\n\t\trr := NewBitmap()\n\t\trr.Add(2)\n\t\trr.Add(4)\n\n\t\tassert.EqualValues(t, expectedStats, rr.Stats())\n\t})\n}\n\nfunc TestFlipVerySmall(t *testing.T) {\n\trb := NewBitmap()\n\trb.Flip(0, 10) // got [0,9], card is 10\n\trb.Flip(0, 1)  // give back the number 0, card goes to 9\n\trbcard := rb.GetCardinality()\n\n\tassert.EqualValues(t, 9, rbcard)\n}\n\nfunc TestReverseIterator(t *testing.T) {\n\tt.Run(\"#1\", func(t *testing.T) {\n\t\tvalues := []uint32{0, 2, 15, 16, 31, 32, 33, 9999, MaxUint16, MaxUint32}\n\t\tbm := New()\n\t\tfor n := 0; n < len(values); n++ {\n\t\t\tbm.Add(values[n])\n\t\t}\n\t\ti := bm.ReverseIterator()\n\t\tn := len(values) - 1\n\n\t\tfor i.HasNext() {\n\t\t\tassert.EqualValues(t, i.Next(), values[n])\n\t\t\tn--\n\t\t}\n\n\t\t// HasNext() was terminating early - add test\n\t\ti = bm.ReverseIterator()\n\t\tn = len(values) - 1\n\t\tfor ; n >= 0; n-- {\n\t\t\tassert.EqualValues(t, i.Next(), values[n])\n\t\t\tassert.False(t, n > 0 && !i.HasNext())\n\t\t}\n\t})\n\n\tt.Run(\"#2\", func(t *testing.T) {\n\t\tbm := New()\n\t\ti := bm.ReverseIterator()\n\n\t\tassert.False(t, i.HasNext())\n\t})\n\n\tt.Run(\"#3\", func(t *testing.T) {\n\t\tbm := New()\n\t\tbm.AddInt(0)\n\t\ti := bm.ReverseIterator()\n\n\t\tassert.True(t, i.HasNext())\n\t\tassert.EqualValues(t, 0, i.Next())\n\t\tassert.False(t, i.HasNext())\n\t})\n\n\tt.Run(\"#4\", func(t *testing.T) {\n\t\tbm := New()\n\t\tbm.AddInt(9999)\n\t\ti := bm.ReverseIterator()\n\n\t\tassert.True(t, i.HasNext())\n\t\tassert.EqualValues(t, 9999, i.Next())\n\t\tassert.False(t, i.HasNext())\n\t})\n\n\tt.Run(\"#5\", func(t *testing.T) {\n\t\tbm := New()\n\t\tbm.AddInt(MaxUint16)\n\t\ti := bm.ReverseIterator()\n\n\t\tassert.True(t, i.HasNext())\n\t\tassert.EqualValues(t, MaxUint16, i.Next())\n\t\tassert.False(t, i.HasNext())\n\t})\n\n\tt.Run(\"#6\", func(t *testing.T) {\n\t\tbm := New()\n\t\tbm.Add(MaxUint32)\n\t\ti := bm.ReverseIterator()\n\n\t\tassert.True(t, i.HasNext())\n\t\tassert.EqualValues(t, uint32(MaxUint32), i.Next())\n\t\tassert.False(t, i.HasNext())\n\t})\n}\n\nfunc TestIteratorPeekNext(t *testing.T) {\n\tvalues := []uint32{0, 2, 15, 16, 31, 32, 33, 9999, MaxUint16, MaxUint32}\n\tbm := New()\n\n\tfor n := 0; n < len(values); n++ {\n\t\tbm.Add(values[n])\n\t}\n\n\ti := bm.Iterator()\n\tassert.True(t, i.HasNext())\n\n\tfor i.HasNext() {\n\t\tassert.Equal(t, i.PeekNext(), i.Next())\n\t}\n}\n\nfunc TestIteratorAdvance(t *testing.T) {\n\tvalues := []uint32{1, 2, 15, 16, 31, 32, 33, 9999, MaxUint16}\n\tbm := New()\n\n\tfor n := 0; n < len(values); n++ {\n\t\tbm.Add(values[n])\n\t}\n\n\tcases := []struct {\n\t\tminval   uint32\n\t\texpected uint32\n\t}{\n\t\t{0, 1},\n\t\t{1, 1},\n\t\t{2, 2},\n\t\t{3, 15},\n\t\t{30, 31},\n\t\t{33, 33},\n\t\t{9998, 9999},\n\t\t{MaxUint16, MaxUint16},\n\t}\n\n\tt.Run(\"advance by using a new int iterator\", func(t *testing.T) {\n\t\tfor _, c := range cases {\n\t\t\ti := bm.Iterator()\n\t\t\ti.AdvanceIfNeeded(c.minval)\n\n\t\t\tassert.True(t, i.HasNext())\n\t\t\tassert.Equal(t, c.expected, i.PeekNext())\n\t\t}\n\t})\n\n\tt.Run(\"advance by using the same int iterator\", func(t *testing.T) {\n\t\ti := bm.Iterator()\n\n\t\tfor _, c := range cases {\n\t\t\ti.AdvanceIfNeeded(c.minval)\n\n\t\t\tassert.True(t, i.HasNext())\n\t\t\tassert.Equal(t, c.expected, i.PeekNext())\n\t\t}\n\t})\n\n\tt.Run(\"advance out of a container value\", func(t *testing.T) {\n\t\ti := bm.Iterator()\n\n\t\ti.AdvanceIfNeeded(MaxUint32)\n\t\tassert.False(t, i.HasNext())\n\n\t\ti.AdvanceIfNeeded(MaxUint32)\n\t\tassert.False(t, i.HasNext())\n\t})\n\n\tt.Run(\"advance on a value that is less than the pointed value\", func(t *testing.T) {\n\t\ti := bm.Iterator()\n\t\ti.AdvanceIfNeeded(29)\n\n\t\tassert.True(t, i.HasNext())\n\t\tassert.EqualValues(t, 31, i.PeekNext())\n\n\t\ti.AdvanceIfNeeded(13)\n\n\t\tassert.True(t, i.HasNext())\n\t\tassert.EqualValues(t, 31, i.PeekNext())\n\t})\n}\n\nfunc TestPackageFlipMaxRangeEnd(t *testing.T) {\n\tvar empty Bitmap\n\tflipped := Flip(&empty, 0, MaxRange)\n\n\tassert.EqualValues(t, MaxRange, flipped.GetCardinality())\n}\n\nfunc TestBitmapFlipMaxRangeEnd(t *testing.T) {\n\tvar bm Bitmap\n\tbm.Flip(0, MaxRange)\n\n\tassert.EqualValues(t, MaxRange, bm.GetCardinality())\n}\n\nfunc TestIterate(t *testing.T) {\n\trb := NewBitmap()\n\n\tfor i := 0; i < 300; i++ {\n\t\trb.Add(uint32(i))\n\t}\n\n\tvar values []uint32\n\trb.Iterate(func(x uint32) bool {\n\t\tvalues = append(values, x)\n\t\treturn true\n\t})\n\n\tassert.Equal(t, rb.ToArray(), values)\n}\n\nfunc TestIterateCompressed(t *testing.T) {\n\trb := NewBitmap()\n\n\tfor i := 0; i < 300; i++ {\n\t\trb.Add(uint32(i))\n\t}\n\n\trb.RunOptimize()\n\n\tvar values []uint32\n\trb.Iterate(func(x uint32) bool {\n\t\tvalues = append(values, x)\n\t\treturn true\n\t})\n\n\tassert.Equal(t, rb.ToArray(), values)\n}\n\nfunc TestIterateLargeValues(t *testing.T) {\n\trb := NewBitmap()\n\n\t// This range of values ensures that all different types of containers will be used\n\tfor i := 150000; i < 450000; i++ {\n\t\trb.Add(uint32(i))\n\t}\n\n\tvar values []uint32\n\trb.Iterate(func(x uint32) bool {\n\t\tvalues = append(values, x)\n\t\treturn true\n\t})\n\n\tassert.Equal(t, rb.ToArray(), values)\n}\n\nfunc TestIterateHalt(t *testing.T) {\n\trb := NewBitmap()\n\n\t// This range of values ensures that all different types of containers will be used\n\tfor i := 150000; i < 450000; i++ {\n\t\trb.Add(uint32(i))\n\t}\n\n\tvar values []uint32\n\tcount := uint64(0)\n\tstopAt := rb.GetCardinality() - 1\n\trb.Iterate(func(x uint32) bool {\n\t\tvalues = append(values, x)\n\t\tcount++\n\t\tif count == stopAt {\n\t\t\treturn false\n\t\t}\n\t\treturn true\n\t})\n\n\texpected := rb.ToArray()\n\texpected = expected[0 : len(expected)-1]\n\tassert.Equal(t, expected, values)\n}\n\nfunc testDense(fn func(string, *Bitmap)) {\n\tbc := New()\n\tfor i := 0; i <= arrayDefaultMaxSize; i++ {\n\t\tbc.Add(uint32(1 + MaxUint16 + i*2))\n\t}\n\n\trc := New()\n\trc.AddRange(1, 2)\n\trc.AddRange(bc.GetCardinality(), bc.GetCardinality()*2)\n\n\tac := New()\n\tfor i := 1; i <= arrayDefaultMaxSize; i++ {\n\t\tac.Add(uint32(MaxUint16 + i*2))\n\t}\n\n\tbrc := New()\n\tfor i := 150000; i < 450000; i++ {\n\t\tbrc.Add(uint32(i))\n\t}\n\n\tfor _, tc := range []struct {\n\t\tname string\n\t\trb   *Bitmap\n\t}{\n\t\t{\"bitmap\", bc},\n\t\t{\"run\", rc},\n\t\t{\"array\", ac},\n\t\t{\"bitmaps-and-runs\", brc},\n\t} {\n\t\tfn(tc.name+\"-\"+strconv.FormatUint(tc.rb.GetCardinality(), 10), tc.rb)\n\t}\n}\n\nfunc TestToDense(t *testing.T) {\n\ttestDense(func(name string, rb *Bitmap) {\n\t\tt.Run(name, func(t *testing.T) {\n\t\t\tbm := bitset.From(rb.ToDense())\n\t\t\tassert.EqualValues(t, rb.GetCardinality(), uint64(bm.Count()))\n\t\t\trb.Iterate(func(x uint32) bool {\n\t\t\t\treturn assert.True(t, bm.Test(uint(x)), \"value %d should be set\", x)\n\t\t\t})\n\t\t})\n\t})\n}\n\nfunc TestFromDense(t *testing.T) {\n\ttestDense(func(name string, rb *Bitmap) {\n\t\tfor _, doCopy := range []bool{false, true} {\n\t\t\tt.Run(fmt.Sprintf(\"%s,doCopy=%t\", name, doCopy), func(t *testing.T) {\n\t\t\t\tdense := rb.ToDense()\n\t\t\t\tcp := FromDense(dense, doCopy)\n\t\t\t\tif doCopy {\n\t\t\t\t\t// Clear the original dense slice to ensure we don't have any\n\t\t\t\t\t// references to it\n\t\t\t\t\tfor i := range dense {\n\t\t\t\t\t\tdense[i] = 0\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tassert.True(t, rb.Equals(cp))\n\t\t\t})\n\t\t}\n\t})\n}\n\nfunc TestFromBitSet(t *testing.T) {\n\ttestDense(func(name string, rb *Bitmap) {\n\t\tt.Run(fmt.Sprintf(\"%s\", name), func(t *testing.T) {\n\t\t\tdense := rb.ToBitSet()\n\t\t\tcp := FromBitSet(dense)\n\t\t\tassert.True(t, rb.Equals(cp))\n\t\t})\n\t})\n}\n\nfunc TestRoaringArrayValidation(t *testing.T) {\n\ta := newRoaringArray()\n\n\tassert.ErrorIs(t, a.validate(), ErrEmptyKeys)\n\n\ta.keys = append(a.keys, uint16(3), uint16(1))\n\tassert.ErrorIs(t, a.validate(), ErrKeySortOrder)\n\ta.clear()\n\n\t// build up cardinality coherent arrays\n\ta.keys = append(a.keys, uint16(1), uint16(3), uint16(10))\n\tassert.ErrorIs(t, a.validate(), ErrCardinalityConstraint)\n\ta.containers = append(a.containers, &runContainer16{}, &runContainer16{}, &runContainer16{})\n\tassert.ErrorIs(t, a.validate(), ErrCardinalityConstraint)\n\ta.needCopyOnWrite = append(a.needCopyOnWrite, true, false, true)\n\tassert.Errorf(t, a.validate(), \"zero intervals\")\n}\n\nfunc TestBitMapValidation(t *testing.T) {\n\tbm := NewBitmap()\n\tbm.AddRange(0, 100)\n\tbm.AddRange(306, 406)\n\tbm.AddRange(102, 202)\n\tbm.AddRange(204, 304)\n\tassert.NoError(t, bm.Validate())\n\n\trandomEntries := make([]uint32, 0, 1000)\n\tfor i := 0; i < 1000; i++ {\n\t\trandomEntries = append(randomEntries, rand.Uint32())\n\t}\n\n\tbm.AddMany(randomEntries)\n\tassert.NoError(t, bm.Validate())\n\n\trandomEntries = make([]uint32, 0, 1000)\n\tfor i := 0; i < 1000; i++ {\n\t\trandomEntries = append(randomEntries, uint32(i))\n\t}\n\tbm.AddMany(randomEntries)\n\tassert.NoError(t, bm.Validate())\n}\n\nfunc TestBitMapValidationFromDeserialization(t *testing.T) {\n\t// To understand what is going on here, read https://github.com/RoaringBitmap/RoaringFormatSpec\n\t// Maintainers: The loader and corruptor are dependent on one another\n\t// The tests expect a certain size, with values at certain location.\n\t// The tests are geared toward single byte corruption.\n\n\t// There is no way to test Bitmap container corruption once the bitmap is deserialzied\n\n\tdeserializationTests := []struct {\n\t\tname      string\n\t\tloader    func(bm *Bitmap)\n\t\tcorruptor func(s []byte)\n\t\terr       error\n\t}{\n\t\t{\n\t\t\tname: \"Corrupts Run Length vs Num Runs\",\n\t\t\tloader: func(bm *Bitmap) {\n\t\t\t\tbm.AddRange(0, 2)\n\t\t\t\tbm.AddRange(4, 6)\n\t\t\t\tbm.AddRange(8, 100)\n\t\t\t},\n\t\t\tcorruptor: func(s []byte) {\n\t\t\t\t// 21 is the length of the run of the last run/range\n\t\t\t\t// Shortening causes interval sum to be to short\n\t\t\t\ts[21] = 1\n\t\t\t},\n\t\t\terr: ErrRunIntervalSize,\n\t\t},\n\t\t{\n\t\t\tname: \"Corrupts Run Length\",\n\t\t\tloader: func(bm *Bitmap) {\n\t\t\t\tbm.AddRange(100, 110)\n\t\t\t},\n\t\t\tcorruptor: func(s []byte) {\n\t\t\t\t// 13 is the length of the run\n\t\t\t\t// Setting to zero causes an invalid run\n\t\t\t\ts[13] = 0\n\t\t\t},\n\t\t\terr: ErrRunIntervalLength,\n\t\t},\n\t\t{\n\t\t\tname: \"Creates Interval Overlap\",\n\t\t\tloader: func(bm *Bitmap) {\n\t\t\t\tbm.AddRange(100, 110)\n\t\t\t\tbm.AddRange(115, 125)\n\t\t\t},\n\t\t\tcorruptor: func(s []byte) {\n\t\t\t\t// sets the start of the second run\n\t\t\t\t// Creates overlapping intervals\n\t\t\t\ts[15] = 108\n\t\t\t},\n\t\t\terr: ErrRunIntervalOverlap,\n\t\t},\n\t\t{\n\t\t\tname: \"Break Array Sort Order\",\n\t\t\tloader: func(bm *Bitmap) {\n\t\t\t\tarrayEntries := make([]uint32, 0, 10)\n\t\t\t\tfor i := 0; i < 10; i++ {\n\t\t\t\t\tarrayEntries = append(arrayEntries, uint32(i))\n\t\t\t\t}\n\t\t\t\tbm.AddMany(arrayEntries)\n\t\t\t},\n\t\t\tcorruptor: func(s []byte) {\n\t\t\t\t// breaks the sort order\n\t\t\t\ts[34] = 0\n\t\t\t},\n\t\t\terr: ErrArrayIncorrectSort,\n\t\t},\n\t}\n\n\tfor _, tt := range deserializationTests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tif err := recover(); err != nil {\n\t\t\t\t}\n\t\t\t}()\n\n\t\t\tbm := NewBitmap()\n\t\t\ttt.loader(bm)\n\t\t\tassert.NoError(t, bm.Validate())\n\t\t\tserialized, err := bm.ToBytes()\n\t\t\tassert.NoError(t, err)\n\t\t\ttt.corruptor(serialized)\n\t\t\tcorruptedDeserializedBitMap := NewBitmap()\n\t\t\tcorruptedDeserializedBitMap.ReadFrom(bytes.NewReader(serialized))\n\t\t\tassert.ErrorIs(t, corruptedDeserializedBitMap.Validate(), tt.err)\n\n\t\t\tcorruptedDeserializedBitMap = NewBitmap()\n\t\t\tcorruptedDeserializedBitMap.MustReadFrom(bytes.NewReader(serialized))\n\t\t\t// We will never hit this because of the recover\n\t\t\tt.Errorf(\"did not panic\")\n\t\t})\n\t}\n}\n\nfunc TestNextAndPreviousValue(t *testing.T) {\n\tt.Run(\"Java Regression1 \", func(t *testing.T) {\n\t\t// [Java1] https://github.com/RoaringBitmap/RoaringBitmap/blob/5235aa62c32fa3bf7fae40a562e3edc75f61be4e/RoaringBitmap/src/test/java/org/roaringbitmap/TestRunContainer.java#L3645\n\t\tbmp := New()\n\t\tbmp.AddRange(64, 129)\n\t\tassert.Equal(t, int64(64), bmp.NextValue(64))\n\t\tassert.Equal(t, int64(64), bmp.NextValue(0))\n\t\tassert.Equal(t, int64(64), bmp.NextValue(64))\n\t\tassert.Equal(t, int64(65), bmp.NextValue(65))\n\t\tassert.Equal(t, int64(128), bmp.NextValue(128))\n\t\tassert.Equal(t, int64(-1), bmp.NextValue(129))\n\n\t\tassert.Equal(t, int64(-1), bmp.PreviousValue(0))\n\t\tassert.Equal(t, int64(-1), bmp.PreviousValue(63))\n\t\tassert.Equal(t, int64(64), bmp.PreviousValue(64))\n\t\tassert.Equal(t, int64(65), bmp.PreviousValue(65))\n\t\tassert.Equal(t, int64(128), bmp.PreviousValue(128))\n\t\tassert.Equal(t, int64(128), bmp.PreviousValue(129))\n\n\t\tassert.Equal(t, int64(0), bmp.NextAbsentValue(0))\n\t\tassert.Equal(t, int64(63), bmp.NextAbsentValue(63))\n\t\tassert.Equal(t, int64(129), bmp.NextAbsentValue(64))\n\t\tassert.Equal(t, int64(129), bmp.NextAbsentValue(65))\n\t\tassert.Equal(t, int64(129), bmp.NextAbsentValue(128))\n\t\tassert.Equal(t, int64(129), bmp.NextAbsentValue(129))\n\n\t\tassert.Equal(t, int64(0), bmp.PreviousAbsentValue(0))\n\t\tassert.Equal(t, int64(63), bmp.PreviousAbsentValue(63))\n\t\tassert.Equal(t, int64(63), bmp.PreviousAbsentValue(64))\n\t\tassert.Equal(t, int64(63), bmp.PreviousAbsentValue(65))\n\t\tassert.Equal(t, int64(63), bmp.PreviousAbsentValue(128))\n\t})\n\tt.Run(\"Java Regression2\", func(t *testing.T) {\n\t\t// [Java2] https://github.com/RoaringBitmap/RoaringBitmap/blob/5235aa62c32fa3bf7fae40a562e3edc75f61be4e/RoaringBitmap/src/test/java/org/roaringbitmap/TestRunContainer.java#L3655\n\n\t\tbmp := New()\n\t\tbmp.AddRange(64, 129)\n\t\tbmp.AddRange(256, 256+64+1)\n\t\tassert.Equal(t, int64(64), bmp.NextValue(0))\n\t\tassert.Equal(t, int64(64), bmp.NextValue(64))\n\t\tassert.Equal(t, int64(65), bmp.NextValue(65))\n\t\tassert.Equal(t, int64(128), bmp.NextValue(128))\n\t\tassert.Equal(t, int64(256), bmp.NextValue(129))\n\t\tassert.Equal(t, int64(-1), bmp.NextValue(512))\n\n\t\tassert.Equal(t, int64(-1), bmp.PreviousValue(0))\n\t\tassert.Equal(t, int64(-1), bmp.PreviousValue(63))\n\t\tassert.Equal(t, int64(64), bmp.PreviousValue(64))\n\t\tassert.Equal(t, int64(65), bmp.PreviousValue(65))\n\t\tassert.Equal(t, int64(128), bmp.PreviousValue(128))\n\t\tassert.Equal(t, int64(128), bmp.PreviousValue(129))\n\t\tassert.Equal(t, int64(128), bmp.PreviousValue(199))\n\t\tassert.Equal(t, int64(128), bmp.PreviousValue(200))\n\t\tassert.Equal(t, int64(128), bmp.PreviousValue(250))\n\t\tassert.Equal(t, int64(256), bmp.PreviousValue(256))\n\t\tassert.Equal(t, int64(320), bmp.PreviousValue(2500))\n\n\t\tassert.Equal(t, int64(0), bmp.NextAbsentValue(0))\n\t\tassert.Equal(t, int64(63), bmp.NextAbsentValue(63))\n\t\tassert.Equal(t, int64(129), bmp.NextAbsentValue(64))\n\t\tassert.Equal(t, int64(129), bmp.NextAbsentValue(65))\n\t\tassert.Equal(t, int64(129), bmp.NextAbsentValue(128))\n\t\tassert.Equal(t, int64(129), bmp.NextAbsentValue(129))\n\t\tassert.Equal(t, int64(199), bmp.NextAbsentValue(199))\n\t\tassert.Equal(t, int64(200), bmp.NextAbsentValue(200))\n\t\tassert.Equal(t, int64(250), bmp.NextAbsentValue(250))\n\t\tassert.Equal(t, int64(321), bmp.NextAbsentValue(256))\n\t\tassert.Equal(t, int64(321), bmp.NextAbsentValue(320))\n\n\t\tassert.Equal(t, int64(0), bmp.PreviousAbsentValue(0))\n\t\tassert.Equal(t, int64(63), bmp.PreviousAbsentValue(63))\n\t\tassert.Equal(t, int64(63), bmp.PreviousAbsentValue(64))\n\t\tassert.Equal(t, int64(63), bmp.PreviousAbsentValue(65))\n\t\tassert.Equal(t, int64(63), bmp.PreviousAbsentValue(128))\n\t\tassert.Equal(t, int64(129), bmp.PreviousAbsentValue(129))\n\t\tassert.Equal(t, int64(199), bmp.PreviousAbsentValue(199))\n\t\tassert.Equal(t, int64(200), bmp.PreviousAbsentValue(200))\n\t\tassert.Equal(t, int64(250), bmp.PreviousAbsentValue(250))\n\t\tassert.Equal(t, int64(255), bmp.PreviousAbsentValue(256))\n\t\tassert.Equal(t, int64(255), bmp.PreviousAbsentValue(300))\n\t\tassert.Equal(t, int64(500), bmp.PreviousAbsentValue(500))\n\t\tassert.Equal(t, int64(501), bmp.PreviousAbsentValue(501))\n\t})\n\n\tt.Run(\"Java Regression3\", func(t *testing.T) {\n\t\t// [Java3] https://github.com/RoaringBitmap/RoaringBitmap/blob/5235aa62c32fa3bf7fae40a562e3edc75f61be4e/RoaringBitmap/src/test/java/org/roaringbitmap/TestRunContainer.java#L3666\n\n\t\tbmp := New()\n\t\tbmp.AddRange(64, 129)\n\t\tbmp.AddRange(200, 200+300+1)\n\t\tbmp.AddRange(5000, 5000+200+1)\n\t\tassert.Equal(t, int64(64), bmp.NextValue(0))\n\t\tassert.Equal(t, int64(64), bmp.NextValue(63))\n\t\tassert.Equal(t, int64(64), bmp.NextValue(64))\n\t\tassert.Equal(t, int64(65), bmp.NextValue(65))\n\t\tassert.Equal(t, int64(128), bmp.NextValue(128))\n\t\tassert.Equal(t, int64(200), bmp.NextValue(129))\n\t\tassert.Equal(t, int64(200), bmp.NextValue(199))\n\t\tassert.Equal(t, int64(200), bmp.NextValue(200))\n\t\tassert.Equal(t, int64(250), bmp.NextValue(250))\n\t\tassert.Equal(t, int64(5000), bmp.NextValue(2500))\n\t\tassert.Equal(t, int64(5000), bmp.NextValue(5000))\n\t\tassert.Equal(t, int64(5200), bmp.NextValue(5200))\n\t\tassert.Equal(t, int64(-1), bmp.NextValue(5201))\n\n\t\tassert.Equal(t, int64(-1), bmp.PreviousValue(0))\n\t\tassert.Equal(t, int64(-1), bmp.PreviousValue(63))\n\t\tassert.Equal(t, int64(64), bmp.PreviousValue(64))\n\t\tassert.Equal(t, int64(65), bmp.PreviousValue(65))\n\t\tassert.Equal(t, int64(128), bmp.PreviousValue(128))\n\t\tassert.Equal(t, int64(128), bmp.PreviousValue(129))\n\t\tassert.Equal(t, int64(128), bmp.PreviousValue(199))\n\t\tassert.Equal(t, int64(200), bmp.PreviousValue(200))\n\t\tassert.Equal(t, int64(250), bmp.PreviousValue(250))\n\t\tassert.Equal(t, int64(500), bmp.PreviousValue(2500))\n\t\tassert.Equal(t, int64(5000), bmp.PreviousValue(5000))\n\t\tassert.Equal(t, int64(5200), bmp.PreviousValue(5200))\n\t\tassert.Equal(t, int64(5200), bmp.PreviousValue(5201))\n\n\t\tassert.Equal(t, int64(0), bmp.NextAbsentValue(0))\n\t\tassert.Equal(t, int64(63), bmp.NextAbsentValue(63))\n\t\tassert.Equal(t, int64(129), bmp.NextAbsentValue(64))\n\t\tassert.Equal(t, int64(129), bmp.NextAbsentValue(65))\n\t\tassert.Equal(t, int64(129), bmp.NextAbsentValue(128))\n\t\tassert.Equal(t, int64(129), bmp.NextAbsentValue(129))\n\t\tassert.Equal(t, int64(199), bmp.NextAbsentValue(199))\n\t\tassert.Equal(t, int64(501), bmp.NextAbsentValue(200))\n\t\tassert.Equal(t, int64(501), bmp.NextAbsentValue(250))\n\t\tassert.Equal(t, int64(2500), bmp.NextAbsentValue(2500))\n\t\tassert.Equal(t, int64(5201), bmp.NextAbsentValue(5000))\n\t\tassert.Equal(t, int64(5201), bmp.NextAbsentValue(5200))\n\t\tassert.Equal(t, int64(5201), bmp.NextAbsentValue(5201))\n\n\t\tassert.Equal(t, int64(0), bmp.PreviousAbsentValue(0))\n\t\tassert.Equal(t, int64(63), bmp.PreviousAbsentValue(63))\n\t\tassert.Equal(t, int64(63), bmp.PreviousAbsentValue(64))\n\t\tassert.Equal(t, int64(63), bmp.PreviousAbsentValue(65))\n\t\tassert.Equal(t, int64(63), bmp.PreviousAbsentValue(128))\n\t\tassert.Equal(t, int64(129), bmp.PreviousAbsentValue(129))\n\t\tassert.Equal(t, int64(199), bmp.PreviousAbsentValue(199))\n\t\tassert.Equal(t, int64(199), bmp.PreviousAbsentValue(200))\n\t\tassert.Equal(t, int64(199), bmp.PreviousAbsentValue(250))\n\t\tassert.Equal(t, int64(2500), bmp.PreviousAbsentValue(2500))\n\t\tassert.Equal(t, int64(4999), bmp.PreviousAbsentValue(5000))\n\t\tassert.Equal(t, int64(4999), bmp.PreviousAbsentValue(5200))\n\t\tassert.Equal(t, int64(5201), bmp.PreviousAbsentValue(5201))\n\t})\n\n\tt.Run(\"skip odd \", func(t *testing.T) {\n\t\tbmp := New()\n\t\tfor i := 0; i < 2000; i++ {\n\t\t\tbmp.Add(uint32(i * 2))\n\t\t}\n\t\tfor i := 0; i < 2000; i++ {\n\t\t\tassert.Equal(t, int64(i*2), bmp.NextValue(uint32(i*2)))\n\t\t\tassert.Equal(t, int64(i*2), bmp.PreviousValue(uint32(i*2)))\n\t\t\tassert.Equal(t, int64(i*2+1), bmp.NextAbsentValue(uint32(i*2+1)))\n\n\t\t\tif i != 0 {\n\t\t\t\tassert.Equal(t, int64(i*2-1), bmp.PreviousAbsentValue(uint32(i*2)))\n\t\t\t}\n\t\t}\n\t})\n\n\tt.Run(\"Absent target container\", func(t *testing.T) {\n\t\tbmp := BitmapOf(2, 3, 131072, MaxUint32)\n\n\t\tassert.Equal(t, int64(3), bmp.PreviousValue(65536))\n\t\tassert.Equal(t, int64(131072), bmp.PreviousValue(MaxUint32>>1))\n\t\tassert.Equal(t, int64(131072), bmp.PreviousValue(MaxUint32-131071))\n\n\t\tbmp = BitmapOf(131072)\n\t\tassert.Equal(t, int64(-1), bmp.PreviousValue(65536))\n\t})\n\n\tt.Run(\"skipping with ranges\", func(t *testing.T) {\n\t\tbmp := New()\n\t\tintervalEnd := 512\n\t\trangeStart := intervalEnd * 2\n\t\trangeEnd := 2048\n\t\tfor i := 0; i < intervalEnd; i++ {\n\t\t\tbmp.Add(uint32(i * 2))\n\t\t}\n\t\tbmp.AddRange(uint64(rangeStart), uint64(rangeEnd))\n\n\t\tfor i := 0; i < intervalEnd; i++ {\n\t\t\tassert.Equal(t, int64(i*2), bmp.NextValue(uint32(i*2)))\n\t\t\tassert.Equal(t, int64(i*2), bmp.PreviousValue(uint32(i*2)))\n\t\t\tassert.Equal(t, int64(i*2+1), bmp.NextAbsentValue(uint32(i*2)))\n\t\t\tif i != 0 {\n\t\t\t\tassert.Equal(t, int64(i*2-1), bmp.PreviousAbsentValue(uint32(i*2)))\n\t\t\t}\n\t\t}\n\t\tfor i := rangeStart; i < rangeEnd; i++ {\n\t\t\tassert.Equal(t, int64(i), bmp.NextValue(uint32(i)))\n\t\t\tassert.Equal(t, int64(i), bmp.PreviousValue(uint32(i)))\n\t\t\tassert.Equal(t, int64(rangeEnd), bmp.NextAbsentValue(uint32(i)))\n\t\t\tassert.Equal(t, int64(rangeStart-1), bmp.PreviousAbsentValue(uint32((i))))\n\t\t}\n\t})\n\n\tt.Run(\"randomized\", func(t *testing.T) {\n\t\tbmp := New()\n\n\t\tintervalEnd := 4096\n\t\tentries := make([]uint32, 0, intervalEnd)\n\n\t\tfor i := 0; i < intervalEnd; i++ {\n\t\t\tentry := rand.Uint32()\n\t\t\tbmp.Add(entry)\n\t\t\tentries = append(entries, entry)\n\t\t}\n\n\t\tfor i := 0; i < intervalEnd; i++ {\n\t\t\tentry := entries[i]\n\t\t\tassert.Equal(t, int64(entry), bmp.NextValue(entry))\n\t\t\tassert.Equal(t, int64(entry), bmp.PreviousValue(entry))\n\t\t\tassert.NotEqual(t, int64(entry), bmp.NextAbsentValue(entry))\n\t\t\tassert.NotEqual(t, int64(entry), bmp.PreviousAbsentValue(entry))\n\n\t\t}\n\t})\n}\n\nfunc BenchmarkFromDense(b *testing.B) {\n\ttestDense(func(name string, rb *Bitmap) {\n\t\tdense := make([]uint64, rb.DenseSize())\n\t\trb.WriteDenseTo(dense)\n\t\tcp := FromDense(dense, false)\n\n\t\tfor _, doCopy := range []bool{false, true} {\n\t\t\tb.Run(fmt.Sprintf(\"%s,doCopy=%t\", name, doCopy), func(b *testing.B) {\n\t\t\t\tb.ReportAllocs()\n\t\t\t\tb.SetBytes(int64(len(dense) * 8))\n\t\t\t\tb.ResetTimer()\n\t\t\t\tfor i := 0; i < b.N; i++ {\n\t\t\t\t\tcp.FromDense(dense, doCopy)\n\t\t\t\t\tcp.Clear()\n\t\t\t\t}\n\t\t\t})\n\t\t}\n\t})\n}\n\nfunc BenchmarkWriteDenseTo(b *testing.B) {\n\ttestDense(func(name string, rb *Bitmap) {\n\t\tb.Run(name, func(b *testing.B) {\n\t\t\tdense := make([]uint64, rb.DenseSize())\n\t\t\tb.ReportAllocs()\n\t\t\tb.SetBytes(int64(len(dense) * 8))\n\t\t\tb.ResetTimer()\n\t\t\tfor i := 0; i < b.N; i++ {\n\t\t\t\trb.WriteDenseTo(dense)\n\t\t\t}\n\t\t})\n\t})\n}\n\nfunc BenchmarkEvenIntervalArrayUnions(b *testing.B) {\n\tinputBitmaps := make([]*Bitmap, 40)\n\tfor i := 0; i < 40; i++ {\n\t\tbitmap := NewBitmap()\n\t\tfor j := 0; j < 100; j++ {\n\t\t\tbitmap.Add(uint32(2 * (j + 10*i)))\n\t\t}\n\t\tinputBitmaps[i] = bitmap\n\t}\n\n\tb.ResetTimer()\n\tb.ReportAllocs()\n\tfor i := 0; i < b.N; i++ {\n\t\tbitmap := NewBitmap()\n\t\tfor _, input := range inputBitmaps {\n\t\t\tbitmap.Or(input)\n\t\t}\n\t}\n}\n\nfunc BenchmarkInPlaceArrayUnions(b *testing.B) {\n\trand.Seed(100)\n\tb.ReportAllocs()\n\tcomponentBitmaps := make([]*Bitmap, 100)\n\tfor i := 0; i < 100; i++ {\n\t\tbitmap := NewBitmap()\n\t\tfor j := 0; j < 100; j++ {\n\t\t\t// keep all entries in [0,4096), so they stay arrays.\n\t\t\tbitmap.Add(uint32(rand.Intn(arrayDefaultMaxSize)))\n\t\t}\n\t\tcomponentBitmaps[i] = bitmap\n\t}\n\tb.ResetTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\tbitmap := NewBitmap()\n\t\tfor j := 0; j < 100; j++ {\n\t\t\tbitmap.Or(componentBitmaps[rand.Intn(100)])\n\t\t}\n\t}\n}\n\nfunc BenchmarkAntagonisticArrayUnionsGrowth(b *testing.B) {\n\tleft := NewBitmap()\n\tright := NewBitmap()\n\tfor i := 0; i < 4096; i++ {\n\t\tleft.Add(uint32(2 * i))\n\t\tright.Add(uint32(2*i + 1))\n\t}\n\tb.ReportAllocs()\n\tb.ResetTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\tleft.Clone().Or(right)\n\t}\n}\n\nfunc BenchmarkRepeatedGrowthArrayUnion(b *testing.B) {\n\tb.ReportAllocs()\n\tfor i := 0; i < b.N; i++ {\n\t\tsink := NewBitmap()\n\t\tsource := NewBitmap()\n\t\tfor i := 0; i < 2048; i++ {\n\t\t\tsource.Add(uint32(2 * i))\n\t\t\tsink.Or(source)\n\t\t}\n\t}\n}\n\nfunc BenchmarkRepeatedSelfArrayUnion(b *testing.B) {\n\tbitmap := NewBitmap()\n\tfor i := 0; i < 4096; i++ {\n\t\tbitmap.Add(uint32(2 * i))\n\t}\n\tb.ReportAllocs()\n\tb.ResetTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\treceiver := NewBitmap()\n\t\tfor j := 0; j < 1000; j++ {\n\t\t\treceiver.Or(bitmap)\n\t\t}\n\t}\n}\n\n// BenchmarkArrayIorMergeThreshold tests performance\n// when unioning two array containers when the cardinality sum is over 4096\nfunc BenchmarkArrayUnionThreshold(b *testing.B) {\n\ttestOddPoint := map[string]int{\n\t\t\"mostly-overlap\": 4900,\n\t\t\"little-overlap\": 2000,\n\t\t\"no-overlap\":     0,\n\t}\n\tfor name, oddPoint := range testOddPoint {\n\t\tb.Run(name, func(b *testing.B) {\n\t\t\tleft := NewBitmap()\n\t\t\tright := NewBitmap()\n\t\t\tfor i := 0; i < 5000; i++ {\n\t\t\t\tif i%2 == 0 {\n\t\t\t\t\tleft.Add(uint32(i))\n\t\t\t\t}\n\t\t\t\tif i%2 == 0 && i < oddPoint {\n\t\t\t\t\tright.Add(uint32(i))\n\t\t\t\t} else if i%2 == 1 && i >= oddPoint {\n\t\t\t\t\tright.Add(uint32(i))\n\t\t\t\t}\n\t\t\t}\n\t\t\tb.ResetTimer()\n\t\t\tb.ReportAllocs()\n\t\t\tfor i := 0; i < b.N; i++ {\n\t\t\t\tright.Clone().Or(left)\n\t\t\t}\n\t\t})\n\t}\n}\n"
        },
        {
          "name": "roaringarray.go",
          "type": "blob",
          "size": 21.62109375,
          "content": "package roaring\n\nimport (\n\t\"bytes\"\n\t\"encoding/binary\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\n\t\"github.com/RoaringBitmap/roaring/v2/internal\"\n)\n\ntype container interface {\n\t// addOffset returns the (low, high) parts of the shifted container.\n\t// Whenever one of them would be empty, nil will be returned instead to\n\t// avoid unnecessary allocations.\n\taddOffset(uint16) (container, container)\n\n\tclone() container\n\tand(container) container\n\tandCardinality(container) int\n\tiand(container) container // i stands for inplace\n\tandNot(container) container\n\tiandNot(container) container // i stands for inplace\n\tisEmpty() bool\n\tgetCardinality() int\n\t// rank returns the number of integers that are\n\t// smaller or equal to x. rank(infinity) would be getCardinality().\n\trank(uint16) int\n\n\tiadd(x uint16) bool                   // inplace, returns true if x was new.\n\tiaddReturnMinimized(uint16) container // may change return type to minimize storage.\n\n\tiaddRange(start, endx int) container // i stands for inplace, range is [firstOfRange,endx)\n\n\tiremove(x uint16) bool                   // inplace, returns true if x was present.\n\tiremoveReturnMinimized(uint16) container // may change return type to minimize storage.\n\n\tnot(start, final int) container        // range is [firstOfRange,lastOfRange)\n\tinot(firstOfRange, endx int) container // i stands for inplace, range is [firstOfRange,endx)\n\txor(r container) container\n\tgetShortIterator() shortPeekable\n\titerate(cb func(x uint16) bool) bool\n\tgetReverseIterator() shortIterable\n\tgetManyIterator() manyIterable\n\tcontains(i uint16) bool\n\tmaximum() uint16\n\tminimum() uint16\n\n\t// equals is now logical equals; it does not require the\n\t// same underlying container types, but compares across\n\t// any of the implementations.\n\tequals(r container) bool\n\n\tfillLeastSignificant16bits(array []uint32, i int, mask uint32) int\n\tor(r container) container\n\torCardinality(r container) int\n\tisFull() bool\n\tior(r container) container   // i stands for inplace\n\tintersects(r container) bool // whether the two containers intersect\n\tlazyOR(r container) container\n\tlazyIOR(r container) container\n\tgetSizeInBytes() int\n\tiremoveRange(start, final int) container // i stands for inplace, range is [firstOfRange,lastOfRange)\n\tselectInt(x uint16) int                  // selectInt returns the xth integer in the container\n\tserializedSizeInBytes() int\n\twriteTo(io.Writer) (int, error)\n\n\tnumberOfRuns() int\n\ttoEfficientContainer() container\n\tString() string\n\tcontainerType() contype\n\n\tsafeMinimum() (uint16, error)\n\tsafeMaximum() (uint16, error)\n\tnextValue(x uint16) int\n\tpreviousValue(x uint16) int\n\tnextAbsentValue(x uint16) int\n\tpreviousAbsentValue(x uint16) int\n\tvalidate() error\n}\n\ntype contype uint8\n\nconst (\n\tbitmapContype contype = iota\n\tarrayContype\n\trun16Contype\n\trun32Contype\n)\n\nvar (\n\tErrEmptyKeys             = errors.New(\"keys were empty\")\n\tErrKeySortOrder          = errors.New(\"keys were out of order\")\n\tErrCardinalityConstraint = errors.New(\"size of arrays was not coherent\")\n)\n\n// careful: range is [firstOfRange,lastOfRange]\nfunc rangeOfOnes(start, last int) container {\n\tif start > MaxUint16 {\n\t\tpanic(\"rangeOfOnes called with start > MaxUint16\")\n\t}\n\tif last > MaxUint16 {\n\t\tpanic(\"rangeOfOnes called with last > MaxUint16\")\n\t}\n\tif start < 0 {\n\t\tpanic(\"rangeOfOnes called with start < 0\")\n\t}\n\tif last < 0 {\n\t\tpanic(\"rangeOfOnes called with last < 0\")\n\t}\n\treturn newRunContainer16Range(uint16(start), uint16(last))\n}\n\ntype roaringArray struct {\n\tkeys            []uint16\n\tcontainers      []container `msg:\"-\"` // don't try to serialize directly.\n\tneedCopyOnWrite []bool\n\tcopyOnWrite     bool\n}\n\nfunc newRoaringArray() *roaringArray {\n\treturn &roaringArray{}\n}\n\n// runOptimize compresses the element containers to minimize space consumed.\n// Q: how does this interact with copyOnWrite and needCopyOnWrite?\n// A: since we aren't changing the logical content, just the representation,\n//\n//\twe don't bother to check the needCopyOnWrite bits. We replace\n//\t(possibly all) elements of ra.containers in-place with space\n//\toptimized versions.\nfunc (ra *roaringArray) runOptimize() {\n\tfor i := range ra.containers {\n\t\tra.containers[i] = ra.containers[i].toEfficientContainer()\n\t}\n}\n\nfunc (ra *roaringArray) appendContainer(key uint16, value container, mustCopyOnWrite bool) {\n\tra.keys = append(ra.keys, key)\n\tra.containers = append(ra.containers, value)\n\tra.needCopyOnWrite = append(ra.needCopyOnWrite, mustCopyOnWrite)\n}\n\nfunc (ra *roaringArray) appendWithoutCopy(sa roaringArray, startingindex int) {\n\tmustCopyOnWrite := sa.needCopyOnWrite[startingindex]\n\tra.appendContainer(sa.keys[startingindex], sa.containers[startingindex], mustCopyOnWrite)\n}\n\nfunc (ra *roaringArray) appendCopy(sa roaringArray, startingindex int) {\n\t// cow only if the two request it, or if we already have a lightweight copy\n\tcopyonwrite := (ra.copyOnWrite && sa.copyOnWrite) || sa.needsCopyOnWrite(startingindex)\n\tif !copyonwrite {\n\t\t// since there is no copy-on-write, we need to clone the container (this is important)\n\t\tra.appendContainer(sa.keys[startingindex], sa.containers[startingindex].clone(), copyonwrite)\n\t} else {\n\t\tra.appendContainer(sa.keys[startingindex], sa.containers[startingindex], copyonwrite)\n\t\tif !sa.needsCopyOnWrite(startingindex) {\n\t\t\tsa.setNeedsCopyOnWrite(startingindex)\n\t\t}\n\t}\n}\n\nfunc (ra *roaringArray) appendWithoutCopyMany(sa roaringArray, startingindex, end int) {\n\tfor i := startingindex; i < end; i++ {\n\t\tra.appendWithoutCopy(sa, i)\n\t}\n}\n\nfunc (ra *roaringArray) appendCopyMany(sa roaringArray, startingindex, end int) {\n\tfor i := startingindex; i < end; i++ {\n\t\tra.appendCopy(sa, i)\n\t}\n}\n\nfunc (ra *roaringArray) appendCopiesUntil(sa roaringArray, stoppingKey uint16) {\n\t// cow only if the two request it, or if we already have a lightweight copy\n\tcopyonwrite := ra.copyOnWrite && sa.copyOnWrite\n\n\tfor i := 0; i < sa.size(); i++ {\n\t\tif sa.keys[i] >= stoppingKey {\n\t\t\tbreak\n\t\t}\n\t\tthiscopyonewrite := copyonwrite || sa.needsCopyOnWrite(i)\n\t\tif thiscopyonewrite {\n\t\t\tra.appendContainer(sa.keys[i], sa.containers[i], thiscopyonewrite)\n\t\t\tif !sa.needsCopyOnWrite(i) {\n\t\t\t\tsa.setNeedsCopyOnWrite(i)\n\t\t\t}\n\n\t\t} else {\n\t\t\t// since there is no copy-on-write, we need to clone the container (this is important)\n\t\t\tra.appendContainer(sa.keys[i], sa.containers[i].clone(), thiscopyonewrite)\n\t\t}\n\t}\n}\n\nfunc (ra *roaringArray) appendCopiesAfter(sa roaringArray, beforeStart uint16) {\n\t// cow only if the two request it, or if we already have a lightweight copy\n\tcopyonwrite := ra.copyOnWrite && sa.copyOnWrite\n\n\tstartLocation := sa.getIndex(beforeStart)\n\tif startLocation >= 0 {\n\t\tstartLocation++\n\t} else {\n\t\tstartLocation = -startLocation - 1\n\t}\n\n\tfor i := startLocation; i < sa.size(); i++ {\n\t\tthiscopyonewrite := copyonwrite || sa.needsCopyOnWrite(i)\n\t\tif thiscopyonewrite {\n\t\t\tra.appendContainer(sa.keys[i], sa.containers[i], thiscopyonewrite)\n\t\t\tif !sa.needsCopyOnWrite(i) {\n\t\t\t\tsa.setNeedsCopyOnWrite(i)\n\t\t\t}\n\t\t} else {\n\t\t\t// since there is no copy-on-write, we need to clone the container (this is important)\n\t\t\tra.appendContainer(sa.keys[i], sa.containers[i].clone(), thiscopyonewrite)\n\t\t}\n\t}\n}\n\nfunc (ra *roaringArray) removeIndexRange(begin, end int) {\n\tif end <= begin {\n\t\treturn\n\t}\n\n\tr := end - begin\n\n\tcopy(ra.keys[begin:], ra.keys[end:])\n\tcopy(ra.containers[begin:], ra.containers[end:])\n\tcopy(ra.needCopyOnWrite[begin:], ra.needCopyOnWrite[end:])\n\n\tra.resize(len(ra.keys) - r)\n}\n\nfunc (ra *roaringArray) resize(newsize int) {\n\tfor k := newsize; k < len(ra.containers); k++ {\n\t\tra.containers[k] = nil\n\t}\n\n\tra.keys = ra.keys[:newsize]\n\tra.containers = ra.containers[:newsize]\n\tra.needCopyOnWrite = ra.needCopyOnWrite[:newsize]\n}\n\nfunc (ra *roaringArray) clear() {\n\tra.resize(0)\n\tra.copyOnWrite = false\n}\n\nfunc (ra *roaringArray) clone() *roaringArray {\n\tsa := roaringArray{}\n\tsa.copyOnWrite = ra.copyOnWrite\n\n\t// this is where copyOnWrite is used.\n\tif ra.copyOnWrite {\n\t\tsa.keys = make([]uint16, len(ra.keys))\n\t\tcopy(sa.keys, ra.keys)\n\t\tsa.containers = make([]container, len(ra.containers))\n\t\tcopy(sa.containers, ra.containers)\n\t\tsa.needCopyOnWrite = make([]bool, len(ra.needCopyOnWrite))\n\n\t\tra.markAllAsNeedingCopyOnWrite()\n\t\tsa.markAllAsNeedingCopyOnWrite()\n\n\t\t// sa.needCopyOnWrite is shared\n\t} else {\n\t\t// make a full copy\n\n\t\tsa.keys = make([]uint16, len(ra.keys))\n\t\tcopy(sa.keys, ra.keys)\n\n\t\tsa.containers = make([]container, len(ra.containers))\n\t\tfor i := range sa.containers {\n\t\t\tsa.containers[i] = ra.containers[i].clone()\n\t\t}\n\n\t\tsa.needCopyOnWrite = make([]bool, len(ra.needCopyOnWrite))\n\t}\n\treturn &sa\n}\n\n// clone all containers which have needCopyOnWrite set to true\n// This can be used to make sure it is safe to munmap a []byte\n// that the roaring array may still have a reference to.\nfunc (ra *roaringArray) cloneCopyOnWriteContainers() {\n\tfor i, needCopyOnWrite := range ra.needCopyOnWrite {\n\t\tif needCopyOnWrite {\n\t\t\tra.containers[i] = ra.containers[i].clone()\n\t\t\tra.needCopyOnWrite[i] = false\n\t\t}\n\t}\n}\n\n// unused function:\n//func (ra *roaringArray) containsKey(x uint16) bool {\n//\treturn (ra.binarySearch(0, int64(len(ra.keys)), x) >= 0)\n//}\n\n// getContainer returns the container with key `x`\n// if no such container exists `nil` is returned\nfunc (ra *roaringArray) getContainer(x uint16) container {\n\ti := ra.binarySearch(0, int64(len(ra.keys)), x)\n\tif i < 0 {\n\t\treturn nil\n\t}\n\treturn ra.containers[i]\n}\n\nfunc (ra *roaringArray) getContainerAtIndex(i int) container {\n\treturn ra.containers[i]\n}\n\nfunc (ra *roaringArray) getFastContainerAtIndex(i int, needsWriteable bool) container {\n\tc := ra.getContainerAtIndex(i)\n\tswitch t := c.(type) {\n\tcase *arrayContainer:\n\t\tc = t.toBitmapContainer()\n\tcase *runContainer16:\n\t\tif !t.isFull() {\n\t\t\tc = t.toBitmapContainer()\n\t\t}\n\tcase *bitmapContainer:\n\t\tif needsWriteable && ra.needCopyOnWrite[i] {\n\t\t\tc = ra.containers[i].clone()\n\t\t}\n\t}\n\treturn c\n}\n\n// getUnionedWritableContainer switches behavior for in-place Or\n// depending on whether the container requires a copy on write.\n// If it does using the non-inplace or() method leads to fewer allocations.\nfunc (ra *roaringArray) getUnionedWritableContainer(pos int, other container) container {\n\tif ra.needCopyOnWrite[pos] {\n\t\treturn ra.getContainerAtIndex(pos).or(other)\n\t}\n\treturn ra.getContainerAtIndex(pos).ior(other)\n}\n\nfunc (ra *roaringArray) getWritableContainerAtIndex(i int) container {\n\tif ra.needCopyOnWrite[i] {\n\t\tra.containers[i] = ra.containers[i].clone()\n\t\tra.needCopyOnWrite[i] = false\n\t}\n\treturn ra.containers[i]\n}\n\n// getIndex returns the index of the container with key `x`\n// if no such container exists a negative value is returned\nfunc (ra *roaringArray) getIndex(x uint16) int {\n\t// Todo : test\n\t// before the binary search, we optimize for frequent cases\n\tsize := len(ra.keys)\n\tif (size == 0) || (ra.keys[size-1] == x) {\n\t\treturn size - 1\n\t}\n\treturn ra.binarySearch(0, int64(size), x)\n}\n\nfunc (ra *roaringArray) getKeyAtIndex(i int) uint16 {\n\treturn ra.keys[i]\n}\n\nfunc (ra *roaringArray) insertNewKeyValueAt(i int, key uint16, value container) {\n\tra.keys = append(ra.keys, 0)\n\tra.containers = append(ra.containers, nil)\n\n\tcopy(ra.keys[i+1:], ra.keys[i:])\n\tcopy(ra.containers[i+1:], ra.containers[i:])\n\n\tra.keys[i] = key\n\tra.containers[i] = value\n\n\tra.needCopyOnWrite = append(ra.needCopyOnWrite, false)\n\tcopy(ra.needCopyOnWrite[i+1:], ra.needCopyOnWrite[i:])\n\tra.needCopyOnWrite[i] = false\n}\n\nfunc (ra *roaringArray) remove(key uint16) bool {\n\ti := ra.binarySearch(0, int64(len(ra.keys)), key)\n\tif i >= 0 { // if a new key\n\t\tra.removeAtIndex(i)\n\t\treturn true\n\t}\n\treturn false\n}\n\nfunc (ra *roaringArray) removeAtIndex(i int) {\n\tcopy(ra.keys[i:], ra.keys[i+1:])\n\tcopy(ra.containers[i:], ra.containers[i+1:])\n\n\tcopy(ra.needCopyOnWrite[i:], ra.needCopyOnWrite[i+1:])\n\n\tra.resize(len(ra.keys) - 1)\n}\n\nfunc (ra *roaringArray) setContainerAtIndex(i int, c container) {\n\tra.containers[i] = c\n}\n\nfunc (ra *roaringArray) replaceKeyAndContainerAtIndex(i int, key uint16, c container, mustCopyOnWrite bool) {\n\tra.keys[i] = key\n\tra.containers[i] = c\n\tra.needCopyOnWrite[i] = mustCopyOnWrite\n}\n\nfunc (ra *roaringArray) size() int {\n\treturn len(ra.keys)\n}\n\n// binarySearch returns the index of the key.\n// negative value returned if not found\nfunc (ra *roaringArray) binarySearch(begin, end int64, ikey uint16) int {\n\t// TODO: add unit tests\n\tlow := begin\n\thigh := end - 1\n\tfor low+16 <= high {\n\t\tmiddleIndex := low + (high-low)/2 // avoid overflow\n\t\tmiddleValue := ra.keys[middleIndex]\n\n\t\tif middleValue < ikey {\n\t\t\tlow = middleIndex + 1\n\t\t} else if middleValue > ikey {\n\t\t\thigh = middleIndex - 1\n\t\t} else {\n\t\t\treturn int(middleIndex)\n\t\t}\n\t}\n\tfor ; low <= high; low++ {\n\t\tval := ra.keys[low]\n\t\tif val >= ikey {\n\t\t\tif val == ikey {\n\t\t\t\treturn int(low)\n\t\t\t}\n\t\t\tbreak\n\t\t}\n\t}\n\treturn -int(low + 1)\n}\n\nfunc (ra *roaringArray) equals(o interface{}) bool {\n\tsrb, ok := o.(roaringArray)\n\tif ok {\n\n\t\tif srb.size() != ra.size() {\n\t\t\treturn false\n\t\t}\n\t\tfor i, k := range ra.keys {\n\t\t\tif k != srb.keys[i] {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\n\t\tfor i, c := range ra.containers {\n\t\t\tif !c.equals(srb.containers[i]) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\t}\n\treturn false\n}\n\nfunc (ra *roaringArray) headerSize() uint64 {\n\tsize := uint64(len(ra.keys))\n\tif ra.hasRunCompression() {\n\t\tif size < noOffsetThreshold { // for small bitmaps, we omit the offsets\n\t\t\treturn 4 + (size+7)/8 + 4*size\n\t\t}\n\t\treturn 4 + (size+7)/8 + 8*size // - 4 because we pack the size with the cookie\n\t}\n\treturn 4 + 4 + 8*size\n}\n\n// should be dirt cheap\nfunc (ra *roaringArray) serializedSizeInBytes() uint64 {\n\tanswer := ra.headerSize()\n\tfor _, c := range ra.containers {\n\t\tanswer += uint64(c.serializedSizeInBytes())\n\t}\n\treturn answer\n}\n\n// spec: https://github.com/RoaringBitmap/RoaringFormatSpec\nfunc (ra *roaringArray) writeTo(w io.Writer) (n int64, err error) {\n\thasRun := ra.hasRunCompression()\n\tisRunSizeInBytes := 0\n\tcookieSize := 8\n\tif hasRun {\n\t\tcookieSize = 4\n\t\tisRunSizeInBytes = (len(ra.keys) + 7) / 8\n\t}\n\tdescriptiveHeaderSize := 4 * len(ra.keys)\n\tpreambleSize := cookieSize + isRunSizeInBytes + descriptiveHeaderSize\n\n\tbuf := make([]byte, preambleSize+4*len(ra.keys))\n\n\tnw := 0\n\n\tif hasRun {\n\t\tbinary.LittleEndian.PutUint16(buf[0:], uint16(serialCookie))\n\t\tnw += 2\n\t\tbinary.LittleEndian.PutUint16(buf[2:], uint16(len(ra.keys)-1))\n\t\tnw += 2\n\t\t// compute isRun bitmap without temporary allocation\n\t\trunbitmapslice := buf[nw : nw+isRunSizeInBytes]\n\t\tfor i, c := range ra.containers {\n\t\t\tswitch c.(type) {\n\t\t\tcase *runContainer16:\n\t\t\t\trunbitmapslice[i/8] |= 1 << (uint(i) % 8)\n\t\t\t}\n\t\t}\n\t\tnw += isRunSizeInBytes\n\t} else {\n\t\tbinary.LittleEndian.PutUint32(buf[0:], uint32(serialCookieNoRunContainer))\n\t\tnw += 4\n\t\tbinary.LittleEndian.PutUint32(buf[4:], uint32(len(ra.keys)))\n\t\tnw += 4\n\t}\n\n\t// descriptive header\n\tfor i, key := range ra.keys {\n\t\tbinary.LittleEndian.PutUint16(buf[nw:], key)\n\t\tnw += 2\n\t\tc := ra.containers[i]\n\t\tbinary.LittleEndian.PutUint16(buf[nw:], uint16(c.getCardinality()-1))\n\t\tnw += 2\n\t}\n\n\tstartOffset := int64(preambleSize + 4*len(ra.keys))\n\tif !hasRun || (len(ra.keys) >= noOffsetThreshold) {\n\t\t// offset header\n\t\tfor _, c := range ra.containers {\n\t\t\tbinary.LittleEndian.PutUint32(buf[nw:], uint32(startOffset))\n\t\t\tnw += 4\n\t\t\tswitch rc := c.(type) {\n\t\t\tcase *runContainer16:\n\t\t\t\tstartOffset += 2 + int64(len(rc.iv))*4\n\t\t\tdefault:\n\t\t\t\tstartOffset += int64(getSizeInBytesFromCardinality(c.getCardinality()))\n\t\t\t}\n\t\t}\n\t}\n\n\twritten, err := w.Write(buf[:nw])\n\tif err != nil {\n\t\treturn n, err\n\t}\n\tn += int64(written)\n\n\tfor _, c := range ra.containers {\n\t\twritten, err := c.writeTo(w)\n\t\tif err != nil {\n\t\t\treturn n, err\n\t\t}\n\t\tn += int64(written)\n\t}\n\treturn n, nil\n}\n\n// spec: https://github.com/RoaringBitmap/RoaringFormatSpec\nfunc (ra *roaringArray) toBytes() ([]byte, error) {\n\tvar buf bytes.Buffer\n\t_, err := ra.writeTo(&buf)\n\treturn buf.Bytes(), err\n}\n\n// Reads a serialized roaringArray from a byte slice.\nfunc (ra *roaringArray) readFrom(stream internal.ByteInput, cookieHeader ...byte) (int64, error) {\n\tvar cookie uint32\n\tvar err error\n\tif len(cookieHeader) > 0 && len(cookieHeader) != 4 {\n\t\treturn int64(len(cookieHeader)), fmt.Errorf(\"error in roaringArray.readFrom: could not read initial cookie: incorrect size of cookie header\")\n\t}\n\tif len(cookieHeader) == 4 {\n\t\tcookie = binary.LittleEndian.Uint32(cookieHeader)\n\t} else {\n\t\tcookie, err = stream.ReadUInt32()\n\t\tif err != nil {\n\t\t\treturn stream.GetReadBytes(), fmt.Errorf(\"error in roaringArray.readFrom: could not read initial cookie: %s\", err)\n\t\t}\n\t}\n\t// If NextReturnsSafeSlice is false, then willNeedCopyOnWrite should be true\n\twillNeedCopyOnWrite := !stream.NextReturnsSafeSlice()\n\n\tvar size uint32\n\tvar isRunBitmap []byte\n\n\tif cookie&0x0000FFFF == serialCookie {\n\t\tsize = uint32(cookie>>16 + 1)\n\t\t// create is-run-container bitmap\n\t\tisRunBitmapSize := (int(size) + 7) / 8\n\t\tisRunBitmap, err = stream.Next(isRunBitmapSize)\n\t\tif err != nil {\n\t\t\treturn stream.GetReadBytes(), fmt.Errorf(\"malformed bitmap, failed to read is-run bitmap, got: %s\", err)\n\t\t}\n\t} else if cookie == serialCookieNoRunContainer {\n\t\tsize, err = stream.ReadUInt32()\n\t\tif err != nil {\n\t\t\treturn stream.GetReadBytes(), fmt.Errorf(\"malformed bitmap, failed to read a bitmap size: %s\", err)\n\t\t}\n\t} else {\n\t\treturn stream.GetReadBytes(), fmt.Errorf(\"error in roaringArray.readFrom: did not find expected serialCookie in header\")\n\t}\n\n\tif size > (1 << 16) {\n\t\treturn stream.GetReadBytes(), fmt.Errorf(\"it is logically impossible to have more than (1<<16) containers\")\n\t}\n\n\t// descriptive header\n\tbuf, err := stream.Next(2 * 2 * int(size))\n\tif err != nil {\n\t\treturn stream.GetReadBytes(), fmt.Errorf(\"failed to read descriptive header: %s\", err)\n\t}\n\n\tkeycard := byteSliceAsUint16Slice(buf)\n\n\tif isRunBitmap == nil || size >= noOffsetThreshold {\n\t\tif err := stream.SkipBytes(int(size) * 4); err != nil {\n\t\t\treturn stream.GetReadBytes(), fmt.Errorf(\"failed to skip bytes: %s\", err)\n\t\t}\n\t}\n\n\t// Allocate slices upfront as number of containers is known\n\tif cap(ra.containers) >= int(size) {\n\t\tra.containers = ra.containers[:size]\n\t} else {\n\t\tra.containers = make([]container, size)\n\t}\n\n\tif cap(ra.keys) >= int(size) {\n\t\tra.keys = ra.keys[:size]\n\t} else {\n\t\tra.keys = make([]uint16, size)\n\t}\n\n\tif cap(ra.needCopyOnWrite) >= int(size) {\n\t\tra.needCopyOnWrite = ra.needCopyOnWrite[:size]\n\t} else {\n\t\tra.needCopyOnWrite = make([]bool, size)\n\t}\n\n\tfor i := uint32(0); i < size; i++ {\n\t\tkey := keycard[2*i]\n\t\tcard := int(keycard[2*i+1]) + 1\n\t\tra.keys[i] = key\n\t\tra.needCopyOnWrite[i] = willNeedCopyOnWrite\n\n\t\tif isRunBitmap != nil && isRunBitmap[i/8]&(1<<(i%8)) != 0 {\n\t\t\t// run container\n\t\t\tnr, err := stream.ReadUInt16()\n\t\t\tif err != nil {\n\t\t\t\treturn 0, fmt.Errorf(\"failed to read runtime container size: %s\", err)\n\t\t\t}\n\n\t\t\tbuf, err := stream.Next(int(nr) * 4)\n\t\t\tif err != nil {\n\t\t\t\treturn stream.GetReadBytes(), fmt.Errorf(\"failed to read runtime container content: %s\", err)\n\t\t\t}\n\n\t\t\tnb := runContainer16{\n\t\t\t\tiv: byteSliceAsInterval16Slice(buf),\n\t\t\t}\n\n\t\t\tra.containers[i] = &nb\n\t\t} else if card > arrayDefaultMaxSize {\n\t\t\t// bitmap container\n\t\t\tbuf, err := stream.Next(arrayDefaultMaxSize * 2)\n\t\t\tif err != nil {\n\t\t\t\treturn stream.GetReadBytes(), fmt.Errorf(\"failed to read bitmap container: %s\", err)\n\t\t\t}\n\n\t\t\tnb := bitmapContainer{\n\t\t\t\tcardinality: card,\n\t\t\t\tbitmap:      byteSliceAsUint64Slice(buf),\n\t\t\t}\n\n\t\t\tra.containers[i] = &nb\n\t\t} else {\n\t\t\t// array container\n\t\t\tbuf, err := stream.Next(card * 2)\n\t\t\tif err != nil {\n\t\t\t\treturn stream.GetReadBytes(), fmt.Errorf(\"failed to read array container: %s\", err)\n\t\t\t}\n\n\t\t\tnb := arrayContainer{\n\t\t\t\tbyteSliceAsUint16Slice(buf),\n\t\t\t}\n\n\t\t\tra.containers[i] = &nb\n\t\t}\n\t}\n\n\treturn stream.GetReadBytes(), nil\n}\n\nfunc (ra *roaringArray) hasRunCompression() bool {\n\tfor _, c := range ra.containers {\n\t\tswitch c.(type) {\n\t\tcase *runContainer16:\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\n/**\n * Find the smallest integer index larger than pos such that array[index].key&gt;=min. If none can\n * be found, return size. Based on code by O. Kaser.\n *\n * @param min minimal value\n * @param pos index to exceed\n * @return the smallest index greater than pos such that array[index].key is at least as large as\n *         min, or size if it is not possible.\n */\nfunc (ra *roaringArray) advanceUntil(min uint16, pos int) int {\n\tlower := pos + 1\n\n\tif lower >= len(ra.keys) || ra.keys[lower] >= min {\n\t\treturn lower\n\t}\n\n\tspansize := 1\n\n\tfor lower+spansize < len(ra.keys) && ra.keys[lower+spansize] < min {\n\t\tspansize *= 2\n\t}\n\tvar upper int\n\tif lower+spansize < len(ra.keys) {\n\t\tupper = lower + spansize\n\t} else {\n\t\tupper = len(ra.keys) - 1\n\t}\n\n\tif ra.keys[upper] == min {\n\t\treturn upper\n\t}\n\n\tif ra.keys[upper] < min {\n\t\t// means\n\t\t// array\n\t\t// has no\n\t\t// item\n\t\t// >= min\n\t\t// pos = array.length;\n\t\treturn len(ra.keys)\n\t}\n\n\t// we know that the next-smallest span was too small\n\tlower += (spansize >> 1)\n\n\tmid := 0\n\tfor lower+1 != upper {\n\t\tmid = (lower + upper) >> 1\n\t\tif ra.keys[mid] == min {\n\t\t\treturn mid\n\t\t} else if ra.keys[mid] < min {\n\t\t\tlower = mid\n\t\t} else {\n\t\t\tupper = mid\n\t\t}\n\t}\n\treturn upper\n}\n\nfunc (ra *roaringArray) markAllAsNeedingCopyOnWrite() {\n\tfor i := range ra.needCopyOnWrite {\n\t\tra.needCopyOnWrite[i] = true\n\t}\n}\n\nfunc (ra *roaringArray) needsCopyOnWrite(i int) bool {\n\treturn ra.needCopyOnWrite[i]\n}\n\nfunc (ra *roaringArray) setNeedsCopyOnWrite(i int) {\n\tra.needCopyOnWrite[i] = true\n}\n\nfunc (ra *roaringArray) checkKeysSorted() bool {\n\tif len(ra.keys) == 0 || len(ra.keys) == 1 {\n\t\treturn true\n\t}\n\tprevious := ra.keys[0]\n\tfor nextIdx := 1; nextIdx < len(ra.keys); nextIdx++ {\n\t\tnext := ra.keys[nextIdx]\n\t\tif previous >= next {\n\t\t\treturn false\n\t\t}\n\t\tprevious = next\n\n\t}\n\treturn true\n}\n\n// validate checks the referential integrity\n// ensures len(keys) == len(containers), recurses and checks each container type\nfunc (ra *roaringArray) validate() error {\n\tif len(ra.keys) == 0 {\n\t\treturn ErrEmptyKeys\n\t}\n\n\tif !ra.checkKeysSorted() {\n\t\treturn ErrKeySortOrder\n\t}\n\n\tif len(ra.keys) != len(ra.containers) {\n\t\treturn ErrCardinalityConstraint\n\t}\n\n\tif len(ra.keys) != len(ra.needCopyOnWrite) {\n\t\treturn ErrCardinalityConstraint\n\t}\n\n\tfor _, container := range ra.containers {\n\t\terr := container.validate()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\treturn nil\n}\n"
        },
        {
          "name": "roaringarray_test.go",
          "type": "blob",
          "size": 0.9638671875,
          "content": "package roaring\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestRoaringArrayAdvanceUntil(t *testing.T) {\n\tbitmap := New()\n\tlow := 1 << 16\n\tmid := 2 << 16\n\thigh := 3 << 16\n\tbitmap.AddRange(uint64(low)-1, uint64(low)+2)\n\tbitmap.AddRange(uint64(mid)-1, uint64(mid)+2)\n\tbitmap.AddRange(uint64(high)-1, uint64(high)+2)\n\n\tassert.Equal(t, 0, bitmap.highlowcontainer.advanceUntil(0, -1))\n\tassert.Equal(t, 1, bitmap.highlowcontainer.advanceUntil(1, -1))\n\tassert.Equal(t, 2, bitmap.highlowcontainer.advanceUntil(2, -1))\n\tassert.Equal(t, 3, bitmap.highlowcontainer.advanceUntil(3, -1))\n\tassert.Equal(t, 4, bitmap.highlowcontainer.advanceUntil(4, -1))\n\n\tassert.Equal(t, 1, bitmap.highlowcontainer.advanceUntil(0, 0))\n\tassert.Equal(t, 2, bitmap.highlowcontainer.advanceUntil(1, 1))\n\tassert.Equal(t, 3, bitmap.highlowcontainer.advanceUntil(2, 2))\n\tassert.Equal(t, 4, bitmap.highlowcontainer.advanceUntil(3, 3))\n\tassert.Equal(t, 5, bitmap.highlowcontainer.advanceUntil(4, 4))\n}\n"
        },
        {
          "name": "roaringcow_test.go",
          "type": "blob",
          "size": 41.6083984375,
          "content": "package roaring\n\nimport (\n\t\"bytes\"\n\t\"math/rand\"\n\t\"strconv\"\n\t\"testing\"\n\n\t\"github.com/bits-and-blooms/bitset\"\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestIssue386(t *testing.T) {\n\ta := NewBitmap()\n\tfor i := uint32(0); i < 1000; i++ {\n\t\ta.Add(i)\n\t}\n\ta.SetCopyOnWrite(true)\n\taClone := a.Clone()\n\tassert.False(t, a.Contains(1001))\n\tassert.EqualValues(t, 1000, a.GetCardinality())\n\tassert.EqualValues(t, 1000, aClone.GetCardinality())\n\tb := NewBitmap()\n\tb.Add(1001)\n\tassert.False(t, a.Contains(1001))\n\tassert.True(t, b.Contains(1001))\n\tassert.EqualValues(t, 1000, a.GetCardinality())\n\tassert.EqualValues(t, 1000, aClone.GetCardinality())\n\tc := NewBitmap()\n\tc.Or(aClone)\n\tassert.EqualValues(t, 1000, c.GetCardinality())\n\tassert.EqualValues(t, 1000, a.GetCardinality())\n\tassert.EqualValues(t, 1000, aClone.GetCardinality())\n\tc.Or(b)\n\tassert.EqualValues(t, 1001, c.GetCardinality())\n\tassert.True(t, c.Contains(1001))\n\tassert.False(t, a.Contains(1001))\n\tassert.EqualValues(t, 1000, a.GetCardinality())\n\tassert.EqualValues(t, 1000, aClone.GetCardinality())\n}\n\nfunc TestCloneOfCOW(t *testing.T) {\n\trb1 := NewBitmap()\n\trb1.SetCopyOnWrite(true)\n\trb1.Add(10)\n\trb1.Add(12)\n\trb1.Remove(12)\n\n\trb2 := rb1.Clone()\n\n\trb3 := rb1.Clone()\n\n\trb2.Remove(10)\n\n\trb3.AddRange(100, 200)\n\n\tassert.NotEmpty(t, rb2.IsEmpty())\n\tassert.EqualValues(t, 100+1, rb3.GetCardinality())\n\tassert.True(t, rb1.Contains(10))\n\tassert.EqualValues(t, 1, rb1.GetCardinality())\n}\n\nfunc TestRoaringBitmapBitmapOfCOW(t *testing.T) {\n\tarray := []uint32{5580, 33722, 44031, 57276, 83097}\n\tbmp := BitmapOf(array...)\n\tbmp.SetCopyOnWrite(true)\n\n\tassert.EqualValues(t, len(array), bmp.GetCardinality())\n}\n\nfunc TestRoaringBitmapAddCOW(t *testing.T) {\n\tarray := []uint32{5580, 33722, 44031, 57276, 83097}\n\tbmp := New()\n\tbmp.SetCopyOnWrite(true)\n\tfor _, v := range array {\n\t\tbmp.Add(v)\n\t}\n\n\tassert.EqualValues(t, len(array), bmp.GetCardinality())\n}\n\nfunc TestRoaringBitmapAddManyCOW(t *testing.T) {\n\tarray := []uint32{5580, 33722, 44031, 57276, 83097}\n\tbmp := NewBitmap()\n\tbmp.SetCopyOnWrite(true)\n\n\tbmp.AddMany(array)\n\n\tassert.EqualValues(t, len(array), bmp.GetCardinality())\n}\n\n// https://github.com/RoaringBitmap/roaring/issues/64\nfunc TestFlip64COW(t *testing.T) {\n\tbm := New()\n\tbm.SetCopyOnWrite(true)\n\n\tbm.AddInt(0)\n\tbm.Flip(1, 2)\n\ti := bm.Iterator()\n\n\tassert.False(t, i.Next() != 0 || i.Next() != 1 || i.HasNext())\n}\n\n// https://github.com/RoaringBitmap/roaring/issues/64\nfunc TestFlip64OffCOW(t *testing.T) {\n\tbm := New()\n\tbm.SetCopyOnWrite(true)\n\n\tbm.AddInt(10)\n\tbm.Flip(11, 12)\n\ti := bm.Iterator()\n\n\tassert.False(t, i.Next() != 10 || i.Next() != 11 || i.HasNext())\n}\n\nfunc TestStringerCOW(t *testing.T) {\n\tv := NewBitmap()\n\tv.SetCopyOnWrite(true)\n\tfor i := uint32(0); i < 10; i++ {\n\t\tv.Add(i)\n\t}\n\n\tassert.Equal(t, \"{0,1,2,3,4,5,6,7,8,9}\", v.String())\n\n\tv.RunOptimize()\n\n\tassert.Equal(t, \"{0,1,2,3,4,5,6,7,8,9}\", v.String())\n}\n\nfunc TestFastCardCOW(t *testing.T) {\n\tbm := NewBitmap()\n\tbm.SetCopyOnWrite(true)\n\tbm.Add(1)\n\tbm.AddRange(21, 260000)\n\n\tbm2 := NewBitmap()\n\tbm2.SetCopyOnWrite(true)\n\tbm2.Add(25)\n\n\tassert.EqualValues(t, 1, bm2.AndCardinality(bm))\n\tassert.Equal(t, bm.GetCardinality(), bm2.OrCardinality(bm))\n\tassert.EqualValues(t, 1, bm.AndCardinality(bm2))\n\tassert.Equal(t, bm.GetCardinality(), bm.OrCardinality(bm2))\n\tassert.EqualValues(t, 1, bm2.AndCardinality(bm))\n\tassert.Equal(t, bm.GetCardinality(), bm2.OrCardinality(bm))\n\n\tbm.RunOptimize()\n\n\tassert.EqualValues(t, 1, bm2.AndCardinality(bm))\n\tassert.Equal(t, bm.GetCardinality(), bm2.OrCardinality(bm))\n\tassert.EqualValues(t, 1, bm.AndCardinality(bm2))\n\tassert.Equal(t, bm.GetCardinality(), bm.OrCardinality(bm2))\n\tassert.EqualValues(t, 1, bm2.AndCardinality(bm))\n\tassert.Equal(t, bm.GetCardinality(), bm2.OrCardinality(bm))\n}\n\nfunc TestIntersects1COW(t *testing.T) {\n\tbm := NewBitmap()\n\tbm.SetCopyOnWrite(true)\n\tbm.Add(1)\n\tbm.AddRange(21, 26)\n\n\tbm2 := NewBitmap()\n\tbm2.SetCopyOnWrite(true)\n\tbm2.Add(25)\n\n\tassert.True(t, bm2.Intersects(bm))\n\n\tbm.Remove(25)\n\tassert.False(t, bm2.Intersects(bm))\n\n\tbm.AddRange(1, 100000)\n\tassert.True(t, bm2.Intersects(bm))\n}\n\nfunc TestRangePanicCOW(t *testing.T) {\n\tbm := NewBitmap()\n\tbm.SetCopyOnWrite(true)\n\tbm.Add(1)\n\tbm.AddRange(21, 26)\n\tbm.AddRange(9, 14)\n\tbm.AddRange(11, 16)\n}\n\nfunc TestRangeRemovalCOW(t *testing.T) {\n\tbm := NewBitmap()\n\tbm.SetCopyOnWrite(true)\n\tbm.Add(1)\n\tbm.AddRange(21, 26)\n\tbm.AddRange(9, 14)\n\tbm.RemoveRange(11, 16)\n\tbm.RemoveRange(1, 26)\n\n\tassert.EqualValues(t, 0, bm.GetCardinality())\n\n\tbm.AddRange(1, 10000)\n\tassert.EqualValues(t, 10000-1, bm.GetCardinality())\n\n\tbm.RemoveRange(1, 10000)\n\tassert.EqualValues(t, 0, bm.GetCardinality())\n}\n\nfunc TestRangeRemovalFromContentCOW(t *testing.T) {\n\tbm := NewBitmap()\n\tbm.SetCopyOnWrite(true)\n\tfor i := 100; i < 10000; i++ {\n\t\tbm.AddInt(i * 3)\n\t}\n\tbm.AddRange(21, 26)\n\tbm.AddRange(9, 14)\n\tbm.RemoveRange(11, 16)\n\tbm.RemoveRange(0, 30000)\n\n\tassert.EqualValues(t, 0, bm.GetCardinality())\n}\n\nfunc TestFlipOnEmptyCOW(t *testing.T) {\n\tt.Run(\"TestFlipOnEmpty in-place\", func(t *testing.T) {\n\t\tbm := NewBitmap()\n\t\tbm.SetCopyOnWrite(true)\n\t\tbm.Flip(0, 10)\n\t\tc := bm.GetCardinality()\n\n\t\tassert.EqualValues(t, 10, c)\n\t})\n\n\tt.Run(\"TestFlipOnEmpty, generating new result\", func(t *testing.T) {\n\t\tbm := NewBitmap()\n\t\tbm.SetCopyOnWrite(true)\n\t\tbm = Flip(bm, 0, 10)\n\t\tc := bm.GetCardinality()\n\n\t\tassert.EqualValues(t, 10, c)\n\t})\n}\n\nfunc TestBitmapRankCOW(t *testing.T) {\n\tfor N := uint32(1); N <= 1048576; N *= 2 {\n\t\tt.Run(\"rank tests\"+strconv.Itoa(int(N)), func(t *testing.T) {\n\t\t\tfor gap := uint32(1); gap <= 65536; gap *= 2 {\n\t\t\t\trb1 := NewBitmap()\n\t\t\t\trb1.SetCopyOnWrite(true)\n\t\t\t\tfor x := uint32(0); x <= N; x += gap {\n\t\t\t\t\trb1.Add(x)\n\t\t\t\t}\n\t\t\t\tfor y := uint32(0); y <= N; y++ {\n\t\t\t\t\tif rb1.Rank(y) != uint64((y+1+gap-1)/gap) {\n\t\t\t\t\t\tassert.Equal(t, (y+1+gap-1)/gap, rb1.Rank(y))\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestBitmapSelectCOW(t *testing.T) {\n\tfor N := uint32(1); N <= 1048576; N *= 2 {\n\t\tt.Run(\"rank tests\"+strconv.Itoa(int(N)), func(t *testing.T) {\n\t\t\tfor gap := uint32(1); gap <= 65536; gap *= 2 {\n\t\t\t\trb1 := NewBitmap()\n\t\t\t\trb1.SetCopyOnWrite(true)\n\t\t\t\tfor x := uint32(0); x <= N; x += gap {\n\t\t\t\t\trb1.Add(x)\n\t\t\t\t}\n\t\t\t\tfor y := uint32(0); y <= N/gap; y++ {\n\t\t\t\t\texpectedInt := y * gap\n\t\t\t\t\ti, err := rb1.Select(y)\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\tt.Fatal(err)\n\t\t\t\t\t}\n\n\t\t\t\t\tif i != expectedInt {\n\t\t\t\t\t\tassert.Equal(t, expectedInt, i)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}\n\n// some extra tests\nfunc TestBitmapExtraCOW(t *testing.T) {\n\tfor N := uint32(1); N <= 65536; N *= 2 {\n\t\tt.Run(\"extra tests\"+strconv.Itoa(int(N)), func(t *testing.T) {\n\t\t\tfor gap := uint32(1); gap <= 65536; gap *= 2 {\n\t\t\t\tbs1 := bitset.New(0)\n\t\t\t\trb1 := NewBitmap()\n\t\t\t\trb1.SetCopyOnWrite(true)\n\n\t\t\t\tfor x := uint32(0); x <= N; x += gap {\n\t\t\t\t\tbs1.Set(uint(x))\n\t\t\t\t\trb1.Add(x)\n\t\t\t\t}\n\n\t\t\t\tassert.EqualValues(t, rb1.GetCardinality(), bs1.Count())\n\t\t\t\tassert.True(t, equalsBitSet(bs1, rb1))\n\n\t\t\t\tfor offset := uint32(1); offset <= gap; offset *= 2 {\n\t\t\t\t\tbs2 := bitset.New(0)\n\t\t\t\t\trb2 := NewBitmap()\n\t\t\t\t\trb2.SetCopyOnWrite(true)\n\n\t\t\t\t\tfor x := uint32(0); x <= N; x += gap {\n\t\t\t\t\t\tbs2.Set(uint(x + offset))\n\t\t\t\t\t\trb2.Add(x + offset)\n\t\t\t\t\t}\n\n\t\t\t\t\tassert.EqualValues(t, rb2.GetCardinality(), bs2.Count())\n\t\t\t\t\tassert.True(t, equalsBitSet(bs2, rb2))\n\n\t\t\t\t\tclonebs1 := bs1.Clone()\n\t\t\t\t\tclonebs1.InPlaceIntersection(bs2)\n\t\t\t\t\tif !equalsBitSet(clonebs1, And(rb1, rb2)) {\n\t\t\t\t\t\tv := rb1.Clone()\n\t\t\t\t\t\tv.And(rb2)\n\n\t\t\t\t\t\tassert.True(t, equalsBitSet(clonebs1, v))\n\t\t\t\t\t}\n\n\t\t\t\t\t// testing OR\n\t\t\t\t\tclonebs1 = bs1.Clone()\n\t\t\t\t\tclonebs1.InPlaceUnion(bs2)\n\n\t\t\t\t\tassert.True(t, equalsBitSet(clonebs1, Or(rb1, rb2)))\n\n\t\t\t\t\t// testing XOR\n\t\t\t\t\tclonebs1 = bs1.Clone()\n\t\t\t\t\tclonebs1.InPlaceSymmetricDifference(bs2)\n\n\t\t\t\t\tassert.True(t, equalsBitSet(clonebs1, Xor(rb1, rb2)))\n\n\t\t\t\t\t//testing NOTAND\n\t\t\t\t\tclonebs1 = bs1.Clone()\n\t\t\t\t\tclonebs1.InPlaceDifference(bs2)\n\n\t\t\t\t\tassert.True(t, equalsBitSet(clonebs1, AndNot(rb1, rb2)))\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestBitmapCOW(t *testing.T) {\n\tt.Run(\"Test Contains\", func(t *testing.T) {\n\t\trbm1 := NewBitmap()\n\t\trbm1.SetCopyOnWrite(true)\n\t\tfor k := 0; k < 1000; k++ {\n\t\t\trbm1.AddInt(17 * k)\n\t\t}\n\t\tfor k := 0; k < 17*1000; k++ {\n\t\t\tassert.Equal(t, k/17*17 == k, rbm1.ContainsInt(k))\n\t\t}\n\t})\n\n\tt.Run(\"Test Clone\", func(t *testing.T) {\n\t\trb1 := NewBitmap()\n\t\trb1.SetCopyOnWrite(true)\n\t\trb1.Add(10)\n\n\t\trb2 := rb1.Clone()\n\t\trb2.Remove(10)\n\n\t\tassert.True(t, rb1.Contains(10))\n\t})\n\n\tt.Run(\"Test ANDNOT4\", func(t *testing.T) {\n\t\trb := NewBitmap()\n\t\trb.SetCopyOnWrite(true)\n\t\trb2 := NewBitmap()\n\t\trb2.SetCopyOnWrite(true)\n\n\t\tfor i := 0; i < 200000; i += 4 {\n\t\t\trb2.AddInt(i)\n\t\t}\n\t\tfor i := 200000; i < 400000; i += 14 {\n\t\t\trb2.AddInt(i)\n\t\t}\n\n\t\toff := AndNot(rb2, rb)\n\t\tandNotresult := AndNot(rb, rb2)\n\n\t\tassert.True(t, rb.Equals(andNotresult))\n\t\tassert.True(t, rb2.Equals(off))\n\n\t\trb2.AndNot(rb)\n\t\tassert.True(t, rb2.Equals(off))\n\t})\n\n\tt.Run(\"Test AND\", func(t *testing.T) {\n\t\trr := NewBitmap()\n\t\trr.SetCopyOnWrite(true)\n\t\tfor k := 0; k < 4000; k++ {\n\t\t\trr.AddInt(k)\n\t\t}\n\t\trr.Add(100000)\n\t\trr.Add(110000)\n\t\trr2 := NewBitmap()\n\t\trr2.SetCopyOnWrite(true)\n\t\trr2.Add(13)\n\t\trrand := And(rr, rr2)\n\t\tarray := rrand.ToArray()\n\n\t\tassert.Equal(t, 1, len(array))\n\t\tassert.EqualValues(t, 13, array[0])\n\n\t\trr.And(rr2)\n\t\tarray = rr.ToArray()\n\n\t\tassert.Equal(t, 1, len(array))\n\t\tassert.EqualValues(t, 13, array[0])\n\t})\n\n\tt.Run(\"Test AND 2\", func(t *testing.T) {\n\t\trr := NewBitmap()\n\t\trr.SetCopyOnWrite(true)\n\t\tfor k := 4000; k < 4256; k++ {\n\t\t\trr.AddInt(k)\n\t\t}\n\t\tfor k := 65536; k < 65536+4000; k++ {\n\t\t\trr.AddInt(k)\n\t\t}\n\t\tfor k := 3 * 65536; k < 3*65536+9000; k++ {\n\t\t\trr.AddInt(k)\n\t\t}\n\t\tfor k := 4 * 65535; k < 4*65535+7000; k++ {\n\t\t\trr.AddInt(k)\n\t\t}\n\t\tfor k := 6 * 65535; k < 6*65535+10000; k++ {\n\t\t\trr.AddInt(k)\n\t\t}\n\t\tfor k := 8 * 65535; k < 8*65535+1000; k++ {\n\t\t\trr.AddInt(k)\n\t\t}\n\t\tfor k := 9 * 65535; k < 9*65535+30000; k++ {\n\t\t\trr.AddInt(k)\n\t\t}\n\n\t\trr2 := NewBitmap()\n\t\trr2.SetCopyOnWrite(true)\n\t\tfor k := 4000; k < 4256; k++ {\n\t\t\trr2.AddInt(k)\n\t\t}\n\t\tfor k := 65536; k < 65536+4000; k++ {\n\t\t\trr2.AddInt(k)\n\t\t}\n\t\tfor k := 3*65536 + 2000; k < 3*65536+6000; k++ {\n\t\t\trr2.AddInt(k)\n\t\t}\n\t\tfor k := 6 * 65535; k < 6*65535+1000; k++ {\n\t\t\trr2.AddInt(k)\n\t\t}\n\t\tfor k := 7 * 65535; k < 7*65535+1000; k++ {\n\t\t\trr2.AddInt(k)\n\t\t}\n\t\tfor k := 10 * 65535; k < 10*65535+5000; k++ {\n\t\t\trr2.AddInt(k)\n\t\t}\n\t\tcorrect := And(rr, rr2)\n\t\trr.And(rr2)\n\n\t\tassert.True(t, correct.Equals(rr))\n\t})\n\n\tt.Run(\"Test AND 2\", func(t *testing.T) {\n\t\trr := NewBitmap()\n\t\trr.SetCopyOnWrite(true)\n\t\tfor k := 0; k < 4000; k++ {\n\t\t\trr.AddInt(k)\n\t\t}\n\t\trr.AddInt(100000)\n\t\trr.AddInt(110000)\n\t\trr2 := NewBitmap()\n\t\trr2.SetCopyOnWrite(true)\n\t\trr2.AddInt(13)\n\n\t\trrand := And(rr, rr2)\n\t\tarray := rrand.ToArray()\n\n\t\tassert.Equal(t, 1, len(array))\n\t\tassert.EqualValues(t, 13, array[0])\n\t})\n\n\tt.Run(\"Test AND 3a\", func(t *testing.T) {\n\t\trr := NewBitmap()\n\t\trr.SetCopyOnWrite(true)\n\t\trr2 := NewBitmap()\n\t\trr2.SetCopyOnWrite(true)\n\t\tfor k := 6 * 65536; k < 6*65536+10000; k++ {\n\t\t\trr.AddInt(k)\n\t\t}\n\t\tfor k := 6 * 65536; k < 6*65536+1000; k++ {\n\t\t\trr2.AddInt(k)\n\t\t}\n\t\tresult := And(rr, rr2)\n\n\t\tassert.EqualValues(t, 1000, result.GetCardinality())\n\t})\n\n\tt.Run(\"Test AND 3\", func(t *testing.T) {\n\t\tvar arrayand [11256]uint32\n\t\t//393,216\n\t\tpos := 0\n\t\trr := NewBitmap()\n\t\trr.SetCopyOnWrite(true)\n\t\tfor k := 4000; k < 4256; k++ {\n\t\t\trr.AddInt(k)\n\t\t}\n\t\tfor k := 65536; k < 65536+4000; k++ {\n\t\t\trr.AddInt(k)\n\t\t}\n\t\tfor k := 3 * 65536; k < 3*65536+1000; k++ {\n\t\t\trr.AddInt(k)\n\t\t}\n\t\tfor k := 3*65536 + 1000; k < 3*65536+7000; k++ {\n\t\t\trr.AddInt(k)\n\t\t}\n\t\tfor k := 3*65536 + 7000; k < 3*65536+9000; k++ {\n\t\t\trr.AddInt(k)\n\t\t}\n\t\tfor k := 4 * 65536; k < 4*65536+7000; k++ {\n\t\t\trr.AddInt(k)\n\t\t}\n\t\tfor k := 8 * 65536; k < 8*65536+1000; k++ {\n\t\t\trr.AddInt(k)\n\t\t}\n\t\tfor k := 9 * 65536; k < 9*65536+30000; k++ {\n\t\t\trr.AddInt(k)\n\t\t}\n\n\t\trr2 := NewBitmap()\n\t\trr2.SetCopyOnWrite(true)\n\t\tfor k := 4000; k < 4256; k++ {\n\t\t\trr2.AddInt(k)\n\t\t\tarrayand[pos] = uint32(k)\n\t\t\tpos++\n\t\t}\n\t\tfor k := 65536; k < 65536+4000; k++ {\n\t\t\trr2.AddInt(k)\n\t\t\tarrayand[pos] = uint32(k)\n\t\t\tpos++\n\t\t}\n\t\tfor k := 3*65536 + 1000; k < 3*65536+7000; k++ {\n\t\t\trr2.AddInt(k)\n\t\t\tarrayand[pos] = uint32(k)\n\t\t\tpos++\n\t\t}\n\t\tfor k := 6 * 65536; k < 6*65536+10000; k++ {\n\t\t\trr.AddInt(k)\n\t\t}\n\t\tfor k := 6 * 65536; k < 6*65536+1000; k++ {\n\t\t\trr2.AddInt(k)\n\t\t\tarrayand[pos] = uint32(k)\n\t\t\tpos++\n\t\t}\n\n\t\tfor k := 7 * 65536; k < 7*65536+1000; k++ {\n\t\t\trr2.AddInt(k)\n\t\t}\n\t\tfor k := 10 * 65536; k < 10*65536+5000; k++ {\n\t\t\trr2.AddInt(k)\n\t\t}\n\t\trrand := And(rr, rr2)\n\n\t\tarrayres := rrand.ToArray()\n\t\tok := true\n\t\tfor i := range arrayres {\n\t\t\tif i < len(arrayand) {\n\t\t\t\tif arrayres[i] != arrayand[i] {\n\t\t\t\t\tt.Log(i, arrayres[i], arrayand[i])\n\t\t\t\t\tok = false\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tt.Log('x', arrayres[i])\n\t\t\t\tok = false\n\t\t\t}\n\t\t}\n\n\t\tassert.Equal(t, len(arrayres), len(arrayand))\n\t\tassert.True(t, ok)\n\t})\n\n\tt.Run(\"Test AND 4\", func(t *testing.T) {\n\t\trb := NewBitmap()\n\t\trb.SetCopyOnWrite(true)\n\t\trb2 := NewBitmap()\n\t\trb2.SetCopyOnWrite(true)\n\n\t\tfor i := 0; i < 200000; i += 4 {\n\t\t\trb2.AddInt(i)\n\t\t}\n\t\tfor i := 200000; i < 400000; i += 14 {\n\t\t\trb2.AddInt(i)\n\t\t}\n\t\t//TODO: Bitmap.And(bm,bm2)\n\t\tandresult := And(rb, rb2)\n\t\toff := And(rb2, rb)\n\n\t\tassert.True(t, andresult.Equals(off))\n\t\tassert.EqualValues(t, 0, andresult.GetCardinality())\n\n\t\tfor i := 500000; i < 600000; i += 14 {\n\t\t\trb.AddInt(i)\n\t\t}\n\t\tfor i := 200000; i < 400000; i += 3 {\n\t\t\trb2.AddInt(i)\n\t\t}\n\t\tandresult2 := And(rb, rb2)\n\n\t\tassert.EqualValues(t, 0, andresult.GetCardinality())\n\t\tassert.EqualValues(t, 0, andresult2.GetCardinality())\n\n\t\tfor i := 0; i < 200000; i += 4 {\n\t\t\trb.AddInt(i)\n\t\t}\n\t\tfor i := 200000; i < 400000; i += 14 {\n\t\t\trb.AddInt(i)\n\t\t}\n\n\t\tassert.EqualValues(t, 0, andresult.GetCardinality())\n\n\t\trc := And(rb, rb2)\n\t\trb.And(rb2)\n\n\t\tassert.Equal(t, rb.GetCardinality(), rc.GetCardinality())\n\t})\n\n\tt.Run(\"ArrayContainerCardinalityTest\", func(t *testing.T) {\n\t\tac := newArrayContainer()\n\t\tfor k := uint16(0); k < 100; k++ {\n\t\t\tac.iadd(k)\n\t\t\tassert.EqualValues(t, k+1, ac.getCardinality())\n\t\t}\n\t\tfor k := uint16(0); k < 100; k++ {\n\t\t\tac.iadd(k)\n\t\t\tassert.EqualValues(t, 100, ac.getCardinality())\n\t\t}\n\t})\n\n\tt.Run(\"or test\", func(t *testing.T) {\n\t\trr := NewBitmap()\n\t\trr.SetCopyOnWrite(true)\n\t\tfor k := 0; k < 4000; k++ {\n\t\t\trr.AddInt(k)\n\t\t}\n\t\trr2 := NewBitmap()\n\t\trr2.SetCopyOnWrite(true)\n\t\tfor k := 4000; k < 8000; k++ {\n\t\t\trr2.AddInt(k)\n\t\t}\n\t\tresult := Or(rr, rr2)\n\t\tassert.Equal(t, rr.GetCardinality()+rr2.GetCardinality(), result.GetCardinality())\n\t})\n\n\tt.Run(\"basic test\", func(t *testing.T) {\n\t\trr := NewBitmap()\n\t\trr.SetCopyOnWrite(true)\n\t\tvar a [4002]uint32\n\t\tpos := 0\n\t\tfor k := 0; k < 4000; k++ {\n\t\t\trr.AddInt(k)\n\t\t\ta[pos] = uint32(k)\n\t\t\tpos++\n\t\t}\n\t\trr.AddInt(100000)\n\t\ta[pos] = 100000\n\t\tpos++\n\t\trr.AddInt(110000)\n\t\ta[pos] = 110000\n\t\tpos++\n\t\tarray := rr.ToArray()\n\t\tok := true\n\t\tfor i := range a {\n\t\t\tif array[i] != a[i] {\n\t\t\t\tt.Log(\"rr : \", array[i], \" a : \", a[i])\n\t\t\t\tok = false\n\t\t\t}\n\t\t}\n\n\t\tassert.Equal(t, len(a), len(array))\n\t\tassert.True(t, ok)\n\t})\n\n\tt.Run(\"BitmapContainerCardinalityTest\", func(t *testing.T) {\n\t\tac := newBitmapContainer()\n\t\tfor k := uint16(0); k < 100; k++ {\n\t\t\tac.iadd(k)\n\t\t\tassert.EqualValues(t, k+1, ac.getCardinality())\n\t\t}\n\t\tfor k := uint16(0); k < 100; k++ {\n\t\t\tac.iadd(k)\n\t\t\tassert.EqualValues(t, 100, ac.getCardinality())\n\t\t}\n\t})\n\n\tt.Run(\"BitmapContainerTest\", func(t *testing.T) {\n\t\trr := newBitmapContainer()\n\t\trr.iadd(uint16(110))\n\t\trr.iadd(uint16(114))\n\t\trr.iadd(uint16(115))\n\t\tvar array [3]uint16\n\t\tpos := 0\n\t\tfor itr := rr.getShortIterator(); itr.hasNext(); {\n\t\t\tarray[pos] = itr.next()\n\t\t\tpos++\n\t\t}\n\n\t\tassert.EqualValues(t, 110, array[0])\n\t\tassert.EqualValues(t, 114, array[1])\n\t\tassert.EqualValues(t, 115, array[2])\n\t})\n\n\tt.Run(\"cardinality test\", func(t *testing.T) {\n\t\tN := 1024\n\t\tfor gap := 7; gap < 100000; gap *= 10 {\n\t\t\tfor offset := 2; offset <= 1024; offset *= 2 {\n\t\t\t\trb := NewBitmap()\n\t\t\t\trb.SetCopyOnWrite(true)\n\t\t\t\tfor k := 0; k < N; k++ {\n\t\t\t\t\trb.AddInt(k * gap)\n\t\t\t\t\tassert.EqualValues(t, k+1, rb.GetCardinality())\n\t\t\t\t}\n\n\t\t\t\tassert.EqualValues(t, N, rb.GetCardinality())\n\n\t\t\t\t// check the add of existing values\n\t\t\t\tfor k := 0; k < N; k++ {\n\t\t\t\t\trb.AddInt(k * gap)\n\t\t\t\t\tassert.EqualValues(t, N, rb.GetCardinality())\n\t\t\t\t}\n\n\t\t\t\trb2 := NewBitmap()\n\t\t\t\trb2.SetCopyOnWrite(true)\n\n\t\t\t\tfor k := 0; k < N; k++ {\n\t\t\t\t\trb2.AddInt(k * gap * offset)\n\t\t\t\t\tassert.EqualValues(t, k+1, rb2.GetCardinality())\n\t\t\t\t}\n\n\t\t\t\tassert.EqualValues(t, N, rb2.GetCardinality())\n\n\t\t\t\tfor k := 0; k < N; k++ {\n\t\t\t\t\trb2.AddInt(k * gap * offset)\n\t\t\t\t\tassert.EqualValues(t, N, rb2.GetCardinality())\n\t\t\t\t}\n\t\t\t\tassert.EqualValues(t, N/offset, And(rb, rb2).GetCardinality())\n\t\t\t\tassert.EqualValues(t, 2*N-2*N/offset, Xor(rb, rb2).GetCardinality())\n\t\t\t\tassert.EqualValues(t, 2*N-N/offset, Or(rb, rb2).GetCardinality())\n\t\t\t}\n\t\t}\n\t})\n\n\tt.Run(\"clear test\", func(t *testing.T) {\n\t\trb := NewBitmap()\n\t\trb.SetCopyOnWrite(true)\n\t\tfor i := 0; i < 200000; i += 7 {\n\t\t\t// dense\n\t\t\trb.AddInt(i)\n\t\t}\n\t\tfor i := 200000; i < 400000; i += 177 {\n\t\t\t// sparse\n\t\t\trb.AddInt(i)\n\t\t}\n\n\t\trb2 := NewBitmap()\n\t\trb2.SetCopyOnWrite(true)\n\t\trb3 := NewBitmap()\n\t\trb3.SetCopyOnWrite(true)\n\t\tfor i := 0; i < 200000; i += 4 {\n\t\t\trb2.AddInt(i)\n\t\t}\n\t\tfor i := 200000; i < 400000; i += 14 {\n\t\t\trb2.AddInt(i)\n\t\t}\n\n\t\trb.Clear()\n\n\t\tassert.EqualValues(t, 0, rb.GetCardinality())\n\t\tassert.NotEqual(t, 0, rb2.GetCardinality())\n\n\t\trb.AddInt(4)\n\t\trb3.AddInt(4)\n\t\tandresult := And(rb, rb2)\n\t\torresult := Or(rb, rb2)\n\n\t\tassert.EqualValues(t, 1, andresult.GetCardinality())\n\t\tassert.Equal(t, rb2.GetCardinality(), orresult.GetCardinality())\n\n\t\tfor i := 0; i < 200000; i += 4 {\n\t\t\trb.AddInt(i)\n\t\t\trb3.AddInt(i)\n\t\t}\n\t\tfor i := 200000; i < 400000; i += 114 {\n\t\t\trb.AddInt(i)\n\t\t\trb3.AddInt(i)\n\t\t}\n\n\t\tarrayrr := rb.ToArray()\n\t\tarrayrr3 := rb3.ToArray()\n\t\tok := true\n\t\tfor i := range arrayrr {\n\t\t\tif arrayrr[i] != arrayrr3[i] {\n\t\t\t\tok = false\n\t\t\t}\n\t\t}\n\n\t\tassert.Equal(t, len(arrayrr3), len(arrayrr))\n\t\tassert.True(t, ok)\n\t})\n\n\tt.Run(\"constainer factory \", func(t *testing.T) {\n\t\tbc1 := newBitmapContainer()\n\t\tbc2 := newBitmapContainer()\n\t\tbc3 := newBitmapContainer()\n\t\tac1 := newArrayContainer()\n\t\tac2 := newArrayContainer()\n\t\tac3 := newArrayContainer()\n\n\t\tfor i := 0; i < 5000; i++ {\n\t\t\tbc1.iadd(uint16(i * 70))\n\t\t}\n\t\tfor i := 0; i < 5000; i++ {\n\t\t\tbc2.iadd(uint16(i * 70))\n\t\t}\n\t\tfor i := 0; i < 5000; i++ {\n\t\t\tbc3.iadd(uint16(i * 70))\n\t\t}\n\t\tfor i := 0; i < 4000; i++ {\n\t\t\tac1.iadd(uint16(i * 50))\n\t\t}\n\t\tfor i := 0; i < 4000; i++ {\n\t\t\tac2.iadd(uint16(i * 50))\n\t\t}\n\t\tfor i := 0; i < 4000; i++ {\n\t\t\tac3.iadd(uint16(i * 50))\n\t\t}\n\n\t\trbc := ac1.clone().(*arrayContainer).toBitmapContainer()\n\t\tvalidate(t, rbc, ac1)\n\n\t\trbc = ac2.clone().(*arrayContainer).toBitmapContainer()\n\t\tvalidate(t, rbc, ac2)\n\n\t\trbc = ac3.clone().(*arrayContainer).toBitmapContainer()\n\t\tvalidate(t, rbc, ac3)\n\t})\n\n\tt.Run(\"flipTest1 \", func(t *testing.T) {\n\t\trb := NewBitmap()\n\t\trb.SetCopyOnWrite(true)\n\t\trb.Flip(100000, 200000) // in-place on empty bitmap\n\t\trbcard := rb.GetCardinality()\n\n\t\tassert.EqualValues(t, rbcard, 100000)\n\n\t\tbs := bitset.New(20000 - 10000)\n\t\tfor i := uint(100000); i < 200000; i++ {\n\t\t\tbs.Set(i)\n\t\t}\n\n\t\tassert.True(t, equalsBitSet(bs, rb))\n\t})\n\n\tt.Run(\"flipTest1A\", func(t *testing.T) {\n\t\trb := NewBitmap()\n\t\trb.SetCopyOnWrite(true)\n\t\trb1 := Flip(rb, 100000, 200000)\n\t\trbcard := rb1.GetCardinality()\n\n\t\tassert.EqualValues(t, rbcard, 100000)\n\t\tassert.EqualValues(t, rb.GetCardinality(), 0)\n\n\t\tbs := bitset.New(0)\n\t\tassert.True(t, equalsBitSet(bs, rb))\n\n\t\tfor i := uint(100000); i < 200000; i++ {\n\t\t\tbs.Set(i)\n\t\t}\n\n\t\tassert.True(t, equalsBitSet(bs, rb1))\n\t})\n\n\tt.Run(\"flipTest2\", func(t *testing.T) {\n\t\trb := NewBitmap()\n\t\trb.SetCopyOnWrite(true)\n\t\trb.Flip(100000, 100000)\n\t\trbcard := rb.GetCardinality()\n\n\t\tassert.EqualValues(t, rbcard, 0)\n\n\t\tbs := bitset.New(0)\n\t\tassert.True(t, equalsBitSet(bs, rb))\n\t})\n\n\tt.Run(\"flipTest2A\", func(t *testing.T) {\n\t\trb := NewBitmap()\n\t\trb.SetCopyOnWrite(true)\n\t\trb1 := Flip(rb, 100000, 100000)\n\n\t\trb.AddInt(1)\n\t\trbcard := rb1.GetCardinality()\n\n\t\tassert.EqualValues(t, 0, rbcard)\n\t\tassert.EqualValues(t, rb.GetCardinality(), 1)\n\n\t\tbs := bitset.New(0)\n\t\tassert.True(t, equalsBitSet(bs, rb1))\n\n\t\tbs.Set(1)\n\t\tassert.True(t, equalsBitSet(bs, rb))\n\t})\n\n\tt.Run(\"flipTest3A\", func(t *testing.T) {\n\t\trb := NewBitmap()\n\t\trb.SetCopyOnWrite(true)\n\t\trb.Flip(100000, 200000) // got 100k-199999\n\t\trb.Flip(100000, 199991) // give back 100k-199990\n\t\trbcard := rb.GetCardinality()\n\n\t\tassert.EqualValues(t, 9, rbcard)\n\n\t\tbs := bitset.New(0)\n\t\tfor i := uint(199991); i < 200000; i++ {\n\t\t\tbs.Set(i)\n\t\t}\n\n\t\tassert.True(t, equalsBitSet(bs, rb))\n\t})\n\n\tt.Run(\"flipTest4A\", func(t *testing.T) {\n\t\t// fits evenly on both ends\n\t\trb := NewBitmap()\n\t\trb.SetCopyOnWrite(true)\n\t\trb.Flip(100000, 200000) // got 100k-199999\n\t\trb.Flip(65536, 4*65536)\n\t\trbcard := rb.GetCardinality()\n\n\t\t// 65536 to 99999 are 1s\n\t\t// 200000 to 262143 are 1s: total card\n\n\t\tassert.EqualValues(t, 96608, rbcard)\n\n\t\tbs := bitset.New(0)\n\t\tfor i := uint(65536); i < 100000; i++ {\n\t\t\tbs.Set(i)\n\t\t}\n\t\tfor i := uint(200000); i < 262144; i++ {\n\t\t\tbs.Set(i)\n\t\t}\n\n\t\tassert.True(t, equalsBitSet(bs, rb))\n\t})\n\n\tt.Run(\"flipTest5\", func(t *testing.T) {\n\t\t// fits evenly on small end, multiple\n\t\t// containers\n\t\trb := NewBitmap()\n\t\trb.SetCopyOnWrite(true)\n\t\trb.Flip(100000, 132000)\n\t\trb.Flip(65536, 120000)\n\t\trbcard := rb.GetCardinality()\n\n\t\t// 65536 to 99999 are 1s\n\t\t// 120000 to 131999\n\n\t\tassert.EqualValues(t, 46464, rbcard)\n\n\t\tbs := bitset.New(0)\n\t\tfor i := uint(65536); i < 100000; i++ {\n\t\t\tbs.Set(i)\n\t\t}\n\t\tfor i := uint(120000); i < 132000; i++ {\n\t\t\tbs.Set(i)\n\t\t}\n\n\t\tassert.True(t, equalsBitSet(bs, rb))\n\t})\n\n\tt.Run(\"flipTest6\", func(t *testing.T) {\n\t\trb := NewBitmap()\n\t\trb.SetCopyOnWrite(true)\n\t\trb1 := Flip(rb, 100000, 132000)\n\t\trb2 := Flip(rb1, 65536, 120000)\n\t\t//rbcard := rb2.GetCardinality()\n\n\t\tbs := bitset.New(0)\n\t\tfor i := uint(65536); i < 100000; i++ {\n\t\t\tbs.Set(i)\n\t\t}\n\t\tfor i := uint(120000); i < 132000; i++ {\n\t\t\tbs.Set(i)\n\t\t}\n\n\t\tassert.True(t, equalsBitSet(bs, rb2))\n\t})\n\n\tt.Run(\"flipTest6A\", func(t *testing.T) {\n\t\trb := NewBitmap()\n\t\trb.SetCopyOnWrite(true)\n\t\trb1 := Flip(rb, 100000, 132000)\n\t\trb2 := Flip(rb1, 99000, 2*65536)\n\t\trbcard := rb2.GetCardinality()\n\n\t\tassert.EqualValues(t, 1928, rbcard)\n\n\t\tbs := bitset.New(0)\n\t\tfor i := uint(99000); i < 100000; i++ {\n\t\t\tbs.Set(i)\n\t\t}\n\t\tfor i := uint(2 * 65536); i < 132000; i++ {\n\t\t\tbs.Set(i)\n\t\t}\n\n\t\tassert.True(t, equalsBitSet(bs, rb2))\n\t})\n\n\tt.Run(\"flipTest7\", func(t *testing.T) {\n\t\t// within 1 word, first container\n\t\trb := NewBitmap()\n\t\trb.SetCopyOnWrite(true)\n\t\trb.Flip(650, 132000)\n\t\trb.Flip(648, 651)\n\t\trbcard := rb.GetCardinality()\n\n\t\t// 648, 649, 651-131999\n\t\tassert.EqualValues(t, 132000-651+2, rbcard)\n\n\t\tbs := bitset.New(0)\n\t\tbs.Set(648)\n\t\tbs.Set(649)\n\t\tfor i := uint(651); i < 132000; i++ {\n\t\t\tbs.Set(i)\n\t\t}\n\n\t\tassert.True(t, equalsBitSet(bs, rb))\n\t})\n\n\tt.Run(\"flipTestBig\", func(t *testing.T) {\n\t\tnumCases := 1000\n\t\trb := NewBitmap()\n\t\trb.SetCopyOnWrite(true)\n\t\tbs := bitset.New(0)\n\t\t//Random r = new Random(3333);\n\t\tcheckTime := 2.0\n\n\t\tfor i := 0; i < numCases; i++ {\n\t\t\tstart := rand.Intn(65536 * 20)\n\t\t\tend := rand.Intn(65536 * 20)\n\t\t\tif rand.Float64() < float64(0.1) {\n\t\t\t\tend = start + rand.Intn(100)\n\t\t\t}\n\t\t\trb.Flip(uint64(start), uint64(end))\n\t\t\tif start < end {\n\t\t\t\tFlipRange(start, end, bs) // throws exception\n\t\t\t}\n\t\t\t// otherwise\n\t\t\t// insert some more ANDs to keep things sparser\n\t\t\tif rand.Float64() < 0.2 {\n\t\t\t\tmask := NewBitmap()\n\t\t\t\tmask.SetCopyOnWrite(true)\n\t\t\t\tmask1 := bitset.New(0)\n\t\t\t\tstartM := rand.Intn(65536 * 20)\n\t\t\t\tendM := startM + 100000\n\t\t\t\tmask.Flip(uint64(startM), uint64(endM))\n\t\t\t\tFlipRange(startM, endM, mask1)\n\t\t\t\tmask.Flip(0, 65536*20+100000)\n\t\t\t\tFlipRange(0, 65536*20+100000, mask1)\n\t\t\t\trb.And(mask)\n\t\t\t\tbs.InPlaceIntersection(mask1)\n\t\t\t}\n\t\t\t// see if we can detect incorrectly shared containers\n\t\t\tif rand.Float64() < 0.1 {\n\t\t\t\tirrelevant := Flip(rb, 10, 100000)\n\t\t\t\tirrelevant.Flip(5, 200000)\n\t\t\t\tirrelevant.Flip(190000, 260000)\n\t\t\t}\n\t\t\tif float64(i) > checkTime {\n\t\t\t\tassert.True(t, equalsBitSet(bs, rb))\n\t\t\t\tcheckTime *= 1.5\n\t\t\t}\n\t\t}\n\t})\n\n\tt.Run(\"ortest\", func(t *testing.T) {\n\t\trr := NewBitmap()\n\t\trr.SetCopyOnWrite(true)\n\t\tfor k := 0; k < 4000; k++ {\n\t\t\trr.AddInt(k)\n\t\t}\n\t\trr.AddInt(100000)\n\t\trr.AddInt(110000)\n\t\trr2 := NewBitmap()\n\t\trr2.SetCopyOnWrite(true)\n\t\tfor k := 0; k < 4000; k++ {\n\t\t\trr2.AddInt(k)\n\t\t}\n\n\t\trror := Or(rr, rr2)\n\n\t\tarray := rror.ToArray()\n\n\t\trr.Or(rr2)\n\t\tarrayirr := rr.ToArray()\n\n\t\tassert.True(t, IntsEquals(array, arrayirr))\n\t})\n\n\tt.Run(\"ORtest\", func(t *testing.T) {\n\t\trr := NewBitmap()\n\t\trr.SetCopyOnWrite(true)\n\t\tfor k := 4000; k < 4256; k++ {\n\t\t\trr.AddInt(k)\n\t\t}\n\t\tfor k := 65536; k < 65536+4000; k++ {\n\t\t\trr.AddInt(k)\n\t\t}\n\t\tfor k := 3 * 65536; k < 3*65536+9000; k++ {\n\t\t\trr.AddInt(k)\n\t\t}\n\t\tfor k := 4 * 65535; k < 4*65535+7000; k++ {\n\t\t\trr.AddInt(k)\n\t\t}\n\t\tfor k := 6 * 65535; k < 6*65535+10000; k++ {\n\t\t\trr.AddInt(k)\n\t\t}\n\t\tfor k := 8 * 65535; k < 8*65535+1000; k++ {\n\t\t\trr.AddInt(k)\n\t\t}\n\t\tfor k := 9 * 65535; k < 9*65535+30000; k++ {\n\t\t\trr.AddInt(k)\n\t\t}\n\n\t\trr2 := NewBitmap()\n\t\trr2.SetCopyOnWrite(true)\n\t\tfor k := 4000; k < 4256; k++ {\n\t\t\trr2.AddInt(k)\n\t\t}\n\t\tfor k := 65536; k < 65536+4000; k++ {\n\t\t\trr2.AddInt(k)\n\t\t}\n\t\tfor k := 3*65536 + 2000; k < 3*65536+6000; k++ {\n\t\t\trr2.AddInt(k)\n\t\t}\n\t\tfor k := 6 * 65535; k < 6*65535+1000; k++ {\n\t\t\trr2.AddInt(k)\n\t\t}\n\t\tfor k := 7 * 65535; k < 7*65535+1000; k++ {\n\t\t\trr2.AddInt(k)\n\t\t}\n\t\tfor k := 10 * 65535; k < 10*65535+5000; k++ {\n\t\t\trr2.AddInt(k)\n\t\t}\n\n\t\tcorrect := Or(rr, rr2)\n\t\trr.Or(rr2)\n\n\t\tassert.True(t, correct.Equals(rr))\n\t})\n\n\tt.Run(\"ortest2\", func(t *testing.T) {\n\t\tarrayrr := make([]uint32, 4000+4000+2)\n\t\tpos := 0\n\t\trr := NewBitmap()\n\t\trr.SetCopyOnWrite(true)\n\t\tfor k := 0; k < 4000; k++ {\n\t\t\trr.AddInt(k)\n\t\t\tarrayrr[pos] = uint32(k)\n\t\t\tpos++\n\t\t}\n\t\trr.AddInt(100000)\n\t\trr.AddInt(110000)\n\t\trr2 := NewBitmap()\n\t\trr2.SetCopyOnWrite(true)\n\t\tfor k := 4000; k < 8000; k++ {\n\t\t\trr2.AddInt(k)\n\t\t\tarrayrr[pos] = uint32(k)\n\t\t\tpos++\n\t\t}\n\n\t\tarrayrr[pos] = 100000\n\t\tpos++\n\t\tarrayrr[pos] = 110000\n\t\tpos++\n\n\t\trror := Or(rr, rr2)\n\t\tarrayor := rror.ToArray()\n\n\t\tassert.True(t, IntsEquals(arrayor, arrayrr))\n\t})\n\n\tt.Run(\"ortest3\", func(t *testing.T) {\n\t\tV1 := make(map[int]bool)\n\t\tV2 := make(map[int]bool)\n\n\t\trr := NewBitmap()\n\t\trr.SetCopyOnWrite(true)\n\t\trr2 := NewBitmap()\n\t\trr2.SetCopyOnWrite(true)\n\t\tfor k := 0; k < 4000; k++ {\n\t\t\trr2.AddInt(k)\n\t\t\tV1[k] = true\n\t\t}\n\t\tfor k := 3500; k < 4500; k++ {\n\t\t\trr.AddInt(k)\n\t\t\tV1[k] = true\n\t\t}\n\t\tfor k := 4000; k < 65000; k++ {\n\t\t\trr2.AddInt(k)\n\t\t\tV1[k] = true\n\t\t}\n\n\t\t// In the second node of each roaring bitmap, we have two bitmap\n\t\t// containers.\n\t\t// So, we will check the union between two BitmapContainers\n\t\tfor k := 65536; k < 65536+10000; k++ {\n\t\t\trr.AddInt(k)\n\t\t\tV1[k] = true\n\t\t}\n\n\t\tfor k := 65536; k < 65536+14000; k++ {\n\t\t\trr2.AddInt(k)\n\t\t\tV1[k] = true\n\t\t}\n\n\t\t// In the 3rd node of each Roaring Bitmap, we have an\n\t\t// ArrayContainer, so, we will try the union between two\n\t\t// ArrayContainers.\n\t\tfor k := 4 * 65535; k < 4*65535+1000; k++ {\n\t\t\trr.AddInt(k)\n\t\t\tV1[k] = true\n\t\t}\n\n\t\tfor k := 4 * 65535; k < 4*65535+800; k++ {\n\t\t\trr2.AddInt(k)\n\t\t\tV1[k] = true\n\t\t}\n\n\t\t// For the rest, we will check if the union will take them in\n\t\t// the result\n\t\tfor k := 6 * 65535; k < 6*65535+1000; k++ {\n\t\t\trr.AddInt(k)\n\t\t\tV1[k] = true\n\t\t}\n\n\t\tfor k := 7 * 65535; k < 7*65535+2000; k++ {\n\t\t\trr2.AddInt(k)\n\t\t\tV1[k] = true\n\t\t}\n\n\t\trror := Or(rr, rr2)\n\t\tvalide := true\n\n\t\tfor _, k := range rror.ToArray() {\n\t\t\t_, found := V1[int(k)]\n\t\t\tif !found {\n\t\t\t\tvalide = false\n\t\t\t}\n\t\t\tV2[int(k)] = true\n\t\t}\n\n\t\tfor k := range V1 {\n\t\t\t_, found := V2[k]\n\t\t\tif !found {\n\t\t\t\tvalide = false\n\t\t\t}\n\t\t}\n\n\t\tassert.True(t, valide)\n\t})\n\n\tt.Run(\"ortest4\", func(t *testing.T) {\n\t\trb := NewBitmap()\n\t\trb.SetCopyOnWrite(true)\n\t\trb2 := NewBitmap()\n\t\trb2.SetCopyOnWrite(true)\n\n\t\tfor i := 0; i < 200000; i += 4 {\n\t\t\trb2.AddInt(i)\n\t\t}\n\t\tfor i := 200000; i < 400000; i += 14 {\n\t\t\trb2.AddInt(i)\n\t\t}\n\t\trb2card := rb2.GetCardinality()\n\n\t\t// check or against an empty bitmap\n\t\torresult := Or(rb, rb2)\n\t\toff := Or(rb2, rb)\n\n\t\tassert.True(t, orresult.Equals(off))\n\t\tassert.Equal(t, orresult.GetCardinality(), rb2card)\n\n\t\tfor i := 500000; i < 600000; i += 14 {\n\t\t\trb.AddInt(i)\n\t\t}\n\t\tfor i := 200000; i < 400000; i += 3 {\n\t\t\trb2.AddInt(i)\n\t\t}\n\t\t// check or against an empty bitmap\n\t\torresult2 := Or(rb, rb2)\n\n\t\tassert.Equal(t, orresult.GetCardinality(), rb2card)\n\t\tassert.Equal(t, rb2.GetCardinality()+rb.GetCardinality(), orresult2.GetCardinality())\n\n\t\trb.Or(rb2)\n\t\tassert.True(t, rb.Equals(orresult2))\n\t})\n\n\tt.Run(\"randomTest\", func(t *testing.T) {\n\t\trTestCOW(t, 15)\n\t\trTestCOW(t, 1024)\n\t\trTestCOW(t, 4096)\n\t\trTestCOW(t, 65536)\n\t\trTestCOW(t, 65536*16)\n\t})\n\n\tt.Run(\"SimpleCardinality\", func(t *testing.T) {\n\t\tN := 512\n\t\tgap := 70\n\n\t\trb := NewBitmap()\n\t\trb.SetCopyOnWrite(true)\n\t\tfor k := 0; k < N; k++ {\n\t\t\trb.AddInt(k * gap)\n\t\t\tassert.EqualValues(t, k+1, rb.GetCardinality())\n\t\t}\n\n\t\tassert.EqualValues(t, N, rb.GetCardinality())\n\n\t\tfor k := 0; k < N; k++ {\n\t\t\trb.AddInt(k * gap)\n\t\t\tassert.EqualValues(t, N, rb.GetCardinality())\n\t\t}\n\t})\n\n\tt.Run(\"XORtest\", func(t *testing.T) {\n\t\trr := NewBitmap()\n\t\trr.SetCopyOnWrite(true)\n\t\tfor k := 4000; k < 4256; k++ {\n\t\t\trr.AddInt(k)\n\t\t}\n\t\tfor k := 65536; k < 65536+4000; k++ {\n\t\t\trr.AddInt(k)\n\t\t}\n\t\tfor k := 3 * 65536; k < 3*65536+9000; k++ {\n\t\t\trr.AddInt(k)\n\t\t}\n\t\tfor k := 4 * 65535; k < 4*65535+7000; k++ {\n\t\t\trr.AddInt(k)\n\t\t}\n\t\tfor k := 6 * 65535; k < 6*65535+10000; k++ {\n\t\t\trr.AddInt(k)\n\t\t}\n\t\tfor k := 8 * 65535; k < 8*65535+1000; k++ {\n\t\t\trr.AddInt(k)\n\t\t}\n\t\tfor k := 9 * 65535; k < 9*65535+30000; k++ {\n\t\t\trr.AddInt(k)\n\t\t}\n\n\t\trr2 := NewBitmap()\n\t\trr2.SetCopyOnWrite(true)\n\t\tfor k := 4000; k < 4256; k++ {\n\t\t\trr2.AddInt(k)\n\t\t}\n\t\tfor k := 65536; k < 65536+4000; k++ {\n\t\t\trr2.AddInt(k)\n\t\t}\n\t\tfor k := 3*65536 + 2000; k < 3*65536+6000; k++ {\n\t\t\trr2.AddInt(k)\n\t\t}\n\t\tfor k := 6 * 65535; k < 6*65535+1000; k++ {\n\t\t\trr2.AddInt(k)\n\t\t}\n\t\tfor k := 7 * 65535; k < 7*65535+1000; k++ {\n\t\t\trr2.AddInt(k)\n\t\t}\n\t\tfor k := 10 * 65535; k < 10*65535+5000; k++ {\n\t\t\trr2.AddInt(k)\n\t\t}\n\t\tcorrect := Xor(rr, rr2)\n\t\trr.Xor(rr2)\n\n\t\tassert.True(t, correct.Equals(rr))\n\t})\n\n\tt.Run(\"xortest1\", func(t *testing.T) {\n\t\tV1 := make(map[int]bool)\n\t\tV2 := make(map[int]bool)\n\n\t\trr := NewBitmap()\n\t\trr.SetCopyOnWrite(true)\n\t\trr2 := NewBitmap()\n\t\trr2.SetCopyOnWrite(true)\n\t\t// For the first 65536: rr2 has a bitmap container, and rr has\n\t\t// an array container.\n\t\t// We will check the union between a BitmapCintainer and an\n\t\t// arrayContainer\n\t\tfor k := 0; k < 4000; k++ {\n\t\t\trr2.AddInt(k)\n\t\t\tif k < 3500 {\n\t\t\t\tV1[k] = true\n\t\t\t}\n\t\t}\n\t\tfor k := 3500; k < 4500; k++ {\n\t\t\trr.AddInt(k)\n\t\t}\n\t\tfor k := 4000; k < 65000; k++ {\n\t\t\trr2.AddInt(k)\n\t\t\tif k >= 4500 {\n\t\t\t\tV1[k] = true\n\t\t\t}\n\t\t}\n\n\t\tfor k := 65536; k < 65536+30000; k++ {\n\t\t\trr.AddInt(k)\n\t\t}\n\n\t\tfor k := 65536; k < 65536+50000; k++ {\n\t\t\trr2.AddInt(k)\n\t\t\tif k >= 65536+30000 {\n\t\t\t\tV1[k] = true\n\t\t\t}\n\t\t}\n\n\t\t// In the 3rd node of each Roaring Bitmap, we have an\n\t\t// ArrayContainer. So, we will try the union between two\n\t\t// ArrayContainers.\n\t\tfor k := 4 * 65535; k < 4*65535+1000; k++ {\n\t\t\trr.AddInt(k)\n\t\t\tif k >= (4*65535 + 800) {\n\t\t\t\tV1[k] = true\n\t\t\t}\n\t\t}\n\n\t\tfor k := 4 * 65535; k < 4*65535+800; k++ {\n\t\t\trr2.AddInt(k)\n\t\t}\n\n\t\tfor k := 6 * 65535; k < 6*65535+1000; k++ {\n\t\t\trr.AddInt(k)\n\t\t\tV1[k] = true\n\t\t}\n\n\t\tfor k := 7 * 65535; k < 7*65535+2000; k++ {\n\t\t\trr2.AddInt(k)\n\t\t\tV1[k] = true\n\t\t}\n\n\t\trrxor := Xor(rr, rr2)\n\t\tvalide := true\n\n\t\tfor _, i := range rrxor.ToArray() {\n\t\t\t_, found := V1[int(i)]\n\t\t\tif !found {\n\t\t\t\tvalide = false\n\t\t\t}\n\t\t\tV2[int(i)] = true\n\t\t}\n\t\tfor k := range V1 {\n\t\t\t_, found := V2[k]\n\t\t\tif !found {\n\t\t\t\tvalide = false\n\t\t\t}\n\t\t}\n\n\t\tassert.True(t, valide)\n\t})\n}\n\nfunc TestXORtest4COW(t *testing.T) {\n\trb := NewBitmap()\n\trb.SetCopyOnWrite(true)\n\trb2 := NewBitmap()\n\trb2.SetCopyOnWrite(true)\n\tcounter := 0\n\n\tfor i := 0; i < 200000; i += 4 {\n\t\trb2.AddInt(i)\n\t\tcounter++\n\t}\n\n\tassert.EqualValues(t, counter, rb2.GetCardinality())\n\n\tfor i := 200000; i < 400000; i += 14 {\n\t\trb2.AddInt(i)\n\t\tcounter++\n\t}\n\n\tassert.EqualValues(t, counter, rb2.GetCardinality())\n\n\trb2card := rb2.GetCardinality()\n\tassert.EqualValues(t, counter, rb2card)\n\n\t// check or against an empty bitmap\n\txorresult := Xor(rb, rb2)\n\tassert.EqualValues(t, counter, xorresult.GetCardinality())\n\n\toff := Or(rb2, rb)\n\n\tassert.EqualValues(t, counter, off.GetCardinality())\n\tassert.True(t, xorresult.Equals(off))\n\n\tassert.Equal(t, xorresult.GetCardinality(), rb2card)\n\tfor i := 500000; i < 600000; i += 14 {\n\t\trb.AddInt(i)\n\t}\n\tfor i := 200000; i < 400000; i += 3 {\n\t\trb2.AddInt(i)\n\t}\n\t// check or against an empty bitmap\n\txorresult2 := Xor(rb, rb2)\n\n\tassert.Equal(t, xorresult.GetCardinality(), rb2card)\n\tassert.Equal(t, xorresult2.GetCardinality(), rb2.GetCardinality()+rb.GetCardinality())\n\n\trb.Xor(rb2)\n\tassert.True(t, xorresult2.Equals(rb))\n\t//need to add the massives\n}\n\nfunc TestBigRandomCOW(t *testing.T) {\n\tt.Run(\"randomTest\", func(t *testing.T) {\n\t\trTestCOW(t, 15)\n\t\trTestCOW(t, 100)\n\t\trTestCOW(t, 512)\n\t\trTestCOW(t, 1023)\n\t\trTestCOW(t, 1025)\n\t\trTestCOW(t, 4095)\n\t\trTestCOW(t, 4096)\n\t\trTestCOW(t, 4097)\n\t\trTestCOW(t, 65536)\n\t\trTestCOW(t, 65536*16)\n\t})\n}\n\nfunc rTestCOW(t *testing.T, N int) {\n\tfor gap := 1; gap <= 65536; gap *= 2 {\n\t\tbs1 := bitset.New(0)\n\t\trb1 := NewBitmap()\n\t\trb1.SetCopyOnWrite(true)\n\t\tfor x := 0; x <= N; x += gap {\n\t\t\tbs1.Set(uint(x))\n\t\t\trb1.AddInt(x)\n\t\t}\n\n\t\tassert.EqualValues(t, rb1.GetCardinality(), bs1.Count())\n\t\tassert.True(t, equalsBitSet(bs1, rb1))\n\n\t\tfor offset := 1; offset <= gap; offset *= 2 {\n\t\t\tbs2 := bitset.New(0)\n\t\t\trb2 := NewBitmap()\n\t\t\trb2.SetCopyOnWrite(true)\n\t\t\tfor x := 0; x <= N; x += gap {\n\t\t\t\tbs2.Set(uint(x + offset))\n\t\t\t\trb2.AddInt(x + offset)\n\t\t\t}\n\n\t\t\tassert.EqualValues(t, rb2.GetCardinality(), bs2.Count())\n\t\t\tassert.True(t, equalsBitSet(bs2, rb2))\n\n\t\t\tclonebs1 := bs1.Clone()\n\t\t\tclonebs1.InPlaceIntersection(bs2)\n\t\t\tif !equalsBitSet(clonebs1, And(rb1, rb2)) {\n\t\t\t\tv := rb1.Clone()\n\t\t\t\tv.And(rb2)\n\t\t\t\tassert.True(t, equalsBitSet(clonebs1, v))\n\t\t\t}\n\n\t\t\t// testing OR\n\t\t\tclonebs1 = bs1.Clone()\n\t\t\tclonebs1.InPlaceUnion(bs2)\n\n\t\t\tassert.True(t, equalsBitSet(clonebs1, Or(rb1, rb2)))\n\n\t\t\t// testing XOR\n\t\t\tclonebs1 = bs1.Clone()\n\t\t\tclonebs1.InPlaceSymmetricDifference(bs2)\n\n\t\t\tassert.True(t, equalsBitSet(clonebs1, Xor(rb1, rb2)))\n\n\t\t\t//testing NOTAND\n\t\t\tclonebs1 = bs1.Clone()\n\t\t\tclonebs1.InPlaceDifference(bs2)\n\n\t\t\tassert.True(t, equalsBitSet(clonebs1, AndNot(rb1, rb2)))\n\t\t}\n\t}\n}\n\nfunc TestRoaringArrayCOW(t *testing.T) {\n\ta := newRoaringArray()\n\n\tt.Run(\"Test Init\", func(t *testing.T) {\n\t\tassert.Equal(t, 0, a.size())\n\t})\n\n\tt.Run(\"Test Insert\", func(t *testing.T) {\n\t\ta.appendContainer(0, newArrayContainer(), false)\n\n\t\tassert.Equal(t, 1, a.size())\n\t})\n\n\tt.Run(\"Test Remove\", func(t *testing.T) {\n\t\ta.remove(0)\n\t\tassert.Equal(t, 0, a.size())\n\t})\n\n\tt.Run(\"Test popcount Full\", func(t *testing.T) {\n\t\tres := popcount(uint64(0xffffffffffffffff))\n\t\tassert.EqualValues(t, 64, res)\n\t})\n\n\tt.Run(\"Test popcount Empty\", func(t *testing.T) {\n\t\tres := popcount(0)\n\t\tassert.EqualValues(t, 0, res)\n\t})\n\n\tt.Run(\"Test popcount 16\", func(t *testing.T) {\n\t\tres := popcount(0xff00ff)\n\t\tassert.EqualValues(t, 16, res)\n\t})\n\n\tt.Run(\"Test ArrayContainer Add\", func(t *testing.T) {\n\t\tar := newArrayContainer()\n\t\tar.iadd(1)\n\n\t\tassert.EqualValues(t, 1, ar.getCardinality())\n\t})\n\n\tt.Run(\"Test ArrayContainer Add wacky\", func(t *testing.T) {\n\t\tar := newArrayContainer()\n\t\tar.iadd(0)\n\t\tar.iadd(5000)\n\n\t\tassert.EqualValues(t, 2, ar.getCardinality())\n\t})\n\n\tt.Run(\"Test ArrayContainer Add Reverse\", func(t *testing.T) {\n\t\tar := newArrayContainer()\n\t\tar.iadd(5000)\n\t\tar.iadd(2048)\n\t\tar.iadd(0)\n\n\t\tassert.EqualValues(t, 3, ar.getCardinality())\n\t})\n\n\tt.Run(\"Test BitmapContainer Add \", func(t *testing.T) {\n\t\tbm := newBitmapContainer()\n\t\tbm.iadd(0)\n\n\t\tassert.EqualValues(t, 1, bm.getCardinality())\n\t})\n}\n\nfunc TestFlipBigACOW(t *testing.T) {\n\tnumCases := 1000\n\tbs := bitset.New(0)\n\tcheckTime := 2.0\n\trb1 := NewBitmap()\n\trb1.SetCopyOnWrite(true)\n\trb2 := NewBitmap()\n\trb2.SetCopyOnWrite(true)\n\n\tfor i := 0; i < numCases; i++ {\n\t\tstart := rand.Intn(65536 * 20)\n\t\tend := rand.Intn(65536 * 20)\n\t\tif rand.Float64() < 0.1 {\n\t\t\tend = start + rand.Intn(100)\n\t\t}\n\n\t\tif (i & 1) == 0 {\n\t\t\trb2 = FlipInt(rb1, start, end)\n\t\t\t// tweak the other, catch bad sharing\n\t\t\trb1.FlipInt(rand.Intn(65536*20), rand.Intn(65536*20))\n\t\t} else {\n\t\t\trb1 = FlipInt(rb2, start, end)\n\t\t\trb2.FlipInt(rand.Intn(65536*20), rand.Intn(65536*20))\n\t\t}\n\n\t\tif start < end {\n\t\t\tFlipRange(start, end, bs) // throws exception\n\t\t}\n\t\t// otherwise\n\t\t// insert some more ANDs to keep things sparser\n\t\tif (rand.Float64() < 0.2) && (i&1) == 0 {\n\t\t\tmask := NewBitmap()\n\t\t\tmask.SetCopyOnWrite(true)\n\t\t\tmask1 := bitset.New(0)\n\t\t\tstartM := rand.Intn(65536 * 20)\n\t\t\tendM := startM + 100000\n\t\t\tmask.FlipInt(startM, endM)\n\t\t\tFlipRange(startM, endM, mask1)\n\t\t\tmask.FlipInt(0, 65536*20+100000)\n\t\t\tFlipRange(0, 65536*20+100000, mask1)\n\t\t\trb2.And(mask)\n\t\t\tbs.InPlaceIntersection(mask1)\n\t\t}\n\n\t\tif float64(i) > checkTime {\n\t\t\tvar rb *Bitmap\n\n\t\t\tif (i & 1) == 0 {\n\t\t\t\trb = rb2\n\t\t\t} else {\n\t\t\t\trb = rb1\n\t\t\t}\n\t\t\tassert.True(t, equalsBitSet(bs, rb))\n\t\t\tcheckTime *= 1.5\n\t\t}\n\t}\n}\n\nfunc TestDoubleAddCOW(t *testing.T) {\n\tt.Run(\"doubleadd \", func(t *testing.T) {\n\t\trb := NewBitmap()\n\t\trb.SetCopyOnWrite(true)\n\t\trb.AddRange(65533, 65536)\n\t\trb.AddRange(65530, 65536)\n\t\trb2 := NewBitmap()\n\t\trb2.SetCopyOnWrite(true)\n\t\trb2.AddRange(65530, 65536)\n\n\t\tassert.True(t, rb.Equals(rb2))\n\n\t\trb2.RemoveRange(65530, 65536)\n\t\tassert.EqualValues(t, 0, rb2.GetCardinality())\n\t})\n\n\tt.Run(\"doubleadd2 \", func(t *testing.T) {\n\t\trb := NewBitmap()\n\t\trb.SetCopyOnWrite(true)\n\t\trb.AddRange(65533, 65536*20)\n\t\trb.AddRange(65530, 65536*20)\n\t\trb2 := NewBitmap()\n\t\trb2.SetCopyOnWrite(true)\n\t\trb2.AddRange(65530, 65536*20)\n\n\t\tassert.True(t, rb.Equals(rb2))\n\n\t\trb2.RemoveRange(65530, 65536*20)\n\t\tassert.EqualValues(t, 0, rb2.GetCardinality())\n\t})\n\n\tt.Run(\"doubleadd3 \", func(t *testing.T) {\n\t\trb := NewBitmap()\n\t\trb.SetCopyOnWrite(true)\n\t\trb.AddRange(65533, 65536*20+10)\n\t\trb.AddRange(65530, 65536*20+10)\n\n\t\trb2 := NewBitmap()\n\t\trb2.SetCopyOnWrite(true)\n\t\trb2.AddRange(65530, 65536*20+10)\n\t\tassert.True(t, rb.Equals(rb2))\n\t\trb2.RemoveRange(65530, 65536*20+1)\n\n\t\tassert.EqualValues(t, 9, rb2.GetCardinality())\n\t})\n\n\tt.Run(\"doubleadd4 \", func(t *testing.T) {\n\t\trb := NewBitmap()\n\t\trb.SetCopyOnWrite(true)\n\t\trb.AddRange(65533, 65536*20)\n\t\trb.RemoveRange(65533+5, 65536*20)\n\n\t\tassert.EqualValues(t, 5, rb.GetCardinality())\n\t})\n\n\tt.Run(\"doubleadd5 \", func(t *testing.T) {\n\t\trb := NewBitmap()\n\t\trb.SetCopyOnWrite(true)\n\t\trb.AddRange(65533, 65536*20)\n\t\trb.RemoveRange(65533+5, 65536*20-5)\n\n\t\tassert.EqualValues(t, 10, rb.GetCardinality())\n\t})\n\n\tt.Run(\"doubleadd6 \", func(t *testing.T) {\n\t\trb := NewBitmap()\n\t\trb.SetCopyOnWrite(true)\n\t\trb.AddRange(65533, 65536*20-5)\n\t\trb.RemoveRange(65533+5, 65536*20-10)\n\n\t\tassert.EqualValues(t, 10, rb.GetCardinality())\n\t})\n\n\tt.Run(\"doubleadd7 \", func(t *testing.T) {\n\t\trb := NewBitmap()\n\t\trb.SetCopyOnWrite(true)\n\t\trb.AddRange(65533, 65536*20+1)\n\t\trb.RemoveRange(65533+1, 65536*20)\n\n\t\tassert.EqualValues(t, 2, rb.GetCardinality())\n\t})\n\n\tt.Run(\"AndNotBug01 \", func(t *testing.T) {\n\t\trb1 := NewBitmap()\n\t\trb1.SetCopyOnWrite(true)\n\t\trb1.AddRange(0, 60000)\n\t\trb2 := NewBitmap()\n\t\trb2.SetCopyOnWrite(true)\n\t\trb2.AddRange(60000-10, 60000+10)\n\t\trb2.AndNot(rb1)\n\t\trb3 := NewBitmap()\n\t\trb3.SetCopyOnWrite(true)\n\t\trb3.AddRange(60000, 60000+10)\n\n\t\tassert.True(t, rb2.Equals(rb3))\n\t})\n}\n\nfunc TestAndNotCOW(t *testing.T) {\n\trr := NewBitmap()\n\trr.SetCopyOnWrite(true)\n\tfor k := 4000; k < 4256; k++ {\n\t\trr.AddInt(k)\n\t}\n\tfor k := 65536; k < 65536+4000; k++ {\n\t\trr.AddInt(k)\n\t}\n\tfor k := 3 * 65536; k < 3*65536+9000; k++ {\n\t\trr.AddInt(k)\n\t}\n\tfor k := 4 * 65535; k < 4*65535+7000; k++ {\n\t\trr.AddInt(k)\n\t}\n\tfor k := 6 * 65535; k < 6*65535+10000; k++ {\n\t\trr.AddInt(k)\n\t}\n\tfor k := 8 * 65535; k < 8*65535+1000; k++ {\n\t\trr.AddInt(k)\n\t}\n\tfor k := 9 * 65535; k < 9*65535+30000; k++ {\n\t\trr.AddInt(k)\n\t}\n\n\trr2 := NewBitmap()\n\trr2.SetCopyOnWrite(true)\n\tfor k := 4000; k < 4256; k++ {\n\t\trr2.AddInt(k)\n\t}\n\tfor k := 65536; k < 65536+4000; k++ {\n\t\trr2.AddInt(k)\n\t}\n\tfor k := 3*65536 + 2000; k < 3*65536+6000; k++ {\n\t\trr2.AddInt(k)\n\t}\n\tfor k := 6 * 65535; k < 6*65535+1000; k++ {\n\t\trr2.AddInt(k)\n\t}\n\tfor k := 7 * 65535; k < 7*65535+1000; k++ {\n\t\trr2.AddInt(k)\n\t}\n\tfor k := 10 * 65535; k < 10*65535+5000; k++ {\n\t\trr2.AddInt(k)\n\t}\n\tcorrect := AndNot(rr, rr2)\n\trr.AndNot(rr2)\n\n\tassert.True(t, correct.Equals(rr))\n}\n\nfunc TestStatsCOW(t *testing.T) {\n\tt.Run(\"Test Stats with empty bitmap\", func(t *testing.T) {\n\t\texpectedStats := Statistics{}\n\t\trr := NewBitmap()\n\t\trr.SetCopyOnWrite(true)\n\n\t\tassert.EqualValues(t, expectedStats, rr.Stats())\n\t})\n\n\tt.Run(\"Test Stats with bitmap Container\", func(t *testing.T) {\n\t\t// Given a bitmap that should have a single bitmap container\n\t\texpectedStats := Statistics{\n\t\t\tCardinality: 60000,\n\t\t\tContainers:  1,\n\n\t\t\tBitmapContainers:      1,\n\t\t\tBitmapContainerValues: 60000,\n\t\t\tBitmapContainerBytes:  8192,\n\n\t\t\tRunContainers:      0,\n\t\t\tRunContainerBytes:  0,\n\t\t\tRunContainerValues: 0,\n\t\t}\n\t\trr := NewBitmap()\n\t\trr.SetCopyOnWrite(true)\n\t\tfor i := uint32(0); i < 60000; i++ {\n\t\t\trr.Add(i)\n\t\t}\n\n\t\tassert.EqualValues(t, expectedStats, rr.Stats())\n\t})\n\n\tt.Run(\"Test Stats with Array Container\", func(t *testing.T) {\n\t\t// Given a bitmap that should have a single array container\n\t\texpectedStats := Statistics{\n\t\t\tCardinality: 2,\n\t\t\tContainers:  1,\n\n\t\t\tArrayContainers:      1,\n\t\t\tArrayContainerValues: 2,\n\t\t\tArrayContainerBytes:  4,\n\t\t}\n\t\trr := NewBitmap()\n\t\trr.SetCopyOnWrite(true)\n\t\trr.Add(2)\n\t\trr.Add(4)\n\n\t\tassert.EqualValues(t, expectedStats, rr.Stats())\n\t})\n}\n\nfunc TestFlipVerySmallCOW(t *testing.T) {\n\trb := NewBitmap()\n\trb.SetCopyOnWrite(true)\n\trb.Flip(0, 10) // got [0,9], card is 10\n\trb.Flip(0, 1)  // give back the number 0, card goes to 9\n\trbcard := rb.GetCardinality()\n\n\tassert.EqualValues(t, 9, rbcard)\n}\n\nfunc TestCloneCOWContainers(t *testing.T) {\n\trb := NewBitmap()\n\trb.AddRange(0, 3000)\n\tbuf := &bytes.Buffer{}\n\trb.WriteTo(buf)\n\n\tnewRb1 := NewBitmap()\n\tnewRb1.FromBuffer(buf.Bytes())\n\tnewRb1.CloneCopyOnWriteContainers()\n\n\trb2 := NewBitmap()\n\trb2.AddRange(3000, 6000)\n\tbuf.Reset()\n\trb2.WriteTo(buf)\n\n\tassert.EqualValues(t, rb.ToArray(), newRb1.ToArray())\n}\n\nfunc TestInPlaceCOWContainers(t *testing.T) {\n\t// write bitmap\n\twb1 := NewBitmap()\n\twb2 := NewBitmap()\n\n\twb1.AddRange(0, 3000)\n\twb2.AddRange(2000, 5000)\n\n\tbuf1 := &bytes.Buffer{}\n\tbuf2 := &bytes.Buffer{}\n\n\twb1.WriteTo(buf1)\n\twb2.WriteTo(buf2)\n\n\t// read bitmaps\n\trb1 := NewBitmap()\n\trb2 := NewBitmap()\n\n\trb1.FromBuffer(buf1.Bytes())\n\trb2.FromBuffer(buf2.Bytes())\n\n\tassert.True(t, wb1.Equals(rb1))\n\tassert.True(t, wb2.Equals(rb2))\n\n\trb1.Or(rb2)\n\n\tassert.True(t, Or(wb1, wb2).Equals(rb1))\n\tassert.True(t, wb2.Equals(rb2))\n\n\trb3 := NewBitmap()\n\trb3.FromBuffer(buf1.Bytes())\n\n\tassert.True(t, rb3.Equals(wb1))\n}\n"
        },
        {
          "name": "runcontainer.go",
          "type": "blob",
          "size": 71.740234375,
          "content": "package roaring\n\n//\n// Copyright (c) 2016 by the roaring authors.\n// Licensed under the Apache License, Version 2.0.\n//\n// We derive a few lines of code from the sort.Search\n// function in the golang standard library. That function\n// is Copyright 2009 The Go Authors, and licensed\n// under the following BSD-style license.\n/*\nCopyright (c) 2009 The Go Authors. All rights reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are\nmet:\n\n   * Redistributions of source code must retain the above copyright\nnotice, this list of conditions and the following disclaimer.\n   * Redistributions in binary form must reproduce the above\ncopyright notice, this list of conditions and the following disclaimer\nin the documentation and/or other materials provided with the\ndistribution.\n   * Neither the name of Google Inc. nor the names of its\ncontributors may be used to endorse or promote products derived from\nthis software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n\"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\nLIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\nA PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\nOWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\nSPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\nLIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\nTHEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n*/\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"sort\"\n)\n\n// runContainer16 does run-length encoding of sets of\n// uint16 integers.\ntype runContainer16 struct {\n\t// iv is a slice of sorted, non-overlapping, non-adjacent intervals.\n\tiv []interval16\n}\n\n// interval16 is the internal to runContainer16\n// structure that maintains the individual [start, last]\n// closed intervals.\ntype interval16 struct {\n\tstart  uint16\n\tlength uint16 // length minus 1\n}\n\nvar (\n\tErrRunIntervalsEmpty  = errors.New(\"run contained no interval\")\n\tErrRunNonSorted       = errors.New(\"runs were not sorted\")\n\tErrRunIntervalLength  = errors.New(\"interval had zero length\")\n\tErrRunIntervalEqual   = errors.New(\"intervals were equal\")\n\tErrRunIntervalOverlap = errors.New(\"intervals overlapped or were continguous\")\n\tErrRunIntervalSize    = errors.New(\"too many intervals relative to data\")\n\tMaxNumIntervals       = 2048\n\tMaxIntervalsSum       = 2048\n)\n\nfunc newInterval16Range(start, last uint16) interval16 {\n\tif last < start {\n\t\tpanic(fmt.Sprintf(\"last (%d) cannot be smaller than start (%d)\", last, start))\n\t}\n\n\treturn interval16{\n\t\tstart,\n\t\tlast - start,\n\t}\n}\n\n// runlen returns the count of integers in the interval.\nfunc (iv interval16) runlen() int {\n\treturn int(iv.length) + 1\n}\n\nfunc (iv interval16) last() uint16 {\n\treturn iv.start + iv.length\n}\n\n// String produces a human viewable string of the contents.\nfunc (iv interval16) String() string {\n\treturn fmt.Sprintf(\"[%d, %d]\", iv.start, iv.length)\n}\n\nfunc ivalString16(iv []interval16) string {\n\tvar s string\n\tvar j int\n\tvar p interval16\n\tfor j, p = range iv {\n\t\ts += fmt.Sprintf(\"%v:[%d, %d], \", j, p.start, p.last())\n\t}\n\treturn s\n}\n\n// String produces a human viewable string of the contents.\nfunc (rc *runContainer16) String() string {\n\tif len(rc.iv) == 0 {\n\t\treturn \"runContainer16{}\"\n\t}\n\tis := ivalString16(rc.iv)\n\treturn `runContainer16{` + is + `}`\n}\n\n// uint16Slice is a sort.Sort convenience method\ntype uint16Slice []uint16\n\n// Len returns the length of p.\nfunc (p uint16Slice) Len() int { return len(p) }\n\n// Less returns p[i] < p[j]\nfunc (p uint16Slice) Less(i, j int) bool { return p[i] < p[j] }\n\n// Swap swaps elements i and j.\nfunc (p uint16Slice) Swap(i, j int) { p[i], p[j] = p[j], p[i] }\n\n// addHelper helps build a runContainer16.\ntype addHelper16 struct {\n\trunstart      uint16\n\trunlen        uint16\n\tactuallyAdded uint16\n\tm             []interval16\n\trc            *runContainer16\n}\n\nfunc (ah *addHelper16) storeIval(runstart, runlen uint16) {\n\tmi := interval16{start: runstart, length: runlen}\n\tah.m = append(ah.m, mi)\n}\n\nfunc (ah *addHelper16) add(cur, prev uint16, i int) {\n\tif cur == prev+1 {\n\t\tah.runlen++\n\t\tah.actuallyAdded++\n\t} else {\n\t\tif cur < prev {\n\t\t\tpanic(fmt.Sprintf(\"newRunContainer16FromVals sees \"+\n\t\t\t\t\"unsorted vals; vals[%v]=cur=%v < prev=%v. Sort your vals\"+\n\t\t\t\t\" before calling us with alreadySorted == true.\", i, cur, prev))\n\t\t}\n\t\tif cur == prev {\n\t\t\t// ignore duplicates\n\t\t} else {\n\t\t\tah.actuallyAdded++\n\t\t\tah.storeIval(ah.runstart, ah.runlen)\n\t\t\tah.runstart = cur\n\t\t\tah.runlen = 0\n\t\t}\n\t}\n}\n\n// newRunContainerRange makes a new container made of just the specified closed interval [rangestart,rangelast]\nfunc newRunContainer16Range(rangestart uint16, rangelast uint16) *runContainer16 {\n\trc := &runContainer16{}\n\trc.iv = append(rc.iv, newInterval16Range(rangestart, rangelast))\n\treturn rc\n}\n\n// newRunContainer16FromVals makes a new container from vals.\n//\n// For efficiency, vals should be sorted in ascending order.\n// Ideally vals should not contain duplicates, but we detect and\n// ignore them. If vals is already sorted in ascending order, then\n// pass alreadySorted = true. Otherwise, for !alreadySorted,\n// we will sort vals before creating a runContainer16 of them.\n// We sort the original vals, so this will change what the\n// caller sees in vals as a side effect.\nfunc newRunContainer16FromVals(alreadySorted bool, vals ...uint16) *runContainer16 {\n\t// keep this in sync with newRunContainer16FromArray below\n\n\trc := &runContainer16{}\n\tah := addHelper16{rc: rc}\n\n\tif !alreadySorted {\n\t\tsort.Sort(uint16Slice(vals))\n\t}\n\tn := len(vals)\n\tvar cur, prev uint16\n\tswitch {\n\tcase n == 0:\n\t\t// nothing more\n\tcase n == 1:\n\t\tah.m = append(ah.m, newInterval16Range(vals[0], vals[0]))\n\t\tah.actuallyAdded++\n\tdefault:\n\t\tah.runstart = vals[0]\n\t\tah.actuallyAdded++\n\t\tfor i := 1; i < n; i++ {\n\t\t\tprev = vals[i-1]\n\t\t\tcur = vals[i]\n\t\t\tah.add(cur, prev, i)\n\t\t}\n\t\tah.storeIval(ah.runstart, ah.runlen)\n\t}\n\trc.iv = ah.m\n\treturn rc\n}\n\n// newRunContainer16FromBitmapContainer makes a new run container from bc,\n// somewhat efficiently. For reference, see the Java\n// https://github.com/RoaringBitmap/RoaringBitmap/blob/master/src/main/java/org/roaringbitmap/RunContainer.java#L145-L192\nfunc newRunContainer16FromBitmapContainer(bc *bitmapContainer) *runContainer16 {\n\trc := &runContainer16{}\n\tnbrRuns := bc.numberOfRuns()\n\tif nbrRuns == 0 {\n\t\treturn rc\n\t}\n\trc.iv = make([]interval16, nbrRuns)\n\n\tlongCtr := 0            // index of current long in bitmap\n\tcurWord := bc.bitmap[0] // its value\n\trunCount := 0\n\tfor {\n\t\t// potentially multiword advance to first 1 bit\n\t\tfor curWord == 0 && longCtr < len(bc.bitmap)-1 {\n\t\t\tlongCtr++\n\t\t\tcurWord = bc.bitmap[longCtr]\n\t\t}\n\n\t\tif curWord == 0 {\n\t\t\t// wrap up, no more runs\n\t\t\treturn rc\n\t\t}\n\t\tlocalRunStart := countTrailingZeros(curWord)\n\t\trunStart := localRunStart + 64*longCtr\n\t\t// stuff 1s into number's LSBs\n\t\tcurWordWith1s := curWord | (curWord - 1)\n\n\t\t// find the next 0, potentially in a later word\n\t\trunEnd := 0\n\t\tfor curWordWith1s == maxWord && longCtr < len(bc.bitmap)-1 {\n\t\t\tlongCtr++\n\t\t\tcurWordWith1s = bc.bitmap[longCtr]\n\t\t}\n\n\t\tif curWordWith1s == maxWord {\n\t\t\t// a final unterminated run of 1s\n\t\t\trunEnd = wordSizeInBits + longCtr*64\n\t\t\trc.iv[runCount].start = uint16(runStart)\n\t\t\trc.iv[runCount].length = uint16(runEnd) - uint16(runStart) - 1\n\t\t\treturn rc\n\t\t}\n\t\tlocalRunEnd := countTrailingZeros(^curWordWith1s)\n\t\trunEnd = localRunEnd + longCtr*64\n\t\trc.iv[runCount].start = uint16(runStart)\n\t\trc.iv[runCount].length = uint16(runEnd) - 1 - uint16(runStart)\n\t\trunCount++\n\t\t// now, zero out everything right of runEnd.\n\t\tcurWord = curWordWith1s & (curWordWith1s + 1)\n\t\t// We've lathered and rinsed, so repeat...\n\t}\n}\n\n// newRunContainer16FromArray populates a new\n// runContainer16 from the contents of arr.\nfunc newRunContainer16FromArray(arr *arrayContainer) *runContainer16 {\n\t// keep this in sync with newRunContainer16FromVals above\n\n\trc := &runContainer16{}\n\tah := addHelper16{rc: rc}\n\n\tn := arr.getCardinality()\n\tvar cur, prev uint16\n\tswitch {\n\tcase n == 0:\n\t\t// nothing more\n\tcase n == 1:\n\t\tah.m = append(ah.m, newInterval16Range(arr.content[0], arr.content[0]))\n\t\tah.actuallyAdded++\n\tdefault:\n\t\tah.runstart = arr.content[0]\n\t\tah.actuallyAdded++\n\t\tfor i := 1; i < n; i++ {\n\t\t\tprev = arr.content[i-1]\n\t\t\tcur = arr.content[i]\n\t\t\tah.add(cur, prev, i)\n\t\t}\n\t\tah.storeIval(ah.runstart, ah.runlen)\n\t}\n\trc.iv = ah.m\n\treturn rc\n}\n\n// set adds the integers in vals to the set. Vals\n// must be sorted in increasing order; if not, you should set\n// alreadySorted to false, and we will sort them in place for you.\n// (Be aware of this side effect -- it will affect the callers\n// view of vals).\n//\n// If you have a small number of additions to an already\n// big runContainer16, calling Add() may be faster.\nfunc (rc *runContainer16) set(alreadySorted bool, vals ...uint16) {\n\trc2 := newRunContainer16FromVals(alreadySorted, vals...)\n\tun := rc.union(rc2)\n\trc.iv = un.iv\n}\n\n// canMerge returns true iff the intervals\n// a and b either overlap or they are\n// contiguous and so can be merged into\n// a single interval.\nfunc canMerge16(a, b interval16) bool {\n\tif int(a.last())+1 < int(b.start) {\n\t\treturn false\n\t}\n\treturn int(b.last())+1 >= int(a.start)\n}\n\n// haveOverlap differs from canMerge in that\n// it tells you if the intersection of a\n// and b would contain an element (otherwise\n// it would be the empty set, and we return\n// false).\nfunc haveOverlap16(a, b interval16) bool {\n\tif int(a.last())+1 <= int(b.start) {\n\t\treturn false\n\t}\n\treturn int(b.last())+1 > int(a.start)\n}\n\n// mergeInterval16s joins a and b into a\n// new interval, and panics if it cannot.\nfunc mergeInterval16s(a, b interval16) (res interval16) {\n\tif !canMerge16(a, b) {\n\t\tpanic(fmt.Sprintf(\"cannot merge %#v and %#v\", a, b))\n\t}\n\n\tif b.start < a.start {\n\t\tres.start = b.start\n\t} else {\n\t\tres.start = a.start\n\t}\n\n\tif b.last() > a.last() {\n\t\tres.length = b.last() - res.start\n\t} else {\n\t\tres.length = a.last() - res.start\n\t}\n\n\treturn\n}\n\n// intersectInterval16s returns the intersection\n// of a and b. The isEmpty flag will be true if\n// a and b were disjoint.\nfunc intersectInterval16s(a, b interval16) (res interval16, isEmpty bool) {\n\tif !haveOverlap16(a, b) {\n\t\tisEmpty = true\n\t\treturn\n\t}\n\tif b.start > a.start {\n\t\tres.start = b.start\n\t} else {\n\t\tres.start = a.start\n\t}\n\n\tbEnd := b.last()\n\taEnd := a.last()\n\tvar resEnd uint16\n\n\tif bEnd < aEnd {\n\t\tresEnd = bEnd\n\t} else {\n\t\tresEnd = aEnd\n\t}\n\tres.length = resEnd - res.start\n\treturn\n}\n\n// union merges two runContainer16s, producing\n// a new runContainer16 with the union of rc and b.\nfunc (rc *runContainer16) union(b *runContainer16) *runContainer16 {\n\t// rc is also known as 'a' here, but golint insisted we\n\t// call it rc for consistency with the rest of the methods.\n\n\tvar m []interval16\n\n\talim := int(len(rc.iv))\n\tblim := int(len(b.iv))\n\n\tvar na int // next from a\n\tvar nb int // next from b\n\n\t// merged holds the current merge output, which might\n\t// get additional merges before being appended to m.\n\tvar merged interval16\n\tvar mergedUsed bool // is merged being used at the moment?\n\n\tvar cura interval16 // currently considering this interval16 from a\n\tvar curb interval16 // currently considering this interval16 from b\n\n\tpass := 0\n\tfor na < alim && nb < blim {\n\t\tpass++\n\t\tcura = rc.iv[na]\n\t\tcurb = b.iv[nb]\n\n\t\tif mergedUsed {\n\t\t\tmergedUpdated := false\n\t\t\tif canMerge16(cura, merged) {\n\t\t\t\tmerged = mergeInterval16s(cura, merged)\n\t\t\t\tna = rc.indexOfIntervalAtOrAfter(int(merged.last())+1, na+1)\n\t\t\t\tmergedUpdated = true\n\t\t\t}\n\t\t\tif canMerge16(curb, merged) {\n\t\t\t\tmerged = mergeInterval16s(curb, merged)\n\t\t\t\tnb = b.indexOfIntervalAtOrAfter(int(merged.last())+1, nb+1)\n\t\t\t\tmergedUpdated = true\n\t\t\t}\n\t\t\tif !mergedUpdated {\n\t\t\t\t// we know that merged is disjoint from cura and curb\n\t\t\t\tm = append(m, merged)\n\t\t\t\tmergedUsed = false\n\t\t\t}\n\t\t\tcontinue\n\n\t\t} else {\n\t\t\t// !mergedUsed\n\t\t\tif !canMerge16(cura, curb) {\n\t\t\t\tif cura.start < curb.start {\n\t\t\t\t\tm = append(m, cura)\n\t\t\t\t\tna++\n\t\t\t\t} else {\n\t\t\t\t\tm = append(m, curb)\n\t\t\t\t\tnb++\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tmerged = mergeInterval16s(cura, curb)\n\t\t\t\tmergedUsed = true\n\t\t\t\tna = rc.indexOfIntervalAtOrAfter(int(merged.last())+1, na+1)\n\t\t\t\tnb = b.indexOfIntervalAtOrAfter(int(merged.last())+1, nb+1)\n\t\t\t}\n\t\t}\n\t}\n\tvar aDone, bDone bool\n\tif na >= alim {\n\t\taDone = true\n\t}\n\tif nb >= blim {\n\t\tbDone = true\n\t}\n\t// finish by merging anything remaining into merged we can:\n\tif mergedUsed {\n\t\tif !aDone {\n\t\taAdds:\n\t\t\tfor na < alim {\n\t\t\t\tcura = rc.iv[na]\n\t\t\t\tif canMerge16(cura, merged) {\n\t\t\t\t\tmerged = mergeInterval16s(cura, merged)\n\t\t\t\t\tna = rc.indexOfIntervalAtOrAfter(int(merged.last())+1, na+1)\n\t\t\t\t} else {\n\t\t\t\t\tbreak aAdds\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif !bDone {\n\t\tbAdds:\n\t\t\tfor nb < blim {\n\t\t\t\tcurb = b.iv[nb]\n\t\t\t\tif canMerge16(curb, merged) {\n\t\t\t\t\tmerged = mergeInterval16s(curb, merged)\n\t\t\t\t\tnb = b.indexOfIntervalAtOrAfter(int(merged.last())+1, nb+1)\n\t\t\t\t} else {\n\t\t\t\t\tbreak bAdds\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tm = append(m, merged)\n\t}\n\tif na < alim {\n\t\tm = append(m, rc.iv[na:]...)\n\t}\n\tif nb < blim {\n\t\tm = append(m, b.iv[nb:]...)\n\t}\n\n\tres := &runContainer16{iv: m}\n\treturn res\n}\n\n// unionCardinality returns the cardinality of the merger of two runContainer16s,  the union of rc and b.\nfunc (rc *runContainer16) unionCardinality(b *runContainer16) uint {\n\t// rc is also known as 'a' here, but golint insisted we\n\t// call it rc for consistency with the rest of the methods.\n\tanswer := uint(0)\n\n\talim := int(len(rc.iv))\n\tblim := int(len(b.iv))\n\n\tvar na int // next from a\n\tvar nb int // next from b\n\n\t// merged holds the current merge output, which might\n\t// get additional merges before being appended to m.\n\tvar merged interval16\n\tvar mergedUsed bool // is merged being used at the moment?\n\n\tvar cura interval16 // currently considering this interval16 from a\n\tvar curb interval16 // currently considering this interval16 from b\n\n\tpass := 0\n\tfor na < alim && nb < blim {\n\t\tpass++\n\t\tcura = rc.iv[na]\n\t\tcurb = b.iv[nb]\n\n\t\tif mergedUsed {\n\t\t\tmergedUpdated := false\n\t\t\tif canMerge16(cura, merged) {\n\t\t\t\tmerged = mergeInterval16s(cura, merged)\n\t\t\t\tna = rc.indexOfIntervalAtOrAfter(int(merged.last())+1, na+1)\n\t\t\t\tmergedUpdated = true\n\t\t\t}\n\t\t\tif canMerge16(curb, merged) {\n\t\t\t\tmerged = mergeInterval16s(curb, merged)\n\t\t\t\tnb = b.indexOfIntervalAtOrAfter(int(merged.last())+1, nb+1)\n\t\t\t\tmergedUpdated = true\n\t\t\t}\n\t\t\tif !mergedUpdated {\n\t\t\t\t// we know that merged is disjoint from cura and curb\n\t\t\t\t// m = append(m, merged)\n\t\t\t\tanswer += uint(merged.last()) - uint(merged.start) + 1\n\t\t\t\tmergedUsed = false\n\t\t\t}\n\t\t\tcontinue\n\n\t\t} else {\n\t\t\t// !mergedUsed\n\t\t\tif !canMerge16(cura, curb) {\n\t\t\t\tif cura.start < curb.start {\n\t\t\t\t\tanswer += uint(cura.last()) - uint(cura.start) + 1\n\t\t\t\t\t// m = append(m, cura)\n\t\t\t\t\tna++\n\t\t\t\t} else {\n\t\t\t\t\tanswer += uint(curb.last()) - uint(curb.start) + 1\n\t\t\t\t\t// m = append(m, curb)\n\t\t\t\t\tnb++\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tmerged = mergeInterval16s(cura, curb)\n\t\t\t\tmergedUsed = true\n\t\t\t\tna = rc.indexOfIntervalAtOrAfter(int(merged.last())+1, na+1)\n\t\t\t\tnb = b.indexOfIntervalAtOrAfter(int(merged.last())+1, nb+1)\n\t\t\t}\n\t\t}\n\t}\n\tvar aDone, bDone bool\n\tif na >= alim {\n\t\taDone = true\n\t}\n\tif nb >= blim {\n\t\tbDone = true\n\t}\n\t// finish by merging anything remaining into merged we can:\n\tif mergedUsed {\n\t\tif !aDone {\n\t\taAdds:\n\t\t\tfor na < alim {\n\t\t\t\tcura = rc.iv[na]\n\t\t\t\tif canMerge16(cura, merged) {\n\t\t\t\t\tmerged = mergeInterval16s(cura, merged)\n\t\t\t\t\tna = rc.indexOfIntervalAtOrAfter(int(merged.last())+1, na+1)\n\t\t\t\t} else {\n\t\t\t\t\tbreak aAdds\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif !bDone {\n\t\tbAdds:\n\t\t\tfor nb < blim {\n\t\t\t\tcurb = b.iv[nb]\n\t\t\t\tif canMerge16(curb, merged) {\n\t\t\t\t\tmerged = mergeInterval16s(curb, merged)\n\t\t\t\t\tnb = b.indexOfIntervalAtOrAfter(int(merged.last())+1, nb+1)\n\t\t\t\t} else {\n\t\t\t\t\tbreak bAdds\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// m = append(m, merged)\n\t\tanswer += uint(merged.last()) - uint(merged.start) + 1\n\t}\n\tfor _, r := range rc.iv[na:] {\n\t\tanswer += uint(r.last()) - uint(r.start) + 1\n\t}\n\tfor _, r := range b.iv[nb:] {\n\t\tanswer += uint(r.last()) - uint(r.start) + 1\n\t}\n\treturn answer\n}\n\n// indexOfIntervalAtOrAfter is a helper for union.\nfunc (rc *runContainer16) indexOfIntervalAtOrAfter(key int, startIndex int) int {\n\tw, already, _ := rc.searchRange(key, startIndex, 0)\n\tif already {\n\t\treturn w\n\t}\n\treturn w + 1\n}\n\n// intersect returns a new runContainer16 holding the\n// intersection of rc (also known as 'a')  and b.\nfunc (rc *runContainer16) intersect(b *runContainer16) *runContainer16 {\n\ta := rc\n\tnuma := int(len(a.iv))\n\tnumb := int(len(b.iv))\n\tres := &runContainer16{}\n\tif numa == 0 || numb == 0 {\n\t\treturn res\n\t}\n\n\tif numa == 1 && numb == 1 {\n\t\tif !haveOverlap16(a.iv[0], b.iv[0]) {\n\t\t\treturn res\n\t\t}\n\t}\n\n\tvar output []interval16\n\n\tvar acuri int\n\tvar bcuri int\n\n\tastart := int(a.iv[acuri].start)\n\tbstart := int(b.iv[bcuri].start)\n\n\tvar intersection interval16\n\tvar leftoverstart int\n\tvar isOverlap, isLeftoverA, isLeftoverB bool\n\tvar done bool\ntoploop:\n\tfor acuri < numa && bcuri < numb {\n\n\t\tisOverlap, isLeftoverA, isLeftoverB, leftoverstart, intersection = intersectWithLeftover16(astart, int(a.iv[acuri].last()), bstart, int(b.iv[bcuri].last()))\n\n\t\tif !isOverlap {\n\t\t\tswitch {\n\t\t\tcase astart < bstart:\n\t\t\t\tacuri, done = a.findNextIntervalThatIntersectsStartingFrom(acuri+1, bstart)\n\t\t\t\tif done {\n\t\t\t\t\tbreak toploop\n\t\t\t\t}\n\t\t\t\tastart = int(a.iv[acuri].start)\n\n\t\t\tcase astart > bstart:\n\t\t\t\tbcuri, done = b.findNextIntervalThatIntersectsStartingFrom(bcuri+1, astart)\n\t\t\t\tif done {\n\t\t\t\t\tbreak toploop\n\t\t\t\t}\n\t\t\t\tbstart = int(b.iv[bcuri].start)\n\t\t\t}\n\t\t} else {\n\t\t\t// isOverlap\n\t\t\toutput = append(output, intersection)\n\t\t\tswitch {\n\t\t\tcase isLeftoverA:\n\t\t\t\t// note that we change astart without advancing acuri,\n\t\t\t\t// since we need to capture any 2ndary intersections with a.iv[acuri]\n\t\t\t\tastart = leftoverstart\n\t\t\t\tbcuri++\n\t\t\t\tif bcuri >= numb {\n\t\t\t\t\tbreak toploop\n\t\t\t\t}\n\t\t\t\tbstart = int(b.iv[bcuri].start)\n\t\t\tcase isLeftoverB:\n\t\t\t\t// note that we change bstart without advancing bcuri,\n\t\t\t\t// since we need to capture any 2ndary intersections with b.iv[bcuri]\n\t\t\t\tbstart = leftoverstart\n\t\t\t\tacuri++\n\t\t\t\tif acuri >= numa {\n\t\t\t\t\tbreak toploop\n\t\t\t\t}\n\t\t\t\tastart = int(a.iv[acuri].start)\n\t\t\tdefault:\n\t\t\t\t// neither had leftover, both completely consumed\n\n\t\t\t\t// advance to next a interval\n\t\t\t\tacuri++\n\t\t\t\tif acuri >= numa {\n\t\t\t\t\tbreak toploop\n\t\t\t\t}\n\t\t\t\tastart = int(a.iv[acuri].start)\n\n\t\t\t\t// advance to next b interval\n\t\t\t\tbcuri++\n\t\t\t\tif bcuri >= numb {\n\t\t\t\t\tbreak toploop\n\t\t\t\t}\n\t\t\t\tbstart = int(b.iv[bcuri].start)\n\t\t\t}\n\t\t}\n\t} // end for toploop\n\n\tif len(output) == 0 {\n\t\treturn res\n\t}\n\n\tres.iv = output\n\treturn res\n}\n\n// intersectCardinality returns the cardinality of  the\n// intersection of rc (also known as 'a')  and b.\nfunc (rc *runContainer16) intersectCardinality(b *runContainer16) int {\n\tanswer := int(0)\n\n\ta := rc\n\tnuma := int(len(a.iv))\n\tnumb := int(len(b.iv))\n\tif numa == 0 || numb == 0 {\n\t\treturn 0\n\t}\n\n\tif numa == 1 && numb == 1 {\n\t\tif !haveOverlap16(a.iv[0], b.iv[0]) {\n\t\t\treturn 0\n\t\t}\n\t}\n\n\tvar acuri int\n\tvar bcuri int\n\n\tastart := int(a.iv[acuri].start)\n\tbstart := int(b.iv[bcuri].start)\n\n\tvar intersection interval16\n\tvar leftoverstart int\n\tvar isOverlap, isLeftoverA, isLeftoverB bool\n\tvar done bool\n\tpass := 0\ntoploop:\n\tfor acuri < numa && bcuri < numb {\n\t\tpass++\n\n\t\tisOverlap, isLeftoverA, isLeftoverB, leftoverstart, intersection = intersectWithLeftover16(astart, int(a.iv[acuri].last()), bstart, int(b.iv[bcuri].last()))\n\n\t\tif !isOverlap {\n\t\t\tswitch {\n\t\t\tcase astart < bstart:\n\t\t\t\tacuri, done = a.findNextIntervalThatIntersectsStartingFrom(acuri+1, bstart)\n\t\t\t\tif done {\n\t\t\t\t\tbreak toploop\n\t\t\t\t}\n\t\t\t\tastart = int(a.iv[acuri].start)\n\n\t\t\tcase astart > bstart:\n\t\t\t\tbcuri, done = b.findNextIntervalThatIntersectsStartingFrom(bcuri+1, astart)\n\t\t\t\tif done {\n\t\t\t\t\tbreak toploop\n\t\t\t\t}\n\t\t\t\tbstart = int(b.iv[bcuri].start)\n\t\t\t}\n\t\t} else {\n\t\t\t// isOverlap\n\t\t\tanswer += int(intersection.last()) - int(intersection.start) + 1\n\t\t\tswitch {\n\t\t\tcase isLeftoverA:\n\t\t\t\t// note that we change astart without advancing acuri,\n\t\t\t\t// since we need to capture any 2ndary intersections with a.iv[acuri]\n\t\t\t\tastart = leftoverstart\n\t\t\t\tbcuri++\n\t\t\t\tif bcuri >= numb {\n\t\t\t\t\tbreak toploop\n\t\t\t\t}\n\t\t\t\tbstart = int(b.iv[bcuri].start)\n\t\t\tcase isLeftoverB:\n\t\t\t\t// note that we change bstart without advancing bcuri,\n\t\t\t\t// since we need to capture any 2ndary intersections with b.iv[bcuri]\n\t\t\t\tbstart = leftoverstart\n\t\t\t\tacuri++\n\t\t\t\tif acuri >= numa {\n\t\t\t\t\tbreak toploop\n\t\t\t\t}\n\t\t\t\tastart = int(a.iv[acuri].start)\n\t\t\tdefault:\n\t\t\t\t// neither had leftover, both completely consumed\n\n\t\t\t\t// advance to next a interval\n\t\t\t\tacuri++\n\t\t\t\tif acuri >= numa {\n\t\t\t\t\tbreak toploop\n\t\t\t\t}\n\t\t\t\tastart = int(a.iv[acuri].start)\n\n\t\t\t\t// advance to next b interval\n\t\t\t\tbcuri++\n\t\t\t\tif bcuri >= numb {\n\t\t\t\t\tbreak toploop\n\t\t\t\t}\n\t\t\t\tbstart = int(b.iv[bcuri].start)\n\t\t\t}\n\t\t}\n\t} // end for toploop\n\n\treturn answer\n}\n\n// get returns true iff key is in the container.\nfunc (rc *runContainer16) contains(key uint16) bool {\n\t_, in, _ := rc.search(int(key))\n\treturn in\n}\n\n// numIntervals returns the count of intervals in the container.\nfunc (rc *runContainer16) numIntervals() int {\n\treturn len(rc.iv)\n}\n\n// searchRange returns alreadyPresent to indicate if the\n// key is already in one of our interval16s.\n//\n// If key is alreadyPresent, then whichInterval16 tells\n// you where.\n//\n// If key is not already present, then whichInterval16 is\n// set as follows:\n//\n//\ta) whichInterval16 == len(rc.iv)-1 if key is beyond our\n//\t   last interval16 in rc.iv;\n//\n//\tb) whichInterval16 == -1 if key is before our first\n//\t   interval16 in rc.iv;\n//\n//\tc) whichInterval16 is set to the minimum index of rc.iv\n//\t   which comes strictly before the key;\n//\t   so  rc.iv[whichInterval16].last < key,\n//\t   and  if whichInterval16+1 exists, then key < rc.iv[whichInterval16+1].start\n//\t   (Note that whichInterval16+1 won't exist when\n//\t   whichInterval16 is the last interval.)\n//\n// runContainer16.search always returns whichInterval16 < len(rc.iv).\n//\n// The search space is from startIndex to endxIndex. If endxIndex is set to zero, then there\n// no upper bound.\nfunc (rc *runContainer16) searchRange(key int, startIndex int, endxIndex int) (whichInterval16 int, alreadyPresent bool, numCompares int) {\n\tn := int(len(rc.iv))\n\tif n == 0 {\n\t\treturn -1, false, 0\n\t}\n\tif endxIndex == 0 {\n\t\tendxIndex = n\n\t}\n\n\t// sort.Search returns the smallest index i\n\t// in [0, n) at which f(i) is true, assuming that on the range [0, n),\n\t// f(i) == true implies f(i+1) == true.\n\t// If there is no such index, Search returns n.\n\n\t// For correctness, this began as verbatim snippet from\n\t// sort.Search in the Go standard lib.\n\t// We inline our comparison function for speed, and\n\t// annotate with numCompares\n\t// to observe and test that extra bounds are utilized.\n\ti, j := startIndex, endxIndex\n\tfor i < j {\n\t\th := i + (j-i)/2 // avoid overflow when computing h as the bisector\n\t\t// i <= h < j\n\t\tnumCompares++\n\t\tif !(key < int(rc.iv[h].start)) {\n\t\t\ti = h + 1\n\t\t} else {\n\t\t\tj = h\n\t\t}\n\t}\n\tbelow := i\n\t// end std lib snippet.\n\n\t// The above is a simple in-lining and annotation of:\n\t/*\tbelow := sort.Search(n,\n\t\tfunc(i int) bool {\n\t\t\treturn key < rc.iv[i].start\n\t\t})\n\t*/\n\twhichInterval16 = below - 1\n\n\tif below == n {\n\t\t// all falses => key is >= start of all interval16s\n\t\t// ... so does it belong to the last interval16?\n\t\tif key < int(rc.iv[n-1].last())+1 {\n\t\t\t// yes, it belongs to the last interval16\n\t\t\talreadyPresent = true\n\t\t\treturn\n\t\t}\n\t\t// no, it is beyond the last interval16.\n\t\t// leave alreadyPreset = false\n\t\treturn\n\t}\n\n\t// INVAR: key is below rc.iv[below]\n\tif below == 0 {\n\t\t// key is before the first first interval16.\n\t\t// leave alreadyPresent = false\n\t\treturn\n\t}\n\n\t// INVAR: key is >= rc.iv[below-1].start and\n\t//        key is <  rc.iv[below].start\n\n\t// is key in below-1 interval16?\n\tif key >= int(rc.iv[below-1].start) && key < int(rc.iv[below-1].last())+1 {\n\t\t// yes, it is. key is in below-1 interval16.\n\t\talreadyPresent = true\n\t\treturn\n\t}\n\n\t// INVAR: key >= rc.iv[below-1].endx && key < rc.iv[below].start\n\t// leave alreadyPresent = false\n\treturn\n}\n\n// search returns alreadyPresent to indicate if the\n// key is already in one of our interval16s.\n//\n// If key is alreadyPresent, then whichInterval16 tells\n// you where.\n//\n// If key is not already present, then whichInterval16 is\n// set as follows:\n//\n//\ta) whichInterval16 == len(rc.iv)-1 if key is beyond our\n//\t   last interval16 in rc.iv;\n//\n//\tb) whichInterval16 == -1 if key is before our first\n//\t   interval16 in rc.iv;\n//\n//\tc) whichInterval16 is set to the maximum index of rc.iv\n//\t   which comes strictly before the key;\n//\t   so  rc.iv[whichInterval16].last < key,\n//\t   and  if whichInterval16+1 exists, then key < rc.iv[whichInterval16+1].start\n//\t   (Note that whichInterval16+1 won't exist when\n//\t   whichInterval16 is the last interval.)\n//\n// runContainer16.search always returns whichInterval16 < len(rc.iv).\nfunc (rc *runContainer16) search(key int) (whichInterval16 int, alreadyPresent bool, numCompares int) {\n\treturn rc.searchRange(key, 0, 0)\n}\n\n// getCardinality returns the count of the integers stored in the\n// runContainer16. The running complexity depends on the size\n// of the container.\nfunc (rc *runContainer16) getCardinality() int {\n\t// have to compute it\n\tn := 0\n\tfor _, p := range rc.iv {\n\t\tn += p.runlen()\n\t}\n\treturn n\n}\n\n// isEmpty returns true if the container is empty.\n// It runs in constant time.\nfunc (rc *runContainer16) isEmpty() bool {\n\treturn len(rc.iv) == 0\n}\n\n// AsSlice decompresses the contents into a []uint16 slice.\nfunc (rc *runContainer16) AsSlice() []uint16 {\n\ts := make([]uint16, rc.getCardinality())\n\tj := 0\n\tfor _, p := range rc.iv {\n\t\tfor i := p.start; i <= p.last(); i++ {\n\t\t\ts[j] = i\n\t\t\tj++\n\t\t}\n\t}\n\treturn s\n}\n\n// newRunContainer16 creates an empty run container.\nfunc newRunContainer16() *runContainer16 {\n\treturn &runContainer16{}\n}\n\n// newRunContainer16CopyIv creates a run container, initializing\n// with a copy of the supplied iv slice.\nfunc newRunContainer16CopyIv(iv []interval16) *runContainer16 {\n\trc := &runContainer16{\n\t\tiv: make([]interval16, len(iv)),\n\t}\n\tcopy(rc.iv, iv)\n\treturn rc\n}\n\nfunc (rc *runContainer16) Clone() *runContainer16 {\n\trc2 := newRunContainer16CopyIv(rc.iv)\n\treturn rc2\n}\n\n// newRunContainer16TakeOwnership returns a new runContainer16\n// backed by the provided iv slice, which we will\n// assume exclusive control over from now on.\nfunc newRunContainer16TakeOwnership(iv []interval16) *runContainer16 {\n\trc := &runContainer16{\n\t\tiv: iv,\n\t}\n\treturn rc\n}\n\nconst (\n\tbaseRc16Size        = 2\n\tperIntervalRc16Size = 4\n)\n\n// see also runContainer16SerializedSizeInBytes(numRuns int) int\n\n// getSizeInBytes returns the number of bytes of memory\n// required by this runContainer16.\nfunc (rc *runContainer16) getSizeInBytes() int {\n\treturn perIntervalRc16Size*len(rc.iv) + baseRc16Size\n}\n\n// runContainer16SerializedSizeInBytes returns the number of bytes of disk\n// required to hold numRuns in a runContainer16.\nfunc runContainer16SerializedSizeInBytes(numRuns int) int {\n\treturn perIntervalRc16Size*numRuns + baseRc16Size\n}\n\n// Add adds a single value k to the set.\nfunc (rc *runContainer16) Add(k uint16) (wasNew bool) {\n\t// TODO comment from runContainer16.java:\n\t// it might be better and simpler to do return\n\t// toBitmapOrArrayContainer(getCardinality()).add(k)\n\t// but note that some unit tests use this method to build up test\n\t// runcontainers without calling runOptimize\n\n\tk64 := int(k)\n\n\tindex, present, _ := rc.search(k64)\n\tif present {\n\t\treturn // already there\n\t}\n\twasNew = true\n\n\tn := int(len(rc.iv))\n\tif index == -1 {\n\t\t// we may need to extend the first run\n\t\tif n > 0 {\n\t\t\tif rc.iv[0].start == k+1 {\n\t\t\t\trc.iv[0].start = k\n\t\t\t\trc.iv[0].length++\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t\t// nope, k stands alone, starting the new first interval16.\n\t\trc.iv = append([]interval16{newInterval16Range(k, k)}, rc.iv...)\n\t\treturn\n\t}\n\n\t// are we off the end? handle both index == n and index == n-1:\n\tif index >= n-1 {\n\t\tif int(rc.iv[n-1].last())+1 == k64 {\n\t\t\trc.iv[n-1].length++\n\t\t\treturn\n\t\t}\n\t\trc.iv = append(rc.iv, newInterval16Range(k, k))\n\t\treturn\n\t}\n\n\t// INVAR: index and index+1 both exist, and k goes between them.\n\t//\n\t// Now: add k into the middle,\n\t// possibly fusing with index or index+1 interval16\n\t// and possibly resulting in fusing of two interval16s\n\t// that had a one integer gap.\n\n\tleft := index\n\tright := index + 1\n\n\t// are we fusing left and right by adding k?\n\tif int(rc.iv[left].last())+1 == k64 && int(rc.iv[right].start) == k64+1 {\n\t\t// fuse into left\n\t\trc.iv[left].length = rc.iv[right].last() - rc.iv[left].start\n\t\t// remove redundant right\n\t\trc.iv = append(rc.iv[:left+1], rc.iv[right+1:]...)\n\t\treturn\n\t}\n\n\t// are we an addition to left?\n\tif int(rc.iv[left].last())+1 == k64 {\n\t\t// yes\n\t\trc.iv[left].length++\n\t\treturn\n\t}\n\n\t// are we an addition to right?\n\tif int(rc.iv[right].start) == k64+1 {\n\t\t// yes\n\t\trc.iv[right].start = k\n\t\trc.iv[right].length++\n\t\treturn\n\t}\n\n\t// k makes a standalone new interval16, inserted in the middle\n\ttail := append([]interval16{newInterval16Range(k, k)}, rc.iv[right:]...)\n\trc.iv = append(rc.iv[:left+1], tail...)\n\treturn\n}\n\n// runIterator16 advice: you must call hasNext()\n// before calling next()/peekNext() to insure there are contents.\ntype runIterator16 struct {\n\trc            *runContainer16\n\tcurIndex      int\n\tcurPosInIndex uint16\n}\n\n// newRunIterator16 returns a new empty run container.\nfunc (rc *runContainer16) newRunIterator16() *runIterator16 {\n\treturn &runIterator16{rc: rc, curIndex: 0, curPosInIndex: 0}\n}\n\nfunc (rc *runContainer16) iterate(cb func(x uint16) bool) bool {\n\titerator := runIterator16{rc, 0, 0}\n\n\tfor iterator.hasNext() {\n\t\tif !cb(iterator.next()) {\n\t\t\treturn false\n\t\t}\n\t}\n\n\treturn true\n}\n\n// hasNext returns false if calling next will panic. It\n// returns true when there is at least one more value\n// available in the iteration sequence.\nfunc (ri *runIterator16) hasNext() bool {\n\treturn int(len(ri.rc.iv)) > ri.curIndex+1 ||\n\t\t(int(len(ri.rc.iv)) == ri.curIndex+1 && ri.rc.iv[ri.curIndex].length >= ri.curPosInIndex)\n}\n\n// next returns the next value in the iteration sequence.\nfunc (ri *runIterator16) next() uint16 {\n\tnext := ri.rc.iv[ri.curIndex].start + ri.curPosInIndex\n\n\tif ri.curPosInIndex == ri.rc.iv[ri.curIndex].length {\n\t\tri.curPosInIndex = 0\n\t\tri.curIndex++\n\t} else {\n\t\tri.curPosInIndex++\n\t}\n\n\treturn next\n}\n\n// peekNext returns the next value in the iteration sequence without advancing the iterator\nfunc (ri *runIterator16) peekNext() uint16 {\n\treturn ri.rc.iv[ri.curIndex].start + ri.curPosInIndex\n}\n\n// advanceIfNeeded advances as long as the next value is smaller than minval\nfunc (ri *runIterator16) advanceIfNeeded(minval uint16) {\n\tif !ri.hasNext() || ri.peekNext() >= minval {\n\t\treturn\n\t}\n\n\t// interval cannot be -1 because of minval > peekNext\n\tinterval, isPresent, _ := ri.rc.searchRange(int(minval), ri.curIndex, int(len(ri.rc.iv)))\n\n\t// if the minval is present, set the curPosIndex at the right position\n\tif isPresent {\n\t\tri.curIndex = interval\n\t\tri.curPosInIndex = minval - ri.rc.iv[ri.curIndex].start\n\t} else {\n\t\t// otherwise interval is set to to the minimum index of rc.iv\n\t\t// which comes strictly before the key, that's why we set the next interval\n\t\tri.curIndex = interval + 1\n\t\tri.curPosInIndex = 0\n\t}\n}\n\n// runReverseIterator16 advice: you must call hasNext()\n// before calling next() to insure there are contents.\ntype runReverseIterator16 struct {\n\trc            *runContainer16\n\tcurIndex      int    // index into rc.iv\n\tcurPosInIndex uint16 // offset in rc.iv[curIndex]\n}\n\n// newRunReverseIterator16 returns a new empty run iterator.\nfunc (rc *runContainer16) newRunReverseIterator16() *runReverseIterator16 {\n\tindex := int(len(rc.iv)) - 1\n\tpos := uint16(0)\n\n\tif index >= 0 {\n\t\tpos = rc.iv[index].length\n\t}\n\n\treturn &runReverseIterator16{\n\t\trc:            rc,\n\t\tcurIndex:      index,\n\t\tcurPosInIndex: pos,\n\t}\n}\n\n// hasNext returns false if calling next will panic. It\n// returns true when there is at least one more value\n// available in the iteration sequence.\nfunc (ri *runReverseIterator16) hasNext() bool {\n\treturn ri.curIndex > 0 || ri.curIndex == 0 && ri.curPosInIndex >= 0\n}\n\n// next returns the next value in the iteration sequence.\nfunc (ri *runReverseIterator16) next() uint16 {\n\tnext := ri.rc.iv[ri.curIndex].start + ri.curPosInIndex\n\n\tif ri.curPosInIndex > 0 {\n\t\tri.curPosInIndex--\n\t} else {\n\t\tri.curIndex--\n\n\t\tif ri.curIndex >= 0 {\n\t\t\tri.curPosInIndex = ri.rc.iv[ri.curIndex].length\n\t\t}\n\t}\n\n\treturn next\n}\n\nfunc (rc *runContainer16) newManyRunIterator16() *runIterator16 {\n\treturn rc.newRunIterator16()\n}\n\n// hs are the high bits to include to avoid needing to reiterate over the buffer in NextMany\nfunc (ri *runIterator16) nextMany(hs uint32, buf []uint32) int {\n\tn := 0\n\n\tif !ri.hasNext() {\n\t\treturn n\n\t}\n\n\t// start and end are inclusive\n\tfor n < len(buf) {\n\t\tmoreVals := 0\n\n\t\tif ri.rc.iv[ri.curIndex].length >= ri.curPosInIndex {\n\t\t\t// add as many as you can from this seq\n\t\t\tmoreVals = minOfInt(int(ri.rc.iv[ri.curIndex].length-ri.curPosInIndex)+1, len(buf)-n)\n\t\t\tbase := uint32(ri.rc.iv[ri.curIndex].start+ri.curPosInIndex) | hs\n\n\t\t\t// allows BCE\n\t\t\tbuf2 := buf[n : n+moreVals]\n\t\t\tfor i := range buf2 {\n\t\t\t\tbuf2[i] = base + uint32(i)\n\t\t\t}\n\n\t\t\t// update values\n\t\t\tn += moreVals\n\t\t}\n\n\t\tif moreVals+int(ri.curPosInIndex) > int(ri.rc.iv[ri.curIndex].length) {\n\t\t\tri.curPosInIndex = 0\n\t\t\tri.curIndex++\n\n\t\t\tif ri.curIndex == int(len(ri.rc.iv)) {\n\t\t\t\tbreak\n\t\t\t}\n\t\t} else {\n\t\t\tri.curPosInIndex += uint16(moreVals) // moreVals always fits in uint16\n\t\t}\n\t}\n\n\treturn n\n}\n\nfunc (ri *runIterator16) nextMany64(hs uint64, buf []uint64) int {\n\tn := 0\n\n\tif !ri.hasNext() {\n\t\treturn n\n\t}\n\n\t// start and end are inclusive\n\tfor n < len(buf) {\n\t\tmoreVals := 0\n\n\t\tif ri.rc.iv[ri.curIndex].length >= ri.curPosInIndex {\n\t\t\t// add as many as you can from this seq\n\t\t\tmoreVals = minOfInt(int(ri.rc.iv[ri.curIndex].length-ri.curPosInIndex)+1, len(buf)-n)\n\t\t\tbase := uint64(ri.rc.iv[ri.curIndex].start+ri.curPosInIndex) | hs\n\n\t\t\t// allows BCE\n\t\t\tbuf2 := buf[n : n+moreVals]\n\t\t\tfor i := range buf2 {\n\t\t\t\tbuf2[i] = base + uint64(i)\n\t\t\t}\n\n\t\t\t// update values\n\t\t\tn += moreVals\n\t\t}\n\n\t\tif moreVals+int(ri.curPosInIndex) > int(ri.rc.iv[ri.curIndex].length) {\n\t\t\tri.curPosInIndex = 0\n\t\t\tri.curIndex++\n\n\t\t\tif ri.curIndex == int(len(ri.rc.iv)) {\n\t\t\t\tbreak\n\t\t\t}\n\t\t} else {\n\t\t\tri.curPosInIndex += uint16(moreVals) // moreVals always fits in uint16\n\t\t}\n\t}\n\n\treturn n\n}\n\n// remove removes key from the container.\nfunc (rc *runContainer16) removeKey(key uint16) (wasPresent bool) {\n\tvar index int\n\tindex, wasPresent, _ = rc.search(int(key))\n\tif !wasPresent {\n\t\treturn // already removed, nothing to do.\n\t}\n\tpos := key - rc.iv[index].start\n\trc.deleteAt(&index, &pos)\n\treturn\n}\n\n// internal helper functions\n\nfunc (rc *runContainer16) deleteAt(curIndex *int, curPosInIndex *uint16) {\n\tci := *curIndex\n\tpos := *curPosInIndex\n\n\t// are we first, last, or in the middle of our interval16?\n\tswitch {\n\tcase pos == 0:\n\t\tif int(rc.iv[ci].length) == 0 {\n\t\t\t// our interval disappears\n\t\t\trc.iv = append(rc.iv[:ci], rc.iv[ci+1:]...)\n\t\t\t// curIndex stays the same, since the delete did\n\t\t\t// the advance for us.\n\t\t\t*curPosInIndex = 0\n\t\t} else {\n\t\t\trc.iv[ci].start++ // no longer overflowable\n\t\t\trc.iv[ci].length--\n\t\t}\n\tcase pos == rc.iv[ci].length:\n\t\t// length\n\t\trc.iv[ci].length--\n\t\t// our interval16 cannot disappear, else we would have been pos == 0, case first above.\n\t\t*curPosInIndex--\n\t\t// if we leave *curIndex alone, then Next() will work properly even after the delete.\n\tdefault:\n\t\t// middle\n\t\t// split into two, adding an interval16\n\t\tnew0 := newInterval16Range(rc.iv[ci].start, rc.iv[ci].start+*curPosInIndex-1)\n\n\t\tnew1start := int(rc.iv[ci].start+*curPosInIndex) + 1\n\t\tif new1start > int(MaxUint16) {\n\t\t\tpanic(\"overflow?!?!\")\n\t\t}\n\t\tnew1 := newInterval16Range(uint16(new1start), rc.iv[ci].last())\n\t\ttail := append([]interval16{new0, new1}, rc.iv[ci+1:]...)\n\t\trc.iv = append(rc.iv[:ci], tail...)\n\t\t// update curIndex and curPosInIndex\n\t\t*curIndex++\n\t\t*curPosInIndex = 0\n\t}\n}\n\nfunc have4Overlap16(astart, alast, bstart, blast int) bool {\n\tif alast+1 <= bstart {\n\t\treturn false\n\t}\n\treturn blast+1 > astart\n}\n\nfunc intersectWithLeftover16(astart, alast, bstart, blast int) (isOverlap, isLeftoverA, isLeftoverB bool, leftoverstart int, intersection interval16) {\n\tif !have4Overlap16(astart, alast, bstart, blast) {\n\t\treturn\n\t}\n\tisOverlap = true\n\n\t// do the intersection:\n\tif bstart > astart {\n\t\tintersection.start = uint16(bstart)\n\t} else {\n\t\tintersection.start = uint16(astart)\n\t}\n\n\tswitch {\n\tcase blast < alast:\n\t\tisLeftoverA = true\n\t\tleftoverstart = blast + 1\n\t\tintersection.length = uint16(blast) - intersection.start\n\tcase alast < blast:\n\t\tisLeftoverB = true\n\t\tleftoverstart = alast + 1\n\t\tintersection.length = uint16(alast) - intersection.start\n\tdefault:\n\t\t// alast == blast\n\t\tintersection.length = uint16(alast) - intersection.start\n\t}\n\n\treturn\n}\n\nfunc (rc *runContainer16) findNextIntervalThatIntersectsStartingFrom(startIndex int, key int) (index int, done bool) {\n\tw, _, _ := rc.searchRange(key, startIndex, 0)\n\t// rc.search always returns w < len(rc.iv)\n\tif w < startIndex {\n\t\t// not found and comes before lower bound startIndex,\n\t\t// so just use the lower bound.\n\t\tif startIndex == int(len(rc.iv)) {\n\t\t\t// also this bump up means that we are done\n\t\t\treturn startIndex, true\n\t\t}\n\t\treturn startIndex, false\n\t}\n\n\treturn w, false\n}\n\nfunc sliceToString16(m []interval16) string {\n\ts := \"\"\n\tfor i := range m {\n\t\ts += fmt.Sprintf(\"%v: %s, \", i, m[i])\n\t}\n\treturn s\n}\n\n// helper for invert\nfunc (rc *runContainer16) invertlastInterval(origin uint16, lastIdx int) []interval16 {\n\tcur := rc.iv[lastIdx]\n\tif cur.last() == MaxUint16 {\n\t\tif cur.start == origin {\n\t\t\treturn nil // empty container\n\t\t}\n\t\treturn []interval16{newInterval16Range(origin, cur.start-1)}\n\t}\n\tif cur.start == origin {\n\t\treturn []interval16{newInterval16Range(cur.last()+1, MaxUint16)}\n\t}\n\t// invert splits\n\treturn []interval16{\n\t\tnewInterval16Range(origin, cur.start-1),\n\t\tnewInterval16Range(cur.last()+1, MaxUint16),\n\t}\n}\n\n// invert returns a new container (not inplace), that is\n// the inversion of rc. For each bit b in rc, the\n// returned value has !b\nfunc (rc *runContainer16) invert() *runContainer16 {\n\tni := len(rc.iv)\n\tvar m []interval16\n\tswitch ni {\n\tcase 0:\n\t\treturn &runContainer16{iv: []interval16{newInterval16Range(0, MaxUint16)}}\n\tcase 1:\n\t\treturn &runContainer16{iv: rc.invertlastInterval(0, 0)}\n\t}\n\tvar invstart int\n\tult := ni - 1\n\tfor i, cur := range rc.iv {\n\t\tif i == ult {\n\t\t\t// invertlastInteval will add both intervals (b) and (c) in\n\t\t\t// diagram below.\n\t\t\tm = append(m, rc.invertlastInterval(uint16(invstart), i)...)\n\t\t\tbreak\n\t\t}\n\t\t// INVAR: i and cur are not the last interval, there is a next at i+1\n\t\t//\n\t\t// ........[cur.start, cur.last] ...... [next.start, next.last]....\n\t\t//    ^                             ^                           ^\n\t\t//   (a)                           (b)                         (c)\n\t\t//\n\t\t// Now: we add interval (a); but if (a) is empty, for cur.start==0, we skip it.\n\t\tif cur.start > 0 {\n\t\t\tm = append(m, newInterval16Range(uint16(invstart), cur.start-1))\n\t\t}\n\t\tinvstart = int(cur.last() + 1)\n\t}\n\treturn &runContainer16{iv: m}\n}\n\nfunc (iv interval16) equal(b interval16) bool {\n\treturn iv.start == b.start && iv.length == b.length\n}\n\nfunc (iv interval16) isSuperSetOf(b interval16) bool {\n\treturn iv.start <= b.start && b.last() <= iv.last()\n}\n\nfunc (iv interval16) isNonContiguousDisjoint(b interval16) bool {\n\t// cover the zero start case\n\tif iv.start == b.start {\n\t\treturn false\n\t}\n\n\tnonContiguous1 := iv.start == b.last()+1 || iv.last() == b.start+1\n\tnonContiguous2 := b.start == iv.last()+1 || b.last() == iv.start+1\n\tif nonContiguous1 || nonContiguous2 {\n\t\treturn false\n\t}\n\tivl := iv.last()\n\tbl := b.last()\n\n\tc1 := iv.start <= b.start && b.start <= ivl\n\tc2 := b.start <= iv.start && iv.start <= bl\n\n\treturn !c1 && !c2\n}\n\nfunc (iv interval16) subtractInterval(del interval16) (left []interval16, delcount int) {\n\tisect, isEmpty := intersectInterval16s(iv, del)\n\n\tif isEmpty {\n\t\treturn nil, 0\n\t}\n\tif del.isSuperSetOf(iv) {\n\t\treturn nil, iv.runlen()\n\t}\n\n\tswitch {\n\tcase isect.start > iv.start && isect.last() < iv.last():\n\t\tnew0 := newInterval16Range(iv.start, isect.start-1)\n\t\tnew1 := newInterval16Range(isect.last()+1, iv.last())\n\t\treturn []interval16{new0, new1}, isect.runlen()\n\tcase isect.start == iv.start:\n\t\treturn []interval16{newInterval16Range(isect.last()+1, iv.last())}, isect.runlen()\n\tdefault:\n\t\treturn []interval16{newInterval16Range(iv.start, isect.start-1)}, isect.runlen()\n\t}\n}\n\nfunc (rc *runContainer16) isubtract(del interval16) {\n\torigiv := make([]interval16, len(rc.iv))\n\tcopy(origiv, rc.iv)\n\tn := int(len(rc.iv))\n\tif n == 0 {\n\t\treturn // already done.\n\t}\n\n\t_, isEmpty := intersectInterval16s(newInterval16Range(rc.iv[0].start, rc.iv[n-1].last()), del)\n\tif isEmpty {\n\t\treturn // done\n\t}\n\n\t// INVAR there is some intersection between rc and del\n\tistart, startAlready, _ := rc.search(int(del.start))\n\tilast, lastAlready, _ := rc.search(int(del.last()))\n\tif istart == -1 {\n\t\tif ilast == n-1 && !lastAlready {\n\t\t\trc.iv = nil\n\t\t\treturn\n\t\t}\n\t}\n\t// some intervals will remain\n\tswitch {\n\tcase startAlready && lastAlready:\n\t\tres0, _ := rc.iv[istart].subtractInterval(del)\n\n\t\t// would overwrite values in iv b/c res0 can have len 2. so\n\t\t// write to origiv instead.\n\t\tlost := 1 + ilast - istart\n\t\tchangeSize := int(len(res0)) - lost\n\t\tnewSize := int(len(rc.iv)) + changeSize\n\n\t\t//\trc.iv = append(pre, caboose...)\n\t\t//\treturn\n\n\t\tif ilast != istart {\n\t\t\tres1, _ := rc.iv[ilast].subtractInterval(del)\n\t\t\tres0 = append(res0, res1...)\n\t\t\tchangeSize = int(len(res0)) - lost\n\t\t\tnewSize = int(len(rc.iv)) + changeSize\n\t\t}\n\t\tswitch {\n\t\tcase changeSize < 0:\n\t\t\t// shrink\n\t\t\tcopy(rc.iv[istart+int(len(res0)):], rc.iv[ilast+1:])\n\t\t\tcopy(rc.iv[istart:istart+int(len(res0))], res0)\n\t\t\trc.iv = rc.iv[:newSize]\n\t\t\treturn\n\t\tcase changeSize == 0:\n\t\t\t// stay the same\n\t\t\tcopy(rc.iv[istart:istart+int(len(res0))], res0)\n\t\t\treturn\n\t\tdefault:\n\t\t\t// changeSize > 0 is only possible when ilast == istart.\n\t\t\t// Hence we now know: changeSize == 1 and len(res0) == 2\n\t\t\trc.iv = append(rc.iv, interval16{})\n\t\t\t// len(rc.iv) is correct now, no need to rc.iv = rc.iv[:newSize]\n\n\t\t\t// copy the tail into place\n\t\t\tcopy(rc.iv[ilast+2:], rc.iv[ilast+1:])\n\t\t\t// copy the new item(s) into place\n\t\t\tcopy(rc.iv[istart:istart+2], res0)\n\t\t\treturn\n\t\t}\n\n\tcase !startAlready && !lastAlready:\n\t\t// we get to discard whole intervals\n\n\t\t// from the search() definition:\n\n\t\t// if del.start is not present, then istart is\n\t\t// set as follows:\n\t\t//\n\t\t//  a) istart == n-1 if del.start is beyond our\n\t\t//     last interval16 in rc.iv;\n\t\t//\n\t\t//  b) istart == -1 if del.start is before our first\n\t\t//     interval16 in rc.iv;\n\t\t//\n\t\t//  c) istart is set to the minimum index of rc.iv\n\t\t//     which comes strictly before the del.start;\n\t\t//     so  del.start > rc.iv[istart].last,\n\t\t//     and  if istart+1 exists, then del.start < rc.iv[istart+1].startx\n\n\t\t// if del.last is not present, then ilast is\n\t\t// set as follows:\n\t\t//\n\t\t//  a) ilast == n-1 if del.last is beyond our\n\t\t//     last interval16 in rc.iv;\n\t\t//\n\t\t//  b) ilast == -1 if del.last is before our first\n\t\t//     interval16 in rc.iv;\n\t\t//\n\t\t//  c) ilast is set to the minimum index of rc.iv\n\t\t//     which comes strictly before the del.last;\n\t\t//     so  del.last > rc.iv[ilast].last,\n\t\t//     and  if ilast+1 exists, then del.last < rc.iv[ilast+1].start\n\n\t\t// INVAR: istart >= 0\n\t\tpre := rc.iv[:istart+1]\n\t\tif ilast == n-1 {\n\t\t\trc.iv = pre\n\t\t\treturn\n\t\t}\n\t\t// INVAR: ilast < n-1\n\t\tlost := ilast - istart\n\t\tchangeSize := -lost\n\t\tnewSize := int(len(rc.iv)) + changeSize\n\t\tif changeSize != 0 {\n\t\t\tcopy(rc.iv[ilast+1+changeSize:], rc.iv[ilast+1:])\n\t\t}\n\t\trc.iv = rc.iv[:newSize]\n\t\treturn\n\n\tcase startAlready && !lastAlready:\n\t\t// we can only shrink or stay the same size\n\t\t// i.e. we either eliminate the whole interval,\n\t\t// or just cut off the right side.\n\t\tres0, _ := rc.iv[istart].subtractInterval(del)\n\t\tif len(res0) > 0 {\n\t\t\t// len(res) must be 1\n\t\t\trc.iv[istart] = res0[0]\n\t\t}\n\t\tlost := 1 + (ilast - istart)\n\t\tchangeSize := int(len(res0)) - lost\n\t\tnewSize := int(len(rc.iv)) + changeSize\n\t\tif changeSize != 0 {\n\t\t\tcopy(rc.iv[ilast+1+changeSize:], rc.iv[ilast+1:])\n\t\t}\n\t\trc.iv = rc.iv[:newSize]\n\t\treturn\n\n\tcase !startAlready && lastAlready:\n\t\t// we can only shrink or stay the same size\n\t\tres1, _ := rc.iv[ilast].subtractInterval(del)\n\t\tlost := ilast - istart\n\t\tchangeSize := int(len(res1)) - lost\n\t\tnewSize := int(len(rc.iv)) + changeSize\n\t\tif changeSize != 0 {\n\t\t\t// move the tail first to make room for res1\n\t\t\tcopy(rc.iv[ilast+1+changeSize:], rc.iv[ilast+1:])\n\t\t}\n\t\tcopy(rc.iv[istart+1:], res1)\n\t\trc.iv = rc.iv[:newSize]\n\t\treturn\n\t}\n}\n\n// compute rc minus b, and return the result as a new value (not inplace).\n// port of run_container_andnot from CRoaring...\n// https://github.com/RoaringBitmap/CRoaring/blob/master/src/containers/run.c#L435-L496\nfunc (rc *runContainer16) AndNotRunContainer16(b *runContainer16) *runContainer16 {\n\tif len(b.iv) == 0 || len(rc.iv) == 0 {\n\t\treturn rc\n\t}\n\n\tdst := newRunContainer16()\n\tapos := 0\n\tbpos := 0\n\n\ta := rc\n\n\tastart := a.iv[apos].start\n\talast := a.iv[apos].last()\n\tbstart := b.iv[bpos].start\n\tblast := b.iv[bpos].last()\n\n\talen := len(a.iv)\n\tblen := len(b.iv)\n\n\tfor apos < alen && bpos < blen {\n\t\tswitch {\n\t\tcase alast < bstart:\n\t\t\t// output the first run\n\t\t\tdst.iv = append(dst.iv, newInterval16Range(astart, alast))\n\t\t\tapos++\n\t\t\tif apos < alen {\n\t\t\t\tastart = a.iv[apos].start\n\t\t\t\talast = a.iv[apos].last()\n\t\t\t}\n\t\tcase blast < astart:\n\t\t\t// exit the second run\n\t\t\tbpos++\n\t\t\tif bpos < blen {\n\t\t\t\tbstart = b.iv[bpos].start\n\t\t\t\tblast = b.iv[bpos].last()\n\t\t\t}\n\t\tdefault:\n\t\t\t//   a: [             ]\n\t\t\t//   b:            [    ]\n\t\t\t// alast >= bstart\n\t\t\t// blast >= astart\n\t\t\tif astart < bstart {\n\t\t\t\tdst.iv = append(dst.iv, newInterval16Range(astart, bstart-1))\n\t\t\t}\n\t\t\tif alast > blast {\n\t\t\t\tastart = blast + 1\n\t\t\t} else {\n\t\t\t\tapos++\n\t\t\t\tif apos < alen {\n\t\t\t\t\tastart = a.iv[apos].start\n\t\t\t\t\talast = a.iv[apos].last()\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif apos < alen {\n\t\tdst.iv = append(dst.iv, newInterval16Range(astart, alast))\n\t\tapos++\n\t\tif apos < alen {\n\t\t\tdst.iv = append(dst.iv, a.iv[apos:]...)\n\t\t}\n\t}\n\n\treturn dst\n}\n\nfunc (rc *runContainer16) numberOfRuns() (nr int) {\n\treturn len(rc.iv)\n}\n\nfunc (rc *runContainer16) containerType() contype {\n\treturn run16Contype\n}\n\nfunc (rc *runContainer16) equals16(srb *runContainer16) bool {\n\t// Check if the containers are the same object.\n\tif rc == srb {\n\t\treturn true\n\t}\n\n\tif len(srb.iv) != len(rc.iv) {\n\t\treturn false\n\t}\n\n\tfor i, v := range rc.iv {\n\t\tif v != srb.iv[i] {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\n// compile time verify we meet interface requirements\nvar _ container = &runContainer16{}\n\nfunc (rc *runContainer16) clone() container {\n\treturn newRunContainer16CopyIv(rc.iv)\n}\n\nfunc (rc *runContainer16) minimum() uint16 {\n\treturn rc.iv[0].start // assume not empty\n}\n\nfunc (rc *runContainer16) safeMinimum() (uint16, error) {\n\tif len(rc.iv) == 0 {\n\t\treturn 0, errors.New(\"Empty runs\")\n\t}\n\n\treturn rc.minimum(), nil\n}\n\nfunc (rc *runContainer16) maximum() uint16 {\n\treturn rc.iv[len(rc.iv)-1].last() // assume not empty\n}\n\nfunc (rc *runContainer16) safeMaximum() (uint16, error) {\n\tif len(rc.iv) == 0 {\n\t\treturn 0, errors.New(\"Empty runs\")\n\t}\n\treturn rc.maximum(), nil // assume not empty\n}\n\nfunc (rc *runContainer16) isFull() bool {\n\treturn (len(rc.iv) == 1) && ((rc.iv[0].start == 0) && (rc.iv[0].last() == MaxUint16))\n}\n\nfunc (rc *runContainer16) and(a container) container {\n\tif rc.isFull() {\n\t\treturn a.clone()\n\t}\n\tswitch c := a.(type) {\n\tcase *runContainer16:\n\t\treturn rc.intersect(c)\n\tcase *arrayContainer:\n\t\treturn rc.andArray(c)\n\tcase *bitmapContainer:\n\t\treturn rc.andBitmapContainer(c)\n\t}\n\tpanic(\"unsupported container type\")\n}\n\nfunc (rc *runContainer16) andCardinality(a container) int {\n\tswitch c := a.(type) {\n\tcase *runContainer16:\n\t\treturn int(rc.intersectCardinality(c))\n\tcase *arrayContainer:\n\t\treturn rc.andArrayCardinality(c)\n\tcase *bitmapContainer:\n\t\treturn rc.andBitmapContainerCardinality(c)\n\t}\n\tpanic(\"unsupported container type\")\n}\n\n// andBitmapContainer finds the intersection of rc and b.\nfunc (rc *runContainer16) andBitmapContainer(bc *bitmapContainer) container {\n\tbc2 := newBitmapContainerFromRun(rc)\n\treturn bc2.andBitmap(bc)\n}\n\nfunc (rc *runContainer16) andArrayCardinality(ac *arrayContainer) int {\n\tpos := 0\n\tanswer := 0\n\tmaxpos := ac.getCardinality()\n\tif maxpos == 0 {\n\t\treturn 0 // won't happen in actual code\n\t}\n\tv := ac.content[pos]\nmainloop:\n\tfor _, p := range rc.iv {\n\t\tfor v < p.start {\n\t\t\tpos++\n\t\t\tif pos == maxpos {\n\t\t\t\tbreak mainloop\n\t\t\t}\n\t\t\tv = ac.content[pos]\n\t\t}\n\t\tfor v <= p.last() {\n\t\t\tanswer++\n\t\t\tpos++\n\t\t\tif pos == maxpos {\n\t\t\t\tbreak mainloop\n\t\t\t}\n\t\t\tv = ac.content[pos]\n\t\t}\n\t}\n\treturn answer\n}\n\nfunc (rc *runContainer16) iand(a container) container {\n\tif rc.isFull() {\n\t\treturn a.clone()\n\t}\n\tswitch c := a.(type) {\n\tcase *runContainer16:\n\t\treturn rc.inplaceIntersect(c)\n\tcase *arrayContainer:\n\t\treturn rc.andArray(c)\n\tcase *bitmapContainer:\n\t\treturn rc.iandBitmapContainer(c)\n\t}\n\tpanic(\"unsupported container type\")\n}\n\nfunc (rc *runContainer16) inplaceIntersect(rc2 *runContainer16) container {\n\tsect := rc.intersect(rc2)\n\t*rc = *sect\n\treturn rc\n}\n\nfunc (rc *runContainer16) iandBitmapContainer(bc *bitmapContainer) container {\n\tisect := rc.andBitmapContainer(bc)\n\t*rc = *newRunContainer16FromContainer(isect)\n\treturn rc\n}\n\nfunc (rc *runContainer16) andArray(ac *arrayContainer) container {\n\tif len(rc.iv) == 0 {\n\t\treturn newArrayContainer()\n\t}\n\n\tacCardinality := ac.getCardinality()\n\tc := newArrayContainerCapacity(acCardinality)\n\n\tfor rlePos, arrayPos := 0, 0; arrayPos < acCardinality; {\n\t\tiv := rc.iv[rlePos]\n\t\tarrayVal := ac.content[arrayPos]\n\n\t\tfor iv.last() < arrayVal {\n\t\t\trlePos++\n\t\t\tif rlePos == len(rc.iv) {\n\t\t\t\treturn c\n\t\t\t}\n\t\t\tiv = rc.iv[rlePos]\n\t\t}\n\n\t\tif iv.start > arrayVal {\n\t\t\tarrayPos = advanceUntil(ac.content, arrayPos, len(ac.content), iv.start)\n\t\t} else {\n\t\t\tc.content = append(c.content, arrayVal)\n\t\t\tarrayPos++\n\t\t}\n\t}\n\treturn c\n}\n\nfunc (rc *runContainer16) andNot(a container) container {\n\tswitch c := a.(type) {\n\tcase *arrayContainer:\n\t\treturn rc.andNotArray(c)\n\tcase *bitmapContainer:\n\t\treturn rc.andNotBitmap(c)\n\tcase *runContainer16:\n\t\treturn rc.andNotRunContainer16(c)\n\t}\n\tpanic(\"unsupported container type\")\n}\n\nfunc (rc *runContainer16) fillLeastSignificant16bits(x []uint32, i int, mask uint32) int {\n\tk := i\n\tvar val int\n\tfor _, p := range rc.iv {\n\t\tn := p.runlen()\n\t\tfor j := int(0); j < n; j++ {\n\t\t\tval = int(p.start) + j\n\t\t\tx[k] = uint32(val) | mask\n\t\t\tk++\n\t\t}\n\t}\n\treturn k\n}\n\nfunc (rc *runContainer16) getShortIterator() shortPeekable {\n\treturn rc.newRunIterator16()\n}\n\nfunc (rc *runContainer16) getReverseIterator() shortIterable {\n\treturn rc.newRunReverseIterator16()\n}\n\nfunc (rc *runContainer16) getManyIterator() manyIterable {\n\treturn rc.newManyRunIterator16()\n}\n\n// add the values in the range [firstOfRange, endx). endx\n// is still abe to express 2^16 because it is an int not an uint16.\nfunc (rc *runContainer16) iaddRange(firstOfRange, endx int) container {\n\tif firstOfRange > endx {\n\t\tpanic(fmt.Sprintf(\"invalid %v = endx > firstOfRange\", endx))\n\t}\n\tif firstOfRange == endx {\n\t\treturn rc\n\t}\n\taddme := newRunContainer16TakeOwnership([]interval16{\n\t\t{\n\t\t\tstart:  uint16(firstOfRange),\n\t\t\tlength: uint16(endx - 1 - firstOfRange),\n\t\t},\n\t})\n\t*rc = *rc.union(addme)\n\treturn rc\n}\n\n// remove the values in the range [firstOfRange,endx)\nfunc (rc *runContainer16) iremoveRange(firstOfRange, endx int) container {\n\tif firstOfRange > endx {\n\t\tpanic(fmt.Sprintf(\"request to iremove empty set [%v, %v),\"+\n\t\t\t\" nothing to do.\", firstOfRange, endx))\n\t}\n\t// empty removal\n\tif firstOfRange == endx {\n\t\treturn rc\n\t}\n\tx := newInterval16Range(uint16(firstOfRange), uint16(endx-1))\n\trc.isubtract(x)\n\treturn rc\n}\n\n// not flip the values in the range [firstOfRange,endx)\nfunc (rc *runContainer16) not(firstOfRange, endx int) container {\n\tif firstOfRange > endx {\n\t\tpanic(fmt.Sprintf(\"invalid %v = endx > firstOfRange = %v\", endx, firstOfRange))\n\t}\n\n\treturn rc.Not(firstOfRange, endx)\n}\n\n// Not flips the values in the range [firstOfRange,endx).\n// This is not inplace. Only the returned value has the flipped bits.\n//\n// Currently implemented as (!A intersect B) union (A minus B),\n// where A is rc, and B is the supplied [firstOfRange, endx) interval.\n//\n// TODO(time optimization): convert this to a single pass\n// algorithm by copying AndNotRunContainer16() and modifying it.\n// Current routine is correct but\n// makes 2 more passes through the arrays than should be\n// strictly necessary. Measure both ways though--this may not matter.\nfunc (rc *runContainer16) Not(firstOfRange, endx int) *runContainer16 {\n\tif firstOfRange > endx {\n\t\tpanic(fmt.Sprintf(\"invalid %v = endx > firstOfRange == %v\", endx, firstOfRange))\n\t}\n\n\tif firstOfRange >= endx {\n\t\treturn rc.Clone()\n\t}\n\n\ta := rc\n\t// algo:\n\t// (!A intersect B) union (A minus B)\n\n\tnota := a.invert()\n\n\tbs := []interval16{newInterval16Range(uint16(firstOfRange), uint16(endx-1))}\n\tb := newRunContainer16TakeOwnership(bs)\n\n\tnotAintersectB := nota.intersect(b)\n\n\taMinusB := a.AndNotRunContainer16(b)\n\n\trc2 := notAintersectB.union(aMinusB)\n\treturn rc2\n}\n\n// equals is now logical equals; it does not require the\n// same underlying container type.\nfunc (rc *runContainer16) equals(o container) bool {\n\tsrb, ok := o.(*runContainer16)\n\n\tif !ok {\n\t\t// maybe value instead of pointer\n\t\tval, valok := o.(*runContainer16)\n\t\tif valok {\n\t\t\tsrb = val\n\t\t\tok = true\n\t\t}\n\t}\n\tif ok {\n\t\t// Check if the containers are the same object.\n\t\tif rc == srb {\n\t\t\treturn true\n\t\t}\n\n\t\tif len(srb.iv) != len(rc.iv) {\n\t\t\treturn false\n\t\t}\n\n\t\tfor i, v := range rc.iv {\n\t\t\tif v != srb.iv[i] {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\t}\n\n\t// use generic comparison\n\tif o.getCardinality() != rc.getCardinality() {\n\t\treturn false\n\t}\n\trit := rc.getShortIterator()\n\tbit := o.getShortIterator()\n\n\t// k := 0\n\tfor rit.hasNext() {\n\t\tif bit.next() != rit.next() {\n\t\t\treturn false\n\t\t}\n\t\t// k++\n\t}\n\treturn true\n}\n\nfunc (rc *runContainer16) iaddReturnMinimized(x uint16) container {\n\trc.Add(x)\n\treturn rc\n}\n\nfunc (rc *runContainer16) iadd(x uint16) (wasNew bool) {\n\treturn rc.Add(x)\n}\n\nfunc (rc *runContainer16) iremoveReturnMinimized(x uint16) container {\n\trc.removeKey(x)\n\treturn rc\n}\n\nfunc (rc *runContainer16) iremove(x uint16) bool {\n\treturn rc.removeKey(x)\n}\n\nfunc (rc *runContainer16) or(a container) container {\n\tif rc.isFull() {\n\t\treturn rc.clone()\n\t}\n\tswitch c := a.(type) {\n\tcase *runContainer16:\n\t\treturn rc.union(c)\n\tcase *arrayContainer:\n\t\treturn rc.orArray(c)\n\tcase *bitmapContainer:\n\t\treturn rc.orBitmapContainer(c)\n\t}\n\tpanic(\"unsupported container type\")\n}\n\nfunc (rc *runContainer16) orCardinality(a container) int {\n\tswitch c := a.(type) {\n\tcase *runContainer16:\n\t\treturn int(rc.unionCardinality(c))\n\tcase *arrayContainer:\n\t\treturn rc.orArrayCardinality(c)\n\tcase *bitmapContainer:\n\t\treturn rc.orBitmapContainerCardinality(c)\n\t}\n\tpanic(\"unsupported container type\")\n}\n\n// orBitmapContainer finds the union of rc and bc.\nfunc (rc *runContainer16) orBitmapContainer(bc *bitmapContainer) container {\n\tbc2 := newBitmapContainerFromRun(rc)\n\treturn bc2.iorBitmap(bc)\n}\n\nfunc (rc *runContainer16) andBitmapContainerCardinality(bc *bitmapContainer) int {\n\tanswer := 0\n\tfor i := range rc.iv {\n\t\tanswer += bc.getCardinalityInRange(uint(rc.iv[i].start), uint(rc.iv[i].last())+1)\n\t}\n\t// bc.computeCardinality()\n\treturn answer\n}\n\nfunc (rc *runContainer16) orBitmapContainerCardinality(bc *bitmapContainer) int {\n\treturn rc.getCardinality() + bc.getCardinality() - rc.andBitmapContainerCardinality(bc)\n}\n\n// orArray finds the union of rc and ac.\nfunc (rc *runContainer16) orArray(ac *arrayContainer) container {\n\tif ac.isEmpty() {\n\t\treturn rc.clone()\n\t}\n\tif rc.isEmpty() {\n\t\treturn ac.clone()\n\t}\n\tintervals, cardMinusOne := runArrayUnionToRuns(rc, ac)\n\tresult := newRunContainer16TakeOwnership(intervals)\n\tif len(intervals) >= MaxNumIntervals && cardMinusOne >= arrayDefaultMaxSize {\n\t\treturn newBitmapContainerFromRun(result)\n\t}\n\tif len(intervals)*2 > 1+int(cardMinusOne) {\n\t\treturn result.toArrayContainer()\n\t}\n\treturn result\n}\n\n// orArray finds the union of rc and ac.\nfunc (rc *runContainer16) orArrayCardinality(ac *arrayContainer) int {\n\treturn ac.getCardinality() + rc.getCardinality() - rc.andArrayCardinality(ac)\n}\n\nfunc (rc *runContainer16) ior(a container) container {\n\tif rc.isFull() {\n\t\treturn rc\n\t}\n\tswitch c := a.(type) {\n\tcase *runContainer16:\n\t\treturn rc.inplaceUnion(c)\n\tcase *arrayContainer:\n\t\treturn rc.iorArray(c)\n\tcase *bitmapContainer:\n\t\treturn rc.iorBitmapContainer(c)\n\t}\n\tpanic(\"unsupported container type\")\n}\n\nfunc (rc *runContainer16) inplaceUnion(rc2 *runContainer16) container {\n\tfor _, p := range rc2.iv {\n\t\tlast := int(p.last())\n\t\tfor i := int(p.start); i <= last; i++ {\n\t\t\trc.Add(uint16(i))\n\t\t}\n\t}\n\treturn rc\n}\n\nfunc (rc *runContainer16) iorBitmapContainer(bc *bitmapContainer) container {\n\tit := bc.getShortIterator()\n\tfor it.hasNext() {\n\t\trc.Add(it.next())\n\t}\n\treturn rc\n}\n\nfunc (rc *runContainer16) iorArray(ac *arrayContainer) container {\n\tif rc.isEmpty() {\n\t\treturn ac.clone()\n\t}\n\tif ac.isEmpty() {\n\t\treturn rc\n\t}\n\tvar cardMinusOne uint16\n\t// TODO: perform the union algorithm in-place using rc.iv\n\t// this can be done with methods like the in-place array container union\n\t// but maybe lazily moving the remaining elements back.\n\trc.iv, cardMinusOne = runArrayUnionToRuns(rc, ac)\n\tif len(rc.iv) >= MaxNumIntervals && cardMinusOne >= arrayDefaultMaxSize {\n\t\treturn newBitmapContainerFromRun(rc)\n\t}\n\tif len(rc.iv)*2 > 1+int(cardMinusOne) {\n\t\treturn rc.toArrayContainer()\n\t}\n\treturn rc\n}\n\nfunc runArrayUnionToRuns(rc *runContainer16, ac *arrayContainer) ([]interval16, uint16) {\n\tpos1 := 0\n\tpos2 := 0\n\tlength1 := len(ac.content)\n\tlength2 := len(rc.iv)\n\ttarget := make([]interval16, 0, len(rc.iv))\n\t// have to find the first range\n\t// options are\n\t// 1. from array container\n\t// 2. from run container\n\tvar previousInterval interval16\n\tvar cardMinusOne uint16\n\tif ac.content[0] < rc.iv[0].start {\n\t\tpreviousInterval.start = ac.content[0]\n\t\tpreviousInterval.length = 0\n\t\tpos1++\n\t} else {\n\t\tpreviousInterval.start = rc.iv[0].start\n\t\tpreviousInterval.length = rc.iv[0].length\n\t\tpos2++\n\t}\n\n\tfor pos1 < length1 || pos2 < length2 {\n\t\tif pos1 < length1 {\n\t\t\ts1 := ac.content[pos1]\n\t\t\tif s1 <= previousInterval.start+previousInterval.length {\n\t\t\t\tpos1++\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif previousInterval.last() < MaxUint16 && previousInterval.last()+1 == s1 {\n\t\t\t\tpreviousInterval.length++\n\t\t\t\tpos1++\n\t\t\t\tcontinue\n\t\t\t}\n\t\t}\n\t\tif pos2 < length2 {\n\t\t\trange2 := rc.iv[pos2]\n\t\t\tif range2.start <= previousInterval.last() || range2.start > 0 && range2.start-1 == previousInterval.last() {\n\t\t\t\tpos2++\n\t\t\t\tif previousInterval.last() < range2.last() {\n\t\t\t\t\tpreviousInterval.length = range2.last() - previousInterval.start\n\t\t\t\t}\n\t\t\t\tcontinue\n\t\t\t}\n\t\t}\n\t\tcardMinusOne += previousInterval.length + 1\n\t\ttarget = append(target, previousInterval)\n\t\tif pos2 == length2 || pos1 < length1 && ac.content[pos1] < rc.iv[pos2].start {\n\t\t\tpreviousInterval.start = ac.content[pos1]\n\t\t\tpreviousInterval.length = 0\n\t\t\tpos1++\n\t\t} else {\n\t\t\tpreviousInterval = rc.iv[pos2]\n\t\t\tpos2++\n\t\t}\n\t}\n\tcardMinusOne += previousInterval.length\n\ttarget = append(target, previousInterval)\n\n\treturn target, cardMinusOne\n}\n\n// lazyIOR is described (not yet implemented) in\n// this nice note from @lemire on\n// https://github.com/RoaringBitmap/roaring/pull/70#issuecomment-263613737\n//\n// Description of lazyOR and lazyIOR from @lemire:\n//\n// Lazy functions are optional and can be simply\n// wrapper around non-lazy functions.\n//\n// The idea of \"laziness\" is as follows. It is\n// inspired by the concept of lazy evaluation\n// you might be familiar with (functional programming\n// and all that). So a roaring bitmap is\n// such that all its containers are, in some\n// sense, chosen to use as little memory as\n// possible. This is nice. Also, all bitsets\n// are \"cardinality aware\" so that you can do\n// fast rank/select queries, or query the\n// cardinality of the whole bitmap... very fast,\n// without latency.\n//\n// However, imagine that you are aggregating 100\n// bitmaps together. So you OR the first two, then OR\n// that with the third one and so forth. Clearly,\n// intermediate bitmaps don't need to be as\n// compressed as possible, right? They can be\n// in a \"dirty state\". You only need the end\n// result to be in a nice state... which you\n// can achieve by calling repairAfterLazy at the end.\n//\n// The Java/C code does something special for\n// the in-place lazy OR runs. The idea is that\n// instead of taking two run containers and\n// generating a new one, we actually try to\n// do the computation in-place through a\n// technique invented by @gssiyankai (pinging him!).\n// What you do is you check whether the host\n// run container has lots of extra capacity.\n// If it does, you move its data at the end of\n// the backing array, and then you write\n// the answer at the beginning. What this\n// trick does is minimize memory allocations.\nfunc (rc *runContainer16) lazyIOR(a container) container {\n\t// not lazy at the moment\n\treturn rc.ior(a)\n}\n\n// lazyOR is described above in lazyIOR.\nfunc (rc *runContainer16) lazyOR(a container) container {\n\t// not lazy at the moment\n\treturn rc.or(a)\n}\n\nfunc (rc *runContainer16) intersects(a container) bool {\n\t// TODO: optimize by doing inplace/less allocation\n\tisect := rc.and(a)\n\treturn !isect.isEmpty()\n}\n\nfunc (rc *runContainer16) xor(a container) container {\n\tswitch c := a.(type) {\n\tcase *arrayContainer:\n\t\treturn rc.xorArray(c)\n\tcase *bitmapContainer:\n\t\treturn rc.xorBitmap(c)\n\tcase *runContainer16:\n\t\treturn rc.xorRunContainer16(c)\n\t}\n\tpanic(\"unsupported container type\")\n}\n\nfunc (rc *runContainer16) iandNot(a container) container {\n\tswitch c := a.(type) {\n\tcase *arrayContainer:\n\t\treturn rc.iandNotArray(c)\n\tcase *bitmapContainer:\n\t\treturn rc.iandNotBitmap(c)\n\tcase *runContainer16:\n\t\treturn rc.iandNotRunContainer16(c)\n\t}\n\tpanic(\"unsupported container type\")\n}\n\n// flip the values in the range [firstOfRange,endx)\nfunc (rc *runContainer16) inot(firstOfRange, endx int) container {\n\tif firstOfRange > endx {\n\t\tpanic(fmt.Sprintf(\"invalid %v = endx > firstOfRange = %v\", endx, firstOfRange))\n\t}\n\tif firstOfRange > endx {\n\t\treturn rc\n\t}\n\t// TODO: minimize copies, do it all inplace; not() makes a copy.\n\trc = rc.Not(firstOfRange, endx)\n\treturn rc\n}\n\nfunc (rc *runContainer16) rank(x uint16) int {\n\tn := int(len(rc.iv))\n\txx := int(x)\n\tw, already, _ := rc.search(xx)\n\tif w < 0 {\n\t\treturn 0\n\t}\n\tif !already && w == n-1 {\n\t\treturn rc.getCardinality()\n\t}\n\tvar rnk int\n\tif !already {\n\t\tfor i := int(0); i <= w; i++ {\n\t\t\trnk += rc.iv[i].runlen()\n\t\t}\n\t\treturn int(rnk)\n\t}\n\tfor i := int(0); i < w; i++ {\n\t\trnk += rc.iv[i].runlen()\n\t}\n\trnk += int(x-rc.iv[w].start) + 1\n\treturn int(rnk)\n}\n\nfunc (rc *runContainer16) selectInt(x uint16) int {\n\tvar offset int\n\tfor k := range rc.iv {\n\t\tnextOffset := offset + rc.iv[k].runlen()\n\t\tif nextOffset > int(x) {\n\t\t\treturn int(int(rc.iv[k].start) + (int(x) - offset))\n\t\t}\n\t\toffset = nextOffset\n\t}\n\tpanic(\"cannot select x\")\n}\n\nfunc (rc *runContainer16) andNotRunContainer16(b *runContainer16) container {\n\treturn rc.AndNotRunContainer16(b)\n}\n\nfunc (rc *runContainer16) andNotArray(ac *arrayContainer) container {\n\trcb := rc.toBitmapContainer()\n\tacb := ac.toBitmapContainer()\n\treturn rcb.andNotBitmap(acb)\n}\n\nfunc (rc *runContainer16) andNotBitmap(bc *bitmapContainer) container {\n\trcb := rc.toBitmapContainer()\n\treturn rcb.andNotBitmap(bc)\n}\n\nfunc (rc *runContainer16) toBitmapContainer() *bitmapContainer {\n\tbc := newBitmapContainer()\n\tfor i := range rc.iv {\n\t\tbc.iaddRange(int(rc.iv[i].start), int(rc.iv[i].last())+1)\n\t}\n\tbc.computeCardinality()\n\treturn bc\n}\n\nfunc (rc *runContainer16) iandNotRunContainer16(x2 *runContainer16) container {\n\t// TODO: check size and optimize the return value\n\trc2 := rc.AndNotRunContainer16(x2)\n\t*rc = *rc2\n\treturn rc\n}\n\nfunc (rc *runContainer16) iandNotArray(ac *arrayContainer) container {\n\trcb := rc.toBitmapContainer()\n\tacb := ac.toBitmapContainer()\n\trcb.iandNotBitmapSurely(acb)\n\t// TODO: check size and optimize the return value\n\t// TODO: is inplace modification really required? If not, elide the copy.\n\trc2 := newRunContainer16FromBitmapContainer(rcb)\n\t*rc = *rc2\n\treturn rc\n}\n\nfunc (rc *runContainer16) iandNotBitmap(bc *bitmapContainer) container {\n\trcb := rc.toBitmapContainer()\n\trcb.iandNotBitmapSurely(bc)\n\t// TODO: check size and optimize the return value\n\t// TODO: is inplace modification really required? If not, elide the copy.\n\trc2 := newRunContainer16FromBitmapContainer(rcb)\n\t*rc = *rc2\n\treturn rc\n}\n\nfunc (rc *runContainer16) xorRunContainer16(x2 *runContainer16) container {\n\trcb := rc.toBitmapContainer()\n\tx2b := x2.toBitmapContainer()\n\treturn rcb.xorBitmap(x2b)\n}\n\nfunc (rc *runContainer16) xorArray(ac *arrayContainer) container {\n\trcb := rc.toBitmapContainer()\n\tacb := ac.toBitmapContainer()\n\treturn rcb.xorBitmap(acb)\n}\n\nfunc (rc *runContainer16) xorBitmap(bc *bitmapContainer) container {\n\trcb := rc.toBitmapContainer()\n\treturn rcb.xorBitmap(bc)\n}\n\n// convert to bitmap or array *if needed*\nfunc (rc *runContainer16) toEfficientContainer() container {\n\tsizeAsRunContainer := rc.getSizeInBytes()\n\tsizeAsBitmapContainer := bitmapContainerSizeInBytes()\n\tcard := rc.getCardinality()\n\tsizeAsArrayContainer := arrayContainerSizeInBytes(card)\n\tif sizeAsRunContainer < minOfInt(sizeAsBitmapContainer, sizeAsArrayContainer) {\n\t\treturn rc\n\t}\n\tif card <= arrayDefaultMaxSize {\n\t\treturn rc.toArrayContainer()\n\t}\n\tbc := newBitmapContainerFromRun(rc)\n\treturn bc\n}\n\nfunc (rc *runContainer16) toArrayContainer() *arrayContainer {\n\tac := newArrayContainer()\n\tfor i := range rc.iv {\n\t\tac.iaddRange(int(rc.iv[i].start), int(rc.iv[i].last())+1)\n\t}\n\treturn ac\n}\n\nfunc newRunContainer16FromContainer(c container) *runContainer16 {\n\tswitch x := c.(type) {\n\tcase *runContainer16:\n\t\treturn x.Clone()\n\tcase *arrayContainer:\n\t\treturn newRunContainer16FromArray(x)\n\tcase *bitmapContainer:\n\t\treturn newRunContainer16FromBitmapContainer(x)\n\t}\n\tpanic(\"unsupported container type\")\n}\n\n// And finds the intersection of rc and b.\nfunc (rc *runContainer16) And(b *Bitmap) *Bitmap {\n\tout := NewBitmap()\n\tfor _, p := range rc.iv {\n\t\tplast := p.last()\n\t\tfor i := p.start; i <= plast; i++ {\n\t\t\tif b.Contains(uint32(i)) {\n\t\t\t\tout.Add(uint32(i))\n\t\t\t}\n\t\t}\n\t}\n\treturn out\n}\n\n// Xor returns the exclusive-or of rc and b.\nfunc (rc *runContainer16) Xor(b *Bitmap) *Bitmap {\n\tout := b.Clone()\n\tfor _, p := range rc.iv {\n\t\tplast := p.last()\n\t\tfor v := p.start; v <= plast; v++ {\n\t\t\tw := uint32(v)\n\t\t\tif out.Contains(w) {\n\t\t\t\tout.RemoveRange(uint64(w), uint64(w+1))\n\t\t\t} else {\n\t\t\t\tout.Add(w)\n\t\t\t}\n\t\t}\n\t}\n\treturn out\n}\n\n// Or returns the union of rc and b.\nfunc (rc *runContainer16) Or(b *Bitmap) *Bitmap {\n\tout := b.Clone()\n\tfor _, p := range rc.iv {\n\t\tplast := p.last()\n\t\tfor v := p.start; v <= plast; v++ {\n\t\t\tout.Add(uint32(v))\n\t\t}\n\t}\n\treturn out\n}\n\n// serializedSizeInBytes returns the number of bytes of memory\n// required by this runContainer16. This is for the\n// Roaring format, as specified https://github.com/RoaringBitmap/RoaringFormatSpec/\nfunc (rc *runContainer16) serializedSizeInBytes() int {\n\t// number of runs in one uint16, then each run\n\t// needs two more uint16\n\treturn 2 + len(rc.iv)*4\n}\n\nfunc (rc *runContainer16) addOffset(x uint16) (container, container) {\n\tvar low, high *runContainer16\n\n\tif len(rc.iv) == 0 {\n\t\treturn nil, nil\n\t}\n\n\tfirst := uint32(rc.iv[0].start) + uint32(x)\n\tif highbits(first) == 0 {\n\t\t// Some elements will fall into low part, allocate a container.\n\t\t// Checking the first one is enough because they are ordered.\n\t\tlow = newRunContainer16()\n\t}\n\tlast := uint32(rc.iv[len(rc.iv)-1].start)\n\tlast += uint32(rc.iv[len(rc.iv)-1].length)\n\tlast += uint32(x)\n\tif highbits(last) > 0 {\n\t\t// Some elements will fall into high part, allocate a container.\n\t\t// Checking the last one is enough because they are ordered.\n\t\thigh = newRunContainer16()\n\t}\n\n\tfor _, iv := range rc.iv {\n\t\tval := int(iv.start) + int(x)\n\t\tfinalVal := int(val) + int(iv.length)\n\t\tif val <= 0xffff {\n\t\t\tif finalVal <= 0xffff {\n\t\t\t\tlow.iv = append(low.iv, interval16{uint16(val), iv.length})\n\t\t\t} else {\n\t\t\t\tlow.iv = append(low.iv, interval16{uint16(val), uint16(0xffff - val)})\n\t\t\t\thigh.iv = append(high.iv, interval16{uint16(0), uint16(finalVal & 0xffff)})\n\t\t\t}\n\t\t} else {\n\t\t\thigh.iv = append(high.iv, interval16{uint16(val & 0xffff), iv.length})\n\t\t}\n\t}\n\n\t// Ensure proper nil interface.\n\tif low == nil {\n\t\treturn nil, high\n\t}\n\tif high == nil {\n\t\treturn low, nil\n\t}\n\n\treturn low, high\n}\n\n// nextValue returns either the `target` if found or the next larger value.\n// If the target is in the interior or a run then `target` will be returned\n// Ex: If our run structure resmembles [[a,c], [d,f]] with a <= target <= c then `target` will be returned.\n// Ex: If c < target < d then d is returned.\n// Ex: If target < a then a is returned\n// if the target > max, this is out of bounds and -1 is returned\nfunc (rc *runContainer16) nextValue(target uint16) int {\n\tif len(rc.iv) == 0 {\n\t\treturn -1\n\t}\n\n\twhichIndex, alreadyPresent, _ := rc.search(int(target))\n\n\tif alreadyPresent {\n\t\treturn int(target)\n\t}\n\n\tif whichIndex == -1 {\n\t\treturn int(rc.iv[0].start)\n\t}\n\n\tif whichIndex == len(rc.iv)-1 {\n\t\treturn -1\n\t}\n\n\t// The if relies on the non-contiguous nature of runs.\n\t// If we have two runs [a,b] and another run [c,d]\n\t// We can rely on the invariant that b+1 < c\n\t// We will return c\n\tpossibleNext := whichIndex + 1\n\tif possibleNext < len(rc.iv) {\n\t\treturn int(rc.iv[possibleNext].start)\n\t}\n\n\treturn -1\n}\n\n// nextAbsentValue returns the next absent value.\n// By construction the next absent value will be located between gaps in runs\n//\n// Ex: if our runs resemble [[a,b],[c,d]] and a <= target <= b  then b+1 will not be equal to c, b+1 will be returned\n// Ex: if target < a then target is returned\n// Ex: if target > d then target is returned\nfunc (rc *runContainer16) nextAbsentValue(target uint16) int {\n\twhichIndex, alreadyPresent, _ := rc.search(int(target))\n\n\tif !alreadyPresent {\n\t\treturn int(target)\n\t}\n\n\treturn int(rc.iv[whichIndex].last()) + 1\n}\n\n// previousValue will return the previous present value\n// If the target is in the interior of a run  then `target` will be returned\n//\n// Example:\n// If our run structure resmembles [[a,c], [d,f]] with a <= target  <= c then target will be returned.\n// If c < target < d then c is returned.\n// if target > f then f is returned\n// if the target is less than a, this is out of bounds and -1 is returned\nfunc (rc *runContainer16) previousValue(target uint16) int {\n\twhichIndex, alreadyPresent, _ := rc.search(int(target))\n\n\tif len(rc.iv) == 0 {\n\t\treturn int(target)\n\t}\n\n\tif alreadyPresent {\n\t\treturn int(target)\n\t}\n\tif whichIndex == -1 {\n\t\treturn -1\n\t}\n\n\treturn int(rc.iv[whichIndex].last())\n}\n\n// previousAbsentValue will return the previous absent value\n// If the target is in the interior of a run then then the start of the range minus 1 will be returned\n//\n// Example:\n// If our run structure resmembles [[x,z], [a,c], [d,f]] with a <= target  <= c then a-1 will be returned.\n// if the target < x then target is returned\n// if target > f then target is returned\nfunc (rc *runContainer16) previousAbsentValue(target uint16) int {\n\twhichIndex, alreadyPresent, _ := rc.search(int(target))\n\n\tif !alreadyPresent {\n\t\treturn int(target)\n\t}\n\n\treturn int(rc.iv[whichIndex].start) - 1\n}\n\n// isNonContiguousDisjoint returns an error if the intervals overlap e.g have non-empty intersection\nfunc isNonContiguousDisjoint(outer interval16, inner interval16) error {\n\tif !outer.isNonContiguousDisjoint(inner) {\n\t\treturn ErrRunIntervalOverlap\n\t}\n\n\treturn nil\n}\n\n// validate checks the run container referential integrity\n// Ensures runs are not degenerate, non-contiguous and non-overlapping\nfunc (rc *runContainer16) validate() error {\n\tif rc.getCardinality() == 0 {\n\t\treturn ErrRunIntervalsEmpty\n\t}\n\n\tintervalsSum := 0\n\tfor outeridx := range rc.iv {\n\n\t\tif rc.iv[outeridx].length == 0 {\n\t\t\treturn ErrRunIntervalLength\n\t\t}\n\n\t\touterInterval := rc.iv[outeridx]\n\n\t\tintervalsSum += outerInterval.runlen()\n\t\tfor inneridx := outeridx + 1; inneridx < len(rc.iv); inneridx++ {\n\n\t\t\tinnerInterval := rc.iv[inneridx]\n\n\t\t\tif outerInterval.equal(innerInterval) {\n\t\t\t\treturn ErrRunIntervalEqual\n\t\t\t}\n\n\t\t\t// only check the start of runs\n\t\t\t// if the run length overlap the next check will catch that.\n\t\t\tif outerInterval.start >= innerInterval.start {\n\t\t\t\treturn ErrRunNonSorted\n\t\t\t}\n\n\t\t\terr := isNonContiguousDisjoint(outerInterval, innerInterval)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\n\t}\n\t/*\n\t\t\tif number of distinct values in the container >= 2048 then\n\t\t    check that the number of runs is no more than 2047\n\t\t    (otherwise you could use a bitset container)\n\t\t\telse\n\t\t    check that the number of runs < (number of distinct values) / 2\n\t\t    (otherwise you could use an array container)\n\t*/\n\tif MaxIntervalsSum <= intervalsSum {\n\t\tif !(len(rc.iv) < MaxNumIntervals) {\n\t\t\treturn ErrRunIntervalSize\n\t\t}\n\t} else {\n\t\tif !(len(rc.iv) < (intervalsSum / 2)) {\n\t\t\treturn ErrRunIntervalSize\n\t\t}\n\t}\n\n\treturn nil\n}\n"
        },
        {
          "name": "runcontainer_test.go",
          "type": "blob",
          "size": 71.271484375,
          "content": "package roaring\n\nimport (\n\t\"fmt\"\n\t\"math/rand\"\n\t\"sort\"\n\t\"strings\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\n// trial is used in the randomized testing of runContainers\ntype trial struct {\n\tn           int\n\tpercentFill float64\n\tntrial      int\n\n\t// only in the union test\n\t// only subtract test\n\tpercentDelete float64\n\n\t// only in 067 randomized operations\n\t// we do this + 1 passes\n\tnumRandomOpsPass int\n\n\t// allow sampling range control\n\t// only recent tests respect this.\n\tsrang *interval16\n}\n\n// canMerge, and mergeInterval16s should do what they say\nfunc TestRleInterval16s(t *testing.T) {\n\ta := newInterval16Range(0, 9)\n\tb := newInterval16Range(0, 1)\n\treport := sliceToString16([]interval16{a, b})\n\t_ = report\n\tc := newInterval16Range(2, 4)\n\td := newInterval16Range(2, 5)\n\te := newInterval16Range(0, 4)\n\tf := newInterval16Range(9, 9)\n\tg := newInterval16Range(8, 9)\n\th := newInterval16Range(5, 6)\n\ti := newInterval16Range(6, 6)\n\n\taIb, empty := intersectInterval16s(a, b)\n\tassert.False(t, empty)\n\tassert.EqualValues(t, b, aIb)\n\n\tassert.True(t, canMerge16(b, c))\n\tassert.True(t, canMerge16(c, b))\n\tassert.True(t, canMerge16(a, h))\n\n\tassert.True(t, canMerge16(d, e))\n\tassert.True(t, canMerge16(f, g))\n\tassert.True(t, canMerge16(c, h))\n\n\tassert.False(t, canMerge16(b, h))\n\tassert.False(t, canMerge16(h, b))\n\tassert.False(t, canMerge16(c, i))\n\n\tassert.EqualValues(t, e, mergeInterval16s(b, c))\n\tassert.EqualValues(t, e, mergeInterval16s(c, b))\n\n\tassert.EqualValues(t, h, mergeInterval16s(h, i))\n\tassert.EqualValues(t, h, mergeInterval16s(i, h))\n\n\t////// start\n\tassert.EqualValues(t, newInterval16Range(0, 1), mergeInterval16s(newInterval16Range(0, 0), newInterval16Range(1, 1)))\n\tassert.EqualValues(t, newInterval16Range(0, 1), mergeInterval16s(newInterval16Range(1, 1), newInterval16Range(0, 0)))\n\tassert.EqualValues(t, newInterval16Range(0, 5), mergeInterval16s(newInterval16Range(0, 4), newInterval16Range(3, 5)))\n\tassert.EqualValues(t, newInterval16Range(0, 4), mergeInterval16s(newInterval16Range(0, 4), newInterval16Range(3, 4)))\n\n\tassert.EqualValues(t, newInterval16Range(0, 8), mergeInterval16s(newInterval16Range(1, 7), newInterval16Range(0, 8)))\n\tassert.EqualValues(t, newInterval16Range(0, 8), mergeInterval16s(newInterval16Range(1, 7), newInterval16Range(0, 8)))\n\n\tassert.Panics(t, func() { _ = mergeInterval16s(newInterval16Range(0, 0), newInterval16Range(2, 3)) })\n}\n\nfunc TestRunOffset(t *testing.T) {\n\tv := newRunContainer16TakeOwnership([]interval16{newInterval16Range(34, 39)})\n\tofftest := uint16(65500)\n\tl, h := v.addOffset(offtest)\n\n\texpected := []int{65534, 65535, 65536, 65537, 65538, 65539}\n\twout := make([]int, len(expected))\n\n\tvar w0card, w1card int\n\n\tif l != nil {\n\t\tw0card = l.getCardinality()\n\n\t\tfor i := 0; i < w0card; i++ {\n\t\t\twout[i] = l.selectInt(uint16(i))\n\t\t}\n\t}\n\n\tif h != nil {\n\t\tw1card = h.getCardinality()\n\n\t\tfor i := 0; i < w1card; i++ {\n\t\t\twout[i+w0card] = h.selectInt(uint16(i)) + 65536\n\t\t}\n\t}\n\n\tassert.Equal(t, v.getCardinality(), w0card+w1card)\n\tfor i, x := range wout {\n\t\tassert.Equal(t, expected[i], x)\n\t}\n}\n\nfunc TestRunArrayUnionToRuns(t *testing.T) {\n\tarrayArg := newArrayContainerRange(0, 10)\n\trunArg := newRunContainer16Range(11, 65535)\n\tintervals, cardMinusOne := runArrayUnionToRuns(runArg, arrayArg)\n\tassert.Equal(t, uint16(65535), cardMinusOne)\n\tassert.Equal(t, []interval16{{start: 0, length: 65535}}, intervals)\n}\n\nfunc TestRleRunIterator16(t *testing.T) {\n\tt.Run(\"RunIterator16 unit tests for next, hasNext, and peekNext should pass\", func(t *testing.T) {\n\t\t{\n\t\t\trc := newRunContainer16()\n\t\t\tmsg := rc.String()\n\t\t\t_ = msg\n\n\t\t\tassert.EqualValues(t, 0, rc.getCardinality())\n\n\t\t\tit := rc.newRunIterator16()\n\n\t\t\tassert.False(t, it.hasNext())\n\t\t\tassert.Panics(t, func() { it.peekNext() })\n\t\t\tassert.Panics(t, func() { it.next() })\n\t\t}\n\t\t{\n\t\t\trc := newRunContainer16TakeOwnership([]interval16{newInterval16Range(4, 4)})\n\t\t\tassert.EqualValues(t, 1, rc.getCardinality())\n\n\t\t\tit := rc.newRunIterator16()\n\n\t\t\tassert.True(t, it.hasNext())\n\t\t\tassert.EqualValues(t, uint16(4), it.peekNext())\n\t\t\tassert.EqualValues(t, uint16(4), it.next())\n\t\t}\n\t\t{\n\t\t\trc := newRunContainer16CopyIv([]interval16{newInterval16Range(4, 9)})\n\t\t\tassert.EqualValues(t, 6, rc.getCardinality())\n\n\t\t\tit := rc.newRunIterator16()\n\t\t\tassert.True(t, it.hasNext())\n\n\t\t\tfor i := 4; i < 10; i++ {\n\t\t\t\tassert.Equal(t, uint16(i), it.next())\n\t\t\t}\n\n\t\t\tassert.False(t, it.hasNext())\n\t\t}\n\n\t\t{\n\t\t\t// basic nextMany test\n\t\t\trc := newRunContainer16CopyIv([]interval16{newInterval16Range(4, 9)})\n\t\t\tassert.EqualValues(t, 6, rc.getCardinality())\n\n\t\t\tit := rc.newManyRunIterator16()\n\t\t\tbuf := make([]uint32, 10)\n\t\t\tn := it.nextMany(0, buf)\n\n\t\t\tassert.Equal(t, 6, n)\n\n\t\t\texpected := []uint32{4, 5, 6, 7, 8, 9, 0, 0, 0, 0}\n\t\t\tfor i, e := range expected {\n\t\t\t\tassert.Equal(t, e, buf[i])\n\t\t\t}\n\t\t}\n\n\t\t{\n\t\t\t// nextMany with len(buf) == 0\n\t\t\trc := newRunContainer16CopyIv([]interval16{newInterval16Range(4, 9)})\n\t\t\tassert.EqualValues(t, 6, rc.getCardinality())\n\n\t\t\tit := rc.newManyRunIterator16()\n\t\t\tvar buf []uint32\n\t\t\tn := it.nextMany(0, buf)\n\n\t\t\tassert.Equal(t, 0, n)\n\t\t}\n\n\t\t{\n\t\t\t// basic nextMany test across ranges\n\t\t\trc := newRunContainer16CopyIv([]interval16{\n\t\t\t\tnewInterval16Range(4, 7),\n\t\t\t\tnewInterval16Range(11, 13),\n\t\t\t\tnewInterval16Range(18, 21),\n\t\t\t})\n\n\t\t\tassert.EqualValues(t, 11, rc.getCardinality())\n\n\t\t\tit := rc.newManyRunIterator16()\n\t\t\tbuf := make([]uint32, 15)\n\t\t\tn := it.nextMany(0, buf)\n\n\t\t\tassert.Equal(t, 11, n)\n\n\t\t\texpected := []uint32{4, 5, 6, 7, 11, 12, 13, 18, 19, 20, 21, 0, 0, 0, 0}\n\t\t\tfor i, e := range expected {\n\t\t\t\tassert.Equal(t, e, buf[i])\n\t\t\t}\n\t\t}\n\t\t{\n\t\t\t// basic nextMany test across ranges with different buffer sizes\n\t\t\trc := newRunContainer16CopyIv([]interval16{\n\t\t\t\tnewInterval16Range(4, 7),\n\t\t\t\tnewInterval16Range(11, 13),\n\t\t\t\tnewInterval16Range(18, 21),\n\t\t\t})\n\t\t\texpectedCard := 11\n\t\t\texpectedVals := []uint32{4, 5, 6, 7, 11, 12, 13, 18, 19, 20, 21}\n\t\t\ths := uint32(1 << 16)\n\n\t\t\tassert.EqualValues(t, expectedCard, rc.getCardinality())\n\n\t\t\tfor bufSize := 2; bufSize < 15; bufSize++ {\n\t\t\t\tbuf := make([]uint32, bufSize)\n\t\t\t\tseen := 0\n\t\t\t\tit := rc.newManyRunIterator16()\n\t\t\t\tfor n := it.nextMany(hs, buf); n != 0; n = it.nextMany(hs, buf) {\n\t\t\t\t\t// catch runaway iteration\n\t\t\t\t\tassert.LessOrEqual(t, seen+n, expectedCard)\n\n\t\t\t\t\tfor i, e := range expectedVals[seen : seen+n] {\n\t\t\t\t\t\tassert.Equal(t, e+hs, buf[i])\n\t\t\t\t\t}\n\t\t\t\t\tseen += n\n\t\t\t\t\t// if we have more values to return then we shouldn't leave empty slots in the buffer\n\t\t\t\t\tif seen < expectedCard {\n\t\t\t\t\t\tassert.Equal(t, bufSize, n)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tassert.Equal(t, expectedCard, seen)\n\t\t\t}\n\t\t}\n\n\t\t{\n\t\t\t// basic nextMany interaction with hasNext\n\t\t\trc := newRunContainer16CopyIv([]interval16{newInterval16Range(4, 4)})\n\t\t\tassert.EqualValues(t, 1, rc.getCardinality())\n\n\t\t\tit := rc.newManyRunIterator16()\n\t\t\tassert.True(t, it.hasNext())\n\n\t\t\tbuf := make([]uint32, 4)\n\t\t\tn := it.nextMany(0, buf)\n\n\t\t\tassert.Equal(t, 1, n)\n\n\t\t\texpected := []uint32{4, 0, 0, 0}\n\n\t\t\tfor i, e := range expected {\n\t\t\t\tassert.Equal(t, e, buf[i])\n\t\t\t}\n\n\t\t\tassert.False(t, it.hasNext())\n\n\t\t\tbuf = make([]uint32, 4)\n\t\t\tn = it.nextMany(0, buf)\n\n\t\t\tassert.Equal(t, 0, n)\n\n\t\t\texpected = []uint32{0, 0, 0, 0}\n\t\t\tfor i, e := range expected {\n\t\t\t\tassert.Equal(t, e, buf[i])\n\t\t\t}\n\t\t}\n\t\t{\n\t\t\trc := newRunContainer16TakeOwnership([]interval16{\n\t\t\t\tnewInterval16Range(0, 0),\n\t\t\t\tnewInterval16Range(2, 2),\n\t\t\t\tnewInterval16Range(4, 4),\n\t\t\t})\n\t\t\trc1 := newRunContainer16TakeOwnership([]interval16{\n\t\t\t\tnewInterval16Range(6, 7),\n\t\t\t\tnewInterval16Range(10, 11),\n\t\t\t\tnewInterval16Range(MaxUint16, MaxUint16),\n\t\t\t})\n\n\t\t\trc = rc.union(rc1)\n\n\t\t\tassert.EqualValues(t, 8, rc.getCardinality())\n\n\t\t\tit := rc.newRunIterator16()\n\n\t\t\tassert.EqualValues(t, 0, it.next())\n\t\t\tassert.EqualValues(t, 2, it.next())\n\t\t\tassert.EqualValues(t, 4, it.next())\n\t\t\tassert.EqualValues(t, 6, it.next())\n\t\t\tassert.EqualValues(t, 7, it.next())\n\t\t\tassert.EqualValues(t, 10, it.next())\n\t\t\tassert.EqualValues(t, 11, it.next())\n\t\t\tassert.EqualValues(t, MaxUint16, it.next())\n\t\t\tassert.False(t, it.hasNext())\n\n\t\t\tnewInterval16Range(0, MaxUint16)\n\t\t\trc2 := newRunContainer16TakeOwnership([]interval16{newInterval16Range(0, MaxUint16)})\n\n\t\t\trc2 = rc2.union(rc)\n\t\t\tassert.Equal(t, 1, rc2.numIntervals())\n\t\t}\n\t})\n}\n\nfunc TestRleRunReverseIterator16(t *testing.T) {\n\tt.Run(\"RunReverseIterator16 unit tests for next, hasNext, and peekNext should pass\", func(t *testing.T) {\n\t\t{\n\t\t\trc := newRunContainer16()\n\t\t\tit := rc.newRunReverseIterator16()\n\t\t\tassert.False(t, it.hasNext())\n\t\t\tassert.Panics(t, func() { it.next() })\n\t\t}\n\t\t{\n\t\t\trc := newRunContainer16TakeOwnership([]interval16{newInterval16Range(0, 0)})\n\t\t\tit := rc.newRunReverseIterator16()\n\t\t\tassert.True(t, it.hasNext())\n\t\t\tassert.EqualValues(t, uint16(0), it.next())\n\t\t\tassert.Panics(t, func() { it.next() })\n\t\t\tassert.False(t, it.hasNext())\n\t\t\tassert.Panics(t, func() { it.next() })\n\t\t}\n\t\t{\n\t\t\trc := newRunContainer16TakeOwnership([]interval16{newInterval16Range(4, 4)})\n\t\t\tit := rc.newRunReverseIterator16()\n\t\t\tassert.True(t, it.hasNext())\n\t\t\tassert.EqualValues(t, uint16(4), it.next())\n\t\t\tassert.False(t, it.hasNext())\n\t\t}\n\t\t{\n\t\t\trc := newRunContainer16TakeOwnership([]interval16{newInterval16Range(MaxUint16, MaxUint16)})\n\t\t\tit := rc.newRunReverseIterator16()\n\t\t\tassert.True(t, it.hasNext())\n\t\t\tassert.EqualValues(t, uint16(MaxUint16), it.next())\n\t\t\tassert.False(t, it.hasNext())\n\t\t}\n\t\t{\n\t\t\trc := newRunContainer16TakeOwnership([]interval16{newInterval16Range(4, 9)})\n\t\t\tit := rc.newRunReverseIterator16()\n\t\t\tassert.True(t, it.hasNext())\n\t\t\tfor i := 9; i >= 4; i-- {\n\t\t\t\tassert.Equal(t, uint16(i), it.next())\n\t\t\t\tif i > 4 {\n\t\t\t\t\tassert.True(t, it.hasNext())\n\t\t\t\t} else if i == 4 {\n\t\t\t\t\tassert.False(t, it.hasNext())\n\t\t\t\t}\n\t\t\t}\n\t\t\tassert.False(t, it.hasNext())\n\t\t\tassert.Panics(t, func() { it.next() })\n\t\t}\n\t\t{\n\t\t\trc := newRunContainer16TakeOwnership([]interval16{\n\t\t\t\tnewInterval16Range(0, 0),\n\t\t\t\tnewInterval16Range(2, 2),\n\t\t\t\tnewInterval16Range(4, 4),\n\t\t\t\tnewInterval16Range(6, 7),\n\t\t\t\tnewInterval16Range(10, 12),\n\t\t\t\tnewInterval16Range(MaxUint16, MaxUint16),\n\t\t\t})\n\n\t\t\tit := rc.newRunReverseIterator16()\n\t\t\tassert.Equal(t, uint16(MaxUint16), it.next())\n\t\t\tassert.Equal(t, uint16(12), it.next())\n\t\t\tassert.Equal(t, uint16(11), it.next())\n\t\t\tassert.Equal(t, uint16(10), it.next())\n\t\t\tassert.Equal(t, uint16(7), it.next())\n\t\t\tassert.Equal(t, uint16(6), it.next())\n\t\t\tassert.Equal(t, uint16(4), it.next())\n\t\t\tassert.Equal(t, uint16(2), it.next())\n\t\t\tassert.Equal(t, uint16(0), it.next())\n\t\t\tassert.Equal(t, false, it.hasNext())\n\t\t\tassert.Panics(t, func() { it.next() })\n\t\t}\n\t})\n}\n\nfunc TestRleIntersection16(t *testing.T) {\n\tt.Run(\"RunContainer16.intersect of two RunContainer16(s) should return their intersection\", func(t *testing.T) {\n\t\t{\n\t\t\tvals := []uint16{0, 2, 4, 6, 8, 10, 12, 14, 16, 18, MaxUint16 - 3, MaxUint16 - 1}\n\n\t\t\ta := newRunContainer16FromVals(true, vals[:5]...)\n\t\t\tb := newRunContainer16FromVals(true, vals[2:]...)\n\n\t\t\tassert.True(t, haveOverlap16(newInterval16Range(0, 2), newInterval16Range(2, 2)))\n\t\t\tassert.False(t, haveOverlap16(newInterval16Range(0, 2), newInterval16Range(3, 3)))\n\n\t\t\tisect := a.intersect(b)\n\n\t\t\tassert.EqualValues(t, 3, isect.getCardinality())\n\t\t\tassert.True(t, isect.contains(4))\n\t\t\tassert.True(t, isect.contains(6))\n\t\t\tassert.True(t, isect.contains(8))\n\n\t\t\tnewInterval16Range(0, MaxUint16)\n\t\t\td := newRunContainer16TakeOwnership([]interval16{newInterval16Range(0, MaxUint16)})\n\t\t\tisect = isect.intersect(d)\n\n\t\t\tassert.EqualValues(t, 3, isect.getCardinality())\n\t\t\tassert.True(t, isect.contains(4))\n\t\t\tassert.True(t, isect.contains(6))\n\t\t\tassert.True(t, isect.contains(8))\n\n\t\t\te := newRunContainer16TakeOwnership(\n\t\t\t\t[]interval16{\n\t\t\t\t\tnewInterval16Range(2, 4),\n\t\t\t\t\tnewInterval16Range(8, 9),\n\t\t\t\t\tnewInterval16Range(14, 16),\n\t\t\t\t\tnewInterval16Range(20, 22),\n\t\t\t\t},\n\t\t\t)\n\t\t\tf := newRunContainer16TakeOwnership(\n\t\t\t\t[]interval16{\n\t\t\t\t\tnewInterval16Range(3, 18),\n\t\t\t\t\tnewInterval16Range(22, 23),\n\t\t\t\t},\n\t\t\t)\n\n\t\t\t{\n\t\t\t\tisect = e.intersect(f)\n\n\t\t\t\tassert.EqualValues(t, 8, isect.getCardinality())\n\t\t\t\tassert.True(t, isect.contains(3))\n\t\t\t\tassert.True(t, isect.contains(4))\n\t\t\t\tassert.True(t, isect.contains(8))\n\t\t\t\tassert.True(t, isect.contains(9))\n\t\t\t\tassert.True(t, isect.contains(14))\n\t\t\t\tassert.True(t, isect.contains(15))\n\t\t\t\tassert.True(t, isect.contains(16))\n\t\t\t\tassert.True(t, isect.contains(22))\n\t\t\t}\n\n\t\t\t{\n\t\t\t\t// check for symmetry\n\t\t\t\tisect = f.intersect(e)\n\n\t\t\t\tassert.EqualValues(t, 8, isect.getCardinality())\n\t\t\t\tassert.True(t, isect.contains(3))\n\t\t\t\tassert.True(t, isect.contains(4))\n\t\t\t\tassert.True(t, isect.contains(8))\n\t\t\t\tassert.True(t, isect.contains(9))\n\t\t\t\tassert.True(t, isect.contains(14))\n\t\t\t\tassert.True(t, isect.contains(15))\n\t\t\t\tassert.True(t, isect.contains(16))\n\t\t\t\tassert.True(t, isect.contains(22))\n\t\t\t}\n\t\t}\n\t})\n}\n\nfunc TestRleRandomIntersection16(t *testing.T) {\n\tt.Run(\"RunContainer.intersect of two RunContainers should return their intersection, and this should hold over randomized container content when compared to intersection done with hash maps\", func(t *testing.T) {\n\t\tseed := int64(42)\n\t\trand.Seed(seed)\n\n\t\ttrials := []trial{\n\t\t\t{n: 100, percentFill: .80, ntrial: 10},\n\t\t\t{n: 1000, percentFill: .20, ntrial: 20},\n\t\t\t{n: 10000, percentFill: .01, ntrial: 10},\n\t\t\t{n: 1000, percentFill: .99, ntrial: 10},\n\t\t}\n\n\t\ttester := func(tr trial) {\n\t\t\tfor j := 0; j < tr.ntrial; j++ {\n\t\t\t\tma := make(map[int]bool)\n\t\t\t\tmb := make(map[int]bool)\n\n\t\t\t\tn := tr.n\n\t\t\t\ta := []uint16{}\n\t\t\t\tb := []uint16{}\n\n\t\t\t\tvar first, second int\n\n\t\t\t\tdraw := int(float64(n) * tr.percentFill)\n\t\t\t\tfor i := 0; i < draw; i++ {\n\t\t\t\t\tr0 := rand.Intn(n)\n\t\t\t\t\ta = append(a, uint16(r0))\n\t\t\t\t\tma[r0] = true\n\t\t\t\t\tif i == 0 {\n\t\t\t\t\t\tfirst = r0\n\t\t\t\t\t\tsecond = r0 + 1\n\t\t\t\t\t\ta = append(a, uint16(second))\n\t\t\t\t\t\tma[second] = true\n\t\t\t\t\t}\n\n\t\t\t\t\tr1 := rand.Intn(n)\n\t\t\t\t\tb = append(b, uint16(r1))\n\t\t\t\t\tmb[r1] = true\n\t\t\t\t}\n\n\t\t\t\t// print a; very likely it has dups\n\t\t\t\tsort.Sort(uint16Slice(a))\n\t\t\t\tstringA := \"\"\n\t\t\t\tfor i := range a {\n\t\t\t\t\tstringA += fmt.Sprintf(\"%v, \", a[i])\n\t\t\t\t}\n\n\t\t\t\t// hash version of intersect:\n\t\t\t\thashi := make(map[int]bool)\n\t\t\t\tfor k := range ma {\n\t\t\t\t\tif mb[k] {\n\t\t\t\t\t\thashi[k] = true\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// RunContainer's Intersect\n\t\t\t\tbrle := newRunContainer16FromVals(false, b...)\n\n\t\t\t\t// arle := newRunContainer16FromVals(false, a...)\n\t\t\t\t// instead of the above line, create from array\n\t\t\t\t// get better test coverage:\n\t\t\t\tarr := newArrayContainerRange(int(first), int(second))\n\t\t\t\tarle := newRunContainer16FromArray(arr)\n\t\t\t\tarle.set(false, a...)\n\n\t\t\t\tisect := arle.intersect(brle)\n\n\t\t\t\t// showHash(\"hashi\", hashi)\n\n\t\t\t\tfor k := range hashi {\n\t\t\t\t\tassert.True(t, isect.contains(uint16(k)))\n\t\t\t\t}\n\n\t\t\t\tassert.EqualValues(t, len(hashi), isect.getCardinality())\n\t\t\t}\n\t\t}\n\n\t\tfor i := range trials {\n\t\t\ttester(trials[i])\n\t\t}\n\t})\n}\n\nfunc TestRleRandomUnion16(t *testing.T) {\n\tt.Run(\"RunContainer.union of two RunContainers should return their union, and this should hold over randomized container content when compared to union done with hash maps\", func(t *testing.T) {\n\t\tseed := int64(42)\n\t\trand.Seed(seed)\n\n\t\ttrials := []trial{\n\t\t\t{n: 100, percentFill: .80, ntrial: 10},\n\t\t\t{n: 1000, percentFill: .20, ntrial: 20},\n\t\t\t{n: 10000, percentFill: .01, ntrial: 10},\n\t\t\t{n: 1000, percentFill: .99, ntrial: 10, percentDelete: .04},\n\t\t}\n\n\t\ttester := func(tr trial) {\n\t\t\tfor j := 0; j < tr.ntrial; j++ {\n\t\t\t\tma := make(map[int]bool)\n\t\t\t\tmb := make(map[int]bool)\n\n\t\t\t\tn := tr.n\n\t\t\t\ta := []uint16{}\n\t\t\t\tb := []uint16{}\n\n\t\t\t\tdraw := int(float64(n) * tr.percentFill)\n\t\t\t\tnumDel := int(float64(n) * tr.percentDelete)\n\t\t\t\tfor i := 0; i < draw; i++ {\n\t\t\t\t\tr0 := rand.Intn(n)\n\t\t\t\t\ta = append(a, uint16(r0))\n\t\t\t\t\tma[r0] = true\n\n\t\t\t\t\tr1 := rand.Intn(n)\n\t\t\t\t\tb = append(b, uint16(r1))\n\t\t\t\t\tmb[r1] = true\n\t\t\t\t}\n\n\t\t\t\t// hash version of union:\n\t\t\t\thashu := make(map[int]bool)\n\t\t\t\tfor k := range ma {\n\t\t\t\t\thashu[k] = true\n\t\t\t\t}\n\t\t\t\tfor k := range mb {\n\t\t\t\t\thashu[k] = true\n\t\t\t\t}\n\n\t\t\t\t// showHash(\"hashu\", hashu)\n\n\t\t\t\t// RunContainer's Union\n\t\t\t\tarle := newRunContainer16()\n\t\t\t\tfor i := range a {\n\t\t\t\t\tarle.Add(a[i])\n\t\t\t\t}\n\t\t\t\tbrle := newRunContainer16()\n\t\t\t\tbrle.set(false, b...)\n\n\t\t\t\tunion := arle.union(brle)\n\t\t\t\tun := union.AsSlice()\n\t\t\t\tsort.Sort(uint16Slice(un))\n\n\t\t\t\tfor kk, v := range un {\n\t\t\t\t\t_ = kk\n\t\t\t\t\tassert.True(t, hashu[int(v)])\n\t\t\t\t}\n\n\t\t\t\tfor k := range hashu {\n\t\t\t\t\tassert.True(t, union.contains(uint16(k)))\n\t\t\t\t}\n\n\t\t\t\tassert.EqualValues(t, len(hashu), union.getCardinality())\n\n\t\t\t\t// do the deletes, exercising the remove functionality\n\t\t\t\tfor i := 0; i < numDel; i++ {\n\t\t\t\t\tr1 := rand.Intn(len(a))\n\t\t\t\t\tgoner := a[r1]\n\t\t\t\t\tunion.removeKey(goner)\n\t\t\t\t\tdelete(hashu, int(goner))\n\t\t\t\t}\n\n\t\t\t\t// verify the same as in the hashu\n\t\t\t\tassert.EqualValues(t, len(hashu), union.getCardinality())\n\n\t\t\t\tfor k := range hashu {\n\t\t\t\t\tassert.True(t, union.contains(uint16(k)))\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor i := range trials {\n\t\t\ttester(trials[i])\n\t\t}\n\t})\n}\n\nfunc TestRleAndOrXor16(t *testing.T) {\n\tt.Run(\"RunContainer And, Or, Xor tests\", func(t *testing.T) {\n\t\t{\n\t\t\trc := newRunContainer16TakeOwnership([]interval16{\n\t\t\t\tnewInterval16Range(0, 0),\n\t\t\t\tnewInterval16Range(2, 2),\n\t\t\t\tnewInterval16Range(4, 4),\n\t\t\t})\n\t\t\tb0 := NewBitmap()\n\t\t\tb0.Add(2)\n\t\t\tb0.Add(6)\n\t\t\tb0.Add(8)\n\n\t\t\tand := rc.And(b0)\n\t\t\tor := rc.Or(b0)\n\t\t\txor := rc.Xor(b0)\n\n\t\t\tassert.EqualValues(t, 1, and.GetCardinality())\n\t\t\tassert.EqualValues(t, 5, or.GetCardinality())\n\t\t\tassert.EqualValues(t, 4, xor.GetCardinality())\n\n\t\t\t// test creating size 0 and 1 from array\n\t\t\tarr := newArrayContainerCapacity(0)\n\t\t\tempty := newRunContainer16FromArray(arr)\n\t\t\tonceler := newArrayContainerCapacity(1)\n\t\t\tonceler.content = append(onceler.content, uint16(0))\n\t\t\toneZero := newRunContainer16FromArray(onceler)\n\n\t\t\tassert.EqualValues(t, 0, empty.getCardinality())\n\t\t\tassert.EqualValues(t, 1, oneZero.getCardinality())\n\t\t\tassert.EqualValues(t, 0, empty.And(b0).GetCardinality())\n\t\t\tassert.EqualValues(t, 3, empty.Or(b0).GetCardinality())\n\n\t\t\t// exercise newRunContainer16FromVals() with 0 and 1 inputs.\n\t\t\tempty2 := newRunContainer16FromVals(false, []uint16{}...)\n\t\t\tassert.EqualValues(t, 0, empty2.getCardinality())\n\n\t\t\tone2 := newRunContainer16FromVals(false, []uint16{1}...)\n\t\t\tassert.EqualValues(t, 1, one2.getCardinality())\n\t\t}\n\t})\n}\n\nfunc TestRlePanics16(t *testing.T) {\n\tt.Run(\"Some RunContainer calls/methods should panic if misused\", func(t *testing.T) {\n\t\t// newRunContainer16FromVals\n\t\tassert.Panics(t, func() { newRunContainer16FromVals(true, 1, 0) })\n\n\t\tarr := newArrayContainerRange(1, 3)\n\t\tarr.content = []uint16{2, 3, 3, 2, 1}\n\t\tassert.Panics(t, func() { newRunContainer16FromArray(arr) })\n\t})\n}\n\nfunc TestRleCoverageOddsAndEnds16(t *testing.T) {\n\tt.Run(\"Some RunContainer code paths that don't otherwise get coverage -- these should be tested to increase percentage of code coverage in testing\", func(t *testing.T) {\n\t\trc := &runContainer16{}\n\t\tassert.Equal(t, \"runContainer16{}\", rc.String())\n\n\t\trc.iv = make([]interval16, 1)\n\t\trc.iv[0] = newInterval16Range(3, 4)\n\n\t\tassert.Equal(t, \"runContainer16{0:[3, 4], }\", rc.String())\n\n\t\ta := newInterval16Range(5, 9)\n\t\tb := newInterval16Range(0, 1)\n\t\tc := newInterval16Range(1, 2)\n\n\t\t// intersectInterval16s(a, b interval16)\n\t\tisect, isEmpty := intersectInterval16s(a, b)\n\t\tassert.True(t, isEmpty)\n\n\t\t// [0,0] can't be trusted: assert.Equal(t, 0, isect.runlen())\n\t\tisect, isEmpty = intersectInterval16s(b, c)\n\n\t\tassert.False(t, isEmpty)\n\t\tassert.EqualValues(t, 1, isect.runlen())\n\n\t\t// runContainer16.union\n\t\t{\n\t\t\tra := newRunContainer16FromVals(false, 4, 5)\n\t\t\trb := newRunContainer16FromVals(false, 4, 6, 8, 9, 10)\n\t\t\tra.union(rb)\n\n\t\t\tassert.EqualValues(t, 2, rb.indexOfIntervalAtOrAfter(4, 2))\n\t\t\tassert.EqualValues(t, 2, rb.indexOfIntervalAtOrAfter(3, 2))\n\t\t}\n\n\t\t// runContainer.intersect\n\t\t{\n\t\t\tra := newRunContainer16()\n\t\t\trb := newRunContainer16()\n\n\t\t\tassert.EqualValues(t, 0, ra.intersect(rb).getCardinality())\n\t\t}\n\t\t{\n\t\t\tra := newRunContainer16FromVals(false, 1)\n\t\t\trb := newRunContainer16FromVals(false, 4)\n\n\t\t\tassert.EqualValues(t, 0, ra.intersect(rb).getCardinality())\n\t\t}\n\n\t\t// runContainer.Add\n\t\t{\n\t\t\tra := newRunContainer16FromVals(false, 1)\n\t\t\trb := newRunContainer16FromVals(false, 4)\n\n\t\t\tassert.EqualValues(t, 1, ra.getCardinality())\n\t\t\tassert.EqualValues(t, 1, rb.getCardinality())\n\n\t\t\tra.Add(5)\n\n\t\t\tassert.EqualValues(t, 2, ra.getCardinality())\n\n\t\t\t// newRunIterator16()\n\t\t\tempty := newRunContainer16()\n\t\t\tit := empty.newRunIterator16()\n\n\t\t\tassert.Panics(t, func() { it.next() })\n\n\t\t\tit2 := ra.newRunIterator16()\n\t\t\tit2.curIndex = len(it2.rc.iv)\n\n\t\t\tassert.Panics(t, func() { it2.next() })\n\n\t\t\t// runIterator16.peekNext()\n\t\t\temptyIt := empty.newRunIterator16()\n\n\t\t\tassert.Panics(t, func() { emptyIt.peekNext() })\n\n\t\t\t// newRunContainer16FromArray\n\t\t\tarr := newArrayContainerRange(1, 6)\n\t\t\tarr.content = []uint16{5, 5, 5, 6, 9}\n\t\t\trc3 := newRunContainer16FromArray(arr)\n\n\t\t\tassert.EqualValues(t, 3, rc3.getCardinality())\n\n\t\t\t// runContainer16SerializedSizeInBytes\n\t\t\t// runContainer16.SerializedSizeInBytes\n\t\t\t_ = runContainer16SerializedSizeInBytes(3)\n\t\t\t_ = rc3.serializedSizeInBytes()\n\n\t\t\t// findNextIntervalThatIntersectsStartingFrom\n\t\t\tidx, _ := rc3.findNextIntervalThatIntersectsStartingFrom(0, 100)\n\n\t\t\tassert.EqualValues(t, 1, idx)\n\n\t\t\t// deleteAt / remove\n\t\t\trc3.Add(10)\n\t\t\trc3.removeKey(10)\n\t\t\trc3.removeKey(9)\n\n\t\t\tassert.EqualValues(t, 2, rc3.getCardinality())\n\n\t\t\trc3.Add(9)\n\t\t\trc3.Add(10)\n\t\t\trc3.Add(12)\n\n\t\t\tassert.EqualValues(t, 5, rc3.getCardinality())\n\n\t\t\tit3 := rc3.newRunIterator16()\n\t\t\tit3.next()\n\t\t\tit3.next()\n\t\t\tit3.next()\n\t\t\tit3.next()\n\n\t\t\tassert.EqualValues(t, 12, it3.peekNext())\n\t\t\tassert.EqualValues(t, 12, it3.next())\n\t\t}\n\n\t\t// runContainer16.equals\n\t\t{\n\t\t\trc16 := newRunContainer16()\n\t\t\tassert.True(t, rc16.equals16(rc16))\n\t\t\trc16b := newRunContainer16()\n\n\t\t\tassert.True(t, rc16.equals16(rc16b))\n\n\t\t\trc16.Add(1)\n\t\t\trc16b.Add(2)\n\n\t\t\tassert.False(t, rc16.equals16(rc16b))\n\t\t}\n\t})\n}\n\nfunc TestRleStoringMax16(t *testing.T) {\n\tt.Run(\"Storing the MaxUint16 should be possible, because it may be necessary to do so--users will assume that any valid uint16 should be storable. In particular the smaller 16-bit version will definitely expect full access to all bits.\", func(t *testing.T) {\n\t\trc := newRunContainer16()\n\t\trc.Add(MaxUint16)\n\n\t\tassert.True(t, rc.contains(MaxUint16))\n\t\tassert.EqualValues(t, 1, rc.getCardinality())\n\n\t\trc.removeKey(MaxUint16)\n\n\t\tassert.False(t, rc.contains(MaxUint16))\n\t\tassert.EqualValues(t, 0, rc.getCardinality())\n\n\t\trc.set(false, MaxUint16-1, MaxUint16)\n\n\t\tassert.EqualValues(t, 2, rc.getCardinality())\n\t\tassert.True(t, rc.contains(MaxUint16-1))\n\t\tassert.True(t, rc.contains(MaxUint16))\n\n\t\trc.removeKey(MaxUint16 - 1)\n\n\t\tassert.EqualValues(t, 1, rc.getCardinality())\n\n\t\trc.removeKey(MaxUint16)\n\n\t\tassert.EqualValues(t, 0, rc.getCardinality())\n\n\t\trc.set(false, MaxUint16-2, MaxUint16-1, MaxUint16)\n\n\t\tassert.EqualValues(t, 3, rc.getCardinality())\n\t\tassert.EqualValues(t, 1, rc.numIntervals())\n\n\t\trc.removeKey(MaxUint16 - 1)\n\n\t\tassert.EqualValues(t, 2, rc.numIntervals())\n\t\tassert.EqualValues(t, 2, rc.getCardinality())\n\t})\n}\n\n// go test -bench BenchmarkFromBitmap -run -\nfunc BenchmarkFromBitmap16(b *testing.B) {\n\tb.StopTimer()\n\tseed := int64(42)\n\trand.Seed(seed)\n\n\ttr := trial{n: 10000, percentFill: .95, ntrial: 1, numRandomOpsPass: 100}\n\t_, _, bc := getRandomSameThreeContainers(tr)\n\n\tb.StartTimer()\n\n\tfor j := 0; j < b.N; j++ {\n\t\tnewRunContainer16FromBitmapContainer(bc)\n\t}\n}\n\nfunc TestRle16RandomIntersectAgainstOtherContainers010(t *testing.T) {\n\tt.Run(\"runContainer16 `and` operation against other container types should correctly do the intersection\", func(t *testing.T) {\n\t\tseed := int64(42)\n\t\trand.Seed(seed)\n\n\t\ttrials := []trial{\n\t\t\t{n: 100, percentFill: .95, ntrial: 1},\n\t\t}\n\n\t\ttester := func(tr trial) {\n\t\t\tfor j := 0; j < tr.ntrial; j++ {\n\t\t\t\tma := make(map[int]bool)\n\t\t\t\tmb := make(map[int]bool)\n\n\t\t\t\tn := tr.n\n\t\t\t\ta := []uint16{}\n\t\t\t\tb := []uint16{}\n\n\t\t\t\tdraw := int(float64(n) * tr.percentFill)\n\t\t\t\tfor i := 0; i < draw; i++ {\n\t\t\t\t\tr0 := rand.Intn(n)\n\t\t\t\t\ta = append(a, uint16(r0))\n\t\t\t\t\tma[r0] = true\n\n\t\t\t\t\tr1 := rand.Intn(n)\n\t\t\t\t\tb = append(b, uint16(r1))\n\t\t\t\t\tmb[r1] = true\n\t\t\t\t}\n\n\t\t\t\t// showArray16(a, \"a\")\n\t\t\t\t// showArray16(b, \"b\")\n\n\t\t\t\t// hash version of intersect:\n\t\t\t\thashi := make(map[int]bool)\n\t\t\t\tfor k := range ma {\n\t\t\t\t\tif mb[k] {\n\t\t\t\t\t\thashi[k] = true\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// RunContainer's Intersect\n\t\t\t\trc := newRunContainer16FromVals(false, a...)\n\n\t\t\t\t// vs bitmapContainer\n\t\t\t\tbc := newBitmapContainer()\n\t\t\t\tfor _, bv := range b {\n\t\t\t\t\tbc.iadd(bv)\n\t\t\t\t}\n\n\t\t\t\t// vs arrayContainer\n\t\t\t\tac := newArrayContainer()\n\t\t\t\tfor _, bv := range b {\n\t\t\t\t\tac.iadd(bv)\n\t\t\t\t}\n\n\t\t\t\t// vs runContainer\n\t\t\t\trcb := newRunContainer16FromVals(false, b...)\n\n\t\t\t\trcVsBcIsect := rc.and(bc)\n\t\t\t\trcVsAcIsect := rc.and(ac)\n\t\t\t\trcVsRcbIsect := rc.and(rcb)\n\n\t\t\t\tfor k := range hashi {\n\t\t\t\t\tassert.True(t, rcVsBcIsect.contains(uint16(k)))\n\n\t\t\t\t\tassert.True(t, rcVsAcIsect.contains(uint16(k)))\n\n\t\t\t\t\tassert.True(t, rcVsRcbIsect.contains(uint16(k)))\n\t\t\t\t}\n\n\t\t\t\tassert.Equal(t, len(hashi), rcVsBcIsect.getCardinality())\n\t\t\t\tassert.Equal(t, len(hashi), rcVsAcIsect.getCardinality())\n\t\t\t\tassert.Equal(t, len(hashi), rcVsRcbIsect.getCardinality())\n\t\t\t}\n\t\t}\n\n\t\tfor i := range trials {\n\t\t\ttester(trials[i])\n\t\t}\n\t})\n}\n\nfunc TestRle16RandomUnionAgainstOtherContainers011(t *testing.T) {\n\tt.Run(\"runContainer16 `or` operation against other container types should correctly do the intersection\", func(t *testing.T) {\n\t\tseed := int64(42)\n\t\trand.Seed(seed)\n\n\t\ttrials := []trial{\n\t\t\t{n: 100, percentFill: .95, ntrial: 1},\n\t\t}\n\n\t\ttester := func(tr trial) {\n\t\t\tfor j := 0; j < tr.ntrial; j++ {\n\t\t\t\tma := make(map[int]bool)\n\t\t\t\tmb := make(map[int]bool)\n\n\t\t\t\tn := tr.n\n\t\t\t\ta := []uint16{}\n\t\t\t\tb := []uint16{}\n\n\t\t\t\tdraw := int(float64(n) * tr.percentFill)\n\t\t\t\tfor i := 0; i < draw; i++ {\n\t\t\t\t\tr0 := rand.Intn(n)\n\t\t\t\t\ta = append(a, uint16(r0))\n\t\t\t\t\tma[r0] = true\n\n\t\t\t\t\tr1 := rand.Intn(n)\n\t\t\t\t\tb = append(b, uint16(r1))\n\t\t\t\t\tmb[r1] = true\n\t\t\t\t}\n\n\t\t\t\t// showArray16(a, \"a\")\n\t\t\t\t// showArray16(b, \"b\")\n\n\t\t\t\t// hash version of union\n\t\t\t\thashi := make(map[int]bool)\n\t\t\t\tfor k := range ma {\n\t\t\t\t\thashi[k] = true\n\t\t\t\t}\n\t\t\t\tfor k := range mb {\n\t\t\t\t\thashi[k] = true\n\t\t\t\t}\n\n\t\t\t\t// RunContainer's 'or'\n\t\t\t\trc := newRunContainer16FromVals(false, a...)\n\n\t\t\t\t// vs bitmapContainer\n\t\t\t\tbc := newBitmapContainer()\n\t\t\t\tfor _, bv := range b {\n\t\t\t\t\tbc.iadd(bv)\n\t\t\t\t}\n\n\t\t\t\t// vs arrayContainer\n\t\t\t\tac := newArrayContainer()\n\t\t\t\tfor _, bv := range b {\n\t\t\t\t\tac.iadd(bv)\n\t\t\t\t}\n\n\t\t\t\t// vs runContainer\n\t\t\t\trcb := newRunContainer16FromVals(false, b...)\n\n\t\t\t\trcVsBcUnion := rc.or(bc)\n\t\t\t\trcVsAcUnion := rc.or(ac)\n\t\t\t\trcVsRcbUnion := rc.or(rcb)\n\n\t\t\t\tfor k := range hashi {\n\t\t\t\t\tassert.True(t, rcVsBcUnion.contains(uint16(k)))\n\t\t\t\t\tassert.True(t, rcVsAcUnion.contains(uint16(k)))\n\t\t\t\t\tassert.True(t, rcVsRcbUnion.contains(uint16(k)))\n\t\t\t\t}\n\t\t\t\tassert.Equal(t, len(hashi), rcVsBcUnion.getCardinality())\n\t\t\t\tassert.Equal(t, len(hashi), rcVsAcUnion.getCardinality())\n\t\t\t\tassert.Equal(t, len(hashi), rcVsRcbUnion.getCardinality())\n\t\t\t}\n\t\t}\n\n\t\tfor i := range trials {\n\t\t\ttester(trials[i])\n\t\t}\n\t})\n}\n\nfunc TestRle16RandomInplaceUnionAgainstOtherContainers012(t *testing.T) {\n\tt.Run(\"runContainer16 `ior` inplace union operation against other container types should correctly do the intersection\", func(t *testing.T) {\n\t\tseed := int64(42)\n\t\trand.Seed(seed)\n\n\t\ttrials := []trial{\n\t\t\t{n: 10, percentFill: .95, ntrial: 1},\n\t\t}\n\n\t\ttester := func(tr trial) {\n\t\t\tfor j := 0; j < tr.ntrial; j++ {\n\t\t\t\tma := make(map[int]bool)\n\t\t\t\tmb := make(map[int]bool)\n\n\t\t\t\tn := tr.n\n\t\t\t\ta := []uint16{}\n\t\t\t\tb := []uint16{}\n\n\t\t\t\tdraw := int(float64(n) * tr.percentFill)\n\t\t\t\tfor i := 0; i < draw; i++ {\n\t\t\t\t\tr0 := rand.Intn(n)\n\t\t\t\t\ta = append(a, uint16(r0))\n\t\t\t\t\tma[r0] = true\n\n\t\t\t\t\tr1 := rand.Intn(n)\n\t\t\t\t\tb = append(b, uint16(r1))\n\t\t\t\t\tmb[r1] = true\n\t\t\t\t}\n\n\t\t\t\t// showArray16(a, \"a\")\n\t\t\t\t// showArray16(b, \"b\")\n\n\t\t\t\t// hash version of union\n\t\t\t\thashi := make(map[int]bool)\n\t\t\t\tfor k := range ma {\n\t\t\t\t\thashi[k] = true\n\t\t\t\t}\n\t\t\t\tfor k := range mb {\n\t\t\t\t\thashi[k] = true\n\t\t\t\t}\n\n\t\t\t\t// RunContainer's 'or'\n\t\t\t\trc := newRunContainer16FromVals(false, a...)\n\t\t\t\trcVsBcUnion := rc.Clone()\n\t\t\t\trcVsAcUnion := rc.Clone()\n\t\t\t\trcVsRcbUnion := rc.Clone()\n\n\t\t\t\t// vs bitmapContainer\n\t\t\t\tbc := newBitmapContainer()\n\t\t\t\tfor _, bv := range b {\n\t\t\t\t\tbc.iadd(bv)\n\t\t\t\t}\n\n\t\t\t\t// vs arrayContainer\n\t\t\t\tac := newArrayContainer()\n\t\t\t\tfor _, bv := range b {\n\t\t\t\t\tac.iadd(bv)\n\t\t\t\t}\n\n\t\t\t\t// vs runContainer\n\t\t\t\trcb := newRunContainer16FromVals(false, b...)\n\n\t\t\t\trcVsBcUnion.ior(bc)\n\t\t\t\trcVsAcUnion.ior(ac)\n\t\t\t\trcVsRcbUnion.ior(rcb)\n\n\t\t\t\tfor k := range hashi {\n\t\t\t\t\tassert.True(t, rcVsBcUnion.contains(uint16(k)))\n\n\t\t\t\t\tassert.True(t, rcVsAcUnion.contains(uint16(k)))\n\n\t\t\t\t\tassert.True(t, rcVsRcbUnion.contains(uint16(k)))\n\t\t\t\t}\n\n\t\t\t\tassert.Equal(t, len(hashi), rcVsBcUnion.getCardinality())\n\t\t\t\tassert.Equal(t, len(hashi), rcVsAcUnion.getCardinality())\n\t\t\t\tassert.Equal(t, len(hashi), rcVsRcbUnion.getCardinality())\n\t\t\t}\n\t\t}\n\n\t\tfor i := range trials {\n\t\t\ttester(trials[i])\n\t\t}\n\t})\n}\n\nfunc TestRle16RandomInplaceIntersectAgainstOtherContainers014(t *testing.T) {\n\tt.Run(\"runContainer16 `iand` inplace-and operation against other container types should correctly do the intersection\", func(t *testing.T) {\n\t\tseed := int64(42)\n\t\trand.Seed(seed)\n\n\t\ttrials := []trial{\n\t\t\t{n: 100, percentFill: .95, ntrial: 1},\n\t\t}\n\n\t\ttester := func(tr trial) {\n\t\t\tfor j := 0; j < tr.ntrial; j++ {\n\t\t\t\tma := make(map[int]bool)\n\t\t\t\tmb := make(map[int]bool)\n\n\t\t\t\tn := tr.n\n\t\t\t\ta := []uint16{}\n\t\t\t\tb := []uint16{}\n\n\t\t\t\tdraw := int(float64(n) * tr.percentFill)\n\t\t\t\tfor i := 0; i < draw; i++ {\n\t\t\t\t\tr0 := rand.Intn(n)\n\t\t\t\t\ta = append(a, uint16(r0))\n\t\t\t\t\tma[r0] = true\n\n\t\t\t\t\tr1 := rand.Intn(n)\n\t\t\t\t\tb = append(b, uint16(r1))\n\t\t\t\t\tmb[r1] = true\n\t\t\t\t}\n\n\t\t\t\t// showArray16(a, \"a\")\n\t\t\t\t// showArray16(b, \"b\")\n\n\t\t\t\t// hash version of intersect:\n\t\t\t\thashi := make(map[int]bool)\n\t\t\t\tfor k := range ma {\n\t\t\t\t\tif mb[k] {\n\t\t\t\t\t\thashi[k] = true\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// RunContainer's Intersect\n\t\t\t\trc := newRunContainer16FromVals(false, a...)\n\n\t\t\t\t// vs bitmapContainer\n\t\t\t\tbc := newBitmapContainer()\n\t\t\t\tfor _, bv := range b {\n\t\t\t\t\tbc.iadd(bv)\n\t\t\t\t}\n\n\t\t\t\t// vs arrayContainer\n\t\t\t\tac := newArrayContainer()\n\t\t\t\tfor _, bv := range b {\n\t\t\t\t\tac.iadd(bv)\n\t\t\t\t}\n\n\t\t\t\t// vs runContainer\n\t\t\t\trcb := newRunContainer16FromVals(false, b...)\n\n\t\t\t\tvar rcVsBcIsect container = rc.Clone()\n\t\t\t\tvar rcVsAcIsect container = rc.Clone()\n\t\t\t\tvar rcVsRcbIsect container = rc.Clone()\n\n\t\t\t\trcVsBcIsect = rcVsBcIsect.iand(bc)\n\t\t\t\trcVsAcIsect = rcVsAcIsect.iand(ac)\n\t\t\t\trcVsRcbIsect = rcVsRcbIsect.iand(rcb)\n\n\t\t\t\tfor k := range hashi {\n\t\t\t\t\tassert.True(t, rcVsBcIsect.contains(uint16(k)))\n\n\t\t\t\t\tassert.True(t, rcVsAcIsect.contains(uint16(k)))\n\n\t\t\t\t\tassert.True(t, rcVsRcbIsect.contains(uint16(k)))\n\t\t\t\t}\n\n\t\t\t\tassert.Equal(t, len(hashi), rcVsBcIsect.getCardinality())\n\t\t\t\tassert.Equal(t, len(hashi), rcVsAcIsect.getCardinality())\n\t\t\t\tassert.Equal(t, len(hashi), rcVsRcbIsect.getCardinality())\n\t\t\t}\n\t\t}\n\n\t\tfor i := range trials {\n\t\t\ttester(trials[i])\n\t\t}\n\t})\n}\n\nfunc TestRle16RemoveApi015(t *testing.T) {\n\tt.Run(\"runContainer16 `remove` (a minus b) should work\", func(t *testing.T) {\n\t\tseed := int64(42)\n\t\trand.Seed(seed)\n\n\t\ttrials := []trial{\n\t\t\t{n: 100, percentFill: .95, ntrial: 1},\n\t\t}\n\n\t\ttester := func(tr trial) {\n\t\t\tfor j := 0; j < tr.ntrial; j++ {\n\t\t\t\tma := make(map[int]bool)\n\t\t\t\tmb := make(map[int]bool)\n\n\t\t\t\tn := tr.n\n\t\t\t\ta := []uint16{}\n\t\t\t\tb := []uint16{}\n\n\t\t\t\tdraw := int(float64(n) * tr.percentFill)\n\t\t\t\tfor i := 0; i < draw; i++ {\n\t\t\t\t\tr0 := rand.Intn(n)\n\t\t\t\t\ta = append(a, uint16(r0))\n\t\t\t\t\tma[r0] = true\n\n\t\t\t\t\tr1 := rand.Intn(n)\n\t\t\t\t\tb = append(b, uint16(r1))\n\t\t\t\t\tmb[r1] = true\n\t\t\t\t}\n\n\t\t\t\t// showArray16(a, \"a\")\n\t\t\t\t// showArray16(b, \"b\")\n\n\t\t\t\t// hash version of remove:\n\t\t\t\thashrm := make(map[int]bool)\n\t\t\t\tfor k := range ma {\n\t\t\t\t\thashrm[k] = true\n\t\t\t\t}\n\t\t\t\tfor k := range mb {\n\t\t\t\t\tdelete(hashrm, k)\n\t\t\t\t}\n\n\t\t\t\t// RunContainer's remove\n\t\t\t\trc := newRunContainer16FromVals(false, a...)\n\n\t\t\t\tfor k := range mb {\n\t\t\t\t\trc.iremove(uint16(k))\n\t\t\t\t}\n\n\t\t\t\tfor k := range hashrm {\n\t\t\t\t\tassert.True(t, rc.contains(uint16(k)))\n\t\t\t\t}\n\n\t\t\t\tassert.Equal(t, len(hashrm), rc.getCardinality())\n\t\t\t}\n\t\t}\n\n\t\tfor i := range trials {\n\t\t\ttester(trials[i])\n\t\t}\n\t})\n}\n\nfunc showArray16(a []uint16, name string) {\n\tsort.Sort(uint16Slice(a))\n\tstringA := \"\"\n\tfor i := range a {\n\t\tstringA += fmt.Sprintf(\"%v, \", a[i])\n\t}\n}\n\nfunc TestRle16RandomAndNot016(t *testing.T) {\n\tt.Run(\"runContainer16 `andNot` operation against other container types should correctly do the and-not operation\", func(t *testing.T) {\n\t\tseed := int64(42)\n\t\trand.Seed(seed)\n\n\t\ttrials := []trial{\n\t\t\t{n: 1000, percentFill: .95, ntrial: 2},\n\t\t}\n\n\t\ttester := func(tr trial) {\n\t\t\tfor j := 0; j < tr.ntrial; j++ {\n\t\t\t\tma := make(map[int]bool)\n\t\t\t\tmb := make(map[int]bool)\n\n\t\t\t\tn := tr.n\n\t\t\t\ta := []uint16{}\n\t\t\t\tb := []uint16{}\n\n\t\t\t\tdraw := int(float64(n) * tr.percentFill)\n\t\t\t\tfor i := 0; i < draw; i++ {\n\t\t\t\t\tr0 := rand.Intn(n)\n\t\t\t\t\ta = append(a, uint16(r0))\n\t\t\t\t\tma[r0] = true\n\n\t\t\t\t\tr1 := rand.Intn(n)\n\t\t\t\t\tb = append(b, uint16(r1))\n\t\t\t\t\tmb[r1] = true\n\t\t\t\t}\n\n\t\t\t\t// showArray16(a, \"a\")\n\t\t\t\t// showArray16(b, \"b\")\n\n\t\t\t\t// hash version of and-not\n\t\t\t\thashi := make(map[int]bool)\n\t\t\t\tfor k := range ma {\n\t\t\t\t\thashi[k] = true\n\t\t\t\t}\n\t\t\t\tfor k := range mb {\n\t\t\t\t\tdelete(hashi, k)\n\t\t\t\t}\n\n\t\t\t\t// RunContainer's and-not\n\t\t\t\trc := newRunContainer16FromVals(false, a...)\n\n\t\t\t\t// vs bitmapContainer\n\t\t\t\tbc := newBitmapContainer()\n\t\t\t\tfor _, bv := range b {\n\t\t\t\t\tbc.iadd(bv)\n\t\t\t\t}\n\n\t\t\t\t// vs arrayContainer\n\t\t\t\tac := newArrayContainer()\n\t\t\t\tfor _, bv := range b {\n\t\t\t\t\tac.iadd(bv)\n\t\t\t\t}\n\n\t\t\t\t// vs runContainer\n\t\t\t\trcb := newRunContainer16FromVals(false, b...)\n\n\t\t\t\trcVsBcAndnot := rc.andNot(bc)\n\t\t\t\trcVsAcAndnot := rc.andNot(ac)\n\t\t\t\trcVsRcbAndnot := rc.andNot(rcb)\n\n\t\t\t\tfor k := range hashi {\n\t\t\t\t\tassert.True(t, rcVsBcAndnot.contains(uint16(k)))\n\t\t\t\t\tassert.True(t, rcVsAcAndnot.contains(uint16(k)))\n\t\t\t\t\tassert.True(t, rcVsRcbAndnot.contains(uint16(k)))\n\t\t\t\t}\n\n\t\t\t\tassert.Equal(t, len(hashi), rcVsBcAndnot.getCardinality())\n\t\t\t\tassert.Equal(t, len(hashi), rcVsAcAndnot.getCardinality())\n\t\t\t\tassert.Equal(t, len(hashi), rcVsRcbAndnot.getCardinality())\n\t\t\t}\n\t\t}\n\n\t\tfor i := range trials {\n\t\t\ttester(trials[i])\n\t\t}\n\t})\n}\n\nfunc TestRle16RandomInplaceAndNot017(t *testing.T) {\n\tt.Run(\"runContainer16 `iandNot` operation against other container types should correctly do the inplace-and-not operation\", func(t *testing.T) {\n\t\tseed := int64(42)\n\t\trand.Seed(seed)\n\n\t\ttrials := []trial{\n\t\t\t{n: 1000, percentFill: .95, ntrial: 2},\n\t\t}\n\n\t\ttester := func(tr trial) {\n\t\t\tfor j := 0; j < tr.ntrial; j++ {\n\t\t\t\tma := make(map[int]bool)\n\t\t\t\tmb := make(map[int]bool)\n\n\t\t\t\tn := tr.n\n\t\t\t\ta := []uint16{}\n\t\t\t\tb := []uint16{}\n\n\t\t\t\tdraw := int(float64(n) * tr.percentFill)\n\t\t\t\tfor i := 0; i < draw; i++ {\n\t\t\t\t\tr0 := rand.Intn(n)\n\t\t\t\t\ta = append(a, uint16(r0))\n\t\t\t\t\tma[r0] = true\n\n\t\t\t\t\tr1 := rand.Intn(n)\n\t\t\t\t\tb = append(b, uint16(r1))\n\t\t\t\t\tmb[r1] = true\n\t\t\t\t}\n\n\t\t\t\t// showArray16(a, \"a\")\n\t\t\t\t// showArray16(b, \"b\")\n\n\t\t\t\t// hash version of and-not\n\t\t\t\thashi := make(map[int]bool)\n\t\t\t\tfor k := range ma {\n\t\t\t\t\thashi[k] = true\n\t\t\t\t}\n\t\t\t\tfor k := range mb {\n\t\t\t\t\tdelete(hashi, k)\n\t\t\t\t}\n\n\t\t\t\t// RunContainer's and-not\n\t\t\t\trc := newRunContainer16FromVals(false, a...)\n\n\t\t\t\t// vs bitmapContainer\n\t\t\t\tbc := newBitmapContainer()\n\t\t\t\tfor _, bv := range b {\n\t\t\t\t\tbc.iadd(bv)\n\t\t\t\t}\n\n\t\t\t\t// vs arrayContainer\n\t\t\t\tac := newArrayContainer()\n\t\t\t\tfor _, bv := range b {\n\t\t\t\t\tac.iadd(bv)\n\t\t\t\t}\n\n\t\t\t\t// vs runContainer\n\t\t\t\trcb := newRunContainer16FromVals(false, b...)\n\n\t\t\t\trcVsBcIandnot := rc.Clone()\n\t\t\t\trcVsAcIandnot := rc.Clone()\n\t\t\t\trcVsRcbIandnot := rc.Clone()\n\n\t\t\t\trcVsBcIandnot.iandNot(bc)\n\t\t\t\trcVsAcIandnot.iandNot(ac)\n\t\t\t\trcVsRcbIandnot.iandNot(rcb)\n\n\t\t\t\tfor k := range hashi {\n\t\t\t\t\tassert.True(t, rcVsBcIandnot.contains(uint16(k)))\n\t\t\t\t\tassert.True(t, rcVsAcIandnot.contains(uint16(k)))\n\t\t\t\t\tassert.True(t, rcVsRcbIandnot.contains(uint16(k)))\n\t\t\t\t}\n\t\t\t\tassert.Equal(t, len(hashi), rcVsBcIandnot.getCardinality())\n\t\t\t\tassert.Equal(t, len(hashi), rcVsAcIandnot.getCardinality())\n\t\t\t\tassert.Equal(t, len(hashi), rcVsRcbIandnot.getCardinality())\n\t\t\t}\n\t\t}\n\n\t\tfor i := range trials {\n\t\t\ttester(trials[i])\n\t\t}\n\t})\n}\n\nfunc TestRle16InversionOfIntervals018(t *testing.T) {\n\tt.Run(\"runContainer `invert` operation should do a NOT on the set of intervals, in-place\", func(t *testing.T) {\n\t\tseed := int64(42)\n\t\trand.Seed(seed)\n\n\t\ttrials := []trial{\n\t\t\t{n: 1000, percentFill: .90, ntrial: 1},\n\t\t}\n\n\t\ttester := func(tr trial) {\n\t\t\tfor j := 0; j < tr.ntrial; j++ {\n\t\t\t\tma := make(map[int]bool)\n\t\t\t\thashNotA := make(map[int]bool)\n\n\t\t\t\tn := tr.n\n\t\t\t\ta := []uint16{}\n\n\t\t\t\t// hashNotA will be NOT ma\n\t\t\t\t// for i := 0; i < n; i++ {\n\t\t\t\tfor i := 0; i < MaxUint16+1; i++ {\n\t\t\t\t\thashNotA[i] = true\n\t\t\t\t}\n\n\t\t\t\tdraw := int(float64(n) * tr.percentFill)\n\t\t\t\tfor i := 0; i < draw; i++ {\n\t\t\t\t\tr0 := rand.Intn(n)\n\t\t\t\t\ta = append(a, uint16(r0))\n\t\t\t\t\tma[r0] = true\n\t\t\t\t\tdelete(hashNotA, r0)\n\t\t\t\t}\n\n\t\t\t\t// RunContainer's invert\n\t\t\t\trc := newRunContainer16FromVals(false, a...)\n\n\t\t\t\tinv := rc.invert()\n\n\t\t\t\tassert.Equal(t, 1+MaxUint16-rc.getCardinality(), inv.getCardinality())\n\n\t\t\t\tfor k := 0; k < n; k++ {\n\t\t\t\t\tif hashNotA[k] {\n\t\t\t\t\t\tassert.True(t, inv.contains(uint16(k)))\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// skip for now, too big to do 2^16-1\n\t\t\t\tassert.Equal(t, len(hashNotA), inv.getCardinality())\n\t\t\t}\n\t\t}\n\n\t\tfor i := range trials {\n\t\t\ttester(trials[i])\n\t\t}\n\t})\n}\n\nfunc TestRle16SubtractionOfIntervals019(t *testing.T) {\n\tt.Run(\"runContainer `subtract` operation removes an interval in-place\", func(t *testing.T) {\n\t\t// basics\n\n\t\ti22 := newInterval16Range(2, 2)\n\t\tleft, _ := i22.subtractInterval(i22)\n\t\tassert.EqualValues(t, 0, len(left))\n\n\t\tv := newInterval16Range(1, 6)\n\t\tleft, _ = v.subtractInterval(newInterval16Range(3, 4))\n\n\t\tassert.EqualValues(t, 2, len(left))\n\t\tassert.EqualValues(t, 1, left[0].start)\n\t\tassert.EqualValues(t, 2, left[0].last())\n\t\tassert.EqualValues(t, 5, left[1].start)\n\t\tassert.EqualValues(t, 6, left[1].last())\n\n\t\tv = newInterval16Range(1, 6)\n\t\tleft, _ = v.subtractInterval(newInterval16Range(4, 10))\n\n\t\tassert.EqualValues(t, 1, len(left))\n\t\tassert.EqualValues(t, 1, left[0].start)\n\t\tassert.EqualValues(t, 3, left[0].last())\n\n\t\tv = newInterval16Range(5, 10)\n\t\tleft, _ = v.subtractInterval(newInterval16Range(0, 7))\n\n\t\tassert.EqualValues(t, 1, len(left))\n\t\tassert.EqualValues(t, 8, left[0].start)\n\t\tassert.EqualValues(t, 10, left[0].last())\n\n\t\tseed := int64(42)\n\t\trand.Seed(seed)\n\n\t\ttrials := []trial{\n\t\t\t{n: 1000, percentFill: .90, ntrial: 1},\n\t\t}\n\n\t\ttester := func(tr trial) {\n\t\t\tfor j := 0; j < tr.ntrial; j++ {\n\t\t\t\tma := make(map[int]bool)\n\t\t\t\tmb := make(map[int]bool)\n\n\t\t\t\tn := tr.n\n\t\t\t\ta := []uint16{}\n\t\t\t\tb := []uint16{}\n\n\t\t\t\t// hashAminusB will be  ma - mb\n\t\t\t\thashAminusB := make(map[int]bool)\n\n\t\t\t\tdraw := int(float64(n) * tr.percentFill)\n\t\t\t\tfor i := 0; i < draw; i++ {\n\t\t\t\t\tr0 := rand.Intn(n)\n\t\t\t\t\ta = append(a, uint16(r0))\n\t\t\t\t\tma[r0] = true\n\t\t\t\t\thashAminusB[r0] = true\n\n\t\t\t\t\tr1 := rand.Intn(n)\n\t\t\t\t\tb = append(b, uint16(r1))\n\t\t\t\t\tmb[r1] = true\n\t\t\t\t}\n\n\t\t\t\tfor k := range mb {\n\t\t\t\t\tdelete(hashAminusB, k)\n\t\t\t\t}\n\n\t\t\t\t// RunContainer's subtract A - B\n\t\t\t\trc := newRunContainer16FromVals(false, a...)\n\t\t\t\trcb := newRunContainer16FromVals(false, b...)\n\n\t\t\t\tabkup := rc.Clone()\n\n\t\t\t\tit := rcb.newRunIterator16()\n\t\t\t\tfor it.hasNext() {\n\t\t\t\t\tnx := it.next()\n\t\t\t\t\trc.isubtract(newInterval16Range(nx, nx))\n\t\t\t\t}\n\n\t\t\t\t// also check full interval subtraction\n\t\t\t\tfor _, p := range rcb.iv {\n\t\t\t\t\tabkup.isubtract(p)\n\t\t\t\t}\n\n\t\t\t\tfor k := range hashAminusB {\n\t\t\t\t\tassert.True(t, rc.contains(uint16(k)))\n\t\t\t\t\tassert.True(t, abkup.contains(uint16(k)))\n\t\t\t\t}\n\n\t\t\t\tassert.EqualValues(t, len(hashAminusB), rc.getCardinality())\n\t\t\t\tassert.EqualValues(t, len(hashAminusB), abkup.getCardinality())\n\t\t\t}\n\t\t}\n\n\t\tfor i := range trials {\n\t\t\ttester(trials[i])\n\t\t}\n\t})\n}\n\nfunc TestRle16Rank020(t *testing.T) {\n\tv := container(newRunContainer16())\n\tv = v.iaddReturnMinimized(10)\n\tv = v.iaddReturnMinimized(100)\n\tv = v.iaddReturnMinimized(1000)\n\tif v.getCardinality() != 3 {\n\t\tt.Errorf(\"Bogus cardinality.\")\n\t}\n\tfor i := 0; i <= arrayDefaultMaxSize; i++ {\n\t\tthisrank := v.rank(uint16(i))\n\t\tif i < 10 {\n\t\t\tif thisrank != 0 {\n\t\t\t\tt.Errorf(\"At %d should be zero but is %d \", i, thisrank)\n\t\t\t}\n\t\t} else if i < 100 {\n\t\t\tif thisrank != 1 {\n\t\t\t\tt.Errorf(\"At %d should be zero but is %d \", i, thisrank)\n\t\t\t}\n\t\t} else if i < 1000 {\n\t\t\tif thisrank != 2 {\n\t\t\t\tt.Errorf(\"At %d should be zero but is %d \", i, thisrank)\n\t\t\t}\n\t\t} else {\n\t\t\tif thisrank != 3 {\n\t\t\t\tt.Errorf(\"At %d should be zero but is %d \", i, thisrank)\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc TestRle16NotAlsoKnownAsFlipRange021(t *testing.T) {\n\tt.Run(\"runContainer `Not` operation should flip the bits of a range on the new returned container\", func(t *testing.T) {\n\t\tseed := int64(42)\n\t\trand.Seed(seed)\n\n\t\ttrials := []trial{\n\t\t\t{n: 100, percentFill: .8, ntrial: 2},\n\t\t}\n\n\t\ttester := func(tr trial) {\n\t\t\tfor j := 0; j < tr.ntrial; j++ {\n\n\t\t\t\t// what is the interval we are going to flip?\n\n\t\t\t\tma := make(map[int]bool)\n\t\t\t\tflipped := make(map[int]bool)\n\n\t\t\t\tn := tr.n\n\t\t\t\ta := []uint16{}\n\n\t\t\t\tdraw := int(float64(n) * tr.percentFill)\n\t\t\t\tfor i := 0; i < draw; i++ {\n\t\t\t\t\tr0 := rand.Intn(n)\n\t\t\t\t\ta = append(a, uint16(r0))\n\t\t\t\t\tma[r0] = true\n\t\t\t\t\tflipped[r0] = true\n\t\t\t\t}\n\n\t\t\t\t// pick an interval to flip\n\t\t\t\tbegin := rand.Intn(n)\n\t\t\t\tlast := rand.Intn(n)\n\t\t\t\tif last < begin {\n\t\t\t\t\tbegin, last = last, begin\n\t\t\t\t}\n\n\t\t\t\t// do the flip on the hash `flipped`\n\t\t\t\tfor i := begin; i <= last; i++ {\n\t\t\t\t\tif flipped[i] {\n\t\t\t\t\t\tdelete(flipped, i)\n\t\t\t\t\t} else {\n\t\t\t\t\t\tflipped[i] = true\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// RunContainer's Not\n\t\t\t\trc := newRunContainer16FromVals(false, a...)\n\t\t\t\tflp := rc.Not(begin, last+1)\n\n\t\t\t\tassert.EqualValues(t, len(flipped), flp.getCardinality())\n\n\t\t\t\tfor k := 0; k < n; k++ {\n\t\t\t\t\tif flipped[k] {\n\t\t\t\t\t\tassert.True(t, flp.contains(uint16(k)))\n\t\t\t\t\t} else {\n\t\t\t\t\t\tassert.False(t, flp.contains(uint16(k)))\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tassert.EqualValues(t, len(flipped), flp.getCardinality())\n\t\t\t}\n\t\t}\n\n\t\tfor i := range trials {\n\t\t\ttester(trials[i])\n\t\t}\n\t})\n}\n\nfunc TestRleEquals022(t *testing.T) {\n\tt.Run(\"runContainer `equals` should accurately compare contents against other container types\", func(t *testing.T) {\n\t\tseed := int64(42)\n\t\trand.Seed(seed)\n\n\t\ttrials := []trial{\n\t\t\t{n: 100, percentFill: .2, ntrial: 10},\n\t\t}\n\n\t\ttester := func(tr trial) {\n\t\t\tfor j := 0; j < tr.ntrial; j++ {\n\n\t\t\t\tma := make(map[int]bool)\n\n\t\t\t\tn := tr.n\n\t\t\t\ta := []uint16{}\n\n\t\t\t\tdraw := int(float64(n) * tr.percentFill)\n\t\t\t\tfor i := 0; i < draw; i++ {\n\t\t\t\t\tr0 := rand.Intn(n)\n\t\t\t\t\ta = append(a, uint16(r0))\n\t\t\t\t\tma[r0] = true\n\t\t\t\t}\n\n\t\t\t\trc := newRunContainer16FromVals(false, a...)\n\n\t\t\t\t// make bitmap and array versions:\n\t\t\t\tbc := newBitmapContainer()\n\t\t\t\tac := newArrayContainer()\n\t\t\t\tfor k := range ma {\n\t\t\t\t\tac.iadd(uint16(k))\n\t\t\t\t\tbc.iadd(uint16(k))\n\t\t\t\t}\n\n\t\t\t\t// compare equals() across all three\n\t\t\t\tassert.True(t, rc.equals(ac))\n\t\t\t\tassert.True(t, rc.equals(bc))\n\n\t\t\t\tassert.True(t, ac.equals(rc))\n\t\t\t\tassert.True(t, ac.equals(bc))\n\n\t\t\t\tassert.True(t, bc.equals(ac))\n\t\t\t\tassert.True(t, bc.equals(rc))\n\n\t\t\t\t// and for good measure, check against the hash\n\t\t\t\tassert.EqualValues(t, len(ma), rc.getCardinality())\n\t\t\t\tassert.EqualValues(t, len(ma), ac.getCardinality())\n\t\t\t\tassert.EqualValues(t, len(ma), bc.getCardinality())\n\n\t\t\t\tfor k := range ma {\n\t\t\t\t\tassert.True(t, rc.contains(uint16(k)))\n\t\t\t\t\tassert.True(t, ac.contains(uint16(k)))\n\t\t\t\t\tassert.True(t, bc.contains(uint16(k)))\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor i := range trials {\n\t\t\ttester(trials[i])\n\t\t}\n\t})\n}\n\nfunc TestRleIntersects023(t *testing.T) {\n\tt.Run(\"runContainer `intersects` query should work against any mix of container types\", func(t *testing.T) {\n\t\tseed := int64(42)\n\t\trand.Seed(seed)\n\n\t\ttrials := []trial{\n\t\t\t{n: 10, percentFill: .293, ntrial: 1000},\n\t\t}\n\n\t\ttester := func(tr trial) {\n\t\t\tfor j := 0; j < tr.ntrial; j++ {\n\n\t\t\t\tma := make(map[int]bool)\n\t\t\t\tmb := make(map[int]bool)\n\n\t\t\t\tn := tr.n\n\t\t\t\ta := []uint16{}\n\t\t\t\tb := []uint16{}\n\n\t\t\t\tdraw := int(float64(n) * tr.percentFill)\n\t\t\t\tfor i := 0; i < draw; i++ {\n\t\t\t\t\tr0 := rand.Intn(n)\n\t\t\t\t\ta = append(a, uint16(r0))\n\t\t\t\t\tma[r0] = true\n\n\t\t\t\t\tr1 := rand.Intn(n)\n\t\t\t\t\tb = append(b, uint16(r1))\n\t\t\t\t\tmb[r1] = true\n\t\t\t\t}\n\n\t\t\t\t// determine if they intersect from the maps\n\t\t\t\tisect := false\n\t\t\t\tfor k := range ma {\n\t\t\t\t\tif mb[k] {\n\t\t\t\t\t\tisect = true\n\t\t\t\t\t\tbreak\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\trcA := newRunContainer16FromVals(false, a...)\n\t\t\t\trcB := newRunContainer16FromVals(false, b...)\n\n\t\t\t\t// make bitmap and array versions:\n\t\t\t\tbcA := newBitmapContainer()\n\t\t\t\tbcB := newBitmapContainer()\n\n\t\t\t\tacA := newArrayContainer()\n\t\t\t\tacB := newArrayContainer()\n\t\t\t\tfor k := range ma {\n\t\t\t\t\tacA.iadd(uint16(k))\n\t\t\t\t\tbcA.iadd(uint16(k))\n\t\t\t\t}\n\t\t\t\tfor k := range mb {\n\t\t\t\t\tacB.iadd(uint16(k))\n\t\t\t\t\tbcB.iadd(uint16(k))\n\t\t\t\t}\n\n\t\t\t\t// compare intersects() across all three\n\n\t\t\t\t// same type\n\t\t\t\tassert.Equal(t, isect, rcA.intersects(rcB))\n\t\t\t\tassert.Equal(t, isect, acA.intersects(acB))\n\t\t\t\tassert.Equal(t, isect, bcA.intersects(bcB))\n\n\t\t\t\t// across types\n\t\t\t\tassert.Equal(t, isect, rcA.intersects(acB))\n\t\t\t\tassert.Equal(t, isect, rcA.intersects(bcB))\n\n\t\t\t\tassert.Equal(t, isect, acA.intersects(rcB))\n\t\t\t\tassert.Equal(t, isect, acA.intersects(bcB))\n\n\t\t\t\tassert.Equal(t, isect, bcA.intersects(acB))\n\t\t\t\tassert.Equal(t, isect, bcA.intersects(rcB))\n\n\t\t\t\t// and swap the call pattern, so we test B intersects A as well.\n\n\t\t\t\t// same type\n\t\t\t\tassert.Equal(t, isect, rcB.intersects(rcA))\n\t\t\t\tassert.Equal(t, isect, acB.intersects(acA))\n\t\t\t\tassert.Equal(t, isect, bcB.intersects(bcA))\n\n\t\t\t\t// across types\n\t\t\t\tassert.Equal(t, isect, rcB.intersects(acA))\n\t\t\t\tassert.Equal(t, isect, rcB.intersects(bcA))\n\n\t\t\t\tassert.Equal(t, isect, acB.intersects(rcA))\n\t\t\t\tassert.Equal(t, isect, acB.intersects(bcA))\n\n\t\t\t\tassert.Equal(t, isect, bcB.intersects(acA))\n\t\t\t\tassert.Equal(t, isect, bcB.intersects(rcA))\n\t\t\t}\n\t\t}\n\n\t\tfor i := range trials {\n\t\t\ttester(trials[i])\n\t\t}\n\t})\n}\n\nfunc TestRleToEfficientContainer027(t *testing.T) {\n\tt.Run(\"runContainer toEfficientContainer should return equivalent containers\", func(t *testing.T) {\n\t\tseed := int64(42)\n\t\trand.Seed(seed)\n\n\t\t// 4096 or fewer integers -> array typically\n\n\t\ttrials := []trial{\n\t\t\t{n: 8000, percentFill: .01, ntrial: 10},\n\t\t\t{n: 8000, percentFill: .99, ntrial: 10},\n\t\t}\n\n\t\ttester := func(tr trial) {\n\t\t\tfor j := 0; j < tr.ntrial; j++ {\n\t\t\t\tma := make(map[int]bool)\n\t\t\t\tn := tr.n\n\t\t\t\ta := []uint16{}\n\t\t\t\tdraw := int(float64(n) * tr.percentFill)\n\n\t\t\t\tfor i := 0; i < draw; i++ {\n\t\t\t\t\tr0 := rand.Intn(n)\n\t\t\t\t\ta = append(a, uint16(r0))\n\t\t\t\t\tma[r0] = true\n\t\t\t\t}\n\n\t\t\t\trc := newRunContainer16FromVals(false, a...)\n\t\t\t\tc := rc.toEfficientContainer()\n\n\t\t\t\tassert.True(t, rc.equals(c))\n\t\t\t}\n\t\t}\n\n\t\tfor i := range trials {\n\t\t\ttester(trials[i])\n\t\t}\n\t})\n\n\tt.Run(\"runContainer toEfficientContainer should return an equivalent bitmap when that is efficient\", func(t *testing.T) {\n\t\ta := []uint16{}\n\n\t\t// odd intergers should be smallest as a bitmap\n\t\tfor i := 0; i < MaxUint16; i++ {\n\t\t\tif i%2 == 1 {\n\t\t\t\ta = append(a, uint16(i))\n\t\t\t}\n\t\t}\n\n\t\trc := newRunContainer16FromVals(false, a...)\n\n\t\tc := rc.toEfficientContainer()\n\t\tassert.True(t, rc.equals(c))\n\n\t\t_, isBitmapContainer := c.(*bitmapContainer)\n\t\tassert.True(t, isBitmapContainer)\n\t})\n}\n\nfunc TestRle16RandomFillLeastSignificant16bits029(t *testing.T) {\n\tt.Run(\"runContainer16.fillLeastSignificant16bits() should fill contents as expected, matching the same function on bitmap and array containers\", func(t *testing.T) {\n\t\tseed := int64(42)\n\t\trand.Seed(seed)\n\n\t\ttrials := []trial{\n\t\t\t{n: 100, percentFill: .95, ntrial: 1},\n\t\t}\n\n\t\ttester := func(tr trial) {\n\t\t\tfor j := 0; j < tr.ntrial; j++ {\n\t\t\t\tma := make(map[int]bool)\n\n\t\t\t\tn := tr.n\n\t\t\t\ta := []uint16{}\n\n\t\t\t\tdraw := int(float64(n) * tr.percentFill)\n\t\t\t\tfor i := 0; i < draw; i++ {\n\t\t\t\t\tr0 := rand.Intn(n)\n\t\t\t\t\ta = append(a, uint16(r0))\n\t\t\t\t\tma[r0] = true\n\t\t\t\t}\n\n\t\t\t\t// showArray16(a, \"a\")\n\n\t\t\t\t// RunContainer\n\t\t\t\trc := newRunContainer16FromVals(false, a...)\n\n\t\t\t\t// vs bitmapContainer\n\t\t\t\tbc := newBitmapContainer()\n\t\t\t\tfor _, av := range a {\n\t\t\t\t\tbc.iadd(av)\n\t\t\t\t}\n\n\t\t\t\t// vs arrayContainer\n\t\t\t\tac := newArrayContainer()\n\t\t\t\tfor _, av := range a {\n\t\t\t\t\tac.iadd(av)\n\t\t\t\t}\n\n\t\t\t\tacOut := make([]uint32, n+10)\n\t\t\t\tbcOut := make([]uint32, n+10)\n\t\t\t\trcOut := make([]uint32, n+10)\n\n\t\t\t\tpos2 := 0\n\n\t\t\t\t// see Bitmap.ToArray() for principal use\n\t\t\t\ths := uint32(43) << 16\n\t\t\t\tac.fillLeastSignificant16bits(acOut, pos2, hs)\n\t\t\t\tbc.fillLeastSignificant16bits(bcOut, pos2, hs)\n\t\t\t\trc.fillLeastSignificant16bits(rcOut, pos2, hs)\n\n\t\t\t\tassert.EqualValues(t, acOut, rcOut)\n\t\t\t\tassert.EqualValues(t, bcOut, rcOut)\n\t\t\t}\n\t\t}\n\n\t\tfor i := range trials {\n\t\t\ttester(trials[i])\n\t\t}\n\t})\n}\n\nfunc TestRle16RandomGetShortIterator030(t *testing.T) {\n\tt.Run(\"runContainer16.getShortIterator should traverse the contents expected, matching the traversal of the bitmap and array containers\", func(t *testing.T) {\n\t\tseed := int64(42)\n\t\trand.Seed(seed)\n\n\t\ttrials := []trial{\n\t\t\t{n: 100, percentFill: .95, ntrial: 1},\n\t\t}\n\n\t\ttester := func(tr trial) {\n\t\t\tfor j := 0; j < tr.ntrial; j++ {\n\t\t\t\tma := make(map[int]bool)\n\n\t\t\t\tn := tr.n\n\t\t\t\ta := []uint16{}\n\n\t\t\t\tdraw := int(float64(n) * tr.percentFill)\n\t\t\t\tfor i := 0; i < draw; i++ {\n\t\t\t\t\tr0 := rand.Intn(n)\n\t\t\t\t\ta = append(a, uint16(r0))\n\t\t\t\t\tma[r0] = true\n\t\t\t\t}\n\n\t\t\t\t// showArray16(a, \"a\")\n\n\t\t\t\t// RunContainer\n\t\t\t\trc := newRunContainer16FromVals(false, a...)\n\n\t\t\t\t// vs bitmapContainer\n\t\t\t\tbc := newBitmapContainer()\n\t\t\t\tfor _, av := range a {\n\t\t\t\t\tbc.iadd(av)\n\t\t\t\t}\n\n\t\t\t\t// vs arrayContainer\n\t\t\t\tac := newArrayContainer()\n\t\t\t\tfor _, av := range a {\n\t\t\t\t\tac.iadd(av)\n\t\t\t\t}\n\n\t\t\t\trit := rc.getShortIterator()\n\t\t\t\tait := ac.getShortIterator()\n\t\t\t\tbit := bc.getShortIterator()\n\n\t\t\t\tfor ait.hasNext() {\n\t\t\t\t\trn := rit.next()\n\t\t\t\t\tan := ait.next()\n\t\t\t\t\tbn := bit.next()\n\n\t\t\t\t\tassert.Equal(t, an, rn)\n\t\t\t\t\tassert.Equal(t, bn, rn)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor i := range trials {\n\t\t\ttester(trials[i])\n\t\t}\n\t})\n}\n\nfunc TestRle16RandomIaddRangeIremoveRange031(t *testing.T) {\n\tt.Run(\"runContainer16.iaddRange and iremoveRange should add/remove contents as expected, matching the same operations on the bitmap and array containers and the hashmap pos control\", func(t *testing.T) {\n\t\tseed := int64(42)\n\t\trand.Seed(seed)\n\n\t\ttrials := []trial{\n\t\t\t{n: 101, percentFill: .9, ntrial: 10},\n\t\t}\n\n\t\ttester := func(tr trial) {\n\t\t\tfor j := 0; j < tr.ntrial; j++ {\n\t\t\t\tma := make(map[int]bool)\n\n\t\t\t\tn := tr.n\n\t\t\t\ta := []uint16{}\n\n\t\t\t\tdraw := int(float64(n) * tr.percentFill)\n\t\t\t\tfor i := 0; i < draw; i++ {\n\t\t\t\t\tr0 := rand.Intn(n)\n\t\t\t\t\ta = append(a, uint16(r0))\n\t\t\t\t\tma[r0] = true\n\t\t\t\t}\n\n\t\t\t\t// showArray16(a, \"a\")\n\n\t\t\t\t// RunContainer\n\t\t\t\trc := newRunContainer16FromVals(false, a...)\n\n\t\t\t\t// vs bitmapContainer\n\t\t\t\tbc := newBitmapContainer()\n\t\t\t\tfor _, av := range a {\n\t\t\t\t\tbc.iadd(av)\n\t\t\t\t}\n\n\t\t\t\t// vs arrayContainer\n\t\t\t\tac := newArrayContainer()\n\t\t\t\tfor _, av := range a {\n\t\t\t\t\tac.iadd(av)\n\t\t\t\t}\n\n\t\t\t\t// iaddRange and iRemoveRange : pick some distinct random endpoints\n\t\t\t\ta0 := rand.Intn(n)\n\t\t\t\ta1 := a0\n\t\t\t\tfor a1 == a0 {\n\t\t\t\t\ta1 = rand.Intn(n)\n\t\t\t\t}\n\t\t\t\tif a0 > a1 {\n\t\t\t\t\ta0, a1 = a1, a0\n\t\t\t\t}\n\n\t\t\t\tr0 := rand.Intn(n)\n\t\t\t\tr1 := r0\n\t\t\t\tfor r1 == r0 {\n\t\t\t\t\tr1 = rand.Intn(n)\n\t\t\t\t}\n\t\t\t\tif r0 > r1 {\n\t\t\t\t\tr0, r1 = r1, r0\n\t\t\t\t}\n\n\t\t\t\t// do the add\n\t\t\t\tfor i := a0; i <= a1; i++ {\n\t\t\t\t\tma[i] = true\n\t\t\t\t}\n\t\t\t\t// then the remove\n\t\t\t\tfor i := r0; i <= r1; i++ {\n\t\t\t\t\tdelete(ma, i)\n\t\t\t\t}\n\n\t\t\t\trc.iaddRange(a0, a1+1)\n\t\t\t\trc.iremoveRange(r0, r1+1)\n\n\t\t\t\tbc.iaddRange(a0, a1+1)\n\t\t\t\tbc.iremoveRange(r0, r1+1)\n\n\t\t\t\tac.iaddRange(a0, a1+1)\n\t\t\t\tac.iremoveRange(r0, r1+1)\n\n\t\t\t\tassert.EqualValues(t, len(ma), rc.getCardinality())\n\t\t\t\tassert.Equal(t, ac.getCardinality(), rc.getCardinality())\n\t\t\t\tassert.Equal(t, bc.getCardinality(), rc.getCardinality())\n\n\t\t\t\trit := rc.getShortIterator()\n\t\t\t\tait := ac.getShortIterator()\n\t\t\t\tbit := bc.getShortIterator()\n\n\t\t\t\tfor ait.hasNext() {\n\t\t\t\t\trn := rit.next()\n\t\t\t\t\tan := ait.next()\n\t\t\t\t\tbn := bit.next()\n\n\t\t\t\t\tassert.Equal(t, an, rn)\n\t\t\t\t\tassert.Equal(t, bn, rn)\n\t\t\t\t}\n\t\t\t\t// verify againt the map\n\t\t\t\tfor k := range ma {\n\t\t\t\t\tassert.True(t, rc.contains(uint16(k)))\n\t\t\t\t}\n\n\t\t\t\t// coverage for run16 method\n\t\t\t\tassert.Equal(t, 2+4*rc.numberOfRuns(), rc.serializedSizeInBytes())\n\t\t\t}\n\t\t}\n\n\t\tfor i := range trials {\n\t\t\ttester(trials[i])\n\t\t}\n\t})\n}\n\nfunc TestAllContainerMethodsAllContainerTypes065(t *testing.T) {\n\tt.Run(\"each of the container methods that takes two containers should handle all 3x3==9 possible ways of being called -- without panic\", func(t *testing.T) {\n\t\ta := newArrayContainer()\n\t\tr := newRunContainer16()\n\t\tb := newBitmapContainer()\n\n\t\tarr := []container{a, r, b}\n\t\tfor _, i := range arr {\n\t\t\tfor _, j := range arr {\n\t\t\t\ti.and(j)\n\t\t\t\ti.iand(j)\n\t\t\t\ti.andNot(j)\n\n\t\t\t\ti.iandNot(j)\n\t\t\t\ti.xor(j)\n\t\t\t\ti.equals(j)\n\n\t\t\t\ti.or(j)\n\t\t\t\ti.ior(j)\n\t\t\t\ti.intersects(j)\n\n\t\t\t\ti.lazyOR(j)\n\t\t\t\ti.lazyIOR(j)\n\t\t\t}\n\t\t}\n\t})\n}\n\ntype twoCall func(r container) container\n\ntype twofer struct {\n\tname string\n\tcall twoCall\n\tcn   container\n}\n\nfunc TestAllContainerMethodsAllContainerTypesWithData067(t *testing.T) {\n\tt.Run(\"each of the container methods that takes two containers should handle all 3x3==9 possible ways of being called -- and return results that agree with each other\", func(t *testing.T) {\n\t\tseed := int64(42)\n\t\trand.Seed(seed)\n\n\t\tsrang := newInterval16Range(MaxUint16-100, MaxUint16)\n\t\ttrials := []trial{\n\t\t\t{n: 100, percentFill: .7, ntrial: 1, numRandomOpsPass: 100},\n\t\t\t{n: 100, percentFill: .7, ntrial: 1, numRandomOpsPass: 100, srang: &srang},\n\t\t}\n\n\t\ttester := func(tr trial) {\n\t\t\tfor j := 0; j < tr.ntrial; j++ {\n\n\t\t\t\ta, r, b := getRandomSameThreeContainers(tr)\n\t\t\t\ta2, r2, b2 := getRandomSameThreeContainers(tr)\n\n\t\t\t\treceiver := []container{a, r, b}\n\t\t\t\targ := []container{a2, r2, b2}\n\t\t\t\tcallme := []twofer{}\n\n\t\t\t\tnCalls := 0\n\t\t\t\tfor k, c := range receiver {\n\t\t\t\t\tcallme = append(callme, twofer{\"and\", c.and, c})\n\t\t\t\t\tcallme = append(callme, twofer{\"iand\", c.iand, c})\n\t\t\t\t\tcallme = append(callme, twofer{\"ior\", c.ior, c})\n\t\t\t\t\tcallme = append(callme, twofer{\"lazyOR\", c.lazyOR, c})\n\t\t\t\t\tcallme = append(callme, twofer{\"lazyIOR\", c.lazyIOR, c})\n\t\t\t\t\tcallme = append(callme, twofer{\"or\", c.or, c})\n\t\t\t\t\tcallme = append(callme, twofer{\"xor\", c.xor, c})\n\t\t\t\t\tcallme = append(callme, twofer{\"andNot\", c.andNot, c})\n\t\t\t\t\tcallme = append(callme, twofer{\"iandNot\", c.iandNot, c})\n\t\t\t\t\tif k == 0 {\n\t\t\t\t\t\tnCalls = len(callme)\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tfor pass := 0; pass < tr.numRandomOpsPass+1; pass++ {\n\t\t\t\t\tfor k := 0; k < nCalls; k++ {\n\t\t\t\t\t\tperm := getRandomPermutation(nCalls)\n\t\t\t\t\t\tkk := perm[k]\n\t\t\t\t\t\tc1 := callme[kk]          // array receiver\n\t\t\t\t\t\tc2 := callme[kk+nCalls]   // run receiver\n\t\t\t\t\t\tc3 := callme[kk+2*nCalls] // bitmap receiver\n\n\t\t\t\t\t\tif c1.name != c2.name {\n\t\t\t\t\t\t\tpanic(\"internal logic error\")\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif c3.name != c2.name {\n\t\t\t\t\t\t\tpanic(\"internal logic error\")\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tfor k2, a := range arg {\n\n\t\t\t\t\t\t\tif !c1.cn.equals(c2.cn) {\n\t\t\t\t\t\t\t\tpanic(\"c1 not equal to c2\")\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif !c1.cn.equals(c3.cn) {\n\t\t\t\t\t\t\t\tpanic(\"c1 not equal to c3\")\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tres1 := c1.call(a) // array\n\t\t\t\t\t\t\tres2 := c2.call(a) // run\n\t\t\t\t\t\t\tres3 := c3.call(a) // bitmap\n\n\t\t\t\t\t\t\tz := c1.name\n\n\t\t\t\t\t\t\t// In-place operation are best effort\n\t\t\t\t\t\t\t// User should not assume the receiver is modified, returned container has to be used\n\t\t\t\t\t\t\tif strings.HasPrefix(z, \"i\") || z == \"lazyIOR\" {\n\t\t\t\t\t\t\t\tc1.cn = res1\n\t\t\t\t\t\t\t\tc2.cn = res2\n\t\t\t\t\t\t\t\tc3.cn = res3\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif strings.HasPrefix(z, \"lazy\") {\n\t\t\t\t\t\t\t\t// on purpose, the lazy functions\n\t\t\t\t\t\t\t\t// do not scan to update their cardinality\n\t\t\t\t\t\t\t\tif asBc, isBc := res1.(*bitmapContainer); isBc {\n\t\t\t\t\t\t\t\t\tasBc.computeCardinality()\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif asBc, isBc := res2.(*bitmapContainer); isBc {\n\t\t\t\t\t\t\t\t\tasBc.computeCardinality()\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif asBc, isBc := res3.(*bitmapContainer); isBc {\n\t\t\t\t\t\t\t\t\tasBc.computeCardinality()\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// check for equality all ways...\n\t\t\t\t\t\t\t// excercising equals() calls too.\n\n\t\t\t\t\t\t\tif !res1.equals(res2) {\n\t\t\t\t\t\t\t\tpanic(fmt.Sprintf(\"k:%v, k2:%v, res1 != res2,\"+\n\t\t\t\t\t\t\t\t\t\" call is '%s'\", k, k2, c1.name))\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif !res2.equals(res1) {\n\t\t\t\t\t\t\t\tpanic(fmt.Sprintf(\"k:%v, k2:%v, res2 != res1,\"+\n\t\t\t\t\t\t\t\t\t\" call is '%s'\", k, k2, c1.name))\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif !res1.equals(res3) {\n\t\t\t\t\t\t\t\tpanic(fmt.Sprintf(\"k:%v, k2:%v, res1 != res3,\"+\n\t\t\t\t\t\t\t\t\t\" call is '%s'\", k, k2, c1.name))\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif !res3.equals(res1) {\n\t\t\t\t\t\t\t\tpanic(fmt.Sprintf(\"k:%v, k2:%v, res3 != res1,\"+\n\t\t\t\t\t\t\t\t\t\" call is '%s'\", k, k2, c1.name))\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif !res2.equals(res3) {\n\t\t\t\t\t\t\t\tpanic(fmt.Sprintf(\"k:%v, k2:%v, res2 != res3,\"+\n\t\t\t\t\t\t\t\t\t\" call is '%s'\", k, k2, c1.name))\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif !res3.equals(res2) {\n\t\t\t\t\t\t\t\tpanic(fmt.Sprintf(\"k:%v, k2:%v, res3 != res2,\"+\n\t\t\t\t\t\t\t\t\t\" call is '%s'\", k, k2, c1.name))\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} // end k\n\t\t\t\t} // end pass\n\n\t\t\t} // end j\n\t\t} // end tester\n\n\t\tfor i := range trials {\n\t\t\ttester(trials[i])\n\t\t}\n\t})\n}\n\nfunc TestNextValueRun(t *testing.T) {\n\tt.Run(\"Java Regression1\", func(t *testing.T) {\n\t\t// [Java1] https://github.com/RoaringBitmap/RoaringBitmap/blob/5235aa62c32fa3bf7fae40a562e3edc75f61be4e/RoaringBitmap/src/test/java/org/roaringbitmap/TestRunContainer.java#L3645\n\t\trunContainer := newRunContainer16()\n\t\trunContainer.iaddRange(64, 129)\n\t\tassert.Equal(t, 64, runContainer.nextValue(0))\n\t\tassert.Equal(t, 64, runContainer.nextValue(64))\n\t\tassert.Equal(t, 65, runContainer.nextValue(65))\n\t\tassert.Equal(t, 128, runContainer.nextValue(128))\n\t\tassert.Equal(t, -1, runContainer.nextValue(129))\n\t})\n\n\tt.Run(\"Java Regression2\", func(t *testing.T) {\n\t\t// [Java2] https://github.com/RoaringBitmap/RoaringBitmap/blob/5235aa62c32fa3bf7fae40a562e3edc75f61be4e/RoaringBitmap/src/test/java/org/roaringbitmap/TestRunContainer.java#L3655\n\n\t\trunContainer := newRunContainer16()\n\t\trunContainer.iaddRange(64, 129)\n\t\trunContainer.iaddRange(256, 256+64+1)\n\t\tassert.Equal(t, 64, runContainer.nextValue(0))\n\t\tassert.Equal(t, 64, runContainer.nextValue(64))\n\t\tassert.Equal(t, 65, runContainer.nextValue(65))\n\t\tassert.Equal(t, 128, runContainer.nextValue(128))\n\t\tassert.Equal(t, 256, runContainer.nextValue(129))\n\t\tassert.Equal(t, -1, runContainer.nextValue(512))\n\t})\n\n\tt.Run(\"Java Regression3\", func(t *testing.T) {\n\t\t// [Java3] https://github.com/RoaringBitmap/RoaringBitmap/blob/5235aa62c32fa3bf7fae40a562e3edc75f61be4e/RoaringBitmap/src/test/java/org/roaringbitmap/TestRunContainer.java#L3666\n\n\t\trunContainer := newRunContainer16()\n\t\trunContainer.iaddRange(64, 129)\n\t\trunContainer.iaddRange(256, 200+300+1)\n\t\trunContainer.iaddRange(200, 200+300+1)\n\t\trunContainer.iaddRange(5000, 5000+200+1)\n\t\tassert.Equal(t, 64, runContainer.nextValue(0))\n\t\tassert.Equal(t, 64, runContainer.nextValue(64))\n\t\tassert.Equal(t, 64, runContainer.nextValue(64))\n\t\tassert.Equal(t, 65, runContainer.nextValue(65))\n\t\tassert.Equal(t, 128, runContainer.nextValue(128))\n\t\tassert.Equal(t, 200, runContainer.nextValue(129))\n\t\tassert.Equal(t, 200, runContainer.nextValue(199))\n\t\tassert.Equal(t, 200, runContainer.nextValue(200))\n\t\tassert.Equal(t, 250, runContainer.nextValue(250))\n\t\tassert.Equal(t, 5000, runContainer.nextValue(2500))\n\t\tassert.Equal(t, 5000, runContainer.nextValue(5000))\n\t\tassert.Equal(t, 5200, runContainer.nextValue(5200))\n\t\tassert.Equal(t, -1, runContainer.nextValue(5201))\n\t})\n}\n\nfunc TestPreviousValueRun(t *testing.T) {\n\tt.Run(\"Java Regression1\", func(t *testing.T) {\n\t\t// [Java 1] https://github.com/RoaringBitmap/RoaringBitmap/blob/5235aa62c32fa3bf7fae40a562e3edc75f61be4e/RoaringBitmap/src/test/java/org/roaringbitmap/TestRunContainer.java#L3684\n\t\trunContainer := newRunContainer16()\n\t\trunContainer.iaddRange(64, 129)\n\t\tassert.Equal(t, -1, runContainer.previousValue(0))\n\t\tassert.Equal(t, -1, runContainer.previousValue(63))\n\t\tassert.Equal(t, 64, runContainer.previousValue(64))\n\t\tassert.Equal(t, 65, runContainer.previousValue(65))\n\t\tassert.Equal(t, 128, runContainer.previousValue(128))\n\t\tassert.Equal(t, 128, runContainer.previousValue(129))\n\t})\n\n\tt.Run(\"Java Regression2\", func(t *testing.T) {\n\t\t// [Java 2]  https://github.com/RoaringBitmap/RoaringBitmap/blob/5235aa62c32fa3bf7fae40a562e3edc75f61be4e/RoaringBitmap/src/test/java/org/roaringbitmap/TestRunContainer.java#L3695\n\t\trunContainer := newRunContainer16()\n\t\trunContainer.iaddRange(64, 129)\n\t\trunContainer.iaddRange(200, 200+300+1)\n\t\trunContainer.iaddRange(5000, 5000+200+1)\n\t\tassert.Equal(t, -1, runContainer.previousValue(0))\n\t\tassert.Equal(t, -1, runContainer.previousValue(63))\n\t\tassert.Equal(t, 64, runContainer.previousValue(64))\n\t\tassert.Equal(t, 65, runContainer.previousValue(65))\n\t\tassert.Equal(t, 128, runContainer.previousValue(128))\n\t\tassert.Equal(t, 128, runContainer.previousValue(129))\n\t\tassert.Equal(t, 128, runContainer.previousValue(199))\n\t\tassert.Equal(t, 200, runContainer.previousValue(200))\n\t\tassert.Equal(t, 250, runContainer.previousValue(250))\n\t\tassert.Equal(t, 500, runContainer.previousValue(2500))\n\t\tassert.Equal(t, 5000, runContainer.previousValue(5000))\n\t\tassert.Equal(t, 5200, runContainer.previousValue(5200))\n\t\t// TODO Question\n\t\tassert.Equal(t, 5200, runContainer.previousValue(5201))\n\t})\n}\n\nfunc TestNextAbsentValueRun(t *testing.T) {\n\tt.Run(\"Java Regression1\", func(t *testing.T) {\n\t\t// [Java 1] https://github.com/RoaringBitmap/RoaringBitmap/blob/5235aa62c32fa3bf7fae40a562e3edc75f61be4e/RoaringBitmap/src/test/java/org/roaringbitmap/TestRunContainer.java#L3760\n\t\trunContainer := newRunContainer16()\n\t\trunContainer.iaddRange(64, 129)\n\t\tassert.Equal(t, 0, runContainer.nextAbsentValue(0))\n\t\tassert.Equal(t, 63, runContainer.nextAbsentValue(63))\n\t\tassert.Equal(t, 129, runContainer.nextAbsentValue(64))\n\t\tassert.Equal(t, 129, runContainer.nextAbsentValue(65))\n\t\tassert.Equal(t, 129, runContainer.nextAbsentValue(128))\n\t\tassert.Equal(t, 129, runContainer.nextAbsentValue(129))\n\t})\n\n\tt.Run(\"Java Regression2\", func(t *testing.T) {\n\t\t// [Java 2] https://github.com/RoaringBitmap/RoaringBitmap/blob/5235aa62c32fa3bf7fae40a562e3edc75f61be4e/RoaringBitmap/src/test/java/org/roaringbitmap/TestRunContainer.java#L3815\n\t\trunContainer := newRunContainer16()\n\t\trunContainer.iaddRange(64, 129)\n\t\trunContainer.iaddRange(200, 501)\n\t\trunContainer.iaddRange(5000, 5201)\n\n\t\tassert.Equal(t, 0, runContainer.nextAbsentValue(0))\n\t\tassert.Equal(t, 63, runContainer.nextAbsentValue(63))\n\t\tassert.Equal(t, 129, runContainer.nextAbsentValue(64))\n\t\tassert.Equal(t, 129, runContainer.nextAbsentValue(65))\n\t\tassert.Equal(t, 129, runContainer.nextAbsentValue(128))\n\t\tassert.Equal(t, 129, runContainer.nextAbsentValue(129))\n\t\tassert.Equal(t, 199, runContainer.nextAbsentValue(199))\n\t\tassert.Equal(t, 501, runContainer.nextAbsentValue(200))\n\t\tassert.Equal(t, 501, runContainer.nextAbsentValue(250))\n\t\tassert.Equal(t, 2500, runContainer.nextAbsentValue(2500))\n\t\tassert.Equal(t, 5201, runContainer.nextAbsentValue(5000))\n\t\tassert.Equal(t, 5201, runContainer.nextAbsentValue(5200))\n\t})\n\n\tt.Run(\"Java Regression3\", func(t *testing.T) {\n\t\t// [Java 3] https://github.com/RoaringBitmap/RoaringBitmap/blob/5235aa62c32fa3bf7fae40a562e3edc75f61be4e/RoaringBitmap/src/test/java/org/roaringbitmap/TestRunContainer.java#L3832\n\t\trunContainer := newRunContainer16()\n\t\tfor i := 0; i < 1000; i++ {\n\t\t\tassert.Equal(t, i, runContainer.nextAbsentValue(uint16(i)))\n\t\t}\n\t})\n}\n\nfunc TestPreviousAbsentValueRun(t *testing.T) {\n\tt.Run(\"Java Regression 1\", func(t *testing.T) {\n\t\t// [Java 1] https://github.com/RoaringBitmap/RoaringBitmap/blob/5235aa62c32fa3bf7fae40a562e3edc75f61be4e/RoaringBitmap/src/test/java/org/roaringbitmap/TestRunContainer.java#L3732\n\t\trunContainer := newRunContainer16()\n\t\trunContainer.iaddRange(64, 129)\n\n\t\tassert.Equal(t, 0, runContainer.previousAbsentValue(0))\n\t\tassert.Equal(t, 63, runContainer.previousAbsentValue(63))\n\t\tassert.Equal(t, 63, runContainer.previousAbsentValue(64))\n\t\tassert.Equal(t, 63, runContainer.previousAbsentValue(65))\n\t\tassert.Equal(t, 63, runContainer.previousAbsentValue(128))\n\t\tassert.Equal(t, 129, runContainer.previousAbsentValue(129))\n\t})\n\n\tt.Run(\"Java Regression2\", func(t *testing.T) {\n\t\t// [Java 2] https://github.com/RoaringBitmap/RoaringBitmap/blob/5235aa62c32fa3bf7fae40a562e3edc75f61be4e/RoaringBitmap/src/test/java/org/roaringbitmap/TestRunContainer.java#L3743\n\n\t\trunContainer := newRunContainer16()\n\t\trunContainer.iaddRange(64, 129)\n\t\trunContainer.iaddRange(200, 501)\n\t\trunContainer.iaddRange(5000, 5201)\n\n\t\tassert.Equal(t, 0, runContainer.previousAbsentValue(0))\n\t\tassert.Equal(t, 63, runContainer.previousAbsentValue(63))\n\t\tassert.Equal(t, 63, runContainer.previousAbsentValue(64))\n\t\tassert.Equal(t, 63, runContainer.previousAbsentValue(65))\n\t\tassert.Equal(t, 63, runContainer.previousAbsentValue(128))\n\t\tassert.Equal(t, 129, runContainer.previousAbsentValue(129))\n\t\tassert.Equal(t, 199, runContainer.previousAbsentValue(199))\n\t\tassert.Equal(t, 199, runContainer.previousAbsentValue(200))\n\t\tassert.Equal(t, 199, runContainer.previousAbsentValue(250))\n\t\tassert.Equal(t, 2500, runContainer.previousAbsentValue(2500))\n\t\tassert.Equal(t, 4999, runContainer.previousAbsentValue(5000))\n\t\tassert.Equal(t, 4999, runContainer.previousAbsentValue(5200))\n\t})\n\n\tt.Run(\"Java Regression3\", func(t *testing.T) {\n\t\t// [Java 3] https://github.com/RoaringBitmap/RoaringBitmap/blob/5235aa62c32fa3bf7fae40a562e3edc75f61be4e/RoaringBitmap/src/test/java/org/roaringbitmap/TestRunContainer.java#L3760\n\t\trunContainer := newRunContainer16()\n\t\tfor i := 0; i < 1000; i++ {\n\t\t\tassert.Equal(t, i, runContainer.previousAbsentValue(uint16(i)))\n\t\t}\n\t})\n}\n\nfunc TestRuntimeIteratorPeekNext(t *testing.T) {\n\ttestContainerIteratorPeekNext(t, newRunContainer16())\n}\n\nfunc TestRuntimeIteratorAdvance(t *testing.T) {\n\ttestContainerIteratorAdvance(t, newRunContainer16())\n}\n\nfunc TestIntervalOverlaps(t *testing.T) {\n\t// contiguous runs\n\ta := newInterval16Range(0, 9)\n\tb := newInterval16Range(10, 20)\n\n\t// Ensure the function is reflexive\n\tassert.False(t, a.isNonContiguousDisjoint(a))\n\tassert.False(t, a.isNonContiguousDisjoint(b))\n\t// Ensure the function is symmetric\n\tassert.False(t, b.isNonContiguousDisjoint(a))\n\tassert.Error(t, isNonContiguousDisjoint(a, b))\n\n\t// identical runs\n\ta = newInterval16Range(0, 9)\n\tb = newInterval16Range(0, 9)\n\n\tassert.False(t, a.isNonContiguousDisjoint(b))\n\tassert.False(t, b.isNonContiguousDisjoint(a))\n\tassert.Error(t, isNonContiguousDisjoint(a, b))\n\n\t// identical start runs\n\ta = newInterval16Range(0, 9)\n\tb = newInterval16Range(0, 20)\n\n\tassert.False(t, a.isNonContiguousDisjoint(b))\n\tassert.False(t, b.isNonContiguousDisjoint(a))\n\tassert.Error(t, isNonContiguousDisjoint(a, b))\n\n\t// overlapping runs\n\ta = newInterval16Range(0, 12)\n\tb = newInterval16Range(10, 20)\n\n\tassert.False(t, a.isNonContiguousDisjoint(b))\n\tassert.Error(t, isNonContiguousDisjoint(a, b))\n\n\t// subset runs\n\ta = newInterval16Range(0, 12)\n\tb = newInterval16Range(5, 9)\n\n\tassert.False(t, a.isNonContiguousDisjoint(b))\n\tassert.Error(t, isNonContiguousDisjoint(a, b))\n\n\t// degenerate runs\n\ta = newInterval16Range(0, 0)\n\tb = newInterval16Range(5, 5)\n\n\tassert.True(t, a.isNonContiguousDisjoint(b))\n\tassert.NoError(t, isNonContiguousDisjoint(a, b))\n\n\t// disjoint non-contiguous runs\n\ta = newInterval16Range(0, 100)\n\tb = newInterval16Range(1000, 2000)\n\n\tassert.True(t, a.isNonContiguousDisjoint(b))\n\tassert.NoError(t, isNonContiguousDisjoint(a, b))\n}\n\nfunc TestIntervalValidationFailing(t *testing.T) {\n\trc := &runContainer16{}\n\tassert.Error(t, rc.validate())\n\n\ta := newInterval16Range(0, 9)\n\tb := newInterval16Range(0, 9)\n\trc = &runContainer16{}\n\trc.iv = append(rc.iv, a, b)\n\tassert.ErrorIs(t, rc.validate(), ErrRunIntervalEqual)\n\n\ta = newInterval16Range(0, 9)\n\tb = newInterval16Range(10, 20)\n\n\trc = &runContainer16{}\n\trc.iv = append(rc.iv, a, b)\n\tassert.ErrorIs(t, rc.validate(), ErrRunIntervalOverlap)\n\n\ta = newInterval16Range(0, 12)\n\tb = newInterval16Range(10, 20)\n\n\trc = &runContainer16{}\n\trc.iv = append(rc.iv, a, b)\n\tassert.Error(t, rc.validate(), ErrRunIntervalOverlap)\n\n\tc := newInterval16Range(100, 150)\n\td := newInterval16Range(1000, 10000)\n\n\trc = &runContainer16{}\n\trc.iv = append(rc.iv, a, b, c, d)\n\tassert.ErrorIs(t, rc.validate(), ErrRunIntervalOverlap)\n\n\ta = newInterval16Range(0, 10)\n\tb = newInterval16Range(100, 200)\n\n\t// missort\n\trc = &runContainer16{}\n\trc.iv = append(rc.iv, b, a)\n\tassert.ErrorIs(t, rc.validate(), ErrRunNonSorted)\n\n\trc = &runContainer16{}\n\tstart := -4\n\tfor i := 0; i < MaxNumIntervals; i++ {\n\t\tstart += 4\n\t\tend := start + 2\n\t\ta := newInterval16Range(uint16(start), uint16(end))\n\t\trc.iv = append(rc.iv, a)\n\n\t}\n\tassert.ErrorIs(t, rc.validate(), ErrRunIntervalSize)\n\n\t// too many small runs, use array\n\trc = &runContainer16{}\n\tstart = -3\n\tfor i := 0; i < 10; i++ {\n\t\tstart += 3\n\t\tend := start + 1\n\t\ta := newInterval16Range(uint16(start), uint16(end))\n\t\trc.iv = append(rc.iv, a)\n\n\t}\n\tassert.ErrorIs(t, rc.validate(), ErrRunIntervalSize)\n}\n\nfunc TestIntervalValidationsPassing(t *testing.T) {\n\trc := &runContainer16{}\n\ta := newInterval16Range(0, 10)\n\tb := newInterval16Range(100, 200)\n\trc.iv = append(rc.iv, a, b)\n\tassert.NoError(t, rc.validate())\n\n\t// Large total sum, but enough intervals\n\trc = &runContainer16{}\n\ta = newInterval16Range(0, uint16(MaxIntervalsSum+1))\n\trc.iv = append(rc.iv, a)\n\tassert.NoError(t, rc.validate())\n\n\trc = &runContainer16{}\n\ta = newInterval16Range(0, uint16(MaxIntervalsSum+1))\n\tb = newInterval16Range(uint16(MaxIntervalsSum+3), uint16(MaxIntervalsSum*2))\n\trc.iv = append(rc.iv, a, b)\n\tassert.NoError(t, rc.validate())\n}\n\nfunc TestRunContainerUnionCardinality(t *testing.T) {\n\tt.Run(\"Two Empty Runs\", func(t *testing.T) {\n\t\tfirst := runContainer16{}\n\t\tsecond := runContainer16{}\n\t\tresult := first.unionCardinality(&second)\n\t\tassert.Equal(t, uint(0), result)\n\t})\n\n\tt.Run(\"First Run Empty\", func(t *testing.T) {\n\t\tfirst := runContainer16{}\n\t\tsecond := runContainer16{}\n\t\tsecond.iaddRange(0, 1024)\n\t\tresult := first.unionCardinality(&second)\n\t\tassert.Equal(t, uint(1024), result)\n\t})\n\n\tt.Run(\"Second Run Empty\", func(t *testing.T) {\n\t\tfirst := runContainer16{}\n\t\tsecond := runContainer16{}\n\t\tfirst.iaddRange(0, 1024)\n\t\tresult := first.unionCardinality(&second)\n\t\tassert.Equal(t, uint(1024), result)\n\t})\n\n\tt.Run(\"Disjoint Ranges\", func(t *testing.T) {\n\t\tfirst := runContainer16{}\n\t\tfirst.iaddRange(512, 1024)\n\t\tsecond := runContainer16{}\n\t\tsecond.iaddRange(0, 256)\n\t\tresult := first.unionCardinality(&second)\n\t\tassert.Equal(t, uint(256+512), result)\n\t})\n\n\tt.Run(\"Complete Overlap\", func(t *testing.T) {\n\t\tfirst := runContainer16{}\n\t\tfirst.iaddRange(0, 256)\n\t\tsecond := runContainer16{}\n\t\tsecond.iaddRange(0, 256)\n\t\tresult := first.unionCardinality(&second)\n\t\tassert.Equal(t, uint(256), result)\n\t})\n}\n\nfunc TestRunContainerIntersectCardinality(t *testing.T) {\n\tt.Run(\"Two Empty Runs\", func(t *testing.T) {\n\t\tfirst := runContainer16{}\n\t\tsecond := runContainer16{}\n\t\tresult := first.intersectCardinality(&second)\n\t\tassert.Equal(t, 0, result)\n\t})\n\n\tt.Run(\"First Run Empty\", func(t *testing.T) {\n\t\tfirst := runContainer16{}\n\t\tsecond := runContainer16{}\n\t\tsecond.iaddRange(0, 1024)\n\t\tresult := first.intersectCardinality(&second)\n\t\tassert.Equal(t, 0, result)\n\t})\n\n\tt.Run(\"Second Run Empty\", func(t *testing.T) {\n\t\tfirst := runContainer16{}\n\t\tsecond := runContainer16{}\n\t\tfirst.iaddRange(0, 1024)\n\t\tresult := first.intersectCardinality(&second)\n\t\tassert.Equal(t, 0, result)\n\t})\n\n\tt.Run(\"Disjoint Ranges\", func(t *testing.T) {\n\t\tfirst := runContainer16{}\n\t\tfirst.iaddRange(512, 1024)\n\t\tsecond := runContainer16{}\n\t\tsecond.iaddRange(0, 256)\n\t\tresult := first.intersectCardinality(&second)\n\t\tassert.Equal(t, 0, result)\n\t})\n\n\tt.Run(\"Complete Overlap\", func(t *testing.T) {\n\t\tfirst := runContainer16{}\n\t\tfirst.iaddRange(0, 256)\n\t\tsecond := runContainer16{}\n\t\tsecond.iaddRange(0, 256)\n\t\tresult := first.intersectCardinality(&second)\n\t\tassert.Equal(t, 256, result)\n\t})\n\n\tt.Run(\"Single Element Intersection\", func(t *testing.T) {\n\t\tfirst := runContainer16{}\n\t\tfirst.iaddRange(0, 257)\n\t\tsecond := runContainer16{}\n\t\tsecond.iaddRange(256, 512)\n\t\tresult := first.intersectCardinality(&second)\n\t\tassert.Equal(t, 1, result)\n\t})\n}\n\n// go test -bench BenchmarkShortIteratorAdvance -run -\nfunc BenchmarkShortIteratorAdvanceRuntime(b *testing.B) {\n\tbenchmarkContainerIteratorAdvance(b, newRunContainer16())\n}\n\n// go test -bench BenchmarkShortIteratorNext -run -\nfunc BenchmarkShortIteratorNextRuntime(b *testing.B) {\n\tbenchmarkContainerIteratorNext(b, newRunContainer16())\n}\n\n// generate random contents, then return that same\n// logical content in three different container types\nfunc getRandomSameThreeContainers(tr trial) (*arrayContainer, *runContainer16, *bitmapContainer) {\n\tma := make(map[int]bool)\n\n\tn := tr.n\n\ta := []uint16{}\n\n\tvar samp interval16\n\tif tr.srang != nil {\n\t\tsamp = *tr.srang\n\t} else {\n\t\tif n-1 > MaxUint16 {\n\t\t\tpanic(fmt.Errorf(\"n out of range: %v\", n))\n\t\t}\n\t\tsamp.start = 0\n\t\tsamp.length = uint16(n - 2)\n\t}\n\n\tdraw := int(float64(n) * tr.percentFill)\n\tfor i := 0; i < draw; i++ {\n\t\tr0 := int(samp.start) + rand.Intn(int(samp.runlen()))\n\t\ta = append(a, uint16(r0))\n\t\tma[r0] = true\n\t}\n\n\trc := newRunContainer16FromVals(false, a...)\n\n\t// vs bitmapContainer\n\tbc := newBitmapContainerFromRun(rc)\n\tac := rc.toArrayContainer()\n\n\treturn ac, rc, bc\n}\n"
        },
        {
          "name": "serialization.go",
          "type": "blob",
          "size": 0.474609375,
          "content": "package roaring\n\nimport (\n\t\"encoding/binary\"\n\t\"io\"\n)\n\n// writeTo for runContainer16 follows this\n// spec: https://github.com/RoaringBitmap/RoaringFormatSpec\nfunc (b *runContainer16) writeTo(stream io.Writer) (int, error) {\n\tbuf := make([]byte, 2+4*len(b.iv))\n\tbinary.LittleEndian.PutUint16(buf[0:], uint16(len(b.iv)))\n\tfor i, v := range b.iv {\n\t\tbinary.LittleEndian.PutUint16(buf[2+i*4:], v.start)\n\t\tbinary.LittleEndian.PutUint16(buf[2+2+i*4:], v.length)\n\t}\n\treturn stream.Write(buf)\n}\n"
        },
        {
          "name": "serialization_frozen_test.go",
          "type": "blob",
          "size": 6.6865234375,
          "content": "//go:build (386 && !appengine) || (amd64 && !appengine) || (arm && !appengine) || (arm64 && !appengine) || (ppc64le && !appengine) || (mipsle && !appengine) || (mips64le && !appengine) || (mips64p32le && !appengine) || (wasm && !appengine)\n// +build 386,!appengine amd64,!appengine arm,!appengine arm64,!appengine ppc64le,!appengine mipsle,!appengine mips64le,!appengine mips64p32le,!appengine wasm,!appengine\n\npackage roaring\n\nimport (\n\t\"bytes\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"os\"\n\t\"reflect\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestFrozenFormat(t *testing.T) {\n\ttests := [...]struct {\n\t\tname, frozenPath, portablePath string\n\t}{\n\t\t{\n\t\t\tname:         \"bitmaps only\",\n\t\t\tfrozenPath:   \"testfrozendata/bitmaps_only.frozen\",\n\t\t\tportablePath: \"testfrozendata/bitmaps_only.portable\",\n\t\t},\n\t\t{\n\t\t\tname:         \"arrays only\",\n\t\t\tfrozenPath:   \"testfrozendata/arrays_only.frozen\",\n\t\t\tportablePath: \"testfrozendata/arrays_only.portable\",\n\t\t},\n\t\t{\n\t\t\tname:         \"runs only\",\n\t\t\tfrozenPath:   \"testfrozendata/runs_only.frozen\",\n\t\t\tportablePath: \"testfrozendata/runs_only.portable\",\n\t\t},\n\t\t{\n\t\t\tname:         \"mixed\",\n\t\t\tfrozenPath:   \"testfrozendata/mixed.frozen\",\n\t\t\tportablePath: \"testfrozendata/mixed.portable\",\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\t// NOTE: opted for loading files twice rather than optimizing it because:\n\t\t// 1. It's still cheap enough, it's small files; and\n\t\t// 2. In a buggy scenario one of the tests may write into the buffer and cause\n\t\t//    a race condition, making it harder to figure out why the tests fail.\n\t\tname, fpath, ppath := test.name, test.frozenPath, test.portablePath\n\t\tt.Run(\"view \"+name, func(t *testing.T) {\n\t\t\tt.Parallel()\n\n\t\t\tfrozenBuf, err := ioutil.ReadFile(fpath)\n\t\t\tif err != nil {\n\t\t\t\tfmt.Fprintf(os.Stderr, \"\\n\\nIMPORTANT: For testing file IO, the roaring library requires disk access.\\nWe omit some tests for now.\\n\\n\")\n\t\t\t\treturn\n\t\t\t}\n\t\t\tportableBuf, err := ioutil.ReadFile(ppath)\n\t\t\tif err != nil {\n\t\t\t\tfmt.Fprintf(os.Stderr, \"\\n\\nIMPORTANT: For testing file IO, the roaring library requires disk access.\\nWe omit some tests for now.\\n\\n\")\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tfrozen, portable := New(), New()\n\t\t\tif err := frozen.FrozenView(frozenBuf); err != nil {\n\t\t\t\tt.Fatalf(\"failed to load bitmap from %s: %s\", fpath, err)\n\t\t\t}\n\t\t\tif _, err := portable.FromBuffer(portableBuf); err != nil {\n\t\t\t\tt.Fatalf(\"failed to load bitmap from %s: %s\", ppath, err)\n\t\t\t}\n\n\t\t\tif !frozen.Equals(portable) {\n\t\t\t\tt.Fatalf(\"bitmaps for %s and %s differ\", fpath, ppath)\n\t\t\t}\n\t\t})\n\t\tt.Run(\"freeze \"+name, func(t *testing.T) {\n\t\t\tt.Parallel()\n\n\t\t\tfrozenBuf, err := ioutil.ReadFile(fpath)\n\t\t\tif err != nil {\n\t\t\t\tfmt.Fprintf(os.Stderr, \"\\n\\nIMPORTANT: For testing file IO, the roaring library requires disk access.\\nWe omit some tests for now.\\n\\n\")\n\t\t\t\treturn\n\t\t\t}\n\t\t\tportableBuf, err := ioutil.ReadFile(ppath)\n\t\t\tif err != nil {\n\t\t\t\tfmt.Fprintf(os.Stderr, \"\\n\\nIMPORTANT: For testing file IO, the roaring library requires disk access.\\nWe omit some tests for now.\\n\\n\")\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tportable := New()\n\t\t\tif _, err := portable.FromBuffer(portableBuf); err != nil {\n\t\t\t\tt.Fatalf(\"failed to load bitmap from %s: %s\", ppath, err)\n\t\t\t}\n\n\t\t\tfrozenSize := portable.GetFrozenSizeInBytes()\n\t\t\tif int(frozenSize) != len(frozenBuf) {\n\t\t\t\tt.Errorf(\"size for serializing %s differs from %s's size\", ppath, fpath)\n\t\t\t}\n\t\t\tfrozen, err := portable.Freeze()\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"can't freeze %s: %s\", ppath, err)\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(frozen, frozenBuf) {\n\t\t\t\tt.Fatalf(\"frozen file for %s and %s differ\", fpath, ppath)\n\t\t\t}\n\t\t})\n\t\tt.Run(\"freeze with writer\"+name, func(t *testing.T) {\n\t\t\tt.Parallel()\n\n\t\t\tfrozenBuf, err := ioutil.ReadFile(fpath)\n\t\t\tif err != nil {\n\t\t\t\tfmt.Fprintf(os.Stderr, \"\\n\\nIMPORTANT: For testing file IO, the roaring library requires disk access.\\nWe omit some tests for now.\\n\\n\")\n\t\t\t\treturn\n\t\t\t}\n\t\t\tportableBuf, err := ioutil.ReadFile(ppath)\n\t\t\tif err != nil {\n\t\t\t\tfmt.Fprintf(os.Stderr, \"\\n\\nIMPORTANT: For testing file IO, the roaring library requires disk access.\\nWe omit some tests for now.\\n\\n\")\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tportable := New()\n\t\t\tif _, err := portable.FromBuffer(portableBuf); err != nil {\n\t\t\t\tt.Fatalf(\"failed to load bitmap from %s: %s\", ppath, err)\n\t\t\t}\n\n\t\t\twr := &bytes.Buffer{}\n\t\t\tfrozenSize, err := portable.WriteFrozenTo(wr)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"can't freeze %s: %s\", ppath, err)\n\t\t\t}\n\t\t\tif int(frozenSize) != len(frozenBuf) {\n\t\t\t\tt.Errorf(\"size for serializing %s differs from %s's size\", ppath, fpath)\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(wr.Bytes(), frozenBuf) {\n\t\t\t\tt.Fatalf(\"frozen file for %s and %s differ\", fpath, ppath)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestBitMapValidationFromFrozen(t *testing.T) {\n\t// To understand what is going on here, read https://github.com/RoaringBitmap/RoaringFormatSpec\n\t// Maintainers: The loader and corruptor are dependent on one another\n\t// The tests expect a certain size, with values at certain location.\n\t// The tests are geared toward single byte corruption.\n\n\t// There is no way to test Bitmap container corruption once the bitmap is deserialized\n\n\tdeserializationTests := []struct {\n\t\tname      string\n\t\tloader    func(bm *Bitmap)\n\t\tcorruptor func(s []byte)\n\t\terr       error\n\t}{\n\t\t{\n\t\t\tname: \"Corrupts Run Length vs Num Runs\",\n\t\t\tloader: func(bm *Bitmap) {\n\t\t\t\tbm.AddRange(0, 2)\n\t\t\t\tbm.AddRange(4, 6)\n\t\t\t\tbm.AddRange(8, 100)\n\t\t\t},\n\t\t\tcorruptor: func(s []byte) {\n\t\t\t\t// 21 is the length of the run of the last run/range\n\t\t\t\t// Shortening causes interval sum to be to short\n\t\t\t\ts[10] = 1\n\t\t\t},\n\t\t\terr: ErrRunIntervalSize,\n\t\t},\n\t\t{\n\t\t\tname: \"Corrupts Run Length\",\n\t\t\tloader: func(bm *Bitmap) {\n\t\t\t\tbm.AddRange(100, 110)\n\t\t\t},\n\t\t\tcorruptor: func(s []byte) {\n\t\t\t\t// 13 is the length of the run\n\t\t\t\t// Setting to zero causes an invalid run\n\t\t\t\ts[2] = 0\n\t\t\t},\n\t\t\terr: ErrRunIntervalLength,\n\t\t},\n\t\t{\n\t\t\tname: \"Creates Interval Overlap\",\n\t\t\tloader: func(bm *Bitmap) {\n\t\t\t\tbm.AddRange(100, 110)\n\t\t\t\tbm.AddRange(115, 125)\n\t\t\t},\n\t\t\tcorruptor: func(s []byte) {\n\t\t\t\t// sets the start of the second run\n\t\t\t\t// Creates overlapping intervals\n\t\t\t\ts[4] = 108\n\t\t\t},\n\t\t\terr: ErrRunIntervalOverlap,\n\t\t},\n\t\t{\n\t\t\tname: \"Break Array Sort Order\",\n\t\t\tloader: func(bm *Bitmap) {\n\t\t\t\tarrayEntries := make([]uint32, 0, 10)\n\t\t\t\tfor i := 0; i < 10; i++ {\n\t\t\t\t\tarrayEntries = append(arrayEntries, uint32(i))\n\t\t\t\t}\n\t\t\t\tbm.AddMany(arrayEntries)\n\t\t\t},\n\t\t\tcorruptor: func(s []byte) {\n\t\t\t\t// breaks the sort order\n\t\t\t\ts[4] = 0\n\t\t\t},\n\t\t\terr: ErrArrayIncorrectSort,\n\t\t},\n\t}\n\n\tfor _, tt := range deserializationTests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tbm := NewBitmap()\n\t\t\ttt.loader(bm)\n\t\t\tassert.NoError(t, bm.Validate())\n\t\t\tserialized, err := bm.Freeze()\n\t\t\tassert.NoError(t, err)\n\t\t\ttt.corruptor(serialized)\n\t\t\tcorruptedDeserializedBitMap := NewBitmap()\n\n\t\t\tassert.ErrorIs(t, corruptedDeserializedBitMap.MustFrozenView(serialized), tt.err)\n\t\t})\n\t}\n}\n"
        },
        {
          "name": "serialization_generic.go",
          "type": "blob",
          "size": 3.30078125,
          "content": "//go:build (!amd64 && !386 && !arm && !arm64 && !ppc64le && !mipsle && !mips64le && !mips64p32le && !wasm) || appengine\n// +build !amd64,!386,!arm,!arm64,!ppc64le,!mipsle,!mips64le,!mips64p32le,!wasm appengine\n\npackage roaring\n\nimport (\n\t\"encoding/binary\"\n\t\"errors\"\n\t\"io\"\n)\n\nfunc (b *arrayContainer) writeTo(stream io.Writer) (int, error) {\n\tbuf := make([]byte, 2*len(b.content))\n\tfor i, v := range b.content {\n\t\tbase := i * 2\n\t\tbuf[base] = byte(v)\n\t\tbuf[base+1] = byte(v >> 8)\n\t}\n\treturn stream.Write(buf)\n}\n\nfunc (b *arrayContainer) readFrom(stream io.Reader) (int, error) {\n\terr := binary.Read(stream, binary.LittleEndian, b.content)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\treturn 2 * len(b.content), nil\n}\n\nfunc (b *bitmapContainer) writeTo(stream io.Writer) (int, error) {\n\tif b.cardinality <= arrayDefaultMaxSize {\n\t\treturn 0, errors.New(\"refusing to write bitmap container with cardinality of array container\")\n\t}\n\n\t// Write set\n\tbuf := make([]byte, 8*len(b.bitmap))\n\tfor i, v := range b.bitmap {\n\t\tbase := i * 8\n\t\tbuf[base] = byte(v)\n\t\tbuf[base+1] = byte(v >> 8)\n\t\tbuf[base+2] = byte(v >> 16)\n\t\tbuf[base+3] = byte(v >> 24)\n\t\tbuf[base+4] = byte(v >> 32)\n\t\tbuf[base+5] = byte(v >> 40)\n\t\tbuf[base+6] = byte(v >> 48)\n\t\tbuf[base+7] = byte(v >> 56)\n\t}\n\treturn stream.Write(buf)\n}\n\nfunc (b *bitmapContainer) readFrom(stream io.Reader) (int, error) {\n\terr := binary.Read(stream, binary.LittleEndian, b.bitmap)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\tb.computeCardinality()\n\treturn 8 * len(b.bitmap), nil\n}\n\nfunc (bc *bitmapContainer) asLittleEndianByteSlice() []byte {\n\tby := make([]byte, len(bc.bitmap)*8)\n\tfor i := range bc.bitmap {\n\t\tbinary.LittleEndian.PutUint64(by[i*8:], bc.bitmap[i])\n\t}\n\treturn by\n}\n\nfunc uint64SliceAsByteSlice(slice []uint64) []byte {\n\tby := make([]byte, len(slice)*8)\n\n\tfor i, v := range slice {\n\t\tbinary.LittleEndian.PutUint64(by[i*8:], v)\n\t}\n\n\treturn by\n}\n\nfunc uint16SliceAsByteSlice(slice []uint16) []byte {\n\tby := make([]byte, len(slice)*2)\n\n\tfor i, v := range slice {\n\t\tbinary.LittleEndian.PutUint16(by[i*2:], v)\n\t}\n\n\treturn by\n}\n\nfunc interval16SliceAsByteSlice(slice []interval16) []byte {\n\tby := make([]byte, len(slice)*4)\n\n\tfor i, v := range slice {\n\t\tbinary.LittleEndian.PutUint16(by[i*2:], v.start)\n\t\tbinary.LittleEndian.PutUint16(by[i*2+2:], v.length)\n\t}\n\n\treturn by\n}\n\nfunc byteSliceAsUint16Slice(slice []byte) []uint16 {\n\tif len(slice)%2 != 0 {\n\t\tpanic(\"Slice size should be divisible by 2\")\n\t}\n\n\tb := make([]uint16, len(slice)/2)\n\n\tfor i := range b {\n\t\tb[i] = binary.LittleEndian.Uint16(slice[2*i:])\n\t}\n\n\treturn b\n}\n\nfunc byteSliceAsUint64Slice(slice []byte) []uint64 {\n\tif len(slice)%8 != 0 {\n\t\tpanic(\"Slice size should be divisible by 8\")\n\t}\n\n\tb := make([]uint64, len(slice)/8)\n\n\tfor i := range b {\n\t\tb[i] = binary.LittleEndian.Uint64(slice[8*i:])\n\t}\n\n\treturn b\n}\n\n// Converts a byte slice to a interval16 slice.\n// The function assumes that the slice byte buffer is run container data\n// encoded according to Roaring Format Spec\nfunc byteSliceAsInterval16Slice(byteSlice []byte) []interval16 {\n\tif len(byteSlice)%4 != 0 {\n\t\tpanic(\"Slice size should be divisible by 4\")\n\t}\n\n\tintervalSlice := make([]interval16, len(byteSlice)/4)\n\n\tfor i := range intervalSlice {\n\t\tintervalSlice[i] = interval16{\n\t\t\tstart:  binary.LittleEndian.Uint16(byteSlice[i*4:]),\n\t\t\tlength: binary.LittleEndian.Uint16(byteSlice[i*4+2:]),\n\t\t}\n\t}\n\n\treturn intervalSlice\n}\n"
        },
        {
          "name": "serialization_littleendian.go",
          "type": "blob",
          "size": 19.7568359375,
          "content": "//go:build (386 && !appengine) || (amd64 && !appengine) || (arm && !appengine) || (arm64 && !appengine) || (ppc64le && !appengine) || (mipsle && !appengine) || (mips64le && !appengine) || (mips64p32le && !appengine) || (wasm && !appengine)\n// +build 386,!appengine amd64,!appengine arm,!appengine arm64,!appengine ppc64le,!appengine mipsle,!appengine mips64le,!appengine mips64p32le,!appengine wasm,!appengine\n\npackage roaring\n\nimport (\n\t\"encoding/binary\"\n\t\"errors\"\n\t\"io\"\n\t\"reflect\"\n\t\"runtime\"\n\t\"unsafe\"\n)\n\nfunc (ac *arrayContainer) writeTo(stream io.Writer) (int, error) {\n\tbuf := uint16SliceAsByteSlice(ac.content)\n\treturn stream.Write(buf)\n}\n\nfunc (bc *bitmapContainer) writeTo(stream io.Writer) (int, error) {\n\tif bc.cardinality <= arrayDefaultMaxSize {\n\t\treturn 0, errors.New(\"refusing to write bitmap container with cardinality of array container\")\n\t}\n\tbuf := uint64SliceAsByteSlice(bc.bitmap)\n\treturn stream.Write(buf)\n}\n\nfunc uint64SliceAsByteSlice(slice []uint64) []byte {\n\t// make a new slice header\n\theader := *(*reflect.SliceHeader)(unsafe.Pointer(&slice))\n\n\t// update its capacity and length\n\theader.Len *= 8\n\theader.Cap *= 8\n\n\t// instantiate result and use KeepAlive so data isn't unmapped.\n\tresult := *(*[]byte)(unsafe.Pointer(&header))\n\truntime.KeepAlive(&slice)\n\n\t// return it\n\treturn result\n}\n\nfunc uint16SliceAsByteSlice(slice []uint16) []byte {\n\t// make a new slice header\n\theader := *(*reflect.SliceHeader)(unsafe.Pointer(&slice))\n\n\t// update its capacity and length\n\theader.Len *= 2\n\theader.Cap *= 2\n\n\t// instantiate result and use KeepAlive so data isn't unmapped.\n\tresult := *(*[]byte)(unsafe.Pointer(&header))\n\truntime.KeepAlive(&slice)\n\n\t// return it\n\treturn result\n}\n\nfunc interval16SliceAsByteSlice(slice []interval16) []byte {\n\t// make a new slice header\n\theader := *(*reflect.SliceHeader)(unsafe.Pointer(&slice))\n\n\t// update its capacity and length\n\theader.Len *= 4\n\theader.Cap *= 4\n\n\t// instantiate result and use KeepAlive so data isn't unmapped.\n\tresult := *(*[]byte)(unsafe.Pointer(&header))\n\truntime.KeepAlive(&slice)\n\n\t// return it\n\treturn result\n}\n\nfunc (bc *bitmapContainer) asLittleEndianByteSlice() []byte {\n\treturn uint64SliceAsByteSlice(bc.bitmap)\n}\n\n// Deserialization code follows\n\n// //\n// These methods (byteSliceAsUint16Slice,...) do not make copies,\n// they are pointer-based (unsafe). The caller is responsible to\n// ensure that the input slice does not get garbage collected, deleted\n// or modified while you hold the returned slince.\n// //\nfunc byteSliceAsUint16Slice(slice []byte) (result []uint16) { // here we create a new slice holder\n\tif len(slice)%2 != 0 {\n\t\tpanic(\"Slice size should be divisible by 2\")\n\t}\n\t// reference: https://go101.org/article/unsafe.html\n\n\t// make a new slice header\n\tbHeader := (*reflect.SliceHeader)(unsafe.Pointer(&slice))\n\trHeader := (*reflect.SliceHeader)(unsafe.Pointer(&result))\n\n\t// transfer the data from the given slice to a new variable (our result)\n\trHeader.Data = bHeader.Data\n\trHeader.Len = bHeader.Len / 2\n\trHeader.Cap = bHeader.Cap / 2\n\n\t// instantiate result and use KeepAlive so data isn't unmapped.\n\truntime.KeepAlive(&slice) // it is still crucial, GC can free it)\n\n\t// return result\n\treturn\n}\n\nfunc byteSliceAsUint64Slice(slice []byte) (result []uint64) {\n\tif len(slice)%8 != 0 {\n\t\tpanic(\"Slice size should be divisible by 8\")\n\t}\n\t// reference: https://go101.org/article/unsafe.html\n\n\t// make a new slice header\n\tbHeader := (*reflect.SliceHeader)(unsafe.Pointer(&slice))\n\trHeader := (*reflect.SliceHeader)(unsafe.Pointer(&result))\n\n\t// transfer the data from the given slice to a new variable (our result)\n\trHeader.Data = bHeader.Data\n\trHeader.Len = bHeader.Len / 8\n\trHeader.Cap = bHeader.Cap / 8\n\n\t// instantiate result and use KeepAlive so data isn't unmapped.\n\truntime.KeepAlive(&slice) // it is still crucial, GC can free it)\n\n\t// return result\n\treturn\n}\n\nfunc byteSliceAsInterval16Slice(slice []byte) (result []interval16) {\n\tif len(slice)%4 != 0 {\n\t\tpanic(\"Slice size should be divisible by 4\")\n\t}\n\t// reference: https://go101.org/article/unsafe.html\n\n\t// make a new slice header\n\tbHeader := (*reflect.SliceHeader)(unsafe.Pointer(&slice))\n\trHeader := (*reflect.SliceHeader)(unsafe.Pointer(&result))\n\n\t// transfer the data from the given slice to a new variable (our result)\n\trHeader.Data = bHeader.Data\n\trHeader.Len = bHeader.Len / 4\n\trHeader.Cap = bHeader.Cap / 4\n\n\t// instantiate result and use KeepAlive so data isn't unmapped.\n\truntime.KeepAlive(&slice) // it is still crucial, GC can free it)\n\n\t// return result\n\treturn\n}\n\nfunc byteSliceAsContainerSlice(slice []byte) (result []container) {\n\tvar c container\n\tcontainerSize := int(unsafe.Sizeof(c))\n\n\tif len(slice)%containerSize != 0 {\n\t\tpanic(\"Slice size should be divisible by unsafe.Sizeof(container)\")\n\t}\n\t// reference: https://go101.org/article/unsafe.html\n\n\t// make a new slice header\n\tbHeader := (*reflect.SliceHeader)(unsafe.Pointer(&slice))\n\trHeader := (*reflect.SliceHeader)(unsafe.Pointer(&result))\n\n\t// transfer the data from the given slice to a new variable (our result)\n\trHeader.Data = bHeader.Data\n\trHeader.Len = bHeader.Len / containerSize\n\trHeader.Cap = bHeader.Cap / containerSize\n\n\t// instantiate result and use KeepAlive so data isn't unmapped.\n\truntime.KeepAlive(&slice) // it is still crucial, GC can free it)\n\n\t// return result\n\treturn\n}\n\nfunc byteSliceAsBitsetSlice(slice []byte) (result []bitmapContainer) {\n\tbitsetSize := int(unsafe.Sizeof(bitmapContainer{}))\n\tif len(slice)%bitsetSize != 0 {\n\t\tpanic(\"Slice size should be divisible by unsafe.Sizeof(bitmapContainer)\")\n\t}\n\t// reference: https://go101.org/article/unsafe.html\n\n\t// make a new slice header\n\tbHeader := (*reflect.SliceHeader)(unsafe.Pointer(&slice))\n\trHeader := (*reflect.SliceHeader)(unsafe.Pointer(&result))\n\n\t// transfer the data from the given slice to a new variable (our result)\n\trHeader.Data = bHeader.Data\n\trHeader.Len = bHeader.Len / bitsetSize\n\trHeader.Cap = bHeader.Cap / bitsetSize\n\n\t// instantiate result and use KeepAlive so data isn't unmapped.\n\truntime.KeepAlive(&slice) // it is still crucial, GC can free it)\n\n\t// return result\n\treturn\n}\n\nfunc byteSliceAsArraySlice(slice []byte) (result []arrayContainer) {\n\tarraySize := int(unsafe.Sizeof(arrayContainer{}))\n\tif len(slice)%arraySize != 0 {\n\t\tpanic(\"Slice size should be divisible by unsafe.Sizeof(arrayContainer)\")\n\t}\n\t// reference: https://go101.org/article/unsafe.html\n\n\t// make a new slice header\n\tbHeader := (*reflect.SliceHeader)(unsafe.Pointer(&slice))\n\trHeader := (*reflect.SliceHeader)(unsafe.Pointer(&result))\n\n\t// transfer the data from the given slice to a new variable (our result)\n\trHeader.Data = bHeader.Data\n\trHeader.Len = bHeader.Len / arraySize\n\trHeader.Cap = bHeader.Cap / arraySize\n\n\t// instantiate result and use KeepAlive so data isn't unmapped.\n\truntime.KeepAlive(&slice) // it is still crucial, GC can free it)\n\n\t// return result\n\treturn\n}\n\nfunc byteSliceAsRun16Slice(slice []byte) (result []runContainer16) {\n\trun16Size := int(unsafe.Sizeof(runContainer16{}))\n\tif len(slice)%run16Size != 0 {\n\t\tpanic(\"Slice size should be divisible by unsafe.Sizeof(runContainer16)\")\n\t}\n\t// reference: https://go101.org/article/unsafe.html\n\n\t// make a new slice header\n\tbHeader := (*reflect.SliceHeader)(unsafe.Pointer(&slice))\n\trHeader := (*reflect.SliceHeader)(unsafe.Pointer(&result))\n\n\t// transfer the data from the given slice to a new variable (our result)\n\trHeader.Data = bHeader.Data\n\trHeader.Len = bHeader.Len / run16Size\n\trHeader.Cap = bHeader.Cap / run16Size\n\n\t// instantiate result and use KeepAlive so data isn't unmapped.\n\truntime.KeepAlive(&slice) // it is still crucial, GC can free it)\n\n\t// return result\n\treturn\n}\n\nfunc byteSliceAsBoolSlice(slice []byte) (result []bool) {\n\tboolSize := int(unsafe.Sizeof(true))\n\tif len(slice)%boolSize != 0 {\n\t\tpanic(\"Slice size should be divisible by unsafe.Sizeof(bool)\")\n\t}\n\t// reference: https://go101.org/article/unsafe.html\n\n\t// make a new slice header\n\tbHeader := (*reflect.SliceHeader)(unsafe.Pointer(&slice))\n\trHeader := (*reflect.SliceHeader)(unsafe.Pointer(&result))\n\n\t// transfer the data from the given slice to a new variable (our result)\n\trHeader.Data = bHeader.Data\n\trHeader.Len = bHeader.Len / boolSize\n\trHeader.Cap = bHeader.Cap / boolSize\n\n\t// instantiate result and use KeepAlive so data isn't unmapped.\n\truntime.KeepAlive(&slice) // it is still crucial, GC can free it)\n\n\t// return result\n\treturn\n}\n\n// FrozenView creates a static view of a serialized bitmap stored in buf.\n// It uses CRoaring's frozen bitmap format.\n//\n// The format specification is available here:\n// https://github.com/RoaringBitmap/CRoaring/blob/2c867e9f9c9e2a3a7032791f94c4c7ae3013f6e0/src/roaring.c#L2756-L2783\n//\n// The provided byte array (buf) is expected to be a constant.\n// The function makes the best effort attempt not to copy data.\n// Only little endian is supported. The function will err if it detects a big\n// endian serialized file.\n// You should take care not to modify buff as it will likely result in\n// unexpected program behavior.\n// If said buffer comes from a memory map, it's advisable to give it read\n// only permissions, either at creation or by calling Mprotect from the\n// golang.org/x/sys/unix package.\n//\n// Resulting bitmaps are effectively immutable in the following sense:\n// a copy-on-write marker is used so that when you modify the resulting\n// bitmap, copies of selected data (containers) are made.\n// You should *not* change the copy-on-write status of the resulting\n// bitmaps (SetCopyOnWrite).\n//\n// If buf becomes unavailable, then a bitmap created with\n// FromBuffer would be effectively broken. Furthermore, any\n// bitmap derived from this bitmap (e.g., via Or, And) might\n// also be broken. Thus, before making buf unavailable, you should\n// call CloneCopyOnWriteContainers on all such bitmaps.\nfunc (rb *Bitmap) FrozenView(buf []byte) error {\n\treturn rb.highlowcontainer.frozenView(buf)\n}\n\nfunc (rb *Bitmap) MustFrozenView(buf []byte) error {\n\tif err := rb.FrozenView(buf); err != nil {\n\t\treturn err\n\t}\n\terr := rb.Validate()\n\n\treturn err\n}\n\n/* Verbatim specification from CRoaring.\n *\n * FROZEN SERIALIZATION FORMAT DESCRIPTION\n *\n * -- (beginning must be aligned by 32 bytes) --\n * <bitset_data> uint64_t[BITSET_CONTAINER_SIZE_IN_WORDS * num_bitset_containers]\n * <run_data>    rle16_t[total number of rle elements in all run containers]\n * <array_data>  uint16_t[total number of array elements in all array containers]\n * <keys>        uint16_t[num_containers]\n * <counts>      uint16_t[num_containers]\n * <typecodes>   uint8_t[num_containers]\n * <header>      uint32_t\n *\n * <header> is a 4-byte value which is a bit union of frozenCookie (15 bits)\n * and the number of containers (17 bits).\n *\n * <counts> stores number of elements for every container.\n * Its meaning depends on container type.\n * For array and bitset containers, this value is the container cardinality minus one.\n * For run container, it is the number of rle_t elements (n_runs).\n *\n * <bitset_data>,<array_data>,<run_data> are flat arrays of elements of\n * all containers of respective type.\n *\n * <*_data> and <keys> are kept close together because they are not accessed\n * during deserilization. This may reduce IO in case of large mmaped bitmaps.\n * All members have their native alignments during deserilization except <header>,\n * which is not guaranteed to be aligned by 4 bytes.\n */\nconst frozenCookie = 13766\n\nvar (\n\t// ErrFrozenBitmapInvalidCookie is returned when the header does not contain the frozenCookie.\n\tErrFrozenBitmapInvalidCookie = errors.New(\"header does not contain the frozenCookie\")\n\t// ErrFrozenBitmapBigEndian is returned when the header is big endian.\n\tErrFrozenBitmapBigEndian = errors.New(\"loading big endian frozen bitmaps is not supported\")\n\t// ErrFrozenBitmapIncomplete is returned when the buffer is too small to contain a frozen bitmap.\n\tErrFrozenBitmapIncomplete = errors.New(\"input buffer too small to contain a frozen bitmap\")\n\t// ErrFrozenBitmapOverpopulated is returned when the number of containers is too large.\n\tErrFrozenBitmapOverpopulated = errors.New(\"too many containers\")\n\t// ErrFrozenBitmapUnexpectedData is returned when the buffer contains unexpected data.\n\tErrFrozenBitmapUnexpectedData = errors.New(\"spurious data in input\")\n\t// ErrFrozenBitmapInvalidTypecode is returned when the typecode is invalid.\n\tErrFrozenBitmapInvalidTypecode = errors.New(\"unrecognized typecode\")\n\t// ErrFrozenBitmapBufferTooSmall is returned when the buffer is too small.\n\tErrFrozenBitmapBufferTooSmall = errors.New(\"buffer too small\")\n)\n\nfunc (ra *roaringArray) frozenView(buf []byte) error {\n\tif len(buf) < 4 {\n\t\treturn ErrFrozenBitmapIncomplete\n\t}\n\n\theaderBE := binary.BigEndian.Uint32(buf[len(buf)-4:])\n\tif headerBE&0x7fff == frozenCookie {\n\t\treturn ErrFrozenBitmapBigEndian\n\t}\n\n\theader := binary.LittleEndian.Uint32(buf[len(buf)-4:])\n\tbuf = buf[:len(buf)-4]\n\n\tif header&0x7fff != frozenCookie {\n\t\treturn ErrFrozenBitmapInvalidCookie\n\t}\n\n\tnCont := int(header >> 15)\n\tif nCont > (1 << 16) {\n\t\treturn ErrFrozenBitmapOverpopulated\n\t}\n\n\t// 1 byte per type, 2 bytes per key, 2 bytes per count.\n\tif len(buf) < 5*nCont {\n\t\treturn ErrFrozenBitmapIncomplete\n\t}\n\n\ttypes := buf[len(buf)-nCont:]\n\tbuf = buf[:len(buf)-nCont]\n\n\tcounts := byteSliceAsUint16Slice(buf[len(buf)-2*nCont:])\n\tbuf = buf[:len(buf)-2*nCont]\n\n\tkeys := byteSliceAsUint16Slice(buf[len(buf)-2*nCont:])\n\tbuf = buf[:len(buf)-2*nCont]\n\n\tnBitmap, nArray, nRun := 0, 0, 0\n\tnArrayEl, nRunEl := 0, 0\n\tfor i, t := range types {\n\t\tswitch t {\n\t\tcase 1:\n\t\t\tnBitmap++\n\t\tcase 2:\n\t\t\tnArray++\n\t\t\tnArrayEl += int(counts[i]) + 1\n\t\tcase 3:\n\t\t\tnRun++\n\t\t\tnRunEl += int(counts[i])\n\t\tdefault:\n\t\t\treturn ErrFrozenBitmapInvalidTypecode\n\t\t}\n\t}\n\n\tif len(buf) < (1<<13)*nBitmap+4*nRunEl+2*nArrayEl {\n\t\treturn ErrFrozenBitmapIncomplete\n\t}\n\n\tbitsetsArena := byteSliceAsUint64Slice(buf[:(1<<13)*nBitmap])\n\tbuf = buf[(1<<13)*nBitmap:]\n\n\trunsArena := byteSliceAsInterval16Slice(buf[:4*nRunEl])\n\tbuf = buf[4*nRunEl:]\n\n\tarraysArena := byteSliceAsUint16Slice(buf[:2*nArrayEl])\n\tbuf = buf[2*nArrayEl:]\n\n\tif len(buf) != 0 {\n\t\treturn ErrFrozenBitmapUnexpectedData\n\t}\n\n\tvar c container\n\tcontainersSz := int(unsafe.Sizeof(c)) * nCont\n\tbitsetsSz := int(unsafe.Sizeof(bitmapContainer{})) * nBitmap\n\tarraysSz := int(unsafe.Sizeof(arrayContainer{})) * nArray\n\trunsSz := int(unsafe.Sizeof(runContainer16{})) * nRun\n\tneedCOWSz := int(unsafe.Sizeof(true)) * nCont\n\n\tbitmapArenaSz := containersSz + bitsetsSz + arraysSz + runsSz + needCOWSz\n\tbitmapArena := make([]byte, bitmapArenaSz)\n\n\tcontainers := byteSliceAsContainerSlice(bitmapArena[:containersSz])\n\tbitmapArena = bitmapArena[containersSz:]\n\n\tbitsets := byteSliceAsBitsetSlice(bitmapArena[:bitsetsSz])\n\tbitmapArena = bitmapArena[bitsetsSz:]\n\n\tarrays := byteSliceAsArraySlice(bitmapArena[:arraysSz])\n\tbitmapArena = bitmapArena[arraysSz:]\n\n\truns := byteSliceAsRun16Slice(bitmapArena[:runsSz])\n\tbitmapArena = bitmapArena[runsSz:]\n\n\tneedCOW := byteSliceAsBoolSlice(bitmapArena)\n\n\tiBitset, iArray, iRun := 0, 0, 0\n\tfor i, t := range types {\n\t\tneedCOW[i] = true\n\n\t\tswitch t {\n\t\tcase 1:\n\t\t\tcontainers[i] = &bitsets[iBitset]\n\t\t\tbitsets[iBitset].cardinality = int(counts[i]) + 1\n\t\t\tbitsets[iBitset].bitmap = bitsetsArena[:1024]\n\t\t\tbitsetsArena = bitsetsArena[1024:]\n\t\t\tiBitset++\n\t\tcase 2:\n\t\t\tcontainers[i] = &arrays[iArray]\n\t\t\tsz := int(counts[i]) + 1\n\t\t\tarrays[iArray].content = arraysArena[:sz]\n\t\t\tarraysArena = arraysArena[sz:]\n\t\t\tiArray++\n\t\tcase 3:\n\t\t\tcontainers[i] = &runs[iRun]\n\t\t\truns[iRun].iv = runsArena[:counts[i]]\n\t\t\trunsArena = runsArena[counts[i]:]\n\t\t\tiRun++\n\t\t}\n\t}\n\n\t// Not consuming the full input is a bug.\n\tif iBitset != nBitmap || len(bitsetsArena) != 0 ||\n\t\tiArray != nArray || len(arraysArena) != 0 ||\n\t\tiRun != nRun || len(runsArena) != 0 {\n\t\tpanic(\"we missed something\")\n\t}\n\n\tra.keys = keys\n\tra.containers = containers\n\tra.needCopyOnWrite = needCOW\n\tra.copyOnWrite = true\n\n\treturn nil\n}\n\n// GetFrozenSizeInBytes returns the size in bytes of the frozen bitmap.\nfunc (rb *Bitmap) GetFrozenSizeInBytes() uint64 {\n\tnBits, nArrayEl, nRunEl := uint64(0), uint64(0), uint64(0)\n\tfor _, c := range rb.highlowcontainer.containers {\n\t\tswitch v := c.(type) {\n\t\tcase *bitmapContainer:\n\t\t\tnBits++\n\t\tcase *arrayContainer:\n\t\t\tnArrayEl += uint64(len(v.content))\n\t\tcase *runContainer16:\n\t\t\tnRunEl += uint64(len(v.iv))\n\t\t}\n\t}\n\treturn 4 + 5*uint64(len(rb.highlowcontainer.containers)) +\n\t\t(nBits << 13) + 2*nArrayEl + 4*nRunEl\n}\n\n// Freeze serializes the bitmap in the CRoaring's frozen format.\nfunc (rb *Bitmap) Freeze() ([]byte, error) {\n\tsz := rb.GetFrozenSizeInBytes()\n\tbuf := make([]byte, sz)\n\t_, err := rb.FreezeTo(buf)\n\treturn buf, err\n}\n\n// FreezeTo serializes the bitmap in the CRoaring's frozen format.\nfunc (rb *Bitmap) FreezeTo(buf []byte) (int, error) {\n\tcontainers := rb.highlowcontainer.containers\n\tnCont := len(containers)\n\n\tnBits, nArrayEl, nRunEl := 0, 0, 0\n\tfor _, c := range containers {\n\t\tswitch v := c.(type) {\n\t\tcase *bitmapContainer:\n\t\t\tnBits++\n\t\tcase *arrayContainer:\n\t\t\tnArrayEl += len(v.content)\n\t\tcase *runContainer16:\n\t\t\tnRunEl += len(v.iv)\n\t\t}\n\t}\n\n\tserialSize := 4 + 5*nCont + (1<<13)*nBits + 4*nRunEl + 2*nArrayEl\n\tif len(buf) < serialSize {\n\t\treturn 0, ErrFrozenBitmapBufferTooSmall\n\t}\n\n\tbitsArena := byteSliceAsUint64Slice(buf[:(1<<13)*nBits])\n\tbuf = buf[(1<<13)*nBits:]\n\n\trunsArena := byteSliceAsInterval16Slice(buf[:4*nRunEl])\n\tbuf = buf[4*nRunEl:]\n\n\tarraysArena := byteSliceAsUint16Slice(buf[:2*nArrayEl])\n\tbuf = buf[2*nArrayEl:]\n\n\tkeys := byteSliceAsUint16Slice(buf[:2*nCont])\n\tbuf = buf[2*nCont:]\n\n\tcounts := byteSliceAsUint16Slice(buf[:2*nCont])\n\tbuf = buf[2*nCont:]\n\n\ttypes := buf[:nCont]\n\tbuf = buf[nCont:]\n\n\theader := uint32(frozenCookie | (nCont << 15))\n\tbinary.LittleEndian.PutUint32(buf[:4], header)\n\n\tcopy(keys, rb.highlowcontainer.keys[:])\n\n\tfor i, c := range containers {\n\t\tswitch v := c.(type) {\n\t\tcase *bitmapContainer:\n\t\t\tcopy(bitsArena, v.bitmap)\n\t\t\tbitsArena = bitsArena[1024:]\n\t\t\tcounts[i] = uint16(v.cardinality - 1)\n\t\t\ttypes[i] = 1\n\t\tcase *arrayContainer:\n\t\t\tcopy(arraysArena, v.content)\n\t\t\tarraysArena = arraysArena[len(v.content):]\n\t\t\telems := len(v.content)\n\t\t\tcounts[i] = uint16(elems - 1)\n\t\t\ttypes[i] = 2\n\t\tcase *runContainer16:\n\t\t\tcopy(runsArena, v.iv)\n\t\t\truns := len(v.iv)\n\t\t\trunsArena = runsArena[runs:]\n\t\t\tcounts[i] = uint16(runs)\n\t\t\ttypes[i] = 3\n\t\t}\n\t}\n\n\treturn serialSize, nil\n}\n\n// WriteFrozenTo serializes the bitmap in the CRoaring's frozen format.\nfunc (rb *Bitmap) WriteFrozenTo(wr io.Writer) (int, error) {\n\t// FIXME: this is a naive version that iterates 4 times through the\n\t// containers and allocates 3*len(containers) bytes; it's quite likely\n\t// it can be done more efficiently.\n\tcontainers := rb.highlowcontainer.containers\n\twritten := 0\n\n\tfor _, c := range containers {\n\t\tc, ok := c.(*bitmapContainer)\n\t\tif !ok {\n\t\t\tcontinue\n\t\t}\n\t\tn, err := wr.Write(uint64SliceAsByteSlice(c.bitmap))\n\t\twritten += n\n\t\tif err != nil {\n\t\t\treturn written, err\n\t\t}\n\t}\n\n\tfor _, c := range containers {\n\t\tc, ok := c.(*runContainer16)\n\t\tif !ok {\n\t\t\tcontinue\n\t\t}\n\t\tn, err := wr.Write(interval16SliceAsByteSlice(c.iv))\n\t\twritten += n\n\t\tif err != nil {\n\t\t\treturn written, err\n\t\t}\n\t}\n\n\tfor _, c := range containers {\n\t\tc, ok := c.(*arrayContainer)\n\t\tif !ok {\n\t\t\tcontinue\n\t\t}\n\t\tn, err := wr.Write(uint16SliceAsByteSlice(c.content))\n\t\twritten += n\n\t\tif err != nil {\n\t\t\treturn written, err\n\t\t}\n\t}\n\n\tn, err := wr.Write(uint16SliceAsByteSlice(rb.highlowcontainer.keys))\n\twritten += n\n\tif err != nil {\n\t\treturn written, err\n\t}\n\n\tcountTypeBuf := make([]byte, 3*len(containers))\n\tcounts := byteSliceAsUint16Slice(countTypeBuf[:2*len(containers)])\n\ttypes := countTypeBuf[2*len(containers):]\n\n\tfor i, c := range containers {\n\t\tswitch c := c.(type) {\n\t\tcase *bitmapContainer:\n\t\t\tcounts[i] = uint16(c.cardinality - 1)\n\t\t\ttypes[i] = 1\n\t\tcase *arrayContainer:\n\t\t\telems := len(c.content)\n\t\t\tcounts[i] = uint16(elems - 1)\n\t\t\ttypes[i] = 2\n\t\tcase *runContainer16:\n\t\t\truns := len(c.iv)\n\t\t\tcounts[i] = uint16(runs)\n\t\t\ttypes[i] = 3\n\t\t}\n\t}\n\n\tn, err = wr.Write(countTypeBuf)\n\twritten += n\n\tif err != nil {\n\t\treturn written, err\n\t}\n\n\theader := uint32(frozenCookie | (len(containers) << 15))\n\tif err := binary.Write(wr, binary.LittleEndian, header); err != nil {\n\t\treturn written, err\n\t}\n\twritten += 4\n\n\treturn written, nil\n}\n"
        },
        {
          "name": "serialization_test.go",
          "type": "blob",
          "size": 17.548828125,
          "content": "package roaring\n\n// to run just these tests: go test -run TestSerialization*\n\nimport (\n\t\"bytes\"\n\t\"encoding/binary\"\n\t\"encoding/gob\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"runtime\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n\t\"github.com/stretchr/testify/require\"\n)\n\nfunc TestSerializationOfEmptyBitmap(t *testing.T) {\n\trb := NewBitmap()\n\n\tbuf := &bytes.Buffer{}\n\t_, err := rb.WriteTo(buf)\n\n\trequire.NoError(t, err)\n\tassert.EqualValues(t, buf.Len(), rb.GetSerializedSizeInBytes())\n\n\tnewrb := NewBitmap()\n\t_, err = newrb.ReadFrom(buf)\n\n\trequire.NoError(t, err)\n\tassert.True(t, rb.Equals(newrb))\n}\n\nfunc TestBase64_036(t *testing.T) {\n\trb := BitmapOf(1, 2, 3, 4, 5, 100, 1000)\n\n\tbstr, _ := rb.ToBase64()\n\tassert.NotEmpty(t, bstr)\n\n\tnewrb := NewBitmap()\n\n\t_, err := newrb.FromBase64(bstr)\n\n\trequire.NoError(t, err)\n\tassert.True(t, rb.Equals(newrb))\n}\n\nfunc TestSerializationBasic037(t *testing.T) {\n\trb := BitmapOf(1, 2, 3, 4, 5, 100, 1000)\n\n\tbuf := &bytes.Buffer{}\n\t_, err := rb.WriteTo(buf)\n\n\trequire.NoError(t, err)\n\tassert.EqualValues(t, buf.Len(), rb.GetSerializedSizeInBytes())\n\n\tnewrb := NewBitmap()\n\t_, err = newrb.ReadFrom(buf)\n\n\trequire.NoError(t, err)\n\tassert.True(t, rb.Equals(newrb))\n}\n\nfunc TestSerializationToFile038(t *testing.T) {\n\trb := BitmapOf(1, 2, 3, 4, 5, 100, 1000)\n\tfname := \"myfile.bin\"\n\tfout, err := os.OpenFile(fname, os.O_RDWR|os.O_CREATE|os.O_TRUNC, 0660)\n\tif err != nil {\n\t\tfmt.Fprintf(os.Stderr, \"\\n\\nIMPORTANT: For testing file IO, the roaring library requires disk access.\\nWe omit some tests for now.\\n\\n\")\n\t\treturn\n\t}\n\n\tvar l int64\n\tl, err = rb.WriteTo(fout)\n\tif err != nil {\n\t\tfmt.Fprintf(os.Stderr, \"\\n\\nIMPORTANT: For testing file IO, the roaring library requires disk access.\\nWe omit some tests for now.\\n\\n\")\n\t\treturn\n\t}\n\n\tassert.EqualValues(t, l, rb.GetSerializedSizeInBytes())\n\n\tfout.Close()\n\n\tnewrb := NewBitmap()\n\tfin, err := os.Open(fname)\n\tif err != nil {\n\t\tfmt.Fprintf(os.Stderr, \"\\n\\nIMPORTANT: For testing file IO, the roaring library requires disk access.\\nWe omit some tests for now.\\n\\n\")\n\t\treturn\n\t}\n\n\tdefer func() {\n\t\tfin.Close()\n\t\t_ = os.Remove(fname)\n\t}()\n\n\t_, _ = newrb.ReadFrom(fin)\n\tassert.True(t, rb.Equals(newrb))\n}\n\nfunc TestSerializationReadRunsFromFile039(t *testing.T) {\n\tfn := \"testdata/bitmapwithruns.bin\"\n\n\tby, err := ioutil.ReadFile(fn)\n\tif err != nil {\n\t\tfmt.Fprintf(os.Stderr, \"\\n\\nIMPORTANT: For testing file IO, the roaring library requires disk access.\\nWe omit some tests for now.\\n\\n\")\n\t\treturn\n\t}\n\n\tnewrb := NewBitmap()\n\t_, err = newrb.ReadFrom(bytes.NewBuffer(by))\n\n\trequire.NoError(t, err)\n}\n\nfunc TestSerializationBasic4WriteAndReadFile040(t *testing.T) {\n\tfname := \"testdata/all3.classic\"\n\n\trb := NewBitmap()\n\tfor k := uint32(0); k < 100000; k += 1000 {\n\t\trb.Add(k)\n\t}\n\tfor k := uint32(100000); k < 200000; k++ {\n\t\trb.Add(3 * k)\n\t}\n\tfor k := uint32(700000); k < 800000; k++ {\n\t\trb.Add(k)\n\t}\n\n\trb.highlowcontainer.runOptimize()\n\tfout, err := os.Create(fname)\n\tif err != nil {\n\t\tfmt.Fprintf(os.Stderr, \"\\n\\nIMPORTANT: For testing file IO, the roaring library requires disk access.\\nWe omit some tests for now.\\n\\n\")\n\t\treturn\n\t}\n\n\tvar l int64\n\n\tl, err = rb.WriteTo(fout)\n\n\tif err != nil {\n\t\tfmt.Fprintf(os.Stderr, \"\\n\\nIMPORTANT: For testing file IO, the roaring library requires disk access.\\nWe omit some tests for now.\\n\\n\")\n\t\treturn\n\t}\n\tassert.EqualValues(t, l, rb.GetSerializedSizeInBytes())\n\n\tfout.Close()\n\tfin, err := os.Open(fname)\n\tif err != nil {\n\t\tfmt.Fprintf(os.Stderr, \"\\n\\nIMPORTANT: For testing file IO, the roaring library requires disk access.\\nWe omit some tests for now.\\n\\n\")\n\t\treturn\n\t}\n\n\tdefer fin.Close()\n\n\tnewrb := NewBitmap()\n\t_, err = newrb.ReadFrom(fin)\n\n\trequire.NoError(t, err)\n\tassert.True(t, rb.Equals(newrb))\n}\n\nfunc TestSerializationFromJava051(t *testing.T) {\n\tfname := \"testdata/bitmapwithoutruns.bin\"\n\tnewrb := NewBitmap()\n\tfin, err := os.Open(fname)\n\tif err != nil {\n\t\tfmt.Fprintf(os.Stderr, \"\\n\\nIMPORTANT: For testing file IO, the roaring library requires disk access.\\nWe omit some tests for now.\\n\\n\")\n\t\treturn\n\t}\n\n\tdefer func() {\n\t\tfin.Close()\n\t}()\n\n\t_, _ = newrb.ReadFrom(fin)\n\tt.Log(newrb.GetCardinality())\n\trb := NewBitmap()\n\tfor k := uint32(0); k < 100000; k += 1000 {\n\t\trb.Add(k)\n\t}\n\tfor k := uint32(100000); k < 200000; k++ {\n\t\trb.Add(3 * k)\n\t}\n\tfor k := uint32(700000); k < 800000; k++ {\n\t\trb.Add(k)\n\t}\n\n\tassert.True(t, rb.Equals(newrb))\n}\n\nfunc TestSerializationFromJavaWithRuns052(t *testing.T) {\n\tfname := \"testdata/bitmapwithruns.bin\"\n\n\tnewrb := NewBitmap()\n\tfin, err := os.Open(fname)\n\tif err != nil {\n\t\tfmt.Fprintf(os.Stderr, \"\\n\\nIMPORTANT: For testing file IO, the roaring library requires disk access.\\nWe omit some tests for now.\\n\\n\")\n\t\treturn\n\t}\n\n\tdefer func() {\n\t\tfin.Close()\n\t}()\n\t_, _ = newrb.ReadFrom(fin)\n\trb := NewBitmap()\n\n\tfor k := uint32(0); k < 100000; k += 1000 {\n\t\trb.Add(k)\n\t}\n\tfor k := uint32(100000); k < 200000; k++ {\n\t\trb.Add(3 * k)\n\t}\n\tfor k := uint32(700000); k < 800000; k++ {\n\t\trb.Add(k)\n\t}\n\n\tassert.True(t, rb.Equals(newrb))\n}\n\nfunc TestSerializationBasic2_041(t *testing.T) {\n\trb := BitmapOf(1, 2, 3, 4, 5, 100, 1000, 10000, 100000, 1000000)\n\tbuf := &bytes.Buffer{}\n\tsz := rb.GetSerializedSizeInBytes()\n\tub := BoundSerializedSizeInBytes(rb.GetCardinality(), 1000001)\n\n\tassert.False(t, sz > ub+10)\n\n\tl := int(rb.GetSerializedSizeInBytes())\n\t_, err := rb.WriteTo(buf)\n\n\trequire.NoError(t, err)\n\tassert.Equal(t, l, buf.Len())\n\n\tnewrb := NewBitmap()\n\t_, err = newrb.ReadFrom(buf)\n\n\trequire.NoError(t, err)\n\tassert.True(t, rb.Equals(newrb))\n}\n\nfunc TestFromUnsafeBytes(t *testing.T) {\n\trb := BitmapOf(1, 2, 3, 4, 5, 100, 1000, 10000, 100000, 1000000)\n\tbuf := &bytes.Buffer{}\n\t_, err := rb.WriteTo(buf)\n\trequire.NoError(t, err)\n\tb := buf.Bytes()\n\trb2 := NewBitmap()\n\t_, err2 := rb2.FromUnsafeBytes(b)\n\trequire.NoError(t, err2)\n\tassert.True(t, rb.Equals(rb2))\n}\n\n// roaringarray.writeTo and .readFrom should serialize and unserialize when containing all 3 container types\nfunc TestSerializationBasic3_042(t *testing.T) {\n\trb := BitmapOf(1, 2, 3, 4, 5, 100, 1000, 10000, 100000, 1000000)\n\tfor i := 5000000; i < 5000000+2*(1<<16); i++ {\n\t\trb.AddInt(i)\n\t}\n\n\t// confirm all three types present\n\tvar bc, ac, rc bool\n\tfor _, v := range rb.highlowcontainer.containers {\n\t\tswitch cn := v.(type) {\n\t\tcase *bitmapContainer:\n\t\t\tbc = true\n\t\tcase *arrayContainer:\n\t\t\tac = true\n\t\tcase *runContainer16:\n\t\t\trc = true\n\t\tdefault:\n\t\t\tt.Fatalf(\"Unrecognized container implementation: %T\", cn)\n\t\t}\n\t}\n\n\tassert.True(t, bc, \"no bitmapContainer found, change your test input so we test all three!\")\n\tassert.True(t, ac, \"no arrayContainer found, change your test input so we test all three!\")\n\tassert.True(t, rc, \"no runContainer16 found, change your test input so we test all three!\")\n\n\tvar buf bytes.Buffer\n\t_, err := rb.WriteTo(&buf)\n\n\trequire.NoError(t, err)\n\tassert.EqualValues(t, buf.Len(), rb.GetSerializedSizeInBytes())\n\n\tnewrb := NewBitmap()\n\t_, err = newrb.ReadFrom(&buf)\n\n\trequire.NoError(t, err)\n\tassert.Equal(t, rb.GetCardinality(), newrb.GetCardinality())\n\tassert.True(t, newrb.Equals(rb))\n}\n\nfunc TestGobcoding043(t *testing.T) {\n\trb := BitmapOf(1, 2, 3, 4, 5, 100, 1000)\n\n\tbuf := new(bytes.Buffer)\n\tencoder := gob.NewEncoder(buf)\n\terr := encoder.Encode(rb)\n\n\trequire.NoError(t, err)\n\n\tvar b Bitmap\n\tdecoder := gob.NewDecoder(buf)\n\terr = decoder.Decode(&b)\n\n\trequire.NoError(t, err)\n\tassert.True(t, b.Equals(rb))\n}\n\nfunc TestByteSliceAsUint16Slice(t *testing.T) {\n\tt.Run(\"valid slice\", func(t *testing.T) {\n\t\texpectedSize := 2\n\t\tslice := make([]byte, 4)\n\t\tbinary.LittleEndian.PutUint16(slice, 42)\n\t\tbinary.LittleEndian.PutUint16(slice[2:], 43)\n\n\t\tuint16Slice := byteSliceAsUint16Slice(slice)\n\n\t\tassert.Equal(t, expectedSize, len(uint16Slice))\n\t\tassert.Equal(t, expectedSize, cap(uint16Slice))\n\t\tassert.False(t, uint16Slice[0] != 42 || uint16Slice[1] != 43)\n\t})\n\n\tt.Run(\"inlined\", func(t *testing.T) {\n\t\tfirst, second := singleSliceInArray()\n\t\tt.Logf(\"received %v %v\", first, second[0])\n\t\tif !first.Equals(second[0]) {\n\t\t\tt.Errorf(\"inline fail %v %v\", first, second[0])\n\t\t}\n\t})\n\n\tt.Run(\"empty slice\", func(t *testing.T) {\n\t\tslice := make([]byte, 0, 0)\n\t\tuint16Slice := byteSliceAsUint16Slice(slice)\n\n\t\tassert.Equal(t, 0, len(uint16Slice))\n\t\tassert.Equal(t, 0, cap(uint16Slice))\n\t})\n\n\tt.Run(\"invalid slice size\", func(t *testing.T) {\n\t\tslice := make([]byte, 1, 1)\n\n\t\tassert.Panics(t, func() {\n\t\t\tbyteSliceAsUint16Slice(slice)\n\t\t})\n\t})\n}\n\nfunc singleSliceInArray() (*Bitmap, []*Bitmap) {\n\tfirstSlice := singleSlice()\n\tcontainerSlice := make([]*Bitmap, 0)\n\tsecondContainer := singleSlice()\n\tcontainerSlice = append(containerSlice, secondContainer)\n\treturn firstSlice, containerSlice\n}\n\nfunc singleSlice() *Bitmap {\n\tslice := make([]byte, 2)\n\treturn &Bitmap{highlowcontainer: roaringArray{keys: []uint16{0}, containers: []container{&arrayContainer{byteSliceAsUint16Slice(slice)}}}}\n}\n\nfunc TestByteSliceAsUint64Slice(t *testing.T) {\n\tt.Run(\"valid slice\", func(t *testing.T) {\n\t\texpectedSize := 2\n\t\tslice := make([]byte, 16)\n\t\tbinary.LittleEndian.PutUint64(slice, 42)\n\t\tbinary.LittleEndian.PutUint64(slice[8:], 43)\n\n\t\tuint64Slice := byteSliceAsUint64Slice(slice)\n\n\t\tassert.Equal(t, expectedSize, len(uint64Slice))\n\t\tassert.Equal(t, expectedSize, cap(uint64Slice))\n\t\tassert.False(t, uint64Slice[0] != 42 || uint64Slice[1] != 43)\n\t})\n\n\tt.Run(\"empty slice\", func(t *testing.T) {\n\t\tslice := make([]byte, 0, 0)\n\t\tuint64Slice := byteSliceAsUint64Slice(slice)\n\n\t\tassert.Equal(t, 0, len(uint64Slice))\n\t\tassert.Equal(t, 0, cap(uint64Slice))\n\t})\n\n\tt.Run(\"invalid slice size\", func(t *testing.T) {\n\t\tslice := make([]byte, 1, 1)\n\n\t\tassert.Panics(t, func() {\n\t\t\tbyteSliceAsUint64Slice(slice)\n\t\t})\n\t})\n}\n\nfunc TestByteSliceAsInterval16Slice(t *testing.T) {\n\tt.Run(\"valid slice\", func(t *testing.T) {\n\t\texpectedSize := 2\n\t\tslice := make([]byte, 8)\n\t\tbinary.LittleEndian.PutUint16(slice, 10)\n\t\tbinary.LittleEndian.PutUint16(slice[2:], 2)\n\t\tbinary.LittleEndian.PutUint16(slice[4:], 20)\n\t\tbinary.LittleEndian.PutUint16(slice[6:], 2)\n\n\t\tintervalSlice := byteSliceAsInterval16Slice(slice)\n\n\t\tassert.Equal(t, expectedSize, len(intervalSlice))\n\t\tassert.Equal(t, expectedSize, cap(intervalSlice))\n\n\t\ti1 := newInterval16Range(10, 12)\n\t\ti2 := newInterval16Range(20, 22)\n\n\t\tassert.False(t, intervalSlice[0] != i1 || intervalSlice[1] != i2)\n\t})\n\n\tt.Run(\"empty slice\", func(t *testing.T) {\n\t\tslice := make([]byte, 0, 0)\n\t\tintervalSlice := byteSliceAsInterval16Slice(slice)\n\n\t\tassert.Equal(t, 0, len(intervalSlice))\n\t\tassert.Equal(t, 0, cap(intervalSlice))\n\t})\n\n\tt.Run(\"invalid slice length\", func(t *testing.T) {\n\t\tslice := make([]byte, 1, 1)\n\n\t\tassert.Panics(t, func() {\n\t\t\tbyteSliceAsInterval16Slice(slice)\n\t\t})\n\t})\n}\n\nfunc TestBitmap_FromBuffer(t *testing.T) {\n\tt.Run(\"empty bitmap\", func(t *testing.T) {\n\t\trb := NewBitmap()\n\n\t\tbuf := &bytes.Buffer{}\n\t\t_, err := rb.WriteTo(buf)\n\n\t\trequire.NoError(t, err)\n\t\tassert.EqualValues(t, buf.Len(), rb.GetSerializedSizeInBytes())\n\n\t\tnewRb := NewBitmap()\n\t\tnewRb.FromBuffer(buf.Bytes())\n\n\t\trequire.NoError(t, err)\n\t\tassert.True(t, rb.Equals(newRb))\n\t})\n\n\tt.Run(\"basic bitmap of 7 elements\", func(t *testing.T) {\n\t\trb := BitmapOf(1, 2, 3, 4, 5, 100, 1000)\n\n\t\tbuf := &bytes.Buffer{}\n\t\t_, err := rb.WriteTo(buf)\n\n\t\trequire.NoError(t, err)\n\n\t\tnewRb := NewBitmap()\n\t\t_, err = newRb.FromBuffer(buf.Bytes())\n\n\t\trequire.NoError(t, err)\n\t\tassert.True(t, rb.Equals(newRb))\n\t})\n\n\tt.Run(\"bitmap with runs\", func(t *testing.T) {\n\t\tfile := \"testdata/bitmapwithruns.bin\"\n\n\t\tbuf, err := ioutil.ReadFile(file)\n\t\tif err != nil {\n\t\t\tfmt.Fprintf(os.Stderr, \"\\n\\nIMPORTANT: For testing file IO, the roaring library requires disk access.\\nWe omit some tests for now.\\n\\n\")\n\t\t\treturn\n\t\t}\n\n\t\trb := NewBitmap()\n\t\t_, err = rb.FromBuffer(buf)\n\n\t\trequire.NoError(t, err)\n\t\tassert.EqualValues(t, 3, rb.Stats().RunContainers)\n\t\tassert.EqualValues(t, 11, rb.Stats().Containers)\n\t})\n\n\tt.Run(\"bitmap without runs\", func(t *testing.T) {\n\t\tfn := \"testdata/bitmapwithruns.bin\"\n\t\tbuf, err := ioutil.ReadFile(fn)\n\n\t\tif err != nil {\n\t\t\tfmt.Fprintf(os.Stderr, \"\\n\\nIMPORTANT: For testing file IO, the roaring library requires disk access.\\nWe omit some tests for now.\\n\\n\")\n\t\t\treturn\n\t\t}\n\n\t\trb := NewBitmap()\n\t\t_, err = rb.FromBuffer(buf)\n\n\t\trequire.NoError(t, err)\n\t})\n\n\t// all3.classic somehow created by other tests.\n\tt.Run(\"all3.classic bitmap\", func(t *testing.T) {\n\t\tfile := \"testdata/all3.classic\"\n\t\tbuf, err := ioutil.ReadFile(file)\n\n\t\tif err != nil {\n\t\t\tfmt.Fprintf(os.Stderr, \"\\n\\nIMPORTANT: For testing file IO, the roaring library requires disk access.\\nWe omit some tests for now.\\n\\n\")\n\t\t\treturn\n\t\t}\n\n\t\trb := NewBitmap()\n\t\t_, err = rb.FromBuffer(buf)\n\n\t\trequire.NoError(t, err)\n\t})\n\n\tt.Run(\"testdata/bitmapwithruns.bin bitmap Ops\", func(t *testing.T) {\n\t\tfile := \"testdata/bitmapwithruns.bin\"\n\t\tbuf, err := ioutil.ReadFile(file)\n\n\t\tif err != nil {\n\t\t\tfmt.Fprintf(os.Stderr, \"\\n\\nIMPORTANT: For testing file IO, the roaring library requires disk access.\\nWe omit some tests for now.\\n\\n\")\n\t\t\treturn\n\t\t}\n\n\t\tempt := NewBitmap()\n\n\t\trb1 := NewBitmap()\n\t\t_, err = rb1.FromBuffer(buf)\n\n\t\trequire.NoError(t, err)\n\n\t\trb2 := NewBitmap()\n\t\t_, err = rb2.FromBuffer(buf)\n\n\t\trequire.NoError(t, err)\n\n\t\trbor := Or(rb1, rb2)\n\t\trbfastor := FastOr(rb1, rb2)\n\t\trband := And(rb1, rb2)\n\t\trbxor := Xor(rb1, rb2)\n\t\trbandnot := AndNot(rb1, rb2)\n\n\t\tassert.True(t, rbor.Equals(rb1))\n\t\tassert.True(t, rbfastor.Equals(rbor))\n\t\tassert.True(t, rband.Equals(rb1))\n\t\tassert.True(t, rbxor.Equals(empt))\n\t\tassert.True(t, rbandnot.Equals(empt))\n\t})\n\n\tt.Run(\"marking all containers as requiring COW\", func(t *testing.T) {\n\t\tfile := \"testdata/bitmapwithruns.bin\"\n\t\tbuf, err := ioutil.ReadFile(file)\n\n\t\tif err != nil {\n\t\t\tfmt.Fprintf(os.Stderr, \"\\n\\nIMPORTANT: For testing file IO, the roaring library requires disk access.\\nWe omit some tests for now.\\n\\n\")\n\t\t\treturn\n\t\t}\n\n\t\trb := NewBitmap()\n\t\t_, err = rb.FromBuffer(buf)\n\n\t\trequire.NoError(t, err)\n\n\t\tfor i, cow := range rb.highlowcontainer.needCopyOnWrite {\n\t\t\tassert.Truef(t, cow, \"Container at pos %d was not marked as needs-copy-on-write\", i)\n\t\t}\n\t})\n}\n\nfunc TestSerializationCrashers(t *testing.T) {\n\tcrashers, err := filepath.Glob(\"testdata/crash*\")\n\n\tif err != nil {\n\t\tfmt.Fprintf(os.Stderr, \"\\n\\nIMPORTANT: For testing file IO, the roaring library requires disk access.\\nWe omit some tests for now.\\n\\n\")\n\t\treturn\n\t}\n\n\tfor _, crasher := range crashers {\n\t\tdata, err := ioutil.ReadFile(crasher)\n\t\tif err != nil {\n\t\t\tfmt.Fprintf(os.Stderr, \"\\n\\nIMPORTANT: For testing file IO, the roaring library requires disk access.\\nWe omit some tests for now.\\n\\n\")\n\t\t\treturn\n\t\t}\n\n\t\t// take a copy in case the stream is modified during unpacking attempt\n\t\torig := make([]byte, len(data))\n\t\tcopy(orig, data)\n\n\t\t_, err = NewBitmap().FromBuffer(data)\n\t\tassert.Error(t, err)\n\n\t\t// reset for next one\n\t\tcopy(data, orig)\n\t\t_, err = NewBitmap().ReadFrom(bytes.NewReader(data))\n\n\t\tassert.Error(t, err)\n\t}\n}\n\nfunc TestIssue396(t *testing.T) {\n\tid := uint64(100000)\n\tbitmap := NewBitmap()\n\tfor i := uint64(0); i < id; i++ {\n\t\tif i%2 == 0 {\n\t\t\tbitmap.Add(uint32(i))\n\t\t}\n\t}\n\tbitmapBytes, err := bitmap.MarshalBinary()\n\trequire.Nil(t, err)\n\n\tbitmapUnmarshalled := NewBitmap()\n\terr = bitmapUnmarshalled.UnmarshalBinary(bitmapBytes)\n\trequire.Nil(t, err)\n\tassert.True(t, bitmap.Equals(bitmapUnmarshalled))\n\tbitmapUnmarshalled = bitmapUnmarshalled.Clone()\n\tassert.True(t, bitmap.Equals(bitmapUnmarshalled))\n}\n\nfunc TestBitmapFromBufferCOW(t *testing.T) {\n\trbbogus := NewBitmap()\n\trbbogus.Add(100)\n\trbbogus.Add(100000)\n\trb1 := NewBitmap()\n\trb1.Add(1)\n\tbuf1 := &bytes.Buffer{}\n\trb1.WriteTo(buf1)\n\trb2 := NewBitmap()\n\trb2.Add(1000000)\n\tbuf2 := &bytes.Buffer{}\n\trb2.WriteTo(buf2)\n\tnewRb1 := NewBitmap()\n\tnewRb1.FromBuffer(buf1.Bytes())\n\tnewRb2 := NewBitmap()\n\tnewRb2.FromBuffer(buf2.Bytes())\n\trbor1 := Or(newRb1, newRb2)\n\trbor2 := rbor1\n\trbor3 := Or(newRb1, newRb2)\n\trbor1.CloneCopyOnWriteContainers()\n\trbor2.CloneCopyOnWriteContainers()\n\trbor3.CloneCopyOnWriteContainers()\n\tbuf1.Reset()\n\tbuf2.Reset()\n\trbbogus.WriteTo(buf1)\n\trbbogus.WriteTo(buf2)\n\trbexpected := NewBitmap()\n\trbexpected.Add(1)\n\trbexpected.Add(1000000)\n\n\tassert.True(t, rbexpected.Equals(rbor2))\n\tassert.True(t, rbexpected.Equals(rbor3))\n}\n\nfunc TestHoldReference(t *testing.T) {\n\tt.Run(\"Test Hold Reference\", func(t *testing.T) {\n\t\trb := New()\n\t\tbuf := &bytes.Buffer{}\n\n\t\tfor i := uint32(0); i < 650; i++ {\n\t\t\trb.Add(i)\n\t\t}\n\n\t\t_, err := rb.WriteTo(buf)\n\t\trequire.NoError(t, err)\n\n\t\tnb := New()\n\t\tdata := buf.Bytes()\n\t\t_, err = nb.ReadFrom(bytes.NewReader(data))\n\n\t\trequire.NoError(t, err)\n\n\t\tbuf = nil\n\t\trb = nil\n\t\tdata = nil\n\n\t\truntime.GC()\n\n\t\titerator := nb.Iterator()\n\t\ti := uint32(0)\n\n\t\tfor iterator.HasNext() {\n\t\t\tv := iterator.Next()\n\n\t\t\tif v != i {\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tassert.Equal(t, i, v)\n\t\t\ti++\n\t\t}\n\t})\n}\n\nfunc BenchmarkUnserializeReadFrom(b *testing.B) {\n\tfor _, size := range []uint32{650, 6500, 65000, 650000, 6500000} {\n\t\trb := New()\n\t\tbuf := &bytes.Buffer{}\n\n\t\tfor i := uint32(0); i < size; i++ {\n\t\t\trb.Add(i)\n\t\t}\n\n\t\t_, err := rb.WriteTo(buf)\n\n\t\tif err != nil {\n\t\t\tb.Fatalf(\"Unexpected error occurs: %v\", err)\n\t\t}\n\n\t\tb.Run(fmt.Sprintf(\"ReadFrom-%d\", size), func(b *testing.B) {\n\t\t\tb.ReportAllocs()\n\t\t\tb.StartTimer()\n\n\t\t\tfor n := 0; n < b.N; n++ {\n\t\t\t\treader := bytes.NewReader(buf.Bytes())\n\t\t\t\tnb := New()\n\n\t\t\t\tif _, err := nb.ReadFrom(reader); err != nil {\n\t\t\t\t\tb.Fatalf(\"Unexpected error occurs: %v\", err)\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tb.StopTimer()\n\t\t})\n\t}\n}\n\nfunc BenchmarkUnserializeFromBuffer(b *testing.B) {\n\tfor _, size := range []uint32{650, 6500, 65000, 650000, 6500000} {\n\t\trb := New()\n\t\tbuf := &bytes.Buffer{}\n\n\t\tfor i := uint32(0); i < size; i++ {\n\t\t\trb.Add(i)\n\t\t}\n\n\t\t_, err := rb.WriteTo(buf)\n\n\t\tif err != nil {\n\t\t\tb.Fatalf(\"Unexpected error occurs: %v\", err)\n\t\t}\n\n\t\tb.Run(fmt.Sprintf(\"FromBuffer-%d\", size), func(b *testing.B) {\n\t\t\tb.ReportAllocs()\n\t\t\tb.StartTimer()\n\n\t\t\tfor n := 0; n < b.N; n++ {\n\t\t\t\tnb := New()\n\n\t\t\t\tif _, err := nb.FromBuffer(buf.Bytes()); err != nil {\n\t\t\t\t\tb.Fatalf(\"Unexpected error occurs: %v\", err)\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tb.StopTimer()\n\t\t})\n\t}\n}\n"
        },
        {
          "name": "serializationfuzz.go",
          "type": "blob",
          "size": 0.3701171875,
          "content": "//go:build gofuzz\n// +build gofuzz\n\npackage roaring\n\nimport \"bytes\"\n\nfunc FuzzSerializationStream(data []byte) int {\n\tnewrb := NewBitmap()\n\tif _, err := newrb.ReadFrom(bytes.NewReader(data)); err != nil {\n\t\treturn 0\n\t}\n\treturn 1\n}\n\nfunc FuzzSerializationBuffer(data []byte) int {\n\tnewrb := NewBitmap()\n\tif _, err := newrb.FromBuffer(data); err != nil {\n\t\treturn 0\n\t}\n\treturn 1\n}\n"
        },
        {
          "name": "setutil.go",
          "type": "blob",
          "size": 12.52734375,
          "content": "package roaring\n\nfunc difference(set1 []uint16, set2 []uint16, buffer []uint16) int {\n\tif len(set2) == 0 {\n\t\tbuffer = buffer[:len(set1)]\n\t\tcopy(buffer, set1)\n\t\treturn len(set1)\n\t}\n\tif len(set1) == 0 {\n\t\treturn 0\n\t}\n\tpos := 0\n\tk1 := 0\n\tk2 := 0\n\tbuffer = buffer[:cap(buffer)]\n\ts1 := set1[k1]\n\ts2 := set2[k2]\n\tfor {\n\t\tif s1 < s2 {\n\t\t\tbuffer[pos] = s1\n\t\t\tpos++\n\t\t\tk1++\n\t\t\tif k1 >= len(set1) {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\ts1 = set1[k1]\n\t\t} else if s1 == s2 {\n\t\t\tk1++\n\t\t\tk2++\n\t\t\tif k1 >= len(set1) {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\ts1 = set1[k1]\n\t\t\tif k2 >= len(set2) {\n\t\t\t\tfor ; k1 < len(set1); k1++ {\n\t\t\t\t\tbuffer[pos] = set1[k1]\n\t\t\t\t\tpos++\n\t\t\t\t}\n\t\t\t\tbreak\n\t\t\t}\n\t\t\ts2 = set2[k2]\n\t\t} else { // if (val1>val2)\n\t\t\tk2++\n\t\t\tif k2 >= len(set2) {\n\t\t\t\tfor ; k1 < len(set1); k1++ {\n\t\t\t\t\tbuffer[pos] = set1[k1]\n\t\t\t\t\tpos++\n\t\t\t\t}\n\t\t\t\tbreak\n\t\t\t}\n\t\t\ts2 = set2[k2]\n\t\t}\n\t}\n\treturn pos\n}\n\nfunc exclusiveUnion2by2(set1 []uint16, set2 []uint16, buffer []uint16) int {\n\tif 0 == len(set2) {\n\t\tbuffer = buffer[:len(set1)]\n\t\tcopy(buffer, set1[:])\n\t\treturn len(set1)\n\t}\n\tif 0 == len(set1) {\n\t\tbuffer = buffer[:len(set2)]\n\t\tcopy(buffer, set2[:])\n\t\treturn len(set2)\n\t}\n\tpos := 0\n\tk1 := 0\n\tk2 := 0\n\ts1 := set1[k1]\n\ts2 := set2[k2]\n\tbuffer = buffer[:cap(buffer)]\n\tfor {\n\t\tif s1 < s2 {\n\t\t\tbuffer[pos] = s1\n\t\t\tpos++\n\t\t\tk1++\n\t\t\tif k1 >= len(set1) {\n\t\t\t\tfor ; k2 < len(set2); k2++ {\n\t\t\t\t\tbuffer[pos] = set2[k2]\n\t\t\t\t\tpos++\n\t\t\t\t}\n\t\t\t\tbreak\n\t\t\t}\n\t\t\ts1 = set1[k1]\n\t\t} else if s1 == s2 {\n\t\t\tk1++\n\t\t\tk2++\n\t\t\tif k1 >= len(set1) {\n\t\t\t\tfor ; k2 < len(set2); k2++ {\n\t\t\t\t\tbuffer[pos] = set2[k2]\n\t\t\t\t\tpos++\n\t\t\t\t}\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tif k2 >= len(set2) {\n\t\t\t\tfor ; k1 < len(set1); k1++ {\n\t\t\t\t\tbuffer[pos] = set1[k1]\n\t\t\t\t\tpos++\n\t\t\t\t}\n\t\t\t\tbreak\n\t\t\t}\n\t\t\ts1 = set1[k1]\n\t\t\ts2 = set2[k2]\n\t\t} else { // if (val1>val2)\n\t\t\tbuffer[pos] = s2\n\t\t\tpos++\n\t\t\tk2++\n\t\t\tif k2 >= len(set2) {\n\t\t\t\tfor ; k1 < len(set1); k1++ {\n\t\t\t\t\tbuffer[pos] = set1[k1]\n\t\t\t\t\tpos++\n\t\t\t\t}\n\t\t\t\tbreak\n\t\t\t}\n\t\t\ts2 = set2[k2]\n\t\t}\n\t}\n\treturn pos\n}\n\n// union2by2Cardinality computes the cardinality of the union\nfunc union2by2Cardinality(set1 []uint16, set2 []uint16) int {\n\tpos := 0\n\tk1 := 0\n\tk2 := 0\n\tif 0 == len(set2) {\n\t\treturn len(set1)\n\t}\n\tif 0 == len(set1) {\n\t\treturn len(set2)\n\t}\n\ts1 := set1[k1]\n\ts2 := set2[k2]\n\tfor {\n\t\tif s1 < s2 {\n\t\t\tpos++\n\t\t\tk1++\n\t\t\tif k1 >= len(set1) {\n\t\t\t\tpos += len(set2) - k2\n\t\t\t\tbreak\n\t\t\t}\n\t\t\ts1 = set1[k1]\n\t\t} else if s1 == s2 {\n\t\t\tpos++\n\t\t\tk1++\n\t\t\tk2++\n\t\t\tif k1 >= len(set1) {\n\t\t\t\tpos += len(set2) - k2\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tif k2 >= len(set2) {\n\t\t\t\tpos += len(set1) - k1\n\t\t\t\tbreak\n\t\t\t}\n\t\t\ts1 = set1[k1]\n\t\t\ts2 = set2[k2]\n\t\t} else { // if (set1[k1]>set2[k2])\n\t\t\tpos++\n\t\t\tk2++\n\t\t\tif k2 >= len(set2) {\n\t\t\t\tpos += len(set1) - k1\n\t\t\t\tbreak\n\t\t\t}\n\t\t\ts2 = set2[k2]\n\t\t}\n\t}\n\treturn pos\n}\n\nfunc intersection2by2(\n\tset1 []uint16,\n\tset2 []uint16,\n\tbuffer []uint16,\n) int {\n\tif len(set1)*64 < len(set2) {\n\t\treturn onesidedgallopingintersect2by2(set1, set2, buffer)\n\t} else if len(set2)*64 < len(set1) {\n\t\treturn onesidedgallopingintersect2by2(set2, set1, buffer)\n\t} else {\n\t\treturn localintersect2by2(set1, set2, buffer)\n\t}\n}\n\n// intersection2by2Cardinality computes the cardinality of the intersection\nfunc intersection2by2Cardinality(\n\tset1 []uint16,\n\tset2 []uint16,\n) int {\n\tif len(set1)*64 < len(set2) {\n\t\treturn onesidedgallopingintersect2by2Cardinality(set1, set2)\n\t} else if len(set2)*64 < len(set1) {\n\t\treturn onesidedgallopingintersect2by2Cardinality(set2, set1)\n\t} else {\n\t\treturn localintersect2by2Cardinality(set1, set2)\n\t}\n}\n\n// intersects2by2 computes whether the two sets intersect\nfunc intersects2by2(\n\tset1 []uint16,\n\tset2 []uint16,\n) bool {\n\t// could be optimized if one set is much larger than the other one\n\tif (len(set1) == 0) || (len(set2) == 0) {\n\t\treturn false\n\t}\n\tindex1 := 0\n\tindex2 := 0\n\tvalue1 := set1[index1]\n\tvalue2 := set2[index2]\nmainwhile:\n\tfor {\n\n\t\tif value2 < value1 {\n\t\t\tfor {\n\t\t\t\tindex2++\n\t\t\t\tif index2 == len(set2) {\n\t\t\t\t\tbreak mainwhile\n\t\t\t\t}\n\t\t\t\tvalue2 = set2[index2]\n\t\t\t\tif value2 >= value1 {\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif value1 < value2 {\n\t\t\tfor {\n\t\t\t\tindex1++\n\t\t\t\tif index1 == len(set1) {\n\t\t\t\t\tbreak mainwhile\n\t\t\t\t}\n\t\t\t\tvalue1 = set1[index1]\n\t\t\t\tif value1 >= value2 {\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\t// (set2[k2] == set1[k1])\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\nfunc localintersect2by2(\n\tset1 []uint16,\n\tset2 []uint16,\n\tbuffer []uint16,\n) int {\n\tif (len(set1) == 0) || (len(set2) == 0) {\n\t\treturn 0\n\t}\n\tk1 := 0\n\tk2 := 0\n\tpos := 0\n\tbuffer = buffer[:cap(buffer)]\n\ts1 := set1[k1]\n\ts2 := set2[k2]\nmainwhile:\n\tfor {\n\t\tif s2 < s1 {\n\t\t\tfor {\n\t\t\t\tk2++\n\t\t\t\tif k2 == len(set2) {\n\t\t\t\t\tbreak mainwhile\n\t\t\t\t}\n\t\t\t\ts2 = set2[k2]\n\t\t\t\tif s2 >= s1 {\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif s1 < s2 {\n\t\t\tfor {\n\t\t\t\tk1++\n\t\t\t\tif k1 == len(set1) {\n\t\t\t\t\tbreak mainwhile\n\t\t\t\t}\n\t\t\t\ts1 = set1[k1]\n\t\t\t\tif s1 >= s2 {\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\t// (set2[k2] == set1[k1])\n\t\t\tbuffer[pos] = s1\n\t\t\tpos++\n\t\t\tk1++\n\t\t\tif k1 == len(set1) {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\ts1 = set1[k1]\n\t\t\tk2++\n\t\t\tif k2 == len(set2) {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\ts2 = set2[k2]\n\t\t}\n\t}\n\treturn pos\n}\n\n// / localintersect2by2Cardinality computes the cardinality of the intersection\nfunc localintersect2by2Cardinality(\n\tset1 []uint16,\n\tset2 []uint16,\n) int {\n\tif (len(set1) == 0) || (len(set2) == 0) {\n\t\treturn 0\n\t}\n\tindex1 := 0\n\tindex2 := 0\n\tpos := 0\n\tvalue1 := set1[index1]\n\tvalue2 := set2[index2]\nmainwhile:\n\tfor {\n\t\tif value2 < value1 {\n\t\t\tfor {\n\t\t\t\tindex2++\n\t\t\t\tif index2 == len(set2) {\n\t\t\t\t\tbreak mainwhile\n\t\t\t\t}\n\t\t\t\tvalue2 = set2[index2]\n\t\t\t\tif value2 >= value1 {\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif value1 < value2 {\n\t\t\tfor {\n\t\t\t\tindex1++\n\t\t\t\tif index1 == len(set1) {\n\t\t\t\t\tbreak mainwhile\n\t\t\t\t}\n\t\t\t\tvalue1 = set1[index1]\n\t\t\t\tif value1 >= value2 {\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\t// (set2[k2] == set1[k1])\n\t\t\tpos++\n\t\t\tindex1++\n\t\t\tif index1 == len(set1) {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tvalue1 = set1[index1]\n\t\t\tindex2++\n\t\t\tif index2 == len(set2) {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tvalue2 = set2[index2]\n\t\t}\n\t}\n\treturn pos\n}\n\nfunc advanceUntil(\n\tarray []uint16,\n\tpos int,\n\tlength int,\n\tmin uint16,\n) int {\n\tlower := pos + 1\n\n\tif lower >= length || array[lower] >= min {\n\t\treturn lower\n\t}\n\n\tspansize := 1\n\n\tfor lower+spansize < length && array[lower+spansize] < min {\n\t\tspansize *= 2\n\t}\n\tvar upper int\n\tif lower+spansize < length {\n\t\tupper = lower + spansize\n\t} else {\n\t\tupper = length - 1\n\t}\n\n\tif array[upper] == min {\n\t\treturn upper\n\t}\n\n\tif array[upper] < min {\n\t\t// means\n\t\t// array\n\t\t// has no\n\t\t// item\n\t\t// >= min\n\t\t// pos = array.length;\n\t\treturn length\n\t}\n\n\t// we know that the next-smallest span was too small\n\tlower += (spansize >> 1)\n\n\tmid := 0\n\tfor lower+1 != upper {\n\t\tmid = (lower + upper) >> 1\n\t\tif array[mid] == min {\n\t\t\treturn mid\n\t\t} else if array[mid] < min {\n\t\t\tlower = mid\n\t\t} else {\n\t\t\tupper = mid\n\t\t}\n\t}\n\treturn upper\n}\n\nfunc onesidedgallopingintersect2by2(\n\tsmallset []uint16,\n\tlargeset []uint16,\n\tbuffer []uint16,\n) int {\n\tif 0 == len(smallset) {\n\t\treturn 0\n\t}\n\tbuffer = buffer[:cap(buffer)]\n\tk1 := 0\n\tk2 := 0\n\tpos := 0\n\ts1 := largeset[k1]\n\ts2 := smallset[k2]\nmainwhile:\n\n\tfor {\n\t\tif s1 < s2 {\n\t\t\tk1 = advanceUntil(largeset, k1, len(largeset), s2)\n\t\t\tif k1 == len(largeset) {\n\t\t\t\tbreak mainwhile\n\t\t\t}\n\t\t\ts1 = largeset[k1]\n\t\t}\n\t\tif s2 < s1 {\n\t\t\tk2++\n\t\t\tif k2 == len(smallset) {\n\t\t\t\tbreak mainwhile\n\t\t\t}\n\t\t\ts2 = smallset[k2]\n\t\t} else {\n\n\t\t\tbuffer[pos] = s2\n\t\t\tpos++\n\t\t\tk2++\n\t\t\tif k2 == len(smallset) {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\ts2 = smallset[k2]\n\t\t\tk1 = advanceUntil(largeset, k1, len(largeset), s2)\n\t\t\tif k1 == len(largeset) {\n\t\t\t\tbreak mainwhile\n\t\t\t}\n\t\t\ts1 = largeset[k1]\n\t\t}\n\n\t}\n\treturn pos\n}\n\nfunc onesidedgallopingintersect2by2Cardinality(\n\tsmallset []uint16,\n\tlargeset []uint16,\n) int {\n\tif 0 == len(smallset) {\n\t\treturn 0\n\t}\n\tk1 := 0\n\tk2 := 0\n\tpos := 0\n\ts1 := largeset[k1]\n\ts2 := smallset[k2]\nmainwhile:\n\n\tfor {\n\t\tif s1 < s2 {\n\t\t\tk1 = advanceUntil(largeset, k1, len(largeset), s2)\n\t\t\tif k1 == len(largeset) {\n\t\t\t\tbreak mainwhile\n\t\t\t}\n\t\t\ts1 = largeset[k1]\n\t\t}\n\t\tif s2 < s1 {\n\t\t\tk2++\n\t\t\tif k2 == len(smallset) {\n\t\t\t\tbreak mainwhile\n\t\t\t}\n\t\t\ts2 = smallset[k2]\n\t\t} else {\n\n\t\t\tpos++\n\t\t\tk2++\n\t\t\tif k2 == len(smallset) {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\ts2 = smallset[k2]\n\t\t\tk1 = advanceUntil(largeset, k1, len(largeset), s2)\n\t\t\tif k1 == len(largeset) {\n\t\t\t\tbreak mainwhile\n\t\t\t}\n\t\t\ts1 = largeset[k1]\n\t\t}\n\n\t}\n\treturn pos\n}\n\nfunc binarySearch(array []uint16, ikey uint16) int {\n\tlow := 0\n\thigh := len(array) - 1\n\tfor low+16 <= high {\n\t\tmiddleIndex := int(uint32(low+high) >> 1)\n\t\tmiddleValue := array[middleIndex]\n\t\tif middleValue < ikey {\n\t\t\tlow = middleIndex + 1\n\t\t} else if middleValue > ikey {\n\t\t\thigh = middleIndex - 1\n\t\t} else {\n\t\t\treturn middleIndex\n\t\t}\n\t}\n\tfor ; low <= high; low++ {\n\t\tval := array[low]\n\t\tif val >= ikey {\n\t\t\tif val == ikey {\n\t\t\t\treturn low\n\t\t\t}\n\t\t\tbreak\n\t\t}\n\t}\n\treturn -(low + 1)\n}\n\n// searchResult provides information about a search request.\n// The values will depend on the context of the search\ntype searchResult struct {\n\tvalue      uint16\n\tindex      int\n\texactMatch bool\n}\n\n// notFound returns a bool depending the search context\n// For cases `previousValue` and `nextValue` if target is present in the slice\n// this function will return `true` otherwise `false`\n// For `nextAbsentValue` and `previousAbsentValue` this will only return `False`\nfunc (sr *searchResult) notFound() bool {\n\treturn !sr.exactMatch\n}\n\n// outOfBounds indicates whether the target was outside the lower and upper bounds of the container\nfunc (sr *searchResult) outOfBounds() bool {\n\treturn sr.index <= -1\n}\n\n// binarySearchUntil is a helper function around binarySearchUntilWithBounds\n// The user does not have to pass in the lower and upper bound\n// The lower bound is taken to be `0` and the upper bound `len(array)-1`\nfunc binarySearchUntil(array []uint16, target uint16) searchResult {\n\treturn binarySearchUntilWithBounds(array, target, 0, len(array)-1)\n}\n\n// binarySearchUntilWithBounds returns a `searchResult`.\n// If an exact match is found the `searchResult{target, <index>, true}` will be returned, where `<index>` is\n// `target`s index in `array`, and `result.notFound()` evaluates to `false`.\n// If a match is not found, but `target` was in-bounds then the result.index will be the closest smaller value\n// Example: [ 8,9,11,12] if the target was 10, then `searchResult{9, 1, false}` will be returned.\n// If `target` was out of bounds `searchResult{0, -1, false}` will be returned.\nfunc binarySearchUntilWithBounds(array []uint16, target uint16, lowIndex int, maxIndex int) searchResult {\n\thighIndex := maxIndex\n\n\tclosestIndex := -1\n\n\tif target < array[lowIndex] {\n\t\treturn searchResult{0, closestIndex, false}\n\t}\n\n\tif target > array[maxIndex] {\n\t\treturn searchResult{0, len(array), false}\n\t}\n\n\tfor lowIndex <= highIndex {\n\t\tmiddleIndex := (lowIndex + highIndex) / 2\n\t\tmiddleValue := array[middleIndex]\n\n\t\tif middleValue == target {\n\t\t\treturn searchResult{middleValue, middleIndex, true}\n\t\t}\n\n\t\tif target < middleValue {\n\n\t\t\tif middleIndex > 0 && target > array[middleIndex-1] {\n\t\t\t\treturn searchResult{array[middleIndex-1], middleIndex - 1, false}\n\t\t\t}\n\n\t\t\thighIndex = middleIndex\n\t\t} else {\n\t\t\tif middleIndex < maxIndex && target < array[middleIndex+1] {\n\t\t\t\treturn searchResult{middleValue, middleIndex, false}\n\t\t\t}\n\t\t\tlowIndex = middleIndex + 1\n\t\t}\n\n\t}\n\n\treturn searchResult{array[closestIndex], closestIndex, false}\n}\n\n// binarySearchPast is a wrapper around binarySearchPastWithBounds\n// The user does not have to pass in the lower and upper bound\n// The lower bound is taken to be `0` and the upper bound `len(array)-1`\nfunc binarySearchPast(array []uint16, target uint16) searchResult {\n\treturn binarySearchPastWithBounds(array, target, 0, len(array)-1)\n}\n\n// binarySearchPastWithBounds looks for the smallest value larger than or equal to `target`\n// If `target` is out of bounds a `searchResult` indicating out of bounds is returned\n// `target` does not have to exist in the slice.\n//\n// Example:\n// Suppose the slice is [...10,13...] with `target` equal to 11\n// The searchResult will have searchResult.value = 13\nfunc binarySearchPastWithBounds(array []uint16, target uint16, lowIndex int, maxIndex int) searchResult {\n\thighIndex := maxIndex\n\n\tclosestIndex := -1\n\n\tif target < array[lowIndex] {\n\t\treturn searchResult{0, closestIndex, false}\n\t}\n\n\tif target > array[maxIndex] {\n\t\treturn searchResult{0, len(array), false}\n\t}\n\n\tfor lowIndex <= highIndex {\n\t\tmiddleIndex := (lowIndex + highIndex) / 2\n\t\tmiddleValue := array[middleIndex]\n\n\t\tif middleValue == target {\n\t\t\treturn searchResult{middleValue, middleIndex, true}\n\t\t}\n\n\t\tif target < middleValue {\n\n\t\t\tif middleIndex > 0 && target > array[middleIndex-1] {\n\t\t\t\treturn searchResult{array[middleIndex], middleIndex, false}\n\t\t\t}\n\n\t\t\thighIndex = middleIndex\n\t\t} else {\n\t\t\tif middleIndex < maxIndex && target < array[middleIndex+1] {\n\t\t\t\treturn searchResult{array[middleIndex+1], middleIndex + 1, false}\n\t\t\t}\n\t\t\tlowIndex = middleIndex + 1\n\t\t}\n\n\t}\n\n\treturn searchResult{array[closestIndex], closestIndex, false}\n}\n"
        },
        {
          "name": "setutil_arm64.go",
          "type": "blob",
          "size": 0.17578125,
          "content": "//go:build arm64 && !gccgo && !appengine\n// +build arm64,!gccgo,!appengine\n\npackage roaring\n\n//go:noescape\nfunc union2by2(set1 []uint16, set2 []uint16, buffer []uint16) (size int)\n"
        },
        {
          "name": "setutil_arm64.s",
          "type": "blob",
          "size": 3.6611328125,
          "content": "// +build arm64,!gccgo,!appengine\n\n#include \"textflag.h\"\n\n\n// This implements union2by2 using golang's version of arm64 assembly\n// The algorithm is very similar to the generic one,\n// but makes better use of arm64 features so is notably faster.\n// The basic algorithm structure is as follows:\n// 1. If either set is empty, copy the other set into the buffer and return the length\n// 2. Otherwise, load the first element of each set into a variable (s1 and s2).\n// 3. a. Compare the values of s1 and s2.\n // b. add the smaller one to the buffer.\n // c. perform a bounds check before incrementing.\n // If one set is finished, copy the rest of the other set over.\n // d. update s1 and or s2 to the next value, continue loop.\n //\n // Past the fact of the algorithm, this code makes use of several arm64 features\n // Condition Codes:\n // arm64's CMP operation sets 4 bits that can be used for branching,\n // rather than just true or false.\n // As a consequence, a single comparison gives enough information to distinguish the three cases\n //\n // Post-increment pointers after load/store:\n // Instructions like `MOVHU.P 2(R0), R6`\n // increment the register by a specified amount, in this example 2.\n // Because uint16's are exactly 2 bytes and the length of the slices\n // is part of the slice header,\n // there is no need to separately track the index into the slice.\n // Instead, the code can calculate the final read value and compare against that,\n // using the post-increment reads to move the pointers along.\n //\n // TODO: CALL out to memmove once the list is exhausted.\n // Right now it moves the necessary shorts so that the remaining count\n // is a multiple of 4 and then copies 64 bits at a time.\n\nTEXT ¬∑union2by2(SB), NOSPLIT, $0-80\n\t// R0, R1, and R2 for the pointers to the three slices\n\tMOVD set1+0(FP), R0\n\tMOVD set2+24(FP), R1\n\tMOVD buffer+48(FP), R2\n\n\t//R3 and R4 will be the values at which we will have finished reading set1 and set2.\n\t// R3 should be R0 + 2 * set1_len+8(FP)\n\tMOVD set1_len+8(FP), R3\n\tMOVD set2_len+32(FP), R4\n\n\tADD R3<<1, R0, R3\n\tADD R4<<1, R1, R4\n\n\n\t//Rather than counting the number of elements added separately\n\t//Save the starting register of buffer.\n\tMOVD buffer+48(FP), R5\n\n\t// set1 is empty, just flush set2\n\tCMP R0, R3\n\tBEQ flush_right\n\n\t// set2 is empty, just flush set1\n\tCMP R1, R4\n\tBEQ flush_left\n\n\t// R6, R7 are the working space for s1 and s2\n\tMOVD ZR, R6\n\tMOVD ZR, R7\n\n\tMOVHU.P 2(R0), R6\n\tMOVHU.P 2(R1), R7\nloop:\n\n\tCMP R6, R7\n\tBEQ pop_both // R6 == R7\n\tBLS pop_right // R6 > R7\n//pop_left: // R6 < R7\n\tMOVHU.P R6, 2(R2)\n\tCMP R0, R3\n\tBEQ pop_then_flush_right\n\tMOVHU.P 2(R0), R6\n\tJMP loop\npop_both:\n\tMOVHU.P R6, 2(R2) //could also use R7, since they are equal\n\tCMP R0, R3\n\tBEQ flush_right\n\tCMP R1, R4\n\tBEQ flush_left\n\tMOVHU.P 2(R0), R6\n\tMOVHU.P 2(R1), R7\n\tJMP loop\npop_right:\n\tMOVHU.P R7, 2(R2)\n\tCMP R1, R4\n\tBEQ pop_then_flush_left\n\tMOVHU.P 2(R1), R7\n\tJMP loop\n\npop_then_flush_right:\n\tMOVHU.P R7, 2(R2)\nflush_right:\n\tMOVD R1, R0\n\tMOVD R4, R3\n\tJMP flush_left\npop_then_flush_left:\n\tMOVHU.P R6, 2(R2)\nflush_left:\n\tCMP R0, R3\n\tBEQ return\n\t//figure out how many bytes to slough off. Must be a multiple of two\n\tSUB R0, R3, R4\n\tANDS $6, R4\n\tBEQ long_flush //handles the 0 mod 8 case\n\tSUBS $4, R4, R4 // since possible values are 2, 4, 6, this splits evenly\n\tBLT pop_single  // exactly the 2 case\n\tMOVW.P 4(R0), R6\n\tMOVW.P R6, 4(R2)\n\tBEQ long_flush // we're now aligned by 64 bits, as R4==4, otherwise 2 more\npop_single:\n\tMOVHU.P 2(R0), R6\n\tMOVHU.P R6, 2(R2)\nlong_flush:\n\t// at this point we know R3 - R0 is a multiple of 8.\n\tCMP R0, R3\n\tBEQ return\n\tMOVD.P 8(R0), R6\n\tMOVD.P R6, 8(R2)\n\tJMP long_flush\nreturn:\n\t// number of shorts written is (R5 - R2) >> 1\n\tSUB R5, R2\n\tLSR $1, R2, R2\n\tMOVD R2, size+72(FP)\n\tRET\n"
        },
        {
          "name": "setutil_generic.go",
          "type": "blob",
          "size": 1.103515625,
          "content": "//go:build !arm64 || gccgo || appengine\n// +build !arm64 gccgo appengine\n\npackage roaring\n\nfunc union2by2(set1 []uint16, set2 []uint16, buffer []uint16) int {\n\tpos := 0\n\tk1 := 0\n\tk2 := 0\n\tif 0 == len(set2) {\n\t\tbuffer = buffer[:len(set1)]\n\t\tcopy(buffer, set1[:])\n\t\treturn len(set1)\n\t}\n\tif 0 == len(set1) {\n\t\tbuffer = buffer[:len(set2)]\n\t\tcopy(buffer, set2[:])\n\t\treturn len(set2)\n\t}\n\ts1 := set1[k1]\n\ts2 := set2[k2]\n\tbuffer = buffer[:cap(buffer)]\n\tfor {\n\t\tif s1 < s2 {\n\t\t\tbuffer[pos] = s1\n\t\t\tpos++\n\t\t\tk1++\n\t\t\tif k1 >= len(set1) {\n\t\t\t\tcopy(buffer[pos:], set2[k2:])\n\t\t\t\tpos += len(set2) - k2\n\t\t\t\tbreak\n\t\t\t}\n\t\t\ts1 = set1[k1]\n\t\t} else if s1 == s2 {\n\t\t\tbuffer[pos] = s1\n\t\t\tpos++\n\t\t\tk1++\n\t\t\tk2++\n\t\t\tif k1 >= len(set1) {\n\t\t\t\tcopy(buffer[pos:], set2[k2:])\n\t\t\t\tpos += len(set2) - k2\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tif k2 >= len(set2) {\n\t\t\t\tcopy(buffer[pos:], set1[k1:])\n\t\t\t\tpos += len(set1) - k1\n\t\t\t\tbreak\n\t\t\t}\n\t\t\ts1 = set1[k1]\n\t\t\ts2 = set2[k2]\n\t\t} else { // if (set1[k1]>set2[k2])\n\t\t\tbuffer[pos] = s2\n\t\t\tpos++\n\t\t\tk2++\n\t\t\tif k2 >= len(set2) {\n\t\t\t\tcopy(buffer[pos:], set1[k1:])\n\t\t\t\tpos += len(set1) - k1\n\t\t\t\tbreak\n\t\t\t}\n\t\t\ts2 = set2[k2]\n\t\t}\n\t}\n\treturn pos\n}\n"
        },
        {
          "name": "setutil_test.go",
          "type": "blob",
          "size": 8.56640625,
          "content": "package roaring\n\n// to run just these tests: go test -run TestSetUtil*\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestSetUtilDifference(t *testing.T) {\n\tdata1 := []uint16{0, 1, 2, 3, 4, 9}\n\tdata2 := []uint16{2, 3, 4, 5, 8, 9, 11}\n\tresult := make([]uint16, 0, len(data1)+len(data2))\n\texpectedresult := []uint16{0, 1}\n\tnl := difference(data1, data2, result)\n\tresult = result[:nl]\n\n\tassert.Equal(t, expectedresult, result)\n\n\texpectedresult = []uint16{5, 8, 11}\n\tnl = difference(data2, data1, result)\n\tresult = result[:nl]\n\n\tassert.Equal(t, expectedresult, result)\n\n\t// empty set2\n\tdata2 = []uint16{}\n\texpectedresult = []uint16{0, 1, 2, 3, 4, 9}\n\tnl = difference(data1, data2, result)\n\tresult = result[:nl]\n\n\tassert.Equal(t, expectedresult, result)\n\n\t// empty set 1\n\tdata1 = []uint16{}\n\tdata2 = []uint16{2, 3, 4, 5, 8, 9, 11}\n\texpectedresult = []uint16{}\n\tnl = difference(data1, data2, result)\n\tresult = result[:nl]\n\n\tassert.Equal(t, expectedresult, result)\n}\n\nfunc TestSetUtilUnion(t *testing.T) {\n\tdata1 := []uint16{0, 1, 2, 3, 4, 9}\n\tdata2 := []uint16{2, 3, 4, 5, 8, 9, 11}\n\tresult := make([]uint16, 0, len(data1)+len(data2))\n\texpectedresult := []uint16{0, 1, 2, 3, 4, 5, 8, 9, 11}\n\tnl := union2by2(data1, data2, result)\n\tresult = result[:nl]\n\n\tassert.Equal(t, expectedresult, result)\n\n\tnl = union2by2(data2, data1, result)\n\tresult = result[:nl]\n\n\tassert.Equal(t, expectedresult, result)\n}\n\nfunc TestSetUtilExclusiveUnion(t *testing.T) {\n\tdata1 := []uint16{0, 1, 2, 3, 4, 9}\n\tdata2 := []uint16{2, 3, 4, 5, 8, 9, 11}\n\tresult := make([]uint16, 0, len(data1)+len(data2))\n\texpectedresult := []uint16{0, 1, 5, 8, 11}\n\tnl := exclusiveUnion2by2(data1, data2, result)\n\tresult = result[:nl]\n\n\tassert.Equal(t, expectedresult, result)\n\n\tnl = exclusiveUnion2by2(data2, data1, result)\n\tresult = result[:nl]\n\n\tassert.Equal(t, expectedresult, result)\n}\n\nfunc TestSetUtilIntersection(t *testing.T) {\n\tdata1 := []uint16{0, 1, 2, 3, 4, 9}\n\tdata2 := []uint16{2, 3, 4, 5, 8, 9, 11}\n\tresult := make([]uint16, 0, len(data1)+len(data2))\n\texpectedresult := []uint16{2, 3, 4, 9}\n\tnl := intersection2by2(data1, data2, result)\n\tresult = result[:nl]\n\tresult = result[:len(expectedresult)]\n\n\tassert.Equal(t, expectedresult, result)\n\n\tnl = intersection2by2(data2, data1, result)\n\tresult = result[:nl]\n\n\tassert.Equal(t, expectedresult, result)\n\n\tdata1 = []uint16{4}\n\tdata2 = make([]uint16, 10000)\n\n\tfor i := range data2 {\n\t\tdata2[i] = uint16(i)\n\t}\n\n\tresult = make([]uint16, 0, len(data1)+len(data2))\n\texpectedresult = data1\n\tnl = intersection2by2(data1, data2, result)\n\tresult = result[:nl]\n\n\tassert.Equal(t, expectedresult, result)\n\n\tnl = intersection2by2(data2, data1, result)\n\tresult = result[:nl]\n\n\tassert.Equal(t, expectedresult, result)\n}\n\nfunc TestSetUtilIntersection2(t *testing.T) {\n\tdata1 := []uint16{0, 2, 4, 6, 8, 10, 12, 14, 16, 18}\n\tdata2 := []uint16{0, 3, 6, 9, 12, 15, 18}\n\tresult := make([]uint16, 0, len(data1)+len(data2))\n\texpectedresult := []uint16{0, 6, 12, 18}\n\tnl := intersection2by2(data1, data2, result)\n\tresult = result[:nl]\n\tresult = result[:len(expectedresult)]\n\n\tassert.Equal(t, expectedresult, result)\n}\n\nfunc TestSetUtilBinarySearch(t *testing.T) {\n\tdata := make([]uint16, 256)\n\tfor i := range data {\n\t\tdata[i] = uint16(2 * i)\n\t}\n\tfor i := 0; i < 2*len(data); i++ {\n\t\tkey := uint16(i)\n\t\tloc := binarySearch(data, key)\n\t\tif (key & 1) == 0 {\n\t\t\tassert.Equal(t, int(key)/2, loc)\n\t\t} else {\n\t\t\tassert.Equal(t, -int(key)/2-2, loc)\n\t\t}\n\t}\n}\n\nfunc TestBinarySearchUntil(t *testing.T) {\n\ttype searchTest struct {\n\t\tname          string\n\t\ttargetSlice   []uint16\n\t\ttarget        uint16\n\t\texpectedValue uint16\n\t\tisExactMatch  bool\n\t\texpectedIndex int\n\t}\n\n\ttests := []searchTest{\n\t\t{\n\t\t\t\"matches\",\n\t\t\t[]uint16{0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 13, 14, 15, 16, 17},\n\t\t\t9, 9, true, 9,\n\t\t},\n\t\t{\n\t\t\t\"missing 12 with gap\",\n\t\t\t[]uint16{0, 1, 2, 3, 4, 5, 6, 13, 14, 15, 16, 17},\n\t\t\t12, 6, false, 6,\n\t\t},\n\t\t{\n\t\t\t\"missing 10 but close neighbors\",\n\t\t\t[]uint16{0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 12},\n\t\t\t10, 9, false, 9,\n\t\t},\n\t\t{\n\t\t\t\"missing close to beginning\",\n\t\t\t[]uint16{0, 2, 3, 4, 5, 6, 7, 8, 9, 11, 12},\n\t\t\t1, 0, false, 0,\n\t\t},\n\t\t{\n\t\t\t\"missing gap\",\n\t\t\t[]uint16{0, 1, 2, 3, 4, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17},\n\t\t\t6, 4, false, 4,\n\t\t},\n\t\t{\n\t\t\t\"out of bounds at beginning\",\n\t\t\t[]uint16{1, 2, 3, 4, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17},\n\t\t\t0, 0, false, -1,\n\t\t},\n\t\t{\n\t\t\t\"out of bounds at the end\",\n\t\t\t[]uint16{0, 1, 2, 3, 4, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17},\n\t\t\t100, 0, false, 15,\n\t\t},\n\t\t{\n\t\t\t\"missing alternating\",\n\t\t\t[]uint16{0, 2, 4, 6, 8, 10, 12, 14, 16, 18, 22, 24, 26},\n\t\t\t20, 18, false, 9,\n\t\t},\n\t}\n\n\tfor _, testCase := range tests {\n\t\tt.Run(testCase.name, func(t *testing.T) {\n\t\t\tresult := binarySearchUntil(testCase.targetSlice, testCase.target)\n\t\t\tassert.Equal(t, testCase.expectedIndex, result.index)\n\t\t\tassert.Equal(t, testCase.expectedIndex, result.index)\n\t\t\tassert.Equal(t, testCase.isExactMatch, result.exactMatch)\n\t\t})\n\t}\n}\n\nfunc TestBinarySearchPastWithBounds(t *testing.T) {\n\ttype searchTest struct {\n\t\tname          string\n\t\ttargetSlice   []uint16\n\t\ttarget        uint16\n\t\texpectedValue uint16\n\t\tisExactMatch  bool\n\t\texpectedIndex int\n\t\tlow           int\n\t\thigh          int\n\t}\n\n\ttests := []searchTest{\n\t\t{\n\t\t\t\"has match but not in range\",\n\t\t\t[]uint16{0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 13, 14, 15, 16, 17},\n\t\t\t9, 0, false, 15, 0, 4,\n\t\t},\n\t\t{\n\t\t\t\"matches\",\n\t\t\t[]uint16{0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 13, 14, 15, 16, 17},\n\t\t\t9, 9, true, 9, 0, 10,\n\t\t},\n\t\t{\n\t\t\t\"missing 10-12 full range\",\n\t\t\t[]uint16{0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 13, 14, 15, 16, 17},\n\t\t\t12, uint16(13), false, 10, 0, 14,\n\t\t},\n\t\t{\n\t\t\t\"has match but not in range\",\n\t\t\t[]uint16{0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 13, 14, 15, 16, 17},\n\t\t\t9, 0, false, 15, 0, 4,\n\t\t},\n\t\t{\n\t\t\t\"missing 12 with gap\",\n\t\t\t[]uint16{0, 1, 2, 3, 4, 5, 6, 13, 14, 15, 16, 17},\n\t\t\t12, 13, false, 7, 4, 11,\n\t\t},\n\t\t{\n\t\t\t\"missing 10 but close neighbors\",\n\t\t\t[]uint16{0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 12},\n\t\t\t10, 11, false, 10, 6, 11,\n\t\t},\n\t\t{\n\t\t\t\"missing 10 out of range\",\n\t\t\t[]uint16{0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 12},\n\t\t\t10, 0, false, 12, 0, 5,\n\t\t},\n\t}\n\n\tfor _, testCase := range tests {\n\t\tt.Run(testCase.name, func(t *testing.T) {\n\t\t\tresult := binarySearchPastWithBounds(testCase.targetSlice, testCase.target, testCase.low, testCase.high)\n\t\t\tassert.Equal(t, testCase.expectedIndex, result.index)\n\t\t\tassert.Equal(t, testCase.expectedValue, result.value)\n\t\t\tassert.Equal(t, testCase.isExactMatch, result.exactMatch)\n\t\t})\n\t}\n}\n\nfunc makeLargeSet(start int) []uint16 {\n\tdata := make([]uint16, 0, 256)\n\tfor i := 0; i < 256; i++ {\n\t\tdata = append(data, uint16(start+i))\n\t}\n\treturn data\n}\n\nfunc TestSetUtilIntersection2By2Cardinality(t *testing.T) {\n\ttype searchTest struct {\n\t\tname          string\n\t\tdata1         []uint16\n\t\tdata2         []uint16\n\t\texpectedValue int\n\t}\n\n\ttests := []searchTest{\n\t\t{\n\t\t\t\"cardinality 1 intersection\",\n\t\t\t[]uint16{0, 1, 2, 3, 4, 9},\n\t\t\t[]uint16{8, 9, 10, 11, 12},\n\t\t\t1,\n\t\t},\n\t\t{\n\t\t\t\"empty set\",\n\t\t\t[]uint16{},\n\t\t\t[]uint16{8, 9, 10, 11, 12},\n\t\t\t0,\n\t\t},\n\t\t{\n\t\t\t\"cardinality 0\",\n\t\t\t[]uint16{1},\n\t\t\t[]uint16{8, 9, 10, 11, 12},\n\t\t\t0,\n\t\t},\n\t\t{\n\t\t\t\"large first set - cardinality 0\",\n\t\t\tmakeLargeSet(1024),\n\t\t\t[]uint16{8, 9},\n\t\t\t0,\n\t\t},\n\t\t{\n\t\t\t\"large second set - cardinality 0\",\n\t\t\t[]uint16{8, 9},\n\t\t\tmakeLargeSet(1024),\n\t\t\t0,\n\t\t},\n\t\t{\n\t\t\t\"large first set - cardinality 2\",\n\t\t\tmakeLargeSet(0),\n\t\t\t[]uint16{8, 9},\n\t\t\t2,\n\t\t},\n\t\t{\n\t\t\t\"large second set - cardinality 2\",\n\t\t\t[]uint16{8, 9},\n\t\t\tmakeLargeSet(0),\n\t\t\t2,\n\t\t},\n\t}\n\n\tfor _, testCase := range tests {\n\t\tt.Run(testCase.name, func(t *testing.T) {\n\t\t\tresult := intersection2by2Cardinality(testCase.data1, testCase.data2)\n\t\t\tassert.Equal(t, result, testCase.expectedValue)\n\t\t})\n\t}\n}\n\nfunc TestSetUtilUnionBy2Cardinality(t *testing.T) {\n\ttype searchTest struct {\n\t\tname          string\n\t\tdata1         []uint16\n\t\tdata2         []uint16\n\t\texpectedValue int\n\t}\n\n\ttests := []searchTest{\n\t\t{\n\t\t\t\"cardinality 1 intersection\",\n\t\t\t[]uint16{0, 1, 2, 3, 4, 9},\n\t\t\t[]uint16{8, 9, 10, 11, 12},\n\t\t\t10,\n\t\t},\n\t\t{\n\t\t\t\"empty set \",\n\t\t\t[]uint16{},\n\t\t\t[]uint16{8, 9, 10, 11, 12},\n\t\t\t5,\n\t\t},\n\t\t{\n\t\t\t\"cardinality 6\",\n\t\t\t[]uint16{1},\n\t\t\t[]uint16{8, 9, 10, 11, 12},\n\t\t\t6,\n\t\t},\n\t\t{\n\t\t\t\"large first set - cardinality 258\",\n\t\t\tmakeLargeSet(1024),\n\t\t\t[]uint16{8, 9},\n\t\t\t258,\n\t\t},\n\t\t{\n\t\t\t\"large second set - cardinality 0\",\n\t\t\t[]uint16{8, 9},\n\t\t\tmakeLargeSet(1024),\n\t\t\t258,\n\t\t},\n\t\t{\n\t\t\t\"large first set - cardinality 2\",\n\t\t\tmakeLargeSet(0),\n\t\t\t[]uint16{8, 9},\n\t\t\t256,\n\t\t},\n\t\t{\n\t\t\t\"large second set - cardinality 2\",\n\t\t\t[]uint16{8, 9},\n\t\t\tmakeLargeSet(0),\n\t\t\t256,\n\t\t},\n\t}\n\n\tfor _, testCase := range tests {\n\t\tt.Run(testCase.name, func(t *testing.T) {\n\t\t\tresult := union2by2Cardinality(testCase.data1, testCase.data2)\n\t\t\tassert.Equal(t, result, testCase.expectedValue)\n\t\t})\n\t}\n}\n"
        },
        {
          "name": "shortiterator.go",
          "type": "blob",
          "size": 0.8447265625,
          "content": "package roaring\n\ntype shortIterable interface {\n\thasNext() bool\n\tnext() uint16\n}\n\ntype shortPeekable interface {\n\tshortIterable\n\tpeekNext() uint16\n\tadvanceIfNeeded(minval uint16)\n}\n\ntype shortIterator struct {\n\tslice []uint16\n\tloc   int\n}\n\nfunc (si *shortIterator) hasNext() bool {\n\treturn si.loc < len(si.slice)\n}\n\nfunc (si *shortIterator) next() uint16 {\n\ta := si.slice[si.loc]\n\tsi.loc++\n\treturn a\n}\n\nfunc (si *shortIterator) peekNext() uint16 {\n\treturn si.slice[si.loc]\n}\n\nfunc (si *shortIterator) advanceIfNeeded(minval uint16) {\n\tif si.hasNext() && si.peekNext() < minval {\n\t\tsi.loc = advanceUntil(si.slice, si.loc, len(si.slice), minval)\n\t}\n}\n\ntype reverseIterator struct {\n\tslice []uint16\n\tloc   int\n}\n\nfunc (si *reverseIterator) hasNext() bool {\n\treturn si.loc >= 0\n}\n\nfunc (si *reverseIterator) next() uint16 {\n\ta := si.slice[si.loc]\n\tsi.loc--\n\treturn a\n}\n"
        },
        {
          "name": "smat.go",
          "type": "blob",
          "size": 10.357421875,
          "content": "//go:build gofuzz\n// +build gofuzz\n\n/*\n# Instructions for smat testing for roaring\n\n[smat](https://github.com/mschoch/smat) is a framework that provides\nstate machine assisted fuzz testing.\n\nTo run the smat tests for roaring...\n\n## Prerequisites\n\n    $ go get github.com/dvyukov/go-fuzz/go-fuzz\n    $ go get github.com/dvyukov/go-fuzz/go-fuzz-build\n\n## Steps\n\n1.  Generate initial smat corpus:\n```\n    go test -tags=gofuzz -run=TestGenerateSmatCorpus\n```\n\n2.  Build go-fuzz test program with instrumentation:\n```\n    go-fuzz-build -func FuzzSmat github.com/RoaringBitmap/roaring\n```\n\n3.  Run go-fuzz:\n```\n    go-fuzz -bin=./roaring-fuzz.zip -workdir=workdir/ -timeout=200\n```\n\nYou should see output like...\n```\n2016/09/16 13:58:35 slaves: 8, corpus: 1 (3s ago), crashers: 0, restarts: 1/0, execs: 0 (0/sec), cover: 0, uptime: 3s\n2016/09/16 13:58:38 slaves: 8, corpus: 1 (6s ago), crashers: 0, restarts: 1/0, execs: 0 (0/sec), cover: 0, uptime: 6s\n2016/09/16 13:58:41 slaves: 8, corpus: 1 (9s ago), crashers: 0, restarts: 1/44, execs: 44 (5/sec), cover: 0, uptime: 9s\n2016/09/16 13:58:44 slaves: 8, corpus: 1 (12s ago), crashers: 0, restarts: 1/45, execs: 45 (4/sec), cover: 0, uptime: 12s\n2016/09/16 13:58:47 slaves: 8, corpus: 1 (15s ago), crashers: 0, restarts: 1/46, execs: 46 (3/sec), cover: 0, uptime: 15s\n2016/09/16 13:58:50 slaves: 8, corpus: 1 (18s ago), crashers: 0, restarts: 1/47, execs: 47 (3/sec), cover: 0, uptime: 18s\n2016/09/16 13:58:53 slaves: 8, corpus: 1 (21s ago), crashers: 0, restarts: 1/63, execs: 63 (3/sec), cover: 0, uptime: 21s\n2016/09/16 13:58:56 slaves: 8, corpus: 1 (24s ago), crashers: 0, restarts: 1/65, execs: 65 (3/sec), cover: 0, uptime: 24s\n2016/09/16 13:58:59 slaves: 8, corpus: 1 (27s ago), crashers: 0, restarts: 1/66, execs: 66 (2/sec), cover: 0, uptime: 27s\n2016/09/16 13:59:02 slaves: 8, corpus: 1 (30s ago), crashers: 0, restarts: 1/67, execs: 67 (2/sec), cover: 0, uptime: 30s\n2016/09/16 13:59:05 slaves: 8, corpus: 1 (33s ago), crashers: 0, restarts: 1/83, execs: 83 (3/sec), cover: 0, uptime: 33s\n2016/09/16 13:59:08 slaves: 8, corpus: 1 (36s ago), crashers: 0, restarts: 1/84, execs: 84 (2/sec), cover: 0, uptime: 36s\n2016/09/16 13:59:11 slaves: 8, corpus: 2 (0s ago), crashers: 0, restarts: 1/85, execs: 85 (2/sec), cover: 0, uptime: 39s\n2016/09/16 13:59:14 slaves: 8, corpus: 17 (2s ago), crashers: 0, restarts: 1/86, execs: 86 (2/sec), cover: 480, uptime: 42s\n2016/09/16 13:59:17 slaves: 8, corpus: 17 (5s ago), crashers: 0, restarts: 1/66, execs: 132 (3/sec), cover: 487, uptime: 45s\n2016/09/16 13:59:20 slaves: 8, corpus: 17 (8s ago), crashers: 0, restarts: 1/440, execs: 2645 (55/sec), cover: 487, uptime: 48s\n\n```\n\nLet it run, and if the # of crashers is > 0, check out the reports in\nthe workdir where you should be able to find the panic goroutine stack\ntraces.\n*/\n\npackage roaring\n\nimport (\n\t\"fmt\"\n\t\"sort\"\n\n\t\"github.com/bits-and-blooms/bitset\"\n\t\"github.com/mschoch/smat\"\n)\n\n// fuzz test using state machine driven by byte stream.\nfunc FuzzSmat(data []byte) int {\n\treturn smat.Fuzz(&smatContext{}, smat.ActionID('S'), smat.ActionID('T'),\n\t\tsmatActionMap, data)\n}\n\nvar smatDebug = false\n\nfunc smatLog(prefix, format string, args ...interface{}) {\n\tif smatDebug {\n\t\tfmt.Print(prefix)\n\t\tfmt.Printf(format, args...)\n\t}\n}\n\ntype smatContext struct {\n\tpairs []*smatPair\n\n\t// Two registers, x & y.\n\tx int\n\ty int\n\n\tactions int\n}\n\ntype smatPair struct {\n\tbm *Bitmap\n\tbs *bitset.BitSet\n}\n\n// ------------------------------------------------------------------\n\nvar smatActionMap = smat.ActionMap{\n\tsmat.ActionID('X'): smatAction(\"x++\", smatWrap(func(c *smatContext) { c.x++ })),\n\tsmat.ActionID('x'): smatAction(\"x--\", smatWrap(func(c *smatContext) { c.x-- })),\n\tsmat.ActionID('Y'): smatAction(\"y++\", smatWrap(func(c *smatContext) { c.y++ })),\n\tsmat.ActionID('y'): smatAction(\"y--\", smatWrap(func(c *smatContext) { c.y-- })),\n\tsmat.ActionID('*'): smatAction(\"x*y\", smatWrap(func(c *smatContext) { c.x = c.x * c.y })),\n\tsmat.ActionID('<'): smatAction(\"x<<\", smatWrap(func(c *smatContext) { c.x = c.x << 1 })),\n\n\tsmat.ActionID('^'): smatAction(\"swap\", smatWrap(func(c *smatContext) { c.x, c.y = c.y, c.x })),\n\n\tsmat.ActionID('['): smatAction(\" pushPair\", smatWrap(smatPushPair)),\n\tsmat.ActionID(']'): smatAction(\" popPair\", smatWrap(smatPopPair)),\n\n\tsmat.ActionID('B'): smatAction(\" setBit\", smatWrap(smatSetBit)),\n\tsmat.ActionID('b'): smatAction(\" removeBit\", smatWrap(smatRemoveBit)),\n\n\tsmat.ActionID('o'): smatAction(\" or\", smatWrap(smatOr)),\n\tsmat.ActionID('a'): smatAction(\" and\", smatWrap(smatAnd)),\n\n\tsmat.ActionID('#'): smatAction(\" cardinality\", smatWrap(smatCardinality)),\n\n\tsmat.ActionID('O'): smatAction(\" orCardinality\", smatWrap(smatOrCardinality)),\n\tsmat.ActionID('A'): smatAction(\" andCardinality\", smatWrap(smatAndCardinality)),\n\n\tsmat.ActionID('c'): smatAction(\" clear\", smatWrap(smatClear)),\n\tsmat.ActionID('r'): smatAction(\" runOptimize\", smatWrap(smatRunOptimize)),\n\n\tsmat.ActionID('e'): smatAction(\" isEmpty\", smatWrap(smatIsEmpty)),\n\n\tsmat.ActionID('i'): smatAction(\" intersects\", smatWrap(smatIntersects)),\n\n\tsmat.ActionID('f'): smatAction(\" flip\", smatWrap(smatFlip)),\n\n\tsmat.ActionID('-'): smatAction(\" difference\", smatWrap(smatDifference)),\n}\n\nvar smatRunningPercentActions []smat.PercentAction\n\nfunc init() {\n\tvar ids []int\n\tfor actionId := range smatActionMap {\n\t\tids = append(ids, int(actionId))\n\t}\n\tsort.Ints(ids)\n\n\tpct := 100 / len(smatActionMap)\n\tfor _, actionId := range ids {\n\t\tsmatRunningPercentActions = append(smatRunningPercentActions,\n\t\t\tsmat.PercentAction{pct, smat.ActionID(actionId)})\n\t}\n\n\tsmatActionMap[smat.ActionID('S')] = smatAction(\"SETUP\", smatSetupFunc)\n\tsmatActionMap[smat.ActionID('T')] = smatAction(\"TEARDOWN\", smatTeardownFunc)\n}\n\n// We only have one smat state: running.\nfunc smatRunning(next byte) smat.ActionID {\n\treturn smat.PercentExecute(next, smatRunningPercentActions...)\n}\n\nfunc smatAction(name string, f func(ctx smat.Context) (smat.State, error)) func(smat.Context) (smat.State, error) {\n\treturn func(ctx smat.Context) (smat.State, error) {\n\t\tc := ctx.(*smatContext)\n\t\tc.actions++\n\n\t\tsmatLog(\"  \", \"%s\\n\", name)\n\n\t\treturn f(ctx)\n\t}\n}\n\n// Creates an smat action func based on a simple callback.\nfunc smatWrap(cb func(c *smatContext)) func(smat.Context) (next smat.State, err error) {\n\treturn func(ctx smat.Context) (next smat.State, err error) {\n\t\tc := ctx.(*smatContext)\n\t\tcb(c)\n\t\treturn smatRunning, nil\n\t}\n}\n\n// Invokes a callback function with the input v bounded to len(c.pairs).\nfunc (c *smatContext) withPair(v int, cb func(*smatPair)) {\n\tif len(c.pairs) > 0 {\n\t\tif v < 0 {\n\t\t\tv = -v\n\t\t}\n\t\tv = v % len(c.pairs)\n\t\tcb(c.pairs[v])\n\t}\n}\n\n// ------------------------------------------------------------------\n\nfunc smatSetupFunc(ctx smat.Context) (next smat.State, err error) {\n\treturn smatRunning, nil\n}\n\nfunc smatTeardownFunc(ctx smat.Context) (next smat.State, err error) {\n\treturn nil, err\n}\n\n// ------------------------------------------------------------------\n\nfunc smatPushPair(c *smatContext) {\n\tc.pairs = append(c.pairs, &smatPair{\n\t\tbm: NewBitmap(),\n\t\tbs: bitset.New(100),\n\t})\n}\n\nfunc smatPopPair(c *smatContext) {\n\tif len(c.pairs) > 0 {\n\t\tc.pairs = c.pairs[0 : len(c.pairs)-1]\n\t}\n}\n\nfunc smatSetBit(c *smatContext) {\n\tc.withPair(c.x, func(p *smatPair) {\n\t\ty := uint32(c.y)\n\t\tp.bm.AddInt(int(y))\n\t\tp.bs.Set(uint(y))\n\t\tp.checkEquals()\n\t})\n}\n\nfunc smatRemoveBit(c *smatContext) {\n\tc.withPair(c.x, func(p *smatPair) {\n\t\ty := uint32(c.y)\n\t\tp.bm.Remove(y)\n\t\tp.bs.Clear(uint(y))\n\t\tp.checkEquals()\n\t})\n}\n\nfunc smatAnd(c *smatContext) {\n\tc.withPair(c.x, func(px *smatPair) {\n\t\tc.withPair(c.y, func(py *smatPair) {\n\t\t\tpx.bm.And(py.bm)\n\t\t\tpx.bs = px.bs.Intersection(py.bs)\n\t\t\tpx.checkEquals()\n\t\t\tpy.checkEquals()\n\t\t})\n\t})\n}\n\nfunc smatOr(c *smatContext) {\n\tc.withPair(c.x, func(px *smatPair) {\n\t\tc.withPair(c.y, func(py *smatPair) {\n\t\t\tpx.bm.Or(py.bm)\n\t\t\tpx.bs = px.bs.Union(py.bs)\n\t\t\tpx.checkEquals()\n\t\t\tpy.checkEquals()\n\t\t})\n\t})\n}\n\nfunc smatAndCardinality(c *smatContext) {\n\tc.withPair(c.x, func(px *smatPair) {\n\t\tc.withPair(c.y, func(py *smatPair) {\n\t\t\tc0 := px.bm.AndCardinality(py.bm)\n\t\t\tc1 := px.bs.IntersectionCardinality(py.bs)\n\t\t\tif c0 != uint64(c1) {\n\t\t\t\tpanic(\"expected same add cardinality\")\n\t\t\t}\n\t\t\tpx.checkEquals()\n\t\t\tpy.checkEquals()\n\t\t})\n\t})\n}\n\nfunc smatOrCardinality(c *smatContext) {\n\tc.withPair(c.x, func(px *smatPair) {\n\t\tc.withPair(c.y, func(py *smatPair) {\n\t\t\tc0 := px.bm.OrCardinality(py.bm)\n\t\t\tc1 := px.bs.UnionCardinality(py.bs)\n\t\t\tif c0 != uint64(c1) {\n\t\t\t\tpanic(\"expected same or cardinality\")\n\t\t\t}\n\t\t\tpx.checkEquals()\n\t\t\tpy.checkEquals()\n\t\t})\n\t})\n}\n\nfunc smatRunOptimize(c *smatContext) {\n\tc.withPair(c.x, func(px *smatPair) {\n\t\tpx.bm.RunOptimize()\n\t\tpx.checkEquals()\n\t})\n}\n\nfunc smatClear(c *smatContext) {\n\tc.withPair(c.x, func(px *smatPair) {\n\t\tpx.bm.Clear()\n\t\tpx.bs = px.bs.ClearAll()\n\t\tpx.checkEquals()\n\t})\n}\n\nfunc smatCardinality(c *smatContext) {\n\tc.withPair(c.x, func(px *smatPair) {\n\t\tc0 := px.bm.GetCardinality()\n\t\tc1 := px.bs.Count()\n\t\tif c0 != uint64(c1) {\n\t\t\tpanic(\"expected same cardinality\")\n\t\t}\n\t})\n}\n\nfunc smatIsEmpty(c *smatContext) {\n\tc.withPair(c.x, func(px *smatPair) {\n\t\tc0 := px.bm.IsEmpty()\n\t\tc1 := px.bs.None()\n\t\tif c0 != c1 {\n\t\t\tpanic(\"expected same is empty\")\n\t\t}\n\t})\n}\n\nfunc smatIntersects(c *smatContext) {\n\tc.withPair(c.x, func(px *smatPair) {\n\t\tc.withPair(c.y, func(py *smatPair) {\n\t\t\tv0 := px.bm.Intersects(py.bm)\n\t\t\tv1 := px.bs.IntersectionCardinality(py.bs) > 0\n\t\t\tif v0 != v1 {\n\t\t\t\tpanic(\"intersects not equal\")\n\t\t\t}\n\n\t\t\tpx.checkEquals()\n\t\t\tpy.checkEquals()\n\t\t})\n\t})\n}\n\nfunc smatFlip(c *smatContext) {\n\tc.withPair(c.x, func(p *smatPair) {\n\t\ty := uint32(c.y)\n\t\tp.bm.Flip(uint64(y), uint64(y)+1)\n\t\tp.bs = p.bs.Flip(uint(y))\n\t\tp.checkEquals()\n\t})\n}\n\nfunc smatDifference(c *smatContext) {\n\tc.withPair(c.x, func(px *smatPair) {\n\t\tc.withPair(c.y, func(py *smatPair) {\n\t\t\tpx.bm.AndNot(py.bm)\n\t\t\tpx.bs = px.bs.Difference(py.bs)\n\t\t\tpx.checkEquals()\n\t\t\tpy.checkEquals()\n\t\t})\n\t})\n}\n\nfunc (p *smatPair) checkEquals() {\n\tif !p.equalsBitSet(p.bs, p.bm) {\n\t\tpanic(\"bitset mismatch\")\n\t}\n}\n\nfunc (p *smatPair) equalsBitSet(a *bitset.BitSet, b *Bitmap) bool {\n\tfor i, e := a.NextSet(0); e; i, e = a.NextSet(i + 1) {\n\t\tif !b.ContainsInt(int(i)) {\n\t\t\tfmt.Printf(\"in a bitset, not b bitmap, i: %d\\n\", i)\n\t\t\tfmt.Printf(\"  a bitset: %s\\n  b bitmap: %s\\n\",\n\t\t\t\ta.String(), b.String())\n\t\t\treturn false\n\t\t}\n\t}\n\n\ti := b.Iterator()\n\tfor i.HasNext() {\n\t\tv := i.Next()\n\t\tif !a.Test(uint(v)) {\n\t\t\tfmt.Printf(\"in b bitmap, not a bitset, v: %d\\n\", v)\n\t\t\tfmt.Printf(\"  a bitset: %s\\n  b bitmap: %s\\n\",\n\t\t\t\ta.String(), b.String())\n\t\t\treturn false\n\t\t}\n\t}\n\n\treturn true\n}\n"
        },
        {
          "name": "smat_generate_test.go",
          "type": "blob",
          "size": 1.1435546875,
          "content": "//go:build gofuzz\n// +build gofuzz\n\npackage roaring\n\nimport (\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"os\"\n\t\"testing\"\n\n\t\"github.com/mschoch/smat\"\n)\n\nfunc TestGenerateSmatCorpus(t *testing.T) {\n\tfor i, actionSeq := range smatActionSeqs {\n\t\tbyteSequence, err := actionSeq.ByteEncoding(&smatContext{},\n\t\t\tsmat.ActionID('S'), smat.ActionID('T'), smatActionMap)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"error from ByteEncoding, err: %v, i: %d, actonSeq: %#v\",\n\t\t\t\terr, i, actionSeq)\n\t\t}\n\t\tos.MkdirAll(\"workdir/corpus\", 0700)\n\t\tioutil.WriteFile(fmt.Sprintf(\"workdir/corpus/%d\", i), byteSequence, 0600)\n\t}\n}\n\nvar smatActionSeqs = []smat.ActionSeq{\n\t{\n\t\tsmat.ActionID('X'),\n\t\tsmat.ActionID('X'),\n\t\tsmat.ActionID('Y'),\n\t\tsmat.ActionID('Y'),\n\t\tsmat.ActionID('<'),\n\t\tsmat.ActionID('<'),\n\t\tsmat.ActionID('*'),\n\t\tsmat.ActionID('x'),\n\t\tsmat.ActionID('y'),\n\t\tsmat.ActionID('*'),\n\t\tsmat.ActionID('['),\n\t\tsmat.ActionID('['),\n\t\tsmat.ActionID('B'),\n\t\tsmat.ActionID('a'),\n\t\tsmat.ActionID('o'),\n\t\tsmat.ActionID('A'),\n\t\tsmat.ActionID('O'),\n\t\tsmat.ActionID('#'),\n\t\tsmat.ActionID('X'),\n\t\tsmat.ActionID('Y'),\n\t\tsmat.ActionID('B'),\n\t\tsmat.ActionID('e'),\n\t\tsmat.ActionID('f'),\n\t\tsmat.ActionID('-'),\n\t\tsmat.ActionID('e'),\n\t},\n}\n"
        },
        {
          "name": "smat_hits_test.go",
          "type": "blob",
          "size": 1.533203125,
          "content": "//  Copyright (c) 2016 Couchbase, Inc.\n//  Licensed under the Apache License, Version 2.0 (the \"License\");\n//  you may not use this file except in compliance with the\n//  License. You may obtain a copy of the License at\n//    http://www.apache.org/licenses/LICENSE-2.0\n//  Unless required by applicable law or agreed to in writing,\n//  software distributed under the License is distributed on an \"AS\n//  IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n//  express or implied. See the License for the specific language\n//  governing permissions and limitations under the License.\n\n//go:build gofuzz\n// +build gofuzz\n\npackage roaring\n\nimport (\n\t\"log\"\n\t\"testing\"\n\n\t\"github.com/mschoch/smat\"\n)\n\n// Crashers reported by smat, captured as pairs of strings.  A pair is\n// a short descrption of the crash then the corresponding crash-input.\nvar smatHits = []string{\n\t\"0001:\\n\" +\n\t\t\"in a bitset, not b bitmap, pos: 0\\n\" +\n\t\t\"  a bitset: {0,1}\\n\" +\n\t\t\"  b bitmap: {1,0}\\n\" +\n\t\t\"panic: bitset mismatch\\n\" +\n\t\t\"  SETUP\\n\" +\n\t\t\"   pushPair\\n\" +\n\t\t\"   setBit\\n\" +\n\t\t\"  y++\\n\" +\n\t\t\"   flip\\n\",\n\t\"]5S\\xa5\",\n}\n\n// Test the previous issues found by smat.\nfunc TestSmatHits(t *testing.T) {\n\tsmatDebugPrev := smatDebug\n\tsmatDebug = true // Use true when diagnosing a crash.\n\n\tfor i := 0; i < len(smatHits); i += 2 {\n\t\tdesc := smatHits[i]\n\t\thit := []byte(smatHits[i+1])\n\n\t\tlog.Printf(\"testing smat hit: (%d) %s\\n\", i/2, desc)\n\n\t\t// fuzz the hit input\n\t\tsmat.Fuzz(&smatContext{}, smat.ActionID('S'), smat.ActionID('T'),\n\t\t\tsmatActionMap, hit)\n\t}\n\n\tsmatDebug = smatDebugPrev\n}\n"
        },
        {
          "name": "testdata",
          "type": "tree",
          "content": null
        },
        {
          "name": "testfrozendata",
          "type": "tree",
          "content": null
        },
        {
          "name": "util.go",
          "type": "blob",
          "size": 6.6494140625,
          "content": "package roaring\n\nimport (\n\t\"math\"\n\t\"math/rand\"\n\t\"sort\"\n)\n\nconst (\n\tarrayDefaultMaxSize        = 4096 // containers with 4096 or fewer integers should be array containers.\n\tarrayLazyLowerBound        = 1024\n\tmaxCapacity                = 1 << 16\n\tserialCookieNoRunContainer = 12346 // only arrays and bitmaps\n\tinvalidCardinality         = -1\n\tserialCookie               = 12347 // runs, arrays, and bitmaps\n\tnoOffsetThreshold          = 4\n\n\t// MaxUint32 is the largest uint32 value.\n\tMaxUint32 = math.MaxUint32\n\n\t// MaxRange is One more than the maximum allowed bitmap bit index. For use as an upper\n\t// bound for ranges.\n\tMaxRange uint64 = MaxUint32 + 1\n\n\t// MaxUint16 is the largest 16 bit unsigned int.\n\t// This is the largest value an interval16 can store.\n\tMaxUint16 = math.MaxUint16\n\n\t// Compute wordSizeInBytes, the size of a word in bytes.\n\t_m              = ^uint64(0)\n\t_logS           = _m>>8&1 + _m>>16&1 + _m>>32&1\n\twordSizeInBytes = 1 << _logS\n\n\t// other constants used in ctz_generic.go\n\twordSizeInBits = wordSizeInBytes << 3 // word size in bits\n)\n\nconst maxWord = 1<<wordSizeInBits - 1\n\n// doesn't apply to runContainers\nfunc getSizeInBytesFromCardinality(card int) int {\n\tif card > arrayDefaultMaxSize {\n\t\t// bitmapContainer\n\t\treturn maxCapacity / 8\n\t}\n\t// arrayContainer\n\treturn 2 * card\n}\n\nfunc fill(arr []uint64, val uint64) {\n\tfor i := range arr {\n\t\tarr[i] = val\n\t}\n}\n\nfunc fillRange(arr []uint64, start, end int, val uint64) {\n\tfor i := start; i < end; i++ {\n\t\tarr[i] = val\n\t}\n}\n\nfunc fillArrayAND(container []uint16, bitmap1, bitmap2 []uint64) {\n\tif len(bitmap1) != len(bitmap2) {\n\t\tpanic(\"array lengths don't match\")\n\t}\n\t// TODO: rewrite in assembly\n\tpos := 0\n\tfor k := range bitmap1 {\n\t\tbitset := bitmap1[k] & bitmap2[k]\n\t\tfor bitset != 0 {\n\t\t\tt := bitset & -bitset\n\t\t\tcontainer[pos] = uint16((k*64 + int(popcount(t-1))))\n\t\t\tpos = pos + 1\n\t\t\tbitset ^= t\n\t\t}\n\t}\n}\n\nfunc fillArrayANDNOT(container []uint16, bitmap1, bitmap2 []uint64) {\n\tif len(bitmap1) != len(bitmap2) {\n\t\tpanic(\"array lengths don't match\")\n\t}\n\t// TODO: rewrite in assembly\n\tpos := 0\n\tfor k := range bitmap1 {\n\t\tbitset := bitmap1[k] &^ bitmap2[k]\n\t\tfor bitset != 0 {\n\t\t\tt := bitset & -bitset\n\t\t\tcontainer[pos] = uint16((k*64 + int(popcount(t-1))))\n\t\t\tpos = pos + 1\n\t\t\tbitset ^= t\n\t\t}\n\t}\n}\n\nfunc fillArrayXOR(container []uint16, bitmap1, bitmap2 []uint64) {\n\tif len(bitmap1) != len(bitmap2) {\n\t\tpanic(\"array lengths don't match\")\n\t}\n\t// TODO: rewrite in assembly\n\tpos := 0\n\tfor k := 0; k < len(bitmap1); k++ {\n\t\tbitset := bitmap1[k] ^ bitmap2[k]\n\t\tfor bitset != 0 {\n\t\t\tt := bitset & -bitset\n\t\t\tcontainer[pos] = uint16((k*64 + int(popcount(t-1))))\n\t\t\tpos = pos + 1\n\t\t\tbitset ^= t\n\t\t}\n\t}\n}\n\nfunc highbits(x uint32) uint16 {\n\treturn uint16(x >> 16)\n}\n\nfunc lowbits(x uint32) uint16 {\n\treturn uint16(x & maxLowBit)\n}\n\nfunc combineLoHi16(lob uint16, hob uint16) uint32 {\n\treturn combineLoHi32(uint32(lob), uint32(hob))\n}\n\nfunc combineLoHi32(lob uint32, hob uint32) uint32 {\n\treturn uint32(lob) | (hob << 16)\n}\n\nconst maxLowBit = 0xFFFF\n\nfunc flipBitmapRange(bitmap []uint64, start int, end int) {\n\tif start >= end {\n\t\treturn\n\t}\n\tfirstword := start / 64\n\tendword := (end - 1) / 64\n\tbitmap[firstword] ^= ^(^uint64(0) << uint(start%64))\n\tfor i := firstword; i < endword; i++ {\n\t\tbitmap[i] = ^bitmap[i]\n\t}\n\tbitmap[endword] ^= ^uint64(0) >> (uint(-end) % 64)\n}\n\nfunc resetBitmapRange(bitmap []uint64, start int, end int) {\n\tif start >= end {\n\t\treturn\n\t}\n\tfirstword := start / 64\n\tendword := (end - 1) / 64\n\tif firstword == endword {\n\t\tbitmap[firstword] &= ^((^uint64(0) << uint(start%64)) & (^uint64(0) >> (uint(-end) % 64)))\n\t\treturn\n\t}\n\tbitmap[firstword] &= ^(^uint64(0) << uint(start%64))\n\tfor i := firstword + 1; i < endword; i++ {\n\t\tbitmap[i] = 0\n\t}\n\tbitmap[endword] &= ^(^uint64(0) >> (uint(-end) % 64))\n}\n\nfunc setBitmapRange(bitmap []uint64, start int, end int) {\n\tif start >= end {\n\t\treturn\n\t}\n\tfirstword := start / 64\n\tendword := (end - 1) / 64\n\tif firstword == endword {\n\t\tbitmap[firstword] |= (^uint64(0) << uint(start%64)) & (^uint64(0) >> (uint(-end) % 64))\n\t\treturn\n\t}\n\tbitmap[firstword] |= ^uint64(0) << uint(start%64)\n\tfor i := firstword + 1; i < endword; i++ {\n\t\tbitmap[i] = ^uint64(0)\n\t}\n\tbitmap[endword] |= ^uint64(0) >> (uint(-end) % 64)\n}\n\nfunc flipBitmapRangeAndCardinalityChange(bitmap []uint64, start int, end int) int {\n\tbefore := wordCardinalityForBitmapRange(bitmap, start, end)\n\tflipBitmapRange(bitmap, start, end)\n\tafter := wordCardinalityForBitmapRange(bitmap, start, end)\n\treturn int(after - before)\n}\n\nfunc resetBitmapRangeAndCardinalityChange(bitmap []uint64, start int, end int) int {\n\tbefore := wordCardinalityForBitmapRange(bitmap, start, end)\n\tresetBitmapRange(bitmap, start, end)\n\tafter := wordCardinalityForBitmapRange(bitmap, start, end)\n\treturn int(after - before)\n}\n\nfunc setBitmapRangeAndCardinalityChange(bitmap []uint64, start int, end int) int {\n\tbefore := wordCardinalityForBitmapRange(bitmap, start, end)\n\tsetBitmapRange(bitmap, start, end)\n\tafter := wordCardinalityForBitmapRange(bitmap, start, end)\n\treturn int(after - before)\n}\n\nfunc wordCardinalityForBitmapRange(bitmap []uint64, start int, end int) uint64 {\n\tanswer := uint64(0)\n\tif start >= end {\n\t\treturn answer\n\t}\n\tfirstword := start / 64\n\tendword := (end - 1) / 64\n\tfor i := firstword; i <= endword; i++ {\n\t\tanswer += popcount(bitmap[i])\n\t}\n\treturn answer\n}\n\nfunc selectBitPosition(w uint64, j int) int {\n\tseen := 0\n\n\t// Divide 64bit\n\tpart := w & 0xFFFFFFFF\n\tn := popcount(part)\n\tif n <= uint64(j) {\n\t\tpart = w >> 32\n\t\tseen += 32\n\t\tj -= int(n)\n\t}\n\tw = part\n\n\t// Divide 32bit\n\tpart = w & 0xFFFF\n\tn = popcount(part)\n\tif n <= uint64(j) {\n\t\tpart = w >> 16\n\t\tseen += 16\n\t\tj -= int(n)\n\t}\n\tw = part\n\n\t// Divide 16bit\n\tpart = w & 0xFF\n\tn = popcount(part)\n\tif n <= uint64(j) {\n\t\tpart = w >> 8\n\t\tseen += 8\n\t\tj -= int(n)\n\t}\n\tw = part\n\n\t// Lookup in final byte\n\tvar counter uint\n\tfor counter = 0; counter < 8; counter++ {\n\t\tj -= int((w >> counter) & 1)\n\t\tif j < 0 {\n\t\t\tbreak\n\t\t}\n\t}\n\treturn seen + int(counter)\n}\n\nfunc panicOn(err error) {\n\tif err != nil {\n\t\tpanic(err)\n\t}\n}\n\ntype ph struct {\n\torig int\n\trand int\n}\n\ntype pha []ph\n\nfunc (p pha) Len() int           { return len(p) }\nfunc (p pha) Less(i, j int) bool { return p[i].rand < p[j].rand }\nfunc (p pha) Swap(i, j int)      { p[i], p[j] = p[j], p[i] }\n\nfunc getRandomPermutation(n int) []int {\n\tr := make([]ph, n)\n\tfor i := 0; i < n; i++ {\n\t\tr[i].orig = i\n\t\tr[i].rand = rand.Intn(1 << 29)\n\t}\n\tsort.Sort(pha(r))\n\tm := make([]int, n)\n\tfor i := range m {\n\t\tm[i] = r[i].orig\n\t}\n\treturn m\n}\n\nfunc minOfInt(a, b int) int {\n\tif a < b {\n\t\treturn a\n\t}\n\treturn b\n}\n\nfunc maxOfInt(a, b int) int {\n\tif a > b {\n\t\treturn a\n\t}\n\treturn b\n}\n\nfunc maxOfUint16(a, b uint16) uint16 {\n\tif a > b {\n\t\treturn a\n\t}\n\treturn b\n}\n\nfunc minOfUint16(a, b uint16) uint16 {\n\tif a < b {\n\t\treturn a\n\t}\n\treturn b\n}\n"
        },
        {
          "name": "util_test.go",
          "type": "blob",
          "size": 0.50390625,
          "content": "package roaring\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestLobHob(t *testing.T) {\n\tfor i := 0; i < 2049; i++ {\n\t\tval := uint32(i)\n\t\tlob := lowbits(uint32(val))\n\t\thob := highbits(uint32(val))\n\t\treconstructed := combineLoHi16(lob, hob)\n\t\tassert.Equal(t, reconstructed, val)\n\t}\n\n\tfor i := 0; i < 2049; i++ {\n\t\tval := uint32(i)\n\t\tlob := lowbits(uint32(val))\n\t\thob := highbits(uint32(val))\n\t\treconstructed := combineLoHi32(uint32(lob), uint32(hob))\n\t\tassert.Equal(t, reconstructed, val)\n\t}\n}\n"
        }
      ]
    }
  ]
}