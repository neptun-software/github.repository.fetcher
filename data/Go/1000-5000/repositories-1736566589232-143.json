{
  "metadata": {
    "timestamp": 1736566589232,
    "page": 143,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjE1MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "orcaman/concurrent-map",
      "stars": 4353,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.0068359375,
          "content": ".idea/\n"
        },
        {
          "name": ".travis.yml",
          "type": "blob",
          "size": 0.9658203125,
          "content": "# This is a weird way of telling Travis to use the fast container-based test\n# runner instead of the slow VM-based runner.\nsudo: false\n\nlanguage: go\n\n# You don't need to test on very old version of the Go compiler. It's the user's\n# responsibility to keep their compilers up to date.\ngo:\n  - 1.18\n\n# Only clone the most recent commit.\ngit:\n  depth: 1\n\n# Skip the install step. Don't `go get` dependencies. Only build with the code\n# in vendor/\ninstall: true\n\n# Don't email me the results of the test runs.\nnotifications:\n  email: false\n\nbefore_script:\n  - go install github.com/golangci/golangci-lint/cmd/golangci-lint@latest\n\n# script always runs to completion (set +e). If we have linter issues AND a\n# failing test, we want to see both. Configure golangci-lint with a\n# .golangci.yml file at the top level of your repo.\nscript:\n  - golangci-lint run       # run a bunch of code checkers/linters in parallel\n  - go test -v -race ./...  # Run all the tests with the race detector enabled\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.052734375,
          "content": "The MIT License (MIT)\n\nCopyright (c) 2014 streamrail\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n\n"
        },
        {
          "name": "README-zh.md",
          "type": "blob",
          "size": 2.4765625,
          "content": "# concurrent map [![Build Status](https://travis-ci.com/orcaman/concurrent-map.svg?branch=master)](https://travis-ci.com/orcaman/concurrent-map)\n\n正如 [这里](http://golang.org/doc/faq#atomic_maps) 和 [这里](http://blog.golang.org/go-maps-in-action)所描述的, Go语言原生的`map`类型并不支持并发读写。`concurrent-map`提供了一种高性能的解决方案:通过对内部`map`进行分片，降低锁粒度，从而达到最少的锁等待时间(锁冲突)\n\n在Go 1.9之前，go语言标准库中并没有实现并发`map`。在Go 1.9中，引入了`sync.Map`。新的`sync.Map`与此`concurrent-map`有几个关键区别。标准库中的`sync.Map`是专为`append-only`场景设计的。因此，如果您想将`Map`用于一个类似内存数据库，那么使用我们的版本可能会受益。你可以在golang repo上读到更多，[这里](https://github.com/golang/go/issues/21035) and [这里](https://stackoverflow.com/questions/11063473/map-with-concurrent-access)\n***译注:`sync.Map`在读多写少性能比较好，否则并发性能很差***\n\n## 用法\n\n导入包:\n\n```go\nimport (\n\t\"github.com/orcaman/concurrent-map/v2\"\n)\n\n```\n\n```bash\ngo get \"github.com/orcaman/concurrent-map/v2\"\n```\n\n现在包被导入到了`cmap`命名空间下\n***译注:通常包的限定前缀(命名空间)是和目录名一致的，但是这个包有点典型😂，不一致！！！所以用的时候注意***\n\n## 示例\n\n```go\n\n\t// 创建一个新的 map.\n\tm := cmap.New[string]()\n\n\t// 设置变量m一个键为“foo”值为“bar”键值对\n\tm.Set(\"foo\", \"bar\")\n\n\t// 从m中获取指定键值.\n\tbar, ok := m.Get(\"foo\")\n\n\t// 删除键为“foo”的项\n\tm.Remove(\"foo\")\n\n```\n\n更多使用示例请查看`concurrent_map_test.go`.\n\n运行测试:\n\n```bash\ngo test \"github.com/orcaman/concurrent-map/v2\"\n```\n\n## 贡献说明\n\n我们非常欢迎大家的贡献。如欲合并贡献，请遵循以下指引:\n- 新建一个issue,并且叙述为什么这么做(解决一个bug，增加一个功能，等等)\n- 根据核心团队对上述问题的反馈，提交一个PR，描述变更并链接到该问题。\n- 新代码必须具有测试覆盖率。\n- 如果代码是关于性能问题的，则必须在流程中包括基准测试(无论是在问题中还是在PR中)。\n- 一般来说，我们希望`concurrent-map`尽可能简单，且与原生的`map`有相似的操作。当你新建issue时请注意这一点。\n\n## 许可证\nMIT (see [LICENSE](https://github.com/orcaman/concurrent-map/blob/master/LICENSE) file)\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 2.3642578125,
          "content": "# concurrent map [![Build Status](https://travis-ci.com/orcaman/concurrent-map.svg?branch=master)](https://travis-ci.com/orcaman/concurrent-map)\n\nAs explained [here](http://golang.org/doc/faq#atomic_maps) and [here](http://blog.golang.org/go-maps-in-action), the `map` type in Go doesn't support concurrent reads and writes. `concurrent-map` provides a high-performance solution to this by sharding the map with minimal time spent waiting for locks.\n\nPrior to Go 1.9, there was no concurrent map implementation in the stdlib. In Go 1.9, `sync.Map` was introduced. The new `sync.Map` has a few key differences from this map. The stdlib `sync.Map` is designed for append-only scenarios. So if you want to use the map for something more like in-memory db, you might benefit from using our version. You can read more about it in the golang repo, for example [here](https://github.com/golang/go/issues/21035) and [here](https://stackoverflow.com/questions/11063473/map-with-concurrent-access)\n\n## usage\n\nImport the package:\n\n```go\nimport (\n\t\"github.com/orcaman/concurrent-map/v2\"\n)\n\n```\n\n```bash\ngo get \"github.com/orcaman/concurrent-map/v2\"\n```\n\nThe package is now imported under the \"cmap\" namespace.\n\n## example\n\n```go\n\n\t// Create a new map.\n\tm := cmap.New[string]()\n\n\t// Sets item within map, sets \"bar\" under key \"foo\"\n\tm.Set(\"foo\", \"bar\")\n\n\t// Retrieve item from map.\n\tbar, ok := m.Get(\"foo\")\n\n\t// Removes item under key \"foo\"\n\tm.Remove(\"foo\")\n\n```\n\nFor more examples have a look at concurrent_map_test.go.\n\nRunning tests:\n\n```bash\ngo test \"github.com/orcaman/concurrent-map/v2\"\n```\n\n## guidelines for contributing\n\nContributions are highly welcome. In order for a contribution to be merged, please follow these guidelines:\n- Open an issue and describe what you are after (fixing a bug, adding an enhancement, etc.).\n- According to the core team's feedback on the above mentioned issue, submit a pull request, describing the changes and linking to the issue.\n- New code must have test coverage.\n- If the code is about performance issues, you must include benchmarks in the process (either in the issue or in the PR).\n- In general, we would like to keep `concurrent-map` as simple as possible and as similar to the native `map`. Please keep this in mind when opening issues.\n\n## language\n- [中文说明](./README-zh.md)\n\n## license\nMIT (see [LICENSE](https://github.com/orcaman/concurrent-map/blob/master/LICENSE) file)\n"
        },
        {
          "name": "concurrent_map.go",
          "type": "blob",
          "size": 9.181640625,
          "content": "package cmap\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"sync\"\n)\n\nvar SHARD_COUNT = 32\n\ntype Stringer interface {\n\tfmt.Stringer\n\tcomparable\n}\n\n// A \"thread\" safe map of type string:Anything.\n// To avoid lock bottlenecks this map is dived to several (SHARD_COUNT) map shards.\ntype ConcurrentMap[K comparable, V any] struct {\n\tshards   []*ConcurrentMapShared[K, V]\n\tsharding func(key K) uint32\n}\n\n// A \"thread\" safe string to anything map.\ntype ConcurrentMapShared[K comparable, V any] struct {\n\titems        map[K]V\n\tsync.RWMutex // Read Write mutex, guards access to internal map.\n}\n\nfunc create[K comparable, V any](sharding func(key K) uint32) ConcurrentMap[K, V] {\n\tm := ConcurrentMap[K, V]{\n\t\tsharding: sharding,\n\t\tshards:   make([]*ConcurrentMapShared[K, V], SHARD_COUNT),\n\t}\n\tfor i := 0; i < SHARD_COUNT; i++ {\n\t\tm.shards[i] = &ConcurrentMapShared[K, V]{items: make(map[K]V)}\n\t}\n\treturn m\n}\n\n// Creates a new concurrent map.\nfunc New[V any]() ConcurrentMap[string, V] {\n\treturn create[string, V](fnv32)\n}\n\n// Creates a new concurrent map.\nfunc NewStringer[K Stringer, V any]() ConcurrentMap[K, V] {\n\treturn create[K, V](strfnv32[K])\n}\n\n// Creates a new concurrent map.\nfunc NewWithCustomShardingFunction[K comparable, V any](sharding func(key K) uint32) ConcurrentMap[K, V] {\n\treturn create[K, V](sharding)\n}\n\n// GetShard returns shard under given key\nfunc (m ConcurrentMap[K, V]) GetShard(key K) *ConcurrentMapShared[K, V] {\n\treturn m.shards[uint(m.sharding(key))%uint(SHARD_COUNT)]\n}\n\nfunc (m ConcurrentMap[K, V]) MSet(data map[K]V) {\n\tfor key, value := range data {\n\t\tshard := m.GetShard(key)\n\t\tshard.Lock()\n\t\tshard.items[key] = value\n\t\tshard.Unlock()\n\t}\n}\n\n// Sets the given value under the specified key.\nfunc (m ConcurrentMap[K, V]) Set(key K, value V) {\n\t// Get map shard.\n\tshard := m.GetShard(key)\n\tshard.Lock()\n\tshard.items[key] = value\n\tshard.Unlock()\n}\n\n// Callback to return new element to be inserted into the map\n// It is called while lock is held, therefore it MUST NOT\n// try to access other keys in same map, as it can lead to deadlock since\n// Go sync.RWLock is not reentrant\ntype UpsertCb[V any] func(exist bool, valueInMap V, newValue V) V\n\n// Insert or Update - updates existing element or inserts a new one using UpsertCb\nfunc (m ConcurrentMap[K, V]) Upsert(key K, value V, cb UpsertCb[V]) (res V) {\n\tshard := m.GetShard(key)\n\tshard.Lock()\n\tv, ok := shard.items[key]\n\tres = cb(ok, v, value)\n\tshard.items[key] = res\n\tshard.Unlock()\n\treturn res\n}\n\n// Sets the given value under the specified key if no value was associated with it.\nfunc (m ConcurrentMap[K, V]) SetIfAbsent(key K, value V) bool {\n\t// Get map shard.\n\tshard := m.GetShard(key)\n\tshard.Lock()\n\t_, ok := shard.items[key]\n\tif !ok {\n\t\tshard.items[key] = value\n\t}\n\tshard.Unlock()\n\treturn !ok\n}\n\n// Get retrieves an element from map under given key.\nfunc (m ConcurrentMap[K, V]) Get(key K) (V, bool) {\n\t// Get shard\n\tshard := m.GetShard(key)\n\tshard.RLock()\n\t// Get item from shard.\n\tval, ok := shard.items[key]\n\tshard.RUnlock()\n\treturn val, ok\n}\n\n// Count returns the number of elements within the map.\nfunc (m ConcurrentMap[K, V]) Count() int {\n\tcount := 0\n\tfor i := 0; i < SHARD_COUNT; i++ {\n\t\tshard := m.shards[i]\n\t\tshard.RLock()\n\t\tcount += len(shard.items)\n\t\tshard.RUnlock()\n\t}\n\treturn count\n}\n\n// Looks up an item under specified key\nfunc (m ConcurrentMap[K, V]) Has(key K) bool {\n\t// Get shard\n\tshard := m.GetShard(key)\n\tshard.RLock()\n\t// See if element is within shard.\n\t_, ok := shard.items[key]\n\tshard.RUnlock()\n\treturn ok\n}\n\n// Remove removes an element from the map.\nfunc (m ConcurrentMap[K, V]) Remove(key K) {\n\t// Try to get shard.\n\tshard := m.GetShard(key)\n\tshard.Lock()\n\tdelete(shard.items, key)\n\tshard.Unlock()\n}\n\n// RemoveCb is a callback executed in a map.RemoveCb() call, while Lock is held\n// If returns true, the element will be removed from the map\ntype RemoveCb[K any, V any] func(key K, v V, exists bool) bool\n\n// RemoveCb locks the shard containing the key, retrieves its current value and calls the callback with those params\n// If callback returns true and element exists, it will remove it from the map\n// Returns the value returned by the callback (even if element was not present in the map)\nfunc (m ConcurrentMap[K, V]) RemoveCb(key K, cb RemoveCb[K, V]) bool {\n\t// Try to get shard.\n\tshard := m.GetShard(key)\n\tshard.Lock()\n\tv, ok := shard.items[key]\n\tremove := cb(key, v, ok)\n\tif remove && ok {\n\t\tdelete(shard.items, key)\n\t}\n\tshard.Unlock()\n\treturn remove\n}\n\n// Pop removes an element from the map and returns it\nfunc (m ConcurrentMap[K, V]) Pop(key K) (v V, exists bool) {\n\t// Try to get shard.\n\tshard := m.GetShard(key)\n\tshard.Lock()\n\tv, exists = shard.items[key]\n\tdelete(shard.items, key)\n\tshard.Unlock()\n\treturn v, exists\n}\n\n// IsEmpty checks if map is empty.\nfunc (m ConcurrentMap[K, V]) IsEmpty() bool {\n\treturn m.Count() == 0\n}\n\n// Used by the Iter & IterBuffered functions to wrap two variables together over a channel,\ntype Tuple[K comparable, V any] struct {\n\tKey K\n\tVal V\n}\n\n// Iter returns an iterator which could be used in a for range loop.\n//\n// Deprecated: using IterBuffered() will get a better performence\nfunc (m ConcurrentMap[K, V]) Iter() <-chan Tuple[K, V] {\n\tchans := snapshot(m)\n\tch := make(chan Tuple[K, V])\n\tgo fanIn(chans, ch)\n\treturn ch\n}\n\n// IterBuffered returns a buffered iterator which could be used in a for range loop.\nfunc (m ConcurrentMap[K, V]) IterBuffered() <-chan Tuple[K, V] {\n\tchans := snapshot(m)\n\ttotal := 0\n\tfor _, c := range chans {\n\t\ttotal += cap(c)\n\t}\n\tch := make(chan Tuple[K, V], total)\n\tgo fanIn(chans, ch)\n\treturn ch\n}\n\n// Clear removes all items from map.\nfunc (m ConcurrentMap[K, V]) Clear() {\n\tfor item := range m.IterBuffered() {\n\t\tm.Remove(item.Key)\n\t}\n}\n\n// Returns a array of channels that contains elements in each shard,\n// which likely takes a snapshot of `m`.\n// It returns once the size of each buffered channel is determined,\n// before all the channels are populated using goroutines.\nfunc snapshot[K comparable, V any](m ConcurrentMap[K, V]) (chans []chan Tuple[K, V]) {\n\t//When you access map items before initializing.\n\tif len(m.shards) == 0 {\n\t\tpanic(`cmap.ConcurrentMap is not initialized. Should run New() before usage.`)\n\t}\n\tchans = make([]chan Tuple[K, V], SHARD_COUNT)\n\twg := sync.WaitGroup{}\n\twg.Add(SHARD_COUNT)\n\t// Foreach shard.\n\tfor index, shard := range m.shards {\n\t\tgo func(index int, shard *ConcurrentMapShared[K, V]) {\n\t\t\t// Foreach key, value pair.\n\t\t\tshard.RLock()\n\t\t\tchans[index] = make(chan Tuple[K, V], len(shard.items))\n\t\t\twg.Done()\n\t\t\tfor key, val := range shard.items {\n\t\t\t\tchans[index] <- Tuple[K, V]{key, val}\n\t\t\t}\n\t\t\tshard.RUnlock()\n\t\t\tclose(chans[index])\n\t\t}(index, shard)\n\t}\n\twg.Wait()\n\treturn chans\n}\n\n// fanIn reads elements from channels `chans` into channel `out`\nfunc fanIn[K comparable, V any](chans []chan Tuple[K, V], out chan Tuple[K, V]) {\n\twg := sync.WaitGroup{}\n\twg.Add(len(chans))\n\tfor _, ch := range chans {\n\t\tgo func(ch chan Tuple[K, V]) {\n\t\t\tfor t := range ch {\n\t\t\t\tout <- t\n\t\t\t}\n\t\t\twg.Done()\n\t\t}(ch)\n\t}\n\twg.Wait()\n\tclose(out)\n}\n\n// Items returns all items as map[string]V\nfunc (m ConcurrentMap[K, V]) Items() map[K]V {\n\ttmp := make(map[K]V)\n\n\t// Insert items to temporary map.\n\tfor item := range m.IterBuffered() {\n\t\ttmp[item.Key] = item.Val\n\t}\n\n\treturn tmp\n}\n\n// Iterator callbacalled for every key,value found in\n// maps. RLock is held for all calls for a given shard\n// therefore callback sess consistent view of a shard,\n// but not across the shards\ntype IterCb[K comparable, V any] func(key K, v V)\n\n// Callback based iterator, cheapest way to read\n// all elements in a map.\nfunc (m ConcurrentMap[K, V]) IterCb(fn IterCb[K, V]) {\n\tfor idx := range m.shards {\n\t\tshard := (m.shards)[idx]\n\t\tshard.RLock()\n\t\tfor key, value := range shard.items {\n\t\t\tfn(key, value)\n\t\t}\n\t\tshard.RUnlock()\n\t}\n}\n\n// Keys returns all keys as []string\nfunc (m ConcurrentMap[K, V]) Keys() []K {\n\tcount := m.Count()\n\tch := make(chan K, count)\n\tgo func() {\n\t\t// Foreach shard.\n\t\twg := sync.WaitGroup{}\n\t\twg.Add(SHARD_COUNT)\n\t\tfor _, shard := range m.shards {\n\t\t\tgo func(shard *ConcurrentMapShared[K, V]) {\n\t\t\t\t// Foreach key, value pair.\n\t\t\t\tshard.RLock()\n\t\t\t\tfor key := range shard.items {\n\t\t\t\t\tch <- key\n\t\t\t\t}\n\t\t\t\tshard.RUnlock()\n\t\t\t\twg.Done()\n\t\t\t}(shard)\n\t\t}\n\t\twg.Wait()\n\t\tclose(ch)\n\t}()\n\n\t// Generate keys\n\tkeys := make([]K, 0, count)\n\tfor k := range ch {\n\t\tkeys = append(keys, k)\n\t}\n\treturn keys\n}\n\n// Reviles ConcurrentMap \"private\" variables to json marshal.\nfunc (m ConcurrentMap[K, V]) MarshalJSON() ([]byte, error) {\n\t// Create a temporary map, which will hold all item spread across shards.\n\ttmp := make(map[K]V)\n\n\t// Insert items to temporary map.\n\tfor item := range m.IterBuffered() {\n\t\ttmp[item.Key] = item.Val\n\t}\n\treturn json.Marshal(tmp)\n}\nfunc strfnv32[K fmt.Stringer](key K) uint32 {\n\treturn fnv32(key.String())\n}\n\nfunc fnv32(key string) uint32 {\n\thash := uint32(2166136261)\n\tconst prime32 = uint32(16777619)\n\tkeyLength := len(key)\n\tfor i := 0; i < keyLength; i++ {\n\t\thash *= prime32\n\t\thash ^= uint32(key[i])\n\t}\n\treturn hash\n}\n\n// Reverse process of Marshal.\nfunc (m *ConcurrentMap[K, V]) UnmarshalJSON(b []byte) (err error) {\n\ttmp := make(map[K]V)\n\n\t// Unmarshal into a single map.\n\tif err := json.Unmarshal(b, &tmp); err != nil {\n\t\treturn err\n\t}\n\n\t// foreach key,value pair in temporary map insert into our concurrent map.\n\tfor key, val := range tmp {\n\t\tm.Set(key, val)\n\t}\n\treturn nil\n}\n"
        },
        {
          "name": "concurrent_map_bench_test.go",
          "type": "blob",
          "size": 7.4072265625,
          "content": "package cmap\n\nimport (\n\t\"strconv\"\n\t\"sync\"\n\t\"testing\"\n)\n\ntype Integer int\n\nfunc (i Integer) String() string {\n\treturn strconv.Itoa(int(i))\n}\n\nfunc BenchmarkItems(b *testing.B) {\n\tm := New[Animal]()\n\n\t// Insert 100 elements.\n\tfor i := 0; i < 10000; i++ {\n\t\tm.Set(strconv.Itoa(i), Animal{strconv.Itoa(i)})\n\t}\n\tfor i := 0; i < b.N; i++ {\n\t\tm.Items()\n\t}\n}\n\nfunc BenchmarkItemsInteger(b *testing.B) {\n\tm := NewStringer[Integer, Animal]()\n\n\t// Insert 100 elements.\n\tfor i := 0; i < 10000; i++ {\n\t\tm.Set((Integer)(i), Animal{strconv.Itoa(i)})\n\t}\n\tfor i := 0; i < b.N; i++ {\n\t\tm.Items()\n\t}\n}\nfunc directSharding(key uint32) uint32 {\n\treturn key\n}\n\nfunc BenchmarkItemsInt(b *testing.B) {\n\tm := NewWithCustomShardingFunction[uint32, Animal](directSharding)\n\n\t// Insert 100 elements.\n\tfor i := 0; i < 10000; i++ {\n\t\tm.Set((uint32)(i), Animal{strconv.Itoa(i)})\n\t}\n\tfor i := 0; i < b.N; i++ {\n\t\tm.Items()\n\t}\n}\n\nfunc BenchmarkMarshalJson(b *testing.B) {\n\tm := New[Animal]()\n\n\t// Insert 100 elements.\n\tfor i := 0; i < 10000; i++ {\n\t\tm.Set(strconv.Itoa(i), Animal{strconv.Itoa(i)})\n\t}\n\tfor i := 0; i < b.N; i++ {\n\t\t_, err := m.MarshalJSON()\n\t\tif err != nil {\n\t\t\tb.FailNow()\n\t\t}\n\t}\n}\n\nfunc BenchmarkStrconv(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tstrconv.Itoa(i)\n\t}\n}\n\nfunc BenchmarkSingleInsertAbsent(b *testing.B) {\n\tm := New[string]()\n\tb.ResetTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\tm.Set(strconv.Itoa(i), \"value\")\n\t}\n}\n\nfunc BenchmarkSingleInsertAbsentSyncMap(b *testing.B) {\n\tvar m sync.Map\n\tb.ResetTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\tm.Store(strconv.Itoa(i), \"value\")\n\t}\n}\n\nfunc BenchmarkSingleInsertPresent(b *testing.B) {\n\tm := New[string]()\n\tm.Set(\"key\", \"value\")\n\tb.ResetTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\tm.Set(\"key\", \"value\")\n\t}\n}\n\nfunc BenchmarkSingleInsertPresentSyncMap(b *testing.B) {\n\tvar m sync.Map\n\tm.Store(\"key\", \"value\")\n\tb.ResetTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\tm.Store(\"key\", \"value\")\n\t}\n}\n\nfunc benchmarkMultiInsertDifferent(b *testing.B) {\n\tm := New[string]()\n\tfinished := make(chan struct{}, b.N)\n\t_, set := GetSet(m, finished)\n\tb.ResetTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\tgo set(strconv.Itoa(i), \"value\")\n\t}\n\tfor i := 0; i < b.N; i++ {\n\t\t<-finished\n\t}\n}\n\nfunc BenchmarkMultiInsertDifferentSyncMap(b *testing.B) {\n\tvar m sync.Map\n\tfinished := make(chan struct{}, b.N)\n\t_, set := GetSetSyncMap[string, string](&m, finished)\n\n\tb.ResetTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\tgo set(strconv.Itoa(i), \"value\")\n\t}\n\tfor i := 0; i < b.N; i++ {\n\t\t<-finished\n\t}\n}\n\nfunc BenchmarkMultiInsertDifferent_1_Shard(b *testing.B) {\n\trunWithShards(benchmarkMultiInsertDifferent, b, 1)\n}\nfunc BenchmarkMultiInsertDifferent_16_Shard(b *testing.B) {\n\trunWithShards(benchmarkMultiInsertDifferent, b, 16)\n}\nfunc BenchmarkMultiInsertDifferent_32_Shard(b *testing.B) {\n\trunWithShards(benchmarkMultiInsertDifferent, b, 32)\n}\nfunc BenchmarkMultiInsertDifferent_256_Shard(b *testing.B) {\n\trunWithShards(benchmarkMultiGetSetDifferent, b, 256)\n}\n\nfunc BenchmarkMultiInsertSame(b *testing.B) {\n\tm := New[string]()\n\tfinished := make(chan struct{}, b.N)\n\t_, set := GetSet(m, finished)\n\tm.Set(\"key\", \"value\")\n\tb.ResetTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\tgo set(\"key\", \"value\")\n\t}\n\tfor i := 0; i < b.N; i++ {\n\t\t<-finished\n\t}\n}\n\nfunc BenchmarkMultiInsertSameSyncMap(b *testing.B) {\n\tvar m sync.Map\n\tfinished := make(chan struct{}, b.N)\n\t_, set := GetSetSyncMap[string, string](&m, finished)\n\tm.Store(\"key\", \"value\")\n\tb.ResetTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\tgo set(\"key\", \"value\")\n\t}\n\tfor i := 0; i < b.N; i++ {\n\t\t<-finished\n\t}\n}\n\nfunc BenchmarkMultiGetSame(b *testing.B) {\n\tm := New[string]()\n\tfinished := make(chan struct{}, b.N)\n\tget, _ := GetSet(m, finished)\n\tm.Set(\"key\", \"value\")\n\tb.ResetTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\tgo get(\"key\", \"value\")\n\t}\n\tfor i := 0; i < b.N; i++ {\n\t\t<-finished\n\t}\n}\n\nfunc BenchmarkMultiGetSameSyncMap(b *testing.B) {\n\tvar m sync.Map\n\tfinished := make(chan struct{}, b.N)\n\tget, _ := GetSetSyncMap[string, string](&m, finished)\n\tm.Store(\"key\", \"value\")\n\tb.ResetTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\tgo get(\"key\", \"value\")\n\t}\n\tfor i := 0; i < b.N; i++ {\n\t\t<-finished\n\t}\n}\n\nfunc benchmarkMultiGetSetDifferent(b *testing.B) {\n\tm := New[string]()\n\tfinished := make(chan struct{}, 2*b.N)\n\tget, set := GetSet(m, finished)\n\tm.Set(\"-1\", \"value\")\n\tb.ResetTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\tgo set(strconv.Itoa(i-1), \"value\")\n\t\tgo get(strconv.Itoa(i), \"value\")\n\t}\n\tfor i := 0; i < 2*b.N; i++ {\n\t\t<-finished\n\t}\n}\n\nfunc BenchmarkMultiGetSetDifferentSyncMap(b *testing.B) {\n\tvar m sync.Map\n\tfinished := make(chan struct{}, 2*b.N)\n\tget, set := GetSetSyncMap[string, string](&m, finished)\n\tm.Store(\"-1\", \"value\")\n\tb.ResetTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\tgo set(strconv.Itoa(i-1), \"value\")\n\t\tgo get(strconv.Itoa(i), \"value\")\n\t}\n\tfor i := 0; i < 2*b.N; i++ {\n\t\t<-finished\n\t}\n}\n\nfunc BenchmarkMultiGetSetDifferent_1_Shard(b *testing.B) {\n\trunWithShards(benchmarkMultiGetSetDifferent, b, 1)\n}\nfunc BenchmarkMultiGetSetDifferent_16_Shard(b *testing.B) {\n\trunWithShards(benchmarkMultiGetSetDifferent, b, 16)\n}\nfunc BenchmarkMultiGetSetDifferent_32_Shard(b *testing.B) {\n\trunWithShards(benchmarkMultiGetSetDifferent, b, 32)\n}\nfunc BenchmarkMultiGetSetDifferent_256_Shard(b *testing.B) {\n\trunWithShards(benchmarkMultiGetSetDifferent, b, 256)\n}\n\nfunc benchmarkMultiGetSetBlock(b *testing.B) {\n\tm := New[string]()\n\tfinished := make(chan struct{}, 2*b.N)\n\tget, set := GetSet(m, finished)\n\tfor i := 0; i < b.N; i++ {\n\t\tm.Set(strconv.Itoa(i%100), \"value\")\n\t}\n\tb.ResetTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\tgo set(strconv.Itoa(i%100), \"value\")\n\t\tgo get(strconv.Itoa(i%100), \"value\")\n\t}\n\tfor i := 0; i < 2*b.N; i++ {\n\t\t<-finished\n\t}\n}\n\nfunc BenchmarkMultiGetSetBlockSyncMap(b *testing.B) {\n\tvar m sync.Map\n\tfinished := make(chan struct{}, 2*b.N)\n\tget, set := GetSetSyncMap[string, string](&m, finished)\n\tfor i := 0; i < b.N; i++ {\n\t\tm.Store(strconv.Itoa(i%100), \"value\")\n\t}\n\tb.ResetTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\tgo set(strconv.Itoa(i%100), \"value\")\n\t\tgo get(strconv.Itoa(i%100), \"value\")\n\t}\n\tfor i := 0; i < 2*b.N; i++ {\n\t\t<-finished\n\t}\n}\n\nfunc BenchmarkMultiGetSetBlock_1_Shard(b *testing.B) {\n\trunWithShards(benchmarkMultiGetSetBlock, b, 1)\n}\nfunc BenchmarkMultiGetSetBlock_16_Shard(b *testing.B) {\n\trunWithShards(benchmarkMultiGetSetBlock, b, 16)\n}\nfunc BenchmarkMultiGetSetBlock_32_Shard(b *testing.B) {\n\trunWithShards(benchmarkMultiGetSetBlock, b, 32)\n}\nfunc BenchmarkMultiGetSetBlock_256_Shard(b *testing.B) {\n\trunWithShards(benchmarkMultiGetSetBlock, b, 256)\n}\n\n\nfunc GetSet[K comparable, V any](m ConcurrentMap[K, V], finished chan struct{}) (set func(key K, value V), get func(key K, value V)) {\n\treturn func(key K, value V) {\n\t\t\tfor i := 0; i < 10; i++ {\n\t\t\t\tm.Get(key)\n\t\t\t}\n\t\t\tfinished <- struct{}{}\n\t\t}, func(key K, value V) {\n\t\t\tfor i := 0; i < 10; i++ {\n\t\t\t\tm.Set(key, value)\n\t\t\t}\n\t\t\tfinished <- struct{}{}\n\t\t}\n}\n\nfunc GetSetSyncMap[K comparable, V any](m *sync.Map, finished chan struct{}) (get func(key K, value V), set func(key K, value V)) {\n\tget = func(key K, value V) {\n\t\tfor i := 0; i < 10; i++ {\n\t\t\tm.Load(key)\n\t\t}\n\t\tfinished <- struct{}{}\n\t}\n\tset = func(key K, value V) {\n\t\tfor i := 0; i < 10; i++ {\n\t\t\tm.Store(key, value)\n\t\t}\n\t\tfinished <- struct{}{}\n\t}\n\treturn\n}\n\nfunc runWithShards(bench func(b *testing.B), b *testing.B, shardsCount int) {\n\toldShardsCount := SHARD_COUNT\n\tSHARD_COUNT = shardsCount\n\tbench(b)\n\tSHARD_COUNT = oldShardsCount\n}\n\nfunc BenchmarkKeys(b *testing.B) {\n\tm := New[Animal]()\n\n\t// Insert 100 elements.\n\tfor i := 0; i < 10000; i++ {\n\t\tm.Set(strconv.Itoa(i), Animal{strconv.Itoa(i)})\n\t}\n\tfor i := 0; i < b.N; i++ {\n\t\tm.Keys()\n\t}\n}\n"
        },
        {
          "name": "concurrent_map_test.go",
          "type": "blob",
          "size": 11.619140625,
          "content": "package cmap\n\nimport (\n\t\"encoding/json\"\n\t\"hash/fnv\"\n\t\"sort\"\n\t\"strconv\"\n\t\"testing\"\n)\n\ntype Animal struct {\n\tname string\n}\n\nfunc TestMapCreation(t *testing.T) {\n\tm := New[string]()\n\tif m.shards == nil {\n\t\tt.Error(\"map is null.\")\n\t}\n\n\tif m.Count() != 0 {\n\t\tt.Error(\"new map should be empty.\")\n\t}\n}\n\nfunc TestInsert(t *testing.T) {\n\tm := New[Animal]()\n\telephant := Animal{\"elephant\"}\n\tmonkey := Animal{\"monkey\"}\n\n\tm.Set(\"elephant\", elephant)\n\tm.Set(\"monkey\", monkey)\n\n\tif m.Count() != 2 {\n\t\tt.Error(\"map should contain exactly two elements.\")\n\t}\n}\n\nfunc TestInsertAbsent(t *testing.T) {\n\tm := New[Animal]()\n\telephant := Animal{\"elephant\"}\n\tmonkey := Animal{\"monkey\"}\n\n\tm.SetIfAbsent(\"elephant\", elephant)\n\tif ok := m.SetIfAbsent(\"elephant\", monkey); ok {\n\t\tt.Error(\"map set a new value even the entry is already present\")\n\t}\n}\n\nfunc TestGet(t *testing.T) {\n\tm := New[Animal]()\n\n\t// Get a missing element.\n\tval, ok := m.Get(\"Money\")\n\n\tif ok == true {\n\t\tt.Error(\"ok should be false when item is missing from map.\")\n\t}\n\n\tif (val != Animal{}) {\n\t\tt.Error(\"Missing values should return as null.\")\n\t}\n\n\telephant := Animal{\"elephant\"}\n\tm.Set(\"elephant\", elephant)\n\n\t// Retrieve inserted element.\n\telephant, ok = m.Get(\"elephant\")\n\tif ok == false {\n\t\tt.Error(\"ok should be true for item stored within the map.\")\n\t}\n\n\tif elephant.name != \"elephant\" {\n\t\tt.Error(\"item was modified.\")\n\t}\n}\n\nfunc TestHas(t *testing.T) {\n\tm := New[Animal]()\n\n\t// Get a missing element.\n\tif m.Has(\"Money\") == true {\n\t\tt.Error(\"element shouldn't exists\")\n\t}\n\n\telephant := Animal{\"elephant\"}\n\tm.Set(\"elephant\", elephant)\n\n\tif m.Has(\"elephant\") == false {\n\t\tt.Error(\"element exists, expecting Has to return True.\")\n\t}\n}\n\nfunc TestRemove(t *testing.T) {\n\tm := New[Animal]()\n\n\tmonkey := Animal{\"monkey\"}\n\tm.Set(\"monkey\", monkey)\n\n\tm.Remove(\"monkey\")\n\n\tif m.Count() != 0 {\n\t\tt.Error(\"Expecting count to be zero once item was removed.\")\n\t}\n\n\ttemp, ok := m.Get(\"monkey\")\n\n\tif ok != false {\n\t\tt.Error(\"Expecting ok to be false for missing items.\")\n\t}\n\n\tif (temp != Animal{}) {\n\t\tt.Error(\"Expecting item to be nil after its removal.\")\n\t}\n\n\t// Remove a none existing element.\n\tm.Remove(\"noone\")\n}\n\nfunc TestRemoveCb(t *testing.T) {\n\tm := New[Animal]()\n\n\tmonkey := Animal{\"monkey\"}\n\tm.Set(\"monkey\", monkey)\n\telephant := Animal{\"elephant\"}\n\tm.Set(\"elephant\", elephant)\n\n\tvar (\n\t\tmapKey   string\n\t\tmapVal   Animal\n\t\twasFound bool\n\t)\n\tcb := func(key string, val Animal, exists bool) bool {\n\t\tmapKey = key\n\t\tmapVal = val\n\t\twasFound = exists\n\n\t\treturn val.name == \"monkey\"\n\t}\n\n\t// Monkey should be removed\n\tresult := m.RemoveCb(\"monkey\", cb)\n\tif !result {\n\t\tt.Errorf(\"Result was not true\")\n\t}\n\n\tif mapKey != \"monkey\" {\n\t\tt.Error(\"Wrong key was provided to the callback\")\n\t}\n\n\tif mapVal != monkey {\n\t\tt.Errorf(\"Wrong value was provided to the value\")\n\t}\n\n\tif !wasFound {\n\t\tt.Errorf(\"Key was not found\")\n\t}\n\n\tif m.Has(\"monkey\") {\n\t\tt.Errorf(\"Key was not removed\")\n\t}\n\n\t// Elephant should not be removed\n\tresult = m.RemoveCb(\"elephant\", cb)\n\tif result {\n\t\tt.Errorf(\"Result was true\")\n\t}\n\n\tif mapKey != \"elephant\" {\n\t\tt.Error(\"Wrong key was provided to the callback\")\n\t}\n\n\tif mapVal != elephant {\n\t\tt.Errorf(\"Wrong value was provided to the value\")\n\t}\n\n\tif !wasFound {\n\t\tt.Errorf(\"Key was not found\")\n\t}\n\n\tif !m.Has(\"elephant\") {\n\t\tt.Errorf(\"Key was removed\")\n\t}\n\n\t// Unset key should remain unset\n\tresult = m.RemoveCb(\"horse\", cb)\n\tif result {\n\t\tt.Errorf(\"Result was true\")\n\t}\n\n\tif mapKey != \"horse\" {\n\t\tt.Error(\"Wrong key was provided to the callback\")\n\t}\n\n\tif (mapVal != Animal{}) {\n\t\tt.Errorf(\"Wrong value was provided to the value\")\n\t}\n\n\tif wasFound {\n\t\tt.Errorf(\"Key was found\")\n\t}\n\n\tif m.Has(\"horse\") {\n\t\tt.Errorf(\"Key was created\")\n\t}\n}\n\nfunc TestPop(t *testing.T) {\n\tm := New[Animal]()\n\n\tmonkey := Animal{\"monkey\"}\n\tm.Set(\"monkey\", monkey)\n\n\tv, exists := m.Pop(\"monkey\")\n\n\tif !exists || v != monkey {\n\t\tt.Error(\"Pop didn't find a monkey.\")\n\t}\n\n\tv2, exists2 := m.Pop(\"monkey\")\n\n\tif exists2 || v2 == monkey {\n\t\tt.Error(\"Pop keeps finding monkey\")\n\t}\n\n\tif m.Count() != 0 {\n\t\tt.Error(\"Expecting count to be zero once item was Pop'ed.\")\n\t}\n\n\ttemp, ok := m.Get(\"monkey\")\n\n\tif ok != false {\n\t\tt.Error(\"Expecting ok to be false for missing items.\")\n\t}\n\n\tif (temp != Animal{}) {\n\t\tt.Error(\"Expecting item to be nil after its removal.\")\n\t}\n}\n\nfunc TestCount(t *testing.T) {\n\tm := New[Animal]()\n\tfor i := 0; i < 100; i++ {\n\t\tm.Set(strconv.Itoa(i), Animal{strconv.Itoa(i)})\n\t}\n\n\tif m.Count() != 100 {\n\t\tt.Error(\"Expecting 100 element within map.\")\n\t}\n}\n\nfunc TestIsEmpty(t *testing.T) {\n\tm := New[Animal]()\n\n\tif m.IsEmpty() == false {\n\t\tt.Error(\"new map should be empty\")\n\t}\n\n\tm.Set(\"elephant\", Animal{\"elephant\"})\n\n\tif m.IsEmpty() != false {\n\t\tt.Error(\"map shouldn't be empty.\")\n\t}\n}\n\nfunc TestIterator(t *testing.T) {\n\tm := New[Animal]()\n\n\t// Insert 100 elements.\n\tfor i := 0; i < 100; i++ {\n\t\tm.Set(strconv.Itoa(i), Animal{strconv.Itoa(i)})\n\t}\n\n\tcounter := 0\n\t// Iterate over elements.\n\tfor item := range m.Iter() {\n\t\tval := item.Val\n\n\t\tif (val == Animal{}) {\n\t\t\tt.Error(\"Expecting an object.\")\n\t\t}\n\t\tcounter++\n\t}\n\n\tif counter != 100 {\n\t\tt.Error(\"We should have counted 100 elements.\")\n\t}\n}\n\nfunc TestBufferedIterator(t *testing.T) {\n\tm := New[Animal]()\n\n\t// Insert 100 elements.\n\tfor i := 0; i < 100; i++ {\n\t\tm.Set(strconv.Itoa(i), Animal{strconv.Itoa(i)})\n\t}\n\n\tcounter := 0\n\t// Iterate over elements.\n\tfor item := range m.IterBuffered() {\n\t\tval := item.Val\n\n\t\tif (val == Animal{}) {\n\t\t\tt.Error(\"Expecting an object.\")\n\t\t}\n\t\tcounter++\n\t}\n\n\tif counter != 100 {\n\t\tt.Error(\"We should have counted 100 elements.\")\n\t}\n}\n\nfunc TestClear(t *testing.T) {\n\tm := New[Animal]()\n\n\t// Insert 100 elements.\n\tfor i := 0; i < 100; i++ {\n\t\tm.Set(strconv.Itoa(i), Animal{strconv.Itoa(i)})\n\t}\n\n\tm.Clear()\n\n\tif m.Count() != 0 {\n\t\tt.Error(\"We should have 0 elements.\")\n\t}\n}\n\nfunc TestIterCb(t *testing.T) {\n\tm := New[Animal]()\n\n\t// Insert 100 elements.\n\tfor i := 0; i < 100; i++ {\n\t\tm.Set(strconv.Itoa(i), Animal{strconv.Itoa(i)})\n\t}\n\n\tcounter := 0\n\t// Iterate over elements.\n\tm.IterCb(func(key string, v Animal) {\n\t\tcounter++\n\t})\n\tif counter != 100 {\n\t\tt.Error(\"We should have counted 100 elements.\")\n\t}\n}\n\nfunc TestItems(t *testing.T) {\n\tm := New[Animal]()\n\n\t// Insert 100 elements.\n\tfor i := 0; i < 100; i++ {\n\t\tm.Set(strconv.Itoa(i), Animal{strconv.Itoa(i)})\n\t}\n\n\titems := m.Items()\n\n\tif len(items) != 100 {\n\t\tt.Error(\"We should have counted 100 elements.\")\n\t}\n}\n\nfunc TestConcurrent(t *testing.T) {\n\tm := New[int]()\n\tch := make(chan int)\n\tconst iterations = 1000\n\tvar a [iterations]int\n\n\t// Using go routines insert 1000 ints into our map.\n\tgo func() {\n\t\tfor i := 0; i < iterations/2; i++ {\n\t\t\t// Add item to map.\n\t\t\tm.Set(strconv.Itoa(i), i)\n\n\t\t\t// Retrieve item from map.\n\t\t\tval, _ := m.Get(strconv.Itoa(i))\n\n\t\t\t// Write to channel inserted value.\n\t\t\tch <- val\n\t\t} // Call go routine with current index.\n\t}()\n\n\tgo func() {\n\t\tfor i := iterations / 2; i < iterations; i++ {\n\t\t\t// Add item to map.\n\t\t\tm.Set(strconv.Itoa(i), i)\n\n\t\t\t// Retrieve item from map.\n\t\t\tval, _ := m.Get(strconv.Itoa(i))\n\n\t\t\t// Write to channel inserted value.\n\t\t\tch <- val\n\t\t} // Call go routine with current index.\n\t}()\n\n\t// Wait for all go routines to finish.\n\tcounter := 0\n\tfor elem := range ch {\n\t\ta[counter] = elem\n\t\tcounter++\n\t\tif counter == iterations {\n\t\t\tbreak\n\t\t}\n\t}\n\n\t// Sorts array, will make is simpler to verify all inserted values we're returned.\n\tsort.Ints(a[0:iterations])\n\n\t// Make sure map contains 1000 elements.\n\tif m.Count() != iterations {\n\t\tt.Error(\"Expecting 1000 elements.\")\n\t}\n\n\t// Make sure all inserted values we're fetched from map.\n\tfor i := 0; i < iterations; i++ {\n\t\tif i != a[i] {\n\t\t\tt.Error(\"missing value\", i)\n\t\t}\n\t}\n}\n\nfunc TestJsonMarshal(t *testing.T) {\n\tSHARD_COUNT = 2\n\tdefer func() {\n\t\tSHARD_COUNT = 32\n\t}()\n\texpected := \"{\\\"a\\\":1,\\\"b\\\":2}\"\n\tm := New[int]()\n\tm.Set(\"a\", 1)\n\tm.Set(\"b\", 2)\n\tj, err := json.Marshal(m)\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n\n\tif string(j) != expected {\n\t\tt.Error(\"json\", string(j), \"differ from expected\", expected)\n\t\treturn\n\t}\n}\n\nfunc TestKeys(t *testing.T) {\n\tm := New[Animal]()\n\n\t// Insert 100 elements.\n\tfor i := 0; i < 100; i++ {\n\t\tm.Set(strconv.Itoa(i), Animal{strconv.Itoa(i)})\n\t}\n\n\tkeys := m.Keys()\n\tif len(keys) != 100 {\n\t\tt.Error(\"We should have counted 100 elements.\")\n\t}\n}\n\nfunc TestMInsert(t *testing.T) {\n\tanimals := map[string]Animal{\n\t\t\"elephant\": {\"elephant\"},\n\t\t\"monkey\":   {\"monkey\"},\n\t}\n\tm := New[Animal]()\n\tm.MSet(animals)\n\n\tif m.Count() != 2 {\n\t\tt.Error(\"map should contain exactly two elements.\")\n\t}\n}\n\nfunc TestFnv32(t *testing.T) {\n\tkey := []byte(\"ABC\")\n\n\thasher := fnv.New32()\n\t_, err := hasher.Write(key)\n\tif err != nil {\n\t\tt.Errorf(err.Error())\n\t}\n\tif fnv32(string(key)) != hasher.Sum32() {\n\t\tt.Errorf(\"Bundled fnv32 produced %d, expected result from hash/fnv32 is %d\", fnv32(string(key)), hasher.Sum32())\n\t}\n\n}\n\nfunc TestUpsert(t *testing.T) {\n\tdolphin := Animal{\"dolphin\"}\n\twhale := Animal{\"whale\"}\n\ttiger := Animal{\"tiger\"}\n\tlion := Animal{\"lion\"}\n\n\tcb := func(exists bool, valueInMap Animal, newValue Animal) Animal {\n\t\tif !exists {\n\t\t\treturn newValue\n\t\t}\n\t\tvalueInMap.name += newValue.name\n\t\treturn valueInMap\n\t}\n\n\tm := New[Animal]()\n\tm.Set(\"marine\", dolphin)\n\tm.Upsert(\"marine\", whale, cb)\n\tm.Upsert(\"predator\", tiger, cb)\n\tm.Upsert(\"predator\", lion, cb)\n\n\tif m.Count() != 2 {\n\t\tt.Error(\"map should contain exactly two elements.\")\n\t}\n\n\tmarineAnimals, ok := m.Get(\"marine\")\n\tif marineAnimals.name != \"dolphinwhale\" || !ok {\n\t\tt.Error(\"Set, then Upsert failed\")\n\t}\n\n\tpredators, ok := m.Get(\"predator\")\n\tif !ok || predators.name != \"tigerlion\" {\n\t\tt.Error(\"Upsert, then Upsert failed\")\n\t}\n}\n\nfunc TestKeysWhenRemoving(t *testing.T) {\n\tm := New[Animal]()\n\n\t// Insert 100 elements.\n\tTotal := 100\n\tfor i := 0; i < Total; i++ {\n\t\tm.Set(strconv.Itoa(i), Animal{strconv.Itoa(i)})\n\t}\n\n\t// Remove 10 elements concurrently.\n\tNum := 10\n\tfor i := 0; i < Num; i++ {\n\t\tgo func(c *ConcurrentMap[string, Animal], n int) {\n\t\t\tc.Remove(strconv.Itoa(n))\n\t\t}(&m, i)\n\t}\n\tkeys := m.Keys()\n\tfor _, k := range keys {\n\t\tif k == \"\" {\n\t\t\tt.Error(\"Empty keys returned\")\n\t\t}\n\t}\n}\n\nfunc TestUnDrainedIter(t *testing.T) {\n\tm := New[Animal]()\n\t// Insert 100 elements.\n\tTotal := 100\n\tfor i := 0; i < Total; i++ {\n\t\tm.Set(strconv.Itoa(i), Animal{strconv.Itoa(i)})\n\t}\n\tcounter := 0\n\t// Iterate over elements.\n\tch := m.Iter()\n\tfor item := range ch {\n\t\tval := item.Val\n\n\t\tif (val == Animal{}) {\n\t\t\tt.Error(\"Expecting an object.\")\n\t\t}\n\t\tcounter++\n\t\tif counter == 42 {\n\t\t\tbreak\n\t\t}\n\t}\n\tfor i := Total; i < 2*Total; i++ {\n\t\tm.Set(strconv.Itoa(i), Animal{strconv.Itoa(i)})\n\t}\n\tfor item := range ch {\n\t\tval := item.Val\n\n\t\tif (val == Animal{}) {\n\t\t\tt.Error(\"Expecting an object.\")\n\t\t}\n\t\tcounter++\n\t}\n\n\tif counter != 100 {\n\t\tt.Error(\"We should have been right where we stopped\")\n\t}\n\n\tcounter = 0\n\tfor item := range m.IterBuffered() {\n\t\tval := item.Val\n\n\t\tif (val == Animal{}) {\n\t\t\tt.Error(\"Expecting an object.\")\n\t\t}\n\t\tcounter++\n\t}\n\n\tif counter != 200 {\n\t\tt.Error(\"We should have counted 200 elements.\")\n\t}\n}\n\nfunc TestUnDrainedIterBuffered(t *testing.T) {\n\tm := New[Animal]()\n\t// Insert 100 elements.\n\tTotal := 100\n\tfor i := 0; i < Total; i++ {\n\t\tm.Set(strconv.Itoa(i), Animal{strconv.Itoa(i)})\n\t}\n\tcounter := 0\n\t// Iterate over elements.\n\tch := m.IterBuffered()\n\tfor item := range ch {\n\t\tval := item.Val\n\n\t\tif (val == Animal{}) {\n\t\t\tt.Error(\"Expecting an object.\")\n\t\t}\n\t\tcounter++\n\t\tif counter == 42 {\n\t\t\tbreak\n\t\t}\n\t}\n\tfor i := Total; i < 2*Total; i++ {\n\t\tm.Set(strconv.Itoa(i), Animal{strconv.Itoa(i)})\n\t}\n\tfor item := range ch {\n\t\tval := item.Val\n\n\t\tif (val == Animal{}) {\n\t\t\tt.Error(\"Expecting an object.\")\n\t\t}\n\t\tcounter++\n\t}\n\n\tif counter != 100 {\n\t\tt.Error(\"We should have been right where we stopped\")\n\t}\n\n\tcounter = 0\n\tfor item := range m.IterBuffered() {\n\t\tval := item.Val\n\n\t\tif (val == Animal{}) {\n\t\t\tt.Error(\"Expecting an object.\")\n\t\t}\n\t\tcounter++\n\t}\n\n\tif counter != 200 {\n\t\tt.Error(\"We should have counted 200 elements.\")\n\t}\n}\n"
        },
        {
          "name": "go.mod",
          "type": "blob",
          "size": 0.0517578125,
          "content": "module github.com/orcaman/concurrent-map/v2\n\ngo 1.18\n"
        }
      ]
    }
  ]
}