{
  "metadata": {
    "timestamp": 1736566687690,
    "page": 243,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjI1MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "volatiletech/authboss",
      "stars": 3892,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.3388671875,
          "content": "# Compiled Object files, Static and Dynamic libs (Shared Objects)\r\n*.o\r\n*.a\r\n*.so\r\n\r\n# Folders\r\n_obj\r\n_test\r\n\r\n# Architecture specific extensions/prefixes\r\n*.[568vq]\r\n[568vq].out\r\n\r\n*.cgo1.go\r\n*.cgo2.c\r\n_cgo_defun.c\r\n_cgo_gotypes.go\r\n_cgo_export.*\r\n\r\n_testmain.go\r\n\r\n*.exe\r\n*.test\r\n*.prof\r\n*.out\r\n\r\n*.iml\r\n.idea\r\n\r\ndefaults/smtp_mailer_test.json\r\n"
        },
        {
          "name": "CHANGELOG.md",
          "type": "blob",
          "size": 16.3662109375,
          "content": "# Changelog\n\nThe format is based on [Keep a Changelog](http://keepachangelog.com/en/1.0.0/)\nand this project adheres to [Semantic Versioning](http://semver.org/spec/v2.0.0.html).\n\n## [3.5.0] - 2023-12-30\n\n### Added\n\n- Localization interface (thanks @stepehenafamo)\n\n- ### Security\n\n- Bump crypto dependency\n\n## [3.4.0] - 2023-11-19\n\n### Added\n\n- Configurable hashing (thanks @larrycinnabar, @stephenafamo)\n- Compatability with http.ResponseController.Unwrap interface (thanks @stephenafamo)\n\n### Security\n\n- Bump dependencies, change min Go version to 1.20\n\n## [3.3.0] - 2023-09-28\n\n### Added\n\n- Added a way for storers to present secondary emails for recovery.\n\n### Security\n\n- Fix a critical issue in totp backup code rejection\n\n## [3.2.2] - 2023-03-12\n\n### Security\n\n- Upgrade dependencies\n\n## [3.2.1] - 2022-10-10\n\n### Security\n\n- Change it such that events are fired around recovery. Some important events\n  were not occurring despite being logged in that would manage state like\n  remember cookies, locking state, etc.\n\n  A significant side effect of this is that when 2fa is currently turned on on\n  an account, it could be bypassed by using the Recover functionality with the\n  `RecoverLoginAfterRecovery` feature which was not otherwise flagged as a\n  dangerous option.\n\n  While it is true that recover uses an email to invoke the flow and therefore\n  some second factor has been utilizied, it should be considered insecure to\n  bypass an authenticator or sms verification for any login and therefore\n  this large change in behavior is being shipped as a security fix (meaning it\n  becomes a minor change).\n\n## [3.2.0] - 2021-08-11\n\n### Added\n\n- Add additional events so users can take domain-specific actions when a user\n  adds or removes 2fa.\n\n## [3.1.1] - 2021-07-01\n\n### Fixed\n\n- Fix a test that had gone red\n\n## [3.1.0] - 2021-07-01\n\n### Added\n\n- Add an optional interface in totp2fa that when implemented on the authboss\n  User struct can prevent re-use of totp 2fa codes. This normally should have\n  been a requirement for this module's usage but due to backward compatibility\n  it's being added as optional and will become mandatory in the next major\n  version.\n\n### Changed\n\n- Change totp/sms email validation to delete the \"email validation\" session\n  key after successfully adding 2fa to an account. This requires a second\n  email verification in the same session if a user deletes and re-adds\n  2fa. This change is a behavior change but is not worthy of a larger version\n  bump and should slightly increase security.\n- Change \"Successfully Authenticated\" flash message when logging in with\n  totp/sms 2fa methods. This was a difference between logging in with the\n  auth module. It now has no flash message.\n\n## [3.0.5] - 2021-05-18\n\n- Fix an open redirect security issue. This is technically a breaking change\n  if you are redirecting to some other site or front-end that's not on your\n  server.\n\n## [3.0.4] - 2021-04-27\n\n### Changed\n\n- Change qrcode endpoint for totp to try to prevent caching\n\n## [3.0.3] - 2021-02-14\n\n### Fixed\n\n- Fix that EventRecoverStart/EventRecoverEnd were not being called.\n\n### Changed\n\n- Change Remember module to listen to `After(EventRecoverEnd)` in order to\n  invoke its handler to delete the remember cookie & tokens. This previously\n  was not being called so it could be viewed as new behavior though this only\n  applies if you are using both `remember` and `recover` modules.\n\n### Deprecate\n\n- EventPasswordReset is used nowhere and is no longer intended to be used.\n\n## [3.0.2] - 2020-09-17\n\n### Fixed\n\n- Fix an open redirect security issue. This is technically a breaking change\n  if you are redirecting to some other site or front-end that's not on your\n  server.\n\n## [3.0.1] - 2020-08-25\n\n### Added\n\n- Add the ability to carry query string parameters in the redirection to and\n  away from the login page.\n\n## [3.0.0] - 2020-07-03\n\n### Added\n\n- Move to Go modules\n\n## [2.4.1] - 2020-05-18\n\n### Fixed\n\nFix a security issue where a user could brute-force a password based on\ndiffering responses that are returned from the site when the incorrect password\nis entered versus the correct password.\n\nThis comes with a slight change in behavior to minimize differences between the\ncode paths of a correct vs incorrect password: The \"attempt\" time is always\nbumped in the DB no matter if it was the right or wrong password when being\nrejected for locking.\n\n## [2.4.0] - 2020-02-07\n\n### Added\n\n- Add config option MailNoGoroutine which prevents the modules from using a\n  goroutine to launch the mailer. This is important because the context\n  that it passes from the http request will be cancelled in a race condition\n  and will affect mailer implementations that honor context cancellation.\n\n## [2.3.2] - 2020-01-30\n\n### Fixed\n\n- Fix many \"lint\" type errors (thanks @frederikhors)\n\n## [2.3.1] - 2020-01-28\n\n### Added\n\n- Logout events (Before & After) for deletion of a users session\n  (thanks @abelkuruvilla)\n\n### Changed\n\n- Calls to Email() will now merge ctx data from the passed in ctx so it's\n  available in the template, just like calls to Render() (thanks @Gys)\n\n### Fixed\n\n- Fix one of the mocks that were no longer in sync with an interface\n\n## [2.3.0] - 2019-03-30\n\n### Added\n\n- Add VerifyPassword method to hide the bcrypt implementation details when\n  authboss consumer code wants to verify the password out of band.\n- ClientStateResponseWriter now supports the http.Hijacker interface if the\n  underlying ResponseWriter does (thanks @tobias-kuendig)\n- DelAllSession is a new method called both by Expire and Logout (in addition\n  to still calling DelKnownSession etc. as they do now) to ensure that\n  conforming implementations of ClientStateReadWriter's delete all keys\n  in the session.\n- Config.Storage.SessionWhitelistKeys has been added in order to allow users\n  to persist session variables past logout/expire.\n\n### Fixed\n\n- Fix bug where user's expiration time did not start until their first\n  request after login.\n- Fix bug where expired users could perform one request past their expiration\n- Fix bug with missing imports (thanks @frederikhors)\n- Fix bug with inverted remember me checkbox logic\n- Fix validation not happening when user commences recovery\n\n### Deprecated\n\n- Deprecated DelKnownSession for DelAllSession. DelAllSession should be\n  implemented by existing ClientStateReadWriters in order to prevent session\n  values from leaking to a different user post-logout/expire.\n\n## [2.2.0] - 2018-12-16\n\n### Added\n\n- Add e-mail confirmation before 2fa setup feature\n- Add config value TwoFactorEmailAuthRequired\n- Add a more flexible way of adding behaviors and requirements to\n  authboss.Middleware. This API is at authboss.Middleware2 temporarily\n  until we can make a breaking change.\n\n### Fixed\n\n- Fix a bug where GET /login would panic when no FormValueRedirect is\n  provided. (thanks @rarguelloF)\n- Fix a bug where lowercase password requirements in the default rules\n  implementation were not being checked correctly (thanks @rarguelloF)\n- Fix a bug in remember where a user would get half-authed even though they\n  were logged in depending on middleware ordering.\n- Fix a bug where if you were using lock/remember modules with 2fa they\n  would fail since the events didn't contain the current user in the context\n  as the auth module delivers them.\n- Fix a bug with 2fa where a locked account could get a double response\n\n### Deprecated\n\n- Deprecate the config field ConfirmMethod in favor of MailRouteMethod. See\n  documentation for these config fields to understand how to use them now.\n- Deprecate Middleware/MountedMiddleware for Middleware2 and MountedMiddleware2\n  as these new APIs are more flexible. When v3 hits (Mounted)Middleware2 will\n  become just (Mounted)Middleware.\n- Deprecate RoutesRedirectOnUnauthed in favor of ResponseOnUnauthed\n\n## [2.1.1] - 2018-12-10\n\n### Security\n\n- Fix a bug with the 2fa code where a client that failed to log in to a user\n  account got SessionTOTPPendingPID set to that user's pid. That user's pid\n  was used as lookup for verify() method in totp/sms methods before current\n  user was looked at meaning the logged in user could remove 2fa from the\n  other user's account because of the lookup order.\n\n## [2.1.0] - 2018-10-28\n\n### Added\n\n- Add Config option to defaults.HTTPRedirector to allow it to coerce redirect\n  response codes to http.StatusOK to help make more regular APIs.\n- Add Config option for MailRoot. This is a URL that overrides the typical\n  URL building using Root/MountPath that recover and confirm do to enable\n  creating mail links to a different location than where the API is hosted.\n- Add a configuration option that allows confirm to change the method type\n  it expects since in an API setting a GET is strange as there is body details.\n\n### Changed\n\n- defaults.HTTPRedirector now always responds with a \"status\": \"success\"\n  when responding to an API unless there's a failure.\n- defaults.JSONRenderer now renders a \"status\": \"success\" or \"status\": \"failure\"\n  based on the presence of known failure keys (configurable, defaults to\n  standard Authboss HTMLData errors).\n\n### Fixed\n\n- Fix a bug where content-types like 'application/json;charset=utf-8' would\n  not trigger api responses in the default responder.\n- Fix LoadCurrentUser error handling, it was swallowing errors when users were\n  not logged in, changed to be consistent, now returns ErrUserNotFound just like\n  CurrentUser.\n- Fix a bug where EventAuth and EventAuthFailure were not being fired in the\n  2fa modules which would stop users from becoming locked on 2fa failures\n  or logging in without being confirmed.\n\n## [2.0.0] - 2018-09-03\n\n### Added\n\n- Add sms2fa and totp2fa packages so users can use two factor authentication\n- Add twofactor package to enable 2fa recovery codes for sms2fa and totp2fa\n- Add OTP module so users can create one time passwords and use them to log in.\n- Add more documentation about how RegisterPreserveFields works so people\n  don't have to chase the godocs to figure out how to implement it.\n\n### Changed\n\n- authboss.Middleware now has boolean flags to provide more control over\n  how unathenticated users are dealt with. It can now redirect users to\n  the login screen with a redirect to the page they were attempting to reach\n  and it can also protect against half-authed users and users who have\n  not authenticated with two factor auth.\n\n### Fixed\n\n- Ensure all uses of crypto/rand.Read are replaced by io.ReadFull(rand.Reader)\n  to ensure that we never get a read that's full of zeroes. This was a bug\n  present in a uuid library, we don't want to make the same mistake.\n\n## [2.0.0-rc6] - 2018-08-16\n\n- LoadClientStateMiddleware no longer panics when LoadClientState fails.\n  Instead it logs error messages and gives a 500 server error to users instead\n  of returning no response from the server at all due to panic.\n\n### Fixed\n\n- Fix a bug where LoadClientState could return a nil request if the state\n  returned nil instead of falling through.\n- Fix Middlewares link in README\n- Fix error message when forgetting authboss.LoadClientStateMiddleware to\n  be a bit more indicative of what the problem might be.\n\n## [2.0.0-rc5] - 2018-07-04\n\n### Changed\n\n- The upstream golang.org/x/oauth2 library has changed it's API, this fixes\n  the breakage.\n\n## [2.0.0-rc4] - 2018-06-27\n\n### Changed\n\n- RememberingServerStorer now has context on its methods\n\n## [2.0.0-rc3] - 2018-05-25\n\n### Changed\n\n- Recover and Confirm now use split tokens\n\n    The reason for this change is that there's a timing attack possible\n    because of the use of memcmp() by databases to check if the token exists.\n    By using a separate piece of the token as a selector, we use memcmp() in\n    one place, but a crypto constant time compare in the other to check the\n    other value, and this value cannot be leaked by timing, and since you need\n    both to recover/confirm as the user, this attack should now be mitigated.\n\n    This requires users to implement additional fields on the user and rename\n    the Storer methods.\n\n## [2.0.0-rc2] - 2018-05-14\n\nMostly rewrote Authboss by changing many of the core interfaces. This release\nis instrumental in providing better support for integrating with many web frameworks\nand setups.\n\n### Added\n\n- v2 Upgrade guide (tov2.md)\n\n- API/JSON Support\n\n    Because of the new abstractions it's possible to implement body readers,\n    responders, redirectors and renderers that all speak JSON (or anything else for that\n    matter). There are a number of these that exist already in the defaults package.\n\n### Changed\n\n- The core functionality of authboss is now delivered over a set of interfaces\n\n    This change was fairly massive. We've abstracted the HTTP stack completely\n    so that authboss isn't really doing things like issuing template renderings,\n    it's just asking a small interface to do it instead. The reason for doing this\n    was because the previous design was too inflexible and wouldn't integrate nicely\n    with various frameworks etc. The defaults package helps fill in the gaps for typical\n    use cases.\n\n- Storage is now done by many small interfaces\n\n    It became apparent than the old reflect-based mapping was a horrible solution\n    to passing data back and forth between these structs. So instead we've created a\n    much more verbose (but type safe) set of interfaces to govern which fields we need.\n\n    Now we can check that our structs have the correct methods using variable declarations\n    and there's no more confusion about how various types map back and forth inside the\n    mystical `Bind` and `Unbind` methods.\n\n    The downside to this of course is it's incredibly verbose to create a fully featured\n    model, but I think that the benefits outweigh the downsides (see bugs in the past about\n    different types being broken/not supported/not working correctly).\n\n- Support for context.Context is now much better\n\n    We had a few pull requests that kind of shoved context.Context support in the sides\n    so that authboss would work in Google App Engine. With this release context is\n    almost everywhere that an external system would be interacted with.\n\n- Client State management rewritten\n\n    The old method of client state management performed writes too frequently. By using a\n    collection of state change events that are later applied in a single write operation at\n    the end, we make it so we don't get duplicate cookies etc. The bad thing about this is\n    that we have to wrap the ResponseWriter. But there's an UnderlyingResponseWriter\n    interface to deal with this problem.\n\n- Validation has been broken into smaller and hopefully nicer interfaces\n\n    Validation needs to be handled by the BodyReader's set of returned structs. This punts\n    validation outside of the realm of Authboss for the most part, but there's still\n    helpful tools in the defaults package to help with validation if you're against writing\n    rolling your own.\n\n- Logout has been broken out into it's own module to avoid duplication inside login/oauth2\n  since they perform the same function.\n\n- Config is now a nested struct, this helps organize the properties a little better (but\n  I hope you never mouse over the type definition in a code editor).\n\n### Removed\n\n- Notable removal of AllowInsecureLoginAfterConfirm\n\n### Fixed\n\n- Fix bug where e-mail with only a textbody would send blank e-mails\n\n### Deprecated\n\n- Use of gopkg.in, it's no longer a supported method of consuming authboss. Use\n  manual vendoring, dep or vgo.\n\n## [1.0.0] - 2015-08-02\n### Changed\nThis change is potentially breaking, it did break the sample since the supporting struct was wrong for the data we were using.\n\n**Lock:** The documentation was updated to reflect that the struct value for AttemptNumber is indeed an int64.\n**Unbind:** Previously it would scrape the struct for the supported types (string, int, bool, time.Time, sql.Scanner/driver.Valuer)\nand make them into a map. Now the field list will contain all types found in the struct.\n**Bind:** Before this would only set the supported types (described above), now it attempts to set all values. It does check to ensure\nthe type in the attribute map matches what's in the struct before assignment.\n\n## 2015-04-01 Refactor for Multi-tenancy\n### Changed\nThis breaking change allows multiple sites running off the same code base to each use different configurations of Authboss. To migrate\nyour code simply use authboss.New() to get an instance of Authboss and all the old things that used to be in the authboss package are\nnow there. See [this commit to the sample](https://github.com/volatiletech/authboss-sample/commit/eea55fc3b03855d4e9fb63577d72ce8ff0cd4079)\nto see precisely how to make these changes.\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.0703125,
          "content": "The MIT License (MIT)\n\nCopyright (c) 2015 Kris Runzer, Aaron Lefkowitz\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 47.9287109375,
          "content": "<img src=\"http://i.imgur.com/fPIgqLg.jpg\"/>\n\n# Authboss\n\n[![GoDoc](https://img.shields.io/badge/godoc-reference-5272B4)](https://pkg.go.dev/mod/github.com/volatiletech/authboss/v3)\n![ActionsCI](https://github.com/volatiletech/authboss/workflows/test/badge.svg)\n[![Mail](https://img.shields.io/badge/mail%20list-authboss-lightgrey.svg)](https://groups.google.com/a/volatile.tech/forum/#!forum/authboss)\n![Go Coverage](https://img.shields.io/badge/coverage-84.9%25-brightgreen.svg?longCache=true&style=flat)\n[![Go Report Card](https://goreportcard.com/badge/github.com/volatiletech/authboss)](https://goreportcard.com/report/github.com/volatiletech/authboss)\n\nAuthboss is a modular authentication system for the web.\n\nIt has several modules that represent authentication and authorization features that are common\nto websites in general so that you can enable as many as you need, and leave the others out.\nIt makes it easy to plug in authentication to an application and get a lot of functionality\nfor (hopefully) a smaller amount of integration effort.\n\n# New to v2?\n\nv1 -> v2 was a very big change. If you're looking to upgrade there is a general guide in\n[tov2.md](tov2.md) in this project.\n\n# New to v3?\n\nv2 -> v3 was not a big change, it simply changed the project to use Go modules.\nAuthboss no longer supports GOPATH as of version 3\n\n# Why use Authboss?\n\nEvery time you'd like to start a new web project, you really want to get to the heart of what you're\ntrying to accomplish very quickly and it would be a sure bet to say one of the systems you're excited\nabout implementing and innovating on is not authentication. In fact it's very much the opposite: it's\none of those things that you have to do and one of those things you loathe to do. Authboss is supposed\nto remove a lot of the tedium that comes with this, as well as a lot of the chances to make mistakes.\nThis allows you to care about what you're intending to do, rather than care about ancillary support\nsystems required to make what you're intending to do happen.\n\nHere are a few bullet point reasons you might like to try it out:\n\n* Saves you time (Authboss integration time should be less than re-implementation time)\n* Saves you mistakes (at least using Authboss, people can bug fix as a collective and all benefit)\n* Should integrate with or without any web framework\n\n# [Click Here To Get Started](https://volatiletech.github.io/authboss/#/migration)\n\n# Readme Table of Contents\n<!-- TOC -->\n\n- [Authboss](#authboss)\n- [New to v2?](#new-to-v2)\n- [New to v3?](#new-to-v3)\n- [Why use Authboss?](#why-use-authboss)\n- [Readme Table of Contents](#readme-table-of-contents)\n- [Getting Started](#getting-started)\n    - [App Requirements](#app-requirements)\n        - [CSRF Protection](#csrf-protection)\n        - [Request Throttling](#request-throttling)\n    - [Integration Requirements](#integration-requirements)\n        - [Middleware](#middleware)\n        - [Configuration](#configuration)\n        - [Storage and Core implementations](#storage-and-core-implementations)\n        - [ServerStorer implementation](#serverstorer-implementation)\n        - [User implementation](#user-implementation)\n        - [Values implementation](#values-implementation)\n    - [Config](#config)\n        - [Paths](#paths)\n        - [Modules](#modules)\n        - [Mail](#mail)\n        - [Storage](#storage)\n        - [Core](#core)\n- [Available Modules](#available-modules)\n- [Middlewares](#middlewares)\n- [Use Cases](#use-cases)\n    - [Get Current User](#get-current-user)\n    - [Reset Password](#reset-password)\n    - [User Auth via Password](#user-auth-via-password)\n    - [User Auth via OAuth1](#user-auth-via-oauth1)\n    - [User Auth via OAuth2](#user-auth-via-oauth2)\n    - [User Registration](#user-registration)\n    - [Confirming Registrations](#confirming-registrations)\n    - [Password Recovery](#password-recovery)\n    - [Remember Me](#remember-me)\n    - [Locking Users](#locking-users)\n    - [Expiring User Sessions](#expiring-user-sessions)\n    - [One Time Passwords](#one-time-passwords)\n    - [Two Factor Authentication](#two-factor-authentication)\n        - [Two-Factor Recovery](#two-factor-recovery)\n        - [Two-Factor Setup E-mail Authorization](#two-factor-setup-e-mail-authorization)\n        - [Time-Based One Time Passwords 2FA (totp)](#time-based-one-time-passwords-2fa-totp)\n            - [Adding 2fa to a user](#adding-2fa-to-a-user)\n            - [Removing 2fa from a user](#removing-2fa-from-a-user)\n            - [Logging in with 2fa](#logging-in-with-2fa)\n            - [Using Recovery Codes](#using-recovery-codes)\n        - [Text Message 2FA (sms)](#text-message-2fa-sms)\n            - [Adding 2fa to a user](#adding-2fa-to-a-user-1)\n            - [Removing 2fa from a user](#removing-2fa-from-a-user-1)\n            - [Logging in with 2fa](#logging-in-with-2fa-1)\n            - [Using Recovery Codes](#using-recovery-codes-1)\n    - [Rendering Views](#rendering-views)\n        - [HTML Views](#html-views)\n        - [JSON Views](#json-views)\n        - [Data](#data)\n\n<!-- /TOC -->\n\n# Getting Started\n\nTo get started with Authboss in the simplest way, is to simply create a Config, populate it\nwith the things that are required, and start implementing [use cases](#use-cases). The use\ncases describe what's required to be able to use a particular piece of functionality,\nor the best practice when implementing a piece of functionality. Please note the\n[app requirements](#app-requirements) for your application as well\n[integration requirements](#integration-requirements) that follow.\n\nOf course the standard practice of fetching the library is just the beginning:\n\n```bash\n# Get the latest, you must be using Go modules as of v3 of Authboss.\ngo get -u github.com/volatiletech/authboss/v3\n```\n\nHere's a bit of starter code that was stolen from the sample.\n\n```go\nab := authboss.New()\n\nab.Config.Storage.Server = myDatabaseImplementation\nab.Config.Storage.SessionState = mySessionImplementation\nab.Config.Storage.CookieState = myCookieImplementation\n\nab.Config.Paths.Mount = \"/authboss\"\nab.Config.Paths.RootURL = \"https://www.example.com/\"\n\n// This is using the renderer from: github.com/volatiletech/authboss\nab.Config.Core.ViewRenderer = abrenderer.NewHTML(\"/auth\", \"ab_views\")\n// Probably want a MailRenderer here too.\n\n\n// This instantiates and uses every default implementation\n// in the Config.Core area that exist in the defaults package.\n// Just a convenient helper if you don't want to do anything fancy.\n defaults.SetCore(&ab.Config, false, false)\n\nif err := ab.Init(); err != nil {\n    panic(err)\n}\n\n// Mount the router to a path (this should be the same as the Mount path above)\n// mux in this example is a chi router, but it could be anything that can route to\n// the Core.Router.\nmux.Mount(\"/authboss\", http.StripPrefix(\"/authboss\", ab.Config.Core.Router))\n```\n\nFor a more in-depth look you **definitely should** look at the authboss sample to see what a full \nimplementation looks like. This will probably help you more than any of this documentation.\n\n[https://github.com/volatiletech/authboss-sample](https://github.com/volatiletech/authboss-sample)\n\n## App Requirements\n\nAuthboss does a lot of things, but it doesn't do some of the important things that are required by\na typical authentication system, because it can't guarantee that you're doing many of those things\nin a different way already, so it punts the responsibility.\n\n### CSRF Protection\n\nWhat this means is you should apply a middleware that can protect the application from csrf\nattacks or you may be vulnerable. Authboss previously handled this but it took on a dependency\nthat was unnecessary and it complicated the code. Because Authboss does not render views nor\nconsumes data directly from the user, it no longer does this.\n\n### Request Throttling\n\nCurrently Authboss is vulnerable to brute force attacks because there are no protections on\nit's endpoints. This again is left up to the creator of the website to protect the whole website\nat once (as well as Authboss) from these sorts of attacks.\n\n## Integration Requirements\n\nIn terms of integrating Authboss into your app, the following things must be considered.\n\n### Middleware\n\nThere are middlewares that are required to be installed in your middleware stack if it's\nall to function properly, please see [Middlewares](#middlewares) for more information.\n\n### Configuration\n\nThere are some required configuration variables that have no sane defaults and are particular\nto your app:\n\n* Config.Paths.Mount\n* Config.Paths.RootURL\n\n### Storage and Core implementations\n\nEverything under Config.Storage and Config.Core are required and you must provide them,\nhowever you can optionally use default implementations from the\n[defaults package](https://github.com/volatiletech/authboss/tree/master/defaults).\nThis also provides an easy way to share implementations of certain stack pieces (like HTML Form Parsing).\nAs you saw in the example above these can be easily initialized with the `SetCore` method in that\npackage.\n\nThe following is a list of storage interfaces, they must be provided by the implementer. Server is a\nvery involved implementation, please see the additional documentation below for more details.\n\n* Config.Storage.Server\n* Config.Storage.SessionState\n* Config.Storage.CookieState (only for \"remember me\" functionality)\n\nThe following is a list of the core pieces, these typically are abstracting the HTTP stack.\nOut of all of these you'll probably be mostly okay with the default implementations in the\ndefaults package but there are two big exceptions to this rule and that's the ViewRenderer\nand the MailRenderer. For more information please see the use case [Rendering Views](#rendering-views)\n\n* Config.Core.Router\n* Config.Core.ErrorHandler\n* Config.Core.Responder\n* Config.Core.Redirector\n* Config.Core.BodyReader\n* Config.Core.ViewRenderer\n* Config.Core.MailRenderer\n* Config.Core.Mailer\n* Config.Core.Logger\n\n### ServerStorer implementation\n\nThe [ServerStorer](https://pkg.go.dev/github.com/volatiletech/authboss/v3/#ServerStorer) is\nmeant to be upgraded to add capabilities depending on what modules you'd like to use.\nIt starts out by only knowing how to save and load users, but the `remember` module as an example\nneeds to be able to find users by remember me tokens, so it upgrades to a\n[RememberingServerStorer](https://pkg.go.dev/github.com/volatiletech/authboss/v3/#RememberingServerStorer)\nwhich adds these abilities.\n\nYour `ServerStorer` implementation does not need to implement all these additional interfaces\nunless you're using a module that requires it. See the [Use Cases](#use-cases) documentation to know what the requirements are.\n\n### User implementation\n\nUsers in Authboss are represented by the\n[User interface](https://pkg.go.dev/github.com/volatiletech/authboss/v3/#User). The user\ninterface is a flexible notion, because it can be upgraded to suit the needs of the various modules.\n\nInitially the User must only be able to Get/Set a `PID` or primary identifier. This allows the authboss\nmodules to know how to refer to him in the database. The `ServerStorer` also makes use of this\nto save/load users.\n\nAs mentioned, it can be upgraded, for example suppose now we want to use the `confirm` module,\nin that case the e-mail address now becomes a requirement. So the `confirm` module will attempt\nto upgrade the user (and panic if it fails) to a\n[ConfirmableUser](https://pkg.go.dev/github.com/volatiletech/authboss/v3/#ConfirmableUser)\nwhich supports retrieving and setting of confirm tokens, e-mail addresses, and a confirmed state.\n\nYour `User` implementation does not need to implement all these additional user interfaces unless you're\nusing a module that requires it. See the [Use Cases](#use-cases) documentation to know what the\nrequirements are.\n\n### Values implementation\n\nThe [BodyReader](https://pkg.go.dev/github.com/volatiletech/authboss/v3/#BodyReader)\ninterface in the Config returns\n[Validator](https://pkg.go.dev/github.com/volatiletech/authboss/v3/#Validator) implementations\nwhich can be validated. But much like the storer and user it can be upgraded to add different\ncapabilities.\n\nA typical `BodyReader` (like the one in the defaults package) implementation checks the page being\nrequested and switches on that to parse the body in whatever way\n(msgpack, json, url-encoded, doesn't matter), and produce a struct that has the ability to\n`Validate()` it's data as well as functions to retrieve the data necessary for the particular\nvaluer required by the module.\n\nAn example of an upgraded `Valuer` is the\n[UserValuer](https://pkg.go.dev/github.com/volatiletech/authboss/v3/#UserValuer)\nwhich stores and validates the PID and Password that a user has provided for the modules to use.\n\nYour body reader implementation does not need to implement all valuer types unless you're\nusing a module that requires it. See the [Use Cases](#use-cases) documentation to know what the\nrequirements are.\n\n## Config\n\nThe config struct is an important part of Authboss. It's the key to making Authboss do what you\nwant with the implementations you want. Please look at it's code definition as you read the\ndocumentation below, it will make much more sense.\n\n[Config Struct Documentation](https://pkg.go.dev/github.com/volatiletech/authboss/v3/#Config)\n\n### Paths\n\nPaths are the paths that should be redirected to or used in whatever circumstance they describe.\nTwo special paths that are required are `Mount` and `RootURL` without which certain authboss\nmodules will not function correctly. Most paths get defaulted to `/` such as after login success\nor when a user is locked out of their account.\n\n### Modules\n\nModules are module specific configuration options. They mostly control the behavior of modules.\nFor example `RegisterPreserveFields` decides a whitelist of fields to allow back into the data\nto be re-rendered so the user doesn't have to type them in again.\n\n### Mail\n\nMail sending related options.\n\n### Storage\n\nThese are the implementations of how storage on the server and the client are done in your\napp. There are no default implementations for these at this time. See the [Godoc](https://pkg.go.dev/mod/github.com/volatiletech/authboss/v3) for more information\nabout what these are.\n\n### Core\n\nThese are the implementations of the HTTP stack for your app. How do responses render? How are\nthey redirected? How are errors handled?\n\nFor most of these there are default implementations from the\n[defaults package](https://github.com/volatiletech/authboss/tree/master/defaults) available, but not for all.\nSee the package documentation for more information about what's available.\n\n# Available Modules\n\nEach module can be turned on simply by importing it and the side-effects take care of the rest.\nNot all the capabilities of authboss are represented by a module, see [Use Cases](#use-cases)\nto view the supported use cases as well as how to use them in your app.\n\n**Note**: The two factor packages do not enable via side-effect import, see their documentation\nfor more information.\n\nName      | Import Path                               | Description\n----------|-------------------------------------------|------------\nAuth      | github.com/volatiletech/authboss/v3/auth     | Database password authentication for users.\nConfirm   | github.com/volatiletech/authboss/v3/confirm  | Prevents login before e-mail verification.\nExpire    | github.com/volatiletech/authboss/v3/expire   | Expires a user's login\nLock      | github.com/volatiletech/authboss/v3/lock     | Locks user accounts after authentication failures.\nLogout    | github.com/volatiletech/authboss/v3/logout   | Destroys user sessions for auth/oauth2.\nOAuth1    | github.com/stephenafamo/authboss-oauth1      | Provides oauth1 authentication for users.\nOAuth2    | github.com/volatiletech/authboss/v3/oauth2   | Provides oauth2 authentication for users.\nRecover   | github.com/volatiletech/authboss/v3/recover  | Allows for password resets via e-mail.\nRegister  | github.com/volatiletech/authboss/v3/register | User-initiated account creation.\nRemember  | github.com/volatiletech/authboss/v3/remember | Persisting login sessions past session cookie expiry.\nOTP       | github.com/volatiletech/authboss/v3/otp      | One time passwords for use instead of passwords.\nTwofactor | github.com/volatiletech/authboss/v3/otp/twofactor | Regenerate recovery codes for 2fa.\nTotp2fa   | github.com/volatiletech/authboss/v3/otp/twofactor/totp2fa | Use Google authenticator-like things for a second auth factor.\nSms2fa    | github.com/volatiletech/authboss/v3/otp/twofactor/sms2fa | Use a phone for a second auth factor.\n\n# Middlewares\n\nThe only middleware that's truly required is the `LoadClientStateMiddleware`, and that's because it\nenables session and cookie handling for Authboss. Without that, it's not a very useful piece of\nsoftware.\n\nThe remaining middlewares are either the implementation of an entire module (like expire),\nor a key part of a module. For example you probably wouldn't want to use the lock module\nwithout the middleware that would stop a locked user from using an authenticated resource,\nbecause then locking wouldn't be useful unless of course you had your own way of dealing\nwith locking, which is why it's only recommended, and not required. Typically you will\nuse the middlewares if you use the module.\n\nName | Requirement | Description\n---- | ----------- | -----------\n[Middleware](https://pkg.go.dev/github.com/volatiletech/authboss/v3/#Middleware) | Recommended | Prevents unauthenticated users from accessing routes.\n[LoadClientStateMiddleware](https://pkg.go.dev/github.com/volatiletech/authboss/v3/#Authboss.LoadClientStateMiddleware) | **Required** | Enables cookie and session handling\n[ModuleListMiddleware](https://pkg.go.dev/github.com/volatiletech/authboss/v3/#Authboss.ModuleListMiddleware) | Optional | Inserts a loaded module list into the view data\n[confirm.Middleware](https://pkg.go.dev/github.com/volatiletech/authboss/v3/confirm/#Middleware) | Recommended with confirm | Ensures users are confirmed or rejects request\n[expire.Middleware](https://pkg.go.dev/github.com/volatiletech/authboss/v3/expire/#Middleware) | **Required** with expire | Expires user sessions after an inactive period\n[lock.Middleware](https://pkg.go.dev/github.com/volatiletech/authboss/v3/lock/#Middleware) | Recommended with lock | Rejects requests from locked users\n[remember.Middleware](https://pkg.go.dev/github.com/volatiletech/authboss/v3/remember/#Middleware) | Recommended with remember | Logs a user in from a remember cookie\n\n\n# Use Cases\n\n## Get Current User\n\nCurrentUser can be retrieved by calling\n[Authboss.CurrentUser](https://pkg.go.dev/github.com/volatiletech/authboss/v3/#Authboss.CurrentUser)\nbut a pre-requisite is that\n[Authboss.LoadClientState](https://pkg.go.dev/github.com/volatiletech/authboss/v3/#Authboss.LoadClientState)\nhas been called first to load the client state into the request context.\nThis is typically achieved by using the\n[Authboss.LoadClientStateMiddleware](https://pkg.go.dev/github.com/volatiletech/authboss/v3/#Authboss.LoadClientStateMiddleware), but can\nbe done manually as well.\n\n## Reset Password\n\nUpdating a user's password is non-trivial for several reasons:\n\n1. The bcrypt algorithm must have the correct cost, and also be being used.\n1. The user's remember me tokens should all be deleted so that previously authenticated sessions are invalid\n1. Optionally the user should be logged out (**not taken care of by UpdatePassword**)\n\nIn order to do this, we can use the\n[Authboss.UpdatePassword](https://pkg.go.dev/github.com/volatiletech/authboss/v3/#Authboss.UpdatePassword)\nmethod. This ensures the above facets are taken care of which the exception of the logging out part.\n\nIf it's also desirable to have the user logged out, please use the following methods to erase\nall known sessions and cookies from the user.\n\n* [authboss.DelKnownSession](https://pkg.go.dev/github.com/volatiletech/authboss/v3/#DelKnownSession)\n* [authboss.DelKnownCookie](https://pkg.go.dev/github.com/volatiletech/authboss/v3/#DelKnownCookie)\n\n*Note: DelKnownSession has been deprecated for security reasons*\n\n## User Auth via Password\n\n| Info and Requirements |          |\n| --------------------- | -------- |\nModule        | auth\nPages         | login\nRoutes        | /login\nEmails        | _None_\nMiddlewares   | [LoadClientStateMiddleware](https://pkg.go.dev/github.com/volatiletech/authboss/v3/#Authboss.LoadClientStateMiddleware)\nClientStorage | Session and Cookie\nServerStorer  | [ServerStorer](https://pkg.go.dev/github.com/volatiletech/authboss/v3/#ServerStorer)\nUser          | [AuthableUser](https://pkg.go.dev/github.com/volatiletech/authboss/v3/#AuthableUser)\nValues        | [UserValuer](https://pkg.go.dev/github.com/volatiletech/authboss/v3/#UserValuer)\nMailer        | _None_\n\nTo enable this side-effect import the auth module, and ensure that the requirements above are met.\nIt's very likely that you'd also want to enable the logout module in addition to this.\n\nDirect a user to `GET /login` to have them enter their credentials and log in.\n\n## User Auth via OAuth1\n\n| Info and Requirements |          |\n| --------------------- | -------- |\nModule        | oauth1\nPages         | _None_\nRoutes        | /oauth1/{provider}, /oauth1/callback/{provider}\nEmails        | _None_\nMiddlewares   | [LoadClientStateMiddleware](https://pkg.go.dev/github.com/volatiletech/authboss/#Authboss.LoadClientStateMiddleware)\nClientStorage | Session\nServerStorer  | [OAuth1ServerStorer](https://pkg.go.dev/github.com/stephenafamo/authboss-oauth1?tab=doc#ServerStorer)\nUser          | [OAuth1User](https://pkg.go.dev/github.com/stephenafamo/authboss-oauth1?tab=doc#User)\nValues        | _None_\nMailer        | _None_\n\nThis is a tougher implementation than most modules because there's a lot going on. In addition to the\nrequirements stated above, you must also configure the `oauth1.Providers`. It's a public variable in the module.\n\n```go\nimport oauth1 \"github.com/stephenafamo/authboss-oauth1\"\n\noauth1.Providers = map[string]oauth1.Provider{}\n```\n\nThe providers require an oauth1 configuration that's typical for the Go oauth1 package, but in addition\nto that they need a `FindUserDetails` method which has to take the token that's retrieved from the oauth1\nprovider, and call an endpoint that retrieves details about the user (at LEAST user's uid).\nThese parameters are returned in `map[string]string` form and passed into the `oauth1.ServerStorer`.\n\nPlease see the following documentation for more details:\n\n* [Package docs for oauth1](https://pkg.go.dev/github.com/stephenafamo/authboss-oauth1)\n* [oauth1.Provider](https://pkg.go.dev/github.com/stephenafamo/authboss-oauth1?tab=doc#Provider)\n* [oauth1.ServerStorer](https://pkg.go.dev/github.com/stephenafamo/authboss-oauth1/#OAuth1ServerStorer)\n\n## User Auth via OAuth2\n\n| Info and Requirements |          |\n| --------------------- | -------- |\nModule        | oauth2\nPages         | _None_\nRoutes        | /oauth2/{provider}, /oauth2/callback/{provider}\nEmails        | _None_\nMiddlewares   | [LoadClientStateMiddleware](https://pkg.go.dev/github.com/volatiletech/authboss/v3/#Authboss.LoadClientStateMiddleware)\nClientStorage | Session\nServerStorer  | [OAuth2ServerStorer](https://pkg.go.dev/github.com/volatiletech/authboss/v3/#OAuth2ServerStorer)\nUser          | [OAuth2User](https://pkg.go.dev/github.com/volatiletech/authboss/v3/#OAuth2User)\nValues        | _None_\nMailer        | _None_\n\nThis is a tougher implementation than most modules because there's a lot going on. In addition to the\nrequirements stated above, you must also configure the `OAuth2Providers` in the config struct.\n\nThe providers require an oauth2 configuration that's typical for the Go oauth2 package, but in addition\nto that they need a `FindUserDetails` method which has to take the token that's retrieved from the oauth2\nprovider, and call an endpoint that retrieves details about the user (at LEAST user's uid).\nThese parameters are returned in `map[string]string` form and passed into the `OAuth2ServerStorer`.\n\nPlease see the following documentation for more details:\n\n* [Package docs for oauth2](https://pkg.go.dev/github.com/volatiletech/authboss/v3/oauth2/)\n* [authboss.OAuth2Provider](https://pkg.go.dev/github.com/volatiletech/authboss/v3/#OAuth2Provider)\n* [authboss.OAuth2ServerStorer](https://pkg.go.dev/github.com/volatiletech/authboss/v3/#OAuth2ServerStorer)\n\n## User Registration\n\n| Info and Requirements |          |\n| --------------------- | -------- |\nModule        | register\nPages         | register\nRoutes        | /register\nEmails        | _None_\nMiddlewares   | [LoadClientStateMiddleware](https://pkg.go.dev/github.com/volatiletech/authboss/v3/#Authboss.LoadClientStateMiddleware)\nClientStorage | Session\nServerStorer  | [CreatingServerStorer](https://pkg.go.dev/github.com/volatiletech/authboss/v3/#CreatingServerStorer)\nUser          | [AuthableUser](https://pkg.go.dev/github.com/volatiletech/authboss/v3/#AuthableUser), optionally [ArbitraryUser](https://pkg.go.dev/github.com/volatiletech/authboss/v3/#ArbitraryUser)\nValues        | [UserValuer](https://pkg.go.dev/github.com/volatiletech/authboss/v3/#UserValuer), optionally also [ArbitraryValuer](https://pkg.go.dev/github.com/volatiletech/authboss/v3/#ArbitraryValuer)\nMailer        | _None_\n\nUsers can self-register for a service using this module. You may optionally want them to confirm\nthemselves, which can be done using the confirm module.\n\nThe complicated part in implementing registrations are around the `RegisterPreserveFields`. This is to\nhelp in the case where a user fills out many fields, and then say enters a password\nwhich doesn't meet minimum requirements and it fails during validation. These preserve fields should\nstop the user from having to type in all that data again (it's a whitelist). This **must** be used\nin conjuction with `ArbitraryValuer` and although it's not a hard requirement `ArbitraryUser`\nshould be used otherwise the arbitrary values cannot be stored in the database.\n\nWhen the register module sees arbitrary data from an `ArbitraryValuer`, it sets the data key\n`authboss.DataPreserve` with a `map[string]string` in the data for when registration fails.\nThis means the (whitelisted) values entered by the user previously will be accessible in the\ntemplates by using `.preserve.field_name`. Preserve may be empty or nil so use\n`{{with ...}}` to make sure you don't have template errors.\n\nThere is additional [Godoc documentation](https://pkg.go.dev/mod/github.com/volatiletech/authboss/v3#Config) on the `RegisterPreserveFields` config option as well as\nthe `ArbitraryUser` and `ArbitraryValuer` interfaces themselves.\n\n## Confirming Registrations\n\n| Info and Requirements |          |\n| --------------------- | -------- |\nModule        | confirm\nPages         | confirm\nRoutes        | /confirm\nEmails        | confirm_html, confirm_txt\nMiddlewares   | [LoadClientStateMiddleware](https://pkg.go.dev/github.com/volatiletech/authboss/v3/#Authboss.LoadClientStateMiddleware), [confirm.Middleware](https://pkg.go.dev/github.com/volatiletech/authboss/v3/confirm/#Middleware)\nClientStorage | Session\nServerStorer  | [ConfirmingServerStorer](https://pkg.go.dev/github.com/volatiletech/authboss/v3/#ConfirmingServerStorer)\nUser          | [ConfirmableUser](https://pkg.go.dev/github.com/volatiletech/authboss/v3/#ConfirmableUser)\nValues        | [ConfirmValuer](https://pkg.go.dev/github.com/volatiletech/authboss/v3/#ConfirmValuer)\nMailer        | Required\n\nConfirming registrations via e-mail can be done with this module (whether or not done via the register\nmodule).\n\nA hook on register kicks off the start of a confirmation which sends an e-mail with a token for the user.\nWhen the user re-visits the page, the `BodyReader` must read the token and return a type that returns\nthe token.\n\nConfirmations carry two values in the database to prevent a timing attack. The selector and the\nverifier, always make sure in the ConfirmingServerStorer you're searching by the selector and\nnot the verifier.\n\n## Password Recovery\n\n| Info and Requirements |          |\n| --------------------- | -------- |\nModule        | recover\nPages         | recover_start, recover_middle (not used for renders, only values), recover_end\nRoutes        | /recover, /recover/end\nEmails        | recover_html, recover_txt\nMiddlewares   | [LoadClientStateMiddleware](https://pkg.go.dev/github.com/volatiletech/authboss/v3/#Authboss.LoadClientStateMiddleware)\nClientStorage | Session\nServerStorer  | [RecoveringServerStorer](https://pkg.go.dev/github.com/volatiletech/authboss/v3/#RecoveringServerStorer)\nUser          | [RecoverableUser](https://pkg.go.dev/github.com/volatiletech/authboss/v3/#RecoverableUser)\nValues        | [RecoverStartValuer](https://pkg.go.dev/github.com/volatiletech/authboss/v3/#RecoverStartValuer), [RecoverMiddleValuer](https://pkg.go.dev/github.com/volatiletech/authboss/v3/#RecoverMiddleValuer), [RecoverEndValuer](https://pkg.go.dev/github.com/volatiletech/authboss/v3/#RecoverEndValuer)\nMailer        | Required\n\nThe flow for password recovery is that the user is initially shown a page that wants their `PID` to\nbe entered. The `RecoverStartValuer` retrieves that on `POST` to `/recover`.\n\nAn e-mail is sent out, and the user clicks the link inside it and is taken back to `/recover/end`\nas a `GET`, at this point the `RecoverMiddleValuer` grabs the token and will insert it into the data\nto be rendered.\n\nThey enter their password into the form, and `POST` to `/recover/end` which sends the token and\nthe new password which is retrieved by `RecoverEndValuer` which sets their password and saves them.\n\nPassword recovery has two values in the database to prevent a timing attack. The selector and the\nverifier, always make sure in the RecoveringServerStorer you're searching by the selector and\nnot the verifier.\n\n## Remember Me\n\n| Info and Requirements |          |\n| --------------------- | -------- |\nModule        | remember\nPages         | _None_\nRoutes        | _None_\nEmails        | _None_\nMiddlewares   | LoadClientStateMiddleware,\nMiddlewares   | [LoadClientStateMiddleware](https://pkg.go.dev/github.com/volatiletech/authboss/v3/#Authboss.LoadClientStateMiddleware), [remember.Middleware](https://pkg.go.dev/github.com/volatiletech/authboss/v3/remember/#Middleware)\nClientStorage | Session, Cookies\nServerStorer  | [RememberingServerStorer](https://pkg.go.dev/github.com/volatiletech/authboss/v3/#RememberingServerStorer)\nUser          | User\nValues        | [RememberValuer](https://pkg.go.dev/github.com/volatiletech/authboss/v3/#RememberValuer) (not a Validator)\nMailer        | _None_\n\nRemember uses cookie storage to log in users without a session via the `remember.Middleware`.\nBecause of this this middleware should be used high up in the stack, but it also needs to be after\nthe `LoadClientStateMiddleware` so that client state is available via the authboss mechanisms.\n\nThere is an intricacy to the `RememberingServerStorer`, it doesn't use the `User` struct at all,\ninstead it simply instructs the storer to save tokens to a pid and recall them just the same. Typically\nin most databases this will require a separate table, though you could implement using pg arrays\nor something as well.\n\nA user who is logged in via Remember tokens is also considered \"half-authed\" which is a session\nkey (`authboss.SessionHalfAuthKey`) that you can query to check to see if a user should have\nfull rights to more sensitive data, if they are half-authed and they want to change their user\ndetails for example you may want to force them to go to the login screen and put in their\npassword to get a full auth first. The `authboss.Middleware` has a boolean flag to `forceFullAuth`\nwhich prevents half-authed users from using that route.\n\n## Locking Users\n\n| Info and Requirements |          |\n| --------------------- | -------- |\nModule        | lock\nPages         | _None_\nRoutes        | _None_\nEmails        | _None_\nMiddlewares   | [LoadClientStateMiddleware](https://pkg.go.dev/github.com/volatiletech/authboss/v3/#Authboss.LoadClientStateMiddleware), [lock.Middleware](https://pkg.go.dev/github.com/volatiletech/authboss/v3/lock/#Middleware)\nClientStorage | Session\nServerStorer  | [ServerStorer](https://pkg.go.dev/github.com/volatiletech/authboss/v3/#ServerStorer)\nUser          | [LockableUser](https://pkg.go.dev/github.com/volatiletech/authboss/v3/#LockableUser)\nValues        | _None_\nMailer        | _None_\n\nLock ensures that a user's account becomes locked if authentication (both auth, oauth2, otp) are\nfailed enough times.\n\nThe middleware protects resources from locked users, without it, there is no point to this module.\nYou should put in front of any resource that requires a login to function.\n\n## Expiring User Sessions\n\n| Info and Requirements |          |\n| --------------------- | -------- |\nModule        | expire\nPages         | _None_\nRoutes        | _None_\nEmails        | _None_\nMiddlewares   | [LoadClientStateMiddleware](https://pkg.go.dev/github.com/volatiletech/authboss/v3/#Authboss.LoadClientStateMiddleware), [expire.Middleware](https://pkg.go.dev/github.com/volatiletech/authboss/v3/expire/#Middleware)\nClientStorage | Session\nServerStorer  | _None_\nUser          | [User](https://pkg.go.dev/github.com/volatiletech/authboss/v3/#User)\nValues        | _None_\nMailer        | _None_\n\n**Note:** Unlike most modules in Authboss you must call `expire.Setup()`\nto enable this module. See the sample to see how to do this. This may be changed in the future.\n\nExpire simply uses sessions to track when the last action of a user is, if that action is longer\nthan configured then the session is deleted and the user removed from the request context.\n\nThis middleware should be inserted at a high level (closer to the request) in the middleware chain\nto ensure that \"activity\" is logged properly, as well as any middlewares down the chain do not\nattempt to do anything with the user before it's removed from the request context.\n\n## One Time Passwords\n\n| Info and Requirements |          |\n| --------------------- | -------- |\nModule        | otp\nPages         | otp, otpadd, otpclear\nRoutes        | /otp/login, /otp/add, /otp/clear\nEmails        | _None_\nMiddlewares   | [LoadClientStateMiddleware](https://pkg.go.dev/github.com/volatiletech/authboss/v3/#Authboss.LoadClientStateMiddleware)\nClientStorage | Session and Cookie\nServerStorer  | [ServerStorer](https://pkg.go.dev/github.com/volatiletech/authboss/v3/#ServerStorer)\nUser          | [otp.User](https://pkg.go.dev/github.com/volatiletech/authboss/v3/otp/#User)\nValues        | [UserValuer](https://pkg.go.dev/github.com/volatiletech/authboss/v3/#UserValuer)\nMailer        | _None_\n\nOne time passwords can be useful if users require a backup password in case they lose theirs,\nor they're logging in on an untrusted computer. This module allows users to add one time passwords,\nclear them, or log in with them.\n\nLogging in with a one time password instead of a password is identical to having logged in normally\nwith their typical password with the exception that the one time passwords are consumed immediately\nupon use and cannot be used again.\n\n`otp` should not be confused with two factor authentication. Although 2fa also uses one-time passwords\nthe `otp` module has nothing to do with it and is strictly a mechanism for logging in with an alternative\nto a user's regular password.\n\n## Two Factor Authentication\n\n2FA in Authboss is implemented in a few separate modules: twofactor, totp2fa and sms2fa.\n\nYou should use two factor authentication in your application if you want additional security beyond\nthat of just simple passwords. Each 2fa module supports a different mechanism for verifying a second\nfactor of authentication from a user.\n\n### Two-Factor Recovery\n\n| Info and Requirements |          |\n| --------------------- | -------- |\nModule        | twofactor\nPages         | recovery2fa\nRoutes        | /2fa/recovery/regen\nEmails        | _None_\nMiddlewares   | [LoadClientStateMiddleware](https://pkg.go.dev/github.com/volatiletech/authboss/v3/#Authboss.LoadClientStateMiddleware)\nClientStorage | Session\nServerStorer  | [ServerStorer](https://pkg.go.dev/github.com/volatiletech/authboss/v3/#ServerStorer)\nUser          | [twofactor.User](https://pkg.go.dev/github.com/volatiletech/authboss/v3/otp/twofactor/#User)\nValues        | _None_\nMailer        | _None_\n\n**Note:** Unlike most modules in Authboss you must construct a `twofactor.Recovery` and call `.Setup()`\non it to enable this module. See the sample to see how to do this. This may be changed in the future.\n\nPackage twofactor is all about the common functionality of providing backup codes for two factor\nmechanisms. Instead of each module implementing backup codes on it's own, common functionality has\nbeen put here including a route to regenerate backup codes.\n\nBackup codes are useful in case people lose access to their second factor for authentication. This happens\nwhen users lose their phones for example. When this occurs, they can use one of their backup-codes.\n\nBackup codes are one-time use, they are bcrypted for security, and they only allow bypassing the 2fa\nauthentication part, they cannot be used in lieu of a user's password, for that sort of recovery see\nthe `otp` module.\n\n### Two-Factor Setup E-mail Authorization\n\n| Info and Requirements |          |\n| --------------------- | -------- |\nModule        | twofactor\nPages         | twofactor_verify\nRoutes        | /2fa/recovery/regen\nEmails        | twofactor_verify_email_html, twofactor_verify_email_txt\nMiddlewares   | [LoadClientStateMiddleware](https://pkg.go.dev/github.com/volatiletech/authboss/v3/#Authboss.LoadClientStateMiddleware)\nClientStorage | Session\nServerStorer  | [ServerStorer](https://pkg.go.dev/github.com/volatiletech/authboss/v3/#ServerStorer)\nUser          | [twofactor.User](https://pkg.go.dev/github.com/volatiletech/authboss/v3/otp/twofactor/#User)\nValues        | [twofactor.EmailVerifyTokenValuer](https://pkg.go.dev/github.com/volatiletech/authboss/v3/otp/twofactor/#EmailVerifyTokenValuer)\nMailer        | Required\n\nTo enable this feature simply turn on\n`authboss.Config.Modules.TwoFactorEmailAuthRequired` and new routes and\nmiddlewares will be installed when you set up one of the 2fa modules.\n\nWhen enabled, the routes for setting up 2fa on an account are protected by a\nmiddleware that will redirect to `/2fa/{totp,sms}/email/verify` where\nPage `twofactor_verify` is displayed. The user is prompted to authorize the\naddition of 2fa to their account. The data for this page contains `email` and\na `url` for the POST. The url is required because this page is shared between\nall 2fa types.\n\nOnce they POST to the url, a token is stored in their session and an e-mail is\nsent with that token. When they click the link that goes to\n`/2fa/{totp,sms}/email/verify/end` with a token in the query string the session\ntoken is verified and exchanged for a value that says they're verified and\nlastly it redirects them to the setup URL for the type of 2fa they were\nattempting to setup.\n\n### Time-Based One Time Passwords 2FA (totp)\n\n| Info and Requirements |          |\n| --------------------- | -------- |\nModule        | totp2fa\nPages         | totp2fa_{setup,confirm,remove,validate}, totp2fa_{confirm,remove}_success\nRoutes        | /2fa/totp/{setup,confirm,qr,remove,validate}\nEmails        | _None_\nMiddlewares   | [LoadClientStateMiddleware](https://pkg.go.dev/github.com/volatiletech/authboss/v3/#Authboss.LoadClientStateMiddleware)\nClientStorage | Session **(SECURE!)**\nServerStorer  | [ServerStorer](https://pkg.go.dev/github.com/volatiletech/authboss/v3/#ServerStorer)\nUser          | [totp2fa.User](https://pkg.go.dev/github.com/volatiletech/authboss/v3/otp/twofactor/totp2fa/#User)\nValues        | [TOTPCodeValuer](https://pkg.go.dev/github.com/volatiletech/authboss/v3/otp/twofactor/totp2fa/#TOTPCodeValuer)\nMailer        | _None_\n\n**Note:** Unlike most modules in Authboss you must construct a `totp2fa.TOTP` and call `.Setup()`\non it to enable this module. See the sample to see how to do this This may be changed in the future.\n\n**Note:** To allow users to regenerate their backup codes, you must also use the `twofactor` module.\n\n**Note:** Routes are protected by `authboss.Middleware` so only logged in users can access them.\nYou can configure whether unauthenticated users should be redirected to log in or are 404'd using\nthe `authboss.Config.Modules.RoutesRedirectOnUnathed` configuration flag.\n\n#### Adding 2fa to a user\n\nWhen a logged in user would like to add 2fa to their account direct them `GET /2fa/totp/setup`, the `GET`\non this page does virtually nothing so you don't have to use it, just `POST` immediately to have\na smoother flow for the user. **This puts the 2fa secret in their session temporarily meaning you must\nhave proper secure sessions for this to be secure.**\n\nThey will be redirected to `GET /2fa/totp/confirm` where the data will show `totp2fa.DataTOTPSecret`,\nthis is the key that user's should enter into their Google Authenticator or similar app. Once they've\nadded it they need to send a `POST /2fa/totp/confirm` with a correct code which removes the 2fa secret\nfrom their session and permanently adds it to their `totp2fa.User` and 2fa is now enabled for them.\nThe data from the `POST` will contain a key `twofactor.DataRecoveryCodes` that contains an array\nof recovery codes for the user.\n\nIf you wish to show the user a QR code, `GET /2fa/totp/qr` at any time during or after totp2fa setup\nwill return a 200x200 png QR code that they can scan.\n\n#### Removing 2fa from a user\n\nA user begins by going to `GET /2fa/totp/remove` and enters a code which posts to `POST /2fa/totp/remove`\nand if it's correct they're shown a success page and 2fa is removed from them, if not they get\nvalidation errors.\n\n#### Logging in with 2fa\n\nWhen a user goes to log in, the `totp` module checks the user after they log in for the presence of\na totp2fa secret, if there is one it does not give them a logged in session value immediately and\nredirects them to `GET /2fa/totp/validate` where they must enter a correct code to `POST /2fa/totp/validate`\nif the code is correct they're logged in normally as well as they get the session value\n`authboss.Session2FA` set to `\"totp\"` to prove that they've authenticated with two factors.\n\n#### Using Recovery Codes\n\nBoth when logging in and removing totp2fa from an account, a recovery code may be used instead. They can\n`POST` to the same url, they simply send a different form field. The recovery code is consumed on use\nand may not be used again.\n\n### Text Message 2FA (sms)\n\nPackage sms2fa uses sms shared secrets as a means to authenticate a user with a second factor:\ntheir phone number.\n\n| Info and Requirements |          |\n| --------------------- | -------- |\nModule        | sms2fa\nPages         | sms2fa_{setup,confirm,remove,validate}, sms2fa_{confirm,remove}_success\nRoutes        | /2fa/{setup,confirm,remove,validate}\nEmails        | _None_\nMiddlewares   | [LoadClientStateMiddleware](https://pkg.go.dev/github.com/volatiletech/authboss/v3/#Authboss.LoadClientStateMiddleware)\nClientStorage | Session (**SECURE!**)\nServerStorer  | [ServerStorer](https://pkg.go.dev/github.com/volatiletech/authboss/v3/#ServerStorer)\nUser          | [sms2fa.User](https://pkg.go.dev/github.com/volatiletech/authboss/v3/otp/twofactor/sms2fa/#User), [sms2fa.SMSNumberProvider](https://pkg.go.dev/github.com/volatiletech/authboss/v3/otp/twofactor/sms2fa/#SMSNumberProvider)\nValues        | [SMSValuer](https://pkg.go.dev/github.com/volatiletech/authboss/v3/otp/twofactor/sms2fa/#SMSValuer), [SMSPhoneNumberValuer](https://pkg.go.dev/github.com/volatiletech/authboss/v3/otp/twofactor/sms2fa/#SMSPhoneNumberValuer)\nMailer        | _None_\n\n**Note:** Unlike most modules in Authboss you must construct a `sms2fa.SMS` and call `.Setup()`\non it to enable this module. See the sample to see how to do this. This may be changed in the future.\n\n**Note:** To allow users to regenerate their backup codes, you must also use the `twofactor` module.\n\n**Note:** Routes are protected by `authboss.Middleware` so only logged in users can access them.\nYou can configure whether unauthenticated users should be redirected to log in or are 404'd using\nthe `authboss.Config.Modules.RoutesRedirectOnUnathed` configuration flag.\n\n**Note:** sms2fa always stores the code it's expecting in the user's session therefore **you must\nhave secure sessions or the code itself is not secure!**\n\n**Note:** sms2fa pages all send codes via sms on `POST` when no data code is given. This is also how\nusers can resend the code in case they did not get it (for example a second\n`POST /2fa/sms/{confirm,remove}` with no form-fields filled in will end up resending the code).\n\n**Note:** Sending sms codes is rate-limited to 1 sms/10 sec for that user, this is controlled by placing\na timestamp in their session to prevent abuse.\n\n#### Adding 2fa to a user\n\nWhen a logged in user would like to add 2fa to their account direct them `GET /2fa/sms/setup` where\nthey must enter a phone number. If the logged in user also implements `sms2fa.SMSNumberProvider` then\nthis interface will be used to retrieve a phone number (if it exists) from the user and put it in\n`sms2fa.DataSMSPhoneNumber` so that the user interface can populate it for the user, making it convenient\nto re-use an already saved phone number inside the user.\n\nOnce they `POST /2fa/sms/setup` with a phone number, the `sms2fa.Sender` interface will be\ninvoked to send the SMS code to the user and they will be redirected to `GET /2fa/sms/confirm` where\nthey enter the code they received which does a `POST /2fa/sms/confirm` to store the phone number\nthey were confirming permanently on their user using `sms2fa.User` which enables sms2fa for them.\nThe data from the `POST` will contain a key `twofactor.DataRecoveryCodes` that contains an array\nof recovery codes for the user.\n\n#### Removing 2fa from a user\n\nA user begins by going to `GET /2fa/sms/remove`. This page does nothing on it's own. In order to\nbegin the process `POST /2fa/sms/remove` with no data (or a recovery code to skip needing the sms code)\nto send the sms code to the user. Then they can `POST /2fa/sms/remove` again with the correct code\nto have it permanently removed.\n\n#### Logging in with 2fa\n\nWhen a user goes to log in, the `sms` module checks the user after they log in for the presence of\na sms2fa phone number, if there is one it does not give them a logged in session value but instead\nsends an SMS code to their configured number and and redirects them to `GET /2fa/sms/validate`\nwhere they must enter a correct code to `POST /2fa/totp/validate`. If the code is correct they're\nlogged in normally as well as they get the session value `authboss.Session2FA` set to `\"sms\"` to prove\nthat they've authenticated with two factors.\n\n#### Using Recovery Codes\n\nSame as totp2fa above.\n\n## Rendering Views\n\nThe authboss rendering system is simple. It's defined by one interface: [Renderer](https://pkg.go.dev/github.com/volatiletech/authboss/v3/#Renderer)\n\nThe renderer knows how to load templates, and how to render them with some data and that's it.\nSo let's examine the most common view types that you might want to use.\n\n### HTML Views\n\nWhen your app is a traditional web application and is generating it's HTML\nserverside using templates this becomes a small wrapper on top of your rendering\nsetup. For example if you're using `html/template` then you could just use\n`template.New()` inside the `Load()` method and store that somewhere and call\n`template.Execute()` in the `Render()` method.\n\nThere is also a very basic renderer: [Authboss\nRenderer](https://github.com/volatiletech/authboss-renderer) which has some very\nugly built in views and the ability to override them with your own if you don't\nwant to integrate your own rendering system into that interface.\n\n### JSON Views\n\nIf you're building an API that's mostly backed by a javascript front-end, then you'll probably\nwant to use a renderer that converts the data to JSON. There is a simple json renderer available in\nthe [defaults package](https://github.com/volatiletech/authboss/tree/master/defaults) package if you wish to\nuse that.\n\n### Data\n\nThe most important part about this interface is the data that you have to render.\nThere are several keys that are used throughout authboss that you'll want to render in your views.\n\nThey're in the file [html_data.go](https://github.com/volatiletech/authboss/blob/master/html_data.go)\nand are constants prefixed with `Data`. See the documentation in that file for more information on\nwhich keys exist and what they contain.\n\nThe default [responder](https://pkg.go.dev/github.com/volatiletech/authboss/v3/defaults/#Responder)\nalso happens to collect data from the Request context, and hence this is a great place to inject\ndata you'd like to render (for example data for your html layout, or csrf tokens).\n"
        },
        {
          "name": "auth",
          "type": "tree",
          "content": null
        },
        {
          "name": "authboss.go",
          "type": "blob",
          "size": 8.720703125,
          "content": "/*\nPackage authboss is a modular authentication system for the web. It tries to\nremove as much boilerplate and \"hard things\" as possible so that each time you\nstart a new web project in Go, you can plug it in, configure and be off to the\nraces without having to think about how to store passwords or remember tokens.\n*/\npackage authboss\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"net/http\"\n\t\"net/url\"\n\t\"path\"\n\n\t\"github.com/friendsofgo/errors\"\n\t\"golang.org/x/crypto/bcrypt\"\n)\n\n// Authboss contains a configuration and other details for running.\ntype Authboss struct {\n\tConfig\n\tEvents *Events\n\n\tloadedModules map[string]Moduler\n}\n\n// New makes a new instance of authboss with a default\n// configuration.\nfunc New() *Authboss {\n\tab := &Authboss{}\n\n\tab.loadedModules = make(map[string]Moduler)\n\tab.Events = NewEvents()\n\n\tab.Config.Defaults()\n\treturn ab\n}\n\n// Init authboss, modules, renderers\nfunc (a *Authboss) Init(modulesToLoad ...string) error {\n\t// Create the hasher\n\t// Have to do it in Init for backwards compatibility.\n\t// If a user did not previously use defaults.SetCore() then they will\n\t// suddenly start getting panics\n\t// We also cannot use config.Defaults() so we can respect the user's BCryptCost\n\tif a.Config.Core.Hasher == nil {\n\t\ta.Config.Core.Hasher = NewBCryptHasher(a.Config.Modules.BCryptCost)\n\t}\n\n\tif len(modulesToLoad) == 0 {\n\t\tmodulesToLoad = RegisteredModules()\n\t}\n\n\tfor _, name := range modulesToLoad {\n\t\tif err := a.loadModule(name); err != nil {\n\t\t\treturn errors.Errorf(\"module %s failed to load: %+v\", name, err)\n\t\t}\n\t}\n\n\treturn nil\n}\n\n// UpdatePassword updates the password field of a user using the same semantics\n// that register/auth do to create and verify passwords. It saves this using\n// the storer.\n//\n// In addition to that, it also invalidates any remember me tokens, if the\n// storer supports that kind of operation.\n//\n// Note that it's best practice after having called this method to also delete\n// all the user's logged in sessions. The CURRENT logged in session can be\n// deleted with `authboss.DelKnown(Session|Cookie)` but to delete ALL logged\n// in sessions for a user requires special mechanisms not currently provided\n// by authboss.\nfunc (a *Authboss) UpdatePassword(ctx context.Context, user AuthableUser, newPassword string) error {\n\tpass, err := a.Config.Core.Hasher.GenerateHash(newPassword)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tuser.PutPassword(pass)\n\n\tstorer := a.Config.Storage.Server\n\tif err := storer.Save(ctx, user); err != nil {\n\t\treturn err\n\t}\n\n\trmStorer, ok := storer.(RememberingServerStorer)\n\tif !ok {\n\t\treturn nil\n\t}\n\n\treturn rmStorer.DelRememberTokens(ctx, user.GetPID())\n}\n\n// VerifyPassword check that the provided password for the user is correct.\n// Returns nil on success otherwise there will be an error.\n// Simply a wrapper for [a.Core.Hasher.CompareHashAndPassword]\nfunc (a *Authboss) VerifyPassword(user AuthableUser, password string) error {\n\treturn a.Core.Hasher.CompareHashAndPassword(user.GetPassword(), password)\n}\n\n// Localizef is a helper to translate a key using the translator\n// If the localizer is nil or returns an empty string,\n// then the original text will be returned using [fmt.Sprintf] to interpolate the args.\nfunc (a *Authboss) Localizef(ctx context.Context, key LocalizationKey, args ...any) string {\n\tif a.Config.Core.Localizer == nil {\n\t\treturn fmt.Sprintf(key.Default, args...)\n\t}\n\n\tif translated := a.Config.Core.Localizer.Localizef(ctx, key, args...); translated != \"\" {\n\t\treturn translated\n\t}\n\n\treturn fmt.Sprintf(key.Default, args...)\n}\n\n// VerifyPassword uses authboss mechanisms to check that a password is correct.\n// Returns nil on success otherwise there will be an error. Simply a helper\n// to do the bcrypt comparison.\n//\n// NOTE: This function will work ONLY if no custom hasher was configured in global ab.config\n//\n// Deperecated: use [a.VerifyPassword] instead\nfunc VerifyPassword(user AuthableUser, password string) error {\n\treturn bcrypt.CompareHashAndPassword([]byte(user.GetPassword()), []byte(password))\n}\n\n// MWRequirements are user requirements for authboss.Middleware\n// in order to access the routes in protects. Requirements is a bit-set integer\n// to be able to easily combine requirements like so:\n//\n//\tauthboss.RequireFullAuth | authboss.Require2FA\ntype MWRequirements int\n\n// MWRespondOnFailure tells authboss.Middleware how to respond to\n// a failure to meet the requirements.\ntype MWRespondOnFailure int\n\n// Middleware requirements\nconst (\n\tRequireNone MWRequirements = 0x00\n\t// RequireFullAuth means half-authed users will also be rejected\n\tRequireFullAuth MWRequirements = 0x01\n\t// Require2FA means that users who have not authed with 2fa will\n\t// be rejected.\n\tRequire2FA MWRequirements = 0x02\n)\n\n// Middleware response types\nconst (\n\t// RespondNotFound does not allow users who are not logged in to know a\n\t// route exists by responding with a 404.\n\tRespondNotFound MWRespondOnFailure = iota\n\t// RespondRedirect redirects users to the login page\n\tRespondRedirect\n\t// RespondUnauthorized provides a 401, this allows users to know the page\n\t// exists unlike the 404 option.\n\tRespondUnauthorized\n)\n\n// Middleware is deprecated. See Middleware2.\nfunc Middleware(ab *Authboss, redirectToLogin bool, forceFullAuth bool, force2fa bool) func(http.Handler) http.Handler {\n\treturn MountedMiddleware(ab, false, redirectToLogin, forceFullAuth, force2fa)\n}\n\n// MountedMiddleware is deprecated. See MountedMiddleware2.\nfunc MountedMiddleware(ab *Authboss, mountPathed, redirectToLogin, forceFullAuth, force2fa bool) func(http.Handler) http.Handler {\n\tvar reqs MWRequirements\n\tfailResponse := RespondNotFound\n\tif forceFullAuth {\n\t\treqs |= RequireFullAuth\n\t}\n\tif force2fa {\n\t\treqs |= Require2FA\n\t}\n\tif redirectToLogin {\n\t\tfailResponse = RespondRedirect\n\t}\n\treturn MountedMiddleware2(ab, mountPathed, reqs, failResponse)\n}\n\n// Middleware2 prevents someone from accessing a route that should be\n// only allowed for users who are logged in.\n// It allows the user through if they are logged in (SessionKey is present in\n// the session).\n//\n// requirements are set by logical or'ing together requirements. eg:\n//\n//\tauthboss.RequireFullAuth | authboss.Require2FA\n//\n// failureResponse is how the middleware rejects the users that don't meet\n// the criteria. This should be chosen from the MWRespondOnFailure constants.\nfunc Middleware2(ab *Authboss, requirements MWRequirements, failureResponse MWRespondOnFailure) func(http.Handler) http.Handler {\n\treturn MountedMiddleware2(ab, false, requirements, failureResponse)\n}\n\n// MountedMiddleware2 hides an option from typical users in \"mountPathed\".\n// Normal routes should never need this only authboss routes (since they\n// are behind mountPath typically). This method is exported only for use\n// by Authboss modules, normal users should use Middleware instead.\n//\n// If mountPathed is true, then before redirecting to a URL it will add\n// the mountpath to the front of it.\nfunc MountedMiddleware2(ab *Authboss, mountPathed bool, reqs MWRequirements, failResponse MWRespondOnFailure) func(http.Handler) http.Handler {\n\treturn func(next http.Handler) http.Handler {\n\t\treturn http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\t\tlog := ab.RequestLogger(r)\n\n\t\t\tfail := func(w http.ResponseWriter, r *http.Request) {\n\t\t\t\tswitch failResponse {\n\t\t\t\tcase RespondNotFound:\n\t\t\t\t\tlog.Infof(\"not found for unauthorized user at: %s\", r.URL.Path)\n\t\t\t\t\tw.WriteHeader(http.StatusNotFound)\n\t\t\t\tcase RespondUnauthorized:\n\t\t\t\t\tlog.Infof(\"unauthorized for unauthorized user at: %s\", r.URL.Path)\n\t\t\t\t\tw.WriteHeader(http.StatusUnauthorized)\n\t\t\t\tcase RespondRedirect:\n\t\t\t\t\tlog.Infof(\"redirecting unauthorized user to login from: %s\", r.URL.Path)\n\t\t\t\t\tvals := make(url.Values)\n\n\t\t\t\t\tredirURL := r.URL.Path\n\t\t\t\t\tif mountPathed && len(ab.Config.Paths.Mount) != 0 {\n\t\t\t\t\t\tredirURL = path.Join(ab.Config.Paths.Mount, redirURL)\n\t\t\t\t\t}\n\t\t\t\t\tif len(r.URL.RawQuery) != 0 {\n\t\t\t\t\t\tredirURL += \"?\" + r.URL.RawQuery\n\t\t\t\t\t}\n\t\t\t\t\tvals.Set(FormValueRedirect, redirURL)\n\n\t\t\t\t\tro := RedirectOptions{\n\t\t\t\t\t\tCode:         http.StatusTemporaryRedirect,\n\t\t\t\t\t\tFailure:      ab.Localizef(r.Context(), TxtAuthFailed),\n\t\t\t\t\t\tRedirectPath: path.Join(ab.Config.Paths.Mount, fmt.Sprintf(\"/login?%s\", vals.Encode())),\n\t\t\t\t\t}\n\n\t\t\t\t\tif err := ab.Config.Core.Redirector.Redirect(w, r, ro); err != nil {\n\t\t\t\t\t\tlog.Errorf(\"failed to redirect user during authboss.Middleware redirect: %+v\", err)\n\t\t\t\t\t}\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif hasBit(reqs, RequireFullAuth) && !IsFullyAuthed(r) || hasBit(reqs, Require2FA) && !IsTwoFactored(r) {\n\t\t\t\tfail(w, r)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif _, err := ab.LoadCurrentUser(&r); err == ErrUserNotFound {\n\t\t\t\tfail(w, r)\n\t\t\t\treturn\n\t\t\t} else if err != nil {\n\t\t\t\tlog.Errorf(\"error fetching current user: %+v\", err)\n\t\t\t\tw.WriteHeader(http.StatusInternalServerError)\n\t\t\t\treturn\n\t\t\t} else {\n\t\t\t\tnext.ServeHTTP(w, r)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc hasBit(reqs, req MWRequirements) bool {\n\treturn reqs&req == req\n}\n"
        },
        {
          "name": "authboss_test.go",
          "type": "blob",
          "size": 5.8017578125,
          "content": "package authboss\n\nimport (\n\t\"context\"\n\t\"net/http\"\n\t\"net/http/httptest\"\n\t\"testing\"\n)\n\nfunc TestAuthBossInit(t *testing.T) {\n\tt.Parallel()\n\n\tab := New()\n\terr := ab.Init()\n\tif err != nil {\n\t\tt.Error(\"Unexpected error:\", err)\n\t}\n}\n\nfunc TestAuthbossUpdatePassword(t *testing.T) {\n\tt.Parallel()\n\n\tuser := &mockUser{}\n\tstorer := newMockServerStorer()\n\n\tab := New()\n\tab.Config.Storage.Server = storer\n\tab.Config.Core.Hasher = mockHasher{}\n\n\tif err := ab.UpdatePassword(context.Background(), user, \"hello world\"); err != nil {\n\t\tt.Error(err)\n\t}\n\n\tif len(user.Password) == 0 {\n\t\tt.Error(\"password was not updated\")\n\t}\n}\n\ntype testRedirector struct {\n\tOpts RedirectOptions\n}\n\nfunc (r *testRedirector) Redirect(w http.ResponseWriter, req *http.Request, ro RedirectOptions) error {\n\tr.Opts = ro\n\tif len(ro.RedirectPath) == 0 {\n\t\tpanic(\"no redirect path on redirect call\")\n\t}\n\thttp.Redirect(w, req, ro.RedirectPath, ro.Code)\n\treturn nil\n}\n\nfunc TestAuthbossMiddleware(t *testing.T) {\n\tt.Parallel()\n\n\tab := New()\n\tab.Core.Logger = mockLogger{}\n\tab.Storage.Server = &mockServerStorer{\n\t\tUsers: map[string]*mockUser{\n\t\t\t\"test@test.com\": {},\n\t\t},\n\t}\n\n\tsetupMore := func(mountPathed bool, requirements MWRequirements, failResponse MWRespondOnFailure) (*httptest.ResponseRecorder, bool, bool) {\n\t\tr := httptest.NewRequest(\"GET\", \"/super/secret\", nil)\n\t\trec := httptest.NewRecorder()\n\t\tw := ab.NewResponse(rec)\n\n\t\tvar err error\n\t\tr, err = ab.LoadClientState(w, r)\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\n\t\tvar mid func(http.Handler) http.Handler\n\t\tif !mountPathed {\n\t\t\tmid = Middleware2(ab, requirements, failResponse)\n\t\t} else {\n\t\t\tmid = MountedMiddleware2(ab, true, requirements, failResponse)\n\t\t}\n\t\tvar called, hadUser bool\n\t\tserver := mid(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\t\tcalled = true\n\t\t\thadUser = r.Context().Value(CTXKeyUser) != nil\n\t\t\tw.WriteHeader(http.StatusOK)\n\t\t}))\n\n\t\tserver.ServeHTTP(w, r)\n\n\t\treturn rec, called, hadUser\n\t}\n\n\tt.Run(\"Accept\", func(t *testing.T) {\n\t\tab.Storage.SessionState = mockClientStateReadWriter{\n\t\t\tstate: mockClientState{SessionKey: \"test@test.com\"},\n\t\t}\n\n\t\t_, called, hadUser := setupMore(false, RequireNone, RespondNotFound)\n\n\t\tif !called {\n\t\t\tt.Error(\"should have been called\")\n\t\t}\n\t\tif !hadUser {\n\t\t\tt.Error(\"should have had user\")\n\t\t}\n\t})\n\tt.Run(\"AcceptHalfAuth\", func(t *testing.T) {\n\t\tab.Storage.SessionState = mockClientStateReadWriter{\n\t\t\tstate: mockClientState{SessionKey: \"test@test.com\", SessionHalfAuthKey: \"true\"},\n\t\t}\n\n\t\t_, called, hadUser := setupMore(false, RequireNone, RespondNotFound)\n\n\t\tif !called {\n\t\t\tt.Error(\"should have been called\")\n\t\t}\n\t\tif !hadUser {\n\t\t\tt.Error(\"should have had user\")\n\t\t}\n\t})\n\tt.Run(\"Accept2FA\", func(t *testing.T) {\n\t\tab.Storage.SessionState = mockClientStateReadWriter{\n\t\t\tstate: mockClientState{SessionKey: \"test@test.com\", Session2FA: \"sms\"},\n\t\t}\n\n\t\t_, called, hadUser := setupMore(false, Require2FA, RespondNotFound)\n\n\t\tif !called {\n\t\t\tt.Error(\"should have been called\")\n\t\t}\n\t\tif !hadUser {\n\t\t\tt.Error(\"should have had user\")\n\t\t}\n\t})\n\tt.Run(\"RejectNotFound\", func(t *testing.T) {\n\t\tab.Storage.SessionState = mockClientStateReadWriter{}\n\n\t\trec, called, hadUser := setupMore(false, RequireNone, RespondNotFound)\n\n\t\tif rec.Code != http.StatusNotFound {\n\t\t\tt.Error(\"wrong code:\", rec.Code)\n\t\t}\n\t\tif called {\n\t\t\tt.Error(\"should not have been called\")\n\t\t}\n\t\tif hadUser {\n\t\t\tt.Error(\"should not have had user\")\n\t\t}\n\t})\n\tt.Run(\"RejectUnauthorized\", func(t *testing.T) {\n\t\tab.Storage.SessionState = mockClientStateReadWriter{}\n\n\t\trec, called, hadUser := setupMore(false, RequireNone, RespondUnauthorized)\n\n\t\tif rec.Code != http.StatusUnauthorized {\n\t\t\tt.Error(\"wrong code:\", rec.Code)\n\t\t}\n\t\tif called {\n\t\t\tt.Error(\"should not have been called\")\n\t\t}\n\t\tif hadUser {\n\t\t\tt.Error(\"should not have had user\")\n\t\t}\n\t})\n\tt.Run(\"RejectRedirect\", func(t *testing.T) {\n\t\tredir := &testRedirector{}\n\t\tab.Config.Core.Redirector = redir\n\n\t\tab.Storage.SessionState = mockClientStateReadWriter{}\n\n\t\t_, called, hadUser := setupMore(false, RequireNone, RespondRedirect)\n\n\t\tif redir.Opts.Code != http.StatusTemporaryRedirect {\n\t\t\tt.Error(\"code was wrong:\", redir.Opts.Code)\n\t\t}\n\t\tif redir.Opts.RedirectPath != \"/auth/login?redir=%2Fsuper%2Fsecret\" {\n\t\t\tt.Error(\"redirect path was wrong:\", redir.Opts.RedirectPath)\n\t\t}\n\t\tif called {\n\t\t\tt.Error(\"should not have been called\")\n\t\t}\n\t\tif hadUser {\n\t\t\tt.Error(\"should not have had user\")\n\t\t}\n\t})\n\tt.Run(\"RejectMountpathedRedirect\", func(t *testing.T) {\n\t\tredir := &testRedirector{}\n\t\tab.Config.Core.Redirector = redir\n\n\t\tab.Storage.SessionState = mockClientStateReadWriter{}\n\n\t\t_, called, hadUser := setupMore(true, RequireNone, RespondRedirect)\n\n\t\tif redir.Opts.Code != http.StatusTemporaryRedirect {\n\t\t\tt.Error(\"code was wrong:\", redir.Opts.Code)\n\t\t}\n\t\tif redir.Opts.RedirectPath != \"/auth/login?redir=%2Fauth%2Fsuper%2Fsecret\" {\n\t\t\tt.Error(\"redirect path was wrong:\", redir.Opts.RedirectPath)\n\t\t}\n\t\tif called {\n\t\t\tt.Error(\"should not have been called\")\n\t\t}\n\t\tif hadUser {\n\t\t\tt.Error(\"should not have had user\")\n\t\t}\n\t})\n\tt.Run(\"RequireFullAuth\", func(t *testing.T) {\n\t\tab.Storage.SessionState = mockClientStateReadWriter{\n\t\t\tstate: mockClientState{SessionKey: \"test@test.com\", SessionHalfAuthKey: \"true\"},\n\t\t}\n\n\t\trec, called, hadUser := setupMore(false, RequireFullAuth, RespondNotFound)\n\t\tif rec.Code != http.StatusNotFound {\n\t\t\tt.Error(\"wrong code:\", rec.Code)\n\t\t}\n\t\tif called {\n\t\t\tt.Error(\"should not have been called\")\n\t\t}\n\t\tif hadUser {\n\t\t\tt.Error(\"should not have had user\")\n\t\t}\n\t})\n\tt.Run(\"Require2FA\", func(t *testing.T) {\n\t\tab.Storage.SessionState = mockClientStateReadWriter{\n\t\t\tstate: mockClientState{SessionKey: \"test@test.com\"},\n\t\t}\n\n\t\trec, called, hadUser := setupMore(false, Require2FA, RespondNotFound)\n\n\t\tif rec.Code != http.StatusNotFound {\n\t\t\tt.Error(\"wrong code:\", rec.Code)\n\t\t}\n\t\tif called {\n\t\t\tt.Error(\"should not have been called\")\n\t\t}\n\t\tif hadUser {\n\t\t\tt.Error(\"should not have had user\")\n\t\t}\n\t})\n}\n"
        },
        {
          "name": "circle.yml",
          "type": "blob",
          "size": 0.6181640625,
          "content": "test:\n  pre:\n    - go get github.com/jstemmer/go-junit-report\n    - go get github.com/mattn/goveralls\n  override:\n    - go test -v -race ./... > $CIRCLE_ARTIFACTS/gotest.txt\n    - >\n      echo \"mode: set\" > $CIRCLE_ARTIFACTS/coverage.txt &&\n      for i in $(go list ./...); do\n      rm -f coverage.tmp;\n      go test -v -coverprofile coverage.tmp $i;\n      tail -n +2 coverage.tmp >> $CIRCLE_ARTIFACTS/coverage.txt;\n      done\n  post:\n    - cat $CIRCLE_ARTIFACTS/gotest.txt | go-junit-report > $CIRCLE_TEST_REPORTS/junit.xml\n    - goveralls -coverprofile=$CIRCLE_ARTIFACTS/coverage.txt -service=circle-ci -repotoken=$COVERALLS_TOKEN\n"
        },
        {
          "name": "client_state.go",
          "type": "blob",
          "size": 12.2939453125,
          "content": "package authboss\n\nimport (\n\t\"bufio\"\n\t\"context\"\n\t\"errors\"\n\t\"fmt\"\n\t\"net\"\n\t\"net/http\"\n\t\"strings\"\n)\n\nconst (\n\t// SessionKey is the primarily used key by authboss.\n\tSessionKey = \"uid\"\n\t// SessionHalfAuthKey is used for sessions that have been authenticated by\n\t// the remember module. This serves as a way to force full authentication\n\t// by denying half-authed users acccess to sensitive areas.\n\tSessionHalfAuthKey = \"halfauth\"\n\t// SessionLastAction is the session key to retrieve the\n\t// last action of a user.\n\tSessionLastAction = \"last_action\"\n\t// Session2FA is set when a user has been authenticated with a second factor\n\tSession2FA = \"twofactor\"\n\t// Session2FAAuthToken is a random token set in the session to be verified\n\t// by e-mail.\n\tSession2FAAuthToken = \"twofactor_auth_token\"\n\t// Session2FAAuthed is in the session (and set to \"true\") when the user\n\t// has successfully verified the token sent via e-mail in the two factor\n\t// e-mail authentication process.\n\tSession2FAAuthed = \"twofactor_authed\"\n\t// SessionOAuth2State is the xsrf protection key for oauth.\n\tSessionOAuth2State = \"oauth2_state\"\n\t// SessionOAuth2Params is the additional settings for oauth\n\t// like redirection/remember.\n\tSessionOAuth2Params = \"oauth2_params\"\n\n\t// CookieRemember is used for cookies and form input names.\n\tCookieRemember = \"rm\"\n\n\t// FlashSuccessKey is used for storing success flash messages on the session\n\tFlashSuccessKey = \"flash_success\"\n\t// FlashErrorKey is used for storing success flash messages on the session\n\tFlashErrorKey = \"flash_error\"\n)\n\n// ClientStateEventKind is an enum.\ntype ClientStateEventKind int\n\n// ClientStateEvent kinds\nconst (\n\t// ClientStateEventPut means you should put the key-value pair into the\n\t// client state.\n\tClientStateEventPut ClientStateEventKind = iota\n\t// ClientStateEventPut means you should delete the key-value pair from the\n\t// client state.\n\tClientStateEventDel\n\t// ClientStateEventDelAll means you should delete EVERY key-value pair from\n\t// the client state - though a whitelist of keys that should not be deleted\n\t// may be passed through as a comma separated list of keys in\n\t// the ClientStateEvent.Key field.\n\tClientStateEventDelAll\n)\n\n// ClientStateEvent are the different events that can be recorded during\n// a request.\ntype ClientStateEvent struct {\n\tKind  ClientStateEventKind\n\tKey   string\n\tValue string\n}\n\n// ClientStateReadWriter is used to create a cookie storer from an http request.\n// Keep in mind security considerations for your implementation, Secure,\n// HTTP-Only, etc flags.\n//\n// There's two major uses for this. To create session storage, and remember me\n// cookies.\ntype ClientStateReadWriter interface {\n\t// ReadState should return a map like structure allowing it to look up\n\t// any values in the current session, or any cookie in the request\n\tReadState(*http.Request) (ClientState, error)\n\t// WriteState can sometimes be called with a nil ClientState in the event\n\t// that no ClientState was read in from LoadClientState\n\tWriteState(http.ResponseWriter, ClientState, []ClientStateEvent) error\n}\n\n// UnderlyingResponseWriter retrieves the response\n// writer underneath the current one. This allows us\n// to wrap and later discover the particular one that we want.\n// Keep in mind this should not be used to call the normal methods\n// of a responsewriter, just additional ones particular to that type\n// because it's possible to introduce subtle bugs otherwise.\ntype UnderlyingResponseWriter interface {\n\tUnderlyingResponseWriter() http.ResponseWriter\n}\n\n// WrappingResponseWriter is a response writer that can be unwrapped\n// is is used identically to [UnderlyingResponseWriter] but uses the standard\n// set out in [http.ResponseContoller]\ntype WrappingResponseWriter interface {\n\tUnwrap() http.ResponseWriter\n}\n\n// ClientState represents the client's current state and can answer queries\n// about it.\ntype ClientState interface {\n\tGet(key string) (string, bool)\n}\n\n// ClientStateResponseWriter is used to write out the client state at the last\n// moment before the response code is written.\ntype ClientStateResponseWriter struct {\n\thttp.ResponseWriter\n\n\tcookieStateRW  ClientStateReadWriter\n\tsessionStateRW ClientStateReadWriter\n\n\tcookieState  ClientState\n\tsessionState ClientState\n\n\thasWritten         bool\n\tcookieStateEvents  []ClientStateEvent\n\tsessionStateEvents []ClientStateEvent\n}\n\n// LoadClientStateMiddleware wraps all requests with the\n// ClientStateResponseWriter as well as loading the current client\n// state into the context for use.\nfunc (a *Authboss) LoadClientStateMiddleware(h http.Handler) http.Handler {\n\treturn http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\twriter := a.NewResponse(w)\n\t\trequest, err := a.LoadClientState(writer, r)\n\t\tif err != nil {\n\t\t\tlogger := a.RequestLogger(r)\n\t\t\tlogger.Errorf(\"failed to load client state %+v\", err)\n\n\t\t\tw.WriteHeader(http.StatusInternalServerError)\n\t\t\treturn\n\t\t}\n\n\t\th.ServeHTTP(writer, request)\n\t})\n}\n\n// NewResponse wraps the ResponseWriter with a ClientStateResponseWriter\nfunc (a *Authboss) NewResponse(w http.ResponseWriter) *ClientStateResponseWriter {\n\treturn &ClientStateResponseWriter{\n\t\tResponseWriter: w,\n\t\tcookieStateRW:  a.Config.Storage.CookieState,\n\t\tsessionStateRW: a.Config.Storage.SessionState,\n\t}\n}\n\n// LoadClientState loads the state from sessions and cookies\n// into the ResponseWriter for later use.\nfunc (a *Authboss) LoadClientState(w http.ResponseWriter, r *http.Request) (*http.Request, error) {\n\tif a.Storage.SessionState != nil {\n\t\tstate, err := a.Storage.SessionState.ReadState(r)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t} else if state != nil {\n\t\t\tc := MustClientStateResponseWriter(w)\n\t\t\tc.sessionState = state\n\t\t\tr = r.WithContext(context.WithValue(r.Context(), CTXKeySessionState, state))\n\t\t}\n\t}\n\tif a.Storage.CookieState != nil {\n\t\tstate, err := a.Storage.CookieState.ReadState(r)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t} else if state != nil {\n\t\t\tc := MustClientStateResponseWriter(w)\n\t\t\tc.cookieState = state\n\t\t\tr = r.WithContext(context.WithValue(r.Context(), CTXKeyCookieState, state))\n\t\t}\n\t}\n\n\treturn r, nil\n}\n\n// MustClientStateResponseWriter tries to find a csrw inside the response\n// writer by using the UnderlyingResponseWriter interface.\nfunc MustClientStateResponseWriter(w http.ResponseWriter) *ClientStateResponseWriter {\n\tfor {\n\t\tif c, ok := w.(*ClientStateResponseWriter); ok {\n\t\t\treturn c\n\t\t}\n\n\t\tif u, ok := w.(UnderlyingResponseWriter); ok {\n\t\t\tw = u.UnderlyingResponseWriter()\n\t\t\tcontinue\n\t\t}\n\n\t\tif u, ok := w.(WrappingResponseWriter); ok {\n\t\t\tw = u.Unwrap()\n\t\t\tcontinue\n\t\t}\n\n\t\tpanic(fmt.Sprintf(\"ResponseWriter must be a ClientStateResponseWriter or UnderlyingResponseWriter in (see: authboss.LoadClientStateMiddleware): %T\", w))\n\t}\n}\n\n// WriteHeader writes the header, but in order to handle errors from the\n// underlying ClientStateReadWriter, it has to panic.\nfunc (c *ClientStateResponseWriter) WriteHeader(code int) {\n\tif !c.hasWritten {\n\t\tif err := c.putClientState(); err != nil {\n\t\t\tpanic(err)\n\t\t}\n\t}\n\tc.ResponseWriter.WriteHeader(code)\n}\n\n// Header retrieves the underlying headers\nfunc (c ClientStateResponseWriter) Header() http.Header {\n\treturn c.ResponseWriter.Header()\n}\n\n// Hijack implements the http.Hijacker interface by calling the\n// underlying implementation if available.\nfunc (c ClientStateResponseWriter) Hijack() (net.Conn, *bufio.ReadWriter, error) {\n\th, ok := c.ResponseWriter.(http.Hijacker)\n\tif ok {\n\t\treturn h.Hijack()\n\t}\n\treturn nil, nil, errors.New(\"authboss: underlying ResponseWriter does not support hijacking\")\n}\n\n// Write ensures that the client state is written before any writes\n// to the body occur (before header flush to http client)\nfunc (c *ClientStateResponseWriter) Write(b []byte) (int, error) {\n\tif !c.hasWritten {\n\t\tif err := c.putClientState(); err != nil {\n\t\t\treturn 0, err\n\t\t}\n\t}\n\treturn c.ResponseWriter.Write(b)\n}\n\n// UnderlyingResponseWriter for this instance\nfunc (c *ClientStateResponseWriter) UnderlyingResponseWriter() http.ResponseWriter {\n\treturn c.ResponseWriter\n}\n\n// Unwrap is used by http.ResponseController in Go 1.20\nfunc (c *ClientStateResponseWriter) Unwrap() http.ResponseWriter {\n\treturn c.ResponseWriter\n}\n\nfunc (c *ClientStateResponseWriter) putClientState() error {\n\tif c.hasWritten {\n\t\tpanic(\"should not call putClientState twice\")\n\t}\n\tc.hasWritten = true\n\n\tif len(c.cookieStateEvents) == 0 && len(c.sessionStateEvents) == 0 {\n\t\treturn nil\n\t}\n\n\tif c.sessionStateRW != nil && len(c.sessionStateEvents) > 0 {\n\t\terr := c.sessionStateRW.WriteState(c, c.sessionState, c.sessionStateEvents)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\tif c.cookieStateRW != nil && len(c.cookieStateEvents) > 0 {\n\t\terr := c.cookieStateRW.WriteState(c, c.cookieState, c.cookieStateEvents)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\treturn nil\n}\n\n// IsFullyAuthed returns false if the user has a SessionHalfAuth\n// in his session.\nfunc IsFullyAuthed(r *http.Request) bool {\n\t_, hasHalfAuth := GetSession(r, SessionHalfAuthKey)\n\treturn !hasHalfAuth\n}\n\n// IsTwoFactored returns false if the user doesn't have a Session2FA\n// in his session.\nfunc IsTwoFactored(r *http.Request) bool {\n\t_, has2fa := GetSession(r, Session2FA)\n\treturn has2fa\n}\n\n// DelAllSession deletes all variables in the session except for those on\n// the whitelist.\n//\n// The whitelist is typically provided directly from the authboss config.\n//\n// This is the best way to ensure the session is cleaned up after use for\n// a given user. An example is when a user is expired or logged out this method\n// is called.\nfunc DelAllSession(w http.ResponseWriter, whitelist []string) {\n\tdelAllState(w, CTXKeySessionState, whitelist)\n}\n\n// DelKnownSession is deprecated. See DelAllSession for an alternative.\n// DelKnownSession deletes all known session variables,\n// effectively logging a user out.\nfunc DelKnownSession(w http.ResponseWriter) {\n\tDelSession(w, SessionKey)\n\tDelSession(w, SessionHalfAuthKey)\n\tDelSession(w, SessionLastAction)\n}\n\n// DelKnownCookie deletes all known cookie variables, which can be used\n// to delete remember me pieces.\nfunc DelKnownCookie(w http.ResponseWriter) {\n\tDelCookie(w, CookieRemember)\n}\n\n// PutSession puts a value into the session\nfunc PutSession(w http.ResponseWriter, key, val string) {\n\tputState(w, CTXKeySessionState, key, val)\n}\n\n// DelSession deletes a key-value from the session.\nfunc DelSession(w http.ResponseWriter, key string) {\n\tdelState(w, CTXKeySessionState, key)\n}\n\n// GetSession fetches a value from the session\nfunc GetSession(r *http.Request, key string) (string, bool) {\n\treturn getState(r, CTXKeySessionState, key)\n}\n\n// PutCookie puts a value into the session\nfunc PutCookie(w http.ResponseWriter, key, val string) {\n\tputState(w, CTXKeyCookieState, key, val)\n}\n\n// DelCookie deletes a key-value from the session.\nfunc DelCookie(w http.ResponseWriter, key string) {\n\tdelState(w, CTXKeyCookieState, key)\n}\n\n// GetCookie fetches a value from the session\nfunc GetCookie(r *http.Request, key string) (string, bool) {\n\treturn getState(r, CTXKeyCookieState, key)\n}\n\nfunc putState(w http.ResponseWriter, CTXKey contextKey, key, val string) {\n\tsetState(w, CTXKey, ClientStateEventPut, key, val)\n}\n\nfunc delState(w http.ResponseWriter, CTXKey contextKey, key string) {\n\tsetState(w, CTXKey, ClientStateEventDel, key, \"\")\n}\n\nfunc delAllState(w http.ResponseWriter, CTXKey contextKey, whitelist []string) {\n\tsetState(w, CTXKey, ClientStateEventDelAll, strings.Join(whitelist, \",\"), \"\")\n}\n\nfunc setState(w http.ResponseWriter, ctxKey contextKey, op ClientStateEventKind, key, val string) {\n\tcsrw := MustClientStateResponseWriter(w)\n\tev := ClientStateEvent{\n\t\tKind: op,\n\t\tKey:  key,\n\t}\n\n\tif op == ClientStateEventPut {\n\t\tev.Value = val\n\t}\n\n\tswitch ctxKey {\n\tcase CTXKeySessionState:\n\t\tcsrw.sessionStateEvents = append(csrw.sessionStateEvents, ev)\n\tcase CTXKeyCookieState:\n\t\tcsrw.cookieStateEvents = append(csrw.cookieStateEvents, ev)\n\t}\n}\n\nfunc getState(r *http.Request, ctxKey contextKey, key string) (string, bool) {\n\tval := r.Context().Value(ctxKey)\n\tif val == nil {\n\t\treturn \"\", false\n\t}\n\n\tstate := val.(ClientState)\n\treturn state.Get(key)\n}\n\n// FlashSuccess returns FlashSuccessKey from the session and removes it.\nfunc FlashSuccess(w http.ResponseWriter, r *http.Request) string {\n\tstr, ok := GetSession(r, FlashSuccessKey)\n\tif !ok {\n\t\treturn \"\"\n\t}\n\n\tDelSession(w, FlashSuccessKey)\n\treturn str\n}\n\n// FlashError returns FlashError from the session and removes it.\nfunc FlashError(w http.ResponseWriter, r *http.Request) string {\n\tstr, ok := GetSession(r, FlashErrorKey)\n\tif !ok {\n\t\treturn \"\"\n\t}\n\n\tDelSession(w, FlashErrorKey)\n\treturn str\n}\n"
        },
        {
          "name": "client_state_test.go",
          "type": "blob",
          "size": 4.939453125,
          "content": "package authboss\n\nimport (\n\t\"io\"\n\t\"net/http/httptest\"\n\t\"strings\"\n\t\"testing\"\n)\n\nfunc TestStateGet(t *testing.T) {\n\tt.Parallel()\n\n\tab := New()\n\tab.Storage.SessionState = newMockClientStateRW(\"one\", \"two\")\n\tab.Storage.CookieState = newMockClientStateRW(\"three\", \"four\")\n\n\tr := httptest.NewRequest(\"GET\", \"/\", nil)\n\tw := ab.NewResponse(httptest.NewRecorder())\n\n\tvar err error\n\tr, err = ab.LoadClientState(w, r)\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n\n\tif got, _ := GetSession(r, \"one\"); got != \"two\" {\n\t\tt.Error(\"session value was wrong:\", got)\n\t}\n\tif got, _ := GetCookie(r, \"three\"); got != \"four\" {\n\t\tt.Error(\"cookie value was wrong:\", got)\n\t}\n}\n\nfunc TestStateResponseWriterDoubleWritePanic(t *testing.T) {\n\tt.Parallel()\n\n\tab := New()\n\tab.Storage.SessionState = newMockClientStateRW(\"one\", \"two\")\n\n\tw := ab.NewResponse(httptest.NewRecorder())\n\n\tw.WriteHeader(200)\n\t// Check this doesn't panic\n\tw.WriteHeader(200)\n\n\tdefer func() {\n\t\tif recover() == nil {\n\t\t\tt.Error(\"expected a panic\")\n\t\t}\n\t}()\n\n\t_ = w.putClientState()\n}\n\nfunc TestStateResponseWriterLastSecondWriteHeader(t *testing.T) {\n\tt.Parallel()\n\n\tab := New()\n\tab.Storage.SessionState = newMockClientStateRW()\n\n\tw := ab.NewResponse(httptest.NewRecorder())\n\n\tPutSession(w, \"one\", \"two\")\n\n\tw.WriteHeader(200)\n\tgot := strings.TrimSpace(w.Header().Get(\"test_session\"))\n\tif got != `{\"one\":\"two\"}` {\n\t\tt.Error(\"got:\", got)\n\t}\n}\n\nfunc TestStateResponseWriterLastSecondWriteWrite(t *testing.T) {\n\tt.Parallel()\n\n\tab := New()\n\tab.Storage.SessionState = newMockClientStateRW()\n\n\tw := ab.NewResponse(httptest.NewRecorder())\n\n\tPutSession(w, \"one\", \"two\")\n\n\tio.WriteString(w, \"Hello world!\")\n\n\tgot := strings.TrimSpace(w.Header().Get(\"test_session\"))\n\tif got != `{\"one\":\"two\"}` {\n\t\tt.Error(\"got:\", got)\n\t}\n}\n\nfunc TestStateResponseWriterEvents(t *testing.T) {\n\tt.Parallel()\n\n\tab := New()\n\tw := ab.NewResponse(httptest.NewRecorder())\n\n\tPutSession(w, \"one\", \"two\")\n\tDelSession(w, \"one\")\n\tDelCookie(w, \"one\")\n\tPutCookie(w, \"two\", \"one\")\n\n\twant := ClientStateEvent{Kind: ClientStateEventPut, Key: \"one\", Value: \"two\"}\n\tif got := w.sessionStateEvents[0]; got != want {\n\t\tt.Error(\"event was wrong\", got)\n\t}\n\n\twant = ClientStateEvent{Kind: ClientStateEventDel, Key: \"one\"}\n\tif got := w.sessionStateEvents[1]; got != want {\n\t\tt.Error(\"event was wrong\", got)\n\t}\n\n\twant = ClientStateEvent{Kind: ClientStateEventDel, Key: \"one\"}\n\tif got := w.cookieStateEvents[0]; got != want {\n\t\tt.Error(\"event was wrong\", got)\n\t}\n\n\twant = ClientStateEvent{Kind: ClientStateEventPut, Key: \"two\", Value: \"one\"}\n\tif got := w.cookieStateEvents[1]; got != want {\n\t\tt.Error(\"event was wrong\", got)\n\t}\n}\n\nfunc TestFlashClearer(t *testing.T) {\n\tt.Parallel()\n\n\tab := New()\n\tab.Storage.SessionState = newMockClientStateRW(FlashSuccessKey, \"a\", FlashErrorKey, \"b\")\n\n\tr := httptest.NewRequest(\"GET\", \"/\", nil)\n\tw := ab.NewResponse(httptest.NewRecorder())\n\n\tif msg := FlashSuccess(w, r); msg != \"\" {\n\t\tt.Error(\"unexpected flash success:\", msg)\n\t}\n\n\tif msg := FlashError(w, r); msg != \"\" {\n\t\tt.Error(\"unexpected flash error:\", msg)\n\t}\n\n\tvar err error\n\tr, err = ab.LoadClientState(w, r)\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n\n\tif msg := FlashSuccess(w, r); msg != \"a\" {\n\t\tt.Error(\"Unexpected flash success:\", msg)\n\t}\n\n\tif msg := FlashError(w, r); msg != \"b\" {\n\t\tt.Error(\"Unexpected flash error:\", msg)\n\t}\n\n\twant := ClientStateEvent{Kind: ClientStateEventDel, Key: FlashSuccessKey}\n\tif got := w.sessionStateEvents[0]; got != want {\n\t\tt.Error(\"event was wrong\", got)\n\t}\n\twant = ClientStateEvent{Kind: ClientStateEventDel, Key: FlashErrorKey}\n\tif got := w.sessionStateEvents[1]; got != want {\n\t\tt.Error(\"event was wrong\", got)\n\t}\n}\n\nfunc TestDelAllSession(t *testing.T) {\n\tt.Parallel()\n\n\tcsrw := &ClientStateResponseWriter{}\n\n\tDelAllSession(csrw, []string{\"notthisone\", \"orthis\"})\n\n\tif len(csrw.sessionStateEvents) != 1 {\n\t\tt.Error(\"should have one delete all\")\n\t}\n\tif ev := csrw.sessionStateEvents[0]; ev.Kind != ClientStateEventDelAll {\n\t\tt.Error(\"it should be a delete all event:\", ev.Kind)\n\t} else if ev.Key != \"notthisone,orthis\" {\n\t\tt.Error(\"the whitelist should be passed through as CSV:\", ev.Key)\n\t}\n}\n\nfunc TestDelKnown(t *testing.T) {\n\tt.Parallel()\n\n\tcsrw := &ClientStateResponseWriter{}\n\n\tDelKnownSession(csrw)\n\tDelKnownCookie(csrw)\n\n\tmustBeDel := func(ev ClientStateEvent) {\n\t\tt.Helper()\n\t\tif ev.Kind != ClientStateEventDel {\n\t\t\tt.Error(\"events should all be deletes\")\n\t\t}\n\t}\n\n\tif len(csrw.sessionStateEvents) != 3 {\n\t\tt.Error(\"should have deleted 3 session entries\")\n\t}\n\tmustBeDel(csrw.sessionStateEvents[0])\n\tmustBeDel(csrw.sessionStateEvents[1])\n\tmustBeDel(csrw.sessionStateEvents[2])\n\n\tfor i, key := range []string{SessionKey, SessionHalfAuthKey, SessionLastAction} {\n\t\tif sessionKey := csrw.sessionStateEvents[i].Key; key != sessionKey {\n\t\t\tt.Errorf(\"%d) key was wrong, want: %s, got: %s\", i, key, sessionKey)\n\t\t}\n\t}\n\n\tif len(csrw.cookieStateEvents) != 1 {\n\t\tt.Error(\"should have deleted 1 cookie\")\n\t}\n\tmustBeDel(csrw.cookieStateEvents[0])\n\tif key := csrw.cookieStateEvents[0].Key; key != CookieRemember {\n\t\tt.Error(\"cookie key was wrong:\", key)\n\t}\n}\n"
        },
        {
          "name": "config.go",
          "type": "blob",
          "size": 10.2421875,
          "content": "package authboss\n\nimport (\n\t\"net/http\"\n\t\"time\"\n\n\t\"golang.org/x/crypto/bcrypt\"\n)\n\n// Config holds all the configuration for both authboss and it's modules.\ntype Config struct {\n\tPaths struct {\n\t\t// Mount is the path to mount authboss's routes at (eg /auth).\n\t\tMount string\n\n\t\t// NotAuthorized is the default URL to kick users back to when\n\t\t// they attempt an action that requires them to be logged in and\n\t\t// they're not auth'd\n\t\tNotAuthorized string\n\n\t\t// AuthLoginOK is the redirect path after a successful authentication.\n\t\tAuthLoginOK string\n\n\t\t// ConfirmOK once a user has confirmed their account\n\t\t// this says where they should go\n\t\tConfirmOK string\n\t\t// ConfirmNotOK is used by the middleware, when a user is still supposed\n\t\t// to confirm their account, this is where they should be redirected to.\n\t\tConfirmNotOK string\n\n\t\t// LockNotOK is a path to go to when the user fails\n\t\tLockNotOK string\n\n\t\t// LogoutOK is the redirect path after a log out.\n\t\tLogoutOK string\n\n\t\t// OAuth2LoginOK is the redirect path after a successful oauth2 login\n\t\tOAuth2LoginOK string\n\t\t// OAuth2LoginNotOK is the redirect path after\n\t\t// an unsuccessful oauth2 login\n\t\tOAuth2LoginNotOK string\n\n\t\t// RecoverOK is the redirect path after a successful recovery of a\n\t\t// password.\n\t\tRecoverOK string\n\n\t\t// RegisterOK is the redirect path after a successful registration.\n\t\tRegisterOK string\n\n\t\t// RootURL is the scheme+host+port of the web application\n\t\t// (eg https://www.happiness.com:8080) for url generation.\n\t\t// No trailing slash.\n\t\tRootURL string\n\n\t\t// TwoFactorEmailAuthNotOK is where a user is redirected when\n\t\t// the user attempts to add 2fa to their account without verifying\n\t\t// their e-mail OR when they've completed the first step towards\n\t\t// verification and need to check their e-mail to proceed.\n\t\tTwoFactorEmailAuthNotOK string\n\t}\n\n\tModules struct {\n\t\t// BCryptCost is the cost of the bcrypt password hashing function.\n\t\t// Deprecated: Use Hasher instead.\n\t\tBCryptCost int\n\n\t\t// ConfirmMethod IS DEPRECATED! See MailRouteMethod instead.\n\t\t//\n\t\t// ConfirmMethod controls which http method confirm expects.\n\t\t// This is because typically this is a GET request since it's a link\n\t\t// from an e-mail, but in api-like cases it needs to be able to be a\n\t\t// post since there's data that must be sent to it.\n\t\tConfirmMethod string\n\n\t\t// ExpireAfter controls the time an account is idle before being\n\t\t// logged out by the ExpireMiddleware.\n\t\tExpireAfter time.Duration\n\n\t\t// LockAfter this many tries.\n\t\tLockAfter int\n\t\t// LockWindow is the waiting time before the number of attempts are reset.\n\t\tLockWindow time.Duration\n\t\t// LockDuration is how long an account is locked for.\n\t\tLockDuration time.Duration\n\n\t\t// LogoutMethod is the method the logout route should use\n\t\t// (default should be DELETE)\n\t\tLogoutMethod string\n\n\t\t// MailRouteMethod is used to set the type of request that's used for\n\t\t// routes that require a token from an e-mail link's query string.\n\t\t// This is things like confirm and two factor e-mail auth.\n\t\t//\n\t\t// You should probably set this to POST if you are building an API\n\t\t// so that the user goes to the frontend with their link & token\n\t\t// and the front-end calls the API with the token in a POST JSON body.\n\t\t//\n\t\t// This configuration setting deprecates ConfirmMethod.\n\t\t// If ConfirmMethod is set to the default value (GET) then\n\t\t// MailRouteMethod is used. If ConfirmMethod is not the default value\n\t\t// then it is used until Authboss v3 when only MailRouteMethod will be\n\t\t// used.\n\t\tMailRouteMethod string\n\n\t\t// MailNoGoroutine is used to prevent the mailer from being launched\n\t\t// in a goroutine by the Authboss modules.\n\t\t//\n\t\t// This behavior will become the default in Authboss v3 and each\n\t\t// Mailer implementation will be required to use goroutines if it sees\n\t\t// fit.\n\t\t//\n\t\t// It's important that this is the case if you are using contexts\n\t\t// as the http request context will be cancelled by the Go http server\n\t\t// and it may interrupt your use of the context that the Authboss module\n\t\t// is passing to you, preventing proper use of it.\n\t\tMailNoGoroutine bool\n\n\t\t// RegisterPreserveFields are fields used with registration that are\n\t\t// to be rendered when post fails in a normal way\n\t\t// (for example validation errors), they will be passed back in the\n\t\t// data of the response under the key DataPreserve which\n\t\t// will be a map[string]string.\n\t\t//\n\t\t// All fields that are to be preserved must be able to be returned by\n\t\t// the ArbitraryValuer.GetValues()\n\t\t//\n\t\t// This means in order to have a field named \"address\" you would need\n\t\t// to have that returned by the ArbitraryValuer.GetValues() method and\n\t\t// then it would be available to be whitelisted by this\n\t\t// configuration variable.\n\t\tRegisterPreserveFields []string\n\n\t\t// RecoverTokenDuration controls how long a token sent via\n\t\t// email for password recovery is valid for.\n\t\tRecoverTokenDuration time.Duration\n\t\t// RecoverLoginAfterRecovery if true will log users in after password\n\t\t// recovery, if false they will be redirected and need to log in\n\t\t// again manually.\n\t\tRecoverLoginAfterRecovery bool\n\n\t\t// OAuth2Providers lists all providers that can be used. See\n\t\t// OAuthProvider documentation for more details.\n\t\tOAuth2Providers map[string]OAuth2Provider\n\n\t\t// TwoFactorEmailAuthRequired forces users to first confirm they have\n\t\t// access to their e-mail with the current device by clicking a link\n\t\t// and confirming a token stored in the session.\n\t\tTwoFactorEmailAuthRequired bool\n\n\t\t// TOTP2FAIssuer is the issuer that appears in the url when scanning\n\t\t// a qr code for google authenticator.\n\t\tTOTP2FAIssuer string\n\n\t\t// DEPRECATED: See ResponseOnUnauthed\n\t\t// RoutesRedirectOnUnauthed controls whether or not a user is redirected\n\t\t// or given a 404 when they are unauthenticated and attempting to access\n\t\t// a route that's login-protected inside Authboss itself.\n\t\t// The otp/twofactor modules all use authboss.Middleware to protect\n\t\t// their routes and this is the redirectToLogin parameter in that\n\t\t// middleware that they pass through.\n\t\tRoutesRedirectOnUnauthed bool\n\n\t\t// ResponseOnUnauthed controls how a user is responded to when\n\t\t// attempting to access a route that's login-protected inside Authboss\n\t\t// itself. The otp/twofactor modules all use authboss.Middleware2 to\n\t\t// protect their routes and this is the failResponse parameter in that\n\t\t// middleware that they pass through.\n\t\t//\n\t\t// This deprecates RoutesRedirectOnUnauthed. If RoutesRedirectOnUnauthed\n\t\t// is true, the value of this will be set to RespondRedirect until\n\t\t// authboss v3.\n\t\tResponseOnUnauthed MWRespondOnFailure\n\t}\n\n\tMail struct {\n\t\t// RootURL is a full path to an application that is hosting a front-end\n\t\t// Typically using a combination of Paths.RootURL and Paths.Mount\n\t\t// MailRoot will be assembled if not set.\n\t\t// Typically looks like: https://our-front-end.com/authenication\n\t\t// No trailing slash.\n\t\tRootURL string\n\n\t\t// From is the email address authboss e-mails come from.\n\t\tFrom string\n\t\t// FromName is the name authboss e-mails come from.\n\t\tFromName string\n\t\t// SubjectPrefix is used to add something to the front of the authboss\n\t\t// email subjects.\n\t\tSubjectPrefix string\n\t}\n\n\tStorage struct {\n\t\t// Storer is the interface through which Authboss accesses the web apps\n\t\t// database for user operations.\n\t\tServer ServerStorer\n\n\t\t// CookieState must be defined to provide an interface capapable of\n\t\t// storing cookies for the given response, and reading them from the\n\t\t// request.\n\t\tCookieState ClientStateReadWriter\n\t\t// SessionState must be defined to provide an interface capable of\n\t\t// storing session-only values for the given response, and reading them\n\t\t// from the request.\n\t\tSessionState ClientStateReadWriter\n\n\t\t// SessionStateWhitelistKeys are set to preserve keys in the session\n\t\t// when authboss.DelAllSession is called. A correct implementation\n\t\t// of ClientStateReadWriter will delete ALL session key-value pairs\n\t\t// unless that key is whitelisted here.\n\t\tSessionStateWhitelistKeys []string\n\t}\n\n\tCore struct {\n\t\t// Router is the entity that controls all routing to authboss routes\n\t\t// modules will register their routes with it.\n\t\tRouter Router\n\n\t\t// ErrorHandler wraps http requests with centralized error handling.\n\t\tErrorHandler ErrorHandler\n\n\t\t// Responder takes a generic response from a controller and prepares\n\t\t// the response, uses a renderer to create the body, and replies to the\n\t\t// http request.\n\t\tResponder HTTPResponder\n\n\t\t// Redirector can redirect a response, similar to Responder but\n\t\t// responsible only for redirection.\n\t\tRedirector HTTPRedirector\n\n\t\t// BodyReader reads validatable data from the body of a request to\n\t\t// be able to get data from the user's client.\n\t\tBodyReader BodyReader\n\n\t\t// ViewRenderer loads the templates for the application.\n\t\tViewRenderer Renderer\n\t\t// MailRenderer loads the templates for mail. If this is nil, it will\n\t\t// fall back to using the Renderer created from the ViewLoader instead.\n\t\tMailRenderer Renderer\n\n\t\t// Mailer is the mailer being used to send e-mails out via smtp\n\t\tMailer Mailer\n\n\t\t// Hasher hashes passwords into hashes\n\t\tHasher Hasher\n\n\t\t// OneTimeTokenGenerator generates credentials (selector+verified+token)\n\t\tOneTimeTokenGenerator OneTimeTokenGenerator\n\n\t\t// Logger implies just a few log levels for use, can optionally\n\t\t// also implement the ContextLogger to be able to upgrade to a\n\t\t// request specific logger.\n\t\tLogger Logger\n\n\t\t// Localizer is used to translate strings into different languages.\n\t\tLocalizer Localizer\n\t}\n}\n\n// Defaults sets the configuration's default values.\nfunc (c *Config) Defaults() {\n\tc.Paths.Mount = \"/auth\"\n\tc.Paths.NotAuthorized = \"/\"\n\tc.Paths.AuthLoginOK = \"/\"\n\tc.Paths.ConfirmOK = \"/\"\n\tc.Paths.ConfirmNotOK = \"/\"\n\tc.Paths.LockNotOK = \"/\"\n\tc.Paths.LogoutOK = \"/\"\n\tc.Paths.OAuth2LoginOK = \"/\"\n\tc.Paths.OAuth2LoginNotOK = \"/\"\n\tc.Paths.RecoverOK = \"/\"\n\tc.Paths.RegisterOK = \"/\"\n\tc.Paths.RootURL = \"http://localhost:8080\"\n\tc.Paths.TwoFactorEmailAuthNotOK = \"/\"\n\n\tc.Modules.BCryptCost = bcrypt.DefaultCost\n\tc.Modules.ConfirmMethod = http.MethodGet\n\tc.Modules.ExpireAfter = time.Hour\n\tc.Modules.LockAfter = 3\n\tc.Modules.LockWindow = 5 * time.Minute\n\tc.Modules.LockDuration = 12 * time.Hour\n\tc.Modules.LogoutMethod = \"DELETE\"\n\tc.Modules.MailRouteMethod = http.MethodGet\n\tc.Modules.RecoverLoginAfterRecovery = false\n\tc.Modules.RecoverTokenDuration = 24 * time.Hour\n\n\tc.Core.OneTimeTokenGenerator = NewSha512TokenGenerator()\n}\n"
        },
        {
          "name": "confirm",
          "type": "tree",
          "content": null
        },
        {
          "name": "context.go",
          "type": "blob",
          "size": 4.1396484375,
          "content": "package authboss\n\nimport (\n\t\"context\"\n\t\"net/http\"\n)\n\ntype contextKey string\n\n// CTX Keys for authboss\nconst (\n\tCTXKeyPID  contextKey = \"pid\"\n\tCTXKeyUser contextKey = \"user\"\n\n\tCTXKeySessionState contextKey = \"session\"\n\tCTXKeyCookieState  contextKey = \"cookie\"\n\n\t// CTXKeyData is a context key for the accumulating\n\t// map[string]interface{} (authboss.HTMLData) to pass to the\n\t// renderer\n\tCTXKeyData contextKey = \"data\"\n\n\t// CTXKeyValues is to pass the data submitted from API request or form\n\t// along in the context in case modules need it. The only module that needs\n\t// user information currently is remember so only auth/oauth2 are currently\n\t// going to use this.\n\tCTXKeyValues contextKey = \"values\"\n)\n\nfunc (c contextKey) String() string {\n\treturn \"authboss ctx key \" + string(c)\n}\n\n// CurrentUserID retrieves the current user from the session.\n// TODO(aarondl): This method never returns an error, one day we'll change\n// the function signature.\nfunc (a *Authboss) CurrentUserID(r *http.Request) (string, error) {\n\tif pid := r.Context().Value(CTXKeyPID); pid != nil {\n\t\treturn pid.(string), nil\n\t}\n\n\tpid, _ := GetSession(r, SessionKey)\n\treturn pid, nil\n}\n\n// CurrentUserIDP retrieves the current user but panics if it's not available for\n// any reason.\nfunc (a *Authboss) CurrentUserIDP(r *http.Request) string {\n\ti, err := a.CurrentUserID(r)\n\tif err != nil {\n\t\tpanic(err)\n\t} else if len(i) == 0 {\n\t\tpanic(ErrUserNotFound)\n\t}\n\n\treturn i\n}\n\n// CurrentUser retrieves the current user from the session and the database.\n// Before the user is loaded from the database the context key is checked.\n// If the session doesn't have the user ID ErrUserNotFound will be returned.\nfunc (a *Authboss) CurrentUser(r *http.Request) (User, error) {\n\tif user := r.Context().Value(CTXKeyUser); user != nil {\n\t\treturn user.(User), nil\n\t}\n\n\tpid, err := a.CurrentUserID(r)\n\tif err != nil {\n\t\treturn nil, err\n\t} else if len(pid) == 0 {\n\t\treturn nil, ErrUserNotFound\n\t}\n\n\treturn a.currentUser(r.Context(), pid)\n}\n\n// CurrentUserP retrieves the current user but panics if it's not available for\n// any reason.\nfunc (a *Authboss) CurrentUserP(r *http.Request) User {\n\ti, err := a.CurrentUser(r)\n\tif err != nil {\n\t\tpanic(err)\n\t} else if i == nil {\n\t\tpanic(ErrUserNotFound)\n\t}\n\treturn i\n}\n\nfunc (a *Authboss) currentUser(ctx context.Context, pid string) (User, error) {\n\treturn a.Storage.Server.Load(ctx, pid)\n}\n\n// LoadCurrentUserID takes a pointer to a pointer to the request in order to\n// change the current method's request pointer itself to the new request that\n// contains the new context that has the pid in it.\nfunc (a *Authboss) LoadCurrentUserID(r **http.Request) (string, error) {\n\tpid, err := a.CurrentUserID(*r)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\tif len(pid) == 0 {\n\t\treturn \"\", nil\n\t}\n\n\tctx := context.WithValue((**r).Context(), CTXKeyPID, pid)\n\t*r = (**r).WithContext(ctx)\n\n\treturn pid, nil\n}\n\n// LoadCurrentUserIDP loads the current user id and panics if it's not found\nfunc (a *Authboss) LoadCurrentUserIDP(r **http.Request) string {\n\tpid, err := a.LoadCurrentUserID(r)\n\tif err != nil {\n\t\tpanic(err)\n\t} else if len(pid) == 0 {\n\t\tpanic(ErrUserNotFound)\n\t}\n\n\treturn pid\n}\n\n// LoadCurrentUser takes a pointer to a pointer to the request in order to\n// change the current method's request pointer itself to the new request that\n// contains the new context that has the user in it. Calls LoadCurrentUserID\n// so the primary id is also put in the context.\nfunc (a *Authboss) LoadCurrentUser(r **http.Request) (User, error) {\n\tif user := (*r).Context().Value(CTXKeyUser); user != nil {\n\t\treturn user.(User), nil\n\t}\n\n\tpid, err := a.LoadCurrentUserID(r)\n\tif err != nil {\n\t\treturn nil, err\n\t} else if len(pid) == 0 {\n\t\treturn nil, ErrUserNotFound\n\t}\n\n\tctx := (**r).Context()\n\tuser, err := a.currentUser(ctx, pid)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tctx = context.WithValue(ctx, CTXKeyUser, user)\n\t*r = (**r).WithContext(ctx)\n\treturn user, nil\n}\n\n// LoadCurrentUserP does the same as LoadCurrentUser but panics if\n// the current user is not found.\nfunc (a *Authboss) LoadCurrentUserP(r **http.Request) User {\n\tuser, err := a.LoadCurrentUser(r)\n\tif err != nil {\n\t\tpanic(err)\n\t} else if user == nil {\n\t\tpanic(ErrUserNotFound)\n\t}\n\n\treturn user\n}\n"
        },
        {
          "name": "context_test.go",
          "type": "blob",
          "size": 4.4814453125,
          "content": "package authboss\n\nimport (\n\t\"context\"\n\t\"net/http\"\n\t\"net/http/httptest\"\n\t\"testing\"\n)\n\nfunc loadClientStateP(ab *Authboss, w http.ResponseWriter, r *http.Request) *http.Request {\n\tr, err := ab.LoadClientState(w, r)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\treturn r\n}\n\nfunc testSetupContext() (*Authboss, *http.Request) {\n\tab := New()\n\tab.Storage.SessionState = newMockClientStateRW(SessionKey, \"george-pid\")\n\tab.Storage.Server = &mockServerStorer{\n\t\tUsers: map[string]*mockUser{\n\t\t\t\"george-pid\": {Email: \"george-pid\", Password: \"unreadable\"},\n\t\t},\n\t}\n\tr := httptest.NewRequest(\"GET\", \"/\", nil)\n\tw := ab.NewResponse(httptest.NewRecorder())\n\tr = loadClientStateP(ab, w, r)\n\n\treturn ab, r\n}\n\nfunc testSetupContextCached() (*Authboss, *mockUser, *http.Request) {\n\tab := New()\n\twantUser := &mockUser{Email: \"george-pid\", Password: \"unreadable\"}\n\treq := httptest.NewRequest(\"GET\", \"/\", nil)\n\tctx := context.WithValue(req.Context(), CTXKeyPID, \"george-pid\")\n\tctx = context.WithValue(ctx, CTXKeyUser, wantUser)\n\treq = req.WithContext(ctx)\n\n\treturn ab, wantUser, req\n}\n\nfunc testSetupContextPanic() *Authboss {\n\tab := New()\n\tab.Storage.SessionState = newMockClientStateRW(SessionKey, \"george-pid\")\n\tab.Storage.Server = &mockServerStorer{}\n\n\treturn ab\n}\n\nfunc TestCurrentUserID(t *testing.T) {\n\tt.Parallel()\n\n\tab, r := testSetupContext()\n\n\tid, err := ab.CurrentUserID(r)\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n\n\tif id != \"george-pid\" {\n\t\tt.Error(\"got:\", id)\n\t}\n}\n\nfunc TestCurrentUserIDContext(t *testing.T) {\n\tt.Parallel()\n\n\tab, r := testSetupContext()\n\n\tid, err := ab.CurrentUserID(r)\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n\n\tif id != \"george-pid\" {\n\t\tt.Error(\"got:\", id)\n\t}\n}\n\nfunc TestCurrentUserIDP(t *testing.T) {\n\tt.Parallel()\n\n\tab := testSetupContextPanic()\n\t// Overwrite the setup functions state storer\n\tab.Storage.SessionState = newMockClientStateRW()\n\n\tdefer func() {\n\t\tif recover().(error) != ErrUserNotFound {\n\t\t\tt.Failed()\n\t\t}\n\t}()\n\n\t_ = ab.CurrentUserIDP(httptest.NewRequest(\"GET\", \"/\", nil))\n}\n\nfunc TestCurrentUser(t *testing.T) {\n\tt.Parallel()\n\n\tab, r := testSetupContext()\n\n\tuser, err := ab.CurrentUser(r)\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n\n\tif got := user.GetPID(); got != \"george-pid\" {\n\t\tt.Error(\"got:\", got)\n\t}\n}\n\nfunc TestCurrentUserContext(t *testing.T) {\n\tt.Parallel()\n\n\tab, _, r := testSetupContextCached()\n\n\tuser, err := ab.CurrentUser(r)\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n\n\tif got := user.GetPID(); got != \"george-pid\" {\n\t\tt.Error(\"got:\", got)\n\t}\n}\n\nfunc TestCurrentUserP(t *testing.T) {\n\tt.Parallel()\n\n\tab := testSetupContextPanic()\n\n\tdefer func() {\n\t\tif recover().(error) != ErrUserNotFound {\n\t\t\tt.Failed()\n\t\t}\n\t}()\n\n\t_ = ab.CurrentUserP(httptest.NewRequest(\"GET\", \"/\", nil))\n}\n\nfunc TestLoadCurrentUserID(t *testing.T) {\n\tt.Parallel()\n\n\tab, r := testSetupContext()\n\n\tid, err := ab.LoadCurrentUserID(&r)\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n\n\tif id != \"george-pid\" {\n\t\tt.Error(\"got:\", id)\n\t}\n\n\tif r.Context().Value(CTXKeyPID).(string) != \"george-pid\" {\n\t\tt.Error(\"context was not updated in local request\")\n\t}\n}\n\nfunc TestLoadCurrentUserIDContext(t *testing.T) {\n\tt.Parallel()\n\n\tab, _, r := testSetupContextCached()\n\n\tpid, err := ab.LoadCurrentUserID(&r)\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n\n\tif pid != \"george-pid\" {\n\t\tt.Error(\"got:\", pid)\n\t}\n}\n\nfunc TestLoadCurrentUserIDP(t *testing.T) {\n\tt.Parallel()\n\n\tab := testSetupContextPanic()\n\n\tdefer func() {\n\t\tif recover().(error) != ErrUserNotFound {\n\t\t\tt.Failed()\n\t\t}\n\t}()\n\n\tr := httptest.NewRequest(\"GET\", \"/\", nil)\n\t_ = ab.LoadCurrentUserIDP(&r)\n}\n\nfunc TestLoadCurrentUser(t *testing.T) {\n\tt.Parallel()\n\n\tab, r := testSetupContext()\n\n\tuser, err := ab.LoadCurrentUser(&r)\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n\n\tif got := user.GetPID(); got != \"george-pid\" {\n\t\tt.Error(\"got:\", got)\n\t}\n\n\twant := user.(*mockUser)\n\tgot := r.Context().Value(CTXKeyUser).(*mockUser)\n\tif got != want {\n\t\tt.Errorf(\"users mismatched:\\nwant: %#v\\ngot: %#v\", want, got)\n\t}\n}\n\nfunc TestLoadCurrentUserContext(t *testing.T) {\n\tt.Parallel()\n\n\tab, wantUser, r := testSetupContextCached()\n\n\tuser, err := ab.LoadCurrentUser(&r)\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n\n\tgot := user.(*mockUser)\n\tif got != wantUser {\n\t\tt.Errorf(\"users mismatched:\\nwant: %#v\\ngot: %#v\", wantUser, got)\n\t}\n}\n\nfunc TestLoadCurrentUserP(t *testing.T) {\n\tt.Parallel()\n\n\tab := testSetupContextPanic()\n\n\tdefer func() {\n\t\tif recover().(error) != ErrUserNotFound {\n\t\t\tt.Failed()\n\t\t}\n\t}()\n\n\tr := httptest.NewRequest(\"GET\", \"/\", nil)\n\t_ = ab.LoadCurrentUserP(&r)\n}\n\nfunc TestCTXKeyString(t *testing.T) {\n\tt.Parallel()\n\n\tif got := CTXKeyPID.String(); got != \"authboss ctx key pid\" {\n\t\tt.Error(got)\n\t}\n}\n"
        },
        {
          "name": "defaults",
          "type": "tree",
          "content": null
        },
        {
          "name": "docs",
          "type": "tree",
          "content": null
        },
        {
          "name": "errors.go",
          "type": "blob",
          "size": 0.2734375,
          "content": "package authboss\n\nimport (\n\t\"net/http\"\n)\n\n// ErrorHandler allows routing to http.HandlerFunc's that additionally\n// return an error for a higher level error handling mechanism.\ntype ErrorHandler interface {\n\tWrap(func(w http.ResponseWriter, r *http.Request) error) http.Handler\n}\n"
        },
        {
          "name": "events.go",
          "type": "blob",
          "size": 2.96484375,
          "content": "package authboss\n\nimport (\n\t\"net/http\"\n)\n\n//go:generate stringer -output stringers.go -type \"Event\"\n\n// Event type is for describing events\ntype Event int\n\n// Event kinds\nconst (\n\tEventRegister Event = iota\n\tEventAuth\n\t// EventAuthHijack is used to steal the authentication process after a\n\t// successful auth but before any session variable has been put in.\n\t// Most useful for defining an additional step for authentication\n\t// (like 2fa). It needs to be separate to EventAuth because other modules\n\t// do checks that would also interrupt event handlers with an authentication\n\t// failure so there's an ordering problem.\n\tEventAuthHijack\n\tEventOAuth2\n\tEventAuthFail\n\tEventOAuth2Fail\n\tEventRecoverStart\n\tEventRecoverEnd\n\tEventGetUser\n\tEventGetUserSession\n\t// Deprecated: EventPasswordReset is used nowhere\n\tEventPasswordReset\n\tEventLogout\n\tEventTwoFactorAdded\n\tEventTwoFactorRemoved\n)\n\n// EventHandler reacts to events that are fired by Authboss controllers.\n// These controllers will normally process a request by themselves, but if\n// there is special consideration for example a successful login, but the\n// user is locked, the lock module's controller may seize control over the\n// request.\n//\n// Very much a controller level middleware.\ntype EventHandler func(w http.ResponseWriter, r *http.Request, handled bool) (bool, error)\n\n// Events is a collection of Events that fire before and after certain methods.\ntype Events struct {\n\tbefore map[Event][]EventHandler\n\tafter  map[Event][]EventHandler\n}\n\n// NewEvents creates a new set of before and after Events.\nfunc NewEvents() *Events {\n\treturn &Events{\n\t\tbefore: make(map[Event][]EventHandler),\n\t\tafter:  make(map[Event][]EventHandler),\n\t}\n}\n\n// Before event, call f.\nfunc (c *Events) Before(e Event, f EventHandler) {\n\tevents := c.before[e]\n\tevents = append(events, f)\n\tc.before[e] = events\n}\n\n// After event, call f.\nfunc (c *Events) After(e Event, f EventHandler) {\n\tevents := c.after[e]\n\tevents = append(events, f)\n\tc.after[e] = events\n}\n\n// FireBefore executes the handlers that were registered to fire before\n// the event passed in.\n//\n// If it encounters an error it will stop immediately without calling\n// other handlers.\n//\n// If a handler handles the request, it will pass this information both\n// to handlers further down the chain (to let them know that w has been used)\n// as well as set w to nil as a precaution.\nfunc (c *Events) FireBefore(e Event, w http.ResponseWriter, r *http.Request) (bool, error) {\n\treturn c.call(c.before[e], w, r)\n}\n\n// FireAfter event to all the Events with a context. The error can safely be\n// ignored as it is logged.\nfunc (c *Events) FireAfter(e Event, w http.ResponseWriter, r *http.Request) (bool, error) {\n\treturn c.call(c.after[e], w, r)\n}\n\nfunc (c *Events) call(evs []EventHandler, w http.ResponseWriter, r *http.Request) (bool, error) {\n\thandled := false\n\n\tfor _, fn := range evs {\n\t\tinterrupt, err := fn(w, r, handled)\n\t\tif err != nil {\n\t\t\treturn false, err\n\t\t}\n\t\tif interrupt {\n\t\t\thandled = true\n\t\t}\n\t}\n\n\treturn handled, nil\n}\n"
        },
        {
          "name": "events_test.go",
          "type": "blob",
          "size": 3.294921875,
          "content": "package authboss\n\nimport (\n\t\"net/http\"\n\t\"testing\"\n\n\t\"github.com/friendsofgo/errors\"\n)\n\nfunc TestEvents(t *testing.T) {\n\tt.Parallel()\n\n\tab := New()\n\tafterCalled := false\n\tbeforeCalled := false\n\n\tab.Events.Before(EventRegister, func(http.ResponseWriter, *http.Request, bool) (bool, error) {\n\t\tbeforeCalled = true\n\t\treturn false, nil\n\t})\n\tab.Events.After(EventRegister, func(http.ResponseWriter, *http.Request, bool) (bool, error) {\n\t\tafterCalled = true\n\t\treturn false, nil\n\t})\n\n\tif beforeCalled || afterCalled {\n\t\tt.Error(\"Neither should be called.\")\n\t}\n\n\thandled, err := ab.Events.FireBefore(EventRegister, nil, nil)\n\tif err != nil {\n\t\tt.Error(\"Unexpected error:\", err)\n\t}\n\tif handled {\n\t\tt.Error(\"It should not have been handled.\")\n\t}\n\n\tif !beforeCalled {\n\t\tt.Error(\"Expected before to have been called.\")\n\t}\n\tif afterCalled {\n\t\tt.Error(\"Expected after not to be called.\")\n\t}\n\n\tab.Events.FireAfter(EventRegister, nil, nil)\n\tif !afterCalled {\n\t\tt.Error(\"Expected after to be called.\")\n\t}\n}\n\nfunc TestEventsHandled(t *testing.T) {\n\tt.Parallel()\n\n\tab := New()\n\tfirstCalled := false\n\tsecondCalled := false\n\n\tfirstHandled := false\n\tsecondHandled := false\n\n\tab.Events.Before(EventRegister, func(w http.ResponseWriter, r *http.Request, handled bool) (bool, error) {\n\t\tfirstCalled = true\n\t\tfirstHandled = handled\n\t\treturn true, nil\n\t})\n\tab.Events.Before(EventRegister, func(w http.ResponseWriter, r *http.Request, handled bool) (bool, error) {\n\t\tsecondCalled = true\n\t\tsecondHandled = handled\n\t\treturn false, nil\n\t})\n\n\thandled, err := ab.Events.FireBefore(EventRegister, nil, nil)\n\tif err != nil {\n\t\tt.Error(\"Unexpected error:\", err)\n\t}\n\tif !handled {\n\t\tt.Error(\"it should have been handled\")\n\t}\n\n\tif !firstCalled {\n\t\tt.Error(\"expected first to have been called\")\n\t}\n\tif !secondCalled {\n\t\tt.Error(\"expected second to have been called\")\n\t}\n\n\tif firstHandled {\n\t\tt.Error(\"first should not see the event as being handled\")\n\t}\n\tif !secondHandled {\n\t\tt.Error(\"second should see the event as being handled\")\n\t}\n}\n\nfunc TestEventsErrors(t *testing.T) {\n\tt.Parallel()\n\n\tab := New()\n\tfirstCalled := false\n\tsecondCalled := false\n\n\texpect := errors.New(\"error\")\n\n\tab.Events.Before(EventRegister, func(http.ResponseWriter, *http.Request, bool) (bool, error) {\n\t\tfirstCalled = true\n\t\treturn false, expect\n\t})\n\tab.Events.Before(EventRegister, func(http.ResponseWriter, *http.Request, bool) (bool, error) {\n\t\tsecondCalled = true\n\t\treturn false, nil\n\t})\n\n\t_, err := ab.Events.FireBefore(EventRegister, nil, nil)\n\tif err != expect {\n\t\tt.Error(\"got the wrong error back:\", err)\n\t}\n\n\tif !firstCalled {\n\t\tt.Error(\"expected first to have been called\")\n\t}\n\tif secondCalled {\n\t\tt.Error(\"expected second to not have been called\")\n\t}\n}\n\nfunc TestEventString(t *testing.T) {\n\tt.Parallel()\n\n\ttests := []struct {\n\t\tev  Event\n\t\tstr string\n\t}{\n\t\t{EventRegister, \"EventRegister\"},\n\t\t{EventAuth, \"EventAuth\"},\n\t\t{EventOAuth2, \"EventOAuth2\"},\n\t\t{EventAuthFail, \"EventAuthFail\"},\n\t\t{EventOAuth2Fail, \"EventOAuth2Fail\"},\n\t\t{EventRecoverStart, \"EventRecoverStart\"},\n\t\t{EventRecoverEnd, \"EventRecoverEnd\"},\n\t\t{EventGetUser, \"EventGetUser\"},\n\t\t{EventGetUserSession, \"EventGetUserSession\"},\n\t\t{EventPasswordReset, \"EventPasswordReset\"},\n\t}\n\n\tfor i, test := range tests {\n\t\tif got := test.ev.String(); got != test.str {\n\t\t\tt.Errorf(\"%d) Wrong string for Event(%d) expected: %v got: %s\", i, test.ev, test.str, got)\n\t\t}\n\t}\n}\n"
        },
        {
          "name": "expire",
          "type": "tree",
          "content": null
        },
        {
          "name": "go.mod",
          "type": "blob",
          "size": 0.5771484375,
          "content": "module github.com/volatiletech/authboss/v3\n\ngo 1.20\n\nrequire (\n\tgithub.com/friendsofgo/errors v0.9.2\n\tgithub.com/pquerna/otp v1.4.0\n\tgolang.org/x/crypto v0.17.0\n\tgolang.org/x/oauth2 v0.6.0\n)\n\nrequire (\n\tcloud.google.com/go v0.34.0 // indirect\n\tgithub.com/boombuler/barcode v1.0.1 // indirect\n\tgithub.com/davecgh/go-spew v1.1.1 // indirect\n\tgithub.com/golang/protobuf v1.5.3 // indirect\n\tgolang.org/x/net v0.17.0 // indirect\n\tgolang.org/x/xerrors v0.0.0-20220907171357-04be3eba64a2 // indirect\n\tgoogle.golang.org/appengine v1.6.7 // indirect\n\tgoogle.golang.org/protobuf v1.29.1 // indirect\n)\n"
        },
        {
          "name": "go.sum",
          "type": "blob",
          "size": 3.943359375,
          "content": "cloud.google.com/go v0.34.0 h1:eOI3/cP2VTU6uZLDYAoic+eyzzB9YyGmJ7eIjl8rOPg=\ncloud.google.com/go v0.34.0/go.mod h1:aQUYkXzVsufM+DwF1aE+0xfcU+56JwCaLick0ClmMTw=\ngithub.com/boombuler/barcode v1.0.1-0.20190219062509-6c824513bacc/go.mod h1:paBWMcWSl3LHKBqUq+rly7CNSldXjb2rDl3JlRe0mD8=\ngithub.com/boombuler/barcode v1.0.1 h1:NDBbPmhS+EqABEs5Kg3n/5ZNjy73Pz7SIV+KCeqyXcs=\ngithub.com/boombuler/barcode v1.0.1/go.mod h1:paBWMcWSl3LHKBqUq+rly7CNSldXjb2rDl3JlRe0mD8=\ngithub.com/davecgh/go-spew v1.1.0/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=\ngithub.com/davecgh/go-spew v1.1.1 h1:vj9j/u1bqnvCEfJOwUhtlOARqs3+rkHYY13jYWTU97c=\ngithub.com/davecgh/go-spew v1.1.1/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=\ngithub.com/friendsofgo/errors v0.9.2 h1:X6NYxef4efCBdwI7BgS820zFaN7Cphrmb+Pljdzjtgk=\ngithub.com/friendsofgo/errors v0.9.2/go.mod h1:yCvFW5AkDIL9qn7suHVLiI/gH228n7PC4Pn44IGoTOI=\ngithub.com/golang/protobuf v1.3.1/go.mod h1:6lQm79b+lXiMfvg/cZm0SGofjICqVBUtrP5yJMmIC1U=\ngithub.com/golang/protobuf v1.5.0/go.mod h1:FsONVRAS9T7sI+LIUmWTfcYkHO4aIWwzhcaSAoJOfIk=\ngithub.com/golang/protobuf v1.5.3 h1:KhyjKVUg7Usr/dYsdSqoFveMYd5ko72D+zANwlG1mmg=\ngithub.com/golang/protobuf v1.5.3/go.mod h1:XVQd3VNwM+JqD3oG2Ue2ip4fOMUkwXdXDdiuN0vRsmY=\ngithub.com/google/go-cmp v0.5.5/go.mod h1:v8dTdLbMG2kIc/vJvl+f65V22dbkXbowE6jgT/gNBxE=\ngithub.com/google/go-cmp v0.5.8 h1:e6P7q2lk1O+qJJb4BtCQXlK8vWEO8V1ZeuEdJNOqZyg=\ngithub.com/pmezard/go-difflib v1.0.0 h1:4DBwDE0NGyQoBHbLQYPwSUPoCMWR5BEzIk/f1lZbAQM=\ngithub.com/pmezard/go-difflib v1.0.0/go.mod h1:iKH77koFhYxTK1pcRnkKkqfTogsbg7gZNVY4sRDYZ/4=\ngithub.com/pquerna/otp v1.4.0 h1:wZvl1TIVxKRThZIBiwOOHOGP/1+nZyWBil9Y2XNEDzg=\ngithub.com/pquerna/otp v1.4.0/go.mod h1:dkJfzwRKNiegxyNb54X/3fLwhCynbMspSyWKnvi1AEg=\ngithub.com/stretchr/objx v0.1.0/go.mod h1:HFkY916IF+rwdDfMAkV7OtwuqBVzrE8GR6GFx+wExME=\ngithub.com/stretchr/testify v1.3.0 h1:TivCn/peBQ7UY8ooIcPgZFpTNSz0Q2U6UrFlUfqbe0Q=\ngithub.com/stretchr/testify v1.3.0/go.mod h1:M5WIy9Dh21IEIfnGCwXGc5bZfKNJtfHm1UVUgZn+9EI=\ngolang.org/x/crypto v0.0.0-20190308221718-c2843e01d9a2/go.mod h1:djNgcEr1/C05ACkg1iLfiJU5Ep61QUkGW8qpdssI0+w=\ngolang.org/x/crypto v0.17.0 h1:r8bRNjWL3GshPW3gkd+RpvzWrZAwPS49OmTGZ/uhM4k=\ngolang.org/x/crypto v0.17.0/go.mod h1:gCAAfMLgwOJRpTjQ2zCCt2OcSfYMTeZVSRtQlPC7Nq4=\ngolang.org/x/net v0.0.0-20190603091049-60506f45cf65/go.mod h1:HSz+uSET+XFnRR8LxR5pz3Of3rY3CfYBVs4xY44aLks=\ngolang.org/x/net v0.17.0 h1:pVaXccu2ozPjCXewfr1S7xza/zcXTity9cCdXQYSjIM=\ngolang.org/x/net v0.17.0/go.mod h1:NxSsAGuq816PNPmqtQdLE42eU2Fs7NoRIZrHJAlaCOE=\ngolang.org/x/oauth2 v0.6.0 h1:Lh8GPgSKBfWSwFvtuWOfeI3aAAnbXTSutYxJiOJFgIw=\ngolang.org/x/oauth2 v0.6.0/go.mod h1:ycmewcwgD4Rpr3eZJLSB4Kyyljb3qDh40vJ8STE5HKw=\ngolang.org/x/sys v0.0.0-20190215142949-d0b11bdaac8a/go.mod h1:STP8DvDyc/dI5b8T5hshtkjS+E42TnysNCUPdjciGhY=\ngolang.org/x/text v0.3.0/go.mod h1:NqM8EUOU14njkJ3fqMW+pc6Ldnwhi/IjpwHt7yyuwOQ=\ngolang.org/x/text v0.3.2/go.mod h1:bEr9sfX3Q8Zfm5fL9x+3itogRgK3+ptLWKqgva+5dAk=\ngolang.org/x/tools v0.0.0-20180917221912-90fa682c2a6e/go.mod h1:n7NCudcB/nEzxVGmLbDWY5pfWTLqBcC2KZ6jyYvM4mQ=\ngolang.org/x/xerrors v0.0.0-20190717185122-a985d3407aa7/go.mod h1:I/5z698sn9Ka8TeJc9MKroUUfqBBauWjQqLJ2OPfmY0=\ngolang.org/x/xerrors v0.0.0-20191204190536-9bdfabe68543/go.mod h1:I/5z698sn9Ka8TeJc9MKroUUfqBBauWjQqLJ2OPfmY0=\ngolang.org/x/xerrors v0.0.0-20220907171357-04be3eba64a2 h1:H2TDz8ibqkAF6YGhCdN3jS9O0/s90v0rJh3X/OLHEUk=\ngolang.org/x/xerrors v0.0.0-20220907171357-04be3eba64a2/go.mod h1:K8+ghG5WaK9qNqU5K3HdILfMLy1f3aNYFI/wnl100a8=\ngoogle.golang.org/appengine v1.6.7 h1:FZR1q0exgwxzPzp/aF+VccGrSfxfPpkBqjIIEq3ru6c=\ngoogle.golang.org/appengine v1.6.7/go.mod h1:8WjMMxjGQR8xUklV/ARdw2HLXBOI7O7uCIDZVag1xfc=\ngoogle.golang.org/protobuf v1.26.0-rc.1/go.mod h1:jlhhOSvTdKEhbULTjvd4ARK9grFBp09yW+WbY/TyQbw=\ngoogle.golang.org/protobuf v1.26.0/go.mod h1:9q0QmTI4eRPtz6boOQmLYwt+qCgq0jsYwAQnmE0givc=\ngoogle.golang.org/protobuf v1.29.1 h1:7QBf+IK2gx70Ap/hDsOmam3GE0v9HicjfEdAxE62UoM=\ngoogle.golang.org/protobuf v1.29.1/go.mod h1:HV8QOd/L58Z+nl8r43ehVNZIU/HEI6OcFqwMG9pJV4I=\n"
        },
        {
          "name": "hasher.go",
          "type": "blob",
          "size": 0.8115234375,
          "content": "package authboss\n\nimport (\n\t\"golang.org/x/crypto/bcrypt\"\n)\n\n// Hasher is the interface that wraps the hashing and comparison of passwords\ntype Hasher interface {\n\tCompareHashAndPassword(hash, password string) error\n\tGenerateHash(password string) (string, error)\n}\n\n// NewBCryptHasher creates a new bcrypt hasher with the given cost\nfunc NewBCryptHasher(cost int) *bcryptHasher {\n\treturn &bcryptHasher{cost: cost}\n}\n\ntype bcryptHasher struct {\n\tcost int\n}\n\nfunc (h *bcryptHasher) GenerateHash(password string) (string, error) {\n\thash, err := bcrypt.GenerateFromPassword([]byte(password), h.cost)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\treturn string(hash), nil\n}\n\nfunc (h *bcryptHasher) CompareHashAndPassword(hashedPassword, password string) error {\n\treturn bcrypt.CompareHashAndPassword([]byte(hashedPassword), []byte(password))\n}\n"
        },
        {
          "name": "hasher_test.go",
          "type": "blob",
          "size": 0.7646484375,
          "content": "package authboss\n\nimport (\n\t\"strings\"\n\t\"testing\"\n\n\t\"golang.org/x/crypto/bcrypt\"\n)\n\nfunc TestBcryptHasher(t *testing.T) {\n\tt.Parallel()\n\n\thasher := NewBCryptHasher(bcrypt.DefaultCost)\n\n\thash, err := hasher.GenerateHash(\"qwerty\")\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n\n\tif hash == \"\" {\n\t\tt.Error(\"Result Hash must be not empty\")\n\t}\n\tif len(hash) != 60 {\n\t\tt.Error(\"hash was invalid length\", len(hash))\n\t}\n\tif !strings.HasPrefix(hash, \"$2a$10$\") {\n\t\tt.Error(\"hash was wrong\", hash)\n\t}\n\n\tif err := hasher.CompareHashAndPassword(hash, \"qwerty\"); err != nil {\n\t\tt.Error(\"compare-hash-and-password for valid password must be ok\", err)\n\t}\n\n\tif err := hasher.CompareHashAndPassword(hash, \"qwerty-invalid\"); err == nil {\n\t\tt.Error(\"compare-hash-and-password for invalid password must fail\")\n\t}\n}\n"
        },
        {
          "name": "html_data.go",
          "type": "blob",
          "size": 3.0869140625,
          "content": "package authboss\n\nimport (\n\t\"context\"\n\t\"net/http\"\n)\n\n// Keys for use in HTMLData that are meaningful\nconst (\n\t// DataErr is for one off errors that don't really belong to\n\t// a particular field. It should be a string.\n\tDataErr = \"error\"\n\t// DataValidation is for validation errors, it should always\n\t// have been created using the Map() style functions in the\n\t// validation method so that html/text template users don't\n\t// struggle in displaying them.\n\t//\n\t// It is: map[string][]string, where the key in the map is the field\n\t// and the []string on the other side is the list of problems\n\t// with that field.\n\t//\n\t// It's also important to note that if the errors that were Map()'d\n\t// did not implement FieldError or for generic errors\n\t// the empty string (\"\") is used as a key in the map for those\n\t// errors that couldn't be fit to a specific field.\n\tDataValidation = \"errors\"\n\t// DataPreserve preserves fields during large form exercises\n\t// like user registration so we don't have to re-type safe\n\t// information like addresses etc.\n\t//\n\t// This data looks like map[string]string, and is simply\n\t// keyed by the field name, and the value is the field value.\n\tDataPreserve = \"preserve\"\n\t// DataModules contains a map[string]bool of which modules are loaded\n\t// The bool is largely extraneous and can be ignored, if the module is\n\t// loaded it will be present in the map, if not it will be missing.\n\tDataModules = \"modules\"\n)\n\n// HTMLData is used to render templates with.\ntype HTMLData map[string]interface{}\n\n// NewHTMLData creates HTMLData from key-value pairs. The input is a key-value\n// slice, where odd elements are keys, and the following even element\n// is their value.\nfunc NewHTMLData(data ...interface{}) HTMLData {\n\tif len(data)%2 != 0 {\n\t\tpanic(\"it should be a key value list of arguments.\")\n\t}\n\n\th := make(HTMLData)\n\n\tfor i := 0; i < len(data)-1; i += 2 {\n\t\tk, ok := data[i].(string)\n\t\tif !ok {\n\t\t\tpanic(\"Keys must be strings.\")\n\t\t}\n\n\t\th[k] = data[i+1]\n\t}\n\n\treturn h\n}\n\n// Merge adds the data from other to h. If there are conflicting keys\n// they are overwritten by other's values.\nfunc (h HTMLData) Merge(other HTMLData) HTMLData {\n\tfor k, v := range other {\n\t\th[k] = v\n\t}\n\treturn h\n}\n\n// MergeKV adds extra key-values to the HTMLData. The input is a key-value\n// slice, where odd elements are keys, and the following even element\n// is their value.\nfunc (h HTMLData) MergeKV(data ...interface{}) HTMLData {\n\tif len(data)%2 != 0 {\n\t\tpanic(\"It should be a key value list of arguments.\")\n\t}\n\n\tfor i := 0; i < len(data)-1; i += 2 {\n\t\tk, ok := data[i].(string)\n\t\tif !ok {\n\t\t\tpanic(\"Keys must be strings.\")\n\t\t}\n\n\t\th[k] = data[i+1]\n\t}\n\n\treturn h\n}\n\n// MergeDataInRequest edits the request pointer to point to a new request with\n// a modified context that contains the merged data.\nfunc MergeDataInRequest(r **http.Request, other HTMLData) {\n\tctx := (*r).Context()\n\tcurrentIntf := ctx.Value(CTXKeyData)\n\tif currentIntf == nil {\n\t\t*r = (*r).WithContext(context.WithValue(ctx, CTXKeyData, other))\n\t\treturn\n\t}\n\n\tcurrent := currentIntf.(HTMLData)\n\tmerged := current.Merge(other)\n\t*r = (*r).WithContext(context.WithValue(ctx, CTXKeyData, merged))\n}\n"
        },
        {
          "name": "html_data_test.go",
          "type": "blob",
          "size": 1.59765625,
          "content": "package authboss\n\nimport (\n\t\"context\"\n\t\"net/http/httptest\"\n\t\"testing\"\n)\n\nfunc TestHTMLData(t *testing.T) {\n\tt.Parallel()\n\n\tdata := NewHTMLData(\"a\", \"b\").MergeKV(\"c\", \"d\").Merge(NewHTMLData(\"e\", \"f\"))\n\tif data[\"a\"].(string) != \"b\" {\n\t\tt.Error(\"A was wrong:\", data[\"a\"])\n\t}\n\tif data[\"c\"].(string) != \"d\" {\n\t\tt.Error(\"C was wrong:\", data[\"c\"])\n\t}\n\tif data[\"e\"].(string) != \"f\" {\n\t\tt.Error(\"E was wrong:\", data[\"e\"])\n\t}\n}\n\nfunc TestHTMLData_Panics(t *testing.T) {\n\tt.Parallel()\n\n\tnPanics := 0\n\tpanicCount := func() {\n\t\tif r := recover(); r != nil {\n\t\t\tnPanics++\n\t\t}\n\t}\n\n\tfunc() {\n\t\tdefer panicCount()\n\t\tNewHTMLData(\"hello\")\n\t}()\n\n\tfunc() {\n\t\tdefer panicCount()\n\t\tNewHTMLData().MergeKV(\"hello\")\n\t}()\n\n\tfunc() {\n\t\tdefer panicCount()\n\t\tNewHTMLData(5, 6)\n\t}()\n\n\tfunc() {\n\t\tdefer panicCount()\n\t\tNewHTMLData().MergeKV(7, 8)\n\t}()\n\n\tif nPanics != 4 {\n\t\tt.Error(\"They all should have paniced.\")\n\t}\n}\n\nfunc TestHTMLDataMergeDataInRequest(t *testing.T) {\n\tt.Parallel()\n\n\tr := httptest.NewRequest(\"GET\", \"/\", nil)\n\tMergeDataInRequest(&r, HTMLData{\"hello\": \"world\"})\n\n\tval := r.Context().Value(CTXKeyData).(HTMLData)[\"hello\"].(string)\n\tif val != \"world\" {\n\t\tt.Error(\"expected world, got:\", val)\n\t}\n\n\tr = httptest.NewRequest(\"GET\", \"/\", nil)\n\tr = r.WithContext(context.WithValue(context.Background(), CTXKeyData, HTMLData{\"first\": \"here\"}))\n\tMergeDataInRequest(&r, HTMLData{\"hello\": \"world\"})\n\n\tval = r.Context().Value(CTXKeyData).(HTMLData)[\"hello\"].(string)\n\tif val != \"world\" {\n\t\tt.Error(\"expected world, got:\", val)\n\t}\n\n\tval = r.Context().Value(CTXKeyData).(HTMLData)[\"first\"].(string)\n\tif val != \"here\" {\n\t\tt.Error(\"expected world, got:\", val)\n\t}\n}\n"
        },
        {
          "name": "localizer.go",
          "type": "blob",
          "size": 6.3408203125,
          "content": "package authboss\n\nimport (\n\t\"context\"\n)\n\ntype Localizer interface {\n\t// Get the translation for the given text in the given context.\n\t// If no translation is found, an empty string should be returned.\n\tLocalizef(ctx context.Context, key LocalizationKey, args ...any) string\n}\n\ntype LocalizationKey struct {\n\tID      string\n\tDefault string\n}\n\nvar (\n\tTxtSuccess = LocalizationKey{\n\t\tID:      \"Success\",\n\t\tDefault: \"success\",\n\t}\n\n\t// Used in the auth module\n\tTxtInvalidCredentials = LocalizationKey{\n\t\tID:      \"InvalidCredentials\",\n\t\tDefault: \"Invalid Credentials\",\n\t}\n\tTxtAuthFailed = LocalizationKey{\n\t\tID:      \"AuthFailed\",\n\t\tDefault: \"Please login\",\n\t}\n\n\t// Used in the register module\n\tTxtUserAlreadyExists = LocalizationKey{\n\t\tID:      \"UserAlreadyExists\",\n\t\tDefault: \"User already exists\",\n\t}\n\tTxtRegisteredAndLoggedIn = LocalizationKey{\n\t\tID:      \"RegisteredAndLoggedIn\",\n\t\tDefault: \"Account successfully created, you are now logged in\",\n\t}\n\n\t// Used in the confirm module\n\tTxtConfirmYourAccount = LocalizationKey{\n\t\tID:      \"ConfirmYourAccount\",\n\t\tDefault: \"Please verify your account, an e-mail has been sent to you.\",\n\t}\n\tTxtAccountNotConfirmed = LocalizationKey{\n\t\tID:      \"AccountNotConfirmed\",\n\t\tDefault: \"Your account has not been confirmed, please check your e-mail.\",\n\t}\n\tTxtInvalidConfirmToken = LocalizationKey{\n\t\tID:      \"InvalidConfirmToken\",\n\t\tDefault: \"Your confirmation token is invalid.\",\n\t}\n\tTxtConfrimationSuccess = LocalizationKey{\n\t\tID:      \"ConfrimationSuccess\",\n\t\tDefault: \"You have successfully confirmed your account.\",\n\t}\n\tTxtConfirmEmailSubject = LocalizationKey{\n\t\tID:      \"ConfirmEmailSubject\",\n\t\tDefault: \"Confirm New Account\",\n\t}\n\n\t// Used in the lock module\n\tTxtLocked = LocalizationKey{\n\t\tID:      \"Locked\",\n\t\tDefault: \"Your account has been locked, please contact the administrator.\",\n\t}\n\n\t// Used in the logout module\n\tTxtLoggedOut = LocalizationKey{\n\t\tID:      \"LoggedOut\",\n\t\tDefault: \"You have been logged out\",\n\t}\n\n\t// Used in the oauth2 module\n\tTxtOAuth2LoginOK = LocalizationKey{\n\t\tID:      \"OAuth2LoginOK\",\n\t\tDefault: \"Logged in successfully with %s.\",\n\t}\n\tTxtOAuth2LoginNotOK = LocalizationKey{\n\t\tID:      \"OAuth2LoginNotOK\",\n\t\tDefault: \"%s login cancelled or failed\",\n\t}\n\n\t// Used in the recover module\n\tTxtRecoverInitiateSuccessFlash = LocalizationKey{\n\t\tID:      \"RecoverInitiateSuccessFlash\",\n\t\tDefault: \"An email has been sent to you with further instructions on how to reset your password.\",\n\t}\n\tTxtPasswordResetEmailSubject = LocalizationKey{\n\t\tID:      \"PasswordResetEmailSubject\",\n\t\tDefault: \"Password Reset\",\n\t}\n\tTxtRecoverSuccessMsg = LocalizationKey{\n\t\tID:      \"RecoverSuccessMsg\",\n\t\tDefault: \"Successfully updated password\",\n\t}\n\tTxtRecoverAndLoginSuccessMsg = LocalizationKey{\n\t\tID:      \"RecoverAndLoginSuccessMsg\",\n\t\tDefault: \"Successfully updated password and logged in\",\n\t}\n\n\t// Used in the otp module\n\tTxtTooManyOTPs = LocalizationKey{\n\t\tID:      \"TooManyOTPs\",\n\t\tDefault: \"You cannot have more than %d one time passwords\",\n\t}\n\n\t// Used in the 2fa module\n\tTxtEmailVerifyTriggered = LocalizationKey{\n\t\tID:      \"EmailVerifyTriggered\",\n\t\tDefault: \"An e-mail has been sent to confirm 2FA activation\",\n\t}\n\tTxtEmailVerifySubject = LocalizationKey{\n\t\tID:      \"EmailVerifySubject\",\n\t\tDefault: \"Add 2FA to Account\",\n\t}\n\tTxtInvalid2FAVerificationToken = LocalizationKey{\n\t\tID:      \"Invalid2FAVerificationToken\",\n\t\tDefault: \"Invalid 2FA email verification token\",\n\t}\n\tTxt2FAAuthorizationRequired = LocalizationKey{\n\t\tID:      \"2FAAuthorizationRequired\",\n\t\tDefault: \"You must first authorize adding 2fa by e-mail\",\n\t}\n\tTxtInvalid2FACode = LocalizationKey{\n\t\tID:      \"Invalid2FACode\",\n\t\tDefault: \"2FA code was invalid\",\n\t}\n\tTxtRepeated2FACode = LocalizationKey{\n\t\tID:      \"Repeated2FACode\",\n\t\tDefault: \"2FA code was previously used\",\n\t}\n\tTxtTOTP2FANotActive = LocalizationKey{\n\t\tID:      \"TOTP2FANotActive\",\n\t\tDefault: \"TOTP 2FA is not active\",\n\t}\n\tTxtSMSNumberRequired = LocalizationKey{\n\t\tID:      \"SMSNumberRequired\",\n\t\tDefault: \"You must provide a phone number\",\n\t}\n\tTxtSMSWaitToResend = LocalizationKey{\n\t\tID:      \"SMSWaitToResend\",\n\t\tDefault: \"Please wait a few moments before resending the SMS code\",\n\t}\n)\n\n// // Translation constants\n// const (\n// \tTxtSuccess = \"success\"\n//\n// \t// Used in the auth module\n// \tTxtInvalidCredentials = \"Invalid Credentials\"\n// \tTxtAuthFailed         = \"Please login\"\n//\n// \t// Used in the register module\n// \tTxtUserAlreadyExists     = \"User already exists\"\n// \tTxtRegisteredAndLoggedIn = \"Account successfully created, you are now logged in\"\n//\n// \t// Used in the confirm module\n// \tTxtConfirmYourAccount  = \"Please verify your account, an e-mail has been sent to you.\"\n// \tTxtAccountNotConfirmed = \"Your account has not been confirmed, please check your e-mail.\"\n// \tTxtInvalidConfirmToken = \"Your confirmation token is invalid.\"\n// \tTxtConfrimationSuccess = \"You have successfully confirmed your account.\"\n// \tTxtConfirmEmailSubject = \"Confirm New Account\"\n//\n// \t// Used in the lock module\n// \tTxtLocked = \"Your account has been locked, please contact the administrator.\"\n//\n// \t// Used in the logout module\n// \tTxtLoggedOut = \"You have been logged out\"\n//\n// \t// Used in the oauth2 module\n// \tTxtOAuth2LoginOK    = \"Logged in successfully with %s.\"\n// \tTxtOAuth2LoginNotOK = \"%s login cancelled or failed\"\n//\n// \t// Used in the recover module\n// \tTxtRecoverInitiateSuccessFlash = \"An email has been sent to you with further instructions on how to reset your password.\"\n// \tTxtPasswordResetEmailSubject   = \"Password Reset\"\n// \tTxtRecoverSuccessMsg           = \"Successfully updated password\"\n// \tTxtRecoverAndLoginSuccessMsg   = \"Successfully updated password and logged in\"\n//\n// \t// Used in the otp module\n// \tTxtTooManyOTPs = \"You cannot have more than %d one time passwords\"\n//\n// \t// Used in the 2fa module\n// \tTxtEmailVerifyTriggered        = \"An e-mail has been sent to confirm 2FA activation\"\n// \tTxtEmailVerifySubject          = \"Add 2FA to Account\"\n// \tTxtInvalid2FAVerificationToken = \"Invalid 2FA email verification token\"\n// \tTxt2FAAuthorizationRequired    = \"You must first authorize adding 2fa by e-mail\"\n// \tTxtInvalid2FACode              = \"2FA code was invalid\"\n// \tTxtRepeated2FACode             = \"2FA code was previously used\"\n// \tTxtTOTP2FANotActive            = \"TOTP 2FA is not active\"\n// \tTxtSMSNumberRequired           = \"You must provide a phone number\"\n// \tTxtSMSWaitToResend             = \"Please wait a few moments before resending the SMS code\"\n// )\n"
        },
        {
          "name": "lock",
          "type": "tree",
          "content": null
        },
        {
          "name": "logger.go",
          "type": "blob",
          "size": 1.796875,
          "content": "package authboss\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"net/http\"\n)\n\n// Logger is the basic logging structure that's required\ntype Logger interface {\n\tInfo(string)\n\tError(string)\n}\n\n// ContextLogger creates a logger from a request context\ntype ContextLogger interface {\n\tFromContext(context.Context) Logger\n}\n\n// RequestLogger creates a logger from a request\ntype RequestLogger interface {\n\tFromRequest(*http.Request) Logger\n}\n\n// RequestLogger returns a request logger if possible, if not\n// it calls Logger which tries to do a ContextLogger, and if\n// that fails it will finally get a normal logger.\nfunc (a *Authboss) RequestLogger(r *http.Request) FmtLogger {\n\tlogger := a.Config.Core.Logger\n\tif reqLogger, ok := logger.(RequestLogger); ok {\n\t\treturn FmtLogger{reqLogger.FromRequest(r)}\n\t}\n\n\treturn FmtLogger{a.Logger(r.Context())}\n}\n\n// Logger returns an appopriate logger for the context:\n// If context is nil, then it simply returns the configured\n// logger.\n// If context is not nil, then it will attempt to upgrade\n// the configured logger to a ContextLogger, and create\n// a context-specific logger for use.\nfunc (a *Authboss) Logger(ctx context.Context) FmtLogger {\n\tlogger := a.Config.Core.Logger\n\tif ctx == nil {\n\t\treturn FmtLogger{logger}\n\t}\n\n\tctxLogger, ok := logger.(ContextLogger)\n\tif !ok {\n\t\treturn FmtLogger{logger}\n\t}\n\n\treturn FmtLogger{ctxLogger.FromContext(ctx)}\n}\n\n// FmtLogger adds convenience functions on top of the logging\n// methods for formatting.\ntype FmtLogger struct {\n\tLogger\n}\n\n// Errorf prints to Error() with fmt.Printf semantics\nfunc (f FmtLogger) Errorf(format string, values ...interface{}) {\n\tf.Logger.Error(fmt.Sprintf(format, values...))\n}\n\n// Infof prints to Info() with fmt.Printf semantics\nfunc (f FmtLogger) Infof(format string, values ...interface{}) {\n\tf.Logger.Info(fmt.Sprintf(format, values...))\n}\n"
        },
        {
          "name": "logger_test.go",
          "type": "blob",
          "size": 1.2939453125,
          "content": "package authboss\n\nimport (\n\t\"context\"\n\t\"net/http\"\n\t\"net/http/httptest\"\n\t\"testing\"\n)\n\ntype (\n\ttestLogger struct {\n\t\tinfo  string\n\t\terror string\n\t}\n\ttestCtxLogger struct{}\n)\n\nfunc (t *testLogger) Info(s string) {\n\tt.info += s\n}\nfunc (t *testLogger) Error(s string) {\n\tt.error += s\n}\n\nfunc (t testLogger) FromContext(ctx context.Context) Logger { return testCtxLogger{} }\nfunc (t testLogger) FromRequest(r *http.Request) Logger     { return &testLogger{} }\n\nfunc (t testCtxLogger) Info(string)  {}\nfunc (t testCtxLogger) Error(string) {}\n\nfunc TestLogger(t *testing.T) {\n\tt.Parallel()\n\n\tab := New()\n\tlogger := &testLogger{}\n\tab.Config.Core.Logger = logger\n\n\tif logger != ab.Logger(nil).Logger.(*testLogger) {\n\t\tt.Error(\"wanted our logger back\")\n\t}\n\n\tif _, ok := ab.Logger(context.Background()).Logger.(testCtxLogger); !ok {\n\t\tt.Error(\"wanted ctx logger back\")\n\t}\n\n\tif _, ok := ab.RequestLogger(httptest.NewRequest(\"GET\", \"/\", nil)).Logger.(*testLogger); !ok {\n\t\tt.Error(\"wanted normal logger back\")\n\t}\n}\n\nfunc TestFmtLogger(t *testing.T) {\n\tt.Parallel()\n\n\tlogger := &testLogger{}\n\tfmtlog := FmtLogger{logger}\n\n\tfmtlog.Errorf(\"%s %s\", \"ok\", \"go\")\n\tfmtlog.Infof(\"%s %s\", \"go\", \"ok\")\n\n\tif logger.error != \"ok go\" {\n\t\tt.Error(\"wrong output\", logger.error)\n\t}\n\tif logger.info != \"go ok\" {\n\t\tt.Error(\"wrong output\", logger.info)\n\t}\n}\n"
        },
        {
          "name": "logout",
          "type": "tree",
          "content": null
        },
        {
          "name": "mailer.go",
          "type": "blob",
          "size": 0.6201171875,
          "content": "package authboss\n\nimport (\n\t\"context\"\n)\n\n// Mailer is a type that is capable of sending an e-mail.\ntype Mailer interface {\n\tSend(context.Context, Email) error\n}\n\n// Email all the things. The ToNames and friends are parallel arrays and must\n// be 0-length or the same length as their counterpart. To omit a name\n// for a user at an index in To simply use an empty string at that\n// index in ToNames.\ntype Email struct {\n\tTo, Cc, Bcc                []string\n\tToNames, CcNames, BccNames []string\n\tFromName, From             string\n\tReplyToName, ReplyTo       string\n\tSubject                    string\n\n\tTextBody string\n\tHTMLBody string\n}\n"
        },
        {
          "name": "mocks",
          "type": "tree",
          "content": null
        },
        {
          "name": "mocks_test.go",
          "type": "blob",
          "size": 7.7939453125,
          "content": "package authboss\n\nimport (\n\t\"context\"\n\t\"encoding/json\"\n\t\"golang.org/x/crypto/bcrypt\"\n\t\"net/http\"\n\t\"time\"\n)\n\ntype mockUser struct {\n\tEmail    string\n\tPassword string\n\tUsername string\n\n\tRecoverSelector string\n\tRecoverVerifier string\n\tRecoverExpiry   time.Time\n\n\tConfirmSelector string\n\tConfirmVerifier string\n\tConfirmed       bool\n\n\tAttemptCount int\n\tLastAttempt  time.Time\n\tLocked       time.Time\n\n\tOAuth2UID      string\n\tOAuth2Provider string\n\tOAuth2Token    string\n\tOAuth2Refresh  string\n\tOAuth2Expiry   time.Time\n\n\tArbitrary map[string]string\n}\n\nfunc newMockServerStorer() *mockServerStorer {\n\treturn &mockServerStorer{\n\t\tUsers:  make(map[string]*mockUser),\n\t\tTokens: make(map[string][]string),\n\t}\n}\n\ntype mockServerStorer struct {\n\tUsers  map[string]*mockUser\n\tTokens map[string][]string\n}\n\nfunc (m *mockServerStorer) Load(ctx context.Context, key string) (User, error) {\n\tu, ok := m.Users[key]\n\tif !ok {\n\t\treturn nil, ErrUserNotFound\n\t}\n\n\treturn u, nil\n}\n\nfunc (m *mockServerStorer) Save(ctx context.Context, user User) error {\n\tu := user.(*mockUser)\n\tm.Users[u.Email] = u\n\n\treturn nil\n}\n\nfunc (m *mockServerStorer) AddRememberToken(ctx context.Context, pid, token string) error {\n\tm.Tokens[pid] = append(m.Tokens[pid], token)\n\treturn nil\n}\n\nfunc (m *mockServerStorer) DelRememberTokens(ctx context.Context, pid string) error {\n\tdelete(m.Tokens, pid)\n\treturn nil\n}\n\nfunc (m *mockServerStorer) UseRememberToken(ctx context.Context, pid, token string) error {\n\tarr, ok := m.Tokens[pid]\n\tif !ok {\n\t\treturn ErrTokenNotFound\n\t}\n\n\tfor i, tok := range arr {\n\t\tif tok == token {\n\t\t\tarr[i] = arr[len(arr)-1]\n\t\t\tm.Tokens[pid] = arr[:len(arr)-2]\n\t\t\treturn nil\n\t\t}\n\t}\n\n\treturn ErrTokenNotFound\n}\n\n// This section of functions was purely for test coverage\nfunc (m *mockServerStorer) New(ctx context.Context) User                { panic(\"not impl\") }\nfunc (m *mockServerStorer) Create(ctx context.Context, user User) error { panic(\"not impl\") }\nfunc (m *mockServerStorer) NewFromOAuth2(ctx context.Context, provider string, details map[string]string) (OAuth2User, error) {\n\tpanic(\"not impl\")\n}\nfunc (m *mockServerStorer) LoadByConfirmSelector(ctx context.Context, selector string) (ConfirmableUser, error) {\n\tpanic(\"not impl\")\n}\nfunc (m *mockServerStorer) LoadByRecoverSelector(ctx context.Context, selector string) (RecoverableUser, error) {\n\tpanic(\"not impl\")\n}\nfunc (m *mockServerStorer) SaveOAuth2(ctx context.Context, user OAuth2User) error { panic(\"not impl\") }\n\nfunc (m mockUser) GetPID() string                             { return m.Email }\nfunc (m mockUser) GetEmail() string                           { return m.Email }\nfunc (m mockUser) GetUsername() string                        { return m.Username }\nfunc (m mockUser) GetPassword() string                        { return m.Password }\nfunc (m mockUser) GetRecoverSelector() string                 { return m.RecoverSelector }\nfunc (m mockUser) GetRecoverVerifier() string                 { return m.RecoverVerifier }\nfunc (m mockUser) GetRecoverExpiry() time.Time                { return m.RecoverExpiry }\nfunc (m mockUser) GetConfirmSelector() string                 { return m.ConfirmSelector }\nfunc (m mockUser) GetConfirmVerifier() string                 { return m.ConfirmVerifier }\nfunc (m mockUser) GetConfirmed() bool                         { return m.Confirmed }\nfunc (m mockUser) GetAttemptCount() int                       { return m.AttemptCount }\nfunc (m mockUser) GetLastAttempt() time.Time                  { return m.LastAttempt }\nfunc (m mockUser) GetLocked() time.Time                       { return m.Locked }\nfunc (m mockUser) IsOAuth2User() bool                         { return len(m.OAuth2Provider) != 0 }\nfunc (m mockUser) GetOAuth2UID() string                       { return m.OAuth2UID }\nfunc (m mockUser) GetOAuth2Provider() string                  { return m.OAuth2Provider }\nfunc (m mockUser) GetOAuth2AccessToken() string               { return m.OAuth2Token }\nfunc (m mockUser) GetOAuth2RefreshToken() string              { return m.OAuth2Refresh }\nfunc (m mockUser) GetOAuth2Expiry() time.Time                 { return m.OAuth2Expiry }\nfunc (m mockUser) GetArbitrary() map[string]string            { return m.Arbitrary }\nfunc (m *mockUser) PutPID(email string)                       { m.Email = email }\nfunc (m *mockUser) PutUsername(username string)               { m.Username = username }\nfunc (m *mockUser) PutEmail(email string)                     { m.Email = email }\nfunc (m *mockUser) PutPassword(password string)               { m.Password = password }\nfunc (m *mockUser) PutRecoverSelector(recoverSelector string) { m.RecoverSelector = recoverSelector }\nfunc (m *mockUser) PutRecoverVerifier(recoverVerifier string) { m.RecoverVerifier = recoverVerifier }\nfunc (m *mockUser) PutRecoverExpiry(recoverExpiry time.Time)  { m.RecoverExpiry = recoverExpiry }\nfunc (m *mockUser) PutConfirmSelector(confirmSelector string) { m.ConfirmSelector = confirmSelector }\nfunc (m *mockUser) PutConfirmVerifier(confirmVerifier string) { m.ConfirmVerifier = confirmVerifier }\nfunc (m *mockUser) PutConfirmed(confirmed bool)               { m.Confirmed = confirmed }\nfunc (m *mockUser) PutAttemptCount(attemptCount int)          { m.AttemptCount = attemptCount }\nfunc (m *mockUser) PutLastAttempt(attemptTime time.Time)      { m.LastAttempt = attemptTime }\nfunc (m *mockUser) PutLocked(locked time.Time)                { m.Locked = locked }\nfunc (m *mockUser) PutOAuth2UID(uid string)                   { m.OAuth2UID = uid }\nfunc (m *mockUser) PutOAuth2Provider(provider string)         { m.OAuth2Provider = provider }\nfunc (m *mockUser) PutOAuth2AccessToken(token string)         { m.OAuth2Token = token }\nfunc (m *mockUser) PutOAuth2RefreshToken(refresh string)      { m.OAuth2Refresh = refresh }\nfunc (m *mockUser) PutOAuth2Expiry(expiry time.Time)          { m.OAuth2Expiry = expiry }\nfunc (m *mockUser) PutArbitrary(arb map[string]string)        { m.Arbitrary = arb }\n\ntype mockClientStateReadWriter struct {\n\tstate mockClientState\n}\n\ntype mockClientState map[string]string\n\nfunc newMockClientStateRW(keyValue ...string) mockClientStateReadWriter {\n\tstate := mockClientState{}\n\tfor i := 0; i < len(keyValue); i += 2 {\n\t\tkey, value := keyValue[i], keyValue[i+1]\n\t\tstate[key] = value\n\t}\n\n\treturn mockClientStateReadWriter{state}\n}\n\nfunc (m mockClientStateReadWriter) ReadState(r *http.Request) (ClientState, error) {\n\treturn m.state, nil\n}\n\nfunc (m mockClientStateReadWriter) WriteState(w http.ResponseWriter, cs ClientState, evs []ClientStateEvent) error {\n\tvar state mockClientState\n\n\tif cs != nil {\n\t\tstate = cs.(mockClientState)\n\t} else {\n\t\tstate = mockClientState{}\n\t}\n\n\tfor _, ev := range evs {\n\t\tswitch ev.Kind {\n\t\tcase ClientStateEventPut:\n\t\t\tstate[ev.Key] = ev.Value\n\t\tcase ClientStateEventDel:\n\t\t\tdelete(state, ev.Key)\n\t\t}\n\t}\n\n\tb, err := json.Marshal(state)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tw.Header().Set(\"test_session\", string(b))\n\treturn nil\n}\n\nfunc (m mockClientState) Get(key string) (string, bool) {\n\tval, ok := m[key]\n\treturn val, ok\n}\n\ntype mockEmailRenderer struct{}\n\nfunc (m mockEmailRenderer) Load(names ...string) error { return nil }\n\nfunc (m mockEmailRenderer) Render(ctx context.Context, name string, data HTMLData) ([]byte, string, error) {\n\tswitch name {\n\tcase \"text\":\n\t\treturn []byte(\"a development text e-mail template\"), \"text/plain\", nil\n\tcase \"html\":\n\t\treturn []byte(\"a development html e-mail template\"), \"text/html\", nil\n\tdefault:\n\t\tpanic(\"shouldn't get here\")\n\t}\n}\n\ntype mockLogger struct{}\n\nfunc (m mockLogger) Info(s string)  {}\nfunc (m mockLogger) Error(s string) {}\n\ntype mockHasher struct{}\n\nfunc (m mockHasher) GenerateHash(s string) (string, error) {\n\thash, err := bcrypt.GenerateFromPassword([]byte(s), bcrypt.DefaultCost)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\treturn string(hash), nil\n}\n\nfunc (m mockHasher) CompareHashAndPassword(hashedPassword, password string) error {\n\treturn bcrypt.CompareHashAndPassword([]byte(hashedPassword), []byte(password))\n}\n"
        },
        {
          "name": "module.go",
          "type": "blob",
          "size": 3.27734375,
          "content": "package authboss\n\nimport (\n\t\"context\"\n\t\"net/http\"\n\t\"reflect\"\n)\n\nvar registeredModules = make(map[string]Moduler)\n\n// Moduler should be implemented by all the authboss modules.\ntype Moduler interface {\n\t// Init the module\n\tInit(*Authboss) error\n}\n\n// RegisterModule with the core providing all the necessary information to\n// integrate into authboss.\nfunc RegisterModule(name string, m Moduler) {\n\tregisteredModules[name] = m\n}\n\n// RegisteredModules returns a list of modules that are currently registered.\nfunc RegisteredModules() []string {\n\tmods := make([]string, len(registeredModules))\n\ti := 0\n\tfor k := range registeredModules {\n\t\tmods[i] = k\n\t\ti++\n\t}\n\n\treturn mods\n}\n\n// LoadedModules returns a list of modules that are currently loaded.\nfunc (a *Authboss) LoadedModules() []string {\n\tmods := make([]string, len(a.loadedModules))\n\ti := 0\n\tfor k := range a.loadedModules {\n\t\tmods[i] = k\n\t\ti++\n\t}\n\n\treturn mods\n}\n\n// IsLoaded checks if a specific module is loaded.\nfunc (a *Authboss) IsLoaded(mod string) bool {\n\t_, ok := a.loadedModules[mod]\n\treturn ok\n}\n\n// loadModule loads a particular module. It uses reflection to create a new\n// instance of the module type. The original value is copied, but not deep\n// copied so care should be taken to make sure most initialization happens\n// inside the Initialize() method of the module.\n//\n// This method exists so many copies of authboss can be loaded and initialized\n// at the same time if we didn't use this, then the registeredModules\n// instances of the modules would end up used by the first instance of authboss.\nfunc (a *Authboss) loadModule(name string) error {\n\tmodule, ok := registeredModules[name]\n\tif !ok {\n\t\tpanic(\"could not find module: \" + name)\n\t}\n\n\tvar wasPtr bool\n\tmodVal := reflect.ValueOf(module)\n\tif modVal.Kind() == reflect.Ptr {\n\t\twasPtr = true\n\t\tmodVal = modVal.Elem()\n\t}\n\n\tmodType := modVal.Type()\n\tvalue := reflect.New(modType)\n\tif !wasPtr {\n\t\tvalue = value.Elem()\n\t\tvalue.Set(modVal)\n\t} else {\n\t\tvalue.Elem().Set(modVal)\n\t}\n\n\tmod := value.Interface().(Moduler)\n\ta.loadedModules[name] = mod\n\treturn mod.Init(a)\n}\n\n// ModuleListMiddleware puts a map in the data that can be used\n// to provide the renderer with information about which pieces of the\n// views to show. The bool is extraneous, as presence in the map is\n// the indication of wether or not the module is loaded.\n// Data looks like:\n// map[modulename] = true\n//\n// oauth2 providers are also listed here using the syntax:\n// oauth2.google for an example. Be careful since this doesn't actually mean\n// that the oauth2 module has been loaded so you should do a conditional\n// that checks for both.\nfunc ModuleListMiddleware(ab *Authboss) func(http.Handler) http.Handler {\n\treturn func(next http.Handler) http.Handler {\n\t\treturn http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\t\tvar data HTMLData\n\n\t\t\tctx := r.Context()\n\t\t\tdataIntf := ctx.Value(CTXKeyData)\n\t\t\tif dataIntf != nil {\n\t\t\t\tdata = dataIntf.(HTMLData)\n\t\t\t} else {\n\t\t\t\tdata = HTMLData{}\n\t\t\t}\n\n\t\t\tloaded := make(map[string]bool, len(ab.loadedModules))\n\t\t\tfor k := range ab.loadedModules {\n\t\t\t\tloaded[k] = true\n\t\t\t}\n\n\t\t\tfor provider := range ab.Config.Modules.OAuth2Providers {\n\t\t\t\tloaded[\"oauth2.\"+provider] = true\n\t\t\t}\n\n\t\t\tdata[DataModules] = loaded\n\t\t\tr = r.WithContext(context.WithValue(ctx, CTXKeyData, data))\n\t\t\tnext.ServeHTTP(w, r)\n\t\t})\n\t}\n}\n"
        },
        {
          "name": "module_test.go",
          "type": "blob",
          "size": 2.0400390625,
          "content": "package authboss\n\nimport (\n\t\"net/http\"\n\t\"net/http/httptest\"\n\t\"testing\"\n)\n\nconst (\n\ttestModName = \"testmodule\"\n)\n\nvar (\n\ttestMod = &testModule{}\n)\n\nfunc init() {\n\tRegisterModule(testModName, testMod)\n}\n\ntype testModule struct{}\n\nfunc (t *testModule) Init(a *Authboss) error { return nil }\n\nfunc TestRegister(t *testing.T) {\n\tt.Parallel()\n\n\t// RegisterModule called by init()\n\tif _, ok := registeredModules[testModName]; !ok {\n\t\tt.Error(\"Expected module to be saved.\")\n\t}\n}\n\nfunc TestLoadedModules(t *testing.T) {\n\tt.Parallel()\n\n\t// RegisterModule called by init()\n\tregistered := RegisteredModules()\n\tif len(registered) != 1 {\n\t\tt.Error(\"Expected only a single module to be loaded.\")\n\t} else {\n\t\tfound := false\n\t\tfor _, name := range registered {\n\t\t\tif name == testModName {\n\t\t\t\tfound = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif !found {\n\t\t\tt.Error(\"It should have found the module:\", registered)\n\t\t}\n\t}\n}\n\nfunc TestIsLoaded(t *testing.T) {\n\tt.Parallel()\n\n\tab := New()\n\tif err := ab.Init(); err != nil {\n\t\tt.Error(err)\n\t}\n\n\tif loaded := ab.LoadedModules(); len(loaded) == 0 || loaded[0] != testModName {\n\t\tt.Error(\"Loaded modules wrong:\", loaded)\n\t}\n}\n\nfunc TestModuleLoadedMiddleware(t *testing.T) {\n\tt.Parallel()\n\n\tab := New()\n\n\tab.loadedModules = map[string]Moduler{\n\t\t\"recover\": nil,\n\t\t\"auth\":    nil,\n\t\t\"oauth2\":  nil,\n\t}\n\tab.Config.Modules.OAuth2Providers = map[string]OAuth2Provider{\n\t\t\"google\": {},\n\t}\n\n\tvar mods map[string]bool\n\tserver := ModuleListMiddleware(ab)(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tdata := r.Context().Value(CTXKeyData).(HTMLData)\n\t\tmods = data[DataModules].(map[string]bool)\n\t}))\n\n\tserver.ServeHTTP(nil, httptest.NewRequest(\"GET\", \"/\", nil))\n\n\tif len(mods) != 4 {\n\t\tt.Error(\"want 4 modules, got:\", len(mods))\n\t}\n\n\tif _, ok := mods[\"auth\"]; !ok {\n\t\tt.Error(\"auth should be loaded\")\n\t}\n\tif _, ok := mods[\"recover\"]; !ok {\n\t\tt.Error(\"recover should be loaded\")\n\t}\n\tif _, ok := mods[\"oauth2\"]; !ok {\n\t\tt.Error(\"modules should include oauth2.google\")\n\t}\n\tif _, ok := mods[\"oauth2.google\"]; !ok {\n\t\tt.Error(\"modules should include oauth2.google\")\n\t}\n}\n"
        },
        {
          "name": "oauth2.go",
          "type": "blob",
          "size": 1.0732421875,
          "content": "package authboss\n\nimport (\n\t\"context\"\n\t\"net/url\"\n\n\t\"golang.org/x/oauth2\"\n)\n\n/*\nOAuth2Provider is the entire configuration\nrequired to authenticate with this provider.\n\nThe OAuth2Config does not need a redirect URL because it will\nbe automatically created by the route registration in the oauth2 module.\n\nAdditionalParams can be used to specify extra parameters to tack on to the\nend of the initial request, this allows for provider specific oauth options\nlike access_type=offline to be passed to the provider.\n\nFindUserDetails gives the config and the token allowing an http client using the\nauthenticated token to be created, a call is then made to a known endpoint that will\nreturn details about the user we've retrieved the token for. Those details are returned\nas a map[string]string and subsequently passed into OAuth2ServerStorer.NewFromOAuth2.\nAPI this must be handled for each provider separately.\n*/\ntype OAuth2Provider struct {\n\tOAuth2Config     *oauth2.Config\n\tAdditionalParams url.Values\n\tFindUserDetails  func(context.Context, oauth2.Config, *oauth2.Token) (map[string]string, error)\n}\n"
        },
        {
          "name": "oauth2",
          "type": "tree",
          "content": null
        },
        {
          "name": "one_time_token_generator.go",
          "type": "blob",
          "size": 2.162109375,
          "content": "package authboss\n\nimport (\n\t\"crypto/rand\"\n\t\"crypto/sha512\"\n\t\"encoding/base64\"\n\t\"io\"\n)\n\n// OneTimeTokenGenerator is an interface for generating one-time tokens\n// for authentication purposes.\ntype OneTimeTokenGenerator interface {\n\t// Generatetoken generates a one-time use 2-part token for authenticating a request.\n\t// selector: to be stored in the database and ALWAYS used in select query\n\t// verifier: to be stored in database but NEVER used in select query\n\t// token: the user-facing base64 encoded selector+verifier\n\tGenerateToken() (selector, verifier, token string, err error)\n\n\tParseToken(token string) (selectorBytes, verifierBytes []byte)\n\n\tTokenSize() int\n}\n\nconst (\n\ttokenSize  = 64\n\ttokenSplit = tokenSize / 2\n)\n\n// Sha512TokenGenerator generates one-time tokens using SHA512\ntype Sha512TokenGenerator struct{}\n\n// NewSha512TokenGenerator creates a new Sha512TokenGenerator\nfunc NewSha512TokenGenerator() *Sha512TokenGenerator {\n\treturn &Sha512TokenGenerator{}\n}\n\n// GenerateToken generates pieces needed as credentials\n// selector: hash of the first half of an N byte value\n// (to be stored in the database and used in SELECT query)\n// verifier: hash of the second half of an N byte value\n// (to be stored in database but never used in SELECT query)\n// token: the user-facing base64 encoded selector+verifier\nfunc (cg *Sha512TokenGenerator) GenerateToken() (selector, verifier, token string, err error) {\n\trawToken := make([]byte, tokenSize)\n\tif _, err = io.ReadFull(rand.Reader, rawToken); err != nil {\n\t\treturn \"\", \"\", \"\", err\n\t}\n\n\tselectorBytes := sha512.Sum512(rawToken[:tokenSplit])\n\tverifierBytes := sha512.Sum512(rawToken[tokenSplit:])\n\n\treturn base64.StdEncoding.EncodeToString(selectorBytes[:]),\n\t\tbase64.StdEncoding.EncodeToString(verifierBytes[:]),\n\t\tbase64.URLEncoding.EncodeToString(rawToken),\n\t\tnil\n}\n\nfunc (cg *Sha512TokenGenerator) ParseToken(rawToken string) (selectorBytes, verifierBytes []byte) {\n\tselectorBytes64 := sha512.Sum512([]byte(rawToken)[:tokenSplit])\n\tselectorBytes = selectorBytes64[:]\n\n\tverifierBytes64 := sha512.Sum512([]byte(rawToken)[tokenSplit:])\n\tverifierBytes = verifierBytes64[:]\n\n\treturn\n}\n\nfunc (cg *Sha512TokenGenerator) TokenSize() int { return tokenSize }\n"
        },
        {
          "name": "one_time_token_generator_test.go",
          "type": "blob",
          "size": 0.9169921875,
          "content": "package authboss\n\nimport (\n\t\"encoding/base64\"\n\t\"testing\"\n)\n\nfunc TestOneTimeTokenGenerator(t *testing.T) {\n\tt.Parallel()\n\n\tcredsGenerator := NewSha512TokenGenerator()\n\n\tselector, verifier, tokenEncoded, err := credsGenerator.GenerateToken()\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n\n\t// let's decode the token\n\ttokenBytes, err := base64.URLEncoding.DecodeString(tokenEncoded)\n\ttoken := string(tokenBytes)\n\n\tif len(token) != credsGenerator.TokenSize() {\n\t\tt.Error(\"token size is invalid\", len(token))\n\t}\n\n\tselectorBytes, verifierBytes := credsGenerator.ParseToken(token)\n\n\t// encode back and verify\n\n\tselectorParsed := base64.StdEncoding.EncodeToString(selectorBytes[:])\n\tverifierParsed := base64.StdEncoding.EncodeToString(verifierBytes[:])\n\n\tif selectorParsed != selector {\n\t\tt.Error(\"selector generated wrong\", selector, selectorParsed)\n\t}\n\n\tif verifierParsed != verifier {\n\t\tt.Error(\"verifier generated wrong\", verifier, verifierParsed)\n\t}\n}\n"
        },
        {
          "name": "otp",
          "type": "tree",
          "content": null
        },
        {
          "name": "recover",
          "type": "tree",
          "content": null
        },
        {
          "name": "register",
          "type": "tree",
          "content": null
        },
        {
          "name": "remember",
          "type": "tree",
          "content": null
        },
        {
          "name": "renderer.go",
          "type": "blob",
          "size": 0.3623046875,
          "content": "package authboss\n\nimport \"context\"\n\n// Renderer is a type that can render a given template with some data.\ntype Renderer interface {\n\t// Load the given templates, will most likely be called multiple times\n\tLoad(names ...string) error\n\n\t// Render the given template\n\tRender(ctx context.Context, page string, data HTMLData) (output []byte, contentType string, err error)\n}\n"
        },
        {
          "name": "response.go",
          "type": "blob",
          "size": 2.853515625,
          "content": "package authboss\n\nimport (\n\t\"context\"\n\t\"net/http\"\n\n\t\"github.com/friendsofgo/errors\"\n)\n\nconst (\n\t// FormValueRedirect should be honored by HTTPRedirector implementations\n\t// as the value from the URL that overrides the typical redirect when\n\t// FollowRedirParam is set to true.\n\tFormValueRedirect = \"redir\"\n)\n\n// HTTPResponder knows how to respond to an HTTP request\n// Must consider:\n// - Flash messages\n// - XSRF handling (template data)\n// - Assembling template data from various sources\n//\n// Authboss controller methods (like the one called in response to\n// POST /auth/login) will call this method to write a response to the user.\ntype HTTPResponder interface {\n\tRespond(w http.ResponseWriter, r *http.Request, code int, templateName string, data HTMLData) error\n}\n\n// HTTPRedirector redirects http requests to a different url (must handle\n// both json and html) When an authboss controller wants to redirect a user to\n// a different path, it will use this interface.\ntype HTTPRedirector interface {\n\tRedirect(w http.ResponseWriter, r *http.Request, ro RedirectOptions) error\n}\n\n// RedirectOptions packages up all the pieces a module needs to write out a\n// response.\ntype RedirectOptions struct {\n\t// Success & Failure are used to set Flash messages / JSON messages\n\t// if set. They should be mutually exclusive.\n\tSuccess string\n\tFailure string\n\n\t// Code is used when it's an API request instead of 200.\n\tCode int\n\n\t// When a request should redirect a user somewhere on completion, these\n\t// should be set. RedirectURL tells it where to go. And optionally set\n\t// FollowRedirParam to override the RedirectURL if the form parameter\n\t// defined by FormValueRedirect is passed in the request.\n\t//\n\t// Redirecting works differently whether it's an API request or not.\n\t// If it's an API request, then it will leave the URL in a \"redirect\"\n\t// parameter.\n\tRedirectPath     string\n\tFollowRedirParam bool\n}\n\n// EmailResponseOptions controls how e-mails are rendered and sent\ntype EmailResponseOptions struct {\n\tData         HTMLData\n\tHTMLTemplate string\n\tTextTemplate string\n}\n\n// Email renders the e-mail templates for the given email and\n// sends it using the mailer.\nfunc (a *Authboss) Email(ctx context.Context, email Email, ro EmailResponseOptions) error {\n\tctxData := ctx.Value(CTXKeyData)\n\tif ctxData != nil {\n\t\tif ro.Data == nil {\n\t\t\tro.Data = HTMLData{}\n\t\t}\n\t\tro.Data.Merge(ctxData.(HTMLData))\n\t}\n\tif len(ro.HTMLTemplate) != 0 {\n\t\thtmlBody, _, err := a.Core.MailRenderer.Render(ctx, ro.HTMLTemplate, ro.Data)\n\t\tif err != nil {\n\t\t\treturn errors.Wrap(err, \"failed to render e-mail html body\")\n\t\t}\n\t\temail.HTMLBody = string(htmlBody)\n\t}\n\n\tif len(ro.TextTemplate) != 0 {\n\t\ttextBody, _, err := a.Core.MailRenderer.Render(ctx, ro.TextTemplate, ro.Data)\n\t\tif err != nil {\n\t\t\treturn errors.Wrap(err, \"failed to render e-mail text body\")\n\t\t}\n\t\temail.TextBody = string(textBody)\n\t}\n\n\treturn a.Core.Mailer.Send(ctx, email)\n}\n"
        },
        {
          "name": "response_test.go",
          "type": "blob",
          "size": 0.7001953125,
          "content": "package authboss\n\nimport (\n\t\"context\"\n\t\"testing\"\n)\n\ntype testMailer struct{ sent bool }\n\nfunc (t *testMailer) Send(context.Context, Email) error {\n\tt.sent = true\n\treturn nil\n}\n\nfunc TestEmail(t *testing.T) {\n\tt.Parallel()\n\n\tab := New()\n\n\tmailer := &testMailer{}\n\trenderer := &mockEmailRenderer{}\n\tab.Config.Core.Mailer = mailer\n\tab.Config.Core.MailRenderer = renderer\n\n\temail := Email{\n\t\tTo:      []string{\"support@authboss.com\"},\n\t\tSubject: \"Send help\",\n\t}\n\n\tro := EmailResponseOptions{\n\t\tData:         nil,\n\t\tHTMLTemplate: \"html\",\n\t\tTextTemplate: \"text\",\n\t}\n\n\tif err := ab.Email(context.Background(), email, ro); err != nil {\n\t\tt.Error(err)\n\t}\n\n\tif !mailer.sent {\n\t\tt.Error(\"the e-mail should have been sent\")\n\t}\n}\n"
        },
        {
          "name": "router.go",
          "type": "blob",
          "size": 0.2705078125,
          "content": "package authboss\n\nimport (\n\t\"net/http\"\n)\n\n// Router can register routes to later be used by the web application\ntype Router interface {\n\thttp.Handler\n\n\tGet(path string, handler http.Handler)\n\tPost(path string, handler http.Handler)\n\tDelete(path string, handler http.Handler)\n}\n"
        },
        {
          "name": "storage.go",
          "type": "blob",
          "size": 6.4150390625,
          "content": "package authboss\n\n// A conscious decision was made to put all storer\n// and user types into this file despite them truly\n// belonging to outside modules. The reason for this\n// is because documentation-wise, it was previously\n// difficult to find what you had to implement or even\n// what you could implement.\n\nimport (\n\t\"context\"\n\n\t\"github.com/friendsofgo/errors\"\n)\n\nvar (\n\t// ErrUserFound should be returned from Create (see ConfirmUser)\n\t// when the primaryID of the record is found.\n\tErrUserFound = errors.New(\"user found\")\n\t// ErrUserNotFound should be returned from Get when the record is not found.\n\tErrUserNotFound = errors.New(\"user not found\")\n\t// ErrTokenNotFound should be returned from UseToken when the\n\t// record is not found.\n\tErrTokenNotFound = errors.New(\"token not found\")\n)\n\n// ServerStorer represents the data store that's capable of loading users\n// and giving them a context with which to store themselves.\ntype ServerStorer interface {\n\t// Load will look up the user based on the passed the PrimaryID. Under\n\t// normal circumstances this comes from GetPID() of the user.\n\t//\n\t// OAuth2 logins are special-cased to return an OAuth2 pid (combination of\n\t// provider:oauth2uid), and therefore key be special cased in a Load()\n\t// implementation to handle that form, use ParseOAuth2PID to see\n\t// if key is an OAuth2PID or not.\n\tLoad(ctx context.Context, key string) (User, error)\n\n\t// Save persists the user in the database, this should never\n\t// create a user and instead return ErrUserNotFound if the user\n\t// does not exist.\n\tSave(ctx context.Context, user User) error\n}\n\n// CreatingServerStorer is used for creating new users\n// like when Registration or OAuth2 is being done.\ntype CreatingServerStorer interface {\n\tServerStorer\n\n\t// New creates a blank user, it is not yet persisted in the database\n\t// but is just for storing data\n\tNew(ctx context.Context) User\n\t// Create the user in storage, it should not overwrite a user\n\t// and should return ErrUserFound if it currently exists.\n\tCreate(ctx context.Context, user User) error\n}\n\n// OAuth2ServerStorer has the ability to create users from data from the provider.\n//\n// A correct implementation of OAuth2ServerStorer will have a Load() method\n// that special cases the key parameter to be aware of possible OAuth2 pids\n// by using the ParseOAuth2PID method.\ntype OAuth2ServerStorer interface {\n\tServerStorer\n\n\t// NewFromOAuth2 should return an OAuth2User from a set\n\t// of details returned from OAuth2Provider.FindUserDetails\n\t// A more in-depth explanation is that once we've got an access token\n\t// for the service in question (say a service that rhymes with book)\n\t// the FindUserDetails function does an http request to a known endpoint\n\t// that provides details about the user, those details are captured in a\n\t// generic way as map[string]string and passed into this function to be\n\t// turned into a real user.\n\t//\n\t// It's possible that the user exists in the database already, and so\n\t// an attempt should be made to look that user up using the details.\n\t// Any details that have changed should be updated. Do not save the user\n\t// since that will be done later by OAuth2ServerStorer.SaveOAuth2()\n\tNewFromOAuth2(ctx context.Context, provider string, details map[string]string) (OAuth2User, error)\n\n\t// SaveOAuth2 has different semantics from the typical ServerStorer.Save,\n\t// in this case we want to insert a user if they do not exist.\n\t// The difference must be made clear because in the non-oauth2 case,\n\t// we know exactly when we want to Create vs Update. However since we're\n\t// simply trying to persist a user that may have been in our database,\n\t// but if not should already be (since you can think of the operation as\n\t// a caching of what's on the oauth2 provider's servers).\n\tSaveOAuth2(ctx context.Context, user OAuth2User) error\n}\n\n// ConfirmingServerStorer can find a user by a confirm token\ntype ConfirmingServerStorer interface {\n\tServerStorer\n\n\t// LoadByConfirmSelector finds a user by his confirm selector field\n\t// and should return ErrUserNotFound if that user cannot be found.\n\tLoadByConfirmSelector(ctx context.Context, selector string) (ConfirmableUser, error)\n}\n\n// RecoveringServerStorer allows users to be recovered by a token\ntype RecoveringServerStorer interface {\n\tServerStorer\n\n\t// LoadByRecoverSelector finds a user by his recover selector field\n\t// and should return ErrUserNotFound if that user cannot be found.\n\tLoadByRecoverSelector(ctx context.Context, selector string) (RecoverableUser, error)\n}\n\n// RememberingServerStorer allows users to be remembered across sessions\ntype RememberingServerStorer interface {\n\tServerStorer\n\n\t// AddRememberToken to a user\n\tAddRememberToken(ctx context.Context, pid, token string) error\n\t// DelRememberTokens removes all tokens for the given pid\n\tDelRememberTokens(ctx context.Context, pid string) error\n\t// UseRememberToken finds the pid-token pair and deletes it.\n\t// If the token could not be found return ErrTokenNotFound\n\tUseRememberToken(ctx context.Context, pid, token string) error\n}\n\n// EnsureCanCreate makes sure the server storer supports create operations\nfunc EnsureCanCreate(storer ServerStorer) CreatingServerStorer {\n\ts, ok := storer.(CreatingServerStorer)\n\tif !ok {\n\t\tpanic(\"could not upgrade ServerStorer to CreatingServerStorer, check your struct\")\n\t}\n\n\treturn s\n}\n\n// EnsureCanConfirm makes sure the server storer supports\n// confirm-lookup operations\nfunc EnsureCanConfirm(storer ServerStorer) ConfirmingServerStorer {\n\ts, ok := storer.(ConfirmingServerStorer)\n\tif !ok {\n\t\tpanic(\"could not upgrade ServerStorer to ConfirmingServerStorer, check your struct\")\n\t}\n\n\treturn s\n}\n\n// EnsureCanRecover makes sure the server storer supports\n// confirm-lookup operations\nfunc EnsureCanRecover(storer ServerStorer) RecoveringServerStorer {\n\ts, ok := storer.(RecoveringServerStorer)\n\tif !ok {\n\t\tpanic(\"could not upgrade ServerStorer to RecoveringServerStorer, check your struct\")\n\t}\n\n\treturn s\n}\n\n// EnsureCanRemember makes sure the server storer supports remember operations\nfunc EnsureCanRemember(storer ServerStorer) RememberingServerStorer {\n\ts, ok := storer.(RememberingServerStorer)\n\tif !ok {\n\t\tpanic(\"could not upgrade ServerStorer to RememberingServerStorer, check your struct\")\n\t}\n\n\treturn s\n}\n\n// EnsureCanOAuth2 makes sure the server storer supports\n// oauth2 creation and lookup\nfunc EnsureCanOAuth2(storer ServerStorer) OAuth2ServerStorer {\n\ts, ok := storer.(OAuth2ServerStorer)\n\tif !ok {\n\t\tpanic(\"could not upgrade ServerStorer to OAuth2ServerStorer, check your struct\")\n\t}\n\n\treturn s\n}\n"
        },
        {
          "name": "storage_test.go",
          "type": "blob",
          "size": 1.287109375,
          "content": "package authboss\n\nimport (\n\t\"context\"\n\t\"testing\"\n)\n\ntype testAssertionFailStorer struct{}\n\nfunc (testAssertionFailStorer) Load(ctx context.Context, key string) (User, error) { return nil, nil }\nfunc (testAssertionFailStorer) Save(ctx context.Context, user User) error          { return nil }\n\nfunc TestStorageAssertions(t *testing.T) {\n\tt.Parallel()\n\n\ts := &mockServerStorer{}\n\tfs := testAssertionFailStorer{}\n\n\tpaniced := false\n\tfunc() {\n\t\tdefer func() {\n\t\t\tif r := recover(); r != nil {\n\t\t\t\tpaniced = true\n\t\t\t}\n\t\t}()\n\n\t\tEnsureCanCreate(s)\n\t\tEnsureCanConfirm(s)\n\t\tEnsureCanRecover(s)\n\t\tEnsureCanRemember(s)\n\t\tEnsureCanOAuth2(s)\n\t}()\n\n\tif paniced {\n\t\tt.Error(\"The mock storer should have included all interfaces and should not panic\")\n\t}\n\n\tdidPanic := func(f func()) (paniced bool) {\n\t\tdefer func() {\n\t\t\tif r := recover(); r != nil {\n\t\t\t\tpaniced = true\n\t\t\t}\n\t\t}()\n\n\t\tf()\n\t\treturn paniced\n\t}\n\n\tif !didPanic(func() { EnsureCanCreate(fs) }) {\n\t\tt.Error(\"should have panic'd\")\n\t}\n\tif !didPanic(func() { EnsureCanConfirm(fs) }) {\n\t\tt.Error(\"should have panic'd\")\n\t}\n\tif !didPanic(func() { EnsureCanRecover(fs) }) {\n\t\tt.Error(\"should have panic'd\")\n\t}\n\tif !didPanic(func() { EnsureCanRemember(fs) }) {\n\t\tt.Error(\"should have panic'd\")\n\t}\n\tif !didPanic(func() { EnsureCanOAuth2(fs) }) {\n\t\tt.Error(\"should have panic'd\")\n\t}\n}\n"
        },
        {
          "name": "stringers.go",
          "type": "blob",
          "size": 1.1630859375,
          "content": "// Code generated by \"stringer -output stringers.go -type Event\"; DO NOT EDIT.\n\npackage authboss\n\nimport \"strconv\"\n\nfunc _() {\n\t// An \"invalid array index\" compiler error signifies that the constant values have changed.\n\t// Re-run the stringer command to generate them again.\n\tvar x [1]struct{}\n\t_ = x[EventRegister-0]\n\t_ = x[EventAuth-1]\n\t_ = x[EventAuthHijack-2]\n\t_ = x[EventOAuth2-3]\n\t_ = x[EventAuthFail-4]\n\t_ = x[EventOAuth2Fail-5]\n\t_ = x[EventRecoverStart-6]\n\t_ = x[EventRecoverEnd-7]\n\t_ = x[EventGetUser-8]\n\t_ = x[EventGetUserSession-9]\n\t_ = x[EventPasswordReset-10]\n\t_ = x[EventLogout-11]\n\t_ = x[EventTwoFactorAdded-12]\n\t_ = x[EventTwoFactorRemoved-13]\n}\n\nconst _Event_name = \"EventRegisterEventAuthEventAuthHijackEventOAuth2EventAuthFailEventOAuth2FailEventRecoverStartEventRecoverEndEventGetUserEventGetUserSessionEventPasswordResetEventLogoutEventTwoFactorAddedEventTwoFactorRemoved\"\n\nvar _Event_index = [...]uint8{0, 13, 22, 37, 48, 61, 76, 93, 108, 120, 139, 157, 168, 187, 208}\n\nfunc (i Event) String() string {\n\tif i < 0 || i >= Event(len(_Event_index)-1) {\n\t\treturn \"Event(\" + strconv.FormatInt(int64(i), 10) + \")\"\n\t}\n\treturn _Event_name[_Event_index[i]:_Event_index[i+1]]\n}\n"
        },
        {
          "name": "tov2.md",
          "type": "blob",
          "size": 3.9951171875,
          "content": "# Migrating to v2 from v1\n\nAs always, the best way to understand most of this is to look at the\n[authboss-sample](https://github.com/volatiletech/authboss-sample). You could even look at\nthe commits that lead from v1 to v2 (though it is not divided nicely into small commits).\n\n## Configuration\n\nThe configuration has been changed drastically from an API perspective as it's now sub-divided\nwith substructs into pieces. But in general the same options should be available with few exceptions.\n\nIn most cases the replacements will be very straightforward, and if you were using the default values\nnothing much should have to change.\n\n## HTTP Stack (and defaults package)\n\nThe HTTP stack has been ripped apart into several small interfaces defined in the config struct.\nBefore you panic when you see Responder, Redirector, BodyReader etc, it's important to see the\n`defaults` package in Authboss. This package contains sane default implementations for all of\nthese components (with the exception of an html renderer, though a JSON one is present).\n\nYou probably will not want to override any of these and so I'd suggest a peek at the method\n`default.SetCore` (used in the sample as well) that sets up these default implementations\neasily.\n\nThere is also an HTML renderer available at\n[authboss-renderer](https://github.com/volatiletech/authboss-renderer).\n\n## Server storage\n\n### Understanding User vs Storer\n\nIn the past Authboss used extremely confusing terminology and sort of a conflated\ndesign of User and Storer (database). In v2 these concepts have been separated and\nthere is now a User interface and a ServerStorer interface. These two interfaces represent\nthe concepts of the User data, and the Server storage mechanism that loads and saves\nusers.\n\nThe user interface is now implemented without reflection. Previously in Authboss we would\nscrape the values from your struct, and update them via reflection as well. This is extremely\nerror prone and relies on hardcoded types everywhere and it just generally was a bad idea.\nDespite the verbosity of using methods for every single field value we want, it's type safe\nand provides a great spot for doing type conversions between whatever you're using in your\nstruct/database and whatever authboss wants for talking to web clients.\n\n### ServerStorer\n\nThis interface simply needs to Load and Save Users at the outset. Just like before there\nare upgraded interfaces that are required by other modules, for example the `recover` module\nwants a `RecoveringServerStorer` which has the method `LoadByRecoverToken` which you'll have\nto add to your storer.\n\n### User\n\nYour user struct should be able to remain the same, and all you need to do is add the methods\nrequired for getting and setting the fields. Remember the methods are dictated by the interfaces\nrequired by the modules you're loading (see authboss README.md for more details). For example\nthe `auth` module requires an `AuthableUser` which requires `Get|PutPassword` methods.\n\n## Client state\n\nThe client state interfaces have been rewritten to do a just-in-time write to the response\nbefore the headers are completely flushed. This makes sure we only Read and only Write the\nclient state (cookies/sessions) one time. It requires a new middleware `LoadClientStateMiddleware`\nwhich wraps the responsewriter with a new one that has the ability to manage client state.\n\nIn the ClientStateReadWriter interface (the one you now implement to handle sessions and cookies)\nyou now return a ClientState interface (basically a map of values) that represents a snapshot of the\nstate of the client when the request was initially read, this ensures that code will use the context\nfor value passing through the middleware stack and not the session as an added bonus.\nEssentially this ClientState caches the values for the remainder of the request.\n\nEvents are written to the ResponseWriter and eventually the `WriteState` method is called and is\ngiven the old state and the events that occurred during request processing, asks for a new state\nto be written out to the responsewriter's headers.\n"
        },
        {
          "name": "user.go",
          "type": "blob",
          "size": 5.60546875,
          "content": "package authboss\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\t\"time\"\n\n\t\"github.com/friendsofgo/errors\"\n)\n\n// User has functions for each piece of data it requires.\n// Data should not be persisted on each function call.\n// User has a PID (primary ID) that is used on the site as\n// a single unique identifier to any given user (very typically e-mail\n// or username).\n//\n// User interfaces return no errors or bools to signal that a value was\n// not present. Instead 0-value = null = not present, this puts the onus\n// on Authboss code to check for this.\ntype User interface {\n\tGetPID() (pid string)\n\tPutPID(pid string)\n}\n\n// AuthableUser is identified by a password\ntype AuthableUser interface {\n\tUser\n\n\tGetPassword() (password string)\n\tPutPassword(password string)\n}\n\n// ConfirmableUser can be in a state of confirmed or not\ntype ConfirmableUser interface {\n\tUser\n\n\tGetEmail() (email string)\n\tGetConfirmed() (confirmed bool)\n\tGetConfirmSelector() (selector string)\n\tGetConfirmVerifier() (verifier string)\n\n\tPutEmail(email string)\n\tPutConfirmed(confirmed bool)\n\tPutConfirmSelector(selector string)\n\tPutConfirmVerifier(verifier string)\n}\n\n// LockableUser is a user that can be locked\ntype LockableUser interface {\n\tUser\n\n\tGetAttemptCount() (attempts int)\n\tGetLastAttempt() (last time.Time)\n\tGetLocked() (locked time.Time)\n\n\tPutAttemptCount(attempts int)\n\tPutLastAttempt(last time.Time)\n\tPutLocked(locked time.Time)\n}\n\n// RecoverableUser is a user that can be recovered via e-mail\ntype RecoverableUser interface {\n\tAuthableUser\n\n\tGetEmail() (email string)\n\tGetRecoverSelector() (selector string)\n\tGetRecoverVerifier() (verifier string)\n\tGetRecoverExpiry() (expiry time.Time)\n\n\tPutEmail(email string)\n\tPutRecoverSelector(selector string)\n\tPutRecoverVerifier(verifier string)\n\tPutRecoverExpiry(expiry time.Time)\n}\n\ntype RecoverableUserWithSecondaryEmails interface {\n\tRecoverableUser\n\n\tGetSecondaryEmails() (secondaryEmails []string)\n}\n\n// ArbitraryUser allows arbitrary data from the web form through. You should\n// definitely only pull the keys you want from the map, since this is unfiltered\n// input from a web request and is an attack vector.\ntype ArbitraryUser interface {\n\tUser\n\n\t// GetArbitrary is used only to display the arbitrary data back to the user\n\t// when the form is reset.\n\tGetArbitrary() (arbitrary map[string]string)\n\t// PutArbitrary allows arbitrary fields defined by the authboss library\n\t// consumer to add fields to the user registration piece.\n\tPutArbitrary(arbitrary map[string]string)\n}\n\n// OAuth2User allows reading and writing values relating to OAuth2\n// Also see MakeOAuthPID/ParseOAuthPID for helpers to fulfill the User\n// part of the interface.\ntype OAuth2User interface {\n\tUser\n\n\t// IsOAuth2User checks to see if a user was registered in the site as an\n\t// oauth2 user.\n\tIsOAuth2User() bool\n\n\tGetOAuth2UID() (uid string)\n\tGetOAuth2Provider() (provider string)\n\tGetOAuth2AccessToken() (token string)\n\tGetOAuth2RefreshToken() (refreshToken string)\n\tGetOAuth2Expiry() (expiry time.Time)\n\n\tPutOAuth2UID(uid string)\n\tPutOAuth2Provider(provider string)\n\tPutOAuth2AccessToken(token string)\n\tPutOAuth2RefreshToken(refreshToken string)\n\tPutOAuth2Expiry(expiry time.Time)\n}\n\n// MustBeAuthable forces an upgrade to an AuthableUser or panic.\nfunc MustBeAuthable(u User) AuthableUser {\n\tif au, ok := u.(AuthableUser); ok {\n\t\treturn au\n\t}\n\tpanic(fmt.Sprintf(\"could not upgrade user to an authable user, type: %T\", u))\n}\n\n// MustBeConfirmable forces an upgrade to a ConfirmableUser or panic.\nfunc MustBeConfirmable(u User) ConfirmableUser {\n\tif cu, ok := u.(ConfirmableUser); ok {\n\t\treturn cu\n\t}\n\tpanic(fmt.Sprintf(\"could not upgrade user to a confirmable user, type: %T\", u))\n}\n\n// MustBeLockable forces an upgrade to a LockableUser or panic.\nfunc MustBeLockable(u User) LockableUser {\n\tif lu, ok := u.(LockableUser); ok {\n\t\treturn lu\n\t}\n\tpanic(fmt.Sprintf(\"could not upgrade user to a lockable user, given type: %T\", u))\n}\n\n// MustBeRecoverable forces an upgrade to a RecoverableUser or panic.\nfunc MustBeRecoverable(u User) RecoverableUser {\n\tif lu, ok := u.(RecoverableUser); ok {\n\t\treturn lu\n\t}\n\tpanic(fmt.Sprintf(\"could not upgrade user to a recoverable user, given type: %T\", u))\n}\n\nfunc CanBeRecoverableUserWithSecondaryEmails(u User) (RecoverableUserWithSecondaryEmails, bool) {\n\tif lu, ok := u.(RecoverableUserWithSecondaryEmails); ok {\n\t\treturn lu, true\n\t}\n\treturn nil, false\n}\n\n// MustBeOAuthable forces an upgrade to an OAuth2User or panic.\nfunc MustBeOAuthable(u User) OAuth2User {\n\tif ou, ok := u.(OAuth2User); ok {\n\t\treturn ou\n\t}\n\tpanic(fmt.Sprintf(\"could not upgrade user to an oauthable user, given type: %T\", u))\n}\n\n// MakeOAuth2PID is used to create a pid for users that don't have\n// an e-mail address or username in the normal system. This allows\n// all the modules to continue to working as intended without having\n// a true primary id. As well as not having to divide the regular and oauth\n// stuff all down the middle.\nfunc MakeOAuth2PID(provider, uid string) string {\n\treturn fmt.Sprintf(\"oauth2;;%s;;%s\", provider, uid)\n}\n\n// ParseOAuth2PID returns the uid and provider for a given OAuth2 pid\nfunc ParseOAuth2PID(pid string) (provider, uid string, err error) {\n\tsplits := strings.Split(pid, \";;\")\n\tif len(splits) != 3 {\n\t\treturn \"\", \"\", errors.Errorf(\"failed to parse oauth2 pid, too many segments: %s\", pid)\n\t}\n\tif splits[0] != \"oauth2\" {\n\t\treturn \"\", \"\", errors.Errorf(\"invalid oauth2 pid, did not start with oauth2: %s\", pid)\n\t}\n\n\treturn splits[1], splits[2], nil\n}\n\n// ParseOAuth2PIDP returns the uid and provider for a given OAuth2 pid\nfunc ParseOAuth2PIDP(pid string) (provider, uid string) {\n\tvar err error\n\tprovider, uid, err = ParseOAuth2PID(pid)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\treturn provider, uid\n}\n"
        },
        {
          "name": "user_test.go",
          "type": "blob",
          "size": 2.080078125,
          "content": "package authboss\n\nimport \"testing\"\n\nfunc TestOAuth2PIDs(t *testing.T) {\n\tt.Parallel()\n\n\tprovider := \"provider\"\n\tuid := \"uid\"\n\tpid := MakeOAuth2PID(provider, uid)\n\n\tif pid != \"oauth2;;provider;;uid\" {\n\t\tt.Error(\"pid was wrong:\", pid)\n\t}\n\n\tgotProvider, gotUID := ParseOAuth2PIDP(pid)\n\tif gotUID != uid {\n\t\tt.Error(\"uid was wrong:\", gotUID)\n\t}\n\tif gotProvider != provider {\n\t\tt.Error(\"provider was wrong:\", gotProvider)\n\t}\n\n\tnotEnoughSegments, didntStartWithOAuth2 := false, false\n\n\tfunc() {\n\t\tdefer func() {\n\t\t\tif r := recover(); r != nil {\n\t\t\t\tnotEnoughSegments = true\n\t\t\t}\n\t\t}()\n\n\t\t_, _ = ParseOAuth2PIDP(\"nope\")\n\t}()\n\n\tif !notEnoughSegments {\n\t\tt.Error(\"expected a panic when there's not enough segments\")\n\t}\n\n\tfunc() {\n\t\tdefer func() {\n\t\t\tif r := recover(); r != nil {\n\t\t\t\tdidntStartWithOAuth2 = true\n\t\t\t}\n\t\t}()\n\n\t\t_, _ = ParseOAuth2PIDP(\"notoauth2;;but;;restisgood\")\n\t}()\n\n\tif !didntStartWithOAuth2 {\n\t\tt.Error(\"expected a panic when the pid doesn't start with oauth2\")\n\t}\n}\n\ntype testAssertionFailUser struct{}\n\nfunc (testAssertionFailUser) GetPID() string { return \"\" }\nfunc (testAssertionFailUser) PutPID(string)  {}\n\nfunc TestUserAssertions(t *testing.T) {\n\tt.Parallel()\n\n\tu := &mockUser{}\n\tfu := testAssertionFailUser{}\n\n\tpaniced := false\n\tfunc() {\n\t\tdefer func() {\n\t\t\tif r := recover(); r != nil {\n\t\t\t\tpaniced = true\n\t\t\t}\n\t\t}()\n\n\t\tMustBeAuthable(u)\n\t\tMustBeConfirmable(u)\n\t\tMustBeLockable(u)\n\t\tMustBeOAuthable(u)\n\t\tMustBeRecoverable(u)\n\t}()\n\n\tif paniced {\n\t\tt.Error(\"The mock user should have included all interfaces and should not panic\")\n\t}\n\n\tdidPanic := func(f func()) (paniced bool) {\n\t\tdefer func() {\n\t\t\tif r := recover(); r != nil {\n\t\t\t\tpaniced = true\n\t\t\t}\n\t\t}()\n\n\t\tf()\n\t\treturn paniced\n\t}\n\n\tif !didPanic(func() { MustBeAuthable(fu) }) {\n\t\tt.Error(\"should have panic'd\")\n\t}\n\tif !didPanic(func() { MustBeConfirmable(fu) }) {\n\t\tt.Error(\"should have panic'd\")\n\t}\n\tif !didPanic(func() { MustBeLockable(fu) }) {\n\t\tt.Error(\"should have panic'd\")\n\t}\n\tif !didPanic(func() { MustBeOAuthable(fu) }) {\n\t\tt.Error(\"should have panic'd\")\n\t}\n\tif !didPanic(func() { MustBeRecoverable(fu) }) {\n\t\tt.Error(\"should have panic'd\")\n\t}\n}\n"
        },
        {
          "name": "validation.go",
          "type": "blob",
          "size": 1.4306640625,
          "content": "package authboss\n\nimport (\n\t\"bytes\"\n)\n\nconst (\n\t// ConfirmPrefix is prepended to names of confirm fields.\n\tConfirmPrefix = \"confirm_\"\n)\n\n// Validator takes a form name and a set of inputs and returns any\n// validation errors for the inputs.\ntype Validator interface {\n\t// Validate makes the type validate itself and return\n\t// a list of validation errors.\n\tValidate() []error\n}\n\n// FieldError describes an error on a field\n// Typically .Error() has both Name() and Err() together, hence the reason\n// for separation.\ntype FieldError interface {\n\terror\n\tName() string\n\tErr() error\n}\n\n// ErrorMap is a shortcut to change []error into ErrorList and call Map on it\n// since this is a common operation.\nfunc ErrorMap(e []error) map[string][]string {\n\treturn ErrorList(e).Map()\n}\n\n// ErrorList is simply a slice of errors with helpers.\ntype ErrorList []error\n\n// Error satisfies the error interface.\nfunc (e ErrorList) Error() string {\n\tb := &bytes.Buffer{}\n\tfirst := true\n\tfor _, err := range e {\n\t\tif first {\n\t\t\tfirst = false\n\t\t} else {\n\t\t\tb.WriteString(\", \")\n\t\t}\n\t\tb.WriteString(err.Error())\n\t}\n\treturn b.String()\n}\n\n// Map groups errors by their field name\nfunc (e ErrorList) Map() map[string][]string {\n\tm := make(map[string][]string)\n\n\tfor _, err := range e {\n\t\tfieldErr, ok := err.(FieldError)\n\t\tif !ok {\n\t\t\tm[\"\"] = append(m[\"\"], err.Error())\n\t\t} else {\n\t\t\tname, err := fieldErr.Name(), fieldErr.Err()\n\t\t\tm[name] = append(m[name], err.Error())\n\t\t}\n\t}\n\n\treturn m\n}\n"
        },
        {
          "name": "validation_test.go",
          "type": "blob",
          "size": 1.9482421875,
          "content": "package authboss\n\nimport (\n\t\"testing\"\n\n\t\"github.com/friendsofgo/errors\"\n)\n\ntype mockFieldError struct {\n\tname string\n\terr  error\n}\n\nfunc (m mockFieldError) Name() string {\n\treturn m.name\n}\n\nfunc (m mockFieldError) Err() error {\n\treturn m.err\n}\n\nfunc (m mockFieldError) Error() string {\n\treturn m.err.Error()\n}\n\nfunc TestErrorList_Error(t *testing.T) {\n\tt.Parallel()\n\n\terrList := ErrorList{errors.New(\"one\"), errors.New(\"two\")}\n\tif e := errList.Error(); e != \"one, two\" {\n\t\tt.Error(\"Wrong value for error:\", e)\n\t}\n}\n\nfunc TestErrorList_Map(t *testing.T) {\n\tt.Parallel()\n\n\terrNotLong := \"not long enough\"\n\terrEmail := \"should be an email\"\n\terrAsploded := \"asploded\"\n\n\terrList := ErrorList{\n\t\tmockFieldError{\"username\", errors.New(errNotLong)},\n\t\tmockFieldError{\"username\", errors.New(errEmail)},\n\t\tmockFieldError{\"password\", errors.New(errNotLong)},\n\t\terrors.New(errAsploded),\n\t}\n\n\tm := errList.Map()\n\tif len(m) != 3 {\n\t\tt.Error(\"Wrong number of fields:\", len(m))\n\t}\n\n\tusernameErrs := m[\"username\"]\n\tif len(usernameErrs) != 2 {\n\t\tt.Error(\"Wrong number of username errors:\", len(usernameErrs))\n\t}\n\tif usernameErrs[0] != errNotLong {\n\t\tt.Error(\"Wrong username error at 0:\", usernameErrs[0])\n\t}\n\tif usernameErrs[1] != errEmail {\n\t\tt.Error(\"Wrong username error at 1:\", usernameErrs[1])\n\t}\n\n\tpasswordErrs := m[\"password\"]\n\tif len(passwordErrs) != 1 {\n\t\tt.Error(\"Wrong number of password errors:\", len(passwordErrs))\n\t}\n\tif passwordErrs[0] != errNotLong {\n\t\tt.Error(\"Wrong password error at 0:\", passwordErrs[0])\n\t}\n\n\tunknownErrs := m[\"\"]\n\tif len(unknownErrs) != 1 {\n\t\tt.Error(\"Wrong number of unknown errors:\", len(unknownErrs))\n\t}\n\tif unknownErrs[0] != errAsploded {\n\t\tt.Error(\"Wrong unknown error at 0:\", unknownErrs[0])\n\t}\n}\n\nfunc TestErrorList_MapHelper(t *testing.T) {\n\tt.Parallel()\n\n\terrList := []error{\n\t\tmockFieldError{\"username\", errors.New(\"\")},\n\t\tmockFieldError{\"username\", errors.New(\"\")},\n\t\tmockFieldError{\"password\", errors.New(\"\")},\n\t}\n\n\tvar _ map[string][]string = ErrorMap(errList)\n}\n"
        },
        {
          "name": "values.go",
          "type": "blob",
          "size": 4.1884765625,
          "content": "package authboss\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n)\n\n// BodyReader reads data from the request\n// and returns it in an abstract form.\n// Typically used to decode JSON responses\n// or Url Encoded request bodies.\n//\n// The first parameter is the page that this request\n// was made on so we can tell what kind of JSON object\n// or form was present as well as create the proper\n// validation mechanisms.\n//\n// A typical example of this is taking the request\n// and turning it into a JSON struct that knows how\n// to validate itself and return certain fields.\ntype BodyReader interface {\n\tRead(page string, r *http.Request) (Validator, error)\n}\n\n// UserValuer allows us to pull out the PID and Password from the request.\ntype UserValuer interface {\n\tValidator\n\n\tGetPID() string\n\tGetPassword() string\n}\n\n// ConfirmValuer allows us to pull out the token from the request\ntype ConfirmValuer interface {\n\tValidator\n\n\tGetToken() string\n}\n\n// RecoverStartValuer provides the PID entered by the user.\ntype RecoverStartValuer interface {\n\tValidator\n\n\tGetPID() string\n}\n\n// RecoverMiddleValuer provides the token that the user submitted\n// via their link.\ntype RecoverMiddleValuer interface {\n\tValidator\n\n\tGetToken() string\n}\n\n// RecoverEndValuer is used to get data back from the final\n// page of password recovery, the user will provide a password\n// and it must be accompanied by the token to authorize the changing\n// of that password. Contrary to the RecoverValuer, this should\n// have validation errors for bad tokens.\ntype RecoverEndValuer interface {\n\tValidator\n\n\tGetPassword() string\n\tGetToken() string\n}\n\n// RememberValuer allows auth/oauth2 to pass along the remember\n// bool from the user to the remember module unobtrusively.\ntype RememberValuer interface {\n\t// Intentionally omitting validator\n\n\t// GetShouldRemember is the checkbox or what have you that\n\t// tells the remember module if it should remember that user's\n\t// authentication or not.\n\tGetShouldRemember() bool\n}\n\n// ArbitraryValuer provides the \"rest\" of the fields\n// that aren't strictly needed for anything in particular,\n// address, secondary e-mail, etc.\n//\n// There are two important notes about this interface:\n//\n// 1. That this is composed with Validator, as these fields\n// should both be validated and culled of invalid pieces\n// as they will be passed into ArbitraryUser.PutArbitrary()\n//\n// 2. These values will also be culled according to the RegisterPreserveFields\n// whitelist and sent back in the data under the key DataPreserve.\ntype ArbitraryValuer interface {\n\tValidator\n\n\tGetValues() map[string]string\n}\n\n// MustHaveUserValues upgrades a validatable set of values\n// to ones specific to an authenticating user.\nfunc MustHaveUserValues(v Validator) UserValuer {\n\tif u, ok := v.(UserValuer); ok {\n\t\treturn u\n\t}\n\n\tpanic(fmt.Sprintf(\"bodyreader returned a type that could not be upgraded to UserValuer: %T\", v))\n}\n\n// MustHaveConfirmValues upgrades a validatable set of values\n// to ones specific to a user that needs to be confirmed.\nfunc MustHaveConfirmValues(v Validator) ConfirmValuer {\n\tif u, ok := v.(ConfirmValuer); ok {\n\t\treturn u\n\t}\n\n\tpanic(fmt.Sprintf(\"bodyreader returned a type that could not be upgraded to ConfirmValuer: %T\", v))\n}\n\n// MustHaveRecoverStartValues upgrades a validatable set of values\n// to ones specific to a user that needs to be recovered.\nfunc MustHaveRecoverStartValues(v Validator) RecoverStartValuer {\n\tif u, ok := v.(RecoverStartValuer); ok {\n\t\treturn u\n\t}\n\n\tpanic(fmt.Sprintf(\"bodyreader returned a type that could not be upgraded to RecoverStartValuer: %T\", v))\n}\n\n// MustHaveRecoverMiddleValues upgrades a validatable set of values\n// to ones specific to a user that's attempting to recover.\nfunc MustHaveRecoverMiddleValues(v Validator) RecoverMiddleValuer {\n\tif u, ok := v.(RecoverMiddleValuer); ok {\n\t\treturn u\n\t}\n\n\tpanic(fmt.Sprintf(\"bodyreader returned a type that could not be upgraded to RecoverMiddleValuer: %T\", v))\n}\n\n// MustHaveRecoverEndValues upgrades a validatable set of values\n// to ones specific to a user that needs to be recovered.\nfunc MustHaveRecoverEndValues(v Validator) RecoverEndValuer {\n\tif u, ok := v.(RecoverEndValuer); ok {\n\t\treturn u\n\t}\n\n\tpanic(fmt.Sprintf(\"bodyreader returned a type that could not be upgraded to RecoverEndValuer: %T\", v))\n}\n"
        },
        {
          "name": "values_test.go",
          "type": "blob",
          "size": 1.66796875,
          "content": "package authboss\n\nimport \"testing\"\n\ntype testAssertionValues struct{}\n\nfunc (testAssertionValues) Validate() []error            { return nil }\nfunc (testAssertionValues) GetPID() string               { return \"\" }\nfunc (testAssertionValues) GetPassword() string          { return \"\" }\nfunc (testAssertionValues) GetToken() string             { return \"\" }\nfunc (testAssertionValues) GetShouldRemember() bool      { return false }\nfunc (testAssertionValues) GetValues() map[string]string { return nil }\n\ntype testAssertionFailValues struct{}\n\nfunc (testAssertionFailValues) Validate() []error { return nil }\n\nfunc TestValueAssertions(t *testing.T) {\n\tt.Parallel()\n\n\tv := testAssertionValues{}\n\tfv := testAssertionFailValues{}\n\n\tpaniced := false\n\tfunc() {\n\t\tdefer func() {\n\t\t\tif r := recover(); r != nil {\n\t\t\t\tpaniced = true\n\t\t\t}\n\n\t\t}()\n\n\t\tMustHaveUserValues(v)\n\t\tMustHaveConfirmValues(v)\n\t\tMustHaveRecoverStartValues(v)\n\t\tMustHaveRecoverMiddleValues(v)\n\t\tMustHaveRecoverEndValues(v)\n\t}()\n\n\tif paniced {\n\t\tt.Error(\"The mock storer should have included all interfaces and should not panic\")\n\t}\n\n\tdidPanic := func(f func()) (paniced bool) {\n\t\tdefer func() {\n\t\t\tif r := recover(); r != nil {\n\t\t\t\tpaniced = true\n\t\t\t}\n\t\t}()\n\n\t\tf()\n\t\treturn paniced\n\t}\n\n\tif !didPanic(func() { MustHaveUserValues(fv) }) {\n\t\tt.Error(\"should have panic'd\")\n\t}\n\tif !didPanic(func() { MustHaveConfirmValues(fv) }) {\n\t\tt.Error(\"should have panic'd\")\n\t}\n\tif !didPanic(func() { MustHaveRecoverStartValues(fv) }) {\n\t\tt.Error(\"should have panic'd\")\n\t}\n\tif !didPanic(func() { MustHaveRecoverMiddleValues(fv) }) {\n\t\tt.Error(\"should have panic'd\")\n\t}\n\tif !didPanic(func() { MustHaveRecoverEndValues(fv) }) {\n\t\tt.Error(\"should have panic'd\")\n\t}\n}\n"
        }
      ]
    }
  ]
}