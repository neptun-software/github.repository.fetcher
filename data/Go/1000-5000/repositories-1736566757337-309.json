{
  "metadata": {
    "timestamp": 1736566757337,
    "page": 309,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjMxMA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "alexflint/gallium",
      "stars": 3672,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".gitattributes",
          "type": "blob",
          "size": 0.34375,
          "content": "*.so filter=lfs diff=lfs merge=lfs -text\n*.dylib filter=lfs diff=lfs merge=lfs -text\ndist/Gallium.framework/Versions/A/Resources/icudtl.dat filter=lfs diff=lfs merge=lfs -text\ndist/Gallium.framework/Versions/A/Resources/content_shell.pak filter=lfs diff=lfs merge=lfs -text\ndist/Gallium.framework/Versions/A/Gallium filter=lfs diff=lfs merge=lfs -text\n"
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.1337890625,
          "content": "/*.vcxproj*\n/*.xcodeproj/\n/lib/build/\n\n# Visual Studio\n/*.opensdf\n/*.sdf\n/*.sln\n/*.suo\n/ipch/\n\n# Linux\nout/\n\n# Vim\n/*.swp\n*.app\n\n/build/\n"
        },
        {
          "name": ".travis.yml",
          "type": "blob",
          "size": 0.19140625,
          "content": "language: go\nos:\n  - osx\n\nosx_image: xcode8\n\nbefore_install:\n  - brew install git-lfs\n  - git lfs install --system\n  - git lfs pull\n\nsudo: false\n\ngo:\n  - 1.7\n  - tip\n\nscript:\n  - go test -v ./...\n"
        },
        {
          "name": "Godeps",
          "type": "tree",
          "content": null
        },
        {
          "name": "LICENSE.md",
          "type": "blob",
          "size": 1.0419921875,
          "content": "MIT License\n\nCopyright (c) 2025 Alex Flint\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 10.3525390625,
          "content": "[![GoDoc](https://godoc.org/github.com/alexflint/gallium?status.svg)](https://godoc.org/github.com/alexflint/gallium)\n[![Build Status](https://travis-ci.org/alexflint/gallium.svg?branch=master)](https://travis-ci.org/alexflint/gallium)\n\nWrite desktop applications in Go, HTML, Javascript, and CSS.\n\nGallium is a Go library for managing windows, menus, dock icons, and desktop notifications. Each window contains a webview component, in which you code your UI in HTML. Under the hood, the webview is running Chromium.\n\n### Warning\n\nThis is an extremely early version of Gallium. Most APIs will probably change\nbefore the 1.0 release, and much of the functionality that is already implemented\nremains unstable.\n\n### Platforms\n\nOnly OSX is supported right now. I intend to add support for Windows and Linux\nsoon.\n\n### Discussion\n\nJoin the `#gallium` channel over at the Gophers slack. (You can request an invite to\nthe Gophers slack team [here](https://gophersinvite.herokuapp.com/).)\n\n### Installation\n\nRequires go >= 1.7\n\nFirst install git large file storage, then install Gallium:\n```shell\n$ brew install git-lfs\n$ git lfs install\n$ go get github.com/alexflint/gallium  # will not work without git lfs!\n```\n\nThis will fetch a 92MB framework containing a binary distribution\nof the Chromium content module, so it may take a few moments. This\nis also why git large file storage must be installed (github has\na limit on file size.)\n\n### Quickstart\n\n```go\npackage main\n\nimport (\n  \"os\"\n  \"runtime\"\n\n  \"github.com/alexflint/gallium\"\n)\n\nfunc main() {\n  runtime.LockOSThread()         // must be the first statement in main - see below\n  gallium.Loop(os.Args, onReady) // must be called from main function\n}\n\nfunc onReady(app *gallium.App) {\n  app.OpenWindow(\"http://example.com/\", gallium.FramedWindow)\n}\n```\n\nTo run the example as a full-fledged UI application, you need to build\nan app bundle:\n```shell\n$ go build ./example\n$ go install github.com/alexflint/gallium/cmd/gallium-bundle\n$ gallium-bundle example\n$ open example.app\n```\n\n![Result of the example](https://cloud.githubusercontent.com/assets/640247/18623245/c71c2d26-7def-11e6-9ad3-1a5541d7fc86.png)\n\nIf you run the executable directly without building an app bundle then\nmany UI elements, such as menus, will not work correctly.\n\n```shell\n$ go run example.go\n```\n\n### Menus\n\n```go\nfunc main() {\n  runtime.LockOSThread()\n  gallium.Loop(os.Args, onReady)\n}\n\nfunc onReady(app *gallium.App) {\n  app.OpenWindow(\"http://example.com/\", gallium.FramedWindow)\n  app.SetMenu([]gallium.Menu{\n    gallium.Menu{\n      Title: \"demo\",\n      Entries: []gallium.MenuEntry{\n        gallium.MenuItem{\n          Title:    \"About\",\n          OnClick:  handleMenuAbout,\n        },\n        gallium.Separator,\n        gallium.MenuItem{\n          Title:    \"Quit\",\n          Shortcut: \"Cmd+q\",\n          OnClick:  handleMenuQuit,\n        },\n      },\n    },\n  })\n}\n\nfunc handleMenuAbout() {\n  log.Println(\"about clicked\")\n  os.Exit(0)\n}\n\nfunc handleMenuQuit() {\n  log.Println(\"quit clicked\")\n  os.Exit(0)\n}\n```\n\n![Menu demo](https://cloud.githubusercontent.com/assets/640247/20243830/17fbaa8e-a91d-11e6-8eca-7ae7c1418a7e.png)\n\n### Status Bar\n\n```go\nfunc main() {\n  runtime.LockOSThread()\n  gallium.Loop(os.Args, onReady)\n}\n\nfunc onReady(app *gallium.App) {\n  app.OpenWindow(\"http://example.com/\", gallium.FramedWindow)\n  app.AddStatusItem(\n    20,\n    \"statusbar\",\n    true,\n    gallium.MenuItem{\n      Title:   \"Do something\",\n      OnClick: handleDoSomething,\n    },\n    gallium.MenuItem{\n      Title:   \"Do something else\",\n      OnClick: handleDoSomethingElse,\n    },\n  )\n}\n\nfunc handleDoSomething() {\n  log.Println(\"do something\")\n}\n\nfunc handleDoSomethingElse() {\n  log.Println(\"do something else\")\n}\n```\n\n![Statusbar demo](https://cloud.githubusercontent.com/assets/640247/18698431/06e9d88c-7f7f-11e6-9fa5-d6be40a07840.png)\n\n### Desktop Notifications\n\nNote that the OSX Notification Center determines whether or not to show any\ngiven desktop notification, so you may need to open the notification center\nand scroll to the bottom in order to see notifications during development.\n\n```go\nfunc main() {\n  runtime.LockOSThread()\n  gallium.Loop(os.Args, onReady)\n}\n\nfunc onReady(app *gallium.App) {\n  img, err := gallium.ImageFromPNG(pngBuffer)\n  if err != nil {\n    ...\n  }\n\n  app.Post(gallium.Notification{\n    Title:    \"Wow this is a notification\",\n    Subtitle: \"The subtitle\",\n    Image:    img,\n  })\n}\n```\n\n### Dock icons\n\nTo add a dock icon, create a directory named `myapp.iconset` containing the following files:\n```\nicon_16x16.png          # 16 x 16\nicon_16x16@2x.png       # 32 x 32\nicon_32x32.png          # 32 x 32\nicon_32x32@2x.png       # 64 x 64\nicon_128x128.png        # 128 x 128\nicon_128x128@2x.png     # 256 x 256\nicon_256x256.png        # 256 x 256\nicon_256x256@2x.png     # 512 x 512\nicon_512x512.png        # 512 x 512\nicon_512x512@2x.png     # 1024 x 1024\n```\n\nThen build you app with\n```shell\ngallium-bundle myapp --icon myapp.iconset\n```\n\nAlternatively, if you have a `.icns` file:\n```shell\ngallium-bundle myapp --icon myapp.icns\n```\n\n### Writing native code\n\nYou can write C or Objective-C code that interfaces directly with native\nwindowing APIs. The following example uses the macOS native API `[NSWindow\nsetAlphaValue]` to create a semi-transparent window.\n\n```go\npackage main\n\nimport (\n  \"log\"\n  \"os\"\n  \"runtime\"\n\n  \"github.com/alexflint/gallium\"\n)\n\n/*\n#cgo CFLAGS: -x objective-c\n#cgo CFLAGS: -framework Cocoa\n#cgo LDFLAGS: -framework Cocoa\n\n#include <Cocoa/Cocoa.h>\n#include <dispatch/dispatch.h>\n\nvoid SetAlpha(void* window, float alpha) {\n  // Cocoa requires that all UI operations happen on the main thread. Since\n  // gallium.Loop will have initiated the Cocoa event loop, we can can use\n  // dispatch_async to run code on the main thread.\n  dispatch_async(dispatch_get_main_queue(), ^{\n    NSWindow* w = (NSWindow*)window;\n    [w setAlphaValue:alpha];\n  });\n}\n*/\nimport \"C\"\n\nfunc onReady(ui *gallium.App) {\n  window, err := ui.OpenWindow(\"http://example.com/\", gallium.FramedWindow)\n  if err != nil {\n    log.Fatal(err)\n  }\n  C.SetAlpha(window.NativeWindow(), 0.5)\n}\n\nfunc main() {\n  runtime.LockOSThread()\n  gallium.Loop(os.Args, onReady)\n}\n```\n\n### Relationship to other projects\n\n[Electron](http://electron.atom.io/) is a well-known framework for writing desktop applications in node.js. Electron and Gallium are similar in that the core UI is developed in HTML and javascript, but with Gallium the \"outer layer\" of logic is written in Go. Both Electron and Gallium use Chromium under the hood, and some of the C components for Gallium were ported from Electron.\n\nThe [Chromium Embedded Framework](https://bitbucket.org/chromiumembedded/cef) is a C framework for embedding Chromium into other applications. I investigated CEF as a basis for Gallium but decided to use [libchromiumcontent](https://github.com/electron/libchromiumcontent) instead.\n\n[cef2go](https://github.com/cztomczak/cef2go) is a Go wrapper for Chromium based on CEF, but so far it still requires some manual steps to use as a library.\n\n### Rationale\n\nThe goal of Gallium is to make it possible to write cross-platform\ndesktop UI applications in Go.\n\n### Troubleshooting\n\n**\"file was built for unsupported file format\"**\n\nIf you see the following error:\n```\nld: warning: ignoring file go/src/github.com/alexflint/gallium/dist/Gallium.framework/Gallium, file was built for unsupported file format ( 0x76 0x65 0x72 0x73 0x69 0x6F 0x6E 0x20 0x68 0x74 0x74 0x70 0x73 0x3A 0x2F 0x2F ) which is not the architecture being linked (x86_64): go/src/github.com/alexflint/gallium/dist/Gallium.framework/Gallium\n```\nthen you probably have an issue with `git lfs`. You can confirm that this is\nthe problem by checking the size of the file in the error message: it should\nbe over 1 MB, but if you see a much smaller file then this is your problem.\n\nTo fix this, try re-installing `git lfs` as described in the installation\nsection above, then delete and re-install gallium.\n\n**No console output**\n\nWhen you run an app bundle with `open Foo.app`, OSX launch services discards\nstandard output and standard error. If you need to see this output for\ndebugging purposes, use a redirect:\n```\ngallium.RedirectStdoutStderr(\"output.log\")\n```\n\n**App does not start**\n\nWhen you run an app bundle with `open Foo.app`, OSX launch services will only\nstart your app if there is not already another instance of the same\napplication running, so if your app refuses to start then try checking the\nactivity monitor for an already running instance.\n\n**Menus not visible**\n\nIf you run the binary directly without building an app\nbundle then your menus will not show up, and the window will initially appear\nbehind other applications.\n\n### UI thread issues and runtime.LockOSThread\n\nIt is very important that the first statement in your main function\nbe `runtime.LockOSThread()`. The reason is that gallium calls\nout to various C functions in order to create and manage OSX UI elements,\nand many of these are required to be called from the first thread\ncreated by the process. But the Go runtime creates many threads and any\none piece of Go code could end up running on any thread. The solution\nis `runtime.LockOSThread`, which tells the Go scheduler to lock the\ncurrent goroutine so that it will only ever run on the current thread.\nSince the main function always starts off on the main thread, this wil\nguarantee that the later call to `gallium.Loop` will also be on the main\nthread. At this point gallium takes ownership of this thread for its main\nevent loop and calls the `OnReady` callback in a separate goroutine.\nFrom this point forward it is safe to call gallium functions from any\ngoroutine.\n\n### Shared libraries and linking issues\n\nGallium is based on Chromium, which it accesses via `Gallium.framework`.\nThat framework in turn contains `libchromiumcontent.dylib`, which is a \nshared library containing the chromium content module and is distributed\nin binary form by the same folks responsible for the excellent Electron\nframework. When you build your Go executable, the directives in\n`Gallium.framework` instruct the linker to set up the executable to look for\n`Gallium.framework` in two places at runtime:\n 1. `<dir containing executable>/../Frameworks/Gallium.framework`: this\n     will resolve correctly if you choose to build and run your app as a\n     bundle (and also means you can distribute the app bundle as a\n     self-contained unit).\n 2. `$GOPATH/src/github.com/alexflint/dist/Gallium.framework`: this will\n     resolve if you choose to run your executable directly.\n\n"
        },
        {
          "name": "app.go",
          "type": "blob",
          "size": 7.7431640625,
          "content": "package gallium\n\n/*\n#cgo CFLAGS: -mmacosx-version-min=10.8\n#cgo CFLAGS: -DGALLIUM_DIR=${SRCDIR}\n#cgo CFLAGS: -Idist/include\n\n#include <stdlib.h>\n#include \"gallium/browser.h\"\n#include \"gallium/cocoa.h\"\n\n// It does not seem that we can import \"_cgo_export.h\" from here\nextern void cgo_onReady(int);\n\n// This is a wrapper around GalliumLoop that adds the function pointer\n// argument, since this does not seem to be possible from Go directly.\nstatic inline void helper_GalliumLoop(int app_id, const char* arg0, struct gallium_error** err) {\n\tGalliumLoop(app_id, arg0, &cgo_onReady, err);\n}\n*/\nimport \"C\"\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"log\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"time\"\n\t\"unsafe\"\n)\n\nvar (\n\terrZeroWidth  = errors.New(\"window width was zero\")\n\terrZeroHeight = errors.New(\"window height was zero\")\n)\n\n// cerr holds a C-allocated error, which must be freed explicitly.\ntype cerr struct {\n\tc *C.struct_gallium_error\n}\n\n// newCerr allocates a new error struct. It must be freed explicitly.\nfunc newCerr() cerr {\n\treturn cerr{\n\t\tc: (*C.struct_gallium_error)(C.malloc(C.sizeof_struct_gallium_error)),\n\t}\n}\n\nfunc (e cerr) free() {\n\tC.free(unsafe.Pointer(e.c))\n}\n\nfunc (e *cerr) err() error {\n\t// TODO\n\treturn fmt.Errorf(\"C error\")\n}\n\n// Loop starts the browser loop and does not return unless there is an initialization error\nfunc Loop(args []string, onReady func(*App)) error {\n\tlog.Println(\"\\n\\n=== gallium.Loop ===\")\n\tcerr := newCerr()\n\tdefer cerr.free()\n\n\tapp := App{\n\t\tready: make(chan struct{}),\n\t}\n\n\tgo func() {\n\t\tselect {\n\t\tcase <-app.ready:\n\t\t\tonReady(&app)\n\t\tcase <-time.After(3 * time.Second):\n\t\t\tlog.Fatal(\"Waited for 3 seconds without ready signal\")\n\t\t}\n\t}()\n\n\tappId := apps.add(&app)\n\tC.helper_GalliumLoop(C.int(appId), C.CString(args[0]), &cerr.c)\n\treturn cerr.err()\n}\n\n// appManager is the singleton for managing app instances\ntype appManager []*App\n\nfunc (m *appManager) add(app *App) int {\n\tid := len(*m)\n\t*m = append(*m, app)\n\treturn id\n}\n\nfunc (m *appManager) get(id int) *App {\n\treturn (*m)[id]\n}\n\nvar apps appManager\n\n// App is the handle that allows you to create windows and menus\ntype App struct {\n\t// ready is how the cgo onready callback indicates to the Loop goroutine that\n\t// chromium is initialized\n\tready chan struct{}\n}\n\n// WindowOptions contains options for creating windows\ntype WindowOptions struct {\n\tTitle            string // String to display in title bar\n\tShape            Rect   // Initial size and position of window\n\tTitleBar         bool   // Whether the window title bar\n\tFrame            bool   // Whether the window has a frame\n\tResizable        bool   // Whether the window border can be dragged to change its shape\n\tCloseButton      bool   // Whether the window has a close button\n\tMinButton        bool   // Whether the window has a miniaturize button\n\tFullScreenButton bool   // Whether the window has a full screen button\n\tMenu             []MenuEntry\n}\n\n// FramedWindow contains options for an \"ordinary\" window with title bar,\n// frame, and min/max/close buttons.\nvar FramedWindow = WindowOptions{\n\tShape: Rect{\n\t\tWidth:  800,\n\t\tHeight: 600,\n\t\tLeft:   100,\n\t\tBottom: 100,\n\t},\n\tTitleBar:         true,\n\tFrame:            true,\n\tResizable:        true,\n\tCloseButton:      true,\n\tMinButton:        true,\n\tFullScreenButton: true,\n\tTitle:            defaultWindowTitle(),\n}\n\nfunc defaultWindowTitle() string {\n\t// try the display name first\n\tif name := BundleInfo(\"CFBundleDisplayName\"); name != \"\" {\n\t\treturn name\n\t}\n\t// then fall back to the short name\n\tif name := BundleInfo(\"CFBundleName\"); name != \"\" {\n\t\treturn name\n\t}\n\t// then fall back to the executable name\n\tif len(os.Args) > 0 {\n\t\tfilepath.Base(os.Args[0])\n\t}\n\treturn \"\"\n}\n\n// FramelessWindow contains options for a window with no frame or border, but that\n// is still resizable.\nvar FramelessWindow = WindowOptions{\n\tShape: Rect{\n\t\tWidth:  800,\n\t\tHeight: 600,\n\t\tLeft:   100,\n\t\tBottom: 100,\n\t},\n\tResizable: true,\n}\n\n// Window represents a window registered with the native UI toolkit (e.g. NSWindow on macOS)\ntype Window struct {\n\tc *C.gallium_window_t\n}\n\n// OpenWindow creates a window that will load the given URL.\nfunc (app *App) OpenWindow(url string, opt WindowOptions) (*Window, error) {\n\tif opt.Shape.Width == 0 {\n\t\treturn nil, errZeroWidth\n\t}\n\tif opt.Shape.Height == 0 {\n\t\treturn nil, errZeroHeight\n\t}\n\t// Create the Cocoa window\n\tcwin := C.GalliumOpenWindow(\n\t\tC.CString(url),\n\t\tC.CString(opt.Title),\n\t\tC.int(opt.Shape.Width),\n\t\tC.int(opt.Shape.Height),\n\t\tC.int(opt.Shape.Left),\n\t\tC.int(opt.Shape.Bottom),\n\t\tC.bool(opt.TitleBar),\n\t\tC.bool(opt.Frame),\n\t\tC.bool(opt.Resizable),\n\t\tC.bool(opt.CloseButton),\n\t\tC.bool(opt.MinButton),\n\t\tC.bool(opt.FullScreenButton))\n\n\t// TODO: associate menu\n\treturn &Window{\n\t\tc: cwin,\n\t}, nil\n}\n\n// Shape gets the current shape of the window.\nfunc (w *Window) Shape() Rect {\n\treturn rectFromC(C.GalliumWindowGetShape(w.c))\n}\n\n// Shape gets the current shape of the window.\nfunc (w *Window) SetShape(r Rect) {\n\tC.GalliumWindowSetShape(w.c, C.int(r.Width), C.int(r.Height), C.int(r.Left), C.int(r.Bottom))\n}\n\n// URL gets the URL that the window is currently at.\nfunc (w *Window) URL() string {\n\treturn C.GoString(C.GalliumWindowGetURL(w.c))\n}\n\n// LoadURL causes the window to load the given URL\nfunc (w *Window) LoadURL(url string) {\n\tC.GalliumWindowLoadURL(w.c, C.CString(url))\n}\n\n// Reload reloads the current URL\nfunc (w *Window) Reload() {\n\tC.GalliumWindowReload(w.c)\n}\n\n// Reload reloads the current URL, ignoring cached versions of resources.\nfunc (w *Window) ReloadNoCache() {\n\tC.GalliumWindowReloadNoCache(w.c)\n}\n\n// Open opens the window. This is the default state for a window created\n// via OpenWindow, so you only need to call this if you manually closed\n// the window.\nfunc (w *Window) Open() {\n\tC.GalliumWindowOpen(w.c)\n}\n\n// Close closes the window, as if the close button had been clicked.\nfunc (w *Window) Close() {\n\tC.GalliumWindowClose(w.c)\n}\n\n// Miniaturize miniaturizes the window, as if the min button had been clicked.\nfunc (w *Window) Miniaturize() {\n\tC.GalliumWindowMiniaturize(w.c)\n}\n\n// Undo undoes the last text editing action\nfunc (w *Window) Undo() {\n\tC.GalliumWindowUndo(w.c)\n}\n\n// Redo redoes the last text editing action\nfunc (w *Window) Redo() {\n\tC.GalliumWindowRedo(w.c)\n}\n\n// Cut cuts the current text selection to the pastboard\nfunc (w *Window) Cut() {\n\tC.GalliumWindowCut(w.c)\n}\n\n// Copy copies the current text selection to the pasteboard\nfunc (w *Window) Copy() {\n\tC.GalliumWindowCopy(w.c)\n}\n\n// Paste pastes from the pasteboard\nfunc (w *Window) Paste() {\n\tC.GalliumWindowPaste(w.c)\n}\n\n// PasteAndMatchStyle pastes from the pasteboard, matching style to the current element\nfunc (w *Window) PasteAndMatchStyle() {\n\tC.GalliumWindowPasteAndMatchStyle(w.c)\n}\n\n// Delete deletes the current text selection\nfunc (w *Window) Delete() {\n\tC.GalliumWindowDelete(w.c)\n}\n\n// SelectAll selects all text in the current element\nfunc (w *Window) SelectAll() {\n\tC.GalliumWindowSelectAll(w.c)\n}\n\n// Unselect unselects any text selection\nfunc (w *Window) Unselect() {\n\tC.GalliumWindowUnselect(w.c)\n}\n\n// OpenDevTools opens the developer tools for this window.\nfunc (w *Window) OpenDevTools() {\n\tC.GalliumWindowOpenDevTools(w.c)\n}\n\n// CloseDevTools closes the developer tools.\nfunc (w *Window) CloseDevTools() {\n\tC.GalliumWindowCloseDevTools(w.c)\n}\n\n// DevToolsVisible returns whether the developer tools are showing\nfunc (w *Window) DevToolsAreOpen() bool {\n\treturn bool(C.GalliumWindowDevToolsAreOpen(w.c))\n}\n\n// NativeWindow gets a operating-system dependent handle for this window. Under macOS\n// this is NSWindow*.\nfunc (w *Window) NativeWindow() unsafe.Pointer {\n\treturn unsafe.Pointer(C.GalliumWindowNativeWindow(w.c))\n}\n\n// NativeWindow gets an operating-system dependent handle for the window controller.\n// Under macOS this is *NSWindowController.\nfunc (w *Window) NativeController() unsafe.Pointer {\n\treturn unsafe.Pointer(C.GalliumWindowNativeController(w.c))\n}\n"
        },
        {
          "name": "callbacks.go",
          "type": "blob",
          "size": 0.9345703125,
          "content": "package gallium\n\nimport (\n\t\"log\"\n\t\"unsafe\"\n)\n\nimport \"C\"\n\n// This file contains all Go functions that are exported to cgo. They\n// are here because the presence of an export means that the C prelude\n// gets copied into two locations.\n\n//export cgo_onReady\nfunc cgo_onReady(appId int) {\n\t// do not actually call the user function from here because that would\n\t// block the UI loop\n\tapps.get(appId).ready <- struct{}{}\n}\n\n//export cgo_onMenuClicked\nfunc cgo_onMenuClicked(data unsafe.Pointer) {\n\tif menuMgr == nil {\n\t\tlog.Println(\"onMenuClicked called but menu manager was nil\")\n\t\treturn\n\t}\n\n\tif data == nil {\n\t\tlog.Println(\"onMenuClicked called but data parameter was nil\")\n\t\treturn\n\t}\n\n\tid := *(*int)(data)\n\titem, found := menuMgr.items[id]\n\tif !found {\n\t\tlog.Printf(\"onMenuClicked received non-existent ID %d\", id)\n\t\treturn\n\t}\n\n\tif item.OnClick == nil {\n\t\tlog.Printf(\"onMenuClicked found %s but OnClick was nil\", item.Title)\n\t\treturn\n\t}\n\n\titem.OnClick()\n}\n"
        },
        {
          "name": "cmd",
          "type": "tree",
          "content": null
        },
        {
          "name": "cocoa.go",
          "type": "blob",
          "size": 5.7724609375,
          "content": "package gallium\n\n/*\n#include <stdlib.h>\n#include \"gallium/cocoa.h\"\n\n// It does not seem that we can import \"_cgo_export.h\" from here\nextern void cgo_onMenuClicked(void*);\n\n// This is a wrapper around NSMenu_AddMenuItem that adds the function pointer\n// argument, since this does not seem to be possible from Go directly.\nstatic inline gallium_nsmenuitem_t* helper_NSMenu_AddMenuItem(\n\tgallium_nsmenu_t* menu,\n\tconst char* title,\n\tconst char* shortcutKey,\n\tgallium_modifier_t shortcutModifier,\n\tvoid *callbackArg) {\n\n\treturn NSMenu_AddMenuItem(\n\t\tmenu,\n\t\ttitle,\n\t\tshortcutKey,\n\t\tshortcutModifier,\n\t\t&cgo_onMenuClicked,\n\t\tcallbackArg);\n}\n*/\nimport \"C\"\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"log\"\n\t\"strings\"\n\t\"unsafe\"\n)\n\n// MenuEntry is the interface for menus and menu items.\ntype MenuEntry interface {\n\tmenu()\n}\n\n// Separator displays a horizontal separator within a menu\nvar Separator MenuEntry\n\n// A MenuItem has a title and can be clicked on. It is a leaf node in the menu tree.\ntype MenuItem struct {\n\tTitle    string\n\tShortcut KeyCombination\n\tOnClick  func()\n}\n\nfunc (MenuItem) menu() {}\n\n// A Menu has a title and a list of entries. It is a non-leaf node in the menu tree.\ntype Menu struct {\n\tTitle   string\n\tEntries []MenuEntry\n}\n\nfunc (Menu) menu() {}\n\n// menuMgr is the singleton that owns the menu\nvar menuMgr *menuManager\n\n// menuManager translates Menus and MenuItems to their native equivalent (e.g. NSMenuItem on macOS)\ntype menuManager struct {\n\titems map[int]MenuItem\n}\n\nfunc newMenuManager() *menuManager {\n\treturn &menuManager{make(map[int]MenuItem)}\n}\n\nfunc (m *menuManager) add(menu MenuEntry, parent *C.gallium_nsmenu_t) {\n\tswitch menu := menu.(type) {\n\tcase Menu:\n\t\titem := C.NSMenu_AddMenuItem(parent, C.CString(menu.Title), nil, 0, nil, nil)\n\t\tsubmenu := C.NSMenu_New(C.CString(menu.Title))\n\t\tC.NSMenuItem_SetSubmenu(item, submenu)\n\t\tfor _, entry := range menu.Entries {\n\t\t\tm.add(entry, submenu)\n\t\t}\n\tcase MenuItem:\n\t\tid := len(m.items)\n\t\tm.items[id] = menu\n\n\t\tcallbackArg := C.malloc(C.sizeof_int)\n\t\t*(*C.int)(callbackArg) = C.int(id)\n\n\t\tC.helper_NSMenu_AddMenuItem(\n\t\t\tparent,\n\t\t\tC.CString(menu.Title),\n\t\t\tC.CString(menu.Shortcut.Key),\n\t\t\tC.gallium_modifier_t(menu.Shortcut.Modifiers),\n\t\t\tcallbackArg)\n\tcase nil:\n\t\t// nil means add a separator\n\t\tC.NSMenu_AddSeparator(parent)\n\tdefault:\n\t\tlog.Printf(\"unexpected menu entry: %T\", menu)\n\t}\n}\n\nfunc parseShortcut(s string) (key string, modifiers int, err error) {\n\tparts := strings.Split(s, \"+\")\n\tif len(parts) == 0 {\n\t\treturn \"\", 0, fmt.Errorf(\"empty shortcut\")\n\t}\n\tkey = parts[len(parts)-1]\n\tif len(key) == 0 {\n\t\treturn \"\", 0, fmt.Errorf(\"empty key\")\n\t}\n\tfor _, part := range parts[:len(parts)-1] {\n\t\tswitch strings.ToLower(part) {\n\t\tcase \"cmd\":\n\t\t\tmodifiers |= int(C.GalliumCmdModifier)\n\t\tcase \"ctrl\":\n\t\t\tmodifiers |= int(C.GalliumCtrlModifier)\n\t\tcase \"cmdctrl\":\n\t\t\tmodifiers |= int(C.GalliumCmdOrCtrlModifier)\n\t\tcase \"alt\":\n\t\t\tmodifiers |= int(C.GalliumAltOrOptionModifier)\n\t\tcase \"option\":\n\t\t\tmodifiers |= int(C.GalliumAltOrOptionModifier)\n\t\tcase \"fn\":\n\t\t\tmodifiers |= int(C.GalliumFnModifier)\n\t\tcase \"shift\":\n\t\t\tmodifiers |= int(C.GalliumShiftModifier)\n\t\tdefault:\n\t\t\treturn \"\", 0, fmt.Errorf(\"unknown modifier: %s\", part)\n\t\t}\n\t}\n\treturn\n}\n\nfunc (app *App) SetMenu(menus []Menu) {\n\tif menuMgr == nil {\n\t\tmenuMgr = newMenuManager()\n\t}\n\troot := C.NSMenu_New(C.CString(\"<root>\"))\n\tfor _, m := range menus {\n\t\tmenuMgr.add(m, root)\n\t}\n\tC.NSApplication_SetMainMenu(root)\n}\n\ntype StatusItemOptions struct {\n\tImage     *Image      // image to show in the status bar, must be non-nil\n\tWidth     float64     // width of item in pixels (zero means automatic size)\n\tHighlight bool        // whether to highlight the item when clicked\n\tMenu      []MenuEntry // the menu to display when the item is clicked\n}\n\nfunc (app *App) AddStatusItem(opts StatusItemOptions) {\n\tif menuMgr == nil {\n\t\tmenuMgr = newMenuManager()\n\t}\n\tif opts.Image == nil {\n\t\tpanic(\"status item image must not be nil\")\n\t}\n\n\tmenu := C.NSMenu_New(C.CString(\"<statusbar>\"))\n\tfor _, m := range opts.Menu {\n\t\tmenuMgr.add(m, menu)\n\t}\n\tC.NSStatusBar_AddItem(\n\t\topts.Image.c,\n\t\tC.float(opts.Width),\n\t\tC.bool(opts.Highlight),\n\t\tmenu)\n}\n\n// Image holds a handle to a platform-specific image structure (e.g. NSImage on macOS).\ntype Image struct {\n\tc *C.gallium_nsimage_t\n}\n\nvar (\n\tErrImageDecodeFailed = errors.New(\"image could not be decoded\")\n)\n\n// ImageFromPNG creates an image from a buffer containing a PNG-encoded image.\nfunc ImageFromPNG(buf []byte) (*Image, error) {\n\tcbuf := C.CBytes(buf)\n\tdefer C.free(cbuf)\n\tcimg := C.NSImage_NewFromPNG(cbuf, C.int(len(buf)))\n\tif cimg == nil {\n\t\treturn nil, ErrImageDecodeFailed\n\t}\n\treturn &Image{cimg}, nil\n}\n\n// Notification represents a desktop notification\ntype Notification struct {\n\tTitle             string\n\tSubtitle          string\n\tInformativeText   string\n\tImage             *Image\n\tIdentifier        string\n\tActionButtonTitle string\n\tOtherButtonTitle  string\n}\n\n// Post shows the given desktop notification\nfunc (app *App) Post(n Notification) {\n\tvar cimg *C.gallium_nsimage_t\n\tif n.Image != nil {\n\t\tcimg = n.Image.c\n\t}\n\tcn := C.NSUserNotification_New(\n\t\tC.CString(n.Title),\n\t\tC.CString(n.Subtitle),\n\t\tC.CString(n.InformativeText),\n\t\tcimg,\n\t\tC.CString(n.Identifier),\n\t\tlen(n.ActionButtonTitle) > 0,\n\t\tlen(n.OtherButtonTitle) > 0,\n\t\tC.CString(n.ActionButtonTitle),\n\t\tC.CString(n.OtherButtonTitle))\n\n\tC.NSUserNotificationCenter_DeliverNotification(cn)\n}\n\n// BundleInfo looks up an entry in the Info.plist for the current bundle.\nfunc BundleInfo(key string) string {\n\tcstr := C.MainBundle_ObjectForKey(C.CString(key))\n\tif cstr == nil {\n\t\treturn \"\"\n\t}\n\tdefer C.free(unsafe.Pointer(cstr))\n\treturn C.GoString(cstr)\n}\n\n// RunApplication is for debugging only. It allows creation of menus and\n// desktop notifications without firing up any parts of chromium. It will\n// be removed before the 1.0 release.\nfunc RunApplication() {\n\tC.NSApplication_Run()\n}\n"
        },
        {
          "name": "dist",
          "type": "tree",
          "content": null
        },
        {
          "name": "examples",
          "type": "tree",
          "content": null
        },
        {
          "name": "globalshortcut.go",
          "type": "blob",
          "size": 2.99609375,
          "content": "package gallium\n\n/*\n#cgo CFLAGS: -mmacosx-version-min=10.8\n#cgo CFLAGS: -DGALLIUM_DIR=${SRCDIR}\n#cgo CFLAGS: -Idist/include\n\n#include <stdlib.h>\n#include \"gallium/globalshortcut.h\"\n\nextern void cgo_onGlobalShortcut(int64_t);\n\n// This is a wrapper around NSMenu_AddMenuItem that adds the function pointer\n// argument, since this does not seem to be possible from Go directly.\nstatic inline void helper_AddGlobalShortcut(\n\tint ID,\n\tconst char* shortcutKey,\n\tgallium_modifier_t shortcutModifier) {\n\n\tGalliumAddGlobalShortcut(\n\t\tID,\n\t\tshortcutKey,\n\t\tshortcutModifier,\n\t\t&cgo_onGlobalShortcut);\n}\n*/\nimport \"C\"\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"log\"\n\t\"strings\"\n)\n\nvar (\n\tnextID   int\n\thandlers = make(map[int]func())\n)\n\n//export cgo_onGlobalShortcut\nfunc cgo_onGlobalShortcut(id int) {\n\tfmt.Println(\"cgo_onGlobalShortcut received ID\", id)\n\tif handler, found := handlers[id]; found {\n\t\thandler()\n\t} else {\n\t\tlog.Println(\"no handler for global shortcut ID\", id)\n\t}\n}\n\n// Modifier represents zero or more modifier keys (control, shift, option, etc)\ntype Modifier int\n\n// these must be kept in sync with the gallium_modifier_t enum in cocoa.h\nconst (\n\tModifierCmd Modifier = 1 << iota\n\tModifierCtrl\n\tModifierCmdOrCtrl\n\tModifierAltOrOption\n\tModifierFn\n\tModifierShift\n)\n\n// KeyCombination represents a key together with zero or more modifiers. It\n// is used to set up keyboard shortcuts.\ntype KeyCombination struct {\n\tKey       string\n\tModifiers Modifier\n}\n\nvar (\n\terrEmptyKey      = errors.New(\"empty key\")\n\terrEmptyShortcut = errors.New(\"empty shortcut\")\n)\n\n// ParseKeys parses a key combination specified as a string like \"cmd shift a\".\nfunc ParseKeys(s string) (KeyCombination, error) {\n\t// for backwards compatibility split on both \"+\" and \" \"\n\tparts := strings.Split(s, \" \")\n\tif strings.Contains(s, \"+\") {\n\t\tparts = strings.Split(s, \"+\")\n\t}\n\tif len(parts) == 0 {\n\t\treturn KeyCombination{}, errEmptyShortcut\n\t}\n\tvar keys KeyCombination\n\tkeys.Key = parts[len(parts)-1]\n\tif len(keys.Key) == 0 {\n\t\treturn KeyCombination{}, errEmptyKey\n\t}\n\tfor _, part := range parts[:len(parts)-1] {\n\t\tswitch strings.ToLower(part) {\n\t\tcase \"cmd\":\n\t\t\tkeys.Modifiers |= ModifierCmd\n\t\tcase \"ctrl\":\n\t\t\tkeys.Modifiers |= ModifierCtrl\n\t\tcase \"cmdctrl\":\n\t\t\tkeys.Modifiers |= ModifierCmdOrCtrl\n\t\tcase \"alt\":\n\t\t\tkeys.Modifiers |= ModifierAltOrOption\n\t\tcase \"option\":\n\t\t\tkeys.Modifiers |= ModifierAltOrOption\n\t\tcase \"fn\":\n\t\t\tkeys.Modifiers |= ModifierFn\n\t\tcase \"shift\":\n\t\t\tkeys.Modifiers |= ModifierShift\n\t\tdefault:\n\t\t\treturn KeyCombination{}, fmt.Errorf(\"unknown modifier: %s\", part)\n\t\t}\n\t}\n\treturn keys, nil\n}\n\n// MustParseKeys is like ParseKeys but panics on error\nfunc MustParseKeys(s string) KeyCombination {\n\tkeys, err := ParseKeys(s)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\treturn keys\n}\n\n// AddGlobalShortcut calls the handler whenever the key combination is pressed\n// in any application.\nfunc AddGlobalShortcut(keys KeyCombination, handler func()) {\n\tid := nextID\n\tnextID++\n\thandlers[id] = handler\n\n\tC.helper_AddGlobalShortcut(\n\t\tC.int(id),\n\t\tC.CString(keys.Key),\n\t\tC.gallium_modifier_t(keys.Modifiers))\n}\n"
        },
        {
          "name": "linkflags.go",
          "type": "blob",
          "size": 0.279296875,
          "content": "package gallium\n\n/*\n#cgo LDFLAGS: -F${SRCDIR}/dist\n#cgo LDFLAGS: -framework Gallium\n#cgo LDFLAGS: -Wl,-rpath,@executable_path/../Frameworks\n#cgo LDFLAGS: -Wl,-rpath,@loader_path/../Frameworks\n#cgo LDFLAGS: -Wl,-rpath,${SRCDIR}/dist\n#cgo LDFLAGS: -mmacosx-version-min=10.8\n*/\nimport \"C\"\n"
        },
        {
          "name": "rect.go",
          "type": "blob",
          "size": 0.5673828125,
          "content": "package gallium\n\n/*\n#cgo CFLAGS: -mmacosx-version-min=10.8\n#cgo CFLAGS: -DGALLIUM_DIR=${SRCDIR}\n#cgo CFLAGS: -Idist/include\n\n#include <stdlib.h>\n#include \"gallium/core.h\"\n*/\nimport \"C\"\n\n// Rect represents a rectangular region on the screen\ntype Rect struct {\n\tWidth  int // Width in pixels\n\tHeight int // Height in pixels\n\tLeft   int // Left is offset from left in pixel\n\tBottom int // Left is offset from top in pixels\n}\n\nfunc rectFromC(c C.gallium_rect_t) Rect {\n\treturn Rect{\n\t\tWidth:  int(c.width),\n\t\tHeight: int(c.height),\n\t\tLeft:   int(c.left),\n\t\tBottom: int(c.bottom),\n\t}\n}\n"
        },
        {
          "name": "redirect.go",
          "type": "blob",
          "size": 1.31640625,
          "content": "package gallium\n\nimport (\n\t\"os\"\n\t\"syscall\"\n)\n\n// RedirectStdoutStderr overwrites the stdout and stderr streams with a file\n// descriptor that writes to the given path. This is done with os.Dup2,\n// meaning that even C functions that write to stdout or stderr will be\n// redirected to the file.\nfunc RedirectStdoutStderr(path string) (*os.File, error) {\n\treturn redirect(path, os.Stdout.Fd(), os.Stderr.Fd())\n}\n\n// RedirectStdout overwrites the stdout streams with a file\n// descriptor that writes to the given path. This is done with os.Dup2,\n// meaning that even C functions that write to stdout will be\n// redirected to the file.\nfunc RedirectStdout(path string) (*os.File, error) {\n\treturn redirect(path, os.Stdout.Fd())\n}\n\n// RedirectStderr overwrites the stderr streams with a file\n// descriptor that writes to the given path. This is done with os.Dup2,\n// meaning that even C functions that write to stderr will be\n// redirected to the file.\nfunc RedirectStderr(path string) (*os.File, error) {\n\treturn redirect(path, os.Stderr.Fd())\n}\n\nfunc redirect(path string, fds ...uintptr) (*os.File, error) {\n\tf, err := os.OpenFile(path, os.O_WRONLY|os.O_APPEND|os.O_CREATE, 0777)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tfor _, fd := range fds {\n\t\terr = syscall.Dup2(int(f.Fd()), int(fd))\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\treturn f, nil\n}\n"
        },
        {
          "name": "screen.go",
          "type": "blob",
          "size": 1.7802734375,
          "content": "package gallium\n\n/*\n#cgo CFLAGS: -mmacosx-version-min=10.8\n#cgo CFLAGS: -DGALLIUM_DIR=${SRCDIR}\n#cgo CFLAGS: -Idist/include\n\n#include <stdlib.h>\n#include \"gallium/screen.h\"\n*/\nimport \"C\"\nimport \"fmt\"\n\n// A screen represents a rectangular display, normally corresponding to a\n// physical display. \"Device coordinates\" means a position on a screen\n// measured from (0, 0) at the bottom left of the device. \"Global coordinates\"\n// means the coordinate system in which each of the screens are positioned\n// relative to each other. Global and device coordinates almost always have\n// the same scale factor. It is possible for screens to overlap in global\n// coordinates (such as when mirroring a display.)\ntype Screen struct {\n\tShape        Rect // the size and position of this screen in global coords\n\tUsable       Rect // excludes the menubar and dock\n\tBitsPerPixel int  // color depth of this screen (total of all color components)\n\tID           int  // unique identifier for this screen\n}\n\nfunc screenFromC(c *C.gallium_screen_t) Screen {\n\treturn Screen{\n\t\tShape:        rectFromC(C.GalliumScreenShape(c)),\n\t\tUsable:       rectFromC(C.GalliumScreenUsable(c)),\n\t\tBitsPerPixel: int(C.GalliumScreenBitsPerPixel(c)),\n\t\tID:           int(C.GalliumScreenID(c)),\n\t}\n}\n\n// Screens gets a list of available screens\nfunc Screens() []Screen {\n\tvar screens []Screen\n\tn := int(C.GalliumScreenCount())\n\tfor i := 0; i < n; i++ {\n\t\tc := C.GalliumScreen(C.int(i))\n\t\tif c == nil {\n\t\t\tpanic(fmt.Sprintf(\"GalliumScreen returned nil for index %d\", i))\n\t\t}\n\t\tscreens = append(screens, screenFromC(c))\n\t}\n\treturn screens\n}\n\n// FocusedScreen gets the screen containing the currently focused window\nfunc FocusedScreen() Screen {\n\tc := C.GalliumFocusedScreen()\n\tif c == nil {\n\t\tpanic(\"GalliumFocusedScreen returned nil\")\n\t}\n\treturn screenFromC(c)\n}\n"
        },
        {
          "name": "vendor",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}