{
  "metadata": {
    "timestamp": 1736566822812,
    "page": 390,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjM5MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "cortesi/devd",
      "stars": 3446,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".gitattributes",
          "type": "blob",
          "size": 0.0185546875,
          "content": "rice-box.go binary\n"
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.03125,
          "content": "tmp\n./devd\n./devd.exe\n.DS_Store\n"
        },
        {
          "name": ".travis.yml",
          "type": "blob",
          "size": 0.287109375,
          "content": "language: go\n\ngo:\n    - 1.12.x\n\nmatrix:\n    include:\n        - os: linux\n        - os: windows\n        - os: osx\n          osx_image: xcode11\n\ninstall:\n    - go get -t -v ./...\n    - go install ./cmd/devd\n\nscript:\n    - go test -v -race ./...\n\nnotifications:\n    email:\n        - aldo@corte.si\n"
        },
        {
          "name": "CHANGELOG.md",
          "type": "blob",
          "size": 3.818359375,
          "content": "# Unreleased\n\n* Improves CORS support. Allows connections with credentials that were\n  previously refused. See\n  <https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS/Errors/CORSNotSupportingCredentials>\n\n# v0.9: 21 January 2019\n\n* Fix live reload issues on Linux (Delyan Angelov)\n* Only inject livereload content if content type is text/html (Mattias Wadman)\n* Fix treatment of X-Forwarded-Proto (Marvin Frick)\n* Dependency updates and test improvements\n\n\n# v0.8: 8 January 2018\n\n* Improvements in file change monitoring, fixing a number of bugs and\n  reliability issues, and improving the way we handle symlinks (via the\n  moddwatch repo).\n* Fix handling of the X-Forwarded-Proto header in reverse proxy (thanks to Bernd\n  Haug <bernd.haug@xaidat.com>).\n* Various other minor fixes and documentation updates.\n\n\n# v0.7: 8 December 2016\n\n* Add the --notfound flag, which specifies over-rides when the static file sever can't find a file. This is useful for single-page JS app development.\n* Improved directory listings, nicer 404 pages.\n* X-Forwarded-Proto is now added to reverse proxied requests.\n\n\n# v0.6: 24 September 2016\n\n* Fix support for MacOS Sierra. This just involved a recompile to fix a compatibility issue between older versions of the Go toolchain and Sierra.\n* Fix an issue that caused a slash to be added to some URLs forwarded to reverse proxied hosts.\n* livereload: endpoints now run on all domains, fixing livereload on subdomain endpoints.\n* livereload: fix support  of IE11 (thanks thomas@houseofcode.io).\n* Sort directory list entries (thanks @Schnouki).\n* Improved route parsing and clarity - (thanks to @aellerton).\n\n\n# v0.5: 8 April 2016\n\n* Increase the size of the initial file chunk we inspect or a </head> tag for\nlivereload injection. Fixes some rare cases where pages with a lot of header\ndata didn't trigger livereload.\n* Request that upstream servers do not return compressed data, allowing\nlivereload script injection. (thanks Thomas B Homburg <thomas@homburg.dk>)\n* Bugfix: Fix recursive file monitoring for static routes\n\n\n# v0.4: 12 February 2016\n\n* Add support for [modd](https://github.com/cortesi/modd), with the -m flag.\n* Add -X flag to set Access-Control-Allow-Origin: * on all responses, allowing\n  the use of multiple .devd.io domains in testing.\n* Add -L flag, which turns on livereload but doesn't trigger on modification,\n  allowing livereload to be driven by external tools.\n* Add -C flag to force colour output, even if we're not attachd to a terminal.\n* Add -t flag to disable timestamps.\n* Silence console errors due to a stupid long-standing Firefox bug.\n* Fix throttling of data upload.\n* Improve display of content sizes.\n* Add distributions for OpenBSD and NetBSD.\n\n\n# v0.3: 12 November 2015\n\n* -s (--tls) Generate a self-signed certificate, and enable TLS. The cert\n  bundle is stored in ~/.devd.cert\n* Add the X-Forwarded-Host header to reverse proxied traffic.\n* Disable upstream cert validation for reverse proxied traffic. This makes\n  using self-signed certs for development easy. Devd shoudn't be used in\n  contexts where this might pose a security risk.\n* Bugfix: make CSS livereload work in Firefox\n* Bugfix: make sure the Host header and SNI host matches for reverse proxied\n  traffic.\n\n\n# v0.2\n\n* -x (--exclude) flag to exclude files from livereload.\n* -P (--password) flag for quick HTTP Basic password protection.\n* -q (--quiet) flag to suppress all output from devd.\n* Humanize file sizes in console logs.\n* Improve directory indexes - better formatting, they now also livereload.\n* Devd's built-in livereload URLs are now less likely to clash with user URLs.\n* Internal 404 pages are now included in logs, timing measurement, and\n  filtering.\n* Improved heuristics for livereload file change detection. We now handle\n  things like transient files created by editors better.\n* A Linux ARM build will now be distributed with each release.\n"
        },
        {
          "name": "CONTRIBUTORS",
          "type": "blob",
          "size": 0.19921875,
          "content": "    40\tAldo Cortesi <aldo@nullcube.com>\n     6\tAldo Cortesi <aldo@corte.si>\n     3\tBarret Rennie <barret@brennie.ca>\n     1\tBill Mill <bill@billmill.org>\n     1\tJudson Mitchell <judsonmitchell@gmail.com>\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.0693359375,
          "content": "The MIT License (MIT)\n\nCopyright (c) 2015 Aldo Cortesi <aldo@corte.si>\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 11,
          "content": "\n[![Travis Build Status](https://travis-ci.org/cortesi/devd.svg?branch=master)](https://travis-ci.org/cortesi/devd)\n\n\n\n# devd: a local webserver for developers\n\n![screenshot](docs/devd-terminal.png \"devd in action\")\n\n# Install\n\nGo to the [releases page](https://github.com/cortesi/devd/releases/latest), download the package for your OS, and copy the binary to somewhere on your PATH.\n\nIf you have a working Go installation, you can also say\n\n    go get github.com/cortesi/devd/cmd/devd\n\n# Quick start\n\nServe the current directory, open it in the browser (**-o**), and livereload when files change (**-l**):\n\n```bash\ndevd -ol .\n```\n\nReverse proxy to http://localhost:8080, and livereload when any file in the **src** directory changes:\n\n```bash\ndevd -w ./src http://localhost:8080\n```\n\n\n# Using devd with modd\n\n[Modd](https://github.com/cortesi/modd) is devd's sister project - a dev tool\nthat runs commands and manages daemons in response to filesystem changes. Devd\ncan be used with modd to rebuild a project and reload the browser when\nfilesystem changes are detected.\n\nHere's a quick example of a simple *modd.conf* file to illustrate.\n\n```\nsrc/** {\n    prep: render ./src ./rendered\n}\n\nrendered/*.css ./rendered/*.html {\n    daemon: devd -m ./rendered\n}\n```\n\nThe first block runs the *render* script whenever anything in the *src*\ndirectory changes. The second block starts a devd instance, and triggers\nlivereload with a signal whenever a .css or .html file in the *rendered*\ndirectory changes.\n\nSee the [modd](https://github.com/cortesi/modd) project page for details.\n\n\n# Features\n\n### Cross-platform and self-contained\n\nDevd is a single statically compiled binary with no external dependencies, and\nis released for macOS, Linux and Windows. Don't want to install Node or Python\nin that light-weight Docker instance you're hacking in? Just copy over the devd\nbinary and be done with it.\n\n\n### Designed for the terminal\n\nThis means no config file, no daemonization, and logs that are designed to be\nread in the terminal by a developer. Logs are colorized and log entries span\nmultiple lines. Devd's logs are detailed, warn about corner cases that other\ndaemons ignore, and can optionally include things like detailed timing\ninformation and full headers.\n\n\n### Convenient\n\nTo make quickly firing up an instance as simple as possible, devd automatically\nchooses an open port to run on (unless it's specified), and can open a browser\nwindow pointing to the daemon root for you (the **-o** flag in the example\nabove). It also has utility features like the **-s** flag, which auto-generates\na self-signed certificate for devd, stores it in ~/.devd.certs and enables TLS\nall in one step.\n\n\n### Livereload\n\nWhen livereload is enabled, devd injects a small script into HTML pages, just\nbefore the closing *head* tag. The script listens for change notifications over\na websocket connection, and reloads resources as needed. No browser addon is\nrequired, and livereload works even for reverse proxied apps. If only changes\nto CSS files are seen, devd will only reload external CSS resources, otherwise\na full page reload is done. This serves the current directory with livereload\nenabled:\n\n<pre class=\"terminal\">devd -l .</pre>\n\nYou can also trigger livereload for files that are not being served, letting\nyou reload reverse proxied applications when source files change. So, this\ncommand watches the *src* directory tree, and reverse proxies to a locally\nrunning application:\n\n<pre class=\"terminal\">devd -w ./src http://localhost:8888</pre>\n\nThe **-x** flag excludes files from triggering livereload based on a [pattern\nspecification](#excluding-files-from-livereload). The following command\ndisables livereload for all files with the \".less\" extension:\n\n<pre class=\"terminal\">devd -x \"**.less\" -l .</pre>\n\nWhen livereload is enabled (with the **-L**, **-l** or **-w** flags), devd\nresponds to a SIGHUP by issuing a livereload notice to all connected browsers.\nThis allows external tools, like devd's sister project **modd**, to trigger\nlivereload. If livereload is not enabled, SIGHUP causes the daemon to exit.\n\nThe closing *head* tag must be found within the first 30kb of the remote file,\notherwise livereload is disabled for the file.\n\n\n### Reverse proxy + static file server + flexible routing\n\nModern apps tend to be collections of web servers, and devd caters for this\nwith flexible reverse proxying. You can use devd to overlay a set of services\non a single domain, add livereload to services that don't natively support it,\nadd throttling and latency simulation to existing services, and so forth.\n\nHere's a more complicated example showing how all this ties together - it\noverlays two applications and a tree of static files. Livereload is enabled for\nthe static files (**-l**) and also triggered whenever source files for reverse\nproxied apps change (**-w**):\n\n<pre class=\"terminal\">\ndevd -l \\\n-w ./src/ \\\n/=http://localhost:8888 \\\n/api/=http://localhost:8889 \\\n/static/=./assets\n</pre>\n\nThe [route specification syntax](#routes) is compact but powerful enough to cater for most use cases.\n\n### Light-weight virtual hosting\n\nDevd uses a dedicated domain - **devd.io** - to do simple virtual hosting. This\ndomain and all its subdomains resolve to 127.0.0.1, which we use to set up\nvirtual hosting without any changes to */etc/hosts* or other local\nconfiguration. Route specifications that don't start with a leading **/** are\ntaken to be subdomains of **devd.io**. So, the following command serves a\nstatic site from devd.io, and reverse proxies a locally running app on\napi.devd.io:\n\n<pre class=\"terminal\">\ndevd ./static api=http://localhost:8888\n</pre>\n\n\n### Latency and bandwidth simulation\n\nWant to know what it's like to use your fancy 5mb HTML5 app from a mobile phone\nin Botswana? Look up the bandwidth and latency\n[here](http://www.cisco.com/c/en/us/solutions/collateral/service-provider/global-cloud-index-gci/CloudIndex_Supplement.html),\nand invoke devd like so (making sure to convert from kilobits per second to\nkilobytes per second and account for the location of your server):\n\n<pre class=\"terminal\">devd -d 114 -u 51 -n 275 .</pre>\n\nDevd tries to be reasonably accurate in simulating bandwidth and latency - it\nuses a token bucket implementation for throttling, properly handles concurrent\nrequests, and chunks traffic up so data flow is smooth.\n\n\n## Routes\n\nThe devd command takes one or more route specifications as arguments. Routes\nhave the basic format **root=endpoint**. Roots can be fixed, like\n\"/favicon.ico\", or subtrees, like \"/images/\" (note the trailing slash).\nEndpoints can be filesystem paths or URLs to upstream HTTP servers.\n\nHere's a route that serves the directory *./static* under */assets* on the server:\n\n```\n/assets/=./static\n```\n\nTo use a **devd.io** subdomain (which will resolve to 127.0.0.1), just add it\nto the the front of the root specification. We recognize subdomains by the fact\nthat they don't start with a leading **/**. So, this route serves the\n**/static** directory under **static.devd.io/assets**:\n\n```\nstatic/assets=./static\n```\n\nReverse proxy specifications are similar, but the endpoint specification is a\nURL. The following serves a local URL from the root **app.devd.io/login**:\n\n```\napp/login=http://localhost:8888\n```\n\nIf the **root** specification is omitted, it is assumed to be \"/\", i.e. a\npattern matching all paths. So, a simple directory specification serves the\ndirectory tree directly under **devd.io**:\n\n```\ndevd ./static\n```\n\nSimilarly, a simple reverse proxy can be started like this:\n\n```\ndevd http://localhost:8888\n```\n\nThere is also a shortcut for reverse proxying to localhost:\n\n```\ndevd :8888\n\n```\n\n### Serving default content for files not found\n\nThe **--notfound** flag can be passed multiple times, and specifies a set of\nroutes that are consulted when a requested file is not found by the static file\nserver. The basic syntax is **root=path**, where **root** has the same\nsemantics as route specification. As with routes, the **root=** component is\noptional, and if absent is taken to be equal to **/**. The **path** is always\nrelative to the static directory being served. When it starts with a leading\nslash (**/**), devd will only look for a replacement file in a single location\nrelative to the root of the tree. Otherwise, it will search for a matching file\nby joining the specified **path** with all path components up to the root of\nthe tree.\n\nLet's illustrate this with an example. Say we have a */static* directory as\nfollows:\n\n```\n./static\n├── bar\n│   └── index.html\n└── index.html\n```\n\nWe can specify that devd should look for an *index.html* anywhere on the path\nto the root of the static tree as follows:\n\n```\ndevd --notfound index.html  /static\n```\n\nNow, the following happens:\n\n* A request for */nonexistent.html* returns the contents of */index.html*\n* A request for */bar/nonexistent.html* returns the contents of */bar/index.html*\n* A request for */foo/bar/voing/index.html* returns the contents of */index.html*\n\nWe could instead specify an absolute path in the route, in which case the\ncontents of */index.html* would be returned for all the examples above:\n\n```\ndevd --notfound /index.html  /static\n```\n\nDevd won't serve an over-ride page if the expected type of the incoming request\ndoesn't match that of the override specification. We do this by looking at the\nfile extension and expected MIME types of the over-ride and request, defaulting\nto *text/html* if the type couldn't be positively established. This prevents\nissues where, for instance, an HTML over-ride page might be served where images\nare expected.\n\n\n## Excluding files from livereload\n\nThe **-x** flag supports the following terms:\n\nTerm          | Meaning\n------------- | -------\n`*`           | matches any sequence of non-path-separators\n`**`          | matches any sequence of characters, including path separators\n`?`           | matches any single non-path-separator character\n`[class]`     | matches any single non-path-separator character against a class of characters\n`{alt1,...}`  | matches a sequence of characters if one of the comma-separated alternatives matches\n\nAny character with a special meaning can be escaped with a backslash (`\\`). Character classes support the following:\n\nClass      | Meaning\n---------- | -------\n`[abc]`    | matches any single character within the set\n`[a-z]`    | matches any single character in the range\n`[^class]` | matches any single character which does *not* match the class\n\n\n## About reverse proxying\n\nDevd does not validate upstream SSL certificates when reverse proxying. For our\nuse case, development servers will usually be running locally, often with\nself-signed certificates for testing. You shouldn't use devd in cases where\nupstream cert validation matters.\n\nThe *X-Forwarded-Host* and *X-Forwarded-Proto* headers are set to the devd\nserver's address and protocol for reverse proxied traffic. You might need to\nenable support for this in your application for redirects and the like to work\ncorrectly.\n\n\n# Development\n\nThe scripts used to build this package for distribution can be found\n[here](https://github.com/cortesi/godist). External packages are vendored using\n[dep](https://github.com/golang/dep).\n"
        },
        {
          "name": "certgen.go",
          "type": "blob",
          "size": 1.8583984375,
          "content": "package devd\n\nimport (\n\t\"crypto/rand\"\n\t\"crypto/rsa\"\n\t\"crypto/x509\"\n\t\"crypto/x509/pkix\"\n\t\"encoding/pem\"\n\t\"fmt\"\n\t\"math/big\"\n\t\"os\"\n\t\"time\"\n)\n\n// GenerateCert generates a self-signed certificate bundle for devd\nfunc GenerateCert(dst string) error {\n\tpriv, err := rsa.GenerateKey(rand.Reader, 2048)\n\tif err != nil {\n\t\treturn err\n\t}\n\tnotBefore := time.Now()\n\tnotAfter := notBefore.Add(365 * 24 * time.Hour * 3)\n\n\tserialNumberLimit := new(big.Int).Lsh(big.NewInt(1), 128)\n\tserialNumber, err := rand.Int(rand.Reader, serialNumberLimit)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\ttemplate := x509.Certificate{\n\t\tSerialNumber: serialNumber,\n\t\tSubject: pkix.Name{\n\t\t\tOrganization: []string{\"Acme Co\"},\n\t\t},\n\t\tNotBefore: notBefore,\n\t\tNotAfter:  notAfter,\n\n\t\tKeyUsage:              x509.KeyUsageKeyEncipherment | x509.KeyUsageDigitalSignature,\n\t\tExtKeyUsage:           []x509.ExtKeyUsage{x509.ExtKeyUsageServerAuth},\n\t\tBasicConstraintsValid: true,\n\t}\n\ttemplate.DNSNames = append(template.DNSNames, \"devd.io\")\n\ttemplate.DNSNames = append(template.DNSNames, \"*.devd.io\")\n\n\tderBytes, err := x509.CreateCertificate(\n\t\trand.Reader,\n\t\t&template,\n\t\t&template,\n\t\t&priv.PublicKey,\n\t\tpriv,\n\t)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"Could not create cert: %s\", err)\n\t}\n\n\tcertOut, err := os.Create(dst)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"Could not open %s for writing: %s\", dst, err)\n\t}\n\terr = pem.Encode(certOut, &pem.Block{Type: \"CERTIFICATE\", Bytes: derBytes})\n\tif err != nil {\n\t\treturn err\n\t}\n\n\terr = certOut.Close()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tkeyOut, err := os.OpenFile(dst, os.O_WRONLY|os.O_APPEND, 0600)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"Could not open %s for writing: %s\", dst, err)\n\t}\n\terr = pem.Encode(\n\t\tkeyOut,\n\t\t&pem.Block{\n\t\t\tType:  \"RSA PRIVATE KEY\",\n\t\t\tBytes: x509.MarshalPKCS1PrivateKey(priv),\n\t\t},\n\t)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\terr = keyOut.Close()\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}\n"
        },
        {
          "name": "certgen_test.go",
          "type": "blob",
          "size": 0.376953125,
          "content": "package devd\n\nimport (\n\t\"io/ioutil\"\n\t\"os\"\n\t\"path\"\n\t\"testing\"\n)\n\nfunc TestGenerateCert(t *testing.T) {\n\td, err := ioutil.TempDir(\"\", \"devdtest\")\n\tif err != nil {\n\t\tt.Error(err)\n\t\treturn\n\t}\n\tdefer func() { _ = os.Remove(d) }()\n\tdst := path.Join(d, \"certbundle\")\n\terr = GenerateCert(dst)\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n\n\t_, err = getTLSConfig(dst)\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n}\n"
        },
        {
          "name": "cmd",
          "type": "tree",
          "content": null
        },
        {
          "name": "common_test.go",
          "type": "blob",
          "size": 0.8134765625,
          "content": "package devd\n\nimport (\n\t\"net/http\"\n\t\"net/http/httptest\"\n\t\"net/url\"\n\t\"strings\"\n\t\"testing\"\n)\n\ntype handlerTester struct {\n\tt *testing.T\n\th http.Handler\n}\n\n// Request makes a test request\nfunc (ht *handlerTester) Request(method string, url string, params url.Values) *httptest.ResponseRecorder {\n\treq, err := http.NewRequest(method, url, strings.NewReader(params.Encode()))\n\tif err != nil {\n\t\tht.t.Errorf(\"%v\", err)\n\t}\n\tif params != nil {\n\t\treq.Header.Set(\n\t\t\t\"Content-Type\",\n\t\t\t\"application/x-www-form-urlencoded; param=value\",\n\t\t)\n\t}\n\tw := httptest.NewRecorder()\n\tht.h.ServeHTTP(w, req)\n\treturn w\n}\n\n// AssertCode asserts that the HTTP return code matches an expected value\nfunc AssertCode(t *testing.T, resp *httptest.ResponseRecorder, code int) {\n\tif resp.Code != code {\n\t\tt.Errorf(\"Expected code %d, got %d\", code, resp.Code)\n\t}\n}\n"
        },
        {
          "name": "docs",
          "type": "tree",
          "content": null
        },
        {
          "name": "fileserver",
          "type": "tree",
          "content": null
        },
        {
          "name": "go.mod",
          "type": "blob",
          "size": 1.498046875,
          "content": "module github.com/cortesi/devd\n\ngo 1.12\n\nrequire (\n\tgithub.com/GeertJohan/go.rice v1.0.0\n\tgithub.com/alecthomas/template v0.0.0-20190718012654-fb15b899a751\n\tgithub.com/alecthomas/units v0.0.0-20190924025748-f65c72e2690d\n\tgithub.com/bmatcuk/doublestar v1.3.0\n\tgithub.com/cortesi/moddwatch v0.0.0-20190809041828-239a95c12d84\n\tgithub.com/cortesi/termlog v0.0.0-20190809035425-7871d363854c\n\tgithub.com/daaku/go.zipexe v1.0.1\n\tgithub.com/dustin/go-humanize v1.0.0\n\tgithub.com/fatih/color v1.9.0\n\tgithub.com/goji/httpauth v0.0.0-20160601135302-2da839ab0f4d\n\tgithub.com/google/go-cmp v0.4.0 // indirect\n\tgithub.com/gorilla/websocket v1.4.2\n\tgithub.com/juju/ratelimit v1.0.1\n\tgithub.com/kardianos/osext v0.0.0-20190222173326-2bc1f35cddc0\n\tgithub.com/kr/text v0.2.0 // indirect\n\tgithub.com/mattn/go-colorable v0.1.6\n\tgithub.com/mattn/go-isatty v0.0.12\n\tgithub.com/mitchellh/go-homedir v1.1.0\n\tgithub.com/niemeyer/pretty v0.0.0-20200227124842-a10e7caefd8e // indirect\n\tgithub.com/nkovacs/streamquote v1.0.0 // indirect\n\tgithub.com/rjeczalik/notify v0.0.0-20181126183243-629144ba06a1\n\tgithub.com/stretchr/testify v1.5.1 // indirect\n\tgithub.com/toqueteos/webbrowser v1.2.0\n\tgolang.org/x/crypto v0.0.0-20200423211502-4bdfaf469ed5\n\tgolang.org/x/net v0.0.0-20200425230154-ff2c4b7c35a0\n\tgolang.org/x/sys v0.0.0-20200420163511-1957bb5e6d1f\n\tgolang.org/x/tools v0.0.0-20190815232600-256244171580 // indirect\n\tgopkg.in/alecthomas/kingpin.v2 v2.2.6\n\tgopkg.in/check.v1 v1.0.0-20200227125254-8fa46927fb4f // indirect\n\tgopkg.in/yaml.v2 v2.2.8 // indirect\n)\n"
        },
        {
          "name": "go.sum",
          "type": "blob",
          "size": 15.109375,
          "content": "github.com/GeertJohan/go.incremental v1.0.0/go.mod h1:6fAjUhbVuX1KcMD3c8TEgVUqmo4seqhv0i0kdATSkM0=\ngithub.com/GeertJohan/go.rice v0.0.0-20170420135705-c02ca9a983da h1:UVU3a9pRUyLdnBtn60WjRl0s4SEyJc2ChCY56OAR6wI=\ngithub.com/GeertJohan/go.rice v0.0.0-20170420135705-c02ca9a983da/go.mod h1:DgrzXonpdQbfN3uYaGz1EG4Sbhyum/MMIn6Cphlh2bw=\ngithub.com/GeertJohan/go.rice v1.0.0 h1:KkI6O9uMaQU3VEKaj01ulavtF7o1fWT7+pk/4voiMLQ=\ngithub.com/GeertJohan/go.rice v1.0.0/go.mod h1:eH6gbSOAUv07dQuZVnBmoDP8mgsM1rtixis4Tib9if0=\ngithub.com/akavel/rsrc v0.8.0/go.mod h1:uLoCtb9J+EyAqh+26kdrTgmzRBFPGOolLWKpdxkKq+c=\ngithub.com/alecthomas/template v0.0.0-20160405071501-a0175ee3bccc h1:cAKDfWh5VpdgMhJosfJnn5/FoN2SRZ4p7fJNX58YPaU=\ngithub.com/alecthomas/template v0.0.0-20160405071501-a0175ee3bccc/go.mod h1:LOuyumcjzFXgccqObfd/Ljyb9UuFJ6TxHnclSeseNhc=\ngithub.com/alecthomas/template v0.0.0-20190718012654-fb15b899a751 h1:JYp7IbQjafoB+tBA3gMyHYHrpOtNuDiK/uB5uXxq5wM=\ngithub.com/alecthomas/template v0.0.0-20190718012654-fb15b899a751/go.mod h1:LOuyumcjzFXgccqObfd/Ljyb9UuFJ6TxHnclSeseNhc=\ngithub.com/alecthomas/units v0.0.0-20151022065526-2efee857e7cf h1:qet1QNfXsQxTZqLG4oE62mJzwPIB8+Tee4RNCL9ulrY=\ngithub.com/alecthomas/units v0.0.0-20151022065526-2efee857e7cf/go.mod h1:ybxpYRFXyAe+OPACYpWeL0wqObRcbAqCMya13uyzqw0=\ngithub.com/alecthomas/units v0.0.0-20190717042225-c3de453c63f4 h1:Hs82Z41s6SdL1CELW+XaDYmOH4hkBN4/N9og/AsOv7E=\ngithub.com/alecthomas/units v0.0.0-20190717042225-c3de453c63f4/go.mod h1:ybxpYRFXyAe+OPACYpWeL0wqObRcbAqCMya13uyzqw0=\ngithub.com/alecthomas/units v0.0.0-20190924025748-f65c72e2690d h1:UQZhZ2O0vMHr2cI+DC1Mbh0TJxzA3RcLoMsFw+aXw7E=\ngithub.com/alecthomas/units v0.0.0-20190924025748-f65c72e2690d/go.mod h1:rBZYJk541a8SKzHPHnH3zbiI+7dagKZ0cgpgrD7Fyho=\ngithub.com/bmatcuk/doublestar v1.1.1 h1:YroD6BJCZBYx06yYFEWvUuKVWQn3vLLQAVmDmvTSaiQ=\ngithub.com/bmatcuk/doublestar v1.1.1/go.mod h1:UD6OnuiIn0yFxxA2le/rnRU1G4RaI4UvFv1sNto9p6w=\ngithub.com/bmatcuk/doublestar v1.1.5 h1:2bNwBOmhyFEFcoB3tGvTD5xanq+4kyOZlB8wFYbMjkk=\ngithub.com/bmatcuk/doublestar v1.1.5/go.mod h1:wiQtGV+rzVYxB7WIlirSN++5HPtPlXEo9MEoZQC/PmE=\ngithub.com/bmatcuk/doublestar v1.3.0 h1:1jLE2y0VpSrOn/QR9G4f2RmrCtkM3AuATcWradjHUvM=\ngithub.com/bmatcuk/doublestar v1.3.0/go.mod h1:wiQtGV+rzVYxB7WIlirSN++5HPtPlXEo9MEoZQC/PmE=\ngithub.com/cortesi/moddwatch v0.0.0-20181223233523-0a1e0881aa88 h1:Kxz5+1NaF2eZYpFEVM2VScumPI18VetEGySRLAmhnDc=\ngithub.com/cortesi/moddwatch v0.0.0-20181223233523-0a1e0881aa88/go.mod h1:UXc2CZTlqaY7wvJBbpDaAsRNU0Wv/D/XbN9Pcam1kkU=\ngithub.com/cortesi/moddwatch v0.0.0-20190809034736-2411614b3ac7 h1:YEFi+H/Z45AjwHaRsR50cl6IXjSg8EDzTjc05XK4Auw=\ngithub.com/cortesi/moddwatch v0.0.0-20190809034736-2411614b3ac7/go.mod h1:g60iWp/lO/DUFRg1vnpwDysHGZrMqqzdFV5Py25oqvQ=\ngithub.com/cortesi/moddwatch v0.0.0-20190809041828-239a95c12d84 h1:isRVsIi4gwygChA9pK1eOhf8JrUC2XoC0L6iThqOIkY=\ngithub.com/cortesi/moddwatch v0.0.0-20190809041828-239a95c12d84/go.mod h1:g60iWp/lO/DUFRg1vnpwDysHGZrMqqzdFV5Py25oqvQ=\ngithub.com/cortesi/termlog v0.0.0-20171116205515-87cefd5ac843 h1:sz+t+nXcEBP+hvtorswkEXc3xkXEAkU6AI2i4eii2sQ=\ngithub.com/cortesi/termlog v0.0.0-20171116205515-87cefd5ac843/go.mod h1:Ko6mGAZIfPhPee+oBtJuuF6S31ag18BtmK9PewP/T5w=\ngithub.com/cortesi/termlog v0.0.0-20190809035425-7871d363854c h1:D5UylL3xKRrrqZKk/NhrOhoQVdCQwuEeyFgTfN9n9O4=\ngithub.com/cortesi/termlog v0.0.0-20190809035425-7871d363854c/go.mod h1:gh6GQA3zOsGU4pz+X6ZHqW63KxI/V7KLmBCG9ODJ+l4=\ngithub.com/creack/pty v1.1.9/go.mod h1:oKZEueFk5CKHvIhNR5MUki03XCEU+Q6VDXinZuGJ33E=\ngithub.com/daaku/go.zipexe v0.0.0-20150329023125-a5fe2436ffcb h1:tUf55Po0vzOendQ7NWytcdK0VuzQmfAgvGBUOQvN0WA=\ngithub.com/daaku/go.zipexe v0.0.0-20150329023125-a5fe2436ffcb/go.mod h1:U0vRfAucUOohvdCxt5MWLF+TePIL0xbCkbKIiV8TQCE=\ngithub.com/daaku/go.zipexe v1.0.0/go.mod h1:z8IiR6TsVLEYKwXAoE/I+8ys/sDkgTzSL0CLnGVd57E=\ngithub.com/daaku/go.zipexe v1.0.1 h1:wV4zMsDOI2SZ2m7Tdz1Ps96Zrx+TzaK15VbUaGozw0M=\ngithub.com/daaku/go.zipexe v1.0.1/go.mod h1:5xWogtqlYnfBXkSB1o9xysukNP9GTvaNkqzUZbt3Bw8=\ngithub.com/davecgh/go-spew v1.1.0/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=\ngithub.com/davecgh/go-spew v1.1.1 h1:vj9j/u1bqnvCEfJOwUhtlOARqs3+rkHYY13jYWTU97c=\ngithub.com/davecgh/go-spew v1.1.1/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=\ngithub.com/dustin/go-humanize v1.0.0 h1:VSnTsYCnlFHaM2/igO1h6X3HA71jcobQuxemgkq4zYo=\ngithub.com/dustin/go-humanize v1.0.0/go.mod h1:HtrtbFcZ19U5GC7JDqmcUSB87Iq5E25KnS6fMYU6eOk=\ngithub.com/fatih/color v0.0.0-20181010231311-3f9d52f7176a h1:uGz8bS2tdMYpIjzS/ccMHV4H127Wz//pxlx7dN5qHB4=\ngithub.com/fatih/color v0.0.0-20181010231311-3f9d52f7176a/go.mod h1:Zm6kSWBoL9eyXnKyktHP6abPY2pDugNf5KwzbycvMj4=\ngithub.com/fatih/color v1.7.0 h1:DkWD4oS2D8LGGgTQ6IvwJJXSL5Vp2ffcQg58nFV38Ys=\ngithub.com/fatih/color v1.7.0/go.mod h1:Zm6kSWBoL9eyXnKyktHP6abPY2pDugNf5KwzbycvMj4=\ngithub.com/fatih/color v1.9.0 h1:8xPHl4/q1VyqGIPif1F+1V3Y3lSmrq01EabUW3CoW5s=\ngithub.com/fatih/color v1.9.0/go.mod h1:eQcE1qtQxscV5RaZvpXrrb8Drkc3/DdQ+uUYCNjL+zU=\ngithub.com/goji/httpauth v0.0.0-20160601135302-2da839ab0f4d h1:lBXNCxVENCipq4D1Is42JVOP4eQjlB8TQ6H69Yx5J9Q=\ngithub.com/goji/httpauth v0.0.0-20160601135302-2da839ab0f4d/go.mod h1:nnjvkQ9ptGaCkuDUx6wNykzzlUixGxvkme+H/lnzb+A=\ngithub.com/google/go-cmp v0.3.1 h1:Xye71clBPdm5HgqGwUkwhbynsUJZhDbS20FvLhQ2izg=\ngithub.com/google/go-cmp v0.3.1/go.mod h1:8QqcDgzrUqlUb/G2PQTWiueGozuR1884gddMywk6iLU=\ngithub.com/google/go-cmp v0.4.0 h1:xsAVV57WRhGj6kEIi8ReJzQlHHqcBYCElAvkovg3B/4=\ngithub.com/google/go-cmp v0.4.0/go.mod h1:v8dTdLbMG2kIc/vJvl+f65V22dbkXbowE6jgT/gNBxE=\ngithub.com/gorilla/websocket v1.4.0 h1:WDFjx/TMzVgy9VdMMQi2K2Emtwi2QcUQsztZ/zLaH/Q=\ngithub.com/gorilla/websocket v1.4.0/go.mod h1:E7qHFY5m1UJ88s3WnNqhKjPHQ0heANvMoAMk2YaljkQ=\ngithub.com/gorilla/websocket v1.4.2 h1:+/TMaTYc4QFitKJxsQ7Yye35DkWvkdLcvGKqM+x0Ufc=\ngithub.com/gorilla/websocket v1.4.2/go.mod h1:YR8l580nyteQvAITg2hZ9XVh4b55+EU/adAjf1fMHhE=\ngithub.com/jessevdk/go-flags v1.4.0/go.mod h1:4FA24M0QyGHXBuZZK/XkWh8h0e1EYbRYJSGM75WSRxI=\ngithub.com/juju/ratelimit v1.0.1 h1:+7AIFJVQ0EQgq/K9+0Krm7m530Du7tIz0METWzN0RgY=\ngithub.com/juju/ratelimit v1.0.1/go.mod h1:qapgC/Gy+xNh9UxzV13HGGl/6UXNN+ct+vwSgWNm/qk=\ngithub.com/kardianos/osext v0.0.0-20170510131534-ae77be60afb1 h1:PJPDf8OUfOK1bb/NeTKd4f1QXZItOX389VN3B6qC8ro=\ngithub.com/kardianos/osext v0.0.0-20170510131534-ae77be60afb1/go.mod h1:1NbS8ALrpOvjt0rHPNLyCIeMtbizbir8U//inJ+zuB8=\ngithub.com/kardianos/osext v0.0.0-20190222173326-2bc1f35cddc0/go.mod h1:1NbS8ALrpOvjt0rHPNLyCIeMtbizbir8U//inJ+zuB8=\ngithub.com/kr/pty v1.1.1/go.mod h1:pFQYn66WHrOpPYNljwOMqo10TkYh1fy3cYio2l3bCsQ=\ngithub.com/kr/text v0.1.0 h1:45sCR5RtlFHMR4UwH9sdQ5TC8v0qDQCHnXt+kaKSTVE=\ngithub.com/kr/text v0.1.0/go.mod h1:4Jbv+DJW3UT/LiOwJeYQe1efqtUx/iVham/4vfdArNI=\ngithub.com/kr/text v0.2.0 h1:5Nx0Ya0ZqY2ygV366QzturHI13Jq95ApcVaJBhpS+AY=\ngithub.com/kr/text v0.2.0/go.mod h1:eLer722TekiGuMkidMxC/pM04lWEeraHUUmBw8l2grE=\ngithub.com/mattn/go-colorable v0.0.9 h1:UVL0vNpWh04HeJXV0KLcaT7r06gOH2l4OW6ddYRUIY4=\ngithub.com/mattn/go-colorable v0.0.9/go.mod h1:9vuHe8Xs5qXnSaW/c/ABM9alt+Vo+STaOChaDxuIBZU=\ngithub.com/mattn/go-colorable v0.1.2 h1:/bC9yWikZXAL9uJdulbSfyVNIR3n3trXl+v8+1sx8mU=\ngithub.com/mattn/go-colorable v0.1.2/go.mod h1:U0ppj6V5qS13XJ6of8GYAs25YV2eR4EVcfRqFIhoBtE=\ngithub.com/mattn/go-colorable v0.1.4/go.mod h1:U0ppj6V5qS13XJ6of8GYAs25YV2eR4EVcfRqFIhoBtE=\ngithub.com/mattn/go-colorable v0.1.6 h1:6Su7aK7lXmJ/U79bYtBjLNaha4Fs1Rg9plHpcH+vvnE=\ngithub.com/mattn/go-colorable v0.1.6/go.mod h1:u6P/XSegPjTcexA+o6vUJrdnUu04hMope9wVRipJSqc=\ngithub.com/mattn/go-isatty v0.0.4 h1:bnP0vzxcAdeI1zdubAl5PjU6zsERjGZb7raWodagDYs=\ngithub.com/mattn/go-isatty v0.0.4/go.mod h1:M+lRXTBqGeGNdLjl/ufCoiOlB5xdOkqRJdNxMWT7Zi4=\ngithub.com/mattn/go-isatty v0.0.8 h1:HLtExJ+uU2HOZ+wI0Tt5DtUDrx8yhUqDcp7fYERX4CE=\ngithub.com/mattn/go-isatty v0.0.8/go.mod h1:Iq45c/XA43vh69/j3iqttzPXn0bhXyGjM0Hdxcsrc5s=\ngithub.com/mattn/go-isatty v0.0.11/go.mod h1:PhnuNfih5lzO57/f3n+odYbM4JtupLOxQOAqxQCu2WE=\ngithub.com/mattn/go-isatty v0.0.12 h1:wuysRhFDzyxgEmMf5xjvJ2M9dZoWAXNNr5LSBS7uHXY=\ngithub.com/mattn/go-isatty v0.0.12/go.mod h1:cbi8OIDigv2wuxKPP5vlRcQ1OAZbq2CE4Kysco4FUpU=\ngithub.com/mitchellh/go-homedir v1.0.0 h1:vKb8ShqSby24Yrqr/yDYkuFz8d0WUjys40rvnGC8aR0=\ngithub.com/mitchellh/go-homedir v1.0.0/go.mod h1:SfyaCUpYCn1Vlf4IUYiD9fPX4A5wJrkLzIz1N1q0pr0=\ngithub.com/mitchellh/go-homedir v1.1.0 h1:lukF9ziXFxDFPkA1vsr5zpc1XuPDn/wFntq5mG+4E0Y=\ngithub.com/mitchellh/go-homedir v1.1.0/go.mod h1:SfyaCUpYCn1Vlf4IUYiD9fPX4A5wJrkLzIz1N1q0pr0=\ngithub.com/niemeyer/pretty v0.0.0-20200227124842-a10e7caefd8e h1:fD57ERR4JtEqsWbfPhv4DMiApHyliiK5xCTNVSPiaAs=\ngithub.com/niemeyer/pretty v0.0.0-20200227124842-a10e7caefd8e/go.mod h1:zD1mROLANZcx1PVRCS0qkT7pwLkGfwJo4zjcN/Tysno=\ngithub.com/nkovacs/streamquote v0.0.0-20170412213628-49af9bddb229/go.mod h1:0aYXnNPJ8l7uZxf45rWW1a/uME32OF0rhiYGNQ2oF2E=\ngithub.com/nkovacs/streamquote v1.0.0/go.mod h1:BN+NaZ2CmdKqUuTUXUEm9j95B2TRbpOWpxbJYzzgUsc=\ngithub.com/pmezard/go-difflib v1.0.0 h1:4DBwDE0NGyQoBHbLQYPwSUPoCMWR5BEzIk/f1lZbAQM=\ngithub.com/pmezard/go-difflib v1.0.0/go.mod h1:iKH77koFhYxTK1pcRnkKkqfTogsbg7gZNVY4sRDYZ/4=\ngithub.com/rjeczalik/notify v0.0.0-20181126183243-629144ba06a1 h1:FLWDC+iIP9BWgYKvWKKtOUZux35LIQNAuIzp/63RQJU=\ngithub.com/rjeczalik/notify v0.0.0-20181126183243-629144ba06a1/go.mod h1:aErll2f0sUX9PXZnVNyeiObbmTlk5jnMoCa4QEjJeqM=\ngithub.com/stretchr/objx v0.1.0/go.mod h1:HFkY916IF+rwdDfMAkV7OtwuqBVzrE8GR6GFx+wExME=\ngithub.com/stretchr/testify v1.4.0/go.mod h1:j7eGeouHqKxXV5pUuKE4zz7dFj8WfuZ+81PSLYec5m4=\ngithub.com/stretchr/testify v1.5.1 h1:nOGnQDM7FYENwehXlg/kFVnos3rEvtKTjRvOWSzb6H4=\ngithub.com/stretchr/testify v1.5.1/go.mod h1:5W2xD1RspED5o8YsWQXVCued0rvSQ+mT+I5cxcmMvtA=\ngithub.com/toqueteos/webbrowser v0.0.0-20171128075006-43eedf9c266f h1:Oool8pJEkNHHvlAvrnWJJem2kXRi1g5raLI3bmic7Ho=\ngithub.com/toqueteos/webbrowser v0.0.0-20171128075006-43eedf9c266f/go.mod h1:Hqqqmzj8AHn+VlZyVjaRWY20i25hoOZGAABCcg2el4A=\ngithub.com/toqueteos/webbrowser v1.2.0 h1:tVP/gpK69Fx+qMJKsLE7TD8LuGWPnEV71wBN9rrstGQ=\ngithub.com/toqueteos/webbrowser v1.2.0/go.mod h1:XWoZq4cyp9WeUeak7w7LXRUQf1F1ATJMir8RTqb4ayM=\ngithub.com/valyala/bytebufferpool v1.0.0/go.mod h1:6bBcMArwyJ5K/AmCkWv1jt77kVWyCJ6HpOuEn7z0Csc=\ngithub.com/valyala/fasttemplate v1.0.1/go.mod h1:UQGH1tvbgY+Nz5t2n7tXsz52dQxojPUpymEIMZ47gx8=\ngolang.org/x/crypto v0.0.0-20181203042331-505ab145d0a9 h1:mKdxBk7AujPs8kU4m80U72y/zjbZ3UcXC7dClwKbUI0=\ngolang.org/x/crypto v0.0.0-20181203042331-505ab145d0a9/go.mod h1:6SG95UA2DQfeDnfUPMdvaQW0Q7yPrPDi9nlGo2tz2b4=\ngolang.org/x/crypto v0.0.0-20190308221718-c2843e01d9a2/go.mod h1:djNgcEr1/C05ACkg1iLfiJU5Ep61QUkGW8qpdssI0+w=\ngolang.org/x/crypto v0.0.0-20190701094942-4def268fd1a4 h1:HuIa8hRrWRSrqYzx1qI49NNxhdi2PrY7gxVSq1JjLDc=\ngolang.org/x/crypto v0.0.0-20190701094942-4def268fd1a4/go.mod h1:yigFU9vqHzYiE8UmvKecakEJjdnWj3jj499lnFckfCI=\ngolang.org/x/crypto v0.0.0-20200423211502-4bdfaf469ed5 h1:Q7tZBpemrlsc2I7IyODzhtallWRSm4Q0d09pL6XbQtU=\ngolang.org/x/crypto v0.0.0-20200423211502-4bdfaf469ed5/go.mod h1:LzIPMQfyMNhhGPhUkYOs5KpL4U8rLKemX1yGLhDgUto=\ngolang.org/x/net v0.0.0-20181220203305-927f97764cc3 h1:eH6Eip3UpmR+yM/qI9Ijluzb1bNv/cAU/n+6l8tRSis=\ngolang.org/x/net v0.0.0-20181220203305-927f97764cc3/go.mod h1:mL1N/T3taQHkDXs73rZJwtUhF3w3ftmwwsq0BUmARs4=\ngolang.org/x/net v0.0.0-20190404232315-eb5bcb51f2a3/go.mod h1:t9HGtf8HONx5eT2rtn7q6eTqICYqUVnKs3thJo3Qplg=\ngolang.org/x/net v0.0.0-20190620200207-3b0461eec859/go.mod h1:z5CRVTTTmAJ677TzLLGU+0bjPO0LkuOLi4/5GtJWs/s=\ngolang.org/x/net v0.0.0-20190724013045-ca1201d0de80 h1:Ao/3l156eZf2AW5wK8a7/smtodRU+gha3+BeqJ69lRk=\ngolang.org/x/net v0.0.0-20190724013045-ca1201d0de80/go.mod h1:z5CRVTTTmAJ677TzLLGU+0bjPO0LkuOLi4/5GtJWs/s=\ngolang.org/x/net v0.0.0-20190813141303-74dc4d7220e7 h1:fHDIZ2oxGnUZRN6WgWFCbYBjH9uqVPRCUVUDhs0wnbA=\ngolang.org/x/net v0.0.0-20190813141303-74dc4d7220e7/go.mod h1:z5CRVTTTmAJ677TzLLGU+0bjPO0LkuOLi4/5GtJWs/s=\ngolang.org/x/net v0.0.0-20200425230154-ff2c4b7c35a0 h1:Jcxah/M+oLZ/R4/z5RzfPzGbPXnVDPkEDtf2JnuxN+U=\ngolang.org/x/net v0.0.0-20200425230154-ff2c4b7c35a0/go.mod h1:qpuaurCH72eLCgpAm/N6yyVIVM9cpaDIP3A8BGJEC5A=\ngolang.org/x/sync v0.0.0-20190423024810-112230192c58/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=\ngolang.org/x/sys v0.0.0-20180926160741-c2ed4eda69e7/go.mod h1:STP8DvDyc/dI5b8T5hshtkjS+E42TnysNCUPdjciGhY=\ngolang.org/x/sys v0.0.0-20181221143128-b4a75ba826a6 h1:IcgEB62HYgAhX0Nd/QrVgZlxlcyxbGQHElLUhW2X4Fo=\ngolang.org/x/sys v0.0.0-20181221143128-b4a75ba826a6/go.mod h1:STP8DvDyc/dI5b8T5hshtkjS+E42TnysNCUPdjciGhY=\ngolang.org/x/sys v0.0.0-20190215142949-d0b11bdaac8a/go.mod h1:STP8DvDyc/dI5b8T5hshtkjS+E42TnysNCUPdjciGhY=\ngolang.org/x/sys v0.0.0-20190222072716-a9d3bda3a223/go.mod h1:STP8DvDyc/dI5b8T5hshtkjS+E42TnysNCUPdjciGhY=\ngolang.org/x/sys v0.0.0-20190412213103-97732733099d/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20190804053845-51ab0e2deafa h1:KIDDMLT1O0Nr7TSxp8xM5tJcdn8tgyAONntO829og1M=\ngolang.org/x/sys v0.0.0-20190804053845-51ab0e2deafa/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20190813064441-fde4db37ae7a h1:aYOabOQFp6Vj6W1F80affTUvO9UxmJRx8K0gsfABByQ=\ngolang.org/x/sys v0.0.0-20190813064441-fde4db37ae7a/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20191026070338-33540a1f6037/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20200116001909-b77594299b42/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20200223170610-d5e6a3e2c0ae/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20200323222414-85ca7c5b95cd/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20200420163511-1957bb5e6d1f h1:gWF768j/LaZugp8dyS4UwsslYCYz9XgFxvlgsn0n9H8=\ngolang.org/x/sys v0.0.0-20200420163511-1957bb5e6d1f/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/text v0.3.0/go.mod h1:NqM8EUOU14njkJ3fqMW+pc6Ldnwhi/IjpwHt7yyuwOQ=\ngolang.org/x/text v0.3.2/go.mod h1:bEr9sfX3Q8Zfm5fL9x+3itogRgK3+ptLWKqgva+5dAk=\ngolang.org/x/tools v0.0.0-20180917221912-90fa682c2a6e/go.mod h1:n7NCudcB/nEzxVGmLbDWY5pfWTLqBcC2KZ6jyYvM4mQ=\ngolang.org/x/tools v0.0.0-20190808195139-e713427fea3f/go.mod h1:b+2E5dAYhXwXZwtnZ6UAqBI28+e2cm9otk0dWdXHAEo=\ngolang.org/x/tools v0.0.0-20190815232600-256244171580/go.mod h1:b+2E5dAYhXwXZwtnZ6UAqBI28+e2cm9otk0dWdXHAEo=\ngolang.org/x/xerrors v0.0.0-20190717185122-a985d3407aa7/go.mod h1:I/5z698sn9Ka8TeJc9MKroUUfqBBauWjQqLJ2OPfmY0=\ngolang.org/x/xerrors v0.0.0-20191204190536-9bdfabe68543 h1:E7g+9GITq07hpfrRu66IVDexMakfv52eLZ2CXBWiKr4=\ngolang.org/x/xerrors v0.0.0-20191204190536-9bdfabe68543/go.mod h1:I/5z698sn9Ka8TeJc9MKroUUfqBBauWjQqLJ2OPfmY0=\ngopkg.in/alecthomas/kingpin.v2 v2.2.6 h1:jMFz6MfLP0/4fUyZle81rXUoxOBFi19VUFKVDOQfozc=\ngopkg.in/alecthomas/kingpin.v2 v2.2.6/go.mod h1:FMv+mEhP44yOT+4EoQTLFTRgOQ1FBLkstjWtayDeSgw=\ngopkg.in/check.v1 v0.0.0-20161208181325-20d25e280405/go.mod h1:Co6ibVJAznAaIkqp8huTwlJQCZ016jof/cbN4VW5Yz0=\ngopkg.in/check.v1 v1.0.0-20200227125254-8fa46927fb4f h1:BLraFXnmrev5lT+xlilqcH8XK9/i0At2xKjWk4p6zsU=\ngopkg.in/check.v1 v1.0.0-20200227125254-8fa46927fb4f/go.mod h1:Co6ibVJAznAaIkqp8huTwlJQCZ016jof/cbN4VW5Yz0=\ngopkg.in/yaml.v2 v2.2.2 h1:ZCJp+EgiOT7lHqUV2J862kp8Qj64Jo6az82+3Td9dZw=\ngopkg.in/yaml.v2 v2.2.2/go.mod h1:hI93XBmqTisBFMUTm0b8Fm+jr3Dg1NNxqwp+5A1VGuI=\ngopkg.in/yaml.v2 v2.2.8 h1:obN1ZagJSUGI0Ek/LBmuj4SNLPfIny3KsKFopxRdj10=\ngopkg.in/yaml.v2 v2.2.8/go.mod h1:hI93XBmqTisBFMUTm0b8Fm+jr3Dg1NNxqwp+5A1VGuI=\n"
        },
        {
          "name": "httpctx",
          "type": "tree",
          "content": null
        },
        {
          "name": "inject",
          "type": "tree",
          "content": null
        },
        {
          "name": "livereload",
          "type": "tree",
          "content": null
        },
        {
          "name": "logheader.go",
          "type": "blob",
          "size": 0.462890625,
          "content": "package devd\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\n\t\"github.com/cortesi/termlog\"\n\t\"github.com/fatih/color\"\n)\n\n// LogHeader logs a header\nfunc LogHeader(log termlog.Logger, h http.Header) {\n\tmax := 0\n\tfor k := range h {\n\t\tif len(k) > max {\n\t\t\tmax = len(k)\n\t\t}\n\t}\n\tfor k, vals := range h {\n\t\tfor _, v := range vals {\n\t\t\tpad := fmt.Sprintf(fmt.Sprintf(\"%%%ds\", max-len(k)+1), \" \")\n\t\t\tlog.SayAs(\n\t\t\t\t\"headers\",\n\t\t\t\t\"\\t%s%s%s\",\n\t\t\t\tcolor.BlueString(k)+\":\",\n\t\t\t\tpad,\n\t\t\t\tv,\n\t\t\t)\n\t\t}\n\t}\n}\n"
        },
        {
          "name": "modd.conf",
          "type": "blob",
          "size": 0.3271484375,
          "content": "\ntemplates/*.html {\n    prep: \"\n        rice embed-go\n    \"\n}\n\nlivereload/static/*.js {\n    indir: ./livereload\n    prep: \"\n        # rice embed-go livereload\n        rice embed-go\n    \"\n}\n\n**/*.go !vendor/** {\n    prep: go test @dirmods\n}\n\n**/*.go !**/*_test.go {\n    prep: go install ./cmd/devd\n    daemon +sigterm: devd -ml ./tmp\n}\n"
        },
        {
          "name": "responselogger.go",
          "type": "blob",
          "size": 2.4970703125,
          "content": "package devd\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"strconv\"\n\n\t\"github.com/cortesi/devd/timer\"\n\t\"github.com/cortesi/termlog\"\n\t\"github.com/dustin/go-humanize\"\n\t\"github.com/fatih/color\"\n)\n\n// ResponseLogWriter is a ResponseWriter that logs\ntype ResponseLogWriter struct {\n\tLog         termlog.Logger\n\tResp        http.ResponseWriter\n\tFlusher     http.Flusher\n\tTimer       *timer.Timer\n\twroteHeader bool\n}\n\nfunc (rl *ResponseLogWriter) logCode(code int, status string) {\n\tvar codestr string\n\tswitch {\n\tcase code >= 200 && code < 300:\n\t\tcodestr = color.GreenString(\"%d %s\", code, status)\n\tcase code >= 300 && code < 400:\n\t\tcodestr = color.BlueString(\"%d %s\", code, status)\n\tcase code >= 400 && code < 500:\n\t\tcodestr = color.YellowString(\"%d %s\", code, status)\n\tcase code >= 500 && code < 600:\n\t\tcodestr = color.RedString(\"%d %s\", code, status)\n\tdefault:\n\t\tcodestr = fmt.Sprintf(\"%d %s\", code, status)\n\t}\n\tcl := rl.Header().Get(\"content-length\")\n\tclstr := \"\"\n\tif cl != \"\" {\n\t\tcli, err := strconv.Atoi(cl)\n\t\tif err != nil {\n\t\t\trl.Log.Warn(\"Invalid content-length header\")\n\t\t} else if cli > 0 {\n\t\t\tclstr = fmt.Sprintf(\"%s\", humanize.Bytes(uint64(cli)))\n\t\t}\n\t}\n\trl.Log.Say(\"<- %s %s\", codestr, clstr)\n}\n\n// Header returns the header map that will be sent by WriteHeader.\n// Changing the header after a call to WriteHeader (or Write) has\n// no effect.\nfunc (rl *ResponseLogWriter) Header() http.Header {\n\treturn rl.Resp.Header()\n}\n\n// Write writes the data to the connection as part of an HTTP reply.\n// If WriteHeader has not yet been called, Write calls WriteHeader(http.StatusOK)\n// before writing the data.  If the Header does not contain a\n// Content-Type line, Write adds a Content-Type set to the result of passing\n// the initial 512 bytes of written data to DetectContentType.\nfunc (rl *ResponseLogWriter) Write(data []byte) (int, error) {\n\tif !rl.wroteHeader {\n\t\trl.WriteHeader(http.StatusOK)\n\t}\n\tret, err := rl.Resp.Write(data)\n\trl.Timer.ResponseDone()\n\treturn ret, err\n}\n\n// WriteHeader sends an HTTP response header with status code.\n// If WriteHeader is not called explicitly, the first call to Write\n// will trigger an implicit WriteHeader(http.StatusOK).\n// Thus explicit calls to WriteHeader are mainly used to\n// send error codes.\nfunc (rl *ResponseLogWriter) WriteHeader(code int) {\n\trl.wroteHeader = true\n\trl.logCode(code, http.StatusText(code))\n\tLogHeader(rl.Log, rl.Resp.Header())\n\trl.Timer.ResponseHeaders()\n\trl.Resp.WriteHeader(code)\n\trl.Timer.ResponseDone()\n}\n\nfunc (rl *ResponseLogWriter) Flush() {\n\tif rl.Flusher != nil {\n\t\trl.Flusher.Flush()\n\t}\n}\n"
        },
        {
          "name": "reverseproxy",
          "type": "tree",
          "content": null
        },
        {
          "name": "rice-box.go",
          "type": "blob",
          "size": 2.947265625,
          "content": "package devd\n\nimport (\n\t\"github.com/GeertJohan/go.rice/embedded\"\n\t\"time\"\n)\n\nfunc init() {\n\n\t// define files\n\tfile2 := &embedded.EmbeddedFile{\n\t\tFilename:    \"404.html\",\n\t\tFileModTime: time.Unix(1503017339, 0),\n\t\tContent:     string(\"<html>\\n    <head>\\n        <style>\\n            p {\\n                padding: 20px;\\n                font-size: 3em;\\n            }\\n            .footer {\\n                width: 100%;\\n                margin-top: 2em;\\n                text-align: right;\\n                font-style: italic;\\n            }\\n        </style>\\n    </head>\\n    <body>\\n        <p>404: Page not found</p>\\n        <div class=\\\"footer\\\">\\n            {{ .Version }}\\n        </div>\\n    </body>\\n</html>\\n\"),\n\t}\n\tfile3 := &embedded.EmbeddedFile{\n\t\tFilename:    \"dirlist.html\",\n\t\tFileModTime: time.Unix(1503017339, 0),\n\t\tContent:     string(\"<html>\\n    <head>\\n        <style>\\n            #files {\\n                border-collapse: collapse;\\n            }\\n            .dir a {\\n                color: #0741d9;\\n            }\\n            .file a {\\n                color: #0787d9;\\n            }\\n            .hidden a {\\n                color: #a5b1b9;\\n            }\\n            #files tr {\\n                border-bottom: 1px solid #c0c0c0;\\n            }\\n            #files td {\\n                padding: 10px;\\n            }\\n            #files .dir .name {\\n                font-weight: bold\\n            }\\n            #files .empty {\\n                font-style: italic;\\n            }\\n            .footer {\\n                width: 100%;\\n                margin-top: 2em;\\n                text-align: right;\\n                font-style: italic;\\n            }\\n        </style>\\n    </head>\\n    <body>\\n        <h1>{{.Name}}</h1>\\n        <table id=\\\"files\\\">\\n            {{ range .Files }}\\n    \\t\\t\\t<tr class=\\\"{{ . | fileType  }}\\\">\\n                    <td class=\\\"name\\\">\\n                        <a href=\\\"{{.Name}}\\\">{{.Name}}{{ if .IsDir }}/{{ end }}</a>\\n                    </td>\\n                    <td class=\\\"size\\\">{{ .Size | bytes }}</td>\\n                    <td class=\\\"modified\\\">{{ .ModTime | reltime }}</td>\\n                </tr>\\n            {{ else }}\\n                <tr><td class=\\\"empty\\\" span=\\\"2\\\">No files found.</td></tr>\\n            {{ end }}\\n        </table>\\n        <div class=\\\"footer\\\">\\n            {{ .Version }}\\n        </div>\\n    </body>\\n</html>\\n\"),\n\t}\n\n\t// define dirs\n\tdir1 := &embedded.EmbeddedDir{\n\t\tFilename:   \"\",\n\t\tDirModTime: time.Unix(1503017339, 0),\n\t\tChildFiles: []*embedded.EmbeddedFile{\n\t\t\tfile2, // \"404.html\"\n\t\t\tfile3, // \"dirlist.html\"\n\n\t\t},\n\t}\n\n\t// link ChildDirs\n\tdir1.ChildDirs = []*embedded.EmbeddedDir{}\n\n\t// register embeddedBox\n\tembedded.RegisterEmbeddedBox(`templates`, &embedded.EmbeddedBox{\n\t\tName: `templates`,\n\t\tTime: time.Unix(1503017339, 0),\n\t\tDirs: map[string]*embedded.EmbeddedDir{\n\t\t\t\"\": dir1,\n\t\t},\n\t\tFiles: map[string]*embedded.EmbeddedFile{\n\t\t\t\"404.html\":     file2,\n\t\t\t\"dirlist.html\": file3,\n\t\t},\n\t})\n}\n"
        },
        {
          "name": "ricetemp",
          "type": "tree",
          "content": null
        },
        {
          "name": "route.go",
          "type": "blob",
          "size": 3.4560546875,
          "content": "package devd\n\nimport (\n\t\"crypto/tls\"\n\t\"errors\"\n\t\"fmt\"\n\t\"html/template\"\n\t\"net/http\"\n\t\"net/url\"\n\t\"time\"\n\n\t\"github.com/cortesi/devd/fileserver\"\n\t\"github.com/cortesi/devd/httpctx\"\n\t\"github.com/cortesi/devd/inject\"\n\t\"github.com/cortesi/devd/reverseproxy\"\n\t\"github.com/cortesi/devd/routespec\"\n)\n\n// Endpoint is the destination of a Route - either on the filesystem or\n// forwarding to another URL\ntype endpoint interface {\n\tHandler(prefix string, templates *template.Template, ci inject.CopyInject) httpctx.Handler\n\tString() string\n}\n\n// An endpoint that forwards to an upstream URL\ntype forwardEndpoint url.URL\n\nfunc (ep forwardEndpoint) Handler(prefix string, templates *template.Template, ci inject.CopyInject) httpctx.Handler {\n\tu := url.URL(ep)\n\trp := reverseproxy.NewSingleHostReverseProxy(&u, ci)\n\trp.Transport = &http.Transport{\n\t\tTLSClientConfig: &tls.Config{InsecureSkipVerify: true},\n\t}\n\trp.FlushInterval = 200 * time.Millisecond\n\treturn httpctx.StripPrefix(prefix, rp)\n}\n\nfunc newForwardEndpoint(path string) (*forwardEndpoint, error) {\n\turl, err := url.Parse(path)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"Could not parse route URL: %s\", err)\n\t}\n\tf := forwardEndpoint(*url)\n\treturn &f, nil\n}\n\nfunc (ep forwardEndpoint) String() string {\n\treturn \"forward to \" + ep.Scheme + \"://\" + ep.Host + ep.Path\n}\n\n// An enpoint that serves a filesystem location\ntype filesystemEndpoint struct {\n\tRoot           string\n\tnotFoundRoutes []routespec.RouteSpec\n}\n\nfunc newFilesystemEndpoint(path string, notfound []string) (*filesystemEndpoint, error) {\n\trparts := []routespec.RouteSpec{}\n\tfor _, p := range notfound {\n\t\trp, err := routespec.ParseRouteSpec(p)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tif rp.IsURL {\n\t\t\treturn nil, fmt.Errorf(\"Not found over-ride target cannot be a URL.\")\n\t\t}\n\t\trparts = append(rparts, *rp)\n\t}\n\treturn &filesystemEndpoint{path, rparts}, nil\n}\n\nfunc (ep filesystemEndpoint) Handler(prefix string, templates *template.Template, ci inject.CopyInject) httpctx.Handler {\n\treturn &fileserver.FileServer{\n\t\tVersion:        \"devd \" + Version,\n\t\tRoot:           http.Dir(ep.Root),\n\t\tInject:         ci,\n\t\tTemplates:      templates,\n\t\tNotFoundRoutes: ep.notFoundRoutes,\n\t\tPrefix:         prefix,\n\t}\n}\n\nfunc (ep filesystemEndpoint) String() string {\n\treturn \"reads files from \" + ep.Root\n}\n\n// Route is a mapping from a (host, path) tuple to an endpoint.\ntype Route struct {\n\tHost     string\n\tPath     string\n\tEndpoint endpoint\n}\n\n// Constructs a new route from a string specifcation. Specifcations are of the\n// form ANCHOR=VALUE.\nfunc newRoute(s string, notfound []string) (*Route, error) {\n\trp, err := routespec.ParseRouteSpec(s)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tvar ep endpoint\n\n\tif rp.IsURL {\n\t\tep, err = newForwardEndpoint(rp.Value)\n\t} else {\n\t\tep, err = newFilesystemEndpoint(rp.Value, notfound)\n\t}\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn &Route{rp.Host, rp.Path, ep}, nil\n}\n\n// MuxMatch produces a match clause suitable for passing to a Mux\nfunc (f Route) MuxMatch() string {\n\t// Path is guaranteed to start with /\n\treturn f.Host + f.Path\n}\n\n// RouteCollection is a collection of routes\ntype RouteCollection map[string]Route\n\nfunc (f *RouteCollection) String() string {\n\treturn fmt.Sprintf(\"%v\", *f)\n}\n\n// Add a route to the collection\nfunc (f RouteCollection) Add(value string, notfound []string) error {\n\ts, err := newRoute(value, notfound)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif _, exists := f[s.MuxMatch()]; exists {\n\t\treturn errors.New(\"Route already exists.\")\n\t}\n\tf[s.MuxMatch()] = *s\n\treturn nil\n}\n"
        },
        {
          "name": "route_test.go",
          "type": "blob",
          "size": 3.767578125,
          "content": "package devd\n\nimport (\n\t\"fmt\"\n\t\"reflect\"\n\t\"strings\"\n\t\"testing\"\n\n\t\"github.com/GeertJohan/go.rice\"\n\t\"github.com/cortesi/devd/inject\"\n\t\"github.com/cortesi/devd/ricetemp\"\n)\n\nfunc tFilesystemEndpoint(s string) *filesystemEndpoint {\n\te, _ := newFilesystemEndpoint(s, []string{})\n\treturn e\n}\n\nfunc tForwardEndpoint(s string) *forwardEndpoint {\n\te, _ := newForwardEndpoint(s)\n\treturn e\n}\n\nfunc within(s string, e error) bool {\n\ts = strings.ToLower(s)\n\testr := strings.ToLower(fmt.Sprint(e))\n\treturn strings.Contains(estr, s)\n}\n\nvar newSpecTests = []struct {\n\traw  string\n\tspec *Route\n\terr  string\n}{\n\t{\n\t\t\"/one=two\",\n\t\t&Route{\"\", \"/one\", tFilesystemEndpoint(\"two\")},\n\t\t\"\",\n\t},\n\t{\n\t\t\"/one=two=three\",\n\t\t&Route{\"\", \"/one\", tFilesystemEndpoint(\"two=three\")},\n\t\t\"\",\n\t},\n\t{\n\t\t\"one\",\n\t\t&Route{\"\", \"/\", tFilesystemEndpoint(\"one\")},\n\t\t\"invalid spec\",\n\t},\n\t{\"=one\", nil, \"invalid spec\"},\n\t{\"one=\", nil, \"invalid spec\"},\n\t{\n\t\t\"one/two=three\",\n\t\t&Route{\"one.devd.io\", \"/two\", tFilesystemEndpoint(\"three\")},\n\t\t\"\",\n\t},\n\t{\n\t\t\"one=three\",\n\t\t&Route{\"one.devd.io\", \"/\", tFilesystemEndpoint(\"three\")},\n\t\t\"\",\n\t},\n\t{\n\t\t\"one=http://three\",\n\t\t&Route{\"one.devd.io\", \"/\", tForwardEndpoint(\"http://three\")},\n\t\t\"\",\n\t},\n\t{\n\t\t\"one=localhost:1234\",\n\t\tnil,\n\t\t\"Unknown scheme 'localhost': did you mean http or https?: localhost:1234\",\n\t},\n\t{\n\t\t\"one=localhost:1234/abc\",\n\t\tnil,\n\t\t\"Unknown scheme 'localhost': did you mean http or https?: localhost:1234/abc\",\n\t},\n\t{\n\t\t\"one=ws://three\",\n\t\tnil,\n\t\t\"Websocket protocol not supported: ws://three\",\n\t},\n\t{\n\t\t\"one=:1234\",\n\t\t&Route{\"one.devd.io\", \"/\", tForwardEndpoint(\"http://localhost:1234\")},\n\t\t\"\",\n\t},\n}\n\nfunc TestParseSpec(t *testing.T) {\n\tfor i, tt := range newSpecTests {\n\t\ts, err := newRoute(tt.raw, []string{})\n\t\tif tt.spec != nil {\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"Test %d, error:\\n%s\\n\", i, err)\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(s, tt.spec) {\n\t\t\t\tt.Errorf(\"Test %d, expecting:\\n%s\\nGot:\\n%s\\n\", i, tt.spec, s)\n\t\t\t\tcontinue\n\t\t\t}\n\t\t} else if tt.err != \"\" {\n\t\t\tif err == nil {\n\t\t\t\tt.Errorf(\"Test %d, expected error:\\n%s\\n\", i, tt.err)\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif !within(tt.err, err) {\n\t\t\t\tt.Errorf(\n\t\t\t\t\t\"Test %d, expected error:\\n%s\\nGot error:%s\\n\",\n\t\t\t\t\ti,\n\t\t\t\t\ttt.err,\n\t\t\t\t\terr,\n\t\t\t\t)\n\t\t\t\tcontinue\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc TestForwardEndpoint(t *testing.T) {\n\tf, err := newForwardEndpoint(\"http://foo\")\n\tif err != nil {\n\t\tt.Errorf(\"Unexpected error: %s\", err)\n\t}\n\trb, err := rice.FindBox(\"templates\")\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n\ttemplates, err := ricetemp.MakeTemplates(rb)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\tf.Handler(\"\", templates, inject.CopyInject{})\n\n\tf, err = newForwardEndpoint(\"%\")\n\tif err == nil {\n\t\tt.Errorf(\"Expected error, got %s\", f)\n\t}\n}\n\nfunc TestNewRoute(t *testing.T) {\n\tr, err := newRoute(\"foo=http://%\", []string{})\n\tif err == nil {\n\t\tt.Errorf(\"Expected error, got %s\", r)\n\t}\n}\n\nfunc TestRouteHandler(t *testing.T) {\n\tvar routeHandlerTests = []struct {\n\t\tspec string\n\t}{\n\t\t{\"/one=two\"},\n\t}\n\tfor i, tt := range routeHandlerTests {\n\t\tr, err := newRoute(tt.spec, []string{})\n\t\tif err != nil {\n\t\t\tt.Errorf(\n\t\t\t\t\"Test %d, unexpected error:\\n%s\\n\",\n\t\t\t\ti,\n\t\t\t\terr,\n\t\t\t)\n\t\t}\n\n\t\trb, err := rice.FindBox(\"templates\")\n\t\tif err != nil {\n\t\t\tt.Error(err)\n\t\t}\n\t\ttemplates, err := ricetemp.MakeTemplates(rb)\n\t\tif err != nil {\n\t\t\tpanic(err)\n\t\t}\n\n\t\tr.Endpoint.Handler(\"\", templates, inject.CopyInject{})\n\t}\n}\n\nfunc TestRouteCollection(t *testing.T) {\n\tvar m = make(RouteCollection)\n\t_ = m.String()\n\terr := m.Add(\"foo=bar\", []string{})\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n\terr = m.Add(\"foo\", []string{})\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n\n\terr = m.Add(\"xxx=bar\", []string{})\n\tif err != nil {\n\t\tt.Errorf(\"Set error: %s\", err)\n\t}\n\n\terr = m.Add(\"xxx=bar\", []string{})\n\tif err == nil {\n\t\tt.Errorf(\"Expected error, got: %s\", m)\n\t}\n}\n\nfunc TestNotFound(t *testing.T) {\n\te, _ := newFilesystemEndpoint(\"/test\", []string{})\n\tfmt.Println(e)\n}\n"
        },
        {
          "name": "routespec",
          "type": "tree",
          "content": null
        },
        {
          "name": "scripts",
          "type": "tree",
          "content": null
        },
        {
          "name": "server.go",
          "type": "blob",
          "size": 9.806640625,
          "content": "package devd\n\nimport (\n\t\"crypto/tls\"\n\t\"fmt\"\n\t\"html/template\"\n\t\"net\"\n\t\"net/http\"\n\t\"os\"\n\t\"os/signal\"\n\t\"regexp\"\n\t\"strings\"\n\t\"syscall\"\n\t\"time\"\n\n\t\"golang.org/x/net/context\"\n\n\trice \"github.com/GeertJohan/go.rice\"\n\t\"github.com/goji/httpauth\"\n\n\t\"github.com/cortesi/devd/httpctx\"\n\t\"github.com/cortesi/devd/inject\"\n\t\"github.com/cortesi/devd/livereload\"\n\t\"github.com/cortesi/devd/ricetemp\"\n\t\"github.com/cortesi/devd/slowdown\"\n\t\"github.com/cortesi/devd/timer\"\n\t\"github.com/cortesi/termlog\"\n)\n\nconst (\n\t// Version is the current version of devd\n\tVersion  = \"0.9\"\n\tportLow  = 8000\n\tportHigh = 10000\n)\n\nfunc pickPort(addr string, low int, high int, tls bool) (net.Listener, error) {\n\tfirstTry := 80\n\tif tls {\n\t\tfirstTry = 443\n\t}\n\thl, err := net.Listen(\"tcp\", fmt.Sprintf(\"%v:%d\", addr, firstTry))\n\tif err == nil {\n\t\treturn hl, nil\n\t}\n\tfor i := low; i < high; i++ {\n\t\thl, err := net.Listen(\"tcp\", fmt.Sprintf(\"%v:%d\", addr, i))\n\t\tif err == nil {\n\t\t\treturn hl, nil\n\t\t}\n\t}\n\treturn nil, fmt.Errorf(\"Could not find open port.\")\n}\n\nfunc getTLSConfig(path string) (t *tls.Config, err error) {\n\tconfig := &tls.Config{}\n\tif config.NextProtos == nil {\n\t\tconfig.NextProtos = []string{\"http/1.1\"}\n\t}\n\tconfig.Certificates = make([]tls.Certificate, 1)\n\tconfig.Certificates[0], err = tls.LoadX509KeyPair(path, path)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn config, nil\n}\n\n// This filthy hack works in conjunction with hostPortStrip to restore the\n// original request host after mux match.\nfunc revertOriginalHost(r *http.Request) {\n\toriginal := r.Header.Get(\"_devd_original_host\")\n\tif original != \"\" {\n\t\tr.Host = original\n\t\tr.Header.Del(\"_devd_original_host\")\n\t}\n}\n\n// We can remove the mangling once this is fixed:\n// \t\thttps://github.com/golang/go/issues/10463\nfunc hostPortStrip(next http.Handler) http.Handler {\n\treturn http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\thost, _, err := net.SplitHostPort(r.Host)\n\t\tif err == nil {\n\t\t\toriginal := r.Host\n\t\t\tr.Host = host\n\t\t\tr.Header.Set(\"_devd_original_host\", original)\n\t\t}\n\t\tnext.ServeHTTP(w, r)\n\t})\n}\n\nfunc matchStringAny(regexps []*regexp.Regexp, s string) bool {\n\tfor _, r := range regexps {\n\t\tif r.MatchString(s) {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\nfunc formatURL(tls bool, httpIP string, port int) string {\n\tproto := \"http\"\n\tif tls {\n\t\tproto = \"https\"\n\t}\n\thost := httpIP\n\tif httpIP == \"0.0.0.0\" || httpIP == \"127.0.0.1\" {\n\t\thost = \"devd.io\"\n\t}\n\tif port == 443 && tls {\n\t\treturn fmt.Sprintf(\"https://%s\", host)\n\t}\n\tif port == 80 && !tls {\n\t\treturn fmt.Sprintf(\"http://%s\", host)\n\t}\n\treturn fmt.Sprintf(\"%s://%s:%d\", proto, host, port)\n}\n\n// Credentials is a simple username/password pair\ntype Credentials struct {\n\tusername string\n\tpassword string\n}\n\n// CredentialsFromSpec creates a set of credentials from a spec\nfunc CredentialsFromSpec(spec string) (*Credentials, error) {\n\tparts := strings.SplitN(spec, \":\", 2)\n\tif len(parts) != 2 || parts[0] == \"\" || parts[1] == \"\" {\n\t\treturn nil, fmt.Errorf(\"Invalid credential spec: %s\", spec)\n\t}\n\treturn &Credentials{parts[0], parts[1]}, nil\n}\n\n// Devd represents the devd server options\ntype Devd struct {\n\tRoutes RouteCollection\n\n\t// Shaping\n\tLatency       int\n\tDownKbps      uint\n\tUpKbps        uint\n\tServingScheme string\n\n\t// Add headers\n\tAddHeaders *http.Header\n\n\t// Livereload and watch static routes\n\tLivereloadRoutes bool\n\t// Livereload, but don't watch static routes\n\tLivereload bool\n\tWatchPaths []string\n\tExcludes   []string\n\n\t// Add Access-Control-Allow-Origin header\n\tCors bool\n\n\t// Logging\n\tIgnoreLogs []*regexp.Regexp\n\n\t// Password protection\n\tCredentials *Credentials\n\n\tlrserver *livereload.Server\n}\n\n// WrapHandler wraps an httpctx.Handler in the paraphernalia needed by devd for\n// logging, latency, and so forth.\nfunc (dd *Devd) WrapHandler(log termlog.TermLog, next httpctx.Handler) http.Handler {\n\th := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tr.URL.Scheme = dd.ServingScheme\n\t\trevertOriginalHost(r)\n\t\ttimr := timer.Timer{}\n\t\tsublog := log.Group()\n\t\tdefer func() {\n\t\t\ttiming := termlog.DefaultPalette.Timestamp.SprintFunc()(\"timing: \")\n\t\t\tsublog.SayAs(\"timer\", timing+timr.String())\n\t\t\tsublog.Done()\n\t\t}()\n\t\tif matchStringAny(dd.IgnoreLogs, fmt.Sprintf(\"%s%s\", r.URL.Host, r.RequestURI)) {\n\t\t\tsublog.Quiet()\n\t\t}\n\t\ttimr.RequestHeaders()\n\t\ttime.Sleep(time.Millisecond * time.Duration(dd.Latency))\n\n\t\tdpath := r.RequestURI\n\t\tif !strings.HasPrefix(dpath, \"/\") {\n\t\t\tdpath = \"/\" + dpath\n\t\t}\n\t\tsublog.Say(\"%s %s\", r.Method, dpath)\n\t\tLogHeader(sublog, r.Header)\n\t\tctx := timr.NewContext(context.Background())\n\t\tctx = termlog.NewContext(ctx, sublog)\n\t\tif dd.AddHeaders != nil {\n\t\t\tfor h, vals := range *dd.AddHeaders {\n\t\t\t\tfor _, v := range vals {\n\t\t\t\t\tw.Header().Set(h, v)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif dd.Cors {\n\t\t\torigin := r.Header.Get(\"Origin\")\n\t\t\tif origin == \"\" {\n\t\t\t\torigin = \"*\"\n\t\t\t}\n\t\t\tw.Header().Set(\"Access-Control-Allow-Origin\", origin)\n\t\t\trequestHeaders := r.Header.Get(\"Access-Control-Request-Headers\")\n\t\t\tif requestHeaders != \"\" {\n\t\t\t\tw.Header().Set(\"Access-Control-Allow-Headers\", requestHeaders)\n\t\t\t}\n\t\t\trequestMethod := r.Header.Get(\"Access-Control-Request-Method\")\n\t\t\tif requestMethod != \"\" {\n\t\t\t\tw.Header().Set(\"Access-Control-Allow-Methods\", requestMethod)\n\t\t\t}\n\t\t}\n\t\tflusher, _ := w.(http.Flusher)\n\t\tnext.ServeHTTPContext(\n\t\t\tctx,\n\t\t\t&ResponseLogWriter{Log: sublog, Resp: w, Flusher: flusher, Timer: &timr},\n\t\t\tr,\n\t\t)\n\t})\n\treturn h\n}\n\n// HasLivereload tells us if livereload is enabled\nfunc (dd *Devd) HasLivereload() bool {\n\tif dd.Livereload || dd.LivereloadRoutes || len(dd.WatchPaths) > 0 {\n\t\treturn true\n\t}\n\treturn false\n}\n\n// AddRoutes adds route specifications to the server\nfunc (dd *Devd) AddRoutes(specs []string, notfound []string) error {\n\tdd.Routes = make(RouteCollection)\n\tfor _, s := range specs {\n\t\terr := dd.Routes.Add(s, notfound)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"Invalid route specification: %s\", err)\n\t\t}\n\t}\n\treturn nil\n}\n\n// AddIgnores adds log ignore patterns to the server\nfunc (dd *Devd) AddIgnores(specs []string) error {\n\tdd.IgnoreLogs = make([]*regexp.Regexp, 0, 0)\n\tfor _, expr := range specs {\n\t\tv, err := regexp.Compile(expr)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"%s\", err)\n\t\t}\n\t\tdd.IgnoreLogs = append(dd.IgnoreLogs, v)\n\t}\n\treturn nil\n}\n\n// HandleNotFound handles pages not found. In particular, this handler is used\n// when we have no matching route for a request. This also means it's not\n// useful to inject the livereload paraphernalia here.\nfunc HandleNotFound(templates *template.Template) httpctx.Handler {\n\treturn httpctx.HandlerFunc(func(ctx context.Context, w http.ResponseWriter, r *http.Request) {\n\t\tw.WriteHeader(http.StatusNotFound)\n\t\terr := templates.Lookup(\"404.html\").Execute(w, nil)\n\t\tif err != nil {\n\t\t\tlogger := termlog.FromContext(ctx)\n\t\t\tlogger.Shout(\"Could not execute template: %s\", err)\n\t\t}\n\t})\n}\n\n// Router constructs the main Devd router that serves all requests\nfunc (dd *Devd) Router(logger termlog.TermLog, templates *template.Template) (http.Handler, error) {\n\tmux := http.NewServeMux()\n\thasGlobal := false\n\n\tci := inject.CopyInject{}\n\tif dd.HasLivereload() {\n\t\tci = livereload.Injector\n\t}\n\n\tfor match, route := range dd.Routes {\n\t\tif match == \"/\" {\n\t\t\thasGlobal = true\n\t\t}\n\t\thandler := dd.WrapHandler(\n\t\t\tlogger,\n\t\t\troute.Endpoint.Handler(route.Path, templates, ci),\n\t\t)\n\t\tmux.Handle(match, handler)\n\t}\n\tif dd.HasLivereload() {\n\t\tlr := livereload.NewServer(\"livereload\", logger)\n\t\tmux.Handle(livereload.EndpointPath, lr)\n\t\tmux.Handle(livereload.ScriptPath, http.HandlerFunc(lr.ServeScript))\n\t\tseen := make(map[string]bool)\n\t\tfor _, route := range dd.Routes {\n\t\t\tif _, ok := seen[route.Host]; route.Host != \"\" && ok == false {\n\t\t\t\tmux.Handle(route.Host+livereload.EndpointPath, lr)\n\t\t\t\tmux.Handle(\n\t\t\t\t\troute.Host+livereload.ScriptPath,\n\t\t\t\t\thttp.HandlerFunc(lr.ServeScript),\n\t\t\t\t)\n\t\t\t\tseen[route.Host] = true\n\t\t\t}\n\t\t}\n\t\tif dd.LivereloadRoutes {\n\t\t\terr := WatchRoutes(dd.Routes, lr, dd.Excludes, logger)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, fmt.Errorf(\"Could not watch routes for livereload: %s\", err)\n\t\t\t}\n\t\t}\n\t\tif len(dd.WatchPaths) > 0 {\n\t\t\terr := WatchPaths(dd.WatchPaths, dd.Excludes, lr, logger)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, fmt.Errorf(\"Could not watch path for livereload: %s\", err)\n\t\t\t}\n\t\t}\n\t\tdd.lrserver = lr\n\t}\n\tif !hasGlobal {\n\t\tmux.Handle(\n\t\t\t\"/\",\n\t\t\tdd.WrapHandler(logger, HandleNotFound(templates)),\n\t\t)\n\t}\n\tvar h = http.Handler(mux)\n\tif dd.Credentials != nil {\n\t\th = httpauth.SimpleBasicAuth(\n\t\t\tdd.Credentials.username, dd.Credentials.password,\n\t\t)(h)\n\t}\n\treturn hostPortStrip(h), nil\n}\n\n// Serve starts the devd server. The callback is called with the serving URL\n// just before service starts.\nfunc (dd *Devd) Serve(address string, port int, certFile string, logger termlog.TermLog, callback func(string)) error {\n\ttemplates, err := ricetemp.MakeTemplates(rice.MustFindBox(\"templates\"))\n\tif err != nil {\n\t\treturn fmt.Errorf(\"Error loading templates: %s\", err)\n\t}\n\tmux, err := dd.Router(logger, templates)\n\tif err != nil {\n\t\treturn err\n\t}\n\tvar tlsConfig *tls.Config\n\tvar tlsEnabled bool\n\tif certFile != \"\" {\n\t\ttlsConfig, err = getTLSConfig(certFile)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"Could not load certs: %s\", err)\n\t\t}\n\t\ttlsEnabled = true\n\t}\n\n\tvar hl net.Listener\n\tif port > 0 {\n\t\thl, err = net.Listen(\"tcp\", fmt.Sprintf(\"%v:%d\", address, port))\n\t} else {\n\t\thl, err = pickPort(address, portLow, portHigh, tlsEnabled)\n\t}\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif tlsConfig != nil {\n\t\thl = tls.NewListener(hl, tlsConfig)\n\t}\n\n\thl = slowdown.NewSlowListener(hl, dd.UpKbps*1024, dd.DownKbps*1024)\n\turl := formatURL(tlsEnabled, address, hl.Addr().(*net.TCPAddr).Port)\n\tlogger.Say(\"Listening on %s (%s)\", url, hl.Addr().String())\n\tserver := &http.Server{Addr: hl.Addr().String(), Handler: mux}\n\tcallback(url)\n\n\tif dd.HasLivereload() {\n\t\tc := make(chan os.Signal, 1)\n\t\tsignal.Notify(c, syscall.SIGHUP)\n\t\tgo func() {\n\t\t\tfor {\n\t\t\t\t<-c\n\t\t\t\tlogger.Say(\"Received signal - reloading\")\n\t\t\t\tdd.lrserver.Reload([]string{\"*\"})\n\t\t\t}\n\t\t}()\n\t}\n\n\terr = server.Serve(hl)\n\tlogger.Shout(\"Server stopped: %v\", err)\n\treturn nil\n}\n"
        },
        {
          "name": "server_test.go",
          "type": "blob",
          "size": 2.7294921875,
          "content": "package devd\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n\n\t\"github.com/GeertJohan/go.rice\"\n\t\"github.com/cortesi/devd/inject\"\n\t\"github.com/cortesi/devd/ricetemp\"\n\t\"github.com/cortesi/termlog\"\n)\n\nvar formatURLTests = []struct {\n\ttls    bool\n\taddr   string\n\tport   int\n\toutput string\n}{\n\t{true, \"127.0.0.1\", 8000, \"https://devd.io:8000\"},\n\t{false, \"127.0.0.1\", 8000, \"http://devd.io:8000\"},\n\t{false, \"127.0.0.1\", 80, \"http://devd.io\"},\n\t{true, \"127.0.0.1\", 443, \"https://devd.io\"},\n\t{false, \"127.0.0.1\", 443, \"http://devd.io:443\"},\n}\n\nfunc TestFormatURL(t *testing.T) {\n\tfor i, tt := range formatURLTests {\n\t\turl := formatURL(tt.tls, tt.addr, tt.port)\n\t\tif url != tt.output {\n\t\t\tt.Errorf(\"Test %d, expected \\\"%s\\\" got \\\"%s\\\"\", i, tt.output, url)\n\t\t}\n\t}\n}\n\nfunc TestPickPort(t *testing.T) {\n\t_, err := pickPort(\"127.0.0.1\", 8000, 10000, true)\n\tif err != nil {\n\t\tt.Errorf(\"Could not bind to any port: %s\", err)\n\t}\n\t_, err = pickPort(\"127.0.0.1\", 8000, 8000, true)\n\tif err == nil {\n\t\tt.Errorf(\"Expected not to be able to bind to any port\")\n\t}\n\n}\n\nfunc fsEndpoint(s string) *filesystemEndpoint {\n\te, _ := newFilesystemEndpoint(s, []string{})\n\treturn e\n}\n\nfunc TestDevdRouteHandler(t *testing.T) {\n\tlogger := termlog.NewLog()\n\tlogger.Quiet()\n\tr := Route{\"\", \"/\", fsEndpoint(\"./testdata\")}\n\ttemplates := ricetemp.MustMakeTemplates(rice.MustFindBox(\"templates\"))\n\tci := inject.CopyInject{}\n\n\tdevd := Devd{LivereloadRoutes: true}\n\th := devd.WrapHandler(logger, r.Endpoint.Handler(\"\", templates, ci))\n\tht := handlerTester{t, h}\n\n\tAssertCode(t, ht.Request(\"GET\", \"/\", nil), 200)\n}\n\nfunc TestDevdHandler(t *testing.T) {\n\tlogger := termlog.NewLog()\n\tlogger.Quiet()\n\ttemplates := ricetemp.MustMakeTemplates(rice.MustFindBox(\"templates\"))\n\n\tdevd := Devd{LivereloadRoutes: true, WatchPaths: []string{\"./\"}}\n\terr := devd.AddRoutes([]string{\"./\"}, []string{})\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n\th, err := devd.Router(logger, templates)\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n\tht := handlerTester{t, h}\n\n\tAssertCode(t, ht.Request(\"GET\", \"/\", nil), 200)\n\tAssertCode(t, ht.Request(\"GET\", \"/nonexistent\", nil), 404)\n}\n\nfunc TestGetTLSConfig(t *testing.T) {\n\t_, err := getTLSConfig(\"nonexistent\")\n\tif err == nil {\n\t\tt.Error(\"Expected failure, found success.\")\n\t}\n\t_, err = getTLSConfig(\"./testdata/certbundle.pem\")\n\tif err != nil {\n\t\tt.Errorf(\"Could not get TLS config: %s\", err)\n\t}\n}\n\nvar credentialsTests = []struct {\n\tspec  string\n\tcreds *Credentials\n}{\n\t{\"foo:bar\", &Credentials{\"foo\", \"bar\"}},\n\t{\"foo:\", nil},\n\t{\":bar\", nil},\n\t{\"foo:bar:voing\", &Credentials{\"foo\", \"bar:voing\"}},\n\t{\"foo\", nil},\n}\n\nfunc TestCredentials(t *testing.T) {\n\tfor i, data := range credentialsTests {\n\t\tgot, _ := CredentialsFromSpec(data.spec)\n\t\tif !reflect.DeepEqual(data.creds, got) {\n\t\t\tt.Errorf(\"%d: got %v, expected %v\", i, got, data.creds)\n\t\t}\n\t}\n}\n"
        },
        {
          "name": "slowdown",
          "type": "tree",
          "content": null
        },
        {
          "name": "templates",
          "type": "tree",
          "content": null
        },
        {
          "name": "testdata",
          "type": "tree",
          "content": null
        },
        {
          "name": "timer",
          "type": "tree",
          "content": null
        },
        {
          "name": "watch.go",
          "type": "blob",
          "size": 1.876953125,
          "content": "package devd\n\nimport (\n\t\"os\"\n\t\"time\"\n\n\t\"github.com/cortesi/devd/livereload\"\n\t\"github.com/cortesi/moddwatch\"\n\t\"github.com/cortesi/termlog\"\n)\n\nconst batchTime = time.Millisecond * 200\n\n// Watch watches an endpoint for changes, if it supports them.\nfunc (r Route) Watch(\n\tch chan []string,\n\texcludePatterns []string,\n\tlog termlog.Logger,\n) (*moddwatch.Watcher, error) {\n\twd, err := os.Getwd()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tvar watcher *moddwatch.Watcher\n\tswitch r.Endpoint.(type) {\n\tcase *filesystemEndpoint:\n\t\tep := *r.Endpoint.(*filesystemEndpoint)\n\t\tmodchan := make(chan *moddwatch.Mod, 1)\n\t\twatcher, err = moddwatch.Watch(\n\t\t\twd,\n\t\t\t[]string{ep.Root + \"/...\", \"**\"},\n\t\t\texcludePatterns,\n\t\t\tbatchTime,\n\t\t\tmodchan,\n\t\t)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tgo func() {\n\t\t\tfor mod := range modchan {\n\t\t\t\tif !mod.Empty() {\n\t\t\t\t\tch <- mod.All()\n\t\t\t\t}\n\t\t\t}\n\t\t}()\n\t}\n\treturn watcher, nil\n}\n\n// WatchPaths watches a set of paths, and broadcasts changes through reloader.\nfunc WatchPaths(paths, excludePatterns []string, reloader livereload.Reloader, log termlog.Logger) error {\n\twd, err := os.Getwd()\n\tif err != nil {\n\t\treturn err\n\t}\n\tch := make(chan []string, 1)\n\tfor _, path := range paths {\n\t\tmodchan := make(chan *moddwatch.Mod, 1)\n\t\t_, err := moddwatch.Watch(\n\t\t\twd,\n\t\t\t[]string{path},\n\t\t\texcludePatterns,\n\t\t\tbatchTime,\n\t\t\tmodchan,\n\t\t)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tgo func() {\n\t\t\tfor mod := range modchan {\n\t\t\t\tif !mod.Empty() {\n\t\t\t\t\tch <- mod.All()\n\t\t\t\t}\n\t\t\t}\n\t\t}()\n\t}\n\tgo reloader.Watch(ch)\n\treturn nil\n}\n\n// WatchRoutes watches the route collection, and broadcasts changes through reloader.\nfunc WatchRoutes(routes RouteCollection, reloader livereload.Reloader, excludePatterns []string, log termlog.Logger) error {\n\tc := make(chan []string, 1)\n\tfor i := range routes {\n\t\t_, err := routes[i].Watch(c, excludePatterns, log)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\tgo reloader.Watch(c)\n\treturn nil\n}\n"
        },
        {
          "name": "watch_test.go",
          "type": "blob",
          "size": 1.7001953125,
          "content": "package devd\n\nimport (\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"os\"\n\t\"sync\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/cortesi/moddwatch\"\n\t\"github.com/cortesi/termlog\"\n)\n\nfunc addTempFile(t *testing.T, tmpFolder string, fname string, content string) {\n\tif err := ioutil.WriteFile(tmpFolder+\"/\"+fname, []byte(content), 0644); err != nil {\n\t\tt.Error(err)\n\t}\n}\n\nfunc TestRouteWatch(t *testing.T) {\n\tlogger := termlog.NewLog()\n\tlogger.Quiet()\n\n\ttmpFolder, err := ioutil.TempDir(\"\", \"\")\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n\tdefer os.RemoveAll(tmpFolder)\n\n\t// Ensure that using . for the path works:\n\tos.Chdir(tmpFolder)\n\troutes := make(RouteCollection)\n\troutes.Add(\".\", nil)\n\n\tchangedFiles := make(map[string]int)\n\tch := make(chan []string, 1024)\n\n\tvar exited sync.WaitGroup\n\texited.Add(1)\n\tvar lck sync.Mutex\n\tgo func() {\n\t\tfor {\n\t\t\tdata, more := <-ch\n\t\t\tif more {\n\t\t\t\tfor i := range data {\n\t\t\t\t\tlck.Lock()\n\t\t\t\t\tfmt.Println(data)\n\t\t\t\t\tif _, ok := changedFiles[data[i]]; !ok {\n\t\t\t\t\t\tchangedFiles[data[i]] = 1\n\t\t\t\t\t}\n\t\t\t\t\tlck.Unlock()\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\texited.Done()\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t}()\n\twatchers := make([]*moddwatch.Watcher, len(routes))\n\ti := 0\n\tfor r := range routes {\n\t\twatcher, err := routes[r].Watch(ch, nil, logger)\n\t\twatchers[i] = watcher\n\t\tif err != nil {\n\t\t\tt.Error(err)\n\t\t}\n\t\ti++\n\t}\n\n\taddTempFile(t, tmpFolder, \"a.txt\", \"foo\\n\")\n\taddTempFile(t, tmpFolder, \"c.txt\", \"bar\\n\")\n\taddTempFile(t, tmpFolder, \"another.file.txt\", \"bar\\n\")\n\n\tfor i := 0; i < 100; i++ {\n\t\tlck.Lock()\n\t\tif len(changedFiles) >= 3 {\n\t\t\tlck.Unlock()\n\t\t\tbreak\n\t\t}\n\t\tlck.Unlock()\n\t\ttime.Sleep(50 * time.Millisecond)\n\t}\n\n\tfor _, v := range watchers {\n\t\tv.Stop()\n\t}\n\tclose(ch)\n\n\texited.Wait()\n\n\tif len(changedFiles) != 3 {\n\t\tt.Errorf(\"wanted 3 changed files, got %d\", len(changedFiles))\n\t}\n}\n"
        }
      ]
    }
  ]
}