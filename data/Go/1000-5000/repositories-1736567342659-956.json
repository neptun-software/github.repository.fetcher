{
  "metadata": {
    "timestamp": 1736567342659,
    "page": 956,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjk2MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "tidwall/redcon",
      "stars": 2197,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.0517578125,
          "content": "The MIT License (MIT)\n\nCopyright (c) 2016 Josh Baker\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of\nthis software and associated documentation files (the \"Software\"), to deal in\nthe Software without restriction, including without limitation the rights to\nuse, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of\nthe Software, and to permit persons to whom the Software is furnished to do so,\nsubject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS\nFOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR\nCOPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER\nIN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\nCONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 4.87890625,
          "content": "<p align=\"center\">\n<img \n    src=\"logo.png\" \n    width=\"336\" border=\"0\" alt=\"REDCON\">\n<br>\n<a href=\"https://godoc.org/github.com/tidwall/redcon\"><img src=\"https://img.shields.io/badge/api-reference-blue.svg?style=flat-square\" alt=\"GoDoc\"></a>\n</p>\n\n<p align=\"center\">Redis compatible server framework for Go</p>\n\nFeatures\n--------\n- Create a [Fast](#benchmarks) custom Redis compatible server in Go\n- Simple interface. One function `ListenAndServe` and two types `Conn` & `Command`\n- Support for pipelining and telnet commands\n- Works with Redis clients such as [redigo](https://github.com/garyburd/redigo), [redis-py](https://github.com/andymccurdy/redis-py), [node_redis](https://github.com/NodeRedis/node_redis), and [jedis](https://github.com/xetorthio/jedis)\n- [TLS Support](#tls-example)\n- Compatible pub/sub support\n- Multithreaded\n\n*This library is also avaliable for [Rust](https://github.com/tidwall/redcon.rs) and [C](https://github.com/tidwall/redcon.c).*\n\nInstalling\n----------\n\n```\ngo get -u github.com/tidwall/redcon\n```\n\nExample\n-------\n\nHere's a full example of a Redis clone that accepts:\n\n- SET key value\n- GET key\n- DEL key\n- PING\n- QUIT\n- PUBLISH channel message\n- SUBSCRIBE channel\n\nYou can run this example from a terminal:\n\n```sh\ngo run example/clone.go\n```\n\n```go\npackage main\n\nimport (\n\t\"log\"\n\t\"strings\"\n\t\"sync\"\n\n\t\"github.com/tidwall/redcon\"\n)\n\nvar addr = \":6380\"\n\nfunc main() {\n\tvar mu sync.RWMutex\n\tvar items = make(map[string][]byte)\n\tvar ps redcon.PubSub\n\tgo log.Printf(\"started server at %s\", addr)\n\terr := redcon.ListenAndServe(addr,\n\t\tfunc(conn redcon.Conn, cmd redcon.Command) {\n\t\t\tswitch strings.ToLower(string(cmd.Args[0])) {\n\t\t\tdefault:\n\t\t\t\tconn.WriteError(\"ERR unknown command '\" + string(cmd.Args[0]) + \"'\")\n\t\t\tcase \"ping\":\n\t\t\t\tconn.WriteString(\"PONG\")\n\t\t\tcase \"quit\":\n\t\t\t\tconn.WriteString(\"OK\")\n\t\t\t\tconn.Close()\n\t\t\tcase \"set\":\n\t\t\t\tif len(cmd.Args) != 3 {\n\t\t\t\t\tconn.WriteError(\"ERR wrong number of arguments for '\" + string(cmd.Args[0]) + \"' command\")\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tmu.Lock()\n\t\t\t\titems[string(cmd.Args[1])] = cmd.Args[2]\n\t\t\t\tmu.Unlock()\n\t\t\t\tconn.WriteString(\"OK\")\n\t\t\tcase \"get\":\n\t\t\t\tif len(cmd.Args) != 2 {\n\t\t\t\t\tconn.WriteError(\"ERR wrong number of arguments for '\" + string(cmd.Args[0]) + \"' command\")\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tmu.RLock()\n\t\t\t\tval, ok := items[string(cmd.Args[1])]\n\t\t\t\tmu.RUnlock()\n\t\t\t\tif !ok {\n\t\t\t\t\tconn.WriteNull()\n\t\t\t\t} else {\n\t\t\t\t\tconn.WriteBulk(val)\n\t\t\t\t}\n\t\t\tcase \"del\":\n\t\t\t\tif len(cmd.Args) != 2 {\n\t\t\t\t\tconn.WriteError(\"ERR wrong number of arguments for '\" + string(cmd.Args[0]) + \"' command\")\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tmu.Lock()\n\t\t\t\t_, ok := items[string(cmd.Args[1])]\n\t\t\t\tdelete(items, string(cmd.Args[1]))\n\t\t\t\tmu.Unlock()\n\t\t\t\tif !ok {\n\t\t\t\t\tconn.WriteInt(0)\n\t\t\t\t} else {\n\t\t\t\t\tconn.WriteInt(1)\n\t\t\t\t}\n\t\t\tcase \"publish\":\n\t\t\t\tif len(cmd.Args) != 3 {\n\t\t\t\t\tconn.WriteError(\"ERR wrong number of arguments for '\" + string(cmd.Args[0]) + \"' command\")\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tconn.WriteInt(ps.Publish(string(cmd.Args[1]), string(cmd.Args[2])))\n\t\t\tcase \"subscribe\", \"psubscribe\":\n\t\t\t\tif len(cmd.Args) < 2 {\n\t\t\t\t\tconn.WriteError(\"ERR wrong number of arguments for '\" + string(cmd.Args[0]) + \"' command\")\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tcommand := strings.ToLower(string(cmd.Args[0]))\n\t\t\t\tfor i := 1; i < len(cmd.Args); i++ {\n\t\t\t\t\tif command == \"psubscribe\" {\n\t\t\t\t\t\tps.Psubscribe(conn, string(cmd.Args[i]))\n\t\t\t\t\t} else {\n\t\t\t\t\t\tps.Subscribe(conn, string(cmd.Args[i]))\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\tfunc(conn redcon.Conn) bool {\n\t\t\t// Use this function to accept or deny the connection.\n\t\t\t// log.Printf(\"accept: %s\", conn.RemoteAddr())\n\t\t\treturn true\n\t\t},\n\t\tfunc(conn redcon.Conn, err error) {\n\t\t\t// This is called when the connection has been closed\n\t\t\t// log.Printf(\"closed: %s, err: %v\", conn.RemoteAddr(), err)\n\t\t},\n\t)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n}\n```\n\nTLS Example\n-----------\n\nRedcon has full TLS support through the `ListenAndServeTLS` function.\n\nThe [same example](example/tls/clone.go) is also provided for serving Redcon over TLS. \n\n```sh\ngo run example/tls/clone.go\n```\n\nBenchmarks\n----------\n\n**Redis**: Single-threaded, no disk persistence.\n\n```\n$ redis-server --port 6379 --appendonly no\n```\n```\nredis-benchmark -p 6379 -t set,get -n 10000000 -q -P 512 -c 512\nSET: 941265.12 requests per second\nGET: 1189909.50 requests per second\n```\n\n**Redcon**: Single-threaded, no disk persistence.\n\n```\n$ GOMAXPROCS=1 go run example/clone.go\n```\n```\nredis-benchmark -p 6380 -t set,get -n 10000000 -q -P 512 -c 512\nSET: 2018570.88 requests per second\nGET: 2403846.25 requests per second\n```\n\n**Redcon**: Multi-threaded, no disk persistence.\n\n```\n$ GOMAXPROCS=0 go run example/clone.go\n```\n```\n$ redis-benchmark -p 6380 -t set,get -n 10000000 -q -P 512 -c 512\nSET: 1944390.38 requests per second\nGET: 3993610.25 requests per second\n```\n\n*Running on a MacBook Pro 15\" 2.8 GHz Intel Core i7 using Go 1.7*\n\nContact\n-------\nJosh Baker [@tidwall](http://twitter.com/tidwall)\n\nLicense\n-------\nRedcon source code is available under the MIT [License](/LICENSE).\n"
        },
        {
          "name": "example",
          "type": "tree",
          "content": null
        },
        {
          "name": "go.mod",
          "type": "blob",
          "size": 0.1181640625,
          "content": "module github.com/tidwall/redcon\n\ngo 1.15\n\nrequire (\n\tgithub.com/tidwall/btree v1.1.0\n\tgithub.com/tidwall/match v1.1.1\n)\n"
        },
        {
          "name": "go.sum",
          "type": "blob",
          "size": 0.326171875,
          "content": "github.com/tidwall/btree v1.1.0 h1:5P+9WU8ui5uhmcg3SoPyTwoI0mVyZ1nps7YQzTZFkYM=\ngithub.com/tidwall/btree v1.1.0/go.mod h1:TzIRzen6yHbibdSfK6t8QimqbUnoxUSrZfeW7Uob0q4=\ngithub.com/tidwall/match v1.1.1 h1:+Ho715JplO36QYgwN9PGYNhgZvoUSc9X2c80KVTi+GA=\ngithub.com/tidwall/match v1.1.1/go.mod h1:eRSPERbgtNPcGhD8UCthc6PmLEQXEWd3PRB5JTxsfmM=\n"
        },
        {
          "name": "logo.png",
          "type": "blob",
          "size": 23.5390625,
          "content": null
        },
        {
          "name": "redcon.go",
          "type": "blob",
          "size": 33.6435546875,
          "content": "// Package redcon implements a Redis compatible server framework\npackage redcon\n\nimport (\n\t\"bufio\"\n\t\"crypto/tls\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"net\"\n\t\"strings\"\n\t\"sync\"\n\t\"time\"\n\n\t\"github.com/tidwall/btree\"\n\t\"github.com/tidwall/match\"\n)\n\nvar (\n\terrUnbalancedQuotes       = &errProtocol{\"unbalanced quotes in request\"}\n\terrInvalidBulkLength      = &errProtocol{\"invalid bulk length\"}\n\terrInvalidMultiBulkLength = &errProtocol{\"invalid multibulk length\"}\n\terrDetached               = errors.New(\"detached\")\n\terrIncompleteCommand      = errors.New(\"incomplete command\")\n\terrTooMuchData            = errors.New(\"too much data\")\n)\n\nconst maxBufferCap = 262144\n\ntype errProtocol struct {\n\tmsg string\n}\n\nfunc (err *errProtocol) Error() string {\n\treturn \"Protocol error: \" + err.msg\n}\n\n// Conn represents a client connection\ntype Conn interface {\n\t// RemoteAddr returns the remote address of the client connection.\n\tRemoteAddr() string\n\t// Close closes the connection.\n\tClose() error\n\t// WriteError writes an error to the client.\n\tWriteError(msg string)\n\t// WriteString writes a string to the client.\n\tWriteString(str string)\n\t// WriteBulk writes bulk bytes to the client.\n\tWriteBulk(bulk []byte)\n\t// WriteBulkString writes a bulk string to the client.\n\tWriteBulkString(bulk string)\n\t// WriteInt writes an integer to the client.\n\tWriteInt(num int)\n\t// WriteInt64 writes a 64-bit signed integer to the client.\n\tWriteInt64(num int64)\n\t// WriteUint64 writes a 64-bit unsigned integer to the client.\n\tWriteUint64(num uint64)\n\t// WriteArray writes an array header. You must then write additional\n\t// sub-responses to the client to complete the response.\n\t// For example to write two strings:\n\t//\n\t//   c.WriteArray(2)\n\t//   c.WriteBulkString(\"item 1\")\n\t//   c.WriteBulkString(\"item 2\")\n\tWriteArray(count int)\n\t// WriteNull writes a null to the client\n\tWriteNull()\n\t// WriteRaw writes raw data to the client.\n\tWriteRaw(data []byte)\n\t// WriteAny writes any type to the client.\n\t//   nil             -> null\n\t//   error           -> error (adds \"ERR \" when first word is not uppercase)\n\t//   string          -> bulk-string\n\t//   numbers         -> bulk-string\n\t//   []byte          -> bulk-string\n\t//   bool            -> bulk-string (\"0\" or \"1\")\n\t//   slice           -> array\n\t//   map             -> array with key/value pairs\n\t//   SimpleString    -> string\n\t//   SimpleInt       -> integer\n\t//   everything-else -> bulk-string representation using fmt.Sprint()\n\tWriteAny(any interface{})\n\t// Context returns a user-defined context\n\tContext() interface{}\n\t// SetContext sets a user-defined context\n\tSetContext(v interface{})\n\t// SetReadBuffer updates the buffer read size for the connection\n\tSetReadBuffer(bytes int)\n\t// Detach return a connection that is detached from the server.\n\t// Useful for operations like PubSub.\n\t//\n\t//   dconn := conn.Detach()\n\t//   go func(){\n\t//       defer dconn.Close()\n\t//       cmd, err := dconn.ReadCommand()\n\t//       if err != nil{\n\t//           fmt.Printf(\"read failed: %v\\n\", err)\n\t//\t         return\n\t//       }\n\t//       fmt.Printf(\"received command: %v\", cmd)\n\t//       hconn.WriteString(\"OK\")\n\t//       if err := dconn.Flush(); err != nil{\n\t//           fmt.Printf(\"write failed: %v\\n\", err)\n\t//\t         return\n\t//       }\n\t//   }()\n\tDetach() DetachedConn\n\t// ReadPipeline returns all commands in current pipeline, if any\n\t// The commands are removed from the pipeline.\n\tReadPipeline() []Command\n\t// PeekPipeline returns all commands in current pipeline, if any.\n\t// The commands remain in the pipeline.\n\tPeekPipeline() []Command\n\t// NetConn returns the base net.Conn connection\n\tNetConn() net.Conn\n}\n\n// NewServer returns a new Redcon server configured on \"tcp\" network net.\nfunc NewServer(addr string,\n\thandler func(conn Conn, cmd Command),\n\taccept func(conn Conn) bool,\n\tclosed func(conn Conn, err error),\n) *Server {\n\treturn NewServerNetwork(\"tcp\", addr, handler, accept, closed)\n}\n\n// NewServerTLS returns a new Redcon TLS server configured on \"tcp\" network net.\nfunc NewServerTLS(addr string,\n\thandler func(conn Conn, cmd Command),\n\taccept func(conn Conn) bool,\n\tclosed func(conn Conn, err error),\n\tconfig *tls.Config,\n) *TLSServer {\n\treturn NewServerNetworkTLS(\"tcp\", addr, handler, accept, closed, config)\n}\n\n// NewServerNetwork returns a new Redcon server. The network net must be\n// a stream-oriented network: \"tcp\", \"tcp4\", \"tcp6\", \"unix\" or \"unixpacket\"\nfunc NewServerNetwork(\n\tnet, laddr string,\n\thandler func(conn Conn, cmd Command),\n\taccept func(conn Conn) bool,\n\tclosed func(conn Conn, err error),\n) *Server {\n\tif handler == nil {\n\t\tpanic(\"handler is nil\")\n\t}\n\ts := newServer()\n\ts.net = net\n\ts.laddr = laddr\n\ts.handler = handler\n\ts.accept = accept\n\ts.closed = closed\n\treturn s\n}\n\n// NewServerNetworkTLS returns a new TLS Redcon server. The network net must be\n// a stream-oriented network: \"tcp\", \"tcp4\", \"tcp6\", \"unix\" or \"unixpacket\"\nfunc NewServerNetworkTLS(\n\tnet, laddr string,\n\thandler func(conn Conn, cmd Command),\n\taccept func(conn Conn) bool,\n\tclosed func(conn Conn, err error),\n\tconfig *tls.Config,\n) *TLSServer {\n\tif handler == nil {\n\t\tpanic(\"handler is nil\")\n\t}\n\ts := Server{\n\t\tnet:     net,\n\t\tladdr:   laddr,\n\t\thandler: handler,\n\t\taccept:  accept,\n\t\tclosed:  closed,\n\t\tconns:   make(map[*conn]bool),\n\t}\n\n\ttls := &TLSServer{\n\t\tconfig: config,\n\t\tServer: &s,\n\t}\n\treturn tls\n}\n\n// Close stops listening on the TCP address.\n// Already Accepted connections will be closed.\nfunc (s *Server) Close() error {\n\ts.mu.Lock()\n\tdefer s.mu.Unlock()\n\tif s.ln == nil {\n\t\treturn errors.New(\"not serving\")\n\t}\n\ts.done = true\n\treturn s.ln.Close()\n}\n\n// ListenAndServe serves incoming connections.\nfunc (s *Server) ListenAndServe() error {\n\treturn s.ListenServeAndSignal(nil)\n}\n\n// Addr returns server's listen address\nfunc (s *Server) Addr() net.Addr {\n\treturn s.ln.Addr()\n}\n\n// Close stops listening on the TCP address.\n// Already Accepted connections will be closed.\nfunc (s *TLSServer) Close() error {\n\ts.mu.Lock()\n\tdefer s.mu.Unlock()\n\tif s.ln == nil {\n\t\treturn errors.New(\"not serving\")\n\t}\n\ts.done = true\n\treturn s.ln.Close()\n}\n\n// ListenAndServe serves incoming connections.\nfunc (s *TLSServer) ListenAndServe() error {\n\treturn s.ListenServeAndSignal(nil)\n}\n\nfunc newServer() *Server {\n\ts := &Server{\n\t\tconns: make(map[*conn]bool),\n\t}\n\treturn s\n}\n\n// Serve creates a new server and serves with the given net.Listener.\nfunc Serve(ln net.Listener,\n\thandler func(conn Conn, cmd Command),\n\taccept func(conn Conn) bool,\n\tclosed func(conn Conn, err error),\n) error {\n\ts := newServer()\n\ts.mu.Lock()\n\ts.net = ln.Addr().Network()\n\ts.laddr = ln.Addr().String()\n\ts.ln = ln\n\ts.handler = handler\n\ts.accept = accept\n\ts.closed = closed\n\ts.mu.Unlock()\n\treturn serve(s)\n}\n\n// ListenAndServe creates a new server and binds to addr configured on \"tcp\" network net.\nfunc ListenAndServe(addr string,\n\thandler func(conn Conn, cmd Command),\n\taccept func(conn Conn) bool,\n\tclosed func(conn Conn, err error),\n) error {\n\treturn ListenAndServeNetwork(\"tcp\", addr, handler, accept, closed)\n}\n\n// ListenAndServeTLS creates a new TLS server and binds to addr configured on \"tcp\" network net.\nfunc ListenAndServeTLS(addr string,\n\thandler func(conn Conn, cmd Command),\n\taccept func(conn Conn) bool,\n\tclosed func(conn Conn, err error),\n\tconfig *tls.Config,\n) error {\n\treturn ListenAndServeNetworkTLS(\"tcp\", addr, handler, accept, closed, config)\n}\n\n// ListenAndServeNetwork creates a new server and binds to addr. The network net must be\n// a stream-oriented network: \"tcp\", \"tcp4\", \"tcp6\", \"unix\" or \"unixpacket\"\nfunc ListenAndServeNetwork(\n\tnet, laddr string,\n\thandler func(conn Conn, cmd Command),\n\taccept func(conn Conn) bool,\n\tclosed func(conn Conn, err error),\n) error {\n\treturn NewServerNetwork(net, laddr, handler, accept, closed).ListenAndServe()\n}\n\n// ListenAndServeNetworkTLS creates a new TLS server and binds to addr. The network net must be\n// a stream-oriented network: \"tcp\", \"tcp4\", \"tcp6\", \"unix\" or \"unixpacket\"\nfunc ListenAndServeNetworkTLS(\n\tnet, laddr string,\n\thandler func(conn Conn, cmd Command),\n\taccept func(conn Conn) bool,\n\tclosed func(conn Conn, err error),\n\tconfig *tls.Config,\n) error {\n\treturn NewServerNetworkTLS(net, laddr, handler, accept, closed, config).ListenAndServe()\n}\n\n// ListenServeAndSignal serves incoming connections and passes nil or error\n// when listening. signal can be nil.\nfunc (s *Server) ListenServeAndSignal(signal chan error) error {\n\tln, err := net.Listen(s.net, s.laddr)\n\tif err != nil {\n\t\tif signal != nil {\n\t\t\tsignal <- err\n\t\t}\n\t\treturn err\n\t}\n\ts.mu.Lock()\n\ts.ln = ln\n\ts.mu.Unlock()\n\tif signal != nil {\n\t\tsignal <- nil\n\t}\n\treturn serve(s)\n}\n\n// Serve serves incoming connections with the given net.Listener.\nfunc (s *Server) Serve(ln net.Listener) error {\n\ts.mu.Lock()\n\ts.ln = ln\n\ts.net = ln.Addr().Network()\n\ts.laddr = ln.Addr().String()\n\ts.mu.Unlock()\n\treturn serve(s)\n}\n\n// ListenServeAndSignal serves incoming connections and passes nil or error\n// when listening. signal can be nil.\nfunc (s *TLSServer) ListenServeAndSignal(signal chan error) error {\n\tln, err := tls.Listen(s.net, s.laddr, s.config)\n\tif err != nil {\n\t\tif signal != nil {\n\t\t\tsignal <- err\n\t\t}\n\t\treturn err\n\t}\n\ts.mu.Lock()\n\ts.ln = ln\n\ts.mu.Unlock()\n\tif signal != nil {\n\t\tsignal <- nil\n\t}\n\treturn serve(s.Server)\n}\n\nfunc serve(s *Server) error {\n\tdefer func() {\n\t\ts.ln.Close()\n\t\tfunc() {\n\t\t\ts.mu.Lock()\n\t\t\tdefer s.mu.Unlock()\n\t\t\tfor c := range s.conns {\n\t\t\t\tc.conn.Close()\n\t\t\t}\n\t\t\ts.conns = nil\n\t\t}()\n\t}()\n\tfor {\n\t\tlnconn, err := s.ln.Accept()\n\t\tif err != nil {\n\t\t\ts.mu.Lock()\n\t\t\tdone := s.done\n\t\t\ts.mu.Unlock()\n\t\t\tif done {\n\t\t\t\treturn nil\n\t\t\t}\n\t\t\tif errors.Is(err, net.ErrClosed) {\n\t\t\t\t// see https://github.com/tidwall/redcon/issues/46\n\t\t\t\treturn nil\n\t\t\t}\n\t\t\tif s.AcceptError != nil {\n\t\t\t\ts.AcceptError(err)\n\t\t\t}\n\t\t\tcontinue\n\t\t}\n\t\tc := &conn{\n\t\t\tconn: lnconn,\n\t\t\taddr: lnconn.RemoteAddr().String(),\n\t\t\twr:   NewWriter(lnconn),\n\t\t\trd:   NewReader(lnconn),\n\t\t}\n\t\ts.mu.Lock()\n\t\tc.idleClose = s.idleClose\n\t\ts.conns[c] = true\n\t\ts.mu.Unlock()\n\t\tif s.accept != nil && !s.accept(c) {\n\t\t\ts.mu.Lock()\n\t\t\tdelete(s.conns, c)\n\t\t\ts.mu.Unlock()\n\t\t\tc.Close()\n\t\t\tcontinue\n\t\t}\n\t\tgo handle(s, c)\n\t}\n}\n\n// handle manages the server connection.\nfunc handle(s *Server, c *conn) {\n\tvar err error\n\tdefer func() {\n\t\tif err != errDetached {\n\t\t\t// do not close the connection when a detach is detected.\n\t\t\tc.conn.Close()\n\t\t}\n\t\tfunc() {\n\t\t\t// remove the conn from the server\n\t\t\ts.mu.Lock()\n\t\t\tdefer s.mu.Unlock()\n\t\t\tdelete(s.conns, c)\n\t\t\tif s.closed != nil {\n\t\t\t\tif err == io.EOF {\n\t\t\t\t\terr = nil\n\t\t\t\t}\n\t\t\t\ts.closed(c, err)\n\t\t\t}\n\t\t}()\n\t}()\n\n\terr = func() error {\n\t\t// read commands and feed back to the client\n\t\tfor {\n\t\t\t// read pipeline commands\n\t\t\tif c.idleClose != 0 {\n\t\t\t\tc.conn.SetReadDeadline(time.Now().Add(c.idleClose))\n\t\t\t}\n\t\t\tcmds, err := c.rd.readCommands(nil)\n\t\t\tif err != nil {\n\t\t\t\tif err, ok := err.(*errProtocol); ok {\n\t\t\t\t\t// All protocol errors should attempt a response to\n\t\t\t\t\t// the client. Ignore write errors.\n\t\t\t\t\tc.wr.WriteError(\"ERR \" + err.Error())\n\t\t\t\t\tc.wr.Flush()\n\t\t\t\t}\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tc.cmds = cmds\n\t\t\tfor len(c.cmds) > 0 {\n\t\t\t\tcmd := c.cmds[0]\n\t\t\t\tif len(c.cmds) == 1 {\n\t\t\t\t\tc.cmds = nil\n\t\t\t\t} else {\n\t\t\t\t\tc.cmds = c.cmds[1:]\n\t\t\t\t}\n\t\t\t\ts.handler(c, cmd)\n\t\t\t}\n\t\t\tif c.detached {\n\t\t\t\t// client has been detached\n\t\t\t\treturn errDetached\n\t\t\t}\n\t\t\tif c.closed {\n\t\t\t\treturn nil\n\t\t\t}\n\t\t\tif err := c.wr.Flush(); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t}()\n}\n\n// conn represents a client connection\ntype conn struct {\n\tconn      net.Conn\n\twr        *Writer\n\trd        *Reader\n\taddr      string\n\tctx       interface{}\n\tdetached  bool\n\tclosed    bool\n\tcmds      []Command\n\tidleClose time.Duration\n}\n\nfunc (c *conn) Close() error {\n\tc.wr.Flush()\n\tc.closed = true\n\treturn c.conn.Close()\n}\nfunc (c *conn) Context() interface{}        { return c.ctx }\nfunc (c *conn) SetContext(v interface{})    { c.ctx = v }\nfunc (c *conn) SetReadBuffer(n int)         {}\nfunc (c *conn) WriteString(str string)      { c.wr.WriteString(str) }\nfunc (c *conn) WriteBulk(bulk []byte)       { c.wr.WriteBulk(bulk) }\nfunc (c *conn) WriteBulkString(bulk string) { c.wr.WriteBulkString(bulk) }\nfunc (c *conn) WriteInt(num int)            { c.wr.WriteInt(num) }\nfunc (c *conn) WriteInt64(num int64)        { c.wr.WriteInt64(num) }\nfunc (c *conn) WriteUint64(num uint64)      { c.wr.WriteUint64(num) }\nfunc (c *conn) WriteError(msg string)       { c.wr.WriteError(msg) }\nfunc (c *conn) WriteArray(count int)        { c.wr.WriteArray(count) }\nfunc (c *conn) WriteNull()                  { c.wr.WriteNull() }\nfunc (c *conn) WriteRaw(data []byte)        { c.wr.WriteRaw(data) }\nfunc (c *conn) WriteAny(v interface{})      { c.wr.WriteAny(v) }\nfunc (c *conn) RemoteAddr() string          { return c.addr }\nfunc (c *conn) ReadPipeline() []Command {\n\tcmds := c.cmds\n\tc.cmds = nil\n\treturn cmds\n}\nfunc (c *conn) PeekPipeline() []Command {\n\treturn c.cmds\n}\nfunc (c *conn) NetConn() net.Conn {\n\treturn c.conn\n}\n\n// BaseWriter returns the underlying connection writer, if any\nfunc BaseWriter(c Conn) *Writer {\n\tif c, ok := c.(*conn); ok {\n\t\treturn c.wr\n\t}\n\treturn nil\n}\n\n// DetachedConn represents a connection that is detached from the server\ntype DetachedConn interface {\n\t// Conn is the original connection\n\tConn\n\t// ReadCommand reads the next client command.\n\tReadCommand() (Command, error)\n\t// Flush flushes any writes to the network.\n\tFlush() error\n}\n\n// Detach removes the current connection from the server loop and returns\n// a detached connection. This is useful for operations such as PubSub.\n// The detached connection must be closed by calling Close() when done.\n// All writes such as WriteString() will not be written to the client\n// until Flush() is called.\nfunc (c *conn) Detach() DetachedConn {\n\tc.detached = true\n\tcmds := c.cmds\n\tc.cmds = nil\n\treturn &detachedConn{conn: c, cmds: cmds}\n}\n\ntype detachedConn struct {\n\t*conn\n\tcmds []Command\n}\n\n// Flush writes and Write* calls to the client.\nfunc (dc *detachedConn) Flush() error {\n\treturn dc.conn.wr.Flush()\n}\n\n// ReadCommand read the next command from the client.\nfunc (dc *detachedConn) ReadCommand() (Command, error) {\n\tif len(dc.cmds) > 0 {\n\t\tcmd := dc.cmds[0]\n\t\tif len(dc.cmds) == 1 {\n\t\t\tdc.cmds = nil\n\t\t} else {\n\t\t\tdc.cmds = dc.cmds[1:]\n\t\t}\n\t\treturn cmd, nil\n\t}\n\tcmd, err := dc.rd.ReadCommand()\n\tif err != nil {\n\t\treturn Command{}, err\n\t}\n\treturn cmd, nil\n}\n\n// Command represent a command\ntype Command struct {\n\t// Raw is a encoded RESP message.\n\tRaw []byte\n\t// Args is a series of arguments that make up the command.\n\tArgs [][]byte\n}\n\n// Server defines a server for clients for managing client connections.\ntype Server struct {\n\tmu        sync.Mutex\n\tnet       string\n\tladdr     string\n\thandler   func(conn Conn, cmd Command)\n\taccept    func(conn Conn) bool\n\tclosed    func(conn Conn, err error)\n\tconns     map[*conn]bool\n\tln        net.Listener\n\tdone      bool\n\tidleClose time.Duration\n\n\t// AcceptError is an optional function used to handle Accept errors.\n\tAcceptError func(err error)\n}\n\n// TLSServer defines a server for clients for managing client connections.\ntype TLSServer struct {\n\t*Server\n\tconfig *tls.Config\n}\n\n// Writer allows for writing RESP messages.\ntype Writer struct {\n\tw   io.Writer\n\tb   []byte\n\terr error\n}\n\n// NewWriter creates a new RESP writer.\nfunc NewWriter(wr io.Writer) *Writer {\n\treturn &Writer{\n\t\tw: wr,\n\t}\n}\n\n// WriteNull writes a null to the client\nfunc (w *Writer) WriteNull() {\n\tif w.err != nil {\n\t\treturn\n\t}\n\tw.b = AppendNull(w.b)\n}\n\n// WriteArray writes an array header. You must then write additional\n// sub-responses to the client to complete the response.\n// For example to write two strings:\n//\n//\tc.WriteArray(2)\n//\tc.WriteBulkString(\"item 1\")\n//\tc.WriteBulkString(\"item 2\")\nfunc (w *Writer) WriteArray(count int) {\n\tif w.err != nil {\n\t\treturn\n\t}\n\tw.b = AppendArray(w.b, count)\n}\n\n// WriteBulk writes bulk bytes to the client.\nfunc (w *Writer) WriteBulk(bulk []byte) {\n\tif w.err != nil {\n\t\treturn\n\t}\n\tw.b = AppendBulk(w.b, bulk)\n}\n\n// WriteBulkString writes a bulk string to the client.\nfunc (w *Writer) WriteBulkString(bulk string) {\n\tif w.err != nil {\n\t\treturn\n\t}\n\tw.b = AppendBulkString(w.b, bulk)\n}\n\n// Buffer returns the unflushed buffer. This is a copy so changes\n// to the resulting []byte will not affect the writer.\nfunc (w *Writer) Buffer() []byte {\n\tif w.err != nil {\n\t\treturn nil\n\t}\n\treturn append([]byte(nil), w.b...)\n}\n\n// SetBuffer replaces the unflushed buffer with new bytes.\nfunc (w *Writer) SetBuffer(raw []byte) {\n\tif w.err != nil {\n\t\treturn\n\t}\n\tw.b = w.b[:0]\n\tw.b = append(w.b, raw...)\n}\n\n// Flush writes all unflushed Write* calls to the underlying writer.\nfunc (w *Writer) Flush() error {\n\tif w.err != nil {\n\t\treturn w.err\n\t}\n\t_, w.err = w.w.Write(w.b)\n\tif cap(w.b) > maxBufferCap || w.err != nil {\n\t\tw.b = nil\n\t} else {\n\t\tw.b = w.b[:0]\n\t}\n\treturn w.err\n}\n\n// WriteError writes an error to the client.\nfunc (w *Writer) WriteError(msg string) {\n\tif w.err != nil {\n\t\treturn\n\t}\n\tw.b = AppendError(w.b, msg)\n}\n\n// WriteString writes a string to the client.\nfunc (w *Writer) WriteString(msg string) {\n\tif w.err != nil {\n\t\treturn\n\t}\n\tw.b = AppendString(w.b, msg)\n}\n\n// WriteInt writes an integer to the client.\nfunc (w *Writer) WriteInt(num int) {\n\tif w.err != nil {\n\t\treturn\n\t}\n\tw.WriteInt64(int64(num))\n}\n\n// WriteInt64 writes a 64-bit signed integer to the client.\nfunc (w *Writer) WriteInt64(num int64) {\n\tif w.err != nil {\n\t\treturn\n\t}\n\tw.b = AppendInt(w.b, num)\n}\n\n// WriteUint64 writes a 64-bit unsigned integer to the client.\nfunc (w *Writer) WriteUint64(num uint64) {\n\tif w.err != nil {\n\t\treturn\n\t}\n\tw.b = AppendUint(w.b, num)\n}\n\n// WriteRaw writes raw data to the client.\nfunc (w *Writer) WriteRaw(data []byte) {\n\tif w.err != nil {\n\t\treturn\n\t}\n\tw.b = append(w.b, data...)\n}\n\n// WriteAny writes any type to client.\n//\n//\tnil             -> null\n//\terror           -> error (adds \"ERR \" when first word is not uppercase)\n//\tstring          -> bulk-string\n//\tnumbers         -> bulk-string\n//\t[]byte          -> bulk-string\n//\tbool            -> bulk-string (\"0\" or \"1\")\n//\tslice           -> array\n//\tmap             -> array with key/value pairs\n//\tSimpleString    -> string\n//\tSimpleInt       -> integer\n//\teverything-else -> bulk-string representation using fmt.Sprint()\nfunc (w *Writer) WriteAny(v interface{}) {\n\tif w.err != nil {\n\t\treturn\n\t}\n\tw.b = AppendAny(w.b, v)\n}\n\n// Reader represent a reader for RESP or telnet commands.\ntype Reader struct {\n\trd    *bufio.Reader\n\tbuf   []byte\n\tstart int\n\tend   int\n\tcmds  []Command\n}\n\n// NewReader returns a command reader which will read RESP or telnet commands.\nfunc NewReader(rd io.Reader) *Reader {\n\treturn &Reader{\n\t\trd:  bufio.NewReader(rd),\n\t\tbuf: make([]byte, 4096),\n\t}\n}\n\nfunc parseInt(b []byte) (int, bool) {\n\tif len(b) == 1 && b[0] >= '0' && b[0] <= '9' {\n\t\treturn int(b[0] - '0'), true\n\t}\n\tvar n int\n\tvar sign bool\n\tvar i int\n\tif len(b) > 0 && b[0] == '-' {\n\t\tsign = true\n\t\ti++\n\t}\n\tfor ; i < len(b); i++ {\n\t\tif b[i] < '0' || b[i] > '9' {\n\t\t\treturn 0, false\n\t\t}\n\t\tn = n*10 + int(b[i]-'0')\n\t}\n\tif sign {\n\t\tn *= -1\n\t}\n\treturn n, true\n}\n\nfunc (rd *Reader) readCommands(leftover *int) ([]Command, error) {\n\tvar cmds []Command\n\tb := rd.buf[rd.start:rd.end]\n\tif rd.end-rd.start == 0 && len(rd.buf) > 4096 {\n\t\trd.buf = rd.buf[:4096]\n\t\trd.start = 0\n\t\trd.end = 0\n\t}\n\tif len(b) > 0 {\n\t\t// we have data, yay!\n\t\t// but is this enough data for a complete command? or multiple?\n\tnext:\n\t\tswitch b[0] {\n\t\tdefault:\n\t\t\t// just a plain text command\n\t\t\tfor i := 0; i < len(b); i++ {\n\t\t\t\tif b[i] == '\\n' {\n\t\t\t\t\tvar line []byte\n\t\t\t\t\tif i > 0 && b[i-1] == '\\r' {\n\t\t\t\t\t\tline = b[:i-1]\n\t\t\t\t\t} else {\n\t\t\t\t\t\tline = b[:i]\n\t\t\t\t\t}\n\t\t\t\t\tvar cmd Command\n\t\t\t\t\tvar quote bool\n\t\t\t\t\tvar quotech byte\n\t\t\t\t\tvar escape bool\n\t\t\t\touter:\n\t\t\t\t\tfor {\n\t\t\t\t\t\tnline := make([]byte, 0, len(line))\n\t\t\t\t\t\tfor i := 0; i < len(line); i++ {\n\t\t\t\t\t\t\tc := line[i]\n\t\t\t\t\t\t\tif !quote {\n\t\t\t\t\t\t\t\tif c == ' ' {\n\t\t\t\t\t\t\t\t\tif len(nline) > 0 {\n\t\t\t\t\t\t\t\t\t\tcmd.Args = append(cmd.Args, nline)\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tline = line[i+1:]\n\t\t\t\t\t\t\t\t\tcontinue outer\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif c == '\"' || c == '\\'' {\n\t\t\t\t\t\t\t\t\tif i != 0 {\n\t\t\t\t\t\t\t\t\t\treturn nil, errUnbalancedQuotes\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tquotech = c\n\t\t\t\t\t\t\t\t\tquote = true\n\t\t\t\t\t\t\t\t\tline = line[i+1:]\n\t\t\t\t\t\t\t\t\tcontinue outer\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tif escape {\n\t\t\t\t\t\t\t\t\tescape = false\n\t\t\t\t\t\t\t\t\tswitch c {\n\t\t\t\t\t\t\t\t\tcase 'n':\n\t\t\t\t\t\t\t\t\t\tc = '\\n'\n\t\t\t\t\t\t\t\t\tcase 'r':\n\t\t\t\t\t\t\t\t\t\tc = '\\r'\n\t\t\t\t\t\t\t\t\tcase 't':\n\t\t\t\t\t\t\t\t\t\tc = '\\t'\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t} else if c == quotech {\n\t\t\t\t\t\t\t\t\tquote = false\n\t\t\t\t\t\t\t\t\tquotech = 0\n\t\t\t\t\t\t\t\t\tcmd.Args = append(cmd.Args, nline)\n\t\t\t\t\t\t\t\t\tline = line[i+1:]\n\t\t\t\t\t\t\t\t\tif len(line) > 0 && line[0] != ' ' {\n\t\t\t\t\t\t\t\t\t\treturn nil, errUnbalancedQuotes\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tcontinue outer\n\t\t\t\t\t\t\t\t} else if c == '\\\\' {\n\t\t\t\t\t\t\t\t\tescape = true\n\t\t\t\t\t\t\t\t\tcontinue\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tnline = append(nline, c)\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif quote {\n\t\t\t\t\t\t\treturn nil, errUnbalancedQuotes\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif len(line) > 0 {\n\t\t\t\t\t\t\tcmd.Args = append(cmd.Args, line)\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak\n\t\t\t\t\t}\n\t\t\t\t\tif len(cmd.Args) > 0 {\n\t\t\t\t\t\t// convert this to resp command syntax\n\t\t\t\t\t\tvar wr Writer\n\t\t\t\t\t\twr.WriteArray(len(cmd.Args))\n\t\t\t\t\t\tfor i := range cmd.Args {\n\t\t\t\t\t\t\twr.WriteBulk(cmd.Args[i])\n\t\t\t\t\t\t\tcmd.Args[i] = append([]byte(nil), cmd.Args[i]...)\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcmd.Raw = wr.b\n\t\t\t\t\t\tcmds = append(cmds, cmd)\n\t\t\t\t\t}\n\t\t\t\t\tb = b[i+1:]\n\t\t\t\t\tif len(b) > 0 {\n\t\t\t\t\t\tgoto next\n\t\t\t\t\t} else {\n\t\t\t\t\t\tgoto done\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\tcase '*':\n\t\t\t// resp formatted command\n\t\t\tmarks := make([]int, 0, 16)\n\t\touter2:\n\t\t\tfor i := 1; i < len(b); i++ {\n\t\t\t\tif b[i] == '\\n' {\n\t\t\t\t\tif b[i-1] != '\\r' {\n\t\t\t\t\t\treturn nil, errInvalidMultiBulkLength\n\t\t\t\t\t}\n\t\t\t\t\tcount, ok := parseInt(b[1 : i-1])\n\t\t\t\t\tif !ok || count <= 0 {\n\t\t\t\t\t\treturn nil, errInvalidMultiBulkLength\n\t\t\t\t\t}\n\t\t\t\t\tmarks = marks[:0]\n\t\t\t\t\tfor j := 0; j < count; j++ {\n\t\t\t\t\t\t// read bulk length\n\t\t\t\t\t\ti++\n\t\t\t\t\t\tif i < len(b) {\n\t\t\t\t\t\t\tif b[i] != '$' {\n\t\t\t\t\t\t\t\treturn nil, &errProtocol{\"expected '$', got '\" +\n\t\t\t\t\t\t\t\t\tstring(b[i]) + \"'\"}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tsi := i\n\t\t\t\t\t\t\tfor ; i < len(b); i++ {\n\t\t\t\t\t\t\t\tif b[i] == '\\n' {\n\t\t\t\t\t\t\t\t\tif b[i-1] != '\\r' {\n\t\t\t\t\t\t\t\t\t\treturn nil, errInvalidBulkLength\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tsize, ok := parseInt(b[si+1 : i-1])\n\t\t\t\t\t\t\t\t\tif !ok || size < 0 {\n\t\t\t\t\t\t\t\t\t\treturn nil, errInvalidBulkLength\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tif i+size+2 >= len(b) {\n\t\t\t\t\t\t\t\t\t\t// not ready\n\t\t\t\t\t\t\t\t\t\tbreak outer2\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tif b[i+size+2] != '\\n' ||\n\t\t\t\t\t\t\t\t\t\tb[i+size+1] != '\\r' {\n\t\t\t\t\t\t\t\t\t\treturn nil, errInvalidBulkLength\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\ti++\n\t\t\t\t\t\t\t\t\tmarks = append(marks, i, i+size)\n\t\t\t\t\t\t\t\t\ti += size + 1\n\t\t\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif len(marks) == count*2 {\n\t\t\t\t\t\tvar cmd Command\n\t\t\t\t\t\tif rd.rd != nil {\n\t\t\t\t\t\t\t// make a raw copy of the entire command when\n\t\t\t\t\t\t\t// there's a underlying reader.\n\t\t\t\t\t\t\tcmd.Raw = append([]byte(nil), b[:i+1]...)\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// just assign the slice\n\t\t\t\t\t\t\tcmd.Raw = b[:i+1]\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcmd.Args = make([][]byte, len(marks)/2)\n\t\t\t\t\t\t// slice up the raw command into the args based on\n\t\t\t\t\t\t// the recorded marks.\n\t\t\t\t\t\tfor h := 0; h < len(marks); h += 2 {\n\t\t\t\t\t\t\tcmd.Args[h/2] = cmd.Raw[marks[h]:marks[h+1]]\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcmds = append(cmds, cmd)\n\t\t\t\t\t\tb = b[i+1:]\n\t\t\t\t\t\tif len(b) > 0 {\n\t\t\t\t\t\t\tgoto next\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tgoto done\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\tdone:\n\t\trd.start = rd.end - len(b)\n\t}\n\tif leftover != nil {\n\t\t*leftover = rd.end - rd.start\n\t}\n\tif len(cmds) > 0 {\n\t\treturn cmds, nil\n\t}\n\tif rd.rd == nil {\n\t\treturn nil, errIncompleteCommand\n\t}\n\tif rd.end == len(rd.buf) {\n\t\t// at the end of the buffer.\n\t\tif rd.start == rd.end {\n\t\t\t// rewind the to the beginning\n\t\t\trd.start, rd.end = 0, 0\n\t\t} else {\n\t\t\t// must grow the buffer\n\t\t\tnewbuf := make([]byte, len(rd.buf)*2)\n\t\t\tcopy(newbuf, rd.buf)\n\t\t\trd.buf = newbuf\n\t\t}\n\t}\n\tn, err := rd.rd.Read(rd.buf[rd.end:])\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\trd.end += n\n\treturn rd.readCommands(leftover)\n}\n\n// ReadCommands reads the next pipeline commands.\nfunc (rd *Reader) ReadCommands() ([]Command, error) {\n\tfor {\n\t\tif len(rd.cmds) > 0 {\n\t\t\tcmds := rd.cmds\n\t\t\trd.cmds = nil\n\t\t\treturn cmds, nil\n\t\t}\n\t\tcmds, err := rd.readCommands(nil)\n\t\tif err != nil {\n\t\t\treturn []Command{}, err\n\t\t}\n\t\trd.cmds = cmds\n\t}\n}\n\n// ReadCommand reads the next command.\nfunc (rd *Reader) ReadCommand() (Command, error) {\n\tif len(rd.cmds) > 0 {\n\t\tcmd := rd.cmds[0]\n\t\trd.cmds = rd.cmds[1:]\n\t\treturn cmd, nil\n\t}\n\tcmds, err := rd.readCommands(nil)\n\tif err != nil {\n\t\treturn Command{}, err\n\t}\n\trd.cmds = cmds\n\treturn rd.ReadCommand()\n}\n\n// Parse parses a raw RESP message and returns a command.\nfunc Parse(raw []byte) (Command, error) {\n\trd := Reader{buf: raw, end: len(raw)}\n\tvar leftover int\n\tcmds, err := rd.readCommands(&leftover)\n\tif err != nil {\n\t\treturn Command{}, err\n\t}\n\tif leftover > 0 {\n\t\treturn Command{}, errTooMuchData\n\t}\n\treturn cmds[0], nil\n\n}\n\n// A Handler responds to an RESP request.\ntype Handler interface {\n\tServeRESP(conn Conn, cmd Command)\n}\n\n// The HandlerFunc type is an adapter to allow the use of\n// ordinary functions as RESP handlers. If f is a function\n// with the appropriate signature, HandlerFunc(f) is a\n// Handler that calls f.\ntype HandlerFunc func(conn Conn, cmd Command)\n\n// ServeRESP calls f(w, r)\nfunc (f HandlerFunc) ServeRESP(conn Conn, cmd Command) {\n\tf(conn, cmd)\n}\n\n// ServeMux is an RESP command multiplexer.\ntype ServeMux struct {\n\thandlers map[string]Handler\n}\n\n// NewServeMux allocates and returns a new ServeMux.\nfunc NewServeMux() *ServeMux {\n\treturn &ServeMux{\n\t\thandlers: make(map[string]Handler),\n\t}\n}\n\n// HandleFunc registers the handler function for the given command.\nfunc (m *ServeMux) HandleFunc(command string, handler func(conn Conn, cmd Command)) {\n\tif handler == nil {\n\t\tpanic(\"redcon: nil handler\")\n\t}\n\tm.Handle(command, HandlerFunc(handler))\n}\n\n// Handle registers the handler for the given command.\n// If a handler already exists for command, Handle panics.\nfunc (m *ServeMux) Handle(command string, handler Handler) {\n\tif command == \"\" {\n\t\tpanic(\"redcon: invalid command\")\n\t}\n\tif handler == nil {\n\t\tpanic(\"redcon: nil handler\")\n\t}\n\tif _, exist := m.handlers[command]; exist {\n\t\tpanic(\"redcon: multiple registrations for \" + command)\n\t}\n\n\tm.handlers[command] = handler\n}\n\n// ServeRESP dispatches the command to the handler.\nfunc (m *ServeMux) ServeRESP(conn Conn, cmd Command) {\n\tcommand := strings.ToLower(string(cmd.Args[0]))\n\n\tif handler, ok := m.handlers[command]; ok {\n\t\thandler.ServeRESP(conn, cmd)\n\t} else {\n\t\tconn.WriteError(\"ERR unknown command '\" + command + \"'\")\n\t}\n}\n\n// PubSub is a Redis compatible pub/sub server\ntype PubSub struct {\n\tmu     sync.RWMutex\n\tnextid uint64\n\tinitd  bool\n\tchans  *btree.BTree\n\tconns  map[Conn]*pubSubConn\n}\n\n// Subscribe a connection to PubSub\nfunc (ps *PubSub) Subscribe(conn Conn, channel string) {\n\tps.subscribe(conn, false, channel)\n}\n\n// Psubscribe a connection to PubSub\nfunc (ps *PubSub) Psubscribe(conn Conn, channel string) {\n\tps.subscribe(conn, true, channel)\n}\n\n// Publish a message to subscribers\nfunc (ps *PubSub) Publish(channel, message string) int {\n\tps.mu.RLock()\n\tdefer ps.mu.RUnlock()\n\tif !ps.initd {\n\t\treturn 0\n\t}\n\tvar sent int\n\t// write messages to all clients that are subscribed on the channel\n\tpivot := &pubSubEntry{pattern: false, channel: channel}\n\tps.chans.Ascend(pivot, func(item interface{}) bool {\n\t\tentry := item.(*pubSubEntry)\n\t\tif entry.channel != pivot.channel || entry.pattern != pivot.pattern {\n\t\t\treturn false\n\t\t}\n\t\tentry.sconn.writeMessage(entry.pattern, \"\", channel, message)\n\t\tsent++\n\t\treturn true\n\t})\n\n\t// match on and write all psubscribe clients\n\tpivot = &pubSubEntry{pattern: true}\n\tps.chans.Ascend(pivot, func(item interface{}) bool {\n\t\tentry := item.(*pubSubEntry)\n\t\tif match.Match(channel, entry.channel) {\n\t\t\tentry.sconn.writeMessage(entry.pattern, entry.channel, channel,\n\t\t\t\tmessage)\n\t\t}\n\t\tsent++\n\t\treturn true\n\t})\n\n\treturn sent\n}\n\ntype pubSubConn struct {\n\tid      uint64\n\tmu      sync.Mutex\n\tconn    Conn\n\tdconn   DetachedConn\n\tentries map[*pubSubEntry]bool\n}\n\ntype pubSubEntry struct {\n\tpattern bool\n\tsconn   *pubSubConn\n\tchannel string\n}\n\nfunc (sconn *pubSubConn) writeMessage(pat bool, pchan, channel, msg string) {\n\tsconn.mu.Lock()\n\tdefer sconn.mu.Unlock()\n\tif pat {\n\t\tsconn.dconn.WriteArray(4)\n\t\tsconn.dconn.WriteBulkString(\"pmessage\")\n\t\tsconn.dconn.WriteBulkString(pchan)\n\t\tsconn.dconn.WriteBulkString(channel)\n\t\tsconn.dconn.WriteBulkString(msg)\n\t} else {\n\t\tsconn.dconn.WriteArray(3)\n\t\tsconn.dconn.WriteBulkString(\"message\")\n\t\tsconn.dconn.WriteBulkString(channel)\n\t\tsconn.dconn.WriteBulkString(msg)\n\t}\n\tsconn.dconn.Flush()\n}\n\n// bgrunner runs in the background and reads incoming commands from the\n// detached client.\nfunc (sconn *pubSubConn) bgrunner(ps *PubSub) {\n\tdefer func() {\n\t\t// client connection has ended, disconnect from the PubSub instances\n\t\t// and close the network connection.\n\t\tps.mu.Lock()\n\t\tdefer ps.mu.Unlock()\n\t\tfor entry := range sconn.entries {\n\t\t\tps.chans.Delete(entry)\n\t\t}\n\t\tdelete(ps.conns, sconn.conn)\n\t\tsconn.mu.Lock()\n\t\tdefer sconn.mu.Unlock()\n\t\tsconn.dconn.Close()\n\t}()\n\tfor {\n\t\tcmd, err := sconn.dconn.ReadCommand()\n\t\tif err != nil {\n\t\t\treturn\n\t\t}\n\t\tif len(cmd.Args) == 0 {\n\t\t\tcontinue\n\t\t}\n\t\tswitch strings.ToLower(string(cmd.Args[0])) {\n\t\tcase \"psubscribe\", \"subscribe\":\n\t\t\tif len(cmd.Args) < 2 {\n\t\t\t\tfunc() {\n\t\t\t\t\tsconn.mu.Lock()\n\t\t\t\t\tdefer sconn.mu.Unlock()\n\t\t\t\t\tsconn.dconn.WriteError(fmt.Sprintf(\"ERR wrong number of \"+\n\t\t\t\t\t\t\"arguments for '%s'\", cmd.Args[0]))\n\t\t\t\t\tsconn.dconn.Flush()\n\t\t\t\t}()\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tcommand := strings.ToLower(string(cmd.Args[0]))\n\t\t\tfor i := 1; i < len(cmd.Args); i++ {\n\t\t\t\tif command == \"psubscribe\" {\n\t\t\t\t\tps.Psubscribe(sconn.conn, string(cmd.Args[i]))\n\t\t\t\t} else {\n\t\t\t\t\tps.Subscribe(sconn.conn, string(cmd.Args[i]))\n\t\t\t\t}\n\t\t\t}\n\t\tcase \"unsubscribe\", \"punsubscribe\":\n\t\t\tpattern := strings.ToLower(string(cmd.Args[0])) == \"punsubscribe\"\n\t\t\tif len(cmd.Args) == 1 {\n\t\t\t\tps.unsubscribe(sconn.conn, pattern, true, \"\")\n\t\t\t} else {\n\t\t\t\tfor i := 1; i < len(cmd.Args); i++ {\n\t\t\t\t\tchannel := string(cmd.Args[i])\n\t\t\t\t\tps.unsubscribe(sconn.conn, pattern, false, channel)\n\t\t\t\t}\n\t\t\t}\n\t\tcase \"quit\":\n\t\t\tfunc() {\n\t\t\t\tsconn.mu.Lock()\n\t\t\t\tdefer sconn.mu.Unlock()\n\t\t\t\tsconn.dconn.WriteString(\"OK\")\n\t\t\t\tsconn.dconn.Flush()\n\t\t\t\tsconn.dconn.Close()\n\t\t\t}()\n\t\t\treturn\n\t\tcase \"ping\":\n\t\t\tvar msg string\n\t\t\tswitch len(cmd.Args) {\n\t\t\tcase 1:\n\t\t\tcase 2:\n\t\t\t\tmsg = string(cmd.Args[1])\n\t\t\tdefault:\n\t\t\t\tfunc() {\n\t\t\t\t\tsconn.mu.Lock()\n\t\t\t\t\tdefer sconn.mu.Unlock()\n\t\t\t\t\tsconn.dconn.WriteError(fmt.Sprintf(\"ERR wrong number of \"+\n\t\t\t\t\t\t\"arguments for '%s'\", cmd.Args[0]))\n\t\t\t\t\tsconn.dconn.Flush()\n\t\t\t\t}()\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tfunc() {\n\t\t\t\tsconn.mu.Lock()\n\t\t\t\tdefer sconn.mu.Unlock()\n\t\t\t\tsconn.dconn.WriteArray(2)\n\t\t\t\tsconn.dconn.WriteBulkString(\"pong\")\n\t\t\t\tsconn.dconn.WriteBulkString(msg)\n\t\t\t\tsconn.dconn.Flush()\n\t\t\t}()\n\t\tdefault:\n\t\t\tfunc() {\n\t\t\t\tsconn.mu.Lock()\n\t\t\t\tdefer sconn.mu.Unlock()\n\t\t\t\tsconn.dconn.WriteError(fmt.Sprintf(\"ERR Can't execute '%s': \"+\n\t\t\t\t\t\"only (P)SUBSCRIBE / (P)UNSUBSCRIBE / PING / QUIT are \"+\n\t\t\t\t\t\"allowed in this context\", cmd.Args[0]))\n\t\t\t\tsconn.dconn.Flush()\n\t\t\t}()\n\t\t}\n\t}\n}\n\n// byEntry is a \"less\" function that sorts the entries in a btree. The tree\n// is sorted be (pattern, channel, conn.id). All pattern=true entries are at\n// the end (right) of the tree.\nfunc byEntry(a, b interface{}) bool {\n\taa := a.(*pubSubEntry)\n\tbb := b.(*pubSubEntry)\n\tif !aa.pattern && bb.pattern {\n\t\treturn true\n\t}\n\tif aa.pattern && !bb.pattern {\n\t\treturn false\n\t}\n\tif aa.channel < bb.channel {\n\t\treturn true\n\t}\n\tif aa.channel > bb.channel {\n\t\treturn false\n\t}\n\tvar aid uint64\n\tvar bid uint64\n\tif aa.sconn != nil {\n\t\taid = aa.sconn.id\n\t}\n\tif bb.sconn != nil {\n\t\tbid = bb.sconn.id\n\t}\n\treturn aid < bid\n}\n\nfunc (ps *PubSub) subscribe(conn Conn, pattern bool, channel string) {\n\tps.mu.Lock()\n\tdefer ps.mu.Unlock()\n\n\t// initialize the PubSub instance\n\tif !ps.initd {\n\t\tps.conns = make(map[Conn]*pubSubConn)\n\t\tps.chans = btree.New(byEntry)\n\t\tps.initd = true\n\t}\n\n\t// fetch the pubSubConn\n\tsconn, ok := ps.conns[conn]\n\tif !ok {\n\t\t// initialize a new pubSubConn, which runs on a detached connection,\n\t\t// and attach it to the PubSub channels/conn btree\n\t\tps.nextid++\n\t\tdconn := conn.Detach()\n\t\tsconn = &pubSubConn{\n\t\t\tid:      ps.nextid,\n\t\t\tconn:    conn,\n\t\t\tdconn:   dconn,\n\t\t\tentries: make(map[*pubSubEntry]bool),\n\t\t}\n\t\tps.conns[conn] = sconn\n\t}\n\tsconn.mu.Lock()\n\tdefer sconn.mu.Unlock()\n\n\t// add an entry to the pubsub btree\n\tentry := &pubSubEntry{\n\t\tpattern: pattern,\n\t\tchannel: channel,\n\t\tsconn:   sconn,\n\t}\n\tps.chans.Set(entry)\n\tsconn.entries[entry] = true\n\n\t// send a message to the client\n\tsconn.dconn.WriteArray(3)\n\tif pattern {\n\t\tsconn.dconn.WriteBulkString(\"psubscribe\")\n\t} else {\n\t\tsconn.dconn.WriteBulkString(\"subscribe\")\n\t}\n\tsconn.dconn.WriteBulkString(channel)\n\tvar count int\n\tfor entry := range sconn.entries {\n\t\tif entry.pattern == pattern {\n\t\t\tcount++\n\t\t}\n\t}\n\tsconn.dconn.WriteInt(count)\n\tsconn.dconn.Flush()\n\n\t// start the background client operation\n\tif !ok {\n\t\tgo sconn.bgrunner(ps)\n\t}\n}\n\nfunc (ps *PubSub) unsubscribe(conn Conn, pattern, all bool, channel string) {\n\tps.mu.Lock()\n\tdefer ps.mu.Unlock()\n\t// fetch the pubSubConn. This must exist\n\tsconn := ps.conns[conn]\n\tsconn.mu.Lock()\n\tdefer sconn.mu.Unlock()\n\n\tremoveEntry := func(entry *pubSubEntry) {\n\t\tif entry != nil {\n\t\t\tps.chans.Delete(entry)\n\t\t\tdelete(sconn.entries, entry)\n\t\t}\n\t\tsconn.dconn.WriteArray(3)\n\t\tif pattern {\n\t\t\tsconn.dconn.WriteBulkString(\"punsubscribe\")\n\t\t} else {\n\t\t\tsconn.dconn.WriteBulkString(\"unsubscribe\")\n\t\t}\n\t\tif entry != nil {\n\t\t\tsconn.dconn.WriteBulkString(entry.channel)\n\t\t} else {\n\t\t\tsconn.dconn.WriteNull()\n\t\t}\n\t\tvar count int\n\t\tfor entry := range sconn.entries {\n\t\t\tif entry.pattern == pattern {\n\t\t\t\tcount++\n\t\t\t}\n\t\t}\n\t\tsconn.dconn.WriteInt(count)\n\t}\n\tif all {\n\t\t// unsubscribe from all (p)subscribe entries\n\t\tvar entries []*pubSubEntry\n\t\tfor entry := range sconn.entries {\n\t\t\tif entry.pattern == pattern {\n\t\t\t\tentries = append(entries, entry)\n\t\t\t}\n\t\t}\n\t\tif len(entries) == 0 {\n\t\t\tremoveEntry(nil)\n\t\t} else {\n\t\t\tfor _, entry := range entries {\n\t\t\t\tremoveEntry(entry)\n\t\t\t}\n\t\t}\n\t} else {\n\t\t// unsubscribe single channel from (p)subscribe.\n\t\tfor entry := range sconn.entries {\n\t\t\tif entry.pattern == pattern && entry.channel == channel {\n\t\t\t\tremoveEntry(entry)\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}\n\tsconn.dconn.Flush()\n}\n\n// SetIdleClose will automatically close idle connections after the specified\n// duration. Use zero to disable this feature.\nfunc (s *Server) SetIdleClose(dur time.Duration) {\n\ts.mu.Lock()\n\ts.idleClose = dur\n\ts.mu.Unlock()\n}\n"
        },
        {
          "name": "redcon_test.go",
          "type": "blob",
          "size": 16.697265625,
          "content": "package redcon\n\nimport (\n\t\"bufio\"\n\t\"bytes\"\n\t\"fmt\"\n\t\"io\"\n\t\"log\"\n\t\"math/rand\"\n\t\"net\"\n\t\"os\"\n\t\"strconv\"\n\t\"strings\"\n\t\"sync\"\n\t\"testing\"\n\t\"time\"\n)\n\n// TestRandomCommands fills a bunch of random commands and test various\n// ways that the reader may receive data.\nfunc TestRandomCommands(t *testing.T) {\n\trand.Seed(time.Now().UnixNano())\n\n\t// build random commands.\n\tgcmds := make([][]string, 10000)\n\tfor i := 0; i < len(gcmds); i++ {\n\t\targs := make([]string, (rand.Int()%50)+1) // 1-50 args\n\t\tfor j := 0; j < len(args); j++ {\n\t\t\tn := rand.Int() % 10\n\t\t\tif j == 0 {\n\t\t\t\tn++\n\t\t\t}\n\t\t\targ := make([]byte, n)\n\t\t\tfor k := 0; k < len(arg); k++ {\n\t\t\t\targ[k] = byte(rand.Int() % 0xFF)\n\t\t\t}\n\t\t\targs[j] = string(arg)\n\t\t}\n\t\tgcmds[i] = args\n\t}\n\t// create a list of a buffers\n\tvar bufs []string\n\n\t// pipe valid RESP commands\n\tfor i := 0; i < len(gcmds); i++ {\n\t\targs := gcmds[i]\n\t\tmsg := fmt.Sprintf(\"*%d\\r\\n\", len(args))\n\t\tfor j := 0; j < len(args); j++ {\n\t\t\tmsg += fmt.Sprintf(\"$%d\\r\\n%s\\r\\n\", len(args[j]), args[j])\n\t\t}\n\t\tbufs = append(bufs, msg)\n\t}\n\tbufs = append(bufs, \"RESET THE INDEX\\r\\n\")\n\n\t// pipe valid plain commands\n\tfor i := 0; i < len(gcmds); i++ {\n\t\targs := gcmds[i]\n\t\tvar msg string\n\t\tfor j := 0; j < len(args); j++ {\n\t\t\tquotes := false\n\t\t\tvar narg []byte\n\t\t\targ := args[j]\n\t\t\tif len(arg) == 0 {\n\t\t\t\tquotes = true\n\t\t\t}\n\t\t\tfor k := 0; k < len(arg); k++ {\n\t\t\t\tswitch arg[k] {\n\t\t\t\tdefault:\n\t\t\t\t\tnarg = append(narg, arg[k])\n\t\t\t\tcase ' ':\n\t\t\t\t\tquotes = true\n\t\t\t\t\tnarg = append(narg, arg[k])\n\t\t\t\tcase '\\\\', '\"', '*':\n\t\t\t\t\tquotes = true\n\t\t\t\t\tnarg = append(narg, '\\\\', arg[k])\n\t\t\t\tcase '\\r':\n\t\t\t\t\tquotes = true\n\t\t\t\t\tnarg = append(narg, '\\\\', 'r')\n\t\t\t\tcase '\\n':\n\t\t\t\t\tquotes = true\n\t\t\t\t\tnarg = append(narg, '\\\\', 'n')\n\t\t\t\t}\n\t\t\t}\n\t\t\tmsg += \" \"\n\t\t\tif quotes {\n\t\t\t\tmsg += \"\\\"\"\n\t\t\t}\n\t\t\tmsg += string(narg)\n\t\t\tif quotes {\n\t\t\t\tmsg += \"\\\"\"\n\t\t\t}\n\t\t}\n\t\tif msg != \"\" {\n\t\t\tmsg = msg[1:]\n\t\t}\n\t\tmsg += \"\\r\\n\"\n\t\tbufs = append(bufs, msg)\n\t}\n\tbufs = append(bufs, \"RESET THE INDEX\\r\\n\")\n\n\t// pipe valid RESP commands in broken chunks\n\tlmsg := \"\"\n\tfor i := 0; i < len(gcmds); i++ {\n\t\targs := gcmds[i]\n\t\tmsg := fmt.Sprintf(\"*%d\\r\\n\", len(args))\n\t\tfor j := 0; j < len(args); j++ {\n\t\t\tmsg += fmt.Sprintf(\"$%d\\r\\n%s\\r\\n\", len(args[j]), args[j])\n\t\t}\n\t\tmsg = lmsg + msg\n\t\tif len(msg) > 0 {\n\t\t\tlmsg = msg[len(msg)/2:]\n\t\t\tmsg = msg[:len(msg)/2]\n\t\t}\n\t\tbufs = append(bufs, msg)\n\t}\n\tbufs = append(bufs, lmsg)\n\tbufs = append(bufs, \"RESET THE INDEX\\r\\n\")\n\n\t// pipe valid RESP commands in large broken chunks\n\tlmsg = \"\"\n\tfor i := 0; i < len(gcmds); i++ {\n\t\targs := gcmds[i]\n\t\tmsg := fmt.Sprintf(\"*%d\\r\\n\", len(args))\n\t\tfor j := 0; j < len(args); j++ {\n\t\t\tmsg += fmt.Sprintf(\"$%d\\r\\n%s\\r\\n\", len(args[j]), args[j])\n\t\t}\n\t\tif len(lmsg) < 1500 {\n\t\t\tlmsg += msg\n\t\t\tcontinue\n\t\t}\n\t\tmsg = lmsg + msg\n\t\tif len(msg) > 0 {\n\t\t\tlmsg = msg[len(msg)/2:]\n\t\t\tmsg = msg[:len(msg)/2]\n\t\t}\n\t\tbufs = append(bufs, msg)\n\t}\n\tbufs = append(bufs, lmsg)\n\tbufs = append(bufs, \"RESET THE INDEX\\r\\n\")\n\n\t// Pipe the buffers in a background routine\n\trd, wr := io.Pipe()\n\tgo func() {\n\t\tdefer wr.Close()\n\t\tfor _, msg := range bufs {\n\t\t\tio.WriteString(wr, msg)\n\t\t}\n\t}()\n\tdefer rd.Close()\n\tcnt := 0\n\tidx := 0\n\tstart := time.Now()\n\tr := NewReader(rd)\n\tfor {\n\t\tcmd, err := r.ReadCommand()\n\t\tif err != nil {\n\t\t\tif err == io.EOF {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tlog.Fatal(err)\n\t\t}\n\t\tif len(cmd.Args) == 3 && string(cmd.Args[0]) == \"RESET\" &&\n\t\t\tstring(cmd.Args[1]) == \"THE\" && string(cmd.Args[2]) == \"INDEX\" {\n\t\t\tif idx != len(gcmds) {\n\t\t\t\tt.Fatalf(\"did not process all commands\")\n\t\t\t}\n\t\t\tidx = 0\n\t\t\tbreak\n\t\t}\n\t\tif len(cmd.Args) != len(gcmds[idx]) {\n\t\t\tt.Fatalf(\"len not equal for index %d -- %d != %d\", idx, len(cmd.Args), len(gcmds[idx]))\n\t\t}\n\t\tfor i := 0; i < len(cmd.Args); i++ {\n\t\t\tif i == 0 {\n\t\t\t\tif len(cmd.Args[i]) == len(gcmds[idx][i]) {\n\t\t\t\t\tok := true\n\t\t\t\t\tfor j := 0; j < len(cmd.Args[i]); j++ {\n\t\t\t\t\t\tc1, c2 := cmd.Args[i][j], gcmds[idx][i][j]\n\t\t\t\t\t\tif c1 >= 'A' && c1 <= 'Z' {\n\t\t\t\t\t\t\tc1 += 32\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif c2 >= 'A' && c2 <= 'Z' {\n\t\t\t\t\t\t\tc2 += 32\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif c1 != c2 {\n\t\t\t\t\t\t\tok = false\n\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif ok {\n\t\t\t\t\t\tcontinue\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if string(cmd.Args[i]) == string(gcmds[idx][i]) {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tt.Fatalf(\"not equal for index %d/%d\", idx, i)\n\t\t}\n\t\tidx++\n\t\tcnt++\n\t}\n\tif false {\n\t\tdur := time.Since(start)\n\t\tfmt.Printf(\"%d commands in %s - %.0f ops/sec\\n\", cnt, dur, float64(cnt)/(float64(dur)/float64(time.Second)))\n\t}\n}\nfunc testDetached(conn DetachedConn) {\n\tconn.WriteString(\"DETACHED\")\n\tif err := conn.Flush(); err != nil {\n\t\tpanic(err)\n\t}\n}\nfunc TestServerTCP(t *testing.T) {\n\ttestServerNetwork(t, \"tcp\", \":12345\")\n}\nfunc TestServerUnix(t *testing.T) {\n\tos.RemoveAll(\"/tmp/redcon-unix.sock\")\n\tdefer os.RemoveAll(\"/tmp/redcon-unix.sock\")\n\ttestServerNetwork(t, \"unix\", \"/tmp/redcon-unix.sock\")\n}\n\nfunc testServerNetwork(t *testing.T, network, laddr string) {\n\ts := NewServerNetwork(network, laddr,\n\t\tfunc(conn Conn, cmd Command) {\n\t\t\tswitch strings.ToLower(string(cmd.Args[0])) {\n\t\t\tdefault:\n\t\t\t\tconn.WriteError(\"ERR unknown command '\" + string(cmd.Args[0]) + \"'\")\n\t\t\tcase \"ping\":\n\t\t\t\tconn.WriteString(\"PONG\")\n\t\t\tcase \"quit\":\n\t\t\t\tconn.WriteString(\"OK\")\n\t\t\t\tconn.Close()\n\t\t\tcase \"detach\":\n\t\t\t\tgo testDetached(conn.Detach())\n\t\t\tcase \"int\":\n\t\t\t\tconn.WriteInt(100)\n\t\t\tcase \"bulk\":\n\t\t\t\tconn.WriteBulkString(\"bulk\")\n\t\t\tcase \"bulkbytes\":\n\t\t\t\tconn.WriteBulk([]byte(\"bulkbytes\"))\n\t\t\tcase \"null\":\n\t\t\t\tconn.WriteNull()\n\t\t\tcase \"err\":\n\t\t\t\tconn.WriteError(\"ERR error\")\n\t\t\tcase \"array\":\n\t\t\t\tconn.WriteArray(2)\n\t\t\t\tconn.WriteInt(99)\n\t\t\t\tconn.WriteString(\"Hi!\")\n\t\t\t}\n\t\t},\n\t\tfunc(conn Conn) bool {\n\t\t\t//log.Printf(\"accept: %s\", conn.RemoteAddr())\n\t\t\treturn true\n\t\t},\n\t\tfunc(conn Conn, err error) {\n\t\t\t//log.Printf(\"closed: %s [%v]\", conn.RemoteAddr(), err)\n\t\t},\n\t)\n\tif err := s.Close(); err == nil {\n\t\tt.Fatalf(\"expected an error, should not be able to close before serving\")\n\t}\n\tgo func() {\n\t\ttime.Sleep(time.Second / 4)\n\t\tif err := ListenAndServeNetwork(network, laddr, func(conn Conn, cmd Command) {}, nil, nil); err == nil {\n\t\t\tpanic(\"expected an error, should not be able to listen on the same port\")\n\t\t}\n\t\ttime.Sleep(time.Second / 4)\n\n\t\terr := s.Close()\n\t\tif err != nil {\n\t\t\tpanic(err)\n\t\t}\n\t\terr = s.Close()\n\t\tif err == nil {\n\t\t\tpanic(\"expected an error\")\n\t\t}\n\t}()\n\tdone := make(chan bool)\n\tsignal := make(chan error)\n\tgo func() {\n\t\tdefer func() {\n\t\t\tdone <- true\n\t\t}()\n\t\terr := <-signal\n\t\tif err != nil {\n\t\t\tpanic(err)\n\t\t}\n\t\tc, err := net.Dial(network, laddr)\n\t\tif err != nil {\n\t\t\tpanic(err)\n\t\t}\n\t\tdefer c.Close()\n\t\tdo := func(cmd string) (string, error) {\n\t\t\tio.WriteString(c, cmd)\n\t\t\tbuf := make([]byte, 1024)\n\t\t\tn, err := c.Read(buf)\n\t\t\tif err != nil {\n\t\t\t\treturn \"\", err\n\t\t\t}\n\t\t\treturn string(buf[:n]), nil\n\t\t}\n\t\tres, err := do(\"PING\\r\\n\")\n\t\tif err != nil {\n\t\t\tpanic(err)\n\t\t}\n\t\tif res != \"+PONG\\r\\n\" {\n\t\t\tpanic(fmt.Sprintf(\"expecting '+PONG\\r\\n', got '%v'\", res))\n\t\t}\n\t\tres, err = do(\"BULK\\r\\n\")\n\t\tif err != nil {\n\t\t\tpanic(err)\n\t\t}\n\t\tif res != \"$4\\r\\nbulk\\r\\n\" {\n\t\t\tpanic(fmt.Sprintf(\"expecting bulk, got '%v'\", res))\n\t\t}\n\t\tres, err = do(\"BULKBYTES\\r\\n\")\n\t\tif err != nil {\n\t\t\tpanic(err)\n\t\t}\n\t\tif res != \"$9\\r\\nbulkbytes\\r\\n\" {\n\t\t\tpanic(fmt.Sprintf(\"expecting bulkbytes, got '%v'\", res))\n\t\t}\n\t\tres, err = do(\"INT\\r\\n\")\n\t\tif err != nil {\n\t\t\tpanic(err)\n\t\t}\n\t\tif res != \":100\\r\\n\" {\n\t\t\tpanic(fmt.Sprintf(\"expecting int, got '%v'\", res))\n\t\t}\n\t\tres, err = do(\"NULL\\r\\n\")\n\t\tif err != nil {\n\t\t\tpanic(err)\n\t\t}\n\t\tif res != \"$-1\\r\\n\" {\n\t\t\tpanic(fmt.Sprintf(\"expecting nul, got '%v'\", res))\n\t\t}\n\t\tres, err = do(\"ARRAY\\r\\n\")\n\t\tif err != nil {\n\t\t\tpanic(err)\n\t\t}\n\t\tif res != \"*2\\r\\n:99\\r\\n+Hi!\\r\\n\" {\n\t\t\tpanic(fmt.Sprintf(\"expecting array, got '%v'\", res))\n\t\t}\n\t\tres, err = do(\"ERR\\r\\n\")\n\t\tif err != nil {\n\t\t\tpanic(err)\n\t\t}\n\t\tif res != \"-ERR error\\r\\n\" {\n\t\t\tpanic(fmt.Sprintf(\"expecting array, got '%v'\", res))\n\t\t}\n\t\tres, err = do(\"DETACH\\r\\n\")\n\t\tif err != nil {\n\t\t\tpanic(err)\n\t\t}\n\t\tif res != \"+DETACHED\\r\\n\" {\n\t\t\tpanic(fmt.Sprintf(\"expecting string, got '%v'\", res))\n\t\t}\n\t}()\n\tgo func() {\n\t\terr := s.ListenServeAndSignal(signal)\n\t\tif err != nil {\n\t\t\tpanic(err)\n\t\t}\n\t}()\n\t<-done\n}\n\nfunc TestWriter(t *testing.T) {\n\tbuf := &bytes.Buffer{}\n\twr := NewWriter(buf)\n\twr.WriteError(\"ERR bad stuff\")\n\twr.Flush()\n\tif buf.String() != \"-ERR bad stuff\\r\\n\" {\n\t\tt.Fatal(\"failed\")\n\t}\n\tbuf.Reset()\n\twr.WriteString(\"HELLO\")\n\twr.Flush()\n\tif buf.String() != \"+HELLO\\r\\n\" {\n\t\tt.Fatal(\"failed\")\n\t}\n\tbuf.Reset()\n\twr.WriteInt(-1234)\n\twr.Flush()\n\tif buf.String() != \":-1234\\r\\n\" {\n\t\tt.Fatal(\"failed\")\n\t}\n\tbuf.Reset()\n\twr.WriteNull()\n\twr.Flush()\n\tif buf.String() != \"$-1\\r\\n\" {\n\t\tt.Fatal(\"failed\")\n\t}\n\tbuf.Reset()\n\twr.WriteBulk([]byte(\"HELLO\\r\\nPLANET\"))\n\twr.Flush()\n\tif buf.String() != \"$13\\r\\nHELLO\\r\\nPLANET\\r\\n\" {\n\t\tt.Fatal(\"failed\")\n\t}\n\tbuf.Reset()\n\twr.WriteBulkString(\"HELLO\\r\\nPLANET\")\n\twr.Flush()\n\tif buf.String() != \"$13\\r\\nHELLO\\r\\nPLANET\\r\\n\" {\n\t\tt.Fatal(\"failed\")\n\t}\n\tbuf.Reset()\n\twr.WriteArray(3)\n\twr.WriteBulkString(\"THIS\")\n\twr.WriteBulkString(\"THAT\")\n\twr.WriteString(\"THE OTHER THING\")\n\twr.Flush()\n\tif buf.String() != \"*3\\r\\n$4\\r\\nTHIS\\r\\n$4\\r\\nTHAT\\r\\n+THE OTHER THING\\r\\n\" {\n\t\tt.Fatal(\"failed\")\n\t}\n\tbuf.Reset()\n}\nfunc testMakeRawCommands(rawargs [][]string) []string {\n\tvar rawcmds []string\n\tfor i := 0; i < len(rawargs); i++ {\n\t\trawcmd := \"*\" + strconv.FormatUint(uint64(len(rawargs[i])), 10) + \"\\r\\n\"\n\t\tfor j := 0; j < len(rawargs[i]); j++ {\n\t\t\trawcmd += \"$\" + strconv.FormatUint(uint64(len(rawargs[i][j])), 10) + \"\\r\\n\"\n\t\t\trawcmd += rawargs[i][j] + \"\\r\\n\"\n\t\t}\n\t\trawcmds = append(rawcmds, rawcmd)\n\t}\n\treturn rawcmds\n}\n\nfunc TestReaderRespRandom(t *testing.T) {\n\trand.Seed(time.Now().UnixNano())\n\tfor h := 0; h < 10000; h++ {\n\t\tvar rawargs [][]string\n\t\tfor i := 0; i < 100; i++ {\n\t\t\t// var args []string\n\t\t\tn := int(rand.Int() % 16)\n\t\t\tfor j := 0; j < n; j++ {\n\t\t\t\targ := make([]byte, rand.Int()%512)\n\t\t\t\trand.Read(arg)\n\t\t\t\t// args = append(args, string(arg))\n\t\t\t}\n\t\t}\n\t\trawcmds := testMakeRawCommands(rawargs)\n\t\tdata := strings.Join(rawcmds, \"\")\n\t\trd := NewReader(bytes.NewBufferString(data))\n\t\tfor i := 0; i < len(rawcmds); i++ {\n\t\t\tif len(rawargs[i]) == 0 {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tcmd, err := rd.ReadCommand()\n\t\t\tif err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\t\t\tif string(cmd.Raw) != rawcmds[i] {\n\t\t\t\tt.Fatalf(\"expected '%v', got '%v'\", rawcmds[i], string(cmd.Raw))\n\t\t\t}\n\t\t\tif len(cmd.Args) != len(rawargs[i]) {\n\t\t\t\tt.Fatalf(\"expected '%v', got '%v'\", len(rawargs[i]), len(cmd.Args))\n\t\t\t}\n\t\t\tfor j := 0; j < len(rawargs[i]); j++ {\n\t\t\t\tif string(cmd.Args[j]) != rawargs[i][j] {\n\t\t\t\t\tt.Fatalf(\"expected '%v', got '%v'\", rawargs[i][j], string(cmd.Args[j]))\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc TestPlainReader(t *testing.T) {\n\trawargs := [][]string{\n\t\t{\"HELLO\", \"WORLD\"},\n\t\t{\"HELLO\", \"WORLD\"},\n\t\t{\"HELLO\", \"PLANET\"},\n\t\t{\"HELLO\", \"JELLO\"},\n\t\t{\"HELLO \", \"JELLO\"},\n\t}\n\trawcmds := []string{\n\t\t\"HELLO WORLD\\n\",\n\t\t\"HELLO WORLD\\r\\n\",\n\t\t\"  HELLO  PLANET \\r\\n\",\n\t\t\" \\\"HELLO\\\" \\\"JELLO\\\" \\r\\n\",\n\t\t\" \\\"HELLO \\\" JELLO \\n\",\n\t}\n\trawres := []string{\n\t\t\"*2\\r\\n$5\\r\\nHELLO\\r\\n$5\\r\\nWORLD\\r\\n\",\n\t\t\"*2\\r\\n$5\\r\\nHELLO\\r\\n$5\\r\\nWORLD\\r\\n\",\n\t\t\"*2\\r\\n$5\\r\\nHELLO\\r\\n$6\\r\\nPLANET\\r\\n\",\n\t\t\"*2\\r\\n$5\\r\\nHELLO\\r\\n$5\\r\\nJELLO\\r\\n\",\n\t\t\"*2\\r\\n$6\\r\\nHELLO \\r\\n$5\\r\\nJELLO\\r\\n\",\n\t}\n\tdata := strings.Join(rawcmds, \"\")\n\trd := NewReader(bytes.NewBufferString(data))\n\tfor i := 0; i < len(rawcmds); i++ {\n\t\tif len(rawargs[i]) == 0 {\n\t\t\tcontinue\n\t\t}\n\t\tcmd, err := rd.ReadCommand()\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tif string(cmd.Raw) != rawres[i] {\n\t\t\tt.Fatalf(\"expected '%v', got '%v'\", rawres[i], string(cmd.Raw))\n\t\t}\n\t\tif len(cmd.Args) != len(rawargs[i]) {\n\t\t\tt.Fatalf(\"expected '%v', got '%v'\", len(rawargs[i]), len(cmd.Args))\n\t\t}\n\t\tfor j := 0; j < len(rawargs[i]); j++ {\n\t\t\tif string(cmd.Args[j]) != rawargs[i][j] {\n\t\t\t\tt.Fatalf(\"expected '%v', got '%v'\", rawargs[i][j], string(cmd.Args[j]))\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc TestParse(t *testing.T) {\n\t_, err := Parse(nil)\n\tif err != errIncompleteCommand {\n\t\tt.Fatalf(\"expected '%v', got '%v'\", errIncompleteCommand, err)\n\t}\n\t_, err = Parse([]byte(\"*1\\r\\n\"))\n\tif err != errIncompleteCommand {\n\t\tt.Fatalf(\"expected '%v', got '%v'\", errIncompleteCommand, err)\n\t}\n\t_, err = Parse([]byte(\"*-1\\r\\n\"))\n\tif err != errInvalidMultiBulkLength {\n\t\tt.Fatalf(\"expected '%v', got '%v'\", errInvalidMultiBulkLength, err)\n\t}\n\t_, err = Parse([]byte(\"*0\\r\\n\"))\n\tif err != errInvalidMultiBulkLength {\n\t\tt.Fatalf(\"expected '%v', got '%v'\", errInvalidMultiBulkLength, err)\n\t}\n\tcmd, err := Parse([]byte(\"*1\\r\\n$1\\r\\nA\\r\\n\"))\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif string(cmd.Raw) != \"*1\\r\\n$1\\r\\nA\\r\\n\" {\n\t\tt.Fatalf(\"expected '%v', got '%v'\", \"*1\\r\\n$1\\r\\nA\\r\\n\", string(cmd.Raw))\n\t}\n\tif len(cmd.Args) != 1 {\n\t\tt.Fatalf(\"expected '%v', got '%v'\", 1, len(cmd.Args))\n\t}\n\tif string(cmd.Args[0]) != \"A\" {\n\t\tt.Fatalf(\"expected '%v', got '%v'\", \"A\", string(cmd.Args[0]))\n\t}\n\tcmd, err = Parse([]byte(\"A\\r\\n\"))\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif string(cmd.Raw) != \"*1\\r\\n$1\\r\\nA\\r\\n\" {\n\t\tt.Fatalf(\"expected '%v', got '%v'\", \"*1\\r\\n$1\\r\\nA\\r\\n\", string(cmd.Raw))\n\t}\n\tif len(cmd.Args) != 1 {\n\t\tt.Fatalf(\"expected '%v', got '%v'\", 1, len(cmd.Args))\n\t}\n\tif string(cmd.Args[0]) != \"A\" {\n\t\tt.Fatalf(\"expected '%v', got '%v'\", \"A\", string(cmd.Args[0]))\n\t}\n}\n\nfunc TestPubSub(t *testing.T) {\n\taddr := \":12346\"\n\tdone := make(chan bool)\n\tgo func() {\n\t\tvar ps PubSub\n\t\tgo func() {\n\t\t\ttch := time.NewTicker(time.Millisecond * 5)\n\t\t\tdefer tch.Stop()\n\t\t\tchannels := []string{\"achan1\", \"bchan2\", \"cchan3\", \"dchan4\"}\n\t\t\tfor i := 0; ; i++ {\n\t\t\t\tselect {\n\t\t\t\tcase <-tch.C:\n\t\t\t\tcase <-done:\n\t\t\t\t\tfor {\n\t\t\t\t\t\tvar empty bool\n\t\t\t\t\t\tps.mu.Lock()\n\t\t\t\t\t\tif len(ps.conns) == 0 {\n\t\t\t\t\t\t\tif ps.chans.Len() != 0 {\n\t\t\t\t\t\t\t\tpanic(\"chans not empty\")\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tempty = true\n\t\t\t\t\t\t}\n\t\t\t\t\t\tps.mu.Unlock()\n\t\t\t\t\t\tif empty {\n\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\t}\n\t\t\t\t\t\ttime.Sleep(time.Millisecond * 10)\n\t\t\t\t\t}\n\t\t\t\t\tdone <- true\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tchannel := channels[i%len(channels)]\n\t\t\t\tmessage := fmt.Sprintf(\"message %d\", i)\n\t\t\t\tps.Publish(channel, message)\n\t\t\t}\n\t\t}()\n\t\tpanic(ListenAndServe(addr, func(conn Conn, cmd Command) {\n\t\t\tswitch strings.ToLower(string(cmd.Args[0])) {\n\t\t\tdefault:\n\t\t\t\tconn.WriteError(\"ERR unknown command '\" +\n\t\t\t\t\tstring(cmd.Args[0]) + \"'\")\n\t\t\tcase \"publish\":\n\t\t\t\tif len(cmd.Args) != 3 {\n\t\t\t\t\tconn.WriteError(\"ERR wrong number of arguments for '\" +\n\t\t\t\t\t\tstring(cmd.Args[0]) + \"' command\")\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tcount := ps.Publish(string(cmd.Args[1]), string(cmd.Args[2]))\n\t\t\t\tconn.WriteInt(count)\n\t\t\tcase \"subscribe\", \"psubscribe\":\n\t\t\t\tif len(cmd.Args) < 2 {\n\t\t\t\t\tconn.WriteError(\"ERR wrong number of arguments for '\" +\n\t\t\t\t\t\tstring(cmd.Args[0]) + \"' command\")\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tcommand := strings.ToLower(string(cmd.Args[0]))\n\t\t\t\tfor i := 1; i < len(cmd.Args); i++ {\n\t\t\t\t\tif command == \"psubscribe\" {\n\t\t\t\t\t\tps.Psubscribe(conn, string(cmd.Args[i]))\n\t\t\t\t\t} else {\n\t\t\t\t\t\tps.Subscribe(conn, string(cmd.Args[i]))\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}, nil, nil))\n\t}()\n\n\tfinal := make(chan bool)\n\tgo func() {\n\t\tselect {\n\t\tcase <-time.Tick(time.Second * 30):\n\t\t\tpanic(\"timeout\")\n\t\tcase <-final:\n\t\t\treturn\n\t\t}\n\t}()\n\n\t// create 10 connections\n\tvar wg sync.WaitGroup\n\twg.Add(10)\n\tfor i := 0; i < 10; i++ {\n\t\tgo func(i int) {\n\t\t\tdefer wg.Done()\n\t\t\tvar conn net.Conn\n\t\t\tfor i := 0; i < 5; i++ {\n\t\t\t\tvar err error\n\t\t\t\tconn, err = net.Dial(\"tcp\", addr)\n\t\t\t\tif err != nil {\n\t\t\t\t\ttime.Sleep(time.Second / 10)\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t}\n\t\t\tif conn == nil {\n\t\t\t\tpanic(\"could not connect to server\")\n\t\t\t}\n\t\t\tdefer conn.Close()\n\n\t\t\tregs := make(map[string]int)\n\t\t\tvar maxp int\n\t\t\tvar maxs int\n\t\t\tfmt.Fprintf(conn, \"subscribe achan1\\r\\n\")\n\t\t\tfmt.Fprintf(conn, \"subscribe bchan2 cchan3\\r\\n\")\n\t\t\tfmt.Fprintf(conn, \"psubscribe a*1\\r\\n\")\n\t\t\tfmt.Fprintf(conn, \"psubscribe b*2 c*3\\r\\n\")\n\n\t\t\t// collect 50 messages from each channel\n\t\t\trd := bufio.NewReader(conn)\n\t\t\tvar buf []byte\n\t\t\tfor {\n\t\t\t\tline, err := rd.ReadBytes('\\n')\n\t\t\t\tif err != nil {\n\t\t\t\t\tpanic(err)\n\t\t\t\t}\n\t\t\t\tbuf = append(buf, line...)\n\t\t\t\tn, resp := ReadNextRESP(buf)\n\t\t\t\tif n == 0 {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\tbuf = nil\n\t\t\t\tif resp.Type != Array {\n\t\t\t\t\tpanic(\"expected array\")\n\t\t\t\t}\n\t\t\t\tvar vals []RESP\n\t\t\t\tresp.ForEach(func(item RESP) bool {\n\t\t\t\t\tvals = append(vals, item)\n\t\t\t\t\treturn true\n\t\t\t\t})\n\n\t\t\t\tname := string(vals[0].Data)\n\t\t\t\tswitch name {\n\t\t\t\tcase \"subscribe\":\n\t\t\t\t\tif len(vals) != 3 {\n\t\t\t\t\t\tpanic(\"invalid count\")\n\t\t\t\t\t}\n\t\t\t\t\tch := string(vals[1].Data)\n\t\t\t\t\tregs[ch] = 0\n\t\t\t\t\tmaxs, _ = strconv.Atoi(string(vals[2].Data))\n\t\t\t\tcase \"psubscribe\":\n\t\t\t\t\tif len(vals) != 3 {\n\t\t\t\t\t\tpanic(\"invalid count\")\n\t\t\t\t\t}\n\t\t\t\t\tch := string(vals[1].Data)\n\t\t\t\t\tregs[ch] = 0\n\t\t\t\t\tmaxp, _ = strconv.Atoi(string(vals[2].Data))\n\t\t\t\tcase \"message\":\n\t\t\t\t\tif len(vals) != 3 {\n\t\t\t\t\t\tpanic(\"invalid count\")\n\t\t\t\t\t}\n\t\t\t\t\tch := string(vals[1].Data)\n\t\t\t\t\tregs[ch] = regs[ch] + 1\n\t\t\t\tcase \"pmessage\":\n\t\t\t\t\tif len(vals) != 4 {\n\t\t\t\t\t\tpanic(\"invalid count\")\n\t\t\t\t\t}\n\t\t\t\t\tch := string(vals[1].Data)\n\t\t\t\t\tregs[ch] = regs[ch] + 1\n\t\t\t\t}\n\t\t\t\tif len(regs) == 6 && maxp == 3 && maxs == 3 {\n\t\t\t\t\tready := true\n\t\t\t\t\tfor _, count := range regs {\n\t\t\t\t\t\tif count < 50 {\n\t\t\t\t\t\t\tready = false\n\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif ready {\n\t\t\t\t\t\t// all messages have been received\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}(i)\n\t}\n\twg.Wait()\n\t// notify sender\n\tdone <- true\n\t// wait for sender\n\t<-done\n\t// stop the timeout\n\tfinal <- true\n}\n"
        },
        {
          "name": "resp.go",
          "type": "blob",
          "size": 15.8896484375,
          "content": "package redcon\n\nimport (\n\t\"fmt\"\n\t\"reflect\"\n\t\"sort\"\n\t\"strconv\"\n\t\"strings\"\n)\n\n// Type of RESP\ntype Type byte\n\n// Various RESP kinds\nconst (\n\tInteger = ':'\n\tString  = '+'\n\tBulk    = '$'\n\tArray   = '*'\n\tError   = '-'\n)\n\ntype RESP struct {\n\tType  Type\n\tRaw   []byte\n\tData  []byte\n\tCount int\n}\n\n// ForEach iterates over each Array element\nfunc (r RESP) ForEach(iter func(resp RESP) bool) {\n\tdata := r.Data\n\tfor i := 0; i < r.Count; i++ {\n\t\tn, resp := ReadNextRESP(data)\n\t\tif !iter(resp) {\n\t\t\treturn\n\t\t}\n\t\tdata = data[n:]\n\t}\n}\n\nfunc (r RESP) Bytes() []byte {\n\treturn r.Data\n}\n\nfunc (r RESP) String() string {\n\treturn string(r.Data)\n}\n\nfunc (r RESP) Int() int64 {\n\tx, _ := strconv.ParseInt(r.String(), 10, 64)\n\treturn x\n}\n\nfunc (r RESP) Float() float64 {\n\tx, _ := strconv.ParseFloat(r.String(), 10)\n\treturn x\n}\n\n// Map returns a key/value map of an Array.\n// The receiver RESP must be an Array with an equal number of values, where\n// the value of the key is followed by the key.\n// Example: key1,value1,key2,value2,key3,value3\nfunc (r RESP) Map() map[string]RESP {\n\tif r.Type != Array {\n\t\treturn nil\n\t}\n\tvar n int\n\tvar key string\n\tm := make(map[string]RESP)\n\tr.ForEach(func(resp RESP) bool {\n\t\tif n&1 == 0 {\n\t\t\tkey = resp.String()\n\t\t} else {\n\t\t\tm[key] = resp\n\t\t}\n\t\tn++\n\t\treturn true\n\t})\n\treturn m\n}\n\nfunc (r RESP) MapGet(key string) RESP {\n\tif r.Type != Array {\n\t\treturn RESP{}\n\t}\n\tvar val RESP\n\tvar n int\n\tvar ok bool\n\tr.ForEach(func(resp RESP) bool {\n\t\tif n&1 == 0 {\n\t\t\tok = resp.String() == key\n\t\t} else if ok {\n\t\t\tval = resp\n\t\t\treturn false\n\t\t}\n\t\tn++\n\t\treturn true\n\t})\n\treturn val\n}\n\nfunc (r RESP) Exists() bool {\n\treturn r.Type != 0\n}\n\n// ReadNextRESP returns the next resp in b and returns the number of bytes the\n// took up the result.\nfunc ReadNextRESP(b []byte) (n int, resp RESP) {\n\tif len(b) == 0 {\n\t\treturn 0, RESP{} // no data to read\n\t}\n\tresp.Type = Type(b[0])\n\tswitch resp.Type {\n\tcase Integer, String, Bulk, Array, Error:\n\tdefault:\n\t\treturn 0, RESP{} // invalid kind\n\t}\n\t// read to end of line\n\ti := 1\n\tfor ; ; i++ {\n\t\tif i == len(b) {\n\t\t\treturn 0, RESP{} // not enough data\n\t\t}\n\t\tif b[i] == '\\n' {\n\t\t\tif b[i-1] != '\\r' {\n\t\t\t\treturn 0, RESP{} //, missing CR character\n\t\t\t}\n\t\t\ti++\n\t\t\tbreak\n\t\t}\n\t}\n\tresp.Raw = b[0:i]\n\tresp.Data = b[1 : i-2]\n\tif resp.Type == Integer {\n\t\t// Integer\n\t\tif len(resp.Data) == 0 {\n\t\t\treturn 0, RESP{} //, invalid integer\n\t\t}\n\t\tvar j int\n\t\tif resp.Data[0] == '-' {\n\t\t\tif len(resp.Data) == 1 {\n\t\t\t\treturn 0, RESP{} //, invalid integer\n\t\t\t}\n\t\t\tj++\n\t\t}\n\t\tfor ; j < len(resp.Data); j++ {\n\t\t\tif resp.Data[j] < '0' || resp.Data[j] > '9' {\n\t\t\t\treturn 0, RESP{} // invalid integer\n\t\t\t}\n\t\t}\n\t\treturn len(resp.Raw), resp\n\t}\n\tif resp.Type == String || resp.Type == Error {\n\t\t// String, Error\n\t\treturn len(resp.Raw), resp\n\t}\n\tvar err error\n\tresp.Count, err = strconv.Atoi(string(resp.Data))\n\tif resp.Type == Bulk {\n\t\t// Bulk\n\t\tif err != nil {\n\t\t\treturn 0, RESP{} // invalid number of bytes\n\t\t}\n\t\tif resp.Count < 0 {\n\t\t\tresp.Data = nil\n\t\t\tresp.Count = 0\n\t\t\treturn len(resp.Raw), resp\n\t\t}\n\t\tif len(b) < i+resp.Count+2 {\n\t\t\treturn 0, RESP{} // not enough data\n\t\t}\n\t\tif b[i+resp.Count] != '\\r' || b[i+resp.Count+1] != '\\n' {\n\t\t\treturn 0, RESP{} // invalid end of line\n\t\t}\n\t\tresp.Data = b[i : i+resp.Count]\n\t\tresp.Raw = b[0 : i+resp.Count+2]\n\t\tresp.Count = 0\n\t\treturn len(resp.Raw), resp\n\t}\n\t// Array\n\tif err != nil {\n\t\treturn 0, RESP{} // invalid number of elements\n\t}\n\tvar tn int\n\tsdata := b[i:]\n\tfor j := 0; j < resp.Count; j++ {\n\t\trn, rresp := ReadNextRESP(sdata)\n\t\tif rresp.Type == 0 {\n\t\t\treturn 0, RESP{}\n\t\t}\n\t\ttn += rn\n\t\tsdata = sdata[rn:]\n\t}\n\tresp.Data = b[i : i+tn]\n\tresp.Raw = b[0 : i+tn]\n\treturn len(resp.Raw), resp\n}\n\n// Kind is the kind of command\ntype Kind int\n\nconst (\n\t// Redis is returned for Redis protocol commands\n\tRedis Kind = iota\n\t// Tile38 is returnd for Tile38 native protocol commands\n\tTile38\n\t// Telnet is returnd for plain telnet commands\n\tTelnet\n)\n\nvar errInvalidMessage = &errProtocol{\"invalid message\"}\n\n// ReadNextCommand reads the next command from the provided packet. It's\n// possible that the packet contains multiple commands, or zero commands\n// when the packet is incomplete.\n// 'argsbuf' is an optional reusable buffer and it can be nil.\n// 'complete' indicates that a command was read. false means no more commands.\n// 'args' are the output arguments for the command.\n// 'kind' is the type of command that was read.\n// 'leftover' is any remaining unused bytes which belong to the next command.\n// 'err' is returned when a protocol error was encountered.\nfunc ReadNextCommand(packet []byte, argsbuf [][]byte) (\n\tcomplete bool, args [][]byte, kind Kind, leftover []byte, err error,\n) {\n\targs = argsbuf[:0]\n\tif len(packet) > 0 {\n\t\tif packet[0] != '*' {\n\t\t\tif packet[0] == '$' {\n\t\t\t\treturn readTile38Command(packet, args)\n\t\t\t}\n\t\t\treturn readTelnetCommand(packet, args)\n\t\t}\n\t\t// standard redis command\n\t\tfor s, i := 1, 1; i < len(packet); i++ {\n\t\t\tif packet[i] == '\\n' {\n\t\t\t\tif packet[i-1] != '\\r' {\n\t\t\t\t\treturn false, args[:0], Redis, packet, errInvalidMultiBulkLength\n\t\t\t\t}\n\t\t\t\tcount, ok := parseInt(packet[s : i-1])\n\t\t\t\tif !ok || count < 0 {\n\t\t\t\t\treturn false, args[:0], Redis, packet, errInvalidMultiBulkLength\n\t\t\t\t}\n\t\t\t\ti++\n\t\t\t\tif count == 0 {\n\t\t\t\t\treturn true, args[:0], Redis, packet[i:], nil\n\t\t\t\t}\n\t\t\tnextArg:\n\t\t\t\tfor j := 0; j < count; j++ {\n\t\t\t\t\tif i == len(packet) {\n\t\t\t\t\t\tbreak\n\t\t\t\t\t}\n\t\t\t\t\tif packet[i] != '$' {\n\t\t\t\t\t\treturn false, args[:0], Redis, packet,\n\t\t\t\t\t\t\t&errProtocol{\"expected '$', got '\" +\n\t\t\t\t\t\t\t\tstring(packet[i]) + \"'\"}\n\t\t\t\t\t}\n\t\t\t\t\tfor s := i + 1; i < len(packet); i++ {\n\t\t\t\t\t\tif packet[i] == '\\n' {\n\t\t\t\t\t\t\tif packet[i-1] != '\\r' {\n\t\t\t\t\t\t\t\treturn false, args[:0], Redis, packet, errInvalidBulkLength\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tn, ok := parseInt(packet[s : i-1])\n\t\t\t\t\t\t\tif !ok || count <= 0 {\n\t\t\t\t\t\t\t\treturn false, args[:0], Redis, packet, errInvalidBulkLength\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ti++\n\t\t\t\t\t\t\tif len(packet)-i >= n+2 {\n\t\t\t\t\t\t\t\tif packet[i+n] != '\\r' || packet[i+n+1] != '\\n' {\n\t\t\t\t\t\t\t\t\treturn false, args[:0], Redis, packet, errInvalidBulkLength\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\targs = append(args, packet[i:i+n])\n\t\t\t\t\t\t\t\ti += n + 2\n\t\t\t\t\t\t\t\tif j == count-1 {\n\t\t\t\t\t\t\t\t\t// done reading\n\t\t\t\t\t\t\t\t\treturn true, args, Redis, packet[i:], nil\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tcontinue nextArg\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}\n\treturn false, args[:0], Redis, packet, nil\n}\n\nfunc readTile38Command(packet []byte, argsbuf [][]byte) (\n\tcomplete bool, args [][]byte, kind Kind, leftover []byte, err error,\n) {\n\tfor i := 1; i < len(packet); i++ {\n\t\tif packet[i] == ' ' {\n\t\t\tn, ok := parseInt(packet[1:i])\n\t\t\tif !ok || n < 0 {\n\t\t\t\treturn false, args[:0], Tile38, packet, errInvalidMessage\n\t\t\t}\n\t\t\ti++\n\t\t\tif len(packet) >= i+n+2 {\n\t\t\t\tif packet[i+n] != '\\r' || packet[i+n+1] != '\\n' {\n\t\t\t\t\treturn false, args[:0], Tile38, packet, errInvalidMessage\n\t\t\t\t}\n\t\t\t\tline := packet[i : i+n]\n\t\t\treading:\n\t\t\t\tfor len(line) != 0 {\n\t\t\t\t\tif line[0] == '{' {\n\t\t\t\t\t\t// The native protocol cannot understand json boundaries so it assumes that\n\t\t\t\t\t\t// a json element must be at the end of the line.\n\t\t\t\t\t\targs = append(args, line)\n\t\t\t\t\t\tbreak\n\t\t\t\t\t}\n\t\t\t\t\tif line[0] == '\"' && line[len(line)-1] == '\"' {\n\t\t\t\t\t\tif len(args) > 0 &&\n\t\t\t\t\t\t\tstrings.ToLower(string(args[0])) == \"set\" &&\n\t\t\t\t\t\t\tstrings.ToLower(string(args[len(args)-1])) == \"string\" {\n\t\t\t\t\t\t\t// Setting a string value that is contained inside double quotes.\n\t\t\t\t\t\t\t// This is only because of the boundary issues of the native protocol.\n\t\t\t\t\t\t\targs = append(args, line[1:len(line)-1])\n\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\ti := 0\n\t\t\t\t\tfor ; i < len(line); i++ {\n\t\t\t\t\t\tif line[i] == ' ' {\n\t\t\t\t\t\t\tvalue := line[:i]\n\t\t\t\t\t\t\tif len(value) > 0 {\n\t\t\t\t\t\t\t\targs = append(args, value)\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tline = line[i+1:]\n\t\t\t\t\t\t\tcontinue reading\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\targs = append(args, line)\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t\treturn true, args, Tile38, packet[i+n+2:], nil\n\t\t\t}\n\t\t\tbreak\n\t\t}\n\t}\n\treturn false, args[:0], Tile38, packet, nil\n}\nfunc readTelnetCommand(packet []byte, argsbuf [][]byte) (\n\tcomplete bool, args [][]byte, kind Kind, leftover []byte, err error,\n) {\n\t// just a plain text command\n\tfor i := 0; i < len(packet); i++ {\n\t\tif packet[i] == '\\n' {\n\t\t\tvar line []byte\n\t\t\tif i > 0 && packet[i-1] == '\\r' {\n\t\t\t\tline = packet[:i-1]\n\t\t\t} else {\n\t\t\t\tline = packet[:i]\n\t\t\t}\n\t\t\tvar quote bool\n\t\t\tvar quotech byte\n\t\t\tvar escape bool\n\t\touter:\n\t\t\tfor {\n\t\t\t\tnline := make([]byte, 0, len(line))\n\t\t\t\tfor i := 0; i < len(line); i++ {\n\t\t\t\t\tc := line[i]\n\t\t\t\t\tif !quote {\n\t\t\t\t\t\tif c == ' ' {\n\t\t\t\t\t\t\tif len(nline) > 0 {\n\t\t\t\t\t\t\t\targs = append(args, nline)\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tline = line[i+1:]\n\t\t\t\t\t\t\tcontinue outer\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif c == '\"' || c == '\\'' {\n\t\t\t\t\t\t\tif i != 0 {\n\t\t\t\t\t\t\t\treturn false, args[:0], Telnet, packet, errUnbalancedQuotes\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tquotech = c\n\t\t\t\t\t\t\tquote = true\n\t\t\t\t\t\t\tline = line[i+1:]\n\t\t\t\t\t\t\tcontinue outer\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif escape {\n\t\t\t\t\t\t\tescape = false\n\t\t\t\t\t\t\tswitch c {\n\t\t\t\t\t\t\tcase 'n':\n\t\t\t\t\t\t\t\tc = '\\n'\n\t\t\t\t\t\t\tcase 'r':\n\t\t\t\t\t\t\t\tc = '\\r'\n\t\t\t\t\t\t\tcase 't':\n\t\t\t\t\t\t\t\tc = '\\t'\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else if c == quotech {\n\t\t\t\t\t\t\tquote = false\n\t\t\t\t\t\t\tquotech = 0\n\t\t\t\t\t\t\targs = append(args, nline)\n\t\t\t\t\t\t\tline = line[i+1:]\n\t\t\t\t\t\t\tif len(line) > 0 && line[0] != ' ' {\n\t\t\t\t\t\t\t\treturn false, args[:0], Telnet, packet, errUnbalancedQuotes\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcontinue outer\n\t\t\t\t\t\t} else if c == '\\\\' {\n\t\t\t\t\t\t\tescape = true\n\t\t\t\t\t\t\tcontinue\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tnline = append(nline, c)\n\t\t\t\t}\n\t\t\t\tif quote {\n\t\t\t\t\treturn false, args[:0], Telnet, packet, errUnbalancedQuotes\n\t\t\t\t}\n\t\t\t\tif len(line) > 0 {\n\t\t\t\t\targs = append(args, line)\n\t\t\t\t}\n\t\t\t\tbreak\n\t\t\t}\n\t\t\treturn true, args, Telnet, packet[i+1:], nil\n\t\t}\n\t}\n\treturn false, args[:0], Telnet, packet, nil\n}\n\n// appendPrefix will append a \"$3\\r\\n\" style redis prefix for a message.\nfunc appendPrefix(b []byte, c byte, n int64) []byte {\n\tif n >= 0 && n <= 9 {\n\t\treturn append(b, c, byte('0'+n), '\\r', '\\n')\n\t}\n\tb = append(b, c)\n\tb = strconv.AppendInt(b, n, 10)\n\treturn append(b, '\\r', '\\n')\n}\n\n// AppendUint appends a Redis protocol uint64 to the input bytes.\nfunc AppendUint(b []byte, n uint64) []byte {\n\tb = append(b, ':')\n\tb = strconv.AppendUint(b, n, 10)\n\treturn append(b, '\\r', '\\n')\n}\n\n// AppendInt appends a Redis protocol int64 to the input bytes.\nfunc AppendInt(b []byte, n int64) []byte {\n\treturn appendPrefix(b, ':', n)\n}\n\n// AppendArray appends a Redis protocol array to the input bytes.\nfunc AppendArray(b []byte, n int) []byte {\n\treturn appendPrefix(b, '*', int64(n))\n}\n\n// AppendBulk appends a Redis protocol bulk byte slice to the input bytes.\nfunc AppendBulk(b []byte, bulk []byte) []byte {\n\tb = appendPrefix(b, '$', int64(len(bulk)))\n\tb = append(b, bulk...)\n\treturn append(b, '\\r', '\\n')\n}\n\n// AppendBulkString appends a Redis protocol bulk string to the input bytes.\nfunc AppendBulkString(b []byte, bulk string) []byte {\n\tb = appendPrefix(b, '$', int64(len(bulk)))\n\tb = append(b, bulk...)\n\treturn append(b, '\\r', '\\n')\n}\n\n// AppendString appends a Redis protocol string to the input bytes.\nfunc AppendString(b []byte, s string) []byte {\n\tb = append(b, '+')\n\tb = append(b, stripNewlines(s)...)\n\treturn append(b, '\\r', '\\n')\n}\n\n// AppendError appends a Redis protocol error to the input bytes.\nfunc AppendError(b []byte, s string) []byte {\n\tb = append(b, '-')\n\tb = append(b, stripNewlines(s)...)\n\treturn append(b, '\\r', '\\n')\n}\n\n// AppendOK appends a Redis protocol OK to the input bytes.\nfunc AppendOK(b []byte) []byte {\n\treturn append(b, '+', 'O', 'K', '\\r', '\\n')\n}\nfunc stripNewlines(s string) string {\n\tfor i := 0; i < len(s); i++ {\n\t\tif s[i] == '\\r' || s[i] == '\\n' {\n\t\t\ts = strings.Replace(s, \"\\r\", \" \", -1)\n\t\t\ts = strings.Replace(s, \"\\n\", \" \", -1)\n\t\t\tbreak\n\t\t}\n\t}\n\treturn s\n}\n\n// AppendTile38 appends a Tile38 message to the input bytes.\nfunc AppendTile38(b []byte, data []byte) []byte {\n\tb = append(b, '$')\n\tb = strconv.AppendInt(b, int64(len(data)), 10)\n\tb = append(b, ' ')\n\tb = append(b, data...)\n\treturn append(b, '\\r', '\\n')\n}\n\n// AppendNull appends a Redis protocol null to the input bytes.\nfunc AppendNull(b []byte) []byte {\n\treturn append(b, '$', '-', '1', '\\r', '\\n')\n}\n\n// AppendBulkFloat appends a float64, as bulk bytes.\nfunc AppendBulkFloat(dst []byte, f float64) []byte {\n\treturn AppendBulk(dst, strconv.AppendFloat(nil, f, 'f', -1, 64))\n}\n\n// AppendBulkInt appends an int64, as bulk bytes.\nfunc AppendBulkInt(dst []byte, x int64) []byte {\n\treturn AppendBulk(dst, strconv.AppendInt(nil, x, 10))\n}\n\n// AppendBulkUint appends an uint64, as bulk bytes.\nfunc AppendBulkUint(dst []byte, x uint64) []byte {\n\treturn AppendBulk(dst, strconv.AppendUint(nil, x, 10))\n}\n\nfunc prefixERRIfNeeded(msg string) string {\n\tmsg = strings.TrimSpace(msg)\n\tfirstWord := strings.Split(msg, \" \")[0]\n\taddERR := len(firstWord) == 0\n\tfor i := 0; i < len(firstWord); i++ {\n\t\tif firstWord[i] < 'A' || firstWord[i] > 'Z' {\n\t\t\taddERR = true\n\t\t\tbreak\n\t\t}\n\t}\n\tif addERR {\n\t\tmsg = strings.TrimSpace(\"ERR \" + msg)\n\t}\n\treturn msg\n}\n\n// SimpleString is for representing a non-bulk representation of a string\n// from an *Any call.\ntype SimpleString string\n\n// SimpleInt is for representing a non-bulk representation of a int\n// from an *Any call.\ntype SimpleInt int\n\n// SimpleError is for representing an error without adding the \"ERR\" prefix\n// from an *Any call.\ntype SimpleError error\n\n// Marshaler is the interface implemented by types that\n// can marshal themselves into a Redis response type from an *Any call.\n// The return value is not check for validity.\ntype Marshaler interface {\n\tMarshalRESP() []byte\n}\n\n// AppendAny appends any type to valid Redis type.\n//   nil             -> null\n//   error           -> error (adds \"ERR \" when first word is not uppercase)\n//   string          -> bulk-string\n//   numbers         -> bulk-string\n//   []byte          -> bulk-string\n//   bool            -> bulk-string (\"0\" or \"1\")\n//   slice           -> array\n//   map             -> array with key/value pairs\n//   SimpleString    -> string\n//   SimpleInt       -> integer\n//   Marshaler       -> raw bytes\n//   everything-else -> bulk-string representation using fmt.Sprint()\nfunc AppendAny(b []byte, v interface{}) []byte {\n\tswitch v := v.(type) {\n\tcase SimpleString:\n\t\tb = AppendString(b, string(v))\n\tcase SimpleInt:\n\t\tb = AppendInt(b, int64(v))\n\tcase SimpleError:\n\t\tb = AppendError(b, v.Error())\n\tcase nil:\n\t\tb = AppendNull(b)\n\tcase error:\n\t\tb = AppendError(b, prefixERRIfNeeded(v.Error()))\n\tcase string:\n\t\tb = AppendBulkString(b, v)\n\tcase []byte:\n\t\tb = AppendBulk(b, v)\n\tcase bool:\n\t\tif v {\n\t\t\tb = AppendBulkString(b, \"1\")\n\t\t} else {\n\t\t\tb = AppendBulkString(b, \"0\")\n\t\t}\n\tcase int:\n\t\tb = AppendBulkInt(b, int64(v))\n\tcase int8:\n\t\tb = AppendBulkInt(b, int64(v))\n\tcase int16:\n\t\tb = AppendBulkInt(b, int64(v))\n\tcase int32:\n\t\tb = AppendBulkInt(b, int64(v))\n\tcase int64:\n\t\tb = AppendBulkInt(b, int64(v))\n\tcase uint:\n\t\tb = AppendBulkUint(b, uint64(v))\n\tcase uint8:\n\t\tb = AppendBulkUint(b, uint64(v))\n\tcase uint16:\n\t\tb = AppendBulkUint(b, uint64(v))\n\tcase uint32:\n\t\tb = AppendBulkUint(b, uint64(v))\n\tcase uint64:\n\t\tb = AppendBulkUint(b, uint64(v))\n\tcase float32:\n\t\tb = AppendBulkFloat(b, float64(v))\n\tcase float64:\n\t\tb = AppendBulkFloat(b, float64(v))\n\tcase Marshaler:\n\t\tb = append(b, v.MarshalRESP()...)\n\tdefault:\n\t\tvv := reflect.ValueOf(v)\n\t\tswitch vv.Kind() {\n\t\tcase reflect.Slice:\n\t\t\tn := vv.Len()\n\t\t\tb = AppendArray(b, n)\n\t\t\tfor i := 0; i < n; i++ {\n\t\t\t\tb = AppendAny(b, vv.Index(i).Interface())\n\t\t\t}\n\t\tcase reflect.Map:\n\t\t\tn := vv.Len()\n\t\t\tb = AppendArray(b, n*2)\n\t\t\tvar i int\n\t\t\tvar strKey bool\n\t\t\tvar strsKeyItems []strKeyItem\n\n\t\t\titer := vv.MapRange()\n\t\t\tfor iter.Next() {\n\t\t\t\tkey := iter.Key().Interface()\n\t\t\t\tif i == 0 {\n\t\t\t\t\tif _, ok := key.(string); ok {\n\t\t\t\t\t\tstrKey = true\n\t\t\t\t\t\tstrsKeyItems = make([]strKeyItem, n)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif strKey {\n\t\t\t\t\tstrsKeyItems[i] = strKeyItem{\n\t\t\t\t\t\tkey.(string), iter.Value().Interface(),\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tb = AppendAny(b, key)\n\t\t\t\t\tb = AppendAny(b, iter.Value().Interface())\n\t\t\t\t}\n\t\t\t\ti++\n\t\t\t}\n\t\t\tif strKey {\n\t\t\t\tsort.Slice(strsKeyItems, func(i, j int) bool {\n\t\t\t\t\treturn strsKeyItems[i].key < strsKeyItems[j].key\n\t\t\t\t})\n\t\t\t\tfor _, item := range strsKeyItems {\n\t\t\t\t\tb = AppendBulkString(b, item.key)\n\t\t\t\t\tb = AppendAny(b, item.value)\n\t\t\t\t}\n\t\t\t}\n\t\tdefault:\n\t\t\tb = AppendBulkString(b, fmt.Sprint(v))\n\t\t}\n\t}\n\treturn b\n}\n\ntype strKeyItem struct {\n\tkey   string\n\tvalue interface{}\n}\n"
        },
        {
          "name": "resp_test.go",
          "type": "blob",
          "size": 6.4951171875,
          "content": "package redcon\n\nimport (\n\t\"bytes\"\n\t\"fmt\"\n\t\"math/rand\"\n\t\"strconv\"\n\t\"testing\"\n\t\"time\"\n)\n\nfunc isEmptyRESP(resp RESP) bool {\n\treturn resp.Type == 0 && resp.Count == 0 &&\n\t\tresp.Data == nil && resp.Raw == nil\n}\n\nfunc expectBad(t *testing.T, payload string) {\n\tt.Helper()\n\tn, resp := ReadNextRESP([]byte(payload))\n\tif n > 0 || !isEmptyRESP(resp) {\n\t\tt.Fatalf(\"expected empty resp\")\n\t}\n}\n\nfunc respVOut(a RESP) string {\n\tvar data string\n\tvar raw string\n\tif a.Data == nil {\n\t\tdata = \"nil\"\n\t} else {\n\t\tdata = strconv.Quote(string(a.Data))\n\t}\n\tif a.Raw == nil {\n\t\traw = \"nil\"\n\t} else {\n\t\traw = strconv.Quote(string(a.Raw))\n\t}\n\treturn fmt.Sprintf(\"{Type: %d, Count: %d, Data: %s, Raw: %s}\",\n\t\ta.Type, a.Count, data, raw,\n\t)\n}\n\nfunc respEquals(a, b RESP) bool {\n\tif a.Count != b.Count {\n\t\treturn false\n\t}\n\tif a.Type != b.Type {\n\t\treturn false\n\t}\n\tif (a.Data == nil && b.Data != nil) || (a.Data != nil && b.Data == nil) {\n\t\treturn false\n\t}\n\tif string(a.Data) != string(b.Data) {\n\t\treturn false\n\t}\n\tif (a.Raw == nil && b.Raw != nil) || (a.Raw != nil && b.Raw == nil) {\n\t\treturn false\n\t}\n\tif string(a.Raw) != string(b.Raw) {\n\t\treturn false\n\t}\n\treturn true\n}\n\nfunc expectGood(t *testing.T, payload string, exp RESP) {\n\tt.Helper()\n\tn, resp := ReadNextRESP([]byte(payload))\n\tif n != len(payload) || isEmptyRESP(resp) {\n\t\tt.Fatalf(\"expected good resp\")\n\t}\n\tif string(resp.Raw) != payload {\n\t\tt.Fatalf(\"expected '%s', got '%s'\", payload, resp.Raw)\n\t}\n\texp.Raw = []byte(payload)\n\tswitch exp.Type {\n\tcase Integer, String, Error:\n\t\texp.Data = []byte(payload[1 : len(payload)-2])\n\t}\n\tif !respEquals(resp, exp) {\n\t\tt.Fatalf(\"expected %v, got %v\", respVOut(exp), respVOut(resp))\n\t}\n}\n\nfunc TestRESP(t *testing.T) {\n\texpectBad(t, \"\")\n\texpectBad(t, \"^hello\\r\\n\")\n\texpectBad(t, \"+hello\\r\")\n\texpectBad(t, \"+hello\\n\")\n\texpectBad(t, \":\\r\\n\")\n\texpectBad(t, \":-\\r\\n\")\n\texpectBad(t, \":-abc\\r\\n\")\n\texpectBad(t, \":abc\\r\\n\")\n\texpectGood(t, \":-123\\r\\n\", RESP{Type: Integer})\n\texpectGood(t, \":123\\r\\n\", RESP{Type: Integer})\n\texpectBad(t, \"+\\r\")\n\texpectBad(t, \"+\\n\")\n\texpectGood(t, \"+\\r\\n\", RESP{Type: String})\n\texpectGood(t, \"+hello world\\r\\n\", RESP{Type: String})\n\texpectBad(t, \"-\\r\")\n\texpectBad(t, \"-\\n\")\n\texpectGood(t, \"-\\r\\n\", RESP{Type: Error})\n\texpectGood(t, \"-hello world\\r\\n\", RESP{Type: Error})\n\texpectBad(t, \"$\")\n\texpectBad(t, \"$\\r\")\n\texpectBad(t, \"$\\r\\n\")\n\texpectGood(t, \"$-1\\r\\n\", RESP{Type: Bulk})\n\texpectGood(t, \"$0\\r\\n\\r\\n\", RESP{Type: Bulk, Data: []byte(\"\")})\n\texpectBad(t, \"$5\\r\\nhello\\r\")\n\texpectBad(t, \"$5\\r\\nhello\\n\\n\")\n\texpectGood(t, \"$5\\r\\nhello\\r\\n\", RESP{Type: Bulk, Data: []byte(\"hello\")})\n\texpectBad(t, \"*a\\r\\n\")\n\texpectBad(t, \"*3\\r\\n\")\n\texpectBad(t, \"*3\\r\\n:hello\\r\")\n\texpectGood(t, \"*3\\r\\n:1\\r\\n:2\\r\\n:3\\r\\n\",\n\t\tRESP{Type: Array, Count: 3, Data: []byte(\":1\\r\\n:2\\r\\n:3\\r\\n\")})\n\n\tvar xx int\n\t_, r := ReadNextRESP([]byte(\"*4\\r\\n:1\\r\\n:2\\r\\n:3\\r\\n:4\\r\\n\"))\n\tr.ForEach(func(resp RESP) bool {\n\t\txx++\n\t\tx, _ := strconv.Atoi(string(resp.Data))\n\t\tif x != xx {\n\t\t\tt.Fatalf(\"expected %v, got %v\", x, xx)\n\t\t}\n\t\tif xx == 3 {\n\t\t\treturn false\n\t\t}\n\t\treturn true\n\t})\n\tif xx != 3 {\n\t\tt.Fatalf(\"expected %v, got %v\", 3, xx)\n\t}\n}\n\nfunc TestNextCommand(t *testing.T) {\n\trand.Seed(time.Now().UnixNano())\n\tstart := time.Now()\n\tfor time.Since(start) < time.Second {\n\t\t// keep copy of pipeline args for final compare\n\t\tvar plargs [][][]byte\n\n\t\t// create a pipeline of random number of commands with random data.\n\t\tN := rand.Int() % 10000\n\t\tvar data []byte\n\t\tfor i := 0; i < N; i++ {\n\t\t\tnargs := rand.Int() % 10\n\t\t\tdata = AppendArray(data, nargs)\n\t\t\tvar args [][]byte\n\t\t\tfor j := 0; j < nargs; j++ {\n\t\t\t\targ := make([]byte, rand.Int()%100)\n\t\t\t\tif _, err := rand.Read(arg); err != nil {\n\t\t\t\t\tt.Fatal(err)\n\t\t\t\t}\n\t\t\t\tdata = AppendBulk(data, arg)\n\t\t\t\targs = append(args, arg)\n\t\t\t}\n\t\t\tplargs = append(plargs, args)\n\t\t}\n\n\t\t// break data into random number of chunks\n\t\tchunkn := rand.Int() % 100\n\t\tif chunkn == 0 {\n\t\t\tchunkn = 1\n\t\t}\n\t\tif len(data) < chunkn {\n\t\t\tcontinue\n\t\t}\n\t\tvar chunks [][]byte\n\t\tvar chunksz int\n\t\tfor i := 0; i < len(data); i += chunksz {\n\t\t\tchunksz = rand.Int() % (len(data) / chunkn)\n\t\t\tvar chunk []byte\n\t\t\tif i+chunksz < len(data) {\n\t\t\t\tchunk = data[i : i+chunksz]\n\t\t\t} else {\n\t\t\t\tchunk = data[i:]\n\t\t\t}\n\t\t\tchunks = append(chunks, chunk)\n\t\t}\n\n\t\t// process chunks\n\t\tvar rbuf []byte\n\t\tvar fargs [][][]byte\n\t\tfor _, chunk := range chunks {\n\t\t\tvar data []byte\n\t\t\tif len(rbuf) > 0 {\n\t\t\t\tdata = append(rbuf, chunk...)\n\t\t\t} else {\n\t\t\t\tdata = chunk\n\t\t\t}\n\t\t\tfor {\n\t\t\t\tcomplete, args, _, leftover, err := ReadNextCommand(data, nil)\n\t\t\t\tdata = leftover\n\t\t\t\tif err != nil {\n\t\t\t\t\tt.Fatal(err)\n\t\t\t\t}\n\t\t\t\tif !complete {\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t\tfargs = append(fargs, args)\n\t\t\t}\n\t\t\trbuf = append(rbuf[:0], data...)\n\t\t}\n\t\t// compare final args to original\n\t\tif len(plargs) != len(fargs) {\n\t\t\tt.Fatalf(\"not equal size: %v != %v\", len(plargs), len(fargs))\n\t\t}\n\t\tfor i := 0; i < len(plargs); i++ {\n\t\t\tif len(plargs[i]) != len(fargs[i]) {\n\t\t\t\tt.Fatalf(\"not equal size for item %v: %v != %v\", i, len(plargs[i]), len(fargs[i]))\n\t\t\t}\n\t\t\tfor j := 0; j < len(plargs[i]); j++ {\n\t\t\t\tif !bytes.Equal(plargs[i][j], plargs[i][j]) {\n\t\t\t\t\tt.Fatalf(\"not equal for item %v:%v: %v != %v\", i, j, len(plargs[i][j]), len(fargs[i][j]))\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc TestAppendBulkFloat(t *testing.T) {\n\tvar b []byte\n\tb = AppendString(b, \"HELLO\")\n\tb = AppendBulkFloat(b, 9.123192839)\n\tb = AppendString(b, \"HELLO\")\n\texp := \"+HELLO\\r\\n$11\\r\\n9.123192839\\r\\n+HELLO\\r\\n\"\n\tif string(b) != exp {\n\t\tt.Fatalf(\"expected '%s', got '%s'\", exp, b)\n\t}\n}\n\nfunc TestAppendBulkInt(t *testing.T) {\n\tvar b []byte\n\tb = AppendString(b, \"HELLO\")\n\tb = AppendBulkInt(b, -9182739137)\n\tb = AppendString(b, \"HELLO\")\n\texp := \"+HELLO\\r\\n$11\\r\\n-9182739137\\r\\n+HELLO\\r\\n\"\n\tif string(b) != exp {\n\t\tt.Fatalf(\"expected '%s', got '%s'\", exp, b)\n\t}\n}\n\nfunc TestAppendBulkUint(t *testing.T) {\n\tvar b []byte\n\tb = AppendString(b, \"HELLO\")\n\tb = AppendBulkInt(b, 91827391370)\n\tb = AppendString(b, \"HELLO\")\n\texp := \"+HELLO\\r\\n$11\\r\\n91827391370\\r\\n+HELLO\\r\\n\"\n\tif string(b) != exp {\n\t\tt.Fatalf(\"expected '%s', got '%s'\", exp, b)\n\t}\n}\n\nfunc TestArrayMap(t *testing.T) {\n\tvar dst []byte\n\tdst = AppendArray(dst, 4)\n\tdst = AppendBulkString(dst, \"key1\")\n\tdst = AppendBulkString(dst, \"val1\")\n\tdst = AppendBulkString(dst, \"key2\")\n\tdst = AppendBulkString(dst, \"val2\")\n\tn, resp := ReadNextRESP(dst)\n\tif n != len(dst) {\n\t\tt.Fatalf(\"expected '%d', got '%d'\", len(dst), n)\n\t}\n\tm := resp.Map()\n\tif len(m) != 2 {\n\t\tt.Fatalf(\"expected '%d', got '%d'\", 2, len(m))\n\t}\n\tif m[\"key1\"].String() != \"val1\" {\n\t\tt.Fatalf(\"expected '%s', got '%s'\", \"val1\", m[\"key1\"].String())\n\t}\n\tif m[\"key2\"].String() != \"val2\" {\n\t\tt.Fatalf(\"expected '%s', got '%s'\", \"val2\", m[\"key2\"].String())\n\t}\n}\n"
        }
      ]
    }
  ]
}