{
  "metadata": {
    "timestamp": 1736567036783,
    "page": 619,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjYyMA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "eclipse-paho/paho.mqtt.golang",
      "stars": 2817,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.419921875,
          "content": "# Compiled Object files, Static and Dynamic libs (Shared Objects)\n*.o\n*.a\n*.so\n\n# Folders\n_obj\n_test\n\n# Architecture specific extensions/prefixes\n*.[568vq]\n[568vq].out\n\n*.cgo1.go\n*.cgo2.c\n_cgo_defun.c\n_cgo_gotypes.go\n_cgo_export.*\n\n_testmain.go\n\n*.exe\n\n*.msg\n*.lok\n\nsamples/trivial\nsamples/trivial2\nsamples/sample\nsamples/reconnect\nsamples/ssl\nsamples/custom_store\nsamples/simple\nsamples/stdinpub\nsamples/stdoutsub\nsamples/routing"
        },
        {
          "name": "CODE_OF_CONDUCT.md",
          "type": "blob",
          "size": 9.57421875,
          "content": "# Community Code of Conduct\n\n**Version 2.0  \nJanuary 1, 2023**\n\n## Our Pledge\n\nIn the interest of fostering an open and welcoming environment, we as community members, contributors, Committers[^1], and Project Leads (collectively \"Contributors\") pledge to make participation in our projects and our community a harassment-free and inclusive experience for everyone.\n\nThis Community Code of Conduct (\"Code\") outlines our behavior expectations as members of our community in all Eclipse Foundation activities, both offline and online. It is not intended to govern scenarios or behaviors outside of the scope of Eclipse Foundation activities. Nor is it intended to replace or supersede the protections offered to all our community members under the law. Please follow both the spirit and letter of this Code and encourage other Contributors to follow these principles into our work. Failure to read or acknowledge this Code does not excuse a Contributor from compliance with the Code.\n\n## Our Standards\n\nExamples of behavior that contribute to creating a positive and professional environment include:\n\n- Using welcoming and inclusive language;\n- Actively encouraging all voices;\n- Helping others bring their perspectives and listening actively. If you find yourself dominating a discussion, it is especially important to encourage other voices to join in;\n- Being respectful of differing viewpoints and experiences;\n- Gracefully accepting constructive criticism;\n- Focusing on what is best for the community;\n- Showing empathy towards other community members;\n- Being direct but professional; and\n- Leading by example by holding yourself and others accountable\n\nExamples of unacceptable behavior by Contributors include:\n\n- The use of sexualized language or imagery;\n- Unwelcome sexual attention or advances;\n- Trolling, insulting/derogatory comments, and personal or political attacks;\n- Public or private harassment, repeated harassment;\n- Publishing others' private information, such as a physical or electronic address, without explicit permission;\n- Violent threats or language directed against another person;\n- Sexist, racist, or otherwise discriminatory jokes and language;\n- Posting sexually explicit or violent material;\n- Sharing private content, such as emails sent privately or non-publicly, or unlogged forums such as IRC channel history;\n- Personal insults, especially those using racist or sexist terms;\n- Excessive or unnecessary profanity;\n- Advocating for, or encouraging, any of the above behavior; and\n- Other conduct which could reasonably be considered inappropriate in a professional setting\n\n## Our Responsibilities\n\nWith the support of the Eclipse Foundation employees, consultants, officers, and directors (collectively, the \"Staff\"), Committers, and Project Leads, the Eclipse Foundation Conduct Committee (the \"Conduct Committee\") is responsible for clarifying the standards of acceptable behavior. The Conduct Committee takes appropriate and fair corrective action in response to any instances of unacceptable behavior.\n\n## Scope\n\nThis Code applies within all Project, Working Group, and Interest Group spaces and communication channels of the Eclipse Foundation (collectively, \"Eclipse spaces\"), within any Eclipse-organized event or meeting, and in public spaces when an individual is representing an Eclipse Foundation Project, Working Group, Interest Group, or their communities. Examples of representing a Project or community include posting via an official social media account, personal accounts, or acting as an appointed representative at an online or offline event. Representation of Projects, Working Groups, and Interest Groups may be further defined and clarified by Committers, Project Leads, or the Staff.\n\n## Enforcement\n\nInstances of abusive, harassing, or otherwise unacceptable behavior may be reported by contacting the Conduct Committee via conduct@eclipse-foundation.org. All complaints will be reviewed and investigated and will result in a response that is deemed necessary and appropriate to the circumstances. Without the explicit consent of the reporter, the Conduct Committee is obligated to maintain confidentiality with regard to the reporter of an incident. The Conduct Committee is further obligated to ensure that the respondent is provided with sufficient information about the complaint to reply. If such details cannot be provided while maintaining confidentiality, the Conduct Committee will take the respondent‘s inability to provide a defense into account in its deliberations and decisions. Further details of enforcement guidelines may be posted separately.\n\nStaff, Committers and Project Leads have the right to report, remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code, or to block temporarily or permanently any Contributor for other behaviors that they deem inappropriate, threatening, offensive, or harmful. Any such actions will be reported to the Conduct Committee for transparency and record keeping.\n\nAny Staff (including officers and directors of the Eclipse Foundation), Committers, Project Leads, or Conduct Committee members who are the subject of a complaint to the Conduct Committee will be recused from the process of resolving any such complaint.\n\n## Responsibility\n\nThe responsibility for administering this Code rests with the Conduct Committee, with oversight by the Executive Director and the Board of Directors. For additional information on the Conduct Committee and its process, please write to <conduct@eclipse-foundation.org>.\n\n## Investigation of Potential Code Violations\n\nAll conflict is not bad as a healthy debate may sometimes be necessary to push us to do our best. It is, however, unacceptable to be disrespectful or offensive, or violate this Code. If you see someone engaging in objectionable behavior violating this Code, we encourage you to address the behavior directly with those involved. If for some reason, you are unable to resolve the matter or feel uncomfortable doing so, or if the behavior is threatening or harassing, please report it following the procedure laid out below.\n\nReports should be directed to <conduct@eclipse-foundation.org>. It is the Conduct Committee’s role to receive and address reported violations of this Code and to ensure a fair and speedy resolution.\n\nThe Eclipse Foundation takes all reports of potential Code violations seriously and is committed to confidentiality and a full investigation of all allegations. The identity of the reporter will be omitted from the details of the report supplied to the accused. Contributors who are being investigated for a potential Code violation will have an opportunity to be heard prior to any final determination. Those found to have violated the Code can seek reconsideration of the violation and disciplinary action decisions. Every effort will be made to have all matters disposed of within 60 days of the receipt of the complaint.\n\n## Actions\nContributors who do not follow this Code in good faith may face temporary or permanent repercussions as determined by the Conduct Committee.\n\nThis Code does not address all conduct. It works in conjunction with our [Communication Channel Guidelines](https://www.eclipse.org/org/documents/communication-channel-guidelines/), [Social Media Guidelines](https://www.eclipse.org/org/documents/social_media_guidelines.php), [Bylaws](https://www.eclipse.org/org/documents/eclipse-foundation-be-bylaws-en.pdf), and [Internal Rules](https://www.eclipse.org/org/documents/ef-be-internal-rules.pdf) which set out additional protections for, and obligations of, all contributors. The Foundation has additional policies that provide further guidance on other matters.\n\nIt’s impossible to spell out every possible scenario that might be deemed a violation of this Code. Instead, we rely on one another’s good judgment to uphold a high standard of integrity within all Eclipse Spaces. Sometimes, identifying the right thing to do isn’t an easy call. In such a scenario, raise the issue as early as possible.\n\n## No Retaliation\n\nThe Eclipse community relies upon and values the help of Contributors who identify potential problems that may need to be addressed within an Eclipse Space. Any retaliation against a Contributor who raises an issue honestly is a violation of this Code. That a Contributor has raised a concern honestly or participated in an investigation, cannot be the basis for any adverse action, including threats, harassment, or discrimination. If you work with someone who has raised a concern or provided information in an investigation, you should continue to treat the person with courtesy and respect. If you believe someone has retaliated against you, report the matter as described by this Code. Honest reporting does not mean that you have to be right when you raise a concern; you just have to believe that the information you are providing is accurate.\n\nFalse reporting, especially when intended to retaliate or exclude, is itself a violation of this Code and will not be accepted or tolerated.\n\nEveryone is encouraged to ask questions about this Code. Your feedback is welcome, and you will get a response within three business days. Write to <conduct@eclipse-foundation.org>.\n\n## Amendments\n\nThe Eclipse Foundation Board of Directors may amend this Code from time to time and may vary the procedures it sets out where appropriate in a particular case.\n\n### Attribution\n\nThis Code was inspired by the [Contributor Covenant](https://www.contributor-covenant.org/), version 1.4, available [here](https://www.contributor-covenant.org/version/1/4/code-of-conduct/).\n\n[^1]: Capitalized terms used herein without definition shall have the meanings assigned to them in the Bylaws."
        },
        {
          "name": "CONTRIBUTING.md",
          "type": "blob",
          "size": 2.15625,
          "content": "Contributing to Paho\n====================\n\nThanks for your interest in this project.\n\nProject description:\n--------------------\n\nThe Paho project has been created to provide scalable open-source implementations of open and standard messaging protocols aimed at new, existing, and emerging applications for Machine-to-Machine (M2M) and Internet of Things (IoT).\nPaho reflects the inherent physical and cost constraints of device connectivity. Its objectives include effective levels of decoupling between devices and applications, designed to keep markets open and encourage the rapid growth of scalable Web and Enterprise middleware and applications. Paho is being kicked off with MQTT publish/subscribe client implementations for use on embedded platforms, along with corresponding server support as determined by the community.\n\n- https://projects.eclipse.org/projects/technology.paho\n\nDeveloper resources:\n--------------------\n\nInformation regarding source code management, builds, coding standards, and more.\n\n- https://projects.eclipse.org/projects/technology.paho/developer\n\nContributor License Agreement:\n------------------------------\n\nBefore your contribution can be accepted by the project, you need to create and electronically sign the Eclipse Foundation Contributor License Agreement (CLA).\n\n- http://www.eclipse.org/legal/CLA.php\n\nContributing Code:\n------------------\n\nThe Go client is developed in Github, see their documentation on the process of forking and pull requests; https://help.github.com/categories/collaborating-on-projects-using-pull-requests/\n\nGit commit messages should follow the style described here;\n\nhttp://tbaggery.com/2008/04/19/a-note-about-git-commit-messages.html\n\nContact:\n--------\n\nContact the project developers via the project's \"dev\" list.\n\n- https://dev.eclipse.org/mailman/listinfo/paho-dev\n\nSearch for bugs:\n----------------\n\nThis project uses Github issues to track ongoing development and issues.\n\n- https://github.com/eclipse/paho.mqtt.golang/issues\n\nCreate a new bug:\n-----------------\n\nBe sure to search for existing bugs before you create another one. Remember that contributions are always welcome!\n\n- https://github.com/eclipse/paho.mqtt.golang/issues\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 14.5009765625,
          "content": "Eclipse Public License - v 2.0 (EPL-2.0)\n\nThis program and the accompanying materials\nare made available under the terms of the Eclipse Public License v2.0\nand Eclipse Distribution License v1.0 which accompany this distribution.\n\nThe Eclipse Public License is available at\n  https://www.eclipse.org/legal/epl-2.0/\nand the Eclipse Distribution License is available at\n  http://www.eclipse.org/org/documents/edl-v10.php.\n\nFor an explanation of what dual-licensing means to you, see:\nhttps://www.eclipse.org/legal/eplfaq.php#DUALLIC\n\n****\nThe epl-2.0 is copied below in order to pass the pkg.go.dev license check (https://pkg.go.dev/license-policy).\n****\nEclipse Public License - v 2.0\n\n    THE ACCOMPANYING PROGRAM IS PROVIDED UNDER THE TERMS OF THIS ECLIPSE\n    PUBLIC LICENSE (\"AGREEMENT\"). ANY USE, REPRODUCTION OR DISTRIBUTION\n    OF THE PROGRAM CONSTITUTES RECIPIENT'S ACCEPTANCE OF THIS AGREEMENT.\n\n1. DEFINITIONS\n\n\"Contribution\" means:\n\n  a) in the case of the initial Contributor, the initial content\n     Distributed under this Agreement, and\n\n  b) in the case of each subsequent Contributor:\n     i) changes to the Program, and\n     ii) additions to the Program;\n  where such changes and/or additions to the Program originate from\n  and are Distributed by that particular Contributor. A Contribution\n  \"originates\" from a Contributor if it was added to the Program by\n  such Contributor itself or anyone acting on such Contributor's behalf.\n  Contributions do not include changes or additions to the Program that\n  are not Modified Works.\n\n\"Contributor\" means any person or entity that Distributes the Program.\n\n\"Licensed Patents\" mean patent claims licensable by a Contributor which\nare necessarily infringed by the use or sale of its Contribution alone\nor when combined with the Program.\n\n\"Program\" means the Contributions Distributed in accordance with this\nAgreement.\n\n\"Recipient\" means anyone who receives the Program under this Agreement\nor any Secondary License (as applicable), including Contributors.\n\n\"Derivative Works\" shall mean any work, whether in Source Code or other\nform, that is based on (or derived from) the Program and for which the\neditorial revisions, annotations, elaborations, or other modifications\nrepresent, as a whole, an original work of authorship.\n\n\"Modified Works\" shall mean any work in Source Code or other form that\nresults from an addition to, deletion from, or modification of the\ncontents of the Program, including, for purposes of clarity any new file\nin Source Code form that contains any contents of the Program. Modified\nWorks shall not include works that contain only declarations,\ninterfaces, types, classes, structures, or files of the Program solely\nin each case in order to link to, bind by name, or subclass the Program\nor Modified Works thereof.\n\n\"Distribute\" means the acts of a) distributing or b) making available\nin any manner that enables the transfer of a copy.\n\n\"Source Code\" means the form of a Program preferred for making\nmodifications, including but not limited to software source code,\ndocumentation source, and configuration files.\n\n\"Secondary License\" means either the GNU General Public License,\nVersion 2.0, or any later versions of that license, including any\nexceptions or additional permissions as identified by the initial\nContributor.\n\n2. GRANT OF RIGHTS\n\n  a) Subject to the terms of this Agreement, each Contributor hereby\n  grants Recipient a non-exclusive, worldwide, royalty-free copyright\n  license to reproduce, prepare Derivative Works of, publicly display,\n  publicly perform, Distribute and sublicense the Contribution of such\n  Contributor, if any, and such Derivative Works.\n\n  b) Subject to the terms of this Agreement, each Contributor hereby\n  grants Recipient a non-exclusive, worldwide, royalty-free patent\n  license under Licensed Patents to make, use, sell, offer to sell,\n  import and otherwise transfer the Contribution of such Contributor,\n  if any, in Source Code or other form. This patent license shall\n  apply to the combination of the Contribution and the Program if, at\n  the time the Contribution is added by the Contributor, such addition\n  of the Contribution causes such combination to be covered by the\n  Licensed Patents. The patent license shall not apply to any other\n  combinations which include the Contribution. No hardware per se is\n  licensed hereunder.\n\n  c) Recipient understands that although each Contributor grants the\n  licenses to its Contributions set forth herein, no assurances are\n  provided by any Contributor that the Program does not infringe the\n  patent or other intellectual property rights of any other entity.\n  Each Contributor disclaims any liability to Recipient for claims\n  brought by any other entity based on infringement of intellectual\n  property rights or otherwise. As a condition to exercising the\n  rights and licenses granted hereunder, each Recipient hereby\n  assumes sole responsibility to secure any other intellectual\n  property rights needed, if any. For example, if a third party\n  patent license is required to allow Recipient to Distribute the\n  Program, it is Recipient's responsibility to acquire that license\n  before distributing the Program.\n\n  d) Each Contributor represents that to its knowledge it has\n  sufficient copyright rights in its Contribution, if any, to grant\n  the copyright license set forth in this Agreement.\n\n  e) Notwithstanding the terms of any Secondary License, no\n  Contributor makes additional grants to any Recipient (other than\n  those set forth in this Agreement) as a result of such Recipient's\n  receipt of the Program under the terms of a Secondary License\n  (if permitted under the terms of Section 3).\n\n3. REQUIREMENTS\n\n3.1 If a Contributor Distributes the Program in any form, then:\n\n  a) the Program must also be made available as Source Code, in\n  accordance with section 3.2, and the Contributor must accompany\n  the Program with a statement that the Source Code for the Program\n  is available under this Agreement, and informs Recipients how to\n  obtain it in a reasonable manner on or through a medium customarily\n  used for software exchange; and\n\n  b) the Contributor may Distribute the Program under a license\n  different than this Agreement, provided that such license:\n     i) effectively disclaims on behalf of all other Contributors all\n     warranties and conditions, express and implied, including\n     warranties or conditions of title and non-infringement, and\n     implied warranties or conditions of merchantability and fitness\n     for a particular purpose;\n\n     ii) effectively excludes on behalf of all other Contributors all\n     liability for damages, including direct, indirect, special,\n     incidental and consequential damages, such as lost profits;\n\n     iii) does not attempt to limit or alter the recipients' rights\n     in the Source Code under section 3.2; and\n\n     iv) requires any subsequent distribution of the Program by any\n     party to be under a license that satisfies the requirements\n     of this section 3.\n\n3.2 When the Program is Distributed as Source Code:\n\n  a) it must be made available under this Agreement, or if the\n  Program (i) is combined with other material in a separate file or\n  files made available under a Secondary License, and (ii) the initial\n  Contributor attached to the Source Code the notice described in\n  Exhibit A of this Agreement, then the Program may be made available\n  under the terms of such Secondary Licenses, and\n\n  b) a copy of this Agreement must be included with each copy of\n  the Program.\n\n3.3 Contributors may not remove or alter any copyright, patent,\ntrademark, attribution notices, disclaimers of warranty, or limitations\nof liability (\"notices\") contained within the Program from any copy of\nthe Program which they Distribute, provided that Contributors may add\ntheir own appropriate notices.\n\n4. COMMERCIAL DISTRIBUTION\n\nCommercial distributors of software may accept certain responsibilities\nwith respect to end users, business partners and the like. While this\nlicense is intended to facilitate the commercial use of the Program,\nthe Contributor who includes the Program in a commercial product\noffering should do so in a manner which does not create potential\nliability for other Contributors. Therefore, if a Contributor includes\nthe Program in a commercial product offering, such Contributor\n(\"Commercial Contributor\") hereby agrees to defend and indemnify every\nother Contributor (\"Indemnified Contributor\") against any losses,\ndamages and costs (collectively \"Losses\") arising from claims, lawsuits\nand other legal actions brought by a third party against the Indemnified\nContributor to the extent caused by the acts or omissions of such\nCommercial Contributor in connection with its distribution of the Program\nin a commercial product offering. The obligations in this section do not\napply to any claims or Losses relating to any actual or alleged\nintellectual property infringement. In order to qualify, an Indemnified\nContributor must: a) promptly notify the Commercial Contributor in\nwriting of such claim, and b) allow the Commercial Contributor to control,\nand cooperate with the Commercial Contributor in, the defense and any\nrelated settlement negotiations. The Indemnified Contributor may\nparticipate in any such claim at its own expense.\n\nFor example, a Contributor might include the Program in a commercial\nproduct offering, Product X. That Contributor is then a Commercial\nContributor. If that Commercial Contributor then makes performance\nclaims, or offers warranties related to Product X, those performance\nclaims and warranties are such Commercial Contributor's responsibility\nalone. Under this section, the Commercial Contributor would have to\ndefend claims against the other Contributors related to those performance\nclaims and warranties, and if a court requires any other Contributor to\npay any damages as a result, the Commercial Contributor must pay\nthose damages.\n\n5. NO WARRANTY\n\nEXCEPT AS EXPRESSLY SET FORTH IN THIS AGREEMENT, AND TO THE EXTENT\nPERMITTED BY APPLICABLE LAW, THE PROGRAM IS PROVIDED ON AN \"AS IS\"\nBASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, EITHER EXPRESS OR\nIMPLIED INCLUDING, WITHOUT LIMITATION, ANY WARRANTIES OR CONDITIONS OF\nTITLE, NON-INFRINGEMENT, MERCHANTABILITY OR FITNESS FOR A PARTICULAR\nPURPOSE. Each Recipient is solely responsible for determining the\nappropriateness of using and distributing the Program and assumes all\nrisks associated with its exercise of rights under this Agreement,\nincluding but not limited to the risks and costs of program errors,\ncompliance with applicable laws, damage to or loss of data, programs\nor equipment, and unavailability or interruption of operations.\n\n6. DISCLAIMER OF LIABILITY\n\nEXCEPT AS EXPRESSLY SET FORTH IN THIS AGREEMENT, AND TO THE EXTENT\nPERMITTED BY APPLICABLE LAW, NEITHER RECIPIENT NOR ANY CONTRIBUTORS\nSHALL HAVE ANY LIABILITY FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\nEXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING WITHOUT LIMITATION LOST\nPROFITS), HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\nCONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\nARISING IN ANY WAY OUT OF THE USE OR DISTRIBUTION OF THE PROGRAM OR THE\nEXERCISE OF ANY RIGHTS GRANTED HEREUNDER, EVEN IF ADVISED OF THE\nPOSSIBILITY OF SUCH DAMAGES.\n\n7. GENERAL\n\nIf any provision of this Agreement is invalid or unenforceable under\napplicable law, it shall not affect the validity or enforceability of\nthe remainder of the terms of this Agreement, and without further\naction by the parties hereto, such provision shall be reformed to the\nminimum extent necessary to make such provision valid and enforceable.\n\nIf Recipient institutes patent litigation against any entity\n(including a cross-claim or counterclaim in a lawsuit) alleging that the\nProgram itself (excluding combinations of the Program with other software\nor hardware) infringes such Recipient's patent(s), then such Recipient's\nrights granted under Section 2(b) shall terminate as of the date such\nlitigation is filed.\n\nAll Recipient's rights under this Agreement shall terminate if it\nfails to comply with any of the material terms or conditions of this\nAgreement and does not cure such failure in a reasonable period of\ntime after becoming aware of such noncompliance. If all Recipient's\nrights under this Agreement terminate, Recipient agrees to cease use\nand distribution of the Program as soon as reasonably practicable.\nHowever, Recipient's obligations under this Agreement and any licenses\ngranted by Recipient relating to the Program shall continue and survive.\n\nEveryone is permitted to copy and distribute copies of this Agreement,\nbut in order to avoid inconsistency the Agreement is copyrighted and\nmay only be modified in the following manner. The Agreement Steward\nreserves the right to publish new versions (including revisions) of\nthis Agreement from time to time. No one other than the Agreement\nSteward has the right to modify this Agreement. The Eclipse Foundation\nis the initial Agreement Steward. The Eclipse Foundation may assign the\nresponsibility to serve as the Agreement Steward to a suitable separate\nentity. Each new version of the Agreement will be given a distinguishing\nversion number. The Program (including Contributions) may always be\nDistributed subject to the version of the Agreement under which it was\nreceived. In addition, after a new version of the Agreement is published,\nContributor may elect to Distribute the Program (including its\nContributions) under the new version.\n\nExcept as expressly stated in Sections 2(a) and 2(b) above, Recipient\nreceives no rights or licenses to the intellectual property of any\nContributor under this Agreement, whether expressly, by implication,\nestoppel or otherwise. All rights in the Program not expressly granted\nunder this Agreement are reserved. Nothing in this Agreement is intended\nto be enforceable by any entity that is not a Contributor or Recipient.\nNo third-party beneficiary rights are created under this Agreement.\n\nExhibit A - Form of Secondary Licenses Notice\n\n\"This Source Code may also be made available under the following\nSecondary Licenses when the conditions for such availability set forth\nin the Eclipse Public License, v. 2.0 are satisfied: {name license(s),\nversion(s), and exceptions or additional permissions here}.\"\n\n  Simply including a copy of this Agreement, including this Exhibit A\n  is not sufficient to license the Source Code under Secondary Licenses.\n\n  If it is not possible or desirable to put the notice in a particular\n  file, then You may include the notice in a location (such as a LICENSE\n  file in a relevant directory) where a recipient would be likely to\n  look for such a notice.\n\n  You may add additional accurate notices of copyright ownership.\n"
        },
        {
          "name": "NOTICE.md",
          "type": "blob",
          "size": 2.43359375,
          "content": "# Notices for paho.mqtt.golang\n\nThis content is produced and maintained by the Eclipse Paho project.\n\n * Project home: https://www.eclipse.org/paho/\n\nNote that a [separate mqtt v5 client](https://github.com/eclipse/paho.golang) also exists (this is a full rewrite\nand deliberately incompatible with this library).\n\n## Trademarks\n\nEclipse Mosquitto trademarks of the Eclipse Foundation. Eclipse, and the\nEclipse Logo are registered trademarks of the Eclipse Foundation.\n\nPaho is a trademark of the Eclipse Foundation. Eclipse, and the Eclipse Logo are\nregistered trademarks of the Eclipse Foundation.\n\n## Copyright\n\nAll content is the property of the respective authors or their employers.\nFor more information regarding authorship of content, please consult the\nlisted source code repository logs.\n\n## Declared Project Licenses\n\nThis program and the accompanying materials are made available under the terms of the \nEclipse Public License v2.0 and Eclipse Distribution License v1.0 which accompany this\ndistribution.\n\nThe Eclipse Public License is available at\nhttps://www.eclipse.org/legal/epl-2.0/\nand the Eclipse Distribution License is available at\nhttp://www.eclipse.org/org/documents/edl-v10.php.\n\nFor an explanation of what dual-licensing means to you, see:\nhttps://www.eclipse.org/legal/eplfaq.php#DUALLIC\n\nSPDX-License-Identifier: EPL-2.0 or BSD-3-Clause\n\n## Source Code\n\nThe project maintains the following source code repositories:\n\n * https://github.com/eclipse/paho.mqtt.golang\n\n## Third-party Content\n\nThis project makes use of the follow third party projects.\n\nGo Programming Language and Standard Library\n\n* License: BSD-style license (https://golang.org/LICENSE)\n* Project: https://golang.org/\n\nGo Networking\n\n* License: BSD 3-Clause style license and patent grant.\n* Project: https://cs.opensource.google/go/x/net\n\nGo Sync\n\n* License: BSD 3-Clause style license and patent grant.\n* Project: https://cs.opensource.google/go/x/sync/\n\nGorilla Websockets v1.4.2\n\n* License: BSD 2-Clause \"Simplified\" License\n* Project: https://github.com/gorilla/websocket\n\n## Cryptography\n\nContent may contain encryption software. The country in which you are currently\nmay have restrictions on the import, possession, and use, and/or re-export to\nanother country, of encryption software. BEFORE using any encryption software,\nplease check the country's laws, regulations and policies concerning the import,\npossession, or use, and re-export of encryption software, to see if this is\npermitted."
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 10.05859375,
          "content": "\n[![PkgGoDev](https://pkg.go.dev/badge/github.com/eclipse/paho.mqtt.golang)](https://pkg.go.dev/github.com/eclipse/paho.mqtt.golang)\n[![Go Report Card](https://goreportcard.com/badge/github.com/eclipse/paho.mqtt.golang)](https://goreportcard.com/report/github.com/eclipse/paho.mqtt.golang)\n\nEclipse Paho MQTT Go client\n===========================\n\n\nThis repository contains the source code for the [Eclipse Paho](https://eclipse.org/paho) MQTT 3.1/3.11 Go client library. \n\nThis code builds a library which enable applications to connect to an [MQTT](https://mqtt.org) broker to publish \nmessages, and to subscribe to topics and receive published messages.\n\nThis library supports a fully asynchronous mode of operation.\n\nA client supporting MQTT V5 is [also available](https://github.com/eclipse/paho.golang).\n\nInstallation and Build\n----------------------\n\nThe process depends upon whether you are using [modules](https://golang.org/ref/mod) (recommended) or `GOPATH`. \n\n#### Modules\n\nIf you are using [modules](https://blog.golang.org/using-go-modules) then `import \"github.com/eclipse/paho.mqtt.golang\"` \nand start using it. The necessary packages will be download automatically when you run `go build`. \n\nNote that the latest release will be downloaded and changes may have been made since the release. If you have \nencountered an issue, or wish to try the latest code for another reason, then run \n`go get github.com/eclipse/paho.mqtt.golang@master` to get the latest commit.\n\n#### GOPATH\n\nInstallation is as easy as:\n\n```\ngo get github.com/eclipse/paho.mqtt.golang\n```\n\nThe client depends on Google's [proxy](https://godoc.org/golang.org/x/net/proxy) package and the \n[websockets](https://godoc.org/github.com/gorilla/websocket) package, also easily installed with the commands:\n\n```\ngo get github.com/gorilla/websocket\ngo get golang.org/x/net/proxy\n```\n\n\nUsage and API\n-------------\n\nDetailed API documentation is available by using to godoc tool, or can be browsed online\nusing the [pkg.go.dev](https://pkg.go.dev/github.com/eclipse/paho.mqtt.golang) service.\n\nSamples are available in the `cmd` directory for reference.\n\nNote:\n\nThe library also supports using MQTT over websockets by using the `ws://` (unsecure) or `wss://` (secure) prefix in the\nURI. If the client is running behind a corporate http/https proxy then the following environment variables `HTTP_PROXY`,\n`HTTPS_PROXY` and `NO_PROXY` are taken into account when establishing the connection.\n\nTroubleshooting\n---------------\n\nIf you are new to MQTT and your application is not working as expected reviewing the\n[MQTT specification](https://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html), which this library implements,\nis a good first step. [MQTT.org](https://mqtt.org) has some [good resources](https://mqtt.org/getting-started/) that answer many \ncommon questions.\n\n### Error Handling\n\nThe asynchronous nature of this library makes it easy to forget to check for errors. Consider using a go routine to \nlog these: \n\n```go\nt := client.Publish(\"topic\", qos, retained, msg)\ngo func() {\n    _ = t.Wait() // Can also use '<-t.Done()' in releases > 1.2.0\n    if t.Error() != nil {\n        log.Error(t.Error()) // Use your preferred logging technique (or just fmt.Printf)\n    }\n}()\n```\n\n### Logging\n\nIf you are encountering issues then enabling logging, both within this library and on your broker, is a good way to\nbegin troubleshooting. This library can produce various levels of log by assigning the logging endpoints, ERROR, \nCRITICAL, WARN and DEBUG. For example:\n\n```go\nfunc main() {\n\tmqtt.ERROR = log.New(os.Stdout, \"[ERROR] \", 0)\n\tmqtt.CRITICAL = log.New(os.Stdout, \"[CRIT] \", 0)\n\tmqtt.WARN = log.New(os.Stdout, \"[WARN]  \", 0)\n\tmqtt.DEBUG = log.New(os.Stdout, \"[DEBUG] \", 0)\n\n\t// Connect, Subscribe, Publish etc..\n}\n```\n\n### Common Problems\n\n* Seemingly random disconnections may be caused by another client connecting to the broker with the same client \nidentifier; this is as per the [spec](https://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc384800405).\n* Unless ordered delivery of messages is essential (and you have configured your broker to support this e.g. \n  `max_inflight_messages=1` in mosquitto) then set `ClientOptions.SetOrderMatters(false)`. Doing so will avoid the \n  below issue (deadlocks due to blocking message handlers).\n* A `MessageHandler` (called when a new message is received) must not block (unless \n  `ClientOptions.SetOrderMatters(false)` set). If you wish to perform a long-running task, or publish a message, then \n  please use a go routine (blocking in the handler is a common cause of unexpected `pingresp \nnot received, disconnecting` errors). \n* When QOS1+ subscriptions have been created previously and you connect with `CleanSession` set to false it is possible \nthat the broker will deliver retained messages before `Subscribe` can be called. To process these messages either \nconfigure a handler with `AddRoute` or set a `DefaultPublishHandler`. If there is no handler (or `DefaultPublishHandler`) \nthen inbound messages will not be acknowledged. Adding a handler (even if it's  `opts.SetDefaultPublishHandler(func(mqtt.Client, mqtt.Message) {})`) \nis highly recommended to avoid inadvertently hitting inflight message limits.\n* Loss of network connectivity may not be detected immediately. If this is an issue then consider setting \n`ClientOptions.KeepAlive` (sends regular messages to check the link is active).\n* Reusing a `Client` is not completely safe. After calling `Disconnect` please create a new Client (`NewClient()`) rather \nthan attempting to reuse the existing one (note that features such as `SetAutoReconnect` mean this is rarely necessary).\n* Brokers offer many configuration options; some settings may lead to unexpected results.\n* Publish tokens will complete if the connection is lost and re-established using the default\noptions.SetAutoReconnect(true) functionality (token.Error() will return nil). Attempts will be made to re-deliver the\nmessage but there is currently no easy way know when such messages are delivered.\n\nIf using Mosquitto then there are a range of fairly common issues:\n* `listener` - By default [Mosquitto v2+](https://mosquitto.org/documentation/migrating-to-2-0/) listens on loopback \ninterfaces only (meaning it will only accept connections made from the computer its running on).\n* `max_inflight_messages` - Unless this is set to 1 mosquitto does not guarantee ordered delivery of messages. \n* `max_queued_messages` / `max_queued_bytes` - These impose limits on the number/size of queued messages. The defaults\nmay lead to messages being silently dropped.\n* `persistence` - Defaults to false (messages will not survive a broker restart)\n* `max_keepalive` - defaults to 65535 and, from version 2.0.12, `SetKeepAlive(0)` will result in a rejected connection \nby default.\n\nReporting bugs\n--------------\n\nPlease report bugs by raising issues for this project in github https://github.com/eclipse/paho.mqtt.golang/issues\n\nA limited number of contributors monitor the issues section so if you have a general question please see the \nresources in the [more information](#more-information) section for help.\n\nWe welcome bug reports, but it is important they are actionable. A significant percentage of issues reported are not \nresolved due to a lack of information. If we cannot replicate the problem then it is unlikely we will be able to fix it. \nThe information required will vary from issue to issue but almost all bug reports would be expected to include: \n\n* Which version of the package you are using (tag or commit - this should be in your `go.mod` file)\n* A full, clear, description of the problem (detail what you are expecting vs what actually happens).\n* Configuration information (code showing how you connect, please include all references to `ClientOption`)\n* Broker details (name and version).\n\nIf at all possible please also include:\n* Details of your attempts to resolve the issue (what have you tried, what worked, what did not).\n* A [Minimal, Reproducible Example](https://stackoverflow.com/help/minimal-reproducible-example). Providing an example\nis the best way to demonstrate the issue you are facing; it is important this includes all relevant information\n(including broker configuration). Docker (see `cmd/docker`) makes it relatively simple to provide a working end-to-end\nexample.\n* Broker logs covering the period the issue occurred.\n* [Application Logs](#logging) covering the period the issue occurred. Unless you have isolated the root cause of the \nissue please include a link to a full log (including data from well before the problem arose).\n\nIt is important to remember that this library does not stand alone; it communicates with a broker and any issues you are \nseeing may be due to:\n\n* Bugs in your code.\n* Bugs in this library.\n* The broker configuration.\n* Bugs in the broker.\n* Issues with whatever you are communicating with.\n\nWhen submitting an issue, please ensure that you provide sufficient details to enable us to eliminate causes outside of\nthis library.\n\nContributing\n------------\n\nWe welcome pull requests but before your contribution can be accepted by the project, you need to create and \nelectronically sign the Eclipse Contributor Agreement (ECA) and sign off on the Eclipse Foundation Certificate of Origin.\n\nMore information is available in the \n[Eclipse Development Resources](http://wiki.eclipse.org/Development_Resources/Contributing_via_Git); please take special \nnote of the requirement that the commit record contain a \"Signed-off-by\" entry.\n\nMore information\n----------------\n\n[Stack Overflow](https://stackoverflow.com/questions/tagged/mqtt+go) has a range questions/answers covering a range of \ncommon issues (both relating to use of this library and MQTT in general). This is the best place to ask general questions \n(including those relating to the use of this library).\n\nDiscussion of the Paho clients takes place on the [Eclipse paho-dev mailing list](https://dev.eclipse.org/mailman/listinfo/paho-dev).\n\nGeneral questions about the MQTT protocol are discussed in the [MQTT Google Group](https://groups.google.com/forum/?hl=en-US&fromgroups#!forum/mqtt).\n\nThere is much more information available via the [MQTT community site](http://mqtt.org).\n"
        },
        {
          "name": "SECURITY.md",
          "type": "blob",
          "size": 0.341796875,
          "content": "# Security Policy\n\nThis project implements the Eclipse Foundation Security Policy\n\n* https://www.eclipse.org/security\n\n## Supported Versions\n\nOnly the most recent release of the client will be supported with security updates.\n\n## Reporting a Vulnerability\n\nPlease report vulnerabilities to the Eclipse Foundation Security Team at security@eclipse.org"
        },
        {
          "name": "backoff.go",
          "type": "blob",
          "size": 3.162109375,
          "content": "/*\n * Copyright (c) 2021 IBM Corp and others.\n *\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v2.0\n * and Eclipse Distribution License v1.0 which accompany this distribution.\n *\n * The Eclipse Public License is available at\n *    https://www.eclipse.org/legal/epl-2.0/\n * and the Eclipse Distribution License is available at\n *   http://www.eclipse.org/org/documents/edl-v10.php.\n *\n * Contributors:\n *    Matt Brittan\n *    Daichi Tomaru\n */\n\npackage mqtt\n\nimport (\n\t\"sync\"\n\t\"time\"\n)\n\n// Controller for sleep with backoff when the client attempts reconnection\n// It has statuses for each situations cause reconnection.\ntype backoffController struct {\n\tsync.RWMutex\n\tstatusMap map[string]*backoffStatus\n}\n\ntype backoffStatus struct {\n\tlastSleepPeriod time.Duration\n\tlastErrorTime   time.Time\n}\n\nfunc newBackoffController() *backoffController {\n\treturn &backoffController{\n\t\tstatusMap: map[string]*backoffStatus{},\n\t}\n}\n\n// Calculate next sleep period from the specified parameters.\n// Returned values are next sleep period and whether the error situation is continual.\n// If connection errors continuouslly occurs, its sleep period is exponentially increased.\n// Also if there is a lot of time between last and this error, sleep period is initialized.\nfunc (b *backoffController) getBackoffSleepTime(\n\tsituation string, initSleepPeriod time.Duration, maxSleepPeriod time.Duration, processTime time.Duration, skipFirst bool,\n) (time.Duration, bool) {\n\t// Decide first sleep time if the situation is not continual. \n\tvar firstProcess = func(status *backoffStatus, init time.Duration, skip bool) (time.Duration, bool) {\n\t\tif skip {\n\t\t\tstatus.lastSleepPeriod = 0\n\t\t\treturn 0, false\n\t\t}\n\t\tstatus.lastSleepPeriod = init\n\t\treturn init, false\n\t}\n\n\t// Prioritize maxSleep.\n\tif initSleepPeriod > maxSleepPeriod {\n\t\tinitSleepPeriod = maxSleepPeriod\n\t}\n\tb.Lock()\n\tdefer b.Unlock()\n\n\tstatus, exist := b.statusMap[situation]\n\tif !exist {\n\t\tb.statusMap[situation] = &backoffStatus{initSleepPeriod, time.Now()}\n\t\treturn firstProcess(b.statusMap[situation], initSleepPeriod, skipFirst)\n\t}\n\n\toldTime := status.lastErrorTime\n\tstatus.lastErrorTime = time.Now()\n\n\t// When there is a lot of time between last and this error, sleep period is initialized.\n\tif status.lastErrorTime.Sub(oldTime) > (processTime * 2 + status.lastSleepPeriod) {\n\t\treturn firstProcess(status, initSleepPeriod, skipFirst)\n\t}\n\n\tif status.lastSleepPeriod == 0 {\n\t\tstatus.lastSleepPeriod = initSleepPeriod\n\t\treturn initSleepPeriod, true\n\t}\n\n\tif nextSleepPeriod := status.lastSleepPeriod * 2; nextSleepPeriod <= maxSleepPeriod {\n\t\tstatus.lastSleepPeriod = nextSleepPeriod\n\t} else {\n\t\tstatus.lastSleepPeriod = maxSleepPeriod\n\t}\n\n\treturn status.lastSleepPeriod, true\n}\n\n// Execute sleep the time returned from getBackoffSleepTime.\nfunc (b *backoffController) sleepWithBackoff(\n\tsituation string, initSleepPeriod time.Duration, maxSleepPeriod time.Duration, processTime time.Duration, skipFirst bool,\n) (time.Duration, bool) {\n\tsleep, isFirst := b.getBackoffSleepTime(situation, initSleepPeriod, maxSleepPeriod, processTime, skipFirst)\n\tif sleep != 0 {\n\t\ttime.Sleep(sleep)\n\t}\n\treturn sleep, isFirst\n}\n"
        },
        {
          "name": "backoff_test.go",
          "type": "blob",
          "size": 3.3681640625,
          "content": "/*\n * Copyright (c) 2021 IBM Corp and others.\n *\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v2.0\n * and Eclipse Distribution License v1.0 which accompany this distribution.\n *\n * The Eclipse Public License is available at\n *    https://www.eclipse.org/legal/epl-2.0/\n * and the Eclipse Distribution License is available at\n *   http://www.eclipse.org/org/documents/edl-v10.php.\n *\n * Contributors:\n *    Matt Brittan\n *    Daichi Tomaru\n */\n\npackage mqtt\n\nimport (\n\t\"testing\"\n\t\"time\"\n)\n\nfunc TestGetBackoffSleepTime(t *testing.T) {\n\t// Test for adding new situation\n\tcontroller := newBackoffController()\n\tif s, c := controller.getBackoffSleepTime(\"not-exist\", 1 * time.Second, 5 * time.Second, 1 * time.Second, false); !((s == 1 * time.Second) && !c) {\n\t\tt.Errorf(\"When new situation is added, period should be initSleepPeriod and naturally it shouldn't be continual error. s:%d c%t\", s, c)\n\t}\n\n\t// Test for the continual error in the same situation and suppression of sleep period by maxSleepPeriod\n\tcontroller.getBackoffSleepTime(\"multi\", 10 * time.Second, 30 * time.Second, 1 * time.Second, false)\n\tif s, c := controller.getBackoffSleepTime(\"multi\", 10 * time.Second, 30 * time.Second, 1 * time.Second, false); !((s == 20 * time.Second) && c) {\n\t\tt.Errorf(\"When same situation is called again, period should be increased and it should be regarded as a continual error. s:%d c%t\", s, c)\n\t}\n\tif s, c := controller.getBackoffSleepTime(\"multi\", 10 * time.Second, 30 * time.Second, 1 * time.Second, false); !((s == 30 * time.Second) && c) {\n\t\tt.Errorf(\"A same situation is called three times. 10 * 2 * 2 = 40 but maxSleepPeriod is 30. So the next period should be 30. s:%d c%t\", s, c)\n\t}\n\n\t// Test for initialization by elapsed time.\n\tcontroller.getBackoffSleepTime(\"elapsed\", 1 * time.Second, 128 * time.Second, 1 * time.Second, false)\n\tcontroller.getBackoffSleepTime(\"elapsed\", 1 * time.Second, 128 * time.Second, 1 * time.Second, false)\n\ttime.Sleep((1 * 2 + 1 * 2 + 1) * time.Second)\n\tif s, c := controller.getBackoffSleepTime(\"elapsed\", 1 * time.Second, 128 * time.Second, 1 * time.Second, false); !((s == 1 * time.Second) && !c) {\n\t\tt.Errorf(\"Initialization should be triggered by elapsed time. s:%d c%t\", s, c)\n\t}\n\n\t// Test when initial and max period is same.\n\tcontroller.getBackoffSleepTime(\"same\", 2 * time.Second, 2 * time.Second, 1 * time.Second, false)\n\tif s, c := controller.getBackoffSleepTime(\"same\", 2 * time.Second, 2 * time.Second, 1 * time.Second, false); !((s == 2 * time.Second) && c) {\n\t\tt.Errorf(\"Sleep time should be always 2. s:%d c%t\", s, c)\n\t}\n\n\t// Test when initial period > max period.\n\tcontroller.getBackoffSleepTime(\"bigger\", 5 * time.Second, 2 * time.Second, 1 * time.Second, false)\n\tif s, c := controller.getBackoffSleepTime(\"bigger\", 5 * time.Second, 2 * time.Second, 1 * time.Second, false); !((s == 2 * time.Second) && c) {\n\t\tt.Errorf(\"Sleep time should be 2. s:%d c%t\", s, c)\n\t}\n\n\t// Test when first sleep is skipped.\n\tif s, c := controller.getBackoffSleepTime(\"skip\", 3 * time.Second, 12 * time.Second, 1 * time.Second, true); !((s == 0) && !c) {\n\t\tt.Errorf(\"Sleep time should be 0 because of skip. s:%d c%t\", s, c)\n\t}\n\tif s, c := controller.getBackoffSleepTime(\"skip\", 3 * time.Second, 12 * time.Second, 1 * time.Second, true); !((s == 3 * time.Second) && c) {\n\t\tt.Errorf(\"Sleep time should be 3. s:%d c%t\", s, c)\n\t}\n}\n"
        },
        {
          "name": "client.go",
          "type": "blob",
          "size": 46.8125,
          "content": "/*\n * Copyright (c) 2021 IBM Corp and others.\n *\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v2.0\n * and Eclipse Distribution License v1.0 which accompany this distribution.\n *\n * The Eclipse Public License is available at\n *    https://www.eclipse.org/legal/epl-2.0/\n * and the Eclipse Distribution License is available at\n *   http://www.eclipse.org/org/documents/edl-v10.php.\n *\n * Contributors:\n *    Seth Hoenig\n *    Allan Stockdill-Mander\n *    Mike Robertson\n *    Matt Brittan\n */\n\n// Portions copyright © 2018 TIBCO Software Inc.\n\n// Package mqtt provides an MQTT v3.1.1 client library.\npackage mqtt\n\nimport (\n\t\"bytes\"\n\t\"context\"\n\t\"errors\"\n\t\"fmt\"\n\t\"net\"\n\t\"strings\"\n\t\"sync\"\n\t\"sync/atomic\"\n\t\"time\"\n\n\t\"golang.org/x/sync/semaphore\"\n\n\t\"github.com/eclipse/paho.mqtt.golang/packets\"\n)\n\n// Client is the interface definition for a Client as used by this\n// library, the interface is primarily to allow mocking tests.\n//\n// It is an MQTT v3.1.1 client for communicating\n// with an MQTT server using non-blocking methods that allow work\n// to be done in the background.\n// An application may connect to an MQTT server using:\n//\n//\t\tA plain TCP socket (e.g. mqtt://test.mosquitto.org:1833)\n//\t\tA secure SSL/TLS socket (e.g. tls://test.mosquitto.org:8883)\n//\t\tA websocket (e.g ws://test.mosquitto.org:8080 or wss://test.mosquitto.org:8081)\n//\t Something else (using `options.CustomOpenConnectionFn`)\n//\n// To enable ensured message delivery at Quality of Service (QoS) levels\n// described in the MQTT spec, a message persistence mechanism must be\n// used. This is done by providing a type which implements the Store\n// interface. For convenience, FileStore and MemoryStore are provided\n// implementations that should be sufficient for most use cases. More\n// information can be found in their respective documentation.\n// Numerous connection options may be specified by configuring a\n// and then supplying a ClientOptions type.\n// Implementations of Client must be safe for concurrent use by multiple\n// goroutines\ntype Client interface {\n\t// IsConnected returns a bool signifying whether\n\t// the client is connected or not.\n\tIsConnected() bool\n\t// IsConnectionOpen return a bool signifying whether the client has an active\n\t// connection to mqtt broker, i.e not in disconnected or reconnect mode\n\tIsConnectionOpen() bool\n\t// Connect will create a connection to the message broker, by default\n\t// it will attempt to connect at v3.1.1 and auto retry at v3.1 if that\n\t// fails\n\tConnect() Token\n\t// Disconnect will end the connection with the server, but not before waiting\n\t// the specified number of milliseconds to wait for existing work to be\n\t// completed.\n\tDisconnect(quiesce uint)\n\t// Publish will publish a message with the specified QoS and content\n\t// to the specified topic.\n\t// Returns a token to track delivery of the message to the broker\n\tPublish(topic string, qos byte, retained bool, payload interface{}) Token\n\t// Subscribe starts a new subscription. Provide a MessageHandler to be executed when\n\t// a message is published on the topic provided, or nil for the default handler.\n\t//\n\t// If options.OrderMatters is true (the default) then callback must not block or\n\t// call functions within this package that may block (e.g. Publish) other than in\n\t// a new go routine.\n\t// callback must be safe for concurrent use by multiple goroutines.\n\tSubscribe(topic string, qos byte, callback MessageHandler) Token\n\t// SubscribeMultiple starts a new subscription for multiple topics. Provide a MessageHandler to\n\t// be executed when a message is published on one of the topics provided, or nil for the\n\t// default handler.\n\t//\n\t// If options.OrderMatters is true (the default) then callback must not block or\n\t// call functions within this package that may block (e.g. Publish) other than in\n\t// a new go routine.\n\t// callback must be safe for concurrent use by multiple goroutines.\n\tSubscribeMultiple(filters map[string]byte, callback MessageHandler) Token\n\t// Unsubscribe will end the subscription from each of the topics provided.\n\t// Messages published to those topics from other clients will no longer be\n\t// received.\n\tUnsubscribe(topics ...string) Token\n\t// AddRoute allows you to add a handler for messages on a specific topic\n\t// without making a subscription. For example having a different handler\n\t// for parts of a wildcard subscription or for receiving retained messages\n\t// upon connection (before Sub scribe can be processed).\n\t//\n\t// If options.OrderMatters is true (the default) then callback must not block or\n\t// call functions within this package that may block (e.g. Publish) other than in\n\t// a new go routine.\n\t// callback must be safe for concurrent use by multiple goroutines.\n\tAddRoute(topic string, callback MessageHandler)\n\t// OptionsReader returns a ClientOptionsReader which is a copy of the clientoptions\n\t// in use by the client.\n\tOptionsReader() ClientOptionsReader\n}\n\n// client implements the Client interface\n// clients are safe for concurrent use by multiple\n// goroutines\ntype client struct {\n\tlastSent        atomic.Value // time.Time - the last time a packet was successfully sent to network\n\tlastReceived    atomic.Value // time.Time - the last time a packet was successfully received from network\n\tpingOutstanding int32        // set to 1 if a ping has been sent but response not ret received\n\n\tstatus connectionStatus // see constants in status.go for values\n\n\tmessageIds // effectively a map from message id to token completor\n\n\tobound    chan *PacketAndToken // outgoing publish packet\n\toboundP   chan *PacketAndToken // outgoing 'priority' packet (anything other than publish)\n\tmsgRouter *router              // routes topics to handlers\n\tpersist   Store\n\toptions   ClientOptions\n\toptionsMu sync.Mutex // Protects the options in a few limited cases where needed for testing\n\n\tconn   net.Conn   // the network connection, must only be set with connMu locked (only used when starting/stopping workers)\n\tconnMu sync.Mutex // mutex for the connection (again only used in two functions)\n\n\tstop         chan struct{}  // Closed to request that workers stop\n\tworkers      sync.WaitGroup // used to wait for workers to complete (ping, keepalive, errwatch, resume)\n\tcommsStopped chan struct{}  // closed when the comms routines have stopped (kept running until after workers have closed to avoid deadlocks)\n\n\tbackoff *backoffController\n}\n\n// NewClient will create an MQTT v3.1.1 client with all of the options specified\n// in the provided ClientOptions. The client must have the Connect method called\n// on it before it may be used. This is to make sure resources (such as a net\n// connection) are created before the application is actually ready.\nfunc NewClient(o *ClientOptions) Client {\n\tc := &client{}\n\tc.options = *o\n\n\tif c.options.Store == nil {\n\t\tc.options.Store = NewMemoryStore()\n\t}\n\tswitch c.options.ProtocolVersion {\n\tcase 3, 4:\n\t\tc.options.protocolVersionExplicit = true\n\tcase 0x83, 0x84:\n\t\tc.options.protocolVersionExplicit = true\n\tdefault:\n\t\tc.options.ProtocolVersion = 4\n\t\tc.options.protocolVersionExplicit = false\n\t}\n\tc.persist = c.options.Store\n\tc.messageIds = messageIds{index: make(map[uint16]tokenCompletor)}\n\tc.msgRouter = newRouter()\n\tc.msgRouter.setDefaultHandler(c.options.DefaultPublishHandler)\n\tc.obound = make(chan *PacketAndToken)\n\tc.oboundP = make(chan *PacketAndToken)\n\tc.backoff = newBackoffController()\n\treturn c\n}\n\n// AddRoute allows you to add a handler for messages on a specific topic\n// without making a subscription. For example having a different handler\n// for parts of a wildcard subscription\n//\n// If options.OrderMatters is true (the default) then callback must not block or\n// call functions within this package that may block (e.g. Publish) other than in\n// a new go routine.\n// callback must be safe for concurrent use by multiple goroutines.\nfunc (c *client) AddRoute(topic string, callback MessageHandler) {\n\tif callback != nil {\n\t\tc.msgRouter.addRoute(topic, callback)\n\t}\n}\n\n// IsConnected returns a bool signifying whether\n// the client is connected or not.\n// connected means that the connection is up now OR it will\n// be established/reestablished automatically when possible\n// Warning: The connection status may change at any time so use this with care!\nfunc (c *client) IsConnected() bool {\n\t// This will need to change if additional statuses are added\n\ts, r := c.status.ConnectionStatusRetry()\n\tswitch {\n\tcase s == connected:\n\t\treturn true\n\tcase c.options.ConnectRetry && s == connecting:\n\t\treturn true\n\tcase c.options.AutoReconnect:\n\t\treturn s == reconnecting || (s == disconnecting && r) // r indicates we will reconnect\n\tdefault:\n\t\treturn false\n\t}\n}\n\n// IsConnectionOpen return a bool signifying whether the client has an active\n// connection to mqtt broker, i.e. not in disconnected or reconnect mode\n// Warning: The connection status may change at any time so use this with care!\nfunc (c *client) IsConnectionOpen() bool {\n\treturn c.status.ConnectionStatus() == connected\n}\n\n// ErrNotConnected is the error returned from function calls that are\n// made when the client is not connected to a broker\nvar ErrNotConnected = errors.New(\"not Connected\")\n\n// Connect will create a connection to the message broker, by default\n// it will attempt to connect at v3.1.1 and auto retry at v3.1 if that\n// fails\n// Note: If using QOS1+ and CleanSession=false it is advisable to add\n// routes (or a DefaultPublishHandler) prior to calling Connect()\n// because queued messages may be delivered immediately post connection\nfunc (c *client) Connect() Token {\n\tt := newToken(packets.Connect).(*ConnectToken)\n\tDEBUG.Println(CLI, \"Connect()\")\n\n\tconnectionUp, err := c.status.Connecting()\n\tif err != nil {\n\t\tif err == errAlreadyConnectedOrReconnecting && c.options.AutoReconnect {\n\t\t\t// When reconnection is active we don't consider calls tro Connect to ba an error (mainly for compatability)\n\t\t\tWARN.Println(CLI, \"Connect() called but not disconnected\")\n\t\t\tt.returnCode = packets.Accepted\n\t\t\tt.flowComplete()\n\t\t\treturn t\n\t\t}\n\t\tERROR.Println(CLI, err) // CONNECT should never be called unless we are disconnected\n\t\tt.setError(err)\n\t\treturn t\n\t}\n\n\tc.persist.Open()\n\tif c.options.ConnectRetry {\n\t\tc.reserveStoredPublishIDs() // Reserve IDs to allow publishing before connect complete\n\t}\n\n\tgo func() {\n\t\tif len(c.options.Servers) == 0 {\n\t\t\tt.setError(fmt.Errorf(\"no servers defined to connect to\"))\n\t\t\tif err := connectionUp(false); err != nil {\n\t\t\t\tERROR.Println(CLI, err.Error())\n\t\t\t}\n\t\t\treturn\n\t\t}\n\n\tRETRYCONN:\n\t\tvar conn net.Conn\n\t\tvar rc byte\n\t\tvar err error\n\t\tconn, rc, t.sessionPresent, err = c.attemptConnection()\n\t\tif err != nil {\n\t\t\tif c.options.ConnectRetry {\n\t\t\t\tDEBUG.Println(CLI, \"Connect failed, sleeping for\", int(c.options.ConnectRetryInterval.Seconds()), \"seconds and will then retry, error:\", err.Error())\n\t\t\t\ttime.Sleep(c.options.ConnectRetryInterval)\n\n\t\t\t\tif c.status.ConnectionStatus() == connecting { // Possible connection aborted elsewhere\n\t\t\t\t\tgoto RETRYCONN\n\t\t\t\t}\n\t\t\t}\n\t\t\tERROR.Println(CLI, \"Failed to connect to a broker\")\n\t\t\tc.persist.Close()\n\t\t\tt.returnCode = rc\n\t\t\tt.setError(err)\n\t\t\tif err := connectionUp(false); err != nil {\n\t\t\t\tERROR.Println(CLI, err.Error())\n\t\t\t}\n\t\t\treturn\n\t\t}\n\t\tinboundFromStore := make(chan packets.ControlPacket)           // there may be some inbound comms packets in the store that are awaiting processing\n\t\tif c.startCommsWorkers(conn, connectionUp, inboundFromStore) { // note that this takes care of updating the status (to connected or disconnected)\n\t\t\t// Take care of any messages in the store\n\t\t\tif !c.options.CleanSession {\n\t\t\t\tc.resume(c.options.ResumeSubs, inboundFromStore)\n\t\t\t} else {\n\t\t\t\tc.persist.Reset()\n\t\t\t}\n\t\t} else { // Note: With the new status subsystem this should only happen if Disconnect called simultaneously with the above\n\t\t\tWARN.Println(CLI, \"Connect() called but connection established in another goroutine\")\n\t\t}\n\n\t\tclose(inboundFromStore)\n\t\tt.flowComplete()\n\t\tDEBUG.Println(CLI, \"exit startClient\")\n\t}()\n\treturn t\n}\n\n// internal function used to reconnect the client when it loses its connection\n// The connection status MUST be reconnecting prior to calling this function (via call to status.connectionLost)\nfunc (c *client) reconnect(connectionUp connCompletedFn) {\n\tDEBUG.Println(CLI, \"enter reconnect\")\n\tvar (\n\t\tinitSleep = 1 * time.Second\n\t\tconn      net.Conn\n\t)\n\n\t// If the reason of connection lost is same as the before one, sleep timer is set before attempting connection is started.\n\t// Sleep time is exponentially increased as the same situation continues\n\tif slp, isContinual := c.backoff.sleepWithBackoff(\"connectionLost\", initSleep, c.options.MaxReconnectInterval, 3*time.Second, true); isContinual {\n\t\tDEBUG.Println(CLI, \"Detect continual connection lost after reconnect, slept for\", int(slp.Seconds()), \"seconds\")\n\t}\n\n\tfor {\n\t\tif nil != c.options.OnReconnecting {\n\t\t\tc.options.OnReconnecting(c, &c.options)\n\t\t}\n\t\tvar err error\n\t\tconn, _, _, err = c.attemptConnection()\n\t\tif err == nil {\n\t\t\tbreak\n\t\t}\n\t\tsleep, _ := c.backoff.sleepWithBackoff(\"attemptReconnection\", initSleep, c.options.MaxReconnectInterval, c.options.ConnectTimeout, false)\n\t\tDEBUG.Println(CLI, \"Reconnect failed, slept for\", int(sleep.Seconds()), \"seconds:\", err)\n\n\t\tif c.status.ConnectionStatus() != reconnecting { // Disconnect may have been called\n\t\t\tif err := connectionUp(false); err != nil { // Should always return an error\n\t\t\t\tERROR.Println(CLI, err.Error())\n\t\t\t}\n\t\t\tDEBUG.Println(CLI, \"Client moved to disconnected state while reconnecting, abandoning reconnect\")\n\t\t\treturn\n\t\t}\n\t}\n\n\tinboundFromStore := make(chan packets.ControlPacket)           // there may be some inbound comms packets in the store that are awaiting processing\n\tif c.startCommsWorkers(conn, connectionUp, inboundFromStore) { // note that this takes care of updating the status (to connected or disconnected)\n\t\tc.resume(c.options.ResumeSubs, inboundFromStore)\n\t}\n\tclose(inboundFromStore)\n}\n\n// attemptConnection makes a single attempt to connect to each of the brokers\n// the protocol version to use is passed in (as c.options.ProtocolVersion)\n// Note: Does not set c.conn in order to minimise race conditions\n// Returns:\n// net.Conn - Connected network connection\n// byte - Return code (packets.Accepted indicates a successful connection).\n// bool - SessionPresent flag from the connect ack (only valid if packets.Accepted)\n// err - Error (err != nil guarantees that conn has been set to active connection).\nfunc (c *client) attemptConnection() (net.Conn, byte, bool, error) {\n\tprotocolVersion := c.options.ProtocolVersion\n\tvar (\n\t\tsessionPresent bool\n\t\tconn           net.Conn\n\t\terr            error\n\t\trc             byte\n\t)\n\n\tc.optionsMu.Lock() // Protect c.options.Servers so that servers can be added in test cases\n\tbrokers := c.options.Servers\n\tc.optionsMu.Unlock()\n\tfor _, broker := range brokers {\n\t\tcm := newConnectMsgFromOptions(&c.options, broker)\n\t\tDEBUG.Println(CLI, \"about to write new connect msg\")\n\tCONN:\n\t\ttlsCfg := c.options.TLSConfig\n\t\tif c.options.OnConnectAttempt != nil {\n\t\t\tDEBUG.Println(CLI, \"using custom onConnectAttempt handler...\")\n\t\t\ttlsCfg = c.options.OnConnectAttempt(broker, c.options.TLSConfig)\n\t\t}\n\t\tconnDeadline := time.Now().Add(c.options.ConnectTimeout) // Time by which connection must be established\n\t\tdialer := c.options.Dialer\n\t\tif dialer == nil { //\n\t\t\tWARN.Println(CLI, \"dialer was nil, using default\")\n\t\t\tdialer = &net.Dialer{Timeout: 30 * time.Second}\n\t\t}\n\t\t// Start by opening the network connection (tcp, tls, ws) etc\n\t\tif c.options.CustomOpenConnectionFn != nil {\n\t\t\tconn, err = c.options.CustomOpenConnectionFn(broker, c.options)\n\t\t} else {\n\t\t\tconn, err = openConnection(broker, tlsCfg, c.options.ConnectTimeout, c.options.HTTPHeaders, c.options.WebsocketOptions, dialer)\n\t\t}\n\t\tif err != nil {\n\t\t\tERROR.Println(CLI, err.Error())\n\t\t\tWARN.Println(CLI, \"failed to connect to broker, trying next\")\n\t\t\trc = packets.ErrNetworkError\n\t\t\tcontinue\n\t\t}\n\t\tDEBUG.Println(CLI, \"socket connected to broker\")\n\n\t\t// Now we perform the MQTT connection handshake ensuring that it does not exceed the timeout\n\t\tif err := conn.SetDeadline(connDeadline); err != nil {\n\t\t\tERROR.Println(CLI, \"set deadline for handshake \", err)\n\t\t}\n\n\t\t// Now we perform the MQTT connection handshake\n\t\trc, sessionPresent, err = connectMQTT(conn, cm, protocolVersion)\n\t\tif rc == packets.Accepted {\n\t\t\tif err := conn.SetDeadline(time.Time{}); err != nil {\n\t\t\t\tERROR.Println(CLI, \"reset deadline following handshake \", err)\n\t\t\t}\n\t\t\tbreak // successfully connected\n\t\t}\n\n\t\t// We may have to attempt the connection with MQTT 3.1\n\t\t_ = conn.Close()\n\n\t\tif !c.options.protocolVersionExplicit && protocolVersion == 4 { // try falling back to 3.1?\n\t\t\tDEBUG.Println(CLI, \"Trying reconnect using MQTT 3.1 protocol\")\n\t\t\tprotocolVersion = 3\n\t\t\tgoto CONN\n\t\t}\n\t\tif c.options.protocolVersionExplicit { // to maintain logging from previous version\n\t\t\tERROR.Println(CLI, \"Connecting to\", broker, \"CONNACK was not CONN_ACCEPTED, but rather\", packets.ConnackReturnCodes[rc])\n\t\t}\n\t}\n\t// If the connection was successful we set member variable and lock in the protocol version for future connection attempts (and users)\n\tif rc == packets.Accepted {\n\t\tc.options.ProtocolVersion = protocolVersion\n\t\tc.options.protocolVersionExplicit = true\n\t} else {\n\t\t// Maintain same error format as used previously\n\t\tif rc != packets.ErrNetworkError { // mqtt error\n\t\t\terr = packets.ConnErrors[rc]\n\t\t} else { // network error (if this occurred in ConnectMQTT then err will be nil)\n\t\t\terr = fmt.Errorf(\"%w : %w\", packets.ConnErrors[rc], err)\n\t\t}\n\t}\n\treturn conn, rc, sessionPresent, err\n}\n\n// Disconnect will end the connection with the server, but not before waiting\n// the specified number of milliseconds to wait for existing work to be\n// completed.\n// WARNING: `Disconnect` may return before all activities (goroutines) have completed. This means that\n// reusing the `client` may lead to panics. If you want to reconnect when the connection drops then use\n// `SetAutoReconnect` and/or `SetConnectRetry`options instead of implementing this yourself.\nfunc (c *client) Disconnect(quiesce uint) {\n\tdone := make(chan struct{}) // Simplest way to ensure quiesce is always honoured\n\tgo func() {\n\t\tdefer close(done)\n\t\tdisDone, err := c.status.Disconnecting()\n\t\tif err != nil {\n\t\t\t// Status has been set to disconnecting, but we had to wait for something else to complete\n\t\t\tWARN.Println(CLI, err.Error())\n\t\t\treturn\n\t\t}\n\t\tdefer func() {\n\t\t\tc.disconnect() // Force disconnection\n\t\t\tdisDone()      // Update status\n\t\t}()\n\t\tDEBUG.Println(CLI, \"disconnecting\")\n\t\tdm := packets.NewControlPacket(packets.Disconnect).(*packets.DisconnectPacket)\n\t\tdt := newToken(packets.Disconnect)\n\t\tselect {\n\t\tcase c.oboundP <- &PacketAndToken{p: dm, t: dt}:\n\t\t\t// wait for work to finish, or quiesce time consumed\n\t\t\tDEBUG.Println(CLI, \"calling WaitTimeout\")\n\t\t\tdt.WaitTimeout(time.Duration(quiesce) * time.Millisecond)\n\t\t\tDEBUG.Println(CLI, \"WaitTimeout done\")\n\t\t// Below code causes a potential data race. Following status refactor it should no longer be required\n\t\t// but leaving in as need to check code further.\n\t\t// case <-c.commsStopped:\n\t\t//           WARN.Println(\"Disconnect packet could not be sent because comms stopped\")\n\t\tcase <-time.After(time.Duration(quiesce) * time.Millisecond):\n\t\t\tWARN.Println(\"Disconnect packet not sent due to timeout\")\n\t\t}\n\t}()\n\n\t// Return when done or after timeout expires (would like to change but this maintains compatibility)\n\tdelay := time.NewTimer(time.Duration(quiesce) * time.Millisecond)\n\tselect {\n\tcase <-done:\n\t\tif !delay.Stop() {\n\t\t\t<-delay.C\n\t\t}\n\tcase <-delay.C:\n\t}\n}\n\n// forceDisconnect will end the connection with the mqtt broker immediately (used for tests only)\nfunc (c *client) forceDisconnect() {\n\tdisDone, err := c.status.Disconnecting()\n\tif err != nil {\n\t\t// Possible that we are not actually connected\n\t\tWARN.Println(CLI, err.Error())\n\t\treturn\n\t}\n\tDEBUG.Println(CLI, \"forcefully disconnecting\")\n\tc.disconnect()\n\tdisDone()\n}\n\n// disconnect cleans up after a final disconnection (user requested so no auto reconnection)\nfunc (c *client) disconnect() {\n\tdone := c.stopCommsWorkers()\n\tif done != nil {\n\t\t<-done // Wait until the disconnect is complete (to limit chance that another connection will be started)\n\t\tDEBUG.Println(CLI, \"forcefully disconnecting\")\n\t\tc.messageIds.cleanUp()\n\t\tDEBUG.Println(CLI, \"disconnected\")\n\t\tc.persist.Close()\n\t}\n}\n\n// internalConnLost cleanup when connection is lost or an error occurs\n// Note: This function will not block\nfunc (c *client) internalConnLost(whyConnLost error) {\n\t// It is possible that internalConnLost will be called multiple times simultaneously\n\t// (including after sending a DisconnectPacket) as such we only do cleanup etc if the\n\t// routines were actually running and are not being disconnected at users request\n\tDEBUG.Println(CLI, \"internalConnLost called\")\n\tdisDone, err := c.status.ConnectionLost(c.options.AutoReconnect && c.status.ConnectionStatus() > connecting)\n\tif err != nil {\n\t\tif err == errConnLossWhileDisconnecting || err == errAlreadyHandlingConnectionLoss {\n\t\t\treturn // Loss of connection is expected or already being handled\n\t\t}\n\t\tERROR.Println(CLI, fmt.Sprintf(\"internalConnLost unexpected status: %s\", err.Error()))\n\t\treturn\n\t}\n\n\t// c.stopCommsWorker returns a channel that is closed when the operation completes. This was required prior\n\t// to the implementation of proper status management but has been left in place, for now, to minimise change\n\tstopDone := c.stopCommsWorkers()\n\t// stopDone was required in previous versions because there was no connectionLost status (and there were\n\t// issues with status handling). This code has been left in place for the time being just in case the new\n\t// status handling contains bugs (refactoring required at some point).\n\tif stopDone == nil { // stopDone will be nil if workers already in the process of stopping or stopped\n\t\tERROR.Println(CLI, \"internalConnLost stopDone unexpectedly nil - BUG BUG\")\n\t\t// Cannot really do anything other than leave things disconnected\n\t\tif _, err = disDone(false); err != nil { // Safest option - cannot leave status as connectionLost\n\t\t\tERROR.Println(CLI, fmt.Sprintf(\"internalConnLost failed to set status to disconnected (stopDone): %s\", err.Error()))\n\t\t}\n\t\treturn\n\t}\n\n\t// It may take a while for the disconnection to complete whatever called us needs to exit cleanly so finnish in goRoutine\n\tgo func() {\n\t\tDEBUG.Println(CLI, \"internalConnLost waiting on workers\")\n\t\t<-stopDone\n\t\tDEBUG.Println(CLI, \"internalConnLost workers stopped\")\n\n\t\treConnDone, err := disDone(true)\n\t\tif err != nil {\n\t\t\tERROR.Println(CLI, \"failure whilst reporting completion of disconnect\", err)\n\t\t} else if reConnDone == nil { // Should never happen\n\t\t\tERROR.Println(CLI, \"BUG BUG BUG reconnection function is nil\", err)\n\t\t}\n\n\t\treconnect := err == nil && reConnDone != nil\n\n\t\tif c.options.CleanSession && !reconnect {\n\t\t\tc.messageIds.cleanUp() // completes PUB/SUB/UNSUB tokens\n\t\t} else if !c.options.ResumeSubs {\n\t\t\tc.messageIds.cleanUpSubscribe() // completes SUB/UNSUB tokens\n\t\t}\n\t\tif reconnect {\n\t\t\tgo c.reconnect(reConnDone) // Will set connection status to reconnecting\n\t\t}\n\t\tif c.options.OnConnectionLost != nil {\n\t\t\tgo c.options.OnConnectionLost(c, whyConnLost)\n\t\t}\n\t\tDEBUG.Println(CLI, \"internalConnLost complete\")\n\t}()\n}\n\n// startCommsWorkers is called when the connection is up.\n// It starts off the routines needed to process incoming and outgoing messages.\n// Returns true if the comms workers were started (i.e. successful connection)\n// connectionUp(true) will be called once everything is up;  connectionUp(false) will be called on failure\nfunc (c *client) startCommsWorkers(conn net.Conn, connectionUp connCompletedFn, inboundFromStore <-chan packets.ControlPacket) bool {\n\tDEBUG.Println(CLI, \"startCommsWorkers called\")\n\tc.connMu.Lock()\n\tdefer c.connMu.Unlock()\n\tif c.conn != nil { // Should never happen due to new status handling; leaving in for safety for the time being\n\t\tWARN.Println(CLI, \"startCommsWorkers called when commsworkers already running BUG BUG\")\n\t\t_ = conn.Close() // No use for the new network connection\n\t\tif err := connectionUp(false); err != nil {\n\t\t\tERROR.Println(CLI, err.Error())\n\t\t}\n\t\treturn false\n\t}\n\tc.conn = conn // Store the connection\n\n\tc.stop = make(chan struct{})\n\tif c.options.KeepAlive != 0 {\n\t\tatomic.StoreInt32(&c.pingOutstanding, 0)\n\t\tc.lastReceived.Store(time.Now())\n\t\tc.lastSent.Store(time.Now())\n\t\tc.workers.Add(1)\n\t\tgo keepalive(c, conn)\n\t}\n\n\t// matchAndDispatch will process messages received from the network. It may generate acknowledgements\n\t// It will complete when incomingPubChan is closed and will close ackOut prior to exiting\n\tincomingPubChan := make(chan *packets.PublishPacket)\n\tc.workers.Add(1) // Done will be called when ackOut is closed\n\tackOut := c.msgRouter.matchAndDispatch(incomingPubChan, c.options.Order, c)\n\n\t// The connection is now ready for use (we spin up a few go routines below).\n\t// It is possible that Disconnect has been called in the interim...\n\t// issue 675：we will allow the connection to complete before the Disconnect is allowed to proceed\n\t//   as if a Disconnect event occurred immediately after connectionUp(true) completed.\n\tif err := connectionUp(true); err != nil {\n\t\tERROR.Println(CLI, err)\n\t}\n\n\tDEBUG.Println(CLI, \"client is connected/reconnected\")\n\tif c.options.OnConnect != nil {\n\t\tgo c.options.OnConnect(c)\n\t}\n\n\t// c.oboundP and c.obound need to stay active for the life of the client because, depending upon the options,\n\t// messages may be published while the client is disconnected (they will block unless in a goroutine). However\n\t// to keep the comms routines clean we want to shutdown the input messages it uses so create out own channels\n\t// and copy data across.\n\tcommsobound := make(chan *PacketAndToken)  // outgoing publish packets\n\tcommsoboundP := make(chan *PacketAndToken) // outgoing 'priority' packet\n\tc.workers.Add(1)\n\tgo func() {\n\t\tdefer c.workers.Done()\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase msg := <-c.oboundP:\n\t\t\t\tcommsoboundP <- msg\n\t\t\tcase msg := <-c.obound:\n\t\t\t\tcommsobound <- msg\n\t\t\tcase msg, ok := <-ackOut:\n\t\t\t\tif !ok {\n\t\t\t\t\tackOut = nil     // ignore channel going forward\n\t\t\t\t\tc.workers.Done() // matchAndDispatch has completed\n\t\t\t\t\tcontinue         // await next message\n\t\t\t\t}\n\t\t\t\tcommsoboundP <- msg\n\t\t\tcase <-c.stop:\n\t\t\t\t// Attempt to transmit any outstanding acknowledgements (this may well fail but should work if this is a clean disconnect)\n\t\t\t\tif ackOut != nil {\n\t\t\t\t\tfor msg := range ackOut {\n\t\t\t\t\t\tcommsoboundP <- msg\n\t\t\t\t\t}\n\t\t\t\t\tc.workers.Done() // matchAndDispatch has completed\n\t\t\t\t}\n\t\t\t\tclose(commsoboundP) // Nothing sending to these channels anymore so close them and allow comms routines to exit\n\t\t\t\tclose(commsobound)\n\t\t\t\tDEBUG.Println(CLI, \"startCommsWorkers output redirector finished\")\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t}()\n\n\tcommsIncomingPub, commsErrors := startComms(c.conn, c, inboundFromStore, commsoboundP, commsobound)\n\tc.commsStopped = make(chan struct{})\n\tgo func() {\n\t\tfor {\n\t\t\tif commsIncomingPub == nil && commsErrors == nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tselect {\n\t\t\tcase pub, ok := <-commsIncomingPub:\n\t\t\t\tif !ok {\n\t\t\t\t\t// Incoming comms has shutdown\n\t\t\t\t\tclose(incomingPubChan) // stop the router\n\t\t\t\t\tcommsIncomingPub = nil\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\t// Care is needed here because an error elsewhere could trigger a deadlock\n\t\t\tsendPubLoop:\n\t\t\t\tfor {\n\t\t\t\t\tselect {\n\t\t\t\t\tcase incomingPubChan <- pub:\n\t\t\t\t\t\tbreak sendPubLoop\n\t\t\t\t\tcase err, ok := <-commsErrors:\n\t\t\t\t\t\tif !ok { // commsErrors has been closed so we can ignore it\n\t\t\t\t\t\t\tcommsErrors = nil\n\t\t\t\t\t\t\tcontinue\n\t\t\t\t\t\t}\n\t\t\t\t\t\tERROR.Println(CLI, \"Connect comms goroutine - error triggered during send Pub\", err)\n\t\t\t\t\t\tc.internalConnLost(err) // no harm in calling this if the connection is already down (or shutdown is in progress)\n\t\t\t\t\t\tcontinue\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\tcase err, ok := <-commsErrors:\n\t\t\t\tif !ok {\n\t\t\t\t\tcommsErrors = nil\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\tERROR.Println(CLI, \"Connect comms goroutine - error triggered\", err)\n\t\t\t\tc.internalConnLost(err) // no harm in calling this if the connection is already down (or shutdown is in progress)\n\t\t\t\tcontinue\n\t\t\t}\n\t\t}\n\t\tDEBUG.Println(CLI, \"incoming comms goroutine done\")\n\t\tclose(c.commsStopped)\n\t}()\n\tDEBUG.Println(CLI, \"startCommsWorkers done\")\n\treturn true\n}\n\n// stopWorkersAndComms - Cleanly shuts down worker go routines (including the comms routines) and waits until everything has stopped\n// Returns nil if workers did not need to be stopped; otherwise returns a channel which will be closed when the stop is complete\n// Note: This may block so run as a go routine if calling from any of the comms routines\n// Note2: It should be possible to simplify this now that the new status management code is in place.\nfunc (c *client) stopCommsWorkers() chan struct{} {\n\tDEBUG.Println(CLI, \"stopCommsWorkers called\")\n\t// It is possible that this function will be called multiple times simultaneously due to the way things get shutdown\n\tc.connMu.Lock()\n\tif c.conn == nil {\n\t\tDEBUG.Println(CLI, \"stopCommsWorkers done (not running)\")\n\t\tc.connMu.Unlock()\n\t\treturn nil\n\t}\n\n\t// It is important that everything is stopped in the correct order to avoid deadlocks. The main issue here is\n\t// the router because it both receives incoming publish messages and also sends outgoing acknowledgements. To\n\t// avoid issues we signal the workers to stop and close the connection (it is probably already closed but\n\t// there is no harm in being sure). We can then wait for the workers to finnish before closing outbound comms\n\t// channels which will allow the comms routines to exit.\n\n\t// We stop all non-comms related workers first (ping, keepalive, errwatch, resume etc) so they don't get blocked waiting on comms\n\tclose(c.stop)     // Signal for workers to stop\n\tc.conn.Close()    // Possible that this is already closed but no harm in closing again\n\tc.conn = nil      // Important that this is the only place that this is set to nil\n\tc.connMu.Unlock() // As the connection is now nil we can unlock the mu (allowing subsequent calls to exit immediately)\n\n\tdoneChan := make(chan struct{})\n\n\tgo func() {\n\t\tDEBUG.Println(CLI, \"stopCommsWorkers waiting for workers\")\n\t\tc.workers.Wait()\n\n\t\t// Stopping the workers will allow the comms routines to exit; we wait for these to complete\n\t\tDEBUG.Println(CLI, \"stopCommsWorkers waiting for comms\")\n\t\t<-c.commsStopped // wait for comms routine to stop\n\n\t\tDEBUG.Println(CLI, \"stopCommsWorkers done\")\n\t\tclose(doneChan)\n\t}()\n\treturn doneChan\n}\n\n// Publish will publish a message with the specified QoS and content\n// to the specified topic.\n// Returns a token to track delivery of the message to the broker\nfunc (c *client) Publish(topic string, qos byte, retained bool, payload interface{}) Token {\n\ttoken := newToken(packets.Publish).(*PublishToken)\n\tDEBUG.Println(CLI, \"enter Publish\")\n\tswitch {\n\tcase !c.IsConnected():\n\t\ttoken.setError(ErrNotConnected)\n\t\treturn token\n\tcase c.status.ConnectionStatus() == reconnecting && qos == 0:\n\t\t// message written to store and will be sent when connection comes up\n\t\ttoken.flowComplete()\n\t\treturn token\n\t}\n\tpub := packets.NewControlPacket(packets.Publish).(*packets.PublishPacket)\n\tpub.Qos = qos\n\tpub.TopicName = topic\n\tpub.Retain = retained\n\tswitch p := payload.(type) {\n\tcase string:\n\t\tpub.Payload = []byte(p)\n\tcase []byte:\n\t\tpub.Payload = p\n\tcase bytes.Buffer:\n\t\tpub.Payload = p.Bytes()\n\tdefault:\n\t\ttoken.setError(fmt.Errorf(\"unknown payload type\"))\n\t\treturn token\n\t}\n\n\tif pub.Qos != 0 && pub.MessageID == 0 {\n\t\tmID := c.getID(token)\n\t\tif mID == 0 {\n\t\t\ttoken.setError(fmt.Errorf(\"no message IDs available\"))\n\t\t\treturn token\n\t\t}\n\t\tpub.MessageID = mID\n\t\ttoken.messageID = mID\n\t}\n\tpersistOutbound(c.persist, pub)\n\tswitch c.status.ConnectionStatus() {\n\tcase connecting:\n\t\tDEBUG.Println(CLI, \"storing publish message (connecting), topic:\", topic)\n\tcase reconnecting:\n\t\tDEBUG.Println(CLI, \"storing publish message (reconnecting), topic:\", topic)\n\tcase disconnecting:\n\t\tDEBUG.Println(CLI, \"storing publish message (disconnecting), topic:\", topic)\n\tdefault:\n\t\tDEBUG.Println(CLI, \"sending publish message, topic:\", topic)\n\t\tpublishWaitTimeout := c.options.WriteTimeout\n\t\tif publishWaitTimeout == 0 {\n\t\t\tpublishWaitTimeout = time.Second * 30\n\t\t}\n\n\t\tt := time.NewTimer(publishWaitTimeout)\n\t\tdefer t.Stop()\n\n\t\tselect {\n\t\tcase c.obound <- &PacketAndToken{p: pub, t: token}:\n\t\tcase <-t.C:\n\t\t\ttoken.setError(errors.New(\"publish was broken by timeout\"))\n\t\t}\n\t}\n\treturn token\n}\n\n// Subscribe starts a new subscription. Provide a MessageHandler to be executed when\n// a message is published on the topic provided.\n//\n// If options.OrderMatters is true (the default) then callback must not block or\n// call functions within this package that may block (e.g. Publish) other than in\n// a new go routine.\n// callback must be safe for concurrent use by multiple goroutines.\nfunc (c *client) Subscribe(topic string, qos byte, callback MessageHandler) Token {\n\ttoken := newToken(packets.Subscribe).(*SubscribeToken)\n\tDEBUG.Println(CLI, \"enter Subscribe\")\n\tif !c.IsConnected() {\n\t\ttoken.setError(ErrNotConnected)\n\t\treturn token\n\t}\n\tif !c.IsConnectionOpen() {\n\t\tswitch {\n\t\tcase !c.options.ResumeSubs:\n\t\t\t// if not connected and resumeSubs not set this sub will be thrown away\n\t\t\ttoken.setError(fmt.Errorf(\"not currently connected and ResumeSubs not set\"))\n\t\t\treturn token\n\t\tcase c.options.CleanSession && c.status.ConnectionStatus() == reconnecting:\n\t\t\t// if reconnecting and cleanSession is true this sub will be thrown away\n\t\t\ttoken.setError(fmt.Errorf(\"reconnecting state and cleansession is true\"))\n\t\t\treturn token\n\t\t}\n\t}\n\tsub := packets.NewControlPacket(packets.Subscribe).(*packets.SubscribePacket)\n\tif err := validateTopicAndQos(topic, qos); err != nil {\n\t\ttoken.setError(err)\n\t\treturn token\n\t}\n\tsub.Topics = append(sub.Topics, topic)\n\tsub.Qoss = append(sub.Qoss, qos)\n\n\tif strings.HasPrefix(topic, \"$share/\") {\n\t\ttopic = strings.Join(strings.Split(topic, \"/\")[2:], \"/\")\n\t}\n\n\tif strings.HasPrefix(topic, \"$queue/\") {\n\t\ttopic = strings.TrimPrefix(topic, \"$queue/\")\n\t}\n\n\tif callback != nil {\n\t\tc.msgRouter.addRoute(topic, callback)\n\t}\n\n\ttoken.subs = append(token.subs, topic)\n\n\tif sub.MessageID == 0 {\n\t\tmID := c.getID(token)\n\t\tif mID == 0 {\n\t\t\ttoken.setError(fmt.Errorf(\"no message IDs available\"))\n\t\t\treturn token\n\t\t}\n\t\tsub.MessageID = mID\n\t\ttoken.messageID = mID\n\t}\n\tDEBUG.Println(CLI, sub.String())\n\n\tif c.options.ResumeSubs { // Only persist if we need this to resume subs after a disconnection\n\t\tpersistOutbound(c.persist, sub)\n\t}\n\tswitch c.status.ConnectionStatus() {\n\tcase connecting:\n\t\tDEBUG.Println(CLI, \"storing subscribe message (connecting), topic:\", topic)\n\tcase reconnecting:\n\t\tDEBUG.Println(CLI, \"storing subscribe message (reconnecting), topic:\", topic)\n\tcase disconnecting:\n\t\tDEBUG.Println(CLI, \"storing subscribe message (disconnecting), topic:\", topic)\n\tdefault:\n\t\tDEBUG.Println(CLI, \"sending subscribe message, topic:\", topic)\n\t\tsubscribeWaitTimeout := c.options.WriteTimeout\n\t\tif subscribeWaitTimeout == 0 {\n\t\t\tsubscribeWaitTimeout = time.Second * 30\n\t\t}\n\t\tselect {\n\t\tcase c.oboundP <- &PacketAndToken{p: sub, t: token}:\n\t\tcase <-time.After(subscribeWaitTimeout):\n\t\t\ttoken.setError(errors.New(\"subscribe was broken by timeout\"))\n\t\t}\n\t}\n\tDEBUG.Println(CLI, \"exit Subscribe\")\n\treturn token\n}\n\n// SubscribeMultiple starts a new subscription for multiple topics. Provide a MessageHandler to\n// be executed when a message is published on one of the topics provided.\n//\n// If options.OrderMatters is true (the default) then callback must not block or\n// call functions within this package that may block (e.g. Publish) other than in\n// a new go routine.\n// callback must be safe for concurrent use by multiple goroutines.\nfunc (c *client) SubscribeMultiple(filters map[string]byte, callback MessageHandler) Token {\n\tvar err error\n\ttoken := newToken(packets.Subscribe).(*SubscribeToken)\n\tDEBUG.Println(CLI, \"enter SubscribeMultiple\")\n\tif !c.IsConnected() {\n\t\ttoken.setError(ErrNotConnected)\n\t\treturn token\n\t}\n\tif !c.IsConnectionOpen() {\n\t\tswitch {\n\t\tcase !c.options.ResumeSubs:\n\t\t\t// if not connected and resumesubs not set this sub will be thrown away\n\t\t\ttoken.setError(fmt.Errorf(\"not currently connected and ResumeSubs not set\"))\n\t\t\treturn token\n\t\tcase c.options.CleanSession && c.status.ConnectionStatus() == reconnecting:\n\t\t\t// if reconnecting and cleanSession is true this sub will be thrown away\n\t\t\ttoken.setError(fmt.Errorf(\"reconnecting state and cleansession is true\"))\n\t\t\treturn token\n\t\t}\n\t}\n\tsub := packets.NewControlPacket(packets.Subscribe).(*packets.SubscribePacket)\n\tif sub.Topics, sub.Qoss, err = validateSubscribeMap(filters); err != nil {\n\t\ttoken.setError(err)\n\t\treturn token\n\t}\n\n\tif callback != nil {\n\t\tfor topic := range filters {\n\t\t\tc.msgRouter.addRoute(topic, callback)\n\t\t}\n\t}\n\ttoken.subs = make([]string, len(sub.Topics))\n\tcopy(token.subs, sub.Topics)\n\n\tif sub.MessageID == 0 {\n\t\tmID := c.getID(token)\n\t\tif mID == 0 {\n\t\t\ttoken.setError(fmt.Errorf(\"no message IDs available\"))\n\t\t\treturn token\n\t\t}\n\t\tsub.MessageID = mID\n\t\ttoken.messageID = mID\n\t}\n\tif c.options.ResumeSubs { // Only persist if we need this to resume subs after a disconnection\n\t\tpersistOutbound(c.persist, sub)\n\t}\n\tswitch c.status.ConnectionStatus() {\n\tcase connecting:\n\t\tDEBUG.Println(CLI, \"storing subscribe message (connecting), topics:\", sub.Topics)\n\tcase reconnecting:\n\t\tDEBUG.Println(CLI, \"storing subscribe message (reconnecting), topics:\", sub.Topics)\n\tcase disconnecting:\n\t\tDEBUG.Println(CLI, \"storing subscribe message (disconnecting), topics:\", sub.Topics)\n\tdefault:\n\t\tDEBUG.Println(CLI, \"sending subscribe message, topics:\", sub.Topics)\n\t\tsubscribeWaitTimeout := c.options.WriteTimeout\n\t\tif subscribeWaitTimeout == 0 {\n\t\t\tsubscribeWaitTimeout = time.Second * 30\n\t\t}\n\t\tselect {\n\t\tcase c.oboundP <- &PacketAndToken{p: sub, t: token}:\n\t\tcase <-time.After(subscribeWaitTimeout):\n\t\t\ttoken.setError(errors.New(\"subscribe was broken by timeout\"))\n\t\t}\n\t}\n\tDEBUG.Println(CLI, \"exit SubscribeMultiple\")\n\treturn token\n}\n\n// reserveStoredPublishIDs reserves the ids for publish packets in the persistent store to ensure these are not duplicated\nfunc (c *client) reserveStoredPublishIDs() {\n\t// The resume function sets the stored id for publish packets only (some other packets\n\t// will get new ids in net code). This means that the only keys we need to ensure are\n\t// unique are the publish ones (and these will completed/replaced in resume() )\n\tif !c.options.CleanSession {\n\t\tstoredKeys := c.persist.All()\n\t\tfor _, key := range storedKeys {\n\t\t\tpacket := c.persist.Get(key)\n\t\t\tif packet == nil {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tswitch packet.(type) {\n\t\t\tcase *packets.PublishPacket:\n\t\t\t\tdetails := packet.Details()\n\t\t\t\ttoken := &PlaceHolderToken{id: details.MessageID}\n\t\t\t\tc.claimID(token, details.MessageID)\n\t\t\t}\n\t\t}\n\t}\n}\n\n// Load all stored messages and resend them\n// Call this to ensure QOS > 1,2 even after an application crash\n// Note: This function will exit if c.stop is closed (this allows the shutdown to proceed avoiding a potential deadlock)\n// other than that it does not return until all messages in the store have been sent (connect() does not complete its\n// token before this completes)\nfunc (c *client) resume(subscription bool, ibound chan packets.ControlPacket) {\n\tDEBUG.Println(STR, \"enter Resume\")\n\n\t// Prior to sending a message getSemaphore will be called and once sent releaseSemaphore will be called\n\t// with the token (so semaphore can be released when ACK received if applicable).\n\t// Using a weighted semaphore rather than channels because this retains ordering\n\tgetSemaphore := func() {}                    // Default = do nothing\n\treleaseSemaphore := func(_ *PublishToken) {} // Default = do nothing\n\tvar sem *semaphore.Weighted\n\tif c.options.MaxResumePubInFlight > 0 {\n\t\tsem = semaphore.NewWeighted(int64(c.options.MaxResumePubInFlight))\n\t\tctx, cancel := context.WithCancel(context.Background()) // Context needed for semaphore\n\t\tdefer cancel()                                          // ensure context gets cancelled\n\n\t\tgo func() {\n\t\t\tselect {\n\t\t\tcase <-c.stop: // Request to stop (due to comm error etc)\n\t\t\t\tcancel()\n\t\t\tcase <-ctx.Done(): // resume completed normally\n\t\t\t}\n\t\t}()\n\n\t\tgetSemaphore = func() { sem.Acquire(ctx, 1) }\n\t\treleaseSemaphore = func(token *PublishToken) { // Note: If token never completes then resume() may stall (will still exit on ctx.Done())\n\t\t\tgo func() {\n\t\t\t\tselect {\n\t\t\t\tcase <-token.Done():\n\t\t\t\tcase <-ctx.Done():\n\t\t\t\t}\n\t\t\t\tsem.Release(1)\n\t\t\t}()\n\t\t}\n\t}\n\n\tstoredKeys := c.persist.All()\n\tfor _, key := range storedKeys {\n\t\tpacket := c.persist.Get(key)\n\t\tif packet == nil {\n\t\t\tDEBUG.Println(STR, fmt.Sprintf(\"resume found NIL packet (%s)\", key))\n\t\t\tcontinue\n\t\t}\n\t\tdetails := packet.Details()\n\t\tif isKeyOutbound(key) {\n\t\t\tswitch p := packet.(type) {\n\t\t\tcase *packets.SubscribePacket:\n\t\t\t\tif subscription {\n\t\t\t\t\tDEBUG.Println(STR, fmt.Sprintf(\"loaded pending subscribe (%d)\", details.MessageID))\n\t\t\t\t\tsubPacket := packet.(*packets.SubscribePacket)\n\t\t\t\t\ttoken := newToken(packets.Subscribe).(*SubscribeToken)\n\t\t\t\t\ttoken.messageID = details.MessageID\n\t\t\t\t\ttoken.subs = append(token.subs, subPacket.Topics...)\n\t\t\t\t\tc.claimID(token, details.MessageID)\n\t\t\t\t\tselect {\n\t\t\t\t\tcase c.oboundP <- &PacketAndToken{p: packet, t: token}:\n\t\t\t\t\tcase <-c.stop:\n\t\t\t\t\t\tDEBUG.Println(STR, \"resume exiting due to stop\")\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tc.persist.Del(key) // Unsubscribe packets should not be retained following a reconnect\n\t\t\t\t}\n\t\t\tcase *packets.UnsubscribePacket:\n\t\t\t\tif subscription {\n\t\t\t\t\tDEBUG.Println(STR, fmt.Sprintf(\"loaded pending unsubscribe (%d)\", details.MessageID))\n\t\t\t\t\ttoken := newToken(packets.Unsubscribe).(*UnsubscribeToken)\n\t\t\t\t\tselect {\n\t\t\t\t\tcase c.oboundP <- &PacketAndToken{p: packet, t: token}:\n\t\t\t\t\tcase <-c.stop:\n\t\t\t\t\t\tDEBUG.Println(STR, \"resume exiting due to stop\")\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tc.persist.Del(key) // Unsubscribe packets should not be retained following a reconnect\n\t\t\t\t}\n\t\t\tcase *packets.PubrelPacket:\n\t\t\t\tDEBUG.Println(STR, fmt.Sprintf(\"loaded pending pubrel (%d)\", details.MessageID))\n\t\t\t\tselect {\n\t\t\t\tcase c.oboundP <- &PacketAndToken{p: packet, t: nil}:\n\t\t\t\tcase <-c.stop:\n\t\t\t\t\tDEBUG.Println(STR, \"resume exiting due to stop\")\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\tcase *packets.PublishPacket:\n\t\t\t\t// spec: If the DUP flag is set to 0, it indicates that this is the first occasion that the Client or\n\t\t\t\t// Server has attempted to send this MQTT PUBLISH Packet. If the DUP flag is set to 1, it indicates that\n\t\t\t\t// this might be re-delivery of an earlier attempt to send the Packet.\n\t\t\t\t//\n\t\t\t\t// If the message is in the store than an attempt at delivery has been made (note that the message may\n\t\t\t\t// never have made it onto the wire but tracking that would be complicated!).\n\t\t\t\tif p.Qos != 0 { // spec: The DUP flag MUST be set to 0 for all QoS 0 messages\n\t\t\t\t\tp.Dup = true\n\t\t\t\t}\n\t\t\t\ttoken := newToken(packets.Publish).(*PublishToken)\n\t\t\t\ttoken.messageID = details.MessageID\n\t\t\t\tc.claimID(token, details.MessageID)\n\t\t\t\tDEBUG.Println(STR, fmt.Sprintf(\"loaded pending publish (%d)\", details.MessageID))\n\t\t\t\tDEBUG.Println(STR, details)\n\t\t\t\tgetSemaphore()\n\t\t\t\tselect {\n\t\t\t\tcase c.obound <- &PacketAndToken{p: p, t: token}:\n\t\t\t\tcase <-c.stop:\n\t\t\t\t\tDEBUG.Println(STR, \"resume exiting due to stop\")\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\treleaseSemaphore(token) // If limiting simultaneous messages then we need to know when message is acknowledged\n\t\t\tdefault:\n\t\t\t\tERROR.Println(STR, fmt.Sprintf(\"invalid message type (inbound - %T) in store (discarded)\", packet))\n\t\t\t\tc.persist.Del(key)\n\t\t\t}\n\t\t} else {\n\t\t\tswitch packet.(type) {\n\t\t\tcase *packets.PubrelPacket:\n\t\t\t\tDEBUG.Println(STR, fmt.Sprintf(\"loaded pending incomming (%d)\", details.MessageID))\n\t\t\t\tselect {\n\t\t\t\tcase ibound <- packet:\n\t\t\t\tcase <-c.stop:\n\t\t\t\t\tDEBUG.Println(STR, \"resume exiting due to stop (ibound <- packet)\")\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\tdefault:\n\t\t\t\tERROR.Println(STR, fmt.Sprintf(\"invalid message type (%T) in store (discarded)\", packet))\n\t\t\t\tc.persist.Del(key)\n\t\t\t}\n\t\t}\n\t}\n\tDEBUG.Println(STR, \"exit resume\")\n}\n\n// Unsubscribe will end the subscription from each of the topics provided.\n// Messages published to those topics from other clients will no longer be\n// received.\nfunc (c *client) Unsubscribe(topics ...string) Token {\n\ttoken := newToken(packets.Unsubscribe).(*UnsubscribeToken)\n\tDEBUG.Println(CLI, \"enter Unsubscribe\")\n\tif !c.IsConnected() {\n\t\ttoken.setError(ErrNotConnected)\n\t\treturn token\n\t}\n\tif !c.IsConnectionOpen() {\n\t\tswitch {\n\t\tcase !c.options.ResumeSubs:\n\t\t\t// if not connected and resumeSubs not set this unsub will be thrown away\n\t\t\ttoken.setError(fmt.Errorf(\"not currently connected and ResumeSubs not set\"))\n\t\t\treturn token\n\t\tcase c.options.CleanSession && c.status.ConnectionStatus() == reconnecting:\n\t\t\t// if reconnecting and cleanSession is true this unsub will be thrown away\n\t\t\ttoken.setError(fmt.Errorf(\"reconnecting state and cleansession is true\"))\n\t\t\treturn token\n\t\t}\n\t}\n\tunsub := packets.NewControlPacket(packets.Unsubscribe).(*packets.UnsubscribePacket)\n\tunsub.Topics = make([]string, len(topics))\n\tcopy(unsub.Topics, topics)\n\n\tif unsub.MessageID == 0 {\n\t\tmID := c.getID(token)\n\t\tif mID == 0 {\n\t\t\ttoken.setError(fmt.Errorf(\"no message IDs available\"))\n\t\t\treturn token\n\t\t}\n\t\tunsub.MessageID = mID\n\t\ttoken.messageID = mID\n\t}\n\n\tif c.options.ResumeSubs { // Only persist if we need this to resume subs after a disconnection\n\t\tpersistOutbound(c.persist, unsub)\n\t}\n\n\tswitch c.status.ConnectionStatus() {\n\tcase connecting:\n\t\tDEBUG.Println(CLI, \"storing unsubscribe message (connecting), topics:\", topics)\n\tcase reconnecting:\n\t\tDEBUG.Println(CLI, \"storing unsubscribe message (reconnecting), topics:\", topics)\n\tcase disconnecting:\n\t\tDEBUG.Println(CLI, \"storing unsubscribe message (reconnecting), topics:\", topics)\n\tdefault:\n\t\tDEBUG.Println(CLI, \"sending unsubscribe message, topics:\", topics)\n\t\tsubscribeWaitTimeout := c.options.WriteTimeout\n\t\tif subscribeWaitTimeout == 0 {\n\t\t\tsubscribeWaitTimeout = time.Second * 30\n\t\t}\n\t\tselect {\n\t\tcase c.oboundP <- &PacketAndToken{p: unsub, t: token}:\n\t\t\tfor _, topic := range topics {\n\t\t\t\tc.msgRouter.deleteRoute(topic)\n\t\t\t}\n\t\tcase <-time.After(subscribeWaitTimeout):\n\t\t\ttoken.setError(errors.New(\"unsubscribe was broken by timeout\"))\n\t\t}\n\t}\n\n\tDEBUG.Println(CLI, \"exit Unsubscribe\")\n\treturn token\n}\n\n// OptionsReader returns a ClientOptionsReader which is a copy of the clientoptions\n// in use by the client.\nfunc (c *client) OptionsReader() ClientOptionsReader {\n\tr := ClientOptionsReader{options: &c.options}\n\treturn r\n}\n\n// DefaultConnectionLostHandler is a definition of a function that simply\n// reports to the DEBUG log the reason for the client losing a connection.\nfunc DefaultConnectionLostHandler(client Client, reason error) {\n\tDEBUG.Println(\"Connection lost:\", reason.Error())\n}\n\n// UpdateLastReceived - Will be called whenever a packet is received off the network\n// This is used by the keepalive routine to\nfunc (c *client) UpdateLastReceived() {\n\tif c.options.KeepAlive != 0 {\n\t\tc.lastReceived.Store(time.Now())\n\t}\n}\n\n// UpdateLastReceived - Will be called whenever a packet is successfully transmitted to the network\nfunc (c *client) UpdateLastSent() {\n\tif c.options.KeepAlive != 0 {\n\t\tc.lastSent.Store(time.Now())\n\t}\n}\n\n// getWriteTimeOut returns the writetimeout (duration to wait when writing to the connection) or 0 if none\nfunc (c *client) getWriteTimeOut() time.Duration {\n\treturn c.options.WriteTimeout\n}\n\n// persistOutbound adds the packet to the outbound store\nfunc (c *client) persistOutbound(m packets.ControlPacket) {\n\tpersistOutbound(c.persist, m)\n}\n\n// persistInbound adds the packet to the inbound store\nfunc (c *client) persistInbound(m packets.ControlPacket) {\n\tpersistInbound(c.persist, m)\n}\n\n// pingRespReceived will be called by the network routines when a ping response is received\nfunc (c *client) pingRespReceived() {\n\tatomic.StoreInt32(&c.pingOutstanding, 0)\n}\n"
        },
        {
          "name": "client_test.go",
          "type": "blob",
          "size": 2.3681640625,
          "content": "/*\n * Copyright (c) 2021 IBM Corp and others.\n *\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v2.0\n * and Eclipse Distribution License v1.0 which accompany this distribution.\n *\n * The Eclipse Public License is available at\n *    https://www.eclipse.org/legal/epl-2.0/\n * and the Eclipse Distribution License is available at\n *   http://www.eclipse.org/org/documents/edl-v10.php.\n *\n * Contributors:\n *    Seth Hoenig\n *    Allan Stockdill-Mander\n *    Mike Robertson\n *    Matt Brittan\n */\npackage mqtt\n\nimport (\n\t\"net\"\n\t\"net/url\"\n\t\"strings\"\n\t\"testing\"\n\t\"time\"\n)\n\nfunc TestCustomConnectionFunction(t *testing.T) {\n\t// Set netpipe to emulate a connection of a different type\n\tnetClient, netServer := net.Pipe()\n\tdefer netClient.Close()\n\tdefer netServer.Close()\n\n\toutputChan := make(chan struct {\n\t\tmsg []byte\n\t\terr error\n\t})\n\tgo func() {\n\t\t// read first message only\n\t\tbytes := make([]byte, 1024)\n\t\tnetServer.SetDeadline(time.Now().Add(time.Second)) // Ensure this will always complete\n\t\tn, err := netServer.Read(bytes)\n\t\tif err != nil {\n\t\t\toutputChan <- struct {\n\t\t\t\tmsg []byte\n\t\t\t\terr error\n\t\t\t}{err: err}\n\t\t} else {\n\t\t\toutputChan <- struct {\n\t\t\t\tmsg []byte\n\t\t\t\terr error\n\t\t\t}{msg: bytes[:n]}\n\t\t}\n\t}()\n\t// Set custom network connection function and client connect\n\tvar customConnectionFunc OpenConnectionFunc = func(uri *url.URL, options ClientOptions) (net.Conn, error) {\n\t\treturn netClient, nil\n\t}\n\toptions := NewClientOptions().SetCustomOpenConnectionFn(customConnectionFunc)\n\tbrokerAddr := netServer.LocalAddr().Network()\n\toptions.AddBroker(brokerAddr)\n\tclient := NewClient(options)\n\n\t// Try to connect using custom function, wait for 2 seconds, to pass MQTT first message\n\t// Note that the token should NOT complete (because a CONNACK is never sent)\n\ttoken := client.Connect()\n\tif token.WaitTimeout(2 * time.Second) {\n\t\tt.Fatal(\"token should not complete\") // should be blocked waiting for CONNACK\n\t}\n\tif token.Error() != nil { // Should never have an error\n\t\tt.Fatalf(\"%v\", token.Error())\n\t}\n\n\tmsg := <-outputChan\n\tif msg.err != nil {\n\t\tt.Fatalf(\"read from simulated connection failed: %v\", msg.err)\n\t}\n\n\t// Analyze first message sent by client and received by the server\n\tfirstMessage := string(msg.msg)\n\tif len(firstMessage) <= 0 || !strings.Contains(firstMessage, \"MQTT\") {\n\t\tt.Error(\"no message received on connect\")\n\t}\n}\n"
        },
        {
          "name": "cmd",
          "type": "tree",
          "content": null
        },
        {
          "name": "components.go",
          "type": "blob",
          "size": 0.9541015625,
          "content": "/*\n * Copyright (c) 2021 IBM Corp and others.\n *\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v2.0\n * and Eclipse Distribution License v1.0 which accompany this distribution.\n *\n * The Eclipse Public License is available at\n *    https://www.eclipse.org/legal/epl-2.0/\n * and the Eclipse Distribution License is available at\n *   http://www.eclipse.org/org/documents/edl-v10.php.\n *\n * Contributors:\n *    Seth Hoenig\n *    Allan Stockdill-Mander\n *    Mike Robertson\n */\n\npackage mqtt\n\ntype component string\n\n// Component names for debug output\nconst (\n\tNET component = \"[net]     \"\n\tPNG component = \"[pinger]  \"\n\tCLI component = \"[client]  \"\n\tDEC component = \"[decode]  \"\n\tMES component = \"[message] \"\n\tSTR component = \"[store]   \"\n\tMID component = \"[msgids]  \"\n\tTST component = \"[test]    \"\n\tSTA component = \"[state]   \"\n\tERR component = \"[error]   \"\n\tROU component = \"[router]  \"\n)\n"
        },
        {
          "name": "edl-v10",
          "type": "blob",
          "size": 1.52734375,
          "content": "\nEclipse Distribution License - v 1.0\n\nCopyright (c) 2007, Eclipse Foundation, Inc. and its licensors.\n\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n\n    Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\n    Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\n    Neither the name of the Eclipse Foundation, Inc. nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission. \n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\n"
        },
        {
          "name": "epl-v20",
          "type": "blob",
          "size": 13.86328125,
          "content": "Eclipse Public License - v 2.0\n\n    THE ACCOMPANYING PROGRAM IS PROVIDED UNDER THE TERMS OF THIS ECLIPSE\n    PUBLIC LICENSE (\"AGREEMENT\"). ANY USE, REPRODUCTION OR DISTRIBUTION\n    OF THE PROGRAM CONSTITUTES RECIPIENT'S ACCEPTANCE OF THIS AGREEMENT.\n\n1. DEFINITIONS\n\n\"Contribution\" means:\n\n  a) in the case of the initial Contributor, the initial content\n     Distributed under this Agreement, and\n\n  b) in the case of each subsequent Contributor:\n     i) changes to the Program, and\n     ii) additions to the Program;\n  where such changes and/or additions to the Program originate from\n  and are Distributed by that particular Contributor. A Contribution\n  \"originates\" from a Contributor if it was added to the Program by\n  such Contributor itself or anyone acting on such Contributor's behalf.\n  Contributions do not include changes or additions to the Program that\n  are not Modified Works.\n\n\"Contributor\" means any person or entity that Distributes the Program.\n\n\"Licensed Patents\" mean patent claims licensable by a Contributor which\nare necessarily infringed by the use or sale of its Contribution alone\nor when combined with the Program.\n\n\"Program\" means the Contributions Distributed in accordance with this\nAgreement.\n\n\"Recipient\" means anyone who receives the Program under this Agreement\nor any Secondary License (as applicable), including Contributors.\n\n\"Derivative Works\" shall mean any work, whether in Source Code or other\nform, that is based on (or derived from) the Program and for which the\neditorial revisions, annotations, elaborations, or other modifications\nrepresent, as a whole, an original work of authorship.\n\n\"Modified Works\" shall mean any work in Source Code or other form that\nresults from an addition to, deletion from, or modification of the\ncontents of the Program, including, for purposes of clarity any new file\nin Source Code form that contains any contents of the Program. Modified\nWorks shall not include works that contain only declarations,\ninterfaces, types, classes, structures, or files of the Program solely\nin each case in order to link to, bind by name, or subclass the Program\nor Modified Works thereof.\n\n\"Distribute\" means the acts of a) distributing or b) making available\nin any manner that enables the transfer of a copy.\n\n\"Source Code\" means the form of a Program preferred for making\nmodifications, including but not limited to software source code,\ndocumentation source, and configuration files.\n\n\"Secondary License\" means either the GNU General Public License,\nVersion 2.0, or any later versions of that license, including any\nexceptions or additional permissions as identified by the initial\nContributor.\n\n2. GRANT OF RIGHTS\n\n  a) Subject to the terms of this Agreement, each Contributor hereby\n  grants Recipient a non-exclusive, worldwide, royalty-free copyright\n  license to reproduce, prepare Derivative Works of, publicly display,\n  publicly perform, Distribute and sublicense the Contribution of such\n  Contributor, if any, and such Derivative Works.\n\n  b) Subject to the terms of this Agreement, each Contributor hereby\n  grants Recipient a non-exclusive, worldwide, royalty-free patent\n  license under Licensed Patents to make, use, sell, offer to sell,\n  import and otherwise transfer the Contribution of such Contributor,\n  if any, in Source Code or other form. This patent license shall\n  apply to the combination of the Contribution and the Program if, at\n  the time the Contribution is added by the Contributor, such addition\n  of the Contribution causes such combination to be covered by the\n  Licensed Patents. The patent license shall not apply to any other\n  combinations which include the Contribution. No hardware per se is\n  licensed hereunder.\n\n  c) Recipient understands that although each Contributor grants the\n  licenses to its Contributions set forth herein, no assurances are\n  provided by any Contributor that the Program does not infringe the\n  patent or other intellectual property rights of any other entity.\n  Each Contributor disclaims any liability to Recipient for claims\n  brought by any other entity based on infringement of intellectual\n  property rights or otherwise. As a condition to exercising the\n  rights and licenses granted hereunder, each Recipient hereby\n  assumes sole responsibility to secure any other intellectual\n  property rights needed, if any. For example, if a third party\n  patent license is required to allow Recipient to Distribute the\n  Program, it is Recipient's responsibility to acquire that license\n  before distributing the Program.\n\n  d) Each Contributor represents that to its knowledge it has\n  sufficient copyright rights in its Contribution, if any, to grant\n  the copyright license set forth in this Agreement.\n\n  e) Notwithstanding the terms of any Secondary License, no\n  Contributor makes additional grants to any Recipient (other than\n  those set forth in this Agreement) as a result of such Recipient's\n  receipt of the Program under the terms of a Secondary License\n  (if permitted under the terms of Section 3).\n\n3. REQUIREMENTS\n\n3.1 If a Contributor Distributes the Program in any form, then:\n\n  a) the Program must also be made available as Source Code, in\n  accordance with section 3.2, and the Contributor must accompany\n  the Program with a statement that the Source Code for the Program\n  is available under this Agreement, and informs Recipients how to\n  obtain it in a reasonable manner on or through a medium customarily\n  used for software exchange; and\n\n  b) the Contributor may Distribute the Program under a license\n  different than this Agreement, provided that such license:\n     i) effectively disclaims on behalf of all other Contributors all\n     warranties and conditions, express and implied, including\n     warranties or conditions of title and non-infringement, and\n     implied warranties or conditions of merchantability and fitness\n     for a particular purpose;\n\n     ii) effectively excludes on behalf of all other Contributors all\n     liability for damages, including direct, indirect, special,\n     incidental and consequential damages, such as lost profits;\n\n     iii) does not attempt to limit or alter the recipients' rights\n     in the Source Code under section 3.2; and\n\n     iv) requires any subsequent distribution of the Program by any\n     party to be under a license that satisfies the requirements\n     of this section 3.\n\n3.2 When the Program is Distributed as Source Code:\n\n  a) it must be made available under this Agreement, or if the\n  Program (i) is combined with other material in a separate file or\n  files made available under a Secondary License, and (ii) the initial\n  Contributor attached to the Source Code the notice described in\n  Exhibit A of this Agreement, then the Program may be made available\n  under the terms of such Secondary Licenses, and\n\n  b) a copy of this Agreement must be included with each copy of\n  the Program.\n\n3.3 Contributors may not remove or alter any copyright, patent,\ntrademark, attribution notices, disclaimers of warranty, or limitations\nof liability (\"notices\") contained within the Program from any copy of\nthe Program which they Distribute, provided that Contributors may add\ntheir own appropriate notices.\n\n4. COMMERCIAL DISTRIBUTION\n\nCommercial distributors of software may accept certain responsibilities\nwith respect to end users, business partners and the like. While this\nlicense is intended to facilitate the commercial use of the Program,\nthe Contributor who includes the Program in a commercial product\noffering should do so in a manner which does not create potential\nliability for other Contributors. Therefore, if a Contributor includes\nthe Program in a commercial product offering, such Contributor\n(\"Commercial Contributor\") hereby agrees to defend and indemnify every\nother Contributor (\"Indemnified Contributor\") against any losses,\ndamages and costs (collectively \"Losses\") arising from claims, lawsuits\nand other legal actions brought by a third party against the Indemnified\nContributor to the extent caused by the acts or omissions of such\nCommercial Contributor in connection with its distribution of the Program\nin a commercial product offering. The obligations in this section do not\napply to any claims or Losses relating to any actual or alleged\nintellectual property infringement. In order to qualify, an Indemnified\nContributor must: a) promptly notify the Commercial Contributor in\nwriting of such claim, and b) allow the Commercial Contributor to control,\nand cooperate with the Commercial Contributor in, the defense and any\nrelated settlement negotiations. The Indemnified Contributor may\nparticipate in any such claim at its own expense.\n\nFor example, a Contributor might include the Program in a commercial\nproduct offering, Product X. That Contributor is then a Commercial\nContributor. If that Commercial Contributor then makes performance\nclaims, or offers warranties related to Product X, those performance\nclaims and warranties are such Commercial Contributor's responsibility\nalone. Under this section, the Commercial Contributor would have to\ndefend claims against the other Contributors related to those performance\nclaims and warranties, and if a court requires any other Contributor to\npay any damages as a result, the Commercial Contributor must pay\nthose damages.\n\n5. NO WARRANTY\n\nEXCEPT AS EXPRESSLY SET FORTH IN THIS AGREEMENT, AND TO THE EXTENT\nPERMITTED BY APPLICABLE LAW, THE PROGRAM IS PROVIDED ON AN \"AS IS\"\nBASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, EITHER EXPRESS OR\nIMPLIED INCLUDING, WITHOUT LIMITATION, ANY WARRANTIES OR CONDITIONS OF\nTITLE, NON-INFRINGEMENT, MERCHANTABILITY OR FITNESS FOR A PARTICULAR\nPURPOSE. Each Recipient is solely responsible for determining the\nappropriateness of using and distributing the Program and assumes all\nrisks associated with its exercise of rights under this Agreement,\nincluding but not limited to the risks and costs of program errors,\ncompliance with applicable laws, damage to or loss of data, programs\nor equipment, and unavailability or interruption of operations.\n\n6. DISCLAIMER OF LIABILITY\n\nEXCEPT AS EXPRESSLY SET FORTH IN THIS AGREEMENT, AND TO THE EXTENT\nPERMITTED BY APPLICABLE LAW, NEITHER RECIPIENT NOR ANY CONTRIBUTORS\nSHALL HAVE ANY LIABILITY FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\nEXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING WITHOUT LIMITATION LOST\nPROFITS), HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\nCONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\nARISING IN ANY WAY OUT OF THE USE OR DISTRIBUTION OF THE PROGRAM OR THE\nEXERCISE OF ANY RIGHTS GRANTED HEREUNDER, EVEN IF ADVISED OF THE\nPOSSIBILITY OF SUCH DAMAGES.\n\n7. GENERAL\n\nIf any provision of this Agreement is invalid or unenforceable under\napplicable law, it shall not affect the validity or enforceability of\nthe remainder of the terms of this Agreement, and without further\naction by the parties hereto, such provision shall be reformed to the\nminimum extent necessary to make such provision valid and enforceable.\n\nIf Recipient institutes patent litigation against any entity\n(including a cross-claim or counterclaim in a lawsuit) alleging that the\nProgram itself (excluding combinations of the Program with other software\nor hardware) infringes such Recipient's patent(s), then such Recipient's\nrights granted under Section 2(b) shall terminate as of the date such\nlitigation is filed.\n\nAll Recipient's rights under this Agreement shall terminate if it\nfails to comply with any of the material terms or conditions of this\nAgreement and does not cure such failure in a reasonable period of\ntime after becoming aware of such noncompliance. If all Recipient's\nrights under this Agreement terminate, Recipient agrees to cease use\nand distribution of the Program as soon as reasonably practicable.\nHowever, Recipient's obligations under this Agreement and any licenses\ngranted by Recipient relating to the Program shall continue and survive.\n\nEveryone is permitted to copy and distribute copies of this Agreement,\nbut in order to avoid inconsistency the Agreement is copyrighted and\nmay only be modified in the following manner. The Agreement Steward\nreserves the right to publish new versions (including revisions) of\nthis Agreement from time to time. No one other than the Agreement\nSteward has the right to modify this Agreement. The Eclipse Foundation\nis the initial Agreement Steward. The Eclipse Foundation may assign the\nresponsibility to serve as the Agreement Steward to a suitable separate\nentity. Each new version of the Agreement will be given a distinguishing\nversion number. The Program (including Contributions) may always be\nDistributed subject to the version of the Agreement under which it was\nreceived. In addition, after a new version of the Agreement is published,\nContributor may elect to Distribute the Program (including its\nContributions) under the new version.\n\nExcept as expressly stated in Sections 2(a) and 2(b) above, Recipient\nreceives no rights or licenses to the intellectual property of any\nContributor under this Agreement, whether expressly, by implication,\nestoppel or otherwise. All rights in the Program not expressly granted\nunder this Agreement are reserved. Nothing in this Agreement is intended\nto be enforceable by any entity that is not a Contributor or Recipient.\nNo third-party beneficiary rights are created under this Agreement.\n\nExhibit A - Form of Secondary Licenses Notice\n\n\"This Source Code may also be made available under the following\nSecondary Licenses when the conditions for such availability set forth\nin the Eclipse Public License, v. 2.0 are satisfied: {name license(s),\nversion(s), and exceptions or additional permissions here}.\"\n\n  Simply including a copy of this Agreement, including this Exhibit A\n  is not sufficient to license the Source Code under Secondary Licenses.\n\n  If it is not possible or desirable to put the notice in a particular\n  file, then You may include the notice in a location (such as a LICENSE\n  file in a relevant directory) where a recipient would be likely to\n  look for such a notice.\n\n  You may add additional accurate notices of copyright ownership."
        },
        {
          "name": "filestore.go",
          "type": "blob",
          "size": 6.4560546875,
          "content": "/*\n * Copyright (c) 2021 IBM Corp and others.\n *\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v2.0\n * and Eclipse Distribution License v1.0 which accompany this distribution.\n *\n * The Eclipse Public License is available at\n *    https://www.eclipse.org/legal/epl-2.0/\n * and the Eclipse Distribution License is available at\n *   http://www.eclipse.org/org/documents/edl-v10.php.\n *\n * Contributors:\n *    Seth Hoenig\n *    Allan Stockdill-Mander\n *    Mike Robertson\n */\n\npackage mqtt\n\nimport (\n\t\"io/fs\"\n\t\"os\"\n\t\"path\"\n\t\"sort\"\n\t\"sync\"\n\n\t\"github.com/eclipse/paho.mqtt.golang/packets\"\n)\n\nconst (\n\tmsgExt     = \".msg\"\n\ttmpExt     = \".tmp\"\n\tcorruptExt = \".CORRUPT\"\n)\n\n// FileStore implements the store interface using the filesystem to provide\n// true persistence, even across client failure. This is designed to use a\n// single directory per running client. If you are running multiple clients\n// on the same filesystem, you will need to be careful to specify unique\n// store directories for each.\ntype FileStore struct {\n\tsync.RWMutex\n\tdirectory string\n\topened    bool\n}\n\n// NewFileStore will create a new FileStore which stores its messages in the\n// directory provided.\nfunc NewFileStore(directory string) *FileStore {\n\tstore := &FileStore{\n\t\tdirectory: directory,\n\t\topened:    false,\n\t}\n\treturn store\n}\n\n// Open will allow the FileStore to be used.\nfunc (store *FileStore) Open() {\n\tstore.Lock()\n\tdefer store.Unlock()\n\t// if no store directory was specified in ClientOpts, by default use the\n\t// current working directory\n\tif store.directory == \"\" {\n\t\tstore.directory, _ = os.Getwd()\n\t}\n\n\t// if store dir exists, great, otherwise, create it\n\tif !exists(store.directory) {\n\t\tperms := os.FileMode(0770)\n\t\tmerr := os.MkdirAll(store.directory, perms)\n\t\tchkerr(merr)\n\t}\n\tstore.opened = true\n\tDEBUG.Println(STR, \"store is opened at\", store.directory)\n}\n\n// Close will disallow the FileStore from being used.\nfunc (store *FileStore) Close() {\n\tstore.Lock()\n\tdefer store.Unlock()\n\tstore.opened = false\n\tDEBUG.Println(STR, \"store is closed\")\n}\n\n// Put will put a message into the store, associated with the provided\n// key value.\nfunc (store *FileStore) Put(key string, m packets.ControlPacket) {\n\tstore.Lock()\n\tdefer store.Unlock()\n\tif !store.opened {\n\t\tERROR.Println(STR, \"Trying to use file store, but not open\")\n\t\treturn\n\t}\n\tfull := fullpath(store.directory, key)\n\twrite(store.directory, key, m)\n\tif !exists(full) {\n\t\tERROR.Println(STR, \"file not created:\", full)\n\t}\n}\n\n// Get will retrieve a message from the store, the one associated with\n// the provided key value.\nfunc (store *FileStore) Get(key string) packets.ControlPacket {\n\tstore.RLock()\n\tdefer store.RUnlock()\n\tif !store.opened {\n\t\tERROR.Println(STR, \"trying to use file store, but not open\")\n\t\treturn nil\n\t}\n\tfilepath := fullpath(store.directory, key)\n\tif !exists(filepath) {\n\t\treturn nil\n\t}\n\tmfile, oerr := os.Open(filepath)\n\tchkerr(oerr)\n\tmsg, rerr := packets.ReadPacket(mfile)\n\tchkerr(mfile.Close())\n\n\t// Message was unreadable, return nil\n\tif rerr != nil {\n\t\tnewpath := corruptpath(store.directory, key)\n\t\tWARN.Println(STR, \"corrupted file detected:\", rerr.Error(), \"archived at:\", newpath)\n\t\tif err := os.Rename(filepath, newpath); err != nil {\n\t\t\tERROR.Println(STR, err)\n\t\t}\n\t\treturn nil\n\t}\n\treturn msg\n}\n\n// All will provide a list of all of the keys associated with messages\n// currently residing in the FileStore.\nfunc (store *FileStore) All() []string {\n\tstore.RLock()\n\tdefer store.RUnlock()\n\treturn store.all()\n}\n\n// Del will remove the persisted message associated with the provided\n// key from the FileStore.\nfunc (store *FileStore) Del(key string) {\n\tstore.Lock()\n\tdefer store.Unlock()\n\tstore.del(key)\n}\n\n// Reset will remove all persisted messages from the FileStore.\nfunc (store *FileStore) Reset() {\n\tstore.Lock()\n\tdefer store.Unlock()\n\tWARN.Println(STR, \"FileStore Reset\")\n\tfor _, key := range store.all() {\n\t\tstore.del(key)\n\t}\n}\n\n// lockless\nfunc (store *FileStore) all() []string {\n\tvar err error\n\tvar keys []string\n\n\tif !store.opened {\n\t\tERROR.Println(STR, \"trying to use file store, but not open\")\n\t\treturn nil\n\t}\n\n\tentries, err := os.ReadDir(store.directory)\n\tchkerr(err)\n\tfiles := make(fileInfos, 0, len(entries))\n\tfor _, entry := range entries {\n\t\tinfo, err := entry.Info()\n\t\tchkerr(err)\n\t\tfiles = append(files, info)\n\t}\n\tsort.Sort(files)\n\tfor _, f := range files {\n\t\tDEBUG.Println(STR, \"file in All():\", f.Name())\n\t\tname := f.Name()\n\t\tif len(name) < len(msgExt) || name[len(name)-len(msgExt):] != msgExt {\n\t\t\tDEBUG.Println(STR, \"skipping file, doesn't have right extension: \", name)\n\t\t\tcontinue\n\t\t}\n\t\tkey := name[0 : len(name)-4] // remove file extension\n\t\tkeys = append(keys, key)\n\t}\n\treturn keys\n}\n\n// lockless\nfunc (store *FileStore) del(key string) {\n\tif !store.opened {\n\t\tERROR.Println(STR, \"trying to use file store, but not open\")\n\t\treturn\n\t}\n\tDEBUG.Println(STR, \"store del filepath:\", store.directory)\n\tDEBUG.Println(STR, \"store delete key:\", key)\n\tfilepath := fullpath(store.directory, key)\n\tDEBUG.Println(STR, \"path of deletion:\", filepath)\n\tif !exists(filepath) {\n\t\tWARN.Println(STR, \"store could not delete key:\", key)\n\t\treturn\n\t}\n\trerr := os.Remove(filepath)\n\tchkerr(rerr)\n\tDEBUG.Println(STR, \"del msg:\", key)\n\tif exists(filepath) {\n\t\tERROR.Println(STR, \"file not deleted:\", filepath)\n\t}\n}\n\nfunc fullpath(store string, key string) string {\n\tp := path.Join(store, key+msgExt)\n\treturn p\n}\n\nfunc tmppath(store string, key string) string {\n\tp := path.Join(store, key+tmpExt)\n\treturn p\n}\n\nfunc corruptpath(store string, key string) string {\n\tp := path.Join(store, key+corruptExt)\n\treturn p\n}\n\n// create file called \"X.[messageid].tmp\" located in the store\n// the contents of the file is the bytes of the message, then\n// rename it to \"X.[messageid].msg\", overwriting any existing\n// message with the same id\n// X will be 'i' for inbound messages, and O for outbound messages\nfunc write(store, key string, m packets.ControlPacket) {\n\ttemppath := tmppath(store, key)\n\tf, err := os.Create(temppath)\n\tchkerr(err)\n\twerr := m.Write(f)\n\tchkerr(werr)\n\tcerr := f.Close()\n\tchkerr(cerr)\n\trerr := os.Rename(temppath, fullpath(store, key))\n\tchkerr(rerr)\n}\n\nfunc exists(file string) bool {\n\tif _, err := os.Stat(file); err != nil {\n\t\tif os.IsNotExist(err) {\n\t\t\treturn false\n\t\t}\n\t\tchkerr(err)\n\t}\n\treturn true\n}\n\ntype fileInfos []fs.FileInfo\n\nfunc (f fileInfos) Len() int {\n\treturn len(f)\n}\n\nfunc (f fileInfos) Swap(i, j int) {\n\tf[i], f[j] = f[j], f[i]\n}\n\nfunc (f fileInfos) Less(i, j int) bool {\n\treturn f[i].ModTime().Before(f[j].ModTime())\n}\n"
        },
        {
          "name": "fvt",
          "type": "tree",
          "content": null
        },
        {
          "name": "fvt_client_test.go",
          "type": "blob",
          "size": 47.6630859375,
          "content": "/*\n * Copyright (c) 2021 IBM Corp and others.\n *\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v2.0\n * and Eclipse Distribution License v1.0 which accompany this distribution.\n *\n * The Eclipse Public License is available at\n *    https://www.eclipse.org/legal/epl-2.0/\n * and the Eclipse Distribution License is available at\n *   http://www.eclipse.org/org/documents/edl-v10.php.\n *\n * Contributors:\n *    Seth Hoenig\n *    Allan Stockdill-Mander\n *    Mike Robertson\n */\n\npackage mqtt\n\nimport (\n\t\"bytes\"\n\t\"context\"\n\t\"fmt\"\n\t\"runtime\"\n\t\"strconv\"\n\t\"sync\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/eclipse/paho.mqtt.golang/packets\"\n)\n\nfunc Test_Start(t *testing.T) {\n\tops := NewClientOptions().SetClientID(\"Start\").AddBroker(FVTTCP)\n\tc := NewClient(ops)\n\n\tif token := c.Connect(); token.Wait() && token.Error() != nil {\n\t\tt.Fatalf(\"Error on Client.Connect(): %v\", token.Error())\n\t}\n\n\t// Disconnect should return within 250ms and calling a second time should not block\n\tdisconnectC := make(chan struct{}, 1)\n\tgo func() {\n\t\tc.Disconnect(250)\n\t\tc.Disconnect(5)\n\t\tclose(disconnectC)\n\t}()\n\n\tselect {\n\tcase <-time.After(time.Millisecond * 300):\n\t\tt.Errorf(\"disconnect did not finnish within 300ms\")\n\tcase <-disconnectC:\n\t}\n}\n\n/* uncomment this if you have connection policy disallowing FailClientID\n func Test_InvalidConnRc(t *testing.T) {\n\t ops := NewClientOptions().SetClientID(\"FailClientID\").\n\t\t AddBroker(\"tcp://\" + FVT_IP + \":17003\").\n\t\t SetStore(NewFileStore(\"/tmp/fvt/InvalidConnRc\"))\n\n\t c := NewClient(ops)\n\t _, err := c.Connect()\n\t if err != ErrNotAuthorized {\n\t\t t.Fatalf(\"Did not receive error as expected, got %v\", err)\n\t }\n\t c.Disconnect(250)\n }\n*/\n\n// Helper function for Test_Start_Ssl\n// func NewTLSConfig() *tls.Config {\n// \tcertpool := x509.NewCertPool()\n// \tpemCerts, err := ioutil.ReadFile(\"samples/samplecerts/CAfile.pem\")\n// \tif err == nil {\n// \t\tcertpool.AppendCertsFromPEM(pemCerts)\n// \t}\n\n// \tcert, err := tls.LoadX509KeyPair(\"samples/samplecerts/client-crt.pem\", \"samples/samplecerts/client-key.pem\")\n// \tif err != nil {\n// \t\tpanic(err)\n// \t}\n\n// \treturn &tls.Config{\n// \t\tRootCAs:            certpool,\n// \t\tClientAuth:         tls.NoClientCert,\n// \t\tClientCAs:          nil,\n// \t\tInsecureSkipVerify: true,\n// \t\tCertificates:       []tls.Certificate{cert},\n// \t}\n// }\n\n/* uncomment this if you have ssl setup\n func Test_Start_Ssl(t *testing.T) {\n\t tlsconfig := NewTlsConfig()\n\t ops := NewClientOptions().SetClientID(\"StartSsl\").\n\t\t AddBroker(FVT_SSL).\n\t\t SetStore(NewFileStore(\"/tmp/fvt/Start_Ssl\")).\n\t\t SetTlsConfig(tlsconfig)\n\n\t c := NewClient(ops)\n\n\t _, err := c.Connect()\n\t if err != nil {\n\t\t t.Fatalf(\"Error on Client.Connect(): %v\", err)\n\t }\n\n\t c.Disconnect(250)\n }\n*/\n\n// Disconnect should not block under any circumstance\n// This is triggered by issue #501; there is a very slight chance that Disconnect could get through the\n// `status == connected` check and then the connection drops...\nfunc Test_Disconnect(t *testing.T) {\n\tops := NewClientOptions().SetClientID(\"Disconnect\").AddBroker(FVTTCP)\n\tc := NewClient(ops)\n\n\tif token := c.Connect(); token.Wait() && token.Error() != nil {\n\t\tt.Fatalf(\"Error on Client.Connect(): %v\", token.Error())\n\t}\n\n\t// Attempt to disconnect twice simultaneously and ensure this does not block\n\tdisconnectC := make(chan struct{}, 1)\n\tgo func() {\n\t\tc.Disconnect(250)\n\t\tcli := c.(*client)\n\t\tcli.status.forceConnectionStatus(connected)\n\t\tc.Disconnect(250)\n\t\tclose(disconnectC)\n\t}()\n\n\tselect {\n\tcase <-time.After(time.Millisecond * 300):\n\t\tt.Errorf(\"disconnect did not finnish within 300ms\")\n\tcase <-disconnectC:\n\t}\n}\n\nfunc Test_Publish_1(t *testing.T) {\n\tops := NewClientOptions()\n\tops.AddBroker(FVTTCP)\n\tops.SetClientID(\"Publish_1\")\n\n\tc := NewClient(ops)\n\ttoken := c.Connect()\n\tif token.Wait() && token.Error() != nil {\n\t\tt.Fatalf(\"Error on Client.Connect(): %v\", token.Error())\n\t}\n\n\tc.Publish(\"test/Publish\", 0, false, \"Publish qo0\")\n\n\tc.Disconnect(250)\n}\n\nfunc Test_Publish_2(t *testing.T) {\n\tops := NewClientOptions()\n\tops.AddBroker(FVTTCP)\n\tops.SetClientID(\"Publish_2\")\n\n\tc := NewClient(ops)\n\ttoken := c.Connect()\n\tif token.Wait() && token.Error() != nil {\n\t\tt.Fatalf(\"Error on Client.Connect(): %v\", token.Error())\n\t}\n\n\tc.Publish(\"/test/Publish\", 0, false, \"Publish1 qos0\")\n\tc.Publish(\"/test/Publish\", 0, false, \"Publish2 qos0\")\n\n\tc.Disconnect(250)\n}\n\nfunc Test_Publish_3(t *testing.T) {\n\tops := NewClientOptions()\n\tops.AddBroker(FVTTCP)\n\tops.SetClientID(\"Publish_3\")\n\n\tc := NewClient(ops)\n\ttoken := c.Connect()\n\tif token.Wait() && token.Error() != nil {\n\t\tt.Fatalf(\"Error on Client.Connect(): %v\", token.Error())\n\t}\n\n\tc.Publish(\"/test/Publish\", 0, false, \"Publish1 qos0\")\n\tc.Publish(\"/test/Publish\", 1, false, \"Publish2 qos1\")\n\tc.Publish(\"/test/Publish\", 2, false, \"Publish2 qos2\")\n\n\tc.Disconnect(250)\n}\n\nfunc Test_Publish_BytesBuffer(t *testing.T) {\n\tops := NewClientOptions()\n\tops.AddBroker(FVTTCP)\n\tops.SetClientID(\"Publish_BytesBuffer\")\n\n\tc := NewClient(ops)\n\ttoken := c.Connect()\n\tif token.Wait() && token.Error() != nil {\n\t\tt.Fatalf(\"Error on Client.Connect(): %v\", token.Error())\n\t}\n\n\tpayload := bytes.NewBufferString(\"Publish qos0\")\n\n\tc.Publish(\"test/Publish\", 0, false, payload)\n\n\tc.Disconnect(250)\n}\n\nfunc Test_Subscribe(t *testing.T) {\n\tpops := NewClientOptions()\n\tpops.AddBroker(FVTTCP)\n\tpops.SetClientID(\"Subscribe_tx\")\n\tp := NewClient(pops)\n\n\tsops := NewClientOptions()\n\tsops.AddBroker(FVTTCP)\n\tsops.SetClientID(\"Subscribe_rx\")\n\tvar f MessageHandler = func(client Client, msg Message) {\n\t\tfmt.Printf(\"TOPIC: %s\\n\", msg.Topic())\n\t\tfmt.Printf(\"MSG: %s\\n\", msg.Payload())\n\t}\n\tsops.SetDefaultPublishHandler(f)\n\ts := NewClient(sops)\n\n\tsToken := s.Connect()\n\tif sToken.Wait() && sToken.Error() != nil {\n\t\tt.Fatalf(\"Error on Client.Connect(): %v\", sToken.Error())\n\t}\n\n\ts.Subscribe(\"/test/sub\", 0, nil)\n\n\tpToken := p.Connect()\n\tif pToken.Wait() && pToken.Error() != nil {\n\t\tt.Fatalf(\"Error on Client.Connect(): %v\", pToken.Error())\n\t}\n\n\tp.Publish(\"/test/sub\", 0, false, \"Publish qos0\")\n\n\tp.Disconnect(250)\n\ts.Disconnect(250)\n}\n\nfunc Test_Will(t *testing.T) {\n\twillmsgc := make(chan string, 1)\n\n\tsops := NewClientOptions().AddBroker(FVTTCP)\n\tsops.SetClientID(\"will-giver\")\n\tsops.SetWill(\"/wills\", \"good-byte!\", 0, false)\n\tsops.SetConnectionLostHandler(func(client Client, err error) {\n\t\tfmt.Println(\"OnConnectionLost!\")\n\t})\n\tsops.SetAutoReconnect(false)\n\tc := NewClient(sops).(*client)\n\n\twops := NewClientOptions()\n\twops.AddBroker(FVTTCP)\n\twops.SetClientID(\"will-subscriber\")\n\twops.SetDefaultPublishHandler(func(client Client, msg Message) {\n\t\tfmt.Printf(\"TOPIC: %s\\n\", msg.Topic())\n\t\tfmt.Printf(\"MSG: %s\\n\", msg.Payload())\n\t\twillmsgc <- string(msg.Payload())\n\t})\n\twops.SetAutoReconnect(false)\n\twsub := NewClient(wops)\n\n\tif wToken := wsub.Connect(); wToken.Wait() && wToken.Error() != nil {\n\t\tt.Fatalf(\"Error on Client.Connect(): %v\", wToken.Error())\n\t}\n\n\tif wsubToken := wsub.Subscribe(\"/wills\", 0, nil); wsubToken.Wait() && wsubToken.Error() != nil {\n\t\tt.Fatalf(\"Error on Client.Subscribe(): %v\", wsubToken.Error())\n\t}\n\n\tif token := c.Connect(); token.Wait() && token.Error() != nil {\n\t\tt.Fatalf(\"Error on Client.Connect(): %v\", token.Error())\n\t}\n\n\tc.forceDisconnect()\n\n\tif <-willmsgc != \"good-byte!\" {\n\t\tt.Fatalf(\"will message did not have correct payload\")\n\t}\n\n\twsub.Disconnect(250)\n}\n\nfunc Test_CleanSession(t *testing.T) {\n\tclsnc := make(chan string, 1)\n\n\tsops := NewClientOptions().AddBroker(FVTTCP)\n\tsops.SetClientID(\"clsn-sender\")\n\tsops.SetConnectionLostHandler(func(client Client, err error) {\n\t\tfmt.Println(\"OnConnectionLost!\")\n\t})\n\tsops.SetAutoReconnect(false)\n\tc := NewClient(sops).(*client)\n\n\twops := NewClientOptions()\n\twops.AddBroker(FVTTCP)\n\twops.SetClientID(\"clsn-tester\")\n\twops.SetCleanSession(false)\n\twops.SetDefaultPublishHandler(func(client Client, msg Message) {\n\t\tfmt.Printf(\"TOPIC: %s\\n\", msg.Topic())\n\t\tfmt.Printf(\"MSG: %s\\n\", msg.Payload())\n\t\tclsnc <- string(msg.Payload())\n\t})\n\twops.SetAutoReconnect(false)\n\twsub := NewClient(wops)\n\n\tif wToken := wsub.Connect(); wToken.Wait() && wToken.Error() != nil {\n\t\tt.Fatalf(\"Error on Client.Connect(): %v\", wToken.Error())\n\t}\n\n\tif wsubToken := wsub.Subscribe(\"clean\", 1, nil); wsubToken.Wait() && wsubToken.Error() != nil {\n\t\tt.Fatalf(\"Error on Client.Subscribe(): %v\", wsubToken.Error())\n\t}\n\n\twsub.Disconnect(250)\n\ttime.Sleep(2 * time.Second)\n\n\tif token := c.Connect(); token.Wait() && token.Error() != nil {\n\t\tt.Fatalf(\"Error on Client.Connect(): %v\", token.Error())\n\t}\n\n\tif pToken := c.Publish(\"clean\", 1, false, \"clean!\"); pToken.Wait() && pToken.Error() != nil {\n\t\tt.Fatalf(\"Error on Client.Publish(): %v\", pToken.Error())\n\t}\n\n\tc.Disconnect(250)\n\n\twsub = NewClient(wops)\n\tif wToken := wsub.Connect(); wToken.Wait() && wToken.Error() != nil {\n\t\tt.Fatalf(\"Error on Client.Connect(): %v\", wToken.Error())\n\t}\n\n\tselect {\n\tcase msg := <-clsnc:\n\t\tif msg != \"clean!\" {\n\t\t\tt.Fatalf(\"will message did not have correct payload\")\n\t\t}\n\tcase <-time.NewTicker(5 * time.Second).C:\n\t\tt.Fatalf(\"failed to receive publish\")\n\t}\n\n\twsub.Disconnect(250)\n\n\twops.SetCleanSession(true)\n\n\twsub = NewClient(wops)\n\tif wToken := wsub.Connect(); wToken.Wait() && wToken.Error() != nil {\n\t\tt.Fatalf(\"Error on Client.Connect(): %v\", wToken.Error())\n\t}\n\n\twsub.Disconnect(250)\n}\n\nfunc Test_Binary_Will(t *testing.T) {\n\twillmsgc := make(chan []byte, 1)\n\twill := []byte{\n\t\t0xDE,\n\t\t0xAD,\n\t\t0xBE,\n\t\t0xEF,\n\t}\n\n\tsops := NewClientOptions().AddBroker(FVTTCP)\n\tsops.SetClientID(\"will-giver\")\n\tsops.SetBinaryWill(\"/wills\", will, 0, false)\n\tsops.SetConnectionLostHandler(func(client Client, err error) {\n\t})\n\tsops.SetAutoReconnect(false)\n\tc := NewClient(sops).(*client)\n\n\twops := NewClientOptions().AddBroker(FVTTCP)\n\twops.SetClientID(\"will-subscriber\")\n\twops.SetDefaultPublishHandler(func(client Client, msg Message) {\n\t\tfmt.Printf(\"TOPIC: %s\\n\", msg.Topic())\n\t\tfmt.Printf(\"MSG: %v\\n\", msg.Payload())\n\t\twillmsgc <- msg.Payload()\n\t})\n\twops.SetAutoReconnect(false)\n\twsub := NewClient(wops)\n\n\tif wToken := wsub.Connect(); wToken.Wait() && wToken.Error() != nil {\n\t\tt.Fatalf(\"Error on Client.Connect(): %v\", wToken.Error())\n\t}\n\n\tif wsubToken := wsub.Subscribe(\"/wills\", 0, nil); wsubToken.Wait() && wsubToken.Error() != nil {\n\t\tt.Fatalf(\"Error on Client.Subscribe() %v\", wsubToken.Error())\n\t}\n\n\tif token := c.Connect(); token.Wait() && token.Error() != nil {\n\t\tt.Fatalf(\"Error on Client.Connect(): %v\", token.Error())\n\t}\n\n\tc.forceDisconnect()\n\n\tif !bytes.Equal(<-willmsgc, will) {\n\t\tt.Fatalf(\"will message did not have correct payload\")\n\t}\n\n\twsub.Disconnect(250)\n}\n\n/**\n\"[...] a publisher is responsible for determining the maximum QoS a\nmessage can be delivered at, but a subscriber is able to downgrade\nthe QoS to one more suitable for its usage.\nThe QoS of a message is never upgraded.\"\n**/\n\n/***********************************\n * Tests to cover the 9 QoS combos *\n ***********************************/\n\nfunc wait(c chan bool) {\n\tfmt.Println(\"choke is waiting\")\n\t<-c\n}\n\n// Pub 0, Sub 0\n\nfunc Test_p0s0(t *testing.T) {\n\ttopic := \"/test/p0s0\"\n\tchoke := make(chan bool)\n\n\tpops := NewClientOptions()\n\tpops.AddBroker(FVTTCP)\n\tpops.SetClientID(\"p0s0-pub\")\n\tp := NewClient(pops)\n\n\tsops := NewClientOptions()\n\tsops.AddBroker(FVTTCP)\n\tsops.SetClientID(\"p0s0-sub\")\n\tvar f MessageHandler = func(client Client, msg Message) {\n\t\tfmt.Printf(\"TOPIC: %s\\n\", msg.Topic())\n\t\tfmt.Printf(\"MSG: %s\\n\", msg.Payload())\n\t\tchoke <- true\n\t}\n\tsops.SetDefaultPublishHandler(f)\n\n\ts := NewClient(sops)\n\n\tif token := s.Connect(); token.Wait() && token.Error() != nil {\n\t\tt.Fatalf(\"Error on Client.Connect(): %v\", token.Error())\n\t}\n\n\tif token := s.Subscribe(topic, 0, nil); token.Wait() && token.Error() != nil {\n\t\tt.Fatalf(\"Error on Client.Subscribe(): %v\", token.Error())\n\t}\n\n\tif token := p.Connect(); token.Wait() && token.Error() != nil {\n\t\tt.Fatalf(\"Error on Client.Connect(): %v\", token.Error())\n\t}\n\tp.Publish(topic, 0, false, \"p0s0 payload 1\")\n\tp.Publish(topic, 0, false, \"p0s0 payload 2\")\n\n\twait(choke)\n\twait(choke)\n\n\tp.Publish(topic, 0, false, \"p0s0 payload 3\")\n\twait(choke)\n\n\tp.Disconnect(250)\n\ts.Disconnect(250)\n}\n\n// Pub 0, Sub 1\n\nfunc Test_p0s1(t *testing.T) {\n\ttopic := \"/test/p0s1\"\n\tchoke := make(chan bool)\n\n\tpops := NewClientOptions()\n\tpops.AddBroker(FVTTCP)\n\tpops.SetClientID(\"p0s1-pub\")\n\tp := NewClient(pops)\n\n\tsops := NewClientOptions()\n\tsops.AddBroker(FVTTCP)\n\tsops.SetClientID(\"p0s1-sub\")\n\tvar f MessageHandler = func(client Client, msg Message) {\n\t\tfmt.Printf(\"TOPIC: %s\\n\", msg.Topic())\n\t\tfmt.Printf(\"MSG: %s\\n\", msg.Payload())\n\t\tchoke <- true\n\t}\n\tsops.SetDefaultPublishHandler(f)\n\n\ts := NewClient(sops)\n\tif token := s.Connect(); token.Wait() && token.Error() != nil {\n\t\tt.Fatalf(\"Error on Client.Connect(): %v\", token.Error())\n\t}\n\n\tif token := s.Subscribe(topic, 1, nil); token.Wait() && token.Error() != nil {\n\t\tt.Fatalf(\"Error on Client.Subscribe(): %v\", token.Error())\n\t}\n\n\tif token := p.Connect(); token.Wait() && token.Error() != nil {\n\t\tt.Fatalf(\"Error on Client.Connect(): %v\", token.Error())\n\t}\n\tp.Publish(topic, 0, false, \"p0s1 payload 1\")\n\tp.Publish(topic, 0, false, \"p0s1 payload 2\")\n\n\twait(choke)\n\twait(choke)\n\n\tp.Publish(topic, 0, false, \"p0s1 payload 3\")\n\twait(choke)\n\n\tp.Disconnect(250)\n\ts.Disconnect(250)\n}\n\n// Pub 0, Sub 2\n\nfunc Test_p0s2(t *testing.T) {\n\ttopic := \"/test/p0s2\"\n\tchoke := make(chan bool)\n\n\tpops := NewClientOptions()\n\tpops.AddBroker(FVTTCP)\n\tpops.SetClientID(\"p0s2-pub\")\n\tp := NewClient(pops)\n\n\tsops := NewClientOptions()\n\tsops.AddBroker(FVTTCP)\n\tsops.SetClientID(\"p0s2-sub\")\n\tvar f MessageHandler = func(client Client, msg Message) {\n\t\tfmt.Printf(\"TOPIC: %s\\n\", msg.Topic())\n\t\tfmt.Printf(\"MSG: %s\\n\", msg.Payload())\n\t\tchoke <- true\n\t}\n\tsops.SetDefaultPublishHandler(f)\n\n\ts := NewClient(sops)\n\tif token := s.Connect(); token.Wait() && token.Error() != nil {\n\t\tt.Fatalf(\"Error on Client.Connect(): %v\", token.Error())\n\t}\n\n\tif token := s.Subscribe(topic, 2, nil); token.Wait() && token.Error() != nil {\n\t\tt.Fatalf(\"Error on Client.Subscribe(): %v\", token.Error())\n\t}\n\n\tif token := p.Connect(); token.Wait() && token.Error() != nil {\n\t\tt.Fatalf(\"Error on Client.Connect(): %v\", token.Error())\n\t}\n\tp.Publish(topic, 0, false, \"p0s2 payload 1\")\n\tp.Publish(topic, 0, false, \"p0s2 payload 2\")\n\n\twait(choke)\n\twait(choke)\n\n\tp.Publish(topic, 0, false, \"p0s2 payload 3\")\n\n\twait(choke)\n\n\tp.Disconnect(250)\n\ts.Disconnect(250)\n}\n\n// Pub 1, Sub 0\n\nfunc Test_p1s0(t *testing.T) {\n\ttopic := \"/test/p1s0\"\n\tchoke := make(chan bool)\n\n\tpops := NewClientOptions()\n\tpops.AddBroker(FVTTCP)\n\tpops.SetClientID(\"p1s0-pub\")\n\tp := NewClient(pops)\n\n\tsops := NewClientOptions()\n\tsops.AddBroker(FVTTCP)\n\tsops.SetClientID(\"p1s0-sub\")\n\tvar f MessageHandler = func(client Client, msg Message) {\n\t\tfmt.Printf(\"TOPIC: %s\\n\", msg.Topic())\n\t\tfmt.Printf(\"MSG: %s\\n\", msg.Payload())\n\t\tchoke <- true\n\t}\n\tsops.SetDefaultPublishHandler(f)\n\n\ts := NewClient(sops)\n\tif token := s.Connect(); token.Wait() && token.Error() != nil {\n\t\tt.Fatalf(\"Error on Client.Connect(): %v\", token.Error())\n\t}\n\n\tif token := s.Subscribe(topic, 0, nil); token.Wait() && token.Error() != nil {\n\t\tt.Fatalf(\"Error on Client.Subscribe(): %v\", token.Error())\n\t}\n\n\tif token := p.Connect(); token.Wait() && token.Error() != nil {\n\t\tt.Fatalf(\"Error on Client.Connect(): %v\", token.Error())\n\t}\n\tp.Publish(topic, 1, false, \"p1s0 payload 1\")\n\tp.Publish(topic, 1, false, \"p1s0 payload 2\")\n\n\twait(choke)\n\twait(choke)\n\n\tp.Publish(topic, 1, false, \"p1s0 payload 3\")\n\n\twait(choke)\n\n\tp.Disconnect(250)\n\ts.Disconnect(250)\n}\n\n// Pub 1, Sub 1\n\nfunc Test_p1s1(t *testing.T) {\n\ttopic := \"/test/p1s1\"\n\tchoke := make(chan bool)\n\n\tpops := NewClientOptions()\n\tpops.AddBroker(FVTTCP)\n\tpops.SetClientID(\"p1s1-pub\")\n\tp := NewClient(pops)\n\n\tsops := NewClientOptions()\n\tsops.AddBroker(FVTTCP)\n\tsops.SetClientID(\"p1s1-sub\")\n\tvar f MessageHandler = func(client Client, msg Message) {\n\t\tfmt.Printf(\"TOPIC: %s\\n\", msg.Topic())\n\t\tfmt.Printf(\"MSG: %s\\n\", msg.Payload())\n\t\tchoke <- true\n\t}\n\tsops.SetDefaultPublishHandler(f)\n\n\ts := NewClient(sops)\n\tif token := s.Connect(); token.Wait() && token.Error() != nil {\n\t\tt.Fatalf(\"Error on Client.Connect(): %v\", token.Error())\n\t}\n\n\tif token := s.Subscribe(topic, 1, nil); token.Wait() && token.Error() != nil {\n\t\tt.Fatalf(\"Error on Client.Subscribe(): %v\", token.Error())\n\t}\n\n\tif token := p.Connect(); token.Wait() && token.Error() != nil {\n\t\tt.Fatalf(\"Error on Client.Connect(): %v\", token.Error())\n\t}\n\tp.Publish(topic, 1, false, \"p1s1 payload 1\")\n\tp.Publish(topic, 1, false, \"p1s1 payload 2\")\n\n\twait(choke)\n\twait(choke)\n\n\tp.Publish(topic, 1, false, \"p1s1 payload 3\")\n\twait(choke)\n\n\tp.Disconnect(250)\n\ts.Disconnect(250)\n}\n\n// Pub 1, Sub 2\n\nfunc Test_p1s2(t *testing.T) {\n\ttopic := \"/test/p1s2\"\n\tchoke := make(chan bool)\n\n\tpops := NewClientOptions()\n\tpops.AddBroker(FVTTCP)\n\tpops.SetClientID(\"p1s2-pub\")\n\tp := NewClient(pops)\n\n\tsops := NewClientOptions()\n\tsops.AddBroker(FVTTCP)\n\tsops.SetClientID(\"p1s2-sub\")\n\tvar f MessageHandler = func(client Client, msg Message) {\n\t\tfmt.Printf(\"TOPIC: %s\\n\", msg.Topic())\n\t\tfmt.Printf(\"MSG: %s\\n\", msg.Payload())\n\t\tchoke <- true\n\t}\n\tsops.SetDefaultPublishHandler(f)\n\n\ts := NewClient(sops)\n\tif token := s.Connect(); token.Wait() && token.Error() != nil {\n\t\tt.Fatalf(\"Error on Client.Connect(): %v\", token.Error())\n\t}\n\n\tif token := s.Subscribe(topic, 2, nil); token.Wait() && token.Error() != nil {\n\t\tt.Fatalf(\"Error on Client.Subscribe(): %v\", token.Error())\n\t}\n\n\tif token := p.Connect(); token.Wait() && token.Error() != nil {\n\t\tt.Fatalf(\"Error on Client.Connect(): %v\", token.Error())\n\t}\n\tp.Publish(topic, 1, false, \"p1s2 payload 1\")\n\tp.Publish(topic, 1, false, \"p1s2 payload 2\")\n\n\twait(choke)\n\twait(choke)\n\n\tp.Publish(topic, 1, false, \"p1s2 payload 3\")\n\n\twait(choke)\n\n\tp.Disconnect(250)\n\ts.Disconnect(250)\n}\n\n// Pub 2, Sub 0\n\nfunc Test_p2s0(t *testing.T) {\n\ttopic := \"/test/p2s0\"\n\tchoke := make(chan bool)\n\n\tpops := NewClientOptions()\n\tpops.AddBroker(FVTTCP)\n\tpops.SetClientID(\"p2s0-pub\")\n\tp := NewClient(pops)\n\n\tsops := NewClientOptions()\n\tsops.AddBroker(FVTTCP)\n\tsops.SetClientID(\"p2s0-sub\")\n\tvar f MessageHandler = func(client Client, msg Message) {\n\t\tfmt.Printf(\"TOPIC: %s\\n\", msg.Topic())\n\t\tfmt.Printf(\"MSG: %s\\n\", msg.Payload())\n\t\tchoke <- true\n\t}\n\tsops.SetDefaultPublishHandler(f)\n\n\ts := NewClient(sops)\n\tif token := s.Connect(); token.Wait() && token.Error() != nil {\n\t\tt.Fatalf(\"Error on Client.Connect(): %v\", token.Error())\n\t}\n\n\tif token := s.Subscribe(topic, 0, nil); token.Wait() && token.Error() != nil {\n\t\tt.Fatalf(\"Error on Client.Subscribe(): %v\", token.Error())\n\t}\n\n\tif token := p.Connect(); token.Wait() && token.Error() != nil {\n\t\tt.Fatalf(\"Error on Client.Connect(): %v\", token.Error())\n\t}\n\tp.Publish(topic, 2, false, \"p2s0 payload 1\")\n\tp.Publish(topic, 2, false, \"p2s0 payload 2\")\n\twait(choke)\n\twait(choke)\n\n\tp.Publish(topic, 2, false, \"p2s0 payload 3\")\n\twait(choke)\n\n\tp.Disconnect(250)\n\ts.Disconnect(250)\n}\n\n// Pub 2, Sub 1\n\nfunc Test_p2s1(t *testing.T) {\n\ttopic := \"/test/p2s1\"\n\tchoke := make(chan bool)\n\n\tpops := NewClientOptions()\n\tpops.AddBroker(FVTTCP)\n\tpops.SetClientID(\"p2s1-pub\")\n\tp := NewClient(pops)\n\n\tsops := NewClientOptions()\n\tsops.AddBroker(FVTTCP)\n\tsops.SetClientID(\"p2s1-sub\")\n\tvar f MessageHandler = func(client Client, msg Message) {\n\t\tfmt.Printf(\"TOPIC: %s\\n\", msg.Topic())\n\t\tfmt.Printf(\"MSG: %s\\n\", msg.Payload())\n\t\tchoke <- true\n\t}\n\tsops.SetDefaultPublishHandler(f)\n\n\ts := NewClient(sops)\n\tif token := s.Connect(); token.Wait() && token.Error() != nil {\n\t\tt.Fatalf(\"Error on Client.Connect(): %v\", token.Error())\n\t}\n\n\tif token := s.Subscribe(topic, 1, nil); token.Wait() && token.Error() != nil {\n\t\tt.Fatalf(\"Error on Client.Subscribe(): %v\", token.Error())\n\t}\n\n\tif token := p.Connect(); token.Wait() && token.Error() != nil {\n\t\tt.Fatalf(\"Error on Client.Connect(): %v\", token.Error())\n\t}\n\tp.Publish(topic, 2, false, \"p2s1 payload 1\")\n\tp.Publish(topic, 2, false, \"p2s1 payload 2\")\n\n\twait(choke)\n\twait(choke)\n\n\tp.Publish(topic, 2, false, \"p2s1 payload 3\")\n\n\twait(choke)\n\n\tp.Disconnect(250)\n\ts.Disconnect(250)\n}\n\n// Pub 2, Sub 2\n\nfunc Test_p2s2(t *testing.T) {\n\ttopic := \"/test/p2s2\"\n\tchoke := make(chan bool)\n\n\tpops := NewClientOptions()\n\tpops.AddBroker(FVTTCP)\n\tpops.SetClientID(\"p2s2-pub\")\n\tp := NewClient(pops)\n\n\tsops := NewClientOptions()\n\tsops.AddBroker(FVTTCP)\n\tsops.SetClientID(\"p2s2-sub\")\n\tvar f MessageHandler = func(client Client, msg Message) {\n\t\tfmt.Printf(\"TOPIC: %s\\n\", msg.Topic())\n\t\tfmt.Printf(\"MSG: %s\\n\", msg.Payload())\n\t\tchoke <- true\n\t}\n\tsops.SetDefaultPublishHandler(f)\n\n\ts := NewClient(sops)\n\tif token := s.Connect(); token.Wait() && token.Error() != nil {\n\t\tt.Fatalf(\"Error on Client.Connect(): %v\", token.Error())\n\t}\n\n\tif token := s.Subscribe(topic, 2, nil); token.Wait() && token.Error() != nil {\n\t\tt.Fatalf(\"Error on Client.Subscribe(): %v\", token.Error())\n\t}\n\n\tif token := p.Connect(); token.Wait() && token.Error() != nil {\n\t\tt.Fatalf(\"Error on Client.Connect(): %v\", token.Error())\n\t}\n\tp.Publish(topic, 2, false, \"p2s2 payload 1\")\n\tp.Publish(topic, 2, false, \"p2s2 payload 2\")\n\n\twait(choke)\n\twait(choke)\n\n\tp.Publish(topic, 2, false, \"p2s2 payload 3\")\n\n\twait(choke)\n\n\tp.Disconnect(250)\n\ts.Disconnect(250)\n}\n\nfunc Test_PublishMessage(t *testing.T) {\n\ttopic := \"/test/pubmsg\"\n\tchoke := make(chan bool)\n\n\tpops := NewClientOptions()\n\tpops.AddBroker(FVTTCP)\n\tpops.SetClientID(\"pubmsg-pub\")\n\tp := NewClient(pops)\n\n\tsops := NewClientOptions()\n\tsops.AddBroker(FVTTCP)\n\tsops.SetClientID(\"pubmsg-sub\")\n\tvar f MessageHandler = func(client Client, msg Message) {\n\t\tfmt.Printf(\"TOPIC: %s\\n\", msg.Topic())\n\t\tfmt.Printf(\"MSG: %s\\n\", msg.Payload())\n\t\tif string(msg.Payload()) != \"pubmsg payload\" {\n\t\t\tfmt.Println(\"Message payload incorrect\", msg.Payload(), len(\"pubmsg payload\"))\n\t\t\tt.Fatalf(\"Message payload incorrect\")\n\t\t}\n\t\tchoke <- true\n\t}\n\tsops.SetDefaultPublishHandler(f)\n\n\ts := NewClient(sops)\n\tif token := s.Connect(); token.Wait() && token.Error() != nil {\n\t\tt.Fatalf(\"Error on Client.Connect(): %v\", token.Error())\n\t}\n\n\tif token := s.Subscribe(topic, 2, nil); token.Wait() && token.Error() != nil {\n\t\tt.Fatalf(\"Error on Client.Subscribe(): %v\", token.Error())\n\t}\n\n\tif token := p.Connect(); token.Wait() && token.Error() != nil {\n\t\tt.Fatalf(\"Error on Client.Connect(): %v\", token.Error())\n\t}\n\n\ttext := \"pubmsg payload\"\n\tp.Publish(topic, 0, false, text)\n\tp.Publish(topic, 0, false, text)\n\twait(choke)\n\twait(choke)\n\n\tp.Publish(topic, 0, false, text)\n\twait(choke)\n\n\tp.Disconnect(250)\n\ts.Disconnect(250)\n}\n\nfunc Test_PublishEmptyMessage(t *testing.T) {\n\ttopic := \"/test/pubmsgempty\"\n\tchoke := make(chan bool)\n\n\tpops := NewClientOptions()\n\tpops.AddBroker(FVTTCP)\n\tpops.SetClientID(\"pubmsgempty-pub\")\n\tp := NewClient(pops)\n\n\tsops := NewClientOptions()\n\tsops.AddBroker(FVTTCP)\n\tsops.SetClientID(\"pubmsgempty-sub\")\n\tvar f MessageHandler = func(client Client, msg Message) {\n\t\tfmt.Printf(\"TOPIC: %s\\n\", msg.Topic())\n\t\tfmt.Printf(\"MSG: %s\\n\", msg.Payload())\n\t\tif string(msg.Payload()) != \"\" {\n\t\t\tt.Fatalf(\"Message payload incorrect\")\n\t\t}\n\t\tchoke <- true\n\t}\n\tsops.SetDefaultPublishHandler(f)\n\n\ts := NewClient(sops)\n\tif sToken := s.Connect(); sToken.Wait() && sToken.Error() != nil {\n\t\tt.Fatalf(\"Error on Client.Connect(): %v\", sToken.Error())\n\t}\n\n\tif sToken := s.Subscribe(topic, 2, nil); sToken.Wait() && sToken.Error() != nil {\n\t\tt.Fatalf(\"Error on Client.Subscribe(): %v\", sToken.Error())\n\t}\n\n\tif pToken := p.Connect(); pToken.Wait() && pToken.Error() != nil {\n\t\tt.Fatalf(\"Error on Client.Connect(): %v\", pToken.Error())\n\t}\n\n\tp.Publish(topic, 0, false, \"\")\n\tp.Publish(topic, 0, false, \"\")\n\twait(choke)\n\twait(choke)\n\n\tp.Publish(topic, 0, false, \"\")\n\twait(choke)\n\n\tp.Disconnect(250)\n\ts.Disconnect(250)\n}\n\n// Test_CallbackOverrun - When ordermatters=false the callbacks are called within a go routine. It is possible that\n// the connection will drop before the handler completes and this should result in the ACK being dropped silently\n// (leads to a panic in v1.3-v1.3.4)\nfunc Test_CallbackOverrun(t *testing.T) {\n\ttopic := \"/test/callbackoverrun\"\n\thandlerCalled := make(chan bool)\n\thandlerChoke := make(chan bool)\n\thandlerError := make(chan error)\n\n\tpops := NewClientOptions()\n\tpops.AddBroker(FVTTCP)\n\tpops.SetOrderMatters(false) // Not really needed but consistent...\n\tpops.SetClientID(\"callbackoverrun-pub\")\n\tp := NewClient(pops)\n\n\tsops := NewClientOptions()\n\tsops.AddBroker(FVTTCP)\n\tsops.SetOrderMatters(false)\n\tsops.SetClientID(\"callbackoverrun-sub\")\n\tvar f MessageHandler = func(client Client, msg Message) {\n\t\thandlerCalled <- true\n\t\t<-handlerChoke // Wait until connection has been closed\n\t\tif string(msg.Payload()) != \"test message\" {\n\t\t\thandlerError <- fmt.Errorf(\"Message payload incorrect\")\n\t\t} else {\n\t\t\thandlerError <- nil // Allow main test to proceed (should not raise error in go routine)\n\t\t}\n\t}\n\n\ts := NewClient(sops).(*client)\n\tif sToken := s.Connect(); sToken.Wait() && sToken.Error() != nil {\n\t\tt.Fatalf(\"Error on Client.Connect(): %v\", sToken.Error())\n\t}\n\n\tif sToken := s.Subscribe(topic, 1, f); sToken.Wait() && sToken.Error() != nil {\n\t\tt.Fatalf(\"Error on Client.Subscribe(): %v\", sToken.Error())\n\t}\n\n\tif pToken := p.Connect(); pToken.Wait() && pToken.Error() != nil {\n\t\tt.Fatalf(\"Error on Client.Connect(): %v\", pToken.Error())\n\t}\n\n\tp.Publish(topic, 1, false, \"test message\")\n\twait(handlerCalled)  // Wait until the handler has been called\n\ts.Disconnect(250)    // Ensure the connection is dropped\n\t<-s.commsStopped     // Double check...\n\thandlerChoke <- true // Allow handler to proceed\n\n\terr := <-handlerError\n\tif err != nil {\n\t\tt.Fatalf(err.Error())\n\t}\n\n\ttime.Sleep(time.Microsecond) // Allow a little time in case the handler returning after connection dropped causes an issue (panic)\n\tfmt.Println(\"reconnecting\")\n\t// Now attempt to reconnect (checking for blockages)\n\tif sToken := s.Connect(); sToken.Wait() && sToken.Error() != nil {\n\t\tt.Fatalf(\"Error on Client.Connect(): %v\", sToken.Error())\n\t}\n\n\ts.Disconnect(250)\n\tp.Disconnect(250)\n}\n\n// func Test_Cleanstore(t *testing.T) {\n// \tstore := \"/tmp/fvt/cleanstore\"\n// \ttopic := \"/test/cleanstore\"\n\n// \tpops := NewClientOptions()\n// \tpops.AddBroker(FVTTCP)\n// \tpops.SetClientID(\"cleanstore-pub\")\n// \tpops.SetStore(NewFileStore(store + \"/p\"))\n// \tp := NewClient(pops)\n\n// \tvar s *Client\n// \tsops := NewClientOptions()\n// \tsops.AddBroker(FVTTCP)\n// \tsops.SetClientID(\"cleanstore-sub\")\n// \tsops.SetCleanSession(false)\n// \tsops.SetStore(NewFileStore(store + \"/s\"))\n// \tvar f MessageHandler = func(client Client, msg Message) {\n// \t\tfmt.Printf(\"TOPIC: %s\\n\", msg.Topic())\n// \t\tfmt.Printf(\"MSG: %s\\n\", msg.Payload())\n// \t\t// Close the connection after receiving\n// \t\t// the first message so that hopefully\n// \t\t// there is something in the store to be\n// \t\t// cleaned.\n// \t\ts.ForceDisconnect()\n// \t}\n// \tsops.SetDefaultPublishHandler(f)\n\n// \ts = NewClient(sops)\n// \tsToken := s.Connect()\n// \tif sToken.Wait() && sToken.Error() != nil {\n// \t\tt.Fatalf(\"Error on Client.Connect(): %v\", sToken.Error())\n// \t}\n\n// \tsToken = s.Subscribe(topic, 2, nil)\n// \tif sToken.Wait() && sToken.Error() != nil {\n// \t\tt.Fatalf(\"Error on Client.Subscribe(): %v\", sToken.Error())\n// \t}\n\n// \tpToken := p.Connect()\n// \tif pToken.Wait() && pToken.Error() != nil {\n// \t\tt.Fatalf(\"Error on Client.Connect(): %v\", pToken.Error())\n// \t}\n\n// \ttext := \"test message\"\n// \tp.Publish(topic, 0, false, text)\n// \tp.Publish(topic, 0, false, text)\n// \tp.Publish(topic, 0, false, text)\n\n// \tp.Disconnect(250)\n\n// \ts2ops := NewClientOptions()\n// \ts2ops.AddBroker(FVTTCP)\n// \ts2ops.SetClientID(\"cleanstore-sub\")\n// \ts2ops.SetCleanSession(true)\n// \ts2ops.SetStore(NewFileStore(store + \"/s\"))\n// \ts2ops.SetDefaultPublishHandler(f)\n\n// \ts2 := NewClient(s2ops)\n// \tsToken = s2.Connect()\n// \tif sToken.Wait() && sToken.Error() != nil {\n// \t\tt.Fatalf(\"Error on Client.Connect(): %v\", sToken.Error())\n// \t}\n\n// \t// at this point existing state should be cleared...\n// \t// how to check?\n// }\n\nfunc Test_MultipleURLs(t *testing.T) {\n\tops := NewClientOptions()\n\tops.AddBroker(\"tcp://127.0.0.1:10000\")\n\tops.AddBroker(FVTTCP)\n\tops.SetClientID(\"MultiURL\")\n\n\tc := NewClient(ops)\n\n\tif token := c.Connect(); token.Wait() && token.Error() != nil {\n\t\tt.Fatalf(\"Error on Client.Connect(): %v\", token.Error())\n\t}\n\n\tif pToken := c.Publish(\"/test/MultiURL\", 0, false, \"Publish qo0\"); pToken.Wait() && pToken.Error() != nil {\n\t\tt.Fatalf(\"Error on Client.Publish(): %v\", pToken.Error())\n\t}\n\n\tc.Disconnect(250)\n}\n\n// A test to make sure ping mechanism is working\nfunc Test_ping1_idle5(t *testing.T) {\n\tops := NewClientOptions()\n\tops.AddBroker(FVTTCP)\n\tops.SetClientID(\"p3i10\")\n\tops.SetConnectionLostHandler(func(c Client, err error) {\n\t\tt.Fatalf(\"Connection-lost handler was called: %s\", err)\n\t})\n\tops.SetKeepAlive(4 * time.Second)\n\n\tc := NewClient(ops)\n\n\tif token := c.Connect(); token.Wait() && token.Error() != nil {\n\t\tt.Fatalf(\"Error on Client.Connect(): %v\", token.Error())\n\t}\n\ttime.Sleep(8 * time.Second)\n\tc.Disconnect(250)\n}\n\nfunc Test_autoreconnect(t *testing.T) {\n\tops := NewClientOptions()\n\tops.AddBroker(FVTTCP)\n\tops.SetClientID(\"auto_reconnect\")\n\tops.SetAutoReconnect(true)\n\tops.SetOnConnectHandler(func(c Client) {\n\t\tt.Log(\"Connected\")\n\t})\n\tops.SetKeepAlive(2 * time.Second)\n\n\tc := NewClient(ops)\n\n\tif token := c.Connect(); token.Wait() && token.Error() != nil {\n\t\tt.Fatalf(\"Error on Client.Connect(): %v\", token.Error())\n\t}\n\n\ttime.Sleep(5 * time.Second)\n\n\tfmt.Println(\"Breaking connection\")\n\tc.(*client).internalConnLost(fmt.Errorf(\"autoreconnect test\"))\n\n\ttime.Sleep(5 * time.Second)\n\tif !c.IsConnected() {\n\t\tt.Fail()\n\t}\n\n\tc.Disconnect(250)\n}\n\nfunc Test_cleanUpMids(t *testing.T) {\n\tops := NewClientOptions()\n\tops.AddBroker(FVTTCP)\n\tops.SetClientID(\"auto_reconnect\")\n\tops.SetCleanSession(true)\n\tops.SetAutoReconnect(true)\n\tops.SetKeepAlive(10 * time.Second)\n\n\tc := NewClient(ops)\n\n\tif token := c.Connect(); token.Wait() && token.Error() != nil {\n\t\tt.Fatalf(\"Error on Client.Connect(): %v\", token.Error())\n\t}\n\n\ttoken := c.Publish(\"/test/cleanUP\", 2, false, \"cleanup test\")\n\tc.(*client).messageIds.mu.Lock()\n\tfmt.Println(\"Breaking connection\", len(c.(*client).messageIds.index))\n\tif len(c.(*client).messageIds.index) == 0 {\n\t\tt.Fatalf(\"Should be a token in the messageIDs, none found\")\n\t}\n\tc.(*client).messageIds.mu.Unlock()\n\tc.(*client).internalConnLost(fmt.Errorf(\"cleanup test\"))\n\n\ttime.Sleep(1 * time.Second)\n\tif !c.IsConnected() {\n\t\tt.Fail()\n\t}\n\n\tc.(*client).messageIds.mu.Lock()\n\tif len(c.(*client).messageIds.index) > 0 {\n\t\tt.Fatalf(\"Should have cleaned up messageIDs, have %d left\", len(c.(*client).messageIds.index))\n\t}\n\tc.(*client).messageIds.mu.Unlock()\n\n\t// This test used to check that token.Error() was not nil. However this is not something that can\n\t// be done reliably - it is likely to work with a remote broker but less so with a local one.\n\t// This is because:\n\t// - If the publish fails in net.go while transmitting then an error will be generated\n\t// - If the transmit succeeds (regardless of whether the handshake completes then no error is generated)\n\t// If the intention is that an error should always be returned if the publish is incomplete upon disconnedt then\n\t// internalConnLost needs to be altered (if c.options.CleanSession && !c.options.AutoReconnect)\n\t// if token.Error() == nil {\n\t// t.Fatal(\"token should have received an error on connection loss\")\n\t// }\n\tfmt.Println(token.Error())\n\n\tc.Disconnect(250)\n}\n\n// Test that cleanup happens properly on explicit Disconnect()\nfunc Test_cleanUpMids_2(t *testing.T) {\n\tops := NewClientOptions()\n\tops.AddBroker(FVTTCP)\n\tops.SetClientID(\"auto_reconnect\")\n\tops.SetCleanSession(true)\n\tops.SetAutoReconnect(true)\n\tops.SetKeepAlive(10 * time.Second)\n\n\tc := NewClient(ops)\n\tcl := c.(*client)\n\n\tif token := c.Connect(); token.Wait() && token.Error() != nil {\n\t\tt.Fatalf(\"Error on Client.Connect(): %v\", token.Error())\n\t}\n\n\ttoken := c.Publish(\"/test/cleanUP\", 2, false, \"cleanup test 2\")\n\tcl.messageIds.mu.Lock()\n\tmq := len(c.(*client).messageIds.index)\n\tcl.messageIds.mu.Unlock()\n\tif mq == 0 {\n\t\tt.Fatalf(\"Should be a token in the messageIDs, none found\")\n\t}\n\t// fmt.Println(\"Disconnecting\", len(cl.messageIds.index))\n\tc.Disconnect(0)\n\n\tfmt.Println(\"Wait on Token\")\n\t// We should be able to wait on this token without any issue\n\ttoken.Wait()\n\n\tcl.messageIds.mu.Lock()\n\tmq = len(c.(*client).messageIds.index)\n\tcl.messageIds.mu.Unlock()\n\tif mq > 0 {\n\t\tt.Fatalf(\"Should have cleaned up messageIDs, have %d left\", len(c.(*client).messageIds.index))\n\t}\n\tif token.Error() == nil {\n\t\tt.Fatal(\"token should have received an error on connection loss\")\n\t}\n\t// fmt.Println(token.Error())\n}\n\nfunc Test_ConnectRetry(t *testing.T) {\n\t// Connect for publish - initially use invalid server\n\tcops := NewClientOptions().AddBroker(\"256.256.256.256\").SetClientID(\"cr-pub\").\n\t\tSetConnectRetry(true).SetConnectRetryInterval(time.Second / 2)\n\tc := NewClient(cops).(*client)\n\tconnectToken := c.Connect()\n\n\ttime.Sleep(time.Second) // Wait a second to ensure we are past SetConnectRetryInterval\n\tif connectToken.Error() != nil {\n\t\tt.Fatalf(\"Connect returned error (should be retrying) (%v)\", connectToken.Error())\n\t}\n\tc.optionsMu.Lock() // Protect c.options.Servers so that servers can be added in test cases\n\tc.options.AddBroker(FVTTCP)\n\tc.optionsMu.Unlock()\n\tif connectToken.Wait() && connectToken.Error() != nil {\n\t\tt.Fatalf(\"Error connecting after valid broker added: %v\", connectToken.Error())\n\t}\n\tc.Disconnect(250)\n}\n\nfunc Test_ConnectRetryPublish(t *testing.T) {\n\ttopic := \"/test/connectRetry\"\n\tpayload := \"sample Payload\"\n\tchoke := make(chan bool)\n\n\t// subscribe to topic and wait for expected message (only received after connection successful)\n\tsops := NewClientOptions().AddBroker(FVTTCP).SetClientID(\"crp-sub\")\n\tvar f MessageHandler = func(client Client, msg Message) {\n\t\tif msg.Topic() != topic || string(msg.Payload()) != payload {\n\t\t\tt.Fatalf(\"Received unexpected message: %v, %v\", msg.Topic(), msg.Payload())\n\t\t}\n\t\tchoke <- true\n\t}\n\tsops.SetDefaultPublishHandler(f)\n\n\ts := NewClient(sops)\n\tif token := s.Connect(); token.Wait() && token.Error() != nil {\n\t\tt.Fatalf(\"Error on Client.Connect(): %v\", token.Error())\n\t}\n\n\tif token := s.Subscribe(topic, 0, nil); token.Wait() && token.Error() != nil {\n\t\tt.Fatalf(\"Error on Client.Subscribe(): %v\", token.Error())\n\t}\n\n\t// Connect for publish - initially use invalid server\n\tmemStore := NewMemoryStore()\n\tmemStore.Open()\n\tpops := NewClientOptions().AddBroker(\"256.256.256.256\").SetClientID(\"crp-pub\").\n\t\tSetStore(memStore).SetConnectRetry(true).SetConnectRetryInterval(time.Second / 2)\n\tp := NewClient(pops).(*client)\n\tconnectToken := p.Connect()\n\tp.Publish(topic, 1, false, payload)\n\t// Check publish packet in the memorystore\n\tids := memStore.All()\n\tif len(ids) == 0 {\n\t\tt.Fatalf(\"Expected published message to be in store\")\n\t} else if len(ids) != 1 {\n\t\tt.Fatalf(\"Expected 1 message to be in store\")\n\t}\n\tpacket := memStore.Get(ids[0])\n\tif packet == nil {\n\t\tt.Fatal(\"Failed to retrieve packet from store\")\n\t}\n\tpp, ok := packet.(*packets.PublishPacket)\n\tif !ok {\n\t\tt.Fatalf(\"Message in store not of the expected type (%T)\", packet)\n\t}\n\tif pp.TopicName != topic || string(pp.Payload) != payload {\n\t\tt.Fatalf(\"Stored message Packet contents not as expected (%v, %v)\", pp.TopicName, pp.Payload)\n\t}\n\ttime.Sleep(time.Second) // Wait a second to ensure we are past SetConnectRetryInterval\n\tif connectToken.Error() != nil {\n\t\tt.Fatalf(\"Connect returned error (should be retrying) (%v)\", connectToken.Error())\n\t}\n\n\t// disconnecting closes the store (both in disconnect and in Connect which runs as a goRoutine).\n\t// As such we duplicate the store\n\tmemStore2 := NewMemoryStore()\n\tmemStore2.Open()\n\tmemStore2.Put(ids[0], packet)\n\n\t// disconnect and then reconnect with correct server\n\tp.Disconnect(250)\n\n\tpops = NewClientOptions().AddBroker(FVTTCP).SetClientID(\"crp-pub\").SetCleanSession(false).\n\t\tSetStore(memStore2).SetConnectRetry(true).SetConnectRetryInterval(time.Second / 2)\n\tp = NewClient(pops).(*client)\n\tif token := p.Connect(); token.Wait() && token.Error() != nil {\n\t\tt.Fatalf(\"Error on valid Publish.Connect(): %v\", token.Error())\n\t}\n\n\tif connectToken.Wait() && connectToken.Error() == nil {\n\t\tt.Fatalf(\"Expected connection error - got nil\")\n\t}\n\twait(choke)\n\n\tp.Disconnect(250)\n\ts.Disconnect(250)\n\tmemStore.Close()\n}\n\nfunc Test_ResumeSubs(t *testing.T) {\n\ttopic := \"/test/ResumeSubs\"\n\tvar qos byte = 1\n\n\t// subscribe to topic before establishing a connection, and publish a message after the publish client has connected successfully\n\tsubMemStore := NewMemoryStore()\n\tsubMemStore.Open()\n\tsops := NewClientOptions().AddBroker(\"256.256.256.256\").SetClientID(\"resumesubs-sub\").SetConnectRetry(true).\n\t\tSetConnectRetryInterval(time.Second / 2).SetResumeSubs(true).SetStore(subMemStore)\n\n\ts := NewClient(sops)\n\tsConnToken := s.Connect()\n\tsubToken := s.Subscribe(topic, qos, nil) // Message should be stored before this returns\n\n\t// Verify subscribe packet exists in the memory store\n\tids := subMemStore.All()\n\tif len(ids) == 0 {\n\t\tt.Fatalf(\"Expected subscribe packet to be in store\")\n\t} else if len(ids) != 1 {\n\t\tt.Fatalf(\"Expected 1 packet to be in store\")\n\t}\n\tpacket := subMemStore.Get(ids[0])\n\tif packet == nil {\n\t\tt.Fatal(\"Failed to retrieve packet from store\")\n\t}\n\tsp, ok := packet.(*packets.SubscribePacket)\n\tif !ok {\n\t\tt.Fatalf(\"Packet in store not of the expected type (%T)\", packet)\n\t}\n\tif len(sp.Topics) != 1 || sp.Topics[0] != topic || len(sp.Qoss) != 1 || sp.Qoss[0] != qos {\n\t\tt.Fatalf(\"Stored Subscribe Packet contents not as expected (%v, %v)\", sp.Topics, sp.Qoss)\n\t}\n\n\ttime.Sleep(time.Second) // Wait a second to ensure we are past SetConnectRetryInterval\n\tif sConnToken.Error() != nil {\n\t\tt.Fatalf(\"Connect returned error (should be retrying) (%v)\", sConnToken.Error())\n\t}\n\tif subToken.Error() != nil {\n\t\tt.Fatalf(\"Subscribe returned error (should be persisted) (%v)\", sConnToken.Error())\n\t}\n\n\t// test that the stored subscribe packet gets sent to the broker after connecting\n\tsubMemStore2 := NewMemoryStore()\n\tsubMemStore2.Open()\n\tsubMemStore2.Put(ids[0], packet)\n\n\ts.Disconnect(250)\n\n\t// Connect to broker and test that subscription was resumed\n\tsops = NewClientOptions().AddBroker(FVTTCP).SetClientID(\"resumesubs-sub\").\n\t\tSetStore(subMemStore2).SetResumeSubs(true).SetCleanSession(false).SetConnectRetry(true).\n\t\tSetConnectRetryInterval(time.Second / 2)\n\n\tmsgChan := make(chan Message)\n\tvar f MessageHandler = func(client Client, msg Message) {\n\t\tmsgChan <- msg\n\t}\n\tsops.SetDefaultPublishHandler(f)\n\ts = NewClient(sops).(*client)\n\tif sConnToken = s.Connect(); sConnToken.Wait() && sConnToken.Error() != nil {\n\t\tt.Fatalf(\"Error on valid subscribe Connect(): %v\", sConnToken.Error())\n\t}\n\n\t// publish message to subscribed topic to verify subscription\n\tpops := NewClientOptions().AddBroker(FVTTCP).SetClientID(\"resumesubs-pub\").SetCleanSession(true).\n\t\tSetConnectRetry(true).SetConnectRetryInterval(time.Second / 2)\n\tp := NewClient(pops).(*client)\n\tif pConnToken := p.Connect(); pConnToken.Wait() && pConnToken.Error() != nil {\n\t\tt.Fatalf(\"Error on valid Publish.Connect(): %v\", pConnToken.Error())\n\t}\n\n\tpayload := \"sample Payload\"\n\tif pubToken := p.Publish(topic, 1, false, payload); pubToken.Wait() && pubToken.Error() != nil {\n\t\tt.Fatalf(\"Error on valid Client.Publish(): %v\", pubToken.Error())\n\t}\n\n\ttimer := time.NewTicker(time.Second) // We wait a second to ensure message is only received once\n\tvar gotMsg bool\nresultLoop:\n\tfor {\n\t\tselect {\n\t\tcase msg := <-msgChan:\n\t\t\tif msg.Topic() == topic && string(msg.Payload()) == payload {\n\t\t\t\tif gotMsg {\n\t\t\t\t\tt.Fatalf(\"Received message 1 twice\")\n\t\t\t\t}\n\t\t\t\tgotMsg = true\n\t\t\t} else {\n\t\t\t\tt.Fatalf(\"Received unexpected message: %v, %v\", msg.Topic(), msg.Payload())\n\t\t\t}\n\t\tcase <-timer.C:\n\t\t\tbreak resultLoop\n\t\t}\n\n\t}\n\tif !gotMsg {\n\t\tt.Error(\"did not receive message 1\")\n\t}\n\n\ts.Disconnect(250)\n\tp.Disconnect(250)\n}\n\nfunc Test_ResumeSubsWithReconnect(t *testing.T) {\n\ttopic := \"/test/ResumeSubs\"\n\tvar qos byte = 1\n\n\t// subscribe to topic before establishing a connection, and publish a message after the publish client has connected successfully\n\tops := NewClientOptions().SetClientID(\"Start\").AddBroker(FVTTCP).SetConnectRetry(true).SetConnectRetryInterval(time.Second / 2).\n\t\tSetResumeSubs(true).SetCleanSession(false)\n\tc := NewClient(ops)\n\tsConnToken := c.Connect()\n\tsConnToken.Wait()\n\tif sConnToken.Error() != nil {\n\t\tt.Fatalf(\"Connect returned error (%v)\", sConnToken.Error())\n\t}\n\n\t// Send subscription request and then immediately force disconnect (hope it will happen before sub sent)\n\tsubToken := newToken(packets.Subscribe).(*SubscribeToken)\n\tsub := packets.NewControlPacket(packets.Subscribe).(*packets.SubscribePacket)\n\tsub.Topics = append(sub.Topics, topic)\n\tsub.Qoss = append(sub.Qoss, qos)\n\tsubToken.subs = append(subToken.subs, topic)\n\n\tif sub.MessageID == 0 {\n\t\tsub.MessageID = c.(*client).getID(subToken)\n\t\tsubToken.messageID = sub.MessageID\n\t}\n\tDEBUG.Println(CLI, sub.String())\n\n\tpersistOutbound(c.(*client).persist, sub)\n\t// subToken := c.Subscribe(topic, qos, nil)\n\tc.(*client).internalConnLost(fmt.Errorf(\"reconnection subscription test\"))\n\n\t// As reconnect is enabled the client should automatically reconnect\n\tsubDone := make(chan bool)\n\tgo func(t *testing.T) {\n\t\tsubToken.Wait()\n\t\tif err := subToken.Error(); err != nil {\n\t\t\tt.Errorf(\"Connect returned error (should be retrying) (%v)\", err)\n\t\t}\n\t\tclose(subDone)\n\t}(t)\n\t// Wait for done or timeout\n\tselect {\n\tcase <-subDone:\n\tcase <-time.After(4 * time.Second):\n\t\tt.Fatalf(\"Timed out waiting for subToken to complete\")\n\t}\n\n\tc.Disconnect(250)\n}\n\n// Issue 509 - occasional deadlock when connections are lost unexpectedly\n// This was quite a nasty deadlock which occurred in very rare circumstances; I could not come up with a reliable way of\n// replicating this but the below would cause it to happen fairly consistently (when the test was run a decent number\n// of times). Following the fix it ran 10,000 times without issue.\n//\n//\tgo test -count 10000 -run DisconnectWhileProcessingIncomingPublish\nfunc Test_DisconnectWhileProcessingIncomingPublish(t *testing.T) {\n\ttopic := \"/test/DisconnectWhileProcessingIncomingPublish\"\n\n\tpops := NewClientOptions()\n\tpops.AddBroker(FVTTCP)\n\t// pops.SetOrderMatters(false) // Not really needed but consistent...\n\tpops.SetClientID(\"dwpip-pub\")\n\tp := NewClient(pops)\n\n\tsops := NewClientOptions()\n\tsops.AddBroker(FVTTCP)\n\tsops.SetAutoReconnect(false)                 // We don't want the connection to be re-established\n\tsops.SetWriteTimeout(500 * time.Millisecond) // We will be sending a lot of publish messages and want go routines to clear...\n\t// sops.SetOrderMatters(false)\n\tsops.SetClientID(\"dwpip-sub\")\n\t// We need to know when the subscriber has lost its connection (this indicates that the deadlock has not occurred)\n\tsDisconnected := make(chan struct{})\n\tsops.SetConnectionLostHandler(func(Client, error) { close(sDisconnected) })\n\n\tmsgReceived := make(chan struct{})\n\tvar oneMsgReceived sync.Once\n\tvar f MessageHandler = func(client Client, msg Message) {\n\t\t// No need to do anything when message received (just want ACK sent ASAP)\n\t\toneMsgReceived.Do(func() { close(msgReceived) })\n\t}\n\n\ts := NewClient(sops).(*client) // s = subscriber\n\tif sToken := s.Connect(); sToken.Wait() && sToken.Error() != nil {\n\t\tt.Fatalf(\"Error on subscriber Client.Connect(): %v\", sToken.Error())\n\t}\n\n\tif sToken := s.Subscribe(topic, 1, f); sToken.Wait() && sToken.Error() != nil {\n\t\tt.Fatalf(\"Error on subscriber Client.Subscribe(): %v\", sToken.Error())\n\t}\n\n\t// Use a go routine to swamp the broker with messages\n\tif pToken := p.Connect(); pToken.Wait() && pToken.Error() != nil { // p = publisher\n\t\tt.Fatalf(\"Error on publisher Client.Connect(): %v\", pToken.Error())\n\t}\n\t// We will hammer both the publisher and subscriber with messages\n\tctx, cancel := context.WithCancel(context.Background())\n\tpubDone := make(chan struct{})\n\tgo func() {\n\t\tdefer close(pubDone)\n\t\ti := 0\n\t\tfor {\n\t\t\tp.Publish(topic, 1, false, fmt.Sprintf(\"test message: %d\", i))\n\t\t\t// After the connection goes down s.Publish will start blocking (this is not ideal but fixing it's a problem for another time)\n\t\t\tgo func(i int) { s.Publish(topic+\"IGNORE\", 1, false, fmt.Sprintf(\"test message: %d\", i)) }(i)\n\t\t\ti++\n\t\t\tif ctx.Err() != nil {\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t}()\n\n\t// Wait until we have received a message (ensuring that the stream of messages has started)\n\tdelay := time.NewTimer(time.Second) // Be careful with timers as this will be run in a tight loop!\n\tselect {\n\tcase <-msgReceived: // All good\n\t\tif !delay.Stop() { // Cleanly close timer as this may be run in a tight loop!\n\t\t\t<-delay.C\n\t\t}\n\tcase <-delay.C:\n\t\tt.Errorf(\"no messages received\")\n\t}\n\n\t// We need the connection to drop; unfortunately using any internal method (`s.conn.Close()` etc) will hide the\n\t// behaviour because any calls to Read/Write will return immediately. So we just ask the broker to disconnect..\n\tdm := packets.NewControlPacket(packets.Disconnect).(*packets.DisconnectPacket)\n\terr := dm.Write(s.conn)\n\tif err != nil {\n\t\tt.Fatalf(\"error sending disconnect packet: %s\", err)\n\t}\n\n\t// Lets give the library up to a second to shutdown (indicated by the status changing)\n\tdelay = time.NewTimer(time.Second) // Be careful with timers as this will be run in a tight loop!\n\tselect {\n\tcase <-sDisconnected: // All good\n\t\tif !delay.Stop() {\n\t\t\t<-delay.C\n\t\t}\n\tcase <-delay.C:\n\t\tcancel()                     // no point leaving publisher running\n\t\ttime.Sleep(10 * time.Second) // Allow publish calls to timeout (otherwise there will be tons of go routines running!)\n\t\tbuf := make([]byte, 1<<20)\n\t\tstacklen := runtime.Stack(buf, true)\n\t\tt.Fatalf(\"connection was not lost as expected - probable deadlock. Stacktrace follows: %s\", buf[:stacklen])\n\t}\n\n\tcancel() // no point leaving publisher running\n\n\tdelay = time.NewTimer(time.Second) // Be careful with timers as this will be run in a tight loop!\n\tselect {\n\tcase <-pubDone:\n\t\tif !delay.Stop() {\n\t\t\t<-delay.C\n\t\t}\n\tcase <-delay.C:\n\t\tt.Errorf(\"pubdone not closed within two seconds (probably due to load on system but may be an issue)\")\n\t}\n\tp.Disconnect(250) // Close publisher\n}\n\n// Test_ResumeSubsMaxInflight - Check the MaxResumePubInFlight option.\n// This is difficult to test without control of the broker (because we will be communicating via the broker not\n// directly. However, due to the way resume works when there is no limit to inflight messages message ordering is not\n// guaranteed. However, with SetMaxResumePubInFlight(1) it is guaranteed so we use that to test.\n// On my PC (using mosquitto under docker) running this without SetMaxResumePubInFlight(1) will fail with 1000 messages\n// (generally passes if only 100 are sent). With the option set it always passes.\nfunc Test_ResumeSubsMaxInflight(t *testing.T) {\n\ttopic := \"/test/ResumeSubsMaxInflight\"\n\tvar qos byte = 1\n\n\t// When a connection is made with messages in the store normally it would be expected that many messages will be\n\t// transmitted simultaneously; using MaxResumePubInFlight we can limit this to 1.\n\t// subscribe to topic before establishing a connection, and publish a message after the publish client has connected successfully\n\tsops := NewClientOptions().SetClientID(\"rsmif-Sub\").AddBroker(FVTTCP).SetOrderMatters(true)\n\ts := NewClient(sops) // s = subscriber\n\tif sToken := s.Connect(); sToken.Wait() && sToken.Error() != nil {\n\t\tt.Fatalf(\"Error on subscriber Client.Connect(): %v\", sToken.Error())\n\t}\n\n\tincommingMsg := make(chan int, 1000)\n\tvar f MessageHandler = func(client Client, msg Message) {\n\t\tnum, _ := strconv.Atoi(string(msg.Payload()))\n\t\tincommingMsg <- num\n\t}\n\n\tif sToken := s.Subscribe(topic, qos, f); sToken.Wait() && sToken.Error() != nil {\n\t\tt.Fatalf(\"Error on subscriber Client.Subscribe(): %v\", sToken.Error())\n\t}\n\n\t// Now we preload an ordered memory store with 100 messages and connect...\n\tmemStore := NewOrderedMemoryStore()\n\tmemStore.Open()\n\n\tfor i := 0; i < 1000; i++ {\n\t\tpub := packets.NewControlPacket(packets.Publish).(*packets.PublishPacket)\n\t\tpub.Qos = qos\n\t\tpub.TopicName = topic\n\t\tpub.Payload = []byte(strconv.Itoa(i))\n\t\tpub.MessageID = uint16(i + 1)\n\t\tmemStore.Put(outboundKeyFromMID(pub.Details().MessageID), pub)\n\t\ttime.Sleep(time.Nanosecond)\n\t}\n\n\tpops := NewClientOptions().AddBroker(FVTTCP).SetClientID(\"rsmif-Pub\").SetOrderMatters(false).\n\t\tSetCleanSession(false).SetStore(memStore).SetMaxResumePubInFlight(1)\n\tp := NewClient(pops)\n\tif pToken := p.Connect(); pToken.Wait() && pToken.Error() != nil { // Note: messages will be received before this completes\n\t\tt.Fatalf(\"Error on publisher Client.Connect(): %v\", pToken.Error())\n\t}\n\t// We should receive 100 * 1's\n\ttimeOut := time.NewTimer(30 * time.Second)\n\tdefer timeOut.Stop()\ngetLoop:\n\tfor i := 0; i < 1000; i++ {\n\t\tselect {\n\t\tcase <-timeOut.C:\n\t\t\tt.Errorf(\"timed out waiting for messages (after receiving %d)\", i)\n\t\t\tbreak getLoop\n\t\tcase s := <-incommingMsg:\n\t\t\tif s != i {\n\t\t\t\tt.Errorf(\"received message out of order (expected %d, got %d)\", i, s)\n\t\t\t\tbreak getLoop\n\t\t\t}\n\t\t\tcontinue\n\t\t}\n\t}\n\n\tp.Disconnect(250)\n\ts.Disconnect(250)\n}\n"
        },
        {
          "name": "fvt_store_test.go",
          "type": "blob",
          "size": 11.0341796875,
          "content": "/*\n * Copyright (c) 2021 IBM Corp and others.\n *\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v2.0\n * and Eclipse Distribution License v1.0 which accompany this distribution.\n *\n * The Eclipse Public License is available at\n *    https://www.eclipse.org/legal/epl-2.0/\n * and the Eclipse Distribution License is available at\n *   http://www.eclipse.org/org/documents/edl-v10.php.\n *\n * Contributors:\n *    Seth Hoenig\n *    Allan Stockdill-Mander\n *    Mike Robertson\n */\n\npackage mqtt\n\nimport (\n\t\"bytes\"\n\t\"io/ioutil\"\n\t\"os\"\n\t\"testing\"\n\n\t\"github.com/eclipse/paho.mqtt.golang/packets\"\n)\n\n/**********************************************\n **** A mock store implementation for test ****\n **********************************************/\n\ntype TestStore struct {\n\tmput []uint16\n\tmget []uint16\n\tmdel []uint16\n}\n\nfunc (ts *TestStore) Open() {\n}\n\nfunc (ts *TestStore) Close() {\n}\n\nfunc (ts *TestStore) Put(key string, m packets.ControlPacket) {\n\tts.mput = append(ts.mput, m.Details().MessageID)\n}\n\nfunc (ts *TestStore) Get(key string) packets.ControlPacket {\n\tmid := mIDFromKey(key)\n\tts.mget = append(ts.mget, mid)\n\treturn nil\n}\n\nfunc (ts *TestStore) All() []string {\n\treturn nil\n}\n\nfunc (ts *TestStore) Del(key string) {\n\tmid := mIDFromKey(key)\n\tts.mdel = append(ts.mdel, mid)\n}\n\nfunc (ts *TestStore) Reset() {\n}\n\n/*******************\n **** FileStore ****\n *******************/\n\nfunc Test_NewFileStore(t *testing.T) {\n\tstoredir := \"/tmp/TestStore/_new\"\n\tf := NewFileStore(storedir)\n\tif f.opened {\n\t\tt.Fatalf(\"filestore was opened without opening it\")\n\t}\n\tif f.directory != storedir {\n\t\tt.Fatalf(\"filestore directory is wrong\")\n\t}\n\t// storedir might exist or might not, just like with a real client\n\t// the point is, we don't care, we just want it to exist after it is\n\t// opened\n}\n\nfunc Test_FileStore_Open(t *testing.T) {\n\tstoredir := \"/tmp/TestStore/_open\"\n\n\tf := NewFileStore(storedir)\n\tf.Open()\n\tif !f.opened {\n\t\tt.Fatalf(\"filestore was not set open\")\n\t}\n\tif f.directory != storedir {\n\t\tt.Fatalf(\"filestore directory is wrong\")\n\t}\n\tif !exists(storedir) {\n\t\tt.Fatalf(\"filestore directory does not exst after opening it\")\n\t}\n}\n\nfunc Test_FileStore_Close(t *testing.T) {\n\tstoredir := \"/tmp/TestStore/_unopen\"\n\tf := NewFileStore(storedir)\n\tf.Open()\n\tif !f.opened {\n\t\tt.Fatalf(\"filestore was not set open\")\n\t}\n\tif f.directory != storedir {\n\t\tt.Fatalf(\"filestore directory is wrong\")\n\t}\n\tif !exists(storedir) {\n\t\tt.Fatalf(\"filestore directory does not exst after opening it\")\n\t}\n\n\tf.Close()\n\tif f.opened {\n\t\tt.Fatalf(\"filestore was still open after unopen\")\n\t}\n\tif !exists(storedir) {\n\t\tt.Fatalf(\"filestore was deleted after unopen\")\n\t}\n}\n\nfunc Test_FileStore_write(t *testing.T) {\n\tstoredir := \"/tmp/TestStore/_write\"\n\tf := NewFileStore(storedir)\n\tf.Open()\n\n\tpm := packets.NewControlPacket(packets.Publish).(*packets.PublishPacket)\n\tpm.Qos = 1\n\tpm.TopicName = \"a/b/c\"\n\tpm.Payload = []byte{0xBE, 0xEF, 0xED}\n\tpm.MessageID = 91\n\n\tkey := inboundKeyFromMID(pm.MessageID)\n\tf.Put(key, pm)\n\n\tif !exists(storedir + \"/i.91.msg\") {\n\t\tt.Fatalf(\"message not in store\")\n\t}\n\n}\n\nfunc Test_FileStore_Get(t *testing.T) {\n\tstoredir := \"/tmp/TestStore/_get\"\n\tf := NewFileStore(storedir)\n\tf.Open()\n\tpm := packets.NewControlPacket(packets.Publish).(*packets.PublishPacket)\n\tpm.Qos = 1\n\tpm.TopicName = \"/a/b/c\"\n\tpm.Payload = []byte{0xBE, 0xEF, 0xED}\n\tpm.MessageID = 120\n\n\tkey := outboundKeyFromMID(pm.MessageID)\n\tf.Put(key, pm)\n\n\tif !exists(storedir + \"/o.120.msg\") {\n\t\tt.Fatalf(\"message not in store\")\n\t}\n\n\texp := []byte{\n\t\t/* msg type */\n\t\t0x32, // qos 1\n\n\t\t/* remlen */\n\t\t0x0d,\n\n\t\t/* topic, msg id in varheader */\n\t\t0x00, // length of topic\n\t\t0x06,\n\t\t0x2F, // /\n\t\t0x61, // a\n\t\t0x2F, // /\n\t\t0x62, // b\n\t\t0x2F, // /\n\t\t0x63, // c\n\n\t\t/* msg id (is always 2 bytes) */\n\t\t0x00,\n\t\t0x78,\n\n\t\t/*payload */\n\t\t0xBE,\n\t\t0xEF,\n\t\t0xED,\n\t}\n\n\tm := f.Get(key)\n\n\tif m == nil {\n\t\tt.Fatalf(\"message not retreived from store\")\n\t}\n\n\tvar msg bytes.Buffer\n\tif err := m.Write(&msg); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif !bytes.Equal(exp, msg.Bytes()) {\n\t\tt.Fatal(\"message from store not same as what went in\", msg.Bytes())\n\t}\n}\n\nfunc Test_FileStore_Get_Corrupted(t *testing.T) {\n\tstoredir := \"/tmp/TestStore/_get_error\"\n\tf := NewFileStore(storedir)\n\tf.Open()\n\tpm := packets.NewControlPacket(packets.Publish).(*packets.PublishPacket)\n\tpm.Qos = 1\n\tpm.TopicName = \"/a/b/c\"\n\tpm.Payload = []byte{0xBE, 0xEF, 0xED}\n\tpm.MessageID = 120\n\n\tkey := outboundKeyFromMID(pm.MessageID)\n\n\texp := []byte{\n\t\t/* msg type */\n\t\t0x32, // qos 1\n\n\t\t/* remlen */\n\t\t0x0d,\n\n\t\t/* topic, msg id in varheader */\n\t\t0x00, // length of topic\n\t\t0x06,\n\t\t// Oh no the rest is gone!\n\t}\n\n\tfile, err := os.Create(storedir + \"/o.120.msg\")\n\tchkerr(err)\n\t_, err = file.Write(exp)\n\tchkerr(err)\n\tchkerr(file.Close())\n\n\tif !exists(storedir + \"/o.120.msg\") {\n\t\tt.Fatalf(\"corrupt message not in store\")\n\t}\n\n\tm := f.Get(key)\n\n\tif m != nil {\n\t\tt.Fatalf(\"corrupted message retrieved from store\")\n\t}\n\n\tif exists(storedir + \"/o.120.msg\") {\n\t\tt.Fatalf(\"corrupt message left in store\")\n\t}\n\n\tif !exists(storedir + \"/o.120.CORRUPT\") {\n\t\tt.Fatalf(\"corrupt message not archived\")\n\t}\n\n\tcontents, err := ioutil.ReadFile(storedir + \"/o.120.CORRUPT\")\n\tchkerr(err)\n\n\tif !bytes.Equal(exp, contents) {\n\t\tt.Fatal(\"archived corrupted bytes not the same as those saved\", exp, contents)\n\t}\n}\n\nfunc Test_FileStore_All(t *testing.T) {\n\tstoredir := \"/tmp/TestStore/_all\"\n\tf := NewFileStore(storedir)\n\tf.Open()\n\tpm := packets.NewControlPacket(packets.Publish).(*packets.PublishPacket)\n\tpm.Qos = 2\n\tpm.TopicName = \"/t/r/v\"\n\tpm.Payload = []byte{0x01, 0x02}\n\tpm.MessageID = 121\n\n\tkey := outboundKeyFromMID(pm.MessageID)\n\tf.Put(key, pm)\n\n\tkeys := f.All()\n\tif len(keys) != 1 {\n\t\tt.Logf(\"Keys: %s\", keys)\n\t\tt.Fatalf(\"FileStore.All does not have the messages\")\n\t}\n\n\tif keys[0] != \"o.121\" {\n\t\tt.Fatalf(\"FileStore.All has wrong key\")\n\t}\n}\n\nfunc Test_FileStore_Del(t *testing.T) {\n\tstoredir := \"/tmp/TestStore/_del\"\n\tf := NewFileStore(storedir)\n\tf.Open()\n\n\tpm := packets.NewControlPacket(packets.Publish).(*packets.PublishPacket)\n\tpm.Qos = 1\n\tpm.TopicName = \"a/b/c\"\n\tpm.Payload = []byte{0xBE, 0xEF, 0xED}\n\tpm.MessageID = 17\n\n\tkey := inboundKeyFromMID(pm.MessageID)\n\tf.Put(key, pm)\n\n\tif !exists(storedir + \"/i.17.msg\") {\n\t\tt.Fatalf(\"message not in store\")\n\t}\n\n\tf.Del(key)\n\n\tif exists(storedir + \"/i.17.msg\") {\n\t\tt.Fatalf(\"message still exists after deletion\")\n\t}\n}\n\nfunc Test_FileStore_Reset(t *testing.T) {\n\tstoredir := \"/tmp/TestStore/_reset\"\n\tf := NewFileStore(storedir)\n\tf.Open()\n\n\tpm1 := packets.NewControlPacket(packets.Publish).(*packets.PublishPacket)\n\tpm1.Qos = 1\n\tpm1.TopicName = \"/q/w/e\"\n\tpm1.Payload = []byte{0xBB}\n\tpm1.MessageID = 71\n\tkey1 := inboundKeyFromMID(pm1.MessageID)\n\tf.Put(key1, pm1)\n\n\tpm2 := packets.NewControlPacket(packets.Publish).(*packets.PublishPacket)\n\tpm2.Qos = 1\n\tpm2.TopicName = \"/q/w/e\"\n\tpm2.Payload = []byte{0xBB}\n\tpm2.MessageID = 72\n\tkey2 := inboundKeyFromMID(pm2.MessageID)\n\tf.Put(key2, pm2)\n\n\tpm3 := packets.NewControlPacket(packets.Publish).(*packets.PublishPacket)\n\tpm3.Qos = 1\n\tpm3.TopicName = \"/q/w/e\"\n\tpm3.Payload = []byte{0xBB}\n\tpm3.MessageID = 73\n\tkey3 := inboundKeyFromMID(pm3.MessageID)\n\tf.Put(key3, pm3)\n\n\tpm4 := packets.NewControlPacket(packets.Publish).(*packets.PublishPacket)\n\tpm4.Qos = 1\n\tpm4.TopicName = \"/q/w/e\"\n\tpm4.Payload = []byte{0xBB}\n\tpm4.MessageID = 74\n\tkey4 := inboundKeyFromMID(pm4.MessageID)\n\tf.Put(key4, pm4)\n\n\tpm5 := packets.NewControlPacket(packets.Publish).(*packets.PublishPacket)\n\tpm5.Qos = 1\n\tpm5.TopicName = \"/q/w/e\"\n\tpm5.Payload = []byte{0xBB}\n\tpm5.MessageID = 75\n\tkey5 := inboundKeyFromMID(pm5.MessageID)\n\tf.Put(key5, pm5)\n\n\tif !exists(storedir + \"/i.71.msg\") {\n\t\tt.Fatalf(\"message not in store\")\n\t}\n\n\tif !exists(storedir + \"/i.72.msg\") {\n\t\tt.Fatalf(\"message not in store\")\n\t}\n\n\tif !exists(storedir + \"/i.73.msg\") {\n\t\tt.Fatalf(\"message not in store\")\n\t}\n\n\tif !exists(storedir + \"/i.74.msg\") {\n\t\tt.Fatalf(\"message not in store\")\n\t}\n\n\tif !exists(storedir + \"/i.75.msg\") {\n\t\tt.Fatalf(\"message not in store\")\n\t}\n\n\tf.Reset()\n\n\tif exists(storedir + \"/i.71.msg\") {\n\t\tt.Fatalf(\"message still exists after reset\")\n\t}\n\n\tif exists(storedir + \"/i.72.msg\") {\n\t\tt.Fatalf(\"message still exists after reset\")\n\t}\n\n\tif exists(storedir + \"/i.73.msg\") {\n\t\tt.Fatalf(\"message still exists after reset\")\n\t}\n\n\tif exists(storedir + \"/i.74.msg\") {\n\t\tt.Fatalf(\"message still exists after reset\")\n\t}\n\n\tif exists(storedir + \"/i.75.msg\") {\n\t\tt.Fatalf(\"message still exists after reset\")\n\t}\n}\n\n/*******************\n *** MemoryStore ***\n *******************/\n\nfunc Test_NewMemoryStore(t *testing.T) {\n\tm := NewMemoryStore()\n\tif m == nil {\n\t\tt.Fatalf(\"MemoryStore could not be created\")\n\t}\n}\n\nfunc Test_MemoryStore_Open(t *testing.T) {\n\tm := NewMemoryStore()\n\tm.Open()\n\tif !m.opened {\n\t\tt.Fatalf(\"MemoryStore was not set open\")\n\t}\n}\n\nfunc Test_MemoryStore_Close(t *testing.T) {\n\tm := NewMemoryStore()\n\tm.Open()\n\tif !m.opened {\n\t\tt.Fatalf(\"MemoryStore was not set open\")\n\t}\n\n\tm.Close()\n\tif m.opened {\n\t\tt.Fatalf(\"MemoryStore was still open after unopen\")\n\t}\n}\n\nfunc Test_MemoryStore_Reset(t *testing.T) {\n\tm := NewMemoryStore()\n\tm.Open()\n\n\tpm := packets.NewControlPacket(packets.Publish).(*packets.PublishPacket)\n\tpm.Qos = 2\n\tpm.TopicName = \"/f/r/s\"\n\tpm.Payload = []byte{0xAB}\n\tpm.MessageID = 81\n\n\tkey := outboundKeyFromMID(pm.MessageID)\n\tm.Put(key, pm)\n\n\tif len(m.messages) != 1 {\n\t\tt.Fatalf(\"message not in memstore\")\n\t}\n\n\tm.Reset()\n\n\tif len(m.messages) != 0 {\n\t\tt.Fatalf(\"reset did not clear memstore\")\n\t}\n}\n\nfunc Test_MemoryStore_write(t *testing.T) {\n\tm := NewMemoryStore()\n\tm.Open()\n\n\tpm := packets.NewControlPacket(packets.Publish).(*packets.PublishPacket)\n\tpm.Qos = 1\n\tpm.TopicName = \"/a/b/c\"\n\tpm.Payload = []byte{0xBE, 0xEF, 0xED}\n\tpm.MessageID = 91\n\tkey := inboundKeyFromMID(pm.MessageID)\n\tm.Put(key, pm)\n\n\tif len(m.messages) != 1 {\n\t\tt.Fatalf(\"message not in store\")\n\t}\n}\n\nfunc Test_MemoryStore_Get(t *testing.T) {\n\tm := NewMemoryStore()\n\tm.Open()\n\tpm := packets.NewControlPacket(packets.Publish).(*packets.PublishPacket)\n\tpm.Qos = 1\n\tpm.TopicName = \"/a/b/c\"\n\tpm.Payload = []byte{0xBE, 0xEF, 0xED}\n\tpm.MessageID = 120\n\n\tkey := outboundKeyFromMID(pm.MessageID)\n\tm.Put(key, pm)\n\n\tif len(m.messages) != 1 {\n\t\tt.Fatalf(\"message not in store\")\n\t}\n\n\texp := []byte{\n\t\t/* msg type */\n\t\t0x32, // qos 1\n\n\t\t/* remlen */\n\t\t0x0d,\n\n\t\t/* topic, msg id in varheader */\n\t\t0x00, // length of topic\n\t\t0x06,\n\t\t0x2F, // /\n\t\t0x61, // a\n\t\t0x2F, // /\n\t\t0x62, // b\n\t\t0x2F, // /\n\t\t0x63, // c\n\n\t\t/* msg id (is always 2 bytes) */\n\t\t0x00,\n\t\t0x78,\n\n\t\t/*payload */\n\t\t0xBE,\n\t\t0xEF,\n\t\t0xED,\n\t}\n\n\tmsg := m.Get(key)\n\n\tif msg == nil {\n\t\tt.Fatalf(\"message not retreived from store\")\n\t}\n\n\tvar buf bytes.Buffer\n\tif err := msg.Write(&buf); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif !bytes.Equal(exp, buf.Bytes()) {\n\t\tt.Fatalf(\"message from store not same as what went in\")\n\t}\n}\n\nfunc Test_MemoryStore_Del(t *testing.T) {\n\tm := NewMemoryStore()\n\tm.Open()\n\n\tpm := packets.NewControlPacket(packets.Publish).(*packets.PublishPacket)\n\tpm.Qos = 1\n\tpm.TopicName = \"/a/b/c\"\n\tpm.Payload = []byte{0xBE, 0xEF, 0xED}\n\tpm.MessageID = 17\n\n\tkey := outboundKeyFromMID(pm.MessageID)\n\n\tm.Put(key, pm)\n\n\tif len(m.messages) != 1 {\n\t\tt.Fatalf(\"message not in store\")\n\t}\n\n\tm.Del(key)\n\n\tif len(m.messages) != 0 {\n\t\tt.Fatalf(\"message still exists after deletion\")\n\t}\n}\n"
        },
        {
          "name": "fvt_test.go",
          "type": "blob",
          "size": 0.9521484375,
          "content": "/*\n * Copyright (c) 2021 IBM Corp and others.\n *\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v2.0\n * and Eclipse Distribution License v1.0 which accompany this distribution.\n *\n * The Eclipse Public License is available at\n *    https://www.eclipse.org/legal/epl-2.0/\n * and the Eclipse Distribution License is available at\n *   http://www.eclipse.org/org/documents/edl-v10.php.\n *\n * Contributors:\n *    Seth Hoenig\n *    Allan Stockdill-Mander\n *    Mike Robertson\n */\n\npackage mqtt\n\nimport \"os\"\n\n// Use setup_IMA.sh for IBM's MessageSight\n// Use fvt/rsmb.cfg for IBM's Really Small Message Broker\n// Use fvt/mosquitto.cfg for the open source Mosquitto project\n\nvar (\n\tFVTTCP string\n\tFVTSSL string\n)\n\nfunc init() {\n\tFVTAddr := os.Getenv(\"TEST_FVT_ADDR\")\n\tif FVTAddr == \"\" {\n\t\tFVTAddr = \"127.0.0.1\"\n\t}\n\tFVTTCP = \"tcp://\" + FVTAddr + \":1883\"\n\tFVTSSL = \"ssl://\" + FVTAddr + \":8883\"\n}\n"
        },
        {
          "name": "go.mod",
          "type": "blob",
          "size": 0.150390625,
          "content": "module github.com/eclipse/paho.mqtt.golang\n\ngo 1.20\n\nrequire (\n\tgithub.com/gorilla/websocket v1.5.3\n\tgolang.org/x/net v0.27.0\n\tgolang.org/x/sync v0.7.0\n)\n"
        },
        {
          "name": "go.sum",
          "type": "blob",
          "size": 0.4697265625,
          "content": "github.com/gorilla/websocket v1.5.3 h1:saDtZ6Pbx/0u+bgYQ3q96pZgCzfhKXGPqt7kZ72aNNg=\ngithub.com/gorilla/websocket v1.5.3/go.mod h1:YR8l580nyteQvAITg2hZ9XVh4b55+EU/adAjf1fMHhE=\ngolang.org/x/net v0.27.0 h1:5K3Njcw06/l2y9vpGCSdcxWOYHOUk3dVNGDXN+FvAys=\ngolang.org/x/net v0.27.0/go.mod h1:dDi0PyhWNoiUOrAS8uXv/vnScO4wnHQO4mj9fn/RytE=\ngolang.org/x/sync v0.7.0 h1:YsImfSBoP9QPYL0xyKJPq0gcaJdG3rInoqxTWbfQu9M=\ngolang.org/x/sync v0.7.0/go.mod h1:Czt+wKu1gCyEFDUtn0jG5QVvpJ6rzVqr5aXyt9drQfk=\n"
        },
        {
          "name": "memstore.go",
          "type": "blob",
          "size": 3.7265625,
          "content": "/*\n * Copyright (c) 2021 IBM Corp and others.\n *\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v2.0\n * and Eclipse Distribution License v1.0 which accompany this distribution.\n *\n * The Eclipse Public License is available at\n *    https://www.eclipse.org/legal/epl-2.0/\n * and the Eclipse Distribution License is available at\n *   http://www.eclipse.org/org/documents/edl-v10.php.\n *\n * Contributors:\n *    Seth Hoenig\n *    Allan Stockdill-Mander\n *    Mike Robertson\n */\n\npackage mqtt\n\nimport (\n\t\"sync\"\n\n\t\"github.com/eclipse/paho.mqtt.golang/packets\"\n)\n\n// MemoryStore implements the store interface to provide a \"persistence\"\n// mechanism wholly stored in memory. This is only useful for\n// as long as the client instance exists.\ntype MemoryStore struct {\n\tsync.RWMutex\n\tmessages map[string]packets.ControlPacket\n\topened   bool\n}\n\n// NewMemoryStore returns a pointer to a new instance of\n// MemoryStore, the instance is not initialized and ready to\n// use until Open() has been called on it.\nfunc NewMemoryStore() *MemoryStore {\n\tstore := &MemoryStore{\n\t\tmessages: make(map[string]packets.ControlPacket),\n\t\topened:   false,\n\t}\n\treturn store\n}\n\n// Open initializes a MemoryStore instance.\nfunc (store *MemoryStore) Open() {\n\tstore.Lock()\n\tdefer store.Unlock()\n\tstore.opened = true\n\tDEBUG.Println(STR, \"memorystore initialized\")\n}\n\n// Put takes a key and a pointer to a Message and stores the\n// message.\nfunc (store *MemoryStore) Put(key string, message packets.ControlPacket) {\n\tstore.Lock()\n\tdefer store.Unlock()\n\tif !store.opened {\n\t\tERROR.Println(STR, \"Trying to use memory store, but not open\")\n\t\treturn\n\t}\n\tstore.messages[key] = message\n}\n\n// Get takes a key and looks in the store for a matching Message\n// returning either the Message pointer or nil.\nfunc (store *MemoryStore) Get(key string) packets.ControlPacket {\n\tstore.RLock()\n\tdefer store.RUnlock()\n\tif !store.opened {\n\t\tERROR.Println(STR, \"Trying to use memory store, but not open\")\n\t\treturn nil\n\t}\n\tmid := mIDFromKey(key)\n\tm := store.messages[key]\n\tif m == nil {\n\t\tCRITICAL.Println(STR, \"memorystore get: message\", mid, \"not found\")\n\t} else {\n\t\tDEBUG.Println(STR, \"memorystore get: message\", mid, \"found\")\n\t}\n\treturn m\n}\n\n// All returns a slice of strings containing all the keys currently\n// in the MemoryStore.\nfunc (store *MemoryStore) All() []string {\n\tstore.RLock()\n\tdefer store.RUnlock()\n\tif !store.opened {\n\t\tERROR.Println(STR, \"Trying to use memory store, but not open\")\n\t\treturn nil\n\t}\n\tvar keys []string\n\tfor k := range store.messages {\n\t\tkeys = append(keys, k)\n\t}\n\treturn keys\n}\n\n// Del takes a key, searches the MemoryStore and if the key is found\n// deletes the Message pointer associated with it.\nfunc (store *MemoryStore) Del(key string) {\n\tstore.Lock()\n\tdefer store.Unlock()\n\tif !store.opened {\n\t\tERROR.Println(STR, \"Trying to use memory store, but not open\")\n\t\treturn\n\t}\n\tmid := mIDFromKey(key)\n\tm := store.messages[key]\n\tif m == nil {\n\t\tWARN.Println(STR, \"memorystore del: message\", mid, \"not found\")\n\t} else {\n\t\tdelete(store.messages, key)\n\t\tDEBUG.Println(STR, \"memorystore del: message\", mid, \"was deleted\")\n\t}\n}\n\n// Close will disallow modifications to the state of the store.\nfunc (store *MemoryStore) Close() {\n\tstore.Lock()\n\tdefer store.Unlock()\n\tif !store.opened {\n\t\tERROR.Println(STR, \"Trying to close memory store, but not open\")\n\t\treturn\n\t}\n\tstore.opened = false\n\tDEBUG.Println(STR, \"memorystore closed\")\n}\n\n// Reset eliminates all persisted message data in the store.\nfunc (store *MemoryStore) Reset() {\n\tstore.Lock()\n\tdefer store.Unlock()\n\tif !store.opened {\n\t\tERROR.Println(STR, \"Trying to reset memory store, but not open\")\n\t}\n\tstore.messages = make(map[string]packets.ControlPacket)\n\tWARN.Println(STR, \"memorystore wiped\")\n}\n"
        },
        {
          "name": "memstore_ordered.go",
          "type": "blob",
          "size": 4.6044921875,
          "content": "/*\n * Copyright (c) 2021 IBM Corp and others.\n *\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v2.0\n * and Eclipse Distribution License v1.0 which accompany this distribution.\n *\n * The Eclipse Public License is available at\n *    https://www.eclipse.org/legal/epl-2.0/\n * and the Eclipse Distribution License is available at\n *   http://www.eclipse.org/org/documents/edl-v10.php.\n *\n * Contributors:\n *    Seth Hoenig\n *    Allan Stockdill-Mander\n *    Mike Robertson\n *    Matt Brittan\n */\n\npackage mqtt\n\nimport (\n\t\"sort\"\n\t\"sync\"\n\t\"time\"\n\n\t\"github.com/eclipse/paho.mqtt.golang/packets\"\n)\n\n// OrderedMemoryStore uses a map internally so the order in which All() returns packets is\n// undefined. OrderedMemoryStore resolves this by storing the time the message is added\n// and sorting based upon this.\n\n// storedMessage encapsulates a message and the time it was initially stored\ntype storedMessage struct {\n\tts  time.Time\n\tmsg packets.ControlPacket\n}\n\n// OrderedMemoryStore implements the store interface to provide a \"persistence\"\n// mechanism wholly stored in memory. This is only useful for\n// as long as the client instance exists.\ntype OrderedMemoryStore struct {\n\tsync.RWMutex\n\tmessages map[string]storedMessage\n\topened   bool\n}\n\n// NewOrderedMemoryStore returns a pointer to a new instance of\n// OrderedMemoryStore, the instance is not initialized and ready to\n// use until Open() has been called on it.\nfunc NewOrderedMemoryStore() *OrderedMemoryStore {\n\tstore := &OrderedMemoryStore{\n\t\tmessages: make(map[string]storedMessage),\n\t\topened:   false,\n\t}\n\treturn store\n}\n\n// Open initializes a OrderedMemoryStore instance.\nfunc (store *OrderedMemoryStore) Open() {\n\tstore.Lock()\n\tdefer store.Unlock()\n\tstore.opened = true\n\tDEBUG.Println(STR, \"OrderedMemoryStore initialized\")\n}\n\n// Put takes a key and a pointer to a Message and stores the\n// message.\nfunc (store *OrderedMemoryStore) Put(key string, message packets.ControlPacket) {\n\tstore.Lock()\n\tdefer store.Unlock()\n\tif !store.opened {\n\t\tERROR.Println(STR, \"Trying to use memory store, but not open\")\n\t\treturn\n\t}\n\tstore.messages[key] = storedMessage{ts: time.Now(), msg: message}\n}\n\n// Get takes a key and looks in the store for a matching Message\n// returning either the Message pointer or nil.\nfunc (store *OrderedMemoryStore) Get(key string) packets.ControlPacket {\n\tstore.RLock()\n\tdefer store.RUnlock()\n\tif !store.opened {\n\t\tERROR.Println(STR, \"Trying to use memory store, but not open\")\n\t\treturn nil\n\t}\n\tmid := mIDFromKey(key)\n\tm, ok := store.messages[key]\n\tif !ok || m.msg == nil {\n\t\tCRITICAL.Println(STR, \"OrderedMemoryStore get: message\", mid, \"not found\")\n\t} else {\n\t\tDEBUG.Println(STR, \"OrderedMemoryStore get: message\", mid, \"found\")\n\t}\n\treturn m.msg\n}\n\n// All returns a slice of strings containing all the keys currently\n// in the OrderedMemoryStore.\nfunc (store *OrderedMemoryStore) All() []string {\n\tstore.RLock()\n\tdefer store.RUnlock()\n\tif !store.opened {\n\t\tERROR.Println(STR, \"Trying to use memory store, but not open\")\n\t\treturn nil\n\t}\n\ttype tsAndKey struct {\n\t\tts  time.Time\n\t\tkey string\n\t}\n\n\ttsKeys := make([]tsAndKey, 0, len(store.messages))\n\tfor k, v := range store.messages {\n\t\ttsKeys = append(tsKeys, tsAndKey{ts: v.ts, key: k})\n\t}\n\tsort.Slice(tsKeys, func(a int, b int) bool { return tsKeys[a].ts.Before(tsKeys[b].ts) })\n\n\tkeys := make([]string, len(tsKeys))\n\tfor i := range tsKeys {\n\t\tkeys[i] = tsKeys[i].key\n\t}\n\treturn keys\n}\n\n// Del takes a key, searches the OrderedMemoryStore and if the key is found\n// deletes the Message pointer associated with it.\nfunc (store *OrderedMemoryStore) Del(key string) {\n\tstore.Lock()\n\tdefer store.Unlock()\n\tif !store.opened {\n\t\tERROR.Println(STR, \"Trying to use memory store, but not open\")\n\t\treturn\n\t}\n\tmid := mIDFromKey(key)\n\t_, ok := store.messages[key]\n\tif !ok {\n\t\tWARN.Println(STR, \"OrderedMemoryStore del: message\", mid, \"not found\")\n\t} else {\n\t\tdelete(store.messages, key)\n\t\tDEBUG.Println(STR, \"OrderedMemoryStore del: message\", mid, \"was deleted\")\n\t}\n}\n\n// Close will disallow modifications to the state of the store.\nfunc (store *OrderedMemoryStore) Close() {\n\tstore.Lock()\n\tdefer store.Unlock()\n\tif !store.opened {\n\t\tERROR.Println(STR, \"Trying to close memory store, but not open\")\n\t\treturn\n\t}\n\tstore.opened = false\n\tDEBUG.Println(STR, \"OrderedMemoryStore closed\")\n}\n\n// Reset eliminates all persisted message data in the store.\nfunc (store *OrderedMemoryStore) Reset() {\n\tstore.Lock()\n\tdefer store.Unlock()\n\tif !store.opened {\n\t\tERROR.Println(STR, \"Trying to reset memory store, but not open\")\n\t}\n\tstore.messages = make(map[string]storedMessage)\n\tWARN.Println(STR, \"OrderedMemoryStore wiped\")\n}\n"
        },
        {
          "name": "message.go",
          "type": "blob",
          "size": 2.7001953125,
          "content": "/*\n * Copyright (c) 2021 IBM Corp and others.\n *\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v2.0\n * and Eclipse Distribution License v1.0 which accompany this distribution.\n *\n * The Eclipse Public License is available at\n *    https://www.eclipse.org/legal/epl-2.0/\n * and the Eclipse Distribution License is available at\n *   http://www.eclipse.org/org/documents/edl-v10.php.\n *\n * Contributors:\n *    Seth Hoenig\n *    Allan Stockdill-Mander\n *    Mike Robertson\n */\n\npackage mqtt\n\nimport (\n\t\"net/url\"\n\t\"sync\"\n\n\t\"github.com/eclipse/paho.mqtt.golang/packets\"\n)\n\n// Message defines the externals that a message implementation must support\n// these are received messages that are passed to the callbacks, not internal\n// messages\ntype Message interface {\n\tDuplicate() bool\n\tQos() byte\n\tRetained() bool\n\tTopic() string\n\tMessageID() uint16\n\tPayload() []byte\n\tAck()\n}\n\ntype message struct {\n\tduplicate bool\n\tqos       byte\n\tretained  bool\n\ttopic     string\n\tmessageID uint16\n\tpayload   []byte\n\tonce      sync.Once\n\tack       func()\n}\n\nfunc (m *message) Duplicate() bool {\n\treturn m.duplicate\n}\n\nfunc (m *message) Qos() byte {\n\treturn m.qos\n}\n\nfunc (m *message) Retained() bool {\n\treturn m.retained\n}\n\nfunc (m *message) Topic() string {\n\treturn m.topic\n}\n\nfunc (m *message) MessageID() uint16 {\n\treturn m.messageID\n}\n\nfunc (m *message) Payload() []byte {\n\treturn m.payload\n}\n\nfunc (m *message) Ack() {\n\tm.once.Do(m.ack)\n}\n\nfunc messageFromPublish(p *packets.PublishPacket, ack func()) Message {\n\treturn &message{\n\t\tduplicate: p.Dup,\n\t\tqos:       p.Qos,\n\t\tretained:  p.Retain,\n\t\ttopic:     p.TopicName,\n\t\tmessageID: p.MessageID,\n\t\tpayload:   p.Payload,\n\t\tack:       ack,\n\t}\n}\n\nfunc newConnectMsgFromOptions(options *ClientOptions, broker *url.URL) *packets.ConnectPacket {\n\tm := packets.NewControlPacket(packets.Connect).(*packets.ConnectPacket)\n\n\tm.CleanSession = options.CleanSession\n\tm.WillFlag = options.WillEnabled\n\tm.WillRetain = options.WillRetained\n\tm.ClientIdentifier = options.ClientID\n\n\tif options.WillEnabled {\n\t\tm.WillQos = options.WillQos\n\t\tm.WillTopic = options.WillTopic\n\t\tm.WillMessage = options.WillPayload\n\t}\n\n\tusername := options.Username\n\tpassword := options.Password\n\tif broker.User != nil {\n\t\tusername = broker.User.Username()\n\t\tif pwd, ok := broker.User.Password(); ok {\n\t\t\tpassword = pwd\n\t\t}\n\t}\n\tif options.CredentialsProvider != nil {\n\t\tusername, password = options.CredentialsProvider()\n\t}\n\n\tif username != \"\" {\n\t\tm.UsernameFlag = true\n\t\tm.Username = username\n\t\t// mustn't have password without user as well\n\t\tif password != \"\" {\n\t\t\tm.PasswordFlag = true\n\t\t\tm.Password = []byte(password)\n\t\t}\n\t}\n\n\tm.Keepalive = uint16(options.KeepAlive)\n\n\treturn m\n}\n"
        },
        {
          "name": "messageids.go",
          "type": "blob",
          "size": 5.25,
          "content": "/*\n * Copyright (c) 2013 IBM Corp and others.\n *\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v2.0\n * and Eclipse Distribution License v1.0 which accompany this distribution.\n *\n * The Eclipse Public License is available at\n *    https://www.eclipse.org/legal/epl-2.0/\n * and the Eclipse Distribution License is available at\n *   http://www.eclipse.org/org/documents/edl-v10.php.\n *\n * Contributors:\n *    Seth Hoenig\n *    Allan Stockdill-Mander\n *    Mike Robertson\n *    Matt Brittan\n */\n\npackage mqtt\n\nimport (\n\t\"fmt\"\n\t\"sync\"\n\t\"time\"\n)\n\n// MId is 16 bit message id as specified by the MQTT spec.\n// In general, these values should not be depended upon by\n// the client application.\ntype MId uint16\n\ntype messageIds struct {\n\tmu    sync.RWMutex // Named to prevent Mu from being accessible directly via client\n\tindex map[uint16]tokenCompletor\n\n\tlastIssuedID uint16 // The most recently issued ID. Used so we cycle through ids rather than immediately reusing them (can make debugging easier)\n}\n\nconst (\n\tmidMin uint16 = 1\n\tmidMax uint16 = 65535\n)\n\n// cleanup clears the message ID map; completes all token types and sets error on PUB, SUB and UNSUB tokens.\nfunc (mids *messageIds) cleanUp() {\n\tmids.mu.Lock()\n\tfor _, token := range mids.index {\n\t\tswitch token.(type) {\n\t\tcase *PublishToken:\n\t\t\ttoken.setError(fmt.Errorf(\"connection lost before Publish completed\"))\n\t\tcase *SubscribeToken:\n\t\t\ttoken.setError(fmt.Errorf(\"connection lost before Subscribe completed\"))\n\t\tcase *UnsubscribeToken:\n\t\t\ttoken.setError(fmt.Errorf(\"connection lost before Unsubscribe completed\"))\n\t\tcase nil: // should not be any nil entries\n\t\t\tcontinue\n\t\t}\n\t\ttoken.flowComplete()\n\t}\n\tmids.index = make(map[uint16]tokenCompletor)\n\tmids.mu.Unlock()\n\tDEBUG.Println(MID, \"cleaned up\")\n}\n\n// cleanUpSubscribe removes all SUBSCRIBE and UNSUBSCRIBE tokens (setting error)\n// This may be called when the connection is lost, and we will not be resending SUB/UNSUB packets\nfunc (mids *messageIds) cleanUpSubscribe() {\n\tmids.mu.Lock()\n\tfor mid, token := range mids.index {\n\t\tswitch token.(type) {\n\t\tcase *SubscribeToken:\n\t\t\ttoken.setError(fmt.Errorf(\"connection lost before Subscribe completed\"))\n\t\t\tdelete(mids.index, mid)\n\t\tcase *UnsubscribeToken:\n\t\t\ttoken.setError(fmt.Errorf(\"connection lost before Unsubscribe completed\"))\n\t\t\tdelete(mids.index, mid)\n\t\t}\n\t}\n\tmids.mu.Unlock()\n\tDEBUG.Println(MID, \"cleaned up subs\")\n}\n\nfunc (mids *messageIds) freeID(id uint16) {\n\tmids.mu.Lock()\n\tdelete(mids.index, id)\n\tmids.mu.Unlock()\n}\n\nfunc (mids *messageIds) claimID(token tokenCompletor, id uint16) {\n\tmids.mu.Lock()\n\tdefer mids.mu.Unlock()\n\tif _, ok := mids.index[id]; !ok {\n\t\tmids.index[id] = token\n\t} else {\n\t\told := mids.index[id]\n\t\told.flowComplete()\n\t\tmids.index[id] = token\n\t}\n\tif id > mids.lastIssuedID {\n\t\tmids.lastIssuedID = id\n\t}\n}\n\n// getID will return an available id or 0 if none available\n// The id will generally be the previous id + 1 (because this makes tracing messages a bit simpler)\nfunc (mids *messageIds) getID(t tokenCompletor) uint16 {\n\tmids.mu.Lock()\n\tdefer mids.mu.Unlock()\n\ti := mids.lastIssuedID // note: the only situation where lastIssuedID is 0 the map will be empty\n\tlooped := false        // uint16 will loop from 65535->0\n\tfor {\n\t\ti++\n\t\tif i == 0 { // skip 0 because its not a valid id (Control Packets MUST contain a non-zero 16-bit Packet Identifier [MQTT-2.3.1-1])\n\t\t\ti++\n\t\t\tlooped = true\n\t\t}\n\t\tif _, ok := mids.index[i]; !ok {\n\t\t\tmids.index[i] = t\n\t\t\tmids.lastIssuedID = i\n\t\t\treturn i\n\t\t}\n\t\tif (looped && i == mids.lastIssuedID) || (mids.lastIssuedID == 0 && i == midMax) { // lastIssuedID will be 0 at startup\n\t\t\treturn 0 // no free ids\n\t\t}\n\t}\n}\n\nfunc (mids *messageIds) getToken(id uint16) tokenCompletor {\n\tmids.mu.RLock()\n\tdefer mids.mu.RUnlock()\n\tif token, ok := mids.index[id]; ok {\n\t\treturn token\n\t}\n\treturn &DummyToken{id: id}\n}\n\ntype DummyToken struct {\n\tid uint16\n}\n\n// Wait implements the Token Wait method.\nfunc (d *DummyToken) Wait() bool {\n\treturn true\n}\n\n// WaitTimeout implements the Token WaitTimeout method.\nfunc (d *DummyToken) WaitTimeout(t time.Duration) bool {\n\treturn true\n}\n\n// Done implements the Token Done method.\nfunc (d *DummyToken) Done() <-chan struct{} {\n\tch := make(chan struct{})\n\tclose(ch)\n\treturn ch\n}\n\nfunc (d *DummyToken) flowComplete() {\n\tERROR.Printf(\"A lookup for token %d returned nil\\n\", d.id)\n}\n\nfunc (d *DummyToken) Error() error {\n\treturn nil\n}\n\nfunc (d *DummyToken) setError(e error) {}\n\n// PlaceHolderToken does nothing and was implemented to allow a messageid to be reserved\n// it differs from DummyToken in that calling flowComplete does not generate an error (it\n// is expected that flowComplete will be called when the token is overwritten with a real token)\ntype PlaceHolderToken struct {\n\tid uint16\n}\n\n// Wait implements the Token Wait method.\nfunc (p *PlaceHolderToken) Wait() bool {\n\treturn true\n}\n\n// WaitTimeout implements the Token WaitTimeout method.\nfunc (p *PlaceHolderToken) WaitTimeout(t time.Duration) bool {\n\treturn true\n}\n\n// Done implements the Token Done method.\nfunc (p *PlaceHolderToken) Done() <-chan struct{} {\n\tch := make(chan struct{})\n\tclose(ch)\n\treturn ch\n}\n\nfunc (p *PlaceHolderToken) flowComplete() {\n}\n\nfunc (p *PlaceHolderToken) Error() error {\n\treturn nil\n}\n\nfunc (p *PlaceHolderToken) setError(e error) {}\n"
        },
        {
          "name": "net.go",
          "type": "blob",
          "size": 17.470703125,
          "content": "/*\n * Copyright (c) 2021 IBM Corp and others.\n *\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v2.0\n * and Eclipse Distribution License v1.0 which accompany this distribution.\n *\n * The Eclipse Public License is available at\n *    https://www.eclipse.org/legal/epl-2.0/\n * and the Eclipse Distribution License is available at\n *   http://www.eclipse.org/org/documents/edl-v10.php.\n *\n * Contributors:\n *    Seth Hoenig\n *    Allan Stockdill-Mander\n *    Mike Robertson\n *    Matt Brittan\n */\n\npackage mqtt\n\nimport (\n\t\"errors\"\n\t\"io\"\n\t\"net\"\n\t\"reflect\"\n\t\"strings\"\n\t\"sync\"\n\t\"time\"\n\n\t\"github.com/eclipse/paho.mqtt.golang/packets\"\n)\n\nconst closedNetConnErrorText = \"use of closed network connection\" // error string for closed conn (https://golang.org/src/net/error_test.go)\n\n// ConnectMQTT takes a connected net.Conn and performs the initial MQTT handshake. Parameters are:\n// conn - Connected net.Conn\n// cm - Connect Packet with everything other than the protocol name/version populated (historical reasons)\n// protocolVersion - The protocol version to attempt to connect with\n//\n// Note that, for backward compatibility, ConnectMQTT() suppresses the actual connection error (compare to connectMQTT()).\nfunc ConnectMQTT(conn net.Conn, cm *packets.ConnectPacket, protocolVersion uint) (byte, bool) {\n\trc, sessionPresent, _ := connectMQTT(conn, cm, protocolVersion)\n\treturn rc, sessionPresent\n}\n\nfunc connectMQTT(conn io.ReadWriter, cm *packets.ConnectPacket, protocolVersion uint) (byte, bool, error) {\n\tswitch protocolVersion {\n\tcase 3:\n\t\tDEBUG.Println(CLI, \"Using MQTT 3.1 protocol\")\n\t\tcm.ProtocolName = \"MQIsdp\"\n\t\tcm.ProtocolVersion = 3\n\tcase 0x83:\n\t\tDEBUG.Println(CLI, \"Using MQTT 3.1b protocol\")\n\t\tcm.ProtocolName = \"MQIsdp\"\n\t\tcm.ProtocolVersion = 0x83\n\tcase 0x84:\n\t\tDEBUG.Println(CLI, \"Using MQTT 3.1.1b protocol\")\n\t\tcm.ProtocolName = \"MQTT\"\n\t\tcm.ProtocolVersion = 0x84\n\tdefault:\n\t\tDEBUG.Println(CLI, \"Using MQTT 3.1.1 protocol\")\n\t\tcm.ProtocolName = \"MQTT\"\n\t\tcm.ProtocolVersion = 4\n\t}\n\n\tif err := cm.Write(conn); err != nil {\n\t\tERROR.Println(CLI, err)\n\t\treturn packets.ErrNetworkError, false, err\n\t}\n\n\trc, sessionPresent, err := verifyCONNACK(conn)\n\treturn rc, sessionPresent, err\n}\n\n// This function is only used for receiving a connack\n// when the connection is first started.\n// This prevents receiving incoming data while resume\n// is in progress if clean session is false.\nfunc verifyCONNACK(conn io.Reader) (byte, bool, error) {\n\tDEBUG.Println(NET, \"connect started\")\n\n\tca, err := packets.ReadPacket(conn)\n\tif err != nil {\n\t\tERROR.Println(NET, \"connect got error\", err)\n\t\treturn packets.ErrNetworkError, false, err\n\t}\n\n\tif ca == nil {\n\t\tERROR.Println(NET, \"received nil packet\")\n\t\treturn packets.ErrNetworkError, false, errors.New(\"nil CONNACK packet\")\n\t}\n\n\tmsg, ok := ca.(*packets.ConnackPacket)\n\tif !ok {\n\t\tERROR.Println(NET, \"received msg that was not CONNACK\")\n\t\treturn packets.ErrNetworkError, false, errors.New(\"non-CONNACK first packet received\")\n\t}\n\n\tDEBUG.Println(NET, \"received connack\")\n\treturn msg.ReturnCode, msg.SessionPresent, nil\n}\n\n// inbound encapsulates the output from startIncoming.\n// err  - If != nil then an error has occurred\n// cp - A control packet received over the network link\ntype inbound struct {\n\terr error\n\tcp  packets.ControlPacket\n}\n\n// startIncoming initiates a goroutine that reads incoming messages off the wire and sends them to the channel (returned).\n// If there are any issues with the network connection then the returned channel will be closed and the goroutine will exit\n// (so closing the connection will terminate the goroutine)\nfunc startIncoming(conn io.Reader) <-chan inbound {\n\tvar err error\n\tvar cp packets.ControlPacket\n\tibound := make(chan inbound)\n\n\tDEBUG.Println(NET, \"incoming started\")\n\n\tgo func() {\n\t\tfor {\n\t\t\tif cp, err = packets.ReadPacket(conn); err != nil {\n\t\t\t\t// We do not want to log the error if it is due to the network connection having been closed\n\t\t\t\t// elsewhere (i.e. after sending DisconnectPacket). Detecting this situation is the subject of\n\t\t\t\t// https://github.com/golang/go/issues/4373\n\t\t\t\tif !strings.Contains(err.Error(), closedNetConnErrorText) {\n\t\t\t\t\tibound <- inbound{err: err}\n\t\t\t\t}\n\t\t\t\tclose(ibound)\n\t\t\t\tDEBUG.Println(NET, \"incoming complete\")\n\t\t\t\treturn\n\t\t\t}\n\t\t\tDEBUG.Println(NET, \"startIncoming Received Message\")\n\t\t\tibound <- inbound{cp: cp}\n\t\t}\n\t}()\n\n\treturn ibound\n}\n\n// incomingComms encapsulates the possible output of the incomingComms routine. If err != nil then an error has occurred and\n// the routine will have terminated; otherwise one of the other members should be non-nil\ntype incomingComms struct {\n\terr         error                  // If non-nil then there has been an error (ignore everything else)\n\toutbound    *PacketAndToken        // Packet (with token) than needs to be sent out (e.g. an acknowledgement)\n\tincomingPub *packets.PublishPacket // A new publish has been received; this will need to be passed on to our user\n}\n\n// startIncomingComms initiates incoming communications; this includes starting a goroutine to process incoming\n// messages.\n// Accepts a channel of inbound messages from the store (persisted messages); note this must be closed as soon as\n// everything in the store has been sent.\n// Returns a channel that will be passed any received packets; this will be closed on a network error (and inboundFromStore closed)\nfunc startIncomingComms(conn io.Reader,\n\tc commsFns,\n\tinboundFromStore <-chan packets.ControlPacket,\n) <-chan incomingComms {\n\tibound := startIncoming(conn) // Start goroutine that reads from network connection\n\toutput := make(chan incomingComms)\n\n\tDEBUG.Println(NET, \"startIncomingComms started\")\n\tgo func() {\n\t\tfor {\n\t\t\tif inboundFromStore == nil && ibound == nil {\n\t\t\t\tclose(output)\n\t\t\t\tDEBUG.Println(NET, \"startIncomingComms goroutine complete\")\n\t\t\t\treturn // As soon as ibound is closed we can exit (should have already processed an error)\n\t\t\t}\n\t\t\tDEBUG.Println(NET, \"logic waiting for msg on ibound\")\n\n\t\t\tvar msg packets.ControlPacket\n\t\t\tvar ok bool\n\t\t\tselect {\n\t\t\tcase msg, ok = <-inboundFromStore:\n\t\t\t\tif !ok {\n\t\t\t\t\tDEBUG.Println(NET, \"startIncomingComms: inboundFromStore complete\")\n\t\t\t\t\tinboundFromStore = nil // should happen quickly as this is only for persisted messages\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\tDEBUG.Println(NET, \"startIncomingComms: got msg from store\")\n\t\t\tcase ibMsg, ok := <-ibound:\n\t\t\t\tif !ok {\n\t\t\t\t\tDEBUG.Println(NET, \"startIncomingComms: ibound complete\")\n\t\t\t\t\tibound = nil\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\tDEBUG.Println(NET, \"startIncomingComms: got msg on ibound\")\n\t\t\t\t// If the inbound comms routine encounters any issues it will send us an error.\n\t\t\t\tif ibMsg.err != nil {\n\t\t\t\t\toutput <- incomingComms{err: ibMsg.err}\n\t\t\t\t\tcontinue // Usually the channel will be closed immediately after sending an error but safer that we do not assume this\n\t\t\t\t}\n\t\t\t\tmsg = ibMsg.cp\n\n\t\t\t\tc.persistInbound(msg)\n\t\t\t\tc.UpdateLastReceived() // Notify keepalive logic that we recently received a packet\n\t\t\t}\n\n\t\t\tswitch m := msg.(type) {\n\t\t\tcase *packets.PingrespPacket:\n\t\t\t\tDEBUG.Println(NET, \"startIncomingComms: received pingresp\")\n\t\t\t\tc.pingRespReceived()\n\t\t\tcase *packets.SubackPacket:\n\t\t\t\tDEBUG.Println(NET, \"startIncomingComms: received suback, id:\", m.MessageID)\n\t\t\t\ttoken := c.getToken(m.MessageID)\n\n\t\t\t\tif t, ok := token.(*SubscribeToken); ok {\n\t\t\t\t\tDEBUG.Println(NET, \"startIncomingComms: granted qoss\", m.ReturnCodes)\n\t\t\t\t\tfor i, qos := range m.ReturnCodes {\n\t\t\t\t\t\tt.subResult[t.subs[i]] = qos\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\ttoken.flowComplete()\n\t\t\t\tc.freeID(m.MessageID)\n\t\t\tcase *packets.UnsubackPacket:\n\t\t\t\tDEBUG.Println(NET, \"startIncomingComms: received unsuback, id:\", m.MessageID)\n\t\t\t\tc.getToken(m.MessageID).flowComplete()\n\t\t\t\tc.freeID(m.MessageID)\n\t\t\tcase *packets.PublishPacket:\n\t\t\t\tDEBUG.Println(NET, \"startIncomingComms: received publish, msgId:\", m.MessageID)\n\t\t\t\toutput <- incomingComms{incomingPub: m}\n\t\t\tcase *packets.PubackPacket:\n\t\t\t\tDEBUG.Println(NET, \"startIncomingComms: received puback, id:\", m.MessageID)\n\t\t\t\tc.getToken(m.MessageID).flowComplete()\n\t\t\t\tc.freeID(m.MessageID)\n\t\t\tcase *packets.PubrecPacket:\n\t\t\t\tDEBUG.Println(NET, \"startIncomingComms: received pubrec, id:\", m.MessageID)\n\t\t\t\tprel := packets.NewControlPacket(packets.Pubrel).(*packets.PubrelPacket)\n\t\t\t\tprel.MessageID = m.MessageID\n\t\t\t\toutput <- incomingComms{outbound: &PacketAndToken{p: prel, t: nil}}\n\t\t\tcase *packets.PubrelPacket:\n\t\t\t\tDEBUG.Println(NET, \"startIncomingComms: received pubrel, id:\", m.MessageID)\n\t\t\t\tpc := packets.NewControlPacket(packets.Pubcomp).(*packets.PubcompPacket)\n\t\t\t\tpc.MessageID = m.MessageID\n\t\t\t\tc.persistOutbound(pc)\n\t\t\t\toutput <- incomingComms{outbound: &PacketAndToken{p: pc, t: nil}}\n\t\t\tcase *packets.PubcompPacket:\n\t\t\t\tDEBUG.Println(NET, \"startIncomingComms: received pubcomp, id:\", m.MessageID)\n\t\t\t\tc.getToken(m.MessageID).flowComplete()\n\t\t\t\tc.freeID(m.MessageID)\n\t\t\t}\n\t\t}\n\t}()\n\treturn output\n}\n\n// startOutgoingComms initiates a go routine to transmit outgoing packets.\n// Pass in an open network connection and channels for outbound messages (including those triggered\n// directly from incoming comms).\n// Returns a channel that will receive details of any errors (closed when the goroutine exits)\n// This function wil only terminate when all input channels are closed\nfunc startOutgoingComms(conn net.Conn,\n\tc commsFns,\n\toboundp <-chan *PacketAndToken,\n\tobound <-chan *PacketAndToken,\n\toboundFromIncoming <-chan *PacketAndToken,\n) <-chan error {\n\terrChan := make(chan error)\n\tDEBUG.Println(NET, \"outgoing started\")\n\n\tgo func() {\n\t\tfor {\n\t\t\tDEBUG.Println(NET, \"outgoing waiting for an outbound message\")\n\n\t\t\t// This goroutine will only exits when all of the input channels we receive on have been closed. This approach is taken to avoid any\n\t\t\t// deadlocks (if the connection goes down there are limited options as to what we can do with anything waiting on us and\n\t\t\t// throwing away the packets seems the best option)\n\t\t\tif oboundp == nil && obound == nil && oboundFromIncoming == nil {\n\t\t\t\tDEBUG.Println(NET, \"outgoing comms stopping\")\n\t\t\t\tclose(errChan)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tselect {\n\t\t\tcase pub, ok := <-obound:\n\t\t\t\tif !ok {\n\t\t\t\t\tobound = nil\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\tmsg := pub.p.(*packets.PublishPacket)\n\t\t\t\tDEBUG.Println(NET, \"obound msg to write\", msg.MessageID)\n\n\t\t\t\twriteTimeout := c.getWriteTimeOut()\n\t\t\t\tif writeTimeout > 0 {\n\t\t\t\t\tif err := conn.SetWriteDeadline(time.Now().Add(writeTimeout)); err != nil {\n\t\t\t\t\t\tERROR.Println(NET, \"SetWriteDeadline \", err)\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif err := msg.Write(conn); err != nil {\n\t\t\t\t\tERROR.Println(NET, \"outgoing obound reporting error \", err)\n\t\t\t\t\tpub.t.setError(err)\n\t\t\t\t\t// report error if it's not due to the connection being closed elsewhere\n\t\t\t\t\tif !strings.Contains(err.Error(), closedNetConnErrorText) {\n\t\t\t\t\t\terrChan <- err\n\t\t\t\t\t}\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\n\t\t\t\tif writeTimeout > 0 {\n\t\t\t\t\t// If we successfully wrote, we don't want the timeout to happen during an idle period\n\t\t\t\t\t// so we reset it to infinite.\n\t\t\t\t\tif err := conn.SetWriteDeadline(time.Time{}); err != nil {\n\t\t\t\t\t\tERROR.Println(NET, \"SetWriteDeadline to 0 \", err)\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif msg.Qos == 0 {\n\t\t\t\t\tpub.t.flowComplete()\n\t\t\t\t}\n\t\t\t\tDEBUG.Println(NET, \"obound wrote msg, id:\", msg.MessageID)\n\t\t\tcase msg, ok := <-oboundp:\n\t\t\t\tif !ok {\n\t\t\t\t\toboundp = nil\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\tDEBUG.Println(NET, \"obound priority msg to write, type\", reflect.TypeOf(msg.p))\n\t\t\t\tif err := msg.p.Write(conn); err != nil {\n\t\t\t\t\tERROR.Println(NET, \"outgoing oboundp reporting error \", err)\n\t\t\t\t\tif msg.t != nil {\n\t\t\t\t\t\tmsg.t.setError(err)\n\t\t\t\t\t}\n\t\t\t\t\terrChan <- err\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\n\t\t\t\tif _, ok := msg.p.(*packets.DisconnectPacket); ok {\n\t\t\t\t\tmsg.t.(*DisconnectToken).flowComplete()\n\t\t\t\t\tDEBUG.Println(NET, \"outbound wrote disconnect, closing connection\")\n\t\t\t\t\t// As per the MQTT spec \"After sending a DISCONNECT Packet the Client MUST close the Network Connection\"\n\t\t\t\t\t// Closing the connection will cause the goroutines to end in sequence (starting with incoming comms)\n\t\t\t\t\t_ = conn.Close()\n\t\t\t\t}\n\t\t\tcase msg, ok := <-oboundFromIncoming: // message triggered by an inbound message (PubrecPacket or PubrelPacket)\n\t\t\t\tif !ok {\n\t\t\t\t\toboundFromIncoming = nil\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\tDEBUG.Println(NET, \"obound from incoming msg to write, type\", reflect.TypeOf(msg.p), \" ID \", msg.p.Details().MessageID)\n\t\t\t\tif err := msg.p.Write(conn); err != nil {\n\t\t\t\t\tERROR.Println(NET, \"outgoing oboundFromIncoming reporting error\", err)\n\t\t\t\t\tif msg.t != nil {\n\t\t\t\t\t\tmsg.t.setError(err)\n\t\t\t\t\t}\n\t\t\t\t\terrChan <- err\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t}\n\t\t\tc.UpdateLastSent() // Record that a packet has been received (for keepalive routine)\n\t\t}\n\t}()\n\treturn errChan\n}\n\n// commsFns provide access to the client state (messageids, requesting disconnection and updating timing)\ntype commsFns interface {\n\tgetToken(id uint16) tokenCompletor       // Retrieve the token for the specified messageid (if none then a dummy token must be returned)\n\tfreeID(id uint16)                        // Release the specified messageid (clearing out of any persistent store)\n\tUpdateLastReceived()                     // Must be called whenever a packet is received\n\tUpdateLastSent()                         // Must be called whenever a packet is successfully sent\n\tgetWriteTimeOut() time.Duration          // Return the writetimeout (or 0 if none)\n\tpersistOutbound(m packets.ControlPacket) // add the packet to the outbound store\n\tpersistInbound(m packets.ControlPacket)  // add the packet to the inbound store\n\tpingRespReceived()                       // Called when a ping response is received\n}\n\n// startComms initiates goroutines that handles communications over the network connection\n// Messages will be stored (via commsFns) and deleted from the store as necessary\n// It returns two channels:\n//\n//\tpackets.PublishPacket - Will receive publish packets received over the network.\n//\tClosed when incoming comms routines exit (on shutdown or if network link closed)\n//\terror - Any errors will be sent on this channel. The channel is closed when all comms routines have shut down\n//\n// Note: The comms routines monitoring oboundp and obound will not shutdown until those channels are both closed. Any messages received between the\n// connection being closed and those channels being closed will generate errors (and nothing will be sent). That way the chance of a deadlock is\n// minimised.\nfunc startComms(conn net.Conn, // Network connection (must be active)\n\tc commsFns, // getters and setters to enable us to cleanly interact with client\n\tinboundFromStore <-chan packets.ControlPacket, // Inbound packets from the persistence store (should be closed relatively soon after startup)\n\toboundp <-chan *PacketAndToken,\n\tobound <-chan *PacketAndToken) (\n\t<-chan *packets.PublishPacket, // Publishpackages received over the network\n\t<-chan error, // Any errors (should generally trigger a disconnect)\n) {\n\t// Start inbound comms handler; this needs to be able to transmit messages so we start a go routine to add these to the priority outbound channel\n\tibound := startIncomingComms(conn, c, inboundFromStore)\n\toutboundFromIncoming := make(chan *PacketAndToken) // Will accept outgoing messages triggered by startIncomingComms (e.g. acknowledgements)\n\n\t// Start the outgoing handler. It is important to note that output from startIncomingComms is fed into startOutgoingComms (for ACK's)\n\toboundErr := startOutgoingComms(conn, c, oboundp, obound, outboundFromIncoming)\n\tDEBUG.Println(NET, \"startComms started\")\n\n\t// Run up go routines to handle the output from the above comms functions - these are handled in separate\n\t// go routines because they can interact (e.g. ibound triggers an ACK to obound which triggers an error)\n\tvar wg sync.WaitGroup\n\twg.Add(2)\n\n\toutPublish := make(chan *packets.PublishPacket)\n\toutError := make(chan error)\n\n\t// Any messages received get passed to the appropriate channel\n\tgo func() {\n\t\tfor ic := range ibound {\n\t\t\tif ic.err != nil {\n\t\t\t\toutError <- ic.err\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif ic.outbound != nil {\n\t\t\t\toutboundFromIncoming <- ic.outbound\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif ic.incomingPub != nil {\n\t\t\t\toutPublish <- ic.incomingPub\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tERROR.Println(STR, \"startComms received empty incomingComms msg\")\n\t\t}\n\t\t// Close channels that will not be written to again (allowing other routines to exit)\n\t\tclose(outboundFromIncoming)\n\t\tclose(outPublish)\n\t\twg.Done()\n\t}()\n\n\t// Any errors will be passed out to our caller\n\tgo func() {\n\t\tfor err := range oboundErr {\n\t\t\toutError <- err\n\t\t}\n\t\twg.Done()\n\t}()\n\n\t// outError is used by both routines so can only be closed when they are both complete\n\tgo func() {\n\t\twg.Wait()\n\t\tclose(outError)\n\t\tDEBUG.Println(NET, \"startComms closing outError\")\n\t}()\n\n\treturn outPublish, outError\n}\n\n// ackFunc acknowledges a packet\n// WARNING the function returned must not be called if the comms routine is shutting down or not running\n// (it needs outgoing comms in order to send the acknowledgement). Currently this is only called from\n// matchAndDispatch which will be shutdown before the comms are\nfunc ackFunc(oboundP chan *PacketAndToken, persist Store, packet *packets.PublishPacket) func() {\n\treturn func() {\n\t\tswitch packet.Qos {\n\t\tcase 2:\n\t\t\tpr := packets.NewControlPacket(packets.Pubrec).(*packets.PubrecPacket)\n\t\t\tpr.MessageID = packet.MessageID\n\t\t\tDEBUG.Println(NET, \"putting pubrec msg on obound\")\n\t\t\toboundP <- &PacketAndToken{p: pr, t: nil}\n\t\t\tDEBUG.Println(NET, \"done putting pubrec msg on obound\")\n\t\tcase 1:\n\t\t\tpa := packets.NewControlPacket(packets.Puback).(*packets.PubackPacket)\n\t\t\tpa.MessageID = packet.MessageID\n\t\t\tDEBUG.Println(NET, \"putting puback msg on obound\")\n\t\t\tpersistOutbound(persist, pa)\n\t\t\toboundP <- &PacketAndToken{p: pa, t: nil}\n\t\t\tDEBUG.Println(NET, \"done putting puback msg on obound\")\n\t\tcase 0:\n\t\t\t// do nothing, since there is no need to send an ack packet back\n\t\t}\n\t}\n}\n"
        },
        {
          "name": "netconn.go",
          "type": "blob",
          "size": 2.875,
          "content": "/*\n * Copyright (c) 2021 IBM Corp and others.\n *\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v2.0\n * and Eclipse Distribution License v1.0 which accompany this distribution.\n *\n * The Eclipse Public License is available at\n *    https://www.eclipse.org/legal/epl-2.0/\n * and the Eclipse Distribution License is available at\n *   http://www.eclipse.org/org/documents/edl-v10.php.\n *\n * Contributors:\n *    Seth Hoenig\n *    Allan Stockdill-Mander\n *    Mike Robertson\n *    MAtt Brittan\n */\n\npackage mqtt\n\nimport (\n\t\"crypto/tls\"\n\t\"errors\"\n\t\"net\"\n\t\"net/http\"\n\t\"net/url\"\n\t\"os\"\n\t\"time\"\n\n\t\"golang.org/x/net/proxy\"\n)\n\n//\n// This just establishes the network connection; once established the type of connection should be irrelevant\n//\n\n// openConnection opens a network connection using the protocol indicated in the URL.\n// Does not carry out any MQTT specific handshakes.\nfunc openConnection(uri *url.URL, tlsc *tls.Config, timeout time.Duration, headers http.Header, websocketOptions *WebsocketOptions, dialer *net.Dialer) (net.Conn, error) {\n\tswitch uri.Scheme {\n\tcase \"ws\":\n\t\tdialURI := *uri // #623 - Gorilla Websockets does not accept URL's where uri.User != nil\n\t\tdialURI.User = nil\n\t\tconn, err := NewWebsocket(dialURI.String(), nil, timeout, headers, websocketOptions)\n\t\treturn conn, err\n\tcase \"wss\":\n\t\tdialURI := *uri // #623 - Gorilla Websockets does not accept URL's where uri.User != nil\n\t\tdialURI.User = nil\n\t\tconn, err := NewWebsocket(dialURI.String(), tlsc, timeout, headers, websocketOptions)\n\t\treturn conn, err\n\tcase \"mqtt\", \"tcp\":\n\t\tallProxy := os.Getenv(\"all_proxy\")\n\t\tif len(allProxy) == 0 {\n\t\t\tconn, err := dialer.Dial(\"tcp\", uri.Host)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\treturn conn, nil\n\t\t}\n\t\tproxyDialer := proxy.FromEnvironment()\n\n\t\tconn, err := proxyDialer.Dial(\"tcp\", uri.Host)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\treturn conn, nil\n\tcase \"unix\":\n\t\tvar conn net.Conn\n\t\tvar err error\n\n\t\t// this check is preserved for compatibility with older versions\n\t\t// which used uri.Host only (it works for local paths, e.g. unix://socket.sock in current dir)\n\t\tif len(uri.Host) > 0 {\n\t\t\tconn, err = dialer.Dial(\"unix\", uri.Host)\n\t\t} else {\n\t\t\tconn, err = dialer.Dial(\"unix\", uri.Path)\n\t\t}\n\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\treturn conn, nil\n\tcase \"ssl\", \"tls\", \"mqtts\", \"mqtt+ssl\", \"tcps\":\n\t\tallProxy := os.Getenv(\"all_proxy\")\n\t\tif len(allProxy) == 0 {\n\t\t\tconn, err := tls.DialWithDialer(dialer, \"tcp\", uri.Host, tlsc)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\treturn conn, nil\n\t\t}\n\t\tproxyDialer := proxy.FromEnvironment()\n\t\tconn, err := proxyDialer.Dial(\"tcp\", uri.Host)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\ttlsConn := tls.Client(conn, tlsc)\n\n\t\terr = tlsConn.Handshake()\n\t\tif err != nil {\n\t\t\t_ = conn.Close()\n\t\t\treturn nil, err\n\t\t}\n\n\t\treturn tlsConn, nil\n\t}\n\treturn nil, errors.New(\"unknown protocol\")\n}\n"
        },
        {
          "name": "oops.go",
          "type": "blob",
          "size": 0.6171875,
          "content": "/*\n * Copyright (c) 2021 IBM Corp and others.\n *\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v2.0\n * and Eclipse Distribution License v1.0 which accompany this distribution.\n *\n * The Eclipse Public License is available at\n *    https://www.eclipse.org/legal/epl-2.0/\n * and the Eclipse Distribution License is available at\n *   http://www.eclipse.org/org/documents/edl-v10.php.\n *\n * Contributors:\n *    Seth Hoenig\n *    Allan Stockdill-Mander\n *    Mike Robertson\n */\n\npackage mqtt\n\nfunc chkerr(e error) {\n\tif e != nil {\n\t\tpanic(e)\n\t}\n}\n"
        },
        {
          "name": "options.go",
          "type": "blob",
          "size": 17.8251953125,
          "content": "/*\n * Copyright (c) 2021 IBM Corp and others.\n *\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v2.0\n * and Eclipse Distribution License v1.0 which accompany this distribution.\n *\n * The Eclipse Public License is available at\n *    https://www.eclipse.org/legal/epl-2.0/\n * and the Eclipse Distribution License is available at\n *   http://www.eclipse.org/org/documents/edl-v10.php.\n *\n * Contributors:\n *    Seth Hoenig\n *    Allan Stockdill-Mander\n *    Mike Robertson\n *    Måns Ansgariusson\n */\n\n// Portions copyright © 2018 TIBCO Software Inc.\n\npackage mqtt\n\nimport (\n\t\"crypto/tls\"\n\t\"net\"\n\t\"net/http\"\n\t\"net/url\"\n\t\"strings\"\n\t\"time\"\n)\n\n// CredentialsProvider allows the username and password to be updated\n// before reconnecting. It should return the current username and password.\ntype CredentialsProvider func() (username string, password string)\n\n// MessageHandler is a callback type which can be set to be\n// executed upon the arrival of messages published to topics\n// to which the client is subscribed.\ntype MessageHandler func(Client, Message)\n\n// ConnectionLostHandler is a callback type which can be set to be\n// executed upon an unintended disconnection from the MQTT broker.\n// Disconnects caused by calling Disconnect or ForceDisconnect will\n// not cause an OnConnectionLost callback to execute.\ntype ConnectionLostHandler func(Client, error)\n\n// OnConnectHandler is a callback that is called when the client\n// state changes from unconnected/disconnected to connected. Both\n// at initial connection and on reconnection\ntype OnConnectHandler func(Client)\n\n// ReconnectHandler is invoked prior to reconnecting after\n// the initial connection is lost\ntype ReconnectHandler func(Client, *ClientOptions)\n\n// ConnectionAttemptHandler is invoked prior to making the initial connection.\ntype ConnectionAttemptHandler func(broker *url.URL, tlsCfg *tls.Config) *tls.Config\n\n// OpenConnectionFunc is invoked to establish the underlying network connection\n// Its purpose if for custom network transports.\n// Does not carry out any MQTT specific handshakes.\ntype OpenConnectionFunc func(uri *url.URL, options ClientOptions) (net.Conn, error)\n\n// ClientOptions contains configurable options for an Client. Note that these should be set using the\n// relevant methods (e.g. AddBroker) rather than directly. See those functions for information on usage.\n// WARNING: Create the below using NewClientOptions unless you have a compelling reason not to. It is easy\n// to create a configuration with difficult to trace issues (e.g. Mosquitto 2.0.12+ will reject connections\n// with KeepAlive=0 by default).\ntype ClientOptions struct {\n\tServers                 []*url.URL\n\tClientID                string\n\tUsername                string\n\tPassword                string\n\tCredentialsProvider     CredentialsProvider\n\tCleanSession            bool\n\tOrder                   bool\n\tWillEnabled             bool\n\tWillTopic               string\n\tWillPayload             []byte\n\tWillQos                 byte\n\tWillRetained            bool\n\tProtocolVersion         uint\n\tprotocolVersionExplicit bool\n\tTLSConfig               *tls.Config\n\tKeepAlive               int64 // Warning: Some brokers may reject connections with Keepalive = 0.\n\tPingTimeout             time.Duration\n\tConnectTimeout          time.Duration\n\tMaxReconnectInterval    time.Duration\n\tAutoReconnect           bool\n\tConnectRetryInterval    time.Duration\n\tConnectRetry            bool\n\tStore                   Store\n\tDefaultPublishHandler   MessageHandler\n\tOnConnect               OnConnectHandler\n\tOnConnectionLost        ConnectionLostHandler\n\tOnReconnecting          ReconnectHandler\n\tOnConnectAttempt        ConnectionAttemptHandler\n\tWriteTimeout            time.Duration\n\tMessageChannelDepth     uint\n\tResumeSubs              bool\n\tHTTPHeaders             http.Header\n\tWebsocketOptions        *WebsocketOptions\n\tMaxResumePubInFlight    int // // 0 = no limit; otherwise this is the maximum simultaneous messages sent while resuming\n\tDialer                  *net.Dialer\n\tCustomOpenConnectionFn  OpenConnectionFunc\n\tAutoAckDisabled         bool\n}\n\n// NewClientOptions will create a new ClientClientOptions type with some\n// default values.\n//   Port: 1883\n//   CleanSession: True\n//   Order: True (note: it is recommended that this be set to FALSE unless order is important)\n//   KeepAlive: 30 (seconds)\n//   ConnectTimeout: 30 (seconds)\n//   MaxReconnectInterval 10 (minutes)\n//   AutoReconnect: True\nfunc NewClientOptions() *ClientOptions {\n\to := &ClientOptions{\n\t\tServers:                 nil,\n\t\tClientID:                \"\",\n\t\tUsername:                \"\",\n\t\tPassword:                \"\",\n\t\tCleanSession:            true,\n\t\tOrder:                   true,\n\t\tWillEnabled:             false,\n\t\tWillTopic:               \"\",\n\t\tWillPayload:             nil,\n\t\tWillQos:                 0,\n\t\tWillRetained:            false,\n\t\tProtocolVersion:         0,\n\t\tprotocolVersionExplicit: false,\n\t\tKeepAlive:               30,\n\t\tPingTimeout:             10 * time.Second,\n\t\tConnectTimeout:          30 * time.Second,\n\t\tMaxReconnectInterval:    10 * time.Minute,\n\t\tAutoReconnect:           true,\n\t\tConnectRetryInterval:    30 * time.Second,\n\t\tConnectRetry:            false,\n\t\tStore:                   nil,\n\t\tOnConnect:               nil,\n\t\tOnConnectionLost:        DefaultConnectionLostHandler,\n\t\tOnConnectAttempt:        nil,\n\t\tWriteTimeout:            0, // 0 represents timeout disabled\n\t\tResumeSubs:              false,\n\t\tHTTPHeaders:             make(map[string][]string),\n\t\tWebsocketOptions:        &WebsocketOptions{},\n\t\tDialer:                  &net.Dialer{Timeout: 30 * time.Second},\n\t\tCustomOpenConnectionFn:  nil,\n\t\tAutoAckDisabled:         false,\n\t}\n\treturn o\n}\n\n// AddBroker adds a broker URI to the list of brokers to be used. The format should be\n// scheme://host:port\n// Where \"scheme\" is one of \"tcp\", \"ssl\", or \"ws\", \"host\" is the ip-address (or hostname)\n// and \"port\" is the port on which the broker is accepting connections.\n//\n// Default values for hostname is \"127.0.0.1\", for schema is \"tcp://\".\n//\n// An example broker URI would look like: tcp://foobar.com:1883\nfunc (o *ClientOptions) AddBroker(server string) *ClientOptions {\n\tif len(server) > 0 && server[0] == ':' {\n\t\tserver = \"127.0.0.1\" + server\n\t}\n\tif !strings.Contains(server, \"://\") {\n\t\tserver = \"tcp://\" + server\n\t}\n\tbrokerURI, err := url.Parse(server)\n\tif err != nil {\n\t\tERROR.Println(CLI, \"Failed to parse %q broker address: %s\", server, err)\n\t\treturn o\n\t}\n\to.Servers = append(o.Servers, brokerURI)\n\treturn o\n}\n\n// SetResumeSubs will enable resuming of stored (un)subscribe messages when connecting\n// but not reconnecting if CleanSession is false. Otherwise these messages are discarded.\nfunc (o *ClientOptions) SetResumeSubs(resume bool) *ClientOptions {\n\to.ResumeSubs = resume\n\treturn o\n}\n\n// SetClientID will set the client id to be used by this client when\n// connecting to the MQTT broker. According to the MQTT v3.1 specification,\n// a client id must be no longer than 23 characters.\nfunc (o *ClientOptions) SetClientID(id string) *ClientOptions {\n\to.ClientID = id\n\treturn o\n}\n\n// SetUsername will set the username to be used by this client when connecting\n// to the MQTT broker. Note: without the use of SSL/TLS, this information will\n// be sent in plaintext across the wire.\nfunc (o *ClientOptions) SetUsername(u string) *ClientOptions {\n\to.Username = u\n\treturn o\n}\n\n// SetPassword will set the password to be used by this client when connecting\n// to the MQTT broker. Note: without the use of SSL/TLS, this information will\n// be sent in plaintext across the wire.\nfunc (o *ClientOptions) SetPassword(p string) *ClientOptions {\n\to.Password = p\n\treturn o\n}\n\n// SetCredentialsProvider will set a method to be called by this client when\n// connecting to the MQTT broker that provide the current username and password.\n// Note: without the use of SSL/TLS, this information will be sent\n// in plaintext across the wire.\nfunc (o *ClientOptions) SetCredentialsProvider(p CredentialsProvider) *ClientOptions {\n\to.CredentialsProvider = p\n\treturn o\n}\n\n// SetCleanSession will set the \"clean session\" flag in the connect message\n// when this client connects to an MQTT broker. By setting this flag, you are\n// indicating that no messages saved by the broker for this client should be\n// delivered. Any messages that were going to be sent by this client before\n// disconnecting previously but didn't will not be sent upon connecting to the\n// broker.\nfunc (o *ClientOptions) SetCleanSession(clean bool) *ClientOptions {\n\to.CleanSession = clean\n\treturn o\n}\n\n// SetOrderMatters will set the message routing to guarantee order within\n// each QoS level. By default, this value is true. If set to false (recommended),\n// this flag indicates that messages can be delivered asynchronously\n// from the client to the application and possibly arrive out of order.\n// Specifically, the message handler is called in its own go routine.\n// Note that setting this to true does not guarantee in-order delivery\n// (this is subject to broker settings like \"max_inflight_messages=1\" in mosquitto)\n// and if true then handlers must not block.\nfunc (o *ClientOptions) SetOrderMatters(order bool) *ClientOptions {\n\to.Order = order\n\treturn o\n}\n\n// SetTLSConfig will set an SSL/TLS configuration to be used when connecting\n// to an MQTT broker. Please read the official Go documentation for more\n// information.\nfunc (o *ClientOptions) SetTLSConfig(t *tls.Config) *ClientOptions {\n\to.TLSConfig = t\n\treturn o\n}\n\n// SetStore will set the implementation of the Store interface\n// used to provide message persistence in cases where QoS levels\n// QoS_ONE or QoS_TWO are used. If no store is provided, then the\n// client will use MemoryStore by default.\nfunc (o *ClientOptions) SetStore(s Store) *ClientOptions {\n\to.Store = s\n\treturn o\n}\n\n// SetKeepAlive will set the amount of time (in seconds) that the client\n// should wait before sending a PING request to the broker. This will\n// allow the client to know that a connection has not been lost with the\n// server.\nfunc (o *ClientOptions) SetKeepAlive(k time.Duration) *ClientOptions {\n\to.KeepAlive = int64(k / time.Second)\n\treturn o\n}\n\n// SetPingTimeout will set the amount of time (in seconds) that the client\n// will wait after sending a PING request to the broker, before deciding\n// that the connection has been lost. Default is 10 seconds.\nfunc (o *ClientOptions) SetPingTimeout(k time.Duration) *ClientOptions {\n\to.PingTimeout = k\n\treturn o\n}\n\n// SetProtocolVersion sets the MQTT version to be used to connect to the\n// broker. Legitimate values are currently 3 - MQTT 3.1 or 4 - MQTT 3.1.1\nfunc (o *ClientOptions) SetProtocolVersion(pv uint) *ClientOptions {\n\tif (pv >= 3 && pv <= 4) || (pv > 0x80) {\n\t\to.ProtocolVersion = pv\n\t\to.protocolVersionExplicit = true\n\t}\n\treturn o\n}\n\n// UnsetWill will cause any set will message to be disregarded.\nfunc (o *ClientOptions) UnsetWill() *ClientOptions {\n\to.WillEnabled = false\n\treturn o\n}\n\n// SetWill accepts a string will message to be set. When the client connects,\n// it will give this will message to the broker, which will then publish the\n// provided payload (the will) to any clients that are subscribed to the provided\n// topic.\nfunc (o *ClientOptions) SetWill(topic string, payload string, qos byte, retained bool) *ClientOptions {\n\to.SetBinaryWill(topic, []byte(payload), qos, retained)\n\treturn o\n}\n\n// SetBinaryWill accepts a []byte will message to be set. When the client connects,\n// it will give this will message to the broker, which will then publish the\n// provided payload (the will) to any clients that are subscribed to the provided\n// topic.\nfunc (o *ClientOptions) SetBinaryWill(topic string, payload []byte, qos byte, retained bool) *ClientOptions {\n\to.WillEnabled = true\n\to.WillTopic = topic\n\to.WillPayload = payload\n\to.WillQos = qos\n\to.WillRetained = retained\n\treturn o\n}\n\n// SetDefaultPublishHandler sets the MessageHandler that will be called when a message\n// is received that does not match any known subscriptions.\n//\n// If OrderMatters is true (the defaultHandler) then callback must not block or\n// call functions within this package that may block (e.g. Publish) other than in\n// a new go routine.\n// defaultHandler must be safe for concurrent use by multiple goroutines.\nfunc (o *ClientOptions) SetDefaultPublishHandler(defaultHandler MessageHandler) *ClientOptions {\n\to.DefaultPublishHandler = defaultHandler\n\treturn o\n}\n\n// SetOnConnectHandler sets the function to be called when the client is connected. Both\n// at initial connection time and upon automatic reconnect.\nfunc (o *ClientOptions) SetOnConnectHandler(onConn OnConnectHandler) *ClientOptions {\n\to.OnConnect = onConn\n\treturn o\n}\n\n// SetConnectionLostHandler will set the OnConnectionLost callback to be executed\n// in the case where the client unexpectedly loses connection with the MQTT broker.\nfunc (o *ClientOptions) SetConnectionLostHandler(onLost ConnectionLostHandler) *ClientOptions {\n\to.OnConnectionLost = onLost\n\treturn o\n}\n\n// SetReconnectingHandler sets the OnReconnecting callback to be executed prior\n// to the client attempting a reconnect to the MQTT broker.\nfunc (o *ClientOptions) SetReconnectingHandler(cb ReconnectHandler) *ClientOptions {\n\to.OnReconnecting = cb\n\treturn o\n}\n\n// SetConnectionAttemptHandler sets the ConnectionAttemptHandler callback to be executed prior\n// to each attempt to connect to an MQTT broker. Returns the *tls.Config that will be used when establishing\n// the connection (a copy of the tls.Config from ClientOptions will be passed in along with the broker URL).\n// This allows connection specific changes to be made to the *tls.Config.\nfunc (o *ClientOptions) SetConnectionAttemptHandler(onConnectAttempt ConnectionAttemptHandler) *ClientOptions {\n\to.OnConnectAttempt = onConnectAttempt\n\treturn o\n}\n\n// SetWriteTimeout puts a limit on how long a mqtt publish should block until it unblocks with a\n// timeout error. A duration of 0 never times out. Default never times out\nfunc (o *ClientOptions) SetWriteTimeout(t time.Duration) *ClientOptions {\n\to.WriteTimeout = t\n\treturn o\n}\n\n// SetConnectTimeout limits how long the client will wait when trying to open a connection\n// to an MQTT server before timing out. A duration of 0 never times out.\n// Default 30 seconds. Currently only operational on TCP/TLS connections.\nfunc (o *ClientOptions) SetConnectTimeout(t time.Duration) *ClientOptions {\n\to.ConnectTimeout = t\n\to.Dialer.Timeout = t\n\treturn o\n}\n\n// SetMaxReconnectInterval sets the maximum time that will be waited between reconnection attempts\n// when connection is lost\nfunc (o *ClientOptions) SetMaxReconnectInterval(t time.Duration) *ClientOptions {\n\to.MaxReconnectInterval = t\n\treturn o\n}\n\n// SetAutoReconnect sets whether the automatic reconnection logic should be used\n// when the connection is lost, even if disabled the ConnectionLostHandler is still\n// called\nfunc (o *ClientOptions) SetAutoReconnect(a bool) *ClientOptions {\n\to.AutoReconnect = a\n\treturn o\n}\n\n// SetConnectRetryInterval sets the time that will be waited between connection attempts\n// when initially connecting if ConnectRetry is TRUE\nfunc (o *ClientOptions) SetConnectRetryInterval(t time.Duration) *ClientOptions {\n\to.ConnectRetryInterval = t\n\treturn o\n}\n\n// SetConnectRetry sets whether the connect function will automatically retry the connection\n// in the event of a failure (when true the token returned by the Connect function will\n// not complete until the connection is up or it is cancelled)\n// If ConnectRetry is true then subscriptions should be requested in OnConnect handler\n// Setting this to TRUE permits messages to be published before the connection is established\nfunc (o *ClientOptions) SetConnectRetry(a bool) *ClientOptions {\n\to.ConnectRetry = a\n\treturn o\n}\n\n// SetMessageChannelDepth DEPRECATED The value set here no longer has any effect, this function\n// remains so the API is not altered.\nfunc (o *ClientOptions) SetMessageChannelDepth(s uint) *ClientOptions {\n\to.MessageChannelDepth = s\n\treturn o\n}\n\n// SetHTTPHeaders sets the additional HTTP headers that will be sent in the WebSocket\n// opening handshake.\nfunc (o *ClientOptions) SetHTTPHeaders(h http.Header) *ClientOptions {\n\to.HTTPHeaders = h\n\treturn o\n}\n\n// SetWebsocketOptions sets the additional websocket options used in a WebSocket connection\nfunc (o *ClientOptions) SetWebsocketOptions(w *WebsocketOptions) *ClientOptions {\n\to.WebsocketOptions = w\n\treturn o\n}\n\n// SetMaxResumePubInFlight sets the maximum simultaneous publish messages that will be sent while resuming. Note that\n// this only applies to messages coming from the store (so additional sends may push us over the limit)\n// Note that the connect token will not be flagged as complete until all messages have been sent from the\n// store. If broker does not respond to messages then resume may not complete.\n// This option was put in place because resuming after downtime can saturate low capacity links.\nfunc (o *ClientOptions) SetMaxResumePubInFlight(MaxResumePubInFlight int) *ClientOptions {\n\to.MaxResumePubInFlight = MaxResumePubInFlight\n\treturn o\n}\n\n// SetDialer sets the tcp dialer options used in a tcp connection\nfunc (o *ClientOptions) SetDialer(dialer *net.Dialer) *ClientOptions {\n\to.Dialer = dialer\n\treturn o\n}\n\n// SetCustomOpenConnectionFn replaces the inbuilt function that establishes a network connection with a custom function.\n// The passed in function should return an open `net.Conn` or an error (see the existing openConnection function for an example)\n// It enables custom networking types in addition to the defaults (tcp, tls, websockets...)\nfunc (o *ClientOptions) SetCustomOpenConnectionFn(customOpenConnectionFn OpenConnectionFunc) *ClientOptions {\n\tif customOpenConnectionFn != nil {\n\t\to.CustomOpenConnectionFn = customOpenConnectionFn\n\t}\n\treturn o\n}\n\n// SetAutoAckDisabled enables or disables the Automated Acking of Messages received by the handler.\n//\tBy default it is set to false. Setting it to true will disable the auto-ack globally.\nfunc (o *ClientOptions) SetAutoAckDisabled(autoAckDisabled bool) *ClientOptions {\n\to.AutoAckDisabled = autoAckDisabled\n\treturn o\n}\n"
        },
        {
          "name": "options_reader.go",
          "type": "blob",
          "size": 4.271484375,
          "content": "/*\n * Copyright (c) 2021 IBM Corp and others.\n *\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v2.0\n * and Eclipse Distribution License v1.0 which accompany this distribution.\n *\n * The Eclipse Public License is available at\n *    https://www.eclipse.org/legal/epl-2.0/\n * and the Eclipse Distribution License is available at\n *   http://www.eclipse.org/org/documents/edl-v10.php.\n *\n * Contributors:\n *    Seth Hoenig\n *    Allan Stockdill-Mander\n *    Mike Robertson\n */\n\npackage mqtt\n\nimport (\n\t\"crypto/tls\"\n\t\"net/http\"\n\t\"net/url\"\n\t\"time\"\n)\n\n// ClientOptionsReader provides an interface for reading ClientOptions after the client has been initialized.\ntype ClientOptionsReader struct {\n\toptions *ClientOptions\n}\n\n// NewOptionsReader creates a ClientOptionsReader, this should only be used for mocking purposes.\n//\n// An example implementation:\n//\n//\tfunc (c *mqttClientMock) OptionsReader() mqtt.ClientOptionsReader {\n//\t\topts := mqtt.NewClientOptions()\n//\t\topts.UserName = \"TestUserName\"\n//\t\treturn mqtt.NewOptionsReader(opts)\n//\t}\nfunc NewOptionsReader(o *ClientOptions) ClientOptionsReader {\n\treturn ClientOptionsReader{\n\t\toptions: o,\n\t}\n}\n\n// Servers returns a slice of the servers defined in the clientoptions\nfunc (r *ClientOptionsReader) Servers() []*url.URL {\n\ts := make([]*url.URL, len(r.options.Servers))\n\n\tfor i, u := range r.options.Servers {\n\t\tnu := *u\n\t\ts[i] = &nu\n\t}\n\n\treturn s\n}\n\n// ResumeSubs returns true if resuming stored (un)sub is enabled\nfunc (r *ClientOptionsReader) ResumeSubs() bool {\n\ts := r.options.ResumeSubs\n\treturn s\n}\n\n// ClientID returns the set client id\nfunc (r *ClientOptionsReader) ClientID() string {\n\ts := r.options.ClientID\n\treturn s\n}\n\n// Username returns the set username\nfunc (r *ClientOptionsReader) Username() string {\n\ts := r.options.Username\n\treturn s\n}\n\n// Password returns the set password\nfunc (r *ClientOptionsReader) Password() string {\n\ts := r.options.Password\n\treturn s\n}\n\n// CleanSession returns whether Cleansession is set\nfunc (r *ClientOptionsReader) CleanSession() bool {\n\ts := r.options.CleanSession\n\treturn s\n}\n\nfunc (r *ClientOptionsReader) Order() bool {\n\ts := r.options.Order\n\treturn s\n}\n\nfunc (r *ClientOptionsReader) WillEnabled() bool {\n\ts := r.options.WillEnabled\n\treturn s\n}\n\nfunc (r *ClientOptionsReader) WillTopic() string {\n\ts := r.options.WillTopic\n\treturn s\n}\n\nfunc (r *ClientOptionsReader) WillPayload() []byte {\n\ts := r.options.WillPayload\n\treturn s\n}\n\nfunc (r *ClientOptionsReader) WillQos() byte {\n\ts := r.options.WillQos\n\treturn s\n}\n\nfunc (r *ClientOptionsReader) WillRetained() bool {\n\ts := r.options.WillRetained\n\treturn s\n}\n\nfunc (r *ClientOptionsReader) ProtocolVersion() uint {\n\ts := r.options.ProtocolVersion\n\treturn s\n}\n\nfunc (r *ClientOptionsReader) TLSConfig() *tls.Config {\n\ts := r.options.TLSConfig\n\treturn s\n}\n\nfunc (r *ClientOptionsReader) KeepAlive() time.Duration {\n\ts := time.Duration(r.options.KeepAlive * int64(time.Second))\n\treturn s\n}\n\nfunc (r *ClientOptionsReader) PingTimeout() time.Duration {\n\ts := r.options.PingTimeout\n\treturn s\n}\n\nfunc (r *ClientOptionsReader) ConnectTimeout() time.Duration {\n\ts := r.options.ConnectTimeout\n\treturn s\n}\n\nfunc (r *ClientOptionsReader) MaxReconnectInterval() time.Duration {\n\ts := r.options.MaxReconnectInterval\n\treturn s\n}\n\nfunc (r *ClientOptionsReader) AutoReconnect() bool {\n\ts := r.options.AutoReconnect\n\treturn s\n}\n\n// ConnectRetryInterval returns the delay between retries on the initial connection (if ConnectRetry true)\nfunc (r *ClientOptionsReader) ConnectRetryInterval() time.Duration {\n\ts := r.options.ConnectRetryInterval\n\treturn s\n}\n\n// ConnectRetry returns whether the initial connection request will be retried until connection established\nfunc (r *ClientOptionsReader) ConnectRetry() bool {\n\ts := r.options.ConnectRetry\n\treturn s\n}\n\nfunc (r *ClientOptionsReader) WriteTimeout() time.Duration {\n\ts := r.options.WriteTimeout\n\treturn s\n}\n\nfunc (r *ClientOptionsReader) MessageChannelDepth() uint {\n\ts := r.options.MessageChannelDepth\n\treturn s\n}\n\nfunc (r *ClientOptionsReader) HTTPHeaders() http.Header {\n\th := r.options.HTTPHeaders\n\treturn h\n}\n\n// WebsocketOptions returns the currently configured WebSocket options\nfunc (r *ClientOptionsReader) WebsocketOptions() *WebsocketOptions {\n\ts := r.options.WebsocketOptions\n\treturn s\n}\n"
        },
        {
          "name": "options_test.go",
          "type": "blob",
          "size": 1.107421875,
          "content": "/*\n * Copyright (c) 2021 IBM Corp and others.\n *\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v2.0\n * and Eclipse Distribution License v1.0 which accompany this distribution.\n *\n * The Eclipse Public License is available at\n *    https://www.eclipse.org/legal/epl-2.0/\n * and the Eclipse Distribution License is available at\n *   http://www.eclipse.org/org/documents/edl-v10.php.\n *\n * Contributors:\n *    Seth Hoenig\n *    Allan Stockdill-Mander\n *    Mike Robertson\n *    Måns Ansgariusson\n */\n\n// Portions copyright © 2018 TIBCO Software Inc.\npackage mqtt\n\nimport (\n\t\"fmt\"\n\t\"net\"\n\t\"net/url\"\n\t\"testing\"\n)\n\nfunc TestSetCustomConnectionOptions(t *testing.T) {\n\tvar customConnectionFunc OpenConnectionFunc = func(uri *url.URL, options ClientOptions) (net.Conn, error) {\n\t\treturn nil, fmt.Errorf(\"not implemented open connection func\")\n\t}\n\toptions := &ClientOptions{}\n\toptions = options.SetCustomOpenConnectionFn(customConnectionFunc)\n\tif options.CustomOpenConnectionFn == nil {\n\t\tt.Error(\"custom open connection function cannot be set\")\n\t}\n}\n"
        },
        {
          "name": "packets",
          "type": "tree",
          "content": null
        },
        {
          "name": "ping.go",
          "type": "blob",
          "size": 2.4638671875,
          "content": "/*\n * Copyright (c) 2021 IBM Corp and others.\n *\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v2.0\n * and Eclipse Distribution License v1.0 which accompany this distribution.\n *\n * The Eclipse Public License is available at\n *    https://www.eclipse.org/legal/epl-2.0/\n * and the Eclipse Distribution License is available at\n *   http://www.eclipse.org/org/documents/edl-v10.php.\n *\n * Contributors:\n *    Seth Hoenig\n *    Allan Stockdill-Mander\n *    Mike Robertson\n */\n\npackage mqtt\n\nimport (\n\t\"errors\"\n\t\"io\"\n\t\"sync/atomic\"\n\t\"time\"\n\n\t\"github.com/eclipse/paho.mqtt.golang/packets\"\n)\n\n// keepalive - Send ping when connection unused for set period\n// connection passed in to avoid race condition on shutdown\nfunc keepalive(c *client, conn io.Writer) {\n\tdefer c.workers.Done()\n\tDEBUG.Println(PNG, \"keepalive starting\")\n\tvar checkInterval time.Duration\n\tvar pingSent time.Time\n\n\tif c.options.KeepAlive > 10 {\n\t\tcheckInterval = 5 * time.Second\n\t} else {\n\t\tcheckInterval = time.Duration(c.options.KeepAlive) * time.Second / 4\n\t}\n\n\tintervalTicker := time.NewTicker(checkInterval)\n\tdefer intervalTicker.Stop()\n\n\tfor {\n\t\tselect {\n\t\tcase <-c.stop:\n\t\t\tDEBUG.Println(PNG, \"keepalive stopped\")\n\t\t\treturn\n\t\tcase <-intervalTicker.C:\n\t\t\tlastSent := c.lastSent.Load().(time.Time)\n\t\t\tlastReceived := c.lastReceived.Load().(time.Time)\n\n\t\t\tDEBUG.Println(PNG, \"ping check\", time.Since(lastSent).Seconds())\n\t\t\tif time.Since(lastSent) >= time.Duration(c.options.KeepAlive*int64(time.Second)) || time.Since(lastReceived) >= time.Duration(c.options.KeepAlive*int64(time.Second)) {\n\t\t\t\tif atomic.LoadInt32(&c.pingOutstanding) == 0 {\n\t\t\t\t\tDEBUG.Println(PNG, \"keepalive sending ping\")\n\t\t\t\t\tping := packets.NewControlPacket(packets.Pingreq).(*packets.PingreqPacket)\n\t\t\t\t\t// We don't want to wait behind large messages being sent, the `Write` call\n\t\t\t\t\t// will block until it is able to send the packet.\n\t\t\t\t\tatomic.StoreInt32(&c.pingOutstanding, 1)\n\t\t\t\t\tif err := ping.Write(conn); err != nil {\n\t\t\t\t\t\tERROR.Println(PNG, err)\n\t\t\t\t\t}\n\t\t\t\t\tc.lastSent.Store(time.Now())\n\t\t\t\t\tpingSent = time.Now()\n\t\t\t\t}\n\t\t\t}\n\t\t\tif atomic.LoadInt32(&c.pingOutstanding) > 0 && time.Since(pingSent) >= c.options.PingTimeout {\n\t\t\t\tCRITICAL.Println(PNG, \"pingresp not received, disconnecting\")\n\t\t\t\tc.internalConnLost(errors.New(\"pingresp not received, disconnecting\")) // no harm in calling this if the connection is already down (or shutdown is in progress)\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t}\n}\n"
        },
        {
          "name": "router.go",
          "type": "blob",
          "size": 7.4609375,
          "content": "/*\n * Copyright (c) 2021 IBM Corp and others.\n *\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v2.0\n * and Eclipse Distribution License v1.0 which accompany this distribution.\n *\n * The Eclipse Public License is available at\n *    https://www.eclipse.org/legal/epl-2.0/\n * and the Eclipse Distribution License is available at\n *   http://www.eclipse.org/org/documents/edl-v10.php.\n *\n * Contributors:\n *    Seth Hoenig\n *    Allan Stockdill-Mander\n *    Mike Robertson\n */\n\npackage mqtt\n\nimport (\n\t\"container/list\"\n\t\"strings\"\n\t\"sync\"\n\n\t\"github.com/eclipse/paho.mqtt.golang/packets\"\n)\n\n// route is a type which associates MQTT Topic strings with a\n// callback to be executed upon the arrival of a message associated\n// with a subscription to that topic.\ntype route struct {\n\ttopic    string\n\tcallback MessageHandler\n}\n\n// match takes a slice of strings which represent the route being tested having been split on '/'\n// separators, and a slice of strings representing the topic string in the published message, similarly\n// split.\n// The function determines if the topic string matches the route according to the MQTT topic rules\n// and returns a boolean of the outcome\nfunc match(route []string, topic []string) bool {\n\tif len(route) == 0 {\n\t\treturn len(topic) == 0\n\t}\n\n\tif len(topic) == 0 {\n\t\treturn route[0] == \"#\"\n\t}\n\n\tif route[0] == \"#\" {\n\t\treturn true\n\t}\n\n\tif (route[0] == \"+\") || (route[0] == topic[0]) {\n\t\treturn match(route[1:], topic[1:])\n\t}\n\treturn false\n}\n\nfunc routeIncludesTopic(route, topic string) bool {\n\treturn match(routeSplit(route), strings.Split(topic, \"/\"))\n}\n\n// removes $share and sharename when splitting the route to allow\n// shared subscription routes to correctly match the topic\nfunc routeSplit(route string) []string {\n\tvar result []string\n\tif strings.HasPrefix(route, \"$share\") {\n\t\tresult = strings.Split(route, \"/\")[2:]\n\t} else {\n\t\tresult = strings.Split(route, \"/\")\n\t}\n\treturn result\n}\n\n// match takes the topic string of the published message and does a basic compare to the\n// string of the current Route, if they match it returns true\nfunc (r *route) match(topic string) bool {\n\treturn r.topic == topic || routeIncludesTopic(r.topic, topic)\n}\n\ntype router struct {\n\tsync.RWMutex\n\troutes         *list.List\n\tdefaultHandler MessageHandler\n\tmessages       chan *packets.PublishPacket\n}\n\n// newRouter returns a new instance of a Router and channel which can be used to tell the Router\n// to stop\nfunc newRouter() *router {\n\trouter := &router{routes: list.New(), messages: make(chan *packets.PublishPacket)}\n\treturn router\n}\n\n// addRoute takes a topic string and MessageHandler callback. It looks in the current list of\n// routes to see if there is already a matching Route. If there is it replaces the current\n// callback with the new one. If not it add a new entry to the list of Routes.\nfunc (r *router) addRoute(topic string, callback MessageHandler) {\n\tr.Lock()\n\tdefer r.Unlock()\n\tfor e := r.routes.Front(); e != nil; e = e.Next() {\n\t\tif e.Value.(*route).topic == topic {\n\t\t\tr := e.Value.(*route)\n\t\t\tr.callback = callback\n\t\t\treturn\n\t\t}\n\t}\n\tr.routes.PushBack(&route{topic: topic, callback: callback})\n}\n\n// deleteRoute takes a route string, looks for a matching Route in the list of Routes. If\n// found it removes the Route from the list.\nfunc (r *router) deleteRoute(topic string) {\n\tr.Lock()\n\tdefer r.Unlock()\n\tfor e := r.routes.Front(); e != nil; e = e.Next() {\n\t\tif e.Value.(*route).topic == topic {\n\t\t\tr.routes.Remove(e)\n\t\t\treturn\n\t\t}\n\t}\n}\n\n// setDefaultHandler assigns a default callback that will be called if no matching Route\n// is found for an incoming Publish.\nfunc (r *router) setDefaultHandler(handler MessageHandler) {\n\tr.Lock()\n\tdefer r.Unlock()\n\tr.defaultHandler = handler\n}\n\n// matchAndDispatch takes a channel of Message pointers as input and starts a go routine that\n// takes messages off the channel, matches them against the internal route list and calls the\n// associated callback (or the defaultHandler, if one exists and no other route matched). If\n// anything is sent down the stop channel the function will end.\nfunc (r *router) matchAndDispatch(messages <-chan *packets.PublishPacket, order bool, client *client) <-chan *PacketAndToken {\n\tvar wg sync.WaitGroup\n\tackOutChan := make(chan *PacketAndToken) // Channel returned to caller; closed when messages channel closed\n\tvar ackInChan chan *PacketAndToken       // ACKs generated by ackFunc get put onto this channel\n\n\tstopAckCopy := make(chan struct{})    // Closure requests stop of go routine copying ackInChan to ackOutChan\n\tackCopyStopped := make(chan struct{}) // Closure indicates that it is safe to close ackOutChan\n\tgoRoutinesDone := make(chan struct{}) // closed on wg.Done()\n\tif order {\n\t\tackInChan = ackOutChan // When order = true no go routines are used so safe to use one channel and close when done\n\t} else {\n\t\t// When order = false ACK messages are sent in go routines so ackInChan cannot be closed until all goroutines done\n\t\tackInChan = make(chan *PacketAndToken)\n\t\tgo func() { // go routine to copy from ackInChan to ackOutChan until stopped\n\t\t\tfor {\n\t\t\t\tselect {\n\t\t\t\tcase a := <-ackInChan:\n\t\t\t\t\tackOutChan <- a\n\t\t\t\tcase <-stopAckCopy:\n\t\t\t\t\tclose(ackCopyStopped) // Signal main go routine that it is safe to close ackOutChan\n\t\t\t\t\tfor {\n\t\t\t\t\t\tselect {\n\t\t\t\t\t\tcase <-ackInChan: // drain ackInChan to ensure all goRoutines can complete cleanly (ACK dropped)\n\t\t\t\t\t\t\tDEBUG.Println(ROU, \"matchAndDispatch received acknowledgment after processing stopped (ACK dropped).\")\n\t\t\t\t\t\tcase <-goRoutinesDone:\n\t\t\t\t\t\t\tclose(ackInChan) // Nothing further should be sent (a panic is probably better than silent failure)\n\t\t\t\t\t\t\tDEBUG.Println(ROU, \"matchAndDispatch order=false copy goroutine exiting.\")\n\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}()\n\t}\n\n\tgo func() { // Main go routine handling inbound messages\n\t\tfor message := range messages {\n\t\t\t// DEBUG.Println(ROU, \"matchAndDispatch received message\")\n\t\t\tsent := false\n\t\t\tr.RLock()\n\t\t\tm := messageFromPublish(message, ackFunc(ackInChan, client.persist, message))\n\t\t\tvar handlers []MessageHandler\n\t\t\tfor e := r.routes.Front(); e != nil; e = e.Next() {\n\t\t\t\tif e.Value.(*route).match(message.TopicName) {\n\t\t\t\t\tif order {\n\t\t\t\t\t\thandlers = append(handlers, e.Value.(*route).callback)\n\t\t\t\t\t} else {\n\t\t\t\t\t\thd := e.Value.(*route).callback\n\t\t\t\t\t\twg.Add(1)\n\t\t\t\t\t\tgo func() {\n\t\t\t\t\t\t\thd(client, m)\n\t\t\t\t\t\t\tif !client.options.AutoAckDisabled {\n\t\t\t\t\t\t\t\tm.Ack()\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\twg.Done()\n\t\t\t\t\t\t}()\n\t\t\t\t\t}\n\t\t\t\t\tsent = true\n\t\t\t\t}\n\t\t\t}\n\t\t\tif !sent {\n\t\t\t\tif r.defaultHandler != nil {\n\t\t\t\t\tif order {\n\t\t\t\t\t\thandlers = append(handlers, r.defaultHandler)\n\t\t\t\t\t} else {\n\t\t\t\t\t\twg.Add(1)\n\t\t\t\t\t\tgo func() {\n\t\t\t\t\t\t\tr.defaultHandler(client, m)\n\t\t\t\t\t\t\tif !client.options.AutoAckDisabled {\n\t\t\t\t\t\t\t\tm.Ack()\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\twg.Done()\n\t\t\t\t\t\t}()\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tDEBUG.Println(ROU, \"matchAndDispatch received message and no handler was available. Message will NOT be acknowledged.\")\n\t\t\t\t}\n\t\t\t}\n\t\t\tr.RUnlock()\n\t\t\tfor _, handler := range handlers {\n\t\t\t\thandler(client, m)\n\t\t\t\tif !client.options.AutoAckDisabled {\n\t\t\t\t\tm.Ack()\n\t\t\t\t}\n\t\t\t}\n\t\t\t// DEBUG.Println(ROU, \"matchAndDispatch handled message\")\n\t\t}\n\t\tif order {\n\t\t\tclose(ackOutChan)\n\t\t} else { // Ensure that nothing further will be written to ackOutChan before closing it\n\t\t\tclose(stopAckCopy)\n\t\t\t<-ackCopyStopped\n\t\t\tclose(ackOutChan)\n\t\t\tgo func() {\n\t\t\t\twg.Wait() // Note: If this remains running then the user has handlers that are not returning\n\t\t\t\tclose(goRoutinesDone)\n\t\t\t}()\n\t\t}\n\t\tDEBUG.Println(ROU, \"matchAndDispatch exiting\")\n\t}()\n\treturn ackOutChan\n}\n"
        },
        {
          "name": "status.go",
          "type": "blob",
          "size": 12.505859375,
          "content": "/*\n * Copyright (c) 2021 IBM Corp and others.\n *\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v2.0\n * and Eclipse Distribution License v1.0 which accompany this distribution.\n *\n * The Eclipse Public License is available at\n *    https://www.eclipse.org/legal/epl-2.0/\n * and the Eclipse Distribution License is available at\n *   http://www.eclipse.org/org/documents/edl-v10.php.\n *\n * Contributors:\n *    Seth Hoenig\n *    Allan Stockdill-Mander\n *    Mike Robertson\n *    Matt Brittan\n */\n\npackage mqtt\n\nimport (\n\t\"errors\"\n\t\"sync\"\n)\n\n// Status - Manage the connection status\n\n// Multiple go routines will want to access/set this. Previously status was implemented as a `uint32` and updated\n// with a mixture of atomic functions and a mutex (leading to some deadlock type issues that were very hard to debug).\n\n// In this new implementation `connectionStatus` takes over managing the state and provides functions that allow the\n// client to request a move to a particular state (it may reject these requests!). In some cases the 'state' is\n// transitory, for example `connecting`, in those cases a function will be returned that allows the client to move\n// to a more static state (`disconnected` or `connected`).\n\n// This \"belts-and-braces\" may be a little over the top but issues with the status have caused a number of difficult\n// to trace bugs in the past and the likelihood that introducing a new system would introduce bugs seemed high!\n// I have written this in a way that should make it very difficult to misuse it (but it does make things a little\n// complex with functions returning functions that return functions!).\n\ntype status uint32\n\nconst (\n\tdisconnected  status = iota // default (nil) status is disconnected\n\tdisconnecting               // Transitioning from one of the below states back to disconnected\n\tconnecting\n\treconnecting\n\tconnected\n)\n\n// String simplify output of statuses\nfunc (s status) String() string {\n\tswitch s {\n\tcase disconnected:\n\t\treturn \"disconnected\"\n\tcase disconnecting:\n\t\treturn \"disconnecting\"\n\tcase connecting:\n\t\treturn \"connecting\"\n\tcase reconnecting:\n\t\treturn \"reconnecting\"\n\tcase connected:\n\t\treturn \"connected\"\n\tdefault:\n\t\treturn \"invalid\"\n\t}\n}\n\ntype connCompletedFn func(success bool) error\ntype disconnectCompletedFn func()\ntype connectionLostHandledFn func(bool) (connCompletedFn, error)\n\n/* State transitions\n\nstatic states are `disconnected` and `connected`. For all other states a process will hold a function that will move\nthe state to one of those. That function effectively owns the state and any other changes must not proceed until it\ncompletes. One exception to that is that the state can always be moved to `disconnecting` which provides a signal that\ntransitions to `connected` will be rejected (this is required because a Disconnect can be requested while in the\nConnecting state).\n\n# Basic Operations\n\nThe standard workflows are:\n\ndisconnected -> `Connecting()` -> connecting -> `connCompletedFn(true)` -> connected\nconnected -> `Disconnecting()` -> disconnecting -> `disconnectCompletedFn()` -> disconnected\nconnected -> `ConnectionLost(false)` -> disconnecting -> `connectionLostHandledFn(true/false)` -> disconnected\nconnected -> `ConnectionLost(true)` -> disconnecting -> `connectionLostHandledFn(true)` -> connected\n\nUnfortunately the above workflows are complicated by the fact that `Disconnecting()` or `ConnectionLost()` may,\npotentially, be called at any time (i.e. whilst in the middle of transitioning between states). If this happens:\n\n* The state will be set to disconnecting (which will prevent any request to move the status to connected)\n* The call to `Disconnecting()`/`ConnectionLost()` will block until the previously active call completes and then\n  handle the disconnection.\n\nReading the tests (unit_status_test.go) might help understand these rules.\n*/\n\nvar (\n\terrAbortConnection                = errors.New(\"disconnect called whist connection attempt in progress\")\n\terrAlreadyConnectedOrReconnecting = errors.New(\"status is already connected or reconnecting\")\n\terrStatusMustBeDisconnected       = errors.New(\"status can only transition to connecting from disconnected\")\n\terrAlreadyDisconnected            = errors.New(\"status is already disconnected\")\n\terrDisconnectionRequested         = errors.New(\"disconnection was requested whilst the action was in progress\")\n\terrDisconnectionInProgress        = errors.New(\"disconnection already in progress\")\n\terrAlreadyHandlingConnectionLoss  = errors.New(\"status is already Connection Lost\")\n\terrConnLossWhileDisconnecting     = errors.New(\"connection status is disconnecting so loss of connection is expected\")\n)\n\n// connectionStatus encapsulates, and protects, the connection status.\ntype connectionStatus struct {\n\tsync.RWMutex  // Protects the variables below\n\tstatus        status\n\twillReconnect bool // only used when status == disconnecting. Indicates that an attempt will be made to reconnect (allows us to abort that)\n\n\t// Some statuses are transitional (e.g. connecting, connectionLost, reconnecting, disconnecting), that is, whatever\n\t// process moves us into that status will move us out of it when an action is complete. Sometimes other users\n\t// will need to know when the action is complete (e.g. the user calls `Disconnect()` whilst the status is\n\t// `connecting`). `actionCompleted` will be set whenever we move into one of the above statues and the channel\n\t// returned to anything else requesting a status change. The channel will be closed when the operation is complete.\n\tactionCompleted chan struct{} // Only valid whilst status is Connecting or Reconnecting; will be closed when connection completed (success or failure)\n}\n\n// ConnectionStatus returns the connection status.\n// WARNING: the status may change at any time so users should not assume they are the only goroutine touching this\nfunc (c *connectionStatus) ConnectionStatus() status {\n\tc.RLock()\n\tdefer c.RUnlock()\n\treturn c.status\n}\n\n// ConnectionStatusRetry returns the connection status and retry flag (indicates that we expect to reconnect).\n// WARNING: the status may change at any time so users should not assume they are the only goroutine touching this\nfunc (c *connectionStatus) ConnectionStatusRetry() (status, bool) {\n\tc.RLock()\n\tdefer c.RUnlock()\n\treturn c.status, c.willReconnect\n}\n\n// Connecting - Changes the status to connecting if that is a permitted operation\n// Will do nothing unless the current status is disconnected\n// Returns a function that MUST be called when the operation is complete (pass in true if successful)\nfunc (c *connectionStatus) Connecting() (connCompletedFn, error) {\n\tc.Lock()\n\tdefer c.Unlock()\n\t// Calling Connect when already connecting (or if reconnecting) may not always be considered an error\n\tif c.status == connected || c.status == reconnecting {\n\t\treturn nil, errAlreadyConnectedOrReconnecting\n\t}\n\tif c.status != disconnected {\n\t\treturn nil, errStatusMustBeDisconnected\n\t}\n\tc.status = connecting\n\tc.actionCompleted = make(chan struct{})\n\treturn c.connected, nil\n}\n\n// connected is an internal function (it is returned by functions that set the status to connecting or reconnecting,\n// calling it completes the operation). `success` is used to indicate whether the operation was successfully completed.\nfunc (c *connectionStatus) connected(success bool) error {\n\tc.Lock()\n\tdefer func() {\n\t\tclose(c.actionCompleted) // Alert anything waiting on the connection process to complete\n\t\tc.actionCompleted = nil  // Be tidy\n\t\tc.Unlock()\n\t}()\n\n\t// Status may have moved to disconnecting in the interim (i.e. at users request)\n\tif c.status == disconnecting {\n\t\treturn errAbortConnection\n\t}\n\tif success {\n\t\tc.status = connected\n\t} else {\n\t\tc.status = disconnected\n\t}\n\treturn nil\n}\n\n// Disconnecting - should be called when beginning the disconnection process (cleanup etc.).\n// Can be called from ANY status and the end result will always be a status of disconnected\n// Note that if a connection/reconnection attempt is in progress this function will set the status to `disconnecting`\n// then block until the connection process completes (or aborts).\n// Returns a function that MUST be called when the operation is complete (assumed to always be successful!)\nfunc (c *connectionStatus) Disconnecting() (disconnectCompletedFn, error) {\n\tc.Lock()\n\tif c.status == disconnected {\n\t\tc.Unlock()\n\t\treturn nil, errAlreadyDisconnected // May not always be treated as an error\n\t}\n\tif c.status == disconnecting { // Need to wait for existing process to complete\n\t\tc.willReconnect = false // Ensure that the existing disconnect process will not reconnect\n\t\tdisConnectDone := c.actionCompleted\n\t\tc.Unlock()\n\t\t<-disConnectDone                   // Wait for existing operation to complete\n\t\treturn nil, errAlreadyDisconnected // Well we are now!\n\t}\n\n\tprevStatus := c.status\n\tc.status = disconnecting\n\n\t// We may need to wait for connection/reconnection process to complete (they should regularly check the status)\n\tif prevStatus == connecting || prevStatus == reconnecting {\n\t\tconnectDone := c.actionCompleted\n\t\tc.Unlock() // Safe because the only way to leave the disconnecting status is via this function\n\t\t<-connectDone\n\n\t\tif prevStatus == reconnecting && !c.willReconnect {\n\t\t\treturn nil, errAlreadyDisconnected // Following connectionLost process we will be disconnected\n\t\t}\n\t\tc.Lock()\n\t}\n\tc.actionCompleted = make(chan struct{})\n\tc.Unlock()\n\treturn c.disconnectionCompleted, nil\n}\n\n// disconnectionCompleted is an internal function (it is returned by functions that set the status to disconnecting)\nfunc (c *connectionStatus) disconnectionCompleted() {\n\tc.Lock()\n\tdefer c.Unlock()\n\tc.status = disconnected\n\tclose(c.actionCompleted) // Alert anything waiting on the connection process to complete\n\tc.actionCompleted = nil\n}\n\n// ConnectionLost - should be called when the connection is lost.\n// This really only differs from Disconnecting in that we may transition into a reconnection (but that could be\n// cancelled something else calls Disconnecting in the meantime).\n// The returned function should be called when cleanup is completed. It will return a function to be called when\n// reconnect completes (or nil if no reconnect requested/disconnect called in the interim).\n// Note: This function may block if a connection is in progress (the move to connected will be rejected)\nfunc (c *connectionStatus) ConnectionLost(willReconnect bool) (connectionLostHandledFn, error) {\n\tc.Lock()\n\tdefer c.Unlock()\n\tif c.status == disconnected {\n\t\treturn nil, errAlreadyDisconnected\n\t}\n\tif c.status == disconnecting { // its expected that connection lost will be called during the disconnection process\n\t\treturn nil, errDisconnectionInProgress\n\t}\n\n\tc.willReconnect = willReconnect\n\tprevStatus := c.status\n\tc.status = disconnecting\n\n\t// There is a slight possibility that a connection attempt is in progress (connection up and goroutines started but\n\t// status not yet changed). By changing the status we ensure that process will exit cleanly\n\tif prevStatus == connecting || prevStatus == reconnecting {\n\t\tconnectDone := c.actionCompleted\n\t\tc.Unlock() // Safe because the only way to leave the disconnecting status is via this function\n\t\t<-connectDone\n\t\tc.Lock()\n\t\tif !willReconnect {\n\t\t\t// In this case the connection will always be aborted so there is nothing more for us to do\n\t\t\treturn nil, errAlreadyDisconnected\n\t\t}\n\t}\n\tc.actionCompleted = make(chan struct{})\n\n\treturn c.getConnectionLostHandler(willReconnect), nil\n}\n\n// getConnectionLostHandler is an internal function. It returns the function to be returned by ConnectionLost\nfunc (c *connectionStatus) getConnectionLostHandler(reconnectRequested bool) connectionLostHandledFn {\n\treturn func(proceed bool) (connCompletedFn, error) {\n\t\t// Note that connCompletedFn will only be provided if both reconnectRequested and proceed are true\n\t\tc.Lock()\n\t\tdefer c.Unlock()\n\n\t\t// `Disconnecting()` may have been called while the disconnection was being processed (this makes it permanent!)\n\t\tif !c.willReconnect || !proceed {\n\t\t\tc.status = disconnected\n\t\t\tclose(c.actionCompleted) // Alert anything waiting on the connection process to complete\n\t\t\tc.actionCompleted = nil\n\t\t\tif !reconnectRequested || !proceed {\n\t\t\t\treturn nil, nil\n\t\t\t}\n\t\t\treturn nil, errDisconnectionRequested\n\t\t}\n\n\t\tc.status = reconnecting\n\t\treturn c.connected, nil // Note that c.actionCompleted is still live and will be closed in connected\n\t}\n}\n\n// forceConnectionStatus - forces the connection status to the specified value.\n// This should only be used when there is no alternative (i.e. only in tests and to recover from situations that\n// are unexpected)\nfunc (c *connectionStatus) forceConnectionStatus(s status) {\n\tc.Lock()\n\tdefer c.Unlock()\n\tc.status = s\n}\n"
        },
        {
          "name": "store.go",
          "type": "blob",
          "size": 3.8349609375,
          "content": "/*\n * Copyright (c) 2021 IBM Corp and others.\n *\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v2.0\n * and Eclipse Distribution License v1.0 which accompany this distribution.\n *\n * The Eclipse Public License is available at\n *    https://www.eclipse.org/legal/epl-2.0/\n * and the Eclipse Distribution License is available at\n *   http://www.eclipse.org/org/documents/edl-v10.php.\n *\n * Contributors:\n *    Seth Hoenig\n *    Allan Stockdill-Mander\n *    Mike Robertson\n */\n\npackage mqtt\n\nimport (\n\t\"fmt\"\n\t\"strconv\"\n\n\t\"github.com/eclipse/paho.mqtt.golang/packets\"\n)\n\nconst (\n\tinboundPrefix  = \"i.\"\n\toutboundPrefix = \"o.\"\n)\n\n// Store is an interface which can be used to provide implementations\n// for message persistence.\n// Because we may have to store distinct messages with the same\n// message ID, we need a unique key for each message. This is\n// possible by prepending \"i.\" or \"o.\" to each message id\ntype Store interface {\n\tOpen()\n\tPut(key string, message packets.ControlPacket)\n\tGet(key string) packets.ControlPacket\n\tAll() []string\n\tDel(key string)\n\tClose()\n\tReset()\n}\n\n// A key MUST have the form \"X.[messageid]\"\n// where X is 'i' or 'o'\nfunc mIDFromKey(key string) uint16 {\n\ts := key[2:]\n\ti, err := strconv.ParseUint(s, 10, 16)\n\tchkerr(err)\n\treturn uint16(i)\n}\n\n// Return true if key prefix is outbound\nfunc isKeyOutbound(key string) bool {\n\treturn key[:2] == outboundPrefix\n}\n\n// Return true if key prefix is inbound\nfunc isKeyInbound(key string) bool {\n\treturn key[:2] == inboundPrefix\n}\n\n// Return a string of the form \"i.[id]\"\nfunc inboundKeyFromMID(id uint16) string {\n\treturn fmt.Sprintf(\"%s%d\", inboundPrefix, id)\n}\n\n// Return a string of the form \"o.[id]\"\nfunc outboundKeyFromMID(id uint16) string {\n\treturn fmt.Sprintf(\"%s%d\", outboundPrefix, id)\n}\n\n// govern which outgoing messages are persisted\nfunc persistOutbound(s Store, m packets.ControlPacket) {\n\tswitch m.Details().Qos {\n\tcase 0:\n\t\tswitch m.(type) {\n\t\tcase *packets.PubackPacket, *packets.PubcompPacket:\n\t\t\t// Sending puback. delete matching publish\n\t\t\t// from ibound\n\t\t\ts.Del(inboundKeyFromMID(m.Details().MessageID))\n\t\t}\n\tcase 1:\n\t\tswitch m.(type) {\n\t\tcase *packets.PublishPacket, *packets.PubrelPacket, *packets.SubscribePacket, *packets.UnsubscribePacket:\n\t\t\t// Sending publish. store in obound\n\t\t\t// until puback received\n\t\t\ts.Put(outboundKeyFromMID(m.Details().MessageID), m)\n\t\tdefault:\n\t\t\tERROR.Println(STR, \"Asked to persist an invalid message type\")\n\t\t}\n\tcase 2:\n\t\tswitch m.(type) {\n\t\tcase *packets.PublishPacket:\n\t\t\t// Sending publish. store in obound\n\t\t\t// until pubrel received\n\t\t\ts.Put(outboundKeyFromMID(m.Details().MessageID), m)\n\t\tdefault:\n\t\t\tERROR.Println(STR, \"Asked to persist an invalid message type\")\n\t\t}\n\t}\n}\n\n// govern which incoming messages are persisted\nfunc persistInbound(s Store, m packets.ControlPacket) {\n\tswitch m.Details().Qos {\n\tcase 0:\n\t\tswitch m.(type) {\n\t\tcase *packets.PubackPacket, *packets.SubackPacket, *packets.UnsubackPacket, *packets.PubcompPacket:\n\t\t\t// Received a puback. delete matching publish\n\t\t\t// from obound\n\t\t\ts.Del(outboundKeyFromMID(m.Details().MessageID))\n\t\tcase *packets.PublishPacket, *packets.PubrecPacket, *packets.PingrespPacket, *packets.ConnackPacket:\n\t\tdefault:\n\t\t\tERROR.Println(STR, \"Asked to persist an invalid messages type\")\n\t\t}\n\tcase 1:\n\t\tswitch m.(type) {\n\t\tcase *packets.PublishPacket, *packets.PubrelPacket:\n\t\t\t// Received a publish. store it in ibound\n\t\t\t// until puback sent\n\t\t\ts.Put(inboundKeyFromMID(m.Details().MessageID), m)\n\t\tdefault:\n\t\t\tERROR.Println(STR, \"Asked to persist an invalid messages type\")\n\t\t}\n\tcase 2:\n\t\tswitch m.(type) {\n\t\tcase *packets.PublishPacket:\n\t\t\t// Received a publish. store it in ibound\n\t\t\t// until pubrel received\n\t\t\ts.Put(inboundKeyFromMID(m.Details().MessageID), m)\n\t\tdefault:\n\t\t\tERROR.Println(STR, \"Asked to persist an invalid messages type\")\n\t\t}\n\t}\n}\n"
        },
        {
          "name": "token.go",
          "type": "blob",
          "size": 5.9736328125,
          "content": "/*\n * Copyright (c) 2021 IBM Corp and others.\n *\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v2.0\n * and Eclipse Distribution License v1.0 which accompany this distribution.\n *\n * The Eclipse Public License is available at\n *    https://www.eclipse.org/legal/epl-2.0/\n * and the Eclipse Distribution License is available at\n *   http://www.eclipse.org/org/documents/edl-v10.php.\n *\n * Contributors:\n *    Allan Stockdill-Mander\n */\n\npackage mqtt\n\nimport (\n\t\"errors\"\n\t\"sync\"\n\t\"time\"\n\n\t\"github.com/eclipse/paho.mqtt.golang/packets\"\n)\n\n// PacketAndToken is a struct that contains both a ControlPacket and a\n// Token. This struct is passed via channels between the client interface\n// code and the underlying code responsible for sending and receiving\n// MQTT messages.\ntype PacketAndToken struct {\n\tp packets.ControlPacket\n\tt tokenCompletor\n}\n\n// Token defines the interface for the tokens used to indicate when\n// actions have completed.\ntype Token interface {\n\t// Wait will wait indefinitely for the Token to complete, ie the Publish\n\t// to be sent and confirmed receipt from the broker.\n\tWait() bool\n\n\t// WaitTimeout takes a time.Duration to wait for the flow associated with the\n\t// Token to complete, returns true if it returned before the timeout or\n\t// returns false if the timeout occurred. In the case of a timeout the Token\n\t// does not have an error set in case the caller wishes to wait again.\n\tWaitTimeout(time.Duration) bool\n\n\t// Done returns a channel that is closed when the flow associated\n\t// with the Token completes. Clients should call Error after the\n\t// channel is closed to check if the flow completed successfully.\n\t//\n\t// Done is provided for use in select statements. Simple use cases may\n\t// use Wait or WaitTimeout.\n\tDone() <-chan struct{}\n\n\tError() error\n}\n\ntype TokenErrorSetter interface {\n\tsetError(error)\n}\n\ntype tokenCompletor interface {\n\tToken\n\tTokenErrorSetter\n\tflowComplete()\n}\n\ntype baseToken struct {\n\tm        sync.RWMutex\n\tcomplete chan struct{}\n\terr      error\n}\n\n// Wait implements the Token Wait method.\nfunc (b *baseToken) Wait() bool {\n\t<-b.complete\n\treturn true\n}\n\n// WaitTimeout implements the Token WaitTimeout method.\nfunc (b *baseToken) WaitTimeout(d time.Duration) bool {\n\ttimer := time.NewTimer(d)\n\tselect {\n\tcase <-b.complete:\n\t\tif !timer.Stop() {\n\t\t\t<-timer.C\n\t\t}\n\t\treturn true\n\tcase <-timer.C:\n\t}\n\n\treturn false\n}\n\n// Done implements the Token Done method.\nfunc (b *baseToken) Done() <-chan struct{} {\n\treturn b.complete\n}\n\nfunc (b *baseToken) flowComplete() {\n\tselect {\n\tcase <-b.complete:\n\tdefault:\n\t\tclose(b.complete)\n\t}\n}\n\nfunc (b *baseToken) Error() error {\n\tb.m.RLock()\n\tdefer b.m.RUnlock()\n\treturn b.err\n}\n\nfunc (b *baseToken) setError(e error) {\n\tb.m.Lock()\n\tb.err = e\n\tb.flowComplete()\n\tb.m.Unlock()\n}\n\nfunc newToken(tType byte) tokenCompletor {\n\tswitch tType {\n\tcase packets.Connect:\n\t\treturn &ConnectToken{baseToken: baseToken{complete: make(chan struct{})}}\n\tcase packets.Subscribe:\n\t\treturn &SubscribeToken{baseToken: baseToken{complete: make(chan struct{})}, subResult: make(map[string]byte)}\n\tcase packets.Publish:\n\t\treturn &PublishToken{baseToken: baseToken{complete: make(chan struct{})}}\n\tcase packets.Unsubscribe:\n\t\treturn &UnsubscribeToken{baseToken: baseToken{complete: make(chan struct{})}}\n\tcase packets.Disconnect:\n\t\treturn &DisconnectToken{baseToken: baseToken{complete: make(chan struct{})}}\n\t}\n\treturn nil\n}\n\n// ConnectToken is an extension of Token containing the extra fields\n// required to provide information about calls to Connect()\ntype ConnectToken struct {\n\tbaseToken\n\treturnCode     byte\n\tsessionPresent bool\n}\n\n// ReturnCode returns the acknowledgement code in the connack sent\n// in response to a Connect()\nfunc (c *ConnectToken) ReturnCode() byte {\n\tc.m.RLock()\n\tdefer c.m.RUnlock()\n\treturn c.returnCode\n}\n\n// SessionPresent returns a bool representing the value of the\n// session present field in the connack sent in response to a Connect()\nfunc (c *ConnectToken) SessionPresent() bool {\n\tc.m.RLock()\n\tdefer c.m.RUnlock()\n\treturn c.sessionPresent\n}\n\n// PublishToken is an extension of Token containing the extra fields\n// required to provide information about calls to Publish()\ntype PublishToken struct {\n\tbaseToken\n\tmessageID uint16\n}\n\n// MessageID returns the MQTT message ID that was assigned to the\n// Publish packet when it was sent to the broker\nfunc (p *PublishToken) MessageID() uint16 {\n\treturn p.messageID\n}\n\n// SubscribeToken is an extension of Token containing the extra fields\n// required to provide information about calls to Subscribe()\ntype SubscribeToken struct {\n\tbaseToken\n\tsubs      []string\n\tsubResult map[string]byte\n\tmessageID uint16\n}\n\n// Result returns a map of topics that were subscribed to along with\n// the matching return code from the broker. This is either the Qos\n// value of the subscription or an error code.\nfunc (s *SubscribeToken) Result() map[string]byte {\n\ts.m.RLock()\n\tdefer s.m.RUnlock()\n\treturn s.subResult\n}\n\n// UnsubscribeToken is an extension of Token containing the extra fields\n// required to provide information about calls to Unsubscribe()\ntype UnsubscribeToken struct {\n\tbaseToken\n\tmessageID uint16\n}\n\n// DisconnectToken is an extension of Token containing the extra fields\n// required to provide information about calls to Disconnect()\ntype DisconnectToken struct {\n\tbaseToken\n}\n\n// TimedOut is the error returned by WaitTimeout when the timeout expires\nvar TimedOut = errors.New(\"context canceled\")\n\n// WaitTokenTimeout is a utility function used to simplify the use of token.WaitTimeout\n// token.WaitTimeout may return `false` due to time out but t.Error() still results\n// in nil.\n// `if t := client.X(); t.WaitTimeout(time.Second) && t.Error() != nil {` may evaluate\n// to false even if the operation fails.\n// It is important to note that if TimedOut is returned, then the operation may still be running\n// and could eventually complete successfully.\nfunc WaitTokenTimeout(t Token, d time.Duration) error {\n\tif !t.WaitTimeout(d) {\n\t\treturn TimedOut\n\t}\n\treturn t.Error()\n}\n"
        },
        {
          "name": "token_test.go",
          "type": "blob",
          "size": 1.4990234375,
          "content": "/*\n * Copyright (c) 2021 IBM Corp and others.\n *\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v2.0\n * and Eclipse Distribution License v1.0 which accompany this distribution.\n *\n * The Eclipse Public License is available at\n *    https://www.eclipse.org/legal/epl-2.0/\n * and the Eclipse Distribution License is available at\n *   http://www.eclipse.org/org/documents/edl-v10.php.\n *\n * Contributors:\n *    Allan Stockdill-Mander\n */\n\npackage mqtt\n\nimport (\n\t\"errors\"\n\t\"testing\"\n\t\"time\"\n)\n\nfunc TestWaitTimeout(t *testing.T) {\n\tb := baseToken{}\n\n\tif b.WaitTimeout(time.Second) {\n\t\tt.Fatal(\"Should have failed\")\n\t}\n\n\t// Now lets confirm that WaitTimeout returns\n\t// setError() grabs the mutex which previously caused issues\n\t// when there is a result (it returns true in this case)\n\tb = baseToken{complete: make(chan struct{})}\n\tgo func(bt *baseToken) {\n\t\tbt.setError(errors.New(\"test error\"))\n\t}(&b)\n\tif !b.WaitTimeout(5 * time.Second) {\n\t\tt.Fatal(\"Should have succeeded\")\n\t}\n}\n\nfunc TestWaitTokenTimeout(t *testing.T) {\n\tb := baseToken{}\n\n\tif !errors.Is(WaitTokenTimeout(&b, time.Second), TimedOut) {\n\t\tt.Fatal(\"Should have failed\")\n\t}\n\n\t// Now let's confirm that WaitTimeout returns correct error\n\tb = baseToken{complete: make(chan struct{})}\n\ttestError := errors.New(\"test\")\n\tgo func(bt *baseToken) {\n\t\tbt.setError(testError)\n\t}(&b)\n\tif !errors.Is(WaitTokenTimeout(&b, 5*time.Second), testError) {\n\t\tt.Fatal(\"Unexpected error received\")\n\t}\n}\n"
        },
        {
          "name": "topic.go",
          "type": "blob",
          "size": 2.7841796875,
          "content": "/*\n * Copyright (c) 2021 IBM Corp and others.\n *\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v2.0\n * and Eclipse Distribution License v1.0 which accompany this distribution.\n *\n * The Eclipse Public License is available at\n *    https://www.eclipse.org/legal/epl-2.0/\n * and the Eclipse Distribution License is available at\n *   http://www.eclipse.org/org/documents/edl-v10.php.\n *\n * Contributors:\n *    Seth Hoenig\n *    Allan Stockdill-Mander\n *    Mike Robertson\n */\n\npackage mqtt\n\nimport (\n\t\"errors\"\n\t\"strings\"\n)\n\n// ErrInvalidQos is the error returned when an packet is to be sent\n// with an invalid Qos value\nvar ErrInvalidQos = errors.New(\"invalid QoS\")\n\n// ErrInvalidTopicEmptyString is the error returned when a topic string\n// is passed in that is 0 length\nvar ErrInvalidTopicEmptyString = errors.New(\"invalid Topic; empty string\")\n\n// ErrInvalidTopicMultilevel is the error returned when a topic string\n// is passed in that has the multi level wildcard in any position but\n// the last\nvar ErrInvalidTopicMultilevel = errors.New(\"invalid Topic; multi-level wildcard must be last level\")\n\n// Topic Names and Topic Filters\n// The MQTT v3.1.1 spec clarifies a number of ambiguities with regard\n// to the validity of Topic strings.\n// - A Topic must be between 1 and 65535 bytes.\n// - A Topic is case sensitive.\n// - A Topic may contain whitespace.\n// - A Topic containing a leading forward slash is different than a Topic without.\n// - A Topic may be \"/\" (two levels, both empty string).\n// - A Topic must be UTF-8 encoded.\n// - A Topic may contain any number of levels.\n// - A Topic may contain an empty level (two forward slashes in a row).\n// - A TopicName may not contain a wildcard.\n// - A TopicFilter may only have a # (multi-level) wildcard as the last level.\n// - A TopicFilter may contain any number of + (single-level) wildcards.\n// - A TopicFilter with a # will match the absence of a level\n//     Example:  a subscription to \"foo/#\" will match messages published to \"foo\".\n\nfunc validateSubscribeMap(subs map[string]byte) ([]string, []byte, error) {\n\tif len(subs) == 0 {\n\t\treturn nil, nil, errors.New(\"invalid subscription; subscribe map must not be empty\")\n\t}\n\n\tvar topics []string\n\tvar qoss []byte\n\tfor topic, qos := range subs {\n\t\tif err := validateTopicAndQos(topic, qos); err != nil {\n\t\t\treturn nil, nil, err\n\t\t}\n\t\ttopics = append(topics, topic)\n\t\tqoss = append(qoss, qos)\n\t}\n\n\treturn topics, qoss, nil\n}\n\nfunc validateTopicAndQos(topic string, qos byte) error {\n\tif len(topic) == 0 {\n\t\treturn ErrInvalidTopicEmptyString\n\t}\n\n\tlevels := strings.Split(topic, \"/\")\n\tfor i, level := range levels {\n\t\tif level == \"#\" && i != len(levels)-1 {\n\t\t\treturn ErrInvalidTopicMultilevel\n\t\t}\n\t}\n\n\tif qos > 2 {\n\t\treturn ErrInvalidQos\n\t}\n\treturn nil\n}\n"
        },
        {
          "name": "trace.go",
          "type": "blob",
          "size": 1.328125,
          "content": "/*\n * Copyright (c) 2021 IBM Corp and others.\n *\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v2.0\n * and Eclipse Distribution License v1.0 which accompany this distribution.\n *\n * The Eclipse Public License is available at\n *    https://www.eclipse.org/legal/epl-2.0/\n * and the Eclipse Distribution License is available at\n *   http://www.eclipse.org/org/documents/edl-v10.php.\n *\n * Contributors:\n *    Seth Hoenig\n *    Allan Stockdill-Mander\n *    Mike Robertson\n */\n\npackage mqtt\n\ntype (\n\t// Logger interface allows implementations to provide to this package any\n\t// object that implements the methods defined in it.\n\tLogger interface {\n\t\tPrintln(v ...interface{})\n\t\tPrintf(format string, v ...interface{})\n\t}\n\n\t// NOOPLogger implements the logger that does not perform any operation\n\t// by default. This allows us to efficiently discard the unwanted messages.\n\tNOOPLogger struct{}\n)\n\nfunc (NOOPLogger) Println(v ...interface{})               {}\nfunc (NOOPLogger) Printf(format string, v ...interface{}) {}\n\n// Internal levels of library output that are initialised to not print\n// anything but can be overridden by programmer\nvar (\n\tERROR    Logger = NOOPLogger{}\n\tCRITICAL Logger = NOOPLogger{}\n\tWARN     Logger = NOOPLogger{}\n\tDEBUG    Logger = NOOPLogger{}\n)\n"
        },
        {
          "name": "unit_client_test.go",
          "type": "blob",
          "size": 2.4638671875,
          "content": "/*\n * Copyright (c) 2021 IBM Corp and others.\n *\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v2.0\n * and Eclipse Distribution License v1.0 which accompany this distribution.\n *\n * The Eclipse Public License is available at\n *    https://www.eclipse.org/legal/epl-2.0/\n * and the Eclipse Distribution License is available at\n *   http://www.eclipse.org/org/documents/edl-v10.php.\n *\n * Contributors:\n *    Seth Hoenig\n *    Allan Stockdill-Mander\n *    Mike Robertson\n */\n\npackage mqtt\n\nimport (\n\t\"log\"\n\t\"net/http\"\n\t_ \"net/http/pprof\"\n\t\"testing\"\n)\n\nfunc init() {\n\t// Logging is off by default as this makes things simpler when you just want to confirm that tests pass\n\t// DEBUG = log.New(os.Stderr, \"DEBUG    \", log.Ltime)\n\t// WARN = log.New(os.Stderr, \"WARNING  \", log.Ltime)\n\t// CRITICAL = log.New(os.Stderr, \"CRITICAL \", log.Ltime)\n\t// ERROR = log.New(os.Stderr, \"ERROR    \", log.Ltime)\n\n\tgo func() {\n\t\tlog.Println(http.ListenAndServe(\"localhost:6060\", nil))\n\t}()\n}\n\nfunc Test_NewClient_simple(t *testing.T) {\n\tops := NewClientOptions().SetClientID(\"foo\").AddBroker(\"tcp://10.10.0.1:1883\")\n\tc := NewClient(ops).(*client)\n\n\tif c == nil {\n\t\tt.Fatalf(\"ops is nil\")\n\t}\n\n\tif c.options.ClientID != \"foo\" {\n\t\tt.Fatalf(\"bad client id\")\n\t}\n\n\tif c.options.Servers[0].Scheme != \"tcp\" {\n\t\tt.Fatalf(\"bad server scheme\")\n\t}\n\n\tif c.options.Servers[0].Host != \"10.10.0.1:1883\" {\n\t\tt.Fatalf(\"bad server host\")\n\t}\n}\n\nfunc Test_NewClient_optionsReader(t *testing.T) {\n\tops := NewClientOptions().SetClientID(\"foo\").AddBroker(\"tcp://10.10.0.1:1883\")\n\tc := NewClient(ops).(*client)\n\n\tif c == nil {\n\t\tt.Fatalf(\"ops is nil\")\n\t}\n\n\trOps := c.OptionsReader()\n\tcid := rOps.ClientID()\n\n\tif cid != \"foo\" {\n\t\tt.Fatalf(\"unable to read client ID\")\n\t}\n\n\tservers := rOps.Servers()\n\tbroker := servers[0]\n\tif broker.Hostname() != \"10.10.0.1\" {\n\t\tt.Fatalf(\"unable to read hostname\")\n\t}\n\n}\n\nfunc Test_isConnection(t *testing.T) {\n\tops := NewClientOptions()\n\tc := NewClient(ops)\n\n\tc.(*client).status.forceConnectionStatus(connected)\n\tif !c.IsConnectionOpen() {\n\t\tt.Fail()\n\t}\n}\n\nfunc Test_isConnectionOpenNegative(t *testing.T) {\n\tops := NewClientOptions()\n\tc := NewClient(ops)\n\n\tc.(*client).status.forceConnectionStatus(reconnecting)\n\tif c.IsConnectionOpen() {\n\t\tt.Fail()\n\t}\n\tc.(*client).status.forceConnectionStatus(connecting)\n\tif c.IsConnectionOpen() {\n\t\tt.Fail()\n\t}\n\tc.(*client).status.forceConnectionStatus(disconnected)\n\tif c.IsConnectionOpen() {\n\t\tt.Fail()\n\t}\n}\n"
        },
        {
          "name": "unit_message_test.go",
          "type": "blob",
          "size": 1.6650390625,
          "content": "/*\n * Copyright (c) 2021 IBM Corp and others.\n *\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v2.0\n * and Eclipse Distribution License v1.0 which accompany this distribution.\n *\n * The Eclipse Public License is available at\n *    https://www.eclipse.org/legal/epl-2.0/\n * and the Eclipse Distribution License is available at\n *   http://www.eclipse.org/org/documents/edl-v10.php.\n *\n * Contributors:\n *    Andrew Young\n */\n\npackage mqtt\n\nimport (\n\t\"net/url\"\n\t\"testing\"\n)\n\nfunc Test_UsernamePassword(t *testing.T) {\n\toptions := NewClientOptions()\n\toptions.Username = \"username\"\n\toptions.Password = \"password\"\n\n\tm := newConnectMsgFromOptions(options, &url.URL{})\n\n\tif m.Username != \"username\" {\n\t\tt.Fatalf(\"Username not set correctly\")\n\t}\n\n\tif string(m.Password) != \"password\" {\n\t\tt.Fatalf(\"Password not set correctly\")\n\t}\n}\n\nfunc Test_CredentialsProvider(t *testing.T) {\n\toptions := NewClientOptions()\n\toptions.Username = \"incorrect\"\n\toptions.Password = \"incorrect\"\n\toptions.SetCredentialsProvider(func() (username string, password string) {\n\t\treturn \"username\", \"password\"\n\t})\n\n\tm := newConnectMsgFromOptions(options, &url.URL{})\n\n\tif m.Username != \"username\" {\n\t\tt.Fatalf(\"Username not set correctly\")\n\t}\n\n\tif string(m.Password) != \"password\" {\n\t\tt.Fatalf(\"Password not set correctly\")\n\t}\n}\n\nfunc Test_BrokerCredentials(t *testing.T) {\n\tm := newConnectMsgFromOptions(\n\t\tNewClientOptions(),\n\t\t&url.URL{User: url.UserPassword(\"username\", \"password\")},\n\t)\n\tif m.Username != \"username\" {\n\t\tt.Fatalf(\"Username not set correctly\")\n\t}\n\tif string(m.Password) != \"password\" {\n\t\tt.Fatalf(\"Password not set correctly\")\n\t}\n}\n"
        },
        {
          "name": "unit_messageids_test.go",
          "type": "blob",
          "size": 1.73828125,
          "content": "/*\n * Copyright (c) 2021 IBM Corp and others.\n *\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v2.0\n * and Eclipse Distribution License v1.0 which accompany this distribution.\n *\n * The Eclipse Public License is available at\n *    https://www.eclipse.org/legal/epl-2.0/\n * and the Eclipse Distribution License is available at\n *   http://www.eclipse.org/org/documents/edl-v10.php.\n *\n * Contributors:\n *    Seth Hoenig\n *    Allan Stockdill-Mander\n *    Mike Robertson\n */\n\npackage mqtt\n\nimport (\n\t\"testing\"\n)\n\nfunc Test_getID(t *testing.T) {\n\tmids := &messageIds{index: make(map[uint16]tokenCompletor)}\n\n\ti1 := mids.getID(&DummyToken{})\n\n\tif i1 != 1 {\n\t\tt.Fatalf(\"i1 was wrong: %v\", i1)\n\t}\n\n\ti2 := mids.getID(&DummyToken{})\n\n\tif i2 != 2 {\n\t\tt.Fatalf(\"i2 was wrong: %v\", i2)\n\t}\n\n\tfor i := uint16(3); i < 100; i++ {\n\t\tid := mids.getID(&DummyToken{})\n\t\tif id != i {\n\t\t\tt.Fatalf(\"id was wrong expected %v got %v\", i, id)\n\t\t}\n\t}\n}\n\nfunc Test_freeID(t *testing.T) {\n\tmids := &messageIds{index: make(map[uint16]tokenCompletor)}\n\n\ti1 := mids.getID(&DummyToken{})\n\tmids.freeID(i1)\n\n\tif i1 != 1 {\n\t\tt.Fatalf(\"i1 was wrong: %v\", i1)\n\t}\n\n\t// The below may be needed for a specific test but leaving it in permanently makes output confusing\n\t// i2 := mids.getID(&DummyToken{})\n\t// fmt.Printf(\"i2: %v\\n\", i2)\n}\n\nfunc Test_noFreeID(t *testing.T) {\n\tvar d DummyToken\n\n\tmids := &messageIds{index: make(map[uint16]tokenCompletor)}\n\n\tfor i := midMin; i != 0; i++ {\n\t\t// Uncomment to see all message IDS log.Println(i)\n\t\tmids.index[i] = &d\n\t}\n\n\tmid := mids.getID(&d)\n\tif mid != 0 {\n\t\tt.Errorf(\"shouldn't be any mids left\")\n\t}\n\n\tmid = mids.getID(&d)\n\tif mid != 0 {\n\t\tt.Errorf(\"shouldn't be any mids left\")\n\t}\n}\n"
        },
        {
          "name": "unit_options_test.go",
          "type": "blob",
          "size": 2.833984375,
          "content": "/*\n * Copyright (c) 2021 IBM Corp and others.\n *\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v2.0\n * and Eclipse Distribution License v1.0 which accompany this distribution.\n *\n * The Eclipse Public License is available at\n *    https://www.eclipse.org/legal/epl-2.0/\n * and the Eclipse Distribution License is available at\n *   http://www.eclipse.org/org/documents/edl-v10.php.\n *\n * Contributors:\n *    Seth Hoenig\n *    Allan Stockdill-Mander\n *    Mike Robertson\n */\n\npackage mqtt\n\nimport (\n\t\"crypto/tls\"\n\t\"crypto/x509\"\n\t\"testing\"\n\t\"time\"\n)\n\nfunc Test_NewClientOptions_default(t *testing.T) {\n\to := NewClientOptions()\n\n\tif o.ClientID != \"\" {\n\t\tt.Fatalf(\"bad default client id\")\n\t}\n\n\tif o.Username != \"\" {\n\t\tt.Fatalf(\"bad default username\")\n\t}\n\n\tif o.Password != \"\" {\n\t\tt.Fatalf(\"bad default password\")\n\t}\n\n\tif o.KeepAlive != 30 {\n\t\tt.Fatalf(\"bad default timeout\")\n\t}\n}\n\nfunc Test_NewClientOptions_mix(t *testing.T) {\n\to := NewClientOptions()\n\to.AddBroker(\"tcp://192.168.1.2:9999\")\n\to.SetClientID(\"myclientid\")\n\to.SetUsername(\"myuser\")\n\to.SetPassword(\"mypassword\")\n\to.SetKeepAlive(88 * time.Second)\n\n\tif o.Servers[0].Scheme != \"tcp\" {\n\t\tt.Fatalf(\"bad scheme\")\n\t}\n\n\tif o.Servers[0].Host != \"192.168.1.2:9999\" {\n\t\tt.Fatalf(\"bad host\")\n\t}\n\n\tif o.ClientID != \"myclientid\" {\n\t\tt.Fatalf(\"bad set clientid\")\n\t}\n\n\tif o.Username != \"myuser\" {\n\t\tt.Fatalf(\"bad set username\")\n\t}\n\n\tif o.Password != \"mypassword\" {\n\t\tt.Fatalf(\"bad set password\")\n\t}\n\n\tif o.KeepAlive != 88 {\n\t\tt.Fatalf(\"bad set timeout: %d\", o.KeepAlive)\n\t}\n}\n\nfunc Test_ModifyOptions(t *testing.T) {\n\to := NewClientOptions()\n\to.AddBroker(\"tcp://3.3.3.3:12345\")\n\tc := NewClient(o).(*client)\n\to.AddBroker(\"ws://2.2.2.2:9999\")\n\to.SetOrderMatters(false)\n\n\tif c.options.Servers[0].Scheme != \"tcp\" {\n\t\tt.Fatalf(\"client options.server.Scheme was modified\")\n\t}\n\n\t// if c.options.server.Host != \"2.2.2.2:9999\" {\n\t// \tt.Fatalf(\"client options.server.Host was modified\")\n\t// }\n\n\tif o.Order != false {\n\t\tt.Fatalf(\"options.order was not modified\")\n\t}\n}\n\nfunc Test_TLSConfig(t *testing.T) {\n\to := NewClientOptions().SetTLSConfig(&tls.Config{\n\t\tRootCAs:            x509.NewCertPool(),\n\t\tClientAuth:         tls.NoClientCert,\n\t\tClientCAs:          x509.NewCertPool(),\n\t\tInsecureSkipVerify: true})\n\n\tc := NewClient(o).(*client)\n\n\tif c.options.TLSConfig.ClientAuth != tls.NoClientCert {\n\t\tt.Fatalf(\"client options.tlsConfig ClientAuth incorrect\")\n\t}\n\n\tif c.options.TLSConfig.InsecureSkipVerify != true {\n\t\tt.Fatalf(\"client options.tlsConfig InsecureSkipVerify incorrect\")\n\t}\n}\n\nfunc Test_OnConnectionLost(t *testing.T) {\n\tonconnlost := func(client Client, err error) {\n\t\tpanic(err)\n\t}\n\to := NewClientOptions().SetConnectionLostHandler(onconnlost)\n\n\tc := NewClient(o).(*client)\n\n\tif c.options.OnConnectionLost == nil {\n\t\tt.Fatalf(\"client options.onconnlost was nil\")\n\t}\n}\n"
        },
        {
          "name": "unit_ping_test.go",
          "type": "blob",
          "size": 1.76171875,
          "content": "/*\n * Copyright (c) 2021 IBM Corp and others.\n *\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v2.0\n * and Eclipse Distribution License v1.0 which accompany this distribution.\n *\n * The Eclipse Public License is available at\n *    https://www.eclipse.org/legal/epl-2.0/\n * and the Eclipse Distribution License is available at\n *   http://www.eclipse.org/org/documents/edl-v10.php.\n *\n * Contributors:\n *    Seth Hoenig\n *    Allan Stockdill-Mander\n *    Mike Robertson\n */\n\npackage mqtt\n\nimport (\n\t\"bytes\"\n\t\"testing\"\n\n\t\"github.com/eclipse/paho.mqtt.golang/packets\"\n)\n\nfunc Test_NewPingReqMessage(t *testing.T) {\n\tpr := packets.NewControlPacket(packets.Pingreq).(*packets.PingreqPacket)\n\tif pr.MessageType != packets.Pingreq {\n\t\tt.Errorf(\"NewPingReqMessage bad msg type: %v\", pr.MessageType)\n\t}\n\tif pr.RemainingLength != 0 {\n\t\tt.Errorf(\"NewPingReqMessage bad remlen, expected 0, got %d\", pr.RemainingLength)\n\t}\n\n\texp := []byte{\n\t\t0xC0,\n\t\t0x00,\n\t}\n\n\tvar buf bytes.Buffer\n\tif err := pr.Write(&buf); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tbs := buf.Bytes()\n\n\tif len(bs) != 2 {\n\t\tt.Errorf(\"NewPingReqMessage.Bytes() wrong length: %d\", len(bs))\n\t}\n\n\tif exp[0] != bs[0] || exp[1] != bs[1] {\n\t\tt.Errorf(\"NewPingMessage.Bytes() wrong\")\n\t}\n}\n\nfunc Test_DecodeMessage_pingresp(t *testing.T) {\n\tbs := bytes.NewBuffer([]byte{\n\t\t0xD0,\n\t\t0x00,\n\t})\n\tpresp, _ := packets.ReadPacket(bs)\n\tif presp.(*packets.PingrespPacket).MessageType != packets.Pingresp {\n\t\tt.Errorf(\"DecodeMessage ping response wrong msg type: %v\", presp.(*packets.PingrespPacket).MessageType)\n\t}\n\tif presp.(*packets.PingrespPacket).RemainingLength != 0 {\n\t\tt.Errorf(\"DecodeMessage ping response wrong rem len: %d\", presp.(*packets.PingrespPacket).RemainingLength)\n\t}\n}\n"
        },
        {
          "name": "unit_router_test.go",
          "type": "blob",
          "size": 5.9345703125,
          "content": "/*\n * Copyright (c) 2021 IBM Corp and others.\n *\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v2.0\n * and Eclipse Distribution License v1.0 which accompany this distribution.\n *\n * The Eclipse Public License is available at\n *    https://www.eclipse.org/legal/epl-2.0/\n * and the Eclipse Distribution License is available at\n *   http://www.eclipse.org/org/documents/edl-v10.php.\n *\n * Contributors:\n *    Seth Hoenig\n *    Allan Stockdill-Mander\n *    Mike Robertson\n */\n\npackage mqtt\n\nimport (\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/eclipse/paho.mqtt.golang/packets\"\n)\n\nfunc Test_newRouter(t *testing.T) {\n\trouter := newRouter()\n\tif router == nil {\n\t\tt.Fatalf(\"router is nil\")\n\t}\n\tif router.routes.Len() != 0 {\n\t\tt.Fatalf(\"router.routes was not empty\")\n\t}\n}\n\nfunc Test_AddRoute(t *testing.T) {\n\trouter := newRouter()\n\tcb := func(client Client, msg Message) {\n\t}\n\trouter.addRoute(\"/alpha\", cb)\n\n\tif router.routes.Len() != 1 {\n\t\tt.Fatalf(\"router.routes was wrong\")\n\t}\n}\n\nfunc Test_AddRoute_Wildcards(t *testing.T) {\n\trouter := newRouter()\n\tcb := func(client Client, msg Message) {\n\t}\n\trouter.addRoute(\"#\", cb)\n\trouter.addRoute(\"topic1\", cb)\n\n\tif router.routes.Len() != 2 {\n\t\tt.Fatalf(\"addRoute should only override routes on exact topic match\")\n\t}\n}\n\nfunc Test_DeleteRoute_Wildcards(t *testing.T) {\n\trouter := newRouter()\n\tcb := func(client Client, msg Message) {\n\t}\n\trouter.addRoute(\"#\", cb)\n\trouter.addRoute(\"topic1\", cb)\n\trouter.deleteRoute(\"topic1\")\n\n\texpected := \"#\"\n\tgot := router.routes.Front().Value.(*route).topic\n\tif !(router.routes.Front().Value.(*route).topic == \"#\") {\n\t\tt.Fatalf(\"deleteRoute deleted wrong route when wildcards are used, got topic '%s', expected route with topic '%s'\", got, expected)\n\t}\n}\n\nfunc Test_Match(t *testing.T) {\n\trouter := newRouter()\n\trouter.addRoute(\"/alpha\", nil)\n\n\tif !router.routes.Front().Value.(*route).match(\"/alpha\") {\n\t\tt.Fatalf(\"match function is bad\")\n\t}\n\n\tif router.routes.Front().Value.(*route).match(\"alpha\") {\n\t\tt.Fatalf(\"match function is bad\")\n\t}\n}\n\nfunc Test_match(t *testing.T) {\n\n\tcheck := func(route, topic string, exp bool) {\n\t\tresult := routeIncludesTopic(route, topic)\n\t\tif exp != result {\n\t\t\tt.Errorf(\"match was bad R: %v, T: %v, EXP: %v\", route, topic, exp)\n\t\t}\n\t}\n\n\t// ** Basic **\n\tR := \"\"\n\tT := \"\"\n\tcheck(R, T, true)\n\n\tR = \"x\"\n\tT = \"\"\n\tcheck(R, T, false)\n\n\tR = \"\"\n\tT = \"x\"\n\tcheck(R, T, false)\n\n\tR = \"x\"\n\tT = \"x\"\n\tcheck(R, T, true)\n\n\tR = \"x\"\n\tT = \"X\"\n\tcheck(R, T, false)\n\n\tR = \"alpha\"\n\tT = \"alpha\"\n\tcheck(R, T, true)\n\n\tR = \"alpha\"\n\tT = \"beta\"\n\tcheck(R, T, false)\n\n\t// ** / **\n\tR = \"/\"\n\tT = \"/\"\n\tcheck(R, T, true)\n\n\tR = \"/one\"\n\tT = \"/one\"\n\tcheck(R, T, true)\n\n\tR = \"/\"\n\tT = \"/two\"\n\tcheck(R, T, false)\n\n\tR = \"/two\"\n\tT = \"/\"\n\tcheck(R, T, false)\n\n\tR = \"/two\"\n\tT = \"two\"\n\tcheck(R, T, false) // a leading \"/\" creates a different topic\n\n\tR = \"/a/\"\n\tT = \"/a\"\n\tcheck(R, T, false)\n\n\tR = \"/a/\"\n\tT = \"/a/b\"\n\tcheck(R, T, false)\n\n\tR = \"/a/b\"\n\tT = \"/a/b\"\n\tcheck(R, T, true)\n\n\tR = \"/a/b/\"\n\tT = \"/a/b\"\n\tcheck(R, T, false)\n\n\tR = \"/a/b\"\n\tT = \"/R/b\"\n\tcheck(R, T, false)\n\n\t// ** + **\n\tR = \"/a/+/c\"\n\tT = \"/a/b/c\"\n\tcheck(R, T, true)\n\n\tR = \"/+/b/c\"\n\tT = \"/a/b/c\"\n\tcheck(R, T, true)\n\n\tR = \"/a/b/+\"\n\tT = \"/a/b/c\"\n\tcheck(R, T, true)\n\n\tR = \"/a/+/+\"\n\tT = \"/a/b/c\"\n\tcheck(R, T, true)\n\n\tR = \"/+/+/+\"\n\tT = \"/a/b/c\"\n\tcheck(R, T, true)\n\n\tR = \"/+/+/c\"\n\tT = \"/a/b/c\"\n\tcheck(R, T, true)\n\n\tR = \"/a/b/c/+\" // different number of levels\n\tT = \"/a/b/c\"\n\tcheck(R, T, false)\n\n\tR = \"+\"\n\tT = \"a\"\n\tcheck(R, T, true)\n\n\tR = \"/+\"\n\tT = \"a\"\n\tcheck(R, T, false)\n\n\tR = \"+/+\"\n\tT = \"/a\"\n\tcheck(R, T, true)\n\n\tR = \"+/+\"\n\tT = \"a\"\n\tcheck(R, T, false)\n\n\t// ** # **\n\tR = \"#\"\n\tT = \"/a/b/c\"\n\tcheck(R, T, true)\n\n\tR = \"/#\"\n\tT = \"/a/b/c\"\n\tcheck(R, T, true)\n\n\t// R = \"/#/\" // not valid\n\t// T = \"/a/b/c\"\n\t// check(R, T, true)\n\n\tR = \"/#\"\n\tT = \"/a/b/c\"\n\tcheck(R, T, true)\n\n\tR = \"/a/#\"\n\tT = \"/a/b/c\"\n\tcheck(R, T, true)\n\n\tR = \"/a/#\"\n\tT = \"/a/b/c\"\n\tcheck(R, T, true)\n\n\tR = \"/a/b/#\"\n\tT = \"/a/b/c\"\n\tcheck(R, T, true)\n\n\t// ** unicode **\n\tR = \"☃\"\n\tT = \"☃\"\n\tcheck(R, T, true)\n\n\tR = \"✈\"\n\tT = \"☃\"\n\tcheck(R, T, false)\n\n\tR = \"/☃/✈\"\n\tT = \"/☃/ッ\"\n\tcheck(R, T, false)\n\n\tR = \"#\"\n\tT = \"/☃/ッ\"\n\tcheck(R, T, true)\n\n\tR = \"/☃/+\"\n\tT = \"/☃/ッ/♫/ø/☹☹☹\"\n\tcheck(R, T, false)\n\n\tR = \"/☃/#\"\n\tT = \"/☃/ッ/♫/ø/☹☹☹\"\n\tcheck(R, T, true)\n\n\tR = \"/☃/ッ/♫/ø/+\"\n\tT = \"/☃/ッ/♫/ø/☹☹☹\"\n\tcheck(R, T, true)\n\n\tR = \"/☃/ッ/+/ø/☹☹☹\"\n\tT = \"/☃/ッ/♫/ø/☹☹☹\"\n\tcheck(R, T, true)\n\n\tR = \"/+/a/ッ/+/ø/☹☹☹\"\n\tT = \"/b/♫/ッ/♫/ø/☹☹☹\"\n\tcheck(R, T, false)\n\n\tR = \"/+/♫/ッ/+/ø/☹☹☹\"\n\tT = \"/b/♫/ッ/♫/ø/☹☹☹\"\n\tcheck(R, T, true)\n}\n\nfunc Test_MatchAndDispatch(t *testing.T) {\n\tcalledback := make(chan bool)\n\n\tcb := func(c Client, m Message) {\n\t\tcalledback <- true\n\t}\n\n\tpub := packets.NewControlPacket(packets.Publish).(*packets.PublishPacket)\n\tpub.Qos = 2\n\tpub.TopicName = \"a\"\n\tpub.Payload = []byte(\"foo\")\n\n\tmsgs := make(chan *packets.PublishPacket)\n\n\trouter := newRouter()\n\trouter.addRoute(\"a\", cb)\n\n\tstopped := make(chan bool)\n\tgo func() {\n\t\trouter.matchAndDispatch(msgs, true, &client{oboundP: make(chan *PacketAndToken, 100)})\n\t\tstopped <- true\n\t}()\n\tmsgs <- pub\n\n\t<-calledback\n\n\tclose(msgs)\n\n\tselect {\n\tcase <-stopped:\n\t\tbreak\n\tcase <-time.After(time.Second):\n\t\tt.Errorf(\"matchAndDispatch should have exited\")\n\t}\n}\n\nfunc Test_SharedSubscription_MatchAndDispatch(t *testing.T) {\n\tcalledback := make(chan bool)\n\n\tcb := func(c Client, m Message) {\n\t\tcalledback <- true\n\t}\n\n\tpub := packets.NewControlPacket(packets.Publish).(*packets.PublishPacket)\n\tpub.Qos = 2\n\tpub.TopicName = \"a\"\n\tpub.Payload = []byte(\"foo\")\n\n\tmsgs := make(chan *packets.PublishPacket)\n\n\trouter := newRouter()\n\trouter.addRoute(\"$share/az1/a\", cb)\n\n\tstopped := make(chan bool)\n\tgo func() {\n\t\trouter.matchAndDispatch(msgs, true, &client{oboundP: make(chan *PacketAndToken, 100)})\n\t\tstopped <- true\n\t}()\n\n\tmsgs <- pub\n\n\t<-calledback\n\n\tclose(msgs)\n\n\tselect {\n\tcase <-stopped:\n\t\tbreak\n\tcase <-time.After(time.Second):\n\t\tt.Errorf(\"matchAndDispatch should have exited\")\n\t}\n\n}\n"
        },
        {
          "name": "unit_status_test.go",
          "type": "blob",
          "size": 12.2236328125,
          "content": "/*\n * Copyright (c) 2022 IBM Corp and others.\n *\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v2.0\n * and Eclipse Distribution License v1.0 which accompany this distribution.\n *\n * The Eclipse Public License is available at\n *    https://www.eclipse.org/legal/epl-2.0/\n * and the Eclipse Distribution License is available at\n *   http://www.eclipse.org/org/documents/edl-v10.php.\n *\n * Contributors:\n *    Matt Brittan\n */\n\npackage mqtt\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n\t\"time\"\n)\n\nfunc Test_BasicStatusOperations(t *testing.T) {\n\tt.Parallel()\n\ts := connectionStatus{}\n\tif s.ConnectionStatus() != disconnected {\n\t\tt.Fatalf(\"Expected disconnected; got: %v\", s.ConnectionStatus())\n\t}\n\n\t// Normal connection and disconnection\n\tcf, err := s.Connecting()\n\tif err != nil {\n\t\tt.Fatalf(\"Error connecting: %v\", err)\n\t}\n\tif s.ConnectionStatus() != connecting {\n\t\tt.Fatalf(\"Expected connecting; got: %v\", s.ConnectionStatus())\n\t}\n\tif err = cf(true); err != nil {\n\t\tt.Fatalf(\"Error completing connection: %v\", err)\n\t}\n\tif s.ConnectionStatus() != connected {\n\t\tt.Fatalf(\"Expected connected; got: %v\", s.ConnectionStatus())\n\t}\n\n\t// reconnect so we test all statuses\n\trf, err := s.ConnectionLost(true)\n\tif err != nil {\n\t\tt.Fatalf(\"Error calling connection lost: %v\", err)\n\t}\n\tif s.ConnectionStatus() != disconnecting {\n\t\tt.Fatalf(\"Expected disconnecting; got: %v\", s.ConnectionStatus())\n\t}\n\tif cf, err = rf(true); err != nil {\n\t\tt.Fatalf(\"Error completing disconnection portion of reconnect: %v\", err)\n\t}\n\tif s.ConnectionStatus() != reconnecting {\n\t\tt.Fatalf(\"Expected reconnecting; got: %v\", s.ConnectionStatus())\n\t}\n\tif err = cf(true); err != nil {\n\t\tt.Fatalf(\"Error completing reconnection: %v\", err)\n\t}\n\tif s.ConnectionStatus() != connected {\n\t\tt.Fatalf(\"Expected connected(2); got: %v\", s.ConnectionStatus())\n\t}\n\n\t// And disconnect\n\tdf, err := s.Disconnecting()\n\tif err != nil {\n\t\tt.Fatalf(\"Error disconnecting: %v\", err)\n\t}\n\tif s.ConnectionStatus() != disconnecting {\n\t\tt.Fatalf(\"Expected disconnecting; got: %v\", s.ConnectionStatus())\n\t}\n\tdf()\n\tif s.ConnectionStatus() != disconnected {\n\t\tt.Fatalf(\"Expected disconnected; got: %v\", s.ConnectionStatus())\n\t}\n}\n\n// Test_AdvancedStatusOperations checks a few of the more unusual transitions\nfunc Test_AdvancedStatusOperations(t *testing.T) {\n\tt.Parallel()\n\n\t// Aborted connection (i.e. user triggered)\n\ts := connectionStatus{}\n\tif s.ConnectionStatus() != disconnected {\n\t\tt.Fatalf(\"Expected disconnected; got: %v\", s.ConnectionStatus())\n\t}\n\n\t// Normal connection and disconnection\n\tcf, err := s.Connecting()\n\tif err != nil {\n\t\tt.Fatalf(\"Error connecting: %v\", err)\n\t}\n\tif s.ConnectionStatus() != connecting {\n\t\tt.Fatalf(\"Expected connecting; got: %v\", s.ConnectionStatus())\n\t}\n\tif err = cf(false); err != nil { // Unsuccessful connection (e.g. user aborted connection)\n\t\tt.Fatalf(\"Error completing connection: %v\", err)\n\t}\n\tif s.ConnectionStatus() != disconnected {\n\t\tt.Fatalf(\"Expected disconnected; got: %v\", s.ConnectionStatus())\n\t}\n\n\t// Connection lost - no reconnection requested\n\ts = connectionStatus{status: connected}\n\trf, err := s.ConnectionLost(false)\n\tif err != nil {\n\t\tt.Fatalf(\"Error connecting: %v\", err)\n\t}\n\tif s.ConnectionStatus() != disconnecting {\n\t\tt.Fatalf(\"Expected disconnecting; got: %v\", s.ConnectionStatus())\n\t}\n\tcf, err = rf(true) // argument should be ignored as no reconnect was requested\n\tif cf != nil {\n\t\tt.Fatalf(\"Function to complete reconnection should not be returned (as reconnection not requested)\")\n\t}\n\tif err != nil {\n\t\tt.Fatalf(\"Error completing connection lost operation: %v\", err)\n\t}\n\tif s.ConnectionStatus() != disconnected {\n\t\tt.Fatalf(\"Expected disconnected; got: %v\", s.ConnectionStatus())\n\t}\n\n\t// Aborted reconnection - stage 1 (i.e. user triggered whist disconnect in progress)\n\ts = connectionStatus{status: connected}\n\trf, err = s.ConnectionLost(true)\n\tif err != nil {\n\t\tt.Fatalf(\"Error connecting: %v\", err)\n\t}\n\tif s.ConnectionStatus() != disconnecting {\n\t\tt.Fatalf(\"Expected disconnecting; got: %v\", s.ConnectionStatus())\n\t}\n\tcf, err = rf(false)\n\tif cf != nil {\n\t\tt.Fatalf(\"Function to complete reconnection should not be returned (as reconnection not requested)\")\n\t}\n\tif err != nil {\n\t\tt.Fatalf(\"Error completing connection lost operation: %v\", err)\n\t}\n\tif s.ConnectionStatus() != disconnected {\n\t\tt.Fatalf(\"Expected disconnected; got: %v\", s.ConnectionStatus())\n\t}\n\n\t// Aborted reconnection - stage 2 (i.e. user triggered whist disconnect in progress)\n\ts = connectionStatus{status: connected}\n\trf, err = s.ConnectionLost(true)\n\tif err != nil {\n\t\tt.Fatalf(\"Error connecting: %v\", err)\n\t}\n\tif s.ConnectionStatus() != disconnecting {\n\t\tt.Fatalf(\"Expected disconnecting; got: %v\", s.ConnectionStatus())\n\t}\n\tcf, err = rf(true)\n\tif err != nil {\n\t\tt.Fatalf(\"Error completing connection lost operation: %v\", err)\n\t}\n\tif cf == nil {\n\t\tt.Fatalf(\"Function to complete reconnection should be returned (as reconnection requested)\")\n\t}\n\tif s.ConnectionStatus() != reconnecting {\n\t\tt.Fatalf(\"Expected reconnecting; got: %v\", s.ConnectionStatus())\n\t}\n\tif err = cf(false); err != nil {\n\t\tt.Fatalf(\"Error completing reconnection: %v\", err)\n\t}\n\tif s.ConnectionStatus() != disconnected {\n\t\tt.Fatalf(\"Expected disconnected; got: %v\", s.ConnectionStatus())\n\t}\n}\n\nfunc Test_AbortedConnection(t *testing.T) {\n\tt.Parallel()\n\ts := connectionStatus{}\n\tif s.ConnectionStatus() != disconnected {\n\t\tt.Fatalf(\"Expected disconnected; got: %v\", s.ConnectionStatus())\n\t}\n\n\t// Start Connection\n\tcf, err := s.Connecting()\n\tif err != nil {\n\t\tt.Fatalf(\"Error connecting: %v\", err)\n\t}\n\tif s.ConnectionStatus() != connecting {\n\t\tt.Fatalf(\"Expected connecting; got: %v\", s.ConnectionStatus())\n\t}\n\n\t// Another goroutine calls Disconnect\n\tdiscErr := make(chan error)\n\tgo func() {\n\t\tdfFn, err := s.Disconnecting()\n\t\tdiscErr <- err\n\t\tdfFn()\n\t\tclose(discErr)\n\t}()\n\ttime.Sleep(time.Millisecond) // Provide time for Disconnect call to run\n\tif s.ConnectionStatus() != disconnecting {\n\t\tt.Fatalf(\"Expected disconnecting; got: %v\", s.ConnectionStatus())\n\t}\n\tselect {\n\tcase err = <-discErr:\n\t\tt.Fatalf(\"Disconnecting must block until connection attempt terminates: %v\", err)\n\tdefault:\n\t}\n\n\terr = cf(true) // status should not matter\n\tif err != errAbortConnection {\n\t\tt.Fatalf(\"Expected errAbortConnection got: %v\", err)\n\t}\n\tif s.ConnectionStatus() != disconnecting {\n\t\tt.Fatalf(\"Expected disconnecting; got: %v\", s.ConnectionStatus())\n\t}\n\n\tselect {\n\tcase err = <-discErr:\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"Did not expect an error: %v\", err)\n\t\t}\n\tcase <-time.After(time.Second):\n\t\tt.Fatalf(\"Timeout waiting for goroutine to complete\")\n\t}\n\n\ttime.Sleep(time.Millisecond) // Provide time for other goroutine to complete\n\tif s.ConnectionStatus() != disconnected {\n\t\tt.Fatalf(\"Expected disconnected; got: %v\", s.ConnectionStatus())\n\t}\n\tselect {\n\tcase <-discErr: // channel should be closed\n\tdefault:\n\t\tt.Fatalf(\"Completion of connect should unblock Disconnecting call\")\n\t}\n}\n\nfunc Test_AbortedReConnection(t *testing.T) {\n\tt.Parallel()\n\ts := connectionStatus{status: connected} // start in connected state\n\tif s.ConnectionStatus() != connected {\n\t\tt.Fatalf(\"Expected connected; got: %v\", s.ConnectionStatus())\n\t}\n\n\t// Connection is lost but we want to reconnect\n\tlhf, err := s.ConnectionLost(true)\n\tif err != nil {\n\t\tt.Fatalf(\"Unexpected error: %v\", err)\n\t}\n\n\t// Another goroutine calls Disconnect\n\tdiscErr := make(chan error)\n\tgo func() {\n\t\tdfFn, err := s.Disconnecting()\n\t\tif dfFn != nil {\n\t\t\tdiscErr <- fmt.Errorf(\"should not get a functiuon back from s.Disconnecting in this case\")\n\t\t\treturn\n\t\t}\n\t\tdiscErr <- err\n\t}()\n\ttime.Sleep(time.Millisecond) // Provide time for Disconnect call to run\n\tif s.ConnectionStatus() != disconnecting {\n\t\tt.Fatalf(\"Expected disconnecting; got: %v\", s.ConnectionStatus())\n\t}\n\tselect {\n\tcase err = <-discErr:\n\t\tt.Fatalf(\"Disconnecting must block until reconnection attempt terminates: %v\", err)\n\tdefault:\n\t}\n\n\tcf, err := lhf(true) // status should not matter\n\tif cf != nil {\n\t\tt.Fatalf(\"As Disconnect has been called we should not have any ability to continue\")\n\t}\n\tif err != errDisconnectionRequested {\n\t\tt.Fatalf(\"Expected errDisconnectionRequested got: %v\", err)\n\t}\n\tif s.ConnectionStatus() != disconnected {\n\t\tt.Fatalf(\"Expected disconnected; got: %v\", s.ConnectionStatus())\n\t}\n\n\tselect {\n\tcase err = <-discErr:\n\t\tif err != errAlreadyDisconnected {\n\t\t\tt.Fatalf(\"Expected errAlreadyDisconnected got: %v\", err)\n\t\t}\n\tcase <-time.After(time.Second):\n\t\tt.Fatalf(\"Timeout waiting for goroutine to complete\")\n\t}\n}\n\n// Test_ConnectionLostDuringConnect don't really expect this to happen due to connMu\n// If it does happen and reconnect is true the results would not be great\nfunc Test_ConnectionLostDuringConnect(t *testing.T) {\n\tt.Parallel()\n\ts := connectionStatus{}\n\tif s.ConnectionStatus() != disconnected {\n\t\tt.Fatalf(\"Expected disconnected; got: %v\", s.ConnectionStatus())\n\t}\n\n\t// Start Connection\n\tcf, err := s.Connecting()\n\tif err != nil {\n\t\tt.Fatalf(\"Error connecting: %v\", err)\n\t}\n\tif s.ConnectionStatus() != connecting {\n\t\tt.Fatalf(\"Expected connecting; got: %v\", s.ConnectionStatus())\n\t}\n\n\t// Another goroutine calls ConnectionLost (don't expect this to every actually happen but...)\n\tclErr := make(chan error)\n\tgo func() {\n\t\t_, err := s.ConnectionLost(false)\n\t\tclErr <- err\n\t}()\n\ttime.Sleep(time.Millisecond) // Provide time for Disconnect call to run\n\tif s.ConnectionStatus() != disconnecting {\n\t\tt.Fatalf(\"Expected disconnecting; got: %v\", s.ConnectionStatus())\n\t}\n\tselect {\n\tcase err = <-clErr:\n\t\tt.Fatalf(\"ConnectionLost must block until connection attempt terminates: %v\", err)\n\tdefault:\n\t}\n\n\terr = cf(true) // status should not matter\n\tif err != errAbortConnection {\n\t\tt.Fatalf(\"Expected errAbortConnection got: %v\", err)\n\t}\n\tif s.ConnectionStatus() != disconnecting {\n\t\tt.Fatalf(\"Expected disconnecting; got: %v\", s.ConnectionStatus())\n\t}\n\n\tselect {\n\tcase err = <-clErr:\n\t\tif err != errAlreadyDisconnected {\n\t\t\tt.Fatalf(\"Expected errAlreadyDisconnected got: %v\", err)\n\t\t}\n\tcase <-time.After(time.Second):\n\t\tt.Fatalf(\"Timeout waiting for goroutine to complete\")\n\t}\n}\n\n/*\nclErr := make(chan error)\n\tgo func() {\n\t\trf, err := s.ConnectionLost(false)\n\t\tclErr <- err\n\t\tcf, err := rf(false)\n\t\tif err != errAlreadyDisconnected {\n\t\t\tclErr <- fmt.Errorf(\"expected errAlreadyDisconnected got %v\", err)\n\t\t}\n\t\tif cf != nil {\n\t\t\tclErr <- fmt.Errorf(\"cf is not nil\")\n\t\t}\n\t\tclose(clErr)\n\n\t}()\n\ttime.Sleep(time.Millisecond) // Provide time for Disconnect call to run\n\tif s.ConnectionStatus() != disconnecting {\n\t\tt.Fatalf(\"Expected disconnecting; got: %v\", s.ConnectionStatus())\n\t}\n\tselect {\n\tcase err = <-clErr:\n\t\tt.Fatalf(\"ConnectionLost must block until connection attempt terminates: %v\", err)\n\tdefault:\n\t}\n\n\terr = cf(true) // status should not matter\n\tif err != errAbortConnection {\n\t\tt.Fatalf(\"Expected errAbortConnection got: %v\", err)\n\t}\n\tif s.ConnectionStatus() != disconnecting {\n\t\tt.Fatalf(\"Expected disconnecting; got: %v\", s.ConnectionStatus())\n\t}\n\n\tselect {\n\tcase err = <-clErr:\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"Did not expect an error: %v\", err)\n\t\t}\n\tcase <-time.After(time.Second):\n\t\tt.Fatalf(\"Timeout waiting for goroutine to complete\")\n\t}\n\n\ttime.Sleep(time.Millisecond) // Provide time for other goroutine to complete\n\tif s.ConnectionStatus() != disconnected {\n\t\tt.Fatalf(\"Expected disconnected; got: %v\", s.ConnectionStatus())\n\t}\n\tselect {\n\tcase <-clErr: // channel should be closed\n\tdefault:\n\t\tt.Fatalf(\"Completion of connect should unblock Disconnecting call\")\n\t}\n*/\n\n/*\n// TODO - Test aborting functions etc\n\ndisconnected -> `Connecting()` -> connecting -> `connCompletedFn(true)` -> connected\nconnected -> `Disconnecting()` -> disconnecting -> `disconnectCompletedFn()` -> disconnected\nconnected -> `ConnectionLost(false)` -> disconnecting -> `connectionLostHandledFn(true/false)` -> disconnected\nconnected -> `ConnectionLost(true)` -> disconnecting -> `connectionLostHandledFn(true)` -> connected\n\nUnfortunately the above workflows are complicated by the fact that `Disconnecting()` or `ConnectionLost()` may,\npotentially, be called at any time (i.e.whilst in the middle of transitioning between states).If this happens:\n\n* The state will be set to disconnecting (which will prevent any request to move the status to connected)\n* The call to `Disconnecting()`/`ConnectionLost()` will block until the previously active call completes and then\nhandle the disconnection.\n\nReading the tests (unit_client_test.go ) might help understand these rules.\n*/\n"
        },
        {
          "name": "unit_store_test.go",
          "type": "blob",
          "size": 12.7626953125,
          "content": "/*\n * Copyright (c) 2021 IBM Corp and others.\n *\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v2.0\n * and Eclipse Distribution License v1.0 which accompany this distribution.\n *\n * The Eclipse Public License is available at\n *    https://www.eclipse.org/legal/epl-2.0/\n * and the Eclipse Distribution License is available at\n *   http://www.eclipse.org/org/documents/edl-v10.php.\n *\n * Contributors:\n *    Seth Hoenig\n *    Allan Stockdill-Mander\n *    Mike Robertson\n */\n\npackage mqtt\n\nimport (\n\t\"testing\"\n\n\t\"github.com/eclipse/paho.mqtt.golang/packets\"\n)\n\nfunc Test_fullpath(t *testing.T) {\n\tp := fullpath(\"/tmp/store\", \"o.44324\")\n\te := \"/tmp/store/o.44324.msg\"\n\tif p != e {\n\t\tt.Fatalf(\"full path expected %s, got %s\", e, p)\n\t}\n}\n\nfunc Test_exists(t *testing.T) {\n\tb := exists(\"/\")\n\tif !b {\n\t\tt.Errorf(\"/proc/cpuinfo was not found\")\n\t}\n}\n\nfunc Test_exists_no(t *testing.T) {\n\tb := exists(\"/this/path/is/not/real/i/hope\")\n\tif b {\n\t\tt.Errorf(\"you have some strange files\")\n\t}\n}\n\nfunc Test_mIDFromKey(t *testing.T) {\n\tkey := \"i.123\"\n\texp := uint16(123)\n\tres := mIDFromKey(key)\n\tif exp != res {\n\t\tt.Fatalf(\"mIDFromKey failed\")\n\t}\n}\n\nfunc Test_inboundKeyFromMID(t *testing.T) {\n\tid := uint16(9876)\n\texp := \"i.9876\"\n\tres := inboundKeyFromMID(id)\n\tif exp != res {\n\t\tt.Fatalf(\"inboundKeyFromMID failed\")\n\t}\n}\n\nfunc Test_outboundKeyFromMID(t *testing.T) {\n\tid := uint16(7654)\n\texp := \"o.7654\"\n\tres := outboundKeyFromMID(id)\n\tif exp != res {\n\t\tt.Fatalf(\"outboundKeyFromMID failed\")\n\t}\n}\n\n/************************\n **** persistOutbound ****\n ************************/\n\nfunc Test_persistOutbound_connect(t *testing.T) {\n\tts := &TestStore{}\n\tm := packets.NewControlPacket(packets.Connect).(*packets.ConnectPacket)\n\tm.Qos = 0\n\tm.Username = \"user\"\n\tm.Password = []byte(\"pass\")\n\tm.ClientIdentifier = \"cid\"\n\t// m := newConnectMsg(false, false, QOS_ZERO, false, \"\", nil, \"cid\", \"user\", \"pass\", 10)\n\tpersistOutbound(ts, m)\n\n\tif len(ts.mput) != 0 {\n\t\tt.Fatalf(\"persistOutbound put message it should not have\")\n\t}\n\n\tif len(ts.mget) != 0 {\n\t\tt.Fatalf(\"persistOutbound get message it should not have\")\n\t}\n\n\tif len(ts.mdel) != 0 {\n\t\tt.Fatalf(\"persistOutbound del message it should not have\")\n\t}\n}\n\nfunc Test_persistOutbound_publish_0(t *testing.T) {\n\tts := &TestStore{}\n\tm := packets.NewControlPacket(packets.Publish).(*packets.PublishPacket)\n\tm.Qos = 0\n\tm.TopicName = \"/popub0\"\n\tm.Payload = []byte{0xBB, 0x00}\n\tm.MessageID = 40\n\tpersistOutbound(ts, m)\n\n\tif len(ts.mput) != 0 {\n\t\tt.Fatalf(\"persistOutbound put message it should not have\")\n\t}\n\n\tif len(ts.mget) != 0 {\n\t\tt.Fatalf(\"persistOutbound get message it should not have\")\n\t}\n\n\tif len(ts.mdel) != 0 {\n\t\tt.Fatalf(\"persistOutbound del message it should not have\")\n\t}\n}\n\nfunc Test_persistOutbound_publish_1(t *testing.T) {\n\tts := &TestStore{}\n\tm := packets.NewControlPacket(packets.Publish).(*packets.PublishPacket)\n\tm.Qos = 1\n\tm.TopicName = \"/popub1\"\n\tm.Payload = []byte{0xBB, 0x00}\n\tm.MessageID = 41\n\tpersistOutbound(ts, m)\n\n\tif len(ts.mput) != 1 || ts.mput[0] != 41 {\n\t\tt.Fatalf(\"persistOutbound put message it should not have\")\n\t}\n\n\tif len(ts.mget) != 0 {\n\t\tt.Fatalf(\"persistOutbound get message it should not have\")\n\t}\n\n\tif len(ts.mdel) != 0 {\n\t\tt.Fatalf(\"persistOutbound del message it should not have\")\n\t}\n}\n\nfunc Test_persistOutbound_publish_2(t *testing.T) {\n\tts := &TestStore{}\n\tm := packets.NewControlPacket(packets.Publish).(*packets.PublishPacket)\n\tm.Qos = 2\n\tm.TopicName = \"/popub2\"\n\tm.Payload = []byte{0xBB, 0x00}\n\tm.MessageID = 42\n\tpersistOutbound(ts, m)\n\n\tif len(ts.mput) != 1 || ts.mput[0] != 42 {\n\t\tt.Fatalf(\"persistOutbound put message it should not have\")\n\t}\n\n\tif len(ts.mget) != 0 {\n\t\tt.Fatalf(\"persistOutbound get message it should not have\")\n\t}\n\n\tif len(ts.mdel) != 0 {\n\t\tt.Fatalf(\"persistOutbound del message it should not have\")\n\t}\n}\n\nfunc Test_persistOutbound_puback(t *testing.T) {\n\tts := &TestStore{}\n\tm := packets.NewControlPacket(packets.Puback).(*packets.PubackPacket)\n\tpersistOutbound(ts, m)\n\n\tif len(ts.mput) != 0 {\n\t\tt.Fatalf(\"persistOutbound put message it should not have\")\n\t}\n\n\tif len(ts.mget) != 0 {\n\t\tt.Fatalf(\"persistOutbound get message it should not have\")\n\t}\n\n\tif len(ts.mdel) != 1 {\n\t\tt.Fatalf(\"persistOutbound del message it should not have\")\n\t}\n}\n\nfunc Test_persistOutbound_pubrec(t *testing.T) {\n\tts := &TestStore{}\n\tm := packets.NewControlPacket(packets.Pubrec).(*packets.PubrecPacket)\n\tpersistOutbound(ts, m)\n\n\tif len(ts.mput) != 0 {\n\t\tt.Fatalf(\"persistOutbound put message it should not have\")\n\t}\n\n\tif len(ts.mget) != 0 {\n\t\tt.Fatalf(\"persistOutbound get message it should not have\")\n\t}\n\n\tif len(ts.mdel) != 0 {\n\t\tt.Fatalf(\"persistOutbound del message it should not have\")\n\t}\n}\n\nfunc Test_persistOutbound_pubrel(t *testing.T) {\n\tts := &TestStore{}\n\tm := packets.NewControlPacket(packets.Pubrel).(*packets.PubrelPacket)\n\tm.MessageID = 43\n\n\tpersistOutbound(ts, m)\n\n\tif len(ts.mput) != 1 || ts.mput[0] != 43 {\n\t\tt.Fatalf(\"persistOutbound put message it should not have\")\n\t}\n\n\tif len(ts.mget) != 0 {\n\t\tt.Fatalf(\"persistOutbound get message it should not have\")\n\t}\n\n\tif len(ts.mdel) != 0 {\n\t\tt.Fatalf(\"persistOutbound del message it should not have\")\n\t}\n}\n\nfunc Test_persistOutbound_pubcomp(t *testing.T) {\n\tts := &TestStore{}\n\tm := packets.NewControlPacket(packets.Pubcomp).(*packets.PubcompPacket)\n\tpersistOutbound(ts, m)\n\n\tif len(ts.mput) != 0 {\n\t\tt.Fatalf(\"persistOutbound put message it should not have\")\n\t}\n\n\tif len(ts.mget) != 0 {\n\t\tt.Fatalf(\"persistOutbound get message it should not have\")\n\t}\n\n\tif len(ts.mdel) != 1 {\n\t\tt.Fatalf(\"persistOutbound del message it should not have\")\n\t}\n}\n\nfunc Test_persistOutbound_subscribe(t *testing.T) {\n\tts := &TestStore{}\n\tm := packets.NewControlPacket(packets.Subscribe).(*packets.SubscribePacket)\n\tm.Topics = []string{\"/posub\"}\n\tm.Qoss = []byte{1}\n\tm.MessageID = 44\n\tpersistOutbound(ts, m)\n\n\tif len(ts.mput) != 1 || ts.mput[0] != 44 {\n\t\tt.Fatalf(\"persistOutbound put message it should not have\")\n\t}\n\n\tif len(ts.mget) != 0 {\n\t\tt.Fatalf(\"persistOutbound get message it should not have\")\n\t}\n\n\tif len(ts.mdel) != 0 {\n\t\tt.Fatalf(\"persistOutbound del message it should not have\")\n\t}\n}\n\nfunc Test_persistOutbound_unsubscribe(t *testing.T) {\n\tts := &TestStore{}\n\tm := packets.NewControlPacket(packets.Unsubscribe).(*packets.UnsubscribePacket)\n\tm.Topics = []string{\"/posub\"}\n\tm.MessageID = 45\n\tpersistOutbound(ts, m)\n\n\tif len(ts.mput) != 1 || ts.mput[0] != 45 {\n\t\tt.Fatalf(\"persistOutbound put message it should not have\")\n\t}\n\n\tif len(ts.mget) != 0 {\n\t\tt.Fatalf(\"persistOutbound get message it should not have\")\n\t}\n\n\tif len(ts.mdel) != 0 {\n\t\tt.Fatalf(\"persistOutbound del message it should not have\")\n\t}\n}\n\nfunc Test_persistOutbound_pingreq(t *testing.T) {\n\tts := &TestStore{}\n\tm := packets.NewControlPacket(packets.Pingreq)\n\tpersistOutbound(ts, m)\n\n\tif len(ts.mput) != 0 {\n\t\tt.Fatalf(\"persistOutbound put message it should not have\")\n\t}\n\n\tif len(ts.mget) != 0 {\n\t\tt.Fatalf(\"persistOutbound get message it should not have\")\n\t}\n\n\tif len(ts.mdel) != 0 {\n\t\tt.Fatalf(\"persistOutbound del message it should not have\")\n\t}\n}\n\nfunc Test_persistOutbound_disconnect(t *testing.T) {\n\tts := &TestStore{}\n\tm := packets.NewControlPacket(packets.Disconnect)\n\tpersistOutbound(ts, m)\n\n\tif len(ts.mput) != 0 {\n\t\tt.Fatalf(\"persistOutbound put message it should not have\")\n\t}\n\n\tif len(ts.mget) != 0 {\n\t\tt.Fatalf(\"persistOutbound get message it should not have\")\n\t}\n\n\tif len(ts.mdel) != 0 {\n\t\tt.Fatalf(\"persistOutbound del message it should not have\")\n\t}\n}\n\n/************************\n **** persistInbound ****\n ************************/\n\nfunc Test_persistInbound_connack(t *testing.T) {\n\tts := &TestStore{}\n\tm := packets.NewControlPacket(packets.Connack)\n\tpersistInbound(ts, m)\n\n\tif len(ts.mput) != 0 {\n\t\tt.Fatalf(\"persistInbound in bad state\")\n\t}\n\n\tif len(ts.mget) != 0 {\n\t\tt.Fatalf(\"persistInbound in bad state\")\n\t}\n\n\tif len(ts.mdel) != 0 {\n\t\tt.Fatalf(\"persistInbound in bad state\")\n\t}\n}\n\nfunc Test_persistInbound_publish_0(t *testing.T) {\n\tts := &TestStore{}\n\tm := packets.NewControlPacket(packets.Publish).(*packets.PublishPacket)\n\tm.Qos = 0\n\tm.TopicName = \"/pipub0\"\n\tm.Payload = []byte{0xCC, 0x01}\n\tm.MessageID = 50\n\tpersistInbound(ts, m)\n\n\tif len(ts.mput) != 0 {\n\t\tt.Fatalf(\"persistInbound in bad state\")\n\t}\n\n\tif len(ts.mget) != 0 {\n\t\tt.Fatalf(\"persistInbound in bad state\")\n\t}\n\n\tif len(ts.mdel) != 0 {\n\t\tt.Fatalf(\"persistInbound in bad state\")\n\t}\n}\n\nfunc Test_persistInbound_publish_1(t *testing.T) {\n\tts := &TestStore{}\n\tm := packets.NewControlPacket(packets.Publish).(*packets.PublishPacket)\n\tm.Qos = 1\n\tm.TopicName = \"/pipub1\"\n\tm.Payload = []byte{0xCC, 0x02}\n\tm.MessageID = 51\n\tpersistInbound(ts, m)\n\n\tif len(ts.mput) != 1 || ts.mput[0] != 51 {\n\t\tt.Fatalf(\"persistInbound in bad state\")\n\t}\n\n\tif len(ts.mget) != 0 {\n\t\tt.Fatalf(\"persistInbound in bad state\")\n\t}\n\n\tif len(ts.mdel) != 0 {\n\t\tt.Fatalf(\"persistInbound in bad state\")\n\t}\n}\n\nfunc Test_persistInbound_publish_2(t *testing.T) {\n\tts := &TestStore{}\n\tm := packets.NewControlPacket(packets.Publish).(*packets.PublishPacket)\n\tm.Qos = 2\n\tm.TopicName = \"/pipub2\"\n\tm.Payload = []byte{0xCC, 0x03}\n\tm.MessageID = 52\n\tpersistInbound(ts, m)\n\n\tif len(ts.mput) != 1 || ts.mput[0] != 52 {\n\t\tt.Fatalf(\"persistInbound in bad state\")\n\t}\n\n\tif len(ts.mget) != 0 {\n\t\tt.Fatalf(\"persistInbound in bad state\")\n\t}\n\n\tif len(ts.mdel) != 0 {\n\t\tt.Fatalf(\"persistInbound in bad state\")\n\t}\n}\n\nfunc Test_persistInbound_puback(t *testing.T) {\n\tts := &TestStore{}\n\tpub := packets.NewControlPacket(packets.Publish).(*packets.PublishPacket)\n\tpub.Qos = 1\n\tpub.TopicName = \"/pub1\"\n\tpub.Payload = []byte{0xCC, 0x04}\n\tpub.MessageID = 53\n\tpublishKey := inboundKeyFromMID(pub.MessageID)\n\tts.Put(publishKey, pub)\n\n\tm := packets.NewControlPacket(packets.Puback).(*packets.PubackPacket)\n\tm.MessageID = 53\n\n\tpersistInbound(ts, m) // \"deletes\" packets.Publish from store\n\n\tif len(ts.mput) != 1 { // not actually deleted in TestStore\n\t\tt.Fatalf(\"persistInbound in bad state\")\n\t}\n\n\tif len(ts.mget) != 0 {\n\t\tt.Fatalf(\"persistInbound in bad state\")\n\t}\n\n\tif len(ts.mdel) != 1 || ts.mdel[0] != 53 {\n\t\tt.Fatalf(\"persistInbound in bad state\")\n\t}\n}\n\nfunc Test_persistInbound_pubrec(t *testing.T) {\n\tts := &TestStore{}\n\tpub := packets.NewControlPacket(packets.Publish).(*packets.PublishPacket)\n\tpub.Qos = 2\n\tpub.TopicName = \"/pub2\"\n\tpub.Payload = []byte{0xCC, 0x05}\n\tpub.MessageID = 54\n\tpublishKey := inboundKeyFromMID(pub.MessageID)\n\tts.Put(publishKey, pub)\n\n\tm := packets.NewControlPacket(packets.Pubrec).(*packets.PubrecPacket)\n\tm.MessageID = 54\n\n\tpersistInbound(ts, m)\n\n\tif len(ts.mput) != 1 || ts.mput[0] != 54 {\n\t\tt.Fatalf(\"persistInbound in bad state\")\n\t}\n\n\tif len(ts.mget) != 0 {\n\t\tt.Fatalf(\"persistInbound in bad state\")\n\t}\n\n\tif len(ts.mdel) != 0 {\n\t\tt.Fatalf(\"persistInbound in bad state\")\n\t}\n}\n\nfunc Test_persistInbound_pubrel(t *testing.T) {\n\tts := &TestStore{}\n\tpub := packets.NewControlPacket(packets.Publish).(*packets.PublishPacket)\n\tpub.Qos = 2\n\tpub.TopicName = \"/pub2\"\n\tpub.Payload = []byte{0xCC, 0x06}\n\tpub.MessageID = 55\n\tpublishKey := inboundKeyFromMID(pub.MessageID)\n\tts.Put(publishKey, pub)\n\n\tm := packets.NewControlPacket(packets.Pubrel).(*packets.PubrelPacket)\n\tm.MessageID = 55\n\n\tpersistInbound(ts, m) // will overwrite publish\n\n\tif len(ts.mput) != 2 {\n\t\tt.Fatalf(\"persistInbound in bad state\")\n\t}\n\n\tif len(ts.mget) != 0 {\n\t\tt.Fatalf(\"persistInbound in bad state\")\n\t}\n\n\tif len(ts.mdel) != 0 {\n\t\tt.Fatalf(\"persistInbound in bad state\")\n\t}\n}\n\nfunc Test_persistInbound_pubcomp(t *testing.T) {\n\tts := &TestStore{}\n\n\tm := packets.NewControlPacket(packets.Pubcomp).(*packets.PubcompPacket)\n\tm.MessageID = 56\n\n\tpersistInbound(ts, m)\n\n\tif len(ts.mput) != 0 {\n\t\tt.Fatalf(\"persistInbound in bad state\")\n\t}\n\n\tif len(ts.mget) != 0 {\n\t\tt.Fatalf(\"persistInbound in bad state\")\n\t}\n\n\tif len(ts.mdel) != 1 || ts.mdel[0] != 56 {\n\t\tt.Fatalf(\"persistInbound in bad state\")\n\t}\n}\n\nfunc Test_persistInbound_suback(t *testing.T) {\n\tts := &TestStore{}\n\n\tm := packets.NewControlPacket(packets.Suback).(*packets.SubackPacket)\n\tm.MessageID = 57\n\n\tpersistInbound(ts, m)\n\n\tif len(ts.mput) != 0 {\n\t\tt.Fatalf(\"persistInbound in bad state\")\n\t}\n\n\tif len(ts.mget) != 0 {\n\t\tt.Fatalf(\"persistInbound in bad state\")\n\t}\n\n\tif len(ts.mdel) != 1 || ts.mdel[0] != 57 {\n\t\tt.Fatalf(\"persistInbound in bad state\")\n\t}\n}\n\nfunc Test_persistInbound_unsuback(t *testing.T) {\n\tts := &TestStore{}\n\n\tm := packets.NewControlPacket(packets.Unsuback).(*packets.UnsubackPacket)\n\tm.MessageID = 58\n\n\tpersistInbound(ts, m)\n\n\tif len(ts.mput) != 0 {\n\t\tt.Fatalf(\"persistInbound in bad state\")\n\t}\n\n\tif len(ts.mget) != 0 {\n\t\tt.Fatalf(\"persistInbound in bad state\")\n\t}\n\n\tif len(ts.mdel) != 1 || ts.mdel[0] != 58 {\n\t\tt.Fatalf(\"persistInbound in bad state\")\n\t}\n}\n\nfunc Test_persistInbound_pingresp(t *testing.T) {\n\tts := &TestStore{}\n\tm := packets.NewControlPacket(packets.Pingresp)\n\n\tpersistInbound(ts, m)\n\n\tif len(ts.mput) != 0 {\n\t\tt.Fatalf(\"persistInbound in bad state\")\n\t}\n\n\tif len(ts.mget) != 0 {\n\t\tt.Fatalf(\"persistInbound in bad state\")\n\t}\n\n\tif len(ts.mdel) != 0 {\n\t\tt.Fatalf(\"persistInbound in bad state\")\n\t}\n}\n"
        },
        {
          "name": "unit_topic_test.go",
          "type": "blob",
          "size": 1.2451171875,
          "content": "/*\n * Copyright (c) 2021 IBM Corp and others.\n *\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v2.0\n * and Eclipse Distribution License v1.0 which accompany this distribution.\n *\n * The Eclipse Public License is available at\n *    https://www.eclipse.org/legal/epl-2.0/\n * and the Eclipse Distribution License is available at\n *   http://www.eclipse.org/org/documents/edl-v10.php.\n *\n * Contributors:\n *    Seth Hoenig\n *    Allan Stockdill-Mander\n *    Mike Robertson\n */\n\npackage mqtt\n\nimport (\n\t\"testing\"\n)\n\nfunc Test_ValidateTopicAndQos_qos3(t *testing.T) {\n\te := validateTopicAndQos(\"a\", 3)\n\tif e != ErrInvalidQos {\n\t\tt.Fatalf(\"invalid error for invalid qos\")\n\t}\n}\n\nfunc Test_ValidateTopicAndQos_ES(t *testing.T) {\n\te := validateTopicAndQos(\"\", 0)\n\tif e != ErrInvalidTopicEmptyString {\n\t\tt.Fatalf(\"invalid error for empty topic name\")\n\t}\n}\n\nfunc Test_ValidateTopicAndQos_a_0(t *testing.T) {\n\te := validateTopicAndQos(\"a\", 0)\n\tif e != nil {\n\t\tt.Fatalf(\"error from valid NewTopicFilter\")\n\t}\n}\n\nfunc Test_ValidateTopicAndQos_H(t *testing.T) {\n\te := validateTopicAndQos(\"a/#/c\", 0)\n\tif e != ErrInvalidTopicMultilevel {\n\t\tt.Fatalf(\"invalid error for bad multilevel topic filter\")\n\t}\n}\n"
        },
        {
          "name": "websocket.go",
          "type": "blob",
          "size": 3.0859375,
          "content": "/*\n * This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v2.0\n * and Eclipse Distribution License v1.0 which accompany this distribution.\n *\n * The Eclipse Public License is available at\n *    https://www.eclipse.org/legal/epl-2.0/\n * and the Eclipse Distribution License is available at\n *   http://www.eclipse.org/org/documents/edl-v10.php.\n *\n * Contributors:\n */\n\npackage mqtt\n\nimport (\n\t\"crypto/tls\"\n\t\"fmt\"\n\t\"io\"\n\t\"net\"\n\t\"net/http\"\n\t\"net/url\"\n\t\"sync\"\n\t\"time\"\n\n\t\"github.com/gorilla/websocket\"\n)\n\n// WebsocketOptions are config options for a websocket dialer\ntype WebsocketOptions struct {\n\tReadBufferSize  int\n\tWriteBufferSize int\n\tProxy           ProxyFunction\n}\n\ntype ProxyFunction func(req *http.Request) (*url.URL, error)\n\n// NewWebsocket returns a new websocket and returns a net.Conn compatible interface using the gorilla/websocket package\nfunc NewWebsocket(host string, tlsc *tls.Config, timeout time.Duration, requestHeader http.Header, options *WebsocketOptions) (net.Conn, error) {\n\tif timeout == 0 {\n\t\ttimeout = 10 * time.Second\n\t}\n\n\tif options == nil {\n\t\t// Apply default options\n\t\toptions = &WebsocketOptions{}\n\t}\n\tif options.Proxy == nil {\n\t\toptions.Proxy = http.ProxyFromEnvironment\n\t}\n\tdialer := &websocket.Dialer{\n\t\tProxy:             options.Proxy,\n\t\tHandshakeTimeout:  timeout,\n\t\tEnableCompression: false,\n\t\tTLSClientConfig:   tlsc,\n\t\tSubprotocols:      []string{\"mqtt\"},\n\t\tReadBufferSize:    options.ReadBufferSize,\n\t\tWriteBufferSize:   options.WriteBufferSize,\n\t}\n\n\tws, resp, err := dialer.Dial(host, requestHeader)\n\n\tif err != nil {\n\t\tif resp != nil {\n\t\t\tWARN.Println(CLI, fmt.Sprintf(\"Websocket handshake failure. StatusCode: %d. Body: %s\", resp.StatusCode, resp.Body))\n\t\t}\n\t\treturn nil, err\n\t}\n\n\twrapper := &websocketConnector{\n\t\tConn: ws,\n\t}\n\treturn wrapper, err\n}\n\n// websocketConnector is a websocket wrapper so it satisfies the net.Conn interface so it is a\n// drop in replacement of the golang.org/x/net/websocket package.\n// Implementation guide taken from https://github.com/gorilla/websocket/issues/282\ntype websocketConnector struct {\n\t*websocket.Conn\n\tr   io.Reader\n\trio sync.Mutex\n\twio sync.Mutex\n}\n\n// SetDeadline sets both the read and write deadlines\nfunc (c *websocketConnector) SetDeadline(t time.Time) error {\n\tif err := c.SetReadDeadline(t); err != nil {\n\t\treturn err\n\t}\n\terr := c.SetWriteDeadline(t)\n\treturn err\n}\n\n// Write writes data to the websocket\nfunc (c *websocketConnector) Write(p []byte) (int, error) {\n\tc.wio.Lock()\n\tdefer c.wio.Unlock()\n\n\terr := c.WriteMessage(websocket.BinaryMessage, p)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\treturn len(p), nil\n}\n\n// Read reads the current websocket frame\nfunc (c *websocketConnector) Read(p []byte) (int, error) {\n\tc.rio.Lock()\n\tdefer c.rio.Unlock()\n\tfor {\n\t\tif c.r == nil {\n\t\t\t// Advance to next message.\n\t\t\tvar err error\n\t\t\t_, c.r, err = c.NextReader()\n\t\t\tif err != nil {\n\t\t\t\treturn 0, err\n\t\t\t}\n\t\t}\n\t\tn, err := c.r.Read(p)\n\t\tif err == io.EOF {\n\t\t\t// At end of message.\n\t\t\tc.r = nil\n\t\t\tif n > 0 {\n\t\t\t\treturn n, nil\n\t\t\t}\n\t\t\t// No data read, continue to next message.\n\t\t\tcontinue\n\t\t}\n\t\treturn n, err\n\t}\n}\n"
        }
      ]
    }
  ]
}