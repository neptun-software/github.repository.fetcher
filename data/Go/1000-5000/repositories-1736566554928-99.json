{
  "metadata": {
    "timestamp": 1736566554928,
    "page": 99,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjEwMA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "oklog/ulid",
      "stars": 4581,
      "defaultBranch": "main",
      "files": [
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.3212890625,
          "content": "#### joe made this: http://goel.io/joe\n\n#####=== Go ===#####\n\n# Compiled Object files, Static and Dynamic libs (Shared Objects)\n*.o\n*.a\n*.so\n\n# Folders\n_obj\n_test\n\n# Architecture specific extensions/prefixes\n*.[568vq]\n[568vq].out\n\n*.cgo1.go\n*.cgo2.c\n_cgo_defun.c\n_cgo_gotypes.go\n_cgo_export.*\n\n_testmain.go\n\n*.exe\n*.test\n*.prof\n\n"
        },
        {
          "name": "AUTHORS.md",
          "type": "blob",
          "size": 0.0576171875,
          "content": "- Peter Bourgon (@peterbourgon)\n- Tom√°s Senart (@tsenart)\n"
        },
        {
          "name": "CHANGELOG.md",
          "type": "blob",
          "size": 0.6787109375,
          "content": "## 1.3.1 / 2018-10-02\n\n* Use underlying entropy source for random increments in Monotonic (#32)\n\n## 1.3.0 / 2018-09-29\n\n* Monotonic entropy support (#31)\n\n## 1.2.0 / 2018-09-09\n\n* Add a function to convert Unix time in milliseconds back to time.Time (#30)\n\n## 1.1.0 / 2018-08-15\n\n* Ensure random part is always read from the entropy reader in full (#28)\n\n## 1.0.0 / 2018-07-29\n\n* Add ParseStrict and MustParseStrict functions (#26)\n* Enforce overflow checking when parsing (#20)\n\n## 0.3.0 / 2017-01-03\n\n* Implement ULID.Compare method\n\n## 0.2.0 / 2016-12-13\n\n* Remove year 2262 Timestamp bug. (#1)\n* Gracefully handle invalid encodings when parsing.\n\n## 0.1.0 / 2016-12-06\n\n* First ULID release\n"
        },
        {
          "name": "CONTRIBUTING.md",
          "type": "blob",
          "size": 0.751953125,
          "content": "# Contributing\n\nWe use GitHub to manage reviews of pull requests.\n\n* If you have a trivial fix or improvement, go ahead and create a pull\n  request, addressing (with `@...`) one or more of the maintainers\n  (see [AUTHORS.md](AUTHORS.md)) in the description of the pull request.\n\n* If you plan to do something more involved, first propose your ideas\n  in a Github issue. This will avoid unnecessary work and surely give\n  you and us a good deal of inspiration.\n\n* Relevant coding style guidelines are the [Go Code Review\n  Comments](https://code.google.com/p/go-wiki/wiki/CodeReviewComments)\n  and the _Formatting and style_ section of Peter Bourgon's [Go: Best\n  Practices for Production\n  Environments](http://peter.bourgon.org/go-in-production/#formatting-and-style).\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 11.0908203125,
          "content": "                                 Apache License\n                           Version 2.0, January 2004\n                        http://www.apache.org/licenses/\n\n   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION\n\n   1. Definitions.\n\n      \"License\" shall mean the terms and conditions for use, reproduction,\n      and distribution as defined by Sections 1 through 9 of this document.\n\n      \"Licensor\" shall mean the copyright owner or entity authorized by\n      the copyright owner that is granting the License.\n\n      \"Legal Entity\" shall mean the union of the acting entity and all\n      other entities that control, are controlled by, or are under common\n      control with that entity. For the purposes of this definition,\n      \"control\" means (i) the power, direct or indirect, to cause the\n      direction or management of such entity, whether by contract or\n      otherwise, or (ii) ownership of fifty percent (50%) or more of the\n      outstanding shares, or (iii) beneficial ownership of such entity.\n\n      \"You\" (or \"Your\") shall mean an individual or Legal Entity\n      exercising permissions granted by this License.\n\n      \"Source\" form shall mean the preferred form for making modifications,\n      including but not limited to software source code, documentation\n      source, and configuration files.\n\n      \"Object\" form shall mean any form resulting from mechanical\n      transformation or translation of a Source form, including but\n      not limited to compiled object code, generated documentation,\n      and conversions to other media types.\n\n      \"Work\" shall mean the work of authorship, whether in Source or\n      Object form, made available under the License, as indicated by a\n      copyright notice that is included in or attached to the work\n      (an example is provided in the Appendix below).\n\n      \"Derivative Works\" shall mean any work, whether in Source or Object\n      form, that is based on (or derived from) the Work and for which the\n      editorial revisions, annotations, elaborations, or other modifications\n      represent, as a whole, an original work of authorship. For the purposes\n      of this License, Derivative Works shall not include works that remain\n      separable from, or merely link (or bind by name) to the interfaces of,\n      the Work and Derivative Works thereof.\n\n      \"Contribution\" shall mean any work of authorship, including\n      the original version of the Work and any modifications or additions\n      to that Work or Derivative Works thereof, that is intentionally\n      submitted to Licensor for inclusion in the Work by the copyright owner\n      or by an individual or Legal Entity authorized to submit on behalf of\n      the copyright owner. For the purposes of this definition, \"submitted\"\n      means any form of electronic, verbal, or written communication sent\n      to the Licensor or its representatives, including but not limited to\n      communication on electronic mailing lists, source code control systems,\n      and issue tracking systems that are managed by, or on behalf of, the\n      Licensor for the purpose of discussing and improving the Work, but\n      excluding communication that is conspicuously marked or otherwise\n      designated in writing by the copyright owner as \"Not a Contribution.\"\n\n      \"Contributor\" shall mean Licensor and any individual or Legal Entity\n      on behalf of whom a Contribution has been received by Licensor and\n      subsequently incorporated within the Work.\n\n   2. Grant of Copyright License. Subject to the terms and conditions of\n      this License, each Contributor hereby grants to You a perpetual,\n      worldwide, non-exclusive, no-charge, royalty-free, irrevocable\n      copyright license to reproduce, prepare Derivative Works of,\n      publicly display, publicly perform, sublicense, and distribute the\n      Work and such Derivative Works in Source or Object form.\n\n   3. Grant of Patent License. Subject to the terms and conditions of\n      this License, each Contributor hereby grants to You a perpetual,\n      worldwide, non-exclusive, no-charge, royalty-free, irrevocable\n      (except as stated in this section) patent license to make, have made,\n      use, offer to sell, sell, import, and otherwise transfer the Work,\n      where such license applies only to those patent claims licensable\n      by such Contributor that are necessarily infringed by their\n      Contribution(s) alone or by combination of their Contribution(s)\n      with the Work to which such Contribution(s) was submitted. If You\n      institute patent litigation against any entity (including a\n      cross-claim or counterclaim in a lawsuit) alleging that the Work\n      or a Contribution incorporated within the Work constitutes direct\n      or contributory patent infringement, then any patent licenses\n      granted to You under this License for that Work shall terminate\n      as of the date such litigation is filed.\n\n   4. Redistribution. You may reproduce and distribute copies of the\n      Work or Derivative Works thereof in any medium, with or without\n      modifications, and in Source or Object form, provided that You\n      meet the following conditions:\n\n      (a) You must give any other recipients of the Work or\n          Derivative Works a copy of this License; and\n\n      (b) You must cause any modified files to carry prominent notices\n          stating that You changed the files; and\n\n      (c) You must retain, in the Source form of any Derivative Works\n          that You distribute, all copyright, patent, trademark, and\n          attribution notices from the Source form of the Work,\n          excluding those notices that do not pertain to any part of\n          the Derivative Works; and\n\n      (d) If the Work includes a \"NOTICE\" text file as part of its\n          distribution, then any Derivative Works that You distribute must\n          include a readable copy of the attribution notices contained\n          within such NOTICE file, excluding those notices that do not\n          pertain to any part of the Derivative Works, in at least one\n          of the following places: within a NOTICE text file distributed\n          as part of the Derivative Works; within the Source form or\n          documentation, if provided along with the Derivative Works; or,\n          within a display generated by the Derivative Works, if and\n          wherever such third-party notices normally appear. The contents\n          of the NOTICE file are for informational purposes only and\n          do not modify the License. You may add Your own attribution\n          notices within Derivative Works that You distribute, alongside\n          or as an addendum to the NOTICE text from the Work, provided\n          that such additional attribution notices cannot be construed\n          as modifying the License.\n\n      You may add Your own copyright statement to Your modifications and\n      may provide additional or different license terms and conditions\n      for use, reproduction, or distribution of Your modifications, or\n      for any such Derivative Works as a whole, provided Your use,\n      reproduction, and distribution of the Work otherwise complies with\n      the conditions stated in this License.\n\n   5. Submission of Contributions. Unless You explicitly state otherwise,\n      any Contribution intentionally submitted for inclusion in the Work\n      by You to the Licensor shall be under the terms and conditions of\n      this License, without any additional terms or conditions.\n      Notwithstanding the above, nothing herein shall supersede or modify\n      the terms of any separate license agreement you may have executed\n      with Licensor regarding such Contributions.\n\n   6. Trademarks. This License does not grant permission to use the trade\n      names, trademarks, service marks, or product names of the Licensor,\n      except as required for reasonable and customary use in describing the\n      origin of the Work and reproducing the content of the NOTICE file.\n\n   7. Disclaimer of Warranty. Unless required by applicable law or\n      agreed to in writing, Licensor provides the Work (and each\n      Contributor provides its Contributions) on an \"AS IS\" BASIS,\n      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n      implied, including, without limitation, any warranties or conditions\n      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A\n      PARTICULAR PURPOSE. You are solely responsible for determining the\n      appropriateness of using or redistributing the Work and assume any\n      risks associated with Your exercise of permissions under this License.\n\n   8. Limitation of Liability. In no event and under no legal theory,\n      whether in tort (including negligence), contract, or otherwise,\n      unless required by applicable law (such as deliberate and grossly\n      negligent acts) or agreed to in writing, shall any Contributor be\n      liable to You for damages, including any direct, indirect, special,\n      incidental, or consequential damages of any character arising as a\n      result of this License or out of the use or inability to use the\n      Work (including but not limited to damages for loss of goodwill,\n      work stoppage, computer failure or malfunction, or any and all\n      other commercial damages or losses), even if such Contributor\n      has been advised of the possibility of such damages.\n\n   9. Accepting Warranty or Additional Liability. While redistributing\n      the Work or Derivative Works thereof, You may choose to offer,\n      and charge a fee for, acceptance of support, warranty, indemnity,\n      or other liability obligations and/or rights consistent with this\n      License. However, in accepting such obligations, You may act only\n      on Your own behalf and on Your sole responsibility, not on behalf\n      of any other Contributor, and only if You agree to indemnify,\n      defend, and hold each Contributor harmless for any liability\n      incurred by, or claims asserted against, such Contributor by reason\n      of your accepting any such warranty or additional liability.\n\n   END OF TERMS AND CONDITIONS\n\n   APPENDIX: How to apply the Apache License to your work.\n\n      To apply the Apache License to your work, attach the following\n      boilerplate notice, with the fields enclosed by brackets \"[]\"\n      replaced with your own identifying information. (Don't include\n      the brackets!)  The text should be enclosed in the appropriate\n      comment syntax for the file format. We also recommend that a\n      file or class name and description of purpose be included on the\n      same \"printed page\" as the copyright notice for easier\n      identification within third-party archives.\n\n   Copyright [yyyy] [name of copyright owner]\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n       http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 10.0166015625,
          "content": "# Universally Unique Lexicographically Sortable Identifier\n\n[![Project status](https://img.shields.io/github/release/oklog/ulid.svg?style=flat-square)](https://github.com/oklog/ulid/releases/latest)\n![Build Status](https://github.com/oklog/ulid/actions/workflows/test.yml/badge.svg)\n[![Go Report Card](https://goreportcard.com/badge/oklog/ulid?cache=0)](https://goreportcard.com/report/oklog/ulid)\n[![Coverage Status](https://coveralls.io/repos/github/oklog/ulid/badge.svg?branch=master&cache=0)](https://coveralls.io/github/oklog/ulid?branch=master)\n[![go.dev reference](https://img.shields.io/badge/go.dev-reference-007d9c?logo=go&logoColor=white&style=flat-square)](https://pkg.go.dev/github.com/oklog/ulid/v2)\n[![Apache 2 licensed](https://img.shields.io/badge/license-Apache2-blue.svg)](https://raw.githubusercontent.com/oklog/ulid/master/LICENSE)\n\nA Go port of [ulid/javascript](https://github.com/ulid/javascript) with binary format implemented.\n\n## Background\n\nA GUID/UUID can be suboptimal for many use-cases because:\n\n- It isn't the most character efficient way of encoding 128 bits\n- UUID v1/v2 is impractical in many environments, as it requires access to a unique, stable MAC address\n- UUID v3/v5 requires a unique seed and produces randomly distributed IDs, which can cause fragmentation in many data structures\n- UUID v4 provides no other information than randomness which can cause fragmentation in many data structures\n\nA ULID however:\n\n- Is compatible with UUID/GUID's\n- 1.21e+24 unique ULIDs per millisecond (1,208,925,819,614,629,174,706,176 to be exact)\n- Lexicographically sortable\n- Canonically encoded as a 26 character string, as opposed to the 36 character UUID\n- Uses Crockford's base32 for better efficiency and readability (5 bits per character)\n- Case insensitive\n- No special characters (URL safe)\n- Monotonic sort order (correctly detects and handles the same millisecond)\n\n## Install\n\nThis package requires Go modules.\n\n```shell\ngo get github.com/oklog/ulid/v2\n```\n\n## Usage\n\nULIDs are constructed from two things: a timestamp with millisecond precision,\nand some random data.\n\nTimestamps are modeled as uint64 values representing a Unix time in milliseconds.\nThey can be produced by passing a [time.Time](https://pkg.go.dev/time#Time) to\n[ulid.Timestamp](https://pkg.go.dev/github.com/oklog/ulid/v2#Timestamp),\nor by calling  [time.Time.UnixMilli](https://pkg.go.dev/time#Time.UnixMilli)\nand converting the returned value to `uint64`.\n\nRandom data is taken from a provided [io.Reader](https://pkg.go.dev/io#Reader).\nThis design allows for greater flexibility when choosing trade-offs, but can be\na bit confusing to newcomers.\n\nIf you just want to generate a ULID and don't (yet) care about details like\nperformance, cryptographic security, etc., use the\n[ulid.Make](https://pkg.go.dev/github.com/oklog/ulid/v2#Make) helper function.\nThis function calls [time.Now](https://pkg.go.dev/time#Now) to get a timestamp,\nand uses a source of entropy which is process-global,\n[pseudo-random](https://pkg.go.dev/math/rand), and\n[monotonic](https://pkg.go.dev/github.com/oklog/ulid/v2#LockedMonotonicReader).\n\n```go\nfmt.Println(ulid.Make())\n// 01G65Z755AFWAKHE12NY0CQ9FH\n```\n\nMore advanced use cases should utilize\n[ulid.New](https://pkg.go.dev/github.com/oklog/ulid/v2#New).\n\n```go\nentropy := rand.New(rand.NewSource(time.Now().UnixNano()))\nms := ulid.Timestamp(time.Now())\nfmt.Println(ulid.New(ms, entropy))\n// 01G65Z755AFWAKHE12NY0CQ9FH\n```\n\nCare should be taken when providing a source of entropy.\n\nThe above example utilizes [math/rand.Rand](https://pkg.go.dev/math/rand#Rand),\nwhich is not safe for concurrent use by multiple goroutines. Consider\nalternatives such as\n[x/exp/rand](https://pkg.go.dev/golang.org/x/exp/rand#LockedSource).\nSecurity-sensitive use cases should always use cryptographically secure entropy\nprovided by [crypto/rand](https://pkg.go.dev/crypto/rand).\n\nPerformance-sensitive use cases should avoid synchronization when generating\nIDs. One option is to use a unique source of entropy for each concurrent\ngoroutine, which results in no lock contention, but cannot provide strong\nguarantees about the random data, and does not provide monotonicity within a\ngiven millisecond. One common performance optimization is to pool sources of\nentropy using a [sync.Pool](https://pkg.go.dev/sync#Pool).\n\nMonotonicity is a property that says each ULID is \"bigger than\" the previous\none. ULIDs are automatically monotonic, but only to millisecond precision. ULIDs\ngenerated within the same millisecond are ordered by their random component,\nwhich means they are by default un-ordered. You can use\n[ulid.MonotonicEntropy](https://pkg.go.dev/github.com/oklog/ulid/v2#MonotonicEntropy) or\n[ulid.LockedMonotonicEntropy](https://pkg.go.dev/github.com/oklog/ulid/v2#LockedMonotonicEntropy)\nto create ULIDs that are monotonic within a given millisecond, with caveats. See\nthe documentation for details.\n\nIf you don't care about time-based ordering of generated IDs, then there's no\nreason to use ULIDs! There are many other kinds of IDs that are easier, faster,\nsmaller, etc. Consider UUIDs.\n\n## Commandline tool\n\nThis repo also provides a tool to generate and parse ULIDs at the command line.\n\n```shell\ngo install github.com/oklog/ulid/v2/cmd/ulid@latest\n```\n\nUsage:\n\n```shell\nUsage: ulid [-hlqz] [-f <format>] [parameters ...]\n -f, --format=<format>  when parsing, show times in this format: default, rfc3339, unix, ms\n -h, --help             print this help text\n -l, --local            when parsing, show local time instead of UTC\n -q, --quick            when generating, use non-crypto-grade entropy\n -z, --zero             when generating, fix entropy to all-zeroes\n```\n\nExamples:\n\n```shell\n$ ulid\n01D78XYFJ1PRM1WPBCBT3VHMNV\n$ ulid -z\n01D78XZ44G0000000000000000\n$ ulid 01D78XZ44G0000000000000000\nSun Mar 31 03:51:23.536 UTC 2019\n$ ulid --format=rfc3339 --local 01D78XZ44G0000000000000000\n2019-03-31T05:51:23.536+02:00\n```\n\n## Specification\n\nBelow is the current specification of ULID as implemented in this repository.\n\n### Components\n\n**Timestamp**\n- 48 bits\n- UNIX-time in milliseconds\n- Won't run out of space till the year 10889 AD\n\n**Entropy**\n- 80 bits\n- User defined entropy source.\n- Monotonicity within the same millisecond with [`ulid.Monotonic`](https://godoc.org/github.com/oklog/ulid#Monotonic)\n\n### Encoding\n\n[Crockford's Base32](http://www.crockford.com/wrmg/base32.html) is used as shown.\nThis alphabet excludes the letters I, L, O, and U to avoid confusion and abuse.\n\n```\n0123456789ABCDEFGHJKMNPQRSTVWXYZ\n```\n\n### Binary Layout and Byte Order\n\nThe components are encoded as 16 octets. Each component is encoded with the Most Significant Byte first (network byte order).\n\n```\n0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                      32_bit_uint_time_high                    |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|     16_bit_uint_time_low      |       16_bit_uint_random      |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                       32_bit_uint_random                      |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                       32_bit_uint_random                      |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n```\n\n### String Representation\n\n```\n 01AN4Z07BY      79KA1307SR9X4MV3\n|----------|    |----------------|\n Timestamp           Entropy\n  10 chars           16 chars\n   48bits             80bits\n   base32             base32\n```\n\n## Test\n\n```shell\ngo test ./...\n```\n\n## Benchmarks\n\nOn a Intel Core i7 Ivy Bridge 2.7 GHz, MacOS 10.12.1 and Go 1.8.0beta1\n\n```\nBenchmarkNew/WithCryptoEntropy-8      2000000        771 ns/op      20.73 MB/s   16 B/op   1 allocs/op\nBenchmarkNew/WithEntropy-8            20000000      65.8 ns/op     243.01 MB/s   16 B/op   1 allocs/op\nBenchmarkNew/WithoutEntropy-8         50000000      30.0 ns/op     534.06 MB/s   16 B/op   1 allocs/op\nBenchmarkMustNew/WithCryptoEntropy-8  2000000        781 ns/op      20.48 MB/s   16 B/op   1 allocs/op\nBenchmarkMustNew/WithEntropy-8        20000000      70.0 ns/op     228.51 MB/s   16 B/op   1 allocs/op\nBenchmarkMustNew/WithoutEntropy-8     50000000      34.6 ns/op     462.98 MB/s   16 B/op   1 allocs/op\nBenchmarkParse-8                      50000000      30.0 ns/op     866.16 MB/s    0 B/op   0 allocs/op\nBenchmarkMustParse-8                  50000000      35.2 ns/op     738.94 MB/s    0 B/op   0 allocs/op\nBenchmarkString-8                     20000000      64.9 ns/op     246.40 MB/s   32 B/op   1 allocs/op\nBenchmarkMarshal/Text-8               20000000      55.8 ns/op     286.84 MB/s   32 B/op   1 allocs/op\nBenchmarkMarshal/TextTo-8             100000000     22.4 ns/op     714.91 MB/s    0 B/op   0 allocs/op\nBenchmarkMarshal/Binary-8             300000000     4.02 ns/op    3981.77 MB/s    0 B/op   0 allocs/op\nBenchmarkMarshal/BinaryTo-8           2000000000    1.18 ns/op   13551.75 MB/s    0 B/op   0 allocs/op\nBenchmarkUnmarshal/Text-8             100000000     20.5 ns/op    1265.27 MB/s    0 B/op   0 allocs/op\nBenchmarkUnmarshal/Binary-8           300000000     4.94 ns/op    3240.01 MB/s    0 B/op   0 allocs/op\nBenchmarkNow-8                        100000000     15.1 ns/op     528.09 MB/s    0 B/op   0 allocs/op\nBenchmarkTimestamp-8                  2000000000    0.29 ns/op   27271.59 MB/s    0 B/op   0 allocs/op\nBenchmarkTime-8                       2000000000    0.58 ns/op   13717.80 MB/s    0 B/op   0 allocs/op\nBenchmarkSetTime-8                    2000000000    0.89 ns/op    9023.95 MB/s    0 B/op   0 allocs/op\nBenchmarkEntropy-8                    200000000     7.62 ns/op    1311.66 MB/s    0 B/op   0 allocs/op\nBenchmarkSetEntropy-8                 2000000000    0.88 ns/op   11376.54 MB/s    0 B/op   0 allocs/op\nBenchmarkCompare-8                    200000000     7.34 ns/op    4359.23 MB/s    0 B/op   0 allocs/op\n```\n\n## Prior Art\n\n- [ulid/javascript](https://github.com/ulid/javascript)\n- [RobThree/NUlid](https://github.com/RobThree/NUlid)\n- [imdario/go-ulid](https://github.com/imdario/go-ulid)\n"
        },
        {
          "name": "cmd",
          "type": "tree",
          "content": null
        },
        {
          "name": "go.mod",
          "type": "blob",
          "size": 0.1083984375,
          "content": "module github.com/oklog/ulid/v2\n\ngo 1.15\n\nrequire github.com/pborman/getopt v0.0.0-20170112200414-7148bc3a4c30\n"
        },
        {
          "name": "go.sum",
          "type": "blob",
          "size": 0.2197265625,
          "content": "github.com/pborman/getopt v0.0.0-20170112200414-7148bc3a4c30 h1:BHT1/DKsYDGkUgQ2jmMaozVcdk+sVfz0+1ZJq4zkWgw=\ngithub.com/pborman/getopt v0.0.0-20170112200414-7148bc3a4c30/go.mod h1:85jBQOZwpVEaDAr341tbn15RS4fCAsIst0qp7i8ex1o=\n"
        },
        {
          "name": "ulid.go",
          "type": "blob",
          "size": 22.0380859375,
          "content": "// Copyright 2016 The Oklog Authors\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage ulid\n\nimport (\n\t\"bufio\"\n\t\"bytes\"\n\t\"database/sql/driver\"\n\t\"encoding/binary\"\n\t\"errors\"\n\t\"io\"\n\t\"math\"\n\t\"math/bits\"\n\t\"math/rand\"\n\t\"sync\"\n\t\"time\"\n)\n\n/*\nA ULID is a 16 byte Universally Unique Lexicographically Sortable Identifier\n\n\tThe components are encoded as 16 octets.\n\tEach component is encoded with the MSB first (network byte order).\n\n\t0                   1                   2                   3\n\t0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n\t+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\t|                      32_bit_uint_time_high                    |\n\t+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\t|     16_bit_uint_time_low      |       16_bit_uint_random      |\n\t+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\t|                       32_bit_uint_random                      |\n\t+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\t|                       32_bit_uint_random                      |\n\t+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n*/\ntype ULID [16]byte\n\nvar (\n\t// ErrDataSize is returned when parsing or unmarshaling ULIDs with the wrong\n\t// data size.\n\tErrDataSize = errors.New(\"ulid: bad data size when unmarshaling\")\n\n\t// ErrInvalidCharacters is returned when parsing or unmarshaling ULIDs with\n\t// invalid Base32 encodings.\n\tErrInvalidCharacters = errors.New(\"ulid: bad data characters when unmarshaling\")\n\n\t// ErrBufferSize is returned when marshalling ULIDs to a buffer of insufficient\n\t// size.\n\tErrBufferSize = errors.New(\"ulid: bad buffer size when marshaling\")\n\n\t// ErrBigTime is returned when constructing a ULID with a time that is larger\n\t// than MaxTime.\n\tErrBigTime = errors.New(\"ulid: time too big\")\n\n\t// ErrOverflow is returned when unmarshaling a ULID whose first character is\n\t// larger than 7, thereby exceeding the valid bit depth of 128.\n\tErrOverflow = errors.New(\"ulid: overflow when unmarshaling\")\n\n\t// ErrMonotonicOverflow is returned by a Monotonic entropy source when\n\t// incrementing the previous ULID's entropy bytes would result in overflow.\n\tErrMonotonicOverflow = errors.New(\"ulid: monotonic entropy overflow\")\n\n\t// ErrScanValue is returned when the value passed to scan cannot be unmarshaled\n\t// into the ULID.\n\tErrScanValue = errors.New(\"ulid: source value must be a string or byte slice\")\n\n\t// Zero is a zero-value ULID.\n\tZero ULID\n)\n\n// MonotonicReader is an interface that should yield monotonically increasing\n// entropy into the provided slice for all calls with the same ms parameter. If\n// a MonotonicReader is provided to the New constructor, its MonotonicRead\n// method will be used instead of Read.\ntype MonotonicReader interface {\n\tio.Reader\n\tMonotonicRead(ms uint64, p []byte) error\n}\n\n// New returns a ULID with the given Unix milliseconds timestamp and an\n// optional entropy source. Use the Timestamp function to convert\n// a time.Time to Unix milliseconds.\n//\n// ErrBigTime is returned when passing a timestamp bigger than MaxTime.\n// Reading from the entropy source may also return an error.\n//\n// Safety for concurrent use is only dependent on the safety of the\n// entropy source.\nfunc New(ms uint64, entropy io.Reader) (id ULID, err error) {\n\tif err = id.SetTime(ms); err != nil {\n\t\treturn id, err\n\t}\n\n\tswitch e := entropy.(type) {\n\tcase nil:\n\t\treturn id, err\n\tcase MonotonicReader:\n\t\terr = e.MonotonicRead(ms, id[6:])\n\tdefault:\n\t\t_, err = io.ReadFull(e, id[6:])\n\t}\n\n\treturn id, err\n}\n\n// MustNew is a convenience function equivalent to New that panics on failure\n// instead of returning an error.\nfunc MustNew(ms uint64, entropy io.Reader) ULID {\n\tid, err := New(ms, entropy)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\treturn id\n}\n\n// MustNewDefault is a convenience function equivalent to MustNew with\n// DefaultEntropy as the entropy. It may panic if the given time.Time is too\n// large or too small.\nfunc MustNewDefault(t time.Time) ULID {\n\treturn MustNew(Timestamp(t), defaultEntropy)\n}\n\nvar defaultEntropy = func() io.Reader {\n\trng := rand.New(rand.NewSource(time.Now().UnixNano()))\n\treturn &LockedMonotonicReader{MonotonicReader: Monotonic(rng, 0)}\n}()\n\n// DefaultEntropy returns a thread-safe per process monotonically increasing\n// entropy source.\nfunc DefaultEntropy() io.Reader {\n\treturn defaultEntropy\n}\n\n// Make returns a ULID with the current time in Unix milliseconds and\n// monotonically increasing entropy for the same millisecond.\n// It is safe for concurrent use, leveraging a sync.Pool underneath for minimal\n// contention.\nfunc Make() (id ULID) {\n\t// NOTE: MustNew can't panic since DefaultEntropy never returns an error.\n\treturn MustNew(Now(), defaultEntropy)\n}\n\n// Parse parses an encoded ULID, returning an error in case of failure.\n//\n// ErrDataSize is returned if the len(ulid) is different from an encoded\n// ULID's length. Invalid encodings produce undefined ULIDs. For a version that\n// returns an error instead, see ParseStrict.\nfunc Parse(ulid string) (id ULID, err error) {\n\treturn id, parse([]byte(ulid), false, &id)\n}\n\n// ParseStrict parses an encoded ULID, returning an error in case of failure.\n//\n// It is like Parse, but additionally validates that the parsed ULID consists\n// only of valid base32 characters. It is slightly slower than Parse.\n//\n// ErrDataSize is returned if the len(ulid) is different from an encoded\n// ULID's length. Invalid encodings return ErrInvalidCharacters.\nfunc ParseStrict(ulid string) (id ULID, err error) {\n\treturn id, parse([]byte(ulid), true, &id)\n}\n\nfunc parse(v []byte, strict bool, id *ULID) error {\n\t// Check if a base32 encoded ULID is the right length.\n\tif len(v) != EncodedSize {\n\t\treturn ErrDataSize\n\t}\n\n\t// Check if all the characters in a base32 encoded ULID are part of the\n\t// expected base32 character set.\n\tif strict &&\n\t\t(dec[v[0]] == 0xFF ||\n\t\t\tdec[v[1]] == 0xFF ||\n\t\t\tdec[v[2]] == 0xFF ||\n\t\t\tdec[v[3]] == 0xFF ||\n\t\t\tdec[v[4]] == 0xFF ||\n\t\t\tdec[v[5]] == 0xFF ||\n\t\t\tdec[v[6]] == 0xFF ||\n\t\t\tdec[v[7]] == 0xFF ||\n\t\t\tdec[v[8]] == 0xFF ||\n\t\t\tdec[v[9]] == 0xFF ||\n\t\t\tdec[v[10]] == 0xFF ||\n\t\t\tdec[v[11]] == 0xFF ||\n\t\t\tdec[v[12]] == 0xFF ||\n\t\t\tdec[v[13]] == 0xFF ||\n\t\t\tdec[v[14]] == 0xFF ||\n\t\t\tdec[v[15]] == 0xFF ||\n\t\t\tdec[v[16]] == 0xFF ||\n\t\t\tdec[v[17]] == 0xFF ||\n\t\t\tdec[v[18]] == 0xFF ||\n\t\t\tdec[v[19]] == 0xFF ||\n\t\t\tdec[v[20]] == 0xFF ||\n\t\t\tdec[v[21]] == 0xFF ||\n\t\t\tdec[v[22]] == 0xFF ||\n\t\t\tdec[v[23]] == 0xFF ||\n\t\t\tdec[v[24]] == 0xFF ||\n\t\t\tdec[v[25]] == 0xFF) {\n\t\treturn ErrInvalidCharacters\n\t}\n\n\t// Check if the first character in a base32 encoded ULID will overflow. This\n\t// happens because the base32 representation encodes 130 bits, while the\n\t// ULID is only 128 bits.\n\t//\n\t// See https://github.com/oklog/ulid/issues/9 for details.\n\tif v[0] > '7' {\n\t\treturn ErrOverflow\n\t}\n\n\t// Use an optimized unrolled loop (from https://github.com/RobThree/NUlid)\n\t// to decode a base32 ULID.\n\n\t// 6 bytes timestamp (48 bits)\n\t(*id)[0] = (dec[v[0]] << 5) | dec[v[1]]\n\t(*id)[1] = (dec[v[2]] << 3) | (dec[v[3]] >> 2)\n\t(*id)[2] = (dec[v[3]] << 6) | (dec[v[4]] << 1) | (dec[v[5]] >> 4)\n\t(*id)[3] = (dec[v[5]] << 4) | (dec[v[6]] >> 1)\n\t(*id)[4] = (dec[v[6]] << 7) | (dec[v[7]] << 2) | (dec[v[8]] >> 3)\n\t(*id)[5] = (dec[v[8]] << 5) | dec[v[9]]\n\n\t// 10 bytes of entropy (80 bits)\n\t(*id)[6] = (dec[v[10]] << 3) | (dec[v[11]] >> 2)\n\t(*id)[7] = (dec[v[11]] << 6) | (dec[v[12]] << 1) | (dec[v[13]] >> 4)\n\t(*id)[8] = (dec[v[13]] << 4) | (dec[v[14]] >> 1)\n\t(*id)[9] = (dec[v[14]] << 7) | (dec[v[15]] << 2) | (dec[v[16]] >> 3)\n\t(*id)[10] = (dec[v[16]] << 5) | dec[v[17]]\n\t(*id)[11] = (dec[v[18]] << 3) | dec[v[19]]>>2\n\t(*id)[12] = (dec[v[19]] << 6) | (dec[v[20]] << 1) | (dec[v[21]] >> 4)\n\t(*id)[13] = (dec[v[21]] << 4) | (dec[v[22]] >> 1)\n\t(*id)[14] = (dec[v[22]] << 7) | (dec[v[23]] << 2) | (dec[v[24]] >> 3)\n\t(*id)[15] = (dec[v[24]] << 5) | dec[v[25]]\n\n\treturn nil\n}\n\n// MustParse is a convenience function equivalent to Parse that panics on failure\n// instead of returning an error.\nfunc MustParse(ulid string) ULID {\n\tid, err := Parse(ulid)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\treturn id\n}\n\n// MustParseStrict is a convenience function equivalent to ParseStrict that\n// panics on failure instead of returning an error.\nfunc MustParseStrict(ulid string) ULID {\n\tid, err := ParseStrict(ulid)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\treturn id\n}\n\n// Bytes returns bytes slice representation of ULID.\nfunc (id ULID) Bytes() []byte {\n\treturn id[:]\n}\n\n// String returns a lexicographically sortable string encoded ULID\n// (26 characters, non-standard base 32) e.g. 01AN4Z07BY79KA1307SR9X4MV3.\n// Format: tttttttttteeeeeeeeeeeeeeee where t is time and e is entropy.\nfunc (id ULID) String() string {\n\tulid := make([]byte, EncodedSize)\n\t_ = id.MarshalTextTo(ulid)\n\treturn string(ulid)\n}\n\n// MarshalBinary implements the encoding.BinaryMarshaler interface by\n// returning the ULID as a byte slice.\nfunc (id ULID) MarshalBinary() ([]byte, error) {\n\tulid := make([]byte, len(id))\n\treturn ulid, id.MarshalBinaryTo(ulid)\n}\n\n// MarshalBinaryTo writes the binary encoding of the ULID to the given buffer.\n// ErrBufferSize is returned when the len(dst) != 16.\nfunc (id ULID) MarshalBinaryTo(dst []byte) error {\n\tif len(dst) != len(id) {\n\t\treturn ErrBufferSize\n\t}\n\n\tcopy(dst, id[:])\n\treturn nil\n}\n\n// UnmarshalBinary implements the encoding.BinaryUnmarshaler interface by\n// copying the passed data and converting it to a ULID. ErrDataSize is\n// returned if the data length is different from ULID length.\nfunc (id *ULID) UnmarshalBinary(data []byte) error {\n\tif len(data) != len(*id) {\n\t\treturn ErrDataSize\n\t}\n\n\tcopy((*id)[:], data)\n\treturn nil\n}\n\n// Encoding is the base 32 encoding alphabet used in ULID strings.\nconst Encoding = \"0123456789ABCDEFGHJKMNPQRSTVWXYZ\"\n\n// MarshalText implements the encoding.TextMarshaler interface by\n// returning the string encoded ULID.\nfunc (id ULID) MarshalText() ([]byte, error) {\n\tulid := make([]byte, EncodedSize)\n\treturn ulid, id.MarshalTextTo(ulid)\n}\n\n// MarshalTextTo writes the ULID as a string to the given buffer.\n// ErrBufferSize is returned when the len(dst) != 26.\nfunc (id ULID) MarshalTextTo(dst []byte) error {\n\t// Optimized unrolled loop ahead.\n\t// From https://github.com/RobThree/NUlid\n\n\tif len(dst) != EncodedSize {\n\t\treturn ErrBufferSize\n\t}\n\n\t// 10 byte timestamp\n\tdst[0] = Encoding[(id[0]&224)>>5]\n\tdst[1] = Encoding[id[0]&31]\n\tdst[2] = Encoding[(id[1]&248)>>3]\n\tdst[3] = Encoding[((id[1]&7)<<2)|((id[2]&192)>>6)]\n\tdst[4] = Encoding[(id[2]&62)>>1]\n\tdst[5] = Encoding[((id[2]&1)<<4)|((id[3]&240)>>4)]\n\tdst[6] = Encoding[((id[3]&15)<<1)|((id[4]&128)>>7)]\n\tdst[7] = Encoding[(id[4]&124)>>2]\n\tdst[8] = Encoding[((id[4]&3)<<3)|((id[5]&224)>>5)]\n\tdst[9] = Encoding[id[5]&31]\n\n\t// 16 bytes of entropy\n\tdst[10] = Encoding[(id[6]&248)>>3]\n\tdst[11] = Encoding[((id[6]&7)<<2)|((id[7]&192)>>6)]\n\tdst[12] = Encoding[(id[7]&62)>>1]\n\tdst[13] = Encoding[((id[7]&1)<<4)|((id[8]&240)>>4)]\n\tdst[14] = Encoding[((id[8]&15)<<1)|((id[9]&128)>>7)]\n\tdst[15] = Encoding[(id[9]&124)>>2]\n\tdst[16] = Encoding[((id[9]&3)<<3)|((id[10]&224)>>5)]\n\tdst[17] = Encoding[id[10]&31]\n\tdst[18] = Encoding[(id[11]&248)>>3]\n\tdst[19] = Encoding[((id[11]&7)<<2)|((id[12]&192)>>6)]\n\tdst[20] = Encoding[(id[12]&62)>>1]\n\tdst[21] = Encoding[((id[12]&1)<<4)|((id[13]&240)>>4)]\n\tdst[22] = Encoding[((id[13]&15)<<1)|((id[14]&128)>>7)]\n\tdst[23] = Encoding[(id[14]&124)>>2]\n\tdst[24] = Encoding[((id[14]&3)<<3)|((id[15]&224)>>5)]\n\tdst[25] = Encoding[id[15]&31]\n\n\treturn nil\n}\n\n// Byte to index table for O(1) lookups when unmarshaling.\n// We use 0xFF as sentinel value for invalid indexes.\nvar dec = [...]byte{\n\t0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,\n\t0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,\n\t0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,\n\t0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,\n\t0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x01,\n\t0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0xFF, 0xFF,\n\t0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E,\n\t0x0F, 0x10, 0x11, 0xFF, 0x12, 0x13, 0xFF, 0x14, 0x15, 0xFF,\n\t0x16, 0x17, 0x18, 0x19, 0x1A, 0xFF, 0x1B, 0x1C, 0x1D, 0x1E,\n\t0x1F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x0A, 0x0B, 0x0C,\n\t0x0D, 0x0E, 0x0F, 0x10, 0x11, 0xFF, 0x12, 0x13, 0xFF, 0x14,\n\t0x15, 0xFF, 0x16, 0x17, 0x18, 0x19, 0x1A, 0xFF, 0x1B, 0x1C,\n\t0x1D, 0x1E, 0x1F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,\n\t0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,\n\t0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,\n\t0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,\n\t0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,\n\t0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,\n\t0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,\n\t0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,\n\t0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,\n\t0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,\n\t0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,\n\t0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,\n\t0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,\n\t0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,\n}\n\n// EncodedSize is the length of a text encoded ULID.\nconst EncodedSize = 26\n\n// UnmarshalText implements the encoding.TextUnmarshaler interface by\n// parsing the data as string encoded ULID.\n//\n// ErrDataSize is returned if the len(v) is different from an encoded\n// ULID's length. Invalid encodings produce undefined ULIDs.\nfunc (id *ULID) UnmarshalText(v []byte) error {\n\treturn parse(v, false, id)\n}\n\n// Time returns the Unix time in milliseconds encoded in the ULID.\n// Use the top level Time function to convert the returned value to\n// a time.Time.\nfunc (id ULID) Time() uint64 {\n\treturn uint64(id[5]) | uint64(id[4])<<8 |\n\t\tuint64(id[3])<<16 | uint64(id[2])<<24 |\n\t\tuint64(id[1])<<32 | uint64(id[0])<<40\n}\n\n// Timestamp returns the time encoded in the ULID as a time.Time.\nfunc (id ULID) Timestamp() time.Time {\n\treturn Time(id.Time())\n}\n\n// IsZero returns true if the ULID is a zero-value ULID, i.e. ulid.Zero.\nfunc (id ULID) IsZero() bool {\n\treturn id.Compare(Zero) == 0\n}\n\n// maxTime is the maximum Unix time in milliseconds that can be\n// represented in a ULID.\nvar maxTime = ULID{0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF}.Time()\n\n// MaxTime returns the maximum Unix time in milliseconds that\n// can be encoded in a ULID.\nfunc MaxTime() uint64 { return maxTime }\n\n// Now is a convenience function that returns the current\n// UTC time in Unix milliseconds. Equivalent to:\n//\n//\tTimestamp(time.Now().UTC())\nfunc Now() uint64 { return Timestamp(time.Now().UTC()) }\n\n// Timestamp converts a time.Time to Unix milliseconds.\n//\n// Because of the way ULID stores time, times from the year\n// 10889 produces undefined results.\nfunc Timestamp(t time.Time) uint64 {\n\treturn uint64(t.Unix())*1000 +\n\t\tuint64(t.Nanosecond()/int(time.Millisecond))\n}\n\n// Time converts Unix milliseconds in the format\n// returned by the Timestamp function to a time.Time.\nfunc Time(ms uint64) time.Time {\n\ts := int64(ms / 1e3)\n\tns := int64((ms % 1e3) * 1e6)\n\treturn time.Unix(s, ns)\n}\n\n// SetTime sets the time component of the ULID to the given Unix time\n// in milliseconds.\nfunc (id *ULID) SetTime(ms uint64) error {\n\tif ms > maxTime {\n\t\treturn ErrBigTime\n\t}\n\n\t(*id)[0] = byte(ms >> 40)\n\t(*id)[1] = byte(ms >> 32)\n\t(*id)[2] = byte(ms >> 24)\n\t(*id)[3] = byte(ms >> 16)\n\t(*id)[4] = byte(ms >> 8)\n\t(*id)[5] = byte(ms)\n\n\treturn nil\n}\n\n// Entropy returns the entropy from the ULID.\nfunc (id ULID) Entropy() []byte {\n\te := make([]byte, 10)\n\tcopy(e, id[6:])\n\treturn e\n}\n\n// SetEntropy sets the ULID entropy to the passed byte slice.\n// ErrDataSize is returned if len(e) != 10.\nfunc (id *ULID) SetEntropy(e []byte) error {\n\tif len(e) != 10 {\n\t\treturn ErrDataSize\n\t}\n\n\tcopy((*id)[6:], e)\n\treturn nil\n}\n\n// Compare returns an integer comparing id and other lexicographically.\n// The result will be 0 if id==other, -1 if id < other, and +1 if id > other.\nfunc (id ULID) Compare(other ULID) int {\n\treturn bytes.Compare(id[:], other[:])\n}\n\n// Scan implements the sql.Scanner interface. It supports scanning\n// a string or byte slice.\nfunc (id *ULID) Scan(src interface{}) error {\n\tswitch x := src.(type) {\n\tcase nil:\n\t\treturn nil\n\tcase string:\n\t\treturn id.UnmarshalText([]byte(x))\n\tcase []byte:\n\t\treturn id.UnmarshalBinary(x)\n\t}\n\n\treturn ErrScanValue\n}\n\n// Value implements the sql/driver.Valuer interface, returning the ULID as a\n// slice of bytes, by invoking MarshalBinary. If your use case requires a string\n// representation instead, you can create a wrapper type that calls String()\n// instead.\n//\n//\ttype stringValuer ulid.ULID\n//\n//\tfunc (v stringValuer) Value() (driver.Value, error) {\n//\t    return ulid.ULID(v).String(), nil\n//\t}\n//\n//\t// Example usage.\n//\tdb.Exec(\"...\", stringValuer(id))\n//\n// All valid ULIDs, including zero-value ULIDs, return a valid Value with a nil\n// error. If your use case requires zero-value ULIDs to return a non-nil error,\n// you can create a wrapper type that special-cases this behavior.\n//\n//\tvar zeroValueULID ulid.ULID\n//\n//\ttype invalidZeroValuer ulid.ULID\n//\n//\tfunc (v invalidZeroValuer) Value() (driver.Value, error) {\n//\t    if ulid.ULID(v).Compare(zeroValueULID) == 0 {\n//\t        return nil, fmt.Errorf(\"zero value\")\n//\t    }\n//\t    return ulid.ULID(v).Value()\n//\t}\n//\n//\t// Example usage.\n//\tdb.Exec(\"...\", invalidZeroValuer(id))\nfunc (id ULID) Value() (driver.Value, error) {\n\treturn id.MarshalBinary()\n}\n\n// Monotonic returns a source of entropy that yields strictly increasing entropy\n// bytes, to a limit governeed by the `inc` parameter.\n//\n// Specifically, calls to MonotonicRead within the same ULID timestamp return\n// entropy incremented by a random number between 1 and `inc` inclusive. If an\n// increment results in entropy that would overflow available space,\n// MonotonicRead returns ErrMonotonicOverflow.\n//\n// Passing `inc == 0` results in the reasonable default `math.MaxUint32`. Lower\n// values of `inc` provide more monotonic entropy in a single millisecond, at\n// the cost of easier \"guessability\" of generated ULIDs. If your code depends on\n// ULIDs having secure entropy bytes, then it's recommended to use the secure\n// default value of `inc == 0`, unless you know what you're doing.\n//\n// The provided entropy source must actually yield random bytes. Otherwise,\n// monotonic reads are not guaranteed to terminate, since there isn't enough\n// randomness to compute an increment number.\n//\n// The returned type isn't safe for concurrent use.\nfunc Monotonic(entropy io.Reader, inc uint64) *MonotonicEntropy {\n\tm := MonotonicEntropy{\n\t\tReader: bufio.NewReader(entropy),\n\t\tinc:    inc,\n\t}\n\n\tif m.inc == 0 {\n\t\tm.inc = math.MaxUint32\n\t}\n\n\tif rng, ok := entropy.(rng); ok {\n\t\tm.rng = rng\n\t}\n\n\treturn &m\n}\n\ntype rng interface{ Int63n(n int64) int64 }\n\n// LockedMonotonicReader wraps a MonotonicReader with a sync.Mutex for safe\n// concurrent use.\ntype LockedMonotonicReader struct {\n\tmu sync.Mutex\n\tMonotonicReader\n}\n\n// MonotonicRead synchronizes calls to the wrapped MonotonicReader.\nfunc (r *LockedMonotonicReader) MonotonicRead(ms uint64, p []byte) (err error) {\n\tr.mu.Lock()\n\terr = r.MonotonicReader.MonotonicRead(ms, p)\n\tr.mu.Unlock()\n\treturn err\n}\n\n// MonotonicEntropy is an opaque type that provides monotonic entropy.\ntype MonotonicEntropy struct {\n\tio.Reader\n\tms      uint64\n\tinc     uint64\n\tentropy uint80\n\trand    [8]byte\n\trng     rng\n}\n\n// MonotonicRead implements the MonotonicReader interface.\nfunc (m *MonotonicEntropy) MonotonicRead(ms uint64, entropy []byte) (err error) {\n\tif !m.entropy.IsZero() && m.ms == ms {\n\t\terr = m.increment()\n\t\tm.entropy.AppendTo(entropy)\n\t} else if _, err = io.ReadFull(m.Reader, entropy); err == nil {\n\t\tm.ms = ms\n\t\tm.entropy.SetBytes(entropy)\n\t}\n\treturn err\n}\n\n// increment the previous entropy number with a random number\n// of up to m.inc (inclusive).\nfunc (m *MonotonicEntropy) increment() error {\n\tif inc, err := m.random(); err != nil {\n\t\treturn err\n\t} else if m.entropy.Add(inc) {\n\t\treturn ErrMonotonicOverflow\n\t}\n\treturn nil\n}\n\n// random returns a uniform random value in [1, m.inc), reading entropy\n// from m.Reader. When m.inc == 0 || m.inc == 1, it returns 1.\n// Adapted from: https://golang.org/pkg/crypto/rand/#Int\nfunc (m *MonotonicEntropy) random() (inc uint64, err error) {\n\tif m.inc <= 1 {\n\t\treturn 1, nil\n\t}\n\n\t// Fast path for using a underlying rand.Rand directly.\n\tif m.rng != nil {\n\t\t// Range: [1, m.inc)\n\t\treturn 1 + uint64(m.rng.Int63n(int64(m.inc))), nil\n\t}\n\n\t// bitLen is the maximum bit length needed to encode a value < m.inc.\n\tbitLen := bits.Len64(m.inc)\n\n\t// byteLen is the maximum byte length needed to encode a value < m.inc.\n\tbyteLen := uint(bitLen+7) / 8\n\n\t// msbitLen is the number of bits in the most significant byte of m.inc-1.\n\tmsbitLen := uint(bitLen % 8)\n\tif msbitLen == 0 {\n\t\tmsbitLen = 8\n\t}\n\n\tfor inc == 0 || inc >= m.inc {\n\t\tif _, err = io.ReadFull(m.Reader, m.rand[:byteLen]); err != nil {\n\t\t\treturn 0, err\n\t\t}\n\n\t\t// Clear bits in the first byte to increase the probability\n\t\t// that the candidate is < m.inc.\n\t\tm.rand[0] &= uint8(int(1<<msbitLen) - 1)\n\n\t\t// Convert the read bytes into an uint64 with byteLen\n\t\t// Optimized unrolled loop.\n\t\tswitch byteLen {\n\t\tcase 1:\n\t\t\tinc = uint64(m.rand[0])\n\t\tcase 2:\n\t\t\tinc = uint64(binary.LittleEndian.Uint16(m.rand[:2]))\n\t\tcase 3, 4:\n\t\t\tinc = uint64(binary.LittleEndian.Uint32(m.rand[:4]))\n\t\tcase 5, 6, 7, 8:\n\t\t\tinc = uint64(binary.LittleEndian.Uint64(m.rand[:8]))\n\t\t}\n\t}\n\n\t// Range: [1, m.inc)\n\treturn 1 + inc, nil\n}\n\ntype uint80 struct {\n\tHi uint16\n\tLo uint64\n}\n\nfunc (u *uint80) SetBytes(bs []byte) {\n\tu.Hi = binary.BigEndian.Uint16(bs[:2])\n\tu.Lo = binary.BigEndian.Uint64(bs[2:])\n}\n\nfunc (u *uint80) AppendTo(bs []byte) {\n\tbinary.BigEndian.PutUint16(bs[:2], u.Hi)\n\tbinary.BigEndian.PutUint64(bs[2:], u.Lo)\n}\n\nfunc (u *uint80) Add(n uint64) (overflow bool) {\n\tlo, hi := u.Lo, u.Hi\n\tif u.Lo += n; u.Lo < lo {\n\t\tu.Hi++\n\t}\n\treturn u.Hi < hi\n}\n\nfunc (u uint80) IsZero() bool {\n\treturn u.Hi == 0 && u.Lo == 0\n}\n"
        },
        {
          "name": "ulid_test.go",
          "type": "blob",
          "size": 19.5673828125,
          "content": "// Copyright 2016 The Oklog Authors\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage ulid_test\n\nimport (\n\t\"bytes\"\n\tcrand \"crypto/rand\"\n\t\"fmt\"\n\t\"io\"\n\t\"math\"\n\t\"math/rand\"\n\t\"strings\"\n\t\"testing\"\n\t\"testing/iotest\"\n\t\"testing/quick\"\n\t\"time\"\n\n\t\"github.com/oklog/ulid/v2\"\n)\n\nfunc ExampleULID() {\n\tt := time.Unix(1000000, 0)\n\tentropy := ulid.Monotonic(rand.New(rand.NewSource(t.UnixNano())), 0)\n\tfmt.Println(ulid.MustNew(ulid.Timestamp(t), entropy))\n\t// Output: 0000XSNJG0MQJHBF4QX1EFD6Y3\n}\n\nfunc TestNew(t *testing.T) {\n\tt.Parallel()\n\n\tt.Run(\"ULID\", testULID(func(ms uint64, e io.Reader) ulid.ULID {\n\t\tid, err := ulid.New(ms, e)\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\treturn id\n\t}))\n\n\tt.Run(\"Error\", func(t *testing.T) {\n\t\t_, err := ulid.New(ulid.MaxTime()+1, nil)\n\t\tif got, want := err, ulid.ErrBigTime; got != want {\n\t\t\tt.Errorf(\"got err %v, want %v\", got, want)\n\t\t}\n\n\t\t_, err = ulid.New(0, strings.NewReader(\"\"))\n\t\tif got, want := err, io.EOF; got != want {\n\t\t\tt.Errorf(\"got err %v, want %v\", got, want)\n\t\t}\n\t})\n}\n\nfunc TestMake(t *testing.T) {\n\tt.Parallel()\n\tid := ulid.Make()\n\trt, err := ulid.Parse(id.String())\n\tif err != nil {\n\t\tt.Fatalf(\"parse %q: %v\", id.String(), err)\n\t}\n\tif id != rt {\n\t\tt.Fatalf(\"%q != %q\", id.String(), rt.String())\n\t}\n}\n\nfunc TestMustNew(t *testing.T) {\n\tt.Parallel()\n\n\tt.Run(\"ULID\", testULID(ulid.MustNew))\n\n\tt.Run(\"Panic\", func(t *testing.T) {\n\t\tdefer func() {\n\t\t\tif got, want := recover(), io.EOF; got != want {\n\t\t\t\tt.Errorf(\"panic with err %v, want %v\", got, want)\n\t\t\t}\n\t\t}()\n\t\t_ = ulid.MustNew(0, strings.NewReader(\"\"))\n\t})\n}\n\nfunc TestMustNewDefault(t *testing.T) {\n\tt.Parallel()\n\n\tt.Run(\"ULID\", func(t *testing.T) {\n\t\tid := ulid.MustNewDefault(time.Now())\n\t\trt, err := ulid.Parse(id.String())\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"parse %q: %v\", id.String(), err)\n\t\t}\n\t\tif id != rt {\n\t\t\tt.Fatalf(\"%q != %q\", id.String(), rt.String())\n\t\t}\n\t})\n\n\tt.Run(\"Panic\", func(t *testing.T) {\n\t\tdefer func() {\n\t\t\tif got, want := recover(), ulid.ErrBigTime; got != want {\n\t\t\t\tt.Errorf(\"got panic %v, want %v\", got, want)\n\t\t\t}\n\t\t}()\n\t\t_ = ulid.MustNewDefault(time.Time{})\n\t})\n}\n\nfunc TestMustParse(t *testing.T) {\n\tt.Parallel()\n\n\tfor _, tc := range []struct {\n\t\tname string\n\t\tfn   func(string) ulid.ULID\n\t}{\n\t\t{\"MustParse\", ulid.MustParse},\n\t\t{\"MustParseStrict\", ulid.MustParseStrict},\n\t} {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tif got, want := recover(), ulid.ErrDataSize; got != want {\n\t\t\t\t\tt.Errorf(\"got panic %v, want %v\", got, want)\n\t\t\t\t}\n\t\t\t}()\n\t\t\t_ = tc.fn(\"\")\n\t\t})\n\n\t}\n}\n\nfunc testULID(mk func(uint64, io.Reader) ulid.ULID) func(*testing.T) {\n\treturn func(t *testing.T) {\n\t\twant := ulid.ULID{0x0, 0x0, 0x0, 0x1, 0x86, 0xa0}\n\t\tif got := mk(1e5, nil); got != want { // optional entropy\n\t\t\tt.Errorf(\"\\ngot  %#v\\nwant %#v\", got, want)\n\t\t}\n\n\t\tentropy := bytes.Repeat([]byte{0xFF}, 16)\n\t\tcopy(want[6:], entropy)\n\t\tif got := mk(1e5, bytes.NewReader(entropy)); got != want {\n\t\t\tt.Errorf(\"\\ngot  %#v\\nwant %#v\", got, want)\n\t\t}\n\t}\n}\n\nfunc TestRoundTrips(t *testing.T) {\n\tt.Parallel()\n\n\tprop := func(id ulid.ULID) bool {\n\t\tbin, err := id.MarshalBinary()\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\n\t\ttxt, err := id.MarshalText()\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\n\t\tvar a ulid.ULID\n\t\tif err = a.UnmarshalBinary(bin); err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\n\t\tvar b ulid.ULID\n\t\tif err = b.UnmarshalText(txt); err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\n\t\treturn id == a && b == id &&\n\t\t\tid == ulid.MustParse(id.String()) &&\n\t\t\tid == ulid.MustParseStrict(id.String())\n\t}\n\n\terr := quick.Check(prop, &quick.Config{MaxCount: 1e5})\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n}\n\nfunc TestMarshalingErrors(t *testing.T) {\n\tt.Parallel()\n\n\tvar id ulid.ULID\n\tfor _, tc := range []struct {\n\t\tname string\n\t\tfn   func([]byte) error\n\t\terr  error\n\t}{\n\t\t{\"UnmarshalBinary\", id.UnmarshalBinary, ulid.ErrDataSize},\n\t\t{\"UnmarshalText\", id.UnmarshalText, ulid.ErrDataSize},\n\t\t{\"MarshalBinaryTo\", id.MarshalBinaryTo, ulid.ErrBufferSize},\n\t\t{\"MarshalTextTo\", id.MarshalTextTo, ulid.ErrBufferSize},\n\t} {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tif got, want := tc.fn([]byte{}), tc.err; got != want {\n\t\t\t\tt.Errorf(\"got err %v, want %v\", got, want)\n\t\t\t}\n\t\t})\n\n\t}\n}\n\nfunc TestParseStrictInvalidCharacters(t *testing.T) {\n\tt.Parallel()\n\n\ttype testCase struct {\n\t\tname  string\n\t\tinput string\n\t}\n\ttestCases := []testCase{}\n\tbase := \"0000XSNJG0MQJHBF4QX1EFD6Y3\"\n\tfor i := 0; i < ulid.EncodedSize; i++ {\n\t\ttestCases = append(testCases, testCase{\n\t\t\tname:  fmt.Sprintf(\"Invalid 0xFF at index %d\", i),\n\t\t\tinput: base[:i] + \"\\xff\" + base[i+1:],\n\t\t})\n\t\ttestCases = append(testCases, testCase{\n\t\t\tname:  fmt.Sprintf(\"Invalid 0x00 at index %d\", i),\n\t\t\tinput: base[:i] + \"\\x00\" + base[i+1:],\n\t\t})\n\t}\n\n\tfor _, tt := range testCases {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\t_, err := ulid.ParseStrict(tt.input)\n\t\t\tif err != ulid.ErrInvalidCharacters {\n\t\t\t\tt.Errorf(\"Parse(%q): got err %v, want %v\", tt.input, err, ulid.ErrInvalidCharacters)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestAlizainCompatibility(t *testing.T) {\n\tt.Parallel()\n\n\tts := uint64(1469918176385)\n\tgot := ulid.MustNew(ts, bytes.NewReader(make([]byte, 16)))\n\twant := ulid.MustParse(\"01ARYZ6S410000000000000000\")\n\tif got != want {\n\t\tt.Fatalf(\"with time=%d, got %q, want %q\", ts, got, want)\n\t}\n}\n\nfunc TestEncoding(t *testing.T) {\n\tt.Parallel()\n\n\tenc := make(map[rune]bool, len(ulid.Encoding))\n\tfor _, r := range ulid.Encoding {\n\t\tenc[r] = true\n\t}\n\n\tprop := func(id ulid.ULID) bool {\n\t\tfor _, r := range id.String() {\n\t\t\tif !enc[r] {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\t}\n\n\tif err := quick.Check(prop, &quick.Config{MaxCount: 1e5}); err != nil {\n\t\tt.Fatal(err)\n\t}\n}\n\nfunc TestLexicographicalOrder(t *testing.T) {\n\tt.Parallel()\n\n\tprop := func(a, b ulid.ULID) bool {\n\t\tt1, t2 := a.Time(), b.Time()\n\t\ts1, s2 := a.String(), b.String()\n\t\tord := bytes.Compare(a[:], b[:])\n\t\treturn t1 == t2 ||\n\t\t\t(t1 > t2 && s1 > s2 && ord == +1) ||\n\t\t\t(t1 < t2 && s1 < s2 && ord == -1)\n\t}\n\n\ttop := ulid.MustNew(ulid.MaxTime(), nil)\n\tfor i := 0; i < 10; i++ { // test upper boundary state space\n\t\tnext := ulid.MustNew(top.Time()-1, nil)\n\t\tif !prop(top, next) {\n\t\t\tt.Fatalf(\"bad lexicographical order: (%v, %q) > (%v, %q) == false\",\n\t\t\t\ttop.Time(), top,\n\t\t\t\tnext.Time(), next,\n\t\t\t)\n\t\t}\n\t\ttop = next\n\t}\n\n\tif err := quick.Check(prop, &quick.Config{MaxCount: 1e6}); err != nil {\n\t\tt.Fatal(err)\n\t}\n}\n\nfunc TestCaseInsensitivity(t *testing.T) {\n\tt.Parallel()\n\n\tupper := func(id ulid.ULID) (out ulid.ULID) {\n\t\treturn ulid.MustParse(strings.ToUpper(id.String()))\n\t}\n\n\tlower := func(id ulid.ULID) (out ulid.ULID) {\n\t\treturn ulid.MustParse(strings.ToLower(id.String()))\n\t}\n\n\terr := quick.CheckEqual(upper, lower, nil)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n}\n\nfunc TestParseRobustness(t *testing.T) {\n\tt.Parallel()\n\n\tcases := [][]byte{\n\t\t{0x1, 0xc0, 0x73, 0x62, 0x4a, 0xaf, 0x39, 0x78, 0x51, 0x4e, 0xf8, 0x44, 0x3b,\n\t\t\t0xb2, 0xa8, 0x59, 0xc7, 0x5f, 0xc3, 0xcc, 0x6a, 0xf2, 0x6d, 0x5a, 0xaa, 0x20},\n\t}\n\n\tfor _, tc := range cases {\n\t\tif _, err := ulid.Parse(string(tc)); err != nil {\n\t\t\tt.Error(err)\n\t\t}\n\t}\n\n\tprop := func(s [26]byte) (ok bool) {\n\t\tdefer func() {\n\t\t\tif err := recover(); err != nil {\n\t\t\t\tt.Error(err)\n\t\t\t\tok = false\n\t\t\t}\n\t\t}()\n\n\t\t// quick.Check doesn't constrain input,\n\t\t// so we need to do so artificially.\n\t\tif s[0] > '7' {\n\t\t\ts[0] %= '7'\n\t\t}\n\n\t\tvar err error\n\t\tif _, err = ulid.Parse(string(s[:])); err != nil {\n\t\t\tt.Error(err)\n\t\t}\n\n\t\treturn err == nil\n\t}\n\n\terr := quick.Check(prop, &quick.Config{MaxCount: 1e4})\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n}\n\nfunc TestNow(t *testing.T) {\n\tt.Parallel()\n\n\tbefore := ulid.Now()\n\tafter := ulid.Timestamp(time.Now().UTC().Add(time.Millisecond))\n\n\tif before >= after {\n\t\tt.Fatalf(\"clock went mad: before %v, after %v\", before, after)\n\t}\n}\n\nfunc TestTimestamp(t *testing.T) {\n\tt.Parallel()\n\n\ttm := time.Unix(1, 1000) // will be truncated\n\tif got, want := ulid.Timestamp(tm), uint64(1000); got != want {\n\t\tt.Errorf(\"for %v, got %v, want %v\", tm, got, want)\n\t}\n\n\tmt := ulid.MaxTime()\n\tdt := time.Unix(int64(mt/1000), int64((mt%1000)*1000000)).Truncate(time.Millisecond)\n\tts := ulid.Timestamp(dt)\n\tif got, want := ts, mt; got != want {\n\t\tt.Errorf(\"got timestamp %d, want %d\", got, want)\n\t}\n}\n\nfunc TestTime(t *testing.T) {\n\tt.Parallel()\n\n\toriginal := time.Now()\n\tdiff := original.Sub(ulid.Time(ulid.Timestamp(original)))\n\tif diff >= time.Millisecond {\n\t\tt.Errorf(\"difference between original and recovered time (%d) greater\"+\n\t\t\t\"than a millisecond\", diff)\n\t}\n}\n\nfunc TestTimestampRoundTrips(t *testing.T) {\n\tt.Parallel()\n\n\tprop := func(ts uint64) bool {\n\t\treturn ts == ulid.Timestamp(ulid.Time(ts))\n\t}\n\n\terr := quick.Check(prop, &quick.Config{MaxCount: 1e5})\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n}\n\nfunc TestULIDTime(t *testing.T) {\n\tt.Parallel()\n\n\tmaxTime := ulid.MaxTime()\n\n\tvar id ulid.ULID\n\tif got, want := id.SetTime(maxTime+1), ulid.ErrBigTime; got != want {\n\t\tt.Errorf(\"got err %v, want %v\", got, want)\n\t}\n\n\trng := rand.New(rand.NewSource(time.Now().UnixNano()))\n\tfor i := 0; i < 1e6; i++ {\n\t\tms := uint64(rng.Int63n(int64(maxTime)))\n\n\t\tvar id ulid.ULID\n\t\tif err := id.SetTime(ms); err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\n\t\tif got, want := id.Time(), ms; got != want {\n\t\t\tt.Fatalf(\"\\nfor %v:\\ngot  %v\\nwant %v\", id, got, want)\n\t\t}\n\t}\n}\n\nfunc TestULIDTimestamp(t *testing.T) {\n\tt.Parallel()\n\n\t{\n\t\tid := ulid.Make()\n\t\tts := id.Timestamp()\n\t\ttt := ulid.Time(id.Time())\n\t\tif ts != tt {\n\t\t\tt.Errorf(\"id.Timestamp() %s != ulid.Time(id.Time()) %s\", ts, tt)\n\t\t}\n\t}\n\n\t{\n\t\tnow := time.Now()\n\t\tid := ulid.MustNew(ulid.Timestamp(now), ulid.DefaultEntropy())\n\t\tif want, have := now.Truncate(time.Millisecond), id.Timestamp(); want != have {\n\t\t\tt.Errorf(\"Timestamp: want %v, have %v\", want, have)\n\t\t}\n\t}\n}\n\nfunc TestZero(t *testing.T) {\n\tt.Parallel()\n\n\tvar id ulid.ULID\n\tif ok := id.IsZero(); !ok {\n\t\tt.Error(\".IsZero: must return true for zero-value ULIDs, have false\")\n\t}\n\n\tid = ulid.MustNew(ulid.Now(), ulid.DefaultEntropy())\n\tif ok := id.IsZero(); ok {\n\t\tt.Error(\".IsZero: must return false for non-zero-value ULIDs, have true\")\n\t}\n}\n\nfunc TestEntropy(t *testing.T) {\n\tt.Parallel()\n\n\tvar id ulid.ULID\n\tif got, want := id.SetEntropy([]byte{}), ulid.ErrDataSize; got != want {\n\t\tt.Errorf(\"got err %v, want %v\", got, want)\n\t}\n\n\tprop := func(e [10]byte) bool {\n\t\tvar id ulid.ULID\n\t\tif err := id.SetEntropy(e[:]); err != nil {\n\t\t\tt.Fatalf(\"got err %v\", err)\n\t\t}\n\n\t\tgot, want := id.Entropy(), e[:]\n\t\teq := bytes.Equal(got, want)\n\t\tif !eq {\n\t\t\tt.Errorf(\"\\n(!= %v\\n    %v)\", got, want)\n\t\t}\n\n\t\treturn eq\n\t}\n\n\tif err := quick.Check(prop, nil); err != nil {\n\t\tt.Fatal(err)\n\t}\n}\n\nfunc TestEntropyRead(t *testing.T) {\n\tt.Parallel()\n\n\tprop := func(e [10]byte) bool {\n\t\tflakyReader := iotest.HalfReader(bytes.NewReader(e[:]))\n\n\t\tid, err := ulid.New(ulid.Now(), flakyReader)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"got err %v\", err)\n\t\t}\n\n\t\tgot, want := id.Entropy(), e[:]\n\t\teq := bytes.Equal(got, want)\n\t\tif !eq {\n\t\t\tt.Errorf(\"\\n(!= %v\\n    %v)\", got, want)\n\t\t}\n\n\t\treturn eq\n\t}\n\n\tif err := quick.Check(prop, &quick.Config{MaxCount: 1e4}); err != nil {\n\t\tt.Fatal(err)\n\t}\n}\n\nfunc TestCompare(t *testing.T) {\n\tt.Parallel()\n\n\ta := func(a, b ulid.ULID) int {\n\t\treturn strings.Compare(a.String(), b.String())\n\t}\n\n\tb := func(a, b ulid.ULID) int {\n\t\treturn a.Compare(b)\n\t}\n\n\terr := quick.CheckEqual(a, b, &quick.Config{MaxCount: 1e5})\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n}\n\nfunc TestOverflowHandling(t *testing.T) {\n\tt.Parallel()\n\n\tfor s, want := range map[string]error{\n\t\t\"00000000000000000000000000\": nil,\n\t\t\"70000000000000000000000000\": nil,\n\t\t\"7ZZZZZZZZZZZZZZZZZZZZZZZZZ\": nil,\n\t\t\"80000000000000000000000000\": ulid.ErrOverflow,\n\t\t\"80000000000000000000000001\": ulid.ErrOverflow,\n\t\t\"ZZZZZZZZZZZZZZZZZZZZZZZZZZ\": ulid.ErrOverflow,\n\t} {\n\t\tif _, have := ulid.Parse(s); want != have {\n\t\t\tt.Errorf(\"%s: want error %v, have %v\", s, want, have)\n\t\t}\n\t}\n}\n\nfunc TestScan(t *testing.T) {\n\tid := ulid.MustNew(123, crand.Reader)\n\n\tfor _, tc := range []struct {\n\t\tname string\n\t\tin   interface{}\n\t\tout  ulid.ULID\n\t\terr  error\n\t}{\n\t\t{\"string\", id.String(), id, nil},\n\t\t{\"bytes\", id[:], id, nil},\n\t\t{\"nil\", nil, ulid.ULID{}, nil},\n\t\t{\"other\", 44, ulid.ULID{}, ulid.ErrScanValue},\n\t} {\n\t\ttc := tc\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tt.Parallel()\n\n\t\t\tvar out ulid.ULID\n\t\t\terr := out.Scan(tc.in)\n\t\t\tif got, want := out, tc.out; got.Compare(want) != 0 {\n\t\t\t\tt.Errorf(\"got ULID %s, want %s\", got, want)\n\t\t\t}\n\n\t\t\tif got, want := fmt.Sprint(err), fmt.Sprint(tc.err); got != want {\n\t\t\t\tt.Errorf(\"got err %q, want %q\", got, want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestMonotonic(t *testing.T) {\n\tnow := ulid.Now()\n\tfor _, e := range []struct {\n\t\tname string\n\t\tmk   func() io.Reader\n\t}{\n\t\t{\"cryptorand\", func() io.Reader { return crand.Reader }},\n\t\t{\"mathrand\", func() io.Reader { return rand.New(rand.NewSource(int64(now))) }},\n\t} {\n\t\tfor _, inc := range []uint64{\n\t\t\t0,\n\t\t\t1,\n\t\t\t2,\n\t\t\tmath.MaxUint8 + 1,\n\t\t\tmath.MaxUint16 + 1,\n\t\t\tmath.MaxUint32 + 1,\n\t\t} {\n\t\t\tinc := inc\n\t\t\tentropy := ulid.Monotonic(e.mk(), uint64(inc))\n\n\t\t\tt.Run(fmt.Sprintf(\"entropy=%s/inc=%d\", e.name, inc), func(t *testing.T) {\n\t\t\t\tt.Parallel()\n\n\t\t\t\tvar prev ulid.ULID\n\t\t\t\tfor i := 0; i < 10000; i++ {\n\t\t\t\t\tnext, err := ulid.New(123, entropy)\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\tt.Fatal(err)\n\t\t\t\t\t}\n\n\t\t\t\t\tif prev.Compare(next) >= 0 {\n\t\t\t\t\t\tt.Fatalf(\"prev: %v %v > next: %v %v\",\n\t\t\t\t\t\t\tprev.Time(), prev.Entropy(), next.Time(), next.Entropy())\n\t\t\t\t\t}\n\n\t\t\t\t\tprev = next\n\t\t\t\t}\n\t\t\t})\n\t\t}\n\t}\n}\n\nfunc TestMonotonicOverflow(t *testing.T) {\n\tt.Parallel()\n\n\tentropy := ulid.Monotonic(\n\t\tio.MultiReader(\n\t\t\tbytes.NewReader(bytes.Repeat([]byte{0xFF}, 10)), // Entropy for first ULID\n\t\t\tcrand.Reader, // Following random entropy\n\t\t),\n\t\t0,\n\t)\n\n\tprev, err := ulid.New(0, entropy)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tnext, err := ulid.New(prev.Time(), entropy)\n\tif have, want := err, ulid.ErrMonotonicOverflow; have != want {\n\t\tt.Errorf(\"have ulid: %v %v err: %v, want err: %v\",\n\t\t\tnext.Time(), next.Entropy(), have, want)\n\t}\n}\n\nfunc TestMonotonicSafe(t *testing.T) {\n\tt.Parallel()\n\n\tvar (\n\t\trng  = rand.New(rand.NewSource(time.Now().UnixNano()))\n\t\tsafe = &ulid.LockedMonotonicReader{MonotonicReader: ulid.Monotonic(rng, 0)}\n\t\tt0   = ulid.Timestamp(time.Now())\n\t)\n\n\terrs := make(chan error, 100)\n\tfor i := 0; i < cap(errs); i++ {\n\t\tgo func() {\n\t\t\tu0 := ulid.MustNew(t0, safe)\n\t\t\tu1 := u0\n\t\t\tfor j := 0; j < 1024; j++ {\n\t\t\t\tu0, u1 = u1, ulid.MustNew(t0, safe)\n\t\t\t\tif u0.String() >= u1.String() {\n\t\t\t\t\terrs <- fmt.Errorf(\n\t\t\t\t\t\t\"%s (%d %x) >= %s (%d %x)\",\n\t\t\t\t\t\tu0.String(), u0.Time(), u0.Entropy(),\n\t\t\t\t\t\tu1.String(), u1.Time(), u1.Entropy(),\n\t\t\t\t\t)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}\n\t\t\terrs <- nil\n\t\t}()\n\t}\n\n\tfor i := 0; i < cap(errs); i++ {\n\t\tif err := <-errs; err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t}\n}\n\nfunc TestULID_Bytes(t *testing.T) {\n\ttt := time.Unix(1000000, 0)\n\tentropy := ulid.Monotonic(rand.New(rand.NewSource(tt.UnixNano())), 0)\n\tid := ulid.MustNew(ulid.Timestamp(tt), entropy)\n\tbid := id.Bytes()\n\tbid[len(bid)-1]++\n\tif bytes.Equal(id.Bytes(), bid) {\n\t\tt.Error(\"Bytes() returned a reference to ulid underlying array!\")\n\t}\n}\n\nfunc BenchmarkNew(b *testing.B) {\n\tbenchmarkMakeULID(b, func(timestamp uint64, entropy io.Reader) {\n\t\t_, _ = ulid.New(timestamp, entropy)\n\t})\n}\n\nfunc BenchmarkMustNew(b *testing.B) {\n\tbenchmarkMakeULID(b, func(timestamp uint64, entropy io.Reader) {\n\t\t_ = ulid.MustNew(timestamp, entropy)\n\t})\n}\n\nfunc benchmarkMakeULID(b *testing.B, f func(uint64, io.Reader)) {\n\tb.ReportAllocs()\n\tb.SetBytes(int64(len(ulid.ULID{})))\n\n\trng := rand.New(rand.NewSource(time.Now().UnixNano()))\n\n\tfor _, tc := range []struct {\n\t\tname       string\n\t\ttimestamps []uint64\n\t\tentropy    io.Reader\n\t}{\n\t\t{\"WithCrypoEntropy\", []uint64{123}, crand.Reader},\n\t\t{\"WithEntropy\", []uint64{123}, rng},\n\t\t{\"WithMonotonicEntropy_SameTimestamp_Inc0\", []uint64{123}, ulid.Monotonic(rng, 0)},\n\t\t{\"WithMonotonicEntropy_DifferentTimestamp_Inc0\", []uint64{122, 123}, ulid.Monotonic(rng, 0)},\n\t\t{\"WithMonotonicEntropy_SameTimestamp_Inc1\", []uint64{123}, ulid.Monotonic(rng, 1)},\n\t\t{\"WithMonotonicEntropy_DifferentTimestamp_Inc1\", []uint64{122, 123}, ulid.Monotonic(rng, 1)},\n\t\t{\"WithCryptoMonotonicEntropy_SameTimestamp_Inc1\", []uint64{123}, ulid.Monotonic(crand.Reader, 1)},\n\t\t{\"WithCryptoMonotonicEntropy_DifferentTimestamp_Inc1\", []uint64{122, 123}, ulid.Monotonic(crand.Reader, 1)},\n\t\t{\"WithoutEntropy\", []uint64{123}, nil},\n\t} {\n\t\ttc := tc\n\t\tb.Run(tc.name, func(b *testing.B) {\n\t\t\tb.StopTimer()\n\t\t\tb.ResetTimer()\n\t\t\tb.StartTimer()\n\t\t\tfor i := 0; i < b.N; i++ {\n\t\t\t\tf(tc.timestamps[i%len(tc.timestamps)], tc.entropy)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc BenchmarkParse(b *testing.B) {\n\tconst s = \"0000XSNJG0MQJHBF4QX1EFD6Y3\"\n\tb.SetBytes(int64(len(s)))\n\tfor i := 0; i < b.N; i++ {\n\t\t_, _ = ulid.Parse(s)\n\t}\n}\n\nfunc BenchmarkParseStrict(b *testing.B) {\n\tconst s = \"0000XSNJG0MQJHBF4QX1EFD6Y3\"\n\tb.SetBytes(int64(len(s)))\n\tfor i := 0; i < b.N; i++ {\n\t\t_, _ = ulid.ParseStrict(s)\n\t}\n}\n\nfunc BenchmarkMustParse(b *testing.B) {\n\tconst s = \"0000XSNJG0MQJHBF4QX1EFD6Y3\"\n\tb.SetBytes(int64(len(s)))\n\tfor i := 0; i < b.N; i++ {\n\t\t_ = ulid.MustParse(s)\n\t}\n}\n\nfunc BenchmarkString(b *testing.B) {\n\tentropy := rand.New(rand.NewSource(time.Now().UnixNano()))\n\tid := ulid.MustNew(123456, entropy)\n\tb.SetBytes(int64(len(id)))\n\tb.ResetTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\t_ = id.String()\n\t}\n}\n\nfunc BenchmarkMarshal(b *testing.B) {\n\tentropy := rand.New(rand.NewSource(time.Now().UnixNano()))\n\tbuf := make([]byte, ulid.EncodedSize)\n\tid := ulid.MustNew(123456, entropy)\n\n\tb.Run(\"Text\", func(b *testing.B) {\n\t\tb.SetBytes(int64(len(id)))\n\t\tb.ResetTimer()\n\t\tfor i := 0; i < b.N; i++ {\n\t\t\t_, _ = id.MarshalText()\n\t\t}\n\t})\n\n\tb.Run(\"TextTo\", func(b *testing.B) {\n\t\tb.SetBytes(int64(len(id)))\n\t\tb.ResetTimer()\n\t\tfor i := 0; i < b.N; i++ {\n\t\t\t_ = id.MarshalTextTo(buf)\n\t\t}\n\t})\n\n\tb.Run(\"Binary\", func(b *testing.B) {\n\t\tb.SetBytes(int64(len(id)))\n\t\tb.ResetTimer()\n\t\tfor i := 0; i < b.N; i++ {\n\t\t\t_, _ = id.MarshalBinary()\n\t\t}\n\t})\n\n\tb.Run(\"BinaryTo\", func(b *testing.B) {\n\t\tb.SetBytes(int64(len(id)))\n\t\tb.ResetTimer()\n\t\tfor i := 0; i < b.N; i++ {\n\t\t\t_ = id.MarshalBinaryTo(buf)\n\t\t}\n\t})\n}\n\nfunc BenchmarkUnmarshal(b *testing.B) {\n\tvar id ulid.ULID\n\ts := \"0000XSNJG0MQJHBF4QX1EFD6Y3\"\n\ttxt := []byte(s)\n\tbin, _ := ulid.MustParse(s).MarshalBinary()\n\n\tb.Run(\"Text\", func(b *testing.B) {\n\t\tb.SetBytes(int64(len(txt)))\n\t\tb.ResetTimer()\n\t\tfor i := 0; i < b.N; i++ {\n\t\t\t_ = id.UnmarshalText(txt)\n\t\t}\n\t})\n\n\tb.Run(\"Binary\", func(b *testing.B) {\n\t\tb.SetBytes(int64(len(bin)))\n\t\tb.ResetTimer()\n\t\tfor i := 0; i < b.N; i++ {\n\t\t\t_ = id.UnmarshalBinary(bin)\n\t\t}\n\t})\n}\n\nfunc BenchmarkNow(b *testing.B) {\n\tb.SetBytes(8)\n\tb.ResetTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\t_ = ulid.Now()\n\t}\n}\n\nfunc BenchmarkTimestamp(b *testing.B) {\n\tnow := time.Now()\n\tb.SetBytes(8)\n\tb.ResetTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\t_ = ulid.Timestamp(now)\n\t}\n}\n\nfunc BenchmarkTime(b *testing.B) {\n\tid := ulid.MustNew(123456789, nil)\n\tb.SetBytes(8)\n\tb.ResetTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\t_ = id.Time()\n\t}\n}\n\nfunc BenchmarkSetTime(b *testing.B) {\n\tvar id ulid.ULID\n\tb.SetBytes(8)\n\tb.ResetTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\t_ = id.SetTime(123456789)\n\t}\n}\n\nfunc BenchmarkEntropy(b *testing.B) {\n\tid := ulid.MustNew(0, strings.NewReader(\"ABCDEFGHIJKLMNOP\"))\n\tb.SetBytes(10)\n\tb.ResetTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\t_ = id.Entropy()\n\t}\n}\n\nfunc BenchmarkSetEntropy(b *testing.B) {\n\tvar id ulid.ULID\n\te := []byte(\"ABCDEFGHIJKLMNOP\")\n\tb.SetBytes(10)\n\tb.ResetTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\t_ = id.SetEntropy(e)\n\t}\n}\n\nfunc BenchmarkCompare(b *testing.B) {\n\tid, other := ulid.MustNew(12345, nil), ulid.MustNew(54321, nil)\n\tb.SetBytes(int64(len(id) * 2))\n\tb.ResetTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\t_ = id.Compare(other)\n\t}\n}\n"
        }
      ]
    }
  ]
}