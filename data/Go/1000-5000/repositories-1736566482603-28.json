{
  "metadata": {
    "timestamp": 1736566482603,
    "page": 28,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjMw",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "streadway/amqp",
      "stars": 4883,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.2314453125,
          "content": "certs/*\nspec/spec\nexamples/simple-consumer/simple-consumer\nexamples/simple-producer/simple-producer\n\n.idea/**/workspace.xml\n.idea/**/tasks.xml\n.idea/**/usage.statistics.xml\n.idea/**/dictionaries\n.idea/**/shelf\n\n.idea/**/contentModel.xml\n"
        },
        {
          "name": ".travis.yml",
          "type": "blob",
          "size": 0.3310546875,
          "content": "language: go\n\ngo:\n  - 1.10.x\n  - 1.11.x\n  - 1.12.x\n  - 1.13.x\n\naddons:\n  apt:\n    packages:\n      - rabbitmq-server\n\nservices:\n  - rabbitmq\n\nenv:\n  - GO111MODULE=on AMQP_URL=amqp://guest:guest@127.0.0.1:5672/\n\nbefore_install:\n  - go get -v golang.org/x/lint/golint\n\nscript:\n  - ./pre-commit\n  - go test -cpu=1,2 -v -tags integration ./...\n"
        },
        {
          "name": "CONTRIBUTING.md",
          "type": "blob",
          "size": 1.162109375,
          "content": "## Prequisites\n\n1. Go: [https://golang.org/dl/](https://golang.org/dl/)\n1. Golint `go get -u -v github.com/golang/lint/golint`\n\n## Contributing\n\nThe workflow is pretty standard:\n\n1. Fork github.com/streadway/amqp\n1. Add the pre-commit hook: `ln -s ../../pre-commit .git/hooks/pre-commit`\n1. Create your feature branch (`git checkout -b my-new-feature`)\n1. Run integration tests (see below)\n1. **Implement tests**\n1. Implement fixs\n1. Commit your changes (`git commit -am 'Add some feature'`)\n1. Push to a branch (`git push -u origin my-new-feature`)\n1. Submit a pull request\n\n## Running Tests\n\nThe test suite assumes that:\n\n * A RabbitMQ node is running on localhost with all defaults: [https://www.rabbitmq.com/download.html](https://www.rabbitmq.com/download.html)\n * `AMQP_URL` is exported to `amqp://guest:guest@127.0.0.1:5672/`\n\n### Integration Tests\n\nAfter starting a local RabbitMQ, run integration tests with the following:\n\n    env AMQP_URL=amqp://guest:guest@127.0.0.1:5672/ go test -v -cpu 2 -tags integration -race\n\nAll integration tests should use the `integrationConnection(...)` test\nhelpers defined in `integration_test.go` to setup the integration environment\nand logging.\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.27734375,
          "content": "Copyright (c) 2012-2019, Sean Treadway, SoundCloud Ltd.\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are met:\n\nRedistributions of source code must retain the above copyright notice, this\nlist of conditions and the following disclaimer.\n\nRedistributions in binary form must reproduce the above copyright notice, this\nlist of conditions and the following disclaimer in the documentation and/or\nother materials provided with the distribution.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\nANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\nWARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\nFOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\nDAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\nSERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\nCAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\nOR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 4.01171875,
          "content": "[![Build Status](https://api.travis-ci.org/streadway/amqp.svg)](http://travis-ci.org/streadway/amqp) [![GoDoc](https://godoc.org/github.com/streadway/amqp?status.svg)](http://godoc.org/github.com/streadway/amqp)\n\n# Go RabbitMQ Client Library (Unmaintained Fork)\n\n## Beware of Abandonware\n\nThis repository is **NOT ACTIVELY MAINTAINED**. Consider using\na different fork instead: [rabbitmq/amqp091-go](https://github.com/rabbitmq/amqp091-go).\nIn case of questions, start a discussion in that repo or [use other RabbitMQ community resources](https://rabbitmq.com/contact.html).\n\n\n\n## Project Maturity\n\nThis project has been used in production systems for many years. As of 2022,\nthis repository is **NOT ACTIVELY MAINTAINED**.\n\nThis repository is **very strict** about any potential public API changes.\nYou may want to consider [rabbitmq/amqp091-go](https://github.com/rabbitmq/amqp091-go) which\nis more willing to adapt the API.\n\n\n## Supported Go Versions\n\nThis library supports two most recent Go release series, currently 1.10 and 1.11.\n\n\n## Supported RabbitMQ Versions\n\nThis project supports RabbitMQ versions starting with `2.0` but primarily tested\nagainst reasonably recent `3.x` releases. Some features and behaviours may be\nserver version-specific.\n\n## Goals\n\nProvide a functional interface that closely represents the AMQP 0.9.1 model\ntargeted to RabbitMQ as a server.  This includes the minimum necessary to\ninteract the semantics of the protocol.\n\n## Non-goals\n\nThings not intended to be supported.\n\n  * Auto reconnect and re-synchronization of client and server topologies.\n    * Reconnection would require understanding the error paths when the\n      topology cannot be declared on reconnect.  This would require a new set\n      of types and code paths that are best suited at the call-site of this\n      package.  AMQP has a dynamic topology that needs all peers to agree. If\n      this doesn't happen, the behavior is undefined.  Instead of producing a\n      possible interface with undefined behavior, this package is designed to\n      be simple for the caller to implement the necessary connection-time\n      topology declaration so that reconnection is trivial and encapsulated in\n      the caller's application code.\n  * AMQP Protocol negotiation for forward or backward compatibility.\n    * 0.9.1 is stable and widely deployed.  Versions 0.10 and 1.0 are divergent\n      specifications that change the semantics and wire format of the protocol.\n      We will accept patches for other protocol support but have no plans for\n      implementation ourselves.\n  * Anything other than PLAIN and EXTERNAL authentication mechanisms.\n    * Keeping the mechanisms interface modular makes it possible to extend\n      outside of this package.  If other mechanisms prove to be popular, then\n      we would accept patches to include them in this package.\n\n## Usage\n\nSee the 'examples' subdirectory for simple producers and consumers executables.\nIf you have a use-case in mind which isn't well-represented by the examples,\nplease file an issue.\n\n## Documentation\n\nUse [Godoc documentation](http://godoc.org/github.com/streadway/amqp) for\nreference and usage.\n\n[RabbitMQ tutorials in\nGo](https://github.com/rabbitmq/rabbitmq-tutorials/tree/master/go) are also\navailable.\n\n## Contributing\n\nPull requests are very much welcomed.  Create your pull request on a non-master\nbranch, make sure a test or example is included that covers your change and\nyour commits represent coherent changes that include a reason for the change.\n\nTo run the integration tests, make sure you have RabbitMQ running on any host,\nexport the environment variable `AMQP_URL=amqp://host/` and run `go test -tags\nintegration`.  TravisCI will also run the integration tests.\n\nThanks to the [community of contributors](https://github.com/streadway/amqp/graphs/contributors).\n\n## External packages\n\n  * [Google App Engine Dialer support](https://github.com/soundtrackyourbrand/gaeamqp)\n  * [RabbitMQ examples in Go](https://github.com/rabbitmq/rabbitmq-tutorials/tree/master/go)\n\n## License\n\nBSD 2 clause - see LICENSE for more details.\n\n\n"
        },
        {
          "name": "_examples",
          "type": "tree",
          "content": null
        },
        {
          "name": "allocator.go",
          "type": "blob",
          "size": 2.1435546875,
          "content": "package amqp\n\nimport (\n\t\"bytes\"\n\t\"fmt\"\n\t\"math/big\"\n)\n\nconst (\n\tfree      = 0\n\tallocated = 1\n)\n\n// allocator maintains a bitset of allocated numbers.\ntype allocator struct {\n\tpool *big.Int\n\tlast int\n\tlow  int\n\thigh int\n}\n\n// NewAllocator reserves and frees integers out of a range between low and\n// high.\n//\n// O(N) worst case space used, where N is maximum allocated, divided by\n// sizeof(big.Word)\nfunc newAllocator(low, high int) *allocator {\n\treturn &allocator{\n\t\tpool: big.NewInt(0),\n\t\tlast: low,\n\t\tlow:  low,\n\t\thigh: high,\n\t}\n}\n\n// String returns a string describing the contents of the allocator like\n// \"allocator[low..high] reserved..until\"\n//\n// O(N) where N is high-low\nfunc (a allocator) String() string {\n\tb := &bytes.Buffer{}\n\tfmt.Fprintf(b, \"allocator[%d..%d]\", a.low, a.high)\n\n\tfor low := a.low; low <= a.high; low++ {\n\t\thigh := low\n\t\tfor a.reserved(high) && high <= a.high {\n\t\t\thigh++\n\t\t}\n\n\t\tif high > low+1 {\n\t\t\tfmt.Fprintf(b, \" %d..%d\", low, high-1)\n\t\t} else if high > low {\n\t\t\tfmt.Fprintf(b, \" %d\", high-1)\n\t\t}\n\n\t\tlow = high\n\t}\n\treturn b.String()\n}\n\n// Next reserves and returns the next available number out of the range between\n// low and high.  If no number is available, false is returned.\n//\n// O(N) worst case runtime where N is allocated, but usually O(1) due to a\n// rolling index into the oldest allocation.\nfunc (a *allocator) next() (int, bool) {\n\twrapped := a.last\n\n\t// Find trailing bit\n\tfor ; a.last <= a.high; a.last++ {\n\t\tif a.reserve(a.last) {\n\t\t\treturn a.last, true\n\t\t}\n\t}\n\n\t// Find preceding free'd pool\n\ta.last = a.low\n\n\tfor ; a.last < wrapped; a.last++ {\n\t\tif a.reserve(a.last) {\n\t\t\treturn a.last, true\n\t\t}\n\t}\n\n\treturn 0, false\n}\n\n// reserve claims the bit if it is not already claimed, returning true if\n// successfully claimed.\nfunc (a *allocator) reserve(n int) bool {\n\tif a.reserved(n) {\n\t\treturn false\n\t}\n\ta.pool.SetBit(a.pool, n-a.low, allocated)\n\treturn true\n}\n\n// reserved returns true if the integer has been allocated\nfunc (a *allocator) reserved(n int) bool {\n\treturn a.pool.Bit(n-a.low) == allocated\n}\n\n// release frees the use of the number for another allocation\nfunc (a *allocator) release(n int) {\n\ta.pool.SetBit(a.pool, n-a.low, free)\n}\n"
        },
        {
          "name": "allocator_test.go",
          "type": "blob",
          "size": 2.0966796875,
          "content": "package amqp\n\nimport (\n\t\"math/rand\"\n\t\"testing\"\n)\n\nfunc TestAllocatorFirstShouldBeTheLow(t *testing.T) {\n\tn, ok := newAllocator(1, 2).next()\n\tif !ok {\n\t\tt.Fatalf(\"expected to allocate between 1 and 2\")\n\t}\n\n\tif want, got := 1, n; want != got {\n\t\tt.Fatalf(\"expected to first allocation to be 1\")\n\t}\n}\n\nfunc TestAllocatorShouldBeBoundByHigh(t *testing.T) {\n\ta := newAllocator(1, 2)\n\n\tif n, ok := a.next(); n != 1 || !ok {\n\t\tt.Fatalf(\"expected to allocate between 1 and 2, got %d, %v\", n, ok)\n\t}\n\tif n, ok := a.next(); n != 2 || !ok {\n\t\tt.Fatalf(\"expected to allocate between 1 and 2, got %d, %v\", n, ok)\n\t}\n\tif _, ok := a.next(); ok {\n\t\tt.Fatalf(\"expected not to allocate outside of 1 and 2\")\n\t}\n}\n\nfunc TestAllocatorStringShouldIncludeAllocatedRanges(t *testing.T) {\n\ta := newAllocator(1, 10)\n\ta.reserve(1)\n\ta.reserve(2)\n\ta.reserve(3)\n\ta.reserve(5)\n\ta.reserve(6)\n\ta.reserve(8)\n\ta.reserve(10)\n\n\tif want, got := \"allocator[1..10] 1..3 5..6 8 10\", a.String(); want != got {\n\t\tt.Fatalf(\"expected String of %q, got %q\", want, got)\n\t}\n}\n\nfunc TestAllocatorShouldReuseReleased(t *testing.T) {\n\ta := newAllocator(1, 2)\n\n\tfirst, _ := a.next()\n\tif want, got := 1, first; want != got {\n\t\tt.Fatalf(\"expected allocation to be %d, got: %d\", want, got)\n\t}\n\n\tsecond, _ := a.next()\n\tif want, got := 2, second; want != got {\n\t\tt.Fatalf(\"expected allocation to be %d, got: %d\", want, got)\n\t}\n\n\ta.release(first)\n\n\tthird, _ := a.next()\n\tif want, got := first, third; want != got {\n\t\tt.Fatalf(\"expected third allocation to be %d, got: %d\", want, got)\n\t}\n\n\t_, ok := a.next()\n\tif want, got := false, ok; want != got {\n\t\tt.Fatalf(\"expected fourth allocation to saturate the pool\")\n\t}\n}\n\nfunc TestAllocatorReleasesKeepUpWithAllocationsForAllSizes(t *testing.T) {\n\tif testing.Short() {\n\t\tt.Skip()\n\t}\n\n\tconst runs = 5\n\tconst max = 13\n\n\tfor lim := 1; lim < 2<<max; lim <<= 1 {\n\t\ta := newAllocator(0, lim)\n\n\t\tfor i := 0; i < runs*lim; i++ {\n\t\t\tif i >= lim { // fills the allocator\n\t\t\t\ta.release(int(rand.Int63n(int64(lim))))\n\t\t\t}\n\t\t\tif _, ok := a.next(); !ok {\n\t\t\t\tt.Fatalf(\"expected %d runs of random release of size %d not to fail on allocation %d\", runs, lim, i)\n\t\t\t}\n\t\t}\n\t}\n}\n"
        },
        {
          "name": "auth.go",
          "type": "blob",
          "size": 1.580078125,
          "content": "// Copyright (c) 2012, Sean Treadway, SoundCloud Ltd.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n// Source code and contact info at http://github.com/streadway/amqp\n\npackage amqp\n\nimport (\n\t\"fmt\"\n)\n\n// Authentication interface provides a means for different SASL authentication\n// mechanisms to be used during connection tuning.\ntype Authentication interface {\n\tMechanism() string\n\tResponse() string\n}\n\n// PlainAuth is a similar to Basic Auth in HTTP.\ntype PlainAuth struct {\n\tUsername string\n\tPassword string\n}\n\n// Mechanism returns \"PLAIN\"\nfunc (auth *PlainAuth) Mechanism() string {\n\treturn \"PLAIN\"\n}\n\n// Response returns the null character delimited encoding for the SASL PLAIN Mechanism.\nfunc (auth *PlainAuth) Response() string {\n\treturn fmt.Sprintf(\"\\000%s\\000%s\", auth.Username, auth.Password)\n}\n\n// AMQPlainAuth is similar to PlainAuth\ntype AMQPlainAuth struct {\n\tUsername string\n\tPassword string\n}\n\n// Mechanism returns \"AMQPLAIN\"\nfunc (auth *AMQPlainAuth) Mechanism() string {\n\treturn \"AMQPLAIN\"\n}\n\n// Response returns the null character delimited encoding for the SASL PLAIN Mechanism.\nfunc (auth *AMQPlainAuth) Response() string {\n\treturn fmt.Sprintf(\"LOGIN:%sPASSWORD:%s\", auth.Username, auth.Password)\n}\n\n// Finds the first mechanism preferred by the client that the server supports.\nfunc pickSASLMechanism(client []Authentication, serverMechanisms []string) (auth Authentication, ok bool) {\n\tfor _, auth = range client {\n\t\tfor _, mech := range serverMechanisms {\n\t\t\tif auth.Mechanism() == mech {\n\t\t\t\treturn auth, true\n\t\t\t}\n\t\t}\n\t}\n\n\treturn\n}\n"
        },
        {
          "name": "certs.sh",
          "type": "blob",
          "size": 2.9169921875,
          "content": "#!/bin/sh\n#\n# Creates the CA, server and client certs to be used by tls_test.go\n# http://www.rabbitmq.com/ssl.html\n#\n# Copy stdout into the const section of tls_test.go or use for RabbitMQ\n#\nroot=$PWD/certs\n\nif [ -f $root/ca/serial ]; then\n  echo >&2 \"Previous installation found\"\n  echo >&2 \"Remove $root/ca and rerun to overwrite\"\n  exit 1\nfi\n\nmkdir -p $root/ca/private\nmkdir -p $root/ca/certs\nmkdir -p $root/server\nmkdir -p $root/client\n\ncd $root/ca\n\nchmod 700 private\ntouch index.txt\necho 'unique_subject = no' > index.txt.attr\necho '01' > serial\necho >openssl.cnf '\n[ ca ]\ndefault_ca = testca\n\n[ testca ]\ndir = .\ncertificate = $dir/cacert.pem\ndatabase = $dir/index.txt\nnew_certs_dir = $dir/certs\nprivate_key = $dir/private/cakey.pem\nserial = $dir/serial\n\ndefault_crl_days = 7\ndefault_days = 3650\ndefault_md = sha1\n\npolicy = testca_policy\nx509_extensions = certificate_extensions\n\n[ testca_policy ]\ncommonName = supplied\nstateOrProvinceName = optional\ncountryName = optional\nemailAddress = optional\norganizationName = optional\norganizationalUnitName = optional\n\n[ certificate_extensions ]\nbasicConstraints = CA:false\n\n[ req ]\ndefault_bits = 2048\ndefault_keyfile = ./private/cakey.pem\ndefault_md = sha1\nprompt = yes\ndistinguished_name = root_ca_distinguished_name\nx509_extensions = root_ca_extensions\n\n[ root_ca_distinguished_name ]\ncommonName = hostname\n\n[ root_ca_extensions ]\nbasicConstraints = CA:true\nkeyUsage = keyCertSign, cRLSign\n\n[ client_ca_extensions ]\nbasicConstraints = CA:false\nkeyUsage = digitalSignature\nextendedKeyUsage = 1.3.6.1.5.5.7.3.2\n\n[ server_ca_extensions ]\nbasicConstraints = CA:false\nkeyUsage = keyEncipherment\nextendedKeyUsage = 1.3.6.1.5.5.7.3.1\nsubjectAltName = @alt_names\n\n[ alt_names ]\nIP.1 = 127.0.0.1\n'\n\nopenssl req \\\n  -x509 \\\n  -nodes \\\n  -config openssl.cnf \\\n  -newkey rsa:2048 \\\n  -days 3650 \\\n  -subj \"/CN=MyTestCA/\" \\\n  -out cacert.pem \\\n  -outform PEM\n\nopenssl x509 \\\n  -in cacert.pem \\\n  -out cacert.cer \\\n  -outform DER\n\nopenssl genrsa -out $root/server/key.pem 2048\nopenssl genrsa -out $root/client/key.pem 2048\n\nopenssl req \\\n  -new \\\n  -nodes \\\n  -config openssl.cnf \\\n  -subj \"/CN=127.0.0.1/O=server/\" \\\n  -key $root/server/key.pem \\\n  -out $root/server/req.pem \\\n  -outform PEM\n\nopenssl req \\\n  -new \\\n  -nodes \\\n  -config openssl.cnf \\\n  -subj \"/CN=127.0.0.1/O=client/\" \\\n  -key $root/client/key.pem \\\n  -out $root/client/req.pem \\\n  -outform PEM\n\nopenssl ca \\\n  -config openssl.cnf \\\n  -in $root/server/req.pem \\\n  -out $root/server/cert.pem \\\n  -notext \\\n  -batch \\\n  -extensions server_ca_extensions\n\nopenssl ca \\\n  -config openssl.cnf \\\n  -in $root/client/req.pem \\\n  -out $root/client/cert.pem \\\n  -notext \\\n  -batch \\\n  -extensions client_ca_extensions\n\ncat <<-END\nconst caCert = \\`\n`cat $root/ca/cacert.pem`\n\\`\n\nconst serverCert = \\`\n`cat $root/server/cert.pem`\n\\`\n\nconst serverKey = \\`\n`cat $root/server/key.pem`\n\\`\n\nconst clientCert = \\`\n`cat $root/client/cert.pem`\n\\`\n\nconst clientKey = \\`\n`cat $root/client/key.pem`\n\\`\nEND\n"
        },
        {
          "name": "channel.go",
          "type": "blob",
          "size": 47.53515625,
          "content": "// Copyright (c) 2012, Sean Treadway, SoundCloud Ltd.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n// Source code and contact info at http://github.com/streadway/amqp\n\npackage amqp\n\nimport (\n\t\"reflect\"\n\t\"sync\"\n\t\"sync/atomic\"\n)\n\n// 0      1         3             7                  size+7 size+8\n// +------+---------+-------------+  +------------+  +-----------+\n// | type | channel |     size    |  |  payload   |  | frame-end |\n// +------+---------+-------------+  +------------+  +-----------+\n//  octet   short         long         size octets       octet\nconst frameHeaderSize = 1 + 2 + 4 + 1\n\n/*\nChannel represents an AMQP channel. Used as a context for valid message\nexchange.  Errors on methods with this Channel as a receiver means this channel\nshould be discarded and a new channel established.\n\n*/\ntype Channel struct {\n\tdestructor sync.Once\n\tm          sync.Mutex // struct field mutex\n\tconfirmM   sync.Mutex // publisher confirms state mutex\n\tnotifyM    sync.RWMutex\n\n\tconnection *Connection\n\n\trpc       chan message\n\tconsumers *consumers\n\n\tid uint16\n\n\t// closed is set to 1 when the channel has been closed - see Channel.send()\n\tclosed int32\n\n\t// true when we will never notify again\n\tnoNotify bool\n\n\t// Channel and Connection exceptions will be broadcast on these listeners.\n\tcloses []chan *Error\n\n\t// Listeners for active=true flow control.  When true is sent to a listener,\n\t// publishing should pause until false is sent to listeners.\n\tflows []chan bool\n\n\t// Listeners for returned publishings for unroutable messages on mandatory\n\t// publishings or undeliverable messages on immediate publishings.\n\treturns []chan Return\n\n\t// Listeners for when the server notifies the client that\n\t// a consumer has been cancelled.\n\tcancels []chan string\n\n\t// Allocated when in confirm mode in order to track publish counter and order confirms\n\tconfirms   *confirms\n\tconfirming bool\n\n\t// Selects on any errors from shutdown during RPC\n\terrors chan *Error\n\n\t// State machine that manages frame order, must only be mutated by the connection\n\trecv func(*Channel, frame) error\n\n\t// Current state for frame re-assembly, only mutated from recv\n\tmessage messageWithContent\n\theader  *headerFrame\n\tbody    []byte\n}\n\n// Constructs a new channel with the given framing rules\nfunc newChannel(c *Connection, id uint16) *Channel {\n\treturn &Channel{\n\t\tconnection: c,\n\t\tid:         id,\n\t\trpc:        make(chan message),\n\t\tconsumers:  makeConsumers(),\n\t\tconfirms:   newConfirms(),\n\t\trecv:       (*Channel).recvMethod,\n\t\terrors:     make(chan *Error, 1),\n\t}\n}\n\n// shutdown is called by Connection after the channel has been removed from the\n// connection registry.\nfunc (ch *Channel) shutdown(e *Error) {\n\tch.destructor.Do(func() {\n\t\tch.m.Lock()\n\t\tdefer ch.m.Unlock()\n\n\t\t// Grab an exclusive lock for the notify channels\n\t\tch.notifyM.Lock()\n\t\tdefer ch.notifyM.Unlock()\n\n\t\t// Broadcast abnormal shutdown\n\t\tif e != nil {\n\t\t\tfor _, c := range ch.closes {\n\t\t\t\tc <- e\n\t\t\t}\n\t\t}\n\n\t\t// Signal that from now on, Channel.send() should call\n\t\t// Channel.sendClosed()\n\t\tatomic.StoreInt32(&ch.closed, 1)\n\n\t\t// Notify RPC if we're selecting\n\t\tif e != nil {\n\t\t\tch.errors <- e\n\t\t}\n\n\t\tch.consumers.close()\n\n\t\tfor _, c := range ch.closes {\n\t\t\tclose(c)\n\t\t}\n\n\t\tfor _, c := range ch.flows {\n\t\t\tclose(c)\n\t\t}\n\n\t\tfor _, c := range ch.returns {\n\t\t\tclose(c)\n\t\t}\n\n\t\tfor _, c := range ch.cancels {\n\t\t\tclose(c)\n\t\t}\n\n\t\t// Set the slices to nil to prevent the dispatch() range from sending on\n\t\t// the now closed channels after we release the notifyM mutex\n\t\tch.flows = nil\n\t\tch.closes = nil\n\t\tch.returns = nil\n\t\tch.cancels = nil\n\n\t\tif ch.confirms != nil {\n\t\t\tch.confirms.Close()\n\t\t}\n\n\t\tclose(ch.errors)\n\t\tch.noNotify = true\n\t})\n}\n\n// send calls Channel.sendOpen() during normal operation.\n//\n// After the channel has been closed, send calls Channel.sendClosed(), ensuring\n// only 'channel.close' is sent to the server.\nfunc (ch *Channel) send(msg message) (err error) {\n\t// If the channel is closed, use Channel.sendClosed()\n\tif atomic.LoadInt32(&ch.closed) == 1 {\n\t\treturn ch.sendClosed(msg)\n\t}\n\n\treturn ch.sendOpen(msg)\n}\n\nfunc (ch *Channel) open() error {\n\treturn ch.call(&channelOpen{}, &channelOpenOk{})\n}\n\n// Performs a request/response call for when the message is not NoWait and is\n// specified as Synchronous.\nfunc (ch *Channel) call(req message, res ...message) error {\n\tif err := ch.send(req); err != nil {\n\t\treturn err\n\t}\n\n\tif req.wait() {\n\t\tselect {\n\t\tcase e, ok := <-ch.errors:\n\t\t\tif ok {\n\t\t\t\treturn e\n\t\t\t}\n\t\t\treturn ErrClosed\n\n\t\tcase msg := <-ch.rpc:\n\t\t\tif msg != nil {\n\t\t\t\tfor _, try := range res {\n\t\t\t\t\tif reflect.TypeOf(msg) == reflect.TypeOf(try) {\n\t\t\t\t\t\t// *res = *msg\n\t\t\t\t\t\tvres := reflect.ValueOf(try).Elem()\n\t\t\t\t\t\tvmsg := reflect.ValueOf(msg).Elem()\n\t\t\t\t\t\tvres.Set(vmsg)\n\t\t\t\t\t\treturn nil\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn ErrCommandInvalid\n\t\t\t}\n\t\t\t// RPC channel has been closed without an error, likely due to a hard\n\t\t\t// error on the Connection.  This indicates we have already been\n\t\t\t// shutdown and if were waiting, will have returned from the errors chan.\n\t\t\treturn ErrClosed\n\t\t}\n\t}\n\n\treturn nil\n}\n\nfunc (ch *Channel) sendClosed(msg message) (err error) {\n\t// After a 'channel.close' is sent or received the only valid response is\n\t// channel.close-ok\n\tif _, ok := msg.(*channelCloseOk); ok {\n\t\treturn ch.connection.send(&methodFrame{\n\t\t\tChannelId: ch.id,\n\t\t\tMethod:    msg,\n\t\t})\n\t}\n\n\treturn ErrClosed\n}\n\nfunc (ch *Channel) sendOpen(msg message) (err error) {\n\tif content, ok := msg.(messageWithContent); ok {\n\t\tprops, body := content.getContent()\n\t\tclass, _ := content.id()\n\n\t\t// catch client max frame size==0 and server max frame size==0\n\t\t// set size to length of what we're trying to publish\n\t\tvar size int\n\t\tif ch.connection.Config.FrameSize > 0 {\n\t\t\tsize = ch.connection.Config.FrameSize - frameHeaderSize\n\t\t} else {\n\t\t\tsize = len(body)\n\t\t}\n\n\t\tif err = ch.connection.send(&methodFrame{\n\t\t\tChannelId: ch.id,\n\t\t\tMethod:    content,\n\t\t}); err != nil {\n\t\t\treturn\n\t\t}\n\n\t\tif err = ch.connection.send(&headerFrame{\n\t\t\tChannelId:  ch.id,\n\t\t\tClassId:    class,\n\t\t\tSize:       uint64(len(body)),\n\t\t\tProperties: props,\n\t\t}); err != nil {\n\t\t\treturn\n\t\t}\n\n\t\t// chunk body into size (max frame size - frame header size)\n\t\tfor i, j := 0, size; i < len(body); i, j = j, j+size {\n\t\t\tif j > len(body) {\n\t\t\t\tj = len(body)\n\t\t\t}\n\n\t\t\tif err = ch.connection.send(&bodyFrame{\n\t\t\t\tChannelId: ch.id,\n\t\t\t\tBody:      body[i:j],\n\t\t\t}); err != nil {\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t} else {\n\t\terr = ch.connection.send(&methodFrame{\n\t\t\tChannelId: ch.id,\n\t\t\tMethod:    msg,\n\t\t})\n\t}\n\n\treturn\n}\n\n// Eventually called via the state machine from the connection's reader\n// goroutine, so assumes serialized access.\nfunc (ch *Channel) dispatch(msg message) {\n\tswitch m := msg.(type) {\n\tcase *channelClose:\n\t\t// lock before sending connection.close-ok\n\t\t// to avoid unexpected interleaving with basic.publish frames if\n\t\t// publishing is happening concurrently\n\t\tch.m.Lock()\n\t\tch.send(&channelCloseOk{})\n\t\tch.m.Unlock()\n\t\tch.connection.closeChannel(ch, newError(m.ReplyCode, m.ReplyText))\n\n\tcase *channelFlow:\n\t\tch.notifyM.RLock()\n\t\tfor _, c := range ch.flows {\n\t\t\tc <- m.Active\n\t\t}\n\t\tch.notifyM.RUnlock()\n\t\tch.send(&channelFlowOk{Active: m.Active})\n\n\tcase *basicCancel:\n\t\tch.notifyM.RLock()\n\t\tfor _, c := range ch.cancels {\n\t\t\tc <- m.ConsumerTag\n\t\t}\n\t\tch.notifyM.RUnlock()\n\t\tch.consumers.cancel(m.ConsumerTag)\n\n\tcase *basicReturn:\n\t\tret := newReturn(*m)\n\t\tch.notifyM.RLock()\n\t\tfor _, c := range ch.returns {\n\t\t\tc <- *ret\n\t\t}\n\t\tch.notifyM.RUnlock()\n\n\tcase *basicAck:\n\t\tif ch.confirming {\n\t\t\tif m.Multiple {\n\t\t\t\tch.confirms.Multiple(Confirmation{m.DeliveryTag, true})\n\t\t\t} else {\n\t\t\t\tch.confirms.One(Confirmation{m.DeliveryTag, true})\n\t\t\t}\n\t\t}\n\n\tcase *basicNack:\n\t\tif ch.confirming {\n\t\t\tif m.Multiple {\n\t\t\t\tch.confirms.Multiple(Confirmation{m.DeliveryTag, false})\n\t\t\t} else {\n\t\t\t\tch.confirms.One(Confirmation{m.DeliveryTag, false})\n\t\t\t}\n\t\t}\n\n\tcase *basicDeliver:\n\t\tch.consumers.send(m.ConsumerTag, newDelivery(ch, m))\n\t\t// TODO log failed consumer and close channel, this can happen when\n\t\t// deliveries are in flight and a no-wait cancel has happened\n\n\tdefault:\n\t\tch.rpc <- msg\n\t}\n}\n\nfunc (ch *Channel) transition(f func(*Channel, frame) error) error {\n\tch.recv = f\n\treturn nil\n}\n\nfunc (ch *Channel) recvMethod(f frame) error {\n\tswitch frame := f.(type) {\n\tcase *methodFrame:\n\t\tif msg, ok := frame.Method.(messageWithContent); ok {\n\t\t\tch.body = make([]byte, 0)\n\t\t\tch.message = msg\n\t\t\treturn ch.transition((*Channel).recvHeader)\n\t\t}\n\n\t\tch.dispatch(frame.Method) // termination state\n\t\treturn ch.transition((*Channel).recvMethod)\n\n\tcase *headerFrame:\n\t\t// drop\n\t\treturn ch.transition((*Channel).recvMethod)\n\n\tcase *bodyFrame:\n\t\t// drop\n\t\treturn ch.transition((*Channel).recvMethod)\n\t}\n\n\tpanic(\"unexpected frame type\")\n}\n\nfunc (ch *Channel) recvHeader(f frame) error {\n\tswitch frame := f.(type) {\n\tcase *methodFrame:\n\t\t// interrupt content and handle method\n\t\treturn ch.recvMethod(f)\n\n\tcase *headerFrame:\n\t\t// start collecting if we expect body frames\n\t\tch.header = frame\n\n\t\tif frame.Size == 0 {\n\t\t\tch.message.setContent(ch.header.Properties, ch.body)\n\t\t\tch.dispatch(ch.message) // termination state\n\t\t\treturn ch.transition((*Channel).recvMethod)\n\t\t}\n\t\treturn ch.transition((*Channel).recvContent)\n\n\tcase *bodyFrame:\n\t\t// drop and reset\n\t\treturn ch.transition((*Channel).recvMethod)\n\t}\n\n\tpanic(\"unexpected frame type\")\n}\n\n// state after method + header and before the length\n// defined by the header has been reached\nfunc (ch *Channel) recvContent(f frame) error {\n\tswitch frame := f.(type) {\n\tcase *methodFrame:\n\t\t// interrupt content and handle method\n\t\treturn ch.recvMethod(f)\n\n\tcase *headerFrame:\n\t\t// drop and reset\n\t\treturn ch.transition((*Channel).recvMethod)\n\n\tcase *bodyFrame:\n\t\tif cap(ch.body) == 0 {\n\t\t\tch.body = make([]byte, 0, ch.header.Size)\n\t\t}\n\t\tch.body = append(ch.body, frame.Body...)\n\n\t\tif uint64(len(ch.body)) >= ch.header.Size {\n\t\t\tch.message.setContent(ch.header.Properties, ch.body)\n\t\t\tch.dispatch(ch.message) // termination state\n\t\t\treturn ch.transition((*Channel).recvMethod)\n\t\t}\n\n\t\treturn ch.transition((*Channel).recvContent)\n\t}\n\n\tpanic(\"unexpected frame type\")\n}\n\n/*\nClose initiate a clean channel closure by sending a close message with the error\ncode set to '200'.\n\nIt is safe to call this method multiple times.\n\n*/\nfunc (ch *Channel) Close() error {\n\tdefer ch.connection.closeChannel(ch, nil)\n\treturn ch.call(\n\t\t&channelClose{ReplyCode: replySuccess},\n\t\t&channelCloseOk{},\n\t)\n}\n\n/*\nNotifyClose registers a listener for when the server sends a channel or\nconnection exception in the form of a Connection.Close or Channel.Close method.\nConnection exceptions will be broadcast to all open channels and all channels\nwill be closed, where channel exceptions will only be broadcast to listeners to\nthis channel.\n\nThe chan provided will be closed when the Channel is closed and on a\ngraceful close, no error will be sent.\n\n*/\nfunc (ch *Channel) NotifyClose(c chan *Error) chan *Error {\n\tch.notifyM.Lock()\n\tdefer ch.notifyM.Unlock()\n\n\tif ch.noNotify {\n\t\tclose(c)\n\t} else {\n\t\tch.closes = append(ch.closes, c)\n\t}\n\n\treturn c\n}\n\n/*\nNotifyFlow registers a listener for basic.flow methods sent by the server.\nWhen `false` is sent on one of the listener channels, all publishers should\npause until a `true` is sent.\n\nThe server may ask the producer to pause or restart the flow of Publishings\nsent by on a channel. This is a simple flow-control mechanism that a server can\nuse to avoid overflowing its queues or otherwise finding itself receiving more\nmessages than it can process. Note that this method is not intended for window\ncontrol. It does not affect contents returned by basic.get-ok methods.\n\nWhen a new channel is opened, it is active (flow is active). Some\napplications assume that channels are inactive until started. To emulate\nthis behavior a client MAY open the channel, then pause it.\n\nPublishers should respond to a flow messages as rapidly as possible and the\nserver may disconnect over producing channels that do not respect these\nmessages.\n\nbasic.flow-ok methods will always be returned to the server regardless of\nthe number of listeners there are.\n\nTo control the flow of deliveries from the server, use the Channel.Flow()\nmethod instead.\n\nNote: RabbitMQ will rather use TCP pushback on the network connection instead\nof sending basic.flow.  This means that if a single channel is producing too\nmuch on the same connection, all channels using that connection will suffer,\nincluding acknowledgments from deliveries.  Use different Connections if you\ndesire to interleave consumers and producers in the same process to avoid your\nbasic.ack messages from getting rate limited with your basic.publish messages.\n\n*/\nfunc (ch *Channel) NotifyFlow(c chan bool) chan bool {\n\tch.notifyM.Lock()\n\tdefer ch.notifyM.Unlock()\n\n\tif ch.noNotify {\n\t\tclose(c)\n\t} else {\n\t\tch.flows = append(ch.flows, c)\n\t}\n\n\treturn c\n}\n\n/*\nNotifyReturn registers a listener for basic.return methods.  These can be sent\nfrom the server when a publish is undeliverable either from the mandatory or\nimmediate flags.\n\nA return struct has a copy of the Publishing along with some error\ninformation about why the publishing failed.\n\n*/\nfunc (ch *Channel) NotifyReturn(c chan Return) chan Return {\n\tch.notifyM.Lock()\n\tdefer ch.notifyM.Unlock()\n\n\tif ch.noNotify {\n\t\tclose(c)\n\t} else {\n\t\tch.returns = append(ch.returns, c)\n\t}\n\n\treturn c\n}\n\n/*\nNotifyCancel registers a listener for basic.cancel methods.  These can be sent\nfrom the server when a queue is deleted or when consuming from a mirrored queue\nwhere the master has just failed (and was moved to another node).\n\nThe subscription tag is returned to the listener.\n\n*/\nfunc (ch *Channel) NotifyCancel(c chan string) chan string {\n\tch.notifyM.Lock()\n\tdefer ch.notifyM.Unlock()\n\n\tif ch.noNotify {\n\t\tclose(c)\n\t} else {\n\t\tch.cancels = append(ch.cancels, c)\n\t}\n\n\treturn c\n}\n\n/*\nNotifyConfirm calls NotifyPublish and starts a goroutine sending\nordered Ack and Nack DeliveryTag to the respective channels.\n\nFor strict ordering, use NotifyPublish instead.\n*/\nfunc (ch *Channel) NotifyConfirm(ack, nack chan uint64) (chan uint64, chan uint64) {\n\tconfirms := ch.NotifyPublish(make(chan Confirmation, cap(ack)+cap(nack)))\n\n\tgo func() {\n\t\tfor c := range confirms {\n\t\t\tif c.Ack {\n\t\t\t\tack <- c.DeliveryTag\n\t\t\t} else {\n\t\t\t\tnack <- c.DeliveryTag\n\t\t\t}\n\t\t}\n\t\tclose(ack)\n\t\tif nack != ack {\n\t\t\tclose(nack)\n\t\t}\n\t}()\n\n\treturn ack, nack\n}\n\n/*\nNotifyPublish registers a listener for reliable publishing. Receives from this\nchan for every publish after Channel.Confirm will be in order starting with\nDeliveryTag 1.\n\nThere will be one and only one Confirmation Publishing starting with the\ndelivery tag of 1 and progressing sequentially until the total number of\nPublishings have been seen by the server.\n\nAcknowledgments will be received in the order of delivery from the\nNotifyPublish channels even if the server acknowledges them out of order.\n\nThe listener chan will be closed when the Channel is closed.\n\nThe capacity of the chan Confirmation must be at least as large as the\nnumber of outstanding publishings.  Not having enough buffered chans will\ncreate a deadlock if you attempt to perform other operations on the Connection\nor Channel while confirms are in-flight.\n\nIt's advisable to wait for all Confirmations to arrive before calling\nChannel.Close() or Connection.Close().\n\n*/\nfunc (ch *Channel) NotifyPublish(confirm chan Confirmation) chan Confirmation {\n\tch.notifyM.Lock()\n\tdefer ch.notifyM.Unlock()\n\n\tif ch.noNotify {\n\t\tclose(confirm)\n\t} else {\n\t\tch.confirms.Listen(confirm)\n\t}\n\n\treturn confirm\n\n}\n\n/*\nQos controls how many messages or how many bytes the server will try to keep on\nthe network for consumers before receiving delivery acks.  The intent of Qos is\nto make sure the network buffers stay full between the server and client.\n\nWith a prefetch count greater than zero, the server will deliver that many\nmessages to consumers before acknowledgments are received.  The server ignores\nthis option when consumers are started with noAck because no acknowledgments\nare expected or sent.\n\nWith a prefetch size greater than zero, the server will try to keep at least\nthat many bytes of deliveries flushed to the network before receiving\nacknowledgments from the consumers.  This option is ignored when consumers are\nstarted with noAck.\n\nWhen global is true, these Qos settings apply to all existing and future\nconsumers on all channels on the same connection.  When false, the Channel.Qos\nsettings will apply to all existing and future consumers on this channel.\n\nPlease see the RabbitMQ Consumer Prefetch documentation for an explanation of\nhow the global flag is implemented in RabbitMQ, as it differs from the\nAMQP 0.9.1 specification in that global Qos settings are limited in scope to\nchannels, not connections (https://www.rabbitmq.com/consumer-prefetch.html).\n\nTo get round-robin behavior between consumers consuming from the same queue on\ndifferent connections, set the prefetch count to 1, and the next available\nmessage on the server will be delivered to the next available consumer.\n\nIf your consumer work time is reasonably consistent and not much greater\nthan two times your network round trip time, you will see significant\nthroughput improvements starting with a prefetch count of 2 or slightly\ngreater as described by benchmarks on RabbitMQ.\n\nhttp://www.rabbitmq.com/blog/2012/04/25/rabbitmq-performance-measurements-part-2/\n*/\nfunc (ch *Channel) Qos(prefetchCount, prefetchSize int, global bool) error {\n\treturn ch.call(\n\t\t&basicQos{\n\t\t\tPrefetchCount: uint16(prefetchCount),\n\t\t\tPrefetchSize:  uint32(prefetchSize),\n\t\t\tGlobal:        global,\n\t\t},\n\t\t&basicQosOk{},\n\t)\n}\n\n/*\nCancel stops deliveries to the consumer chan established in Channel.Consume and\nidentified by consumer.\n\nOnly use this method to cleanly stop receiving deliveries from the server and\ncleanly shut down the consumer chan identified by this tag.  Using this method\nand waiting for remaining messages to flush from the consumer chan will ensure\nall messages received on the network will be delivered to the receiver of your\nconsumer chan.\n\nContinue consuming from the chan Delivery provided by Channel.Consume until the\nchan closes.\n\nWhen noWait is true, do not wait for the server to acknowledge the cancel.\nOnly use this when you are certain there are no deliveries in flight that\nrequire an acknowledgment, otherwise they will arrive and be dropped in the\nclient without an ack, and will not be redelivered to other consumers.\n\n*/\nfunc (ch *Channel) Cancel(consumer string, noWait bool) error {\n\treq := &basicCancel{\n\t\tConsumerTag: consumer,\n\t\tNoWait:      noWait,\n\t}\n\tres := &basicCancelOk{}\n\n\tif err := ch.call(req, res); err != nil {\n\t\treturn err\n\t}\n\n\tif req.wait() {\n\t\tch.consumers.cancel(res.ConsumerTag)\n\t} else {\n\t\t// Potentially could drop deliveries in flight\n\t\tch.consumers.cancel(consumer)\n\t}\n\n\treturn nil\n}\n\n/*\nQueueDeclare declares a queue to hold messages and deliver to consumers.\nDeclaring creates a queue if it doesn't already exist, or ensures that an\nexisting queue matches the same parameters.\n\nEvery queue declared gets a default binding to the empty exchange \"\" which has\nthe type \"direct\" with the routing key matching the queue's name.  With this\ndefault binding, it is possible to publish messages that route directly to\nthis queue by publishing to \"\" with the routing key of the queue name.\n\n  QueueDeclare(\"alerts\", true, false, false, false, nil)\n  Publish(\"\", \"alerts\", false, false, Publishing{Body: []byte(\"...\")})\n\n  Delivery       Exchange  Key       Queue\n  -----------------------------------------------\n  key: alerts -> \"\"     -> alerts -> alerts\n\nThe queue name may be empty, in which case the server will generate a unique name\nwhich will be returned in the Name field of Queue struct.\n\nDurable and Non-Auto-Deleted queues will survive server restarts and remain\nwhen there are no remaining consumers or bindings.  Persistent publishings will\nbe restored in this queue on server restart.  These queues are only able to be\nbound to durable exchanges.\n\nNon-Durable and Auto-Deleted queues will not be redeclared on server restart\nand will be deleted by the server after a short time when the last consumer is\ncanceled or the last consumer's channel is closed.  Queues with this lifetime\ncan also be deleted normally with QueueDelete.  These durable queues can only\nbe bound to non-durable exchanges.\n\nNon-Durable and Non-Auto-Deleted queues will remain declared as long as the\nserver is running regardless of how many consumers.  This lifetime is useful\nfor temporary topologies that may have long delays between consumer activity.\nThese queues can only be bound to non-durable exchanges.\n\nDurable and Auto-Deleted queues will be restored on server restart, but without\nactive consumers will not survive and be removed.  This Lifetime is unlikely\nto be useful.\n\nExclusive queues are only accessible by the connection that declares them and\nwill be deleted when the connection closes.  Channels on other connections\nwill receive an error when attempting  to declare, bind, consume, purge or\ndelete a queue with the same name.\n\nWhen noWait is true, the queue will assume to be declared on the server.  A\nchannel exception will arrive if the conditions are met for existing queues\nor attempting to modify an existing queue from a different connection.\n\nWhen the error return value is not nil, you can assume the queue could not be\ndeclared with these parameters, and the channel will be closed.\n\n*/\nfunc (ch *Channel) QueueDeclare(name string, durable, autoDelete, exclusive, noWait bool, args Table) (Queue, error) {\n\tif err := args.Validate(); err != nil {\n\t\treturn Queue{}, err\n\t}\n\n\treq := &queueDeclare{\n\t\tQueue:      name,\n\t\tPassive:    false,\n\t\tDurable:    durable,\n\t\tAutoDelete: autoDelete,\n\t\tExclusive:  exclusive,\n\t\tNoWait:     noWait,\n\t\tArguments:  args,\n\t}\n\tres := &queueDeclareOk{}\n\n\tif err := ch.call(req, res); err != nil {\n\t\treturn Queue{}, err\n\t}\n\n\tif req.wait() {\n\t\treturn Queue{\n\t\t\tName:      res.Queue,\n\t\t\tMessages:  int(res.MessageCount),\n\t\t\tConsumers: int(res.ConsumerCount),\n\t\t}, nil\n\t}\n\n\treturn Queue{Name: name}, nil\n}\n\n/*\n\nQueueDeclarePassive is functionally and parametrically equivalent to\nQueueDeclare, except that it sets the \"passive\" attribute to true. A passive\nqueue is assumed by RabbitMQ to already exist, and attempting to connect to a\nnon-existent queue will cause RabbitMQ to throw an exception. This function\ncan be used to test for the existence of a queue.\n\n*/\nfunc (ch *Channel) QueueDeclarePassive(name string, durable, autoDelete, exclusive, noWait bool, args Table) (Queue, error) {\n\tif err := args.Validate(); err != nil {\n\t\treturn Queue{}, err\n\t}\n\n\treq := &queueDeclare{\n\t\tQueue:      name,\n\t\tPassive:    true,\n\t\tDurable:    durable,\n\t\tAutoDelete: autoDelete,\n\t\tExclusive:  exclusive,\n\t\tNoWait:     noWait,\n\t\tArguments:  args,\n\t}\n\tres := &queueDeclareOk{}\n\n\tif err := ch.call(req, res); err != nil {\n\t\treturn Queue{}, err\n\t}\n\n\tif req.wait() {\n\t\treturn Queue{\n\t\t\tName:      res.Queue,\n\t\t\tMessages:  int(res.MessageCount),\n\t\t\tConsumers: int(res.ConsumerCount),\n\t\t}, nil\n\t}\n\n\treturn Queue{Name: name}, nil\n}\n\n/*\nQueueInspect passively declares a queue by name to inspect the current message\ncount and consumer count.\n\nUse this method to check how many messages ready for delivery reside in the queue,\nhow many consumers are receiving deliveries, and whether a queue by this\nname already exists.\n\nIf the queue by this name exists, use Channel.QueueDeclare check if it is\ndeclared with specific parameters.\n\nIf a queue by this name does not exist, an error will be returned and the\nchannel will be closed.\n\n*/\nfunc (ch *Channel) QueueInspect(name string) (Queue, error) {\n\treq := &queueDeclare{\n\t\tQueue:   name,\n\t\tPassive: true,\n\t}\n\tres := &queueDeclareOk{}\n\n\terr := ch.call(req, res)\n\n\tstate := Queue{\n\t\tName:      name,\n\t\tMessages:  int(res.MessageCount),\n\t\tConsumers: int(res.ConsumerCount),\n\t}\n\n\treturn state, err\n}\n\n/*\nQueueBind binds an exchange to a queue so that publishings to the exchange will\nbe routed to the queue when the publishing routing key matches the binding\nrouting key.\n\n  QueueBind(\"pagers\", \"alert\", \"log\", false, nil)\n  QueueBind(\"emails\", \"info\", \"log\", false, nil)\n\n  Delivery       Exchange  Key       Queue\n  -----------------------------------------------\n  key: alert --> log ----> alert --> pagers\n  key: info ---> log ----> info ---> emails\n  key: debug --> log       (none)    (dropped)\n\nIf a binding with the same key and arguments already exists between the\nexchange and queue, the attempt to rebind will be ignored and the existing\nbinding will be retained.\n\nIn the case that multiple bindings may cause the message to be routed to the\nsame queue, the server will only route the publishing once.  This is possible\nwith topic exchanges.\n\n  QueueBind(\"pagers\", \"alert\", \"amq.topic\", false, nil)\n  QueueBind(\"emails\", \"info\", \"amq.topic\", false, nil)\n  QueueBind(\"emails\", \"#\", \"amq.topic\", false, nil) // match everything\n\n  Delivery       Exchange        Key       Queue\n  -----------------------------------------------\n  key: alert --> amq.topic ----> alert --> pagers\n  key: info ---> amq.topic ----> # ------> emails\n                           \\---> info ---/\n  key: debug --> amq.topic ----> # ------> emails\n\nIt is only possible to bind a durable queue to a durable exchange regardless of\nwhether the queue or exchange is auto-deleted.  Bindings between durable queues\nand exchanges will also be restored on server restart.\n\nIf the binding could not complete, an error will be returned and the channel\nwill be closed.\n\nWhen noWait is false and the queue could not be bound, the channel will be\nclosed with an error.\n\n*/\nfunc (ch *Channel) QueueBind(name, key, exchange string, noWait bool, args Table) error {\n\tif err := args.Validate(); err != nil {\n\t\treturn err\n\t}\n\n\treturn ch.call(\n\t\t&queueBind{\n\t\t\tQueue:      name,\n\t\t\tExchange:   exchange,\n\t\t\tRoutingKey: key,\n\t\t\tNoWait:     noWait,\n\t\t\tArguments:  args,\n\t\t},\n\t\t&queueBindOk{},\n\t)\n}\n\n/*\nQueueUnbind removes a binding between an exchange and queue matching the key and\narguments.\n\nIt is possible to send and empty string for the exchange name which means to\nunbind the queue from the default exchange.\n\n*/\nfunc (ch *Channel) QueueUnbind(name, key, exchange string, args Table) error {\n\tif err := args.Validate(); err != nil {\n\t\treturn err\n\t}\n\n\treturn ch.call(\n\t\t&queueUnbind{\n\t\t\tQueue:      name,\n\t\t\tExchange:   exchange,\n\t\t\tRoutingKey: key,\n\t\t\tArguments:  args,\n\t\t},\n\t\t&queueUnbindOk{},\n\t)\n}\n\n/*\nQueuePurge removes all messages from the named queue which are not waiting to\nbe acknowledged.  Messages that have been delivered but have not yet been\nacknowledged will not be removed.\n\nWhen successful, returns the number of messages purged.\n\nIf noWait is true, do not wait for the server response and the number of\nmessages purged will not be meaningful.\n*/\nfunc (ch *Channel) QueuePurge(name string, noWait bool) (int, error) {\n\treq := &queuePurge{\n\t\tQueue:  name,\n\t\tNoWait: noWait,\n\t}\n\tres := &queuePurgeOk{}\n\n\terr := ch.call(req, res)\n\n\treturn int(res.MessageCount), err\n}\n\n/*\nQueueDelete removes the queue from the server including all bindings then\npurges the messages based on server configuration, returning the number of\nmessages purged.\n\nWhen ifUnused is true, the queue will not be deleted if there are any\nconsumers on the queue.  If there are consumers, an error will be returned and\nthe channel will be closed.\n\nWhen ifEmpty is true, the queue will not be deleted if there are any messages\nremaining on the queue.  If there are messages, an error will be returned and\nthe channel will be closed.\n\nWhen noWait is true, the queue will be deleted without waiting for a response\nfrom the server.  The purged message count will not be meaningful. If the queue\ncould not be deleted, a channel exception will be raised and the channel will\nbe closed.\n\n*/\nfunc (ch *Channel) QueueDelete(name string, ifUnused, ifEmpty, noWait bool) (int, error) {\n\treq := &queueDelete{\n\t\tQueue:    name,\n\t\tIfUnused: ifUnused,\n\t\tIfEmpty:  ifEmpty,\n\t\tNoWait:   noWait,\n\t}\n\tres := &queueDeleteOk{}\n\n\terr := ch.call(req, res)\n\n\treturn int(res.MessageCount), err\n}\n\n/*\nConsume immediately starts delivering queued messages.\n\nBegin receiving on the returned chan Delivery before any other operation on the\nConnection or Channel.\n\nContinues deliveries to the returned chan Delivery until Channel.Cancel,\nConnection.Close, Channel.Close, or an AMQP exception occurs.  Consumers must\nrange over the chan to ensure all deliveries are received.  Unreceived\ndeliveries will block all methods on the same connection.\n\nAll deliveries in AMQP must be acknowledged.  It is expected of the consumer to\ncall Delivery.Ack after it has successfully processed the delivery.  If the\nconsumer is cancelled or the channel or connection is closed any unacknowledged\ndeliveries will be requeued at the end of the same queue.\n\nThe consumer is identified by a string that is unique and scoped for all\nconsumers on this channel.  If you wish to eventually cancel the consumer, use\nthe same non-empty identifier in Channel.Cancel.  An empty string will cause\nthe library to generate a unique identity.  The consumer identity will be\nincluded in every Delivery in the ConsumerTag field\n\nWhen autoAck (also known as noAck) is true, the server will acknowledge\ndeliveries to this consumer prior to writing the delivery to the network.  When\nautoAck is true, the consumer should not call Delivery.Ack. Automatically\nacknowledging deliveries means that some deliveries may get lost if the\nconsumer is unable to process them after the server delivers them.\nSee http://www.rabbitmq.com/confirms.html for more details.\n\nWhen exclusive is true, the server will ensure that this is the sole consumer\nfrom this queue. When exclusive is false, the server will fairly distribute\ndeliveries across multiple consumers.\n\nThe noLocal flag is not supported by RabbitMQ.\n\nIt's advisable to use separate connections for\nChannel.Publish and Channel.Consume so not to have TCP pushback on publishing\naffect the ability to consume messages, so this parameter is here mostly for\ncompleteness.\n\nWhen noWait is true, do not wait for the server to confirm the request and\nimmediately begin deliveries.  If it is not possible to consume, a channel\nexception will be raised and the channel will be closed.\n\nOptional arguments can be provided that have specific semantics for the queue\nor server.\n\nInflight messages, limited by Channel.Qos will be buffered until received from\nthe returned chan.\n\nWhen the Channel or Connection is closed, all buffered and inflight messages will\nbe dropped.\n\nWhen the consumer tag is cancelled, all inflight messages will be delivered until\nthe returned chan is closed.\n\n*/\nfunc (ch *Channel) Consume(queue, consumer string, autoAck, exclusive, noLocal, noWait bool, args Table) (<-chan Delivery, error) {\n\t// When we return from ch.call, there may be a delivery already for the\n\t// consumer that hasn't been added to the consumer hash yet.  Because of\n\t// this, we never rely on the server picking a consumer tag for us.\n\n\tif err := args.Validate(); err != nil {\n\t\treturn nil, err\n\t}\n\n\tif consumer == \"\" {\n\t\tconsumer = uniqueConsumerTag()\n\t}\n\n\treq := &basicConsume{\n\t\tQueue:       queue,\n\t\tConsumerTag: consumer,\n\t\tNoLocal:     noLocal,\n\t\tNoAck:       autoAck,\n\t\tExclusive:   exclusive,\n\t\tNoWait:      noWait,\n\t\tArguments:   args,\n\t}\n\tres := &basicConsumeOk{}\n\n\tdeliveries := make(chan Delivery)\n\n\tch.consumers.add(consumer, deliveries)\n\n\tif err := ch.call(req, res); err != nil {\n\t\tch.consumers.cancel(consumer)\n\t\treturn nil, err\n\t}\n\n\treturn (<-chan Delivery)(deliveries), nil\n}\n\n/*\nExchangeDeclare declares an exchange on the server. If the exchange does not\nalready exist, the server will create it.  If the exchange exists, the server\nverifies that it is of the provided type, durability and auto-delete flags.\n\nErrors returned from this method will close the channel.\n\nExchange names starting with \"amq.\" are reserved for pre-declared and\nstandardized exchanges. The client MAY declare an exchange starting with\n\"amq.\" if the passive option is set, or the exchange already exists.  Names can\nconsist of a non-empty sequence of letters, digits, hyphen, underscore,\nperiod, or colon.\n\nEach exchange belongs to one of a set of exchange kinds/types implemented by\nthe server. The exchange types define the functionality of the exchange - i.e.\nhow messages are routed through it. Once an exchange is declared, its type\ncannot be changed.  The common types are \"direct\", \"fanout\", \"topic\" and\n\"headers\".\n\nDurable and Non-Auto-Deleted exchanges will survive server restarts and remain\ndeclared when there are no remaining bindings.  This is the best lifetime for\nlong-lived exchange configurations like stable routes and default exchanges.\n\nNon-Durable and Auto-Deleted exchanges will be deleted when there are no\nremaining bindings and not restored on server restart.  This lifetime is\nuseful for temporary topologies that should not pollute the virtual host on\nfailure or after the consumers have completed.\n\nNon-Durable and Non-Auto-deleted exchanges will remain as long as the server is\nrunning including when there are no remaining bindings.  This is useful for\ntemporary topologies that may have long delays between bindings.\n\nDurable and Auto-Deleted exchanges will survive server restarts and will be\nremoved before and after server restarts when there are no remaining bindings.\nThese exchanges are useful for robust temporary topologies or when you require\nbinding durable queues to auto-deleted exchanges.\n\nNote: RabbitMQ declares the default exchange types like 'amq.fanout' as\ndurable, so queues that bind to these pre-declared exchanges must also be\ndurable.\n\nExchanges declared as `internal` do not accept accept publishings. Internal\nexchanges are useful when you wish to implement inter-exchange topologies\nthat should not be exposed to users of the broker.\n\nWhen noWait is true, declare without waiting for a confirmation from the server.\nThe channel may be closed as a result of an error.  Add a NotifyClose listener\nto respond to any exceptions.\n\nOptional amqp.Table of arguments that are specific to the server's implementation of\nthe exchange can be sent for exchange types that require extra parameters.\n*/\nfunc (ch *Channel) ExchangeDeclare(name, kind string, durable, autoDelete, internal, noWait bool, args Table) error {\n\tif err := args.Validate(); err != nil {\n\t\treturn err\n\t}\n\n\treturn ch.call(\n\t\t&exchangeDeclare{\n\t\t\tExchange:   name,\n\t\t\tType:       kind,\n\t\t\tPassive:    false,\n\t\t\tDurable:    durable,\n\t\t\tAutoDelete: autoDelete,\n\t\t\tInternal:   internal,\n\t\t\tNoWait:     noWait,\n\t\t\tArguments:  args,\n\t\t},\n\t\t&exchangeDeclareOk{},\n\t)\n}\n\n/*\n\nExchangeDeclarePassive is functionally and parametrically equivalent to\nExchangeDeclare, except that it sets the \"passive\" attribute to true. A passive\nexchange is assumed by RabbitMQ to already exist, and attempting to connect to a\nnon-existent exchange will cause RabbitMQ to throw an exception. This function\ncan be used to detect the existence of an exchange.\n\n*/\nfunc (ch *Channel) ExchangeDeclarePassive(name, kind string, durable, autoDelete, internal, noWait bool, args Table) error {\n\tif err := args.Validate(); err != nil {\n\t\treturn err\n\t}\n\n\treturn ch.call(\n\t\t&exchangeDeclare{\n\t\t\tExchange:   name,\n\t\t\tType:       kind,\n\t\t\tPassive:    true,\n\t\t\tDurable:    durable,\n\t\t\tAutoDelete: autoDelete,\n\t\t\tInternal:   internal,\n\t\t\tNoWait:     noWait,\n\t\t\tArguments:  args,\n\t\t},\n\t\t&exchangeDeclareOk{},\n\t)\n}\n\n/*\nExchangeDelete removes the named exchange from the server. When an exchange is\ndeleted all queue bindings on the exchange are also deleted.  If this exchange\ndoes not exist, the channel will be closed with an error.\n\nWhen ifUnused is true, the server will only delete the exchange if it has no queue\nbindings.  If the exchange has queue bindings the server does not delete it\nbut close the channel with an exception instead.  Set this to true if you are\nnot the sole owner of the exchange.\n\nWhen noWait is true, do not wait for a server confirmation that the exchange has\nbeen deleted.  Failing to delete the channel could close the channel.  Add a\nNotifyClose listener to respond to these channel exceptions.\n*/\nfunc (ch *Channel) ExchangeDelete(name string, ifUnused, noWait bool) error {\n\treturn ch.call(\n\t\t&exchangeDelete{\n\t\t\tExchange: name,\n\t\t\tIfUnused: ifUnused,\n\t\t\tNoWait:   noWait,\n\t\t},\n\t\t&exchangeDeleteOk{},\n\t)\n}\n\n/*\nExchangeBind binds an exchange to another exchange to create inter-exchange\nrouting topologies on the server.  This can decouple the private topology and\nrouting exchanges from exchanges intended solely for publishing endpoints.\n\nBinding two exchanges with identical arguments will not create duplicate\nbindings.\n\nBinding one exchange to another with multiple bindings will only deliver a\nmessage once.  For example if you bind your exchange to `amq.fanout` with two\ndifferent binding keys, only a single message will be delivered to your\nexchange even though multiple bindings will match.\n\nGiven a message delivered to the source exchange, the message will be forwarded\nto the destination exchange when the routing key is matched.\n\n  ExchangeBind(\"sell\", \"MSFT\", \"trade\", false, nil)\n  ExchangeBind(\"buy\", \"AAPL\", \"trade\", false, nil)\n\n  Delivery       Source      Key      Destination\n  example        exchange             exchange\n  -----------------------------------------------\n  key: AAPL  --> trade ----> MSFT     sell\n                       \\---> AAPL --> buy\n\nWhen noWait is true, do not wait for the server to confirm the binding.  If any\nerror occurs the channel will be closed.  Add a listener to NotifyClose to\nhandle these errors.\n\nOptional arguments specific to the exchanges bound can also be specified.\n*/\nfunc (ch *Channel) ExchangeBind(destination, key, source string, noWait bool, args Table) error {\n\tif err := args.Validate(); err != nil {\n\t\treturn err\n\t}\n\n\treturn ch.call(\n\t\t&exchangeBind{\n\t\t\tDestination: destination,\n\t\t\tSource:      source,\n\t\t\tRoutingKey:  key,\n\t\t\tNoWait:      noWait,\n\t\t\tArguments:   args,\n\t\t},\n\t\t&exchangeBindOk{},\n\t)\n}\n\n/*\nExchangeUnbind unbinds the destination exchange from the source exchange on the\nserver by removing the routing key between them.  This is the inverse of\nExchangeBind.  If the binding does not currently exist, an error will be\nreturned.\n\nWhen noWait is true, do not wait for the server to confirm the deletion of the\nbinding.  If any error occurs the channel will be closed.  Add a listener to\nNotifyClose to handle these errors.\n\nOptional arguments that are specific to the type of exchanges bound can also be\nprovided.  These must match the same arguments specified in ExchangeBind to\nidentify the binding.\n*/\nfunc (ch *Channel) ExchangeUnbind(destination, key, source string, noWait bool, args Table) error {\n\tif err := args.Validate(); err != nil {\n\t\treturn err\n\t}\n\n\treturn ch.call(\n\t\t&exchangeUnbind{\n\t\t\tDestination: destination,\n\t\t\tSource:      source,\n\t\t\tRoutingKey:  key,\n\t\t\tNoWait:      noWait,\n\t\t\tArguments:   args,\n\t\t},\n\t\t&exchangeUnbindOk{},\n\t)\n}\n\n/*\nPublish sends a Publishing from the client to an exchange on the server.\n\nWhen you want a single message to be delivered to a single queue, you can\npublish to the default exchange with the routingKey of the queue name.  This is\nbecause every declared queue gets an implicit route to the default exchange.\n\nSince publishings are asynchronous, any undeliverable message will get returned\nby the server.  Add a listener with Channel.NotifyReturn to handle any\nundeliverable message when calling publish with either the mandatory or\nimmediate parameters as true.\n\nPublishings can be undeliverable when the mandatory flag is true and no queue is\nbound that matches the routing key, or when the immediate flag is true and no\nconsumer on the matched queue is ready to accept the delivery.\n\nThis can return an error when the channel, connection or socket is closed.  The\nerror or lack of an error does not indicate whether the server has received this\npublishing.\n\nIt is possible for publishing to not reach the broker if the underlying socket\nis shut down without pending publishing packets being flushed from the kernel\nbuffers.  The easy way of making it probable that all publishings reach the\nserver is to always call Connection.Close before terminating your publishing\napplication.  The way to ensure that all publishings reach the server is to add\na listener to Channel.NotifyPublish and put the channel in confirm mode with\nChannel.Confirm.  Publishing delivery tags and their corresponding\nconfirmations start at 1.  Exit when all publishings are confirmed.\n\nWhen Publish does not return an error and the channel is in confirm mode, the\ninternal counter for DeliveryTags with the first confirmation starts at 1.\n\n*/\nfunc (ch *Channel) Publish(exchange, key string, mandatory, immediate bool, msg Publishing) error {\n\tif err := msg.Headers.Validate(); err != nil {\n\t\treturn err\n\t}\n\n\tch.m.Lock()\n\tdefer ch.m.Unlock()\n\n\tif err := ch.send(&basicPublish{\n\t\tExchange:   exchange,\n\t\tRoutingKey: key,\n\t\tMandatory:  mandatory,\n\t\tImmediate:  immediate,\n\t\tBody:       msg.Body,\n\t\tProperties: properties{\n\t\t\tHeaders:         msg.Headers,\n\t\t\tContentType:     msg.ContentType,\n\t\t\tContentEncoding: msg.ContentEncoding,\n\t\t\tDeliveryMode:    msg.DeliveryMode,\n\t\t\tPriority:        msg.Priority,\n\t\t\tCorrelationId:   msg.CorrelationId,\n\t\t\tReplyTo:         msg.ReplyTo,\n\t\t\tExpiration:      msg.Expiration,\n\t\t\tMessageId:       msg.MessageId,\n\t\t\tTimestamp:       msg.Timestamp,\n\t\t\tType:            msg.Type,\n\t\t\tUserId:          msg.UserId,\n\t\t\tAppId:           msg.AppId,\n\t\t},\n\t}); err != nil {\n\t\treturn err\n\t}\n\n\tif ch.confirming {\n\t\tch.confirms.Publish()\n\t}\n\n\treturn nil\n}\n\n/*\nGet synchronously receives a single Delivery from the head of a queue from the\nserver to the client.  In almost all cases, using Channel.Consume will be\npreferred.\n\nIf there was a delivery waiting on the queue and that delivery was received, the\nsecond return value will be true.  If there was no delivery waiting or an error\noccurred, the ok bool will be false.\n\nAll deliveries must be acknowledged including those from Channel.Get.  Call\nDelivery.Ack on the returned delivery when you have fully processed this\ndelivery.\n\nWhen autoAck is true, the server will automatically acknowledge this message so\nyou don't have to.  But if you are unable to fully process this message before\nthe channel or connection is closed, the message will not get requeued.\n\n*/\nfunc (ch *Channel) Get(queue string, autoAck bool) (msg Delivery, ok bool, err error) {\n\treq := &basicGet{Queue: queue, NoAck: autoAck}\n\tres := &basicGetOk{}\n\tempty := &basicGetEmpty{}\n\n\tif err := ch.call(req, res, empty); err != nil {\n\t\treturn Delivery{}, false, err\n\t}\n\n\tif res.DeliveryTag > 0 {\n\t\treturn *(newDelivery(ch, res)), true, nil\n\t}\n\n\treturn Delivery{}, false, nil\n}\n\n/*\nTx puts the channel into transaction mode on the server.  All publishings and\nacknowledgments following this method will be atomically committed or rolled\nback for a single queue.  Call either Channel.TxCommit or Channel.TxRollback to\nleave a this transaction and immediately start a new transaction.\n\nThe atomicity across multiple queues is not defined as queue declarations and\nbindings are not included in the transaction.\n\nThe behavior of publishings that are delivered as mandatory or immediate while\nthe channel is in a transaction is not defined.\n\nOnce a channel has been put into transaction mode, it cannot be taken out of\ntransaction mode.  Use a different channel for non-transactional semantics.\n\n*/\nfunc (ch *Channel) Tx() error {\n\treturn ch.call(\n\t\t&txSelect{},\n\t\t&txSelectOk{},\n\t)\n}\n\n/*\nTxCommit atomically commits all publishings and acknowledgments for a single\nqueue and immediately start a new transaction.\n\nCalling this method without having called Channel.Tx is an error.\n\n*/\nfunc (ch *Channel) TxCommit() error {\n\treturn ch.call(\n\t\t&txCommit{},\n\t\t&txCommitOk{},\n\t)\n}\n\n/*\nTxRollback atomically rolls back all publishings and acknowledgments for a\nsingle queue and immediately start a new transaction.\n\nCalling this method without having called Channel.Tx is an error.\n\n*/\nfunc (ch *Channel) TxRollback() error {\n\treturn ch.call(\n\t\t&txRollback{},\n\t\t&txRollbackOk{},\n\t)\n}\n\n/*\nFlow pauses the delivery of messages to consumers on this channel.  Channels\nare opened with flow control active, to open a channel with paused\ndeliveries immediately call this method with `false` after calling\nConnection.Channel.\n\nWhen active is `false`, this method asks the server to temporarily pause deliveries\nuntil called again with active as `true`.\n\nChannel.Get methods will not be affected by flow control.\n\nThis method is not intended to act as window control.  Use Channel.Qos to limit\nthe number of unacknowledged messages or bytes in flight instead.\n\nThe server may also send us flow methods to throttle our publishings.  A well\nbehaving publishing client should add a listener with Channel.NotifyFlow and\npause its publishings when `false` is sent on that channel.\n\nNote: RabbitMQ prefers to use TCP push back to control flow for all channels on\na connection, so under high volume scenarios, it's wise to open separate\nConnections for publishings and deliveries.\n\n*/\nfunc (ch *Channel) Flow(active bool) error {\n\treturn ch.call(\n\t\t&channelFlow{Active: active},\n\t\t&channelFlowOk{},\n\t)\n}\n\n/*\nConfirm puts this channel into confirm mode so that the client can ensure all\npublishings have successfully been received by the server.  After entering this\nmode, the server will send a basic.ack or basic.nack message with the deliver\ntag set to a 1 based incremental index corresponding to every publishing\nreceived after the this method returns.\n\nAdd a listener to Channel.NotifyPublish to respond to the Confirmations. If\nChannel.NotifyPublish is not called, the Confirmations will be silently\nignored.\n\nThe order of acknowledgments is not bound to the order of deliveries.\n\nAck and Nack confirmations will arrive at some point in the future.\n\nUnroutable mandatory or immediate messages are acknowledged immediately after\nany Channel.NotifyReturn listeners have been notified.  Other messages are\nacknowledged when all queues that should have the message routed to them have\neither received acknowledgment of delivery or have enqueued the message,\npersisting the message if necessary.\n\nWhen noWait is true, the client will not wait for a response.  A channel\nexception could occur if the server does not support this method.\n\n*/\nfunc (ch *Channel) Confirm(noWait bool) error {\n\tif err := ch.call(\n\t\t&confirmSelect{Nowait: noWait},\n\t\t&confirmSelectOk{},\n\t); err != nil {\n\t\treturn err\n\t}\n\n\tch.confirmM.Lock()\n\tch.confirming = true\n\tch.confirmM.Unlock()\n\n\treturn nil\n}\n\n/*\nRecover redelivers all unacknowledged deliveries on this channel.\n\nWhen requeue is false, messages will be redelivered to the original consumer.\n\nWhen requeue is true, messages will be redelivered to any available consumer,\npotentially including the original.\n\nIf the deliveries cannot be recovered, an error will be returned and the channel\nwill be closed.\n\nNote: this method is not implemented on RabbitMQ, use Delivery.Nack instead\n*/\nfunc (ch *Channel) Recover(requeue bool) error {\n\treturn ch.call(\n\t\t&basicRecover{Requeue: requeue},\n\t\t&basicRecoverOk{},\n\t)\n}\n\n/*\nAck acknowledges a delivery by its delivery tag when having been consumed with\nChannel.Consume or Channel.Get.\n\nAck acknowledges all message received prior to the delivery tag when multiple\nis true.\n\nSee also Delivery.Ack\n*/\nfunc (ch *Channel) Ack(tag uint64, multiple bool) error {\n\tch.m.Lock()\n\tdefer ch.m.Unlock()\n\n\treturn ch.send(&basicAck{\n\t\tDeliveryTag: tag,\n\t\tMultiple:    multiple,\n\t})\n}\n\n/*\nNack negatively acknowledges a delivery by its delivery tag.  Prefer this\nmethod to notify the server that you were not able to process this delivery and\nit must be redelivered or dropped.\n\nSee also Delivery.Nack\n*/\nfunc (ch *Channel) Nack(tag uint64, multiple bool, requeue bool) error {\n\tch.m.Lock()\n\tdefer ch.m.Unlock()\n\n\treturn ch.send(&basicNack{\n\t\tDeliveryTag: tag,\n\t\tMultiple:    multiple,\n\t\tRequeue:     requeue,\n\t})\n}\n\n/*\nReject negatively acknowledges a delivery by its delivery tag.  Prefer Nack\nover Reject when communicating with a RabbitMQ server because you can Nack\nmultiple messages, reducing the amount of protocol messages to exchange.\n\nSee also Delivery.Reject\n*/\nfunc (ch *Channel) Reject(tag uint64, requeue bool) error {\n\tch.m.Lock()\n\tdefer ch.m.Unlock()\n\n\treturn ch.send(&basicReject{\n\t\tDeliveryTag: tag,\n\t\tRequeue:     requeue,\n\t})\n}\n"
        },
        {
          "name": "client_test.go",
          "type": "blob",
          "size": 16.4150390625,
          "content": "// Copyright (c) 2012, Sean Treadway, SoundCloud Ltd.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n// Source code and contact info at http://github.com/streadway/amqp\n\npackage amqp\n\nimport (\n\t\"bytes\"\n\t\"io\"\n\t\"reflect\"\n\t\"testing\"\n\t\"time\"\n)\n\ntype server struct {\n\t*testing.T\n\tr reader             // framer <- client\n\tw writer             // framer -> client\n\tS io.ReadWriteCloser // Server IO\n\tC io.ReadWriteCloser // Client IO\n\n\t// captured client frames\n\tstart connectionStartOk\n\ttune  connectionTuneOk\n}\n\nfunc defaultConfig() Config {\n\treturn Config{\n\t\tSASL:   []Authentication{&PlainAuth{\"guest\", \"guest\"}},\n\t\tVhost:  \"/\",\n\t\tLocale: defaultLocale,\n\t}\n}\n\nfunc newServer(t *testing.T, serverIO, clientIO io.ReadWriteCloser) *server {\n\treturn &server{\n\t\tT: t,\n\t\tr: reader{serverIO},\n\t\tw: writer{serverIO},\n\t\tS: serverIO,\n\t\tC: clientIO,\n\t}\n}\n\nfunc newSession(t *testing.T) (io.ReadWriteCloser, *server) {\n\trs, wc := io.Pipe()\n\trc, ws := io.Pipe()\n\n\trws := &logIO{t, \"server\", pipe{rs, ws}}\n\trwc := &logIO{t, \"client\", pipe{rc, wc}}\n\n\treturn rwc, newServer(t, rws, rwc)\n}\n\nfunc (t *server) expectBytes(b []byte) {\n\tin := make([]byte, len(b))\n\tif _, err := io.ReadFull(t.S, in); err != nil {\n\t\tt.Fatalf(\"io error expecting bytes: %v\", err)\n\t}\n\n\tif bytes.Compare(b, in) != 0 {\n\t\tt.Fatalf(\"failed bytes: expected: %s got: %s\", string(b), string(in))\n\t}\n}\n\nfunc (t *server) send(channel int, m message) {\n\tdefer time.AfterFunc(time.Second, func() { panic(\"send deadlock\") }).Stop()\n\n\tif msg, ok := m.(messageWithContent); ok {\n\t\tprops, body := msg.getContent()\n\t\tclass, _ := msg.id()\n\t\tt.w.WriteFrame(&methodFrame{\n\t\t\tChannelId: uint16(channel),\n\t\t\tMethod:    msg,\n\t\t})\n\t\tt.w.WriteFrame(&headerFrame{\n\t\t\tChannelId:  uint16(channel),\n\t\t\tClassId:    class,\n\t\t\tSize:       uint64(len(body)),\n\t\t\tProperties: props,\n\t\t})\n\t\tt.w.WriteFrame(&bodyFrame{\n\t\t\tChannelId: uint16(channel),\n\t\t\tBody:      body,\n\t\t})\n\t} else {\n\t\tt.w.WriteFrame(&methodFrame{\n\t\t\tChannelId: uint16(channel),\n\t\t\tMethod:    m,\n\t\t})\n\t}\n}\n\n// drops all but method frames expected on the given channel\nfunc (t *server) recv(channel int, m message) message {\n\tdefer time.AfterFunc(time.Second, func() { panic(\"recv deadlock\") }).Stop()\n\n\tvar remaining int\n\tvar header *headerFrame\n\tvar body []byte\n\n\tfor {\n\t\tframe, err := t.r.ReadFrame()\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"frame err, read: %s\", err)\n\t\t}\n\n\t\tif frame.channel() != uint16(channel) {\n\t\t\tt.Fatalf(\"expected frame on channel %d, got channel %d\", channel, frame.channel())\n\t\t}\n\n\t\tswitch f := frame.(type) {\n\t\tcase *heartbeatFrame:\n\t\t\t// drop\n\n\t\tcase *headerFrame:\n\t\t\t// start content state\n\t\t\theader = f\n\t\t\tremaining = int(header.Size)\n\t\t\tif remaining == 0 {\n\t\t\t\tm.(messageWithContent).setContent(header.Properties, nil)\n\t\t\t\treturn m\n\t\t\t}\n\n\t\tcase *bodyFrame:\n\t\t\t// continue until terminated\n\t\t\tbody = append(body, f.Body...)\n\t\t\tremaining -= len(f.Body)\n\t\t\tif remaining <= 0 {\n\t\t\t\tm.(messageWithContent).setContent(header.Properties, body)\n\t\t\t\treturn m\n\t\t\t}\n\n\t\tcase *methodFrame:\n\t\t\tif reflect.TypeOf(m) == reflect.TypeOf(f.Method) {\n\t\t\t\twantv := reflect.ValueOf(m).Elem()\n\t\t\t\thavev := reflect.ValueOf(f.Method).Elem()\n\t\t\t\twantv.Set(havev)\n\t\t\t\tif _, ok := m.(messageWithContent); !ok {\n\t\t\t\t\treturn m\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tt.Fatalf(\"expected method type: %T, got: %T\", m, f.Method)\n\t\t\t}\n\n\t\tdefault:\n\t\t\tt.Fatalf(\"unexpected frame: %+v\", f)\n\t\t}\n\t}\n}\n\nfunc (t *server) expectAMQP() {\n\tt.expectBytes([]byte{'A', 'M', 'Q', 'P', 0, 0, 9, 1})\n}\n\nfunc (t *server) connectionStart() {\n\tt.send(0, &connectionStart{\n\t\tVersionMajor: 0,\n\t\tVersionMinor: 9,\n\t\tMechanisms:   \"PLAIN\",\n\t\tLocales:      \"en_US\",\n\t})\n\n\tt.recv(0, &t.start)\n}\n\nfunc (t *server) connectionTune() {\n\tt.send(0, &connectionTune{\n\t\tChannelMax: 11,\n\t\tFrameMax:   20000,\n\t\tHeartbeat:  10,\n\t})\n\n\tt.recv(0, &t.tune)\n}\n\nfunc (t *server) connectionOpen() {\n\tt.expectAMQP()\n\tt.connectionStart()\n\tt.connectionTune()\n\n\tt.recv(0, &connectionOpen{})\n\tt.send(0, &connectionOpenOk{})\n}\n\nfunc (t *server) connectionClose() {\n\tt.recv(0, &connectionClose{})\n\tt.send(0, &connectionCloseOk{})\n}\n\nfunc (t *server) channelOpen(id int) {\n\tt.recv(id, &channelOpen{})\n\tt.send(id, &channelOpenOk{})\n}\n\nfunc TestDefaultClientProperties(t *testing.T) {\n\trwc, srv := newSession(t)\n\n\tgo func() {\n\t\tsrv.connectionOpen()\n\t\trwc.Close()\n\t}()\n\n\tif c, err := Open(rwc, defaultConfig()); err != nil {\n\t\tt.Fatalf(\"could not create connection: %v (%s)\", c, err)\n\t}\n\n\tif want, got := defaultProduct, srv.start.ClientProperties[\"product\"]; want != got {\n\t\tt.Errorf(\"expected product %s got: %s\", want, got)\n\t}\n\n\tif want, got := defaultVersion, srv.start.ClientProperties[\"version\"]; want != got {\n\t\tt.Errorf(\"expected version %s got: %s\", want, got)\n\t}\n\n\tif want, got := defaultLocale, srv.start.Locale; want != got {\n\t\tt.Errorf(\"expected locale %s got: %s\", want, got)\n\t}\n}\n\nfunc TestCustomClientProperties(t *testing.T) {\n\trwc, srv := newSession(t)\n\n\tconfig := defaultConfig()\n\tconfig.Properties = Table{\n\t\t\"product\": \"foo\",\n\t\t\"version\": \"1.0\",\n\t}\n\n\tgo func() {\n\t\tsrv.connectionOpen()\n\t\trwc.Close()\n\t}()\n\n\tif c, err := Open(rwc, config); err != nil {\n\t\tt.Fatalf(\"could not create connection: %v (%s)\", c, err)\n\t}\n\n\tif want, got := config.Properties[\"product\"], srv.start.ClientProperties[\"product\"]; want != got {\n\t\tt.Errorf(\"expected product %s got: %s\", want, got)\n\t}\n\n\tif want, got := config.Properties[\"version\"], srv.start.ClientProperties[\"version\"]; want != got {\n\t\tt.Errorf(\"expected version %s got: %s\", want, got)\n\t}\n}\n\nfunc TestOpen(t *testing.T) {\n\trwc, srv := newSession(t)\n\tgo func() {\n\t\tsrv.connectionOpen()\n\t\trwc.Close()\n\t}()\n\n\tif c, err := Open(rwc, defaultConfig()); err != nil {\n\t\tt.Fatalf(\"could not create connection: %v (%s)\", c, err)\n\t}\n}\n\nfunc TestChannelOpen(t *testing.T) {\n\trwc, srv := newSession(t)\n\n\tgo func() {\n\t\tsrv.connectionOpen()\n\t\tsrv.channelOpen(1)\n\n\t\trwc.Close()\n\t}()\n\n\tc, err := Open(rwc, defaultConfig())\n\tif err != nil {\n\t\tt.Fatalf(\"could not create connection: %v (%s)\", c, err)\n\t}\n\n\tch, err := c.Channel()\n\tif err != nil {\n\t\tt.Fatalf(\"could not open channel: %v (%s)\", ch, err)\n\t}\n}\n\nfunc TestOpenFailedSASLUnsupportedMechanisms(t *testing.T) {\n\trwc, srv := newSession(t)\n\n\tgo func() {\n\t\tsrv.expectAMQP()\n\t\tsrv.send(0, &connectionStart{\n\t\t\tVersionMajor: 0,\n\t\t\tVersionMinor: 9,\n\t\t\tMechanisms:   \"KERBEROS NTLM\",\n\t\t\tLocales:      \"en_US\",\n\t\t})\n\t}()\n\n\tc, err := Open(rwc, defaultConfig())\n\tif err != ErrSASL {\n\t\tt.Fatalf(\"expected ErrSASL got: %+v on %+v\", err, c)\n\t}\n}\n\nfunc TestOpenFailedCredentials(t *testing.T) {\n\trwc, srv := newSession(t)\n\n\tgo func() {\n\t\tsrv.expectAMQP()\n\t\tsrv.connectionStart()\n\t\t// Now kill/timeout the connection indicating bad auth\n\t\trwc.Close()\n\t}()\n\n\tc, err := Open(rwc, defaultConfig())\n\tif err != ErrCredentials {\n\t\tt.Fatalf(\"expected ErrCredentials got: %+v on %+v\", err, c)\n\t}\n}\n\nfunc TestOpenFailedVhost(t *testing.T) {\n\trwc, srv := newSession(t)\n\n\tgo func() {\n\t\tsrv.expectAMQP()\n\t\tsrv.connectionStart()\n\t\tsrv.connectionTune()\n\t\tsrv.recv(0, &connectionOpen{})\n\n\t\t// Now kill/timeout the connection on bad Vhost\n\t\trwc.Close()\n\t}()\n\n\tc, err := Open(rwc, defaultConfig())\n\tif err != ErrVhost {\n\t\tt.Fatalf(\"expected ErrVhost got: %+v on %+v\", err, c)\n\t}\n}\n\nfunc TestConfirmMultipleOrdersDeliveryTags(t *testing.T) {\n\trwc, srv := newSession(t)\n\tdefer rwc.Close()\n\n\tgo func() {\n\t\tsrv.connectionOpen()\n\t\tsrv.channelOpen(1)\n\n\t\tsrv.recv(1, &confirmSelect{})\n\t\tsrv.send(1, &confirmSelectOk{})\n\n\t\tsrv.recv(1, &basicPublish{})\n\t\tsrv.recv(1, &basicPublish{})\n\t\tsrv.recv(1, &basicPublish{})\n\t\tsrv.recv(1, &basicPublish{})\n\n\t\t// Single tag, plus multiple, should produce\n\t\t// 2, 1, 3, 4\n\t\tsrv.send(1, &basicAck{DeliveryTag: 2})\n\t\tsrv.send(1, &basicAck{DeliveryTag: 1})\n\t\tsrv.send(1, &basicAck{DeliveryTag: 4, Multiple: true})\n\n\t\tsrv.recv(1, &basicPublish{})\n\t\tsrv.recv(1, &basicPublish{})\n\t\tsrv.recv(1, &basicPublish{})\n\t\tsrv.recv(1, &basicPublish{})\n\n\t\t// And some more, but in reverse order, multiple then one\n\t\t// 5, 6, 7, 8\n\t\tsrv.send(1, &basicAck{DeliveryTag: 6, Multiple: true})\n\t\tsrv.send(1, &basicAck{DeliveryTag: 8})\n\t\tsrv.send(1, &basicAck{DeliveryTag: 7})\n\t}()\n\n\tc, err := Open(rwc, defaultConfig())\n\tif err != nil {\n\t\tt.Fatalf(\"could not create connection: %v (%s)\", c, err)\n\t}\n\n\tch, err := c.Channel()\n\tif err != nil {\n\t\tt.Fatalf(\"could not open channel: %v (%s)\", ch, err)\n\t}\n\n\tconfirm := ch.NotifyPublish(make(chan Confirmation))\n\n\tch.Confirm(false)\n\n\tgo func() {\n\t\tch.Publish(\"\", \"q\", false, false, Publishing{Body: []byte(\"pub 1\")})\n\t\tch.Publish(\"\", \"q\", false, false, Publishing{Body: []byte(\"pub 2\")})\n\t\tch.Publish(\"\", \"q\", false, false, Publishing{Body: []byte(\"pub 3\")})\n\t\tch.Publish(\"\", \"q\", false, false, Publishing{Body: []byte(\"pub 4\")})\n\t}()\n\n\t// received out of order, consumed in order\n\tfor i, tag := range []uint64{1, 2, 3, 4} {\n\t\tif ack := <-confirm; tag != ack.DeliveryTag {\n\t\t\tt.Fatalf(\"failed ack, expected ack#%d to be %d, got %d\", i, tag, ack.DeliveryTag)\n\t\t}\n\t}\n\n\tgo func() {\n\t\tch.Publish(\"\", \"q\", false, false, Publishing{Body: []byte(\"pub 5\")})\n\t\tch.Publish(\"\", \"q\", false, false, Publishing{Body: []byte(\"pub 6\")})\n\t\tch.Publish(\"\", \"q\", false, false, Publishing{Body: []byte(\"pub 7\")})\n\t\tch.Publish(\"\", \"q\", false, false, Publishing{Body: []byte(\"pub 8\")})\n\t}()\n\n\tfor i, tag := range []uint64{5, 6, 7, 8} {\n\t\tif ack := <-confirm; tag != ack.DeliveryTag {\n\t\t\tt.Fatalf(\"failed ack, expected ack#%d to be %d, got %d\", i, tag, ack.DeliveryTag)\n\t\t}\n\t}\n\n}\n\nfunc TestNotifyClosesReusedPublisherConfirmChan(t *testing.T) {\n\trwc, srv := newSession(t)\n\n\tgo func() {\n\t\tsrv.connectionOpen()\n\t\tsrv.channelOpen(1)\n\n\t\tsrv.recv(1, &confirmSelect{})\n\t\tsrv.send(1, &confirmSelectOk{})\n\n\t\tsrv.recv(0, &connectionClose{})\n\t\tsrv.send(0, &connectionCloseOk{})\n\t}()\n\n\tc, err := Open(rwc, defaultConfig())\n\tif err != nil {\n\t\tt.Fatalf(\"could not create connection: %v (%s)\", c, err)\n\t}\n\n\tch, err := c.Channel()\n\tif err != nil {\n\t\tt.Fatalf(\"could not open channel: %v (%s)\", ch, err)\n\t}\n\n\tackAndNack := make(chan uint64)\n\tch.NotifyConfirm(ackAndNack, ackAndNack)\n\n\tif err := ch.Confirm(false); err != nil {\n\t\tt.Fatalf(\"expected to enter confirm mode: %v\", err)\n\t}\n\n\tif err := c.Close(); err != nil {\n\t\tt.Fatalf(\"could not close connection: %v (%s)\", c, err)\n\t}\n}\n\nfunc TestNotifyClosesAllChansAfterConnectionClose(t *testing.T) {\n\trwc, srv := newSession(t)\n\n\tgo func() {\n\t\tsrv.connectionOpen()\n\t\tsrv.channelOpen(1)\n\n\t\tsrv.recv(0, &connectionClose{})\n\t\tsrv.send(0, &connectionCloseOk{})\n\t}()\n\n\tc, err := Open(rwc, defaultConfig())\n\tif err != nil {\n\t\tt.Fatalf(\"could not create connection: %v (%s)\", c, err)\n\t}\n\n\tch, err := c.Channel()\n\tif err != nil {\n\t\tt.Fatalf(\"could not open channel: %v (%s)\", ch, err)\n\t}\n\n\tif err := c.Close(); err != nil {\n\t\tt.Fatalf(\"could not close connection: %v (%s)\", c, err)\n\t}\n\n\tselect {\n\tcase <-c.NotifyClose(make(chan *Error)):\n\tcase <-time.After(time.Millisecond):\n\t\tt.Errorf(\"expected to close NotifyClose chan after Connection.Close\")\n\t}\n\n\tselect {\n\tcase <-ch.NotifyClose(make(chan *Error)):\n\tcase <-time.After(time.Millisecond):\n\t\tt.Errorf(\"expected to close Connection.NotifyClose chan after Connection.Close\")\n\t}\n\n\tselect {\n\tcase <-ch.NotifyFlow(make(chan bool)):\n\tcase <-time.After(time.Millisecond):\n\t\tt.Errorf(\"expected to close Channel.NotifyFlow chan after Connection.Close\")\n\t}\n\n\tselect {\n\tcase <-ch.NotifyCancel(make(chan string)):\n\tcase <-time.After(time.Millisecond):\n\t\tt.Errorf(\"expected to close Channel.NofityCancel chan after Connection.Close\")\n\t}\n\n\tselect {\n\tcase <-ch.NotifyReturn(make(chan Return)):\n\tcase <-time.After(time.Millisecond):\n\t\tt.Errorf(\"expected to close Channel.NotifyReturn chan after Connection.Close\")\n\t}\n\n\tconfirms := ch.NotifyPublish(make(chan Confirmation))\n\n\tselect {\n\tcase <-confirms:\n\tcase <-time.After(time.Millisecond):\n\t\tt.Errorf(\"expected to close confirms on Channel.NotifyPublish chan after Connection.Close\")\n\t}\n}\n\n// Should not panic when sending bodies split at different boundaries\nfunc TestPublishBodySliceIssue74(t *testing.T) {\n\trwc, srv := newSession(t)\n\tdefer rwc.Close()\n\n\tconst frameSize = 100\n\tconst publishings = frameSize * 3\n\n\tdone := make(chan bool)\n\tbase := make([]byte, publishings)\n\n\tgo func() {\n\t\tsrv.connectionOpen()\n\t\tsrv.channelOpen(1)\n\n\t\tfor i := 0; i < publishings; i++ {\n\t\t\tsrv.recv(1, &basicPublish{})\n\t\t}\n\n\t\tdone <- true\n\t}()\n\n\tcfg := defaultConfig()\n\tcfg.FrameSize = frameSize\n\n\tc, err := Open(rwc, cfg)\n\tif err != nil {\n\t\tt.Fatalf(\"could not create connection: %v (%s)\", c, err)\n\t}\n\n\tch, err := c.Channel()\n\tif err != nil {\n\t\tt.Fatalf(\"could not open channel: %v (%s)\", ch, err)\n\t}\n\n\tfor i := 0; i < publishings; i++ {\n\t\tgo ch.Publish(\"\", \"q\", false, false, Publishing{Body: base[0:i]})\n\t}\n\n\t<-done\n}\n\n// Should not panic when server and client have frame_size of 0\nfunc TestPublishZeroFrameSizeIssue161(t *testing.T) {\n\trwc, srv := newSession(t)\n\tdefer rwc.Close()\n\n\tconst frameSize = 0\n\tconst publishings = 1\n\tdone := make(chan bool)\n\n\tgo func() {\n\t\tsrv.connectionOpen()\n\t\tsrv.channelOpen(1)\n\n\t\tfor i := 0; i < publishings; i++ {\n\t\t\tsrv.recv(1, &basicPublish{})\n\t\t}\n\n\t\tdone <- true\n\t}()\n\n\tcfg := defaultConfig()\n\tcfg.FrameSize = frameSize\n\n\tc, err := Open(rwc, cfg)\n\n\t// override the tuned framesize with a hard 0, as would happen when rabbit is configured with 0\n\tc.Config.FrameSize = frameSize\n\n\tif err != nil {\n\t\tt.Fatalf(\"could not create connection: %v (%s)\", c, err)\n\t}\n\n\tch, err := c.Channel()\n\tif err != nil {\n\t\tt.Fatalf(\"could not open channel: %v (%s)\", ch, err)\n\t}\n\n\tfor i := 0; i < publishings; i++ {\n\t\tgo ch.Publish(\"\", \"q\", false, false, Publishing{Body: []byte(\"anything\")})\n\t}\n\n\t<-done\n}\n\nfunc TestPublishAndShutdownDeadlockIssue84(t *testing.T) {\n\trwc, srv := newSession(t)\n\tdefer rwc.Close()\n\n\tgo func() {\n\t\tsrv.connectionOpen()\n\t\tsrv.channelOpen(1)\n\t\tsrv.recv(1, &basicPublish{})\n\t\t// Mimic a broken io pipe so that Publish catches the error and goes into shutdown\n\t\tsrv.S.Close()\n\t}()\n\n\tc, err := Open(rwc, defaultConfig())\n\tif err != nil {\n\t\tt.Fatalf(\"couldn't create connection: %v (%s)\", c, err)\n\t}\n\n\tch, err := c.Channel()\n\tif err != nil {\n\t\tt.Fatalf(\"couldn't open channel: %v (%s)\", ch, err)\n\t}\n\n\tdefer time.AfterFunc(500*time.Millisecond, func() { panic(\"Publish deadlock\") }).Stop()\n\tfor {\n\t\tif err := ch.Publish(\"exchange\", \"q\", false, false, Publishing{Body: []byte(\"test\")}); err != nil {\n\t\t\tt.Log(\"successfully caught disconnect error\", err)\n\t\t\treturn\n\t\t}\n\t}\n}\n\n// TestChannelReturnsCloseRace ensures that receiving a basicReturn frame and\n// sending the notification to the bound channel does not race with\n// channel.shutdown() which closes all registered notification channels - checks\n// for a \"send on closed channel\" panic\nfunc TestChannelReturnsCloseRace(t *testing.T) {\n\tdefer time.AfterFunc(5*time.Second, func() { panic(\"Shutdown deadlock\") }).Stop()\n\tch := newChannel(&Connection{}, 1)\n\n\t// Register a channel to close in channel.shutdown()\n\tnotify := make(chan Return, 1)\n\tch.NotifyReturn(notify)\n\n\tgo func() {\n\t\tfor range notify {\n\t\t\t// Drain notifications\n\t\t}\n\t}()\n\n\t// Simulate receiving a load of returns (triggering a write to the above\n\t// channel) while we call shutdown concurrently\n\tgo func() {\n\t\tfor i := 0; i < 100; i++ {\n\t\t\tch.dispatch(&basicReturn{})\n\t\t}\n\t}()\n\n\tch.shutdown(nil)\n}\n\n// TestLeakClosedConsumersIssue264 ensures that closing a consumer with\n// prefetched messages does not leak the buffering goroutine.\nfunc TestLeakClosedConsumersIssue264(t *testing.T) {\n\tconst tag = \"consumer-tag\"\n\n\trwc, srv := newSession(t)\n\tdefer rwc.Close()\n\n\tgo func() {\n\t\tsrv.connectionOpen()\n\t\tsrv.channelOpen(1)\n\n\t\tsrv.recv(1, &basicQos{})\n\t\tsrv.send(1, &basicQosOk{})\n\n\t\tsrv.recv(1, &basicConsume{})\n\t\tsrv.send(1, &basicConsumeOk{ConsumerTag: tag})\n\n\t\t// This delivery is intended to be consumed\n\t\tsrv.send(1, &basicDeliver{ConsumerTag: tag, DeliveryTag: 1})\n\n\t\t// This delivery is intended to be dropped\n\t\tsrv.send(1, &basicDeliver{ConsumerTag: tag, DeliveryTag: 2})\n\n\t\tsrv.recv(0, &connectionClose{})\n\t\tsrv.send(0, &connectionCloseOk{})\n\t\tsrv.C.Close()\n\t}()\n\n\tc, err := Open(rwc, defaultConfig())\n\tif err != nil {\n\t\tt.Fatalf(\"could not create connection: %v (%s)\", c, err)\n\t}\n\n\tch, err := c.Channel()\n\tif err != nil {\n\t\tt.Fatalf(\"could not open channel: %v (%s)\", ch, err)\n\t}\n\tch.Qos(2, 0, false)\n\n\tconsumer, err := ch.Consume(\"queue\", tag, false, false, false, false, nil)\n\tif err != nil {\n\t\tt.Fatalf(\"unexpected error during consumer: %v\", err)\n\t}\n\n\tfirst := <-consumer\n\tif want, got := uint64(1), first.DeliveryTag; want != got {\n\t\tt.Fatalf(\"unexpected delivery tag: want: %d, got: %d\", want, got)\n\t}\n\n\tif err := c.Close(); err != nil {\n\t\tt.Fatalf(\"unexpected error during connection close: %v\", err)\n\t}\n\n\tif _, open := <-consumer; open {\n\t\tt.Fatalf(\"expected deliveries channel to be closed immediately when the connection is closed so not to leak the bufferDeliveries goroutine\")\n\t}\n}\n"
        },
        {
          "name": "confirms.go",
          "type": "blob",
          "size": 1.982421875,
          "content": "package amqp\n\nimport \"sync\"\n\n// confirms resequences and notifies one or multiple publisher confirmation listeners\ntype confirms struct {\n\tm         sync.Mutex\n\tlisteners []chan Confirmation\n\tsequencer map[uint64]Confirmation\n\tpublished uint64\n\texpecting uint64\n}\n\n// newConfirms allocates a confirms\nfunc newConfirms() *confirms {\n\treturn &confirms{\n\t\tsequencer: map[uint64]Confirmation{},\n\t\tpublished: 0,\n\t\texpecting: 1,\n\t}\n}\n\nfunc (c *confirms) Listen(l chan Confirmation) {\n\tc.m.Lock()\n\tdefer c.m.Unlock()\n\n\tc.listeners = append(c.listeners, l)\n}\n\n// publish increments the publishing counter\nfunc (c *confirms) Publish() uint64 {\n\tc.m.Lock()\n\tdefer c.m.Unlock()\n\n\tc.published++\n\treturn c.published\n}\n\n// confirm confirms one publishing, increments the expecting delivery tag, and\n// removes bookkeeping for that delivery tag.\nfunc (c *confirms) confirm(confirmation Confirmation) {\n\tdelete(c.sequencer, c.expecting)\n\tc.expecting++\n\tfor _, l := range c.listeners {\n\t\tl <- confirmation\n\t}\n}\n\n// resequence confirms any out of order delivered confirmations\nfunc (c *confirms) resequence() {\n\tfor c.expecting <= c.published {\n\t\tsequenced, found := c.sequencer[c.expecting]\n\t\tif !found {\n\t\t\treturn\n\t\t}\n\t\tc.confirm(sequenced)\n\t}\n}\n\n// one confirms one publishing and all following in the publishing sequence\nfunc (c *confirms) One(confirmed Confirmation) {\n\tc.m.Lock()\n\tdefer c.m.Unlock()\n\n\tif c.expecting == confirmed.DeliveryTag {\n\t\tc.confirm(confirmed)\n\t} else {\n\t\tc.sequencer[confirmed.DeliveryTag] = confirmed\n\t}\n\tc.resequence()\n}\n\n// multiple confirms all publishings up until the delivery tag\nfunc (c *confirms) Multiple(confirmed Confirmation) {\n\tc.m.Lock()\n\tdefer c.m.Unlock()\n\n\tfor c.expecting <= confirmed.DeliveryTag {\n\t\tc.confirm(Confirmation{c.expecting, confirmed.Ack})\n\t}\n\tc.resequence()\n}\n\n// Close closes all listeners, discarding any out of sequence confirmations\nfunc (c *confirms) Close() error {\n\tc.m.Lock()\n\tdefer c.m.Unlock()\n\n\tfor _, l := range c.listeners {\n\t\tclose(l)\n\t}\n\tc.listeners = nil\n\treturn nil\n}\n"
        },
        {
          "name": "confirms_test.go",
          "type": "blob",
          "size": 2.7822265625,
          "content": "package amqp\n\nimport (\n\t\"testing\"\n\t\"time\"\n)\n\nfunc TestConfirmOneResequences(t *testing.T) {\n\tvar (\n\t\tfixtures = []Confirmation{\n\t\t\t{1, true},\n\t\t\t{2, false},\n\t\t\t{3, true},\n\t\t}\n\t\tc = newConfirms()\n\t\tl = make(chan Confirmation, len(fixtures))\n\t)\n\n\tc.Listen(l)\n\n\tfor i := range fixtures {\n\t\tif want, got := uint64(i+1), c.Publish(); want != got {\n\t\t\tt.Fatalf(\"expected publish to return the 1 based delivery tag published, want: %d, got: %d\", want, got)\n\t\t}\n\t}\n\n\tc.One(fixtures[1])\n\tc.One(fixtures[2])\n\n\tselect {\n\tcase confirm := <-l:\n\t\tt.Fatalf(\"expected to wait in order to properly resequence results, got: %+v\", confirm)\n\tdefault:\n\t}\n\n\tc.One(fixtures[0])\n\n\tfor i, fix := range fixtures {\n\t\tif want, got := fix, <-l; want != got {\n\t\t\tt.Fatalf(\"expected to return confirmations in sequence for %d, want: %+v, got: %+v\", i, want, got)\n\t\t}\n\t}\n}\n\nfunc TestConfirmMixedResequences(t *testing.T) {\n\tvar (\n\t\tfixtures = []Confirmation{\n\t\t\t{1, true},\n\t\t\t{2, true},\n\t\t\t{3, true},\n\t\t}\n\t\tc = newConfirms()\n\t\tl = make(chan Confirmation, len(fixtures))\n\t)\n\tc.Listen(l)\n\n\tfor range fixtures {\n\t\tc.Publish()\n\t}\n\n\tc.One(fixtures[0])\n\tc.One(fixtures[2])\n\tc.Multiple(fixtures[1])\n\n\tfor i, fix := range fixtures {\n\t\twant := fix\n\t\tvar got Confirmation\n\t\tselect {\n\t\tcase got = <-l:\n\t\tcase <-time.After(1 * time.Second):\n\t\t\tt.Fatalf(\"timeout on reading confirmations\")\n\t\t}\n\t\tif want != got {\n\t\t\tt.Fatalf(\"expected to confirm in sequence for %d, want: %+v, got: %+v\", i, want, got)\n\t\t}\n\t}\n}\n\nfunc TestConfirmMultipleResequences(t *testing.T) {\n\tvar (\n\t\tfixtures = []Confirmation{\n\t\t\t{1, true},\n\t\t\t{2, true},\n\t\t\t{3, true},\n\t\t\t{4, true},\n\t\t}\n\t\tc = newConfirms()\n\t\tl = make(chan Confirmation, len(fixtures))\n\t)\n\tc.Listen(l)\n\n\tfor range fixtures {\n\t\tc.Publish()\n\t}\n\n\tc.Multiple(fixtures[len(fixtures)-1])\n\n\tfor i, fix := range fixtures {\n\t\tif want, got := fix, <-l; want != got {\n\t\t\tt.Fatalf(\"expected to confirm multiple in sequence for %d, want: %+v, got: %+v\", i, want, got)\n\t\t}\n\t}\n}\n\nfunc BenchmarkSequentialBufferedConfirms(t *testing.B) {\n\tvar (\n\t\tc = newConfirms()\n\t\tl = make(chan Confirmation, 10)\n\t)\n\n\tc.Listen(l)\n\n\tfor i := 0; i < t.N; i++ {\n\t\tif i > cap(l)-1 {\n\t\t\t<-l\n\t\t}\n\t\tc.One(Confirmation{c.Publish(), true})\n\t}\n}\n\nfunc TestConfirmsIsThreadSafe(t *testing.T) {\n\tconst count = 1000\n\tconst timeout = 5 * time.Second\n\tvar (\n\t\tc    = newConfirms()\n\t\tl    = make(chan Confirmation)\n\t\tpub  = make(chan Confirmation)\n\t\tdone = make(chan Confirmation)\n\t\tlate = time.After(timeout)\n\t)\n\n\tc.Listen(l)\n\n\tfor i := 0; i < count; i++ {\n\t\tgo func() { pub <- Confirmation{c.Publish(), true} }()\n\t}\n\n\tfor i := 0; i < count; i++ {\n\t\tgo func() { c.One(<-pub) }()\n\t}\n\n\tfor i := 0; i < count; i++ {\n\t\tgo func() { done <- <-l }()\n\t}\n\n\tfor i := 0; i < count; i++ {\n\t\tselect {\n\t\tcase <-done:\n\t\tcase <-late:\n\t\t\tt.Fatalf(\"expected all publish/confirms to finish after %s\", timeout)\n\t\t}\n\t}\n}\n"
        },
        {
          "name": "connection.go",
          "type": "blob",
          "size": 22.9033203125,
          "content": "// Copyright (c) 2012, Sean Treadway, SoundCloud Ltd.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n// Source code and contact info at http://github.com/streadway/amqp\n\npackage amqp\n\nimport (\n\t\"bufio\"\n\t\"crypto/tls\"\n\t\"io\"\n\t\"net\"\n\t\"reflect\"\n\t\"strconv\"\n\t\"strings\"\n\t\"sync\"\n\t\"sync/atomic\"\n\t\"time\"\n)\n\nconst (\n\tmaxChannelMax = (2 << 15) - 1\n\n\tdefaultHeartbeat         = 10 * time.Second\n\tdefaultConnectionTimeout = 30 * time.Second\n\tdefaultProduct           = \"https://github.com/streadway/amqp\"\n\tdefaultVersion           = \"\"\n\t// Safer default that makes channel leaks a lot easier to spot\n\t// before they create operational headaches. See https://github.com/rabbitmq/rabbitmq-server/issues/1593.\n\tdefaultChannelMax = (2 << 10) - 1\n\tdefaultLocale     = \"en_US\"\n)\n\n// Config is used in DialConfig and Open to specify the desired tuning\n// parameters used during a connection open handshake.  The negotiated tuning\n// will be stored in the returned connection's Config field.\ntype Config struct {\n\t// The SASL mechanisms to try in the client request, and the successful\n\t// mechanism used on the Connection object.\n\t// If SASL is nil, PlainAuth from the URL is used.\n\tSASL []Authentication\n\n\t// Vhost specifies the namespace of permissions, exchanges, queues and\n\t// bindings on the server.  Dial sets this to the path parsed from the URL.\n\tVhost string\n\n\tChannelMax int           // 0 max channels means 2^16 - 1\n\tFrameSize  int           // 0 max bytes means unlimited\n\tHeartbeat  time.Duration // less than 1s uses the server's interval\n\n\t// TLSClientConfig specifies the client configuration of the TLS connection\n\t// when establishing a tls transport.\n\t// If the URL uses an amqps scheme, then an empty tls.Config with the\n\t// ServerName from the URL is used.\n\tTLSClientConfig *tls.Config\n\n\t// Properties is table of properties that the client advertises to the server.\n\t// This is an optional setting - if the application does not set this,\n\t// the underlying library will use a generic set of client properties.\n\tProperties Table\n\n\t// Connection locale that we expect to always be en_US\n\t// Even though servers must return it as per the AMQP 0-9-1 spec,\n\t// we are not aware of it being used other than to satisfy the spec requirements\n\tLocale string\n\n\t// Dial returns a net.Conn prepared for a TLS handshake with TSLClientConfig,\n\t// then an AMQP connection handshake.\n\t// If Dial is nil, net.DialTimeout with a 30s connection and 30s deadline is\n\t// used during TLS and AMQP handshaking.\n\tDial func(network, addr string) (net.Conn, error)\n}\n\n// Connection manages the serialization and deserialization of frames from IO\n// and dispatches the frames to the appropriate channel.  All RPC methods and\n// asynchronous Publishing, Delivery, Ack, Nack and Return messages are\n// multiplexed on this channel.  There must always be active receivers for\n// every asynchronous message on this connection.\ntype Connection struct {\n\tdestructor sync.Once  // shutdown once\n\tsendM      sync.Mutex // conn writer mutex\n\tm          sync.Mutex // struct field mutex\n\n\tconn io.ReadWriteCloser\n\n\trpc       chan message\n\twriter    *writer\n\tsends     chan time.Time     // timestamps of each frame sent\n\tdeadlines chan readDeadliner // heartbeater updates read deadlines\n\n\tallocator *allocator // id generator valid after openTune\n\tchannels  map[uint16]*Channel\n\n\tnoNotify bool // true when we will never notify again\n\tcloses   []chan *Error\n\tblocks   []chan Blocking\n\n\terrors chan *Error\n\n\tConfig Config // The negotiated Config after connection.open\n\n\tMajor      int      // Server's major version\n\tMinor      int      // Server's minor version\n\tProperties Table    // Server properties\n\tLocales    []string // Server locales\n\n\tclosed int32 // Will be 1 if the connection is closed, 0 otherwise. Should only be accessed as atomic\n}\n\ntype readDeadliner interface {\n\tSetReadDeadline(time.Time) error\n}\n\n// DefaultDial establishes a connection when config.Dial is not provided\nfunc DefaultDial(connectionTimeout time.Duration) func(network, addr string) (net.Conn, error) {\n\treturn func(network, addr string) (net.Conn, error) {\n\t\tconn, err := net.DialTimeout(network, addr, connectionTimeout)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\t// Heartbeating hasn't started yet, don't stall forever on a dead server.\n\t\t// A deadline is set for TLS and AMQP handshaking. After AMQP is established,\n\t\t// the deadline is cleared in openComplete.\n\t\tif err := conn.SetDeadline(time.Now().Add(connectionTimeout)); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\treturn conn, nil\n\t}\n}\n\n// Dial accepts a string in the AMQP URI format and returns a new Connection\n// over TCP using PlainAuth.  Defaults to a server heartbeat interval of 10\n// seconds and sets the handshake deadline to 30 seconds. After handshake,\n// deadlines are cleared.\n//\n// Dial uses the zero value of tls.Config when it encounters an amqps://\n// scheme.  It is equivalent to calling DialTLS(amqp, nil).\nfunc Dial(url string) (*Connection, error) {\n\treturn DialConfig(url, Config{\n\t\tHeartbeat: defaultHeartbeat,\n\t\tLocale:    defaultLocale,\n\t})\n}\n\n// DialTLS accepts a string in the AMQP URI format and returns a new Connection\n// over TCP using PlainAuth.  Defaults to a server heartbeat interval of 10\n// seconds and sets the initial read deadline to 30 seconds.\n//\n// DialTLS uses the provided tls.Config when encountering an amqps:// scheme.\nfunc DialTLS(url string, amqps *tls.Config) (*Connection, error) {\n\treturn DialConfig(url, Config{\n\t\tHeartbeat:       defaultHeartbeat,\n\t\tTLSClientConfig: amqps,\n\t\tLocale:          defaultLocale,\n\t})\n}\n\n// DialConfig accepts a string in the AMQP URI format and a configuration for\n// the transport and connection setup, returning a new Connection.  Defaults to\n// a server heartbeat interval of 10 seconds and sets the initial read deadline\n// to 30 seconds.\nfunc DialConfig(url string, config Config) (*Connection, error) {\n\tvar err error\n\tvar conn net.Conn\n\n\turi, err := ParseURI(url)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif config.SASL == nil {\n\t\tconfig.SASL = []Authentication{uri.PlainAuth()}\n\t}\n\n\tif config.Vhost == \"\" {\n\t\tconfig.Vhost = uri.Vhost\n\t}\n\n\taddr := net.JoinHostPort(uri.Host, strconv.FormatInt(int64(uri.Port), 10))\n\n\tdialer := config.Dial\n\tif dialer == nil {\n\t\tdialer = DefaultDial(defaultConnectionTimeout)\n\t}\n\n\tconn, err = dialer(\"tcp\", addr)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif uri.Scheme == \"amqps\" {\n\t\tif config.TLSClientConfig == nil {\n\t\t\tconfig.TLSClientConfig = new(tls.Config)\n\t\t}\n\n\t\t// If ServerName has not been specified in TLSClientConfig,\n\t\t// set it to the URI host used for this connection.\n\t\tif config.TLSClientConfig.ServerName == \"\" {\n\t\t\tconfig.TLSClientConfig.ServerName = uri.Host\n\t\t}\n\n\t\tclient := tls.Client(conn, config.TLSClientConfig)\n\t\tif err := client.Handshake(); err != nil {\n\n\t\t\tconn.Close()\n\t\t\treturn nil, err\n\t\t}\n\n\t\tconn = client\n\t}\n\n\treturn Open(conn, config)\n}\n\n/*\nOpen accepts an already established connection, or other io.ReadWriteCloser as\na transport.  Use this method if you have established a TLS connection or wish\nto use your own custom transport.\n\n*/\nfunc Open(conn io.ReadWriteCloser, config Config) (*Connection, error) {\n\tc := &Connection{\n\t\tconn:      conn,\n\t\twriter:    &writer{bufio.NewWriter(conn)},\n\t\tchannels:  make(map[uint16]*Channel),\n\t\trpc:       make(chan message),\n\t\tsends:     make(chan time.Time),\n\t\terrors:    make(chan *Error, 1),\n\t\tdeadlines: make(chan readDeadliner, 1),\n\t}\n\tgo c.reader(conn)\n\treturn c, c.open(config)\n}\n\n/*\nLocalAddr returns the local TCP peer address, or \":0\" (the zero value of net.TCPAddr)\nas a fallback default value if the underlying transport does not support LocalAddr().\n*/\nfunc (c *Connection) LocalAddr() net.Addr {\n\tif conn, ok := c.conn.(interface {\n\t\tLocalAddr() net.Addr\n\t}); ok {\n\t\treturn conn.LocalAddr()\n\t}\n\treturn &net.TCPAddr{}\n}\n\n// ConnectionState returns basic TLS details of the underlying transport.\n// Returns a zero value when the underlying connection does not implement\n// ConnectionState() tls.ConnectionState.\nfunc (c *Connection) ConnectionState() tls.ConnectionState {\n\tif conn, ok := c.conn.(interface {\n\t\tConnectionState() tls.ConnectionState\n\t}); ok {\n\t\treturn conn.ConnectionState()\n\t}\n\treturn tls.ConnectionState{}\n}\n\n/*\nNotifyClose registers a listener for close events either initiated by an error\naccompanying a connection.close method or by a normal shutdown.\n\nOn normal shutdowns, the chan will be closed.\n\nTo reconnect after a transport or protocol error, register a listener here and\nre-run your setup process.\n\n*/\nfunc (c *Connection) NotifyClose(receiver chan *Error) chan *Error {\n\tc.m.Lock()\n\tdefer c.m.Unlock()\n\n\tif c.noNotify {\n\t\tclose(receiver)\n\t} else {\n\t\tc.closes = append(c.closes, receiver)\n\t}\n\n\treturn receiver\n}\n\n/*\nNotifyBlocked registers a listener for RabbitMQ specific TCP flow control\nmethod extensions connection.blocked and connection.unblocked.  Flow control is\nactive with a reason when Blocking.Blocked is true.  When a Connection is\nblocked, all methods will block across all connections until server resources\nbecome free again.\n\nThis optional extension is supported by the server when the\n\"connection.blocked\" server capability key is true.\n\n*/\nfunc (c *Connection) NotifyBlocked(receiver chan Blocking) chan Blocking {\n\tc.m.Lock()\n\tdefer c.m.Unlock()\n\n\tif c.noNotify {\n\t\tclose(receiver)\n\t} else {\n\t\tc.blocks = append(c.blocks, receiver)\n\t}\n\n\treturn receiver\n}\n\n/*\nClose requests and waits for the response to close the AMQP connection.\n\nIt's advisable to use this message when publishing to ensure all kernel buffers\nhave been flushed on the server and client before exiting.\n\nAn error indicates that server may not have received this request to close but\nthe connection should be treated as closed regardless.\n\nAfter returning from this call, all resources associated with this connection,\nincluding the underlying io, Channels, Notify listeners and Channel consumers\nwill also be closed.\n*/\nfunc (c *Connection) Close() error {\n\tif c.IsClosed() {\n\t\treturn ErrClosed\n\t}\n\n\tdefer c.shutdown(nil)\n\treturn c.call(\n\t\t&connectionClose{\n\t\t\tReplyCode: replySuccess,\n\t\t\tReplyText: \"kthxbai\",\n\t\t},\n\t\t&connectionCloseOk{},\n\t)\n}\n\nfunc (c *Connection) closeWith(err *Error) error {\n\tif c.IsClosed() {\n\t\treturn ErrClosed\n\t}\n\n\tdefer c.shutdown(err)\n\treturn c.call(\n\t\t&connectionClose{\n\t\t\tReplyCode: uint16(err.Code),\n\t\t\tReplyText: err.Reason,\n\t\t},\n\t\t&connectionCloseOk{},\n\t)\n}\n\n// IsClosed returns true if the connection is marked as closed, otherwise false\n// is returned.\nfunc (c *Connection) IsClosed() bool {\n\treturn (atomic.LoadInt32(&c.closed) == 1)\n}\n\nfunc (c *Connection) send(f frame) error {\n\tif c.IsClosed() {\n\t\treturn ErrClosed\n\t}\n\n\tc.sendM.Lock()\n\terr := c.writer.WriteFrame(f)\n\tc.sendM.Unlock()\n\n\tif err != nil {\n\t\t// shutdown could be re-entrant from signaling notify chans\n\t\tgo c.shutdown(&Error{\n\t\t\tCode:   FrameError,\n\t\t\tReason: err.Error(),\n\t\t})\n\t} else {\n\t\t// Broadcast we sent a frame, reducing heartbeats, only\n\t\t// if there is something that can receive - like a non-reentrant\n\t\t// call or if the heartbeater isn't running\n\t\tselect {\n\t\tcase c.sends <- time.Now():\n\t\tdefault:\n\t\t}\n\t}\n\n\treturn err\n}\n\nfunc (c *Connection) shutdown(err *Error) {\n\tatomic.StoreInt32(&c.closed, 1)\n\n\tc.destructor.Do(func() {\n\t\tc.m.Lock()\n\t\tdefer c.m.Unlock()\n\n\t\tif err != nil {\n\t\t\tfor _, c := range c.closes {\n\t\t\t\tc <- err\n\t\t\t}\n\t\t}\n\n\t\tif err != nil {\n\t\t\tc.errors <- err\n\t\t}\n\t\t// Shutdown handler goroutine can still receive the result.\n\t\tclose(c.errors)\n\n\t\tfor _, c := range c.closes {\n\t\t\tclose(c)\n\t\t}\n\n\t\tfor _, c := range c.blocks {\n\t\t\tclose(c)\n\t\t}\n\n\t\t// Shutdown the channel, but do not use closeChannel() as it calls\n\t\t// releaseChannel() which requires the connection lock.\n\t\t//\n\t\t// Ranging over c.channels and calling releaseChannel() that mutates\n\t\t// c.channels is racy - see commit 6063341 for an example.\n\t\tfor _, ch := range c.channels {\n\t\t\tch.shutdown(err)\n\t\t}\n\n\t\tc.conn.Close()\n\n\t\tc.channels = map[uint16]*Channel{}\n\t\tc.allocator = newAllocator(1, c.Config.ChannelMax)\n\t\tc.noNotify = true\n\t})\n}\n\n// All methods sent to the connection channel should be synchronous so we\n// can handle them directly without a framing component\nfunc (c *Connection) demux(f frame) {\n\tif f.channel() == 0 {\n\t\tc.dispatch0(f)\n\t} else {\n\t\tc.dispatchN(f)\n\t}\n}\n\nfunc (c *Connection) dispatch0(f frame) {\n\tswitch mf := f.(type) {\n\tcase *methodFrame:\n\t\tswitch m := mf.Method.(type) {\n\t\tcase *connectionClose:\n\t\t\t// Send immediately as shutdown will close our side of the writer.\n\t\t\tc.send(&methodFrame{\n\t\t\t\tChannelId: 0,\n\t\t\t\tMethod:    &connectionCloseOk{},\n\t\t\t})\n\n\t\t\tc.shutdown(newError(m.ReplyCode, m.ReplyText))\n\t\tcase *connectionBlocked:\n\t\t\tfor _, c := range c.blocks {\n\t\t\t\tc <- Blocking{Active: true, Reason: m.Reason}\n\t\t\t}\n\t\tcase *connectionUnblocked:\n\t\t\tfor _, c := range c.blocks {\n\t\t\t\tc <- Blocking{Active: false}\n\t\t\t}\n\t\tdefault:\n\t\t\tc.rpc <- m\n\t\t}\n\tcase *heartbeatFrame:\n\t\t// kthx - all reads reset our deadline.  so we can drop this\n\tdefault:\n\t\t// lolwat - channel0 only responds to methods and heartbeats\n\t\tc.closeWith(ErrUnexpectedFrame)\n\t}\n}\n\nfunc (c *Connection) dispatchN(f frame) {\n\tc.m.Lock()\n\tchannel := c.channels[f.channel()]\n\tc.m.Unlock()\n\n\tif channel != nil {\n\t\tchannel.recv(channel, f)\n\t} else {\n\t\tc.dispatchClosed(f)\n\t}\n}\n\n// section 2.3.7: \"When a peer decides to close a channel or connection, it\n// sends a Close method.  The receiving peer MUST respond to a Close with a\n// Close-Ok, and then both parties can close their channel or connection.  Note\n// that if peers ignore Close, deadlock can happen when both peers send Close\n// at the same time.\"\n//\n// When we don't have a channel, so we must respond with close-ok on a close\n// method.  This can happen between a channel exception on an asynchronous\n// method like basic.publish and a synchronous close with channel.close.\n// In that case, we'll get both a channel.close and channel.close-ok in any\n// order.\nfunc (c *Connection) dispatchClosed(f frame) {\n\t// Only consider method frames, drop content/header frames\n\tif mf, ok := f.(*methodFrame); ok {\n\t\tswitch mf.Method.(type) {\n\t\tcase *channelClose:\n\t\t\tc.send(&methodFrame{\n\t\t\t\tChannelId: f.channel(),\n\t\t\t\tMethod:    &channelCloseOk{},\n\t\t\t})\n\t\tcase *channelCloseOk:\n\t\t\t// we are already closed, so do nothing\n\t\tdefault:\n\t\t\t// unexpected method on closed channel\n\t\t\tc.closeWith(ErrClosed)\n\t\t}\n\t}\n}\n\n// Reads each frame off the IO and hand off to the connection object that\n// will demux the streams and dispatch to one of the opened channels or\n// handle on channel 0 (the connection channel).\nfunc (c *Connection) reader(r io.Reader) {\n\tbuf := bufio.NewReader(r)\n\tframes := &reader{buf}\n\tconn, haveDeadliner := r.(readDeadliner)\n\n\tfor {\n\t\tframe, err := frames.ReadFrame()\n\n\t\tif err != nil {\n\t\t\tc.shutdown(&Error{Code: FrameError, Reason: err.Error()})\n\t\t\treturn\n\t\t}\n\n\t\tc.demux(frame)\n\n\t\tif haveDeadliner {\n\t\t\tselect {\n\t\t\tcase c.deadlines <- conn:\n\t\t\tdefault:\n\t\t\t\t// On c.Close() c.heartbeater() might exit just before c.deadlines <- conn is called.\n\t\t\t\t// Which results in this goroutine being stuck forever.\n\t\t\t}\n\t\t}\n\t}\n}\n\n// Ensures that at least one frame is being sent at the tuned interval with a\n// jitter tolerance of 1s\nfunc (c *Connection) heartbeater(interval time.Duration, done chan *Error) {\n\tconst maxServerHeartbeatsInFlight = 3\n\n\tvar sendTicks <-chan time.Time\n\tif interval > 0 {\n\t\tticker := time.NewTicker(interval)\n\t\tdefer ticker.Stop()\n\t\tsendTicks = ticker.C\n\t}\n\n\tlastSent := time.Now()\n\n\tfor {\n\t\tselect {\n\t\tcase at, stillSending := <-c.sends:\n\t\t\t// When actively sending, depend on sent frames to reset server timer\n\t\t\tif stillSending {\n\t\t\t\tlastSent = at\n\t\t\t} else {\n\t\t\t\treturn\n\t\t\t}\n\n\t\tcase at := <-sendTicks:\n\t\t\t// When idle, fill the space with a heartbeat frame\n\t\t\tif at.Sub(lastSent) > interval-time.Second {\n\t\t\t\tif err := c.send(&heartbeatFrame{}); err != nil {\n\t\t\t\t\t// send heartbeats even after close/closeOk so we\n\t\t\t\t\t// tick until the connection starts erroring\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}\n\n\t\tcase conn := <-c.deadlines:\n\t\t\t// When reading, reset our side of the deadline, if we've negotiated one with\n\t\t\t// a deadline that covers at least 2 server heartbeats\n\t\t\tif interval > 0 {\n\t\t\t\tconn.SetReadDeadline(time.Now().Add(maxServerHeartbeatsInFlight * interval))\n\t\t\t}\n\n\t\tcase <-done:\n\t\t\treturn\n\t\t}\n\t}\n}\n\n// Convenience method to inspect the Connection.Properties[\"capabilities\"]\n// Table for server identified capabilities like \"basic.ack\" or\n// \"confirm.select\".\nfunc (c *Connection) isCapable(featureName string) bool {\n\tcapabilities, _ := c.Properties[\"capabilities\"].(Table)\n\thasFeature, _ := capabilities[featureName].(bool)\n\treturn hasFeature\n}\n\n// allocateChannel records but does not open a new channel with a unique id.\n// This method is the initial part of the channel lifecycle and paired with\n// releaseChannel\nfunc (c *Connection) allocateChannel() (*Channel, error) {\n\tc.m.Lock()\n\tdefer c.m.Unlock()\n\n\tif c.IsClosed() {\n\t\treturn nil, ErrClosed\n\t}\n\n\tid, ok := c.allocator.next()\n\tif !ok {\n\t\treturn nil, ErrChannelMax\n\t}\n\n\tch := newChannel(c, uint16(id))\n\tc.channels[uint16(id)] = ch\n\n\treturn ch, nil\n}\n\n// releaseChannel removes a channel from the registry as the final part of the\n// channel lifecycle\nfunc (c *Connection) releaseChannel(id uint16) {\n\tc.m.Lock()\n\tdefer c.m.Unlock()\n\n\tdelete(c.channels, id)\n\tc.allocator.release(int(id))\n}\n\n// openChannel allocates and opens a channel, must be paired with closeChannel\nfunc (c *Connection) openChannel() (*Channel, error) {\n\tch, err := c.allocateChannel()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif err := ch.open(); err != nil {\n\t\tc.releaseChannel(ch.id)\n\t\treturn nil, err\n\t}\n\treturn ch, nil\n}\n\n// closeChannel releases and initiates a shutdown of the channel.  All channel\n// closures should be initiated here for proper channel lifecycle management on\n// this connection.\nfunc (c *Connection) closeChannel(ch *Channel, e *Error) {\n\tch.shutdown(e)\n\tc.releaseChannel(ch.id)\n}\n\n/*\nChannel opens a unique, concurrent server channel to process the bulk of AMQP\nmessages.  Any error from methods on this receiver will render the receiver\ninvalid and a new Channel should be opened.\n\n*/\nfunc (c *Connection) Channel() (*Channel, error) {\n\treturn c.openChannel()\n}\n\nfunc (c *Connection) call(req message, res ...message) error {\n\t// Special case for when the protocol header frame is sent insted of a\n\t// request method\n\tif req != nil {\n\t\tif err := c.send(&methodFrame{ChannelId: 0, Method: req}); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\tselect {\n\tcase err, ok := <-c.errors:\n\t\tif !ok {\n\t\t\treturn ErrClosed\n\t\t}\n\t\treturn err\n\n\tcase msg := <-c.rpc:\n\t\t// Try to match one of the result types\n\t\tfor _, try := range res {\n\t\t\tif reflect.TypeOf(msg) == reflect.TypeOf(try) {\n\t\t\t\t// *res = *msg\n\t\t\t\tvres := reflect.ValueOf(try).Elem()\n\t\t\t\tvmsg := reflect.ValueOf(msg).Elem()\n\t\t\t\tvres.Set(vmsg)\n\t\t\t\treturn nil\n\t\t\t}\n\t\t}\n\t\treturn ErrCommandInvalid\n\t}\n\t// unreachable\n}\n\n//    Connection          = open-Connection *use-Connection close-Connection\n//    open-Connection     = C:protocol-header\n//                          S:START C:START-OK\n//                          *challenge\n//                          S:TUNE C:TUNE-OK\n//                          C:OPEN S:OPEN-OK\n//    challenge           = S:SECURE C:SECURE-OK\n//    use-Connection      = *channel\n//    close-Connection    = C:CLOSE S:CLOSE-OK\n//                        / S:CLOSE C:CLOSE-OK\nfunc (c *Connection) open(config Config) error {\n\tif err := c.send(&protocolHeader{}); err != nil {\n\t\treturn err\n\t}\n\n\treturn c.openStart(config)\n}\n\nfunc (c *Connection) openStart(config Config) error {\n\tstart := &connectionStart{}\n\n\tif err := c.call(nil, start); err != nil {\n\t\treturn err\n\t}\n\n\tc.Major = int(start.VersionMajor)\n\tc.Minor = int(start.VersionMinor)\n\tc.Properties = Table(start.ServerProperties)\n\tc.Locales = strings.Split(start.Locales, \" \")\n\n\t// eventually support challenge/response here by also responding to\n\t// connectionSecure.\n\tauth, ok := pickSASLMechanism(config.SASL, strings.Split(start.Mechanisms, \" \"))\n\tif !ok {\n\t\treturn ErrSASL\n\t}\n\n\t// Save this mechanism off as the one we chose\n\tc.Config.SASL = []Authentication{auth}\n\n\t// Set the connection locale to client locale\n\tc.Config.Locale = config.Locale\n\n\treturn c.openTune(config, auth)\n}\n\nfunc (c *Connection) openTune(config Config, auth Authentication) error {\n\tif len(config.Properties) == 0 {\n\t\tconfig.Properties = Table{\n\t\t\t\"product\": defaultProduct,\n\t\t\t\"version\": defaultVersion,\n\t\t}\n\t}\n\n\tconfig.Properties[\"capabilities\"] = Table{\n\t\t\"connection.blocked\":     true,\n\t\t\"consumer_cancel_notify\": true,\n\t}\n\n\tok := &connectionStartOk{\n\t\tClientProperties: config.Properties,\n\t\tMechanism:        auth.Mechanism(),\n\t\tResponse:         auth.Response(),\n\t\tLocale:           config.Locale,\n\t}\n\ttune := &connectionTune{}\n\n\tif err := c.call(ok, tune); err != nil {\n\t\t// per spec, a connection can only be closed when it has been opened\n\t\t// so at this point, we know it's an auth error, but the socket\n\t\t// was closed instead.  Return a meaningful error.\n\t\treturn ErrCredentials\n\t}\n\n\t// When the server and client both use default 0, then the max channel is\n\t// only limited by uint16.\n\tc.Config.ChannelMax = pick(config.ChannelMax, int(tune.ChannelMax))\n\tif c.Config.ChannelMax == 0 {\n\t\tc.Config.ChannelMax = defaultChannelMax\n\t}\n\tc.Config.ChannelMax = min(c.Config.ChannelMax, maxChannelMax)\n\n\t// Frame size includes headers and end byte (len(payload)+8), even if\n\t// this is less than FrameMinSize, use what the server sends because the\n\t// alternative is to stop the handshake here.\n\tc.Config.FrameSize = pick(config.FrameSize, int(tune.FrameMax))\n\n\t// Save this off for resetDeadline()\n\tc.Config.Heartbeat = time.Second * time.Duration(pick(\n\t\tint(config.Heartbeat/time.Second),\n\t\tint(tune.Heartbeat)))\n\n\t// \"The client should start sending heartbeats after receiving a\n\t// Connection.Tune method\"\n\tgo c.heartbeater(c.Config.Heartbeat, c.NotifyClose(make(chan *Error, 1)))\n\n\tif err := c.send(&methodFrame{\n\t\tChannelId: 0,\n\t\tMethod: &connectionTuneOk{\n\t\t\tChannelMax: uint16(c.Config.ChannelMax),\n\t\t\tFrameMax:   uint32(c.Config.FrameSize),\n\t\t\tHeartbeat:  uint16(c.Config.Heartbeat / time.Second),\n\t\t},\n\t}); err != nil {\n\t\treturn err\n\t}\n\n\treturn c.openVhost(config)\n}\n\nfunc (c *Connection) openVhost(config Config) error {\n\treq := &connectionOpen{VirtualHost: config.Vhost}\n\tres := &connectionOpenOk{}\n\n\tif err := c.call(req, res); err != nil {\n\t\t// Cannot be closed yet, but we know it's a vhost problem\n\t\treturn ErrVhost\n\t}\n\n\tc.Config.Vhost = config.Vhost\n\n\treturn c.openComplete()\n}\n\n// openComplete performs any final Connection initialization dependent on the\n// connection handshake and clears any state needed for TLS and AMQP handshaking.\nfunc (c *Connection) openComplete() error {\n\t// We clear the deadlines and let the heartbeater reset the read deadline if requested.\n\t// RabbitMQ uses TCP flow control at this point for pushback so Writes can\n\t// intentionally block.\n\tif deadliner, ok := c.conn.(interface {\n\t\tSetDeadline(time.Time) error\n\t}); ok {\n\t\t_ = deadliner.SetDeadline(time.Time{})\n\t}\n\n\tc.allocator = newAllocator(1, c.Config.ChannelMax)\n\treturn nil\n}\n\nfunc max(a, b int) int {\n\tif a > b {\n\t\treturn a\n\t}\n\treturn b\n}\n\nfunc min(a, b int) int {\n\tif a < b {\n\t\treturn a\n\t}\n\treturn b\n}\n\nfunc pick(client, server int) int {\n\tif client == 0 || server == 0 {\n\t\treturn max(client, server)\n\t}\n\treturn min(client, server)\n}\n"
        },
        {
          "name": "connection_test.go",
          "type": "blob",
          "size": 5.341796875,
          "content": "// Copyright (c) 2016, Sean Treadway, SoundCloud Ltd.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n// Source code and contact info at http://github.com/streadway/amqp\n\n// +build integration\n\npackage amqp\n\nimport (\n\t\"crypto/tls\"\n\t\"net\"\n\t\"sync\"\n\t\"testing\"\n\t\"time\"\n)\n\nfunc TestRequiredServerLocale(t *testing.T) {\n\tconn := integrationConnection(t, \"AMQP 0-9-1 required server locale\")\n\trequiredServerLocale := defaultLocale\n\n\tfor _, locale := range conn.Locales {\n\t\tif locale == requiredServerLocale {\n\t\t\treturn\n\t\t}\n\t}\n\n\tt.Fatalf(\"AMQP 0-9-1 server must support at least the %s locale, server sent the following locales: %#v\", requiredServerLocale, conn.Locales)\n}\n\nfunc TestDefaultConnectionLocale(t *testing.T) {\n\tconn := integrationConnection(t, \"client default locale\")\n\n\tif conn.Config.Locale != defaultLocale {\n\t\tt.Fatalf(\"Expected default connection locale to be %s, is was: %s\", defaultLocale, conn.Config.Locale)\n\t}\n}\n\nfunc TestChannelOpenOnAClosedConnectionFails(t *testing.T) {\n\tconn := integrationConnection(t, \"channel on close\")\n\n\tconn.Close()\n\n\tif _, err := conn.Channel(); err != ErrClosed {\n\t\tt.Fatalf(\"channel.open on a closed connection %#v is expected to fail\", conn)\n\t}\n}\n\n// TestChannelOpenOnAClosedConnectionFails_ReleasesAllocatedChannel ensures the\n// channel allocated is released if opening the channel fails.\nfunc TestChannelOpenOnAClosedConnectionFails_ReleasesAllocatedChannel(t *testing.T) {\n\tconn := integrationConnection(t, \"releases channel allocation\")\n\tconn.Close()\n\n\tbefore := len(conn.channels)\n\n\tif _, err := conn.Channel(); err != ErrClosed {\n\t\tt.Fatalf(\"channel.open on a closed connection %#v is expected to fail\", conn)\n\t}\n\n\tif len(conn.channels) != before {\n\t\tt.Fatalf(\"channel.open failed, but the allocated channel was not released\")\n\t}\n}\n\n// TestRaceBetweenChannelAndConnectionClose ensures allocating a new channel\n// does not race with shutting the connection down.\n//\n// See https://github.com/streadway/amqp/issues/251 - thanks to jmalloc for the\n// test case.\nfunc TestRaceBetweenChannelAndConnectionClose(t *testing.T) {\n\tdefer time.AfterFunc(10*time.Second, func() { panic(\"Close deadlock\") }).Stop()\n\n\tconn := integrationConnection(t, \"allocation/shutdown race\")\n\n\tgo conn.Close()\n\tfor i := 0; i < 10; i++ {\n\t\tgo func() {\n\t\t\tch, err := conn.Channel()\n\t\t\tif err == nil {\n\t\t\t\tch.Close()\n\t\t\t}\n\t\t}()\n\t}\n}\n\n// TestRaceBetweenChannelShutdownAndSend ensures closing a channel\n// (channel.shutdown) does not race with calling channel.send() from any other\n// goroutines.\n//\n// See https://github.com/streadway/amqp/pull/253#issuecomment-292464811 for\n// more details - thanks to jmalloc again.\nfunc TestRaceBetweenChannelShutdownAndSend(t *testing.T) {\n\tdefer time.AfterFunc(10*time.Second, func() { panic(\"Close deadlock\") }).Stop()\n\n\tconn := integrationConnection(t, \"channel close/send race\")\n\tdefer conn.Close()\n\n\tch, _ := conn.Channel()\n\n\tgo ch.Close()\n\tfor i := 0; i < 10; i++ {\n\t\tgo func() {\n\t\t\t// ch.Ack calls ch.send() internally.\n\t\t\tch.Ack(42, false)\n\t\t}()\n\t}\n}\n\nfunc TestQueueDeclareOnAClosedConnectionFails(t *testing.T) {\n\tconn := integrationConnection(t, \"queue declare on close\")\n\tch, _ := conn.Channel()\n\n\tconn.Close()\n\n\tif _, err := ch.QueueDeclare(\"an example\", false, false, false, false, nil); err != ErrClosed {\n\t\tt.Fatalf(\"queue.declare on a closed connection %#v is expected to return ErrClosed, returned: %#v\", conn, err)\n\t}\n}\n\nfunc TestConcurrentClose(t *testing.T) {\n\tconst concurrency = 32\n\n\tconn := integrationConnection(t, \"concurrent close\")\n\tdefer conn.Close()\n\n\twg := sync.WaitGroup{}\n\twg.Add(concurrency)\n\tfor i := 0; i < concurrency; i++ {\n\t\tgo func() {\n\t\t\tdefer wg.Done()\n\n\t\t\terr := conn.Close()\n\n\t\t\tif err == nil {\n\t\t\t\tt.Log(\"first concurrent close was successful\")\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif err == ErrClosed {\n\t\t\t\tt.Log(\"later concurrent close were successful and returned ErrClosed\")\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\t// BUG(st) is this really acceptable? we got a net.OpError before the\n\t\t\t// connection was marked as closed means a race condition between the\n\t\t\t// network connection and handshake state. It should be a package error\n\t\t\t// returned.\n\t\t\tif _, neterr := err.(*net.OpError); neterr {\n\t\t\t\tt.Logf(\"unknown net.OpError during close, ignoring: %+v\", err)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\t// A different/protocol error occurred indicating a race or missed condition\n\t\t\tif _, other := err.(*Error); other {\n\t\t\t\tt.Fatalf(\"Expected no error, or ErrClosed, or a net.OpError from conn.Close(), got %#v (%s) of type %T\", err, err, err)\n\t\t\t}\n\t\t}()\n\t}\n\twg.Wait()\n}\n\n// TestPlaintextDialTLS esnures amqp:// connections succeed when using DialTLS.\nfunc TestPlaintextDialTLS(t *testing.T) {\n\turi, err := ParseURI(integrationURLFromEnv())\n\tif err != nil {\n\t\tt.Fatalf(\"parse URI error: %s\", err)\n\t}\n\n\t// We can only test when we have a plaintext listener\n\tif uri.Scheme != \"amqp\" {\n\t\tt.Skip(\"requires server listening for plaintext connections\")\n\t}\n\n\tconn, err := DialTLS(uri.String(), &tls.Config{MinVersion: tls.VersionTLS12})\n\tif err != nil {\n\t\tt.Fatalf(\"unexpected dial error, got %v\", err)\n\t}\n\tconn.Close()\n}\n\n// TestIsClosed will test the public method IsClosed on a connection.\nfunc TestIsClosed(t *testing.T) {\n\tconn := integrationConnection(t, \"public IsClosed()\")\n\n\tif conn.IsClosed() {\n\t\tt.Fatalf(\"connection expected to not be marked as closed\")\n\t}\n\n\tconn.Close()\n\n\tif !conn.IsClosed() {\n\t\tt.Fatal(\"connection expected to be marked as closed\")\n\t}\n}\n"
        },
        {
          "name": "consumers.go",
          "type": "blob",
          "size": 2.78515625,
          "content": "// Copyright (c) 2012, Sean Treadway, SoundCloud Ltd.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n// Source code and contact info at http://github.com/streadway/amqp\n\npackage amqp\n\nimport (\n\t\"os\"\n\t\"strconv\"\n\t\"sync\"\n\t\"sync/atomic\"\n)\n\nvar consumerSeq uint64\n\nconst consumerTagLengthMax = 0xFF // see writeShortstr\n\nfunc uniqueConsumerTag() string {\n\treturn commandNameBasedUniqueConsumerTag(os.Args[0])\n}\n\nfunc commandNameBasedUniqueConsumerTag(commandName string) string {\n\ttagPrefix := \"ctag-\"\n\ttagInfix := commandName\n\ttagSuffix := \"-\" + strconv.FormatUint(atomic.AddUint64(&consumerSeq, 1), 10)\n\n\tif len(tagPrefix)+len(tagInfix)+len(tagSuffix) > consumerTagLengthMax {\n\t\ttagInfix = \"streadway/amqp\"\n\t}\n\n\treturn tagPrefix + tagInfix + tagSuffix\n}\n\ntype consumerBuffers map[string]chan *Delivery\n\n// Concurrent type that manages the consumerTag ->\n// ingress consumerBuffer mapping\ntype consumers struct {\n\tsync.WaitGroup               // one for buffer\n\tclosed         chan struct{} // signal buffer\n\n\tsync.Mutex // protects below\n\tchans      consumerBuffers\n}\n\nfunc makeConsumers() *consumers {\n\treturn &consumers{\n\t\tclosed: make(chan struct{}),\n\t\tchans:  make(consumerBuffers),\n\t}\n}\n\nfunc (subs *consumers) buffer(in chan *Delivery, out chan Delivery) {\n\tdefer close(out)\n\tdefer subs.Done()\n\n\tvar inflight = in\n\tvar queue []*Delivery\n\n\tfor delivery := range in {\n\t\tqueue = append(queue, delivery)\n\n\t\tfor len(queue) > 0 {\n\t\t\tselect {\n\t\t\tcase <-subs.closed:\n\t\t\t\t// closed before drained, drop in-flight\n\t\t\t\treturn\n\n\t\t\tcase delivery, consuming := <-inflight:\n\t\t\t\tif consuming {\n\t\t\t\t\tqueue = append(queue, delivery)\n\t\t\t\t} else {\n\t\t\t\t\tinflight = nil\n\t\t\t\t}\n\n\t\t\tcase out <- *queue[0]:\n\t\t\t\tqueue = queue[1:]\n\t\t\t}\n\t\t}\n\t}\n}\n\n// On key conflict, close the previous channel.\nfunc (subs *consumers) add(tag string, consumer chan Delivery) {\n\tsubs.Lock()\n\tdefer subs.Unlock()\n\n\tif prev, found := subs.chans[tag]; found {\n\t\tclose(prev)\n\t}\n\n\tin := make(chan *Delivery)\n\tsubs.chans[tag] = in\n\n\tsubs.Add(1)\n\tgo subs.buffer(in, consumer)\n}\n\nfunc (subs *consumers) cancel(tag string) (found bool) {\n\tsubs.Lock()\n\tdefer subs.Unlock()\n\n\tch, found := subs.chans[tag]\n\n\tif found {\n\t\tdelete(subs.chans, tag)\n\t\tclose(ch)\n\t}\n\n\treturn found\n}\n\nfunc (subs *consumers) close() {\n\tsubs.Lock()\n\tdefer subs.Unlock()\n\n\tclose(subs.closed)\n\n\tfor tag, ch := range subs.chans {\n\t\tdelete(subs.chans, tag)\n\t\tclose(ch)\n\t}\n\n\tsubs.Wait()\n}\n\n// Sends a delivery to a the consumer identified by `tag`.\n// If unbuffered channels are used for Consume this method\n// could block all deliveries until the consumer\n// receives on the other end of the channel.\nfunc (subs *consumers) send(tag string, msg *Delivery) bool {\n\tsubs.Lock()\n\tdefer subs.Unlock()\n\n\tbuffer, found := subs.chans[tag]\n\tif found {\n\t\tbuffer <- msg\n\t}\n\n\treturn found\n}\n"
        },
        {
          "name": "consumers_test.go",
          "type": "blob",
          "size": 0.509765625,
          "content": "package amqp\n\nimport (\n\t\"strings\"\n\t\"testing\"\n)\n\nfunc TestGeneratedUniqueConsumerTagDoesNotExceedMaxLength(t *testing.T) {\n\tassertCorrectLength := func(commandName string) {\n\t\ttag := commandNameBasedUniqueConsumerTag(commandName)\n\t\tif len(tag) > consumerTagLengthMax {\n\t\t\tt.Error(\"Generated unique consumer tag exceeds maximum length:\", tag)\n\t\t}\n\t}\n\n\tassertCorrectLength(\"test\")\n\tassertCorrectLength(strings.Repeat(\"z\", 249))\n\tassertCorrectLength(strings.Repeat(\"z\", 256))\n\tassertCorrectLength(strings.Repeat(\"z\", 1024))\n}\n"
        },
        {
          "name": "delivery.go",
          "type": "blob",
          "size": 5.8271484375,
          "content": "// Copyright (c) 2012, Sean Treadway, SoundCloud Ltd.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n// Source code and contact info at http://github.com/streadway/amqp\n\npackage amqp\n\nimport (\n\t\"errors\"\n\t\"time\"\n)\n\nvar errDeliveryNotInitialized = errors.New(\"delivery not initialized\")\n\n// Acknowledger notifies the server of successful or failed consumption of\n// delivieries via identifier found in the Delivery.DeliveryTag field.\n//\n// Applications can provide mock implementations in tests of Delivery handlers.\ntype Acknowledger interface {\n\tAck(tag uint64, multiple bool) error\n\tNack(tag uint64, multiple bool, requeue bool) error\n\tReject(tag uint64, requeue bool) error\n}\n\n// Delivery captures the fields for a previously delivered message resident in\n// a queue to be delivered by the server to a consumer from Channel.Consume or\n// Channel.Get.\ntype Delivery struct {\n\tAcknowledger Acknowledger // the channel from which this delivery arrived\n\n\tHeaders Table // Application or header exchange table\n\n\t// Properties\n\tContentType     string    // MIME content type\n\tContentEncoding string    // MIME content encoding\n\tDeliveryMode    uint8     // queue implementation use - non-persistent (1) or persistent (2)\n\tPriority        uint8     // queue implementation use - 0 to 9\n\tCorrelationId   string    // application use - correlation identifier\n\tReplyTo         string    // application use - address to reply to (ex: RPC)\n\tExpiration      string    // implementation use - message expiration spec\n\tMessageId       string    // application use - message identifier\n\tTimestamp       time.Time // application use - message timestamp\n\tType            string    // application use - message type name\n\tUserId          string    // application use - creating user - should be authenticated user\n\tAppId           string    // application use - creating application id\n\n\t// Valid only with Channel.Consume\n\tConsumerTag string\n\n\t// Valid only with Channel.Get\n\tMessageCount uint32\n\n\tDeliveryTag uint64\n\tRedelivered bool\n\tExchange    string // basic.publish exchange\n\tRoutingKey  string // basic.publish routing key\n\n\tBody []byte\n}\n\nfunc newDelivery(channel *Channel, msg messageWithContent) *Delivery {\n\tprops, body := msg.getContent()\n\n\tdelivery := Delivery{\n\t\tAcknowledger: channel,\n\n\t\tHeaders:         props.Headers,\n\t\tContentType:     props.ContentType,\n\t\tContentEncoding: props.ContentEncoding,\n\t\tDeliveryMode:    props.DeliveryMode,\n\t\tPriority:        props.Priority,\n\t\tCorrelationId:   props.CorrelationId,\n\t\tReplyTo:         props.ReplyTo,\n\t\tExpiration:      props.Expiration,\n\t\tMessageId:       props.MessageId,\n\t\tTimestamp:       props.Timestamp,\n\t\tType:            props.Type,\n\t\tUserId:          props.UserId,\n\t\tAppId:           props.AppId,\n\n\t\tBody: body,\n\t}\n\n\t// Properties for the delivery types\n\tswitch m := msg.(type) {\n\tcase *basicDeliver:\n\t\tdelivery.ConsumerTag = m.ConsumerTag\n\t\tdelivery.DeliveryTag = m.DeliveryTag\n\t\tdelivery.Redelivered = m.Redelivered\n\t\tdelivery.Exchange = m.Exchange\n\t\tdelivery.RoutingKey = m.RoutingKey\n\n\tcase *basicGetOk:\n\t\tdelivery.MessageCount = m.MessageCount\n\t\tdelivery.DeliveryTag = m.DeliveryTag\n\t\tdelivery.Redelivered = m.Redelivered\n\t\tdelivery.Exchange = m.Exchange\n\t\tdelivery.RoutingKey = m.RoutingKey\n\t}\n\n\treturn &delivery\n}\n\n/*\nAck delegates an acknowledgement through the Acknowledger interface that the\nclient or server has finished work on a delivery.\n\nAll deliveries in AMQP must be acknowledged.  If you called Channel.Consume\nwith autoAck true then the server will be automatically ack each message and\nthis method should not be called.  Otherwise, you must call Delivery.Ack after\nyou have successfully processed this delivery.\n\nWhen multiple is true, this delivery and all prior unacknowledged deliveries\non the same channel will be acknowledged.  This is useful for batch processing\nof deliveries.\n\nAn error will indicate that the acknowledge could not be delivered to the\nchannel it was sent from.\n\nEither Delivery.Ack, Delivery.Reject or Delivery.Nack must be called for every\ndelivery that is not automatically acknowledged.\n*/\nfunc (d Delivery) Ack(multiple bool) error {\n\tif d.Acknowledger == nil {\n\t\treturn errDeliveryNotInitialized\n\t}\n\treturn d.Acknowledger.Ack(d.DeliveryTag, multiple)\n}\n\n/*\nReject delegates a negatively acknowledgement through the Acknowledger interface.\n\nWhen requeue is true, queue this message to be delivered to a consumer on a\ndifferent channel.  When requeue is false or the server is unable to queue this\nmessage, it will be dropped.\n\nIf you are batch processing deliveries, and your server supports it, prefer\nDelivery.Nack.\n\nEither Delivery.Ack, Delivery.Reject or Delivery.Nack must be called for every\ndelivery that is not automatically acknowledged.\n*/\nfunc (d Delivery) Reject(requeue bool) error {\n\tif d.Acknowledger == nil {\n\t\treturn errDeliveryNotInitialized\n\t}\n\treturn d.Acknowledger.Reject(d.DeliveryTag, requeue)\n}\n\n/*\nNack negatively acknowledge the delivery of message(s) identified by the\ndelivery tag from either the client or server.\n\nWhen multiple is true, nack messages up to and including delivered messages up\nuntil the delivery tag delivered on the same channel.\n\nWhen requeue is true, request the server to deliver this message to a different\nconsumer.  If it is not possible or requeue is false, the message will be\ndropped or delivered to a server configured dead-letter queue.\n\nThis method must not be used to select or requeue messages the client wishes\nnot to handle, rather it is to inform the server that the client is incapable\nof handling this message at this time.\n\nEither Delivery.Ack, Delivery.Reject or Delivery.Nack must be called for every\ndelivery that is not automatically acknowledged.\n*/\nfunc (d Delivery) Nack(multiple, requeue bool) error {\n\tif d.Acknowledger == nil {\n\t\treturn errDeliveryNotInitialized\n\t}\n\treturn d.Acknowledger.Nack(d.DeliveryTag, multiple, requeue)\n}\n"
        },
        {
          "name": "delivery_test.go",
          "type": "blob",
          "size": 0.9072265625,
          "content": "package amqp\n\nimport \"testing\"\n\nfunc shouldNotPanic(t *testing.T) {\n\tif err := recover(); err != nil {\n\t\tt.Fatalf(\"should not panic, got: %s\", err)\n\t}\n}\n\n// A closed delivery chan could produce zero value.  Ack/Nack/Reject on these\n// deliveries can produce a nil pointer panic.  Instead return an error when\n// the method can never be successful.\nfunc TestAckZeroValueAcknowledgerDoesNotPanic(t *testing.T) {\n\tdefer shouldNotPanic(t)\n\tif err := (Delivery{}).Ack(false); err == nil {\n\t\tt.Errorf(\"expected Delivery{}.Ack to error\")\n\t}\n}\n\nfunc TestNackZeroValueAcknowledgerDoesNotPanic(t *testing.T) {\n\tdefer shouldNotPanic(t)\n\tif err := (Delivery{}).Nack(false, false); err == nil {\n\t\tt.Errorf(\"expected Delivery{}.Ack to error\")\n\t}\n}\n\nfunc TestRejectZeroValueAcknowledgerDoesNotPanic(t *testing.T) {\n\tdefer shouldNotPanic(t)\n\tif err := (Delivery{}).Reject(false); err == nil {\n\t\tt.Errorf(\"expected Delivery{}.Ack to error\")\n\t}\n}\n"
        },
        {
          "name": "doc.go",
          "type": "blob",
          "size": 4.8125,
          "content": "// Copyright (c) 2012, Sean Treadway, SoundCloud Ltd.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n// Source code and contact info at http://github.com/streadway/amqp\n\n/*\nPackage amqp is an AMQP 0.9.1 client with RabbitMQ extensions\n\nUnderstand the AMQP 0.9.1 messaging model by reviewing these links first. Much\nof the terminology in this library directly relates to AMQP concepts.\n\n  Resources\n\n  http://www.rabbitmq.com/tutorials/amqp-concepts.html\n  http://www.rabbitmq.com/getstarted.html\n  http://www.rabbitmq.com/amqp-0-9-1-reference.html\n\nDesign\n\nMost other broker clients publish to queues, but in AMQP, clients publish\nExchanges instead.  AMQP is programmable, meaning that both the producers and\nconsumers agree on the configuration of the broker, instead of requiring an\noperator or system configuration that declares the logical topology in the\nbroker.  The routing between producers and consumer queues is via Bindings.\nThese bindings form the logical topology of the broker.\n\nIn this library, a message sent from publisher is called a \"Publishing\" and a\nmessage received to a consumer is called a \"Delivery\".  The fields of\nPublishings and Deliveries are close but not exact mappings to the underlying\nwire format to maintain stronger types.  Many other libraries will combine\nmessage properties with message headers.  In this library, the message well\nknown properties are strongly typed fields on the Publishings and Deliveries,\nwhereas the user defined headers are in the Headers field.\n\nThe method naming closely matches the protocol's method name with positional\nparameters mapping to named protocol message fields.  The motivation here is to\npresent a comprehensive view over all possible interactions with the server.\n\nGenerally, methods that map to protocol methods of the \"basic\" class will be\nelided in this interface, and \"select\" methods of various channel mode selectors\nwill be elided for example Channel.Confirm and Channel.Tx.\n\nThe library is intentionally designed to be synchronous, where responses for\neach protocol message are required to be received in an RPC manner.  Some\nmethods have a noWait parameter like Channel.QueueDeclare, and some methods are\nasynchronous like Channel.Publish.  The error values should still be checked for\nthese methods as they will indicate IO failures like when the underlying\nconnection closes.\n\nAsynchronous Events\n\nClients of this library may be interested in receiving some of the protocol\nmessages other than Deliveries like basic.ack methods while a channel is in\nconfirm mode.\n\nThe Notify* methods with Connection and Channel receivers model the pattern of\nasynchronous events like closes due to exceptions, or messages that are sent out\nof band from an RPC call like basic.ack or basic.flow.\n\nAny asynchronous events, including Deliveries and Publishings must always have\na receiver until the corresponding chans are closed.  Without asynchronous\nreceivers, the sychronous methods will block.\n\nUse Case\n\nIt's important as a client to an AMQP topology to ensure the state of the\nbroker matches your expectations.  For both publish and consume use cases,\nmake sure you declare the queues, exchanges and bindings you expect to exist\nprior to calling Channel.Publish or Channel.Consume.\n\n  // Connections start with amqp.Dial() typically from a command line argument\n  // or environment variable.\n  connection, err := amqp.Dial(os.Getenv(\"AMQP_URL\"))\n\n  // To cleanly shutdown by flushing kernel buffers, make sure to close and\n  // wait for the response.\n  defer connection.Close()\n\n  // Most operations happen on a channel.  If any error is returned on a\n  // channel, the channel will no longer be valid, throw it away and try with\n  // a different channel.  If you use many channels, it's useful for the\n  // server to\n  channel, err := connection.Channel()\n\n  // Declare your topology here, if it doesn't exist, it will be created, if\n  // it existed already and is not what you expect, then that's considered an\n  // error.\n\n  // Use your connection on this topology with either Publish or Consume, or\n  // inspect your queues with QueueInspect.  It's unwise to mix Publish and\n  // Consume to let TCP do its job well.\n\nSSL/TLS - Secure connections\n\nWhen Dial encounters an amqps:// scheme, it will use the zero value of a\ntls.Config.  This will only perform server certificate and host verification.\n\nUse DialTLS when you wish to provide a client certificate (recommended),\ninclude a private certificate authority's certificate in the cert chain for\nserver validity, or run insecure by not verifying the server certificate dial\nyour own connection.  DialTLS will use the provided tls.Config when it\nencounters an amqps:// scheme and will dial a plain connection when it\nencounters an amqp:// scheme.\n\nSSL/TLS in RabbitMQ is documented here: http://www.rabbitmq.com/ssl.html\n\n*/\npackage amqp\n"
        },
        {
          "name": "example_client_test.go",
          "type": "blob",
          "size": 6.94921875,
          "content": "package amqp_test\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"log\"\n\t\"os\"\n\t\"time\"\n\n\t\"github.com/streadway/amqp\"\n)\n\n// This exports a Session object that wraps this library. It\n// automatically reconnects when the connection fails, and\n// blocks all pushes until the connection succeeds. It also\n// confirms every outgoing message, so none are lost.\n// It doesn't automatically ack each message, but leaves that\n// to the parent process, since it is usage-dependent.\n//\n// Try running this in one terminal, and `rabbitmq-server` in another.\n// Stop & restart RabbitMQ to see how the queue reacts.\nfunc Example() {\n\tname := \"job_queue\"\n\taddr := \"amqp://guest:guest@localhost:5672/\"\n\tqueue := New(name, addr)\n\tmessage := []byte(\"message\")\n\t// Attempt to push a message every 2 seconds\n\tfor {\n\t\ttime.Sleep(time.Second * 2)\n\t\tif err := queue.Push(message); err != nil {\n\t\t\tfmt.Printf(\"Push failed: %s\\n\", err)\n\t\t} else {\n\t\t\tfmt.Println(\"Push succeeded!\")\n\t\t}\n\t}\n}\n\ntype Session struct {\n\tname            string\n\tlogger          *log.Logger\n\tconnection      *amqp.Connection\n\tchannel         *amqp.Channel\n\tdone            chan bool\n\tnotifyConnClose chan *amqp.Error\n\tnotifyChanClose chan *amqp.Error\n\tnotifyConfirm   chan amqp.Confirmation\n\tisReady         bool\n}\n\nconst (\n\t// When reconnecting to the server after connection failure\n\treconnectDelay = 5 * time.Second\n\n\t// When setting up the channel after a channel exception\n\treInitDelay = 2 * time.Second\n\n\t// When resending messages the server didn't confirm\n\tresendDelay = 5 * time.Second\n)\n\nvar (\n\terrNotConnected  = errors.New(\"not connected to a server\")\n\terrAlreadyClosed = errors.New(\"already closed: not connected to the server\")\n\terrShutdown      = errors.New(\"session is shutting down\")\n)\n\n// New creates a new consumer state instance, and automatically\n// attempts to connect to the server.\nfunc New(name string, addr string) *Session {\n\tsession := Session{\n\t\tlogger: log.New(os.Stdout, \"\", log.LstdFlags),\n\t\tname:   name,\n\t\tdone:   make(chan bool),\n\t}\n\tgo session.handleReconnect(addr)\n\treturn &session\n}\n\n// handleReconnect will wait for a connection error on\n// notifyConnClose, and then continuously attempt to reconnect.\nfunc (session *Session) handleReconnect(addr string) {\n\tfor {\n\t\tsession.isReady = false\n\t\tlog.Println(\"Attempting to connect\")\n\n\t\tconn, err := session.connect(addr)\n\n\t\tif err != nil {\n\t\t\tlog.Println(\"Failed to connect. Retrying...\")\n\n\t\t\tselect {\n\t\t\tcase <-session.done:\n\t\t\t\treturn\n\t\t\tcase <-time.After(reconnectDelay):\n\t\t\t}\n\t\t\tcontinue\n\t\t}\n\n\t\tif done := session.handleReInit(conn); done {\n\t\t\tbreak\n\t\t}\n\t}\n}\n\n// connect will create a new AMQP connection\nfunc (session *Session) connect(addr string) (*amqp.Connection, error) {\n\tconn, err := amqp.Dial(addr)\n\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tsession.changeConnection(conn)\n\tlog.Println(\"Connected!\")\n\treturn conn, nil\n}\n\n// handleReconnect will wait for a channel error\n// and then continuously attempt to re-initialize both channels\nfunc (session *Session) handleReInit(conn *amqp.Connection) bool {\n\tfor {\n\t\tsession.isReady = false\n\n\t\terr := session.init(conn)\n\n\t\tif err != nil {\n\t\t\tlog.Println(\"Failed to initialize channel. Retrying...\")\n\n\t\t\tselect {\n\t\t\tcase <-session.done:\n\t\t\t\treturn true\n\t\t\tcase <-time.After(reInitDelay):\n\t\t\t}\n\t\t\tcontinue\n\t\t}\n\n\t\tselect {\n\t\tcase <-session.done:\n\t\t\treturn true\n\t\tcase <-session.notifyConnClose:\n\t\t\tlog.Println(\"Connection closed. Reconnecting...\")\n\t\t\treturn false\n\t\tcase <-session.notifyChanClose:\n\t\t\tlog.Println(\"Channel closed. Re-running init...\")\n\t\t}\n\t}\n}\n\n// init will initialize channel & declare queue\nfunc (session *Session) init(conn *amqp.Connection) error {\n\tch, err := conn.Channel()\n\n\tif err != nil {\n\t\treturn err\n\t}\n\n\terr = ch.Confirm(false)\n\n\tif err != nil {\n\t\treturn err\n\t}\n\t_, err = ch.QueueDeclare(\n\t\tsession.name,\n\t\tfalse, // Durable\n\t\tfalse, // Delete when unused\n\t\tfalse, // Exclusive\n\t\tfalse, // No-wait\n\t\tnil,   // Arguments\n\t)\n\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tsession.changeChannel(ch)\n\tsession.isReady = true\n\tlog.Println(\"Setup!\")\n\n\treturn nil\n}\n\n// changeConnection takes a new connection to the queue,\n// and updates the close listener to reflect this.\nfunc (session *Session) changeConnection(connection *amqp.Connection) {\n\tsession.connection = connection\n\tsession.notifyConnClose = make(chan *amqp.Error)\n\tsession.connection.NotifyClose(session.notifyConnClose)\n}\n\n// changeChannel takes a new channel to the queue,\n// and updates the channel listeners to reflect this.\nfunc (session *Session) changeChannel(channel *amqp.Channel) {\n\tsession.channel = channel\n\tsession.notifyChanClose = make(chan *amqp.Error)\n\tsession.notifyConfirm = make(chan amqp.Confirmation, 1)\n\tsession.channel.NotifyClose(session.notifyChanClose)\n\tsession.channel.NotifyPublish(session.notifyConfirm)\n}\n\n// Push will push data onto the queue, and wait for a confirm.\n// If no confirms are received until within the resendTimeout,\n// it continuously re-sends messages until a confirm is received.\n// This will block until the server sends a confirm. Errors are\n// only returned if the push action itself fails, see UnsafePush.\nfunc (session *Session) Push(data []byte) error {\n\tif !session.isReady {\n\t\treturn errors.New(\"failed to push: not connected\")\n\t}\n\tfor {\n\t\terr := session.UnsafePush(data)\n\t\tif err != nil {\n\t\t\tsession.logger.Println(\"Push failed. Retrying...\")\n\t\t\tselect {\n\t\t\tcase <-session.done:\n\t\t\t\treturn errShutdown\n\t\t\tcase <-time.After(resendDelay):\n\t\t\t}\n\t\t\tcontinue\n\t\t}\n\t\tselect {\n\t\tcase confirm := <-session.notifyConfirm:\n\t\t\tif confirm.Ack {\n\t\t\t\tsession.logger.Println(\"Push confirmed!\")\n\t\t\t\treturn nil\n\t\t\t}\n\t\tcase <-time.After(resendDelay):\n\t\t}\n\t\tsession.logger.Println(\"Push didn't confirm. Retrying...\")\n\t}\n}\n\n// UnsafePush will push to the queue without checking for\n// confirmation. It returns an error if it fails to connect.\n// No guarantees are provided for whether the server will\n// recieve the message.\nfunc (session *Session) UnsafePush(data []byte) error {\n\tif !session.isReady {\n\t\treturn errNotConnected\n\t}\n\treturn session.channel.Publish(\n\t\t\"\",           // Exchange\n\t\tsession.name, // Routing key\n\t\tfalse,        // Mandatory\n\t\tfalse,        // Immediate\n\t\tamqp.Publishing{\n\t\t\tContentType: \"text/plain\",\n\t\t\tBody:        data,\n\t\t},\n\t)\n}\n\n// Stream will continuously put queue items on the channel.\n// It is required to call delivery.Ack when it has been\n// successfully processed, or delivery.Nack when it fails.\n// Ignoring this will cause data to build up on the server.\nfunc (session *Session) Stream() (<-chan amqp.Delivery, error) {\n\tif !session.isReady {\n\t\treturn nil, errNotConnected\n\t}\n\treturn session.channel.Consume(\n\t\tsession.name,\n\t\t\"\",    // Consumer\n\t\tfalse, // Auto-Ack\n\t\tfalse, // Exclusive\n\t\tfalse, // No-local\n\t\tfalse, // No-Wait\n\t\tnil,   // Args\n\t)\n}\n\n// Close will cleanly shutdown the channel and connection.\nfunc (session *Session) Close() error {\n\tif !session.isReady {\n\t\treturn errAlreadyClosed\n\t}\n\terr := session.channel.Close()\n\tif err != nil {\n\t\treturn err\n\t}\n\terr = session.connection.Close()\n\tif err != nil {\n\t\treturn err\n\t}\n\tclose(session.done)\n\tsession.isReady = false\n\treturn nil\n}\n"
        },
        {
          "name": "examples_test.go",
          "type": "blob",
          "size": 11.896484375,
          "content": "package amqp_test\n\nimport (\n\t\"crypto/tls\"\n\t\"crypto/x509\"\n\t\"io/ioutil\"\n\t\"log\"\n\t\"net\"\n\t\"runtime\"\n\t\"time\"\n\n\t\"github.com/streadway/amqp\"\n)\n\nfunc ExampleConfig_timeout() {\n\t// Provide your own anonymous Dial function that delgates to net.DialTimout\n\t// for custom timeouts\n\n\tconn, err := amqp.DialConfig(\"amqp:///\", amqp.Config{\n\t\tDial: func(network, addr string) (net.Conn, error) {\n\t\t\treturn net.DialTimeout(network, addr, 2*time.Second)\n\t\t},\n\t})\n\n\tlog.Printf(\"conn: %v, err: %v\", conn, err)\n}\n\nfunc ExampleDialTLS() {\n\t// This example assume you have a RabbitMQ node running on localhost\n\t// with TLS enabled.\n\t//\n\t// The easiest way to create the CA, certificates and keys required for these\n\t// examples is by using tls-gen: https://github.com/michaelklishin/tls-gen\n\t//\n\t// A comprehensive RabbitMQ TLS guide can be found at\n\t// http://www.rabbitmq.com/ssl.html\n\t//\n\t// Once you have the required TLS files in place, use the following\n\t// rabbitmq.config example for the RabbitMQ node that you will run on\n\t// localhost:\n\t//\n\t//   [\n\t//   {rabbit, [\n\t//     {tcp_listeners, []},     % listens on 127.0.0.1:5672\n\t//     {ssl_listeners, [5671]}, % listens on 0.0.0.0:5671\n\t//     {ssl_options, [{cacertfile,\"/path/to/your/testca/cacert.pem\"},\n\t//                    {certfile,\"/path/to/your/server/cert.pem\"},\n\t//                    {keyfile,\"/path/to/your/server/key.pem\"},\n\t//                    {verify,verify_peer},\n\t//                    {fail_if_no_peer_cert,true}]}\n\t//     ]}\n\t//   ].\n\t//\n\t//\n\t// In the above rabbitmq.config example, we are disabling the plain AMQP port\n\t// and verifying that clients and fail if no certificate is presented.\n\t//\n\t// The self-signing certificate authority's certificate (cacert.pem) must be\n\t// included in the RootCAs to be trusted, otherwise the server certificate\n\t// will fail certificate verification.\n\t//\n\t// Alternatively to adding it to the tls.Config. you can add the CA's cert to\n\t// your system's root CAs.  The tls package will use the system roots\n\t// specific to each support OS.  Under OS X, add (drag/drop) cacert.pem\n\t// file to the 'Certificates' section of KeyChain.app to add and always\n\t// trust.  You can also add it via the command line:\n\t//\n\t//   security add-certificate testca/cacert.pem\n\t//   security add-trusted-cert testca/cacert.pem\n\t//\n\t// If you depend on the system root CAs, then use nil for the RootCAs field\n\t// so the system roots will be loaded instead.\n\t//\n\t// Server names are validated by the crypto/tls package, so the server\n\t// certificate must be made for the hostname in the URL.  Find the commonName\n\t// (CN) and make sure the hostname in the URL matches this common name.  Per\n\t// the RabbitMQ instructions (or tls-gen) for a self-signed cert, this defaults to the\n\t// current hostname.\n\t//\n\t//   openssl x509 -noout -in /path/to/certificate.pem -subject\n\t//\n\t// If your server name in your certificate is different than the host you are\n\t// connecting to, set the hostname used for verification in\n\t// ServerName field of the tls.Config struct.\n\tcfg := new(tls.Config)\n\n\t// see at the top\n\tcfg.RootCAs = x509.NewCertPool()\n\n\tif ca, err := ioutil.ReadFile(\"testca/cacert.pem\"); err == nil {\n\t\tcfg.RootCAs.AppendCertsFromPEM(ca)\n\t}\n\n\t// Move the client cert and key to a location specific to your application\n\t// and load them here.\n\n\tif cert, err := tls.LoadX509KeyPair(\"client/cert.pem\", \"client/key.pem\"); err == nil {\n\t\tcfg.Certificates = append(cfg.Certificates, cert)\n\t}\n\n\t// see a note about Common Name (CN) at the top\n\tconn, err := amqp.DialTLS(\"amqps://server-name-from-certificate/\", cfg)\n\n\tlog.Printf(\"conn: %v, err: %v\", conn, err)\n}\n\nfunc ExampleChannel_Confirm_bridge() {\n\t// This example acts as a bridge, shoveling all messages sent from the source\n\t// exchange \"log\" to destination exchange \"log\".\n\n\t// Confirming publishes can help from overproduction and ensure every message\n\t// is delivered.\n\n\t// Setup the source of the store and forward\n\tsource, err := amqp.Dial(\"amqp://source/\")\n\tif err != nil {\n\t\tlog.Fatalf(\"connection.open source: %s\", err)\n\t}\n\tdefer source.Close()\n\n\tchs, err := source.Channel()\n\tif err != nil {\n\t\tlog.Fatalf(\"channel.open source: %s\", err)\n\t}\n\n\tif err := chs.ExchangeDeclare(\"log\", \"topic\", true, false, false, false, nil); err != nil {\n\t\tlog.Fatalf(\"exchange.declare destination: %s\", err)\n\t}\n\n\tif _, err := chs.QueueDeclare(\"remote-tee\", true, true, false, false, nil); err != nil {\n\t\tlog.Fatalf(\"queue.declare source: %s\", err)\n\t}\n\n\tif err := chs.QueueBind(\"remote-tee\", \"#\", \"logs\", false, nil); err != nil {\n\t\tlog.Fatalf(\"queue.bind source: %s\", err)\n\t}\n\n\tshovel, err := chs.Consume(\"remote-tee\", \"shovel\", false, false, false, false, nil)\n\tif err != nil {\n\t\tlog.Fatalf(\"basic.consume source: %s\", err)\n\t}\n\n\t// Setup the destination of the store and forward\n\tdestination, err := amqp.Dial(\"amqp://destination/\")\n\tif err != nil {\n\t\tlog.Fatalf(\"connection.open destination: %s\", err)\n\t}\n\tdefer destination.Close()\n\n\tchd, err := destination.Channel()\n\tif err != nil {\n\t\tlog.Fatalf(\"channel.open destination: %s\", err)\n\t}\n\n\tif err := chd.ExchangeDeclare(\"log\", \"topic\", true, false, false, false, nil); err != nil {\n\t\tlog.Fatalf(\"exchange.declare destination: %s\", err)\n\t}\n\n\t// Buffer of 1 for our single outstanding publishing\n\tconfirms := chd.NotifyPublish(make(chan amqp.Confirmation, 1))\n\n\tif err := chd.Confirm(false); err != nil {\n\t\tlog.Fatalf(\"confirm.select destination: %s\", err)\n\t}\n\n\t// Now pump the messages, one by one, a smarter implementation\n\t// would batch the deliveries and use multiple ack/nacks\n\tfor {\n\t\tmsg, ok := <-shovel\n\t\tif !ok {\n\t\t\tlog.Fatalf(\"source channel closed, see the reconnect example for handling this\")\n\t\t}\n\n\t\terr = chd.Publish(\"logs\", msg.RoutingKey, false, false, amqp.Publishing{\n\t\t\t// Copy all the properties\n\t\t\tContentType:     msg.ContentType,\n\t\t\tContentEncoding: msg.ContentEncoding,\n\t\t\tDeliveryMode:    msg.DeliveryMode,\n\t\t\tPriority:        msg.Priority,\n\t\t\tCorrelationId:   msg.CorrelationId,\n\t\t\tReplyTo:         msg.ReplyTo,\n\t\t\tExpiration:      msg.Expiration,\n\t\t\tMessageId:       msg.MessageId,\n\t\t\tTimestamp:       msg.Timestamp,\n\t\t\tType:            msg.Type,\n\t\t\tUserId:          msg.UserId,\n\t\t\tAppId:           msg.AppId,\n\n\t\t\t// Custom headers\n\t\t\tHeaders: msg.Headers,\n\n\t\t\t// And the body\n\t\t\tBody: msg.Body,\n\t\t})\n\n\t\tif err != nil {\n\t\t\tmsg.Nack(false, false)\n\t\t\tlog.Fatalf(\"basic.publish destination: %+v\", msg)\n\t\t}\n\n\t\t// only ack the source delivery when the destination acks the publishing\n\t\tif confirmed := <-confirms; confirmed.Ack {\n\t\t\tmsg.Ack(false)\n\t\t} else {\n\t\t\tmsg.Nack(false, false)\n\t\t}\n\t}\n}\n\nfunc ExampleChannel_Consume() {\n\t// Connects opens an AMQP connection from the credentials in the URL.\n\tconn, err := amqp.Dial(\"amqp://guest:guest@localhost:5672/\")\n\tif err != nil {\n\t\tlog.Fatalf(\"connection.open: %s\", err)\n\t}\n\tdefer conn.Close()\n\n\tc, err := conn.Channel()\n\tif err != nil {\n\t\tlog.Fatalf(\"channel.open: %s\", err)\n\t}\n\n\t// We declare our topology on both the publisher and consumer to ensure they\n\t// are the same.  This is part of AMQP being a programmable messaging model.\n\t//\n\t// See the Channel.Publish example for the complimentary declare.\n\terr = c.ExchangeDeclare(\"logs\", \"topic\", true, false, false, false, nil)\n\tif err != nil {\n\t\tlog.Fatalf(\"exchange.declare: %s\", err)\n\t}\n\n\t// Establish our queue topologies that we are responsible for\n\ttype bind struct {\n\t\tqueue string\n\t\tkey   string\n\t}\n\n\tbindings := []bind{\n\t\t{\"page\", \"alert\"},\n\t\t{\"email\", \"info\"},\n\t\t{\"firehose\", \"#\"},\n\t}\n\n\tfor _, b := range bindings {\n\t\t_, err = c.QueueDeclare(b.queue, true, false, false, false, nil)\n\t\tif err != nil {\n\t\t\tlog.Fatalf(\"queue.declare: %v\", err)\n\t\t}\n\n\t\terr = c.QueueBind(b.queue, b.key, \"logs\", false, nil)\n\t\tif err != nil {\n\t\t\tlog.Fatalf(\"queue.bind: %v\", err)\n\t\t}\n\t}\n\n\t// Set our quality of service.  Since we're sharing 3 consumers on the same\n\t// channel, we want at least 3 messages in flight.\n\terr = c.Qos(3, 0, false)\n\tif err != nil {\n\t\tlog.Fatalf(\"basic.qos: %v\", err)\n\t}\n\n\t// Establish our consumers that have different responsibilities.  Our first\n\t// two queues do not ack the messages on the server, so require to be acked\n\t// on the client.\n\n\tpages, err := c.Consume(\"page\", \"pager\", false, false, false, false, nil)\n\tif err != nil {\n\t\tlog.Fatalf(\"basic.consume: %v\", err)\n\t}\n\n\tgo func() {\n\t\tfor log := range pages {\n\t\t\t// ... this consumer is responsible for sending pages per log\n\t\t\tlog.Ack(false)\n\t\t}\n\t}()\n\n\t// Notice how the concern for which messages arrive here are in the AMQP\n\t// topology and not in the queue.  We let the server pick a consumer tag this\n\t// time.\n\n\temails, err := c.Consume(\"email\", \"\", false, false, false, false, nil)\n\tif err != nil {\n\t\tlog.Fatalf(\"basic.consume: %v\", err)\n\t}\n\n\tgo func() {\n\t\tfor log := range emails {\n\t\t\t// ... this consumer is responsible for sending emails per log\n\t\t\tlog.Ack(false)\n\t\t}\n\t}()\n\n\t// This consumer requests that every message is acknowledged as soon as it's\n\t// delivered.\n\n\tfirehose, err := c.Consume(\"firehose\", \"\", true, false, false, false, nil)\n\tif err != nil {\n\t\tlog.Fatalf(\"basic.consume: %v\", err)\n\t}\n\n\t// To show how to process the items in parallel, we'll use a work pool.\n\tfor i := 0; i < runtime.NumCPU(); i++ {\n\t\tgo func(work <-chan amqp.Delivery) {\n\t\t\tfor range work {\n\t\t\t\t// ... this consumer pulls from the firehose and doesn't need to acknowledge\n\t\t\t}\n\t\t}(firehose)\n\t}\n\n\t// Wait until you're ready to finish, could be a signal handler here.\n\ttime.Sleep(10 * time.Second)\n\n\t// Cancelling a consumer by name will finish the range and gracefully end the\n\t// goroutine\n\terr = c.Cancel(\"pager\", false)\n\tif err != nil {\n\t\tlog.Fatalf(\"basic.cancel: %v\", err)\n\t}\n\n\t// deferred closing the Connection will also finish the consumer's ranges of\n\t// their delivery chans.  If you need every delivery to be processed, make\n\t// sure to wait for all consumers goroutines to finish before exiting your\n\t// process.\n}\n\nfunc ExampleChannel_Publish() {\n\t// Connects opens an AMQP connection from the credentials in the URL.\n\tconn, err := amqp.Dial(\"amqp://guest:guest@localhost:5672/\")\n\tif err != nil {\n\t\tlog.Fatalf(\"connection.open: %s\", err)\n\t}\n\n\t// This waits for a server acknowledgment which means the sockets will have\n\t// flushed all outbound publishings prior to returning.  It's important to\n\t// block on Close to not lose any publishings.\n\tdefer conn.Close()\n\n\tc, err := conn.Channel()\n\tif err != nil {\n\t\tlog.Fatalf(\"channel.open: %s\", err)\n\t}\n\n\t// We declare our topology on both the publisher and consumer to ensure they\n\t// are the same.  This is part of AMQP being a programmable messaging model.\n\t//\n\t// See the Channel.Consume example for the complimentary declare.\n\terr = c.ExchangeDeclare(\"logs\", \"topic\", true, false, false, false, nil)\n\tif err != nil {\n\t\tlog.Fatalf(\"exchange.declare: %v\", err)\n\t}\n\n\t// Prepare this message to be persistent.  Your publishing requirements may\n\t// be different.\n\tmsg := amqp.Publishing{\n\t\tDeliveryMode: amqp.Persistent,\n\t\tTimestamp:    time.Now(),\n\t\tContentType:  \"text/plain\",\n\t\tBody:         []byte(\"Go Go AMQP!\"),\n\t}\n\n\t// This is not a mandatory delivery, so it will be dropped if there are no\n\t// queues bound to the logs exchange.\n\terr = c.Publish(\"logs\", \"info\", false, false, msg)\n\tif err != nil {\n\t\t// Since publish is asynchronous this can happen if the network connection\n\t\t// is reset or if the server has run out of resources.\n\t\tlog.Fatalf(\"basic.publish: %v\", err)\n\t}\n}\n\nfunc publishAllTheThings(conn *amqp.Connection) {\n\t// ... snarf snarf, barf barf\n}\n\nfunc ExampleConnection_NotifyBlocked() {\n\t// Simply logs when the server throttles the TCP connection for publishers\n\n\t// Test this by tuning your server to have a low memory watermark:\n\t// rabbitmqctl set_vm_memory_high_watermark 0.00000001\n\n\tconn, err := amqp.Dial(\"amqp://guest:guest@localhost:5672/\")\n\tif err != nil {\n\t\tlog.Fatalf(\"connection.open: %s\", err)\n\t}\n\tdefer conn.Close()\n\n\tblockings := conn.NotifyBlocked(make(chan amqp.Blocking))\n\tgo func() {\n\t\tfor b := range blockings {\n\t\t\tif b.Active {\n\t\t\t\tlog.Printf(\"TCP blocked: %q\", b.Reason)\n\t\t\t} else {\n\t\t\t\tlog.Printf(\"TCP unblocked\")\n\t\t\t}\n\t\t}\n\t}()\n\n\t// Your application domain channel setup publishings\n\tpublishAllTheThings(conn)\n}\n"
        },
        {
          "name": "fuzz.go",
          "type": "blob",
          "size": 0.232421875,
          "content": "// +build gofuzz\n\npackage amqp\n\nimport \"bytes\"\n\nfunc Fuzz(data []byte) int {\n\tr := reader{bytes.NewReader(data)}\n\tframe, err := r.ReadFrame()\n\tif err != nil {\n\t\tif frame != nil {\n\t\t\tpanic(\"frame is not nil\")\n\t\t}\n\t\treturn 0\n\t}\n\treturn 1\n}\n"
        },
        {
          "name": "gen.sh",
          "type": "blob",
          "size": 0.0869140625,
          "content": "#!/bin/sh\ngo run spec/gen.go < spec/amqp0-9-1.stripped.extended.xml | gofmt > spec091.go\n"
        },
        {
          "name": "go.mod",
          "type": "blob",
          "size": 0.12109375,
          "content": "// Deprecated: Consider using the github.com/rabbitmq/amqp091-go package instead.\nmodule github.com/streadway/amqp\n\ngo 1.10\n"
        },
        {
          "name": "integration_test.go",
          "type": "blob",
          "size": 45.294921875,
          "content": "// Copyright (c) 2012, Sean Treadway, SoundCloud Ltd.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n// Source code and contact info at http://github.com/streadway/amqp\n\n// +build integration\n\npackage amqp\n\nimport (\n\t\"bytes\"\n\tdevrand \"crypto/rand\"\n\t\"encoding/binary\"\n\t\"fmt\"\n\t\"hash/crc32\"\n\t\"io\"\n\t\"math/rand\"\n\t\"net\"\n\t\"os\"\n\t\"reflect\"\n\t\"strconv\"\n\t\"sync\"\n\t\"testing\"\n\t\"testing/quick\"\n\t\"time\"\n)\n\nfunc TestIntegrationOpenClose(t *testing.T) {\n\tif c := integrationConnection(t, \"open-close\"); c != nil {\n\t\tt.Logf(\"have connection, calling connection close\")\n\t\tif err := c.Close(); err != nil {\n\t\t\tt.Fatalf(\"connection close: %s\", err)\n\t\t}\n\t\tt.Logf(\"connection close OK\")\n\t}\n}\n\nfunc TestIntegrationOpenCloseChannel(t *testing.T) {\n\tif c := integrationConnection(t, \"channel\"); c != nil {\n\t\tdefer c.Close()\n\n\t\tch, err := c.Channel()\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"create channel 1: %s\", err)\n\t\t}\n\t\tch.Close()\n\t}\n}\n\nfunc TestIntegrationHighChannelChurnInTightLoop(t *testing.T) {\n\tif c := integrationConnection(t, \"channel churn\"); c != nil {\n\t\tdefer c.Close()\n\n\t\tfor i := 0; i < 1000; i++ {\n\t\t\tch, err := c.Channel()\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"create channel 1: %s\", err)\n\t\t\t}\n\t\t\tch.Close()\n\t\t}\n\t}\n}\n\nfunc TestIntegrationOpenConfig(t *testing.T) {\n\tconfig := Config{}\n\n\tc, err := DialConfig(integrationURLFromEnv(), config)\n\tif err != nil {\n\t\tt.Fatalf(\"expected to dial with config %+v integration server: %s\", config, err)\n\t}\n\n\tif _, err := c.Channel(); err != nil {\n\t\tt.Errorf(\"expected to open channel: %s\", err)\n\t}\n\n\tif err := c.Close(); err != nil {\n\t\tt.Errorf(\"expected to close the connection: %s\", err)\n\t}\n}\n\nfunc TestIntegrationOpenConfigWithNetDial(t *testing.T) {\n\tconfig := Config{Dial: net.Dial}\n\n\tc, err := DialConfig(integrationURLFromEnv(), config)\n\tif err != nil {\n\t\tt.Fatalf(\"expected to dial with config %+v integration server: %s\", config, err)\n\t}\n\n\tif _, err := c.Channel(); err != nil {\n\t\tt.Errorf(\"expected to open channel: %s\", err)\n\t}\n\n\tif err := c.Close(); err != nil {\n\t\tt.Errorf(\"expected to close the connection: %s\", err)\n\t}\n}\n\nfunc TestIntegrationLocalAddr(t *testing.T) {\n\tconfig := Config{}\n\n\tc, err := DialConfig(integrationURLFromEnv(), config)\n\tif err != nil {\n\t\tt.Fatalf(\"expected to dial with config %+v integration server: %s\", config, err)\n\t}\n\tdefer c.Close()\n\n\ta := c.LocalAddr()\n\t_, portString, err := net.SplitHostPort(a.String())\n\tif err != nil {\n\t\tt.Errorf(\"expected to get a local network address with config %+v integration server: %s\", config, a.String())\n\t}\n\n\tport, err := strconv.Atoi(portString)\n\tif err != nil {\n\t\tt.Errorf(\"expected to get a TCP port number with config %+v integration server: %s\", config, err)\n\t}\n\tt.Logf(\"Connected to port %d\\n\", port)\n}\n\n// https://github.com/streadway/amqp/issues/94\nfunc TestExchangePassiveOnMissingExchangeShouldError(t *testing.T) {\n\tc := integrationConnection(t, \"exch\")\n\tif c != nil {\n\t\tdefer c.Close()\n\n\t\tch, err := c.Channel()\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"create channel 1: %s\", err)\n\t\t}\n\t\tdefer ch.Close()\n\n\t\tif err := ch.ExchangeDeclarePassive(\n\t\t\t\"test-integration-missing-passive-exchange\",\n\t\t\t\"direct\", // type\n\t\t\tfalse,    // duration (note: is durable)\n\t\t\ttrue,     // auto-delete\n\t\t\tfalse,    // internal\n\t\t\tfalse,    // nowait\n\t\t\tnil,      // args\n\t\t); err == nil {\n\t\t\tt.Fatal(\"ExchangeDeclarePassive of a missing exchange should return error\")\n\t\t}\n\t}\n}\n\n// https://github.com/streadway/amqp/issues/94\nfunc TestIntegrationExchangeDeclarePassiveOnDeclaredShouldNotError(t *testing.T) {\n\tc := integrationConnection(t, \"exch\")\n\tif c != nil {\n\t\tdefer c.Close()\n\n\t\texchange := \"test-integration-declared-passive-exchange\"\n\n\t\tch, err := c.Channel()\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"create channel: %s\", err)\n\t\t}\n\t\tdefer ch.Close()\n\n\t\tif err := ch.ExchangeDeclare(\n\t\t\texchange, // name\n\t\t\t\"direct\", // type\n\t\t\tfalse,    // durable\n\t\t\ttrue,     // auto-delete\n\t\t\tfalse,    // internal\n\t\t\tfalse,    // nowait\n\t\t\tnil,      // args\n\t\t); err != nil {\n\t\t\tt.Fatalf(\"declare exchange: %s\", err)\n\t\t}\n\n\t\tif err := ch.ExchangeDeclarePassive(\n\t\t\texchange, // name\n\t\t\t\"direct\", // type\n\t\t\tfalse,    // durable\n\t\t\ttrue,     // auto-delete\n\t\t\tfalse,    // internal\n\t\t\tfalse,    // nowait\n\t\t\tnil,      // args\n\t\t); err != nil {\n\t\t\tt.Fatalf(\"ExchangeDeclarePassive on a declared exchange should not error, got: %q\", err)\n\t\t}\n\t}\n}\n\nfunc TestIntegrationExchange(t *testing.T) {\n\tc := integrationConnection(t, \"exch\")\n\tif c != nil {\n\t\tdefer c.Close()\n\n\t\tchannel, err := c.Channel()\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"create channel: %s\", err)\n\t\t}\n\t\tt.Logf(\"create channel OK\")\n\n\t\texchange := \"test-integration-exchange\"\n\n\t\tif err := channel.ExchangeDeclare(\n\t\t\texchange, // name\n\t\t\t\"direct\", // type\n\t\t\tfalse,    // duration\n\t\t\ttrue,     // auto-delete\n\t\t\tfalse,    // internal\n\t\t\tfalse,    // nowait\n\t\t\tnil,      // args\n\t\t); err != nil {\n\t\t\tt.Fatalf(\"declare exchange: %s\", err)\n\t\t}\n\t\tt.Logf(\"declare exchange OK\")\n\n\t\tif err := channel.ExchangeDelete(exchange, false, false); err != nil {\n\t\t\tt.Fatalf(\"delete exchange: %s\", err)\n\t\t}\n\t\tt.Logf(\"delete exchange OK\")\n\n\t\tif err := channel.Close(); err != nil {\n\t\t\tt.Fatalf(\"close channel: %s\", err)\n\t\t}\n\t\tt.Logf(\"close channel OK\")\n\t}\n}\n\n// https://github.com/streadway/amqp/issues/94\nfunc TestIntegrationQueueDeclarePassiveOnMissingExchangeShouldError(t *testing.T) {\n\tc := integrationConnection(t, \"queue\")\n\tif c != nil {\n\t\tdefer c.Close()\n\n\t\tch, err := c.Channel()\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"create channel1: %s\", err)\n\t\t}\n\t\tdefer ch.Close()\n\n\t\tif _, err := ch.QueueDeclarePassive(\n\t\t\t\"test-integration-missing-passive-queue\", // name\n\t\t\tfalse,                                    // duration (note: not durable)\n\t\t\ttrue,                                     // auto-delete\n\t\t\tfalse,                                    // exclusive\n\t\t\tfalse,                                    // noWait\n\t\t\tnil,                                      // arguments\n\t\t); err == nil {\n\t\t\tt.Fatal(\"QueueDeclarePassive of a missing queue should error\")\n\t\t}\n\t}\n}\n\n// https://github.com/streadway/amqp/issues/94\nfunc TestIntegrationPassiveQueue(t *testing.T) {\n\tc := integrationConnection(t, \"queue\")\n\tif c != nil {\n\t\tdefer c.Close()\n\n\t\tname := \"test-integration-declared-passive-queue\"\n\n\t\tch, err := c.Channel()\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"create channel1: %s\", err)\n\t\t}\n\t\tdefer ch.Close()\n\n\t\tif _, err := ch.QueueDeclare(\n\t\t\tname,  // name\n\t\t\tfalse, // durable\n\t\t\ttrue,  // auto-delete\n\t\t\tfalse, // exclusive\n\t\t\tfalse, // noWait\n\t\t\tnil,   // arguments\n\t\t); err != nil {\n\t\t\tt.Fatalf(\"queue declare: %s\", err)\n\t\t}\n\n\t\tif _, err := ch.QueueDeclarePassive(\n\t\t\tname,  // name\n\t\t\tfalse, // durable\n\t\t\ttrue,  // auto-delete\n\t\t\tfalse, // exclusive\n\t\t\tfalse, // noWait\n\t\t\tnil,   // arguments\n\t\t); err != nil {\n\t\t\tt.Fatalf(\"QueueDeclarePassive on declared queue should not error, got: %q\", err)\n\t\t}\n\n\t\tif _, err := ch.QueueDeclarePassive(\n\t\t\tname,  // name\n\t\t\ttrue,  // durable (note: differs)\n\t\t\ttrue,  // auto-delete\n\t\t\tfalse, // exclusive\n\t\t\tfalse, // noWait\n\t\t\tnil,   // arguments\n\t\t); err != nil {\n\t\t\tt.Fatalf(\"QueueDeclarePassive on declared queue with different flags should error\")\n\t\t}\n\t}\n}\n\nfunc TestIntegrationBasicQueueOperations(t *testing.T) {\n\tc := integrationConnection(t, \"queue\")\n\tif c != nil {\n\t\tdefer c.Close()\n\n\t\tchannel, err := c.Channel()\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"create channel: %s\", err)\n\t\t}\n\t\tt.Logf(\"create channel OK\")\n\n\t\texchangeName := \"test-basic-ops-exchange\"\n\t\tqueueName := \"test-basic-ops-queue\"\n\n\t\tdeleteQueueFirstOptions := []bool{true, false}\n\t\tfor _, deleteQueueFirst := range deleteQueueFirstOptions {\n\n\t\t\tif err := channel.ExchangeDeclare(\n\t\t\t\texchangeName, // name\n\t\t\t\t\"direct\",     // type\n\t\t\t\ttrue,         // duration (note: is durable)\n\t\t\t\tfalse,        // auto-delete\n\t\t\t\tfalse,        // internal\n\t\t\t\tfalse,        // nowait\n\t\t\t\tnil,          // args\n\t\t\t); err != nil {\n\t\t\t\tt.Fatalf(\"declare exchange: %s\", err)\n\t\t\t}\n\t\t\tt.Logf(\"declare exchange OK\")\n\n\t\t\tif _, err := channel.QueueDeclare(\n\t\t\t\tqueueName, // name\n\t\t\t\ttrue,      // duration (note: durable)\n\t\t\t\tfalse,     // auto-delete\n\t\t\t\tfalse,     // exclusive\n\t\t\t\tfalse,     // noWait\n\t\t\t\tnil,       // arguments\n\t\t\t); err != nil {\n\t\t\t\tt.Fatalf(\"queue declare: %s\", err)\n\t\t\t}\n\t\t\tt.Logf(\"declare queue OK\")\n\n\t\t\tif err := channel.QueueBind(\n\t\t\t\tqueueName,    // name\n\t\t\t\t\"\",           // routingKey\n\t\t\t\texchangeName, // sourceExchange\n\t\t\t\tfalse,        // noWait\n\t\t\t\tnil,          // arguments\n\t\t\t); err != nil {\n\t\t\t\tt.Fatalf(\"queue bind: %s\", err)\n\t\t\t}\n\t\t\tt.Logf(\"queue bind OK\")\n\n\t\t\tif deleteQueueFirst {\n\t\t\t\tif _, err := channel.QueueDelete(\n\t\t\t\t\tqueueName, // name\n\t\t\t\t\tfalse,     // ifUnused (false=be aggressive)\n\t\t\t\t\tfalse,     // ifEmpty (false=be aggressive)\n\t\t\t\t\tfalse,     // noWait\n\t\t\t\t); err != nil {\n\t\t\t\t\tt.Fatalf(\"delete queue (first): %s\", err)\n\t\t\t\t}\n\t\t\t\tt.Logf(\"delete queue (first) OK\")\n\n\t\t\t\tif err := channel.ExchangeDelete(exchangeName, false, false); err != nil {\n\t\t\t\t\tt.Fatalf(\"delete exchange (after delete queue): %s\", err)\n\t\t\t\t}\n\t\t\t\tt.Logf(\"delete exchange (after delete queue) OK\")\n\n\t\t\t} else { // deleteExchangeFirst\n\t\t\t\tif err := channel.ExchangeDelete(exchangeName, false, false); err != nil {\n\t\t\t\t\tt.Fatalf(\"delete exchange (first): %s\", err)\n\t\t\t\t}\n\t\t\t\tt.Logf(\"delete exchange (first) OK\")\n\n\t\t\t\tif _, err := channel.QueueInspect(queueName); err != nil {\n\t\t\t\t\tt.Fatalf(\"inspect queue state after deleting exchange: %s\", err)\n\t\t\t\t}\n\t\t\t\tt.Logf(\"queue properly remains after exchange is deleted\")\n\n\t\t\t\tif _, err := channel.QueueDelete(\n\t\t\t\t\tqueueName,\n\t\t\t\t\tfalse, // ifUnused\n\t\t\t\t\tfalse, // ifEmpty\n\t\t\t\t\tfalse, // noWait\n\t\t\t\t); err != nil {\n\t\t\t\t\tt.Fatalf(\"delete queue (after delete exchange): %s\", err)\n\t\t\t\t}\n\t\t\t\tt.Logf(\"delete queue (after delete exchange) OK\")\n\t\t\t}\n\t\t}\n\n\t\tif err := channel.Close(); err != nil {\n\t\t\tt.Fatalf(\"close channel: %s\", err)\n\t\t}\n\t\tt.Logf(\"close channel OK\")\n\t}\n}\n\nfunc TestIntegrationConnectionNegotiatesMaxChannels(t *testing.T) {\n\tconfig := Config{ChannelMax: 0}\n\n\tc, err := DialConfig(integrationURLFromEnv(), config)\n\tif err != nil {\n\t\tt.Fatalf(\"expected to dial with config %+v integration server: %s\", config, err)\n\t}\n\tdefer c.Close()\n\n\tif want, got := defaultChannelMax, c.Config.ChannelMax; want != got {\n\t\tt.Errorf(\"expected connection to negotiate uint16 (%d) channels, got: %d\", want, got)\n\t}\n}\n\nfunc TestIntegrationConnectionNegotiatesClientMaxChannels(t *testing.T) {\n\tconfig := Config{ChannelMax: 16}\n\n\tc, err := DialConfig(integrationURLFromEnv(), config)\n\tif err != nil {\n\t\tt.Fatalf(\"expected to dial with config %+v integration server: %s\", config, err)\n\t}\n\tdefer c.Close()\n\n\tif want, got := config.ChannelMax, c.Config.ChannelMax; want != got {\n\t\tt.Errorf(\"expected client specified channel limit after handshake %d, got: %d\", want, got)\n\t}\n}\n\nfunc TestIntegrationChannelIDsExhausted(t *testing.T) {\n\tconfig := Config{ChannelMax: 16}\n\n\tc, err := DialConfig(integrationURLFromEnv(), config)\n\tif err != nil {\n\t\tt.Fatalf(\"expected to dial with config %+v integration server: %s\", config, err)\n\t}\n\tdefer c.Close()\n\n\tfor i := 1; i <= c.Config.ChannelMax; i++ {\n\t\tif _, err := c.Channel(); err != nil {\n\t\t\tt.Fatalf(\"expected allocating all channel ids to succed, failed on %d with %v\", i, err)\n\t\t}\n\t}\n\n\tif _, err := c.Channel(); err != ErrChannelMax {\n\t\tt.Fatalf(\"expected allocating all channels to produce the client side error %#v, got: %#v\", ErrChannelMax, err)\n\t}\n}\n\nfunc TestIntegrationChannelClosing(t *testing.T) {\n\tc := integrationConnection(t, \"closings\")\n\tif c != nil {\n\t\tdefer c.Close()\n\n\t\t// This function is run on every channel after it is successfully\n\t\t// opened. It can do something to verify something. It should be\n\t\t// quick; many channels may be opened!\n\t\tf := func(t *testing.T, c *Channel) {\n\t\t\treturn\n\t\t}\n\n\t\t// open and close\n\t\tchannel, err := c.Channel()\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"basic create channel: %s\", err)\n\t\t}\n\t\tt.Logf(\"basic create channel OK\")\n\n\t\tif err := channel.Close(); err != nil {\n\t\t\tt.Fatalf(\"basic close channel: %s\", err)\n\t\t}\n\t\tt.Logf(\"basic close channel OK\")\n\n\t\t// deferred close\n\t\tsignal := make(chan bool)\n\t\tgo func() {\n\t\t\tchannel, err := c.Channel()\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"second create channel: %s\", err)\n\t\t\t}\n\t\t\tt.Logf(\"second create channel OK\")\n\n\t\t\t<-signal // a bit of synchronization\n\t\t\tf(t, channel)\n\n\t\t\tdefer func() {\n\t\t\t\tif err := channel.Close(); err != nil {\n\t\t\t\t\tt.Fatalf(\"deferred close channel: %s\", err)\n\t\t\t\t}\n\t\t\t\tt.Logf(\"deferred close channel OK\")\n\t\t\t\tsignal <- true\n\t\t\t}()\n\t\t}()\n\t\tsignal <- true\n\t\tselect {\n\t\tcase <-signal:\n\t\t\tt.Logf(\"(got close signal OK)\")\n\t\t\tbreak\n\t\tcase <-time.After(250 * time.Millisecond):\n\t\t\tt.Fatalf(\"deferred close: timeout\")\n\t\t}\n\n\t\t// multiple channels\n\t\tfor _, n := range []int{2, 4, 8, 16, 32, 64, 128, 256} {\n\t\t\tchannels := make([]*Channel, n)\n\t\t\tfor i := 0; i < n; i++ {\n\t\t\t\tvar err error\n\t\t\t\tif channels[i], err = c.Channel(); err != nil {\n\t\t\t\t\tt.Fatalf(\"create channel %d/%d: %s\", i+1, n, err)\n\t\t\t\t}\n\t\t\t}\n\t\t\tf(t, channel)\n\t\t\tfor i, channel := range channels {\n\t\t\t\tif err := channel.Close(); err != nil {\n\t\t\t\t\tt.Fatalf(\"close channel %d/%d: %s\", i+1, n, err)\n\t\t\t\t}\n\t\t\t}\n\t\t\tt.Logf(\"created/closed %d channels OK\", n)\n\t\t}\n\n\t}\n}\n\nfunc TestIntegrationMeaningfulChannelErrors(t *testing.T) {\n\tc := integrationConnection(t, \"pub\")\n\tif c != nil {\n\t\tdefer c.Close()\n\n\t\tch, err := c.Channel()\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"Could not create channel\")\n\t\t}\n\n\t\tqueue := \"test.integration.channel.error\"\n\n\t\t_, err = ch.QueueDeclare(queue, false, true, false, false, nil)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"Could not declare\")\n\t\t}\n\n\t\t_, err = ch.QueueDeclare(queue, true, false, false, false, nil)\n\t\tif err == nil {\n\t\t\tt.Fatalf(\"Expected error, got nil\")\n\t\t}\n\n\t\te, ok := err.(*Error)\n\t\tif !ok {\n\t\t\tt.Fatalf(\"Expected type Error response, got %T\", err)\n\t\t}\n\n\t\tif e.Code != PreconditionFailed {\n\t\t\tt.Fatalf(\"Expected PreconditionFailed, got: %+v\", e)\n\t\t}\n\n\t\t_, err = ch.QueueDeclare(queue, false, true, false, false, nil)\n\t\tif err != ErrClosed {\n\t\t\tt.Fatalf(\"Expected channel to be closed, got: %T\", err)\n\t\t}\n\t}\n}\n\n// https://github.com/streadway/amqp/issues/6\nfunc TestIntegrationNonBlockingClose(t *testing.T) {\n\tc := integrationConnection(t, \"#6\")\n\tif c != nil {\n\t\tdefer c.Close()\n\n\t\tch, err := c.Channel()\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"Could not create channel\")\n\t\t}\n\n\t\tqueue := \"test.integration.blocking.close\"\n\n\t\t_, err = ch.QueueDeclare(queue, false, true, false, false, nil)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"Could not declare\")\n\t\t}\n\n\t\tmsgs, err := ch.Consume(queue, \"\", false, false, false, false, nil)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"Could not consume\")\n\t\t}\n\n\t\t// Simulate a consumer\n\t\tgo func() {\n\t\t\tfor range msgs {\n\t\t\t\tt.Logf(\"Oh my, received message on an empty queue\")\n\t\t\t}\n\t\t}()\n\n\t\tsucceed := make(chan bool)\n\n\t\tgo func() {\n\t\t\tif err = ch.Close(); err != nil {\n\t\t\t\tt.Fatalf(\"Close produced an error when it shouldn't\")\n\t\t\t}\n\t\t\tsucceed <- true\n\t\t}()\n\n\t\tselect {\n\t\tcase <-succeed:\n\t\t\tbreak\n\t\tcase <-time.After(1 * time.Second):\n\t\t\tt.Fatalf(\"Close timed out after 1s\")\n\t\t}\n\t}\n}\n\nfunc TestIntegrationPublishConsume(t *testing.T) {\n\tqueue := \"test.integration.publish.consume\"\n\n\tc1 := integrationConnection(t, \"pub\")\n\tc2 := integrationConnection(t, \"sub\")\n\n\tif c1 != nil && c2 != nil {\n\t\tdefer c1.Close()\n\t\tdefer c2.Close()\n\n\t\tpub, _ := c1.Channel()\n\t\tsub, _ := c2.Channel()\n\n\t\tpub.QueueDeclare(queue, false, true, false, false, nil)\n\t\tsub.QueueDeclare(queue, false, true, false, false, nil)\n\t\tdefer pub.QueueDelete(queue, false, false, false)\n\n\t\tmessages, _ := sub.Consume(queue, \"\", false, false, false, false, nil)\n\n\t\tpub.Publish(\"\", queue, false, false, Publishing{Body: []byte(\"pub 1\")})\n\t\tpub.Publish(\"\", queue, false, false, Publishing{Body: []byte(\"pub 2\")})\n\t\tpub.Publish(\"\", queue, false, false, Publishing{Body: []byte(\"pub 3\")})\n\n\t\tassertConsumeBody(t, messages, []byte(\"pub 1\"))\n\t\tassertConsumeBody(t, messages, []byte(\"pub 2\"))\n\t\tassertConsumeBody(t, messages, []byte(\"pub 3\"))\n\t}\n}\n\nfunc TestIntegrationConsumeFlow(t *testing.T) {\n\tqueue := \"test.integration.consumer-flow\"\n\n\tc1 := integrationConnection(t, \"pub-flow\")\n\tc2 := integrationConnection(t, \"sub-flow\")\n\n\tif c1 != nil && c2 != nil {\n\t\tdefer c1.Close()\n\t\tdefer c2.Close()\n\n\t\tpub, _ := c1.Channel()\n\t\tsub, _ := c2.Channel()\n\n\t\tpub.QueueDeclare(queue, false, true, false, false, nil)\n\t\tsub.QueueDeclare(queue, false, true, false, false, nil)\n\t\tdefer pub.QueueDelete(queue, false, false, false)\n\n\t\tsub.Qos(1, 0, false)\n\n\t\tmessages, _ := sub.Consume(queue, \"\", false, false, false, false, nil)\n\n\t\tpub.Publish(\"\", queue, false, false, Publishing{Body: []byte(\"pub 1\")})\n\t\tpub.Publish(\"\", queue, false, false, Publishing{Body: []byte(\"pub 2\")})\n\n\t\tmsg := assertConsumeBody(t, messages, []byte(\"pub 1\"))\n\n\t\tif err := sub.Flow(false); err.(*Error).Code == NotImplemented {\n\t\t\tt.Log(\"flow control is not supported on this version of rabbitmq\")\n\t\t\treturn\n\t\t}\n\n\t\tmsg.Ack(false)\n\n\t\tselect {\n\t\tcase <-messages:\n\t\t\tt.Fatalf(\"message was delivered when flow was not active\")\n\t\tdefault:\n\t\t}\n\n\t\tsub.Flow(true)\n\n\t\tmsg = assertConsumeBody(t, messages, []byte(\"pub 2\"))\n\t\tmsg.Ack(false)\n\t}\n}\n\nfunc TestIntegrationRecoverNotImplemented(t *testing.T) {\n\tqueue := \"test.recover\"\n\n\tif c, ch := integrationQueue(t, queue); c != nil {\n\t\tif product, ok := c.Properties[\"product\"]; ok && product.(string) == \"RabbitMQ\" {\n\t\t\tdefer c.Close()\n\n\t\t\terr := ch.Recover(false)\n\n\t\t\tif ex, ok := err.(*Error); !ok || ex.Code != 540 {\n\t\t\t\tt.Fatalf(\"Expected NOT IMPLEMENTED got: %v\", ex)\n\t\t\t}\n\t\t}\n\t}\n}\n\n// This test is driven by a private API to simulate the server sending a channelFlow message\nfunc TestIntegrationPublishFlow(t *testing.T) {\n\t// TODO - no idea how to test without affecting the server or mucking internal APIs\n\t// i'd like to make sure the RW lock can be held by multiple publisher threads\n\t// and that multiple channelFlow messages do not block the dispatch thread\n}\n\nfunc TestIntegrationConsumeCancel(t *testing.T) {\n\tqueue := \"test.integration.consume-cancel\"\n\n\tc := integrationConnection(t, \"pub\")\n\n\tif c != nil {\n\t\tdefer c.Close()\n\n\t\tch, _ := c.Channel()\n\n\t\tch.QueueDeclare(queue, false, true, false, false, nil)\n\t\tdefer ch.QueueDelete(queue, false, false, false)\n\n\t\tmessages, _ := ch.Consume(queue, \"integration-tag\", false, false, false, false, nil)\n\n\t\tch.Publish(\"\", queue, false, false, Publishing{Body: []byte(\"1\")})\n\n\t\tassertConsumeBody(t, messages, []byte(\"1\"))\n\n\t\terr := ch.Cancel(\"integration-tag\", false)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"error cancelling the consumer: %v\", err)\n\t\t}\n\n\t\tch.Publish(\"\", queue, false, false, Publishing{Body: []byte(\"2\")})\n\n\t\tselect {\n\t\tcase <-time.After(100 * time.Millisecond):\n\t\t\tt.Fatalf(\"Timeout on Close\")\n\t\tcase _, ok := <-messages:\n\t\t\tif ok {\n\t\t\t\tt.Fatalf(\"Extra message on consumer when consumer should have been closed\")\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc (c *Connection) Generate(r *rand.Rand, _ int) reflect.Value {\n\turlStr := os.Getenv(\"AMQP_URL\")\n\tif urlStr == \"\" {\n\t\treturn reflect.ValueOf(nil)\n\t}\n\n\tconn, err := Dial(urlStr)\n\tif err != nil {\n\t\treturn reflect.ValueOf(nil)\n\t}\n\n\treturn reflect.ValueOf(conn)\n}\n\nfunc (c Publishing) Generate(r *rand.Rand, _ int) reflect.Value {\n\tvar ok bool\n\tvar t reflect.Value\n\n\tp := Publishing{}\n\t//p.DeliveryMode = uint8(r.Intn(3))\n\t//p.Priority = uint8(r.Intn(8))\n\n\tif r.Intn(2) > 0 {\n\t\tp.ContentType = \"application/octet-stream\"\n\t}\n\n\tif r.Intn(2) > 0 {\n\t\tp.ContentEncoding = \"gzip\"\n\t}\n\n\tif r.Intn(2) > 0 {\n\t\tp.CorrelationId = fmt.Sprintf(\"%d\", r.Int())\n\t}\n\n\tif r.Intn(2) > 0 {\n\t\tp.ReplyTo = fmt.Sprintf(\"%d\", r.Int())\n\t}\n\n\tif r.Intn(2) > 0 {\n\t\tp.MessageId = fmt.Sprintf(\"%d\", r.Int())\n\t}\n\n\tif r.Intn(2) > 0 {\n\t\tp.Type = fmt.Sprintf(\"%d\", r.Int())\n\t}\n\n\tif r.Intn(2) > 0 {\n\t\tp.AppId = fmt.Sprintf(\"%d\", r.Int())\n\t}\n\n\tif r.Intn(2) > 0 {\n\t\tp.Timestamp = time.Unix(r.Int63(), r.Int63())\n\t}\n\n\tif t, ok = quick.Value(reflect.TypeOf(p.Body), r); ok {\n\t\tp.Body = t.Bytes()\n\t}\n\n\treturn reflect.ValueOf(p)\n}\n\nfunc TestQuickPublishOnly(t *testing.T) {\n\tif c := integrationConnection(t, \"quick\"); c != nil {\n\t\tdefer c.Close()\n\t\tpub, err := c.Channel()\n\t\tqueue := \"test-publish\"\n\n\t\tif _, err = pub.QueueDeclare(queue, false, true, false, false, nil); err != nil {\n\t\t\tt.Errorf(\"Failed to declare: %s\", err)\n\t\t\treturn\n\t\t}\n\n\t\tdefer pub.QueueDelete(queue, false, false, false)\n\n\t\tquick.Check(func(msg Publishing) bool {\n\t\t\treturn pub.Publish(\"\", queue, false, false, msg) == nil\n\t\t}, nil)\n\t}\n}\n\nfunc TestPublishEmptyBody(t *testing.T) {\n\tc := integrationConnection(t, \"empty\")\n\tif c != nil {\n\t\tdefer c.Close()\n\n\t\tch, err := c.Channel()\n\t\tif err != nil {\n\t\t\tt.Errorf(\"Failed to create channel\")\n\t\t\treturn\n\t\t}\n\n\t\tqueue := \"test-TestPublishEmptyBody\"\n\n\t\tif _, err := ch.QueueDeclare(queue, false, true, false, false, nil); err != nil {\n\t\t\tt.Fatalf(\"Could not declare\")\n\t\t}\n\n\t\tmessages, err := ch.Consume(queue, \"\", false, false, false, false, nil)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"Could not consume\")\n\t\t}\n\n\t\terr = ch.Publish(\"\", queue, false, false, Publishing{})\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"Could not publish\")\n\t\t}\n\n\t\tselect {\n\t\tcase msg := <-messages:\n\t\t\tif len(msg.Body) != 0 {\n\t\t\t\tt.Errorf(\"Received non empty body\")\n\t\t\t}\n\t\tcase <-time.After(200 * time.Millisecond):\n\t\t\tt.Errorf(\"Timeout on receive\")\n\t\t}\n\t}\n}\n\nfunc TestPublishEmptyBodyWithHeadersIssue67(t *testing.T) {\n\tc := integrationConnection(t, \"issue67\")\n\tif c != nil {\n\t\tdefer c.Close()\n\n\t\tch, err := c.Channel()\n\t\tif err != nil {\n\t\t\tt.Errorf(\"Failed to create channel\")\n\t\t\treturn\n\t\t}\n\n\t\tqueue := \"test-TestPublishEmptyBodyWithHeaders\"\n\n\t\tif _, err := ch.QueueDeclare(queue, false, true, false, false, nil); err != nil {\n\t\t\tt.Fatalf(\"Could not declare\")\n\t\t}\n\n\t\tmessages, err := ch.Consume(queue, \"\", false, false, false, false, nil)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"Could not consume\")\n\t\t}\n\n\t\theaders := Table{\n\t\t\t\"ham\": \"spam\",\n\t\t}\n\n\t\terr = ch.Publish(\"\", queue, false, false, Publishing{Headers: headers})\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"Could not publish\")\n\t\t}\n\n\t\tselect {\n\t\tcase msg := <-messages:\n\t\t\tif msg.Headers[\"ham\"] == nil {\n\t\t\t\tt.Fatalf(\"Headers aren't sent\")\n\t\t\t}\n\t\t\tif msg.Headers[\"ham\"] != \"spam\" {\n\t\t\t\tt.Fatalf(\"Headers are wrong\")\n\t\t\t}\n\t\tcase <-time.After(200 * time.Millisecond):\n\t\t\tt.Errorf(\"Timeout on receive\")\n\t\t}\n\t}\n}\n\nfunc TestQuickPublishConsumeOnly(t *testing.T) {\n\tc1 := integrationConnection(t, \"quick-pub\")\n\tc2 := integrationConnection(t, \"quick-sub\")\n\n\tif c1 != nil && c2 != nil {\n\t\tdefer c1.Close()\n\t\tdefer c2.Close()\n\n\t\tpub, err := c1.Channel()\n\t\tsub, err := c2.Channel()\n\n\t\tqueue := \"TestPublishConsumeOnly\"\n\n\t\tif _, err = pub.QueueDeclare(queue, false, true, false, false, nil); err != nil {\n\t\t\tt.Errorf(\"Failed to declare: %s\", err)\n\t\t\treturn\n\t\t}\n\n\t\tif _, err = sub.QueueDeclare(queue, false, true, false, false, nil); err != nil {\n\t\t\tt.Errorf(\"Failed to declare: %s\", err)\n\t\t\treturn\n\t\t}\n\n\t\tdefer sub.QueueDelete(queue, false, false, false)\n\n\t\tch, err := sub.Consume(queue, \"\", false, false, false, false, nil)\n\t\tif err != nil {\n\t\t\tt.Errorf(\"Could not sub: %s\", err)\n\t\t}\n\n\t\tquick.CheckEqual(\n\t\t\tfunc(msg Publishing) []byte {\n\t\t\t\tempty := Publishing{Body: msg.Body}\n\t\t\t\tif pub.Publish(\"\", queue, false, false, empty) != nil {\n\t\t\t\t\treturn []byte{'X'}\n\t\t\t\t}\n\t\t\t\treturn msg.Body\n\t\t\t},\n\t\t\tfunc(msg Publishing) []byte {\n\t\t\t\tout := <-ch\n\t\t\t\tout.Ack(false)\n\t\t\t\treturn out.Body\n\t\t\t},\n\t\t\tnil)\n\t}\n}\n\nfunc TestQuickPublishConsumeBigBody(t *testing.T) {\n\tc1 := integrationConnection(t, \"big-pub\")\n\tc2 := integrationConnection(t, \"big-sub\")\n\n\tif c1 != nil && c2 != nil {\n\t\tdefer c1.Close()\n\t\tdefer c2.Close()\n\n\t\tpub, err := c1.Channel()\n\t\tsub, err := c2.Channel()\n\n\t\tqueue := \"test-pubsub\"\n\n\t\tif _, err = sub.QueueDeclare(queue, false, true, false, false, nil); err != nil {\n\t\t\tt.Errorf(\"Failed to declare: %s\", err)\n\t\t\treturn\n\t\t}\n\n\t\tch, err := sub.Consume(queue, \"\", false, false, false, false, nil)\n\t\tif err != nil {\n\t\t\tt.Errorf(\"Could not sub: %s\", err)\n\t\t}\n\n\t\tfixture := Publishing{\n\t\t\tBody: make([]byte, 1e4+1000),\n\t\t}\n\n\t\tif _, err = pub.QueueDeclare(queue, false, true, false, false, nil); err != nil {\n\t\t\tt.Errorf(\"Failed to declare: %s\", err)\n\t\t\treturn\n\t\t}\n\n\t\terr = pub.Publish(\"\", queue, false, false, fixture)\n\t\tif err != nil {\n\t\t\tt.Errorf(\"Could not publish big body\")\n\t\t}\n\n\t\tselect {\n\t\tcase msg := <-ch:\n\t\t\tif bytes.Compare(msg.Body, fixture.Body) != 0 {\n\t\t\t\tt.Errorf(\"Consumed big body didn't match\")\n\t\t\t}\n\t\tcase <-time.After(200 * time.Millisecond):\n\t\t\tt.Errorf(\"Timeout on receive\")\n\t\t}\n\t}\n}\n\nfunc TestIntegrationGetOk(t *testing.T) {\n\tif c := integrationConnection(t, \"getok\"); c != nil {\n\t\tdefer c.Close()\n\n\t\tqueue := \"test.get-ok\"\n\t\tch, _ := c.Channel()\n\n\t\tch.QueueDeclare(queue, false, true, false, false, nil)\n\t\tch.Publish(\"\", queue, false, false, Publishing{Body: []byte(\"ok\")})\n\n\t\tmsg, ok, err := ch.Get(queue, false)\n\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"Failed get: %v\", err)\n\t\t}\n\n\t\tif !ok {\n\t\t\tt.Fatalf(\"Get on a queued message did not find the message\")\n\t\t}\n\n\t\tif string(msg.Body) != \"ok\" {\n\t\t\tt.Fatalf(\"Get did not get the correct message\")\n\t\t}\n\t}\n}\n\nfunc TestIntegrationGetEmpty(t *testing.T) {\n\tif c := integrationConnection(t, \"getok\"); c != nil {\n\t\tdefer c.Close()\n\n\t\tqueue := \"test.get-ok\"\n\t\tch, _ := c.Channel()\n\n\t\tch.QueueDeclare(queue, false, true, false, false, nil)\n\n\t\t_, ok, err := ch.Get(queue, false)\n\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"Failed get: %v\", err)\n\t\t}\n\n\t\tif !ok {\n\t\t\tt.Fatalf(\"Get on a queued message retrieved a message when it shouldn't have\")\n\t\t}\n\t}\n}\n\nfunc TestIntegrationTxCommit(t *testing.T) {\n\tif c := integrationConnection(t, \"txcommit\"); c != nil {\n\t\tdefer c.Close()\n\n\t\tqueue := \"test.tx.commit\"\n\t\tch, _ := c.Channel()\n\n\t\tch.QueueDeclare(queue, false, true, false, false, nil)\n\n\t\tif err := ch.Tx(); err != nil {\n\t\t\tt.Fatalf(\"tx.select failed\")\n\t\t}\n\n\t\tch.Publish(\"\", queue, false, false, Publishing{Body: []byte(\"ok\")})\n\n\t\tif err := ch.TxCommit(); err != nil {\n\t\t\tt.Fatalf(\"tx.commit failed\")\n\t\t}\n\n\t\tmsg, ok, err := ch.Get(queue, false)\n\n\t\tif err != nil || !ok {\n\t\t\tt.Fatalf(\"Failed get: %v\", err)\n\t\t}\n\n\t\tif string(msg.Body) != \"ok\" {\n\t\t\tt.Fatalf(\"Get did not get the correct message from the transaction\")\n\t\t}\n\t}\n}\n\nfunc TestIntegrationTxRollback(t *testing.T) {\n\tif c := integrationConnection(t, \"txrollback\"); c != nil {\n\t\tdefer c.Close()\n\n\t\tqueue := \"test.tx.rollback\"\n\t\tch, _ := c.Channel()\n\n\t\tch.QueueDeclare(queue, false, true, false, false, nil)\n\n\t\tif err := ch.Tx(); err != nil {\n\t\t\tt.Fatalf(\"tx.select failed\")\n\t\t}\n\n\t\tch.Publish(\"\", queue, false, false, Publishing{Body: []byte(\"ok\")})\n\n\t\tif err := ch.TxRollback(); err != nil {\n\t\t\tt.Fatalf(\"tx.rollback failed\")\n\t\t}\n\n\t\t_, ok, err := ch.Get(queue, false)\n\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"Failed get: %v\", err)\n\t\t}\n\n\t\tif ok {\n\t\t\tt.Fatalf(\"message was published when it should have been rolled back\")\n\t\t}\n\t}\n}\n\nfunc TestIntegrationReturn(t *testing.T) {\n\tif c, ch := integrationQueue(t, \"return\"); c != nil {\n\t\tdefer c.Close()\n\n\t\tret := make(chan Return, 1)\n\n\t\tch.NotifyReturn(ret)\n\n\t\t// mandatory publish to an exchange without a binding should be returned\n\t\tch.Publish(\"\", \"return-without-binding\", true, false, Publishing{Body: []byte(\"mandatory\")})\n\n\t\tselect {\n\t\tcase res := <-ret:\n\t\t\tif string(res.Body) != \"mandatory\" {\n\t\t\t\tt.Fatalf(\"expected return of the same message\")\n\t\t\t}\n\n\t\t\tif res.ReplyCode != NoRoute {\n\t\t\t\tt.Fatalf(\"expected no consumers reply code on the Return result, got: %v\", res.ReplyCode)\n\t\t\t}\n\n\t\tcase <-time.After(200 * time.Millisecond):\n\t\t\tt.Fatalf(\"no return was received within 200ms\")\n\t\t}\n\t}\n}\n\nfunc TestIntegrationCancel(t *testing.T) {\n\tqueue := \"cancel\"\n\tconsumerTag := \"test.cancel\"\n\n\tif c, ch := integrationQueue(t, queue); c != nil {\n\t\tdefer c.Close()\n\n\t\tcancels := ch.NotifyCancel(make(chan string, 1))\n\n\t\tgo func() {\n\t\t\tif _, err := ch.Consume(queue, consumerTag, false, false, false, false, nil); err != nil {\n\t\t\t\tt.Fatalf(\"cannot consume from %q to test NotifyCancel: %v\", queue, err)\n\t\t\t}\n\t\t\tif _, err := ch.QueueDelete(queue, false, false, false); err != nil {\n\t\t\t\tt.Fatalf(\"cannot delete integration queue: %v\", err)\n\t\t\t}\n\t\t}()\n\n\t\tselect {\n\t\tcase tag := <-cancels:\n\t\t\tif want, got := consumerTag, tag; want != got {\n\t\t\t\tt.Fatalf(\"expected to be notified of deleted queue with consumer tag, got: %q\", got)\n\t\t\t}\n\t\tcase <-time.After(200 * time.Millisecond):\n\t\t\tt.Fatalf(\"expected to be notified of deleted queue with 200ms\")\n\t\t}\n\t}\n}\n\nfunc TestIntegrationConfirm(t *testing.T) {\n\tif c, ch := integrationQueue(t, \"confirm\"); c != nil {\n\t\tdefer c.Close()\n\n\t\tconfirms := ch.NotifyPublish(make(chan Confirmation, 1))\n\n\t\tif err := ch.Confirm(false); err != nil {\n\t\t\tt.Fatalf(\"could not confirm\")\n\t\t}\n\n\t\tch.Publish(\"\", \"confirm\", false, false, Publishing{Body: []byte(\"confirm\")})\n\n\t\tselect {\n\t\tcase confirmed := <-confirms:\n\t\t\tif confirmed.DeliveryTag != 1 {\n\t\t\t\tt.Fatalf(\"expected ack starting with delivery tag of 1\")\n\t\t\t}\n\t\tcase <-time.After(200 * time.Millisecond):\n\t\t\tt.Fatalf(\"no ack was received within 200ms\")\n\t\t}\n\t}\n}\n\n// https://github.com/streadway/amqp/issues/61\nfunc TestRoundTripAllFieldValueTypes61(t *testing.T) {\n\tif conn := integrationConnection(t, \"issue61\"); conn != nil {\n\t\tdefer conn.Close()\n\t\ttimestamp := time.Unix(100000000, 0)\n\n\t\theaders := Table{\n\t\t\t\"A\": []interface{}{\n\t\t\t\t[]interface{}{\"nested array\", int32(3)},\n\t\t\t\tDecimal{2, 1},\n\t\t\t\tTable{\"S\": \"nested table in array\"},\n\t\t\t\tint32(2 << 20),\n\t\t\t\tstring(\"array string\"),\n\t\t\t\ttimestamp,\n\t\t\t\tnil,\n\t\t\t\tbyte(2),\n\t\t\t\tfloat64(2.64),\n\t\t\t\tfloat32(2.32),\n\t\t\t\tint64(2 << 60),\n\t\t\t\tint16(2 << 10),\n\t\t\t\tbool(true),\n\t\t\t\t[]byte{'b', '2'},\n\t\t\t},\n\t\t\t\"D\": Decimal{1, 1},\n\t\t\t\"F\": Table{\"S\": \"nested table in table\"},\n\t\t\t\"I\": int32(1 << 20),\n\t\t\t\"S\": string(\"string\"),\n\t\t\t\"T\": timestamp,\n\t\t\t\"V\": nil,\n\t\t\t\"b\": byte(1),\n\t\t\t\"d\": float64(1.64),\n\t\t\t\"f\": float32(1.32),\n\t\t\t\"l\": int64(1 << 60),\n\t\t\t\"s\": int16(1 << 10),\n\t\t\t\"t\": bool(true),\n\t\t\t\"x\": []byte{'b', '1'},\n\t\t}\n\n\t\tqueue := \"test.issue61-roundtrip\"\n\t\tch, _ := conn.Channel()\n\n\t\tif _, err := ch.QueueDeclare(queue, false, true, false, false, nil); err != nil {\n\t\t\tt.Fatalf(\"Could not declare\")\n\t\t}\n\n\t\tmsgs, err := ch.Consume(queue, \"\", false, false, false, false, nil)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"Could not consume\")\n\t\t}\n\n\t\terr = ch.Publish(\"\", queue, false, false, Publishing{Body: []byte(\"ignored\"), Headers: headers})\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"Could not publish: %v\", err)\n\t\t}\n\n\t\tmsg, ok := <-msgs\n\n\t\tif !ok {\n\t\t\tt.Fatalf(\"Channel closed prematurely likely due to publish exception\")\n\t\t}\n\n\t\tfor k, v := range headers {\n\t\t\tif !reflect.DeepEqual(v, msg.Headers[k]) {\n\t\t\t\tt.Errorf(\"Round trip header not the same for key %q: expected: %#v, got %#v\", k, v, msg.Headers[k])\n\t\t\t}\n\t\t}\n\t}\n}\n\n// Declares a queue with the x-message-ttl extension to exercise integer\n// serialization.\n//\n// Relates to https://github.com/streadway/amqp/issues/60\n//\nfunc TestDeclareArgsXMessageTTL(t *testing.T) {\n\tif conn := integrationConnection(t, \"declareTTL\"); conn != nil {\n\t\tdefer conn.Close()\n\n\t\tch, _ := conn.Channel()\n\t\targs := Table{\"x-message-ttl\": int32(9000000)}\n\n\t\t// should not drop the connection\n\t\tif _, err := ch.QueueDeclare(\"declareWithTTL\", false, true, false, false, args); err != nil {\n\t\t\tt.Fatalf(\"cannot declare with TTL: got: %v\", err)\n\t\t}\n\t}\n}\n\n// Sets up the topology where rejected messages will be forwarded\n// to a fanout exchange, with a single queue bound.\n//\n// Relates to https://github.com/streadway/amqp/issues/56\n//\nfunc TestDeclareArgsRejectToDeadLetterQueue(t *testing.T) {\n\tif conn := integrationConnection(t, \"declareArgs\"); conn != nil {\n\t\tdefer conn.Close()\n\n\t\tex, q := \"declareArgs\", \"declareArgs-deliveries\"\n\t\tdlex, dlq := ex+\"-dead-letter\", q+\"-dead-letter\"\n\n\t\tch, _ := conn.Channel()\n\n\t\tif err := ch.ExchangeDeclare(ex, \"fanout\", false, true, false, false, nil); err != nil {\n\t\t\tt.Fatalf(\"cannot declare %v: got: %v\", ex, err)\n\t\t}\n\n\t\tif err := ch.ExchangeDeclare(dlex, \"fanout\", false, true, false, false, nil); err != nil {\n\t\t\tt.Fatalf(\"cannot declare %v: got: %v\", dlex, err)\n\t\t}\n\n\t\tif _, err := ch.QueueDeclare(dlq, false, true, false, false, nil); err != nil {\n\t\t\tt.Fatalf(\"cannot declare %v: got: %v\", dlq, err)\n\t\t}\n\n\t\tif err := ch.QueueBind(dlq, \"#\", dlex, false, nil); err != nil {\n\t\t\tt.Fatalf(\"cannot bind %v to %v: got: %v\", dlq, dlex, err)\n\t\t}\n\n\t\tif _, err := ch.QueueDeclare(q, false, true, false, false, Table{\n\t\t\t\"x-dead-letter-exchange\": dlex,\n\t\t}); err != nil {\n\t\t\tt.Fatalf(\"cannot declare %v with dlq %v: got: %v\", q, dlex, err)\n\t\t}\n\n\t\tif err := ch.QueueBind(q, \"#\", ex, false, nil); err != nil {\n\t\t\tt.Fatalf(\"cannot bind %v: got: %v\", ex, err)\n\t\t}\n\n\t\tfails, err := ch.Consume(q, \"\", false, false, false, false, nil)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"cannot consume %v: got: %v\", q, err)\n\t\t}\n\n\t\t// Reject everything consumed\n\t\tgo func() {\n\t\t\tfor d := range fails {\n\t\t\t\td.Reject(false)\n\t\t\t}\n\t\t}()\n\n\t\t// Publish the 'poison'\n\t\tif err := ch.Publish(ex, q, true, false, Publishing{Body: []byte(\"ignored\")}); err != nil {\n\t\t\tt.Fatalf(\"publishing failed\")\n\t\t}\n\n\t\t// spin-get until message arrives on the dead-letter queue with a\n\t\t// synchronous parse to exercise the array field (x-death) set by the\n\t\t// server relating to issue-56\n\t\tfor i := 0; i < 10; i++ {\n\t\t\td, got, err := ch.Get(dlq, false)\n\t\t\tif !got && err == nil {\n\t\t\t\tcontinue\n\t\t\t} else if err != nil {\n\t\t\t\tt.Fatalf(\"expected success in parsing reject, got: %v\", err)\n\t\t\t} else {\n\t\t\t\t// pass if we've parsed an array\n\t\t\t\tif v, ok := d.Headers[\"x-death\"]; ok {\n\t\t\t\t\tif _, ok := v.([]interface{}); ok {\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tt.Fatalf(\"array field x-death expected in the headers, got: %v (%T)\", d.Headers, d.Headers[\"x-death\"])\n\t\t\t}\n\t\t}\n\n\t\tt.Fatalf(\"expectd dead-letter after 10 get attempts\")\n\t}\n}\n\n// https://github.com/streadway/amqp/issues/48\nfunc TestDeadlockConsumerIssue48(t *testing.T) {\n\tif conn := integrationConnection(t, \"issue48\"); conn != nil {\n\t\tdefer conn.Close()\n\n\t\tdeadline := make(chan bool)\n\t\tgo func() {\n\t\t\tselect {\n\t\t\tcase <-time.After(5 * time.Second):\n\t\t\t\tpanic(\"expected to receive 2 deliveries while in an RPC, got a deadlock\")\n\t\t\tcase <-deadline:\n\t\t\t\t// pass\n\t\t\t}\n\t\t}()\n\n\t\tch, err := conn.Channel()\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"got error on channel.open: %v\", err)\n\t\t}\n\n\t\tqueue := \"test-issue48\"\n\n\t\tif _, err := ch.QueueDeclare(queue, false, true, false, false, nil); err != nil {\n\t\t\tt.Fatalf(\"expected to declare a queue: %v\", err)\n\t\t}\n\n\t\tif err := ch.Confirm(false); err != nil {\n\t\t\tt.Fatalf(\"got error on confirm: %v\", err)\n\t\t}\n\n\t\tconfirms := ch.NotifyPublish(make(chan Confirmation, 2))\n\n\t\tfor i := 0; i < cap(confirms); i++ {\n\t\t\t// Fill the queue with some new or remaining publishings\n\t\t\tch.Publish(\"\", queue, false, false, Publishing{Body: []byte(\"\")})\n\t\t}\n\n\t\tfor i := 0; i < cap(confirms); i++ {\n\t\t\t// Wait for them to land on the queue so they'll be delivered on consume\n\t\t\t<-confirms\n\t\t}\n\n\t\t// Consuming should send them all on the wire\n\t\tmsgs, err := ch.Consume(queue, \"\", false, false, false, false, nil)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"got error on consume: %v\", err)\n\t\t}\n\n\t\t// We pop one off the chan, the other is on the wire\n\t\t<-msgs\n\n\t\t// Opening a new channel (any RPC) while another delivery is on the wire\n\t\tif _, err := conn.Channel(); err != nil {\n\t\t\tt.Fatalf(\"got error on consume: %v\", err)\n\t\t}\n\n\t\t// We pop the next off the chan\n\t\t<-msgs\n\n\t\tdeadline <- true\n\t}\n}\n\n// https://github.com/streadway/amqp/issues/46\nfunc TestRepeatedChannelExceptionWithPublishAndMaxProcsIssue46(t *testing.T) {\n\tconn := integrationConnection(t, \"issue46\")\n\tif conn != nil {\n\t\tfor i := 0; i < 100; i++ {\n\t\t\tch, err := conn.Channel()\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"expected error only on publish, got error on channel.open: %v\", err)\n\t\t\t}\n\n\t\t\tfor j := 0; j < 10; j++ {\n\t\t\t\terr = ch.Publish(\"not-existing-exchange\", \"some-key\", false, false, Publishing{Body: []byte(\"some-data\")})\n\t\t\t\tif err, ok := err.(Error); ok {\n\t\t\t\t\tif err.Code != 504 {\n\t\t\t\t\t\tt.Fatalf(\"expected channel only exception, got: %v\", err)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n// https://github.com/streadway/amqp/issues/43\nfunc TestChannelExceptionWithCloseIssue43(t *testing.T) {\n\tconn := integrationConnection(t, \"issue43\")\n\tif conn != nil {\n\t\tgo func() {\n\t\t\tfor err := range conn.NotifyClose(make(chan *Error)) {\n\t\t\t\tt.Log(err.Error())\n\t\t\t}\n\t\t}()\n\n\t\tc1, err := conn.Channel()\n\t\tif err != nil {\n\t\t\tpanic(err)\n\t\t}\n\n\t\tgo func() {\n\t\t\tfor err := range c1.NotifyClose(make(chan *Error)) {\n\t\t\t\tt.Log(\"Channel1 Close: \" + err.Error())\n\t\t\t}\n\t\t}()\n\n\t\tc2, err := conn.Channel()\n\t\tif err != nil {\n\t\t\tpanic(err)\n\t\t}\n\n\t\tgo func() {\n\t\t\tfor err := range c2.NotifyClose(make(chan *Error)) {\n\t\t\t\tt.Log(\"Channel2 Close: \" + err.Error())\n\t\t\t}\n\t\t}()\n\n\t\t// Cause an asynchronous channel exception causing the server\n\t\t// to send a \"channel.close\" method either before or after the next\n\t\t// asynchronous method.\n\t\terr = c1.Publish(\"nonexisting-exchange\", \"\", false, false, Publishing{})\n\t\tif err != nil {\n\t\t\tpanic(err)\n\t\t}\n\n\t\t// Receive or send the channel close method, the channel shuts down\n\t\t// but this expects a channel.close-ok to be received.\n\t\tc1.Close()\n\n\t\t// This ensures that the 2nd channel is unaffected by the channel exception\n\t\t// on channel 1.\n\t\terr = c2.ExchangeDeclare(\"test-channel-still-exists\", \"direct\", false, true, false, false, nil)\n\t\tif err != nil {\n\t\t\tpanic(err)\n\t\t}\n\t}\n}\n\n// https://github.com/streadway/amqp/issues/7\nfunc TestCorruptedMessageIssue7(t *testing.T) {\n\tmessageCount := 1024\n\n\tc1 := integrationConnection(t, \"\")\n\tc2 := integrationConnection(t, \"\")\n\n\tif c1 != nil && c2 != nil {\n\t\tdefer c1.Close()\n\t\tdefer c2.Close()\n\n\t\tpub, err := c1.Channel()\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"Cannot create Channel\")\n\t\t}\n\n\t\tsub, err := c2.Channel()\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"Cannot create Channel\")\n\t\t}\n\n\t\tqueue := \"test-corrupted-message-regression\"\n\n\t\tif _, err := pub.QueueDeclare(queue, false, true, false, false, nil); err != nil {\n\t\t\tt.Fatalf(\"Cannot declare\")\n\t\t}\n\n\t\tif _, err := sub.QueueDeclare(queue, false, true, false, false, nil); err != nil {\n\t\t\tt.Fatalf(\"Cannot declare\")\n\t\t}\n\n\t\tmsgs, err := sub.Consume(queue, \"\", false, false, false, false, nil)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"Cannot consume\")\n\t\t}\n\n\t\tfor i := 0; i < messageCount; i++ {\n\t\t\terr := pub.Publish(\"\", queue, false, false, Publishing{\n\t\t\t\tBody: generateCrc32Random(7 * i),\n\t\t\t})\n\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"Failed to publish\")\n\t\t\t}\n\t\t}\n\n\t\tfor i := 0; i < messageCount; i++ {\n\t\t\tselect {\n\t\t\tcase msg := <-msgs:\n\t\t\t\tassertMessageCrc32(t, msg.Body, fmt.Sprintf(\"missed match at %d\", i))\n\t\t\tcase <-time.After(200 * time.Millisecond):\n\t\t\t\tt.Fatalf(\"Timeout on recv\")\n\t\t\t}\n\t\t}\n\t}\n}\n\n// https://github.com/streadway/amqp/issues/136\nfunc TestChannelCounterShouldNotPanicIssue136(t *testing.T) {\n\tif c := integrationConnection(t, \"issue136\"); c != nil {\n\t\tdefer c.Close()\n\t\tvar wg sync.WaitGroup\n\n\t\t// exceeds 65535 channels\n\t\tfor i := 0; i < 8; i++ {\n\t\t\twg.Add(1)\n\t\t\tgo func(i int) {\n\t\t\t\tfor j := 0; j < 10000; j++ {\n\t\t\t\t\tch, err := c.Channel()\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\tt.Fatalf(\"failed to create channel %d:%d, got: %v\", i, j, err)\n\t\t\t\t\t}\n\t\t\t\t\tif err := ch.Close(); err != nil {\n\t\t\t\t\t\tt.Fatalf(\"failed to close channel %d:%d, got: %v\", i, j, err)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\twg.Done()\n\t\t\t}(i)\n\t\t}\n\t\twg.Wait()\n\t}\n}\n\nfunc TestExchangeDeclarePrecondition(t *testing.T) {\n\tc1 := integrationConnection(t, \"exchange-double-declare\")\n\tc2 := integrationConnection(t, \"exchange-double-declare-cleanup\")\n\tif c1 != nil && c2 != nil {\n\t\tdefer c1.Close()\n\t\tdefer c2.Close()\n\n\t\tch, err := c1.Channel()\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"Create channel\")\n\t\t}\n\n\t\texchange := \"test-mismatched-redeclare\"\n\n\t\terr = ch.ExchangeDeclare(\n\t\t\texchange,\n\t\t\t\"direct\", // exchangeType\n\t\t\tfalse,    // durable\n\t\t\ttrue,     // auto-delete\n\t\t\tfalse,    // internal\n\t\t\tfalse,    // noWait\n\t\t\tnil,      // arguments\n\t\t)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"Could not initially declare exchange\")\n\t\t}\n\n\t\terr = ch.ExchangeDeclare(\n\t\t\texchange,\n\t\t\t\"direct\",\n\t\t\ttrue, // different durability\n\t\t\ttrue,\n\t\t\tfalse,\n\t\t\tfalse,\n\t\t\tnil,\n\t\t)\n\n\t\tif err == nil {\n\t\t\tt.Fatalf(\"Expected to fail a redeclare with different durability, didn't receive an error\")\n\t\t}\n\n\t\tif err, ok := err.(Error); ok {\n\t\t\tif err.Code != PreconditionFailed {\n\t\t\t\tt.Fatalf(\"Expected precondition error\")\n\t\t\t}\n\t\t\tif !err.Recover {\n\t\t\t\tt.Fatalf(\"Expected to be able to recover\")\n\t\t\t}\n\t\t}\n\n\t\tch2, _ := c2.Channel()\n\t\tif err = ch2.ExchangeDelete(exchange, false, false); err != nil {\n\t\t\tt.Fatalf(\"Could not delete exchange: %v\", err)\n\t\t}\n\t}\n}\n\nfunc TestRabbitMQQueueTTLGet(t *testing.T) {\n\tif c := integrationRabbitMQ(t, \"ttl\"); c != nil {\n\t\tdefer c.Close()\n\n\t\tqueue := \"test.rabbitmq-message-ttl\"\n\t\tchannel, err := c.Channel()\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"channel: %v\", err)\n\t\t}\n\n\t\tif _, err = channel.QueueDeclare(\n\t\t\tqueue,\n\t\t\tfalse,\n\t\t\ttrue,\n\t\t\tfalse,\n\t\t\tfalse,\n\t\t\tTable{\"x-message-ttl\": int32(100)}, // in ms\n\t\t); err != nil {\n\t\t\tt.Fatalf(\"queue declare: %s\", err)\n\t\t}\n\n\t\tchannel.Publish(\"\", queue, false, false, Publishing{Body: []byte(\"ttl\")})\n\n\t\ttime.Sleep(200 * time.Millisecond)\n\n\t\t_, ok, err := channel.Get(queue, false)\n\n\t\tif ok {\n\t\t\tt.Fatalf(\"Expected the message to expire in 100ms, it didn't expire after 200ms\")\n\t\t}\n\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"Failed to get on ttl queue\")\n\t\t}\n\t}\n}\n\nfunc TestRabbitMQQueueNackMultipleRequeue(t *testing.T) {\n\tif c := integrationRabbitMQ(t, \"nack\"); c != nil {\n\t\tdefer c.Close()\n\n\t\tif c.isCapable(\"basic.nack\") {\n\t\t\tqueue := \"test.rabbitmq-basic-nack\"\n\t\t\tchannel, err := c.Channel()\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"channel: %v\", err)\n\t\t\t}\n\n\t\t\tif _, err = channel.QueueDeclare(queue, false, true, false, false, nil); err != nil {\n\t\t\t\tt.Fatalf(\"queue declare: %s\", err)\n\t\t\t}\n\n\t\t\tchannel.Publish(\"\", queue, false, false, Publishing{Body: []byte(\"1\")})\n\t\t\tchannel.Publish(\"\", queue, false, false, Publishing{Body: []byte(\"2\")})\n\n\t\t\tm1, ok, err := channel.Get(queue, false)\n\t\t\tif !ok || err != nil || m1.Body[0] != '1' {\n\t\t\t\tt.Fatalf(\"could not get message %v\", m1)\n\t\t\t}\n\n\t\t\tm2, ok, err := channel.Get(queue, false)\n\t\t\tif !ok || err != nil || m2.Body[0] != '2' {\n\t\t\t\tt.Fatalf(\"could not get message %v\", m2)\n\t\t\t}\n\n\t\t\tm2.Nack(true, true)\n\n\t\t\tm1, ok, err = channel.Get(queue, false)\n\t\t\tif !ok || err != nil || m1.Body[0] != '1' {\n\t\t\t\tt.Fatalf(\"could not get message %v\", m1)\n\t\t\t}\n\n\t\t\tm2, ok, err = channel.Get(queue, false)\n\t\t\tif !ok || err != nil || m2.Body[0] != '2' {\n\t\t\t\tt.Fatalf(\"could not get message %v\", m2)\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc TestConsumerCancelNotification(t *testing.T) {\n\tc := integrationConnection(t, \"consumer cancel notification\")\n\tif c != nil {\n\t\tdefer c.Close()\n\t\tch, err := c.Channel()\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"got error on channel.open: %v\", err)\n\t\t}\n\n\t\tqueue := \"test-consumer-cancel-notification\"\n\n\t\tif _, err := ch.QueueDeclare(queue, false, true, false, false, nil); err != nil {\n\t\t\tt.Fatalf(\"expected to declare a queue: %v\", err)\n\t\t}\n\n\t\tif _, err := ch.Consume(queue, \"\", false, false, false, false, nil); err != nil {\n\t\t\tt.Fatalf(\"basic.consume failed\")\n\t\t}\n\t\t// consumer cancel notification channel\n\t\tccnChan := make(chan string, 1)\n\t\tch.NotifyCancel(ccnChan)\n\n\t\tif _, err := ch.QueueDelete(queue, false, false, true); err != nil {\n\t\t\tt.Fatalf(\"queue.delete failed: %s\", err)\n\t\t}\n\n\t\tselect {\n\t\tcase <-ccnChan:\n\t\t\t// do nothing\n\t\tcase <-time.After(time.Second * 10):\n\t\t\tt.Errorf(\"basic.cancel wasn't received\")\n\t\t\tt.Fail()\n\t\t}\n\t\t// we don't close ccnChan because channel shutdown\n\t\t// does it\n\t}\n}\n\nfunc TestConcurrentChannelAndConnectionClose(t *testing.T) {\n\tc := integrationConnection(t, \"concurrent channel and connection test\")\n\tif c != nil {\n\t\tch, err := c.Channel()\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"got error on channel.open: %v\", err)\n\t\t}\n\n\t\tvar wg sync.WaitGroup\n\t\twg.Add(2)\n\n\t\tstarter := make(chan struct{})\n\t\tgo func() {\n\t\t\tdefer wg.Done()\n\t\t\t<-starter\n\t\t\tc.Close()\n\t\t}()\n\n\t\tgo func() {\n\t\t\tdefer wg.Done()\n\t\t\t<-starter\n\t\t\tch.Close()\n\t\t}()\n\t\tclose(starter)\n\t\twg.Wait()\n\t}\n}\n\n/*\n * Support for integration tests\n */\n\nfunc integrationURLFromEnv() string {\n\turl := os.Getenv(\"AMQP_URL\")\n\tif url == \"\" {\n\t\turl = \"amqp://\"\n\t}\n\treturn url\n}\n\nfunc loggedConnection(t *testing.T, conn *Connection, name string) *Connection {\n\tif name != \"\" {\n\t\tconn.conn = &logIO{t, name, conn.conn}\n\t}\n\treturn conn\n}\n\n// Returns a connection to the AMQP if the AMQP_URL environment\n// variable is set and a connection can be established.\nfunc integrationConnection(t *testing.T, name string) *Connection {\n\tconn, err := Dial(integrationURLFromEnv())\n\tif err != nil {\n\t\tt.Fatalf(\"cannot dial integration server. Is the rabbitmq-server service running? %s\", err)\n\t\treturn nil\n\t}\n\treturn loggedConnection(t, conn, name)\n}\n\n// Returns a connection, channel and declares a queue when the AMQP_URL is in the environment\nfunc integrationQueue(t *testing.T, name string) (*Connection, *Channel) {\n\tif conn := integrationConnection(t, name); conn != nil {\n\t\tif channel, err := conn.Channel(); err == nil {\n\t\t\tif _, err = channel.QueueDeclare(name, false, true, false, false, nil); err == nil {\n\t\t\t\treturn conn, channel\n\t\t\t}\n\t\t}\n\t}\n\treturn nil, nil\n}\n\n// Delegates to integrationConnection and only returns a connection if the\n// product is RabbitMQ\nfunc integrationRabbitMQ(t *testing.T, name string) *Connection {\n\tif conn := integrationConnection(t, \"connect\"); conn != nil {\n\t\tif server, ok := conn.Properties[\"product\"]; ok && server == \"RabbitMQ\" {\n\t\t\treturn conn\n\t\t}\n\t}\n\n\treturn nil\n}\n\nfunc assertConsumeBody(t *testing.T, messages <-chan Delivery, want []byte) (msg *Delivery) {\n\tselect {\n\tcase got := <-messages:\n\t\tif bytes.Compare(want, got.Body) != 0 {\n\t\t\tt.Fatalf(\"Message body does not match want: %v, got: %v, for: %+v\", want, got.Body, got)\n\t\t}\n\t\tmsg = &got\n\tcase <-time.After(200 * time.Millisecond):\n\t\tt.Fatalf(\"Timeout waiting for %v\", want)\n\t}\n\n\treturn msg\n}\n\n// Pulls out the CRC and verifies the remaining content against the CRC\nfunc assertMessageCrc32(t *testing.T, msg []byte, assert string) {\n\tsize := binary.BigEndian.Uint32(msg[:4])\n\n\tcrc := crc32.NewIEEE()\n\tcrc.Write(msg[8:])\n\n\tif binary.BigEndian.Uint32(msg[4:8]) != crc.Sum32() {\n\t\tt.Fatalf(\"Message does not match CRC: %s\", assert)\n\t}\n\n\tif int(size) != len(msg)-8 {\n\t\tt.Fatalf(\"Message does not match size, should=%d, is=%d: %s\", size, len(msg)-8, assert)\n\t}\n}\n\n// Creates a random body size with a leading 32-bit CRC in network byte order\n// that verifies the remaining slice\nfunc generateCrc32Random(size int) []byte {\n\tmsg := make([]byte, size+8)\n\tif _, err := io.ReadFull(devrand.Reader, msg); err != nil {\n\t\tpanic(err)\n\t}\n\n\tcrc := crc32.NewIEEE()\n\tcrc.Write(msg[8:])\n\n\tbinary.BigEndian.PutUint32(msg[0:4], uint32(size))\n\tbinary.BigEndian.PutUint32(msg[4:8], crc.Sum32())\n\n\treturn msg\n}\n"
        },
        {
          "name": "pre-commit",
          "type": "blob",
          "size": 1.1484375,
          "content": "#!/bin/sh\n\nLATEST_STABLE_SUPPORTED_GO_VERSION=\"1.11\"\n\nmain() {\n  if local_go_version_is_latest_stable\n  then\n    run_gofmt\n    run_golint\n    run_govet\n  fi\n  run_unit_tests\n}\n\nlocal_go_version_is_latest_stable() {\n  go version | grep -q $LATEST_STABLE_SUPPORTED_GO_VERSION\n}\n\nlog_error() {\n  echo \"$*\" 1>&2\n}\n\nrun_gofmt() {\n  GOFMT_FILES=$(gofmt -l .)\n  if [ -n \"$GOFMT_FILES\" ]\n  then\n    log_error \"gofmt failed for the following files:\n$GOFMT_FILES\n\nplease run 'gofmt -w .' on your changes before committing.\"\n    exit 1\n  fi\n}\n\nrun_golint() {\n  GOLINT_ERRORS=$(golint ./... | grep -v \"Id should be\")\n  if [ -n \"$GOLINT_ERRORS\" ]\n  then\n    log_error \"golint failed for the following reasons:\n$GOLINT_ERRORS\n\nplease run 'golint ./...' on your changes before committing.\"\n    exit 1\n  fi\n}\n\nrun_govet() {\n  GOVET_ERRORS=$(go tool vet ./*.go 2>&1)\n  if [ -n \"$GOVET_ERRORS\" ]\n  then\n    log_error \"go vet failed for the following reasons:\n$GOVET_ERRORS\n\nplease run 'go tool vet ./*.go' on your changes before committing.\"\n    exit 1\n  fi\n}\n\nrun_unit_tests() {\n  if [ -z \"$NOTEST\" ]\n  then\n    log_error 'Running short tests...'\n    env AMQP_URL= go test -short\n  fi\n}\n\nmain\n"
        },
        {
          "name": "read.go",
          "type": "blob",
          "size": 9.3125,
          "content": "// Copyright (c) 2012, Sean Treadway, SoundCloud Ltd.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n// Source code and contact info at http://github.com/streadway/amqp\n\npackage amqp\n\nimport (\n\t\"bytes\"\n\t\"encoding/binary\"\n\t\"errors\"\n\t\"io\"\n\t\"time\"\n)\n\n/*\nReads a frame from an input stream and returns an interface that can be cast into\none of the following:\n\n   methodFrame\n   PropertiesFrame\n   bodyFrame\n   heartbeatFrame\n\n2.3.5  frame Details\n\nAll frames consist of a header (7 octets), a payload of arbitrary size, and a\n'frame-end' octet that detects malformed frames:\n\n  0      1         3             7                  size+7 size+8\n  +------+---------+-------------+  +------------+  +-----------+\n  | type | channel |     size    |  |  payload   |  | frame-end |\n  +------+---------+-------------+  +------------+  +-----------+\n   octet   short         long         size octets       octet\n\nTo read a frame, we:\n  1. Read the header and check the frame type and channel.\n\t2. Depending on the frame type, we read the payload and process it.\n  3. Read the frame end octet.\n\nIn realistic implementations where performance is a concern, we would use\nread-ahead buffering or\n\ngathering reads to avoid doing three separate system calls to read a frame.\n*/\nfunc (r *reader) ReadFrame() (frame frame, err error) {\n\tvar scratch [7]byte\n\n\tif _, err = io.ReadFull(r.r, scratch[:7]); err != nil {\n\t\treturn\n\t}\n\n\ttyp := uint8(scratch[0])\n\tchannel := binary.BigEndian.Uint16(scratch[1:3])\n\tsize := binary.BigEndian.Uint32(scratch[3:7])\n\n\tswitch typ {\n\tcase frameMethod:\n\t\tif frame, err = r.parseMethodFrame(channel, size); err != nil {\n\t\t\treturn\n\t\t}\n\n\tcase frameHeader:\n\t\tif frame, err = r.parseHeaderFrame(channel, size); err != nil {\n\t\t\treturn\n\t\t}\n\n\tcase frameBody:\n\t\tif frame, err = r.parseBodyFrame(channel, size); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\tcase frameHeartbeat:\n\t\tif frame, err = r.parseHeartbeatFrame(channel, size); err != nil {\n\t\t\treturn\n\t\t}\n\n\tdefault:\n\t\treturn nil, ErrFrame\n\t}\n\n\tif _, err = io.ReadFull(r.r, scratch[:1]); err != nil {\n\t\treturn nil, err\n\t}\n\n\tif scratch[0] != frameEnd {\n\t\treturn nil, ErrFrame\n\t}\n\n\treturn\n}\n\nfunc readShortstr(r io.Reader) (v string, err error) {\n\tvar length uint8\n\tif err = binary.Read(r, binary.BigEndian, &length); err != nil {\n\t\treturn\n\t}\n\n\tbytes := make([]byte, length)\n\tif _, err = io.ReadFull(r, bytes); err != nil {\n\t\treturn\n\t}\n\treturn string(bytes), nil\n}\n\nfunc readLongstr(r io.Reader) (v string, err error) {\n\tvar length uint32\n\tif err = binary.Read(r, binary.BigEndian, &length); err != nil {\n\t\treturn\n\t}\n\n\t// slices can't be longer than max int32 value\n\tif length > (^uint32(0) >> 1) {\n\t\treturn\n\t}\n\n\tbytes := make([]byte, length)\n\tif _, err = io.ReadFull(r, bytes); err != nil {\n\t\treturn\n\t}\n\treturn string(bytes), nil\n}\n\nfunc readDecimal(r io.Reader) (v Decimal, err error) {\n\tif err = binary.Read(r, binary.BigEndian, &v.Scale); err != nil {\n\t\treturn\n\t}\n\tif err = binary.Read(r, binary.BigEndian, &v.Value); err != nil {\n\t\treturn\n\t}\n\treturn\n}\n\nfunc readFloat32(r io.Reader) (v float32, err error) {\n\tif err = binary.Read(r, binary.BigEndian, &v); err != nil {\n\t\treturn\n\t}\n\treturn\n}\n\nfunc readFloat64(r io.Reader) (v float64, err error) {\n\tif err = binary.Read(r, binary.BigEndian, &v); err != nil {\n\t\treturn\n\t}\n\treturn\n}\n\nfunc readTimestamp(r io.Reader) (v time.Time, err error) {\n\tvar sec int64\n\tif err = binary.Read(r, binary.BigEndian, &sec); err != nil {\n\t\treturn\n\t}\n\treturn time.Unix(sec, 0), nil\n}\n\n/*\n'A': []interface{}\n'D': Decimal\n'F': Table\n'I': int32\n'S': string\n'T': time.Time\n'V': nil\n'b': byte\n'd': float64\n'f': float32\n'l': int64\n's': int16\n't': bool\n'x': []byte\n*/\nfunc readField(r io.Reader) (v interface{}, err error) {\n\tvar typ byte\n\tif err = binary.Read(r, binary.BigEndian, &typ); err != nil {\n\t\treturn\n\t}\n\n\tswitch typ {\n\tcase 't':\n\t\tvar value uint8\n\t\tif err = binary.Read(r, binary.BigEndian, &value); err != nil {\n\t\t\treturn\n\t\t}\n\t\treturn (value != 0), nil\n\n\tcase 'b':\n\t\tvar value [1]byte\n\t\tif _, err = io.ReadFull(r, value[0:1]); err != nil {\n\t\t\treturn\n\t\t}\n\t\treturn value[0], nil\n\n\tcase 's':\n\t\tvar value int16\n\t\tif err = binary.Read(r, binary.BigEndian, &value); err != nil {\n\t\t\treturn\n\t\t}\n\t\treturn value, nil\n\n\tcase 'I':\n\t\tvar value int32\n\t\tif err = binary.Read(r, binary.BigEndian, &value); err != nil {\n\t\t\treturn\n\t\t}\n\t\treturn value, nil\n\n\tcase 'l':\n\t\tvar value int64\n\t\tif err = binary.Read(r, binary.BigEndian, &value); err != nil {\n\t\t\treturn\n\t\t}\n\t\treturn value, nil\n\n\tcase 'f':\n\t\tvar value float32\n\t\tif err = binary.Read(r, binary.BigEndian, &value); err != nil {\n\t\t\treturn\n\t\t}\n\t\treturn value, nil\n\n\tcase 'd':\n\t\tvar value float64\n\t\tif err = binary.Read(r, binary.BigEndian, &value); err != nil {\n\t\t\treturn\n\t\t}\n\t\treturn value, nil\n\n\tcase 'D':\n\t\treturn readDecimal(r)\n\n\tcase 'S':\n\t\treturn readLongstr(r)\n\n\tcase 'A':\n\t\treturn readArray(r)\n\n\tcase 'T':\n\t\treturn readTimestamp(r)\n\n\tcase 'F':\n\t\treturn readTable(r)\n\n\tcase 'x':\n\t\tvar len int32\n\t\tif err = binary.Read(r, binary.BigEndian, &len); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tvalue := make([]byte, len)\n\t\tif _, err = io.ReadFull(r, value); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\treturn value, err\n\n\tcase 'V':\n\t\treturn nil, nil\n\t}\n\n\treturn nil, ErrSyntax\n}\n\n/*\n\tField tables are long strings that contain packed name-value pairs.  The\n\tname-value pairs are encoded as short string defining the name, and octet\n\tdefining the values type and then the value itself.   The valid field types for\n\ttables are an extension of the native integer, bit, string, and timestamp\n\ttypes, and are shown in the grammar.  Multi-octet integer fields are always\n\theld in network byte order.\n*/\nfunc readTable(r io.Reader) (table Table, err error) {\n\tvar nested bytes.Buffer\n\tvar str string\n\n\tif str, err = readLongstr(r); err != nil {\n\t\treturn\n\t}\n\n\tnested.Write([]byte(str))\n\n\ttable = make(Table)\n\n\tfor nested.Len() > 0 {\n\t\tvar key string\n\t\tvar value interface{}\n\n\t\tif key, err = readShortstr(&nested); err != nil {\n\t\t\treturn\n\t\t}\n\n\t\tif value, err = readField(&nested); err != nil {\n\t\t\treturn\n\t\t}\n\n\t\ttable[key] = value\n\t}\n\n\treturn\n}\n\nfunc readArray(r io.Reader) ([]interface{}, error) {\n\tvar (\n\t\tsize uint32\n\t\terr  error\n\t)\n\n\tif err = binary.Read(r, binary.BigEndian, &size); err != nil {\n\t\treturn nil, err\n\t}\n\n\tvar (\n\t\tlim   = &io.LimitedReader{R: r, N: int64(size)}\n\t\tarr   = []interface{}{}\n\t\tfield interface{}\n\t)\n\n\tfor {\n\t\tif field, err = readField(lim); err != nil {\n\t\t\tif err == io.EOF {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\treturn nil, err\n\t\t}\n\t\tarr = append(arr, field)\n\t}\n\n\treturn arr, nil\n}\n\n// Checks if this bit mask matches the flags bitset\nfunc hasProperty(mask uint16, prop int) bool {\n\treturn int(mask)&prop > 0\n}\n\nfunc (r *reader) parseHeaderFrame(channel uint16, size uint32) (frame frame, err error) {\n\thf := &headerFrame{\n\t\tChannelId: channel,\n\t}\n\n\tif err = binary.Read(r.r, binary.BigEndian, &hf.ClassId); err != nil {\n\t\treturn\n\t}\n\n\tif err = binary.Read(r.r, binary.BigEndian, &hf.weight); err != nil {\n\t\treturn\n\t}\n\n\tif err = binary.Read(r.r, binary.BigEndian, &hf.Size); err != nil {\n\t\treturn\n\t}\n\n\tvar flags uint16\n\n\tif err = binary.Read(r.r, binary.BigEndian, &flags); err != nil {\n\t\treturn\n\t}\n\n\tif hasProperty(flags, flagContentType) {\n\t\tif hf.Properties.ContentType, err = readShortstr(r.r); err != nil {\n\t\t\treturn\n\t\t}\n\t}\n\tif hasProperty(flags, flagContentEncoding) {\n\t\tif hf.Properties.ContentEncoding, err = readShortstr(r.r); err != nil {\n\t\t\treturn\n\t\t}\n\t}\n\tif hasProperty(flags, flagHeaders) {\n\t\tif hf.Properties.Headers, err = readTable(r.r); err != nil {\n\t\t\treturn\n\t\t}\n\t}\n\tif hasProperty(flags, flagDeliveryMode) {\n\t\tif err = binary.Read(r.r, binary.BigEndian, &hf.Properties.DeliveryMode); err != nil {\n\t\t\treturn\n\t\t}\n\t}\n\tif hasProperty(flags, flagPriority) {\n\t\tif err = binary.Read(r.r, binary.BigEndian, &hf.Properties.Priority); err != nil {\n\t\t\treturn\n\t\t}\n\t}\n\tif hasProperty(flags, flagCorrelationId) {\n\t\tif hf.Properties.CorrelationId, err = readShortstr(r.r); err != nil {\n\t\t\treturn\n\t\t}\n\t}\n\tif hasProperty(flags, flagReplyTo) {\n\t\tif hf.Properties.ReplyTo, err = readShortstr(r.r); err != nil {\n\t\t\treturn\n\t\t}\n\t}\n\tif hasProperty(flags, flagExpiration) {\n\t\tif hf.Properties.Expiration, err = readShortstr(r.r); err != nil {\n\t\t\treturn\n\t\t}\n\t}\n\tif hasProperty(flags, flagMessageId) {\n\t\tif hf.Properties.MessageId, err = readShortstr(r.r); err != nil {\n\t\t\treturn\n\t\t}\n\t}\n\tif hasProperty(flags, flagTimestamp) {\n\t\tif hf.Properties.Timestamp, err = readTimestamp(r.r); err != nil {\n\t\t\treturn\n\t\t}\n\t}\n\tif hasProperty(flags, flagType) {\n\t\tif hf.Properties.Type, err = readShortstr(r.r); err != nil {\n\t\t\treturn\n\t\t}\n\t}\n\tif hasProperty(flags, flagUserId) {\n\t\tif hf.Properties.UserId, err = readShortstr(r.r); err != nil {\n\t\t\treturn\n\t\t}\n\t}\n\tif hasProperty(flags, flagAppId) {\n\t\tif hf.Properties.AppId, err = readShortstr(r.r); err != nil {\n\t\t\treturn\n\t\t}\n\t}\n\tif hasProperty(flags, flagReserved1) {\n\t\tif hf.Properties.reserved1, err = readShortstr(r.r); err != nil {\n\t\t\treturn\n\t\t}\n\t}\n\n\treturn hf, nil\n}\n\nfunc (r *reader) parseBodyFrame(channel uint16, size uint32) (frame frame, err error) {\n\tbf := &bodyFrame{\n\t\tChannelId: channel,\n\t\tBody:      make([]byte, size),\n\t}\n\n\tif _, err = io.ReadFull(r.r, bf.Body); err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn bf, nil\n}\n\nvar errHeartbeatPayload = errors.New(\"Heartbeats should not have a payload\")\n\nfunc (r *reader) parseHeartbeatFrame(channel uint16, size uint32) (frame frame, err error) {\n\thf := &heartbeatFrame{\n\t\tChannelId: channel,\n\t}\n\n\tif size > 0 {\n\t\treturn nil, errHeartbeatPayload\n\t}\n\n\treturn hf, nil\n}\n"
        },
        {
          "name": "read_test.go",
          "type": "blob",
          "size": 0.5166015625,
          "content": "package amqp\n\nimport (\n\t\"strings\"\n\t\"testing\"\n)\n\nfunc TestGoFuzzCrashers(t *testing.T) {\n\tif testing.Short() {\n\t\tt.Skip(\"excessive allocation\")\n\t}\n\n\ttestData := []string{\n\t\t\"\\b000000\",\n\t\t\"\\x02\\x16\\x10[\\t\\xbdui\" + \"\\x10\\x01\\x00\\xff\\xbf\\xef\\xbfn\\x99\\x00\\x10r\",\n\t\t\"\\x0300\\x00\\x00\\x00\\x040000\",\n\t}\n\n\tfor idx, testStr := range testData {\n\t\tr := reader{strings.NewReader(testStr)}\n\t\tframe, err := r.ReadFrame()\n\t\tif err != nil && frame != nil {\n\t\t\tt.Errorf(\"%d. frame is not nil: %#v err = %v\", idx, frame, err)\n\t\t}\n\t}\n}\n"
        },
        {
          "name": "reconnect_test.go",
          "type": "blob",
          "size": 2.8076171875,
          "content": "package amqp_test\n\nimport (\n\t\"fmt\"\n\t\"github.com/streadway/amqp\"\n\t\"os\"\n)\n\n// Every connection should declare the topology they expect\nfunc setup(url, queue string) (*amqp.Connection, *amqp.Channel, error) {\n\tconn, err := amqp.Dial(url)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tch, err := conn.Channel()\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tif _, err := ch.QueueDeclare(queue, false, true, false, false, nil); err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\treturn conn, ch, nil\n}\n\nfunc consume(url, queue string) (*amqp.Connection, <-chan amqp.Delivery, error) {\n\tconn, ch, err := setup(url, queue)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\t// Indicate we only want 1 message to acknowledge at a time.\n\tif err := ch.Qos(1, 0, false); err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\t// Exclusive consumer\n\tdeliveries, err := ch.Consume(queue, \"\", false, true, false, false, nil)\n\n\treturn conn, deliveries, err\n}\n\nfunc ExampleConnection_reconnect() {\n\tif url := os.Getenv(\"AMQP_URL\"); url != \"\" {\n\t\tqueue := \"example.reconnect\"\n\n\t\t// The connection/channel for publishing to interleave the ingress messages\n\t\t// between reconnects, shares the same topology as the consumer.  If we rather\n\t\t// sent all messages up front, the first consumer would receive every message.\n\t\t// We would rather show how the messages are not lost between reconnects.\n\t\t_, pub, err := setup(url, queue)\n\t\tif err != nil {\n\t\t\tfmt.Println(\"err publisher setup:\", err)\n\t\t\treturn\n\t\t}\n\n\t\t// Purge the queue from the publisher side to establish initial state\n\t\tif _, err := pub.QueuePurge(queue, false); err != nil {\n\t\t\tfmt.Println(\"err purge:\", err)\n\t\t\treturn\n\t\t}\n\n\t\t// Reconnect simulation, should be for { ... } in production\n\t\tfor i := 1; i <= 3; i++ {\n\t\t\tfmt.Println(\"connect\")\n\n\t\t\tconn, deliveries, err := consume(url, queue)\n\t\t\tif err != nil {\n\t\t\t\tfmt.Println(\"err consume:\", err)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\t// Simulate a producer on a different connection showing that consumers\n\t\t\t// continue where they were left off after each reconnect.\n\t\t\tif err := pub.Publish(\"\", queue, false, false, amqp.Publishing{\n\t\t\t\tBody: []byte(fmt.Sprintf(\"%d\", i)),\n\t\t\t}); err != nil {\n\t\t\t\tfmt.Println(\"err publish:\", err)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\t// Simulates a consumer that when the range finishes, will setup a new\n\t\t\t// session and begin ranging over the deliveries again.\n\t\t\tfor msg := range deliveries {\n\t\t\t\tfmt.Println(string(msg.Body))\n\t\t\t\tmsg.Ack(false)\n\n\t\t\t\t// Simulate an error like a server restart, loss of route or operator\n\t\t\t\t// intervention that results in the connection terminating\n\t\t\t\tgo conn.Close()\n\t\t\t}\n\t\t}\n\t} else {\n\t\t// pass with expected output when not running in an integration\n\t\t// environment.\n\t\tfmt.Println(\"connect\")\n\t\tfmt.Println(\"1\")\n\t\tfmt.Println(\"connect\")\n\t\tfmt.Println(\"2\")\n\t\tfmt.Println(\"connect\")\n\t\tfmt.Println(\"3\")\n\t}\n\n\t// Output:\n\t// connect\n\t// 1\n\t// connect\n\t// 2\n\t// connect\n\t// 3\n}\n"
        },
        {
          "name": "return.go",
          "type": "blob",
          "size": 2.2255859375,
          "content": "// Copyright (c) 2012, Sean Treadway, SoundCloud Ltd.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n// Source code and contact info at http://github.com/streadway/amqp\n\npackage amqp\n\nimport (\n\t\"time\"\n)\n\n// Return captures a flattened struct of fields returned by the server when a\n// Publishing is unable to be delivered either due to the `mandatory` flag set\n// and no route found, or `immediate` flag set and no free consumer.\ntype Return struct {\n\tReplyCode  uint16 // reason\n\tReplyText  string // description\n\tExchange   string // basic.publish exchange\n\tRoutingKey string // basic.publish routing key\n\n\t// Properties\n\tContentType     string    // MIME content type\n\tContentEncoding string    // MIME content encoding\n\tHeaders         Table     // Application or header exchange table\n\tDeliveryMode    uint8     // queue implementation use - non-persistent (1) or persistent (2)\n\tPriority        uint8     // queue implementation use - 0 to 9\n\tCorrelationId   string    // application use - correlation identifier\n\tReplyTo         string    // application use - address to to reply to (ex: RPC)\n\tExpiration      string    // implementation use - message expiration spec\n\tMessageId       string    // application use - message identifier\n\tTimestamp       time.Time // application use - message timestamp\n\tType            string    // application use - message type name\n\tUserId          string    // application use - creating user id\n\tAppId           string    // application use - creating application\n\n\tBody []byte\n}\n\nfunc newReturn(msg basicReturn) *Return {\n\tprops, body := msg.getContent()\n\n\treturn &Return{\n\t\tReplyCode:  msg.ReplyCode,\n\t\tReplyText:  msg.ReplyText,\n\t\tExchange:   msg.Exchange,\n\t\tRoutingKey: msg.RoutingKey,\n\n\t\tHeaders:         props.Headers,\n\t\tContentType:     props.ContentType,\n\t\tContentEncoding: props.ContentEncoding,\n\t\tDeliveryMode:    props.DeliveryMode,\n\t\tPriority:        props.Priority,\n\t\tCorrelationId:   props.CorrelationId,\n\t\tReplyTo:         props.ReplyTo,\n\t\tExpiration:      props.Expiration,\n\t\tMessageId:       props.MessageId,\n\t\tTimestamp:       props.Timestamp,\n\t\tType:            props.Type,\n\t\tUserId:          props.UserId,\n\t\tAppId:           props.AppId,\n\n\t\tBody: body,\n\t}\n}\n"
        },
        {
          "name": "shared_test.go",
          "type": "blob",
          "size": 1.5380859375,
          "content": "// Copyright (c) 2012, Sean Treadway, SoundCloud Ltd.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n// Source code and contact info at http://github.com/streadway/amqp\n\npackage amqp\n\nimport (\n\t\"encoding/hex\"\n\t\"io\"\n\t\"testing\"\n)\n\ntype pipe struct {\n\tr *io.PipeReader\n\tw *io.PipeWriter\n}\n\nfunc (p pipe) Read(b []byte) (int, error) {\n\treturn p.r.Read(b)\n}\n\nfunc (p pipe) Write(b []byte) (int, error) {\n\treturn p.w.Write(b)\n}\n\nfunc (p pipe) Close() error {\n\tp.r.Close()\n\tp.w.Close()\n\treturn nil\n}\n\ntype logIO struct {\n\tt      *testing.T\n\tprefix string\n\tproxy  io.ReadWriteCloser\n}\n\nfunc (log *logIO) Read(p []byte) (n int, err error) {\n\tlog.t.Logf(\"%s reading %d\\n\", log.prefix, len(p))\n\tn, err = log.proxy.Read(p)\n\tif err != nil {\n\t\tlog.t.Logf(\"%s read %x: %v\\n\", log.prefix, p[0:n], err)\n\t} else {\n\t\tlog.t.Logf(\"%s read:\\n%s\\n\", log.prefix, hex.Dump(p[0:n]))\n\t\t//fmt.Printf(\"%s read:\\n%s\\n\", log.prefix, hex.Dump(p[0:n]))\n\t}\n\treturn\n}\n\nfunc (log *logIO) Write(p []byte) (n int, err error) {\n\tlog.t.Logf(\"%s writing %d\\n\", log.prefix, len(p))\n\tn, err = log.proxy.Write(p)\n\tif err != nil {\n\t\tlog.t.Logf(\"%s write %d, %x: %v\\n\", log.prefix, len(p), p[0:n], err)\n\t} else {\n\t\tlog.t.Logf(\"%s write %d:\\n%s\", log.prefix, len(p), hex.Dump(p[0:n]))\n\t\t//fmt.Printf(\"%s write %d:\\n%s\", log.prefix, len(p), hex.Dump(p[0:n]))\n\t}\n\treturn\n}\n\nfunc (log *logIO) Close() (err error) {\n\terr = log.proxy.Close()\n\tif err != nil {\n\t\tlog.t.Logf(\"%s close : %v\\n\", log.prefix, err)\n\t} else {\n\t\tlog.t.Logf(\"%s close\\n\", log.prefix)\n\t}\n\treturn\n}\n"
        },
        {
          "name": "spec",
          "type": "tree",
          "content": null
        },
        {
          "name": "spec091.go",
          "type": "blob",
          "size": 57.84765625,
          "content": "// Copyright (c) 2012, Sean Treadway, SoundCloud Ltd.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n// Source code and contact info at http://github.com/streadway/amqp\n\n/* GENERATED FILE - DO NOT EDIT */\n/* Rebuild from the spec/gen.go tool */\n\npackage amqp\n\nimport (\n\t\"encoding/binary\"\n\t\"fmt\"\n\t\"io\"\n)\n\n// Error codes that can be sent from the server during a connection or\n// channel exception or used by the client to indicate a class of error like\n// ErrCredentials.  The text of the error is likely more interesting than\n// these constants.\nconst (\n\tframeMethod        = 1\n\tframeHeader        = 2\n\tframeBody          = 3\n\tframeHeartbeat     = 8\n\tframeMinSize       = 4096\n\tframeEnd           = 206\n\treplySuccess       = 200\n\tContentTooLarge    = 311\n\tNoRoute            = 312\n\tNoConsumers        = 313\n\tConnectionForced   = 320\n\tInvalidPath        = 402\n\tAccessRefused      = 403\n\tNotFound           = 404\n\tResourceLocked     = 405\n\tPreconditionFailed = 406\n\tFrameError         = 501\n\tSyntaxError        = 502\n\tCommandInvalid     = 503\n\tChannelError       = 504\n\tUnexpectedFrame    = 505\n\tResourceError      = 506\n\tNotAllowed         = 530\n\tNotImplemented     = 540\n\tInternalError      = 541\n)\n\nfunc isSoftExceptionCode(code int) bool {\n\tswitch code {\n\tcase 311:\n\t\treturn true\n\tcase 312:\n\t\treturn true\n\tcase 313:\n\t\treturn true\n\tcase 403:\n\t\treturn true\n\tcase 404:\n\t\treturn true\n\tcase 405:\n\t\treturn true\n\tcase 406:\n\t\treturn true\n\n\t}\n\treturn false\n}\n\ntype connectionStart struct {\n\tVersionMajor     byte\n\tVersionMinor     byte\n\tServerProperties Table\n\tMechanisms       string\n\tLocales          string\n}\n\nfunc (msg *connectionStart) id() (uint16, uint16) {\n\treturn 10, 10\n}\n\nfunc (msg *connectionStart) wait() bool {\n\treturn true\n}\n\nfunc (msg *connectionStart) write(w io.Writer) (err error) {\n\n\tif err = binary.Write(w, binary.BigEndian, msg.VersionMajor); err != nil {\n\t\treturn\n\t}\n\tif err = binary.Write(w, binary.BigEndian, msg.VersionMinor); err != nil {\n\t\treturn\n\t}\n\n\tif err = writeTable(w, msg.ServerProperties); err != nil {\n\t\treturn\n\t}\n\n\tif err = writeLongstr(w, msg.Mechanisms); err != nil {\n\t\treturn\n\t}\n\tif err = writeLongstr(w, msg.Locales); err != nil {\n\t\treturn\n\t}\n\n\treturn\n}\n\nfunc (msg *connectionStart) read(r io.Reader) (err error) {\n\n\tif err = binary.Read(r, binary.BigEndian, &msg.VersionMajor); err != nil {\n\t\treturn\n\t}\n\tif err = binary.Read(r, binary.BigEndian, &msg.VersionMinor); err != nil {\n\t\treturn\n\t}\n\n\tif msg.ServerProperties, err = readTable(r); err != nil {\n\t\treturn\n\t}\n\n\tif msg.Mechanisms, err = readLongstr(r); err != nil {\n\t\treturn\n\t}\n\tif msg.Locales, err = readLongstr(r); err != nil {\n\t\treturn\n\t}\n\n\treturn\n}\n\ntype connectionStartOk struct {\n\tClientProperties Table\n\tMechanism        string\n\tResponse         string\n\tLocale           string\n}\n\nfunc (msg *connectionStartOk) id() (uint16, uint16) {\n\treturn 10, 11\n}\n\nfunc (msg *connectionStartOk) wait() bool {\n\treturn true\n}\n\nfunc (msg *connectionStartOk) write(w io.Writer) (err error) {\n\n\tif err = writeTable(w, msg.ClientProperties); err != nil {\n\t\treturn\n\t}\n\n\tif err = writeShortstr(w, msg.Mechanism); err != nil {\n\t\treturn\n\t}\n\n\tif err = writeLongstr(w, msg.Response); err != nil {\n\t\treturn\n\t}\n\n\tif err = writeShortstr(w, msg.Locale); err != nil {\n\t\treturn\n\t}\n\n\treturn\n}\n\nfunc (msg *connectionStartOk) read(r io.Reader) (err error) {\n\n\tif msg.ClientProperties, err = readTable(r); err != nil {\n\t\treturn\n\t}\n\n\tif msg.Mechanism, err = readShortstr(r); err != nil {\n\t\treturn\n\t}\n\n\tif msg.Response, err = readLongstr(r); err != nil {\n\t\treturn\n\t}\n\n\tif msg.Locale, err = readShortstr(r); err != nil {\n\t\treturn\n\t}\n\n\treturn\n}\n\ntype connectionSecure struct {\n\tChallenge string\n}\n\nfunc (msg *connectionSecure) id() (uint16, uint16) {\n\treturn 10, 20\n}\n\nfunc (msg *connectionSecure) wait() bool {\n\treturn true\n}\n\nfunc (msg *connectionSecure) write(w io.Writer) (err error) {\n\n\tif err = writeLongstr(w, msg.Challenge); err != nil {\n\t\treturn\n\t}\n\n\treturn\n}\n\nfunc (msg *connectionSecure) read(r io.Reader) (err error) {\n\n\tif msg.Challenge, err = readLongstr(r); err != nil {\n\t\treturn\n\t}\n\n\treturn\n}\n\ntype connectionSecureOk struct {\n\tResponse string\n}\n\nfunc (msg *connectionSecureOk) id() (uint16, uint16) {\n\treturn 10, 21\n}\n\nfunc (msg *connectionSecureOk) wait() bool {\n\treturn true\n}\n\nfunc (msg *connectionSecureOk) write(w io.Writer) (err error) {\n\n\tif err = writeLongstr(w, msg.Response); err != nil {\n\t\treturn\n\t}\n\n\treturn\n}\n\nfunc (msg *connectionSecureOk) read(r io.Reader) (err error) {\n\n\tif msg.Response, err = readLongstr(r); err != nil {\n\t\treturn\n\t}\n\n\treturn\n}\n\ntype connectionTune struct {\n\tChannelMax uint16\n\tFrameMax   uint32\n\tHeartbeat  uint16\n}\n\nfunc (msg *connectionTune) id() (uint16, uint16) {\n\treturn 10, 30\n}\n\nfunc (msg *connectionTune) wait() bool {\n\treturn true\n}\n\nfunc (msg *connectionTune) write(w io.Writer) (err error) {\n\n\tif err = binary.Write(w, binary.BigEndian, msg.ChannelMax); err != nil {\n\t\treturn\n\t}\n\n\tif err = binary.Write(w, binary.BigEndian, msg.FrameMax); err != nil {\n\t\treturn\n\t}\n\n\tif err = binary.Write(w, binary.BigEndian, msg.Heartbeat); err != nil {\n\t\treturn\n\t}\n\n\treturn\n}\n\nfunc (msg *connectionTune) read(r io.Reader) (err error) {\n\n\tif err = binary.Read(r, binary.BigEndian, &msg.ChannelMax); err != nil {\n\t\treturn\n\t}\n\n\tif err = binary.Read(r, binary.BigEndian, &msg.FrameMax); err != nil {\n\t\treturn\n\t}\n\n\tif err = binary.Read(r, binary.BigEndian, &msg.Heartbeat); err != nil {\n\t\treturn\n\t}\n\n\treturn\n}\n\ntype connectionTuneOk struct {\n\tChannelMax uint16\n\tFrameMax   uint32\n\tHeartbeat  uint16\n}\n\nfunc (msg *connectionTuneOk) id() (uint16, uint16) {\n\treturn 10, 31\n}\n\nfunc (msg *connectionTuneOk) wait() bool {\n\treturn true\n}\n\nfunc (msg *connectionTuneOk) write(w io.Writer) (err error) {\n\n\tif err = binary.Write(w, binary.BigEndian, msg.ChannelMax); err != nil {\n\t\treturn\n\t}\n\n\tif err = binary.Write(w, binary.BigEndian, msg.FrameMax); err != nil {\n\t\treturn\n\t}\n\n\tif err = binary.Write(w, binary.BigEndian, msg.Heartbeat); err != nil {\n\t\treturn\n\t}\n\n\treturn\n}\n\nfunc (msg *connectionTuneOk) read(r io.Reader) (err error) {\n\n\tif err = binary.Read(r, binary.BigEndian, &msg.ChannelMax); err != nil {\n\t\treturn\n\t}\n\n\tif err = binary.Read(r, binary.BigEndian, &msg.FrameMax); err != nil {\n\t\treturn\n\t}\n\n\tif err = binary.Read(r, binary.BigEndian, &msg.Heartbeat); err != nil {\n\t\treturn\n\t}\n\n\treturn\n}\n\ntype connectionOpen struct {\n\tVirtualHost string\n\treserved1   string\n\treserved2   bool\n}\n\nfunc (msg *connectionOpen) id() (uint16, uint16) {\n\treturn 10, 40\n}\n\nfunc (msg *connectionOpen) wait() bool {\n\treturn true\n}\n\nfunc (msg *connectionOpen) write(w io.Writer) (err error) {\n\tvar bits byte\n\n\tif err = writeShortstr(w, msg.VirtualHost); err != nil {\n\t\treturn\n\t}\n\tif err = writeShortstr(w, msg.reserved1); err != nil {\n\t\treturn\n\t}\n\n\tif msg.reserved2 {\n\t\tbits |= 1 << 0\n\t}\n\n\tif err = binary.Write(w, binary.BigEndian, bits); err != nil {\n\t\treturn\n\t}\n\n\treturn\n}\n\nfunc (msg *connectionOpen) read(r io.Reader) (err error) {\n\tvar bits byte\n\n\tif msg.VirtualHost, err = readShortstr(r); err != nil {\n\t\treturn\n\t}\n\tif msg.reserved1, err = readShortstr(r); err != nil {\n\t\treturn\n\t}\n\n\tif err = binary.Read(r, binary.BigEndian, &bits); err != nil {\n\t\treturn\n\t}\n\tmsg.reserved2 = (bits&(1<<0) > 0)\n\n\treturn\n}\n\ntype connectionOpenOk struct {\n\treserved1 string\n}\n\nfunc (msg *connectionOpenOk) id() (uint16, uint16) {\n\treturn 10, 41\n}\n\nfunc (msg *connectionOpenOk) wait() bool {\n\treturn true\n}\n\nfunc (msg *connectionOpenOk) write(w io.Writer) (err error) {\n\n\tif err = writeShortstr(w, msg.reserved1); err != nil {\n\t\treturn\n\t}\n\n\treturn\n}\n\nfunc (msg *connectionOpenOk) read(r io.Reader) (err error) {\n\n\tif msg.reserved1, err = readShortstr(r); err != nil {\n\t\treturn\n\t}\n\n\treturn\n}\n\ntype connectionClose struct {\n\tReplyCode uint16\n\tReplyText string\n\tClassId   uint16\n\tMethodId  uint16\n}\n\nfunc (msg *connectionClose) id() (uint16, uint16) {\n\treturn 10, 50\n}\n\nfunc (msg *connectionClose) wait() bool {\n\treturn true\n}\n\nfunc (msg *connectionClose) write(w io.Writer) (err error) {\n\n\tif err = binary.Write(w, binary.BigEndian, msg.ReplyCode); err != nil {\n\t\treturn\n\t}\n\n\tif err = writeShortstr(w, msg.ReplyText); err != nil {\n\t\treturn\n\t}\n\n\tif err = binary.Write(w, binary.BigEndian, msg.ClassId); err != nil {\n\t\treturn\n\t}\n\tif err = binary.Write(w, binary.BigEndian, msg.MethodId); err != nil {\n\t\treturn\n\t}\n\n\treturn\n}\n\nfunc (msg *connectionClose) read(r io.Reader) (err error) {\n\n\tif err = binary.Read(r, binary.BigEndian, &msg.ReplyCode); err != nil {\n\t\treturn\n\t}\n\n\tif msg.ReplyText, err = readShortstr(r); err != nil {\n\t\treturn\n\t}\n\n\tif err = binary.Read(r, binary.BigEndian, &msg.ClassId); err != nil {\n\t\treturn\n\t}\n\tif err = binary.Read(r, binary.BigEndian, &msg.MethodId); err != nil {\n\t\treturn\n\t}\n\n\treturn\n}\n\ntype connectionCloseOk struct {\n}\n\nfunc (msg *connectionCloseOk) id() (uint16, uint16) {\n\treturn 10, 51\n}\n\nfunc (msg *connectionCloseOk) wait() bool {\n\treturn true\n}\n\nfunc (msg *connectionCloseOk) write(w io.Writer) (err error) {\n\n\treturn\n}\n\nfunc (msg *connectionCloseOk) read(r io.Reader) (err error) {\n\n\treturn\n}\n\ntype connectionBlocked struct {\n\tReason string\n}\n\nfunc (msg *connectionBlocked) id() (uint16, uint16) {\n\treturn 10, 60\n}\n\nfunc (msg *connectionBlocked) wait() bool {\n\treturn false\n}\n\nfunc (msg *connectionBlocked) write(w io.Writer) (err error) {\n\n\tif err = writeShortstr(w, msg.Reason); err != nil {\n\t\treturn\n\t}\n\n\treturn\n}\n\nfunc (msg *connectionBlocked) read(r io.Reader) (err error) {\n\n\tif msg.Reason, err = readShortstr(r); err != nil {\n\t\treturn\n\t}\n\n\treturn\n}\n\ntype connectionUnblocked struct {\n}\n\nfunc (msg *connectionUnblocked) id() (uint16, uint16) {\n\treturn 10, 61\n}\n\nfunc (msg *connectionUnblocked) wait() bool {\n\treturn false\n}\n\nfunc (msg *connectionUnblocked) write(w io.Writer) (err error) {\n\n\treturn\n}\n\nfunc (msg *connectionUnblocked) read(r io.Reader) (err error) {\n\n\treturn\n}\n\ntype channelOpen struct {\n\treserved1 string\n}\n\nfunc (msg *channelOpen) id() (uint16, uint16) {\n\treturn 20, 10\n}\n\nfunc (msg *channelOpen) wait() bool {\n\treturn true\n}\n\nfunc (msg *channelOpen) write(w io.Writer) (err error) {\n\n\tif err = writeShortstr(w, msg.reserved1); err != nil {\n\t\treturn\n\t}\n\n\treturn\n}\n\nfunc (msg *channelOpen) read(r io.Reader) (err error) {\n\n\tif msg.reserved1, err = readShortstr(r); err != nil {\n\t\treturn\n\t}\n\n\treturn\n}\n\ntype channelOpenOk struct {\n\treserved1 string\n}\n\nfunc (msg *channelOpenOk) id() (uint16, uint16) {\n\treturn 20, 11\n}\n\nfunc (msg *channelOpenOk) wait() bool {\n\treturn true\n}\n\nfunc (msg *channelOpenOk) write(w io.Writer) (err error) {\n\n\tif err = writeLongstr(w, msg.reserved1); err != nil {\n\t\treturn\n\t}\n\n\treturn\n}\n\nfunc (msg *channelOpenOk) read(r io.Reader) (err error) {\n\n\tif msg.reserved1, err = readLongstr(r); err != nil {\n\t\treturn\n\t}\n\n\treturn\n}\n\ntype channelFlow struct {\n\tActive bool\n}\n\nfunc (msg *channelFlow) id() (uint16, uint16) {\n\treturn 20, 20\n}\n\nfunc (msg *channelFlow) wait() bool {\n\treturn true\n}\n\nfunc (msg *channelFlow) write(w io.Writer) (err error) {\n\tvar bits byte\n\n\tif msg.Active {\n\t\tbits |= 1 << 0\n\t}\n\n\tif err = binary.Write(w, binary.BigEndian, bits); err != nil {\n\t\treturn\n\t}\n\n\treturn\n}\n\nfunc (msg *channelFlow) read(r io.Reader) (err error) {\n\tvar bits byte\n\n\tif err = binary.Read(r, binary.BigEndian, &bits); err != nil {\n\t\treturn\n\t}\n\tmsg.Active = (bits&(1<<0) > 0)\n\n\treturn\n}\n\ntype channelFlowOk struct {\n\tActive bool\n}\n\nfunc (msg *channelFlowOk) id() (uint16, uint16) {\n\treturn 20, 21\n}\n\nfunc (msg *channelFlowOk) wait() bool {\n\treturn false\n}\n\nfunc (msg *channelFlowOk) write(w io.Writer) (err error) {\n\tvar bits byte\n\n\tif msg.Active {\n\t\tbits |= 1 << 0\n\t}\n\n\tif err = binary.Write(w, binary.BigEndian, bits); err != nil {\n\t\treturn\n\t}\n\n\treturn\n}\n\nfunc (msg *channelFlowOk) read(r io.Reader) (err error) {\n\tvar bits byte\n\n\tif err = binary.Read(r, binary.BigEndian, &bits); err != nil {\n\t\treturn\n\t}\n\tmsg.Active = (bits&(1<<0) > 0)\n\n\treturn\n}\n\ntype channelClose struct {\n\tReplyCode uint16\n\tReplyText string\n\tClassId   uint16\n\tMethodId  uint16\n}\n\nfunc (msg *channelClose) id() (uint16, uint16) {\n\treturn 20, 40\n}\n\nfunc (msg *channelClose) wait() bool {\n\treturn true\n}\n\nfunc (msg *channelClose) write(w io.Writer) (err error) {\n\n\tif err = binary.Write(w, binary.BigEndian, msg.ReplyCode); err != nil {\n\t\treturn\n\t}\n\n\tif err = writeShortstr(w, msg.ReplyText); err != nil {\n\t\treturn\n\t}\n\n\tif err = binary.Write(w, binary.BigEndian, msg.ClassId); err != nil {\n\t\treturn\n\t}\n\tif err = binary.Write(w, binary.BigEndian, msg.MethodId); err != nil {\n\t\treturn\n\t}\n\n\treturn\n}\n\nfunc (msg *channelClose) read(r io.Reader) (err error) {\n\n\tif err = binary.Read(r, binary.BigEndian, &msg.ReplyCode); err != nil {\n\t\treturn\n\t}\n\n\tif msg.ReplyText, err = readShortstr(r); err != nil {\n\t\treturn\n\t}\n\n\tif err = binary.Read(r, binary.BigEndian, &msg.ClassId); err != nil {\n\t\treturn\n\t}\n\tif err = binary.Read(r, binary.BigEndian, &msg.MethodId); err != nil {\n\t\treturn\n\t}\n\n\treturn\n}\n\ntype channelCloseOk struct {\n}\n\nfunc (msg *channelCloseOk) id() (uint16, uint16) {\n\treturn 20, 41\n}\n\nfunc (msg *channelCloseOk) wait() bool {\n\treturn true\n}\n\nfunc (msg *channelCloseOk) write(w io.Writer) (err error) {\n\n\treturn\n}\n\nfunc (msg *channelCloseOk) read(r io.Reader) (err error) {\n\n\treturn\n}\n\ntype exchangeDeclare struct {\n\treserved1  uint16\n\tExchange   string\n\tType       string\n\tPassive    bool\n\tDurable    bool\n\tAutoDelete bool\n\tInternal   bool\n\tNoWait     bool\n\tArguments  Table\n}\n\nfunc (msg *exchangeDeclare) id() (uint16, uint16) {\n\treturn 40, 10\n}\n\nfunc (msg *exchangeDeclare) wait() bool {\n\treturn true && !msg.NoWait\n}\n\nfunc (msg *exchangeDeclare) write(w io.Writer) (err error) {\n\tvar bits byte\n\n\tif err = binary.Write(w, binary.BigEndian, msg.reserved1); err != nil {\n\t\treturn\n\t}\n\n\tif err = writeShortstr(w, msg.Exchange); err != nil {\n\t\treturn\n\t}\n\tif err = writeShortstr(w, msg.Type); err != nil {\n\t\treturn\n\t}\n\n\tif msg.Passive {\n\t\tbits |= 1 << 0\n\t}\n\n\tif msg.Durable {\n\t\tbits |= 1 << 1\n\t}\n\n\tif msg.AutoDelete {\n\t\tbits |= 1 << 2\n\t}\n\n\tif msg.Internal {\n\t\tbits |= 1 << 3\n\t}\n\n\tif msg.NoWait {\n\t\tbits |= 1 << 4\n\t}\n\n\tif err = binary.Write(w, binary.BigEndian, bits); err != nil {\n\t\treturn\n\t}\n\n\tif err = writeTable(w, msg.Arguments); err != nil {\n\t\treturn\n\t}\n\n\treturn\n}\n\nfunc (msg *exchangeDeclare) read(r io.Reader) (err error) {\n\tvar bits byte\n\n\tif err = binary.Read(r, binary.BigEndian, &msg.reserved1); err != nil {\n\t\treturn\n\t}\n\n\tif msg.Exchange, err = readShortstr(r); err != nil {\n\t\treturn\n\t}\n\tif msg.Type, err = readShortstr(r); err != nil {\n\t\treturn\n\t}\n\n\tif err = binary.Read(r, binary.BigEndian, &bits); err != nil {\n\t\treturn\n\t}\n\tmsg.Passive = (bits&(1<<0) > 0)\n\tmsg.Durable = (bits&(1<<1) > 0)\n\tmsg.AutoDelete = (bits&(1<<2) > 0)\n\tmsg.Internal = (bits&(1<<3) > 0)\n\tmsg.NoWait = (bits&(1<<4) > 0)\n\n\tif msg.Arguments, err = readTable(r); err != nil {\n\t\treturn\n\t}\n\n\treturn\n}\n\ntype exchangeDeclareOk struct {\n}\n\nfunc (msg *exchangeDeclareOk) id() (uint16, uint16) {\n\treturn 40, 11\n}\n\nfunc (msg *exchangeDeclareOk) wait() bool {\n\treturn true\n}\n\nfunc (msg *exchangeDeclareOk) write(w io.Writer) (err error) {\n\n\treturn\n}\n\nfunc (msg *exchangeDeclareOk) read(r io.Reader) (err error) {\n\n\treturn\n}\n\ntype exchangeDelete struct {\n\treserved1 uint16\n\tExchange  string\n\tIfUnused  bool\n\tNoWait    bool\n}\n\nfunc (msg *exchangeDelete) id() (uint16, uint16) {\n\treturn 40, 20\n}\n\nfunc (msg *exchangeDelete) wait() bool {\n\treturn true && !msg.NoWait\n}\n\nfunc (msg *exchangeDelete) write(w io.Writer) (err error) {\n\tvar bits byte\n\n\tif err = binary.Write(w, binary.BigEndian, msg.reserved1); err != nil {\n\t\treturn\n\t}\n\n\tif err = writeShortstr(w, msg.Exchange); err != nil {\n\t\treturn\n\t}\n\n\tif msg.IfUnused {\n\t\tbits |= 1 << 0\n\t}\n\n\tif msg.NoWait {\n\t\tbits |= 1 << 1\n\t}\n\n\tif err = binary.Write(w, binary.BigEndian, bits); err != nil {\n\t\treturn\n\t}\n\n\treturn\n}\n\nfunc (msg *exchangeDelete) read(r io.Reader) (err error) {\n\tvar bits byte\n\n\tif err = binary.Read(r, binary.BigEndian, &msg.reserved1); err != nil {\n\t\treturn\n\t}\n\n\tif msg.Exchange, err = readShortstr(r); err != nil {\n\t\treturn\n\t}\n\n\tif err = binary.Read(r, binary.BigEndian, &bits); err != nil {\n\t\treturn\n\t}\n\tmsg.IfUnused = (bits&(1<<0) > 0)\n\tmsg.NoWait = (bits&(1<<1) > 0)\n\n\treturn\n}\n\ntype exchangeDeleteOk struct {\n}\n\nfunc (msg *exchangeDeleteOk) id() (uint16, uint16) {\n\treturn 40, 21\n}\n\nfunc (msg *exchangeDeleteOk) wait() bool {\n\treturn true\n}\n\nfunc (msg *exchangeDeleteOk) write(w io.Writer) (err error) {\n\n\treturn\n}\n\nfunc (msg *exchangeDeleteOk) read(r io.Reader) (err error) {\n\n\treturn\n}\n\ntype exchangeBind struct {\n\treserved1   uint16\n\tDestination string\n\tSource      string\n\tRoutingKey  string\n\tNoWait      bool\n\tArguments   Table\n}\n\nfunc (msg *exchangeBind) id() (uint16, uint16) {\n\treturn 40, 30\n}\n\nfunc (msg *exchangeBind) wait() bool {\n\treturn true && !msg.NoWait\n}\n\nfunc (msg *exchangeBind) write(w io.Writer) (err error) {\n\tvar bits byte\n\n\tif err = binary.Write(w, binary.BigEndian, msg.reserved1); err != nil {\n\t\treturn\n\t}\n\n\tif err = writeShortstr(w, msg.Destination); err != nil {\n\t\treturn\n\t}\n\tif err = writeShortstr(w, msg.Source); err != nil {\n\t\treturn\n\t}\n\tif err = writeShortstr(w, msg.RoutingKey); err != nil {\n\t\treturn\n\t}\n\n\tif msg.NoWait {\n\t\tbits |= 1 << 0\n\t}\n\n\tif err = binary.Write(w, binary.BigEndian, bits); err != nil {\n\t\treturn\n\t}\n\n\tif err = writeTable(w, msg.Arguments); err != nil {\n\t\treturn\n\t}\n\n\treturn\n}\n\nfunc (msg *exchangeBind) read(r io.Reader) (err error) {\n\tvar bits byte\n\n\tif err = binary.Read(r, binary.BigEndian, &msg.reserved1); err != nil {\n\t\treturn\n\t}\n\n\tif msg.Destination, err = readShortstr(r); err != nil {\n\t\treturn\n\t}\n\tif msg.Source, err = readShortstr(r); err != nil {\n\t\treturn\n\t}\n\tif msg.RoutingKey, err = readShortstr(r); err != nil {\n\t\treturn\n\t}\n\n\tif err = binary.Read(r, binary.BigEndian, &bits); err != nil {\n\t\treturn\n\t}\n\tmsg.NoWait = (bits&(1<<0) > 0)\n\n\tif msg.Arguments, err = readTable(r); err != nil {\n\t\treturn\n\t}\n\n\treturn\n}\n\ntype exchangeBindOk struct {\n}\n\nfunc (msg *exchangeBindOk) id() (uint16, uint16) {\n\treturn 40, 31\n}\n\nfunc (msg *exchangeBindOk) wait() bool {\n\treturn true\n}\n\nfunc (msg *exchangeBindOk) write(w io.Writer) (err error) {\n\n\treturn\n}\n\nfunc (msg *exchangeBindOk) read(r io.Reader) (err error) {\n\n\treturn\n}\n\ntype exchangeUnbind struct {\n\treserved1   uint16\n\tDestination string\n\tSource      string\n\tRoutingKey  string\n\tNoWait      bool\n\tArguments   Table\n}\n\nfunc (msg *exchangeUnbind) id() (uint16, uint16) {\n\treturn 40, 40\n}\n\nfunc (msg *exchangeUnbind) wait() bool {\n\treturn true && !msg.NoWait\n}\n\nfunc (msg *exchangeUnbind) write(w io.Writer) (err error) {\n\tvar bits byte\n\n\tif err = binary.Write(w, binary.BigEndian, msg.reserved1); err != nil {\n\t\treturn\n\t}\n\n\tif err = writeShortstr(w, msg.Destination); err != nil {\n\t\treturn\n\t}\n\tif err = writeShortstr(w, msg.Source); err != nil {\n\t\treturn\n\t}\n\tif err = writeShortstr(w, msg.RoutingKey); err != nil {\n\t\treturn\n\t}\n\n\tif msg.NoWait {\n\t\tbits |= 1 << 0\n\t}\n\n\tif err = binary.Write(w, binary.BigEndian, bits); err != nil {\n\t\treturn\n\t}\n\n\tif err = writeTable(w, msg.Arguments); err != nil {\n\t\treturn\n\t}\n\n\treturn\n}\n\nfunc (msg *exchangeUnbind) read(r io.Reader) (err error) {\n\tvar bits byte\n\n\tif err = binary.Read(r, binary.BigEndian, &msg.reserved1); err != nil {\n\t\treturn\n\t}\n\n\tif msg.Destination, err = readShortstr(r); err != nil {\n\t\treturn\n\t}\n\tif msg.Source, err = readShortstr(r); err != nil {\n\t\treturn\n\t}\n\tif msg.RoutingKey, err = readShortstr(r); err != nil {\n\t\treturn\n\t}\n\n\tif err = binary.Read(r, binary.BigEndian, &bits); err != nil {\n\t\treturn\n\t}\n\tmsg.NoWait = (bits&(1<<0) > 0)\n\n\tif msg.Arguments, err = readTable(r); err != nil {\n\t\treturn\n\t}\n\n\treturn\n}\n\ntype exchangeUnbindOk struct {\n}\n\nfunc (msg *exchangeUnbindOk) id() (uint16, uint16) {\n\treturn 40, 51\n}\n\nfunc (msg *exchangeUnbindOk) wait() bool {\n\treturn true\n}\n\nfunc (msg *exchangeUnbindOk) write(w io.Writer) (err error) {\n\n\treturn\n}\n\nfunc (msg *exchangeUnbindOk) read(r io.Reader) (err error) {\n\n\treturn\n}\n\ntype queueDeclare struct {\n\treserved1  uint16\n\tQueue      string\n\tPassive    bool\n\tDurable    bool\n\tExclusive  bool\n\tAutoDelete bool\n\tNoWait     bool\n\tArguments  Table\n}\n\nfunc (msg *queueDeclare) id() (uint16, uint16) {\n\treturn 50, 10\n}\n\nfunc (msg *queueDeclare) wait() bool {\n\treturn true && !msg.NoWait\n}\n\nfunc (msg *queueDeclare) write(w io.Writer) (err error) {\n\tvar bits byte\n\n\tif err = binary.Write(w, binary.BigEndian, msg.reserved1); err != nil {\n\t\treturn\n\t}\n\n\tif err = writeShortstr(w, msg.Queue); err != nil {\n\t\treturn\n\t}\n\n\tif msg.Passive {\n\t\tbits |= 1 << 0\n\t}\n\n\tif msg.Durable {\n\t\tbits |= 1 << 1\n\t}\n\n\tif msg.Exclusive {\n\t\tbits |= 1 << 2\n\t}\n\n\tif msg.AutoDelete {\n\t\tbits |= 1 << 3\n\t}\n\n\tif msg.NoWait {\n\t\tbits |= 1 << 4\n\t}\n\n\tif err = binary.Write(w, binary.BigEndian, bits); err != nil {\n\t\treturn\n\t}\n\n\tif err = writeTable(w, msg.Arguments); err != nil {\n\t\treturn\n\t}\n\n\treturn\n}\n\nfunc (msg *queueDeclare) read(r io.Reader) (err error) {\n\tvar bits byte\n\n\tif err = binary.Read(r, binary.BigEndian, &msg.reserved1); err != nil {\n\t\treturn\n\t}\n\n\tif msg.Queue, err = readShortstr(r); err != nil {\n\t\treturn\n\t}\n\n\tif err = binary.Read(r, binary.BigEndian, &bits); err != nil {\n\t\treturn\n\t}\n\tmsg.Passive = (bits&(1<<0) > 0)\n\tmsg.Durable = (bits&(1<<1) > 0)\n\tmsg.Exclusive = (bits&(1<<2) > 0)\n\tmsg.AutoDelete = (bits&(1<<3) > 0)\n\tmsg.NoWait = (bits&(1<<4) > 0)\n\n\tif msg.Arguments, err = readTable(r); err != nil {\n\t\treturn\n\t}\n\n\treturn\n}\n\ntype queueDeclareOk struct {\n\tQueue         string\n\tMessageCount  uint32\n\tConsumerCount uint32\n}\n\nfunc (msg *queueDeclareOk) id() (uint16, uint16) {\n\treturn 50, 11\n}\n\nfunc (msg *queueDeclareOk) wait() bool {\n\treturn true\n}\n\nfunc (msg *queueDeclareOk) write(w io.Writer) (err error) {\n\n\tif err = writeShortstr(w, msg.Queue); err != nil {\n\t\treturn\n\t}\n\n\tif err = binary.Write(w, binary.BigEndian, msg.MessageCount); err != nil {\n\t\treturn\n\t}\n\tif err = binary.Write(w, binary.BigEndian, msg.ConsumerCount); err != nil {\n\t\treturn\n\t}\n\n\treturn\n}\n\nfunc (msg *queueDeclareOk) read(r io.Reader) (err error) {\n\n\tif msg.Queue, err = readShortstr(r); err != nil {\n\t\treturn\n\t}\n\n\tif err = binary.Read(r, binary.BigEndian, &msg.MessageCount); err != nil {\n\t\treturn\n\t}\n\tif err = binary.Read(r, binary.BigEndian, &msg.ConsumerCount); err != nil {\n\t\treturn\n\t}\n\n\treturn\n}\n\ntype queueBind struct {\n\treserved1  uint16\n\tQueue      string\n\tExchange   string\n\tRoutingKey string\n\tNoWait     bool\n\tArguments  Table\n}\n\nfunc (msg *queueBind) id() (uint16, uint16) {\n\treturn 50, 20\n}\n\nfunc (msg *queueBind) wait() bool {\n\treturn true && !msg.NoWait\n}\n\nfunc (msg *queueBind) write(w io.Writer) (err error) {\n\tvar bits byte\n\n\tif err = binary.Write(w, binary.BigEndian, msg.reserved1); err != nil {\n\t\treturn\n\t}\n\n\tif err = writeShortstr(w, msg.Queue); err != nil {\n\t\treturn\n\t}\n\tif err = writeShortstr(w, msg.Exchange); err != nil {\n\t\treturn\n\t}\n\tif err = writeShortstr(w, msg.RoutingKey); err != nil {\n\t\treturn\n\t}\n\n\tif msg.NoWait {\n\t\tbits |= 1 << 0\n\t}\n\n\tif err = binary.Write(w, binary.BigEndian, bits); err != nil {\n\t\treturn\n\t}\n\n\tif err = writeTable(w, msg.Arguments); err != nil {\n\t\treturn\n\t}\n\n\treturn\n}\n\nfunc (msg *queueBind) read(r io.Reader) (err error) {\n\tvar bits byte\n\n\tif err = binary.Read(r, binary.BigEndian, &msg.reserved1); err != nil {\n\t\treturn\n\t}\n\n\tif msg.Queue, err = readShortstr(r); err != nil {\n\t\treturn\n\t}\n\tif msg.Exchange, err = readShortstr(r); err != nil {\n\t\treturn\n\t}\n\tif msg.RoutingKey, err = readShortstr(r); err != nil {\n\t\treturn\n\t}\n\n\tif err = binary.Read(r, binary.BigEndian, &bits); err != nil {\n\t\treturn\n\t}\n\tmsg.NoWait = (bits&(1<<0) > 0)\n\n\tif msg.Arguments, err = readTable(r); err != nil {\n\t\treturn\n\t}\n\n\treturn\n}\n\ntype queueBindOk struct {\n}\n\nfunc (msg *queueBindOk) id() (uint16, uint16) {\n\treturn 50, 21\n}\n\nfunc (msg *queueBindOk) wait() bool {\n\treturn true\n}\n\nfunc (msg *queueBindOk) write(w io.Writer) (err error) {\n\n\treturn\n}\n\nfunc (msg *queueBindOk) read(r io.Reader) (err error) {\n\n\treturn\n}\n\ntype queueUnbind struct {\n\treserved1  uint16\n\tQueue      string\n\tExchange   string\n\tRoutingKey string\n\tArguments  Table\n}\n\nfunc (msg *queueUnbind) id() (uint16, uint16) {\n\treturn 50, 50\n}\n\nfunc (msg *queueUnbind) wait() bool {\n\treturn true\n}\n\nfunc (msg *queueUnbind) write(w io.Writer) (err error) {\n\n\tif err = binary.Write(w, binary.BigEndian, msg.reserved1); err != nil {\n\t\treturn\n\t}\n\n\tif err = writeShortstr(w, msg.Queue); err != nil {\n\t\treturn\n\t}\n\tif err = writeShortstr(w, msg.Exchange); err != nil {\n\t\treturn\n\t}\n\tif err = writeShortstr(w, msg.RoutingKey); err != nil {\n\t\treturn\n\t}\n\n\tif err = writeTable(w, msg.Arguments); err != nil {\n\t\treturn\n\t}\n\n\treturn\n}\n\nfunc (msg *queueUnbind) read(r io.Reader) (err error) {\n\n\tif err = binary.Read(r, binary.BigEndian, &msg.reserved1); err != nil {\n\t\treturn\n\t}\n\n\tif msg.Queue, err = readShortstr(r); err != nil {\n\t\treturn\n\t}\n\tif msg.Exchange, err = readShortstr(r); err != nil {\n\t\treturn\n\t}\n\tif msg.RoutingKey, err = readShortstr(r); err != nil {\n\t\treturn\n\t}\n\n\tif msg.Arguments, err = readTable(r); err != nil {\n\t\treturn\n\t}\n\n\treturn\n}\n\ntype queueUnbindOk struct {\n}\n\nfunc (msg *queueUnbindOk) id() (uint16, uint16) {\n\treturn 50, 51\n}\n\nfunc (msg *queueUnbindOk) wait() bool {\n\treturn true\n}\n\nfunc (msg *queueUnbindOk) write(w io.Writer) (err error) {\n\n\treturn\n}\n\nfunc (msg *queueUnbindOk) read(r io.Reader) (err error) {\n\n\treturn\n}\n\ntype queuePurge struct {\n\treserved1 uint16\n\tQueue     string\n\tNoWait    bool\n}\n\nfunc (msg *queuePurge) id() (uint16, uint16) {\n\treturn 50, 30\n}\n\nfunc (msg *queuePurge) wait() bool {\n\treturn true && !msg.NoWait\n}\n\nfunc (msg *queuePurge) write(w io.Writer) (err error) {\n\tvar bits byte\n\n\tif err = binary.Write(w, binary.BigEndian, msg.reserved1); err != nil {\n\t\treturn\n\t}\n\n\tif err = writeShortstr(w, msg.Queue); err != nil {\n\t\treturn\n\t}\n\n\tif msg.NoWait {\n\t\tbits |= 1 << 0\n\t}\n\n\tif err = binary.Write(w, binary.BigEndian, bits); err != nil {\n\t\treturn\n\t}\n\n\treturn\n}\n\nfunc (msg *queuePurge) read(r io.Reader) (err error) {\n\tvar bits byte\n\n\tif err = binary.Read(r, binary.BigEndian, &msg.reserved1); err != nil {\n\t\treturn\n\t}\n\n\tif msg.Queue, err = readShortstr(r); err != nil {\n\t\treturn\n\t}\n\n\tif err = binary.Read(r, binary.BigEndian, &bits); err != nil {\n\t\treturn\n\t}\n\tmsg.NoWait = (bits&(1<<0) > 0)\n\n\treturn\n}\n\ntype queuePurgeOk struct {\n\tMessageCount uint32\n}\n\nfunc (msg *queuePurgeOk) id() (uint16, uint16) {\n\treturn 50, 31\n}\n\nfunc (msg *queuePurgeOk) wait() bool {\n\treturn true\n}\n\nfunc (msg *queuePurgeOk) write(w io.Writer) (err error) {\n\n\tif err = binary.Write(w, binary.BigEndian, msg.MessageCount); err != nil {\n\t\treturn\n\t}\n\n\treturn\n}\n\nfunc (msg *queuePurgeOk) read(r io.Reader) (err error) {\n\n\tif err = binary.Read(r, binary.BigEndian, &msg.MessageCount); err != nil {\n\t\treturn\n\t}\n\n\treturn\n}\n\ntype queueDelete struct {\n\treserved1 uint16\n\tQueue     string\n\tIfUnused  bool\n\tIfEmpty   bool\n\tNoWait    bool\n}\n\nfunc (msg *queueDelete) id() (uint16, uint16) {\n\treturn 50, 40\n}\n\nfunc (msg *queueDelete) wait() bool {\n\treturn true && !msg.NoWait\n}\n\nfunc (msg *queueDelete) write(w io.Writer) (err error) {\n\tvar bits byte\n\n\tif err = binary.Write(w, binary.BigEndian, msg.reserved1); err != nil {\n\t\treturn\n\t}\n\n\tif err = writeShortstr(w, msg.Queue); err != nil {\n\t\treturn\n\t}\n\n\tif msg.IfUnused {\n\t\tbits |= 1 << 0\n\t}\n\n\tif msg.IfEmpty {\n\t\tbits |= 1 << 1\n\t}\n\n\tif msg.NoWait {\n\t\tbits |= 1 << 2\n\t}\n\n\tif err = binary.Write(w, binary.BigEndian, bits); err != nil {\n\t\treturn\n\t}\n\n\treturn\n}\n\nfunc (msg *queueDelete) read(r io.Reader) (err error) {\n\tvar bits byte\n\n\tif err = binary.Read(r, binary.BigEndian, &msg.reserved1); err != nil {\n\t\treturn\n\t}\n\n\tif msg.Queue, err = readShortstr(r); err != nil {\n\t\treturn\n\t}\n\n\tif err = binary.Read(r, binary.BigEndian, &bits); err != nil {\n\t\treturn\n\t}\n\tmsg.IfUnused = (bits&(1<<0) > 0)\n\tmsg.IfEmpty = (bits&(1<<1) > 0)\n\tmsg.NoWait = (bits&(1<<2) > 0)\n\n\treturn\n}\n\ntype queueDeleteOk struct {\n\tMessageCount uint32\n}\n\nfunc (msg *queueDeleteOk) id() (uint16, uint16) {\n\treturn 50, 41\n}\n\nfunc (msg *queueDeleteOk) wait() bool {\n\treturn true\n}\n\nfunc (msg *queueDeleteOk) write(w io.Writer) (err error) {\n\n\tif err = binary.Write(w, binary.BigEndian, msg.MessageCount); err != nil {\n\t\treturn\n\t}\n\n\treturn\n}\n\nfunc (msg *queueDeleteOk) read(r io.Reader) (err error) {\n\n\tif err = binary.Read(r, binary.BigEndian, &msg.MessageCount); err != nil {\n\t\treturn\n\t}\n\n\treturn\n}\n\ntype basicQos struct {\n\tPrefetchSize  uint32\n\tPrefetchCount uint16\n\tGlobal        bool\n}\n\nfunc (msg *basicQos) id() (uint16, uint16) {\n\treturn 60, 10\n}\n\nfunc (msg *basicQos) wait() bool {\n\treturn true\n}\n\nfunc (msg *basicQos) write(w io.Writer) (err error) {\n\tvar bits byte\n\n\tif err = binary.Write(w, binary.BigEndian, msg.PrefetchSize); err != nil {\n\t\treturn\n\t}\n\n\tif err = binary.Write(w, binary.BigEndian, msg.PrefetchCount); err != nil {\n\t\treturn\n\t}\n\n\tif msg.Global {\n\t\tbits |= 1 << 0\n\t}\n\n\tif err = binary.Write(w, binary.BigEndian, bits); err != nil {\n\t\treturn\n\t}\n\n\treturn\n}\n\nfunc (msg *basicQos) read(r io.Reader) (err error) {\n\tvar bits byte\n\n\tif err = binary.Read(r, binary.BigEndian, &msg.PrefetchSize); err != nil {\n\t\treturn\n\t}\n\n\tif err = binary.Read(r, binary.BigEndian, &msg.PrefetchCount); err != nil {\n\t\treturn\n\t}\n\n\tif err = binary.Read(r, binary.BigEndian, &bits); err != nil {\n\t\treturn\n\t}\n\tmsg.Global = (bits&(1<<0) > 0)\n\n\treturn\n}\n\ntype basicQosOk struct {\n}\n\nfunc (msg *basicQosOk) id() (uint16, uint16) {\n\treturn 60, 11\n}\n\nfunc (msg *basicQosOk) wait() bool {\n\treturn true\n}\n\nfunc (msg *basicQosOk) write(w io.Writer) (err error) {\n\n\treturn\n}\n\nfunc (msg *basicQosOk) read(r io.Reader) (err error) {\n\n\treturn\n}\n\ntype basicConsume struct {\n\treserved1   uint16\n\tQueue       string\n\tConsumerTag string\n\tNoLocal     bool\n\tNoAck       bool\n\tExclusive   bool\n\tNoWait      bool\n\tArguments   Table\n}\n\nfunc (msg *basicConsume) id() (uint16, uint16) {\n\treturn 60, 20\n}\n\nfunc (msg *basicConsume) wait() bool {\n\treturn true && !msg.NoWait\n}\n\nfunc (msg *basicConsume) write(w io.Writer) (err error) {\n\tvar bits byte\n\n\tif err = binary.Write(w, binary.BigEndian, msg.reserved1); err != nil {\n\t\treturn\n\t}\n\n\tif err = writeShortstr(w, msg.Queue); err != nil {\n\t\treturn\n\t}\n\tif err = writeShortstr(w, msg.ConsumerTag); err != nil {\n\t\treturn\n\t}\n\n\tif msg.NoLocal {\n\t\tbits |= 1 << 0\n\t}\n\n\tif msg.NoAck {\n\t\tbits |= 1 << 1\n\t}\n\n\tif msg.Exclusive {\n\t\tbits |= 1 << 2\n\t}\n\n\tif msg.NoWait {\n\t\tbits |= 1 << 3\n\t}\n\n\tif err = binary.Write(w, binary.BigEndian, bits); err != nil {\n\t\treturn\n\t}\n\n\tif err = writeTable(w, msg.Arguments); err != nil {\n\t\treturn\n\t}\n\n\treturn\n}\n\nfunc (msg *basicConsume) read(r io.Reader) (err error) {\n\tvar bits byte\n\n\tif err = binary.Read(r, binary.BigEndian, &msg.reserved1); err != nil {\n\t\treturn\n\t}\n\n\tif msg.Queue, err = readShortstr(r); err != nil {\n\t\treturn\n\t}\n\tif msg.ConsumerTag, err = readShortstr(r); err != nil {\n\t\treturn\n\t}\n\n\tif err = binary.Read(r, binary.BigEndian, &bits); err != nil {\n\t\treturn\n\t}\n\tmsg.NoLocal = (bits&(1<<0) > 0)\n\tmsg.NoAck = (bits&(1<<1) > 0)\n\tmsg.Exclusive = (bits&(1<<2) > 0)\n\tmsg.NoWait = (bits&(1<<3) > 0)\n\n\tif msg.Arguments, err = readTable(r); err != nil {\n\t\treturn\n\t}\n\n\treturn\n}\n\ntype basicConsumeOk struct {\n\tConsumerTag string\n}\n\nfunc (msg *basicConsumeOk) id() (uint16, uint16) {\n\treturn 60, 21\n}\n\nfunc (msg *basicConsumeOk) wait() bool {\n\treturn true\n}\n\nfunc (msg *basicConsumeOk) write(w io.Writer) (err error) {\n\n\tif err = writeShortstr(w, msg.ConsumerTag); err != nil {\n\t\treturn\n\t}\n\n\treturn\n}\n\nfunc (msg *basicConsumeOk) read(r io.Reader) (err error) {\n\n\tif msg.ConsumerTag, err = readShortstr(r); err != nil {\n\t\treturn\n\t}\n\n\treturn\n}\n\ntype basicCancel struct {\n\tConsumerTag string\n\tNoWait      bool\n}\n\nfunc (msg *basicCancel) id() (uint16, uint16) {\n\treturn 60, 30\n}\n\nfunc (msg *basicCancel) wait() bool {\n\treturn true && !msg.NoWait\n}\n\nfunc (msg *basicCancel) write(w io.Writer) (err error) {\n\tvar bits byte\n\n\tif err = writeShortstr(w, msg.ConsumerTag); err != nil {\n\t\treturn\n\t}\n\n\tif msg.NoWait {\n\t\tbits |= 1 << 0\n\t}\n\n\tif err = binary.Write(w, binary.BigEndian, bits); err != nil {\n\t\treturn\n\t}\n\n\treturn\n}\n\nfunc (msg *basicCancel) read(r io.Reader) (err error) {\n\tvar bits byte\n\n\tif msg.ConsumerTag, err = readShortstr(r); err != nil {\n\t\treturn\n\t}\n\n\tif err = binary.Read(r, binary.BigEndian, &bits); err != nil {\n\t\treturn\n\t}\n\tmsg.NoWait = (bits&(1<<0) > 0)\n\n\treturn\n}\n\ntype basicCancelOk struct {\n\tConsumerTag string\n}\n\nfunc (msg *basicCancelOk) id() (uint16, uint16) {\n\treturn 60, 31\n}\n\nfunc (msg *basicCancelOk) wait() bool {\n\treturn true\n}\n\nfunc (msg *basicCancelOk) write(w io.Writer) (err error) {\n\n\tif err = writeShortstr(w, msg.ConsumerTag); err != nil {\n\t\treturn\n\t}\n\n\treturn\n}\n\nfunc (msg *basicCancelOk) read(r io.Reader) (err error) {\n\n\tif msg.ConsumerTag, err = readShortstr(r); err != nil {\n\t\treturn\n\t}\n\n\treturn\n}\n\ntype basicPublish struct {\n\treserved1  uint16\n\tExchange   string\n\tRoutingKey string\n\tMandatory  bool\n\tImmediate  bool\n\tProperties properties\n\tBody       []byte\n}\n\nfunc (msg *basicPublish) id() (uint16, uint16) {\n\treturn 60, 40\n}\n\nfunc (msg *basicPublish) wait() bool {\n\treturn false\n}\n\nfunc (msg *basicPublish) getContent() (properties, []byte) {\n\treturn msg.Properties, msg.Body\n}\n\nfunc (msg *basicPublish) setContent(props properties, body []byte) {\n\tmsg.Properties, msg.Body = props, body\n}\n\nfunc (msg *basicPublish) write(w io.Writer) (err error) {\n\tvar bits byte\n\n\tif err = binary.Write(w, binary.BigEndian, msg.reserved1); err != nil {\n\t\treturn\n\t}\n\n\tif err = writeShortstr(w, msg.Exchange); err != nil {\n\t\treturn\n\t}\n\tif err = writeShortstr(w, msg.RoutingKey); err != nil {\n\t\treturn\n\t}\n\n\tif msg.Mandatory {\n\t\tbits |= 1 << 0\n\t}\n\n\tif msg.Immediate {\n\t\tbits |= 1 << 1\n\t}\n\n\tif err = binary.Write(w, binary.BigEndian, bits); err != nil {\n\t\treturn\n\t}\n\n\treturn\n}\n\nfunc (msg *basicPublish) read(r io.Reader) (err error) {\n\tvar bits byte\n\n\tif err = binary.Read(r, binary.BigEndian, &msg.reserved1); err != nil {\n\t\treturn\n\t}\n\n\tif msg.Exchange, err = readShortstr(r); err != nil {\n\t\treturn\n\t}\n\tif msg.RoutingKey, err = readShortstr(r); err != nil {\n\t\treturn\n\t}\n\n\tif err = binary.Read(r, binary.BigEndian, &bits); err != nil {\n\t\treturn\n\t}\n\tmsg.Mandatory = (bits&(1<<0) > 0)\n\tmsg.Immediate = (bits&(1<<1) > 0)\n\n\treturn\n}\n\ntype basicReturn struct {\n\tReplyCode  uint16\n\tReplyText  string\n\tExchange   string\n\tRoutingKey string\n\tProperties properties\n\tBody       []byte\n}\n\nfunc (msg *basicReturn) id() (uint16, uint16) {\n\treturn 60, 50\n}\n\nfunc (msg *basicReturn) wait() bool {\n\treturn false\n}\n\nfunc (msg *basicReturn) getContent() (properties, []byte) {\n\treturn msg.Properties, msg.Body\n}\n\nfunc (msg *basicReturn) setContent(props properties, body []byte) {\n\tmsg.Properties, msg.Body = props, body\n}\n\nfunc (msg *basicReturn) write(w io.Writer) (err error) {\n\n\tif err = binary.Write(w, binary.BigEndian, msg.ReplyCode); err != nil {\n\t\treturn\n\t}\n\n\tif err = writeShortstr(w, msg.ReplyText); err != nil {\n\t\treturn\n\t}\n\tif err = writeShortstr(w, msg.Exchange); err != nil {\n\t\treturn\n\t}\n\tif err = writeShortstr(w, msg.RoutingKey); err != nil {\n\t\treturn\n\t}\n\n\treturn\n}\n\nfunc (msg *basicReturn) read(r io.Reader) (err error) {\n\n\tif err = binary.Read(r, binary.BigEndian, &msg.ReplyCode); err != nil {\n\t\treturn\n\t}\n\n\tif msg.ReplyText, err = readShortstr(r); err != nil {\n\t\treturn\n\t}\n\tif msg.Exchange, err = readShortstr(r); err != nil {\n\t\treturn\n\t}\n\tif msg.RoutingKey, err = readShortstr(r); err != nil {\n\t\treturn\n\t}\n\n\treturn\n}\n\ntype basicDeliver struct {\n\tConsumerTag string\n\tDeliveryTag uint64\n\tRedelivered bool\n\tExchange    string\n\tRoutingKey  string\n\tProperties  properties\n\tBody        []byte\n}\n\nfunc (msg *basicDeliver) id() (uint16, uint16) {\n\treturn 60, 60\n}\n\nfunc (msg *basicDeliver) wait() bool {\n\treturn false\n}\n\nfunc (msg *basicDeliver) getContent() (properties, []byte) {\n\treturn msg.Properties, msg.Body\n}\n\nfunc (msg *basicDeliver) setContent(props properties, body []byte) {\n\tmsg.Properties, msg.Body = props, body\n}\n\nfunc (msg *basicDeliver) write(w io.Writer) (err error) {\n\tvar bits byte\n\n\tif err = writeShortstr(w, msg.ConsumerTag); err != nil {\n\t\treturn\n\t}\n\n\tif err = binary.Write(w, binary.BigEndian, msg.DeliveryTag); err != nil {\n\t\treturn\n\t}\n\n\tif msg.Redelivered {\n\t\tbits |= 1 << 0\n\t}\n\n\tif err = binary.Write(w, binary.BigEndian, bits); err != nil {\n\t\treturn\n\t}\n\n\tif err = writeShortstr(w, msg.Exchange); err != nil {\n\t\treturn\n\t}\n\tif err = writeShortstr(w, msg.RoutingKey); err != nil {\n\t\treturn\n\t}\n\n\treturn\n}\n\nfunc (msg *basicDeliver) read(r io.Reader) (err error) {\n\tvar bits byte\n\n\tif msg.ConsumerTag, err = readShortstr(r); err != nil {\n\t\treturn\n\t}\n\n\tif err = binary.Read(r, binary.BigEndian, &msg.DeliveryTag); err != nil {\n\t\treturn\n\t}\n\n\tif err = binary.Read(r, binary.BigEndian, &bits); err != nil {\n\t\treturn\n\t}\n\tmsg.Redelivered = (bits&(1<<0) > 0)\n\n\tif msg.Exchange, err = readShortstr(r); err != nil {\n\t\treturn\n\t}\n\tif msg.RoutingKey, err = readShortstr(r); err != nil {\n\t\treturn\n\t}\n\n\treturn\n}\n\ntype basicGet struct {\n\treserved1 uint16\n\tQueue     string\n\tNoAck     bool\n}\n\nfunc (msg *basicGet) id() (uint16, uint16) {\n\treturn 60, 70\n}\n\nfunc (msg *basicGet) wait() bool {\n\treturn true\n}\n\nfunc (msg *basicGet) write(w io.Writer) (err error) {\n\tvar bits byte\n\n\tif err = binary.Write(w, binary.BigEndian, msg.reserved1); err != nil {\n\t\treturn\n\t}\n\n\tif err = writeShortstr(w, msg.Queue); err != nil {\n\t\treturn\n\t}\n\n\tif msg.NoAck {\n\t\tbits |= 1 << 0\n\t}\n\n\tif err = binary.Write(w, binary.BigEndian, bits); err != nil {\n\t\treturn\n\t}\n\n\treturn\n}\n\nfunc (msg *basicGet) read(r io.Reader) (err error) {\n\tvar bits byte\n\n\tif err = binary.Read(r, binary.BigEndian, &msg.reserved1); err != nil {\n\t\treturn\n\t}\n\n\tif msg.Queue, err = readShortstr(r); err != nil {\n\t\treturn\n\t}\n\n\tif err = binary.Read(r, binary.BigEndian, &bits); err != nil {\n\t\treturn\n\t}\n\tmsg.NoAck = (bits&(1<<0) > 0)\n\n\treturn\n}\n\ntype basicGetOk struct {\n\tDeliveryTag  uint64\n\tRedelivered  bool\n\tExchange     string\n\tRoutingKey   string\n\tMessageCount uint32\n\tProperties   properties\n\tBody         []byte\n}\n\nfunc (msg *basicGetOk) id() (uint16, uint16) {\n\treturn 60, 71\n}\n\nfunc (msg *basicGetOk) wait() bool {\n\treturn true\n}\n\nfunc (msg *basicGetOk) getContent() (properties, []byte) {\n\treturn msg.Properties, msg.Body\n}\n\nfunc (msg *basicGetOk) setContent(props properties, body []byte) {\n\tmsg.Properties, msg.Body = props, body\n}\n\nfunc (msg *basicGetOk) write(w io.Writer) (err error) {\n\tvar bits byte\n\n\tif err = binary.Write(w, binary.BigEndian, msg.DeliveryTag); err != nil {\n\t\treturn\n\t}\n\n\tif msg.Redelivered {\n\t\tbits |= 1 << 0\n\t}\n\n\tif err = binary.Write(w, binary.BigEndian, bits); err != nil {\n\t\treturn\n\t}\n\n\tif err = writeShortstr(w, msg.Exchange); err != nil {\n\t\treturn\n\t}\n\tif err = writeShortstr(w, msg.RoutingKey); err != nil {\n\t\treturn\n\t}\n\n\tif err = binary.Write(w, binary.BigEndian, msg.MessageCount); err != nil {\n\t\treturn\n\t}\n\n\treturn\n}\n\nfunc (msg *basicGetOk) read(r io.Reader) (err error) {\n\tvar bits byte\n\n\tif err = binary.Read(r, binary.BigEndian, &msg.DeliveryTag); err != nil {\n\t\treturn\n\t}\n\n\tif err = binary.Read(r, binary.BigEndian, &bits); err != nil {\n\t\treturn\n\t}\n\tmsg.Redelivered = (bits&(1<<0) > 0)\n\n\tif msg.Exchange, err = readShortstr(r); err != nil {\n\t\treturn\n\t}\n\tif msg.RoutingKey, err = readShortstr(r); err != nil {\n\t\treturn\n\t}\n\n\tif err = binary.Read(r, binary.BigEndian, &msg.MessageCount); err != nil {\n\t\treturn\n\t}\n\n\treturn\n}\n\ntype basicGetEmpty struct {\n\treserved1 string\n}\n\nfunc (msg *basicGetEmpty) id() (uint16, uint16) {\n\treturn 60, 72\n}\n\nfunc (msg *basicGetEmpty) wait() bool {\n\treturn true\n}\n\nfunc (msg *basicGetEmpty) write(w io.Writer) (err error) {\n\n\tif err = writeShortstr(w, msg.reserved1); err != nil {\n\t\treturn\n\t}\n\n\treturn\n}\n\nfunc (msg *basicGetEmpty) read(r io.Reader) (err error) {\n\n\tif msg.reserved1, err = readShortstr(r); err != nil {\n\t\treturn\n\t}\n\n\treturn\n}\n\ntype basicAck struct {\n\tDeliveryTag uint64\n\tMultiple    bool\n}\n\nfunc (msg *basicAck) id() (uint16, uint16) {\n\treturn 60, 80\n}\n\nfunc (msg *basicAck) wait() bool {\n\treturn false\n}\n\nfunc (msg *basicAck) write(w io.Writer) (err error) {\n\tvar bits byte\n\n\tif err = binary.Write(w, binary.BigEndian, msg.DeliveryTag); err != nil {\n\t\treturn\n\t}\n\n\tif msg.Multiple {\n\t\tbits |= 1 << 0\n\t}\n\n\tif err = binary.Write(w, binary.BigEndian, bits); err != nil {\n\t\treturn\n\t}\n\n\treturn\n}\n\nfunc (msg *basicAck) read(r io.Reader) (err error) {\n\tvar bits byte\n\n\tif err = binary.Read(r, binary.BigEndian, &msg.DeliveryTag); err != nil {\n\t\treturn\n\t}\n\n\tif err = binary.Read(r, binary.BigEndian, &bits); err != nil {\n\t\treturn\n\t}\n\tmsg.Multiple = (bits&(1<<0) > 0)\n\n\treturn\n}\n\ntype basicReject struct {\n\tDeliveryTag uint64\n\tRequeue     bool\n}\n\nfunc (msg *basicReject) id() (uint16, uint16) {\n\treturn 60, 90\n}\n\nfunc (msg *basicReject) wait() bool {\n\treturn false\n}\n\nfunc (msg *basicReject) write(w io.Writer) (err error) {\n\tvar bits byte\n\n\tif err = binary.Write(w, binary.BigEndian, msg.DeliveryTag); err != nil {\n\t\treturn\n\t}\n\n\tif msg.Requeue {\n\t\tbits |= 1 << 0\n\t}\n\n\tif err = binary.Write(w, binary.BigEndian, bits); err != nil {\n\t\treturn\n\t}\n\n\treturn\n}\n\nfunc (msg *basicReject) read(r io.Reader) (err error) {\n\tvar bits byte\n\n\tif err = binary.Read(r, binary.BigEndian, &msg.DeliveryTag); err != nil {\n\t\treturn\n\t}\n\n\tif err = binary.Read(r, binary.BigEndian, &bits); err != nil {\n\t\treturn\n\t}\n\tmsg.Requeue = (bits&(1<<0) > 0)\n\n\treturn\n}\n\ntype basicRecoverAsync struct {\n\tRequeue bool\n}\n\nfunc (msg *basicRecoverAsync) id() (uint16, uint16) {\n\treturn 60, 100\n}\n\nfunc (msg *basicRecoverAsync) wait() bool {\n\treturn false\n}\n\nfunc (msg *basicRecoverAsync) write(w io.Writer) (err error) {\n\tvar bits byte\n\n\tif msg.Requeue {\n\t\tbits |= 1 << 0\n\t}\n\n\tif err = binary.Write(w, binary.BigEndian, bits); err != nil {\n\t\treturn\n\t}\n\n\treturn\n}\n\nfunc (msg *basicRecoverAsync) read(r io.Reader) (err error) {\n\tvar bits byte\n\n\tif err = binary.Read(r, binary.BigEndian, &bits); err != nil {\n\t\treturn\n\t}\n\tmsg.Requeue = (bits&(1<<0) > 0)\n\n\treturn\n}\n\ntype basicRecover struct {\n\tRequeue bool\n}\n\nfunc (msg *basicRecover) id() (uint16, uint16) {\n\treturn 60, 110\n}\n\nfunc (msg *basicRecover) wait() bool {\n\treturn true\n}\n\nfunc (msg *basicRecover) write(w io.Writer) (err error) {\n\tvar bits byte\n\n\tif msg.Requeue {\n\t\tbits |= 1 << 0\n\t}\n\n\tif err = binary.Write(w, binary.BigEndian, bits); err != nil {\n\t\treturn\n\t}\n\n\treturn\n}\n\nfunc (msg *basicRecover) read(r io.Reader) (err error) {\n\tvar bits byte\n\n\tif err = binary.Read(r, binary.BigEndian, &bits); err != nil {\n\t\treturn\n\t}\n\tmsg.Requeue = (bits&(1<<0) > 0)\n\n\treturn\n}\n\ntype basicRecoverOk struct {\n}\n\nfunc (msg *basicRecoverOk) id() (uint16, uint16) {\n\treturn 60, 111\n}\n\nfunc (msg *basicRecoverOk) wait() bool {\n\treturn true\n}\n\nfunc (msg *basicRecoverOk) write(w io.Writer) (err error) {\n\n\treturn\n}\n\nfunc (msg *basicRecoverOk) read(r io.Reader) (err error) {\n\n\treturn\n}\n\ntype basicNack struct {\n\tDeliveryTag uint64\n\tMultiple    bool\n\tRequeue     bool\n}\n\nfunc (msg *basicNack) id() (uint16, uint16) {\n\treturn 60, 120\n}\n\nfunc (msg *basicNack) wait() bool {\n\treturn false\n}\n\nfunc (msg *basicNack) write(w io.Writer) (err error) {\n\tvar bits byte\n\n\tif err = binary.Write(w, binary.BigEndian, msg.DeliveryTag); err != nil {\n\t\treturn\n\t}\n\n\tif msg.Multiple {\n\t\tbits |= 1 << 0\n\t}\n\n\tif msg.Requeue {\n\t\tbits |= 1 << 1\n\t}\n\n\tif err = binary.Write(w, binary.BigEndian, bits); err != nil {\n\t\treturn\n\t}\n\n\treturn\n}\n\nfunc (msg *basicNack) read(r io.Reader) (err error) {\n\tvar bits byte\n\n\tif err = binary.Read(r, binary.BigEndian, &msg.DeliveryTag); err != nil {\n\t\treturn\n\t}\n\n\tif err = binary.Read(r, binary.BigEndian, &bits); err != nil {\n\t\treturn\n\t}\n\tmsg.Multiple = (bits&(1<<0) > 0)\n\tmsg.Requeue = (bits&(1<<1) > 0)\n\n\treturn\n}\n\ntype txSelect struct {\n}\n\nfunc (msg *txSelect) id() (uint16, uint16) {\n\treturn 90, 10\n}\n\nfunc (msg *txSelect) wait() bool {\n\treturn true\n}\n\nfunc (msg *txSelect) write(w io.Writer) (err error) {\n\n\treturn\n}\n\nfunc (msg *txSelect) read(r io.Reader) (err error) {\n\n\treturn\n}\n\ntype txSelectOk struct {\n}\n\nfunc (msg *txSelectOk) id() (uint16, uint16) {\n\treturn 90, 11\n}\n\nfunc (msg *txSelectOk) wait() bool {\n\treturn true\n}\n\nfunc (msg *txSelectOk) write(w io.Writer) (err error) {\n\n\treturn\n}\n\nfunc (msg *txSelectOk) read(r io.Reader) (err error) {\n\n\treturn\n}\n\ntype txCommit struct {\n}\n\nfunc (msg *txCommit) id() (uint16, uint16) {\n\treturn 90, 20\n}\n\nfunc (msg *txCommit) wait() bool {\n\treturn true\n}\n\nfunc (msg *txCommit) write(w io.Writer) (err error) {\n\n\treturn\n}\n\nfunc (msg *txCommit) read(r io.Reader) (err error) {\n\n\treturn\n}\n\ntype txCommitOk struct {\n}\n\nfunc (msg *txCommitOk) id() (uint16, uint16) {\n\treturn 90, 21\n}\n\nfunc (msg *txCommitOk) wait() bool {\n\treturn true\n}\n\nfunc (msg *txCommitOk) write(w io.Writer) (err error) {\n\n\treturn\n}\n\nfunc (msg *txCommitOk) read(r io.Reader) (err error) {\n\n\treturn\n}\n\ntype txRollback struct {\n}\n\nfunc (msg *txRollback) id() (uint16, uint16) {\n\treturn 90, 30\n}\n\nfunc (msg *txRollback) wait() bool {\n\treturn true\n}\n\nfunc (msg *txRollback) write(w io.Writer) (err error) {\n\n\treturn\n}\n\nfunc (msg *txRollback) read(r io.Reader) (err error) {\n\n\treturn\n}\n\ntype txRollbackOk struct {\n}\n\nfunc (msg *txRollbackOk) id() (uint16, uint16) {\n\treturn 90, 31\n}\n\nfunc (msg *txRollbackOk) wait() bool {\n\treturn true\n}\n\nfunc (msg *txRollbackOk) write(w io.Writer) (err error) {\n\n\treturn\n}\n\nfunc (msg *txRollbackOk) read(r io.Reader) (err error) {\n\n\treturn\n}\n\ntype confirmSelect struct {\n\tNowait bool\n}\n\nfunc (msg *confirmSelect) id() (uint16, uint16) {\n\treturn 85, 10\n}\n\nfunc (msg *confirmSelect) wait() bool {\n\treturn true\n}\n\nfunc (msg *confirmSelect) write(w io.Writer) (err error) {\n\tvar bits byte\n\n\tif msg.Nowait {\n\t\tbits |= 1 << 0\n\t}\n\n\tif err = binary.Write(w, binary.BigEndian, bits); err != nil {\n\t\treturn\n\t}\n\n\treturn\n}\n\nfunc (msg *confirmSelect) read(r io.Reader) (err error) {\n\tvar bits byte\n\n\tif err = binary.Read(r, binary.BigEndian, &bits); err != nil {\n\t\treturn\n\t}\n\tmsg.Nowait = (bits&(1<<0) > 0)\n\n\treturn\n}\n\ntype confirmSelectOk struct {\n}\n\nfunc (msg *confirmSelectOk) id() (uint16, uint16) {\n\treturn 85, 11\n}\n\nfunc (msg *confirmSelectOk) wait() bool {\n\treturn true\n}\n\nfunc (msg *confirmSelectOk) write(w io.Writer) (err error) {\n\n\treturn\n}\n\nfunc (msg *confirmSelectOk) read(r io.Reader) (err error) {\n\n\treturn\n}\n\nfunc (r *reader) parseMethodFrame(channel uint16, size uint32) (f frame, err error) {\n\tmf := &methodFrame{\n\t\tChannelId: channel,\n\t}\n\n\tif err = binary.Read(r.r, binary.BigEndian, &mf.ClassId); err != nil {\n\t\treturn\n\t}\n\n\tif err = binary.Read(r.r, binary.BigEndian, &mf.MethodId); err != nil {\n\t\treturn\n\t}\n\n\tswitch mf.ClassId {\n\n\tcase 10: // connection\n\t\tswitch mf.MethodId {\n\n\t\tcase 10: // connection start\n\t\t\t//fmt.Println(\"NextMethod: class:10 method:10\")\n\t\t\tmethod := &connectionStart{}\n\t\t\tif err = method.read(r.r); err != nil {\n\t\t\t\treturn\n\t\t\t}\n\t\t\tmf.Method = method\n\n\t\tcase 11: // connection start-ok\n\t\t\t//fmt.Println(\"NextMethod: class:10 method:11\")\n\t\t\tmethod := &connectionStartOk{}\n\t\t\tif err = method.read(r.r); err != nil {\n\t\t\t\treturn\n\t\t\t}\n\t\t\tmf.Method = method\n\n\t\tcase 20: // connection secure\n\t\t\t//fmt.Println(\"NextMethod: class:10 method:20\")\n\t\t\tmethod := &connectionSecure{}\n\t\t\tif err = method.read(r.r); err != nil {\n\t\t\t\treturn\n\t\t\t}\n\t\t\tmf.Method = method\n\n\t\tcase 21: // connection secure-ok\n\t\t\t//fmt.Println(\"NextMethod: class:10 method:21\")\n\t\t\tmethod := &connectionSecureOk{}\n\t\t\tif err = method.read(r.r); err != nil {\n\t\t\t\treturn\n\t\t\t}\n\t\t\tmf.Method = method\n\n\t\tcase 30: // connection tune\n\t\t\t//fmt.Println(\"NextMethod: class:10 method:30\")\n\t\t\tmethod := &connectionTune{}\n\t\t\tif err = method.read(r.r); err != nil {\n\t\t\t\treturn\n\t\t\t}\n\t\t\tmf.Method = method\n\n\t\tcase 31: // connection tune-ok\n\t\t\t//fmt.Println(\"NextMethod: class:10 method:31\")\n\t\t\tmethod := &connectionTuneOk{}\n\t\t\tif err = method.read(r.r); err != nil {\n\t\t\t\treturn\n\t\t\t}\n\t\t\tmf.Method = method\n\n\t\tcase 40: // connection open\n\t\t\t//fmt.Println(\"NextMethod: class:10 method:40\")\n\t\t\tmethod := &connectionOpen{}\n\t\t\tif err = method.read(r.r); err != nil {\n\t\t\t\treturn\n\t\t\t}\n\t\t\tmf.Method = method\n\n\t\tcase 41: // connection open-ok\n\t\t\t//fmt.Println(\"NextMethod: class:10 method:41\")\n\t\t\tmethod := &connectionOpenOk{}\n\t\t\tif err = method.read(r.r); err != nil {\n\t\t\t\treturn\n\t\t\t}\n\t\t\tmf.Method = method\n\n\t\tcase 50: // connection close\n\t\t\t//fmt.Println(\"NextMethod: class:10 method:50\")\n\t\t\tmethod := &connectionClose{}\n\t\t\tif err = method.read(r.r); err != nil {\n\t\t\t\treturn\n\t\t\t}\n\t\t\tmf.Method = method\n\n\t\tcase 51: // connection close-ok\n\t\t\t//fmt.Println(\"NextMethod: class:10 method:51\")\n\t\t\tmethod := &connectionCloseOk{}\n\t\t\tif err = method.read(r.r); err != nil {\n\t\t\t\treturn\n\t\t\t}\n\t\t\tmf.Method = method\n\n\t\tcase 60: // connection blocked\n\t\t\t//fmt.Println(\"NextMethod: class:10 method:60\")\n\t\t\tmethod := &connectionBlocked{}\n\t\t\tif err = method.read(r.r); err != nil {\n\t\t\t\treturn\n\t\t\t}\n\t\t\tmf.Method = method\n\n\t\tcase 61: // connection unblocked\n\t\t\t//fmt.Println(\"NextMethod: class:10 method:61\")\n\t\t\tmethod := &connectionUnblocked{}\n\t\t\tif err = method.read(r.r); err != nil {\n\t\t\t\treturn\n\t\t\t}\n\t\t\tmf.Method = method\n\n\t\tdefault:\n\t\t\treturn nil, fmt.Errorf(\"Bad method frame, unknown method %d for class %d\", mf.MethodId, mf.ClassId)\n\t\t}\n\n\tcase 20: // channel\n\t\tswitch mf.MethodId {\n\n\t\tcase 10: // channel open\n\t\t\t//fmt.Println(\"NextMethod: class:20 method:10\")\n\t\t\tmethod := &channelOpen{}\n\t\t\tif err = method.read(r.r); err != nil {\n\t\t\t\treturn\n\t\t\t}\n\t\t\tmf.Method = method\n\n\t\tcase 11: // channel open-ok\n\t\t\t//fmt.Println(\"NextMethod: class:20 method:11\")\n\t\t\tmethod := &channelOpenOk{}\n\t\t\tif err = method.read(r.r); err != nil {\n\t\t\t\treturn\n\t\t\t}\n\t\t\tmf.Method = method\n\n\t\tcase 20: // channel flow\n\t\t\t//fmt.Println(\"NextMethod: class:20 method:20\")\n\t\t\tmethod := &channelFlow{}\n\t\t\tif err = method.read(r.r); err != nil {\n\t\t\t\treturn\n\t\t\t}\n\t\t\tmf.Method = method\n\n\t\tcase 21: // channel flow-ok\n\t\t\t//fmt.Println(\"NextMethod: class:20 method:21\")\n\t\t\tmethod := &channelFlowOk{}\n\t\t\tif err = method.read(r.r); err != nil {\n\t\t\t\treturn\n\t\t\t}\n\t\t\tmf.Method = method\n\n\t\tcase 40: // channel close\n\t\t\t//fmt.Println(\"NextMethod: class:20 method:40\")\n\t\t\tmethod := &channelClose{}\n\t\t\tif err = method.read(r.r); err != nil {\n\t\t\t\treturn\n\t\t\t}\n\t\t\tmf.Method = method\n\n\t\tcase 41: // channel close-ok\n\t\t\t//fmt.Println(\"NextMethod: class:20 method:41\")\n\t\t\tmethod := &channelCloseOk{}\n\t\t\tif err = method.read(r.r); err != nil {\n\t\t\t\treturn\n\t\t\t}\n\t\t\tmf.Method = method\n\n\t\tdefault:\n\t\t\treturn nil, fmt.Errorf(\"Bad method frame, unknown method %d for class %d\", mf.MethodId, mf.ClassId)\n\t\t}\n\n\tcase 40: // exchange\n\t\tswitch mf.MethodId {\n\n\t\tcase 10: // exchange declare\n\t\t\t//fmt.Println(\"NextMethod: class:40 method:10\")\n\t\t\tmethod := &exchangeDeclare{}\n\t\t\tif err = method.read(r.r); err != nil {\n\t\t\t\treturn\n\t\t\t}\n\t\t\tmf.Method = method\n\n\t\tcase 11: // exchange declare-ok\n\t\t\t//fmt.Println(\"NextMethod: class:40 method:11\")\n\t\t\tmethod := &exchangeDeclareOk{}\n\t\t\tif err = method.read(r.r); err != nil {\n\t\t\t\treturn\n\t\t\t}\n\t\t\tmf.Method = method\n\n\t\tcase 20: // exchange delete\n\t\t\t//fmt.Println(\"NextMethod: class:40 method:20\")\n\t\t\tmethod := &exchangeDelete{}\n\t\t\tif err = method.read(r.r); err != nil {\n\t\t\t\treturn\n\t\t\t}\n\t\t\tmf.Method = method\n\n\t\tcase 21: // exchange delete-ok\n\t\t\t//fmt.Println(\"NextMethod: class:40 method:21\")\n\t\t\tmethod := &exchangeDeleteOk{}\n\t\t\tif err = method.read(r.r); err != nil {\n\t\t\t\treturn\n\t\t\t}\n\t\t\tmf.Method = method\n\n\t\tcase 30: // exchange bind\n\t\t\t//fmt.Println(\"NextMethod: class:40 method:30\")\n\t\t\tmethod := &exchangeBind{}\n\t\t\tif err = method.read(r.r); err != nil {\n\t\t\t\treturn\n\t\t\t}\n\t\t\tmf.Method = method\n\n\t\tcase 31: // exchange bind-ok\n\t\t\t//fmt.Println(\"NextMethod: class:40 method:31\")\n\t\t\tmethod := &exchangeBindOk{}\n\t\t\tif err = method.read(r.r); err != nil {\n\t\t\t\treturn\n\t\t\t}\n\t\t\tmf.Method = method\n\n\t\tcase 40: // exchange unbind\n\t\t\t//fmt.Println(\"NextMethod: class:40 method:40\")\n\t\t\tmethod := &exchangeUnbind{}\n\t\t\tif err = method.read(r.r); err != nil {\n\t\t\t\treturn\n\t\t\t}\n\t\t\tmf.Method = method\n\n\t\tcase 51: // exchange unbind-ok\n\t\t\t//fmt.Println(\"NextMethod: class:40 method:51\")\n\t\t\tmethod := &exchangeUnbindOk{}\n\t\t\tif err = method.read(r.r); err != nil {\n\t\t\t\treturn\n\t\t\t}\n\t\t\tmf.Method = method\n\n\t\tdefault:\n\t\t\treturn nil, fmt.Errorf(\"Bad method frame, unknown method %d for class %d\", mf.MethodId, mf.ClassId)\n\t\t}\n\n\tcase 50: // queue\n\t\tswitch mf.MethodId {\n\n\t\tcase 10: // queue declare\n\t\t\t//fmt.Println(\"NextMethod: class:50 method:10\")\n\t\t\tmethod := &queueDeclare{}\n\t\t\tif err = method.read(r.r); err != nil {\n\t\t\t\treturn\n\t\t\t}\n\t\t\tmf.Method = method\n\n\t\tcase 11: // queue declare-ok\n\t\t\t//fmt.Println(\"NextMethod: class:50 method:11\")\n\t\t\tmethod := &queueDeclareOk{}\n\t\t\tif err = method.read(r.r); err != nil {\n\t\t\t\treturn\n\t\t\t}\n\t\t\tmf.Method = method\n\n\t\tcase 20: // queue bind\n\t\t\t//fmt.Println(\"NextMethod: class:50 method:20\")\n\t\t\tmethod := &queueBind{}\n\t\t\tif err = method.read(r.r); err != nil {\n\t\t\t\treturn\n\t\t\t}\n\t\t\tmf.Method = method\n\n\t\tcase 21: // queue bind-ok\n\t\t\t//fmt.Println(\"NextMethod: class:50 method:21\")\n\t\t\tmethod := &queueBindOk{}\n\t\t\tif err = method.read(r.r); err != nil {\n\t\t\t\treturn\n\t\t\t}\n\t\t\tmf.Method = method\n\n\t\tcase 50: // queue unbind\n\t\t\t//fmt.Println(\"NextMethod: class:50 method:50\")\n\t\t\tmethod := &queueUnbind{}\n\t\t\tif err = method.read(r.r); err != nil {\n\t\t\t\treturn\n\t\t\t}\n\t\t\tmf.Method = method\n\n\t\tcase 51: // queue unbind-ok\n\t\t\t//fmt.Println(\"NextMethod: class:50 method:51\")\n\t\t\tmethod := &queueUnbindOk{}\n\t\t\tif err = method.read(r.r); err != nil {\n\t\t\t\treturn\n\t\t\t}\n\t\t\tmf.Method = method\n\n\t\tcase 30: // queue purge\n\t\t\t//fmt.Println(\"NextMethod: class:50 method:30\")\n\t\t\tmethod := &queuePurge{}\n\t\t\tif err = method.read(r.r); err != nil {\n\t\t\t\treturn\n\t\t\t}\n\t\t\tmf.Method = method\n\n\t\tcase 31: // queue purge-ok\n\t\t\t//fmt.Println(\"NextMethod: class:50 method:31\")\n\t\t\tmethod := &queuePurgeOk{}\n\t\t\tif err = method.read(r.r); err != nil {\n\t\t\t\treturn\n\t\t\t}\n\t\t\tmf.Method = method\n\n\t\tcase 40: // queue delete\n\t\t\t//fmt.Println(\"NextMethod: class:50 method:40\")\n\t\t\tmethod := &queueDelete{}\n\t\t\tif err = method.read(r.r); err != nil {\n\t\t\t\treturn\n\t\t\t}\n\t\t\tmf.Method = method\n\n\t\tcase 41: // queue delete-ok\n\t\t\t//fmt.Println(\"NextMethod: class:50 method:41\")\n\t\t\tmethod := &queueDeleteOk{}\n\t\t\tif err = method.read(r.r); err != nil {\n\t\t\t\treturn\n\t\t\t}\n\t\t\tmf.Method = method\n\n\t\tdefault:\n\t\t\treturn nil, fmt.Errorf(\"Bad method frame, unknown method %d for class %d\", mf.MethodId, mf.ClassId)\n\t\t}\n\n\tcase 60: // basic\n\t\tswitch mf.MethodId {\n\n\t\tcase 10: // basic qos\n\t\t\t//fmt.Println(\"NextMethod: class:60 method:10\")\n\t\t\tmethod := &basicQos{}\n\t\t\tif err = method.read(r.r); err != nil {\n\t\t\t\treturn\n\t\t\t}\n\t\t\tmf.Method = method\n\n\t\tcase 11: // basic qos-ok\n\t\t\t//fmt.Println(\"NextMethod: class:60 method:11\")\n\t\t\tmethod := &basicQosOk{}\n\t\t\tif err = method.read(r.r); err != nil {\n\t\t\t\treturn\n\t\t\t}\n\t\t\tmf.Method = method\n\n\t\tcase 20: // basic consume\n\t\t\t//fmt.Println(\"NextMethod: class:60 method:20\")\n\t\t\tmethod := &basicConsume{}\n\t\t\tif err = method.read(r.r); err != nil {\n\t\t\t\treturn\n\t\t\t}\n\t\t\tmf.Method = method\n\n\t\tcase 21: // basic consume-ok\n\t\t\t//fmt.Println(\"NextMethod: class:60 method:21\")\n\t\t\tmethod := &basicConsumeOk{}\n\t\t\tif err = method.read(r.r); err != nil {\n\t\t\t\treturn\n\t\t\t}\n\t\t\tmf.Method = method\n\n\t\tcase 30: // basic cancel\n\t\t\t//fmt.Println(\"NextMethod: class:60 method:30\")\n\t\t\tmethod := &basicCancel{}\n\t\t\tif err = method.read(r.r); err != nil {\n\t\t\t\treturn\n\t\t\t}\n\t\t\tmf.Method = method\n\n\t\tcase 31: // basic cancel-ok\n\t\t\t//fmt.Println(\"NextMethod: class:60 method:31\")\n\t\t\tmethod := &basicCancelOk{}\n\t\t\tif err = method.read(r.r); err != nil {\n\t\t\t\treturn\n\t\t\t}\n\t\t\tmf.Method = method\n\n\t\tcase 40: // basic publish\n\t\t\t//fmt.Println(\"NextMethod: class:60 method:40\")\n\t\t\tmethod := &basicPublish{}\n\t\t\tif err = method.read(r.r); err != nil {\n\t\t\t\treturn\n\t\t\t}\n\t\t\tmf.Method = method\n\n\t\tcase 50: // basic return\n\t\t\t//fmt.Println(\"NextMethod: class:60 method:50\")\n\t\t\tmethod := &basicReturn{}\n\t\t\tif err = method.read(r.r); err != nil {\n\t\t\t\treturn\n\t\t\t}\n\t\t\tmf.Method = method\n\n\t\tcase 60: // basic deliver\n\t\t\t//fmt.Println(\"NextMethod: class:60 method:60\")\n\t\t\tmethod := &basicDeliver{}\n\t\t\tif err = method.read(r.r); err != nil {\n\t\t\t\treturn\n\t\t\t}\n\t\t\tmf.Method = method\n\n\t\tcase 70: // basic get\n\t\t\t//fmt.Println(\"NextMethod: class:60 method:70\")\n\t\t\tmethod := &basicGet{}\n\t\t\tif err = method.read(r.r); err != nil {\n\t\t\t\treturn\n\t\t\t}\n\t\t\tmf.Method = method\n\n\t\tcase 71: // basic get-ok\n\t\t\t//fmt.Println(\"NextMethod: class:60 method:71\")\n\t\t\tmethod := &basicGetOk{}\n\t\t\tif err = method.read(r.r); err != nil {\n\t\t\t\treturn\n\t\t\t}\n\t\t\tmf.Method = method\n\n\t\tcase 72: // basic get-empty\n\t\t\t//fmt.Println(\"NextMethod: class:60 method:72\")\n\t\t\tmethod := &basicGetEmpty{}\n\t\t\tif err = method.read(r.r); err != nil {\n\t\t\t\treturn\n\t\t\t}\n\t\t\tmf.Method = method\n\n\t\tcase 80: // basic ack\n\t\t\t//fmt.Println(\"NextMethod: class:60 method:80\")\n\t\t\tmethod := &basicAck{}\n\t\t\tif err = method.read(r.r); err != nil {\n\t\t\t\treturn\n\t\t\t}\n\t\t\tmf.Method = method\n\n\t\tcase 90: // basic reject\n\t\t\t//fmt.Println(\"NextMethod: class:60 method:90\")\n\t\t\tmethod := &basicReject{}\n\t\t\tif err = method.read(r.r); err != nil {\n\t\t\t\treturn\n\t\t\t}\n\t\t\tmf.Method = method\n\n\t\tcase 100: // basic recover-async\n\t\t\t//fmt.Println(\"NextMethod: class:60 method:100\")\n\t\t\tmethod := &basicRecoverAsync{}\n\t\t\tif err = method.read(r.r); err != nil {\n\t\t\t\treturn\n\t\t\t}\n\t\t\tmf.Method = method\n\n\t\tcase 110: // basic recover\n\t\t\t//fmt.Println(\"NextMethod: class:60 method:110\")\n\t\t\tmethod := &basicRecover{}\n\t\t\tif err = method.read(r.r); err != nil {\n\t\t\t\treturn\n\t\t\t}\n\t\t\tmf.Method = method\n\n\t\tcase 111: // basic recover-ok\n\t\t\t//fmt.Println(\"NextMethod: class:60 method:111\")\n\t\t\tmethod := &basicRecoverOk{}\n\t\t\tif err = method.read(r.r); err != nil {\n\t\t\t\treturn\n\t\t\t}\n\t\t\tmf.Method = method\n\n\t\tcase 120: // basic nack\n\t\t\t//fmt.Println(\"NextMethod: class:60 method:120\")\n\t\t\tmethod := &basicNack{}\n\t\t\tif err = method.read(r.r); err != nil {\n\t\t\t\treturn\n\t\t\t}\n\t\t\tmf.Method = method\n\n\t\tdefault:\n\t\t\treturn nil, fmt.Errorf(\"Bad method frame, unknown method %d for class %d\", mf.MethodId, mf.ClassId)\n\t\t}\n\n\tcase 90: // tx\n\t\tswitch mf.MethodId {\n\n\t\tcase 10: // tx select\n\t\t\t//fmt.Println(\"NextMethod: class:90 method:10\")\n\t\t\tmethod := &txSelect{}\n\t\t\tif err = method.read(r.r); err != nil {\n\t\t\t\treturn\n\t\t\t}\n\t\t\tmf.Method = method\n\n\t\tcase 11: // tx select-ok\n\t\t\t//fmt.Println(\"NextMethod: class:90 method:11\")\n\t\t\tmethod := &txSelectOk{}\n\t\t\tif err = method.read(r.r); err != nil {\n\t\t\t\treturn\n\t\t\t}\n\t\t\tmf.Method = method\n\n\t\tcase 20: // tx commit\n\t\t\t//fmt.Println(\"NextMethod: class:90 method:20\")\n\t\t\tmethod := &txCommit{}\n\t\t\tif err = method.read(r.r); err != nil {\n\t\t\t\treturn\n\t\t\t}\n\t\t\tmf.Method = method\n\n\t\tcase 21: // tx commit-ok\n\t\t\t//fmt.Println(\"NextMethod: class:90 method:21\")\n\t\t\tmethod := &txCommitOk{}\n\t\t\tif err = method.read(r.r); err != nil {\n\t\t\t\treturn\n\t\t\t}\n\t\t\tmf.Method = method\n\n\t\tcase 30: // tx rollback\n\t\t\t//fmt.Println(\"NextMethod: class:90 method:30\")\n\t\t\tmethod := &txRollback{}\n\t\t\tif err = method.read(r.r); err != nil {\n\t\t\t\treturn\n\t\t\t}\n\t\t\tmf.Method = method\n\n\t\tcase 31: // tx rollback-ok\n\t\t\t//fmt.Println(\"NextMethod: class:90 method:31\")\n\t\t\tmethod := &txRollbackOk{}\n\t\t\tif err = method.read(r.r); err != nil {\n\t\t\t\treturn\n\t\t\t}\n\t\t\tmf.Method = method\n\n\t\tdefault:\n\t\t\treturn nil, fmt.Errorf(\"Bad method frame, unknown method %d for class %d\", mf.MethodId, mf.ClassId)\n\t\t}\n\n\tcase 85: // confirm\n\t\tswitch mf.MethodId {\n\n\t\tcase 10: // confirm select\n\t\t\t//fmt.Println(\"NextMethod: class:85 method:10\")\n\t\t\tmethod := &confirmSelect{}\n\t\t\tif err = method.read(r.r); err != nil {\n\t\t\t\treturn\n\t\t\t}\n\t\t\tmf.Method = method\n\n\t\tcase 11: // confirm select-ok\n\t\t\t//fmt.Println(\"NextMethod: class:85 method:11\")\n\t\t\tmethod := &confirmSelectOk{}\n\t\t\tif err = method.read(r.r); err != nil {\n\t\t\t\treturn\n\t\t\t}\n\t\t\tmf.Method = method\n\n\t\tdefault:\n\t\t\treturn nil, fmt.Errorf(\"Bad method frame, unknown method %d for class %d\", mf.MethodId, mf.ClassId)\n\t\t}\n\n\tdefault:\n\t\treturn nil, fmt.Errorf(\"Bad method frame, unknown class %d\", mf.ClassId)\n\t}\n\n\treturn mf, nil\n}\n"
        },
        {
          "name": "tls_test.go",
          "type": "blob",
          "size": 8.5263671875,
          "content": "package amqp\n\nimport (\n\t\"crypto/tls\"\n\t\"crypto/x509\"\n\t\"fmt\"\n\t\"net\"\n\t\"testing\"\n\t\"time\"\n)\n\nfunc tlsServerConfig() *tls.Config {\n\tcfg := new(tls.Config)\n\n\tcfg.ClientCAs = x509.NewCertPool()\n\tcfg.ClientCAs.AppendCertsFromPEM([]byte(caCert))\n\n\tcert, err := tls.X509KeyPair([]byte(serverCert), []byte(serverKey))\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\tcfg.Certificates = append(cfg.Certificates, cert)\n\tcfg.ClientAuth = tls.RequireAndVerifyClientCert\n\n\treturn cfg\n}\n\nfunc tlsClientConfig() *tls.Config {\n\tcfg := new(tls.Config)\n\tcfg.RootCAs = x509.NewCertPool()\n\tcfg.RootCAs.AppendCertsFromPEM([]byte(caCert))\n\n\tcert, err := tls.X509KeyPair([]byte(clientCert), []byte(clientKey))\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\tcfg.Certificates = append(cfg.Certificates, cert)\n\n\treturn cfg\n}\n\ntype tlsServer struct {\n\tnet.Listener\n\tURL      string\n\tConfig   *tls.Config\n\tSessions chan *server\n}\n\n// Captures the header for each accepted connection\nfunc (s *tlsServer) Serve(t *testing.T) {\n\tfor {\n\t\tc, err := s.Accept()\n\t\tif err != nil {\n\t\t\treturn\n\t\t}\n\t\ts.Sessions <- newServer(t, c, c)\n\t}\n}\n\nfunc startTLSServer(t *testing.T, cfg *tls.Config) tlsServer {\n\tl, err := tls.Listen(\"tcp\", \"127.0.0.1:0\", cfg)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\ts := tlsServer{\n\t\tListener: l,\n\t\tConfig:   cfg,\n\t\tURL:      fmt.Sprintf(\"amqps://%s/\", l.Addr().String()),\n\t\tSessions: make(chan *server),\n\t}\n\tgo s.Serve(t)\n\n\treturn s\n}\n\n// Tests opening a connection of a TLS enabled socket server\nfunc TestTLSHandshake(t *testing.T) {\n\tsrv := startTLSServer(t, tlsServerConfig())\n\tdefer srv.Close()\n\tgo func() {\n\t\tselect {\n\t\tcase <-time.After(10 * time.Millisecond):\n\t\t\tt.Fatalf(\"server timeout waiting for TLS handshake from client\")\n\t\tcase session := <-srv.Sessions:\n\t\t\tsession.connectionOpen()\n\t\t\tsession.connectionClose()\n\t\t\tsession.S.Close()\n\t\t}\n\t}()\n\n\tc, err := DialTLS(srv.URL, tlsClientConfig())\n\tif err != nil {\n\t\tt.Fatalf(\"expected to open a TLS connection, got err: %v\", err)\n\t}\n\tdefer c.Close()\n\n\tif st := c.ConnectionState(); !st.HandshakeComplete {\n\t\tt.Errorf(\"expected to complete a TLS handshake, TLS connection state: %+v\", st)\n\t}\n}\n\nconst caCert = `\n-----BEGIN CERTIFICATE-----\nMIICxjCCAa6gAwIBAgIJANWuMWMQSxvdMA0GCSqGSIb3DQEBBQUAMBMxETAPBgNV\nBAMTCE15VGVzdENBMB4XDTE0MDEyNzE5NTIyMloXDTI0MDEyNTE5NTIyMlowEzER\nMA8GA1UEAxMITXlUZXN0Q0EwggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIB\nAQDBsIrkW4ob9Z/gzR2/Maa2stbutry6/vvz8eiJwIKIbaHGwqtFOUGiWeKw7H76\nIH3SjTAhNQY2hoKPyH41D36sDJkYBRyHFJTK/6ffvOhpyLnuXJAnoS62eKPSNUAx\n5i/lkHj42ESutYAH9qbHCI/gBm9G4WmhGAyA16xzC1n07JObl6KFoY1PqHKl823z\nmvF47I24DzemEfjdwC9nAAX/pGYOg9FA9nQv7NnhlsJMxueCx55RNU1ADRoqsbfE\nT0CQTOT4ryugGrUp9J4Cwen6YbXZrS6+Kff5SQCAns0Qu8/bwj0DKkuBGLF+Mnwe\nmq9bMzyZPUrPM3Gu48ao8YAfAgMBAAGjHTAbMAwGA1UdEwQFMAMBAf8wCwYDVR0P\nBAQDAgEGMA0GCSqGSIb3DQEBBQUAA4IBAQCBwXGblRxIEOlEP6ANZ1C8AHWyG8lR\nCQduFclc0tmyCCz5fnyLK0aGu9LhXXe6/HSKqgs4mJqeqYOojdjkfOme/YdwDzjK\nWIf0kRYQHcB6NeyEZwW8C7subTP1Xw6zbAmjvQrtCGvRM+fi3/cs1sSSkd/EoRk4\n7GM9qQl/JIIoCOGncninf2NQm5YSpbit6/mOQD7EhqXsw+bX+IRh3DHC1Apv/PoA\nHlDNeM4vjWaBxsmvRSndrIvew1czboFM18oRSSIqAkU7dKZ0SbC11grzmNxMG2aD\nf9y8FIG6RK/SEaOZuc+uBGXx7tj7dczpE/2puqYcaVGwcv4kkrC/ZuRm\n-----END CERTIFICATE-----\n`\n\nconst serverCert = `\n-----BEGIN CERTIFICATE-----\nMIIC8zCCAdugAwIBAgIBATANBgkqhkiG9w0BAQUFADATMREwDwYDVQQDEwhNeVRl\nc3RDQTAeFw0xNDAxMjcxOTUyMjNaFw0yNDAxMjUxOTUyMjNaMCUxEjAQBgNVBAMT\nCTEyNy4wLjAuMTEPMA0GA1UEChMGc2VydmVyMIIBIjANBgkqhkiG9w0BAQEFAAOC\nAQ8AMIIBCgKCAQEAxYAKbeGyg0gP0xwVsZsufzk/SUCtD44Gp3lQYQ9QumQ1IVZu\nPmZWwPWrzI93a1Abruz6ZhXaB3jcL5QPAy1N44IiFgVN45CZXBsqkpJe/abzRFOV\nDRnHxattPDHdgwML5d3nURKGUM/7+ACj5E4pZEDlM3RIjIKVd+doJsL7n6myO8FE\ntIpt4vTz1MFp3F+ntPnHU3BZ/VZ1UjSlFWnCjT0CR0tnXsPmlIaC98HThS8x5zNB\nfvvSN+Zln8RWdNLnEVHVdqYtOQ828QbCx8s1HfClGgaVoSDrzz+qQgtZFO4wW264\n2CWkNd8DSJUJ/HlPNXmbXsrRMgvGaL7YUz2yRQIDAQABo0AwPjAJBgNVHRMEAjAA\nMAsGA1UdDwQEAwIFIDATBgNVHSUEDDAKBggrBgEFBQcDATAPBgNVHREECDAGhwR/\nAAABMA0GCSqGSIb3DQEBBQUAA4IBAQAE2g+wAFf9Xg5svcnb7+mfseYV16k9l5WG\nonrmR3FLsbTxfbr4PZJMHrswPbi2NRk0+ETPUpcv1RP7pUB7wSEvuS1NPGcU92iP\n58ycP3dYtLzmuu6BkgToZqwsCU8fC2zM0wt3+ifzPpDMffWWOioVuA3zdM9WPQYz\n+Ofajd0XaZwFZS8uTI5WXgObz7Xqfmln4tF3Sq1CTyuJ44qK4p83XOKFq+L04aD0\nd0c8w3YQNUENny/vMP9mDu3FQ3SnDz2GKl1LSjGe2TUnkoMkDfdk4wSzndTz/ecb\nQiCPKijwVPWNOWV3NDE2edMxDPxDoKoEm5F4UGfGjxSRnYCIoZLh\n-----END CERTIFICATE-----\n`\n\nconst serverKey = `\n-----BEGIN RSA PRIVATE KEY-----\nMIIEowIBAAKCAQEAxYAKbeGyg0gP0xwVsZsufzk/SUCtD44Gp3lQYQ9QumQ1IVZu\nPmZWwPWrzI93a1Abruz6ZhXaB3jcL5QPAy1N44IiFgVN45CZXBsqkpJe/abzRFOV\nDRnHxattPDHdgwML5d3nURKGUM/7+ACj5E4pZEDlM3RIjIKVd+doJsL7n6myO8FE\ntIpt4vTz1MFp3F+ntPnHU3BZ/VZ1UjSlFWnCjT0CR0tnXsPmlIaC98HThS8x5zNB\nfvvSN+Zln8RWdNLnEVHVdqYtOQ828QbCx8s1HfClGgaVoSDrzz+qQgtZFO4wW264\n2CWkNd8DSJUJ/HlPNXmbXsrRMgvGaL7YUz2yRQIDAQABAoIBAGsyEvcPAGg3DbfE\nz5WFp9gPx2TIAOanbL8rnlAAEw4H47qDgfTGcSHsdeHioKuTYGMyZrpP8/YISGJe\nl0NfLJ5mfH+9Q0hXrJWMfS/u2DYOjo0wXH8u1fpZEEISwqsgVS3fonSjfFmSea1j\nE5GQRvEONBkYbWQuYFgjNqmLPS2r5lKbWCQvc1MB/vvVBwOTiO0ON7m/EkM5RKt9\ncDT5ZhhVjBpdmd9HpVbKTdBj8Q0l5/ZHZUEgZA6FDZEwYxTd9l87Z4YT+5SR0z9t\nk8/Z0CHd3x3Rv891t7m66ZJkaOda8NC65/432MQEQwJltmrKnc22dS8yI26rrmpp\ng3tcbSUCgYEA5nMXdQKS4vF+Kp10l/HqvGz2sU8qQaWYZQIg7Th3QJPo6N52po/s\nnn3UF0P5mT1laeZ5ZQJKx4gnmuPnIZ2ZtJQDyFhIbRPcZ+2hSNSuLYVcrumOC3EP\n3OZyFtFE1THO73aFe5e1jEdtoOne3Bds/Hq6NF45fkVdL+M9e8pfXIsCgYEA22W8\nzGjbWyrFOYvKknMQVtHnMx8BJEtsvWRknP6CWAv/8WyeZpE128Pve1m441AQnopS\nCuOF5wFK0iUXBFbS3Pe1/1j3em6yfVznuUHqJ7Qc+dNzxVvkTK8jGB6x+vm+M9Hg\nmuHUM726IUxckoSNXbPNAVPIZab1NdSxam7F9m8CgYEAx55QZmIJXJ41XLKxqWC7\npeZ5NpPNlbncrTpPzUzJN94ntXfmrVckbxGt401VayEctMQYyZ9XqUlOjUP3FU5Q\nM3S3Zhba/eljVX8o406fZf0MkNLs4QpZ5E6V6x/xEP+pMhKng6yhbVb+JpIPIvUD\nyhyBKRWplbB+DRo5Sv685gsCgYA7l5m9h+m1DJv/cnn2Z2yTuHXtC8namuYRV1iA\n0ByFX9UINXGc+GpBpCnDPm6ax5+MAJQiQwSW52H0TIDA+/hQbrQvhHHL/o9av8Zt\nKns4h5KrRQUYIUqUjamhnozHV9iS6LnyN87Usv8AlmY6oehoADN53dD702qdUYVT\nHH2G3wKBgCdvqyw78FR/n8cUWesTPnxx5HCeWJ1J+2BESnUnPmKZ71CV1H7uweja\nvPUxuuuGLKfNx84OKCfRDbtOgMOeyh9T1RmXry6Srz/7/udjlF0qmFiRXfBNAgoR\ntNb0+Ri/vY0AHrQ7UnCbl12qPVaqhEXLr+kCGNEPFqpMJPPEeMK0\n-----END RSA PRIVATE KEY-----\n`\n\nconst clientCert = `\n-----BEGIN CERTIFICATE-----\nMIIC4jCCAcqgAwIBAgIBAjANBgkqhkiG9w0BAQUFADATMREwDwYDVQQDEwhNeVRl\nc3RDQTAeFw0xNDAxMjcxOTUyMjNaFw0yNDAxMjUxOTUyMjNaMCUxEjAQBgNVBAMT\nCTEyNy4wLjAuMTEPMA0GA1UEChMGY2xpZW50MIIBIjANBgkqhkiG9w0BAQEFAAOC\nAQ8AMIIBCgKCAQEAu7LMqd+agoH168Bsi0WJ36ulYqDypq+GZPF7uWOo2pE0raKH\nB++31/hjnkt6yC5kLKVZZ0EfolBa9q4Cy6swfGaEMafy44ZCRneLnt1azL1N6Kfz\n+U0KsOqyQDoMxYJG1gVTEZN19/U/ew2eazcxKyERI3oGCQ4SbpkxBTbfxtAFk49e\nxIB3obsuMVUrmtXE4FkUkvG7NgpPUgrhp0yxYpj9zruZGzGGT1zNhcarbQ/4i7It\nZMbnv6pqQWtYDgnGX2TDRcEiXGeO+KrzhfpTRLfO3K4np8e8cmTyXM+4lMlWUgma\nKrRdu1QXozGqRs47u2prGKGdSQWITpqNVCY8fQIDAQABoy8wLTAJBgNVHRMEAjAA\nMAsGA1UdDwQEAwIHgDATBgNVHSUEDDAKBggrBgEFBQcDAjANBgkqhkiG9w0BAQUF\nAAOCAQEAhCuBCLznPc4O96hT3P8Fx19L3ltrWbc/pWrx8JjxUaGk8kNmjMjY+/Mt\nJBbjUBx2kJwaY0EHMAfw7D1f1wcCeNycx/0dyb0E6xzhmPw5fY15GGNg8rzWwqSY\n+i/1iqU0IRkmRHV7XCF+trd2H0Ec+V1Fd/61E2ccJfOL5aSAyWbMCUtWxS3QMnqH\nFBfKdVEiY9WNht5hnvsXQBRaNhowJ6Cwa7/1/LZjmhcXiJ0xrc1Hggj3cvS+4vll\nEw+20a0tPKjD/v/2oSQL+qkeYKV4fhCGkaBHCpPlSJrqorb7B6NmPy3nS26ETKE/\no2UCfZc5g2MU1ENa31kT1iuhKZapsA==\n-----END CERTIFICATE-----\n`\n\nconst clientKey = `\n-----BEGIN RSA PRIVATE KEY-----\nMIIEowIBAAKCAQEAu7LMqd+agoH168Bsi0WJ36ulYqDypq+GZPF7uWOo2pE0raKH\nB++31/hjnkt6yC5kLKVZZ0EfolBa9q4Cy6swfGaEMafy44ZCRneLnt1azL1N6Kfz\n+U0KsOqyQDoMxYJG1gVTEZN19/U/ew2eazcxKyERI3oGCQ4SbpkxBTbfxtAFk49e\nxIB3obsuMVUrmtXE4FkUkvG7NgpPUgrhp0yxYpj9zruZGzGGT1zNhcarbQ/4i7It\nZMbnv6pqQWtYDgnGX2TDRcEiXGeO+KrzhfpTRLfO3K4np8e8cmTyXM+4lMlWUgma\nKrRdu1QXozGqRs47u2prGKGdSQWITpqNVCY8fQIDAQABAoIBAGSEn3hFyEAmCyYi\n2b5IEksXaC2GlgxQKb/7Vs/0oCPU6YonZPsKFMFzQx4tu+ZiecEzF8rlJGTPdbdv\nfw3FcuTcHeVd1QSmDO4h7UK5tnu40XVMJKsY6CXQun8M13QajYbmORNLjjypOULU\nC0fNueYoAj6mhX7p61MRdSAev/5+0+bVQQG/tSVDQzdngvKpaCunOphiB2VW2Aa0\n7aYPOFCoPB2uo0DwUmBB0yfx9x4hXX9ovQI0YFou7bq6iYJ0vlZBvYQ9YrVdxjKL\navcz1N5xM3WFAkZJSVT/Ho5+uTbZx4RrJ8b5T+t2spOKmXyAjwS2rL/XMAh8YRZ1\nu44duoECgYEA4jpK2qshgQ0t49rjVHEDKX5x7ElEZefl0rHZ/2X/uHUDKpKj2fTq\n3TQzHquiQ4Aof7OEB9UE3DGrtpvo/j/PYxL5Luu5VR4AIEJm+CA8GYuE96+uIL0Z\nM2r3Lux6Bp30Z47Eit2KiY4fhrWs59WB3NHHoFxgzHSVbnuA02gcX2ECgYEA1GZw\niXIVYaK07ED+q/0ObyS5hD1cMhJ7ifSN9BxuG0qUpSigbkTGj09fUDS4Fqsz9dvz\nF0P93fZvyia242TIfDUwJEsDQCgHk7SGa4Rx/p/3x/obIEERk7K76Hdg93U5NXhV\nNvczvgL0HYxnb+qtumwMgGPzncB4lGcTnRyOfp0CgYBTIsDnYwRI/KLknUf1fCKB\nWSpcfwBXwsS+jQVjygQTsUyclI8KResZp1kx6DkVPT+kzj+y8SF8GfTUgq844BJC\ngnJ4P8A3+3JoaH6WqKHtcUxICZOgDF36e1CjOdwOGnX6qIipz4hdzJDhXFpSSDAV\nCjKmR8x61k0j8NcC2buzgQKBgFr7eo9VwBTvpoJhIPY5UvqHB7S+uAR26FZi3H/J\nwdyM6PmKWpaBfXCb9l8cBhMnyP0y94FqzY9L5fz48nSbkkmqWvHg9AaCXySFOuNJ\ne68vhOszlnUNimLzOAzPPkkh/JyL7Cy8XXyyNTGHGDPXmg12BTDmH8/eR4iCUuOE\n/QD9AoGBALQ/SkvfO3D5+k9e/aTHRuMJ0+PWdLUMTZ39oJQxUx+qj7/xpjDvWTBn\neDmF/wjnIAg+020oXyBYo6plEZfDz3EYJQZ+3kLLEU+O/A7VxCakPYPwCr7N/InL\nCcg/TVSIXxw/6uJnojoAjMIEU45NoP6RMp0mWYYb2OlteEv08Ovp\n-----END RSA PRIVATE KEY-----\n`\n"
        },
        {
          "name": "types.go",
          "type": "blob",
          "size": 14.345703125,
          "content": "// Copyright (c) 2012, Sean Treadway, SoundCloud Ltd.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n// Source code and contact info at http://github.com/streadway/amqp\n\npackage amqp\n\nimport (\n\t\"fmt\"\n\t\"io\"\n\t\"time\"\n)\n\n// Constants for standard AMQP 0-9-1 exchange types.\nconst (\n\tExchangeDirect  = \"direct\"\n\tExchangeFanout  = \"fanout\"\n\tExchangeTopic   = \"topic\"\n\tExchangeHeaders = \"headers\"\n)\n\nvar (\n\t// ErrClosed is returned when the channel or connection is not open\n\tErrClosed = &Error{Code: ChannelError, Reason: \"channel/connection is not open\"}\n\n\t// ErrChannelMax is returned when Connection.Channel has been called enough\n\t// times that all channel IDs have been exhausted in the client or the\n\t// server.\n\tErrChannelMax = &Error{Code: ChannelError, Reason: \"channel id space exhausted\"}\n\n\t// ErrSASL is returned from Dial when the authentication mechanism could not\n\t// be negoated.\n\tErrSASL = &Error{Code: AccessRefused, Reason: \"SASL could not negotiate a shared mechanism\"}\n\n\t// ErrCredentials is returned when the authenticated client is not authorized\n\t// to any vhost.\n\tErrCredentials = &Error{Code: AccessRefused, Reason: \"username or password not allowed\"}\n\n\t// ErrVhost is returned when the authenticated user is not permitted to\n\t// access the requested Vhost.\n\tErrVhost = &Error{Code: AccessRefused, Reason: \"no access to this vhost\"}\n\n\t// ErrSyntax is hard protocol error, indicating an unsupported protocol,\n\t// implementation or encoding.\n\tErrSyntax = &Error{Code: SyntaxError, Reason: \"invalid field or value inside of a frame\"}\n\n\t// ErrFrame is returned when the protocol frame cannot be read from the\n\t// server, indicating an unsupported protocol or unsupported frame type.\n\tErrFrame = &Error{Code: FrameError, Reason: \"frame could not be parsed\"}\n\n\t// ErrCommandInvalid is returned when the server sends an unexpected response\n\t// to this requested message type. This indicates a bug in this client.\n\tErrCommandInvalid = &Error{Code: CommandInvalid, Reason: \"unexpected command received\"}\n\n\t// ErrUnexpectedFrame is returned when something other than a method or\n\t// heartbeat frame is delivered to the Connection, indicating a bug in the\n\t// client.\n\tErrUnexpectedFrame = &Error{Code: UnexpectedFrame, Reason: \"unexpected frame received\"}\n\n\t// ErrFieldType is returned when writing a message containing a Go type unsupported by AMQP.\n\tErrFieldType = &Error{Code: SyntaxError, Reason: \"unsupported table field type\"}\n)\n\n// Error captures the code and reason a channel or connection has been closed\n// by the server.\ntype Error struct {\n\tCode    int    // constant code from the specification\n\tReason  string // description of the error\n\tServer  bool   // true when initiated from the server, false when from this library\n\tRecover bool   // true when this error can be recovered by retrying later or with different parameters\n}\n\nfunc newError(code uint16, text string) *Error {\n\treturn &Error{\n\t\tCode:    int(code),\n\t\tReason:  text,\n\t\tRecover: isSoftExceptionCode(int(code)),\n\t\tServer:  true,\n\t}\n}\n\nfunc (e Error) Error() string {\n\treturn fmt.Sprintf(\"Exception (%d) Reason: %q\", e.Code, e.Reason)\n}\n\n// Used by header frames to capture routing and header information\ntype properties struct {\n\tContentType     string    // MIME content type\n\tContentEncoding string    // MIME content encoding\n\tHeaders         Table     // Application or header exchange table\n\tDeliveryMode    uint8     // queue implementation use - Transient (1) or Persistent (2)\n\tPriority        uint8     // queue implementation use - 0 to 9\n\tCorrelationId   string    // application use - correlation identifier\n\tReplyTo         string    // application use - address to to reply to (ex: RPC)\n\tExpiration      string    // implementation use - message expiration spec\n\tMessageId       string    // application use - message identifier\n\tTimestamp       time.Time // application use - message timestamp\n\tType            string    // application use - message type name\n\tUserId          string    // application use - creating user id\n\tAppId           string    // application use - creating application\n\treserved1       string    // was cluster-id - process for buffer consumption\n}\n\n// DeliveryMode.  Transient means higher throughput but messages will not be\n// restored on broker restart.  The delivery mode of publishings is unrelated\n// to the durability of the queues they reside on.  Transient messages will\n// not be restored to durable queues, persistent messages will be restored to\n// durable queues and lost on non-durable queues during server restart.\n//\n// This remains typed as uint8 to match Publishing.DeliveryMode.  Other\n// delivery modes specific to custom queue implementations are not enumerated\n// here.\nconst (\n\tTransient  uint8 = 1\n\tPersistent uint8 = 2\n)\n\n// The property flags are an array of bits that indicate the presence or\n// absence of each property value in sequence.  The bits are ordered from most\n// high to low - bit 15 indicates the first property.\nconst (\n\tflagContentType     = 0x8000\n\tflagContentEncoding = 0x4000\n\tflagHeaders         = 0x2000\n\tflagDeliveryMode    = 0x1000\n\tflagPriority        = 0x0800\n\tflagCorrelationId   = 0x0400\n\tflagReplyTo         = 0x0200\n\tflagExpiration      = 0x0100\n\tflagMessageId       = 0x0080\n\tflagTimestamp       = 0x0040\n\tflagType            = 0x0020\n\tflagUserId          = 0x0010\n\tflagAppId           = 0x0008\n\tflagReserved1       = 0x0004\n)\n\n// Queue captures the current server state of the queue on the server returned\n// from Channel.QueueDeclare or Channel.QueueInspect.\ntype Queue struct {\n\tName      string // server confirmed or generated name\n\tMessages  int    // count of messages not awaiting acknowledgment\n\tConsumers int    // number of consumers receiving deliveries\n}\n\n// Publishing captures the client message sent to the server.  The fields\n// outside of the Headers table included in this struct mirror the underlying\n// fields in the content frame.  They use native types for convenience and\n// efficiency.\ntype Publishing struct {\n\t// Application or exchange specific fields,\n\t// the headers exchange will inspect this field.\n\tHeaders Table\n\n\t// Properties\n\tContentType     string    // MIME content type\n\tContentEncoding string    // MIME content encoding\n\tDeliveryMode    uint8     // Transient (0 or 1) or Persistent (2)\n\tPriority        uint8     // 0 to 9\n\tCorrelationId   string    // correlation identifier\n\tReplyTo         string    // address to to reply to (ex: RPC)\n\tExpiration      string    // message expiration spec\n\tMessageId       string    // message identifier\n\tTimestamp       time.Time // message timestamp\n\tType            string    // message type name\n\tUserId          string    // creating user id - ex: \"guest\"\n\tAppId           string    // creating application id\n\n\t// The application specific payload of the message\n\tBody []byte\n}\n\n// Blocking notifies the server's TCP flow control of the Connection.  When a\n// server hits a memory or disk alarm it will block all connections until the\n// resources are reclaimed.  Use NotifyBlock on the Connection to receive these\n// events.\ntype Blocking struct {\n\tActive bool   // TCP pushback active/inactive on server\n\tReason string // Server reason for activation\n}\n\n// Confirmation notifies the acknowledgment or negative acknowledgement of a\n// publishing identified by its delivery tag.  Use NotifyPublish on the Channel\n// to consume these events.\ntype Confirmation struct {\n\tDeliveryTag uint64 // A 1 based counter of publishings from when the channel was put in Confirm mode\n\tAck         bool   // True when the server successfully received the publishing\n}\n\n// Decimal matches the AMQP decimal type.  Scale is the number of decimal\n// digits Scale == 2, Value == 12345, Decimal == 123.45\ntype Decimal struct {\n\tScale uint8\n\tValue int32\n}\n\n// Table stores user supplied fields of the following types:\n//\n//   bool\n//   byte\n//   float32\n//   float64\n//   int\n//   int16\n//   int32\n//   int64\n//   nil\n//   string\n//   time.Time\n//   amqp.Decimal\n//   amqp.Table\n//   []byte\n//   []interface{} - containing above types\n//\n// Functions taking a table will immediately fail when the table contains a\n// value of an unsupported type.\n//\n// The caller must be specific in which precision of integer it wishes to\n// encode.\n//\n// Use a type assertion when reading values from a table for type conversion.\n//\n// RabbitMQ expects int32 for integer values.\n//\ntype Table map[string]interface{}\n\nfunc validateField(f interface{}) error {\n\tswitch fv := f.(type) {\n\tcase nil, bool, byte, int, int16, int32, int64, float32, float64, string, []byte, Decimal, time.Time:\n\t\treturn nil\n\n\tcase []interface{}:\n\t\tfor _, v := range fv {\n\t\t\tif err := validateField(v); err != nil {\n\t\t\t\treturn fmt.Errorf(\"in array %s\", err)\n\t\t\t}\n\t\t}\n\t\treturn nil\n\n\tcase Table:\n\t\tfor k, v := range fv {\n\t\t\tif err := validateField(v); err != nil {\n\t\t\t\treturn fmt.Errorf(\"table field %q %s\", k, err)\n\t\t\t}\n\t\t}\n\t\treturn nil\n\t}\n\n\treturn fmt.Errorf(\"value %T not supported\", f)\n}\n\n// Validate returns and error if any Go types in the table are incompatible with AMQP types.\nfunc (t Table) Validate() error {\n\treturn validateField(t)\n}\n\n// Heap interface for maintaining delivery tags\ntype tagSet []uint64\n\nfunc (set tagSet) Len() int              { return len(set) }\nfunc (set tagSet) Less(i, j int) bool    { return (set)[i] < (set)[j] }\nfunc (set tagSet) Swap(i, j int)         { (set)[i], (set)[j] = (set)[j], (set)[i] }\nfunc (set *tagSet) Push(tag interface{}) { *set = append(*set, tag.(uint64)) }\nfunc (set *tagSet) Pop() interface{} {\n\tval := (*set)[len(*set)-1]\n\t*set = (*set)[:len(*set)-1]\n\treturn val\n}\n\ntype message interface {\n\tid() (uint16, uint16)\n\twait() bool\n\tread(io.Reader) error\n\twrite(io.Writer) error\n}\n\ntype messageWithContent interface {\n\tmessage\n\tgetContent() (properties, []byte)\n\tsetContent(properties, []byte)\n}\n\n/*\nThe base interface implemented as:\n\n2.3.5  frame Details\n\nAll frames consist of a header (7 octets), a payload of arbitrary size, and a 'frame-end' octet that detects\nmalformed frames:\n\n  0      1         3             7                  size+7 size+8\n  +------+---------+-------------+  +------------+  +-----------+\n  | type | channel |     size    |  |  payload   |  | frame-end |\n  +------+---------+-------------+  +------------+  +-----------+\n   octet   short         long         size octets       octet\n\nTo read a frame, we:\n\n 1. Read the header and check the frame type and channel.\n 2. Depending on the frame type, we read the payload and process it.\n 3. Read the frame end octet.\n\nIn realistic implementations where performance is a concern, we would use\nread-ahead buffering or gathering reads to avoid doing three separate\nsystem calls to read a frame.\n\n*/\ntype frame interface {\n\twrite(io.Writer) error\n\tchannel() uint16\n}\n\ntype reader struct {\n\tr io.Reader\n}\n\ntype writer struct {\n\tw io.Writer\n}\n\n// Implements the frame interface for Connection RPC\ntype protocolHeader struct{}\n\nfunc (protocolHeader) write(w io.Writer) error {\n\t_, err := w.Write([]byte{'A', 'M', 'Q', 'P', 0, 0, 9, 1})\n\treturn err\n}\n\nfunc (protocolHeader) channel() uint16 {\n\tpanic(\"only valid as initial handshake\")\n}\n\n/*\nMethod frames carry the high-level protocol commands (which we call \"methods\").\nOne method frame carries one command.  The method frame payload has this format:\n\n  0          2           4\n  +----------+-----------+-------------- - -\n  | class-id | method-id | arguments...\n  +----------+-----------+-------------- - -\n     short      short    ...\n\nTo process a method frame, we:\n 1. Read the method frame payload.\n 2. Unpack it into a structure.  A given method always has the same structure,\n so we can unpack the method rapidly.  3. Check that the method is allowed in\n the current context.\n 4. Check that the method arguments are valid.\n 5. Execute the method.\n\nMethod frame bodies are constructed as a list of AMQP data fields (bits,\nintegers, strings and string tables).  The marshalling code is trivially\ngenerated directly from the protocol specifications, and can be very rapid.\n*/\ntype methodFrame struct {\n\tChannelId uint16\n\tClassId   uint16\n\tMethodId  uint16\n\tMethod    message\n}\n\nfunc (f *methodFrame) channel() uint16 { return f.ChannelId }\n\n/*\nHeartbeating is a technique designed to undo one of TCP/IP's features, namely\nits ability to recover from a broken physical connection by closing only after\na quite long time-out.  In some scenarios we need to know very rapidly if a\npeer is disconnected or not responding for other reasons (e.g. it is looping).\nSince heartbeating can be done at a low level, we implement this as a special\ntype of frame that peers exchange at the transport level, rather than as a\nclass method.\n*/\ntype heartbeatFrame struct {\n\tChannelId uint16\n}\n\nfunc (f *heartbeatFrame) channel() uint16 { return f.ChannelId }\n\n/*\nCertain methods (such as Basic.Publish, Basic.Deliver, etc.) are formally\ndefined as carrying content.  When a peer sends such a method frame, it always\nfollows it with a content header and zero or more content body frames.\n\nA content header frame has this format:\n\n    0          2        4           12               14\n    +----------+--------+-----------+----------------+------------- - -\n    | class-id | weight | body size | property flags | property list...\n    +----------+--------+-----------+----------------+------------- - -\n      short     short    long long       short        remainder...\n\nWe place content body in distinct frames (rather than including it in the\nmethod) so that AMQP may support \"zero copy\" techniques in which content is\nnever marshalled or encoded.  We place the content properties in their own\nframe so that recipients can selectively discard contents they do not want to\nprocess\n*/\ntype headerFrame struct {\n\tChannelId  uint16\n\tClassId    uint16\n\tweight     uint16\n\tSize       uint64\n\tProperties properties\n}\n\nfunc (f *headerFrame) channel() uint16 { return f.ChannelId }\n\n/*\nContent is the application data we carry from client-to-client via the AMQP\nserver.  Content is, roughly speaking, a set of properties plus a binary data\npart.  The set of allowed properties are defined by the Basic class, and these\nform the \"content header frame\".  The data can be any size, and MAY be broken\ninto several (or many) chunks, each forming a \"content body frame\".\n\nLooking at the frames for a specific channel, as they pass on the wire, we\nmight see something like this:\n\n\t\t[method]\n\t\t[method] [header] [body] [body]\n\t\t[method]\n\t\t...\n*/\ntype bodyFrame struct {\n\tChannelId uint16\n\tBody      []byte\n}\n\nfunc (f *bodyFrame) channel() uint16 { return f.ChannelId }\n"
        },
        {
          "name": "uri.go",
          "type": "blob",
          "size": 3.943359375,
          "content": "// Copyright (c) 2012, Sean Treadway, SoundCloud Ltd.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n// Source code and contact info at http://github.com/streadway/amqp\n\npackage amqp\n\nimport (\n\t\"errors\"\n\t\"net\"\n\t\"net/url\"\n\t\"strconv\"\n\t\"strings\"\n)\n\nvar errURIScheme = errors.New(\"AMQP scheme must be either 'amqp://' or 'amqps://'\")\nvar errURIWhitespace = errors.New(\"URI must not contain whitespace\")\n\nvar schemePorts = map[string]int{\n\t\"amqp\":  5672,\n\t\"amqps\": 5671,\n}\n\nvar defaultURI = URI{\n\tScheme:   \"amqp\",\n\tHost:     \"localhost\",\n\tPort:     5672,\n\tUsername: \"guest\",\n\tPassword: \"guest\",\n\tVhost:    \"/\",\n}\n\n// URI represents a parsed AMQP URI string.\ntype URI struct {\n\tScheme   string\n\tHost     string\n\tPort     int\n\tUsername string\n\tPassword string\n\tVhost    string\n}\n\n// ParseURI attempts to parse the given AMQP URI according to the spec.\n// See http://www.rabbitmq.com/uri-spec.html.\n//\n// Default values for the fields are:\n//\n//   Scheme: amqp\n//   Host: localhost\n//   Port: 5672\n//   Username: guest\n//   Password: guest\n//   Vhost: /\n//\nfunc ParseURI(uri string) (URI, error) {\n\tbuilder := defaultURI\n\n\tif strings.Contains(uri, \" \") == true {\n\t\treturn builder, errURIWhitespace\n\t}\n\n\tu, err := url.Parse(uri)\n\tif err != nil {\n\t\treturn builder, err\n\t}\n\n\tdefaultPort, okScheme := schemePorts[u.Scheme]\n\n\tif okScheme {\n\t\tbuilder.Scheme = u.Scheme\n\t} else {\n\t\treturn builder, errURIScheme\n\t}\n\n\thost := u.Hostname()\n\tport := u.Port()\n\n\tif host != \"\" {\n\t\tbuilder.Host = host\n\t}\n\n\tif port != \"\" {\n\t\tport32, err := strconv.ParseInt(port, 10, 32)\n\t\tif err != nil {\n\t\t\treturn builder, err\n\t\t}\n\t\tbuilder.Port = int(port32)\n\t} else {\n\t\tbuilder.Port = defaultPort\n\t}\n\n\tif u.User != nil {\n\t\tbuilder.Username = u.User.Username()\n\t\tif password, ok := u.User.Password(); ok {\n\t\t\tbuilder.Password = password\n\t\t}\n\t}\n\n\tif u.Path != \"\" {\n\t\tif strings.HasPrefix(u.Path, \"/\") {\n\t\t\tif u.Host == \"\" && strings.HasPrefix(u.Path, \"///\") {\n\t\t\t\t// net/url doesn't handle local context authorities and leaves that up\n\t\t\t\t// to the scheme handler.  In our case, we translate amqp:/// into the\n\t\t\t\t// default host and whatever the vhost should be\n\t\t\t\tif len(u.Path) > 3 {\n\t\t\t\t\tbuilder.Vhost = u.Path[3:]\n\t\t\t\t}\n\t\t\t} else if len(u.Path) > 1 {\n\t\t\t\tbuilder.Vhost = u.Path[1:]\n\t\t\t}\n\t\t} else {\n\t\t\tbuilder.Vhost = u.Path\n\t\t}\n\t}\n\n\treturn builder, nil\n}\n\n// PlainAuth returns a PlainAuth structure based on the parsed URI's\n// Username and Password fields.\nfunc (uri URI) PlainAuth() *PlainAuth {\n\treturn &PlainAuth{\n\t\tUsername: uri.Username,\n\t\tPassword: uri.Password,\n\t}\n}\n\n// AMQPlainAuth returns a PlainAuth structure based on the parsed URI's\n// Username and Password fields.\nfunc (uri URI) AMQPlainAuth() *AMQPlainAuth {\n\treturn &AMQPlainAuth{\n\t\tUsername: uri.Username,\n\t\tPassword: uri.Password,\n\t}\n}\n\nfunc (uri URI) String() string {\n\tauthority, err := url.Parse(\"\")\n\tif err != nil {\n\t\treturn err.Error()\n\t}\n\n\tauthority.Scheme = uri.Scheme\n\n\tif uri.Username != defaultURI.Username || uri.Password != defaultURI.Password {\n\t\tauthority.User = url.User(uri.Username)\n\n\t\tif uri.Password != defaultURI.Password {\n\t\t\tauthority.User = url.UserPassword(uri.Username, uri.Password)\n\t\t}\n\t}\n\n\tauthority.Host = net.JoinHostPort(uri.Host, strconv.Itoa(uri.Port))\n\n\tif defaultPort, found := schemePorts[uri.Scheme]; !found || defaultPort != uri.Port {\n\t\tauthority.Host = net.JoinHostPort(uri.Host, strconv.Itoa(uri.Port))\n\t} else {\n\t\t// JoinHostPort() automatically add brackets to the host if it's\n\t\t// an IPv6 address.\n\t\t//\n\t\t// If not port is specified, JoinHostPort() return an IP address in the\n\t\t// form of \"[::1]:\", so we use TrimSuffix() to remove the extra \":\".\n\t\tauthority.Host = strings.TrimSuffix(net.JoinHostPort(uri.Host, \"\"), \":\")\n\t}\n\n\tif uri.Vhost != defaultURI.Vhost {\n\t\t// Make sure net/url does not double escape, e.g.\n\t\t// \"%2F\" does not become \"%252F\".\n\t\tauthority.Path = uri.Vhost\n\t\tauthority.RawPath = url.QueryEscape(uri.Vhost)\n\t} else {\n\t\tauthority.Path = \"/\"\n\t}\n\n\treturn authority.String()\n}\n"
        },
        {
          "name": "uri_test.go",
          "type": "blob",
          "size": 7.984375,
          "content": "package amqp\n\nimport (\n\t\"testing\"\n)\n\n// Test matrix defined on http://www.rabbitmq.com/uri-spec.html\ntype testURI struct {\n\turl      string\n\tusername string\n\tpassword string\n\thost     string\n\tport     int\n\tvhost    string\n\tcanon    string\n}\n\nvar uriTests = []testURI{\n\t{\n\t\turl:      \"amqp://user:pass@host:10000/vhost\",\n\t\tusername: \"user\",\n\t\tpassword: \"pass\",\n\t\thost:     \"host\",\n\t\tport:     10000,\n\t\tvhost:    \"vhost\",\n\t\tcanon:    \"amqp://user:pass@host:10000/vhost\",\n\t},\n\n\t{\n\t\turl:      \"amqp://\",\n\t\tusername: defaultURI.Username,\n\t\tpassword: defaultURI.Password,\n\t\thost:     defaultURI.Host,\n\t\tport:     defaultURI.Port,\n\t\tvhost:    defaultURI.Vhost,\n\t\tcanon:    \"amqp://localhost/\",\n\t},\n\n\t{\n\t\turl:      \"amqp://:@/\",\n\t\tusername: \"\",\n\t\tpassword: \"\",\n\t\thost:     defaultURI.Host,\n\t\tport:     defaultURI.Port,\n\t\tvhost:    defaultURI.Vhost,\n\t\tcanon:    \"amqp://:@localhost/\",\n\t},\n\n\t{\n\t\turl:      \"amqp://user@\",\n\t\tusername: \"user\",\n\t\tpassword: defaultURI.Password,\n\t\thost:     defaultURI.Host,\n\t\tport:     defaultURI.Port,\n\t\tvhost:    defaultURI.Vhost,\n\t\tcanon:    \"amqp://user@localhost/\",\n\t},\n\n\t{\n\t\turl:      \"amqp://user:pass@\",\n\t\tusername: \"user\",\n\t\tpassword: \"pass\",\n\t\thost:     defaultURI.Host,\n\t\tport:     defaultURI.Port,\n\t\tvhost:    defaultURI.Vhost,\n\t\tcanon:    \"amqp://user:pass@localhost/\",\n\t},\n\n\t{\n\t\turl:      \"amqp://guest:pass@\",\n\t\tusername: \"guest\",\n\t\tpassword: \"pass\",\n\t\thost:     defaultURI.Host,\n\t\tport:     defaultURI.Port,\n\t\tvhost:    defaultURI.Vhost,\n\t\tcanon:    \"amqp://guest:pass@localhost/\",\n\t},\n\n\t{\n\t\turl:      \"amqp://host\",\n\t\tusername: defaultURI.Username,\n\t\tpassword: defaultURI.Password,\n\t\thost:     \"host\",\n\t\tport:     defaultURI.Port,\n\t\tvhost:    defaultURI.Vhost,\n\t\tcanon:    \"amqp://host/\",\n\t},\n\n\t{\n\t\turl:      \"amqp://:10000\",\n\t\tusername: defaultURI.Username,\n\t\tpassword: defaultURI.Password,\n\t\thost:     defaultURI.Host,\n\t\tport:     10000,\n\t\tvhost:    defaultURI.Vhost,\n\t\tcanon:    \"amqp://localhost:10000/\",\n\t},\n\n\t{\n\t\turl:      \"amqp:///vhost\",\n\t\tusername: defaultURI.Username,\n\t\tpassword: defaultURI.Password,\n\t\thost:     defaultURI.Host,\n\t\tport:     defaultURI.Port,\n\t\tvhost:    \"vhost\",\n\t\tcanon:    \"amqp://localhost/vhost\",\n\t},\n\n\t{\n\t\turl:      \"amqp://host/\",\n\t\tusername: defaultURI.Username,\n\t\tpassword: defaultURI.Password,\n\t\thost:     \"host\",\n\t\tport:     defaultURI.Port,\n\t\tvhost:    defaultURI.Vhost,\n\t\tcanon:    \"amqp://host/\",\n\t},\n\n\t{\n\t\turl:      \"amqp://host/%2F\",\n\t\tusername: defaultURI.Username,\n\t\tpassword: defaultURI.Password,\n\t\thost:     \"host\",\n\t\tport:     defaultURI.Port,\n\t\tvhost:    \"/\",\n\t\tcanon:    \"amqp://host/\",\n\t},\n\n\t{\n\t\turl:      \"amqp://host/%2F%2F\",\n\t\tusername: defaultURI.Username,\n\t\tpassword: defaultURI.Password,\n\t\thost:     \"host\",\n\t\tport:     defaultURI.Port,\n\t\tvhost:    \"//\",\n\t\tcanon:    \"amqp://host/%2F%2F\",\n\t},\n\n\t{\n\t\turl:      \"amqp://host/%2Fslash%2F\",\n\t\tusername: defaultURI.Username,\n\t\tpassword: defaultURI.Password,\n\t\thost:     \"host\",\n\t\tport:     defaultURI.Port,\n\t\tvhost:    \"/slash/\",\n\t\tcanon:    \"amqp://host/%2Fslash%2F\",\n\t},\n\n\t{\n\t\turl:      \"amqp://192.168.1.1:1000/\",\n\t\tusername: defaultURI.Username,\n\t\tpassword: defaultURI.Password,\n\t\thost:     \"192.168.1.1\",\n\t\tport:     1000,\n\t\tvhost:    defaultURI.Vhost,\n\t\tcanon:    \"amqp://192.168.1.1:1000/\",\n\t},\n\n\t{\n\t\turl:      \"amqp://[::1]\",\n\t\tusername: defaultURI.Username,\n\t\tpassword: defaultURI.Password,\n\t\thost:     \"::1\",\n\t\tport:     defaultURI.Port,\n\t\tvhost:    defaultURI.Vhost,\n\t\tcanon:    \"amqp://[::1]/\",\n\t},\n\n\t{\n\t\turl:      \"amqp://[::1]:1000\",\n\t\tusername: defaultURI.Username,\n\t\tpassword: defaultURI.Password,\n\t\thost:     \"::1\",\n\t\tport:     1000,\n\t\tvhost:    defaultURI.Vhost,\n\t\tcanon:    \"amqp://[::1]:1000/\",\n\t},\n\n\t{\n\t\turl:      \"amqp://[fe80::1]\",\n\t\tusername: defaultURI.Username,\n\t\tpassword: defaultURI.Password,\n\t\thost:     \"fe80::1\",\n\t\tport:     defaultURI.Port,\n\t\tvhost:    defaultURI.Vhost,\n\t\tcanon:    \"amqp://[fe80::1]/\",\n\t},\n\n\t{\n\t\turl:      \"amqp://[fe80::1]\",\n\t\tusername: defaultURI.Username,\n\t\tpassword: defaultURI.Password,\n\t\thost:     \"fe80::1\",\n\t\tport:     defaultURI.Port,\n\t\tvhost:    defaultURI.Vhost,\n\t\tcanon:    \"amqp://[fe80::1]/\",\n\t},\n\n\t{\n\t\turl:      \"amqp://[fe80::1%25en0]\",\n\t\tusername: defaultURI.Username,\n\t\tpassword: defaultURI.Password,\n\t\thost:     \"fe80::1%en0\",\n\t\tport:     defaultURI.Port,\n\t\tvhost:    defaultURI.Vhost,\n\t\tcanon:    \"amqp://[fe80::1%25en0]/\",\n\t},\n\n\t{\n\t\turl:      \"amqp://[fe80::1]:5671\",\n\t\tusername: defaultURI.Username,\n\t\tpassword: defaultURI.Password,\n\t\thost:     \"fe80::1\",\n\t\tport:     5671,\n\t\tvhost:    defaultURI.Vhost,\n\t\tcanon:    \"amqp://[fe80::1]:5671/\",\n\t},\n\n\t{\n\t\turl:      \"amqps:///\",\n\t\tusername: defaultURI.Username,\n\t\tpassword: defaultURI.Password,\n\t\thost:     defaultURI.Host,\n\t\tport:     schemePorts[\"amqps\"],\n\t\tvhost:    defaultURI.Vhost,\n\t\tcanon:    \"amqps://localhost/\",\n\t},\n\n\t{\n\t\turl:      \"amqps://host:1000/\",\n\t\tusername: defaultURI.Username,\n\t\tpassword: defaultURI.Password,\n\t\thost:     \"host\",\n\t\tport:     1000,\n\t\tvhost:    defaultURI.Vhost,\n\t\tcanon:    \"amqps://host:1000/\",\n\t},\n}\n\nfunc TestURISpec(t *testing.T) {\n\tfor _, test := range uriTests {\n\t\tu, err := ParseURI(test.url)\n\t\tif err != nil {\n\t\t\tt.Fatal(\"Could not parse spec URI: \", test.url, \" err: \", err)\n\t\t}\n\n\t\tif test.username != u.Username {\n\t\t\tt.Error(\"For: \", test.url, \" usernames do not match. want: \", test.username, \" got: \", u.Username)\n\t\t}\n\n\t\tif test.password != u.Password {\n\t\t\tt.Error(\"For: \", test.url, \" passwords do not match. want: \", test.password, \" got: \", u.Password)\n\t\t}\n\n\t\tif test.host != u.Host {\n\t\t\tt.Error(\"For: \", test.url, \" hosts do not match. want: \", test.host, \" got: \", u.Host)\n\t\t}\n\n\t\tif test.port != u.Port {\n\t\t\tt.Error(\"For: \", test.url, \" ports do not match. want: \", test.port, \" got: \", u.Port)\n\t\t}\n\n\t\tif test.vhost != u.Vhost {\n\t\t\tt.Error(\"For: \", test.url, \" vhosts do not match. want: \", test.vhost, \" got: \", u.Vhost)\n\t\t}\n\n\t\tif test.canon != u.String() {\n\t\t\tt.Error(\"For: \", test.url, \" canonical string does not match. want: \", test.canon, \" got: \", u.String())\n\t\t}\n\t}\n}\n\nfunc TestURIUnknownScheme(t *testing.T) {\n\tif _, err := ParseURI(\"http://example.com/\"); err == nil {\n\t\tt.Fatal(\"Expected error when parsing non-amqp scheme\")\n\t}\n}\n\nfunc TestURIScheme(t *testing.T) {\n\tif _, err := ParseURI(\"amqp://example.com/\"); err != nil {\n\t\tt.Fatalf(\"Expected to parse amqp scheme, got %v\", err)\n\t}\n\n\tif _, err := ParseURI(\"amqps://example.com/\"); err != nil {\n\t\tt.Fatalf(\"Expected to parse amqps scheme, got %v\", err)\n\t}\n}\n\nfunc TestURIWhitespace(t *testing.T) {\n\tif _, err := ParseURI(\"amqp://admin:PASSWORD@rabbitmq-service/ -http_port=8080\"); err == nil {\n\t\tt.Fatal(\"Expected to fail if URI contains whitespace\")\n\t}\n}\n\nfunc TestURIDefaults(t *testing.T) {\n\turl := \"amqp://\"\n\turi, err := ParseURI(url)\n\tif err != nil {\n\t\tt.Fatal(\"Could not parse\")\n\t}\n\n\tif uri.String() != \"amqp://localhost/\" {\n\t\tt.Fatal(\"Defaults not encoded properly got:\", uri.String())\n\t}\n}\n\nfunc TestURIComplete(t *testing.T) {\n\turl := \"amqp://bob:dobbs@foo.bar:5678/private\"\n\turi, err := ParseURI(url)\n\tif err != nil {\n\t\tt.Fatal(\"Could not parse\")\n\t}\n\n\tif uri.String() != url {\n\t\tt.Fatal(\"Defaults not encoded properly want:\", url, \" got:\", uri.String())\n\t}\n}\n\nfunc TestURIDefaultPortAmqpNotIncluded(t *testing.T) {\n\turl := \"amqp://foo.bar:5672/\"\n\turi, err := ParseURI(url)\n\tif err != nil {\n\t\tt.Fatal(\"Could not parse\")\n\t}\n\n\tif uri.String() != \"amqp://foo.bar/\" {\n\t\tt.Fatal(\"Defaults not encoded properly got:\", uri.String())\n\t}\n}\n\nfunc TestURIDefaultPortAmqp(t *testing.T) {\n\turl := \"amqp://foo.bar/\"\n\turi, err := ParseURI(url)\n\tif err != nil {\n\t\tt.Fatal(\"Could not parse\")\n\t}\n\n\tif uri.Port != 5672 {\n\t\tt.Fatal(\"Default port not correct for amqp, got:\", uri.Port)\n\t}\n}\n\nfunc TestURIDefaultPortAmqpsNotIncludedInString(t *testing.T) {\n\turl := \"amqps://foo.bar:5671/\"\n\turi, err := ParseURI(url)\n\tif err != nil {\n\t\tt.Fatal(\"Could not parse\")\n\t}\n\n\tif uri.String() != \"amqps://foo.bar/\" {\n\t\tt.Fatal(\"Defaults not encoded properly got:\", uri.String())\n\t}\n}\n\nfunc TestURIDefaultPortAmqps(t *testing.T) {\n\turl := \"amqps://foo.bar/\"\n\turi, err := ParseURI(url)\n\tif err != nil {\n\t\tt.Fatal(\"Could not parse\")\n\t}\n\n\tif uri.Port != 5671 {\n\t\tt.Fatal(\"Default port not correct for amqps, got:\", uri.Port)\n\t}\n}\n"
        },
        {
          "name": "write.go",
          "type": "blob",
          "size": 8.4208984375,
          "content": "// Copyright (c) 2012, Sean Treadway, SoundCloud Ltd.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n// Source code and contact info at http://github.com/streadway/amqp\n\npackage amqp\n\nimport (\n\t\"bufio\"\n\t\"bytes\"\n\t\"encoding/binary\"\n\t\"errors\"\n\t\"io\"\n\t\"math\"\n\t\"time\"\n)\n\nfunc (w *writer) WriteFrame(frame frame) (err error) {\n\tif err = frame.write(w.w); err != nil {\n\t\treturn\n\t}\n\n\tif buf, ok := w.w.(*bufio.Writer); ok {\n\t\terr = buf.Flush()\n\t}\n\n\treturn\n}\n\nfunc (f *methodFrame) write(w io.Writer) (err error) {\n\tvar payload bytes.Buffer\n\n\tif f.Method == nil {\n\t\treturn errors.New(\"malformed frame: missing method\")\n\t}\n\n\tclass, method := f.Method.id()\n\n\tif err = binary.Write(&payload, binary.BigEndian, class); err != nil {\n\t\treturn\n\t}\n\n\tif err = binary.Write(&payload, binary.BigEndian, method); err != nil {\n\t\treturn\n\t}\n\n\tif err = f.Method.write(&payload); err != nil {\n\t\treturn\n\t}\n\n\treturn writeFrame(w, frameMethod, f.ChannelId, payload.Bytes())\n}\n\n// Heartbeat\n//\n// Payload is empty\nfunc (f *heartbeatFrame) write(w io.Writer) (err error) {\n\treturn writeFrame(w, frameHeartbeat, f.ChannelId, []byte{})\n}\n\n// CONTENT HEADER\n// 0          2        4           12               14\n// +----------+--------+-----------+----------------+------------- - -\n// | class-id | weight | body size | property flags | property list...\n// +----------+--------+-----------+----------------+------------- - -\n//    short     short    long long       short        remainder...\n//\nfunc (f *headerFrame) write(w io.Writer) (err error) {\n\tvar payload bytes.Buffer\n\tvar zeroTime time.Time\n\n\tif err = binary.Write(&payload, binary.BigEndian, f.ClassId); err != nil {\n\t\treturn\n\t}\n\n\tif err = binary.Write(&payload, binary.BigEndian, f.weight); err != nil {\n\t\treturn\n\t}\n\n\tif err = binary.Write(&payload, binary.BigEndian, f.Size); err != nil {\n\t\treturn\n\t}\n\n\t// First pass will build the mask to be serialized, second pass will serialize\n\t// each of the fields that appear in the mask.\n\n\tvar mask uint16\n\n\tif len(f.Properties.ContentType) > 0 {\n\t\tmask = mask | flagContentType\n\t}\n\tif len(f.Properties.ContentEncoding) > 0 {\n\t\tmask = mask | flagContentEncoding\n\t}\n\tif f.Properties.Headers != nil && len(f.Properties.Headers) > 0 {\n\t\tmask = mask | flagHeaders\n\t}\n\tif f.Properties.DeliveryMode > 0 {\n\t\tmask = mask | flagDeliveryMode\n\t}\n\tif f.Properties.Priority > 0 {\n\t\tmask = mask | flagPriority\n\t}\n\tif len(f.Properties.CorrelationId) > 0 {\n\t\tmask = mask | flagCorrelationId\n\t}\n\tif len(f.Properties.ReplyTo) > 0 {\n\t\tmask = mask | flagReplyTo\n\t}\n\tif len(f.Properties.Expiration) > 0 {\n\t\tmask = mask | flagExpiration\n\t}\n\tif len(f.Properties.MessageId) > 0 {\n\t\tmask = mask | flagMessageId\n\t}\n\tif f.Properties.Timestamp != zeroTime {\n\t\tmask = mask | flagTimestamp\n\t}\n\tif len(f.Properties.Type) > 0 {\n\t\tmask = mask | flagType\n\t}\n\tif len(f.Properties.UserId) > 0 {\n\t\tmask = mask | flagUserId\n\t}\n\tif len(f.Properties.AppId) > 0 {\n\t\tmask = mask | flagAppId\n\t}\n\n\tif err = binary.Write(&payload, binary.BigEndian, mask); err != nil {\n\t\treturn\n\t}\n\n\tif hasProperty(mask, flagContentType) {\n\t\tif err = writeShortstr(&payload, f.Properties.ContentType); err != nil {\n\t\t\treturn\n\t\t}\n\t}\n\tif hasProperty(mask, flagContentEncoding) {\n\t\tif err = writeShortstr(&payload, f.Properties.ContentEncoding); err != nil {\n\t\t\treturn\n\t\t}\n\t}\n\tif hasProperty(mask, flagHeaders) {\n\t\tif err = writeTable(&payload, f.Properties.Headers); err != nil {\n\t\t\treturn\n\t\t}\n\t}\n\tif hasProperty(mask, flagDeliveryMode) {\n\t\tif err = binary.Write(&payload, binary.BigEndian, f.Properties.DeliveryMode); err != nil {\n\t\t\treturn\n\t\t}\n\t}\n\tif hasProperty(mask, flagPriority) {\n\t\tif err = binary.Write(&payload, binary.BigEndian, f.Properties.Priority); err != nil {\n\t\t\treturn\n\t\t}\n\t}\n\tif hasProperty(mask, flagCorrelationId) {\n\t\tif err = writeShortstr(&payload, f.Properties.CorrelationId); err != nil {\n\t\t\treturn\n\t\t}\n\t}\n\tif hasProperty(mask, flagReplyTo) {\n\t\tif err = writeShortstr(&payload, f.Properties.ReplyTo); err != nil {\n\t\t\treturn\n\t\t}\n\t}\n\tif hasProperty(mask, flagExpiration) {\n\t\tif err = writeShortstr(&payload, f.Properties.Expiration); err != nil {\n\t\t\treturn\n\t\t}\n\t}\n\tif hasProperty(mask, flagMessageId) {\n\t\tif err = writeShortstr(&payload, f.Properties.MessageId); err != nil {\n\t\t\treturn\n\t\t}\n\t}\n\tif hasProperty(mask, flagTimestamp) {\n\t\tif err = binary.Write(&payload, binary.BigEndian, uint64(f.Properties.Timestamp.Unix())); err != nil {\n\t\t\treturn\n\t\t}\n\t}\n\tif hasProperty(mask, flagType) {\n\t\tif err = writeShortstr(&payload, f.Properties.Type); err != nil {\n\t\t\treturn\n\t\t}\n\t}\n\tif hasProperty(mask, flagUserId) {\n\t\tif err = writeShortstr(&payload, f.Properties.UserId); err != nil {\n\t\t\treturn\n\t\t}\n\t}\n\tif hasProperty(mask, flagAppId) {\n\t\tif err = writeShortstr(&payload, f.Properties.AppId); err != nil {\n\t\t\treturn\n\t\t}\n\t}\n\n\treturn writeFrame(w, frameHeader, f.ChannelId, payload.Bytes())\n}\n\n// Body\n//\n// Payload is one byterange from the full body who's size is declared in the\n// Header frame\nfunc (f *bodyFrame) write(w io.Writer) (err error) {\n\treturn writeFrame(w, frameBody, f.ChannelId, f.Body)\n}\n\nfunc writeFrame(w io.Writer, typ uint8, channel uint16, payload []byte) (err error) {\n\tend := []byte{frameEnd}\n\tsize := uint(len(payload))\n\n\t_, err = w.Write([]byte{\n\t\tbyte(typ),\n\t\tbyte((channel & 0xff00) >> 8),\n\t\tbyte((channel & 0x00ff) >> 0),\n\t\tbyte((size & 0xff000000) >> 24),\n\t\tbyte((size & 0x00ff0000) >> 16),\n\t\tbyte((size & 0x0000ff00) >> 8),\n\t\tbyte((size & 0x000000ff) >> 0),\n\t})\n\n\tif err != nil {\n\t\treturn\n\t}\n\n\tif _, err = w.Write(payload); err != nil {\n\t\treturn\n\t}\n\n\tif _, err = w.Write(end); err != nil {\n\t\treturn\n\t}\n\n\treturn\n}\n\nfunc writeShortstr(w io.Writer, s string) (err error) {\n\tb := []byte(s)\n\n\tvar length = uint8(len(b))\n\n\tif err = binary.Write(w, binary.BigEndian, length); err != nil {\n\t\treturn\n\t}\n\n\tif _, err = w.Write(b[:length]); err != nil {\n\t\treturn\n\t}\n\n\treturn\n}\n\nfunc writeLongstr(w io.Writer, s string) (err error) {\n\tb := []byte(s)\n\n\tvar length = uint32(len(b))\n\n\tif err = binary.Write(w, binary.BigEndian, length); err != nil {\n\t\treturn\n\t}\n\n\tif _, err = w.Write(b[:length]); err != nil {\n\t\treturn\n\t}\n\n\treturn\n}\n\n/*\n'A': []interface{}\n'D': Decimal\n'F': Table\n'I': int32\n'S': string\n'T': time.Time\n'V': nil\n'b': byte\n'd': float64\n'f': float32\n'l': int64\n's': int16\n't': bool\n'x': []byte\n*/\nfunc writeField(w io.Writer, value interface{}) (err error) {\n\tvar buf [9]byte\n\tvar enc []byte\n\n\tswitch v := value.(type) {\n\tcase bool:\n\t\tbuf[0] = 't'\n\t\tif v {\n\t\t\tbuf[1] = byte(1)\n\t\t} else {\n\t\t\tbuf[1] = byte(0)\n\t\t}\n\t\tenc = buf[:2]\n\n\tcase byte:\n\t\tbuf[0] = 'b'\n\t\tbuf[1] = byte(v)\n\t\tenc = buf[:2]\n\n\tcase int16:\n\t\tbuf[0] = 's'\n\t\tbinary.BigEndian.PutUint16(buf[1:3], uint16(v))\n\t\tenc = buf[:3]\n\n\tcase int:\n\t\tbuf[0] = 'I'\n\t\tbinary.BigEndian.PutUint32(buf[1:5], uint32(v))\n\t\tenc = buf[:5]\n\n\tcase int32:\n\t\tbuf[0] = 'I'\n\t\tbinary.BigEndian.PutUint32(buf[1:5], uint32(v))\n\t\tenc = buf[:5]\n\n\tcase int64:\n\t\tbuf[0] = 'l'\n\t\tbinary.BigEndian.PutUint64(buf[1:9], uint64(v))\n\t\tenc = buf[:9]\n\n\tcase float32:\n\t\tbuf[0] = 'f'\n\t\tbinary.BigEndian.PutUint32(buf[1:5], math.Float32bits(v))\n\t\tenc = buf[:5]\n\n\tcase float64:\n\t\tbuf[0] = 'd'\n\t\tbinary.BigEndian.PutUint64(buf[1:9], math.Float64bits(v))\n\t\tenc = buf[:9]\n\n\tcase Decimal:\n\t\tbuf[0] = 'D'\n\t\tbuf[1] = byte(v.Scale)\n\t\tbinary.BigEndian.PutUint32(buf[2:6], uint32(v.Value))\n\t\tenc = buf[:6]\n\n\tcase string:\n\t\tbuf[0] = 'S'\n\t\tbinary.BigEndian.PutUint32(buf[1:5], uint32(len(v)))\n\t\tenc = append(buf[:5], []byte(v)...)\n\n\tcase []interface{}: // field-array\n\t\tbuf[0] = 'A'\n\n\t\tsec := new(bytes.Buffer)\n\t\tfor _, val := range v {\n\t\t\tif err = writeField(sec, val); err != nil {\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\n\t\tbinary.BigEndian.PutUint32(buf[1:5], uint32(sec.Len()))\n\t\tif _, err = w.Write(buf[:5]); err != nil {\n\t\t\treturn\n\t\t}\n\n\t\tif _, err = w.Write(sec.Bytes()); err != nil {\n\t\t\treturn\n\t\t}\n\n\t\treturn\n\n\tcase time.Time:\n\t\tbuf[0] = 'T'\n\t\tbinary.BigEndian.PutUint64(buf[1:9], uint64(v.Unix()))\n\t\tenc = buf[:9]\n\n\tcase Table:\n\t\tif _, err = w.Write([]byte{'F'}); err != nil {\n\t\t\treturn\n\t\t}\n\t\treturn writeTable(w, v)\n\n\tcase []byte:\n\t\tbuf[0] = 'x'\n\t\tbinary.BigEndian.PutUint32(buf[1:5], uint32(len(v)))\n\t\tif _, err = w.Write(buf[0:5]); err != nil {\n\t\t\treturn\n\t\t}\n\t\tif _, err = w.Write(v); err != nil {\n\t\t\treturn\n\t\t}\n\t\treturn\n\n\tcase nil:\n\t\tbuf[0] = 'V'\n\t\tenc = buf[:1]\n\n\tdefault:\n\t\treturn ErrFieldType\n\t}\n\n\t_, err = w.Write(enc)\n\n\treturn\n}\n\nfunc writeTable(w io.Writer, table Table) (err error) {\n\tvar buf bytes.Buffer\n\n\tfor key, val := range table {\n\t\tif err = writeShortstr(&buf, key); err != nil {\n\t\t\treturn\n\t\t}\n\t\tif err = writeField(&buf, val); err != nil {\n\t\t\treturn\n\t\t}\n\t}\n\n\treturn writeLongstr(w, string(buf.Bytes()))\n}\n"
        }
      ]
    }
  ]
}