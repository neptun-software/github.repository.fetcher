{
  "metadata": {
    "timestamp": 1736566577933,
    "page": 128,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjEzMA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "google/gxui",
      "stars": 4433,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".travis.yml",
          "type": "blob",
          "size": 0.3671875,
          "content": "language: go\ngo:\n  - 1.4\nbefore_install:\n  - sudo apt-get update\n  - sudo apt-get install -qq libxi-dev libxcursor-dev libxrandr-dev libxinerama-dev mesa-common-dev libgl1-mesa-dev libxxf86vm-dev\ninstall:\n  - go get golang.org/x/tools/cmd/vet\nscript:\n  - go get -t -v ./...\n  - diff -u <(echo -n) <(gofmt -d ./)\n  - go tool vet -composites=false ./\n  - go test -v -race ./...\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.4443359375,
          "content": "Copyright (c) 2015 The Go Authors. All rights reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are\nmet:\n\n   * Redistributions of source code must retain the above copyright\nnotice, this list of conditions and the following disclaimer.\n   * Redistributions in binary form must reproduce the above\ncopyright notice, this list of conditions and the following disclaimer\nin the documentation and/or other materials provided with the\ndistribution.\n   * Neither the name of Google Inc. nor the names of its\ncontributors may be used to endorse or promote products derived from\nthis software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n\"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\nLIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\nA PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\nOWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\nSPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\nLIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\nTHEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 3.447265625,
          "content": "GXUI - A Go cross platform UI library.\n=======\n\n[![Join the chat at https://gitter.im/google/gxui](https://badges.gitter.im/Join%20Chat.svg)](https://gitter.im/google/gxui?utm_source=badge&utm_medium=badge&utm_campaign=pr-badge&utm_content=badge) [![Build Status](https://travis-ci.org/google/gxui.svg?branch=master)](https://travis-ci.org/google/gxui) [![GoDoc](https://godoc.org/github.com/google/gxui?status.svg)](https://godoc.org/github.com/google/gxui)\n\n\nNotice:\n---\n\nUnfortunately due to a shortage of hours in a day, GXUI is no longer maintained.\n\nIf you're looking for a GUI library for your next Go project, [check out these alternatives](https://github.com/avelino/awesome-go#gui).\n\nDisclaimer\n---\n\nThe code is mostly undocumented, and is certainly **not idiomatic Go**.\n\nThis is not an official Google product (experimental or otherwise), it is just code that happens to be owned by Google.\n\nDependencies\n---\n\n### Linux:\n\nIn order to build GXUI on linux, you will need the following packages installed:\n\n    sudo apt-get install libxi-dev libxcursor-dev libxrandr-dev libxinerama-dev mesa-common-dev libgl1-mesa-dev libxxf86vm-dev\n\n### Common:\n\nAfter setting up ```GOPATH``` (see [Go documentation](https://golang.org/doc/code.html)), you can then fetch the GXUI library and its dependencies:\n\n    go get -u github.com/google/gxui/...\n\nSamples\n---\nSamples can be found in [`gxui/samples`](https://github.com/google/gxui/tree/master/samples).\n\nTo build all samples run:\n\n    go install github.com/google/gxui/samples/...\n\nAnd they will be built into ```GOPATH/bin```.\n\nIf you add ```GOPATH/bin``` to your PATH, you can simply type the name of a sample to run it. For example: ```image_viewer```.\n\nWeb\n---\n\ngxui code is cross platform and can be compiled using GopherJS to JavaScript, allowing it to run in browsers with WebGL support. To do so, you'll need the [GopherJS compiler](https://github.com/gopherjs/gopherjs) and some additional dependencies:\n\n    go get -u github.com/gopherjs/gopherjs\n    go get -u -d -tags=js github.com/google/gxui/...\n    \nAfterwards, you can try the samples by running `gopherjs serve` command and opening <http://localhost:8080/github.com/google/gxui/samples/> in a browser.\n\nFonts\n---\nMany of the samples require a font to render text. The dark theme (and currently the only theme) uses `Roboto`.\nThis is built into the gxfont package.\n\nMake sure to mention this font in any notices file distributed with your application.\n\nContributing\n---\nGXUI was written by a couple of Googlers as an experiment and is now unmaintained.\n\nContributions, however small, will require the author to have signed the [Google Individual Contributor License Agreement](https://developers.google.com/open-source/cla/individual?csw=1).\n\nThe CLA is necessary mainly because you own the copyright to your changes, even after your contribution becomes part of our codebase, so we need your permission to use and distribute your code. We also need to be sure of various other things—for instance that you'll tell us if you know that your code infringes on other people's patents. You don't have to sign the CLA until after you've submitted your code for review and a member has approved it, but you must do it before we can put your code into our codebase. Before you start working on a larger contribution, you should get in touch with us first through the issue tracker with your idea so that we can help out and possibly guide you. Coordinating up front makes it much easier to avoid frustration later on.\n"
        },
        {
          "name": "VERSION",
          "type": "blob",
          "size": 0.0068359375,
          "content": "gxui0.1"
        },
        {
          "name": "adapter_base.go",
          "type": "blob",
          "size": 0.83984375,
          "content": "// Copyright 2015 The Go Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage gxui\n\ntype AdapterBase struct {\n\tonDataChanged, onDataReplaced Event\n}\n\nfunc (a *AdapterBase) DataChanged(recreateControls bool) {\n\tif a.onDataChanged != nil {\n\t\ta.onDataChanged.Fire(recreateControls)\n\t}\n}\n\nfunc (a *AdapterBase) DataReplaced() {\n\tif a.onDataReplaced != nil {\n\t\ta.onDataReplaced.Fire()\n\t}\n}\n\nfunc (a *AdapterBase) OnDataChanged(f func(recreateControls bool)) EventSubscription {\n\tif a.onDataChanged == nil {\n\t\ta.onDataChanged = CreateEvent(func(bool) {})\n\t}\n\treturn a.onDataChanged.Listen(f)\n}\n\nfunc (a *AdapterBase) OnDataReplaced(f func()) EventSubscription {\n\tif a.onDataReplaced == nil {\n\t\ta.onDataReplaced = CreateEvent(func() {})\n\t}\n\treturn a.onDataReplaced.Listen(f)\n}\n"
        },
        {
          "name": "adapter_item.go",
          "type": "blob",
          "size": 0.3505859375,
          "content": "// Copyright 2015 The Go Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage gxui\n\n// AdapterItem is a user defined type that can be used to uniquely identify a\n// single item in an adapter. The type must support equality and be hashable.\ntype AdapterItem interface{}\n"
        },
        {
          "name": "alignment.go",
          "type": "blob",
          "size": 0.8037109375,
          "content": "// Copyright 2015 The Go Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage gxui\n\ntype HorizontalAlignment int\n\nconst (\n\tAlignLeft HorizontalAlignment = iota\n\tAlignCenter\n\tAlignRight\n)\n\nfunc (a HorizontalAlignment) AlignLeft() bool   { return a == AlignLeft }\nfunc (a HorizontalAlignment) AlignCenter() bool { return a == AlignCenter }\nfunc (a HorizontalAlignment) AlignRight() bool  { return a == AlignRight }\n\ntype VerticalAlignment int\n\nconst (\n\tAlignTop VerticalAlignment = iota\n\tAlignMiddle\n\tAlignBottom\n)\n\nfunc (a VerticalAlignment) AlignTop() bool    { return a == AlignTop }\nfunc (a VerticalAlignment) AlignMiddle() bool { return a == AlignMiddle }\nfunc (a VerticalAlignment) AlignBottom() bool { return a == AlignBottom }\n"
        },
        {
          "name": "brush.go",
          "type": "blob",
          "size": 0.412109375,
          "content": "// Copyright 2015 The Go Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage gxui\n\nvar WhiteBrush = CreateBrush(White)\nvar TransparentBrush = CreateBrush(Transparent)\nvar BlackBrush = CreateBrush(Black)\nvar DefaultBrush = WhiteBrush\n\ntype Brush struct {\n\tColor Color\n}\n\nfunc CreateBrush(color Color) Brush {\n\treturn Brush{color}\n}\n"
        },
        {
          "name": "bubble_overlay.go",
          "type": "blob",
          "size": 0.3017578125,
          "content": "// Copyright 2015 The Go Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage gxui\n\nimport (\n\t\"github.com/google/gxui/math\"\n)\n\ntype BubbleOverlay interface {\n\tControl\n\tShow(control Control, target math.Point)\n\tHide()\n}\n"
        },
        {
          "name": "button.go",
          "type": "blob",
          "size": 0.388671875,
          "content": "// Copyright 2015 The Go Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage gxui\n\ntype ButtonType int\n\nconst (\n\tPushButton ButtonType = iota\n\tToggleButton\n)\n\ntype Button interface {\n\tLinearLayout\n\tText() string\n\tSetText(string)\n\tType() ButtonType\n\tSetType(ButtonType)\n\tIsChecked() bool\n\tSetChecked(bool)\n}\n"
        },
        {
          "name": "canvas.go",
          "type": "blob",
          "size": 0.640625,
          "content": "// Copyright 2015 The Go Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage gxui\n\nimport (\n\t\"github.com/google/gxui/math\"\n)\n\ntype Canvas interface {\n\tSize() math.Size\n\tIsComplete() bool\n\tComplete()\n\tPush()\n\tPop()\n\tAddClip(math.Rect)\n\tClear(Color)\n\tDrawCanvas(c Canvas, position math.Point)\n\tDrawTexture(t Texture, bounds math.Rect)\n\tDrawRunes(font Font, runes []rune, points []math.Point, color Color)\n\tDrawLines(Polygon, Pen)\n\tDrawPolygon(Polygon, Pen, Brush)\n\tDrawRect(math.Rect, Brush)\n\tDrawRoundedRect(rect math.Rect, tl, tr, bl, br float32, p Pen, b Brush)\n}\n"
        },
        {
          "name": "channeled_event.go",
          "type": "blob",
          "size": 0.94921875,
          "content": "// Copyright 2015 The Go Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage gxui\n\nimport (\n\t\"reflect\"\n\t\"sync\"\n)\n\ntype ChanneledEvent struct {\n\tsync.RWMutex\n\tbase    EventBase\n\tchannel chan func()\n}\n\nfunc CreateChanneledEvent(signature interface{}, channel chan func()) Event {\n\te := &ChanneledEvent{\n\t\tchannel: channel,\n\t}\n\te.base.init(signature)\n\tbaseUnlisten := e.base.unlisten\n\te.base.unlisten = func(id int) {\n\t\te.RLock()\n\t\tbaseUnlisten(id)\n\t\te.RUnlock()\n\t}\n\treturn e\n}\n\nfunc (e *ChanneledEvent) Fire(args ...interface{}) {\n\te.base.VerifyArguments(args)\n\te.channel <- func() {\n\t\te.RLock()\n\t\te.base.InvokeListeners(args)\n\t\te.RUnlock()\n\t}\n}\n\nfunc (e *ChanneledEvent) Listen(listener interface{}) EventSubscription {\n\te.Lock()\n\tres := e.base.Listen(listener)\n\te.Unlock()\n\treturn res\n}\n\nfunc (e *ChanneledEvent) ParameterTypes() []reflect.Type {\n\treturn e.base.ParameterTypes()\n}\n"
        },
        {
          "name": "code_editor.go",
          "type": "blob",
          "size": 0.591796875,
          "content": "// Copyright 2015 The Go Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage gxui\n\ntype CodeSuggestion interface {\n\tName() string\n\tCode() string\n}\n\ntype CodeSuggestionProvider interface {\n\tSuggestionsAt(runeIndex int) []CodeSuggestion\n}\n\ntype CodeEditor interface {\n\tTextBox\n\tSyntaxLayers() CodeSyntaxLayers\n\tSetSyntaxLayers(CodeSyntaxLayers)\n\tTabWidth() int\n\tSetTabWidth(int)\n\tSuggestionProvider() CodeSuggestionProvider\n\tSetSuggestionProvider(CodeSuggestionProvider)\n\tShowSuggestionList()\n\tHideSuggestionList()\n}\n"
        },
        {
          "name": "code_syntax_layer.go",
          "type": "blob",
          "size": 2.7744140625,
          "content": "// Copyright 2015 The Go Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage gxui\n\nimport (\n\t\"github.com/google/gxui/interval\"\n\t\"github.com/google/gxui/math\"\n)\n\ntype CodeSyntaxLayer struct {\n\tspans           interval.IntDataList\n\tcolor           *Color\n\tbackgroundColor *Color\n\tborderColor     *Color\n\tdata            interface{}\n}\n\nfunc CreateCodeSyntaxLayer() *CodeSyntaxLayer { return &CodeSyntaxLayer{} }\n\nfunc (l *CodeSyntaxLayer) Clear() {\n\tl.spans = interval.IntDataList{}\n}\n\nfunc (l *CodeSyntaxLayer) UpdateSpans(runeCount int, edits []TextBoxEdit) {\n\tmin := 0\n\tmax := runeCount\n\tfor _, e := range edits {\n\t\tif l == nil {\n\t\t\tcontinue\n\t\t}\n\t\tfor j, s := range l.spans {\n\t\t\tat := e.At\n\t\t\tstart, end := s.Range()\n\t\t\tif start >= at {\n\t\t\t\tstart = math.Clamp(start+e.Delta, min, max)\n\t\t\t}\n\t\t\tif end > at {\n\t\t\t\tend = math.Clamp(end+e.Delta, min, max)\n\t\t\t}\n\t\t\tif end < start {\n\t\t\t\tend = start\n\t\t\t}\n\t\t\tl.spans[j] = interval.CreateIntData(start, end, s.Data())\n\t\t}\n\t}\n}\n\nfunc (l *CodeSyntaxLayer) Add(start, count int) {\n\tl.AddData(start, count, nil)\n}\n\nfunc (l *CodeSyntaxLayer) AddData(start, count int, data interface{}) {\n\tspan := interval.CreateIntData(start, start+count, data)\n\tinterval.Replace(&l.spans, span)\n}\n\nfunc (l *CodeSyntaxLayer) AddSpan(span interval.IntData) {\n\tinterval.Replace(&l.spans, span)\n}\n\nfunc (l *CodeSyntaxLayer) Spans() interval.IntDataList {\n\treturn l.spans\n}\n\nfunc (l *CodeSyntaxLayer) SpanAt(runeIndex int) *interval.IntData {\n\tidx := interval.IndexOf(&l.spans, uint64(runeIndex))\n\tif idx >= 0 {\n\t\treturn &l.spans[idx]\n\t} else {\n\t\treturn nil\n\t}\n}\n\nfunc (l *CodeSyntaxLayer) Color() *Color {\n\treturn l.color\n}\n\nfunc (l *CodeSyntaxLayer) ClearColor() {\n\tl.color = nil\n}\n\nfunc (l *CodeSyntaxLayer) SetColor(color Color) {\n\tl.color = &color\n}\n\nfunc (l *CodeSyntaxLayer) BackgroundColor() *Color {\n\treturn l.backgroundColor\n}\n\nfunc (l *CodeSyntaxLayer) ClearBackgroundColor() {\n\tl.backgroundColor = nil\n}\n\nfunc (l *CodeSyntaxLayer) SetBackgroundColor(color Color) {\n\tl.backgroundColor = &color\n}\n\nfunc (l *CodeSyntaxLayer) BorderColor() *Color {\n\treturn l.borderColor\n}\n\nfunc (l *CodeSyntaxLayer) ClearBorderColor() {\n\tl.borderColor = nil\n}\n\nfunc (l *CodeSyntaxLayer) SetBorderColor(color Color) {\n\tl.borderColor = &color\n}\n\nfunc (l *CodeSyntaxLayer) Data() interface{} {\n\treturn l.data\n}\n\nfunc (l *CodeSyntaxLayer) SetData(data interface{}) {\n\tl.data = data\n}\n\ntype CodeSyntaxLayers []*CodeSyntaxLayer\n\nfunc (l *CodeSyntaxLayers) Get(idx int) *CodeSyntaxLayer {\n\tif len(*l) <= idx {\n\t\told := *l\n\t\t*l = make(CodeSyntaxLayers, idx+1)\n\t\tcopy(*l, old)\n\t}\n\tlayer := (*l)[idx]\n\tif layer == nil {\n\t\tlayer = &CodeSyntaxLayer{}\n\t\t(*l)[idx] = layer\n\t}\n\treturn layer\n}\n\nfunc (l *CodeSyntaxLayers) Clear() {\n\t*l = CodeSyntaxLayers{}\n}\n"
        },
        {
          "name": "color.go",
          "type": "blob",
          "size": 2.345703125,
          "content": "// Copyright 2015 The Go Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage gxui\n\nimport \"github.com/google/gxui/math\"\n\nvar Transparent = Color{0.0, 0.0, 0.0, 0.0}\n\nvar Black = Color{0.0, 0.0, 0.0, 1.0}\n\nvar Red10 = Color{0.1, 0.0, 0.0, 1.0}\nvar Red20 = Color{0.2, 0.0, 0.0, 1.0}\nvar Red30 = Color{0.3, 0.0, 0.0, 1.0}\nvar Red40 = Color{0.4, 0.0, 0.0, 1.0}\nvar Red50 = Color{0.5, 0.0, 0.0, 1.0}\nvar Red60 = Color{0.6, 0.0, 0.0, 1.0}\nvar Red70 = Color{0.7, 0.0, 0.0, 1.0}\nvar Red80 = Color{0.8, 0.0, 0.0, 1.0}\nvar Red90 = Color{0.9, 0.0, 0.0, 1.0}\nvar Red = Color{1.0, 0.0, 0.0, 1.0}\n\nvar Green10 = Color{0.0, 0.1, 0.0, 1.0}\nvar Green20 = Color{0.0, 0.2, 0.0, 1.0}\nvar Green30 = Color{0.0, 0.3, 0.0, 1.0}\nvar Green40 = Color{0.0, 0.4, 0.0, 1.0}\nvar Green50 = Color{0.0, 0.5, 0.0, 1.0}\nvar Green60 = Color{0.0, 0.6, 0.0, 1.0}\nvar Green70 = Color{0.0, 0.7, 0.0, 1.0}\nvar Green80 = Color{0.0, 0.8, 0.0, 1.0}\nvar Green90 = Color{0.0, 0.9, 0.0, 1.0}\nvar Green = Color{0.0, 1.0, 0.0, 1.0}\n\nvar Blue10 = Color{0.0, 0.0, 0.1, 1.0}\nvar Blue20 = Color{0.0, 0.0, 0.2, 1.0}\nvar Blue30 = Color{0.0, 0.0, 0.3, 1.0}\nvar Blue40 = Color{0.0, 0.0, 0.4, 1.0}\nvar Blue50 = Color{0.0, 0.0, 0.5, 1.0}\nvar Blue60 = Color{0.0, 0.0, 0.6, 1.0}\nvar Blue70 = Color{0.0, 0.0, 0.7, 1.0}\nvar Blue80 = Color{0.0, 0.0, 0.8, 1.0}\nvar Blue90 = Color{0.0, 0.0, 0.9, 1.0}\nvar Blue = Color{0.0, 0.0, 1.0, 1.0}\n\nvar Gray10 = Color{0.1, 0.1, 0.1, 1.0}\nvar Gray15 = Color{0.15, 0.15, 0.15, 1.0}\nvar Gray20 = Color{0.2, 0.2, 0.2, 1.0}\nvar Gray30 = Color{0.3, 0.3, 0.3, 1.0}\nvar Gray40 = Color{0.4, 0.4, 0.4, 1.0}\nvar Gray50 = Color{0.5, 0.5, 0.5, 1.0}\nvar Gray60 = Color{0.6, 0.6, 0.6, 1.0}\nvar Gray70 = Color{0.7, 0.7, 0.7, 1.0}\nvar Gray80 = Color{0.8, 0.8, 0.8, 1.0}\nvar Gray90 = Color{0.9, 0.9, 0.9, 1.0}\nvar White = Color{1.0, 1.0, 1.0, 1.0}\n\nvar Yellow = Color{1.0, 1.0, 0.0, 1.0}\n\ntype Color struct {\n\tR, G, B, A float32\n}\n\nfunc ColorFromHex(hex uint32) Color {\n\treturn Color{\n\t\tA: float32((hex>>24)&0xFF) / 255.0,\n\t\tR: float32((hex>>16)&0xFF) / 255.0,\n\t\tG: float32((hex>>8)&0xFF) / 255.0,\n\t\tB: float32(hex&0xFF) / 255.0,\n\t}\n}\n\nfunc (c Color) MulRGB(s float32) Color {\n\treturn Color{c.R * s, c.G * s, c.B * s, c.A}\n}\n\nfunc (c Color) Saturate() Color {\n\treturn Color{math.Saturate(c.R), math.Saturate(c.G), math.Saturate(c.B), math.Saturate(c.A)}\n}\n"
        },
        {
          "name": "container.go",
          "type": "blob",
          "size": 1.9091796875,
          "content": "// Copyright 2015 The Go Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage gxui\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\n\t\"github.com/google/gxui/math\"\n)\n\ntype Child struct {\n\tControl Control\n\tOffset  math.Point\n}\n\ntype Parent interface {\n\tChildren() Children\n\tRelayout()\n\tRedraw()\n}\n\ntype Container interface {\n\tParent\n\tAddChild(child Control) *Child\n\tAddChildAt(index int, child Control) *Child\n\tRemoveChild(child Control)\n\tRemoveChildAt(index int)\n\tRemoveAll()\n\tPadding() math.Spacing\n\tSetPadding(math.Spacing)\n}\n\n// String returns a string describing the child type and bounds.\nfunc (c *Child) String() string {\n\treturn fmt.Sprintf(\"Type: %T, Bounds: %v\", c.Control, c.Bounds())\n}\n\n// Bounds returns the Child bounds relative to the parent.\nfunc (c *Child) Bounds() math.Rect {\n\treturn c.Control.Size().Rect().Offset(c.Offset)\n}\n\n// Layout sets the Child size and offset relative to the parent.\n// Layout should only be called by the Child's parent.\nfunc (c *Child) Layout(rect math.Rect) {\n\tc.Offset = rect.Min\n\tc.Control.SetSize(rect.Size())\n}\n\n// Children is a list of Child pointers.\ntype Children []*Child\n\n// String returns a string describing the child type and bounds.\nfunc (c Children) String() string {\n\ts := make([]string, len(c))\n\tfor i, c := range c {\n\t\ts[i] = fmt.Sprintf(\"%d: %s\", i, c.String())\n\t}\n\treturn strings.Join(s, \"\\n\")\n}\n\n// IndexOf returns and returns the index of the child control, or -1 if the\n// child is not in this Children list.\nfunc (c Children) IndexOf(control Control) int {\n\tfor i, child := range c {\n\t\tif child.Control == control {\n\t\t\treturn i\n\t\t}\n\t}\n\treturn -1\n}\n\n// Find returns and returns the Child pointer for the given Control, or nil\n// if the child is not in this Children list.\nfunc (c Children) Find(control Control) *Child {\n\tfor _, child := range c {\n\t\tif child.Control == control {\n\t\t\treturn child\n\t\t}\n\t}\n\treturn nil\n}\n"
        },
        {
          "name": "control.go",
          "type": "blob",
          "size": 6.9404296875,
          "content": "// Copyright 2015 The Go Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage gxui\n\nimport \"github.com/google/gxui/math\"\n\n// Control is the interface exposed by all UI control elements.\ntype Control interface {\n\t// Size returns the size of the control. If the control is not attached, then\n\t// the returned size is undefined.\n\tSize() math.Size\n\n\t// SetSize sets the size of the control to the specified value.\n\t// SetSize should only be called by the parent of the control during layout.\n\tSetSize(math.Size)\n\n\t// Draw draws the control's visual apperance into the returned, new canvas.\n\t// Draw is typically called by the parent of the control - calling Draw will\n\t// not issue a re-draw of an attached control.\n\tDraw() Canvas\n\n\t// Parent returns the parent of the control.\n\tParent() Parent\n\n\t// SetParent sets the parent of the control.\n\t// SetParent should only be called by the new parent of the control.\n\tSetParent(Parent)\n\n\t// Attached returns true if the control is directly or indirectly attached\n\t// to a window.\n\tAttached() bool\n\n\t// Attach is called when the control is directly or indirectly attached to a\n\t// window.\n\t// Attach should only be called by the parent of the control.\n\tAttach()\n\n\t// Detach is called when the control is directly or indirectly detached from a\n\t// window.\n\t// Detach should only be called by the parent of the control.\n\tDetach()\n\n\t// DesiredSize returns the desired size of the control based on the min and\n\t// max size limits. The parent control may ignore the desired size.\n\tDesiredSize(min, max math.Size) math.Size\n\n\t// Margin returns the desired spacing between sibling controls.\n\tMargin() math.Spacing\n\n\t// SetMargin set the desired spacing between sibling controls, issuing a\n\t// relayout if the margin has changed.\n\tSetMargin(math.Spacing)\n\n\t// IsVisible returns true if the control is visible.\n\tIsVisible() bool\n\n\t// SetVisible sets the visibility of the control.\n\tSetVisible(bool)\n\n\t// ContainsPoint returns true if the specified local-space point is considered\n\t// within the control.\n\tContainsPoint(math.Point) bool\n\n\t// IsMouseOver returns true if the mouse cursor was last reported within the\n\t// control.\n\tIsMouseOver() bool\n\n\t// IsMouseDown returns true if button was last reported pressed on the\n\t// control.\n\tIsMouseDown(button MouseButton) bool\n\n\t// Click is called when the mouse is pressed and released on the control.\n\t// If Click returns true, then the click event is consumed by the control,\n\t// otherwise the next control below the should be considered for the click\n\t// event.\n\tClick(MouseEvent) (consume bool)\n\n\t// DoubleClick is called when the mouse is double-clicked on the control.\n\t// If DoubleClick returns true, then the double-click event is consumed by the\n\t// control, otherwise the next control below the should be considered for the\n\t// double-click event.\n\tDoubleClick(MouseEvent) (consume bool)\n\n\t// KeyPress is called when a keyboard key is pressed while the control (or\n\t// non-consuming child) has focus. If KeyPress returns true, then the\n\t// key-press event is consumed by the control, otherwise the parent control\n\t// should be considered for the key-press event.\n\tKeyPress(KeyboardEvent) (consume bool)\n\n\t// KeyStroke is called when a key-storke is made while the control (or\n\t// non-consuming child) has focus. If KeyStroke returns true, then the\n\t// key-stroke event is consumed by the control, otherwise the parent control\n\t// should be considered for the key-stroke event.\n\tKeyStroke(KeyStrokeEvent) (consume bool)\n\n\t// MouseScroll is called when a mouse scroll is made while the control (or\n\t// non-consuming child) has focus. If MouseScroll returns true, then the\n\t// mouse-scroll event is consumed by the control, otherwise the parent control\n\t// should be considered for the key-stroke event.\n\tMouseScroll(MouseEvent) (consume bool)\n\n\t// MouseMove is called when the mouse cursor moves over the control.\n\tMouseMove(MouseEvent)\n\n\t// MouseEnter is called when the mouse cursor transitions from outside to\n\t// inside the bounds of the control.\n\tMouseEnter(MouseEvent)\n\n\t// MouseExit is called when the mouse cursor transitions from inside to\n\t// outside the bounds of the control.\n\tMouseExit(MouseEvent)\n\n\t// MouseDown is called when a mouse button is pressed while the mouse cursor\n\t// is over the control.\n\tMouseDown(MouseEvent)\n\n\t// MouseUp is called when a mouse button is released while the mouse cursor\n\t// is over the control.\n\tMouseUp(MouseEvent)\n\n\t// KeyDown is called when a keyboard button is pressed while the control (or\n\t// child control) has focus.\n\tKeyDown(KeyboardEvent)\n\n\t// KeyUp is called when a keyboard button is released while the control (or\n\t// child control) has focus.\n\tKeyUp(KeyboardEvent)\n\n\t// KeyRepeat is called when a keyboard button held long enough for a\n\t// repeat-key event while the control (or child control) has focus.\n\tKeyRepeat(KeyboardEvent)\n\n\t// OnAttach subscribes f to be called whenever the control is attached.\n\tOnAttach(f func()) EventSubscription\n\n\t// OnDetach subscribes f to be called whenever the control is detached.\n\tOnDetach(f func()) EventSubscription\n\n\t// OnKeyPress subscribes f to be called whenever the control receives a\n\t// key-press event.\n\tOnKeyPress(f func(KeyboardEvent)) EventSubscription\n\n\t// OnKeyStroke subscribes f to be called whenever the control receives a\n\t// key-stroke event.\n\tOnKeyStroke(f func(KeyStrokeEvent)) EventSubscription\n\n\t// OnClick subscribes f to be called whenever the control receives a click\n\t// event.\n\tOnClick(f func(MouseEvent)) EventSubscription\n\n\t// OnDoubleClick subscribes f to be called whenever the control receives a\n\t// double-click event.\n\tOnDoubleClick(f func(MouseEvent)) EventSubscription\n\n\t// OnMouseMove subscribes f to be called whenever the control receives a\n\t// mouse-move event.\n\tOnMouseMove(f func(MouseEvent)) EventSubscription\n\n\t// OnMouseEnter subscribes f to be called whenever the control receives a\n\t// mouse-enter event.\n\tOnMouseEnter(f func(MouseEvent)) EventSubscription\n\n\t// OnMouseExit subscribes f to be called whenever the control receives a\n\t// mouse-exit event.\n\tOnMouseExit(f func(MouseEvent)) EventSubscription\n\n\t// OnMouseDown subscribes f to be called whenever the control receives a\n\t// mouse-down event.\n\tOnMouseDown(f func(MouseEvent)) EventSubscription\n\n\t// OnMouseUp subscribes f to be called whenever the control receives a\n\t// mouse-up event.\n\tOnMouseUp(f func(MouseEvent)) EventSubscription\n\n\t// OnMouseScroll subscribes f to be called whenever the control receives a\n\t// mouse-scroll event.\n\tOnMouseScroll(f func(MouseEvent)) EventSubscription\n\n\t// OnKeyDown subscribes f to be called whenever the control receives a\n\t// key-down event.\n\tOnKeyDown(f func(KeyboardEvent)) EventSubscription\n\n\t// OnKeyUp subscribes f to be called whenever the control receives a\n\t// key-up event.\n\tOnKeyUp(f func(KeyboardEvent)) EventSubscription\n\n\t// OnKeyRepeat subscribes f to be called whenever the control receives a\n\t// key-repeat event.\n\tOnKeyRepeat(f func(KeyboardEvent)) EventSubscription\n}\n"
        },
        {
          "name": "control_list.go",
          "type": "blob",
          "size": 0.3173828125,
          "content": "// Copyright 2015 The Go Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage gxui\n\ntype ControlList []Control\n\nfunc (l ControlList) Contains(c Control) bool {\n\tfor _, i := range l {\n\t\tif i == c {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n"
        },
        {
          "name": "debug.go",
          "type": "blob",
          "size": 1.51171875,
          "content": "// Copyright 2015 The Go Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage gxui\n\nimport (\n\t\"fmt\"\n\t\"github.com/google/gxui/math\"\n\t\"reflect\"\n\t\"runtime\"\n)\n\nfunc indent(depth int) string {\n\ts := \"\"\n\tfor i := 0; i < depth; i++ {\n\t\ts += \"   |\"\n\t}\n\treturn s\n}\n\nfunc dump(c interface{}, depth int) string {\n\ts := \"\"\n\tswitch t := c.(type) {\n\tcase Control:\n\t\ts += fmt.Sprintf(\"(%p) %T Size: %+v Margin: %+v \\n\", &t, t, t.Size(), t.Margin())\n\tdefault:\n\t\ts += fmt.Sprintf(\"%T\\n\", t)\n\t}\n\tswitch t := c.(type) {\n\tcase Container:\n\t\tfor i, c := range t.Children() {\n\t\t\ts += fmt.Sprintf(\"%s--- Child %d: \", indent(depth), i)\n\t\t\ts += dump(c.Control, depth+1)\n\t\t}\n\t}\n\treturn s\n}\n\nfunc Dump(c interface{}) {\n\tfmt.Printf(\"%s\\n\", dump(c, 0))\n}\n\nfunc FunctionName(i interface{}) string {\n\treturn runtime.FuncForPC(reflect.ValueOf(i).Pointer()).Name()\n}\n\nfunc BreadcrumbsAt(p Container, pnt math.Point) string {\n\ts := reflect.TypeOf(p).String()\n\tfor _, c := range p.Children() {\n\t\tb := c.Control.Size().Rect().Offset(c.Offset)\n\t\tif b.Contains(pnt) {\n\t\t\tswitch t := c.Control.(type) {\n\t\t\tcase Container:\n\t\t\t\treturn s + \" > \" + BreadcrumbsAt(t, pnt.Sub(c.Offset))\n\t\t\tdefault:\n\t\t\t\treturn s + \" > \" + reflect.TypeOf(c.Control).String()\n\t\t\t}\n\t\t}\n\t}\n\treturn s\n}\n\nfunc Path(p interface{}) string {\n\tif p == nil {\n\t\treturn \"nil\"\n\t}\n\n\ts := reflect.TypeOf(p).String()\n\n\tif c, _ := p.(Control); c != nil {\n\t\tif c.Parent() != nil {\n\t\t\treturn Path(c.Parent()) + \" > \" + s\n\t\t}\n\t}\n\n\treturn s\n}\n"
        },
        {
          "name": "default_adapter.go",
          "type": "blob",
          "size": 2.759765625,
          "content": "// Copyright 2015 The Go Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage gxui\n\nimport (\n\t\"fmt\"\n\t\"reflect\"\n\n\t\"github.com/google/gxui/math\"\n)\n\ntype Viewer interface {\n\tView(t Theme) Control\n}\n\ntype Stringer interface {\n\tString() string\n}\n\ntype DefaultAdapter struct {\n\tAdapterBase\n\titems       reflect.Value\n\titemToIndex map[AdapterItem]int\n\tsize        math.Size\n\tstyleLabel  func(Theme, Label)\n}\n\nfunc CreateDefaultAdapter() *DefaultAdapter {\n\tl := &DefaultAdapter{\n\t\tsize: math.Size{W: 200, H: 16},\n\t}\n\treturn l\n}\n\nfunc (a *DefaultAdapter) SetSizeAsLargest(theme Theme) {\n\ts := math.Size{}\n\tfont := theme.DefaultFont()\n\tfor i := 0; i < a.Count(); i++ {\n\t\tswitch t := a.ItemAt(i).(type) {\n\t\tcase Viewer:\n\t\t\ts = s.Max(t.View(theme).DesiredSize(math.ZeroSize, math.MaxSize))\n\n\t\tcase Stringer:\n\t\t\ts = s.Max(font.Measure(&TextBlock{\n\t\t\t\tRunes: []rune(t.String()),\n\t\t\t}))\n\n\t\tdefault:\n\t\t\ts = s.Max(font.Measure(&TextBlock{\n\t\t\t\tRunes: []rune(fmt.Sprintf(\"%+v\", t)),\n\t\t\t}))\n\t\t}\n\t}\n\ta.SetSize(s)\n}\n\nfunc (a *DefaultAdapter) SetStyleLabel(f func(Theme, Label)) {\n\ta.styleLabel = f\n\ta.DataChanged(true)\n}\n\nfunc (a *DefaultAdapter) Count() int {\n\tif !a.items.IsValid() {\n\t\treturn 0\n\t}\n\n\tswitch a.items.Kind() {\n\tcase reflect.Slice, reflect.Array:\n\t\treturn a.items.Len()\n\n\tdefault:\n\t\treturn 1\n\t}\n}\n\nfunc (a *DefaultAdapter) ItemAt(index int) AdapterItem {\n\tcount := a.Count()\n\tif index < 0 || index >= count {\n\t\tpanic(fmt.Errorf(\"ItemAt index %d is out of bounds [%d, %d]\",\n\t\t\tindex, 0, count-1))\n\t}\n\n\tswitch a.items.Kind() {\n\tcase reflect.Slice, reflect.Array:\n\t\treturn a.items.Index(index).Interface()\n\n\tdefault:\n\t\treturn a.items.Interface()\n\t}\n\n}\n\nfunc (a *DefaultAdapter) ItemIndex(item AdapterItem) int {\n\treturn a.itemToIndex[item]\n}\n\nfunc (a *DefaultAdapter) Size(theme Theme) math.Size {\n\treturn a.size\n}\n\nfunc (a *DefaultAdapter) SetSize(s math.Size) {\n\ta.size = s\n\ta.DataChanged(true)\n}\n\nfunc (a *DefaultAdapter) Create(theme Theme, index int) Control {\n\tswitch t := a.ItemAt(index).(type) {\n\tcase Viewer:\n\t\treturn t.View(theme)\n\n\tcase Stringer:\n\t\tl := theme.CreateLabel()\n\t\tl.SetMargin(math.ZeroSpacing)\n\t\tl.SetMultiline(false)\n\t\tl.SetText(t.String())\n\t\tif a.styleLabel != nil {\n\t\t\ta.styleLabel(theme, l)\n\t\t}\n\t\treturn l\n\n\tdefault:\n\t\tl := theme.CreateLabel()\n\t\tl.SetMargin(math.ZeroSpacing)\n\t\tl.SetMultiline(false)\n\t\tl.SetText(fmt.Sprintf(\"%+v\", t))\n\t\tif a.styleLabel != nil {\n\t\t\ta.styleLabel(theme, l)\n\t\t}\n\t\treturn l\n\t}\n}\n\nfunc (a *DefaultAdapter) Items() interface{} {\n\treturn a.items.Interface()\n}\n\nfunc (a *DefaultAdapter) SetItems(items interface{}) {\n\ta.items = reflect.ValueOf(items)\n\ta.itemToIndex = make(map[AdapterItem]int)\n\tfor idx := 0; idx < a.Count(); idx++ {\n\t\ta.itemToIndex[a.ItemAt(idx)] = idx\n\t}\n\ta.DataReplaced()\n}\n"
        },
        {
          "name": "direction.go",
          "type": "blob",
          "size": 1.0244140625,
          "content": "// Copyright 2015 The Go Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage gxui\n\nimport \"fmt\"\n\ntype Direction int\n\nconst (\n\tTopToBottom Direction = iota\n\tLeftToRight\n\tBottomToTop\n\tRightToLeft\n)\n\nfunc (d Direction) LeftToRight() bool { return d == LeftToRight }\nfunc (d Direction) RightToLeft() bool { return d == RightToLeft }\nfunc (d Direction) TopToBottom() bool { return d == TopToBottom }\nfunc (d Direction) BottomToTop() bool { return d == BottomToTop }\n\nfunc (d Direction) Flip() Direction {\n\tswitch d {\n\tcase TopToBottom:\n\t\treturn BottomToTop\n\tcase LeftToRight:\n\t\treturn RightToLeft\n\tcase BottomToTop:\n\t\treturn TopToBottom\n\tcase RightToLeft:\n\t\treturn LeftToRight\n\tdefault:\n\t\tpanic(fmt.Errorf(\"Unknown direction %d\", d))\n\t}\n}\n\nfunc (d Direction) Orientation() Orientation {\n\tswitch d {\n\tcase TopToBottom, BottomToTop:\n\t\treturn Vertical\n\tcase LeftToRight, RightToLeft:\n\t\treturn Horizontal\n\tdefault:\n\t\tpanic(fmt.Errorf(\"Unknown direction %d\", d))\n\t}\n}\n"
        },
        {
          "name": "driver.go",
          "type": "blob",
          "size": 1.564453125,
          "content": "// Copyright 2015 The Go Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage gxui\n\nimport (\n\t\"image\"\n\n\t\"github.com/google/gxui/math\"\n)\n\ntype Driver interface {\n\t// Call queues f to be run on the UI go-routine, returning before f may have\n\t// been called. Call returns false if the driver has been terminated, in which\n\t// case f may not be called.\n\tCall(f func()) bool\n\n\t// CallSync queues and then blocks for f to be run on the UI go-routine.\n\t// Call returns false if the driver has been terminated, in which case f may\n\t// not be called.\n\tCallSync(f func()) bool\n\n\tTerminate()\n\tSetClipboard(str string)\n\tGetClipboard() (string, error)\n\n\t// CreateFont loads a font from the provided TrueType bytes.\n\tCreateFont(data []byte, size int) (Font, error)\n\n\t// CreateWindowedViewport creates a new windowed Viewport with the specified\n\t// width and height in device independent pixels.\n\tCreateWindowedViewport(width, height int, name string) Viewport\n\n\t// CreateFullscreenViewport creates a new fullscreen Viewport with the\n\t// specified width and height in device independent pixels. If width or\n\t// height is 0, then the viewport adopts the current screen resolution.\n\tCreateFullscreenViewport(width, height int, name string) Viewport\n\n\tCreateCanvas(math.Size) Canvas\n\tCreateTexture(img image.Image, pixelsPerDip float32) Texture\n\n\t// Debug function used to verify that the caller is executing on the UI\n\t// go-routine. If the caller is not on the UI go-routine then the function\n\t// panics.\n\tAssertUIGoroutine()\n}\n"
        },
        {
          "name": "drivers",
          "type": "tree",
          "content": null
        },
        {
          "name": "drop_down_list.go",
          "type": "blob",
          "size": 0.591796875,
          "content": "// Copyright 2015 The Go Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage gxui\n\ntype DropDownList interface {\n\tFocusable\n\tContainer\n\tSetBubbleOverlay(BubbleOverlay)\n\tBubbleOverlay() BubbleOverlay\n\tAdapter() ListAdapter\n\tSetAdapter(ListAdapter)\n\tBorderPen() Pen\n\tSetBorderPen(Pen)\n\tBackgroundBrush() Brush\n\tSetBackgroundBrush(Brush)\n\tSelected() AdapterItem\n\tSelect(AdapterItem)\n\tOnSelectionChanged(func(AdapterItem)) EventSubscription\n\tOnShowList(func()) EventSubscription\n\tOnHideList(func()) EventSubscription\n}\n"
        },
        {
          "name": "event.go",
          "type": "blob",
          "size": 0.3623046875,
          "content": "// Copyright 2015 The Go Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage gxui\n\nimport (\n\t\"reflect\"\n)\n\ntype EventSubscription interface {\n\tUnlisten()\n}\n\ntype Event interface {\n\tFire(args ...interface{})\n\tListen(interface{}) EventSubscription\n\tParameterTypes() []reflect.Type\n}\n"
        },
        {
          "name": "event_base.go",
          "type": "blob",
          "size": 4.5986328125,
          "content": "// Copyright 2015 The Go Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage gxui\n\nimport (\n\t\"fmt\"\n\t\"reflect\"\n)\n\ntype EventListener struct {\n\tId       int\n\tFunction reflect.Value\n}\n\ntype eventBaseSubscription struct {\n\tevent *EventBase\n\tid    int\n}\n\nfunc (s *eventBaseSubscription) Unlisten() {\n\tif s.event != nil {\n\t\ts.event.unlisten(s.id)\n\t\ts.event = nil\n\t}\n}\n\ntype EventBase struct {\n\tunlisten   func(id int)\n\tparamTypes []reflect.Type\n\tisVariadic bool\n\tlisteners  []EventListener\n\tnextId     int\n}\n\nfunc (e *EventBase) init(signature interface{}) {\n\te.unlisten = func(id int) {\n\t\tfor i, l := range e.listeners {\n\t\t\tif l.Id == id {\n\t\t\t\tcopy(e.listeners[i:], e.listeners[i+1:])\n\t\t\t\te.listeners = e.listeners[:len(e.listeners)-1]\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t\tpanic(fmt.Errorf(\"Listener not added to event\"))\n\t}\n\n\tf := reflect.TypeOf(signature)\n\te.paramTypes = make([]reflect.Type, f.NumIn())\n\tfor i, _ := range e.paramTypes {\n\t\te.paramTypes[i] = f.In(i)\n\t}\n\te.isVariadic = f.IsVariadic()\n}\n\nfunc (e *EventBase) String() string {\n\ts := \"Event<\"\n\tfor i, t := range e.paramTypes {\n\t\tif i > 0 {\n\t\t\ts += \", \"\n\t\t}\n\t\tif e.isVariadic && i == len(e.paramTypes)-1 {\n\n\t\t\ts += \"...\"\n\t\t}\n\t\ts += t.String()\n\t}\n\treturn s + \">\"\n}\n\nfunc assignable(to, from reflect.Type) bool {\n\tif from == nil {\n\t\tswitch to.Kind() {\n\t\tcase reflect.Chan, reflect.Interface, reflect.Map, reflect.Ptr, reflect.Slice, reflect.Func:\n\t\t\treturn true\n\t\t}\n\t\treturn false\n\t}\n\treturn from.AssignableTo(to)\n}\n\nfunc (e *EventBase) VerifySignature(argTys []reflect.Type, isVariadic bool) {\n\tparamTypes := e.paramTypes\n\tif isVariadic {\n\t\tif len(argTys) < len(paramTypes)-1 {\n\t\t\tpanic(fmt.Errorf(\"%v.Fire(%v) Too few arguments. Must have at least %v, but got %v\",\n\t\t\t\te.String(), argTys, len(paramTypes), len(argTys)))\n\t\t}\n\t\tfor i, argTy := range argTys {\n\t\t\tvarIdx := len(paramTypes) - 1\n\t\t\tif i >= varIdx {\n\t\t\t\tparamTy := paramTypes[varIdx].Elem()\n\t\t\t\tif !assignable(paramTy, argTy) {\n\t\t\t\t\tpanic(fmt.Errorf(\"%v.Fire(%v) Variadic argument %v for was of the wrong type. Got: %v, Expected: %v\",\n\t\t\t\t\t\te.String(), argTys, i-varIdx, argTy, paramTy))\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tparamTy := paramTypes[i]\n\t\t\t\tif !assignable(paramTy, argTy) {\n\t\t\t\t\tpanic(fmt.Errorf(\"%v.Fire(%v) Argument %v for was of the wrong type. Got: %v, Expected: %v\",\n\t\t\t\t\t\te.String(), argTys, i, argTy, paramTy))\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} else {\n\t\tif len(paramTypes) != len(argTys) {\n\t\t\tpanic(fmt.Errorf(\"%v.Fire(%v) Argument count mismatch. Expected %d, got %d\",\n\t\t\t\te.String(), argTys, len(paramTypes), len(argTys)))\n\t\t}\n\t\tfor i, argTy := range argTys {\n\t\t\tparamTy := paramTypes[i]\n\t\t\tif !assignable(paramTy, argTy) {\n\t\t\t\tpanic(fmt.Errorf(\"%v.Fire(%v) Argument %v for was of the wrong type. Got: %v, Expected: %v\",\n\t\t\t\t\te.String(), argTys, i, argTy, paramTy))\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc (e *EventBase) VerifyArguments(args []interface{}) {\n\targTys := make([]reflect.Type, len(args))\n\tfor i, arg := range args {\n\t\targTys[i] = reflect.TypeOf(arg)\n\t}\n\te.VerifySignature(argTys, e.isVariadic)\n}\n\nfunc (e *EventBase) InvokeListeners(args []interface{}) {\n\targVals := make([]reflect.Value, len(args))\n\tfor i, arg := range args {\n\t\tif arg == nil {\n\t\t\targVals[i] = reflect.New(e.paramTypes[i]).Elem()\n\t\t} else {\n\t\t\targVals[i] = reflect.ValueOf(arg)\n\t\t}\n\t}\n\n\tfor _, l := range e.listeners {\n\t\tl.Function.Call(argVals)\n\t}\n}\n\n// Event compliance\nfunc (e *EventBase) Listen(listener interface{}) EventSubscription {\n\tvar paramTypes []reflect.Type\n\tvar function reflect.Value\n\n\treflectTy := reflect.TypeOf(listener)\n\tif reflectTy.Kind() == reflect.Func {\n\t\tparamTypes = make([]reflect.Type, reflectTy.NumIn())\n\t\tfor i, _ := range paramTypes {\n\t\t\tparamTypes[i] = reflectTy.In(i)\n\t\t}\n\t\tfunction = reflect.ValueOf(listener)\n\t} else {\n\t\tswitch ty := listener.(type) {\n\t\tcase Event:\n\t\t\tparamTypes = ty.ParameterTypes()\n\t\t\tfunction = reflect.ValueOf(listener).MethodByName(\"Fire\")\n\t\tdefault:\n\t\t\tpanic(fmt.Errorf(\"Listener cannot be of type %v\", reflectTy.String()))\n\t\t}\n\t}\n\n\tif function.IsNil() {\n\t\tpanic(\"Listener function is nil\")\n\t}\n\n\tfor i, listenerTy := range paramTypes {\n\t\tif !listenerTy.AssignableTo(e.paramTypes[i]) {\n\t\t\tpanic(fmt.Errorf(\"%v.Listen(%v) Listener parameter %v for was of the wrong type. Got: %v, Expected: %v\",\n\t\t\t\te.String(), listener, i, listenerTy, e.paramTypes[i]))\n\t\t}\n\t}\n\n\tid := e.nextId\n\te.nextId++\n\n\te.listeners = append(e.listeners, EventListener{\n\t\tId:       id,\n\t\tFunction: function,\n\t})\n\n\treturn &eventBaseSubscription{e, id}\n}\n\nfunc (e *EventBase) Fire(args ...interface{}) {\n\te.VerifyArguments(args)\n\te.InvokeListeners(args)\n}\n\nfunc (e *EventBase) ParameterTypes() []reflect.Type {\n\treturn e.paramTypes\n}\n"
        },
        {
          "name": "event_test.go",
          "type": "blob",
          "size": 3.96875,
          "content": "// Copyright 2015 The Go Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage gxui\n\nimport test \"github.com/google/gxui/testing\"\nimport \"testing\"\n\nfunc TestEventNoArgs(t *testing.T) {\n\te := CreateEvent(func() {})\n\n\tfired := false\n\te.Listen(func() { fired = true })\n\ttest.AssertEquals(t, false, fired)\n\n\te.Fire()\n\ttest.AssertEquals(t, true, fired)\n}\n\ntype TestEvent func(i int, s string, b bool)\n\nfunc TestEventExactArgs(t *testing.T) {\n\te := CreateEvent(func(int, string, bool, int, int, bool) {})\n\n\tfired := false\n\te.Listen(func(i1 int, s string, b1 bool, i2, i3 int, b2 bool) {\n\t\ttest.AssertEquals(t, 1, i1)\n\t\ttest.AssertEquals(t, \"hello\", s)\n\t\ttest.AssertEquals(t, false, b1)\n\t\ttest.AssertEquals(t, 2, i2)\n\t\ttest.AssertEquals(t, 3, i3)\n\t\ttest.AssertEquals(t, true, b2)\n\t\tfired = true\n\t})\n\ttest.AssertEquals(t, false, fired)\n\n\te.Fire(1, \"hello\", false, 2, 3, true)\n\ttest.AssertEquals(t, true, fired)\n}\n\nfunc TestEventNilArgs(t *testing.T) {\n\te := CreateEvent(func(chan int, func(), interface{}, map[int]int, *int, []int) {})\n\n\tfired := false\n\te.Listen(func(c chan int, f func(), i interface{}, m map[int]int, p *int, s []int) {\n\t\ttest.AssertEquals(t, true, nil == c)\n\t\ttest.AssertEquals(t, true, nil == f)\n\t\ttest.AssertEquals(t, true, nil == i)\n\t\ttest.AssertEquals(t, true, nil == m)\n\t\ttest.AssertEquals(t, true, nil == p)\n\t\ttest.AssertEquals(t, true, nil == s)\n\t\tfired = true\n\t})\n\ttest.AssertEquals(t, false, fired)\n\n\te.Fire(nil, nil, nil, nil, nil, nil)\n\ttest.AssertEquals(t, true, fired)\n}\n\nfunc TestEventMixedVariadic(t *testing.T) {\n\te := CreateEvent(func(int, int, ...int) {})\n\n\tfired := false\n\te.Listen(func(a, b int, cde ...int) {\n\t\ttest.AssertEquals(t, 3, len(cde))\n\n\t\ttest.AssertEquals(t, 0, a)\n\t\ttest.AssertEquals(t, 1, b)\n\t\ttest.AssertEquals(t, 2, cde[0])\n\t\ttest.AssertEquals(t, 3, cde[1])\n\t\ttest.AssertEquals(t, 4, cde[2])\n\t\tfired = true\n\t})\n\te.Fire(0, 1, 2, 3, 4)\n\ttest.AssertEquals(t, true, fired)\n}\n\nfunc TestEventSingleVariadic(t *testing.T) {\n\te := CreateEvent(func(...int) {})\n\n\tfired := false\n\te.Listen(func(va ...int) {\n\t\ttest.AssertEquals(t, 3, len(va))\n\n\t\ttest.AssertEquals(t, 2, va[0])\n\t\ttest.AssertEquals(t, 3, va[1])\n\t\ttest.AssertEquals(t, 4, va[2])\n\t\tfired = true\n\t})\n\te.Fire(2, 3, 4)\n\ttest.AssertEquals(t, true, fired)\n}\n\nfunc TestEventEmptyVariadic(t *testing.T) {\n\te := CreateEvent(func(...int) {})\n\n\tfired := false\n\te.Listen(func(va ...int) {\n\t\ttest.AssertEquals(t, 0, len(va))\n\t\tfired = true\n\t})\n\te.Fire()\n\ttest.AssertEquals(t, true, fired)\n}\n\nfunc TestEventChaining(t *testing.T) {\n\te1 := CreateEvent(func(int, string, bool, int, int, bool) {})\n\te2 := CreateEvent(func(int, string, bool, int, int, bool) {})\n\n\te1.Listen(e2)\n\n\tfired := false\n\te2.Listen(func(i1 int, s string, b1 bool, i2, i3 int, b2 bool) {\n\t\ttest.AssertEquals(t, 1, i1)\n\t\ttest.AssertEquals(t, \"hello\", s)\n\t\ttest.AssertEquals(t, false, b1)\n\t\ttest.AssertEquals(t, 2, i2)\n\t\ttest.AssertEquals(t, 3, i3)\n\t\ttest.AssertEquals(t, true, b2)\n\t\tfired = true\n\t})\n\ttest.AssertEquals(t, false, fired)\n\n\te1.Fire(1, \"hello\", false, 2, 3, true)\n\ttest.AssertEquals(t, true, fired)\n}\n\nfunc TestEventUnlisten(t *testing.T) {\n\teI := CreateEvent(func() {})\n\teJ := CreateEvent(func() {})\n\teK := CreateEvent(func() {})\n\n\te := CreateEvent(func() {})\n\te.Listen(eI)\n\te.Listen(eJ)\n\te.Listen(eK)\n\n\ti, j, k := 0, 0, 0\n\tsubI := eI.Listen(func() { i++ })\n\tsubJ := eJ.Listen(func() { j++ })\n\tsubK := eK.Listen(func() { k++ })\n\n\ttest.AssertEquals(t, 0, i)\n\ttest.AssertEquals(t, 0, j)\n\ttest.AssertEquals(t, 0, k)\n\n\te.Fire()\n\ttest.AssertEquals(t, 1, i)\n\ttest.AssertEquals(t, 1, j)\n\ttest.AssertEquals(t, 1, k)\n\n\tsubJ.Unlisten()\n\n\te.Fire()\n\ttest.AssertEquals(t, 2, i)\n\ttest.AssertEquals(t, 1, j)\n\ttest.AssertEquals(t, 2, k)\n\n\tsubK.Unlisten()\n\n\te.Fire()\n\ttest.AssertEquals(t, 3, i)\n\ttest.AssertEquals(t, 1, j)\n\ttest.AssertEquals(t, 2, k)\n\n\tsubI.Unlisten()\n\n\te.Fire()\n\ttest.AssertEquals(t, 3, i)\n\ttest.AssertEquals(t, 1, j)\n\ttest.AssertEquals(t, 2, k)\n}\n\n// TODO: Add tests for early signature mismatch failures\n"
        },
        {
          "name": "filtered_list_adapter.go",
          "type": "blob",
          "size": 1.5654296875,
          "content": "// Copyright 2015 The Go Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage gxui\n\nimport (\n\t\"sort\"\n\t\"strings\"\n)\n\ntype FilteredListItem struct {\n\tName string\n\tData interface{}\n}\n\ntype FilteredListAdapter struct {\n\tDefaultAdapter\n\titems []FilteredListItem\n}\n\nfunc (a *FilteredListAdapter) SetItems(items []FilteredListItem) {\n\t// Clone, as the order can be mutated\n\ta.items = append([]FilteredListItem{}, items...)\n\ta.DefaultAdapter.SetItems(a.items)\n}\n\nfunc (a *FilteredListAdapter) Sort(partial string) {\n\tpartialLower := strings.ToLower(partial)\n\tsorter := flaSorter{items: a.items, scores: make([]int, len(a.items))}\n\tfor i, s := range a.items {\n\t\tsorter.scores[i] = flaScore(s.Name, strings.ToLower(s.Name), partial, partialLower)\n\t}\n\tsort.Sort(sorter)\n\ta.DefaultAdapter.SetItems(a.items)\n}\n\ntype flaSorter struct {\n\titems  []FilteredListItem\n\tscores []int\n}\n\nfunc (s flaSorter) Len() int {\n\treturn len(s.items)\n}\n\nfunc (s flaSorter) Less(i, j int) bool {\n\treturn s.scores[i] > s.scores[j]\n}\n\nfunc (s flaSorter) Swap(i, j int) {\n\titems, scores := s.items, s.scores\n\titems[i], items[j] = items[j], items[i]\n\tscores[i], scores[j] = scores[j], scores[i]\n}\n\nfunc flaScore(str, strLower, partial, partialLower string) int {\n\tl := len(partial)\n\tfor i := l; i > 0; i-- {\n\t\tc := 0\n\t\tif strings.Contains(str, partial[:i]) {\n\t\t\tc = i*i + 1\n\t\t} else if strings.Contains(strLower, partialLower[:i]) {\n\t\t\tc = i * i\n\t\t}\n\n\t\tif c > 0 {\n\t\t\treturn c + flaScore(str, strLower, partial[i:], partialLower[i:])\n\t\t}\n\t}\n\treturn 0\n}\n"
        },
        {
          "name": "filtered_list_adapter_test.go",
          "type": "blob",
          "size": 0.5029296875,
          "content": "// Copyright 2015 The Go Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage gxui\n\nimport test \"github.com/google/gxui/testing\"\nimport (\n\t\"strings\"\n\t\"testing\"\n)\n\nfunc calcScore(str, partial string) int {\n\treturn flaScore(str, strings.ToLower(str), partial, strings.ToLower(partial))\n}\n\nfunc TestFilteredListAdapterScore(t *testing.T) {\n\ttest.AssertEquals(t, (3*3)+(2*2+1)+(3*3+1), calcScore(\"a_Mix_Of_Words\", \"mixOfrds\"))\n}\n"
        },
        {
          "name": "focus_controller.go",
          "type": "blob",
          "size": 2.4755859375,
          "content": "// Copyright 2015 The Go Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage gxui\n\ntype FocusController struct {\n\twindow             Window\n\tfocus              Focusable\n\tsetFocusCount      int\n\tdetachSubscription EventSubscription\n}\n\nfunc CreateFocusController(window Window) *FocusController {\n\treturn &FocusController{\n\t\twindow: window,\n\t}\n}\n\nfunc (c *FocusController) SetFocus(f Focusable) {\n\tc.setFocusCount++\n\tif c.focus == f {\n\t\treturn\n\t}\n\tif c.focus != nil {\n\t\to := c.focus\n\t\tc.focus = nil\n\t\tc.detachSubscription.Unlisten()\n\t\to.LostFocus()\n\t\tif c.focus != nil {\n\t\t\treturn // Something in LostFocus() called SetFocus(). Respect their call.\n\t\t}\n\t}\n\tc.focus = f\n\tif c.focus != nil {\n\t\tc.detachSubscription = c.focus.OnDetach(func() { c.SetFocus(nil) })\n\t\tc.focus.GainedFocus()\n\t}\n}\n\nfunc (c *FocusController) SetFocusCount() int {\n\treturn c.setFocusCount\n}\n\nfunc (c *FocusController) Focus() Focusable {\n\treturn c.focus\n}\n\nfunc (c *FocusController) FocusNext() {\n\tc.SetFocus(c.NextFocusable(c.focus, true))\n}\n\nfunc (c *FocusController) FocusPrev() {\n\tc.SetFocus(c.NextFocusable(c.focus, false))\n}\n\nfunc (c *FocusController) NextFocusable(after Control, forwards bool) Focusable {\n\tcontainer, _ := after.(Container)\n\tif container != nil {\n\t\tf := c.NextChildFocusable(container, nil, forwards)\n\t\tif f != nil {\n\t\t\treturn f\n\t\t}\n\t}\n\n\tfor after != nil {\n\t\tparent := after.Parent()\n\t\tif parent != nil {\n\t\t\tf := c.NextChildFocusable(parent, after, forwards)\n\t\t\tif f != nil {\n\t\t\t\treturn f\n\t\t\t}\n\t\t}\n\t\tafter, _ = parent.(Control)\n\t}\n\n\treturn c.NextChildFocusable(c.window, nil, forwards)\n}\n\nfunc (c *FocusController) NextChildFocusable(p Parent, after Control, forwards bool) Focusable {\n\texamineNext := after == nil\n\tchildren := p.Children()\n\n\ti := 0\n\te := len(children)\n\tif !forwards {\n\t\ti = len(children) - 1\n\t\te = -1\n\t}\n\n\tfor i != e {\n\t\tf := children[i]\n\t\tif forwards {\n\t\t\ti++\n\t\t} else {\n\t\t\ti--\n\t\t}\n\n\t\tif !examineNext {\n\t\t\tif f.Control == after {\n\t\t\t\texamineNext = true\n\t\t\t}\n\t\t\tcontinue\n\t\t}\n\n\t\tif focusable := c.Focusable(f.Control); focusable != nil {\n\t\t\treturn focusable\n\t\t}\n\n\t\tif container, ok := f.Control.(Container); ok {\n\t\t\tfocusable := c.NextChildFocusable(container, nil, forwards)\n\t\t\tif focusable != nil {\n\t\t\t\treturn focusable\n\t\t\t}\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc (c *FocusController) Focusable(ctrl Control) Focusable {\n\tfocusable, _ := ctrl.(Focusable)\n\tif focusable != nil && focusable.IsFocusable() {\n\t\treturn focusable\n\t}\n\treturn nil\n}\n"
        },
        {
          "name": "focusable.go",
          "type": "blob",
          "size": 1.0869140625,
          "content": "// Copyright 2015 The Go Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage gxui\n\n// Focusable is the optional interface implmented by controls that have the\n// ability to acquire focus. A control with focus will receive keyboard input\n// first.\ntype Focusable interface {\n\tControl\n\n\t// IsFocusable returns true if the control is currently in a state where it\n\t// can acquire focus.\n\tIsFocusable() bool\n\n\t// HasFocus returns true when the control has focus.\n\tHasFocus() bool\n\n\t// GainedFocus is called when the Focusable gains focus.\n\t// This method is called by the FocusManager should not be called by the user.\n\tGainedFocus()\n\n\t// LostFocus is called when the Focusable loses focus.\n\t// This method is called by the FocusManager should not be called by the user.\n\tLostFocus()\n\n\t// OnGainedFocus subscribes f to be called whenever the control gains focus.\n\tOnGainedFocus(f func()) EventSubscription\n\n\t// OnLostFocus subscribes f to be called whenever the control loses focus.\n\tOnLostFocus(f func()) EventSubscription\n}\n"
        },
        {
          "name": "font.go",
          "type": "blob",
          "size": 0.6103515625,
          "content": "// Copyright 2015 The Go Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage gxui\n\nimport (\n\t\"github.com/google/gxui/math\"\n)\n\n// A Font represents a TrueType font loaded by the GXUI driver.\ntype Font interface {\n\tLoadGlyphs(first, last rune)\n\tSize() int\n\tGlyphMaxSize() math.Size\n\tMeasure(*TextBlock) math.Size\n\tLayout(*TextBlock) (offsets []math.Point)\n}\n\n// TextBlock is a sequence of runes to be laid out.\ntype TextBlock struct {\n\tRunes     []rune\n\tAlignRect math.Rect\n\tH         HorizontalAlignment\n\tV         VerticalAlignment\n}\n"
        },
        {
          "name": "gxfont",
          "type": "tree",
          "content": null
        },
        {
          "name": "image.go",
          "type": "blob",
          "size": 0.7919921875,
          "content": "// Copyright 2015 The Go Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage gxui\n\nimport (\n\t\"github.com/google/gxui/math\"\n)\n\ntype ScalingMode int\n\nconst (\n\tScaling1to1 ScalingMode = iota\n\tScalingExpandGreedy\n\tScalingExplicitSize\n)\n\ntype AspectMode int\n\nconst (\n\tAspectStretch = iota\n\tAspectCorrectLetterbox\n\tAspectCorrectCrop\n)\n\ntype Image interface {\n\tControl\n\tTexture() Texture\n\tSetTexture(Texture)\n\tCanvas() Canvas\n\tSetCanvas(Canvas)\n\tBorderPen() Pen\n\tSetBorderPen(Pen)\n\tBackgroundBrush() Brush\n\tSetBackgroundBrush(Brush)\n\tScalingMode() ScalingMode\n\tSetScalingMode(ScalingMode)\n\tSetExplicitSize(math.Size)\n\tAspectMode() AspectMode\n\tSetAspectMode(AspectMode)\n\tPixelAt(math.Point) (math.Point, bool) // TODO: Remove\n}\n"
        },
        {
          "name": "interval",
          "type": "tree",
          "content": null
        },
        {
          "name": "keyboard_controller.go",
          "type": "blob",
          "size": 1.1455078125,
          "content": "// Copyright 2015 The Go Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage gxui\n\ntype KeyboardController struct {\n\twindow Window\n}\n\nfunc CreateKeyboardController(w Window) *KeyboardController {\n\tc := &KeyboardController{\n\t\twindow: w,\n\t}\n\tw.OnKeyDown(c.keyDown)\n\tw.OnKeyUp(c.keyUp)\n\tw.OnKeyRepeat(c.keyPress)\n\tw.OnKeyStroke(c.keyStroke)\n\treturn c\n}\n\nfunc (c *KeyboardController) keyDown(ev KeyboardEvent) {\n\tf := Control(c.window.Focus())\n\tfor f != nil {\n\t\tf.KeyDown(ev)\n\t\tf, _ = f.Parent().(Control)\n\t}\n\tc.keyPress(ev)\n}\n\nfunc (c *KeyboardController) keyUp(ev KeyboardEvent) {\n\tf := Control(c.window.Focus())\n\tfor f != nil {\n\t\tf.KeyUp(ev)\n\t\tf, _ = f.Parent().(Control)\n\t}\n}\n\nfunc (c *KeyboardController) keyPress(ev KeyboardEvent) {\n\tf := Control(c.window.Focus())\n\tfor f != nil {\n\t\tif f.KeyPress(ev) {\n\t\t\treturn\n\t\t}\n\t\tf, _ = f.Parent().(Control)\n\t}\n\tc.window.KeyPress(ev)\n}\n\nfunc (c *KeyboardController) keyStroke(ev KeyStrokeEvent) {\n\tf := Control(c.window.Focus())\n\tfor f != nil {\n\t\tif f.KeyStroke(ev) {\n\t\t\treturn\n\t\t}\n\t\tf, _ = f.Parent().(Control)\n\t}\n\tc.window.KeyStroke(ev)\n}\n"
        },
        {
          "name": "keyboard_event.go",
          "type": "blob",
          "size": 0.2470703125,
          "content": "// Copyright 2015 The Go Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage gxui\n\ntype KeyboardEvent struct {\n\tKey      KeyboardKey\n\tModifier KeyboardModifier\n}\n"
        },
        {
          "name": "keyboard_key.go",
          "type": "blob",
          "size": 1.1982421875,
          "content": "// Copyright 2015 The Go Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage gxui\n\ntype KeyboardKey int\n\nconst (\n\tKeyUnknown KeyboardKey = iota\n\tKeySpace\n\tKeyApostrophe\n\tKeyComma\n\tKeyMinus\n\tKeyPeriod\n\tKeySlash\n\tKey0\n\tKey1\n\tKey2\n\tKey3\n\tKey4\n\tKey5\n\tKey6\n\tKey7\n\tKey8\n\tKey9\n\tKeySemicolon\n\tKeyEqual\n\tKeyA\n\tKeyB\n\tKeyC\n\tKeyD\n\tKeyE\n\tKeyF\n\tKeyG\n\tKeyH\n\tKeyI\n\tKeyJ\n\tKeyK\n\tKeyL\n\tKeyM\n\tKeyN\n\tKeyO\n\tKeyP\n\tKeyQ\n\tKeyR\n\tKeyS\n\tKeyT\n\tKeyU\n\tKeyV\n\tKeyW\n\tKeyX\n\tKeyY\n\tKeyZ\n\tKeyLeftBracket\n\tKeyBackslash\n\tKeyRightBracket\n\tKeyGraveAccent\n\tKeyWorld1\n\tKeyWorld2\n\tKeyEscape\n\tKeyEnter\n\tKeyTab\n\tKeyBackspace\n\tKeyInsert\n\tKeyDelete\n\tKeyRight\n\tKeyLeft\n\tKeyDown\n\tKeyUp\n\tKeyPageUp\n\tKeyPageDown\n\tKeyHome\n\tKeyEnd\n\tKeyCapsLock\n\tKeyScrollLock\n\tKeyNumLock\n\tKeyPrintScreen\n\tKeyPause\n\tKeyF1\n\tKeyF2\n\tKeyF3\n\tKeyF4\n\tKeyF5\n\tKeyF6\n\tKeyF7\n\tKeyF8\n\tKeyF9\n\tKeyF10\n\tKeyF11\n\tKeyF12\n\tKeyKp0\n\tKeyKp1\n\tKeyKp2\n\tKeyKp3\n\tKeyKp4\n\tKeyKp5\n\tKeyKp6\n\tKeyKp7\n\tKeyKp8\n\tKeyKp9\n\tKeyKpDecimal\n\tKeyKpDivide\n\tKeyKpMultiply\n\tKeyKpSubtract\n\tKeyKpAdd\n\tKeyKpEnter\n\tKeyKpEqual\n\tKeyLeftShift\n\tKeyLeftControl\n\tKeyLeftAlt\n\tKeyLeftSuper\n\tKeyRightShift\n\tKeyRightControl\n\tKeyRightAlt\n\tKeyRightSuper\n\tKeyMenu\n\tKeyLast\n)\n"
        },
        {
          "name": "keyboard_modifier.go",
          "type": "blob",
          "size": 0.6328125,
          "content": "// Copyright 2015 The Go Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage gxui\n\ntype KeyboardModifier int\n\nconst (\n\tModNone    KeyboardModifier = 0\n\tModShift   KeyboardModifier = 1\n\tModControl KeyboardModifier = 2\n\tModAlt     KeyboardModifier = 4\n\tModSuper   KeyboardModifier = 8\n)\n\nfunc (m KeyboardModifier) Shift() bool {\n\treturn m&ModShift != 0\n}\n\nfunc (m KeyboardModifier) Control() bool {\n\treturn m&ModControl != 0\n}\n\nfunc (m KeyboardModifier) Alt() bool {\n\treturn m&ModAlt != 0\n}\n\nfunc (m KeyboardModifier) Super() bool {\n\treturn m&ModSuper != 0\n}\n"
        },
        {
          "name": "keystroke_event.go",
          "type": "blob",
          "size": 0.2431640625,
          "content": "// Copyright 2015 The Go Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage gxui\n\ntype KeyStrokeEvent struct {\n\tCharacter rune\n\tModifier  KeyboardModifier\n}\n"
        },
        {
          "name": "label.go",
          "type": "blob",
          "size": 0.494140625,
          "content": "// Copyright 2015 The Go Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage gxui\n\ntype Label interface {\n\tControl\n\tText() string\n\tSetText(string)\n\tFont() Font\n\tSetFont(Font)\n\tColor() Color\n\tSetColor(Color)\n\tMultiline() bool\n\tSetMultiline(bool)\n\tSetHorizontalAlignment(HorizontalAlignment)\n\tHorizontalAlignment() HorizontalAlignment\n\tSetVerticalAlignment(VerticalAlignment)\n\tVerticalAlignment() VerticalAlignment\n}\n"
        },
        {
          "name": "linear_layout.go",
          "type": "blob",
          "size": 2.560546875,
          "content": "// Copyright 2015 The Go Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage gxui\n\n// LinearLayout is a Container that lays out its child Controls into a column or\n// row. The layout will always start by positioning the first (0'th) child, and\n// then depending on the direction, will position each successive child either\n// to the left, top, right or bottom of the preceding child Control.\n// LinearLayout makes no effort to distribute remaining space evenly between the\n// children - an child control that is laid out before others will reduce the\n// remaining space given to the later children, even to the point that there is\n// zero space remaining.\ntype LinearLayout interface {\n\t// LinearLayout extends the Control interface.\n\tControl\n\n\t// LinearLayout extends the Container interface.\n\tContainer\n\n\t// Direction returns the direction of layout for this LinearLayout.\n\tDirection() Direction\n\n\t// Direction sets the direction of layout for this LinearLayout.\n\tSetDirection(Direction)\n\n\t// SizeMode returns the desired size behaviour for this LinearLayout.\n\tSizeMode() SizeMode\n\n\t// SetSizeMode sets the desired size behaviour for this LinearLayout.\n\tSetSizeMode(SizeMode)\n\n\t// HorizontalAlignment returns the alignment of the child Controls when laying\n\t// out TopToBottom or BottomToTop. It has no effect when the layout direction\n\t// is LeftToRight or RightToLeft.\n\tHorizontalAlignment() HorizontalAlignment\n\n\t// SetHorizontalAlignment sets the alignment of the child Controls when laying\n\t// out TopToBottom or BottomToTop. It has no effect when the layout direction\n\t// is LeftToRight or RightToLeft.\n\tSetHorizontalAlignment(HorizontalAlignment)\n\n\t// VerticalAlignment returns the alignment of the child Controls when laying\n\t// out LeftToRight or RightToLeft. It has no effect when the layout direction\n\t// is TopToBottom or BottomToTop.\n\tVerticalAlignment() VerticalAlignment\n\n\t// SetVerticalAlignment returns the alignment of the child Controls when\n\t// laying out LeftToRight or RightToLeft. It has no effect when the layout\n\t// direction is TopToBottom or BottomToTop.\n\tSetVerticalAlignment(VerticalAlignment)\n\n\t// BorderPen returns the Pen used to draw the LinearLayout's border.\n\tBorderPen() Pen\n\n\t// SetBorderPen sets the Pen used to draw the LinearLayout's border.\n\tSetBorderPen(Pen)\n\n\t// BackgroundBrush returns the Brush used to fill the LinearLayout's\n\t// background.\n\tBackgroundBrush() Brush\n\n\t// SetBackgroundBrush sets the Brush used to fill the LinearLayout's\n\t// background.\n\tSetBackgroundBrush(Brush)\n}\n"
        },
        {
          "name": "list.go",
          "type": "blob",
          "size": 2.185546875,
          "content": "// Copyright 2015 The Go Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage gxui\n\nimport \"github.com/google/gxui/math\"\n\ntype List interface {\n\tFocusable\n\tParent\n\tAdapter() ListAdapter\n\tSetAdapter(ListAdapter)\n\tSetOrientation(Orientation)\n\tOrientation() Orientation\n\tBorderPen() Pen\n\tSetBorderPen(Pen)\n\tBackgroundBrush() Brush\n\tSetBackgroundBrush(Brush)\n\tScrollTo(AdapterItem)\n\tIsItemVisible(AdapterItem) bool\n\tItemControl(AdapterItem) Control\n\tSelected() AdapterItem\n\tSelect(AdapterItem) bool\n\tOnSelectionChanged(func(AdapterItem)) EventSubscription\n\tOnItemClicked(func(MouseEvent, AdapterItem)) EventSubscription\n}\n\n// ListAdapter is an interface used to visualize a flat set of items.\n// Users of the ListAdapter should presume the data is unchanged until the\n// OnDataChanged or OnDataReplaced events are fired.\ntype ListAdapter interface {\n\t// Count returns the total number of items.\n\tCount() int\n\n\t// ItemAt returns the AdapterItem for the item at index i. It is important\n\t// for the Adapter to return consistent AdapterItems for the same data, so\n\t// that selections can be persisted, or re-ordering animations can be played\n\t// when the dataset changes.\n\t// The AdapterItem returned must be equality-unique across all indices.\n\tItemAt(index int) AdapterItem\n\n\t// ItemIndex returns the index of item, or -1 if the adapter does not contain\n\t// item.\n\tItemIndex(item AdapterItem) int\n\n\t// Create returns a Control visualizing the item at the specified index.\n\tCreate(theme Theme, index int) Control\n\n\t// Size returns the size that each of the item's controls will be displayed\n\t// at for the given theme.\n\tSize(Theme) math.Size\n\n\t// OnDataChanged registers f to be called when there is a partial change in\n\t// the items of the adapter. Scroll positions and selections should be\n\t// preserved if possible.\n\t// If recreateControls is true then each of the visible controls should be\n\t// recreated by re-calling Create().\n\tOnDataChanged(f func(recreateControls bool)) EventSubscription\n\n\t// OnDataReplaced registers f to be called when there is a complete\n\t// replacement of items in the adapter.\n\tOnDataReplaced(f func()) EventSubscription\n}\n"
        },
        {
          "name": "math",
          "type": "tree",
          "content": null
        },
        {
          "name": "mixins",
          "type": "tree",
          "content": null
        },
        {
          "name": "mouse_button.go",
          "type": "blob",
          "size": 0.2724609375,
          "content": "// Copyright 2015 The Go Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage gxui\n\ntype MouseButton int\n\nconst (\n\tMouseButtonLeft MouseButton = iota\n\tMouseButtonMiddle\n\tMouseButtonRight\n)\n"
        },
        {
          "name": "mouse_controller.go",
          "type": "blob",
          "size": 2.939453125,
          "content": "// Copyright 2015 The Go Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage gxui\n\nimport (\n\t\"time\"\n)\n\nvar doubleClickTime = time.Millisecond * 300\n\ntype MouseController struct {\n\twindow          Window\n\tfocusController *FocusController\n\tlastOver        ControlPointList\n\tlastDown        map[MouseButton]ControlPointList\n\tlastUpTime      map[MouseButton]time.Time\n}\n\nfunc CreateMouseController(w Window, focusController *FocusController) *MouseController {\n\tc := &MouseController{\n\t\twindow:          w,\n\t\tfocusController: focusController,\n\t\tlastDown:        make(map[MouseButton]ControlPointList),\n\t\tlastUpTime:      make(map[MouseButton]time.Time),\n\t}\n\tw.OnMouseMove(c.mouseMove)\n\tw.OnMouseEnter(c.mouseMove)\n\tw.OnMouseExit(c.mouseMove)\n\tw.OnMouseDown(c.mouseDown)\n\tw.OnMouseUp(c.mouseUp)\n\tw.OnMouseScroll(c.mouseScroll)\n\treturn c\n}\n\nfunc (m *MouseController) updatePosition(ev MouseEvent) {\n\tValidateHierarchy(m.window)\n\n\tnowOver := TopControlsUnder(ev.Point, m.window)\n\n\tfor _, cp := range m.lastOver {\n\t\tif !nowOver.Contains(cp.C) {\n\t\t\te := ev\n\t\t\te.Point = cp.P\n\t\t\tcp.C.MouseExit(e)\n\t\t}\n\t}\n\n\tfor _, cp := range nowOver {\n\t\tif !m.lastOver.Contains(cp.C) {\n\t\t\te := ev\n\t\t\te.Point = cp.P\n\t\t\tcp.C.MouseEnter(e)\n\t\t}\n\t}\n\n\tm.lastOver = nowOver\n}\n\nfunc (m *MouseController) mouseMove(ev MouseEvent) {\n\tm.updatePosition(ev)\n\tfor _, cp := range m.lastOver {\n\t\te := ev\n\t\te.Point = cp.P\n\t\tcp.C.MouseMove(e)\n\t}\n}\n\nfunc (m *MouseController) mouseDown(ev MouseEvent) {\n\tm.updatePosition(ev)\n\n\tfor _, cp := range m.lastOver {\n\t\te := ev\n\t\te.Point = cp.P\n\t\tcp.C.MouseDown(e)\n\t}\n\n\tm.lastDown[ev.Button] = m.lastOver\n}\n\nfunc (m *MouseController) mouseUp(ev MouseEvent) {\n\tm.updatePosition(ev)\n\n\tfor _, cp := range m.lastDown[ev.Button] {\n\t\te := ev\n\t\te.Point = cp.P\n\t\tcp.C.MouseUp(e)\n\t}\n\n\tsetFocusCount := m.focusController.SetFocusCount()\n\n\tdblClick := time.Since(m.lastUpTime[ev.Button]) < doubleClickTime\n\tclickConsumed := false\n\tfor i := len(m.lastDown[ev.Button]) - 1; i >= 0; i-- {\n\t\tcp := m.lastDown[ev.Button][i]\n\t\tif p, found := m.lastOver.Find(cp.C); found {\n\t\t\tev.Point = p\n\t\t\tif (dblClick && cp.C.DoubleClick(ev)) || (!dblClick && cp.C.Click(ev)) {\n\t\t\t\tclickConsumed = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}\n\n\tif !clickConsumed {\n\t\tev.Point = ev.WindowPoint\n\t\tif dblClick {\n\t\t\tm.window.DoubleClick(ev)\n\t\t} else {\n\t\t\tm.window.Click(ev)\n\t\t}\n\t}\n\n\tfocusSet := setFocusCount != m.focusController.SetFocusCount()\n\tif !focusSet {\n\t\tfor i := len(m.lastDown[ev.Button]) - 1; i >= 0; i-- {\n\t\t\tcp := m.lastDown[ev.Button][i]\n\t\t\tif m.lastOver.Contains(cp.C) && m.window.SetFocus(cp.C) {\n\t\t\t\tfocusSet = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\n\t\tif !focusSet {\n\t\t\tm.window.SetFocus(nil)\n\t\t}\n\t}\n\n\tdelete(m.lastDown, ev.Button)\n\tm.lastUpTime[ev.Button] = time.Now()\n}\n\nfunc (m *MouseController) mouseScroll(ev MouseEvent) {\n\tm.updatePosition(ev)\n\n\tfor i := len(m.lastOver) - 1; i >= 0; i-- {\n\t\tcp := m.lastOver[i]\n\t\te := ev\n\t\te.Point = cp.P\n\t\tcp.C.MouseScroll(e)\n\t}\n}\n"
        },
        {
          "name": "mouse_event.go",
          "type": "blob",
          "size": 0.462890625,
          "content": "// Copyright 2015 The Go Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage gxui\n\nimport (\n\t\"github.com/google/gxui/math\"\n)\n\ntype MouseEvent struct {\n\tButton           MouseButton\n\tState            MouseState\n\tPoint            math.Point // Local to the event receiver\n\tWindowPoint      math.Point\n\tWindow           Window\n\tScrollX, ScrollY int\n\tModifier         KeyboardModifier\n}\n"
        },
        {
          "name": "mouse_state.go",
          "type": "blob",
          "size": 0.267578125,
          "content": "// Copyright 2015 The Go Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage gxui\n\ntype MouseState int\n\nfunc (s MouseState) IsDown(b MouseButton) bool {\n\treturn s&(1<<uint(b)) != 0\n}\n"
        },
        {
          "name": "orientation.go",
          "type": "blob",
          "size": 0.685546875,
          "content": "// Copyright 2015 The Go Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage gxui\n\ntype Orientation int\n\nconst (\n\tVertical Orientation = iota\n\tHorizontal\n)\n\nfunc (o Orientation) Horizontal() bool { return o == Horizontal }\nfunc (o Orientation) Vertical() bool   { return o == Vertical }\n\nfunc (o Orientation) Flip() Orientation {\n\tif o == Horizontal {\n\t\treturn Vertical\n\t} else {\n\t\treturn Horizontal\n\t}\n}\n\nfunc (o Orientation) Major(x, y int) int {\n\tif o == Horizontal {\n\t\treturn x\n\t} else {\n\t\treturn y\n\t}\n}\n\nfunc (o Orientation) Minor(x, y int) int {\n\tif o == Horizontal {\n\t\treturn y\n\t} else {\n\t\treturn x\n\t}\n}\n"
        },
        {
          "name": "panel_holder.go",
          "type": "blob",
          "size": 0.4150390625,
          "content": "// Copyright 2015 The Go Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage gxui\n\ntype PanelHolder interface {\n\tControl\n\tAddPanel(panel Control, name string)\n\tAddPanelAt(panel Control, name string, index int)\n\tRemovePanel(panel Control)\n\tSelect(int)\n\tPanelCount() int\n\tPanelIndex(Control) int\n\tPanel(int) Control\n\tTab(int) Control\n}\n"
        },
        {
          "name": "pen.go",
          "type": "blob",
          "size": 0.427734375,
          "content": "// Copyright 2015 The Go Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage gxui\n\nvar DefaultPen Pen = CreatePen(1.0, Black)\nvar TransparentPen Pen = CreatePen(0.0, Transparent)\nvar WhitePen Pen = CreatePen(1.0, White)\n\ntype Pen struct {\n\tWidth float32\n\tColor Color\n}\n\nfunc CreatePen(width float32, color Color) Pen {\n\treturn Pen{width, color}\n}\n"
        },
        {
          "name": "polygon.go",
          "type": "blob",
          "size": 0.318359375,
          "content": "// Copyright 2015 The Go Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage gxui\n\nimport (\n\t\"github.com/google/gxui/math\"\n)\n\ntype PolygonVertex struct {\n\tPosition      math.Point\n\tRoundedRadius float32\n}\n\ntype Polygon []PolygonVertex\n"
        },
        {
          "name": "progress_bar.go",
          "type": "blob",
          "size": 0.33984375,
          "content": "// Copyright 2015 The Go Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage gxui\n\nimport (\n\t\"github.com/google/gxui/math\"\n)\n\ntype ProgressBar interface {\n\tControl\n\tSetDesiredSize(math.Size)\n\tSetProgress(int)\n\tProgress() int\n\tSetTarget(int)\n\tTarget() int\n}\n"
        },
        {
          "name": "samples",
          "type": "tree",
          "content": null
        },
        {
          "name": "scroll_bar.go",
          "type": "blob",
          "size": 0.4521484375,
          "content": "// Copyright 2015 The Go Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage gxui\n\ntype ScrollBar interface {\n\tControl\n\n\tOnScroll(func(from, to int)) EventSubscription\n\tScrollPosition() (from, to int)\n\tSetScrollPosition(from, to int)\n\tScrollLimit() int\n\tSetScrollLimit(l int)\n\tAutoHide() bool\n\tSetAutoHide(l bool)\n\tOrientation() Orientation\n\tSetOrientation(Orientation)\n}\n"
        },
        {
          "name": "scroll_layout.go",
          "type": "blob",
          "size": 0.4208984375,
          "content": "// Copyright 2015 The Go Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage gxui\n\ntype ScrollLayout interface {\n\tControl\n\tParent\n\tSetChild(Control)\n\tChild() Control\n\tSetScrollAxis(horizontal, vertical bool)\n\tScrollAxis() (horizontal, vertical bool)\n\tBorderPen() Pen\n\tSetBorderPen(Pen)\n\tBackgroundBrush() Brush\n\tSetBackgroundBrush(Brush)\n}\n"
        },
        {
          "name": "simple_event.go",
          "type": "blob",
          "size": 0.306640625,
          "content": "// Copyright 2015 The Go Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage gxui\n\ntype SimpleEvent struct {\n\tEventBase\n}\n\nfunc CreateEvent(signature interface{}) Event {\n\te := &SimpleEvent{}\n\te.init(signature)\n\treturn e\n}\n"
        },
        {
          "name": "size_mode.go",
          "type": "blob",
          "size": 0.361328125,
          "content": "// Copyright 2015 The Go Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage gxui\n\ntype SizeMode int\n\nconst (\n\tExpandToContent SizeMode = iota\n\tFill\n)\n\nfunc (s SizeMode) ExpandToContent() bool {\n\treturn s == ExpandToContent\n}\n\nfunc (s SizeMode) Fill() bool {\n\treturn s == Fill\n}\n"
        },
        {
          "name": "splitter_layout.go",
          "type": "blob",
          "size": 0.33984375,
          "content": "// Copyright 2015 The Go Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage gxui\n\ntype SplitterLayout interface {\n\tControl\n\tContainer\n\tChildWeight(Control) float32\n\tSetChildWeight(Control, float32)\n\tOrientation() Orientation\n\tSetOrientation(Orientation)\n}\n"
        },
        {
          "name": "table_layout.go",
          "type": "blob",
          "size": 0.2138671875,
          "content": "package gxui\n\ntype TableLayout interface {\n\tControl\n\n\tParent\n\n\tSetGrid(rows, columns int)\n\t// Add child at cell {x, y} with size of {w, h}\n\tSetChildAt(x, y, w, h int, child Control) *Child\n\tRemoveChild(child Control)\n}\n"
        },
        {
          "name": "testing",
          "type": "tree",
          "content": null
        },
        {
          "name": "text_selection.go",
          "type": "blob",
          "size": 1.431640625,
          "content": "// Copyright 2015 The Go Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage gxui\n\ntype TextSelection struct {\n\tstart, end   int\n\tcaretAtStart bool\n}\n\nfunc CreateTextSelection(start, end int, caretAtStart bool) TextSelection {\n\tif start < end {\n\t\treturn TextSelection{start, end, caretAtStart}\n\t} else {\n\t\treturn TextSelection{end, start, !caretAtStart}\n\t}\n}\n\nfunc (i TextSelection) Length() int             { return i.end - i.start }\nfunc (i TextSelection) Range() (start, end int) { return i.start, i.end }\nfunc (i TextSelection) Start() int              { return i.start }\nfunc (i TextSelection) End() int                { return i.end }\nfunc (i TextSelection) First() int              { return i.start }\nfunc (i TextSelection) Last() int               { return i.end - 1 }\nfunc (i TextSelection) CaretAtStart() bool      { return i.caretAtStart }\n\nfunc (t TextSelection) Offset(i int) TextSelection {\n\treturn TextSelection{\n\t\tstart:        t.start + i,\n\t\tend:          t.end + i,\n\t\tcaretAtStart: t.caretAtStart,\n\t}\n}\nfunc (i TextSelection) Caret() int {\n\tif i.caretAtStart {\n\t\treturn i.start\n\t} else {\n\t\treturn i.end\n\t}\n}\n\nfunc (i TextSelection) From() int { // TODO: Think of a better name for this function\n\tif i.caretAtStart {\n\t\treturn i.end\n\t} else {\n\t\treturn i.start\n\t}\n}\n\nfunc (i TextSelection) Span() (start, end uint64) {\n\treturn uint64(i.start), uint64(i.end)\n}\n"
        },
        {
          "name": "text_selection_list.go",
          "type": "blob",
          "size": 1.787109375,
          "content": "// Copyright 2015 The Go Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage gxui\n\nimport \"github.com/google/gxui/interval\"\n\ntype TextSelectionList []TextSelection\n\nfunc (l TextSelectionList) Transform(from int, transform func(i int) int) TextSelectionList {\n\tres := TextSelectionList{}\n\tfor _, s := range l {\n\t\tstart := s.start\n\t\tend := s.end\n\t\tif start >= from {\n\t\t\tstart = transform(start)\n\t\t}\n\t\tif end >= from {\n\t\t\tend = transform(end)\n\t\t}\n\t\tinterval.Merge(&res, TextSelection{start, end, s.caretAtStart})\n\t}\n\treturn res\n}\n\nfunc (l TextSelectionList) TransformCarets(from int, transform func(i int) int) TextSelectionList {\n\tres := TextSelectionList{}\n\tfor _, s := range l {\n\t\tif s.caretAtStart && s.start >= from {\n\t\t\ts.start = transform(s.start)\n\t\t} else if s.end >= from {\n\t\t\ts.end = transform(s.end)\n\t\t}\n\t\tif s.start > s.end {\n\t\t\ttmp := s.start\n\t\t\ts.start = s.end\n\t\t\ts.end = tmp\n\t\t\ts.caretAtStart = !s.caretAtStart\n\t\t}\n\t\tinterval.Merge(&res, s)\n\t}\n\treturn res\n}\n\nfunc (l TextSelectionList) Len() int {\n\treturn len(l)\n}\n\nfunc (l TextSelectionList) Cap() int {\n\treturn cap(l)\n}\n\nfunc (l *TextSelectionList) SetLen(len int) {\n\t*l = (*l)[:len]\n}\n\nfunc (l *TextSelectionList) GrowTo(length, capacity int) {\n\told := *l\n\t*l = make(TextSelectionList, length, capacity)\n\tcopy(*l, old)\n}\n\nfunc (l TextSelectionList) Copy(to, from, count int) {\n\tcopy(l[to:to+count], l[from:from+count])\n}\n\nfunc (l TextSelectionList) GetInterval(index int) (start, end uint64) {\n\treturn l[index].Span()\n}\n\nfunc (l TextSelectionList) SetInterval(index int, start, end uint64) {\n\tl[index].start = int(start)\n\tl[index].end = int(end)\n}\n\nfunc (l TextSelectionList) MergeData(index int, i interval.Node) {\n\tl[index].caretAtStart = i.(TextSelection).caretAtStart\n}\n"
        },
        {
          "name": "text_selection_list_test.go",
          "type": "blob",
          "size": 2.970703125,
          "content": "// Copyright 2015 The Go Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage gxui\n\nimport test \"github.com/google/gxui/testing\"\nimport (\n\t\"github.com/google/gxui/interval\"\n\t\"testing\"\n)\n\nfunc TestTextSelectionMergeOne(t *testing.T) {\n\ts := TextSelection{5, 10, true}\n\tl := TextSelectionList{}\n\tinterval.Merge(&l, s)\n\ttest.AssertEquals(t, TextSelectionList{s}, l)\n}\n\nfunc TestTextSelectionMergeInner(t *testing.T) {\n\ts1 := TextSelection{5, 10, true}\n\ts2 := TextSelection{6, 9, false}\n\tl := TextSelectionList{s1}\n\tinterval.Merge(&l, s2)\n\ttest.AssertEquals(t, TextSelectionList{\n\t\tTextSelection{5, 10, false},\n\t}, l)\n}\n\nfunc TestTextSelectionMergeAtStart(t *testing.T) {\n\ts1 := TextSelection{6, 9, true}\n\ts2 := TextSelection{6, 7, false}\n\tl := TextSelectionList{s1}\n\tinterval.Merge(&l, s2)\n\ttest.AssertEquals(t, TextSelectionList{\n\t\tTextSelection{6, 9, false},\n\t}, l)\n}\n\nfunc TestTextSelectionMergeAtEnd(t *testing.T) {\n\ts1 := TextSelection{6, 9, true}\n\ts2 := TextSelection{8, 9, false}\n\tl := TextSelectionList{s1}\n\tinterval.Merge(&l, s2)\n\ttest.AssertEquals(t, TextSelectionList{\n\t\tTextSelection{6, 9, false},\n\t}, l)\n}\n\nfunc TestTextSelectionMergeEncompass(t *testing.T) {\n\ts1 := TextSelection{6, 9, false}\n\ts2 := TextSelection{5, 10, true}\n\tl := TextSelectionList{s1}\n\tinterval.Merge(&l, s2)\n\ttest.AssertEquals(t, TextSelectionList{\n\t\tTextSelection{5, 10, true},\n\t}, l)\n}\n\nfunc TestTextSelectionMergeDuplicate(t *testing.T) {\n\ts1 := TextSelection{2, 6, false}\n\ts2 := TextSelection{2, 6, true}\n\tl := TextSelectionList{s1}\n\tinterval.Merge(&l, s2)\n\ttest.AssertEquals(t, TextSelectionList{\n\t\tTextSelection{2, 6, true},\n\t}, l)\n}\n\nfunc TestTextSelectionMergeDuplicate0Len(t *testing.T) {\n\ts1 := TextSelection{2, 2, false}\n\ts2 := TextSelection{2, 2, true}\n\tl := TextSelectionList{s1}\n\tinterval.Merge(&l, s2)\n\ttest.AssertEquals(t, TextSelectionList{\n\t\tTextSelection{2, 2, true},\n\t}, l)\n}\n\nfunc TestTextSelectionMergeExtendStart(t *testing.T) {\n\ts1 := TextSelection{6, 9, false}\n\ts2 := TextSelection{1, 7, true}\n\tl := TextSelectionList{s1}\n\tinterval.Merge(&l, s2)\n\ttest.AssertEquals(t, TextSelectionList{\n\t\tTextSelection{1, 9, true},\n\t}, l)\n}\n\nfunc TestTextSelectionMergeExtendEnd(t *testing.T) {\n\ts1 := TextSelection{6, 9, true}\n\ts2 := TextSelection{8, 15, false}\n\tl := TextSelectionList{s1}\n\tinterval.Merge(&l, s2)\n\ttest.AssertEquals(t, TextSelectionList{\n\t\tTextSelection{6, 15, false},\n\t}, l)\n}\n\nfunc TestTextSelectionMergeBeforeStart(t *testing.T) {\n\ts1 := TextSelection{6, 9, true}\n\ts2 := TextSelection{2, 6, false}\n\tl := TextSelectionList{s1}\n\tinterval.Merge(&l, s2)\n\ttest.AssertEquals(t, TextSelectionList{\n\t\tTextSelection{2, 6, false},\n\t\tTextSelection{6, 9, true},\n\t}, l)\n}\n\nfunc TestTextSelectionMergeAfterEnd(t *testing.T) {\n\ts1 := TextSelection{2, 6, false}\n\ts2 := TextSelection{6, 9, true}\n\tl := TextSelectionList{s1}\n\tinterval.Merge(&l, s2)\n\ttest.AssertEquals(t, TextSelectionList{\n\t\tTextSelection{2, 6, false},\n\t\tTextSelection{6, 9, true},\n\t}, l)\n}\n"
        },
        {
          "name": "textbox.go",
          "type": "blob",
          "size": 0.869140625,
          "content": "// Copyright 2015 The Go Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage gxui\n\nimport (\n\t\"github.com/google/gxui/math\"\n)\n\ntype TextBox interface {\n\tFocusable\n\tOnSelectionChanged(func()) EventSubscription\n\tOnTextChanged(func([]TextBoxEdit)) EventSubscription\n\tPadding() math.Spacing\n\tSetPadding(math.Spacing)\n\tRunes() []rune\n\tText() string\n\tSetText(string)\n\tFont() Font\n\tSetFont(Font)\n\tMultiline() bool\n\tSetMultiline(bool)\n\tDesiredWidth() int\n\tSetDesiredWidth(desiredWidth int)\n\tTextColor() Color\n\tSetTextColor(Color)\n\tSelect(TextSelectionList)\n\tSelectAll()\n\tCarets() []int\n\tRuneIndexAt(p math.Point) (idx int, found bool)\n\tTextAt(s, e int) string\n\tWordAt(runeIndex int) string\n\tScrollToLine(int)\n\tScrollToRune(int)\n\tLineIndex(runeIndex int) int\n\tLineStart(line int) int\n\tLineEnd(line int) int\n}\n"
        },
        {
          "name": "textbox_controller.go",
          "type": "blob",
          "size": 15.673828125,
          "content": "// Copyright 2015 The Go Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage gxui\n\nimport (\n\t\"github.com/google/gxui/interval\"\n\t\"github.com/google/gxui/math\"\n\t\"sort\"\n\t\"strings\"\n\t\"unicode\"\n)\n\ntype TextBoxEdit struct {\n\tAt    int\n\tDelta int\n}\n\ntype TextBoxController struct {\n\tonSelectionChanged          Event\n\tonTextChanged               Event\n\ttext                        []rune\n\tlineStarts                  []int\n\tlineEnds                    []int\n\tselections                  TextSelectionList\n\tlocationHistory             [][]int\n\tlocationHistoryIndex        int\n\tstoreCaretLocationsNextEdit bool\n}\n\nfunc CreateTextBoxController() *TextBoxController {\n\tt := &TextBoxController{\n\t\tonSelectionChanged: CreateEvent(func() {}),\n\t\tonTextChanged:      CreateEvent(func([]TextBoxEdit) {}),\n\t}\n\tt.selections = TextSelectionList{TextSelection{}}\n\treturn t\n}\n\nfunc (t *TextBoxController) textEdited(edits []TextBoxEdit) {\n\tt.updateSelectionsForEdits(edits)\n\tt.onTextChanged.Fire(edits)\n}\n\nfunc (t *TextBoxController) updateSelectionsForEdits(edits []TextBoxEdit) {\n\tmin := 0\n\tmax := len(t.text)\n\tselections := TextSelectionList{}\n\tfor _, selection := range t.selections {\n\t\tfor _, e := range edits {\n\t\t\tat := e.At\n\t\t\tdelta := e.Delta\n\t\t\tif selection.start > at {\n\t\t\t\tselection.start += delta\n\t\t\t}\n\t\t\tif selection.end >= at {\n\t\t\t\tselection.end += delta\n\t\t\t}\n\t\t}\n\t\tif selection.end < selection.start {\n\t\t\tselection.end = selection.start\n\t\t}\n\t\tselection.start = math.Clamp(selection.start, min, max)\n\t\tselection.end = math.Clamp(selection.end, min, max)\n\t\tinterval.Merge(&selections, selection)\n\t}\n\tt.selections = selections\n}\n\nfunc (t *TextBoxController) setTextRunesNoEvent(text []rune) {\n\tt.text = text\n\tt.lineStarts = t.lineStarts[:0]\n\tt.lineEnds = t.lineEnds[:0]\n\n\tt.lineStarts = append(t.lineStarts, 0)\n\tfor i, r := range text {\n\t\tif r == '\\n' {\n\t\t\tt.lineEnds = append(t.lineEnds, i)\n\t\t\tt.lineStarts = append(t.lineStarts, i+1)\n\t\t}\n\t}\n\tt.lineEnds = append(t.lineEnds, len(text))\n}\n\nfunc (t *TextBoxController) maybeStoreCaretLocations() {\n\tif t.storeCaretLocationsNextEdit {\n\t\tt.StoreCaretLocations()\n\t\tt.storeCaretLocationsNextEdit = false\n\t}\n}\n\nfunc (t *TextBoxController) StoreCaretLocations() {\n\tif t.locationHistoryIndex < len(t.locationHistory) {\n\t\tt.locationHistory = t.locationHistory[:t.locationHistoryIndex]\n\t}\n\tt.locationHistory = append(t.locationHistory, t.Carets())\n\tt.locationHistoryIndex = len(t.locationHistory)\n}\n\nfunc (t *TextBoxController) OnSelectionChanged(f func()) EventSubscription {\n\treturn t.onSelectionChanged.Listen(f)\n}\n\nfunc (t *TextBoxController) OnTextChanged(f func([]TextBoxEdit)) EventSubscription {\n\treturn t.onTextChanged.Listen(f)\n}\n\nfunc (t *TextBoxController) SelectionCount() int {\n\treturn len(t.selections)\n}\n\nfunc (t *TextBoxController) Selection(i int) TextSelection {\n\treturn t.selections[i]\n}\n\nfunc (t *TextBoxController) Selections() TextSelectionList {\n\treturn append(TextSelectionList{}, t.selections...)\n}\n\nfunc (t *TextBoxController) SelectionText(i int) string {\n\tsel := t.selections[i]\n\trunes := t.text[sel.start:sel.end]\n\treturn RuneArrayToString(runes)\n}\n\nfunc (t *TextBoxController) SelectionLineText(i int) string {\n\tsel := t.selections[i]\n\tline := t.LineIndex(sel.start)\n\trunes := t.text[t.LineStart(line):t.LineEnd(line)]\n\treturn RuneArrayToString(runes)\n}\n\nfunc (t *TextBoxController) Caret(i int) int {\n\treturn t.selections[i].Caret()\n}\n\nfunc (t *TextBoxController) Carets() []int {\n\tl := make([]int, len(t.selections))\n\tfor i, s := range t.selections {\n\t\tl[i] = s.Caret()\n\t}\n\treturn l\n}\n\nfunc (t *TextBoxController) FirstCaret() int {\n\treturn t.Caret(0)\n}\n\nfunc (t *TextBoxController) LastCaret() int {\n\treturn t.Caret(t.SelectionCount() - 1)\n}\n\nfunc (t *TextBoxController) FirstSelection() TextSelection {\n\treturn t.Selection(0)\n}\n\nfunc (t *TextBoxController) LastSelection() TextSelection {\n\treturn t.Selection(t.SelectionCount() - 1)\n}\n\nfunc (t *TextBoxController) LineCount() int {\n\treturn len(t.lineStarts)\n}\n\nfunc (t *TextBoxController) Line(i int) string {\n\treturn RuneArrayToString(t.LineRunes(i))\n}\n\nfunc (t *TextBoxController) LineRunes(i int) []rune {\n\ts := t.LineStart(i)\n\te := t.LineEnd(i)\n\treturn t.text[s:e]\n}\n\nfunc (t *TextBoxController) LineStart(i int) int {\n\tif t.LineCount() == 0 {\n\t\treturn 0\n\t}\n\treturn t.lineStarts[i]\n}\n\nfunc (t *TextBoxController) LineEnd(i int) int {\n\tif t.LineCount() == 0 {\n\t\treturn 0\n\t}\n\treturn t.lineEnds[i]\n}\n\nfunc (t *TextBoxController) LineIndent(i int) int {\n\ts, e := t.LineStart(i), t.LineEnd(i)\n\tl := e - s\n\tfor i := 0; i < l; i++ {\n\t\tif !unicode.IsSpace(t.text[i+s]) {\n\t\t\treturn i\n\t\t}\n\t}\n\treturn l\n}\n\nfunc (t *TextBoxController) LineIndex(p int) int {\n\treturn sort.Search(len(t.lineStarts), func(i int) bool {\n\t\treturn p <= t.lineEnds[i]\n\t})\n}\n\nfunc (t *TextBoxController) Text() string {\n\treturn RuneArrayToString(t.text)\n}\n\nfunc (t *TextBoxController) TextRange(s, e int) string {\n\treturn RuneArrayToString(t.text[s:e])\n}\n\nfunc (t *TextBoxController) TextRunes() []rune {\n\treturn t.text\n}\n\nfunc (t *TextBoxController) SetText(str string) {\n\tt.SetTextRunes(StringToRuneArray(str))\n}\n\nfunc (t *TextBoxController) SetTextRunes(text []rune) {\n\tt.setTextRunesNoEvent(text)\n\tt.textEdited([]TextBoxEdit{})\n}\n\nfunc (t *TextBoxController) SetTextEdits(text []rune, edits []TextBoxEdit) {\n\tt.setTextRunesNoEvent(text)\n\tt.textEdited(edits)\n}\n\nfunc (t *TextBoxController) IndexFirst(i int) int {\n\treturn 0\n}\n\nfunc (t *TextBoxController) IndexLast(i int) int {\n\treturn len(t.text)\n}\n\nfunc (t *TextBoxController) IndexLeft(i int) int {\n\treturn math.Max(i-1, 0)\n}\n\nfunc (t *TextBoxController) IndexRight(i int) int {\n\treturn math.Min(i+1, len(t.text))\n}\n\nfunc (t *TextBoxController) IndexWordLeft(i int) int {\n\ti--\n\tif i >= 0 {\n\t\twasInWord := t.RuneInWord(t.text[i])\n\t\tfor i > 0 {\n\t\t\tisInWord := t.RuneInWord(t.text[i-1])\n\t\t\tif isInWord != wasInWord {\n\t\t\t\treturn i\n\t\t\t}\n\t\t\twasInWord = isInWord\n\t\t\ti--\n\t\t}\n\t}\n\treturn 0\n}\n\nfunc (t *TextBoxController) IndexWordRight(i int) int {\n\tif i < len(t.text) {\n\t\twasInWord := t.RuneInWord(t.text[i])\n\t\tfor i < len(t.text)-1 {\n\t\t\ti++\n\t\t\tisInWord := t.RuneInWord(t.text[i])\n\t\t\tif isInWord != wasInWord {\n\t\t\t\treturn i\n\t\t\t}\n\t\t\twasInWord = isInWord\n\t\t}\n\t}\n\treturn len(t.text)\n}\n\nfunc (t *TextBoxController) IndexUp(i int) int {\n\tl := t.LineIndex(i)\n\tx := i - t.LineStart(l)\n\tif l > 0 {\n\t\treturn math.Min(t.LineStart(l-1)+x, t.LineEnd(l-1))\n\t} else {\n\t\treturn 0\n\t}\n}\n\nfunc (t *TextBoxController) IndexDown(i int) int {\n\tl := t.LineIndex(i)\n\tx := i - t.LineStart(l)\n\tif l < t.LineCount()-1 {\n\t\treturn math.Min(t.LineStart(l+1)+x, t.LineEnd(l+1))\n\t} else {\n\t\treturn t.LineEnd(l)\n\t}\n}\n\nfunc (t *TextBoxController) IndexHome(i int) int {\n\tl := t.LineIndex(i)\n\ts := t.LineStart(l)\n\tx := i - s\n\tindent := t.LineIndent(l)\n\tif x > indent {\n\t\treturn s + indent\n\t} else {\n\t\treturn s\n\t}\n}\n\nfunc (t *TextBoxController) IndexEnd(i int) int {\n\treturn t.LineEnd(t.LineIndex(i))\n}\n\ntype SelectionTransform func(int) int\n\nfunc (t *TextBoxController) ClearSelections() {\n\tt.storeCaretLocationsNextEdit = true\n\tt.SetCaret(t.Caret(0))\n}\n\nfunc (t *TextBoxController) SetCaret(c int) {\n\tt.storeCaretLocationsNextEdit = true\n\tt.selections = TextSelectionList{}\n\tt.AddCaret(c)\n}\n\nfunc (t *TextBoxController) AddCaret(c int) {\n\tt.storeCaretLocationsNextEdit = true\n\tt.AddSelection(TextSelection{c, c, false})\n}\n\nfunc (t *TextBoxController) AddSelection(s TextSelection) {\n\tt.storeCaretLocationsNextEdit = true\n\tinterval.Merge(&t.selections, s)\n\tt.onSelectionChanged.Fire()\n}\n\nfunc (t *TextBoxController) SetSelection(s TextSelection) {\n\tt.storeCaretLocationsNextEdit = true\n\tt.selections = []TextSelection{s}\n\tt.onSelectionChanged.Fire()\n}\n\nfunc (t *TextBoxController) SetSelections(s TextSelectionList) {\n\tt.storeCaretLocationsNextEdit = true\n\tt.selections = s\n\tif len(s) == 0 {\n\t\tt.AddCaret(0)\n\t} else {\n\t\tt.onSelectionChanged.Fire()\n\t}\n}\n\nfunc (t *TextBoxController) SelectAll() {\n\tt.storeCaretLocationsNextEdit = true\n\tt.SetSelection(TextSelection{0, len(t.text), false})\n}\n\nfunc (t *TextBoxController) RestorePreviousSelections() {\n\tif t.locationHistoryIndex == len(t.locationHistory) {\n\t\tt.StoreCaretLocations()\n\t\tt.locationHistoryIndex--\n\t}\n\tif t.locationHistoryIndex > 0 {\n\t\tt.locationHistoryIndex--\n\t\tlocations := t.locationHistory[t.locationHistoryIndex]\n\t\tt.selections = make(TextSelectionList, len(locations))\n\t\tfor i, l := range locations {\n\t\t\tt.selections[i] = TextSelection{l, l, false}\n\t\t}\n\t\tt.onSelectionChanged.Fire()\n\t}\n}\n\nfunc (t *TextBoxController) RestoreNextSelections() {\n\tif t.locationHistoryIndex < len(t.locationHistory)-1 {\n\t\tt.locationHistoryIndex++\n\t\tlocations := t.locationHistory[t.locationHistoryIndex]\n\t\tt.selections = make(TextSelectionList, len(locations))\n\t\tfor i, l := range locations {\n\t\t\tt.selections[i] = TextSelection{l, l, false}\n\t\t}\n\t\tt.onSelectionChanged.Fire()\n\t}\n}\n\nfunc (t *TextBoxController) AddCarets(transform SelectionTransform) {\n\tt.storeCaretLocationsNextEdit = true\n\tup := t.selections.Transform(0, transform)\n\tfor _, s := range up {\n\t\tinterval.Merge(&t.selections, s)\n\t}\n\tt.onSelectionChanged.Fire()\n}\n\nfunc (t *TextBoxController) GrowSelections(transform SelectionTransform) {\n\tt.storeCaretLocationsNextEdit = true\n\tt.selections = t.selections.TransformCarets(0, transform)\n\tt.onSelectionChanged.Fire()\n}\n\nfunc (t *TextBoxController) MoveSelections(transform SelectionTransform) {\n\tt.storeCaretLocationsNextEdit = true\n\tt.selections = t.selections.Transform(0, transform)\n\tt.onSelectionChanged.Fire()\n}\n\nfunc (t *TextBoxController) AddCaretsUp()       { t.AddCarets(t.IndexUp) }\nfunc (t *TextBoxController) AddCaretsDown()     { t.AddCarets(t.IndexDown) }\nfunc (t *TextBoxController) SelectFirst()       { t.GrowSelections(t.IndexFirst) }\nfunc (t *TextBoxController) SelectLast()        { t.GrowSelections(t.IndexLast) }\nfunc (t *TextBoxController) SelectLeft()        { t.GrowSelections(t.IndexLeft) }\nfunc (t *TextBoxController) SelectRight()       { t.GrowSelections(t.IndexRight) }\nfunc (t *TextBoxController) SelectUp()          { t.GrowSelections(t.IndexUp) }\nfunc (t *TextBoxController) SelectDown()        { t.GrowSelections(t.IndexDown) }\nfunc (t *TextBoxController) SelectHome()        { t.GrowSelections(t.IndexHome) }\nfunc (t *TextBoxController) SelectEnd()         { t.GrowSelections(t.IndexEnd) }\nfunc (t *TextBoxController) SelectLeftByWord()  { t.GrowSelections(t.IndexWordLeft) }\nfunc (t *TextBoxController) SelectRightByWord() { t.GrowSelections(t.IndexWordRight) }\nfunc (t *TextBoxController) MoveFirst()         { t.MoveSelections(t.IndexFirst) }\nfunc (t *TextBoxController) MoveLast()          { t.MoveSelections(t.IndexLast) }\nfunc (t *TextBoxController) MoveLeft()          { t.MoveSelections(t.IndexLeft) }\nfunc (t *TextBoxController) MoveRight()         { t.MoveSelections(t.IndexRight) }\nfunc (t *TextBoxController) MoveUp()            { t.MoveSelections(t.IndexUp) }\nfunc (t *TextBoxController) MoveDown()          { t.MoveSelections(t.IndexDown) }\nfunc (t *TextBoxController) MoveLeftByWord()    { t.MoveSelections(t.IndexWordLeft) }\nfunc (t *TextBoxController) MoveRightByWord()   { t.MoveSelections(t.IndexWordRight) }\nfunc (t *TextBoxController) MoveHome()          { t.MoveSelections(t.IndexHome) }\nfunc (t *TextBoxController) MoveEnd()           { t.MoveSelections(t.IndexEnd) }\n\nfunc (t *TextBoxController) Delete() {\n\tt.maybeStoreCaretLocations()\n\ttext := t.text\n\tedits := []TextBoxEdit{}\n\tfor i := len(t.selections) - 1; i >= 0; i-- {\n\t\ts := t.selections[i]\n\t\tif s.start == s.end && s.end < len(t.text) {\n\t\t\tcopy(text[s.start:], text[s.start+1:])\n\t\t\ttext = text[:len(text)-1]\n\t\t\tedits = append(edits, TextBoxEdit{s.start, -1})\n\t\t} else {\n\t\t\tcopy(text[s.start:], text[s.end:])\n\t\t\tl := s.Length()\n\t\t\ttext = text[:len(text)-l]\n\t\t\tedits = append(edits, TextBoxEdit{s.start, -l})\n\t\t}\n\t\tt.selections[i] = TextSelection{s.end, s.end, false}\n\t}\n\tt.SetTextEdits(text, edits)\n}\n\nfunc (t *TextBoxController) Backspace() {\n\tt.maybeStoreCaretLocations()\n\ttext := t.text\n\tedits := []TextBoxEdit{}\n\tfor i := len(t.selections) - 1; i >= 0; i-- {\n\t\ts := t.selections[i]\n\t\tif s.start == s.end && s.start > 0 {\n\t\t\tcopy(text[s.start-1:], text[s.start:])\n\t\t\ttext = text[:len(text)-1]\n\t\t\tedits = append(edits, TextBoxEdit{s.start - 1, -1})\n\t\t} else {\n\t\t\tcopy(text[s.start:], text[s.end:])\n\t\t\tl := s.Length()\n\t\t\ttext = text[:len(text)-l]\n\t\t\tedits = append(edits, TextBoxEdit{s.start - 1, -l})\n\t\t}\n\t\tt.selections[i] = TextSelection{s.end, s.end, false}\n\t}\n\tt.SetTextEdits(text, edits)\n}\n\nfunc (t *TextBoxController) ReplaceAll(str string) {\n\tt.Replace(func(TextSelection) string { return str })\n}\n\nfunc (t *TextBoxController) ReplaceAllRunes(str []rune) {\n\tt.ReplaceRunes(func(TextSelection) []rune { return str })\n}\n\nfunc (t *TextBoxController) Replace(f func(sel TextSelection) string) {\n\tt.ReplaceRunes(func(s TextSelection) []rune { return StringToRuneArray(f(s)) })\n}\n\nfunc (t *TextBoxController) ReplaceRunes(f func(sel TextSelection) []rune) {\n\tt.maybeStoreCaretLocations()\n\ttext, edit, edits := t.text, TextBoxEdit{}, []TextBoxEdit{}\n\tfor i := len(t.selections) - 1; i >= 0; i-- {\n\t\ts := t.selections[i]\n\t\ttext, edit = t.ReplaceAt(text, s.start, s.end, f(s))\n\t\tedits = append(edits, edit)\n\t}\n\tt.setTextRunesNoEvent(text)\n\tt.textEdited(edits)\n}\n\nfunc (t *TextBoxController) ReplaceAt(text []rune, s, e int, replacement []rune) ([]rune, TextBoxEdit) {\n\treplacementLen := len(replacement)\n\tdelta := replacementLen - (e - s)\n\tif delta > 0 {\n\t\ttext = append(text, make([]rune, delta)...)\n\t}\n\tcopy(text[e+delta:], text[e:])\n\tcopy(text[s:], replacement)\n\tif delta < 0 {\n\t\ttext = text[:len(text)+delta]\n\t}\n\treturn text, TextBoxEdit{s, delta}\n}\n\nfunc (t *TextBoxController) ReplaceWithNewline() {\n\tt.ReplaceAll(\"\\n\")\n\tt.Deselect(false)\n}\n\nfunc (t *TextBoxController) ReplaceWithNewlineKeepIndent() {\n\tt.Replace(func(sel TextSelection) string {\n\t\ts, _ := sel.Range()\n\t\tindent := t.LineIndent(t.LineIndex(s))\n\t\treturn \"\\n\" + strings.Repeat(\" \", indent)\n\t})\n\tt.Deselect(false)\n}\n\nfunc (t *TextBoxController) IndentSelection(tabWidth int) {\n\ttab := make([]rune, tabWidth)\n\tfor i := range tab {\n\t\ttab[i] = ' '\n\t}\n\ttext, edit, edits := t.text, TextBoxEdit{}, []TextBoxEdit{}\n\tlastLine := -1\n\tfor i := len(t.selections) - 1; i >= 0; i-- {\n\t\ts := t.selections[i]\n\t\tlis, lie := t.LineIndex(s.start), t.LineIndex(s.end)\n\t\tif lastLine == lie {\n\t\t\tlie--\n\t\t}\n\t\tfor l := lie; l >= lis; l-- {\n\t\t\tls := t.LineStart(l)\n\t\t\ttext, edit = t.ReplaceAt(text, ls, ls, tab)\n\t\t\tedits = append(edits, edit)\n\t\t}\n\t\tlastLine = lis\n\t}\n\tt.SetTextEdits(text, edits)\n}\n\nfunc (t *TextBoxController) UnindentSelection(tabWidth int) {\n\ttext, edit, edits := t.text, TextBoxEdit{}, []TextBoxEdit{}\n\tlastLine := -1\n\tfor i := len(t.selections) - 1; i >= 0; i-- {\n\t\ts := t.selections[i]\n\t\tlis, lie := t.LineIndex(s.start), t.LineIndex(s.end)\n\t\tif lastLine == lie {\n\t\t\tlie--\n\t\t}\n\t\tfor l := lie; l >= lis; l-- {\n\t\t\tc := math.Min(t.LineIndent(l), tabWidth)\n\t\t\tif c > 0 {\n\t\t\t\tls := t.LineStart(l)\n\t\t\t\ttext, edit = t.ReplaceAt(text, ls, ls+c, []rune{})\n\t\t\t\tedits = append(edits, edit)\n\t\t\t}\n\t\t}\n\t\tlastLine = lis\n\t}\n\tt.SetTextEdits(text, edits)\n}\n\nfunc (t *TextBoxController) RuneInWord(r rune) bool {\n\tswitch {\n\tcase unicode.IsLetter(r), unicode.IsNumber(r), r == '_':\n\t\treturn true\n\tdefault:\n\t\treturn false\n\t}\n}\n\nfunc (t *TextBoxController) WordAt(runeIdx int) (s, e int) {\n\ttext := t.text\n\ts, e = runeIdx, runeIdx\n\tfor s > 0 && t.RuneInWord(text[s-1]) {\n\t\ts--\n\t}\n\tfor e < len(t.text) && t.RuneInWord(text[e]) {\n\t\te++\n\t}\n\treturn s, e\n}\n\nfunc (t *TextBoxController) Deselect(moveCaretToStart bool) (deselected bool) {\n\tdeselected = false\n\tfor i, s := range t.selections {\n\t\tif s.start == s.end {\n\t\t\tcontinue\n\t\t}\n\t\tdeselected = true\n\t\tif moveCaretToStart {\n\t\t\ts.end = s.start\n\t\t} else {\n\t\t\ts.start = s.end\n\t\t}\n\t\tt.selections[i] = s\n\t}\n\tif deselected {\n\t\tt.onSelectionChanged.Fire()\n\t}\n\treturn\n}\n\nfunc (t *TextBoxController) LineAndRow(index int) (line, row int) {\n\tline = t.LineIndex(index)\n\trow = index - t.LineStart(line)\n\treturn\n}\n"
        },
        {
          "name": "textbox_controller_test.go",
          "type": "blob",
          "size": 8.076171875,
          "content": "// Copyright 2015 The Go Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage gxui\n\nimport (\n\t\"fmt\"\n\ttest \"github.com/google/gxui/testing\"\n\t\"testing\"\n)\n\nfunc parseTBC(markup string) *TextBoxController {\n\ttbc := CreateTextBoxController()\n\ttbc.selections = TextSelectionList{}\n\trunes := make([]rune, 0, 32)\n\tsel := TextSelection{}\n\tfor _, c := range markup {\n\t\ti := len(runes)\n\t\tswitch c {\n\t\tcase '|':\n\t\t\ttbc.AddCaret(i)\n\t\tcase '{':\n\t\t\tsel.start = i\n\t\t\tsel.caretAtStart = false\n\t\tcase '[':\n\t\t\tsel.start = i\n\t\t\tsel.caretAtStart = true\n\t\tcase ']':\n\t\t\tsel.end = i\n\t\t\tif sel.CaretAtStart() {\n\t\t\t\tpanic(\"Carat should be at end\")\n\t\t\t}\n\t\t\ttbc.AddSelection(sel)\n\t\tcase '}':\n\t\t\tsel.end = i\n\t\t\tif !sel.CaretAtStart() {\n\t\t\t\tpanic(\"Carat should be at start\")\n\t\t\t}\n\t\t\ttbc.AddSelection(sel)\n\t\tdefault:\n\t\t\trunes = append(runes, c)\n\t\t}\n\t}\n\ttbc.SetTextRunes(runes)\n\treturn tbc\n}\n\nfunc assertTBCTextAndSelectionsEqual(t *testing.T, markup string, c *TextBoxController) {\n\texpected := parseTBC(markup)\n\ttest.AssertEquals(t, expected.Text(), c.Text())\n\ttest.AssertEquals(t, expected.selections, c.selections)\n}\n\nfunc TestTBCLineIndent(t *testing.T) {\n\tc := parseTBC(\"  ÀÁ\\n    BB\\nĆ\\n      D\\n   EE\")\n\ttest.AssertEquals(t, 2, c.LineIndent(0))\n\ttest.AssertEquals(t, 4, c.LineIndent(1))\n\ttest.AssertEquals(t, 0, c.LineIndent(2))\n\ttest.AssertEquals(t, 6, c.LineIndent(3))\n\ttest.AssertEquals(t, 3, c.LineIndent(4))\n}\n\nfunc TestParseTBCCarets(t *testing.T) {\n\tc := parseTBC(\"he|llo\\n|wor|ld\")\n\ttest.AssertEquals(t, \"hello\\nworld\", c.Text())\n\ttest.AssertEquals(t, 2, c.LineCount())\n\ttest.AssertEquals(t, 3, c.SelectionCount())\n\ttest.AssertEquals(t, 2, c.Caret(0))\n\ttest.AssertEquals(t, 6, c.Caret(1))\n\ttest.AssertEquals(t, 9, c.Caret(2))\n}\n\nfunc TestParseTBCSelections(t *testing.T) {\n\tc := parseTBC(\"he[llo}\\n|wor{ld]\")\n\ttest.AssertEquals(t, \"hello\\nworld\", c.Text())\n\ttest.AssertEquals(t, 2, c.LineCount())\n\ttest.AssertEquals(t, 3, c.SelectionCount())\n\ttest.AssertEquals(t, TextSelection{2, 5, true}, c.Selection(0))\n\ttest.AssertEquals(t, TextSelection{6, 6, false}, c.Selection(1))\n\ttest.AssertEquals(t, TextSelection{9, 11, false}, c.Selection(2))\n}\n\nfunc TestTBCWordAt(t *testing.T) {\n\tcheck := func(str, expected string) {\n\t\tc := parseTBC(str)\n\t\ts, e := c.WordAt(c.FirstCaret())\n\t\tc.SetSelection(TextSelection{s, e, false})\n\t\tassertTBCTextAndSelectionsEqual(t, expected, c)\n\t}\n\tcheck(\"abc.dE|f()\", \"abc.{dEf]()\")\n\tcheck(\"dE|f10()\", \"{dEf10]()\")\n\tcheck(\"hello_|world.foo\", \"{hello_world].foo\")\n}\n\nfunc TestTBCReplaceAll(t *testing.T) {\n\tc := parseTBC(\"ħę|ľĺő\\n|ŵōř|ŀď\")\n\tc.ReplaceAll(\"_\")\n\tassertTBCTextAndSelectionsEqual(t, \"ħę{_]ľĺő\\n{_]ŵōř{_]ŀď\", c)\n\tc.Deselect(false)\n\tassertTBCTextAndSelectionsEqual(t, \"ħę_|ľĺő\\n_|ŵōř_|ŀď\", c)\n\tc.ReplaceAll(\"¶§\")\n\tassertTBCTextAndSelectionsEqual(t, \"ħę_{¶§]ľĺő\\n_{¶§]ŵōř_{¶§]ŀď\", c)\n\tc.Deselect(false)\n\tassertTBCTextAndSelectionsEqual(t, \"ħę_¶§|ľĺő\\n_¶§|ŵōř_¶§|ŀď\", c)\n}\n\nfunc TestTBCReplace(t *testing.T) {\n\tc := parseTBC(\"ħę|ľĺő\\n|ŵōř|ŀď\")\n\tc.Replace(func(s TextSelection) string {\n\t\treturn fmt.Sprintf(\"%d\", s.start)\n\t})\n\tassertTBCTextAndSelectionsEqual(t, \"ħę{2]ľĺő\\n{6]ŵōř{9]ŀď\", c)\n}\n\nfunc TestTBCReplaceWithNewline(t *testing.T) {\n\tc := parseTBC(\"   XX|\\n  YY|YY\\n    ZZZ|\")\n\tc.ReplaceWithNewline()\n\tassertTBCTextAndSelectionsEqual(t, \"   XX\\n|\\n  YY\\n|YY\\n    ZZZ\\n|\", c)\n}\n\nfunc ReplaceWithNewlineKeepIndent(t *testing.T) {\n\tc := parseTBC(\"   XX|\\n  YY|YY\\n    ZZZ|\")\n\tc.ReplaceWithNewline()\n\tassertTBCTextAndSelectionsEqual(t, \"   XX\\n   |\\n  YY\\n  |YY\\n    ZZZ\\n    |\", c)\n}\n\nfunc TestTBCReplaceSelection(t *testing.T) {\n\tc := parseTBC(\"ħ{ęľ]ĺő\\nę[ľĺ}\\n|\\n{ŵōřŀď]\")\n\tc.ReplaceAll(\"ŵōřŀď\")\n\tassertTBCTextAndSelectionsEqual(t, \"ħ{ŵōřŀď]ĺő\\nę[ŵōřŀď}\\n{ŵōřŀď]\\n{ŵōřŀď]\", c)\n}\n\nfunc TestTBCBackspaceMulti(t *testing.T) {\n\tc := parseTBC(\"ħęľ|ĺő\\nŵōř|ŀď\")\n\tc.Backspace()\n\tassertTBCTextAndSelectionsEqual(t, \"ħę|ĺő\\nŵō|ŀď\", c)\n\tc.Backspace()\n\tassertTBCTextAndSelectionsEqual(t, \"ħ|ĺő\\nŵ|ŀď\", c)\n}\n\nfunc TestTBCBackspaceCaretOverlap(t *testing.T) {\n\tc := parseTBC(\"ħęľ|ĺ|ő\\nŵōřŀď\")\n\tc.Backspace()\n\tassertTBCTextAndSelectionsEqual(t, \"ħę|ő\\nŵōřŀď\", c)\n\tc.Backspace()\n\tassertTBCTextAndSelectionsEqual(t, \"ħ|ő\\nŵōřŀď\", c)\n}\n\nfunc TestTBCBackspaceAtStart(t *testing.T) {\n\tc := parseTBC(\"|ħęľĺő\\n|ŵōřŀď\")\n\tc.Backspace()\n\tassertTBCTextAndSelectionsEqual(t, \"|ħęľĺő|ŵōřŀď\", c)\n}\n\nfunc TestTBCBackspaceSelection(t *testing.T) {\n\tc := parseTBC(\"ħ[ęľ}ĺ{ő]\\n[ŵ}{ō]řŀď|\")\n\tc.Backspace()\n\tassertTBCTextAndSelectionsEqual(t, \"ħ|ĺ|\\n|řŀ|\", c)\n}\n\nfunc TestTBCDeleteAtEnd(t *testing.T) {\n\tc := parseTBC(\"ħęľĺő|\\nŵōřŀď|\")\n\tc.Delete()\n\tassertTBCTextAndSelectionsEqual(t, \"ħęľĺő|ŵōřŀď|\", c)\n}\n\nfunc TestTBCDeleteSelection(t *testing.T) {\n\tc := parseTBC(\"ħ[ęľ}ĺ{ő]\\n[ŵ}{ō]řŀď|\")\n\tc.Delete()\n\tassertTBCTextAndSelectionsEqual(t, \"ħ|ĺ|\\n|řŀď|\", c)\n}\n\nfunc TestTBCAddCaretsUp(t *testing.T) {\n\tc := parseTBC(\"ÀÁAA|\\nBBB|\\nĆ|\\nDDD|\")\n\tc.AddCaretsUp()\n\tassertTBCTextAndSelectionsEqual(t, \"|ÀÁA|A|\\nB|BB|\\nĆ|\\nDDD|\", c)\n}\n\nfunc TestTBCAddCaretsDown(t *testing.T) {\n\tc := parseTBC(\"ÀÁAA|\\nBBB|\\nĆ|\\nDDD|\")\n\tc.AddCaretsDown()\n\tassertTBCTextAndSelectionsEqual(t, \"ÀÁAA|\\nBBB|\\nĆ|\\nD|DD|\", c)\n}\n\nfunc TestTBCMoveUp(t *testing.T) {\n\tc := parseTBC(\"ÀÁAA|\\nBBB|\\nĆ|\\nDDD|\")\n\tc.MoveUp()\n\tassertTBCTextAndSelectionsEqual(t, \"|ÀÁA|A\\nB|BB\\nĆ|\\nDDD\", c)\n}\n\nfunc TestTBCMoveDown(t *testing.T) {\n\tc := parseTBC(\"ÀÁAA|\\nBBB|\\nĆ|\\nDDD|\")\n\tc.MoveDown()\n\tassertTBCTextAndSelectionsEqual(t, \"ÀÁAA\\nBBB|\\nĆ|\\nD|DD|\", c)\n}\n\nfunc TestTBCMoveLeft(t *testing.T) {\n\tc := parseTBC(\"ÀÁAA|\\nBBB|\\nĆ|\\nDDD|\")\n\tc.MoveLeft()\n\tassertTBCTextAndSelectionsEqual(t, \"ÀÁA|A\\nBB|B\\n|Ć\\nDD|D\", c)\n}\n\nfunc TestTBCMoveRight(t *testing.T) {\n\tc := parseTBC(\"ÀÁAA|\\nBBB|\\nĆ|\\nDDD|\")\n\tc.MoveRight()\n\tassertTBCTextAndSelectionsEqual(t, \"ÀÁAA\\n|BBB\\n|Ć\\n|DDD|\", c)\n}\n\nfunc TestTBCSelectUp(t *testing.T) {\n\tc := parseTBC(\"ÀÁAA|\\nBBB|\\nĆ|\\nDDD|\")\n\tc.SelectUp()\n\tassertTBCTextAndSelectionsEqual(t, \"[ÀÁAA\\nBBB\\nĆ}[\\nDDD}\", c)\n}\n\nfunc TestTBCSelectDown(t *testing.T) {\n\tc := parseTBC(\"ÀÁAA|\\nBBB|\\nĆ|\\nDDD|\")\n\tc.SelectDown()\n\tassertTBCTextAndSelectionsEqual(t, \"ÀÁAA{\\nBBB]{\\nĆ]{\\nD]DD|\", c)\n}\n\nfunc TestTBCSelectLeft(t *testing.T) {\n\tc := parseTBC(\"ÀÁAA|\\nBBB|\\nĆ|\\nDDD|\")\n\tc.SelectLeft()\n\tassertTBCTextAndSelectionsEqual(t, \"ÀÁA[A}\\nBB[B}\\n[Ć}\\nDD[D}\", c)\n}\n\nfunc TestTBCSelectRight(t *testing.T) {\n\tc := parseTBC(\"ÀÁAA|\\nBBB|\\nĆ|\\nDDD|\")\n\tc.SelectRight()\n\tassertTBCTextAndSelectionsEqual(t, \"ÀÁAA{\\n]BBB{\\n]Ć{\\n]DDD|\", c)\n}\n\nfunc TestTBCSelectToWordLeft(t *testing.T) {\n\tc := parseTBC(\"ÀÁ|AA\\nBB B|B BB\\nf|oo() Ć|\\n|DDD\")\n\tc.SelectLeftByWord()\n\tassertTBCTextAndSelectionsEqual(t, \"[ÀÁ}AA\\nBB [B}B BB\\n[f}oo() [Ć}[\\n}DDD\", c)\n}\n\nfunc TestTBCSelectToWordRight(t *testing.T) {\n\tc := parseTBC(\"ÀÁ|AA\\nBB B|B BB\\nf|oo() Ć|\\n|DDD\")\n\tc.SelectRightByWord()\n\tassertTBCTextAndSelectionsEqual(t, \"ÀÁ{AA]\\nBB B{B] BB\\nf{oo]() Ć{\\n]{DDD]\", c)\n}\n\nfunc TestTBCSelectHome(t *testing.T) {\n\tc := parseTBC(\"ÀÁ|AA\\n  BB|B\\nĆ|\\n    |DDD\\n   | EE\")\n\tc.SelectHome()\n\tassertTBCTextAndSelectionsEqual(t, \"[ÀÁ}AA\\n  [BB}B\\n[Ć}\\n[    }DDD\\n[   } EE\", c)\n}\n\nfunc TestTBCSelectEnd(t *testing.T) {\n\tc := parseTBC(\"ÀÁ|AA\\nBB|B\\nĆ|\\nD|DD\")\n\tc.SelectEnd()\n\tassertTBCTextAndSelectionsEqual(t, \"ÀÁ{AA]\\nBB{B]\\nĆ|\\nD{DD]\", c)\n}\n\nfunc TestTBCUnicode(t *testing.T) {\n\tc := parseTBC(\"|1£2£3\")\n\tc.MoveRight()\n\tassertTBCTextAndSelectionsEqual(t, \"1|£2£3\", c)\n\tc.MoveRight()\n\tassertTBCTextAndSelectionsEqual(t, \"1£|2£3\", c)\n\tc.MoveRight()\n\tassertTBCTextAndSelectionsEqual(t, \"1£2|£3\", c)\n}\n\nfunc TestTBCIndentSelection(t *testing.T) {\n\tc := parseTBC(\"a{aa\\n  b]bb|bb\\n    [cc}\\nddd\\ne{e][e}e\\n\")\n\tc.IndentSelection(2)\n\tassertTBCTextAndSelectionsEqual(t, \"  a{aa\\n    b]bb|bb\\n      [cc}\\nddd\\n  e{e][e}e\\n\", c)\n}\n\nfunc TestTBCUnindentSelection(t *testing.T) {\n\tc := parseTBC(\"  a{aa\\n    b]bb|bb\\n      [cc}\\nddd\\n  e{e][e}e\\n\")\n\tc.UnindentSelection(2)\n\tassertTBCTextAndSelectionsEqual(t, \"a{aa\\n  b]bb|bb\\n    [cc}\\nddd\\ne{e][e}e\\n\", c)\n}\n"
        },
        {
          "name": "texture.go",
          "type": "blob",
          "size": 0.3388671875,
          "content": "// Copyright 2015 The Go Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage gxui\n\nimport (\n\t\"image\"\n\n\t\"github.com/google/gxui/math\"\n)\n\ntype Texture interface {\n\tImage() image.Image\n\tSize() math.Size\n\tSizePixels() math.Size\n\tFlipY() bool\n\tSetFlipY(bool)\n}\n"
        },
        {
          "name": "theme.go",
          "type": "blob",
          "size": 0.8203125,
          "content": "// Copyright 2015 The Go Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage gxui\n\ntype Theme interface {\n\tDriver() Driver\n\tDefaultFont() Font\n\tSetDefaultFont(Font)\n\tDefaultMonospaceFont() Font\n\tSetDefaultMonospaceFont(Font)\n\tCreateBubbleOverlay() BubbleOverlay\n\tCreateButton() Button\n\tCreateCodeEditor() CodeEditor\n\tCreateDropDownList() DropDownList\n\tCreateImage() Image\n\tCreateLabel() Label\n\tCreateLinearLayout() LinearLayout\n\tCreateList() List\n\tCreatePanelHolder() PanelHolder\n\tCreateProgressBar() ProgressBar\n\tCreateScrollBar() ScrollBar\n\tCreateScrollLayout() ScrollLayout\n\tCreateSplitterLayout() SplitterLayout\n\tCreateTableLayout() TableLayout\n\tCreateTextBox() TextBox\n\tCreateTree() Tree\n\tCreateWindow(width, height int, title string) Window\n}\n"
        },
        {
          "name": "themes",
          "type": "tree",
          "content": null
        },
        {
          "name": "tooltip_controller.go",
          "type": "blob",
          "size": 2.6533203125,
          "content": "// Copyright 2015 The Go Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage gxui\n\nimport (\n\t\"github.com/google/gxui/math\"\n\t\"time\"\n)\n\ntype ToolTipCreator func(math.Point) Control\n\ntype toolTipTracker struct {\n\tcreator      ToolTipCreator\n\tcontrol      Control\n\tonEnterES    EventSubscription\n\tonExitES     EventSubscription\n\tonMoveES     EventSubscription\n\tlastPosition math.Point\n}\n\ntype ToolTipController struct {\n\tdriver        Driver\n\ttimer         *time.Timer\n\tbubbleOverlay BubbleOverlay\n\ttrackers      []*toolTipTracker\n\tshowing       *toolTipTracker\n}\n\nfunc (c *ToolTipController) beginTimer(tracker *toolTipTracker, timeout time.Duration) {\n\tif c.timer != nil {\n\t\tc.timer.Stop()\n\t\tc.timer = nil\n\t}\n\tif timeout > 0 {\n\t\tc.timer = time.AfterFunc(timeout, func() {\n\t\t\tc.driver.Call(func() { c.showToolTipForTracker(tracker) })\n\t\t})\n\t} else {\n\t\tc.showToolTipForTracker(tracker)\n\t}\n}\n\nfunc (c *ToolTipController) showToolTipForTracker(tracker *toolTipTracker) {\n\ttoolTip := tracker.creator(tracker.lastPosition)\n\tif toolTip != nil {\n\t\tat := TransformCoordinate(tracker.lastPosition, tracker.control, c.bubbleOverlay)\n\t\tc.ShowToolTip(toolTip, at)\n\t\tc.showing = tracker\n\t} else {\n\t\tc.hideToolTipForTracker(tracker)\n\t}\n}\n\nfunc (c *ToolTipController) hideToolTipForTracker(tracker *toolTipTracker) {\n\tif c.showing == tracker {\n\t\tc.bubbleOverlay.Hide()\n\t\tc.showing = nil\n\t}\n}\n\nfunc CreateToolTipController(bubbleOverlay BubbleOverlay, driver Driver) *ToolTipController {\n\treturn &ToolTipController{\n\t\tdriver:        driver,\n\t\tbubbleOverlay: bubbleOverlay,\n\t}\n}\n\nfunc (c *ToolTipController) AddToolTip(control Control, delaySeconds float32, creator ToolTipCreator) {\n\ttracker := &toolTipTracker{\n\t\tcontrol: control,\n\t\tcreator: creator,\n\t}\n\tduration := time.Duration(delaySeconds * float32(time.Second))\n\tbind := func() {\n\t\ttracker.onEnterES = control.OnMouseEnter(func(ev MouseEvent) {\n\t\t\ttracker.lastPosition = ev.Point\n\t\t\tc.beginTimer(tracker, duration)\n\t\t})\n\t\ttracker.onExitES = control.OnMouseExit(func(ev MouseEvent) {\n\t\t\tif c.timer != nil {\n\t\t\t\tc.timer.Stop()\n\t\t\t\tc.timer = nil\n\t\t\t}\n\t\t\tc.hideToolTipForTracker(tracker)\n\t\t})\n\t\ttracker.onMoveES = control.OnMouseMove(func(ev MouseEvent) {\n\t\t\ttracker.lastPosition = ev.Point\n\t\t\tc.beginTimer(tracker, duration)\n\t\t})\n\t}\n\tcontrol.OnAttach(bind)\n\tcontrol.OnDetach(func() {\n\t\tif c.timer != nil {\n\t\t\tc.timer.Stop()\n\t\t\tc.timer = nil\n\t\t}\n\t\ttracker.onEnterES.Unlisten()\n\t\ttracker.onExitES.Unlisten()\n\t\ttracker.onMoveES.Unlisten()\n\t})\n\tif control.Attached() {\n\t\tbind()\n\t}\n}\n\nfunc (c *ToolTipController) ShowToolTip(toolTip Control, at math.Point) {\n\tc.bubbleOverlay.Show(toolTip, at)\n}\n"
        },
        {
          "name": "tree.go",
          "type": "blob",
          "size": 3.0927734375,
          "content": "// Copyright 2015 The Go Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage gxui\n\nimport \"github.com/google/gxui/math\"\n\n// Tree is the interface of all controls that visualize a hierarchical tree\n// structure of items.\ntype Tree interface {\n\tFocusable\n\n\t// SetAdapter binds the specified TreeAdapter to this Tree control, replacing\n\t// any previously bound adapter.\n\tSetAdapter(TreeAdapter)\n\n\t// TreeAdapter returns the currently bound adapter.\n\tAdapter() TreeAdapter\n\n\t// Show makes the specified item visible, expanding the tree if necessary.\n\tShow(AdapterItem)\n\n\t// ExpandAll expands all tree nodes.\n\tExpandAll()\n\n\t// CollapseAll collapses all tree nodes.\n\tCollapseAll()\n\n\t// Selected returns the currently selected item.\n\tSelected() AdapterItem\n\n\t// Select makes the specified item selected. The tree will not automatically\n\t// expand to the newly selected item. If the Tree does not contain the\n\t// specified item, then Select returns false and the previous selection\n\t// remains unaltered.\n\tSelect(AdapterItem) bool\n\n\t// OnSelectionChanged registers the function f to be called when the selection\n\t// changes.\n\tOnSelectionChanged(f func(AdapterItem)) EventSubscription\n}\n\n// TreeNodeContainer is the interface used by nodes that can hold sub-nodes in the tree.\ntype TreeNodeContainer interface {\n\t// Count returns the number of immediate child nodes.\n\tCount() int\n\n\t// Node returns the i'th child TreeNode.\n\tNodeAt(i int) TreeNode\n\n\t// ItemIndex returns the index of the child equal to item, or the index of the\n\t// child that indirectly contains item, or if the item is not found under this\n\t// node, -1.\n\tItemIndex(item AdapterItem) int\n}\n\n// TreeNode is the interface used by nodes in the tree.\ntype TreeNode interface {\n\tTreeNodeContainer\n\n\t// Item returns the AdapterItem this node.\n\t// It is important for the TreeNode to return consistent AdapterItems for\n\t// the same data, so that selections can be persisted, or re-ordering\n\t// animations can be played when the dataset changes.\n\t// The AdapterItem returned must be equality-unique across the entire Adapter.\n\tItem() AdapterItem\n\n\t// Create returns a Control visualizing this node.\n\tCreate(theme Theme) Control\n}\n\n// TreeAdapter is an interface used to visualize a set of hierarchical items.\n// Users of the TreeAdapter should presume the data is unchanged until the\n// OnDataChanged or OnDataReplaced events are fired.\ntype TreeAdapter interface {\n\tTreeNodeContainer\n\n\t// Size returns the size that each of the item's controls will be displayed\n\t// at for the given theme.\n\tSize(Theme) math.Size\n\n\t// OnDataChanged registers f to be called when there is a partial change in\n\t// the items of the adapter. Scroll positions and selections should be\n\t// preserved if possible.\n\t// If recreateControls is true then each of the visible controls should be\n\t// recreated by re-calling Create().\n\tOnDataChanged(f func(recreateControls bool)) EventSubscription\n\n\t// OnDataReplaced registers f to be called when there is a complete\n\t// replacement of items in the adapter.\n\tOnDataReplaced(f func()) EventSubscription\n}\n"
        },
        {
          "name": "utils.go",
          "type": "blob",
          "size": 5.1162109375,
          "content": "// Copyright 2015 The Go Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage gxui\n\nimport (\n\t\"bytes\"\n\t\"fmt\"\n\t\"unicode/utf8\"\n\n\t\"github.com/google/gxui/math\"\n)\n\ntype ParentPoint struct {\n\tC Parent\n\tP math.Point\n}\n\ntype ControlPoint struct {\n\tC Control\n\tP math.Point\n}\n\ntype ControlPointList []ControlPoint\n\nfunc (l ControlPointList) Contains(c Control) bool {\n\t_, found := l.Find(c)\n\treturn found\n}\n\nfunc (l ControlPointList) Find(c Control) (math.Point, bool) {\n\tfor _, i := range l {\n\t\tif i.C == c {\n\t\t\treturn i.P, true\n\t\t}\n\t}\n\treturn math.Point{}, false\n}\n\nfunc ValidateHierarchy(p Parent) {\n\tfor _, c := range p.Children() {\n\t\tif p != c.Control.Parent() {\n\t\t\tpanic(fmt.Errorf(\"Child's parent is not as expected.\\nChild: %s\\nExpected parent: %s\",\n\t\t\t\tPath(c.Control), Path(p)))\n\t\t}\n\t\tif cp, ok := c.Control.(Parent); ok {\n\t\t\tValidateHierarchy(cp)\n\t\t}\n\t}\n}\n\nfunc CommonAncestor(a, b Control) Parent {\n\tseen := make(map[Parent]bool)\n\tif c, _ := a.(Parent); c != nil {\n\t\tseen[c] = true\n\t}\n\tfor a != nil {\n\t\tp := a.Parent()\n\t\tseen[p] = true\n\t\ta, _ = p.(Control)\n\t}\n\tif c, _ := b.(Parent); c != nil {\n\t\tif seen[c] {\n\t\t\treturn c\n\t\t}\n\t}\n\tfor b != nil {\n\t\tp := b.Parent()\n\t\tif seen[p] {\n\t\t\treturn p\n\t\t}\n\t\tb, _ = p.(Control)\n\t}\n\treturn nil\n}\n\nfunc TopControlsUnder(p math.Point, c Parent) ControlPointList {\n\tchildren := c.Children()\n\tfor i := len(children) - 1; i >= 0; i-- {\n\t\tchild := children[i]\n\t\tcp := p.Sub(child.Offset)\n\t\tif child.Control.ContainsPoint(cp) {\n\t\t\tl := ControlPointList{ControlPoint{child.Control, cp}}\n\t\t\tif cc, ok := child.Control.(Parent); ok {\n\t\t\t\tl = append(l, TopControlsUnder(cp, cc)...)\n\t\t\t}\n\t\t\treturn l\n\t\t}\n\t}\n\treturn ControlPointList{}\n}\n\nfunc ControlsUnder(p math.Point, c Parent) ControlPointList {\n\ttoVisit := []ParentPoint{ParentPoint{c, p}}\n\tl := ControlPointList{}\n\tfor len(toVisit) > 0 {\n\t\tc = toVisit[0].C\n\t\tp = toVisit[0].P\n\t\ttoVisit = toVisit[1:]\n\t\tfor _, child := range c.Children() {\n\t\t\tcp := p.Sub(child.Offset)\n\t\t\tif child.Control.ContainsPoint(cp) {\n\t\t\t\tl = append(l, ControlPoint{child.Control, cp})\n\t\t\t\tif cc, ok := child.Control.(Parent); ok {\n\t\t\t\t\ttoVisit = append(toVisit, ParentPoint{cc, cp})\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn l\n}\n\nfunc WindowToChild(coord math.Point, to Control) math.Point {\n\tc := to\n\tfor {\n\t\tp := c.Parent()\n\t\tif p == nil {\n\t\t\tpanic(\"Control's parent was nil\")\n\t\t}\n\t\tchild := p.Children().Find(c)\n\t\tif child == nil {\n\t\t\tDump(p)\n\t\t\tpanic(fmt.Errorf(\"Control's parent (%p %T) did not contain control (%p %T).\", &p, p, &c, c))\n\t\t}\n\t\tcoord = coord.Sub(child.Offset)\n\t\tif _, ok := p.(Window); ok {\n\t\t\treturn coord\n\t\t}\n\t\tc = p.(Control)\n\t}\n}\n\nfunc ChildToParent(coord math.Point, from Control, to Parent) math.Point {\n\tc := from\n\tfor {\n\t\tp := c.Parent()\n\t\tif p == nil {\n\t\t\tpanic(fmt.Errorf(\"Control detached: %s\", Path(c)))\n\t\t}\n\t\tchild := p.Children().Find(c)\n\t\tif child == nil {\n\t\t\tDump(p)\n\t\t\tpanic(fmt.Errorf(\"Control's parent (%p %T) did not contain control (%p %T).\", &p, p, &c, c))\n\t\t}\n\t\tcoord = coord.Add(child.Offset)\n\t\tif p == to {\n\t\t\treturn coord\n\t\t}\n\n\t\tif control, ok := p.(Control); ok {\n\t\t\tc = control\n\t\t} else {\n\t\t\tDump(p)\n\t\t\tpanic(fmt.Errorf(\"ChildToParent (%p %T) -> (%p %T) reached non-control parent (%p %T).\",\n\t\t\t\t&from, from, &to, to, &p, p))\n\t\t}\n\t}\n}\n\nfunc ParentToChild(coord math.Point, from Parent, to Control) math.Point {\n\treturn coord.Sub(ChildToParent(math.ZeroPoint, to, from))\n}\n\nfunc TransformCoordinate(coord math.Point, from, to Control) math.Point {\n\tif from == to {\n\t\treturn coord\n\t}\n\n\tancestor := CommonAncestor(from, to)\n\tif ancestor == nil {\n\t\tpanic(fmt.Errorf(\"No common ancestor between %s and %s\", Path(from), Path(to)))\n\t}\n\n\tif parent, ok := ancestor.(Control); !ok || parent != from {\n\t\tcoord = ChildToParent(coord, from, ancestor)\n\t}\n\tif parent, ok := ancestor.(Control); !ok || parent != to {\n\t\tcoord = ParentToChild(coord, ancestor, to)\n\t}\n\treturn coord\n}\n\n// FindControl performs a depth-first search of the controls starting from root,\n// calling test with each visited control. If test returns true then the search\n// is stopped and FindControl returns the Control passed to test. If no call to\n// test returns true then FindControl returns nil.\nfunc FindControl(root Parent, test func(Control) (found bool)) Control {\n\tif c, ok := root.(Control); ok && test(c) {\n\t\treturn c\n\t}\n\n\tfor _, child := range root.Children() {\n\t\tif test(child.Control) {\n\t\t\treturn child.Control\n\t\t}\n\t\tif parent, ok := child.Control.(Parent); ok {\n\t\t\tif c := FindControl(parent, test); c != nil {\n\t\t\t\treturn c\n\t\t\t}\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc WindowContaining(c Control) Window {\n\tfor {\n\t\tp := c.Parent()\n\t\tif p == nil {\n\t\t\tpanic(\"Control's parent was nil\")\n\t\t}\n\t\tif window, ok := p.(Window); ok {\n\t\t\treturn window\n\t\t}\n\t\tc = p.(Control)\n\t}\n}\n\nfunc SetFocus(focusable Focusable) {\n\twnd := WindowContaining(focusable)\n\twnd.SetFocus(focusable)\n}\n\nfunc StringToRuneArray(str string) []rune {\n\treturn bytes.Runes([]byte(str))\n}\n\nfunc RuneArrayToString(arr []rune) string {\n\ttmp := make([]byte, 8)\n\tenc := make([]byte, 0, len(arr))\n\toffset := 0\n\tfor _, r := range arr {\n\t\tsize := utf8.EncodeRune(tmp, r)\n\t\tenc = append(enc, tmp[:size]...)\n\t\toffset += size\n\t}\n\treturn string(enc)\n}\n"
        },
        {
          "name": "viewport.go",
          "type": "blob",
          "size": 3.666015625,
          "content": "// Copyright 2015 The Go Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage gxui\n\nimport (\n\t\"github.com/google/gxui/math\"\n)\n\ntype Viewport interface {\n\t// SizeDips returns the size of the viewport in device-independent pixels.\n\t// The ratio of pixels to DIPs is based on the screen density and scale\n\t// adjustments made with the SetScale method.\n\tSizeDips() math.Size\n\n\t// SetSizeDips sets the size of the viewport in device-independent pixels.\n\t// The ratio of pixels to DIPs is based on the screen density and scale\n\t// adjustments made with the SetScale method.\n\tSetSizeDips(math.Size)\n\n\t// SizePixels returns the size of the viewport in pixels.\n\tSizePixels() math.Size\n\n\t// Scale returns the display scaling for this viewport.\n\t// A scale of 1 is unscaled, 2 is twice the regular scaling.\n\tScale() float32\n\n\t// SetScale alters the display scaling for this viewport.\n\t// A scale of 1 is unscaled, 2 is twice the regular scaling.\n\tSetScale(float32)\n\n\t// Fullscreen returns true if the viewport was created full-screen.\n\tFullscreen() bool\n\n\t// Title returns the title of the window.\n\t// This is usually the text displayed at the top of the window.\n\tTitle() string\n\n\t// SetTitle changes the title of the window.\n\tSetTitle(string)\n\n\t// Position returns position of the window.\n\tPosition() math.Point\n\n\t// SetPosition changes position of the window.\n\tSetPosition(math.Point)\n\n\t// Show makes the window visible.\n\tShow()\n\n\t// Hide makes the window invisible.\n\tHide()\n\n\t// Close destroys the window.\n\t// Once the window is closed, no further calls should be made to it.\n\tClose()\n\n\t// SetCanvas changes the displayed content of the viewport to the specified\n\t// Canvas. As canvases are immutable once completed, every visual update of a\n\t// viewport will require a call to SetCanvas.\n\tSetCanvas(Canvas)\n\n\t// OnClose subscribes f to be called when the viewport closes.\n\tOnClose(f func()) EventSubscription\n\n\t// OnResize subscribes f to be called whenever the viewport changes size.\n\tOnResize(f func()) EventSubscription\n\n\t// OnMouseMove subscribes f to be called whenever the mouse cursor moves over\n\t// the viewport.\n\tOnMouseMove(f func(MouseEvent)) EventSubscription\n\n\t// OnMouseEnter subscribes f to be called whenever the mouse cursor enters the\n\t// viewport.\n\tOnMouseEnter(f func(MouseEvent)) EventSubscription\n\n\t// OnMouseEnter subscribes f to be called whenever the mouse cursor leaves the\n\t// viewport.\n\tOnMouseExit(f func(MouseEvent)) EventSubscription\n\n\t// OnMouseDown subscribes f to be called whenever a mouse button is pressed\n\t// while the cursor is inside the viewport.\n\tOnMouseDown(f func(MouseEvent)) EventSubscription\n\n\t// OnMouseUp subscribes f to be called whenever a mouse button is released\n\t// while the cursor is inside the viewport.\n\tOnMouseUp(f func(MouseEvent)) EventSubscription\n\n\t// OnMouseScroll subscribes f to be called whenever the mouse scroll wheel\n\t// turns while the cursor is inside the viewport.\n\tOnMouseScroll(f func(MouseEvent)) EventSubscription\n\n\t// OnKeyDown subscribes f to be called whenever a keyboard key is pressed\n\t// while the viewport has focus.\n\tOnKeyDown(f func(KeyboardEvent)) EventSubscription\n\n\t// OnKeyUp subscribes f to be called whenever a keyboard key is released\n\t// while the viewport has focus.\n\tOnKeyUp(f func(KeyboardEvent)) EventSubscription\n\n\t// OnKeyRepeat subscribes f to be called whenever a keyboard key-repeat event\n\t// is raised while the viewport has focus.\n\tOnKeyRepeat(f func(KeyboardEvent)) EventSubscription\n\n\t// OnKeyStroke subscribes f to be called whenever a keyboard key-stroke event\n\t// is raised while the viewport has focus.\n\tOnKeyStroke(f func(KeyStrokeEvent)) EventSubscription\n}\n"
        },
        {
          "name": "while_attached.go",
          "type": "blob",
          "size": 1.9287109375,
          "content": "// Copyright 2015 The Go Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage gxui\n\nimport (\n\t\"fmt\"\n\t\"reflect\"\n)\n\n// WhileAttached binds the function callback to event for the duration of c\n// being attached.\n// event can either be:\n//  • A event of the signature:    event(callback)\n//  • A function of the signature: func(callback) EventSubscription\nfunc WhileAttached(c Control, event, callback interface{}) {\n\tif err := verifyWhileAttachedSignature(event, callback); err != nil {\n\t\tpanic(err)\n\t}\n\tvar s EventSubscription\n\tbind := func() {\n\t\tif e, ok := event.(Event); ok {\n\t\t\ts = e.Listen(callback)\n\t\t} else {\n\t\t\tparams := []reflect.Value{reflect.ValueOf(callback)}\n\t\t\tres := reflect.ValueOf(event).Call(params)[0]\n\t\t\ts = res.Interface().(EventSubscription)\n\t\t}\n\t}\n\tif c.Attached() {\n\t\tbind()\n\t}\n\tc.OnAttach(bind)\n\tc.OnDetach(func() { s.Unlisten() })\n}\n\nfunc verifyWhileAttachedSignature(event, callback interface{}) error {\n\tif _, ok := event.(Event); ok {\n\t\treturn nil // Leave validation up to Event\n\t}\n\te, c := reflect.TypeOf(event), reflect.TypeOf(callback)\n\tif e.Kind() != reflect.Func {\n\t\treturn fmt.Errorf(\"event must be of type Event or func, got type %T\", event)\n\t}\n\tif c.Kind() != reflect.Func {\n\t\treturn fmt.Errorf(\"callback must be of type func, got type %T\", callback)\n\t}\n\tif c := e.NumIn(); c != 1 {\n\t\treturn fmt.Errorf(\"event as func must only take 1 parameter, got %d\", c)\n\t}\n\tif got := e.In(0); got != c {\n\t\treturn fmt.Errorf(\"event as func must only take 1 parameter of type callback, got type %s, callback type: %s\",\n\t\t\tgot, c)\n\t}\n\tif c := e.NumOut(); c != 1 {\n\t\treturn fmt.Errorf(\"event as func must only return 1 value, got %d\", c)\n\t}\n\tif got, expected := e.Out(0), reflect.TypeOf((*EventSubscription)(nil)).Elem(); got != expected {\n\t\treturn fmt.Errorf(\"event as func must only return 1 value of type %s, got type %s\",\n\t\t\texpected, got)\n\t}\n\treturn nil\n}\n"
        },
        {
          "name": "window.go",
          "type": "blob",
          "size": 2.5380859375,
          "content": "// Copyright 2015 The Go Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage gxui\n\nimport (\n\t\"github.com/google/gxui/math\"\n)\n\ntype Window interface {\n\tContainer\n\n\t// Title returns the title of the window.\n\t// This is usually the text displayed at the top of the window.\n\tTitle() string\n\n\t// SetTitle changes the title of the window.\n\tSetTitle(string)\n\n\t// Scale returns the display scaling for this window.\n\t// A scale of 1 is unscaled, 2 is twice the regular scaling.\n\tScale() float32\n\n\t// SetScale alters the display scaling for this window.\n\t// A scale of 1 is unscaled, 2 is twice the regular scaling.\n\tSetScale(float32)\n\n\t// Position returns position of the window.\n\tPosition() math.Point\n\n\t// SetPosition changes position of the window.\n\tSetPosition(math.Point)\n\n\t// Fullscreen returns true if the window is currently full-screen.\n\tFullscreen() bool\n\n\t// SetFullscreen makes the window either full-screen or windowed.\n\tSetFullscreen(bool)\n\n\t// Show makes the window visible.\n\tShow()\n\n\t// Hide makes the window invisible.\n\tHide()\n\n\t// Close destroys the window.\n\t// Once the window is closed, no further calls should be made to it.\n\tClose()\n\n\t// Focus returns the control currently with focus.\n\tFocus() Focusable\n\n\t// SetFocus gives the specified control Focus, returning true on success or\n\t// false if the control cannot be given focus.\n\tSetFocus(Control) bool\n\n\t// BackgroundBrush returns the brush used to draw the window background.\n\tBackgroundBrush() Brush\n\n\t// SetBackgroundBrush sets the brush used to draw the window background.\n\tSetBackgroundBrush(Brush)\n\n\t// BorderPen returns the pen used to draw the window border.\n\tBorderPen() Pen\n\n\t// SetBorderPen sets the pen used to draw the window border.\n\tSetBorderPen(Pen)\n\n\tClick(MouseEvent)\n\tDoubleClick(MouseEvent)\n\tKeyPress(KeyboardEvent)\n\tKeyStroke(KeyStrokeEvent)\n\n\t// Events\n\tOnClose(func()) EventSubscription\n\tOnResize(func()) EventSubscription\n\tOnClick(func(MouseEvent)) EventSubscription\n\tOnDoubleClick(func(MouseEvent)) EventSubscription\n\tOnMouseMove(func(MouseEvent)) EventSubscription\n\tOnMouseEnter(func(MouseEvent)) EventSubscription\n\tOnMouseExit(func(MouseEvent)) EventSubscription\n\tOnMouseDown(func(MouseEvent)) EventSubscription\n\tOnMouseUp(func(MouseEvent)) EventSubscription\n\tOnMouseScroll(func(MouseEvent)) EventSubscription\n\tOnKeyDown(func(KeyboardEvent)) EventSubscription\n\tOnKeyUp(func(KeyboardEvent)) EventSubscription\n\tOnKeyRepeat(func(KeyboardEvent)) EventSubscription\n\tOnKeyStroke(func(KeyStrokeEvent)) EventSubscription\n}\n"
        }
      ]
    }
  ]
}