{
  "metadata": {
    "timestamp": 1736567293959,
    "page": 894,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjkwMA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "unrolled/secure",
      "stars": 2287,
      "defaultBranch": "v1",
      "files": [
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.275390625,
          "content": "# Compiled Object files, Static and Dynamic libs (Shared Objects)\n*.o\n*.a\n*.so\n\n# Folders\n_obj\n_test\n\n# Architecture specific extensions/prefixes\n*.[568vq]\n[568vq].out\n\n*.cgo1.go\n*.cgo2.c\n_cgo_defun.c\n_cgo_gotypes.go\n_cgo_export.*\n\n_testmain.go\n\n*.exe\n*.test\n\n*.pem\n.DS_Store\n*.swp\n"
        },
        {
          "name": ".golangci.yaml",
          "type": "blob",
          "size": 0.49609375,
          "content": "run:\n  timeout: 10m\n  modules-download-mode: readonly\n  allow-parallel-runners: true\n\nlinters:\n  enable-all: true\n  disable:\n    - paralleltest\n    - gochecknoglobals\n    - exhaustruct\n    - wrapcheck\n    - tagliatelle\n    - depguard\n    - ireturn\n    - funlen\n    - varnamelen\n    - gomnd\n    - execinquery\n    - copyloopvar\n    - intrange\n    - gocognit\n    - lll\n    - cyclop\n    - gocyclo\n    - testpackage\n    - err113\n    - nestif\n    - maintidx\n    - contextcheck\n    - perfsprint\n    - exportloopref\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.0546875,
          "content": "The MIT License (MIT)\n\nCopyright (c) 2014 Cory Jacobsen\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of\nthis software and associated documentation files (the \"Software\"), to deal in\nthe Software without restriction, including without limitation the rights to\nuse, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of\nthe Software, and to permit persons to whom the Software is furnished to do so,\nsubject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS\nFOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR\nCOPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER\nIN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\nCONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n"
        },
        {
          "name": "Makefile",
          "type": "blob",
          "size": 0.43359375,
          "content": ".PHONY: help test ci\n.DEFAULT_GOAL := help\n\nhelp: ## Displays this help message.\n\t@awk 'BEGIN {FS = \":.*?## \"} /^[a-zA-Z_-]+:.*?## / {printf \"\\033[36m%-30s\\033[0m %s\\n\", $$1, $$2}' $(MAKEFILE_LIST)\n\ntest: ## Runs the tests, vetting, and golangci linter.\n\tgolangci-lint run ./...\n\tgo test -v -cover -race -count=1 ./...\n\tgo vet .\n\nci: ## Runs on the tests and vetting checks (specific for CI).\n\tgo test -cover -race -count=1 ./...\n\tgo vet ./...\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 15.98828125,
          "content": "# Secure [![GoDoc](https://pkg.go.dev/badge/github.com/unrolled/secure)](http://godoc.org/github.com/unrolled/secure) [![Test](https://github.com/unrolled/secure/actions/workflows/test.yaml/badge.svg)](https://github.com/unrolled/secure/actions)\n\nSecure is an HTTP middleware for Go that facilitates some quick security wins. It's a standard net/http [Handler](http://golang.org/pkg/net/http/#Handler), and can be used with many [frameworks](#integration-examples) or directly with Go's net/http package.\n\n## Usage\n\n~~~ go\n// main.go\npackage main\n\nimport (\n    \"net/http\"\n\n    \"github.com/unrolled/secure\"\n)\n\nvar myHandler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n    w.Write([]byte(\"hello world\"))\n})\n\nfunc main() {\n    secureMiddleware := secure.New(secure.Options{\n        AllowedHosts:          []string{\"example\\\\.com\", \".*\\\\.example\\\\.com\"},\n        AllowedHostsAreRegex:  true,\n        HostsProxyHeaders:     []string{\"X-Forwarded-Host\"},\n        SSLRedirect:           true,\n        SSLHost:               \"ssl.example.com\",\n        SSLProxyHeaders:       map[string]string{\"X-Forwarded-Proto\": \"https\"},\n        STSSeconds:            31536000,\n        STSIncludeSubdomains:  true,\n        STSPreload:            true,\n        FrameDeny:             true,\n        ContentTypeNosniff:    true,\n        BrowserXssFilter:      true,\n        ContentSecurityPolicy: \"script-src $NONCE\",\n    })\n\n    app := secureMiddleware.Handler(myHandler)\n    http.ListenAndServe(\"127.0.0.1:3000\", app)\n}\n~~~\n\nBe sure to include the Secure middleware as close to the top (beginning) as possible (but after logging and recovery). It's best to do the allowed hosts and SSL check before anything else.\n\nThe above example will only allow requests with a host name of 'example.com', or 'ssl.example.com'. Also if the request is not HTTPS, it will be redirected to HTTPS with the host name of 'ssl.example.com'.\nOnce those requirements are satisfied, it will add the following headers:\n~~~ go\nStrict-Transport-Security: 31536000; includeSubdomains; preload\nX-Frame-Options: DENY\nX-Content-Type-Options: nosniff\nX-XSS-Protection: 1; mode=block\nContent-Security-Policy: script-src 'nonce-a2ZobGFoZg=='\n~~~\n\n### Set the `IsDevelopment` option to `true` when developing!\nWhen `IsDevelopment` is true, the AllowedHosts, SSLRedirect, and STS header will not be in effect. This allows you to work in development/test mode and not have any annoying redirects to HTTPS (ie. development can happen on HTTP), or block `localhost` has a bad host.\n\n### Available options\nSecure comes with a variety of configuration options (Note: these are not the default option values. See the defaults below.):\n\n~~~ go\n// ...\ns := secure.New(secure.Options{\n    AllowedHosts: []string{\"ssl.example.com\"}, // AllowedHosts is a list of fully qualified domain names that are allowed. Default is empty list, which allows any and all host names.\n    AllowedHostsAreRegex: false,  // AllowedHostsAreRegex determines, if the provided AllowedHosts slice contains valid regular expressions. Default is false.\n    AllowRequestFunc: nil, // AllowRequestFunc is a custom function type that allows you to determine if the request should proceed or not based on your own custom logic. Default is nil.\n    HostsProxyHeaders: []string{\"X-Forwarded-Hosts\"}, // HostsProxyHeaders is a set of header keys that may hold a proxied hostname value for the request.\n    SSLRedirect: true, // If SSLRedirect is set to true, then only allow HTTPS requests. Default is false.\n    SSLTemporaryRedirect: false, // If SSLTemporaryRedirect is true, then a 307 will be used while redirecting. Default is false (301).\n    SSLHost: \"ssl.example.com\", // SSLHost is the host name that is used to redirect HTTP requests to HTTPS. Default is \"\", which indicates to use the same host.\n    SSLHostFunc: nil, // SSLHostFunc is a function pointer, the return value of the function is the host name that has same functionality as `SSHost`. Default is nil. If SSLHostFunc is nil, the `SSLHost` option will be used.\n    SSLProxyHeaders: map[string]string{\"X-Forwarded-Proto\": \"https\"}, // SSLProxyHeaders is set of header keys with associated values that would indicate a valid HTTPS request. Useful when using Nginx: `map[string]string{\"X-Forwarded-Proto\": \"https\"}`. Default is blank map.\n    STSSeconds: 31536000, // STSSeconds is the max-age of the Strict-Transport-Security header. Default is 0, which would NOT include the header.\n    STSIncludeSubdomains: true, // If STSIncludeSubdomains is set to true, the `includeSubdomains` will be appended to the Strict-Transport-Security header. Default is false.\n    STSPreload: true, // If STSPreload is set to true, the `preload` flag will be appended to the Strict-Transport-Security header. Default is false.\n    ForceSTSHeader: false, // STS header is only included when the connection is HTTPS. If you want to force it to always be added, set to true. `IsDevelopment` still overrides this. Default is false.\n    FrameDeny: true, // If FrameDeny is set to true, adds the X-Frame-Options header with the value of `DENY`. Default is false.\n    CustomFrameOptionsValue: \"SAMEORIGIN\", // CustomFrameOptionsValue allows the X-Frame-Options header value to be set with a custom value. This overrides the FrameDeny option. Default is \"\".\n    ContentTypeNosniff: true, // If ContentTypeNosniff is true, adds the X-Content-Type-Options header with the value `nosniff`. Default is false.\n    BrowserXssFilter: true, // If BrowserXssFilter is true, adds the X-XSS-Protection header with the value `1; mode=block`. Default is false.\n    CustomBrowserXssValue: \"1; report=https://example.com/xss-report\", // CustomBrowserXssValue allows the X-XSS-Protection header value to be set with a custom value. This overrides the BrowserXssFilter option. Default is \"\".\n    ContentSecurityPolicy: \"default-src 'self'\", // ContentSecurityPolicy allows the Content-Security-Policy header value to be set with a custom value. Default is \"\". Passing a template string will replace `$NONCE` with a dynamic nonce value of 16 bytes for each request which can be later retrieved using the Nonce function.\n    ReferrerPolicy: \"same-origin\", // ReferrerPolicy allows the Referrer-Policy header with the value to be set with a custom value. Default is \"\".\n    FeaturePolicy: \"vibrate 'none';\", // Deprecated: this header has been renamed to PermissionsPolicy. FeaturePolicy allows the Feature-Policy header with the value to be set with a custom value. Default is \"\".\n    PermissionsPolicy: \"fullscreen=(), geolocation=()\", // PermissionsPolicy allows the Permissions-Policy header with the value to be set with a custom value. Default is \"\".\n    CrossOriginOpenerPolicy: \"same-origin\", // CrossOriginOpenerPolicy allows the Cross-Origin-Opener-Policy header with the value to be set with a custom value. Default is \"\".\n    CrossOriginEmbedderPolicy: \"require-corp\", // CrossOriginEmbedderPolicy allows the Cross-Origin-Embedder-Policy header with the value to be set with a custom value. Default is \"\". \n    CrossOriginResourcePolicy: \"same-origin\", // CrossOriginResourcePolicy allows the Cross-Origin-Resource-Policy header with the value to be set with a custom value. Default is \"\".  \n    XDNSPrefetchControl: \"on\", // XDNSPrefetchControl allows the X-DNS-Prefetch-Control header to be set via \"on\" or \"off\" keyword. Default is \"\". \n    XPermittedCrossDomainPolicies: \"none\", // XPermittedCrossDomainPolicies allows the X-Permitted-Cross-Domain-Policies to be set with a custom value. Default is \"\".\n    IsDevelopment: true, // This will cause the AllowedHosts, SSLRedirect, and STSSeconds/STSIncludeSubdomains options to be ignored during development. When deploying to production, be sure to set this to false.\n})\n// ...\n~~~\n\n### Default options\nThese are the preset options for Secure:\n\n~~~ go\ns := secure.New()\n\n// Is the same as the default configuration options:\n\nl := secure.New(secure.Options{\n    AllowedHosts: []string,\n    AllowedHostsAreRegex: false,\n    AllowRequestFunc: nil,\n    HostsProxyHeaders: []string,\n    SSLRedirect: false,\n    SSLTemporaryRedirect: false,\n    SSLHost: \"\",\n    SSLProxyHeaders: map[string]string{},\n    STSSeconds: 0,\n    STSIncludeSubdomains: false,\n    STSPreload: false,\n    ForceSTSHeader: false,\n    FrameDeny: false,\n    CustomFrameOptionsValue: \"\",\n    ContentTypeNosniff: false,\n    BrowserXssFilter: false,\n    ContentSecurityPolicy: \"\",\n    PublicKey: \"\",\n    ReferrerPolicy: \"\",\n    FeaturePolicy: \"\",\n    PermissionsPolicy: \"\",\n    CrossOriginOpenerPolicy: \"\",\n    CrossOriginEmbedderPolicy: \"\",\n    CrossOriginResourcePolicy: \"\",\n    XDNSPrefetchControl: \"\",\n    XPermittedCrossDomainPolicies: \"\",\n    IsDevelopment: false,\n})\n~~~\nThe default bad host handler returns the following error:\n~~~ go\nhttp.Error(w, \"Bad Host\", http.StatusInternalServerError)\n~~~\nCall `secure.SetBadHostHandler` to set your own custom handler.\n\nThe default bad request handler returns the following error:\n~~~ go\nhttp.Error(w, \"Bad Request\", http.StatusBadRequest)\n~~~\nCall `secure.SetBadRequestHandler` to set your own custom handler.\n\n### Allow Request Function\nSecure allows you to set a custom function (`func(r *http.Request) bool`) for the `AllowRequestFunc` option. You can use this function as a custom filter to allow the request to continue or simply reject it. This can be handy if you need to do any dynamic filtering on any of the request properties. It should be noted that this function will be called on every request, so be sure to make your checks quick and not relying on time consuming external calls (or you will be slowing down all requests). See above on how to set a custom handler for the rejected requests.\n\n### Redirecting HTTP to HTTPS\nIf you want to redirect all HTTP requests to HTTPS, you can use the following example.\n\n~~~ go\n// main.go\npackage main\n\nimport (\n    \"log\"\n    \"net/http\"\n\n    \"github.com/unrolled/secure\"\n)\n\nvar myHandler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n    w.Write([]byte(\"hello world\"))\n})\n\nfunc main() {\n    secureMiddleware := secure.New(secure.Options{\n        SSLRedirect: true,\n        SSLHost:     \"localhost:8443\", // This is optional in production. The default behavior is to just redirect the request to the HTTPS protocol. Example: http://github.com/some_page would be redirected to https://github.com/some_page.\n    })\n\n    app := secureMiddleware.Handler(myHandler)\n\n    // HTTP\n    go func() {\n        log.Fatal(http.ListenAndServe(\":8080\", app))\n    }()\n\n    // HTTPS\n    // To generate a development cert and key, run the following from your *nix terminal:\n    // go run $GOROOT/src/crypto/tls/generate_cert.go --host=\"localhost\"\n    log.Fatal(http.ListenAndServeTLS(\":8443\", \"cert.pem\", \"key.pem\", app))\n}\n~~~\n\n### Strict Transport Security\nThe STS header will only be sent on verified HTTPS connections (and when `IsDevelopment` is false). Be sure to set the `SSLProxyHeaders` option if your application is behind a proxy to ensure the proper behavior. If you need the STS header for all HTTP and HTTPS requests (which you [shouldn't](http://tools.ietf.org/html/rfc6797#section-7.2)), you can use the `ForceSTSHeader` option. Note that if `IsDevelopment` is true, it will still disable this header even when `ForceSTSHeader` is set to true.\n\n* The `preload` flag is required for domain inclusion in Chrome's [preload](https://hstspreload.appspot.com/) list.\n\n### Content Security Policy\nYou can utilize the CSP Builder to create your policies:\n\n~~~ go\nimport (\n\t\"github.com/unrolled/secure\"\n\t\"github.com/unrolled/secure/cspbuilder\"\n)\n\ncspBuilder := cspbuilder.Builder{\n\tDirectives: map[string][]string{\n\t\tcspbuilder.DefaultSrc: {\"self\"},\n\t\tcspbuilder.ScriptSrc:  {\"self\", \"www.google-analytics.com\"},\n\t\tcspbuilder.ImgSrc:     {\"*\"},\n\t},\n}\n\nopt := secure.Options{\n\tContentSecurityPolicy: cspBuilder.MustBuild(),\n}\n~~~\n\n## Integration examples\n\n### [chi](https://github.com/pressly/chi)\n~~~ go\n// main.go\npackage main\n\nimport (\n    \"net/http\"\n\n    \"github.com/pressly/chi\"\n    \"github.com/unrolled/secure\"\n)\n\nfunc main() {\n    secureMiddleware := secure.New(secure.Options{\n        FrameDeny: true,\n    })\n\n    r := chi.NewRouter()\n    r.Use(secureMiddleware.Handler)\n\n    r.Get(\"/\", func(w http.ResponseWriter, r *http.Request) {\n        w.Write([]byte(\"X-Frame-Options header is now `DENY`.\"))\n    })\n\n    http.ListenAndServe(\"127.0.0.1:3000\", r)\n}\n~~~\n\n### [Echo](https://github.com/labstack/echo)\n~~~ go\n// main.go\npackage main\n\nimport (\n    \"net/http\"\n\n    \"github.com/labstack/echo\"\n    \"github.com/unrolled/secure\"\n)\n\nfunc main() {\n    secureMiddleware := secure.New(secure.Options{\n        FrameDeny: true,\n    })\n\n    e := echo.New()\n    e.GET(\"/\", func(c echo.Context) error {\n        return c.String(http.StatusOK, \"X-Frame-Options header is now `DENY`.\")\n    })\n\n    e.Use(echo.WrapMiddleware(secureMiddleware.Handler))\n    e.Logger.Fatal(e.Start(\"127.0.0.1:3000\"))\n}\n~~~\n\n### [Gin](https://github.com/gin-gonic/gin)\n~~~ go\n// main.go\npackage main\n\nimport (\n    \"github.com/gin-gonic/gin\"\n    \"github.com/unrolled/secure\"\n)\n\nfunc main() {\n    secureMiddleware := secure.New(secure.Options{\n        FrameDeny: true,\n    })\n    secureFunc := func() gin.HandlerFunc {\n        return func(c *gin.Context) {\n            err := secureMiddleware.Process(c.Writer, c.Request)\n\n            // If there was an error, do not continue.\n            if err != nil {\n                c.Abort()\n                return\n            }\n\n            // Avoid header rewrite if response is a redirection.\n            if status := c.Writer.Status(); status > 300 && status < 399 {\n                c.Abort()\n            }\n        }\n    }()\n\n    router := gin.Default()\n    router.Use(secureFunc)\n\n    router.GET(\"/\", func(c *gin.Context) {\n        c.String(200, \"X-Frame-Options header is now `DENY`.\")\n    })\n\n    router.Run(\"127.0.0.1:3000\")\n}\n~~~\n\n### [Goji](https://github.com/zenazn/goji)\n~~~ go\n// main.go\npackage main\n\nimport (\n    \"net/http\"\n\n    \"github.com/unrolled/secure\"\n    \"github.com/zenazn/goji\"\n    \"github.com/zenazn/goji/web\"\n)\n\nfunc main() {\n    secureMiddleware := secure.New(secure.Options{\n        FrameDeny: true,\n    })\n\n    goji.Get(\"/\", func(c web.C, w http.ResponseWriter, req *http.Request) {\n        w.Write([]byte(\"X-Frame-Options header is now `DENY`.\"))\n    })\n    goji.Use(secureMiddleware.Handler)\n    goji.Serve() // Defaults to \":8000\".\n}\n~~~\n\n### [Iris](https://github.com/kataras/iris)\n~~~ go\n//main.go\npackage main\n\nimport (\n    \"github.com/kataras/iris/v12\"\n    \"github.com/unrolled/secure\"\n)\n\nfunc main() {\n    app := iris.New()\n\n    secureMiddleware := secure.New(secure.Options{\n        FrameDeny: true,\n    })\n\n    app.Use(iris.FromStd(secureMiddleware.HandlerFuncWithNext))\n    // Identical to:\n    // app.Use(func(ctx iris.Context) {\n    //     err := secureMiddleware.Process(ctx.ResponseWriter(), ctx.Request())\n    //\n    //     // If there was an error, do not continue.\n    //     if err != nil {\n    //         return\n    //     }\n    //\n    //     ctx.Next()\n    // })\n\n    app.Get(\"/home\", func(ctx iris.Context) {\n        ctx.Writef(\"X-Frame-Options header is now `%s`.\", \"DENY\")\n    })\n\n    app.Listen(\":8080\")\n}\n~~~\n\n### [Mux](https://github.com/gorilla/mux)\n~~~ go\n//main.go\npackage main\n\nimport (\n    \"log\"\n    \"net/http\"\n\n    \"github.com/gorilla/mux\"\n    \"github.com/unrolled/secure\"\n)\n\nfunc main() {\n    secureMiddleware := secure.New(secure.Options{\n        FrameDeny: true,\n    })\n\n    r := mux.NewRouter()\n    r.Use(secureMiddleware.Handler)\n    http.Handle(\"/\", r)\n    log.Fatal(http.ListenAndServe(fmt.Sprintf(\":%d\", 8080), nil))\n}\n~~~\n\n### [Negroni](https://github.com/urfave/negroni)\nNote this implementation has a special helper function called `HandlerFuncWithNext`.\n~~~ go\n// main.go\npackage main\n\nimport (\n    \"net/http\"\n\n    \"github.com/urfave/negroni\"\n    \"github.com/unrolled/secure\"\n)\n\nfunc main() {\n    mux := http.NewServeMux()\n    mux.HandleFunc(\"/\", func(w http.ResponseWriter, req *http.Request) {\n        w.Write([]byte(\"X-Frame-Options header is now `DENY`.\"))\n    })\n\n    secureMiddleware := secure.New(secure.Options{\n        FrameDeny: true,\n    })\n\n    n := negroni.Classic()\n    n.Use(negroni.HandlerFunc(secureMiddleware.HandlerFuncWithNext))\n    n.UseHandler(mux)\n\n    n.Run(\"127.0.0.1:3000\")\n}\n~~~\n"
        },
        {
          "name": "csp.go",
          "type": "blob",
          "size": 1.1201171875,
          "content": "package secure\n\nimport (\n\t\"context\"\n\t\"crypto/rand\"\n\t\"encoding/base64\"\n\t\"io\"\n\t\"net/http\"\n)\n\ntype key int\n\nconst cspNonceKey key = iota\n\n// CSPNonce returns the nonce value associated with the present request.\n// If no nonce has been generated it returns an empty string.\nfunc CSPNonce(c context.Context) string {\n\tif val, ok := c.Value(cspNonceKey).(string); ok {\n\t\treturn val\n\t}\n\n\treturn \"\"\n}\n\n// WithCSPNonce returns a context derived from ctx containing the given nonce as a value.\n//\n// This is intended for testing or more advanced use-cases;\n// For ordinary HTTP handlers, clients can rely on this package's middleware to populate the CSP nonce in the context.\nfunc WithCSPNonce(ctx context.Context, nonce string) context.Context {\n\treturn context.WithValue(ctx, cspNonceKey, nonce)\n}\n\nfunc withCSPNonce(r *http.Request, nonce string) *http.Request {\n\treturn r.WithContext(WithCSPNonce(r.Context(), nonce))\n}\n\nfunc cspRandNonce() string {\n\tvar buf [cspNonceSize]byte\n\n\t_, err := io.ReadFull(rand.Reader, buf[:])\n\tif err != nil {\n\t\tpanic(\"CSP Nonce rand.Reader failed\" + err.Error())\n\t}\n\n\treturn base64.RawStdEncoding.EncodeToString(buf[:])\n}\n"
        },
        {
          "name": "csp_test.go",
          "type": "blob",
          "size": 1.7734375,
          "content": "package secure\n\nimport (\n\t\"context\"\n\t\"encoding/base64\"\n\t\"fmt\"\n\t\"net/http\"\n\t\"net/http/httptest\"\n\t\"strings\"\n\t\"testing\"\n)\n\n//nolint:gochecknoglobals\nvar cspHandler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t_, _ = w.Write([]byte(CSPNonce(r.Context())))\n})\n\nfunc TestCSPNonce(t *testing.T) {\n\tcsp := \"default-src 'self' $NONCE; script-src 'strict-dynamic' $NONCE\"\n\tcases := []struct {\n\t\toptions Options\n\t\theaders []string\n\t}{\n\t\t{Options{ContentSecurityPolicy: csp}, []string{\"Content-Security-Policy\"}},\n\t\t{Options{ContentSecurityPolicyReportOnly: csp}, []string{\"Content-Security-Policy-Report-Only\"}},\n\t\t{\n\t\t\tOptions{ContentSecurityPolicy: csp, ContentSecurityPolicyReportOnly: csp},\n\t\t\t[]string{\"Content-Security-Policy\", \"Content-Security-Policy-Report-Only\"},\n\t\t},\n\t}\n\n\tfor _, c := range cases {\n\t\ts := New(c.options)\n\n\t\tres := httptest.NewRecorder()\n\t\treq, _ := http.NewRequestWithContext(context.Background(), http.MethodGet, \"/foo\", nil)\n\n\t\ts.Handler(cspHandler).ServeHTTP(res, req)\n\n\t\texpect(t, res.Code, http.StatusOK)\n\n\t\tfor _, header := range c.headers {\n\t\t\tcsp := res.Header().Get(header)\n\t\t\texpect(t, strings.Count(csp, \"'nonce-\"), 2)\n\n\t\t\tnonce := strings.Split(strings.Split(csp, \"'\")[3], \"-\")[1]\n\t\t\t// Test that the context has the CSP nonce, but only during the request.\n\t\t\texpect(t, res.Body.String(), nonce)\n\t\t\texpect(t, CSPNonce(req.Context()), \"\")\n\n\t\t\t_, err := base64.RawStdEncoding.DecodeString(nonce)\n\t\t\texpect(t, err, nil)\n\n\t\t\texpect(t, csp, fmt.Sprintf(\"default-src 'self' 'nonce-%[1]s'; script-src 'strict-dynamic' 'nonce-%[1]s'\", nonce))\n\t\t}\n\t}\n}\n\nfunc TestWithCSPNonce(t *testing.T) {\n\treq, _ := http.NewRequestWithContext(context.Background(), http.MethodGet, \"/foo\", nil)\n\n\tnonce := \"jdgKGHkbnd+/\"\n\n\texpect(t, CSPNonce(withCSPNonce(req, nonce).Context()), nonce)\n}\n"
        },
        {
          "name": "cspbuilder",
          "type": "tree",
          "content": null
        },
        {
          "name": "doc.go",
          "type": "blob",
          "size": 0.572265625,
          "content": "/*\nPackage secure is an HTTP middleware for Go that facilitates some quick security wins.\n\n\tpackage main\n\n\timport (\n\t    \"net/http\"\n\n\t    \"github.com/unrolled/secure\"\n\t)\n\n\tvar myHandler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t    w.Write([]byte(\"hello world\"))\n\t})\n\n\tfunc main() {\n\t    secureMiddleware := secure.New(secure.Options{\n\t        AllowedHosts: []string{\"www.example.com\", \"sub.example.com\"},\n\t        SSLRedirect:  true,\n\t    })\n\n\t    app := secureMiddleware.Handler(myHandler)\n\t    http.ListenAndServe(\"127.0.0.1:3000\", app)\n\t}\n*/\npackage secure\n"
        },
        {
          "name": "go.mod",
          "type": "blob",
          "size": 0.0419921875,
          "content": "module github.com/unrolled/secure\n\ngo 1.13\n"
        },
        {
          "name": "go.sum",
          "type": "blob",
          "size": 0,
          "content": ""
        },
        {
          "name": "secure.go",
          "type": "blob",
          "size": 20.7607421875,
          "content": "package secure\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"net/http\"\n\t\"regexp\"\n\t\"strings\"\n)\n\ntype secureCtxKey string\n\nconst (\n\tstsHeader                    = \"Strict-Transport-Security\"\n\tstsSubdomainString           = \"; includeSubDomains\"\n\tstsPreloadString             = \"; preload\"\n\tframeOptionsHeader           = \"X-Frame-Options\"\n\tframeOptionsValue            = \"DENY\"\n\tcontentTypeHeader            = \"X-Content-Type-Options\"\n\tcontentTypeValue             = \"nosniff\"\n\txssProtectionHeader          = \"X-XSS-Protection\"\n\txssProtectionValue           = \"1; mode=block\"\n\tcspHeader                    = \"Content-Security-Policy\"\n\tcspReportOnlyHeader          = \"Content-Security-Policy-Report-Only\"\n\thpkpHeader                   = \"Public-Key-Pins\"\n\treferrerPolicyHeader         = \"Referrer-Policy\"\n\tfeaturePolicyHeader          = \"Feature-Policy\"\n\tpermissionsPolicyHeader      = \"Permissions-Policy\"\n\tcoopHeader                   = \"Cross-Origin-Opener-Policy\"\n\tcoepHeader                   = \"Cross-Origin-Embedder-Policy\"\n\tcorpHeader                   = \"Cross-Origin-Resource-Policy\"\n\tdnsPreFetchControlHeader     = \"X-DNS-Prefetch-Control\"\n\tpermittedCrossDomainPolicies = \"X-Permitted-Cross-Domain-Policies\"\n\tctxDefaultSecureHeaderKey    = secureCtxKey(\"SecureResponseHeader\")\n\tcspNonceSize                 = 16\n)\n\n// SSLHostFunc is a custom function type that can be used to dynamically set the SSL host of a request.\ntype SSLHostFunc func(host string) (newHost string)\n\n// AllowRequestFunc is a custom function type that can be used to dynamically determine if a request should proceed or not.\ntype AllowRequestFunc func(r *http.Request) bool\n\nfunc defaultBadHostHandler(w http.ResponseWriter, _ *http.Request) {\n\thttp.Error(w, \"Bad Host\", http.StatusInternalServerError)\n}\n\nfunc defaultBadRequestHandler(w http.ResponseWriter, _ *http.Request) {\n\thttp.Error(w, \"Bad Request\", http.StatusBadRequest)\n}\n\n// Options is a struct for specifying configuration options for the secure.Secure middleware.\ntype Options struct {\n\t// If BrowserXssFilter is true, adds the X-XSS-Protection header with the value `1; mode=block`. Default is false.\n\tBrowserXssFilter bool //nolint:stylecheck,revive\n\t// If ContentTypeNosniff is true, adds the X-Content-Type-Options header with the value `nosniff`. Default is false.\n\tContentTypeNosniff bool\n\t// If ForceSTSHeader is set to true, the STS header will be added even when the connection is HTTP. Default is false.\n\tForceSTSHeader bool\n\t// If FrameDeny is set to true, adds the X-Frame-Options header with the value of `DENY`. Default is false.\n\tFrameDeny bool\n\t// When developing, the AllowedHosts, SSL, and STS options can cause some unwanted effects. Usually testing happens on http, not https, and on localhost, not your production domain... so set this to true for dev environment.\n\t// If you would like your development environment to mimic production with complete Host blocking, SSL redirects, and STS headers, leave this as false. Default if false.\n\tIsDevelopment bool\n\t// nonceEnabled is used internally for dynamic nouces.\n\tnonceEnabled bool\n\t// If SSLRedirect is set to true, then only allow https requests. Default is false.\n\tSSLRedirect bool\n\t// If SSLForceHost is true and SSLHost is set, requests will be forced to use SSLHost even the ones that are already using SSL. Default is false.\n\tSSLForceHost bool\n\t// If SSLTemporaryRedirect is true, then a 307 will be used while redirecting. Default is false (301).\n\tSSLTemporaryRedirect bool\n\t// If STSIncludeSubdomains is set to true, the `includeSubdomains` will be appended to the Strict-Transport-Security header. Default is false.\n\tSTSIncludeSubdomains bool\n\t// If STSPreload is set to true, the `preload` flag will be appended to the Strict-Transport-Security header. Default is false.\n\tSTSPreload bool\n\t// ContentSecurityPolicy allows the Content-Security-Policy header value to be set with a custom value. Default is \"\".\n\tContentSecurityPolicy string\n\t// ContentSecurityPolicyReportOnly allows the Content-Security-Policy-Report-Only header value to be set with a custom value. Default is \"\".\n\tContentSecurityPolicyReportOnly string\n\t// CustomBrowserXssValue allows the X-XSS-Protection header value to be set with a custom value. This overrides the BrowserXssFilter option. Default is \"\".\n\tCustomBrowserXssValue string //nolint:stylecheck,revive\n\t// Passing a template string will replace `$NONCE` with a dynamic nonce value of 16 bytes for each request which can be later retrieved using the Nonce function.\n\t// Eg: script-src $NONCE -> script-src 'nonce-a2ZobGFoZg=='\n\t// CustomFrameOptionsValue allows the X-Frame-Options header value to be set with a custom value. This overrides the FrameDeny option. Default is \"\".\n\tCustomFrameOptionsValue string\n\t// ReferrerPolicy allows sites to control when browsers will pass the Referer header to other sites. Default is \"\".\n\tReferrerPolicy string\n\t// FeaturePolicy allows to selectively enable and disable use of various browser features and APIs. Default is \"\".\n\t// Deprecated: This header has been renamed to Permissions-Policy.\n\tFeaturePolicy string\n\t// PermissionsPolicy allows to selectively enable and disable use of various browser features and APIs. Default is \"\".\n\tPermissionsPolicy string\n\t// CrossOriginOpenerPolicy allows you to ensure a top-level document does not share a browsing context group with cross-origin documents. Default is \"\".\n\t// Reference: https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cross-Origin-Opener-Policy\n\tCrossOriginOpenerPolicy string\n\t// CrossOriginResourcePolicy header blocks others from loading your resources cross-origin in some cases.\n\t// Reference https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cross-Origin-Opener-Policy\n\tCrossOriginResourcePolicy string\n\t// CrossOriginEmbedderPolicy header helps control what resources can be loaded cross-origin.\n\t// Reference https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cross-Origin-Embedder-Policy\n\tCrossOriginEmbedderPolicy string\n\t// XDNSPrefetchControl header helps control DNS prefetching, which can improve user privacy at the expense of performance.\n\t// Reference: https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-DNS-Prefetch-Control\n\tXDNSPrefetchControl string\n\t// XPermittedCrossDomainPolicies header tells some clients (mostly Adobe products) your domain's policy for loading cross-domain content.\n\t// Reference: https://owasp.org/www-project-secure-headers/\n\tXPermittedCrossDomainPolicies string\n\t// SSLHost is the host name that is used to redirect http requests to https. Default is \"\", which indicates to use the same host.\n\tSSLHost string\n\t// AllowedHosts is a slice of fully qualified domain names that are allowed. Default is an empty slice, which allows any and all host names.\n\tAllowedHosts []string\n\t// AllowedHostsAreRegex determines, if the provided `AllowedHosts` slice contains valid regular expressions. If this flag is set to true, every request's host will be checked against these expressions. Default is false.\n\tAllowedHostsAreRegex bool\n\t// AllowRequestFunc is a custom function that allows you to determine if the request should proceed or not based on your own custom logic. Default is nil.\n\tAllowRequestFunc AllowRequestFunc `json:\"-\" toml:\"-\" yaml:\"-\"`\n\t// HostsProxyHeaders is a set of header keys that may hold a proxied hostname value for the request.\n\tHostsProxyHeaders []string\n\t// SSLHostFunc is a function pointer, the return value of the function is the host name that has same functionality as `SSHost`. Default is nil.\n\t// If SSLHostFunc is nil, the `SSLHost` option will be used.\n\tSSLHostFunc *SSLHostFunc `json:\"-\" toml:\"-\" yaml:\"-\"`\n\t// SSLProxyHeaders is set of header keys with associated values that would indicate a valid https request. Useful when using Nginx: `map[string]string{\"X-Forwarded-Proto\": \"https\"}`. Default is blank map.\n\tSSLProxyHeaders map[string]string\n\t// STSSeconds is the max-age of the Strict-Transport-Security header. Default is 0, which would NOT include the header.\n\tSTSSeconds int64\n\t// SecureContextKey allows a custom key to be specified for context storage.\n\tSecureContextKey string\n}\n\n// Secure is a middleware that helps setup a few basic security features. A single secure.Options struct can be\n// provided to configure which features should be enabled, and the ability to override a few of the default values.\ntype Secure struct {\n\t// Customize Secure with an Options struct.\n\topt Options\n\n\t// badHostHandler is the handler used when an incorrect host is passed in.\n\tbadHostHandler http.Handler\n\n\t// badRequestHandler is the handler used when the AllowRequestFunc rejects a request.\n\tbadRequestHandler http.Handler\n\n\t// cRegexAllowedHosts saves the compiled regular expressions of the AllowedHosts\n\t// option for subsequent use in processRequest\n\tcRegexAllowedHosts []*regexp.Regexp\n\n\t// ctxSecureHeaderKey is the key used for context storage for request modification.\n\tctxSecureHeaderKey secureCtxKey\n}\n\n// New constructs a new Secure instance with the supplied options.\nfunc New(options ...Options) *Secure {\n\tvar o Options\n\tif len(options) == 0 {\n\t\to = Options{}\n\t} else {\n\t\to = options[0]\n\t}\n\n\to.ContentSecurityPolicy = strings.ReplaceAll(o.ContentSecurityPolicy, \"$NONCE\", \"'nonce-%[1]s'\")\n\to.ContentSecurityPolicyReportOnly = strings.ReplaceAll(o.ContentSecurityPolicyReportOnly, \"$NONCE\", \"'nonce-%[1]s'\")\n\n\to.nonceEnabled = strings.Contains(o.ContentSecurityPolicy, \"%[1]s\") || strings.Contains(o.ContentSecurityPolicyReportOnly, \"%[1]s\")\n\n\ts := &Secure{\n\t\topt:               o,\n\t\tbadHostHandler:    http.HandlerFunc(defaultBadHostHandler),\n\t\tbadRequestHandler: http.HandlerFunc(defaultBadRequestHandler),\n\t}\n\n\tif s.opt.AllowedHostsAreRegex {\n\t\t// Test for invalid regular expressions in AllowedHosts\n\t\tfor _, allowedHost := range o.AllowedHosts {\n\t\t\tregex, err := regexp.Compile(fmt.Sprintf(\"^%s$\", allowedHost))\n\t\t\tif err != nil {\n\t\t\t\tpanic(fmt.Sprintf(\"Error parsing AllowedHost: %s\", err))\n\t\t\t}\n\n\t\t\ts.cRegexAllowedHosts = append(s.cRegexAllowedHosts, regex)\n\t\t}\n\t}\n\n\ts.ctxSecureHeaderKey = ctxDefaultSecureHeaderKey\n\tif len(s.opt.SecureContextKey) > 0 {\n\t\ts.ctxSecureHeaderKey = secureCtxKey(s.opt.SecureContextKey)\n\t}\n\n\treturn s\n}\n\n// SetBadHostHandler sets the handler to call when secure rejects the host name.\nfunc (s *Secure) SetBadHostHandler(handler http.Handler) {\n\ts.badHostHandler = handler\n}\n\n// SetBadRequestHandler sets the handler to call when the AllowRequestFunc rejects a request.\nfunc (s *Secure) SetBadRequestHandler(handler http.Handler) {\n\ts.badRequestHandler = handler\n}\n\n// Handler implements the http.HandlerFunc for integration with the standard net/http lib.\nfunc (s *Secure) Handler(h http.Handler) http.Handler {\n\treturn http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\t// Let secure process the request. If it returns an error,\n\t\t// that indicates the request should not continue.\n\t\tresponseHeader, r, err := s.processRequest(w, r)\n\t\taddResponseHeaders(responseHeader, w)\n\n\t\t// If there was an error, do not continue.\n\t\tif err != nil {\n\t\t\treturn\n\t\t}\n\n\t\th.ServeHTTP(w, r)\n\t})\n}\n\n// HandlerForRequestOnly implements the http.HandlerFunc for integration with the standard net/http lib.\n// Note that this is for requests only and will not write any headers.\nfunc (s *Secure) HandlerForRequestOnly(h http.Handler) http.Handler {\n\treturn http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\t// Let secure process the request. If it returns an error,\n\t\t// that indicates the request should not continue.\n\t\tresponseHeader, r, err := s.processRequest(w, r)\n\t\tif err != nil {\n\t\t\treturn\n\t\t}\n\n\t\t// Save response headers in the request context.\n\t\tctx := context.WithValue(r.Context(), s.ctxSecureHeaderKey, responseHeader)\n\n\t\t// No headers will be written to the ResponseWriter.\n\t\th.ServeHTTP(w, r.WithContext(ctx))\n\t})\n}\n\n// HandlerFuncWithNext is a special implementation for Negroni, but could be used elsewhere.\nfunc (s *Secure) HandlerFuncWithNext(w http.ResponseWriter, r *http.Request, next http.HandlerFunc) {\n\t// Let secure process the request. If it returns an error,\n\t// that indicates the request should not continue.\n\tresponseHeader, r, err := s.processRequest(w, r)\n\taddResponseHeaders(responseHeader, w)\n\n\t// If there was an error, do not call next.\n\tif err == nil && next != nil {\n\t\tnext(w, r)\n\t}\n}\n\n// HandlerFuncWithNextForRequestOnly is a special implementation for Negroni, but could be used elsewhere.\n// Note that this is for requests only and will not write any headers.\nfunc (s *Secure) HandlerFuncWithNextForRequestOnly(w http.ResponseWriter, r *http.Request, next http.HandlerFunc) {\n\t// Let secure process the request. If it returns an error,\n\t// that indicates the request should not continue.\n\tresponseHeader, r, err := s.processRequest(w, r)\n\n\t// If there was an error, do not call next.\n\tif err == nil && next != nil {\n\t\t// Save response headers in the request context\n\t\tctx := context.WithValue(r.Context(), s.ctxSecureHeaderKey, responseHeader)\n\n\t\t// No headers will be written to the ResponseWriter.\n\t\tnext(w, r.WithContext(ctx))\n\t}\n}\n\n// addResponseHeaders Adds the headers from 'responseHeader' to the response.\nfunc addResponseHeaders(responseHeader http.Header, w http.ResponseWriter) {\n\tfor key, values := range responseHeader {\n\t\tfor _, value := range values {\n\t\t\tw.Header().Set(key, value)\n\t\t}\n\t}\n}\n\n// Process runs the actual checks and writes the headers in the ResponseWriter.\nfunc (s *Secure) Process(w http.ResponseWriter, r *http.Request) error {\n\tresponseHeader, _, err := s.processRequest(w, r)\n\taddResponseHeaders(responseHeader, w)\n\n\treturn err\n}\n\n// ProcessAndReturnNonce runs the actual checks and writes the headers in the ResponseWriter.\n// In addition, the generated nonce for the request is returned as well as the error value.\nfunc (s *Secure) ProcessAndReturnNonce(w http.ResponseWriter, r *http.Request) (string, error) {\n\tresponseHeader, newR, err := s.processRequest(w, r)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\taddResponseHeaders(responseHeader, w)\n\n\treturn CSPNonce(newR.Context()), err\n}\n\n// ProcessNoModifyRequest runs the actual checks but does not write the headers in the ResponseWriter.\nfunc (s *Secure) ProcessNoModifyRequest(w http.ResponseWriter, r *http.Request) (http.Header, *http.Request, error) {\n\treturn s.processRequest(w, r)\n}\n\n// processRequest runs the actual checks on the request and returns an error if the middleware chain should stop.\nfunc (s *Secure) processRequest(w http.ResponseWriter, r *http.Request) (http.Header, *http.Request, error) {\n\t// Setup nonce if required.\n\tif s.opt.nonceEnabled {\n\t\tr = withCSPNonce(r, cspRandNonce())\n\t}\n\n\t// Resolve the host for the request, using proxy headers if present.\n\thost := r.Host\n\n\tfor _, header := range s.opt.HostsProxyHeaders {\n\t\tif h := r.Header.Get(header); h != \"\" {\n\t\t\thost = h\n\n\t\t\tbreak\n\t\t}\n\t}\n\n\t// Allowed hosts check.\n\tif len(s.opt.AllowedHosts) > 0 && !s.opt.IsDevelopment {\n\t\tisGoodHost := false\n\n\t\tif s.opt.AllowedHostsAreRegex {\n\t\t\tfor _, allowedHost := range s.cRegexAllowedHosts {\n\t\t\t\tif match := allowedHost.MatchString(host); match {\n\t\t\t\t\tisGoodHost = true\n\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tfor _, allowedHost := range s.opt.AllowedHosts {\n\t\t\t\tif strings.EqualFold(allowedHost, host) {\n\t\t\t\t\tisGoodHost = true\n\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif !isGoodHost {\n\t\t\ts.badHostHandler.ServeHTTP(w, r)\n\n\t\t\treturn nil, nil, fmt.Errorf(\"bad host name: %s\", host)\n\t\t}\n\t}\n\n\t// Determine if we are on HTTPS.\n\tssl := s.isSSL(r)\n\n\t// SSL check.\n\tif s.opt.SSLRedirect && !ssl && !s.opt.IsDevelopment {\n\t\turl := r.URL\n\t\turl.Scheme = \"https\"\n\t\turl.Host = host\n\n\t\tif s.opt.SSLHostFunc != nil {\n\t\t\tif h := (*s.opt.SSLHostFunc)(host); len(h) > 0 {\n\t\t\t\turl.Host = h\n\t\t\t}\n\t\t} else if len(s.opt.SSLHost) > 0 {\n\t\t\turl.Host = s.opt.SSLHost\n\t\t}\n\n\t\tstatus := http.StatusMovedPermanently\n\t\tif s.opt.SSLTemporaryRedirect {\n\t\t\tstatus = http.StatusTemporaryRedirect\n\t\t}\n\n\t\thttp.Redirect(w, r, url.String(), status)\n\n\t\treturn nil, nil, fmt.Errorf(\"redirecting to HTTPS\")\n\t}\n\n\tif s.opt.SSLForceHost {\n\t\ttempSSLHost := host\n\n\t\tif s.opt.SSLHostFunc != nil {\n\t\t\tif h := (*s.opt.SSLHostFunc)(host); len(h) > 0 {\n\t\t\t\ttempSSLHost = h\n\t\t\t}\n\t\t} else if len(s.opt.SSLHost) > 0 {\n\t\t\ttempSSLHost = s.opt.SSLHost\n\t\t}\n\n\t\tif tempSSLHost != host {\n\t\t\turl := r.URL\n\t\t\turl.Scheme = \"https\"\n\t\t\turl.Host = tempSSLHost\n\n\t\t\tstatus := http.StatusMovedPermanently\n\t\t\tif s.opt.SSLTemporaryRedirect {\n\t\t\t\tstatus = http.StatusTemporaryRedirect\n\t\t\t}\n\n\t\t\thttp.Redirect(w, r, url.String(), status)\n\n\t\t\treturn nil, nil, fmt.Errorf(\"redirecting to HTTPS\")\n\t\t}\n\t}\n\n\t// If the AllowRequestFunc is set, call it and exit early if needed.\n\tif s.opt.AllowRequestFunc != nil && !s.opt.AllowRequestFunc(r) {\n\t\ts.badRequestHandler.ServeHTTP(w, r)\n\n\t\treturn nil, nil, fmt.Errorf(\"request not allowed\")\n\t}\n\n\t// Create our header container.\n\tresponseHeader := make(http.Header)\n\n\t// Strict Transport Security header. Only add header when we know it's an SSL connection.\n\t// See https://tools.ietf.org/html/rfc6797#section-7.2 for details.\n\tif s.opt.STSSeconds != 0 && (ssl || s.opt.ForceSTSHeader) && !s.opt.IsDevelopment {\n\t\tstsSub := \"\"\n\t\tif s.opt.STSIncludeSubdomains {\n\t\t\tstsSub = stsSubdomainString\n\t\t}\n\n\t\tif s.opt.STSPreload {\n\t\t\tstsSub += stsPreloadString\n\t\t}\n\n\t\tresponseHeader.Set(stsHeader, fmt.Sprintf(\"max-age=%d%s\", s.opt.STSSeconds, stsSub))\n\t}\n\n\t// Frame Options header.\n\tif len(s.opt.CustomFrameOptionsValue) > 0 {\n\t\tresponseHeader.Set(frameOptionsHeader, s.opt.CustomFrameOptionsValue)\n\t} else if s.opt.FrameDeny {\n\t\tresponseHeader.Set(frameOptionsHeader, frameOptionsValue)\n\t}\n\n\t// Content Type Options header.\n\tif s.opt.ContentTypeNosniff {\n\t\tresponseHeader.Set(contentTypeHeader, contentTypeValue)\n\t}\n\n\t// XSS Protection header.\n\tif len(s.opt.CustomBrowserXssValue) > 0 {\n\t\tresponseHeader.Set(xssProtectionHeader, s.opt.CustomBrowserXssValue)\n\t} else if s.opt.BrowserXssFilter {\n\t\tresponseHeader.Set(xssProtectionHeader, xssProtectionValue)\n\t}\n\n\t// Content Security Policy header.\n\tif len(s.opt.ContentSecurityPolicy) > 0 {\n\t\tif s.opt.nonceEnabled {\n\t\t\tresponseHeader.Set(cspHeader, fmt.Sprintf(s.opt.ContentSecurityPolicy, CSPNonce(r.Context())))\n\t\t} else {\n\t\t\tresponseHeader.Set(cspHeader, s.opt.ContentSecurityPolicy)\n\t\t}\n\t}\n\n\t// Content Security Policy Report Only header.\n\tif len(s.opt.ContentSecurityPolicyReportOnly) > 0 {\n\t\tif s.opt.nonceEnabled {\n\t\t\tresponseHeader.Set(cspReportOnlyHeader, fmt.Sprintf(s.opt.ContentSecurityPolicyReportOnly, CSPNonce(r.Context())))\n\t\t} else {\n\t\t\tresponseHeader.Set(cspReportOnlyHeader, s.opt.ContentSecurityPolicyReportOnly)\n\t\t}\n\t}\n\n\t// Referrer Policy header.\n\tif len(s.opt.ReferrerPolicy) > 0 {\n\t\tresponseHeader.Set(referrerPolicyHeader, s.opt.ReferrerPolicy)\n\t}\n\n\t// Feature Policy header.\n\tif len(s.opt.FeaturePolicy) > 0 {\n\t\tresponseHeader.Set(featurePolicyHeader, s.opt.FeaturePolicy)\n\t}\n\n\t// Permissions Policy header.\n\tif len(s.opt.PermissionsPolicy) > 0 {\n\t\tresponseHeader.Set(permissionsPolicyHeader, s.opt.PermissionsPolicy)\n\t}\n\n\t// Cross Origin Opener Policy header.\n\tif len(s.opt.CrossOriginOpenerPolicy) > 0 {\n\t\tresponseHeader.Set(coopHeader, s.opt.CrossOriginOpenerPolicy)\n\t}\n\n\t// Cross Origin Resource Policy header.\n\tif len(s.opt.CrossOriginResourcePolicy) > 0 {\n\t\tresponseHeader.Set(corpHeader, s.opt.CrossOriginResourcePolicy)\n\t}\n\n\t// Cross-Origin-Embedder-Policy header.\n\tif len(s.opt.CrossOriginEmbedderPolicy) > 0 {\n\t\tresponseHeader.Set(coepHeader, s.opt.CrossOriginEmbedderPolicy)\n\t}\n\n\t// X-DNS-Prefetch-Control header.\n\tswitch strings.ToLower(s.opt.XDNSPrefetchControl) {\n\tcase \"on\":\n\t\tresponseHeader.Set(dnsPreFetchControlHeader, \"on\")\n\tcase \"off\":\n\t\tresponseHeader.Set(dnsPreFetchControlHeader, \"off\")\n\t}\n\n\t// X-Permitted-Cross-Domain-Policies header.\n\tif len(s.opt.XPermittedCrossDomainPolicies) > 0 {\n\t\tresponseHeader.Set(permittedCrossDomainPolicies, s.opt.XPermittedCrossDomainPolicies)\n\t}\n\n\treturn responseHeader, r, nil\n}\n\n// isSSL determine if we are on HTTPS.\nfunc (s *Secure) isSSL(r *http.Request) bool {\n\tssl := strings.EqualFold(r.URL.Scheme, \"https\") || r.TLS != nil\n\tif !ssl {\n\t\tfor k, v := range s.opt.SSLProxyHeaders {\n\t\t\tif r.Header.Get(k) == v {\n\t\t\t\tssl = true\n\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}\n\n\treturn ssl\n}\n\n// ModifyResponseHeaders modifies the Response.\n// Used by http.ReverseProxy.\nfunc (s *Secure) ModifyResponseHeaders(res *http.Response) error {\n\tif res != nil && res.Request != nil {\n\t\t// Fix Location response header http to https:\n\t\t// When SSL is enabled,\n\t\t// And SSLHost is defined,\n\t\t// And the response location header includes the SSLHost as the domain with a trailing slash,\n\t\t// Or an exact match to the SSLHost.\n\t\tlocation := res.Header.Get(\"Location\")\n\t\tif s.isSSL(res.Request) &&\n\t\t\tlen(s.opt.SSLHost) > 0 &&\n\t\t\t(strings.HasPrefix(location, fmt.Sprintf(\"http://%s/\", s.opt.SSLHost)) || location == fmt.Sprintf(\"http://%s\", s.opt.SSLHost)) {\n\t\t\tlocation = strings.Replace(location, \"http:\", \"https:\", 1)\n\t\t\tres.Header.Set(\"Location\", location)\n\t\t}\n\n\t\tresponseHeader := res.Request.Context().Value(s.ctxSecureHeaderKey)\n\t\tif responseHeader != nil {\n\t\t\theaders, _ := responseHeader.(http.Header)\n\t\t\tfor header, values := range headers {\n\t\t\t\tif len(values) > 0 {\n\t\t\t\t\tres.Header.Set(header, strings.Join(values, \",\"))\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn nil\n}\n"
        },
        {
          "name": "secure_test.go",
          "type": "blob",
          "size": 40.265625,
          "content": "package secure\n\nimport (\n\t\"context\"\n\t\"crypto/tls\"\n\t\"encoding/json\"\n\t\"net/http\"\n\t\"net/http/httptest\"\n\t\"reflect\"\n\t\"strings\"\n\t\"testing\"\n)\n\nconst (\n\thttpSchema  = \"http\"\n\thttpsSchema = \"https\"\n\texampleHost = \"www.example.com\"\n)\n\n//nolint:gochecknoglobals\nvar myHandler = http.HandlerFunc(func(w http.ResponseWriter, _ *http.Request) {\n\t_, _ = w.Write([]byte(\"bar\"))\n})\n\nfunc TestNoConfigOnlyOneHeader(t *testing.T) {\n\ts := New()\n\n\tres := httptest.NewRecorder()\n\treq, _ := http.NewRequestWithContext(context.Background(), http.MethodGet, \"http://example.com/foo\", nil)\n\n\ts.Handler(myHandler).ServeHTTP(res, req)\n\n\texpect(t, len(res.Header()), 1)\n\texpect(t, strings.Contains(res.Header().Get(\"Content-Type\"), \"text/plain\"), true)\n}\n\nfunc TestNoConfig(t *testing.T) {\n\ts := New()\n\n\tres := httptest.NewRecorder()\n\treq, _ := http.NewRequestWithContext(context.Background(), http.MethodGet, \"http://example.com/foo\", nil)\n\n\ts.Handler(myHandler).ServeHTTP(res, req)\n\n\texpect(t, res.Code, http.StatusOK)\n\texpect(t, res.Body.String(), \"bar\")\n}\n\nfunc TestNoAllowHosts(t *testing.T) {\n\ts := New(Options{\n\t\tAllowedHosts: []string{},\n\t})\n\n\tres := httptest.NewRecorder()\n\treq, _ := http.NewRequestWithContext(context.Background(), http.MethodGet, \"/foo\", nil)\n\treq.Host = exampleHost\n\n\ts.Handler(myHandler).ServeHTTP(res, req)\n\n\texpect(t, res.Code, http.StatusOK)\n\texpect(t, res.Body.String(), `bar`)\n}\n\nfunc TestGoodSingleAllowHosts(t *testing.T) {\n\ts := New(Options{\n\t\tAllowedHosts: []string{\"www.example.com\"},\n\t})\n\n\tres := httptest.NewRecorder()\n\treq, _ := http.NewRequestWithContext(context.Background(), http.MethodGet, \"/foo\", nil)\n\treq.Host = exampleHost\n\n\ts.Handler(myHandler).ServeHTTP(res, req)\n\n\texpect(t, res.Code, http.StatusOK)\n\texpect(t, res.Body.String(), `bar`)\n}\n\nfunc TestBadSingleAllowHosts(t *testing.T) {\n\ts := New(Options{\n\t\tAllowedHosts: []string{\"sub.example.com\"},\n\t})\n\n\tres := httptest.NewRecorder()\n\treq, _ := http.NewRequestWithContext(context.Background(), http.MethodGet, \"/foo\", nil)\n\treq.Host = exampleHost\n\n\ts.Handler(myHandler).ServeHTTP(res, req)\n\n\texpect(t, res.Code, http.StatusInternalServerError)\n}\n\nfunc TestRegexSingleAllowHosts(t *testing.T) {\n\ts := New(Options{\n\t\tAllowedHosts:         []string{\"*\\\\.example\\\\.com\"},\n\t\tAllowedHostsAreRegex: true,\n\t})\n\n\tres := httptest.NewRecorder()\n\treq, _ := http.NewRequestWithContext(context.Background(), http.MethodGet, \"/foo\", nil)\n\treq.Host = exampleHost\n\n\ts.Handler(myHandler).ServeHTTP(res, req)\n\n\texpect(t, res.Code, http.StatusOK)\n\texpect(t, res.Body.String(), `bar`)\n}\n\nfunc TestRegexMultipleAllowHosts(t *testing.T) {\n\ts := New(Options{\n\t\tAllowedHosts:         []string{\".+\\\\.example\\\\.com\", \".*sub\\\\..+-awesome-example\\\\.com\"},\n\t\tAllowedHostsAreRegex: true,\n\t})\n\n\tres := httptest.NewRecorder()\n\treq, _ := http.NewRequestWithContext(context.Background(), http.MethodGet, \"/foo\", nil)\n\treq.Host = \"sub.first-awesome-example.com\"\n\n\ts.Handler(myHandler).ServeHTTP(res, req)\n\n\texpect(t, res.Code, http.StatusOK)\n\texpect(t, res.Body.String(), `bar`)\n\n\tres = httptest.NewRecorder()\n\treq, _ = http.NewRequestWithContext(context.Background(), http.MethodGet, \"/foo\", nil)\n\treq.Host = \"test.sub.second-awesome-example.com\"\n\n\ts.Handler(myHandler).ServeHTTP(res, req)\n\n\texpect(t, res.Code, http.StatusOK)\n\texpect(t, res.Body.String(), `bar`)\n\n\tres = httptest.NewRecorder()\n\treq, _ = http.NewRequestWithContext(context.Background(), http.MethodGet, \"/foo\", nil)\n\treq.Host = \"test.sub.second-example.com\"\n\n\ts.Handler(myHandler).ServeHTTP(res, req)\n\n\texpect(t, res.Code, http.StatusInternalServerError)\n}\n\nfunc TestInvalidRegexAllowHosts(t *testing.T) {\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"The code did not panic\")\n\t\t}\n\t}()\n\tNew(Options{\n\t\tAllowedHosts:         []string{\"[*.e\"},\n\t\tAllowedHostsAreRegex: true,\n\t})\n}\n\nfunc TestGoodSingleAllowHostsProxyHeaders(t *testing.T) {\n\ts := New(Options{\n\t\tAllowedHosts:      []string{\"www.example.com\"},\n\t\tHostsProxyHeaders: []string{\"X-Proxy-Host\"},\n\t})\n\n\tres := httptest.NewRecorder()\n\treq, _ := http.NewRequestWithContext(context.Background(), http.MethodGet, \"/foo\", nil)\n\treq.Host = \"example-internal-3\"\n\treq.Header.Set(\"X-Proxy-Host\", \"www.example.com\")\n\n\ts.Handler(myHandler).ServeHTTP(res, req)\n\n\texpect(t, res.Code, http.StatusOK)\n\texpect(t, res.Body.String(), `bar`)\n}\n\nfunc TestBadSingleAllowHostsProxyHeaders(t *testing.T) {\n\ts := New(Options{\n\t\tAllowedHosts:      []string{\"sub.example.com\"},\n\t\tHostsProxyHeaders: []string{\"X-Proxy-Host\"},\n\t})\n\n\tres := httptest.NewRecorder()\n\treq, _ := http.NewRequestWithContext(context.Background(), http.MethodGet, \"/foo\", nil)\n\treq.Host = \"example-internal\"\n\treq.Header.Set(\"X-Proxy-Host\", \"www.example.com\")\n\n\ts.Handler(myHandler).ServeHTTP(res, req)\n\n\texpect(t, res.Code, http.StatusInternalServerError)\n}\n\nfunc TestGoodMultipleAllowHosts(t *testing.T) {\n\ts := New(Options{\n\t\tAllowedHosts: []string{\"www.example.com\", \"sub.example.com\"},\n\t})\n\n\tres := httptest.NewRecorder()\n\treq, _ := http.NewRequestWithContext(context.Background(), http.MethodGet, \"/foo\", nil)\n\treq.Host = exampleHost\n\n\ts.Handler(myHandler).ServeHTTP(res, req)\n\n\texpect(t, res.Code, http.StatusOK)\n\texpect(t, res.Body.String(), `bar`)\n}\n\nfunc TestBadMultipleAllowHosts(t *testing.T) {\n\ts := New(Options{\n\t\tAllowedHosts: []string{\"www.example.com\", \"sub.example.com\"},\n\t})\n\n\tres := httptest.NewRecorder()\n\treq, _ := http.NewRequestWithContext(context.Background(), http.MethodGet, \"/foo\", nil)\n\treq.Host = \"www3.example.com\"\n\n\ts.Handler(myHandler).ServeHTTP(res, req)\n\n\texpect(t, res.Code, http.StatusInternalServerError)\n}\n\nfunc TestAllowHostsInDevMode(t *testing.T) {\n\ts := New(Options{\n\t\tAllowedHosts:  []string{\"www.example.com\", \"sub.example.com\"},\n\t\tIsDevelopment: true,\n\t})\n\n\tres := httptest.NewRecorder()\n\treq, _ := http.NewRequestWithContext(context.Background(), http.MethodGet, \"/foo\", nil)\n\treq.Host = exampleHost\n\n\ts.Handler(myHandler).ServeHTTP(res, req)\n\n\texpect(t, res.Code, http.StatusOK)\n}\n\nfunc TestBadHostHandler(t *testing.T) {\n\ts := New(Options{\n\t\tAllowedHosts: []string{\"www.example.com\", \"sub.example.com\"},\n\t})\n\n\tbadHandler := http.HandlerFunc(func(w http.ResponseWriter, _ *http.Request) {\n\t\thttp.Error(w, \"BadHost\", http.StatusInternalServerError)\n\t})\n\n\ts.SetBadHostHandler(badHandler)\n\n\tres := httptest.NewRecorder()\n\treq, _ := http.NewRequestWithContext(context.Background(), http.MethodGet, \"/foo\", nil)\n\treq.Host = \"www3.example.com\"\n\n\ts.Handler(myHandler).ServeHTTP(res, req)\n\n\texpect(t, res.Code, http.StatusInternalServerError)\n\n\t// http.Error outputs a new line character with the response.\n\texpect(t, res.Body.String(), \"BadHost\\n\")\n}\n\nfunc TestSSL(t *testing.T) {\n\ts := New(Options{\n\t\tSSLRedirect: true,\n\t})\n\n\tres := httptest.NewRecorder()\n\treq, _ := http.NewRequestWithContext(context.Background(), http.MethodGet, \"/foo\", nil)\n\treq.Host = exampleHost\n\treq.URL.Scheme = httpsSchema\n\n\ts.Handler(myHandler).ServeHTTP(res, req)\n\n\texpect(t, res.Code, http.StatusOK)\n}\n\nfunc TestSSLInDevMode(t *testing.T) {\n\ts := New(Options{\n\t\tSSLRedirect:   true,\n\t\tIsDevelopment: true,\n\t})\n\n\tres := httptest.NewRecorder()\n\treq, _ := http.NewRequestWithContext(context.Background(), http.MethodGet, \"/foo\", nil)\n\treq.Host = exampleHost\n\treq.URL.Scheme = httpSchema\n\n\ts.Handler(myHandler).ServeHTTP(res, req)\n\n\texpect(t, res.Code, http.StatusOK)\n}\n\nfunc TestBasicSSL(t *testing.T) {\n\ts := New(Options{\n\t\tSSLRedirect: true,\n\t})\n\n\tres := httptest.NewRecorder()\n\treq, _ := http.NewRequestWithContext(context.Background(), http.MethodGet, \"/foo\", nil)\n\treq.Host = exampleHost\n\treq.URL.Scheme = httpSchema\n\n\ts.Handler(myHandler).ServeHTTP(res, req)\n\n\texpect(t, res.Code, http.StatusMovedPermanently)\n\texpect(t, res.Header().Get(\"Location\"), \"https://www.example.com/foo\")\n}\n\nfunc TestBasicSSLWithHost(t *testing.T) {\n\ts := New(Options{\n\t\tSSLRedirect: true,\n\t\tSSLHost:     \"secure.example.com\",\n\t})\n\n\tres := httptest.NewRecorder()\n\treq, _ := http.NewRequestWithContext(context.Background(), http.MethodGet, \"/foo\", nil)\n\treq.Host = exampleHost\n\treq.URL.Scheme = httpSchema\n\n\ts.Handler(myHandler).ServeHTTP(res, req)\n\n\texpect(t, res.Code, http.StatusMovedPermanently)\n\texpect(t, res.Header().Get(\"Location\"), \"https://secure.example.com/foo\")\n}\n\nfunc TestBasicSSLWithHostFunc(t *testing.T) {\n\tsslHostFunc := (func() SSLHostFunc {\n\t\treturn func(host string) string {\n\t\t\tnewHost := \"\"\n\t\t\tif host == exampleHost {\n\t\t\t\tnewHost = \"secure.example.com:8443\"\n\t\t\t} else if host == \"www.example.org\" {\n\t\t\t\tnewHost = \"secure.example.org\"\n\t\t\t}\n\n\t\t\treturn newHost\n\t\t}\n\t})()\n\ts := New(Options{\n\t\tSSLRedirect: true,\n\t\tSSLHostFunc: &sslHostFunc,\n\t})\n\n\t// test www.example.com\n\tres := httptest.NewRecorder()\n\treq, _ := http.NewRequestWithContext(context.Background(), http.MethodGet, \"/foo\", nil)\n\treq.Host = exampleHost\n\treq.URL.Scheme = httpSchema\n\n\ts.Handler(myHandler).ServeHTTP(res, req)\n\n\texpect(t, res.Code, http.StatusMovedPermanently)\n\texpect(t, res.Header().Get(\"Location\"), \"https://secure.example.com:8443/foo\")\n\n\t// test www.example.org\n\tres = httptest.NewRecorder()\n\treq, _ = http.NewRequestWithContext(context.Background(), http.MethodGet, \"/foo\", nil)\n\treq.Host = \"www.example.org\"\n\treq.URL.Scheme = httpSchema\n\n\ts.Handler(myHandler).ServeHTTP(res, req)\n\n\texpect(t, res.Code, http.StatusMovedPermanently)\n\texpect(t, res.Header().Get(\"Location\"), \"https://secure.example.org/foo\")\n\n\t// test other\n\tres = httptest.NewRecorder()\n\treq, _ = http.NewRequestWithContext(context.Background(), http.MethodGet, \"/foo\", nil)\n\treq.Host = \"www.other.com\"\n\treq.URL.Scheme = httpSchema\n\n\ts.Handler(myHandler).ServeHTTP(res, req)\n\n\texpect(t, res.Code, http.StatusMovedPermanently)\n\texpect(t, res.Header().Get(\"Location\"), \"https://www.other.com/foo\")\n}\n\nfunc TestBadProxySSL(t *testing.T) {\n\ts := New(Options{\n\t\tSSLRedirect: true,\n\t})\n\n\tres := httptest.NewRecorder()\n\treq, _ := http.NewRequestWithContext(context.Background(), http.MethodGet, \"/foo\", nil)\n\treq.Host = exampleHost\n\treq.URL.Scheme = httpSchema\n\treq.Header.Add(\"X-Forwarded-Proto\", \"https\")\n\n\ts.Handler(myHandler).ServeHTTP(res, req)\n\n\texpect(t, res.Code, http.StatusMovedPermanently)\n\texpect(t, res.Header().Get(\"Location\"), \"https://www.example.com/foo\")\n}\n\nfunc TestCustomProxySSL(t *testing.T) {\n\ts := New(Options{\n\t\tSSLRedirect:     true,\n\t\tSSLProxyHeaders: map[string]string{\"X-Forwarded-Proto\": \"https\"},\n\t})\n\n\tres := httptest.NewRecorder()\n\treq, _ := http.NewRequestWithContext(context.Background(), http.MethodGet, \"/foo\", nil)\n\treq.Host = exampleHost\n\treq.URL.Scheme = httpSchema\n\treq.Header.Add(\"X-Forwarded-Proto\", \"https\")\n\n\ts.Handler(myHandler).ServeHTTP(res, req)\n\n\texpect(t, res.Code, http.StatusOK)\n}\n\nfunc TestCustomProxySSLInDevMode(t *testing.T) {\n\ts := New(Options{\n\t\tSSLRedirect:     true,\n\t\tSSLProxyHeaders: map[string]string{\"X-Forwarded-Proto\": \"https\"},\n\t\tIsDevelopment:   true,\n\t})\n\n\tres := httptest.NewRecorder()\n\treq, _ := http.NewRequestWithContext(context.Background(), http.MethodGet, \"/foo\", nil)\n\treq.Host = exampleHost\n\treq.URL.Scheme = httpSchema\n\treq.Header.Add(\"X-Forwarded-Proto\", \"http\")\n\n\ts.Handler(myHandler).ServeHTTP(res, req)\n\n\texpect(t, res.Code, http.StatusOK)\n}\n\nfunc TestCustomProxyAndHostProxyHeadersWithRedirect(t *testing.T) {\n\ts := New(Options{\n\t\tHostsProxyHeaders: []string{\"X-Forwarded-Host\"},\n\t\tSSLRedirect:       true,\n\t\tSSLProxyHeaders:   map[string]string{\"X-Forwarded-Proto\": \"http\"},\n\t})\n\n\tres := httptest.NewRecorder()\n\treq, _ := http.NewRequestWithContext(context.Background(), http.MethodGet, \"/foo\", nil)\n\treq.Host = \"example-internal\"\n\treq.URL.Scheme = httpSchema\n\treq.Header.Add(\"X-Forwarded-Proto\", \"https\")\n\treq.Header.Add(\"X-Forwarded-Host\", \"www.example.com\")\n\n\ts.Handler(myHandler).ServeHTTP(res, req)\n\n\texpect(t, res.Code, http.StatusMovedPermanently)\n\texpect(t, res.Header().Get(\"Location\"), \"https://www.example.com/foo\")\n}\n\nfunc TestCustomProxyAndHostSSL(t *testing.T) {\n\ts := New(Options{\n\t\tSSLRedirect:     true,\n\t\tSSLProxyHeaders: map[string]string{\"X-Forwarded-Proto\": \"https\"},\n\t\tSSLHost:         \"secure.example.com\",\n\t})\n\n\tres := httptest.NewRecorder()\n\treq, _ := http.NewRequestWithContext(context.Background(), http.MethodGet, \"/foo\", nil)\n\treq.Host = exampleHost\n\treq.URL.Scheme = httpSchema\n\treq.Header.Add(\"X-Forwarded-Proto\", \"https\")\n\n\ts.Handler(myHandler).ServeHTTP(res, req)\n\n\texpect(t, res.Code, http.StatusOK)\n}\n\nfunc TestCustomBadProxyAndHostSSL(t *testing.T) {\n\ts := New(Options{\n\t\tSSLRedirect:     true,\n\t\tSSLProxyHeaders: map[string]string{\"X-Forwarded-Proto\": \"superman\"},\n\t\tSSLHost:         \"secure.example.com\",\n\t})\n\n\tres := httptest.NewRecorder()\n\treq, _ := http.NewRequestWithContext(context.Background(), http.MethodGet, \"/foo\", nil)\n\treq.Host = exampleHost\n\treq.URL.Scheme = httpSchema\n\treq.Header.Add(\"X-Forwarded-Proto\", \"https\")\n\n\ts.Handler(myHandler).ServeHTTP(res, req)\n\n\texpect(t, res.Code, http.StatusMovedPermanently)\n\texpect(t, res.Header().Get(\"Location\"), \"https://secure.example.com/foo\")\n}\n\nfunc TestCustomBadProxyAndHostSSLWithTempRedirect(t *testing.T) {\n\ts := New(Options{\n\t\tSSLRedirect:          true,\n\t\tSSLProxyHeaders:      map[string]string{\"X-Forwarded-Proto\": \"superman\"},\n\t\tSSLHost:              \"secure.example.com\",\n\t\tSSLTemporaryRedirect: true,\n\t})\n\n\tres := httptest.NewRecorder()\n\treq, _ := http.NewRequestWithContext(context.Background(), http.MethodGet, \"/foo\", nil)\n\treq.Host = exampleHost\n\treq.URL.Scheme = httpSchema\n\treq.Header.Add(\"X-Forwarded-Proto\", \"https\")\n\n\ts.Handler(myHandler).ServeHTTP(res, req)\n\n\texpect(t, res.Code, http.StatusTemporaryRedirect)\n\texpect(t, res.Header().Get(\"Location\"), \"https://secure.example.com/foo\")\n}\n\nfunc TestStsHeaderWithNoSSL(t *testing.T) {\n\ts := New(Options{\n\t\tSTSSeconds: 315360000,\n\t})\n\n\tres := httptest.NewRecorder()\n\treq, _ := http.NewRequestWithContext(context.Background(), http.MethodGet, \"/foo\", nil)\n\n\ts.Handler(myHandler).ServeHTTP(res, req)\n\n\texpect(t, res.Code, http.StatusOK)\n\texpect(t, res.Header().Get(\"Strict-Transport-Security\"), \"\")\n}\n\nfunc TestStsHeaderWithNoSSLButWithForce(t *testing.T) {\n\ts := New(Options{\n\t\tSTSSeconds:     315360000,\n\t\tForceSTSHeader: true,\n\t})\n\n\tres := httptest.NewRecorder()\n\treq, _ := http.NewRequestWithContext(context.Background(), http.MethodGet, \"/foo\", nil)\n\n\ts.Handler(myHandler).ServeHTTP(res, req)\n\n\texpect(t, res.Code, http.StatusOK)\n\texpect(t, res.Header().Get(\"Strict-Transport-Security\"), \"max-age=315360000\")\n}\n\nfunc TestStsHeaderWithNoSSLButWithForceForRequestOnly(t *testing.T) {\n\ts := New(Options{\n\t\tSTSSeconds:     315360000,\n\t\tForceSTSHeader: true,\n\t})\n\n\tres := httptest.NewRecorder()\n\treq, _ := http.NewRequestWithContext(context.Background(), http.MethodGet, \"/foo\", nil)\n\n\ts.HandlerForRequestOnly(myHandler).ServeHTTP(res, req)\n\n\texpect(t, res.Code, http.StatusOK)\n\texpect(t, res.Header().Get(\"Strict-Transport-Security\"), \"\")\n}\n\nfunc TestStsHeaderWithNoSSLButWithForceAndIsDev(t *testing.T) {\n\ts := New(Options{\n\t\tSTSSeconds:     315360000,\n\t\tForceSTSHeader: true,\n\t\tIsDevelopment:  true,\n\t})\n\n\tres := httptest.NewRecorder()\n\treq, _ := http.NewRequestWithContext(context.Background(), http.MethodGet, \"/foo\", nil)\n\n\ts.Handler(myHandler).ServeHTTP(res, req)\n\n\texpect(t, res.Code, http.StatusOK)\n\texpect(t, res.Header().Get(\"Strict-Transport-Security\"), \"\")\n}\n\nfunc TestStsHeaderWithSSL(t *testing.T) {\n\ts := New(Options{\n\t\tSSLProxyHeaders: map[string]string{\"X-Forwarded-Proto\": \"https\"},\n\t\tSTSSeconds:      315360000,\n\t})\n\n\tres := httptest.NewRecorder()\n\treq, _ := http.NewRequestWithContext(context.Background(), http.MethodGet, \"/foo\", nil)\n\treq.URL.Scheme = httpSchema\n\treq.Header.Add(\"X-Forwarded-Proto\", \"https\")\n\n\ts.Handler(myHandler).ServeHTTP(res, req)\n\n\texpect(t, res.Code, http.StatusOK)\n\texpect(t, res.Header().Get(\"Strict-Transport-Security\"), \"max-age=315360000\")\n}\n\nfunc TestStsHeaderWithSSLForRequestOnly(t *testing.T) {\n\ts := New(Options{\n\t\tSSLProxyHeaders: map[string]string{\"X-Forwarded-Proto\": \"https\"},\n\t\tSTSSeconds:      315360000,\n\t})\n\n\tres := httptest.NewRecorder()\n\treq, _ := http.NewRequestWithContext(context.Background(), http.MethodGet, \"/foo\", nil)\n\treq.URL.Scheme = httpSchema\n\treq.Header.Add(\"X-Forwarded-Proto\", \"https\")\n\n\ts.HandlerForRequestOnly(myHandler).ServeHTTP(res, req)\n\n\texpect(t, res.Code, http.StatusOK)\n\texpect(t, res.Header().Get(\"Strict-Transport-Security\"), \"\")\n}\n\nfunc TestStsHeaderInDevMode(t *testing.T) {\n\ts := New(Options{\n\t\tSTSSeconds:    315360000,\n\t\tIsDevelopment: true,\n\t})\n\n\tres := httptest.NewRecorder()\n\treq, _ := http.NewRequestWithContext(context.Background(), http.MethodGet, \"/foo\", nil)\n\treq.URL.Scheme = httpsSchema\n\n\ts.Handler(myHandler).ServeHTTP(res, req)\n\n\texpect(t, res.Code, http.StatusOK)\n\texpect(t, res.Header().Get(\"Strict-Transport-Security\"), \"\")\n}\n\nfunc TestStsHeaderWithSubdomains(t *testing.T) {\n\ts := New(Options{\n\t\tSTSSeconds:           315360000,\n\t\tSTSIncludeSubdomains: true,\n\t})\n\n\tres := httptest.NewRecorder()\n\treq, _ := http.NewRequestWithContext(context.Background(), http.MethodGet, \"/foo\", nil)\n\treq.URL.Scheme = httpsSchema\n\n\ts.Handler(myHandler).ServeHTTP(res, req)\n\n\texpect(t, res.Code, http.StatusOK)\n\texpect(t, res.Header().Get(\"Strict-Transport-Security\"), \"max-age=315360000; includeSubDomains\")\n}\n\nfunc TestStsHeaderWithSubdomainsForRequestOnly(t *testing.T) {\n\ts := New(Options{\n\t\tSTSSeconds:           315360000,\n\t\tSTSIncludeSubdomains: true,\n\t})\n\n\tres := httptest.NewRecorder()\n\treq, _ := http.NewRequestWithContext(context.Background(), http.MethodGet, \"/foo\", nil)\n\treq.URL.Scheme = httpsSchema\n\n\ts.HandlerForRequestOnly(myHandler).ServeHTTP(res, req)\n\n\texpect(t, res.Code, http.StatusOK)\n\texpect(t, res.Header().Get(\"Strict-Transport-Security\"), \"\")\n}\n\nfunc TestStsHeaderWithPreload(t *testing.T) {\n\ts := New(Options{\n\t\tSTSSeconds: 315360000,\n\t\tSTSPreload: true,\n\t})\n\n\tres := httptest.NewRecorder()\n\treq, _ := http.NewRequestWithContext(context.Background(), http.MethodGet, \"/foo\", nil)\n\treq.URL.Scheme = httpsSchema\n\n\ts.Handler(myHandler).ServeHTTP(res, req)\n\n\texpect(t, res.Code, http.StatusOK)\n\texpect(t, res.Header().Get(\"Strict-Transport-Security\"), \"max-age=315360000; preload\")\n}\n\nfunc TestStsHeaderWithPreloadForRequest(t *testing.T) {\n\ts := New(Options{\n\t\tSTSSeconds: 315360000,\n\t\tSTSPreload: true,\n\t})\n\n\tres := httptest.NewRecorder()\n\treq, _ := http.NewRequestWithContext(context.Background(), http.MethodGet, \"/foo\", nil)\n\treq.URL.Scheme = httpsSchema\n\n\ts.HandlerForRequestOnly(myHandler).ServeHTTP(res, req)\n\n\texpect(t, res.Code, http.StatusOK)\n\texpect(t, res.Header().Get(\"Strict-Transport-Security\"), \"\")\n}\n\nfunc TestStsHeaderWithSubdomainsWithPreload(t *testing.T) {\n\ts := New(Options{\n\t\tSTSSeconds:           315360000,\n\t\tSTSIncludeSubdomains: true,\n\t\tSTSPreload:           true,\n\t})\n\n\tres := httptest.NewRecorder()\n\treq, _ := http.NewRequestWithContext(context.Background(), http.MethodGet, \"/foo\", nil)\n\treq.URL.Scheme = httpsSchema\n\n\ts.Handler(myHandler).ServeHTTP(res, req)\n\n\texpect(t, res.Code, http.StatusOK)\n\texpect(t, res.Header().Get(\"Strict-Transport-Security\"), \"max-age=315360000; includeSubDomains; preload\")\n}\n\nfunc TestStsHeaderWithSubdomainsWithPreloadForRequestOnly(t *testing.T) {\n\ts := New(Options{\n\t\tSTSSeconds:           315360000,\n\t\tSTSIncludeSubdomains: true,\n\t\tSTSPreload:           true,\n\t})\n\n\tres := httptest.NewRecorder()\n\treq, _ := http.NewRequestWithContext(context.Background(), http.MethodGet, \"/foo\", nil)\n\treq.URL.Scheme = httpsSchema\n\n\ts.HandlerForRequestOnly(myHandler).ServeHTTP(res, req)\n\n\texpect(t, res.Code, http.StatusOK)\n\texpect(t, res.Header().Get(\"Strict-Transport-Security\"), \"\")\n}\n\nfunc TestFrameDeny(t *testing.T) {\n\ts := New(Options{\n\t\tFrameDeny: true,\n\t})\n\n\tres := httptest.NewRecorder()\n\treq, _ := http.NewRequestWithContext(context.Background(), http.MethodGet, \"/foo\", nil)\n\n\ts.Handler(myHandler).ServeHTTP(res, req)\n\n\texpect(t, res.Code, http.StatusOK)\n\texpect(t, res.Header().Get(\"X-Frame-Options\"), \"DENY\")\n}\n\nfunc TestFrameDenyForRequestOnly(t *testing.T) {\n\ts := New(Options{\n\t\tFrameDeny: true,\n\t})\n\n\tres := httptest.NewRecorder()\n\treq, _ := http.NewRequestWithContext(context.Background(), http.MethodGet, \"/foo\", nil)\n\n\ts.HandlerForRequestOnly(myHandler).ServeHTTP(res, req)\n\n\texpect(t, res.Code, http.StatusOK)\n\texpect(t, res.Header().Get(\"X-Frame-Options\"), \"\")\n}\n\nfunc TestCustomFrameValue(t *testing.T) {\n\ts := New(Options{\n\t\tCustomFrameOptionsValue: \"SAMEORIGIN\",\n\t})\n\n\tres := httptest.NewRecorder()\n\treq, _ := http.NewRequestWithContext(context.Background(), http.MethodGet, \"/foo\", nil)\n\n\ts.Handler(myHandler).ServeHTTP(res, req)\n\n\texpect(t, res.Code, http.StatusOK)\n\texpect(t, res.Header().Get(\"X-Frame-Options\"), \"SAMEORIGIN\")\n}\n\nfunc TestCustomFrameValueWithDeny(t *testing.T) {\n\ts := New(Options{\n\t\tFrameDeny:               true,\n\t\tCustomFrameOptionsValue: \"SAMEORIGIN\",\n\t})\n\n\tres := httptest.NewRecorder()\n\treq, _ := http.NewRequestWithContext(context.Background(), http.MethodGet, \"/foo\", nil)\n\n\ts.Handler(myHandler).ServeHTTP(res, req)\n\n\texpect(t, res.Code, http.StatusOK)\n\texpect(t, res.Header().Get(\"X-Frame-Options\"), \"SAMEORIGIN\")\n}\n\nfunc TestCustomFrameValueWithDenyForRequestOnly(t *testing.T) {\n\ts := New(Options{\n\t\tFrameDeny:               true,\n\t\tCustomFrameOptionsValue: \"SAMEORIGIN\",\n\t})\n\n\tres := httptest.NewRecorder()\n\treq, _ := http.NewRequestWithContext(context.Background(), http.MethodGet, \"/foo\", nil)\n\n\ts.HandlerForRequestOnly(myHandler).ServeHTTP(res, req)\n\n\texpect(t, res.Code, http.StatusOK)\n\texpect(t, res.Header().Get(\"X-Frame-Options\"), \"\")\n}\n\nfunc TestContentNosniff(t *testing.T) {\n\ts := New(Options{\n\t\tContentTypeNosniff: true,\n\t})\n\n\tres := httptest.NewRecorder()\n\treq, _ := http.NewRequestWithContext(context.Background(), http.MethodGet, \"/foo\", nil)\n\n\ts.Handler(myHandler).ServeHTTP(res, req)\n\n\texpect(t, res.Code, http.StatusOK)\n\texpect(t, res.Header().Get(\"X-Content-Type-Options\"), \"nosniff\")\n}\n\nfunc TestContentNosniffForRequestOnly(t *testing.T) {\n\ts := New(Options{\n\t\tContentTypeNosniff: true,\n\t})\n\n\tres := httptest.NewRecorder()\n\treq, _ := http.NewRequestWithContext(context.Background(), http.MethodGet, \"/foo\", nil)\n\n\ts.HandlerForRequestOnly(myHandler).ServeHTTP(res, req)\n\n\texpect(t, res.Code, http.StatusOK)\n\texpect(t, res.Header().Get(\"X-Content-Type-Options\"), \"\")\n}\n\nfunc TestXSSProtection(t *testing.T) {\n\ts := New(Options{\n\t\tBrowserXssFilter: true,\n\t})\n\n\tres := httptest.NewRecorder()\n\treq, _ := http.NewRequestWithContext(context.Background(), http.MethodGet, \"/foo\", nil)\n\n\ts.Handler(myHandler).ServeHTTP(res, req)\n\n\texpect(t, res.Code, http.StatusOK)\n\texpect(t, res.Header().Get(\"X-XSS-Protection\"), \"1; mode=block\")\n}\n\nfunc TestXSSProtectionForRequestOnly(t *testing.T) {\n\ts := New(Options{\n\t\tBrowserXssFilter: true,\n\t})\n\n\tres := httptest.NewRecorder()\n\treq, _ := http.NewRequestWithContext(context.Background(), http.MethodGet, \"/foo\", nil)\n\n\ts.HandlerForRequestOnly(myHandler).ServeHTTP(res, req)\n\n\texpect(t, res.Code, http.StatusOK)\n\texpect(t, res.Header().Get(\"X-XSS-Protection\"), \"\")\n}\n\nfunc TestCustomXSSProtection(t *testing.T) {\n\txssVal := \"1; report=https://example.com\"\n\ts := New(Options{\n\t\tCustomBrowserXssValue: xssVal,\n\t})\n\n\tres := httptest.NewRecorder()\n\treq, _ := http.NewRequestWithContext(context.Background(), http.MethodGet, \"/foo\", nil)\n\n\ts.Handler(myHandler).ServeHTTP(res, req)\n\n\texpect(t, res.Code, http.StatusOK)\n\texpect(t, res.Header().Get(\"X-XSS-Protection\"), xssVal)\n}\n\nfunc TestCustomXSSProtectionForRequestOnly(t *testing.T) {\n\txssVal := \"1; report=https://example.com\"\n\ts := New(Options{\n\t\tCustomBrowserXssValue: xssVal,\n\t})\n\n\tres := httptest.NewRecorder()\n\treq, _ := http.NewRequestWithContext(context.Background(), http.MethodGet, \"/foo\", nil)\n\n\ts.HandlerForRequestOnly(myHandler).ServeHTTP(res, req)\n\n\texpect(t, res.Code, http.StatusOK)\n\texpect(t, res.Header().Get(\"X-XSS-Protection\"), \"\")\n}\n\nfunc TestBothXSSProtection(t *testing.T) {\n\txssVal := \"0\"\n\ts := New(Options{\n\t\tBrowserXssFilter:      true,\n\t\tCustomBrowserXssValue: xssVal,\n\t})\n\n\tres := httptest.NewRecorder()\n\treq, _ := http.NewRequestWithContext(context.Background(), http.MethodGet, \"/foo\", nil)\n\n\ts.Handler(myHandler).ServeHTTP(res, req)\n\n\texpect(t, res.Code, http.StatusOK)\n\texpect(t, res.Header().Get(\"X-XSS-Protection\"), xssVal)\n}\n\nfunc TestBothXSSProtectionForRequestOnly(t *testing.T) {\n\txssVal := \"0\"\n\ts := New(Options{\n\t\tBrowserXssFilter:      true,\n\t\tCustomBrowserXssValue: xssVal,\n\t})\n\n\tres := httptest.NewRecorder()\n\treq, _ := http.NewRequestWithContext(context.Background(), http.MethodGet, \"/foo\", nil)\n\n\ts.HandlerForRequestOnly(myHandler).ServeHTTP(res, req)\n\n\texpect(t, res.Code, http.StatusOK)\n\texpect(t, res.Header().Get(\"X-XSS-Protection\"), \"\")\n}\n\nfunc TestCsp(t *testing.T) {\n\ts := New(Options{\n\t\tContentSecurityPolicy: \"default-src 'self'\",\n\t})\n\n\tres := httptest.NewRecorder()\n\treq, _ := http.NewRequestWithContext(context.Background(), http.MethodGet, \"/foo\", nil)\n\n\ts.Handler(myHandler).ServeHTTP(res, req)\n\n\texpect(t, res.Code, http.StatusOK)\n\texpect(t, res.Header().Get(\"Content-Security-Policy\"), \"default-src 'self'\")\n}\n\nfunc TestCspForRequestOnly(t *testing.T) {\n\ts := New(Options{\n\t\tContentSecurityPolicy: \"default-src 'self'\",\n\t})\n\n\tres := httptest.NewRecorder()\n\treq, _ := http.NewRequestWithContext(context.Background(), http.MethodGet, \"/foo\", nil)\n\n\ts.HandlerForRequestOnly(myHandler).ServeHTTP(res, req)\n\n\texpect(t, res.Code, http.StatusOK)\n\texpect(t, res.Header().Get(\"Content-Security-Policy\"), \"\")\n}\n\nfunc TestCspReportOnly(t *testing.T) {\n\ts := New(Options{\n\t\tContentSecurityPolicyReportOnly: \"default-src 'self'\",\n\t})\n\n\tres := httptest.NewRecorder()\n\treq, _ := http.NewRequestWithContext(context.Background(), http.MethodGet, \"/foo\", nil)\n\n\ts.Handler(myHandler).ServeHTTP(res, req)\n\n\texpect(t, res.Code, http.StatusOK)\n\texpect(t, res.Header().Get(\"Content-Security-Policy-Report-Only\"), \"default-src 'self'\")\n}\n\nfunc TestCspReportOnlyForRequestOnly(t *testing.T) {\n\ts := New(Options{\n\t\tContentSecurityPolicyReportOnly: \"default-src 'self'\",\n\t})\n\n\tres := httptest.NewRecorder()\n\treq, _ := http.NewRequestWithContext(context.Background(), http.MethodGet, \"/foo\", nil)\n\n\ts.HandlerForRequestOnly(myHandler).ServeHTTP(res, req)\n\n\texpect(t, res.Code, http.StatusOK)\n\texpect(t, res.Header().Get(\"Content-Security-Policy-Report-Only\"), \"\")\n}\n\nfunc TestInlineSecure(t *testing.T) {\n\ts := New(Options{\n\t\tFrameDeny: true,\n\t})\n\n\tres := httptest.NewRecorder()\n\treq, _ := http.NewRequestWithContext(context.Background(), http.MethodGet, \"/foo\", nil)\n\n\thandler := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\ts.HandlerFuncWithNext(w, r, nil)\n\t\t_, _ = w.Write([]byte(\"bar\"))\n\t})\n\n\thandler.ServeHTTP(res, req)\n\n\texpect(t, res.Code, http.StatusOK)\n\texpect(t, res.Header().Get(\"X-Frame-Options\"), \"DENY\")\n}\n\nfunc TestInlineSecureForRequestOnly(t *testing.T) {\n\ts := New(Options{\n\t\tFrameDeny: true,\n\t})\n\n\tres := httptest.NewRecorder()\n\treq, _ := http.NewRequestWithContext(context.Background(), http.MethodGet, \"/foo\", nil)\n\n\thandler := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\ts.HandlerFuncWithNextForRequestOnly(w, r, nil)\n\t\t_, _ = w.Write([]byte(\"bar\"))\n\t})\n\n\thandler.ServeHTTP(res, req)\n\n\texpect(t, res.Code, http.StatusOK)\n\texpect(t, res.Header().Get(\"X-Frame-Options\"), \"\")\n}\n\nfunc TestReferrer(t *testing.T) {\n\ts := New(Options{\n\t\tReferrerPolicy: \"same-origin\",\n\t})\n\n\tres := httptest.NewRecorder()\n\treq, _ := http.NewRequestWithContext(context.Background(), http.MethodGet, \"/foo\", nil)\n\n\ts.Handler(myHandler).ServeHTTP(res, req)\n\n\texpect(t, res.Code, http.StatusOK)\n\texpect(t, res.Header().Get(\"Referrer-Policy\"), \"same-origin\")\n}\n\nfunc TestReferrerForRequestOnly(t *testing.T) {\n\ts := New(Options{\n\t\tReferrerPolicy: \"same-origin\",\n\t})\n\n\tres := httptest.NewRecorder()\n\treq, _ := http.NewRequestWithContext(context.Background(), http.MethodGet, \"/foo\", nil)\n\n\ts.HandlerForRequestOnly(myHandler).ServeHTTP(res, req)\n\n\texpect(t, res.Code, http.StatusOK)\n\texpect(t, res.Header().Get(\"Referrer-Policy\"), \"\")\n}\n\nfunc TestFeaturePolicy(t *testing.T) {\n\ts := New(Options{\n\t\tFeaturePolicy: \"vibrate 'none';\",\n\t})\n\n\tres := httptest.NewRecorder()\n\treq, _ := http.NewRequestWithContext(context.Background(), http.MethodGet, \"/foo\", nil)\n\n\ts.Handler(myHandler).ServeHTTP(res, req)\n\n\texpect(t, res.Code, http.StatusOK)\n\texpect(t, res.Header().Get(\"Feature-Policy\"), \"vibrate 'none';\")\n}\n\nfunc TestPermissionsPolicy(t *testing.T) {\n\ts := New(Options{\n\t\tPermissionsPolicy: \"geolocation=(self)\",\n\t})\n\n\tres := httptest.NewRecorder()\n\treq, _ := http.NewRequestWithContext(context.Background(), http.MethodGet, \"/foo\", nil)\n\n\ts.Handler(myHandler).ServeHTTP(res, req)\n\n\texpect(t, res.Code, http.StatusOK)\n\texpect(t, res.Header().Get(\"Permissions-Policy\"), \"geolocation=(self)\")\n}\n\nfunc TestCrossOriginOpenerPolicy(t *testing.T) {\n\ts := New(Options{\n\t\tCrossOriginOpenerPolicy: \"same-origin\",\n\t})\n\n\tres := httptest.NewRecorder()\n\treq, _ := http.NewRequestWithContext(context.Background(), http.MethodGet, \"/foo\", nil)\n\n\ts.Handler(myHandler).ServeHTTP(res, req)\n\n\texpect(t, res.Code, http.StatusOK)\n\texpect(t, res.Header().Get(\"Cross-Origin-Opener-Policy\"), \"same-origin\")\n}\n\nfunc TestCrossOriginEmbedderPolicy(t *testing.T) {\n\ts := New(Options{\n\t\tCrossOriginEmbedderPolicy: \"require-corp\",\n\t})\n\n\tres := httptest.NewRecorder()\n\treq, _ := http.NewRequestWithContext(context.Background(), http.MethodGet, \"/foo\", nil)\n\n\ts.Handler(myHandler).ServeHTTP(res, req)\n\n\texpect(t, res.Code, http.StatusOK)\n\texpect(t, res.Header().Get(\"Cross-Origin-Embedder-Policy\"), \"require-corp\")\n}\n\nfunc TestCrossOriginResourcePolicy(t *testing.T) {\n\ts := New(Options{\n\t\tCrossOriginResourcePolicy: \"same-origin\",\n\t})\n\n\tres := httptest.NewRecorder()\n\treq, _ := http.NewRequestWithContext(context.Background(), http.MethodGet, \"/foo\", nil)\n\n\ts.Handler(myHandler).ServeHTTP(res, req)\n\n\texpect(t, res.Code, http.StatusOK)\n\texpect(t, res.Header().Get(\"Cross-Origin-Resource-Policy\"), \"same-origin\")\n}\n\nfunc TestXDNSPreFetchControl(t *testing.T) {\n\ts := New(Options{\n\t\tXDNSPrefetchControl: \"on\",\n\t})\n\n\tres := httptest.NewRecorder()\n\treq, _ := http.NewRequestWithContext(context.Background(), http.MethodGet, \"/foo\", nil)\n\n\ts.Handler(myHandler).ServeHTTP(res, req)\n\n\texpect(t, res.Code, http.StatusOK)\n\texpect(t, res.Header().Get(\"X-DNS-Prefetch-Control\"), \"on\")\n\n\tk := New(Options{\n\t\tXDNSPrefetchControl: \"off\",\n\t})\n\n\tres = httptest.NewRecorder()\n\treq, _ = http.NewRequestWithContext(context.Background(), http.MethodGet, \"/bar\", nil)\n\n\tk.Handler(myHandler).ServeHTTP(res, req)\n\n\texpect(t, res.Code, http.StatusOK)\n\texpect(t, res.Header().Get(\"X-DNS-Prefetch-Control\"), \"off\")\n}\n\nfunc TestXPermittedCrossDomainPolicies(t *testing.T) {\n\ts := New(Options{\n\t\tXPermittedCrossDomainPolicies: \"none\",\n\t})\n\n\tres := httptest.NewRecorder()\n\treq, _ := http.NewRequestWithContext(context.Background(), http.MethodGet, \"/foo\", nil)\n\n\ts.Handler(myHandler).ServeHTTP(res, req)\n\n\texpect(t, res.Code, http.StatusOK)\n\texpect(t, res.Header().Get(\"X-Permitted-Cross-Domain-Policies\"), \"none\")\n}\n\nfunc TestIsSSL(t *testing.T) {\n\ts := New(Options{\n\t\tSSLProxyHeaders: map[string]string{\"X-Forwarded-Proto\": \"https\"},\n\t})\n\n\treq, _ := http.NewRequestWithContext(context.Background(), http.MethodGet, \"/foo\", nil)\n\texpect(t, s.isSSL(req), false)\n\n\treq, _ = http.NewRequestWithContext(context.Background(), http.MethodGet, \"/foo\", nil)\n\treq.TLS = &tls.ConnectionState{\n\t\tCipherSuite: 16,\n\t}\n\texpect(t, s.isSSL(req), true)\n\n\treq, _ = http.NewRequestWithContext(context.Background(), http.MethodGet, \"/foo\", nil)\n\treq.URL.Scheme = httpsSchema\n\texpect(t, s.isSSL(req), true)\n\n\treq, _ = http.NewRequestWithContext(context.Background(), http.MethodGet, \"/foo\", nil)\n\treq.Header.Add(\"X-Forwarded-Proto\", \"https\")\n\texpect(t, s.isSSL(req), true)\n}\n\nfunc TestSSLForceHostWithHTTPS(t *testing.T) {\n\ts := New(Options{\n\t\tSSLProxyHeaders: map[string]string{\"X-Forwarded-Proto\": \"https\"},\n\t\tSSLHost:         \"secure.example.com\",\n\t\tSSLForceHost:    true,\n\t})\n\n\tres := httptest.NewRecorder()\n\treq, _ := http.NewRequestWithContext(context.Background(), http.MethodGet, \"/foo\", nil)\n\treq.Host = exampleHost\n\treq.URL.Scheme = httpsSchema\n\treq.Header.Add(\"X-Forwarded-Proto\", \"https\")\n\n\ts.Handler(myHandler).ServeHTTP(res, req)\n\n\texpect(t, res.Code, http.StatusMovedPermanently)\n}\n\nfunc TestSSLForceHostWithHTTP(t *testing.T) {\n\ts := New(Options{\n\t\tSSLHost:      \"secure.example.com\",\n\t\tSSLForceHost: true,\n\t})\n\n\tres := httptest.NewRecorder()\n\treq, _ := http.NewRequestWithContext(context.Background(), http.MethodGet, \"/foo\", nil)\n\treq.Host = exampleHost\n\treq.URL.Scheme = httpSchema\n\treq.Header.Add(\"X-Forwarded-Proto\", \"http\")\n\n\ts.Handler(myHandler).ServeHTTP(res, req)\n\n\texpect(t, res.Code, http.StatusMovedPermanently)\n}\n\nfunc TestSSLForceHostWithSSLRedirect(t *testing.T) {\n\ts := New(Options{\n\t\tSSLRedirect:     true,\n\t\tSSLProxyHeaders: map[string]string{\"X-Forwarded-Proto\": \"https\"},\n\t\tSSLHost:         \"secure.example.com\",\n\t\tSSLForceHost:    true,\n\t})\n\n\tres := httptest.NewRecorder()\n\treq, _ := http.NewRequestWithContext(context.Background(), http.MethodGet, \"/foo\", nil)\n\treq.Host = exampleHost\n\treq.URL.Scheme = httpsSchema\n\treq.Header.Add(\"X-Forwarded-Proto\", \"https\")\n\n\ts.Handler(myHandler).ServeHTTP(res, req)\n\n\texpect(t, res.Code, http.StatusMovedPermanently)\n}\n\nfunc TestSSLForceHostTemporaryRedirect(t *testing.T) {\n\ts := New(Options{\n\t\tSSLProxyHeaders:      map[string]string{\"X-Forwarded-Proto\": \"https\"},\n\t\tSSLHost:              \"secure.example.com\",\n\t\tSSLForceHost:         true,\n\t\tSSLTemporaryRedirect: true,\n\t})\n\n\tres := httptest.NewRecorder()\n\treq, _ := http.NewRequestWithContext(context.Background(), http.MethodGet, \"/foo\", nil)\n\treq.Host = exampleHost\n\treq.URL.Scheme = httpsSchema\n\treq.Header.Add(\"X-Forwarded-Proto\", \"https\")\n\n\ts.Handler(myHandler).ServeHTTP(res, req)\n\n\texpect(t, res.Code, http.StatusTemporaryRedirect)\n}\n\nfunc TestModifyResponseHeadersNoSSL(t *testing.T) {\n\ts := New(Options{\n\t\tSSLRedirect: false,\n\t})\n\n\tres := &http.Response{}\n\tres.Header = http.Header{\"Location\": []string{\"http://example.com\"}}\n\n\terr := s.ModifyResponseHeaders(res)\n\texpect(t, err, nil)\n\n\texpect(t, res.Header.Get(\"Location\"), \"http://example.com\")\n}\n\nfunc TestModifyResponseHeadersWithSSLAndDifferentSSLHost(t *testing.T) {\n\ts := New(Options{\n\t\tSSLRedirect:     true,\n\t\tSSLHost:         \"secure.example.com\",\n\t\tSSLProxyHeaders: map[string]string{\"X-Forwarded-Proto\": \"https\"},\n\t})\n\n\treq, _ := http.NewRequestWithContext(context.Background(), http.MethodGet, \"/foo\", nil)\n\treq.Host = exampleHost\n\treq.URL.Scheme = httpSchema\n\treq.Header.Add(\"X-Forwarded-Proto\", \"https\")\n\n\tres := &http.Response{}\n\tres.Header = http.Header{\"Location\": []string{\"http://example.com\"}}\n\tres.Request = req\n\n\texpect(t, res.Header.Get(\"Location\"), \"http://example.com\")\n\n\terr := s.ModifyResponseHeaders(res)\n\texpect(t, err, nil)\n\n\texpect(t, res.Header.Get(\"Location\"), \"http://example.com\")\n}\n\nfunc TestModifyResponseHeadersWithSSLAndNoSSLHost(t *testing.T) {\n\ts := New(Options{\n\t\tSSLRedirect:     true,\n\t\tSSLProxyHeaders: map[string]string{\"X-Forwarded-Proto\": \"https\"},\n\t})\n\n\treq, _ := http.NewRequestWithContext(context.Background(), http.MethodGet, \"/foo\", nil)\n\treq.Host = exampleHost\n\treq.URL.Scheme = httpSchema\n\treq.Header.Add(\"X-Forwarded-Proto\", \"https\")\n\n\tres := &http.Response{}\n\tres.Header = http.Header{\"Location\": []string{\"http://example.com\"}}\n\tres.Request = req\n\n\texpect(t, res.Header.Get(\"Location\"), \"http://example.com\")\n\n\terr := s.ModifyResponseHeaders(res)\n\texpect(t, err, nil)\n\n\texpect(t, res.Header.Get(\"Location\"), \"http://example.com\")\n}\n\nfunc TestModifyResponseHeadersWithSSLAndMatchingSSLHost(t *testing.T) {\n\ts := New(Options{\n\t\tSSLRedirect:     true,\n\t\tSSLHost:         \"secure.example.com\",\n\t\tSSLProxyHeaders: map[string]string{\"X-Forwarded-Proto\": \"https\"},\n\t})\n\n\treq, _ := http.NewRequestWithContext(context.Background(), http.MethodGet, \"/foo\", nil)\n\treq.Host = exampleHost\n\treq.URL.Scheme = httpSchema\n\treq.Header.Add(\"X-Forwarded-Proto\", \"https\")\n\n\tres := &http.Response{}\n\tres.Header = http.Header{\"Location\": []string{\"http://secure.example.com\"}}\n\tres.Request = req\n\n\texpect(t, res.Header.Get(\"Location\"), \"http://secure.example.com\")\n\n\terr := s.ModifyResponseHeaders(res)\n\texpect(t, err, nil)\n\n\texpect(t, res.Header.Get(\"Location\"), \"https://secure.example.com\")\n}\n\nfunc TestModifyResponseHeadersWithSSLAndPortInLocationResponse(t *testing.T) {\n\ts := New(Options{\n\t\tSSLRedirect:     true,\n\t\tSSLHost:         \"secure.example.com\",\n\t\tSSLProxyHeaders: map[string]string{\"X-Forwarded-Proto\": \"https\"},\n\t})\n\n\treq, _ := http.NewRequestWithContext(context.Background(), http.MethodGet, \"/foo\", nil)\n\treq.Host = exampleHost\n\treq.URL.Scheme = httpSchema\n\treq.Header.Add(\"X-Forwarded-Proto\", \"https\")\n\n\tres := &http.Response{}\n\tres.Header = http.Header{\"Location\": []string{\"http://secure.example.com:877\"}}\n\tres.Request = req\n\n\texpect(t, res.Header.Get(\"Location\"), \"http://secure.example.com:877\")\n\n\terr := s.ModifyResponseHeaders(res)\n\texpect(t, err, nil)\n\n\texpect(t, res.Header.Get(\"Location\"), \"http://secure.example.com:877\")\n}\n\nfunc TestModifyResponseHeadersWithSSLAndPathInLocationResponse(t *testing.T) {\n\ts := New(Options{\n\t\tSSLRedirect:     true,\n\t\tSSLHost:         \"secure.example.com\",\n\t\tSSLProxyHeaders: map[string]string{\"X-Forwarded-Proto\": \"https\"},\n\t})\n\n\treq, _ := http.NewRequestWithContext(context.Background(), http.MethodGet, \"/foo\", nil)\n\treq.Host = exampleHost\n\treq.URL.Scheme = httpSchema\n\treq.Header.Add(\"X-Forwarded-Proto\", \"https\")\n\n\tres := &http.Response{}\n\tres.Header = http.Header{\"Location\": []string{\"http://secure.example.com/admin/login\"}}\n\tres.Request = req\n\n\texpect(t, res.Header.Get(\"Location\"), \"http://secure.example.com/admin/login\")\n\n\terr := s.ModifyResponseHeaders(res)\n\texpect(t, err, nil)\n\n\texpect(t, res.Header.Get(\"Location\"), \"https://secure.example.com/admin/login\")\n}\n\nfunc TestCustomSecureContextKey(t *testing.T) {\n\ts1 := New(Options{\n\t\tBrowserXssFilter:      true,\n\t\tCustomBrowserXssValue: \"0\",\n\t\tSecureContextKey:      \"totallySecureContextKey\",\n\t})\n\n\tres := httptest.NewRecorder()\n\treq, _ := http.NewRequestWithContext(context.Background(), http.MethodGet, \"/foo\", nil)\n\n\tvar actual *http.Request\n\n\thf := func(_ http.ResponseWriter, r *http.Request) {\n\t\tactual = r\n\t}\n\n\ts1.HandlerFuncWithNextForRequestOnly(res, req, hf)\n\tcontextHeaders, _ := actual.Context().Value(s1.ctxSecureHeaderKey).(http.Header)\n\texpect(t, contextHeaders.Get(xssProtectionHeader), s1.opt.CustomBrowserXssValue)\n}\n\nfunc TestMultipleCustomSecureContextKeys(t *testing.T) {\n\ts1 := New(Options{\n\t\tBrowserXssFilter:      true,\n\t\tCustomBrowserXssValue: \"0\",\n\t\tSecureContextKey:      \"totallySecureContextKey\",\n\t})\n\n\ts2 := New(Options{\n\t\tFeaturePolicy:    \"test\",\n\t\tSecureContextKey: \"anotherSecureContextKey\",\n\t})\n\n\tres := httptest.NewRecorder()\n\treq, _ := http.NewRequestWithContext(context.Background(), http.MethodGet, \"/foo\", nil)\n\n\tvar actual *http.Request\n\n\thf := http.HandlerFunc(func(_ http.ResponseWriter, r *http.Request) {\n\t\tactual = r\n\t})\n\n\tnext := s1.HandlerForRequestOnly(hf)\n\ts2.HandlerFuncWithNextForRequestOnly(res, req, next.ServeHTTP)\n\n\ts1Headers, _ := actual.Context().Value(s1.ctxSecureHeaderKey).(http.Header)\n\ts2Headers, _ := actual.Context().Value(s2.ctxSecureHeaderKey).(http.Header)\n\n\texpect(t, s1Headers.Get(xssProtectionHeader), s1.opt.CustomBrowserXssValue)\n\texpect(t, s2Headers.Get(featurePolicyHeader), s2.opt.FeaturePolicy)\n}\n\nfunc TestAllowRequestFuncTrue(t *testing.T) {\n\ts := New(Options{\n\t\tAllowRequestFunc: func(_ *http.Request) bool { return true },\n\t})\n\n\tres := httptest.NewRecorder()\n\treq, _ := http.NewRequestWithContext(context.Background(), http.MethodGet, \"/foo\", nil)\n\treq.Host = \"www.allow-request.com\"\n\n\ts.Handler(myHandler).ServeHTTP(res, req)\n\n\texpect(t, res.Code, http.StatusOK)\n\texpect(t, res.Body.String(), `bar`)\n}\n\nfunc TestAllowRequestFuncFalse(t *testing.T) {\n\ts := New(Options{\n\t\tAllowRequestFunc: func(_ *http.Request) bool { return false },\n\t})\n\n\tres := httptest.NewRecorder()\n\treq, _ := http.NewRequestWithContext(context.Background(), http.MethodGet, \"/foo\", nil)\n\treq.Host = \"www.deny-request.com\"\n\n\ts.Handler(myHandler).ServeHTTP(res, req)\n\n\texpect(t, res.Code, http.StatusBadRequest)\n}\n\nfunc TestBadRequestHandler(t *testing.T) {\n\ts := New(Options{\n\t\tAllowRequestFunc: func(_ *http.Request) bool { return false },\n\t})\n\tbadRequestFunc := http.HandlerFunc(func(w http.ResponseWriter, _ *http.Request) {\n\t\thttp.Error(w, \"custom error\", http.StatusConflict)\n\t})\n\ts.SetBadRequestHandler(badRequestFunc)\n\n\tres := httptest.NewRecorder()\n\treq, _ := http.NewRequestWithContext(context.Background(), http.MethodGet, \"/foo\", nil)\n\treq.Host = \"www.deny-request.com\"\n\n\ts.Handler(myHandler).ServeHTTP(res, req)\n\n\texpect(t, res.Code, http.StatusConflict)\n\texpect(t, strings.TrimSpace(res.Body.String()), `custom error`)\n}\n\nfunc TestMarshal(t *testing.T) {\n\t// Options has struct field tags to omit func fields\n\tvar o1 Options\n\n\tb, err := json.Marshal(o1) //nolint:musttag\n\tif err != nil {\n\t\tt.Errorf(\"unexpected error marshal: %v\", err)\n\t}\n\n\terr = json.Unmarshal(b, &o1) //nolint:musttag\n\tif err != nil {\n\t\tt.Errorf(\"unexpected error unmarshal: %v\", err)\n\t}\n}\n\n// Test Helper.\nfunc expect(t *testing.T, a interface{}, b interface{}) {\n\tt.Helper()\n\n\tif a != b {\n\t\tt.Errorf(\"Expected [%v] (type %v) - Got [%v] (type %v)\", b, reflect.TypeOf(b), a, reflect.TypeOf(a))\n\t}\n}\n"
        }
      ]
    }
  ]
}