{
  "metadata": {
    "timestamp": 1736567276186,
    "page": 874,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjg4MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "jpillora/overseer",
      "stars": 2331,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.03125,
          "content": "tmp\nmyapp*\nexample/docker\n.idea\n"
        },
        {
          "name": "CONTRIBUTING.md",
          "type": "blob",
          "size": 3.4697265625,
          "content": "\n### Issues\n\nIf you've found a bug, please create an [issue](https://github.com/jpillora/overseer/issues) or if possible, create a fix and send in a pull request.\n\n## Contributing\n\nIf you'd like to contribute, please see the notes below and create an issue mentioning want you want to work on and if you're creating an addition to the core `overseer` repo, then also include the proposed API.\n\n## Issues and bug fixes\n\n### Tests\n\n`overseer` needs a test which suite should drive an:\n\n* HTTP client for verifying application version\n* HTTP server for providing application upgrades\n* an `overseer` process via `exec.Cmd`\n\nAnd as it operates, confirm each phase.\n\n### Updatable config\n\nChild process should pass new config back to the main process and:\n* Update logging settings\n* Update socket bindings\n\n---\n\n## Extra Features\n\nBelow is a list of **optional extras** which would be nice to have. Optional is emphasised here because this project aims to maintain its small API surface.\n\n### More fetchers\n\nIn general New fetchers should go in their own repos which can be linked to from the `overseer` docs. Arguably, the S3 fetcher should have been in it's own repo due to the size of the dependent package `github.com/aws/aws-sdk-go`, though this would break existing programs. Similarly, if a fetcher is reasonably simple and only uses the standard library then it could be included in this repo (e.g. the Github fetcher since it would just need `net/http`).\n\n* HTTP fetcher long-polling (pseduo-push)\n* SCP fetcher (connect to a server, poll path)\n* Github fetcher (given a repo, poll releases)\n* etcd fetcher (given a cluster, watch key)\n* [Omaha](https://github.com/google/omaha) fetcher (a client which speaks omaha, downloads appropriate binary)\n\n### Binary diffs and signatures\n\n* There's two ways to implement binary upgrades:\n  1. As as a stand-alone fetcher. The fetcher itself performs the binary merge to produce new binaries and just passes them to `overseer` as a complete binary (`io.Reader`).\n  1. As a base feature. Create a binary format for delta upgrades, maybe something like:\n\n    ```\n    [\"overseer-delta-upgrade\" 22 bytes][(l)ength-of-config 4 bytes][JSON config l bytes][binary delta]\n    ```\n\n    The CLI would produce these delta upgrades and any fetcher could return one as a binary stream. Overseer just checks for the `\"overseer-delta-upgrade\"` string. The benefit of implementing this in overseer core is all fetchers would implicitly inherit this functionality.\n* In **both** cases, each will need to ship with a corresponding CLI tool, this tool:\n  * Must calculate and create delta updates using [binarydist](https://github.com/kr/binarydist)\n    * [Courgette](http://dev.chromium.org/developers/design-documents/software-updates-courgette) would be better though not sure about Go compatibility\n  * Optionally sign binaries\n      * Create signing ECDSA private and private key\n      * Store public and private keys on the build machine\n      * Embed public keys into the binaries with\n\n        ```\n        -ldflags \"-X github.com/jpillora/overseer/fetcher.PublicKey=A\" -o myapp\n        ```\n      * Only accept future updates with binaries signed by the matching private key\n\n### Versioning\n\n* Originally, there was versioning in the API, though it added complexity and it was removed in favour of a simple binary `ID` which is just SHA1 of the binary.\n* Local rollbacks might be handy though this requires some form of storage. At the moment, everything is inside the pre-existing binary so there is nothing to store.\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.0546875,
          "content": "The MIT License (MIT)\n\nCopyright (c) 2017 Jaime Pillora\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 6.80078125,
          "content": "# overseer\n\n[![GoDoc](https://godoc.org/github.com/jpillora/overseer?status.svg)](https://godoc.org/github.com/jpillora/overseer)   [![Tests](https://github.com/jpillora/overseer/workflows/Tests/badge.svg)](https://github.com/jpillora/overseer/actions?workflow=Tests)\n\n`overseer` is a package for creating monitorable, gracefully restarting, self-upgrading binaries in Go (golang). The main goal of this project is to facilitate the creation of self-upgrading binaries which play nice with standard process managers, secondly it should expose a small and simple API with reasonable defaults.\n\n![overseer diagram](https://docs.google.com/drawings/d/1o12njYyRILy3UDs2E6JzyJEl0psU4ePYiMQ20jiuVOY/pub?w=566&h=284)\n\nCommonly, graceful restarts are performed by the active process (*dark blue*) closing its listeners and passing these matching listening socket files (*green*) over to a newly started process. This restart causes any **foreground** process monitoring to incorrectly detect a program crash. `overseer` attempts to solve this by using a small process to perform this socket file exchange and proxying signals and exit code from the active process.\n\n### Features\n\n* Simple\n* Works with process managers (systemd, upstart, supervisor, etc)\n* Graceful, zero-down time restarts\n* Easy self-upgrading binaries\n\n### Install\n\n```sh\ngo get github.com/jpillora/overseer\n```\n\n### Quick example\n\nThis program works with process managers, supports graceful, zero-down time restarts and self-upgrades its own binary.\n\n``` go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"log\"\n\t\"net/http\"\n\t\"time\"\n\n\t\"github.com/jpillora/overseer\"\n\t\"github.com/jpillora/overseer/fetcher\"\n)\n\n//create another main() to run the overseer process\n//and then convert your old main() into a 'prog(state)'\nfunc main() {\n\toverseer.Run(overseer.Config{\n\t\tProgram: prog,\n\t\tAddress: \":3000\",\n\t\tFetcher: &fetcher.HTTP{\n\t\t\tURL:      \"http://localhost:4000/binaries/myapp\",\n\t\t\tInterval: 1 * time.Second,\n\t\t},\n\t})\n}\n\n//prog(state) runs in a child process\nfunc prog(state overseer.State) {\n\tlog.Printf(\"app (%s) listening...\", state.ID)\n\thttp.Handle(\"/\", http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tfmt.Fprintf(w, \"app (%s) says hello\\n\", state.ID)\n\t}))\n\thttp.Serve(state.Listener, nil)\n}\n```\n\n**How it works:**\n\n* `overseer` uses the main process to check for and install upgrades and a child process to run `Program`.\n* The main process retrieves the files of the listeners described by `Address/es`.\n* The child process is provided with these files which is converted into a `Listener/s` for the `Program` to consume.\n* All child process pipes are connected back to the main process.\n* All signals received on the main process are forwarded through to the child process.\n* `Fetcher` runs in a goroutine and checks for updates at preconfigured interval. When `Fetcher` returns a valid binary stream (`io.Reader`), the master process saves it to a temporary location, verifies it, replaces the current binary and initiates a graceful restart.\n* The `fetcher.HTTP` accepts a `URL`, it polls this URL with HEAD requests and until it detects a change. On change, we `GET` the `URL` and stream it back out to `overseer`. See also `fetcher.S3`.\n* Once a binary is received, it is run with a simple echo token to confirm it is a `overseer` binary.\n* Except for scheduled restarts, the active child process exiting will cause the main process to exit with the same code. So, **`overseer` is not a process manager**.\n\nSee [Config](https://godoc.org/github.com/jpillora/overseer#Config)uration options [here](https://godoc.org/github.com/jpillora/overseer#Config) and the runtime [State](https://godoc.org/github.com/jpillora/overseer#State) available to your program [here](https://godoc.org/github.com/jpillora/overseer#State).\n\n### More examples\n\nSee the [example/](example/) directory and run `example.sh`, you should see the following output:\n\n```sh\n$ cd example/\n$ sh example.sh\nBUILT APP (1)\nRUNNING APP\napp#1 (c7940a5bfc3f0e8633d3bf775f54bb59f50b338e) listening...\napp#1 (c7940a5bfc3f0e8633d3bf775f54bb59f50b338e) says hello\napp#1 (c7940a5bfc3f0e8633d3bf775f54bb59f50b338e) says hello\nBUILT APP (2)\napp#2 (3dacb8bc673c1b4d38f8fb4fad5b017671aa8a67) listening...\napp#2 (3dacb8bc673c1b4d38f8fb4fad5b017671aa8a67) says hello\napp#2 (3dacb8bc673c1b4d38f8fb4fad5b017671aa8a67) says hello\napp#1 (c7940a5bfc3f0e8633d3bf775f54bb59f50b338e) says hello\napp#1 (c7940a5bfc3f0e8633d3bf775f54bb59f50b338e) exiting...\nBUILT APP (3)\napp#3 (b7614e7ff42eed8bb334ed35237743b0e4041678) listening...\napp#3 (b7614e7ff42eed8bb334ed35237743b0e4041678) says hello\napp#3 (b7614e7ff42eed8bb334ed35237743b0e4041678) says hello\napp#2 (3dacb8bc673c1b4d38f8fb4fad5b017671aa8a67) says hello\napp#2 (3dacb8bc673c1b4d38f8fb4fad5b017671aa8a67) exiting...\napp#3 (b7614e7ff42eed8bb334ed35237743b0e4041678) says hello\n```\n\n**Note:** `app#1` stays running until the last request is closed.\n\n#### Only use graceful restarts\n\n```go\nfunc main() {\n\toverseer.Run(overseer.Config{\n\t\tProgram: prog,\n\t\tAddress: \":3000\",\n\t})\n}\n```\n\nSend `main` a `SIGUSR2` (`Config.RestartSignal`) to manually trigger a restart\n\n#### Only use auto-upgrades, no restarts\n\n```go\nfunc main() {\n\toverseer.Run(overseer.Config{\n\t\tProgram: prog,\n\t\tNoRestart: true,\n\t\tFetcher: &fetcher.HTTP{\n\t\t\tURL:      \"http://localhost:4000/binaries/myapp\",\n\t\t\tInterval: 1 * time.Second,\n\t\t},\n\t})\n}\n```\n\nYour binary will be upgraded though it will require manual restart from the user, suitable for creating self-upgrading command-line applications.\n\n#### Multi-platform binaries using a dynamic fetch `URL`\n\n```go\nfunc main() {\n\toverseer.Run(overseer.Config{\n\t\tProgram: prog,\n\t\tFetcher: &fetcher.HTTP{\n\t\t\tURL: \"http://localhost:4000/binaries/app-\"+runtime.GOOS+\"-\"+runtime.GOARCH,\n\t\t\t//e.g.http://localhost:4000/binaries/app-linux-amd64\n\t\t},\n\t})\n}\n```\n\n### Known issues\n\n* The master process's `overseer.Config` cannot be changed via an upgrade, the master process must be restarted.\n\t* Therefore, `Addresses` can only be changed by restarting the main process.\n* Currently shells out to `mv` for moving files because `mv` handles cross-partition moves unlike `os.Rename`.\n* Package `init()` functions will run twice on start, once in the main process and once in the child process.\n\n### More documentation\n\n* [Core `overseer` package](https://godoc.org/github.com/jpillora/overseer)\n* [Common `fetcher.Interface`](https://godoc.org/github.com/jpillora/overseer/fetcher#Interface)\n\t* [File fetcher](https://godoc.org/github.com/jpillora/overseer/fetcher#File)\n\t* [HTTP fetcher](https://godoc.org/github.com/jpillora/overseer/fetcher#HTTP)\n\t* [S3 fetcher](https://godoc.org/github.com/jpillora/overseer/fetcher#S3)\n\t* [Github fetcher](https://godoc.org/github.com/jpillora/overseer/fetcher#Github)\n\n### Third-party Fetchers\n\n* [overseer-bindiff](https://github.com/tgulacsi/overseer-bindiff) A binary diff fetcher and builder\n\n### Contributing\n\nSee [CONTRIBUTING.md](CONTRIBUTING.md)\n"
        },
        {
          "name": "example",
          "type": "tree",
          "content": null
        },
        {
          "name": "fetcher",
          "type": "tree",
          "content": null
        },
        {
          "name": "go.mod",
          "type": "blob",
          "size": 0.1943359375,
          "content": "module github.com/jpillora/overseer\n\ngo 1.13\n\nrequire (\n\tgithub.com/StackExchange/wmi v0.0.0-20190523213315-cbe66965904d\n\tgithub.com/go-ole/go-ole v1.2.4 // indirect\n\tgithub.com/jpillora/s3 v1.1.4\n)\n"
        },
        {
          "name": "go.sum",
          "type": "blob",
          "size": 0.9072265625,
          "content": "github.com/StackExchange/wmi v0.0.0-20190523213315-cbe66965904d h1:G0m3OIz70MZUWq3EgK3CesDbo8upS2Vm9/P3FtgI+Jk=\ngithub.com/StackExchange/wmi v0.0.0-20190523213315-cbe66965904d/go.mod h1:3eOhrUMpNV+6aFIbp5/iudMxNCF27Vw2OZgy4xEx0Fg=\ngithub.com/go-ole/go-ole v1.2.4 h1:nNBDSCOigTSiarFpYE9J/KtEA1IOW4CNeqT9TQDqCxI=\ngithub.com/go-ole/go-ole v1.2.4/go.mod h1:XCwSNxSkXRo4vlyPy93sltvi/qJq0jqQhjqQNIwKuxM=\ngithub.com/jpillora/s3 v1.1.4 h1:YCCKDWzb/Ye9EBNd83ATRF/8wPEy0xd43Rezb6u6fzc=\ngithub.com/jpillora/s3 v1.1.4/go.mod h1:yedE603V+crlFi1Kl/5vZJaBu9pUzE9wvKegU/lF2zs=\ngithub.com/smartystreets/assertions v1.0.1 h1:voD4ITNjPL5jjBfgR/r8fPIIBrliWrWHeiJApdr3r4w=\ngithub.com/smartystreets/assertions v1.0.1/go.mod h1:kHHU4qYBaI3q23Pp3VPrmWhuIUrLW/7eUrw0BU5VaoM=\ngithub.com/smartystreets/gunit v1.1.3 h1:32x+htJCu3aMswhPw3teoJ+PnWPONqdNgaGs6Qt8ZaU=\ngithub.com/smartystreets/gunit v1.1.3/go.mod h1:EH5qMBab2UclzXUcpR8b93eHsIlp9u+pDQIRp5DZNzQ=\n"
        },
        {
          "name": "graceful.go",
          "type": "blob",
          "size": 1.9501953125,
          "content": "package overseer\n\n//overseer listeners and connections allow graceful\n//restarts by tracking when all connections from a listener\n//have been closed\n\nimport (\n\t\"net\"\n\t\"os\"\n\t\"sync\"\n\t\"time\"\n)\n\nfunc newOverseerListener(l net.Listener) *overseerListener {\n\treturn &overseerListener{\n\t\tListener:     l,\n\t\tcloseByForce: make(chan bool),\n\t}\n}\n\n//gracefully closing net.Listener\ntype overseerListener struct {\n\tnet.Listener\n\tcloseError   error\n\tcloseByForce chan bool\n\twg           sync.WaitGroup\n}\n\nfunc (l *overseerListener) Accept() (net.Conn, error) {\n\tconn, err := l.Listener.(*net.TCPListener).AcceptTCP()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tconn.SetKeepAlive(true)                  // see http.tcpKeepAliveListener\n\tconn.SetKeepAlivePeriod(3 * time.Minute) // see http.tcpKeepAliveListener\n\tuconn := overseerConn{\n\t\tConn:   conn,\n\t\twg:     &l.wg,\n\t\tclosed: make(chan bool),\n\t}\n\tgo func() {\n\t\t//connection watcher\n\t\tselect {\n\t\tcase <-l.closeByForce:\n\t\t\tuconn.Close()\n\t\tcase <-uconn.closed:\n\t\t\t//closed manually\n\t\t}\n\t}()\n\tl.wg.Add(1)\n\treturn uconn, nil\n}\n\n//non-blocking trigger close\nfunc (l *overseerListener) release(timeout time.Duration) {\n\t//stop accepting connections - release fd\n\tl.closeError = l.Listener.Close()\n\t//start timer, close by force if deadline not met\n\twaited := make(chan bool)\n\tgo func() {\n\t\tl.wg.Wait()\n\t\twaited <- true\n\t}()\n\tgo func() {\n\t\tselect {\n\t\tcase <-time.After(timeout):\n\t\t\tclose(l.closeByForce)\n\t\tcase <-waited:\n\t\t\t//no need to force close\n\t\t}\n\t}()\n}\n\n//blocking wait for close\nfunc (l *overseerListener) Close() error {\n\tl.wg.Wait()\n\treturn l.closeError\n}\n\nfunc (l *overseerListener) File() *os.File {\n\t// returns a dup(2) - FD_CLOEXEC flag *not* set\n\ttl := l.Listener.(*net.TCPListener)\n\tfl, _ := tl.File()\n\treturn fl\n}\n\n//notifying on close net.Conn\ntype overseerConn struct {\n\tnet.Conn\n\twg     *sync.WaitGroup\n\tclosed chan bool\n}\n\nfunc (o overseerConn) Close() error {\n\terr := o.Conn.Close()\n\tif err == nil {\n\t\to.wg.Done()\n\t\to.closed <- true\n\t}\n\treturn err\n}\n"
        },
        {
          "name": "overseer.go",
          "type": "blob",
          "size": 4.68359375,
          "content": "// Package overseer implements daemonizable\n// self-upgrading binaries in Go (golang).\npackage overseer\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"log\"\n\t\"os\"\n\t\"runtime\"\n\t\"time\"\n\n\t\"github.com/jpillora/overseer/fetcher\"\n)\n\nconst (\n\tenvSlaveID        = \"OVERSEER_SLAVE_ID\"\n\tenvIsSlave        = \"OVERSEER_IS_SLAVE\"\n\tenvNumFDs         = \"OVERSEER_NUM_FDS\"\n\tenvBinID          = \"OVERSEER_BIN_ID\"\n\tenvBinPath        = \"OVERSEER_BIN_PATH\"\n\tenvBinCheck       = \"OVERSEER_BIN_CHECK\"\n\tenvBinCheckLegacy = \"GO_UPGRADE_BIN_CHECK\"\n)\n\n// Config defines overseer's run-time configuration\ntype Config struct {\n\t//Required will prevent overseer from fallback to running\n\t//running the program in the main process on failure.\n\tRequired bool\n\t//Program's main function\n\tProgram func(state State)\n\t//Program's zero-downtime socket listening address (set this or Addresses)\n\tAddress string\n\t//Program's zero-downtime socket listening addresses (set this or Address)\n\tAddresses []string\n\t//RestartSignal will manually trigger a graceful restart. Defaults to SIGUSR2.\n\tRestartSignal os.Signal\n\t//TerminateTimeout controls how long overseer should\n\t//wait for the program to terminate itself. After this\n\t//timeout, overseer will issue a SIGKILL.\n\tTerminateTimeout time.Duration\n\t//MinFetchInterval defines the smallest duration between Fetch()s.\n\t//This helps to prevent unwieldy fetch.Interfaces from hogging\n\t//too many resources. Defaults to 1 second.\n\tMinFetchInterval time.Duration\n\t//PreUpgrade runs after a binary has been retrieved, user defined checks\n\t//can be run here and returning an error will cancel the upgrade.\n\tPreUpgrade func(tempBinaryPath string) error\n\t//Debug enables all [overseer] logs.\n\tDebug bool\n\t//NoWarn disables warning [overseer] logs.\n\tNoWarn bool\n\t//NoRestart disables all restarts, this option essentially converts\n\t//the RestartSignal into a \"ShutdownSignal\".\n\tNoRestart bool\n\t//NoRestartAfterFetch disables automatic restarts after each upgrade.\n\t//Though manual restarts using the RestartSignal can still be performed.\n\tNoRestartAfterFetch bool\n\t//Fetcher will be used to fetch binaries.\n\tFetcher fetcher.Interface\n}\n\nfunc validate(c *Config) error {\n\t//validate\n\tif c.Program == nil {\n\t\treturn errors.New(\"overseer.Config.Program required\")\n\t}\n\tif c.Address != \"\" {\n\t\tif len(c.Addresses) > 0 {\n\t\t\treturn errors.New(\"overseer.Config.Address and Addresses cant both be set\")\n\t\t}\n\t\tc.Addresses = []string{c.Address}\n\t} else if len(c.Addresses) > 0 {\n\t\tc.Address = c.Addresses[0]\n\t}\n\tif c.RestartSignal == nil {\n\t\tc.RestartSignal = SIGUSR2\n\t}\n\tif c.TerminateTimeout <= 0 {\n\t\tc.TerminateTimeout = 30 * time.Second\n\t}\n\tif c.MinFetchInterval <= 0 {\n\t\tc.MinFetchInterval = 1 * time.Second\n\t}\n\treturn nil\n}\n\n//RunErr allows manual handling of any\n//overseer errors.\nfunc RunErr(c Config) error {\n\treturn runErr(&c)\n}\n\n//Run executes overseer, if an error is\n//encountered, overseer fallsback to running\n//the program directly (unless Required is set).\nfunc Run(c Config) {\n\terr := runErr(&c)\n\tif err != nil {\n\t\tif c.Required {\n\t\t\tlog.Fatalf(\"[overseer] %s\", err)\n\t\t} else if c.Debug || !c.NoWarn {\n\t\t\tlog.Printf(\"[overseer] disabled. run failed: %s\", err)\n\t\t}\n\t\tc.Program(DisabledState)\n\t\treturn\n\t}\n\tos.Exit(0)\n}\n\n//sanityCheck returns true if a check was performed\nfunc sanityCheck() bool {\n\t//sanity check\n\tif token := os.Getenv(envBinCheck); token != \"\" {\n\t\tfmt.Fprint(os.Stdout, token)\n\t\treturn true\n\t}\n\t//legacy sanity check using old env var\n\tif token := os.Getenv(envBinCheckLegacy); token != \"\" {\n\t\tfmt.Fprint(os.Stdout, token)\n\t\treturn true\n\t}\n\treturn false\n}\n\n//SanityCheck manually runs the check to ensure this binary\n//is compatible with overseer. This tries to ensure that a restart\n//is never performed against a bad binary, as it would require\n//manual intervention to rectify. This is automatically done\n//on overseer.Run() though it can be manually run prior whenever\n//necessary.\nfunc SanityCheck() {\n\tif sanityCheck() {\n\t\tos.Exit(0)\n\t}\n}\n\n//abstraction over master/slave\nvar currentProcess interface {\n\ttriggerRestart()\n\trun() error\n}\n\nfunc runErr(c *Config) error {\n\t//os not supported\n\tif !supported {\n\t\treturn fmt.Errorf(\"os (%s) not supported\", runtime.GOOS)\n\t}\n\tif err := validate(c); err != nil {\n\t\treturn err\n\t}\n\tif sanityCheck() {\n\t\treturn nil\n\t}\n\t//run either in master or slave mode\n\tif os.Getenv(envIsSlave) == \"1\" {\n\t\tcurrentProcess = &slave{Config: c}\n\t} else {\n\t\tcurrentProcess = &master{Config: c}\n\t}\n\treturn currentProcess.run()\n}\n\n//Restart programmatically triggers a graceful restart. If NoRestart\n//is enabled, then this will essentially be a graceful shutdown.\nfunc Restart() {\n\tif currentProcess != nil {\n\t\tcurrentProcess.triggerRestart()\n\t}\n}\n\n//IsSupported returns whether overseer is supported on the current OS.\nfunc IsSupported() bool {\n\treturn supported\n}\n"
        },
        {
          "name": "proc_master.go",
          "type": "blob",
          "size": 10.6416015625,
          "content": "package overseer\n\nimport (\n\t\"bytes\"\n\t\"crypto/rand\"\n\t\"crypto/sha1\"\n\t\"encoding/hex\"\n\t\"fmt\"\n\t\"io\"\n\t\"log\"\n\t\"net\"\n\t\"os\"\n\t\"os/exec\"\n\t\"os/signal\"\n\t\"path/filepath\"\n\t\"runtime\"\n\t\"strconv\"\n\t\"sync\"\n\t\"syscall\"\n\t\"time\"\n)\n\nvar tmpBinPath = filepath.Join(os.TempDir(), \"overseer-\"+token()+extension())\n\n//a overseer master process\ntype master struct {\n\t*Config\n\tslaveID             int\n\tslaveCmd            *exec.Cmd\n\tslaveExtraFiles     []*os.File\n\tbinPath, tmpBinPath string\n\tbinPerms            os.FileMode\n\tbinHash             []byte\n\trestartMux          sync.Mutex\n\trestarting          bool\n\trestartedAt         time.Time\n\trestarted           chan bool\n\tawaitingUSR1        bool\n\tdescriptorsReleased chan bool\n\tsignalledAt         time.Time\n\tprintCheckUpdate    bool\n}\n\nfunc (mp *master) run() error {\n\tmp.debugf(\"run\")\n\tif err := mp.checkBinary(); err != nil {\n\t\treturn err\n\t}\n\tif mp.Config.Fetcher != nil {\n\t\tif err := mp.Config.Fetcher.Init(); err != nil {\n\t\t\tmp.warnf(\"fetcher init failed (%s). fetcher disabled.\", err)\n\t\t\tmp.Config.Fetcher = nil\n\t\t}\n\t}\n\tmp.setupSignalling()\n\tif err := mp.retreiveFileDescriptors(); err != nil {\n\t\treturn err\n\t}\n\tif mp.Config.Fetcher != nil {\n\t\tmp.printCheckUpdate = true\n\t\tmp.fetch()\n\t\tgo mp.fetchLoop()\n\t}\n\treturn mp.forkLoop()\n}\n\nfunc (mp *master) checkBinary() error {\n\t//get path to binary and confirm its writable\n\tbinPath, err := os.Executable()\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to find binary path (%s)\", err)\n\t}\n\tmp.binPath = binPath\n\tif info, err := os.Stat(binPath); err != nil {\n\t\treturn fmt.Errorf(\"failed to stat binary (%s)\", err)\n\t} else if info.Size() == 0 {\n\t\treturn fmt.Errorf(\"binary file is empty\")\n\t} else {\n\t\t//copy permissions\n\t\tmp.binPerms = info.Mode()\n\t}\n\tf, err := os.Open(binPath)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"cannot read binary (%s)\", err)\n\t}\n\t//initial hash of file\n\thash := sha1.New()\n\tio.Copy(hash, f)\n\tmp.binHash = hash.Sum(nil)\n\tf.Close()\n\t//test bin<->tmpbin moves\n\tif mp.Config.Fetcher != nil {\n\t\tif err := move(tmpBinPath, mp.binPath); err != nil {\n\t\t\treturn fmt.Errorf(\"cannot move binary (%s)\", err)\n\t\t}\n\t\tif err := move(mp.binPath, tmpBinPath); err != nil {\n\t\t\treturn fmt.Errorf(\"cannot move binary back (%s)\", err)\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc (mp *master) setupSignalling() {\n\t//updater-forker comms\n\tmp.restarted = make(chan bool)\n\tmp.descriptorsReleased = make(chan bool)\n\t//read all master process signals\n\tsignals := make(chan os.Signal)\n\tsignal.Notify(signals)\n\tgo func() {\n\t\tfor s := range signals {\n\t\t\tmp.handleSignal(s)\n\t\t}\n\t}()\n}\n\nfunc (mp *master) handleSignal(s os.Signal) {\n\tif s == mp.RestartSignal {\n\t\t//user initiated manual restart\n\t\tgo mp.triggerRestart()\n\t} else if s.String() == \"child exited\" {\n\t\t// will occur on every restart, ignore it\n\t} else\n\t//**during a restart** a SIGUSR1 signals\n\t//to the master process that, the file\n\t//descriptors have been released\n\tif mp.awaitingUSR1 && s == SIGUSR1 {\n\t\tmp.debugf(\"signaled, sockets ready\")\n\t\tmp.awaitingUSR1 = false\n\t\tmp.descriptorsReleased <- true\n\t} else\n\t//while the slave process is running, proxy\n\t//all signals through\n\tif mp.slaveCmd != nil && mp.slaveCmd.Process != nil {\n\t\tmp.debugf(\"proxy signal (%s)\", s)\n\t\tmp.sendSignal(s)\n\t} else\n\t//otherwise if not running, kill on CTRL+c\n\tif s == os.Interrupt {\n\t\tmp.debugf(\"interupt with no slave\")\n\t\tos.Exit(1)\n\t} else {\n\t\tmp.debugf(\"signal discarded (%s), no slave process\", s)\n\t}\n}\n\nfunc (mp *master) sendSignal(s os.Signal) {\n\tif mp.slaveCmd != nil && mp.slaveCmd.Process != nil {\n\t\tif err := mp.slaveCmd.Process.Signal(s); err != nil {\n\t\t\tmp.debugf(\"signal failed (%s), assuming slave process died unexpectedly\", err)\n\t\t\tos.Exit(1)\n\t\t}\n\t}\n}\n\nfunc (mp *master) retreiveFileDescriptors() error {\n\tmp.slaveExtraFiles = make([]*os.File, len(mp.Config.Addresses))\n\tfor i, addr := range mp.Config.Addresses {\n\t\ta, err := net.ResolveTCPAddr(\"tcp\", addr)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"Invalid address %s (%s)\", addr, err)\n\t\t}\n\t\tl, err := net.ListenTCP(\"tcp\", a)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tf, err := l.File()\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"Failed to retreive fd for: %s (%s)\", addr, err)\n\t\t}\n\t\tif err := l.Close(); err != nil {\n\t\t\treturn fmt.Errorf(\"Failed to close listener for: %s (%s)\", addr, err)\n\t\t}\n\t\tmp.slaveExtraFiles[i] = f\n\t}\n\treturn nil\n}\n\n//fetchLoop is run in a goroutine\nfunc (mp *master) fetchLoop() {\n\tmin := mp.Config.MinFetchInterval\n\ttime.Sleep(min)\n\tfor {\n\t\tt0 := time.Now()\n\t\tmp.fetch()\n\t\t//duration fetch of fetch\n\t\tdiff := time.Now().Sub(t0)\n\t\tif diff < min {\n\t\t\tdelay := min - diff\n\t\t\t//ensures at least MinFetchInterval delay.\n\t\t\t//should be throttled by the fetcher!\n\t\t\ttime.Sleep(delay)\n\t\t}\n\t}\n}\n\nfunc (mp *master) fetch() {\n\tif mp.restarting {\n\t\treturn //skip if restarting\n\t}\n\tif mp.printCheckUpdate {\n\t\tmp.debugf(\"checking for updates...\")\n\t}\n\treader, err := mp.Fetcher.Fetch()\n\tif err != nil {\n\t\tmp.debugf(\"failed to get latest version: %s\", err)\n\t\treturn\n\t}\n\tif reader == nil {\n\t\tif mp.printCheckUpdate {\n\t\t\tmp.debugf(\"no updates\")\n\t\t}\n\t\tmp.printCheckUpdate = false\n\t\treturn //fetcher has explicitly said there are no updates\n\t}\n\tmp.printCheckUpdate = true\n\tmp.debugf(\"streaming update...\")\n\t//optional closer\n\tif closer, ok := reader.(io.Closer); ok {\n\t\tdefer closer.Close()\n\t}\n\ttmpBin, err := os.OpenFile(tmpBinPath, os.O_RDWR|os.O_CREATE|os.O_TRUNC, 0666)\n\tif err != nil {\n\t\tmp.warnf(\"failed to open temp binary: %s\", err)\n\t\treturn\n\t}\n\tdefer func() {\n\t\ttmpBin.Close()\n\t\tos.Remove(tmpBinPath)\n\t}()\n\t//tee off to sha1\n\thash := sha1.New()\n\treader = io.TeeReader(reader, hash)\n\t//write to a temp file\n\t_, err = io.Copy(tmpBin, reader)\n\tif err != nil {\n\t\tmp.warnf(\"failed to write temp binary: %s\", err)\n\t\treturn\n\t}\n\t//compare hash\n\tnewHash := hash.Sum(nil)\n\tif bytes.Equal(mp.binHash, newHash) {\n\t\tmp.debugf(\"hash match - skip\")\n\t\treturn\n\t}\n\t//copy permissions\n\tif err := chmod(tmpBin, mp.binPerms); err != nil {\n\t\tmp.warnf(\"failed to make temp binary executable: %s\", err)\n\t\treturn\n\t}\n\tif err := chown(tmpBin, uid, gid); err != nil {\n\t\tmp.warnf(\"failed to change owner of binary: %s\", err)\n\t\treturn\n\t}\n\tif _, err := tmpBin.Stat(); err != nil {\n\t\tmp.warnf(\"failed to stat temp binary: %s\", err)\n\t\treturn\n\t}\n\ttmpBin.Close()\n\tif _, err := os.Stat(tmpBinPath); err != nil {\n\t\tmp.warnf(\"failed to stat temp binary by path: %s\", err)\n\t\treturn\n\t}\n\tif mp.Config.PreUpgrade != nil {\n\t\tif err := mp.Config.PreUpgrade(tmpBinPath); err != nil {\n\t\t\tmp.warnf(\"user cancelled upgrade: %s\", err)\n\t\t\treturn\n\t\t}\n\t}\n\t//overseer sanity check, dont replace our good binary with a non-executable file\n\ttokenIn := token()\n\tcmd := exec.Command(tmpBinPath)\n\tcmd.Env = append(os.Environ(), []string{envBinCheck + \"=\" + tokenIn}...)\n\tcmd.Args = os.Args\n\treturned := false\n\tgo func() {\n\t\ttime.Sleep(5 * time.Second)\n\t\tif !returned {\n\t\t\tmp.warnf(\"sanity check against fetched executable timed-out, check overseer is running\")\n\t\t\tif cmd.Process != nil {\n\t\t\t\tcmd.Process.Kill()\n\t\t\t}\n\t\t}\n\t}()\n\ttokenOut, err := cmd.CombinedOutput()\n\treturned = true\n\tif err != nil {\n\t\tmp.warnf(\"failed to run temp binary: %s (%s) output \\\"%s\\\"\", err, tmpBinPath, tokenOut)\n\t\treturn\n\t}\n\tif tokenIn != string(tokenOut) {\n\t\tmp.warnf(\"sanity check failed\")\n\t\treturn\n\t}\n\t//overwrite!\n\tif err := overwrite(mp.binPath, tmpBinPath); err != nil {\n\t\tmp.warnf(\"failed to overwrite binary: %s\", err)\n\t\treturn\n\t}\n\tmp.debugf(\"upgraded binary (%x -> %x)\", mp.binHash[:12], newHash[:12])\n\tmp.binHash = newHash\n\t//binary successfully replaced\n\tif !mp.Config.NoRestartAfterFetch {\n\t\tmp.triggerRestart()\n\t}\n\t//and keep fetching...\n\treturn\n}\n\nfunc (mp *master) triggerRestart() {\n\tif mp.restarting {\n\t\tmp.debugf(\"already graceful restarting\")\n\t\treturn //skip\n\t} else if mp.slaveCmd == nil || mp.restarting {\n\t\tmp.debugf(\"no slave process\")\n\t\treturn //skip\n\t}\n\tmp.debugf(\"graceful restart triggered\")\n\tmp.restarting = true\n\tmp.awaitingUSR1 = true\n\tmp.signalledAt = time.Now()\n\tmp.sendSignal(mp.Config.RestartSignal) //ask nicely to terminate\n\tselect {\n\tcase <-mp.restarted:\n\t\t//success\n\t\tmp.debugf(\"restart success\")\n\tcase <-time.After(mp.TerminateTimeout):\n\t\t//times up mr. process, we did ask nicely!\n\t\tmp.debugf(\"graceful timeout, forcing exit\")\n\t\tmp.sendSignal(os.Kill)\n\t}\n}\n\n//not a real fork\nfunc (mp *master) forkLoop() error {\n\t//loop, restart command\n\tfor {\n\t\tif err := mp.fork(); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n}\n\nfunc (mp *master) fork() error {\n\tmp.debugf(\"starting %s\", mp.binPath)\n\tcmd := exec.Command(mp.binPath)\n\t//mark this new process as the \"active\" slave process.\n\t//this process is assumed to be holding the socket files.\n\tmp.slaveCmd = cmd\n\tmp.slaveID++\n\t//provide the slave process with some state\n\te := os.Environ()\n\te = append(e, envBinID+\"=\"+hex.EncodeToString(mp.binHash))\n\te = append(e, envBinPath+\"=\"+mp.binPath)\n\te = append(e, envSlaveID+\"=\"+strconv.Itoa(mp.slaveID))\n\te = append(e, envIsSlave+\"=1\")\n\te = append(e, envNumFDs+\"=\"+strconv.Itoa(len(mp.slaveExtraFiles)))\n\tcmd.Env = e\n\t//inherit master args/stdfiles\n\tcmd.Args = os.Args\n\tcmd.Stdin = os.Stdin\n\tcmd.Stdout = os.Stdout\n\tcmd.Stderr = os.Stderr\n\t//include socket files\n\tcmd.ExtraFiles = mp.slaveExtraFiles\n\tif err := cmd.Start(); err != nil {\n\t\treturn fmt.Errorf(\"Failed to start slave process: %s\", err)\n\t}\n\t//was scheduled to restart, notify success\n\tif mp.restarting {\n\t\tmp.restartedAt = time.Now()\n\t\tmp.restarting = false\n\t\tmp.restarted <- true\n\t}\n\t//convert wait into channel\n\tcmdwait := make(chan error)\n\tgo func() {\n\t\tcmdwait <- cmd.Wait()\n\t}()\n\t//wait....\n\tselect {\n\tcase err := <-cmdwait:\n\t\t//program exited before releasing descriptors\n\t\t//proxy exit code out to master\n\t\tcode := 0\n\t\tif err != nil {\n\t\t\tcode = 1\n\t\t\tif exiterr, ok := err.(*exec.ExitError); ok {\n\t\t\t\tif status, ok := exiterr.Sys().(syscall.WaitStatus); ok {\n\t\t\t\t\tcode = status.ExitStatus()\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tmp.debugf(\"prog exited with %d\", code)\n\t\t//if a restarts are disabled or if it was an\n\t\t//unexpected crash, proxy this exit straight\n\t\t//through to the main process\n\t\tif mp.NoRestart || !mp.restarting {\n\t\t\tos.Exit(code)\n\t\t}\n\tcase <-mp.descriptorsReleased:\n\t\t//if descriptors are released, the program\n\t\t//has yielded control of its sockets and\n\t\t//a parallel instance of the program can be\n\t\t//started safely. it should serve state.Listeners\n\t\t//to ensure downtime is kept at <1sec. The previous\n\t\t//cmd.Wait() will still be consumed though the\n\t\t//result will be discarded.\n\t}\n\treturn nil\n}\n\nfunc (mp *master) debugf(f string, args ...interface{}) {\n\tif mp.Config.Debug {\n\t\tlog.Printf(\"[overseer master] \"+f, args...)\n\t}\n}\n\nfunc (mp *master) warnf(f string, args ...interface{}) {\n\tif mp.Config.Debug || !mp.Config.NoWarn {\n\t\tlog.Printf(\"[overseer master] \"+f, args...)\n\t}\n}\n\nfunc token() string {\n\tbuff := make([]byte, 8)\n\trand.Read(buff)\n\treturn hex.EncodeToString(buff)\n}\n\n// On Windows, include the .exe extension, noop otherwise.\nfunc extension() string {\n\tif runtime.GOOS == \"windows\" {\n\t\treturn \".exe\"\n\t}\n\n\treturn \"\"\n}\n"
        },
        {
          "name": "proc_slave.go",
          "type": "blob",
          "size": 3.8427734375,
          "content": "package overseer\n\nimport (\n\t\"fmt\"\n\t\"log\"\n\t\"net\"\n\t\"os\"\n\t\"os/signal\"\n\t\"strconv\"\n\t\"time\"\n)\n\nvar (\n\t//DisabledState is a placeholder state for when\n\t//overseer is disabled and the program function\n\t//is run manually.\n\tDisabledState = State{Enabled: false}\n)\n\n// State contains the current run-time state of overseer\ntype State struct {\n\t//whether overseer is running enabled. When enabled,\n\t//this program will be running in a child process and\n\t//overseer will perform rolling upgrades.\n\tEnabled bool\n\t//ID is a SHA-1 hash of the current running binary\n\tID string\n\t//StartedAt records the start time of the program\n\tStartedAt time.Time\n\t//Listener is the first net.Listener in Listeners\n\tListener net.Listener\n\t//Listeners are the set of acquired sockets by the master\n\t//process. These are all passed into this program in the\n\t//same order they are specified in Config.Addresses.\n\tListeners []net.Listener\n\t//Program's first listening address\n\tAddress string\n\t//Program's listening addresses\n\tAddresses []string\n\t//GracefulShutdown will be filled when its time to perform\n\t//a graceful shutdown.\n\tGracefulShutdown chan bool\n\t//Path of the binary currently being executed\n\tBinPath string\n}\n\n//a overseer slave process\n\ntype slave struct {\n\t*Config\n\tid         string\n\tlisteners  []*overseerListener\n\tmasterPid  int\n\tmasterProc *os.Process\n\tstate      State\n}\n\nfunc (sp *slave) run() error {\n\tsp.id = os.Getenv(envSlaveID)\n\tsp.debugf(\"run\")\n\tsp.state.Enabled = true\n\tsp.state.ID = os.Getenv(envBinID)\n\tsp.state.StartedAt = time.Now()\n\tsp.state.Address = sp.Config.Address\n\tsp.state.Addresses = sp.Config.Addresses\n\tsp.state.GracefulShutdown = make(chan bool, 1)\n\tsp.state.BinPath = os.Getenv(envBinPath)\n\tif err := sp.watchParent(); err != nil {\n\t\treturn err\n\t}\n\tif err := sp.initFileDescriptors(); err != nil {\n\t\treturn err\n\t}\n\tsp.watchSignal()\n\t//run program with state\n\tsp.debugf(\"start program\")\n\tsp.Config.Program(sp.state)\n\treturn nil\n}\n\nfunc (sp *slave) initFileDescriptors() error {\n\t//inspect file descriptors\n\tnumFDs, err := strconv.Atoi(os.Getenv(envNumFDs))\n\tif err != nil {\n\t\treturn fmt.Errorf(\"invalid %s integer\", envNumFDs)\n\t}\n\tsp.listeners = make([]*overseerListener, numFDs)\n\tsp.state.Listeners = make([]net.Listener, numFDs)\n\tfor i := 0; i < numFDs; i++ {\n\t\tf := os.NewFile(uintptr(3+i), \"\")\n\t\tl, err := net.FileListener(f)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"failed to inherit file descriptor: %d\", i)\n\t\t}\n\t\tu := newOverseerListener(l)\n\t\tsp.listeners[i] = u\n\t\tsp.state.Listeners[i] = u\n\t}\n\tif len(sp.state.Listeners) > 0 {\n\t\tsp.state.Listener = sp.state.Listeners[0]\n\t}\n\treturn nil\n}\n\nfunc (sp *slave) watchSignal() {\n\tsignals := make(chan os.Signal)\n\tsignal.Notify(signals, sp.Config.RestartSignal)\n\tgo func() {\n\t\t<-signals\n\t\tsignal.Stop(signals)\n\t\tsp.debugf(\"graceful shutdown requested\")\n\t\t//master wants to restart,\n\t\tclose(sp.state.GracefulShutdown)\n\t\t//release any sockets and notify master\n\t\tif len(sp.listeners) > 0 {\n\t\t\t//perform graceful shutdown\n\t\t\tfor _, l := range sp.listeners {\n\t\t\t\tl.release(sp.Config.TerminateTimeout)\n\t\t\t}\n\t\t\t//signal release of held sockets, allows master to start\n\t\t\t//a new process before this child has actually exited.\n\t\t\t//early restarts not supported with restarts disabled.\n\t\t\tif !sp.NoRestart {\n\t\t\t\tsp.masterProc.Signal(SIGUSR1)\n\t\t\t}\n\t\t\t//listeners should be waiting on connections to close...\n\t\t}\n\t\t//start death-timer\n\t\tgo func() {\n\t\t\ttime.Sleep(sp.Config.TerminateTimeout)\n\t\t\tsp.debugf(\"timeout. forceful shutdown\")\n\t\t\tos.Exit(1)\n\t\t}()\n\t}()\n}\n\nfunc (sp *slave) triggerRestart() {\n\tif err := sp.masterProc.Signal(sp.Config.RestartSignal); err != nil {\n\t\tos.Exit(1)\n\t}\n}\n\nfunc (sp *slave) debugf(f string, args ...interface{}) {\n\tif sp.Config.Debug {\n\t\tlog.Printf(\"[overseer slave#\"+sp.id+\"] \"+f, args...)\n\t}\n}\n\nfunc (sp *slave) warnf(f string, args ...interface{}) {\n\tif sp.Config.Debug || !sp.Config.NoWarn {\n\t\tlog.Printf(\"[overseer slave#\"+sp.id+\"] \"+f, args...)\n\t}\n}\n"
        },
        {
          "name": "proc_slave_others.go",
          "type": "blob",
          "size": 0.59375,
          "content": "// +build !windows\n\npackage overseer\n\nimport (\n\t\"fmt\"\n\t\"os\"\n\t\"syscall\"\n\t\"time\"\n)\n\nfunc (sp *slave) watchParent() error {\n\tsp.masterPid = os.Getppid()\n\tproc, err := os.FindProcess(sp.masterPid)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"master process: %s\", err)\n\t}\n\tsp.masterProc = proc\n\tgo func() {\n\t\t//send signal 0 to master process forever\n\t\tfor {\n\t\t\t//should not error as long as the process is alive\n\t\t\tif err := sp.masterProc.Signal(syscall.Signal(0)); err != nil {\n\t\t\t\tos.Exit(1)\n\t\t\t}\n\t\t\ttime.Sleep(2 * time.Second)\n\t\t}\n\t}()\n\treturn nil\n}\n\nfunc overwrite(dst, src string) error {\n\treturn move(dst, src)\n}\n"
        },
        {
          "name": "proc_slave_windows.go",
          "type": "blob",
          "size": 3.0205078125,
          "content": "// +build windows\n\npackage overseer\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"os\"\n\t\"strings\"\n\t\"time\"\n\n\t\"github.com/StackExchange/wmi\"\n)\n\nvar (\n\tTimeout = 3 * time.Second\n)\n\ntype Win32_Process struct {\n\tName                  string\n\tExecutablePath        *string\n\tCommandLine           *string\n\tPriority              uint32\n\tCreationDate          *time.Time\n\tProcessID             uint32\n\tThreadCount           uint32\n\tStatus                *string\n\tReadOperationCount    uint64\n\tReadTransferCount     uint64\n\tWriteOperationCount   uint64\n\tWriteTransferCount    uint64\n\tCSCreationClassName   string\n\tCSName                string\n\tCaption               *string\n\tCreationClassName     string\n\tDescription           *string\n\tExecutionState        *uint16\n\tHandleCount           uint32\n\tKernelModeTime        uint64\n\tMaximumWorkingSetSize *uint32\n\tMinimumWorkingSetSize *uint32\n\tOSCreationClassName   string\n\tOSName                string\n\tOtherOperationCount   uint64\n\tOtherTransferCount    uint64\n\tPageFaults            uint32\n\tPageFileUsage         uint32\n\tParentProcessID       uint32\n\tPeakPageFileUsage     uint32\n\tPeakVirtualSize       uint64\n\tPeakWorkingSetSize    uint32\n\tPrivatePageCount      uint64\n\tTerminationDate       *time.Time\n\tUserModeTime          uint64\n\tWorkingSetSize        uint64\n}\n\nfunc (sp *slave) watchParent() error {\n\tsp.masterPid = os.Getppid()\n\tproc, err := os.FindProcess(sp.masterPid)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"master process: %s\", err)\n\t}\n\tsp.masterProc = proc\n\tgo func() {\n\t\t//send signal 0 to master process forever\n\t\tfor {\n\t\t\t//should not error as long as the process is alive\n\t\t\tif _, err := GetWin32Proc(int32(sp.masterPid)); err != nil {\n\t\t\t\tos.Exit(1)\n\t\t\t}\n\t\t\ttime.Sleep(2 * time.Second)\n\t\t}\n\t}()\n\treturn nil\n}\n\nfunc GetWin32Proc(pid int32) ([]Win32_Process, error) {\n\treturn GetWin32ProcWithContext(context.Background(), pid)\n}\n\nfunc GetWin32ProcWithContext(ctx context.Context, pid int32) ([]Win32_Process, error) {\n\tvar dst []Win32_Process\n\tquery := fmt.Sprintf(\"WHERE ProcessId = %d\", pid)\n\tq := wmi.CreateQuery(&dst, query)\n\terr := WMIQueryWithContext(ctx, q, &dst)\n\tif err != nil {\n\t\treturn []Win32_Process{}, fmt.Errorf(\"could not get win32Proc: %s\", err)\n\t}\n\n\tif len(dst) == 0 {\n\t\treturn []Win32_Process{}, fmt.Errorf(\"could not get win32Proc: empty\")\n\t}\n\n\treturn dst, nil\n}\n\nfunc WMIQueryWithContext(ctx context.Context, query string, dst interface{}, connectServerArgs ...interface{}) error {\n\tif _, ok := ctx.Deadline(); !ok {\n\t\tctxTimeout, cancel := context.WithTimeout(ctx, Timeout)\n\t\tdefer cancel()\n\t\tctx = ctxTimeout\n\t}\n\n\terrChan := make(chan error, 1)\n\tgo func() {\n\t\terrChan <- wmi.Query(query, dst, connectServerArgs...)\n\t}()\n\n\tselect {\n\tcase <-ctx.Done():\n\t\treturn ctx.Err()\n\tcase err := <-errChan:\n\t\treturn err\n\t}\n}\n\n// overwrite: see https://github.com/jpillora/overseer/issues/56#issuecomment-656405955\nfunc overwrite(dst, src string) error {\n\told := strings.TrimSuffix(dst, \".exe\") + \"-old.exe\"\n\tif err := move(old, dst); err != nil {\n\t\treturn err\n\t}\n\tif err := move(dst, src); err != nil {\n\t\treturn err\n\t}\n\tos.Remove(old)\n\treturn nil\n}\n"
        },
        {
          "name": "sys_posix.go",
          "type": "blob",
          "size": 0.95703125,
          "content": "// +build linux darwin freebsd\n\npackage overseer\n\n//this file attempts to contain all posix\n//specific stuff, that needs to be implemented\n//in some other way on other OSs... TODO!\n\nimport (\n\t\"os\"\n\t\"os/exec\"\n\t\"syscall\"\n)\n\nvar (\n\tsupported = true\n\tuid       = syscall.Getuid()\n\tgid       = syscall.Getgid()\n\tSIGUSR1   = syscall.SIGUSR1\n\tSIGUSR2   = syscall.SIGUSR2\n\tSIGTERM   = syscall.SIGTERM\n)\n\nfunc move(dst, src string) error {\n\tif err := os.Rename(src, dst); err == nil {\n\t\treturn nil\n\t}\n\t//HACK: we're shelling out to mv because linux\n\t//throws errors when crossing device boundaries.\n\t//TODO see sys_posix_mv.go\n\tif err := exec.Command(\"mv\", src, dst).Run(); err != nil {\n\t\treturn err\n\t}\n\n\t// Run sync to 'commit' the mv by clearing caches\n\treturn syncCmd().Run()\n}\n\nfunc syncCmd() *exec.Cmd {\n\treturn exec.Command(\"sync\")\n}\n\nfunc chmod(f *os.File, perms os.FileMode) error {\n\treturn f.Chmod(perms)\n}\nfunc chown(f *os.File, uid, gid int) error {\n\treturn f.Chown(uid, gid)\n}\n"
        },
        {
          "name": "sys_posix_mv.go",
          "type": "blob",
          "size": 6.1103515625,
          "content": "package overseer\n\n// TODO(@jpillora) borrowed from https://github.com/aisola/go-coreutils/blob/master/mv/mv.go\n//\n// mv.go (go-coreutils) 0.1\n// Copyright (C) 2014, The GO-Coreutils Developers.\n//\n// Written By: Abram C. Isola, Michael Murphy\n//\n// package main\n//\n// import \"bufio\"\n// import \"flag\"\n// import \"fmt\"\n// import \"io\"\n// import \"os\"\n// import \"path/filepath\"\n//\n// const (\n// \thelp_text string = `\n//     Usage: mv [OPTION]... [PATH]... [PATH]\n//        or: mv [PATH] [PATH]\n//        or: mv [OPTION]\n//     move or rename files or directories\n//         --help        display this help and exit\n//         --version     output version information and exit\n//         -f, --force   remove existing destination files and never prompt the user\n//     ` // -v, --verbose print the name of each file before moving it\n// \tversion_text = `\n//     mv (go-coreutils) 0.1\n//     Copyright (C) 2014, The GO-Coreutils Developers.\n//     This program comes with ABSOLUTELY NO WARRANTY; for details see\n//     LICENSE. This is free software, and you are welcome to redistribute\n//     it under certain conditions in LICENSE.\n// `\n// )\n//\n// var (\n// \tforceEnabled     = flag.Bool(\"f\", false, \"remove existing destination files and never prompt the user\")\n// \tforceEnabledLong = flag.Bool(\"force\", false, \"remove existing destination files and never prompt the user\")\n// )\n//\n// // The input function prints a statement to the user and accepts an input, then returns the input.\n//\n// func input(prompt, location string) string {\n// \tfmt.Printf(prompt, location)\n//\n// \treader := bufio.NewReader(os.Stdin)\n// \tuserinput, _ := reader.ReadString([]byte(\"\\n\")[0])\n//\n// \treturn userinput\n// }\n//\n// // The fileExists function will check if the file exists.\n//\n// func fileExists(filep string) os.FileInfo {\n// \tfp, err := os.Stat(filep)\n// \tif err != nil && os.IsNotExist(err) {\n// \t\treturn nil\n// \t}\n// \treturn fp\n// }\n//\n// /* The argumentCheck function will check the number of arguments given to the program and process them\n//  * accordingly. */\n//\n// func argumentCheck(files []string) {\n// \tswitch len(files) {\n// \tcase 0: // If there is no argument\n// \t\tfmt.Println(\"mv: missing file operand\\nTry 'mv -help' for more information\")\n// \t\tos.Exit(0)\n// \tcase 1: // If there is one argument\n// \t\tfmt.Printf(\"mv: missing destination file operand after '%s'\\nTry 'mv -help' for more information.\\n\", files[0])\n// \t\tos.Exit(0)\n// \tcase 2: // If there are two arguments\n// \t\tmover(files[0], files[1])\n// \tdefault: // If there are more than two arguments\n// \t\tto_file, files := files[len(files)-1], files[:len(files)-1]\n//\n// \t\tif fp := fileExists(to_file); fp == nil || !fp.IsDir() {\n// \t\t\tfmt.Println(\"mv: when moving multiple files, last argument must be a directory\")\n// \t\t\tos.Exit(0)\n// \t\t} else {\n// \t\t\tfmt.Println(files)\n// \t\t\tfor i := 0; i < len(files); i++ {\n// \t\t\t\tmover(files[i], to_file)\n// \t\t\t}\n// \t\t\tos.Exit(0)\n// \t\t}\n// \t}\n// }\n//\n// /* The mover function will take two strings as an argument and move the original file/dir to\n//  * a new location. */\n//\n// func mover(originalLocation, newLocation string) {\n// \tfp := fileExists(newLocation)\n//\n// \tswitch {\n// \tcase fileExists(originalLocation) == nil: // If the original file does not exist\n// \t\tfmt.Printf(\"mv: cannot stat '%s': No such file or directory\\n\", originalLocation)\n// \t\tos.Exit(0)\n// \tcase fp != nil && !*forceEnabled: // If the destination file does not exist and forceEnabled is disabled\n// \t\tif fp.IsDir() {\n// \t\t\tbase := filepath.Base(originalLocation)\n// \t\t\tif fp2 := fileExists(newLocation + \"/\" + base); fp2 != nil && !*forceEnabled {\n// \t\t\t\tanswer := input(\"File '%s' exists. Overwrite? (y/N): \", newLocation+\"/\"+base)\n// \t\t\t\tif answer == \"y\\n\" {\n// \t\t\t\t\ttry_move(originalLocation, newLocation+\"/\"+base)\n// \t\t\t\t} else {\n// \t\t\t\t\tos.Exit(0)\n// \t\t\t\t}\n// \t\t\t} else if fp2 != nil && *forceEnabled {\n// \t\t\t\ttry_move(originalLocation, newLocation+\"/\"+base)\n// \t\t\t} else if fp2 == nil {\n// \t\t\t\ttry_move(originalLocation, newLocation+\"/\"+base)\n// \t\t\t}\n// \t\t} else {\n// \t\t\tanswer := input(\"File '%s' exists. Overwrite? (y/N): \", newLocation)\n// \t\t\tif answer == \"y\\n\" {\n// \t\t\t\ttry_move(originalLocation, newLocation)\n// \t\t\t} else {\n// \t\t\t\tos.Exit(0)\n// \t\t\t}\n// \t\t}\n// \tdefault: // If the destination file exists and forceEnabled is enabled,\n// \t\ttry_move(originalLocation, newLocation) // or if the file does not exist, move it.\n// \t}\n// }\n//\n// func try_move(originalLocation, newLocation string) error {\n// \terr := os.Rename(originalLocation, newLocation)\n// \tswitch t := err.(type) {\n// \tcase *os.LinkError:\n// \t\tfmt.Printf(\"Cross-device move. Copying instead\\n\")\n// \t\treturn move_across_devices(originalLocation, newLocation)\n// \tcase *os.PathError:\n// \t\tfmt.Printf(\"Path error: %q\\n\", t)\n// \t\treturn err\n// \tcase *os.SyscallError:\n// \t\tfmt.Printf(\"Syscall error: %q\\n\", t)\n// \t\treturn err\n// \tcase nil:\n// \t\treturn nil\n// \tdefault:\n// \t\tfmt.Printf(\"Unkown error Type: %T Error: %q\", t, t)\n// \t\treturn err\n// \t}\n// \treturn nil\n// }\n//\n// func move_across_devices(originalLocation, newLocation string) error {\n// \tsrc, err := os.Open(originalLocation)\n// \tif err != nil {\n// \t\treturn err\n// \t}\n// \tdefer src.Close()\n//\n// \tdst, err := os.Create(newLocation)\n// \tif err != nil {\n// \t\treturn err\n// \t}\n// \tdefer dst.Close()\n//\n// \tsize, err := io.Copy(dst, src)\n// \tif err != nil {\n// \t\treturn err\n// \t}\n//\n// \tsrcStat, err := os.Stat(originalLocation)\n// \tif err != nil {\n// \t\treturn err\n// \t}\n// \tif size != srcStat.Size() {\n// \t\tos.Remove(newLocation)\n// \t\treturn fmt.Errorf(\"Error, file was not copied completely\")\n// \t}\n// \tos.Remove(originalLocation)\n// \treturn nil\n// }\n//\n// func main() {\n// \thelp := flag.Bool(\"help\", false, help_text)\n// \tversion := flag.Bool(\"version\", false, version_text)\n// \tflag.Parse()\n//\n// \t// We only need one instance of forceEnabled\n//\n// \tif *forceEnabledLong {\n// \t\t*forceEnabled = true\n// \t}\n//\n// \t// Display help information\n//\n// \tif *help {\n// \t\tfmt.Println(help_text)\n// \t\tos.Exit(0)\n// \t}\n//\n// \t// Display version information\n//\n// \tif *version {\n// \t\tfmt.Println(version_text)\n// \t\tos.Exit(0)\n// \t}\n//\n// \tfiles := flag.Args() // Obtain a list of files.\n// \targumentCheck(files) // Check the number of arguments and process them.\n// }\n"
        },
        {
          "name": "sys_unsupported.go",
          "type": "blob",
          "size": 0.4560546875,
          "content": "// +build !linux,!darwin,!windows,!freebsd\n\npackage overseer\n\nimport (\n\t\"errors\"\n\t\"os\"\n)\n\nvar (\n\tsupported = false\n\tuid       = 0\n\tgid       = 0\n\tSIGUSR1   = os.Interrupt\n\tSIGUSR2   = os.Interrupt\n\tSIGTERM   = os.Kill\n)\n\nfunc move(dst, src string) error {\n\treturn errors.New(\"Not supported\")\n}\n\nfunc chmod(f *os.File, perms os.FileMode) error {\n\treturn errors.New(\"Not supported\")\n}\n\nfunc chown(f *os.File, uid, gid int) error {\n\treturn errors.New(\"Not supported\")\n}\n"
        },
        {
          "name": "sys_windows.go",
          "type": "blob",
          "size": 1.64453125,
          "content": "// +build windows\n\npackage overseer\n\nimport (\n\t\"bytes\"\n\t\"fmt\"\n\t\"os\"\n\t\"os/exec\"\n\t\"path/filepath\"\n\t\"strings\"\n\t\"syscall\"\n)\n\nvar (\n\tsupported = true\n\tuid       = syscall.Getuid()\n\tgid       = syscall.Getgid()\n\tSIGUSR1   = syscall.SIGTERM\n\tSIGUSR2   = syscall.SIGTERM\n\tSIGTERM   = syscall.SIGTERM\n)\n\nfunc move(dst, src string) error {\n\tos.MkdirAll(filepath.Dir(dst), 0755)\n\tif err := os.Rename(src, dst); err == nil {\n\t\treturn nil\n\t}\n\t//HACK: we're shelling out to move because windows\n\t//throws errors when crossing device boundaries.\n\t// https://www.microsoft.com/resources/documentation/windows/xp/all/proddocs/en-us/move.mspx?mfr=true\n\n\t// https://blogs.msdn.microsoft.com/twistylittlepassagesallalike/2011/04/23/everyone-quotes-command-line-arguments-the-wrong-way/\n\tR := func(s string) string { return replShellMeta.Replace(syscall.EscapeArg(s)) }\n\tcmd := exec.Command(\"cmd\", \"/c\", `move /y `+R(src)+` `+R(dst))\n\tif b, err := cmd.CombinedOutput(); err != nil {\n\t\treturn fmt.Errorf(\"%v: %q: %v\", cmd.Args, bytes.TrimSpace(b), err)\n\t}\n\treturn nil\n}\n\nfunc chmod(f *os.File, perms os.FileMode) error {\n\tif err := f.Chmod(perms); err != nil && !strings.Contains(err.Error(), \"not supported\") {\n\t\treturn err\n\t}\n\treturn nil\n}\n\nfunc chown(f *os.File, uid, gid int) error {\n\tif err := f.Chown(uid, gid); err != nil && !strings.Contains(err.Error(), \"not supported\") {\n\t\treturn err\n\t}\n\treturn nil\n}\n\n// https://blogs.msdn.microsoft.com/twistylittlepassagesallalike/2011/04/23/everyone-quotes-command-line-arguments-the-wrong-way/\nvar replShellMeta = strings.NewReplacer(\n\t`(`, `^(`,\n\t`)`, `^)`,\n\t`%`, `^%`,\n\t`!`, `^!`,\n\t`^`, `^^`,\n\t`\"`, `^\"`,\n\t`<`, `^<`,\n\t`>`, `^>`,\n\t`&`, `^&`,\n\t`|`, `^|`,\n)\n"
        }
      ]
    }
  ]
}