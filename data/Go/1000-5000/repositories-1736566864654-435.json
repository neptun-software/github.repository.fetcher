{
  "metadata": {
    "timestamp": 1736566864654,
    "page": 435,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjQ0MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "koding/kite",
      "stars": 3267,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.0419921875,
          "content": "kontrol-data.*\n_etcd\nkitectl/kitectl\n.env\n\n"
        },
        {
          "name": ".travis.yml",
          "type": "blob",
          "size": 0.75390625,
          "content": "language: go\nsudo: false\ngo:\n  - 1.9.1\ninstall:\n  - go get -u -v github.com/golang/dep/cmd/dep\n  - $GOPATH/bin/dep ensure -vendor-only -v\nscript:\n  - export GOMAXPROCS=$(nproc)\n  - make test\naddons:\n  postgresql: \"9.3\"\nbefore_script:\n  - psql postgres -f kontrol/001-schema.sql -U postgres\n  - psql -c 'CREATE DATABASE kontrol owner kontrol;' -U postgres\n  - psql kontrol -f kontrol/002-table.sql -U postgres\nenv:\n  - KITE_TRANSPORT=\"XHRPolling\" KONTROL_STORAGE=postgres KONTROL_POSTGRES_USERNAME=kontrolapplication KONTROL_POSTGRES_DBNAME=kontrol KONTROL_POSTGRES_PASSWORD=somerandompassword\n  - KITE_TRANSPORT=\"WebSocket\"  KONTROL_STORAGE=postgres KONTROL_POSTGRES_USERNAME=kontrolapplication KONTROL_POSTGRES_DBNAME=kontrol KONTROL_POSTGRES_PASSWORD=somerandompassword\n"
        },
        {
          "name": "Gopkg.lock",
          "type": "blob",
          "size": 5.697265625,
          "content": "# This file is autogenerated, do not edit; changes may be undone by the next 'dep ensure'.\n\n\n[[projects]]\n  name = \"github.com/BurntSushi/toml\"\n  packages = [\".\"]\n  revision = \"b26d9c308763d68093482582cea63d69be07a0f0\"\n  version = \"v0.3.0\"\n\n[[projects]]\n  branch = \"master\"\n  name = \"github.com/armon/go-radix\"\n  packages = [\".\"]\n  revision = \"1fca145dffbcaa8fe914309b1ec0cfc67500fe61\"\n\n[[projects]]\n  name = \"github.com/bgentry/speakeasy\"\n  packages = [\".\"]\n  revision = \"4aabc24848ce5fd31929f7d1e4ea74d3709c14cd\"\n  version = \"v0.1.0\"\n\n[[projects]]\n  name = \"github.com/cenkalti/backoff\"\n  packages = [\".\"]\n  revision = \"61153c768f31ee5f130071d08fc82b85208528de\"\n  version = \"v1.1.0\"\n\n[[projects]]\n  name = \"github.com/coreos/etcd\"\n  packages = [\"client\",\"pkg/pathutil\",\"pkg/srv\",\"pkg/types\",\"version\"]\n  revision = \"33245c6b5b49130ca99280408fadfab01aac0e48\"\n  version = \"v3.3.8\"\n\n[[projects]]\n  name = \"github.com/coreos/go-semver\"\n  packages = [\"semver\"]\n  revision = \"8ab6407b697782a06568d4b7f1db25550ec2e4c6\"\n  version = \"v0.2.0\"\n\n[[projects]]\n  name = \"github.com/dgrijalva/jwt-go\"\n  packages = [\".\"]\n  revision = \"06ea1031745cb8b3dab3f6a236daf2b0aa468b7e\"\n  version = \"v3.2.0\"\n\n[[projects]]\n  branch = \"master\"\n  name = \"github.com/fatih/camelcase\"\n  packages = [\".\"]\n  revision = \"44e46d280b43ec1531bb25252440e34f1b800b65\"\n\n[[projects]]\n  name = \"github.com/fatih/color\"\n  packages = [\".\"]\n  revision = \"5b77d2a35fb0ede96d138fc9a99f5c9b6aef11b4\"\n  version = \"v1.7.0\"\n\n[[projects]]\n  name = \"github.com/fatih/structs\"\n  packages = [\".\"]\n  revision = \"a720dfa8df582c51dee1b36feabb906bde1588bd\"\n  version = \"v1.0\"\n\n[[projects]]\n  name = \"github.com/gorilla/context\"\n  packages = [\".\"]\n  revision = \"08b5f424b9271eedf6f9f0ce86cb9396ed337a42\"\n  version = \"v1.1.1\"\n\n[[projects]]\n  name = \"github.com/gorilla/mux\"\n  packages = [\".\"]\n  revision = \"e3702bed27f0d39777b0b37b664b6280e8ef8fbf\"\n  version = \"v1.6.2\"\n\n[[projects]]\n  name = \"github.com/gorilla/websocket\"\n  packages = [\".\"]\n  revision = \"ea4d1f681babbce9545c9c5f3d5194a789c89f5b\"\n  version = \"v1.2.0\"\n\n[[projects]]\n  branch = \"master\"\n  name = \"github.com/hashicorp/errwrap\"\n  packages = [\".\"]\n  revision = \"7554cd9344cec97297fa6649b055a8c98c2a1e55\"\n\n[[projects]]\n  branch = \"master\"\n  name = \"github.com/hashicorp/go-multierror\"\n  packages = [\".\"]\n  revision = \"b7773ae218740a7be65057fc60b366a49b538a44\"\n\n[[projects]]\n  branch = \"master\"\n  name = \"github.com/hashicorp/go-version\"\n  packages = [\".\"]\n  revision = \"23480c0665776210b5fbbac6eaaee40e3e6a96b7\"\n\n[[projects]]\n  name = \"github.com/igm/sockjs-go\"\n  packages = [\"sockjs\"]\n  revision = \"c8a8c6429d10e3b6865960ad8cb43779b8a834ef\"\n\n[[projects]]\n  name = \"github.com/juju/ratelimit\"\n  packages = [\".\"]\n  revision = \"59fac5042749a5afb9af70e813da1dd5474f0167\"\n  version = \"1.0.1\"\n\n[[projects]]\n  branch = \"master\"\n  name = \"github.com/koding/cache\"\n  packages = [\".\"]\n  revision = \"e8a81b0b3f20f895153311abde1062894b5912d6\"\n\n[[projects]]\n  branch = \"master\"\n  name = \"github.com/koding/logging\"\n  packages = [\".\"]\n  revision = \"8b5a689ed69b1c7cd1e3595276fc2a352d7818e0\"\n\n[[projects]]\n  branch = \"master\"\n  name = \"github.com/koding/multiconfig\"\n  packages = [\".\"]\n  revision = \"69c27309b2d751c576b59ea9c3726597c2375da3\"\n\n[[projects]]\n  branch = \"master\"\n  name = \"github.com/koding/websocketproxy\"\n  packages = [\".\"]\n  revision = \"944ae4ae170f3afa1e0683bcc3230d34c21e70eb\"\n\n[[projects]]\n  branch = \"master\"\n  name = \"github.com/lann/builder\"\n  packages = [\".\"]\n  revision = \"1b87b36280d04fe7882d1512bf038ea2967ad534\"\n\n[[projects]]\n  branch = \"master\"\n  name = \"github.com/lann/ps\"\n  packages = [\".\"]\n  revision = \"62de8c46ede02a7675c4c79c84883eb164cb71e3\"\n\n[[projects]]\n  name = \"github.com/lann/squirrel\"\n  packages = [\".\"]\n  revision = \"a6b93000bd219143c56c16e6cb1c4b91da3f224b\"\n  version = \"v1.0\"\n\n[[projects]]\n  branch = \"master\"\n  name = \"github.com/lib/pq\"\n  packages = [\".\",\"oid\"]\n  revision = \"90697d60dd844d5ef6ff15135d0203f65d2f53b8\"\n\n[[projects]]\n  name = \"github.com/mattn/go-colorable\"\n  packages = [\".\"]\n  revision = \"167de6bfdfba052fa6b2d3664c8f5272e23c9072\"\n  version = \"v0.0.9\"\n\n[[projects]]\n  name = \"github.com/mattn/go-isatty\"\n  packages = [\".\"]\n  revision = \"0360b2af4f38e8d38c7fce2a9f4e702702d73a39\"\n  version = \"v0.0.3\"\n\n[[projects]]\n  branch = \"master\"\n  name = \"github.com/mitchellh/cli\"\n  packages = [\".\"]\n  revision = \"c48282d14eba4b0817ddef3f832ff8d13851aefd\"\n\n[[projects]]\n  name = \"github.com/posener/complete\"\n  packages = [\".\",\"cmd\",\"cmd/install\",\"match\"]\n  revision = \"98eb9847f27ba2008d380a32c98be474dea55bdf\"\n  version = \"v1.1.1\"\n\n[[projects]]\n  branch = \"master\"\n  name = \"github.com/satori/go.uuid\"\n  packages = [\".\"]\n  revision = \"36e9d2ebbde5e3f13ab2e25625fd453271d6522e\"\n\n[[projects]]\n  name = \"github.com/ugorji/go\"\n  packages = [\"codec\"]\n  revision = \"b4c50a2b199d93b13dc15e78929cfb23bfdf21ab\"\n  version = \"v1.1.1\"\n\n[[projects]]\n  branch = \"master\"\n  name = \"golang.org/x/crypto\"\n  packages = [\"ssh/terminal\"]\n  revision = \"027cca12c2d63e3d62b670d901e8a2c95854feec\"\n\n[[projects]]\n  branch = \"master\"\n  name = \"golang.org/x/net\"\n  packages = [\"context\"]\n  revision = \"db08ff08e8622530d9ed3a0e8ac279f6d4c02196\"\n\n[[projects]]\n  branch = \"master\"\n  name = \"golang.org/x/sys\"\n  packages = [\"unix\",\"windows\"]\n  revision = \"6c888cc515d3ed83fc103cf1d84468aad274b0a7\"\n\n[[projects]]\n  branch = \"v2\"\n  name = \"gopkg.in/mgo.v2\"\n  packages = [\".\",\"bson\",\"internal/json\",\"internal/sasl\",\"internal/scram\"]\n  revision = \"3f83fa5005286a7fe593b055f0d7771a7dce4655\"\n\n[[projects]]\n  name = \"gopkg.in/yaml.v2\"\n  packages = [\".\"]\n  revision = \"5420a8b6744d3b0345ab293f6fcba19c978f1183\"\n  version = \"v2.2.1\"\n\n[solve-meta]\n  analyzer-name = \"dep\"\n  analyzer-version = 1\n  inputs-digest = \"c20f9cb7fa5f208c2f79bc997d789636f027f044dfe9f724582763673f7070b4\"\n  solver-name = \"gps-cdcl\"\n  solver-version = 1\n"
        },
        {
          "name": "Gopkg.toml",
          "type": "blob",
          "size": 1.8408203125,
          "content": "# Gopkg.toml example\n#\n# Refer to https://github.com/golang/dep/blob/master/docs/Gopkg.toml.md\n# for detailed Gopkg.toml documentation.\n#\n# required = [\"github.com/user/thing/cmd/thing\"]\n# ignored = [\"github.com/user/project/pkgX\", \"bitbucket.org/user/project/pkgA/pkgY\"]\n#\n# [[constraint]]\n#   name = \"github.com/user/project\"\n#   version = \"1.0.0\"\n#\n# [[constraint]]\n#   name = \"github.com/user/project2\"\n#   branch = \"dev\"\n#   source = \"github.com/myfork/project2\"\n#\n# [[override]]\n#  name = \"github.com/x/y\"\n#  version = \"2.4.0\"\n\n\n[[constraint]]\n  name = \"github.com/cenkalti/backoff\"\n  version = \"1.1.0\"\n\n[[constraint]]\n  name = \"github.com/coreos/etcd\"\n  version = \"3.3.0-rc.1\"\n\n[[constraint]]\n  name = \"github.com/dgrijalva/jwt-go\"\n  version = \"3.1.0\"\n\n[[constraint]]\n  name = \"github.com/fatih/color\"\n  version = \"1.5.0\"\n\n[[constraint]]\n  name = \"github.com/gorilla/mux\"\n  version = \"1.6.0\"\n\n[[constraint]]\n  name = \"github.com/gorilla/websocket\"\n  version = \"1.2.0\"\n\n[[constraint]]\n  branch = \"master\"\n  name = \"github.com/hashicorp/go-version\"\n\n[[constraint]]\n  name = \"github.com/igm/sockjs-go\"\n  revision = \"c8a8c6429d10e3b6865960ad8cb43779b8a834ef\"\n\n[[constraint]]\n  branch = \"master\"\n  name = \"github.com/juju/ratelimit\"\n\n[[constraint]]\n  branch = \"master\"\n  name = \"github.com/koding/cache\"\n\n[[constraint]]\n  branch = \"master\"\n  name = \"github.com/koding/logging\"\n\n[[constraint]]\n  branch = \"master\"\n  name = \"github.com/koding/multiconfig\"\n\n[[constraint]]\n  branch = \"master\"\n  name = \"github.com/koding/websocketproxy\"\n\n[[constraint]]\n  name = \"github.com/lann/squirrel\"\n  version = \"1.0.0\"\n\n[[constraint]]\n  branch = \"master\"\n  name = \"github.com/lib/pq\"\n\n[[constraint]]\n  branch = \"master\"\n  name = \"github.com/mitchellh/cli\"\n\n[[constraint]]\n  branch = \"master\"\n  name = \"github.com/satori/go.uuid\"\n\n[[constraint]]\n  branch = \"master\"\n  name = \"golang.org/x/crypto\"\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.052734375,
          "content": "The MIT License (MIT)\n\nCopyright (c) 2016 Koding Inc.\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of\nthis software and associated documentation files (the \"Software\"), to deal in\nthe Software without restriction, including without limitation the rights to\nuse, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of\nthe Software, and to permit persons to whom the Software is furnished to do so,\nsubject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS\nFOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR\nCOPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER\nIN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\nCONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n"
        },
        {
          "name": "Makefile",
          "type": "blob",
          "size": 4.8818359375,
          "content": "NO_COLOR=\\033[0m\nOK_COLOR=\\033[0;32m\nKITE_HOME=/tmp/test_kite_home\nULIMIT=9000\n\n\nDEBUG?=0\nifeq ($(DEBUG), 1)\n\tVERBOSE=\"-v\"\nendif\n\n# Default to etcd\nifndef KONTROL_STORAGE\n\tKONTROL_STORAGE=etcd\nendif\n\nifndef KITE_TRANSPORT\n\tKITE_TRANSPORT=WebSocket\nendif\n\nifndef POSTGRES_HOST\n\tifdef DOCKER_HOST\n\t\tPOSTGRES_HOST=$(shell echo $(DOCKER_HOST) | cut -d: -f2 | cut -c 3-)\n\telse\n\t\tPOSTGRES_HOST=127.0.0.1\n\tendif\nendif\n\nall: test\n\npostgres:\n\tdocker stop postgres && docker rm postgres || true\n\tdocker run -d -v $(PWD)/postgres.d:/docker-entrypoint-initdb.d --name postgres -p 5432:5432 -P postgres:9.3\n\twhile ! docker logs postgres 2>&1 | grep 'ready for start up' >/dev/null; do sleep 1; done\n\tpsql -h $(POSTGRES_HOST) postgres -f kontrol/001-schema.sql -U postgres\n\tpsql -h $(POSTGRES_HOST) -c 'CREATE DATABASE kontrol owner kontrol;' -U postgres\n\tpsql -h $(POSTGRES_HOST) kontrol -f kontrol/002-table.sql -U postgres\n\tpsql -h $(POSTGRES_HOST) kontrol -f kontrol/003-migration-001-add-kite-key-table.sql -U postgres\n\tpsql -h $(POSTGRES_HOST) kontrol -f kontrol/003-migration-002-add-key-indexes.sql -U postgres\n\techo \"#!/bin/bash\" > .env\n\techo \"alias psql-kite='psql postgresql://postgres@$(POSTGRES_HOST):5432/kontrol'\" >> .env\n\techo \"export KONTROL_POSTGRES_HOST=$(POSTGRES_HOST)\" >> .env\n\techo \"export KONTROL_STORAGE=postgres\" >> .env\n\techo \"export KONTROL_POSTGRES_USERNAME=kontrolapplication\" >> .env\n\techo \"export KONTROL_POSTGRES_DBNAME=kontrol\" >> .env\n\techo \"export KONTROL_POSTGRES_PASSWORD=somerandompassword\" >> .env\n\npostgres-logs:\n\tdocker exec -ti postgres /bin/bash -c 'tail -f /var/lib/postgresql/data/pg_log/*.log'\n\nformat:\n\t@echo \"$(OK_COLOR)==> Formatting the code $(NO_COLOR)\"\n\t@gofmt -s -w *.go\n\t@goimports -w *.go\n\nkontrol:\n\t@echo \"$(OK_COLOR)==> Preparing kontrol test environment $(NO_COLOR)\"\n\t@rm -rf $(KITE_HOME)\n\n\t@echo \"$(OK_COLOR)==> Creating openssl keys $(NO_COLOR)\"\n\t@openssl genrsa -out /tmp/privateKey.pem 2048\n\t@openssl rsa -in /tmp/privateKey.pem -pubout -out /tmp/publicKey.pem\n\n\t@echo \"$(OK_COLOR)==> Creating test kite key $(NO_COLOR)\"\n\t@`which go` run kontrol/kontrol/main.go -publickeyfile /tmp/publicKey.pem -privatekeyfile /tmp/privateKey.pem -initial -username kite -kontrolurl \"http://localhost:4444/kite\"\n\n\t@echo \"$(OK_COLOR)==> Running Kontrol $(NO_COLOR)\"\n\t@`which go` run kontrol/kontrol/main.go -publickeyfile /tmp/publicKey.pem -privatekeyfile /tmp/privateKey.pem -port 4444\n\ninstall:\n\t@echo \"$(OK_COLOR)==> Downloading dependencies$(NO_COLOR)\"\n\t@`which go` get -d -v -t ./...\n\n\t@echo \"$(OK_COLOR)==> Installing test binaries $(NO_COLOR)\"\n\t@`which go` install -v ./kitectl\n\t@`which go` install -v ./kontrol/kontrol\n\t@`which go` install -v ./reverseproxy/reverseproxy\n\t@`which go` install -v ./tunnelproxy/tunnelproxy\n\nkontroltest:\n\t@echo \"$(OK_COLOR)==> Preparing test environment $(NO_COLOR)\"\n\t@echo \"Cleaning $(KITE_HOME) directory\"\n\t@rm -rf $(KITE_HOME)\n\n\n\t@echo \"Using as storage: $(KONTROL_STORAGE)\"\nifeq ($(KONTROL_STORAGE), \"etcd\")\n\t@echo \"Killing previous etcd instance\"\n\t@killall etcd ||:\n\n\t@echo \"Installing etcd\"\n\ttest -d \"_etcd\" || git clone -b release-2.2 https://github.com/coreos/etcd _etcd\n\t@rm -rf _etcd/default.etcd ||: #remove previous folder\n\t@cd _etcd; ./build; ./bin/etcd &\nendif\n\n\t@echo \"Creating test key\"\n\t@`which go` run ./testutil/writekey/main.go\n\n\t@echo \"$(OK_COLOR)==> Downloading dependencies$(NO_COLOR)\"\n\t@`which go` get -d -v -t ./...\n\n\t@echo \"$(OK_COLOR)==> Starting kontrol test $(NO_COLOR)\"\n\t@`which go` test -race $(VERBOSE) ./kontrol\n\ntest:\n\t@echo \"$(OK_COLOR)==> Preparing test environment $(NO_COLOR)\"\n\t@echo \"Using $(KITE_TRANSPORT) transport\"\n\t@echo \"Cleaning $(KITE_HOME) directory\"\n\t@rm -rf $(KITE_HOME)\n\n\t@echo \"Setting ulimit to $(ULIMIT) for multiple client tests\"\n\t@ulimit -n $(ULIMIT) #needed for multiple kontrol tests\n\n\t@echo \"$(OK_COLOR)==> Using kontrol storage: '$(KONTROL_STORAGE)'$(NO_COLOR)\"\n\n\nifeq ($(KONTROL_STORAGE), etcd)\n\t@echo \"Killing previous etcd instance\"\n\t@killall etcd ||:\n\n\t@echo \"Installing etcd\"\n\ttest -d \"_etcd\" || git clone -b release-2.2 https://github.com/coreos/etcd _etcd\n\t@rm -rf _etcd/default.etcd ||: #remove previous folder\n\t@cd _etcd; ./build; ./bin/etcd &\nendif\n\nifeq ($(KONTROL_STORAGE), postgres)\n\nifndef KONTROL_POSTGRES_USERNAME\n    $(error KONTROL_POSTGRES_USERNAME is not set)\nendif\n\nifndef KONTROL_POSTGRES_DBNAME\n    $(error KONTROL_POSTGRES_DBNAME is not set)\nendif\n\nendif\n\n\t@echo \"Creating test key\"\n\t@`which go` run ./testutil/writekey/main.go\n\t\n\t@echo \"$(OK_COLOR)==> Downloading test dependencies$(NO_COLOR)\"\t\t\n\t@`which go` get -d -v -t ./...\n\n\t@echo \"$(OK_COLOR)==> Testing packages $(NO_COLOR)\"\n\t@`which go` test -race $(VERBOSE) -p 1 ./...\n\ndoc:\n\t@`which godoc` github.com/koding/kite | less\n\nvet:\n\t@echo \"$(OK_COLOR)==> Running go vet $(NO_COLOR)\"\n\t@`which go` vet .\n\nlint:\n\t@echo \"$(OK_COLOR)==> Running golint $(NO_COLOR)\"\n\t@`which golint` .\n\nctags:\n\t@ctags -R --languages=c,go\n\n.PHONY: all install format test doc vet lint ctags kontrol kontroltest\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 4.2802734375,
          "content": "Kite Micro-Service Framework\n============================\n\nKite is a framework for developing micro-services in Go.\n\n[![GoDoc](http://img.shields.io/badge/go-documentation-brightgreen.svg?style=flat-square)](https://godoc.org/github.com/koding/kite)\n[![Build Status](http://img.shields.io/travis/koding/kite/master.svg?style=flat-square)](https://travis-ci.org/koding/kite)\n\n![Kite](http://i.imgur.com/iNcltPN.png)\n\n\nKite is both the name of the framework and the micro-service that is written by\nusing this framework.  Basically, Kite is a RPC server as well as a client. It\nconnects to other kites and peers to communicate with each other. They can\ndiscover other kites using a service called Kontrol, and communicate with them \nbidirectionaly. The communication protocol uses a WebSocket (or XHR) as transport \nin order to allow web applications to connect directly to kites.\n\nKites can talk with each other by sending\n[dnode](https://github.com/substack/dnode-protocol/blob/master/doc/protocol.markdown)\nmessages over a socket session.  If the client knows the URL of the server kite it\ncan connect to it directly.  If the URL is not known, client can ask for it\nfrom Kontrol (Service Discovery).\n\nFor more info checkout the blog post at GopherAcademy which explains Kite in more detail: http://blog.gopheracademy.com/birthday-bash-2014/kite-microservice-library/\n\nInstall and Usage\n-----------------\n\nInstall the package with:\n\n```bash\ngo get github.com/koding/kite\n```\n\nImport it with:\n\n```go\nimport \"github.com/koding/kite\"\n```\n\nand use `kite` as the package name inside the code.\n\nWhat is *Kontrol*?\n------------------\n\nKontrol is the service registry and authentication service used by Kites.  It\nis itself a kite too.\n\nWhen a kite starts to run, it can registers itself to Kontrol with the\n`Register()` method if wished.  That enables others to find it by querying\nKontrol. There is also a Proxy Kite for giving public URLs to registered\nkites.\n\nQuery has 7 fields:\n\n    /<username>/<environment>/<name>/<version>/<region>/<hostname>/<id>\n\n* You must at least give the username.\n* The order of the fields is from general to specific.\n* Query cannot contains empty parts between fields.\n\nInstalling *Kontrol*\n------------------\n\nInstall Kontrol:\n\n```\ngo get github.com/koding/kite/kontrol/kontrol\n```\n\nGenerate keys for the Kite key:\n\n```\nopenssl genrsa -out key.pem 2048\nopenssl rsa -in key.pem -pubout > key_pub.pem\n```\n\nSet environment variables:\n\n```\nKONTROL_PORT=6000\nKONTROL_USERNAME=\"kontrol\"\nKONTROL_STORAGE=\"etcd\"\nKONTROL_KONTROLURL=\"http://127.0.0.1:6000/kite\"\nKONTROL_PUBLICKEYFILE=\"certs/key_pub.pem\"\nKONTROL_PRIVATEKEYFILE=\"certs/key.pem\"\n```\n\nGenerate initial Kite key:\n\n```\n./bin/kontrol -initial\n```\n\nHow can I use kites from a browser?\n---------------------------------\n\nA browser can also be a Kite. It has it's own methods (\"log\" for logging a\nmessage to the console, \"alert\" for displaying alert to the user, etc.). A\nconnected kite can call methods defined on the webpage.\n\nSee [kite.js library](https://github.com/koding/kite.js) for more information.\n\nHow can I write a new kite?\n---------------------------\n\n* Import `kite` package.\n* Create a new instance with `kite.New()`.\n* Add your method handlers with `k.HandleFunc()` or `k.Handle()`.\n* Call `k.Run()`\n\nBelow you can find an example, a math kite which calculates the square of a\nreceived number:\n\n```go\npackage main\n\nimport \"github.com/koding/kite\"\n\nfunc main() {\n\t// Create a kite\n\tk := kite.New(\"math\", \"1.0.0\")\n\n\t// Add our handler method with the name \"square\"\n\tk.HandleFunc(\"square\", func(r *kite.Request) (interface{}, error) {\n\t\ta := r.Args.One().MustFloat64()\n\t\tresult := a * a    // calculate the square\n\t\treturn result, nil // send back the result\n\t}).DisableAuthentication()\n\n\t// Attach to a server with port 3636 and run it\n\tk.Config.Port = 3636\n\tk.Run()\n}\n```\n\nNow let's connect to it and send a `4` as an argument.\n\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\n\t\"github.com/koding/kite\"\n)\n\nfunc main() {\n\tk := kite.New(\"exp2\", \"1.0.0\")\n\n\t// Connect to our math kite\n\tmathWorker := k.NewClient(\"http://localhost:3636/kite\")\n\tmathWorker.Dial()\n\n\tresponse, _ := mathWorker.Tell(\"square\", 4) // call \"square\" method with argument 4\n\tfmt.Println(\"result:\", response.MustFloat64())\n}\n```\n\nCheck out the [examples](https://github.com/koding/kite/tree/master/examples)\nfolder for more examples.\n"
        },
        {
          "name": "appveyor.yml",
          "type": "blob",
          "size": 0.6455078125,
          "content": "version: \"{build}\"\n\nos: Windows Server 2012 R2\n\nclone_folder: c:\\projects\\src\\github.com\\koding\\kite\n\nenvironment:\n PATH: c:\\projects\\bin;%PATH%\n GOPATH: c:\\projects\n GOVERSION: 1.9.1\n\ninstall:\n - go version\n\n # update Go\n - rmdir c:\\go /s /q\n - appveyor DownloadFile https://storage.googleapis.com/golang/go%GOVERSION%.windows-amd64.zip\n - 7z x go%GOVERSION%.windows-amd64.zip -y -oC:\\ > NUL\n\n - go get -u -v github.com/golang/dep/cmd/dep\n - dep ensure -vendor-only -v\n\nbuild_script:\n - go build ./...\n - go test -v -race github.com/koding/kite github.com/koding/kite/dnode github.com/koding/kite/systeminfo\n # - go test -v -race ./...\n\ntest: off\n\ndeploy: off\n"
        },
        {
          "name": "bug_test.go",
          "type": "blob",
          "size": 1.2802734375,
          "content": "package kite_test\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"net/http/httptest\"\n\t\"testing\"\n\n\t\"github.com/koding/kite\"\n)\n\nfunc TestKite_MultipleDial(t *testing.T) {\n\tesrv := kite.New(\"echo-server\", \"0.0.0\")\n\tesrv.Config.DisableAuthentication = true\n\tif err := esrv.Config.ReadEnvironmentVariables(); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tesrv.HandleFunc(\"echo\", func(r *kite.Request) (interface{}, error) {\n\t\tvar arg string\n\n\t\tif err := r.Args.One().Unmarshal(&arg); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tif arg == \"\" {\n\t\t\treturn nil, errors.New(\"arg is empty\")\n\t\t}\n\n\t\treturn arg, nil\n\t})\n\n\tts := httptest.NewServer(esrv)\n\tecli := kite.New(\"echo-client\", \"0.0.0\")\n\tif err := ecli.Config.ReadEnvironmentVariables(); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tesrv.SetLogLevel(kite.DEBUG)\n\tecli.SetLogLevel(kite.DEBUG)\n\n\tc := ecli.NewClient(fmt.Sprintf(\"%s/kite\", ts.URL))\n\n\tif err := c.Dial(); err != nil {\n\t\tt.Fatalf(\"dialing echo-server kite error: %s\", err)\n\t}\n\n\tif err := c.Dial(); err != nil {\n\t\tt.Fatalf(\"dialing echo-server kite error: %s\", err)\n\t}\n\n\tresp, err := c.Tell(\"echo\", \"Hello world!\")\n\tif err != nil {\n\t\tt.Fatalf(\"Tell()=%s\", err)\n\t}\n\n\tvar reply string\n\n\tif err := resp.Unmarshal(&reply); err != nil {\n\t\tt.Fatalf(\"Unmarshal()=%s\", err)\n\t}\n\n\tif reply != \"Hello world!\" {\n\t\tt.Fatalf(`got %q, want \"Hello world!\"`, reply)\n\t}\n}\n"
        },
        {
          "name": "client.go",
          "type": "blob",
          "size": 25.5947265625,
          "content": "package kite\n\nimport (\n\t\"context\"\n\t\"encoding/json\"\n\t\"errors\"\n\t\"fmt\"\n\t\"net/http\"\n\t\"strconv\"\n\t\"strings\"\n\t\"sync\"\n\t\"sync/atomic\"\n\t\"time\"\n\n\t\"github.com/koding/kite/config\"\n\t\"github.com/koding/kite/dnode\"\n\t\"github.com/koding/kite/protocol\"\n\t\"github.com/koding/kite/sockjsclient\"\n\n\t\"github.com/cenkalti/backoff\"\n\t\"github.com/gorilla/websocket\"\n\t\"github.com/igm/sockjs-go/sockjs\"\n)\n\nvar forever backoff.BackOff\n\nfunc init() {\n\tb := backoff.NewExponentialBackOff()\n\tb.MaxElapsedTime = 365 * 24 * time.Hour // 1 year\n\n\tforever = &lockedBackoff{b: b}\n}\n\nfunc nopSetSession(sockjs.Session) {}\n\n// Client is the client for communicating with another Kite.\n// It has Tell() and Go() methods for calling methods sync/async way.\ntype Client struct {\n\tprotocol.Kite // remote kite information\n\n\t// LocalKite references to the kite which owns the client\n\t// connection.\n\tLocalKite *Kite\n\n\t// Auth is a credential used to authenticate with a remote kite.\n\t//\n\t// Required if remote kite requires authentication.\n\tAuth *Auth\n\n\t// Reconnect says whether we should reconnect with a new\n\t// session when an old one got invalidated or the connection\n\t// broke.\n\tReconnect bool\n\n\t// URL specifies the SockJS URL of the remote kite.\n\tURL string\n\n\t// Config is used when setting up client connection to\n\t// the remote kite.\n\t//\n\t// If Config is nil, LocalKite.Config is used instead.\n\tConfig *config.Config\n\n\t// Concurrent specified whether we should process incoming messages concurrently.\n\t//\n\t// Defaults to true.\n\tConcurrent bool\n\n\t// ConcurrentCallbacks, when true, makes execution of callbacks in\n\t// incoming messages concurrent. This may result in a callback\n\t// received in an earlier message to be executed after a callback\n\t// from a new meesage - no order is guaranteed, it's up to Go scheduler.\n\t//\n\t// By default this field is false to be backward-compatible with\n\t// go1.4 scheduling behaviour.\n\tConcurrentCallbacks bool\n\n\t// ClientFunc is called each time new sockjs.Session is established.\n\t// The session will use returned *http.Client for HTTP round trips\n\t// for XHR transport.\n\t//\n\t// If ClientFunc is nil, sockjs.Session will use default, internal\n\t// *http.Client value.\n\t//\n\t// Deprecated: Set Config.XHR of the local kite, that\n\t// owns this connection, insead.\n\tClientFunc func(*sockjsclient.DialOptions) *http.Client\n\n\t// ReadBufferSize is the input buffer size. By default it's 4096.\n\t//\n\t// Deprecated: Set Config.Websocket.ReadBufferSize of the local kite,\n\t// that owns this connection, instead.\n\tReadBufferSize int\n\n\t// WriteBufferSize is the output buffer size. By default it's 4096.\n\t//\n\t// Deprecated: Set Config.Websocket.WriteBufferSize of the local kite,\n\t// that owns this connection, instead.\n\tWriteBufferSize int\n\n\tmuProt sync.Mutex // protects protocol.Kite access\n\n\t// To signal waiters of Go() on disconnect.\n\tdisconnect   chan struct{}\n\tdisconnectMu sync.Mutex // protects disconnect chan\n\n\t// authMu protects Auth field.\n\tauthMu sync.Mutex\n\n\t// To signal about the close\n\tcloseChan chan struct{}\n\n\t// closeRenewer is used to stop renewing tokens when client\n\t// is closed but was not dialed\n\tcloseRenewer chan struct{}\n\n\t// interrupt is used to signalise readloop that\n\t// session was interrupted.\n\tinterrupt chan error\n\n\t// To syncronize the consumers\n\twg sync.WaitGroup\n\n\t// SockJS session\n\t// TODO: replace this with a proper interface to support multiple\n\t// transport/protocols\n\tsession sockjs.Session\n\tsend    chan *message\n\n\t// ctx and cancel keeps track of session lifetime\n\tctxMu  sync.Mutex\n\tctx    context.Context\n\tcancel func()\n\n\t// muReconnect protects Reconnect\n\tmuReconnect sync.Mutex\n\n\t// closed is to ensure Close is idempotent\n\tclosed int32\n\n\t// dnode scrubber for saving callbacks sent to remote.\n\tscrubber *dnode.Scrubber\n\n\t// Time to wait before redial connection.\n\tredialBackOff backoff.BackOff\n\n\t// on connect/disconnect handlers are invoked after every\n\t// connect/disconnect.\n\tonConnectHandlers     []func()\n\tonDisconnectHandlers  []func()\n\tonTokenExpireHandlers []func()\n\tonTokenRenewHandlers  []func(string)\n\n\ttestHookSetSession func(sockjs.Session)\n\n\t// For protecting access over OnConnect and OnDisconnect handlers.\n\tm sync.RWMutex\n\n\tfirstRequestHandlersNotified sync.Once\n}\n\n// message carries an encoded payload sent over connected session.\ntype message struct {\n\tp    []byte\n\terrC chan<- error\n}\n\n// callOptions is the type of first argument in the dnode message.\n// It is used when unmarshalling a dnode message.\ntype callOptions struct {\n\t// Arguments to the method\n\tKite             protocol.Kite  `json:\"kite\" dnode:\"-\"`\n\tAuth             *Auth          `json:\"authentication\"`\n\tWithArgs         *dnode.Partial `json:\"withArgs\" dnode:\"-\"`\n\tResponseCallback dnode.Function `json:\"responseCallback\"`\n}\n\n// callOptionsOut is the same structure with callOptions.\n// It is used when marshalling a dnode message.\ntype callOptionsOut struct {\n\tcallOptions\n\n\t// Override this when sending because args will not be a *dnode.Partial.\n\tWithArgs []interface{} `json:\"withArgs\"`\n}\n\n// Authentication is used when connecting a Client.\ntype Auth struct {\n\t// Type can be \"kiteKey\", \"token\" or \"sessionID\" for now.\n\tType string `json:\"type\"`\n\tKey  string `json:\"key\"`\n}\n\n// response is the type of the return value of Tell() and Go() methods.\ntype response struct {\n\tResult *dnode.Partial\n\tErr    error\n}\n\n// NewClient returns a pointer to a new Client. The returned instance\n// is not connected. You have to call Dial() or DialForever() before calling\n// Tell() and Go() methods.\nfunc (k *Kite) NewClient(remoteURL string) *Client {\n\tc := &Client{\n\t\tLocalKite:          k,\n\t\tURL:                remoteURL,\n\t\tdisconnect:         make(chan struct{}),\n\t\tcloseChan:          make(chan struct{}),\n\t\tredialBackOff:      forever,\n\t\tscrubber:           dnode.NewScrubber(),\n\t\ttestHookSetSession: nopSetSession,\n\t\tConcurrent:         true,\n\t\tsend:               make(chan *message),\n\t\tinterrupt:          make(chan error, 1),\n\t\tctx:                context.Background(),\n\t\tcancel:             func() {},\n\t}\n\n\tc.OnConnect(c.setContext)\n\tc.OnDisconnect(c.closeContext)\n\n\tk.OnRegister(c.updateAuth)\n\n\treturn c\n}\n\nfunc (c *Client) SetUsername(username string) {\n\tc.muProt.Lock()\n\tc.Kite.Username = username\n\tc.muProt.Unlock()\n}\n\n// Dial connects to the remote Kite. Returns error if it can't.\nfunc (c *Client) Dial() (err error) {\n\t// zero means no timeout\n\treturn c.DialTimeout(0)\n}\n\n// DialTimeout acts like Dial but takes a timeout.\nfunc (c *Client) DialTimeout(timeout time.Duration) error {\n\terr := c.dial(timeout)\n\n\tc.LocalKite.Log.Debug(\"Dialing '%s' kite: %s (error: %v)\", c.Kite.Name, c.URL, err)\n\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tgo c.run()\n\n\treturn nil\n}\n\n// Dial connects to the remote Kite. If it can't connect, it retries\n// indefinitely. It returns a channel to check if it's connected or not.\nfunc (c *Client) DialForever() (connected chan bool, err error) {\n\tc.Reconnect = true\n\tconnected = make(chan bool, 1) // This will be closed on first connection.\n\tgo c.dialForever(connected)\n\treturn\n}\n\nfunc (c *Client) updateAuth(reg *protocol.RegisterResult) {\n\tc.authMu.Lock()\n\tdefer c.authMu.Unlock()\n\n\tif c.Auth == nil {\n\t\treturn\n\t}\n\n\tif c.Auth.Type == \"kiteKey\" && reg.KiteKey != \"\" {\n\t\tc.Auth.Key = reg.KiteKey\n\t}\n}\n\nfunc (c *Client) setContext() {\n\tc.ctxMu.Lock()\n\tc.ctx, c.cancel = context.WithCancel(context.Background())\n\tc.ctxMu.Unlock()\n}\n\nfunc (c *Client) closeContext() {\n\tc.ctxMu.Lock()\n\tc.cancel()\n\tc.ctxMu.Unlock()\n}\n\nfunc (c *Client) context() context.Context {\n\tc.ctxMu.Lock()\n\tdefer c.ctxMu.Unlock()\n\treturn c.ctx\n}\n\nfunc (c *Client) authCopy() *Auth {\n\tc.authMu.Lock()\n\tdefer c.authMu.Unlock()\n\n\tif c.Auth == nil {\n\t\treturn nil\n\t}\n\n\tauthCopy := *c.Auth\n\treturn &authCopy\n}\n\nfunc (c *Client) dial(timeout time.Duration) (err error) {\n\ttransport := c.config().Transport\n\n\tc.LocalKite.Log.Debug(\"Client transport is set to '%s'\", transport)\n\n\tvar session sockjs.Session\n\n\tswitch transport {\n\tcase config.WebSocket:\n\t\tsession, err = sockjsclient.DialWebsocket(c.URL, c.config())\n\tcase config.XHRPolling:\n\t\tsession, err = sockjsclient.DialXHR(c.URL, c.config())\n\tcase config.Auto:\n\t\tsession, err = sockjsclient.DialWebsocket(c.URL, c.config())\n\t\tif err == websocket.ErrBadHandshake {\n\t\t\t// In cases when kite server is behind a proxy that do\n\t\t\t// not support websocket connections, fall back to XHR.\n\t\t\tsession, err = sockjsclient.DialXHR(c.URL, c.config())\n\t\t}\n\tdefault:\n\t\treturn fmt.Errorf(\"Connection transport is not known '%v'\", transport)\n\t}\n\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tc.setSession(session)\n\tc.wg.Add(1)\n\tgo c.sendHub()\n\n\t// Reset the wait time.\n\tc.redialBackOff.Reset()\n\n\t// Must be run in a goroutine because a handler may wait a response from\n\t// server.\n\tgo c.callOnConnectHandlers()\n\n\treturn nil\n}\n\nfunc (c *Client) dialForever(connectNotifyChan chan bool) {\n\tdial := func() error {\n\t\tif !c.reconnect() {\n\t\t\treturn nil\n\t\t}\n\n\t\tc.LocalKite.Log.Info(\"Dialing '%s' kite: %s\", c.Kite.Name, c.URL)\n\n\t\tif err := c.dial(0); err != nil {\n\t\t\tc.LocalKite.Log.Warning(\"Dialing '%s' kite error: %s: %v\", c.Kite.Name, c.URL, err)\n\n\t\t\treturn err\n\t\t}\n\n\t\treturn nil\n\t}\n\n\tbackoff.Retry(dial, c.redialBackOff) // this will retry dial forever\n\n\tif connectNotifyChan != nil {\n\t\tclose(connectNotifyChan)\n\t}\n\n\tgo c.run()\n}\n\nfunc (c *Client) RemoteAddr() string {\n\tsession := c.getSession()\n\tif session == nil {\n\t\treturn \"\"\n\t}\n\n\twebsocketsession, ok := session.(*sockjsclient.WebsocketSession)\n\tif !ok {\n\t\treturn \"\"\n\t}\n\n\treturn websocketsession.RemoteAddr()\n}\n\n// run consumes incoming dnode messages. Reconnects if necessary.\nfunc (c *Client) run() {\n\terr := c.readLoop()\n\tif err != nil {\n\t\tc.LocalKite.Log.Debug(\"readloop err: %s\", err)\n\t}\n\n\t// falls here when connection disconnects\n\tc.callOnDisconnectHandlers()\n\n\t// let others know that the client has disconnected\n\tc.disconnectMu.Lock()\n\tif c.disconnect != nil {\n\t\tclose(c.disconnect)\n\t\tc.disconnect = nil\n\t}\n\tc.disconnectMu.Unlock()\n\n\tif c.reconnect() {\n\t\t// we override it so it doesn't get selected next time. Because we are\n\t\t// redialing, so after redial if a new method is called, the disconnect\n\t\t// channel is being read and the local \"disconnect\" message will be the\n\t\t// final response. This shouldn't be happen for redials.\n\t\tc.disconnectMu.Lock()\n\t\tc.disconnect = make(chan struct{}, 1)\n\t\tc.disconnectMu.Unlock()\n\t\tgo c.dialForever(nil)\n\t}\n}\n\nfunc (c *Client) reconnect() bool {\n\tc.muReconnect.Lock()\n\tdefer c.muReconnect.Unlock()\n\n\treturn c.Reconnect\n}\n\n// readLoop reads a message from websocket and processes it.\nfunc (c *Client) readLoop() error {\n\tfor {\n\t\tp, err := c.receiveData()\n\n\t\tc.LocalKite.Log.Debug(\"readloop received: %s %v\", p, err)\n\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tmsg, fn, err := c.processMessage(p)\n\t\tif err != nil {\n\t\t\tif _, ok := err.(dnode.CallbackNotFoundError); !ok {\n\t\t\t\tc.LocalKite.Log.Warning(\"error processing message err: %s message: %s\", err, msg)\n\t\t\t}\n\t\t}\n\n\t\tswitch v := fn.(type) {\n\t\tcase *Method: // invoke method\n\t\t\tif c.Concurrent {\n\t\t\t\tgo c.runMethod(v, msg.Arguments)\n\t\t\t} else {\n\t\t\t\tc.runMethod(v, msg.Arguments)\n\t\t\t}\n\t\tcase func(*dnode.Partial): // invoke callback\n\t\t\tif c.Concurrent && c.ConcurrentCallbacks {\n\t\t\t\tgo c.runCallback(v, msg.Arguments)\n\t\t\t} else {\n\t\t\t\tc.runCallback(v, msg.Arguments)\n\t\t\t}\n\t\t}\n\t}\n}\n\n// receiveData reads a message from session.\nfunc (c *Client) receiveData() ([]byte, error) {\n\ttype recv struct {\n\t\tmsg []byte\n\t\terr error\n\t}\n\n\tsession := c.getSession()\n\tif session == nil {\n\t\treturn nil, errors.New(\"not connected\")\n\t}\n\n\tdone := make(chan recv, 1)\n\n\tgo func() {\n\t\tmsg, err := session.Recv()\n\t\tdone <- recv{[]byte(msg), err}\n\t}()\n\n\tselect {\n\tcase r := <-done:\n\t\treturn r.msg, r.err\n\tcase err := <-c.interrupt:\n\t\treturn nil, err\n\t}\n}\n\n// processMessage processes a single message and calls a handler or callback.\nfunc (c *Client) processMessage(data []byte) (msg *dnode.Message, fn interface{}, err error) {\n\t// Call error handler.\n\tdefer func() {\n\t\tif err != nil {\n\t\t\tonError(err)\n\t\t}\n\t}()\n\n\tmsg = &dnode.Message{}\n\n\tif err = json.Unmarshal(data, &msg); err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tsender := func(id uint64, args []interface{}) error {\n\t\t// do not name the error variable to \"err\" here, it's a trap for\n\t\t// shadowing variables\n\t\t_, _, e := c.marshalAndSend(id, args)\n\t\treturn e\n\t}\n\n\t// Replace function placeholders with real functions.\n\tif err := dnode.ParseCallbacks(msg, sender); err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\t// Find the handler function. Method may be string or integer.\n\tswitch method := msg.Method.(type) {\n\tcase float64:\n\t\tid := uint64(method)\n\t\tcallback := c.scrubber.GetCallback(id)\n\t\tif callback == nil {\n\t\t\terr = dnode.CallbackNotFoundError{\n\t\t\t\tID:   id,\n\t\t\t\tArgs: msg.Arguments,\n\t\t\t}\n\t\t\treturn nil, nil, err\n\t\t}\n\n\t\treturn msg, callback, nil\n\tcase string:\n\t\tm, ok := c.LocalKite.handlers[method]\n\t\tif !ok {\n\t\t\terr = dnode.MethodNotFoundError{\n\t\t\t\tMethod: method,\n\t\t\t\tArgs:   msg.Arguments,\n\t\t\t}\n\t\t\treturn nil, nil, err\n\t\t}\n\n\t\treturn msg, m, nil\n\tdefault:\n\t\treturn nil, nil, fmt.Errorf(\"Method is not string or integer: %+v (%T)\", msg.Method, msg.Method)\n\t}\n}\n\nfunc (c *Client) Close() {\n\tif !atomic.CompareAndSwapInt32(&c.closed, 0, 1) {\n\t\treturn // TODO: ErrAlreadyClosed\n\t}\n\n\tc.muReconnect.Lock()\n\t// TODO(rjeczalik): add another internal field for controlling redials\n\t// instead of mutating public field\n\tc.Reconnect = false\n\tc.muReconnect.Unlock()\n\n\tclose(c.closeChan)\n\n\tif c.closeRenewer != nil {\n\t\tselect {\n\t\tcase c.closeRenewer <- struct{}{}:\n\t\tdefault:\n\t\t}\n\t}\n\n\t// wait for consumers to finish buffered messages\n\tc.wg.Wait()\n\n\tif session := c.getSession(); session != nil {\n\t\tsession.Close(3000, \"Go away!\")\n\t}\n}\n\n// sendhub sends the msg received from the send channel to the remote client\nfunc (c *Client) sendHub() {\n\tdefer c.wg.Done()\n\n\tfor {\n\t\tselect {\n\t\tcase msg := <-c.send:\n\t\t\tc.LocalKite.Log.Debug(\"sending: %s\", msg)\n\t\t\tsession := c.getSession()\n\t\t\tif session == nil {\n\t\t\t\tc.LocalKite.Log.Error(\"not connected\")\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\terr := session.Send(string(msg.p))\n\t\t\tif err != nil {\n\t\t\t\tif msg.errC != nil {\n\t\t\t\t\tmsg.errC <- err\n\t\t\t\t}\n\n\t\t\t\tif sockjsclient.IsSessionClosed(err) {\n\t\t\t\t\t// The readloop may already be interrupted, thus the non-blocking send.\n\t\t\t\t\tselect {\n\t\t\t\t\tcase c.interrupt <- err:\n\t\t\t\t\tdefault:\n\t\t\t\t\t}\n\n\t\t\t\t\tc.LocalKite.Log.Error(\"error sending to %s: %s\", session.ID(), err)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}\n\t\tcase <-c.closeChan:\n\t\t\tc.LocalKite.Log.Debug(\"Send hub is closed\")\n\t\t\treturn\n\t\t}\n\t}\n}\n\n// OnConnect adds a callback which is called when client connects\n// to a remote kite.\nfunc (c *Client) OnConnect(handler func()) {\n\tc.m.Lock()\n\tc.onConnectHandlers = append(c.onConnectHandlers, handler)\n\tc.m.Unlock()\n}\n\n// OnDisconnect adds a callback which is called when client disconnects\n// from a remote kite.\nfunc (c *Client) OnDisconnect(handler func()) {\n\tc.m.Lock()\n\tc.onDisconnectHandlers = append(c.onDisconnectHandlers, handler)\n\tc.m.Unlock()\n}\n\n// OnTokenExpire adds a callback which is called when client receives\n// token-is-expired error from a remote kite.\nfunc (c *Client) OnTokenExpire(handler func()) {\n\tc.m.Lock()\n\tc.onTokenExpireHandlers = append(c.onTokenExpireHandlers, handler)\n\tc.m.Unlock()\n}\n\n// OnTokenRenew adds a callback which is called when client successfully\n// renews its token.\nfunc (c *Client) OnTokenRenew(handler func(token string)) {\n\tc.m.Lock()\n\tc.onTokenRenewHandlers = append(c.onTokenRenewHandlers, handler)\n\tc.m.Unlock()\n}\n\n// callOnConnectHandlers runs the registered connect handlers.\nfunc (c *Client) callOnConnectHandlers() {\n\tc.m.RLock()\n\tdefer c.m.RUnlock()\n\n\tfor _, handler := range c.onConnectHandlers {\n\t\tfunc() {\n\t\t\tdefer nopRecover()\n\t\t\thandler()\n\t\t}()\n\t}\n}\n\n// callOnDisconnectHandlers runs the registered disconnect handlers.\nfunc (c *Client) callOnDisconnectHandlers() {\n\tc.m.RLock()\n\tdefer c.m.RUnlock()\n\n\tfor _, handler := range c.onDisconnectHandlers {\n\t\tfunc() {\n\t\t\tdefer nopRecover()\n\t\t\thandler()\n\t\t}()\n\t}\n}\n\n// callOnTokenExpireHandlers calls registered functions when an error\n// from remote kite is received that token used is expired.\nfunc (c *Client) callOnTokenExpireHandlers() {\n\tc.m.RLock()\n\tdefer c.m.RUnlock()\n\n\tfor _, handler := range c.onTokenExpireHandlers {\n\t\tfunc() {\n\t\t\tdefer nopRecover()\n\t\t\thandler()\n\t\t}()\n\t}\n}\n\n// callOnTokenRenewHandlers calls all registered functions when\n// we successfully obtain new token from kontrol.\nfunc (c *Client) callOnTokenRenewHandlers(token string) {\n\tc.m.RLock()\n\tdefer c.m.RUnlock()\n\n\tfor _, handler := range c.onTokenRenewHandlers {\n\t\tfunc() {\n\t\t\tdefer nopRecover()\n\t\t\thandler(token)\n\t\t}()\n\t}\n}\n\nfunc (c *Client) wrapMethodArgs(args []interface{}, responseCallback dnode.Function) []interface{} {\n\toptions := callOptionsOut{\n\t\tWithArgs: args,\n\t\tcallOptions: callOptions{\n\t\t\tKite:             *c.LocalKite.Kite(),\n\t\t\tAuth:             c.authCopy(),\n\t\t\tResponseCallback: responseCallback,\n\t\t},\n\t}\n\treturn []interface{}{options}\n}\n\n// Tell makes a blocking method call to the server.\n// Waits until the callback function is called by the other side and\n// returns the result and the error.\nfunc (c *Client) Tell(method string, args ...interface{}) (result *dnode.Partial, err error) {\n\treturn c.TellWithTimeout(method, 0, args...)\n}\n\n// SendWebRTCRequest sends requests to kontrol for signalling purposes.\nfunc (c *Client) SendWebRTCRequest(req *protocol.WebRTCSignalMessage) error {\n\ttimeout := time.Duration(0)\n\tif c.Config != nil {\n\t\ttimeout = c.Config.Timeout\n\t}\n\t_, err := c.TellWithTimeout(WebRTCHandlerName, timeout, req)\n\treturn err\n}\n\n// TellWithTimeout does the same thing with Tell() method except it takes an\n// extra argument that is the timeout for waiting reply from the remote Kite.\n// If timeout is given 0, the behavior is same as Tell().\nfunc (c *Client) TellWithTimeout(method string, timeout time.Duration, args ...interface{}) (result *dnode.Partial, err error) {\n\tresponse := <-c.GoWithTimeout(method, timeout, args...)\n\treturn response.Result, response.Err\n}\n\n// Go makes an unblocking method call to the server.\n// It returns a channel that the caller can wait on it to get the response.\nfunc (c *Client) Go(method string, args ...interface{}) chan *response {\n\treturn c.GoWithTimeout(method, 0, args...)\n}\n\n// GoWithTimeout does the same thing with Go() method except it takes an\n// extra argument that is the timeout for waiting reply from the remote Kite.\n// If timeout is given 0, the behavior is same as Go().\nfunc (c *Client) GoWithTimeout(method string, timeout time.Duration, args ...interface{}) chan *response {\n\t// We will return this channel to the caller.\n\t// It can wait on this channel to get the response.\n\tresponseChan := make(chan *response, 1)\n\n\tc.sendMethod(method, args, timeout, responseChan)\n\n\treturn responseChan\n}\n\n// sendMethod wraps the arguments, adds a response callback,\n// marshals the message and send it over the wire.\nfunc (c *Client) sendMethod(method string, args []interface{}, timeout time.Duration, responseChan chan *response) {\n\t// To clean the sent callback after response is received.\n\t// Send/Receive in a channel to prevent race condition because\n\t// the callback is run in a separate goroutine.\n\tremoveCallback := make(chan uint64, 1)\n\n\t// When a callback is called it will send the response to this channel.\n\tdoneChan := make(chan *response, 1)\n\n\tcb := c.makeResponseCallback(doneChan, removeCallback, method, args)\n\targs = c.wrapMethodArgs(args, cb)\n\n\tcallbacks, errC, err := c.marshalAndSend(method, args)\n\tif err != nil {\n\t\tresponseChan <- &response{\n\t\t\tResult: nil,\n\t\t\tErr: &Error{\n\t\t\t\tType:    \"sendError\",\n\t\t\t\tMessage: err.Error(),\n\t\t\t},\n\t\t}\n\t\treturn\n\t}\n\n\t// nil value of afterTimeout means no timeout, it will not selected in\n\t// select statement\n\tvar afterTimeout <-chan time.Time\n\tif timeout > 0 {\n\t\tafterTimeout = time.After(timeout)\n\t}\n\n\t// Waits until the response has came or the connection has disconnected.\n\tgo func() {\n\t\tc.disconnectMu.Lock()\n\t\tdefer c.disconnectMu.Unlock()\n\n\t\tselect {\n\t\tcase resp := <-doneChan:\n\t\t\tif e, ok := resp.Err.(*Error); ok {\n\t\t\t\tif e.Type == \"authenticationError\" && strings.Contains(e.Message, \"token is expired\") {\n\t\t\t\t\tc.callOnTokenExpireHandlers()\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tresponseChan <- resp\n\t\tcase <-c.disconnect:\n\t\t\tresponseChan <- &response{\n\t\t\t\tnil,\n\t\t\t\t&Error{\n\t\t\t\t\tType:    \"disconnect\",\n\t\t\t\t\tMessage: \"Remote kite has disconnected\",\n\t\t\t\t},\n\t\t\t}\n\t\tcase err := <-errC:\n\t\t\tif err != nil {\n\t\t\t\tresponseChan <- &response{\n\t\t\t\t\tnil,\n\t\t\t\t\t&Error{\n\t\t\t\t\t\tType:    \"sendError\",\n\t\t\t\t\t\tMessage: err.Error(),\n\t\t\t\t\t},\n\t\t\t\t}\n\t\t\t}\n\t\tcase <-afterTimeout:\n\t\t\tresponseChan <- &response{\n\t\t\t\tnil,\n\t\t\t\t&Error{\n\t\t\t\t\tType:    \"timeout\",\n\t\t\t\t\tMessage: fmt.Sprintf(\"No response to %q method in %s\", method, timeout),\n\t\t\t\t},\n\t\t\t}\n\n\t\t\t// Remove the callback function from the map so we do not\n\t\t\t// consume memory for unused callbacks.\n\t\t\tif id, ok := <-removeCallback; ok {\n\t\t\t\tc.scrubber.RemoveCallback(id)\n\t\t\t}\n\t\t}\n\t}()\n\n\tsendCallbackID(callbacks, removeCallback)\n}\n\n// marshalAndSend takes a method and arguments, scrubs the arguments to create\n// a dnode message, marshals the message to JSON and sends it over the wire.\nfunc (c *Client) marshalAndSend(method interface{}, arguments []interface{}) (callbacks map[string]dnode.Path, errC <-chan error, err error) {\n\t// scrub trough the arguments and save any callbacks.\n\tcallbacks = c.scrubber.Scrub(arguments)\n\n\tdefer func() {\n\t\tif err != nil {\n\t\t\tc.removeCallbacks(callbacks)\n\t\t}\n\t}()\n\n\t// Do not encode empty arguments as \"null\", make it \"[]\".\n\tif arguments == nil {\n\t\targuments = make([]interface{}, 0)\n\t}\n\n\trawArgs, err := json.Marshal(arguments)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tmsg := dnode.Message{\n\t\tMethod:    method,\n\t\tArguments: &dnode.Partial{Raw: rawArgs},\n\t\tCallbacks: callbacks,\n\t}\n\n\tp, err := json.Marshal(msg)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tselect {\n\tcase <-c.closeChan:\n\t\treturn nil, nil, errors.New(\"can't send, client is closed\")\n\tdefault:\n\t\tif c.getSession() == nil {\n\t\t\treturn nil, nil, errors.New(\"can't send, session is not established yet\")\n\t\t}\n\n\t\terrC := make(chan error, 1)\n\n\t\tc.send <- &message{\n\t\t\tp:    p,\n\t\t\terrC: errC,\n\t\t}\n\n\t\treturn callbacks, errC, nil\n\t}\n}\n\nfunc (c *Client) getSession() sockjs.Session {\n\tc.m.RLock()\n\tdefer c.m.RUnlock()\n\n\treturn c.session\n}\n\nfunc (c *Client) setSession(session sockjs.Session) {\n\tc.testHookSetSession(session)\n\n\tc.m.Lock()\n\tc.session = session\n\tc.m.Unlock()\n}\n\n// Used to remove callbacks after error occurs in send().\nfunc (c *Client) removeCallbacks(callbacks map[string]dnode.Path) {\n\tfor sid := range callbacks {\n\t\t// We don't check for error because we have created\n\t\t// the callbacks map in the send function above.\n\t\t// It does not come from remote, so cannot contain errors.\n\t\tid, _ := strconv.ParseUint(sid, 10, 64)\n\t\tc.scrubber.RemoveCallback(id)\n\t}\n}\n\nfunc (c *Client) config() *config.Config {\n\tif c.Config != nil {\n\t\treturn c.Config\n\t}\n\treturn c.LocalKite.Config\n}\n\n// sendCallbackID send the callback number to be deleted after response is received.\nfunc sendCallbackID(callbacks map[string]dnode.Path, ch chan<- uint64) {\n\t// TODO fix finding of responseCallback in dnode message when removing callback\n\tfor id, path := range callbacks {\n\t\tif len(path) != 2 {\n\t\t\tcontinue\n\t\t}\n\t\tp0, ok := path[0].(string)\n\t\tif !ok {\n\t\t\tcontinue\n\t\t}\n\t\tp1, ok := path[1].(string)\n\t\tif !ok {\n\t\t\tcontinue\n\t\t}\n\t\tif p0 != \"0\" || p1 != \"responseCallback\" {\n\t\t\tcontinue\n\t\t}\n\t\ti, _ := strconv.ParseUint(id, 10, 64)\n\t\tch <- i\n\t\treturn\n\t}\n\tclose(ch)\n}\n\n// makeResponseCallback prepares and returns a callback function sent to the server.\n// The caller of the Tell() is blocked until the server calls this callback function.\n// Sets theResponse and notifies the caller by sending to done channel.\nfunc (c *Client) makeResponseCallback(doneChan chan *response, removeCallback <-chan uint64, method string, args []interface{}) dnode.Function {\n\treturn dnode.Callback(func(arguments *dnode.Partial) {\n\t\t// Single argument of response callback.\n\t\tvar resp struct {\n\t\t\tResult *dnode.Partial `json:\"result\"`\n\t\t\tErr    *Error         `json:\"error\"`\n\t\t}\n\n\t\t// Notify that the callback is finished.\n\t\tdefer func() {\n\t\t\tif resp.Err != nil {\n\t\t\t\tc.LocalKite.Log.Debug(\"Error received from kite: %q method: %q args: %#v err: %s\", c.Kite.Name, method, args, resp.Err.Error())\n\t\t\t\tdoneChan <- &response{resp.Result, resp.Err}\n\t\t\t} else {\n\t\t\t\tdoneChan <- &response{resp.Result, nil}\n\t\t\t}\n\t\t}()\n\n\t\t// Remove the callback function from the map so we do not\n\t\t// consume memory for unused callbacks.\n\t\tif id, ok := <-removeCallback; ok {\n\t\t\tc.scrubber.RemoveCallback(id)\n\t\t}\n\n\t\t// We must only get one argument for response callback.\n\t\targ, err := arguments.SliceOfLength(1)\n\t\tif err != nil {\n\t\t\tresp.Err = &Error{Type: \"invalidResponse\", Message: err.Error()}\n\t\t\treturn\n\t\t}\n\n\t\t// Unmarshal callback response argument.\n\t\terr = arg[0].Unmarshal(&resp)\n\t\tif err != nil {\n\t\t\tresp.Err = &Error{Type: \"invalidResponse\", Message: err.Error()}\n\t\t\treturn\n\t\t}\n\n\t\t// At least result or error must be sent.\n\t\tkeys := make(map[string]interface{})\n\t\terr = arg[0].Unmarshal(&keys)\n\t\t_, ok1 := keys[\"result\"]\n\t\t_, ok2 := keys[\"error\"]\n\t\tif !ok1 && !ok2 {\n\t\t\tresp.Err = &Error{\n\t\t\t\tType:    \"invalidResponse\",\n\t\t\t\tMessage: \"Server has sent invalid response arguments\",\n\t\t\t}\n\t\t\treturn\n\t\t}\n\t})\n}\n\n// onError is called when an error happened in a method handler.\nfunc onError(err error) {\n\t// TODO do not marshal options again here\n\tswitch e := err.(type) {\n\tcase dnode.MethodNotFoundError: // Tell the requester \"method is not found\".\n\t\targs, err2 := e.Args.Slice()\n\t\tif err2 != nil {\n\t\t\treturn\n\t\t}\n\n\t\tif len(args) < 1 {\n\t\t\treturn\n\t\t}\n\n\t\tvar options callOptions\n\t\tif err := args[0].Unmarshal(&options); err != nil {\n\t\t\treturn\n\t\t}\n\n\t\tif options.ResponseCallback.Caller != nil {\n\t\t\tresponse := Response{\n\t\t\t\tResult: nil,\n\t\t\t\tError: &Error{\n\t\t\t\t\tType:    \"methodNotFound\",\n\t\t\t\t\tMessage: err.Error(),\n\t\t\t\t},\n\t\t\t}\n\t\t\toptions.ResponseCallback.Call(response)\n\t\t}\n\t}\n}\n\ntype lockedBackoff struct {\n\tmu sync.Mutex\n\tb  backoff.BackOff\n}\n\nfunc (lb *lockedBackoff) NextBackOff() time.Duration {\n\tlb.mu.Lock()\n\tdefer lb.mu.Unlock()\n\n\treturn lb.b.NextBackOff()\n}\n\nfunc (lb *lockedBackoff) Reset() {\n\tlb.mu.Lock()\n\tdefer lb.mu.Unlock()\n\n\tlb.b.Reset()\n}\n"
        },
        {
          "name": "config",
          "type": "tree",
          "content": null
        },
        {
          "name": "dnode",
          "type": "tree",
          "content": null
        },
        {
          "name": "errors.go",
          "type": "blob",
          "size": 1.2158203125,
          "content": "package kite\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\n\t\"github.com/koding/kite/dnode\"\n)\n\n// ErrKeyNotTrusted is returned by verify functions when the key\n// should not be trusted.\nvar ErrKeyNotTrusted = errors.New(\"kontrol key is not trusted\")\n\n// Error is the type of the kite related errors returned from kite package.\ntype Error struct {\n\tType      string `json:\"type\"`\n\tMessage   string `json:\"message\"`\n\tCodeVal   string `json:\"code\"`\n\tRequestID string `json:\"id\"`\n}\n\nfunc (e Error) Code() string {\n\treturn e.CodeVal\n}\n\nfunc (e Error) Error() string {\n\ts := e.Message\n\n\tif e.Type != \"genericError\" && e.Type != \"\" {\n\t\ts = e.Type + \": \" + e.Message\n\t}\n\n\tif e.RequestID != \"\" {\n\t\treturn s + \" (\" + e.RequestID + \")\"\n\t}\n\n\treturn s\n}\n\n// createError creates a new kite.Error for the given r variable\nfunc createError(req *Request, r interface{}) *Error {\n\tif r == nil {\n\t\treturn nil\n\t}\n\n\tvar kiteErr *Error\n\tswitch err := r.(type) {\n\tcase *Error:\n\t\tkiteErr = err\n\tcase *dnode.ArgumentError:\n\t\tkiteErr = &Error{\n\t\t\tType:    \"argumentError\",\n\t\t\tMessage: err.Error(),\n\t\t}\n\tdefault:\n\t\tkiteErr = &Error{\n\t\t\tType:    \"genericError\",\n\t\t\tMessage: fmt.Sprint(r),\n\t\t}\n\t}\n\n\tif kiteErr.RequestID == \"\" && req != nil {\n\t\tkiteErr.RequestID = req.ID\n\t}\n\n\treturn kiteErr\n}\n"
        },
        {
          "name": "examples",
          "type": "tree",
          "content": null
        },
        {
          "name": "handlers.go",
          "type": "blob",
          "size": 4.333984375,
          "content": "package kite\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"net/http\"\n\t\"net/url\"\n\t\"os\"\n\t\"os/exec\"\n\t\"runtime\"\n\t\"time\"\n\n\t\"github.com/gorilla/websocket\"\n\t\"github.com/koding/cache\"\n\t\"github.com/koding/kite/protocol\"\n\t\"github.com/koding/kite/sockjsclient\"\n\t\"github.com/koding/kite/systeminfo\"\n\t\"golang.org/x/crypto/ssh/terminal\"\n)\n\nvar (\n\terrDstNotSet        = errors.New(\"dst not set\")\n\terrDstNotRegistered = errors.New(\"dst not registered\")\n)\n\n// WebRTCHandlerName provides the naming scheme for the handler\nconst WebRTCHandlerName = \"kite.handleWebRTC\"\n\ntype webRTCHandler struct {\n\tkitesColl cache.Cache\n}\n\n// NewWebRCTHandler creates a new handler for web rtc signalling services.\nfunc NewWebRCTHandler() *webRTCHandler {\n\treturn &webRTCHandler{\n\t\tkitesColl: cache.NewMemory(),\n\t}\n}\n\nfunc (w *webRTCHandler) registerSrc(src *Client) {\n\tw.kitesColl.Set(src.ID, src)\n\tsrc.OnDisconnect(func() {\n\t\ttime.Sleep(time.Second * 2)\n\t\tid := src.ID\n\t\t// delete from the collection\n\t\tw.kitesColl.Delete(id)\n\t})\n}\n\nfunc (w *webRTCHandler) getDst(dst string) (*Client, error) {\n\tif dst == \"\" {\n\t\treturn nil, errDstNotSet\n\t}\n\n\tdstKite, err := w.kitesColl.Get(dst)\n\tif err != nil {\n\t\treturn nil, errDstNotRegistered\n\t}\n\n\treturn dstKite.(*Client), nil\n}\n\n// ServeKite implements Hander interface.\nfunc (w *webRTCHandler) ServeKite(r *Request) (interface{}, error) {\n\tvar args protocol.WebRTCSignalMessage\n\n\tif err := r.Args.One().Unmarshal(&args); err != nil {\n\t\treturn nil, fmt.Errorf(\"invalid query: %s\", err)\n\t}\n\n\targs.Src = r.Client.ID\n\n\tw.registerSrc(r.Client)\n\n\tdst, err := w.getDst(args.Dst)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn nil, dst.SendWebRTCRequest(&args)\n}\n\nfunc (k *Kite) addDefaultHandlers() {\n\t// Default RPC methods\n\tk.HandleFunc(\"kite.systemInfo\", handleSystemInfo)\n\tk.HandleFunc(\"kite.heartbeat\", k.handleHeartbeat)\n\tk.HandleFunc(\"kite.ping\", handlePing).DisableAuthentication()\n\tk.HandleFunc(\"kite.tunnel\", handleTunnel)\n\tk.HandleFunc(\"kite.log\", k.handleLog)\n\tk.HandleFunc(\"kite.print\", handlePrint)\n\tk.HandleFunc(\"kite.prompt\", handlePrompt)\n\tk.HandleFunc(\"kite.getPass\", handleGetPass)\n\tif runtime.GOOS == \"darwin\" {\n\t\tk.HandleFunc(\"kite.notify\", handleNotifyDarwin)\n\t}\n\tif k.WebRTCHandler != nil {\n\t\tk.Handle(WebRTCHandlerName, k.WebRTCHandler)\n\t}\n}\n\n// handleSystemInfo returns info about the system (CPU, memory, disk...).\nfunc handleSystemInfo(r *Request) (interface{}, error) {\n\treturn systeminfo.New()\n}\n\n// handleLog prints a log message to stderr.\nfunc (k *Kite) handleLog(r *Request) (interface{}, error) {\n\tmsg, err := r.Args.One().String()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tk.Log.Info(\"%s: %s\", r.Client.Name, msg)\n\n\treturn nil, nil\n}\n\n//handlePing returns a simple \"pong\" string\nfunc handlePing(r *Request) (interface{}, error) {\n\treturn \"pong\", nil\n}\n\n// handlePrint prints a message to stdout.\nfunc handlePrint(r *Request) (interface{}, error) {\n\treturn fmt.Print(r.Args.One().MustString())\n}\n\n// handlePrompt asks user a single line input.\nfunc handlePrompt(r *Request) (interface{}, error) {\n\tfmt.Print(r.Args.One().MustString())\n\tvar s string\n\t_, err := fmt.Scanln(&s)\n\treturn s, err\n}\n\n// handleGetPass reads a line of input from a terminal without local echo.\nfunc handleGetPass(r *Request) (interface{}, error) {\n\tfmt.Print(r.Args.One().MustString())\n\tdata, err := terminal.ReadPassword(int(os.Stdin.Fd())) // stdin\n\tfmt.Println()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn string(data), nil\n}\n\n// handleNotifyDarwin displays a desktop notification on OS X.\nfunc handleNotifyDarwin(r *Request) (interface{}, error) {\n\targs := r.Args.MustSliceOfLength(3)\n\tcmd := exec.Command(\"osascript\", \"-e\", fmt.Sprintf(\"display notification \\\"%s\\\" with title \\\"%s\\\" subtitle \\\"%s\\\"\",\n\t\targs[1].MustString(), args[2].MustString(), args[0].MustString()))\n\treturn nil, cmd.Start()\n}\n\n// handleTunnel opens two websockets, one to proxy kite and one to itself,\n// then it copies the message between them.\nfunc handleTunnel(r *Request) (interface{}, error) {\n\tvar args struct {\n\t\tURL string\n\t}\n\tr.Args.One().MustUnmarshal(&args)\n\n\tparsed, err := url.Parse(args.URL)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\trequestHeader := http.Header{}\n\trequestHeader.Add(\"Origin\", \"http://\"+parsed.Host)\n\n\tremoteConn, _, err := websocket.DefaultDialer.Dial(parsed.String(), requestHeader)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tsession := sockjsclient.NewWebsocketSession(remoteConn)\n\n\tgo r.LocalKite.sockjsHandler(session)\n\treturn nil, nil\n}\n"
        },
        {
          "name": "heartbeat.go",
          "type": "blob",
          "size": 5.505859375,
          "content": "package kite\n\nimport (\n\t\"bytes\"\n\t\"encoding/json\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"net/url\"\n\t\"strings\"\n\t\"time\"\n\n\t\"github.com/cenkalti/backoff\"\n\t\"github.com/koding/kite/protocol\"\n)\n\ntype heartbeatReq struct {\n\tping     func() error\n\tinterval time.Duration\n}\n\nfunc newHeartbeatReq(r *Request) (*heartbeatReq, error) {\n\tif r.Args == nil {\n\t\treturn nil, errors.New(\"empty heartbeat request\")\n\t}\n\n\targs, err := r.Args.SliceOfLength(2)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\td, err := args[0].Float64()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tping, err := args[1].Function()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn &heartbeatReq{\n\t\tinterval: time.Duration(d) * time.Second,\n\t\tping: func() error {\n\t\t\treturn ping.Call()\n\t\t},\n\t}, nil\n}\n\nfunc (k *Kite) processHeartbeats() {\n\tvar (\n\t\tping func() error\n\t\tt    = time.NewTicker(time.Second) // dummy initial value\n\t)\n\n\tt.Stop()\n\n\tfor {\n\t\tselect {\n\t\tcase <-t.C:\n\t\t\tswitch err := ping(); err {\n\t\t\tcase nil:\n\t\t\tcase errRegisterAgain:\n\t\t\t\tt.Stop()\n\t\t\tdefault:\n\t\t\t\tk.Log.Error(\"%s\", err)\n\t\t\t}\n\t\tcase <-k.closeC:\n\t\t\tt.Stop()\n\t\t\treturn\n\t\tcase req := <-k.heartbeatC:\n\t\t\tt.Stop()\n\n\t\t\tif req == nil {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tt = time.NewTicker(req.interval)\n\t\t\tping = req.ping\n\t\t}\n\t}\n}\n\n// RegisterHTTPForever is just like RegisterHTTP however it first tries to\n// register forever until a response from kontrol is received. It's useful to\n// use it during app initializations. After the registration a reconnect is\n// automatically handled inside the RegisterHTTP method.\nfunc (k *Kite) RegisterHTTPForever(kiteURL *url.URL) {\n\t// Create the httpBackoffRegister that RegisterHTTPForever will\n\t// use to backoff repeated register attempts.\n\thttpRegisterBackOff := backoff.NewExponentialBackOff()\n\thttpRegisterBackOff.InitialInterval = 30 * time.Second\n\thttpRegisterBackOff.MaxInterval = 5 * time.Minute\n\thttpRegisterBackOff.Multiplier = 1.7\n\thttpRegisterBackOff.MaxElapsedTime = 0\n\n\tregister := func() error {\n\t\t_, err := k.RegisterHTTP(kiteURL)\n\t\tif err != nil {\n\t\t\tk.Log.Error(\"Cannot register to Kontrol: %s Will retry after %d seconds\",\n\t\t\t\terr,\n\t\t\t\thttpRegisterBackOff.NextBackOff()/time.Second)\n\t\t\treturn err\n\t\t}\n\n\t\treturn nil\n\t}\n\n\t// this will retry register forever\n\terr := backoff.Retry(register, httpRegisterBackOff)\n\tif err != nil {\n\t\tk.Log.Error(\"BackOff stopped retrying with Error '%s'\", err)\n\t}\n}\n\nfunc (k *Kite) getKontrolPath(path string) string {\n\theartbeatURL := k.Config.KontrolURL + \"/\" + path\n\tif strings.HasSuffix(k.Config.KontrolURL, \"/kite\") {\n\t\theartbeatURL = strings.TrimSuffix(k.Config.KontrolURL, \"/kite\") + \"/\" + path\n\t}\n\n\treturn heartbeatURL\n}\n\n// RegisterHTTP registers current Kite to Kontrol. After registration other Kites\n// can find it via GetKites() or WatchKites() method. It registers again if\n// connection to kontrol is lost.\nfunc (k *Kite) RegisterHTTP(kiteURL *url.URL) (*registerResult, error) {\n\tregisterURL := k.getKontrolPath(\"register\")\n\n\targs := protocol.RegisterArgs{\n\t\tURL:  kiteURL.String(),\n\t\tKite: k.Kite(),\n\t\tAuth: &protocol.Auth{\n\t\t\tType: \"kiteKey\",\n\t\t\tKey:  k.KiteKey(),\n\t\t},\n\t}\n\n\tdata, err := json.Marshal(&args)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tresp, err := k.Config.Client.Post(registerURL, \"application/json\", bytes.NewReader(data))\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer resp.Body.Close()\n\n\tvar rr protocol.RegisterResult\n\tif err := json.NewDecoder(resp.Body).Decode(&rr); err != nil {\n\t\treturn nil, err\n\t}\n\n\tif rr.Error != \"\" {\n\t\treturn nil, errors.New(rr.Error)\n\t}\n\n\tif rr.HeartbeatInterval == 0 {\n\t\treturn nil, errors.New(\"heartbeat interval cannot be zero\")\n\t}\n\n\tparsed, err := url.Parse(rr.URL)\n\tif err != nil {\n\t\tk.Log.Error(\"Cannot parse registered URL: %s\", err.Error())\n\t}\n\n\theartbeat := time.Duration(rr.HeartbeatInterval) * time.Second\n\n\tk.Log.Info(\"Registered (via HTTP) with URL: '%s' and HeartBeat interval: '%s'\",\n\t\trr.URL, heartbeat)\n\n\tgo k.sendHeartbeats(heartbeat, kiteURL)\n\n\tk.callOnRegisterHandlers(&rr)\n\n\treturn &registerResult{parsed}, nil\n}\n\nvar errRegisterAgain = errors.New(\"register again\")\n\nfunc (k *Kite) sendHeartbeats(interval time.Duration, kiteURL *url.URL) {\n\theartbeatURL := k.getKontrolPath(\"heartbeat\")\n\n\tk.Log.Debug(\"Starting to send heartbeat to: %s\", heartbeatURL)\n\n\tu, err := url.Parse(heartbeatURL)\n\tif err != nil {\n\t\tk.Log.Fatal(\"HeartbeatURL is malformed: %s\", err)\n\t}\n\n\tq := u.Query()\n\tq.Set(\"id\", k.Id)\n\tu.RawQuery = q.Encode()\n\n\theartbeatFunc := func() error {\n\t\tk.Log.Debug(\"Sending heartbeat to %s\", u)\n\n\t\tresp, err := k.Config.Client.Get(u.String())\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tdefer resp.Body.Close()\n\n\t\tif resp.StatusCode != http.StatusOK {\n\t\t\treturn fmt.Errorf(\"unexpected status code: %d\", resp.StatusCode)\n\t\t}\n\n\t\t// we are just receiving small size strings such as \"pong\",\n\t\t// \"registeragain\" so we limit the reader to read just that\n\t\tp, err := ioutil.ReadAll(io.LimitReader(resp.Body, 16))\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tp = bytes.TrimSpace(p)\n\n\t\tk.Log.Debug(\"Heartbeat response received %q\", p)\n\n\t\tswitch string(p) {\n\t\tcase \"pong\":\n\t\t\treturn nil\n\t\tcase \"registeragain\":\n\t\t\tk.Log.Info(\"Disconnected from Kontrol, going to register again\")\n\n\t\t\tgo func() {\n\t\t\t\tk.RegisterHTTPForever(kiteURL)\n\t\t\t}()\n\n\t\t\treturn errRegisterAgain\n\t\t}\n\n\t\treturn fmt.Errorf(\"malformed heartbeat response: %s\", p)\n\t}\n\n\tk.heartbeatC <- &heartbeatReq{\n\t\tping:     heartbeatFunc,\n\t\tinterval: interval,\n\t}\n}\n\n// handleHeartbeat pings the callback with the given interval seconds.\nfunc (k *Kite) handleHeartbeat(r *Request) (interface{}, error) {\n\treq, err := newHeartbeatReq(r)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tk.heartbeatC <- req\n\n\treturn nil, req.ping()\n}\n"
        },
        {
          "name": "kite.go",
          "type": "blob",
          "size": 14.1708984375,
          "content": "// Package kite is a library for creating micro-services.  Two main types\n// implemented by this package are Kite for creating a micro-service server\n// called \"Kite\" and Client for communicating with another kites.\npackage kite\n\nimport (\n\t\"bytes\"\n\t\"crypto/rsa\"\n\t\"crypto/tls\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"net/http\"\n\t\"net/url\"\n\t\"os\"\n\t\"strings\"\n\t\"sync\"\n\t\"time\"\n\n\t\"github.com/koding/kite/config\"\n\t\"github.com/koding/kite/kitekey\"\n\t\"github.com/koding/kite/protocol\"\n\n\tjwt \"github.com/dgrijalva/jwt-go\"\n\t\"github.com/gorilla/mux\"\n\t\"github.com/igm/sockjs-go/sockjs\"\n\t\"github.com/koding/cache\"\n\t\"github.com/koding/kite/sockjsclient\"\n\tuuid \"github.com/satori/go.uuid\"\n)\n\nvar hostname string\n\nfunc init() {\n\tvar err error\n\thostname, err = os.Hostname()\n\tif err != nil {\n\t\tpanic(fmt.Sprintf(\"kite: cannot get hostname: %s\", err.Error()))\n\t}\n\n\tjwt.TimeFunc = func() time.Time {\n\t\treturn time.Now().UTC()\n\t}\n}\n\n// Kite defines a single process that enables distributed service messaging\n// amongst the peers it is connected. A Kite process acts as a Client and as a\n// Server. That means it can receive request, process them, but it also can\n// make request to other kites.\n//\n// Do not use this struct directly. Use kite.New function, add your handlers\n// with HandleFunc mehtod, then call Run method to start the inbuilt server (or\n// pass it to any http.Handler compatible server)\ntype Kite struct {\n\tConfig *config.Config\n\n\t// Log logs with the given Logger interface\n\tLog Logger\n\n\t// SetLogLevel changes the level of the logger. Default is INFO.\n\tSetLogLevel func(Level)\n\n\t// Contains different functions for authenticating user from request.\n\t// Keys are the authentication types (options.auth.type).\n\tAuthenticators map[string]func(*Request) error\n\n\t// ClientFunc is used as the default value for kite.Client.ClientFunc.\n\t// If nil, a default ClientFunc will be used.\n\t//\n\t// Deprecated: Set Config.XHR field instead.\n\tClientFunc func(*sockjsclient.DialOptions) *http.Client\n\n\t// WebRTCHandler handles the webrtc responses coming from a signalling server.\n\tWebRTCHandler Handler\n\n\t// Handlers added with Kite.HandleFunc().\n\thandlers     map[string]*Method // method map for exported methods\n\tpreHandlers  []Handler          // a list of handlers that are executed before any handler\n\tpostHandlers []Handler          // a list of handlers that are executed after any handler\n\tfinalFuncs   []FinalFunc        // a list of funcs executed after any handler regardless of the error\n\n\t// MethodHandling defines how the kite is returning the response for\n\t// multiple handlers\n\tMethodHandling MethodHandling\n\n\t// HTTP muxer\n\tmuxer *mux.Router\n\n\t// kontrolclient is used to register to kontrol and query third party kites\n\t// from kontrol\n\tkontrol *kontrolClient\n\n\t// kontrolKey stores parsed Config.KontrolKey\n\tkontrolKey *rsa.PublicKey\n\n\t// configMu protects access to Config.{Kite,Kontrol}Key fields.\n\tconfigMu sync.RWMutex\n\n\t// verifyCache is used as a cache for verify method.\n\t//\n\t// The field is set by verifyInit method.\n\tverifyCache *cache.MemoryTTL\n\n\t// verifyFunc is a verify method used to verify auth keys.\n\t//\n\t// For more details see (config.Config).VerifyFunc.\n\t//\n\t// The field is set by verifyInit method.\n\tverifyFunc func(pub string) error\n\n\t// verifyAudienceFunc is used to verify the audience of an\n\t// an incoming JWT token.\n\t//\n\t// For more details see (config.Config).VerifyAudienceFunc.\n\t//\n\t// The field is set by verifyInit method.\n\tverifyAudienceFunc func(*protocol.Kite, string) error\n\n\t// verifyOnce ensures all verify* fields are set up only once.\n\tverifyOnce sync.Once\n\n\t// mu protects assigment to verifyCache\n\tmu sync.Mutex\n\n\t// Handlers to call when a new connection is received.\n\tonConnectHandlers []func(*Client)\n\n\t// Handlers to call before the first request of connected kite.\n\tonFirstRequestHandlers []func(*Client)\n\n\t// Handlers to call when a client has disconnected.\n\tonDisconnectHandlers []func(*Client)\n\n\t// onRegisterHandlers field holds callbacks invoked when Kite\n\t// registers successfully to Kontrol\n\tonRegisterHandlers []func(*protocol.RegisterResult)\n\n\t// handlersMu protects access to on*Handlers fields.\n\thandlersMu sync.RWMutex\n\n\t// heartbeatC is used to control kite's heartbeats; sending\n\t// a non-nil value on the channel makes heartbeat goroutine issue\n\t// new heartbeats; sending nil value stops heartbeats\n\theartbeatC chan *heartbeatReq\n\n\t// server fields, are initialized and used when\n\t// TODO: move them to their own struct, just like KontrolClient\n\tlistener  *gracefulListener\n\tTLSConfig *tls.Config\n\treadyC    chan bool // To signal when kite is ready to accept connections\n\tcloseC    chan bool // To signal when kite is closed with Close()\n\n\tname    string\n\tversion string\n\tId      string // Unique kite instance id\n}\n\n// New creates, initializes and then returns a new Kite instance.\n//\n// Version must be in 3-digit semantic form.\n//\n// Name is important that it's also used to be searched by others.\nfunc New(name, version string) *Kite {\n\treturn NewWithConfig(name, version, config.New())\n}\n\n// NewWithConfig builds a new kite value for the given configuration.\nfunc NewWithConfig(name, version string, cfg *config.Config) *Kite {\n\tif name == \"\" {\n\t\tpanic(\"kite: name cannot be empty\")\n\t}\n\n\tif digits := strings.Split(version, \".\"); len(digits) != 3 {\n\t\tpanic(\"kite: version must be 3-digits semantic version\")\n\t}\n\n\tkiteID := uuid.Must(uuid.NewV4())\n\n\tl, setlevel := newLogger(name)\n\n\tkClient := &kontrolClient{\n\t\treadyConnected:  make(chan struct{}),\n\t\treadyRegistered: make(chan struct{}),\n\t\tregisterChan:    make(chan *url.URL, 1),\n\t}\n\n\tk := &Kite{\n\t\tConfig:         cfg,\n\t\tLog:            l,\n\t\tSetLogLevel:    setlevel,\n\t\tAuthenticators: make(map[string]func(*Request) error),\n\t\thandlers:       make(map[string]*Method),\n\t\tkontrol:        kClient,\n\t\tname:           name,\n\t\tversion:        version,\n\t\tId:             kiteID.String(),\n\t\treadyC:         make(chan bool),\n\t\tcloseC:         make(chan bool),\n\t\theartbeatC:     make(chan *heartbeatReq, 1),\n\t\tmuxer:          mux.NewRouter(),\n\t}\n\n\tif cfg != nil && cfg.UseWebRTC {\n\t\tk.WebRTCHandler = NewWebRCTHandler()\n\t}\n\n\t// All sockjs communication is done through this endpoint..\n\tk.muxer.PathPrefix(\"/kite\").Handler(sockjs.NewHandler(\"/kite\", *cfg.SockJS, k.sockjsHandler))\n\n\t// Add useful debug logs\n\tk.OnConnect(func(c *Client) { k.Log.Debug(\"New session: %s\", c.session.ID()) })\n\tk.OnFirstRequest(func(c *Client) { k.Log.Debug(\"Session %q is identified as %q\", c.session.ID(), c.Kite) })\n\tk.OnDisconnect(func(c *Client) { k.Log.Debug(\"Kite has disconnected: %q\", c.Kite) })\n\tk.OnRegister(k.updateAuth)\n\n\t// Every kite should be able to authenticate the user from token.\n\t// Tokens are granted by Kontrol Kite.\n\tk.Authenticators[\"token\"] = k.AuthenticateFromToken\n\n\t// A kite accepts requests with the same username.\n\tk.Authenticators[\"kiteKey\"] = k.AuthenticateFromKiteKey\n\n\t// Register default methods and handlers.\n\tk.addDefaultHandlers()\n\n\tgo k.processHeartbeats()\n\n\treturn k\n}\n\n// Kite returns the definition of the kite.\nfunc (k *Kite) Kite() *protocol.Kite {\n\treturn &protocol.Kite{\n\t\tUsername:    k.Config.Username,\n\t\tEnvironment: k.Config.Environment,\n\t\tName:        k.name,\n\t\tVersion:     k.version,\n\t\tRegion:      k.Config.Region,\n\t\tHostname:    hostname,\n\t\tID:          k.Id,\n\t}\n}\n\n// KiteKey gives a kite key used to authenticate to kontrol and other kites.\nfunc (k *Kite) KiteKey() string {\n\tk.configMu.RLock()\n\tdefer k.configMu.RUnlock()\n\n\treturn k.Config.KiteKey\n}\n\n// KontrolKey gives a Kontrol's public key.\n//\n// The value is taken form kite key's kontrolKey claim.\nfunc (k *Kite) KontrolKey() *rsa.PublicKey {\n\tk.configMu.RLock()\n\tdefer k.configMu.RUnlock()\n\n\treturn k.kontrolKey\n}\n\n// HandleHTTP registers the HTTP handler for the given pattern into the\n// underlying HTTP muxer.\nfunc (k *Kite) HandleHTTP(pattern string, handler http.Handler) {\n\tk.muxer.Handle(pattern, handler)\n}\n\n// HandleHTTPFunc registers the HTTP handler for the given pattern into the\n// underlying HTTP muxer.\nfunc (k *Kite) HandleHTTPFunc(pattern string, handler func(http.ResponseWriter, *http.Request)) {\n\tk.muxer.HandleFunc(pattern, handler)\n}\n\n// ServeHTTP helps Kite to satisfy the http.Handler interface. So kite can be\n// used as a standard http server.\nfunc (k *Kite) ServeHTTP(w http.ResponseWriter, req *http.Request) {\n\tk.muxer.ServeHTTP(w, req)\n}\n\nfunc (k *Kite) sockjsHandler(session sockjs.Session) {\n\tdefer session.Close(3000, \"Go away!\")\n\n\t// This Client also handles the connected client.\n\t// Since both sides can send/receive messages the client code is reused here.\n\tc := k.NewClient(\"\")\n\tdefer c.Close()\n\n\tc.setSession(session)\n\tc.wg.Add(1)\n\tgo c.sendHub()\n\n\tk.callOnConnectHandlers(c)\n\tc.callOnConnectHandlers()\n\n\t// Run after methods are registered and delegate is set\n\tc.readLoop()\n\n\tc.callOnDisconnectHandlers()\n\tk.callOnDisconnectHandlers(c)\n}\n\n// OnConnect registers a callbacks which is called when a Kite connects\n// to the k Kite.\nfunc (k *Kite) OnConnect(handler func(*Client)) {\n\tk.handlersMu.Lock()\n\tk.onConnectHandlers = append(k.onConnectHandlers, handler)\n\tk.handlersMu.Unlock()\n}\n\n// OnFirstRequest registers a function to run when we receive first request\n// from other Kite.\nfunc (k *Kite) OnFirstRequest(handler func(*Client)) {\n\tk.handlersMu.Lock()\n\tk.onFirstRequestHandlers = append(k.onFirstRequestHandlers, handler)\n\tk.handlersMu.Unlock()\n}\n\n// OnDisconnect registers a function to run when a connected Kite is disconnected.\nfunc (k *Kite) OnDisconnect(handler func(*Client)) {\n\tk.handlersMu.Lock()\n\tk.onDisconnectHandlers = append(k.onDisconnectHandlers, handler)\n\tk.handlersMu.Unlock()\n}\n\n// OnRegister registers a callback which is called when a Kite registers\n// to a Kontrol.\nfunc (k *Kite) OnRegister(handler func(*protocol.RegisterResult)) {\n\tk.handlersMu.Lock()\n\tk.onRegisterHandlers = append(k.onRegisterHandlers, handler)\n\tk.handlersMu.Unlock()\n}\n\nfunc (k *Kite) callOnConnectHandlers(c *Client) {\n\tk.handlersMu.RLock()\n\tdefer k.handlersMu.RUnlock()\n\n\tfor _, handler := range k.onConnectHandlers {\n\t\tfunc() {\n\t\t\tdefer nopRecover()\n\t\t\thandler(c)\n\t\t}()\n\t}\n}\n\nfunc (k *Kite) callOnFirstRequestHandlers(c *Client) {\n\tk.handlersMu.RLock()\n\tdefer k.handlersMu.RUnlock()\n\n\tfor _, handler := range k.onFirstRequestHandlers {\n\t\tfunc() {\n\t\t\tdefer nopRecover()\n\t\t\thandler(c)\n\t\t}()\n\t}\n}\n\nfunc (k *Kite) callOnDisconnectHandlers(c *Client) {\n\tk.handlersMu.RLock()\n\tdefer k.handlersMu.RUnlock()\n\n\tfor _, handler := range k.onDisconnectHandlers {\n\t\tfunc() {\n\t\t\tdefer nopRecover()\n\t\t\thandler(c)\n\t\t}()\n\t}\n}\n\nfunc (k *Kite) callOnRegisterHandlers(r *protocol.RegisterResult) {\n\tk.handlersMu.RLock()\n\tdefer k.handlersMu.RUnlock()\n\n\tfor _, handler := range k.onRegisterHandlers {\n\t\tfunc() {\n\t\t\tdefer nopRecover()\n\t\t\thandler(r)\n\t\t}()\n\t}\n}\n\nfunc (k *Kite) updateAuth(reg *protocol.RegisterResult) {\n\tk.configMu.Lock()\n\tdefer k.configMu.Unlock()\n\n\tswitch {\n\tcase reg.KiteKey != \"\":\n\t\tk.Config.KiteKey = reg.KiteKey\n\n\t\tex := &kitekey.Extractor{\n\t\t\tClaims: &kitekey.KiteClaims{},\n\t\t}\n\n\t\tif _, err := jwt.ParseWithClaims(reg.KiteKey, ex.Claims, ex.Extract); err != nil {\n\t\t\tk.Log.Error(\"auth update: unable to extract kontrol key: %s\", err)\n\n\t\t\tbreak\n\t\t}\n\n\t\tif ex.Claims.KontrolKey != \"\" {\n\t\t\treg.PublicKey = ex.Claims.KontrolKey\n\t\t}\n\t}\n\n\t// we also received a new public key (means the old one was invalidated).\n\t// Use it now.\n\tif reg.PublicKey != \"\" {\n\t\tk.Config.KontrolKey = reg.PublicKey\n\n\t\tkey, err := jwt.ParseRSAPublicKeyFromPEM([]byte(reg.PublicKey))\n\t\tif err != nil {\n\t\t\tk.Log.Error(\"auth update: unable to update kontrol key: %s\", err)\n\n\t\t\treturn\n\t\t}\n\n\t\tk.kontrolKey = key\n\t}\n}\n\n// RSAKey returns the corresponding public key for the issuer of the token.\n// It is called by jwt-go package when validating the signature in the token.\nfunc (k *Kite) RSAKey(token *jwt.Token) (interface{}, error) {\n\tk.verifyOnce.Do(k.verifyInit)\n\n\tkontrolKey := k.KontrolKey()\n\n\tif kontrolKey == nil {\n\t\tpanic(\"kontrol key is not set in config\")\n\t}\n\n\tif _, ok := token.Method.(*jwt.SigningMethodRSA); !ok {\n\t\treturn nil, errors.New(\"invalid signing method\")\n\t}\n\n\tclaims, ok := token.Claims.(*kitekey.KiteClaims)\n\tif !ok {\n\t\treturn nil, errors.New(\"token does not have valid claims\")\n\t}\n\n\tif claims.Issuer != k.Config.KontrolUser {\n\t\treturn nil, fmt.Errorf(\"issuer is not trusted: %s\", claims.Issuer)\n\t}\n\n\treturn kontrolKey, nil\n}\n\n// ErrClose is returned by the Close function, when the argument passed\n// to it was a slice of kites.\ntype ErrClose struct {\n\t// Errs has always length of the slice passed to the Close function.\n\t// It contains at least one non-nil error.\n\tErrs []error\n}\n\n// Error implements the built-in error interface.\nfunc (err *ErrClose) Error() string {\n\tif len(err.Errs) == 1 {\n\t\treturn err.Errs[0].Error()\n\t}\n\n\tvar buf bytes.Buffer\n\n\tfmt.Fprintf(&buf, \"The following kites failed to close:\\n\\n\")\n\n\tfor i, e := range err.Errs {\n\t\tif e == nil {\n\t\t\tcontinue\n\t\t}\n\n\t\tfmt.Fprintf(&buf, \"\\t[%d] %s\\n\", i, e)\n\t}\n\n\treturn buf.String()\n}\n\n// Closer returns a io.Closer that can be used to close all the kites\n// given by the generic argument.\n//\n// The kites is expected to be one of:\n//\n//   - *kite.Kite\n//   - []*kite.Kite\n//   - *kite.Client\n//   - []*kite.Client\n//\n// If the kites argument is a slice and at least one of the kites returns\n// error on Close, the Close method returns *ErrClose.\n//\n// TODO(rjeczalik): Currently (*Kite).Close and (*Client).Close does\n// not implement io.Closer interface - when [0] is resolved, this\n// method should be adopted accordingly.\n//\n//   [0] - https://github.com/koding/kite/issues/183\n//\nfunc Closer(kites interface{}) io.Closer {\n\tswitch k := kites.(type) {\n\tcase *Kite:\n\t\treturn closerFunc(func() []error {\n\t\t\tk.Close()\n\t\t\treturn nil\n\t\t})\n\tcase []*Kite:\n\t\treturn closerFunc(func() []error {\n\t\t\tfor _, k := range k {\n\t\t\t\tk.Close()\n\t\t\t}\n\t\t\treturn nil\n\t\t})\n\tcase *Client:\n\t\treturn closerFunc(func() []error {\n\t\t\tk.Close()\n\t\t\treturn nil\n\t\t})\n\tcase []*Client:\n\t\treturn closerFunc(func() []error {\n\t\t\tfor _, c := range k {\n\t\t\t\tc.Close()\n\t\t\t}\n\t\t\treturn nil\n\t\t})\n\tdefault:\n\t\tpanic(fmt.Errorf(\"unrecognized type passed to Close %T\", kites))\n\t}\n}\n\n// Close is a wrapper for Closer that calls a Close on it.\nfunc Close(kites interface{}) error {\n\treturn Closer(kites).Close()\n}\n\ntype closerFunc func() []error\n\nfunc (fn closerFunc) Close() error {\n\terrs := fn()\n\tif len(errs) > 1 {\n\t\treturn &ErrClose{\n\t\t\tErrs: errs,\n\t\t}\n\t}\n\n\tif len(errs) == 1 && errs[0] != nil {\n\t\treturn errs[0]\n\t}\n\n\treturn nil\n}\n\nfunc nopRecover() { recover() }\n"
        },
        {
          "name": "kite_test.go",
          "type": "blob",
          "size": 11.5859375,
          "content": "package kite\n\nimport (\n\t\"errors\"\n\t\"flag\"\n\t\"fmt\"\n\t\"math\"\n\t\"math/rand\"\n\t\"os\"\n\t\"reflect\"\n\t\"strconv\"\n\t\"sync\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/koding/kite/config\"\n\t\"github.com/koding/kite/dnode\"\n\t\"github.com/koding/kite/protocol\"\n\t\"github.com/koding/kite/sockjsclient\"\n\t_ \"github.com/koding/kite/testutil\"\n\n\t\"github.com/igm/sockjs-go/sockjs\"\n)\n\nvar timeout = flag.Duration(\"telltime\", 4*time.Second, \"Timeout for kite calls.\")\n\nfunc init() {\n\trand.Seed(time.Now().Unix() + int64(os.Getpid()))\n}\n\nfunc panicHandler(*Client) {\n\tpanic(\"this panic should be ignored\")\n}\n\nfunc panicRegisterHandler(*protocol.RegisterResult) {\n\tpanic(\"this panic should be ignored\")\n}\n\nfunc transportFromEnv() config.Transport {\n\tenv := os.Getenv(\"KITE_TRANSPORT\")\n\ttr, ok := config.Transports[env]\n\tif env != \"\" && !ok {\n\t\tpanic(fmt.Errorf(\"transport %q doesn't exists\", env))\n\t}\n\treturn tr\n}\n\nfunc TestContext(t *testing.T) {\n\tflag.Parse()\n\n\tch := make(chan int, 4) // checkpoints, to ensure correct control flow\n\n\tk := New(\"server\", \"0.0.1\")\n\tk.Config.DisableAuthentication = true\n\tk.Config.Port = 3333\n\tk.Config.Transport = transportFromEnv()\n\tk.HandleFunc(\"longrunning\", func(r *Request) (interface{}, error) {\n\t\tch <- 2\n\n\t\tgo func() {\n\t\t\t<-r.Context.Done()\n\t\t\tch <- 4\n\t\t}()\n\t\treturn nil, nil\n\t})\n\tgo k.Run()\n\t<-k.ServerReadyNotify()\n\tdefer k.Close()\n\n\tc := New(\"client\", \"0.0.1\").NewClient(\"http://127.0.0.1:3333/kite\")\n\tif err := c.Dial(); err != nil {\n\t\tt.Fatalf(\"Dial()=%s\", err)\n\t}\n\n\tch <- 1\n\n\tif _, err := c.TellWithTimeout(\"longrunning\", *timeout); err != nil {\n\t\tt.Fatalf(\"TellWithTimeout()=%s\", err)\n\t}\n\n\tch <- 3\n\n\tc.Close()\n\n\tvar got []int\n\twant := []int{1, 2, 3, 4}\n\ttimeout := time.After(2 * time.Second)\n\n\tfor len(got) != len(want) {\n\t\tselect {\n\t\tcase i := <-ch:\n\t\t\tgot = append(got, i)\n\t\tcase <-timeout:\n\t\t\tt.Fatal(\"timed out collecting checkpoints\")\n\t\t}\n\t}\n\n\tif !reflect.DeepEqual(got, want) {\n\t\tt.Fatalf(\"got %v, want %v\", got, want)\n\t}\n}\n\nfunc TestMultiple(t *testing.T) {\n\ttestDuration := time.Second * 10\n\n\t// number of available mathworker kites to be called\n\tkiteNumber := 3\n\n\t// number of exp kites that will call mathwork kites\n\tclientNumber := 3\n\n\t// ports are starting from 6000 up to 6000 + kiteNumber\n\tport := 6000\n\n\ttransport := transportFromEnv()\n\n\tfor i := 0; i < kiteNumber; i++ {\n\t\tm := New(\"mathworker\"+strconv.Itoa(i), \"0.1.\"+strconv.Itoa(i))\n\t\tm.Config.DisableAuthentication = true\n\t\tm.Config.Transport = transport\n\t\tm.Config.Port = port + i\n\n\t\tm.OnConnect(panicHandler)\n\t\tm.OnRegister(panicRegisterHandler)\n\t\tm.OnDisconnect(panicHandler)\n\t\tm.OnFirstRequest(panicHandler)\n\n\t\tm.HandleFunc(\"square\", Square)\n\t\tgo m.Run()\n\t\t<-m.ServerReadyNotify()\n\t\tdefer m.Close()\n\t}\n\n\tclients := make([]*Client, clientNumber)\n\tfor i := 0; i < clientNumber; i++ {\n\t\tcn := New(\"exp\"+strconv.Itoa(i), \"0.0.1\")\n\t\tcn.Config.Transport = transport\n\n\t\tc := cn.NewClient(\"http://127.0.0.1:\" + strconv.Itoa(port+i) + \"/kite\")\n\t\tif err := c.Dial(); err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\n\t\tclients[i] = c\n\t\tdefer c.Close()\n\t}\n\n\ttimeout := time.After(testDuration)\n\n\t// every one second\n\tfor {\n\t\tselect {\n\t\tcase <-time.Tick(time.Second):\n\t\t\tvar wg sync.WaitGroup\n\n\t\t\tfor i := 0; i < clientNumber; i++ {\n\t\t\t\twg.Add(1)\n\n\t\t\t\tgo func(i int, t *testing.T) {\n\t\t\t\t\tdefer wg.Done()\n\t\t\t\t\ttime.Sleep(time.Millisecond * time.Duration(rand.Intn(500)))\n\n\t\t\t\t\t_, err := clients[i].TellWithTimeout(\"square\", 4*time.Second, 2)\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\tt.Error(err)\n\t\t\t\t\t}\n\t\t\t\t}(i, t)\n\t\t\t}\n\n\t\t\twg.Wait()\n\t\tcase <-timeout:\n\t\t\treturn\n\t\t}\n\t}\n}\n\nfunc TestSendError(t *testing.T) {\n\tconst timeout = 5 * time.Second\n\n\tksrv := newXhrKite(\"echo-server\", \"0.0.1\")\n\tksrv.Config.DisableAuthentication = true\n\tksrv.HandleFunc(\"echo\", func(r *Request) (interface{}, error) {\n\t\treturn r.Args.One().MustString(), nil\n\t})\n\n\tgo ksrv.Run()\n\t<-ksrv.ServerReadyNotify()\n\tdefer ksrv.Close()\n\n\tclientSession := make(chan sockjs.Session, 1)\n\n\tkcli := newXhrKite(\"echo-client\", \"0.0.1\")\n\tkcli.Config.DisableAuthentication = true\n\tc := kcli.NewClient(fmt.Sprintf(\"http://127.0.0.1:%d/kite\", ksrv.Port()))\n\tc.testHookSetSession = func(s sockjs.Session) {\n\t\tif _, ok := s.(*sockjsclient.XHRSession); ok {\n\t\t\tclientSession <- s\n\t\t}\n\t}\n\n\tif err := c.DialTimeout(timeout); err != nil {\n\t\tt.Fatalf(\"DialTimeout()=%s\", err)\n\t}\n\n\tselect {\n\tcase <-time.After(timeout):\n\t\tt.Fatal(\"timed out waiting for session\")\n\tcase c := <-clientSession:\n\t\tc.Close(500, \"transport closed\")\n\t}\n\n\tdone := make(chan error)\n\n\tgo func() {\n\t\t_, err := c.Tell(\"echo\", \"should fail\")\n\t\tdone <- err\n\t}()\n\n\tselect {\n\tcase err := <-done:\n\t\tif err == nil {\n\t\t\tt.Error(\"expected err != nil, was nil\")\n\t\t}\n\tcase <-time.After(timeout):\n\t\tt.Fatal(\"timed out waiting for send failure\")\n\t}\n}\n\n// Call a single method with multiple clients. This test is implemented to be\n// sure the method is calling back with in the same time and not timing out.\nfunc TestConcurrency(t *testing.T) {\n\t// Create a mathworker kite\n\tmathKite := newXhrKite(\"mathworker\", \"0.0.1\")\n\tmathKite.Config.DisableAuthentication = true\n\tmathKite.Config.Port = 3637\n\tmathKite.HandleFunc(\"ping\", func(r *Request) (interface{}, error) {\n\t\ttime.Sleep(time.Second)\n\t\treturn \"pong\", nil\n\t})\n\tgo mathKite.Run()\n\t<-mathKite.ServerReadyNotify()\n\tdefer mathKite.Close()\n\n\t// number of exp kites that will call mathworker kite\n\tclientNumber := 3\n\n\tclients := make([]*Client, clientNumber)\n\tfor i := range clients {\n\t\tc := newXhrKite(\"exp\", \"0.0.1\").NewClient(\"http://127.0.0.1:3637/kite\")\n\t\tif err := c.Dial(); err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\n\t\tclients[i] = c\n\t\tdefer c.Close()\n\t}\n\n\tvar wg sync.WaitGroup\n\n\tfor i := range clients {\n\t\twg.Add(1)\n\t\tgo func(i int) {\n\t\t\tdefer wg.Done()\n\t\t\tresult, err := clients[i].TellWithTimeout(\"ping\", 4*time.Second)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\n\t\t\tif result.MustString() != \"pong\" {\n\t\t\t\tt.Errorf(\"Got %s want: pong\", result.MustString())\n\t\t\t}\n\t\t}(i)\n\t}\n\n\twg.Wait()\n}\n\nfunc TestNoConcurrentCallbacks(t *testing.T) {\n\tconst timeout = 2 * time.Second\n\n\ttype Callback struct {\n\t\tIndex int\n\t\tFunc  dnode.Function\n\t}\n\n\tk := newXhrKite(\"callback\", \"0.0.1\")\n\tk.Config.DisableAuthentication = true\n\tk.HandleFunc(\"call\", func(r *Request) (interface{}, error) {\n\t\tif r.Args == nil {\n\t\t\treturn nil, errors.New(\"empty argument\")\n\t\t}\n\n\t\tvar arg Callback\n\t\tif err := r.Args.One().Unmarshal(&arg); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tif !arg.Func.IsValid() {\n\t\t\treturn nil, errors.New(\"invalid argument\")\n\t\t}\n\n\t\tif err := arg.Func.Call(arg.Index); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\treturn true, nil\n\t})\n\n\tgo k.Run()\n\t<-k.ServerReadyNotify()\n\tdefer k.Close()\n\n\turl := fmt.Sprintf(\"http://127.0.0.1:%d/kite\", k.Port())\n\n\tc := k.NewClient(url)\n\tdefer c.Close()\n\n\t// The TestNoConcurrentCallbacks asserts ConcurrentCallbacks\n\t// are disabled by default for each new client.\n\t//\n\t// When callbacks are executed concurrently, the order\n\t// of indices received on the channel is random,\n\t// thus making this test to fail.\n\t//\n\t// c.ConcurrentCallbacks = true\n\n\tif err := c.DialTimeout(timeout); err != nil {\n\t\tt.Errorf(\"DialTimeout(%q)=%s\", url, err)\n\t}\n\n\tindices := make(chan int, 50)\n\tcallback := dnode.Callback(func(arg *dnode.Partial) {\n\t\tvar index int\n\t\tif err := arg.One().Unmarshal(&index); err != nil {\n\t\t\tt.Logf(\"failed to unmarshal: %s\", err)\n\t\t}\n\n\t\ttime.Sleep(time.Duration(rand.Int31n(100)) * time.Millisecond)\n\n\t\tindices <- index\n\t})\n\n\tfor i := 0; i < cap(indices); i++ {\n\t\targ := &Callback{\n\t\t\tIndex: i + 1,\n\t\t\tFunc:  callback,\n\t\t}\n\n\t\tif _, err := c.TellWithTimeout(\"call\", timeout, arg); err != nil {\n\t\t\tt.Fatalf(\"%d: TellWithTimeout()=%s\", i, err)\n\t\t}\n\t}\n\n\tvar n, lastIndex int\n\n\tfor {\n\t\tif n == cap(indices) {\n\t\t\t// All indices were read.\n\t\t\tbreak\n\t\t}\n\n\t\tselect {\n\t\tcase <-time.After(timeout):\n\t\t\tt.Fatalf(\"reading indices has timed out after %s (n=%d)\", timeout, n)\n\t\tcase index := <-indices:\n\t\t\tif index == 0 {\n\t\t\t\tt.Fatalf(\"invalid index=%d (n=%d)\", index, n)\n\t\t\t}\n\n\t\t\tif index <= lastIndex {\n\t\t\t\tt.Fatalf(\"expected to receive indices in ascending order; received %d, last index %d (n=%d)\", index, lastIndex, n)\n\t\t\t}\n\n\t\t\tlastIndex = index\n\t\t\tn++\n\t\t}\n\t}\n}\n\n// Test 2 way communication between kites.\nfunc TestKite(t *testing.T) {\n\t// Create a mathworker kite\n\tmathKite := newXhrKite(\"mathworker\", \"0.0.1\")\n\tmathKite.Config.DisableAuthentication = true\n\tmathKite.Config.Port = 3636\n\tmathKite.HandleFunc(\"square\", Square)\n\tmathKite.HandleFunc(\"squareCB\", SquareCB)\n\tmathKite.HandleFunc(\"sleep\", Sleep)\n\tmathKite.HandleFunc(\"sqrt\", Sqrt)\n\tmathKite.FinalFunc(func(r *Request, resp interface{}, err error) (interface{}, error) {\n\t\tif r.Method != \"sqrt\" || err != ErrNegative {\n\t\t\treturn resp, err\n\t\t}\n\n\t\ta := r.Args.One().MustFloat64()\n\n\t\t// JSON does not marshal complex128,\n\t\t// for test purpose we use just string\n\t\treturn fmt.Sprintf(\"%di\", int(math.Sqrt(-a)+0.5)), nil\n\t})\n\tgo mathKite.Run()\n\t<-mathKite.ServerReadyNotify()\n\tdefer mathKite.Close()\n\n\t// Create exp2 kite\n\texp2Kite := newXhrKite(\"exp2\", \"0.0.1\")\n\tfooChan := make(chan string)\n\texp2Kite.HandleFunc(\"foo\", func(r *Request) (interface{}, error) {\n\t\ts := r.Args.One().MustString()\n\t\tt.Logf(\"Message received: %s\\n\", s)\n\t\tfooChan <- s\n\t\treturn nil, nil\n\t})\n\n\t// exp2 connects to mathworker\n\tremote := exp2Kite.NewClient(\"http://127.0.0.1:3636/kite\")\n\terr := remote.Dial()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer remote.Close()\n\n\tresult, err := remote.TellWithTimeout(\"sqrt\", 4*time.Second, -4)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tif s, err := result.String(); err != nil || s != \"2i\" {\n\t\tt.Fatalf(\"want 2i, got %v (%v)\", result, err)\n\t}\n\n\tresult, err = remote.TellWithTimeout(\"square\", 4*time.Second, 2)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tnumber := result.MustFloat64()\n\n\tt.Logf(\"rpc result: %f\\n\", number)\n\n\tif number != 4 {\n\t\tt.Fatalf(\"Invalid result: %f\", number)\n\t}\n\n\tselect {\n\tcase s := <-fooChan:\n\t\tif s != \"bar\" {\n\t\t\tt.Fatalf(\"Invalid message: %s\", s)\n\t\t}\n\tcase <-time.After(100 * time.Millisecond):\n\t\tt.Fatal(\"Did not get the message\")\n\t}\n\n\tresultChan := make(chan float64, 1)\n\tresultCallback := func(args *dnode.Partial) {\n\t\tn := args.One().MustFloat64()\n\t\tresultChan <- n\n\t}\n\n\tresult, err = remote.TellWithTimeout(\"squareCB\", 4*time.Second, 3, dnode.Callback(resultCallback))\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tselect {\n\tcase n := <-resultChan:\n\t\tif n != 9.0 {\n\t\t\tt.Fatalf(\"Unexpected result: %f\", n)\n\t\t}\n\tcase <-time.After(100 * time.Millisecond):\n\t\tt.Fatal(\"Did not get the message\")\n\t}\n\n\tresult, err = remote.TellWithTimeout(\"sleep\", time.Second)\n\tif err == nil {\n\t\tt.Fatal(\"Did get message in 1 seconds, however the sleep method takes 2 seconds to response\")\n\t}\n\n\tresult, err = remote.Tell(\"sleep\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tif !result.MustBool() {\n\t\tt.Fatal(\"sleep result must be true\")\n\t}\n\n}\n\n// Sleeps for 2 seconds and returns true\nfunc Sleep(r *Request) (interface{}, error) {\n\ttime.Sleep(time.Second * 2)\n\treturn true, nil\n}\n\n// Returns the result. Also tests reverse call.\nfunc Square(r *Request) (interface{}, error) {\n\ta := r.Args.One().MustFloat64()\n\tresult := a * a\n\n\tr.LocalKite.Log.Info(\"Kite call, sending result '%f' back\\n\", result)\n\n\t// Reverse method call\n\tr.Client.Go(\"foo\", \"bar\")\n\n\treturn result, nil\n}\n\nvar ErrNegative = errors.New(\"negative argument\")\n\nfunc Sqrt(r *Request) (interface{}, error) {\n\ta := r.Args.One().MustFloat64()\n\n\tif a < 0 {\n\t\treturn nil, ErrNegative\n\t}\n\n\treturn math.Sqrt(a), nil\n}\n\n// Calls the callback with the result. For testing requests with Callback.\nfunc SquareCB(r *Request) (interface{}, error) {\n\targs := r.Args.MustSliceOfLength(2)\n\ta := args[0].MustFloat64()\n\tcb := args[1].MustFunction()\n\n\tresult := a * a\n\n\tr.LocalKite.Log.Info(\"Kite call, sending result '%f' back\\n\", result)\n\n\t// Send the result.\n\terr := cb.Call(result)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn nil, nil\n}\n\nfunc newXhrKite(name, version string) *Kite {\n\tk := New(name, version)\n\tk.Config.Transport = config.XHRPolling\n\treturn k\n}\n"
        },
        {
          "name": "kitectl",
          "type": "tree",
          "content": null
        },
        {
          "name": "kitekey",
          "type": "tree",
          "content": null
        },
        {
          "name": "kitetest",
          "type": "tree",
          "content": null
        },
        {
          "name": "kontrol",
          "type": "tree",
          "content": null
        },
        {
          "name": "kontrolclient.go",
          "type": "blob",
          "size": 13.4150390625,
          "content": "// kontrolclient implements a kite.Client for interacting with Kontrol kite.\npackage kite\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"math/rand\"\n\t\"net/url\"\n\t\"os\"\n\t\"sync\"\n\t\"time\"\n\n\t\"github.com/koding/kite/dnode\"\n\t\"github.com/koding/kite/protocol\"\n)\n\nconst (\n\tkontrolRetryDuration = 10 * time.Second\n\tproxyRetryDuration   = 10 * time.Second\n)\n\n// Returned from GetKites when query matches no kites.\nvar ErrNoKitesAvailable = errors.New(\"no kites availabile\")\n\n// kontrolClient is a kite for registering and querying Kites from Kontrol.\ntype kontrolClient struct {\n\t*Client\n\tsync.Mutex // protects Client\n\n\t// used for synchronizing methods that needs to be called after\n\t// successful connection or/and registration to kontrol.\n\tonceConnected   sync.Once\n\tonceRegistered  sync.Once\n\treadyConnected  chan struct{}\n\treadyRegistered chan struct{}\n\n\t// lastRegisteredURL stores the Kite url what was send/registered\n\t// successfully to kontrol\n\tlastRegisteredURL *url.URL\n\n\t// registerChan registers the url's it receives from the channel to Kontrol\n\tregisterChan chan *url.URL\n}\n\ntype registerResult struct {\n\tURL *url.URL\n}\n\n// SetupKontrolClient setups and prepares a the kontrol instance. It connects\n// to kontrol and reconnects again if there is any disconnections. This method\n// is called internally whenever a kontrol client specific action is taking.\n// However if you wish to connect earlier you may call this method.\nfunc (k *Kite) SetupKontrolClient() error {\n\tif k.kontrol.Client != nil {\n\t\treturn nil // already prepared\n\t}\n\n\tif k.Config.KontrolURL == \"\" {\n\t\treturn errors.New(\"no kontrol URL given in config\")\n\t}\n\n\tclient := k.NewClient(k.Config.KontrolURL)\n\tclient.Kite = protocol.Kite{Name: \"kontrol\"} // for logging purposes\n\tclient.Auth = &Auth{\n\t\tType: \"kiteKey\",\n\t\tKey:  k.KiteKey(),\n\t}\n\n\tk.kontrol.Lock()\n\tk.kontrol.Client = client\n\tk.kontrol.Unlock()\n\n\tk.kontrol.OnConnect(func() {\n\t\tk.Log.Info(\"Connected to Kontrol\")\n\t\tk.Log.Debug(\"Connected to Kontrol with session %q\", client.session.ID())\n\n\t\t// try to re-register on connect\n\t\tk.kontrol.Lock()\n\t\tif k.kontrol.lastRegisteredURL != nil {\n\t\t\tselect {\n\t\t\tcase k.kontrol.registerChan <- k.kontrol.lastRegisteredURL:\n\t\t\tdefault:\n\t\t\t}\n\t\t}\n\t\tk.kontrol.Unlock()\n\n\t\t// signal all other methods that are listening on this channel, that we\n\t\t// are connected to kontrol.\n\t\tk.kontrol.onceConnected.Do(func() { close(k.kontrol.readyConnected) })\n\t})\n\n\tk.kontrol.OnDisconnect(func() {\n\t\tk.Log.Warning(\"Disconnected from Kontrol.\")\n\t})\n\n\t// non blocking, is going to reconnect if the connection goes down.\n\tif _, err := k.kontrol.DialForever(); err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\n// GetKites returns the list of Kites matching the query. The returned list\n// contains Ready to connect Client instances. The caller must connect\n// with Client.Dial() before using each Kite. An error is returned when no\n// kites are available.\n//\n// The returned clients have token renewer running, which is leaked\n// when a single *Client is not closed. A handy utility to ease closing\n// the clients is a Close function:\n//\n//   clients, err := k.GetKites(&protocol.KontrolQuery{Name: \"foo\"})\n//   if err != nil {\n//       panic(err)\n//   }\n//\n//   // If we want to only use the first result and discard the rest,\n//   // we need to close the rest explicitly.\n//   defer kite.Close(clients[1:])\n//\n//   return clients[0]\n//\nfunc (k *Kite) GetKites(query *protocol.KontrolQuery) ([]*Client, error) {\n\tif err := k.SetupKontrolClient(); err != nil {\n\t\treturn nil, err\n\t}\n\n\tclients, err := k.getKites(protocol.GetKitesArgs{Query: query})\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif len(clients) == 0 {\n\t\treturn nil, ErrNoKitesAvailable\n\t}\n\n\treturn clients, nil\n}\n\n// used internally for GetKites() and WatchKites()\nfunc (k *Kite) getKites(args protocol.GetKitesArgs) ([]*Client, error) {\n\t<-k.kontrol.readyConnected\n\n\tresponse, err := k.kontrol.TellWithTimeout(\"getKites\", k.Config.Timeout, args)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tvar result = new(protocol.GetKitesResult)\n\terr = response.Unmarshal(&result)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tclients := make([]*Client, len(result.Kites))\n\tfor i, currentKite := range result.Kites {\n\t\tauth := &Auth{\n\t\t\tType: \"token\",\n\t\t\tKey:  currentKite.Token,\n\t\t}\n\n\t\tclients[i] = k.NewClient(currentKite.URL)\n\t\tclients[i].Kite = currentKite.Kite\n\t\tclients[i].Auth = auth\n\t}\n\n\t// Renew tokens\n\tfor _, c := range clients {\n\t\ttoken, err := NewTokenRenewer(c, k)\n\t\tif err != nil {\n\t\t\tk.Log.Error(\"Error in token. Token will not be renewed when it expires: %s\", err)\n\t\t\tcontinue\n\t\t}\n\n\t\ttoken.RenewWhenExpires()\n\t\tc.closeRenewer = token.disconnect\n\t}\n\n\treturn clients, nil\n}\n\n// GetToken is used to get a token for a single Kite.\n//\n// In case of calling GetToken multiple times, it usually\n// returns the same token until it expires on Kontrol side.\nfunc (k *Kite) GetToken(kite *protocol.Kite) (string, error) {\n\tif err := k.SetupKontrolClient(); err != nil {\n\t\treturn \"\", err\n\t}\n\n\t<-k.kontrol.readyConnected\n\n\tresult, err := k.kontrol.TellWithTimeout(\"getToken\", k.Config.Timeout, kite)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\tvar tkn string\n\terr = result.Unmarshal(&tkn)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\treturn tkn, nil\n}\n\n// SendWebRTCRequest sends requests to kontrol for signalling purposes.\nfunc (k *Kite) SendWebRTCRequest(req *protocol.WebRTCSignalMessage) error {\n\tif err := k.SetupKontrolClient(); err != nil {\n\t\treturn err\n\t}\n\n\t<-k.kontrol.readyConnected\n\n\t_, err := k.kontrol.TellWithTimeout(WebRTCHandlerName, k.Config.Timeout, req)\n\treturn err\n}\n\n// GetTokenForce is used to obtain a new token for the given kite.\n//\n// It always returns a new token and forces a Kontrol to\n// forget about any previous ones.\nfunc (k *Kite) GetTokenForce(kite *protocol.Kite) (string, error) {\n\tif err := k.SetupKontrolClient(); err != nil {\n\t\treturn \"\", err\n\t}\n\n\t<-k.kontrol.readyConnected\n\n\targs := &protocol.GetTokenArgs{\n\t\tKontrolQuery: *kite.Query(),\n\t\tForce:        true,\n\t}\n\n\tresult, err := k.kontrol.TellWithTimeout(\"getToken\", k.Config.Timeout, args)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\tvar tkn string\n\terr = result.Unmarshal(&tkn)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\treturn tkn, nil\n}\n\n// GetKey is used to get a new public key from kontrol if the current one is\n// invalidated. The key is also replaced in memory and every request is going\n// to use it. This means even if kite.key contains the old key, the kite itself\n// uses the new one.\nfunc (k *Kite) GetKey() (string, error) {\n\tif err := k.SetupKontrolClient(); err != nil {\n\t\treturn \"\", err\n\t}\n\n\t<-k.kontrol.readyConnected\n\n\tresult, err := k.kontrol.TellWithTimeout(\"getKey\", k.Config.Timeout)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\tvar key string\n\terr = result.Unmarshal(&key)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\tk.configMu.Lock()\n\tk.Config.KontrolKey = key\n\tk.configMu.Unlock()\n\n\treturn key, nil\n}\n\n// NewKeyRenewer renews the internal key every given interval\nfunc (k *Kite) NewKeyRenewer(interval time.Duration) {\n\tticker := time.NewTicker(interval)\n\tfor range ticker.C {\n\t\t_, err := k.GetKey()\n\t\tif err != nil {\n\t\t\tk.Log.Warning(\"Key renew failed: %s\", err)\n\t\t}\n\t}\n}\n\n// KontrolReadyNotify returns a channel that is closed when a successful\n// registration to kontrol is done.\nfunc (k *Kite) KontrolReadyNotify() chan struct{} {\n\treturn k.kontrol.readyRegistered\n}\n\n// signalReady is an internal method to notify that a successful registration\n// is done.\nfunc (k *Kite) signalReady() {\n\tk.kontrol.onceRegistered.Do(func() { close(k.kontrol.readyRegistered) })\n}\n\n// RegisterForever is equivalent to Register(), but it tries to re-register if\n// there is a disconnection. The returned error is for the first register\n// attempt. It returns nil if ReadNotify() is ready and it's registered\n// successful.\nfunc (k *Kite) RegisterForever(kiteURL *url.URL) error {\n\terrs := make(chan error, 1)\n\tgo func() {\n\t\tfor u := range k.kontrol.registerChan {\n\t\t\t_, err := k.Register(u)\n\t\t\tif err == nil {\n\t\t\t\tk.kontrol.Lock()\n\t\t\t\tk.kontrol.lastRegisteredURL = u\n\t\t\t\tk.kontrol.Unlock()\n\t\t\t\tk.signalReady()\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tselect {\n\t\t\tcase errs <- err:\n\t\t\tdefault:\n\t\t\t}\n\n\t\t\tk.Log.Error(\"Cannot register to Kontrol: %s Will retry after %d seconds\",\n\t\t\t\terr, kontrolRetryDuration/time.Second)\n\n\t\t\ttime.AfterFunc(kontrolRetryDuration, func() {\n\t\t\t\tselect {\n\t\t\t\tcase k.kontrol.registerChan <- u:\n\t\t\t\tdefault:\n\t\t\t\t}\n\t\t\t})\n\t\t}\n\t}()\n\n\t// don't block if there the given url is nil\n\tif kiteURL == nil {\n\t\treturn nil\n\t}\n\n\t// initiate a registiration if a url is given\n\tk.kontrol.registerChan <- kiteURL\n\n\tselect {\n\tcase <-k.KontrolReadyNotify():\n\t\treturn nil\n\tcase err := <-errs:\n\t\treturn err\n\t}\n}\n\n// Register registers current Kite to Kontrol. After registration other Kites\n// can find it via GetKites() or WatchKites() method.  This method does not\n// handle the reconnection case. If you want to keep registered to kontrol, use\n// RegisterForever().\nfunc (k *Kite) Register(kiteURL *url.URL) (*registerResult, error) {\n\tif err := k.SetupKontrolClient(); err != nil {\n\t\treturn nil, err\n\t}\n\n\t<-k.kontrol.readyConnected\n\n\targs := protocol.RegisterArgs{\n\t\tURL: kiteURL.String(),\n\t}\n\n\tk.Log.Info(\"Registering to kontrol with URL: %s\", kiteURL.String())\n\n\tresponse, err := k.kontrol.TellWithTimeout(\"register\", k.Config.Timeout, args)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tvar rr protocol.RegisterResult\n\terr = response.Unmarshal(&rr)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tk.Log.Info(\"Registered to kontrol with URL: %s and Kite query: %s\",\n\t\trr.URL, k.Kite())\n\n\tparsed, err := url.Parse(rr.URL)\n\tif err != nil {\n\t\tk.Log.Error(\"Cannot parse registered URL: %s\", err)\n\t}\n\n\tk.callOnRegisterHandlers(&rr)\n\n\treturn &registerResult{parsed}, nil\n}\n\n// RegisterToTunnel finds a tunnel proxy kite by asking kontrol then registers\n// itself on proxy. On error, retries forever. On every successful\n// registration, it sends the proxied URL to the registerChan channel. There is\n// no register URL needed because the Tunnel Proxy automatically gets the IP\n// from tunneling. This is a blocking function.\nfunc (k *Kite) RegisterToTunnel() {\n\tquery := &protocol.KontrolQuery{\n\t\tUsername:    k.Config.KontrolUser,\n\t\tEnvironment: k.Config.Environment,\n\t\tName:        \"tunnelproxy\",\n\t}\n\n\tk.RegisterToProxy(nil, query)\n}\n\n// RegisterToProxy is just like RegisterForever but registers the given URL\n// to kontrol over a kite-proxy. A Kiteproxy is a reverseproxy that can be used\n// for SSL termination or handling hundreds of kites behind a single. This is a\n// blocking function.\nfunc (k *Kite) RegisterToProxy(registerURL *url.URL, query *protocol.KontrolQuery) {\n\tgo k.RegisterForever(nil)\n\n\tfor {\n\t\tvar proxyKite *Client\n\n\t\t// The proxy kite to connect can be overridden with the\n\t\t// environmental variable \"KITE_PROXY_URL\". If it is not set\n\t\t// we will ask Kontrol for available Proxy kites.\n\t\t// As an authentication informain kiteKey method will be used,\n\t\t// so be careful when using this feature.\n\t\tkiteProxyURL := os.Getenv(\"KITE_PROXY_URL\")\n\t\tif kiteProxyURL != \"\" {\n\t\t\tproxyKite = k.NewClient(kiteProxyURL)\n\t\t\tproxyKite.Auth = &Auth{\n\t\t\t\tType: \"kiteKey\",\n\t\t\t\tKey:  k.KiteKey(),\n\t\t\t}\n\t\t} else {\n\t\t\tkites, err := k.GetKites(query)\n\t\t\tif err != nil {\n\t\t\t\tk.Log.Error(\"Cannot get Proxy kites from Kontrol: %s\", err.Error())\n\t\t\t\ttime.Sleep(proxyRetryDuration)\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\t// If more than one one Proxy Kite is available pick one randomly.\n\t\t\t// It does not matter which one we connect.\n\t\t\tproxyKite = kites[rand.Int()%len(kites)]\n\t\t}\n\n\t\t// Notify us on disconnect\n\t\tdisconnect := make(chan bool, 1)\n\t\tproxyKite.OnDisconnect(func() {\n\t\t\tselect {\n\t\t\tcase disconnect <- true:\n\t\t\tdefault:\n\t\t\t}\n\t\t})\n\n\t\tproxyURL, err := k.registerToProxyKite(proxyKite, registerURL)\n\t\tif err != nil {\n\t\t\ttime.Sleep(proxyRetryDuration)\n\t\t\tcontinue\n\t\t}\n\n\t\tk.kontrol.registerChan <- proxyURL\n\n\t\t// Block until disconnect from Proxy Kite.\n\t\t<-disconnect\n\t}\n}\n\n// registerToProxyKite dials the proxy kite and calls register method then\n// returns the reverse-proxy URL.\nfunc (k *Kite) registerToProxyKite(c *Client, kiteURL *url.URL) (*url.URL, error) {\n\terr := c.Dial()\n\tif err != nil {\n\t\tk.Log.Error(\"Cannot connect to Proxy kite: %s\", err.Error())\n\t\treturn nil, err\n\t}\n\n\t// Disconnect from Proxy Kite if error happens while registering.\n\tdefer func() {\n\t\tif err != nil {\n\t\t\tc.Close()\n\t\t}\n\t}()\n\n\t// do not panic if we call Tell method below\n\tif kiteURL == nil {\n\t\tkiteURL = &url.URL{}\n\t}\n\n\t// this could be tunnelproxy or reverseproxy. Tunnelproxy doesn't need an\n\t// URL however Reverseproxy needs one.\n\tresult, err := c.TellWithTimeout(\"register\", k.Config.Timeout, kiteURL.String())\n\tif err != nil {\n\t\tk.Log.Error(\"Proxy register error: %s\", err.Error())\n\t\treturn nil, err\n\t}\n\n\tproxyURL, err := result.String()\n\tif err != nil {\n\t\tk.Log.Error(\"Proxy register result error: %s\", err.Error())\n\t\treturn nil, err\n\t}\n\n\tparsed, err := url.Parse(proxyURL)\n\tif err != nil {\n\t\tk.Log.Error(\"Cannot parse Proxy URL: %s\", err.Error())\n\t\treturn nil, err\n\t}\n\n\treturn parsed, nil\n}\n\n// TellKontrolWithTimeout is a lower level function for communicating directly with\n// kontrol. Like GetKites and GetToken, this automatically sets up and connects to\n// kontrol as needed.\nfunc (k *Kite) TellKontrolWithTimeout(method string, timeout time.Duration, args ...interface{}) (result *dnode.Partial, err error) {\n\tif err := k.SetupKontrolClient(); err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Wait for readyConnect, or timeout\n\tselect {\n\tcase <-time.After(k.Config.Timeout):\n\t\treturn nil, &Error{\n\t\t\tType: \"timeout\",\n\t\t\tMessage: fmt.Sprintf(\n\t\t\t\t\"Timed out registering to kontrol for %s method after %s\",\n\t\t\t\tmethod, k.Config.Timeout,\n\t\t\t),\n\t\t}\n\tcase <-k.kontrol.readyConnected:\n\t}\n\n\treturn k.kontrol.TellWithTimeout(method, timeout, args...)\n}\n"
        },
        {
          "name": "logger.go",
          "type": "blob",
          "size": 2.1025390625,
          "content": "package kite\n\nimport (\n\t\"os\"\n\t\"strings\"\n\n\t\"github.com/koding/logging\"\n)\n\ntype Level int\n\nvar debugMode bool\n\n// Logging levels.\nconst (\n\tFATAL Level = iota\n\tERROR\n\tWARNING\n\tINFO\n\tDEBUG\n)\n\n// Logger is the interface used to log messages in different levels.\ntype Logger interface {\n\t// Fatal logs to the FATAL, ERROR, WARNING, INFO and DEBUG levels,\n\t// including a stack trace of all running goroutines, then calls\n\t// os.Exit(1).\n\tFatal(format string, args ...interface{})\n\n\t// Error logs to the ERROR, WARNING, INFO and DEBUG level.\n\tError(format string, args ...interface{})\n\n\t// Warning logs to the WARNING, INFO and DEBUG level.\n\tWarning(format string, args ...interface{})\n\n\t// Info logs to the INFO and DEBUG level.\n\tInfo(format string, args ...interface{})\n\n\t// Debug logs to the DEBUG level.\n\tDebug(format string, args ...interface{})\n}\n\n// getLogLevel returns the logging level defined via the KITE_LOG_LEVEL\n// environment. It returns Info by default if no environment variable\n// is set.\nfunc getLogLevel() Level {\n\tswitch strings.ToUpper(os.Getenv(\"KITE_LOG_LEVEL\")) {\n\tcase \"DEBUG\":\n\t\treturn DEBUG\n\tcase \"WARNING\":\n\t\treturn WARNING\n\tcase \"ERROR\":\n\t\treturn ERROR\n\tcase \"FATAL\":\n\t\treturn FATAL\n\tdefault:\n\t\treturn INFO\n\t}\n}\n\n// convertLevel converts a kite level into logging level\nfunc convertLevel(l Level) logging.Level {\n\tswitch l {\n\tcase DEBUG:\n\t\treturn logging.DEBUG\n\tcase WARNING:\n\t\treturn logging.WARNING\n\tcase ERROR:\n\t\treturn logging.ERROR\n\tcase FATAL:\n\t\treturn logging.CRITICAL\n\tdefault:\n\t\treturn logging.INFO\n\t}\n}\n\n// newLogger returns a new kite logger based on koding/logging package and a\n// SetLogLvel function. The current logLevel is INFO by default, which can be\n// changed with KITE_LOG_LEVEL environment variable.\nfunc newLogger(name string) (Logger, func(Level)) {\n\tlogger := logging.NewLogger(name)\n\tlogger.SetLevel(convertLevel(getLogLevel()))\n\n\tif os.Getenv(\"KITE_LOG_NOCOLOR\") != \"\" {\n\t\tlogging.StdoutHandler.Colorize = false\n\t\tlogging.StderrHandler.Colorize = false\n\t}\n\n\tsetLevel := func(l Level) {\n\t\tlogger.SetLevel(convertLevel(l))\n\t\tlogging.DefaultHandler.SetLevel(convertLevel(l))\n\t}\n\n\treturn logger, setLevel\n}\n"
        },
        {
          "name": "logger_unix.go",
          "type": "blob",
          "size": 0.8681640625,
          "content": "// +build !windows\n\npackage kite\n\nimport (\n\t\"os\"\n\t\"os/signal\"\n\t\"syscall\"\n)\n\n// SetupSignalHandler listens to signals and toggles the log level to DEBUG\n// mode when it received a SIGUSR2 signal. Another SIGUSR2 toggles the log\n// level back to the old level.\nfunc (k *Kite) SetupSignalHandler() {\n\tc := make(chan os.Signal, 1)\n\n\tsignal.Notify(c, syscall.SIGUSR2)\n\tgo func() {\n\t\tfor s := range c {\n\t\t\tk.Log.Info(\"Got signal: %s\", s)\n\n\t\t\tif debugMode {\n\t\t\t\t// toogle back to old settings.\n\t\t\t\tk.Log.Info(\"Disabling debug mode\")\n\t\t\t\tif k.SetLogLevel == nil {\n\t\t\t\t\tk.Log.Error(\"SetLogLevel is not defined\")\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\n\t\t\t\tk.SetLogLevel(getLogLevel())\n\t\t\t\tdebugMode = false\n\t\t\t} else {\n\t\t\t\tk.Log.Info(\"Enabling debug mode\")\n\t\t\t\tif k.SetLogLevel == nil {\n\t\t\t\t\tk.Log.Error(\"SetLogLevel is not defined\")\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\n\t\t\t\tk.SetLogLevel(DEBUG)\n\t\t\t\tdebugMode = true\n\t\t\t}\n\t\t}\n\t}()\n}\n"
        },
        {
          "name": "method.go",
          "type": "blob",
          "size": 8.5146484375,
          "content": "package kite\n\nimport (\n\t\"sync\"\n\t\"time\"\n\n\t\"github.com/juju/ratelimit\"\n)\n\n// MethodHandling defines how to handle chaining of kite.Handler middlewares.\n// An error breaks the chain regardless of what handling is used. Note that all\n// Pre and Post handlers are executed regardless the handling logic, only the\n// return paramater is defined by the handling mode.\ntype MethodHandling int\n\nconst (\n\t// ReturnMethod returns main method's response. This is the standard default.\n\tReturnMethod MethodHandling = iota\n\n\t// ReturnFirst returns the first non-nil response.\n\tReturnFirst\n\n\t// ReturnLatest returns the latest response (waterfall behaviour)\n\tReturnLatest\n)\n\n// Objects implementing the Handler interface can be registered to a method.\n// The returned result must be marshalable with json package.\ntype Handler interface {\n\tServeKite(*Request) (result interface{}, err error)\n}\n\n// HandlerFunc is a type adapter to allow the use of ordinary functions as\n// Kite handlers. If h is a function with the appropriate signature,\n// HandlerFunc(h) is a Handler object that calls h.\ntype HandlerFunc func(*Request) (result interface{}, err error)\n\n// ServeKite calls h(r)\nfunc (h HandlerFunc) ServeKite(r *Request) (interface{}, error) {\n\treturn h(r)\n}\n\n// FinalFunc represents a proxy function that is called last\n// in the method call chain, regardless whether whole call\n// chained succeeded with non-nil error or not.\ntype FinalFunc func(r *Request, resp interface{}, err error) (interface{}, error)\n\n// Method defines a method and the Handler it is bind to. By default\n// \"ReturnMethod\" handling is used.\ntype Method struct {\n\t// name is the method name. Unnamed methods can exist\n\tname string\n\n\t// handler contains the related Handler for the given method\n\thandler      Handler     // handler is the base handler, the response of it is returned as the final\n\tpreHandlers  []Handler   // a list of handlers that are executed before the main handler\n\tpostHandlers []Handler   // a list of handlers that are executed after the main handler\n\tfinalFuncs   []FinalFunc // a list of final funcs executed upon returning from ServeKite\n\n\t// authenticate defines if a given authenticator function is enabled for\n\t// the given auth type in the request.\n\tauthenticate bool\n\n\t// handling defines how to handle chaining of kite.Handler middlewares.\n\thandling MethodHandling\n\n\t// initialized is used to indicate whether all pre and post handlers are\n\t// initialized.\n\tinitialized bool\n\n\t// bucket is used for throttling the method by certain rule\n\tbucket *ratelimit.Bucket\n\n\tmu sync.Mutex // protects handler slices\n}\n\n// addHandle is an internal method to add a handler\nfunc (k *Kite) addHandle(method string, handler Handler) *Method {\n\tauthenticate := true\n\tif k.Config.DisableAuthentication {\n\t\tauthenticate = false\n\t}\n\n\tm := &Method{\n\t\tname:         method,\n\t\thandler:      handler,\n\t\tauthenticate: authenticate,\n\t\thandling:     k.MethodHandling,\n\t}\n\n\tk.handlers[method] = m\n\treturn m\n}\n\n// DisableAuthentication disables authentication check for this method.\nfunc (m *Method) DisableAuthentication() *Method {\n\tm.authenticate = false\n\treturn m\n}\n\n// Throttle throttles the method for each incoming request. The throttle\n// algorithm is based on token bucket implementation:\n// http://en.wikipedia.org/wiki/Token_bucket. Rate determines the number of\n// request which are allowed per frequency. Example: A capacity of 50 and\n// fillInterval of two seconds means that initially it can handle 50 requests\n// and every two seconds the bucket will be filled with one token until it hits\n// the capacity. If there is a burst API calls, all tokens will be exhausted\n// and clients need to be wait until the bucket is filled with time.  For\n// example to have throttle with 30 req/second, you need to have a fillinterval\n// of 33.33 milliseconds.\nfunc (m *Method) Throttle(fillInterval time.Duration, capacity int64) *Method {\n\t// don't do anything if the bucket is initialized already\n\tif m.bucket != nil {\n\t\treturn m\n\t}\n\n\tm.bucket = ratelimit.NewBucket(\n\t\tfillInterval, // interval\n\t\tcapacity,     // token per interval\n\t)\n\n\treturn m\n}\n\n// PreHandler adds a new kite handler which is executed before the method.\nfunc (m *Method) PreHandle(handler Handler) *Method {\n\tm.preHandlers = append(m.preHandlers, handler)\n\treturn m\n}\n\n// PreHandlerFunc adds a new kite handlerfunc which is executed before the\n// method.\nfunc (m *Method) PreHandleFunc(handler HandlerFunc) *Method {\n\treturn m.PreHandle(handler)\n}\n\n// PostHandle adds a new kite handler which is executed after the method.\nfunc (m *Method) PostHandle(handler Handler) *Method {\n\tm.postHandlers = append(m.postHandlers, handler)\n\treturn m\n}\n\n// PostHandlerFunc adds a new kite handlerfunc which is executed before the\n// method.\nfunc (m *Method) PostHandleFunc(handler HandlerFunc) *Method {\n\treturn m.PostHandle(handler)\n}\n\n// FinalFunc registers a function that is always called as a last one\n// after pre-, handler and post- functions for the given method.\n//\n// It receives a result and an error from last handler that\n// got executed prior to calling final func.\nfunc (m *Method) FinalFunc(f FinalFunc) *Method {\n\tm.finalFuncs = append(m.finalFuncs, f)\n\treturn m\n}\n\n// Handle registers the handler for the given method. The handler is called\n// when a method call is received from a Kite.\nfunc (k *Kite) Handle(method string, handler Handler) *Method {\n\treturn k.addHandle(method, handler)\n}\n\n// HandleFunc registers a handler to run when a method call is received from a\n// Kite. It returns a *Method option to further modify certain options on a\n// method call\nfunc (k *Kite) HandleFunc(method string, handler HandlerFunc) *Method {\n\treturn k.addHandle(method, handler)\n}\n\n// PreHandle registers an handler which is executed before a kite.Handler\n// method is executed. Calling PreHandle multiple times registers multiple\n// handlers. A non-error return triggers the execution of the next handler. The\n// execution order is FIFO.\nfunc (k *Kite) PreHandle(handler Handler) {\n\tk.preHandlers = append(k.preHandlers, handler)\n}\n\n// PreHandleFunc is the same as PreHandle. It accepts a HandlerFunc.\nfunc (k *Kite) PreHandleFunc(handler HandlerFunc) {\n\tk.PreHandle(handler)\n}\n\n// PostHandle registers an handler which is executed after a kite.Handler\n// method is executed. Calling PostHandler multiple times registers multiple\n// handlers. A non-error return triggers the execution of the next handler. The\n// execution order is FIFO.\nfunc (k *Kite) PostHandle(handler Handler) {\n\tk.postHandlers = append(k.postHandlers, handler)\n}\n\n// PostHandleFunc is the same as PostHandle. It accepts a HandlerFunc.\nfunc (k *Kite) PostHandleFunc(handler HandlerFunc) {\n\tk.PostHandle(handler)\n}\n\n// FinalFunc registers a function that is always called as a last one\n// after pre-, handler and post- functions.\n//\n// It receives a result and an error from last handler that\n// got executed prior to calling final func.\nfunc (k *Kite) FinalFunc(f FinalFunc) {\n\tk.finalFuncs = append(k.finalFuncs, f)\n}\n\nfunc (m *Method) ServeKite(r *Request) (interface{}, error) {\n\tvar firstResp interface{}\n\tvar resp interface{}\n\tvar err error\n\n\t// first execute preHandlers. make a copy of the handler to avoid race\n\t// conditions\n\tm.mu.Lock()\n\tpreHandlers := make([]Handler, len(m.preHandlers))\n\tfor i, handler := range m.preHandlers {\n\t\tpreHandlers[i] = handler\n\n\t}\n\tm.mu.Unlock()\n\n\tfor _, handler := range preHandlers {\n\t\tresp, err = handler.ServeKite(r)\n\t\tif err != nil {\n\t\t\treturn m.final(r, nil, err)\n\t\t}\n\n\t\tif m.handling == ReturnFirst && resp != nil && firstResp == nil {\n\t\t\tfirstResp = resp\n\t\t}\n\t}\n\n\tpreHandlers = nil // garbage collect it\n\n\t// now call our base handler\n\tresp, err = m.handler.ServeKite(r)\n\tif err != nil {\n\t\treturn m.final(r, nil, err)\n\t}\n\n\t// also save it dependent on the handling mechanism\n\tmethodResp := resp\n\n\tif m.handling == ReturnFirst && resp != nil && firstResp == nil {\n\t\tfirstResp = resp\n\t}\n\n\t// and finally return our postHandlers\n\tm.mu.Lock()\n\tpostHandlers := make([]Handler, len(m.postHandlers))\n\tfor i, handler := range m.postHandlers {\n\t\tpostHandlers[i] = handler\n\t}\n\tm.mu.Unlock()\n\n\tfor _, handler := range postHandlers {\n\t\tresp, err = handler.ServeKite(r)\n\t\tif err != nil {\n\t\t\treturn m.final(r, nil, err)\n\t\t}\n\n\t\tif m.handling == ReturnFirst && resp != nil && firstResp == nil {\n\t\t\tfirstResp = resp\n\t\t}\n\t}\n\n\tpostHandlers = nil // garbage collect it\n\n\tswitch m.handling {\n\tcase ReturnMethod:\n\t\tresp = methodResp\n\tcase ReturnFirst:\n\t\tresp = firstResp\n\t}\n\n\treturn m.final(r, resp, nil)\n}\n\nfunc (m *Method) final(r *Request, resp interface{}, err error) (interface{}, error) {\n\tfor _, f := range m.finalFuncs {\n\t\tresp, err = f(r, resp, err)\n\t}\n\treturn resp, err\n}\n"
        },
        {
          "name": "method_test.go",
          "type": "blob",
          "size": 6.388671875,
          "content": "package kite\n\nimport (\n\t\"context\"\n\t\"errors\"\n\t\"strings\"\n\t\"testing\"\n\t\"time\"\n)\n\nfunc TestMethod_Throttling(t *testing.T) {\n\tk := New(\"testkite\", \"0.0.1\")\n\tk.Config.DisableAuthentication = true\n\tk.Config.Port = 9996\n\n\tk.HandleFunc(\"foo\", func(r *Request) (interface{}, error) {\n\t\treturn \"handle\", nil\n\t}).Throttle(time.Second*2, 30)\n\n\tgo k.Run()\n\tdefer k.Close()\n\t<-k.ServerReadyNotify()\n\n\tc := New(\"exp\", \"0.0.1\").NewClient(\"http://127.0.0.1:9996/kite\")\n\tif err := c.Dial(); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t// First let us exhaust the bucket\n\tfor i := 0; i < 20; i++ {\n\t\t_, err := c.TellWithTimeout(\"foo\", 4*time.Second)\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t}\n\n\t// now, the request 21 should give a requestLimitError\n\t_, err := c.TellWithTimeout(\"foo\", 4*time.Second)\n\tif err != nil {\n\t\tif kErr, ok := err.(*Error); ok {\n\t\t\tif kErr.Type != \"requestLimitError\" {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\t\t}\n\t}\n\n\t// now wait until the bucket is filled again\n\ttime.Sleep(time.Second * 2)\n\n\t// this shouldn't give any error at all\n\t_, err = c.TellWithTimeout(\"foo\", 4*time.Second)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n}\n\nfunc TestMethod_Latest(t *testing.T) {\n\tk := New(\"testkite\", \"0.0.1\")\n\tk.Config.DisableAuthentication = true\n\tk.Config.Port = 9997\n\n\tk.MethodHandling = ReturnLatest\n\n\tk.PreHandleFunc(func(r *Request) (interface{}, error) { return nil, nil })\n\tk.PreHandleFunc(func(r *Request) (interface{}, error) { return \"hello\", nil })\n\n\t// the following shouldn't do anything because the previous error breaks the chain\n\tk.HandleFunc(\"foo\", func(r *Request) (interface{}, error) {\n\t\treturn \"handle\", nil\n\t})\n\n\tk.PostHandleFunc(func(r *Request) (interface{}, error) { return \"post1\", nil })\n\tk.PostHandleFunc(func(r *Request) (interface{}, error) { return \"post2\", nil })\n\n\tgo k.Run()\n\tdefer k.Close()\n\t<-k.ServerReadyNotify()\n\n\tc := New(\"exp\", \"0.0.1\").NewClient(\"http://127.0.0.1:9997/kite\")\n\tif err := c.Dial(); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tresult, err := c.TellWithTimeout(\"foo\", 4*time.Second)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tif result.MustString() != \"post2\" {\n\t\tt.Errorf(\"Latest response should be post2, got %s\", result.MustString())\n\t}\n\n}\n\nfunc TestMethod_First(t *testing.T) {\n\tk := New(\"testkite\", \"0.0.1\")\n\n\tk.Config.DisableAuthentication = true\n\tk.Config.Port = 9998\n\n\tk.MethodHandling = ReturnFirst\n\n\tk.PreHandleFunc(func(r *Request) (interface{}, error) { return nil, nil })\n\tk.PreHandleFunc(func(r *Request) (interface{}, error) { return \"hello\", nil })\n\n\t// the following shouldn't do anything because the previous error breaks the chain\n\tk.HandleFunc(\"foo\", func(r *Request) (interface{}, error) {\n\t\treturn \"handle\", nil\n\t})\n\n\tk.PostHandleFunc(func(r *Request) (interface{}, error) { return \"post1\", nil })\n\tk.PostHandleFunc(func(r *Request) (interface{}, error) { return \"post2\", nil })\n\n\tgo k.Run()\n\tdefer k.Close()\n\t<-k.ServerReadyNotify()\n\n\tc := New(\"exp\", \"0.0.1\").NewClient(\"http://127.0.0.1:9998/kite\")\n\tif err := c.Dial(); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tresult, err := c.TellWithTimeout(\"foo\", 4*time.Second)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tif result.MustString() != \"hello\" {\n\t\tt.Errorf(\"Latest response should be hello, got %s\", result.MustString())\n\t}\n\n}\n\nfunc TestMethod_Error(t *testing.T) {\n\tk := New(\"testkite\", \"0.0.1\")\n\tk.Config.DisableAuthentication = true\n\tk.Config.Port = 9999\n\n\tvar testError = errors.New(\"an error\")\n\n\tk.PreHandleFunc(func(r *Request) (interface{}, error) { return nil, testError })\n\n\t// the following shouldn't do anything because the previous error breaks the chain\n\tk.HandleFunc(\"foo\", func(r *Request) (interface{}, error) {\n\t\treturn \"handle\", nil\n\t})\n\n\tk.PostHandleFunc(func(r *Request) (interface{}, error) { return \"post1\", nil })\n\tk.PostHandleFunc(func(r *Request) (interface{}, error) { return \"post2\", nil })\n\n\tgo k.Run()\n\tdefer k.Close()\n\t<-k.ServerReadyNotify()\n\n\tc := New(\"exp\", \"0.0.1\").NewClient(\"http://127.0.0.1:9999/kite\")\n\tif err := c.Dial(); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t_, err := c.TellWithTimeout(\"foo\", 4*time.Second)\n\tif err == nil {\n\t\tt.Fatal(\"PreHandle returns an error, however error is non-nil.\")\n\t}\n\n\tif !strings.HasPrefix(err.Error(), testError.Error()) {\n\t\tt.Errorf(\"Error should be '%v', got '%v'\", testError, err)\n\t}\n}\n\nfunc TestMethod_Base(t *testing.T) {\n\tk := New(\"testkite\", \"0.0.1\")\n\tk.Config.DisableAuthentication = true\n\tk.Config.Port = 10000\n\n\tk.PreHandleFunc(func(r *Request) (interface{}, error) {\n\t\tr.Context = context.WithValue(r.Context, \"pre1\", \"pre1\")\n\t\treturn nil, nil\n\t})\n\n\tk.PreHandleFunc(func(r *Request) (interface{}, error) {\n\t\tres, _ := r.Context.Value(\"pre1\").(string)\n\t\tif res != \"pre1\" {\n\t\t\tt.Errorf(\"Context response from previous pre handler should be pre1, got: %v\", res)\n\t\t}\n\n\t\tr.Context = context.WithValue(r.Context, \"pre2\", \"pre2\")\n\t\treturn nil, nil\n\t})\n\n\tk.HandleFunc(\"foo\", func(r *Request) (interface{}, error) {\n\t\tres, _ := r.Context.Value(\"funcPre1\").(string)\n\t\tif res != \"funcPre1\" {\n\t\t\tt.Errorf(\"Context response from previous pre handler should be funcPre1, got: %v\", res)\n\t\t}\n\n\t\tr.Context = context.WithValue(r.Context, \"handle\", \"handle\")\n\t\treturn \"main-response\", nil\n\t}).PreHandleFunc(func(r *Request) (interface{}, error) {\n\t\tr.Context = context.WithValue(r.Context, \"funcPre1\", \"funcPre1\")\n\t\treturn \"funcPre1\", nil\n\t}).PostHandleFunc(func(r *Request) (interface{}, error) {\n\t\tres, _ := r.Context.Value(\"handle\").(string)\n\t\tif res != \"handle\" {\n\t\t\tt.Errorf(\"Context response from previous pre handler should be handle, got: %v\", res)\n\t\t}\n\n\t\tr.Context = context.WithValue(r.Context, \"funcPost1\", \"funcPost1\")\n\t\treturn \"funcPost1\", nil\n\t})\n\n\tk.PostHandleFunc(func(r *Request) (interface{}, error) {\n\t\tres, _ := r.Context.Value(\"funcPost1\").(string)\n\t\tif res != \"funcPost1\" {\n\t\t\tt.Errorf(\"Context response from previous pre handler should be funcPost1, got: %v\", res)\n\t\t}\n\n\t\tr.Context = context.WithValue(r.Context, \"post1\", \"post1\")\n\t\treturn \"post1\", nil\n\t})\n\n\tk.PostHandleFunc(func(r *Request) (interface{}, error) {\n\t\tres, _ := r.Context.Value(\"post1\").(string)\n\t\tif res != \"post1\" {\n\t\t\tt.Errorf(\"Context response from previous pre handler should be post1, got: %v\", res)\n\t\t}\n\n\t\treturn \"post2\", nil\n\t})\n\n\tgo k.Run()\n\tdefer k.Close()\n\t<-k.ServerReadyNotify()\n\n\tc := New(\"exp\", \"0.0.1\").NewClient(\"http://127.0.0.1:10000/kite\")\n\tif err := c.Dial(); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tresult, err := c.TellWithTimeout(\"foo\", 4*time.Second)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tif result.MustString() != \"main-response\" {\n\t\tt.Errorf(\"Latest response should be main-response, got %s\", result.MustString())\n\t}\n\n}\n"
        },
        {
          "name": "postgres.d",
          "type": "tree",
          "content": null
        },
        {
          "name": "protocol",
          "type": "tree",
          "content": null
        },
        {
          "name": "registerurl.go",
          "type": "blob",
          "size": 1.9365234375,
          "content": "package kite\n\nimport (\n\t\"bytes\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"io/ioutil\"\n\t\"net\"\n\t\"net/http\"\n\t\"net/url\"\n\t\"strconv\"\n)\n\nconst publicEcho = \"http://echoip.com\"\n\n// RegisterURL returns a URL that is either local or public. It's an helper\n// method to get a Registration URL that can be passed to Kontrol (via the\n// methods Register(), RegisterToProxy(), etc.) It needs to be called after all\n// configurations are done (like TLS, Port,etc.). If local is true a local IP\n// is used, otherwise a public IP is being used.\nfunc (k *Kite) RegisterURL(local bool) *url.URL {\n\tvar ip net.IP\n\tvar err error\n\n\tif local {\n\t\tip, err = localIP()\n\t\tif err != nil {\n\t\t\treturn nil\n\t\t}\n\t} else {\n\t\tip, err = publicIP()\n\t\tif err != nil {\n\t\t\treturn nil\n\t\t}\n\t}\n\n\tscheme := \"http\"\n\tif k.TLSConfig != nil {\n\t\tscheme = \"https\"\n\t}\n\n\treturn &url.URL{\n\t\tScheme: scheme,\n\t\tHost:   ip.String() + \":\" + strconv.Itoa(k.Config.Port),\n\t\tPath:   \"/\" + k.name + \"-\" + k.version + \"/kite\",\n\t}\n}\n\n// localIp returns a local IP from one of the local interfaces.\nfunc localIP() (net.IP, error) {\n\ttt, err := net.Interfaces()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tfor _, t := range tt {\n\t\taa, err := t.Addrs()\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tfor _, a := range aa {\n\t\t\tipnet, ok := a.(*net.IPNet)\n\t\t\tif !ok {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tv4 := ipnet.IP.To4()\n\n\t\t\tif v4 == nil || v4[0] == 127 { // loopback address\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\treturn v4, nil\n\t\t}\n\t}\n\n\treturn nil, errors.New(\"cannot find local IP address\")\n}\n\n// publicIP returns an IP that is supposed to be Public.\nfunc publicIP() (net.IP, error) {\n\tresp, err := http.Get(publicEcho)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer resp.Body.Close()\n\n\t// The ip address is 16 chars long, we read more\n\t// to account for excessive whitespace.\n\tp, err := ioutil.ReadAll(io.LimitReader(resp.Body, 24))\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tn := net.ParseIP(string(bytes.TrimSpace(p)))\n\tif n == nil {\n\t\treturn nil, fmt.Errorf(\"cannot parse ip %s\", p)\n\t}\n\n\treturn n, nil\n}\n"
        },
        {
          "name": "request.go",
          "type": "blob",
          "size": 11.2275390625,
          "content": "package kite\n\nimport (\n\t\"context\"\n\t\"errors\"\n\t\"fmt\"\n\t\"runtime/debug\"\n\t\"time\"\n\n\t\"github.com/dgrijalva/jwt-go\"\n\t\"github.com/koding/cache\"\n\t\"github.com/koding/kite/dnode\"\n\t\"github.com/koding/kite/kitekey\"\n\t\"github.com/koding/kite/protocol\"\n\t\"github.com/koding/kite/sockjsclient\"\n\t\"github.com/koding/kite/utils\"\n)\n\n// Request contains information about the incoming request.\ntype Request struct {\n\t// ID is an unique string, which may be used for tracing the request.\n\tID string\n\n\t// Method defines the method name which is invoked by the incoming request.\n\tMethod string\n\n\t// Username defines the username which the incoming request is bound to.\n\t// This is authenticated and validated if authentication is enabled.\n\tUsername string\n\n\t// Args defines the incoming arguments for the given method.\n\tArgs *dnode.Partial\n\n\t// LocalKite defines a context for the local kite.\n\tLocalKite *Kite\n\n\t// Client defines a context for the remote kite.\n\tClient *Client\n\n\t// Auth stores the authentication information for the incoming request and\n\t// the type of authentication. This is not used when authentication is disabled.\n\tAuth *Auth\n\n\t// Context holds a context that used by the current ServeKite handler. Any\n\t// items added to the Context can be fetched from other handlers in the\n\t// chain. This is useful with PreHandle and PostHandle handlers to pass\n\t// data between handlers.\n\t//\n\t// The context is canceled when client has disconnected or session\n\t// was prematurely terminated.\n\tContext context.Context\n}\n\n// Response is the type of the object that is returned from request handlers\n// and the type of only argument that is passed to callback functions.\ntype Response struct {\n\tError  *Error      `json:\"error\" dnode:\"-\"`\n\tResult interface{} `json:\"result\"`\n}\n\n// runMethod is called when a method is received from remote Kite.\nfunc (c *Client) runMethod(method *Method, args *dnode.Partial) {\n\tvar (\n\t\tcallFunc func(interface{}, *Error)\n\t\trequest  *Request\n\t)\n\n\t// Recover dnode argument errors and send them back. The caller can use\n\t// functions like MustString(), MustSlice()... without the fear of panic.\n\tdefer func() {\n\t\tif r := recover(); r != nil {\n\t\t\tdebug.PrintStack()\n\t\t\tkiteErr := createError(request, r)\n\t\t\tc.LocalKite.Log.Error(kiteErr.Error()) // let's log it too :)\n\t\t\tcallFunc(nil, kiteErr)\n\t\t}\n\t}()\n\n\t// The request that will be constructed from incoming dnode message.\n\trequest, callFunc = c.newRequest(method.name, args)\n\tif method.authenticate {\n\t\tif err := request.authenticate(); err != nil {\n\t\t\tcallFunc(nil, createError(request, err))\n\t\t\treturn\n\t\t}\n\t} else {\n\t\t// if not validated accept any username it sends, also useful for test\n\t\t// cases.\n\t\trequest.Username = request.Client.Kite.Username\n\t}\n\n\tmethod.mu.Lock()\n\tif !method.initialized {\n\t\tmethod.preHandlers = append(method.preHandlers, c.LocalKite.preHandlers...)\n\t\tmethod.postHandlers = append(method.postHandlers, c.LocalKite.postHandlers...)\n\t\tmethod.finalFuncs = append(method.finalFuncs, c.LocalKite.finalFuncs...)\n\t\tmethod.initialized = true\n\t}\n\tmethod.mu.Unlock()\n\n\t// check if any throttling is enabled and then check token's available.\n\t// Tokens are filled per frequency of the initial bucket, so every request\n\t// is going to take one token from the bucket. If many requests come in (in\n\t// span time larger than the bucket's frequency), there will be no token's\n\t// available more so it will return a zero.\n\tif method.bucket != nil && method.bucket.TakeAvailable(1) == 0 {\n\t\tcallFunc(nil, &Error{\n\t\t\tType:      \"requestLimitError\",\n\t\t\tMessage:   \"The maximum request rate is exceeded.\",\n\t\t\tRequestID: request.ID,\n\t\t})\n\t\treturn\n\t}\n\n\t// Call the handler functions.\n\tresult, err := method.ServeKite(request)\n\n\tcallFunc(result, createError(request, err))\n}\n\n// runCallback is called when a callback method call is received from remote Kite.\nfunc (c *Client) runCallback(callback func(*dnode.Partial), args *dnode.Partial) {\n\t// Do not panic no matter what.\n\tdefer func() {\n\t\tif err := recover(); err != nil {\n\t\t\tc.LocalKite.Log.Warning(\"Error in calling the callback function : %v\", err)\n\t\t}\n\t}()\n\n\t// Call the callback function.\n\tcallback(args)\n}\n\n// newRequest returns a new *Request from the method and arguments passed.\nfunc (c *Client) newRequest(method string, args *dnode.Partial) (*Request, func(interface{}, *Error)) {\n\t// Parse dnode method arguments: [options]\n\tvar options callOptions\n\targs.One().MustUnmarshal(&options)\n\n\t// Notify the handlers registered with Kite.OnFirstRequest().\n\tif _, ok := c.session.(*sockjsclient.WebsocketSession); !ok {\n\t\tc.firstRequestHandlersNotified.Do(func() {\n\t\t\tc.m.Lock()\n\t\t\tc.Kite = options.Kite\n\t\t\tc.m.Unlock()\n\t\t\tc.LocalKite.callOnFirstRequestHandlers(c)\n\t\t})\n\t}\n\n\trequest := &Request{\n\t\tID:        utils.RandomString(16),\n\t\tMethod:    method,\n\t\tArgs:      options.WithArgs,\n\t\tLocalKite: c.LocalKite,\n\t\tClient:    c,\n\t\tAuth:      options.Auth,\n\t\tContext:   c.context(),\n\t}\n\n\t// Call response callback function, send back our response\n\tcallFunc := func(result interface{}, err *Error) {\n\t\tif options.ResponseCallback.Caller == nil {\n\t\t\treturn\n\t\t}\n\n\t\t// Only argument to the callback.\n\t\tresponse := Response{\n\t\t\tResult: result,\n\t\t\tError:  err,\n\t\t}\n\n\t\tif err := options.ResponseCallback.Call(response); err != nil {\n\t\t\tc.LocalKite.Log.Error(err.Error())\n\t\t}\n\t}\n\n\treturn request, callFunc\n}\n\n// authenticate tries to authenticate the user by selecting appropriate\n// authenticator function.\nfunc (r *Request) authenticate() *Error {\n\t// Trust the Kite if we have initiated the connection.  Following casts\n\t// means, session is opened by the client.\n\tif _, ok := r.Client.session.(*sockjsclient.WebsocketSession); ok {\n\t\treturn nil\n\t}\n\n\tif _, ok := r.Client.session.(*sockjsclient.XHRSession); ok {\n\t\treturn nil\n\t}\n\n\tif r.Auth == nil {\n\t\treturn &Error{\n\t\t\tType:    \"authenticationError\",\n\t\t\tMessage: \"No authentication information is provided\",\n\t\t}\n\t}\n\n\t// Select authenticator function.\n\tf := r.LocalKite.Authenticators[r.Auth.Type]\n\tif f == nil {\n\t\treturn &Error{\n\t\t\tType:    \"authenticationError\",\n\t\t\tMessage: fmt.Sprintf(\"Unknown authentication type: %s\", r.Auth.Type),\n\t\t}\n\t}\n\n\t// Call authenticator function. It sets the Request.Username field.\n\terr := f(r)\n\tif err != nil {\n\t\treturn &Error{\n\t\t\tType:    \"authenticationError\",\n\t\t\tMessage: fmt.Sprintf(\"%s: %s\", r.Auth.Type, err),\n\t\t}\n\t}\n\n\t// Replace username of the remote Kite with the username that client send\n\t// us. This prevents a Kite to impersonate someone else's Kite.\n\tr.Client.SetUsername(r.Username)\n\treturn nil\n}\n\n// AuthenticateFromToken is the default Authenticator for Kite.\nfunc (k *Kite) AuthenticateFromToken(r *Request) error {\n\tk.verifyOnce.Do(k.verifyInit)\n\n\ttoken, err := jwt.ParseWithClaims(r.Auth.Key, &kitekey.KiteClaims{}, r.LocalKite.RSAKey)\n\n\tif e, ok := err.(*jwt.ValidationError); ok {\n\t\t// Translate public key mismatch errors to token-is-expired one.\n\t\t// This is to signal remote client the key pairs have been\n\t\t// updated on kontrol and it should invalidate all tokens.\n\t\tif (e.Errors & jwt.ValidationErrorSignatureInvalid) != 0 {\n\t\t\treturn errors.New(\"token is expired\")\n\t\t}\n\t}\n\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif !token.Valid {\n\t\treturn errors.New(\"Invalid signature in token\")\n\t}\n\n\tclaims, ok := token.Claims.(*kitekey.KiteClaims)\n\tif !ok {\n\t\treturn errors.New(\"token does not have valid claims\")\n\t}\n\n\tif claims.Audience == \"\" {\n\t\treturn errors.New(\"token has no audience\")\n\t}\n\n\tif claims.Subject == \"\" {\n\t\treturn errors.New(\"token has no username\")\n\t}\n\n\t// check if we have an audience and it matches our own signature\n\tif err := k.verifyAudienceFunc(k.Kite(), claims.Audience); err != nil {\n\t\treturn err\n\t}\n\n\t// We don't check for exp and nbf claims here because jwt-go package\n\t// already checks them.\n\n\t// replace the requester username so we reflect the validated\n\tr.Username = claims.Subject\n\n\treturn nil\n}\n\n// AuthenticateFromKiteKey authenticates user from kite key.\nfunc (k *Kite) AuthenticateFromKiteKey(r *Request) error {\n\tclaims := &kitekey.KiteClaims{}\n\n\ttoken, err := jwt.ParseWithClaims(r.Auth.Key, claims, k.verify)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif !token.Valid {\n\t\treturn errors.New(\"Invalid signature in kite key\")\n\t}\n\n\tif claims.Subject == \"\" {\n\t\treturn errors.New(\"token has no username\")\n\t}\n\n\tr.Username = claims.Subject\n\n\treturn nil\n}\n\n// AuthenticateSimpleKiteKey authenticates user from the given kite key and\n// returns the authenticated username. It's the same as AuthenticateFromKiteKey\n// but can be used without the need for a *kite.Request.\nfunc (k *Kite) AuthenticateSimpleKiteKey(key string) (string, error) {\n\tclaims := &kitekey.KiteClaims{}\n\n\ttoken, err := jwt.ParseWithClaims(key, claims, k.verify)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\tif !token.Valid {\n\t\treturn \"\", errors.New(\"Invalid signature in token\")\n\t}\n\n\tif claims.Subject == \"\" {\n\t\treturn \"\", errors.New(\"token has no username\")\n\t}\n\n\treturn claims.Subject, nil\n}\n\nfunc (k *Kite) verifyInit() {\n\tk.configMu.Lock()\n\tdefer k.configMu.Unlock()\n\n\tk.verifyFunc = k.Config.VerifyFunc\n\n\tif k.verifyFunc == nil {\n\t\tk.verifyFunc = k.selfVerify\n\t}\n\n\tk.verifyAudienceFunc = k.Config.VerifyAudienceFunc\n\n\tif k.verifyAudienceFunc == nil {\n\t\tk.verifyAudienceFunc = k.verifyAudience\n\t}\n\n\tttl := k.Config.VerifyTTL\n\n\tif ttl == 0 {\n\t\tttl = 5 * time.Minute\n\t}\n\n\tif ttl > 0 {\n\t\tk.mu.Lock()\n\t\tk.verifyCache = cache.NewMemoryWithTTL(ttl)\n\t\tk.mu.Unlock()\n\n\t\tk.verifyCache.StartGC(ttl / 2)\n\t}\n\n\tkey, err := jwt.ParseRSAPublicKeyFromPEM([]byte(k.Config.KontrolKey))\n\tif err != nil {\n\t\tk.Log.Error(\"unable to init kontrol key: %s\", err)\n\n\t\treturn\n\t}\n\n\tk.kontrolKey = key\n}\n\nfunc (k *Kite) selfVerify(pub string) error {\n\tk.configMu.RLock()\n\tourKey := k.Config.KontrolKey\n\tk.configMu.RUnlock()\n\n\tif pub != ourKey {\n\t\treturn ErrKeyNotTrusted\n\t}\n\n\treturn nil\n}\n\nfunc (k *Kite) verify(token *jwt.Token) (interface{}, error) {\n\tk.verifyOnce.Do(k.verifyInit)\n\n\tkey := token.Claims.(*kitekey.KiteClaims).KontrolKey\n\tif key == \"\" {\n\t\treturn nil, errors.New(\"no kontrol key found\")\n\t}\n\n\trsaKey, err := jwt.ParseRSAPublicKeyFromPEM([]byte(key))\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tswitch {\n\tcase k.verifyCache != nil:\n\t\tv, err := k.verifyCache.Get(key)\n\t\tif err != nil {\n\t\t\tbreak\n\t\t}\n\n\t\tif !v.(bool) {\n\t\t\treturn nil, errors.New(\"invalid kontrol key found\")\n\t\t}\n\n\t\treturn rsaKey, nil\n\t}\n\n\tif err := k.verifyFunc(key); err != nil {\n\t\tif err == ErrKeyNotTrusted {\n\t\t\tk.verifyCache.Set(key, false)\n\t\t}\n\n\t\t// signal old token to somewhere else (GetKiteKey and alike)\n\n\t\treturn nil, err\n\t}\n\n\tk.verifyCache.Set(key, true)\n\n\treturn rsaKey, nil\n}\n\nfunc (k *Kite) verifyAudience(kite *protocol.Kite, audience string) error {\n\tswitch audience {\n\tcase \"/\":\n\t\t// The root audience is like superuser - it has access to everything.\n\t\treturn nil\n\tcase \"\":\n\t\treturn errors.New(\"invalid empty audience\")\n\t}\n\n\taud, err := protocol.KiteFromString(audience)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"invalid audience: %s (%s)\", err, audience)\n\t}\n\n\t// We verify the Username / Environment / Name matches the kite.\n\t// Empty field (except username) is like wildcard - it matches all values.\n\n\tif kite.Username != aud.Username {\n\t\treturn fmt.Errorf(\"audience: username %q not allowed (%s)\", aud.Username, audience)\n\t}\n\n\tif kite.Environment != aud.Environment && aud.Environment != \"\" {\n\t\treturn fmt.Errorf(\"audience: environment %q not allowed (%s)\", aud.Environment, audience)\n\t}\n\n\tif kite.Name != aud.Name && aud.Name != \"\" {\n\t\treturn fmt.Errorf(\"audience: kite %q not allowed (%s)\", aud.Name, audience)\n\t}\n\n\treturn nil\n}\n"
        },
        {
          "name": "reverseproxy",
          "type": "tree",
          "content": null
        },
        {
          "name": "server.go",
          "type": "blob",
          "size": 4.52734375,
          "content": "// Package server implements a HTTP(S) server for kites.\npackage kite\n\nimport (\n\t\"crypto/tls\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"net\"\n\t\"net/http\"\n\t\"os\"\n\t\"strconv\"\n\t\"strings\"\n\t\"sync\"\n)\n\n// Run is a blocking method. It runs the kite server and then accepts requests\n// asynchronously. It supports graceful restart via SIGUSR2.\nfunc (k *Kite) Run() {\n\tif os.Getenv(\"KITE_VERSION\") != \"\" {\n\t\tfmt.Println(k.Kite().Version)\n\t\tos.Exit(0)\n\t}\n\n\t// An error string equivalent to net.errClosing for using with http.Serve()\n\t// during a graceful exit. Needed to declare here again because it is not\n\t// exported by \"net\" package.\n\tconst errClosing = \"use of closed network connection\"\n\n\terr := k.listenAndServe()\n\tif err != nil {\n\t\tif strings.Contains(err.Error(), errClosing) {\n\t\t\t// The server is closed by Close() method\n\t\t\tk.Log.Info(\"Kite server is closed.\")\n\t\t\treturn\n\t\t}\n\t\tk.Log.Fatal(err.Error())\n\t}\n}\n\n// Close stops the server and the kontrol client instance.\nfunc (k *Kite) Close() {\n\tk.Log.Info(\"Closing kite...\")\n\n\tk.kontrol.Lock()\n\tif k.kontrol != nil && k.kontrol.Client != nil {\n\t\tk.kontrol.Close()\n\t}\n\tk.kontrol.Unlock()\n\n\tif k.listener != nil {\n\t\tk.listener.Close()\n\t\tk.listener = nil\n\t}\n\n\tk.mu.Lock()\n\tcache := k.verifyCache\n\tk.mu.Unlock()\n\n\tif cache != nil {\n\t\tcache.StopGC()\n\t}\n}\n\nfunc (k *Kite) Addr() string {\n\treturn net.JoinHostPort(k.Config.IP, strconv.Itoa(k.Config.Port))\n}\n\n// listenAndServe listens on the TCP network address k.URL.Host and then\n// calls Serve to handle requests on incoming connectionk.\nfunc (k *Kite) listenAndServe() error {\n\t// create a new one if there doesn't exist\n\tl, err := net.Listen(\"tcp4\", k.Addr())\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tk.Log.Info(\"New listening: %s\", l.Addr())\n\n\tif k.TLSConfig != nil {\n\t\tif k.TLSConfig.NextProtos == nil {\n\t\t\tk.TLSConfig.NextProtos = []string{\"http/1.1\"}\n\t\t}\n\t\tl = tls.NewListener(l, k.TLSConfig)\n\t}\n\n\tk.listener = newGracefulListener(l)\n\n\t// listener is ready, notify waiters.\n\tclose(k.readyC)\n\n\tdefer close(k.closeC) // serving is finished, notify waiters.\n\tk.Log.Info(\"Serving...\")\n\n\treturn k.serve(k.listener, k)\n}\n\nfunc (k *Kite) serve(l net.Listener, h http.Handler) error {\n\tif k.Config.Serve != nil {\n\t\treturn k.Config.Serve(l, h)\n\t}\n\treturn http.Serve(l, h)\n}\n\n// Port returns the TCP port number that the kite listens.\n// Port must be called after the listener is initialized.\n// You can use ServerReadyNotify function to get notified when listener is ready.\n//\n// Kite starts to listen the port when Run() is called.\n// Since Run() is blocking you need to run it as a goroutine the call this function when listener is ready.\n//\n// Example:\n//\n//   k := kite.New(\"x\", \"1.0.0\")\n//   go k.Run()\n//   <-k.ServerReadyNotify()\n//   port := k.Port()\n//\nfunc (k *Kite) Port() int {\n\tif k.listener == nil {\n\t\treturn 0\n\t}\n\n\treturn k.listener.Addr().(*net.TCPAddr).Port\n}\n\nfunc (k *Kite) UseTLS(certPEM, keyPEM string) {\n\tif k.TLSConfig == nil {\n\t\tk.TLSConfig = &tls.Config{}\n\t}\n\n\tcert, err := tls.X509KeyPair([]byte(certPEM), []byte(keyPEM))\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\tk.TLSConfig.Certificates = append(k.TLSConfig.Certificates, cert)\n}\n\nfunc (k *Kite) UseTLSFile(certFile, keyFile string) {\n\tcertData, err := ioutil.ReadFile(certFile)\n\tif err != nil {\n\t\tk.Log.Fatal(\"Cannot read certificate file: %s\", err.Error())\n\t}\n\n\tkeyData, err := ioutil.ReadFile(keyFile)\n\tif err != nil {\n\t\tk.Log.Fatal(\"Cannot read certificate file: %s\", err.Error())\n\t}\n\n\tk.UseTLS(string(certData), string(keyData))\n}\n\nfunc (k *Kite) ServerCloseNotify() chan bool {\n\treturn k.closeC\n}\n\nfunc (k *Kite) ServerReadyNotify() chan bool {\n\treturn k.readyC\n}\n\n// gracefulListener closes all accepted connections upon Close to ensure\n// no dangling websocket/xhr sessions outlive the kite.\ntype gracefulListener struct {\n\tnet.Listener\n\n\tconns   map[net.Conn]struct{}\n\tconnsMu sync.Mutex\n}\n\nfunc newGracefulListener(l net.Listener) *gracefulListener {\n\treturn &gracefulListener{\n\t\tListener: l,\n\t\tconns:    make(map[net.Conn]struct{}),\n\t}\n}\n\nfunc (l *gracefulListener) Accept() (net.Conn, error) {\n\tconn, err := l.Listener.Accept()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tl.connsMu.Lock()\n\tl.conns[conn] = struct{}{}\n\tl.connsMu.Unlock()\n\n\treturn &gracefulConn{\n\t\tConn: conn,\n\t\tclose: func() {\n\t\t\tl.connsMu.Lock()\n\t\t\tdelete(l.conns, conn)\n\t\t\tl.connsMu.Unlock()\n\t\t},\n\t}, nil\n}\n\nfunc (l *gracefulListener) Close() error {\n\terr := l.Listener.Close()\n\n\tl.connsMu.Lock()\n\tfor conn := range l.conns {\n\t\tconn.Close()\n\t}\n\tl.conns = nil\n\tl.connsMu.Unlock()\n\n\treturn err\n}\n\ntype gracefulConn struct {\n\tnet.Conn\n\n\tclose func()\n}\n\nfunc (c *gracefulConn) Close() error {\n\tc.close()\n\n\treturn c.Conn.Close()\n}\n"
        },
        {
          "name": "sockjsclient",
          "type": "tree",
          "content": null
        },
        {
          "name": "systeminfo",
          "type": "tree",
          "content": null
        },
        {
          "name": "test",
          "type": "tree",
          "content": null
        },
        {
          "name": "testkeys",
          "type": "tree",
          "content": null
        },
        {
          "name": "testutil",
          "type": "tree",
          "content": null
        },
        {
          "name": "tokenrenewer.go",
          "type": "blob",
          "size": 4.4404296875,
          "content": "package kite\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\t\"sync\"\n\t\"time\"\n\n\tjwt \"github.com/dgrijalva/jwt-go\"\n\t\"github.com/koding/kite/kitekey\"\n\t\"github.com/koding/kite/protocol\"\n)\n\nconst (\n\trenewBefore   = 30 * time.Second\n\tretryInterval = 10 * time.Second\n)\n\n// TokenRenewer renews the token of a Client just before it expires.\ntype TokenRenewer struct {\n\tclient           *Client\n\tlocalKite        *Kite\n\tvalidUntil       time.Time\n\tsignalRenewToken chan struct{}\n\tdisconnect       chan struct{}\n\tonce             sync.Once // for c.installHandlers\n\trenewLoopWG      sync.WaitGroup\n}\n\nfunc NewTokenRenewer(r *Client, k *Kite) (*TokenRenewer, error) {\n\tt := &TokenRenewer{\n\t\tclient:           r,\n\t\tlocalKite:        k,\n\t\tsignalRenewToken: make(chan struct{}),\n\t\tdisconnect:       make(chan struct{}),\n\t}\n\treturn t, t.parse(r.Auth.Key)\n}\n\n// parse the token string and set\nfunc (t *TokenRenewer) parse(tokenString string) error {\n\tclaims := &kitekey.KiteClaims{}\n\n\t_, err := jwt.ParseWithClaims(tokenString, claims, t.localKite.RSAKey)\n\tif err != nil {\n\t\tvalErr, ok := err.(*jwt.ValidationError)\n\t\tif !ok {\n\t\t\treturn err\n\t\t}\n\n\t\t// do noy return for ValidationErrorSignatureValid. This is because we\n\t\t// might asked for a kite who's public Key is different what we have.\n\t\t// We still should be able to send them requests.\n\t\tif (valErr.Errors & jwt.ValidationErrorSignatureInvalid) == 0 {\n\t\t\treturn fmt.Errorf(\"Cannot parse token: %s\", err)\n\t\t}\n\t}\n\n\tt.validUntil = time.Unix(claims.ExpiresAt, 0).UTC()\n\treturn nil\n}\n\n// RenewWhenExpires renews the token before it expires.\nfunc (t *TokenRenewer) RenewWhenExpires() {\n\tt.once.Do(t.installHandlers)\n}\n\nfunc (t *TokenRenewer) installHandlers() {\n\tt.client.OnConnect(t.startRenewLoop)\n\tt.client.OnTokenExpire(t.sendRenewTokenSignal)\n\tt.client.OnDisconnect(t.sendDisconnectSignal)\n}\n\nfunc (t *TokenRenewer) renewLoop() {\n\tt.renewLoopWG.Add(1)\n\tdefer t.renewLoopWG.Done()\n\n\t// renews token before it expires (sends the first signal to the goroutine below)\n\tgo time.AfterFunc(t.renewDuration(), t.sendRenewTokenSignal)\n\n\t// renew token on signal util remote kite disconnects.\n\tfor {\n\t\tselect {\n\t\tcase <-t.signalRenewToken:\n\t\t\tswitch err := t.renewToken(); {\n\t\t\tcase err == nil:\n\t\t\t\tgo time.AfterFunc(t.renewDuration(), t.sendRenewTokenSignal)\n\t\t\tcase err == ErrNoKitesAvailable || strings.Contains(err.Error(), \"no kites found\"):\n\t\t\t\t// If kite went down we're not going to renew the token,\n\t\t\t\t// as we need to dial either way.\n\t\t\t\t//\n\t\t\t\t// This case handles a situation, when kite missed\n\t\t\t\t// disconnect signal (observed to happen with XHR transport).\n\t\t\tdefault:\n\t\t\t\tt.localKite.Log.Error(\"token renewer: %s Cannot renew token for Kite: %s I will retry in %d seconds...\",\n\t\t\t\t\terr, t.client.ID, retryInterval/time.Second)\n\t\t\t\t// Need to sleep here litle bit because a signal is sent\n\t\t\t\t// when an expired token is detected on incoming request.\n\t\t\t\t// This sleep prevents the signal from coming too fast.\n\t\t\t\ttime.Sleep(1 * time.Second)\n\t\t\t\tgo time.AfterFunc(retryInterval, t.sendRenewTokenSignal)\n\t\t\t}\n\t\tcase <-t.disconnect:\n\t\t\treturn\n\t\t}\n\t}\n}\n\n// The duration from now to the time token needs to be renewed.\n// Needs to be calculated after renewing the token.\nfunc (t *TokenRenewer) renewDuration() time.Duration {\n\treturn t.validUntil.Add(-renewBefore).Sub(time.Now().UTC())\n}\n\nfunc (t *TokenRenewer) startRenewLoop() {\n\t// In case when t.client missed a disconnect signal (e.g. due to timeout observed\n\t// by the remote end), previous renewLoop will be still running.\n\tt.sendDisconnectSignal()\n\n\t// if we don't wait to observe previous renewLoop goroutine handle the disconnect\n\t// signal, we'd have a race resulting in new renewLoop goroutine handling it.\n\tt.renewLoopWG.Wait()\n\n\tgo t.renewLoop()\n}\n\nfunc (t *TokenRenewer) sendRenewTokenSignal() {\n\t// Needs to be non-blocking because tokenRenewer may be stopped.\n\tselect {\n\tcase t.signalRenewToken <- struct{}{}:\n\tdefault:\n\t}\n}\n\nfunc (t *TokenRenewer) sendDisconnectSignal() {\n\t// Needs to be non-blocking because tokenRenewer may be stopped.\n\tselect {\n\tcase t.disconnect <- struct{}{}:\n\tdefault:\n\t}\n}\n\n// renewToken gets a new token from a kontrolClient, parses it and sets it as the token.\nfunc (t *TokenRenewer) renewToken() error {\n\trenew := &protocol.Kite{\n\t\tID: t.client.Kite.ID,\n\t}\n\n\ttoken, err := t.localKite.GetToken(renew)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif err = t.parse(token); err != nil {\n\t\treturn err\n\t}\n\n\tt.client.authMu.Lock()\n\tt.client.Auth.Key = token\n\tt.client.authMu.Unlock()\n\n\tt.client.callOnTokenRenewHandlers(token)\n\n\treturn nil\n}\n"
        },
        {
          "name": "tunnelproxy",
          "type": "tree",
          "content": null
        },
        {
          "name": "utils",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}