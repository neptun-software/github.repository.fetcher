{
  "metadata": {
    "timestamp": 1736566507585,
    "page": 54,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjYw",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "brianvoe/gofakeit",
      "stars": 4722,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0,
          "content": ""
        },
        {
          "name": ".vscode",
          "type": "tree",
          "content": null
        },
        {
          "name": "BENCHMARKS.md",
          "type": "blob",
          "size": 32.2880859375,
          "content": "go test -bench=. -benchmem \\\ngoos: darwin \\\ngoarch: amd64 \\\npkg: github.com/brianvoe/gofakeit/v7 \\\ncpu: Apple M1 Max \\\nTable generated with tablesgenerator.com/markdown_tables File->Paste table data\n\n| Benchmark                             | Ops      | CPU            | MEM          | MEM alloc        |\n|---------------------------------------|----------|----------------|--------------|------------------|\n| BenchmarkAddress-10                   | 1369538  | 874.7 ns/op    | 195 B/op     | 5 allocs/op      |\n| BenchmarkStreet-10                    | 3438403  | 347.9 ns/op    | 25 B/op      | 2 allocs/op      |\n| BenchmarkStreetNumber-10              | 8601847  | 138.2 ns/op    | 4 B/op       | 1 allocs/op      |\n| BenchmarkStreetPrefix-10              | 19814623 | 60.26 ns/op    | 0 B/op       | 0 allocs/op      |\n| BenchmarkStreetName-10                | 19633909 | 60.78 ns/op    | 0 B/op       | 0 allocs/op      |\n| BenchmarkStreetSuffix-10              | 19717612 | 60.19 ns/op    | 0 B/op       | 0 allocs/op      |\n| BenchmarkCity-10                      | 20219280 | 58.88 ns/op    | 0 B/op       | 0 allocs/op      |\n| BenchmarkState-10                     | 19526760 | 60.85 ns/op    | 0 B/op       | 0 allocs/op      |\n| BenchmarkStateAbr-10                  | 19634631 | 60.79 ns/op    | 0 B/op       | 0 allocs/op      |\n| BenchmarkZip-10                       | 7521580  | 157.7 ns/op    | 5 B/op       | 1 allocs/op      |\n| BenchmarkCountry-10                   | 19451166 | 61.29 ns/op    | 0 B/op       | 0 allocs/op      |\n| BenchmarkCountryAbr-10                | 19585867 | 60.82 ns/op    | 0 B/op       | 0 allocs/op      |\n| BenchmarkLatitude-10                  | 72309668 | 16.22 ns/op    | 0 B/op       | 0 allocs/op      |\n| BenchmarkLongitude-10                 | 72334910 | 16.23 ns/op    | 0 B/op       | 0 allocs/op      |\n| BenchmarkLatitudeInRange-10           | 65830375 | 17.77 ns/op    | 0 B/op       | 0 allocs/op      |\n| BenchmarkLongitudeInRange-10          | 66400602 | 17.77 ns/op    | 0 B/op       | 0 allocs/op      |\n| BenchmarkPetName-10                   | 30391768 | 39.19 ns/op    | 0 B/op       | 0 allocs/op      |\n| BenchmarkAnimal-10                    | 28761544 | 41.22 ns/op    | 0 B/op       | 0 allocs/op      |\n| BenchmarkAnimalType-10                | 26955640 | 44.13 ns/op    | 0 B/op       | 0 allocs/op      |\n| BenchmarkFarmAnimal-10                | 22307872 | 53.39 ns/op    | 0 B/op       | 0 allocs/op      |\n| BenchmarkCat-10                       | 24226416 | 49.13 ns/op    | 0 B/op       | 0 allocs/op      |\n| BenchmarkDog-10                       | 19702195 | 60.53 ns/op    | 0 B/op       | 0 allocs/op      |\n| BenchmarkBird-10                      | 17095884 | 70.22 ns/op    | 0 B/op       | 0 allocs/op      |\n| BenchmarkAppName-10                   | 3805696  | 314.4 ns/op    | 25 B/op      | 1 allocs/op      |\n| BenchmarkAppVersion-10                | 10250247 | 116.4 ns/op    | 7 B/op       | 1 allocs/op      |\n| BenchmarkAppAuthor-10                 | 11592895 | 101.2 ns/op    | 8 B/op       | 0 allocs/op      |\n| BenchmarkUsername-10                  | 8975020  | 132.9 ns/op    | 16 B/op      | 2 allocs/op      |\n| BenchmarkPassword-10                  | 322147   | 3647 ns/op     | 1656 B/op    | 60 allocs/op     |\n| BenchmarkBeerName-10                  | 27986706 | 42.27 ns/op    | 0 B/op       | 0 allocs/op      |\n| BenchmarkBeerStyle-10                 | 19460616 | 60.99 ns/op    | 0 B/op       | 0 allocs/op      |\n| BenchmarkBeerHop-10                   | 26915132 | 44.35 ns/op    | 0 B/op       | 0 allocs/op      |\n| BenchmarkBeerYeast-10                 | 24840991 | 47.98 ns/op    | 0 B/op       | 0 allocs/op      |\n| BenchmarkBeerMalt-10                  | 20806075 | 57.18 ns/op    | 0 B/op       | 0 allocs/op      |\n| BenchmarkBeerIbu-10                   | 41349307 | 28.99 ns/op    | 8 B/op       | 1 allocs/op      |\n| BenchmarkBeerAlcohol-10               | 6054163  | 197.8 ns/op    | 28 B/op      | 2 allocs/op      |\n| BenchmarkBeerBlg-10                   | 5825622  | 205.6 ns/op    | 37 B/op      | 2 allocs/op      |\n| BenchmarkBook-10                      | 6927696  | 171.9 ns/op    | 48 B/op      | 1 allocs/op      |\n| BenchmarkBookTitle-10                 | 31594431 | 37.36 ns/op    | 0 B/op       | 0 allocs/op      |\n| BenchmarkBookAuthor-10                | 29969000 | 39.91 ns/op    | 0 B/op       | 0 allocs/op      |\n| BenchmarkBookGenre-10                 | 24269676 | 48.77 ns/op    | 0 B/op       | 0 allocs/op      |\n| BenchmarkCar-10                       | 3795943  | 316.3 ns/op    | 96 B/op      | 1 allocs/op      |\n| BenchmarkCarType-10                   | 26309082 | 43.81 ns/op    | 0 B/op       | 0 allocs/op      |\n| BenchmarkCarFuelType-10               | 26414821 | 45.18 ns/op    | 0 B/op       | 0 allocs/op      |\n| BenchmarkCarTransmissionType-10       | 24309171 | 48.83 ns/op    | 0 B/op       | 0 allocs/op      |\n| BenchmarkCarMaker-10                  | 23505099 | 51.01 ns/op    | 0 B/op       | 0 allocs/op      |\n| BenchmarkCarModel-10                  | 19055469 | 62.82 ns/op    | 0 B/op       | 0 allocs/op      |\n| BenchmarkCelebrityActor-10            | 19915483 | 57.84 ns/op    | 0 B/op       | 0 allocs/op      |\n| BenchmarkCelebrityBusiness-10         | 20186090 | 67.55 ns/op    | 0 B/op       | 0 allocs/op      |\n| BenchmarkCelebritySport-10            | 14223360 | 84.47 ns/op    | 0 B/op       | 0 allocs/op      |\n| BenchmarkColor-10                     | 21535978 | 54.16 ns/op    | 0 B/op       | 0 allocs/op      |\n| BenchmarkNiceColors-10                | 71414755 | 16.16 ns/op    | 0 B/op       | 0 allocs/op      |\n| BenchmarkSafeColor-10                 | 24683570 | 46.53 ns/op    | 0 B/op       | 0 allocs/op      |\n| BenchmarkHexColor-10                  | 4815675  | 250.3 ns/op    | 24 B/op      | 3 allocs/op      |\n| BenchmarkRGBColor-10                  | 19453399 | 61.67 ns/op    | 24 B/op      | 1 allocs/op      |\n| BenchmarkCompany-10                   | 25604892 | 46.66 ns/op    | 0 B/op       | 0 allocs/op      |\n| BenchmarkCompanySuffix-10             | 24647574 | 48.83 ns/op    | 0 B/op       | 0 allocs/op      |\n| BenchmarkBlurb-10                     | 20634126 | 58.88 ns/op    | 0 B/op       | 0 allocs/op      |\n| BenchmarkBuzzWord-10                  | 23034157 | 51.84 ns/op    | 0 B/op       | 0 allocs/op      |\n| BenchmarkBS-10                        | 21803314 | 55.08 ns/op    | 0 B/op       | 0 allocs/op      |\n| BenchmarkJob-10                       | 4121804  | 292.0 ns/op    | 64 B/op      | 1 allocs/op      |\n| BenchmarkJobTitle-10                  | 24344308 | 47.51 ns/op    | 0 B/op       | 0 allocs/op      |\n| BenchmarkJobDescriptor-10             | 24049240 | 50.12 ns/op    | 0 B/op       | 0 allocs/op      |\n| BenchmarkJobLevel-10                  | 19349389 | 62.45 ns/op    | 0 B/op       | 0 allocs/op      |\n| BenchmarkSlogan-10                    | 4499653  | 263.1 ns/op    | 41 B/op      | 1 allocs/op      |\n| BenchmarkCSVLookup100-10              | 1184     | 1014597 ns/op  | 713620 B/op  | 9923 allocs/op   |\n| BenchmarkEmoji-10                     | 24200866 | 49.72 ns/op    | 0 B/op       | 0 allocs/op      |\n| BenchmarkEmojiDescription-10          | 22978600 | 52.18 ns/op    | 0 B/op       | 0 allocs/op      |\n| BenchmarkEmojiCategory-10             | 21228057 | 56.57 ns/op    | 0 B/op       | 0 allocs/op      |\n| BenchmarkEmojiAlias-10                | 17616240 | 68.45 ns/op    | 0 B/op       | 0 allocs/op      |\n| BenchmarkEmojiTag-10                  | 19253190 | 62.21 ns/op    | 0 B/op       | 0 allocs/op      |\n| BenchmarkError-10                     | 1637725  | 736.5 ns/op    | 288 B/op     | 8 allocs/op      |\n| BenchmarkErrorObject-10               | 6755540  | 177.7 ns/op    | 32 B/op      | 3 allocs/op      |\n| BenchmarkErrorDatabase-10             | 5794706  | 200.2 ns/op    | 63 B/op      | 3 allocs/op      |\n| BenchmarkErrorGRPC-10                 | 6063802  | 196.8 ns/op    | 64 B/op      | 3 allocs/op      |\n| BenchmarkErrorHTTP-10                 | 3956130  | 302.2 ns/op    | 158 B/op     | 4 allocs/op      |\n| BenchmarkErrorHTTPClient-10           | 6025258  | 196.4 ns/op    | 52 B/op      | 3 allocs/op      |\n| BenchmarkErrorHTTPServer-10           | 5969395  | 202.1 ns/op    | 59 B/op      | 3 allocs/op      |\n| BenchmarkErrorRuntime-10              | 4786108  | 248.3 ns/op    | 150 B/op     | 3 allocs/op      |\n| BenchmarkErrorValidation-10           | 1811821  | 667.8 ns/op    | 277 B/op     | 7 allocs/op      |\n| BenchmarkFileMimeType-10              | 26273320 | 45.47 ns/op    | 0 B/op       | 0 allocs/op      |\n| BenchmarkFileExtension-10             | 22216770 | 53.94 ns/op    | 0 B/op       | 0 allocs/op      |\n| BenchmarkCusip-10                     | 6778542  | 176.4 ns/op    | 16 B/op      | 1 allocs/op      |\n| BenchmarkIsin-10                      | 1844566  | 652.1 ns/op    | 525 B/op     | 7 allocs/op      |\n| BenchmarkFruit-10                     | 20381516 | 58.81 ns/op    | 0 B/op       | 0 allocs/op      |\n| BenchmarkVegetable-10                 | 19638996 | 61.11 ns/op    | 0 B/op       | 0 allocs/op      |\n| BenchmarkBreakfast-10                 | 9425649  | 127.2 ns/op    | 32 B/op      | 1 allocs/op      |\n| BenchmarkLunch-10                     | 8996594  | 133.6 ns/op    | 34 B/op      | 1 allocs/op      |\n| BenchmarkDinner-10                    | 9427389  | 126.6 ns/op    | 36 B/op      | 1 allocs/op      |\n| BenchmarkDrink-10                     | 8552294  | 140.4 ns/op    | 7 B/op       | 2 allocs/op      |\n| BenchmarkSnack-10                     | 7678719  | 156.7 ns/op    | 32 B/op      | 1 allocs/op      |\n| BenchmarkDessert-10                   | 8907098  | 134.0 ns/op    | 31 B/op      | 2 allocs/op      |\n| BenchmarkGamertag-10                  | 2474312  | 483.9 ns/op    | 83 B/op      | 5 allocs/op      |\n| BenchmarkDice-10                      | 47727080 | 25.22 ns/op    | 8 B/op       | 1 allocs/op      |\n| BenchmarkGenerate/package-10          | 423741   | 2822 ns/op     | 1187 B/op    | 29 allocs/op     |\n| BenchmarkGenerate/Complex-10          | 138112   | 8653 ns/op     | 4553 B/op    | 80 allocs/op     |\n| BenchmarkFixedWidthLookup100-10       | 2072     | 583512 ns/op   | 489975 B/op  | 8701 allocs/op   |\n| BenchmarkRegex-10                     | 633699   | 1914 ns/op     | 1632 B/op    | 27 allocs/op     |\n| BenchmarkRegexEmail-10                | 205447   | 5893 ns/op     | 4084 B/op    | 90 allocs/op     |\n| BenchmarkMap-10                       | 337576   | 3596 ns/op     | 1111 B/op    | 16 allocs/op     |\n| BenchmarkHackerPhrase-10              | 166683   | 7209 ns/op     | 3107 B/op    | 50 allocs/op     |\n| BenchmarkHackerAbbreviation-10        | 25295019 | 47.33 ns/op    | 0 B/op       | 0 allocs/op      |\n| BenchmarkHackerAdjective-10           | 24022460 | 49.76 ns/op    | 0 B/op       | 0 allocs/op      |\n| BenchmarkHackerNoun-10                | 22496308 | 53.31 ns/op    | 0 B/op       | 0 allocs/op      |\n| BenchmarkHackerVerb-10                | 18546052 | 64.53 ns/op    | 0 B/op       | 0 allocs/op      |\n| BenchmarkHackeringVerb-10             | 20298242 | 59.05 ns/op    | 0 B/op       | 0 allocs/op      |\n| BenchmarkReplaceWithNumbers-10        | 1402717  | 852.8 ns/op    | 296 B/op     | 10 allocs/op     |\n| BenchmarkHipsterWord-10               | 25151432 | 47.83 ns/op    | 0 B/op       | 0 allocs/op      |\n| BenchmarkHipsterSentence-10           | 1314279  | 907.8 ns/op    | 288 B/op     | 3 allocs/op      |\n| BenchmarkHipsterParagraph-10          | 67437    | 17682 ns/op    | 10521 B/op   | 48 allocs/op     |\n| BenchmarkInputName-10                 | 20759898 | 57.98 ns/op    | 0 B/op       | 0 allocs/op      |\n| BenchmarkSvg-10                       | 225738   | 5181 ns/op     | 8876 B/op    | 52 allocs/op     |\n| BenchmarkImageURL-10                  | 15524359 | 77.15 ns/op    | 38 B/op      | 3 allocs/op      |\n| BenchmarkImage-10                     | 63       | 18773091 ns/op | 2457691 B/op | 307202 allocs/op |\n| BenchmarkImageJpeg-10                 | 39       | 29498291 ns/op | 2982478 B/op | 307217 allocs/op |\n| BenchmarkImagePng-10                  | 16       | 68552771 ns/op | 5899010 B/op | 307270 allocs/op |\n| BenchmarkDomainName-10                | 3001479  | 402.2 ns/op    | 95 B/op      | 5 allocs/op      |\n| BenchmarkDomainSuffix-10              | 21476332 | 56.03 ns/op    | 0 B/op       | 0 allocs/op      |\n| BenchmarkURL-10                       | 1289262  | 934.6 ns/op    | 277 B/op     | 10 allocs/op     |\n| BenchmarkHTTPMethod-10                | 19895946 | 60.56 ns/op    | 0 B/op       | 0 allocs/op      |\n| BenchmarkIPv4Address-10               | 6088518  | 196.5 ns/op    | 16 B/op      | 1 allocs/op      |\n| BenchmarkIPv6Address-10               | 2580320  | 462.0 ns/op    | 111 B/op     | 8 allocs/op      |\n| BenchmarkMacAddress-10                | 3281300  | 364.7 ns/op    | 24 B/op      | 1 allocs/op      |\n| BenchmarkHTTPStatusCode-10            | 16597051 | 72.18 ns/op    | 0 B/op       | 0 allocs/op      |\n| BenchmarkHTTPStatusCodeSimple-10      | 17250238 | 69.52 ns/op    | 0 B/op       | 0 allocs/op      |\n| BenchmarkLogLevel-10                  | 20608036 | 58.20 ns/op    | 0 B/op       | 0 allocs/op      |\n| BenchmarkUserAgent-10                 | 1946059  | 615.5 ns/op    | 298 B/op     | 5 allocs/op      |\n| BenchmarkChromeUserAgent-10           | 2619324  | 458.2 ns/op    | 184 B/op     | 5 allocs/op      |\n| BenchmarkFirefoxUserAgent-10          | 1601706  | 753.8 ns/op    | 362 B/op     | 6 allocs/op      |\n| BenchmarkSafariUserAgent-10           | 1569805  | 764.4 ns/op    | 551 B/op     | 7 allocs/op      |\n| BenchmarkOperaUserAgent-10            | 2378972  | 504.7 ns/op    | 212 B/op     | 5 allocs/op      |\n| BenchmarkJSONLookup100-10             | 928      | 1276230 ns/op  | 813725 B/op  | 12134 allocs/op  |\n| BenchmarkLanguage-10                  | 23873984 | 50.34 ns/op    | 0 B/op       | 0 allocs/op      |\n| BenchmarkLanguageAbbreviation-10      | 25025524 | 47.93 ns/op    | 0 B/op       | 0 allocs/op      |\n| BenchmarkLanguageBCP-10               | 21895112 | 54.74 ns/op    | 0 B/op       | 0 allocs/op      |\n| BenchmarkProgrammingLanguage-10       | 21169636 | 56.70 ns/op    | 0 B/op       | 0 allocs/op      |\n| BenchmarkLoremIpsumWord-10            | 23980356 | 49.92 ns/op    | 0 B/op       | 0 allocs/op      |\n| BenchmarkLoremIpsumSentence-10        | 1344384  | 894.8 ns/op    | 219 B/op     | 2 allocs/op      |\n| BenchmarkLoremIpsumParagraph-10       | 66643    | 17916 ns/op    | 8483 B/op    | 40 allocs/op     |\n| BenchmarkMinecraftOre-10              | 15077451 | 79.85 ns/op    | 0 B/op       | 0 allocs/op      |\n| BenchmarkMinecraftWood-10             | 14422303 | 83.44 ns/op    | 0 B/op       | 0 allocs/op      |\n| BenchmarkMinecraftArmorTier-10        | 15262417 | 78.70 ns/op    | 0 B/op       | 0 allocs/op      |\n| BenchmarkMinecraftArmorPart-10        | 15340200 | 78.11 ns/op    | 0 B/op       | 0 allocs/op      |\n| BenchmarkMinecraftWeapon-10           | 15107792 | 79.78 ns/op    | 0 B/op       | 0 allocs/op      |\n| BenchmarkMinecraftTool-10             | 14428170 | 83.15 ns/op    | 0 B/op       | 0 allocs/op      |\n| BenchmarkMinecraftDye-10              | 14657188 | 81.95 ns/op    | 0 B/op       | 0 allocs/op      |\n| BenchmarkMinecraftFood-10             | 14860236 | 81.01 ns/op    | 0 B/op       | 0 allocs/op      |\n| BenchmarkMinecraftAnimal-10           | 15281302 | 78.35 ns/op    | 0 B/op       | 0 allocs/op      |\n| BenchmarkMinecraftVillagerJob-10      | 14586627 | 82.14 ns/op    | 0 B/op       | 0 allocs/op      |\n| BenchmarkMinecraftVillagerStation-10  | 14678592 | 81.82 ns/op    | 0 B/op       | 0 allocs/op      |\n| BenchmarkMinecraftVillagerLevel-10    | 14314164 | 83.76 ns/op    | 0 B/op       | 0 allocs/op      |\n| BenchmarkMinecraftMobPassive-10       | 15132750 | 79.32 ns/op    | 0 B/op       | 0 allocs/op      |\n| BenchmarkMinecraftMobNeutral-10       | 13802880 | 87.23 ns/op    | 0 B/op       | 0 allocs/op      |\n| BenchmarkMinecraftMobHostile-10       | 13141233 | 91.06 ns/op    | 0 B/op       | 0 allocs/op      |\n| BenchmarkMinecraftMobBoss-10          | 15245322 | 78.79 ns/op    | 0 B/op       | 0 allocs/op      |\n| BenchmarkMinecraftBiome-10            | 14943789 | 79.86 ns/op    | 0 B/op       | 0 allocs/op      |\n| BenchmarkMinecraftWeather-10          | 12681386 | 94.55 ns/op    | 0 B/op       | 0 allocs/op      |\n| BenchmarkBool-10                      | 73596490 | 16.18 ns/op    | 0 B/op       | 0 allocs/op      |\n| BenchmarkUUID-10                      | 4128735  | 288.7 ns/op    | 48 B/op      | 1 allocs/op      |\n| BenchmarkShuffleAnySlice-10           | 3149857  | 380.0 ns/op    | 24 B/op      | 1 allocs/op      |\n| BenchmarkFlipACoin-10                 | 74457853 | 16.17 ns/op    | 0 B/op       | 0 allocs/op      |\n| BenchmarkMovie-10                     | 9234234  | 129.3 ns/op    | 32 B/op      | 1 allocs/op      |\n| BenchmarkMovieName-10                 | 25314163 | 47.82 ns/op    | 0 B/op       | 0 allocs/op      |\n| BenchmarkMovieGenre-10                | 24570799 | 48.81 ns/op    | 0 B/op       | 0 allocs/op      |\n| BenchmarkNumber-10                    | 74087221 | 16.21 ns/op    | 0 B/op       | 0 allocs/op      |\n| BenchmarkUint8-10                     | 73790145 | 16.35 ns/op    | 0 B/op       | 0 allocs/op      |\n| BenchmarkUint16-10                    | 74334474 | 16.27 ns/op    | 0 B/op       | 0 allocs/op      |\n| BenchmarkUint32-10                    | 71804154 | 16.72 ns/op    | 0 B/op       | 0 allocs/op      |\n| BenchmarkUint64-10                    | 71385904 | 16.64 ns/op    | 0 B/op       | 0 allocs/op      |\n| BenchmarkUintRange-10                 | 73982353 | 16.13 ns/op    | 0 B/op       | 0 allocs/op      |\n| BenchmarkInt8-10                      | 73927286 | 16.14 ns/op    | 0 B/op       | 0 allocs/op      |\n| BenchmarkInt16-10                     | 74022668 | 16.19 ns/op    | 0 B/op       | 0 allocs/op      |\n| BenchmarkInt32-10                     | 72009002 | 16.64 ns/op    | 0 B/op       | 0 allocs/op      |\n| BenchmarkInt64-10                     | 72375081 | 16.59 ns/op    | 0 B/op       | 0 allocs/op      |\n| BenchmarkIntRange-10                  | 74396306 | 16.20 ns/op    | 0 B/op       | 0 allocs/op      |\n| BenchmarkFloat32-10                   | 73950822 | 16.20 ns/op    | 0 B/op       | 0 allocs/op      |\n| BenchmarkFloat32Range-10              | 73622833 | 16.18 ns/op    | 0 B/op       | 0 allocs/op      |\n| BenchmarkFloat64-10                   | 73076970 | 16.31 ns/op    | 0 B/op       | 0 allocs/op      |\n| BenchmarkFloat64Range-10              | 73385329 | 16.33 ns/op    | 0 B/op       | 0 allocs/op      |\n| BenchmarkShuffleInts-10               | 9151563  | 131.8 ns/op    | 0 B/op       | 0 allocs/op      |\n| BenchmarkRandomInt-10                 | 72188592 | 16.63 ns/op    | 0 B/op       | 0 allocs/op      |\n| BenchmarkRandomUint-10                | 72293332 | 16.64 ns/op    | 0 B/op       | 0 allocs/op      |\n| BenchmarkHexUint-10                   | 14888452 | 80.93 ns/op    | 16 B/op      | 2 allocs/op      |\n| BenchmarkCurrency-10                  | 14366668 | 83.15 ns/op    | 32 B/op      | 1 allocs/op      |\n| BenchmarkCurrencyShort-10             | 24445954 | 48.68 ns/op    | 0 B/op       | 0 allocs/op      |\n| BenchmarkCurrencyLong-10              | 23560556 | 50.65 ns/op    | 0 B/op       | 0 allocs/op      |\n| BenchmarkPrice-10                     | 73693664 | 16.33 ns/op    | 0 B/op       | 0 allocs/op      |\n| BenchmarkCreditCard-10                | 1000000  | 1153 ns/op     | 264 B/op     | 15 allocs/op     |\n| BenchmarkCreditCardType-10            | 32410167 | 36.93 ns/op    | 0 B/op       | 0 allocs/op      |\n| BenchmarkCreditCardNumber-10          | 1511084  | 799.1 ns/op    | 183 B/op     | 10 allocs/op     |\n| BenchmarkCreditCardExp-10             | 11014600 | 108.5 ns/op    | 5 B/op       | 1 allocs/op      |\n| BenchmarkCreditCardCvv-10             | 20325733 | 59.31 ns/op    | 3 B/op       | 1 allocs/op      |\n| BenchmarkAchRouting-10                | 7338657  | 164.0 ns/op    | 16 B/op      | 1 allocs/op      |\n| BenchmarkAchAccount-10                | 5646235  | 212.0 ns/op    | 16 B/op      | 1 allocs/op      |\n| BenchmarkBitcoinAddress-10            | 517399   | 2306 ns/op     | 715 B/op     | 37 allocs/op     |\n| BenchmarkBitcoinPrivateKey-10         | 1276884  | 943.2 ns/op    | 184 B/op     | 5 allocs/op      |\n| BenchmarkName-10                      | 7771977  | 152.6 ns/op    | 16 B/op      | 1 allocs/op      |\n| BenchmarkFirstName-10                 | 23523357 | 50.98 ns/op    | 0 B/op       | 0 allocs/op      |\n| BenchmarkMiddleName-10                | 17589612 | 68.17 ns/op    | 0 B/op       | 0 allocs/op      |\n| BenchmarkLastName-10                  | 20825980 | 57.63 ns/op    | 0 B/op       | 0 allocs/op      |\n| BenchmarkNamePrefix-10                | 25542308 | 46.65 ns/op    | 0 B/op       | 0 allocs/op      |\n| BenchmarkNameSuffix-10                | 21972974 | 54.56 ns/op    | 0 B/op       | 0 allocs/op      |\n| BenchmarkSSN-10                       | 31829850 | 37.71 ns/op    | 16 B/op      | 1 allocs/op      |\n| BenchmarkGender-10                    | 73621140 | 16.25 ns/op    | 0 B/op       | 0 allocs/op      |\n| BenchmarkHobby-10                     | 17347129 | 69.06 ns/op    | 0 B/op       | 0 allocs/op      |\n| BenchmarkPerson-10                    | 317911   | 3693 ns/op     | 837 B/op     | 33 allocs/op     |\n| BenchmarkContact-10                   | 1843221  | 650.8 ns/op    | 136 B/op     | 6 allocs/op      |\n| BenchmarkPhone-10                     | 6786794  | 176.2 ns/op    | 16 B/op      | 1 allocs/op      |\n| BenchmarkPhoneFormatted-10            | 4674930  | 256.2 ns/op    | 16 B/op      | 1 allocs/op      |\n| BenchmarkEmail-10                     | 2794358  | 431.1 ns/op    | 88 B/op      | 4 allocs/op      |\n| BenchmarkTeams-10                     | 1576238  | 763.8 ns/op    | 672 B/op     | 10 allocs/op     |\n| BenchmarkProduct-10                   | 206918   | 5813 ns/op     | 1069 B/op    | 31 allocs/op     |\n| BenchmarkProductName-10               | 2313364  | 517.4 ns/op    | 103 B/op     | 5 allocs/op      |\n| BenchmarkProductDescription-10        | 348346   | 3434 ns/op     | 549 B/op     | 8 allocs/op      |\n| BenchmarkProductCategory-10           | 25139860 | 47.73 ns/op    | 0 B/op       | 0 allocs/op      |\n| BenchmarkProductFeature-10            | 21264922 | 56.46 ns/op    | 0 B/op       | 0 allocs/op      |\n| BenchmarkProductMaterial-10           | 18142828 | 66.24 ns/op    | 0 B/op       | 0 allocs/op      |\n| BenchmarkProductUPC-10                | 1399148  | 859.1 ns/op    | 96 B/op      | 11 allocs/op     |\n| BenchmarkSchool-10                    | 4161710  | 287.6 ns/op    | 34 B/op      | 1 allocs/op      |\n| BenchmarkLetter-10                    | 73457020 | 16.29 ns/op    | 0 B/op       | 0 allocs/op      |\n| BenchmarkLetterN-10                   | 5060271  | 238.8 ns/op    | 64 B/op      | 2 allocs/op      |\n| BenchmarkVowel-10                     | 58685206 | 20.87 ns/op    | 4 B/op       | 1 allocs/op      |\n| BenchmarkDigit-10                     | 73944177 | 16.20 ns/op    | 0 B/op       | 0 allocs/op      |\n| BenchmarkDigitN-10                    | 5051070  | 236.6 ns/op    | 64 B/op      | 2 allocs/op      |\n| BenchmarkNumerify-10                  | 6794545  | 176.4 ns/op    | 16 B/op      | 1 allocs/op      |\n| BenchmarkLexify-10                    | 11113212 | 108.3 ns/op    | 8 B/op       | 1 allocs/op      |\n| BenchmarkShuffleStrings-10            | 9924429  | 121.0 ns/op    | 0 B/op       | 0 allocs/op      |\n| BenchmarkRandomString-10              | 73420688 | 16.34 ns/op    | 0 B/op       | 0 allocs/op      |\n| BenchmarkTemplate-10                  | 2488     | 477349 ns/op   | 280877 B/op  | 4611 allocs/op   |\n| BenchmarkDate-10                      | 10292476 | 116.2 ns/op    | 0 B/op       | 0 allocs/op      |\n| BenchmarkPastDate-10                  | 18285830 | 65.48 ns/op    | 0 B/op       | 0 allocs/op      |\n| BenchmarkFutureDate-10                | 18399240 | 65.13 ns/op    | 0 B/op       | 0 allocs/op      |\n| BenchmarkDateRange-10                 | 8406979  | 142.7 ns/op    | 0 B/op       | 0 allocs/op      |\n| BenchmarkMonth-10                     | 74105902 | 16.26 ns/op    | 0 B/op       | 0 allocs/op      |\n| BenchmarkMonthString-10               | 73647870 | 16.26 ns/op    | 0 B/op       | 0 allocs/op      |\n| BenchmarkWeekDay-10                   | 73990911 | 16.24 ns/op    | 0 B/op       | 0 allocs/op      |\n| BenchmarkDay-10                       | 73435291 | 16.21 ns/op    | 0 B/op       | 0 allocs/op      |\n| BenchmarkYear-10                      | 73950066 | 16.21 ns/op    | 0 B/op       | 0 allocs/op      |\n| BenchmarkHour-10                      | 74219916 | 16.21 ns/op    | 0 B/op       | 0 allocs/op      |\n| BenchmarkMinute-10                    | 74349634 | 16.21 ns/op    | 0 B/op       | 0 allocs/op      |\n| BenchmarkSecond-10                    | 73787313 | 16.29 ns/op    | 0 B/op       | 0 allocs/op      |\n| BenchmarkNanoSecond-10                | 74299380 | 16.15 ns/op    | 0 B/op       | 0 allocs/op      |\n| BenchmarkTimeZone-10                  | 19105237 | 62.83 ns/op    | 0 B/op       | 0 allocs/op      |\n| BenchmarkTimeZoneFull-10              | 16170054 | 74.27 ns/op    | 0 B/op       | 0 allocs/op      |\n| BenchmarkTimeZoneAbv-10               | 20725029 | 58.23 ns/op    | 0 B/op       | 0 allocs/op      |\n| BenchmarkTimeZoneOffset-10            | 14597666 | 81.13 ns/op    | 0 B/op       | 0 allocs/op      |\n| BenchmarkTimeZoneRegion-10            | 15733551 | 76.25 ns/op    | 0 B/op       | 0 allocs/op      |\n| BenchmarkWeighted-10                  | 28507484 | 40.42 ns/op    | 16 B/op      | 1 allocs/op      |\n| BenchmarkAdjective-10                 | 6726474  | 178.3 ns/op    | 0 B/op       | 0 allocs/op      |\n| BenchmarkAdjectiveDescriptive-10      | 16486224 | 73.39 ns/op    | 0 B/op       | 0 allocs/op      |\n| BenchmarkAdjectiveQuantitative-10     | 15290762 | 78.51 ns/op    | 0 B/op       | 0 allocs/op      |\n| BenchmarkAdjectiveProper-10           | 16535046 | 72.42 ns/op    | 0 B/op       | 0 allocs/op      |\n| BenchmarkAdjectiveDemonstrative-10    | 16448917 | 73.41 ns/op    | 0 B/op       | 0 allocs/op      |\n| BenchmarkAdjectivePossessive-10       | 15715839 | 73.22 ns/op    | 0 B/op       | 0 allocs/op      |\n| BenchmarkAdjectiveInterrogative-10    | 15543478 | 77.43 ns/op    | 0 B/op       | 0 allocs/op      |\n| BenchmarkAdjectiveIndefinite-10       | 16306894 | 73.50 ns/op    | 0 B/op       | 0 allocs/op      |\n| BenchmarkAdverb-10                    | 7139924  | 168.7 ns/op    | 0 B/op       | 0 allocs/op      |\n| BenchmarkAdverbManner-10              | 17139112 | 70.37 ns/op    | 0 B/op       | 0 allocs/op      |\n| BenchmarkAdverbDegree-10              | 16213138 | 73.70 ns/op    | 0 B/op       | 0 allocs/op      |\n| BenchmarkAdverbPlace-10               | 17268267 | 69.67 ns/op    | 0 B/op       | 0 allocs/op      |\n| BenchmarkAdverbTimeDefinite-10        | 16273309 | 73.70 ns/op    | 0 B/op       | 0 allocs/op      |\n| BenchmarkAdverbTimeIndefinite-10      | 15822297 | 74.26 ns/op    | 0 B/op       | 0 allocs/op      |\n| BenchmarkAdverbFrequencyDefinite-10   | 16344181 | 73.30 ns/op    | 0 B/op       | 0 allocs/op      |\n| BenchmarkAdverbFrequencyIndefinite-10 | 16118569 | 74.27 ns/op    | 0 B/op       | 0 allocs/op      |\n| BenchmarkComment-10                   | 1000000  | 1146 ns/op     | 258 B/op     | 6 allocs/op      |\n| BenchmarkConnective-10                | 7132710  | 168.3 ns/op    | 0 B/op       | 0 allocs/op      |\n| BenchmarkConnectiveTime-10            | 15339457 | 78.08 ns/op    | 0 B/op       | 0 allocs/op      |\n| BenchmarkConnectiveComparative-10     | 16188842 | 74.04 ns/op    | 0 B/op       | 0 allocs/op      |\n| BenchmarkConnectiveComplaint-10       | 14127903 | 85.00 ns/op    | 0 B/op       | 0 allocs/op      |\n| BenchmarkConnectiveListing-10         | 16073437 | 74.65 ns/op    | 0 B/op       | 0 allocs/op      |\n| BenchmarkConnectiveCasual-10          | 13771904 | 87.06 ns/op    | 0 B/op       | 0 allocs/op      |\n| BenchmarkConnectiveExamplify-10       | 15763296 | 76.03 ns/op    | 0 B/op       | 0 allocs/op      |\n| BenchmarkWord-10                      | 8047610  | 148.5 ns/op    | 3 B/op       | 0 allocs/op      |\n| BenchmarkSentenceSimple-10            | 682924   | 1707 ns/op     | 590 B/op     | 11 allocs/op     |\n| BenchmarkInterjection-10              | 16295702 | 73.50 ns/op    | 0 B/op       | 0 allocs/op      |\n| BenchmarkNoun-10                      | 6711976  | 179.3 ns/op    | 0 B/op       | 0 allocs/op      |\n| BenchmarkNounCommon-10                | 17117466 | 69.83 ns/op    | 0 B/op       | 0 allocs/op      |\n| BenchmarkNounConcrete-10              | 17144979 | 69.81 ns/op    | 0 B/op       | 0 allocs/op      |\n| BenchmarkNounAbstract-10              | 16839790 | 71.16 ns/op    | 0 B/op       | 0 allocs/op      |\n| BenchmarkNounCollectivePeople-10      | 16360652 | 73.24 ns/op    | 0 B/op       | 0 allocs/op      |\n| BenchmarkNounCollectiveAnimal-10      | 16453287 | 72.79 ns/op    | 0 B/op       | 0 allocs/op      |\n| BenchmarkNounCollectiveThing-10       | 16397232 | 72.97 ns/op    | 0 B/op       | 0 allocs/op      |\n| BenchmarkNounCountable-10             | 17171895 | 69.78 ns/op    | 0 B/op       | 0 allocs/op      |\n| BenchmarkNounUncountable-10           | 17193412 | 69.75 ns/op    | 0 B/op       | 0 allocs/op      |\n| BenchmarkNounProper-10                | 10644372 | 112.0 ns/op    | 7 B/op       | 0 allocs/op      |\n| BenchmarkNounDeterminer-10            | 17003730 | 70.44 ns/op    | 0 B/op       | 0 allocs/op      |\n| BenchmarkPhrase-10                    | 23481584 | 51.12 ns/op    | 0 B/op       | 0 allocs/op      |\n| BenchmarkPhraseNoun-10                | 2961691  | 405.1 ns/op    | 104 B/op     | 2 allocs/op      |\n| BenchmarkPhraseVerb-10                | 1422132  | 845.1 ns/op    | 232 B/op     | 6 allocs/op      |\n| BenchmarkPhraseAdverb-10              | 7617193  | 153.3 ns/op    | 9 B/op       | 0 allocs/op      |\n| BenchmarkPhrasePreposition-10         | 2336155  | 513.3 ns/op    | 123 B/op     | 3 allocs/op      |\n| BenchmarkPreposition-10               | 9244665  | 129.9 ns/op    | 0 B/op       | 0 allocs/op      |\n| BenchmarkPrepositionSimple-10         | 16397623 | 73.11 ns/op    | 0 B/op       | 0 allocs/op      |\n| BenchmarkPrepositionDouble-10         | 16107751 | 74.19 ns/op    | 0 B/op       | 0 allocs/op      |\n| BenchmarkPrepositionCompound-10       | 16364900 | 73.10 ns/op    | 0 B/op       | 0 allocs/op      |\n| BenchmarkPronoun-10                   | 6436707  | 186.4 ns/op    | 0 B/op       | 0 allocs/op      |\n| BenchmarkPronounPersonal-10           | 16997427 | 70.53 ns/op    | 0 B/op       | 0 allocs/op      |\n| BenchmarkPronounObject-10             | 15303380 | 78.27 ns/op    | 0 B/op       | 0 allocs/op      |\n| BenchmarkPronounPossessive-10         | 15323908 | 78.10 ns/op    | 0 B/op       | 0 allocs/op      |\n| BenchmarkPronounReflective-10         | 15258552 | 78.45 ns/op    | 0 B/op       | 0 allocs/op      |\n| BenchmarkPronounIndefinite-10         | 16053780 | 74.69 ns/op    | 0 B/op       | 0 allocs/op      |\n| BenchmarkPronounDemonstrative-10      | 16476726 | 72.73 ns/op    | 0 B/op       | 0 allocs/op      |\n| BenchmarkPronounInterrogative-10      | 15526576 | 77.15 ns/op    | 0 B/op       | 0 allocs/op      |\n| BenchmarkPronounRelative-10           | 14159284 | 84.64 ns/op    | 0 B/op       | 0 allocs/op      |\n| BenchmarkSentence-10                  | 721934   | 1642 ns/op     | 219 B/op     | 3 allocs/op      |\n| BenchmarkParagraph-10                 | 39356    | 30481 ns/op    | 6687 B/op    | 53 allocs/op     |\n| BenchmarkQuestion-10                  | 1757269  | 683.1 ns/op    | 243 B/op     | 3 allocs/op      |\n| BenchmarkQuote-10                     | 1522988  | 787.2 ns/op    | 261 B/op     | 3 allocs/op      |\n| BenchmarkVerb-10                      | 8924802  | 127.6 ns/op    | 0 B/op       | 0 allocs/op      |\n| BenchmarkVerbAction-10                | 17150564 | 69.83 ns/op    | 0 B/op       | 0 allocs/op      |\n| BenchmarkVerbTransitive-10            | 17328488 | 69.21 ns/op    | 0 B/op       | 0 allocs/op      |\n| BenchmarkVerbIntransitive-10          | 16427985 | 72.98 ns/op    | 0 B/op       | 0 allocs/op      |\n| BenchmarkVerbLinking-10               | 17754280 | 67.52 ns/op    | 0 B/op       | 0 allocs/op      |\n| BenchmarkVerbHelping-10               | 17118238 | 70.31 ns/op    | 0 B/op       | 0 allocs/op      |\n| BenchmarkXMLLookup100-10              | 937      | 1279022 ns/op  | 862536 B/op  | 11370 allocs/op  |"
        },
        {
          "name": "CODE_OF_CONDUCT.md",
          "type": "blob",
          "size": 3.1435546875,
          "content": "# Contributor Covenant Code of Conduct\n\n## Our Pledge\n\nIn the interest of fostering an open and welcoming environment, we as contributors and maintainers pledge to making participation in our project and our community a harassment-free experience for everyone, regardless of age, body size, disability, ethnicity, gender identity and expression, level of experience, nationality, personal appearance, race, religion, or sexual identity and orientation.\n\n## Our Standards\n\nExamples of behavior that contributes to creating a positive environment include:\n\n* Using welcoming and inclusive language\n* Being respectful of differing viewpoints and experiences\n* Gracefully accepting constructive criticism\n* Focusing on what is best for the community\n* Showing empathy towards other community members\n\nExamples of unacceptable behavior by participants include:\n\n* The use of sexualized language or imagery and unwelcome sexual attention or advances\n* Trolling, insulting/derogatory comments, and personal or political attacks\n* Public or private harassment\n* Publishing others' private information, such as a physical or electronic address, without explicit permission\n* Other conduct which could reasonably be considered inappropriate in a professional setting\n\n## Our Responsibilities\n\nProject maintainers are responsible for clarifying the standards of acceptable behavior and are expected to take appropriate and fair corrective action in response to any instances of unacceptable behavior.\n\nProject maintainers have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, or to ban temporarily or permanently any contributor for other behaviors that they deem inappropriate, threatening, offensive, or harmful.\n\n## Scope\n\nThis Code of Conduct applies both within project spaces and in public spaces when an individual is representing the project or its community. Examples of representing a project or community include using an official project e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event. Representation of a project may be further defined and clarified by project maintainers.\n\n## Enforcement\n\nInstances of abusive, harassing, or otherwise unacceptable behavior may be reported by contacting the project team at brian@webiswhatido.com. The project team will review and investigate all complaints, and will respond in a way that it deems appropriate to the circumstances. The project team is obligated to maintain confidentiality with regard to the reporter of an incident. Further details of specific enforcement policies may be posted separately.\n\nProject maintainers who do not follow or enforce the Code of Conduct in good faith may face temporary or permanent repercussions as determined by other members of the project's leadership.\n\n## Attribution\n\nThis Code of Conduct is adapted from the [Contributor Covenant][homepage], version 1.4, available at [http://contributor-covenant.org/version/1/4][version]\n\n[homepage]: http://contributor-covenant.org\n[version]: http://contributor-covenant.org/version/1/4/\n"
        },
        {
          "name": "CONTRIBUTING.md",
          "type": "blob",
          "size": 0.0693359375,
          "content": "# Make a pull request and submit it and ill take a look at it. Thanks!\n"
        },
        {
          "name": "LICENSE.txt",
          "type": "blob",
          "size": 1.052734375,
          "content": "The MIT License (MIT)\n\nCopyright (c) [year] [fullname]\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of\nthis software and associated documentation files (the \"Software\"), to deal in\nthe Software without restriction, including without limitation the rights to\nuse, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of\nthe Software, and to permit persons to whom the Software is furnished to do so,\nsubject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS\nFOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR\nCOPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER\nIN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\nCONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE."
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 19.4716796875,
          "content": "![Gofakeit](https://raw.githubusercontent.com/brianvoe/gofakeit/master/logo.png)\n\n# Gofakeit [![Go Report Card](https://goreportcard.com/badge/github.com/brianvoe/gofakeit)](https://goreportcard.com/report/github.com/brianvoe/gofakeit) ![Test](https://github.com/brianvoe/gofakeit/workflows/Test/badge.svg?branch=master) [![GoDoc](https://godoc.org/github.com/brianvoe/gofakeit/v7?status.svg)](https://godoc.org/github.com/brianvoe/gofakeit/v7) [![license](http://img.shields.io/badge/license-MIT-green.svg?style=flat)](https://raw.githubusercontent.com/brianvoe/gofakeit/master/LICENSE.txt)\n\nRandom data generator written in go\n\n[![ko-fi](https://ko-fi.com/img/githubbutton_sm.svg)](https://ko-fi.com/G2G0R5EJT)\n\n<a href=\"https://www.buymeacoffee.com/brianvoe\" target=\"_blank\"><img src=\"https://www.buymeacoffee.com/assets/img/custom_images/orange_img.png\" alt=\"Buy Me A Coffee\" style=\"height: auto !important;width: auto !important;\" ></a>\n\n## Features\n\n- [310+ Functions!!!](#functions)\n- [Random Sources](#random-sources)\n- [Global Rand](#global-rand-set)\n- [Struct Generator](#struct)\n- [Custom Functions](#custom-functions)\n- [Templates](#templates)\n- [Http Server](https://github.com/brianvoe/gofakeit/tree/master/cmd/gofakeitserver)\n- [Command Line Tool](https://github.com/brianvoe/gofakeit/tree/master/cmd/gofakeit)\n- Zero dependencies\n- [Benchmarks](https://github.com/brianvoe/gofakeit/blob/master/BENCHMARKS.md)\n- [Issue](https://github.com/brianvoe/gofakeit/issues)\n\n## Contributors\n\nThank you to all our Gofakeit contributors!\n\n<a href=\"https://github.com/brianvoe/gofakeit/graphs/contributors\">\n  <img src=\"https://contrib.rocks/image?repo=brianvoe/gofakeit\" />\n</a>\n\n## Installation\n\n```go\ngo get github.com/brianvoe/gofakeit/v7\n```\n\n## Simple Usage\n\n```go\nimport \"github.com/brianvoe/gofakeit/v7\"\n\ngofakeit.Name()             // Markus Moen\ngofakeit.Email()            // alaynawuckert@kozey.biz\ngofakeit.Phone()            // (570)245-7485\ngofakeit.BS()               // front-end\ngofakeit.BeerName()         // Duvel\ngofakeit.Color()            // MediumOrchid\ngofakeit.Company()          // Moen, Pagac and Wuckert\ngofakeit.CreditCardNumber() // 4287271570245748\ngofakeit.HackerPhrase()     // Connecting the array won't do anything, we need to generate the haptic COM driver!\ngofakeit.JobTitle()         // Director\ngofakeit.CurrencyShort()    // USD\n```\n\n[See full list of functions](#functions)\n\n## Seed\n\nIf you are using the default global usage and dont care about seeding no need to set anything.\nGofakeit will seed it with a cryptographically secure number.\n\nIf you need a reproducible outcome you can set it via the Seed function call. Every example in\nthis repo sets it for testing purposes.\n\n```go\nimport \"github.com/brianvoe/gofakeit/v7\"\n\ngofakeit.Seed(0) // If 0 will use crypto/rand to generate a number\n\n// or\n\ngofakeit.Seed(8675309) // Set it to whatever number you want\n```\n\n## Random Sources\n\nGofakeit has a few rand sources, by default it uses math/rand/v2 PCG which is a pseudo random number generator and is thread locked.\n\nIf you want to see other potential sources you can see the sub package [Source](https://github.com/brianvoe/gofakeit/tree/master/source) for more information.\n\n```go\nimport (\n\t\"github.com/brianvoe/gofakeit/v7\"\n\t\"github.com/brianvoe/gofakeit/v7/source\"\n\t\"math/rand/v2\"\n)\n\n// Uses math/rand/v2(PCG Pseudo) with mutex locking\nfaker := gofakeit.New(0)\n\n// NewFaker takes in a source and whether or not it should be thread safe\nfaker := gofakeit.NewFaker(source rand.Source, threadSafe bool)\n\n// PCG Pseudo\nfaker := gofakeit.NewFaker(rand.NewPCG(11, 11), true)\n\n// ChaCha8\nfaker := gofakeit.NewFaker(rand.NewChaCha8([32]byte{0, 1, 2, 3, 4, 5}), true)\n\n\n// Additional from Gofakeit sub package source\n\n// JSF(Jenkins Small Fast)\nfaker := gofakeit.NewFaker(source.NewJSF(11), true)\n\n// SFC(Simple Fast Counter)\nfaker := gofakeit.NewFaker(source.NewSFC(11), true)\n\n// Crypto - Uses crypto/rand\nfaker := gofakeit.NewFaker(source.NewCrypto(), true)\n\n// Dumb - simple incrementing number\nfaker := gofakeit.NewFaker(source.NewDumb(11), true)\n```\n\n## Global Rand Set\n\nIf you would like to use the simple function calls but need to use something like\ncrypto/rand you can override the default global with the random source that you want.\n\n```go\nimport \"github.com/brianvoe/gofakeit/v7\"\n\ngofakeit.GlobalFaker = gofakeit.New(0)\n```\n\n## Struct\n\nGofakeit can generate random data for struct fields. For the most part it covers all the basic type\nas well as some non-basic like time.Time.\n\nStruct fields can also use tags to more specifically generate data for that field type.\n\n```go\nimport \"github.com/brianvoe/gofakeit/v7\"\n\n// Create structs with random injected data\ntype Foo struct {\n\tStr           string\n\tInt           int\n\tPointer       *int\n\tName          string         `fake:\"{firstname}\"`         // Any available function all lowercase\n\tSentence      string         `fake:\"{sentence:3}\"`        // Can call with parameters\n\tRandStr       string         `fake:\"{randomstring:[hello,world]}\"`\n\tNumber        string         `fake:\"{number:1,10}\"`       // Comma separated for multiple values\n\tRegex         string         `fake:\"{regex:[abcdef]{5}}\"` // Generate string from regex\n\tMap           map[string]int `fakesize:\"2\"`\n\tArray         []string       `fakesize:\"2\"`\n\tArrayRange    []string       `fakesize:\"2,6\"`\n\tBar           Bar\n\tSkip          *string        `fake:\"skip\"`                // Set to \"skip\" to not generate data for\n\tSkipAlt       *string        `fake:\"-\"`                   // Set to \"-\" to not generate data for\n\tCreated       time.Time                                   // Can take in a fake tag as well as a format tag\n\tCreatedFormat time.Time      `fake:\"{year}-{month}-{day}\" format:\"2006-01-02\"`\n}\n\ntype Bar struct {\n\tName    string\n\tNumber  int\n\tFloat   float32\n}\n\n// Pass your struct as a pointer\nvar f Foo\nerr := gofakeit.Struct(&f)\n\nfmt.Println(f.Str)      \t\t// hrukpttuezptneuvunh\nfmt.Println(f.Int)      \t\t// -7825289004089916589\nfmt.Println(*f.Pointer) \t\t// -343806609094473732\nfmt.Println(f.Name)     \t\t// fred\nfmt.Println(f.Sentence) \t\t// Record river mind.\nfmt.Println(fStr)  \t\t\t\t// world\nfmt.Println(f.Number)   \t\t// 4\nfmt.Println(f.Regex)    \t\t// cbdfc\nfmt.Println(f.Map)    \t\t\t// map[PxLIo:52 lxwnqhqc:846]\nfmt.Println(f.Array)    \t\t// cbdfc\nfmt.Printf(\"%+v\", f.Bar)    \t// {Name:QFpZ Number:-2882647639396178786 Float:1.7636692e+37}\nfmt.Println(f.Skip)     \t\t// <nil>\nfmt.Println(f.Created.String()) // 1908-12-07 04:14:25.685339029 +0000 UTC\n\n// Supported formats\n// int, int8, int16, int32, int64,\n// uint, uint8, uint16, uint32, uint64,\n// float32, float64,\n// bool, string,\n// array, pointers, map\n// time.Time // If setting time you can also set a format tag\n// Nested Struct Fields and Embedded Fields\n```\n\n## Fakeable types\n\nIt is possible to extend a struct by implementing the `Fakeable` interface\nin order to control the generation.\n\nFor example, this is useful when it is not possible to modify the struct that you want to fake by adding struct tags to a field but you still need to be able to control the generation process.\n\n```go\n// Custom string that you want to generate your own data for\ntype Friend string\n\nfunc (c *Friend) Fake(f *gofakeit.Faker) (any, error) {\n\t// Can call any other faker methods\n\treturn f.RandomString([]string{\"billy\", \"fred\", \"susan\"}), nil\n}\n\n// Custom time that you want to generate your own data for\ntype Age time.Time\n\nfunc (c *Age) Fake(f *gofakeit.Faker) (any, error) {\n\treturn f.DateRange(time.Now().AddDate(-100, 0, 0), time.Now().AddDate(-18, 0, 0)), nil\n}\n\n// This is the struct that we cannot modify to add struct tags\ntype User struct {\n\tName Friend\n\tAge *Age\n}\n\nvar u User\ngofakeit.Struct(&u)\nfmt.Printf(\"%s\", f.Name) // billy\nfmt.Printf(\"%s\", f.Age) // 1990-12-07 04:14:25.685339029 +0000 UTC\n```\n\n## Custom Functions\n\nIn a lot of situations you may need to use your own random function usage for your specific needs.\n\nIf you would like to extend the usage of struct tags, generate function, available usages in the gofakeit server\nor gofakeit command sub packages. You can do so via the AddFuncLookup. Each function has their own lookup, if\nyou need more reference examples you can look at each files lookups.\n\n```go\n// Simple\ngofakeit.AddFuncLookup(\"friendname\", gofakeit.Info{\n\tCategory:    \"custom\",\n\tDescription: \"Random friend name\",\n\tExample:     \"bill\",\n\tOutput:      \"string\",\n\tGenerate: func(f *Faker, m *gofakeit.MapParams, info *gofakeit.Info) (any, error) {\n\t\treturn f.RandomString([]string{\"bill\", \"bob\", \"sally\"}), nil\n\t},\n})\n\n// With Params\ngofakeit.AddFuncLookup(\"jumbleword\", gofakeit.Info{\n\tCategory:    \"jumbleword\",\n\tDescription: \"Take a word and jumble it up\",\n\tExample:     \"loredlowlh\",\n\tOutput:      \"string\",\n\tParams: []gofakeit.Param{\n\t\t{Field: \"word\", Type: \"string\", Description: \"Word you want to jumble\"},\n\t},\n\tGenerate: func(f *Faker, m *gofakeit.MapParams, info *gofakeit.Info) (any, error) {\n\t\tword, err := info.GetString(m, \"word\")\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tsplit := strings.Split(word, \"\")\n\t\tf.ShuffleStrings(split)\n\t\treturn strings.Join(split, \"\"), nil\n\t},\n})\n\ntype Foo struct {\n\tFriendName string `fake:\"{friendname}\"`\n\tJumbleWord string `fake:\"{jumbleword:helloworld}\"`\n}\n\nvar f Foo\ngofakeit.Struct(&f)\nfmt.Printf(\"%s\", f.FriendName) // bill\nfmt.Printf(\"%s\", f.JumbleWord) // loredlowlh\n```\n\n## Templates\n\nGenerate custom outputs using golang's template engine [https://pkg.go.dev/text/template](https://pkg.go.dev/text/template).\n\nWe have added all the available functions to the template engine as well as some additional ones that are useful for template building.\n\nAdditional Available Functions\n```go\n- ToUpper(s string) string   \t\t\t// Make string upper case\n- ToLower(s string) string   \t\t\t// Make string lower case\n- ToString(s any)            \t\t\t// Convert to string\n- ToDate(s string) time.Time \t\t\t// Convert string to date\n- SpliceAny(args ...any) []any \t\t\t// Build a slice of anys, used with Weighted\n- SpliceString(args ...string) []string // Build a slice of strings, used with Teams and RandomString\n- SpliceUInt(args ...uint) []uint \t\t// Build a slice of uint, used with Dice and RandomUint\n- SpliceInt(args ...int) []int \t\t\t// Build a slice of int, used with RandomInt\n```\n\n<details>\n  <summary>Unavailable Gofakeit functions</summary>\n\n```go\n// Any functions that dont have a return value\n- AnythingThatReturnsVoid(): void\n\n// Not available to use in templates\n- Template(co *TemplateOptions) ([]byte, error)\n- RandomMapKey(mapI any) any\n```\n</details>\n\n\n### Example Usages\n\n```go\nimport \"github.com/brianvoe/gofakeit/v7\"\n\nfunc main() {\n\t// Accessing the Lines variable from within the template.\n\ttemplate := `\n\tSubject: {{RandomString (SliceString \"Greetings\" \"Hello\" \"Hi\")}}\n\n\tDear {{LastName}},\n\n\t{{RandomString (SliceString \"Greetings!\" \"Hello there!\" \"Hi, how are you?\")}}\n\n\t{{Paragraph 1 5 10 \"\\n\\n\"}}\n\n\t{{RandomString (SliceString \"Warm regards\" \"Best wishes\" \"Sincerely\")}}\n\t{{$person:=Person}}\n\t{{$person.FirstName}} {{$person.LastName}}\n\t{{$person.Email}}\n\t{{$person.Phone}}\n\t`\n\n\tvalue, err := gofakeit.Template(template, &TemplateOptions{Data: 5})\n\n\tif err != nil {\n\t\tfmt.Println(err)\n\t}\n\n\tfmt.Println(string(value))\n}\n```\n\nOutput:\n```text\nSubject: Hello\n\nDear Krajcik,\n\nGreetings!\n\nQuia voluptatem voluptatem voluptatem. Quia voluptatem voluptatem voluptatem. Quia voluptatem voluptatem voluptatem.\n\nWarm regards\nKaitlyn Krajcik\nkaitlynkrajcik@krajcik\n570-245-7485\n```\n\n## Functions\n\nAll functions also exist as methods on the Faker struct\n\n### File\n\nPassing `nil` to `CSV`, `JSON` or `XML` will auto generate data using default values.\n\n```go\nCSV(co *CSVOptions) ([]byte, error)\nJSON(jo *JSONOptions) ([]byte, error)\nXML(xo *XMLOptions) ([]byte, error)\nFileExtension() string\nFileMimeType() string\n```\n\n### Template\n\nPassing `nil` will auto generate data using default values.\n\n```go\nTemplate(co *TemplateOptions) (string, error)\nMarkdown(co *MarkdownOptions) (string, error)\nEmailText(co *EmailOptions) (string, error)\nFixedWidth(co *FixedWidthOptions) (string, error)\n```\n\n### Product\n\n\n```go\nProduct() *ProductInfo\nProductName() string\nProductDescription() string\nProductCategory() string\nProductFeature() string\nProductMaterial() string\nProductUPC() string\nProductAudience() string\nProductDimension() string\nProductUseCase() string\nProductBenefit() string\nProductSuffix() string\n\n```\n\n### Person\n\n```go\nPerson() *PersonInfo\nName() string\nNamePrefix() string\nNameSuffix() string\nFirstName() string\nMiddleName() string\nLastName() string\nGender() string\nSSN() string\nHobby() string\nContact() *ContactInfo\nEmail() string\nPhone() string\nPhoneFormatted() string\nTeams(peopleArray []string, teamsArray []string) map[string][]string\n```\n\n### Generate\n\n```go\nStruct(v any)\nSlice(v any)\nMap() map[string]any\nGenerate(value string) string\nRegex(value string) string\n```\n\n### Auth\n\n```go\nUsername() string\nPassword(lower bool, upper bool, numeric bool, special bool, space bool, num int) string\n```\n\n### Address\n\n```go\nAddress() *AddressInfo\nCity() string\nCountry() string\nCountryAbr() string\nState() string\nStateAbr() string\nStreet() string\nStreetName() string\nStreetNumber() string\nStreetPrefix() string\nStreetSuffix() string\nZip() string\nLatitude() float64\nLatitudeInRange(min, max float64) (float64, error)\nLongitude() float64\nLongitudeInRange(min, max float64) (float64, error)\n```\n\n### Game\n\n```go\nGamertag() string\nDice(numDice uint, sides []uint) []uint\n```\n\n### Beer\n\n```go\nBeerAlcohol() string\nBeerBlg() string\nBeerHop() string\nBeerIbu() string\nBeerMalt() string\nBeerName() string\nBeerStyle() string\nBeerYeast() string\n```\n\n### Car\n\n```go\nCar() *CarInfo\nCarMaker() string\nCarModel() string\nCarType() string\nCarFuelType() string\nCarTransmissionType() string\n```\n\n### Words\n\n```go\n// Nouns\nNoun() string\nNounCommon() string\nNounConcrete() string\nNounAbstract() string\nNounCollectivePeople() string\nNounCollectiveAnimal() string\nNounCollectiveThing() string\nNounCountable() string\nNounUncountable() string\n\n// Verbs\nVerb() string\nVerbAction() string\nVerbLinking() string\nVerbHelping() string\n\n// Adverbs\nAdverb() string\nAdverbManner() string\nAdverbDegree() string\nAdverbPlace() string\nAdverbTimeDefinite() string\nAdverbTimeIndefinite() string\nAdverbFrequencyDefinite() string\nAdverbFrequencyIndefinite() string\n\n// Propositions\nPreposition() string\nPrepositionSimple() string\nPrepositionDouble() string\nPrepositionCompound() string\n\n// Adjectives\nAdjective() string\nAdjectiveDescriptive() string\nAdjectiveQuantitative() string\nAdjectiveProper() string\nAdjectiveDemonstrative() string\nAdjectivePossessive() string\nAdjectiveInterrogative() string\nAdjectiveIndefinite() string\n\n// Pronouns\nPronoun() string\nPronounPersonal() string\nPronounObject() string\nPronounPossessive() string\nPronounReflective() string\nPronounDemonstrative() string\nPronounInterrogative() string\nPronounRelative() string\n\n// Connectives\nConnective() string\nConnectiveTime() string\nConnectiveComparative() string\nConnectiveComplaint() string\nConnectiveListing() string\nConnectiveCasual() string\nConnectiveExamplify() string\n\n// Words\nWord() string\n\n// Sentences\nSentence(wordCount int) string\nParagraph(paragraphCount int, sentenceCount int, wordCount int, separator string) string\nLoremIpsumWord() string\nLoremIpsumSentence(wordCount int) string\nLoremIpsumParagraph(paragraphCount int, sentenceCount int, wordCount int, separator string) string\nQuestion() string\nQuote() string\nPhrase() string\n```\n\n### Foods\n\n```go\nFruit() string\nVegetable() string\nBreakfast() string\nLunch() string\nDinner() string\nSnack() string\nDessert() string\n```\n\n### Misc\n\n```go\nBool() bool\nUUID() string\nWeighted(options []any, weights []float32) (any, error)\nFlipACoin() string\nRandomMapKey(mapI any) any\nShuffleAnySlice(v any)\n```\n\n### Colors\n\n```go\nColor() string\nHexColor() string\nRGBColor() []int\nSafeColor() string\nNiceColors() string\n```\n\n### Images\n\n```go\nImage(width int, height int) *img.RGBA\nImageJpeg(width int, height int) []byte\nImagePng(width int, height int) []byte\n```\n\n### Internet\n\n```go\nURL() string\nDomainName() string\nDomainSuffix() string\nIPv4Address() string\nIPv6Address() string\nMacAddress() string\nHTTPStatusCode() string\nHTTPStatusCodeSimple() int\nLogLevel(logType string) string\nHTTPMethod() string\nHTTPVersion() string\nUserAgent() string\nChromeUserAgent() string\nFirefoxUserAgent() string\nOperaUserAgent() string\nSafariUserAgent() string\n```\n\n### HTML\n\n```go\nInputName() string\nSvg(options *SVGOptions) string\n```\n\n### Date/Time\n\n```go\nDate() time.Time\nPastDate() time.Time\nFutureDate() time.Time\nDateRange(start, end time.Time) time.Time\nNanoSecond() int\nSecond() int\nMinute() int\nHour() int\nMonth() int\nMonthString() string\nDay() int\nWeekDay() string\nYear() int\nTimeZone() string\nTimeZoneAbv() string\nTimeZoneFull() string\nTimeZoneOffset() float32\nTimeZoneRegion() string\n```\n\n### Payment\n\n```go\nPrice(min, max float64) float64\nCreditCard() *CreditCardInfo\nCreditCardCvv() string\nCreditCardExp() string\nCreditCardNumber(*CreditCardOptions) string\nCreditCardType() string\nCurrency() *CurrencyInfo\nCurrencyLong() string\nCurrencyShort() string\nAchRouting() string\nAchAccount() string\nBitcoinAddress() string\nBitcoinPrivateKey() string\n```\n\n### Finance\n\n```go\nCusip() string\nIsin() string\n```\n\n### Company\n\n```go\nBS() string\nBlurb() string\nBuzzWord() string\nCompany() string\nCompanySuffix() string\nJob() *JobInfo\nJobDescriptor() string\nJobLevel() string\nJobTitle() string\nSlogan() string\n```\n\n### Hacker\n\n```go\nHackerAbbreviation() string\nHackerAdjective() string\nHackeringverb() string\nHackerNoun() string\nHackerPhrase() string\nHackerVerb() string\n```\n\n### Hipster\n\n```go\nHipsterWord() string\nHipsterSentence(wordCount int) string\nHipsterParagraph(paragraphCount int, sentenceCount int, wordCount int, separator string) string\n```\n\n### App\n\n```go\nAppName() string\nAppVersion() string\nAppAuthor() string\n```\n\n### Animal\n\n```go\nPetName() string\nAnimal() string\nAnimalType() string\nFarmAnimal() string\nCat() string\nDog() string\nBird() string\n```\n\n### Emoji\n\n```go\nEmoji() string\nEmojiDescription() string\nEmojiCategory() string\nEmojiAlias() string\nEmojiTag() string\n```\n\n### Language\n\n```go\nLanguage() string\nLanguageAbbreviation() string\nProgrammingLanguage() string\nProgrammingLanguageBest() string\n```\n\n### Number\n\n```go\nNumber(min int, max int) int\nInt() int\nIntN(n int) int\nInt8() int8\nInt16() int16\nInt32() int32\nInt64() int64\nUint() uint\nUintN(n uint) uint\nUint8() uint8\nUint16() uint16\nUint32() uint32\nUint64() uint64\nFloat32() float32\nFloat32Range(min, max float32) float32\nFloat64() float64\nFloat64Range(min, max float64) float64\nShuffleInts(a []int)\nRandomInt(i []int) int\nHexUint(bitsize int) string\n```\n\n### String\n\n```go\nDigit() string\nDigitN(n uint) string\nLetter() string\nLetterN(n uint) string\nLexify(str string) string\nNumerify(str string) string\nShuffleStrings(a []string)\nRandomString(a []string) string\n```\n\n### Celebrity\n\n```go\nCelebrityActor() string\nCelebrityBusiness() string\nCelebritySport() string\n```\n\n### Minecraft\n\n```go\nMinecraftOre() string\nMinecraftWood() string\nMinecraftArmorTier() string\nMinecraftArmorPart() string\nMinecraftWeapon() string\nMinecraftTool() string\nMinecraftDye() string\nMinecraftFood() string\nMinecraftAnimal() string\nMinecraftVillagerJob() string\nMinecraftVillagerStation() string\nMinecraftVillagerLevel() string\nMinecraftMobPassive() string\nMinecraftMobNeutral() string\nMinecraftMobHostile() string\nMinecraftMobBoss() string\nMinecraftBiome() string\nMinecraftWeather() string\n```\n\n### Book\n\n```go\nBook() *BookInfo\nBookTitle() string\nBookAuthor() string\nBookGenre() string\n```\n\n### Movie\n\n```go\nMovie() *MovieInfo\nMovieName() string\nMovieGenre() string\n```\n\n### Error\n\n```go\nError() error\nErrorDatabase() error\nErrorGRPC() error\nErrorHTTP() error\nErrorHTTPClient() error\nErrorHTTPServer() error\nErrorInput() error\nErrorRuntime() error\n```\n\n### School\n\n```go\nSchool() string\n```\n"
        },
        {
          "name": "address.go",
          "type": "blob",
          "size": 13.0673828125,
          "content": "package gofakeit\n\nimport (\n\t\"errors\"\n\t\"strings\"\n)\n\n// AddressInfo is a struct full of address information\ntype AddressInfo struct {\n\tAddress   string  `json:\"address\" xml:\"address\"`\n\tStreet    string  `json:\"street\" xml:\"street\"`\n\tCity      string  `json:\"city\" xml:\"city\"`\n\tState     string  `json:\"state\" xml:\"state\"`\n\tZip       string  `json:\"zip\" xml:\"zip\"`\n\tCountry   string  `json:\"country\" xml:\"country\"`\n\tLatitude  float64 `json:\"latitude\" xml:\"latitude\"`\n\tLongitude float64 `json:\"longitude\" xml:\"longitude\"`\n}\n\n// Address will generate a struct of address information\nfunc Address() *AddressInfo { return address(GlobalFaker) }\n\n// Address will generate a struct of address information\nfunc (f *Faker) Address() *AddressInfo { return address(f) }\n\nfunc address(f *Faker) *AddressInfo {\n\tstreet := street(f)\n\tcity := city(f)\n\tstate := state(f)\n\tzip := zip(f)\n\n\treturn &AddressInfo{\n\t\tAddress:   street + \", \" + city + \", \" + state + \" \" + zip,\n\t\tStreet:    street,\n\t\tCity:      city,\n\t\tState:     state,\n\t\tZip:       zip,\n\t\tCountry:   country(f),\n\t\tLatitude:  latitude(f),\n\t\tLongitude: longitude(f),\n\t}\n}\n\n// Street will generate a random address street string\nfunc Street() string { return street(GlobalFaker) }\n\n// Street will generate a random address street string\nfunc (f *Faker) Street() string { return street(f) }\n\nfunc street(f *Faker) string {\n\tvar street = \"\"\n\tswitch randInt := randIntRange(f, 1, 2); randInt {\n\tcase 1:\n\t\tstreet = streetNumber(f) + \" \" + streetPrefix(f) + \" \" + streetName(f) + streetSuffix(f)\n\tcase 2:\n\t\tstreet = streetNumber(f) + \" \" + streetName(f) + streetSuffix(f)\n\t}\n\n\treturn street\n}\n\n// StreetNumber will generate a random address street number string\nfunc StreetNumber() string { return streetNumber(GlobalFaker) }\n\n// StreetNumber will generate a random address street number string\nfunc (f *Faker) StreetNumber() string { return streetNumber(f) }\n\nfunc streetNumber(f *Faker) string {\n\treturn strings.TrimLeft(replaceWithNumbers(f, getRandValue(f, []string{\"address\", \"number\"})), \"0\")\n}\n\n// StreetPrefix will generate a random address street prefix string\nfunc StreetPrefix() string { return streetPrefix(GlobalFaker) }\n\n// StreetPrefix will generate a random address street prefix string\nfunc (f *Faker) StreetPrefix() string { return streetPrefix(f) }\n\nfunc streetPrefix(f *Faker) string { return getRandValue(f, []string{\"address\", \"street_prefix\"}) }\n\n// StreetName will generate a random address street name string\nfunc StreetName() string { return streetName(GlobalFaker) }\n\n// StreetName will generate a random address street name string\nfunc (f *Faker) StreetName() string { return streetName(f) }\n\nfunc streetName(f *Faker) string { return getRandValue(f, []string{\"address\", \"street_name\"}) }\n\n// StreetSuffix will generate a random address street suffix string\nfunc StreetSuffix() string { return streetSuffix(GlobalFaker) }\n\n// StreetSuffix will generate a random address street suffix string\nfunc (f *Faker) StreetSuffix() string { return streetSuffix(f) }\n\nfunc streetSuffix(f *Faker) string { return getRandValue(f, []string{\"address\", \"street_suffix\"}) }\n\n// City will generate a random city string\nfunc City() string { return city(GlobalFaker) }\n\n// City will generate a random city string\nfunc (f *Faker) City() string { return city(f) }\n\nfunc city(f *Faker) string { return getRandValue(f, []string{\"address\", \"city\"}) }\n\n// State will generate a random state string\nfunc State() string { return state(GlobalFaker) }\n\n// State will generate a random state string\nfunc (f *Faker) State() string { return state(f) }\n\nfunc state(f *Faker) string { return getRandValue(f, []string{\"address\", \"state\"}) }\n\n// StateAbr will generate a random abbreviated state string\nfunc StateAbr() string { return stateAbr(GlobalFaker) }\n\n// StateAbr will generate a random abbreviated state string\nfunc (f *Faker) StateAbr() string { return stateAbr(f) }\n\nfunc stateAbr(f *Faker) string { return getRandValue(f, []string{\"address\", \"state_abr\"}) }\n\n// Zip will generate a random Zip code string\nfunc Zip() string { return zip(GlobalFaker) }\n\n// Zip will generate a random Zip code string\nfunc (f *Faker) Zip() string { return zip(f) }\n\nfunc zip(f *Faker) string {\n\treturn replaceWithNumbers(f, getRandValue(f, []string{\"address\", \"zip\"}))\n}\n\n// Country will generate a random country string\nfunc Country() string { return country(GlobalFaker) }\n\n// Country will generate a random country string\nfunc (f *Faker) Country() string { return country(f) }\n\nfunc country(f *Faker) string { return getRandValue(f, []string{\"address\", \"country\"}) }\n\n// CountryAbr will generate a random abbreviated country string\nfunc CountryAbr() string { return countryAbr(GlobalFaker) }\n\n// CountryAbr will generate a random abbreviated country string\nfunc (f *Faker) CountryAbr() string { return countryAbr(f) }\n\nfunc countryAbr(f *Faker) string { return getRandValue(f, []string{\"address\", \"country_abr\"}) }\n\n// Latitude will generate a random latitude float64\nfunc Latitude() float64 { return latitude(GlobalFaker) }\n\n// Latitude will generate a random latitude float64\nfunc (f *Faker) Latitude() float64 { return latitude(f) }\n\nfunc latitude(f *Faker) float64 { return toFixed((f.Float64()*180)-90, 6) }\n\n// LatitudeInRange will generate a random latitude within the input range\nfunc LatitudeInRange(min, max float64) (float64, error) {\n\treturn latitudeInRange(GlobalFaker, min, max)\n}\n\n// LatitudeInRange will generate a random latitude within the input range\nfunc (f *Faker) LatitudeInRange(min, max float64) (float64, error) {\n\treturn latitudeInRange(f, min, max)\n}\n\nfunc latitudeInRange(f *Faker, min, max float64) (float64, error) {\n\tif min > max || min < -90 || min > 90 || max < -90 || max > 90 {\n\t\treturn 0, errors.New(\"invalid min or max range, must be valid floats and between -90 and 90\")\n\t}\n\treturn toFixed(float64Range(f, min, max), 6), nil\n}\n\n// Longitude will generate a random longitude float64\nfunc Longitude() float64 { return longitude(GlobalFaker) }\n\n// Longitude will generate a random longitude float64\nfunc (f *Faker) Longitude() float64 { return longitude(f) }\n\nfunc longitude(f *Faker) float64 { return toFixed((f.Float64()*360)-180, 6) }\n\n// LongitudeInRange will generate a random longitude within the input range\nfunc LongitudeInRange(min, max float64) (float64, error) {\n\treturn longitudeInRange(GlobalFaker, min, max)\n}\n\n// LongitudeInRange will generate a random longitude within the input range\nfunc (f *Faker) LongitudeInRange(min, max float64) (float64, error) {\n\treturn longitudeInRange(f, min, max)\n}\n\nfunc longitudeInRange(f *Faker, min, max float64) (float64, error) {\n\tif min > max || min < -180 || min > 180 || max < -180 || max > 180 {\n\t\treturn 0, errors.New(\"invalid min or max range, must be valid floats and between -180 and 180\")\n\t}\n\treturn toFixed(float64Range(f, min, max), 6), nil\n}\n\nfunc addAddressLookup() {\n\tAddFuncLookup(\"address\", Info{\n\t\tDisplay:     \"Address\",\n\t\tCategory:    \"address\",\n\t\tDescription: \"Residential location including street, city, state, country and postal code\",\n\t\tExample: `{\n\t\"address\": \"364 Unionsville, Norfolk, Ohio 99536\",\n\t\"street\": \"364 Unionsville\",\n\t\"city\": \"Norfolk\",\n\t\"state\": \"Ohio\",\n\t\"zip\": \"99536\",\n\t\"country\": \"Lesotho\",\n\t\"latitude\": 88.792592,\n\t\"longitude\": 174.504681\n}`,\n\t\tOutput:      \"map[string]any\",\n\t\tContentType: \"application/json\",\n\t\tGenerate: func(f *Faker, m *MapParams, info *Info) (any, error) {\n\t\t\treturn address(f), nil\n\t\t},\n\t})\n\n\tAddFuncLookup(\"city\", Info{\n\t\tDisplay:     \"City\",\n\t\tCategory:    \"address\",\n\t\tDescription: \"Part of a country with significant population, often a central hub for culture and commerce\",\n\t\tExample:     \"Marcelside\",\n\t\tOutput:      \"string\",\n\t\tGenerate: func(f *Faker, m *MapParams, info *Info) (any, error) {\n\t\t\treturn city(f), nil\n\t\t},\n\t})\n\n\tAddFuncLookup(\"country\", Info{\n\t\tDisplay:     \"Country\",\n\t\tCategory:    \"address\",\n\t\tDescription: \"Nation with its own government and defined territory\",\n\t\tExample:     \"United States of America\",\n\t\tOutput:      \"string\",\n\t\tGenerate: func(f *Faker, m *MapParams, info *Info) (any, error) {\n\t\t\treturn country(f), nil\n\t\t},\n\t})\n\n\tAddFuncLookup(\"countryabr\", Info{\n\t\tDisplay:     \"Country Abbreviation\",\n\t\tCategory:    \"address\",\n\t\tDescription: \"Shortened 2-letter form of a country's name\",\n\t\tExample:     \"US\",\n\t\tOutput:      \"string\",\n\t\tGenerate: func(f *Faker, m *MapParams, info *Info) (any, error) {\n\t\t\treturn countryAbr(f), nil\n\t\t},\n\t})\n\n\tAddFuncLookup(\"state\", Info{\n\t\tDisplay:     \"State\",\n\t\tCategory:    \"address\",\n\t\tDescription: \"Governmental division within a country, often having its own laws and government\",\n\t\tExample:     \"Illinois\",\n\t\tOutput:      \"string\",\n\t\tGenerate: func(f *Faker, m *MapParams, info *Info) (any, error) {\n\t\t\treturn state(f), nil\n\t\t},\n\t})\n\n\tAddFuncLookup(\"stateabr\", Info{\n\t\tDisplay:     \"State Abbreviation\",\n\t\tCategory:    \"address\",\n\t\tDescription: \"Shortened 2-letter form of a country's state\",\n\t\tExample:     \"IL\",\n\t\tOutput:      \"string\",\n\t\tGenerate: func(f *Faker, m *MapParams, info *Info) (any, error) {\n\t\t\treturn stateAbr(f), nil\n\t\t},\n\t})\n\n\tAddFuncLookup(\"street\", Info{\n\t\tDisplay:     \"Street\",\n\t\tCategory:    \"address\",\n\t\tDescription: \"Public road in a city or town, typically with houses and buildings on each side\",\n\t\tExample:     \"364 East Rapidsborough\",\n\t\tOutput:      \"string\",\n\t\tGenerate: func(f *Faker, m *MapParams, info *Info) (any, error) {\n\t\t\treturn street(f), nil\n\t\t},\n\t})\n\n\tAddFuncLookup(\"streetname\", Info{\n\t\tDisplay:     \"Street Name\",\n\t\tCategory:    \"address\",\n\t\tDescription: \"Name given to a specific road or street\",\n\t\tExample:     \"View\",\n\t\tOutput:      \"string\",\n\t\tGenerate: func(f *Faker, m *MapParams, info *Info) (any, error) {\n\t\t\treturn streetName(f), nil\n\t\t},\n\t})\n\n\tAddFuncLookup(\"streetnumber\", Info{\n\t\tDisplay:     \"Street Number\",\n\t\tCategory:    \"address\",\n\t\tDescription: \"Numerical identifier assigned to a street\",\n\t\tExample:     \"13645\",\n\t\tOutput:      \"string\",\n\t\tGenerate: func(f *Faker, m *MapParams, info *Info) (any, error) {\n\t\t\treturn streetNumber(f), nil\n\t\t},\n\t})\n\n\tAddFuncLookup(\"streetprefix\", Info{\n\t\tDisplay:     \"Street Prefix\",\n\t\tCategory:    \"address\",\n\t\tDescription: \"Directional or descriptive term preceding a street name, like 'East' or 'Main'\",\n\t\tExample:     \"Lake\",\n\t\tOutput:      \"string\",\n\t\tGenerate: func(f *Faker, m *MapParams, info *Info) (any, error) {\n\t\t\treturn streetPrefix(f), nil\n\t\t},\n\t})\n\n\tAddFuncLookup(\"streetsuffix\", Info{\n\t\tDisplay:     \"Street Suffix\",\n\t\tCategory:    \"address\",\n\t\tDescription: \"Designation at the end of a street name indicating type, like 'Avenue' or 'Street'\",\n\t\tExample:     \"land\",\n\t\tOutput:      \"string\",\n\t\tGenerate: func(f *Faker, m *MapParams, info *Info) (any, error) {\n\t\t\treturn streetSuffix(f), nil\n\t\t},\n\t})\n\n\tAddFuncLookup(\"zip\", Info{\n\t\tDisplay:     \"Zip\",\n\t\tCategory:    \"address\",\n\t\tDescription: \"Numerical code for postal address sorting, specific to a geographic area\",\n\t\tExample:     \"13645\",\n\t\tOutput:      \"string\",\n\t\tGenerate: func(f *Faker, m *MapParams, info *Info) (any, error) {\n\t\t\treturn zip(f), nil\n\t\t},\n\t})\n\n\tAddFuncLookup(\"latitude\", Info{\n\t\tDisplay:     \"Latitude\",\n\t\tCategory:    \"address\",\n\t\tDescription: \"Geographic coordinate specifying north-south position on Earth's surface\",\n\t\tExample:     \"-73.534056\",\n\t\tOutput:      \"float\",\n\t\tGenerate: func(f *Faker, m *MapParams, info *Info) (any, error) {\n\t\t\treturn latitude(f), nil\n\t\t},\n\t})\n\n\tAddFuncLookup(\"latituderange\", Info{\n\t\tDisplay:     \"Latitude Range\",\n\t\tCategory:    \"address\",\n\t\tDescription: \"Latitude number between the given range (default min=0, max=90)\",\n\t\tExample:     \"22.921026\",\n\t\tOutput:      \"float\",\n\t\tParams: []Param{\n\t\t\t{Field: \"min\", Display: \"Min\", Type: \"float\", Default: \"0\", Description: \"Minimum range\"},\n\t\t\t{Field: \"max\", Display: \"Max\", Type: \"float\", Default: \"90\", Description: \"Maximum range\"},\n\t\t},\n\t\tGenerate: func(f *Faker, m *MapParams, info *Info) (any, error) {\n\t\t\tmin, err := info.GetFloat64(m, \"min\")\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\n\t\t\tmax, err := info.GetFloat64(m, \"max\")\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\n\t\t\trangeOut, err := latitudeInRange(f, min, max)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\n\t\t\treturn rangeOut, nil\n\t\t},\n\t})\n\n\tAddFuncLookup(\"longitude\", Info{\n\t\tDisplay:     \"Longitude\",\n\t\tCategory:    \"address\",\n\t\tDescription: \"Geographic coordinate indicating east-west position on Earth's surface\",\n\t\tExample:     \"-147.068112\",\n\t\tOutput:      \"float\",\n\t\tGenerate: func(f *Faker, m *MapParams, info *Info) (any, error) {\n\t\t\treturn longitude(f), nil\n\t\t},\n\t})\n\n\tAddFuncLookup(\"longituderange\", Info{\n\t\tDisplay:     \"Longitude Range\",\n\t\tCategory:    \"address\",\n\t\tDescription: \"Longitude number between the given range (default min=0, max=180)\",\n\t\tExample:     \"-8.170450\",\n\t\tOutput:      \"float\",\n\t\tParams: []Param{\n\t\t\t{Field: \"min\", Display: \"Min\", Type: \"float\", Default: \"0\", Description: \"Minimum range\"},\n\t\t\t{Field: \"max\", Display: \"Max\", Type: \"float\", Default: \"180\", Description: \"Maximum range\"},\n\t\t},\n\t\tGenerate: func(f *Faker, m *MapParams, info *Info) (any, error) {\n\t\t\tmin, err := info.GetFloat64(m, \"min\")\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\n\t\t\tmax, err := info.GetFloat64(m, \"max\")\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\n\t\t\trangeOut, err := longitudeInRange(f, min, max)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\n\t\t\treturn rangeOut, nil\n\t\t},\n\t})\n}\n"
        },
        {
          "name": "address_test.go",
          "type": "blob",
          "size": 6.0400390625,
          "content": "package gofakeit\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc ExampleAddress() {\n\tSeed(11)\n\taddress := Address()\n\tfmt.Println(address.Address)\n\tfmt.Println(address.Street)\n\tfmt.Println(address.City)\n\tfmt.Println(address.State)\n\tfmt.Println(address.Zip)\n\tfmt.Println(address.Country)\n\tfmt.Println(address.Latitude)\n\tfmt.Println(address.Longitude)\n\n\t// Output: 125 East Routemouth, North Las Vegas, South Dakota 17999\n\t// 125 East Routemouth\n\t// North Las Vegas\n\t// South Dakota\n\t// 17999\n\t// Iran (Islamic Republic of)\n\t// 83.558542\n\t// -159.896615\n}\n\nfunc ExampleFaker_Address() {\n\tf := New(11)\n\taddress := f.Address()\n\tfmt.Println(address.Address)\n\tfmt.Println(address.Street)\n\tfmt.Println(address.City)\n\tfmt.Println(address.State)\n\tfmt.Println(address.Zip)\n\tfmt.Println(address.Country)\n\tfmt.Println(address.Latitude)\n\tfmt.Println(address.Longitude)\n\n\t// Output: 125 East Routemouth, North Las Vegas, South Dakota 17999\n\t// 125 East Routemouth\n\t// North Las Vegas\n\t// South Dakota\n\t// 17999\n\t// Iran (Islamic Republic of)\n\t// 83.558542\n\t// -159.896615\n}\n\nfunc BenchmarkAddress(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tAddress()\n\t}\n}\n\nfunc ExampleStreet() {\n\tSeed(11)\n\tfmt.Println(Street())\n\n\t// Output: 125 East Routemouth\n}\n\nfunc ExampleFaker_Street() {\n\tf := New(11)\n\tfmt.Println(f.Street())\n\n\t// Output: 125 East Routemouth\n}\n\nfunc BenchmarkStreet(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tStreet()\n\t}\n}\n\nfunc ExampleStreetNumber() {\n\tSeed(11)\n\tfmt.Println(StreetNumber())\n\n\t// Output: 812\n}\n\nfunc ExampleFaker_StreetNumber() {\n\tf := New(11)\n\tfmt.Println(f.StreetNumber())\n\n\t// Output: 812\n}\n\nfunc BenchmarkStreetNumber(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tStreetNumber()\n\t}\n}\n\nfunc ExampleStreetPrefix() {\n\tSeed(11)\n\tfmt.Println(StreetPrefix())\n\n\t// Output: Port\n}\n\nfunc ExampleFaker_StreetPrefix() {\n\tf := New(11)\n\tfmt.Println(f.StreetPrefix())\n\n\t// Output: Port\n}\n\nfunc BenchmarkStreetPrefix(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tStreetPrefix()\n\t}\n}\n\nfunc ExampleStreetName() {\n\tSeed(11)\n\tfmt.Println(StreetName())\n\n\t// Output: Turnpike\n}\n\nfunc ExampleFaker_StreetName() {\n\tf := New(11)\n\tfmt.Println(f.StreetName())\n\n\t// Output: Turnpike\n}\n\nfunc BenchmarkStreetName(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tStreetName()\n\t}\n}\n\nfunc ExampleStreetSuffix() {\n\tSeed(11)\n\tfmt.Println(StreetSuffix())\n\n\t// Output: side\n}\n\nfunc ExampleFaker_StreetSuffix() {\n\tf := New(11)\n\tfmt.Println(f.StreetSuffix())\n\n\t// Output: side\n}\n\nfunc BenchmarkStreetSuffix(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tStreetSuffix()\n\t}\n}\n\nfunc ExampleCity() {\n\tSeed(11)\n\tfmt.Println(City())\n\n\t// Output: Reno\n}\n\nfunc ExampleFaker_City() {\n\tf := New(11)\n\tfmt.Println(f.City())\n\n\t// Output: Reno\n}\n\nfunc TestCity(t *testing.T) {\n\tfor i := 0; i < 100; i++ {\n\t\tCity()\n\t}\n}\n\nfunc BenchmarkCity(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tCity()\n\t}\n}\n\nfunc ExampleState() {\n\tSeed(11)\n\tfmt.Println(State())\n\n\t// Output: Vermont\n}\n\nfunc ExampleFaker_State() {\n\tf := New(11)\n\tfmt.Println(f.State())\n\n\t// Output: Vermont\n}\n\nfunc BenchmarkState(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tState()\n\t}\n}\n\nfunc ExampleStateAbr() {\n\tSeed(11)\n\tfmt.Println(StateAbr())\n\n\t// Output: WV\n}\n\nfunc ExampleFaker_StateAbr() {\n\tf := New(11)\n\tfmt.Println(f.StateAbr())\n\n\t// Output: WV\n}\n\nfunc BenchmarkStateAbr(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tStateAbr()\n\t}\n}\n\nfunc ExampleZip() {\n\tSeed(11)\n\tfmt.Println(Zip())\n\n\t// Output: 81252\n}\n\nfunc ExampleFaker_Zip() {\n\tf := New(11)\n\tfmt.Println(f.Zip())\n\n\t// Output: 81252\n}\n\nfunc BenchmarkZip(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tZip()\n\t}\n}\n\nfunc ExampleCountry() {\n\tSeed(11)\n\tfmt.Println(Country())\n\n\t// Output: Tonga\n}\n\nfunc ExampleFaker_Country() {\n\tf := New(11)\n\tfmt.Println(f.Country())\n\n\t// Output: Tonga\n}\n\nfunc BenchmarkCountry(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tCountry()\n\t}\n}\n\nfunc ExampleCountryAbr() {\n\tSeed(11)\n\tfmt.Println(CountryAbr())\n\n\t// Output: TO\n}\n\nfunc ExampleFaker_CountryAbr() {\n\tf := New(11)\n\tfmt.Println(f.CountryAbr())\n\n\t// Output: TO\n}\n\nfunc BenchmarkCountryAbr(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tCountryAbr()\n\t}\n}\n\nfunc ExampleLatitude() {\n\tSeed(11)\n\tfmt.Println(Latitude())\n\n\t// Output: 48.654167\n}\n\nfunc ExampleFaker_Latitude() {\n\tf := New(11)\n\tfmt.Println(f.Latitude())\n\n\t// Output: 48.654167\n}\n\nfunc BenchmarkLatitude(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tLatitude()\n\t}\n}\n\nfunc ExampleLongitude() {\n\tSeed(11)\n\tfmt.Println(Longitude())\n\n\t// Output: 97.308335\n}\n\nfunc ExampleFaker_Longitude() {\n\tf := New(11)\n\tfmt.Println(f.Longitude())\n\n\t// Output: 97.308335\n}\n\nfunc BenchmarkLongitude(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tLongitude()\n\t}\n}\n\nfunc TestLatitudeInRange(t *testing.T) {\n\tSeed(11)\n\tlat, err := LatitudeInRange(21, 42)\n\tif err != nil {\n\t\tt.Error(\"error should be nil\")\n\t}\n\n\tif lat == 0 {\n\t\tt.Error(\"lat should be not be zero\")\n\t}\n\n\t_, err = LatitudeInRange(50, 42)\n\tif err == nil {\n\t\tt.Error(\"error should be not be nil\")\n\t}\n\n\t_, err = LatitudeInRange(-100, 42)\n\tif err == nil {\n\t\tt.Error(\"error should be not be nil\")\n\t}\n}\n\nfunc ExampleLatitudeInRange() {\n\tSeed(11)\n\tlat, _ := LatitudeInRange(21, 42)\n\tfmt.Println(lat)\n\n\t// Output: 37.176319\n}\n\nfunc ExampleFaker_LatitudeInRange() {\n\tf := New(11)\n\tlat, _ := f.LatitudeInRange(21, 42)\n\tfmt.Println(lat)\n\n\t// Output: 37.176319\n}\n\nfunc BenchmarkLatitudeInRange(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tLatitudeInRange(-90, 90)\n\t}\n}\n\nfunc TestLongitudeInRange(t *testing.T) {\n\tSeed(11)\n\tlong, err := LongitudeInRange(21, 42)\n\tif err != nil {\n\t\tt.Error(\"error should be nil\")\n\t}\n\n\tif long == 0 {\n\t\tt.Error(\"long should be not be zero\")\n\t}\n\n\t_, err = LongitudeInRange(-32, -42)\n\tif err == nil {\n\t\tt.Error(\"error should be not be nil\")\n\t}\n\n\t_, err = LongitudeInRange(190, 192)\n\tif err == nil {\n\t\tt.Error(\"error should be not be nil\")\n\t}\n}\n\nfunc ExampleLongitudeInRange() {\n\tSeed(11)\n\tlong, _ := LongitudeInRange(-10, 10)\n\tfmt.Println(long)\n\n\t// Output: 5.406018\n}\n\nfunc ExampleFaker_LongitudeInRange() {\n\tf := New(11)\n\tlong, _ := f.LongitudeInRange(-10, 10)\n\tfmt.Println(long)\n\n\t// Output: 5.406018\n}\n\nfunc BenchmarkLongitudeInRange(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tLongitudeInRange(-180, 180)\n\t}\n}\n"
        },
        {
          "name": "animal.go",
          "type": "blob",
          "size": 4.06640625,
          "content": "package gofakeit\n\n// PetName will return a random fun pet name\nfunc PetName() string {\n\treturn petName(GlobalFaker)\n}\n\n// PetName will return a random fun pet name\nfunc (f *Faker) PetName() string {\n\treturn petName(f)\n}\n\nfunc petName(f *Faker) string {\n\treturn getRandValue(f, []string{\"animal\", \"petname\"})\n}\n\n// Animal will return a random animal\nfunc Animal() string {\n\treturn animal(GlobalFaker)\n}\n\n// Animal will return a random animal\nfunc (f *Faker) Animal() string {\n\treturn animal(f)\n}\n\nfunc animal(f *Faker) string {\n\treturn getRandValue(f, []string{\"animal\", \"animal\"})\n}\n\n// AnimalType will return a random animal type\nfunc AnimalType() string {\n\treturn animalType(GlobalFaker)\n}\n\n// AnimalType will return a random animal type\nfunc (f *Faker) AnimalType() string {\n\treturn animalType(f)\n}\n\nfunc animalType(f *Faker) string {\n\treturn getRandValue(f, []string{\"animal\", \"type\"})\n}\n\n// FarmAnimal will return a random animal that usually lives on a farm\nfunc FarmAnimal() string {\n\treturn farmAnimal(GlobalFaker)\n}\n\n// FarmAnimal will return a random animal that usually lives on a farm\nfunc (f *Faker) FarmAnimal() string {\n\treturn farmAnimal(f)\n}\n\nfunc farmAnimal(f *Faker) string {\n\treturn getRandValue(f, []string{\"animal\", \"farm\"})\n}\n\n// Cat will return a random cat breed\nfunc Cat() string {\n\treturn cat(GlobalFaker)\n}\n\n// Cat will return a random cat breed\nfunc (f *Faker) Cat() string {\n\treturn cat(f)\n}\n\nfunc cat(f *Faker) string {\n\treturn getRandValue(f, []string{\"animal\", \"cat\"})\n}\n\n// Dog will return a random dog breed\nfunc Dog() string {\n\treturn dog(GlobalFaker)\n}\n\n// Dog will return a random dog breed\nfunc (f *Faker) Dog() string {\n\treturn dog(f)\n}\n\nfunc dog(f *Faker) string {\n\treturn getRandValue(f, []string{\"animal\", \"dog\"})\n}\n\n// Bird will return a random bird species\nfunc Bird() string {\n\treturn bird(GlobalFaker)\n}\n\n// Bird will return a random bird species\nfunc (f *Faker) Bird() string {\n\treturn bird(f)\n}\n\nfunc bird(f *Faker) string {\n\treturn getRandValue(f, []string{\"animal\", \"bird\"})\n}\n\nfunc addAnimalLookup() {\n\tAddFuncLookup(\"petname\", Info{\n\t\tDisplay:     \"Pet Name\",\n\t\tCategory:    \"animal\",\n\t\tDescription: \"Affectionate nickname given to a pet\",\n\t\tExample:     \"Ozzy Pawsborne\",\n\t\tOutput:      \"string\",\n\t\tGenerate: func(f *Faker, m *MapParams, info *Info) (any, error) {\n\t\t\treturn petName(f), nil\n\t\t},\n\t})\n\n\tAddFuncLookup(\"animal\", Info{\n\t\tDisplay:     \"Animal\",\n\t\tCategory:    \"animal\",\n\t\tDescription: \"Living creature with the ability to move, eat, and interact with its environment\",\n\t\tExample:     \"elk\",\n\t\tOutput:      \"string\",\n\t\tGenerate: func(f *Faker, m *MapParams, info *Info) (any, error) {\n\t\t\treturn animal(f), nil\n\t\t},\n\t})\n\n\tAddFuncLookup(\"animaltype\", Info{\n\t\tDisplay:     \"Animal Type\",\n\t\tCategory:    \"animal\",\n\t\tDescription: \"Type of animal, such as mammals, birds, reptiles, etc.\",\n\t\tExample:     \"amphibians\",\n\t\tOutput:      \"string\",\n\t\tGenerate: func(f *Faker, m *MapParams, info *Info) (any, error) {\n\t\t\treturn animalType(f), nil\n\t\t},\n\t})\n\n\tAddFuncLookup(\"farmanimal\", Info{\n\t\tDisplay:     \"Farm Animal\",\n\t\tCategory:    \"animal\",\n\t\tDescription: \"Animal name commonly found on a farm\",\n\t\tExample:     \"Chicken\",\n\t\tOutput:      \"string\",\n\t\tGenerate: func(f *Faker, m *MapParams, info *Info) (any, error) {\n\t\t\treturn farmAnimal(f), nil\n\t\t},\n\t})\n\n\tAddFuncLookup(\"cat\", Info{\n\t\tDisplay:     \"Cat\",\n\t\tCategory:    \"animal\",\n\t\tDescription: \"Various breeds that define different cats\",\n\t\tExample:     \"Chausie\",\n\t\tOutput:      \"string\",\n\t\tGenerate: func(f *Faker, m *MapParams, info *Info) (any, error) {\n\t\t\treturn cat(f), nil\n\t\t},\n\t})\n\n\tAddFuncLookup(\"dog\", Info{\n\t\tDisplay:     \"Dog\",\n\t\tCategory:    \"animal\",\n\t\tDescription: \"Various breeds that define different dogs\",\n\t\tExample:     \"Norwich Terrier\",\n\t\tOutput:      \"string\",\n\t\tGenerate: func(f *Faker, m *MapParams, info *Info) (any, error) {\n\t\t\treturn dog(f), nil\n\t\t},\n\t})\n\n\tAddFuncLookup(\"bird\", Info{\n\t\tDisplay:     \"Bird\",\n\t\tCategory:    \"animal\",\n\t\tDescription: \"Distinct species of birds\",\n\t\tExample:     \"goose\",\n\t\tOutput:      \"string\",\n\t\tGenerate: func(f *Faker, m *MapParams, info *Info) (any, error) {\n\t\t\treturn bird(f), nil\n\t\t},\n\t})\n}\n"
        },
        {
          "name": "animal_test.go",
          "type": "blob",
          "size": 1.8134765625,
          "content": "package gofakeit\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc ExamplePetName() {\n\tSeed(11)\n\tfmt.Println(PetName())\n\n\t// Output: The Notorious D.O.G.\n}\n\nfunc ExampleFaker_PetName() {\n\tf := New(11)\n\tfmt.Println(f.PetName())\n\n\t// Output: The Notorious D.O.G.\n}\n\nfunc BenchmarkPetName(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tPetName()\n\t}\n}\n\nfunc ExampleAnimal() {\n\tSeed(11)\n\tfmt.Println(Animal())\n\n\t// Output: turtle\n}\n\nfunc ExampleFaker_Animal() {\n\tf := New(11)\n\tfmt.Println(f.Animal())\n\n\t// Output: turtle\n}\n\nfunc BenchmarkAnimal(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tAnimal()\n\t}\n}\n\nfunc ExampleAnimalType() {\n\tSeed(11)\n\tfmt.Println(AnimalType())\n\n\t// Output: reptiles\n}\n\nfunc ExampleFaker_AnimalType() {\n\tf := New(11)\n\tfmt.Println(f.AnimalType())\n\n\t// Output: reptiles\n}\n\nfunc BenchmarkAnimalType(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tAnimalType()\n\t}\n}\n\nfunc ExampleFarmAnimal() {\n\tSeed(11)\n\tfmt.Println(FarmAnimal())\n\n\t// Output: Sheep\n}\n\nfunc ExampleFaker_FarmAnimal() {\n\tf := New(11)\n\tfmt.Println(f.FarmAnimal())\n\n\t// Output: Sheep\n}\n\nfunc BenchmarkFarmAnimal(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tFarmAnimal()\n\t}\n}\n\nfunc ExampleCat() {\n\tSeed(11)\n\tfmt.Println(Cat())\n\n\t// Output: Sokoke\n}\n\nfunc ExampleFaker_Cat() {\n\tf := New(11)\n\tfmt.Println(f.Cat())\n\n\t// Output: Sokoke\n}\n\nfunc BenchmarkCat(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tCat()\n\t}\n}\n\nfunc ExampleDog() {\n\tSeed(11)\n\tfmt.Println(Dog())\n\n\t// Output: Rat Terrier\n}\n\nfunc ExampleFaker_Dog() {\n\tf := New(11)\n\tfmt.Println(f.Dog())\n\n\t// Output: Rat Terrier\n}\n\nfunc BenchmarkDog(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tDog()\n\t}\n}\n\nfunc ExampleBird() {\n\tSeed(11)\n\tfmt.Println(Bird())\n\n\t// Output: toucan\n}\n\nfunc ExampleFaker_Bird() {\n\tf := New(11)\n\tfmt.Println(f.Bird())\n\n\t// Output: toucan\n}\n\nfunc BenchmarkBird(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tBird()\n\t}\n}\n"
        },
        {
          "name": "app.go",
          "type": "blob",
          "size": 2.09765625,
          "content": "package gofakeit\n\nimport (\n\t\"fmt\"\n)\n\n// AppName will generate a random app name\nfunc AppName() string {\n\treturn appName(GlobalFaker)\n}\n\n// AppName will generate a random app name\nfunc (f *Faker) AppName() string {\n\treturn appName(f)\n}\n\nfunc appName(f *Faker) string {\n\tname := \"\"\n\tswitch number(f, 1, 3) {\n\tcase 1:\n\t\tname = noun(f) + verb(f)\n\tcase 2:\n\t\tname = color(f) + noun(f)\n\tcase 3:\n\t\tname = animal(f) + verb(f)\n\t}\n\n\treturn title(name)\n}\n\n// AppVersion will generate a random app version\nfunc AppVersion() string {\n\treturn appVersion(GlobalFaker)\n}\n\n// AppVersion will generate a random app version\nfunc (f *Faker) AppVersion() string {\n\treturn appVersion(f)\n}\n\nfunc appVersion(f *Faker) string {\n\treturn fmt.Sprintf(\"%d.%d.%d\", number(f, 1, 5), number(f, 1, 20), number(f, 1, 20))\n}\n\n// AppAuthor will generate a random company or person name\nfunc AppAuthor() string {\n\treturn appAuthor(GlobalFaker)\n}\n\n// AppAuthor will generate a random company or person name\nfunc (f *Faker) AppAuthor() string {\n\treturn appAuthor(f)\n}\n\nfunc appAuthor(f *Faker) string {\n\tif boolFunc(f) {\n\t\treturn name(f)\n\t}\n\n\treturn company(f)\n}\n\nfunc addAppLookup() {\n\tAddFuncLookup(\"appname\", Info{\n\t\tDisplay:     \"App Name\",\n\t\tCategory:    \"app\",\n\t\tDescription: \"Software program designed for a specific purpose or task on a computer or mobile device\",\n\t\tExample:     \"Parkrespond\",\n\t\tOutput:      \"string\",\n\t\tGenerate: func(f *Faker, m *MapParams, info *Info) (any, error) {\n\t\t\treturn appName(f), nil\n\t\t},\n\t})\n\n\tAddFuncLookup(\"appversion\", Info{\n\t\tDisplay:     \"App Version\",\n\t\tCategory:    \"app\",\n\t\tDescription: \"Particular release of an application in Semantic Versioning format\",\n\t\tExample:     \"1.12.14\",\n\t\tOutput:      \"string\",\n\t\tGenerate: func(f *Faker, m *MapParams, info *Info) (any, error) {\n\t\t\treturn appVersion(f), nil\n\t\t},\n\t})\n\n\tAddFuncLookup(\"appauthor\", Info{\n\t\tDisplay:     \"App Author\",\n\t\tCategory:    \"app\",\n\t\tDescription: \"Person or group creating and developing an application\",\n\t\tExample:     \"Qado Energy, Inc.\",\n\t\tOutput:      \"string\",\n\t\tGenerate: func(f *Faker, m *MapParams, info *Info) (any, error) {\n\t\t\treturn appAuthor(f), nil\n\t\t},\n\t})\n}\n"
        },
        {
          "name": "app_test.go",
          "type": "blob",
          "size": 1.1484375,
          "content": "package gofakeit\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc ExampleAppName() {\n\tSeed(11)\n\tfmt.Println(AppName())\n\n\t// Output: Swanthink\n}\n\nfunc ExampleFaker_AppName() {\n\tf := New(11)\n\tfmt.Println(f.AppName())\n\n\t// Output: Swanthink\n}\n\nfunc TestAppName(t *testing.T) {\n\tfor i := 0; i < 100; i++ {\n\t\tname := AppName()\n\t\tif name == \"\" {\n\t\t\tt.Error(\"app name should not be empty\")\n\t\t}\n\t}\n}\n\nfunc BenchmarkAppName(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tAppName()\n\t}\n}\n\nfunc ExampleAppVersion() {\n\tSeed(11)\n\tfmt.Println(AppVersion())\n\n\t// Output: 5.18.4\n}\n\nfunc ExampleFaker_AppVersion() {\n\tf := New(11)\n\tfmt.Println(f.AppVersion())\n\n\t// Output: 5.18.4\n}\n\nfunc BenchmarkAppVersion(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tAppVersion()\n\t}\n}\n\nfunc ExampleAppAuthor() {\n\tSeed(11)\n\tfmt.Println(AppAuthor())\n\n\t// Output: StreetEasy\n}\n\nfunc ExampleFaker_AppAuthor() {\n\tf := New(11)\n\tfmt.Println(f.AppAuthor())\n\n\t// Output: StreetEasy\n}\n\nfunc TestAuthor(t *testing.T) {\n\tfor i := 0; i < 100; i++ {\n\t\tauthor := AppAuthor()\n\t\tif author == \"\" {\n\t\t\tt.Error(\"app author should not be empty\")\n\t\t}\n\t}\n}\n\nfunc BenchmarkAppAuthor(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tAppAuthor()\n\t}\n}\n"
        },
        {
          "name": "auth.go",
          "type": "blob",
          "size": 4.650390625,
          "content": "package gofakeit\n\n// Username will generate a random username based upon picking a random lastname and random numbers at the end\nfunc Username() string {\n\treturn username(GlobalFaker)\n}\n\n// Username will generate a random username based upon picking a random lastname and random numbers at the end\nfunc (f *Faker) Username() string {\n\treturn username(f)\n}\n\nfunc username(f *Faker) string {\n\treturn getRandValue(f, []string{\"person\", \"last\"}) + replaceWithNumbers(f, \"####\")\n}\n\n// Password will generate a random password.\n// Minimum number length of 5 if less than.\nfunc Password(lower bool, upper bool, numeric bool, special bool, space bool, num int) string {\n\treturn password(GlobalFaker, lower, upper, numeric, special, space, num)\n}\n\n// Password will generate a random password.\n// Minimum number length of 5 if less than.\nfunc (f *Faker) Password(lower bool, upper bool, numeric bool, special bool, space bool, num int) string {\n\treturn password(f, lower, upper, numeric, special, space, num)\n}\n\nfunc password(f *Faker, lower bool, upper bool, numeric bool, special bool, space bool, num int) string {\n\t// Make sure the num minimum is at least 5\n\tif num < 5 {\n\t\tnum = 5\n\t}\n\n\t// Setup weights\n\titems := make([]any, 0)\n\tweights := make([]float32, 0)\n\tif lower {\n\t\titems = append(items, \"l\")\n\t\tweights = append(weights, 4)\n\t}\n\tif upper {\n\t\titems = append(items, \"u\")\n\t\tweights = append(weights, 4)\n\t}\n\tif numeric {\n\t\titems = append(items, \"n\")\n\t\tweights = append(weights, 3)\n\t}\n\tif special {\n\t\titems = append(items, \"e\")\n\t\tweights = append(weights, 2)\n\t}\n\tif space {\n\t\titems = append(items, \"a\")\n\t\tweights = append(weights, 1)\n\t}\n\n\t// If no items are selected then default to lower, upper, numeric\n\tif len(items) == 0 {\n\t\titems = append(items, \"l\", \"u\", \"n\")\n\t\tweights = append(weights, 4, 4, 3)\n\t}\n\n\t// Create byte slice\n\tb := make([]byte, num)\n\n\tfor i := 0; i <= num-1; i++ {\n\t\t// Run weighted\n\t\tweight, _ := weighted(f, items, weights)\n\n\t\tswitch weight.(string) {\n\t\tcase \"l\":\n\t\t\tb[i] = lowerStr[f.Int64()%int64(len(lowerStr))]\n\t\tcase \"u\":\n\t\t\tb[i] = upperStr[f.Int64()%int64(len(upperStr))]\n\t\tcase \"n\":\n\t\t\tb[i] = numericStr[f.Int64()%int64(len(numericStr))]\n\t\tcase \"e\":\n\t\t\tb[i] = specialSafeStr[f.Int64()%int64(len(specialSafeStr))]\n\t\tcase \"a\":\n\t\t\tb[i] = spaceStr[f.Int64()%int64(len(spaceStr))]\n\t\t}\n\t}\n\n\t// Shuffle bytes\n\tfor i := range b {\n\t\tj := f.IntN(i + 1)\n\t\tb[i], b[j] = b[j], b[i]\n\t}\n\n\t// Replace first or last character if it's a space, and other options are available\n\tif b[0] == ' ' {\n\t\tb[0] = password(f, lower, upper, numeric, special, false, 1)[0]\n\t}\n\tif b[len(b)-1] == ' ' {\n\t\tb[len(b)-1] = password(f, lower, upper, numeric, special, false, 1)[0]\n\t}\n\n\treturn string(b)\n}\n\nfunc addAuthLookup() {\n\tAddFuncLookup(\"username\", Info{\n\t\tDisplay:     \"Username\",\n\t\tCategory:    \"auth\",\n\t\tDescription: \"Unique identifier assigned to a user for accessing an account or system\",\n\t\tExample:     \"Daniel1364\",\n\t\tOutput:      \"string\",\n\t\tGenerate: func(f *Faker, m *MapParams, info *Info) (any, error) {\n\t\t\treturn username(f), nil\n\t\t},\n\t})\n\n\tAddFuncLookup(\"password\", Info{\n\t\tDisplay:     \"Password\",\n\t\tCategory:    \"auth\",\n\t\tDescription: \"Secret word or phrase used to authenticate access to a system or account\",\n\t\tExample:     \"EEP+wwpk 4lU-eHNXlJZ4n K9%v&TZ9e\",\n\t\tOutput:      \"string\",\n\t\tParams: []Param{\n\t\t\t{Field: \"lower\", Display: \"Lower\", Type: \"bool\", Default: \"true\", Description: \"Whether or not to add lower case characters\"},\n\t\t\t{Field: \"upper\", Display: \"Upper\", Type: \"bool\", Default: \"true\", Description: \"Whether or not to add upper case characters\"},\n\t\t\t{Field: \"numeric\", Display: \"Numeric\", Type: \"bool\", Default: \"true\", Description: \"Whether or not to add numeric characters\"},\n\t\t\t{Field: \"special\", Display: \"Special\", Type: \"bool\", Default: \"true\", Description: \"Whether or not to add special characters\"},\n\t\t\t{Field: \"space\", Display: \"Space\", Type: \"bool\", Default: \"false\", Description: \"Whether or not to add spaces\"},\n\t\t\t{Field: \"length\", Display: \"Length\", Type: \"int\", Default: \"12\", Description: \"Number of characters in password\"},\n\t\t},\n\t\tGenerate: func(f *Faker, m *MapParams, info *Info) (any, error) {\n\t\t\tlower, err := info.GetBool(m, \"lower\")\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\n\t\t\tupper, err := info.GetBool(m, \"upper\")\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\n\t\t\tnumeric, err := info.GetBool(m, \"numeric\")\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\n\t\t\tspecial, err := info.GetBool(m, \"special\")\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\n\t\t\tspace, err := info.GetBool(m, \"space\")\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\n\t\t\tlength, err := info.GetInt(m, \"length\")\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\n\t\t\treturn password(f, lower, upper, numeric, special, space, length), nil\n\t\t},\n\t})\n}\n"
        },
        {
          "name": "auth_test.go",
          "type": "blob",
          "size": 2.197265625,
          "content": "package gofakeit\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc ExampleUsername() {\n\tSeed(11)\n\tfmt.Println(Username())\n\n\t// Output: Treutel8125\n}\n\nfunc ExampleFaker_Username() {\n\tf := New(11)\n\tfmt.Println(f.Username())\n\n\t// Output: Treutel8125\n}\n\nfunc BenchmarkUsername(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tUsername()\n\t}\n}\n\nfunc TestPassword(t *testing.T) {\n\tlength := 10\n\n\tpass := Password(true, true, true, true, true, length)\n\n\tif len(pass) != length {\n\t\tt.Error(\"Password length does not equal requested length\")\n\t}\n\n\t// Test fully empty\n\tpass = Password(false, false, false, false, false, length)\n\tif pass == \"\" {\n\t\tt.Error(\"Password should not be empty\")\n\t}\n\n\t// Test it doesnt start or end with a space\n\tfor i := 0; i < 1000; i++ {\n\t\tpass = Password(true, true, true, true, true, length)\n\t\tif pass[0] == ' ' || pass[len(pass)-1] == ' ' {\n\t\t\tt.Error(\"Password should not start or end with a space\")\n\t\t}\n\t}\n}\n\nfunc ExamplePassword() {\n\tSeed(11)\n\tfmt.Println(Password(true, false, false, false, false, 32))\n\tfmt.Println(Password(false, true, false, false, false, 32))\n\tfmt.Println(Password(false, false, true, false, false, 32))\n\tfmt.Println(Password(false, false, false, true, false, 32))\n\tfmt.Println(Password(true, true, true, true, true, 32))\n\tfmt.Println(Password(true, true, true, true, true, 4))\n\n\t// Output: cfelntbponnbbzrhswobuwlxajeeclrx\n\t// KYEKNGUUNKUYSFBUFFTGDKUVCVYKPONP\n\t// 43622637275953627791234759581343\n\t// @.__-._-!-!_..!-_*_*__-@*.__.__!\n\t// -DTHJ@.oF@d@L5F65 N-.@U5xWX F0DI\n\t// foZnB\n}\n\nfunc ExampleFaker_Password() {\n\tf := New(11)\n\tfmt.Println(f.Password(true, false, false, false, false, 32))\n\tfmt.Println(f.Password(false, true, false, false, false, 32))\n\tfmt.Println(f.Password(false, false, true, false, false, 32))\n\tfmt.Println(f.Password(false, false, false, true, false, 32))\n\tfmt.Println(f.Password(true, true, true, true, true, 32))\n\tfmt.Println(f.Password(true, true, true, true, true, 4))\n\n\t// Output: cfelntbponnbbzrhswobuwlxajeeclrx\n\t// KYEKNGUUNKUYSFBUFFTGDKUVCVYKPONP\n\t// 43622637275953627791234759581343\n\t// @.__-._-!-!_..!-_*_*__-@*.__.__!\n\t// -DTHJ@.oF@d@L5F65 N-.@U5xWX F0DI\n\t// foZnB\n}\n\nfunc BenchmarkPassword(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tPassword(true, true, true, true, true, 50)\n\t}\n}\n"
        },
        {
          "name": "beer.go",
          "type": "blob",
          "size": 5.0390625,
          "content": "package gofakeit\n\nimport (\n\t\"strconv\"\n)\n\n// BeerName will return a random beer name\nfunc BeerName() string {\n\treturn beerName(GlobalFaker)\n}\n\n// BeerName will return a random beer name\nfunc (f *Faker) BeerName() string {\n\treturn beerName(f)\n}\n\nfunc beerName(f *Faker) string {\n\treturn getRandValue(f, []string{\"beer\", \"name\"})\n}\n\n// BeerStyle will return a random beer style\nfunc BeerStyle() string {\n\treturn beerStyle(GlobalFaker)\n}\n\n// BeerStyle will return a random beer style\nfunc (f *Faker) BeerStyle() string {\n\treturn beerStyle(f)\n}\n\nfunc beerStyle(f *Faker) string {\n\treturn getRandValue(f, []string{\"beer\", \"style\"})\n}\n\n// BeerHop will return a random beer hop\nfunc BeerHop() string {\n\treturn beerHop(GlobalFaker)\n}\n\n// BeerHop will return a random beer hop\nfunc (f *Faker) BeerHop() string {\n\treturn beerHop(f)\n}\n\nfunc beerHop(f *Faker) string {\n\treturn getRandValue(f, []string{\"beer\", \"hop\"})\n}\n\n// BeerYeast will return a random beer yeast\nfunc BeerYeast() string {\n\treturn beerYeast(GlobalFaker)\n}\n\n// BeerYeast will return a random beer yeast\nfunc (f *Faker) BeerYeast() string {\n\treturn beerYeast(f)\n}\n\nfunc beerYeast(f *Faker) string {\n\treturn getRandValue(f, []string{\"beer\", \"yeast\"})\n}\n\n// BeerMalt will return a random beer malt\nfunc BeerMalt() string {\n\treturn beerMalt(GlobalFaker)\n}\n\n// BeerMalt will return a random beer malt\nfunc (f *Faker) BeerMalt() string {\n\treturn beerMalt(f)\n}\n\nfunc beerMalt(f *Faker) string {\n\treturn getRandValue(f, []string{\"beer\", \"malt\"})\n}\n\n// BeerAlcohol will return a random beer alcohol level between 2.0 and 10.0\nfunc BeerAlcohol() string {\n\treturn beerAlcohol(GlobalFaker)\n}\n\n// BeerAlcohol will return a random beer alcohol level between 2.0 and 10.0\nfunc (f *Faker) BeerAlcohol() string {\n\treturn beerAlcohol(f)\n}\n\nfunc beerAlcohol(f *Faker) string {\n\treturn strconv.FormatFloat(float64Range(f, 2.0, 10.0), 'f', 1, 64) + \"%\"\n}\n\n// BeerIbu will return a random beer ibu value between 10 and 100\nfunc BeerIbu() string {\n\treturn beerIbu(GlobalFaker)\n}\n\n// BeerIbu will return a random beer ibu value between 10 and 100\nfunc (f *Faker) BeerIbu() string {\n\treturn beerIbu(f)\n}\n\nfunc beerIbu(f *Faker) string {\n\treturn strconv.Itoa(randIntRange(f, 10, 100)) + \" IBU\"\n}\n\n// BeerBlg will return a random beer blg between 5.0 and 20.0\nfunc BeerBlg() string {\n\treturn beerBlg(GlobalFaker)\n}\n\n// BeerBlg will return a random beer blg between 5.0 and 20.0\nfunc (f *Faker) BeerBlg() string {\n\treturn beerBlg(f)\n}\n\nfunc beerBlg(f *Faker) string {\n\treturn strconv.FormatFloat(float64Range(f, 5.0, 20.0), 'f', 1, 64) + \"°Blg\"\n}\n\nfunc addBeerLookup() {\n\tAddFuncLookup(\"beername\", Info{\n\t\tDisplay:     \"Beer Name\",\n\t\tCategory:    \"beer\",\n\t\tDescription: \"Specific brand or variety of beer\",\n\t\tExample:     \"Duvel\",\n\t\tOutput:      \"string\",\n\t\tGenerate: func(f *Faker, m *MapParams, info *Info) (any, error) {\n\t\t\treturn beerName(f), nil\n\t\t},\n\t})\n\n\tAddFuncLookup(\"beerstyle\", Info{\n\t\tDisplay:     \"Beer Style\",\n\t\tCategory:    \"beer\",\n\t\tDescription: \"Distinct characteristics and flavors of beer\",\n\t\tExample:     \"European Amber Lager\",\n\t\tOutput:      \"string\",\n\t\tGenerate: func(f *Faker, m *MapParams, info *Info) (any, error) {\n\t\t\treturn beerStyle(f), nil\n\t\t},\n\t})\n\n\tAddFuncLookup(\"beerhop\", Info{\n\t\tDisplay:     \"Beer Hop\",\n\t\tCategory:    \"beer\",\n\t\tDescription: \"The flower used in brewing to add flavor, aroma, and bitterness to beer\",\n\t\tExample:     \"Glacier\",\n\t\tOutput:      \"string\",\n\t\tGenerate: func(f *Faker, m *MapParams, info *Info) (any, error) {\n\t\t\treturn beerHop(f), nil\n\t\t},\n\t})\n\n\tAddFuncLookup(\"beeryeast\", Info{\n\t\tDisplay:     \"Beer Yeast\",\n\t\tCategory:    \"beer\",\n\t\tDescription: \"Microorganism used in brewing to ferment sugars, producing alcohol and carbonation in beer\",\n\t\tExample:     \"1388 - Belgian Strong Ale\",\n\t\tOutput:      \"string\",\n\t\tGenerate: func(f *Faker, m *MapParams, info *Info) (any, error) {\n\t\t\treturn beerYeast(f), nil\n\t\t},\n\t})\n\n\tAddFuncLookup(\"beermalt\", Info{\n\t\tDisplay:     \"Beer Malt\",\n\t\tCategory:    \"beer\",\n\t\tDescription: \"Processed barley or other grains, provides sugars for fermentation and flavor to beer\",\n\t\tExample:     \"Munich\",\n\t\tOutput:      \"string\",\n\t\tGenerate: func(f *Faker, m *MapParams, info *Info) (any, error) {\n\t\t\treturn beerMalt(f), nil\n\t\t},\n\t})\n\n\tAddFuncLookup(\"beeralcohol\", Info{\n\t\tDisplay:     \"Beer Alcohol\",\n\t\tCategory:    \"beer\",\n\t\tDescription: \"Measures the alcohol content in beer\",\n\t\tExample:     \"2.7%\",\n\t\tOutput:      \"string\",\n\t\tGenerate: func(f *Faker, m *MapParams, info *Info) (any, error) {\n\t\t\treturn beerAlcohol(f), nil\n\t\t},\n\t})\n\n\tAddFuncLookup(\"beeribu\", Info{\n\t\tDisplay:     \"Beer IBU\",\n\t\tCategory:    \"beer\",\n\t\tDescription: \"Scale measuring bitterness of beer from hops\",\n\t\tExample:     \"29 IBU\",\n\t\tOutput:      \"string\",\n\t\tGenerate: func(f *Faker, m *MapParams, info *Info) (any, error) {\n\t\t\treturn beerIbu(f), nil\n\t\t},\n\t})\n\n\tAddFuncLookup(\"beerblg\", Info{\n\t\tDisplay:     \"Beer BLG\",\n\t\tCategory:    \"beer\",\n\t\tDescription: \"Scale indicating the concentration of extract in worts\",\n\t\tExample:     \"6.4°Blg\",\n\t\tOutput:      \"string\",\n\t\tGenerate: func(f *Faker, m *MapParams, info *Info) (any, error) {\n\t\t\treturn beerBlg(f), nil\n\t\t},\n\t})\n}\n"
        },
        {
          "name": "beer_test.go",
          "type": "blob",
          "size": 2.244140625,
          "content": "package gofakeit\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc ExampleBeerName() {\n\tSeed(11)\n\tfmt.Println(BeerName())\n\n\t// Output: Sierra Nevada Bigfoot Barleywine Style Ale\n}\n\nfunc ExampleFaker_BeerName() {\n\tf := New(11)\n\tfmt.Println(f.BeerName())\n\n\t// Output: Sierra Nevada Bigfoot Barleywine Style Ale\n}\n\nfunc BenchmarkBeerName(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tBeerName()\n\t}\n}\n\nfunc ExampleBeerStyle() {\n\tSeed(11)\n\tfmt.Println(BeerStyle())\n\n\t// Output: Vegetable Beer\n}\n\nfunc ExampleFaker_BeerStyle() {\n\tf := New(11)\n\tfmt.Println(f.BeerStyle())\n\n\t// Output: Vegetable Beer\n}\n\nfunc BenchmarkBeerStyle(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tBeerStyle()\n\t}\n}\n\nfunc ExampleBeerHop() {\n\tSeed(11)\n\tfmt.Println(BeerHop())\n\n\t// Output: TriplePearl\n}\n\nfunc ExampleFaker_BeerHop() {\n\tf := New(11)\n\tfmt.Println(f.BeerHop())\n\n\t// Output: TriplePearl\n}\n\nfunc BenchmarkBeerHop(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tBeerHop()\n\t}\n}\n\nfunc ExampleBeerYeast() {\n\tSeed(11)\n\tfmt.Println(BeerYeast())\n\n\t// Output: 2308 - Munich Lager\n}\n\nfunc ExampleFaker_BeerYeast() {\n\tf := New(11)\n\tfmt.Println(f.BeerYeast())\n\n\t// Output: 2308 - Munich Lager\n}\n\nfunc BenchmarkBeerYeast(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tBeerYeast()\n\t}\n\n}\n\nfunc ExampleBeerMalt() {\n\tSeed(11)\n\tfmt.Println(BeerMalt())\n\n\t// Output: Munich\n}\n\nfunc ExampleFaker_BeerMalt() {\n\tf := New(11)\n\tfmt.Println(f.BeerMalt())\n\n\t// Output: Munich\n}\n\nfunc BenchmarkBeerMalt(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tBeerMalt()\n\t}\n}\n\nfunc ExampleBeerIbu() {\n\tSeed(11)\n\tfmt.Println(BeerIbu())\n\n\t// Output: 91 IBU\n}\n\nfunc ExampleFaker_BeerIbu() {\n\tf := New(11)\n\tfmt.Println(f.BeerIbu())\n\n\t// Output: 91 IBU\n}\n\nfunc BenchmarkBeerIbu(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tBeerIbu()\n\t}\n}\n\nfunc ExampleBeerAlcohol() {\n\tSeed(11)\n\tfmt.Println(BeerAlcohol())\n\n\t// Output: 8.2%\n}\n\nfunc ExampleFaker_BeerAlcohol() {\n\tf := New(11)\n\tfmt.Println(f.BeerAlcohol())\n\n\t// Output: 8.2%\n}\n\nfunc BenchmarkBeerAlcohol(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tBeerAlcohol()\n\t}\n}\n\nfunc ExampleBeerBlg() {\n\tSeed(11)\n\tfmt.Println(BeerBlg())\n\n\t// Output: 16.6°Blg\n}\n\nfunc ExampleFaker_BeerBlg() {\n\tf := New(11)\n\tfmt.Println(f.BeerBlg())\n\n\t// Output: 16.6°Blg\n}\n\nfunc BenchmarkBeerBlg(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tBeerBlg()\n\t}\n}\n"
        },
        {
          "name": "book.go",
          "type": "blob",
          "size": 2.3837890625,
          "content": "package gofakeit\n\nfunc BookTitle() string { return bookTitle(GlobalFaker) }\n\nfunc (f *Faker) BookTitle() string { return bookTitle(f) }\n\nfunc bookTitle(f *Faker) string { return getRandValue(f, []string{\"book\", \"title\"}) }\n\nfunc BookAuthor() string { return bookAuthor(GlobalFaker) }\n\nfunc (f *Faker) BookAuthor() string { return bookAuthor(f) }\n\nfunc bookAuthor(f *Faker) string { return getRandValue(f, []string{\"book\", \"author\"}) }\n\nfunc BookGenre() string { return bookGenre(GlobalFaker) }\n\nfunc (f *Faker) BookGenre() string { return bookGenre(f) }\n\nfunc bookGenre(f *Faker) string { return getRandValue(f, []string{\"book\", \"genre\"}) }\n\ntype BookInfo struct {\n\tTitle  string `json:\"title\" xml:\"name\"`\n\tAuthor string `json:\"author\" xml:\"author\"`\n\tGenre  string `json:\"genre\" xml:\"genre\"`\n}\n\nfunc Book() *BookInfo { return book(GlobalFaker) }\n\nfunc (f *Faker) Book() *BookInfo { return book(f) }\n\nfunc book(f *Faker) *BookInfo {\n\treturn &BookInfo{\n\t\tTitle:  bookTitle(f),\n\t\tAuthor: bookAuthor(f),\n\t\tGenre:  bookGenre(f),\n\t}\n}\n\nfunc addBookLookup() {\n\tAddFuncLookup(\"book\", Info{\n\t\tDisplay:     \"Book\",\n\t\tCategory:    \"book\",\n\t\tDescription: \"Written or printed work consisting of pages bound together, covering various subjects or stories\",\n\t\tExample: `{\n\t\"title\": \"Anna Karenina\",\n\t\"author\": \"Toni Morrison\",\n\t\"genre\": \"Thriller\"\n}`,\n\t\tOutput:      \"map[string]string\",\n\t\tContentType: \"application/json\",\n\t\tGenerate: func(f *Faker, m *MapParams, info *Info) (any, error) {\n\t\t\treturn book(f), nil\n\t\t},\n\t})\n\n\tAddFuncLookup(\"booktitle\", Info{\n\t\tDisplay:     \"Title\",\n\t\tCategory:    \"book\",\n\t\tDescription: \"The specific name given to a book\",\n\t\tExample:     \"Hamlet\",\n\t\tOutput:      \"string\",\n\t\tGenerate: func(f *Faker, m *MapParams, info *Info) (any, error) {\n\t\t\treturn bookTitle(f), nil\n\t\t},\n\t})\n\n\tAddFuncLookup(\"bookauthor\", Info{\n\t\tDisplay:     \"Author\",\n\t\tCategory:    \"book\",\n\t\tDescription: \"The individual who wrote or created the content of a book\",\n\t\tExample:     \"Mark Twain\",\n\t\tOutput:      \"string\",\n\t\tGenerate: func(f *Faker, m *MapParams, info *Info) (any, error) {\n\t\t\treturn bookAuthor(f), nil\n\t\t},\n\t})\n\n\tAddFuncLookup(\"bookgenre\", Info{\n\t\tDisplay:     \"Genre\",\n\t\tCategory:    \"book\",\n\t\tDescription: \"Category or type of book defined by its content, style, or form\",\n\t\tExample:     \"Adventure\",\n\t\tOutput:      \"string\",\n\t\tGenerate: func(f *Faker, m *MapParams, info *Info) (any, error) {\n\t\t\treturn bookGenre(f), nil\n\t\t},\n\t})\n}\n"
        },
        {
          "name": "book_test.go",
          "type": "blob",
          "size": 1.41015625,
          "content": "package gofakeit\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc ExampleBook() {\n\tSeed(11)\n\tbook := Book()\n\tfmt.Println(book.Title)\n\tfmt.Println(book.Author)\n\tfmt.Println(book.Genre)\n\n\t// Output: Things Fall Apart\n\t// Toni Morrison\n\t// Erotic\n}\n\nfunc ExampleFaker_Book() {\n\tf := New(11)\n\tbook := f.Book()\n\tfmt.Println(book.Title)\n\tfmt.Println(book.Author)\n\tfmt.Println(book.Genre)\n\n\t// Output: Things Fall Apart\n\t// Toni Morrison\n\t// Erotic\n}\n\nfunc BenchmarkBook(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tBook()\n\t}\n}\n\nfunc TestBook(t *testing.T) {\n\tfor i := 0; i < 100; i++ {\n\t\tBook()\n\t}\n}\n\nfunc ExampleBookTitle() {\n\tSeed(11)\n\tfmt.Println(BookTitle())\n\n\t// Output: Things Fall Apart\n}\n\nfunc ExampleFaker_BookTitle() {\n\tf := New(11)\n\tfmt.Println(f.BookTitle())\n\n\t// Output: Things Fall Apart\n}\n\nfunc BenchmarkBookTitle(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tBookTitle()\n\t}\n}\n\nfunc ExampleBookAuthor() {\n\tSeed(11)\n\tfmt.Println(BookAuthor())\n\n\t// Output: Vladimir Nabokov\n}\n\nfunc ExampleFaker_BookAuthor() {\n\tf := New(11)\n\tfmt.Println(f.BookAuthor())\n\n\t// Output: Vladimir Nabokov\n}\n\nfunc BenchmarkBookAuthor(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tBookAuthor()\n\t}\n}\n\nfunc ExampleBookGenre() {\n\tSeed(11)\n\tfmt.Println(BookGenre())\n\n\t// Output: Thriller\n}\n\nfunc ExampleFaker_BookGenre() {\n\tf := New(11)\n\tfmt.Println(f.BookGenre())\n\n\t// Output: Thriller\n}\n\nfunc BenchmarkBookGenre(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tBookGenre()\n\t}\n}\n"
        },
        {
          "name": "car.go",
          "type": "blob",
          "size": 4.3828125,
          "content": "package gofakeit\n\n// CarInfo is a struct dataset of all car information\ntype CarInfo struct {\n\tType         string `json:\"type\" xml:\"type\"`\n\tFuel         string `json:\"fuel\" xml:\"fuel\"`\n\tTransmission string `json:\"transmission\" xml:\"transmission\"`\n\tBrand        string `json:\"brand\" xml:\"brand\"`\n\tModel        string `json:\"model\" xml:\"model\"`\n\tYear         int    `json:\"year\" xml:\"year\"`\n}\n\n// Car will generate a struct with car information\nfunc Car() *CarInfo { return car(GlobalFaker) }\n\n// Car will generate a struct with car information\nfunc (f *Faker) Car() *CarInfo { return car(f) }\n\nfunc car(f *Faker) *CarInfo {\n\treturn &CarInfo{\n\t\tType:         carType(f),\n\t\tFuel:         carFuelType(f),\n\t\tTransmission: carTransmissionType(f),\n\t\tBrand:        carMaker(f),\n\t\tModel:        carModel(f),\n\t\tYear:         year(f),\n\t}\n}\n\n// CarType will generate a random car type string\nfunc CarType() string { return carType(GlobalFaker) }\n\n// CarType will generate a random car type string\nfunc (f *Faker) CarType() string { return carType(f) }\n\nfunc carType(f *Faker) string { return getRandValue(f, []string{\"car\", \"type\"}) }\n\n// CarFuelType will return a random fuel type\nfunc CarFuelType() string { return carFuelType(GlobalFaker) }\n\n// CarFuelType will return a random fuel type\nfunc (f *Faker) CarFuelType() string { return carFuelType(f) }\n\nfunc carFuelType(f *Faker) string { return getRandValue(f, []string{\"car\", \"fuel_type\"}) }\n\n// CarTransmissionType will return a random transmission type\nfunc CarTransmissionType() string { return carTransmissionType(GlobalFaker) }\n\n// CarTransmissionType will return a random transmission type\nfunc (f *Faker) CarTransmissionType() string { return carTransmissionType(f) }\n\nfunc carTransmissionType(f *Faker) string {\n\treturn getRandValue(f, []string{\"car\", \"transmission_type\"})\n}\n\n// CarMaker will return a random car maker\nfunc CarMaker() string { return carMaker(GlobalFaker) }\n\n// CarMaker will return a random car maker\nfunc (f *Faker) CarMaker() string { return carMaker(f) }\n\nfunc carMaker(f *Faker) string { return getRandValue(f, []string{\"car\", \"maker\"}) }\n\n// CarModel will return a random car model\nfunc CarModel() string { return carModel(GlobalFaker) }\n\n// CarModel will return a random car model\nfunc (f *Faker) CarModel() string { return carModel(f) }\n\nfunc carModel(f *Faker) string { return getRandValue(f, []string{\"car\", \"model\"}) }\n\nfunc addCarLookup() {\n\tAddFuncLookup(\"car\", Info{\n\t\tDisplay:     \"Car\",\n\t\tCategory:    \"car\",\n\t\tDescription: \"Wheeled motor vehicle used for transportation\",\n\t\tExample: `{\n\t\"type\": \"Passenger car mini\",\n\t\"fuel\": \"Gasoline\",\n\t\"transmission\": \"Automatic\",\n\t\"brand\": \"Fiat\",\n\t\"model\": \"Freestyle Fwd\",\n\t\"year\": 1991\n}`,\n\t\tOutput:      \"map[string]any\",\n\t\tContentType: \"application/json\",\n\t\tGenerate: func(f *Faker, m *MapParams, info *Info) (any, error) {\n\t\t\treturn car(f), nil\n\t\t},\n\t})\n\n\tAddFuncLookup(\"cartype\", Info{\n\t\tDisplay:     \"Car Type\",\n\t\tCategory:    \"car\",\n\t\tDescription: \"Classification of cars based on size, use, or body style\",\n\t\tExample:     \"Passenger car mini\",\n\t\tOutput:      \"string\",\n\t\tGenerate: func(f *Faker, m *MapParams, info *Info) (any, error) {\n\t\t\treturn carType(f), nil\n\t\t},\n\t})\n\n\tAddFuncLookup(\"carfueltype\", Info{\n\t\tDisplay:     \"Car Fuel Type\",\n\t\tCategory:    \"car\",\n\t\tDescription: \"Type of energy source a car uses\",\n\t\tExample:     \"CNG\",\n\t\tOutput:      \"string\",\n\t\tGenerate: func(f *Faker, m *MapParams, info *Info) (any, error) {\n\t\t\treturn carFuelType(f), nil\n\t\t},\n\t})\n\n\tAddFuncLookup(\"cartransmissiontype\", Info{\n\t\tDisplay:     \"Car Transmission Type\",\n\t\tCategory:    \"car\",\n\t\tDescription: \"Mechanism a car uses to transmit power from the engine to the wheels\",\n\t\tExample:     \"Manual\",\n\t\tOutput:      \"string\",\n\t\tGenerate: func(f *Faker, m *MapParams, info *Info) (any, error) {\n\t\t\treturn carTransmissionType(f), nil\n\t\t},\n\t})\n\n\tAddFuncLookup(\"carmaker\", Info{\n\t\tDisplay:     \"Car Maker\",\n\t\tCategory:    \"car\",\n\t\tDescription: \"Company or brand that manufactures and designs cars\",\n\t\tExample:     \"Nissan\",\n\t\tOutput:      \"string\",\n\t\tGenerate: func(f *Faker, m *MapParams, info *Info) (any, error) {\n\t\t\treturn carMaker(f), nil\n\t\t},\n\t})\n\n\tAddFuncLookup(\"carmodel\", Info{\n\t\tDisplay:     \"Car Model\",\n\t\tCategory:    \"car\",\n\t\tDescription: \"Specific design or version of a car produced by a manufacturer\",\n\t\tExample:     \"Aveo\",\n\t\tOutput:      \"string\",\n\t\tGenerate: func(f *Faker, m *MapParams, info *Info) (any, error) {\n\t\t\treturn carModel(f), nil\n\t\t},\n\t})\n}\n"
        },
        {
          "name": "car_test.go",
          "type": "blob",
          "size": 2.0810546875,
          "content": "package gofakeit\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc ExampleCar() {\n\tSeed(11)\n\tcar := Car()\n\tfmt.Println(car.Brand)\n\tfmt.Println(car.Fuel)\n\tfmt.Println(car.Model)\n\tfmt.Println(car.Transmission)\n\tfmt.Println(car.Type)\n\tfmt.Println(car.Year)\n\n\t// Output: Dacia\n\t// CNG\n\t// Santafe 4wd\n\t// Automatic\n\t// Passenger car heavy\n\t// 1928\n}\n\nfunc ExampleFaker_Car() {\n\tf := New(11)\n\tcar := f.Car()\n\tfmt.Println(car.Brand)\n\tfmt.Println(car.Fuel)\n\tfmt.Println(car.Model)\n\tfmt.Println(car.Transmission)\n\tfmt.Println(car.Type)\n\tfmt.Println(car.Year)\n\n\t// Output: Dacia\n\t// CNG\n\t// Santafe 4wd\n\t// Automatic\n\t// Passenger car heavy\n\t// 1928\n}\n\nfunc BenchmarkCar(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tCar()\n\t}\n}\n\nfunc ExampleCarType() {\n\tSeed(11)\n\tfmt.Println(CarType())\n\n\t// Output: Passenger car heavy\n}\n\nfunc ExampleFaker_CarType() {\n\tf := New(11)\n\tfmt.Println(f.CarType())\n\n\t// Output: Passenger car heavy\n}\n\nfunc BenchmarkCarType(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tCarType()\n\t}\n}\n\nfunc ExampleCarFuelType() {\n\tSeed(11)\n\tfmt.Println(CarFuelType())\n\n\t// Output: Electric\n}\n\nfunc ExampleFaker_CarFuelType() {\n\tf := New(11)\n\tfmt.Println(f.CarFuelType())\n\n\t// Output: Electric\n}\n\nfunc BenchmarkCarFuelType(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tCarFuelType()\n\t}\n}\n\nfunc ExampleCarTransmissionType() {\n\tSeed(11)\n\tfmt.Println(CarTransmissionType())\n\n\t// Output: Manual\n}\n\nfunc ExampleFaker_CarTransmissionType() {\n\tf := New(11)\n\tfmt.Println(f.CarTransmissionType())\n\n\t// Output: Manual\n}\n\nfunc BenchmarkCarTransmissionType(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tCarTransmissionType()\n\t}\n}\n\nfunc ExampleCarMaker() {\n\tSeed(11)\n\tfmt.Println(CarMaker())\n\n\t// Output: Spyker\n}\n\nfunc ExampleFaker_CarMaker() {\n\tf := New(11)\n\tfmt.Println(f.CarMaker())\n\n\t// Output: Spyker\n}\n\nfunc BenchmarkCarMaker(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tCarMaker()\n\t}\n}\n\nfunc ExampleCarModel() {\n\tSeed(11)\n\tfmt.Println(CarModel())\n\n\t// Output: Prius\n}\n\nfunc ExampleFaker_CarModel() {\n\tf := New(11)\n\tfmt.Println(f.CarModel())\n\n\t// Output: Prius\n}\n\nfunc BenchmarkCarModel(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tCarModel()\n\t}\n}\n"
        },
        {
          "name": "celebrity.go",
          "type": "blob",
          "size": 2.181640625,
          "content": "package gofakeit\n\n// CelebrityActor will generate a random celebrity actor\nfunc CelebrityActor() string { return celebrityActor(GlobalFaker) }\n\n// CelebrityActor will generate a random celebrity actor\nfunc (f *Faker) CelebrityActor() string { return celebrityActor(f) }\n\nfunc celebrityActor(f *Faker) string { return getRandValue(f, []string{\"celebrity\", \"actor\"}) }\n\n// CelebrityBusiness will generate a random celebrity business person\nfunc CelebrityBusiness() string { return celebrityBusiness(GlobalFaker) }\n\n// CelebrityBusiness will generate a random celebrity business person\nfunc (f *Faker) CelebrityBusiness() string { return celebrityBusiness(f) }\n\nfunc celebrityBusiness(f *Faker) string {\n\treturn getRandValue(f, []string{\"celebrity\", \"business\"})\n}\n\n// CelebritySport will generate a random celebrity sport person\nfunc CelebritySport() string { return celebritySport(GlobalFaker) }\n\n// CelebritySport will generate a random celebrity sport person\nfunc (f *Faker) CelebritySport() string { return celebritySport(f) }\n\nfunc celebritySport(f *Faker) string { return getRandValue(f, []string{\"celebrity\", \"sport\"}) }\n\nfunc addCelebrityLookup() {\n\tAddFuncLookup(\"celebrityactor\", Info{\n\t\tDisplay:     \"Celebrity Actor\",\n\t\tCategory:    \"celebrity\",\n\t\tDescription: \"Famous person known for acting in films, television, or theater\",\n\t\tExample:     \"Brad Pitt\",\n\t\tOutput:      \"string\",\n\t\tGenerate: func(f *Faker, m *MapParams, info *Info) (any, error) {\n\t\t\treturn celebrityActor(f), nil\n\t\t},\n\t})\n\n\tAddFuncLookup(\"celebritybusiness\", Info{\n\t\tDisplay:     \"Celebrity Business\",\n\t\tCategory:    \"celebrity\",\n\t\tDescription: \"High-profile individual known for significant achievements in business or entrepreneurship\",\n\t\tExample:     \"Elon Musk\",\n\t\tOutput:      \"string\",\n\t\tGenerate: func(f *Faker, m *MapParams, info *Info) (any, error) {\n\t\t\treturn celebrityBusiness(f), nil\n\t\t},\n\t})\n\n\tAddFuncLookup(\"celebritysport\", Info{\n\t\tDisplay:     \"Celebrity Sport\",\n\t\tCategory:    \"celebrity\",\n\t\tDescription: \"Famous athlete known for achievements in a particular sport\",\n\t\tExample:     \"Michael Phelps\",\n\t\tOutput:      \"string\",\n\t\tGenerate: func(f *Faker, m *MapParams, info *Info) (any, error) {\n\t\t\treturn celebritySport(f), nil\n\t\t},\n\t})\n}\n"
        },
        {
          "name": "celebrity_test.go",
          "type": "blob",
          "size": 0.9814453125,
          "content": "package gofakeit\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc ExampleCelebrityActor() {\n\tSeed(11)\n\tfmt.Println(CelebrityActor())\n\n\t// Output: Shah Rukh Khan\n}\n\nfunc ExampleFaker_CelebrityActor() {\n\tf := New(11)\n\tfmt.Println(f.CelebrityActor())\n\n\t// Output: Shah Rukh Khan\n}\n\nfunc BenchmarkCelebrityActor(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tCelebrityActor()\n\t}\n}\n\nfunc ExampleCelebrityBusiness() {\n\tSeed(11)\n\tfmt.Println(CelebrityBusiness())\n\n\t// Output: Prescott Bush\n}\n\nfunc ExampleFaker_CelebrityBusiness() {\n\tf := New(11)\n\tfmt.Println(f.CelebrityBusiness())\n\n\t// Output: Prescott Bush\n}\n\nfunc BenchmarkCelebrityBusiness(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tCelebrityBusiness()\n\t}\n}\n\nfunc ExampleCelebritySport() {\n\tSeed(11)\n\tfmt.Println(CelebritySport())\n\n\t// Output: Grete Waitz\n}\n\nfunc ExampleFaker_CelebritySport() {\n\tf := New(11)\n\tfmt.Println(f.CelebritySport())\n\n\t// Output: Grete Waitz\n}\n\nfunc BenchmarkCelebritySport(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tCelebritySport()\n\t}\n}\n"
        },
        {
          "name": "cmd",
          "type": "tree",
          "content": null
        },
        {
          "name": "color.go",
          "type": "blob",
          "size": 3.4990234375,
          "content": "package gofakeit\n\nimport (\n\t\"github.com/brianvoe/gofakeit/v7/data\"\n)\n\n// Color will generate a random color string\nfunc Color() string { return color(GlobalFaker) }\n\n// Color will generate a random color string\nfunc (f *Faker) Color() string { return color(f) }\n\nfunc color(f *Faker) string { return getRandValue(f, []string{\"color\", \"full\"}) }\n\n// NiceColor will generate a random safe color string\nfunc NiceColors() []string { return niceColors(GlobalFaker) }\n\n// NiceColor will generate a random safe color string\nfunc (f *Faker) NiceColors() []string { return niceColors(f) }\n\nfunc niceColors(f *Faker) []string {\n\treturn data.ColorsNice[randIntRange(f, 0, len(data.ColorsNice)-1)]\n}\n\n// SafeColor will generate a random safe color string\nfunc SafeColor() string { return safeColor(GlobalFaker) }\n\n// SafeColor will generate a random safe color string\nfunc (f *Faker) SafeColor() string { return safeColor(f) }\n\nfunc safeColor(f *Faker) string { return getRandValue(f, []string{\"color\", \"safe\"}) }\n\n// HexColor will generate a random hexadecimal color string\nfunc HexColor() string { return hexColor(GlobalFaker) }\n\n// HexColor will generate a random hexadecimal color string\nfunc (f *Faker) HexColor() string { return hexColor(f) }\n\nfunc hexColor(f *Faker) string {\n\tcolor := make([]byte, 6)\n\thashQuestion := []byte(\"?#\")\n\tfor i := 0; i < 6; i++ {\n\t\tcolor[i] = hashQuestion[f.IntN(2)]\n\t}\n\n\treturn \"#\" + replaceWithHexLetters(f, replaceWithNumbers(f, string(color)))\n}\n\n// RGBColor will generate a random int slice color\nfunc RGBColor() []int { return rgbColor(GlobalFaker) }\n\n// RGBColor will generate a random int slice color\nfunc (f *Faker) RGBColor() []int { return rgbColor(f) }\n\nfunc rgbColor(f *Faker) []int {\n\treturn []int{randIntRange(f, 0, 255), randIntRange(f, 0, 255), randIntRange(f, 0, 255)}\n}\n\nfunc addColorLookup() {\n\tAddFuncLookup(\"color\", Info{\n\t\tDisplay:     \"Color\",\n\t\tCategory:    \"color\",\n\t\tDescription: \"Hue seen by the eye, returns the name of the color like red or blue\",\n\t\tExample:     \"MediumOrchid\",\n\t\tOutput:      \"string\",\n\t\tGenerate: func(f *Faker, m *MapParams, info *Info) (any, error) {\n\t\t\treturn color(f), nil\n\t\t},\n\t})\n\n\tAddFuncLookup(\"nicecolors\", Info{\n\t\tDisplay:     \"Nice Colors\",\n\t\tCategory:    \"color\",\n\t\tDescription: \"Attractive and appealing combinations of colors, returns an list of color hex codes\",\n\t\tExample:     `[\"#cfffdd\",\"#b4dec1\",\"#5c5863\",\"#a85163\",\"#ff1f4c\"]`,\n\t\tOutput:      \"[]string\",\n\t\tContentType: \"application/json\",\n\t\tGenerate: func(f *Faker, m *MapParams, info *Info) (any, error) {\n\t\t\treturn niceColors(f), nil\n\t\t},\n\t})\n\n\tAddFuncLookup(\"safecolor\", Info{\n\t\tDisplay:     \"Safe Color\",\n\t\tCategory:    \"color\",\n\t\tDescription: \"Colors displayed consistently on different web browsers and devices\",\n\t\tExample:     \"black\",\n\t\tOutput:      \"string\",\n\t\tGenerate: func(f *Faker, m *MapParams, info *Info) (any, error) {\n\t\t\treturn safeColor(f), nil\n\t\t},\n\t})\n\n\tAddFuncLookup(\"hexcolor\", Info{\n\t\tDisplay:     \"Hex Color\",\n\t\tCategory:    \"color\",\n\t\tDescription: \"Six-digit code representing a color in the color model\",\n\t\tExample:     \"#a99fb4\",\n\t\tOutput:      \"string\",\n\t\tGenerate: func(f *Faker, m *MapParams, info *Info) (any, error) {\n\t\t\treturn hexColor(f), nil\n\t\t},\n\t})\n\n\tAddFuncLookup(\"rgbcolor\", Info{\n\t\tDisplay:     \"RGB Color\",\n\t\tCategory:    \"color\",\n\t\tDescription: \"Color defined by red, green, and blue light values\",\n\t\tExample:     \"[85, 224, 195]\",\n\t\tOutput:      \"[]int\",\n\t\tContentType: \"application/json\",\n\t\tGenerate: func(f *Faker, m *MapParams, info *Info) (any, error) {\n\t\t\treturn rgbColor(f), nil\n\t\t},\n\t})\n}\n"
        },
        {
          "name": "color_test.go",
          "type": "blob",
          "size": 1.4189453125,
          "content": "package gofakeit\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc ExampleColor() {\n\tSeed(11)\n\tfmt.Println(Color())\n\n\t// Output: SlateGray\n}\n\nfunc ExampleFaker_Color() {\n\tf := New(11)\n\tfmt.Println(f.Color())\n\n\t// Output: SlateGray\n}\n\nfunc BenchmarkColor(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tColor()\n\t}\n}\n\nfunc ExampleNiceColors() {\n\tSeed(11)\n\tfmt.Println(NiceColors())\n\n\t// Output: [#fffbb7 #a6f6af #66b6ab #5b7c8d #4f2958]\n}\n\nfunc ExampleFaker_NiceColors() {\n\tf := New(11)\n\tfmt.Println(f.NiceColors())\n\n\t// Output: [#fffbb7 #a6f6af #66b6ab #5b7c8d #4f2958]\n}\n\nfunc BenchmarkNiceColors(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tNiceColors()\n\t}\n}\n\nfunc ExampleSafeColor() {\n\tSeed(11)\n\tfmt.Println(SafeColor())\n\n\t// Output: aqua\n}\n\nfunc ExampleFaker_SafeColor() {\n\tf := New(11)\n\tfmt.Println(f.SafeColor())\n\n\t// Output: aqua\n}\n\nfunc BenchmarkSafeColor(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tSafeColor()\n\t}\n}\n\nfunc ExampleHexColor() {\n\tSeed(11)\n\tfmt.Println(HexColor())\n\n\t// Output: #ef759a\n}\n\nfunc ExampleFaker_HexColor() {\n\tf := New(11)\n\tfmt.Println(f.HexColor())\n\n\t// Output: #ef759a\n}\n\nfunc BenchmarkHexColor(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tHexColor()\n\t}\n}\n\nfunc ExampleRGBColor() {\n\tSeed(11)\n\tfmt.Println(RGBColor())\n\n\t// Output: [180 18 181]\n}\n\nfunc ExampleFaker_RGBColor() {\n\tf := New(11)\n\tfmt.Println(f.RGBColor())\n\n\t// Output: [180 18 181]\n}\n\nfunc BenchmarkRGBColor(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tRGBColor()\n\t}\n}\n"
        },
        {
          "name": "company.go",
          "type": "blob",
          "size": 7.4287109375,
          "content": "package gofakeit\n\n// Company will generate a random company name string\nfunc Company() string { return company(GlobalFaker) }\n\n// Company will generate a random company name string\nfunc (f *Faker) Company() string { return company(f) }\n\nfunc company(f *Faker) string { return getRandValue(f, []string{\"company\", \"name\"}) }\n\n// CompanySuffix will generate a random company suffix string\nfunc CompanySuffix() string { return companySuffix(GlobalFaker) }\n\n// CompanySuffix will generate a random company suffix string\nfunc (f *Faker) CompanySuffix() string { return companySuffix(f) }\n\nfunc companySuffix(f *Faker) string { return getRandValue(f, []string{\"company\", \"suffix\"}) }\n\n// Blurb will generate a random company blurb string\nfunc Blurb() string { return blurb(GlobalFaker) }\n\nfunc (f *Faker) Blurb() string { return blurb(f) }\n\nfunc blurb(f *Faker) string { return getRandValue(f, []string{\"company\", \"blurb\"}) }\n\n// BuzzWord will generate a random company buzz word string\nfunc BuzzWord() string { return buzzWord(GlobalFaker) }\n\n// BuzzWord will generate a random company buzz word string\nfunc (f *Faker) BuzzWord() string { return buzzWord(f) }\n\nfunc buzzWord(f *Faker) string { return getRandValue(f, []string{\"company\", \"buzzwords\"}) }\n\n// BS will generate a random company bs string\nfunc BS() string { return bs(GlobalFaker) }\n\n// BS will generate a random company bs string\nfunc (f *Faker) BS() string { return bs(f) }\n\nfunc bs(f *Faker) string { return getRandValue(f, []string{\"company\", \"bs\"}) }\n\n// JobInfo is a struct of job information\ntype JobInfo struct {\n\tCompany    string `json:\"company\" xml:\"company\"`\n\tTitle      string `json:\"title\" xml:\"title\"`\n\tDescriptor string `json:\"descriptor\" xml:\"descriptor\"`\n\tLevel      string `json:\"level\" xml:\"level\"`\n}\n\n// Job will generate a struct with random job information\nfunc Job() *JobInfo { return job(GlobalFaker) }\n\n// Job will generate a struct with random job information\nfunc (f *Faker) Job() *JobInfo { return job(f) }\n\nfunc job(f *Faker) *JobInfo {\n\treturn &JobInfo{\n\t\tCompany:    company(f),\n\t\tTitle:      jobTitle(f),\n\t\tDescriptor: jobDescriptor(f),\n\t\tLevel:      jobLevel(f),\n\t}\n}\n\n// JobTitle will generate a random job title string\nfunc JobTitle() string { return jobTitle(GlobalFaker) }\n\n// JobTitle will generate a random job title string\nfunc (f *Faker) JobTitle() string { return jobTitle(f) }\n\nfunc jobTitle(f *Faker) string { return getRandValue(f, []string{\"job\", \"title\"}) }\n\n// JobDescriptor will generate a random job descriptor string\nfunc JobDescriptor() string { return jobDescriptor(GlobalFaker) }\n\n// JobDescriptor will generate a random job descriptor string\nfunc (f *Faker) JobDescriptor() string { return jobDescriptor(f) }\n\nfunc jobDescriptor(f *Faker) string { return getRandValue(f, []string{\"job\", \"descriptor\"}) }\n\n// JobLevel will generate a random job level string\nfunc JobLevel() string { return jobLevel(GlobalFaker) }\n\n// JobLevel will generate a random job level string\nfunc (f *Faker) JobLevel() string { return jobLevel(f) }\n\nfunc jobLevel(f *Faker) string { return getRandValue(f, []string{\"job\", \"level\"}) }\n\n// Slogan will generate a random company slogan\nfunc Slogan() string { return slogan(GlobalFaker) }\n\n// Slogan will generate a random company slogan\nfunc (f *Faker) Slogan() string { return slogan(f) }\n\n// Slogan will generate a random company slogan\nfunc slogan(f *Faker) string {\n\tslogan := \"\"\n\tvar sloganStyle = number(f, 0, 2)\n\tswitch sloganStyle {\n\t// Noun. Buzzword!\n\tcase 0:\n\t\tslogan = getRandValue(f, []string{\"company\", \"blurb\"}) + \". \" + getRandValue(f, []string{\"company\", \"buzzwords\"}) + \"!\"\n\t// Buzzword Noun, Buzzword Noun.\n\tcase 1:\n\t\tslogan = getRandValue(f, []string{\"company\", \"buzzwords\"}) + \" \" + getRandValue(f, []string{\"company\", \"blurb\"}) + \", \" + getRandValue(f, []string{\"company\", \"buzzwords\"}) + \" \" + getRandValue(f, []string{\"company\", \"blurb\"}) + \".\"\n\t// Buzzword bs Noun, Buzzword.\n\tcase 2:\n\t\tslogan = getRandValue(f, []string{\"company\", \"buzzwords\"}) + \" \" + getRandValue(f, []string{\"company\", \"bs\"}) + \" \" + getRandValue(f, []string{\"company\", \"blurb\"}) + \", \" + getRandValue(f, []string{\"company\", \"buzzwords\"}) + \".\"\n\t}\n\treturn slogan\n}\n\nfunc addCompanyLookup() {\n\tAddFuncLookup(\"company\", Info{\n\t\tDisplay:     \"Company\",\n\t\tCategory:    \"company\",\n\t\tDescription: \"Designated official name of a business or organization\",\n\t\tExample:     \"Moen, Pagac and Wuckert\",\n\t\tOutput:      \"string\",\n\t\tGenerate: func(f *Faker, m *MapParams, info *Info) (any, error) {\n\t\t\treturn company(f), nil\n\t\t},\n\t})\n\n\tAddFuncLookup(\"companysuffix\", Info{\n\t\tDisplay:     \"Company Suffix\",\n\t\tCategory:    \"company\",\n\t\tDescription: \"Suffix at the end of a company name, indicating business structure, like 'Inc.' or 'LLC'\",\n\t\tExample:     \"Inc\",\n\t\tOutput:      \"string\",\n\t\tGenerate: func(f *Faker, m *MapParams, info *Info) (any, error) {\n\t\t\treturn companySuffix(f), nil\n\t\t},\n\t})\n\n\tAddFuncLookup(\"bs\", Info{\n\t\tDisplay:     \"BS\",\n\t\tCategory:    \"company\",\n\t\tDescription: \"Random bs company word\",\n\t\tExample:     \"front-end\",\n\t\tOutput:      \"string\",\n\t\tGenerate: func(f *Faker, m *MapParams, info *Info) (any, error) {\n\t\t\treturn bs(f), nil\n\t\t},\n\t})\n\n\tAddFuncLookup(\"blurb\", Info{\n\t\tDisplay:     \"Blurb\",\n\t\tCategory:    \"company\",\n\t\tDescription: \"Brief description or summary of a company's purpose, products, or services\",\n\t\tExample:     \"word\",\n\t\tOutput:      \"string\",\n\t\tGenerate: func(f *Faker, m *MapParams, info *Info) (any, error) {\n\t\t\treturn blurb(f), nil\n\t\t},\n\t})\n\n\tAddFuncLookup(\"buzzword\", Info{\n\t\tDisplay:     \"Buzzword\",\n\t\tCategory:    \"company\",\n\t\tDescription: \"Trendy or overused term often used in business to sound impressive\",\n\t\tExample:     \"disintermediate\",\n\t\tOutput:      \"string\",\n\t\tGenerate: func(f *Faker, m *MapParams, info *Info) (any, error) {\n\t\t\treturn buzzWord(f), nil\n\t\t},\n\t})\n\n\tAddFuncLookup(\"job\", Info{\n\t\tDisplay:     \"Job\",\n\t\tCategory:    \"company\",\n\t\tDescription: \"Position or role in employment, involving specific tasks and responsibilities\",\n\t\tExample: `{\n\t\"company\": \"ClearHealthCosts\",\n\t\"title\": \"Agent\",\n\t\"descriptor\": \"Future\",\n\t\"level\": \"Tactics\"\n}`,\n\t\tOutput:      \"map[string]string\",\n\t\tContentType: \"application/json\",\n\t\tGenerate: func(f *Faker, m *MapParams, info *Info) (any, error) {\n\t\t\treturn job(f), nil\n\t\t},\n\t})\n\n\tAddFuncLookup(\"jobtitle\", Info{\n\t\tDisplay:     \"Job Title\",\n\t\tCategory:    \"company\",\n\t\tDescription: \"Specific title for a position or role within a company or organization\",\n\t\tExample:     \"Director\",\n\t\tOutput:      \"string\",\n\t\tGenerate: func(f *Faker, m *MapParams, info *Info) (any, error) {\n\t\t\treturn jobTitle(f), nil\n\t\t},\n\t})\n\n\tAddFuncLookup(\"jobdescriptor\", Info{\n\t\tDisplay:     \"Job Descriptor\",\n\t\tCategory:    \"company\",\n\t\tDescription: \"Word used to describe the duties, requirements, and nature of a job\",\n\t\tExample:     \"Central\",\n\t\tOutput:      \"string\",\n\t\tGenerate: func(f *Faker, m *MapParams, info *Info) (any, error) {\n\t\t\treturn jobDescriptor(f), nil\n\t\t},\n\t})\n\n\tAddFuncLookup(\"joblevel\", Info{\n\t\tDisplay:     \"Job Level\",\n\t\tCategory:    \"company\",\n\t\tDescription: \"Random job level\",\n\t\tExample:     \"Assurance\",\n\t\tOutput:      \"string\",\n\t\tGenerate: func(f *Faker, m *MapParams, info *Info) (any, error) {\n\t\t\treturn jobLevel(f), nil\n\t\t},\n\t})\n\n\tAddFuncLookup(\"slogan\", Info{\n\t\tDisplay:     \"Slogan\",\n\t\tCategory:    \"company\",\n\t\tDescription: \"Catchphrase or motto used by a company to represent its brand or values\",\n\t\tExample:     \"Universal seamless Focus, interactive.\",\n\t\tOutput:      \"string\",\n\t\tGenerate: func(f *Faker, m *MapParams, info *Info) (any, error) {\n\t\t\treturn slogan(f), nil\n\t\t},\n\t})\n}\n"
        },
        {
          "name": "company_test.go",
          "type": "blob",
          "size": 3.1103515625,
          "content": "package gofakeit\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc ExampleCompany() {\n\tSeed(11)\n\tfmt.Println(Company())\n\n\t// Output: TransparaGov\n}\n\nfunc ExampleFaker_Company() {\n\tf := New(11)\n\tfmt.Println(f.Company())\n\n\t// Output: TransparaGov\n}\n\nfunc BenchmarkCompany(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tCompany()\n\t}\n}\n\nfunc TestCompany(t *testing.T) {\n\tfor i := 0; i < 100; i++ {\n\t\tCompany()\n\t}\n}\n\nfunc ExampleCompanySuffix() {\n\tSeed(11)\n\tfmt.Println(CompanySuffix())\n\n\t// Output: Inc\n}\n\nfunc ExampleFaker_CompanySuffix() {\n\tf := New(11)\n\tfmt.Println(f.CompanySuffix())\n\n\t// Output: Inc\n}\n\nfunc BenchmarkCompanySuffix(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tCompanySuffix()\n\t}\n}\n\nfunc ExampleBlurb() {\n\tSeed(11)\n\tfmt.Println(Blurb())\n\n\t// Output: Teamwork\n}\n\nfunc ExampleFaker_Blurb() {\n\tf := New(11)\n\tfmt.Println(f.Blurb())\n\n\t// Output: Teamwork\n}\n\nfunc BenchmarkBlurb(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tBlurb()\n\t}\n}\nfunc ExampleBuzzWord() {\n\tSeed(11)\n\tfmt.Println(BuzzWord())\n\n\t// Output: open system\n}\n\nfunc ExampleFaker_BuzzWord() {\n\tf := New(11)\n\tfmt.Println(f.BuzzWord())\n\n\t// Output: open system\n}\n\nfunc BenchmarkBuzzWord(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tBuzzWord()\n\t}\n}\n\nfunc ExampleBS() {\n\tSeed(11)\n\tfmt.Println(BS())\n\n\t// Output: models\n}\n\nfunc ExampleFaker_BS() {\n\tf := New(11)\n\tfmt.Println(f.BS())\n\n\t// Output: models\n}\n\nfunc BenchmarkBS(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tBS()\n\t}\n}\n\nfunc ExampleJob() {\n\tSeed(11)\n\tjobInfo := Job()\n\tfmt.Println(jobInfo.Company)\n\tfmt.Println(jobInfo.Title)\n\tfmt.Println(jobInfo.Descriptor)\n\tfmt.Println(jobInfo.Level)\n\n\t// Output: TransparaGov\n\t// Specialist\n\t// Direct\n\t// Configuration\n}\n\nfunc ExampleFaker_Job() {\n\tf := New(11)\n\tjobInfo := f.Job()\n\tfmt.Println(jobInfo.Company)\n\tfmt.Println(jobInfo.Title)\n\tfmt.Println(jobInfo.Descriptor)\n\tfmt.Println(jobInfo.Level)\n\n\t// Output: TransparaGov\n\t// Specialist\n\t// Direct\n\t// Configuration\n}\n\nfunc BenchmarkJob(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tJob()\n\t}\n}\n\nfunc ExampleJobTitle() {\n\tSeed(11)\n\tfmt.Println(JobTitle())\n\n\t// Output: Strategist\n}\n\nfunc ExampleFaker_JobTitle() {\n\tf := New(11)\n\tfmt.Println(f.JobTitle())\n\n\t// Output: Strategist\n}\n\nfunc BenchmarkJobTitle(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tJobTitle()\n\t}\n}\n\nfunc ExampleJobDescriptor() {\n\tSeed(11)\n\tfmt.Println(JobDescriptor())\n\n\t// Output: Product\n}\n\nfunc ExampleFaker_JobDescriptor() {\n\tf := New(11)\n\tfmt.Println(f.JobDescriptor())\n\n\t// Output: Product\n}\n\nfunc BenchmarkJobDescriptor(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tJobDescriptor()\n\t}\n}\n\nfunc ExampleJobLevel() {\n\tSeed(11)\n\tfmt.Println(JobLevel())\n\n\t// Output: Solutions\n}\n\nfunc ExampleFaker_JobLevel() {\n\tf := New(11)\n\tfmt.Println(f.JobLevel())\n\n\t// Output: Solutions\n}\n\nfunc BenchmarkJobLevel(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tJobLevel()\n\t}\n}\n\nfunc ExampleSlogan() {\n\tSeed(11)\n\tfmt.Println(Slogan())\n\n\t// Output: local area network maximize Drive, mission-critical.\n}\n\nfunc ExampleFaker_Slogan() {\n\tf := New(11)\n\tfmt.Println(f.Slogan())\n\n\t// Output: local area network maximize Drive, mission-critical.\n}\n\nfunc BenchmarkSlogan(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tSlogan()\n\t}\n}\n"
        },
        {
          "name": "csv.go",
          "type": "blob",
          "size": 4.626953125,
          "content": "package gofakeit\n\nimport (\n\t\"bytes\"\n\t\"encoding/csv\"\n\t\"encoding/json\"\n\t\"errors\"\n\t\"fmt\"\n\t\"reflect\"\n\t\"strings\"\n)\n\n// CSVOptions defines values needed for csv generation\ntype CSVOptions struct {\n\tDelimiter string  `json:\"delimiter\" xml:\"delimiter\" fake:\"{randomstring:[,,tab]}\"`\n\tRowCount  int     `json:\"row_count\" xml:\"row_count\" fake:\"{number:1,10}\"`\n\tFields    []Field `json:\"fields\" xml:\"fields\" fake:\"{fields}\"`\n}\n\n// CSV generates an object or an array of objects in json format\n// A nil CSVOptions returns a randomly structured CSV.\nfunc CSV(co *CSVOptions) ([]byte, error) { return csvFunc(GlobalFaker, co) }\n\n// CSV generates an object or an array of objects in json format\n// A nil CSVOptions returns a randomly structured CSV.\nfunc (f *Faker) CSV(co *CSVOptions) ([]byte, error) { return csvFunc(f, co) }\n\nfunc csvFunc(f *Faker, co *CSVOptions) ([]byte, error) {\n\tif co == nil {\n\t\t// We didn't get a CSVOptions, so create a new random one\n\t\terr := f.Struct(&co)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\t// Check delimiter\n\tif co.Delimiter == \"\" {\n\t\tco.Delimiter = \",\"\n\t}\n\tif strings.ToLower(co.Delimiter) == \"tab\" {\n\t\tco.Delimiter = \"\\t\"\n\t}\n\tif co.Delimiter != \",\" && co.Delimiter != \"\\t\" && co.Delimiter != \";\" {\n\t\treturn nil, errors.New(\"invalid delimiter type\")\n\t}\n\n\t// Check fields\n\tif co.Fields == nil || len(co.Fields) <= 0 {\n\t\treturn nil, errors.New(\"must pass fields in order to build json object(s)\")\n\t}\n\n\t// Make sure you set a row count\n\tif co.RowCount <= 0 {\n\t\treturn nil, errors.New(\"must have row count\")\n\t}\n\n\tb := &bytes.Buffer{}\n\tw := csv.NewWriter(b)\n\tw.Comma = []rune(co.Delimiter)[0]\n\n\t// Add header row\n\theader := make([]string, len(co.Fields))\n\tfor i, field := range co.Fields {\n\t\theader[i] = field.Name\n\t}\n\tw.Write(header)\n\n\t// Loop through row count +1(for header) and add fields\n\tfor i := 1; i < co.RowCount+1; i++ {\n\t\tvr := make([]string, len(co.Fields))\n\n\t\t// Loop through fields and add to them to map[string]any\n\t\tfor ii, field := range co.Fields {\n\t\t\tif field.Function == \"autoincrement\" {\n\t\t\t\tvr[ii] = fmt.Sprintf(\"%d\", i)\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\t// Get function info\n\t\t\tfuncInfo := GetFuncLookup(field.Function)\n\t\t\tif funcInfo == nil {\n\t\t\t\treturn nil, errors.New(\"invalid function, \" + field.Function + \" does not exist\")\n\t\t\t}\n\n\t\t\tvalue, err := funcInfo.Generate(f, &field.Params, funcInfo)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\n\t\t\tif _, ok := value.([]byte); ok {\n\t\t\t\t// If it's a slice of bytes or struct, unmarshal it into an interface\n\t\t\t\tvar v any\n\t\t\t\tif err := json.Unmarshal(value.([]byte), &v); err != nil {\n\t\t\t\t\treturn nil, err\n\t\t\t\t}\n\t\t\t\tvalue = v\n\t\t\t}\n\n\t\t\t// If the value is a list of possible values, marsha it into a string\n\t\t\tif reflect.TypeOf(value).Kind() == reflect.Struct ||\n\t\t\t\treflect.TypeOf(value).Kind() == reflect.Ptr ||\n\t\t\t\treflect.TypeOf(value).Kind() == reflect.Map ||\n\t\t\t\treflect.TypeOf(value).Kind() == reflect.Slice {\n\t\t\t\tb, err := json.Marshal(value)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn nil, err\n\t\t\t\t}\n\t\t\t\tvalue = string(b)\n\t\t\t}\n\n\t\t\tvr[ii] = fmt.Sprintf(\"%v\", value)\n\t\t}\n\n\t\tw.Write(vr)\n\t}\n\n\tw.Flush()\n\n\tif err := w.Error(); err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn b.Bytes(), nil\n}\n\nfunc addFileCSVLookup() {\n\tAddFuncLookup(\"csv\", Info{\n\t\tDisplay:     \"CSV\",\n\t\tCategory:    \"file\",\n\t\tDescription: \"Individual lines or data entries within a CSV (Comma-Separated Values) format\",\n\t\tExample: `id,first_name,last_name,password\n1,Markus,Moen,Dc0VYXjkWABx\n2,Osborne,Hilll,XPJ9OVNbs5lm`,\n\t\tOutput:      \"[]byte\",\n\t\tContentType: \"text/csv\",\n\t\tParams: []Param{\n\t\t\t{Field: \"delimiter\", Display: \"Delimiter\", Type: \"string\", Default: \",\", Description: \"Separator in between row values\"},\n\t\t\t{Field: \"rowcount\", Display: \"Row Count\", Type: \"int\", Default: \"100\", Description: \"Number of rows\"},\n\t\t\t{Field: \"fields\", Display: \"Fields\", Type: \"[]Field\", Description: \"Fields containing key name and function\"},\n\t\t},\n\t\tGenerate: func(f *Faker, m *MapParams, info *Info) (any, error) {\n\t\t\tco := CSVOptions{}\n\n\t\t\tdelimiter, err := info.GetString(m, \"delimiter\")\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\tco.Delimiter = delimiter\n\n\t\t\trowcount, err := info.GetInt(m, \"rowcount\")\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\tco.RowCount = rowcount\n\n\t\t\tfieldsStr, err := info.GetStringArray(m, \"fields\")\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\n\t\t\t// Check to make sure fields has length\n\t\t\tif len(fieldsStr) > 0 {\n\t\t\t\tco.Fields = make([]Field, len(fieldsStr))\n\n\t\t\t\tfor i, f := range fieldsStr {\n\t\t\t\t\t// Unmarshal fields string into fields array\n\t\t\t\t\terr = json.Unmarshal([]byte(f), &co.Fields[i])\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\treturn nil, err\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tcsvOut, err := csvFunc(f, &co)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\n\t\t\treturn csvOut, nil\n\t\t},\n\t})\n}\n"
        },
        {
          "name": "csv_test.go",
          "type": "blob",
          "size": 2.9951171875,
          "content": "package gofakeit\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\t\"testing\"\n)\n\nfunc ExampleCSV_array() {\n\tSeed(11)\n\n\tvalue, err := CSV(&CSVOptions{\n\t\tRowCount: 3,\n\t\tFields: []Field{\n\t\t\t{Name: \"id\", Function: \"autoincrement\"},\n\t\t\t{Name: \"first_name\", Function: \"firstname\"},\n\t\t\t{Name: \"last_name\", Function: \"lastname\"},\n\t\t\t{Name: \"password\", Function: \"password\", Params: MapParams{\"special\": {\"false\"}}},\n\t\t},\n\t})\n\tif err != nil {\n\t\tfmt.Println(err)\n\t}\n\n\tfmt.Println(string(value))\n\n\t// Output: id,first_name,last_name,password\n\t// 1,Sonny,Stiedemann,8nwf0o3sBXcR\n\t// 2,Verda,Brakus,3beWLpq75Lua\n\t// 3,Jules,Cremin,Uu38J14Y8W82\n}\n\nfunc ExampleFaker_CSV_array() {\n\tf := New(11)\n\n\tvalue, err := f.CSV(&CSVOptions{\n\t\tRowCount: 3,\n\t\tFields: []Field{\n\t\t\t{Name: \"id\", Function: \"autoincrement\"},\n\t\t\t{Name: \"first_name\", Function: \"firstname\"},\n\t\t\t{Name: \"last_name\", Function: \"lastname\"},\n\t\t\t{Name: \"password\", Function: \"password\", Params: MapParams{\"special\": {\"false\"}}},\n\t\t},\n\t})\n\tif err != nil {\n\t\tfmt.Println(err)\n\t}\n\n\tfmt.Println(string(value))\n\n\t// Output: id,first_name,last_name,password\n\t// 1,Sonny,Stiedemann,8nwf0o3sBXcR\n\t// 2,Verda,Brakus,3beWLpq75Lua\n\t// 3,Jules,Cremin,Uu38J14Y8W82\n}\n\nfunc TestCSVLookup(t *testing.T) {\n\tfaker := New(0)\n\n\tinfo := GetFuncLookup(\"csv\")\n\n\tm := MapParams{\n\t\t\"rowcount\": {\"10\"},\n\t\t\"fields\": {\n\t\t\t`{\"name\":\"id\",\"function\":\"autoincrement\"}`,\n\t\t\t`{\"name\":\"first_name\",\"function\":\"firstname\"}`,\n\t\t\t`{\"name\":\"password\",\"function\":\"password\",\"params\":{\"special\":[\"false\"],\"length\":[\"20\"]}}`,\n\t\t\t`{\"name\":\"address\",\"function\":\"address\"}`,\n\t\t\t`{\n\t\t\t\t\"name\":\"json\",\n\t\t\t\t\"function\":\"json\",\n\t\t\t\t\"params\":{\n\t\t\t\t\t\"type\":\"object\",\n\t\t\t\t\t\"fields\":[\n\t\t\t\t\t\t{\"name\":\"id\",\"function\":\"autoincrement\"},\n\t\t\t\t\t\t{\"name\":\"first_name\",\"function\":\"firstname\"},\n\t\t\t\t\t\t{\"name\":\"last_name\",\"function\":\"lastname\"},\n\t\t\t\t\t\t{\"name\":\"password\",\"function\":\"password\",\"params\":{\"special\":\"false\",\"length\":\"20\"}}\n\t\t\t\t\t]\n\t\t\t\t}\n\t\t\t}`,\n\t\t},\n\t}\n\n\toutput, err := info.Generate(faker, &m, info)\n\tif err != nil {\n\t\tt.Fatal(err.Error())\n\t}\n\n\tvalue := string(output.([]byte))\n\n\t// Check that value has the correct number of rows via new line characters plus 1 for the header\n\tif strings.Count(value, \"\\n\") != 11 {\n\t\tt.Error(\"Expected 10+1(header row) rows, got\", strings.Count(value, \"\\n\")+1)\n\t}\n\n\t// t.Fatal(fmt.Sprintf(\"%s\", value.([]byte)))\n}\n\nfunc TestCSVNoOptions(t *testing.T) {\n\tSeed(11)\n\n\t// if CSVOptions is nil -> get a random CSVOptions\n\t_, err := CSV(nil)\n\tif err != nil {\n\t\tt.Fatal(err.Error())\n\t}\n}\n\nfunc BenchmarkCSVLookup100(b *testing.B) {\n\tfaker := New(0)\n\n\tfor i := 0; i < b.N; i++ {\n\t\tinfo := GetFuncLookup(\"csv\")\n\t\tm := MapParams{\n\t\t\t\"rowcount\": {\"100\"},\n\t\t\t\"fields\": {\n\t\t\t\t`{\"name\":\"id\",\"function\":\"autoincrement\"}`,\n\t\t\t\t`{\"name\":\"first_name\",\"function\":\"firstname\"}`,\n\t\t\t\t`{\"name\":\"last_name\",\"function\":\"lastname\"}`,\n\t\t\t\t`{\"name\":\"password\",\"function\":\"password\"}`,\n\t\t\t\t`{\"name\":\"description\",\"function\":\"paragraph\"}`,\n\t\t\t\t`{\"name\":\"created_at\",\"function\":\"date\"}`,\n\t\t\t},\n\t\t}\n\t\t_, err := info.Generate(faker, &m, info)\n\t\tif err != nil {\n\t\t\tb.Fatal(err.Error())\n\t\t}\n\t}\n}\n"
        },
        {
          "name": "data",
          "type": "tree",
          "content": null
        },
        {
          "name": "doc.go",
          "type": "blob",
          "size": 0.091796875,
          "content": "/*\nPackage gofakeit provides a set of functions that generate random data\n*/\npackage gofakeit\n"
        },
        {
          "name": "emoji.go",
          "type": "blob",
          "size": 3.2958984375,
          "content": "package gofakeit\n\n// Emoji will return a random fun emoji\nfunc Emoji() string { return emoji(GlobalFaker) }\n\n// Emoji will return a random fun emoji\nfunc (f *Faker) Emoji() string { return emoji(f) }\n\nfunc emoji(f *Faker) string { return getRandValue(f, []string{\"emoji\", \"emoji\"}) }\n\n// EmojiDescription will return a random fun emoji description\nfunc EmojiDescription() string { return emojiDescription(GlobalFaker) }\n\n// EmojiDescription will return a random fun emoji description\nfunc (f *Faker) EmojiDescription() string { return emojiDescription(f) }\n\nfunc emojiDescription(f *Faker) string { return getRandValue(f, []string{\"emoji\", \"description\"}) }\n\n// EmojiCategory will return a random fun emoji category\nfunc EmojiCategory() string { return emojiCategory(GlobalFaker) }\n\n// EmojiCategory will return a random fun emoji category\nfunc (f *Faker) EmojiCategory() string { return emojiCategory(f) }\n\nfunc emojiCategory(f *Faker) string { return getRandValue(f, []string{\"emoji\", \"category\"}) }\n\n// EmojiAlias will return a random fun emoji alias\nfunc EmojiAlias() string { return emojiAlias(GlobalFaker) }\n\n// EmojiAlias will return a random fun emoji alias\nfunc (f *Faker) EmojiAlias() string { return emojiAlias(f) }\n\nfunc emojiAlias(f *Faker) string { return getRandValue(f, []string{\"emoji\", \"alias\"}) }\n\n// EmojiTag will return a random fun emoji tag\nfunc EmojiTag() string { return emojiTag(GlobalFaker) }\n\n// EmojiTag will return a random fun emoji tag\nfunc (f *Faker) EmojiTag() string { return emojiTag(f) }\n\nfunc emojiTag(f *Faker) string { return getRandValue(f, []string{\"emoji\", \"tag\"}) }\n\nfunc addEmojiLookup() {\n\tAddFuncLookup(\"emoji\", Info{\n\t\tDisplay:     \"Emoji\",\n\t\tCategory:    \"emoji\",\n\t\tDescription: \"Digital symbol expressing feelings or ideas in text messages and online chats\",\n\t\tExample:     \"🤣\",\n\t\tOutput:      \"string\",\n\t\tGenerate: func(f *Faker, m *MapParams, info *Info) (any, error) {\n\t\t\treturn emoji(f), nil\n\t\t},\n\t})\n\n\tAddFuncLookup(\"emojidescription\", Info{\n\t\tDisplay:     \"Emoji Description\",\n\t\tCategory:    \"emoji\",\n\t\tDescription: \"Brief explanation of the meaning or emotion conveyed by an emoji\",\n\t\tExample:     \"face vomiting\",\n\t\tOutput:      \"string\",\n\t\tGenerate: func(f *Faker, m *MapParams, info *Info) (any, error) {\n\t\t\treturn emojiDescription(f), nil\n\t\t},\n\t})\n\n\tAddFuncLookup(\"emojicategory\", Info{\n\t\tDisplay:     \"Emoji Category\",\n\t\tCategory:    \"emoji\",\n\t\tDescription: \"Group or classification of emojis based on their common theme or use, like 'smileys' or 'animals'\",\n\t\tExample:     \"Smileys & Emotion\",\n\t\tOutput:      \"string\",\n\t\tGenerate: func(f *Faker, m *MapParams, info *Info) (any, error) {\n\t\t\treturn emojiCategory(f), nil\n\t\t},\n\t})\n\n\tAddFuncLookup(\"emojialias\", Info{\n\t\tDisplay:     \"Emoji Alias\",\n\t\tCategory:    \"emoji\",\n\t\tDescription: \"Alternative name or keyword used to represent a specific emoji in text or code\",\n\t\tExample:     \"smile\",\n\t\tOutput:      \"string\",\n\t\tGenerate: func(f *Faker, m *MapParams, info *Info) (any, error) {\n\t\t\treturn emojiAlias(f), nil\n\t\t},\n\t})\n\n\tAddFuncLookup(\"emojitag\", Info{\n\t\tDisplay:     \"Emoji Tag\",\n\t\tCategory:    \"emoji\",\n\t\tDescription: \"Label or keyword associated with an emoji to categorize or search for it easily\",\n\t\tExample:     \"happy\",\n\t\tOutput:      \"string\",\n\t\tGenerate: func(f *Faker, m *MapParams, info *Info) (any, error) {\n\t\t\treturn emojiTag(f), nil\n\t\t},\n\t})\n}\n"
        },
        {
          "name": "emoji_test.go",
          "type": "blob",
          "size": 1.4365234375,
          "content": "package gofakeit\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc ExampleEmoji() {\n\tSeed(11)\n\tfmt.Println(Emoji())\n\n\t// Output: 🇫🇴\n}\n\nfunc ExampleFaker_Emoji() {\n\tf := New(11)\n\tfmt.Println(f.Emoji())\n\n\t// Output: 🇫🇴\n}\n\nfunc BenchmarkEmoji(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tEmoji()\n\t}\n}\n\nfunc ExampleEmojiDescription() {\n\tSeed(11)\n\tfmt.Println(EmojiDescription())\n\n\t// Output: flag: European Union\n}\n\nfunc ExampleFaker_EmojiDescription() {\n\tf := New(11)\n\tfmt.Println(f.EmojiDescription())\n\n\t// Output: flag: European Union\n}\n\nfunc BenchmarkEmojiDescription(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tEmojiDescription()\n\t}\n}\n\nfunc ExampleEmojiCategory() {\n\tSeed(11)\n\tfmt.Println(EmojiCategory())\n\n\t// Output: Flags\n}\n\nfunc ExampleFaker_EmojiCategory() {\n\tf := New(11)\n\tfmt.Println(f.EmojiCategory())\n\n\t// Output: Flags\n}\n\nfunc BenchmarkEmojiCategory(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tEmojiCategory()\n\t}\n}\n\nfunc ExampleEmojiAlias() {\n\tSeed(11)\n\tfmt.Println(EmojiAlias())\n\n\t// Output: eritrea\n}\n\nfunc ExampleFaker_EmojiAlias() {\n\tf := New(11)\n\tfmt.Println(f.EmojiAlias())\n\n\t// Output: eritrea\n}\n\nfunc BenchmarkEmojiAlias(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tEmojiAlias()\n\t}\n}\n\nfunc ExampleEmojiTag() {\n\tSeed(11)\n\tfmt.Println(EmojiTag())\n\n\t// Output: toilet\n}\n\nfunc ExampleFaker_EmojiTag() {\n\tf := New(11)\n\tfmt.Println(f.EmojiTag())\n\n\t// Output: toilet\n}\n\nfunc BenchmarkEmojiTag(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tEmojiTag()\n\t}\n}\n"
        },
        {
          "name": "error.go",
          "type": "blob",
          "size": 6.5263671875,
          "content": "package gofakeit\n\nimport (\n\t\"errors\"\n)\n\n// Error will return a random generic error\nfunc Error() error {\n\treturn err(GlobalFaker)\n}\n\n// Error will return a random generic error\nfunc (f *Faker) Error() error {\n\treturn err(f)\n}\n\nfunc err(f *Faker) error {\n\tgenStr, _ := generate(f, getRandValue(f, []string{\"error\", \"generic\"}))\n\treturn errors.New(genStr)\n}\n\n// ErrorObject will return a random error object word\nfunc ErrorObject() error {\n\treturn errorObject(GlobalFaker)\n}\n\n// ErrorObject will return a random error object word\nfunc (f *Faker) ErrorObject() error {\n\treturn errorObject(f)\n}\n\nfunc errorObject(f *Faker) error {\n\tgenStr, _ := generate(f, getRandValue(f, []string{\"error\", \"object\"}))\n\treturn errors.New(genStr)\n}\n\n// ErrorDatabase will return a random database error\nfunc ErrorDatabase() error {\n\treturn errorDatabase(GlobalFaker)\n}\n\n// ErrorDatabase will return a random database error\nfunc (f *Faker) ErrorDatabase() error {\n\treturn errorDatabase(f)\n}\n\nfunc errorDatabase(f *Faker) error {\n\tgenStr, _ := generate(f, getRandValue(f, []string{\"error\", \"database\"}))\n\treturn errors.New(genStr)\n}\n\n// ErrorGRPC will return a random gRPC error\nfunc ErrorGRPC() error {\n\treturn errorGRPC(GlobalFaker)\n}\n\n// ErrorGRPC will return a random gRPC error\nfunc (f *Faker) ErrorGRPC() error {\n\treturn errorGRPC(f)\n}\n\nfunc errorGRPC(f *Faker) error {\n\tgenStr, _ := generate(f, getRandValue(f, []string{\"error\", \"grpc\"}))\n\treturn errors.New(genStr)\n}\n\n// ErrorHTTP will return a random HTTP error\nfunc ErrorHTTP() error {\n\treturn errorHTTP(GlobalFaker)\n}\n\n// ErrorHTTP will return a random HTTP error\nfunc (f *Faker) ErrorHTTP() error {\n\treturn errorHTTP(f)\n}\n\nfunc errorHTTP(f *Faker) error {\n\tgenStr, _ := generate(f, getRandValue(f, []string{\"error\", \"http\"}))\n\treturn errors.New(genStr)\n}\n\n// ErrorHTTPClient will return a random HTTP client error response (400-418)\nfunc ErrorHTTPClient() error {\n\treturn errorHTTPClient(GlobalFaker)\n}\n\n// ErrorHTTPClient will return a random HTTP client error response (400-418)\nfunc (f *Faker) ErrorHTTPClient() error {\n\treturn errorHTTPClient(f)\n}\n\nfunc errorHTTPClient(f *Faker) error {\n\tgenStr, _ := generate(f, getRandValue(f, []string{\"error\", \"http_client\"}))\n\treturn errors.New(genStr)\n}\n\n// ErrorHTTPServer will return a random HTTP server error response (500-511)\nfunc ErrorHTTPServer() error {\n\treturn errorHTTPServer(GlobalFaker)\n}\n\n// ErrorHTTPServer will return a random HTTP server error response (500-511)\nfunc (f *Faker) ErrorHTTPServer() error {\n\treturn errorHTTPServer(f)\n}\n\nfunc errorHTTPServer(f *Faker) error {\n\tgenStr, _ := generate(f, getRandValue(f, []string{\"error\", \"http_server\"}))\n\treturn errors.New(genStr)\n}\n\n// ErrorRuntime will return a random runtime error\nfunc ErrorRuntime() error {\n\treturn errorRuntime(GlobalFaker)\n}\n\n// ErrorRuntime will return a random runtime error\nfunc (f *Faker) ErrorRuntime() error {\n\treturn errorRuntime(f)\n}\n\nfunc errorRuntime(f *Faker) error {\n\tgenStr, _ := generate(f, getRandValue(f, []string{\"error\", \"runtime\"}))\n\treturn errors.New(genStr)\n}\n\n// ErrorValidation will return a random validation error\nfunc ErrorValidation() error {\n\treturn errorValidation(GlobalFaker)\n}\n\n// ErrorValidation will return a random validation error\nfunc (f *Faker) ErrorValidation() error {\n\treturn errorValidation(f)\n}\n\nfunc errorValidation(f *Faker) error {\n\tgenStr, _ := generate(f, getRandValue(f, []string{\"error\", \"validation\"}))\n\treturn errors.New(genStr)\n}\n\nfunc addErrorLookup() {\n\tAddFuncLookup(\"error\", Info{\n\t\tDisplay:     \"Error\",\n\t\tCategory:    \"error\",\n\t\tDescription: \"Message displayed by a computer or software when a problem or mistake is encountered\",\n\t\tExample:     \"syntax error\",\n\t\tOutput:      \"string\",\n\t\tGenerate: func(f *Faker, m *MapParams, info *Info) (any, error) {\n\t\t\treturn err(f), nil\n\t\t},\n\t})\n\n\tAddFuncLookup(\"errorobject\", Info{\n\t\tDisplay:     \"Error object word\",\n\t\tCategory:    \"error\",\n\t\tDescription: \"Various categories conveying details about encountered errors\",\n\t\tExample:     \"protocol\",\n\t\tOutput:      \"string\",\n\t\tGenerate: func(f *Faker, m *MapParams, info *Info) (any, error) {\n\t\t\treturn errorObject(f), nil\n\t\t},\n\t})\n\n\tAddFuncLookup(\"errordatabase\", Info{\n\t\tDisplay:     \"Database error\",\n\t\tCategory:    \"error\",\n\t\tDescription: \"A problem or issue encountered while accessing or managing a database\",\n\t\tExample:     \"sql error\",\n\t\tOutput:      \"string\",\n\t\tGenerate: func(f *Faker, m *MapParams, info *Info) (any, error) {\n\t\t\treturn errorDatabase(f), nil\n\t\t},\n\t})\n\n\tAddFuncLookup(\"errorgrpc\", Info{\n\t\tDisplay:     \"gRPC error\",\n\t\tCategory:    \"error\",\n\t\tDescription: \"Communication failure in the high-performance, open-source universal RPC framework\",\n\t\tExample:     \"client protocol error\",\n\t\tOutput:      \"string\",\n\t\tGenerate: func(f *Faker, m *MapParams, info *Info) (any, error) {\n\t\t\treturn errorGRPC(f), nil\n\t\t},\n\t})\n\n\tAddFuncLookup(\"errorhttp\", Info{\n\t\tDisplay:     \"HTTP error\",\n\t\tCategory:    \"error\",\n\t\tDescription: \"A problem with a web http request\",\n\t\tExample:     \"invalid method\",\n\t\tOutput:      \"string\",\n\t\tGenerate: func(f *Faker, m *MapParams, info *Info) (any, error) {\n\t\t\treturn errorHTTP(f), nil\n\t\t},\n\t})\n\n\tAddFuncLookup(\"errorhttpclient\", Info{\n\t\tDisplay:     \"HTTP client error\",\n\t\tCategory:    \"error\",\n\t\tDescription: \"Failure or issue occurring within a client software that sends requests to web servers\",\n\t\tExample:     \"request timeout\",\n\t\tOutput:      \"string\",\n\t\tGenerate: func(f *Faker, m *MapParams, info *Info) (any, error) {\n\t\t\treturn errorHTTPClient(f), nil\n\t\t},\n\t})\n\n\tAddFuncLookup(\"errorhttpserver\", Info{\n\t\tDisplay:     \"HTTP server error\",\n\t\tCategory:    \"error\",\n\t\tDescription: \"Failure or issue occurring within a server software that recieves requests from clients\",\n\t\tExample:     \"internal server error\",\n\t\tOutput:      \"string\",\n\t\tGenerate: func(f *Faker, m *MapParams, info *Info) (any, error) {\n\t\t\treturn errorHTTPServer(f), nil\n\t\t},\n\t})\n\n\tAddFuncLookup(\"errorruntime\", Info{\n\t\tDisplay:     \"Runtime error\",\n\t\tCategory:    \"error\",\n\t\tDescription: \"Malfunction occuring during program execution, often causing abrupt termination or unexpected behavior\",\n\t\tExample:     \"address out of bounds\",\n\t\tOutput:      \"string\",\n\t\tGenerate: func(f *Faker, m *MapParams, info *Info) (any, error) {\n\t\t\treturn errorRuntime(f), nil\n\t\t},\n\t})\n\n\tAddFuncLookup(\"errorvalidation\", Info{\n\t\tDisplay:     \"Validation error\",\n\t\tCategory:    \"error\",\n\t\tDescription: \"Occurs when input data fails to meet required criteria or format specifications\",\n\t\tExample:     \"missing required field\",\n\t\tOutput:      \"string\",\n\t\tGenerate: func(f *Faker, m *MapParams, info *Info) (any, error) {\n\t\t\treturn errorValidation(f), nil\n\t\t},\n\t})\n}\n"
        },
        {
          "name": "error_test.go",
          "type": "blob",
          "size": 2.8720703125,
          "content": "package gofakeit\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc ExampleError() {\n\tSeed(11)\n\tfmt.Println(Error())\n\n\t// Output: variable assigned before declaration\n}\n\nfunc ExampleFaker_Error() {\n\tf := New(11)\n\tfmt.Println(f.Error())\n\n\t// Output: variable assigned before declaration\n}\n\nfunc BenchmarkError(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tError()\n\t}\n}\n\nfunc ExampleErrorObject() {\n\tSeed(11)\n\tfmt.Println(ErrorObject())\n\n\t// Output: url\n}\n\nfunc ExampleFaker_ErrorObject() {\n\tf := New(11)\n\tfmt.Println(f.ErrorObject())\n\n\t// Output: url\n}\n\nfunc BenchmarkErrorObject(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tErrorObject()\n\t}\n}\n\nfunc ExampleErrorDatabase() {\n\tSeed(11)\n\tfmt.Println(ErrorDatabase())\n\n\t// Output: destination pointer is nil\n}\n\nfunc ExampleFaker_ErrorDatabase() {\n\tf := New(11)\n\tfmt.Println(f.ErrorDatabase())\n\n\t// Output: destination pointer is nil\n}\n\nfunc BenchmarkErrorDatabase(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tErrorDatabase()\n\t}\n}\n\nfunc ExampleErrorGRPC() {\n\tSeed(11)\n\tfmt.Println(ErrorGRPC())\n\n\t// Output: connection refused\n}\n\nfunc ExampleFaker_ErrorGRPC() {\n\tf := New(11)\n\tfmt.Println(f.ErrorGRPC())\n\n\t// Output: connection refused\n}\n\nfunc BenchmarkErrorGRPC(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tErrorGRPC()\n\t}\n}\n\nfunc ExampleErrorHTTP() {\n\tSeed(11)\n\tfmt.Println(ErrorHTTP())\n\n\t// Output: wrote more than the declared Content-Length\n}\n\nfunc ExampleFaker_ErrorHTTP() {\n\tf := New(11)\n\tfmt.Println(f.ErrorHTTP())\n\n\t// Output: wrote more than the declared Content-Length\n}\n\nfunc BenchmarkErrorHTTP(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tErrorHTTP()\n\t}\n}\n\nfunc ExampleErrorHTTPClient() {\n\tSeed(11)\n\tfmt.Println(ErrorHTTPClient())\n\n\t// Output: expectation failed\n}\n\nfunc ExampleFaker_ErrorHTTPClient() {\n\tf := New(11)\n\tfmt.Println(f.ErrorHTTPClient())\n\n\t// Output: expectation failed\n}\n\nfunc BenchmarkErrorHTTPClient(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tErrorHTTPClient()\n\t}\n}\n\nfunc ExampleErrorHTTPServer() {\n\tSeed(11)\n\tfmt.Println(ErrorHTTPServer())\n\n\t// Output: not extended\n}\n\nfunc ExampleFaker_ErrorHTTPServer() {\n\tf := New(11)\n\tfmt.Println(f.ErrorHTTPServer())\n\n\t// Output: not extended\n}\n\nfunc BenchmarkErrorHTTPServer(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tErrorHTTPServer()\n\t}\n}\n\nfunc ExampleErrorRuntime() {\n\tSeed(11)\n\tfmt.Println(ErrorRuntime())\n\n\t// Output: expected 2 arguments, got 3\n}\n\nfunc ExampleFaker_ErrorRuntime() {\n\tf := New(11)\n\tfmt.Println(f.ErrorRuntime())\n\n\t// Output: expected 2 arguments, got 3\n}\n\nfunc BenchmarkErrorRuntime(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tErrorRuntime()\n\t}\n}\n\nfunc ExampleErrorValidation() {\n\tSeed(11)\n\tfmt.Println(ErrorValidation())\n\n\t// Output: payment details cannot be verified\n}\n\nfunc ExampleFaker_ErrorValidation() {\n\tf := New(11)\n\tfmt.Println(f.ErrorValidation())\n\n\t// Output: payment details cannot be verified\n}\n\nfunc BenchmarkErrorValidation(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tErrorValidation()\n\t}\n}\n"
        },
        {
          "name": "fakeable.go",
          "type": "blob",
          "size": 2.4228515625,
          "content": "package gofakeit\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"reflect\"\n)\n\n// Fakeable is an interface that can be implemented by a type to provide a custom fake value.\ntype Fakeable interface {\n\t// Fake returns a fake value for the type.\n\tFake(faker *Faker) (any, error)\n}\n\nfunc isFakeable(t reflect.Type) bool {\n\tfakeableTyp := reflect.TypeOf((*Fakeable)(nil)).Elem()\n\n\treturn t.Implements(fakeableTyp) || reflect.PointerTo(t).Implements(fakeableTyp)\n}\n\nfunc callFake(faker *Faker, v reflect.Value, possibleKinds ...reflect.Kind) (any, error) {\n\tf, ok := v.Addr().Interface().(Fakeable)\n\tif !ok {\n\t\treturn nil, errors.New(\"not a Fakeable type\")\n\t}\n\n\tfakedValue, err := f.Fake(faker)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"error calling Fake: %w\", err)\n\t}\n\tk := reflect.TypeOf(fakedValue).Kind()\n\tif !containsKind(possibleKinds, k) {\n\t\treturn nil, fmt.Errorf(\"returned value kind %q is not amongst the valid ones: %v\", k, possibleKinds)\n\t}\n\n\tswitch k {\n\tcase reflect.String:\n\t\treturn reflect.ValueOf(fakedValue).String(), nil\n\tcase reflect.Bool:\n\t\treturn reflect.ValueOf(fakedValue).Bool(), nil\n\tcase reflect.Int:\n\t\treturn int(reflect.ValueOf(fakedValue).Int()), nil\n\tcase reflect.Int8:\n\t\treturn int8(reflect.ValueOf(fakedValue).Int()), nil\n\tcase reflect.Int16:\n\t\treturn int16(reflect.ValueOf(fakedValue).Int()), nil\n\tcase reflect.Int32:\n\t\treturn int32(reflect.ValueOf(fakedValue).Int()), nil\n\tcase reflect.Int64:\n\t\treturn int64(reflect.ValueOf(fakedValue).Int()), nil\n\tcase reflect.Uint:\n\t\treturn uint(reflect.ValueOf(fakedValue).Uint()), nil\n\tcase reflect.Uint8:\n\t\treturn uint8(reflect.ValueOf(fakedValue).Uint()), nil\n\tcase reflect.Uint16:\n\t\treturn uint16(reflect.ValueOf(fakedValue).Uint()), nil\n\tcase reflect.Uint32:\n\t\treturn uint32(reflect.ValueOf(fakedValue).Uint()), nil\n\tcase reflect.Uint64:\n\t\treturn uint64(reflect.ValueOf(fakedValue).Uint()), nil\n\tcase reflect.Float32:\n\t\treturn float32(reflect.ValueOf(fakedValue).Float()), nil\n\tcase reflect.Float64:\n\t\treturn float64(reflect.ValueOf(fakedValue).Float()), nil\n\tcase reflect.Slice, reflect.Array:\n\t\treturn reflect.ValueOf(fakedValue).Interface(), nil\n\tcase reflect.Map:\n\t\treturn reflect.ValueOf(fakedValue).Interface(), nil\n\tcase reflect.Struct:\n\t\treturn reflect.ValueOf(fakedValue).Interface(), nil\n\n\tdefault:\n\t\treturn nil, fmt.Errorf(\"unsupported type %q\", k)\n\t}\n}\n\nfunc containsKind(possibleKinds []reflect.Kind, kind reflect.Kind) bool {\n\tfor _, k := range possibleKinds {\n\t\tif k == kind {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n"
        },
        {
          "name": "fakeable_external_test.go",
          "type": "blob",
          "size": 17.3388671875,
          "content": "package gofakeit_test\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/brianvoe/gofakeit/v7\"\n)\n\nvar (\n\ttestTimeValue = time.Now()\n)\n\ntype CustomString string\n\nfunc (c CustomString) Fake(faker *gofakeit.Faker) (any, error) {\n\treturn CustomString(\"hello test\"), nil\n}\n\ntype CustomBool bool\n\nfunc (c CustomBool) Fake(faker *gofakeit.Faker) (any, error) {\n\treturn CustomBool(true), nil\n}\n\ntype CustomInt int\n\nfunc (c CustomInt) Fake(faker *gofakeit.Faker) (any, error) {\n\treturn CustomInt(-42), nil\n}\n\ntype CustomInt8 int8\n\nfunc (c CustomInt8) Fake(faker *gofakeit.Faker) (any, error) {\n\treturn CustomInt8(-42), nil\n}\n\ntype CustomInt16 int16\n\nfunc (c CustomInt16) Fake(faker *gofakeit.Faker) (any, error) {\n\treturn CustomInt16(-42), nil\n}\n\ntype CustomInt32 int32\n\nfunc (c CustomInt32) Fake(faker *gofakeit.Faker) (any, error) {\n\treturn CustomInt32(-42), nil\n}\n\ntype CustomInt64 int64\n\nfunc (c CustomInt64) Fake(faker *gofakeit.Faker) (any, error) {\n\treturn CustomInt64(-42), nil\n}\n\ntype CustomUint uint\n\nfunc (c CustomUint) Fake(faker *gofakeit.Faker) (any, error) {\n\treturn CustomUint(42), nil\n}\n\ntype CustomUint8 uint8\n\nfunc (c CustomUint8) Fake(faker *gofakeit.Faker) (any, error) {\n\treturn CustomUint8(42), nil\n}\n\ntype CustomUint16 uint16\n\nfunc (c CustomUint16) Fake(faker *gofakeit.Faker) (any, error) {\n\treturn CustomUint16(42), nil\n}\n\ntype CustomUint32 uint32\n\nfunc (c CustomUint32) Fake(faker *gofakeit.Faker) (any, error) {\n\treturn CustomUint32(42), nil\n}\n\ntype CustomUint64 uint64\n\nfunc (c CustomUint64) Fake(faker *gofakeit.Faker) (any, error) {\n\treturn CustomUint64(42), nil\n}\n\ntype CustomFloat32 float32\n\nfunc (c CustomFloat32) Fake(faker *gofakeit.Faker) (any, error) {\n\treturn CustomFloat32(42.123), nil\n}\n\ntype CustomFloat64 float64\n\nfunc (c CustomFloat64) Fake(faker *gofakeit.Faker) (any, error) {\n\treturn CustomFloat64(42.123), nil\n}\n\ntype CustomTime time.Time\n\nfunc (c *CustomTime) Fake(faker *gofakeit.Faker) (any, error) {\n\treturn CustomTime(testTimeValue), nil\n}\n\nfunc (c CustomTime) String() string {\n\treturn time.Time(c).String()\n}\n\ntype CustomSlice []string\n\nfunc (c CustomSlice) Fake(faker *gofakeit.Faker) (any, error) {\n\treturn CustomSlice([]string{\"hello\", \"test\"}), nil\n}\n\ntype CustomMap map[string]string\n\nfunc (c CustomMap) Fake(faker *gofakeit.Faker) (any, error) {\n\treturn CustomMap(map[string]string{\"hello\": \"1\", \"test\": \"2\"}), nil\n}\n\ntype CustomArray [2]int\n\nfunc (c CustomArray) Fake(faker *gofakeit.Faker) (any, error) {\n\treturn CustomArray([2]int{1, 2}), nil\n}\n\ntype CustomStruct struct {\n\tStr string\n\tInt int\n}\n\nfunc (c CustomStruct) Fake(faker *gofakeit.Faker) (any, error) {\n\treturn CustomStruct{\n\t\tStr: \"hello test\",\n\t\tInt: 42,\n\t}, nil\n}\n\ntype NestedCustom struct {\n\tStr          CustomString\n\tPtrStr       *CustomString\n\tBool         CustomBool\n\tInt          CustomInt\n\tInt8         CustomInt8\n\tInt16        CustomInt16\n\tInt32        CustomInt32\n\tInt64        CustomInt64\n\tUint         CustomUint\n\tUint8        CustomUint8\n\tUint16       CustomUint16\n\tUint32       CustomUint32\n\tUint64       CustomUint64\n\tFloat32      CustomFloat32\n\tFloat64      CustomFloat64\n\tTimestamp    CustomTime\n\tPtrTimestamp *CustomTime\n\tSliceStr     CustomSlice\n\tArray        CustomArray\n\tMapStr       CustomMap\n\tStruct       CustomStruct\n\tPtrStruct    *CustomStruct\n}\n\ntype NestedOverrideCustom struct {\n\tStr          CustomString  `fake:\"{name}\"`\n\tPtrStr       *CustomString `fake:\"{name}\"`\n\tBool         CustomBool    `fake:\"false\"`\n\tInt          CustomInt     `fake:\"{number:-10,1000}\"`\n\tInt8         CustomInt8    `fake:\"{number:-10,1000}\"`\n\tInt16        CustomInt16   `fake:\"{number:-10,1000}\"`\n\tInt32        CustomInt32   `fake:\"{number:-10,1000}\"`\n\tInt64        CustomInt64   `fake:\"{number:-10,1000}\"`\n\tUint         CustomUint    `fake:\"{number:100,1000}\"`\n\tUint8        CustomUint8   `fake:\"{number:100,1000}\"`\n\tUint16       CustomUint16  `fake:\"{number:100,1000}\"`\n\tUint32       CustomUint32  `fake:\"{number:100,1000}\"`\n\tUint64       CustomUint64  `fake:\"{number:100,1000}\"`\n\tFloat32      CustomFloat32 `fake:\"{number:100,1000}\"`\n\tFloat64      CustomFloat64 `fake:\"{number:100,1000}\"`\n\tTimestamp    CustomTime    `fake:\"{raw_test_date}\"`\n\tPtrTimestamp *CustomTime   `fake:\"{raw_test_date}\"`\n\tSliceStr     CustomSlice   `fake:\"{word}\"`\n\tArray        CustomArray   `fake:\"{number:100,1000}\"`\n\tMapStr       CustomMap     `fakesize:\"2\"`\n}\n\nfunc TestCustomString(t *testing.T) {\n\tvar d CustomString\n\terr := gofakeit.Struct(&d)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\texpected := \"hello test\"\n\tif d != CustomString(expected) {\n\t\tt.Errorf(\"expected %q, got %q\", expected, d)\n\t}\n}\n\nfunc TestCustomBool(t *testing.T) {\n\tvar d CustomBool\n\terr := gofakeit.Struct(&d)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\texpected := true\n\tif d != CustomBool(expected) {\n\t\tt.Errorf(\"expected %t, got %t\", expected, d)\n\t}\n}\n\nfunc TestCustomInt(t *testing.T) {\n\tvar d CustomInt\n\terr := gofakeit.Struct(&d)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\texpected := -42\n\tif d != CustomInt(expected) {\n\t\tt.Errorf(\"expected %d, got %d\", expected, d)\n\t}\n}\n\nfunc TestCustomInt8(t *testing.T) {\n\tvar d CustomInt8\n\terr := gofakeit.Struct(&d)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\texpected := -42\n\tif d != CustomInt8(expected) {\n\t\tt.Errorf(\"expected %d, got %d\", expected, d)\n\t}\n}\n\nfunc TestCustomInt16(t *testing.T) {\n\tvar d CustomInt16\n\terr := gofakeit.Struct(&d)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\texpected := -42\n\tif d != CustomInt16(expected) {\n\t\tt.Errorf(\"expected %d, got %d\", expected, d)\n\t}\n}\n\nfunc TestCustomInt32(t *testing.T) {\n\tvar d CustomInt32\n\terr := gofakeit.Struct(&d)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\texpected := -42\n\tif d != CustomInt32(expected) {\n\t\tt.Errorf(\"expected %d, got %d\", expected, d)\n\t}\n}\n\nfunc TestCustomInt64(t *testing.T) {\n\tvar d CustomInt64\n\terr := gofakeit.Struct(&d)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\texpected := -42\n\tif d != CustomInt64(expected) {\n\t\tt.Errorf(\"expected %d, got %d\", expected, d)\n\t}\n}\n\nfunc TestCustomUint(t *testing.T) {\n\tvar d CustomUint\n\terr := gofakeit.Struct(&d)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\texpected := 42\n\tif d != CustomUint(expected) {\n\t\tt.Errorf(\"expected %d, got %d\", expected, d)\n\t}\n}\n\nfunc TestCustomUint8(t *testing.T) {\n\tvar d CustomUint8\n\terr := gofakeit.Struct(&d)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\texpected := 42\n\tif d != CustomUint8(expected) {\n\t\tt.Errorf(\"expected %d, got %d\", expected, d)\n\t}\n}\n\nfunc TestCustomUint16(t *testing.T) {\n\tvar d CustomUint16\n\terr := gofakeit.Struct(&d)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\texpected := 42\n\tif d != CustomUint16(expected) {\n\t\tt.Errorf(\"expected %d, got %d\", expected, d)\n\t}\n}\n\nfunc TestCustomUint32(t *testing.T) {\n\tvar d CustomUint32\n\terr := gofakeit.Struct(&d)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\texpected := 42\n\tif d != CustomUint32(expected) {\n\t\tt.Errorf(\"expected %d, got %d\", expected, d)\n\t}\n}\n\nfunc TestCustomUint64(t *testing.T) {\n\tvar d CustomUint64\n\terr := gofakeit.Struct(&d)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\texpected := 42\n\tif d != CustomUint64(expected) {\n\t\tt.Errorf(\"expected %d, got %d\", expected, d)\n\t}\n}\nfunc TestCustomFloat32(t *testing.T) {\n\tvar d CustomFloat32\n\terr := gofakeit.Struct(&d)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\texpected := 42.123\n\tif d != CustomFloat32(expected) {\n\t\tt.Errorf(\"expected %f, got %f\", expected, d)\n\t}\n}\n\nfunc TestCustomFloat64(t *testing.T) {\n\tvar d CustomFloat64\n\terr := gofakeit.Struct(&d)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\texpected := 42.123\n\tif d != CustomFloat64(expected) {\n\t\tt.Errorf(\"expected %f, got %f\", expected, d)\n\t}\n}\n\nfunc TestCustomTime(t *testing.T) {\n\tvar d CustomTime\n\terr := gofakeit.Struct(&d)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\texpected := testTimeValue\n\tif d != CustomTime(expected) {\n\t\tt.Errorf(\"expected %q, got %q\", expected.String(), d.String())\n\t}\n}\n\nfunc TestCustomTimePtr(t *testing.T) {\n\tvar d *CustomTime\n\terr := gofakeit.Struct(&d)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\texpected := testTimeValue\n\tif d == nil {\n\t\tt.Fatal(\"expected a pointer to a CustomTime, got nil\")\n\t}\n\tif *d != CustomTime(expected) {\n\t\tt.Errorf(\"expected %q, got %q\", expected.String(), d.String())\n\t}\n}\n\nfunc TestCustomSlice(t *testing.T) {\n\tvar d CustomSlice\n\terr := gofakeit.Struct(&d)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\texpected := []string{\"hello\", \"test\"}\n\tif len(d) != len(expected) {\n\t\tt.Fatalf(\"expected %v, got %v\", expected, d)\n\t}\n\tfor i, v := range expected {\n\t\tif d[i] != v {\n\t\t\tt.Errorf(\"expected item %d of the slice to be: %v, got %v\", i, expected[i], d[i])\n\t\t}\n\t}\n}\n\nfunc TestCustomMap(t *testing.T) {\n\tvar d CustomMap\n\terr := gofakeit.Struct(&d)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\texpected := map[string]string{\"hello\": \"1\", \"test\": \"2\"}\n\tif len(d) != len(expected) {\n\t\tt.Fatalf(\"expected %v, got %v\", expected, d)\n\t}\n\tfor k, v := range expected {\n\t\tif d[k] != v {\n\t\t\tt.Errorf(\"expected item %v of the slice to be: %v, got %v\", k, expected[k], d[k])\n\t\t}\n\t}\n}\n\nfunc TestCustomArray(t *testing.T) {\n\tvar d CustomArray\n\terr := gofakeit.Struct(&d)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\texpected := [2]int{1, 2}\n\tfor i, v := range expected {\n\t\tif d[i] != v {\n\t\t\tt.Errorf(\"expected item %d of the array to be: %v, got %v\", i, expected[i], d[i])\n\t\t}\n\t}\n}\n\nfunc TestCustomStruct(t *testing.T) {\n\tvar d CustomStruct\n\terr := gofakeit.Struct(&d)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tif d.Str != \"hello test\" {\n\t\tt.Errorf(\"expected %q, got %q\", \"hello test\", d.Str)\n\t}\n\tif d.Int != 42 {\n\t\tt.Errorf(\"expected %d, got %d\", 42, d.Int)\n\t}\n}\n\nfunc TestNestedCustom(t *testing.T) {\n\tvar d NestedCustom\n\terr := gofakeit.Struct(&d)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\texpectedStr := \"hello test\"\n\tif d.Str != CustomString(expectedStr) {\n\t\tt.Errorf(\"Str: expected %q, got %q\", expectedStr, d.Str)\n\t}\n\n\tif *d.PtrStr != CustomString(expectedStr) {\n\t\tt.Errorf(\"Str: expected %q, got %q\", expectedStr, *d.PtrStr)\n\t}\n\n\tif !d.Bool {\n\t\tt.Errorf(\"Bool: expected true, got false\")\n\t}\n\n\texpectedInt := -42\n\tif d.Int != CustomInt(expectedInt) {\n\t\tt.Errorf(\"Int: expected %d, got %d\", expectedInt, d.Int)\n\t}\n\tif d.Int8 != CustomInt8(expectedInt) {\n\t\tt.Errorf(\"Int: expected %d, got %d\", expectedInt, d.Int8)\n\t}\n\tif d.Int16 != CustomInt16(expectedInt) {\n\t\tt.Errorf(\"Int: expected %d, got %d\", expectedInt, d.Int16)\n\t}\n\tif d.Int32 != CustomInt32(expectedInt) {\n\t\tt.Errorf(\"Int: expected %d, got %d\", expectedInt, d.Int32)\n\t}\n\tif d.Int64 != CustomInt64(expectedInt) {\n\t\tt.Errorf(\"Int: expected %d, got %d\", expectedInt, d.Int64)\n\t}\n\n\texpectedUint := uint(42)\n\tif d.Uint != CustomUint(expectedUint) {\n\t\tt.Errorf(\"Uint: expected %d, got %d\", expectedUint, d.Uint)\n\t}\n\tif d.Uint8 != CustomUint8(expectedUint) {\n\t\tt.Errorf(\"Uint: expected %d, got %d\", expectedUint, d.Uint8)\n\t}\n\tif d.Uint16 != CustomUint16(expectedUint) {\n\t\tt.Errorf(\"Uint: expected %d, got %d\", expectedUint, d.Uint16)\n\t}\n\tif d.Uint32 != CustomUint32(expectedUint) {\n\t\tt.Errorf(\"Uint: expected %d, got %d\", expectedUint, d.Uint32)\n\t}\n\tif d.Uint64 != CustomUint64(expectedUint) {\n\t\tt.Errorf(\"Uint: expected %d, got %d\", expectedUint, d.Uint64)\n\t}\n\n\texpectedFloat := 42.123\n\tif d.Float32 != CustomFloat32(expectedFloat) {\n\t\tt.Errorf(\"Float: expected %f, got %f\", expectedFloat, d.Float32)\n\t}\n\tif d.Float64 != CustomFloat64(expectedFloat) {\n\t\tt.Errorf(\"Float: expected %f, got %f\", expectedFloat, d.Float64)\n\t}\n\n\texpectedSlice := []string{\"hello\", \"test\"}\n\tif len(d.SliceStr) != len(expectedSlice) {\n\t\tt.Fatalf(\"expected %v, got %v\", expectedSlice, d.SliceStr)\n\t}\n\tfor i, v := range expectedSlice {\n\t\tif d.SliceStr[i] != v {\n\t\t\tt.Errorf(\"expected item %d of the slice to be: %v, got %v\", i, expectedSlice[i], d.SliceStr[i])\n\t\t}\n\t}\n\n\texpectedArray := [2]int{1, 2}\n\tfor i, v := range expectedArray {\n\t\tif d.Array[i] != v {\n\t\t\tt.Errorf(\"expected item %d of the slice to be: %v, got %v\", i, expectedArray[i], d.Array[i])\n\t\t}\n\t}\n\n\texpectedMap := map[string]string{\"hello\": \"1\", \"test\": \"2\"}\n\tif len(d.MapStr) != len(expectedMap) {\n\t\tt.Fatalf(\"expected %v, got %v\", expectedMap, d)\n\t}\n\tfor k, v := range expectedMap {\n\t\tif d.MapStr[k] != v {\n\t\t\tt.Errorf(\"expected item %v of the map to be: %v, got %v\", k, expectedMap[k], d.MapStr[k])\n\t\t}\n\t}\n\n\tif d.Struct.Str != \"hello test\" {\n\t\tt.Errorf(\"expected %q, got %q\", \"hello test\", d.Struct.Str)\n\t}\n\tif d.Struct.Int != 42 {\n\t\tt.Errorf(\"expected %d, got %d\", 42, d.Struct.Int)\n\t}\n\n\tif d.PtrStruct == nil {\n\t\tt.Fatal(\"expected PtrStruct to not be nil\")\n\t}\n\n\tif d.PtrStruct.Str != \"hello test\" {\n\t\tt.Errorf(\"expected %q, got %q\", \"hello test\", d.PtrStruct.Str)\n\t}\n\tif d.PtrStruct.Int != 42 {\n\t\tt.Errorf(\"expected %d, got %d\", 42, d.PtrStruct.Int)\n\t}\n\n\texpectedTimestamp := testTimeValue\n\tif d.Timestamp != CustomTime(expectedTimestamp) {\n\t\tt.Errorf(\"expected %q, got %q\", expectedTimestamp.String(), d.Timestamp.String())\n\t}\n\n\tif d.PtrTimestamp == nil {\n\t\tt.Fatal(\"expected a pointer to a CustomTime, got nil\")\n\t}\n\tif *d.PtrTimestamp != CustomTime(expectedTimestamp) {\n\t\tt.Errorf(\"expected %q, got %q\", expectedTimestamp.String(), d.PtrTimestamp.String())\n\t}\n}\n\nfunc TestNestedOverrideCustom(t *testing.T) {\n\tgofakeit.AddFuncLookup(\"raw_test_date\", gofakeit.Info{\n\t\tDisplay:     \"Date\",\n\t\tCategory:    \"time\",\n\t\tDescription: \"Random date\",\n\t\tExample:     \"2006-01-02T15:04:05Z07:00\",\n\t\tOutput:      \"time.Time\",\n\t\tParams: []gofakeit.Param{\n\t\t\t{\n\t\t\t\tField:       \"format\",\n\t\t\t\tDisplay:     \"Format\",\n\t\t\t\tType:        \"time.Time\",\n\t\t\t\tDescription: \"Raw date time.Time object\",\n\t\t\t},\n\t\t},\n\t\tGenerate: func(f *gofakeit.Faker, m *gofakeit.MapParams, info *gofakeit.Info) (any, error) {\n\t\t\treturn gofakeit.Date(), nil\n\t\t},\n\t})\n\n\tdefer gofakeit.RemoveFuncLookup(\"raw_test_date\")\n\n\tvar d NestedOverrideCustom\n\terr := gofakeit.Struct(&d)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tnonOverrideStr := \"hello test\"\n\tif d.Str == CustomString(nonOverrideStr) {\n\t\tt.Errorf(\"Str: expected a random string but got the non-overriden value\")\n\t}\n\n\tif *d.PtrStr == CustomString(nonOverrideStr) {\n\t\tt.Errorf(\"PtrStr: expected a random string but got the non-overriden value\")\n\t}\n\n\tif d.Bool {\n\t\tt.Errorf(\"Bool: expected false, got true\")\n\t}\n\n\tnonOverrideInt := -42\n\tif d.Int == CustomInt(nonOverrideInt) {\n\t\tt.Errorf(\"Int: expected a random integer but got the non-overriden value\")\n\t}\n\tif d.Int8 == CustomInt8(nonOverrideInt) {\n\t\tt.Errorf(\"Int: expected a random integer but got the non-overriden value\")\n\t}\n\tif d.Int16 == CustomInt16(nonOverrideInt) {\n\t\tt.Errorf(\"Int: expected a random integer but got the non-overriden value\")\n\t}\n\tif d.Int32 == CustomInt32(nonOverrideInt) {\n\t\tt.Errorf(\"Int: expected a random integer but got the non-overriden value\")\n\t}\n\tif d.Int64 == CustomInt64(nonOverrideInt) {\n\t\tt.Errorf(\"Int: expected a random integer but got the non-overriden value\")\n\t}\n\n\tnonOverrideUint := uint(42)\n\tif d.Uint == CustomUint(nonOverrideUint) {\n\t\tt.Errorf(\"Uint: expected a random unsigned integer but got the non-overriden value\")\n\t}\n\tif d.Uint8 == CustomUint8(nonOverrideUint) {\n\t\tt.Errorf(\"Uint: expected a random unsigned integer but got the non-overriden value\")\n\t}\n\tif d.Uint16 == CustomUint16(nonOverrideUint) {\n\t\tt.Errorf(\"Uint: expected a random unsigned integer but got the non-overriden value\")\n\t}\n\tif d.Uint32 == CustomUint32(nonOverrideUint) {\n\t\tt.Errorf(\"Uint: expected a random unsigned integer but got the non-overriden value\")\n\t}\n\tif d.Uint64 == CustomUint64(nonOverrideUint) {\n\t\tt.Errorf(\"Uint: expected a random unsigned integer but got the non-overriden value\")\n\t}\n\n\tnonOverrideFloat := 42.123\n\tif d.Float32 == CustomFloat32(nonOverrideFloat) {\n\t\tt.Errorf(\"Float: expected a random unsigned integer but got the non-overriden value\")\n\t}\n\tif d.Float64 == CustomFloat64(nonOverrideFloat) {\n\t\tt.Errorf(\"Uint: expected a random unsigned integer but got the non-overriden value\")\n\t}\n\n\tnonOverrideSlice := []string{\"hello\", \"test\"}\n\tif len(d.SliceStr) == len(nonOverrideSlice) {\n\t\tt.Logf(\"Slice: Got the same length as the non-overriden slice: %v vs %v\", nonOverrideSlice, d.SliceStr)\n\t\tfor i, v := range nonOverrideSlice {\n\t\t\tif d.SliceStr[i] == v {\n\t\t\t\tt.Errorf(\"Slice: Got non-overriden item %d in the slice\", i)\n\t\t\t}\n\t\t}\n\t}\n\n\tnonOverrideArray := [2]int{1, 2}\n\tfor i, v := range nonOverrideArray {\n\t\tif d.Array[i] == v {\n\t\t\tt.Errorf(\"Array: Got non-overriden item %d in the array\", i)\n\t\t}\n\t}\n\n\tnonOverrideMap := map[string]string{\"hello\": \"1\", \"test\": \"2\"}\n\tif len(d.MapStr) == len(nonOverrideMap) {\n\t\tt.Logf(\"Map: Got the same length as the non-overriden map: %v vs %v\", nonOverrideMap, d.MapStr)\n\n\t\tfor k, v := range nonOverrideMap {\n\t\t\tif d.MapStr[k] == v {\n\t\t\t\tt.Errorf(\"Map: Got non-overriden item %v in the slice\", k)\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc TestSliceCustom(t *testing.T) {\n\tvar B []CustomString\n\tgofakeit.Slice(&B)\n\n\tif len(B) == 0 {\n\t\tt.Errorf(\"expected slice to not be empty\")\n\t}\n\n\texpected := CustomString(\"hello test\")\n\tfor _, v := range B {\n\t\tif v != expected {\n\t\t\tt.Errorf(\"expected all items to be %q, got %q\", expected, v)\n\t\t}\n\t}\n}\n\nfunc TestSliceNestedCustom(t *testing.T) {\n\tvar B []NestedCustom\n\tgofakeit.Slice(&B)\n\n\tif len(B) == 0 {\n\t\tt.Errorf(\"expected slice to not be empty\")\n\t}\n\n\texpected := CustomString(\"hello test\")\n\tfor _, v := range B {\n\t\tif v.Str != expected {\n\t\t\tt.Fatalf(\"expected all items to be %q, got %q\", expected, v.Str)\n\t\t}\n\t}\n}\n\nfunc ExampleCustomInt() {\n\tf1 := gofakeit.New(10)\n\tf2 := gofakeit.New(100)\n\n\tvar A1 CustomInt\n\tvar A2 CustomInt\n\t// CustomInt always returns -42 independently of the seed\n\tf1.Struct(&A1)\n\tf2.Struct(&A2)\n\n\tfmt.Println(A1)\n\tfmt.Println(A2)\n\n\t// Output:\n\t// -42\n\t// -42\n}\n\ntype EvenInt int\n\nfunc (e EvenInt) Fake(faker *gofakeit.Faker) (any, error) {\n\treturn EvenInt(faker.Int8() * 2), nil\n}\n\nfunc ExampleEvenInt() {\n\tf1 := gofakeit.New(10)\n\tf2 := gofakeit.New(100)\n\n\tvar E1 EvenInt\n\tvar E2 EvenInt\n\t// EventInt always returns an even number\n\tf1.Struct(&E1)\n\tf2.Struct(&E2)\n\n\tfmt.Println(E1)\n\tfmt.Println(E2)\n\n\t// Output: -2\n\t// 122\n}\n"
        },
        {
          "name": "fakeable_test.go",
          "type": "blob",
          "size": 3.166015625,
          "content": "package gofakeit\n\nimport (\n\t\"fmt\"\n\t\"math\"\n\t\"reflect\"\n\t\"testing\"\n)\n\ntype strTyp string\n\nfunc (t strTyp) Fake(faker *Faker) (any, error) {\n\treturn faker.FirstName(), nil\n}\n\ntype strTypPtr string\n\nfunc (t *strTypPtr) Fake(faker *Faker) (any, error) {\n\treturn strTypPtr(\"hello test ptr\"), nil\n}\n\ntype testStruct1 struct {\n\tB string `fake:\"{firstname}\"`\n}\n\ntype testStruct2 struct {\n\tB strTyp\n}\n\nfunc TestIsFakeable(t *testing.T) {\n\tvar t1 testStruct2\n\tvar t2 *testStruct2\n\tvar t3 strTyp\n\tvar t4 *strTyp\n\tvar t5 strTypPtr\n\tvar t6 *strTypPtr\n\n\tif isFakeable(reflect.ValueOf(t1).Type()) {\n\t\tt.Errorf(\"expected testStruct2 not to be fakeable\")\n\t}\n\n\tif isFakeable(reflect.ValueOf(t2).Type()) {\n\t\tt.Errorf(\"expected *testStruct2 not to be fakeable\")\n\t}\n\n\tif !isFakeable(reflect.ValueOf(t3).Type()) {\n\t\tt.Errorf(\"expected strTyp to be fakeable\")\n\t}\n\n\tif !isFakeable(reflect.ValueOf(t4).Type()) {\n\t\tt.Errorf(\"expected *strTyp to be fakeable\")\n\t}\n\n\tif !isFakeable(reflect.ValueOf(t5).Type()) {\n\t\tt.Errorf(\"expected strTypPtr to be fakeable\")\n\t}\n\n\tif !isFakeable(reflect.ValueOf(t6).Type()) {\n\t\tt.Errorf(\"expected *strTypPtr to be fakeable\")\n\t}\n}\n\nfunc ExampleFakeable() {\n\tvar t1 testStruct1\n\tvar t2 testStruct1\n\tvar t3 testStruct2\n\tvar t4 testStruct2\n\tNew(314).Struct(&t1)\n\tNew(314).Struct(&t2)\n\tNew(314).Struct(&t3)\n\tNew(314).Struct(&t4)\n\n\tfmt.Printf(\"%#v\\n\", t1)\n\tfmt.Printf(\"%#v\\n\", t2)\n\tfmt.Printf(\"%#v\\n\", t3)\n\tfmt.Printf(\"%#v\\n\", t4)\n\n\t// Output: gofakeit.testStruct1{B:\"Colton\"}\n\t// gofakeit.testStruct1{B:\"Colton\"}\n\t// gofakeit.testStruct2{B:\"Colton\"}\n\t// gofakeit.testStruct2{B:\"Colton\"}\n}\n\ntype gammaFloat64 float64\n\nfunc (gammaFloat64) Fake(f *Faker) (any, error) {\n\talpha := 2.0\n\n\t// Generate a random value from the Gamma distribution\n\tvar r float64\n\tfor r == 0 {\n\t\tu := f.Float64Range(0, 1)\n\t\tv := f.Float64Range(0, 1)\n\t\tw := u * (1 - u)\n\t\ty := math.Sqrt(-2 * math.Log(w) / w)\n\t\tx := alpha * (y*v + u - 0.5)\n\t\tif x > 0 {\n\t\t\tr = x\n\t\t}\n\t}\n\treturn gammaFloat64(r), nil\n}\n\nfunc ExampleFakeable_gammaFloat64() {\n\tf1 := New(100)\n\n\t// Fakes random values from the Gamma distribution\n\tvar A1 gammaFloat64\n\tvar A2 gammaFloat64\n\tvar A3 gammaFloat64\n\tf1.Struct(&A1)\n\tf1.Struct(&A2)\n\tf1.Struct(&A3)\n\n\tfmt.Println(A1)\n\tfmt.Println(A2)\n\tfmt.Println(A3)\n\n\t// Output: 1.9058272589164647\n\t// 1.951453943304136\n\t// 4.336093466276675\n}\n\ntype poissonInt64 int64\n\nfunc (poissonInt64) Fake(faker *Faker) (any, error) {\n\tlambda := 15.0\n\n\t// Generate a random value from the Poisson distribution\n\tvar k int64\n\tvar p float64 = 1.0\n\tvar L float64 = math.Exp(-lambda)\n\tfor p > L {\n\t\tu := faker.Float64Range(0, 1)\n\t\tp *= u\n\t\tk++\n\t}\n\treturn poissonInt64(k - 1), nil\n}\n\ntype employee struct {\n\tName             string `fake:\"{firstname} {lastname}\"`\n\tCallCountPerHour poissonInt64\n}\n\nfunc ExampleFakeable_employee() {\n\tf1 := New(100)\n\n\t// Fakes random values from the Gamma distribution\n\tvar A1 employee\n\tvar A2 employee\n\tvar A3 employee\n\tf1.Struct(&A1)\n\tf1.Struct(&A2)\n\tf1.Struct(&A3)\n\n\tfmt.Printf(\"%#v\\n\", A1)\n\tfmt.Printf(\"%#v\\n\", A2)\n\tfmt.Printf(\"%#v\\n\", A3)\n\n\t// Output: gofakeit.employee{Name:\"Madelynn Hickle\", CallCountPerHour:17}\n\t// gofakeit.employee{Name:\"Brooke Berge\", CallCountPerHour:8}\n\t// gofakeit.employee{Name:\"Rosalee Roberts\", CallCountPerHour:10}\n}\n"
        },
        {
          "name": "faker.go",
          "type": "blob",
          "size": 2.814453125,
          "content": "package gofakeit\n\nimport (\n\t\"errors\"\n\t\"math/rand/v2\"\n\t\"reflect\"\n\t\"sync\"\n\n\t\"github.com/brianvoe/gofakeit/v7/source\"\n)\n\n// Create global variable to deal with global function call\nvar GlobalFaker *Faker = New(0)\n\n// Faker struct is the primary struct for using localized\ntype Faker struct {\n\tRand rand.Source\n\n\t// Lock to make thread safe\n\tLocked bool\n\tmu     sync.Mutex\n}\n\n// New creates and returns a new Faker struct seeded with a given seed\n// using the PCG algorithm in lock mode for thread safety\nfunc New(seed uint64) *Faker {\n\t// If seed is 0, use a random crypto seed\n\tif seed == 0 {\n\t\tfaker := NewFaker(source.NewCrypto(), false)\n\t\tseed = faker.Uint64()\n\t}\n\n\treturn &Faker{\n\t\tRand:   rand.NewPCG(seed, seed),\n\t\tLocked: true,\n\t}\n}\n\n// NewFaker takes in a rand.Source and thread lock state and returns a new Faker struct\nfunc NewFaker(src rand.Source, lock bool) *Faker {\n\treturn &Faker{\n\t\tRand:   src,\n\t\tLocked: lock,\n\t}\n}\n\n// Seed attempts to seed the Faker with the given seed\nfunc (f *Faker) Seed(args ...any) error {\n\t// Lock if locked\n\tif f.Locked {\n\t\tf.mu.Lock()\n\t\tdefer f.mu.Unlock()\n\t}\n\n\t// Ensure GlobalFaker is not nil and Rand is initialized\n\tif GlobalFaker == nil || GlobalFaker.Rand == nil {\n\t\treturn errors.New(\"GlobalFaker or GlobalFaker.Rand is nil\")\n\t}\n\n\t// If args is empty or 0, seed with a random crypto seed\n\tif len(args) == 0 {\n\t\tfaker := NewFaker(source.NewCrypto(), false)\n\t\targs = append(args, faker.Uint64())\n\t}\n\n\tif args[0] == 0 {\n\t\tfaker := NewFaker(source.NewCrypto(), false)\n\t\targs[0] = faker.Uint64()\n\t}\n\n\t// Retrieve the Seed method\n\tmethod := reflect.ValueOf(GlobalFaker.Rand).MethodByName(\"Seed\")\n\tif !method.IsValid() {\n\t\treturn errors.New(\"Seed method not found\")\n\t}\n\n\t// Adjust args if method requires exactly 2 args but only 1 was provided\n\tif method.Type().NumIn() == 2 && len(args) == 1 {\n\t\targs = append(args, args[0]) // Duplicate the first value if only one is provided\n\t}\n\n\t// Get array of function argument types and prepare converted arguments\n\targTypes := make([]reflect.Type, method.Type().NumIn())\n\tconvertedArgs := make([]reflect.Value, len(args))\n\tfor i := 0; i < method.Type().NumIn(); i++ {\n\t\targTypes[i] = method.Type().In(i)\n\t}\n\n\t// Convert args to the expected type by the Seed method\n\tfor i, arg := range args {\n\t\tif i < len(argTypes) { // Ensure arg index is within argTypes bounds\n\t\t\targValue := reflect.ValueOf(arg)\n\t\t\t// Check if conversion is necessary\n\t\t\tif argValue.Type().ConvertibleTo(argTypes[i]) {\n\t\t\t\tconvertedArgs[i] = argValue.Convert(argTypes[i])\n\t\t\t} else {\n\t\t\t\t// If not convertible, use the argument as is (reflectively)\n\t\t\t\tconvertedArgs[i] = argValue\n\t\t\t}\n\t\t}\n\t}\n\n\t// Dynamically call the Seed method with converted arguments\n\tmethod.Call(convertedArgs)\n\n\treturn nil\n}\n\n// Seed attempts to seed the GlobalFaker with the given seed\nfunc Seed(args ...any) error {\n\treturn GlobalFaker.Seed(args...)\n}\n"
        },
        {
          "name": "faker_test.go",
          "type": "blob",
          "size": 2.5556640625,
          "content": "package gofakeit\n\nimport (\n\t\"fmt\"\n\t\"math/rand/v2\"\n\t\"sync\"\n\t\"testing\"\n)\n\nfunc Example() {\n\tSeed(11)\n\n\tfmt.Println(\"Name:\", Name())\n\tfmt.Println(\"Email:\", Email())\n\tfmt.Println(\"Phone:\", Phone())\n\tfmt.Println(\"Address:\", Address().Address)\n\tfmt.Println(\"BS:\", BS())\n\tfmt.Println(\"Beer Name:\", BeerName())\n\tfmt.Println(\"Color:\", Color())\n\tfmt.Println(\"Company:\", Company())\n\tfmt.Println(\"Credit Card:\", CreditCardNumber(nil))\n\tfmt.Println(\"Hacker Phrase:\", HackerPhrase())\n\tfmt.Println(\"Job Title:\", JobTitle())\n\tfmt.Println(\"Password:\", Password(true, true, true, true, false, 32))\n\n\t// Output: Name: Sonny Stiedemann\n\t// Email: codydonnelly@leannon.biz\n\t// Phone: 7598907999\n\t// Address: 4737 Port Hillstown, Santa Ana, Alabama 41026\n\t// BS: enable\n\t// Beer Name: Chocolate St\n\t// Color: Turquoise\n\t// Company: Boundless\n\t// Credit Card: 6282690620525711\n\t// Hacker Phrase: Try to bundle the PNG firewall, maybe it will deconstruct the open-source bandwidth!\n\t// Job Title: Assistant\n\t// Password: Nyf8p8ka1Kvgn...3H*.w7j01yM1vkc2\n}\n\nfunc ExampleNew() {\n\t// Get new faker with default settings\n\tfake := New(11)\n\n\t// All global functions are also available in the structs methods\n\tfmt.Println(\"Name:\", fake.Name())\n\tfmt.Println(\"Email:\", fake.Email())\n\tfmt.Println(\"Phone:\", fake.Phone())\n\n\t// Output:\n\t// Name: Sonny Stiedemann\n\t// Email: codydonnelly@leannon.biz\n\t// Phone: 7598907999\n}\n\nfunc ExampleNewFaker() {\n\t// Create new faker with ChaCha8, cryptographically secure\n\tchacha := rand.NewChaCha8([32]byte{5, 4, 3, 2, 1, 0})\n\tfake := NewFaker(chacha, true)\n\n\t// or\n\n\t// Create new faker with PCG, pseudo-random\n\tpcg := rand.NewPCG(0, 0)\n\tfake = NewFaker(pcg, false)\n\n\tfmt.Println(\"Name:\", fake.Name())\n\n\t// Output:\n\t// Name: Damian Pagac\n}\n\nfunc TestSeed(t *testing.T) {\n\t// Test crypto that has no parameters in Seed\n\tGlobalFaker = New(11)\n\n\t// Test a simple function\n\tname := Name()\n\n\t// Seed\n\terr := Seed(11)\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n\n\t// Make sure name is the same\n\tif name != Name() {\n\t\tt.Error(\"Name was different after seed\")\n\t}\n}\n\nfunc TestSetGlobalFaker(t *testing.T) {\n\t// Set global to crypto\n\tcrypto := rand.NewPCG(11, 11)\n\tGlobalFaker = NewFaker(crypto, true)\n\n\t// Test a simple function\n\tname := Name()\n\tif name == \"\" {\n\t\tt.Error(\"Name was empty\")\n\t}\n\n\t// Set global back to default\n\tGlobalFaker = New(0)\n}\n\nfunc TestConcurrency(t *testing.T) {\n\tvar setupComplete sync.WaitGroup\n\tsetupComplete.Add(1)\n\n\tvar wg sync.WaitGroup\n\tfor i := 0; i < 1000; i++ {\n\t\twg.Add(1)\n\t\tgo func() {\n\t\t\tsetupComplete.Wait()\n\t\t\tParagraph(1, 5, 20, \" \")\n\t\t\twg.Done()\n\t\t}()\n\t}\n\n\tsetupComplete.Done()\n\twg.Wait()\n}\n"
        },
        {
          "name": "file.go",
          "type": "blob",
          "size": 1.3837890625,
          "content": "package gofakeit\n\n// FileExtension will generate a random file extension\nfunc FileExtension() string { return fileExtension(GlobalFaker) }\n\n// FileExtension will generate a random file extension\nfunc (f *Faker) FileExtension() string { return fileExtension(f) }\n\nfunc fileExtension(f *Faker) string { return getRandValue(f, []string{\"file\", \"extension\"}) }\n\n// FileMimeType will generate a random mime file type\nfunc FileMimeType() string { return fileMimeType(GlobalFaker) }\n\n// FileMimeType will generate a random mime file type\nfunc (f *Faker) FileMimeType() string { return fileMimeType(f) }\n\nfunc fileMimeType(f *Faker) string { return getRandValue(f, []string{\"file\", \"mime_type\"}) }\n\nfunc addFileLookup() {\n\tAddFuncLookup(\"fileextension\", Info{\n\t\tDisplay:     \"File Extension\",\n\t\tCategory:    \"file\",\n\t\tDescription: \"Suffix appended to a filename indicating its format or type\",\n\t\tExample:     \"nes\",\n\t\tOutput:      \"string\",\n\t\tGenerate: func(f *Faker, m *MapParams, info *Info) (any, error) {\n\t\t\treturn fileExtension(f), nil\n\t\t},\n\t})\n\n\tAddFuncLookup(\"filemimetype\", Info{\n\t\tDisplay:     \"File Mime Type\",\n\t\tCategory:    \"file\",\n\t\tDescription: \"Defines file format and nature for browsers and email clients using standardized identifiers\",\n\t\tExample:     \"application/json\",\n\t\tOutput:      \"string\",\n\t\tGenerate: func(f *Faker, m *MapParams, info *Info) (any, error) {\n\t\t\treturn fileMimeType(f), nil\n\t\t},\n\t})\n}\n"
        },
        {
          "name": "file_test.go",
          "type": "blob",
          "size": 0.6298828125,
          "content": "package gofakeit\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc ExampleFileMimeType() {\n\tSeed(11)\n\tfmt.Println(FileMimeType())\n\n\t// Output: application/x-wri\n}\n\nfunc ExampleFaker_FileMimeType() {\n\tf := New(11)\n\tfmt.Println(f.FileMimeType())\n\n\t// Output: application/x-wri\n}\n\nfunc BenchmarkFileMimeType(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tFileMimeType()\n\t}\n}\n\nfunc ExampleFileExtension() {\n\tSeed(11)\n\tfmt.Println(FileExtension())\n\n\t// Output: dtd\n}\n\nfunc ExampleFaker_FileExtension() {\n\tf := New(11)\n\tfmt.Println(f.FileExtension())\n\n\t// Output: dtd\n}\n\nfunc BenchmarkFileExtension(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tFileExtension()\n\t}\n}\n"
        },
        {
          "name": "finance.go",
          "type": "blob",
          "size": 2.6982421875,
          "content": "package gofakeit\n\nimport (\n\t\"strconv\"\n\t\"unicode\"\n)\n\nconst cusipStr = upperStr + numericStr\n\n// CUSIP\nfunc Cusip() string {\n\treturn cusip(GlobalFaker)\n}\n\nfunc (f *Faker) Cusip() string {\n\treturn cusip(f)\n}\n\nfunc cusip(f *Faker) string {\n\tcusipBytes := make([]byte, 8)\n\tfor i := 0; i < len(cusipBytes); i++ {\n\t\tcusipBytes[i] = byte(cusipStr[f.IntN(len(cusipStr))])\n\t}\n\n\tbaseCusip := string(cusipBytes)\n\n\tchkDigit := cusipChecksumDigit(baseCusip)\n\treturn baseCusip + chkDigit\n}\n\n// ISIN\nfunc Isin() string {\n\treturn isin(GlobalFaker)\n}\n\nfunc (f *Faker) Isin() string {\n\treturn isin(f)\n}\n\nfunc isin(f *Faker) string {\n\tcountryCode := countryAbr(f)\n\tnsin := cusip(f)\n\tisinChkDig := isinChecksumDigit(countryCode + nsin)\n\treturn countryCode + nsin + isinChkDig\n}\n\n// cusipChecksumDigit returns the checksum digit for a CUSIP\nfunc cusipChecksumDigit(cusip string) string {\n\tsum := 0\n\tfor i, c := range cusip {\n\t\tv := 0\n\t\tif unicode.IsDigit(c) {\n\t\t\tv = int(c - '0')\n\t\t}\n\t\tif unicode.IsLetter(c) {\n\t\t\t//0-indexed ordinal position of Letter + 10\n\t\t\tv = int(c-'A') + 10\n\t\t}\n\t\tif i%2 != 0 {\n\t\t\t// Multiply odd digits by two\n\t\t\tv = v * 2\n\t\t}\n\n\t\tsum = sum + int(v/10) + v%10\n\t}\n\n\treturn strconv.Itoa((10 - (sum % 10)) % 10)\n}\n\n// isinChecksumDigit returns the checksum digit for an ISIN\nfunc isinChecksumDigit(isin string) string {\n\tisinDigits := make([]int, 0)\n\tfor _, c := range isin {\n\t\tif unicode.IsLetter(c) {\n\t\t\tletterVal := int(c) - 55\n\t\t\t// Each digit is added as a separate value\n\t\t\tisinDigits = append(isinDigits, letterVal/10)\n\t\t\tisinDigits = append(isinDigits, letterVal%10)\n\t\t}\n\t\tif unicode.IsDigit(c) {\n\t\t\tisinDigits = append(isinDigits, int(c-'0'))\n\t\t}\n\t}\n\n\toddSum := 0\n\tevenSum := 0\n\n\t// Take the per digit sum of the digitized ISIN, doubling even indexed digits\n\tfor i, d := range isinDigits {\n\t\tif i%2 == 0 {\n\t\t\telem := 2 * d\n\t\t\tif elem > 9 {\n\t\t\t\t// If the element now has two digits, sum those digits\n\t\t\t\telem = (elem % 10) + (elem / 10)\n\t\t\t}\n\t\t\tevenSum += elem\n\t\t} else {\n\t\t\toddSum += d\n\t\t}\n\t}\n\n\treturn strconv.Itoa((10 - (oddSum+evenSum)%10) % 10)\n}\n\n// Lookup Adds\nfunc addFinanceLookup() {\n\tAddFuncLookup(\"cusip\", Info{\n\t\tDisplay:     \"CUSIP\",\n\t\tCategory:    \"finance\",\n\t\tDescription: \"Unique identifier for securities, especially bonds, in the United States and Canada\",\n\t\tExample:     \"38259P508\",\n\t\tOutput:      \"string\",\n\t\tGenerate: func(f *Faker, m *MapParams, info *Info) (any, error) {\n\t\t\treturn cusip(f), nil\n\t\t},\n\t})\n\tAddFuncLookup(\"isin\", Info{\n\t\tDisplay:     \"ISIN\",\n\t\tCategory:    \"finance\",\n\t\tDescription: \"International standard code for uniquely identifying securities worldwide\",\n\t\tExample:     \"CVLRQCZBXQ97\",\n\t\tOutput:      \"string\",\n\t\tGenerate: func(f *Faker, m *MapParams, info *Info) (any, error) {\n\t\t\treturn isin(f), nil\n\t\t},\n\t})\n}\n"
        },
        {
          "name": "finance_test.go",
          "type": "blob",
          "size": 1.9169921875,
          "content": "package gofakeit\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\n// CUSIP Tests\nfunc ExampleCusip() {\n\tSeed(11)\n\tfmt.Println(Cusip())\n\n\t// Output: 64HHTI0T8\n}\n\nfunc ExampleFaker_Cusip() {\n\tf := New(11)\n\tfmt.Println(f.Cusip())\n\n\t// Output: 64HHTI0T8\n}\n\nfunc TestCusip(t *testing.T) {\n\tSeed(11)\n\tcusip := Cusip()\n\tif cusip == \"\" {\n\t\tt.Error(\"Valid Cusips are not blank\")\n\t}\n\tif len(cusip) != 9 {\n\t\tt.Error(\"Valid Cusips are 9 characters in length\")\n\t}\n\tif cusipChecksumDigit(cusip[:8]) != string(cusip[8]) {\n\t\tt.Error(\"Generated Cusip has invalid checksum\")\n\t}\n}\n\nfunc TestCusipCheckDigit(t *testing.T) {\n\ttype test struct {\n\t\tbase string\n\t\twant string\n\t}\n\n\ttests := []test{\n\t\t{base: \"03783310\", want: \"0\"},\n\t\t{base: \"17275R10\", want: \"2\"},\n\t\t{base: \"38259P50\", want: \"8\"},\n\t}\n\tfor _, tc := range tests {\n\t\tdigit := cusipChecksumDigit(tc.base)\n\t\tif digit != tc.want {\n\t\t\tt.Errorf(\"Expected check digit of %s, got %s\", tc.want, digit)\n\t\t}\n\t}\n}\n\nfunc BenchmarkCusip(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tCusip()\n\t}\n}\n\n// ISIN Tests\nfunc ExampleIsin() {\n\tSeed(11)\n\tfmt.Println(Isin())\n\n\t// Output: TO4HHTI0T819\n}\n\nfunc ExampleFaker_Isin() {\n\tf := New(11)\n\tfmt.Println(f.Isin())\n\n\t// Output: TO4HHTI0T819\n}\n\nfunc TestIsin(t *testing.T) {\n\tSeed(11)\n\tisin := Isin()\n\tif isin == \"\" {\n\t\tt.Error(\"Valid ISINs are not blank\")\n\t}\n\tif len(isin) != 12 {\n\t\tt.Error(\"Valid ISINs are 12 characters in length\")\n\t}\n\tif isinChecksumDigit(isin[:11]) != string(isin[11]) {\n\t\tt.Error(\"Generated ISIN has invalid check digit\")\n\t}\n}\n\nfunc TestIsinCheckDigit(t *testing.T) {\n\ttype test struct {\n\t\tbase string\n\t\twant string\n\t}\n\n\ttests := []test{\n\t\t{base: \"US037833100\", want: \"5\"},\n\t\t{base: \"GB000263494\", want: \"6\"},\n\t\t{base: \"US000402625\", want: \"0\"},\n\t}\n\tfor _, tc := range tests {\n\t\tdigit := isinChecksumDigit(tc.base)\n\t\tif digit != tc.want {\n\t\t\tt.Errorf(\"Expected check digit of %s, got %s\", tc.want, digit)\n\t\t}\n\t}\n}\n\nfunc BenchmarkIsin(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tIsin()\n\t}\n}\n"
        },
        {
          "name": "food.go",
          "type": "blob",
          "size": 4.98828125,
          "content": "package gofakeit\n\nimport (\n\t\"strings\"\n)\n\n// Fruit will return a random fruit name\nfunc Fruit() string { return fruit(GlobalFaker) }\n\n// Fruit will return a random fruit name\nfunc (f *Faker) Fruit() string { return fruit(f) }\n\nfunc fruit(f *Faker) string { return getRandValue(f, []string{\"food\", \"fruit\"}) }\n\n// Vegetable will return a random vegetable name\nfunc Vegetable() string { return vegetable(GlobalFaker) }\n\n// Vegetable will return a random vegetable name\nfunc (f *Faker) Vegetable() string { return vegetable(f) }\n\nfunc vegetable(f *Faker) string { return getRandValue(f, []string{\"food\", \"vegetable\"}) }\n\n// Breakfast will return a random breakfast name\nfunc Breakfast() string { return breakfast(GlobalFaker) }\n\n// Breakfast will return a random breakfast name\nfunc (f *Faker) Breakfast() string { return breakfast(f) }\n\nfunc breakfast(f *Faker) string {\n\tv := getRandValue(f, []string{\"food\", \"breakfast\"})\n\treturn strings.ToUpper(v[:1]) + v[1:]\n}\n\n// Lunch will return a random lunch name\nfunc Lunch() string { return lunch(GlobalFaker) }\n\n// Lunch will return a random lunch name\nfunc (f *Faker) Lunch() string { return lunch(f) }\n\nfunc lunch(f *Faker) string {\n\tv := getRandValue(f, []string{\"food\", \"lunch\"})\n\treturn strings.ToUpper(v[:1]) + v[1:]\n}\n\n// Dinner will return a random dinner name\nfunc Dinner() string { return dinner(GlobalFaker) }\n\n// Dinner will return a random dinner name\nfunc (f *Faker) Dinner() string { return dinner(f) }\n\nfunc dinner(f *Faker) string {\n\tv := getRandValue(f, []string{\"food\", \"dinner\"})\n\treturn strings.ToUpper(v[:1]) + v[1:]\n}\n\n// Drink will return a random drink name\nfunc Drink() string { return drink(GlobalFaker) }\n\n// Drink will return a random drink name\nfunc (f *Faker) Drink() string { return drink(f) }\n\nfunc drink(f *Faker) string {\n\tv := getRandValue(f, []string{\"food\", \"drink\"})\n\treturn strings.ToUpper(v[:1]) + v[1:]\n}\n\n// Snack will return a random snack name\nfunc Snack() string { return snack(GlobalFaker) }\n\n// Snack will return a random snack name\nfunc (f *Faker) Snack() string { return snack(f) }\n\nfunc snack(f *Faker) string {\n\tv := getRandValue(f, []string{\"food\", \"snack\"})\n\treturn strings.ToUpper(v[:1]) + v[1:]\n}\n\n// Dessert will return a random dessert name\nfunc Dessert() string { return dessert(GlobalFaker) }\n\n// Dessert will return a random dessert name\nfunc (f *Faker) Dessert() string { return dessert(f) }\n\nfunc dessert(f *Faker) string {\n\tv := getRandValue(f, []string{\"food\", \"dessert\"})\n\treturn strings.ToUpper(v[:1]) + v[1:]\n}\n\nfunc addFoodLookup() {\n\tAddFuncLookup(\"fruit\", Info{\n\t\tDisplay:     \"Fruit\",\n\t\tCategory:    \"food\",\n\t\tDescription: \"Edible plant part, typically sweet, enjoyed as a natural snack or dessert\",\n\t\tExample:     \"Peach\",\n\t\tOutput:      \"string\",\n\t\tGenerate: func(f *Faker, m *MapParams, info *Info) (any, error) {\n\t\t\treturn fruit(f), nil\n\t\t},\n\t})\n\n\tAddFuncLookup(\"vegetable\", Info{\n\t\tDisplay:     \"Vegetable\",\n\t\tCategory:    \"food\",\n\t\tDescription: \"Edible plant or part of a plant, often used in savory cooking or salads\",\n\t\tExample:     \"Amaranth Leaves\",\n\t\tOutput:      \"string\",\n\t\tGenerate: func(f *Faker, m *MapParams, info *Info) (any, error) {\n\t\t\treturn vegetable(f), nil\n\t\t},\n\t})\n\n\tAddFuncLookup(\"breakfast\", Info{\n\t\tDisplay:     \"Breakfast\",\n\t\tCategory:    \"food\",\n\t\tDescription: \"First meal of the day, typically eaten in the morning\",\n\t\tExample:     \"Blueberry banana happy face pancakes\",\n\t\tOutput:      \"string\",\n\t\tGenerate: func(f *Faker, m *MapParams, info *Info) (any, error) {\n\t\t\treturn breakfast(f), nil\n\t\t},\n\t})\n\n\tAddFuncLookup(\"lunch\", Info{\n\t\tDisplay:     \"Lunch\",\n\t\tCategory:    \"food\",\n\t\tDescription: \"Midday meal, often lighter than dinner, eaten around noon\",\n\t\tExample:     \"No bake hersheys bar pie\",\n\t\tOutput:      \"string\",\n\t\tGenerate: func(f *Faker, m *MapParams, info *Info) (any, error) {\n\t\t\treturn lunch(f), nil\n\t\t},\n\t})\n\n\tAddFuncLookup(\"dinner\", Info{\n\t\tDisplay:     \"Dinner\",\n\t\tCategory:    \"food\",\n\t\tDescription: \"Evening meal, typically the day's main and most substantial meal\",\n\t\tExample:     \"Wild addicting dip\",\n\t\tOutput:      \"string\",\n\t\tGenerate: func(f *Faker, m *MapParams, info *Info) (any, error) {\n\t\t\treturn dinner(f), nil\n\t\t},\n\t})\n\n\tAddFuncLookup(\"drink\", Info{\n\t\tDisplay:     \"Drink\",\n\t\tCategory:    \"food\",\n\t\tDescription: \"Liquid consumed for hydration, pleasure, or nutritional benefits\",\n\t\tExample:     \"Soda\",\n\t\tOutput:      \"string\",\n\t\tGenerate: func(f *Faker, m *MapParams, info *Info) (any, error) {\n\t\t\treturn drink(f), nil\n\t\t},\n\t})\n\n\tAddFuncLookup(\"snack\", Info{\n\t\tDisplay:     \"Snack\",\n\t\tCategory:    \"food\",\n\t\tDescription: \"Random snack\",\n\t\tExample:     \"Small, quick food item eaten between meals\",\n\t\tOutput:      \"string\",\n\t\tGenerate: func(f *Faker, m *MapParams, info *Info) (any, error) {\n\t\t\treturn snack(f), nil\n\t\t},\n\t})\n\n\tAddFuncLookup(\"dessert\", Info{\n\t\tDisplay:     \"Dessert\",\n\t\tCategory:    \"food\",\n\t\tDescription: \"Sweet treat often enjoyed after a meal\",\n\t\tExample:     \"French napoleons\",\n\t\tOutput:      \"string\",\n\t\tGenerate: func(f *Faker, m *MapParams, info *Info) (any, error) {\n\t\t\treturn dessert(f), nil\n\t\t},\n\t})\n}\n"
        },
        {
          "name": "food_test.go",
          "type": "blob",
          "size": 2.2373046875,
          "content": "package gofakeit\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc ExampleFruit() {\n\tSeed(11)\n\tfmt.Println(Fruit())\n\n\t// Output: Redcurrant\n}\n\nfunc ExampleFaker_Fruit() {\n\tf := New(11)\n\tfmt.Println(f.Fruit())\n\n\t// Output: Redcurrant\n}\n\nfunc BenchmarkFruit(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tFruit()\n\t}\n}\n\nfunc ExampleVegetable() {\n\tSeed(11)\n\tfmt.Println(Vegetable())\n\n\t// Output: Sweet Potato\n}\n\nfunc ExampleFaker_Vegetable() {\n\tf := New(11)\n\tfmt.Println(f.Vegetable())\n\n\t// Output: Sweet Potato\n}\n\nfunc BenchmarkVegetable(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tVegetable()\n\t}\n}\n\nfunc ExampleBreakfast() {\n\tSeed(11)\n\tfmt.Println(Breakfast())\n\n\t// Output: Purple cow\n}\n\nfunc ExampleFaker_Breakfast() {\n\tf := New(11)\n\tfmt.Println(f.Breakfast())\n\n\t// Output: Purple cow\n}\n\nfunc BenchmarkBreakfast(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tBreakfast()\n\t}\n}\n\nfunc ExampleLunch() {\n\tSeed(11)\n\tfmt.Println(Lunch())\n\n\t// Output: Quick chile relleno casserole\n}\n\nfunc ExampleFaker_Lunch() {\n\tf := New(11)\n\tfmt.Println(f.Lunch())\n\n\t// Output: Quick chile relleno casserole\n}\n\nfunc BenchmarkLunch(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tLunch()\n\t}\n}\n\nfunc ExampleDinner() {\n\tSeed(11)\n\tfmt.Println(Dinner())\n\n\t// Output: German apple cake with cream cheese frosting\n}\n\nfunc ExampleFaker_Dinner() {\n\tf := New(11)\n\tfmt.Println(f.Dinner())\n\n\t// Output: German apple cake with cream cheese frosting\n}\n\nfunc BenchmarkDinner(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tDinner()\n\t}\n}\n\nfunc ExampleDrink() {\n\tSeed(11)\n\tfmt.Println(Drink())\n\n\t// Output: Wine\n}\n\nfunc ExampleFaker_Drink() {\n\tf := New(11)\n\tfmt.Println(f.Drink())\n\n\t// Output: Wine\n}\n\nfunc BenchmarkDrink(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tDrink()\n\t}\n}\n\nfunc ExampleSnack() {\n\tSeed(11)\n\tfmt.Println(Snack())\n\n\t// Output: Fantastic banana bran muffins\n}\n\nfunc ExampleFaker_Snack() {\n\tf := New(11)\n\tfmt.Println(f.Snack())\n\n\t// Output: Fantastic banana bran muffins\n}\n\nfunc BenchmarkSnack(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tSnack()\n\t}\n}\n\nfunc ExampleDessert() {\n\tSeed(11)\n\tfmt.Println(Dessert())\n\n\t// Output: Amish cream pie\n}\n\nfunc ExampleFaker_Dessert() {\n\tf := New(11)\n\tfmt.Println(f.Dessert())\n\n\t// Output: Amish cream pie\n}\n\nfunc BenchmarkDessert(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tDessert()\n\t}\n}\n"
        },
        {
          "name": "game.go",
          "type": "blob",
          "size": 2.6689453125,
          "content": "package gofakeit\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n)\n\n// Gamertag will generate a random video game username\nfunc Gamertag() string { return gamertag(GlobalFaker) }\n\n// Gamertag will generate a random video game username\nfunc (f *Faker) Gamertag() string { return gamertag(f) }\n\nfunc gamertag(f *Faker) string {\n\tstr := \"\"\n\tnum := number(f, 1, 4)\n\tswitch num {\n\tcase 1:\n\t\tstr = fmt.Sprintf(\"%s%ser\", title(nounConcrete(f)), title(verbAction(f)))\n\tcase 2:\n\t\tstr = fmt.Sprintf(\"%s%s\", title(adjectiveDescriptive(f)), title(animal(f)))\n\tcase 3:\n\t\tstr = fmt.Sprintf(\"%s%s\", title(adjectiveDescriptive(f)), title(nounConcrete(f)))\n\tcase 4:\n\t\tstr = fmt.Sprintf(\"%s%s\", title(fruit(f)), title(adjectiveDescriptive(f)))\n\t}\n\n\t// Randomly determine if we should add a number\n\tif f.IntN(3) == 1 {\n\t\tstr += digitN(f, uint(number(f, 1, 3)))\n\t}\n\n\t// Remove any spaces\n\tstr = strings.Replace(str, \" \", \"\", -1)\n\n\treturn str\n}\n\n// Dice will generate a random set of dice\nfunc Dice(numDice uint, sides []uint) []uint { return dice(GlobalFaker, numDice, sides) }\n\n// Dice will generate a random set of dice\nfunc (f *Faker) Dice(numDice uint, sides []uint) []uint { return dice(f, numDice, sides) }\n\nfunc dice(f *Faker, numDice uint, sides []uint) []uint {\n\tdice := make([]uint, numDice)\n\n\t// If we dont have any sides well set the sides to 6\n\tif len(sides) == 0 {\n\t\tsides = []uint{6}\n\t}\n\n\tfor i := range dice {\n\t\t// If sides[i] doesnt exist use the first side\n\t\tif len(sides)-1 < i {\n\t\t\tdice[i] = uint(number(f, 1, int(sides[0])))\n\t\t} else {\n\t\t\tdice[i] = uint(number(f, 1, int(sides[i])))\n\t\t}\n\t}\n\n\treturn dice\n}\n\nfunc addGameLookup() {\n\tAddFuncLookup(\"gamertag\", Info{\n\t\tDisplay:     \"Gamertag\",\n\t\tCategory:    \"game\",\n\t\tDescription: \"User-selected online username or alias used for identification in games\",\n\t\tExample:     \"footinterpret63\",\n\t\tOutput:      \"string\",\n\t\tGenerate: func(f *Faker, m *MapParams, info *Info) (any, error) {\n\t\t\treturn gamertag(f), nil\n\t\t},\n\t})\n\n\tAddFuncLookup(\"dice\", Info{\n\t\tDisplay:     \"Dice\",\n\t\tCategory:    \"game\",\n\t\tDescription: \"Small, cube-shaped objects used in games of chance for random outcomes\",\n\t\tExample:     \"[5, 2, 3]\",\n\t\tOutput:      \"[]uint\",\n\t\tParams: []Param{\n\t\t\t{Field: \"numdice\", Display: \"Number of Dice\", Type: \"uint\", Default: \"1\", Description: \"Number of dice to roll\"},\n\t\t\t{Field: \"sides\", Display: \"Number of Sides\", Type: \"[]uint\", Default: \"[6]\", Description: \"Number of sides on each dice\"},\n\t\t},\n\t\tGenerate: func(f *Faker, m *MapParams, info *Info) (any, error) {\n\t\t\tnumDice, err := info.GetUint(m, \"numdice\")\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\n\t\t\tsides, err := info.GetUintArray(m, \"sides\")\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\n\t\t\treturn dice(f, numDice, sides), nil\n\t\t},\n\t})\n}\n"
        },
        {
          "name": "game_test.go",
          "type": "blob",
          "size": 1.80078125,
          "content": "package gofakeit\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc ExampleGamertag() {\n\tSeed(11)\n\tfmt.Println(Gamertag())\n\n\t// Output: TurkeyThinker\n}\n\nfunc ExampleFaker_Gamertag() {\n\tf := New(11)\n\tfmt.Println(f.Gamertag())\n\n\t// Output: TurkeyThinker\n}\n\nfunc TestGamertag(t *testing.T) {\n\tfor i := 0; i < 100; i++ {\n\t\tg := Gamertag()\n\t\tif g == \"\" {\n\t\t\tt.Errorf(\"Gamertag() returned empty string\")\n\t\t}\n\t}\n}\n\nfunc BenchmarkGamertag(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tGamertag()\n\t}\n}\n\nfunc ExampleDice() {\n\tSeed(11)\n\tfmt.Println(Dice(1, []uint{6}))\n\n\t// Output: [6]\n}\n\nfunc ExampleFaker_Dice() {\n\tf := New(11)\n\tfmt.Println(f.Dice(1, []uint{6}))\n\n\t// Output: [6]\n}\n\nfunc TestDice(t *testing.T) {\n\tfor i := 0; i < 100; i++ {\n\t\t// put together random number of dice and sides\n\t\tnumDice := uint(Number(1, 10))\n\t\tsides := make([]uint, numDice)\n\t\tfor i := 0; i < int(numDice); i++ {\n\t\t\tsides[i] = uint(Number(1, 10))\n\t\t}\n\n\t\tg := Dice(numDice, sides)\n\t\tif len(g) == 0 {\n\t\t\tt.Errorf(\"Dice() returned empty uint array\")\n\t\t}\n\n\t\t// Make sure the length of the array is the same as the number of dice\n\t\tif len(g) != int(numDice) {\n\t\t\tt.Errorf(\"Dice() returned wrong length array\")\n\t\t}\n\t}\n}\n\nfunc TestDiceNoSides(t *testing.T) {\n\tfor i := 0; i < 100; i++ {\n\t\tg := Dice(1, []uint{})\n\t\tif len(g) != 1 {\n\t\t\tt.Errorf(\"Dice() returned non-empty array\")\n\t\t}\n\n\t\t// Make sure g[1] is betwwen 1 and 6\n\t\tif g[0] < 1 || g[0] > 6 {\n\t\t\tt.Errorf(\"Dice() returned wrong number\")\n\t\t}\n\t}\n}\n\nfunc TestDiceOneSide(t *testing.T) {\n\tfor i := 0; i < 100; i++ {\n\t\tg := Dice(10, []uint{1})\n\t\tif len(g) != 10 {\n\t\t\tt.Errorf(\"Dice() returned non 10 value array\")\n\t\t}\n\n\t\t// Make sure all g values are 1\n\t\tfor _, v := range g {\n\t\t\tif v != 1 {\n\t\t\t\tt.Errorf(\"Dice() returned wrong number\")\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc BenchmarkDice(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tDice(1, []uint{6})\n\t}\n}\n"
        },
        {
          "name": "generate.go",
          "type": "blob",
          "size": 15.8681640625,
          "content": "package gofakeit\n\nimport (\n\t\"encoding/json\"\n\t\"errors\"\n\t\"fmt\"\n\t\"math\"\n\t\"regexp/syntax\"\n\t\"strings\"\n)\n\n// Generate fake information from given string.\n// Replaceable values should be within {}\n//\n// Functions\n// Ex: {firstname} - billy\n// Ex: {sentence:3} - Record river mind.\n// Ex: {number:1,10} - 4\n// Ex: {uuid} - 590c1440-9888-45b0-bd51-a817ee07c3f2\n//\n// Letters/Numbers\n// Ex: ### - 481 - random numbers\n// Ex: ??? - fda - random letters\n//\n// For a complete list of runnable functions use FuncsLookup\nfunc Generate(dataVal string) (string, error) { return generate(GlobalFaker, dataVal) }\n\n// Generate fake information from given string.\n// Replaceable values should be within {}\n//\n// Functions\n// Ex: {firstname} - billy\n// Ex: {sentence:3} - Record river mind.\n// Ex: {number:1,10} - 4\n// Ex: {uuid} - 590c1440-9888-45b0-bd51-a817ee07c3f2\n//\n// Letters/Numbers\n// Ex: ### - 481 - random numbers\n// Ex: ??? - fda - random letters\n//\n// For a complete list of runnable functions use FuncsLookup\nfunc (f *Faker) Generate(dataVal string) (string, error) { return generate(f, dataVal) }\n\nfunc generate(f *Faker, dataVal string) (string, error) {\n\t// Replace # with numbers and ? with letters\n\tdataVal = replaceWithNumbers(f, dataVal)\n\tdataVal = replaceWithLetters(f, dataVal)\n\n\t// Check if string has any replaceable values\n\t// Even if it doesnt its ok we will just return the string\n\tif !strings.Contains(dataVal, \"{\") && !strings.Contains(dataVal, \"}\") {\n\t\treturn dataVal, nil\n\t}\n\n\t// Variables to identify the index in which it exists\n\tstartCurly := -1\n\tstartCurlyIgnore := []int{}\n\tendCurly := -1\n\tendCurlyIgnore := []int{}\n\n\t// Loop through string characters\n\tfor i := 0; i < len(dataVal); i++ {\n\t\t// Check for ignores if equal skip\n\t\tshouldSkip := false\n\t\tfor _, igs := range startCurlyIgnore {\n\t\t\tif i == igs {\n\t\t\t\tshouldSkip = true\n\t\t\t}\n\t\t}\n\t\tfor _, ige := range endCurlyIgnore {\n\t\t\tif i == ige {\n\t\t\t\tshouldSkip = true\n\t\t\t}\n\t\t}\n\t\tif shouldSkip {\n\t\t\tcontinue\n\t\t}\n\n\t\t// Identify items between brackets. Ex: {firstname}\n\t\tif string(dataVal[i]) == \"{\" {\n\t\t\tstartCurly = i\n\t\t\tcontinue\n\t\t}\n\t\tif startCurly != -1 && string(dataVal[i]) == \"}\" {\n\t\t\tendCurly = i\n\t\t}\n\t\tif startCurly == -1 || endCurly == -1 {\n\t\t\tcontinue\n\t\t}\n\n\t\t// Get the value between brackets\n\t\tfParts := dataVal[startCurly+1 : endCurly]\n\n\t\t// Check if has params separated by :\n\t\tfNameSplit := strings.SplitN(fParts, \":\", 2)\n\t\tfName := \"\"\n\t\tfParams := \"\"\n\t\tif len(fNameSplit) >= 1 {\n\t\t\tfName = fNameSplit[0]\n\t\t}\n\t\tif len(fNameSplit) >= 2 {\n\t\t\tfParams = fNameSplit[1]\n\t\t}\n\n\t\t// Check to see if its a replaceable lookup function\n\t\tif info := GetFuncLookup(fName); info != nil {\n\t\t\t// Get parameters, make sure params and the split both have values\n\t\t\tmapParams := NewMapParams()\n\t\t\tparamsLen := len(info.Params)\n\n\t\t\t// If just one param and its a string simply just pass it\n\t\t\tif paramsLen == 1 && info.Params[0].Type == \"string\" {\n\t\t\t\tmapParams.Add(info.Params[0].Field, fParams)\n\t\t\t} else if paramsLen > 0 && fParams != \"\" {\n\t\t\t\tvar err error\n\t\t\t\tsplitVals, err := funcLookupSplit(fParams)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn \"\", err\n\t\t\t\t}\n\t\t\t\tmapParams, err = addSplitValsToMapParams(splitVals, info, mapParams)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn \"\", err\n\t\t\t\t}\n\t\t\t}\n\t\t\tif mapParams.Size() == 0 {\n\t\t\t\tmapParams = nil\n\t\t\t}\n\n\t\t\t// Call function\n\t\t\tfValue, err := info.Generate(f, mapParams, info)\n\t\t\tif err != nil {\n\t\t\t\treturn \"\", err\n\t\t\t}\n\n\t\t\t// Successfully found, run replace with new value\n\t\t\tdataVal = strings.Replace(dataVal, \"{\"+fParts+\"}\", fmt.Sprintf(\"%v\", fValue), 1)\n\n\t\t\t// Reset the curly index back to -1 and reset ignores\n\t\t\tstartCurly = -1\n\t\t\tstartCurlyIgnore = []int{}\n\t\t\tendCurly = -1\n\t\t\tendCurlyIgnore = []int{}\n\t\t\ti = -1 // Reset back to the start of the string\n\t\t\tcontinue\n\t\t}\n\n\t\t// Couldnt find anything - mark curly brackets to skip and rerun\n\t\tstartCurlyIgnore = append(startCurlyIgnore, startCurly)\n\t\tendCurlyIgnore = append(endCurlyIgnore, endCurly)\n\n\t\t// Reset the curly index back to -1\n\t\tstartCurly = -1\n\t\tendCurly = -1\n\t\ti = -1 // Reset back to the start of the string\n\t\tcontinue\n\t}\n\n\treturn dataVal, nil\n}\n\n// FixedWidthOptions defines values needed for csv generation\ntype FixedWidthOptions struct {\n\tRowCount int     `json:\"row_count\" xml:\"row_count\" fake:\"{number:1,10}\"`\n\tFields   []Field `json:\"fields\" xml:\"fields\" fake:\"{fields}\"`\n}\n\n// FixedWidth generates an table of random data in fixed width format\n// A nil FixedWidthOptions returns a randomly structured FixedWidth.\nfunc FixedWidth(co *FixedWidthOptions) (string, error) { return fixeWidthFunc(GlobalFaker, co) }\n\n// FixedWidth generates an table of random data in fixed width format\n// A nil FixedWidthOptions returns a randomly structured FixedWidth.\nfunc (f *Faker) FixedWidth(co *FixedWidthOptions) (string, error) { return fixeWidthFunc(f, co) }\n\n// Function to generate a fixed width document\nfunc fixeWidthFunc(f *Faker, co *FixedWidthOptions) (string, error) {\n\t// If we didn't get FixedWidthOptions, create a new random one\n\tif co == nil {\n\t\tco = &FixedWidthOptions{}\n\t}\n\n\t// Make sure you set a row count\n\tif co.RowCount <= 0 {\n\t\tco.RowCount = f.IntN(10) + 1\n\t}\n\n\t// Check fields\n\tif len(co.Fields) <= 0 {\n\t\t// Create random fields\n\t\tco.Fields = []Field{\n\t\t\t{Name: \"Name\", Function: \"{firstname} {lastname}\"},\n\t\t\t{Name: \"Email\", Function: \"email\"},\n\t\t\t{Name: \"Password\", Function: \"password\", Params: MapParams{\"special\": {\"false\"}, \"space\": {\"false\"}}},\n\t\t}\n\t}\n\n\tdata := [][]string{}\n\thasHeader := false\n\n\t// Loop through fields, generate data and add to data array\n\tfor _, field := range co.Fields {\n\t\t// Start new row\n\t\trow := []string{}\n\n\t\t// Add name to first value\n\t\tif field.Name != \"\" {\n\t\t\thasHeader = true\n\t\t}\n\t\trow = append(row, field.Name)\n\n\t\t// Get function\n\t\tfuncInfo := GetFuncLookup(field.Function)\n\t\tvar value any\n\t\tif funcInfo == nil {\n\t\t\t// Try to run the function through generate\n\t\t\tfor i := 0; i < co.RowCount; i++ {\n\t\t\t\tgenStr, err := generate(f, field.Function)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn \"\", err\n\t\t\t\t}\n\n\t\t\t\trow = append(row, genStr)\n\t\t\t}\n\t\t} else {\n\t\t\t// Generate function value\n\t\t\tvar err error\n\t\t\tfor i := 0; i < co.RowCount; i++ {\n\t\t\t\tvalue, err = funcInfo.Generate(f, &field.Params, funcInfo)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn \"\", err\n\t\t\t\t}\n\n\t\t\t\t// Add value to row\n\t\t\t\trow = append(row, anyToString(value))\n\t\t\t}\n\t\t}\n\n\t\t// Add row to data\n\t\tdata = append(data, row)\n\t}\n\n\tvar result strings.Builder\n\n\t// Calculate column widths\n\tcolWidths := make([]int, len(data))\n\tfor i, row := range data {\n\t\tfor _, value := range row {\n\t\t\twidth := len(value) + 5\n\t\t\tif width > colWidths[i] {\n\t\t\t\tcolWidths[i] = width\n\t\t\t}\n\t\t}\n\t}\n\n\t// Append table rows to the string, excluding the entire row if the first value is empty\n\tfor i := 0; i < len(data[0]); i++ {\n\t\tif !hasHeader && i == 0 {\n\t\t\tcontinue // Skip the entire column if the first value is empty\n\t\t}\n\n\t\tvar resultRow strings.Builder\n\t\tfor j, row := range data {\n\t\t\tresultRow.WriteString(fmt.Sprintf(\"%-*s\", colWidths[j], row[i]))\n\t\t}\n\n\t\t// Trim trailing spaces\n\t\tresult.WriteString(strings.TrimRight(resultRow.String(), \" \"))\n\n\t\t// Only add new line if not the last row\n\t\tif i != len(data[0])-1 {\n\t\t\tresult.WriteString(\"\\n\")\n\t\t}\n\t}\n\n\treturn result.String(), nil\n}\n\n// Regex will generate a string based upon a RE2 syntax\nfunc Regex(regexStr string) string { return regex(GlobalFaker, regexStr) }\n\n// Regex will generate a string based upon a RE2 syntax\nfunc (f *Faker) Regex(regexStr string) string { return regex(f, regexStr) }\n\nfunc regex(f *Faker, regexStr string) (gen string) {\n\tre, err := syntax.Parse(regexStr, syntax.Perl)\n\tif err != nil {\n\t\treturn \"Could not parse regex string\"\n\t}\n\n\t// Panic catch\n\tdefer func() {\n\t\tif r := recover(); r != nil {\n\t\t\tgen = fmt.Sprint(f)\n\t\t\treturn\n\n\t\t}\n\t}()\n\n\treturn regexGenerate(f, re, len(regexStr)*100)\n}\n\nfunc regexGenerate(f *Faker, re *syntax.Regexp, limit int) string {\n\tif limit <= 0 {\n\t\tpanic(\"Length limit reached when generating output\")\n\t}\n\n\top := re.Op\n\tswitch op {\n\tcase syntax.OpNoMatch: // matches no strings\n\t\t// Do Nothing\n\tcase syntax.OpEmptyMatch: // matches empty string\n\t\treturn \"\"\n\tcase syntax.OpLiteral: // matches Runes sequence\n\t\tvar b strings.Builder\n\t\tfor _, ru := range re.Rune {\n\t\t\tb.WriteRune(ru)\n\t\t}\n\t\treturn b.String()\n\tcase syntax.OpCharClass: // matches Runes interpreted as range pair list\n\t\t// number of possible chars\n\t\tsum := 0\n\t\tfor i := 0; i < len(re.Rune); i += 2 {\n\t\t\tsum += int(re.Rune[i+1]-re.Rune[i]) + 1\n\t\t\tif re.Rune[i+1] == 0x10ffff { // rune range end\n\t\t\t\tsum = -1\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\n\t\t// pick random char in range (inverse match group)\n\t\tif sum == -1 {\n\t\t\tchars := []uint8{}\n\t\t\tfor j := 0; j < len(allStr); j++ {\n\t\t\t\tc := allStr[j]\n\n\t\t\t\t// Check c in range\n\t\t\t\tfor i := 0; i < len(re.Rune); i += 2 {\n\t\t\t\t\tif rune(c) >= re.Rune[i] && rune(c) <= re.Rune[i+1] {\n\t\t\t\t\t\tchars = append(chars, c)\n\t\t\t\t\t\tbreak\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif len(chars) > 0 {\n\t\t\t\treturn string([]byte{chars[f.IntN(len(chars))]})\n\t\t\t}\n\t\t}\n\n\t\tr := f.IntN(int(sum))\n\t\tvar ru rune\n\t\tsum = 0\n\t\tfor i := 0; i < len(re.Rune); i += 2 {\n\t\t\tgap := int(re.Rune[i+1]-re.Rune[i]) + 1\n\t\t\tif sum+gap > r {\n\t\t\t\tru = re.Rune[i] + rune(r-sum)\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tsum += gap\n\t\t}\n\n\t\treturn string(ru)\n\tcase syntax.OpAnyCharNotNL, syntax.OpAnyChar: // matches any character(and except newline)\n\t\treturn randCharacter(f, allStr)\n\tcase syntax.OpBeginLine: // matches empty string at beginning of line\n\tcase syntax.OpEndLine: // matches empty string at end of line\n\tcase syntax.OpBeginText: // matches empty string at beginning of text\n\tcase syntax.OpEndText: // matches empty string at end of text\n\tcase syntax.OpWordBoundary: // matches word boundary `\\b`\n\tcase syntax.OpNoWordBoundary: // matches word non-boundary `\\B`\n\tcase syntax.OpCapture: // capturing subexpression with index Cap, optional name Name\n\t\treturn regexGenerate(f, re.Sub0[0], limit)\n\tcase syntax.OpStar: // matches Sub[0] zero or more times\n\t\tvar b strings.Builder\n\t\tfor i := 0; i < number(f, 0, 10); i++ {\n\t\t\tfor _, rs := range re.Sub {\n\t\t\t\tb.WriteString(regexGenerate(f, rs, limit-b.Len()))\n\t\t\t}\n\t\t}\n\t\treturn b.String()\n\tcase syntax.OpPlus: // matches Sub[0] one or more times\n\t\tvar b strings.Builder\n\t\tfor i := 0; i < number(f, 1, 10); i++ {\n\t\t\tfor _, rs := range re.Sub {\n\t\t\t\tb.WriteString(regexGenerate(f, rs, limit-b.Len()))\n\t\t\t}\n\t\t}\n\t\treturn b.String()\n\tcase syntax.OpQuest: // matches Sub[0] zero or one times\n\t\tvar b strings.Builder\n\t\tfor i := 0; i < number(f, 0, 1); i++ {\n\t\t\tfor _, rs := range re.Sub {\n\t\t\t\tb.WriteString(regexGenerate(f, rs, limit-b.Len()))\n\t\t\t}\n\t\t}\n\t\treturn b.String()\n\tcase syntax.OpRepeat: // matches Sub[0] at least Min times, at most Max (Max == -1 is no limit)\n\t\tvar b strings.Builder\n\t\tcount := 0\n\t\tre.Max = int(math.Min(float64(re.Max), float64(10)))\n\t\tif re.Max > re.Min {\n\t\t\tcount = f.IntN(re.Max - re.Min + 1)\n\t\t}\n\t\tfor i := 0; i < re.Min || i < (re.Min+count); i++ {\n\t\t\tfor _, rs := range re.Sub {\n\t\t\t\tb.WriteString(regexGenerate(f, rs, limit-b.Len()))\n\t\t\t}\n\t\t}\n\t\treturn b.String()\n\tcase syntax.OpConcat: // matches concatenation of Subs\n\t\tvar b strings.Builder\n\t\tfor _, rs := range re.Sub {\n\t\t\tb.WriteString(regexGenerate(f, rs, limit-b.Len()))\n\t\t}\n\t\treturn b.String()\n\tcase syntax.OpAlternate: // matches alternation of Subs\n\t\treturn regexGenerate(f, re.Sub[number(f, 0, len(re.Sub)-1)], limit)\n\t}\n\n\treturn \"\"\n}\n\n// Map will generate a random set of map data\nfunc Map() map[string]any { return mapFunc(GlobalFaker) }\n\n// Map will generate a random set of map data\nfunc (f *Faker) Map() map[string]any { return mapFunc(f) }\n\nfunc mapFunc(f *Faker) map[string]any {\n\tm := map[string]any{}\n\n\trandWordType := func() string {\n\t\ts := randomString(f, []string{\"lorem\", \"bs\", \"job\", \"name\", \"address\"})\n\t\tswitch s {\n\t\tcase \"bs\":\n\t\t\treturn bs(f)\n\t\tcase \"job\":\n\t\t\treturn jobTitle(f)\n\t\tcase \"name\":\n\t\t\treturn name(f)\n\t\tcase \"address\":\n\t\t\treturn street(f) + \", \" + city(f) + \", \" + state(f) + \" \" + zip(f)\n\t\t}\n\t\treturn word(f)\n\t}\n\n\trandSlice := func() []string {\n\t\tvar sl []string\n\t\tfor ii := 0; ii < number(f, 3, 10); ii++ {\n\t\t\tsl = append(sl, word(f))\n\t\t}\n\t\treturn sl\n\t}\n\n\tfor i := 0; i < number(f, 3, 10); i++ {\n\t\tt := randomString(f, []string{\"string\", \"int\", \"float\", \"slice\", \"map\"})\n\t\tswitch t {\n\t\tcase \"string\":\n\t\t\tm[word(f)] = randWordType()\n\t\tcase \"int\":\n\t\t\tm[word(f)] = number(f, 1, 10000000)\n\t\tcase \"float\":\n\t\t\tm[word(f)] = float32Range(f, 1, 1000000)\n\t\tcase \"slice\":\n\t\t\tm[word(f)] = randSlice()\n\t\tcase \"map\":\n\t\t\tmm := map[string]any{}\n\t\t\ttt := randomString(f, []string{\"string\", \"int\", \"float\", \"slice\"})\n\t\t\tswitch tt {\n\t\t\tcase \"string\":\n\t\t\t\tmm[word(f)] = randWordType()\n\t\t\tcase \"int\":\n\t\t\t\tmm[word(f)] = number(f, 1, 10000000)\n\t\t\tcase \"float\":\n\t\t\t\tmm[word(f)] = float32Range(f, 1, 1000000)\n\t\t\tcase \"slice\":\n\t\t\t\tmm[word(f)] = randSlice()\n\t\t\t}\n\t\t\tm[word(f)] = mm\n\t\t}\n\t}\n\n\treturn m\n}\n\nfunc addGenerateLookup() {\n\tAddFuncLookup(\"generate\", Info{\n\t\tDisplay:     \"Generate\",\n\t\tCategory:    \"generate\",\n\t\tDescription: \"Random string generated from string value based upon available data sets\",\n\t\tExample:     \"{firstname} {lastname} {email} - Markus Moen markusmoen@pagac.net\",\n\t\tOutput:      \"string\",\n\t\tParams: []Param{\n\t\t\t{Field: \"str\", Display: \"String\", Type: \"string\", Description: \"String value to generate from\"},\n\t\t},\n\t\tGenerate: func(f *Faker, m *MapParams, info *Info) (any, error) {\n\t\t\tstr, err := info.GetString(m, \"str\")\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\n\t\t\t// Limit the length of the string passed\n\t\t\tif len(str) > 1000 {\n\t\t\t\treturn nil, errors.New(\"string length is too large. limit to 1000 characters\")\n\t\t\t}\n\n\t\t\treturn generate(f, str)\n\t\t},\n\t})\n\n\tAddFuncLookup(\"fixed_width\", Info{\n\t\tDisplay:     \"Fixed Width\",\n\t\tCategory:    \"generate\",\n\t\tDescription: \"Fixed width rows of output data based on input fields\",\n\t\tExample: `Name               Email                          Password         Age\nMarkus Moen        sylvanmraz@murphy.net          6VlvH6qqXc7g     13\nAlayna Wuckert     santinostanton@carroll.biz     g7sLrS0gEwLO     46\nLura Lockman       zacherykuhic@feil.name         S8gV7Z64KlHG     12`,\n\t\tOutput:      \"[]byte\",\n\t\tContentType: \"text/plain\",\n\t\tParams: []Param{\n\t\t\t{Field: \"rowcount\", Display: \"Row Count\", Type: \"int\", Default: \"10\", Description: \"Number of rows\"},\n\t\t\t{Field: \"fields\", Display: \"Fields\", Type: \"[]Field\", Description: \"Fields name, function and params\"},\n\t\t},\n\t\tGenerate: func(f *Faker, m *MapParams, info *Info) (any, error) {\n\t\t\tco := FixedWidthOptions{}\n\n\t\t\trowCount, err := info.GetInt(m, \"rowcount\")\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\n\t\t\tco.RowCount = rowCount\n\n\t\t\tfields, _ := info.GetStringArray(m, \"fields\")\n\n\t\t\t// Check to make sure fields has length\n\t\t\tif len(fields) > 0 {\n\t\t\t\tco.Fields = make([]Field, len(fields))\n\t\t\t\tfor i, f := range fields {\n\t\t\t\t\t// Unmarshal fields string into fields array\n\t\t\t\t\terr = json.Unmarshal([]byte(f), &co.Fields[i])\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\treturn nil, err\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\treturn nil, errors.New(\"missing fields\")\n\t\t\t}\n\n\t\t\tout, err := fixeWidthFunc(f, &co)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\n\t\t\treturn out, nil\n\t\t},\n\t})\n\n\tAddFuncLookup(\"regex\", Info{\n\t\tDisplay:     \"Regex\",\n\t\tCategory:    \"generate\",\n\t\tDescription: \"Pattern-matching tool used in text processing to search and manipulate strings\",\n\t\tExample:     \"[abcdef]{5} - affec\",\n\t\tOutput:      \"string\",\n\t\tParams: []Param{\n\t\t\t{Field: \"str\", Display: \"String\", Type: \"string\", Description: \"Regex RE2 syntax string\"},\n\t\t},\n\t\tGenerate: func(f *Faker, m *MapParams, info *Info) (any, error) {\n\t\t\tstr, err := info.GetString(m, \"str\")\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\n\t\t\t// Limit the length of the string passed\n\t\t\tif len(str) > 500 {\n\t\t\t\treturn nil, errors.New(\"string length is too large. limit to 500 characters\")\n\t\t\t}\n\n\t\t\treturn regex(f, str), nil\n\t\t},\n\t})\n\n\tAddFuncLookup(\"map\", Info{\n\t\tDisplay:     \"Map\",\n\t\tCategory:    \"generate\",\n\t\tDescription: \"Data structure that stores key-value pairs\",\n\t\tExample: `{\n\t\"software\": 7518355,\n\t\"that\": [\"despite\", \"pack\", \"whereas\", \"recently\", \"there\", \"anyone\", \"time\", \"read\"],\n\t\"use\": 683598,\n\t\"whom\": \"innovate\",\n\t\"yourselves\": 1987784\n}`,\n\t\tOutput:      \"map[string]any\",\n\t\tContentType: \"application/json\",\n\t\tGenerate: func(f *Faker, m *MapParams, info *Info) (any, error) {\n\t\t\treturn mapFunc(f), nil\n\t\t},\n\t})\n}\n"
        },
        {
          "name": "generate_test.go",
          "type": "blob",
          "size": 12.0244140625,
          "content": "package gofakeit\n\nimport (\n\t\"fmt\"\n\t\"regexp\"\n\t\"strings\"\n\t\"testing\"\n)\n\nfunc TestGenerate(t *testing.T) {\n\toutput := \"\"\n\tvar err error\n\n\tnumTests := 1000\n\tfor i := 0; i < numTests; i++ {\n\t\toutput, err = Generate(\"{firstname} {lastname} {email} #?#?#?\")\n\t\tif err != nil {\n\t\t\tt.Error(err)\n\t\t}\n\t\tif strings.Contains(output, \"{\") || strings.Contains(output, \"}\") {\n\t\t\tt.Error(\"Output should not contain either { or }. Output: \", output)\n\t\t}\n\t}\n}\n\nfunc TestGenerate_Sub(t *testing.T) {\n\tt.Run(\"Simple\", func(t *testing.T) {\n\t\tSeed(11)\n\n\t\toutput, err := Generate(\"{randomstring:[{firstname},{lastname}]}\")\n\t\tif err != nil {\n\t\t\tt.Error(err)\n\t\t}\n\t\tif output == \"\" {\n\t\t\tt.Error(\"Output was empty\")\n\t\t}\n\t})\n\n\tt.Run(\"Complex\", func(t *testing.T) {\n\t\tSeed(11)\n\n\t\toutput, err := Generate(\"{randomstring:[{randomstring:[{firstname},{lastname}]},{randomstring:[{firstname},{lastname}]}]}\")\n\t\tif err != nil {\n\t\t\tt.Error(err)\n\t\t}\n\t\tif output == \"\" {\n\t\t\tt.Error(\"Output was empty\")\n\t\t}\n\t})\n}\n\nfunc ExampleGenerate() {\n\tSeed(11)\n\n\tgenStr, _ := Generate(\"{firstname} {lastname} {email} #?#?#?\")\n\tfmt.Println(genStr)\n\tgenStr, _ = Generate(\"{sentence:3}\")\n\tfmt.Println(genStr)\n\tgenStr, _ = Generate(\"{shuffleints:[1,2,3]}\")\n\tfmt.Println(genStr)\n\tgenStr, _ = Generate(\"{randomint:[1,2,3,-4]}\")\n\tfmt.Println(genStr)\n\tgenStr, _ = Generate(\"{randomuint:[1,2,3,4]}\")\n\tfmt.Println(genStr)\n\tgenStr, _ = Generate(\"{number:1,50}\")\n\tfmt.Println(genStr)\n\tgenStr, _ = Generate(\"{shufflestrings:[key:value,int:string,1:2,a:b]}\")\n\tfmt.Println(genStr)\n\n\t// Output: Mollie Legros vanceschroeder@turner.com 8K8b1M\n\t// Something am elsewhere.\n\t// [3 2 1]\n\t// 3\n\t// 3\n\t// 18\n\t// [key:value a:b int:string 1:2]\n}\n\nfunc ExampleFaker_Generate() {\n\tf := New(11)\n\n\tgenStr, _ := f.Generate(\"{firstname} {lastname} {email} #?#?#?\")\n\tfmt.Println(genStr)\n\tgenStr, _ = f.Generate(\"{sentence:3}\")\n\tfmt.Println(genStr)\n\tgenStr, _ = f.Generate(\"{shuffleints:[1,2,3]}\")\n\tfmt.Println(genStr)\n\tgenStr, _ = f.Generate(\"{randomint:[1,2,3,-4]}\")\n\tfmt.Println(genStr)\n\tgenStr, _ = f.Generate(\"{randomuint:[1,2,3,4]}\")\n\tfmt.Println(genStr)\n\tgenStr, _ = f.Generate(\"{number:1,50}\")\n\tfmt.Println(genStr)\n\tgenStr, _ = f.Generate(\"{shufflestrings:[key:value,int:string,1:2,a:b]}\")\n\tfmt.Println(genStr)\n\n\t// Output: Mollie Legros vanceschroeder@turner.com 8K8b1M\n\t// Something am elsewhere.\n\t// [3 2 1]\n\t// 3\n\t// 3\n\t// 18\n\t// [key:value a:b int:string 1:2]\n}\n\nfunc BenchmarkGenerate(b *testing.B) {\n\tb.Run(\"package\", func(b *testing.B) {\n\t\tfor i := 0; i < b.N; i++ {\n\t\t\tGenerate(\"{firstname} {lastname} {email} #?#?#?\")\n\t\t}\n\t})\n\n\tb.Run(\"Complex\", func(b *testing.B) {\n\t\tfor i := 0; i < b.N; i++ {\n\t\t\tGenerate(\"{randomstring:[{randomstring:[{firstname},{lastname}]},{randomstring:[{firstname},{lastname}]}]}\")\n\t\t}\n\t})\n}\n\nfunc ExampleFixedWidth() {\n\tSeed(11)\n\n\tvalue, err := FixedWidth(&FixedWidthOptions{\n\t\tRowCount: 3,\n\t\tFields: []Field{\n\t\t\t{Name: \"Name\", Function: \"{firstname} {lastname}\"},\n\t\t\t{Name: \"Email\", Function: \"email\"},\n\t\t\t{Name: \"Password\", Function: \"password\", Params: MapParams{\"special\": {\"false\"}}},\n\t\t\t{Name: \"Age\", Function: \"{number:1,100}\"},\n\t\t},\n\t})\n\tif err != nil {\n\t\tfmt.Println(err)\n\t}\n\n\tfmt.Println(string(value))\n\n\t// Output: Name                 Email                          Password         Age\n\t// Sonny Stiedemann     mollielegros@wilderman.org     3T8l34B5F0eb     62\n\t// Cody Donnelly        stevebins@robel.io             3fnu2C12baqe     9\n\t// Julius Farrell       tomasaullrich@hane.name        e8W8SJGZi1Y4     77\n}\n\nfunc ExampleFixedWidth_default() {\n\tSeed(11)\n\n\tvalue, err := FixedWidth(nil)\n\tif err != nil {\n\t\tfmt.Println(err)\n\t}\n\n\tfmt.Println(string(value))\n\n\t// Output: Name                  Email                          Password\n\t// Russ Donnelly         missourigrimes@rohan.io        N3xh07881HKv\n\t// Cole Leannon          evanadams@marquardt.com        n2fja08VHMgw\n\t// Darien Rempel         thorajerde@cormier.com         ZhMPq5v8z6iP\n\t// Kaitlyn Wilderman     constancenienow@smitham.io     MkoTT5v5Mv6Q\n\t// Rahul Turner          irvingbins@lemke.io            8Wy0UV016u88\n\t// April Robel           beaulahmayert@kautzer.net      ykgR5bO83YSa\n\t// Tomasa Waters         lelandwaelchi@beahan.net       k68Ew58F9a0V\n\t// Sunny Hane            dawnbaumbach@mcdermott.biz     AbUjm6x5dwd8\n\t// Hilma Jast            lavernerobel@bailey.io         MyY49BLUWKCh\n}\n\nfunc ExampleFixedWidth_noHeader() {\n\tSeed(11)\n\n\tvalue, err := FixedWidth(&FixedWidthOptions{\n\t\tRowCount: 3,\n\t\tFields: []Field{\n\t\t\t{Name: \"\", Function: \"{firstname} {lastname}\"},\n\t\t\t{Name: \"\", Function: \"email\"},\n\t\t\t{Name: \"\", Function: \"password\", Params: MapParams{\"special\": {\"false\"}}},\n\t\t\t{Name: \"\", Function: \"{number:1,100}\"},\n\t\t},\n\t})\n\tif err != nil {\n\t\tfmt.Println(err)\n\t}\n\n\tfmt.Println(value)\n\n\t// Output: Sonny Stiedemann     mollielegros@wilderman.org     3T8l34B5F0eb     62\n\t// Cody Donnelly        stevebins@robel.io             3fnu2C12baqe     9\n\t// Julius Farrell       tomasaullrich@hane.name        e8W8SJGZi1Y4     77\n}\n\nfunc ExampleFaker_FixedWidth() {\n\tf := New(11)\n\n\tvalue, err := f.FixedWidth(&FixedWidthOptions{\n\t\tRowCount: 3,\n\t\tFields: []Field{\n\t\t\t{Name: \"Name\", Function: \"{firstname} {lastname}\"},\n\t\t\t{Name: \"Email\", Function: \"email\"},\n\t\t\t{Name: \"Password\", Function: \"password\", Params: MapParams{\"special\": {\"false\"}}},\n\t\t\t{Name: \"Age\", Function: \"{number:1,100}\"},\n\t\t},\n\t})\n\tif err != nil {\n\t\tfmt.Println(err)\n\t}\n\n\tfmt.Println(string(value))\n\n\t// Output: Name                 Email                          Password         Age\n\t// Sonny Stiedemann     mollielegros@wilderman.org     3T8l34B5F0eb     62\n\t// Cody Donnelly        stevebins@robel.io             3fnu2C12baqe     9\n\t// Julius Farrell       tomasaullrich@hane.name        e8W8SJGZi1Y4     77\n}\n\nfunc TestFixedWidthLookup(t *testing.T) {\n\tfaker := New(0)\n\n\tinfo := GetFuncLookup(\"fixed_width\")\n\n\tm := MapParams{\n\t\t\"rowcount\": {\"10\"},\n\t\t\"fields\": {\n\t\t\t`{\"name\":\"Name\",\"function\":\"{firstname} {lastname}\"}`,\n\t\t\t`{\"name\":\"Email\",\"function\":\"email\"}`,\n\t\t\t`{\"name\":\"Password\",\"function\":\"password\",\"params\":{\"special\":[\"false\"],\"length\":[\"20\"]}}`,\n\t\t\t`{\"name\":\"Age\",\"function\":\"{number:1,100}\"}`,\n\t\t},\n\t}\n\n\toutput, err := info.Generate(faker, &m, info)\n\tif err != nil {\n\t\tt.Fatal(err.Error())\n\t}\n\n\tvalue := string(output.(string))\n\n\t// Check the rumber of rows by counting the newlines, end of file has no newline\n\tif strings.Count(value, \"\\n\") != 10 {\n\t\tt.Error(\"Expected 10+1(header row footer) rows, got\", strings.Count(value, \"\\n\"))\n\t}\n\n}\n\nfunc TestFixedWidthNoOptions(t *testing.T) {\n\tSeed(11)\n\n\t_, err := FixedWidth(nil)\n\n\tif err != nil {\n\t\tt.Fatal(err.Error())\n\t}\n\n}\n\nfunc BenchmarkFixedWidthLookup100(b *testing.B) {\n\tfaker := New(0)\n\n\tfor i := 0; i < b.N; i++ {\n\t\tinfo := GetFuncLookup(\"fixed_width\")\n\t\tm := MapParams{\n\t\t\t\"rowcount\": {\"100\"},\n\t\t\t\"fields\": {\n\t\t\t\t// `{\"name\":\"Name\",\"function\":\"{firstname} {lastname}\"}`,\n\t\t\t\t`{\"name\":\"Email\",\"function\":\"email\"}`,\n\t\t\t\t`{\"name\":\"Password\",\"function\":\"password\",\"params\":{\"special\":[\"false\"],\"length\":[\"20\"]}}`,\n\t\t\t\t`{\"name\":\"Age\",\"function\":\"{number:1,100}\"}`,\n\t\t\t},\n\t\t}\n\t\t_, err := info.Generate(faker, &m, info)\n\t\tif err != nil {\n\t\t\t// Stack trace\n\n\t\t\tb.Fatal(err.Error())\n\t\t}\n\t}\n}\n\nfunc ExampleRegex() {\n\tSeed(11)\n\n\tfmt.Println(Regex(\"[abcdef]{5}\"))\n\tfmt.Println(Regex(\"[[:upper:]]{5}\"))\n\tfmt.Println(Regex(\"(hello|world|whats|up)\"))\n\tfmt.Println(Regex(`^[a-z]{5,10}@[a-z]{5,10}\\.(com|net|org)$`))\n\n\t// Output: ffbbd\n\t// GSNYV\n\t// up\n\t// tyyxi@kshtyia.net\n}\n\nfunc ExampleFaker_Regex() {\n\tf := New(11)\n\n\tfmt.Println(f.Regex(\"[abcdef]{5}\"))\n\tfmt.Println(f.Regex(\"[[:upper:]]{5}\"))\n\tfmt.Println(f.Regex(\"(hello|world|whats|up)\"))\n\tfmt.Println(f.Regex(`^[a-z]{5,10}@[a-z]{5,10}\\.(com|net|org)$`))\n\n\t// Output: ffbbd\n\t// GSNYV\n\t// up\n\t// tyyxi@kshtyia.net\n}\n\nvar regexes = []struct{ test string }{\n\t{`^\\d+$`},\n\t{`\\D{3}`},\n\t{`Z{2,5}`},\n\t{`[^1]{3,5}`},\n\t{`(ab|bc)def`},\n\t{`((123)?){3}`},\n\t{`[^abcdef]{5}`},\n\t{`[a-zA-Z]{100}`},\n\t{`[[:upper:]]{5}`},\n\t{`[^0-5a-z\\s]{5}`},\n\t{`123[0-2]+.*\\w{3}`},\n\t{`(hello|world|whats|up)`},\n\t{`^\\d{1,2}[/](1[0-2]|[1-9])[/]((19|20)\\d{2})$`},\n\t{`^((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\\.){3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])$`},\n\t{\"^[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\\\\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$\"},\n}\n\nfunc TestRegex(t *testing.T) {\n\tfor _, r := range regexes {\n\t\tfor i := 0; i < 100; i++ {\n\t\t\t// Try to compile regexTest\n\t\t\tregCompile, err := regexp.Compile(r.test)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatal(\"Error compiling. regex: \", r.test, \" failed to compile:\", err)\n\t\t\t}\n\n\t\t\t// Generate string and test it matches the regex syntax\n\t\t\treg := Regex(r.test)\n\t\t\tif !regCompile.MatchString(reg) {\n\t\t\t\tt.Error(\"Generated data does not match regex. Regex: \", r.test, \" output: \", reg)\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc TestRegex_Struct(t *testing.T) {\n\tSeed(11)\n\n\ttype Reggy struct {\n\t\tStr1  string `fake:\"{regex:^\\\\d+$}\"`\n\t\tStr2  string `fake:\"{regex:\\\\D{3}}\"`\n\t\tStr3  string `fake:\"{regex:Z{2,5}}\"`\n\t\tStr4  string `fake:\"{regex:[^1]{3,5}}\"`\n\t\tStr5  string `fake:\"{regex:(ab|bc)def}\"`\n\t\tStr6  string `fake:\"{regex:((123)?){3}}\"`\n\t\tStr7  string `fake:\"{regex:[^abcdef]{5}}\"`\n\t\tStr8  string `fake:\"{regex:[a-zA-Z]{10}}\"`\n\t\tStr9  string `fake:\"{regex:[[:upper:]]{5}}\"`\n\t\tStr10 string `fake:\"{regex:[^0-5a-z\\\\s]{5}}\"`\n\t\tStr11 string `fake:\"{regex:123[0-2]+.*\\\\w{3}}\"`\n\t\tStr12 string `fake:\"{regex:(hello|world|whats|up)}\"`\n\t\tStr13 string `fake:\"{regex:^\\\\d{1,2}[/](1[0-2]|[1-9])[/]((19|20)\\\\d{2})$}\"`\n\t}\n\n\trg := Reggy{}\n\tStruct(&rg)\n\n\t// Test Str1 matches regex\n\tif !regexp.MustCompile(`^\\d+$`).MatchString(rg.Str1) {\n\t\tt.Errorf(\"Str1 should match regex: ^\\\\d+$ got: %s\", rg.Str1)\n\t}\n\tif !regexp.MustCompile(`\\D{3}`).MatchString(rg.Str2) {\n\t\tt.Errorf(\"Str2 should match regex: \\\\D{3} got: %s\", rg.Str2)\n\t}\n\tif !regexp.MustCompile(`Z{2,5}`).MatchString(rg.Str3) {\n\t\tt.Errorf(\"Str3 should match regex: Z{2,5} got: %s\", rg.Str3)\n\t}\n\tif !regexp.MustCompile(`[^1]{3,5}`).MatchString(rg.Str4) {\n\t\tt.Errorf(\"Str4 should match regex: [^1]{3,5} got: %s\", rg.Str4)\n\t}\n\tif !regexp.MustCompile(`(ab|bc)def`).MatchString(rg.Str5) {\n\t\tt.Errorf(\"Str5 should match regex: (ab|bc)def got: %s\", rg.Str5)\n\t}\n\tif !regexp.MustCompile(`((123)?){3}`).MatchString(rg.Str6) {\n\t\tt.Errorf(\"Str6 should match regex: ((123)?){3} got: %s\", rg.Str6)\n\t}\n\tif !regexp.MustCompile(`[^abcdef]{5}`).MatchString(rg.Str7) {\n\t\tt.Errorf(\"Str7 should match regex: [^abcdef]{5} got: %s\", rg.Str7)\n\t}\n\tif !regexp.MustCompile(`[a-zA-Z]{10}`).MatchString(rg.Str8) {\n\t\tt.Errorf(\"Str8 should match regex: [a-zA-Z]{10} got: %s\", rg.Str8)\n\t}\n\tif !regexp.MustCompile(`[[:upper:]]{5}`).MatchString(rg.Str9) {\n\t\tt.Errorf(\"Str9 should match regex: [[:upper:]]{5} got: %s\", rg.Str9)\n\t}\n\tif !regexp.MustCompile(`[^0-5a-z\\s]{5}`).MatchString(rg.Str10) {\n\t\tt.Errorf(\"Str10 should match regex: [^0-5a-z\\\\s]{5} got: %s\", rg.Str10)\n\t}\n\tif !regexp.MustCompile(`123[0-2]+.*\\w{3}`).MatchString(rg.Str11) {\n\t\tt.Errorf(\"Str11 should match regex: 123[0-2]+.*\\\\w{3} got: %s\", rg.Str11)\n\t}\n\tif !regexp.MustCompile(`(hello|world|whats|up)`).MatchString(rg.Str12) {\n\t\tt.Errorf(\"Str12 should match regex: (hello|world|whats|up) got: %s\", rg.Str12)\n\t}\n\tif !regexp.MustCompile(`^\\d{1,2}[/](1[0-2]|[1-9])[/]((19|20)\\d{2})$`).MatchString(rg.Str13) {\n\t\tt.Errorf(\"Str13 should match regex: ^\\\\d{1,2}[/](1[0-2]|[1-9])[/]((19|20)\\\\d{2})$ got: %s\", rg.Str13)\n\t}\n}\n\nfunc BenchmarkRegex(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tRegex(`(hello|world|whats|up`)\n\t}\n}\n\nfunc BenchmarkRegexEmail(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tRegex(\"^[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\\\\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$\")\n\t}\n}\n\nfunc ExampleMap() {\n\tSeed(11)\n\tfmt.Println(Map())\n\n\t// Output: map[a:map[that:could] above:[sometimes vast whom us scarcely these huh] am:map[how:9310653] depend:map[hey:5402877] out:381794.78 since:916659.94 these:map[frequently:2314010]]\n}\n\nfunc ExampleFaker_Map() {\n\tf := New(11)\n\tfmt.Println(f.Map())\n\n\t// Output: map[a:map[that:could] above:[sometimes vast whom us scarcely these huh] am:map[how:9310653] depend:map[hey:5402877] out:381794.78 since:916659.94 these:map[frequently:2314010]]\n}\n\nfunc TestMap(t *testing.T) {\n\tfor i := 0; i < 100; i++ {\n\t\tMap()\n\t}\n}\n\nfunc BenchmarkMap(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tMap()\n\t}\n}\n"
        },
        {
          "name": "go.mod",
          "type": "blob",
          "size": 0.046875,
          "content": "module github.com/brianvoe/gofakeit/v7\n\ngo 1.22\n"
        },
        {
          "name": "go.sum",
          "type": "blob",
          "size": 0,
          "content": ""
        },
        {
          "name": "hacker.go",
          "type": "blob",
          "size": 4.396484375,
          "content": "package gofakeit\n\nimport (\n\t\"strings\"\n)\n\n// HackerPhrase will return a random hacker sentence\nfunc HackerPhrase() string { return hackerPhrase(GlobalFaker) }\n\n// HackerPhrase will return a random hacker sentence\nfunc (f *Faker) HackerPhrase() string { return hackerPhrase(f) }\n\nfunc hackerPhrase(f *Faker) string {\n\tgenStr, _ := generate(f, getRandValue(f, []string{\"hacker\", \"phrase\"}))\n\n\twords := strings.Split(genStr, \" \")\n\twords[0] = strings.ToUpper(words[0][0:1]) + words[0][1:]\n\treturn strings.Join(words, \" \")\n}\n\n// HackerAbbreviation will return a random hacker abbreviation\nfunc HackerAbbreviation() string { return hackerAbbreviation(GlobalFaker) }\n\n// HackerAbbreviation will return a random hacker abbreviation\nfunc (f *Faker) HackerAbbreviation() string { return hackerAbbreviation(f) }\n\nfunc hackerAbbreviation(f *Faker) string {\n\treturn getRandValue(f, []string{\"hacker\", \"abbreviation\"})\n}\n\n// HackerAdjective will return a random hacker adjective\nfunc HackerAdjective() string { return hackerAdjective(GlobalFaker) }\n\n// HackerAdjective will return a random hacker adjective\nfunc (f *Faker) HackerAdjective() string { return hackerAdjective(f) }\n\nfunc hackerAdjective(f *Faker) string {\n\treturn getRandValue(f, []string{\"hacker\", \"adjective\"})\n}\n\n// HackerNoun will return a random hacker noun\nfunc HackerNoun() string { return hackerNoun(GlobalFaker) }\n\n// HackerNoun will return a random hacker noun\nfunc (f *Faker) HackerNoun() string { return hackerNoun(f) }\n\nfunc hackerNoun(f *Faker) string {\n\treturn getRandValue(f, []string{\"hacker\", \"noun\"})\n}\n\n// HackerVerb will return a random hacker verb\nfunc HackerVerb() string { return hackerVerb(GlobalFaker) }\n\n// HackerVerb will return a random hacker verb\nfunc (f *Faker) HackerVerb() string { return hackerVerb(f) }\n\nfunc hackerVerb(f *Faker) string {\n\treturn getRandValue(f, []string{\"hacker\", \"verb\"})\n}\n\n// HackeringVerb will return a random hacker ingverb\nfunc HackeringVerb() string { return hackeringVerb(GlobalFaker) }\n\n// HackeringVerb will return a random hacker ingverb\nfunc (f *Faker) HackeringVerb() string { return hackeringVerb(f) }\n\nfunc hackeringVerb(f *Faker) string {\n\treturn getRandValue(f, []string{\"hacker\", \"ingverb\"})\n}\n\nfunc addHackerLookup() {\n\tAddFuncLookup(\"hackerphrase\", Info{\n\t\tDisplay:     \"Hacker Phrase\",\n\t\tCategory:    \"hacker\",\n\t\tDescription: \"Informal jargon and slang used in the hacking and cybersecurity community\",\n\t\tExample:     \"If we calculate the program, we can get to the AI pixel through the redundant XSS matrix!\",\n\t\tOutput:      \"string\",\n\t\tGenerate: func(f *Faker, m *MapParams, info *Info) (any, error) {\n\t\t\treturn hackerPhrase(f), nil\n\t\t},\n\t})\n\n\tAddFuncLookup(\"hackerabbreviation\", Info{\n\t\tDisplay:     \"Hacker Abbreviation\",\n\t\tCategory:    \"hacker\",\n\t\tDescription: \"Abbreviations and acronyms commonly used in the hacking and cybersecurity community\",\n\t\tExample:     \"ADP\",\n\t\tOutput:      \"string\",\n\t\tGenerate: func(f *Faker, m *MapParams, info *Info) (any, error) {\n\t\t\treturn hackerAbbreviation(f), nil\n\t\t},\n\t})\n\n\tAddFuncLookup(\"hackeradjective\", Info{\n\t\tDisplay:     \"Hacker Adjective\",\n\t\tCategory:    \"hacker\",\n\t\tDescription: \"Adjectives describing terms often associated with hackers and cybersecurity experts\",\n\t\tExample:     \"wireless\",\n\t\tOutput:      \"string\",\n\t\tGenerate: func(f *Faker, m *MapParams, info *Info) (any, error) {\n\t\t\treturn hackerAdjective(f), nil\n\t\t},\n\t})\n\n\tAddFuncLookup(\"hackernoun\", Info{\n\t\tDisplay:     \"Hacker Noun\",\n\t\tCategory:    \"hacker\",\n\t\tDescription: \"Noun representing an element, tool, or concept within the realm of hacking and cybersecurity\",\n\t\tExample:     \"driver\",\n\t\tOutput:      \"string\",\n\t\tGenerate: func(f *Faker, m *MapParams, info *Info) (any, error) {\n\t\t\treturn hackerNoun(f), nil\n\t\t},\n\t})\n\n\tAddFuncLookup(\"hackerverb\", Info{\n\t\tDisplay:     \"Hacker Verb\",\n\t\tCategory:    \"hacker\",\n\t\tDescription: \"Verbs associated with actions and activities in the field of hacking and cybersecurity\",\n\t\tExample:     \"synthesize\",\n\t\tOutput:      \"string\",\n\t\tGenerate: func(f *Faker, m *MapParams, info *Info) (any, error) {\n\t\t\treturn hackerVerb(f), nil\n\t\t},\n\t})\n\n\tAddFuncLookup(\"hackeringverb\", Info{\n\t\tDisplay:     \"Hackering Verb\",\n\t\tCategory:    \"hacker\",\n\t\tDescription: \"Verb describing actions and activities related to hacking, often involving computer systems and security\",\n\t\tExample:     \"connecting\",\n\t\tOutput:      \"string\",\n\t\tGenerate: func(f *Faker, m *MapParams, info *Info) (any, error) {\n\t\t\treturn hackeringVerb(f), nil\n\t\t},\n\t})\n}\n"
        },
        {
          "name": "hacker_test.go",
          "type": "blob",
          "size": 1.9150390625,
          "content": "package gofakeit\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc ExampleHackerPhrase() {\n\tSeed(11)\n\tfmt.Println(HackerPhrase())\n\n\t// Output: Use the optical CSS microchip, then you can write the open-source monitor!\n}\n\nfunc ExampleFaker_HackerPhrase() {\n\tf := New(11)\n\tfmt.Println(f.HackerPhrase())\n\n\t// Output: Use the optical CSS microchip, then you can write the open-source monitor!\n}\n\nfunc BenchmarkHackerPhrase(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tHackerPhrase()\n\t}\n}\n\nfunc ExampleHackerAbbreviation() {\n\tSeed(11)\n\tfmt.Println(HackerAbbreviation())\n\n\t// Output: SCSI\n}\n\nfunc ExampleFaker_HackerAbbreviation() {\n\tf := New(11)\n\tfmt.Println(f.HackerAbbreviation())\n\n\t// Output: SCSI\n}\n\nfunc BenchmarkHackerAbbreviation(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tHackerAbbreviation()\n\t}\n}\n\nfunc ExampleHackerAdjective() {\n\tSeed(11)\n\tfmt.Println(HackerAdjective())\n\n\t// Output: solid state\n}\n\nfunc ExampleFaker_HackerAdjective() {\n\tf := New(11)\n\tfmt.Println(f.HackerAdjective())\n\n\t// Output: solid state\n}\n\nfunc BenchmarkHackerAdjective(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tHackerAdjective()\n\t}\n}\n\nfunc ExampleHackerNoun() {\n\tSeed(11)\n\tfmt.Println(HackerNoun())\n\n\t// Output: circuit\n}\n\nfunc ExampleFaker_HackerNoun() {\n\tf := New(11)\n\tfmt.Println(f.HackerNoun())\n\n\t// Output: circuit\n}\n\nfunc BenchmarkHackerNoun(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tHackerNoun()\n\t}\n}\n\nfunc ExampleHackerVerb() {\n\tSeed(11)\n\tfmt.Println(HackerVerb())\n\n\t// Output: lock\n}\n\nfunc ExampleFaker_HackerVerb() {\n\tf := New(11)\n\tfmt.Println(f.HackerVerb())\n\n\t// Output: lock\n}\n\nfunc BenchmarkHackerVerb(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tHackerVerb()\n\t}\n}\n\nfunc ExampleHackeringVerb() {\n\tSeed(11)\n\tfmt.Println(HackeringVerb())\n\n\t// Output: compressing\n}\n\nfunc ExampleFaker_HackeringVerb() {\n\tf := New(11)\n\tfmt.Println(f.HackeringVerb())\n\n\t// Output: compressing\n}\n\nfunc BenchmarkHackeringVerb(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tHackeringVerb()\n\t}\n}\n"
        },
        {
          "name": "helpers.go",
          "type": "blob",
          "size": 8.0947265625,
          "content": "package gofakeit\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"math\"\n\t\"reflect\"\n\t\"strings\"\n\t\"unicode\"\n\n\t\"github.com/brianvoe/gofakeit/v7/data\"\n)\n\nconst lowerStr = \"abcdefghijklmnopqrstuvwxyz\"\nconst upperStr = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\nconst numericStr = \"0123456789\"\nconst specialStr = \"@#$%&?|!(){}<>=*+-_:;,.\"\nconst specialSafeStr = \"!@.-_*\" // https://github.com/1Password/spg/pull/22\nconst spaceStr = \" \"\nconst allStr = lowerStr + upperStr + numericStr + specialStr + spaceStr\nconst vowels = \"aeiou\"\nconst hashtag = '#'\nconst questionmark = '?'\nconst dash = '-'\nconst base58 = \"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz\"\nconst minUint = 0\nconst maxUint = ^uint(0)\nconst minInt = -maxInt - 1\nconst maxInt = int(^uint(0) >> 1)\nconst is32bit = ^uint(0)>>32 == 0\n\n// Check if in lib\nfunc dataCheck(dataVal []string) bool {\n\tvar checkOk bool\n\n\tif len(dataVal) == 2 {\n\t\t_, checkOk = data.Data[dataVal[0]]\n\t\tif checkOk {\n\t\t\t_, checkOk = data.Data[dataVal[0]][dataVal[1]]\n\t\t}\n\t}\n\n\treturn checkOk\n}\n\n// Get Random Value\nfunc getRandValue(f *Faker, dataVal []string) string {\n\tif !dataCheck(dataVal) {\n\t\treturn \"\"\n\t}\n\treturn data.Data[dataVal[0]][dataVal[1]][f.IntN(len(data.Data[dataVal[0]][dataVal[1]]))]\n}\n\n// Replace # with numbers\nfunc replaceWithNumbers(f *Faker, str string) string {\n\tif str == \"\" {\n\t\treturn str\n\t}\n\tbytestr := []byte(str)\n\tfor i := 0; i < len(bytestr); i++ {\n\t\tif bytestr[i] == hashtag {\n\t\t\tbytestr[i] = byte(randDigit(f))\n\t\t}\n\t}\n\tif bytestr[0] == '0' {\n\t\tbytestr[0] = byte(f.IntN(8)+1) + '0'\n\t}\n\n\treturn string(bytestr)\n}\n\n// Replace ? with ASCII lowercase letters\nfunc replaceWithLetters(f *Faker, str string) string {\n\tif str == \"\" {\n\t\treturn str\n\t}\n\tbytestr := []byte(str)\n\tfor i := 0; i < len(bytestr); i++ {\n\t\tif bytestr[i] == questionmark {\n\t\t\tbytestr[i] = byte(randLetter(f))\n\t\t}\n\t}\n\n\treturn string(bytestr)\n}\n\n// Replace ? with ASCII lowercase letters between a and f\nfunc replaceWithHexLetters(f *Faker, str string) string {\n\tif str == \"\" {\n\t\treturn str\n\t}\n\tbytestr := []byte(str)\n\tfor i := 0; i < len(bytestr); i++ {\n\t\tif bytestr[i] == questionmark {\n\t\t\tbytestr[i] = byte(randHexLetter(f))\n\t\t}\n\t}\n\n\treturn string(bytestr)\n}\n\n// Generate random lowercase ASCII letter\nfunc randLetter(f *Faker) rune {\n\tallLetters := upperStr + lowerStr\n\treturn rune(allLetters[f.IntN(len(allLetters))])\n}\n\nfunc randCharacter(f *Faker, s string) string {\n\treturn string(s[f.Int64()%int64(len(s))])\n}\n\n// Generate random lowercase ASCII letter between a and f\nfunc randHexLetter(f *Faker) rune {\n\treturn rune(byte(f.IntN(6)) + 'a')\n}\n\n// Generate random ASCII digit\nfunc randDigit(f *Faker) rune {\n\treturn rune(byte(f.IntN(10)) + '0')\n}\n\n// Generate random integer between min and max\nfunc randIntRange(f *Faker, min, max int) int {\n\tif min == max {\n\t\treturn min\n\t}\n\n\tif min > max {\n\t\tmin, max = max, min // Swap if min is greater than max\n\t}\n\n\t// Use f.IntN to generate a random number in [0, rangeSize) and shift it into [min, max].\n\treturn f.IntN(max-min+1) + min\n}\n\n// Generate random uint between min and max\nfunc randUintRange(f *Faker, min, max uint) uint {\n\tif min == max {\n\t\treturn min // Immediate return if range is zero\n\t}\n\n\tif min > max {\n\t\tmin, max = max, min // Swap if min is greater than max\n\t}\n\n\t// Use f.UintN to generate a random number in [0, rangeSize) and shift it into [min, max].\n\treturn f.UintN(max-min+1) + min\n}\n\nfunc toFixed(num float64, precision int) float64 {\n\toutput := math.Pow(10, float64(precision))\n\treturn float64(math.Floor(num*output)) / output\n}\n\nfunc equalSliceString(a, b []string) bool {\n\tsizeA, sizeB := len(a), len(b)\n\tif sizeA != sizeB {\n\t\treturn false\n\t}\n\n\tfor i, va := range a {\n\t\tvb := b[i]\n\n\t\tif va != vb {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\nfunc equalSliceInt(a, b []int) bool {\n\tsizeA, sizeB := len(a), len(b)\n\tif sizeA != sizeB {\n\t\treturn false\n\t}\n\n\tfor i, va := range a {\n\t\tvb := b[i]\n\n\t\tif va != vb {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\nfunc equalSliceInterface(a, b []any) bool {\n\tsizeA, sizeB := len(a), len(b)\n\tif sizeA != sizeB {\n\t\treturn false\n\t}\n\n\tfor i, va := range a {\n\t\tif !reflect.DeepEqual(va, b[i]) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\nfunc stringInSlice(a string, list []string) bool {\n\tfor _, b := range list {\n\t\tif b == a {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\nfunc anyToString(a any) string {\n\tif a == nil {\n\t\treturn \"\"\n\t}\n\n\t// If it's a slice of bytes or struct, unmarshal it into an interface\n\tif bytes, ok := a.([]byte); ok {\n\t\treturn string(bytes)\n\t}\n\n\t// If it's a struct, map, or slice, convert to JSON\n\tswitch reflect.TypeOf(a).Kind() {\n\tcase reflect.Struct, reflect.Map, reflect.Slice:\n\t\tb, err := json.Marshal(a)\n\t\tif err == nil {\n\t\t\treturn string(b)\n\t\t}\n\t}\n\n\treturn fmt.Sprintf(\"%v\", a)\n}\n\n// Title returns a copy of the string s with all Unicode letters that begin words\n// mapped to their Unicode title case\nfunc title(s string) string {\n\t// isSeparator reports whether the rune could mark a word boundary\n\tisSeparator := func(r rune) bool {\n\t\t// ASCII alphanumerics and underscore are not separators\n\t\tif r <= 0x7F {\n\t\t\tswitch {\n\t\t\tcase '0' <= r && r <= '9':\n\t\t\t\treturn false\n\t\t\tcase 'a' <= r && r <= 'z':\n\t\t\t\treturn false\n\t\t\tcase 'A' <= r && r <= 'Z':\n\t\t\t\treturn false\n\t\t\tcase r == '_':\n\t\t\t\treturn false\n\t\t\t}\n\t\t\treturn true\n\t\t}\n\n\t\t// Letters and digits are not separators\n\t\tif unicode.IsLetter(r) || unicode.IsDigit(r) {\n\t\t\treturn false\n\t\t}\n\n\t\t// Otherwise, all we can do for now is treat spaces as separators.\n\t\treturn unicode.IsSpace(r)\n\t}\n\n\tprev := ' '\n\treturn strings.Map(\n\t\tfunc(r rune) rune {\n\t\t\tif isSeparator(prev) {\n\t\t\t\tprev = r\n\t\t\t\treturn unicode.ToTitle(r)\n\t\t\t}\n\t\t\tprev = r\n\t\t\treturn r\n\t\t},\n\t\ts)\n}\n\nfunc funcLookupSplit(str string) ([]string, error) {\n\tout := []string{}\n\tfor str != \"\" {\n\t\tif strings.HasPrefix(str, \"[\") {\n\t\t\tstartIndex := strings.Index(str, \"[\")\n\t\t\tendIndex := strings.Index(str, \"]\")\n\t\t\tif endIndex == -1 {\n\t\t\t\treturn nil, fmt.Errorf(\"invalid lookup split missing ending ] bracket\")\n\t\t\t}\n\n\t\t\tval := str[(startIndex) : endIndex+1]\n\t\t\tout = append(out, strings.TrimSpace(val))\n\t\t\tstr = strings.Replace(str, val, \"\", 1)\n\n\t\t\t// Trim off comma if it has it\n\t\t\tif strings.HasPrefix(str, \",\") {\n\t\t\t\tstr = strings.Replace(str, \",\", \"\", 1)\n\t\t\t}\n\t\t} else {\n\t\t\tstrSplit := strings.SplitN(str, \",\", 2)\n\t\t\tstrSplitLen := len(strSplit)\n\t\t\tif strSplitLen >= 1 {\n\t\t\t\tout = append(out, strings.TrimSpace(strSplit[0]))\n\t\t\t}\n\t\t\tif strSplitLen >= 2 {\n\t\t\t\tstr = strSplit[1]\n\t\t\t} else {\n\t\t\t\tstr = \"\"\n\t\t\t}\n\t\t}\n\t}\n\n\treturn out, nil\n}\n\n// Used for parsing the tag in a struct\nfunc parseNameAndParamsFromTag(tag string) (string, string) {\n\t// Trim the curly on the beginning and end\n\ttag = strings.TrimLeft(tag, \"{\")\n\ttag = strings.TrimRight(tag, \"}\")\n\t// Check if has params separated by :\n\tfNameSplit := strings.SplitN(tag, \":\", 2)\n\tfName := \"\"\n\tfParams := \"\"\n\tif len(fNameSplit) >= 1 {\n\t\tfName = fNameSplit[0]\n\t}\n\tif len(fNameSplit) >= 2 {\n\t\tfParams = fNameSplit[1]\n\t}\n\treturn fName, fParams\n}\n\n// Used for parsing map params\nfunc parseMapParams(info *Info, fParams string) (*MapParams, error) {\n\t// Get parameters, make sure params and the split both have values\n\tmapParams := NewMapParams()\n\tparamsLen := len(info.Params)\n\n\t// If just one param and its a string simply just pass it\n\tif paramsLen == 1 && info.Params[0].Type == \"string\" {\n\t\tmapParams.Add(info.Params[0].Field, fParams)\n\t} else if paramsLen > 0 && fParams != \"\" {\n\t\tsplitVals, err := funcLookupSplit(fParams)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tmapParams, err = addSplitValsToMapParams(splitVals, info, mapParams)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\t// If mapParams doesnt have a size then return nil\n\tif mapParams.Size() == 0 {\n\t\treturn nil, nil\n\t}\n\n\treturn mapParams, nil\n}\n\n// Used for splitting the values\nfunc addSplitValsToMapParams(splitVals []string, info *Info, mapParams *MapParams) (*MapParams, error) {\n\tfor ii := 0; ii < len(splitVals); ii++ {\n\t\tif len(info.Params)-1 >= ii {\n\t\t\tif strings.HasPrefix(splitVals[ii], \"[\") {\n\t\t\t\tlookupSplits, err := funcLookupSplit(strings.TrimRight(strings.TrimLeft(splitVals[ii], \"[\"), \"]\"))\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn nil, err\n\t\t\t\t}\n\n\t\t\t\tfor _, v := range lookupSplits {\n\t\t\t\t\tmapParams.Add(info.Params[ii].Field, v)\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tmapParams.Add(info.Params[ii].Field, splitVals[ii])\n\t\t\t}\n\t\t}\n\t}\n\treturn mapParams, nil\n}\n"
        },
        {
          "name": "helpers_test.go",
          "type": "blob",
          "size": 8.578125,
          "content": "package gofakeit\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\n// Test taking in two random int values and making sure the output is within the range\nfunc TestRandIntRange(t *testing.T) {\n\t// Create a set of structs to test\n\ttype testStruct struct {\n\t\tmin, max int\n\t}\n\n\t// Create a set of test values\n\ttests := []testStruct{\n\t\t{0, 0},\n\t\t{1000, -1000},\n\t\t{minInt, maxInt},\n\t\t{minInt, minInt + 100}, // Test min\n\t\t{maxInt - 100, maxInt}, // Test max\n\t\t{maxInt - 20000, maxInt - 10000},\n\t\t{minInt + 10000, maxInt - 10000},\n\t}\n\n\t// Add 10000 random values to the test set\n\tfor i := 0; i < 5000; i++ {\n\t\ttests = append(tests, testStruct{\n\t\t\tmin: randIntRange(GlobalFaker, 0, maxInt),\n\t\t\tmax: randIntRange(GlobalFaker, 0, maxInt),\n\t\t})\n\t}\n\tfor i := 0; i < 5000; i++ {\n\t\ttests = append(tests, testStruct{\n\t\t\tmin: randIntRange(GlobalFaker, minInt, 0),\n\t\t\tmax: randIntRange(GlobalFaker, 0, maxInt),\n\t\t})\n\t}\n\n\t// Loop through the tests\n\tfor _, test := range tests {\n\t\t// Get the result\n\t\tresult := randIntRange(GlobalFaker, test.min, test.max)\n\n\t\t// Check the result\n\t\tif test.min > test.max {\n\t\t\t// Test if min is greater than max by reversing the check\n\t\t\tif result > test.min && result < test.max {\n\t\t\t\tt.Fatalf(\"The result should be between %d and %d. Got: %d\", test.min, test.max, result)\n\t\t\t}\n\t\t} else if result < test.min || result > test.max {\n\t\t\tt.Fatalf(\"The result should be between %d and %d. Got: %d\", test.min, test.max, result)\n\t\t}\n\t}\n}\n\n// Test taking in two random uint values and making sure the output is within the range\nfunc TestRandUintRange(t *testing.T) {\n\t// Create a set of structs to test\n\ttype testStruct struct {\n\t\tmin, max uint\n\t}\n\n\t// Create a set of test values\n\ttests := []testStruct{\n\t\t{0, 0},\n\t\t{100000, 100},\n\t\t{minUint, maxUint},\n\t\t{minUint + 10000, maxUint - 10000},\n\t}\n\n\t// Add 10000 random values to the test set\n\tfor i := 0; i < 5000; i++ {\n\t\ttests = append(tests, testStruct{\n\t\t\tmin: randUintRange(GlobalFaker, 0, maxUint),\n\t\t\tmax: randUintRange(GlobalFaker, 0, maxUint),\n\t\t})\n\t}\n\tfor i := 0; i < 5000; i++ {\n\t\ttests = append(tests, testStruct{\n\t\t\tmin: randUintRange(GlobalFaker, 0, maxUint/2),\n\t\t\tmax: randUintRange(GlobalFaker, maxUint/2, maxUint),\n\t\t})\n\t}\n\n\t// Loop through the tests\n\tfor _, test := range tests {\n\t\t// Get the result\n\t\tresult := randUintRange(GlobalFaker, test.min, test.max)\n\n\t\t// Check the result\n\t\tif test.min > test.max {\n\t\t\t// Test if min is greater than max by reversing the check\n\t\t\tif result > test.min && result < test.max {\n\t\t\t\tt.Fatalf(\"The result should be between %d and %d. Got: %d\", test.min, test.max, result)\n\t\t\t}\n\t\t} else if result < test.min || result > test.max {\n\t\t\tt.Fatalf(\"The result should be between %d and %d. Got: %d\", test.min, test.max, result)\n\t\t}\n\t}\n}\n\nfunc TestGetRandValueFail(t *testing.T) {\n\tfor _, test := range [][]string{nil, {}, {\"not\", \"found\"}, {\"person\", \"notfound\"}} {\n\t\tif getRandValue(GlobalFaker, test) != \"\" {\n\t\t\tt.Error(\"You should have gotten no value back\")\n\t\t}\n\t}\n}\n\nfunc TestReplaceWithNumbers(t *testing.T) {\n\tif replaceWithNumbers(GlobalFaker, \"\") != \"\" {\n\t\tt.Error(\"You should have gotten an empty string\")\n\t}\n}\n\nfunc BenchmarkReplaceWithNumbers(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tSeed(11)\n\t\treplaceWithNumbers(GlobalFaker, \"###☺#☻##☹##\")\n\t}\n}\n\nfunc TestReplaceWithNumbersUnicode(t *testing.T) {\n\tfor _, test := range []struct{ in string }{\n\t\t{\"#界#世#\"},\n\t\t{\"☺#☻☹#\"},\n\t\t{\"\\x80#¼#語\"},\n\t} {\n\t\tSeed(11)\n\t\tgot := replaceWithNumbers(GlobalFaker, test.in)\n\t\tif got == test.in {\n\t\t\tt.Errorf(\"got %q, want something different\", got)\n\t\t}\n\n\t\t// Check that # were replaced with numbers\n\t\tfor _, r := range got {\n\t\t\tif r == '#' {\n\t\t\t\tt.Errorf(\"got %q, want something different\", got)\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc TestReplaceWithLetters(t *testing.T) {\n\tif replaceWithLetters(GlobalFaker, \"\") != \"\" {\n\t\tt.Error(\"You should have gotten an empty string\")\n\t}\n}\n\nfunc TestReplaceWithHexLetters(t *testing.T) {\n\tif replaceWithHexLetters(GlobalFaker, \"\") != \"\" {\n\t\tt.Error(\"You should have gotten an empty string\")\n\t}\n}\n\nfunc TestToFixed(t *testing.T) {\n\tfloats := [][]float64{\n\t\t{123.1234567489, 123.123456},\n\t\t{987.987654321, 987.987654},\n\t}\n\n\tfor _, f := range floats {\n\t\tif toFixed(f[0], 6) != f[1] {\n\t\t\tt.Fatalf(\"%g did not equal %g. Got: %g\", f[0], f[1], toFixed(f[0], 6))\n\t\t}\n\t}\n}\n\nfunc TestEqualSlice(t *testing.T) {\n\t// String Array\n\tif equalSliceString([]string{\"a\", \"b\"}, []string{\"a\"}) {\n\t\tt.Fatalf(\"Should have returned false because the string array are not the same\")\n\t}\n\tif equalSliceString([]string{\"a\", \"b\"}, []string{\"c\", \"d\"}) {\n\t\tt.Fatalf(\"Should have returned false because the string array are not the same\")\n\t}\n\tif !equalSliceString([]string{\"a\", \"b\"}, []string{\"a\", \"b\"}) {\n\t\tt.Fatalf(\"Should have returned true because the string array are the same\")\n\t}\n\n\t// Int Array\n\tif equalSliceInt([]int{1, 2}, []int{1}) {\n\t\tt.Fatalf(\"Should have returned false because the int array are not the same\")\n\t}\n\tif equalSliceInt([]int{1, 2}, []int{3, 4}) {\n\t\tt.Fatalf(\"Should have returned false because the int array are not the same\")\n\t}\n\tif !equalSliceInt([]int{1, 2}, []int{1, 2}) {\n\t\tt.Fatalf(\"Should have returned true because the int array are the same\")\n\t}\n\n\t// Interface Array\n\tif equalSliceInterface([]any{1, \"b\"}, []any{1}) {\n\t\tt.Fatalf(\"Should have returned false because the interface array are not the same\")\n\t}\n\tif equalSliceInterface([]any{1, \"b\"}, []any{3, \"d\"}) {\n\t\tt.Fatalf(\"Should have returned false because the interface array are not the same\")\n\t}\n\tif !equalSliceInterface([]any{1, \"b\", []int{1, 2}, []string{\"a\", \"b\"}}, []any{1, \"b\", []int{1, 2}, []string{\"a\", \"b\"}}) {\n\t\tt.Fatalf(\"Should have returned true because the ints array are the same\")\n\t}\n}\n\nfunc TestStringInSlice(t *testing.T) {\n\tif stringInSlice(\"c\", []string{\"a\", \"b\"}) {\n\t\tt.Fatalf(\"Should have returned true because the string is in the slice\")\n\t}\n\tif !stringInSlice(\"a\", []string{\"a\", \"b\", \"c\"}) {\n\t\tt.Fatalf(\"Should have returned true because the string is in the slice\")\n\t}\n}\n\nfunc TestAnyToString(t *testing.T) {\n\ttests := []struct {\n\t\tinput any\n\t\twant  string\n\t}{\n\t\t{input: 42, want: \"42\"},\n\t\t{input: \"Hello, Go!\", want: \"Hello, Go!\"},\n\t\t{input: 3.14, want: \"3.14\"},\n\t\t{input: true, want: \"true\"},\n\t\t{input: struct{ Name string }{Name: \"John\"}, want: `{\"Name\":\"John\"}`},\n\t\t{input: []int{1, 2, 3}, want: \"[1,2,3]\"},\n\t\t{input: map[string]int{\"a\": 1, \"b\": 2}, want: `{\"a\":1,\"b\":2}`},\n\t\t{input: []byte(\"hello world\"), want: \"hello world\"},\n\t\t{input: nil, want: \"\"},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(fmt.Sprintf(\"Input: %v\", test.input), func(t *testing.T) {\n\t\t\tgot := anyToString(test.input)\n\n\t\t\tif got != test.want {\n\t\t\t\tt.Errorf(\"got %v, want %v\", got, test.want)\n\t\t\t}\n\t\t})\n\t}\n\n\t// Additional tests for edge cases\n\tt.Run(\"Edge case: empty byte slice\", func(t *testing.T) {\n\t\temptyByteSlice := []byte{}\n\t\tgot := anyToString(emptyByteSlice)\n\t\twant := \"\"\n\n\t\tif got != want {\n\t\t\tt.Errorf(\"got %v, want %v\", got, want)\n\t\t}\n\t})\n}\n\nfunc TestAnyToStringEdgeCases(t *testing.T) {\n\t// Additional tests for edge cases\n\n\t// Test with a struct containing an unexported field\n\ttype unexportedFieldStruct struct {\n\t\tunexportedField int\n\t\tExportedField   string\n\t}\n\tunexportedStruct := unexportedFieldStruct{unexportedField: 42, ExportedField: \"Hello\"}\n\twant := `{\"ExportedField\":\"Hello\"}`\n\tgot := anyToString(unexportedStruct)\n\tif got != want {\n\t\tt.Errorf(\"got %v, want %v\", got, want)\n\t}\n\n\t// Test with a struct containing a nil interface field\n\ttype nilInterfaceFieldStruct struct {\n\t\tData any\n\t}\n\tnilInterfaceStruct := nilInterfaceFieldStruct{}\n\twant = `{\"Data\":null}`\n\tgot = anyToString(nilInterfaceStruct)\n\tif got != want {\n\t\tt.Errorf(\"got %v, want %v\", got, want)\n\t}\n}\n\nfunc TestTitle(t *testing.T) {\n\ttest := map[string]string{\n\t\t\"\":                     \"\",\n\t\t\"i have a best friend\": \"I Have A Best Friend\",\n\t\t\"this is a test\":       \"This Is A Test\",\n\t\t\"I am 36 years old\":    \"I Am 36 Years Old\",\n\t\t\"whats_up\":             \"Whats_up\",\n\t}\n\n\tfor in, out := range test {\n\t\tif title(in) != out {\n\t\t\tt.Fatalf(\"%s did not equal %s. Got: %s\", in, out, title(in))\n\t\t}\n\t}\n}\n\nfunc TestFuncLookupSplit(t *testing.T) {\n\ttests := map[string][]string{\n\t\t\"\":                  {},\n\t\t\"a\":                 {\"a\"},\n\t\t\"a,b,c\":             {\"a\", \"b\", \"c\"},\n\t\t\"a, b, c\":           {\"a\", \"b\", \"c\"},\n\t\t\"[a,b,c]\":           {\"[a,b,c]\"},\n\t\t\"a,[1,2,3],b\":       {\"a\", \"[1,2,3]\", \"b\"},\n\t\t\"[1,2,3],a,[1,2,3]\": {\"[1,2,3]\", \"a\", \"[1,2,3]\"},\n\t}\n\n\tfor input, expected := range tests {\n\t\tvalues, err := funcLookupSplit(input)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"unexpected error: %v\", err)\n\t\t}\n\t\tif len(values) != len(expected) {\n\t\t\tt.Fatalf(\"%s was not %s\", values, expected)\n\t\t}\n\t\tfor i := 0; i < len(values); i++ {\n\t\t\tif values[i] != expected[i] {\n\t\t\t\tt.Fatalf(\"expected %s got %s\", expected[i], values[i])\n\t\t\t}\n\t\t}\n\t}\n}\n"
        },
        {
          "name": "hipster.go",
          "type": "blob",
          "size": 6.1591796875,
          "content": "package gofakeit\n\nimport (\n\t\"errors\"\n)\n\n// HipsterWord will return a single hipster word\nfunc HipsterWord() string { return hipsterWord(GlobalFaker) }\n\n// HipsterWord will return a single hipster word\nfunc (f *Faker) HipsterWord() string { return hipsterWord(f) }\n\nfunc hipsterWord(f *Faker) string { return getRandValue(f, []string{\"hipster\", \"word\"}) }\n\n// HipsterSentence will generate a random sentence\nfunc HipsterSentence(wordCount int) string { return hipsterSentence(GlobalFaker, wordCount) }\n\n// HipsterSentence will generate a random sentence\nfunc (f *Faker) HipsterSentence(wordCount int) string { return hipsterSentence(f, wordCount) }\n\nfunc hipsterSentence(f *Faker, wordCount int) string {\n\treturn sentenceGen(f, wordCount, hipsterWord)\n}\n\n// HipsterParagraph will generate a random paragraphGenerator\n// Set Paragraph Count\n// Set Sentence Count\n// Set Word Count\n// Set Paragraph Separator\nfunc HipsterParagraph(paragraphCount int, sentenceCount int, wordCount int, separator string) string {\n\treturn hipsterParagraph(GlobalFaker, paragraphCount, sentenceCount, wordCount, separator)\n}\n\n// HipsterParagraph will generate a random paragraphGenerator\n// Set Paragraph Count\n// Set Sentence Count\n// Set Word Count\n// Set Paragraph Separator\nfunc (f *Faker) HipsterParagraph(paragraphCount int, sentenceCount int, wordCount int, separator string) string {\n\treturn hipsterParagraph(f, paragraphCount, sentenceCount, wordCount, separator)\n}\n\nfunc hipsterParagraph(f *Faker, paragraphCount int, sentenceCount int, wordCount int, separator string) string {\n\treturn paragraphGen(f, paragrapOptions{paragraphCount, sentenceCount, wordCount, separator}, hipsterSentence)\n}\n\nfunc addHipsterLookup() {\n\tAddFuncLookup(\"hipsterword\", Info{\n\t\tDisplay:     \"Hipster Word\",\n\t\tCategory:    \"hipster\",\n\t\tDescription: \"Trendy and unconventional vocabulary used by hipsters to express unique cultural preferences\",\n\t\tExample:     \"microdosing\",\n\t\tOutput:      \"string\",\n\t\tGenerate: func(f *Faker, m *MapParams, info *Info) (any, error) {\n\t\t\treturn hipsterWord(f), nil\n\t\t},\n\t})\n\n\tAddFuncLookup(\"hipstersentence\", Info{\n\t\tDisplay:     \"Hipster Sentence\",\n\t\tCategory:    \"hipster\",\n\t\tDescription: \"Sentence showcasing the use of trendy and unconventional vocabulary associated with hipster culture\",\n\t\tExample:     \"Microdosing roof chia echo pickled.\",\n\t\tOutput:      \"string\",\n\t\tParams: []Param{\n\t\t\t{Field: \"wordcount\", Display: \"Word Count\", Type: \"int\", Default: \"5\", Description: \"Number of words in a sentence\"},\n\t\t},\n\t\tGenerate: func(f *Faker, m *MapParams, info *Info) (any, error) {\n\t\t\twordCount, err := info.GetInt(m, \"wordcount\")\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\tif wordCount <= 0 || wordCount > 50 {\n\t\t\t\treturn nil, errors.New(\"invalid word count, must be greater than 0, less than 50\")\n\t\t\t}\n\n\t\t\treturn hipsterSentence(f, wordCount), nil\n\t\t},\n\t})\n\n\tAddFuncLookup(\"hipsterparagraph\", Info{\n\t\tDisplay:     \"Hipster Paragraph\",\n\t\tCategory:    \"hipster\",\n\t\tDescription: \"Paragraph showcasing the use of trendy and unconventional vocabulary associated with hipster culture\",\n\t\tExample: `Microdosing roof chia echo pickled meditation cold-pressed raw denim fingerstache normcore sriracha pork belly. Wolf try-hard pop-up blog tilde hashtag health butcher waistcoat paleo portland vinegar. Microdosing sartorial blue bottle slow-carb freegan five dollar toast you probably haven't heard of them asymmetrical chia farm-to-table narwhal banjo. Gluten-free blog authentic literally synth vinyl meh ethical health fixie banh mi Yuccie. Try-hard drinking squid seitan cray VHS echo chillwave hammock kombucha food truck sustainable.\n\nPug bushwick hella tote bag cliche direct trade waistcoat yr waistcoat knausgaard pour-over master. Pitchfork jean shorts franzen flexitarian distillery hella meggings austin knausgaard crucifix wolf heirloom. Crucifix food truck you probably haven't heard of them trust fund fixie gentrify pitchfork stumptown mlkshk umami chambray blue bottle. 3 wolf moon swag +1 biodiesel knausgaard semiotics taxidermy meh artisan hoodie +1 blue bottle. Fashion axe forage mixtape Thundercats pork belly whatever 90's beard selfies chambray cred mlkshk.\n\nShabby chic typewriter VHS readymade lo-fi bitters PBR&B gentrify lomo raw denim freegan put a bird on it. Raw denim cliche dreamcatcher pug fixie park trust fund migas fingerstache sriracha +1 mustache. Tilde shoreditch kickstarter franzen dreamcatcher green juice mustache neutra polaroid stumptown organic schlitz. Flexitarian ramps chicharrones kogi lo-fi mustache tilde forage street church-key williamsburg taxidermy. Chia mustache plaid mumblecore squid slow-carb disrupt Thundercats goth shoreditch master direct trade.`,\n\t\tOutput: \"string\",\n\t\tParams: []Param{\n\t\t\t{Field: \"paragraphcount\", Display: \"Paragraph Count\", Type: \"int\", Default: \"2\", Description: \"Number of paragraphs\"},\n\t\t\t{Field: \"sentencecount\", Display: \"Sentence Count\", Type: \"int\", Default: \"2\", Description: \"Number of sentences in a paragraph\"},\n\t\t\t{Field: \"wordcount\", Display: \"Word Count\", Type: \"int\", Default: \"5\", Description: \"Number of words in a sentence\"},\n\t\t\t{Field: \"paragraphseparator\", Display: \"Paragraph Separator\", Type: \"string\", Default: \"<br />\", Description: \"String value to add between paragraphs\"},\n\t\t},\n\t\tGenerate: func(f *Faker, m *MapParams, info *Info) (any, error) {\n\t\t\tparagraphCount, err := info.GetInt(m, \"paragraphcount\")\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\tif paragraphCount <= 0 || paragraphCount > 20 {\n\t\t\t\treturn nil, errors.New(\"invalid paragraph count, must be greater than 0, less than 20\")\n\t\t\t}\n\n\t\t\tsentenceCount, err := info.GetInt(m, \"sentencecount\")\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\tif sentenceCount <= 0 || sentenceCount > 20 {\n\t\t\t\treturn nil, errors.New(\"invalid sentence count, must be greater than 0, less than 20\")\n\t\t\t}\n\n\t\t\twordCount, err := info.GetInt(m, \"wordcount\")\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\tif wordCount <= 0 || wordCount > 50 {\n\t\t\t\treturn nil, errors.New(\"invalid word count, must be greater than 0, less than 50\")\n\t\t\t}\n\n\t\t\tparagraphSeparator, err := info.GetString(m, \"paragraphseparator\")\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\n\t\t\treturn hipsterParagraph(f, paragraphCount, sentenceCount, wordCount, paragraphSeparator), nil\n\t\t},\n\t})\n}\n"
        },
        {
          "name": "hipster_test.go",
          "type": "blob",
          "size": 4.2255859375,
          "content": "package gofakeit\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc ExampleHipsterWord() {\n\tSeed(11)\n\tfmt.Println(HipsterWord())\n\n\t// Output: semiotics\n}\n\nfunc ExampleFaker_HipsterWord() {\n\tf := New(11)\n\tfmt.Println(f.HipsterWord())\n\n\t// Output: semiotics\n}\n\nfunc BenchmarkHipsterWord(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tHipsterWord()\n\t}\n}\n\nfunc ExampleHipsterSentence() {\n\tSeed(11)\n\tfmt.Println(HipsterSentence(5))\n\n\t// Output: Semiotics everyday you probably haven't heard of them you probably haven't heard of them portland.\n}\n\nfunc ExampleFaker_HipsterSentence() {\n\tf := New(11)\n\tfmt.Println(f.HipsterSentence(5))\n\n\t// Output: Semiotics everyday you probably haven't heard of them you probably haven't heard of them portland.\n}\n\nfunc BenchmarkHipsterSentence(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tHipsterSentence(10)\n\t}\n}\n\nfunc ExampleHipsterParagraph() {\n\tSeed(11)\n\tfmt.Println(HipsterParagraph(3, 5, 12, \"\\n\"))\n\n\t// Output: Semiotics everyday you probably haven't heard of them you probably haven't heard of them portland austin tattooed retro cardigan Yuccie cred hoodie. Vice pug pug cred intelligentsia roof helvetica squid chambray literally ennui ugh. Chicharrones messenger bag narwhal ennui flannel twee art party mustache sartorial gluten-free cardigan cronut. Hoodie kickstarter cardigan Thundercats heirloom hashtag bitters salvia cleanse forage chartreuse keffiyeh. Sustainable tofu mustache bespoke vice aesthetic iPhone ugh lo-fi health put a bird on it blue bottle.\n\t// Pop-up pabst pitchfork literally roof tattooed tilde shoreditch green juice ethical celiac tilde. Kombucha kinfolk occupy tacos ramps 90's echo meditation kale chips gluten-free humblebrag keffiyeh. Lo-fi bespoke wayfarers chicharrones crucifix green juice humblebrag organic viral shabby chic locavore cred. Roof forage farm-to-table YOLO williamsburg crucifix blog everyday green juice listicle wayfarers post-ironic. Single-origin coffee cray organic YOLO disrupt venmo tofu meggings fanny pack master craft beer tofu.\n\t// Hella helvetica microdosing literally meh etsy echo pabst goth readymade +1 marfa. Pork belly hammock kale chips yr green juice stumptown crucifix hella pork belly franzen wolf austin. Offal cred chartreuse freegan intelligentsia twee trust fund paleo pinterest austin typewriter kogi. Pug single-origin coffee ethical irony helvetica beard green juice viral post-ironic Godard slow-carb put a bird on it. Schlitz hammock beard chia kitsch cred salvia irony farm-to-table loko truffaut ramps.\n}\n\nfunc ExampleFaker_HipsterParagraph() {\n\tf := New(11)\n\tfmt.Println(f.HipsterParagraph(3, 5, 12, \"\\n\"))\n\n\t// Output: Semiotics everyday you probably haven't heard of them you probably haven't heard of them portland austin tattooed retro cardigan Yuccie cred hoodie. Vice pug pug cred intelligentsia roof helvetica squid chambray literally ennui ugh. Chicharrones messenger bag narwhal ennui flannel twee art party mustache sartorial gluten-free cardigan cronut. Hoodie kickstarter cardigan Thundercats heirloom hashtag bitters salvia cleanse forage chartreuse keffiyeh. Sustainable tofu mustache bespoke vice aesthetic iPhone ugh lo-fi health put a bird on it blue bottle.\n\t// Pop-up pabst pitchfork literally roof tattooed tilde shoreditch green juice ethical celiac tilde. Kombucha kinfolk occupy tacos ramps 90's echo meditation kale chips gluten-free humblebrag keffiyeh. Lo-fi bespoke wayfarers chicharrones crucifix green juice humblebrag organic viral shabby chic locavore cred. Roof forage farm-to-table YOLO williamsburg crucifix blog everyday green juice listicle wayfarers post-ironic. Single-origin coffee cray organic YOLO disrupt venmo tofu meggings fanny pack master craft beer tofu.\n\t// Hella helvetica microdosing literally meh etsy echo pabst goth readymade +1 marfa. Pork belly hammock kale chips yr green juice stumptown crucifix hella pork belly franzen wolf austin. Offal cred chartreuse freegan intelligentsia twee trust fund paleo pinterest austin typewriter kogi. Pug single-origin coffee ethical irony helvetica beard green juice viral post-ironic Godard slow-carb put a bird on it. Schlitz hammock beard chia kitsch cred salvia irony farm-to-table loko truffaut ramps.\n}\n\nfunc BenchmarkHipsterParagraph(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tHipsterParagraph(3, 5, 12, \"\\n\")\n\t}\n}\n"
        },
        {
          "name": "html.go",
          "type": "blob",
          "size": 6.3916015625,
          "content": "package gofakeit\n\nimport (\n\t\"errors\"\n\t\"strconv\"\n\t\"strings\"\n\n\t\"github.com/brianvoe/gofakeit/v7/data\"\n)\n\n// InputName will return a random input field name\nfunc InputName() string {\n\treturn inputName(GlobalFaker)\n}\n\n// InputName will return a random input field name\nfunc (f *Faker) InputName() string {\n\treturn inputName(f)\n}\n\nfunc inputName(f *Faker) string {\n\treturn getRandValue(f, []string{\"html\", \"input_name\"})\n}\n\ntype SVGOptions struct {\n\tHeight int\n\tWidth  int\n\tType   string\n\tColors []string\n}\n\n// Generate a random svg generator\nfunc Svg(options *SVGOptions) string { return svg(GlobalFaker, options) }\n\n// Generate a random svg generator\nfunc (f *Faker) Svg(options *SVGOptions) string { return svg(f, options) }\n\nfunc svg(f *Faker, options *SVGOptions) string {\n\t// If options is nil, set it to empty struct\n\tif options == nil {\n\t\toptions = &SVGOptions{}\n\t}\n\n\t// If options height and weight is not set, set it to random number between 100 and 500\n\tif options.Width == 0 {\n\t\toptions.Width = number(f, 100, 500)\n\t}\n\twidthStr := strconv.Itoa(options.Width)\n\tif options.Height == 0 {\n\t\toptions.Height = number(f, 100, 500)\n\t}\n\theightStr := strconv.Itoa(options.Height)\n\n\t// Check if type is set, if not set to random type\n\tif options.Type == \"\" {\n\t\toptions.Type = randomString(f, data.GetSubData(\"html\", \"svg\"))\n\t}\n\n\t// If the colors are not set, set it to a set of nice colors\n\tif len(options.Colors) == 0 {\n\t\toptions.Colors = niceColors(f)\n\t}\n\n\t// Start svg string\n\tsvgStr := `<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 ` + widthStr + ` ` + heightStr + `\" width=\"` + widthStr + `\" height=\"` + heightStr + `\">`\n\n\t// Add a rect for the background\n\tsvgStr += `<rect x=\"0\" y=\"0\" width=\"100%\" height=\"100%\" fill=\"` + randomString(f, options.Colors) + `\" />`\n\n\t// Add a random number of shapes\n\tfor i := 0; i < number(f, 10, 20); i++ {\n\t\t// Add a random shape\n\t\tswitch options.Type {\n\t\tcase \"rect\":\n\t\t\tsvgStr += `<rect x=\"` + strconv.Itoa(number(f, 0, options.Width)) + `\" y=\"` + strconv.Itoa(number(f, 0, options.Height)) + `\" width=\"` + strconv.Itoa(number(f, 0, options.Width)) + `\" height=\"` + strconv.Itoa(number(f, 0, options.Height)) + `\" fill=\"` + randomString(f, options.Colors) + `\" />`\n\t\tcase \"circle\":\n\t\t\tsvgStr += `<circle cx=\"` + strconv.Itoa(number(f, 0, options.Width)) + `\" cy=\"` + strconv.Itoa(number(f, 0, options.Height)) + `\" r=\"` + strconv.Itoa(number(f, 0, options.Width)) + `\" fill=\"` + randomString(f, options.Colors) + `\" />`\n\t\tcase \"ellipse\":\n\t\t\tsvgStr += `<ellipse cx=\"` + strconv.Itoa(number(f, 0, options.Width)) + `\" cy=\"` + strconv.Itoa(number(f, 0, options.Height)) + `\" rx=\"` + strconv.Itoa(number(f, 0, options.Width)) + `\" ry=\"` + strconv.Itoa(number(f, 0, options.Height)) + `\" fill=\"` + randomString(f, options.Colors) + `\" />`\n\t\tcase \"line\":\n\t\t\tsvgStr += `<line x1=\"` + strconv.Itoa(number(f, 0, options.Width)) + `\" y1=\"` + strconv.Itoa(number(f, 0, options.Height)) + `\" x2=\"` + strconv.Itoa(number(f, 0, options.Width)) + `\" y2=\"` + strconv.Itoa(number(f, 0, options.Height)) + `\" stroke=\"` + randomString(f, options.Colors) + `\" />`\n\t\tcase \"polyline\":\n\t\t\tsvgStr += `<polyline points=\"` + strconv.Itoa(number(f, 0, options.Width)) + `,` + strconv.Itoa(number(f, 0, options.Height)) + ` ` + strconv.Itoa(number(f, 0, options.Width)) + `,` + strconv.Itoa(number(f, 0, options.Height)) + ` ` + strconv.Itoa(number(f, 0, options.Width)) + `,` + strconv.Itoa(number(f, 0, options.Height)) + `\" fill=\"` + randomString(f, options.Colors) + `\" />`\n\t\tcase \"polygon\":\n\t\t\tsvgStr += `<polygon points=\"` + strconv.Itoa(number(f, 0, options.Width)) + `,` + strconv.Itoa(number(f, 0, options.Height)) + ` ` + strconv.Itoa(number(f, 0, options.Width)) + `,` + strconv.Itoa(number(f, 0, options.Height)) + ` ` + strconv.Itoa(number(f, 0, options.Width)) + `,` + strconv.Itoa(number(f, 0, options.Height)) + `\" fill=\"` + randomString(f, options.Colors) + `\" />`\n\t\t}\n\t}\n\n\t// End svg string\n\tsvgStr += `</svg>`\n\n\treturn svgStr\n}\n\nfunc addHtmlLookup() {\n\tAddFuncLookup(\"inputname\", Info{\n\t\tDisplay:     \"Input Name\",\n\t\tCategory:    \"html\",\n\t\tDescription: \"Attribute used to define the name of an input element in web forms\",\n\t\tExample:     \"first_name\",\n\t\tOutput:      \"string\",\n\t\tGenerate: func(f *Faker, m *MapParams, info *Info) (any, error) {\n\t\t\treturn inputName(f), nil\n\t\t},\n\t})\n\n\tAddFuncLookup(\"svg\", Info{\n\t\tDisplay:     \"Image SVG\",\n\t\tCategory:    \"html\",\n\t\tDescription: \"Scalable Vector Graphics used to display vector images in web content\",\n\t\tExample: `<svg width=\"369\" height=\"289\">\n\t<rect fill=\"#4f2958\" />\n\t<polygon points=\"382,87 418,212 415,110\" fill=\"#fffbb7\" />\n</svg>`,\n\t\tOutput:      \"string\",\n\t\tContentType: \"image/svg+xml\",\n\t\tParams: []Param{\n\t\t\t{Field: \"width\", Display: \"Width\", Type: \"int\", Default: \"500\", Description: \"Width in px\"},\n\t\t\t{Field: \"height\", Display: \"Height\", Type: \"int\", Default: \"500\", Description: \"Height in px\"},\n\t\t\t{Field: \"type\", Display: \"Type\", Type: \"string\", Optional: true, Options: data.GetSubData(\"html\", \"svg\"), Description: \"Sub child element type\"},\n\t\t\t{Field: \"colors\", Display: \"Colors\", Type: \"[]string\", Optional: true, Description: \"Hex or RGB array of colors to use\"},\n\t\t},\n\t\tGenerate: func(f *Faker, m *MapParams, info *Info) (any, error) {\n\t\t\t// Setup new options\n\t\t\toptions := SVGOptions{}\n\t\t\tvar err error\n\n\t\t\toptions.Width, err = info.GetInt(m, \"width\")\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\tif options.Width < 10 || options.Width >= 1000 {\n\t\t\t\treturn nil, errors.New(\"invalid image width, must be greater than 10, less than 1000\")\n\t\t\t}\n\n\t\t\toptions.Height, err = info.GetInt(m, \"height\")\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\tif options.Height < 10 || options.Height >= 1000 {\n\t\t\t\treturn nil, errors.New(\"invalid image height, must be greater than 10, less than 1000\")\n\t\t\t}\n\n\t\t\toptions.Type, err = info.GetString(m, \"type\")\n\t\t\tsvgData := data.GetSubData(\"html\", \"svg\")\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\n\t\t\t// If type is empty, set with random type\n\t\t\tif options.Type == \"\" {\n\t\t\t\toptions.Type = randomString(f, svgData)\n\t\t\t}\n\n\t\t\t// If not in date html svg type array, return error\n\t\t\tif !stringInSlice(options.Type, svgData) {\n\t\t\t\treturn nil, errors.New(\"invalid svg type, must be one of \" + strings.Join(svgData, \",\"))\n\t\t\t}\n\n\t\t\t// Get colors\n\t\t\toptions.Colors, err = info.GetStringArray(m, \"colors\")\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\n\t\t\t// If colors is empty, set with random colors\n\t\t\tif len(options.Colors) == 0 {\n\t\t\t\toptions.Colors = niceColors(f)\n\t\t\t}\n\n\t\t\treturn svg(f, &options), nil\n\t\t},\n\t})\n}\n"
        },
        {
          "name": "html_test.go",
          "type": "blob",
          "size": 2.9208984375,
          "content": "package gofakeit\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\t\"testing\"\n\n\t\"github.com/brianvoe/gofakeit/v7/data\"\n)\n\nfunc ExampleInputName() {\n\tSeed(11)\n\tfmt.Println(InputName())\n\n\t// Output: message\n}\n\nfunc ExampleFaker_InputName() {\n\tf := New(11)\n\tfmt.Println(f.InputName())\n\n\t// Output: message\n}\n\nfunc BenchmarkInputName(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tInputName()\n\t}\n}\n\nfunc TestSvg(t *testing.T) {\n\tSeed(11)\n\n\t// Loop through SvgTypes and set that type for each test\n\tvar SvgTypes = data.GetSubData(\"html\", \"svg\")\n\tfor _, svgType := range SvgTypes {\n\t\t// Run the test\n\t\tt.Run(svgType, func(t *testing.T) {\n\n\t\t\t// Get the image\n\t\t\timg := Svg(&SVGOptions{\n\t\t\t\tType: svgType,\n\t\t\t})\n\n\t\t\t// Check the image\n\t\t\tif img == \"\" {\n\t\t\t\tt.Error(\"Svg returned an empty string\")\n\t\t\t}\n\n\t\t\t// Check the image\n\t\t\tif !strings.Contains(img, svgType) {\n\t\t\t\tt.Errorf(\"Svg returned an image of type %s, but should have been %s\", svgType, svgType)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc ExampleSvg() {\n\tSeed(11)\n\tfmt.Println(Svg(nil))\n\n\t// Output: <svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 459 443\" width=\"459\" height=\"443\"><rect x=\"0\" y=\"0\" width=\"100%\" height=\"100%\" fill=\"#64908a\" /><circle cx=\"334\" cy=\"238\" r=\"437\" fill=\"#cc2a41\" /><circle cx=\"34\" cy=\"328\" r=\"428\" fill=\"#cc2a41\" /><circle cx=\"151\" cy=\"190\" r=\"191\" fill=\"#e8caa4\" /><circle cx=\"343\" cy=\"410\" r=\"156\" fill=\"#351330\" /><circle cx=\"5\" cy=\"410\" r=\"192\" fill=\"#351330\" /><circle cx=\"94\" cy=\"286\" r=\"384\" fill=\"#cc2a41\" /><circle cx=\"34\" cy=\"239\" r=\"439\" fill=\"#351330\" /><circle cx=\"199\" cy=\"310\" r=\"278\" fill=\"#cc2a41\" /><circle cx=\"293\" cy=\"106\" r=\"20\" fill=\"#64908a\" /><circle cx=\"275\" cy=\"327\" r=\"11\" fill=\"#cc2a41\" /><circle cx=\"406\" cy=\"338\" r=\"239\" fill=\"#e8caa4\" /><circle cx=\"41\" cy=\"71\" r=\"344\" fill=\"#64908a\" /><circle cx=\"411\" cy=\"116\" r=\"208\" fill=\"#64908a\" /><circle cx=\"410\" cy=\"88\" r=\"303\" fill=\"#351330\" /><circle cx=\"241\" cy=\"69\" r=\"285\" fill=\"#cc2a41\" /></svg>\n}\n\nfunc ExampleFaker_Svg() {\n\tf := New(11)\n\tfmt.Println(f.Svg(nil))\n\n\t// Output: <svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 459 443\" width=\"459\" height=\"443\"><rect x=\"0\" y=\"0\" width=\"100%\" height=\"100%\" fill=\"#64908a\" /><circle cx=\"334\" cy=\"238\" r=\"437\" fill=\"#cc2a41\" /><circle cx=\"34\" cy=\"328\" r=\"428\" fill=\"#cc2a41\" /><circle cx=\"151\" cy=\"190\" r=\"191\" fill=\"#e8caa4\" /><circle cx=\"343\" cy=\"410\" r=\"156\" fill=\"#351330\" /><circle cx=\"5\" cy=\"410\" r=\"192\" fill=\"#351330\" /><circle cx=\"94\" cy=\"286\" r=\"384\" fill=\"#cc2a41\" /><circle cx=\"34\" cy=\"239\" r=\"439\" fill=\"#351330\" /><circle cx=\"199\" cy=\"310\" r=\"278\" fill=\"#cc2a41\" /><circle cx=\"293\" cy=\"106\" r=\"20\" fill=\"#64908a\" /><circle cx=\"275\" cy=\"327\" r=\"11\" fill=\"#cc2a41\" /><circle cx=\"406\" cy=\"338\" r=\"239\" fill=\"#e8caa4\" /><circle cx=\"41\" cy=\"71\" r=\"344\" fill=\"#64908a\" /><circle cx=\"411\" cy=\"116\" r=\"208\" fill=\"#64908a\" /><circle cx=\"410\" cy=\"88\" r=\"303\" fill=\"#351330\" /><circle cx=\"241\" cy=\"69\" r=\"285\" fill=\"#cc2a41\" /></svg>\n}\n\nfunc BenchmarkSvg(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tSvg(nil)\n\t}\n}\n"
        },
        {
          "name": "image.go",
          "type": "blob",
          "size": 3.7021484375,
          "content": "package gofakeit\n\nimport (\n\t\"bytes\"\n\t\"errors\"\n\timg \"image\"\n\timgCol \"image/color\"\n\t\"image/jpeg\"\n\t\"image/png\"\n)\n\n// Image generates a random rgba image\nfunc Image(width int, height int) *img.RGBA { return image(GlobalFaker, width, height) }\n\n// Image generates a random rgba image\nfunc (f *Faker) Image(width int, height int) *img.RGBA { return image(f, width, height) }\n\nfunc image(f *Faker, width int, height int) *img.RGBA {\n\tupLeft := img.Point{0, 0}\n\tlowRight := img.Point{width, height}\n\n\timg := img.NewRGBA(img.Rectangle{upLeft, lowRight})\n\n\t// Set color for each pixel\n\tfor x := 0; x < width; x++ {\n\t\tfor y := 0; y < height; y++ {\n\t\t\timg.Set(x, y, imgCol.RGBA{uint8(number(f, 0, 255)), uint8(number(f, 0, 255)), uint8(number(f, 0, 255)), 0xff})\n\t\t}\n\t}\n\n\treturn img\n}\n\n// ImageJpeg generates a random rgba jpeg image\nfunc ImageJpeg(width int, height int) []byte { return imageJpeg(GlobalFaker, width, height) }\n\n// ImageJpeg generates a random rgba jpeg image\nfunc (f *Faker) ImageJpeg(width int, height int) []byte { return imageJpeg(f, width, height) }\n\nfunc imageJpeg(f *Faker, width int, height int) []byte {\n\tbuf := new(bytes.Buffer)\n\tjpeg.Encode(buf, image(f, width, height), nil)\n\treturn buf.Bytes()\n}\n\n// ImagePng generates a random rgba png image\nfunc ImagePng(width int, height int) []byte { return imagePng(GlobalFaker, width, height) }\n\n// ImagePng generates a random rgba png image\nfunc (f *Faker) ImagePng(width int, height int) []byte { return imagePng(f, width, height) }\n\nfunc imagePng(f *Faker, width int, height int) []byte {\n\tbuf := new(bytes.Buffer)\n\tpng.Encode(buf, image(f, width, height))\n\treturn buf.Bytes()\n}\n\nfunc addImageLookup() {\n\tAddFuncLookup(\"imagejpeg\", Info{\n\t\tDisplay:     \"Image JPEG\",\n\t\tCategory:    \"image\",\n\t\tDescription: \"Image file format known for its efficient compression and compatibility\",\n\t\tExample:     \"file.jpeg - bytes\",\n\t\tOutput:      \"[]byte\",\n\t\tContentType: \"image/jpeg\",\n\t\tParams: []Param{\n\t\t\t{Field: \"width\", Display: \"Width\", Type: \"int\", Default: \"500\", Description: \"Image width in px\"},\n\t\t\t{Field: \"height\", Display: \"Height\", Type: \"int\", Default: \"500\", Description: \"Image height in px\"},\n\t\t},\n\t\tGenerate: func(f *Faker, m *MapParams, info *Info) (any, error) {\n\t\t\twidth, err := info.GetInt(m, \"width\")\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\tif width < 10 || width >= 1000 {\n\t\t\t\treturn nil, errors.New(\"invalid image width, must be greater than 10, less than 1000\")\n\t\t\t}\n\n\t\t\theight, err := info.GetInt(m, \"height\")\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\tif height < 10 || height >= 1000 {\n\t\t\t\treturn nil, errors.New(\"invalid image height, must be greater than 10, less than 1000\")\n\t\t\t}\n\n\t\t\treturn imageJpeg(f, width, height), nil\n\t\t},\n\t})\n\n\tAddFuncLookup(\"imagepng\", Info{\n\t\tDisplay:     \"Image PNG\",\n\t\tCategory:    \"image\",\n\t\tDescription: \"Image file format known for its lossless compression and support for transparency\",\n\t\tExample:     \"file.png - bytes\",\n\t\tOutput:      \"[]byte\",\n\t\tContentType: \"image/png\",\n\t\tParams: []Param{\n\t\t\t{Field: \"width\", Display: \"Width\", Type: \"int\", Default: \"500\", Description: \"Image width in px\"},\n\t\t\t{Field: \"height\", Display: \"Height\", Type: \"int\", Default: \"500\", Description: \"Image height in px\"},\n\t\t},\n\t\tGenerate: func(f *Faker, m *MapParams, info *Info) (any, error) {\n\t\t\twidth, err := info.GetInt(m, \"width\")\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\tif width < 10 || width >= 1000 {\n\t\t\t\treturn nil, errors.New(\"invalid image width, must be greater than 10, less than 1000\")\n\t\t\t}\n\n\t\t\theight, err := info.GetInt(m, \"height\")\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\tif height < 10 || height >= 1000 {\n\t\t\t\treturn nil, errors.New(\"invalid image height, must be greater than 10, less than 1000\")\n\t\t\t}\n\n\t\t\treturn imagePng(f, width, height), nil\n\t\t},\n\t})\n}\n"
        },
        {
          "name": "image_test.go",
          "type": "blob",
          "size": 4.9404296875,
          "content": "package gofakeit\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc ExampleImage() {\n\tSeed(11)\n\tfmt.Println(Image(1, 1))\n\n\t// Output: &{[180 18 181 255] 4 (0,0)-(1,1)}\n}\n\nfunc ExampleFaker_Image() {\n\tf := New(11)\n\tfmt.Println(f.Image(1, 1))\n\n\t// Output: &{[180 18 181 255] 4 (0,0)-(1,1)}\n}\n\nfunc BenchmarkImage(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tImage(640, 480)\n\t}\n}\n\nfunc ExampleImageJpeg() {\n\tSeed(11)\n\tfmt.Println(ImageJpeg(1, 1))\n\n\t// Output: [255 216 255 219 0 132 0 8 6 6 7 6 5 8 7 7 7 9 9 8 10 12 20 13 12 11 11 12 25 18 19 15 20 29 26 31 30 29 26 28 28 32 36 46 39 32 34 44 35 28 28 40 55 41 44 48 49 52 52 52 31 39 57 61 56 50 60 46 51 52 50 1 9 9 9 12 11 12 24 13 13 24 50 33 28 33 50 50 50 50 50 50 50 50 50 50 50 50 50 50 50 50 50 50 50 50 50 50 50 50 50 50 50 50 50 50 50 50 50 50 50 50 50 50 50 50 50 50 50 50 50 50 50 50 50 50 255 192 0 17 8 0 1 0 1 3 1 34 0 2 17 1 3 17 1 255 196 1 162 0 0 1 5 1 1 1 1 1 1 0 0 0 0 0 0 0 0 1 2 3 4 5 6 7 8 9 10 11 16 0 2 1 3 3 2 4 3 5 5 4 4 0 0 1 125 1 2 3 0 4 17 5 18 33 49 65 6 19 81 97 7 34 113 20 50 129 145 161 8 35 66 177 193 21 82 209 240 36 51 98 114 130 9 10 22 23 24 25 26 37 38 39 40 41 42 52 53 54 55 56 57 58 67 68 69 70 71 72 73 74 83 84 85 86 87 88 89 90 99 100 101 102 103 104 105 106 115 116 117 118 119 120 121 122 131 132 133 134 135 136 137 138 146 147 148 149 150 151 152 153 154 162 163 164 165 166 167 168 169 170 178 179 180 181 182 183 184 185 186 194 195 196 197 198 199 200 201 202 210 211 212 213 214 215 216 217 218 225 226 227 228 229 230 231 232 233 234 241 242 243 244 245 246 247 248 249 250 1 0 3 1 1 1 1 1 1 1 1 1 0 0 0 0 0 0 1 2 3 4 5 6 7 8 9 10 11 17 0 2 1 2 4 4 3 4 7 5 4 4 0 1 2 119 0 1 2 3 17 4 5 33 49 6 18 65 81 7 97 113 19 34 50 129 8 20 66 145 161 177 193 9 35 51 82 240 21 98 114 209 10 22 36 52 225 37 241 23 24 25 26 38 39 40 41 42 53 54 55 56 57 58 67 68 69 70 71 72 73 74 83 84 85 86 87 88 89 90 99 100 101 102 103 104 105 106 115 116 117 118 119 120 121 122 130 131 132 133 134 135 136 137 138 146 147 148 149 150 151 152 153 154 162 163 164 165 166 167 168 169 170 178 179 180 181 182 183 184 185 186 194 195 196 197 198 199 200 201 202 210 211 212 213 214 215 216 217 218 226 227 228 229 230 231 232 233 234 242 243 244 245 246 247 248 249 250 255 218 0 12 3 1 0 2 17 3 17 0 63 0 229 40 162 138 251 3 239 15 255 217]\n}\n\nfunc ExampleFaker_ImageJpeg() {\n\tf := New(11)\n\tfmt.Println(f.ImageJpeg(1, 1))\n\n\t// Output: [255 216 255 219 0 132 0 8 6 6 7 6 5 8 7 7 7 9 9 8 10 12 20 13 12 11 11 12 25 18 19 15 20 29 26 31 30 29 26 28 28 32 36 46 39 32 34 44 35 28 28 40 55 41 44 48 49 52 52 52 31 39 57 61 56 50 60 46 51 52 50 1 9 9 9 12 11 12 24 13 13 24 50 33 28 33 50 50 50 50 50 50 50 50 50 50 50 50 50 50 50 50 50 50 50 50 50 50 50 50 50 50 50 50 50 50 50 50 50 50 50 50 50 50 50 50 50 50 50 50 50 50 50 50 50 50 255 192 0 17 8 0 1 0 1 3 1 34 0 2 17 1 3 17 1 255 196 1 162 0 0 1 5 1 1 1 1 1 1 0 0 0 0 0 0 0 0 1 2 3 4 5 6 7 8 9 10 11 16 0 2 1 3 3 2 4 3 5 5 4 4 0 0 1 125 1 2 3 0 4 17 5 18 33 49 65 6 19 81 97 7 34 113 20 50 129 145 161 8 35 66 177 193 21 82 209 240 36 51 98 114 130 9 10 22 23 24 25 26 37 38 39 40 41 42 52 53 54 55 56 57 58 67 68 69 70 71 72 73 74 83 84 85 86 87 88 89 90 99 100 101 102 103 104 105 106 115 116 117 118 119 120 121 122 131 132 133 134 135 136 137 138 146 147 148 149 150 151 152 153 154 162 163 164 165 166 167 168 169 170 178 179 180 181 182 183 184 185 186 194 195 196 197 198 199 200 201 202 210 211 212 213 214 215 216 217 218 225 226 227 228 229 230 231 232 233 234 241 242 243 244 245 246 247 248 249 250 1 0 3 1 1 1 1 1 1 1 1 1 0 0 0 0 0 0 1 2 3 4 5 6 7 8 9 10 11 17 0 2 1 2 4 4 3 4 7 5 4 4 0 1 2 119 0 1 2 3 17 4 5 33 49 6 18 65 81 7 97 113 19 34 50 129 8 20 66 145 161 177 193 9 35 51 82 240 21 98 114 209 10 22 36 52 225 37 241 23 24 25 26 38 39 40 41 42 53 54 55 56 57 58 67 68 69 70 71 72 73 74 83 84 85 86 87 88 89 90 99 100 101 102 103 104 105 106 115 116 117 118 119 120 121 122 130 131 132 133 134 135 136 137 138 146 147 148 149 150 151 152 153 154 162 163 164 165 166 167 168 169 170 178 179 180 181 182 183 184 185 186 194 195 196 197 198 199 200 201 202 210 211 212 213 214 215 216 217 218 226 227 228 229 230 231 232 233 234 242 243 244 245 246 247 248 249 250 255 218 0 12 3 1 0 2 17 3 17 0 63 0 229 40 162 138 251 3 239 15 255 217]\n}\n\nfunc BenchmarkImageJpeg(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tImageJpeg(640, 480)\n\t}\n}\n\nfunc ExampleImagePng() {\n\tSeed(11)\n\tfmt.Println(ImagePng(1, 1))\n\n\t// Output: [137 80 78 71 13 10 26 10 0 0 0 13 73 72 68 82 0 0 0 1 0 0 0 1 8 2 0 0 0 144 119 83 222 0 0 0 16 73 68 65 84 120 156 98 218 34 180 21 16 0 0 255 255 3 1 1 126 242 54 123 184 0 0 0 0 73 69 78 68 174 66 96 130]\n}\n\nfunc ExampleFaker_ImagePng() {\n\tf := New(11)\n\tfmt.Println(f.ImagePng(1, 1))\n\n\t// Output: [137 80 78 71 13 10 26 10 0 0 0 13 73 72 68 82 0 0 0 1 0 0 0 1 8 2 0 0 0 144 119 83 222 0 0 0 16 73 68 65 84 120 156 98 218 34 180 21 16 0 0 255 255 3 1 1 126 242 54 123 184 0 0 0 0 73 69 78 68 174 66 96 130]\n}\n\nfunc BenchmarkImagePng(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tImagePng(640, 480)\n\t}\n}\n"
        },
        {
          "name": "internet.go",
          "type": "blob",
          "size": 15.6357421875,
          "content": "package gofakeit\n\nimport (\n\t\"fmt\"\n\t\"strconv\"\n\t\"strings\"\n\n\t\"github.com/brianvoe/gofakeit/v7/data\"\n)\n\n// DomainName will generate a random url domain name\nfunc DomainName() string { return domainName(GlobalFaker) }\n\n// DomainName will generate a random url domain name\nfunc (f *Faker) DomainName() string { return domainName(f) }\n\nfunc domainName(f *Faker) string {\n\tname := strings.Replace(strings.ToLower(jobDescriptor(f)+bs(f)), \" \", \"\", -1)\n\n\treturn fmt.Sprintf(\"%s.%s\", name, domainSuffix(f))\n}\n\n// DomainSuffix will generate a random domain suffix\nfunc DomainSuffix() string { return domainSuffix(GlobalFaker) }\n\n// DomainSuffix will generate a random domain suffix\nfunc (f *Faker) DomainSuffix() string { return domainSuffix(f) }\n\nfunc domainSuffix(f *Faker) string {\n\treturn getRandValue(f, []string{\"internet\", \"domain_suffix\"})\n}\n\n// URL will generate a random url string\nfunc URL() string { return url(GlobalFaker) }\n\n// URL will generate a random url string\nfunc (f *Faker) URL() string { return url(f) }\n\nfunc url(f *Faker) string {\n\t// Slugs\n\tnum := number(f, 1, 4)\n\tslug := make([]string, num)\n\tfor i := 0; i < num; i++ {\n\t\tslug[i] = bs(f)\n\t}\n\n\tscheme := randomString(f, []string{\"https\", \"http\"})\n\tpath := strings.ToLower(strings.Join(slug, \"/\"))\n\n\turl := fmt.Sprintf(\"%s://www.%s/%s\", scheme, domainName(f), path)\n\turl = strings.Replace(url, \" \", \"\", -1)\n\n\treturn url\n}\n\n// HTTPMethod will generate a random http method\nfunc HTTPMethod() string { return httpMethod(GlobalFaker) }\n\n// HTTPMethod will generate a random http method\nfunc (f *Faker) HTTPMethod() string { return httpMethod(f) }\n\nfunc httpMethod(f *Faker) string {\n\treturn getRandValue(f, []string{\"internet\", \"http_method\"})\n}\n\n// IPv4Address will generate a random version 4 ip address\nfunc IPv4Address() string { return ipv4Address(GlobalFaker) }\n\n// IPv4Address will generate a random version 4 ip address\nfunc (f *Faker) IPv4Address() string { return ipv4Address(f) }\n\nfunc ipv4Address(f *Faker) string {\n\tnum := func() int { return f.IntN(256) }\n\n\treturn fmt.Sprintf(\"%d.%d.%d.%d\", num(), num(), num(), num())\n}\n\n// IPv6Address will generate a random version 6 ip address\nfunc IPv6Address() string { return ipv6Address(GlobalFaker) }\n\n// IPv6Address will generate a random version 6 ip address\nfunc (f *Faker) IPv6Address() string { return ipv6Address(f) }\n\nfunc ipv6Address(f *Faker) string {\n\tnum := func() int { return f.IntN(65536) }\n\n\treturn fmt.Sprintf(\"%x:%x:%x:%x:%x:%x:%x:%x\", num(), num(), num(), num(), num(), num(), num(), num())\n}\n\n// MacAddress will generate a random mac address\nfunc MacAddress() string { return macAddress(GlobalFaker) }\n\n// MacAddress will generate a random mac address\nfunc (f *Faker) MacAddress() string { return macAddress(f) }\n\nfunc macAddress(f *Faker) string {\n\tnum := 255\n\n\treturn fmt.Sprintf(\"%02x:%02x:%02x:%02x:%02x:%02x\", f.IntN(num), f.IntN(num), f.IntN(num), f.IntN(num), f.IntN(num), f.IntN(num))\n}\n\n// HTTPStatusCode will generate a random status code\nfunc HTTPStatusCode() int { return httpStatusCode(GlobalFaker) }\n\n// HTTPStatusCode will generate a random status code\nfunc (f *Faker) HTTPStatusCode() int { return httpStatusCode(f) }\n\nfunc httpStatusCode(f *Faker) int {\n\trandInt, _ := strconv.Atoi(getRandValue(f, []string{\"internet\", \"http_status_general\"}))\n\treturn randInt\n}\n\n// HTTPStatusCodeSimple will generate a random simple status code\nfunc HTTPStatusCodeSimple() int { return httpStatusCodeSimple(GlobalFaker) }\n\n// HTTPStatusCodeSimple will generate a random simple status code\nfunc (f *Faker) HTTPStatusCodeSimple() int { return httpStatusCodeSimple(f) }\n\nfunc httpStatusCodeSimple(f *Faker) int {\n\trandInt, _ := strconv.Atoi(getRandValue(f, []string{\"internet\", \"http_status_simple\"}))\n\treturn randInt\n}\n\n// LogLevel will generate a random log level\n// See data/LogLevels for list of available levels\nfunc LogLevel(logType string) string { return logLevel(GlobalFaker, logType) }\n\n// LogLevel will generate a random log level\n// See data/LogLevels for list of available levels\nfunc (f *Faker) LogLevel(logType string) string { return logLevel(f, logType) }\n\nfunc logLevel(f *Faker, logType string) string {\n\tif _, ok := data.LogLevels[logType]; ok {\n\t\treturn getRandValue(f, []string{\"log_level\", logType})\n\t}\n\n\treturn getRandValue(f, []string{\"log_level\", \"general\"})\n}\n\n// UserAgent will generate a random broswer user agent\nfunc UserAgent() string { return userAgent(GlobalFaker) }\n\n// UserAgent will generate a random broswer user agent\nfunc (f *Faker) UserAgent() string { return userAgent(f) }\n\nfunc userAgent(f *Faker) string {\n\trandNum := randIntRange(f, 0, 4)\n\tswitch randNum {\n\tcase 0:\n\t\treturn chromeUserAgent(f)\n\tcase 1:\n\t\treturn firefoxUserAgent(f)\n\tcase 2:\n\t\treturn safariUserAgent(f)\n\tcase 3:\n\t\treturn operaUserAgent(f)\n\tdefault:\n\t\treturn chromeUserAgent(f)\n\t}\n}\n\n// ChromeUserAgent will generate a random chrome browser user agent string\nfunc ChromeUserAgent() string { return chromeUserAgent(GlobalFaker) }\n\n// ChromeUserAgent will generate a random chrome browser user agent string\nfunc (f *Faker) ChromeUserAgent() string { return chromeUserAgent(f) }\n\nfunc chromeUserAgent(f *Faker) string {\n\trandNum1 := strconv.Itoa(randIntRange(f, 531, 536)) + strconv.Itoa(randIntRange(f, 0, 2))\n\trandNum2 := strconv.Itoa(randIntRange(f, 36, 40))\n\trandNum3 := strconv.Itoa(randIntRange(f, 800, 899))\n\treturn \"Mozilla/5.0 \" + \"(\" + randomPlatform(f) + \") AppleWebKit/\" + randNum1 + \" (KHTML, like Gecko) Chrome/\" + randNum2 + \".0.\" + randNum3 + \".0 Mobile Safari/\" + randNum1\n}\n\n// FirefoxUserAgent will generate a random firefox broswer user agent string\nfunc FirefoxUserAgent() string { return firefoxUserAgent(GlobalFaker) }\n\n// FirefoxUserAgent will generate a random firefox broswer user agent string\nfunc (f *Faker) FirefoxUserAgent() string { return firefoxUserAgent(f) }\n\nfunc firefoxUserAgent(f *Faker) string {\n\tver := \"Gecko/\" + date(f).Format(\"2006-01-02\") + \" Firefox/\" + strconv.Itoa(randIntRange(f, 35, 37)) + \".0\"\n\tplatforms := []string{\n\t\t\"(\" + windowsPlatformToken(f) + \"; \" + \"en-US\" + \"; rv:1.9.\" + strconv.Itoa(randIntRange(f, 0, 3)) + \".20) \" + ver,\n\t\t\"(\" + linuxPlatformToken(f) + \"; rv:\" + strconv.Itoa(randIntRange(f, 5, 8)) + \".0) \" + ver,\n\t\t\"(\" + macPlatformToken(f) + \" rv:\" + strconv.Itoa(randIntRange(f, 2, 7)) + \".0) \" + ver,\n\t}\n\n\treturn \"Mozilla/5.0 \" + randomString(f, platforms)\n}\n\n// SafariUserAgent will generate a random safari browser user agent string\nfunc SafariUserAgent() string { return safariUserAgent(GlobalFaker) }\n\n// SafariUserAgent will generate a random safari browser user agent string\nfunc (f *Faker) SafariUserAgent() string { return safariUserAgent(f) }\n\nfunc safariUserAgent(f *Faker) string {\n\trandNum := strconv.Itoa(randIntRange(f, 531, 536)) + \".\" + strconv.Itoa(randIntRange(f, 1, 51)) + \".\" + strconv.Itoa(randIntRange(f, 1, 8))\n\tver := strconv.Itoa(randIntRange(f, 4, 6)) + \".\" + strconv.Itoa(randIntRange(f, 0, 2))\n\n\tmobileDevices := []string{\n\t\t\"iPhone; CPU iPhone OS\",\n\t\t\"iPad; CPU OS\",\n\t}\n\n\tplatforms := []string{\n\t\t\"(Windows; U; \" + windowsPlatformToken(f) + \") AppleWebKit/\" + randNum + \" (KHTML, like Gecko) Version/\" + ver + \" Safari/\" + randNum,\n\t\t\"(\" + macPlatformToken(f) + \" rv:\" + strconv.Itoa(randIntRange(f, 4, 7)) + \".0; en-US) AppleWebKit/\" + randNum + \" (KHTML, like Gecko) Version/\" + ver + \" Safari/\" + randNum,\n\t\t\"(\" + randomString(f, mobileDevices) + \" \" + strconv.Itoa(randIntRange(f, 7, 9)) + \"_\" + strconv.Itoa(randIntRange(f, 0, 3)) + \"_\" + strconv.Itoa(randIntRange(f, 1, 3)) + \" like Mac OS X; \" + \"en-US\" + \") AppleWebKit/\" + randNum + \" (KHTML, like Gecko) Version/\" + strconv.Itoa(randIntRange(f, 3, 5)) + \".0.5 Mobile/8B\" + strconv.Itoa(randIntRange(f, 111, 120)) + \" Safari/6\" + randNum,\n\t}\n\n\treturn \"Mozilla/5.0 \" + randomString(f, platforms)\n}\n\n// OperaUserAgent will generate a random opera browser user agent string\nfunc OperaUserAgent() string { return operaUserAgent(GlobalFaker) }\n\n// OperaUserAgent will generate a random opera browser user agent string\nfunc (f *Faker) OperaUserAgent() string { return operaUserAgent(f) }\n\nfunc operaUserAgent(f *Faker) string {\n\tplatform := \"(\" + randomPlatform(f) + \"; en-US) Presto/2.\" + strconv.Itoa(randIntRange(f, 8, 13)) + \".\" + strconv.Itoa(randIntRange(f, 160, 355)) + \" Version/\" + strconv.Itoa(randIntRange(f, 10, 13)) + \".00\"\n\n\treturn \"Opera/\" + strconv.Itoa(randIntRange(f, 8, 10)) + \".\" + strconv.Itoa(randIntRange(f, 10, 99)) + \" \" + platform\n}\n\n// linuxPlatformToken will generate a random linux platform\nfunc linuxPlatformToken(f *Faker) string {\n\treturn \"X11; Linux \" + getRandValue(f, []string{\"computer\", \"linux_processor\"})\n}\n\n// macPlatformToken will generate a random mac platform\nfunc macPlatformToken(f *Faker) string {\n\treturn \"Macintosh; \" + getRandValue(f, []string{\"computer\", \"mac_processor\"}) + \" Mac OS X 10_\" + strconv.Itoa(randIntRange(f, 5, 9)) + \"_\" + strconv.Itoa(randIntRange(f, 0, 10))\n}\n\n// windowsPlatformToken will generate a random windows platform\nfunc windowsPlatformToken(f *Faker) string {\n\treturn getRandValue(f, []string{\"computer\", \"windows_platform\"})\n}\n\n// randomPlatform will generate a random platform\nfunc randomPlatform(f *Faker) string {\n\tplatforms := []string{\n\t\tlinuxPlatformToken(f),\n\t\tmacPlatformToken(f),\n\t\twindowsPlatformToken(f),\n\t}\n\n\treturn randomString(f, platforms)\n}\n\n// HTTPVersion will generate a random http version\nfunc HTTPVersion() string { return httpVersion(GlobalFaker) }\n\n// HTTPVersion will generate a random http version\nfunc (f *Faker) HTTPVersion() string { return httpVersion(f) }\n\nfunc httpVersion(f *Faker) string {\n\treturn getRandValue(f, []string{\"internet\", \"http_version\"})\n}\n\nfunc addInternetLookup() {\n\tAddFuncLookup(\"url\", Info{\n\t\tDisplay:     \"URL\",\n\t\tCategory:    \"internet\",\n\t\tDescription: \"Web address that specifies the location of a resource on the internet\",\n\t\tExample:     \"http://www.principalproductize.biz/target\",\n\t\tOutput:      \"string\",\n\t\tGenerate: func(f *Faker, m *MapParams, info *Info) (any, error) {\n\t\t\treturn url(f), nil\n\t\t},\n\t})\n\n\tAddFuncLookup(\"domainname\", Info{\n\t\tDisplay:     \"Domain Name\",\n\t\tCategory:    \"internet\",\n\t\tDescription: \"Human-readable web address used to identify websites on the internet\",\n\t\tExample:     \"centraltarget.biz\",\n\t\tOutput:      \"string\",\n\t\tGenerate: func(f *Faker, m *MapParams, info *Info) (any, error) {\n\t\t\treturn domainName(f), nil\n\t\t},\n\t})\n\n\tAddFuncLookup(\"domainsuffix\", Info{\n\t\tDisplay:     \"Domain Suffix\",\n\t\tCategory:    \"internet\",\n\t\tDescription: \"The part of a domain name that comes after the last dot, indicating its type or purpose\",\n\t\tExample:     \"org\",\n\t\tOutput:      \"string\",\n\t\tGenerate: func(f *Faker, m *MapParams, info *Info) (any, error) {\n\t\t\treturn domainSuffix(f), nil\n\t\t},\n\t})\n\n\tAddFuncLookup(\"ipv4address\", Info{\n\t\tDisplay:     \"IPv4 Address\",\n\t\tCategory:    \"internet\",\n\t\tDescription: \"Numerical label assigned to devices on a network for identification and communication\",\n\t\tExample:     \"222.83.191.222\",\n\t\tOutput:      \"string\",\n\t\tGenerate: func(f *Faker, m *MapParams, info *Info) (any, error) {\n\t\t\treturn ipv4Address(f), nil\n\t\t},\n\t})\n\n\tAddFuncLookup(\"ipv6address\", Info{\n\t\tDisplay:     \"IPv6 Address\",\n\t\tCategory:    \"internet\",\n\t\tDescription: \"Numerical label assigned to devices on a network, providing a larger address space than IPv4 for internet communication\",\n\t\tExample:     \"2001:cafe:8898:ee17:bc35:9064:5866:d019\",\n\t\tOutput:      \"string\",\n\t\tGenerate: func(f *Faker, m *MapParams, info *Info) (any, error) {\n\t\t\treturn ipv6Address(f), nil\n\t\t},\n\t})\n\n\tAddFuncLookup(\"httpmethod\", Info{\n\t\tDisplay:     \"HTTP Method\",\n\t\tCategory:    \"internet\",\n\t\tDescription: \"Verb used in HTTP requests to specify the desired action to be performed on a resource\",\n\t\tExample:     \"HEAD\",\n\t\tOutput:      \"string\",\n\t\tGenerate: func(f *Faker, m *MapParams, info *Info) (any, error) {\n\t\t\treturn httpMethod(f), nil\n\t\t},\n\t})\n\n\tAddFuncLookup(\"loglevel\", Info{\n\t\tDisplay:     \"Log Level\",\n\t\tCategory:    \"internet\",\n\t\tDescription: \"Classification used in logging to indicate the severity or priority of a log entry\",\n\t\tExample:     \"error\",\n\t\tOutput:      \"string\",\n\t\tGenerate: func(f *Faker, m *MapParams, info *Info) (any, error) {\n\t\t\treturn logLevel(f, \"\"), nil\n\t\t},\n\t})\n\n\tAddFuncLookup(\"useragent\", Info{\n\t\tDisplay:     \"User Agent\",\n\t\tCategory:    \"internet\",\n\t\tDescription: \"String sent by a web browser to identify itself when requesting web content\",\n\t\tExample:     \"Mozilla/5.0 (Windows NT 5.0) AppleWebKit/5362 (KHTML, like Gecko) Chrome/37.0.834.0 Mobile Safari/5362\",\n\t\tOutput:      \"string\",\n\t\tGenerate: func(f *Faker, m *MapParams, info *Info) (any, error) {\n\t\t\treturn userAgent(f), nil\n\t\t},\n\t})\n\n\tAddFuncLookup(\"chromeuseragent\", Info{\n\t\tDisplay:     \"Chrome User Agent\",\n\t\tCategory:    \"internet\",\n\t\tDescription: \"The specific identification string sent by the Google Chrome web browser when making requests on the internet\",\n\t\tExample:     \"Mozilla/5.0 (X11; Linux i686) AppleWebKit/5312 (KHTML, like Gecko) Chrome/39.0.836.0 Mobile Safari/5312\",\n\t\tOutput:      \"string\",\n\t\tGenerate: func(f *Faker, m *MapParams, info *Info) (any, error) {\n\t\t\treturn chromeUserAgent(f), nil\n\t\t},\n\t})\n\n\tAddFuncLookup(\"firefoxuseragent\", Info{\n\t\tDisplay:     \"Firefox User Agent\",\n\t\tCategory:    \"internet\",\n\t\tDescription: \"The specific identification string sent by the Firefox web browser when making requests on the internet\",\n\t\tExample:     \"Mozilla/5.0 (Macintosh; U; PPC Mac OS X 10_8_3 rv:7.0) Gecko/1900-07-01 Firefox/37.0\",\n\t\tOutput:      \"string\",\n\t\tGenerate: func(f *Faker, m *MapParams, info *Info) (any, error) {\n\t\t\treturn firefoxUserAgent(f), nil\n\t\t},\n\t})\n\n\tAddFuncLookup(\"operauseragent\", Info{\n\t\tDisplay:     \"Opera User Agent\",\n\t\tCategory:    \"internet\",\n\t\tDescription: \"The specific identification string sent by the Opera web browser when making requests on the internet\",\n\t\tExample:     \"Opera/8.39 (Macintosh; U; PPC Mac OS X 10_8_7; en-US) Presto/2.9.335 Version/10.00\",\n\t\tOutput:      \"string\",\n\t\tGenerate: func(f *Faker, m *MapParams, info *Info) (any, error) {\n\t\t\treturn operaUserAgent(f), nil\n\t\t},\n\t})\n\n\tAddFuncLookup(\"safariuseragent\", Info{\n\t\tDisplay:     \"Safari User Agent\",\n\t\tCategory:    \"internet\",\n\t\tDescription: \"The specific identification string sent by the Safari web browser when making requests on the internet\",\n\t\tExample:     \"Mozilla/5.0 (iPad; CPU OS 8_3_2 like Mac OS X; en-US) AppleWebKit/531.15.6 (KHTML, like Gecko) Version/4.0.5 Mobile/8B120 Safari/6531.15.6\",\n\t\tOutput:      \"string\",\n\t\tGenerate: func(f *Faker, m *MapParams, info *Info) (any, error) {\n\t\t\treturn safariUserAgent(f), nil\n\t\t},\n\t})\n\n\tAddFuncLookup(\"httpstatuscode\", Info{\n\t\tDisplay:     \"HTTP Status Code\",\n\t\tCategory:    \"internet\",\n\t\tDescription: \"Random http status code\",\n\t\tExample:     \"200\",\n\t\tOutput:      \"int\",\n\t\tGenerate: func(f *Faker, m *MapParams, info *Info) (any, error) {\n\t\t\treturn httpStatusCode(f), nil\n\t\t},\n\t})\n\n\tAddFuncLookup(\"httpstatuscodesimple\", Info{\n\t\tDisplay:     \"HTTP Status Code Simple\",\n\t\tCategory:    \"internet\",\n\t\tDescription: \"Three-digit number returned by a web server to indicate the outcome of an HTTP request\",\n\t\tExample:     \"404\",\n\t\tOutput:      \"int\",\n\t\tGenerate: func(f *Faker, m *MapParams, info *Info) (any, error) {\n\t\t\treturn httpStatusCodeSimple(f), nil\n\t\t},\n\t})\n\n\tAddFuncLookup(\"httpversion\", Info{\n\t\tDisplay:     \"HTTP Version\",\n\t\tCategory:    \"internet\",\n\t\tDescription: \"Number indicating the version of the HTTP protocol used for communication between a client and a server\",\n\t\tExample:     \"HTTP/1.1\",\n\t\tOutput:      \"string\",\n\t\tGenerate: func(f *Faker, m *MapParams, info *Info) (any, error) {\n\t\t\treturn httpVersion(f), nil\n\t\t},\n\t})\n\n\tAddFuncLookup(\"macaddress\", Info{\n\t\tDisplay:     \"MAC Address\",\n\t\tCategory:    \"internet\",\n\t\tDescription: \"Unique identifier assigned to network interfaces, often used in Ethernet networks\",\n\t\tExample:     \"cb:ce:06:94:22:e9\",\n\t\tOutput:      \"string\",\n\t\tGenerate: func(f *Faker, m *MapParams, info *Info) (any, error) {\n\t\t\treturn macAddress(f), nil\n\t\t},\n\t})\n}\n"
        },
        {
          "name": "internet_test.go",
          "type": "blob",
          "size": 5.96875,
          "content": "package gofakeit\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\t\"testing\"\n)\n\nfunc ExampleDomainName() {\n\tSeed(11)\n\tfmt.Println(DomainName())\n\n\t// Output: productinfrastructures.biz\n}\n\nfunc ExampleFaker_DomainName() {\n\tf := New(11)\n\tfmt.Println(f.DomainName())\n\n\t// Output: productinfrastructures.biz\n}\n\nfunc BenchmarkDomainName(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tDomainName()\n\t}\n}\n\nfunc ExampleDomainSuffix() {\n\tSeed(11)\n\tfmt.Println(DomainSuffix())\n\n\t// Output: io\n}\n\nfunc ExampleFaker_DomainSuffix() {\n\tf := New(11)\n\tfmt.Println(f.DomainSuffix())\n\n\t// Output: io\n}\n\nfunc BenchmarkDomainSuffix(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tDomainSuffix()\n\t}\n}\n\nfunc ExampleURL() {\n\tSeed(11)\n\tfmt.Println(URL())\n\n\t// Output: http://www.directinnovative.biz/infrastructures\n}\n\nfunc ExampleFaker_URL() {\n\tf := New(11)\n\tfmt.Println(f.URL())\n\n\t// Output: http://www.directinnovative.biz/infrastructures\n}\n\nfunc TestURLValid(t *testing.T) {\n\tfor i := 0; i < 10000; i++ {\n\t\turl := URL()\n\n\t\t// Check if url has spaces in it\n\t\tif strings.Contains(url, \" \") {\n\t\t\tt.Error(\"URL has spaces\")\n\t\t}\n\t}\n}\n\nfunc BenchmarkURL(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tURL()\n\t}\n}\n\nfunc ExampleHTTPMethod() {\n\tSeed(11)\n\tfmt.Println(HTTPMethod())\n\n\t// Output: DELETE\n}\n\nfunc ExampleHTTPVersion() {\n\tSeed(11)\n\tfmt.Println(HTTPVersion())\n\n\t// Output: HTTP/2.0\n}\n\nfunc ExampleFaker_HTTPMethod() {\n\tf := New(11)\n\tfmt.Println(f.HTTPMethod())\n\n\t// Output: DELETE\n}\n\nfunc ExampleFaker_HTTPVersion() {\n\tf := New(11)\n\tfmt.Println(f.HTTPVersion())\n\n\t// Output: HTTP/2.0\n}\n\nfunc BenchmarkHTTPMethod(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tHTTPMethod()\n\t}\n}\n\nfunc ExampleIPv4Address() {\n\tSeed(11)\n\tfmt.Println(IPv4Address())\n\n\t// Output: 180.18.181.251\n}\n\nfunc ExampleFaker_IPv4Address() {\n\tf := New(11)\n\tfmt.Println(f.IPv4Address())\n\n\t// Output: 180.18.181.251\n}\n\nfunc BenchmarkIPv4Address(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tIPv4Address()\n\t}\n}\n\nfunc ExampleIPv6Address() {\n\tSeed(11)\n\tfmt.Println(IPv6Address())\n\n\t// Output: ddb4:9212:aab5:87fb:4e33:17a4:f7b9:bf8e\n}\n\nfunc ExampleFaker_IPv6Address() {\n\tf := New(11)\n\tfmt.Println(f.IPv6Address())\n\n\t// Output: ddb4:9212:aab5:87fb:4e33:17a4:f7b9:bf8e\n}\n\nfunc BenchmarkIPv6Address(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tIPv6Address()\n\t}\n}\n\nfunc ExampleMacAddress() {\n\tSeed(11)\n\tfmt.Println(MacAddress())\n\n\t// Output: e4:da:32:33:86:3b\n}\n\nfunc ExampleFaker_MacAddress() {\n\tf := New(11)\n\tfmt.Println(f.MacAddress())\n\n\t// Output: e4:da:32:33:86:3b\n}\n\nfunc BenchmarkMacAddress(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tMacAddress()\n\t}\n}\n\nfunc ExampleHTTPStatusCode() {\n\tSeed(11)\n\tfmt.Println(HTTPStatusCode())\n\n\t// Output: 502\n}\n\nfunc ExampleFaker_HTTPStatusCode() {\n\tf := New(11)\n\tfmt.Println(f.HTTPStatusCode())\n\n\t// Output: 502\n}\n\nfunc BenchmarkHTTPStatusCode(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tHTTPStatusCode()\n\t}\n}\n\nfunc ExampleHTTPStatusCodeSimple() {\n\tSeed(11)\n\tfmt.Println(HTTPStatusCodeSimple())\n\n\t// Output: 500\n}\n\nfunc ExampleFaker_HTTPStatusCodeSimple() {\n\tf := New(11)\n\tfmt.Println(f.HTTPStatusCodeSimple())\n\n\t// Output: 500\n}\n\nfunc BenchmarkHTTPStatusCodeSimple(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tHTTPStatusCodeSimple()\n\t}\n}\n\nfunc ExampleLogLevel() {\n\tSeed(11)\n\tfmt.Println(LogLevel(\"\")) // This will also use general\n\tfmt.Println(LogLevel(\"syslog\"))\n\tfmt.Println(LogLevel(\"apache\"))\n\n\t// Output: debug\n\t// crit\n\t// alert\n}\n\nfunc ExampleFaker_LogLevel() {\n\tf := New(11)\n\tfmt.Println(f.LogLevel(\"\")) // This will also use general\n\tfmt.Println(f.LogLevel(\"syslog\"))\n\tfmt.Println(f.LogLevel(\"apache\"))\n\n\t// Output: debug\n\t// crit\n\t// alert\n}\n\nfunc BenchmarkLogLevel(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tLogLevel(\"general\")\n\t}\n}\n\nfunc ExampleUserAgent() {\n\tSeed(11)\n\tfmt.Println(UserAgent())\n\n\t// Output: Mozilla/5.0 (Windows 98) AppleWebKit/5360 (KHTML, like Gecko) Chrome/37.0.852.0 Mobile Safari/5360\n}\n\nfunc ExampleFaker_UserAgent() {\n\tf := New(11)\n\tfmt.Println(f.UserAgent())\n\n\t// Output: Mozilla/5.0 (Windows 98) AppleWebKit/5360 (KHTML, like Gecko) Chrome/37.0.852.0 Mobile Safari/5360\n}\n\nfunc BenchmarkUserAgent(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tUserAgent()\n\t}\n}\n\nfunc TestUserAgent(t *testing.T) {\n\tfor i := 0; i < 100; i++ {\n\t\tUserAgent()\n\t}\n}\n\nfunc ExampleChromeUserAgent() {\n\tSeed(11)\n\tfmt.Println(ChromeUserAgent())\n\n\t// Output: Mozilla/5.0 (Windows CE) AppleWebKit/5362 (KHTML, like Gecko) Chrome/36.0.820.0 Mobile Safari/5362\n}\n\nfunc ExampleFaker_ChromeUserAgent() {\n\tf := New(11)\n\tfmt.Println(f.ChromeUserAgent())\n\n\t// Output: Mozilla/5.0 (Windows CE) AppleWebKit/5362 (KHTML, like Gecko) Chrome/36.0.820.0 Mobile Safari/5362\n}\n\nfunc BenchmarkChromeUserAgent(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tChromeUserAgent()\n\t}\n}\n\nfunc ExampleFirefoxUserAgent() {\n\tSeed(11)\n\tfmt.Println(FirefoxUserAgent())\n\n\t// Output: Mozilla/5.0 (Windows CE; en-US; rv:1.9.3.20) Gecko/2011-11-07 Firefox/36.0\n}\n\nfunc ExampleFaker_FirefoxUserAgent() {\n\tf := New(11)\n\tfmt.Println(f.FirefoxUserAgent())\n\n\t// Output: Mozilla/5.0 (Windows CE; en-US; rv:1.9.3.20) Gecko/2011-11-07 Firefox/36.0\n}\n\nfunc BenchmarkFirefoxUserAgent(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tFirefoxUserAgent()\n\t}\n}\n\nfunc ExampleSafariUserAgent() {\n\tSeed(11)\n\tfmt.Println(SafariUserAgent())\n\n\t// Output: Mozilla/5.0 (Windows; U; Windows NT 6.0) AppleWebKit/536.44.6 (KHTML, like Gecko) Version/4.1 Safari/536.44.6\n}\n\nfunc ExampleFaker_SafariUserAgent() {\n\tf := New(11)\n\tfmt.Println(f.SafariUserAgent())\n\n\t// Output: Mozilla/5.0 (Windows; U; Windows NT 6.0) AppleWebKit/536.44.6 (KHTML, like Gecko) Version/4.1 Safari/536.44.6\n}\n\nfunc BenchmarkSafariUserAgent(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tSafariUserAgent()\n\t}\n}\n\nfunc ExampleOperaUserAgent() {\n\tSeed(11)\n\tfmt.Println(OperaUserAgent())\n\n\t// Output: Opera/10.91 (X11; Linux i686; en-US) Presto/2.12.265 Version/11.00\n}\n\nfunc ExampleFaker_OperaUserAgent() {\n\tf := New(11)\n\tfmt.Println(f.OperaUserAgent())\n\n\t// Output: Opera/10.91 (X11; Linux i686; en-US) Presto/2.12.265 Version/11.00\n}\n\nfunc BenchmarkOperaUserAgent(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tOperaUserAgent()\n\t}\n}\n"
        },
        {
          "name": "json.go",
          "type": "blob",
          "size": 9.0283203125,
          "content": "package gofakeit\n\nimport (\n\t\"bytes\"\n\t\"encoding/json\"\n\t\"errors\"\n\t\"fmt\"\n\t\"reflect\"\n\t\"strconv\"\n)\n\n// JSONOptions defines values needed for json generation\ntype JSONOptions struct {\n\tType     string  `json:\"type\" xml:\"type\" fake:\"{randomstring:[array,object]}\"` // array or object\n\tRowCount int     `json:\"row_count\" xml:\"row_count\" fake:\"{number:1,10}\"`\n\tIndent   bool    `json:\"indent\" xml:\"indent\"`\n\tFields   []Field `json:\"fields\" xml:\"fields\" fake:\"{fields}\"`\n}\n\ntype jsonKeyVal struct {\n\tKey   string\n\tValue any\n}\n\ntype jsonOrderedKeyVal []*jsonKeyVal\n\nfunc (okv jsonOrderedKeyVal) MarshalJSON() ([]byte, error) {\n\tvar buf bytes.Buffer\n\n\tbuf.WriteString(\"{\")\n\tfor i, kv := range okv {\n\t\t// Add comma to all except last one\n\t\tif i != 0 {\n\t\t\tbuf.WriteString(\",\")\n\t\t}\n\n\t\t// Marshal key and write\n\t\tkey, err := json.Marshal(kv.Key)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tbuf.Write(key)\n\n\t\t// Write colon separator\n\t\tbuf.WriteString(\":\")\n\n\t\t// Marshal value and write\n\t\tval, err := json.Marshal(kv.Value)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tbuf.Write(val)\n\t}\n\tbuf.WriteString(\"}\")\n\n\treturn buf.Bytes(), nil\n}\n\n// JSON generates an object or an array of objects in json format.\n// A nil JSONOptions returns a randomly structured JSON.\nfunc JSON(jo *JSONOptions) ([]byte, error) { return jsonFunc(GlobalFaker, jo) }\n\n// JSON generates an object or an array of objects in json format.\n// A nil JSONOptions returns a randomly structured JSON.\nfunc (f *Faker) JSON(jo *JSONOptions) ([]byte, error) { return jsonFunc(f, jo) }\n\n// JSON generates an object or an array of objects in json format\nfunc jsonFunc(f *Faker, jo *JSONOptions) ([]byte, error) {\n\tif jo == nil {\n\t\t// We didn't get a JSONOptions, so create a new random one\n\t\terr := f.Struct(&jo)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\t// Check to make sure they passed in a type\n\tif jo.Type != \"array\" && jo.Type != \"object\" {\n\t\treturn nil, errors.New(\"invalid type, must be array or object\")\n\t}\n\n\tif jo.Fields == nil || len(jo.Fields) <= 0 {\n\t\treturn nil, errors.New(\"must pass fields in order to build json object(s)\")\n\t}\n\n\tif jo.Type == \"object\" {\n\t\tv := make(jsonOrderedKeyVal, len(jo.Fields))\n\n\t\t// Loop through fields and add to them to map[string]any\n\t\tfor i, field := range jo.Fields {\n\t\t\tif field.Function == \"autoincrement\" {\n\t\t\t\t// Object only has one\n\t\t\t\tv[i] = &jsonKeyVal{Key: field.Name, Value: 1}\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\t// Get function info\n\t\t\tfuncInfo := GetFuncLookup(field.Function)\n\t\t\tif funcInfo == nil {\n\t\t\t\treturn nil, errors.New(\"invalid function, \" + field.Function + \" does not exist\")\n\t\t\t}\n\n\t\t\t// Call function value\n\t\t\tvalue, err := funcInfo.Generate(f, &field.Params, funcInfo)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\n\t\t\tif _, ok := value.([]byte); ok {\n\t\t\t\t// If it's a slice, unmarshal it into an interface\n\t\t\t\tvar val any\n\t\t\t\terr := json.Unmarshal(value.([]byte), &val)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn nil, err\n\t\t\t\t}\n\t\t\t\tvalue = val\n\t\t\t}\n\n\t\t\tv[i] = &jsonKeyVal{Key: field.Name, Value: value}\n\n\t\t}\n\n\t\t// Marshal into bytes\n\t\tif jo.Indent {\n\t\t\tj, _ := json.MarshalIndent(v, \"\", \"    \")\n\t\t\treturn j, nil\n\t\t}\n\n\t\tj, _ := json.Marshal(v)\n\t\treturn j, nil\n\t}\n\n\tif jo.Type == \"array\" {\n\t\t// Make sure you set a row count\n\t\tif jo.RowCount <= 0 {\n\t\t\treturn nil, errors.New(\"must have row count\")\n\t\t}\n\n\t\tv := make([]jsonOrderedKeyVal, jo.RowCount)\n\n\t\tfor i := 0; i < int(jo.RowCount); i++ {\n\t\t\tvr := make(jsonOrderedKeyVal, len(jo.Fields))\n\n\t\t\t// Loop through fields and add to them to map[string]any\n\t\t\tfor ii, field := range jo.Fields {\n\t\t\t\tif field.Function == \"autoincrement\" {\n\t\t\t\t\tvr[ii] = &jsonKeyVal{Key: field.Name, Value: i + 1} // +1 because index starts with 0\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\n\t\t\t\t// Get function info\n\t\t\t\tfuncInfo := GetFuncLookup(field.Function)\n\t\t\t\tif funcInfo == nil {\n\t\t\t\t\treturn nil, errors.New(\"invalid function, \" + field.Function + \" does not exist\")\n\t\t\t\t}\n\n\t\t\t\t// Call function value\n\t\t\t\tvalue, err := funcInfo.Generate(f, &field.Params, funcInfo)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn nil, err\n\t\t\t\t}\n\n\t\t\t\tif _, ok := value.([]byte); ok {\n\t\t\t\t\t// If it's a slice, unmarshal it into an interface\n\t\t\t\t\tvar val any\n\t\t\t\t\terr := json.Unmarshal(value.([]byte), &val)\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\treturn nil, err\n\t\t\t\t\t}\n\t\t\t\t\tvalue = val\n\t\t\t\t}\n\n\t\t\t\tvr[ii] = &jsonKeyVal{Key: field.Name, Value: value}\n\t\t\t}\n\n\t\t\tv[i] = vr\n\t\t}\n\n\t\t// Marshal into bytes\n\t\tif jo.Indent {\n\t\t\tj, _ := json.MarshalIndent(v, \"\", \"    \")\n\t\t\treturn j, nil\n\t\t}\n\n\t\tj, _ := json.Marshal(v)\n\t\treturn j, nil\n\t}\n\n\treturn nil, errors.New(\"invalid type, must be array or object\")\n}\n\nfunc addFileJSONLookup() {\n\tAddFuncLookup(\"json\", Info{\n\t\tDisplay:     \"JSON\",\n\t\tCategory:    \"file\",\n\t\tDescription: \"Format for structured data interchange used in programming, returns an object or an array of objects\",\n\t\tExample: `[\n\t\t\t{ \"first_name\": \"Markus\", \"last_name\": \"Moen\", \"password\": \"Dc0VYXjkWABx\" },\n\t\t\t{ \"first_name\": \"Osborne\", \"last_name\": \"Hilll\", \"password\": \"XPJ9OVNbs5lm\" },\n\t\t\t{ \"first_name\": \"Mertie\", \"last_name\": \"Halvorson\", \"password\": \"eyl3bhwfV8wA\" }\n\t\t]`,\n\t\tOutput:      \"[]byte\",\n\t\tContentType: \"application/json\",\n\t\tParams: []Param{\n\t\t\t{Field: \"type\", Display: \"Type\", Type: \"string\", Default: \"object\", Options: []string{\"object\", \"array\"}, Description: \"Type of JSON, object or array\"},\n\t\t\t{Field: \"rowcount\", Display: \"Row Count\", Type: \"int\", Default: \"100\", Description: \"Number of rows in JSON array\"},\n\t\t\t{Field: \"indent\", Display: \"Indent\", Type: \"bool\", Default: \"false\", Description: \"Whether or not to add indents and newlines\"},\n\t\t\t{Field: \"fields\", Display: \"Fields\", Type: \"[]Field\", Description: \"Fields containing key name and function to run in json format\"},\n\t\t},\n\t\tGenerate: func(f *Faker, m *MapParams, info *Info) (any, error) {\n\t\t\tjo := JSONOptions{}\n\n\t\t\ttyp, err := info.GetString(m, \"type\")\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\tjo.Type = typ\n\n\t\t\trowcount, err := info.GetInt(m, \"rowcount\")\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\tjo.RowCount = rowcount\n\n\t\t\tindent, err := info.GetBool(m, \"indent\")\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\tjo.Indent = indent\n\n\t\t\tfieldsStr, err := info.GetStringArray(m, \"fields\")\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\n\t\t\t// Check to make sure fields has length\n\t\t\tif len(fieldsStr) > 0 {\n\t\t\t\tjo.Fields = make([]Field, len(fieldsStr))\n\n\t\t\t\tfor i, f := range fieldsStr {\n\t\t\t\t\t// Unmarshal fields string into fields array\n\t\t\t\t\terr = json.Unmarshal([]byte(f), &jo.Fields[i])\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\treturn nil, err\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn jsonFunc(f, &jo)\n\t\t},\n\t})\n}\n\n// encoding/json.RawMessage is a special case of []byte\n// it cannot be handled as a reflect.Array/reflect.Slice\n// because it needs additional structure in the output\nfunc rJsonRawMessage(f *Faker, v reflect.Value, tag string) error {\n\tif tag != \"\" {\n\t\terr := rCustom(f, v, tag)\n\t\tif err == nil {\n\t\t\tjsonData := v.Bytes()\n\t\t\tif !json.Valid(jsonData) {\n\t\t\t\tfName, _ := parseNameAndParamsFromTag(tag)\n\t\t\t\treturn errors.New(\"custom function \" + fName + \" returned invalid json data: \" + string(jsonData))\n\t\t\t}\n\t\t}\n\t\treturn err\n\t}\n\n\tb, err := f.JSON(nil)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tv.SetBytes(b)\n\treturn nil\n}\n\n// encoding/json.Number is a special case of string\n// that represents a JSON number literal.\n// It cannot be handled as a string because it needs to\n// represent an integer or a floating-point number.\nfunc rJsonNumber(f *Faker, v reflect.Value, tag string) error {\n\tvar ret json.Number\n\n\tvar numberType string\n\n\tif tag == \"\" {\n\t\tnumberType = f.RandomString([]string{\"int\", \"float\"})\n\n\t\tswitch numberType {\n\t\tcase \"int\":\n\t\t\tretInt := f.Int16()\n\t\t\tret = json.Number(strconv.Itoa(int(retInt)))\n\t\tcase \"float\":\n\t\t\tretFloat := f.Float64()\n\t\t\tret = json.Number(strconv.FormatFloat(retFloat, 'f', -1, 64))\n\t\t}\n\t} else {\n\t\tfName, fParams := parseNameAndParamsFromTag(tag)\n\t\tinfo := GetFuncLookup(fName)\n\t\tif info == nil {\n\t\t\treturn fmt.Errorf(\"invalid function, %s does not exist\", fName)\n\t\t}\n\n\t\t// Parse map params\n\t\tmapParams, err := parseMapParams(info, fParams)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tvalueIface, err := info.Generate(f, mapParams, info)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tswitch value := valueIface.(type) {\n\t\tcase int:\n\t\t\tret = json.Number(strconv.FormatInt(int64(value), 10))\n\t\tcase int8:\n\t\t\tret = json.Number(strconv.FormatInt(int64(value), 10))\n\t\tcase int16:\n\t\t\tret = json.Number(strconv.FormatInt(int64(value), 10))\n\t\tcase int32:\n\t\t\tret = json.Number(strconv.FormatInt(int64(value), 10))\n\t\tcase int64:\n\t\t\tret = json.Number(strconv.FormatInt(int64(value), 10))\n\t\tcase uint:\n\t\t\tret = json.Number(strconv.FormatUint(uint64(value), 10))\n\t\tcase uint8:\n\t\t\tret = json.Number(strconv.FormatUint(uint64(value), 10))\n\t\tcase uint16:\n\t\t\tret = json.Number(strconv.FormatUint(uint64(value), 10))\n\t\tcase uint32:\n\t\t\tret = json.Number(strconv.FormatUint(uint64(value), 10))\n\t\tcase uint64:\n\t\t\tret = json.Number(strconv.FormatUint(uint64(value), 10))\n\t\tcase float32:\n\t\t\tret = json.Number(strconv.FormatFloat(float64(value), 'f', -1, 64))\n\t\tcase float64:\n\t\t\tret = json.Number(strconv.FormatFloat(float64(value), 'f', -1, 64))\n\t\tdefault:\n\t\t\treturn fmt.Errorf(\"invalid type, %s is not a valid type for json.Number\", reflect.TypeOf(value))\n\t\t}\n\t}\n\tv.Set(reflect.ValueOf(ret))\n\treturn nil\n}\n"
        },
        {
          "name": "json_test.go",
          "type": "blob",
          "size": 13.2158203125,
          "content": "package gofakeit\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc ExampleJSON_object() {\n\tSeed(11)\n\n\tvalue, err := JSON(&JSONOptions{\n\t\tType: \"object\",\n\t\tFields: []Field{\n\t\t\t{Name: \"first_name\", Function: \"firstname\"},\n\t\t\t{Name: \"last_name\", Function: \"lastname\"},\n\t\t\t{Name: \"address\", Function: \"address\"},\n\t\t\t{Name: \"password\", Function: \"password\", Params: MapParams{\"special\": {\"false\"}}},\n\t\t},\n\t\tIndent: true,\n\t})\n\tif err != nil {\n\t\tfmt.Println(err)\n\t}\n\n\tfmt.Println(string(value))\n\n\t// Output: {\n\t//     \"first_name\": \"Sonny\",\n\t//     \"last_name\": \"Stiedemann\",\n\t//     \"address\": {\n\t//         \"address\": \"52759 Stationside, San Diego, Oregon 99344\",\n\t//         \"street\": \"52759 Stationside\",\n\t//         \"city\": \"San Diego\",\n\t//         \"state\": \"Oregon\",\n\t//         \"zip\": \"99344\",\n\t//         \"country\": \"Saint Pierre and Miquelon\",\n\t//         \"latitude\": -30.009814,\n\t//         \"longitude\": 154.519771\n\t//     },\n\t//     \"password\": \"l4338TebFL55\"\n\t// }\n}\n\nfunc ExampleFaker_JSON_object() {\n\tf := New(11)\n\n\tvalue, err := f.JSON(&JSONOptions{\n\t\tType: \"object\",\n\t\tFields: []Field{\n\t\t\t{Name: \"first_name\", Function: \"firstname\"},\n\t\t\t{Name: \"last_name\", Function: \"lastname\"},\n\t\t\t{Name: \"address\", Function: \"address\"},\n\t\t\t{Name: \"password\", Function: \"password\", Params: MapParams{\"special\": {\"false\"}}},\n\t\t},\n\t\tIndent: true,\n\t})\n\tif err != nil {\n\t\tfmt.Println(err)\n\t}\n\n\tfmt.Println(string(value))\n\n\t// Output: {\n\t//     \"first_name\": \"Sonny\",\n\t//     \"last_name\": \"Stiedemann\",\n\t//     \"address\": {\n\t//         \"address\": \"52759 Stationside, San Diego, Oregon 99344\",\n\t//         \"street\": \"52759 Stationside\",\n\t//         \"city\": \"San Diego\",\n\t//         \"state\": \"Oregon\",\n\t//         \"zip\": \"99344\",\n\t//         \"country\": \"Saint Pierre and Miquelon\",\n\t//         \"latitude\": -30.009814,\n\t//         \"longitude\": 154.519771\n\t//     },\n\t//     \"password\": \"l4338TebFL55\"\n\t// }\n}\n\nfunc ExampleJSON_array() {\n\tSeed(11)\n\n\tvalue, err := JSON(&JSONOptions{\n\t\tType: \"array\",\n\t\tFields: []Field{\n\t\t\t{Name: \"id\", Function: \"autoincrement\"},\n\t\t\t{Name: \"first_name\", Function: \"firstname\"},\n\t\t\t{Name: \"last_name\", Function: \"lastname\"},\n\t\t\t{Name: \"password\", Function: \"password\", Params: MapParams{\"special\": {\"false\"}}},\n\t\t},\n\t\tRowCount: 3,\n\t\tIndent:   true,\n\t})\n\tif err != nil {\n\t\tfmt.Println(err)\n\t}\n\n\tfmt.Println(string(value))\n\n\t// Output: [\n\t//     {\n\t//         \"id\": 1,\n\t//         \"first_name\": \"Sonny\",\n\t//         \"last_name\": \"Stiedemann\",\n\t//         \"password\": \"8nwf0o3sBXcR\"\n\t//     },\n\t//     {\n\t//         \"id\": 2,\n\t//         \"first_name\": \"Verda\",\n\t//         \"last_name\": \"Brakus\",\n\t//         \"password\": \"3beWLpq75Lua\"\n\t//     },\n\t//     {\n\t//         \"id\": 3,\n\t//         \"first_name\": \"Jules\",\n\t//         \"last_name\": \"Cremin\",\n\t//         \"password\": \"Uu38J14Y8W82\"\n\t//     }\n\t// ]\n}\n\nfunc ExampleFaker_JSON_array() {\n\tf := New(11)\n\n\tvalue, err := f.JSON(&JSONOptions{\n\t\tType: \"array\",\n\t\tFields: []Field{\n\t\t\t{Name: \"id\", Function: \"autoincrement\"},\n\t\t\t{Name: \"first_name\", Function: \"firstname\"},\n\t\t\t{Name: \"last_name\", Function: \"lastname\"},\n\t\t\t{Name: \"password\", Function: \"password\", Params: MapParams{\"special\": {\"false\"}}},\n\t\t},\n\t\tRowCount: 3,\n\t\tIndent:   true,\n\t})\n\tif err != nil {\n\t\tfmt.Println(err)\n\t}\n\n\tfmt.Println(string(value))\n\n\t// Output: [\n\t//     {\n\t//         \"id\": 1,\n\t//         \"first_name\": \"Sonny\",\n\t//         \"last_name\": \"Stiedemann\",\n\t//         \"password\": \"8nwf0o3sBXcR\"\n\t//     },\n\t//     {\n\t//         \"id\": 2,\n\t//         \"first_name\": \"Verda\",\n\t//         \"last_name\": \"Brakus\",\n\t//         \"password\": \"3beWLpq75Lua\"\n\t//     },\n\t//     {\n\t//         \"id\": 3,\n\t//         \"first_name\": \"Jules\",\n\t//         \"last_name\": \"Cremin\",\n\t//         \"password\": \"Uu38J14Y8W82\"\n\t//     }\n\t// ]\n}\n\nfunc TestJSONLookup(t *testing.T) {\n\tfaker := New(0)\n\tinfo := GetFuncLookup(\"json\")\n\n\tm := NewMapParams()\n\tm.Add(\"type\", \"array\")\n\tm.Add(\"rowcount\", \"10\")\n\tm.Add(\"fields\", `{\"name\":\"id\",\"function\":\"autoincrement\"}`)\n\tm.Add(\"fields\", `{\"name\":\"first_name\",\"function\":\"firstname\"}`)\n\tm.Add(\"fields\", `{\"name\":\"password\",\"function\":\"password\",\"params\":{\"special\":[\"false\"],\"length\":[\"20\"]}}`)\n\n\t_, err := info.Generate(faker, m, info)\n\tif err != nil {\n\t\tt.Fatal(err.Error())\n\t}\n}\n\nfunc TestJSONObjectLookupWithSubJSON(t *testing.T) {\n\tfaker := New(11)\n\tinfo := GetFuncLookup(\"json\")\n\n\tm := NewMapParams()\n\tm.Add(\"type\", \"object\")\n\tm.Add(\"fields\", `{\n\t\t\"name\":\"json\",\n\t\t\"function\":\"json\",\n\t\t\"params\":{\n\t\t\t\"type\":\"object\",\n\t\t\t\"fields\":[\n\t\t\t\t{\"name\":\"id\",\"function\":\"autoincrement\"},\n\t\t\t\t{\"name\":\"first_name\",\"function\":\"firstname\"},\n\t\t\t\t{\"name\":\"last_name\",\"function\":\"lastname\"},\n\t\t\t\t{\"name\":\"password\",\"function\":\"password\",\"params\":{\"special\":\"false\",\"length\":\"20\"}}\n\t\t\t]\n\t\t}\n\t}`)\n\n\toutput, err := info.Generate(faker, m, info)\n\tif err != nil {\n\t\tt.Fatal(err.Error())\n\t}\n\n\t// put together a struct to unmarshal the output json into\n\ttype jsonStruct struct {\n\t\tID        int    `json:\"id\"`\n\t\tFirstName string `json:\"first_name\"`\n\t\tLastName  string `json:\"last_name\"`\n\t\tPassword  string `json:\"password\"`\n\t}\n\n\ttype jsonParent struct {\n\t\tJStruct jsonStruct `json:\"json\"`\n\t}\n\n\tvar j jsonParent\n\terr = json.Unmarshal(output.([]byte), &j)\n\tif err != nil {\n\t\tt.Fatal(err.Error())\n\t}\n\n\t// check that the output values are correct\n\tif j.JStruct.ID == 0 {\n\t\tt.Fatalf(\"ID is not 1 got: %v\", j.JStruct.ID)\n\t}\n\tif j.JStruct.FirstName == \"\" {\n\t\tt.Errorf(\"FirstName is empty\")\n\t}\n\tif j.JStruct.LastName == \"\" {\n\t\tt.Errorf(\"LastName is empty\")\n\t}\n\tif j.JStruct.Password == \"\" {\n\t\tt.Errorf(\"Password is empty\")\n\t}\n}\n\nfunc TestJSONArrayLookupWithSubJSON(t *testing.T) {\n\tfaker := New(11)\n\tinfo := GetFuncLookup(\"json\")\n\n\tm := NewMapParams()\n\tm.Add(\"type\", \"object\")\n\tm.Add(\"fields\", `{\n\t\t\"name\":\"json\",\n\t\t\"function\":\"json\",\n\t\t\"params\":{\n\t\t\t\"type\":\"array\",\n\t\t\t\"rowcount\": 10,\n\t\t\t\"fields\":[\n\t\t\t\t{\"name\":\"id\",\"function\":\"autoincrement\"},\n\t\t\t\t{\"name\":\"first_name\",\"function\":\"firstname\"},\n\t\t\t\t{\"name\":\"last_name\",\"function\":\"lastname\"},\n\t\t\t\t{\"name\":\"password\",\"function\":\"password\",\"params\":{\"special\":\"false\",\"length\":\"20\"}},\n\t\t\t\t{\"name\":\"address\",\"function\":\"address\"}\n\t\t\t]\n\t\t}\n\t}`)\n\n\toutput, err := info.Generate(faker, m, info)\n\tif err != nil {\n\t\tt.Fatal(err.Error())\n\t}\n\n\t// put together a struct to unmarshal the output json into\n\ttype jsonStruct struct {\n\t\tID        int         `json:\"id\"`\n\t\tFirstName string      `json:\"first_name\"`\n\t\tLastName  string      `json:\"last_name\"`\n\t\tPassword  string      `json:\"password\"`\n\t\tAddress   AddressInfo `json:\"address\"`\n\t}\n\n\ttype jsonParent struct {\n\t\tJStruct []jsonStruct `json:\"json\"`\n\t}\n\n\tvar j jsonParent\n\n\terr = json.Unmarshal(output.([]byte), &j)\n\tif err != nil {\n\t\tt.Fatal(err.Error())\n\t}\n\n\t// Check row count\n\tif len(j.JStruct) == 0 {\n\t\tt.Fatalf(\"Row count is not 10 got: %v\", len(j.JStruct))\n\t}\n\n\t// check that the output values are correct\n\tif j.JStruct[0].ID == 0 {\n\t\tt.Fatalf(\"ID is empty\")\n\t}\n\tif j.JStruct[0].FirstName == \"\" {\n\t\tt.Errorf(\"FirstName is empty\")\n\t}\n\tif j.JStruct[0].LastName == \"\" {\n\t\tt.Errorf(\"LastName is empty\")\n\t}\n\tif j.JStruct[0].Password == \"\" {\n\t\tt.Errorf(\"Password is empty\")\n\t}\n\tif j.JStruct[0].Address.City == \"\" {\n\t\tt.Errorf(\"City is empty\")\n\t}\n}\n\nfunc TestJSONNoType(t *testing.T) {\n\tSeed(11)\n\n\t_, err := JSON(&JSONOptions{\n\t\tFields: []Field{\n\t\t\t{Name: \"id\", Function: \"autoincrement\"},\n\t\t\t{Name: \"first_name\", Function: \"firstname\"},\n\t\t\t{Name: \"last_name\", Function: \"lastname\"},\n\t\t\t{Name: \"password\", Function: \"password\", Params: MapParams{\"special\": {\"false\"}}},\n\t\t},\n\t\tRowCount: 3,\n\t})\n\tif err == nil {\n\t\tt.Fatal(\"Expected error, no type specified\")\n\t}\n}\n\nfunc TestJSONNoFields(t *testing.T) {\n\tSeed(11)\n\n\t_, err := JSON(&JSONOptions{\n\t\tType:     \"object\",\n\t\tRowCount: 3,\n\t})\n\tif err == nil {\n\t\tt.Fatal(\"Expected error, no fields set\")\n\t}\n}\n\nfunc TestJSONNoCount(t *testing.T) {\n\tSeed(11)\n\n\t_, err := JSON(&JSONOptions{\n\t\tType: \"array\",\n\t\tFields: []Field{\n\t\t\t{Name: \"id\", Function: \"autoincrement\"},\n\t\t\t{Name: \"first_name\", Function: \"firstname\"},\n\t\t\t{Name: \"last_name\", Function: \"lastname\"},\n\t\t\t{Name: \"password\", Function: \"password\", Params: MapParams{\"special\": {\"false\"}}},\n\t\t},\n\t})\n\tif err == nil {\n\t\tt.Fatal(\"Expected error, no count set for array type\")\n\t}\n}\n\nfunc TestJSONNoOptions(t *testing.T) {\n\tSeed(11)\n\n\t// if JSONOptions is nil -> get a random JSONOptions\n\t_, err := JSON(nil)\n\tif err != nil {\n\t\tt.Fatal(err.Error())\n\t}\n}\n\nfunc TestJSONRawMessage(t *testing.T) {\n\ttype J struct {\n\t\tField json.RawMessage `json:\"field\"`\n\t}\n\n\tSeed(11)\n\n\tvar objs []J\n\tSlice(&objs)\n\n\t_, err := json.Marshal(objs)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n}\n\nfunc TestJSONRawMessageWithTag(t *testing.T) {\n\ttype J struct {\n\t\tField json.RawMessage `json:\"field\" faker:\"json\"`\n\t}\n\n\tSeed(11)\n\n\tvar objs []J\n\tSlice(&objs)\n\n\t_, err := json.Marshal(objs)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n}\n\nfunc TestJSONRawMessageWithCustomFuncTag(t *testing.T) {\n\tAddFuncLookup(\"customjsontest\", Info{\n\t\tDisplay:     \"CustomJSONTest\",\n\t\tCategory:    \"file\",\n\t\tExample:     `{\"ErTA\":\"bale\",\"FQJUIGrmnRBfuGlb\":\"over\",\"HTJJPnEKGS\":\"please say that again\",\"HvLvfsQRGbK\":\"whenever one turns around\",\"KKbMlbxquDmwwvRWVlPmwRAeAw\":\"Voluptatem eaque quia facilis quo.\"}`,\n\t\tOutput:      \"[]byte\",\n\t\tContentType: \"application/json\",\n\t\tParams:      []Param{},\n\t\tGenerate: func(f *Faker, m *MapParams, info *Info) (any, error) {\n\t\t\tlength := f.Number(5, 15)\n\t\t\tdataSet := []string{\"word\", \"phrase\", \"loremipsumsentence\", \"{hackeradjective}-{hackernoun}\", \"float64\", \"bool\"}\n\t\t\tresultMap := make(map[string]any)\n\t\t\tfor i := 0; i < length; i++ {\n\t\t\t\tkey := f.LetterN(uint(f.Number(3, 30)))\n\t\t\t\tval, err := f.Generate(RandomString(dataSet))\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn nil, err\n\t\t\t\t}\n\t\t\t\tresultMap[key] = val\n\t\t\t}\n\t\t\tmarshal, err := json.Marshal(resultMap)\n\t\t\tif err != nil {\n\t\t\t\tpanic(err)\n\t\t\t}\n\t\t\treturn marshal, nil\n\t\t},\n\t})\n\n\ttype J struct {\n\t\tField json.RawMessage `json:\"field\" fake:\"customjsontest\"`\n\t}\n\n\tSeed(11)\n\n\tvar objs []J\n\tSlice(&objs)\n\n\t_, err := json.Marshal(objs)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n}\n\nfunc TestJSONRawMessageWithInvalidCustomFuncTag(t *testing.T) {\n\tAddFuncLookup(\"invalidjsontest\", Info{\n\t\tDisplay:     \"InvalidJSONTest\",\n\t\tCategory:    \"file\",\n\t\tExample:     `[181 251 51 164 185 142 21 3 33]`,\n\t\tOutput:      \"[]byte\",\n\t\tParams:      []Param{},\n\t\tGenerate: func(f *Faker, m *MapParams, info *Info) (any, error) {\n\t\t\tvar result []byte\n\t\t\tSlice(&result)\n\t\t\treturn result, nil\n\t\t},\n\t})\n\n\ttype J struct {\n\t\tField json.RawMessage `json:\"field\" fake:\"invalidjsontest\"`\n\t}\n\n\tSeed(11)\n\n\tvar objs []J\n\tSlice(&objs)\n\n\t_, err := json.Marshal(objs)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tvar obj J\n\terr = Struct(&obj)\n\tif err == nil {\n\t\tt.Fatal(\"'Struct(&obj)' was supposed to return an error but didn't\")\n\t}\n}\n\nfunc TestJSONNumber(t *testing.T) {\n\ttype J struct {\n\t\tField json.Number `json:\"field\"`\n\t}\n\n\tSeed(11)\n\n\tvar objs []J\n\tSlice(&objs)\n\n\t_, err := json.Marshal(objs)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n}\n\nfunc TestJSONNumberWithTag(t *testing.T) {\n\ttype J struct {\n\t\tField json.Number `json:\"field\" fake:\"number:3,7\"`\n\t}\n\n\tSeed(11)\n\n\tvar objs []J\n\tSlice(&objs)\n\n\tgot, err := objs[0].Field.Int64()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif got < 3 || got > 7 {\n\t\tt.Errorf(\"Expected a number between 3 and 7, got %d\", got)\n\t}\n\n\t_, err = json.Marshal(objs)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n}\n\nfunc ExampleJSON_numberWithTag() {\n\tSeed(11)\n\n\ttype J struct {\n\t\tFieldNumber  json.Number `fake:\"number:3,7\"`\n\t\tFieldInt8    json.Number `fake:\"int8\"`\n\t\tFieldInt16   json.Number `fake:\"int16\"`\n\t\tFieldInt32   json.Number `fake:\"int32\"`\n\t\tFieldInt64   json.Number `fake:\"int64\"`\n\t\tFieldUint8   json.Number `fake:\"uint8\"`\n\t\tFieldUint16  json.Number `fake:\"uint16\"`\n\t\tFieldUint32  json.Number `fake:\"uint32\"`\n\t\tFieldUint64  json.Number `fake:\"uint64\"`\n\t\tFieldFloat32 json.Number `fake:\"float32\"`\n\t\tFieldFloat64 json.Number `fake:\"float64range:12,72\"`\n\t}\n\n\tvar obj J\n\tStruct(&obj)\n\n\tfmt.Printf(\"obj.FieldNumber = %+v\\n\", obj.FieldNumber)\n\tfmt.Printf(\"obj.FieldInt8 = %+v\\n\", obj.FieldInt8)\n\tfmt.Printf(\"obj.FieldInt16 = %+v\\n\", obj.FieldInt16)\n\tfmt.Printf(\"obj.FieldInt32 = %+v\\n\", obj.FieldInt32)\n\tfmt.Printf(\"obj.FieldInt64 = %+v\\n\", obj.FieldInt64)\n\tfmt.Printf(\"obj.FieldUint8 = %+v\\n\", obj.FieldUint8)\n\tfmt.Printf(\"obj.FieldUint16 = %+v\\n\", obj.FieldUint16)\n\tfmt.Printf(\"obj.FieldUint32 = %+v\\n\", obj.FieldUint32)\n\tfmt.Printf(\"obj.FieldUint64 = %+v\\n\", obj.FieldUint64)\n\tfmt.Printf(\"obj.FieldFloat32 = %+v\\n\", obj.FieldFloat32)\n\tfmt.Printf(\"obj.FieldFloat64 = %+v\\n\", obj.FieldFloat64)\n\n\t// Output: obj.FieldNumber = 7\n\t// obj.FieldInt8 = -110\n\t// obj.FieldInt16 = 10933\n\t// obj.FieldInt32 = 430103905\n\t// obj.FieldInt64 = 525217394518216243\n\t// obj.FieldUint8 = 164\n\t// obj.FieldUint16 = 63417\n\t// obj.FieldUint32 = 2307233133\n\t// obj.FieldUint64 = 17560678512042153749\n\t// obj.FieldFloat32 = 0.11857688426971436\n\t// obj.FieldFloat64 = 51.03971481390635\n}\n\nfunc BenchmarkJSONLookup100(b *testing.B) {\n\tfaker := New(0)\n\n\tfor i := 0; i < b.N; i++ {\n\t\tinfo := GetFuncLookup(\"json\")\n\n\t\tm := NewMapParams()\n\t\tm.Add(\"type\", \"array\")\n\t\tm.Add(\"rowcount\", \"100\")\n\t\tm.Add(\"fields\", `{\"name\":\"id\",\"function\":\"autoincrement\"}`)\n\t\tm.Add(\"fields\", `{\"name\":\"first_name\",\"function\":\"firstname\"}`)\n\t\tm.Add(\"fields\", `{\"name\":\"last_name\",\"function\":\"lastname\"}`)\n\t\tm.Add(\"fields\", `{\"name\":\"password\",\"function\":\"password\"}`)\n\t\tm.Add(\"fields\", `{\"name\":\"description\",\"function\":\"paragraph\"}`)\n\t\tm.Add(\"fields\", `{\"name\":\"created_at\",\"function\":\"date\"}`)\n\n\t\t_, err := info.Generate(faker, m, info)\n\t\tif err != nil {\n\t\t\tb.Fatal(err.Error())\n\t\t}\n\t}\n}\n"
        },
        {
          "name": "languages.go",
          "type": "blob",
          "size": 2.869140625,
          "content": "package gofakeit\n\n// Language will return a random language\nfunc Language() string { return language(GlobalFaker) }\n\n// Language will return a random language\nfunc (f *Faker) Language() string { return language(f) }\n\nfunc language(f *Faker) string { return getRandValue(f, []string{\"language\", \"long\"}) }\n\n// LanguageAbbreviation will return a random language abbreviation\nfunc LanguageAbbreviation() string { return languageAbbreviation(GlobalFaker) }\n\n// LanguageAbbreviation will return a random language abbreviation\nfunc (f *Faker) LanguageAbbreviation() string { return languageAbbreviation(f) }\n\nfunc languageAbbreviation(f *Faker) string { return getRandValue(f, []string{\"language\", \"short\"}) }\n\n// LanguageBCP will return a random language BCP (Best Current Practices)\nfunc LanguageBCP() string { return languageBCP(GlobalFaker) }\n\n// LanguageBCP will return a random language BCP (Best Current Practices)\nfunc (f *Faker) LanguageBCP() string { return languageBCP(f) }\n\nfunc languageBCP(f *Faker) string { return getRandValue(f, []string{\"language\", \"bcp\"}) }\n\n// ProgrammingLanguage will return a random programming language\nfunc ProgrammingLanguage() string { return programmingLanguage(GlobalFaker) }\n\n// ProgrammingLanguage will return a random programming language\nfunc (f *Faker) ProgrammingLanguage() string { return programmingLanguage(f) }\n\nfunc programmingLanguage(f *Faker) string {\n\treturn getRandValue(f, []string{\"language\", \"programming\"})\n}\n\nfunc addLanguagesLookup() {\n\tAddFuncLookup(\"language\", Info{\n\t\tDisplay:     \"Language\",\n\t\tCategory:    \"language\",\n\t\tDescription: \"System of communication using symbols, words, and grammar to convey meaning between individuals\",\n\t\tExample:     \"Kazakh\",\n\t\tOutput:      \"string\",\n\t\tGenerate: func(f *Faker, m *MapParams, info *Info) (any, error) {\n\t\t\treturn language(f), nil\n\t\t},\n\t})\n\n\tAddFuncLookup(\"languageabbreviation\", Info{\n\t\tDisplay:     \"Language Abbreviation\",\n\t\tCategory:    \"language\",\n\t\tDescription: \"Shortened form of a language's name\",\n\t\tExample:     \"kk\",\n\t\tOutput:      \"string\",\n\t\tGenerate: func(f *Faker, m *MapParams, info *Info) (any, error) {\n\t\t\treturn languageAbbreviation(f), nil\n\t\t},\n\t})\n\n\tAddFuncLookup(\"languagebcp\", Info{\n\t\tDisplay:     \"Language BCP\",\n\t\tCategory:    \"language\",\n\t\tDescription: \"Set of guidelines and standards for identifying and representing languages in computing and internet protocols\",\n\t\tExample:     \"en-US\",\n\t\tOutput:      \"string\",\n\t\tGenerate: func(f *Faker, m *MapParams, info *Info) (any, error) {\n\t\t\treturn languageBCP(f), nil\n\t\t},\n\t})\n\n\tAddFuncLookup(\"programminglanguage\", Info{\n\t\tDisplay:     \"Programming Language\",\n\t\tCategory:    \"language\",\n\t\tDescription: \"Formal system of instructions used to create software and perform computational tasks\",\n\t\tExample:     \"Go\",\n\t\tOutput:      \"string\",\n\t\tGenerate: func(f *Faker, m *MapParams, info *Info) (any, error) {\n\t\t\treturn programmingLanguage(f), nil\n\t\t},\n\t})\n}\n"
        },
        {
          "name": "languages_test.go",
          "type": "blob",
          "size": 1.2236328125,
          "content": "package gofakeit\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc ExampleLanguage() {\n\tSeed(11)\n\tfmt.Println(Language())\n\n\t// Output: Turkish\n}\n\nfunc ExampleFaker_Language() {\n\tf := New(11)\n\tfmt.Println(f.Language())\n\n\t// Output: Turkish\n}\n\nfunc BenchmarkLanguage(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tLanguage()\n\t}\n}\n\nfunc ExampleLanguageAbbreviation() {\n\tSeed(11)\n\tfmt.Println(LanguageAbbreviation())\n\n\t// Output: tr\n}\n\nfunc ExampleFaker_LanguageAbbreviation() {\n\tf := New(11)\n\tfmt.Println(f.LanguageAbbreviation())\n\n\t// Output: tr\n}\n\nfunc BenchmarkLanguageAbbreviation(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tLanguageAbbreviation()\n\t}\n}\n\nfunc ExampleLanguageBCP() {\n\tSeed(11)\n\tfmt.Println(LanguageBCP())\n\n\t// Output: tr-TR\n}\n\nfunc ExampleFaker_LanguageBCP() {\n\tf := New(11)\n\tfmt.Println(f.LanguageBCP())\n\n\t// Output: tr-TR\n}\n\nfunc BenchmarkLanguageBCP(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tLanguageBCP()\n\t}\n}\n\nfunc ExampleProgrammingLanguage() {\n\tSeed(11)\n\tfmt.Println(ProgrammingLanguage())\n\n\t// Output: TELCOMP\n}\n\nfunc ExampleFaker_ProgrammingLanguage() {\n\tf := New(11)\n\tfmt.Println(f.ProgrammingLanguage())\n\n\t// Output: TELCOMP\n}\n\nfunc BenchmarkProgrammingLanguage(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tProgrammingLanguage()\n\t}\n}\n"
        },
        {
          "name": "logo.png",
          "type": "blob",
          "size": 25.95703125,
          "content": null
        },
        {
          "name": "lookup.go",
          "type": "blob",
          "size": 12.0986328125,
          "content": "package gofakeit\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"reflect\"\n\t\"strconv\"\n\t\"strings\"\n\t\"sync\"\n)\n\n// FuncLookups is the primary map array with mapping to all available data\nvar FuncLookups map[string]Info\nvar lockFuncLookups sync.Mutex\n\n// MapParams is the values to pass into a lookup generate\ntype MapParams map[string]MapParamsValue\n\ntype MapParamsValue []string\n\n// Info structures fields to better break down what each one generates\ntype Info struct {\n\tDisplay     string                                                `json:\"display\"`\n\tCategory    string                                                `json:\"category\"`\n\tDescription string                                                `json:\"description\"`\n\tExample     string                                                `json:\"example\"`\n\tOutput      string                                                `json:\"output\"`\n\tContentType string                                                `json:\"content_type\"`\n\tParams      []Param                                               `json:\"params\"`\n\tAny         any                                                   `json:\"any\"`\n\tGenerate    func(f *Faker, m *MapParams, info *Info) (any, error) `json:\"-\"`\n}\n\n// Param is a breakdown of param requirements and type definition\ntype Param struct {\n\tField       string   `json:\"field\"`\n\tDisplay     string   `json:\"display\"`\n\tType        string   `json:\"type\"`\n\tOptional    bool     `json:\"optional\"`\n\tDefault     string   `json:\"default\"`\n\tOptions     []string `json:\"options\"`\n\tDescription string   `json:\"description\"`\n}\n\n// Field is used for defining what name and function you to generate for file outuputs\ntype Field struct {\n\tName     string    `json:\"name\"`\n\tFunction string    `json:\"function\"`\n\tParams   MapParams `json:\"params\"`\n}\n\nfunc init() { initLookup() }\n\n// init will add all the functions to MapLookups\nfunc initLookup() {\n\taddAddressLookup()\n\taddAnimalLookup()\n\taddAppLookup()\n\taddAuthLookup()\n\taddBeerLookup()\n\taddBookLookup()\n\taddCarLookup()\n\taddCelebrityLookup()\n\taddColorLookup()\n\taddCompanyLookup()\n\taddDatabaseSQLLookup()\n\taddDateTimeLookup()\n\taddEmojiLookup()\n\taddErrorLookup()\n\taddFileCSVLookup()\n\taddFileJSONLookup()\n\taddFileLookup()\n\taddFileXMLLookup()\n\taddFinanceLookup()\n\taddFoodLookup()\n\taddGameLookup()\n\taddGenerateLookup()\n\taddHackerLookup()\n\taddHipsterLookup()\n\taddHtmlLookup()\n\taddImageLookup()\n\taddInternetLookup()\n\taddLanguagesLookup()\n\taddLoremLookup()\n\taddMinecraftLookup()\n\taddMiscLookup()\n\taddMovieLookup()\n\taddNumberLookup()\n\taddPaymentLookup()\n\taddPersonLookup()\n\taddProductLookup()\n\taddSchoolLookup()\n\taddStringLookup()\n\taddTemplateLookup()\n\taddWeightedLookup()\n\taddWordAdjectiveLookup()\n\taddWordAdverbLookup()\n\taddWordConnectiveLookup()\n\taddWordGeneralLookup()\n\taddWordGrammerLookup()\n\taddWordNounLookup()\n\taddWordPhraseLookup()\n\taddWordPrepositionLookup()\n\taddWordPronounLookup()\n\taddWordSentenceLookup()\n\taddWordVerbLookup()\n\taddWordCommentLookup()\n\taddWordMiscLookup()\n}\n\n// internalFuncLookups is the internal map array with mapping to all available data\nvar internalFuncLookups map[string]Info = map[string]Info{\n\t\"fields\": {\n\t\tDescription: \"Example fields for generating csv, json, xml, etc\",\n\t\tOutput:      \"gofakeit.Field\",\n\t\tGenerate: func(f *Faker, m *MapParams, info *Info) (any, error) {\n\t\t\tfunction, _ := GetRandomSimpleFunc(f)\n\t\t\treturn Field{\n\t\t\t\tName:     function,\n\t\t\t\tFunction: function,\n\t\t\t}, nil\n\t\t},\n\t},\n}\n\n// NewMapParams will create a new MapParams\nfunc NewMapParams() *MapParams {\n\treturn &MapParams{}\n}\n\n// Add will take in a field and value and add it to the map params type\nfunc (m *MapParams) Add(field string, value string) {\n\t_, ok := (*m)[field]\n\tif !ok {\n\t\t(*m)[field] = []string{value}\n\t\treturn\n\t}\n\n\t(*m)[field] = append((*m)[field], value)\n}\n\n// Get will return the array of string from the provided field\nfunc (m *MapParams) Get(field string) []string {\n\treturn (*m)[field]\n}\n\n// Size will return the total size of the underlying map\nfunc (m *MapParams) Size() int {\n\tsize := 0\n\tfor range *m {\n\t\tsize++\n\t}\n\treturn size\n}\n\n// UnmarshalJSON will unmarshal the json into the []string\nfunc (m *MapParamsValue) UnmarshalJSON(data []byte) error {\n\t// check if the data is an array\n\t// if so, marshal it into m\n\tif data[0] == '[' {\n\t\tvar values []any\n\t\terr := json.Unmarshal(data, &values)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\t// convert the values to array of strings\n\t\tfor _, value := range values {\n\t\t\ttypeOf := reflect.TypeOf(value).Kind().String()\n\n\t\t\tif typeOf == \"map\" {\n\t\t\t\tv, err := json.Marshal(value)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t\t*m = append(*m, string(v))\n\t\t\t} else {\n\t\t\t\t*m = append(*m, fmt.Sprintf(\"%v\", value))\n\t\t\t}\n\t\t}\n\t\treturn nil\n\t}\n\n\t// if not, then convert into a string and add it to m\n\tvar s any\n\tif err := json.Unmarshal(data, &s); err != nil {\n\t\treturn err\n\t}\n\n\t*m = append(*m, fmt.Sprintf(\"%v\", s))\n\treturn nil\n}\n\nfunc GetRandomSimpleFunc(f *Faker) (string, Info) {\n\t// Loop through all the functions and add them to a slice\n\tvar keys []string\n\tfor k, info := range FuncLookups {\n\t\t// Only grab simple functions\n\t\tif info.Params == nil {\n\t\t\tkeys = append(keys, k)\n\t\t}\n\t}\n\n\t// Randomly grab a function from the slice\n\trandomKey := randomString(f, keys)\n\n\t// Return the function name and info\n\treturn randomKey, FuncLookups[randomKey]\n}\n\n// AddFuncLookup takes a field and adds it to map\nfunc AddFuncLookup(functionName string, info Info) {\n\tif FuncLookups == nil {\n\t\tFuncLookups = make(map[string]Info)\n\t}\n\n\t// Check content type\n\tif info.ContentType == \"\" {\n\t\tinfo.ContentType = \"text/plain\"\n\t}\n\n\tlockFuncLookups.Lock()\n\tFuncLookups[functionName] = info\n\tlockFuncLookups.Unlock()\n}\n\n// GetFuncLookup will lookup\nfunc GetFuncLookup(functionName string) *Info {\n\tvar info Info\n\tvar ok bool\n\n\t// Check internal functions first\n\tinfo, ok = internalFuncLookups[functionName]\n\tif ok {\n\t\treturn &info\n\t}\n\n\tinfo, ok = FuncLookups[functionName]\n\tif ok {\n\t\treturn &info\n\t}\n\n\treturn nil\n}\n\n// RemoveFuncLookup will remove a function from lookup\nfunc RemoveFuncLookup(functionName string) {\n\t_, ok := FuncLookups[functionName]\n\tif !ok {\n\t\treturn\n\t}\n\n\tlockFuncLookups.Lock()\n\tdelete(FuncLookups, functionName)\n\tlockFuncLookups.Unlock()\n}\n\n// GetAny will retrieve Any field from Info\nfunc (i *Info) GetAny(m *MapParams, field string) (any, error) {\n\t_, value, err := i.GetField(m, field)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Make sure value[0] exists\n\tif len(value) == 0 {\n\t\treturn nil, fmt.Errorf(\"could not find field: %s\", field)\n\t}\n\n\tvar anyValue any\n\n\t// Try to convert to int\n\tvalueInt, err := strconv.ParseInt(value[0], 10, 64)\n\tif err == nil {\n\t\treturn int(valueInt), nil\n\t}\n\n\t// Try to convert to float\n\tvalueFloat, err := strconv.ParseFloat(value[0], 64)\n\tif err == nil {\n\t\treturn valueFloat, nil\n\t}\n\n\t// Try to convert to boolean\n\tvalueBool, err := strconv.ParseBool(value[0])\n\tif err == nil {\n\t\treturn valueBool, nil\n\t}\n\n\terr = json.Unmarshal([]byte(value[0]), &anyValue)\n\tif err == nil {\n\t\treturn valueBool, nil\n\t}\n\n\treturn value[0], nil\n}\n\n// GetMap will retrieve map[string]any field from data\nfunc (i *Info) GetMap(m *MapParams, field string) (map[string]any, error) {\n\t_, value, err := i.GetField(m, field)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tvar mapValue map[string]any\n\terr = json.Unmarshal([]byte(value[0]), &mapValue)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"%s field could not parse to map[string]any\", field)\n\t}\n\n\treturn mapValue, nil\n}\n\n// GetField will retrieve field from data\nfunc (i *Info) GetField(m *MapParams, field string) (*Param, []string, error) {\n\t// Get param\n\tvar p *Param\n\tfor _, param := range i.Params {\n\t\tif param.Field == field {\n\t\t\tp = &param\n\t\t\tbreak\n\t\t}\n\t}\n\tif p == nil {\n\t\treturn nil, nil, fmt.Errorf(\"could not find param field %s\", field)\n\t}\n\n\t// Get value from map\n\tif m != nil {\n\t\tvalue, ok := (*m)[field]\n\t\tif !ok {\n\t\t\t// If default isnt empty use default\n\t\t\tif p.Default != \"\" {\n\t\t\t\treturn p, []string{p.Default}, nil\n\t\t\t}\n\n\t\t\treturn nil, nil, fmt.Errorf(\"could not find field: %s\", field)\n\t\t}\n\n\t\treturn p, value, nil\n\t} else if p.Default != \"\" {\n\t\t// If p.Type is []uint, then we need to convert it to []string\n\t\tif strings.HasPrefix(p.Default, \"[\") {\n\t\t\t// Remove [] from type\n\t\t\tdefaultClean := p.Default[1 : len(p.Default)-1]\n\n\t\t\t// Split on comma\n\t\t\tdefaultSplit := strings.Split(defaultClean, \",\")\n\n\t\t\treturn p, defaultSplit, nil\n\t\t}\n\n\t\t// If default isnt empty use default\n\t\treturn p, []string{p.Default}, nil\n\t}\n\n\treturn nil, nil, fmt.Errorf(\"could not find field: %s\", field)\n}\n\n// GetBool will retrieve boolean field from data\nfunc (i *Info) GetBool(m *MapParams, field string) (bool, error) {\n\tp, value, err := i.GetField(m, field)\n\tif err != nil {\n\t\treturn false, err\n\t}\n\n\t// Try to convert to boolean\n\tvalueBool, err := strconv.ParseBool(value[0])\n\tif err != nil {\n\t\treturn false, fmt.Errorf(\"%s field could not parse to bool value\", p.Field)\n\t}\n\n\treturn valueBool, nil\n}\n\n// GetInt will retrieve int field from data\nfunc (i *Info) GetInt(m *MapParams, field string) (int, error) {\n\tp, value, err := i.GetField(m, field)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\n\t// Try to convert to int\n\tvalueInt, err := strconv.ParseInt(value[0], 10, 64)\n\tif err != nil {\n\t\treturn 0, fmt.Errorf(\"%s field could not parse to int value\", p.Field)\n\t}\n\n\treturn int(valueInt), nil\n}\n\n// GetUint will retrieve uint field from data\nfunc (i *Info) GetUint(m *MapParams, field string) (uint, error) {\n\tp, value, err := i.GetField(m, field)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\n\t// Try to convert to int\n\tvalueUint, err := strconv.ParseUint(value[0], 10, 64)\n\tif err != nil {\n\t\treturn 0, fmt.Errorf(\"%s field could not parse to int value\", p.Field)\n\t}\n\n\treturn uint(valueUint), nil\n}\n\n// GetFloat32 will retrieve int field from data\nfunc (i *Info) GetFloat32(m *MapParams, field string) (float32, error) {\n\tp, value, err := i.GetField(m, field)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\n\t// Try to convert to float\n\tvalueFloat, err := strconv.ParseFloat(value[0], 32)\n\tif err != nil {\n\t\treturn 0, fmt.Errorf(\"%s field could not parse to float value\", p.Field)\n\t}\n\n\treturn float32(valueFloat), nil\n}\n\n// GetFloat64 will retrieve int field from data\nfunc (i *Info) GetFloat64(m *MapParams, field string) (float64, error) {\n\tp, value, err := i.GetField(m, field)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\n\t// Try to convert to float\n\tvalueFloat, err := strconv.ParseFloat(value[0], 64)\n\tif err != nil {\n\t\treturn 0, fmt.Errorf(\"%s field could not parse to float value\", p.Field)\n\t}\n\n\treturn valueFloat, nil\n}\n\n// GetString will retrieve string field from data\nfunc (i *Info) GetString(m *MapParams, field string) (string, error) {\n\t_, value, err := i.GetField(m, field)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\treturn value[0], nil\n}\n\n// GetStringArray will retrieve []string field from data\nfunc (i *Info) GetStringArray(m *MapParams, field string) ([]string, error) {\n\t_, values, err := i.GetField(m, field)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn values, nil\n}\n\n// GetIntArray will retrieve []int field from data\nfunc (i *Info) GetIntArray(m *MapParams, field string) ([]int, error) {\n\t_, value, err := i.GetField(m, field)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tvar ints []int\n\tfor i := 0; i < len(value); i++ {\n\t\tvalueInt, err := strconv.ParseInt(value[i], 10, 64)\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"%s value could not parse to int\", value[i])\n\t\t}\n\t\tints = append(ints, int(valueInt))\n\t}\n\n\treturn ints, nil\n}\n\n// GetUintArray will retrieve []uint field from data\nfunc (i *Info) GetUintArray(m *MapParams, field string) ([]uint, error) {\n\t_, value, err := i.GetField(m, field)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tvar uints []uint\n\tfor i := 0; i < len(value); i++ {\n\t\tvalueUint, err := strconv.ParseUint(value[i], 10, 64)\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"%s value could not parse to uint\", value[i])\n\t\t}\n\t\tuints = append(uints, uint(valueUint))\n\t}\n\n\treturn uints, nil\n}\n\n// GetFloat32Array will retrieve []float field from data\nfunc (i *Info) GetFloat32Array(m *MapParams, field string) ([]float32, error) {\n\t_, value, err := i.GetField(m, field)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tvar floats []float32\n\tfor i := 0; i < len(value); i++ {\n\t\tvalueFloat, err := strconv.ParseFloat(value[i], 32)\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"%s value could not parse to float\", value[i])\n\t\t}\n\t\tfloats = append(floats, float32(valueFloat))\n\t}\n\n\treturn floats, nil\n}\n"
        },
        {
          "name": "lookup_test.go",
          "type": "blob",
          "size": 12.55078125,
          "content": "package gofakeit\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"math/rand/v2\"\n\t\"strings\"\n\t\"testing\"\n)\n\nfunc Example_custom() {\n\tSeed(11)\n\n\tAddFuncLookup(\"friendname\", Info{\n\t\tCategory:    \"custom\",\n\t\tDescription: \"Random friend name\",\n\t\tExample:     \"bill\",\n\t\tOutput:      \"string\",\n\t\tGenerate: func(f *Faker, m *MapParams, info *Info) (any, error) {\n\t\t\treturn RandomString([]string{\"bill\", \"bob\", \"sally\"}), nil\n\t\t},\n\t})\n\n\ttype Foo struct {\n\t\tFriendName string `fake:\"{friendname}\"`\n\t}\n\n\tvar f Foo\n\tStruct(&f)\n\n\tfmt.Printf(\"%s\", f.FriendName)\n\n\t// Output: sally\n}\n\nfunc Example_custom_with_params() {\n\tSeed(11)\n\n\tAddFuncLookup(\"jumbleword\", Info{\n\t\tCategory:    \"jumbleword\",\n\t\tDescription: \"Take a word and jumple it up\",\n\t\tExample:     \"loredlowlh\",\n\t\tOutput:      \"string\",\n\t\tParams: []Param{\n\t\t\t{Field: \"word\", Type: \"int\", Description: \"Word you want to jumble\"},\n\t\t},\n\t\tGenerate: func(f *Faker, m *MapParams, info *Info) (any, error) {\n\t\t\tword, err := info.GetString(m, \"word\")\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\n\t\t\tsplit := strings.Split(word, \"\")\n\t\t\tf.ShuffleStrings(split)\n\t\t\treturn strings.Join(split, \"\"), nil\n\t\t},\n\t})\n\n\ttype Foo struct {\n\t\tJumbleWord string `fake:\"{jumbleword:helloworld}\"`\n\t}\n\n\tvar f Foo\n\tStruct(&f)\n\n\tfmt.Printf(\"%s\", f.JumbleWord)\n\n\t// Output: hldoolewrl\n}\n\nfunc TestMapParamsGet(t *testing.T) {\n\tmapParams := MapParams{\n\t\t\"name\": []string{\"bill\"},\n\t}\n\n\t// Test get string\n\tval := mapParams.Get(\"name\")\n\tif val[0] != \"bill\" {\n\t\tt.Fatalf(\"Expected bill but got %s\", val)\n\t}\n\n\t// Test get from field that doesnt exist\n\tval = mapParams.Get(\"age\")\n\tif len(val) != 0 {\n\t\tt.Fatalf(\"Expected empty slice but got %s\", val)\n\t}\n}\n\nfunc TestMapParamsMarshalJSON(t *testing.T) {\n\tmp := NewMapParams()\n\tmp.Add(\"name\", \"billy\")\n\tmp.Add(\"field\", `{name: \"billy\"}`)\n\n\t// Test marshal into JSON\n\tjsonData, err := json.Marshal(mp)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\t// t.Fatal(string(jsonData))\n\n\t// Unmarshal into MapParams\n\tvar mapData MapParams\n\terr = json.Unmarshal(jsonData, &mapData)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\t// t.Fatalf(\"%+v\", mapData)\n}\n\nfunc TestMapParamsValueUnmarshalJSON(t *testing.T) {\n\tmapParamStr := `{\"name\":[\"billy\",\"mister\"],\"nickname\":\"big boy\",\"age\":[10],\"weight\":200}`\n\n\t// Test unmarshal into MapParams\n\tvar mapData MapParams\n\terr := json.Unmarshal([]byte(mapParamStr), &mapData)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t// Check to make sure we have the right data\n\tif len(mapData) != 4 {\n\t\tt.Fatalf(\"Expected 4 params, got %d\", len(mapData))\n\t}\n\n\tif len(mapData[\"name\"]) != 2 {\n\t\tt.Fatalf(\"Expected 2 names, got %d\", len(mapData[\"name\"]))\n\t} else {\n\t\tif mapData[\"name\"][0] != \"billy\" {\n\t\t\tt.Fatalf(\"Expected billy, got %s\", mapData[\"name\"][0])\n\t\t}\n\t\tif mapData[\"name\"][1] != \"mister\" {\n\t\t\tt.Fatalf(\"Expected mister, got %s\", mapData[\"name\"][1])\n\t\t}\n\t}\n\n\tif len(mapData[\"nickname\"]) != 1 {\n\t\tt.Fatalf(\"Expected 1 nickname, got %d\", len(mapData[\"nickname\"]))\n\t} else {\n\t\tif mapData[\"nickname\"][0] != \"big boy\" {\n\t\t\tt.Fatalf(\"Expected first value of nickname to be big boy but got %s\", mapData[\"nickname\"][0])\n\t\t}\n\t}\n\n\tif len(mapData[\"age\"]) != 1 {\n\t\tt.Fatalf(\"Expected 1 age, got %d\", len(mapData[\"age\"]))\n\t} else {\n\t\tif mapData[\"age\"][0] != \"10\" {\n\t\t\tt.Fatalf(\"Expected first value of age to be 10 but got %s\", mapData[\"age\"][0])\n\t\t}\n\t}\n\n\tif len(mapData[\"weight\"]) != 1 {\n\t\tt.Fatalf(\"Expected 1 weight, got %d\", len(mapData[\"weight\"]))\n\t} else {\n\t\tif mapData[\"weight\"][0] != \"200\" {\n\t\t\tt.Fatalf(\"Expected first value of weight to be 200 but got %s\", mapData[\"weight\"][0])\n\t\t}\n\t}\n}\n\nfunc TestLookupChecking(t *testing.T) {\n\tfaker := New(0)\n\n\tfor field, info := range FuncLookups {\n\t\tvar mapData MapParams\n\t\tif info.Params != nil && len(info.Params) != 0 {\n\t\t\t// Make sure mapdata is set\n\t\t\tif mapData == nil {\n\t\t\t\tmapData = make(MapParams)\n\t\t\t}\n\n\t\t\t// Loop through params and add fields to mapdata\n\t\t\tfor _, p := range info.Params {\n\t\t\t\t// If default is empty and has options randomly pick one\n\t\t\t\tif p.Default == \"\" && len(p.Options) != 0 {\n\t\t\t\t\tmapData[p.Field] = []string{p.Options[rand.IntN(len(p.Options))]}\n\t\t\t\t\tcontinue\n\t\t\t\t} else if p.Default != \"\" {\n\t\t\t\t\t// If p.Type is []uint, then we need to convert it to []string\n\t\t\t\t\tif strings.HasPrefix(p.Type, \"[\") {\n\t\t\t\t\t\t// Remove [] from type\n\t\t\t\t\t\tdefaultClean := p.Default[1 : len(p.Default)-1]\n\t\t\t\t\t\tmapData[p.Field] = strings.Split(defaultClean, \",\")\n\t\t\t\t\t} else {\n\t\t\t\t\t\tmapData[p.Field] = []string{p.Default}\n\t\t\t\t\t}\n\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\n\t\t\t\tswitch p.Type {\n\t\t\t\tcase \"bool\":\n\t\t\t\t\tmapData[p.Field] = []string{fmt.Sprintf(\"%v\", Bool())}\n\t\t\t\tcase \"string\":\n\t\t\t\t\tmapData[p.Field] = []string{Letter()}\n\t\t\t\tcase \"uint\":\n\t\t\t\t\tmapData[p.Field] = []string{fmt.Sprintf(\"%v\", Uint16())}\n\t\t\t\tcase \"int\":\n\t\t\t\t\tmapData[p.Field] = []string{fmt.Sprintf(\"%v\", Int16())}\n\t\t\t\tcase \"float\":\n\t\t\t\t\tmapData[p.Field] = []string{fmt.Sprintf(\"%v\", Float32())}\n\t\t\t\tcase \"[]string\":\n\t\t\t\t\tmapData[p.Field] = []string{Letter(), Letter(), Letter(), Letter()}\n\t\t\t\tcase \"[]int\":\n\t\t\t\t\tmapData[p.Field] = []string{fmt.Sprintf(\"%d\", Int8()), fmt.Sprintf(\"%d\", Int8()), fmt.Sprintf(\"%d\", Int8()), fmt.Sprintf(\"%d\", Int8())}\n\t\t\t\tcase \"[]uint\":\n\t\t\t\t\tmapData[p.Field] = []string{fmt.Sprintf(\"%d\", Uint8()), fmt.Sprintf(\"%d\", Uint8()), fmt.Sprintf(\"%d\", Uint8()), fmt.Sprintf(\"%d\", Uint8())}\n\t\t\t\tcase \"[]float\":\n\t\t\t\t\tmapData[p.Field] = []string{fmt.Sprintf(\"%v\", Float32()), fmt.Sprintf(\"%v\", Float32()), fmt.Sprintf(\"%v\", Float32()), fmt.Sprintf(\"%v\", Float32())}\n\t\t\t\tcase \"[]Field\":\n\t\t\t\t\tmapData[p.Field] = []string{`{\"name\":\"first_name\",\"function\":\"firstname\"}`}\n\t\t\t\tcase \"interface\":\n\t\t\t\t\tmapData[p.Field] = []string{Letter()}\n\t\t\t\tcase \"any\":\n\t\t\t\t\tmapData[p.Field] = []string{Letter()}\n\t\t\t\tdefault:\n\t\t\t\t\tt.Fatalf(\"Looking for %s but switch case doesnt have it\", p.Type)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t_, err := info.Generate(faker, &mapData, &info)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"%s failed - Err: %s - Data: %v\", field, err, mapData)\n\t\t}\n\t}\n}\n\n// Make sure all lookups have specific fields\nfunc TestLookupCheckFields(t *testing.T) {\n\tfor field, info := range FuncLookups {\n\t\tif info.Display == \"\" {\n\t\t\tt.Fatalf(\"%s is missing a display\", field)\n\t\t}\n\t\tif info.Category == \"\" {\n\t\t\tt.Fatalf(\"%s is missing a category\", field)\n\t\t}\n\t\tif info.Example == \"\" {\n\t\t\tt.Fatalf(\"%s is missing an example\", field)\n\t\t}\n\t\tif info.Output == \"\" {\n\t\t\tt.Fatalf(\"%s is misssing output\", field)\n\t\t}\n\n\t\t// Check params\n\t\tif info.Params != nil {\n\t\t\tfor _, p := range info.Params {\n\t\t\t\tif p.Field == \"\" {\n\t\t\t\t\tt.Fatalf(\"Field %s param %s is missing a field\", field, p.Field)\n\t\t\t\t}\n\t\t\t\tif p.Display == \"\" {\n\t\t\t\t\tt.Fatalf(\"Field %s param %s is missing a display\", field, p.Field)\n\t\t\t\t}\n\t\t\t\tif p.Type == \"\" {\n\t\t\t\t\tt.Fatalf(\"Field %s param %s is missing a type\", field, p.Field)\n\t\t\t\t}\n\t\t\t\tif p.Description == \"\" {\n\t\t\t\t\tt.Fatalf(\"Field %s param %s is missing a description\", field, p.Field)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc TestLookupRemove(t *testing.T) {\n\tfuncName := \"friendname\"\n\n\tAddFuncLookup(funcName, Info{\n\t\tCategory:    \"custom\",\n\t\tDescription: \"Random friend name\",\n\t\tExample:     \"bill\",\n\t\tOutput:      \"string\",\n\t\tGenerate: func(f *Faker, m *MapParams, info *Info) (any, error) {\n\t\t\treturn RandomString([]string{\"bill\", \"bob\", \"sally\"}), nil\n\t\t},\n\t})\n\n\tinfo := GetFuncLookup(funcName)\n\tif info == nil {\n\t\tt.Fatal(\"Could not find lookup\")\n\t}\n\n\tRemoveFuncLookup(funcName)\n\n\tinfo = GetFuncLookup(funcName)\n\tif info != nil {\n\t\tt.Fatal(\"Got info when I shouldn't have\")\n\t}\n}\n\nfunc TestLookupCalls(t *testing.T) {\n\tfaker := New(0)\n\n\tfor _, info := range FuncLookups {\n\t\tmapData := make(MapParams)\n\n\t\t// If parameters are required build it\n\t\tif info.Params != nil && len(info.Params) != 0 {\n\t\t\t// Loop through params and add fields to mapdata\n\t\t\tfor _, p := range info.Params {\n\t\t\t\t// If default is empty and has options randomly pick one\n\t\t\t\tif p.Default == \"\" && len(p.Options) != 0 {\n\t\t\t\t\tmapData.Add(p.Field, p.Options[faker.IntN(len(p.Options))])\n\t\t\t\t\tcontinue\n\t\t\t\t} else if p.Default != \"\" {\n\t\t\t\t\t// If p.Type is []uint, then we need to convert it to []string\n\t\t\t\t\tif strings.HasPrefix(p.Type, \"[\") {\n\t\t\t\t\t\t// Remove [] from type\n\t\t\t\t\t\tdefaultClean := p.Default[1 : len(p.Default)-1]\n\n\t\t\t\t\t\t// Split on comma\n\t\t\t\t\t\tdefaultSplit := strings.Split(defaultClean, \",\")\n\n\t\t\t\t\t\t// Loop through defaultSplit and add to mapData\n\t\t\t\t\t\tfor _, s := range defaultSplit {\n\t\t\t\t\t\t\tmapData.Add(p.Field, s)\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tmapData.Add(p.Field, p.Default)\n\t\t\t\t\t}\n\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\n\t\t\t\tswitch p.Type {\n\t\t\t\tcase \"bool\":\n\t\t\t\t\tmapData.Add(p.Field, fmt.Sprintf(\"%v\", Bool()))\n\t\t\t\tcase \"string\":\n\t\t\t\t\tmapData.Add(p.Field, Letter())\n\t\t\t\tcase \"uint\":\n\t\t\t\t\tmapData.Add(p.Field, fmt.Sprintf(\"%v\", Uint16()))\n\t\t\t\tcase \"int\":\n\t\t\t\t\tmapData.Add(p.Field, fmt.Sprintf(\"%v\", Int16()))\n\t\t\t\tcase \"float\":\n\t\t\t\t\tmapData.Add(p.Field, fmt.Sprintf(\"%v\", Float32()))\n\t\t\t\tcase \"[]string\":\n\t\t\t\t\tmapData.Add(p.Field, Letter())\n\t\t\t\t\tmapData.Add(p.Field, Letter())\n\t\t\t\t\tmapData.Add(p.Field, Letter())\n\t\t\t\t\tmapData.Add(p.Field, Letter())\n\t\t\t\tcase \"[]int\":\n\t\t\t\t\tmapData.Add(p.Field, fmt.Sprintf(\"%d\", Int8()))\n\t\t\t\t\tmapData.Add(p.Field, fmt.Sprintf(\"%d\", Int8()))\n\t\t\t\t\tmapData.Add(p.Field, fmt.Sprintf(\"%d\", Int8()))\n\t\t\t\t\tmapData.Add(p.Field, fmt.Sprintf(\"%d\", Int8()))\n\t\t\t\tcase \"[]uint\":\n\t\t\t\t\tmapData.Add(p.Field, fmt.Sprintf(\"%d\", Uint8()))\n\t\t\t\t\tmapData.Add(p.Field, fmt.Sprintf(\"%d\", Uint8()))\n\t\t\t\t\tmapData.Add(p.Field, fmt.Sprintf(\"%d\", Uint8()))\n\t\t\t\t\tmapData.Add(p.Field, fmt.Sprintf(\"%d\", Uint8()))\n\t\t\t\tcase \"[]float\":\n\t\t\t\t\tmapData.Add(p.Field, fmt.Sprintf(\"%v\", Float32()))\n\t\t\t\t\tmapData.Add(p.Field, fmt.Sprintf(\"%v\", Float32()))\n\t\t\t\t\tmapData.Add(p.Field, fmt.Sprintf(\"%v\", Float32()))\n\t\t\t\t\tmapData.Add(p.Field, fmt.Sprintf(\"%v\", Float32()))\n\t\t\t\tcase \"[]Field\":\n\t\t\t\t\tmapData.Add(p.Field, `{\"name\":\"first_name\",\"function\":\"firstname\"}`)\n\t\t\t\tcase \"any\":\n\t\t\t\t\tmapData[p.Field] = []string{Letter()}\n\t\t\t\tdefault:\n\t\t\t\t\tt.Fatalf(\"Looking for %s but switch case doesnt have it\", p.Type)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t_, err := info.Generate(faker, &mapData, &info)\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\n\t}\n}\n\nfunc TestLookupCallsErrorParams(t *testing.T) {\n\t// Look through lookups and empty defaults values to help with tests\n\tfor funcName, info := range FuncLookups {\n\t\tif info.Params != nil || len(info.Params) != 0 {\n\t\t\tparams := []Param{}\n\t\t\tfor _, p := range info.Params {\n\t\t\t\tp.Default = \"\"\n\t\t\t\tparams = append(params, p)\n\t\t\t}\n\t\t\tinfo.Params = params\n\n\t\t\tAddFuncLookup(funcName, info)\n\t\t}\n\t}\n\n\t// Initiate new faker\n\tfaker := New(0)\n\n\tfor funcName, info := range FuncLookups {\n\t\t// If parameters are not required skip it. We are only testing params\n\t\tif info.Params == nil || len(info.Params) == 0 {\n\t\t\tcontinue\n\t\t}\n\n\t\t// Loop through each param and mark each one fail\n\t\tfor i := 0; i < len(info.Params); i++ {\n\t\t\tmapData := NewMapParams()\n\t\t\tskip := false\n\t\t\tcurrentEmptyParam := \"\"\n\n\t\t\t// Loop through params and add fields to mapdata\n\t\t\tfor ii, p := range info.Params {\n\t\t\t\t// If the length is equal to the param loop\n\t\t\t\t// purposly not add that field to trigger an error\n\t\t\t\tif i == ii {\n\t\t\t\t\tcurrentEmptyParam = p.Field\n\n\t\t\t\t\t// If param is optional skip it\n\t\t\t\t\tif p.Optional {\n\t\t\t\t\t\tskip = true\n\t\t\t\t\t}\n\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\n\t\t\t\tif p.Default != \"\" {\n\t\t\t\t\tmapData.Add(p.Field, p.Default)\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\n\t\t\t\tswitch p.Type {\n\t\t\t\tcase \"bool\":\n\t\t\t\t\tmapData.Add(p.Field, fmt.Sprintf(\"%v\", Bool()))\n\t\t\t\tcase \"string\":\n\t\t\t\t\tmapData.Add(p.Field, Letter())\n\t\t\t\tcase \"uint\":\n\t\t\t\t\tmapData.Add(p.Field, fmt.Sprintf(\"%v\", Uint16()))\n\t\t\t\tcase \"int\":\n\t\t\t\t\tmapData.Add(p.Field, fmt.Sprintf(\"%v\", Int16()))\n\t\t\t\tcase \"float\":\n\t\t\t\t\tmapData.Add(p.Field, fmt.Sprintf(\"%v\", Float32()))\n\t\t\t\tcase \"[]string\":\n\t\t\t\t\tmapData.Add(p.Field, Letter())\n\t\t\t\t\tmapData.Add(p.Field, Letter())\n\t\t\t\t\tmapData.Add(p.Field, Letter())\n\t\t\t\t\tmapData.Add(p.Field, Letter())\n\t\t\t\tcase \"[]int\":\n\t\t\t\t\tmapData.Add(p.Field, fmt.Sprintf(\"%d\", Int8()))\n\t\t\t\t\tmapData.Add(p.Field, fmt.Sprintf(\"%d\", Int8()))\n\t\t\t\t\tmapData.Add(p.Field, fmt.Sprintf(\"%d\", Int8()))\n\t\t\t\t\tmapData.Add(p.Field, fmt.Sprintf(\"%d\", Int8()))\n\t\t\t\tcase \"[]uint\":\n\t\t\t\t\tmapData.Add(p.Field, fmt.Sprintf(\"%d\", Uint8()))\n\t\t\t\t\tmapData.Add(p.Field, fmt.Sprintf(\"%d\", Uint8()))\n\t\t\t\t\tmapData.Add(p.Field, fmt.Sprintf(\"%d\", Uint8()))\n\t\t\t\t\tmapData.Add(p.Field, fmt.Sprintf(\"%d\", Uint8()))\n\t\t\t\tcase \"[]float\":\n\t\t\t\t\tmapData.Add(p.Field, fmt.Sprintf(\"%v\", Float32()))\n\t\t\t\t\tmapData.Add(p.Field, fmt.Sprintf(\"%v\", Float32()))\n\t\t\t\t\tmapData.Add(p.Field, fmt.Sprintf(\"%v\", Float32()))\n\t\t\t\t\tmapData.Add(p.Field, fmt.Sprintf(\"%v\", Float32()))\n\t\t\t\tcase \"[]Field\":\n\t\t\t\t\tmapData.Add(p.Field, `{\"name\":\"first_name\",\"function\":\"firstname\"}`)\n\t\t\t\tdefault:\n\t\t\t\t\tt.Fatalf(\"Looking for %s but switch case doesnt have it\", p.Type)\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif !skip {\n\t\t\t\t_, err := info.Generate(faker, mapData, &info)\n\t\t\t\tif err == nil {\n\t\t\t\t\tt.Error(funcName+\" should have failed on param\", currentEmptyParam)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// Reset lookup functions back\n\tinitLookup()\n}\n"
        },
        {
          "name": "lorem.go",
          "type": "blob",
          "size": 5.6337890625,
          "content": "package gofakeit\n\nimport (\n\t\"errors\"\n)\n\n// LoremIpsumWord will generate a random word\nfunc LoremIpsumWord() string { return loremIpsumWord(GlobalFaker) }\n\n// LoremIpsumWord will generate a random word\nfunc (f *Faker) LoremIpsumWord() string { return loremIpsumWord(f) }\n\nfunc loremIpsumWord(f *Faker) string { return getRandValue(f, []string{\"lorem\", \"word\"}) }\n\n// LoremIpsumSentence will generate a random sentence\nfunc LoremIpsumSentence(wordCount int) string {\n\treturn loremIpsumSentence(GlobalFaker, wordCount)\n}\n\n// LoremIpsumSentence will generate a random sentence\nfunc (f *Faker) LoremIpsumSentence(wordCount int) string {\n\treturn loremIpsumSentence(f, wordCount)\n}\n\nfunc loremIpsumSentence(f *Faker, wordCount int) string {\n\treturn sentenceGen(f, wordCount, loremIpsumWord)\n}\n\n// LoremIpsumParagraph will generate a random paragraphGenerator\nfunc LoremIpsumParagraph(paragraphCount int, sentenceCount int, wordCount int, separator string) string {\n\treturn loremIpsumParagraph(GlobalFaker, paragraphCount, sentenceCount, wordCount, separator)\n}\n\n// LoremIpsumParagraph will generate a random paragraphGenerator\nfunc (f *Faker) LoremIpsumParagraph(paragraphCount int, sentenceCount int, wordCount int, separator string) string {\n\treturn loremIpsumParagraph(f, paragraphCount, sentenceCount, wordCount, separator)\n}\n\nfunc loremIpsumParagraph(f *Faker, paragraphCount int, sentenceCount int, wordCount int, separator string) string {\n\treturn paragraphGen(f, paragrapOptions{paragraphCount, sentenceCount, wordCount, separator}, loremIpsumSentence)\n}\n\nfunc addLoremLookup() {\n\tAddFuncLookup(\"loremipsumword\", Info{\n\t\tDisplay:     \"Lorem Ipsum Word\",\n\t\tCategory:    \"word\",\n\t\tDescription: \"Word of the Lorem Ipsum placeholder text used in design and publishing\",\n\t\tExample:     \"quia\",\n\t\tOutput:      \"string\",\n\t\tGenerate: func(f *Faker, m *MapParams, info *Info) (any, error) {\n\t\t\treturn loremIpsumWord(f), nil\n\t\t},\n\t})\n\n\tAddFuncLookup(\"loremipsumsentence\", Info{\n\t\tDisplay:     \"Lorem Ipsum Sentence\",\n\t\tCategory:    \"word\",\n\t\tDescription: \"Sentence of the Lorem Ipsum placeholder text used in design and publishing\",\n\t\tExample:     \"Quia quae repellat consequatur quidem.\",\n\t\tOutput:      \"string\",\n\t\tParams: []Param{\n\t\t\t{Field: \"wordcount\", Display: \"Word Count\", Type: \"int\", Default: \"5\", Description: \"Number of words in a sentence\"},\n\t\t},\n\t\tGenerate: func(f *Faker, m *MapParams, info *Info) (any, error) {\n\t\t\twordCount, err := info.GetInt(m, \"wordcount\")\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\tif wordCount <= 0 || wordCount > 50 {\n\t\t\t\treturn nil, errors.New(\"invalid word count, must be greater than 0, less than 50\")\n\t\t\t}\n\n\t\t\treturn loremIpsumSentence(f, wordCount), nil\n\t\t},\n\t})\n\n\tAddFuncLookup(\"loremipsumparagraph\", Info{\n\t\tDisplay:     \"Lorem Ipsum Paragraph\",\n\t\tCategory:    \"word\",\n\t\tDescription: \"Paragraph of the Lorem Ipsum placeholder text used in design and publishing\",\n\t\tExample: `Quia quae repellat consequatur quidem nisi quo qui voluptatum accusantium quisquam amet. Quas et ut non dolorem ipsam aut enim assumenda mollitia harum ut. Dicta similique veniam nulla voluptas at excepturi non ad maxime at non. Eaque hic repellat praesentium voluptatem qui consequuntur dolor iusto autem velit aut. Fugit tempore exercitationem harum consequatur voluptatum modi minima aut eaque et et.\n\nAut ea voluptatem dignissimos expedita odit tempore quod aut beatae ipsam iste. Minus voluptatibus dolorem maiores eius sed nihil vel enim odio voluptatem accusamus. Natus quibusdam temporibus tenetur cumque sint necessitatibus dolorem ex ducimus iusto ex. Voluptatem neque dicta explicabo officiis et ducimus sit ut ut praesentium pariatur. Illum molestias nisi at dolore ut voluptatem accusantium et fugiat et ut.\n\nExplicabo incidunt reprehenderit non quia dignissimos recusandae vitae soluta quia et quia. Aut veniam voluptas consequatur placeat sapiente non eveniet voluptatibus magni velit eum. Nobis vel repellendus sed est qui autem laudantium quidem quam ullam consequatur. Aut iusto ut commodi similique quae voluptatem atque qui fugiat eum aut. Quis distinctio consequatur voluptatem vel aliquid aut laborum facere officiis iure tempora.`,\n\t\tOutput: \"string\",\n\t\tParams: []Param{\n\t\t\t{Field: \"paragraphcount\", Display: \"Paragraph Count\", Type: \"int\", Default: \"2\", Description: \"Number of paragraphs\"},\n\t\t\t{Field: \"sentencecount\", Display: \"Sentence Count\", Type: \"int\", Default: \"2\", Description: \"Number of sentences in a paragraph\"},\n\t\t\t{Field: \"wordcount\", Display: \"Word Count\", Type: \"int\", Default: \"5\", Description: \"Number of words in a sentence\"},\n\t\t\t{Field: \"paragraphseparator\", Display: \"Paragraph Separator\", Type: \"string\", Default: \"<br />\", Description: \"String value to add between paragraphs\"},\n\t\t},\n\t\tGenerate: func(f *Faker, m *MapParams, info *Info) (any, error) {\n\t\t\tparagraphCount, err := info.GetInt(m, \"paragraphcount\")\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\tif paragraphCount <= 0 || paragraphCount > 20 {\n\t\t\t\treturn nil, errors.New(\"invalid paragraph count, must be greater than 0, less than 20\")\n\t\t\t}\n\n\t\t\tsentenceCount, err := info.GetInt(m, \"sentencecount\")\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\tif sentenceCount <= 0 || sentenceCount > 20 {\n\t\t\t\treturn nil, errors.New(\"invalid sentence count, must be greater than 0, less than 20\")\n\t\t\t}\n\n\t\t\twordCount, err := info.GetInt(m, \"wordcount\")\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\tif wordCount <= 0 || wordCount > 50 {\n\t\t\t\treturn nil, errors.New(\"invalid word count, must be greater than 0, less than 50\")\n\t\t\t}\n\n\t\t\tparagraphSeparator, err := info.GetString(m, \"paragraphseparator\")\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\n\t\t\treturn loremIpsumParagraph(f, paragraphCount, sentenceCount, wordCount, paragraphSeparator), nil\n\t\t},\n\t})\n}\n"
        },
        {
          "name": "lorem_test.go",
          "type": "blob",
          "size": 3.9912109375,
          "content": "package gofakeit\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc ExampleLoremIpsumWord() {\n\tSeed(11)\n\tfmt.Println(LoremIpsumWord())\n\n\t// Output: eveniet\n}\n\nfunc ExampleFaker_LoremIpsumWord() {\n\tf := New(11)\n\tfmt.Println(f.LoremIpsumWord())\n\n\t// Output: eveniet\n}\n\nfunc BenchmarkLoremIpsumWord(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tLoremIpsumWord()\n\t}\n}\n\nfunc ExampleLoremIpsumSentence() {\n\tSeed(11)\n\tfmt.Println(LoremIpsumSentence(5))\n\n\t// Output: Eveniet vero velit velit non.\n}\n\nfunc ExampleFaker_LoremIpsumSentence() {\n\tf := New(11)\n\tfmt.Println(f.LoremIpsumSentence(5))\n\n\t// Output: Eveniet vero velit velit non.\n}\n\nfunc TestLoremIpsumSentence(t *testing.T) {\n\tfor _, count := range []int{-100, -1, 0} {\n\t\tif LoremIpsumSentence(count) != \"\" {\n\t\t\tt.Errorf(\"result should be blank for %d words\", count)\n\t\t}\n\t}\n}\n\nfunc BenchmarkLoremIpsumSentence(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tLoremIpsumSentence(10)\n\t}\n}\n\nfunc ExampleLoremIpsumParagraph() {\n\tSeed(11)\n\tfmt.Println(LoremIpsumParagraph(3, 5, 12, \"\\n\"))\n\n\t// Output: Eveniet vero velit velit non incidunt est sed tenetur consequatur ut architecto. Quod non non et voluptas et esse quisquam ullam placeat molestiae laboriosam. Consequatur in perferendis molestiae quam voluptatem eaque quia facilis quo hic dignissimos. Architecto ut tenetur aut qui et optio id sint quae rerum labore. Quae deserunt quia mollitia id accusantium itaque nisi aut omnis occaecati repellendus.\n\t// Ad sunt neque placeat et qui saepe voluptatem blanditiis voluptatum possimus saepe. Velit distinctio quia quas cupiditate sequi dolorum delectus quia quo corrupti labore. Aut mollitia et aut eligendi blanditiis corrupti aut rem voluptatibus veritatis ut. Et ab voluptas delectus repellat eligendi qui eos blanditiis et et eos. Qui ipsum aut ut voluptate nulla officia qui earum repudiandae quidem officia.\n\t// Fugit esse beatae placeat nihil libero et sunt voluptas velit maiores voluptatem. Reiciendis quia dolor amet blanditiis labore eligendi fugit reiciendis modi est incidunt. Ut ut rerum odit sit voluptatem ipsam consequatur est incidunt aut quis. Non dolorem voluptatum pariatur esse eos blanditiis rem eos commodi accusamus occaecati. Qui voluptatem eos et tempora et id at voluptas suscipit magni cupiditate.\n}\n\nfunc ExampleFaker_LoremIpsumParagraph() {\n\tf := New(11)\n\tfmt.Println(f.LoremIpsumParagraph(3, 5, 12, \"\\n\"))\n\n\t// Output: Eveniet vero velit velit non incidunt est sed tenetur consequatur ut architecto. Quod non non et voluptas et esse quisquam ullam placeat molestiae laboriosam. Consequatur in perferendis molestiae quam voluptatem eaque quia facilis quo hic dignissimos. Architecto ut tenetur aut qui et optio id sint quae rerum labore. Quae deserunt quia mollitia id accusantium itaque nisi aut omnis occaecati repellendus.\n\t// Ad sunt neque placeat et qui saepe voluptatem blanditiis voluptatum possimus saepe. Velit distinctio quia quas cupiditate sequi dolorum delectus quia quo corrupti labore. Aut mollitia et aut eligendi blanditiis corrupti aut rem voluptatibus veritatis ut. Et ab voluptas delectus repellat eligendi qui eos blanditiis et et eos. Qui ipsum aut ut voluptate nulla officia qui earum repudiandae quidem officia.\n\t// Fugit esse beatae placeat nihil libero et sunt voluptas velit maiores voluptatem. Reiciendis quia dolor amet blanditiis labore eligendi fugit reiciendis modi est incidunt. Ut ut rerum odit sit voluptatem ipsam consequatur est incidunt aut quis. Non dolorem voluptatum pariatur esse eos blanditiis rem eos commodi accusamus occaecati. Qui voluptatem eos et tempora et id at voluptas suscipit magni cupiditate.\n}\n\nfunc TestLoremIpsumParagraph(t *testing.T) {\n\tfor _, count := range []struct{ parag, sent, words int }{\n\t\t{1, 1, 0},\n\t\t{1, 0, 1},\n\t\t{0, 1, 1},\n\t\t{1, 1, -100},\n\t\t{1, -100, 1},\n\t\t{-100, 1, 1},\n\t\t{0, 0, 0},\n\t} {\n\t\tif LoremIpsumParagraph(count.parag, count.sent, count.words, \" \") != \"\" {\n\t\t\tt.Errorf(\"result should be blank for %v input\", count)\n\t\t}\n\t}\n}\n\nfunc BenchmarkLoremIpsumParagraph(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tLoremIpsumParagraph(3, 5, 12, \"\\n\")\n\t}\n}\n"
        },
        {
          "name": "minecraft.go",
          "type": "blob",
          "size": 13.244140625,
          "content": "package gofakeit\n\n// MinecraftOre will generate a random Minecraft ore\nfunc MinecraftOre() string { return minecraftOre(GlobalFaker) }\n\n// MinecraftOre will generate a random Minecraft ore\nfunc (f *Faker) MinecraftOre() string { return minecraftOre(f) }\n\nfunc minecraftOre(f *Faker) string { return getRandValue(f, []string{\"minecraft\", \"ore\"}) }\n\n// MinecraftWood will generate a random Minecraft wood\nfunc MinecraftWood() string { return minecraftWood(GlobalFaker) }\n\n// MinecraftWood will generate a random Minecraft wood\nfunc (f *Faker) MinecraftWood() string { return minecraftWood(f) }\n\nfunc minecraftWood(f *Faker) string { return getRandValue(f, []string{\"minecraft\", \"wood\"}) }\n\n// MinecraftArmorTier will generate a random Minecraft armor tier\nfunc MinecraftArmorTier() string { return minecraftArmorTier(GlobalFaker) }\n\n// MinecraftArmorTier will generate a random Minecraft armor tier\nfunc (f *Faker) MinecraftArmorTier() string { return minecraftArmorTier(f) }\n\nfunc minecraftArmorTier(f *Faker) string {\n\treturn getRandValue(f, []string{\"minecraft\", \"armortier\"})\n}\n\n// MinecraftArmorPart will generate a random Minecraft armor part\nfunc MinecraftArmorPart() string { return minecraftArmorPart(GlobalFaker) }\n\n// MinecraftArmorPart will generate a random Minecraft armor part\nfunc (f *Faker) MinecraftArmorPart() string { return minecraftArmorPart(f) }\n\nfunc minecraftArmorPart(f *Faker) string {\n\treturn getRandValue(f, []string{\"minecraft\", \"armorpart\"})\n}\n\n// MinecraftWeapon will generate a random Minecraft weapon\nfunc MinecraftWeapon() string { return minecraftWeapon(GlobalFaker) }\n\n// MinecraftWeapon will generate a random Minecraft weapon\nfunc (f *Faker) MinecraftWeapon() string { return minecraftWeapon(f) }\n\nfunc minecraftWeapon(f *Faker) string { return getRandValue(f, []string{\"minecraft\", \"weapon\"}) }\n\n// MinecraftTool will generate a random Minecraft tool\nfunc MinecraftTool() string { return minecraftTool(GlobalFaker) }\n\n// MinecraftTool will generate a random Minecraft tool\nfunc (f *Faker) MinecraftTool() string { return minecraftTool(f) }\n\nfunc minecraftTool(f *Faker) string { return getRandValue(f, []string{\"minecraft\", \"tool\"}) }\n\n// MinecraftDye will generate a random Minecraft dye\nfunc MinecraftDye() string { return minecraftDye(GlobalFaker) }\n\n// MinecraftDye will generate a random Minecraft dye\nfunc (f *Faker) MinecraftDye() string { return minecraftDye(f) }\n\nfunc minecraftDye(f *Faker) string { return getRandValue(f, []string{\"minecraft\", \"dye\"}) }\n\n// MinecraftFood will generate a random Minecraft food\nfunc MinecraftFood() string { return minecraftFood(GlobalFaker) }\n\n// MinecraftFood will generate a random Minecraft food\nfunc (f *Faker) MinecraftFood() string { return minecraftFood(f) }\n\nfunc minecraftFood(f *Faker) string { return getRandValue(f, []string{\"minecraft\", \"food\"}) }\n\n// MinecraftAnimal will generate a random Minecraft animal\nfunc MinecraftAnimal() string { return minecraftAnimal(GlobalFaker) }\n\n// MinecraftAnimal will generate a random Minecraft animal\nfunc (f *Faker) MinecraftAnimal() string { return minecraftAnimal(f) }\n\nfunc minecraftAnimal(f *Faker) string {\n\treturn getRandValue(f, []string{\"minecraft\", \"animal\"})\n}\n\n// MinecraftVillagerJob will generate a random Minecraft villager job\nfunc MinecraftVillagerJob() string { return minecraftVillagerJob(GlobalFaker) }\n\n// MinecraftVillagerJob will generate a random Minecraft villager job\nfunc (f *Faker) MinecraftVillagerJob() string { return minecraftVillagerJob(f) }\n\nfunc minecraftVillagerJob(f *Faker) string {\n\treturn getRandValue(f, []string{\"minecraft\", \"villagerjob\"})\n}\n\n// MinecraftVillagerStation will generate a random Minecraft villager station\nfunc MinecraftVillagerStation() string { return minecraftVillagerStation(GlobalFaker) }\n\n// MinecraftVillagerStation will generate a random Minecraft villager station\nfunc (f *Faker) MinecraftVillagerStation() string { return minecraftVillagerStation(f) }\n\nfunc minecraftVillagerStation(f *Faker) string {\n\treturn getRandValue(f, []string{\"minecraft\", \"villagerstation\"})\n}\n\n// MinecraftVillagerLevel will generate a random Minecraft villager level\nfunc MinecraftVillagerLevel() string { return minecraftVillagerLevel(GlobalFaker) }\n\n// MinecraftVillagerLevel will generate a random Minecraft villager level\nfunc (f *Faker) MinecraftVillagerLevel() string { return minecraftVillagerLevel(f) }\n\nfunc minecraftVillagerLevel(f *Faker) string {\n\treturn getRandValue(f, []string{\"minecraft\", \"villagerlevel\"})\n}\n\n// MinecraftMobPassive will generate a random Minecraft mob passive\nfunc MinecraftMobPassive() string { return minecraftMobPassive(GlobalFaker) }\n\n// MinecraftMobPassive will generate a random Minecraft mob passive\nfunc (f *Faker) MinecraftMobPassive() string { return minecraftMobPassive(f) }\n\nfunc minecraftMobPassive(f *Faker) string {\n\treturn getRandValue(f, []string{\"minecraft\", \"mobpassive\"})\n}\n\n// MinecraftMobNeutral will generate a random Minecraft mob neutral\nfunc MinecraftMobNeutral() string { return minecraftMobNeutral(GlobalFaker) }\n\n// MinecraftMobNeutral will generate a random Minecraft mob neutral\nfunc (f *Faker) MinecraftMobNeutral() string { return minecraftMobNeutral(f) }\n\nfunc minecraftMobNeutral(f *Faker) string {\n\treturn getRandValue(f, []string{\"minecraft\", \"mobneutral\"})\n}\n\n// MinecraftMobHostile will generate a random Minecraft mob hostile\nfunc MinecraftMobHostile() string { return minecraftMobHostile(GlobalFaker) }\n\n// MinecraftMobHostile will generate a random Minecraft mob hostile\nfunc (f *Faker) MinecraftMobHostile() string { return minecraftMobHostile(f) }\n\nfunc minecraftMobHostile(f *Faker) string {\n\treturn getRandValue(f, []string{\"minecraft\", \"mobhostile\"})\n}\n\n// MinecraftMobBoss will generate a random Minecraft mob boss\nfunc MinecraftMobBoss() string { return minecraftMobBoss(GlobalFaker) }\n\n// MinecraftMobBoss will generate a random Minecraft mob boss\nfunc (f *Faker) MinecraftMobBoss() string { return minecraftMobBoss(f) }\n\nfunc minecraftMobBoss(f *Faker) string {\n\treturn getRandValue(f, []string{\"minecraft\", \"mobboss\"})\n}\n\n// MinecraftBiome will generate a random Minecraft biome\nfunc MinecraftBiome() string { return minecraftBiome(GlobalFaker) }\n\n// MinecraftBiome will generate a random Minecraft biome\nfunc (f *Faker) MinecraftBiome() string { return minecraftBiome(f) }\n\nfunc minecraftBiome(f *Faker) string { return getRandValue(f, []string{\"minecraft\", \"biome\"}) }\n\n// MinecraftWeather will generate a random Minecraft weather\nfunc MinecraftWeather() string { return minecraftWeather(GlobalFaker) }\n\n// MinecraftWeather will generate a random Minecraft weather\nfunc (f *Faker) MinecraftWeather() string { return minecraftWeather(f) }\n\nfunc minecraftWeather(f *Faker) string { return getRandValue(f, []string{\"minecraft\", \"weather\"}) }\n\nfunc addMinecraftLookup() {\n\tAddFuncLookup(\"minecraftore\", Info{\n\t\tDisplay:     \"Minecraft ore\",\n\t\tCategory:    \"minecraft\",\n\t\tDescription: \"Naturally occurring minerals found in the game Minecraft, used for crafting purposes\",\n\t\tExample:     \"coal\",\n\t\tOutput:      \"string\",\n\t\tGenerate: func(f *Faker, m *MapParams, info *Info) (any, error) {\n\t\t\treturn minecraftOre(f), nil\n\t\t},\n\t})\n\n\tAddFuncLookup(\"minecraftwood\", Info{\n\t\tDisplay:     \"Minecraft wood\",\n\t\tCategory:    \"minecraft\",\n\t\tDescription: \"Natural resource in Minecraft, used for crafting various items and building structures\",\n\t\tExample:     \"oak\",\n\t\tOutput:      \"string\",\n\t\tGenerate: func(f *Faker, m *MapParams, info *Info) (any, error) {\n\t\t\treturn minecraftWood(f), nil\n\t\t},\n\t})\n\n\tAddFuncLookup(\"minecraftarmortier\", Info{\n\t\tDisplay:     \"Minecraft armor tier\",\n\t\tCategory:    \"minecraft\",\n\t\tDescription: \"Classification system for armor sets in Minecraft, indicating their effectiveness and protection level\",\n\t\tExample:     \"iron\",\n\t\tOutput:      \"string\",\n\t\tGenerate: func(f *Faker, m *MapParams, info *Info) (any, error) {\n\t\t\treturn minecraftArmorTier(f), nil\n\t\t},\n\t})\n\n\tAddFuncLookup(\"minecraftarmorpart\", Info{\n\t\tDisplay:     \"Minecraft armor part\",\n\t\tCategory:    \"minecraft\",\n\t\tDescription: \"Component of an armor set in Minecraft, such as a helmet, chestplate, leggings, or boots\",\n\t\tExample:     \"helmet\",\n\t\tOutput:      \"string\",\n\t\tGenerate: func(f *Faker, m *MapParams, info *Info) (any, error) {\n\t\t\treturn minecraftArmorPart(f), nil\n\t\t},\n\t})\n\n\tAddFuncLookup(\"minecraftweapon\", Info{\n\t\tDisplay:     \"Minecraft weapon\",\n\t\tCategory:    \"minecraft\",\n\t\tDescription: \"Tools and items used in Minecraft for combat and defeating hostile mobs\",\n\t\tExample:     \"bow\",\n\t\tOutput:      \"string\",\n\t\tGenerate: func(f *Faker, m *MapParams, info *Info) (any, error) {\n\t\t\treturn minecraftWeapon(f), nil\n\t\t},\n\t})\n\n\tAddFuncLookup(\"minecrafttool\", Info{\n\t\tDisplay:     \"Minecraft tool\",\n\t\tCategory:    \"minecraft\",\n\t\tDescription: \"Items in Minecraft designed for specific tasks, including mining, digging, and building\",\n\t\tExample:     \"shovel\",\n\t\tOutput:      \"string\",\n\t\tGenerate: func(f *Faker, m *MapParams, info *Info) (any, error) {\n\t\t\treturn minecraftTool(f), nil\n\t\t},\n\t})\n\n\tAddFuncLookup(\"minecraftdye\", Info{\n\t\tDisplay:     \"Minecraft dye\",\n\t\tCategory:    \"minecraft\",\n\t\tDescription: \"Items used to change the color of various in-game objects\",\n\t\tExample:     \"white\",\n\t\tOutput:      \"string\",\n\t\tGenerate: func(f *Faker, m *MapParams, info *Info) (any, error) {\n\t\t\treturn minecraftDye(f), nil\n\t\t},\n\t})\n\n\tAddFuncLookup(\"minecraftfood\", Info{\n\t\tDisplay:     \"Minecraft food\",\n\t\tCategory:    \"minecraft\",\n\t\tDescription: \"Consumable items in Minecraft that provide nourishment to the player character\",\n\t\tExample:     \"apple\",\n\t\tOutput:      \"string\",\n\t\tGenerate: func(f *Faker, m *MapParams, info *Info) (any, error) {\n\t\t\treturn minecraftFood(f), nil\n\t\t},\n\t})\n\n\tAddFuncLookup(\"minecraftanimal\", Info{\n\t\tDisplay:     \"Minecraft animal\",\n\t\tCategory:    \"minecraft\",\n\t\tDescription: \"Non-hostile creatures in Minecraft, often used for resources and farming\",\n\t\tExample:     \"chicken\",\n\t\tOutput:      \"string\",\n\t\tGenerate: func(f *Faker, m *MapParams, info *Info) (any, error) {\n\t\t\treturn minecraftAnimal(f), nil\n\t\t},\n\t})\n\n\tAddFuncLookup(\"minecraftvillagerjob\", Info{\n\t\tDisplay:     \"Minecraft villager job\",\n\t\tCategory:    \"minecraft\",\n\t\tDescription: \"The profession or occupation assigned to a villager character in the game\",\n\t\tExample:     \"farmer\",\n\t\tOutput:      \"string\",\n\t\tGenerate: func(f *Faker, m *MapParams, info *Info) (any, error) {\n\t\t\treturn minecraftVillagerJob(f), nil\n\t\t},\n\t})\n\n\tAddFuncLookup(\"minecraftvillagerstation\", Info{\n\t\tDisplay:     \"Minecraft villager station\",\n\t\tCategory:    \"minecraft\",\n\t\tDescription: \"Designated area or structure in Minecraft where villagers perform their job-related tasks and trading\",\n\t\tExample:     \"furnace\",\n\t\tOutput:      \"string\",\n\t\tGenerate: func(f *Faker, m *MapParams, info *Info) (any, error) {\n\t\t\treturn minecraftVillagerStation(f), nil\n\t\t},\n\t})\n\n\tAddFuncLookup(\"minecraftvillagerlevel\", Info{\n\t\tDisplay:     \"Minecraft villager level\",\n\t\tCategory:    \"minecraft\",\n\t\tDescription: \"Measure of a villager's experience and proficiency in their assigned job or profession\",\n\t\tExample:     \"master\",\n\t\tOutput:      \"string\",\n\t\tGenerate: func(f *Faker, m *MapParams, info *Info) (any, error) {\n\t\t\treturn minecraftVillagerLevel(f), nil\n\t\t},\n\t})\n\n\tAddFuncLookup(\"minecraftmobpassive\", Info{\n\t\tDisplay:     \"Minecraft mob passive\",\n\t\tCategory:    \"minecraft\",\n\t\tDescription: \"Non-aggressive creatures in the game that do not attack players\",\n\t\tExample:     \"cow\",\n\t\tOutput:      \"string\",\n\t\tGenerate: func(f *Faker, m *MapParams, info *Info) (any, error) {\n\t\t\treturn minecraftMobPassive(f), nil\n\t\t},\n\t})\n\n\tAddFuncLookup(\"minecraftmobneutral\", Info{\n\t\tDisplay:     \"Minecraft mob neutral\",\n\t\tCategory:    \"minecraft\",\n\t\tDescription: \"Creature in the game that only becomes hostile if provoked, typically defending itself when attacked\",\n\t\tExample:     \"bee\",\n\t\tOutput:      \"string\",\n\t\tGenerate: func(f *Faker, m *MapParams, info *Info) (any, error) {\n\t\t\treturn minecraftMobNeutral(f), nil\n\t\t},\n\t})\n\n\tAddFuncLookup(\"minecraftmobhostile\", Info{\n\t\tDisplay:     \"Minecraft mob hostile\",\n\t\tCategory:    \"minecraft\",\n\t\tDescription: \"Aggressive creatures in the game that actively attack players when encountered\",\n\t\tExample:     \"spider\",\n\t\tOutput:      \"string\",\n\t\tGenerate: func(f *Faker, m *MapParams, info *Info) (any, error) {\n\t\t\treturn minecraftMobHostile(f), nil\n\t\t},\n\t})\n\n\tAddFuncLookup(\"minecraftmobboss\", Info{\n\t\tDisplay:     \"Minecraft mob boss\",\n\t\tCategory:    \"minecraft\",\n\t\tDescription: \"Powerful hostile creature in the game, often found in challenging dungeons or structures\",\n\t\tExample:     \"ender dragon\",\n\t\tOutput:      \"string\",\n\t\tGenerate: func(f *Faker, m *MapParams, info *Info) (any, error) {\n\t\t\treturn minecraftMobBoss(f), nil\n\t\t},\n\t})\n\n\tAddFuncLookup(\"minecraftbiome\", Info{\n\t\tDisplay:     \"Minecraft biome\",\n\t\tCategory:    \"minecraft\",\n\t\tDescription: \"Distinctive environmental regions in the game, characterized by unique terrain, vegetation, and weather\",\n\t\tExample:     \"forest\",\n\t\tOutput:      \"string\",\n\t\tGenerate: func(f *Faker, m *MapParams, info *Info) (any, error) {\n\t\t\treturn minecraftBiome(f), nil\n\t\t},\n\t})\n\n\tAddFuncLookup(\"minecraftweather\", Info{\n\t\tDisplay:     \"Minecraft weather\",\n\t\tCategory:    \"minecraft\",\n\t\tDescription: \"Atmospheric conditions in the game that include rain, thunderstorms, and clear skies, affecting gameplay and ambiance\",\n\t\tExample:     \"rain\",\n\t\tOutput:      \"string\",\n\t\tGenerate: func(f *Faker, m *MapParams, info *Info) (any, error) {\n\t\t\treturn minecraftWeather(f), nil\n\t\t},\n\t})\n}\n"
        },
        {
          "name": "minecraft_test.go",
          "type": "blob",
          "size": 5.6806640625,
          "content": "package gofakeit\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc ExampleMinecraftOre() {\n\tSeed(11)\n\tfmt.Println(MinecraftOre())\n\n\t// Output: redstone\n}\n\nfunc ExampleFaker_MinecraftOre() {\n\tf := New(11)\n\tfmt.Println(f.MinecraftOre())\n\n\t// Output: redstone\n}\n\nfunc BenchmarkMinecraftOre(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tMinecraftOre()\n\t}\n}\n\nfunc ExampleMinecraftWood() {\n\tSeed(11)\n\tfmt.Println(MinecraftWood())\n\n\t// Output: dark oak\n}\n\nfunc ExampleFaker_MinecraftWood() {\n\tf := New(11)\n\tfmt.Println(f.MinecraftWood())\n\n\t// Output: dark oak\n}\n\nfunc BenchmarkMinecraftWood(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tMinecraftWood()\n\t}\n}\n\nfunc ExampleMinecraftArmorTier() {\n\tSeed(11)\n\tfmt.Println(MinecraftArmorTier())\n\n\t// Output: netherite\n}\n\nfunc ExampleFaker_MinecraftArmorTier() {\n\tf := New(11)\n\tfmt.Println(f.MinecraftArmorTier())\n\n\t// Output: netherite\n}\n\nfunc BenchmarkMinecraftArmorTier(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tMinecraftArmorTier()\n\t}\n}\n\nfunc ExampleMinecraftArmorPart() {\n\tSeed(11)\n\tfmt.Println(MinecraftArmorPart())\n\n\t// Output:\n\t// helmet\n}\n\nfunc ExampleFaker_MinecraftArmorPart() {\n\tf := New(11)\n\tfmt.Println(f.MinecraftArmorPart())\n\n\t// Output:\n\t// helmet\n}\n\nfunc BenchmarkMinecraftArmorPart(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tMinecraftArmorPart()\n\t}\n}\n\nfunc ExampleMinecraftWeapon() {\n\tSeed(11)\n\tfmt.Println(MinecraftWeapon())\n\n\t// Output: shield\n}\n\nfunc ExampleFaker_MinecraftWeapon() {\n\tf := New(11)\n\tfmt.Println(f.MinecraftWeapon())\n\n\t// Output: shield\n}\n\nfunc BenchmarkMinecraftWeapon(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tMinecraftWeapon()\n\t}\n}\n\nfunc ExampleMinecraftTool() {\n\tSeed(11)\n\tfmt.Println(MinecraftTool())\n\n\t// Output: fishing rod\n}\n\nfunc ExampleFaker_MinecraftTool() {\n\tf := New(11)\n\tfmt.Println(f.MinecraftTool())\n\n\t// Output: fishing rod\n}\n\nfunc BenchmarkMinecraftTool(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tMinecraftTool()\n\t}\n}\n\nfunc ExampleMinecraftDye() {\n\tSeed(11)\n\tfmt.Println(MinecraftDye())\n\n\t// Output: yellow\n}\n\nfunc ExampleFaker_MinecraftDye() {\n\tf := New(11)\n\tfmt.Println(f.MinecraftDye())\n\n\t// Output: yellow\n}\n\nfunc BenchmarkMinecraftDye(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tMinecraftDye()\n\t}\n}\n\nfunc ExampleMinecraftFood() {\n\tSeed(11)\n\tfmt.Println(MinecraftFood())\n\n\t// Output: steak\n}\n\nfunc ExampleFaker_MinecraftFood() {\n\tf := New(11)\n\tfmt.Println(f.MinecraftFood())\n\n\t// Output: steak\n}\n\nfunc BenchmarkMinecraftFood(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tMinecraftFood()\n\t}\n}\n\nfunc ExampleMinecraftAnimal() {\n\tSeed(11)\n\tfmt.Println(MinecraftAnimal())\n\n\t// Output: wolf\n}\n\nfunc ExampleFaker_MinecraftAnimal() {\n\tf := New(11)\n\tfmt.Println(f.MinecraftAnimal())\n\n\t// Output: wolf\n}\n\nfunc BenchmarkMinecraftAnimal(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tMinecraftAnimal()\n\t}\n}\n\nfunc ExampleMinecraftVillagerJob() {\n\tSeed(11)\n\tfmt.Println(MinecraftVillagerJob())\n\n\t// Output: toolsmith\n}\n\nfunc ExampleFaker_MinecraftVillagerJob() {\n\tf := New(11)\n\tfmt.Println(f.MinecraftVillagerJob())\n\n\t// Output:\n\t// toolsmith\n}\n\nfunc BenchmarkMinecraftVillagerJob(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tMinecraftVillagerJob()\n\t}\n}\n\nfunc ExampleMinecraftVillagerStation() {\n\tSeed(11)\n\tfmt.Println(MinecraftVillagerStation())\n\n\t// Output: stonecutter\n}\n\nfunc ExampleFaker_MinecraftVillagerStation() {\n\tf := New(11)\n\tfmt.Println(f.MinecraftVillagerStation())\n\n\t// Output: stonecutter\n}\n\nfunc BenchmarkMinecraftVillagerStation(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tMinecraftVillagerStation()\n\t}\n}\n\nfunc ExampleMinecraftVillagerLevel() {\n\tSeed(11)\n\tfmt.Println(MinecraftVillagerLevel())\n\n\t// Output: master\n}\n\nfunc ExampleFaker_MinecraftVillagerLevel() {\n\tf := New(11)\n\tfmt.Println(f.MinecraftVillagerLevel())\n\n\t// Output: master\n}\n\nfunc BenchmarkMinecraftVillagerLevel(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tMinecraftVillagerLevel()\n\t}\n}\n\nfunc ExampleMinecraftMobPassive() {\n\tSeed(11)\n\tfmt.Println(MinecraftMobPassive())\n\n\t// Output: turtle\n}\n\nfunc ExampleFaker_MinecraftMobPassive() {\n\tf := New(11)\n\tfmt.Println(f.MinecraftMobPassive())\n\n\t// Output: turtle\n}\n\nfunc BenchmarkMinecraftMobPassive(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tMinecraftMobPassive()\n\t}\n}\n\nfunc ExampleMinecraftMobNeutral() {\n\tSeed(11)\n\tfmt.Println(MinecraftMobNeutral())\n\n\t// Output: wolf\n}\n\nfunc ExampleFaker_MinecraftMobNeutral() {\n\tf := New(11)\n\tfmt.Println(f.MinecraftMobNeutral())\n\n\t// Output:\n\t// wolf\n}\n\nfunc BenchmarkMinecraftMobNeutral(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tMinecraftMobNeutral()\n\t}\n}\n\nfunc ExampleMinecraftMobHostile() {\n\tSeed(11)\n\tfmt.Println(MinecraftMobHostile())\n\n\t// Output: wither skeleton\n}\n\nfunc ExampleFaker_MinecraftMobHostile() {\n\tf := New(11)\n\tfmt.Println(f.MinecraftMobHostile())\n\n\t// Output: wither skeleton\n}\n\nfunc BenchmarkMinecraftMobHostile(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tMinecraftMobHostile()\n\t}\n}\n\nfunc ExampleMinecraftMobBoss() {\n\tSeed(11)\n\tfmt.Println(MinecraftMobBoss())\n\n\t// Output:\n\t// ender dragon\n}\n\nfunc ExampleFaker_MinecraftMobBoss() {\n\tf := New(11)\n\tfmt.Println(f.MinecraftMobBoss())\n\n\t// Output:\n\t// ender dragon\n}\n\nfunc BenchmarkMinecraftMobBoss(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tMinecraftMobBoss()\n\t}\n}\n\nfunc ExampleMinecraftBiome() {\n\tSeed(11)\n\tfmt.Println(MinecraftBiome())\n\n\t// Output: the nether\n}\n\nfunc ExampleFaker_MinecraftBiome() {\n\tf := New(11)\n\tfmt.Println(f.MinecraftBiome())\n\n\t// Output: the nether\n}\n\nfunc BenchmarkMinecraftBiome(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tMinecraftBiome()\n\t}\n}\n\nfunc ExampleMinecraftWeather() {\n\tSeed(11)\n\tfmt.Println(MinecraftWeather())\n\n\t// Output: thunder\n}\n\nfunc ExampleFaker_MinecraftWeather() {\n\tf := New(11)\n\tfmt.Println(f.MinecraftWeather())\n\n\t// Output: thunder\n}\n\nfunc BenchmarkMinecraftWeather(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tMinecraftWeather()\n\t}\n}\n"
        },
        {
          "name": "misc.go",
          "type": "blob",
          "size": 4.21484375,
          "content": "package gofakeit\n\nimport (\n\t\"encoding/hex\"\n\t\"reflect\"\n\n\t\"github.com/brianvoe/gofakeit/v7/data\"\n)\n\n// Bool will generate a random boolean value\nfunc Bool() bool { return boolFunc(GlobalFaker) }\n\n// Bool will generate a random boolean value\nfunc (f *Faker) Bool() bool { return boolFunc(f) }\n\nfunc boolFunc(f *Faker) bool { return randIntRange(f, 0, 1) == 1 }\n\n// UUID (version 4) will generate a random unique identifier based upon random numbers\n// Format: xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx\nfunc UUID() string { return uuid(GlobalFaker) }\n\n// UUID (version 4) will generate a random unique identifier based upon random numbers\n// Format: xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx 8-4-4-4-12\nfunc (f *Faker) UUID() string { return uuid(f) }\n\nfunc uuid(f *Faker) string {\n\tversion := byte(4)\n\tuuid := make([]byte, 16)\n\n\t// Read 16 random bytes\n\tfor i := 0; i < 16; i++ {\n\t\tuuid[i] = byte(f.IntN(256))\n\t}\n\n\t// Set version\n\tuuid[6] = (uuid[6] & 0x0f) | (version << 4)\n\n\t// Set variant\n\tuuid[8] = (uuid[8] & 0xbf) | 0x80\n\n\tbuf := make([]byte, 36)\n\thex.Encode(buf[0:8], uuid[0:4])\n\tbuf[8] = dash\n\thex.Encode(buf[9:13], uuid[4:6])\n\tbuf[13] = dash\n\thex.Encode(buf[14:18], uuid[6:8])\n\tbuf[18] = dash\n\thex.Encode(buf[19:23], uuid[8:10])\n\tbuf[23] = dash\n\thex.Encode(buf[24:], uuid[10:])\n\n\treturn string(buf)\n}\n\n// ShuffleAnySlice takes in a slice and outputs it in a random order\nfunc ShuffleAnySlice(v any) { shuffleAnySlice(GlobalFaker, v) }\n\n// ShuffleAnySlice takes in a slice and outputs it in a random order\nfunc (f *Faker) ShuffleAnySlice(v any) { shuffleAnySlice(f, v) }\n\nfunc shuffleAnySlice(f *Faker, v any) {\n\tif v == nil {\n\t\treturn\n\t}\n\n\t// Check type of passed in value, if not a slice return with no action taken\n\ttyp := reflect.TypeOf(v)\n\tif typ.Kind() != reflect.Slice {\n\t\treturn\n\t}\n\n\ts := reflect.ValueOf(v)\n\tn := s.Len()\n\n\tif n <= 1 {\n\t\treturn\n\t}\n\n\tswap := func(i, j int) {\n\t\ttmp := reflect.ValueOf(s.Index(i).Interface())\n\t\ts.Index(i).Set(s.Index(j))\n\t\ts.Index(j).Set(tmp)\n\t}\n\n\t//if size is > int32 probably it will never finish, or ran out of entropy\n\ti := n - 1\n\tfor ; i > 0; i-- {\n\t\tj := int(int32NFunc(f, int32(i+1)))\n\t\tswap(i, j)\n\t}\n}\n\n// FlipACoin will return a random value of Heads or Tails\nfunc FlipACoin() string { return flipACoin(GlobalFaker) }\n\n// FlipACoin will return a random value of Heads or Tails\nfunc (f *Faker) FlipACoin() string { return flipACoin(f) }\n\nfunc flipACoin(f *Faker) string {\n\tif boolFunc(f) {\n\t\treturn \"Heads\"\n\t}\n\n\treturn \"Tails\"\n}\n\n// RandomMapKey will return a random key from a map\nfunc RandomMapKey(mapI any) any { return randomMapKey(GlobalFaker, mapI) }\n\n// RandomMapKey will return a random key from a map\nfunc (f *Faker) RandomMapKey(mapI any) any { return randomMapKey(f, mapI) }\n\nfunc randomMapKey(f *Faker, mapI any) any {\n\tkeys := reflect.ValueOf(mapI).MapKeys()\n\treturn keys[f.IntN(len(keys))].Interface()\n}\n\n// Categories will return a map string array of available data categories and sub categories\nfunc Categories() map[string][]string {\n\ttypes := make(map[string][]string)\n\tfor category, subCategoriesMap := range data.Data {\n\t\tsubCategories := make([]string, 0)\n\t\tfor subType := range subCategoriesMap {\n\t\t\tsubCategories = append(subCategories, subType)\n\t\t}\n\t\ttypes[category] = subCategories\n\t}\n\treturn types\n}\n\nfunc addMiscLookup() {\n\tAddFuncLookup(\"uuid\", Info{\n\t\tDisplay:     \"UUID\",\n\t\tCategory:    \"misc\",\n\t\tDescription: \"128-bit identifier used to uniquely identify objects or entities in computer systems\",\n\t\tExample:     \"590c1440-9888-45b0-bd51-a817ee07c3f2\",\n\t\tOutput:      \"string\",\n\t\tGenerate: func(f *Faker, m *MapParams, info *Info) (any, error) {\n\t\t\treturn uuid(f), nil\n\t\t},\n\t})\n\n\tAddFuncLookup(\"bool\", Info{\n\t\tDisplay:     \"Boolean\",\n\t\tCategory:    \"misc\",\n\t\tDescription: \"Data type that represents one of two possible values, typically true or false\",\n\t\tExample:     \"true\",\n\t\tOutput:      \"bool\",\n\t\tGenerate: func(f *Faker, m *MapParams, info *Info) (any, error) {\n\t\t\treturn boolFunc(f), nil\n\t\t},\n\t})\n\n\tAddFuncLookup(\"flipacoin\", Info{\n\t\tDisplay:     \"Flip A Coin\",\n\t\tCategory:    \"misc\",\n\t\tDescription: \"Decision-making method involving the tossing of a coin to determine outcomes\",\n\t\tExample:     \"Tails\",\n\t\tOutput:      \"string\",\n\t\tGenerate: func(f *Faker, m *MapParams, info *Info) (any, error) {\n\t\t\treturn flipACoin(f), nil\n\t\t},\n\t})\n}\n"
        },
        {
          "name": "misc_test.go",
          "type": "blob",
          "size": 3.8740234375,
          "content": "package gofakeit\n\nimport (\n\t\"fmt\"\n\t\"reflect\"\n\t\"sort\"\n\t\"testing\"\n\n\t\"github.com/brianvoe/gofakeit/v7/data\"\n)\n\nfunc ExampleBool() {\n\tSeed(11)\n\tfmt.Println(Bool())\n\n\t// Output: false\n}\n\nfunc ExampleFaker_Bool() {\n\tf := New(11)\n\tfmt.Println(f.Bool())\n\n\t// Output: false\n}\n\nfunc BenchmarkBool(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tBool()\n\t}\n}\n\nfunc TestUUID(t *testing.T) {\n\tid := UUID()\n\n\tif len(id) != 36 {\n\t\tt.Error(id)\n\t\tt.Error(\"unique length does not equal requested length\")\n\t}\n\n\t// Checking for race conditions, need to run --race\n\tfor i := 0; i < 10000; i++ {\n\t\tgo func() {\n\t\t\t_ = UUID()\n\t\t}()\n\t}\n}\n\nfunc ExampleUUID() {\n\tSeed(11)\n\tfmt.Println(UUID())\n\n\t// Output: b412b5fb-33a4-498e-9503-21c6b7e01dcf\n}\n\nfunc ExampleFaker_UUID() {\n\tf := New(11)\n\tfmt.Println(f.UUID())\n\n\t// Output: b412b5fb-33a4-498e-9503-21c6b7e01dcf\n}\n\nfunc BenchmarkUUID(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tUUID()\n\t}\n}\n\nfunc TestShuffleAnySlice(t *testing.T) {\n\tShuffleAnySlice(nil)           // Should do nothing\n\tShuffleAnySlice(\"b\")           // Should do nothing\n\tShuffleAnySlice([]string{\"b\"}) // If single value should do nothing\n\n\ta := []string{\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\"}\n\tb := make([]string, len(a))\n\tcopy(b, a)\n\tShuffleAnySlice(a)\n\tif equalSliceString(a, b) {\n\t\tt.Errorf(\"shuffle strings resulted in the same permutation, the odds are slim\")\n\t}\n\n\tn := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 0}\n\tm := make([]int, len(n))\n\tcopy(m, n)\n\tShuffleAnySlice(n)\n\tif equalSliceInt(n, m) {\n\t\tt.Errorf(\"shuffle ints resulted in the same permutation, the odds are slim\")\n\t}\n\n\ti := []any{\"a\", 1, \"c\", 3, []string{\"a\", \"b\", \"c\"}, -555, []byte{1, 5}, \"h\"}\n\tii := make([]any, len(i))\n\tcopy(ii, i)\n\tShuffleAnySlice(i)\n\tif equalSliceInterface(i, ii) {\n\t\tt.Errorf(\"shuffle interface resulted in the same permutation, the odds are slim\")\n\t}\n}\n\nfunc ExampleShuffleAnySlice() {\n\tSeed(11)\n\n\tstrings := []string{\"happy\", \"times\", \"for\", \"everyone\", \"have\", \"a\", \"good\", \"day\"}\n\tShuffleAnySlice(strings)\n\tfmt.Println(strings)\n\n\tints := []int{52, 854, 941, 74125, 8413, 777, 89416, 841657}\n\tShuffleAnySlice(ints)\n\tfmt.Println(ints)\n\n\t// Output: [for day happy everyone good times a have]\n\t// [854 52 74125 941 777 8413 841657 89416]\n}\n\nfunc ExampleFaker_ShuffleAnySlice() {\n\tf := New(11)\n\n\tstrings := []string{\"happy\", \"times\", \"for\", \"everyone\", \"have\", \"a\", \"good\", \"day\"}\n\tf.ShuffleAnySlice(strings)\n\tfmt.Println(strings)\n\n\tints := []int{52, 854, 941, 74125, 8413, 777, 89416, 841657}\n\tf.ShuffleAnySlice(ints)\n\tfmt.Println(ints)\n\n\t// Output: [for day happy everyone good times a have]\n\t// [854 52 74125 941 777 8413 841657 89416]\n}\n\nfunc BenchmarkShuffleAnySlice(b *testing.B) {\n\ta := []any{\"a\", 1, \"c\", 3, []string{\"a\", \"b\", \"c\"}, -555, []byte{1, 5}, \"h\"}\n\tfor i := 0; i < b.N; i++ {\n\t\tShuffleAnySlice(a)\n\t}\n}\n\nfunc ExampleFlipACoin() {\n\tSeed(11)\n\tfmt.Println(FlipACoin())\n\n\t// Output: Tails\n}\n\nfunc ExampleFaker_FlipACoin() {\n\tf := New(11)\n\tfmt.Println(f.FlipACoin())\n\n\t// Output: Tails\n}\n\nfunc TestFlipACoin(t *testing.T) {\n\tfor i := 0; i < 100; i++ {\n\t\tFlipACoin()\n\t}\n}\n\nfunc BenchmarkFlipACoin(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tFlipACoin()\n\t}\n}\n\nfunc TestRandomMapKey(t *testing.T) {\n\tmStr := map[string]int{\n\t\t\"a\": 1,\n\t\t\"b\": 2,\n\t\t\"c\": 3,\n\t}\n\n\tfor i := 0; i < 100; i++ {\n\t\tkey := RandomMapKey(mStr)\n\t\tif _, ok := mStr[key.(string)]; !ok {\n\t\t\tt.Errorf(\"key %s not found in map\", key)\n\t\t}\n\t}\n\n\tmInt := map[int]string{\n\t\t1: \"a\",\n\t\t2: \"b\",\n\t\t3: \"c\",\n\t}\n\n\tfor i := 0; i < 100; i++ {\n\t\tf := New(11)\n\t\tkey := f.RandomMapKey(mInt)\n\t\tif _, ok := mInt[key.(int)]; !ok {\n\t\t\tt.Errorf(\"key %d not found in map\", key)\n\t\t}\n\t}\n}\n\nfunc TestCategories(t *testing.T) {\n\tvar got, expected []string\n\tfor k := range Categories() {\n\t\tgot = append(got, k)\n\t}\n\tfor k := range data.Data {\n\t\texpected = append(expected, k)\n\t}\n\tsort.Strings(got)\n\tsort.Strings(expected)\n\tif !reflect.DeepEqual(got, expected) {\n\t\tt.Error(\"Type arrays are not the same.\\nExpected: \", expected, \"\\nGot: \", got)\n\t}\n}\n"
        },
        {
          "name": "movie.go",
          "type": "blob",
          "size": 1.8017578125,
          "content": "package gofakeit\n\nfunc MovieName() string { return movieName(GlobalFaker) }\n\nfunc (f *Faker) MovieName() string { return movieName(f) }\n\nfunc movieName(f *Faker) string { return getRandValue(f, []string{\"movie\", \"name\"}) }\n\nfunc MovieGenre() string { return movieGenre(GlobalFaker) }\n\nfunc (f *Faker) MovieGenre() string { return movieGenre(f) }\n\nfunc movieGenre(f *Faker) string { return getRandValue(f, []string{\"movie\", \"genre\"}) }\n\ntype MovieInfo struct {\n\tName  string `json:\"name\" xml:\"name\"`\n\tGenre string `json:\"genre\" xml:\"genre\"`\n}\n\nfunc Movie() *MovieInfo { return movie(GlobalFaker) }\n\nfunc (f *Faker) Movie() *MovieInfo { return movie(f) }\n\nfunc movie(f *Faker) *MovieInfo {\n\treturn &MovieInfo{\n\t\tName:  movieName(f),\n\t\tGenre: movieGenre(f),\n\t}\n}\n\nfunc addMovieLookup() {\n\tAddFuncLookup(\"movie\", Info{\n\t\tDisplay:     \"Movie\",\n\t\tCategory:    \"movie\",\n\t\tDescription: \"A story told through moving pictures and sound\",\n\t\tExample: `{\n\t\"name\": \"Psycho\",\n\t\"genre\": \"Mystery\"\n}`,\n\t\tOutput:      \"map[string]string\",\n\t\tContentType: \"application/json\",\n\t\tGenerate: func(f *Faker, m *MapParams, info *Info) (any, error) {\n\t\t\treturn movie(f), nil\n\t\t},\n\t})\n\n\tAddFuncLookup(\"moviename\", Info{\n\t\tDisplay:     \"Movie Name\",\n\t\tCategory:    \"movie\",\n\t\tDescription: \"Title or name of a specific film used for identification and reference\",\n\t\tExample:     \"The Matrix\",\n\t\tOutput:      \"string\",\n\t\tGenerate: func(f *Faker, m *MapParams, info *Info) (any, error) {\n\t\t\treturn movieName(f), nil\n\t\t},\n\t})\n\n\tAddFuncLookup(\"moviegenre\", Info{\n\t\tDisplay:     \"Genre\",\n\t\tCategory:    \"movie\",\n\t\tDescription: \"Category that classifies movies based on common themes, styles, and storytelling approaches\",\n\t\tExample:     \"Action\",\n\t\tOutput:      \"string\",\n\t\tGenerate: func(f *Faker, m *MapParams, info *Info) (any, error) {\n\t\t\treturn movieGenre(f), nil\n\t\t},\n\t})\n}\n"
        },
        {
          "name": "movie_test.go",
          "type": "blob",
          "size": 1.0390625,
          "content": "package gofakeit\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc ExampleMovie() {\n\tSeed(11)\n\tmovie := Movie()\n\tfmt.Println(movie.Name)\n\tfmt.Println(movie.Genre)\n\n\t// Output: The Terminator\n\t// Sport\n}\n\nfunc ExampleFaker_Movie() {\n\tf := New(11)\n\tmovie := f.Movie()\n\tfmt.Println(movie.Name)\n\tfmt.Println(movie.Genre)\n\n\t// Output: The Terminator\n\t// Sport\n}\n\nfunc BenchmarkMovie(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tMovie()\n\t}\n}\n\nfunc TestMovie(t *testing.T) {\n\tfor i := 0; i < 100; i++ {\n\t\tMovie()\n\t}\n}\n\nfunc ExampleMovieName() {\n\tSeed(11)\n\tfmt.Println(MovieName())\n\n\t// Output: The Terminator\n}\n\nfunc ExampleFaker_MovieName() {\n\tf := New(11)\n\tfmt.Println(f.MovieName())\n\n\t// Output: The Terminator\n}\n\nfunc BenchmarkMovieName(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tMovieName()\n\t}\n}\n\nfunc ExampleMovieGenre() {\n\tSeed(11)\n\tfmt.Println(MovieGenre())\n\n\t// Output: Thriller\n}\n\nfunc ExampleFaker_MovieGenre() {\n\tf := New(11)\n\tfmt.Println(f.MovieGenre())\n\n\t// Output: Thriller\n}\n\nfunc BenchmarkMovieGenre(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tMovieGenre()\n\t}\n}\n"
        },
        {
          "name": "number.go",
          "type": "blob",
          "size": 19.86328125,
          "content": "package gofakeit\n\nimport (\n\t\"math\"\n\t\"math/bits\"\n)\n\n// Number will generate a random number between given min and max\nfunc Number(min int, max int) int { return number(GlobalFaker, min, max) }\n\n// Number will generate a random number between given min and max\nfunc (f *Faker) Number(min int, max int) int { return number(f, min, max) }\n\nfunc number(f *Faker, min int, max int) int { return randIntRange(f, min, max) }\n\n// Uint will generate a random uint value\nfunc Uint() uint { return uintFunc(GlobalFaker) }\n\n// Uint will generate a random uint value\nfunc (f *Faker) Uint() uint { return uintFunc(f) }\n\nfunc uintFunc(f *Faker) uint { return uint(f.Uint64()) }\n\n// UintN will generate a random uint value between 0 and n\nfunc UintN(n uint) uint { return uintNFunc(GlobalFaker, n) }\n\n// UintN will generate a random uint value between 0 and n\nfunc (f *Faker) UintN(n uint) uint { return uintNFunc(f, n) }\n\nfunc uintNFunc(f *Faker, n uint) uint {\n\tif n == 0 {\n\t\treturn 0\n\t}\n\treturn uint(uint64NFunc(f, uint64(n)))\n}\n\n// Uint8 will generate a random uint8 value\nfunc Uint8() uint8 { return uint8Func(GlobalFaker) }\n\n// Uint8 will generate a random uint8 value\nfunc (f *Faker) Uint8() uint8 { return uint8Func(f) }\n\nfunc uint8Func(f *Faker) uint8 { return uint8(randIntRange(f, minUint, math.MaxUint8)) }\n\n// Uint16 will generate a random uint16 value\nfunc Uint16() uint16 { return uint16Func(GlobalFaker) }\n\n// Uint16 will generate a random uint16 value\nfunc (f *Faker) Uint16() uint16 { return uint16Func(f) }\n\nfunc uint16Func(f *Faker) uint16 { return uint16(randIntRange(f, minUint, math.MaxUint16)) }\n\n// Uint32 will generate a random uint32 value\nfunc Uint32() uint32 { return uint32Func(GlobalFaker) }\n\n// Uint32 will generate a random uint32 value\nfunc (f *Faker) Uint32() uint32 { return uint32Func(f) }\n\nfunc uint32Func(f *Faker) uint32 { return uint32(f.Uint64() >> 32) }\n\n// Uint64 will generate a random uint64 value\nfunc Uint64() uint64 { return GlobalFaker.Uint64() }\n\n// Uint64 will generate a random uint64 value\n// This is the primary location in which the random number is generated.\n// This will be the only location in which reading from Rand.Uint64() is lockable\nfunc (f *Faker) Uint64() uint64 {\n\t// Check if the source is locked\n\tif f.Locked {\n\t\t// Lock the source\n\t\tf.mu.Lock()\n\t\tdefer f.mu.Unlock()\n\t}\n\n\treturn f.Rand.Uint64()\n}\n\n// uint64n is the no-bounds-checks version of Uint64N.\n// See https://cs.opensource.google/go/go/+/refs/tags/go1.22.0:src/math/rand/v2/rand.go;l=78\n// hidden as to not clutter with additional N functions\nfunc uint64NFunc(f *Faker, n uint64) uint64 {\n\tif is32bit && uint64(uint32(n)) == n {\n\t\t// create reusable function here\n\t\tuint32NFunc := func(f *Faker, n uint32) uint32 {\n\t\t\tif n&(n-1) == 0 { // n is power of two, can mask\n\t\t\t\treturn uint32(f.Uint64()) & (n - 1)\n\t\t\t}\n\n\t\t\tx := f.Uint64()\n\t\t\tlo1a, lo0 := bits.Mul32(uint32(x), n)\n\t\t\thi, lo1b := bits.Mul32(uint32(x>>32), n)\n\t\t\tlo1, c := bits.Add32(lo1a, lo1b, 0)\n\t\t\thi += c\n\t\t\tif lo1 == 0 && lo0 < uint32(n) {\n\t\t\t\tn64 := uint64(n)\n\t\t\t\tthresh := uint32(-n64 % n64)\n\t\t\t\tfor lo1 == 0 && lo0 < thresh {\n\t\t\t\t\tx := f.Uint64()\n\t\t\t\t\tlo1a, lo0 = bits.Mul32(uint32(x), n)\n\t\t\t\t\thi, lo1b = bits.Mul32(uint32(x>>32), n)\n\t\t\t\t\tlo1, c = bits.Add32(lo1a, lo1b, 0)\n\t\t\t\t\thi += c\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn hi\n\t\t}\n\n\t\treturn uint64(uint32NFunc(f, uint32(n)))\n\t}\n\tif n&(n-1) == 0 { // n is power of two, can mask\n\t\treturn f.Uint64() & (n - 1)\n\t}\n\n\thi, lo := bits.Mul64(f.Uint64(), n)\n\tif lo < n {\n\t\tthresh := -n % n\n\t\tfor lo < thresh {\n\t\t\thi, lo = bits.Mul64(f.Uint64(), n)\n\t\t}\n\t}\n\treturn hi\n}\n\n// UintRange will generate a random uint value between min and max\nfunc UintRange(min, max uint) uint { return uintRangeFunc(GlobalFaker, min, max) }\n\n// UintRange will generate a random uint value between min and max\nfunc (f *Faker) UintRange(min, max uint) uint { return uintRangeFunc(f, min, max) }\n\nfunc uintRangeFunc(f *Faker, min, max uint) uint { return randUintRange(f, min, max) }\n\n// Int will generate a random int value\nfunc Int() int { return intFunc(GlobalFaker) }\n\n// Int will generate a random int value\nfunc (f *Faker) Int() int { return intFunc(f) }\n\nfunc intFunc(f *Faker) int { return int(uint(f.Uint64()) << 1 >> 1) }\n\n// IntN will generate a random int value between 0 and n\nfunc IntN(n int) int { return intNFunc(GlobalFaker, n) }\n\n// IntN will generate a random int value between 0 and n\nfunc (f *Faker) IntN(n int) int { return intNFunc(f, n) }\n\nfunc intNFunc(f *Faker, n int) int {\n\tif n <= 0 {\n\t\treturn 0\n\t}\n\treturn int(uint64NFunc(f, uint64(n)))\n}\n\n// Int8 will generate a random Int8 value\nfunc Int8() int8 { return int8Func(GlobalFaker) }\n\n// Int8 will generate a random Int8 value\nfunc (f *Faker) Int8() int8 { return int8Func(f) }\n\nfunc int8Func(f *Faker) int8 { return int8(randIntRange(f, math.MinInt8, math.MaxInt8)) }\n\n// Int16 will generate a random int16 value\nfunc Int16() int16 { return int16Func(GlobalFaker) }\n\n// Int16 will generate a random int16 value\nfunc (f *Faker) Int16() int16 { return int16Func(f) }\n\nfunc int16Func(f *Faker) int16 { return int16(randIntRange(f, math.MinInt16, math.MaxInt16)) }\n\n// Int32 will generate a random int32 value\nfunc Int32() int32 { return int32Func(GlobalFaker) }\n\n// Int32 will generate a random int32 value\nfunc (f *Faker) Int32() int32 { return int32Func(f) }\n\nfunc int32Func(f *Faker) int32 { return int32(f.Uint64() >> 33) }\n\n// int32n is an identical computation to int64n\n// hidden as to not clutter with additional N functions\nfunc int32NFunc(f *Faker, n int32) int32 {\n\tif n <= 0 {\n\t\treturn 0\n\t}\n\treturn int32(uint64NFunc(f, uint64(n)))\n}\n\n// Int64 will generate a random int64 value\nfunc Int64() int64 { return int64Func(GlobalFaker) }\n\n// Int64 will generate a random int64 value\nfunc (f *Faker) Int64() int64 { return int64Func(f) }\n\nfunc int64Func(f *Faker) int64 { return int64(f.Uint64() &^ (1 << 63)) }\n\n// IntRange will generate a random int value between min and max\nfunc IntRange(min, max int) int { return intRangeFunc(GlobalFaker, min, max) }\n\n// IntRange will generate a random int value between min and max\nfunc (f *Faker) IntRange(min, max int) int { return intRangeFunc(f, min, max) }\n\nfunc intRangeFunc(f *Faker, min, max int) int { return randIntRange(f, min, max) }\n\n// Float32 will generate a random float32 value\nfunc Float32() float32 { return float32Func(GlobalFaker) }\n\n// Float32 will generate a random float32 value\nfunc (f *Faker) Float32() float32 { return float32Func(f) }\n\nfunc float32Func(f *Faker) float32 {\n\t// There are exactly 1<<24 float32s in [0,1). Use Intn(1<<24) / (1<<24).\n\treturn float32(f.Uint32()<<8>>8) / (1 << 24)\n}\n\n// Float32Range will generate a random float32 value between min and max\nfunc Float32Range(min, max float32) float32 {\n\treturn float32Range(GlobalFaker, min, max)\n}\n\n// Float32Range will generate a random float32 value between min and max\nfunc (f *Faker) Float32Range(min, max float32) float32 {\n\treturn float32Range(f, min, max)\n}\n\nfunc float32Range(f *Faker, min, max float32) float32 {\n\tif min == max {\n\t\treturn min\n\t}\n\treturn f.Float32()*(max-min) + min\n}\n\n// Float64 will generate a random float64 value\nfunc Float64() float64 {\n\treturn float64Func(GlobalFaker)\n}\n\n// Float64 will generate a random float64 value\nfunc (f *Faker) Float64() float64 {\n\treturn float64Func(f)\n}\n\nfunc float64Func(f *Faker) float64 {\n\t// There are exactly 1<<53 float64s in [0,1). Use Intn(1<<53) / (1<<53).\n\treturn float64(f.Uint64()<<11>>11) / (1 << 53)\n}\n\n// Float64Range will generate a random float64 value between min and max\nfunc Float64Range(min, max float64) float64 {\n\treturn float64Range(GlobalFaker, min, max)\n}\n\n// Float64Range will generate a random float64 value between min and max\nfunc (f *Faker) Float64Range(min, max float64) float64 {\n\treturn float64Range(f, min, max)\n}\n\nfunc float64Range(f *Faker, min, max float64) float64 {\n\tif min == max {\n\t\treturn min\n\t}\n\treturn f.Float64()*(max-min) + min\n}\n\n// ShuffleInts will randomize a slice of ints\nfunc ShuffleInts(a []int) { shuffleInts(GlobalFaker, a) }\n\n// ShuffleInts will randomize a slice of ints\nfunc (f *Faker) ShuffleInts(a []int) { shuffleInts(f, a) }\n\nfunc shuffleInts(f *Faker, a []int) {\n\tfor i := range a {\n\t\tj := f.IntN(i + 1)\n\t\ta[i], a[j] = a[j], a[i]\n\t}\n}\n\n// RandomInt will take in a slice of int and return a randomly selected value\nfunc RandomInt(i []int) int { return randomInt(GlobalFaker, i) }\n\n// RandomInt will take in a slice of int and return a randomly selected value\nfunc (f *Faker) RandomInt(i []int) int { return randomInt(f, i) }\n\nfunc randomInt(f *Faker, i []int) int {\n\tsize := len(i)\n\tif size == 0 {\n\t\treturn 0\n\t}\n\tif size == 1 {\n\t\treturn i[0]\n\t}\n\treturn i[f.IntN(size)]\n}\n\n// RandomUint will take in a slice of uint and return a randomly selected value\nfunc RandomUint(u []uint) uint { return randomUint(GlobalFaker, u) }\n\n// RandomUint will take in a slice of uint and return a randomly selected value\nfunc (f *Faker) RandomUint(u []uint) uint { return randomUint(f, u) }\n\nfunc randomUint(f *Faker, u []uint) uint {\n\tsize := len(u)\n\tif size == 0 {\n\t\treturn 0\n\t}\n\tif size == 1 {\n\t\treturn u[0]\n\t}\n\treturn u[f.IntN(size)]\n}\n\n// HexUint will generate a random uint hex value with \"0x\" prefix\nfunc HexUint(bitSize int) string { return hexUint(GlobalFaker, bitSize) }\n\n// HexUint will generate a random uint hex value with \"0x\" prefix\nfunc (f *Faker) HexUint(bitSize int) string { return hexUint(f, bitSize) }\n\nfunc hexUint(f *Faker, bitSize int) string {\n\tdigits := []byte(\"0123456789abcdef\")\n\thexLen := (bitSize >> 2) + 2\n\tif hexLen <= 2 {\n\t\treturn \"0x\"\n\t}\n\n\ts := make([]byte, hexLen)\n\ts[0], s[1] = '0', 'x'\n\tfor i := 2; i < hexLen; i++ {\n\t\ts[i] = digits[f.IntN(16)]\n\t}\n\treturn string(s)\n}\n\nfunc addNumberLookup() {\n\tAddFuncLookup(\"number\", Info{\n\t\tDisplay:     \"Number\",\n\t\tCategory:    \"number\",\n\t\tDescription: \"Mathematical concept used for counting, measuring, and expressing quantities or values\",\n\t\tExample:     \"14866\",\n\t\tOutput:      \"int\",\n\t\tParams: []Param{\n\t\t\t{Field: \"min\", Display: \"Min\", Type: \"int\", Default: \"-2147483648\", Description: \"Minimum integer value\"},\n\t\t\t{Field: \"max\", Display: \"Max\", Type: \"int\", Default: \"2147483647\", Description: \"Maximum integer value\"},\n\t\t},\n\t\tGenerate: func(f *Faker, m *MapParams, info *Info) (any, error) {\n\t\t\tmin, err := info.GetInt(m, \"min\")\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\n\t\t\tmax, err := info.GetInt(m, \"max\")\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\n\t\t\treturn number(f, min, max), nil\n\t\t},\n\t})\n\n\tAddFuncLookup(\"uint\", Info{\n\t\tDisplay:     \"Uint\",\n\t\tCategory:    \"number\",\n\t\tDescription: \"Unsigned integer\",\n\t\tExample:     \"14866\",\n\t\tOutput:      \"uint\",\n\t\tGenerate: func(f *Faker, m *MapParams, info *Info) (any, error) {\n\t\t\treturn uintFunc(f), nil\n\t\t},\n\t})\n\n\tAddFuncLookup(\"uintn\", Info{\n\t\tDisplay:     \"UintN\",\n\t\tCategory:    \"number\",\n\t\tDescription: \"Unsigned integer between 0 and n\",\n\t\tExample:     \"32783\",\n\t\tOutput:      \"uint\",\n\t\tParams: []Param{\n\t\t\t{Field: \"n\", Display: \"N\", Type: \"uint\", Default: \"4294967295\", Description: \"Maximum uint value\"},\n\t\t},\n\t\tGenerate: func(f *Faker, m *MapParams, info *Info) (any, error) {\n\t\t\tn, err := info.GetUint(m, \"n\")\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\n\t\t\treturn uintNFunc(f, n), nil\n\t\t},\n\t})\n\n\tAddFuncLookup(\"uint8\", Info{\n\t\tDisplay:     \"Uint8\",\n\t\tCategory:    \"number\",\n\t\tDescription: \"Unsigned 8-bit integer, capable of representing values from 0 to 255\",\n\t\tExample:     \"152\",\n\t\tOutput:      \"uint8\",\n\t\tGenerate: func(f *Faker, m *MapParams, info *Info) (any, error) {\n\t\t\treturn uint8Func(f), nil\n\t\t},\n\t})\n\n\tAddFuncLookup(\"uint16\", Info{\n\t\tDisplay:     \"Uint16\",\n\t\tCategory:    \"number\",\n\t\tDescription: \"Unsigned 16-bit integer, capable of representing values from 0 to 65,535\",\n\t\tExample:     \"34968\",\n\t\tOutput:      \"uint16\",\n\t\tGenerate: func(f *Faker, m *MapParams, info *Info) (any, error) {\n\t\t\treturn uint16Func(f), nil\n\t\t},\n\t})\n\n\tAddFuncLookup(\"uint32\", Info{\n\t\tDisplay:     \"Uint32\",\n\t\tCategory:    \"number\",\n\t\tDescription: \"Unsigned 32-bit integer, capable of representing values from 0 to 4,294,967,295\",\n\t\tExample:     \"1075055705\",\n\t\tOutput:      \"uint32\",\n\t\tGenerate: func(f *Faker, m *MapParams, info *Info) (any, error) {\n\t\t\treturn uint32Func(f), nil\n\t\t},\n\t})\n\n\tAddFuncLookup(\"uint64\", Info{\n\t\tDisplay:     \"Uint64\",\n\t\tCategory:    \"number\",\n\t\tDescription: \"Unsigned 64-bit integer, capable of representing values from 0 to 18,446,744,073,709,551,615\",\n\t\tExample:     \"843730692693298265\",\n\t\tOutput:      \"uint64\",\n\t\tGenerate: func(f *Faker, m *MapParams, info *Info) (any, error) {\n\t\t\treturn f.Uint64(), nil\n\t\t},\n\t})\n\n\tAddFuncLookup(\"uintrange\", Info{\n\t\tDisplay:     \"UintRange\",\n\t\tCategory:    \"number\",\n\t\tDescription: \"Non-negative integer value between given range\",\n\t\tExample:     \"1075055705\",\n\t\tOutput:      \"uint\",\n\t\tParams: []Param{\n\t\t\t{Field: \"min\", Display: \"Min\", Type: \"uint\", Default: \"0\", Description: \"Minimum uint value\"},\n\t\t\t{Field: \"max\", Display: \"Max\", Type: \"uint\", Default: \"4294967295\", Description: \"Maximum uint value\"},\n\t\t},\n\t\tGenerate: func(f *Faker, m *MapParams, info *Info) (any, error) {\n\t\t\tmin, err := info.GetUint(m, \"min\")\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\n\t\t\tmax, err := info.GetUint(m, \"max\")\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\n\t\t\treturn uintRangeFunc(f, min, max), nil\n\t\t},\n\t})\n\n\tAddFuncLookup(\"int\", Info{\n\t\tDisplay:     \"Int\",\n\t\tCategory:    \"number\",\n\t\tDescription: \"Signed integer\",\n\t\tExample:     \"14866\",\n\t\tOutput:      \"int\",\n\t\tGenerate: func(f *Faker, m *MapParams, info *Info) (any, error) {\n\t\t\treturn intFunc(f), nil\n\t\t},\n\t})\n\n\tAddFuncLookup(\"intn\", Info{\n\t\tDisplay:     \"IntN\",\n\t\tCategory:    \"number\",\n\t\tDescription: \"Integer value between 0 and n\",\n\t\tExample:     \"32783\",\n\t\tOutput:      \"int\",\n\t\tParams: []Param{\n\t\t\t{Field: \"n\", Display: \"N\", Type: \"int\", Default: \"2147483647\", Description: \"Maximum int value\"},\n\t\t},\n\t\tGenerate: func(f *Faker, m *MapParams, info *Info) (any, error) {\n\t\t\tn, err := info.GetInt(m, \"n\")\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\n\t\t\treturn intNFunc(f, n), nil\n\t\t},\n\t})\n\n\tAddFuncLookup(\"int8\", Info{\n\t\tDisplay:     \"Int8\",\n\t\tCategory:    \"number\",\n\t\tDescription: \"Signed 8-bit integer, capable of representing values from -128 to 127\",\n\t\tExample:     \"24\",\n\t\tOutput:      \"int8\",\n\t\tGenerate: func(f *Faker, m *MapParams, info *Info) (any, error) {\n\t\t\treturn int8Func(f), nil\n\t\t},\n\t})\n\n\tAddFuncLookup(\"int16\", Info{\n\t\tDisplay:     \"Int16\",\n\t\tCategory:    \"number\",\n\t\tDescription: \"Signed 16-bit integer, capable of representing values from 32,768 to 32,767\",\n\t\tExample:     \"2200\",\n\t\tOutput:      \"int16\",\n\t\tGenerate: func(f *Faker, m *MapParams, info *Info) (any, error) {\n\t\t\treturn int16Func(f), nil\n\t\t},\n\t})\n\n\tAddFuncLookup(\"int32\", Info{\n\t\tDisplay:     \"Int32\",\n\t\tCategory:    \"number\",\n\t\tDescription: \"Signed 32-bit integer, capable of representing values from -2,147,483,648 to 2,147,483,647\",\n\t\tExample:     \"-1072427943\",\n\t\tOutput:      \"int32\",\n\t\tGenerate: func(f *Faker, m *MapParams, info *Info) (any, error) {\n\t\t\treturn int32Func(f), nil\n\t\t},\n\t})\n\n\tAddFuncLookup(\"int64\", Info{\n\t\tDisplay:     \"Int64\",\n\t\tCategory:    \"number\",\n\t\tDescription: \"Signed 64-bit integer, capable of representing values from -9,223,372,036,854,775,808 to -9,223,372,036,854,775,807\",\n\t\tExample:     \"-8379641344161477543\",\n\t\tOutput:      \"int64\",\n\t\tGenerate: func(f *Faker, m *MapParams, info *Info) (any, error) {\n\t\t\treturn int64Func(f), nil\n\t\t},\n\t})\n\n\tAddFuncLookup(\"intrange\", Info{\n\t\tDisplay:     \"IntRange\",\n\t\tCategory:    \"number\",\n\t\tDescription: \"Integer value between given range\",\n\t\tExample:     \"-8379477543\",\n\t\tOutput:      \"int\",\n\t\tParams: []Param{\n\t\t\t{Field: \"min\", Display: \"Min\", Type: \"int\", Description: \"Minimum int value\"},\n\t\t\t{Field: \"max\", Display: \"Max\", Type: \"int\", Description: \"Maximum int value\"},\n\t\t},\n\t\tGenerate: func(f *Faker, m *MapParams, info *Info) (any, error) {\n\t\t\tmin, err := info.GetInt(m, \"min\")\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\n\t\t\tmax, err := info.GetInt(m, \"max\")\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\n\t\t\treturn intRangeFunc(f, min, max), nil\n\t\t},\n\t})\n\n\tAddFuncLookup(\"float32\", Info{\n\t\tDisplay:     \"Float32\",\n\t\tCategory:    \"number\",\n\t\tDescription: \"Data type representing floating-point numbers with 32 bits of precision in computing\",\n\t\tExample:     \"3.1128167e+37\",\n\t\tOutput:      \"float32\",\n\t\tGenerate: func(f *Faker, m *MapParams, info *Info) (any, error) {\n\t\t\treturn float32Func(f), nil\n\t\t},\n\t})\n\n\tAddFuncLookup(\"float32range\", Info{\n\t\tDisplay:     \"Float32 Range\",\n\t\tCategory:    \"number\",\n\t\tDescription: \"Float32 value between given range\",\n\t\tExample:     \"914774.6\",\n\t\tOutput:      \"float32\",\n\t\tParams: []Param{\n\t\t\t{Field: \"min\", Display: \"Min\", Type: \"float\", Description: \"Minimum float32 value\"},\n\t\t\t{Field: \"max\", Display: \"Max\", Type: \"float\", Description: \"Maximum float32 value\"},\n\t\t},\n\t\tGenerate: func(f *Faker, m *MapParams, info *Info) (any, error) {\n\t\t\tmin, err := info.GetFloat32(m, \"min\")\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\n\t\t\tmax, err := info.GetFloat32(m, \"max\")\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\n\t\t\treturn float32Range(f, min, max), nil\n\t\t},\n\t})\n\n\tAddFuncLookup(\"float64\", Info{\n\t\tDisplay:     \"Float64\",\n\t\tCategory:    \"number\",\n\t\tDescription: \"Data type representing floating-point numbers with 64 bits of precision in computing\",\n\t\tExample:     \"1.644484108270445e+307\",\n\t\tOutput:      \"float64\",\n\t\tGenerate: func(f *Faker, m *MapParams, info *Info) (any, error) {\n\t\t\treturn float64Func(f), nil\n\t\t},\n\t})\n\n\tAddFuncLookup(\"float64range\", Info{\n\t\tDisplay:     \"Float64 Range\",\n\t\tCategory:    \"number\",\n\t\tDescription: \"Float64 value between given range\",\n\t\tExample:     \"914774.5585333086\",\n\t\tOutput:      \"float64\",\n\t\tParams: []Param{\n\t\t\t{Field: \"min\", Display: \"Min\", Type: \"float\", Description: \"Minimum float64 value\"},\n\t\t\t{Field: \"max\", Display: \"Max\", Type: \"float\", Description: \"Maximum float64 value\"},\n\t\t},\n\t\tGenerate: func(f *Faker, m *MapParams, info *Info) (any, error) {\n\t\t\tmin, err := info.GetFloat64(m, \"min\")\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\n\t\t\tmax, err := info.GetFloat64(m, \"max\")\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\n\t\t\treturn float64Range(f, min, max), nil\n\t\t},\n\t})\n\n\tAddFuncLookup(\"shuffleints\", Info{\n\t\tDisplay:     \"Shuffle Ints\",\n\t\tCategory:    \"number\",\n\t\tDescription: \"Shuffles an array of ints\",\n\t\tExample:     \"1,2,3,4 => 3,1,4,2\",\n\t\tOutput:      \"[]int\",\n\t\tParams: []Param{\n\t\t\t{Field: \"ints\", Display: \"Integers\", Type: \"[]int\", Description: \"Delimited separated integers\"},\n\t\t},\n\t\tGenerate: func(f *Faker, m *MapParams, info *Info) (any, error) {\n\t\t\tints, err := info.GetIntArray(m, \"ints\")\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\n\t\t\tshuffleInts(f, ints)\n\n\t\t\treturn ints, nil\n\t\t},\n\t})\n\n\tAddFuncLookup(\"randomint\", Info{\n\t\tDisplay:     \"Random Int\",\n\t\tCategory:    \"number\",\n\t\tDescription: \"Randomly selected value from a slice of int\",\n\t\tExample:     \"-1,2,-3,4 => -3\",\n\t\tOutput:      \"int\",\n\t\tParams: []Param{\n\t\t\t{Field: \"ints\", Display: \"Integers\", Type: \"[]int\", Description: \"Delimited separated integers\"},\n\t\t},\n\t\tGenerate: func(f *Faker, m *MapParams, info *Info) (any, error) {\n\t\t\tints, err := info.GetIntArray(m, \"ints\")\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\n\t\t\treturn randomInt(f, ints), nil\n\t\t},\n\t})\n\n\tAddFuncLookup(\"randomuint\", Info{\n\t\tDisplay:     \"Random Uint\",\n\t\tCategory:    \"number\",\n\t\tDescription: \"Randomly selected value from a slice of uint\",\n\t\tExample:     \"1,2,3,4 => 4\",\n\t\tOutput:      \"uint\",\n\t\tParams: []Param{\n\t\t\t{Field: \"uints\", Display: \"Unsigned Integers\", Type: \"[]uint\", Description: \"Delimited separated unsigned integers\"},\n\t\t},\n\t\tGenerate: func(f *Faker, m *MapParams, info *Info) (any, error) {\n\t\t\tuints, err := info.GetUintArray(m, \"uints\")\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\n\t\t\treturn randomUint(f, uints), nil\n\t\t},\n\t})\n\n\tAddFuncLookup(\"hexuint\", Info{\n\t\tDisplay:     \"HexUint\",\n\t\tCategory:    \"number\",\n\t\tDescription: \"Hexadecimal representation of an unsigned integer\",\n\t\tExample:     \"0x87\",\n\t\tOutput:      \"string\",\n\t\tParams: []Param{\n\t\t\t{Field: \"bitSize\", Display: \"Bit Size\", Type: \"int\", Default: \"8\", Description: \"Bit size of the unsigned integer\"},\n\t\t},\n\t\tGenerate: func(f *Faker, m *MapParams, info *Info) (any, error) {\n\t\t\tbitSize, err := info.GetInt(m, \"bitSize\")\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\n\t\t\treturn hexUint(f, bitSize), nil\n\t\t},\n\t})\n}\n"
        },
        {
          "name": "number_test.go",
          "type": "blob",
          "size": 6.279296875,
          "content": "package gofakeit\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc ExampleNumber() {\n\tSeed(11)\n\tfmt.Println(Number(50, 23456))\n\n\t// Output: 21019\n}\n\nfunc ExampleFaker_Number() {\n\tf := New(11)\n\tfmt.Println(f.Number(50, 23456))\n\n\t// Output: 21019\n}\n\nfunc BenchmarkNumber(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tNumber(10, 999999)\n\t}\n}\n\nfunc ExampleUint8() {\n\tSeed(11)\n\tfmt.Println(Uint8())\n\n\t// Output: 180\n}\n\nfunc ExampleFaker_Uint8() {\n\tf := New(11)\n\tfmt.Println(f.Uint8())\n\n\t// Output: 180\n}\n\nfunc BenchmarkUint8(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tUint8()\n\t}\n}\n\nfunc ExampleUint16() {\n\tSeed(11)\n\tfmt.Println(Uint16())\n\n\t// Output: 56756\n}\n\nfunc ExampleFaker_Uint16() {\n\tf := New(11)\n\tfmt.Println(f.Uint16())\n\n\t// Output: 56756\n}\n\nfunc BenchmarkUint16(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tUint16()\n\t}\n}\n\nfunc ExampleUint32() {\n\tSeed(11)\n\tfmt.Println(Uint32())\n\n\t// Output: 3847792206\n}\n\nfunc ExampleFaker_Uint32() {\n\tf := New(11)\n\tfmt.Println(f.Uint32())\n\n\t// Output: 3847792206\n}\n\nfunc BenchmarkUint32(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tUint32()\n\t}\n}\n\nfunc ExampleUint64() {\n\tSeed(11)\n\tfmt.Println(Uint64())\n\n\t// Output: 16526141687177076148\n}\n\nfunc ExampleFaker_Uint64() {\n\tf := New(11)\n\tfmt.Println(f.Uint64())\n\n\t// Output: 16526141687177076148\n}\n\nfunc BenchmarkUint64(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tUint64()\n\t}\n}\n\nfunc ExampleUintRange() {\n\tSeed(11)\n\tfmt.Println(UintRange(1, 10))\n\n\t// Output: 9\n}\n\nfunc ExampleFaker_UintRange() {\n\tf := New(11)\n\tfmt.Println(f.UintRange(1, 10))\n\n\t// Output: 9\n}\n\nfunc BenchmarkUintRange(b *testing.B) {\n\tmin := uint(1)\n\tmax := uint(10)\n\n\tfor i := 0; i < b.N; i++ {\n\t\tUintRange(min, max)\n\t}\n}\n\nfunc ExampleInt8() {\n\tSeed(11)\n\tfmt.Println(Int8())\n\n\t// Output: 52\n}\n\nfunc ExampleFaker_Int8() {\n\tf := New(11)\n\tfmt.Println(f.Int8())\n\n\t// Output: 52\n}\n\nfunc BenchmarkInt8(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tInt8()\n\t}\n}\n\nfunc ExampleInt16() {\n\tSeed(11)\n\tfmt.Println(Int16())\n\n\t// Output: 23988\n}\n\nfunc ExampleFaker_Int16() {\n\tf := New(11)\n\tfmt.Println(f.Int16())\n\n\t// Output: 23988\n}\n\nfunc BenchmarkInt16(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tInt16()\n\t}\n}\n\nfunc ExampleInt32() {\n\tSeed(11)\n\tfmt.Println(Int32())\n\n\t// Output: 1923896103\n}\n\nfunc ExampleFaker_Int32() {\n\tf := New(11)\n\tfmt.Println(f.Int32())\n\n\t// Output: 1923896103\n}\n\nfunc BenchmarkInt32(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tInt32()\n\t}\n}\n\nfunc ExampleInt64() {\n\tSeed(11)\n\tfmt.Println(Int64())\n\n\t// Output: 7302769650322300340\n}\n\nfunc ExampleFaker_Int64() {\n\tf := New(11)\n\tfmt.Println(f.Int64())\n\n\t// Output: 7302769650322300340\n}\n\nfunc BenchmarkInt64(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tInt64()\n\t}\n}\n\nfunc ExampleIntRange() {\n\tSeed(11)\n\tfmt.Println(IntRange(1, 10))\n\n\t// Output: 9\n}\n\nfunc ExampleFaker_IntRange() {\n\tf := New(11)\n\tfmt.Println(f.IntRange(1, 10))\n\n\t// Output: 9\n}\n\nfunc BenchmarkIntRange(b *testing.B) {\n\tmin := int(1)\n\tmax := int(10)\n\n\tfor i := 0; i < b.N; i++ {\n\t\tIntRange(min, max)\n\t}\n}\n\nfunc ExampleFloat32() {\n\tSeed(11)\n\tfmt.Println(Float32())\n\n\t// Output: 0.3462876\n}\n\nfunc ExampleFaker_Float32() {\n\tf := New(11)\n\tfmt.Println(f.Float32())\n\n\t// Output: 0.3462876\n}\n\nfunc BenchmarkFloat32(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tFloat32()\n\t}\n}\n\nfunc ExampleFloat32Range() {\n\tSeed(11)\n\tfmt.Println(Float32Range(0, 9999999))\n\n\t// Output: 3.4628758e+06\n}\n\nfunc ExampleFaker_Float32Range() {\n\tf := New(11)\n\tfmt.Println(f.Float32Range(0, 9999999))\n\n\t// Output: 3.4628758e+06\n}\n\nfunc BenchmarkFloat32Range(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tFloat32Range(10, 999999)\n\t}\n}\n\nfunc TestFloat32RangeSame(t *testing.T) {\n\tif float32Range(GlobalFaker, 5.0, 5.0) != 5.0 {\n\t\tt.Error(\"You should have gotten 5.0 back\")\n\t}\n}\n\nfunc ExampleFloat64() {\n\tSeed(11)\n\tfmt.Println(Float64())\n\n\t// Output: 0.7703009321621068\n}\n\nfunc ExampleFaker_Float64() {\n\tf := New(11)\n\tfmt.Println(f.Float64())\n\n\t// Output: 0.7703009321621068\n}\n\nfunc BenchmarkFloat64(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tFloat64()\n\t}\n}\n\nfunc ExampleFloat64Range() {\n\tSeed(11)\n\tfmt.Println(Float64Range(0, 9999999))\n\n\t// Output: 7.703008551320136e+06\n}\n\nfunc ExampleFaker_Float64Range() {\n\tf := New(11)\n\tfmt.Println(f.Float64Range(0, 9999999))\n\n\t// Output: 7.703008551320136e+06\n}\n\nfunc BenchmarkFloat64Range(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tFloat64Range(0, 999999)\n\t}\n}\n\nfunc TestRandFloat64RangeSame(t *testing.T) {\n\tif float64Range(GlobalFaker, 5.0, 5.0) != 5.0 {\n\t\tt.Error(\"You should have gotten 5.0 back\")\n\t}\n}\n\nfunc ExampleShuffleInts() {\n\tSeed(11)\n\n\tints := []int{52, 854, 941, 74125, 8413, 777, 89416, 841657}\n\tShuffleInts(ints)\n\tfmt.Println(ints)\n\n\t// Output: [941 777 8413 74125 854 89416 841657 52]\n}\n\nfunc ExampleFaker_ShuffleInts() {\n\tf := New(11)\n\n\tints := []int{52, 854, 941, 74125, 8413, 777, 89416, 841657}\n\tf.ShuffleInts(ints)\n\tfmt.Println(ints)\n\n\t// Output: [941 777 8413 74125 854 89416 841657 52]\n}\n\nfunc BenchmarkShuffleInts(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tShuffleInts([]int{52, 854, 941, 74125, 8413, 777, 89416, 841657})\n\t}\n}\n\nfunc ExampleRandomInt() {\n\tSeed(11)\n\n\tints := []int{52, 854, 941, 74125, 8413, 777, 89416, 841657}\n\tfmt.Println(RandomInt(ints))\n\n\t// Output: 8413\n}\n\nfunc ExampleFaker_RandomInt() {\n\tf := New(11)\n\n\tints := []int{52, 854, 941, 74125, 8413, 777, 89416, 841657}\n\tfmt.Println(f.RandomInt(ints))\n\n\t// Output: 8413\n}\n\nfunc TestRandomInt(t *testing.T) {\n\tints := []int{}\n\tRandomInt(ints)\n\n\tints = []int{1}\n\tRandomInt(ints)\n}\n\nfunc BenchmarkRandomInt(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tRandomInt([]int{52, 854, 941, 74125, 8413, 777, 89416, 841657})\n\t}\n}\n\nfunc ExampleRandomUint() {\n\tSeed(11)\n\n\tints := []uint{52, 854, 941, 74125, 8413, 777, 89416, 841657}\n\tfmt.Println(RandomUint(ints))\n\n\t// Output: 8413\n}\n\nfunc ExampleFaker_RandomUint() {\n\tf := New(11)\n\n\tints := []uint{52, 854, 941, 74125, 8413, 777, 89416, 841657}\n\tfmt.Println(f.RandomUint(ints))\n\n\t// Output: 8413\n}\n\nfunc TestRandomUint(t *testing.T) {\n\tints := []uint{}\n\tRandomUint(ints)\n\n\tints = []uint{1}\n\tRandomUint(ints)\n}\n\nfunc BenchmarkRandomUint(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tRandomUint([]uint{52, 854, 941, 74125, 8413, 777, 89416, 841657})\n\t}\n}\n\nfunc ExampleHexUint() {\n\tSeed(11)\n\tfmt.Println(HexUint(16))\n\n\t// Output: 0x425b\n}\n\nfunc ExampleFaker_HexUint() {\n\tf := New(11)\n\tfmt.Println(f.HexUint(16))\n\n\t// Output: 0x425b\n}\n\nfunc BenchmarkHexUint(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tHexUint(16)\n\t}\n}\n"
        },
        {
          "name": "payment.go",
          "type": "blob",
          "size": 14.1630859375,
          "content": "package gofakeit\n\nimport (\n\t\"math\"\n\t\"strconv\"\n\t\"strings\"\n\t\"time\"\n\n\t\"github.com/brianvoe/gofakeit/v7/data\"\n)\n\n// CurrencyInfo is a struct of currency information\ntype CurrencyInfo struct {\n\tShort string `json:\"short\" xml:\"short\"`\n\tLong  string `json:\"long\" xml:\"long\"`\n}\n\n// Currency will generate a struct with random currency information\nfunc Currency() *CurrencyInfo { return currency(GlobalFaker) }\n\n// Currency will generate a struct with random currency information\nfunc (f *Faker) Currency() *CurrencyInfo { return currency(f) }\n\nfunc currency(f *Faker) *CurrencyInfo {\n\tindex := f.IntN(len(data.Data[\"currency\"][\"short\"]))\n\treturn &CurrencyInfo{\n\t\tShort: data.Data[\"currency\"][\"short\"][index],\n\t\tLong:  data.Data[\"currency\"][\"long\"][index],\n\t}\n}\n\n// CurrencyShort will generate a random short currency value\nfunc CurrencyShort() string { return currencyShort(GlobalFaker) }\n\n// CurrencyShort will generate a random short currency value\nfunc (f *Faker) CurrencyShort() string { return currencyShort(f) }\n\nfunc currencyShort(f *Faker) string { return getRandValue(f, []string{\"currency\", \"short\"}) }\n\n// CurrencyLong will generate a random long currency name\nfunc CurrencyLong() string { return currencyLong(GlobalFaker) }\n\n// CurrencyLong will generate a random long currency name\nfunc (f *Faker) CurrencyLong() string { return currencyLong(f) }\n\nfunc currencyLong(f *Faker) string { return getRandValue(f, []string{\"currency\", \"long\"}) }\n\n// Price will take in a min and max value and return a formatted price\nfunc Price(min, max float64) float64 { return price(GlobalFaker, min, max) }\n\n// Price will take in a min and max value and return a formatted price\nfunc (f *Faker) Price(min, max float64) float64 { return price(f, min, max) }\n\nfunc price(f *Faker, min, max float64) float64 {\n\treturn math.Floor(float64Range(f, min, max)*100) / 100\n}\n\n// CreditCardInfo is a struct containing credit variables\ntype CreditCardInfo struct {\n\tType   string `json:\"type\" xml:\"type\"`\n\tNumber string `json:\"number\" xml:\"number\"`\n\tExp    string `json:\"exp\" xml:\"exp\"`\n\tCvv    string `json:\"cvv\" xml:\"cvv\"`\n}\n\n// CreditCard will generate a struct full of credit card information\nfunc CreditCard() *CreditCardInfo { return creditCard(GlobalFaker) }\n\n// CreditCard will generate a struct full of credit card information\nfunc (f *Faker) CreditCard() *CreditCardInfo { return creditCard(f) }\n\nfunc creditCard(f *Faker) *CreditCardInfo {\n\tccType := randomString(f, data.CreditCardTypes)\n\tccv, _ := generate(f, strings.Repeat(\"#\", int(data.CreditCards[randomString(f, data.CreditCardTypes)].Code.Size)))\n\n\treturn &CreditCardInfo{\n\t\tType:   data.CreditCards[randomString(f, data.CreditCardTypes)].Display,\n\t\tNumber: creditCardNumber(f, &CreditCardOptions{Types: []string{ccType}}),\n\t\tExp:    creditCardExp(f),\n\t\tCvv:    ccv,\n\t}\n}\n\n// CreditCardType will generate a random credit card type string\nfunc CreditCardType() string { return creditCardType(GlobalFaker) }\n\n// CreditCardType will generate a random credit card type string\nfunc (f *Faker) CreditCardType() string { return creditCardType(f) }\n\nfunc creditCardType(f *Faker) string {\n\treturn data.CreditCards[randomString(f, data.CreditCardTypes)].Display\n}\n\n// CreditCardOptions is the options for credit card number\ntype CreditCardOptions struct {\n\tTypes []string `json:\"types\"`\n\tBins  []string `json:\"bins\"` // optional parameter of prepended numbers\n\tGaps  bool     `json:\"gaps\"`\n}\n\n// CreditCardNumber will generate a random luhn credit card number\nfunc CreditCardNumber(cco *CreditCardOptions) string { return creditCardNumber(GlobalFaker, cco) }\n\n// CreditCardNumber will generate a random luhn credit card number\nfunc (f *Faker) CreditCardNumber(cco *CreditCardOptions) string { return creditCardNumber(f, cco) }\n\nfunc creditCardNumber(f *Faker, cco *CreditCardOptions) string {\n\tif cco == nil {\n\t\tcco = &CreditCardOptions{}\n\t}\n\tif cco.Types == nil || len(cco.Types) == 0 {\n\t\tcco.Types = data.CreditCardTypes\n\t}\n\tccType := randomString(f, cco.Types)\n\n\t// Get Card info\n\tvar cardInfo data.CreditCardInfo\n\tif info, ok := data.CreditCards[ccType]; ok {\n\t\tcardInfo = info\n\t} else {\n\t\tccType = randomString(f, data.CreditCardTypes)\n\t\tcardInfo = data.CreditCards[ccType]\n\t}\n\n\t// Get length and pattern\n\tlength := randomUint(f, cardInfo.Lengths)\n\tnumStr := \"\"\n\tif len(cco.Bins) >= 1 {\n\t\tnumStr = randomString(f, cco.Bins)\n\t} else {\n\t\tnumStr = strconv.FormatUint(uint64(randomUint(f, cardInfo.Patterns)), 10)\n\t}\n\tnumStr += strings.Repeat(\"#\", int(length)-len(numStr))\n\tnumStr = numerify(f, numStr)\n\tui, _ := strconv.ParseUint(numStr, 10, 64)\n\n\t// Loop through until its a valid luhn\n\tfor {\n\t\tvalid := isLuhn(strconv.FormatUint(ui, 10))\n\t\tif valid {\n\t\t\tbreak\n\t\t}\n\t\tui++\n\t}\n\tnumStr = strconv.FormatUint(ui, 10)\n\n\t// Add gaps to number\n\tif cco.Gaps {\n\t\tfor i, spot := range cardInfo.Gaps {\n\t\t\tnumStr = numStr[:(int(spot)+i)] + \" \" + numStr[(int(spot)+i):]\n\t\t}\n\t}\n\n\treturn numStr\n}\n\n// CreditCardExp will generate a random credit card expiration date string\n// Exp date will always be a future date\nfunc CreditCardExp() string { return creditCardExp(GlobalFaker) }\n\n// CreditCardExp will generate a random credit card expiration date string\n// Exp date will always be a future date\nfunc (f *Faker) CreditCardExp() string { return creditCardExp(f) }\n\nfunc creditCardExp(f *Faker) string {\n\tmonth := strconv.Itoa(randIntRange(f, 1, 12))\n\tif len(month) == 1 {\n\t\tmonth = \"0\" + month\n\t}\n\n\tvar currentYear = time.Now().Year() - 2000\n\treturn month + \"/\" + strconv.Itoa(randIntRange(f, currentYear+1, currentYear+10))\n}\n\n// CreditCardCvv will generate a random CVV number\n// Its a string because you could have 017 as an exp date\nfunc CreditCardCvv() string { return creditCardCvv(GlobalFaker) }\n\n// CreditCardCvv will generate a random CVV number\n// Its a string because you could have 017 as an exp date\nfunc (f *Faker) CreditCardCvv() string { return creditCardCvv(f) }\n\nfunc creditCardCvv(f *Faker) string { return numerify(f, \"###\") }\n\n// isLuhn check is used for checking if credit card is a valid luhn card\nfunc isLuhn(s string) bool {\n\tvar t = [...]int{0, 2, 4, 6, 8, 1, 3, 5, 7, 9}\n\todd := len(s) & 1\n\tvar sum int\n\tfor i, c := range s {\n\t\tif c < '0' || c > '9' {\n\t\t\treturn false\n\t\t}\n\t\tif i&1 == odd {\n\t\t\tsum += t[c-'0']\n\t\t} else {\n\t\t\tsum += int(c - '0')\n\t\t}\n\t}\n\treturn sum%10 == 0\n}\n\n// AchRouting will generate a 9 digit routing number\nfunc AchRouting() string { return achRouting(GlobalFaker) }\n\n// AchRouting will generate a 9 digit routing number\nfunc (f *Faker) AchRouting() string { return achRouting(f) }\n\nfunc achRouting(f *Faker) string { return numerify(f, \"#########\") }\n\n// AchAccount will generate a 12 digit account number\nfunc AchAccount() string { return achAccount(GlobalFaker) }\n\n// AchAccount will generate a 12 digit account number\nfunc (f *Faker) AchAccount() string { return achAccount(f) }\n\nfunc achAccount(f *Faker) string { return numerify(f, \"############\") }\n\n// BitcoinAddress will generate a random bitcoin address consisting of numbers, upper and lower characters\nfunc BitcoinAddress() string { return bitcoinAddress(GlobalFaker) }\n\n// BitcoinAddress will generate a random bitcoin address consisting of numbers, upper and lower characters\nfunc (f *Faker) BitcoinAddress() string { return bitcoinAddress(f) }\n\nfunc bitcoinAddress(f *Faker) string {\n\treturn randomString(f, []string{\"1\", \"3\"}) + password(f, true, true, true, false, false, number(f, 25, 34))\n}\n\n// BitcoinPrivateKey will generate a random bitcoin private key base58 consisting of numbers, upper and lower characters\nfunc BitcoinPrivateKey() string { return bitcoinPrivateKey(GlobalFaker) }\n\n// BitcoinPrivateKey will generate a random bitcoin private key base58 consisting of numbers, upper and lower characters\nfunc (f *Faker) BitcoinPrivateKey() string { return bitcoinPrivateKey(f) }\n\nfunc bitcoinPrivateKey(f *Faker) string {\n\tvar b strings.Builder\n\tfor i := 0; i < 49; i++ {\n\t\tb.WriteString(randCharacter(f, base58))\n\t}\n\treturn \"5\" + randomString(f, []string{\"H\", \"J\", \"K\"}) + b.String()\n}\n\nfunc addPaymentLookup() {\n\tAddFuncLookup(\"currency\", Info{\n\t\tDisplay:     \"Currency\",\n\t\tCategory:    \"payment\",\n\t\tDescription: \"Medium of exchange, often in the form of paper money or coins, used for trade and transactions\",\n\t\tExample: `{\n\t\"short\": \"IQD\",\n\t\"long\": \"Iraq Dinar\"\n}`,\n\t\tOutput:      \"map[string]string\",\n\t\tContentType: \"application/json\",\n\t\tGenerate: func(f *Faker, m *MapParams, info *Info) (any, error) {\n\t\t\treturn currency(f), nil\n\t\t},\n\t})\n\n\tAddFuncLookup(\"currencyshort\", Info{\n\t\tDisplay:     \"Currency Short\",\n\t\tCategory:    \"payment\",\n\t\tDescription: \"Short 3-letter word used to represent a specific currency\",\n\t\tExample:     \"USD\",\n\t\tOutput:      \"string\",\n\t\tGenerate: func(f *Faker, m *MapParams, info *Info) (any, error) {\n\t\t\treturn currencyShort(f), nil\n\t\t},\n\t})\n\n\tAddFuncLookup(\"currencylong\", Info{\n\t\tDisplay:     \"Currency Long\",\n\t\tCategory:    \"payment\",\n\t\tDescription: \"Complete name of a specific currency used for official identification in financial transactions\",\n\t\tExample:     \"United States Dollar\",\n\t\tOutput:      \"string\",\n\t\tGenerate: func(f *Faker, m *MapParams, info *Info) (any, error) {\n\t\t\treturn currencyLong(f), nil\n\t\t},\n\t})\n\n\tAddFuncLookup(\"price\", Info{\n\t\tDisplay:     \"Price\",\n\t\tCategory:    \"payment\",\n\t\tDescription: \"The amount of money or value assigned to a product, service, or asset in a transaction\",\n\t\tExample:     \"92.26\",\n\t\tOutput:      \"float64\",\n\t\tParams: []Param{\n\t\t\t{Field: \"min\", Display: \"Min\", Type: \"float\", Default: \"0\", Description: \"Minimum price value\"},\n\t\t\t{Field: \"max\", Display: \"Max\", Type: \"float\", Default: \"1000\", Description: \"Maximum price value\"},\n\t\t},\n\t\tGenerate: func(f *Faker, m *MapParams, info *Info) (any, error) {\n\t\t\tmin, err := info.GetFloat64(m, \"min\")\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\n\t\t\tmax, err := info.GetFloat64(m, \"max\")\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\n\t\t\treturn price(f, min, max), nil\n\t\t},\n\t})\n\n\tAddFuncLookup(\"creditcard\", Info{\n\t\tDisplay:     \"Credit Card\",\n\t\tCategory:    \"payment\",\n\t\tDescription: \"Plastic card allowing users to make purchases on credit, with payment due at a later date\",\n\t\tExample: `{\n\t\"type\": \"UnionPay\",\n\t\"number\": \"4364599489953698\",\n\t\"exp\": \"02/24\",\n\t\"cvv\": \"300\"\n}`,\n\t\tOutput:      \"map[string]any\",\n\t\tContentType: \"application/json\",\n\t\tGenerate: func(f *Faker, m *MapParams, info *Info) (any, error) {\n\t\t\treturn creditCard(f), nil\n\t\t},\n\t})\n\n\tAddFuncLookup(\"creditcardtype\", Info{\n\t\tDisplay:     \"Credit Card Type\",\n\t\tCategory:    \"payment\",\n\t\tDescription: \"Classification of credit cards based on the issuing company\",\n\t\tExample:     \"Visa\",\n\t\tOutput:      \"string\",\n\t\tGenerate: func(f *Faker, m *MapParams, info *Info) (any, error) {\n\t\t\treturn creditCardType(f), nil\n\t\t},\n\t})\n\n\tAddFuncLookup(\"creditcardnumber\", Info{\n\t\tDisplay:     \"Credit Card Number\",\n\t\tCategory:    \"payment\",\n\t\tDescription: \"Unique numerical identifier on a credit card used for making electronic payments and transactions\",\n\t\tExample:     \"4136459948995369\",\n\t\tOutput:      \"string\",\n\t\tParams: []Param{\n\t\t\t{\n\t\t\t\tField: \"types\", Display: \"Types\", Type: \"[]string\", Default: \"all\",\n\t\t\t\tOptions:     []string{\"visa\", \"mastercard\", \"american-express\", \"diners-club\", \"discover\", \"jcb\", \"unionpay\", \"maestro\", \"elo\", \"hiper\", \"hipercard\"},\n\t\t\t\tDescription: \"A select number of types you want to use when generating a credit card number\",\n\t\t\t},\n\t\t\t{Field: \"bins\", Display: \"Bins\", Type: \"[]string\", Optional: true, Description: \"Optional list of prepended bin numbers to pick from\"},\n\t\t\t{Field: \"gaps\", Display: \"Gaps\", Type: \"bool\", Default: \"false\", Description: \"Whether or not to have gaps in number\"},\n\t\t},\n\t\tGenerate: func(f *Faker, m *MapParams, info *Info) (any, error) {\n\t\t\ttypes, err := info.GetStringArray(m, \"types\")\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\tif len(types) == 1 && types[0] == \"all\" {\n\t\t\t\ttypes = []string{}\n\t\t\t}\n\n\t\t\tbins, _ := info.GetStringArray(m, \"bins\")\n\n\t\t\tgaps, err := info.GetBool(m, \"gaps\")\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\n\t\t\toptions := CreditCardOptions{\n\t\t\t\tTypes: types,\n\t\t\t\tGaps:  gaps,\n\t\t\t}\n\n\t\t\tif len(bins) >= 1 {\n\t\t\t\toptions.Bins = bins\n\t\t\t}\n\n\t\t\treturn creditCardNumber(f, &options), nil\n\t\t},\n\t})\n\n\tAddFuncLookup(\"creditcardexp\", Info{\n\t\tDisplay:     \"Credit Card Exp\",\n\t\tCategory:    \"payment\",\n\t\tDescription: \"Date when a credit card becomes invalid and cannot be used for transactions\",\n\t\tExample:     \"01/21\",\n\t\tOutput:      \"string\",\n\t\tGenerate: func(f *Faker, m *MapParams, info *Info) (any, error) {\n\t\t\treturn creditCardExp(f), nil\n\t\t},\n\t})\n\n\tAddFuncLookup(\"creditcardcvv\", Info{\n\t\tDisplay:     \"Credit Card CVV\",\n\t\tCategory:    \"payment\",\n\t\tDescription: \"Three or four-digit security code on a credit card used for online and remote transactions\",\n\t\tExample:     \"513\",\n\t\tOutput:      \"string\",\n\t\tGenerate: func(f *Faker, m *MapParams, info *Info) (any, error) {\n\t\t\treturn creditCardCvv(f), nil\n\t\t},\n\t})\n\n\tAddFuncLookup(\"achrouting\", Info{\n\t\tDisplay:     \"ACH Routing Number\",\n\t\tCategory:    \"payment\",\n\t\tDescription: \"Unique nine-digit code used in the U.S. for identifying the bank and processing electronic transactions\",\n\t\tExample:     \"513715684\",\n\t\tOutput:      \"string\",\n\t\tGenerate: func(f *Faker, m *MapParams, info *Info) (any, error) {\n\t\t\treturn achRouting(f), nil\n\t\t},\n\t})\n\n\tAddFuncLookup(\"achaccount\", Info{\n\t\tDisplay:     \"ACH Account Number\",\n\t\tCategory:    \"payment\",\n\t\tDescription: \"A bank account number used for Automated Clearing House transactions and electronic transfers\",\n\t\tExample:     \"491527954328\",\n\t\tOutput:      \"string\",\n\t\tGenerate: func(f *Faker, m *MapParams, info *Info) (any, error) {\n\t\t\treturn achAccount(f), nil\n\t\t},\n\t})\n\n\tAddFuncLookup(\"bitcoinaddress\", Info{\n\t\tDisplay:     \"Bitcoin Address\",\n\t\tCategory:    \"payment\",\n\t\tDescription: \"Cryptographic identifier used to receive, store, and send Bitcoin cryptocurrency in a peer-to-peer network\",\n\t\tExample:     \"1lWLbxojXq6BqWX7X60VkcDIvYA\",\n\t\tOutput:      \"string\",\n\t\tGenerate: func(f *Faker, m *MapParams, info *Info) (any, error) {\n\t\t\treturn bitcoinAddress(f), nil\n\t\t},\n\t})\n\n\tAddFuncLookup(\"bitcoinprivatekey\", Info{\n\t\tDisplay:     \"Bitcoin Private Key\",\n\t\tCategory:    \"payment\",\n\t\tDescription: \"Secret, secure code that allows the owner to access and control their Bitcoin holdings\",\n\t\tExample:     \"5vrbXTADWJ6sQBSYd6lLkG97jljNc0X9VPBvbVqsIH9lWOLcoqg\",\n\t\tOutput:      \"string\",\n\t\tGenerate: func(f *Faker, m *MapParams, info *Info) (any, error) {\n\t\t\treturn bitcoinPrivateKey(f), nil\n\t\t},\n\t})\n}\n"
        },
        {
          "name": "payment_test.go",
          "type": "blob",
          "size": 5.6240234375,
          "content": "package gofakeit\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc ExampleCurrency() {\n\tSeed(11)\n\tcurrency := Currency()\n\tfmt.Println(currency.Short)\n\tfmt.Println(currency.Long)\n\n\t// Output: UGX\n\t// Uganda Shilling\n}\n\nfunc ExampleFaker_Currency() {\n\tf := New(11)\n\tcurrency := f.Currency()\n\tfmt.Println(currency.Short)\n\tfmt.Println(currency.Long)\n\n\t// Output: UGX\n\t// Uganda Shilling\n}\n\nfunc BenchmarkCurrency(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tCurrency()\n\t}\n}\n\nfunc ExampleCurrencyShort() {\n\tSeed(11)\n\tfmt.Println(CurrencyShort())\n\n\t// Output: UGX\n}\n\nfunc ExampleFaker_CurrencyShort() {\n\tf := New(11)\n\tfmt.Println(f.CurrencyShort())\n\n\t// Output: UGX\n}\n\nfunc BenchmarkCurrencyShort(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tCurrencyShort()\n\t}\n}\n\nfunc ExampleCurrencyLong() {\n\tSeed(11)\n\tfmt.Println(CurrencyLong())\n\n\t// Output: Uganda Shilling\n}\n\nfunc ExampleFaker_CurrencyLong() {\n\tf := New(11)\n\tfmt.Println(f.CurrencyLong())\n\n\t// Output: Uganda Shilling\n}\n\nfunc BenchmarkCurrencyLong(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tCurrencyLong()\n\t}\n}\n\nfunc ExamplePrice() {\n\tSeed(11)\n\tfmt.Printf(\"%.2f\", Price(0.8618, 1000))\n\n\t// Output: 770.49\n}\n\nfunc ExampleFaker_Price() {\n\tf := New(11)\n\tfmt.Printf(\"%.2f\", f.Price(0.8618, 1000))\n\n\t// Output: 770.49\n}\n\nfunc BenchmarkPrice(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tPrice(0, 1000)\n\t}\n}\n\nfunc ExampleCreditCard() {\n\tSeed(11)\n\tccInfo := CreditCard()\n\tfmt.Println(ccInfo.Type)\n\tfmt.Println(ccInfo.Number)\n\tfmt.Println(ccInfo.Exp)\n\tfmt.Println(ccInfo.Cvv)\n\n\t// Output: American Express\n\t// 6376095989079994\n\t// 06/29\n\t// 125\n}\n\nfunc ExampleFaker_CreditCard() {\n\tf := New(11)\n\tccInfo := f.CreditCard()\n\tfmt.Println(ccInfo.Type)\n\tfmt.Println(ccInfo.Number)\n\tfmt.Println(ccInfo.Exp)\n\tfmt.Println(ccInfo.Cvv)\n\n\t// Output: American Express\n\t// 6376095989079994\n\t// 06/29\n\t// 125\n}\n\nfunc BenchmarkCreditCard(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tCreditCard()\n\t}\n}\n\nfunc ExampleCreditCardType() {\n\tSeed(11)\n\tfmt.Println(CreditCardType())\n\n\t// Output: Hiper\n}\n\nfunc ExampleFaker_CreditCardType() {\n\tf := New(11)\n\tfmt.Println(f.CreditCardType())\n\n\t// Output: Hiper\n}\n\nfunc BenchmarkCreditCardType(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tCreditCardType()\n\t}\n}\n\nfunc ExampleCreditCardNumber() {\n\tSeed(11)\n\tfmt.Println(CreditCardNumber(nil))\n\tfmt.Println(CreditCardNumber(&CreditCardOptions{Types: []string{\"visa\", \"discover\"}}))\n\tfmt.Println(CreditCardNumber(&CreditCardOptions{Bins: []string{\"4111\"}}))\n\tfmt.Println(CreditCardNumber(&CreditCardOptions{Gaps: true}))\n\n\t// Output: 6376121252759896\n\t// 6449344737930519\n\t// 4111026894059156\n\t// 6706 2052 5709 6\n}\n\nfunc ExampleFaker_CreditCardNumber() {\n\tf := New(11)\n\tfmt.Println(f.CreditCardNumber(nil))\n\tfmt.Println(f.CreditCardNumber(&CreditCardOptions{Types: []string{\"visa\", \"discover\"}}))\n\tfmt.Println(f.CreditCardNumber(&CreditCardOptions{Bins: []string{\"4111\"}}))\n\tfmt.Println(f.CreditCardNumber(&CreditCardOptions{Gaps: true}))\n\n\t// Output: 6376121252759896\n\t// 6449344737930519\n\t// 4111026894059156\n\t// 6706 2052 5709 6\n}\n\nfunc TestCreditCardNumber(t *testing.T) {\n\tfor i := 0; i < 100000; i++ {\n\t\tif !isLuhn(CreditCardNumber(nil)) {\n\t\t\tt.Error(\"Number was not luhn\")\n\t\t}\n\t}\n}\n\nfunc TestCreditCardNumberLookup(t *testing.T) {\n\tfaker := New(0)\n\tinfo := GetFuncLookup(\"creditcardnumber\")\n\n\tm := NewMapParams()\n\tm.Add(\"gaps\", \"true\")\n\n\t_, err := info.Generate(faker, m, info)\n\tif err != nil {\n\t\tt.Fatal(err.Error())\n\t}\n\n\t// t.Fatal(fmt.Sprintf(\"%s\", value.(string)))\n}\n\nfunc BenchmarkCreditCardNumber(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tCreditCardNumber(nil)\n\t}\n}\n\nfunc TestIsLuhn(t *testing.T) {\n\t// Lets make sure this card is invalid\n\tif isLuhn(\"867gfsd5309\") {\n\t\tt.Error(\"Card should have failed\")\n\t}\n\n\t// Lets make sure this card is valid\n\tif !isLuhn(\"4716685826369360\") {\n\t\tt.Error(\"Card should not have failed\")\n\t}\n}\n\nfunc ExampleCreditCardExp() {\n\tSeed(11)\n\tfmt.Println(CreditCardExp())\n\n\t// Output: 11/33\n}\n\nfunc ExampleFaker_CreditCardExp() {\n\tf := New(11)\n\tfmt.Println(f.CreditCardExp())\n\n\t// Output: 11/33\n}\n\nfunc BenchmarkCreditCardExp(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tCreditCardExp()\n\t}\n}\n\nfunc ExampleCreditCardCvv() {\n\tSeed(11)\n\tfmt.Println(CreditCardCvv())\n\n\t// Output: 881\n}\n\nfunc ExampleFaker_CreditCardCvv() {\n\tf := New(11)\n\tfmt.Println(f.CreditCardCvv())\n\n\t// Output: 881\n}\n\nfunc BenchmarkCreditCardCvv(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tCreditCardCvv()\n\t}\n}\n\nfunc ExampleAchRouting() {\n\tSeed(11)\n\tfmt.Println(AchRouting())\n\n\t// Output: 881252759\n}\n\nfunc ExampleFaker_AchRouting() {\n\tf := New(11)\n\tfmt.Println(f.AchRouting())\n\n\t// Output: 881252759\n}\n\nfunc BenchmarkAchRouting(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tAchRouting()\n\t}\n}\n\nfunc ExampleAchAccount() {\n\tSeed(11)\n\tfmt.Println(AchAccount())\n\n\t// Output: 881252759890\n}\n\nfunc ExampleFaker_AchAccount() {\n\tf := New(11)\n\tfmt.Println(f.AchAccount())\n\n\t// Output: 881252759890\n}\n\nfunc BenchmarkAchAccount(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tAchAccount()\n\t}\n}\n\nfunc ExampleBitcoinAddress() {\n\tSeed(11)\n\tfmt.Println(BitcoinAddress())\n\n\t// Output: 13blsBo8bffq7a35c5nwLT4eXWu0pReLF1\n}\n\nfunc ExampleFaker_BitcoinAddress() {\n\tf := New(11)\n\tfmt.Println(f.BitcoinAddress())\n\n\t// Output: 13blsBo8bffq7a35c5nwLT4eXWu0pReLF1\n}\n\nfunc BenchmarkBitcoinAddress(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tBitcoinAddress()\n\t}\n}\n\nfunc ExampleBitcoinPrivateKey() {\n\tSeed(11)\n\tfmt.Println(BitcoinPrivateKey())\n\n\t// Output: 5JMZxkQX2PgaasaHc8wnWLNdMu7rxeU7xS64ev7RWNinacicPfm\n}\n\nfunc ExampleFaker_BitcoinPrivateKey() {\n\tf := New(11)\n\tfmt.Println(f.BitcoinPrivateKey())\n\n\t// Output: 5JMZxkQX2PgaasaHc8wnWLNdMu7rxeU7xS64ev7RWNinacicPfm\n}\n\nfunc BenchmarkBitcoinPrivateKey(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tBitcoinPrivateKey()\n\t}\n}\n"
        },
        {
          "name": "person.go",
          "type": "blob",
          "size": 12.177734375,
          "content": "package gofakeit\n\nimport (\n\t\"math\"\n\t\"strconv\"\n\t\"strings\"\n)\n\n// PersonInfo is a struct of person information\ntype PersonInfo struct {\n\tFirstName  string          `json:\"first_name\" xml:\"first_name\"`\n\tLastName   string          `json:\"last_name\" xml:\"last_name\"`\n\tGender     string          `json:\"gender\" xml:\"gender\"`\n\tSSN        string          `json:\"ssn\" xml:\"ssn\"`\n\tHobby      string          `json:\"hobby\" xml:\"hobby\"`\n\tJob        *JobInfo        `json:\"job\" xml:\"job\"`\n\tAddress    *AddressInfo    `json:\"address\" xml:\"address\"`\n\tContact    *ContactInfo    `json:\"contact\" xml:\"contact\"`\n\tCreditCard *CreditCardInfo `json:\"credit_card\" xml:\"credit_card\"`\n}\n\n// Person will generate a struct with person information\nfunc Person() *PersonInfo { return person(GlobalFaker) }\n\n// Person will generate a struct with person information\nfunc (f *Faker) Person() *PersonInfo { return person(f) }\n\nfunc person(f *Faker) *PersonInfo {\n\treturn &PersonInfo{\n\t\tFirstName:  firstName(f),\n\t\tLastName:   lastName(f),\n\t\tGender:     gender(f),\n\t\tSSN:        ssn(f),\n\t\tHobby:      hobby(f),\n\t\tJob:        job(f),\n\t\tAddress:    address(f),\n\t\tContact:    contact(f),\n\t\tCreditCard: creditCard(f),\n\t}\n}\n\n// Name will generate a random First and Last Name\nfunc Name() string { return name(GlobalFaker) }\n\n// Name will generate a random First and Last Name\nfunc (f *Faker) Name() string { return name(f) }\n\nfunc name(f *Faker) string {\n\treturn getRandValue(f, []string{\"person\", \"first\"}) + \" \" + getRandValue(f, []string{\"person\", \"last\"})\n}\n\n// FirstName will generate a random first name\nfunc FirstName() string { return firstName(GlobalFaker) }\n\n// FirstName will generate a random first name\nfunc (f *Faker) FirstName() string { return firstName(f) }\n\nfunc firstName(f *Faker) string { return getRandValue(f, []string{\"person\", \"first\"}) }\n\n// MiddleName will generate a random middle name\nfunc MiddleName() string { return middleName(GlobalFaker) }\n\n// MiddleName will generate a random middle name\nfunc (f *Faker) MiddleName() string { return middleName(f) }\n\nfunc middleName(f *Faker) string { return getRandValue(f, []string{\"person\", \"middle\"}) }\n\n// LastName will generate a random last name\nfunc LastName() string { return lastName(GlobalFaker) }\n\n// LastName will generate a random last name\nfunc (f *Faker) LastName() string { return lastName(f) }\n\nfunc lastName(f *Faker) string { return getRandValue(f, []string{\"person\", \"last\"}) }\n\n// NamePrefix will generate a random name prefix\nfunc NamePrefix() string { return namePrefix(GlobalFaker) }\n\n// NamePrefix will generate a random name prefix\nfunc (f *Faker) NamePrefix() string { return namePrefix(f) }\n\nfunc namePrefix(f *Faker) string { return getRandValue(f, []string{\"person\", \"prefix\"}) }\n\n// NameSuffix will generate a random name suffix\nfunc NameSuffix() string { return nameSuffix(GlobalFaker) }\n\n// NameSuffix will generate a random name suffix\nfunc (f *Faker) NameSuffix() string { return nameSuffix(f) }\n\nfunc nameSuffix(f *Faker) string { return getRandValue(f, []string{\"person\", \"suffix\"}) }\n\n// SSN will generate a random Social Security Number\nfunc SSN() string { return ssn(GlobalFaker) }\n\n// SSN will generate a random Social Security Number\nfunc (f *Faker) SSN() string { return ssn(f) }\n\nfunc ssn(f *Faker) string { return strconv.Itoa(randIntRange(f, 100000000, 999999999)) }\n\n// Gender will generate a random gender string\nfunc Gender() string { return gender(GlobalFaker) }\n\n// Gender will generate a random gender string\nfunc (f *Faker) Gender() string { return gender(f) }\n\nfunc gender(f *Faker) string {\n\tif boolFunc(f) {\n\t\treturn \"male\"\n\t}\n\n\treturn \"female\"\n}\n\n// Hobby will generate a random hobby string\nfunc Hobby() string { return hobby(GlobalFaker) }\n\n// Hobby will generate a random hobby string\nfunc (f *Faker) Hobby() string { return hobby(f) }\n\nfunc hobby(f *Faker) string { return getRandValue(f, []string{\"person\", \"hobby\"}) }\n\n// ContactInfo struct full of contact info\ntype ContactInfo struct {\n\tPhone string `json:\"phone\" xml:\"phone\"`\n\tEmail string `json:\"email\" xml:\"email\"`\n}\n\n// Contact will generate a struct with information randomly populated contact information\nfunc Contact() *ContactInfo { return contact(GlobalFaker) }\n\n// Contact will generate a struct with information randomly populated contact information\nfunc (f *Faker) Contact() *ContactInfo { return contact(f) }\n\nfunc contact(f *Faker) *ContactInfo {\n\treturn &ContactInfo{\n\t\tPhone: phone(f),\n\t\tEmail: email(f),\n\t}\n}\n\n// Phone will generate a random phone number string\nfunc Phone() string { return phone(GlobalFaker) }\n\n// Phone will generate a random phone number string\nfunc (f *Faker) Phone() string { return phone(f) }\n\nfunc phone(f *Faker) string { return replaceWithNumbers(f, \"##########\") }\n\n// PhoneFormatted will generate a random phone number string\nfunc PhoneFormatted() string { return phoneFormatted(GlobalFaker) }\n\n// PhoneFormatted will generate a random phone number string\nfunc (f *Faker) PhoneFormatted() string { return phoneFormatted(f) }\n\nfunc phoneFormatted(f *Faker) string {\n\treturn replaceWithNumbers(f, getRandValue(f, []string{\"person\", \"phone\"}))\n}\n\n// Email will generate a random email string\nfunc Email() string { return email(GlobalFaker) }\n\n// Email will generate a random email string\nfunc (f *Faker) Email() string { return email(f) }\n\nfunc email(f *Faker) string {\n\temail := getRandValue(f, []string{\"person\", \"first\"}) + getRandValue(f, []string{\"person\", \"last\"})\n\temail += \"@\"\n\temail += getRandValue(f, []string{\"person\", \"last\"}) + \".\" + getRandValue(f, []string{\"internet\", \"domain_suffix\"})\n\n\treturn strings.ToLower(email)\n}\n\n// Teams takes in an array of people and team names and randomly places the people into teams as evenly as possible\nfunc Teams(peopleArray []string, teamsArray []string) map[string][]string {\n\treturn teams(GlobalFaker, peopleArray, teamsArray)\n}\n\n// Teams takes in an array of people and team names and randomly places the people into teams as evenly as possible\nfunc (f *Faker) Teams(peopleArray []string, teamsArray []string) map[string][]string {\n\treturn teams(f, peopleArray, teamsArray)\n}\n\nfunc teams(f *Faker, people []string, teams []string) map[string][]string {\n\t// Shuffle the people if more than 1\n\tif len(people) > 1 {\n\t\tshuffleStrings(f, people)\n\t}\n\n\tpeopleIndex := 0\n\tteamsOutput := make(map[string][]string)\n\tnumPer := math.Ceil(float64(len(people)) / float64(len(teams)))\n\tfor _, team := range teams {\n\t\tteamsOutput[team] = []string{}\n\t\tfor i := 0.00; i < numPer; i++ {\n\t\t\tif peopleIndex < len(people) {\n\t\t\t\tteamsOutput[team] = append(teamsOutput[team], people[peopleIndex])\n\t\t\t\tpeopleIndex++\n\t\t\t}\n\t\t}\n\t}\n\n\treturn teamsOutput\n}\n\nfunc addPersonLookup() {\n\tAddFuncLookup(\"person\", Info{\n\t\tDisplay:     \"Person\",\n\t\tCategory:    \"person\",\n\t\tDescription: \"Personal data, like name and contact details, used for identification and communication\",\n\t\tExample: `{\n\t\"first_name\": \"Markus\",\n\t\"last_name\": \"Moen\",\n\t\"gender\": \"male\",\n\t\"ssn\": \"275413589\",\n\t\"image\": \"https://picsum.photos/208/500\",\n\t\"hobby\": \"Lacrosse\",\n\t\"job\": {\n\t\t\"company\": \"Intermap Technologies\",\n\t\t\"title\": \"Developer\",\n\t\t\"descriptor\": \"Direct\",\n\t\t\"level\": \"Paradigm\"\n\t},\n\t\"address\": {\n\t\t\"address\": \"369 North Cornerbury, Miami, North Dakota 24259\",\n\t\t\"street\": \"369 North Cornerbury\",\n\t\t\"city\": \"Miami\",\n\t\t\"state\": \"North Dakota\",\n\t\t\"zip\": \"24259\",\n\t\t\"country\": \"Ghana\",\n\t\t\"latitude\": -6.662595,\n\t\t\"longitude\": 23.921575\n\t},\n\t\"contact\": {\n\t\t\"phone\": \"3023202027\",\n\t\t\"email\": \"lamarkoelpin@heaney.biz\"\n\t},\n\t\"credit_card\": {\n\t\t\"type\": \"Maestro\",\n\t\t\"number\": \"39800889982276\",\n\t\t\"exp\": \"01/29\",\n\t\t\"cvv\": \"932\"\n\t}\n}`,\n\t\tOutput:      \"map[string]any\",\n\t\tContentType: \"application/json\",\n\t\tGenerate: func(f *Faker, m *MapParams, info *Info) (any, error) {\n\t\t\treturn person(f), nil\n\t\t},\n\t})\n\n\tAddFuncLookup(\"name\", Info{\n\t\tDisplay:     \"Name\",\n\t\tCategory:    \"person\",\n\t\tDescription: \"The given and family name of an individual\",\n\t\tExample:     \"Markus Moen\",\n\t\tOutput:      \"string\",\n\t\tGenerate: func(f *Faker, m *MapParams, info *Info) (any, error) {\n\t\t\treturn name(f), nil\n\t\t},\n\t})\n\n\tAddFuncLookup(\"nameprefix\", Info{\n\t\tDisplay:     \"Name Prefix\",\n\t\tCategory:    \"person\",\n\t\tDescription: \"A title or honorific added before a person's name\",\n\t\tExample:     \"Mr.\",\n\t\tOutput:      \"string\",\n\t\tGenerate: func(f *Faker, m *MapParams, info *Info) (any, error) {\n\t\t\treturn namePrefix(f), nil\n\t\t},\n\t})\n\n\tAddFuncLookup(\"namesuffix\", Info{\n\t\tDisplay:     \"Name Suffix\",\n\t\tCategory:    \"person\",\n\t\tDescription: \"A title or designation added after a person's name\",\n\t\tExample:     \"Jr.\",\n\t\tOutput:      \"string\",\n\t\tGenerate: func(f *Faker, m *MapParams, info *Info) (any, error) {\n\t\t\treturn nameSuffix(f), nil\n\t\t},\n\t})\n\n\tAddFuncLookup(\"firstname\", Info{\n\t\tDisplay:     \"First Name\",\n\t\tCategory:    \"person\",\n\t\tDescription: \"The name given to a person at birth\",\n\t\tExample:     \"Markus\",\n\t\tOutput:      \"string\",\n\t\tGenerate: func(f *Faker, m *MapParams, info *Info) (any, error) {\n\t\t\treturn firstName(f), nil\n\t\t},\n\t})\n\n\tAddFuncLookup(\"middlename\", Info{\n\t\tDisplay:     \"Middle Name\",\n\t\tCategory:    \"person\",\n\t\tDescription: \"Name between a person's first name and last name\",\n\t\tExample:     \"Belinda\",\n\t\tOutput:      \"string\",\n\t\tGenerate: func(f *Faker, m *MapParams, info *Info) (any, error) {\n\t\t\treturn middleName(f), nil\n\t\t},\n\t})\n\n\tAddFuncLookup(\"lastname\", Info{\n\t\tDisplay:     \"Last Name\",\n\t\tCategory:    \"person\",\n\t\tDescription: \"The family name or surname of an individual\",\n\t\tExample:     \"Daniel\",\n\t\tOutput:      \"string\",\n\t\tGenerate: func(f *Faker, m *MapParams, info *Info) (any, error) {\n\t\t\treturn lastName(f), nil\n\t\t},\n\t})\n\n\tAddFuncLookup(\"gender\", Info{\n\t\tDisplay:     \"Gender\",\n\t\tCategory:    \"person\",\n\t\tDescription: \"Classification based on social and cultural norms that identifies an individual\",\n\t\tExample:     \"male\",\n\t\tOutput:      \"string\",\n\t\tGenerate: func(f *Faker, m *MapParams, info *Info) (any, error) {\n\t\t\treturn gender(f), nil\n\t\t},\n\t})\n\n\tAddFuncLookup(\"ssn\", Info{\n\t\tDisplay:     \"SSN\",\n\t\tCategory:    \"person\",\n\t\tDescription: \"Unique nine-digit identifier used for government and financial purposes in the United States\",\n\t\tExample:     \"296446360\",\n\t\tOutput:      \"string\",\n\t\tGenerate: func(f *Faker, m *MapParams, info *Info) (any, error) {\n\t\t\treturn ssn(f), nil\n\t\t},\n\t})\n\n\tAddFuncLookup(\"hobby\", Info{\n\t\tDisplay:     \"Hobby\",\n\t\tCategory:    \"person\",\n\t\tDescription: \"An activity pursued for leisure and pleasure\",\n\t\tExample:     \"Swimming\",\n\t\tOutput:      \"string\",\n\t\tGenerate: func(f *Faker, m *MapParams, info *Info) (any, error) {\n\t\t\treturn hobby(f), nil\n\t\t},\n\t})\n\n\tAddFuncLookup(\"email\", Info{\n\t\tDisplay:     \"Email\",\n\t\tCategory:    \"person\",\n\t\tDescription: \"Electronic mail used for sending digital messages and communication over the internet\",\n\t\tExample:     \"markusmoen@pagac.net\",\n\t\tOutput:      \"string\",\n\t\tGenerate: func(f *Faker, m *MapParams, info *Info) (any, error) {\n\t\t\treturn email(f), nil\n\t\t},\n\t})\n\n\tAddFuncLookup(\"phone\", Info{\n\t\tDisplay:     \"Phone\",\n\t\tCategory:    \"person\",\n\t\tDescription: \"Numerical sequence used to contact individuals via telephone or mobile devices\",\n\t\tExample:     \"6136459948\",\n\t\tOutput:      \"string\",\n\t\tGenerate: func(f *Faker, m *MapParams, info *Info) (any, error) {\n\t\t\treturn phone(f), nil\n\t\t},\n\t})\n\n\tAddFuncLookup(\"phoneformatted\", Info{\n\t\tDisplay:     \"Phone Formatted\",\n\t\tCategory:    \"person\",\n\t\tDescription: \"Formatted phone number of a person\",\n\t\tExample:     \"136-459-9489\",\n\t\tOutput:      \"string\",\n\t\tGenerate: func(f *Faker, m *MapParams, info *Info) (any, error) {\n\t\t\treturn phoneFormatted(f), nil\n\t\t},\n\t})\n\n\tAddFuncLookup(\"teams\", Info{\n\t\tDisplay:     \"Teams\",\n\t\tCategory:    \"person\",\n\t\tDescription: \"Randomly split people into teams\",\n\t\tExample: `{\n\t\"Team 1\": [\n\t\t\"Justin\",\n\t\t\"Connor\",\n\t\t\"Jeff\"\n\t],\n\t\"Team 2\": [\n\t\t\"Sharon\",\n\t\t\"Fabian\",\n\t\t\"Billy\"\n\t],\n\t\"Team 3\": [\n\t\t\"Steve\",\n\t\t\"Robert\"\n\t]\n}`,\n\t\tOutput:      \"map[string][]string\",\n\t\tContentType: \"application/json\",\n\t\tParams: []Param{\n\t\t\t{Field: \"people\", Display: \"Strings\", Type: \"[]string\", Description: \"Array of people\"},\n\t\t\t{Field: \"teams\", Display: \"Strings\", Type: \"[]string\", Description: \"Array of teams\"},\n\t\t},\n\t\tGenerate: func(f *Faker, m *MapParams, info *Info) (any, error) {\n\t\t\tpeople, err := info.GetStringArray(m, \"people\")\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\n\t\t\tteamsArray, err := info.GetStringArray(m, \"teams\")\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\n\t\t\treturn teams(f, people, teamsArray), nil\n\t\t},\n\t})\n}\n"
        },
        {
          "name": "person_test.go",
          "type": "blob",
          "size": 6.814453125,
          "content": "package gofakeit\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc ExampleName() {\n\tSeed(11)\n\tfmt.Println(Name())\n\n\t// Output: Sonny Stiedemann\n}\n\nfunc ExampleFaker_Name() {\n\tf := New(11)\n\tfmt.Println(f.Name())\n\n\t// Output: Sonny Stiedemann\n}\n\nfunc BenchmarkName(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tName()\n\t}\n}\n\nfunc ExampleFirstName() {\n\tSeed(11)\n\tfmt.Println(FirstName())\n\n\t// Output: Sonny\n}\n\nfunc ExampleFaker_FirstName() {\n\tf := New(11)\n\tfmt.Println(f.FirstName())\n\n\t// Output: Sonny\n}\n\nfunc BenchmarkFirstName(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tFirstName()\n\t}\n}\n\nfunc ExampleMiddleName() {\n\tSeed(11)\n\tfmt.Println(MiddleName())\n\n\t// Output: Star\n}\n\nfunc ExampleFaker_MiddleName() {\n\tf := New(11)\n\tfmt.Println(f.MiddleName())\n\n\t// Output: Star\n}\n\nfunc BenchmarkMiddleName(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tMiddleName()\n\t}\n}\n\nfunc ExampleLastName() {\n\tSeed(11)\n\tfmt.Println(LastName())\n\n\t// Output: Treutel\n}\n\nfunc ExampleFaker_LastName() {\n\tf := New(11)\n\tfmt.Println(f.LastName())\n\n\t// Output: Treutel\n}\n\nfunc BenchmarkLastName(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tLastName()\n\t}\n}\n\nfunc ExampleNamePrefix() {\n\tSeed(11)\n\tfmt.Println(NamePrefix())\n\n\t// Output: Dr.\n}\n\nfunc ExampleFaker_NamePrefix() {\n\tf := New(11)\n\tfmt.Println(f.NamePrefix())\n\n\t// Output: Dr.\n}\n\nfunc BenchmarkNamePrefix(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tNamePrefix()\n\t}\n}\n\nfunc ExampleNameSuffix() {\n\tSeed(11)\n\tfmt.Println(NameSuffix())\n\n\t// Output: PhD\n}\n\nfunc ExampleFaker_NameSuffix() {\n\tf := New(11)\n\tfmt.Println(f.NameSuffix())\n\n\t// Output: PhD\n}\n\nfunc BenchmarkNameSuffix(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tNameSuffix()\n\t}\n}\n\nfunc ExampleSSN() {\n\tSeed(11)\n\tfmt.Println(SSN())\n\n\t// Output: 906295542\n}\n\nfunc ExampleFaker_SSN() {\n\tf := New(11)\n\tfmt.Println(f.SSN())\n\n\t// Output: 906295542\n}\n\nfunc BenchmarkSSN(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tSSN()\n\t}\n}\n\nfunc ExampleGender() {\n\tSeed(11)\n\tfmt.Println(Gender())\n\n\t// Output: female\n}\n\nfunc ExampleFaker_Gender() {\n\tf := New(11)\n\tfmt.Println(f.Gender())\n\n\t// Output: female\n}\n\nfunc BenchmarkGender(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tGender()\n\t}\n}\n\nfunc ExampleHobby() {\n\tSeed(11)\n\tfmt.Println(Hobby())\n\n\t// Output: Marching band\n}\n\nfunc ExampleFaker_Hobby() {\n\tf := New(11)\n\tfmt.Println(f.Hobby())\n\n\t// Output: Marching band\n}\n\nfunc BenchmarkHobby(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tHobby()\n\t}\n}\n\nfunc ExamplePerson() {\n\tSeed(11)\n\tperson := Person()\n\tjob := person.Job\n\taddress := person.Address\n\tcontact := person.Contact\n\tcreditCard := person.CreditCard\n\n\tfmt.Println(person.FirstName)\n\tfmt.Println(person.LastName)\n\tfmt.Println(person.Gender)\n\tfmt.Println(person.SSN)\n\tfmt.Println(person.Hobby)\n\n\tfmt.Println(job.Company)\n\tfmt.Println(job.Title)\n\tfmt.Println(job.Descriptor)\n\tfmt.Println(job.Level)\n\n\tfmt.Println(address.Address)\n\tfmt.Println(address.Street)\n\tfmt.Println(address.City)\n\tfmt.Println(address.State)\n\tfmt.Println(address.Zip)\n\tfmt.Println(address.Country)\n\tfmt.Println(address.Latitude)\n\tfmt.Println(address.Longitude)\n\n\tfmt.Println(contact.Phone)\n\tfmt.Println(contact.Email)\n\n\tfmt.Println(creditCard.Type)\n\tfmt.Println(creditCard.Number)\n\tfmt.Println(creditCard.Exp)\n\tfmt.Println(creditCard.Cvv)\n\n\t// Output: Sonny\n\t// Stiedemann\n\t// male\n\t// 280254464\n\t// Sailing\n\t// DataLogix\n\t// Planner\n\t// Human\n\t// Usability\n\t// 679 Underpassborough, Omaha, Massachusetts 37930\n\t// 679 Underpassborough\n\t// Omaha\n\t// Massachusetts\n\t// 37930\n\t// North Macedonia\n\t// -0.877085\n\t// 83.264578\n\t// 4102689405\n\t// verdabrakus@mayert.name\n\t// American Express\n\t// 562570938760\n\t// 04/25\n\t// 906\n}\n\nfunc ExampleFaker_Person() {\n\tf := New(11)\n\tperson := f.Person()\n\tjob := person.Job\n\taddress := person.Address\n\tcontact := person.Contact\n\tcreditCard := person.CreditCard\n\n\tfmt.Println(person.FirstName)\n\tfmt.Println(person.LastName)\n\tfmt.Println(person.Gender)\n\tfmt.Println(person.SSN)\n\tfmt.Println(person.Hobby)\n\n\tfmt.Println(job.Company)\n\tfmt.Println(job.Title)\n\tfmt.Println(job.Descriptor)\n\tfmt.Println(job.Level)\n\n\tfmt.Println(address.Address)\n\tfmt.Println(address.Street)\n\tfmt.Println(address.City)\n\tfmt.Println(address.State)\n\tfmt.Println(address.Zip)\n\tfmt.Println(address.Country)\n\tfmt.Println(address.Latitude)\n\tfmt.Println(address.Longitude)\n\n\tfmt.Println(contact.Phone)\n\tfmt.Println(contact.Email)\n\n\tfmt.Println(creditCard.Type)\n\tfmt.Println(creditCard.Number)\n\tfmt.Println(creditCard.Exp)\n\tfmt.Println(creditCard.Cvv)\n\n\t// Output: Sonny\n\t// Stiedemann\n\t// male\n\t// 280254464\n\t// Sailing\n\t// DataLogix\n\t// Planner\n\t// Human\n\t// Usability\n\t// 679 Underpassborough, Omaha, Massachusetts 37930\n\t// 679 Underpassborough\n\t// Omaha\n\t// Massachusetts\n\t// 37930\n\t// North Macedonia\n\t// -0.877085\n\t// 83.264578\n\t// 4102689405\n\t// verdabrakus@mayert.name\n\t// American Express\n\t// 562570938760\n\t// 04/25\n\t// 906\n}\n\nfunc BenchmarkPerson(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tPerson()\n\t}\n}\n\nfunc ExampleContact() {\n\tSeed(11)\n\tcontact := Contact()\n\tfmt.Println(contact.Phone)\n\tfmt.Println(contact.Email)\n\n\t// Output: 8812527598\n\t// stevebins@robel.io\n}\n\nfunc ExampleFaker_Contact() {\n\tf := New(11)\n\tcontact := f.Contact()\n\tfmt.Println(contact.Phone)\n\tfmt.Println(contact.Email)\n\n\t// Output: 8812527598\n\t// stevebins@robel.io\n}\n\nfunc BenchmarkContact(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tContact()\n\t}\n}\n\nfunc ExamplePhone() {\n\tSeed(11)\n\tfmt.Println(Phone())\n\n\t// Output: 8812527598\n}\n\nfunc ExampleFaker_Phone() {\n\tf := New(11)\n\tfmt.Println(f.Phone())\n\n\t// Output: 8812527598\n}\n\nfunc BenchmarkPhone(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tPhone()\n\t}\n}\n\nfunc ExamplePhoneFormatted() {\n\tSeed(11)\n\tfmt.Println(PhoneFormatted())\n\n\t// Output: 812-527-5989\n}\n\nfunc ExampleFaker_PhoneFormatted() {\n\tf := New(11)\n\tfmt.Println(f.PhoneFormatted())\n\n\t// Output: 812-527-5989\n}\n\nfunc BenchmarkPhoneFormatted(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tPhoneFormatted()\n\t}\n}\n\nfunc ExampleEmail() {\n\tSeed(11)\n\tfmt.Println(Email())\n\n\t// Output: sonnystiedemann@donnelly.biz\n}\n\nfunc ExampleFaker_Email() {\n\tf := New(11)\n\tfmt.Println(f.Email())\n\n\t// Output: sonnystiedemann@donnelly.biz\n}\n\nfunc BenchmarkEmail(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tEmail()\n\t}\n}\n\nfunc ExampleTeams() {\n\tSeed(11)\n\tfmt.Println(Teams(\n\t\t[]string{\"Billy\", \"Sharon\", \"Jeff\", \"Connor\", \"Steve\", \"Justin\", \"Fabian\", \"Robert\"},\n\t\t[]string{\"Team 1\", \"Team 2\", \"Team 3\"},\n\t))\n\n\t// Output: map[Team 1:[Jeff Robert Billy] Team 2:[Connor Fabian Sharon] Team 3:[Justin Steve]]\n}\n\nfunc ExampleFaker_Teams() {\n\tf := New(11)\n\tfmt.Println(f.Teams(\n\t\t[]string{\"Billy\", \"Sharon\", \"Jeff\", \"Connor\", \"Steve\", \"Justin\", \"Fabian\", \"Robert\"},\n\t\t[]string{\"Team 1\", \"Team 2\", \"Team 3\"},\n\t))\n\n\t// Output: map[Team 1:[Jeff Robert Billy] Team 2:[Connor Fabian Sharon] Team 3:[Justin Steve]]\n}\n\nfunc BenchmarkTeams(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tTeams(\n\t\t\t[]string{\"Billy\", \"Sharon\", \"Jeff\", \"Connor\", \"Steve\", \"Justin\", \"Fabian\", \"Robert\"},\n\t\t\t[]string{\"Team 1\", \"Team 2\", \"Team 3\"},\n\t\t)\n\t}\n}\n"
        },
        {
          "name": "product.go",
          "type": "blob",
          "size": 12.6513671875,
          "content": "package gofakeit\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n)\n\ntype ProductInfo struct {\n\tName        string   `json:\"name\" xml:\"name\"`\n\tDescription string   `json:\"description\" xml:\"description\"`\n\tCategories  []string `json:\"categories\" xml:\"categories\"`\n\tPrice       float64  `json:\"price\" xml:\"price\"`\n\tFeatures    []string `json:\"features\" xml:\"features\"`\n\tColor       string   `json:\"color\" xml:\"color\"`\n\tMaterial    string   `json:\"material\" xml:\"material\"`\n\tUPC         string   `json:\"upc\" xml:\"upc\"`\n\tAudience    []string `json:\"audience\" xml:\"audience\"`\n\tDimension   string   `json:\"dimension\" xml:\"dimension\"`\n\tUseCase     string   `json:\"use_case\" xml:\"use_case\"`\n\tBenefit     string   `json:\"benefit\" xml:\"benefit\"`\n\tSuffix      string   `json:\"suffix\" xml:\"suffix\"`\n}\n\n// Product will generate a random set of product information\nfunc Product() *ProductInfo { return product(GlobalFaker) }\n\n// Product will generate a random set of product information\nfunc (f *Faker) Product() *ProductInfo { return product(f) }\n\nfunc product(f *Faker) *ProductInfo {\n\t// Categories\n\tcategories := []string{}\n\tweightedCategory, _ := weighted(f, []any{1, 2, 3, 4}, []float32{1, 4, 3, 4})\n\n\tfor i := 0; i < weightedCategory.(int); i++ {\n\t\tcategories = append(categories, productCategory(f))\n\t}\n\n\t// Features\n\tfeatures := []string{}\n\tfor i := 0; i < number(f, 1, 5); i++ {\n\t\tfeatures = append(features, productFeature(f))\n\t}\n\n\tproduct := &ProductInfo{\n\t\tName:        productName(f),\n\t\tDescription: productDescription(f),\n\t\tCategories:  categories,\n\t\tPrice:       price(f, 3.00, 100.00),\n\t\tUPC:         productUPC(f),\n\t\tFeatures:    features,\n\t\tColor:       safeColor(f),\n\t\tMaterial:    productMaterial(f),\n\t\tAudience:    productAudience(f),\n\t\tDimension:   productDimension(f),\n\t\tUseCase:     productUseCase(f),\n\t\tBenefit:     productBenefit(f),\n\t\tSuffix:      productSuffix(f),\n\t}\n\n\treturn product\n}\n\n// ProductName will generate a random product name\nfunc ProductName() string { return productName(GlobalFaker) }\n\n// ProductName will generate a random product name\nfunc (f *Faker) ProductName() string { return productName(f) }\n\nfunc productName(f *Faker) string {\n\tname := getRandValue(f, []string{\"product\", \"name\"})\n\tswitch number(f, 0, 9) {\n\tcase 1:\n\t\t// Name + Adjective + Feature\n\t\treturn title(fmt.Sprintf(\"%s %s %s\", name, getRandValue(f, []string{\"product\", \"adjective\"}), productFeature(f)))\n\tcase 2:\n\t\t// Adjective + Material + Name\n\t\treturn title(fmt.Sprintf(\"%s %s %s\", getRandValue(f, []string{\"product\", \"adjective\"}), productMaterial(f), name))\n\tcase 3:\n\t\t// Color + Name + Suffix\n\t\treturn title(fmt.Sprintf(\"%s %s %s\", safeColor(f), name, getRandValue(f, []string{\"product\", \"suffix\"})))\n\tcase 4:\n\t\t// Feature + Name + Adjective\n\t\treturn title(fmt.Sprintf(\"%s %s %s\", productFeature(f), name, getRandValue(f, []string{\"product\", \"adjective\"})))\n\tcase 5:\n\t\t// Material + Color + Name\n\t\treturn title(fmt.Sprintf(\"%s %s %s\", productMaterial(f), safeColor(f), name))\n\tcase 6:\n\t\t// Name + Suffix + Material\n\t\treturn title(fmt.Sprintf(\"%s %s %s\", name, getRandValue(f, []string{\"product\", \"suffix\"}), productMaterial(f)))\n\tcase 7:\n\t\t// Adjective + Feature + Name\n\t\treturn title(fmt.Sprintf(\"%s %s %s\", getRandValue(f, []string{\"product\", \"adjective\"}), productFeature(f), name))\n\tcase 8:\n\t\t// Color + Material + Name\n\t\treturn title(fmt.Sprintf(\"%s %s %s\", safeColor(f), productMaterial(f), name))\n\tcase 9:\n\t\t// Suffix + Adjective + Name\n\t\treturn title(fmt.Sprintf(\"%s %s %s\", getRandValue(f, []string{\"product\", \"suffix\"}), getRandValue(f, []string{\"product\", \"adjective\"}), name))\n\t}\n\n\t// case: 0 - Adjective + Name + Suffix\n\treturn title(fmt.Sprintf(\"%s %s %s\", getRandValue(f, []string{\"product\", \"adjective\"}), name, getRandValue(f, []string{\"product\", \"suffix\"})))\n}\n\n// ProductDescription will generate a random product description\nfunc ProductDescription() string { return productDescription(GlobalFaker) }\n\n// ProductDescription will generate a random product description\nfunc (f *Faker) ProductDescription() string { return productDescription(f) }\n\nfunc productDescription(f *Faker) string {\n\tprodDesc := getRandValue(f, []string{\"product\", \"description\"})\n\n\t// Replace all {productaudience} with join \"and\"\n\tfor strings.Contains(prodDesc, \"{productaudience}\") {\n\t\tprodDesc = strings.Replace(prodDesc, \"{productaudience}\", strings.Join(productAudience(f), \" and \"), 1)\n\t}\n\n\tdesc, _ := generate(f, prodDesc)\n\treturn desc\n}\n\n// ProductCategory will generate a random product category\nfunc ProductCategory() string { return productCategory(GlobalFaker) }\n\n// ProductCategory will generate a random product category\nfunc (f *Faker) ProductCategory() string { return productCategory(f) }\n\nfunc productCategory(f *Faker) string {\n\treturn getRandValue(f, []string{\"product\", \"category\"})\n}\n\n// ProductFeature will generate a random product feature\nfunc ProductFeature() string { return productFeature(GlobalFaker) }\n\n// ProductFeature will generate a random product feature\nfunc (f *Faker) ProductFeature() string { return productFeature(f) }\n\nfunc productFeature(f *Faker) string {\n\treturn getRandValue(f, []string{\"product\", \"feature\"})\n}\n\n// ProductMaterial will generate a random product material\nfunc ProductMaterial() string { return productMaterial(GlobalFaker) }\n\n// ProductMaterial will generate a random product material\nfunc (f *Faker) ProductMaterial() string { return productMaterial(f) }\n\nfunc productMaterial(f *Faker) string {\n\treturn getRandValue(f, []string{\"product\", \"material\"})\n}\n\n// ProductUPC will generate a random product UPC\nfunc ProductUPC() string { return productUPC(GlobalFaker) }\n\n// ProductUPC will generate a random product UPC\nfunc (f *Faker) ProductUPC() string { return productUPC(f) }\n\nfunc productUPC(f *Faker) string {\n\t// The first digit of a UPC is a fixed digit (usually 0)\n\tupc := \"0\"\n\n\t// Generate the remaining 11 digits randomly\n\tfor i := 1; i < 12; i++ {\n\t\tdigit := number(f, 0, 9)\n\t\tupc += fmt.Sprintf(\"%d\", digit)\n\t}\n\n\treturn upc\n}\n\n// ProductAudience will generate a random target audience\nfunc ProductAudience() []string { return productAudience(GlobalFaker) }\n\n// ProductAudience will generate a random target audience\nfunc (f *Faker) ProductAudience() []string { return productAudience(f) }\n\nfunc productAudience(f *Faker) []string {\n\taudiences := []string{}\n\tfor i := 0; i < number(f, 1, 2); i++ {\n\t\t// Check if the target audience is already in the list\n\t\t// If it is, generate a new target audience\n\t\tfor {\n\t\t\taudience := getRandValue(f, []string{\"product\", \"target_audience\"})\n\t\t\t// Check if in array\n\t\t\tif !stringInSlice(audience, audiences) {\n\t\t\t\taudiences = append(audiences, audience)\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}\n\treturn audiences\n}\n\n// ProductDimension will generate a random product dimension\nfunc ProductDimension() string { return productDimension(GlobalFaker) }\n\n// ProductDimension will generate a random product dimension\nfunc (f *Faker) ProductDimension() string { return productDimension(f) }\n\nfunc productDimension(f *Faker) string {\n\treturn getRandValue(f, []string{\"product\", \"dimension\"})\n}\n\n// ProductUseCase will generate a random product use case\nfunc ProductUseCase() string { return productUseCase(GlobalFaker) }\n\n// ProductUseCase will generate a random product use case\nfunc (f *Faker) ProductUseCase() string { return productUseCase(f) }\n\nfunc productUseCase(f *Faker) string {\n\treturn getRandValue(f, []string{\"product\", \"use_case\"})\n}\n\n// ProductBenefit will generate a random product benefit\nfunc ProductBenefit() string { return productBenefit(GlobalFaker) }\n\n// ProductBenefit will generate a random product benefit\nfunc (f *Faker) ProductBenefit() string { return productBenefit(f) }\n\nfunc productBenefit(f *Faker) string {\n\treturn getRandValue(f, []string{\"product\", \"benefit\"})\n}\n\n// ProductSuffix will generate a random product suffix\nfunc ProductSuffix() string { return productSuffix(GlobalFaker) }\n\n// ProductSuffix will generate a random product suffix\nfunc (f *Faker) ProductSuffix() string { return productSuffix(f) }\n\nfunc productSuffix(f *Faker) string {\n\treturn getRandValue(f, []string{\"product\", \"suffix\"})\n}\n\nfunc addProductLookup() {\n\tAddFuncLookup(\"product\", Info{\n\t\tDisplay:     \"Product\",\n\t\tCategory:    \"product\",\n\t\tDescription: \"An item created for sale or use\",\n\t\tExample: `{\n\t\"name\": \"olive copper monitor\",\n\t\"description\": \"Backwards caused quarterly without week it hungry thing someone him regularly. Whomever this revolt hence from his timing as quantity us these yours.\",\n\t\"categories\": [\n\t\t\"clothing\",\n\t\t\"tools and hardware\"\n\t],\n\t\"price\": 7.61,\n\t\"features\": [\n\t\t\"ultra-lightweight\"\n\t],\n\t\"color\": \"navy\",\n\t\"material\": \"brass\",\n\t\"upc\": \"012780949980\",\n\t\"audience\": [\n\t\t\"adults\"\n\t],\n\t\"dimension\": \"medium\",\n\t\"use_case\": \"home\",\n\t\"benefit\": \"comfort\",\n\t\"suffix\": \"pro\"\n}`,\n\t\tOutput:      \"map[string]any\",\n\t\tContentType: \"application/json\",\n\t\tGenerate: func(f *Faker, m *MapParams, info *Info) (any, error) {\n\t\t\treturn product(f), nil\n\t\t},\n\t})\n\n\tAddFuncLookup(\"productname\", Info{\n\t\tDisplay:     \"Product Name\",\n\t\tCategory:    \"product\",\n\t\tDescription: \"Distinctive title or label assigned to a product for identification and marketing\",\n\t\tExample:     \"olive copper monitor\",\n\t\tOutput:      \"string\",\n\t\tGenerate: func(f *Faker, m *MapParams, info *Info) (any, error) {\n\t\t\treturn productName(f), nil\n\t\t},\n\t})\n\n\tAddFuncLookup(\"productdescription\", Info{\n\t\tDisplay:     \"Product Description\",\n\t\tCategory:    \"product\",\n\t\tDescription: \"Explanation detailing the features and characteristics of a product\",\n\t\tExample:     \"Backwards caused quarterly without week it hungry thing someone him regularly. Whomever this revolt hence from his timing as quantity us these yours.\",\n\t\tOutput:      \"string\",\n\t\tGenerate: func(f *Faker, m *MapParams, info *Info) (any, error) {\n\t\t\treturn productDescription(f), nil\n\t\t},\n\t})\n\n\tAddFuncLookup(\"productcategory\", Info{\n\t\tDisplay:     \"Product Category\",\n\t\tCategory:    \"product\",\n\t\tDescription: \"Classification grouping similar products based on shared characteristics or functions\",\n\t\tExample:     \"clothing\",\n\t\tOutput:      \"string\",\n\t\tGenerate: func(f *Faker, m *MapParams, info *Info) (any, error) {\n\t\t\treturn productCategory(f), nil\n\t\t},\n\t})\n\n\tAddFuncLookup(\"productfeature\", Info{\n\t\tDisplay:     \"Product Feature\",\n\t\tCategory:    \"product\",\n\t\tDescription: \"Specific characteristic of a product that distinguishes it from others products\",\n\t\tExample:     \"ultra-lightweight\",\n\t\tOutput:      \"string\",\n\t\tGenerate: func(f *Faker, m *MapParams, info *Info) (any, error) {\n\t\t\treturn productFeature(f), nil\n\t\t},\n\t})\n\n\tAddFuncLookup(\"productmaterial\", Info{\n\t\tDisplay:     \"Product Material\",\n\t\tCategory:    \"product\",\n\t\tDescription: \"The substance from which a product is made, influencing its appearance, durability, and properties\",\n\t\tExample:     \"brass\",\n\t\tOutput:      \"string\",\n\t\tGenerate: func(f *Faker, m *MapParams, info *Info) (any, error) {\n\t\t\treturn productMaterial(f), nil\n\t\t},\n\t})\n\n\tAddFuncLookup(\"productupc\", Info{\n\t\tDisplay:     \"Product UPC\",\n\t\tCategory:    \"product\",\n\t\tDescription: \"Standardized barcode used for product identification and tracking in retail and commerce\",\n\t\tExample:     \"012780949980\",\n\t\tOutput:      \"string\",\n\t\tGenerate: func(f *Faker, m *MapParams, info *Info) (any, error) {\n\t\t\treturn productUPC(f), nil\n\t\t},\n\t})\n\n\tAddFuncLookup(\"productaudience\", Info{\n\t\tDisplay:     \"Product Audience\",\n\t\tCategory:    \"product\",\n\t\tDescription: \"The group of people for whom the product is designed or intended\",\n\t\tExample:     \"adults\",\n\t\tOutput:      \"[]string\",\n\t\tGenerate: func(f *Faker, m *MapParams, info *Info) (any, error) {\n\t\t\treturn productAudience(f), nil\n\t\t},\n\t})\n\n\tAddFuncLookup(\"productdimension\", Info{\n\t\tDisplay:     \"Product Dimension\",\n\t\tCategory:    \"product\",\n\t\tDescription: \"The size or dimension of a product\",\n\t\tExample:     \"medium\",\n\t\tOutput:      \"string\",\n\t\tGenerate: func(f *Faker, m *MapParams, info *Info) (any, error) {\n\t\t\treturn productDimension(f), nil\n\t\t},\n\t})\n\n\tAddFuncLookup(\"productusecase\", Info{\n\t\tDisplay:     \"Product Use Case\",\n\t\tCategory:    \"product\",\n\t\tDescription: \"The scenario or purpose for which a product is typically used\",\n\t\tExample:     \"home\",\n\t\tOutput:      \"string\",\n\t\tGenerate: func(f *Faker, m *MapParams, info *Info) (any, error) {\n\t\t\treturn productUseCase(f), nil\n\t\t},\n\t})\n\n\tAddFuncLookup(\"productbenefit\", Info{\n\t\tDisplay:     \"Product Benefit\",\n\t\tCategory:    \"product\",\n\t\tDescription: \"The key advantage or value the product provides\",\n\t\tExample:     \"comfort\",\n\t\tOutput:      \"string\",\n\t\tGenerate: func(f *Faker, m *MapParams, info *Info) (any, error) {\n\t\t\treturn productBenefit(f), nil\n\t\t},\n\t})\n\n\tAddFuncLookup(\"productsuffix\", Info{\n\t\tDisplay:     \"Product Suffix\",\n\t\tCategory:    \"product\",\n\t\tDescription: \"A suffix used to differentiate product models or versions\",\n\t\tExample:     \"pro\",\n\t\tOutput:      \"string\",\n\t\tGenerate: func(f *Faker, m *MapParams, info *Info) (any, error) {\n\t\t\treturn productSuffix(f), nil\n\t\t},\n\t})\n}\n"
        },
        {
          "name": "product_test.go",
          "type": "blob",
          "size": 6.6884765625,
          "content": "package gofakeit\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\t\"testing\"\n)\n\nfunc ExampleProduct() {\n\tSeed(11)\n\tproduct := Product()\n\tfmt.Println(product.Name)\n\tfmt.Println(product.Description)\n\tfmt.Println(product.Categories)\n\tfmt.Println(product.Price)\n\tfmt.Println(product.Features)\n\tfmt.Println(product.Color)\n\tfmt.Println(product.Material)\n\tfmt.Println(product.UPC)\n\tfmt.Println(product.Audience)\n\tfmt.Println(product.Dimension)\n\tfmt.Println(product.UseCase)\n\tfmt.Println(product.Benefit)\n\tfmt.Println(product.Suffix)\n\n\t// Output: Wave Precision Lamp\n\t// This upset product is crafted from wood and includes wireless, making it perfect for personal grooming and delivering comfort for travelers and professionals.\n\t// [cosmetics outdoor gear]\n\t// 73.93\n\t// [touchscreen ultra-lightweight gps-enabled biometric]\n\t// maroon\n\t// silver\n\t// 041026894059\n\t// [gamers musicians]\n\t// heavy\n\t// learning\n\t// efficiency\n\t// dash\n}\n\nfunc ExampleFaker_Product() {\n\tf := New(11)\n\tproduct := f.Product()\n\tfmt.Println(product.Name)\n\tfmt.Println(product.Description)\n\tfmt.Println(product.Categories)\n\tfmt.Println(product.Price)\n\tfmt.Println(product.Features)\n\tfmt.Println(product.Color)\n\tfmt.Println(product.Material)\n\tfmt.Println(product.UPC)\n\tfmt.Println(product.Audience)\n\tfmt.Println(product.Dimension)\n\tfmt.Println(product.UseCase)\n\tfmt.Println(product.Benefit)\n\tfmt.Println(product.Suffix)\n\n\t// Output: Wave Precision Lamp\n\t// This upset product is crafted from wood and includes wireless, making it perfect for personal grooming and delivering comfort for travelers and professionals.\n\t// [cosmetics outdoor gear]\n\t// 73.93\n\t// [touchscreen ultra-lightweight gps-enabled biometric]\n\t// maroon\n\t// silver\n\t// 041026894059\n\t// [gamers musicians]\n\t// heavy\n\t// learning\n\t// efficiency\n\t// dash\n}\n\nfunc TestProduct(t *testing.T) {\n\tfor i := 0; i < 1000; i++ {\n\t\tproduct := Product()\n\t\tif product.Name == \"\" {\n\t\t\tt.Error(\"Name is empty\")\n\t\t}\n\n\t\tif product.Description == \"\" {\n\t\t\tt.Error(\"Description is empty\")\n\t\t}\n\n\t\tif len(product.Categories) == 0 {\n\t\t\tt.Error(\"Categories is empty\")\n\t\t}\n\n\t\tif product.Price == 0 {\n\t\t\tt.Error(\"Price is empty\")\n\t\t}\n\n\t\tif len(product.Features) == 0 {\n\t\t\tt.Error(\"Features is empty\")\n\t\t}\n\n\t\tif product.Color == \"\" {\n\t\t\tt.Error(\"Color is empty\")\n\t\t}\n\n\t\tif product.Material == \"\" {\n\t\t\tt.Error(\"Material is empty\")\n\t\t}\n\n\t\tif product.UPC == \"\" {\n\t\t\tt.Error(\"UPC is empty\")\n\t\t}\n\n\t\tif len(product.Audience) == 0 {\n\t\t\tt.Error(\"Audience is empty\")\n\t\t}\n\n\t\tif product.Dimension == \"\" {\n\t\t\tt.Error(\"Dimension is empty\")\n\t\t}\n\n\t\tif len(product.UseCase) == 0 {\n\t\t\tt.Error(\"UseCase is empty\")\n\t\t}\n\n\t\tif len(product.Benefit) == 0 {\n\t\t\tt.Error(\"Benefit is empty\")\n\t\t}\n\n\t\tif product.Suffix == \"\" {\n\t\t\tt.Error(\"Suffix is empty\")\n\t\t}\n\t}\n}\n\nfunc BenchmarkProduct(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tProduct()\n\t}\n}\n\nfunc ExampleProductName() {\n\tSeed(11)\n\tfmt.Println(ProductName())\n\n\t// Output: Green Glass Hair Dryer\n}\n\nfunc ExampleFaker_ProductName() {\n\tf := New(11)\n\tfmt.Println(f.ProductName())\n\n\t// Output: Green Glass Hair Dryer\n}\n\nfunc BenchmarkProductName(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tProductName()\n\t}\n}\n\nfunc ExampleProductDescription() {\n\tSeed(11)\n\tfmt.Println(ProductDescription())\n\n\t// Output: This product, ideal for seniors and families, features puzzled gold and incorporates gps-enabled to ensure robust construction during remote work.\n}\n\nfunc ExampleFaker_ProductDescription() {\n\tf := New(11)\n\tfmt.Println(f.ProductDescription())\n\n\t// Output: This product, ideal for seniors and families, features puzzled gold and incorporates gps-enabled to ensure robust construction during remote work.\n}\n\n// Runs 10,000 tests to ensure description doesnt have any { or } in it\nfunc TestProductDescriptionReplacement(t *testing.T) {\n\tfor i := 0; i < 100000; i++ {\n\t\tdesc := ProductDescription()\n\t\tif strings.ContainsAny(desc, \"{\") || strings.ContainsAny(desc, \"}\") {\n\t\t\tt.Error(\"Description contains { or }\")\n\t\t}\n\t}\n}\n\nfunc BenchmarkProductDescription(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tProductDescription()\n\t}\n}\n\nfunc ExampleProductCategory() {\n\tSeed(11)\n\tfmt.Println(ProductCategory())\n\n\t// Output: pet food\n}\n\nfunc ExampleFaker_ProductCategory() {\n\tf := New(11)\n\tfmt.Println(f.ProductCategory())\n\n\t// Output: pet food\n}\n\nfunc BenchmarkProductCategory(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tProductCategory()\n\t}\n}\n\nfunc ExampleProductFeature() {\n\tSeed(11)\n\tfmt.Println(ProductFeature())\n\n\t// Output: fast-charging\n}\n\nfunc ExampleFaker_ProductFeature() {\n\tf := New(11)\n\tfmt.Println(f.ProductFeature())\n\n\t// Output: fast-charging\n}\n\nfunc BenchmarkProductFeature(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tProductFeature()\n\t}\n}\n\nfunc ExampleProductMaterial() {\n\tSeed(11)\n\tfmt.Println(ProductMaterial())\n\n\t// Output: quartz\n}\n\nfunc ExampleFaker_ProductMaterial() {\n\tf := New(11)\n\tfmt.Println(f.ProductMaterial())\n\n\t// Output: quartz\n}\n\nfunc BenchmarkProductMaterial(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tProductMaterial()\n\t}\n}\n\nfunc ExampleProductUPC() {\n\tSeed(11)\n\tfmt.Println(ProductUPC())\n\n\t// Output: 088125275989\n}\n\nfunc ExampleFaker_ProductUPC() {\n\tf := New(11)\n\tfmt.Println(f.ProductUPC())\n\n\t// Output: 088125275989\n}\n\nfunc BenchmarkProductUPC(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tProductUPC()\n\t}\n}\n\nfunc ExampleProductAudience() {\n\tSeed(11)\n\tfmt.Println(ProductAudience())\n\n\t// Output: [DIY enthusiasts students]\n}\n\nfunc ExampleFaker_ProductAudience() {\n\tf := New(11)\n\tfmt.Println(f.ProductAudience())\n\n\t// Output: [DIY enthusiasts students]\n}\n\nfunc BenchmarkProductAudience(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tProductAudience()\n\t}\n}\n\nfunc ExampleProductDimension() {\n\tSeed(11)\n\tfmt.Println(ProductDimension())\n\n\t// Output: standard\n}\n\nfunc ExampleFaker_ProductDimension() {\n\tf := New(11)\n\tfmt.Println(f.ProductDimension())\n\n\t// Output: standard\n}\n\nfunc BenchmarkProductDimension(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tProductDimension()\n\t}\n}\n\nfunc ExampleProductUseCase() {\n\tSeed(11)\n\tfmt.Println(ProductUseCase())\n\n\t// Output: remote work\n}\n\nfunc ExampleFaker_ProductUseCase() {\n\tf := New(11)\n\tfmt.Println(f.ProductUseCase())\n\n\t// Output: remote work\n}\n\nfunc BenchmarkProductUseCase(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tProductUseCase()\n\t}\n}\n\nfunc ExampleProductBenefit() {\n\tSeed(11)\n\tfmt.Println(ProductBenefit())\n\n\t// Output: minimal maintenance\n}\n\nfunc ExampleFaker_ProductBenefit() {\n\tf := New(11)\n\tfmt.Println(f.ProductBenefit())\n\n\t// Output: minimal maintenance\n}\n\nfunc BenchmarkProductBenefit(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tProductBenefit()\n\t}\n}\n\nfunc ExampleProductSuffix() {\n\tSeed(11)\n\tfmt.Println(ProductSuffix())\n\n\t// Output: turbo\n}\n\nfunc ExampleFaker_ProductSuffix() {\n\tf := New(11)\n\tfmt.Println(f.ProductSuffix())\n\n\t// Output: turbo\n}\n\nfunc BenchmarkProductSuffix(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tProductSuffix()\n\t}\n}\n"
        },
        {
          "name": "school.go",
          "type": "blob",
          "size": 0.7216796875,
          "content": "package gofakeit\r\n\r\n// School will generate a random School type\r\nfunc School() string { return school(GlobalFaker) }\r\n\r\nfunc (f *Faker) School() string { return school(f) }\r\n\r\nfunc school(f *Faker) string {\r\n\treturn getRandValue(f, []string{\"school\", \"name\"}) + \" \" +\r\n\t\tgetRandValue(f, []string{\"school\", \"isPrivate\"}) + \" \" +\r\n\t\tgetRandValue(f, []string{\"school\", \"type\"})\r\n}\r\n\r\nfunc addSchoolLookup() {\r\n\tAddFuncLookup(\"school\", Info{\r\n\t\tDisplay:     \"School\",\r\n\t\tCategory:    \"school\",\r\n\t\tDescription: \"An institution for formal education and learning\",\r\n\t\tExample:     `Harborview State Academy`,\r\n\t\tOutput:      \"string\",\r\n\t\tGenerate: func(f *Faker, m *MapParams, info *Info) (any, error) {\r\n\t\t\treturn school(f), nil\r\n\t\t},\r\n\t})\r\n}\r\n"
        },
        {
          "name": "school_test.go",
          "type": "blob",
          "size": 0.3525390625,
          "content": "package gofakeit\r\n\r\nimport (\r\n\t\"fmt\"\r\n\t\"testing\"\r\n)\r\n\r\nfunc ExampleSchool() {\r\n\tSeed(11)\r\n\tfmt.Println(School())\r\n\r\n\t// Output: Hillside Private Academy\r\n}\r\n\r\nfunc ExampleFaker_School() {\r\n\tf := New(11)\r\n\tfmt.Println(f.School())\r\n\r\n\t// Output: Hillside Private Academy\r\n}\r\n\r\nfunc BenchmarkSchool(b *testing.B) {\r\n\tfor i := 0; i < b.N; i++ {\r\n\t\tSchool()\r\n\t}\r\n}\r\n"
        },
        {
          "name": "slice.go",
          "type": "blob",
          "size": 0.3798828125,
          "content": "package gofakeit\n\nimport (\n\t\"reflect\"\n)\n\n// Slice fills built-in types and exported fields of a struct with random data.\nfunc Slice(v any) { sliceFunc(GlobalFaker, v) }\n\n// Slice fills built-in types and exported fields of a struct with random data.\nfunc (f *Faker) Slice(v any) { sliceFunc(f, v) }\n\nfunc sliceFunc(f *Faker, v any) {\n\tr(f, reflect.TypeOf(v), reflect.ValueOf(v), \"\", -1)\n}\n"
        },
        {
          "name": "slice_test.go",
          "type": "blob",
          "size": 1.55078125,
          "content": "package gofakeit\n\nimport (\n\t\"fmt\"\n)\n\nfunc ExampleSlice() {\n\tSeed(11)\n\n\tvar S []string\n\tSlice(&S)\n\n\tI := make([]int8, 3)\n\tSlice(&I)\n\n\tfmt.Println(S)\n\tfmt.Println(I)\n\n\t// Output: [KKbMlbxqu mwwv WVlPmw AeAwVH Khrx DcxFeWk vChMCeKf BwRtnboOE mWluN]\n\t// [102 -7 -125]\n}\n\nfunc ExampleFaker_Slice() {\n\tf := New(11)\n\n\tvar S []string\n\tf.Slice(&S)\n\n\tI := make([]int8, 3)\n\tf.Slice(&I)\n\n\tfmt.Println(S)\n\tfmt.Println(I)\n\n\t// Output: [KKbMlbxqu mwwv WVlPmw AeAwVH Khrx DcxFeWk vChMCeKf BwRtnboOE mWluN]\n\t// [102 -7 -125]\n}\n\nfunc ExampleSlice_struct() {\n\tSeed(11)\n\n\ttype Basic struct {\n\t\tS string `fake:\"{firstname}\"`\n\t\tI int\n\t\tF float32\n\t}\n\n\tvar B []Basic\n\tSlice(&B)\n\n\tfmt.Println(B)\n\n\t// Output: [{Russ 3680786209731553973 0.27238095} {Julius 4268594234476337060 0.0051180124} {Kaitlyn 8337306475187377941 0.118576884} {Steve 1365845625386394310 0.27625358} {Tomasa 7952567920265354269 0.648698} {Ernest 7933890822314871011 0.37052673} {Missouri 5542429450337529393 0.36615264} {Tiana 6292602578870227868 0.9382272} {Koby 229639691709918065 0.5914113}]\n}\n\nfunc ExampleFaker_Slice_struct() {\n\tf := New(11)\n\n\ttype Basic struct {\n\t\tS string `fake:\"{firstname}\"`\n\t\tI int\n\t\tF float32\n\t}\n\n\tvar B []Basic\n\tf.Slice(&B)\n\n\tfmt.Println(B)\n\n\t// Output: [{Russ 3680786209731553973 0.27238095} {Julius 4268594234476337060 0.0051180124} {Kaitlyn 8337306475187377941 0.118576884} {Steve 1365845625386394310 0.27625358} {Tomasa 7952567920265354269 0.648698} {Ernest 7933890822314871011 0.37052673} {Missouri 5542429450337529393 0.36615264} {Tiana 6292602578870227868 0.9382272} {Koby 229639691709918065 0.5914113}]\n}\n"
        },
        {
          "name": "source",
          "type": "tree",
          "content": null
        },
        {
          "name": "sql.go",
          "type": "blob",
          "size": 4.09765625,
          "content": "package gofakeit\n\nimport (\n\t\"encoding/json\"\n\t\"errors\"\n\t\"fmt\"\n\t\"strings\"\n)\n\ntype SQLOptions struct {\n\tTable  string  `json:\"table\" xml:\"table\"`   // Table name we are inserting into\n\tCount  int     `json:\"count\" xml:\"count\"`   // How many entries (tuples) we're generating\n\tFields []Field `json:\"fields\" xml:\"fields\"` // The fields to be generated\n}\n\nfunc SQL(so *SQLOptions) (string, error) { return sqlFunc(GlobalFaker, so) }\n\nfunc (f *Faker) SQL(so *SQLOptions) (string, error) { return sqlFunc(f, so) }\n\nfunc sqlFunc(f *Faker, so *SQLOptions) (string, error) {\n\tif so.Table == \"\" {\n\t\treturn \"\", errors.New(\"must provide table name to generate SQL\")\n\t}\n\tif so.Fields == nil || len(so.Fields) <= 0 {\n\t\treturn \"\", errors.New((\"must pass fields in order to generate SQL queries\"))\n\t}\n\tif so.Count <= 0 {\n\t\treturn \"\", errors.New(\"must have entry count\")\n\t}\n\n\tvar sb strings.Builder\n\tsb.WriteString(\"INSERT INTO \" + so.Table + \" \")\n\n\t// Loop through each field and put together column names\n\tvar cols []string\n\tfor _, f := range so.Fields {\n\t\tcols = append(cols, f.Name)\n\t}\n\tsb.WriteString(\"(\" + strings.Join(cols, \", \") + \")\")\n\n\tsb.WriteString(\" VALUES \")\n\tfor i := 0; i < so.Count; i++ {\n\t\t// Start opening value\n\t\tsb.WriteString(\"(\")\n\n\t\t// Now, we need to add all of our fields\n\t\tvar endStr string\n\t\tfor ii, field := range so.Fields {\n\t\t\t// Set end of value string\n\t\t\tendStr = \", \"\n\t\t\tif ii == len(so.Fields)-1 {\n\t\t\t\tendStr = \"\"\n\t\t\t}\n\n\t\t\t// If autoincrement, add based upon loop\n\t\t\tif field.Function == \"autoincrement\" {\n\t\t\t\tsb.WriteString(fmt.Sprintf(\"%d%s\", i+1, endStr))\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\t// Get the function info for the field\n\t\t\tfuncInfo := GetFuncLookup(field.Function)\n\t\t\tif funcInfo == nil {\n\t\t\t\treturn \"\", errors.New(\"invalid function, \" + field.Function + \" does not exist\")\n\t\t\t}\n\n\t\t\t// Generate the value\n\t\t\tval, err := funcInfo.Generate(f, &field.Params, funcInfo)\n\t\t\tif err != nil {\n\t\t\t\treturn \"\", err\n\t\t\t}\n\n\t\t\t// Convert the output value to the proper SQL type\n\t\t\tconvertType := sqlConvertType(funcInfo.Output, val)\n\n\t\t\t// If its the last field, we need to close the value\n\t\t\tsb.WriteString(convertType + endStr)\n\t\t}\n\n\t\t// If its the last value, we need to close the value\n\t\tif i == so.Count-1 {\n\t\t\tsb.WriteString(\");\")\n\t\t} else {\n\t\t\tsb.WriteString(\"),\")\n\t\t}\n\t}\n\n\treturn sb.String(), nil\n}\n\n// sqlConvertType will take in a type and value and convert it to the proper SQL type\nfunc sqlConvertType(t string, val any) string {\n\tswitch t {\n\tcase \"string\":\n\t\treturn `'` + fmt.Sprintf(\"%v\", val) + `'`\n\tcase \"[]byte\":\n\t\treturn `'` + fmt.Sprintf(\"%s\", val) + `'`\n\tdefault:\n\t\treturn fmt.Sprintf(\"%v\", val)\n\t}\n}\n\nfunc addDatabaseSQLLookup() {\n\tAddFuncLookup(\"sql\", Info{\n\t\tDisplay:     \"SQL\",\n\t\tCategory:    \"database\",\n\t\tDescription: \"Command in SQL used to add new data records into a database table\",\n\t\tExample: `INSERT INTO people \n\t(id, first_name, price, age, created_at) \nVALUES \n\t(1, 'Markus', 804.92, 21, '1937-01-30 07:58:01'),\n\t(2, 'Santino', 235.13, 40, '1964-07-07 22:25:40');`,\n\t\tOutput:      \"string\",\n\t\tContentType: \"application/sql\",\n\t\tParams: []Param{\n\t\t\t{Field: \"table\", Display: \"Table\", Type: \"string\", Description: \"Name of the table to insert into\"},\n\t\t\t{Field: \"count\", Display: \"Count\", Type: \"int\", Default: \"100\", Description: \"Number of inserts to generate\"},\n\t\t\t{Field: \"fields\", Display: \"Fields\", Type: \"[]Field\", Description: \"Fields containing key name and function to run in json format\"},\n\t\t},\n\t\tGenerate: func(f *Faker, m *MapParams, info *Info) (any, error) {\n\t\t\tso := SQLOptions{}\n\n\t\t\ttable, err := info.GetString(m, \"table\")\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\tso.Table = table\n\n\t\t\tcount, err := info.GetInt(m, \"count\")\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\tso.Count = count\n\n\t\t\tfieldsStr, err := info.GetStringArray(m, \"fields\")\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\n\t\t\t// Check to make sure fields has length\n\t\t\tif len(fieldsStr) > 0 {\n\t\t\t\tso.Fields = make([]Field, len(fieldsStr))\n\n\t\t\t\tfor i, f := range fieldsStr {\n\t\t\t\t\t// Unmarshal fields string into fields array\n\t\t\t\t\terr = json.Unmarshal([]byte(f), &so.Fields[i])\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\treturn nil, err\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn sqlFunc(f, &so)\n\t\t},\n\t})\n}\n"
        },
        {
          "name": "sql_test.go",
          "type": "blob",
          "size": 4.439453125,
          "content": "package gofakeit\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\t\"testing\"\n)\n\nfunc ExampleSQL() {\n\tSeed(11)\n\n\tres, _ := SQL(&SQLOptions{\n\t\tTable: \"people\",\n\t\tCount: 2,\n\t\tFields: []Field{\n\t\t\t{Name: \"id\", Function: \"autoincrement\"},\n\t\t\t{Name: \"first_name\", Function: \"firstname\"},\n\t\t\t{Name: \"price\", Function: \"price\"},\n\t\t\t{Name: \"age\", Function: \"number\", Params: MapParams{\"min\": {\"1\"}, \"max\": {\"99\"}}},\n\t\t\t{Name: \"created_at\", Function: \"date\", Params: MapParams{\"format\": {\"2006-01-02 15:04:05\"}}},\n\t\t},\n\t})\n\n\tfmt.Println(string(res))\n\n\t// Output: INSERT INTO people (id, first_name, price, age, created_at) VALUES (1, 'Sonny', 985.96, 20, '1925-07-08 17:32:57'),(2, 'Steve', 639.32, 74, '2016-12-29 07:25:24');\n}\n\nfunc ExampleFaker_SQL() {\n\tf := New(11)\n\n\tres, _ := f.SQL(&SQLOptions{\n\t\tTable: \"people\",\n\t\tCount: 2,\n\t\tFields: []Field{\n\t\t\t{Name: \"id\", Function: \"autoincrement\"},\n\t\t\t{Name: \"first_name\", Function: \"firstname\"},\n\t\t\t{Name: \"price\", Function: \"price\"},\n\t\t\t{Name: \"age\", Function: \"number\", Params: MapParams{\"min\": {\"1\"}, \"max\": {\"99\"}}},\n\t\t\t{Name: \"created_at\", Function: \"date\", Params: MapParams{\"format\": {\"2006-01-02 15:04:05\"}}},\n\t\t},\n\t})\n\n\tfmt.Println(string(res))\n\n\t// Output: INSERT INTO people (id, first_name, price, age, created_at) VALUES (1, 'Sonny', 985.96, 20, '1925-07-08 17:32:57'),(2, 'Steve', 639.32, 74, '2016-12-29 07:25:24');\n}\n\nfunc TestSQLJSON(t *testing.T) {\n\tSeed(11)\n\n\tAddFuncLookup(\"jsonperson\", Info{\n\t\tCategory:    \"custom\",\n\t\tDescription: \"random JSON of a person\",\n\t\tExample:     `{\"first_name\":\"Bob\", \"last_name\":\"Jones\"}`,\n\t\tOutput:      \"[]byte\",\n\t\tGenerate: func(f *Faker, m *MapParams, info *Info) (any, error) {\n\n\t\t\tv, _ := JSON(&JSONOptions{\n\t\t\t\tType: \"object\",\n\t\t\t\tFields: []Field{\n\t\t\t\t\t{Name: \"first_name\", Function: \"firstname\"},\n\t\t\t\t\t{Name: \"last_name\", Function: \"lastname\"},\n\t\t\t\t},\n\t\t\t})\n\n\t\t\treturn v, nil\n\t\t},\n\t})\n\tdefer RemoveFuncLookup(\"jsonperson\")\n\n\tres, err := SQL(&SQLOptions{\n\t\tTable: \"people\",\n\t\tCount: 2,\n\t\tFields: []Field{\n\t\t\t{Name: \"data\", Function: \"jsonperson\"},\n\t\t},\n\t})\n\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tif res != `INSERT INTO people (data) VALUES ('{\"first_name\":\"Sonny\",\"last_name\":\"Stiedemann\"}'),('{\"first_name\":\"Cody\",\"last_name\":\"Donnelly\"}');` {\n\t\tt.Errorf(\"SQL query did not match expected output: %s\", res)\n\t}\n}\n\nfunc TestSQLAll(t *testing.T) {\n\tSeed(11)\n\n\tres, err := SQL(&SQLOptions{\n\t\tTable: \"people\",\n\t\tCount: 3,\n\t\tFields: []Field{\n\t\t\t{Name: \"id\", Function: \"autoincrement\"},\n\t\t\t{Name: \"first_name\", Function: \"firstname\"},\n\t\t\t{Name: \"balance\", Function: \"float32\"},\n\t\t},\n\t})\n\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t// Split by VALUES\n\tvalues := strings.Split(res, \"VALUES\")\n\n\t// Check to make sure there are 3 ( and ) symbols\n\tif strings.Count(values[1], \"(\") != 3 || strings.Count(values[1], \")\") != 3 {\n\t\tt.Error(\"SQL query does not have 3 values\")\n\t}\n}\n\nfunc TestSingleSQL(t *testing.T) {\n\tSeed(11)\n\n\tres, err := SQL(&SQLOptions{\n\t\tTable: \"People\",\n\t\tCount: 1,\n\t\tFields: []Field{\n\t\t\t{Name: \"first_name\", Function: \"firstname\"},\n\t\t\t{Name: \"last_name\", Function: \"lastname\"},\n\t\t},\n\t})\n\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t// Split by VALUES\n\tvalues := strings.Split(res, \"VALUES\")\n\n\t// Check to make sure there are 3 ( and ) symbols\n\tif strings.Count(values[1], \"(\") != 1 || strings.Count(values[1], \")\") != 1 {\n\t\tt.Error(\"SQL query should have 1 value\")\n\t}\n}\n\nfunc TestSQLNoCount(t *testing.T) {\n\tSeed(11)\n\n\t_, err := SQL(&SQLOptions{\n\t\tTable: \"People\",\n\t\tFields: []Field{\n\t\t\t{Name: \"first_name\", Function: \"firstname\"},\n\t\t\t{Name: \"last_name\", Function: \"lastname\"},\n\t\t},\n\t})\n\n\tif err == nil {\n\t\tt.Fatal(\"should have failed for no count\")\n\t}\n}\n\nfunc TestSQLNoFields(t *testing.T) {\n\tSeed(11)\n\n\t_, err := SQL(&SQLOptions{\n\t\tTable:  \"People\",\n\t\tCount:  1,\n\t\tFields: []Field{},\n\t})\n\n\tif err == nil {\n\t\tt.Fatal(\"should have failed for no fields\")\n\t}\n}\n\nfunc TestSQLNilFields(t *testing.T) {\n\tSeed(11)\n\n\t_, err := SQL(&SQLOptions{\n\t\tTable: \"People\",\n\t\tCount: 1,\n\t})\n\n\tif err == nil {\n\t\tt.Fatal(\"should have failed for nil fields\")\n\t}\n}\n\nfunc TestSQLInvalidFunction(t *testing.T) {\n\tSeed(11)\n\n\t_, err := SQL(&SQLOptions{\n\t\tTable: \"People\",\n\t\tFields: []Field{\n\t\t\t{Name: \"thing\", Function: \"stuff\"},\n\t\t},\n\t\tCount: 1,\n\t})\n\n\tif err == nil {\n\t\tt.Fatal(\"should have failed for invalid function\")\n\t}\n}\n\nfunc TestSQLNilTable(t *testing.T) {\n\tSeed(11)\n\n\t_, err := SQL(&SQLOptions{\n\t\tCount: 3,\n\t\tFields: []Field{\n\t\t\t{Name: \"first_name\", Function: \"firstname\"},\n\t\t\t{Name: \"last_name\", Function: \"lastname\"},\n\t\t},\n\t})\n\n\tif err == nil {\n\t\tt.Fatal(\"should have failed for no table\")\n\t}\n}\n"
        },
        {
          "name": "string.go",
          "type": "blob",
          "size": 7.9365234375,
          "content": "package gofakeit\n\n// Letter will generate a single random lower case ASCII letter\nfunc Letter() string { return letter(GlobalFaker) }\n\n// Letter will generate a single random lower case ASCII letter\nfunc (f *Faker) Letter() string { return letter(f) }\n\nfunc letter(f *Faker) string { return string(randLetter(f)) }\n\n// LetterN will generate a random ASCII string with length N. Note that this function returns a string with a length of 1 when 0 is passed.\nfunc LetterN(n uint) string { return letterN(GlobalFaker, n) }\n\n// LetterN will generate a random ASCII string with length N. Note that this function returns a string with a length of 1 when 0 is passed.\nfunc (f *Faker) LetterN(n uint) string { return letterN(f, n) }\n\nfunc letterN(f *Faker, n uint) string {\n\t// Make sure we dont use 0\n\tif n == 0 {\n\t\tn = 1\n\t}\n\tout := make([]rune, n)\n\tfor i := 0; i < int(n); i++ {\n\t\tout[i] = randLetter(f)\n\t}\n\treturn string(out)\n}\n\n// Vowel will generate a single random lower case vowel\nfunc Vowel() string { return vowel(GlobalFaker) }\n\n// Vowel will generate a single random lower case vowel\nfunc (f *Faker) Vowel() string { return vowel(f) }\n\nfunc vowel(f *Faker) string { return string(randCharacter(f, vowels)) }\n\n// Digit will generate a single ASCII digit\nfunc Digit() string { return digit(GlobalFaker) }\n\n// Digit will generate a single ASCII digit\nfunc (f *Faker) Digit() string { return digit(f) }\n\nfunc digit(f *Faker) string { return string(randDigit(f)) }\n\n// DigitN will generate a random string of length N consists of ASCII digits. Note that the string generated can start with 0 and this function returns a string with a length of 1 when 0 is passed.\nfunc DigitN(n uint) string { return digitN(GlobalFaker, n) }\n\n// DigitN will generate a random string of length N consists of ASCII digits. Note that the string generated can start with 0 and this function returns a string with a length of 1 when 0 is passed.\nfunc (f *Faker) DigitN(n uint) string { return digitN(f, n) }\n\nfunc digitN(f *Faker, n uint) string {\n\t// Make sure we dont use 0\n\tif n == 0 {\n\t\tn = 1\n\t}\n\tout := make([]rune, n)\n\tfor i := 0; i < int(n); i++ {\n\t\tout[i] = randDigit(f)\n\t}\n\treturn string(out)\n}\n\n// Numerify will replace # with random numerical values\nfunc Numerify(str string) string { return numerify(GlobalFaker, str) }\n\n// Numerify will replace # with random numerical values\nfunc (f *Faker) Numerify(str string) string { return numerify(f, str) }\n\nfunc numerify(f *Faker, str string) string { return replaceWithNumbers(f, str) }\n\n// Lexify will replace ? with random generated letters\nfunc Lexify(str string) string { return lexify(GlobalFaker, str) }\n\n// Lexify will replace ? with random generated letters\nfunc (f *Faker) Lexify(str string) string { return lexify(f, str) }\n\nfunc lexify(f *Faker, str string) string { return replaceWithLetters(f, str) }\n\n// ShuffleStrings will randomize a slice of strings\nfunc ShuffleStrings(a []string) { shuffleStrings(GlobalFaker, a) }\n\n// ShuffleStrings will randomize a slice of strings\nfunc (f *Faker) ShuffleStrings(a []string) { shuffleStrings(f, a) }\n\nfunc shuffleStrings(f *Faker, a []string) {\n\tswap := func(i, j int) {\n\t\ta[i], a[j] = a[j], a[i]\n\t}\n\t//to avoid upgrading to 1.10 I copied the algorithm\n\tn := len(a)\n\tif n <= 1 {\n\t\treturn\n\t}\n\n\t//if size is > int32 probably it will never finish, or ran out of entropy\n\ti := n - 1\n\tfor ; i > 0; i-- {\n\t\tj := int(int32NFunc(f, int32(i+1)))\n\t\tswap(i, j)\n\t}\n}\n\n// RandomString will take in a slice of string and return a randomly selected value\nfunc RandomString(a []string) string { return randomString(GlobalFaker, a) }\n\n// RandomString will take in a slice of string and return a randomly selected value\nfunc (f *Faker) RandomString(a []string) string { return randomString(f, a) }\n\nfunc randomString(f *Faker, a []string) string {\n\tsize := len(a)\n\tif size == 0 {\n\t\treturn \"\"\n\t}\n\tif size == 1 {\n\t\treturn a[0]\n\t}\n\treturn a[f.IntN(size)]\n}\n\nfunc addStringLookup() {\n\tAddFuncLookup(\"letter\", Info{\n\t\tDisplay:     \"Letter\",\n\t\tCategory:    \"string\",\n\t\tDescription: \"Character or symbol from the American Standard Code for Information Interchange (ASCII) character set\",\n\t\tExample:     \"g\",\n\t\tOutput:      \"string\",\n\t\tGenerate: func(f *Faker, m *MapParams, info *Info) (any, error) {\n\t\t\treturn letter(f), nil\n\t\t},\n\t})\n\n\tAddFuncLookup(\"lettern\", Info{\n\t\tDisplay:     \"LetterN\",\n\t\tCategory:    \"string\",\n\t\tDescription: \"ASCII string with length N\",\n\t\tExample:     \"gbRMaRxHki\",\n\t\tOutput:      \"string\",\n\t\tParams: []Param{\n\t\t\t{Field: \"count\", Display: \"Count\", Type: \"uint\", Description: \"Number of digits to generate\"},\n\t\t},\n\t\tGenerate: func(f *Faker, m *MapParams, info *Info) (any, error) {\n\t\t\tui, err := info.GetUint(m, \"count\")\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\n\t\t\treturn letterN(f, ui), nil\n\t\t},\n\t})\n\n\tAddFuncLookup(\"vowel\", Info{\n\t\tDisplay:     \"Vowel\",\n\t\tCategory:    \"string\",\n\t\tDescription: \"Speech sound produced with an open vocal tract\",\n\t\tExample:     \"a\",\n\t\tOutput:      \"string\",\n\t\tGenerate: func(f *Faker, m *MapParams, info *Info) (any, error) {\n\t\t\treturn vowel(f), nil\n\t\t},\n\t})\n\n\tAddFuncLookup(\"digit\", Info{\n\t\tDisplay:     \"Digit\",\n\t\tCategory:    \"string\",\n\t\tDescription: \"Numerical symbol used to represent numbers\",\n\t\tExample:     \"0\",\n\t\tOutput:      \"string\",\n\t\tGenerate: func(f *Faker, m *MapParams, info *Info) (any, error) {\n\t\t\treturn digit(f), nil\n\t\t},\n\t})\n\n\tAddFuncLookup(\"digitn\", Info{\n\t\tDisplay:     \"DigitN\",\n\t\tCategory:    \"string\",\n\t\tDescription: \"string of length N consisting of ASCII digits\",\n\t\tExample:     \"0136459948\",\n\t\tOutput:      \"string\",\n\t\tParams: []Param{\n\t\t\t{Field: \"count\", Display: \"Count\", Type: \"uint\", Description: \"Number of digits to generate\"},\n\t\t},\n\t\tGenerate: func(f *Faker, m *MapParams, info *Info) (any, error) {\n\t\t\tui, err := info.GetUint(m, \"count\")\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\n\t\t\treturn digitN(f, ui), nil\n\t\t},\n\t})\n\n\tAddFuncLookup(\"numerify\", Info{\n\t\tDisplay:     \"Numerify\",\n\t\tCategory:    \"string\",\n\t\tDescription: \"Replace # with random numerical values\",\n\t\tExample:     \"(###)###-#### => (555)867-5309\",\n\t\tOutput:      \"string\",\n\t\tParams: []Param{\n\t\t\t{Field: \"str\", Display: \"String\", Type: \"string\", Description: \"String value to replace #'s\"},\n\t\t},\n\t\tGenerate: func(f *Faker, m *MapParams, info *Info) (any, error) {\n\t\t\tstr, err := info.GetString(m, \"str\")\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\n\t\t\treturn numerify(f, str), nil\n\t\t},\n\t})\n\n\tAddFuncLookup(\"lexify\", Info{\n\t\tDisplay:     \"Lexify\",\n\t\tCategory:    \"string\",\n\t\tDescription: \"Replace ? with random generated letters\",\n\t\tExample:     \"?????@??????.com => billy@mister.com\",\n\t\tOutput:      \"string\",\n\t\tParams: []Param{\n\t\t\t{Field: \"str\", Display: \"String\", Type: \"string\", Description: \"String value to replace ?'s\"},\n\t\t},\n\t\tGenerate: func(f *Faker, m *MapParams, info *Info) (any, error) {\n\t\t\tstr, err := info.GetString(m, \"str\")\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\n\t\t\treturn lexify(f, str), nil\n\t\t},\n\t})\n\n\tAddFuncLookup(\"shufflestrings\", Info{\n\t\tDisplay:     \"Shuffle Strings\",\n\t\tCategory:    \"string\",\n\t\tDescription: \"Shuffle an array of strings\",\n\t\tExample:     \"hello,world,whats,up => whats,world,hello,up\",\n\t\tOutput:      \"[]string\",\n\t\tContentType: \"application/json\",\n\t\tParams: []Param{\n\t\t\t{Field: \"strs\", Display: \"Strings\", Type: \"[]string\", Description: \"Delimited separated strings\"},\n\t\t},\n\t\tGenerate: func(f *Faker, m *MapParams, info *Info) (any, error) {\n\t\t\tstrs, err := info.GetStringArray(m, \"strs\")\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\n\t\t\tshuffleStrings(f, strs)\n\n\t\t\treturn strs, nil\n\t\t},\n\t})\n\n\tAddFuncLookup(\"randomstring\", Info{\n\t\tDisplay:     \"Random String\",\n\t\tCategory:    \"string\",\n\t\tDescription: \"Return a random string from a string array\",\n\t\tExample:     \"hello,world,whats,up => world\",\n\t\tOutput:      \"[]string\",\n\t\tParams: []Param{\n\t\t\t{Field: \"strs\", Display: \"Strings\", Type: \"[]string\", Description: \"Delimited separated strings\"},\n\t\t},\n\t\tGenerate: func(f *Faker, m *MapParams, info *Info) (any, error) {\n\t\t\tstrs, err := info.GetStringArray(m, \"strs\")\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\n\t\t\treturn randomString(f, strs), nil\n\t\t},\n\t})\n}\n"
        },
        {
          "name": "string_test.go",
          "type": "blob",
          "size": 4.5283203125,
          "content": "package gofakeit\n\nimport (\n\t\"fmt\"\n\t\"regexp\"\n\t\"testing\"\n\t\"unicode\"\n)\n\nfunc ExampleLetter() {\n\tSeed(11)\n\tfmt.Println(Letter())\n\n\t// Output: u\n}\n\nfunc ExampleFaker_Letter() {\n\tf := New(11)\n\tfmt.Println(f.Letter())\n\n\t// Output: u\n}\n\nfunc BenchmarkLetter(b *testing.B) {\n\tSeed(11)\n\tfor i := 0; i < b.N; i++ {\n\t\tLetter()\n\t}\n}\n\nfunc TestLetterN(t *testing.T) {\n\tif len(LetterN(0)) != 1 {\n\t\tt.Errorf(\"expected length %d but did not get that number\", 1)\n\t}\n\n\tvar dataSize uint = 10\n\tdata := LetterN(dataSize)\n\tif len(data) != int(dataSize) {\n\t\tt.Errorf(\"expected length %d but got %d\", dataSize, len(data))\n\t}\n\tfor i := 0; i < len(data); i++ {\n\t\tif data[i] > unicode.MaxASCII {\n\t\t\tt.Errorf(\"non ascii char %s found at index %d\", string(data[i]), i)\n\t\t}\n\t}\n}\n\nfunc ExampleLetterN() {\n\tSeed(11)\n\tfmt.Println(LetterN(10))\n\n\t// Output: usKKbMlbxq\n}\n\nfunc ExampleFaker_LetterN() {\n\tf := New(11)\n\tfmt.Println(f.LetterN(10))\n\n\t// Output: usKKbMlbxq\n}\n\nfunc BenchmarkLetterN(b *testing.B) {\n\tSeed(11)\n\tfor i := 0; i < b.N; i++ {\n\t\tLetterN(10)\n\t}\n}\n\nfunc ExampleVowel() {\n\tSeed(11)\n\tfmt.Println(Vowel())\n\n\t// Output: a\n}\n\nfunc ExampleFaker_Vowel() {\n\tf := New(11)\n\tfmt.Println(f.Vowel())\n\n\t// Output: a\n}\n\nfunc BenchmarkVowel(b *testing.B) {\n\tSeed(11)\n\tfor i := 0; i < b.N; i++ {\n\t\tVowel()\n\t}\n}\n\nfunc ExampleDigit() {\n\tSeed(11)\n\tfmt.Println(Digit())\n\n\t// Output: 8\n}\n\nfunc ExampleFaker_Digit() {\n\tf := New(11)\n\tfmt.Println(f.Digit())\n\n\t// Output: 8\n}\n\nfunc BenchmarkDigit(b *testing.B) {\n\tSeed(11)\n\tfor i := 0; i < b.N; i++ {\n\t\tDigit()\n\t}\n}\n\nfunc TestDigitN(t *testing.T) {\n\tif len(DigitN(0)) != 1 {\n\t\tt.Errorf(\"expected length %d but did not get that number\", 1)\n\t}\n\n\tvar dataSize uint = 10\n\tdata := DigitN(dataSize)\n\tif len(data) != int(dataSize) {\n\t\tt.Errorf(\"expected length %d but got %d\", dataSize, len(data))\n\t}\n\tfor i := 0; i < len(data); i++ {\n\t\tval := int(data[i] - '0')\n\t\tif val < 0 || 9 < val {\n\t\t\tt.Errorf(\"non digit %s found at index %d\", string(data[i]), i)\n\t\t}\n\t}\n}\n\nfunc ExampleDigitN() {\n\tSeed(11)\n\tfmt.Println(DigitN(10))\n\n\t// Output: 8812527598\n}\n\nfunc ExampleFaker_DigitN() {\n\tf := New(11)\n\tfmt.Println(f.DigitN(10))\n\n\t// Output: 8812527598\n}\n\nfunc BenchmarkDigitN(b *testing.B) {\n\tSeed(11)\n\tfor i := 0; i < b.N; i++ {\n\t\tDigitN(10)\n\t}\n}\n\nfunc ExampleNumerify() {\n\tSeed(11)\n\tfmt.Println(Numerify(\"###-###-####\"))\n\n\t// Output: 881-252-7598\n}\n\nfunc ExampleFaker_Numerify() {\n\tf := New(11)\n\tfmt.Println(f.Numerify(\"###-###-####\"))\n\n\t// Output: 881-252-7598\n}\n\nfunc BenchmarkNumerify(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tNumerify(\"###-###-####\")\n\t}\n}\n\nfunc ExampleLexify() {\n\tSeed(11)\n\tfmt.Println(Lexify(\"?????\"))\n\n\t// Output: usKKb\n}\n\nfunc ExampleFaker_Lexify() {\n\tf := New(11)\n\tfmt.Println(f.Lexify(\"?????\"))\n\n\t// Output: usKKb\n}\n\nfunc BenchmarkLexify(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tLexify(\"??????\")\n\t}\n}\n\nfunc ExampleShuffleStrings() {\n\tSeed(11)\n\tstrings := []string{\"happy\", \"times\", \"for\", \"everyone\", \"have\", \"a\", \"good\", \"day\"}\n\tShuffleStrings(strings)\n\tfmt.Println(strings)\n\n\t// Output: [for day happy everyone good times a have]\n}\n\nfunc ExampleFaker_ShuffleStrings() {\n\tf := New(11)\n\tstrings := []string{\"happy\", \"times\", \"for\", \"everyone\", \"have\", \"a\", \"good\", \"day\"}\n\tf.ShuffleStrings(strings)\n\tfmt.Println(strings)\n\n\t// Output: [for day happy everyone good times a have]\n}\n\nfunc TestShuffleStrings(t *testing.T) {\n\tShuffleStrings([]string{\"a\"})\n\tShuffleStrings(nil)\n\n\ta := []string{\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\"}\n\tb := make([]string, len(a))\n\tcopy(b, a)\n\tShuffleStrings(a)\n\tif equalSliceString(a, b) {\n\t\tt.Errorf(\"shuffle resulted in the same permutation, the odds are slim\")\n\t}\n}\n\nfunc BenchmarkShuffleStrings(b *testing.B) {\n\tSeed(11)\n\tfor i := 0; i < b.N; i++ {\n\t\tShuffleStrings([]string{\"happy\", \"times\", \"for\", \"everyone\", \"have\", \"a\", \"good\", \"day\"})\n\t}\n}\n\nfunc ExampleRandomString() {\n\tSeed(11)\n\tfmt.Println(RandomString([]string{\"hello\", \"world\"}))\n\n\t// Output: hello\n}\n\nfunc ExampleFaker_RandomString() {\n\tf := New(11)\n\tfmt.Println(f.RandomString([]string{\"hello\", \"world\"}))\n\n\t// Output: hello\n}\n\nfunc TestRandomString(t *testing.T) {\n\tfor _, test := range []struct {\n\t\tin          []string\n\t\tshouldRegex string\n\t}{\n\t\t{[]string{}, \"\"},\n\t\t{nil, \"\"},\n\t\t{[]string{\"a\"}, \"a\"},\n\t\t{[]string{\"a\", \"b\", \"c\", \"d\", \"e\", \"f\"}, \"[abcdef]\"},\n\t} {\n\t\tSeed(11)\n\n\t\tres := RandomString(test.in)\n\t\tmatched, err := regexp.MatchString(test.shouldRegex, res)\n\t\tif err != nil {\n\t\t\tt.Error(err)\n\t\t}\n\n\t\tif !matched {\n\t\t\tt.Errorf(\"expected %s to match %s\", res, test.shouldRegex)\n\t\t}\n\t}\n}\n\nfunc BenchmarkRandomString(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tRandomString([]string{\"hello\", \"world\"})\n\t}\n}\n"
        },
        {
          "name": "struct.go",
          "type": "blob",
          "size": 13.890625,
          "content": "package gofakeit\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"reflect\"\n\t\"strconv\"\n\t\"strings\"\n\t\"time\"\n)\n\n// Struct fills in exported fields of a struct with random data\n// based on the value of `fake` tag of exported fields\n// or with the result of a call to the Fake() method\n// if the field type implements `Fakeable`.\n// Use `fake:\"skip\"` to explicitly skip an element.\n// All built-in types are supported, with templating support\n// for string types.\nfunc Struct(v any) error { return structFunc(GlobalFaker, v) }\n\n// Struct fills in exported fields of a struct with random data\n// based on the value of `fake` tag of exported fields.\n// Use `fake:\"skip\"` to explicitly skip an element.\n// All built-in types are supported, with templating support\n// for string types.\nfunc (f *Faker) Struct(v any) error { return structFunc(f, v) }\n\nfunc structFunc(f *Faker, v any) error {\n\treturn r(f, reflect.TypeOf(v), reflect.ValueOf(v), \"\", 0)\n}\n\nfunc r(f *Faker, t reflect.Type, v reflect.Value, tag string, size int) error {\n\t// Handle special types\n\n\tif t.PkgPath() == \"encoding/json\" {\n\t\t// encoding/json has two special types:\n\t\t// - RawMessage\n\t\t// - Number\n\n\t\tswitch t.Name() {\n\t\tcase \"RawMessage\":\n\t\t\treturn rJsonRawMessage(f, v, tag)\n\t\tcase \"Number\":\n\t\t\treturn rJsonNumber(f, v, tag)\n\t\tdefault:\n\t\t\treturn errors.New(\"unknown encoding/json type: \" + t.Name())\n\t\t}\n\t}\n\n\t// Handle generic types\n\tswitch t.Kind() {\n\tcase reflect.Ptr:\n\t\treturn rPointer(f, t, v, tag, size)\n\tcase reflect.Struct:\n\t\treturn rStruct(f, t, v, tag)\n\tcase reflect.String:\n\t\treturn rString(f, t, v, tag)\n\tcase reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64:\n\t\treturn rUint(f, t, v, tag)\n\tcase reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:\n\t\treturn rInt(f, t, v, tag)\n\tcase reflect.Float32, reflect.Float64:\n\t\treturn rFloat(f, t, v, tag)\n\tcase reflect.Bool:\n\t\treturn rBool(f, t, v, tag)\n\tcase reflect.Array, reflect.Slice:\n\t\treturn rSlice(f, t, v, tag, size)\n\tcase reflect.Map:\n\t\treturn rMap(f, t, v, tag, size)\n\t}\n\n\treturn nil\n}\n\nfunc rCustom(f *Faker, v reflect.Value, tag string) error {\n\t// If tag is empty return error\n\tif tag == \"\" {\n\t\treturn errors.New(\"tag is empty\")\n\t}\n\n\tfName, fParams := parseNameAndParamsFromTag(tag)\n\tinfo := GetFuncLookup(fName)\n\n\t// Check to see if it's a replaceable lookup function\n\tif info == nil {\n\t\treturn fmt.Errorf(\"function %q not found\", tag)\n\t}\n\n\t// Parse map params\n\tmapParams, err := parseMapParams(info, fParams)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Call function\n\tfValue, err := info.Generate(f, mapParams, info)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Create new element of expected type\n\tfield := reflect.New(reflect.TypeOf(fValue))\n\tfield.Elem().Set(reflect.ValueOf(fValue))\n\n\t// Check if element is pointer if so\n\t// grab the underlying value\n\tfieldElem := field.Elem()\n\tif fieldElem.Kind() == reflect.Ptr {\n\t\tfieldElem = fieldElem.Elem()\n\t}\n\n\t// Check if field kind is the same as the expected type\n\tif fieldElem.Kind() != v.Kind() {\n\t\t// return error saying the field and kinds that do not match\n\t\treturn errors.New(\"field kind \" + fieldElem.Kind().String() + \" does not match expected kind \" + v.Kind().String())\n\t}\n\n\t// Set the value\n\tv.Set(fieldElem.Convert(v.Type()))\n\n\t// If a function is called to set the struct\n\t// stop from going through sub fields\n\treturn nil\n}\n\nfunc rStruct(f *Faker, t reflect.Type, v reflect.Value, tag string) error {\n\t// Check if tag exists, if so run custom function\n\tif t.Name() != \"\" && tag != \"\" {\n\t\treturn rCustom(f, v, tag)\n\t}\n\n\t// Check if struct is fakeable\n\tif isFakeable(t) {\n\t\tvalue, err := callFake(f, v, reflect.Struct)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tv.Set(reflect.ValueOf(value))\n\t\treturn nil\n\t}\n\n\t// Loop through all the fields of the struct\n\tn := t.NumField()\n\tfor i := 0; i < n; i++ {\n\t\telementT := t.Field(i)\n\t\telementV := v.Field(i)\n\t\tfakeTag, ok := elementT.Tag.Lookup(\"fake\")\n\n\t\t// Check whether or not to skip this field\n\t\tif ok && fakeTag == \"skip\" || fakeTag == \"-\" {\n\t\t\t// Do nothing, skip it\n\t\t\tcontinue\n\t\t}\n\n\t\t// Check to make sure you can set it or that it's an embedded(anonymous) field\n\t\tif !elementV.CanSet() && !elementT.Anonymous {\n\t\t\tcontinue\n\t\t}\n\n\t\t// Check if reflect type is of values we can specifically set\n\t\telemStr := elementT.Type.String()\n\t\tswitch elemStr {\n\t\tcase \"time.Time\", \"*time.Time\":\n\t\t\t// Check if element is a pointer\n\t\t\telemV := elementV\n\t\t\tif elemStr == \"*time.Time\" {\n\t\t\t\telemV = reflect.New(elementT.Type.Elem()).Elem()\n\t\t\t}\n\n\t\t\t// Run rTime on the element\n\t\t\terr := rTime(f, elementT, elemV, fakeTag)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t\tif elemStr == \"*time.Time\" {\n\t\t\t\telementV.Set(elemV.Addr())\n\t\t\t}\n\n\t\t\tcontinue\n\t\t}\n\n\t\t// Check if fakesize is set\n\t\tsize := -1 // Set to -1 to indicate fakesize was not set\n\t\tfs, ok := elementT.Tag.Lookup(\"fakesize\")\n\t\tif ok {\n\t\t\tvar err error\n\n\t\t\t// Check if size has params separated by ,\n\t\t\tif strings.Contains(fs, \",\") {\n\t\t\t\tsizeSplit := strings.SplitN(fs, \",\", 2)\n\t\t\t\tif len(sizeSplit) == 2 {\n\t\t\t\t\tvar sizeMin int\n\t\t\t\t\tvar sizeMax int\n\n\t\t\t\t\tsizeMin, err = strconv.Atoi(sizeSplit[0])\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\treturn err\n\t\t\t\t\t}\n\t\t\t\t\tsizeMax, err = strconv.Atoi(sizeSplit[1])\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\treturn err\n\t\t\t\t\t}\n\n\t\t\t\t\tsize = f.IntN(sizeMax-sizeMin+1) + sizeMin\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tsize, err = strconv.Atoi(fs)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Recursively call r() to fill in the struct\n\t\terr := r(f, elementT.Type, elementV, fakeTag, size)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\treturn nil\n}\n\nfunc rPointer(f *Faker, t reflect.Type, v reflect.Value, tag string, size int) error {\n\telemT := t.Elem()\n\tif v.IsNil() {\n\t\tnv := reflect.New(elemT).Elem()\n\t\terr := r(f, elemT, nv, tag, size)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tv.Set(nv.Addr())\n\t} else {\n\t\terr := r(f, elemT, v.Elem(), tag, size)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\treturn nil\n}\n\nfunc rSlice(f *Faker, t reflect.Type, v reflect.Value, tag string, size int) error {\n\t// If you cant even set it dont even try\n\tif !v.CanSet() {\n\t\treturn errors.New(\"cannot set slice\")\n\t}\n\n\t// Check if tag exists, if so run custom function\n\tif t.Name() != \"\" && tag != \"\" {\n\t\t// Check to see if custom function works if not continue to normal loop of values\n\t\terr := rCustom(f, v, tag)\n\t\tif err == nil {\n\t\t\treturn nil\n\t\t}\n\t} else if isFakeable(t) {\n\t\tvalue, err := callFake(f, v, reflect.Slice, reflect.Array)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tv.Set(reflect.ValueOf(value))\n\t\treturn nil\n\t}\n\n\t// Grab original size to use if needed for sub arrays\n\togSize := size\n\n\t// If the value has a len and is less than the size\n\t// use that instead of the requested size\n\telemLen := v.Len()\n\tif elemLen == 0 && size == -1 {\n\t\tsize = number(f, 1, 10)\n\t} else if elemLen != 0 && (size == -1 || elemLen < size) {\n\t\tsize = elemLen\n\t}\n\n\t// Get the element type\n\telemT := t.Elem()\n\n\t// Loop through the elements length and set based upon the index\n\tfor i := 0; i < size; i++ {\n\t\tnv := reflect.New(elemT)\n\t\terr := r(f, elemT, nv.Elem(), tag, ogSize)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\t// If values are already set fill them up, otherwise append\n\t\tif elemLen != 0 {\n\t\t\tv.Index(i).Set(reflect.Indirect(nv))\n\t\t} else {\n\t\t\tv.Set(reflect.Append(reflect.Indirect(v), reflect.Indirect(nv)))\n\t\t}\n\t}\n\n\treturn nil\n}\n\nfunc rMap(f *Faker, t reflect.Type, v reflect.Value, tag string, size int) error {\n\t// If you cant even set it dont even try\n\tif !v.CanSet() {\n\t\treturn errors.New(\"cannot set slice\")\n\t}\n\n\t// Check if tag exists, if so run custom function\n\tif tag != \"\" {\n\t\treturn rCustom(f, v, tag)\n\t} else if size > 0 {\n\t\t// NOOP\n\t} else if isFakeable(t) {\n\t\tvalue, err := callFake(f, v, reflect.Map)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tv.Set(reflect.ValueOf(value))\n\t\treturn nil\n\t}\n\n\t// Set a size\n\tnewSize := size\n\tif newSize == -1 {\n\t\tnewSize = number(f, 1, 10)\n\t}\n\n\t// Create new map based upon map key value type\n\tmapType := reflect.MapOf(t.Key(), t.Elem())\n\tnewMap := reflect.MakeMap(mapType)\n\n\tfor i := 0; i < newSize; i++ {\n\t\t// Create new key\n\t\tmapIndex := reflect.New(t.Key())\n\t\terr := r(f, t.Key(), mapIndex.Elem(), \"\", -1)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\t// Create new value\n\t\tmapValue := reflect.New(t.Elem())\n\t\terr = r(f, t.Elem(), mapValue.Elem(), \"\", -1)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tnewMap.SetMapIndex(mapIndex.Elem(), mapValue.Elem())\n\t}\n\n\t// Set newMap into struct field\n\tif t.Kind() == reflect.Ptr {\n\t\tv.Set(newMap.Elem())\n\t} else {\n\t\tv.Set(newMap)\n\t}\n\n\treturn nil\n}\n\nfunc rString(f *Faker, t reflect.Type, v reflect.Value, tag string) error {\n\tif tag != \"\" {\n\t\tgenStr, err := generate(f, tag)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tv.SetString(genStr)\n\t} else if isFakeable(t) {\n\t\tvalue, err := callFake(f, v, reflect.String)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tvalueStr, ok := value.(string)\n\t\tif !ok {\n\t\t\treturn errors.New(\"call to Fake method did not return a string\")\n\t\t}\n\t\tv.SetString(valueStr)\n\t} else {\n\t\tgenStr, err := generate(f, strings.Repeat(\"?\", number(f, 4, 10)))\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tv.SetString(genStr)\n\t}\n\n\treturn nil\n}\n\nfunc rInt(f *Faker, t reflect.Type, v reflect.Value, tag string) error {\n\tif tag != \"\" {\n\t\tgenStr, err := generate(f, tag)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\ti, err := strconv.ParseInt(genStr, 10, 64)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tv.SetInt(i)\n\t} else if isFakeable(t) {\n\t\tvalue, err := callFake(f, v, reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tswitch i := value.(type) {\n\t\tcase int:\n\t\t\tv.SetInt(int64(i))\n\t\tcase int8:\n\t\t\tv.SetInt(int64(i))\n\t\tcase int16:\n\t\t\tv.SetInt(int64(i))\n\t\tcase int32:\n\t\t\tv.SetInt(int64(i))\n\t\tcase int64:\n\t\t\tv.SetInt(int64(i))\n\t\tdefault:\n\t\t\treturn errors.New(\"call to Fake method did not return an integer\")\n\t\t}\n\t} else {\n\t\t// If no tag or error converting to int, set with random value\n\t\tswitch t.Kind() {\n\t\tcase reflect.Int:\n\t\t\tv.SetInt(int64Func(f))\n\t\tcase reflect.Int8:\n\t\t\tv.SetInt(int64(int8Func(f)))\n\t\tcase reflect.Int16:\n\t\t\tv.SetInt(int64(int16Func(f)))\n\t\tcase reflect.Int32:\n\t\t\tv.SetInt(int64(int32Func(f)))\n\t\tcase reflect.Int64:\n\t\t\tv.SetInt(int64Func(f))\n\t\t}\n\t}\n\n\treturn nil\n}\n\nfunc rUint(f *Faker, t reflect.Type, v reflect.Value, tag string) error {\n\tif tag != \"\" {\n\t\tgenStr, err := generate(f, tag)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tu, err := strconv.ParseUint(genStr, 10, 64)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tv.SetUint(u)\n\t} else if isFakeable(t) {\n\t\tvalue, err := callFake(f, v, reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tswitch i := value.(type) {\n\t\tcase uint:\n\t\t\tv.SetUint(uint64(i))\n\t\tcase uint8:\n\t\t\tv.SetUint(uint64(i))\n\t\tcase uint16:\n\t\t\tv.SetUint(uint64(i))\n\t\tcase uint32:\n\t\t\tv.SetUint(uint64(i))\n\t\tcase uint64:\n\t\t\tv.SetUint(uint64(i))\n\t\tdefault:\n\t\t\treturn errors.New(\"call to Fake method did not return an unsigned integer\")\n\t\t}\n\t} else {\n\t\t// If no tag or error converting to uint, set with random value\n\t\tswitch t.Kind() {\n\t\tcase reflect.Uint:\n\t\t\tv.SetUint(f.Uint64())\n\t\tcase reflect.Uint8:\n\t\t\tv.SetUint(uint64(uint8Func(f)))\n\t\tcase reflect.Uint16:\n\t\t\tv.SetUint(uint64(uint16Func(f)))\n\t\tcase reflect.Uint32:\n\t\t\tv.SetUint(uint64(uint32Func(f)))\n\t\tcase reflect.Uint64:\n\t\t\tv.SetUint(f.Uint64())\n\t\t}\n\t}\n\n\treturn nil\n}\n\nfunc rFloat(f *Faker, t reflect.Type, v reflect.Value, tag string) error {\n\tif tag != \"\" {\n\t\tgenStr, err := generate(f, tag)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tf, err := strconv.ParseFloat(genStr, 64)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tv.SetFloat(f)\n\t} else if isFakeable(t) {\n\t\tvalue, err := callFake(f, v, reflect.Float32, reflect.Float64)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tswitch i := value.(type) {\n\t\tcase float32:\n\t\t\tv.SetFloat(float64(i))\n\t\tcase float64:\n\t\t\tv.SetFloat(float64(i))\n\t\tdefault:\n\t\t\treturn errors.New(\"call to Fake method did not return a float\")\n\t\t}\n\t} else {\n\t\t// If no tag or error converting to float, set with random value\n\t\tswitch t.Kind() {\n\t\tcase reflect.Float64:\n\t\t\tv.SetFloat(float64Func(f))\n\t\tcase reflect.Float32:\n\t\t\tv.SetFloat(float64(float32Func(f)))\n\t\t}\n\t}\n\n\treturn nil\n}\n\nfunc rBool(f *Faker, t reflect.Type, v reflect.Value, tag string) error {\n\tif tag != \"\" {\n\t\tgenStr, err := generate(f, tag)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tb, err := strconv.ParseBool(genStr)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tv.SetBool(b)\n\t} else if isFakeable(t) {\n\t\tvalue, err := callFake(f, v, reflect.Bool)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tswitch i := value.(type) {\n\t\tcase bool:\n\t\t\tv.SetBool(bool(i))\n\t\tdefault:\n\t\t\treturn errors.New(\"call to Fake method did not return a boolean\")\n\t\t}\n\t} else {\n\t\t// If no tag or error converting to boolean, set with random value\n\t\tv.SetBool(boolFunc(f))\n\t}\n\n\treturn nil\n}\n\n// rTime will set a time.Time field the best it can from either the default date tag or from the generate tag\nfunc rTime(f *Faker, t reflect.StructField, v reflect.Value, tag string) error {\n\tif tag != \"\" {\n\t\t// Generate time\n\t\ttimeOutput, err := generate(f, tag)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\t// Check to see if timeOutput has monotonic clock reading\n\t\t// if so, remove it. This is because time.Parse() does not\n\t\t// support parsing the monotonic clock reading\n\t\tif strings.Contains(timeOutput, \" m=\") {\n\t\t\ttimeOutput = strings.Split(timeOutput, \" m=\")[0]\n\t\t}\n\n\t\t// Check to see if they are passing in a format\tto parse the time\n\t\ttimeFormat, timeFormatOK := t.Tag.Lookup(\"format\")\n\t\tif timeFormatOK {\n\t\t\ttimeFormat = javaDateFormatToGolangDateFormat(timeFormat)\n\t\t} else {\n\t\t\t// If tag == \"{date}\" use time.RFC3339\n\t\t\t// They are attempting to use the default date lookup\n\t\t\tif tag == \"{date}\" {\n\t\t\t\ttimeFormat = time.RFC3339\n\t\t\t} else {\n\t\t\t\t// Default format of time.Now().String()\n\t\t\t\ttimeFormat = \"2006-01-02 15:04:05.999999999 -0700 MST\"\n\t\t\t}\n\t\t}\n\n\t\t// If output is larger than format cut the output\n\t\t// This helps us avoid errors from time.Parse\n\t\tif len(timeOutput) > len(timeFormat) {\n\t\t\ttimeOutput = timeOutput[:len(timeFormat)]\n\t\t}\n\n\t\t// Attempt to parse the time\n\t\ttimeStruct, err := time.Parse(timeFormat, timeOutput)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tv.Set(reflect.ValueOf(timeStruct))\n\t\treturn nil\n\t}\n\n\tv.Set(reflect.ValueOf(date(f)))\n\treturn nil\n}\n"
        },
        {
          "name": "struct_test.go",
          "type": "blob",
          "size": 20.6962890625,
          "content": "package gofakeit\n\nimport (\n\t\"fmt\"\n\t\"net\"\n\t\"regexp\"\n\t\"strings\"\n\t\"testing\"\n\t\"time\"\n)\n\ntype Basic struct {\n\ts string\n\tS string\n}\n\ntype embeder struct {\n\tA  string\n\tAA []string\n\tembedee\n}\n\ntype embedee struct {\n\tB  string   `fake:\"{firstname}\"`\n\tBA []string `fake:\"{firstname}\" fakesize:\"5\"`\n}\n\ntype Nested struct {\n\tA   string\n\tB   *Basic\n\tbar *Basic\n\tembeder\n}\n\ntype BuiltIn struct {\n\tUint8   *uint8\n\tUint16  *uint16\n\tUint32  *uint32\n\tUint64  *uint64\n\tInt     *int\n\tInt8    *int8\n\tInt16   *int16\n\tInt32   *int32\n\tInt64   *int64\n\tFloat32 *float32\n\tFloat64 *float64\n\tBool    *bool\n}\n\ntype Function struct {\n\tNumber *string `fake:\"#\"`\n\tName   *string `fake:\"{firstname}\"`\n\tConst  *string `fake:\"ABC\"`\n}\n\ntype StrArray []string\ntype IntArray []int\n\ntype StructArray struct {\n\tBars      []*Basic\n\tBuilds    []BuiltIn\n\tSkips     []string  `fake:\"skip\"`\n\tSkipsAlt  []string  `fake:\"-\"`\n\tStrings   []string  `fake:\"{firstname}\" fakesize:\"3\"`\n\tSetLen    [5]string `fake:\"{firstname}\"`\n\tSubStr    [][]string\n\tSubStrLen [][2]string\n\tEmpty     []*Basic    `fakesize:\"0\"`\n\tMulty     []*Function `fakesize:\"3\"`\n\tStrArray  StrArray    `fake:\"{firstname}\" fakesize:\"3\"`\n\tIntArray  *IntArray   `fake:\"{number:1,10}\" fakesize:\"3\"`\n}\n\ntype NestedArray struct {\n\tNA []StructArray `fakesize:\"2\"`\n}\n\nfunc ExampleStruct() {\n\tSeed(11)\n\n\ttype Bar struct {\n\t\tName   string\n\t\tNumber int\n\t\tFloat  float32\n\t}\n\n\ttype Foo struct {\n\t\tStr        string\n\t\tInt        int\n\t\tPointer    *int\n\t\tName       string            `fake:\"{firstname}\"`\n\t\tNumber     string            `fake:\"{number:1,10}\"`\n\t\tSkip       *string           `fake:\"skip\"`\n\t\tSkipAlt    *string           `fake:\"-\"`\n\t\tArray      []string          `fakesize:\"2\"`\n\t\tArrayRange []string          `fakesize:\"2,6\"`\n\t\tMap        map[string]string `fakesize:\"2\"`\n\t\tMapRange   map[string]string `fakesize:\"2,4\"`\n\t\tBar        Bar\n\t}\n\n\tvar f Foo\n\tStruct(&f)\n\n\tfmt.Printf(\"%s\\n\", f.Str)\n\tfmt.Printf(\"%d\\n\", f.Int)\n\tfmt.Printf(\"%d\\n\", *f.Pointer)\n\tfmt.Printf(\"%v\\n\", f.Name)\n\tfmt.Printf(\"%v\\n\", f.Number)\n\tfmt.Printf(\"%v\\n\", f.Skip)\n\tfmt.Printf(\"%v\\n\", f.SkipAlt)\n\tfmt.Printf(\"%v\\n\", f.Array)\n\tfmt.Printf(\"%v\\n\", f.ArrayRange)\n\tfmt.Printf(\"%v\\n\", f.Map)\n\tfmt.Printf(\"%v\\n\", f.MapRange)\n\tfmt.Printf(\"%+v\\n\", f.Bar)\n\n\t// Output: sKKbMlbxqu\n\t// 1365845625386394310\n\t// 4415419407664574903\n\t// Tomasa\n\t// 10\n\t// <nil>\n\t// <nil>\n\t// [RWVlPmwRAe wVHB]\n\t// [rxXDcxFe kfvChMC KfmBwRtn]\n\t// map[gyJrZ:tfZAk oOEImWl:NXYnuKiGab]\n\t// map[WigEnVzBy:JJXMkG aHqIpyVs:UxvheGVE pYyDuWC:yzjqsX]\n\t// {Name:LfLRuhFRHQ Number:5737279083624806933 Float:0.59020466}\n}\n\nfunc ExampleFaker_Struct() {\n\tfake := New(11)\n\n\ttype Bar struct {\n\t\tName   string\n\t\tNumber int\n\t\tFloat  float32\n\t}\n\n\ttype Foo struct {\n\t\tStr        string\n\t\tInt        int\n\t\tPointer    *int\n\t\tName       string            `fake:\"{firstname}\"`\n\t\tNumber     string            `fake:\"{number:1,10}\"`\n\t\tSkip       *string           `fake:\"skip\"`\n\t\tArray      []string          `fakesize:\"2\"`\n\t\tArrayRange []string          `fakesize:\"2,6\"`\n\t\tMap        map[string]string `fakesize:\"2\"`\n\t\tMapRange   map[string]string `fakesize:\"2,4\"`\n\t\tBar        Bar\n\t}\n\n\tvar f Foo\n\tfake.Struct(&f)\n\n\tfmt.Printf(\"%s\\n\", f.Str)\n\tfmt.Printf(\"%d\\n\", f.Int)\n\tfmt.Printf(\"%d\\n\", *f.Pointer)\n\tfmt.Printf(\"%v\\n\", f.Name)\n\tfmt.Printf(\"%v\\n\", f.Number)\n\tfmt.Printf(\"%v\\n\", f.Skip)\n\tfmt.Printf(\"%v\\n\", f.Array)\n\tfmt.Printf(\"%v\\n\", f.Map)\n\tfmt.Printf(\"%v\\n\", f.MapRange)\n\tfmt.Printf(\"%+v\\n\", f.Bar)\n\n\t// Output: sKKbMlbxqu\n\t// 1365845625386394310\n\t// 4415419407664574903\n\t// Tomasa\n\t// 10\n\t// <nil>\n\t// [RWVlPmwRAe wVHB]\n\t// map[gyJrZ:tfZAk oOEImWl:NXYnuKiGab]\n\t// map[WigEnVzBy:JJXMkG aHqIpyVs:UxvheGVE pYyDuWC:yzjqsX]\n\t// {Name:LfLRuhFRHQ Number:5737279083624806933 Float:0.59020466}\n}\n\nfunc ExampleStruct_array() {\n\tSeed(11)\n\n\ttype Foo struct {\n\t\tBar    string\n\t\tInt    int\n\t\tName   string  `fake:\"{firstname}\"`\n\t\tNumber string  `fake:\"{number:1,10}\"`\n\t\tSkip   *string `fake:\"skip\"`\n\t}\n\n\ttype FooMany struct {\n\t\tFoos       []Foo    `fakesize:\"1\"`\n\t\tNames      []string `fake:\"{firstname}\" fakesize:\"3\"`\n\t\tNamesRange []string `fake:\"{firstname}\" fakesize:\"3,6\"`\n\t}\n\n\tvar fm FooMany\n\tStruct(&fm)\n\n\tfmt.Printf(\"%v\\n\", fm.Foos)\n\tfmt.Printf(\"%v\\n\", fm.Names)\n\tfmt.Printf(\"%v\\n\", fm.NamesRange)\n\n\t// Output: [{sKKbMlbxqu 1365845625386394310 Myrtis 10 <nil>}]\n\t// [Tomasa Sunny Ernest]\n\t// [Hassan Missouri Elisabeth Nedra Tiana Evan]\n}\n\nfunc ExampleFaker_Struct_array() {\n\tf := New(11)\n\n\ttype Foo struct {\n\t\tBar    string\n\t\tInt    int\n\t\tName   string  `fake:\"{firstname}\"`\n\t\tNumber string  `fake:\"{number:1,10}\"`\n\t\tSkip   *string `fake:\"skip\"`\n\t}\n\n\ttype FooMany struct {\n\t\tFoos       []Foo    `fakesize:\"1\"`\n\t\tNames      []string `fake:\"{firstname}\" fakesize:\"3\"`\n\t\tNamesRange []string `fake:\"{firstname}\" fakesize:\"3,6\"`\n\t}\n\n\tvar fm FooMany\n\tf.Struct(&fm)\n\n\tfmt.Printf(\"%v\\n\", fm.Foos)\n\tfmt.Printf(\"%v\\n\", fm.Names)\n\tfmt.Printf(\"%v\\n\", fm.NamesRange)\n\n\t// Output: [{sKKbMlbxqu 1365845625386394310 Myrtis 10 <nil>}]\n\t// [Tomasa Sunny Ernest]\n\t// [Hassan Missouri Elisabeth Nedra Tiana Evan]\n}\n\nfunc TestStructBasic(t *testing.T) {\n\tSeed(11)\n\n\tvar basic Basic\n\tStruct(&basic)\n\tif basic.s != \"\" {\n\t\tt.Error(\"unexported field is not populated\")\n\t}\n\tif basic.S == \"\" {\n\t\tt.Error(\"exported field is populated\")\n\t}\n}\n\nfunc TestStructNested(t *testing.T) {\n\tSeed(11)\n\n\tvar nested Nested\n\tStruct(&nested)\n\tif nested.A == \"\" {\n\t\tt.Error(\"exported string field is populated\")\n\t}\n\tif nested.B == nil {\n\t\tt.Error(\"exported struct field is populated\")\n\t}\n\tif nested.B.S == \"\" {\n\t\tt.Error(\"nested struct string field is not populated\")\n\t}\n\tif nested.bar != nil {\n\t\tt.Error(\"nested struct bar should not be populated due to unexported variable\")\n\t}\n\tif nested.embeder.A == \"\" || nested.embeder.AA == nil {\n\t\tt.Error(\"nested embeder fields should be populated\")\n\t}\n\tif nested.embeder.embedee.B == \"\" || nested.embeder.embedee.BA == nil || len(nested.embeder.embedee.BA) != 5 {\n\t\tt.Error(\"nested embeder fields should be populated\")\n\t}\n}\n\nfunc TestStructBuiltInTypes(t *testing.T) {\n\tSeed(11)\n\n\tvar builtIn BuiltIn\n\tStruct(&builtIn)\n\tif builtIn.Uint8 == nil {\n\t\tt.Error(\"builtIn Uint8 was not set\")\n\t}\n\tif builtIn.Uint16 == nil {\n\t\tt.Error(\"builtIn Uint16 was not set\")\n\t}\n\tif builtIn.Uint32 == nil {\n\t\tt.Error(\"builtIn Uint32 was not set\")\n\t}\n\tif builtIn.Uint64 == nil {\n\t\tt.Error(\"builtIn Uint64 was not set\")\n\t}\n\tif builtIn.Int == nil {\n\t\tt.Error(\"builtIn int was not set\")\n\t}\n\tif builtIn.Int8 == nil {\n\t\tt.Error(\"builtIn int8 was not set\")\n\t}\n\tif builtIn.Int16 == nil {\n\t\tt.Error(\"builtIn int16 was not set\")\n\t}\n\tif builtIn.Int32 == nil {\n\t\tt.Error(\"builtIn int32 was not set\")\n\t}\n\tif builtIn.Int64 == nil {\n\t\tt.Error(\"builtIn int64 was not set\")\n\t}\n\tif builtIn.Float32 == nil {\n\t\tt.Error(\"builtIn float32 was not set\")\n\t}\n\tif builtIn.Float64 == nil {\n\t\tt.Error(\"builtIn float64 was not set\")\n\t}\n\tif builtIn.Bool == nil {\n\t\tt.Error(\"builtIn bool was not set\")\n\t}\n}\n\nfunc TestStructWithFunction(t *testing.T) {\n\tSeed(11)\n\n\tvar function Function\n\tStruct(&function)\n\tif *function.Number == \"\" {\n\t\tt.Error(\"function number should set to number value\")\n\t}\n\tif *function.Name == \"\" {\n\t\tt.Error(\"function name should set to name value\")\n\t}\n\tif *function.Const != \"ABC\" {\n\t\tt.Error(\"function const should set to fixed value\")\n\t}\n}\n\nfunc TestStructPointer(t *testing.T) {\n\ttype Info struct {\n\t\tPerson        PersonInfo  `fake:\"{person}\"`\n\t\tPersonPointer *PersonInfo `fake:\"{person}\"`\n\t}\n\n\tvar info Info\n\terr := Struct(&info)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tif info.Person.FirstName == \"\" {\n\t\tt.Error(\"Person wasnt properly set\")\n\t}\n\n\tif info.PersonPointer == nil {\n\t\tt.Error(\"PersonPointer wasnt properly set\")\n\t}\n\tif info.PersonPointer.FirstName == \"\" {\n\t\tt.Error(\"PersonPointer firstname wasnt properly set\")\n\t}\n}\n\nfunc TestCustomArrayType(t *testing.T) {\n\tSeed(11)\n\tAddFuncLookup(\"customType\", Info{\n\t\tCategory:    \"custom\",\n\t\tDescription: \"Random int array\",\n\t\tExample:     \"[1]\",\n\t\tOutput:      \"CustomType\",\n\t\tGenerate: func(f *Faker, m *MapParams, info *Info) (any, error) {\n\t\t\tdata := make([]int, 1)\n\t\t\tdata[0] = 42\n\t\t\treturn data, nil\n\t\t},\n\t})\n\tdefer RemoveFuncLookup(\"customType\")\n\n\tAddFuncLookup(\"customByte\", Info{\n\t\tCategory:    \"custom\",\n\t\tDescription: \"Random byte\",\n\t\tExample:     \"[1]\",\n\t\tOutput:      \"byte\",\n\t\tGenerate: func(f *Faker, m *MapParams, info *Info) (any, error) {\n\t\t\tdata := byte(42)\n\t\t\treturn data, nil\n\t\t},\n\t})\n\n\ttype customType []int\n\tvar wct struct {\n\t\tWithTag         customType `fake:\"{customType}\"`\n\t\tWithOutTag      customType\n\t\tArrayWithTag    []customType `fake:\"{customType}\"`\n\t\tArrayWithOutTag []customType\n\t\tIntSlice        []int\n\t\tChar            byte\n\t\tCharWithTag     byte `fake:\"{customByte}\"`\n\t}\n\terr := Struct(&wct)\n\tif err != nil {\n\t\tt.Error(err)\n\t\tt.FailNow()\n\t}\n\n\tif len(wct.WithTag) != 1 {\n\t\tt.Error(\"wct slice WithTag is not populated from custom function\")\n\t}\n\n\tif wct.WithTag[0] != 42 {\n\t\tt.Errorf(\"wct slice WithTag: want 42, got %d\", wct.WithTag[0])\n\t}\n\n\tif len(wct.WithOutTag) == 0 {\n\t\tt.Error(\"wct slice WithoutTag is not populated\")\n\t}\n\n\tif wct.IntSlice[0] == wct.WithOutTag[0] {\n\t\tt.Error(\"two different slices should have different values\")\n\t}\n\n\tif wct.ArrayWithTag[0][0] != 42 {\n\t\tt.Error(\"wct ArrayWithTag is not populated from custom function\")\n\t}\n\n\tif wct.ArrayWithOutTag[0][0] == 0 {\n\t\tt.Errorf(\"wct ArrayWithoutTag did not set value got:%+v\", wct.ArrayWithOutTag)\n\t}\n\n\tif len(wct.IntSlice) == 0 {\n\t\tt.Error(\"wct slice IntSlice is not populated\")\n\t}\n\n\tif wct.Char == byte(0) {\n\t\tt.Error(\"wct Char is not populated\")\n\t}\n\n\tif wct.CharWithTag != byte(42) {\n\t\tt.Error(\"wct CharWithTag is not populated from custom function\")\n\t}\n}\n\nfunc TestStructArray(t *testing.T) {\n\tSeed(11)\n\n\tvar sa StructArray\n\tStruct(&sa)\n\tif len(sa.Bars) == 0 {\n\t\tt.Error(\"sa slice Bars is not populated\")\n\t}\n\tif len(sa.Builds) == 0 {\n\t\tt.Error(\"sa slice Builds is not populated\")\n\t}\n\tif len(sa.Strings) != 3 {\n\t\tt.Error(\"sa strings should have a length of 3\")\n\t}\n\tif len(sa.Strings) == 3 {\n\t\tfor i, s := range sa.Strings {\n\t\t\tif s == \"\" {\n\t\t\t\tt.Errorf(\"sa Strings index %d was empty\", i)\n\t\t\t}\n\t\t}\n\t}\n\tif len(sa.SetLen) != 5 {\n\t\tfor i, s := range sa.SetLen {\n\t\t\tif s == \"\" {\n\t\t\t\tt.Errorf(\"sa SetLen index %d was empty\", i)\n\t\t\t}\n\t\t}\n\t}\n\tif len(sa.SubStr) == 0 {\n\t\tfor i, s := range sa.SubStr {\n\t\t\tfor ii, ss := range s {\n\t\t\t\tif ss == \"\" {\n\t\t\t\t\tt.Errorf(\"sa SubStr index %d index %d was empty\", i, ii)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif len(sa.SubStrLen) == 0 {\n\t\tfor _, s := range sa.SubStrLen {\n\t\t\tfor _, ss := range s {\n\t\t\t\tif len(ss) != 2 {\n\t\t\t\t\tt.Errorf(\"sa SubStrLen sub length should have been 2\")\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif len(sa.Empty) != 0 {\n\t\tt.Error(\"sa slice Empty is populated\")\n\t}\n\tif len(sa.Skips) != 0 {\n\t\tt.Error(\"sa slice Skips is populated\")\n\t}\n\tif len(sa.Multy) != 3 {\n\t\tt.Error(\"sa slice Multy is not fully populated\")\n\t}\n\tif len(sa.StrArray) != 3 {\n\t\tt.Error(\"sa slice StrArray is not fully populated\")\n\t}\n\tif sa.IntArray == nil || len(*sa.IntArray) != 3 {\n\t\tt.Error(\"sa slice IntArray is not fully populated\")\n\t}\n}\n\nfunc TestStructNestedArray(t *testing.T) {\n\tSeed(11)\n\n\tvar na NestedArray\n\tStruct(&na)\n\tif len(na.NA) != 2 {\n\t\tt.Error(\"na slice NA is not populated\")\n\t}\n\tfor _, elem := range na.NA {\n\t\tif len(elem.Builds) == 0 {\n\t\t\tt.Error(\"a slice Builds is not populated\")\n\t\t}\n\t\tif len(elem.Empty) != 0 {\n\t\t\tt.Error(\"a slice Empty is populated\")\n\t\t}\n\t\tif len(elem.Skips) != 0 {\n\t\t\tt.Error(\"a slice Empty is populated\")\n\t\t}\n\t\tif len(elem.Multy) != 3 {\n\t\t\tt.Error(\"a slice Multy is not fully populated\")\n\t\t}\n\t}\n}\n\nfunc TestStructToInt(t *testing.T) {\n\tSeed(11)\n\n\tvar si struct {\n\t\tInt         int\n\t\tIntConst    int8  `fake:\"-123\"`\n\t\tIntGenerate int64 `fake:\"{number:1,10}\"`\n\t}\n\tStruct(&si)\n\tif si.Int == 0 {\n\t\tt.Error(\"Int should be an actual number greater than 0\")\n\t}\n\tif si.IntConst != -123 {\n\t\tt.Errorf(\"IntConst should be -123 and instead got %d\", si.IntConst)\n\t}\n\tif si.IntGenerate == 0 || si.IntGenerate > 10 {\n\t\tt.Errorf(\"IntGenerate should be between 1-10 but got %d\", si.IntGenerate)\n\t}\n}\n\nfunc TestStructToUint(t *testing.T) {\n\tSeed(11)\n\n\tvar su struct {\n\t\tUint         uint\n\t\tUintConst    uint8  `fake:\"123\"`\n\t\tUintGenerate uint64 `fake:\"{number:1,10}\"`\n\t}\n\tStruct(&su)\n\tif su.Uint == 0 {\n\t\tt.Error(\"Uint should be an actual number greater than 0\")\n\t}\n\tif su.UintConst != 123 {\n\t\tt.Errorf(\"UintConst should be 123 and instead got %d\", su.UintConst)\n\t}\n\tif su.UintGenerate == 0 || su.UintGenerate > 10 {\n\t\tt.Errorf(\"UintGenerate should be between 1-10 but got %d\", su.UintGenerate)\n\t}\n}\n\nfunc TestStructToFloat(t *testing.T) {\n\tSeed(11)\n\n\tvar sf struct {\n\t\tFloat         float32\n\t\tFloatConst    float64 `fake:\"123.456789\"`\n\t\tFloatGenerate float32 `fake:\"{latitude}\"`\n\t}\n\tStruct(&sf)\n\tif sf.Float == 0 {\n\t\tt.Error(\"Float should be an actual number greater than 0\")\n\t}\n\tif sf.FloatConst != 123.456789 {\n\t\tt.Errorf(\"FloatConst should be 123.456.789 and instead got %f\", sf.FloatConst)\n\t}\n\tif sf.FloatGenerate != 87.473328 {\n\t\tt.Errorf(\"FloatGenerate should be 31.477726 but got %f\", sf.FloatGenerate)\n\t}\n}\n\nfunc TestStructToBool(t *testing.T) {\n\tSeed(11)\n\n\tvar sf struct {\n\t\tBool         bool\n\t\tBoolConst    bool `fake:\"true\"`\n\t\tBoolGenerate bool `fake:\"{bool}\"`\n\t}\n\tStruct(&sf)\n\tif sf.Bool == true {\n\t\tt.Error(\"Bool should be true got true\")\n\t}\n\tif sf.BoolConst != true {\n\t\tt.Errorf(\"BoolConst should be true got false\")\n\t}\n\tif sf.BoolGenerate != false {\n\t\tt.Errorf(\"Bool Generate should be %t but got %t\", false, sf.BoolGenerate)\n\t}\n}\n\nfunc TestStructToDateTime(t *testing.T) {\n\tSeed(11)\n\n\tAddFuncLookup(\"datetimestatic\", Info{\n\t\tDescription: \"A static date time\",\n\t\tExample:     \"2021-11-26 15:22:00\",\n\t\tOutput:      \"time.Time\",\n\t\tGenerate: func(f *Faker, m *MapParams, info *Info) (any, error) {\n\t\t\t// Create new static date time\n\t\t\treturn time.Date(2021, 11, 26, 15, 22, 0, 0, time.UTC), nil\n\t\t},\n\t})\n\n\tvar datetime struct {\n\t\tSimple               time.Time\n\t\tTag                  time.Time `fake:\"{date}\"`\n\t\tTagCustom            time.Time `fake:\"{datetimestatic}\"`\n\t\tTagFormat            time.Time `fake:\"{number:1900,1950}-12-05\" format:\"2006-01-02\"`\n\t\tTagJavaFormat        time.Time `fake:\"{number:1900,1950}-12-05\" format:\"yyyy-MM-dd\"`\n\t\tRange                time.Time `fake:\"{daterange:1970-01-01,2000-12-31,2006-01-02}\" format:\"yyyy-MM-dd\"`\n\t\tPointerSimple        *time.Time\n\t\tPointerTag           *time.Time `fake:\"{date}\"`\n\t\tPointerTagCustom     *time.Time `fake:\"{datetimestatic}\"`\n\t\tPointerTagFormat     *time.Time `fake:\"{number:1900,1950}-12-05\" format:\"2006-01-02\"`\n\t\tPointerTagJavaFormat *time.Time `fake:\"{number:1900,1950}-12-05\" format:\"yyyy-MM-dd\"`\n\t\tPointerRange         *time.Time `fake:\"{daterange:1970-01-01,2000-12-31,2006-01-02}\" format:\"yyyy-MM-dd\"`\n\t}\n\terr := Struct(&datetime)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\ttype testCmp struct {\n\t\tname     string\n\t\tobserved string\n\t\texpected string\n\t}\n\n\ttestComparisons := []testCmp{\n\t\t{\n\t\t\tname:     \"Simple\",\n\t\t\tobserved: datetime.Simple.String(),\n\t\t\texpected: \"2011-11-07 04:31:13.726582492 +0000 UTC\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Tag\",\n\t\t\tobserved: datetime.Tag.String(),\n\t\t\texpected: \"1967-12-26 21:04:44 +0000 UTC\",\n\t\t},\n\t\t{\n\t\t\tname:     \"TagCustom\",\n\t\t\tobserved: datetime.TagCustom.String(),\n\t\t\texpected: \"2021-11-26 15:22:00 +0000 UTC\",\n\t\t},\n\t\t{\n\t\t\tname:     \"TagFormat\",\n\t\t\tobserved: datetime.TagFormat.String(),\n\t\t\texpected: \"1947-12-05 00:00:00 +0000 UTC\",\n\t\t},\n\t\t{\n\t\t\tname:     \"TagJavaFormat\",\n\t\t\tobserved: datetime.TagJavaFormat.String(),\n\t\t\texpected: \"1946-12-05 00:00:00 +0000 UTC\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Range\",\n\t\t\tobserved: datetime.Range.String(),\n\t\t\texpected: \"1980-03-10 00:00:00 +0000 UTC\",\n\t\t},\n\t\t{\n\t\t\tname:     \"PointerSimple\",\n\t\t\tobserved: datetime.PointerSimple.String(),\n\t\t\texpected: \"1953-05-23 07:44:55.341122669 +0000 UTC\",\n\t\t},\n\t\t{\n\t\t\tname:     \"PointerTag\",\n\t\t\tobserved: datetime.PointerTag.String(),\n\t\t\texpected: \"1900-07-01 22:25:09 +0000 UTC\",\n\t\t},\n\t\t{\n\t\t\tname:     \"PointerTagCustom\",\n\t\t\tobserved: datetime.PointerTagCustom.String(),\n\t\t\texpected: \"2021-11-26 15:22:00 +0000 UTC\",\n\t\t},\n\t\t{\n\t\t\tname:     \"PointerTagFormat\",\n\t\t\tobserved: datetime.PointerTagFormat.String(),\n\t\t\texpected: \"1910-12-05 00:00:00 +0000 UTC\",\n\t\t},\n\t\t{\n\t\t\tname:     \"PointerTagJavaFormat\",\n\t\t\tobserved: datetime.PointerTagJavaFormat.String(),\n\t\t\texpected: \"1932-12-05 00:00:00 +0000 UTC\",\n\t\t},\n\t\t{\n\t\t\tname:     \"PointerRange\",\n\t\t\tobserved: datetime.PointerRange.String(),\n\t\t\texpected: \"1995-12-07 00:00:00 +0000 UTC\",\n\t\t},\n\t}\n\tfor _, c := range testComparisons {\n\t\tif c.expected != c.observed {\n\t\t\tt.Errorf(\"%s should be %s and instead got %s\", c.name, c.expected, c.observed)\n\t\t}\n\t}\n\n\tRemoveFuncLookup(\"datetimestatic\")\n}\n\nfunc TestStructSetSubStruct(t *testing.T) {\n\tSeed(11)\n\n\ttype Sub struct {\n\t\tStr string\n\t\tNum int\n\t\tFlo float32\n\t}\n\n\ttype Foo struct {\n\t\tSub Sub `fake:\"{setstruct}\"`\n\t}\n\n\tAddFuncLookup(\"setstruct\", Info{\n\t\tGenerate: func(f *Faker, m *MapParams, info *Info) (any, error) {\n\t\t\treturn Sub{Str: \"string\", Num: 123, Flo: 123.456}, nil\n\t\t},\n\t})\n\n\tvar f Foo\n\tStruct(&f)\n\n\tif f.Sub.Str != \"string\" {\n\t\tt.Errorf(\"str didnt equal string, got %s\", f.Sub.Str)\n\t}\n\tif f.Sub.Num != 123 {\n\t\tt.Errorf(\"num didnt equal 123, got %d\", f.Sub.Num)\n\t}\n\tif f.Sub.Flo != 123.456 {\n\t\tt.Errorf(\"flo didnt equal 123.456, got %v\", f.Sub.Flo)\n\t}\n\n\tRemoveFuncLookup(\"setstruct\")\n}\n\nfunc TestStructMap(t *testing.T) {\n\tSeed(11)\n\n\ttype Bar struct {\n\t\tName string\n\t}\n\n\ttype MapCustom map[string]Bar\n\n\ttype Foo struct {\n\t\tMapStr       map[string]string\n\t\tMapInt       map[int]int\n\t\tMapFloat     map[float32]float32\n\t\tMapStrPtr    map[string]*string\n\t\tMapPtr       *map[string]any\n\t\tMapStruct    map[string]Bar\n\t\tMapArray     map[string][]Bar\n\t\tMapSize      map[string]string `fakesize:\"20\"`\n\t\tMapCustom    MapCustom\n\t\tMapCustomMap map[string]MapCustom\n\t}\n\n\tvar f Foo\n\terr := Struct(&f)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tif len(f.MapStr) == 0 {\n\t\tt.Errorf(\"Map Str %+v\", f.MapStr)\n\t}\n\n\tif len(f.MapInt) == 0 {\n\t\tt.Errorf(\"Map Int %+v\", f.MapInt)\n\t}\n\n\tif len(f.MapFloat) == 0 {\n\t\tt.Errorf(\"Map Float %+v\", f.MapFloat)\n\t}\n\n\tif len(f.MapStrPtr) == 0 {\n\t\tt.Errorf(\"Map Str Ptr %+v\", f.MapStrPtr)\n\t}\n\n\tif len(*f.MapPtr) == 0 {\n\t\tt.Errorf(\"Map Ptr %+v\", *f.MapPtr)\n\t}\n\n\tif len(f.MapStruct) == 0 {\n\t\tt.Errorf(\"Map Struct %+v\", f.MapStruct)\n\t}\n\n\tif len(f.MapArray) == 0 {\n\t\tt.Errorf(\"Map Array %+v\", f.MapArray)\n\t} else {\n\t\tfor _, v := range f.MapArray {\n\t\t\tif len(v) == 0 {\n\t\t\t\tt.Errorf(\"Map Array Values %+v\", f.MapArray)\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}\n\n\tif len(f.MapSize) != 20 {\n\t\tt.Errorf(\"Map size %+v\", f.MapSize)\n\t}\n\n\tif len(f.MapCustom) == 0 {\n\t\tt.Errorf(\"Map Custom %+v\", f.MapCustom)\n\t}\n\n\tif len(f.MapCustomMap) == 0 {\n\t\tt.Errorf(\"Map Custom Map %+v\", f.MapCustomMap)\n\t} else {\n\t\tfor _, v := range f.MapCustomMap {\n\t\t\tif len(v) == 0 {\n\t\t\t\tt.Errorf(\"Map Custom Map Values %+v\", f.MapCustomMap)\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc TestStructSliceLoopGeneration(t *testing.T) {\n\ttype S struct {\n\t\tA []string\n\t}\n\n\ts := &S{}\n\tfor i := 0; i < 2; i++ {\n\t\tif err := Struct(s); err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t}\n}\n\nfunc TestExternalCustomType(t *testing.T) {\n\ttype Foo struct {\n\t\tIP net.IP `fake:\"{netip}\"`\n\t}\n\n\tvar f Foo\n\n\tSeed(11)\n\tAddFuncLookup(\"netip\", Info{\n\t\tCategory:    \"custom\",\n\t\tDescription: \"Random IPv4 Address of type net.IP\",\n\t\tExample:     \"1.1.1.1\",\n\t\tOutput:      \"net.IP\",\n\t\tGenerate: func(f *Faker, m *MapParams, info *Info) (any, error) {\n\t\t\tdata := net.IPv4(byte(f.IntN(256)), byte(f.IntN(256)), byte(f.IntN(256)), byte(f.IntN(256)))\n\t\t\treturn data, nil\n\t\t},\n\t})\n\tdefer RemoveFuncLookup(\"netip\")\n\tStruct(&f)\n\n\t// Regex check its an IP\n\treg := `^\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}$`\n\tmatched, err := regexp.MatchString(reg, f.IP.String())\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n\n\tif !matched {\n\t\tt.Errorf(\"IP address is not valid: %s\", f.IP.String())\n\t}\n}\n\nfunc TestStructArrayWithInvalidCustomFunc(t *testing.T) {\n\tAddFuncLookup(\"customType\", Info{\n\t\tCategory:    \"custom\",\n\t\tDescription: \"Random int array\",\n\t\tExample:     \"[1]\",\n\t\tOutput:      \"CustomType\",\n\t\tGenerate: func(f *Faker, m *MapParams, info *Info) (any, error) {\n\t\t\tdata := make([]int, 1)\n\t\t\tdata[0] = 42\n\t\t\treturn data, nil\n\t\t},\n\t})\n\tdefer RemoveFuncLookup(\"customType\")\n\n\tvar invalidCustomTag struct {\n\t\tInvalidTag []int `fake:\"{customType}\"`\n\t}\n\terr := Struct(&invalidCustomTag)\n\tif err.Error() != `strconv.ParseInt: parsing \"[42]\": invalid syntax` {\n\t\tt.Error(err)\n\t}\n}\n\nfunc TestStructMapWithCustomFunction(t *testing.T) {\n\tAddFuncLookup(\"custom_map\", Info{\n\t\tGenerate: func(f *Faker, m *MapParams, info *Info) (any, error) {\n\t\t\treturn map[string]string{\"abc\": \"123\"}, nil\n\t\t},\n\t})\n\tdefer RemoveFuncLookup(\"custom_map\")\n\n\ttype StructMap struct {\n\t\tMapCustomFun map[string]string `fake:\"{custom_map}\"`\n\t}\n\tvar f StructMap\n\n\terr := Struct(&f)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tif v, ok := f.MapCustomFun[\"abc\"]; ok {\n\t\tif v != \"123\" {\n\t\t\tt.Errorf(\"value didnt equal 123, got %v\", v)\n\t\t}\n\t} else {\n\t\tt.Errorf(\"map didnt contain 'abc'.\")\n\t}\n}\n\nfunc TestStructBrokenFakeTag(t *testing.T) {\n\ttype StructMap struct {\n\t\tBrokenTag map[string]string `fake:\"{randomstring:[hello,world}\"`\n\t}\n\tvar f StructMap\n\n\terr := Struct(&f)\n\tif err == nil {\n\t\tt.Error(\"expected error\")\n\t}\n\n\t// error should contain \"missing ending ]\"\n\tif !strings.Contains(err.Error(), \"missing ending ]\") {\n\t\tt.Fatal(err)\n\t}\n}\n"
        },
        {
          "name": "template.go",
          "type": "blob",
          "size": 13.15234375,
          "content": "package gofakeit\n\nimport (\n\t\"bytes\"\n\t\"fmt\"\n\t\"strconv\"\n\t\"time\"\n\n\t\"reflect\"\n\t\"strings\"\n\t\"text/template\"\n)\n\n// TemplateOptions defines values needed for template document generation\ntype TemplateOptions struct {\n\tFuncs template.FuncMap `fake:\"-\"`\n\tData  any              `json:\"data\" xml:\"data\" fake:\"-\"`\n}\n\n// Template generates an document based on the the supplied template\nfunc Template(template string, co *TemplateOptions) (string, error) {\n\tif co == nil {\n\t\tco = &TemplateOptions{}\n\t\tGlobalFaker.Struct(co)\n\t}\n\treturn templateFunc(template, templateFuncMap(GlobalFaker, &co.Funcs), co)\n}\n\n// Template generates an document based on the the supplied template\nfunc (f *Faker) Template(template string, co *TemplateOptions) (string, error) {\n\tif co == nil {\n\t\tco = &TemplateOptions{}\n\t\tf.Struct(co)\n\t}\n\treturn templateFunc(template, templateFuncMap(f, &co.Funcs), co)\n}\n\n// MarkdownOptions defines values needed for markdown document generation\ntype MarkdownOptions struct {\n}\n\n// Template for Markdown\nconst templateMarkdown = `\n{{$repo := Gamertag}}\n{{$language := RandomString (SliceString \"go\" \"python\" \"javascript\")}}\n{{$username := Gamertag}}\n{{$weightedSlice := SliceAny \"github.com\" \"gitlab.com\" \"bitbucket.org\"}}\n{{$weightedWeights := SliceF32 5 1 1}}\n{{$domain := Weighted $weightedSlice $weightedWeights}}\n{{$action := RandomString (SliceString \"process\" \"run\" \"execute\" \"perform\" \"handle\")}}\n{{$usage := RandomString (SliceString \"whimsical story\" \"quirky message\" \"playful alert\" \"funny request\" \"lighthearted command\")}}\n{{$result := RandomString (SliceString \"success\" \"error\" \"unknown\" \"completed\" \"failed\" \"finished\" \"in progress\" \"terminated\")}}\n\n# {{$repo}}\n\n*Author: {{FirstName}} {{LastName}}*\n\n{{Paragraph 2 5 7 \"\\n\\n\"}}\n\n## Table of Contents\n- [Installation](#installation)\n- [Usage](#usage)\n- [License](#license)\n\n## Installation\n{{if eq $language \"go\"}}'''go\ngo get {{$domain}}/{{$username}}/{{$repo}}\n'''{{else if eq $language \"python\"}}'''bash\npip install {{$repo}}\n'''{{else if eq $language \"javascript\"}}'''js\nnpm install {{$repo}}\n'''{{end}}\n\n## Usage\n{{if eq $language \"go\"}}'''go\nresult := {{$repo}}.{{$action}}(\"{{ToLower $usage}}\")\nfmt.Println(\"{{ToLower $repo}} result:\", \"{{ToLower $result}}\")\n'''{{else if eq $language \"python\"}}'''python\nresult = {{ToLower $repo}}.{{$action}}(\"{{ToLower $usage}}\")\nprint(\"{{ToLower $repo}} result:\", \"{{ToLower $result}}\")\n'''{{else if eq $language \"javascript\"}}'''javascript\nconst result = {{ToLower $repo}}.{{$action}}(\"{{ToLower $usage}}\");\nconsole.log(\"{{ToLower $repo}} result:\", \"{{ToLower $result}}\");\n'''{{end}}\n\n## License\n{{RandomString (SliceString \"MIT\" \"Apache 2.0\" \"GPL-3.0\" \"BSD-3-Clause\" \"ISC\")}}\n`\n\n// Markdown will return a single random Markdown template document\nfunc Markdown(co *MarkdownOptions) (string, error) {\n\tif co == nil {\n\t\tco = &MarkdownOptions{}\n\t\tGlobalFaker.Struct(co)\n\t}\n\treturn templateFunc(templateMarkdown, templateFuncMap(GlobalFaker, nil), co)\n}\n\n// Markdown will return a single random Markdown template document\nfunc (f *Faker) Markdown(co *MarkdownOptions) (string, error) {\n\tif co == nil {\n\t\tco = &MarkdownOptions{}\n\t\tf.Struct(co)\n\t}\n\treturn templateFunc(templateMarkdown, templateFuncMap(f, nil), co)\n}\n\n// EmailOptions defines values needed for email document generation\ntype EmailOptions struct {\n}\n\n// Template for email text\nconst templateEmail = `\nSubject: {{RandomString (SliceString \"Greetings\" \"Hello\" \"Hi\")}} from {{FirstName}}!\n\nDear {{LastName}},\n\n{{RandomString (SliceString \"Greetings!\" \"Hello there!\" \"Hi, how are you?\")}} {{RandomString (SliceString \"How's everything going?\" \"I hope your day is going well.\" \"Sending positive vibes your way.\")}}\n\n{{RandomString (SliceString \"I trust this email finds you well.\" \"I hope you're doing great.\" \"Hoping this message reaches you in good spirits.\")}} {{RandomString (SliceString  \"Wishing you a fantastic day!\" \"May your week be filled with joy.\" \"Sending good vibes your way.\")}}\n\n{{Paragraph 3 5 10 \"\\n\\n\"}}\n\n{{RandomString (SliceString \"I would appreciate your thoughts on\" \"I'm eager to hear your feedback on\" \"I'm curious to know what you think about\")}} it. If you have a moment, please feel free to check out the project on {{RandomString (SliceString \"GitHub\" \"GitLab\" \"Bitbucket\")}}\n\n{{RandomString (SliceString \"Your insights would be invaluable.\" \"I'm eager to hear what you think.\" \"Feel free to share your opinions with me.\")}} {{RandomString (SliceString \"Looking forward to your feedback!\" \"Your perspective is highly valued.\" \"Your thoughts matter to me.\")}}\n\n{{RandomString (SliceString \"Thank you for your consideration!\" \"I appreciate your attention to this matter.\" \"Your support means a lot to me.\")}} {{RandomString (SliceString \"Wishing you a wonderful day!\" \"Thanks in advance for your time.\" \"Your feedback is greatly appreciated.\")}}\n\n{{RandomString (SliceString \"Warm regards\" \"Best wishes\" \"Kind regards\" \"Sincerely\" \"With gratitude\")}}\n{{FirstName}} {{LastName}}\n{{Email}}\n{{PhoneFormatted}}\n`\n\n// EmailText will return a single random text email template document\nfunc EmailText(co *EmailOptions) (string, error) {\n\tif co == nil {\n\t\tco = &EmailOptions{}\n\t\tGlobalFaker.Struct(co)\n\t}\n\treturn templateFunc(templateEmail, templateFuncMap(GlobalFaker, nil), co)\n}\n\n// EmailText will return a single random text email template document\nfunc (f *Faker) EmailText(co *EmailOptions) (string, error) {\n\tif co == nil {\n\t\tco = &EmailOptions{}\n\t\tf.Struct(co)\n\t}\n\treturn templateFunc(templateEmail, templateFuncMap(f, nil), co)\n}\n\n// functions that wont work with template engine\nvar templateExclusion = []string{\n\t\"RandomMapKey\",\n\t\"SQL\",\n\t\"Template\",\n}\n\n// Build the template.FuncMap for the template engine\nfunc templateFuncMap(f *Faker, fm *template.FuncMap) *template.FuncMap {\n\n\t// create a new function map\n\tfuncMap := template.FuncMap{}\n\n\tv := reflect.ValueOf(f)\n\n\t// loop through the methods\n\tfor i := 0; i < v.NumMethod(); i++ {\n\t\t// check if the method is in the exclusion list\n\t\tif stringInSlice(v.Type().Method(i).Name, templateExclusion) {\n\t\t\tcontinue\n\t\t}\n\n\t\t// Check if method has return values\n\t\t// If not don't add to function map\n\t\tif v.Type().Method(i).Type.NumOut() == 0 {\n\t\t\tcontinue\n\t\t}\n\n\t\t// add the method to the function map\n\t\tfuncMap[v.Type().Method(i).Name] = v.Method(i).Interface()\n\t}\n\n\t// make string upper case\n\tfuncMap[\"ToUpper\"] = strings.ToUpper\n\n\t// make string lower case\n\tfuncMap[\"ToLower\"] = strings.ToLower\n\n\t// make string title case\n\tfuncMap[\"IntRange\"] = func(start, end int) []int {\n\t\tn := end - start + 1\n\t\tresult := make([]int, n)\n\t\tfor i := 0; i < n; i++ {\n\t\t\tresult[i] = start + i\n\t\t}\n\t\treturn result\n\t}\n\n\t// enable passing any type to return a string\n\tfuncMap[\"ToInt\"] = func(args any) int {\n\t\tswitch v := args.(type) {\n\t\tcase string:\n\t\t\ti, err := strconv.Atoi(v)\n\t\t\tif err != nil {\n\t\t\t\treturn 0\n\t\t\t}\n\n\t\t\treturn i\n\t\tcase float64:\n\t\t\treturn int(v)\n\t\tcase float32:\n\t\t\treturn int(v)\n\t\tcase int:\n\t\t\treturn v\n\n\t\t// Anything else return 0\n\t\tdefault:\n\t\t\treturn 0\n\t\t}\n\t}\n\n\t// enable passing any type to return a float64\n\tfuncMap[\"ToFloat\"] = func(args any) float64 {\n\t\tswitch v := args.(type) {\n\t\tcase string:\n\t\t\ti, err := strconv.ParseFloat(v, 64)\n\t\t\tif err != nil {\n\t\t\t\treturn 0\n\t\t\t}\n\n\t\t\treturn i\n\t\tcase float64:\n\t\t\treturn v\n\t\tcase float32:\n\t\t\treturn float64(v)\n\t\tcase int:\n\t\t\treturn float64(v)\n\n\t\t// Anything else return 0\n\t\tdefault:\n\t\t\treturn 0\n\t\t}\n\t}\n\n\t// ensable passing any type to return a string\n\tfuncMap[\"ToString\"] = func(args any) string {\n\t\tswitch v := args.(type) {\n\t\tcase string:\n\t\t\treturn v\n\t\tcase float64:\n\t\t\treturn strconv.FormatFloat(v, 'f', -1, 64)\n\t\tcase float32:\n\t\t\treturn strconv.FormatFloat(float64(v), 'f', -1, 32)\n\t\tcase int:\n\t\t\treturn strconv.Itoa(v)\n\n\t\t// Anything else return empty string\n\t\tdefault:\n\t\t\treturn \"\"\n\t\t}\n\t}\n\n\t// function to convert string to date time\n\tfuncMap[\"ToDate\"] = func(dateString string) time.Time {\n\t\tdate, err := time.Parse(\"2006-01-02\", dateString)\n\t\tif err != nil {\n\t\t\treturn time.Now()\n\t\t}\n\t\treturn date\n\t}\n\n\t// enable passing slice of interface to functions\n\tfuncMap[\"SliceAny\"] = func(args ...any) []any {\n\t\treturn args\n\t}\n\n\t// enable passing slice of string to functions\n\tfuncMap[\"SliceString\"] = func(args ...string) []string {\n\t\treturn args\n\t}\n\n\t// enable passing slice of uint to functions\n\tfuncMap[\"SliceUInt\"] = func(args ...uint) []uint {\n\t\treturn args\n\t}\n\n\t// enable passing slice of int to functions\n\tfuncMap[\"SliceInt\"] = func(args ...int) []int {\n\t\treturn args\n\t}\n\n\t// enable passing slice of int to functions\n\tfuncMap[\"SliceF32\"] = func(args ...float32) []float32 {\n\t\treturn args\n\t}\n\n\t// Add passed in function map to the function map\n\tif fm != nil {\n\t\tfor k, v := range *fm {\n\t\t\tfuncMap[k] = v\n\t\t}\n\t}\n\n\treturn &funcMap\n}\n\n// function to build the function map for the template engine from the global faker\nfunc templateFunc(temp string, funcs *template.FuncMap, data any) (string, error) {\n\tif temp == \"\" {\n\t\treturn \"\", fmt.Errorf(\"template parameter is empty\")\n\t}\n\n\t// Create a new template and parse\n\ttemplate_gen, err := template.New(\"CodeRun\").Funcs(*funcs).Parse(temp)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\tb := &bytes.Buffer{}\n\terr = template_gen.Execute(b, data)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\t// Return the result\n\treturn strings.ReplaceAll(b.String(), \"\\\\n\", \"\\n\"), nil\n\n}\n\n// addTemplateLookup will add the template functions to the global lookup\nfunc addTemplateLookup() {\n\tAddFuncLookup(\"template\", Info{\n\t\tDisplay:     \"Template\",\n\t\tCategory:    \"template\",\n\t\tDescription: \"Generates document from template\",\n\t\tExample: `{{Firstname}} {{Lastname}}\n\n// output\nMarkus Moen`,\n\t\tOutput:      \"string\",\n\t\tContentType: \"text/plain\",\n\t\tParams: []Param{\n\t\t\t{Field: \"template\", Display: \"Template\", Type: \"string\", Description: \"Golang template to generate the document from\"},\n\t\t\t{Field: \"data\", Display: \"Custom Data\", Type: \"string\", Default: \"\", Optional: true, Description: \"Custom data to pass to the template\"},\n\t\t},\n\t\tGenerate: func(f *Faker, m *MapParams, info *Info) (any, error) {\n\t\t\ttpl, err := info.GetString(m, \"template\")\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\n\t\t\tdata, err := info.GetAny(m, \"data\")\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\n\t\t\ttemplateOut, err := templateFunc(tpl, templateFuncMap(f, nil), &TemplateOptions{Data: data})\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\n\t\t\treturn templateOut, nil\n\t\t},\n\t})\n\n\tAddFuncLookup(\"markdown\", Info{\n\t\tDisplay:     \"Random markdown document\",\n\t\tCategory:    \"template\",\n\t\tDescription: \"Lightweight markup language used for formatting plain text\",\n\t\tExample: `# PurpleSheep5\n\n*Author: Amie Feil*\n\nQuarterly without week it hungry thing someone. Him regularly today whomever this revolt hence. From his timing as quantity us these. Yours live these frantic not may another. How this ours his them those whose.\n\nThem batch its Iraqi most that few. Abroad cheese this whereas next how there. Gorgeous genetics time choir fiction therefore yourselves. Am those infrequently heap software quarterly rather. Punctuation yellow where several his orchard to.\n\n## Table of Contents\n- [Installation](#installation)\n- [Usage](#usage)\n- [License](#license)\n\n## Installation\n'''bash\npip install PurpleSheep5\n'''\n\n## Usage\n'''python\nresult = purplesheep5.process(\"funny request\")\nprint(\"purplesheep5 result:\", \"in progress\")\n'''\n\n## License\nMIT`,\n\t\tOutput: \"string\",\n\t\tGenerate: func(f *Faker, m *MapParams, info *Info) (any, error) {\n\t\t\ttemplate_result, err := templateFunc(templateMarkdown, templateFuncMap(f, nil), &MarkdownOptions{})\n\t\t\treturn string(template_result), err\n\t\t},\n\t})\n\n\tAddFuncLookup(\"email_text\", Info{\n\t\tDisplay:     \"Random text email Document\",\n\t\tCategory:    \"template\",\n\t\tDescription: \"Written content of an email message, including the sender's message to the recipient\",\n\t\tExample: `Subject: Greetings from Marcel!\n\nDear Pagac,\n\nHello there! Sending positive vibes your way.\n\nI hope you're doing great. May your week be filled with joy.\n\nVirtually woman where team late quarterly without week it hungry. Thing someone him regularly today whomever this revolt hence from. His timing as quantity us these yours live these frantic. Not may another how this ours his them those whose. Them batch its Iraqi most that few abroad cheese this.\n\nWhereas next how there gorgeous genetics time choir fiction therefore. Yourselves am those infrequently heap software quarterly rather punctuation yellow. Where several his orchard to frequently hence victorious boxers each. Does auspicious yourselves first soup tomorrow this that must conclude. Anyway some yearly who cough laugh himself both yet rarely.\n\nMe dolphin intensely block would leap plane us first then. Down them eager would hundred super throughout animal yet themselves. Been group flock shake part purchase up usually it her. None it hers boat what their there Turkmen moreover one. Lebanese to brace these shower in it everybody should whatever.\n\nI'm curious to know what you think about it. If you have a moment, please feel free to check out the project on Bitbucket\n\nI'm eager to hear what you think. Looking forward to your feedback!\n\nThank you for your consideration! Thanks in advance for your time.\n\nKind regards\nMilford Johnston\njamelhaag@king.org\n(507)096-3058`,\n\t\tOutput: \"string\",\n\t\tGenerate: func(f *Faker, m *MapParams, info *Info) (any, error) {\n\t\t\ttemplate_result, err := templateFunc(templateEmail, templateFuncMap(f, nil), &EmailOptions{})\n\t\t\treturn string(template_result), err\n\t\t},\n\t})\n}\n"
        },
        {
          "name": "template_test.go",
          "type": "blob",
          "size": 11.1494140625,
          "content": "package gofakeit\n\nimport (\n\t\"fmt\"\n\t\"regexp\"\n\t\"strings\"\n\t\"testing\"\n\t\"text/template\"\n)\n\nfunc ExampleTemplate() {\n\tSeed(11)\n\n\ttemplate := `{{range IntRange 1 4}}{{FirstName}} {{LastName}}\\n{{end}}`\n\n\tvalue, err := Template(template, &TemplateOptions{Data: 4})\n\tif err != nil {\n\t\tfmt.Println(err)\n\t}\n\n\tfmt.Println(string(value))\n\n\t// Output: Sonny Stiedemann\n\t// Cody Donnelly\n\t// Julius Farrell\n\t// Mollie Legros\n\n}\n\nfunc ExampleFaker_Template() {\n\tf := New(11)\n\n\ttemplate := `{{range IntRange 1 4}}{{FirstName}} {{LastName}}\\n{{end}}`\n\n\tvalue, err := f.Template(template, &TemplateOptions{Data: 4})\n\tif err != nil {\n\t\tfmt.Println(err)\n\t}\n\n\tfmt.Println(string(value))\n\n\t// Output: Sonny Stiedemann\n\t// Cody Donnelly\n\t// Julius Farrell\n\t// Mollie Legros\n}\n\nfunc TestPassedInFunctionMap(t *testing.T) {\n\tf := New(11)\n\n\tfuncMap := template.FuncMap{\n\t\t\"title\": func(s string) string {\n\t\t\twords := strings.Fields(s)\n\t\t\tfor i, word := range words {\n\t\t\t\tletters := strings.Split(word, \"\")\n\t\t\t\tletters[0] = strings.ToUpper(letters[0])\n\t\t\t\twords[i] = strings.Join(letters, \"\")\n\t\t\t}\n\t\t\treturn strings.Join(words, \" \")\n\t\t},\n\t}\n\n\ts := `{{printf \"%q\" (title .Data)}}`\n\n\tvalue, err := f.Template(s, &TemplateOptions{Funcs: funcMap, Data: \"the go programming language\"})\n\tif err != nil {\n\t\tfmt.Println(err)\n\t}\n\n\tif value != \"\\\"The Go Programming Language\\\"\" {\n\t\tt.Error(\"Expected \\\"The Go Programming Language\\\", got \", value)\n\t}\n}\n\nfunc TestTemplate_misc(t *testing.T) {\n\tf := New(11)\n\n\t// functions with parameters\n\ttests := map[string]string{\n\t\t\"Weighted\":            \"{{Weighted (SliceAny `hello` 2 6.9) (SliceF32 1 2 3)}}\",\n\t\t\"Dice\":                \"{{Dice 3 (SliceUInt 1 5 3) }}\",\n\t\t\"IntRange\":            \"{{IntRange 1 5}}\",\n\t\t\"UintRange\":           \"{{UintRange 1 5}}\",\n\t\t\"RandomInt\":           \"{{RandomInt (SliceInt 1 5 3) }}\",\n\t\t\"RandomString\":        \"{{RandomString (SliceString `key1` `key2` `key3`)}}\",\n\t\t\"RandomUint\":          \"{{RandomUint (SliceUInt 2 6 9)}}\",\n\t\t\"Teams\":               \"{{Teams (SliceString `person_a` `person_b` `person_c`) (SliceString `team_a` `team_b` `team_c`)}}\",\n\t\t\"SliceAny\":            \"{{SliceAny `hello` 2 6.9}}\",\n\t\t\"SliceString\":         \"{{SliceString `testa` `testb` `testc`}}\",\n\t\t\"SliceF32\":            \"{{SliceF32 1.2 5.55 7.955}}\",\n\t\t\"SliceInt\":            \"{{SliceInt 1 5 9}}\",\n\t\t\"SliceUInt\":           \"{{SliceUInt 1 5 9}}\",\n\t\t\"Password\":            \"{{Password true false false false false 32}}\",\n\t\t\"ToUpper\":             \"{{ToUpper `this was lower`}}\",\n\t\t\"ToLower\":             \"{{ToLower `THIS WAS UPPER`}}\",\n\t\t\"Sentence\":            \"{{Sentence 3}}\",\n\t\t\"LoremIpsumSentence\":  \"{{LoremIpsumSentence 3}}\",\n\t\t\"Image\":               \"{{Image 1 1}}\",\n\t\t\"ImageJpeg\":           \"{{ImageJpeg 1 1}}\",\n\t\t\"ImagePng\":            \"{{ImagePng 1 1}}\",\n\t\t\"Numerify\":            \"{{Numerify `10` }}\",\n\t\t\"LatitudeInRange\":     \"{{LatitudeInRange 21 42 }}\",\n\t\t\"Number\":              \"{{Number 1 42 }}\",\n\t\t\"Price\":               \"{{Price 1 100 }}\",\n\t\t\"Regex\":               \"{{Regex `[abcdef]{5}` }}\",\n\t\t\"DigitN\":              \"{{DigitN 10 }}\",\n\t\t\"LoremIpsumParagraph\": \"{{LoremIpsumParagraph 3  5  12 `\\n` }}\",\n\t\t\"Paragraph\":           \"{{Paragraph 3  5  12 `\\n` }}\",\n\t\t\"Lexify\":              \"{{Lexify `hello`}}\",\n\t\t\"LogLevel\":            \"{{LogLevel `apache`}}\",\n\t\t\"CreditCardNumber\":    \"{{CreditCardNumber nil}}\",\n\t\t\"Markdown\":            \"{{Markdown nil}}\",\n\t\t\"EmailText\":           \"{{EmailText nil}}\",\n\t\t\"LetterN\":             \"{{LetterN 10}}\",\n\t\t\"FixedWidth\":          \"{{FixedWidth nil}}\",\n\t\t\"Float32Range\":        \"{{Float32Range 2.2 55.6}}\",\n\t\t\"Float64Range\":        \"{{Float64Range 2.2 55.6}}\",\n\t\t\"HipsterParagraph\":    \"{{HipsterParagraph 3  5  12 `\\n`}}\",\n\t\t\"HipsterSentence\":     \"{{HipsterParagraph 3  5  12 `\\n`}}\",\n\t\t\"LongitudeInRange\":    \"{{LongitudeInRange 21 42 }}\",\n\t\t\"Svg\":                 \"{{Svg  nil}}\",\n\t\t\"DateRange\":           \"{{DateRange (ToDate `2006-01-02`) (ToDate `2006-01-02`)}}\",\n\t}\n\n\tfor k, v := range tests {\n\n\t\tvalue, err := f.Template(v, nil)\n\n\t\tif err != nil {\n\t\t\tt.Error(k, err)\n\t\t}\n\n\t\tif string(value) == \"\" {\n\t\t\tt.Errorf(\"expected a value for %s, got nothing\", k)\n\t\t}\n\t}\n}\n\nfunc TestTemplateLookup(t *testing.T) {\n\tf := New(11)\n\n\tinfo := GetFuncLookup(\"template\")\n\n\tm := MapParams{\n\t\t\"template\": {\"{{range IntRange 1 (ToInt .Data)}}{{FirstName}} {{LastName}}\\n{{end}}\"},\n\t\t\"data\":     {\"5\"},\n\t}\n\n\tvalue, err := info.Generate(f, &m, info)\n\tif err != nil {\n\t\tt.Fatal(err.Error())\n\t}\n\n\t// Check if value is in the expected format. name[space]name\\n\n\treg := `^(\\w+\\s\\w+\\n){5}$`\n\tmatched, err := regexp.MatchString(reg, value.(string))\n\tif err != nil {\n\t\tt.Fatal(err.Error())\n\t}\n\n\tif !matched {\n\t\tt.Errorf(\"expected %s to match %s\", value, reg)\n\t}\n}\n\nfunc TestTemplateInternalFunctions(t *testing.T) {\n\tSeed(11)\n\n\ttype test struct {\n\t\ttemplate string\n\t\texpected string\n\t}\n\n\ttests := []test{\n\t\t// ToInt\n\t\t{\n\t\t\ttemplate: `{{ ToInt 55 }}`,\n\t\t\texpected: \"55\",\n\t\t},\n\n\t\t// ToFloat\n\t\t{\n\t\t\ttemplate: `{{ ToFloat 55.55 }}`,\n\t\t\texpected: \"55.55\",\n\t\t},\n\n\t\t// ToString\n\t\t{\n\t\t\ttemplate: `{{ ToString 3.55 }}`,\n\t\t\texpected: \"3.55\",\n\t\t},\n\t}\n\n\tfor k, v := range tests {\n\t\tvalue, err := Template(v.template, nil)\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tif value != v.expected {\n\t\t\tt.Errorf(\"Test: %v expected `%s`, got `%s`\", k, v.expected, value)\n\t\t}\n\t}\n}\n\nfunc TestTemplateNoOptions(t *testing.T) {\n\tSeed(11)\n\n\t// The above code is declaring a variable named \"value\" in the Go programming language.\n\tvalue, err := Template(\"{{FirstName}} {{LastName}}\", nil)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t// Make sure value has a space in it\n\tif !strings.Contains(value, \" \") {\n\t\tt.Errorf(\"expected a space in %s\", value)\n\t}\n\n}\n\nfunc ExampleEmailText() {\n\tSeed(11)\n\n\tvalue, err := EmailText(&EmailOptions{})\n\tif err != nil {\n\t\tfmt.Println(err)\n\t}\n\n\tfmt.Println(string(value))\n\n\t// Output: Subject: Hi from Russ!\n\t//\n\t// Dear Donnelly,\n\t//\n\t// Greetings! I hope your day is going well.\n\t//\n\t// I trust this email finds you well. Sending good vibes your way.\n\t//\n\t// Galaxy they how shall cut lastly that someone additionally ambulance. Could a tennis occur why depend heels out can fire. Anyone sometimes that leap whom troop now scarcely since dance. Huh somebody constantly Italian outfit certain weekly murder who cackle. Because her break write nobody could according whoa bevy we.\n\t//\n\t// Them summation to oxygen Greek how previously a what answer. Handle daily ouch upon encourage that after his every she. Wearily still he herself huge failure for yay sparse thoughtfully. Box anyway Jungian regularly world great daily recently whose Elizabethan. Outside to theirs block while French closely sit you to.\n\t//\n\t// Out fight bored yours those bale Parisian host which so. Today Ecuadorian hourly decidedly his everybody this play this little. Them on recently eager usually bunch daily whose somebody them. Few tonight dishonesty spell battery less patience whose inside hair. Your answer hand tonight these she team which today Einsteinian.\n\t//\n\t// I'm eager to hear your feedback on it. If you have a moment, please feel free to check out the project on GitLab\n\t//\n\t// Your insights would be invaluable. Your thoughts matter to me.\n\t//\n\t// I appreciate your attention to this matter. Your feedback is greatly appreciated.\n\t//\n\t// Sincerely\n\t// Hyman Rogahn\n\t// mervingottlieb@goldner.com\n\t// 1-275-132-4165\n}\n\nfunc ExampleFaker_EmailText() {\n\tf := New(11)\n\n\tvalue, err := f.EmailText(&EmailOptions{})\n\tif err != nil {\n\t\tfmt.Println(err)\n\t}\n\n\tfmt.Println(string(value))\n\n\t// Output: Subject: Hi from Russ!\n\t//\n\t// Dear Donnelly,\n\t//\n\t// Greetings! I hope your day is going well.\n\t//\n\t// I trust this email finds you well. Sending good vibes your way.\n\t//\n\t// Galaxy they how shall cut lastly that someone additionally ambulance. Could a tennis occur why depend heels out can fire. Anyone sometimes that leap whom troop now scarcely since dance. Huh somebody constantly Italian outfit certain weekly murder who cackle. Because her break write nobody could according whoa bevy we.\n\t//\n\t// Them summation to oxygen Greek how previously a what answer. Handle daily ouch upon encourage that after his every she. Wearily still he herself huge failure for yay sparse thoughtfully. Box anyway Jungian regularly world great daily recently whose Elizabethan. Outside to theirs block while French closely sit you to.\n\t//\n\t// Out fight bored yours those bale Parisian host which so. Today Ecuadorian hourly decidedly his everybody this play this little. Them on recently eager usually bunch daily whose somebody them. Few tonight dishonesty spell battery less patience whose inside hair. Your answer hand tonight these she team which today Einsteinian.\n\t//\n\t// I'm eager to hear your feedback on it. If you have a moment, please feel free to check out the project on GitLab\n\t//\n\t// Your insights would be invaluable. Your thoughts matter to me.\n\t//\n\t// I appreciate your attention to this matter. Your feedback is greatly appreciated.\n\t//\n\t// Sincerely\n\t// Hyman Rogahn\n\t// mervingottlieb@goldner.com\n\t// 1-275-132-4165\n}\n\n// TemplateMarkdown examples and tests\nfunc ExampleMarkdown() {\n\tSeed(11)\n\n\tvalue, err := Markdown(&MarkdownOptions{})\n\tif err != nil {\n\t\tfmt.Println(err)\n\t}\n\n\tfmt.Println(string(value))\n\n\t// Output: # TurkeyThinker\n\t//\n\t// *Author: Tomasa Waters*\n\t//\n\t// Cut lastly that someone additionally ambulance could. A tennis occur why depend heels out. Can fire anyone sometimes that leap whom. Troop now scarcely since dance huh somebody. Constantly Italian outfit certain weekly murder who.\n\t//\n\t// Cackle because her break write nobody could. According whoa bevy we them summation to. Oxygen Greek how previously a what answer. Handle daily ouch upon encourage that after. His every she wearily still he herself.\n\t//\n\t// ## Table of Contents\n\t// - [Installation](#installation)\n\t// - [Usage](#usage)\n\t// - [License](#license)\n\t//\n\t// ## Installation\n\t// '''bash\n\t// pip install TurkeyThinker\n\t// '''\n\t//\n\t// ## Usage\n\t// '''python\n\t// result = turkeythinker.handle(\"whimsical story\")\n\t// print(\"turkeythinker result:\", \"terminated\")\n\t// '''\n\t//\n\t// ## License\n\t// MIT\n}\n\nfunc ExampleFaker_Markdown() {\n\tf := New(11)\n\n\tvalue, err := f.Markdown(&MarkdownOptions{})\n\tif err != nil {\n\t\tfmt.Println(err)\n\t}\n\n\tfmt.Println(string(value))\n\n\t// Output: # TurkeyThinker\n\t//\n\t// *Author: Tomasa Waters*\n\t//\n\t// Cut lastly that someone additionally ambulance could. A tennis occur why depend heels out. Can fire anyone sometimes that leap whom. Troop now scarcely since dance huh somebody. Constantly Italian outfit certain weekly murder who.\n\t//\n\t// Cackle because her break write nobody could. According whoa bevy we them summation to. Oxygen Greek how previously a what answer. Handle daily ouch upon encourage that after. His every she wearily still he herself.\n\t//\n\t// ## Table of Contents\n\t// - [Installation](#installation)\n\t// - [Usage](#usage)\n\t// - [License](#license)\n\t//\n\t// ## Installation\n\t// '''bash\n\t// pip install TurkeyThinker\n\t// '''\n\t//\n\t// ## Usage\n\t// '''python\n\t// result = turkeythinker.handle(\"whimsical story\")\n\t// print(\"turkeythinker result:\", \"terminated\")\n\t// '''\n\t//\n\t// ## License\n\t// MIT\n}\n\nfunc BenchmarkTemplate(b *testing.B) {\n\tf := New(11)\n\n\tfor i := 0; i < b.N; i++ {\n\t\t_, err := f.Template(\"{{range IntRange 1 (ToInt .Data)}}{{FirstName}} {{LastName}}\\n{{end}}\", &TemplateOptions{Data: 5})\n\t\tif err != nil {\n\t\t\tb.Fatal(err.Error())\n\t\t}\n\t}\n}\n"
        },
        {
          "name": "time.go",
          "type": "blob",
          "size": 15.2216796875,
          "content": "package gofakeit\n\nimport (\n\t\"strconv\"\n\t\"strings\"\n\t\"time\"\n)\n\nvar currentYear = time.Now().Year()\n\n// Date will generate a random time.Time struct\nfunc Date() time.Time { return date(GlobalFaker) }\n\n// Date will generate a random time.Time struct\nfunc (f *Faker) Date() time.Time { return date(f) }\n\nfunc date(f *Faker) time.Time {\n\treturn time.Date(year(f), time.Month(month(f)), day(f), hour(f), minute(f), second(f), nanoSecond(f), time.UTC)\n}\n\n// PastDate will generate a random past time.Time struct\nfunc PastDate() time.Time { return pastDate(GlobalFaker) }\n\n// PastDate will generate a random past time.Time struct\nfunc (f *Faker) PastDate() time.Time { return pastDate(f) }\n\nfunc pastDate(f *Faker) time.Time {\n\treturn time.Now().Add(time.Hour * -time.Duration(number(f, 1, 12)))\n}\n\n// FutureDate will generate a random future time.Time struct\nfunc FutureDate() time.Time { return futureDate(GlobalFaker) }\n\n// FutureDate will generate a random future time.Time struct\nfunc (f *Faker) FutureDate() time.Time { return futureDate(f) }\n\nfunc futureDate(f *Faker) time.Time {\n\treturn time.Now().Add(time.Hour * time.Duration(number(f, 1, 12)))\n}\n\n// DateRange will generate a random time.Time struct between a start and end date\nfunc DateRange(start, end time.Time) time.Time { return dateRange(GlobalFaker, start, end) }\n\n// DateRange will generate a random time.Time struct between a start and end date\nfunc (f *Faker) DateRange(start, end time.Time) time.Time { return dateRange(f, start, end) }\n\nfunc dateRange(f *Faker, start time.Time, end time.Time) time.Time {\n\treturn time.Unix(0, int64(number(f, int(start.UnixNano()), int(end.UnixNano())))).UTC()\n}\n\n// NanoSecond will generate a random nano second\nfunc NanoSecond() int { return nanoSecond(GlobalFaker) }\n\n// NanoSecond will generate a random nano second\nfunc (f *Faker) NanoSecond() int { return nanoSecond(f) }\n\nfunc nanoSecond(f *Faker) int { return number(f, 0, 999999999) }\n\n// Second will generate a random second\nfunc Second() int { return second(GlobalFaker) }\n\n// Second will generate a random second\nfunc (f *Faker) Second() int { return second(f) }\n\nfunc second(f *Faker) int { return number(f, 0, 59) }\n\n// Minute will generate a random minute\nfunc Minute() int { return minute(GlobalFaker) }\n\n// Minute will generate a random minute\nfunc (f *Faker) Minute() int { return minute(f) }\n\nfunc minute(f *Faker) int { return number(f, 0, 59) }\n\n// Hour will generate a random hour - in military time\nfunc Hour() int { return hour(GlobalFaker) }\n\n// Hour will generate a random hour - in military time\nfunc (f *Faker) Hour() int { return hour(f) }\n\nfunc hour(f *Faker) int { return number(f, 0, 23) }\n\n// Day will generate a random day between 1 - 31\nfunc Day() int { return day(GlobalFaker) }\n\n// Day will generate a random day between 1 - 31\nfunc (f *Faker) Day() int { return day(f) }\n\nfunc day(f *Faker) int { return number(f, 1, 31) }\n\n// WeekDay will generate a random weekday string (Monday-Sunday)\nfunc WeekDay() string { return weekDay(GlobalFaker) }\n\n// WeekDay will generate a random weekday string (Monday-Sunday)\nfunc (f *Faker) WeekDay() string { return weekDay(f) }\n\nfunc weekDay(f *Faker) string { return time.Weekday(number(f, 0, 6)).String() }\n\n// Month will generate a random month int\nfunc Month() int { return month(GlobalFaker) }\n\n// Month will generate a random month int\nfunc (f *Faker) Month() int { return month(f) }\n\nfunc month(f *Faker) int { return number(f, 1, 12) }\n\n// MonthString will generate a random month string\nfunc MonthString() string { return monthString(GlobalFaker) }\n\n// MonthString will generate a random month string\nfunc (f *Faker) MonthString() string { return monthString(f) }\n\nfunc monthString(f *Faker) string { return time.Month(number(f, 1, 12)).String() }\n\n// Year will generate a random year between 1900 - current year\nfunc Year() int { return year(GlobalFaker) }\n\n// Year will generate a random year between 1900 - current year\nfunc (f *Faker) Year() int { return year(f) }\n\nfunc year(f *Faker) int { return number(f, 1900, currentYear) }\n\n// TimeZone will select a random timezone string\nfunc TimeZone() string { return timeZone(GlobalFaker) }\n\n// TimeZone will select a random timezone string\nfunc (f *Faker) TimeZone() string { return timeZone(f) }\n\nfunc timeZone(f *Faker) string { return getRandValue(f, []string{\"timezone\", \"text\"}) }\n\n// TimeZoneFull will select a random full timezone string\nfunc TimeZoneFull() string { return timeZoneFull(GlobalFaker) }\n\n// TimeZoneFull will select a random full timezone string\nfunc (f *Faker) TimeZoneFull() string { return timeZoneFull(f) }\n\nfunc timeZoneFull(f *Faker) string { return getRandValue(f, []string{\"timezone\", \"full\"}) }\n\n// TimeZoneRegion will select a random region style timezone string, e.g. \"America/Chicago\"\nfunc TimeZoneRegion() string { return timeZoneRegion(GlobalFaker) }\n\n// TimeZoneRegion will select a random region style timezone string, e.g. \"America/Chicago\"\nfunc (f *Faker) TimeZoneRegion() string { return timeZoneRegion(f) }\n\nfunc timeZoneRegion(f *Faker) string { return getRandValue(f, []string{\"timezone\", \"region\"}) }\n\n// TimeZoneAbv will select a random timezone abbreviation string\nfunc TimeZoneAbv() string { return timeZoneAbv(GlobalFaker) }\n\n// TimeZoneAbv will select a random timezone abbreviation string\nfunc (f *Faker) TimeZoneAbv() string { return timeZoneAbv(f) }\n\nfunc timeZoneAbv(f *Faker) string { return getRandValue(f, []string{\"timezone\", \"abr\"}) }\n\n// TimeZoneOffset will select a random timezone offset\nfunc TimeZoneOffset() float32 { return timeZoneOffset(GlobalFaker) }\n\n// TimeZoneOffset will select a random timezone offset\nfunc (f *Faker) TimeZoneOffset() float32 { return timeZoneOffset(f) }\n\nfunc timeZoneOffset(f *Faker) float32 {\n\tvalue, _ := strconv.ParseFloat(getRandValue(f, []string{\"timezone\", \"offset\"}), 32)\n\treturn float32(value)\n}\n\n// javaDateFormatToGolangDateFormat converts java date format into go date format\nfunc javaDateFormatToGolangDateFormat(format string) string {\n\tformat = strings.Replace(format, \"ddd\", \"_2\", -1)\n\tformat = strings.Replace(format, \"dd\", \"02\", -1)\n\tformat = strings.Replace(format, \"d\", \"2\", -1)\n\n\tformat = strings.Replace(format, \"HH\", \"15\", -1)\n\n\tformat = strings.Replace(format, \"hh\", \"03\", -1)\n\tformat = strings.Replace(format, \"h\", \"3\", -1)\n\n\tformat = strings.Replace(format, \"mm\", \"04\", -1)\n\tformat = strings.Replace(format, \"m\", \"4\", -1)\n\n\tformat = strings.Replace(format, \"ss\", \"05\", -1)\n\tformat = strings.Replace(format, \"s\", \"5\", -1)\n\n\tformat = strings.Replace(format, \"yyyy\", \"2006\", -1)\n\tformat = strings.Replace(format, \"yy\", \"06\", -1)\n\tformat = strings.Replace(format, \"y\", \"06\", -1)\n\n\tformat = strings.Replace(format, \"SSS\", \"000\", -1)\n\n\tformat = strings.Replace(format, \"a\", \"pm\", -1)\n\tformat = strings.Replace(format, \"aa\", \"PM\", -1)\n\n\tformat = strings.Replace(format, \"MMMM\", \"January\", -1)\n\tformat = strings.Replace(format, \"MMM\", \"Jan\", -1)\n\tformat = strings.Replace(format, \"MM\", \"01\", -1)\n\tformat = strings.Replace(format, \"M\", \"1\", -1)\n\n\tformat = strings.Replace(format, \"ZZ\", \"-0700\", -1)\n\n\tif !strings.Contains(format, \"Z07\") {\n\t\tformat = strings.Replace(format, \"Z\", \"-07\", -1)\n\t}\n\n\tformat = strings.Replace(format, \"zz:zz\", \"Z07:00\", -1)\n\tformat = strings.Replace(format, \"zzzz\", \"Z0700\", -1)\n\tformat = strings.Replace(format, \"z\", \"MST\", -1)\n\n\tformat = strings.Replace(format, \"EEEE\", \"Monday\", -1)\n\tformat = strings.Replace(format, \"E\", \"Mon\", -1)\n\n\treturn format\n}\n\nfunc addDateTimeLookup() {\n\tAddFuncLookup(\"date\", Info{\n\t\tDisplay:     \"Date\",\n\t\tCategory:    \"time\",\n\t\tDescription: \"Representation of a specific day, month, and year, often used for chronological reference\",\n\t\tExample:     \"2006-01-02T15:04:05Z07:00\",\n\t\tOutput:      \"string\",\n\t\tParams: []Param{\n\t\t\t{\n\t\t\t\tField:       \"format\",\n\t\t\t\tDisplay:     \"Format\",\n\t\t\t\tType:        \"string\",\n\t\t\t\tDefault:     \"RFC3339\",\n\t\t\t\tOptions:     []string{\"ANSIC\", \"UnixDate\", \"RubyDate\", \"RFC822\", \"RFC822Z\", \"RFC850\", \"RFC1123\", \"RFC1123Z\", \"RFC3339\", \"RFC3339Nano\"},\n\t\t\t\tDescription: \"Date time string format output. You may also use golang time format or java time format\",\n\t\t\t},\n\t\t},\n\t\tGenerate: func(f *Faker, m *MapParams, info *Info) (any, error) {\n\t\t\tformat, err := info.GetString(m, \"format\")\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\n\t\t\tswitch format {\n\t\t\tcase \"ANSIC\":\n\t\t\t\treturn f.Date().Format(time.ANSIC), nil\n\t\t\tcase \"UnixDate\":\n\t\t\t\treturn f.Date().Format(time.UnixDate), nil\n\t\t\tcase \"RubyDate\":\n\t\t\t\treturn f.Date().Format(time.RubyDate), nil\n\t\t\tcase \"RFC822\":\n\t\t\t\treturn f.Date().Format(time.RFC822), nil\n\t\t\tcase \"RFC822Z\":\n\t\t\t\treturn f.Date().Format(time.RFC822Z), nil\n\t\t\tcase \"RFC850\":\n\t\t\t\treturn f.Date().Format(time.RFC850), nil\n\t\t\tcase \"RFC1123\":\n\t\t\t\treturn f.Date().Format(time.RFC1123), nil\n\t\t\tcase \"RFC1123Z\":\n\t\t\t\treturn f.Date().Format(time.RFC1123Z), nil\n\t\t\tcase \"RFC3339\":\n\t\t\t\treturn f.Date().Format(time.RFC3339), nil\n\t\t\tcase \"RFC3339Nano\":\n\t\t\t\treturn f.Date().Format(time.RFC3339Nano), nil\n\t\t\tdefault:\n\t\t\t\tif format == \"\" {\n\t\t\t\t\treturn f.Date().Format(time.RFC3339), nil\n\t\t\t\t}\n\n\t\t\t\treturn f.Date().Format(javaDateFormatToGolangDateFormat(format)), nil\n\t\t\t}\n\t\t},\n\t})\n\n\tAddFuncLookup(\"daterange\", Info{\n\t\tDisplay:     \"DateRange\",\n\t\tCategory:    \"time\",\n\t\tDescription: \"Random date between two ranges\",\n\t\tExample:     \"2006-01-02T15:04:05Z07:00\",\n\t\tOutput:      \"string\",\n\t\tParams: []Param{\n\t\t\t{\n\t\t\t\tField:       \"startdate\",\n\t\t\t\tDisplay:     \"Start Date\",\n\t\t\t\tType:        \"string\",\n\t\t\t\tDefault:     \"1970-01-01\",\n\t\t\t\tDescription: \"Start date time string\",\n\t\t\t},\n\t\t\t{\n\t\t\t\tField:       \"enddate\",\n\t\t\t\tDisplay:     \"End Date\",\n\t\t\t\tType:        \"string\",\n\t\t\t\tDefault:     time.Now().Format(\"2006-01-02\"),\n\t\t\t\tDescription: \"End date time string\",\n\t\t\t},\n\t\t\t{\n\t\t\t\tField:       \"format\",\n\t\t\t\tDisplay:     \"Format\",\n\t\t\t\tType:        \"string\",\n\t\t\t\tDefault:     \"yyyy-MM-dd\",\n\t\t\t\tDescription: \"Date time string format\",\n\t\t\t},\n\t\t},\n\t\tGenerate: func(f *Faker, m *MapParams, info *Info) (any, error) {\n\t\t\tformat, err := info.GetString(m, \"format\")\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\tformat = javaDateFormatToGolangDateFormat(format)\n\n\t\t\tstartdate, err := info.GetString(m, \"startdate\")\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\tstartDateTime, err := time.Parse(format, startdate)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\n\t\t\tenddate, err := info.GetString(m, \"enddate\")\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\tendDateTime, err := time.Parse(format, enddate)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\n\t\t\treturn DateRange(startDateTime, endDateTime).Format(format), nil\n\t\t},\n\t})\n\n\tAddFuncLookup(\"pastdate\", Info{\n\t\tDisplay:     \"PastDate\",\n\t\tCategory:    \"time\",\n\t\tDescription: \"Date that has occurred before the current moment in time\",\n\t\tExample:     \"2007-01-24 13:00:35.820738079 +0000 UTC\",\n\t\tOutput:      \"time\",\n\t\tGenerate: func(f *Faker, m *MapParams, info *Info) (any, error) {\n\t\t\treturn pastDate(f), nil\n\t\t},\n\t})\n\n\tAddFuncLookup(\"futuredate\", Info{\n\t\tDisplay:     \"FutureDate\",\n\t\tCategory:    \"time\",\n\t\tDescription: \"Date that has occurred after the current moment in time\",\n\t\tExample:     \"2107-01-24 13:00:35.820738079 +0000 UTC\",\n\t\tOutput:      \"time\",\n\t\tGenerate: func(f *Faker, m *MapParams, info *Info) (any, error) {\n\t\t\treturn futureDate(f), nil\n\t\t},\n\t})\n\n\tAddFuncLookup(\"nanosecond\", Info{\n\t\tDisplay:     \"Nanosecond\",\n\t\tCategory:    \"time\",\n\t\tDescription: \"Unit of time equal to One billionth (10^-9) of a second\",\n\t\tExample:     \"196446360\",\n\t\tOutput:      \"int\",\n\t\tGenerate: func(f *Faker, m *MapParams, info *Info) (any, error) {\n\t\t\treturn nanoSecond(f), nil\n\t\t},\n\t})\n\n\tAddFuncLookup(\"second\", Info{\n\t\tDisplay:     \"Second\",\n\t\tCategory:    \"time\",\n\t\tDescription: \"Unit of time equal to 1/60th of a minute\",\n\t\tExample:     \"43\",\n\t\tOutput:      \"int\",\n\t\tGenerate: func(f *Faker, m *MapParams, info *Info) (any, error) {\n\t\t\treturn second(f), nil\n\t\t},\n\t})\n\n\tAddFuncLookup(\"minute\", Info{\n\t\tDisplay:     \"Minute\",\n\t\tCategory:    \"time\",\n\t\tDescription: \"Unit of time equal to 60 seconds\",\n\t\tExample:     \"34\",\n\t\tOutput:      \"int\",\n\t\tGenerate: func(f *Faker, m *MapParams, info *Info) (any, error) {\n\t\t\treturn minute(f), nil\n\t\t},\n\t})\n\n\tAddFuncLookup(\"hour\", Info{\n\t\tDisplay:     \"Hour\",\n\t\tCategory:    \"time\",\n\t\tDescription: \"Unit of time equal to 60 minutes\",\n\t\tExample:     \"8\",\n\t\tOutput:      \"int\",\n\t\tGenerate: func(f *Faker, m *MapParams, info *Info) (any, error) {\n\t\t\treturn hour(f), nil\n\t\t},\n\t})\n\n\tAddFuncLookup(\"day\", Info{\n\t\tDisplay:     \"Day\",\n\t\tCategory:    \"time\",\n\t\tDescription: \"24-hour period equivalent to one rotation of Earth on its axis\",\n\t\tExample:     \"12\",\n\t\tOutput:      \"int\",\n\t\tGenerate: func(f *Faker, m *MapParams, info *Info) (any, error) {\n\t\t\treturn day(f), nil\n\t\t},\n\t})\n\n\tAddFuncLookup(\"weekday\", Info{\n\t\tDisplay:     \"Weekday\",\n\t\tCategory:    \"time\",\n\t\tDescription: \"Day of the week excluding the weekend\",\n\t\tExample:     \"Friday\",\n\t\tOutput:      \"string\",\n\t\tGenerate: func(f *Faker, m *MapParams, info *Info) (any, error) {\n\t\t\treturn weekDay(f), nil\n\t\t},\n\t})\n\n\tAddFuncLookup(\"month\", Info{\n\t\tDisplay:     \"Month\",\n\t\tCategory:    \"time\",\n\t\tDescription: \"Division of the year, typically 30 or 31 days long\",\n\t\tExample:     \"1\",\n\t\tOutput:      \"string\",\n\t\tGenerate: func(f *Faker, m *MapParams, info *Info) (any, error) {\n\t\t\treturn month(f), nil\n\t\t},\n\t})\n\n\tAddFuncLookup(\"monthstring\", Info{\n\t\tDisplay:     \"Month String\",\n\t\tCategory:    \"time\",\n\t\tDescription: \"String Representation of a month name\",\n\t\tExample:     \"September\",\n\t\tOutput:      \"string\",\n\t\tGenerate: func(f *Faker, m *MapParams, info *Info) (any, error) {\n\t\t\treturn monthString(f), nil\n\t\t},\n\t})\n\n\tAddFuncLookup(\"year\", Info{\n\t\tDisplay:     \"Year\",\n\t\tCategory:    \"time\",\n\t\tDescription: \"Period of 365 days, the time Earth takes to orbit the Sun\",\n\t\tExample:     \"1900\",\n\t\tOutput:      \"int\",\n\t\tGenerate: func(f *Faker, m *MapParams, info *Info) (any, error) {\n\t\t\treturn year(f), nil\n\t\t},\n\t})\n\n\tAddFuncLookup(\"timezone\", Info{\n\t\tDisplay:     \"Timezone\",\n\t\tCategory:    \"time\",\n\t\tDescription: \"Region where the same standard time is used, based on longitudinal divisions of the Earth\",\n\t\tExample:     \"Kaliningrad Standard Time\",\n\t\tOutput:      \"string\",\n\t\tGenerate: func(f *Faker, m *MapParams, info *Info) (any, error) {\n\t\t\treturn timeZone(f), nil\n\t\t},\n\t})\n\n\tAddFuncLookup(\"timezoneabv\", Info{\n\t\tDisplay:     \"Timezone Abbreviation\",\n\t\tCategory:    \"time\",\n\t\tDescription: \"Abbreviated 3-letter word of a timezone\",\n\t\tExample:     \"KST\",\n\t\tOutput:      \"string\",\n\t\tGenerate: func(f *Faker, m *MapParams, info *Info) (any, error) {\n\t\t\treturn timeZoneAbv(f), nil\n\t\t},\n\t})\n\n\tAddFuncLookup(\"timezonefull\", Info{\n\t\tDisplay:     \"Timezone Full\",\n\t\tCategory:    \"time\",\n\t\tDescription: \"Full name of a timezone\",\n\t\tExample:     \"(UTC+03:00) Kaliningrad, Minsk\",\n\t\tOutput:      \"string\",\n\t\tGenerate: func(f *Faker, m *MapParams, info *Info) (any, error) {\n\t\t\treturn timeZoneFull(f), nil\n\t\t},\n\t})\n\n\tAddFuncLookup(\"timezoneoffset\", Info{\n\t\tDisplay:     \"Timezone Offset\",\n\t\tCategory:    \"time\",\n\t\tDescription: \"The difference in hours from Coordinated Universal Time (UTC) for a specific region\",\n\t\tExample:     \"3\",\n\t\tOutput:      \"float32\",\n\t\tGenerate: func(f *Faker, m *MapParams, info *Info) (any, error) {\n\t\t\treturn timeZoneOffset(f), nil\n\t\t},\n\t})\n\n\tAddFuncLookup(\"timezoneregion\", Info{\n\t\tDisplay:     \"Timezone Region\",\n\t\tCategory:    \"time\",\n\t\tDescription: \"Geographic area sharing the same standard time\",\n\t\tExample:     \"America/Alaska\",\n\t\tOutput:      \"string\",\n\t\tGenerate: func(f *Faker, m *MapParams, info *Info) (any, error) {\n\t\t\treturn timeZoneRegion(f), nil\n\t\t},\n\t})\n\n}\n"
        },
        {
          "name": "time_test.go",
          "type": "blob",
          "size": 5.666015625,
          "content": "package gofakeit\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n\t\"time\"\n)\n\nfunc ExampleDate() {\n\tSeed(11)\n\tfmt.Println(Date())\n\n\t// Output: 2011-11-07 04:31:13.726582492 +0000 UTC\n}\n\nfunc ExampleFaker_Date() {\n\tf := New(11)\n\tfmt.Println(f.Date())\n\n\t// Output: 2011-11-07 04:31:13.726582492 +0000 UTC\n}\n\nfunc TestDateLookup(t *testing.T) {\n\tinfo := GetFuncLookup(\"date\")\n\tfor _, o := range info.Params[0].Options {\n\t\tmapParams := NewMapParams()\n\t\tmapParams.Add(\"format\", o)\n\t\tval, _ := info.Generate(GlobalFaker, mapParams, info)\n\t\tif val == \"\" {\n\t\t\tt.Error(\"value was empty\")\n\t\t}\n\t}\n}\n\nfunc BenchmarkDate(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tDate()\n\t}\n}\n\nfunc ExamplePastDate() {\n\tSeed(11)\n\tfmt.Println(PastDate())\n}\n\nfunc ExampleFaker_PastDate() {\n\tf := New(11)\n\tfmt.Println(f.PastDate())\n}\n\nfunc TestPastDate(t *testing.T) {\n\tnow := time.Now()\n\tpastDate := PastDate()\n\tif now.Before(pastDate) {\n\t\tt.Error(\"Expected time from past, got: \", pastDate)\n\t}\n}\n\nfunc BenchmarkPastDate(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tPastDate()\n\t}\n}\n\nfunc ExampleFutureDate() {\n\tSeed(11)\n\tfmt.Println(FutureDate())\n}\n\nfunc ExampleFaker_FutureDate() {\n\tf := New(11)\n\tfmt.Println(f.FutureDate())\n}\n\nfunc TestFutureDate(t *testing.T) {\n\tnow := time.Now()\n\tfutureDate := FutureDate()\n\tif now.After(futureDate) {\n\t\tt.Error(\"Expected time from future, got: \", futureDate)\n\t}\n}\n\nfunc BenchmarkFutureDate(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tFutureDate()\n\t}\n}\n\nfunc ExampleDateRange() {\n\tSeed(11)\n\tfmt.Println(DateRange(time.Unix(0, 484633944473634951), time.Unix(0, 1431318744473668209))) // May 10, 1985 years to May 10, 2015\n\t// Output: 2012-03-26 09:20:49.250961474 +0000 UTC\n}\n\nfunc ExampleFaker_DateRange() {\n\tf := New(11)\n\tfmt.Println(f.DateRange(time.Unix(0, 484633944473634951), time.Unix(0, 1431318744473668209))) // May 10, 1985 years to May 10, 2015\n\t// Output: 2012-03-26 09:20:49.250961474 +0000 UTC\n}\n\nfunc BenchmarkDateRange(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tDateRange(time.Now().AddDate(-30, 0, 0), time.Now())\n\t}\n}\n\nfunc ExampleMonth() {\n\tSeed(11)\n\tfmt.Println(Month())\n\n\t// Output: 11\n}\n\nfunc ExampleFaker_Month() {\n\tf := New(11)\n\tfmt.Println(f.Month())\n\n\t// Output: 11\n}\n\nfunc BenchmarkMonth(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tMonth()\n\t}\n}\n\nfunc ExampleMonthString() {\n\tSeed(11)\n\tfmt.Println(MonthString())\n\n\t// Output: November\n}\n\nfunc ExampleFaker_MonthString() {\n\tf := New(11)\n\tfmt.Println(f.MonthString())\n\n\t// Output: November\n}\n\nfunc BenchmarkMonthString(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tMonthString()\n\t}\n}\n\nfunc ExampleWeekDay() {\n\tSeed(11)\n\tfmt.Println(WeekDay())\n\n\t// Output: Saturday\n}\n\nfunc ExampleFaker_WeekDay() {\n\tf := New(11)\n\tfmt.Println(f.WeekDay())\n\n\t// Output: Saturday\n}\n\nfunc BenchmarkWeekDay(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tWeekDay()\n\t}\n}\n\nfunc ExampleDay() {\n\tSeed(11)\n\tfmt.Println(Day())\n\n\t// Output: 28\n}\n\nfunc ExampleFaker_Day() {\n\tf := New(11)\n\tfmt.Println(f.Day())\n\n\t// Output: 28\n}\n\nfunc BenchmarkDay(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tDay()\n\t}\n}\n\nfunc ExampleYear() {\n\tSeed(11)\n\tfmt.Println(Year())\n\n\t// Output: 2011\n}\n\nfunc ExampleFaker_Year() {\n\tf := New(11)\n\tfmt.Println(f.Year())\n\n\t// Output: 2011\n}\n\nfunc BenchmarkYear(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tYear()\n\t}\n}\n\nfunc ExampleHour() {\n\tSeed(11)\n\tfmt.Println(Hour())\n\n\t// Output: 21\n}\n\nfunc ExampleFaker_Hour() {\n\tf := New(11)\n\tfmt.Println(f.Hour())\n\n\t// Output: 21\n}\n\nfunc BenchmarkHour(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tHour()\n\t}\n}\n\nfunc ExampleMinute() {\n\tSeed(11)\n\tfmt.Println(Minute())\n\n\t// Output: 53\n}\n\nfunc ExampleFaker_Minute() {\n\tf := New(11)\n\tfmt.Println(f.Minute())\n\n\t// Output: 53\n}\n\nfunc BenchmarkMinute(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tMinute()\n\t}\n}\n\nfunc ExampleSecond() {\n\tSeed(11)\n\tfmt.Println(Second())\n\n\t// Output: 53\n}\n\nfunc ExampleFaker_Second() {\n\tf := New(11)\n\tfmt.Println(f.Second())\n\n\t// Output: 53\n}\n\nfunc BenchmarkSecond(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tSecond()\n\t}\n}\n\nfunc ExampleNanoSecond() {\n\tSeed(11)\n\tfmt.Println(NanoSecond())\n\n\t// Output: 895883936\n}\n\nfunc ExampleFaker_NanoSecond() {\n\tf := New(11)\n\tfmt.Println(f.NanoSecond())\n\n\t// Output: 895883936\n}\n\nfunc BenchmarkNanoSecond(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tNanoSecond()\n\t}\n}\n\nfunc ExampleTimeZone() {\n\tSeed(11)\n\tfmt.Println(TimeZone())\n\n\t// Output: West Pacific Standard Time\n}\n\nfunc ExampleFaker_TimeZone() {\n\tf := New(11)\n\tfmt.Println(f.TimeZone())\n\n\t// Output: West Pacific Standard Time\n}\n\nfunc BenchmarkTimeZone(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tTimeZone()\n\t}\n}\n\nfunc ExampleTimeZoneFull() {\n\tSeed(11)\n\tfmt.Println(TimeZoneFull())\n\n\t// Output: (UTC+10:00) Guam, Port Moresby\n}\n\nfunc ExampleFaker_TimeZoneFull() {\n\tf := New(11)\n\tfmt.Println(f.TimeZoneFull())\n\n\t// Output: (UTC+10:00) Guam, Port Moresby\n}\n\nfunc BenchmarkTimeZoneFull(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tTimeZoneFull()\n\t}\n}\n\nfunc ExampleTimeZoneAbv() {\n\tSeed(11)\n\tfmt.Println(TimeZoneAbv())\n\n\t// Output: WPST\n}\n\nfunc ExampleFaker_TimeZoneAbv() {\n\tf := New(11)\n\tfmt.Println(f.TimeZoneAbv())\n\n\t// Output: WPST\n}\n\nfunc BenchmarkTimeZoneAbv(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tTimeZoneAbv()\n\t}\n}\n\nfunc ExampleTimeZoneOffset() {\n\tSeed(11)\n\tfmt.Println(TimeZoneOffset())\n\n\t// Output: 10\n}\n\nfunc ExampleFaker_TimeZoneOffset() {\n\tf := New(11)\n\tfmt.Println(f.TimeZoneOffset())\n\n\t// Output: 10\n}\n\nfunc BenchmarkTimeZoneOffset(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tTimeZoneOffset()\n\t}\n}\n\nfunc ExampleTimeZoneRegion() {\n\tSeed(11)\n\tfmt.Println(TimeZoneRegion())\n\n\t// Output: Indian/Chagos\n}\n\nfunc ExampleFaker_TimeZoneRegion() {\n\tf := New(11)\n\tfmt.Println(f.TimeZoneRegion())\n\n\t// Output: Indian/Chagos\n}\n\nfunc BenchmarkTimeZoneRegion(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tTimeZoneRegion()\n\t}\n}\n"
        },
        {
          "name": "weighted.go",
          "type": "blob",
          "size": 2.7197265625,
          "content": "package gofakeit\n\nimport (\n\t\"errors\"\n)\n\n// Weighted will take in an array of options and weights and return a random selection based upon its indexed weight\nfunc Weighted(options []any, weights []float32) (any, error) {\n\treturn weighted(GlobalFaker, options, weights)\n}\n\n// Weighted will take in an array of options and weights and return a random selection based upon its indexed weight\nfunc (f *Faker) Weighted(options []any, weights []float32) (any, error) {\n\treturn weighted(f, options, weights)\n}\n\n// Weighted will take in an array of options and weights and return a random selection based upon its indexed weight\nfunc weighted(f *Faker, options []any, weights []float32) (any, error) {\n\tol := len(options)\n\twl := len(weights)\n\n\t// If options length is 1 just return it back\n\tif ol == 1 {\n\t\treturn options[0], nil\n\t}\n\n\t// Make sure they are passing in options\n\tif ol == 0 {\n\t\treturn nil, errors.New(\"didnt pass options\")\n\t}\n\n\t// Make sure they are passing in weights\n\tif wl == 0 {\n\t\treturn nil, errors.New(\"didnt pass weights\")\n\t}\n\n\t// Make sure they are passing in the same length\n\tif ol != wl {\n\t\treturn nil, errors.New(\"options and weights need to be the same length\")\n\t}\n\n\t// Compute the discrete cumulative density from the sum of the weights\n\tcdf := make([]float32, wl)\n\tvar sumOfWeights float32 = 0.0\n\tfor i, weight := range weights {\n\t\tif i > 0 {\n\t\t\tcdf[i] = cdf[i-1] + weight\n\t\t\tsumOfWeights += weight\n\t\t\tcontinue\n\t\t}\n\n\t\tcdf[i] = weight\n\t\tsumOfWeights += weight\n\t}\n\n\t// Get rand value from a multple of sumOfWeights\n\trandSumOfWeights := f.Float32() * sumOfWeights\n\n\tvar l int = 0\n\tvar h int = wl - 1\n\tfor l <= h {\n\t\tm := l + (h-l)/2\n\t\tif randSumOfWeights <= cdf[m] {\n\t\t\tif m == 0 || (m > 0 && randSumOfWeights > cdf[m-1]) {\n\t\t\t\treturn options[m], nil\n\t\t\t}\n\t\t\th = m - 1\n\t\t} else {\n\t\t\tl = m + 1\n\t\t}\n\t}\n\n\treturn nil, errors.New(\"end of function\")\n}\n\nfunc addWeightedLookup() {\n\tAddFuncLookup(\"weighted\", Info{\n\t\tDisplay:     \"Weighted\",\n\t\tCategory:    \"misc\",\n\t\tDescription: \"Randomly select a given option based upon an equal amount of weights\",\n\t\tExample:     \"[hello, 2, 6.9],[1, 2, 3] => 6.9\",\n\t\tOutput:      \"any\",\n\t\tParams: []Param{\n\t\t\t{Field: \"options\", Display: \"Options\", Type: \"[]string\", Description: \"Array of any values\"},\n\t\t\t{Field: \"weights\", Display: \"Weights\", Type: \"[]float\", Description: \"Array of weights\"},\n\t\t},\n\t\tGenerate: func(f *Faker, m *MapParams, info *Info) (any, error) {\n\t\t\toptions, err := info.GetStringArray(m, \"options\")\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\n\t\t\tweights, err := info.GetFloat32Array(m, \"weights\")\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\n\t\t\toptionsInterface := make([]any, len(options))\n\t\t\tfor i, o := range options {\n\t\t\t\toptionsInterface[i] = o\n\t\t\t}\n\n\t\t\treturn weighted(f, optionsInterface, weights)\n\t\t},\n\t})\n}\n"
        },
        {
          "name": "weighted_test.go",
          "type": "blob",
          "size": 1.5576171875,
          "content": "package gofakeit\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc ExampleWeighted() {\n\tSeed(11)\n\n\toptions := []any{\"hello\", 2, 6.9}\n\tweights := []float32{1, 2, 3}\n\toption, _ := Weighted(options, weights)\n\n\tfmt.Println(option)\n\n\t// Output: 2\n}\n\nfunc TestWeighted(t *testing.T) {\n\tpercOfValue := func(options []any, option any) float32 {\n\t\tvar count float32 = 0\n\t\tfor _, o := range options {\n\t\t\tif option == o {\n\t\t\t\tcount++\n\t\t\t}\n\t\t}\n\n\t\treturn (count / float32(len(options))) * 100\n\t}\n\n\tSeed(11)\n\toptions := []any{\"hello\", 2, 6.9}\n\tweights := []float32{1, 2, 3}\n\n\tfoundOptions := []any{}\n\tfor i := 0; i < 100000; i++ {\n\t\to, _ := Weighted(options, weights)\n\t\tfoundOptions = append(foundOptions, o)\n\t}\n\n\tperc := percOfValue(foundOptions, \"hello\")\n\tif perc < 14 || perc > 18 {\n\t\tt.Error(\"hello was not in the bounds of expected range\")\n\t}\n\tperc = percOfValue(foundOptions, 2)\n\tif perc < 30 || perc > 35 {\n\t\tt.Error(\"2 was not in the bounds of expected range\")\n\t}\n\tperc = percOfValue(foundOptions, 6.9)\n\tif perc < 48 || perc > 52 {\n\t\tt.Error(\"6.9 was not in the bounds of expected range\")\n\t}\n}\n\nfunc TestWeightedStruct(t *testing.T) {\n\ttype weighted struct {\n\t\tS string `fake:\"{weighted:[hello, 2, 6.9],[1, 2, 3]}\"`\n\t}\n\n\tSeed(11)\n\n\tvar weight weighted\n\tStruct(&weight)\n\n\t// Make sure it is one of the options\n\tif weight.S != \"hello\" && weight.S != \"2\" && weight.S != \"6.9\" {\n\t\tt.Error(\"Weighted did not return one of the options\")\n\t}\n}\n\nfunc BenchmarkWeighted(b *testing.B) {\n\toptions := []any{\"hello\", 2, 6.9}\n\tweights := []float32{1, 2, 3}\n\n\tSeed(11)\n\tfor i := 0; i < b.N; i++ {\n\t\tWeighted(options, weights)\n\t}\n}\n"
        },
        {
          "name": "word_adjective.go",
          "type": "blob",
          "size": 6.0546875,
          "content": "package gofakeit\n\n// Adjective will generate a random adjective\nfunc Adjective() string { return adjective(GlobalFaker) }\n\n// Adjective will generate a random adjective\nfunc (f *Faker) Adjective() string { return adjective(f) }\n\nfunc adjective(f *Faker) string {\n\tvar adjType = map[int]string{\n\t\t0: \"adjective_descriptive\",\n\t\t1: \"adjective_quantitative\",\n\t\t2: \"adjective_proper\",\n\t\t3: \"adjective_demonstrative\",\n\t\t4: \"adjective_possessive\",\n\t\t5: \"adjective_interrogative\",\n\t\t6: \"adjective_indefinite\",\n\t}\n\treturn getRandValue(f, []string{\"word\", adjType[number(f, 0, 6)]})\n}\n\n// AdjectiveDescriptive will generate a random descriptive adjective\nfunc AdjectiveDescriptive() string { return adjectiveDescriptive(GlobalFaker) }\n\n// AdjectiveDescriptive will generate a random descriptive adjective\nfunc (f *Faker) AdjectiveDescriptive() string { return adjectiveDescriptive(f) }\n\nfunc adjectiveDescriptive(f *Faker) string {\n\treturn getRandValue(f, []string{\"word\", \"adjective_descriptive\"})\n}\n\n// AdjectiveQuantitative will generate a random quantitative adjective\nfunc AdjectiveQuantitative() string { return adjectiveQuantitative(GlobalFaker) }\n\n// AdjectiveQuantitative will generate a random quantitative adjective\nfunc (f *Faker) AdjectiveQuantitative() string { return adjectiveQuantitative(f) }\n\nfunc adjectiveQuantitative(f *Faker) string {\n\treturn getRandValue(f, []string{\"word\", \"adjective_quantitative\"})\n}\n\n// AdjectiveProper will generate a random proper adjective\nfunc AdjectiveProper() string { return adjectiveProper(GlobalFaker) }\n\n// AdjectiveProper will generate a random proper adjective\nfunc (f *Faker) AdjectiveProper() string { return adjectiveProper(f) }\n\nfunc adjectiveProper(f *Faker) string {\n\treturn getRandValue(f, []string{\"word\", \"adjective_proper\"})\n}\n\n// AdjectiveDemonstrative will generate a random demonstrative adjective\nfunc AdjectiveDemonstrative() string { return adjectiveDemonstrative(GlobalFaker) }\n\n// AdjectiveDemonstrative will generate a random demonstrative adjective\nfunc (f *Faker) AdjectiveDemonstrative() string { return adjectiveDemonstrative(f) }\n\nfunc adjectiveDemonstrative(f *Faker) string {\n\treturn getRandValue(f, []string{\"word\", \"adjective_demonstrative\"})\n}\n\n// AdjectivePossessive will generate a random possessive adjective\nfunc AdjectivePossessive() string { return adjectivePossessive(GlobalFaker) }\n\n// AdjectivePossessive will generate a random possessive adjective\nfunc (f *Faker) AdjectivePossessive() string { return adjectivePossessive(f) }\n\nfunc adjectivePossessive(f *Faker) string {\n\treturn getRandValue(f, []string{\"word\", \"adjective_possessive\"})\n}\n\n// AdjectiveInterrogative will generate a random interrogative adjective\nfunc AdjectiveInterrogative() string { return adjectiveInterrogative(GlobalFaker) }\n\n// AdjectiveInterrogative will generate a random interrogative adjective\nfunc (f *Faker) AdjectiveInterrogative() string { return adjectiveInterrogative(f) }\n\nfunc adjectiveInterrogative(f *Faker) string {\n\treturn getRandValue(f, []string{\"word\", \"adjective_interrogative\"})\n}\n\n// AdjectiveIndefinite will generate a random indefinite adjective\nfunc AdjectiveIndefinite() string { return adjectiveIndefinite(GlobalFaker) }\n\n// AdjectiveIndefinite will generate a random indefinite adjective\nfunc (f *Faker) AdjectiveIndefinite() string { return adjectiveIndefinite(f) }\n\nfunc adjectiveIndefinite(f *Faker) string {\n\treturn getRandValue(f, []string{\"word\", \"adjective_indefinite\"})\n}\n\nfunc addWordAdjectiveLookup() {\n\tAddFuncLookup(\"adjective\", Info{\n\t\tDisplay:     \"Adjective\",\n\t\tCategory:    \"word\",\n\t\tDescription: \"Word describing or modifying a noun\",\n\t\tExample:     \"genuine\",\n\t\tOutput:      \"string\",\n\t\tGenerate: func(f *Faker, m *MapParams, info *Info) (any, error) {\n\t\t\treturn adjective(f), nil\n\t\t},\n\t})\n\n\tAddFuncLookup(\"adjectivedescriptive\", Info{\n\t\tDisplay:     \"Descriptive Adjective\",\n\t\tCategory:    \"word\",\n\t\tDescription: \"Adjective that provides detailed characteristics about a noun\",\n\t\tExample:     \"brave\",\n\t\tOutput:      \"string\",\n\t\tGenerate: func(f *Faker, m *MapParams, info *Info) (any, error) {\n\t\t\treturn adjectiveDescriptive(f), nil\n\t\t},\n\t})\n\n\tAddFuncLookup(\"adjectivequantitative\", Info{\n\t\tDisplay:     \"Quantitative Adjective\",\n\t\tCategory:    \"word\",\n\t\tDescription: \"Adjective that indicates the quantity or amount of something\",\n\t\tExample:     \"a little\",\n\t\tOutput:      \"string\",\n\t\tGenerate: func(f *Faker, m *MapParams, info *Info) (any, error) {\n\t\t\treturn adjectiveQuantitative(f), nil\n\t\t},\n\t})\n\n\tAddFuncLookup(\"adjectiveproper\", Info{\n\t\tDisplay:     \"Proper Adjective\",\n\t\tCategory:    \"word\",\n\t\tDescription: \"Adjective derived from a proper noun, often used to describe nationality or origin\",\n\t\tExample:     \"Afghan\",\n\t\tOutput:      \"string\",\n\t\tGenerate: func(f *Faker, m *MapParams, info *Info) (any, error) {\n\t\t\treturn adjectiveProper(f), nil\n\t\t},\n\t})\n\n\tAddFuncLookup(\"adjectivedemonstrative\", Info{\n\t\tDisplay:     \"Demonstrative Adjective\",\n\t\tCategory:    \"word\",\n\t\tDescription: \"Adjective used to point out specific things\",\n\t\tExample:     \"this\",\n\t\tOutput:      \"string\",\n\t\tGenerate: func(f *Faker, m *MapParams, info *Info) (any, error) {\n\t\t\treturn adjectiveDemonstrative(f), nil\n\t\t},\n\t})\n\n\tAddFuncLookup(\"adjectivepossessive\", Info{\n\t\tDisplay:     \"Possessive Adjective\",\n\t\tCategory:    \"word\",\n\t\tDescription: \"Adjective indicating ownership or possession\",\n\t\tExample:     \"my\",\n\t\tOutput:      \"string\",\n\t\tGenerate: func(f *Faker, m *MapParams, info *Info) (any, error) {\n\t\t\treturn adjectivePossessive(f), nil\n\t\t},\n\t})\n\n\tAddFuncLookup(\"adjectiveinterrogative\", Info{\n\t\tDisplay:     \"Interrogative Adjective\",\n\t\tCategory:    \"word\",\n\t\tDescription: \"Adjective used to ask questions\",\n\t\tExample:     \"what\",\n\t\tOutput:      \"string\",\n\t\tGenerate: func(f *Faker, m *MapParams, info *Info) (any, error) {\n\t\t\treturn adjectiveInterrogative(f), nil\n\t\t},\n\t})\n\n\tAddFuncLookup(\"adjectiveindefinite\", Info{\n\t\tDisplay:     \"Indefinite Adjective\",\n\t\tCategory:    \"word\",\n\t\tDescription: \"Adjective describing a non-specific noun\",\n\t\tExample:     \"few\",\n\t\tOutput:      \"string\",\n\t\tGenerate: func(f *Faker, m *MapParams, info *Info) (any, error) {\n\t\t\treturn adjectiveIndefinite(f), nil\n\t\t},\n\t})\n}\n"
        },
        {
          "name": "word_adjective_test.go",
          "type": "blob",
          "size": 2.5771484375,
          "content": "package gofakeit\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc ExampleAdjective() {\n\tSeed(11)\n\tfmt.Println(Adjective())\n\n\t// Output: none\n}\n\nfunc ExampleFaker_Adjective() {\n\tf := New(11)\n\tfmt.Println(f.Adjective())\n\n\t// Output: none\n}\n\nfunc BenchmarkAdjective(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tAdjective()\n\t}\n}\n\nfunc ExampleAdjectiveDescriptive() {\n\tSeed(11)\n\tfmt.Println(AdjectiveDescriptive())\n\n\t// Output: tired\n}\n\nfunc ExampleFaker_AdjectiveDescriptive() {\n\tf := New(11)\n\tfmt.Println(f.AdjectiveDescriptive())\n\n\t// Output: tired\n}\n\nfunc BenchmarkAdjectiveDescriptive(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tAdjectiveDescriptive()\n\t}\n}\n\nfunc ExampleAdjectiveQuantitative() {\n\tSeed(11)\n\tfmt.Println(AdjectiveQuantitative())\n\n\t// Output: sparse\n}\n\nfunc ExampleFaker_AdjectiveQuantitative() {\n\tf := New(11)\n\tfmt.Println(f.AdjectiveQuantitative())\n\n\t// Output: sparse\n}\n\nfunc BenchmarkAdjectiveQuantitative(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tAdjectiveQuantitative()\n\t}\n}\n\nfunc ExampleAdjectiveProper() {\n\tSeed(11)\n\tfmt.Println(AdjectiveProper())\n\n\t// Output: Swiss\n}\n\nfunc ExampleFaker_AdjectiveProper() {\n\tf := New(11)\n\tfmt.Println(f.AdjectiveProper())\n\n\t// Output: Swiss\n}\n\nfunc BenchmarkAdjectiveProper(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tAdjectiveProper()\n\t}\n}\n\nfunc ExampleAdjectiveDemonstrative() {\n\tSeed(11)\n\tfmt.Println(AdjectiveDemonstrative())\n\n\t// Output: it\n}\n\nfunc ExampleFaker_AdjectiveDemonstrative() {\n\tf := New(11)\n\tfmt.Println(f.AdjectiveDemonstrative())\n\n\t// Output: it\n}\n\nfunc BenchmarkAdjectiveDemonstrative(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tAdjectiveDemonstrative()\n\t}\n}\n\nfunc ExampleAdjectivePossessive() {\n\tSeed(11)\n\tfmt.Println(AdjectivePossessive())\n\n\t// Output: their\n}\n\nfunc ExampleFaker_AdjectivePossessive() {\n\tf := New(11)\n\tfmt.Println(f.AdjectivePossessive())\n\n\t// Output: their\n}\n\nfunc BenchmarkAdjectivePossessive(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tAdjectivePossessive()\n\t}\n}\n\nfunc ExampleAdjectiveInterrogative() {\n\tSeed(11)\n\tfmt.Println(AdjectiveInterrogative())\n\n\t// Output: which\n}\n\nfunc ExampleFaker_AdjectiveInterrogative() {\n\tf := New(11)\n\tfmt.Println(f.AdjectiveInterrogative())\n\n\t// Output: which\n}\n\nfunc BenchmarkAdjectiveInterrogative(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tAdjectiveInterrogative()\n\t}\n}\n\nfunc ExampleAdjectiveIndefinite() {\n\tSeed(11)\n\tfmt.Println(AdjectiveIndefinite())\n\n\t// Output: several\n}\n\nfunc ExampleFaker_AdjectiveIndefinite() {\n\tf := New(11)\n\tfmt.Println(f.AdjectiveIndefinite())\n\n\t// Output: several\n}\n\nfunc BenchmarkAdjectiveIndefinite(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tAdjectiveIndefinite()\n\t}\n}\n"
        },
        {
          "name": "word_adverb.go",
          "type": "blob",
          "size": 5.92578125,
          "content": "package gofakeit\n\n// Adverb will generate a random adverb\nfunc Adverb() string { return adverb(GlobalFaker) }\n\n// Adverb will generate a random adverb\nfunc (f *Faker) Adverb() string { return adverb(f) }\n\nfunc adverb(f *Faker) string {\n\tvar adverbType = map[int]string{\n\t\t0: \"adverb_manner\",\n\t\t1: \"adverb_degree\",\n\t\t2: \"adverb_place\",\n\t\t3: \"adverb_time_definite\",\n\t\t4: \"adverb_time_indefinite\",\n\t\t5: \"adverb_frequency_definite\",\n\t\t6: \"adverb_frequency_indefinite\",\n\t}\n\treturn getRandValue(f, []string{\"word\", adverbType[number(f, 0, 6)]})\n}\n\n// AdverbManner will generate a random manner adverb\nfunc AdverbManner() string { return adverbManner(GlobalFaker) }\n\n// AdverbManner will generate a random manner adverb\nfunc (f *Faker) AdverbManner() string { return adverbManner(f) }\n\nfunc adverbManner(f *Faker) string { return getRandValue(f, []string{\"word\", \"adverb_manner\"}) }\n\n// AdverbDegree will generate a random degree adverb\nfunc AdverbDegree() string { return adverbDegree(GlobalFaker) }\n\n// AdverbDegree will generate a random degree adverb\nfunc (f *Faker) AdverbDegree() string { return adverbDegree(f) }\n\nfunc adverbDegree(f *Faker) string { return getRandValue(f, []string{\"word\", \"adverb_degree\"}) }\n\n// AdverbPlace will generate a random place adverb\nfunc AdverbPlace() string { return adverbPlace(GlobalFaker) }\n\n// AdverbPlace will generate a random place adverb\nfunc (f *Faker) AdverbPlace() string { return adverbPlace(f) }\n\nfunc adverbPlace(f *Faker) string { return getRandValue(f, []string{\"word\", \"adverb_place\"}) }\n\n// AdverbTimeDefinite will generate a random time definite adverb\nfunc AdverbTimeDefinite() string { return adverbTimeDefinite(GlobalFaker) }\n\n// AdverbTimeDefinite will generate a random time definite adverb\nfunc (f *Faker) AdverbTimeDefinite() string { return adverbTimeDefinite(f) }\n\nfunc adverbTimeDefinite(f *Faker) string {\n\treturn getRandValue(f, []string{\"word\", \"adverb_time_definite\"})\n}\n\n// AdverbTimeIndefinite will generate a random time indefinite adverb\nfunc AdverbTimeIndefinite() string { return adverbTimeIndefinite(GlobalFaker) }\n\n// AdverbTimeIndefinite will generate a random time indefinite adverb\nfunc (f *Faker) AdverbTimeIndefinite() string { return adverbTimeIndefinite(f) }\n\nfunc adverbTimeIndefinite(f *Faker) string {\n\treturn getRandValue(f, []string{\"word\", \"adverb_time_indefinite\"})\n}\n\n// AdverbFrequencyDefinite will generate a random frequency definite adverb\nfunc AdverbFrequencyDefinite() string { return adverbFrequencyDefinite(GlobalFaker) }\n\n// AdverbFrequencyDefinite will generate a random frequency definite adverb\nfunc (f *Faker) AdverbFrequencyDefinite() string { return adverbFrequencyDefinite(f) }\n\nfunc adverbFrequencyDefinite(f *Faker) string {\n\treturn getRandValue(f, []string{\"word\", \"adverb_frequency_definite\"})\n}\n\n// AdverbFrequencyIndefinite will generate a random frequency indefinite adverb\nfunc AdverbFrequencyIndefinite() string { return adverbFrequencyIndefinite(GlobalFaker) }\n\n// AdverbFrequencyIndefinite will generate a random frequency indefinite adverb\nfunc (f *Faker) AdverbFrequencyIndefinite() string { return adverbFrequencyIndefinite(f) }\n\nfunc adverbFrequencyIndefinite(f *Faker) string {\n\treturn getRandValue(f, []string{\"word\", \"adverb_frequency_indefinite\"})\n}\n\nfunc addWordAdverbLookup() {\n\tAddFuncLookup(\"adverb\", Info{\n\t\tDisplay:     \"Adverb\",\n\t\tCategory:    \"word\",\n\t\tDescription: \"Word that modifies verbs, adjectives, or other adverbs\",\n\t\tExample:     \"smoothly\",\n\t\tOutput:      \"string\",\n\t\tGenerate: func(f *Faker, m *MapParams, info *Info) (any, error) {\n\t\t\treturn adverb(f), nil\n\t\t},\n\t})\n\n\tAddFuncLookup(\"adverbmanner\", Info{\n\t\tDisplay:     \"Adverb Manner\",\n\t\tCategory:    \"word\",\n\t\tDescription: \"Adverb that describes how an action is performed\",\n\t\tExample:     \"stupidly\",\n\t\tOutput:      \"string\",\n\t\tGenerate: func(f *Faker, m *MapParams, info *Info) (any, error) {\n\t\t\treturn adverbManner(f), nil\n\t\t},\n\t})\n\n\tAddFuncLookup(\"adverbdegree\", Info{\n\t\tDisplay:     \"Adverb Degree\",\n\t\tCategory:    \"word\",\n\t\tDescription: \"Adverb that indicates the degree or intensity of an action or adjective\",\n\t\tExample:     \"intensely\",\n\t\tOutput:      \"string\",\n\t\tGenerate: func(f *Faker, m *MapParams, info *Info) (any, error) {\n\t\t\treturn adverbDegree(f), nil\n\t\t},\n\t})\n\n\tAddFuncLookup(\"adverbplace\", Info{\n\t\tDisplay:     \"Adverb Place\",\n\t\tCategory:    \"word\",\n\t\tDescription: \"Adverb that indicates the location or direction of an action\",\n\t\tExample:     \"east\",\n\t\tOutput:      \"string\",\n\t\tGenerate: func(f *Faker, m *MapParams, info *Info) (any, error) {\n\t\t\treturn adverbPlace(f), nil\n\t\t},\n\t})\n\n\tAddFuncLookup(\"adverbtimedefinite\", Info{\n\t\tDisplay:     \"Adverb Time Definite\",\n\t\tCategory:    \"word\",\n\t\tDescription: \"Adverb that specifies the exact time an action occurs\",\n\t\tExample:     \"now\",\n\t\tOutput:      \"string\",\n\t\tGenerate: func(f *Faker, m *MapParams, info *Info) (any, error) {\n\t\t\treturn adverbTimeDefinite(f), nil\n\t\t},\n\t})\n\n\tAddFuncLookup(\"adverbtimeindefinite\", Info{\n\t\tDisplay:     \"Adverb Time Indefinite\",\n\t\tCategory:    \"word\",\n\t\tDescription: \"Adverb that gives a general or unspecified time frame\",\n\t\tExample:     \"already\",\n\t\tOutput:      \"string\",\n\t\tGenerate: func(f *Faker, m *MapParams, info *Info) (any, error) {\n\t\t\treturn adverbTimeIndefinite(f), nil\n\t\t},\n\t})\n\n\tAddFuncLookup(\"adverbfrequencydefinite\", Info{\n\t\tDisplay:     \"Adverb Frequency Definite\",\n\t\tCategory:    \"word\",\n\t\tDescription: \"Adverb that specifies how often an action occurs with a clear frequency\",\n\t\tExample:     \"hourly\",\n\t\tOutput:      \"string\",\n\t\tGenerate: func(f *Faker, m *MapParams, info *Info) (any, error) {\n\t\t\treturn adverbFrequencyDefinite(f), nil\n\t\t},\n\t})\n\n\tAddFuncLookup(\"adverbfrequencyindefinite\", Info{\n\t\tDisplay:     \"Adverb Frequency Indefinite\",\n\t\tCategory:    \"word\",\n\t\tDescription: \"Adverb that specifies how often an action occurs without specifying a particular frequency\",\n\t\tExample:     \"occasionally\",\n\t\tOutput:      \"string\",\n\t\tGenerate: func(f *Faker, m *MapParams, info *Info) (any, error) {\n\t\t\treturn adverbFrequencyIndefinite(f), nil\n\t\t},\n\t})\n}\n"
        },
        {
          "name": "word_adverb_test.go",
          "type": "blob",
          "size": 2.4755859375,
          "content": "package gofakeit\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc ExampleAdverb() {\n\tSeed(11)\n\tfmt.Println(Adverb())\n\n\t// Output: ever\n}\n\nfunc ExampleFaker_Adverb() {\n\tf := New(11)\n\tfmt.Println(f.Adverb())\n\n\t// Output: ever\n}\n\nfunc BenchmarkAdverb(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tAdverb()\n\t}\n}\n\nfunc ExampleAdverbManner() {\n\tSeed(11)\n\tfmt.Println(AdverbManner())\n\n\t// Output: tensely\n}\n\nfunc ExampleFaker_AdverbManner() {\n\tf := New(11)\n\tfmt.Println(f.AdverbManner())\n\n\t// Output: tensely\n}\n\nfunc BenchmarkAdverbManner(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tAdverbManner()\n\t}\n}\n\nfunc ExampleAdverbDegree() {\n\tSeed(11)\n\tfmt.Println(AdverbDegree())\n\n\t// Output: too\n}\n\nfunc ExampleFaker_AdverbDegree() {\n\tf := New(11)\n\tfmt.Println(f.AdverbDegree())\n\n\t// Output: too\n}\n\nfunc BenchmarkAdverbDegree(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tAdverbDegree()\n\t}\n}\n\nfunc ExampleAdverbPlace() {\n\tSeed(11)\n\tfmt.Println(AdverbPlace())\n\n\t// Output: under\n}\n\nfunc ExampleFaker_AdverbPlace() {\n\tf := New(11)\n\tfmt.Println(f.AdverbPlace())\n\n\t// Output: under\n}\n\nfunc BenchmarkAdverbPlace(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tAdverbPlace()\n\t}\n}\n\nfunc ExampleAdverbTimeDefinite() {\n\tSeed(11)\n\tfmt.Println(AdverbTimeDefinite())\n\n\t// Output: yesterday\n}\n\nfunc ExampleFaker_AdverbTimeDefinite() {\n\tf := New(11)\n\tfmt.Println(f.AdverbTimeDefinite())\n\n\t// Output: yesterday\n}\n\nfunc BenchmarkAdverbTimeDefinite(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tAdverbTimeDefinite()\n\t}\n}\n\nfunc ExampleAdverbTimeIndefinite() {\n\tSeed(11)\n\tfmt.Println(AdverbTimeIndefinite())\n\n\t// Output: soon\n}\n\nfunc ExampleFaker_AdverbTimeIndefinite() {\n\tf := New(11)\n\tfmt.Println(f.AdverbTimeIndefinite())\n\n\t// Output: soon\n}\n\nfunc BenchmarkAdverbTimeIndefinite(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tAdverbTimeIndefinite()\n\t}\n}\n\nfunc ExampleAdverbFrequencyDefinite() {\n\tSeed(11)\n\tfmt.Println(AdverbFrequencyDefinite())\n\n\t// Output: yearly\n}\n\nfunc ExampleFaker_AdverbFrequencyDefinite() {\n\tf := New(11)\n\tfmt.Println(f.AdverbFrequencyDefinite())\n\n\t// Output: yearly\n}\n\nfunc BenchmarkAdverbFrequencyDefinite(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tAdverbFrequencyDefinite()\n\t}\n}\n\nfunc ExampleAdverbFrequencyIndefinite() {\n\tSeed(11)\n\tfmt.Println(AdverbFrequencyIndefinite())\n\n\t// Output: generally\n}\n\nfunc ExampleFaker_AdverbFrequencyIndefinite() {\n\tf := New(11)\n\tfmt.Println(f.AdverbFrequencyIndefinite())\n\n\t// Output: generally\n}\n\nfunc BenchmarkAdverbFrequencyIndefinite(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tAdverbFrequencyIndefinite()\n\t}\n}\n"
        },
        {
          "name": "word_comment.go",
          "type": "blob",
          "size": 1.9697265625,
          "content": "package gofakeit\n\nimport (\n\t\"strings\"\n)\n\n// Comment will generate a random statement or remark expressing an opinion, observation, or reaction\nfunc Comment() string { return comment(GlobalFaker) }\n\n// Comment will generate a random statement or remark expressing an opinion, observation, or reaction\nfunc (f *Faker) Comment() string { return comment(f) }\n\nfunc comment(f *Faker) string {\n\tstructures := [][]string{\n\t\t{\"interjection\", \"adjective\", \"noun\", \"verb\", \"adverb\"},\n\t\t{\"noun\", \"verb\", \"preposition\", \"determiner\", \"adjective\", \"noun\"},\n\t\t{\"noun\", \"verb\", \"adverb\"},\n\t\t{\"adjective\", \"noun\", \"verb\"},\n\t\t{\"noun\", \"verb\", \"preposition\", \"noun\"},\n\t}\n\n\t// Randomly select a structure\n\tstructure := structures[number(f, 0, len(structures)-1)]\n\n\t// Build the sentence\n\tvar commentParts []string\n\tfor _, wordType := range structure {\n\t\tswitch wordType {\n\t\tcase \"noun\":\n\t\t\tcommentParts = append(commentParts, noun(f))\n\t\tcase \"verb\":\n\t\t\tcommentParts = append(commentParts, verb(f))\n\t\tcase \"adjective\":\n\t\t\tcommentParts = append(commentParts, adjective(f))\n\t\tcase \"adverb\":\n\t\t\tcommentParts = append(commentParts, adverb(f))\n\t\tcase \"interjection\":\n\t\t\tcommentParts = append(commentParts, interjection(f))\n\t\tcase \"preposition\":\n\t\t\tcommentParts = append(commentParts, preposition(f))\n\t\tcase \"determiner\":\n\t\t\tcommentParts = append(commentParts, nounDeterminer(f))\n\t\tdefault:\n\t\t\t// Should never hit\n\t\t\tpanic(\"Invalid word type\")\n\t\t}\n\t}\n\n\t// Combine the words into a sentence\n\tsentence := strings.Join(commentParts, \" \")\n\n\t// Capitalize the first letter\n\tsentence = title(sentence)\n\n\t// Add a period to the end of the sentence\n\tsentence = sentence + \".\"\n\n\treturn sentence\n}\n\nfunc addWordCommentLookup() {\n\tAddFuncLookup(\"comment\", Info{\n\t\tDisplay:     \"Comment\",\n\t\tCategory:    \"word\",\n\t\tDescription: \"Statement or remark expressing an opinion, observation, or reaction\",\n\t\tExample:     \"wow\",\n\t\tOutput:      \"string\",\n\t\tGenerate: func(f *Faker, m *MapParams, info *Info) (any, error) {\n\t\t\treturn interjection(f), nil\n\t\t},\n\t})\n}\n"
        },
        {
          "name": "word_comment_test.go",
          "type": "blob",
          "size": 0.4189453125,
          "content": "package gofakeit\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc ExampleComment() {\n\tSeed(11)\n\tfmt.Println(Comment())\n\n\t// Output: Fear Drink To Heart.\n}\n\nfunc ExampleFaker_Comment() {\n\tf := New(11)\n\tfmt.Println(f.Comment())\n\n\t// Output: Fear Drink To Heart.\n}\n\nfunc TestComment(t *testing.T) {\n\tf := New(11)\n\tfor i := 0; i < 1000; i++ {\n\t\tf.Comment()\n\t}\n}\n\nfunc BenchmarkComment(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tComment()\n\t}\n}\n"
        },
        {
          "name": "word_connective.go",
          "type": "blob",
          "size": 5.318359375,
          "content": "package gofakeit\n\n// Connective will generate a random connective\nfunc Connective() string { return connective(GlobalFaker) }\n\n// Connective will generate a random connective\nfunc (f *Faker) Connective() string { return connective(f) }\n\nfunc connective(f *Faker) string {\n\tvar connectiveType = map[int]string{\n\t\t0: \"connective_time\",\n\t\t1: \"connective_comparative\",\n\t\t2: \"connective_complaint\",\n\t\t3: \"connective_listing\",\n\t\t4: \"connective_casual\",\n\t\t5: \"connective_examplify\",\n\t}\n\treturn getRandValue(f, []string{\"word\", connectiveType[number(f, 0, 5)]})\n}\n\n// ConnectiveTime will generate a random connective time\nfunc ConnectiveTime() string { return connectiveTime(GlobalFaker) }\n\n// ConnectiveTime will generate a random connective time\n\nfunc (f *Faker) ConnectiveTime() string { return connectiveTime(f) }\n\nfunc connectiveTime(f *Faker) string {\n\treturn getRandValue(f, []string{\"word\", \"connective_time\"})\n}\n\n// ConnectiveComparative will generate a random comparative connective\nfunc ConnectiveComparative() string { return connectiveComparative(GlobalFaker) }\n\n// ConnectiveComparative will generate a random comparative connective\nfunc (f *Faker) ConnectiveComparative() string { return connectiveComparative(f) }\n\nfunc connectiveComparative(f *Faker) string {\n\treturn getRandValue(f, []string{\"word\", \"connective_comparative\"})\n}\n\n// ConnectiveComplaint will generate a random complaint connective\nfunc ConnectiveComplaint() string { return connectiveComplaint(GlobalFaker) }\n\n// ConnectiveComplaint will generate a random complaint connective\nfunc (f *Faker) ConnectiveComplaint() string { return connectiveComplaint(f) }\n\nfunc connectiveComplaint(f *Faker) string {\n\treturn getRandValue(f, []string{\"word\", \"connective_complaint\"})\n}\n\n// ConnectiveListing will generate a random listing connective\nfunc ConnectiveListing() string { return connectiveListing(GlobalFaker) }\n\n// ConnectiveListing will generate a random listing connective\nfunc (f *Faker) ConnectiveListing() string { return connectiveListing(f) }\n\nfunc connectiveListing(f *Faker) string {\n\treturn getRandValue(f, []string{\"word\", \"connective_listing\"})\n}\n\n// ConnectiveCasual will generate a random casual connective\nfunc ConnectiveCasual() string { return connectiveCasual(GlobalFaker) }\n\n// ConnectiveCasual will generate a random casual connective\nfunc (f *Faker) ConnectiveCasual() string { return connectiveCasual(f) }\n\nfunc connectiveCasual(f *Faker) string {\n\treturn getRandValue(f, []string{\"word\", \"connective_casual\"})\n}\n\n// ConnectiveExamplify will generate a random examplify connective\nfunc ConnectiveExamplify() string { return connectiveExamplify(GlobalFaker) }\n\n// ConnectiveExamplify will generate a random examplify connective\nfunc (f *Faker) ConnectiveExamplify() string { return connectiveExamplify(f) }\n\nfunc connectiveExamplify(f *Faker) string {\n\treturn getRandValue(f, []string{\"word\", \"connective_examplify\"})\n}\n\nfunc addWordConnectiveLookup() {\n\tAddFuncLookup(\"connective\", Info{\n\t\tDisplay:     \"Connective\",\n\t\tCategory:    \"word\",\n\t\tDescription: \"Word used to connect words or sentences\",\n\t\tExample:     \"such as\",\n\t\tOutput:      \"string\",\n\t\tGenerate: func(f *Faker, m *MapParams, info *Info) (any, error) {\n\t\t\treturn connective(f), nil\n\t\t},\n\t})\n\n\tAddFuncLookup(\"connectivetime\", Info{\n\t\tDisplay:     \"Connective Time\",\n\t\tCategory:    \"word\",\n\t\tDescription: \"Connective word used to indicate a temporal relationship between events or actions\",\n\t\tExample:     \"finally\",\n\t\tOutput:      \"string\",\n\t\tGenerate: func(f *Faker, m *MapParams, info *Info) (any, error) {\n\t\t\treturn connectiveTime(f), nil\n\t\t},\n\t})\n\n\tAddFuncLookup(\"connectivecomparative\", Info{\n\t\tDisplay:     \"Connective Comparitive\",\n\t\tCategory:    \"word\",\n\t\tDescription: \"Connective word used to indicate a comparison between two or more things\",\n\t\tExample:     \"in addition\",\n\t\tOutput:      \"string\",\n\t\tGenerate: func(f *Faker, m *MapParams, info *Info) (any, error) {\n\t\t\treturn connectiveComparative(f), nil\n\t\t},\n\t})\n\n\tAddFuncLookup(\"connectivecomplaint\", Info{\n\t\tDisplay:     \"Connective Complaint\",\n\t\tCategory:    \"word\",\n\t\tDescription: \"Connective word used to express dissatisfaction or complaints about a situation\",\n\t\tExample:     \"besides\",\n\t\tOutput:      \"string\",\n\t\tGenerate: func(f *Faker, m *MapParams, info *Info) (any, error) {\n\t\t\treturn connectiveComplaint(f), nil\n\t\t},\n\t})\n\n\tAddFuncLookup(\"connectivelisting\", Info{\n\t\tDisplay:     \"Connective Listing\",\n\t\tCategory:    \"word\",\n\t\tDescription: \"Connective word used to list or enumerate items or examples\",\n\t\tExample:     \"firstly\",\n\t\tOutput:      \"string\",\n\t\tGenerate: func(f *Faker, m *MapParams, info *Info) (any, error) {\n\t\t\treturn connectiveListing(f), nil\n\t\t},\n\t})\n\n\tAddFuncLookup(\"connectivecasual\", Info{\n\t\tDisplay:     \"Connective Casual\",\n\t\tCategory:    \"word\",\n\t\tDescription: \"Connective word used to indicate a cause-and-effect relationship between events or actions\",\n\t\tExample:     \"an outcome of\",\n\t\tOutput:      \"string\",\n\t\tGenerate: func(f *Faker, m *MapParams, info *Info) (any, error) {\n\t\t\treturn connectiveCasual(f), nil\n\t\t},\n\t})\n\n\tAddFuncLookup(\"connectiveexamplify\", Info{\n\t\tDisplay:     \"Connective Examplify\",\n\t\tCategory:    \"word\",\n\t\tDescription: \"Connective word used to provide examples or illustrations of a concept or idea\",\n\t\tExample:     \"then\",\n\t\tOutput:      \"string\",\n\t\tGenerate: func(f *Faker, m *MapParams, info *Info) (any, error) {\n\t\t\treturn connectiveExamplify(f), nil\n\t\t},\n\t})\n}\n"
        },
        {
          "name": "word_connective_test.go",
          "type": "blob",
          "size": 2.2138671875,
          "content": "package gofakeit\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc ExampleConnective() {\n\tSeed(11)\n\tfmt.Println(Connective())\n\n\t// Output: through\n}\n\nfunc ExampleFaker_Connective() {\n\tf := New(11)\n\tfmt.Println(f.Connective())\n\n\t// Output: through\n}\n\nfunc BenchmarkConnective(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tConnective()\n\t}\n}\n\nfunc ExampleConnectiveTime() {\n\tSeed(11)\n\tfmt.Println(ConnectiveTime())\n\n\t// Output: when\n}\n\nfunc ExampleFaker_ConnectiveTime() {\n\tf := New(11)\n\tfmt.Println(f.ConnectiveTime())\n\n\t// Output: when\n}\n\nfunc BenchmarkConnectiveTime(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tConnectiveTime()\n\t}\n}\n\nfunc ExampleConnectiveComparative() {\n\tSeed(11)\n\tfmt.Println(ConnectiveComparative())\n\n\t// Output: after all\n}\n\nfunc ExampleFaker_ConnectiveComparative() {\n\tf := New(11)\n\tfmt.Println(f.ConnectiveComparative())\n\n\t// Output: after all\n}\n\nfunc BenchmarkConnectiveComparative(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tConnectiveComparative()\n\t}\n}\n\nfunc ExampleConnectiveComplaint() {\n\tSeed(11)\n\tfmt.Println(ConnectiveComplaint())\n\n\t// Output: i.e.\n}\n\nfunc ExampleFaker_ConnectiveComplaint() {\n\tf := New(11)\n\tfmt.Println(f.ConnectiveComplaint())\n\n\t// Output: i.e.\n}\n\nfunc BenchmarkConnectiveComplaint(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tConnectiveComplaint()\n\t}\n}\n\nfunc ExampleConnectiveListing() {\n\tSeed(11)\n\tfmt.Println(ConnectiveListing())\n\n\t// Output: in summation\n}\n\nfunc ExampleFaker_ConnectiveListing() {\n\tf := New(11)\n\tfmt.Println(f.ConnectiveListing())\n\n\t// Output: in summation\n}\n\nfunc BenchmarkConnectiveListing(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tConnectiveListing()\n\t}\n}\n\nfunc ExampleConnectiveCasual() {\n\tSeed(11)\n\tfmt.Println(ConnectiveCasual())\n\n\t// Output: though\n}\n\nfunc ExampleFaker_ConnectiveCasual() {\n\tf := New(11)\n\tfmt.Println(f.ConnectiveCasual())\n\n\t// Output: though\n}\n\nfunc BenchmarkConnectiveCasual(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tConnectiveCasual()\n\t}\n}\n\nfunc ExampleConnectiveExamplify() {\n\tSeed(11)\n\tfmt.Println(ConnectiveExamplify())\n\n\t// Output: unless\n}\n\nfunc ExampleFaker_ConnectiveExamplify() {\n\tf := New(11)\n\tfmt.Println(f.ConnectiveExamplify())\n\n\t// Output: unless\n}\n\nfunc BenchmarkConnectiveExamplify(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tConnectiveExamplify()\n\t}\n}\n"
        },
        {
          "name": "word_general.go",
          "type": "blob",
          "size": 0.9033203125,
          "content": "package gofakeit\n\nimport (\n\t\"strings\"\n\n\t\"github.com/brianvoe/gofakeit/v7/data\"\n)\n\n// Word will generate a random word\nfunc Word() string { return word(GlobalFaker) }\n\n// Word will generate a random word\nfunc (f *Faker) Word() string { return word(f) }\n\nfunc word(f *Faker) string {\n\tword := getRandValue(f, []string{\"word\", randomString(f, data.WordKeys)})\n\n\t// Word may return a couple of words, if so we will split on space and return a random word\n\tif strings.Contains(word, \" \") {\n\t\treturn randomString(f, strings.Split(word, \" \"))\n\t}\n\n\treturn word\n}\n\nfunc addWordGeneralLookup() {\n\tAddFuncLookup(\"word\", Info{\n\t\tDisplay:     \"Word\",\n\t\tCategory:    \"word\",\n\t\tDescription: \"Basic unit of language representing a concept or thing, consisting of letters and having meaning\",\n\t\tExample:     \"man\",\n\t\tOutput:      \"string\",\n\t\tGenerate: func(f *Faker, m *MapParams, info *Info) (any, error) {\n\t\t\treturn word(f), nil\n\t\t},\n\t})\n}\n"
        },
        {
          "name": "word_general_test.go",
          "type": "blob",
          "size": 0.4072265625,
          "content": "package gofakeit\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc ExampleWord() {\n\tSeed(11)\n\tfmt.Println(Word())\n\n\t// Output: bathe\n}\n\nfunc ExampleFaker_Word() {\n\tf := New(11)\n\tfmt.Println(f.Word())\n\n\t// Output: bathe\n}\n\nfunc BenchmarkWord(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tWord()\n\t}\n}\n\nfunc TestWord(t *testing.T) {\n\tfor i := 0; i < 10000; i++ {\n\t\tif Word() == \"\" {\n\t\t\tt.Errorf(\"result should not be blank\")\n\t\t}\n\t}\n}\n"
        },
        {
          "name": "word_grammar.go",
          "type": "blob",
          "size": 0.9189453125,
          "content": "package gofakeit\n\nimport (\n\t\"unicode\"\n)\n\n// SentenceSimple will generate a random simple sentence\nfunc SentenceSimple() string { return sentenceSimple(GlobalFaker) }\n\n// SentenceSimple will generate a random simple sentence\nfunc (f *Faker) SentenceSimple() string { return sentenceSimple(f) }\n\nfunc sentenceSimple(f *Faker) string {\n\t// simple sentence consists of a noun phrase and a verb phrase\n\tstr := phraseNoun(f) + \" \" + phraseVerb(f) + \".\"\n\n\t// capitalize the first letter\n\tstrR := []rune(str)\n\tstrR[0] = unicode.ToUpper(strR[0])\n\treturn string(strR)\n}\n\nfunc addWordGrammerLookup() {\n\tAddFuncLookup(\"sentencesimple\", Info{\n\t\tDisplay:     \"Simple Sentence\",\n\t\tCategory:    \"word\",\n\t\tDescription: \"Group of words that expresses a complete thought\",\n\t\tExample:     \"A tribe fly the lemony kitchen.\",\n\t\tOutput:      \"string\",\n\t\tGenerate: func(f *Faker, m *MapParams, info *Info) (any, error) {\n\t\t\treturn sentenceSimple(f), nil\n\t\t},\n\t})\n}\n"
        },
        {
          "name": "word_grammar_test.go",
          "type": "blob",
          "size": 0.5146484375,
          "content": "package gofakeit\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc ExampleSentenceSimple() {\n\tSeed(11)\n\tfmt.Println(SentenceSimple())\n\n\t// Output: A fear selfishly cook a tough doctor hardly innocently to realistic project utterly ingeniously.\n}\n\nfunc ExampleFaker_SentenceSimple() {\n\tf := New(11)\n\tfmt.Println(f.SentenceSimple())\n\n\t// Output: A fear selfishly cook a tough doctor hardly innocently to realistic project utterly ingeniously.\n}\n\nfunc BenchmarkSentenceSimple(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tSentenceSimple()\n\t}\n}\n"
        },
        {
          "name": "word_helper.go",
          "type": "blob",
          "size": 0.8916015625,
          "content": "package gofakeit\n\nimport (\n\t\"strings\"\n)\n\n// This will look at a few things to determine what kind of article to use for the word\nfunc getArticle(word string) string {\n\t// If nothing is passed return empty\n\tif word == \"\" {\n\t\treturn \"\"\n\t}\n\n\tword = strings.ToLower(word)\n\tletters := strings.Split(word, \"\")\n\tfirstLetter := \"\"\n\tsecondLetter := \"\"\n\tif len(letters) > 0 {\n\t\tfirstLetter = letters[0]\n\t}\n\tif len(letters) > 1 {\n\t\tsecondLetter = letters[1]\n\t}\n\n\t// If the word starts with a, e, i, o, use an article\n\tif firstLetter == \"a\" || firstLetter == \"e\" || firstLetter == \"i\" || firstLetter == \"o\" {\n\t\treturn \"an\"\n\t}\n\n\t// If the word starts with a u and n or l, use an article\n\tif firstLetter == \"u\" {\n\t\tif secondLetter == \"n\" || secondLetter == \"l\" {\n\t\t\treturn \"an\"\n\t\t}\n\t}\n\n\t// If the word starts with a vowel, use an article\n\tif firstLetter == \"h\" {\n\t\tif secondLetter == \"i\" {\n\t\t\treturn \"an\"\n\t\t}\n\t}\n\n\treturn \"a\"\n}\n"
        },
        {
          "name": "word_helper_test.go",
          "type": "blob",
          "size": 1.2119140625,
          "content": "package gofakeit\n\nimport \"testing\"\n\nfunc TestGetArticle(t *testing.T) {\n\t// If nothing is passed return empty\n\tif getArticle(\"\") != \"\" {\n\t\tt.Error(\"Expected empty string, got: \", getArticle(\"\"))\n\t}\n\n\t// If the word starts with a, e, i, o, use an article\n\tif getArticle(\"apple\") != \"an\" {\n\t\tt.Error(\"Expected an, got: \", getArticle(\"apple\"))\n\t}\n\n\tif getArticle(\"elephant\") != \"an\" {\n\t\tt.Error(\"Expected an, got: \", getArticle(\"elephant\"))\n\t}\n\n\tif getArticle(\"independent\") != \"an\" {\n\t\tt.Error(\"Expected an, got: \", getArticle(\"independent\"))\n\t}\n\n\tif getArticle(\"open\") != \"an\" {\n\t\tt.Error(\"Expected an, got: \", getArticle(\"open\"))\n\t}\n\n\t// If the word starts with a u and n or l, use an article\n\tif getArticle(\"underwear\") != \"an\" {\n\t\tt.Error(\"Expected an, got: \", getArticle(\"underwear\"))\n\t}\n\n\tif getArticle(\"ulcer\") != \"an\" {\n\t\tt.Error(\"Expected an, got: \", getArticle(\"ulcer\"))\n\t}\n\n\t// If the word starts with a vowel, use an article\n\tif getArticle(\"hippos\") != \"an\" {\n\t\tt.Error(\"Expected an, got: \", getArticle(\"hippose\"))\n\t}\n\n\t// Pass a word that will return \"a\"\n\tif getArticle(\"bus\") != \"a\" {\n\t\tt.Error(\"Expected a, got: \", getArticle(\"bus\"))\n\t}\n\n\tif getArticle(\"plane\") != \"a\" {\n\t\tt.Error(\"Expected a, got: \", getArticle(\"plane\"))\n\t}\n}\n"
        },
        {
          "name": "word_misc.go",
          "type": "blob",
          "size": 0.6728515625,
          "content": "package gofakeit\n\n// Interjection will generate a random word expressing emotion\nfunc Interjection() string { return interjection(GlobalFaker) }\n\n// Interjection will generate a random word expressing emotion\nfunc (f *Faker) Interjection() string { return interjection(f) }\n\nfunc interjection(f *Faker) string { return getRandValue(f, []string{\"word\", \"interjection\"}) }\n\nfunc addWordMiscLookup() {\n\tAddFuncLookup(\"interjection\", Info{\n\t\tDisplay:     \"Interjection\",\n\t\tCategory:    \"word\",\n\t\tDescription: \"Word expressing emotion\",\n\t\tExample:     \"wow\",\n\t\tOutput:      \"string\",\n\t\tGenerate: func(f *Faker, m *MapParams, info *Info) (any, error) {\n\t\t\treturn interjection(f), nil\n\t\t},\n\t})\n}\n"
        },
        {
          "name": "word_misc_test.go",
          "type": "blob",
          "size": 0.3232421875,
          "content": "package gofakeit\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc ExampleInterjection() {\n\tSeed(11)\n\tfmt.Println(Interjection())\n\n\t// Output: alas\n}\n\nfunc ExampleFaker_Interjection() {\n\tf := New(11)\n\tfmt.Println(f.Interjection())\n\n\t// Output: alas\n}\n\nfunc BenchmarkInterjection(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tInterjection()\n\t}\n}\n"
        },
        {
          "name": "word_noun.go",
          "type": "blob",
          "size": 7.884765625,
          "content": "package gofakeit\n\n// Noun will generate a random noun\nfunc Noun() string { return noun(GlobalFaker) }\n\n// Noun will generate a random noun\nfunc (f *Faker) Noun() string { return noun(f) }\n\nfunc noun(f *Faker) string {\n\tvar nounType = map[int]string{\n\t\t0: \"noun_common\",\n\t\t1: \"noun_concrete\",\n\t\t2: \"noun_abstract\",\n\t\t3: \"noun_collective_people\",\n\t\t4: \"noun_collective_animal\",\n\t\t5: \"noun_collective_thing\",\n\t\t6: \"noun_countable\",\n\t\t7: \"noun_uncountable\",\n\t}\n\treturn getRandValue(f, []string{\"word\", nounType[number(f, 0, 7)]})\n}\n\n// NounCommon will generate a random common noun\nfunc NounCommon() string { return nounCommon(GlobalFaker) }\n\n// NounCommon will generate a random common noun\nfunc (f *Faker) NounCommon() string { return nounCommon(f) }\n\nfunc nounCommon(f *Faker) string { return getRandValue(f, []string{\"word\", \"noun_common\"}) }\n\n// NounConcrete will generate a random concrete noun\nfunc NounConcrete() string { return nounConcrete(GlobalFaker) }\n\n// NounConcrete will generate a random concrete noun\nfunc (f *Faker) NounConcrete() string { return nounConcrete(f) }\n\nfunc nounConcrete(f *Faker) string { return getRandValue(f, []string{\"word\", \"noun_concrete\"}) }\n\n// NounAbstract will generate a random abstract noun\nfunc NounAbstract() string { return nounAbstract(GlobalFaker) }\n\n// NounAbstract will generate a random abstract noun\nfunc (f *Faker) NounAbstract() string { return nounAbstract(f) }\n\nfunc nounAbstract(f *Faker) string { return getRandValue(f, []string{\"word\", \"noun_abstract\"}) }\n\n// NounCollectivePeople will generate a random collective noun person\nfunc NounCollectivePeople() string { return nounCollectivePeople(GlobalFaker) }\n\n// NounCollectivePeople will generate a random collective noun person\nfunc (f *Faker) NounCollectivePeople() string { return nounCollectivePeople(f) }\n\nfunc nounCollectivePeople(f *Faker) string {\n\treturn getRandValue(f, []string{\"word\", \"noun_collective_people\"})\n}\n\n// NounCollectiveAnimal will generate a random collective noun animal\nfunc NounCollectiveAnimal() string { return nounCollectiveAnimal(GlobalFaker) }\n\n// NounCollectiveAnimal will generate a random collective noun animal\nfunc (f *Faker) NounCollectiveAnimal() string { return nounCollectiveAnimal(f) }\n\nfunc nounCollectiveAnimal(f *Faker) string {\n\treturn getRandValue(f, []string{\"word\", \"noun_collective_animal\"})\n}\n\n// NounCollectiveThing will generate a random collective noun thing\nfunc NounCollectiveThing() string { return nounCollectiveThing(GlobalFaker) }\n\n// NounCollectiveThing will generate a random collective noun thing\nfunc (f *Faker) NounCollectiveThing() string { return nounCollectiveThing(f) }\n\nfunc nounCollectiveThing(f *Faker) string {\n\treturn getRandValue(f, []string{\"word\", \"noun_collective_thing\"})\n}\n\n// NounCountable will generate a random countable noun\nfunc NounCountable() string { return nounCountable(GlobalFaker) }\n\n// NounCountable will generate a random countable noun\nfunc (f *Faker) NounCountable() string { return nounCountable(f) }\n\nfunc nounCountable(f *Faker) string { return getRandValue(f, []string{\"word\", \"noun_countable\"}) }\n\n// NounUncountable will generate a random uncountable noun\nfunc NounUncountable() string { return nounUncountable(GlobalFaker) }\n\n// NounUncountable will generate a random uncountable noun\nfunc (f *Faker) NounUncountable() string { return nounUncountable(f) }\n\nfunc nounUncountable(f *Faker) string {\n\treturn getRandValue(f, []string{\"word\", \"noun_uncountable\"})\n}\n\n// NounProper will generate a random proper noun\nfunc NounProper() string { return nounProper(GlobalFaker) }\n\n// NounProper will generate a random proper noun\nfunc (f *Faker) NounProper() string { return nounProper(f) }\n\nfunc nounProper(f *Faker) string {\n\tswitch randInt := randIntRange(f, 1, 3); randInt {\n\tcase 1:\n\t\treturn getRandValue(f, []string{\"celebrity\", \"actor\"})\n\tcase 2:\n\t\tgenStr, _ := generate(f, getRandValue(f, []string{\"address\", \"city\"}))\n\t\treturn genStr\n\t}\n\n\treturn getRandValue(f, []string{\"person\", \"first\"})\n}\n\n// NounDeterminer will generate a random noun determiner\nfunc NounDeterminer() string { return nounDeterminer(GlobalFaker) }\n\n// NounDeterminer will generate a random noun determiner\nfunc (f *Faker) NounDeterminer() string { return nounDeterminer(f) }\n\nfunc nounDeterminer(f *Faker) string { return getRandValue(f, []string{\"word\", \"noun_determiner\"}) }\n\nfunc addWordNounLookup() {\n\tAddFuncLookup(\"noun\", Info{\n\t\tDisplay:     \"Noun\",\n\t\tCategory:    \"word\",\n\t\tDescription: \"Person, place, thing, or idea, named or referred to in a sentence\",\n\t\tExample:     \"aunt\",\n\t\tOutput:      \"string\",\n\t\tGenerate: func(f *Faker, m *MapParams, info *Info) (any, error) {\n\t\t\treturn noun(f), nil\n\t\t},\n\t})\n\n\tAddFuncLookup(\"nouncommon\", Info{\n\t\tDisplay:     \"Noun Common\",\n\t\tCategory:    \"word\",\n\t\tDescription: \"General name for people, places, or things, not specific or unique\",\n\t\tExample:     \"part\",\n\t\tOutput:      \"string\",\n\t\tGenerate: func(f *Faker, m *MapParams, info *Info) (any, error) {\n\t\t\treturn nounCommon(f), nil\n\t\t},\n\t})\n\n\tAddFuncLookup(\"nounconcrete\", Info{\n\t\tDisplay:     \"Noun Concrete\",\n\t\tCategory:    \"word\",\n\t\tDescription: \"Names for physical entities experienced through senses like sight, touch, smell, or taste\",\n\t\tExample:     \"snowman\",\n\t\tOutput:      \"string\",\n\t\tGenerate: func(f *Faker, m *MapParams, info *Info) (any, error) {\n\t\t\treturn nounConcrete(f), nil\n\t\t},\n\t})\n\n\tAddFuncLookup(\"nounabstract\", Info{\n\t\tDisplay:     \"Noun Abstract\",\n\t\tCategory:    \"word\",\n\t\tDescription: \"Ideas, qualities, or states that cannot be perceived with the five senses\",\n\t\tExample:     \"confusion\",\n\t\tOutput:      \"string\",\n\t\tGenerate: func(f *Faker, m *MapParams, info *Info) (any, error) {\n\t\t\treturn nounAbstract(f), nil\n\t\t},\n\t})\n\n\tAddFuncLookup(\"nouncollectivepeople\", Info{\n\t\tDisplay:     \"Noun Collective People\",\n\t\tCategory:    \"word\",\n\t\tDescription: \"Group of people or things regarded as a unit\",\n\t\tExample:     \"body\",\n\t\tOutput:      \"string\",\n\t\tGenerate: func(f *Faker, m *MapParams, info *Info) (any, error) {\n\t\t\treturn nounCollectivePeople(f), nil\n\t\t},\n\t})\n\n\tAddFuncLookup(\"nouncollectiveanimal\", Info{\n\t\tDisplay:     \"Noun Collective Animal\",\n\t\tCategory:    \"word\",\n\t\tDescription: \"Group of animals, like a 'pack' of wolves or a 'flock' of birds\",\n\t\tExample:     \"party\",\n\t\tOutput:      \"string\",\n\t\tGenerate: func(f *Faker, m *MapParams, info *Info) (any, error) {\n\t\t\treturn nounCollectiveAnimal(f), nil\n\t\t},\n\t})\n\n\tAddFuncLookup(\"nouncollectivething\", Info{\n\t\tDisplay:     \"Noun Collective Thing\",\n\t\tCategory:    \"word\",\n\t\tDescription: \"Group of objects or items, such as a 'bundle' of sticks or a 'cluster' of grapes\",\n\t\tExample:     \"hand\",\n\t\tOutput:      \"string\",\n\t\tGenerate: func(f *Faker, m *MapParams, info *Info) (any, error) {\n\t\t\treturn nounCollectiveThing(f), nil\n\t\t},\n\t})\n\n\tAddFuncLookup(\"nouncountable\", Info{\n\t\tDisplay:     \"Noun Countable\",\n\t\tCategory:    \"word\",\n\t\tDescription: \"Items that can be counted individually\",\n\t\tExample:     \"neck\",\n\t\tOutput:      \"string\",\n\t\tGenerate: func(f *Faker, m *MapParams, info *Info) (any, error) {\n\t\t\treturn nounCountable(f), nil\n\t\t},\n\t})\n\n\tAddFuncLookup(\"noununcountable\", Info{\n\t\tDisplay:     \"Noun Uncountable\",\n\t\tCategory:    \"word\",\n\t\tDescription: \"Items that can't be counted individually\",\n\t\tExample:     \"seafood\",\n\t\tOutput:      \"string\",\n\t\tGenerate: func(f *Faker, m *MapParams, info *Info) (any, error) {\n\t\t\treturn nounUncountable(f), nil\n\t\t},\n\t})\n\n\tAddFuncLookup(\"nounproper\", Info{\n\t\tDisplay:     \"Noun Proper\",\n\t\tCategory:    \"word\",\n\t\tDescription: \"Specific name for a particular person, place, or organization\",\n\t\tExample:     \"John\",\n\t\tOutput:      \"string\",\n\t\tGenerate: func(f *Faker, m *MapParams, info *Info) (any, error) {\n\t\t\treturn nounProper(f), nil\n\t\t},\n\t})\n\n\tAddFuncLookup(\"noundeterminer\", Info{\n\t\tDisplay:     \"Noun Determiner\",\n\t\tCategory:    \"word\",\n\t\tDescription: \"Word that introduces a noun and identifies it as a noun\",\n\t\tExample:     \"your\",\n\t\tOutput:      \"string\",\n\t\tGenerate: func(f *Faker, m *MapParams, info *Info) (any, error) {\n\t\t\treturn nounDeterminer(f), nil\n\t\t},\n\t})\n}\n"
        },
        {
          "name": "word_noun_test.go",
          "type": "blob",
          "size": 3.5576171875,
          "content": "package gofakeit\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc ExampleNoun() {\n\tSeed(11)\n\tfmt.Println(Noun())\n\n\t// Output: nest\n}\n\nfunc ExampleFaker_Noun() {\n\tf := New(11)\n\tfmt.Println(f.Noun())\n\n\t// Output: nest\n}\n\nfunc BenchmarkNoun(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tNoun()\n\t}\n}\n\nfunc ExampleNounCommon() {\n\tSeed(11)\n\tfmt.Println(NounCommon())\n\n\t// Output: group\n}\n\nfunc ExampleFaker_NounCommon() {\n\tf := New(11)\n\tfmt.Println(f.NounCommon())\n\n\t// Output: group\n}\n\nfunc BenchmarkNounCommon(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tNounCommon()\n\t}\n}\n\nfunc ExampleNounConcrete() {\n\tSeed(11)\n\tfmt.Println(NounConcrete())\n\n\t// Output: theater\n}\n\nfunc ExampleFaker_NounConcrete() {\n\tf := New(11)\n\tfmt.Println(f.NounConcrete())\n\n\t// Output: theater\n}\n\nfunc BenchmarkNounConcrete(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tNounConcrete()\n\t}\n}\n\nfunc ExampleNounAbstract() {\n\tSeed(11)\n\tfmt.Println(NounAbstract())\n\n\t// Output: speed\n}\n\nfunc ExampleFaker_NounAbstract() {\n\tf := New(11)\n\tfmt.Println(f.NounAbstract())\n\n\t// Output: speed\n}\n\nfunc BenchmarkNounAbstract(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tNounAbstract()\n\t}\n}\n\nfunc ExampleNounCollectivePeople() {\n\tSeed(11)\n\tfmt.Println(NounCollectivePeople())\n\n\t// Output: posse\n}\n\nfunc ExampleFaker_NounCollectivePeople() {\n\tf := New(11)\n\tfmt.Println(f.NounCollectivePeople())\n\n\t// Output: posse\n}\n\nfunc BenchmarkNounCollectivePeople(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tNounCollectivePeople()\n\t}\n}\n\nfunc ExampleNounCollectiveAnimal() {\n\tSeed(11)\n\tfmt.Println(NounCollectiveAnimal())\n\n\t// Output: leap\n}\n\nfunc ExampleFaker_NounCollectiveAnimal() {\n\tf := New(11)\n\tfmt.Println(f.NounCollectiveAnimal())\n\n\t// Output: leap\n}\n\nfunc BenchmarkNounCollectiveAnimal(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tNounCollectiveAnimal()\n\t}\n}\n\nfunc ExampleNounCollectiveThing() {\n\tSeed(11)\n\tfmt.Println(NounCollectiveThing())\n\n\t// Output: hail\n}\n\nfunc ExampleFaker_NounCollectiveThing() {\n\tf := New(11)\n\tfmt.Println(f.NounCollectiveThing())\n\n\t// Output: hail\n}\n\nfunc BenchmarkNounCollectiveThing(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tNounCollectiveThing()\n\t}\n}\n\nfunc ExampleNounCountable() {\n\tSeed(11)\n\tfmt.Println(NounCountable())\n\n\t// Output: smile\n}\n\nfunc ExampleFaker_NounCountable() {\n\tf := New(11)\n\tfmt.Println(f.NounCountable())\n\n\t// Output: smile\n}\n\nfunc BenchmarkNounCountable(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tNounCountable()\n\t}\n}\n\nfunc ExampleNounUncountable() {\n\tSeed(11)\n\tfmt.Println(NounUncountable())\n\n\t// Output: usage\n}\n\nfunc ExampleFaker_NounUncountable() {\n\tf := New(11)\n\tfmt.Println(f.NounUncountable())\n\n\t// Output: usage\n}\n\nfunc BenchmarkNounUncountable(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tNounUncountable()\n\t}\n}\n\nfunc ExampleNounProper() {\n\tSeed(11)\n\tfmt.Println(NounProper())\n\n\t// Output: Russ\n}\n\nfunc ExampleFaker_NounProper() {\n\tf := New(11)\n\tfmt.Println(f.NounProper())\n\n\t// Output: Russ\n}\n\nfunc TestNounProper(t *testing.T) {\n\tf := New(11)\n\tfor i := 0; i < 100; i++ {\n\t\tif f.NounProper() == \"\" {\n\t\t\tt.Errorf(\"Expected a non-empty string, got nothing\")\n\t\t}\n\t}\n}\n\nfunc BenchmarkNounProper(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tNounProper()\n\t}\n}\n\nfunc ExampleNounDeterminer() {\n\tSeed(11)\n\tfmt.Println(NounDeterminer())\n\n\t// Output: every\n}\n\nfunc ExampleFaker_NounDeterminer() {\n\tf := New(11)\n\tfmt.Println(f.NounDeterminer())\n\n\t// Output: every\n}\n\nfunc TestNounDeterminer(t *testing.T) {\n\tf := New(11)\n\tfor i := 0; i < 100; i++ {\n\t\tif f.NounDeterminer() == \"\" {\n\t\t\tt.Errorf(\"Expected a non-empty string, got nothing\")\n\t\t}\n\t}\n}\n\nfunc BenchmarkNounDeterminer(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tNounDeterminer()\n\t}\n}\n"
        },
        {
          "name": "word_phrase.go",
          "type": "blob",
          "size": 4.234375,
          "content": "package gofakeit\n\nimport (\n\t\"strings\"\n)\n\n// Phrase will return a random phrase\nfunc Phrase() string { return phrase(GlobalFaker) }\n\n// Phrase will return a random phrase\nfunc (f *Faker) Phrase() string { return phrase(f) }\n\nfunc phrase(f *Faker) string { return getRandValue(f, []string{\"sentence\", \"phrase\"}) }\n\n// PhraseNoun will return a random noun phrase\nfunc PhraseNoun() string { return phraseNoun(GlobalFaker) }\n\n// PhraseNoun will return a random noun phrase\nfunc (f *Faker) PhraseNoun() string { return phraseNoun(f) }\n\nfunc phraseNoun(f *Faker) string {\n\tstr := \"\"\n\n\t// You may also want to add an adjective to describe the noun\n\tif boolFunc(f) {\n\t\tstr = adjectiveDescriptive(f) + \" \" + noun(f)\n\t} else {\n\t\tstr = noun(f)\n\t}\n\n\t// Add determiner from weighted list\n\tprob, _ := weighted(f, []any{1, 2, 3}, []float32{2, 1.5, 1})\n\tif prob == 1 {\n\t\tstr = getArticle(str) + \" \" + str\n\t} else if prob == 2 {\n\t\tstr = \"the \" + str\n\t}\n\n\treturn str\n}\n\n// PhraseVerb will return a random preposition phrase\nfunc PhraseVerb() string { return phraseVerb(GlobalFaker) }\n\n// PhraseVerb will return a random preposition phrase\nfunc (f *Faker) PhraseVerb() string { return phraseVerb(f) }\n\nfunc phraseVerb(f *Faker) string {\n\t// Put together a string builder\n\tsb := []string{}\n\n\t// You may have an adverb phrase\n\tif boolFunc(f) {\n\t\tsb = append(sb, phraseAdverb(f))\n\t}\n\n\t// Lets add the primary verb\n\tsb = append(sb, verbAction(f))\n\n\t// You may have a noun phrase\n\tif boolFunc(f) {\n\t\tsb = append(sb, phraseNoun(f))\n\t}\n\n\t// You may have an adverb phrase\n\tif boolFunc(f) {\n\t\tsb = append(sb, phraseAdverb(f))\n\n\t\t// You may also have a preposition phrase\n\t\tif boolFunc(f) {\n\t\t\tsb = append(sb, phrasePreposition(f))\n\t\t}\n\n\t\t// You may also hae an adverb phrase\n\t\tif boolFunc(f) {\n\t\t\tsb = append(sb, phraseAdverb(f))\n\t\t}\n\t}\n\n\treturn strings.Join(sb, \" \")\n}\n\n// PhraseAdverb will return a random adverb phrase\nfunc PhraseAdverb() string { return phraseAdverb(GlobalFaker) }\n\n// PhraseAdverb will return a random adverb phrase\nfunc (f *Faker) PhraseAdverb() string { return phraseAdverb(f) }\n\nfunc phraseAdverb(f *Faker) string {\n\tif boolFunc(f) {\n\t\treturn adverbDegree(f) + \" \" + adverbManner(f)\n\t}\n\n\treturn adverbManner(f)\n}\n\n// PhrasePreposition will return a random preposition phrase\nfunc PhrasePreposition() string { return phrasePreposition(GlobalFaker) }\n\n// PhrasePreposition will return a random preposition phrase\nfunc (f *Faker) PhrasePreposition() string { return phrasePreposition(f) }\n\nfunc phrasePreposition(f *Faker) string {\n\treturn prepositionSimple(f) + \" \" + phraseNoun(f)\n}\n\nfunc addWordPhraseLookup() {\n\tAddFuncLookup(\"phrase\", Info{\n\t\tDisplay:     \"Phrase\",\n\t\tCategory:    \"word\",\n\t\tDescription: \"A small group of words standing together\",\n\t\tExample:     \"time will tell\",\n\t\tOutput:      \"string\",\n\t\tGenerate: func(f *Faker, m *MapParams, info *Info) (any, error) {\n\t\t\treturn phrase(f), nil\n\t\t},\n\t})\n\n\tAddFuncLookup(\"phrasenoun\", Info{\n\t\tDisplay:     \"Noun Phrase\",\n\t\tCategory:    \"word\",\n\t\tDescription: \"Phrase with a noun as its head, functions within sentence like a noun\",\n\t\tExample:     \"a tribe\",\n\t\tOutput:      \"string\",\n\t\tGenerate: func(f *Faker, m *MapParams, info *Info) (any, error) {\n\t\t\treturn phraseNoun(f), nil\n\t\t},\n\t})\n\n\tAddFuncLookup(\"phraseverb\", Info{\n\t\tDisplay:     \"Verb Phrase\",\n\t\tCategory:    \"word\",\n\t\tDescription: \"Phrase that Consists of a verb and its modifiers, expressing an action or state\",\n\t\tExample:     \"a tribe\",\n\t\tOutput:      \"string\",\n\t\tGenerate: func(f *Faker, m *MapParams, info *Info) (any, error) {\n\t\t\treturn phraseVerb(f), nil\n\t\t},\n\t})\n\n\tAddFuncLookup(\"phraseadverb\", Info{\n\t\tDisplay:     \"Adverb Phrase\",\n\t\tCategory:    \"word\",\n\t\tDescription: \"Phrase that modifies a verb, adjective, or another adverb, providing additional information.\",\n\t\tExample:     \"fully gladly\",\n\t\tOutput:      \"string\",\n\t\tGenerate: func(f *Faker, m *MapParams, info *Info) (any, error) {\n\t\t\treturn phraseAdverb(f), nil\n\t\t},\n\t})\n\n\tAddFuncLookup(\"phrasepreposition\", Info{\n\t\tDisplay:     \"Preposition Phrase\",\n\t\tCategory:    \"word\",\n\t\tDescription: \"Phrase starting with a preposition, showing relation between elements in a sentence.\",\n\t\tExample:     \"out the black thing\",\n\t\tOutput:      \"string\",\n\t\tGenerate: func(f *Faker, m *MapParams, info *Info) (any, error) {\n\t\t\treturn phrasePreposition(f), nil\n\t\t},\n\t})\n}\n"
        },
        {
          "name": "word_phrase_test.go",
          "type": "blob",
          "size": 1.6572265625,
          "content": "package gofakeit\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc ExamplePhrase() {\n\tSeed(11)\n\tfmt.Println(Phrase())\n\n\t// Output: how many siblings do you have\n}\n\nfunc ExampleFaker_Phrase() {\n\tf := New(11)\n\tfmt.Println(f.Phrase())\n\n\t// Output: how many siblings do you have\n}\n\nfunc BenchmarkPhrase(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tPhrase()\n\t}\n}\n\nfunc ExamplePhraseNoun() {\n\tSeed(11)\n\tfmt.Println(PhraseNoun())\n\n\t// Output: a fear\n}\n\nfunc ExampleFaker_PhraseNoun() {\n\tf := New(11)\n\tfmt.Println(f.PhraseNoun())\n\n\t// Output: a fear\n}\n\nfunc BenchmarkPhraseNoun(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tPhraseNoun()\n\t}\n}\n\nfunc ExamplePhraseVerb() {\n\tSeed(11)\n\tfmt.Println(PhraseVerb())\n\n\t// Output: bathe the jittery trip totally brightly under a troubling part scarcely unexpectedly\n}\n\nfunc ExampleFaker_PhraseVerb() {\n\tf := New(11)\n\tfmt.Println(f.PhraseVerb())\n\n\t// Output: bathe the jittery trip totally brightly under a troubling part scarcely unexpectedly\n}\n\nfunc BenchmarkPhraseVerb(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tPhraseVerb()\n\t}\n}\n\nfunc ExamplePhraseAdverb() {\n\tSeed(11)\n\tfmt.Println(PhraseAdverb())\n\n\t// Output: successfully\n}\n\nfunc ExampleFaker_PhraseAdverb() {\n\tf := New(11)\n\tfmt.Println(f.PhraseAdverb())\n\n\t// Output: successfully\n}\n\nfunc BenchmarkPhraseAdverb(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tPhraseAdverb()\n\t}\n}\n\nfunc ExamplePhrasePreposition() {\n\tSeed(11)\n\tfmt.Println(PhrasePreposition())\n\n\t// Output: with an archipelago\n}\n\nfunc ExampleFaker_PhrasePreposition() {\n\tf := New(11)\n\tfmt.Println(f.PhrasePreposition())\n\n\t// Output: with an archipelago\n}\n\nfunc BenchmarkPhrasePreposition(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tPhrasePreposition()\n\t}\n}\n"
        },
        {
          "name": "word_preposition.go",
          "type": "blob",
          "size": 3.0390625,
          "content": "package gofakeit\n\n// Preposition will generate a random preposition\nfunc Preposition() string { return preposition(GlobalFaker) }\n\n// Preposition will generate a random preposition\nfunc (f *Faker) Preposition() string { return preposition(f) }\n\nfunc preposition(f *Faker) string {\n\tvar prepType = map[int]string{\n\t\t0: \"preposition_simple\",\n\t\t1: \"preposition_double\",\n\t\t2: \"preposition_compound\",\n\t}\n\treturn getRandValue(f, []string{\"word\", prepType[number(f, 0, 2)]})\n}\n\n// PrepositionSimple will generate a random simple preposition\nfunc PrepositionSimple() string { return prepositionSimple(GlobalFaker) }\n\n// PrepositionSimple will generate a random simple preposition\nfunc (f *Faker) PrepositionSimple() string { return prepositionSimple(f) }\n\nfunc prepositionSimple(f *Faker) string {\n\treturn getRandValue(f, []string{\"word\", \"preposition_simple\"})\n}\n\n// PrepositionDouble will generate a random double preposition\nfunc PrepositionDouble() string { return prepositionDouble(GlobalFaker) }\n\n// PrepositionDouble will generate a random double preposition\nfunc (f *Faker) PrepositionDouble() string { return prepositionDouble(f) }\n\nfunc prepositionDouble(f *Faker) string {\n\treturn getRandValue(f, []string{\"word\", \"preposition_double\"})\n}\n\n// PrepositionCompound will generate a random compound preposition\nfunc PrepositionCompound() string { return prepositionCompound(GlobalFaker) }\n\n// PrepositionCompound will generate a random compound preposition\nfunc (f *Faker) PrepositionCompound() string { return prepositionCompound(f) }\n\nfunc prepositionCompound(f *Faker) string {\n\treturn getRandValue(f, []string{\"word\", \"preposition_compound\"})\n}\n\nfunc addWordPrepositionLookup() {\n\tAddFuncLookup(\"preposition\", Info{\n\t\tDisplay:     \"Preposition\",\n\t\tCategory:    \"word\",\n\t\tDescription: \"Words used to express the relationship of a noun or pronoun to other words in a sentence\",\n\t\tExample:     \"other than\",\n\t\tOutput:      \"string\",\n\t\tGenerate: func(f *Faker, m *MapParams, info *Info) (any, error) {\n\t\t\treturn preposition(f), nil\n\t\t},\n\t})\n\n\tAddFuncLookup(\"prepositionsimple\", Info{\n\t\tDisplay:     \"Preposition Simple\",\n\t\tCategory:    \"word\",\n\t\tDescription: \"Single-word preposition showing relationships between 2 parts of a sentence\",\n\t\tExample:     \"out\",\n\t\tOutput:      \"string\",\n\t\tGenerate: func(f *Faker, m *MapParams, info *Info) (any, error) {\n\t\t\treturn prepositionSimple(f), nil\n\t\t},\n\t})\n\n\tAddFuncLookup(\"prepositiondouble\", Info{\n\t\tDisplay:     \"Preposition Double\",\n\t\tCategory:    \"word\",\n\t\tDescription: \"Two-word combination preposition, indicating a complex relation\",\n\t\tExample:     \"before\",\n\t\tOutput:      \"string\",\n\t\tGenerate: func(f *Faker, m *MapParams, info *Info) (any, error) {\n\t\t\treturn prepositionDouble(f), nil\n\t\t},\n\t})\n\n\tAddFuncLookup(\"prepositioncompound\", Info{\n\t\tDisplay:     \"Preposition Compound\",\n\t\tCategory:    \"word\",\n\t\tDescription: \"Preposition that can be formed by combining two or more prepositions\",\n\t\tExample:     \"according to\",\n\t\tOutput:      \"string\",\n\t\tGenerate: func(f *Faker, m *MapParams, info *Info) (any, error) {\n\t\t\treturn prepositionCompound(f), nil\n\t\t},\n\t})\n}\n"
        },
        {
          "name": "word_preposition_test.go",
          "type": "blob",
          "size": 1.2783203125,
          "content": "package gofakeit\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc ExamplePreposition() {\n\tSeed(11)\n\tfmt.Println(Preposition())\n\n\t// Output: instead of\n}\n\nfunc ExampleFaker_Preposition() {\n\tf := New(11)\n\tfmt.Println(f.Preposition())\n\n\t// Output: instead of\n}\n\nfunc BenchmarkPreposition(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tPreposition()\n\t}\n}\n\nfunc ExamplePrepositionSimple() {\n\tSeed(11)\n\tfmt.Println(PrepositionSimple())\n\n\t// Output: with\n}\n\nfunc ExampleFaker_PrepositionSimple() {\n\tf := New(11)\n\tfmt.Println(f.PrepositionSimple())\n\n\t// Output: with\n}\n\nfunc BenchmarkPrepositionSimple(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tPrepositionSimple()\n\t}\n}\n\nfunc ExamplePrepositionDouble() {\n\tSeed(11)\n\tfmt.Println(PrepositionDouble())\n\n\t// Output: next to\n}\n\nfunc ExampleFaker_PrepositionDouble() {\n\tf := New(11)\n\tfmt.Println(f.PrepositionDouble())\n\n\t// Output: next to\n}\n\nfunc BenchmarkPrepositionDouble(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tPrepositionDouble()\n\t}\n}\n\nfunc ExamplePrepositionCompound() {\n\tSeed(11)\n\tfmt.Println(PrepositionCompound())\n\n\t// Output: other than\n}\n\nfunc ExampleFaker_PrepositionCompound() {\n\tf := New(11)\n\tfmt.Println(f.PrepositionCompound())\n\n\t// Output: other than\n}\n\nfunc BenchmarkPrepositionCompound(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tPrepositionCompound()\n\t}\n}\n"
        },
        {
          "name": "word_pronoun.go",
          "type": "blob",
          "size": 6.46484375,
          "content": "package gofakeit\n\n// Pronoun will generate a random pronoun\nfunc Pronoun() string { return pronoun(GlobalFaker) }\n\n// Pronoun will generate a random pronoun\nfunc (f *Faker) Pronoun() string { return pronoun(f) }\n\nfunc pronoun(f *Faker) string {\n\tvar pronounType = map[int]string{\n\t\t0: \"pronoun_personal\",\n\t\t1: \"pronoun_object\",\n\t\t2: \"pronoun_possessive\",\n\t\t3: \"pronoun_reflective\",\n\t\t4: \"pronoun_indefinite\",\n\t\t5: \"pronoun_demonstrative\",\n\t\t6: \"pronoun_interrogative\",\n\t\t7: \"pronoun_relative\",\n\t}\n\treturn getRandValue(f, []string{\"word\", pronounType[number(f, 0, 7)]})\n}\n\n// PronounPersonal will generate a random personal pronoun\nfunc PronounPersonal() string { return pronounPersonal(GlobalFaker) }\n\n// PronounPersonal will generate a random personal pronoun\nfunc (f *Faker) PronounPersonal() string { return pronounPersonal(f) }\n\nfunc pronounPersonal(f *Faker) string {\n\treturn getRandValue(f, []string{\"word\", \"pronoun_personal\"})\n}\n\n// PronounObject will generate a random object pronoun\nfunc PronounObject() string { return pronounObject(GlobalFaker) }\n\n// PronounObject will generate a random object pronoun\nfunc (f *Faker) PronounObject() string { return pronounObject(f) }\n\nfunc pronounObject(f *Faker) string {\n\treturn getRandValue(f, []string{\"word\", \"pronoun_object\"})\n}\n\n// PronounPossessive will generate a random possessive pronoun\nfunc PronounPossessive() string { return pronounPossessive(GlobalFaker) }\n\n// PronounPossessive will generate a random possessive pronoun\nfunc (f *Faker) PronounPossessive() string { return pronounPossessive(f) }\n\nfunc pronounPossessive(f *Faker) string {\n\treturn getRandValue(f, []string{\"word\", \"pronoun_possessive\"})\n}\n\n// PronounReflective will generate a random reflective pronoun\nfunc PronounReflective() string { return pronounReflective(GlobalFaker) }\n\n// PronounReflective will generate a random reflective pronoun\nfunc (f *Faker) PronounReflective() string { return pronounReflective(f) }\n\nfunc pronounReflective(f *Faker) string {\n\treturn getRandValue(f, []string{\"word\", \"pronoun_reflective\"})\n}\n\n// PronounIndefinite will generate a random indefinite pronoun\nfunc PronounIndefinite() string { return pronounIndefinite(GlobalFaker) }\n\n// PronounIndefinite will generate a random indefinite pronoun\nfunc (f *Faker) PronounIndefinite() string { return pronounIndefinite(f) }\n\nfunc pronounIndefinite(f *Faker) string {\n\treturn getRandValue(f, []string{\"word\", \"pronoun_indefinite\"})\n}\n\n// PronounDemonstrative will generate a random demonstrative pronoun\nfunc PronounDemonstrative() string { return pronounDemonstrative(GlobalFaker) }\n\n// PronounDemonstrative will generate a random demonstrative pronoun\nfunc (f *Faker) PronounDemonstrative() string { return pronounDemonstrative(f) }\n\nfunc pronounDemonstrative(f *Faker) string {\n\treturn getRandValue(f, []string{\"word\", \"pronoun_demonstrative\"})\n}\n\n// PronounInterrogative will generate a random interrogative pronoun\nfunc PronounInterrogative() string { return pronounInterrogative(GlobalFaker) }\n\n// PronounInterrogative will generate a random interrogative pronoun\nfunc (f *Faker) PronounInterrogative() string { return pronounInterrogative(f) }\n\nfunc pronounInterrogative(f *Faker) string {\n\treturn getRandValue(f, []string{\"word\", \"pronoun_interrogative\"})\n}\n\n// PronounRelative will generate a random relative pronoun\nfunc PronounRelative() string { return pronounRelative(GlobalFaker) }\n\n// PronounRelative will generate a random relative pronoun\nfunc (f *Faker) PronounRelative() string { return pronounRelative(f) }\n\nfunc pronounRelative(f *Faker) string {\n\treturn getRandValue(f, []string{\"word\", \"pronoun_relative\"})\n}\n\nfunc addWordPronounLookup() {\n\tAddFuncLookup(\"pronoun\", Info{\n\t\tDisplay:     \"Pronoun\",\n\t\tCategory:    \"word\",\n\t\tDescription: \"Word used in place of a noun to avoid repetition\",\n\t\tExample:     \"me\",\n\t\tOutput:      \"string\",\n\t\tGenerate: func(f *Faker, m *MapParams, info *Info) (any, error) {\n\t\t\treturn pronoun(f), nil\n\t\t},\n\t})\n\n\tAddFuncLookup(\"pronounpersonal\", Info{\n\t\tDisplay:     \"Pronoun Personal\",\n\t\tCategory:    \"word\",\n\t\tDescription: \"Pronoun referring to a specific persons or things\",\n\t\tExample:     \"it\",\n\t\tOutput:      \"string\",\n\t\tGenerate: func(f *Faker, m *MapParams, info *Info) (any, error) {\n\t\t\treturn pronounPersonal(f), nil\n\t\t},\n\t})\n\n\tAddFuncLookup(\"pronounobject\", Info{\n\t\tDisplay:     \"Pronoun Object\",\n\t\tCategory:    \"word\",\n\t\tDescription: \"Pronoun used as the object of a verb or preposition\",\n\t\tExample:     \"it\",\n\t\tOutput:      \"string\",\n\t\tGenerate: func(f *Faker, m *MapParams, info *Info) (any, error) {\n\t\t\treturn pronounObject(f), nil\n\t\t},\n\t})\n\n\tAddFuncLookup(\"pronounpossessive\", Info{\n\t\tDisplay:     \"Pronoun Possessive\",\n\t\tCategory:    \"word\",\n\t\tDescription: \"Pronoun indicating ownership or belonging\",\n\t\tExample:     \"mine\",\n\t\tOutput:      \"string\",\n\t\tGenerate: func(f *Faker, m *MapParams, info *Info) (any, error) {\n\t\t\treturn pronounPossessive(f), nil\n\t\t},\n\t})\n\n\tAddFuncLookup(\"pronounreflective\", Info{\n\t\tDisplay:     \"Pronoun Reflective\",\n\t\tCategory:    \"word\",\n\t\tDescription: \"Pronoun referring back to the subject of the sentence\",\n\t\tExample:     \"myself\",\n\t\tOutput:      \"string\",\n\t\tGenerate: func(f *Faker, m *MapParams, info *Info) (any, error) {\n\t\t\treturn pronounReflective(f), nil\n\t\t},\n\t})\n\n\tAddFuncLookup(\"pronounindefinite\", Info{\n\t\tDisplay:     \"Pronoun Indefinite\",\n\t\tCategory:    \"word\",\n\t\tDescription: \"Pronoun that does not refer to a specific person or thing\",\n\t\tExample:     \"few\",\n\t\tOutput:      \"string\",\n\t\tGenerate: func(f *Faker, m *MapParams, info *Info) (any, error) {\n\t\t\treturn pronounIndefinite(f), nil\n\t\t},\n\t})\n\n\tAddFuncLookup(\"pronoundemonstrative\", Info{\n\t\tDisplay:     \"Pronoun Demonstrative\",\n\t\tCategory:    \"word\",\n\t\tDescription: \"Pronoun that points out specific people or things\",\n\t\tExample:     \"this\",\n\t\tOutput:      \"string\",\n\t\tGenerate: func(f *Faker, m *MapParams, info *Info) (any, error) {\n\t\t\treturn pronounDemonstrative(f), nil\n\t\t},\n\t})\n\n\tAddFuncLookup(\"pronouninterrogative\", Info{\n\t\tDisplay:     \"Pronoun Interrogative\",\n\t\tCategory:    \"word\",\n\t\tDescription: \"Pronoun used to ask questions\",\n\t\tExample:     \"what\",\n\t\tOutput:      \"string\",\n\t\tGenerate: func(f *Faker, m *MapParams, info *Info) (any, error) {\n\t\t\treturn pronounInterrogative(f), nil\n\t\t},\n\t})\n\n\tAddFuncLookup(\"pronounrelative\", Info{\n\t\tDisplay:     \"Pronoun Relative\",\n\t\tCategory:    \"word\",\n\t\tDescription: \"Pronoun that introduces a clause, referring back to a noun or pronoun\",\n\t\tExample:     \"as\",\n\t\tOutput:      \"string\",\n\t\tGenerate: func(f *Faker, m *MapParams, info *Info) (any, error) {\n\t\t\treturn pronounRelative(f), nil\n\t\t},\n\t})\n}\n"
        },
        {
          "name": "word_pronoun_test.go",
          "type": "blob",
          "size": 2.7568359375,
          "content": "package gofakeit\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc ExamplePronoun() {\n\tSeed(11)\n\tfmt.Println(Pronoun())\n\n\t// Output: some\n}\n\nfunc ExampleFaker_Pronoun() {\n\tf := New(11)\n\tfmt.Println(f.Pronoun())\n\n\t// Output: some\n}\n\nfunc BenchmarkPronoun(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tPronoun()\n\t}\n}\n\nfunc ExamplePronounPersonal() {\n\tSeed(11)\n\tfmt.Println(PronounPersonal())\n\n\t// Output: they\n}\n\nfunc ExampleFaker_PronounPersonal() {\n\tf := New(11)\n\tfmt.Println(f.PronounPersonal())\n\n\t// Output: they\n}\n\nfunc BenchmarkPronounPersonal(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tPronounPersonal()\n\t}\n}\n\nfunc ExamplePronounObject() {\n\tSeed(11)\n\tfmt.Println(PronounObject())\n\n\t// Output: them\n}\n\nfunc ExampleFaker_PronounObject() {\n\tf := New(11)\n\tfmt.Println(f.PronounObject())\n\n\t// Output: them\n}\n\nfunc BenchmarkPronounObject(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tPronounObject()\n\t}\n}\n\nfunc ExamplePronounPossessive() {\n\tSeed(11)\n\tfmt.Println(PronounPossessive())\n\n\t// Output: theirs\n}\n\nfunc ExampleFaker_PronounPossessive() {\n\tf := New(11)\n\tfmt.Println(f.PronounPossessive())\n\n\t// Output: theirs\n}\n\nfunc BenchmarkPronounPossessive(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tPronounPossessive()\n\t}\n}\n\nfunc ExamplePronounReflective() {\n\tSeed(11)\n\tfmt.Println(PronounReflective())\n\n\t// Output: itself\n}\n\nfunc ExampleFaker_PronounReflective() {\n\tf := New(11)\n\tfmt.Println(f.PronounReflective())\n\n\t// Output: itself\n}\n\nfunc BenchmarkPronounReflective(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tPronounReflective()\n\t}\n}\n\nfunc ExamplePronounIndefinite() {\n\tSeed(11)\n\tfmt.Println(PronounIndefinite())\n\n\t// Output: somebody\n}\n\nfunc ExampleFaker_PronounIndefinite() {\n\tf := New(11)\n\tfmt.Println(f.PronounIndefinite())\n\n\t// Output: somebody\n}\n\nfunc BenchmarkPronounIndefinite(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tPronounIndefinite()\n\t}\n}\n\nfunc ExamplePronounDemonstrative() {\n\tSeed(11)\n\tfmt.Println(PronounDemonstrative())\n\n\t// Output: this\n}\n\nfunc ExampleFaker_PronounDemonstrative() {\n\tf := New(11)\n\tfmt.Println(f.PronounDemonstrative())\n\n\t// Output: this\n}\n\nfunc BenchmarkPronounDemonstrative(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tPronounDemonstrative()\n\t}\n}\n\nfunc ExamplePronounInterrogative() {\n\tSeed(11)\n\tfmt.Println(PronounInterrogative())\n\n\t// Output: how\n}\n\nfunc ExampleFaker_PronounInterrogative() {\n\tf := New(11)\n\tfmt.Println(f.PronounInterrogative())\n\n\t// Output: how\n}\n\nfunc BenchmarkPronounInterrogative(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tPronounInterrogative()\n\t}\n}\n\nfunc ExamplePronounRelative() {\n\tSeed(11)\n\tfmt.Println(PronounRelative())\n\n\t// Output: whomever\n}\n\nfunc ExampleFaker_PronounRelative() {\n\tf := New(11)\n\tfmt.Println(f.PronounRelative())\n\n\t// Output: whomever\n}\n\nfunc BenchmarkPronounRelative(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tPronounRelative()\n\t}\n}\n"
        },
        {
          "name": "word_sentence.go",
          "type": "blob",
          "size": 6.7666015625,
          "content": "package gofakeit\n\nimport (\n\t\"bytes\"\n\t\"errors\"\n\t\"strings\"\n\t\"unicode\"\n)\n\ntype paragrapOptions struct {\n\tparagraphCount int\n\tsentenceCount  int\n\twordCount      int\n\tseparator      string\n}\n\nconst bytesPerWordEstimation = 6\n\ntype sentenceGenerator func(f *Faker, wordCount int) string\ntype wordGenerator func(f *Faker) string\n\n// Sentence will generate a random sentence\nfunc Sentence(wordCount int) string { return sentence(GlobalFaker, wordCount) }\n\n// Sentence will generate a random sentence\nfunc (f *Faker) Sentence(wordCount int) string { return sentence(f, wordCount) }\n\nfunc sentence(f *Faker, wordCount int) string {\n\treturn sentenceGen(f, wordCount, word)\n}\n\n// Paragraph will generate a random paragraphGenerator\nfunc Paragraph(paragraphCount int, sentenceCount int, wordCount int, separator string) string {\n\treturn paragraph(GlobalFaker, paragraphCount, sentenceCount, wordCount, separator)\n}\n\n// Paragraph will generate a random paragraphGenerator\nfunc (f *Faker) Paragraph(paragraphCount int, sentenceCount int, wordCount int, separator string) string {\n\treturn paragraph(f, paragraphCount, sentenceCount, wordCount, separator)\n}\n\nfunc paragraph(f *Faker, paragraphCount int, sentenceCount int, wordCount int, separator string) string {\n\treturn paragraphGen(f, paragrapOptions{paragraphCount, sentenceCount, wordCount, separator}, sentence)\n}\n\nfunc sentenceGen(f *Faker, wordCount int, word wordGenerator) string {\n\tif wordCount <= 0 {\n\t\treturn \"\"\n\t}\n\n\twordSeparator := ' '\n\tsentence := bytes.Buffer{}\n\tsentence.Grow(wordCount * bytesPerWordEstimation)\n\n\tfor i := 0; i < wordCount; i++ {\n\t\tword := word(f)\n\t\tif i == 0 {\n\t\t\trunes := []rune(word)\n\t\t\trunes[0] = unicode.ToTitle(runes[0])\n\t\t\tword = string(runes)\n\t\t}\n\t\tsentence.WriteString(word)\n\t\tif i < wordCount-1 {\n\t\t\tsentence.WriteRune(wordSeparator)\n\t\t}\n\t}\n\tsentence.WriteRune('.')\n\treturn sentence.String()\n}\n\nfunc paragraphGen(f *Faker, opts paragrapOptions, sentecer sentenceGenerator) string {\n\tif opts.paragraphCount <= 0 || opts.sentenceCount <= 0 || opts.wordCount <= 0 {\n\t\treturn \"\"\n\t}\n\n\t//to avoid making Go 1.10 dependency, we cannot use strings.Builder\n\tparagraphs := bytes.Buffer{}\n\t//we presume the length\n\tparagraphs.Grow(opts.paragraphCount * opts.sentenceCount * opts.wordCount * bytesPerWordEstimation)\n\twordSeparator := ' '\n\n\tfor i := 0; i < opts.paragraphCount; i++ {\n\t\tfor e := 0; e < opts.sentenceCount; e++ {\n\t\t\tparagraphs.WriteString(sentecer(f, opts.wordCount))\n\t\t\tif e < opts.sentenceCount-1 {\n\t\t\t\tparagraphs.WriteRune(wordSeparator)\n\t\t\t}\n\t\t}\n\n\t\tif i < opts.paragraphCount-1 {\n\t\t\tparagraphs.WriteString(opts.separator)\n\t\t}\n\t}\n\n\treturn paragraphs.String()\n}\n\n// Question will return a random question\nfunc Question() string {\n\treturn question(GlobalFaker)\n}\n\n// Question will return a random question\nfunc (f *Faker) Question() string {\n\treturn question(f)\n}\n\nfunc question(f *Faker) string {\n\treturn strings.Replace(hipsterSentence(f, number(f, 3, 10)), \".\", \"?\", 1)\n}\n\n// Quote will return a random quote from a random person\nfunc Quote() string { return quote(GlobalFaker) }\n\n// Quote will return a random quote from a random person\nfunc (f *Faker) Quote() string { return quote(f) }\n\nfunc quote(f *Faker) string {\n\treturn `\"` + hipsterSentence(f, number(f, 3, 10)) + `\" - ` + firstName(f) + \" \" + lastName(f)\n}\n\nfunc addWordSentenceLookup() {\n\tAddFuncLookup(\"sentence\", Info{\n\t\tDisplay:     \"Sentence\",\n\t\tCategory:    \"word\",\n\t\tDescription: \"Set of words expressing a statement, question, exclamation, or command\",\n\t\tExample:     \"Interpret context record river mind.\",\n\t\tOutput:      \"string\",\n\t\tParams: []Param{\n\t\t\t{Field: \"wordcount\", Display: \"Word Count\", Type: \"int\", Default: \"5\", Description: \"Number of words in a sentence\"},\n\t\t},\n\t\tGenerate: func(f *Faker, m *MapParams, info *Info) (any, error) {\n\t\t\twordCount, err := info.GetInt(m, \"wordcount\")\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\tif wordCount <= 0 || wordCount > 50 {\n\t\t\t\treturn nil, errors.New(\"invalid word count, must be greater than 0, less than 50\")\n\t\t\t}\n\n\t\t\treturn sentence(f, wordCount), nil\n\t\t},\n\t})\n\n\tAddFuncLookup(\"paragraph\", Info{\n\t\tDisplay:     \"Paragraph\",\n\t\tCategory:    \"word\",\n\t\tDescription: \"Distinct section of writing covering a single theme, composed of multiple sentences\",\n\t\tExample:     \"Interpret context record river mind press self should compare property outcome divide. Combine approach sustain consult discover explanation direct address church husband seek army. Begin own act welfare replace press suspect stay link place manchester specialist. Arrive price satisfy sign force application hair train provide basis right pay. Close mark teacher strengthen information attempt head touch aim iron tv take.\",\n\t\tOutput:      \"string\",\n\t\tParams: []Param{\n\t\t\t{Field: \"paragraphcount\", Display: \"Paragraph Count\", Type: \"int\", Default: \"2\", Description: \"Number of paragraphs\"},\n\t\t\t{Field: \"sentencecount\", Display: \"Sentence Count\", Type: \"int\", Default: \"2\", Description: \"Number of sentences in a paragraph\"},\n\t\t\t{Field: \"wordcount\", Display: \"Word Count\", Type: \"int\", Default: \"5\", Description: \"Number of words in a sentence\"},\n\t\t\t{Field: \"paragraphseparator\", Display: \"Paragraph Separator\", Type: \"string\", Default: \"<br />\", Description: \"String value to add between paragraphs\"},\n\t\t},\n\t\tGenerate: func(f *Faker, m *MapParams, info *Info) (any, error) {\n\t\t\tparagraphCount, err := info.GetInt(m, \"paragraphcount\")\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\tif paragraphCount <= 0 || paragraphCount > 20 {\n\t\t\t\treturn nil, errors.New(\"invalid paragraph count, must be greater than 0, less than 20\")\n\t\t\t}\n\n\t\t\tsentenceCount, err := info.GetInt(m, \"sentencecount\")\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\tif sentenceCount <= 0 || sentenceCount > 20 {\n\t\t\t\treturn nil, errors.New(\"invalid sentence count, must be greater than 0, less than 20\")\n\t\t\t}\n\n\t\t\twordCount, err := info.GetInt(m, \"wordcount\")\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\tif wordCount <= 0 || wordCount > 50 {\n\t\t\t\treturn nil, errors.New(\"invalid word count, must be greater than 0, less than 50\")\n\t\t\t}\n\n\t\t\tparagraphSeparator, err := info.GetString(m, \"paragraphseparator\")\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\n\t\t\treturn paragraph(f, paragraphCount, sentenceCount, wordCount, paragraphSeparator), nil\n\t\t},\n\t})\n\n\tAddFuncLookup(\"question\", Info{\n\t\tDisplay:     \"Question\",\n\t\tCategory:    \"word\",\n\t\tDescription: \"Statement formulated to inquire or seek clarification\",\n\t\tExample:     \"Roof chia echo?\",\n\t\tOutput:      \"string\",\n\t\tGenerate: func(f *Faker, m *MapParams, info *Info) (any, error) {\n\t\t\treturn question(f), nil\n\t\t},\n\t})\n\n\tAddFuncLookup(\"quote\", Info{\n\t\tDisplay:     \"Quote\",\n\t\tCategory:    \"word\",\n\t\tDescription: \"Direct repetition of someone else's words\",\n\t\tExample:     `\"Roof chia echo.\" - Lura Lockman`,\n\t\tOutput:      \"string\",\n\t\tGenerate: func(f *Faker, m *MapParams, info *Info) (any, error) {\n\t\t\treturn quote(f), nil\n\t\t},\n\t})\n}\n"
        },
        {
          "name": "word_sentence_test.go",
          "type": "blob",
          "size": 4.5478515625,
          "content": "package gofakeit\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\t\"testing\"\n)\n\nfunc ExampleSentence() {\n\tSeed(11)\n\tfmt.Println(Sentence(5))\n\n\t// Output: Bathe regularly quiver these sprint.\n}\n\nfunc ExampleFaker_Sentence() {\n\tf := New(11)\n\tfmt.Println(f.Sentence(5))\n\n\t// Output: Bathe regularly quiver these sprint.\n}\n\nfunc TestSentence(t *testing.T) {\n\tfor i := 0; i < 1000; i++ {\n\t\tlength := len(strings.Split(Sentence(10), \" \"))\n\t\tif length != 10 {\n\t\t\tt.Errorf(\"result should have a length of 10 got %d\", length)\n\t\t}\n\t}\n\n\tfor _, count := range []int{-100, -1, 0} {\n\t\tif Sentence(count) != \"\" {\n\t\t\tt.Errorf(\"result should be blank for %d words\", count)\n\t\t}\n\t}\n}\n\nfunc BenchmarkSentence(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tSentence(10)\n\t}\n}\n\nfunc ExampleParagraph() {\n\tSeed(11)\n\tfmt.Println(Paragraph(3, 5, 12, \"\\n\"))\n\n\t// Output: Bathe regularly quiver these sprint fight something am elsewhere since previously was. That there a tennis occur why depend heels out can fire anyone. Sometimes that leap whom troop now scarcely since dance huh somebody constantly. Italian outfit certain weekly murder who cackle because her break write nobody. Could according whoa bevy we them summation to oxygen Greek how previously.\n\t// A what answer handle daily ouch upon encourage that after his every. She wearily still he herself huge failure for yay sparse thoughtfully box. Anyway Jungian regularly world great daily recently whose Elizabethan outside to theirs. Block while French closely sit you to out fight bored yours those. Bale Parisian host which so today Ecuadorian hourly decidedly his everybody this.\n\t// Play this little them on recently eager usually bunch daily whose somebody. Them few tonight dishonesty spell battery less patience whose inside hair your. Answer hand tonight these she team which today Einsteinian country yesterday for. Phew for now your him hourly infrequently lots drink absolutely when east. Conclude little annually hers nobody since troop it it whoever the park.\n}\n\nfunc ExampleFaker_Paragraph() {\n\tf := New(11)\n\tfmt.Println(f.Paragraph(3, 5, 12, \"\\n\"))\n\n\t// Output: Bathe regularly quiver these sprint fight something am elsewhere since previously was. That there a tennis occur why depend heels out can fire anyone. Sometimes that leap whom troop now scarcely since dance huh somebody constantly. Italian outfit certain weekly murder who cackle because her break write nobody. Could according whoa bevy we them summation to oxygen Greek how previously.\n\t// A what answer handle daily ouch upon encourage that after his every. She wearily still he herself huge failure for yay sparse thoughtfully box. Anyway Jungian regularly world great daily recently whose Elizabethan outside to theirs. Block while French closely sit you to out fight bored yours those. Bale Parisian host which so today Ecuadorian hourly decidedly his everybody this.\n\t// Play this little them on recently eager usually bunch daily whose somebody. Them few tonight dishonesty spell battery less patience whose inside hair your. Answer hand tonight these she team which today Einsteinian country yesterday for. Phew for now your him hourly infrequently lots drink absolutely when east. Conclude little annually hers nobody since troop it it whoever the park.\n}\n\nfunc TestParagraph(t *testing.T) {\n\tfor _, count := range []struct{ parag, sent, words int }{\n\t\t{1, 1, 0},\n\t\t{1, 0, 1},\n\t\t{0, 1, 1},\n\t\t{1, 1, -100},\n\t\t{1, -100, 1},\n\t\t{-100, 1, 1},\n\t\t{0, 0, 0},\n\t} {\n\t\tif Paragraph(count.parag, count.sent, count.words, \" \") != \"\" {\n\t\t\tt.Errorf(\"result should be blank for %v input\", count)\n\t\t}\n\t}\n}\n\nfunc BenchmarkParagraph(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tParagraph(3, 5, 12, \"\\n\")\n\t}\n}\n\nfunc ExampleQuestion() {\n\tSeed(11)\n\tfmt.Println(Question())\n\n\t// Output: Everyday you probably haven't heard of them you probably haven't heard of them portland austin tattooed retro?\n}\n\nfunc ExampleFaker_Question() {\n\tf := New(11)\n\tfmt.Println(f.Question())\n\n\t// Output: Everyday you probably haven't heard of them you probably haven't heard of them portland austin tattooed retro?\n}\n\nfunc BenchmarkQuestion(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tQuestion()\n\t}\n}\n\nfunc ExampleQuote() {\n\tSeed(11)\n\tfmt.Println(Quote())\n\n\t// Output: \"Everyday you probably haven't heard of them you probably haven't heard of them portland austin tattooed retro.\" - Vance Schroeder\n}\n\nfunc ExampleFaker_Quote() {\n\tf := New(11)\n\tfmt.Println(f.Quote())\n\n\t// Output: \"Everyday you probably haven't heard of them you probably haven't heard of them portland austin tattooed retro.\" - Vance Schroeder\n}\n\nfunc BenchmarkQuote(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tQuote()\n\t}\n}\n"
        },
        {
          "name": "word_verb.go",
          "type": "blob",
          "size": 3.9462890625,
          "content": "package gofakeit\n\n// Verb will generate a random verb\nfunc Verb() string { return verb(GlobalFaker) }\n\n// Verb will generate a random verb\nfunc (f *Faker) Verb() string { return verb(f) }\n\nfunc verb(f *Faker) string {\n\tvar verbType = map[int]string{\n\t\t0: \"verb_action\",\n\t\t1: \"verb_linking\",\n\t\t2: \"verb_helping\",\n\t}\n\treturn getRandValue(f, []string{\"word\", verbType[number(f, 0, 2)]})\n}\n\n// VerbAction will generate a random action verb\nfunc VerbAction() string { return verbAction(GlobalFaker) }\n\n// VerbAction will generate a random action verb\nfunc (f *Faker) VerbAction() string { return verbAction(f) }\n\nfunc verbAction(f *Faker) string { return getRandValue(f, []string{\"word\", \"verb_action\"}) }\n\n// VerbTransitive will generate a random transitive verb\nfunc VerbTransitive() string { return verbTransitive(GlobalFaker) }\n\n// VerbTransitive will generate a random transitive verb\nfunc (f *Faker) VerbTransitive() string { return verbTransitive(f) }\n\nfunc verbTransitive(f *Faker) string { return getRandValue(f, []string{\"word\", \"verb_transitive\"}) }\n\n// VerbIntransitive will generate a random intransitive verb\nfunc VerbIntransitive() string { return verbIntransitive(GlobalFaker) }\n\n// VerbIntransitive will generate a random intransitive verb\nfunc (f *Faker) VerbIntransitive() string { return verbIntransitive(f) }\n\nfunc verbIntransitive(f *Faker) string {\n\treturn getRandValue(f, []string{\"word\", \"verb_intransitive\"})\n}\n\n// VerbLinking will generate a random linking verb\nfunc VerbLinking() string { return verbLinking(GlobalFaker) }\n\n// VerbLinking will generate a random linking verb\nfunc (f *Faker) VerbLinking() string { return verbLinking(f) }\n\nfunc verbLinking(f *Faker) string { return getRandValue(f, []string{\"word\", \"verb_linking\"}) }\n\n// VerbHelping will generate a random helping verb\nfunc VerbHelping() string { return verbHelping(GlobalFaker) }\n\n// VerbHelping will generate a random helping verb\nfunc (f *Faker) VerbHelping() string { return verbHelping(f) }\n\nfunc verbHelping(f *Faker) string { return getRandValue(f, []string{\"word\", \"verb_helping\"}) }\n\nfunc addWordVerbLookup() {\n\tAddFuncLookup(\"verb\", Info{\n\t\tDisplay:     \"Verb\",\n\t\tCategory:    \"word\",\n\t\tDescription: \"Word expressing an action, event or state\",\n\t\tExample:     \"release\",\n\t\tOutput:      \"string\",\n\t\tGenerate: func(f *Faker, m *MapParams, info *Info) (any, error) {\n\t\t\treturn verb(f), nil\n\t\t},\n\t})\n\n\tAddFuncLookup(\"verbaction\", Info{\n\t\tDisplay:     \"Action Verb\",\n\t\tCategory:    \"word\",\n\t\tDescription: \"Verb Indicating a physical or mental action\",\n\t\tExample:     \"close\",\n\t\tOutput:      \"string\",\n\t\tGenerate: func(f *Faker, m *MapParams, info *Info) (any, error) {\n\t\t\treturn verbAction(f), nil\n\t\t},\n\t})\n\n\tAddFuncLookup(\"verbtransitive\", Info{\n\t\tDisplay:     \"Transitive Verb\",\n\t\tCategory:    \"word\",\n\t\tDescription: \"Verb that requires a direct object to complete its meaning\",\n\t\tExample:     \"follow\",\n\t\tOutput:      \"string\",\n\t\tGenerate: func(f *Faker, m *MapParams, info *Info) (any, error) {\n\t\t\treturn verbTransitive(f), nil\n\t\t},\n\t})\n\n\tAddFuncLookup(\"verbintransitive\", Info{\n\t\tDisplay:     \"Intransitive Verb\",\n\t\tCategory:    \"word\",\n\t\tDescription: \"Verb that does not require a direct object to complete its meaning\",\n\t\tExample:     \"laugh\",\n\t\tOutput:      \"string\",\n\t\tGenerate: func(f *Faker, m *MapParams, info *Info) (any, error) {\n\t\t\treturn verbIntransitive(f), nil\n\t\t},\n\t})\n\n\tAddFuncLookup(\"verblinking\", Info{\n\t\tDisplay:     \"Linking Verb\",\n\t\tCategory:    \"word\",\n\t\tDescription: \"Verb that Connects the subject of a sentence to a subject complement\",\n\t\tExample:     \"was\",\n\t\tOutput:      \"string\",\n\t\tGenerate: func(f *Faker, m *MapParams, info *Info) (any, error) {\n\t\t\treturn verbLinking(f), nil\n\t\t},\n\t})\n\n\tAddFuncLookup(\"verbhelping\", Info{\n\t\tDisplay:     \"Helping Verb\",\n\t\tCategory:    \"word\",\n\t\tDescription: \"Auxiliary verb that helps the main verb complete the sentence\",\n\t\tExample:     \"be\",\n\t\tOutput:      \"string\",\n\t\tGenerate: func(f *Faker, m *MapParams, info *Info) (any, error) {\n\t\t\treturn verbHelping(f), nil\n\t\t},\n\t})\n}\n"
        },
        {
          "name": "word_verb_test.go",
          "type": "blob",
          "size": 1.6826171875,
          "content": "package gofakeit\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc ExampleVerb() {\n\tSeed(11)\n\tfmt.Println(Verb())\n\n\t// Output: would\n}\n\nfunc ExampleFaker_Verb() {\n\tf := New(11)\n\tfmt.Println(f.Verb())\n\n\t// Output: would\n}\n\nfunc BenchmarkVerb(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tVerb()\n\t}\n}\n\nfunc ExampleVerbAction() {\n\tSeed(11)\n\tfmt.Println(VerbAction())\n\n\t// Output: paint\n}\n\nfunc ExampleFaker_VerbAction() {\n\tf := New(11)\n\tfmt.Println(f.VerbAction())\n\n\t// Output: paint\n}\n\nfunc BenchmarkVerbAction(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tVerbAction()\n\t}\n}\n\nfunc ExampleVerbTransitive() {\n\tSeed(11)\n\tfmt.Println(VerbTransitive())\n\n\t// Output: upgrade\n}\n\nfunc ExampleFaker_VerbTransitive() {\n\tf := New(11)\n\tfmt.Println(f.VerbTransitive())\n\n\t// Output: upgrade\n}\n\nfunc BenchmarkVerbTransitive(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tVerbTransitive()\n\t}\n}\n\nfunc ExampleVerbIntransitive() {\n\tSeed(11)\n\tfmt.Println(VerbIntransitive())\n\n\t// Output: vomit\n}\n\nfunc ExampleFaker_VerbIntransitive() {\n\tf := New(11)\n\tfmt.Println(f.VerbIntransitive())\n\n\t// Output: vomit\n}\n\nfunc BenchmarkVerbIntransitive(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tVerbIntransitive()\n\t}\n}\n\nfunc ExampleVerbLinking() {\n\tSeed(11)\n\tfmt.Println(VerbLinking())\n\n\t// Output: must\n}\n\nfunc ExampleFaker_VerbLinking() {\n\tf := New(11)\n\tfmt.Println(f.VerbLinking())\n\n\t// Output: must\n}\n\nfunc BenchmarkVerbLinking(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tVerbLinking()\n\t}\n}\n\nfunc ExampleVerbHelping() {\n\tSeed(11)\n\tfmt.Println(VerbHelping())\n\n\t// Output: am\n}\n\nfunc ExampleFaker_VerbHelping() {\n\tf := New(11)\n\tfmt.Println(f.VerbHelping())\n\n\t// Output: am\n}\n\nfunc BenchmarkVerbHelping(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tVerbHelping()\n\t}\n}\n"
        },
        {
          "name": "xml.go",
          "type": "blob",
          "size": 8.5166015625,
          "content": "package gofakeit\n\nimport (\n\t\"bytes\"\n\t\"encoding/json\"\n\t\"encoding/xml\"\n\t\"errors\"\n\t\"reflect\"\n)\n\n// XMLOptions defines values needed for json generation\ntype XMLOptions struct {\n\tType          string  `json:\"type\" xml:\"type\" fake:\"{randomstring:[array,single]}\"` // single or array\n\tRootElement   string  `json:\"root_element\" xml:\"root_element\"`\n\tRecordElement string  `json:\"record_element\" xml:\"record_element\"`\n\tRowCount      int     `json:\"row_count\" xml:\"row_count\" fake:\"{number:1,10}\"`\n\tIndent        bool    `json:\"indent\" xml:\"indent\"`\n\tFields        []Field `json:\"fields\" xml:\"fields\" fake:\"{fields}\"`\n}\n\ntype xmlArray struct {\n\tXMLName xml.Name\n\tArray   []xmlMap\n}\n\ntype xmlMap struct {\n\tXMLName  xml.Name\n\tKeyOrder []string\n\tMap      map[string]any `xml:\",chardata\"`\n}\n\ntype xmlEntry struct {\n\tXMLName xml.Name\n\tValue   any `xml:\",chardata\"`\n}\n\nfunc (m xmlMap) MarshalXML(e *xml.Encoder, start xml.StartElement) error {\n\tif len(m.Map) == 0 {\n\t\treturn nil\n\t}\n\n\tstart.Name = m.XMLName\n\n\terr := e.EncodeToken(start)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\terr = xmlMapLoop(e, &m)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn e.EncodeToken(start.End())\n}\n\nfunc xmlMapLoop(e *xml.Encoder, m *xmlMap) error {\n\tvar err error\n\n\t// Check if xmlmap has key order if not create it\n\t// Get key order by order of fields array\n\tif m.KeyOrder == nil {\n\t\tm.KeyOrder = make([]string, len(m.Map))\n\t\tfor k := range m.Map {\n\t\t\tm.KeyOrder = append(m.KeyOrder, k)\n\t\t}\n\t}\n\n\tfor _, key := range m.KeyOrder {\n\t\tv := reflect.ValueOf(m.Map[key])\n\n\t\t// Always get underlyning Value of value\n\t\tif v.Kind() == reflect.Ptr {\n\t\t\tv = reflect.Indirect(v)\n\t\t}\n\n\t\tswitch v.Kind() {\n\t\tcase reflect.Bool,\n\t\t\treflect.String,\n\t\t\treflect.Int, reflect.Int8, reflect.Int32, reflect.Int64,\n\t\t\treflect.Uint, reflect.Uint8, reflect.Uint32, reflect.Uint64,\n\t\t\treflect.Float32, reflect.Float64:\n\t\t\terr = e.Encode(xmlEntry{XMLName: xml.Name{Local: key}, Value: m.Map[key]})\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\tcase reflect.Slice:\n\t\t\te.EncodeToken(xml.StartElement{Name: xml.Name{Local: key}})\n\t\t\tfor i := 0; i < v.Len(); i++ {\n\t\t\t\terr = e.Encode(xmlEntry{XMLName: xml.Name{Local: \"value\"}, Value: v.Index(i).String()})\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t}\n\t\t\te.EncodeToken(xml.EndElement{Name: xml.Name{Local: key}})\n\t\tcase reflect.Map:\n\t\t\terr = e.Encode(xmlMap{\n\t\t\t\tXMLName: xml.Name{Local: key},\n\t\t\t\tMap:     m.Map[key].(map[string]any),\n\t\t\t})\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\tcase reflect.Struct:\n\t\t\t// Convert struct to map[string]any\n\t\t\t// So we can rewrap element\n\t\t\tvar inInterface map[string]any\n\t\t\tinrec, _ := json.Marshal(m.Map[key])\n\t\t\tjson.Unmarshal(inrec, &inInterface)\n\n\t\t\terr = e.Encode(xmlMap{\n\t\t\t\tXMLName: xml.Name{Local: key},\n\t\t\t\tMap:     inInterface,\n\t\t\t})\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\tdefault:\n\t\t\terr = e.Encode(m.Map[key])\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t}\n\n\treturn nil\n}\n\n// XML generates an object or an array of objects in json format\n// A nil XMLOptions returns a randomly structured XML.\nfunc XML(xo *XMLOptions) ([]byte, error) { return xmlFunc(GlobalFaker, xo) }\n\n// XML generates an object or an array of objects in json format\n// A nil XMLOptions returns a randomly structured XML.\nfunc (f *Faker) XML(xo *XMLOptions) ([]byte, error) { return xmlFunc(f, xo) }\n\nfunc xmlFunc(f *Faker, xo *XMLOptions) ([]byte, error) {\n\tif xo == nil {\n\t\t// We didn't get a XMLOptions, so create a new random one\n\t\terr := f.Struct(&xo)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\t// Check to make sure they passed in a type\n\tif xo.Type != \"single\" && xo.Type != \"array\" {\n\t\treturn nil, errors.New(\"invalid type, must be array or object\")\n\t}\n\n\t// Check fields length\n\tif xo.Fields == nil || len(xo.Fields) <= 0 {\n\t\treturn nil, errors.New(\"must pass fields in order to build json object(s)\")\n\t}\n\n\t// Check root element string\n\tif xo.RootElement == \"\" {\n\t\txo.RecordElement = \"xml\"\n\t}\n\n\t// Check record element string\n\tif xo.RecordElement == \"\" {\n\t\txo.RecordElement = \"record\"\n\t}\n\n\t// Get key order by order of fields array\n\tkeyOrder := make([]string, 0, len(xo.Fields))\n\tfor _, f := range xo.Fields {\n\t\tkeyOrder = append(keyOrder, f.Name)\n\t}\n\n\tif xo.Type == \"single\" {\n\t\tv := xmlMap{\n\t\t\tXMLName:  xml.Name{Local: xo.RootElement},\n\t\t\tKeyOrder: keyOrder,\n\t\t\tMap:      make(map[string]any),\n\t\t}\n\n\t\t// Loop through fields and add to them to map[string]any\n\t\tfor _, field := range xo.Fields {\n\t\t\t// Get function info\n\t\t\tfuncInfo := GetFuncLookup(field.Function)\n\t\t\tif funcInfo == nil {\n\t\t\t\treturn nil, errors.New(\"invalid function, \" + field.Function + \" does not exist\")\n\t\t\t}\n\n\t\t\tvalue, err := funcInfo.Generate(f, &field.Params, funcInfo)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\n\t\t\tv.Map[field.Name] = value\n\t\t}\n\n\t\t// Marshal into bytes\n\t\tvar b bytes.Buffer\n\t\tx := xml.NewEncoder(&b)\n\t\tif xo.Indent {\n\t\t\tx.Indent(\"\", \"    \")\n\t\t}\n\t\terr := x.Encode(v)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\treturn b.Bytes(), nil\n\t}\n\n\tif xo.Type == \"array\" {\n\t\t// Make sure you set a row count\n\t\tif xo.RowCount <= 0 {\n\t\t\treturn nil, errors.New(\"must have row count\")\n\t\t}\n\n\t\txa := xmlArray{\n\t\t\tXMLName: xml.Name{Local: xo.RootElement},\n\t\t\tArray:   make([]xmlMap, xo.RowCount),\n\t\t}\n\n\t\tfor i := 1; i <= int(xo.RowCount); i++ {\n\t\t\tv := xmlMap{\n\t\t\t\tXMLName:  xml.Name{Local: xo.RecordElement},\n\t\t\t\tKeyOrder: keyOrder,\n\t\t\t\tMap:      make(map[string]any),\n\t\t\t}\n\n\t\t\t// Loop through fields and add to them to map[string]any\n\t\t\tfor _, field := range xo.Fields {\n\t\t\t\tif field.Function == \"autoincrement\" {\n\t\t\t\t\tv.Map[field.Name] = i\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\n\t\t\t\t// Get function info\n\t\t\t\tfuncInfo := GetFuncLookup(field.Function)\n\t\t\t\tif funcInfo == nil {\n\t\t\t\t\treturn nil, errors.New(\"invalid function, \" + field.Function + \" does not exist\")\n\t\t\t\t}\n\n\t\t\t\tvalue, err := funcInfo.Generate(f, &field.Params, funcInfo)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn nil, err\n\t\t\t\t}\n\n\t\t\t\tv.Map[field.Name] = value\n\t\t\t}\n\n\t\t\txa.Array = append(xa.Array, v)\n\t\t}\n\n\t\t// Marshal into bytes\n\t\tvar b bytes.Buffer\n\t\tx := xml.NewEncoder(&b)\n\t\tif xo.Indent {\n\t\t\tx.Indent(\"\", \"    \")\n\t\t}\n\t\terr := x.Encode(xa)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\treturn b.Bytes(), nil\n\t}\n\n\treturn nil, errors.New(\"invalid type, must be array or object\")\n}\n\nfunc addFileXMLLookup() {\n\tAddFuncLookup(\"xml\", Info{\n\t\tDisplay:     \"XML\",\n\t\tCategory:    \"file\",\n\t\tDescription: \"Generates an single or an array of elements in xml format\",\n\t\tExample: `<xml>\n\t<record>\n\t\t<first_name>Markus</first_name>\n\t\t<last_name>Moen</last_name>\n\t\t<password>Dc0VYXjkWABx</password>\n\t</record>\n\t<record>\n\t\t<first_name>Osborne</first_name>\n\t\t<last_name>Hilll</last_name>\n\t\t<password>XPJ9OVNbs5lm</password>\n\t</record>\n</xml>`,\n\t\tOutput:      \"[]byte\",\n\t\tContentType: \"application/xml\",\n\t\tParams: []Param{\n\t\t\t{Field: \"type\", Display: \"Type\", Type: \"string\", Default: \"single\", Options: []string{\"single\", \"array\"}, Description: \"Type of XML, single or array\"},\n\t\t\t{Field: \"rootelement\", Display: \"Root Element\", Type: \"string\", Default: \"xml\", Description: \"Root element wrapper name\"},\n\t\t\t{Field: \"recordelement\", Display: \"Record Element\", Type: \"string\", Default: \"record\", Description: \"Record element for each record row\"},\n\t\t\t{Field: \"rowcount\", Display: \"Row Count\", Type: \"int\", Default: \"100\", Description: \"Number of rows in JSON array\"},\n\t\t\t{Field: \"indent\", Display: \"Indent\", Type: \"bool\", Default: \"false\", Description: \"Whether or not to add indents and newlines\"},\n\t\t\t{Field: \"fields\", Display: \"Fields\", Type: \"[]Field\", Description: \"Fields containing key name and function to run in json format\"},\n\t\t},\n\t\tGenerate: func(f *Faker, m *MapParams, info *Info) (any, error) {\n\t\t\txo := XMLOptions{}\n\n\t\t\ttyp, err := info.GetString(m, \"type\")\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\txo.Type = typ\n\n\t\t\trootElement, err := info.GetString(m, \"rootelement\")\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\txo.RootElement = rootElement\n\n\t\t\trecordElement, err := info.GetString(m, \"recordelement\")\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\txo.RecordElement = recordElement\n\n\t\t\trowcount, err := info.GetInt(m, \"rowcount\")\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\txo.RowCount = rowcount\n\n\t\t\tfieldsStr, err := info.GetStringArray(m, \"fields\")\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\n\t\t\tindent, err := info.GetBool(m, \"indent\")\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\txo.Indent = indent\n\n\t\t\t// Check to make sure fields has length\n\t\t\tif len(fieldsStr) > 0 {\n\t\t\t\txo.Fields = make([]Field, len(fieldsStr))\n\n\t\t\t\tfor i, f := range fieldsStr {\n\t\t\t\t\t// Unmarshal fields string into fields array\n\t\t\t\t\terr = json.Unmarshal([]byte(f), &xo.Fields[i])\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\treturn nil, errors.New(\"unable to decode json string\")\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn xmlFunc(f, &xo)\n\t\t},\n\t})\n}\n"
        },
        {
          "name": "xml_test.go",
          "type": "blob",
          "size": 6.3251953125,
          "content": "package gofakeit\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc ExampleXML_single() {\n\tSeed(11)\n\n\tvalue, err := XML(&XMLOptions{\n\t\tType:          \"single\",\n\t\tRootElement:   \"xml\",\n\t\tRecordElement: \"record\",\n\t\tRowCount:      2,\n\t\tIndent:        true,\n\t\tFields: []Field{\n\t\t\t{Name: \"first_name\", Function: \"firstname\"},\n\t\t\t{Name: \"last_name\", Function: \"lastname\"},\n\t\t\t{Name: \"password\", Function: \"password\", Params: MapParams{\"special\": {\"false\"}}},\n\t\t},\n\t})\n\tif err != nil {\n\t\tfmt.Println(err)\n\t}\n\n\tfmt.Println(string(value))\n\n\t// Output: <xml>\n\t//     <first_name>Sonny</first_name>\n\t//     <last_name>Stiedemann</last_name>\n\t//     <password>8nwf0o3sBXcR</password>\n\t// </xml>\n}\n\nfunc ExampleFaker_XML_single() {\n\tf := New(11)\n\n\tvalue, err := f.XML(&XMLOptions{\n\t\tType:          \"single\",\n\t\tRootElement:   \"xml\",\n\t\tRecordElement: \"record\",\n\t\tRowCount:      2,\n\t\tIndent:        true,\n\t\tFields: []Field{\n\t\t\t{Name: \"first_name\", Function: \"firstname\"},\n\t\t\t{Name: \"last_name\", Function: \"lastname\"},\n\t\t\t{Name: \"password\", Function: \"password\", Params: MapParams{\"special\": {\"false\"}}},\n\t\t},\n\t})\n\tif err != nil {\n\t\tfmt.Println(err)\n\t}\n\n\tfmt.Println(string(value))\n\n\t// Output: <xml>\n\t//     <first_name>Sonny</first_name>\n\t//     <last_name>Stiedemann</last_name>\n\t//     <password>8nwf0o3sBXcR</password>\n\t// </xml>\n}\n\nfunc ExampleXML_array() {\n\tSeed(11)\n\n\tvalue, err := XML(&XMLOptions{\n\t\tType:          \"array\",\n\t\tRootElement:   \"xml\",\n\t\tRecordElement: \"record\",\n\t\tRowCount:      2,\n\t\tIndent:        true,\n\t\tFields: []Field{\n\t\t\t{Name: \"first_name\", Function: \"firstname\"},\n\t\t\t{Name: \"last_name\", Function: \"lastname\"},\n\t\t\t{Name: \"password\", Function: \"password\", Params: MapParams{\"special\": {\"false\"}}},\n\t\t},\n\t})\n\tif err != nil {\n\t\tfmt.Println(err)\n\t}\n\n\tfmt.Println(string(value))\n\n\t// Output: <xml>\n\t//     <record>\n\t//         <first_name>Sonny</first_name>\n\t//         <last_name>Stiedemann</last_name>\n\t//         <password>8nwf0o3sBXcR</password>\n\t//     </record>\n\t//     <record>\n\t//         <first_name>Verda</first_name>\n\t//         <last_name>Brakus</last_name>\n\t//         <password>3beWLpq75Lua</password>\n\t//     </record>\n\t// </xml>\n}\n\nfunc ExampleFaker_XML_array() {\n\tf := New(11)\n\n\tvalue, err := f.XML(&XMLOptions{\n\t\tType:          \"array\",\n\t\tRootElement:   \"xml\",\n\t\tRecordElement: \"record\",\n\t\tRowCount:      2,\n\t\tIndent:        true,\n\t\tFields: []Field{\n\t\t\t{Name: \"first_name\", Function: \"firstname\"},\n\t\t\t{Name: \"last_name\", Function: \"lastname\"},\n\t\t\t{Name: \"password\", Function: \"password\", Params: MapParams{\"special\": {\"false\"}}},\n\t\t},\n\t})\n\tif err != nil {\n\t\tfmt.Println(err)\n\t}\n\n\tfmt.Println(string(value))\n\n\t// Output: <xml>\n\t//     <record>\n\t//         <first_name>Sonny</first_name>\n\t//         <last_name>Stiedemann</last_name>\n\t//         <password>8nwf0o3sBXcR</password>\n\t//     </record>\n\t//     <record>\n\t//         <first_name>Verda</first_name>\n\t//         <last_name>Brakus</last_name>\n\t//         <password>3beWLpq75Lua</password>\n\t//     </record>\n\t// </xml>\n}\n\nfunc TestXMLSingle(t *testing.T) {\n\tSeed(11)\n\n\tAddFuncLookup(\"randmap\", Info{\n\t\tDisplay:     \"Rand Map\",\n\t\tCategory:    \"generate\",\n\t\tDescription: \"\",\n\t\tExample:     \"\",\n\t\tOutput:      \"string\",\n\t\tGenerate: func(f *Faker, m *MapParams, info *Info) (any, error) {\n\t\t\treturn map[string]any{\n\t\t\t\t\"string\": \"string value\",\n\t\t\t\t\"int\":    123456789,\n\t\t\t\t\"float\":  123.456,\n\t\t\t\t\"array\":  []string{\"one\", \"two\", \"three\"},\n\t\t\t}, nil\n\t\t},\n\t})\n\n\tvalue, err := XML(&XMLOptions{\n\t\tType:        \"single\",\n\t\tRootElement: \"single\",\n\t\tFields: []Field{\n\t\t\t{Name: \"first_name\", Function: \"firstname\"},\n\t\t\t{Name: \"last_name\", Function: \"lastname\"},\n\t\t\t{Name: \"password\", Function: \"password\", Params: MapParams{\"special\": {\"false\"}}},\n\t\t\t{Name: \"person\", Function: \"person\"},\n\t\t\t{Name: \"ints\", Function: \"shufflestrings\", Params: MapParams{\"strs\": {\"123\", \"456\", \"789\"}}},\n\t\t\t{Name: \"rand_map\", Function: \"randmap\"},\n\t\t},\n\t\tIndent: true,\n\t})\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tif fmt.Sprintf(\"%v\", value) == \"\" {\n\t\tt.Fatal(\"Value is empty\")\n\t}\n}\n\nfunc TestXMLArray(t *testing.T) {\n\tSeed(11)\n\n\tAddFuncLookup(\"randmap\", Info{\n\t\tDisplay:     \"Rand Map\",\n\t\tCategory:    \"generate\",\n\t\tDescription: \"\",\n\t\tExample:     \"\",\n\t\tOutput:      \"string\",\n\t\tGenerate: func(f *Faker, m *MapParams, info *Info) (any, error) {\n\t\t\treturn map[string]any{\n\t\t\t\t\"string\": \"string value\",\n\t\t\t\t\"int\":    123456789,\n\t\t\t\t\"float\":  123.456,\n\t\t\t\t\"array\":  []string{\"one\", \"two\", \"three\"},\n\t\t\t}, nil\n\t\t},\n\t})\n\n\tvalue, err := XML(&XMLOptions{\n\t\tType:          \"array\",\n\t\tRootElement:   \"array\",\n\t\tRecordElement: \"record\",\n\t\tRowCount:      10,\n\t\tFields: []Field{\n\t\t\t{Name: \"id\", Function: \"autoincrement\"},\n\t\t\t{Name: \"first_name\", Function: \"firstname\"},\n\t\t\t{Name: \"last_name\", Function: \"lastname\"},\n\t\t\t{Name: \"password\", Function: \"password\", Params: MapParams{\"special\": {\"false\"}}},\n\t\t\t{Name: \"person\", Function: \"person\"},\n\t\t\t{Name: \"ints\", Function: \"shufflestrings\", Params: MapParams{\"strs\": {\"123\", \"456\", \"789\"}}},\n\t\t\t{Name: \"rand_map\", Function: \"randmap\"},\n\t\t},\n\t\tIndent: true,\n\t})\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tif fmt.Sprintf(\"%v\", value) == \"\" {\n\t\tt.Fatal(\"Value is empty\")\n\t}\n}\n\nfunc TestXMLLookup(t *testing.T) {\n\tfaker := New(0)\n\tinfo := GetFuncLookup(\"xml\")\n\n\tm := NewMapParams()\n\tm.Add(\"type\", \"array\")\n\tm.Add(\"rowcount\", \"10\")\n\tm.Add(\"indent\", \"true\")\n\tm.Add(\"fields\", `{\"name\":\"id\",\"function\":\"autoincrement\"}`)\n\tm.Add(\"fields\", `{\"name\":\"first_name\",\"function\":\"firstname\"}`)\n\tm.Add(\"fields\", `{\"name\":\"password\",\"function\":\"password\",\"params\":{\"special\":[\"false\"],\"length\":[\"20\"]}}`)\n\n\t_, err := info.Generate(faker, m, info)\n\tif err != nil {\n\t\tt.Fatal(err.Error())\n\t}\n}\n\nfunc TestXMLNoOptions(t *testing.T) {\n\tSeed(11)\n\n\t// if XMLOptions is nil -> get a random XMLOptions\n\t_, err := XML(nil)\n\tif err != nil {\n\t\tt.Fatal(err.Error())\n\t}\n}\n\nfunc BenchmarkXMLLookup100(b *testing.B) {\n\tfaker := New(0)\n\n\tfor i := 0; i < b.N; i++ {\n\t\tinfo := GetFuncLookup(\"xml\")\n\n\t\tm := NewMapParams()\n\t\tm.Add(\"type\", \"array\")\n\t\tm.Add(\"rowcount\", \"100\")\n\t\tm.Add(\"fields\", `{\"name\":\"id\",\"function\":\"autoincrement\"}`)\n\t\tm.Add(\"fields\", `{\"name\":\"first_name\",\"function\":\"firstname\"}`)\n\t\tm.Add(\"fields\", `{\"name\":\"last_name\",\"function\":\"lastname\"}`)\n\t\tm.Add(\"fields\", `{\"name\":\"password\",\"function\":\"password\"}`)\n\t\tm.Add(\"fields\", `{\"name\":\"description\",\"function\":\"paragraph\"}`)\n\t\tm.Add(\"fields\", `{\"name\":\"created_at\",\"function\":\"date\"}`)\n\n\t\t_, err := info.Generate(faker, m, info)\n\t\tif err != nil {\n\t\t\tb.Fatal(err.Error())\n\t\t}\n\t}\n}\n"
        }
      ]
    }
  ]
}