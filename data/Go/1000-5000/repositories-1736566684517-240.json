{
  "metadata": {
    "timestamp": 1736566684517,
    "page": 240,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjI0MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "fatih/structs",
      "stars": 3909,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.2529296875,
          "content": "# Compiled Object files, Static and Dynamic libs (Shared Objects)\n*.o\n*.a\n*.so\n\n# Folders\n_obj\n_test\n\n# Architecture specific extensions/prefixes\n*.[568vq]\n[568vq].out\n\n*.cgo1.go\n*.cgo2.c\n_cgo_defun.c\n_cgo_gotypes.go\n_cgo_export.*\n\n_testmain.go\n\n*.exe\n*.test\n"
        },
        {
          "name": ".travis.yml",
          "type": "blob",
          "size": 0.294921875,
          "content": "language: go\ngo: \n - 1.7.x\n - 1.8.x\n - 1.9.x\n - tip\nsudo: false\nbefore_install:\n- go get github.com/axw/gocov/gocov\n- go get github.com/mattn/goveralls\n- if ! go get github.com/golang/tools/cmd/cover; then go get golang.org/x/tools/cmd/cover; fi\nscript:\n- $HOME/gopath/bin/goveralls -service=travis-ci\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.052734375,
          "content": "The MIT License (MIT)\n\nCopyright (c) 2014 Fatih Arslan\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE."
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 4.8154296875,
          "content": "# Archived project. No maintenance. \n\nThis project is not maintained anymore and is archived. Feel free to fork and\nmake your own changes if needed. For more detail read my blog post: [Taking an indefinite sabbatical from my projects](https://arslan.io/2018/10/09/taking-an-indefinite-sabbatical-from-my-projects/)\n\nThanks to everyone for their valuable feedback and contributions.\n\n# Structs [![GoDoc](http://img.shields.io/badge/go-documentation-blue.svg?style=flat-square)](http://godoc.org/github.com/fatih/structs) [![Build Status](http://img.shields.io/travis/fatih/structs.svg?style=flat-square)](https://travis-ci.org/fatih/structs) [![Coverage Status](http://img.shields.io/coveralls/fatih/structs.svg?style=flat-square)](https://coveralls.io/r/fatih/structs)\n\nStructs contains various utilities to work with Go (Golang) structs. It was\ninitially used by me to convert a struct into a `map[string]interface{}`. With\ntime I've added other utilities for structs.  It's basically a high level\npackage based on primitives from the reflect package. Feel free to add new\nfunctions or improve the existing code.\n\n## Install\n\n```bash\ngo get github.com/fatih/structs\n```\n\n## Usage and Examples\n\nJust like the standard lib `strings`, `bytes` and co packages, `structs` has\nmany global functions to manipulate or organize your struct data. Lets define\nand declare a struct:\n\n```go\ntype Server struct {\n\tName        string `json:\"name,omitempty\"`\n\tID          int\n\tEnabled     bool\n\tusers       []string // not exported\n\thttp.Server          // embedded\n}\n\nserver := &Server{\n\tName:    \"gopher\",\n\tID:      123456,\n\tEnabled: true,\n}\n```\n\n```go\n// Convert a struct to a map[string]interface{}\n// => {\"Name\":\"gopher\", \"ID\":123456, \"Enabled\":true}\nm := structs.Map(server)\n\n// Convert the values of a struct to a []interface{}\n// => [\"gopher\", 123456, true]\nv := structs.Values(server)\n\n// Convert the names of a struct to a []string\n// (see \"Names methods\" for more info about fields)\nn := structs.Names(server)\n\n// Convert the values of a struct to a []*Field\n// (see \"Field methods\" for more info about fields)\nf := structs.Fields(server)\n\n// Return the struct name => \"Server\"\nn := structs.Name(server)\n\n// Check if any field of a struct is initialized or not.\nh := structs.HasZero(server)\n\n// Check if all fields of a struct is initialized or not.\nz := structs.IsZero(server)\n\n// Check if server is a struct or a pointer to struct\ni := structs.IsStruct(server)\n```\n\n### Struct methods\n\nThe structs functions can be also used as independent methods by creating a new\n`*structs.Struct`. This is handy if you want to have more control over the\nstructs (such as retrieving a single Field).\n\n```go\n// Create a new struct type:\ns := structs.New(server)\n\nm := s.Map()              // Get a map[string]interface{}\nv := s.Values()           // Get a []interface{}\nf := s.Fields()           // Get a []*Field\nn := s.Names()            // Get a []string\nf := s.Field(name)        // Get a *Field based on the given field name\nf, ok := s.FieldOk(name)  // Get a *Field based on the given field name\nn := s.Name()             // Get the struct name\nh := s.HasZero()          // Check if any field is uninitialized\nz := s.IsZero()           // Check if all fields are uninitialized\n```\n\n### Field methods\n\nWe can easily examine a single Field for more detail. Below you can see how we\nget and interact with various field methods:\n\n\n```go\ns := structs.New(server)\n\n// Get the Field struct for the \"Name\" field\nname := s.Field(\"Name\")\n\n// Get the underlying value,  value => \"gopher\"\nvalue := name.Value().(string)\n\n// Set the field's value\nname.Set(\"another gopher\")\n\n// Get the field's kind, kind =>  \"string\"\nname.Kind()\n\n// Check if the field is exported or not\nif name.IsExported() {\n\tfmt.Println(\"Name field is exported\")\n}\n\n// Check if the value is a zero value, such as \"\" for string, 0 for int\nif !name.IsZero() {\n\tfmt.Println(\"Name is initialized\")\n}\n\n// Check if the field is an anonymous (embedded) field\nif !name.IsEmbedded() {\n\tfmt.Println(\"Name is not an embedded field\")\n}\n\n// Get the Field's tag value for tag name \"json\", tag value => \"name,omitempty\"\ntagValue := name.Tag(\"json\")\n```\n\nNested structs are supported too:\n\n```go\naddrField := s.Field(\"Server\").Field(\"Addr\")\n\n// Get the value for addr\na := addrField.Value().(string)\n\n// Or get all fields\nhttpServer := s.Field(\"Server\").Fields()\n```\n\nWe can also get a slice of Fields from the Struct type to iterate over all\nfields. This is handy if you wish to examine all fields:\n\n```go\ns := structs.New(server)\n\nfor _, f := range s.Fields() {\n\tfmt.Printf(\"field name: %+v\\n\", f.Name())\n\n\tif f.IsExported() {\n\t\tfmt.Printf(\"value   : %+v\\n\", f.Value())\n\t\tfmt.Printf(\"is zero : %+v\\n\", f.IsZero())\n\t}\n}\n```\n\n## Credits\n\n * [Fatih Arslan](https://github.com/fatih)\n * [Cihangir Savas](https://github.com/cihangir)\n\n## License\n\nThe MIT License (MIT) - see LICENSE.md for more details\n"
        },
        {
          "name": "field.go",
          "type": "blob",
          "size": 3.751953125,
          "content": "package structs\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"reflect\"\n)\n\nvar (\n\terrNotExported = errors.New(\"field is not exported\")\n\terrNotSettable = errors.New(\"field is not settable\")\n)\n\n// Field represents a single struct field that encapsulates high level\n// functions around the field.\ntype Field struct {\n\tvalue      reflect.Value\n\tfield      reflect.StructField\n\tdefaultTag string\n}\n\n// Tag returns the value associated with key in the tag string. If there is no\n// such key in the tag, Tag returns the empty string.\nfunc (f *Field) Tag(key string) string {\n\treturn f.field.Tag.Get(key)\n}\n\n// Value returns the underlying value of the field. It panics if the field\n// is not exported.\nfunc (f *Field) Value() interface{} {\n\treturn f.value.Interface()\n}\n\n// IsEmbedded returns true if the given field is an anonymous field (embedded)\nfunc (f *Field) IsEmbedded() bool {\n\treturn f.field.Anonymous\n}\n\n// IsExported returns true if the given field is exported.\nfunc (f *Field) IsExported() bool {\n\treturn f.field.PkgPath == \"\"\n}\n\n// IsZero returns true if the given field is not initialized (has a zero value).\n// It panics if the field is not exported.\nfunc (f *Field) IsZero() bool {\n\tzero := reflect.Zero(f.value.Type()).Interface()\n\tcurrent := f.Value()\n\n\treturn reflect.DeepEqual(current, zero)\n}\n\n// Name returns the name of the given field\nfunc (f *Field) Name() string {\n\treturn f.field.Name\n}\n\n// Kind returns the fields kind, such as \"string\", \"map\", \"bool\", etc ..\nfunc (f *Field) Kind() reflect.Kind {\n\treturn f.value.Kind()\n}\n\n// Set sets the field to given value v. It returns an error if the field is not\n// settable (not addressable or not exported) or if the given value's type\n// doesn't match the fields type.\nfunc (f *Field) Set(val interface{}) error {\n\t// we can't set unexported fields, so be sure this field is exported\n\tif !f.IsExported() {\n\t\treturn errNotExported\n\t}\n\n\t// do we get here? not sure...\n\tif !f.value.CanSet() {\n\t\treturn errNotSettable\n\t}\n\n\tgiven := reflect.ValueOf(val)\n\n\tif f.value.Kind() != given.Kind() {\n\t\treturn fmt.Errorf(\"wrong kind. got: %s want: %s\", given.Kind(), f.value.Kind())\n\t}\n\n\tf.value.Set(given)\n\treturn nil\n}\n\n// Zero sets the field to its zero value. It returns an error if the field is not\n// settable (not addressable or not exported).\nfunc (f *Field) Zero() error {\n\tzero := reflect.Zero(f.value.Type()).Interface()\n\treturn f.Set(zero)\n}\n\n// Fields returns a slice of Fields. This is particular handy to get the fields\n// of a nested struct . A struct tag with the content of \"-\" ignores the\n// checking of that particular field. Example:\n//\n//   // Field is ignored by this package.\n//   Field *http.Request `structs:\"-\"`\n//\n// It panics if field is not exported or if field's kind is not struct\nfunc (f *Field) Fields() []*Field {\n\treturn getFields(f.value, f.defaultTag)\n}\n\n// Field returns the field from a nested struct. It panics if the nested struct\n// is not exported or if the field was not found.\nfunc (f *Field) Field(name string) *Field {\n\tfield, ok := f.FieldOk(name)\n\tif !ok {\n\t\tpanic(\"field not found\")\n\t}\n\n\treturn field\n}\n\n// FieldOk returns the field from a nested struct. The boolean returns whether\n// the field was found (true) or not (false).\nfunc (f *Field) FieldOk(name string) (*Field, bool) {\n\tvalue := &f.value\n\t// value must be settable so we need to make sure it holds the address of the\n\t// variable and not a copy, so we can pass the pointer to strctVal instead of a\n\t// copy (which is not assigned to any variable, hence not settable).\n\t// see \"https://blog.golang.org/laws-of-reflection#TOC_8.\"\n\tif f.value.Kind() != reflect.Ptr {\n\t\ta := f.value.Addr()\n\t\tvalue = &a\n\t}\n\tv := strctVal(value.Interface())\n\tt := v.Type()\n\n\tfield, ok := t.FieldByName(name)\n\tif !ok {\n\t\treturn nil, false\n\t}\n\n\treturn &Field{\n\t\tfield: field,\n\t\tvalue: v.FieldByName(name),\n\t}, true\n}\n"
        },
        {
          "name": "field_test.go",
          "type": "blob",
          "size": 7.4150390625,
          "content": "package structs\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n)\n\n// A test struct that defines all cases\ntype Foo struct {\n\tA    string\n\tB    int    `structs:\"y\"`\n\tC    bool   `json:\"c\"`\n\td    string // not exported\n\tE    *Baz\n\tx    string `xml:\"x\"` // not exported, with tag\n\tY    []string\n\tZ    map[string]interface{}\n\t*Bar // embedded\n}\n\ntype Baz struct {\n\tA string\n\tB int\n}\n\ntype Bar struct {\n\tE string\n\tF int\n\tg []string\n}\n\nfunc newStruct() *Struct {\n\tb := &Bar{\n\t\tE: \"example\",\n\t\tF: 2,\n\t\tg: []string{\"zeynep\", \"fatih\"},\n\t}\n\n\t// B and x is not initialized for testing\n\tf := &Foo{\n\t\tA: \"gopher\",\n\t\tC: true,\n\t\td: \"small\",\n\t\tE: nil,\n\t\tY: []string{\"example\"},\n\t\tZ: nil,\n\t}\n\tf.Bar = b\n\n\treturn New(f)\n}\n\nfunc TestField_Set(t *testing.T) {\n\ts := newStruct()\n\n\tf := s.Field(\"A\")\n\terr := f.Set(\"fatih\")\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n\n\tif f.Value().(string) != \"fatih\" {\n\t\tt.Errorf(\"Setted value is wrong: %s want: %s\", f.Value().(string), \"fatih\")\n\t}\n\n\tf = s.Field(\"Y\")\n\terr = f.Set([]string{\"override\", \"with\", \"this\"})\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n\n\tsliceLen := len(f.Value().([]string))\n\tif sliceLen != 3 {\n\t\tt.Errorf(\"Setted values slice length is wrong: %d, want: %d\", sliceLen, 3)\n\t}\n\n\tf = s.Field(\"C\")\n\terr = f.Set(false)\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n\n\tif f.Value().(bool) {\n\t\tt.Errorf(\"Setted value is wrong: %t want: %t\", f.Value().(bool), false)\n\t}\n\n\t// let's pass a different type\n\tf = s.Field(\"A\")\n\terr = f.Set(123) // Field A is of type string, but we are going to pass an integer\n\tif err == nil {\n\t\tt.Error(\"Setting a field's value with a different type than the field's type should return an error\")\n\t}\n\n\t// old value should be still there :)\n\tif f.Value().(string) != \"fatih\" {\n\t\tt.Errorf(\"Setted value is wrong: %s want: %s\", f.Value().(string), \"fatih\")\n\t}\n\n\t// let's access an unexported field, which should give an error\n\tf = s.Field(\"d\")\n\terr = f.Set(\"large\")\n\tif err != errNotExported {\n\t\tt.Error(err)\n\t}\n\n\t// let's set a pointer to struct\n\tb := &Bar{\n\t\tE: \"gopher\",\n\t\tF: 2,\n\t}\n\n\tf = s.Field(\"Bar\")\n\terr = f.Set(b)\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n\n\tbaz := &Baz{\n\t\tA: \"helloWorld\",\n\t\tB: 42,\n\t}\n\n\tf = s.Field(\"E\")\n\terr = f.Set(baz)\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n\n\tba := s.Field(\"E\").Value().(*Baz)\n\n\tif ba.A != \"helloWorld\" {\n\t\tt.Errorf(\"could not set baz. Got: %s Want: helloWorld\", ba.A)\n\t}\n}\n\nfunc TestField_NotSettable(t *testing.T) {\n\ta := map[int]Baz{\n\t\t4: {\n\t\t\tA: \"value\",\n\t\t},\n\t}\n\n\ts := New(a[4])\n\n\tif err := s.Field(\"A\").Set(\"newValue\"); err != errNotSettable {\n\t\tt.Errorf(\"Trying to set non-settable field should error with %q. Got %q instead.\", errNotSettable, err)\n\t}\n}\n\nfunc TestField_Zero(t *testing.T) {\n\ts := newStruct()\n\n\tf := s.Field(\"A\")\n\terr := f.Zero()\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n\n\tif f.Value().(string) != \"\" {\n\t\tt.Errorf(\"Zeroed value is wrong: %s want: %s\", f.Value().(string), \"\")\n\t}\n\n\tf = s.Field(\"Y\")\n\terr = f.Zero()\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n\n\tsliceLen := len(f.Value().([]string))\n\tif sliceLen != 0 {\n\t\tt.Errorf(\"Zeroed values slice length is wrong: %d, want: %d\", sliceLen, 0)\n\t}\n\n\tf = s.Field(\"C\")\n\terr = f.Zero()\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n\n\tif f.Value().(bool) {\n\t\tt.Errorf(\"Zeroed value is wrong: %t want: %t\", f.Value().(bool), false)\n\t}\n\n\t// let's access an unexported field, which should give an error\n\tf = s.Field(\"d\")\n\terr = f.Zero()\n\tif err != errNotExported {\n\t\tt.Error(err)\n\t}\n\n\tf = s.Field(\"Bar\")\n\terr = f.Zero()\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n\n\tf = s.Field(\"E\")\n\terr = f.Zero()\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n\n\tv := s.Field(\"E\").value\n\tif !v.IsNil() {\n\t\tt.Errorf(\"could not set baz. Got: %s Want: <nil>\", v.Interface())\n\t}\n}\n\nfunc TestField(t *testing.T) {\n\ts := newStruct()\n\n\tdefer func() {\n\t\terr := recover()\n\t\tif err == nil {\n\t\t\tt.Error(\"Retrieveing a non existing field from the struct should panic\")\n\t\t}\n\t}()\n\n\t_ = s.Field(\"no-field\")\n}\n\nfunc TestField_Kind(t *testing.T) {\n\ts := newStruct()\n\n\tf := s.Field(\"A\")\n\tif f.Kind() != reflect.String {\n\t\tt.Errorf(\"Field A has wrong kind: %s want: %s\", f.Kind(), reflect.String)\n\t}\n\n\tf = s.Field(\"B\")\n\tif f.Kind() != reflect.Int {\n\t\tt.Errorf(\"Field B has wrong kind: %s want: %s\", f.Kind(), reflect.Int)\n\t}\n\n\t// unexported\n\tf = s.Field(\"d\")\n\tif f.Kind() != reflect.String {\n\t\tt.Errorf(\"Field d has wrong kind: %s want: %s\", f.Kind(), reflect.String)\n\t}\n}\n\nfunc TestField_Tag(t *testing.T) {\n\ts := newStruct()\n\n\tv := s.Field(\"B\").Tag(\"json\")\n\tif v != \"\" {\n\t\tt.Errorf(\"Field's tag value of a non existing tag should return empty, got: %s\", v)\n\t}\n\n\tv = s.Field(\"C\").Tag(\"json\")\n\tif v != \"c\" {\n\t\tt.Errorf(\"Field's tag value of the existing field C should return 'c', got: %s\", v)\n\t}\n\n\tv = s.Field(\"d\").Tag(\"json\")\n\tif v != \"\" {\n\t\tt.Errorf(\"Field's tag value of a non exported field should return empty, got: %s\", v)\n\t}\n\n\tv = s.Field(\"x\").Tag(\"xml\")\n\tif v != \"x\" {\n\t\tt.Errorf(\"Field's tag value of a non exported field with a tag should return 'x', got: %s\", v)\n\t}\n\n\tv = s.Field(\"A\").Tag(\"json\")\n\tif v != \"\" {\n\t\tt.Errorf(\"Field's tag value of a existing field without a tag should return empty, got: %s\", v)\n\t}\n}\n\nfunc TestField_Value(t *testing.T) {\n\ts := newStruct()\n\n\tv := s.Field(\"A\").Value()\n\tval, ok := v.(string)\n\tif !ok {\n\t\tt.Errorf(\"Field's value of a A should be string\")\n\t}\n\n\tif val != \"gopher\" {\n\t\tt.Errorf(\"Field's value of a existing tag should return 'gopher', got: %s\", val)\n\t}\n\n\tdefer func() {\n\t\terr := recover()\n\t\tif err == nil {\n\t\t\tt.Error(\"Value of a non exported field from the field should panic\")\n\t\t}\n\t}()\n\n\t// should panic\n\t_ = s.Field(\"d\").Value()\n}\n\nfunc TestField_IsEmbedded(t *testing.T) {\n\ts := newStruct()\n\n\tif !s.Field(\"Bar\").IsEmbedded() {\n\t\tt.Errorf(\"Fields 'Bar' field is an embedded field\")\n\t}\n\n\tif s.Field(\"d\").IsEmbedded() {\n\t\tt.Errorf(\"Fields 'd' field is not an embedded field\")\n\t}\n}\n\nfunc TestField_IsExported(t *testing.T) {\n\ts := newStruct()\n\n\tif !s.Field(\"Bar\").IsExported() {\n\t\tt.Errorf(\"Fields 'Bar' field is an exported field\")\n\t}\n\n\tif !s.Field(\"A\").IsExported() {\n\t\tt.Errorf(\"Fields 'A' field is an exported field\")\n\t}\n\n\tif s.Field(\"d\").IsExported() {\n\t\tt.Errorf(\"Fields 'd' field is not an exported field\")\n\t}\n}\n\nfunc TestField_IsZero(t *testing.T) {\n\ts := newStruct()\n\n\tif s.Field(\"A\").IsZero() {\n\t\tt.Errorf(\"Fields 'A' field is an initialized field\")\n\t}\n\n\tif !s.Field(\"B\").IsZero() {\n\t\tt.Errorf(\"Fields 'B' field is not an initialized field\")\n\t}\n}\n\nfunc TestField_Name(t *testing.T) {\n\ts := newStruct()\n\n\tif s.Field(\"A\").Name() != \"A\" {\n\t\tt.Errorf(\"Fields 'A' field should have the name 'A'\")\n\t}\n}\n\nfunc TestField_Field(t *testing.T) {\n\ts := newStruct()\n\n\te := s.Field(\"Bar\").Field(\"E\")\n\n\tval, ok := e.Value().(string)\n\tif !ok {\n\t\tt.Error(\"The value of the field 'e' inside 'Bar' struct should be string\")\n\t}\n\n\tif val != \"example\" {\n\t\tt.Errorf(\"The value of 'e' should be 'example, got: %s\", val)\n\t}\n\n\tdefer func() {\n\t\terr := recover()\n\t\tif err == nil {\n\t\t\tt.Error(\"Field of a non existing nested struct should panic\")\n\t\t}\n\t}()\n\n\t_ = s.Field(\"Bar\").Field(\"e\")\n}\n\nfunc TestField_Fields(t *testing.T) {\n\ts := newStruct()\n\tfields := s.Field(\"Bar\").Fields()\n\n\tif len(fields) != 3 {\n\t\tt.Errorf(\"We expect 3 fields in embedded struct, was: %d\", len(fields))\n\t}\n}\n\nfunc TestField_FieldOk(t *testing.T) {\n\ts := newStruct()\n\n\tb, ok := s.FieldOk(\"Bar\")\n\tif !ok {\n\t\tt.Error(\"The field 'Bar' should exists.\")\n\t}\n\n\te, ok := b.FieldOk(\"E\")\n\tif !ok {\n\t\tt.Error(\"The field 'E' should exists.\")\n\t}\n\n\tval, ok := e.Value().(string)\n\tif !ok {\n\t\tt.Error(\"The value of the field 'e' inside 'Bar' struct should be string\")\n\t}\n\n\tif val != \"example\" {\n\t\tt.Errorf(\"The value of 'e' should be 'example, got: %s\", val)\n\t}\n}\n"
        },
        {
          "name": "structs.go",
          "type": "blob",
          "size": 14.9384765625,
          "content": "// Package structs contains various utilities functions to work with structs.\npackage structs\n\nimport (\n\t\"fmt\"\n\n\t\"reflect\"\n)\n\nvar (\n\t// DefaultTagName is the default tag name for struct fields which provides\n\t// a more granular to tweak certain structs. Lookup the necessary functions\n\t// for more info.\n\tDefaultTagName = \"structs\" // struct's field default tag name\n)\n\n// Struct encapsulates a struct type to provide several high level functions\n// around the struct.\ntype Struct struct {\n\traw     interface{}\n\tvalue   reflect.Value\n\tTagName string\n}\n\n// New returns a new *Struct with the struct s. It panics if the s's kind is\n// not struct.\nfunc New(s interface{}) *Struct {\n\treturn &Struct{\n\t\traw:     s,\n\t\tvalue:   strctVal(s),\n\t\tTagName: DefaultTagName,\n\t}\n}\n\n// Map converts the given struct to a map[string]interface{}, where the keys\n// of the map are the field names and the values of the map the associated\n// values of the fields. The default key string is the struct field name but\n// can be changed in the struct field's tag value. The \"structs\" key in the\n// struct's field tag value is the key name. Example:\n//\n//   // Field appears in map as key \"myName\".\n//   Name string `structs:\"myName\"`\n//\n// A tag value with the content of \"-\" ignores that particular field. Example:\n//\n//   // Field is ignored by this package.\n//   Field bool `structs:\"-\"`\n//\n// A tag value with the content of \"string\" uses the stringer to get the value. Example:\n//\n//   // The value will be output of Animal's String() func.\n//   // Map will panic if Animal does not implement String().\n//   Field *Animal `structs:\"field,string\"`\n//\n// A tag value with the option of \"flatten\" used in a struct field is to flatten its fields\n// in the output map. Example:\n//\n//   // The FieldStruct's fields will be flattened into the output map.\n//   FieldStruct time.Time `structs:\",flatten\"`\n//\n// A tag value with the option of \"omitnested\" stops iterating further if the type\n// is a struct. Example:\n//\n//   // Field is not processed further by this package.\n//   Field time.Time     `structs:\"myName,omitnested\"`\n//   Field *http.Request `structs:\",omitnested\"`\n//\n// A tag value with the option of \"omitempty\" ignores that particular field if\n// the field value is empty. Example:\n//\n//   // Field appears in map as key \"myName\", but the field is\n//   // skipped if empty.\n//   Field string `structs:\"myName,omitempty\"`\n//\n//   // Field appears in map as key \"Field\" (the default), but\n//   // the field is skipped if empty.\n//   Field string `structs:\",omitempty\"`\n//\n// Note that only exported fields of a struct can be accessed, non exported\n// fields will be neglected.\nfunc (s *Struct) Map() map[string]interface{} {\n\tout := make(map[string]interface{})\n\ts.FillMap(out)\n\treturn out\n}\n\n// FillMap is the same as Map. Instead of returning the output, it fills the\n// given map.\nfunc (s *Struct) FillMap(out map[string]interface{}) {\n\tif out == nil {\n\t\treturn\n\t}\n\n\tfields := s.structFields()\n\n\tfor _, field := range fields {\n\t\tname := field.Name\n\t\tval := s.value.FieldByName(name)\n\t\tisSubStruct := false\n\t\tvar finalVal interface{}\n\n\t\ttagName, tagOpts := parseTag(field.Tag.Get(s.TagName))\n\t\tif tagName != \"\" {\n\t\t\tname = tagName\n\t\t}\n\n\t\t// if the value is a zero value and the field is marked as omitempty do\n\t\t// not include\n\t\tif tagOpts.Has(\"omitempty\") {\n\t\t\tzero := reflect.Zero(val.Type()).Interface()\n\t\t\tcurrent := val.Interface()\n\n\t\t\tif reflect.DeepEqual(current, zero) {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t}\n\n\t\tif !tagOpts.Has(\"omitnested\") {\n\t\t\tfinalVal = s.nested(val)\n\n\t\t\tv := reflect.ValueOf(val.Interface())\n\t\t\tif v.Kind() == reflect.Ptr {\n\t\t\t\tv = v.Elem()\n\t\t\t}\n\n\t\t\tswitch v.Kind() {\n\t\t\tcase reflect.Map, reflect.Struct:\n\t\t\t\tisSubStruct = true\n\t\t\t}\n\t\t} else {\n\t\t\tfinalVal = val.Interface()\n\t\t}\n\n\t\tif tagOpts.Has(\"string\") {\n\t\t\ts, ok := val.Interface().(fmt.Stringer)\n\t\t\tif ok {\n\t\t\t\tout[name] = s.String()\n\t\t\t}\n\t\t\tcontinue\n\t\t}\n\n\t\tif isSubStruct && (tagOpts.Has(\"flatten\")) {\n\t\t\tfor k := range finalVal.(map[string]interface{}) {\n\t\t\t\tout[k] = finalVal.(map[string]interface{})[k]\n\t\t\t}\n\t\t} else {\n\t\t\tout[name] = finalVal\n\t\t}\n\t}\n}\n\n// Values converts the given s struct's field values to a []interface{}.  A\n// struct tag with the content of \"-\" ignores the that particular field.\n// Example:\n//\n//   // Field is ignored by this package.\n//   Field int `structs:\"-\"`\n//\n// A value with the option of \"omitnested\" stops iterating further if the type\n// is a struct. Example:\n//\n//   // Fields is not processed further by this package.\n//   Field time.Time     `structs:\",omitnested\"`\n//   Field *http.Request `structs:\",omitnested\"`\n//\n// A tag value with the option of \"omitempty\" ignores that particular field and\n// is not added to the values if the field value is empty. Example:\n//\n//   // Field is skipped if empty\n//   Field string `structs:\",omitempty\"`\n//\n// Note that only exported fields of a struct can be accessed, non exported\n// fields  will be neglected.\nfunc (s *Struct) Values() []interface{} {\n\tfields := s.structFields()\n\n\tvar t []interface{}\n\n\tfor _, field := range fields {\n\t\tval := s.value.FieldByName(field.Name)\n\n\t\t_, tagOpts := parseTag(field.Tag.Get(s.TagName))\n\n\t\t// if the value is a zero value and the field is marked as omitempty do\n\t\t// not include\n\t\tif tagOpts.Has(\"omitempty\") {\n\t\t\tzero := reflect.Zero(val.Type()).Interface()\n\t\t\tcurrent := val.Interface()\n\n\t\t\tif reflect.DeepEqual(current, zero) {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t}\n\n\t\tif tagOpts.Has(\"string\") {\n\t\t\ts, ok := val.Interface().(fmt.Stringer)\n\t\t\tif ok {\n\t\t\t\tt = append(t, s.String())\n\t\t\t}\n\t\t\tcontinue\n\t\t}\n\n\t\tif IsStruct(val.Interface()) && !tagOpts.Has(\"omitnested\") {\n\t\t\t// look out for embedded structs, and convert them to a\n\t\t\t// []interface{} to be added to the final values slice\n\t\t\tt = append(t, Values(val.Interface())...)\n\t\t} else {\n\t\t\tt = append(t, val.Interface())\n\t\t}\n\t}\n\n\treturn t\n}\n\n// Fields returns a slice of Fields. A struct tag with the content of \"-\"\n// ignores the checking of that particular field. Example:\n//\n//   // Field is ignored by this package.\n//   Field bool `structs:\"-\"`\n//\n// It panics if s's kind is not struct.\nfunc (s *Struct) Fields() []*Field {\n\treturn getFields(s.value, s.TagName)\n}\n\n// Names returns a slice of field names. A struct tag with the content of \"-\"\n// ignores the checking of that particular field. Example:\n//\n//   // Field is ignored by this package.\n//   Field bool `structs:\"-\"`\n//\n// It panics if s's kind is not struct.\nfunc (s *Struct) Names() []string {\n\tfields := getFields(s.value, s.TagName)\n\n\tnames := make([]string, len(fields))\n\n\tfor i, field := range fields {\n\t\tnames[i] = field.Name()\n\t}\n\n\treturn names\n}\n\nfunc getFields(v reflect.Value, tagName string) []*Field {\n\tif v.Kind() == reflect.Ptr {\n\t\tv = v.Elem()\n\t}\n\n\tt := v.Type()\n\n\tvar fields []*Field\n\n\tfor i := 0; i < t.NumField(); i++ {\n\t\tfield := t.Field(i)\n\n\t\tif tag := field.Tag.Get(tagName); tag == \"-\" {\n\t\t\tcontinue\n\t\t}\n\n\t\tf := &Field{\n\t\t\tfield: field,\n\t\t\tvalue: v.FieldByName(field.Name),\n\t\t}\n\n\t\tfields = append(fields, f)\n\n\t}\n\n\treturn fields\n}\n\n// Field returns a new Field struct that provides several high level functions\n// around a single struct field entity. It panics if the field is not found.\nfunc (s *Struct) Field(name string) *Field {\n\tf, ok := s.FieldOk(name)\n\tif !ok {\n\t\tpanic(\"field not found\")\n\t}\n\n\treturn f\n}\n\n// FieldOk returns a new Field struct that provides several high level functions\n// around a single struct field entity. The boolean returns true if the field\n// was found.\nfunc (s *Struct) FieldOk(name string) (*Field, bool) {\n\tt := s.value.Type()\n\n\tfield, ok := t.FieldByName(name)\n\tif !ok {\n\t\treturn nil, false\n\t}\n\n\treturn &Field{\n\t\tfield:      field,\n\t\tvalue:      s.value.FieldByName(name),\n\t\tdefaultTag: s.TagName,\n\t}, true\n}\n\n// IsZero returns true if all fields in a struct is a zero value (not\n// initialized) A struct tag with the content of \"-\" ignores the checking of\n// that particular field. Example:\n//\n//   // Field is ignored by this package.\n//   Field bool `structs:\"-\"`\n//\n// A value with the option of \"omitnested\" stops iterating further if the type\n// is a struct. Example:\n//\n//   // Field is not processed further by this package.\n//   Field time.Time     `structs:\"myName,omitnested\"`\n//   Field *http.Request `structs:\",omitnested\"`\n//\n// Note that only exported fields of a struct can be accessed, non exported\n// fields  will be neglected. It panics if s's kind is not struct.\nfunc (s *Struct) IsZero() bool {\n\tfields := s.structFields()\n\n\tfor _, field := range fields {\n\t\tval := s.value.FieldByName(field.Name)\n\n\t\t_, tagOpts := parseTag(field.Tag.Get(s.TagName))\n\n\t\tif IsStruct(val.Interface()) && !tagOpts.Has(\"omitnested\") {\n\t\t\tok := IsZero(val.Interface())\n\t\t\tif !ok {\n\t\t\t\treturn false\n\t\t\t}\n\n\t\t\tcontinue\n\t\t}\n\n\t\t// zero value of the given field, such as \"\" for string, 0 for int\n\t\tzero := reflect.Zero(val.Type()).Interface()\n\n\t\t//  current value of the given field\n\t\tcurrent := val.Interface()\n\n\t\tif !reflect.DeepEqual(current, zero) {\n\t\t\treturn false\n\t\t}\n\t}\n\n\treturn true\n}\n\n// HasZero returns true if a field in a struct is not initialized (zero value).\n// A struct tag with the content of \"-\" ignores the checking of that particular\n// field. Example:\n//\n//   // Field is ignored by this package.\n//   Field bool `structs:\"-\"`\n//\n// A value with the option of \"omitnested\" stops iterating further if the type\n// is a struct. Example:\n//\n//   // Field is not processed further by this package.\n//   Field time.Time     `structs:\"myName,omitnested\"`\n//   Field *http.Request `structs:\",omitnested\"`\n//\n// Note that only exported fields of a struct can be accessed, non exported\n// fields  will be neglected. It panics if s's kind is not struct.\nfunc (s *Struct) HasZero() bool {\n\tfields := s.structFields()\n\n\tfor _, field := range fields {\n\t\tval := s.value.FieldByName(field.Name)\n\n\t\t_, tagOpts := parseTag(field.Tag.Get(s.TagName))\n\n\t\tif IsStruct(val.Interface()) && !tagOpts.Has(\"omitnested\") {\n\t\t\tok := HasZero(val.Interface())\n\t\t\tif ok {\n\t\t\t\treturn true\n\t\t\t}\n\n\t\t\tcontinue\n\t\t}\n\n\t\t// zero value of the given field, such as \"\" for string, 0 for int\n\t\tzero := reflect.Zero(val.Type()).Interface()\n\n\t\t//  current value of the given field\n\t\tcurrent := val.Interface()\n\n\t\tif reflect.DeepEqual(current, zero) {\n\t\t\treturn true\n\t\t}\n\t}\n\n\treturn false\n}\n\n// Name returns the structs's type name within its package. For more info refer\n// to Name() function.\nfunc (s *Struct) Name() string {\n\treturn s.value.Type().Name()\n}\n\n// structFields returns the exported struct fields for a given s struct. This\n// is a convenient helper method to avoid duplicate code in some of the\n// functions.\nfunc (s *Struct) structFields() []reflect.StructField {\n\tt := s.value.Type()\n\n\tvar f []reflect.StructField\n\n\tfor i := 0; i < t.NumField(); i++ {\n\t\tfield := t.Field(i)\n\t\t// we can't access the value of unexported fields\n\t\tif field.PkgPath != \"\" {\n\t\t\tcontinue\n\t\t}\n\n\t\t// don't check if it's omitted\n\t\tif tag := field.Tag.Get(s.TagName); tag == \"-\" {\n\t\t\tcontinue\n\t\t}\n\n\t\tf = append(f, field)\n\t}\n\n\treturn f\n}\n\nfunc strctVal(s interface{}) reflect.Value {\n\tv := reflect.ValueOf(s)\n\n\t// if pointer get the underlying element≤\n\tfor v.Kind() == reflect.Ptr {\n\t\tv = v.Elem()\n\t}\n\n\tif v.Kind() != reflect.Struct {\n\t\tpanic(\"not struct\")\n\t}\n\n\treturn v\n}\n\n// Map converts the given struct to a map[string]interface{}. For more info\n// refer to Struct types Map() method. It panics if s's kind is not struct.\nfunc Map(s interface{}) map[string]interface{} {\n\treturn New(s).Map()\n}\n\n// FillMap is the same as Map. Instead of returning the output, it fills the\n// given map.\nfunc FillMap(s interface{}, out map[string]interface{}) {\n\tNew(s).FillMap(out)\n}\n\n// Values converts the given struct to a []interface{}. For more info refer to\n// Struct types Values() method.  It panics if s's kind is not struct.\nfunc Values(s interface{}) []interface{} {\n\treturn New(s).Values()\n}\n\n// Fields returns a slice of *Field. For more info refer to Struct types\n// Fields() method.  It panics if s's kind is not struct.\nfunc Fields(s interface{}) []*Field {\n\treturn New(s).Fields()\n}\n\n// Names returns a slice of field names. For more info refer to Struct types\n// Names() method.  It panics if s's kind is not struct.\nfunc Names(s interface{}) []string {\n\treturn New(s).Names()\n}\n\n// IsZero returns true if all fields is equal to a zero value. For more info\n// refer to Struct types IsZero() method.  It panics if s's kind is not struct.\nfunc IsZero(s interface{}) bool {\n\treturn New(s).IsZero()\n}\n\n// HasZero returns true if any field is equal to a zero value. For more info\n// refer to Struct types HasZero() method.  It panics if s's kind is not struct.\nfunc HasZero(s interface{}) bool {\n\treturn New(s).HasZero()\n}\n\n// IsStruct returns true if the given variable is a struct or a pointer to\n// struct.\nfunc IsStruct(s interface{}) bool {\n\tv := reflect.ValueOf(s)\n\tif v.Kind() == reflect.Ptr {\n\t\tv = v.Elem()\n\t}\n\n\t// uninitialized zero value of a struct\n\tif v.Kind() == reflect.Invalid {\n\t\treturn false\n\t}\n\n\treturn v.Kind() == reflect.Struct\n}\n\n// Name returns the structs's type name within its package. It returns an\n// empty string for unnamed types. It panics if s's kind is not struct.\nfunc Name(s interface{}) string {\n\treturn New(s).Name()\n}\n\n// nested retrieves recursively all types for the given value and returns the\n// nested value.\nfunc (s *Struct) nested(val reflect.Value) interface{} {\n\tvar finalVal interface{}\n\n\tv := reflect.ValueOf(val.Interface())\n\tif v.Kind() == reflect.Ptr {\n\t\tv = v.Elem()\n\t}\n\n\tswitch v.Kind() {\n\tcase reflect.Struct:\n\t\tn := New(val.Interface())\n\t\tn.TagName = s.TagName\n\t\tm := n.Map()\n\n\t\t// do not add the converted value if there are no exported fields, ie:\n\t\t// time.Time\n\t\tif len(m) == 0 {\n\t\t\tfinalVal = val.Interface()\n\t\t} else {\n\t\t\tfinalVal = m\n\t\t}\n\tcase reflect.Map:\n\t\t// get the element type of the map\n\t\tmapElem := val.Type()\n\t\tswitch val.Type().Kind() {\n\t\tcase reflect.Ptr, reflect.Array, reflect.Map,\n\t\t\treflect.Slice, reflect.Chan:\n\t\t\tmapElem = val.Type().Elem()\n\t\t\tif mapElem.Kind() == reflect.Ptr {\n\t\t\t\tmapElem = mapElem.Elem()\n\t\t\t}\n\t\t}\n\n\t\t// only iterate over struct types, ie: map[string]StructType,\n\t\t// map[string][]StructType,\n\t\tif mapElem.Kind() == reflect.Struct ||\n\t\t\t(mapElem.Kind() == reflect.Slice &&\n\t\t\t\tmapElem.Elem().Kind() == reflect.Struct) {\n\t\t\tm := make(map[string]interface{}, val.Len())\n\t\t\tfor _, k := range val.MapKeys() {\n\t\t\t\tm[k.String()] = s.nested(val.MapIndex(k))\n\t\t\t}\n\t\t\tfinalVal = m\n\t\t\tbreak\n\t\t}\n\n\t\t// TODO(arslan): should this be optional?\n\t\tfinalVal = val.Interface()\n\tcase reflect.Slice, reflect.Array:\n\t\tif val.Type().Kind() == reflect.Interface {\n\t\t\tfinalVal = val.Interface()\n\t\t\tbreak\n\t\t}\n\n\t\t// TODO(arslan): should this be optional?\n\t\t// do not iterate of non struct types, just pass the value. Ie: []int,\n\t\t// []string, co... We only iterate further if it's a struct.\n\t\t// i.e []foo or []*foo\n\t\tif val.Type().Elem().Kind() != reflect.Struct &&\n\t\t\t!(val.Type().Elem().Kind() == reflect.Ptr &&\n\t\t\t\tval.Type().Elem().Elem().Kind() == reflect.Struct) {\n\t\t\tfinalVal = val.Interface()\n\t\t\tbreak\n\t\t}\n\n\t\tslices := make([]interface{}, val.Len())\n\t\tfor x := 0; x < val.Len(); x++ {\n\t\t\tslices[x] = s.nested(val.Index(x))\n\t\t}\n\t\tfinalVal = slices\n\tdefault:\n\t\tfinalVal = val.Interface()\n\t}\n\n\treturn finalVal\n}\n"
        },
        {
          "name": "structs_example_test.go",
          "type": "blob",
          "size": 6.3671875,
          "content": "package structs\n\nimport (\n\t\"fmt\"\n\t\"time\"\n)\n\nfunc ExampleNew() {\n\ttype Server struct {\n\t\tName    string\n\t\tID      int32\n\t\tEnabled bool\n\t}\n\n\tserver := &Server{\n\t\tName:    \"Arslan\",\n\t\tID:      123456,\n\t\tEnabled: true,\n\t}\n\n\ts := New(server)\n\n\tfmt.Printf(\"Name        : %v\\n\", s.Name())\n\tfmt.Printf(\"Values      : %v\\n\", s.Values())\n\tfmt.Printf(\"Value of ID : %v\\n\", s.Field(\"ID\").Value())\n\t// Output:\n\t// Name        : Server\n\t// Values      : [Arslan 123456 true]\n\t// Value of ID : 123456\n\n}\n\nfunc ExampleMap() {\n\ttype Server struct {\n\t\tName    string\n\t\tID      int32\n\t\tEnabled bool\n\t}\n\n\ts := &Server{\n\t\tName:    \"Arslan\",\n\t\tID:      123456,\n\t\tEnabled: true,\n\t}\n\n\tm := Map(s)\n\n\tfmt.Printf(\"%#v\\n\", m[\"Name\"])\n\tfmt.Printf(\"%#v\\n\", m[\"ID\"])\n\tfmt.Printf(\"%#v\\n\", m[\"Enabled\"])\n\t// Output:\n\t// \"Arslan\"\n\t// 123456\n\t// true\n\n}\n\nfunc ExampleMap_tags() {\n\t// Custom tags can change the map keys instead of using the fields name\n\ttype Server struct {\n\t\tName    string `structs:\"server_name\"`\n\t\tID      int32  `structs:\"server_id\"`\n\t\tEnabled bool   `structs:\"enabled\"`\n\t}\n\n\ts := &Server{\n\t\tName: \"Zeynep\",\n\t\tID:   789012,\n\t}\n\n\tm := Map(s)\n\n\t// access them by the custom tags defined above\n\tfmt.Printf(\"%#v\\n\", m[\"server_name\"])\n\tfmt.Printf(\"%#v\\n\", m[\"server_id\"])\n\tfmt.Printf(\"%#v\\n\", m[\"enabled\"])\n\t// Output:\n\t// \"Zeynep\"\n\t// 789012\n\t// false\n\n}\n\nfunc ExampleMap_omitNested() {\n\t// By default field with struct types are processed too. We can stop\n\t// processing them via \"omitnested\" tag option.\n\ttype Server struct {\n\t\tName string    `structs:\"server_name\"`\n\t\tID   int32     `structs:\"server_id\"`\n\t\tTime time.Time `structs:\"time,omitnested\"` // do not convert to map[string]interface{}\n\t}\n\n\tconst shortForm = \"2006-Jan-02\"\n\tt, _ := time.Parse(\"2006-Jan-02\", \"2013-Feb-03\")\n\n\ts := &Server{\n\t\tName: \"Zeynep\",\n\t\tID:   789012,\n\t\tTime: t,\n\t}\n\n\tm := Map(s)\n\n\t// access them by the custom tags defined above\n\tfmt.Printf(\"%v\\n\", m[\"server_name\"])\n\tfmt.Printf(\"%v\\n\", m[\"server_id\"])\n\tfmt.Printf(\"%v\\n\", m[\"time\"].(time.Time))\n\t// Output:\n\t// Zeynep\n\t// 789012\n\t// 2013-02-03 00:00:00 +0000 UTC\n}\n\nfunc ExampleMap_omitEmpty() {\n\t// By default field with struct types of zero values are processed too. We\n\t// can stop processing them via \"omitempty\" tag option.\n\ttype Server struct {\n\t\tName     string `structs:\",omitempty\"`\n\t\tID       int32  `structs:\"server_id,omitempty\"`\n\t\tLocation string\n\t}\n\n\t// Only add location\n\ts := &Server{\n\t\tLocation: \"Tokyo\",\n\t}\n\n\tm := Map(s)\n\n\t// map contains only the Location field\n\tfmt.Printf(\"%v\\n\", m)\n\t// Output:\n\t// map[Location:Tokyo]\n}\n\nfunc ExampleValues() {\n\ttype Server struct {\n\t\tName    string\n\t\tID      int32\n\t\tEnabled bool\n\t}\n\n\ts := &Server{\n\t\tName:    \"Fatih\",\n\t\tID:      135790,\n\t\tEnabled: false,\n\t}\n\n\tm := Values(s)\n\n\tfmt.Printf(\"Values: %+v\\n\", m)\n\t// Output:\n\t// Values: [Fatih 135790 false]\n}\n\nfunc ExampleValues_omitEmpty() {\n\t// By default field with struct types of zero values are processed too. We\n\t// can stop processing them via \"omitempty\" tag option.\n\ttype Server struct {\n\t\tName     string `structs:\",omitempty\"`\n\t\tID       int32  `structs:\"server_id,omitempty\"`\n\t\tLocation string\n\t}\n\n\t// Only add location\n\ts := &Server{\n\t\tLocation: \"Ankara\",\n\t}\n\n\tm := Values(s)\n\n\t// values contains only the Location field\n\tfmt.Printf(\"Values: %+v\\n\", m)\n\t// Output:\n\t// Values: [Ankara]\n}\n\nfunc ExampleValues_tags() {\n\ttype Location struct {\n\t\tCity    string\n\t\tCountry string\n\t}\n\n\ttype Server struct {\n\t\tName     string\n\t\tID       int32\n\t\tEnabled  bool\n\t\tLocation Location `structs:\"-\"` // values from location are not included anymore\n\t}\n\n\ts := &Server{\n\t\tName:     \"Fatih\",\n\t\tID:       135790,\n\t\tEnabled:  false,\n\t\tLocation: Location{City: \"Ankara\", Country: \"Turkey\"},\n\t}\n\n\t// Let get all values from the struct s. Note that we don't include values\n\t// from the Location field\n\tm := Values(s)\n\n\tfmt.Printf(\"Values: %+v\\n\", m)\n\t// Output:\n\t// Values: [Fatih 135790 false]\n}\n\nfunc ExampleFields() {\n\ttype Access struct {\n\t\tName         string\n\t\tLastAccessed time.Time\n\t\tNumber       int\n\t}\n\n\ts := &Access{\n\t\tName:         \"Fatih\",\n\t\tLastAccessed: time.Now(),\n\t\tNumber:       1234567,\n\t}\n\n\tfields := Fields(s)\n\n\tfor i, field := range fields {\n\t\tfmt.Printf(\"[%d] %+v\\n\", i, field.Name())\n\t}\n\n\t// Output:\n\t// [0] Name\n\t// [1] LastAccessed\n\t// [2] Number\n}\n\nfunc ExampleFields_nested() {\n\ttype Person struct {\n\t\tName   string\n\t\tNumber int\n\t}\n\n\ttype Access struct {\n\t\tPerson        Person\n\t\tHasPermission bool\n\t\tLastAccessed  time.Time\n\t}\n\n\ts := &Access{\n\t\tPerson:        Person{Name: \"fatih\", Number: 1234567},\n\t\tLastAccessed:  time.Now(),\n\t\tHasPermission: true,\n\t}\n\n\t// Let's get all fields from the struct s.\n\tfields := Fields(s)\n\n\tfor _, field := range fields {\n\t\tif field.Name() == \"Person\" {\n\t\t\tfmt.Printf(\"Access.Person.Name: %+v\\n\", field.Field(\"Name\").Value())\n\t\t}\n\t}\n\n\t// Output:\n\t// Access.Person.Name: fatih\n}\n\nfunc ExampleField() {\n\ttype Person struct {\n\t\tName   string\n\t\tNumber int\n\t}\n\n\ttype Access struct {\n\t\tPerson        Person\n\t\tHasPermission bool\n\t\tLastAccessed  time.Time\n\t}\n\n\taccess := &Access{\n\t\tPerson:        Person{Name: \"fatih\", Number: 1234567},\n\t\tLastAccessed:  time.Now(),\n\t\tHasPermission: true,\n\t}\n\n\t// Create a new Struct type\n\ts := New(access)\n\n\t// Get the Field type for \"Person\" field\n\tp := s.Field(\"Person\")\n\n\t// Get the underlying \"Name field\" and print the value of it\n\tname := p.Field(\"Name\")\n\n\tfmt.Printf(\"Value of Person.Access.Name: %+v\\n\", name.Value())\n\n\t// Output:\n\t// Value of Person.Access.Name: fatih\n\n}\n\nfunc ExampleIsZero() {\n\ttype Server struct {\n\t\tName    string\n\t\tID      int32\n\t\tEnabled bool\n\t}\n\n\t// Nothing is initialized\n\ta := &Server{}\n\tisZeroA := IsZero(a)\n\n\t// Name and Enabled is initialized, but not ID\n\tb := &Server{\n\t\tName:    \"Golang\",\n\t\tEnabled: true,\n\t}\n\tisZeroB := IsZero(b)\n\n\tfmt.Printf(\"%#v\\n\", isZeroA)\n\tfmt.Printf(\"%#v\\n\", isZeroB)\n\t// Output:\n\t// true\n\t// false\n}\n\nfunc ExampleHasZero() {\n\t// Let's define an Access struct. Note that the \"Enabled\" field is not\n\t// going to be checked because we added the \"structs\" tag to the field.\n\ttype Access struct {\n\t\tName         string\n\t\tLastAccessed time.Time\n\t\tNumber       int\n\t\tEnabled      bool `structs:\"-\"`\n\t}\n\n\t// Name and Number is not initialized.\n\ta := &Access{\n\t\tLastAccessed: time.Now(),\n\t}\n\thasZeroA := HasZero(a)\n\n\t// Name and Number is initialized.\n\tb := &Access{\n\t\tName:         \"Fatih\",\n\t\tLastAccessed: time.Now(),\n\t\tNumber:       12345,\n\t}\n\thasZeroB := HasZero(b)\n\n\tfmt.Printf(\"%#v\\n\", hasZeroA)\n\tfmt.Printf(\"%#v\\n\", hasZeroB)\n\t// Output:\n\t// true\n\t// false\n}\n"
        },
        {
          "name": "structs_test.go",
          "type": "blob",
          "size": 24.7236328125,
          "content": "package structs\n\nimport (\n\t\"fmt\"\n\t\"reflect\"\n\t\"testing\"\n\t\"time\"\n)\n\nfunc TestMapNonStruct(t *testing.T) {\n\tfoo := []string{\"foo\"}\n\n\tdefer func() {\n\t\terr := recover()\n\t\tif err == nil {\n\t\t\tt.Error(\"Passing a non struct into Map should panic\")\n\t\t}\n\t}()\n\n\t// this should panic. We are going to recover and and test it\n\t_ = Map(foo)\n}\n\nfunc TestStructIndexes(t *testing.T) {\n\ttype C struct {\n\t\tsomething int\n\t\tProps     map[string]interface{}\n\t}\n\n\tdefer func() {\n\t\terr := recover()\n\t\tif err != nil {\n\t\t\tfmt.Printf(\"err %+v\\n\", err)\n\t\t\tt.Error(\"Using mixed indexes should not panic\")\n\t\t}\n\t}()\n\n\t// They should not panic\n\t_ = Map(&C{})\n\t_ = Fields(&C{})\n\t_ = Values(&C{})\n\t_ = IsZero(&C{})\n\t_ = HasZero(&C{})\n}\n\nfunc TestMap(t *testing.T) {\n\tvar T = struct {\n\t\tA string\n\t\tB int\n\t\tC bool\n\t}{\n\t\tA: \"a-value\",\n\t\tB: 2,\n\t\tC: true,\n\t}\n\n\ta := Map(T)\n\n\tif typ := reflect.TypeOf(a).Kind(); typ != reflect.Map {\n\t\tt.Errorf(\"Map should return a map type, got: %v\", typ)\n\t}\n\n\t// we have three fields\n\tif len(a) != 3 {\n\t\tt.Errorf(\"Map should return a map of len 3, got: %d\", len(a))\n\t}\n\n\tinMap := func(val interface{}) bool {\n\t\tfor _, v := range a {\n\t\t\tif reflect.DeepEqual(v, val) {\n\t\t\t\treturn true\n\t\t\t}\n\t\t}\n\n\t\treturn false\n\t}\n\n\tfor _, val := range []interface{}{\"a-value\", 2, true} {\n\t\tif !inMap(val) {\n\t\t\tt.Errorf(\"Map should have the value %v\", val)\n\t\t}\n\t}\n\n}\n\nfunc TestMap_Tag(t *testing.T) {\n\tvar T = struct {\n\t\tA string `structs:\"x\"`\n\t\tB int    `structs:\"y\"`\n\t\tC bool   `structs:\"z\"`\n\t}{\n\t\tA: \"a-value\",\n\t\tB: 2,\n\t\tC: true,\n\t}\n\n\ta := Map(T)\n\n\tinMap := func(key interface{}) bool {\n\t\tfor k := range a {\n\t\t\tif reflect.DeepEqual(k, key) {\n\t\t\t\treturn true\n\t\t\t}\n\t\t}\n\t\treturn false\n\t}\n\n\tfor _, key := range []string{\"x\", \"y\", \"z\"} {\n\t\tif !inMap(key) {\n\t\t\tt.Errorf(\"Map should have the key %v\", key)\n\t\t}\n\t}\n\n}\n\nfunc TestMap_CustomTag(t *testing.T) {\n\tvar T = struct {\n\t\tA string `json:\"x\"`\n\t\tB int    `json:\"y\"`\n\t\tC bool   `json:\"z\"`\n\t\tD struct {\n\t\t\tE string `json:\"jkl\"`\n\t\t} `json:\"nested\"`\n\t}{\n\t\tA: \"a-value\",\n\t\tB: 2,\n\t\tC: true,\n\t}\n\tT.D.E = \"e-value\"\n\n\ts := New(T)\n\ts.TagName = \"json\"\n\n\ta := s.Map()\n\n\tinMap := func(key interface{}) bool {\n\t\tfor k := range a {\n\t\t\tif reflect.DeepEqual(k, key) {\n\t\t\t\treturn true\n\t\t\t}\n\t\t}\n\t\treturn false\n\t}\n\n\tfor _, key := range []string{\"x\", \"y\", \"z\"} {\n\t\tif !inMap(key) {\n\t\t\tt.Errorf(\"Map should have the key %v\", key)\n\t\t}\n\t}\n\n\tnested, ok := a[\"nested\"].(map[string]interface{})\n\tif !ok {\n\t\tt.Fatalf(\"Map should contain the D field that is tagged as 'nested'\")\n\t}\n\n\te, ok := nested[\"jkl\"].(string)\n\tif !ok {\n\t\tt.Fatalf(\"Map should contain the D.E field that is tagged as 'jkl'\")\n\t}\n\n\tif e != \"e-value\" {\n\t\tt.Errorf(\"D.E field should be equal to 'e-value', got: '%v'\", e)\n\t}\n\n}\n\nfunc TestMap_MultipleCustomTag(t *testing.T) {\n\tvar A = struct {\n\t\tX string `aa:\"ax\"`\n\t}{\"a_value\"}\n\n\taStruct := New(A)\n\taStruct.TagName = \"aa\"\n\n\tvar B = struct {\n\t\tX string `bb:\"bx\"`\n\t}{\"b_value\"}\n\n\tbStruct := New(B)\n\tbStruct.TagName = \"bb\"\n\n\ta, b := aStruct.Map(), bStruct.Map()\n\tif !reflect.DeepEqual(a, map[string]interface{}{\"ax\": \"a_value\"}) {\n\t\tt.Error(\"Map should have field ax with value a_value\")\n\t}\n\n\tif !reflect.DeepEqual(b, map[string]interface{}{\"bx\": \"b_value\"}) {\n\t\tt.Error(\"Map should have field bx with value b_value\")\n\t}\n}\n\nfunc TestMap_OmitEmpty(t *testing.T) {\n\ttype A struct {\n\t\tName  string\n\t\tValue string    `structs:\",omitempty\"`\n\t\tTime  time.Time `structs:\",omitempty\"`\n\t}\n\ta := A{}\n\n\tm := Map(a)\n\n\t_, ok := m[\"Value\"].(map[string]interface{})\n\tif ok {\n\t\tt.Error(\"Map should not contain the Value field that is tagged as omitempty\")\n\t}\n\n\t_, ok = m[\"Time\"].(map[string]interface{})\n\tif ok {\n\t\tt.Error(\"Map should not contain the Time field that is tagged as omitempty\")\n\t}\n}\n\nfunc TestMap_OmitNested(t *testing.T) {\n\ttype A struct {\n\t\tName  string\n\t\tValue string\n\t\tTime  time.Time `structs:\",omitnested\"`\n\t}\n\ta := A{Time: time.Now()}\n\n\ttype B struct {\n\t\tDesc string\n\t\tA    A\n\t}\n\tb := &B{A: a}\n\n\tm := Map(b)\n\n\tin, ok := m[\"A\"].(map[string]interface{})\n\tif !ok {\n\t\tt.Error(\"Map nested structs is not available in the map\")\n\t}\n\n\t// should not happen\n\tif _, ok := in[\"Time\"].(map[string]interface{}); ok {\n\t\tt.Error(\"Map nested struct should omit recursiving parsing of Time\")\n\t}\n\n\tif _, ok := in[\"Time\"].(time.Time); !ok {\n\t\tt.Error(\"Map nested struct should stop parsing of Time at is current value\")\n\t}\n}\n\nfunc TestMap_Nested(t *testing.T) {\n\ttype A struct {\n\t\tName string\n\t}\n\ta := &A{Name: \"example\"}\n\n\ttype B struct {\n\t\tA *A\n\t}\n\tb := &B{A: a}\n\n\tm := Map(b)\n\n\tif typ := reflect.TypeOf(m).Kind(); typ != reflect.Map {\n\t\tt.Errorf(\"Map should return a map type, got: %v\", typ)\n\t}\n\n\tin, ok := m[\"A\"].(map[string]interface{})\n\tif !ok {\n\t\tt.Error(\"Map nested structs is not available in the map\")\n\t}\n\n\tif name := in[\"Name\"].(string); name != \"example\" {\n\t\tt.Errorf(\"Map nested struct's name field should give example, got: %s\", name)\n\t}\n}\n\nfunc TestMap_NestedMapWithStructValues(t *testing.T) {\n\ttype A struct {\n\t\tName string\n\t}\n\n\ttype B struct {\n\t\tA map[string]*A\n\t}\n\n\ta := &A{Name: \"example\"}\n\n\tb := &B{\n\t\tA: map[string]*A{\n\t\t\t\"example_key\": a,\n\t\t},\n\t}\n\n\tm := Map(b)\n\n\tif typ := reflect.TypeOf(m).Kind(); typ != reflect.Map {\n\t\tt.Errorf(\"Map should return a map type, got: %v\", typ)\n\t}\n\n\tin, ok := m[\"A\"].(map[string]interface{})\n\tif !ok {\n\t\tt.Errorf(\"Nested type of map should be of type map[string]interface{}, have %T\", m[\"A\"])\n\t}\n\n\texample := in[\"example_key\"].(map[string]interface{})\n\tif name := example[\"Name\"].(string); name != \"example\" {\n\t\tt.Errorf(\"Map nested struct's name field should give example, got: %s\", name)\n\t}\n}\n\nfunc TestMap_NestedMapWithStringValues(t *testing.T) {\n\ttype B struct {\n\t\tFoo map[string]string\n\t}\n\n\ttype A struct {\n\t\tB *B\n\t}\n\n\tb := &B{\n\t\tFoo: map[string]string{\n\t\t\t\"example_key\": \"example\",\n\t\t},\n\t}\n\n\ta := &A{B: b}\n\n\tm := Map(a)\n\n\tif typ := reflect.TypeOf(m).Kind(); typ != reflect.Map {\n\t\tt.Errorf(\"Map should return a map type, got: %v\", typ)\n\t}\n\n\tin, ok := m[\"B\"].(map[string]interface{})\n\tif !ok {\n\t\tt.Errorf(\"Nested type of map should be of type map[string]interface{}, have %T\", m[\"B\"])\n\t}\n\n\tfoo := in[\"Foo\"].(map[string]string)\n\tif name := foo[\"example_key\"]; name != \"example\" {\n\t\tt.Errorf(\"Map nested struct's name field should give example, got: %s\", name)\n\t}\n}\nfunc TestMap_NestedMapWithInterfaceValues(t *testing.T) {\n\ttype B struct {\n\t\tFoo map[string]interface{}\n\t}\n\n\ttype A struct {\n\t\tB *B\n\t}\n\n\tb := &B{\n\t\tFoo: map[string]interface{}{\n\t\t\t\"example_key\": \"example\",\n\t\t},\n\t}\n\n\ta := &A{B: b}\n\n\tm := Map(a)\n\n\tif typ := reflect.TypeOf(m).Kind(); typ != reflect.Map {\n\t\tt.Errorf(\"Map should return a map type, got: %v\", typ)\n\t}\n\n\tin, ok := m[\"B\"].(map[string]interface{})\n\tif !ok {\n\t\tt.Errorf(\"Nested type of map should be of type map[string]interface{}, have %T\", m[\"B\"])\n\t}\n\n\tfoo := in[\"Foo\"].(map[string]interface{})\n\tif name := foo[\"example_key\"]; name != \"example\" {\n\t\tt.Errorf(\"Map nested struct's name field should give example, got: %s\", name)\n\t}\n}\n\nfunc TestMap_NestedMapWithSliceIntValues(t *testing.T) {\n\ttype B struct {\n\t\tFoo map[string][]int\n\t}\n\n\ttype A struct {\n\t\tB *B\n\t}\n\n\tb := &B{\n\t\tFoo: map[string][]int{\n\t\t\t\"example_key\": {80},\n\t\t},\n\t}\n\n\ta := &A{B: b}\n\n\tm := Map(a)\n\n\tif typ := reflect.TypeOf(m).Kind(); typ != reflect.Map {\n\t\tt.Errorf(\"Map should return a map type, got: %v\", typ)\n\t}\n\n\tin, ok := m[\"B\"].(map[string]interface{})\n\tif !ok {\n\t\tt.Errorf(\"Nested type of map should be of type map[string]interface{}, have %T\", m[\"B\"])\n\t}\n\n\tfoo := in[\"Foo\"].(map[string][]int)\n\tif name := foo[\"example_key\"]; name[0] != 80 {\n\t\tt.Errorf(\"Map nested struct's name field should give example, got: %v\", name)\n\t}\n}\n\nfunc TestMap_NestedMapWithSliceStructValues(t *testing.T) {\n\ttype address struct {\n\t\tCountry string `structs:\"country\"`\n\t}\n\n\ttype B struct {\n\t\tFoo map[string][]address\n\t}\n\n\ttype A struct {\n\t\tB *B\n\t}\n\n\tb := &B{\n\t\tFoo: map[string][]address{\n\t\t\t\"example_key\": {\n\t\t\t\t{Country: \"Turkey\"},\n\t\t\t},\n\t\t},\n\t}\n\n\ta := &A{B: b}\n\tm := Map(a)\n\n\tif typ := reflect.TypeOf(m).Kind(); typ != reflect.Map {\n\t\tt.Errorf(\"Map should return a map type, got: %v\", typ)\n\t}\n\n\tin, ok := m[\"B\"].(map[string]interface{})\n\tif !ok {\n\t\tt.Errorf(\"Nested type of map should be of type map[string]interface{}, have %T\", m[\"B\"])\n\t}\n\n\tfoo := in[\"Foo\"].(map[string]interface{})\n\n\taddresses := foo[\"example_key\"].([]interface{})\n\n\taddr, ok := addresses[0].(map[string]interface{})\n\tif !ok {\n\t\tt.Errorf(\"Nested type of map should be of type map[string]interface{}, have %T\", m[\"B\"])\n\t}\n\n\tif _, exists := addr[\"country\"]; !exists {\n\t\tt.Errorf(\"Expecting country, but found Country\")\n\t}\n}\n\nfunc TestMap_NestedSliceWithStructValues(t *testing.T) {\n\ttype address struct {\n\t\tCountry string `structs:\"customCountryName\"`\n\t}\n\n\ttype person struct {\n\t\tName      string    `structs:\"name\"`\n\t\tAddresses []address `structs:\"addresses\"`\n\t}\n\n\tp := person{\n\t\tName: \"test\",\n\t\tAddresses: []address{\n\t\t\t{Country: \"England\"},\n\t\t\t{Country: \"Italy\"},\n\t\t},\n\t}\n\tmp := Map(p)\n\n\tmpAddresses := mp[\"addresses\"].([]interface{})\n\tif _, exists := mpAddresses[0].(map[string]interface{})[\"Country\"]; exists {\n\t\tt.Errorf(\"Expecting customCountryName, but found Country\")\n\t}\n\n\tif _, exists := mpAddresses[0].(map[string]interface{})[\"customCountryName\"]; !exists {\n\t\tt.Errorf(\"customCountryName key not found\")\n\t}\n}\n\nfunc TestMap_NestedSliceWithPointerOfStructValues(t *testing.T) {\n\ttype address struct {\n\t\tCountry string `structs:\"customCountryName\"`\n\t}\n\n\ttype person struct {\n\t\tName      string     `structs:\"name\"`\n\t\tAddresses []*address `structs:\"addresses\"`\n\t}\n\n\tp := person{\n\t\tName: \"test\",\n\t\tAddresses: []*address{\n\t\t\t{Country: \"England\"},\n\t\t\t{Country: \"Italy\"},\n\t\t},\n\t}\n\tmp := Map(p)\n\n\tmpAddresses := mp[\"addresses\"].([]interface{})\n\tif _, exists := mpAddresses[0].(map[string]interface{})[\"Country\"]; exists {\n\t\tt.Errorf(\"Expecting customCountryName, but found Country\")\n\t}\n\n\tif _, exists := mpAddresses[0].(map[string]interface{})[\"customCountryName\"]; !exists {\n\t\tt.Errorf(\"customCountryName key not found\")\n\t}\n}\n\nfunc TestMap_NestedSliceWithIntValues(t *testing.T) {\n\ttype person struct {\n\t\tName  string `structs:\"name\"`\n\t\tPorts []int  `structs:\"ports\"`\n\t}\n\n\tp := person{\n\t\tName:  \"test\",\n\t\tPorts: []int{80},\n\t}\n\tm := Map(p)\n\n\tports, ok := m[\"ports\"].([]int)\n\tif !ok {\n\t\tt.Errorf(\"Nested type of map should be of type []int, have %T\", m[\"ports\"])\n\t}\n\n\tif ports[0] != 80 {\n\t\tt.Errorf(\"Map nested struct's ports field should give 80, got: %v\", ports)\n\t}\n}\n\nfunc TestMap_Anonymous(t *testing.T) {\n\ttype A struct {\n\t\tName string\n\t}\n\ta := &A{Name: \"example\"}\n\n\ttype B struct {\n\t\t*A\n\t}\n\tb := &B{}\n\tb.A = a\n\n\tm := Map(b)\n\n\tif typ := reflect.TypeOf(m).Kind(); typ != reflect.Map {\n\t\tt.Errorf(\"Map should return a map type, got: %v\", typ)\n\t}\n\n\tin, ok := m[\"A\"].(map[string]interface{})\n\tif !ok {\n\t\tt.Error(\"Embedded structs is not available in the map\")\n\t}\n\n\tif name := in[\"Name\"].(string); name != \"example\" {\n\t\tt.Errorf(\"Embedded A struct's Name field should give example, got: %s\", name)\n\t}\n}\n\nfunc TestMap_Flatnested(t *testing.T) {\n\ttype A struct {\n\t\tName string\n\t}\n\ta := A{Name: \"example\"}\n\n\ttype B struct {\n\t\tA `structs:\",flatten\"`\n\t\tC int\n\t}\n\tb := &B{C: 123}\n\tb.A = a\n\n\tm := Map(b)\n\n\t_, ok := m[\"A\"].(map[string]interface{})\n\tif ok {\n\t\tt.Error(\"Embedded A struct with tag flatten has to be flat in the map\")\n\t}\n\n\texpectedMap := map[string]interface{}{\"Name\": \"example\", \"C\": 123}\n\tif !reflect.DeepEqual(m, expectedMap) {\n\t\tt.Errorf(\"The exprected map %+v does't correspond to %+v\", expectedMap, m)\n\t}\n\n}\n\nfunc TestMap_FlatnestedOverwrite(t *testing.T) {\n\ttype A struct {\n\t\tName string\n\t}\n\ta := A{Name: \"example\"}\n\n\ttype B struct {\n\t\tA    `structs:\",flatten\"`\n\t\tName string\n\t\tC    int\n\t}\n\tb := &B{C: 123, Name: \"bName\"}\n\tb.A = a\n\n\tm := Map(b)\n\n\t_, ok := m[\"A\"].(map[string]interface{})\n\tif ok {\n\t\tt.Error(\"Embedded A struct with tag flatten has to be flat in the map\")\n\t}\n\n\texpectedMap := map[string]interface{}{\"Name\": \"bName\", \"C\": 123}\n\tif !reflect.DeepEqual(m, expectedMap) {\n\t\tt.Errorf(\"The exprected map %+v does't correspond to %+v\", expectedMap, m)\n\t}\n}\n\nfunc TestMap_TimeField(t *testing.T) {\n\ttype A struct {\n\t\tCreatedAt time.Time\n\t}\n\n\ta := &A{CreatedAt: time.Now().UTC()}\n\tm := Map(a)\n\n\t_, ok := m[\"CreatedAt\"].(time.Time)\n\tif !ok {\n\t\tt.Error(\"Time field must be final\")\n\t}\n}\n\nfunc TestFillMap(t *testing.T) {\n\tvar T = struct {\n\t\tA string\n\t\tB int\n\t\tC bool\n\t}{\n\t\tA: \"a-value\",\n\t\tB: 2,\n\t\tC: true,\n\t}\n\n\ta := make(map[string]interface{}, 0)\n\tFillMap(T, a)\n\n\t// we have three fields\n\tif len(a) != 3 {\n\t\tt.Errorf(\"FillMap should fill a map of len 3, got: %d\", len(a))\n\t}\n\n\tinMap := func(val interface{}) bool {\n\t\tfor _, v := range a {\n\t\t\tif reflect.DeepEqual(v, val) {\n\t\t\t\treturn true\n\t\t\t}\n\t\t}\n\n\t\treturn false\n\t}\n\n\tfor _, val := range []interface{}{\"a-value\", 2, true} {\n\t\tif !inMap(val) {\n\t\t\tt.Errorf(\"FillMap should have the value %v\", val)\n\t\t}\n\t}\n}\n\nfunc TestFillMap_Nil(t *testing.T) {\n\tvar T = struct {\n\t\tA string\n\t\tB int\n\t\tC bool\n\t}{\n\t\tA: \"a-value\",\n\t\tB: 2,\n\t\tC: true,\n\t}\n\n\tdefer func() {\n\t\terr := recover()\n\t\tif err != nil {\n\t\t\tt.Error(\"FillMap should not panic if a nil map is passed\")\n\t\t}\n\t}()\n\n\t// nil should no\n\tFillMap(T, nil)\n}\nfunc TestStruct(t *testing.T) {\n\tvar T = struct{}{}\n\n\tif !IsStruct(T) {\n\t\tt.Errorf(\"T should be a struct, got: %T\", T)\n\t}\n\n\tif !IsStruct(&T) {\n\t\tt.Errorf(\"T should be a struct, got: %T\", T)\n\t}\n\n}\n\nfunc TestValues(t *testing.T) {\n\tvar T = struct {\n\t\tA string\n\t\tB int\n\t\tC bool\n\t}{\n\t\tA: \"a-value\",\n\t\tB: 2,\n\t\tC: true,\n\t}\n\n\ts := Values(T)\n\n\tif typ := reflect.TypeOf(s).Kind(); typ != reflect.Slice {\n\t\tt.Errorf(\"Values should return a slice type, got: %v\", typ)\n\t}\n\n\tinSlice := func(val interface{}) bool {\n\t\tfor _, v := range s {\n\t\t\tif reflect.DeepEqual(v, val) {\n\t\t\t\treturn true\n\t\t\t}\n\t\t}\n\t\treturn false\n\t}\n\n\tfor _, val := range []interface{}{\"a-value\", 2, true} {\n\t\tif !inSlice(val) {\n\t\t\tt.Errorf(\"Values should have the value %v\", val)\n\t\t}\n\t}\n}\n\nfunc TestValues_OmitEmpty(t *testing.T) {\n\ttype A struct {\n\t\tName  string\n\t\tValue int `structs:\",omitempty\"`\n\t}\n\n\ta := A{Name: \"example\"}\n\ts := Values(a)\n\n\tif len(s) != 1 {\n\t\tt.Errorf(\"Values of omitted empty fields should be not counted\")\n\t}\n\n\tif s[0].(string) != \"example\" {\n\t\tt.Errorf(\"Values of omitted empty fields should left the value example\")\n\t}\n}\n\nfunc TestValues_OmitNested(t *testing.T) {\n\ttype A struct {\n\t\tName  string\n\t\tValue int\n\t}\n\n\ta := A{\n\t\tName:  \"example\",\n\t\tValue: 123,\n\t}\n\n\ttype B struct {\n\t\tA A `structs:\",omitnested\"`\n\t\tC int\n\t}\n\tb := &B{A: a, C: 123}\n\n\ts := Values(b)\n\n\tif len(s) != 2 {\n\t\tt.Errorf(\"Values of omitted nested struct should be not counted\")\n\t}\n\n\tinSlice := func(val interface{}) bool {\n\t\tfor _, v := range s {\n\t\t\tif reflect.DeepEqual(v, val) {\n\t\t\t\treturn true\n\t\t\t}\n\t\t}\n\t\treturn false\n\t}\n\n\tfor _, val := range []interface{}{123, a} {\n\t\tif !inSlice(val) {\n\t\t\tt.Errorf(\"Values should have the value %v\", val)\n\t\t}\n\t}\n}\n\nfunc TestValues_Nested(t *testing.T) {\n\ttype A struct {\n\t\tName string\n\t}\n\ta := A{Name: \"example\"}\n\n\ttype B struct {\n\t\tA A\n\t\tC int\n\t}\n\tb := &B{A: a, C: 123}\n\n\ts := Values(b)\n\n\tinSlice := func(val interface{}) bool {\n\t\tfor _, v := range s {\n\t\t\tif reflect.DeepEqual(v, val) {\n\t\t\t\treturn true\n\t\t\t}\n\t\t}\n\t\treturn false\n\t}\n\n\tfor _, val := range []interface{}{\"example\", 123} {\n\t\tif !inSlice(val) {\n\t\t\tt.Errorf(\"Values should have the value %v\", val)\n\t\t}\n\t}\n}\n\nfunc TestValues_Anonymous(t *testing.T) {\n\ttype A struct {\n\t\tName string\n\t}\n\ta := A{Name: \"example\"}\n\n\ttype B struct {\n\t\tA\n\t\tC int\n\t}\n\tb := &B{C: 123}\n\tb.A = a\n\n\ts := Values(b)\n\n\tinSlice := func(val interface{}) bool {\n\t\tfor _, v := range s {\n\t\t\tif reflect.DeepEqual(v, val) {\n\t\t\t\treturn true\n\t\t\t}\n\t\t}\n\t\treturn false\n\t}\n\n\tfor _, val := range []interface{}{\"example\", 123} {\n\t\tif !inSlice(val) {\n\t\t\tt.Errorf(\"Values should have the value %v\", val)\n\t\t}\n\t}\n}\n\nfunc TestNames(t *testing.T) {\n\tvar T = struct {\n\t\tA string\n\t\tB int\n\t\tC bool\n\t}{\n\t\tA: \"a-value\",\n\t\tB: 2,\n\t\tC: true,\n\t}\n\n\ts := Names(T)\n\n\tif len(s) != 3 {\n\t\tt.Errorf(\"Names should return a slice of len 3, got: %d\", len(s))\n\t}\n\n\tinSlice := func(val string) bool {\n\t\tfor _, v := range s {\n\t\t\tif reflect.DeepEqual(v, val) {\n\t\t\t\treturn true\n\t\t\t}\n\t\t}\n\t\treturn false\n\t}\n\n\tfor _, val := range []string{\"A\", \"B\", \"C\"} {\n\t\tif !inSlice(val) {\n\t\t\tt.Errorf(\"Names should have the value %v\", val)\n\t\t}\n\t}\n}\n\nfunc TestFields(t *testing.T) {\n\tvar T = struct {\n\t\tA string\n\t\tB int\n\t\tC bool\n\t}{\n\t\tA: \"a-value\",\n\t\tB: 2,\n\t\tC: true,\n\t}\n\n\ts := Fields(T)\n\n\tif len(s) != 3 {\n\t\tt.Errorf(\"Fields should return a slice of len 3, got: %d\", len(s))\n\t}\n\n\tinSlice := func(val string) bool {\n\t\tfor _, v := range s {\n\t\t\tif reflect.DeepEqual(v.Name(), val) {\n\t\t\t\treturn true\n\t\t\t}\n\t\t}\n\t\treturn false\n\t}\n\n\tfor _, val := range []string{\"A\", \"B\", \"C\"} {\n\t\tif !inSlice(val) {\n\t\t\tt.Errorf(\"Fields should have the value %v\", val)\n\t\t}\n\t}\n}\n\nfunc TestFields_OmitNested(t *testing.T) {\n\ttype A struct {\n\t\tName    string\n\t\tEnabled bool\n\t}\n\ta := A{Name: \"example\"}\n\n\ttype B struct {\n\t\tA      A\n\t\tC      int\n\t\tValue  string `structs:\"-\"`\n\t\tNumber int\n\t}\n\tb := &B{A: a, C: 123}\n\n\ts := Fields(b)\n\n\tif len(s) != 3 {\n\t\tt.Errorf(\"Fields should omit nested struct. Expecting 2 got: %d\", len(s))\n\t}\n\n\tinSlice := func(val interface{}) bool {\n\t\tfor _, v := range s {\n\t\t\tif reflect.DeepEqual(v.Name(), val) {\n\t\t\t\treturn true\n\t\t\t}\n\t\t}\n\t\treturn false\n\t}\n\n\tfor _, val := range []interface{}{\"A\", \"C\"} {\n\t\tif !inSlice(val) {\n\t\t\tt.Errorf(\"Fields should have the value %v\", val)\n\t\t}\n\t}\n}\n\nfunc TestFields_Anonymous(t *testing.T) {\n\ttype A struct {\n\t\tName string\n\t}\n\ta := A{Name: \"example\"}\n\n\ttype B struct {\n\t\tA\n\t\tC int\n\t}\n\tb := &B{C: 123}\n\tb.A = a\n\n\ts := Fields(b)\n\n\tinSlice := func(val interface{}) bool {\n\t\tfor _, v := range s {\n\t\t\tif reflect.DeepEqual(v.Name(), val) {\n\t\t\t\treturn true\n\t\t\t}\n\t\t}\n\t\treturn false\n\t}\n\n\tfor _, val := range []interface{}{\"A\", \"C\"} {\n\t\tif !inSlice(val) {\n\t\t\tt.Errorf(\"Fields should have the value %v\", val)\n\t\t}\n\t}\n}\n\nfunc TestIsZero(t *testing.T) {\n\tvar T = struct {\n\t\tA string\n\t\tB int\n\t\tC bool `structs:\"-\"`\n\t\tD []string\n\t}{}\n\n\tok := IsZero(T)\n\tif !ok {\n\t\tt.Error(\"IsZero should return true because none of the fields are initialized.\")\n\t}\n\n\tvar X = struct {\n\t\tA string\n\t\tF *bool\n\t}{\n\t\tA: \"a-value\",\n\t}\n\n\tok = IsZero(X)\n\tif ok {\n\t\tt.Error(\"IsZero should return false because A is initialized\")\n\t}\n\n\tvar Y = struct {\n\t\tA string\n\t\tB int\n\t}{\n\t\tA: \"a-value\",\n\t\tB: 123,\n\t}\n\n\tok = IsZero(Y)\n\tif ok {\n\t\tt.Error(\"IsZero should return false because A and B is initialized\")\n\t}\n}\n\nfunc TestIsZero_OmitNested(t *testing.T) {\n\ttype A struct {\n\t\tName string\n\t\tD    string\n\t}\n\ta := A{Name: \"example\"}\n\n\ttype B struct {\n\t\tA A `structs:\",omitnested\"`\n\t\tC int\n\t}\n\tb := &B{A: a, C: 123}\n\n\tok := IsZero(b)\n\tif ok {\n\t\tt.Error(\"IsZero should return false because A, B and C are initialized\")\n\t}\n\n\taZero := A{}\n\tbZero := &B{A: aZero}\n\n\tok = IsZero(bZero)\n\tif !ok {\n\t\tt.Error(\"IsZero should return true because neither A nor B is initialized\")\n\t}\n\n}\n\nfunc TestIsZero_Nested(t *testing.T) {\n\ttype A struct {\n\t\tName string\n\t\tD    string\n\t}\n\ta := A{Name: \"example\"}\n\n\ttype B struct {\n\t\tA A\n\t\tC int\n\t}\n\tb := &B{A: a, C: 123}\n\n\tok := IsZero(b)\n\tif ok {\n\t\tt.Error(\"IsZero should return false because A, B and C are initialized\")\n\t}\n\n\taZero := A{}\n\tbZero := &B{A: aZero}\n\n\tok = IsZero(bZero)\n\tif !ok {\n\t\tt.Error(\"IsZero should return true because neither A nor B is initialized\")\n\t}\n\n}\n\nfunc TestIsZero_Anonymous(t *testing.T) {\n\ttype A struct {\n\t\tName string\n\t\tD    string\n\t}\n\ta := A{Name: \"example\"}\n\n\ttype B struct {\n\t\tA\n\t\tC int\n\t}\n\tb := &B{C: 123}\n\tb.A = a\n\n\tok := IsZero(b)\n\tif ok {\n\t\tt.Error(\"IsZero should return false because A, B and C are initialized\")\n\t}\n\n\taZero := A{}\n\tbZero := &B{}\n\tbZero.A = aZero\n\n\tok = IsZero(bZero)\n\tif !ok {\n\t\tt.Error(\"IsZero should return true because neither A nor B is initialized\")\n\t}\n}\n\nfunc TestHasZero(t *testing.T) {\n\tvar T = struct {\n\t\tA string\n\t\tB int\n\t\tC bool `structs:\"-\"`\n\t\tD []string\n\t}{\n\t\tA: \"a-value\",\n\t\tB: 2,\n\t}\n\n\tok := HasZero(T)\n\tif !ok {\n\t\tt.Error(\"HasZero should return true because A and B are initialized.\")\n\t}\n\n\tvar X = struct {\n\t\tA string\n\t\tF *bool\n\t}{\n\t\tA: \"a-value\",\n\t}\n\n\tok = HasZero(X)\n\tif !ok {\n\t\tt.Error(\"HasZero should return true because A is initialized\")\n\t}\n\n\tvar Y = struct {\n\t\tA string\n\t\tB int\n\t}{\n\t\tA: \"a-value\",\n\t\tB: 123,\n\t}\n\n\tok = HasZero(Y)\n\tif ok {\n\t\tt.Error(\"HasZero should return false because A and B is initialized\")\n\t}\n}\n\nfunc TestHasZero_OmitNested(t *testing.T) {\n\ttype A struct {\n\t\tName string\n\t\tD    string\n\t}\n\ta := A{Name: \"example\"}\n\n\ttype B struct {\n\t\tA A `structs:\",omitnested\"`\n\t\tC int\n\t}\n\tb := &B{A: a, C: 123}\n\n\t// Because the Field A inside B is omitted  HasZero should return false\n\t// because it will stop iterating deeper andnot going to lookup for D\n\tok := HasZero(b)\n\tif ok {\n\t\tt.Error(\"HasZero should return false because A and C are initialized\")\n\t}\n}\n\nfunc TestHasZero_Nested(t *testing.T) {\n\ttype A struct {\n\t\tName string\n\t\tD    string\n\t}\n\ta := A{Name: \"example\"}\n\n\ttype B struct {\n\t\tA A\n\t\tC int\n\t}\n\tb := &B{A: a, C: 123}\n\n\tok := HasZero(b)\n\tif !ok {\n\t\tt.Error(\"HasZero should return true because D is not initialized\")\n\t}\n}\n\nfunc TestHasZero_Anonymous(t *testing.T) {\n\ttype A struct {\n\t\tName string\n\t\tD    string\n\t}\n\ta := A{Name: \"example\"}\n\n\ttype B struct {\n\t\tA\n\t\tC int\n\t}\n\tb := &B{C: 123}\n\tb.A = a\n\n\tok := HasZero(b)\n\tif !ok {\n\t\tt.Error(\"HasZero should return false because D is not initialized\")\n\t}\n}\n\nfunc TestName(t *testing.T) {\n\ttype Foo struct {\n\t\tA string\n\t\tB bool\n\t}\n\tf := &Foo{}\n\n\tn := Name(f)\n\tif n != \"Foo\" {\n\t\tt.Errorf(\"Name should return Foo, got: %s\", n)\n\t}\n\n\tunnamed := struct{ Name string }{Name: \"Cihangir\"}\n\tm := Name(unnamed)\n\tif m != \"\" {\n\t\tt.Errorf(\"Name should return empty string for unnamed struct, got: %s\", n)\n\t}\n\n\tdefer func() {\n\t\terr := recover()\n\t\tif err == nil {\n\t\t\tt.Error(\"Name should panic if a non struct is passed\")\n\t\t}\n\t}()\n\n\tName([]string{})\n}\n\nfunc TestNestedNilPointer(t *testing.T) {\n\ttype Collar struct {\n\t\tEngraving string\n\t}\n\n\ttype Dog struct {\n\t\tName   string\n\t\tCollar *Collar\n\t}\n\n\ttype Person struct {\n\t\tName string\n\t\tDog  *Dog\n\t}\n\n\tperson := &Person{\n\t\tName: \"John\",\n\t}\n\n\tpersonWithDog := &Person{\n\t\tName: \"Ron\",\n\t\tDog: &Dog{\n\t\t\tName: \"Rover\",\n\t\t},\n\t}\n\n\tpersonWithDogWithCollar := &Person{\n\t\tName: \"Kon\",\n\t\tDog: &Dog{\n\t\t\tName: \"Ruffles\",\n\t\t\tCollar: &Collar{\n\t\t\t\tEngraving: \"If lost, call Kon\",\n\t\t\t},\n\t\t},\n\t}\n\n\tdefer func() {\n\t\terr := recover()\n\t\tif err != nil {\n\t\t\tfmt.Printf(\"err %+v\\n\", err)\n\t\t\tt.Error(\"Internal nil pointer should not panic\")\n\t\t}\n\t}()\n\n\t_ = Map(person)                  // Panics\n\t_ = Map(personWithDog)           // Panics\n\t_ = Map(personWithDogWithCollar) // Doesn't panic\n}\n\nfunc TestSetValueOnNestedField(t *testing.T) {\n\ttype Base struct {\n\t\tID int\n\t}\n\n\ttype User struct {\n\t\tBase\n\t\tName string\n\t}\n\n\tu := User{}\n\ts := New(&u)\n\tf := s.Field(\"Base\").Field(\"ID\")\n\terr := f.Set(10)\n\tif err != nil {\n\t\tt.Errorf(\"Error %v\", err)\n\t}\n\tif f.Value().(int) != 10 {\n\t\tt.Errorf(\"Value should be equal to 10, got %v\", f.Value())\n\t}\n}\n\ntype Person struct {\n\tName string\n\tAge  int\n}\n\nfunc (p *Person) String() string {\n\treturn fmt.Sprintf(\"%s(%d)\", p.Name, p.Age)\n}\n\nfunc TestTagWithStringOption(t *testing.T) {\n\n\ttype Address struct {\n\t\tCountry string  `json:\"country\"`\n\t\tPerson  *Person `json:\"person,string\"`\n\t}\n\n\tperson := &Person{\n\t\tName: \"John\",\n\t\tAge:  23,\n\t}\n\n\taddress := &Address{\n\t\tCountry: \"EU\",\n\t\tPerson:  person,\n\t}\n\n\tdefer func() {\n\t\terr := recover()\n\t\tif err != nil {\n\t\t\tfmt.Printf(\"err %+v\\n\", err)\n\t\t\tt.Error(\"Internal nil pointer should not panic\")\n\t\t}\n\t}()\n\n\ts := New(address)\n\n\ts.TagName = \"json\"\n\tm := s.Map()\n\n\tif m[\"person\"] != person.String() {\n\t\tt.Errorf(\"Value for field person should be %s, got: %s\", person.String(), m[\"person\"])\n\t}\n\n\tvs := s.Values()\n\tif vs[1] != person.String() {\n\t\tt.Errorf(\"Value for 2nd field (person) should be %T, got: %T\", person.String(), vs[1])\n\t}\n}\n\ntype Animal struct {\n\tName string\n\tAge  int\n}\n\ntype Dog struct {\n\tAnimal *Animal `json:\"animal,string\"`\n}\n\nfunc TestNonStringerTagWithStringOption(t *testing.T) {\n\ta := &Animal{\n\t\tName: \"Fluff\",\n\t\tAge:  4,\n\t}\n\n\td := &Dog{\n\t\tAnimal: a,\n\t}\n\n\tdefer func() {\n\t\terr := recover()\n\t\tif err != nil {\n\t\t\tfmt.Printf(\"err %+v\\n\", err)\n\t\t\tt.Error(\"Internal nil pointer should not panic\")\n\t\t}\n\t}()\n\n\ts := New(d)\n\n\ts.TagName = \"json\"\n\tm := s.Map()\n\n\tif _, exists := m[\"animal\"]; exists {\n\t\tt.Errorf(\"Value for field Animal should not exist\")\n\t}\n}\n\nfunc TestMap_InterfaceValue(t *testing.T) {\n\ttype TestStruct struct {\n\t\tA interface{}\n\t}\n\n\texpected := []byte(\"test value\")\n\n\ta := TestStruct{A: expected}\n\ts := Map(a)\n\tif !reflect.DeepEqual(s[\"A\"], expected) {\n\t\tt.Errorf(\"Value does not match expected: %q != %q\", s[\"A\"], expected)\n\t}\n}\n\nfunc TestPointer2Pointer(t *testing.T) {\n\tdefer func() {\n\t\terr := recover()\n\t\tif err != nil {\n\t\t\tfmt.Printf(\"err %+v\\n\", err)\n\t\t\tt.Error(\"Internal nil pointer should not panic\")\n\t\t}\n\t}()\n\ta := &Animal{\n\t\tName: \"Fluff\",\n\t\tAge:  4,\n\t}\n\t_ = Map(&a)\n\n\tb := &a\n\t_ = Map(&b)\n\n\tc := &b\n\t_ = Map(&c)\n}\n\nfunc TestMap_InterfaceTypeWithMapValue(t *testing.T) {\n\ttype A struct {\n\t\tName    string      `structs:\"name\"`\n\t\tIP      string      `structs:\"ip\"`\n\t\tQuery   string      `structs:\"query\"`\n\t\tPayload interface{} `structs:\"payload\"`\n\t}\n\n\ta := A{\n\t\tName:    \"test\",\n\t\tIP:      \"127.0.0.1\",\n\t\tQuery:   \"\",\n\t\tPayload: map[string]string{\"test_param\": \"test_param\"},\n\t}\n\n\tdefer func() {\n\t\terr := recover()\n\t\tif err != nil {\n\t\t\tt.Error(\"Converting Map with an interface{} type with map value should not panic\")\n\t\t}\n\t}()\n\n\t_ = Map(a)\n}\n"
        },
        {
          "name": "tags.go",
          "type": "blob",
          "size": 0.6787109375,
          "content": "package structs\n\nimport \"strings\"\n\n// tagOptions contains a slice of tag options\ntype tagOptions []string\n\n// Has returns true if the given option is available in tagOptions\nfunc (t tagOptions) Has(opt string) bool {\n\tfor _, tagOpt := range t {\n\t\tif tagOpt == opt {\n\t\t\treturn true\n\t\t}\n\t}\n\n\treturn false\n}\n\n// parseTag splits a struct field's tag into its name and a list of options\n// which comes after a name. A tag is in the form of: \"name,option1,option2\".\n// The name can be neglectected.\nfunc parseTag(tag string) (string, tagOptions) {\n\t// tag is one of followings:\n\t// \"\"\n\t// \"name\"\n\t// \"name,opt\"\n\t// \"name,opt,opt2\"\n\t// \",opt\"\n\n\tres := strings.Split(tag, \",\")\n\treturn res[0], res[1:]\n}\n"
        },
        {
          "name": "tags_test.go",
          "type": "blob",
          "size": 0.822265625,
          "content": "package structs\n\nimport \"testing\"\n\nfunc TestParseTag_Name(t *testing.T) {\n\ttags := []struct {\n\t\ttag string\n\t\thas bool\n\t}{\n\t\t{\"\", false},\n\t\t{\"name\", true},\n\t\t{\"name,opt\", true},\n\t\t{\"name , opt, opt2\", false}, // has a single whitespace\n\t\t{\", opt, opt2\", false},\n\t}\n\n\tfor _, tag := range tags {\n\t\tname, _ := parseTag(tag.tag)\n\n\t\tif (name != \"name\") && tag.has {\n\t\t\tt.Errorf(\"Parse tag should return name: %#v\", tag)\n\t\t}\n\t}\n}\n\nfunc TestParseTag_Opts(t *testing.T) {\n\ttags := []struct {\n\t\topts string\n\t\thas  bool\n\t}{\n\t\t{\"name\", false},\n\t\t{\"name,opt\", true},\n\t\t{\"name , opt, opt2\", false}, // has a single whitespace\n\t\t{\",opt, opt2\", true},\n\t\t{\", opt3, opt4\", false},\n\t}\n\n\t// search for \"opt\"\n\tfor _, tag := range tags {\n\t\t_, opts := parseTag(tag.opts)\n\n\t\tif opts.Has(\"opt\") != tag.has {\n\t\t\tt.Errorf(\"Tag opts should have opt: %#v\", tag)\n\t\t}\n\t}\n}\n"
        }
      ]
    }
  ]
}