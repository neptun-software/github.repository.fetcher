{
  "metadata": {
    "timestamp": 1736566872875,
    "page": 443,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjQ1MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "rogchap/v8go",
      "stars": 3250,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".fossa.yml",
          "type": "blob",
          "size": 0.2412109375,
          "content": "# Visit https://fossa.com to learn more\n\nversion: 2\ncli:\n  server: https://app.fossa.com\n  fetcher: custom\n  project: git@github.com:rogchap/v8go.git\nanalyze:\n  modules:\n    - name: v8go\n      type: go\n      target: rogchap.com/v8go\n      path: .\n"
        },
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.1259765625,
          "content": "*swp\n.DS_Store\n\n.build\n.cipd\n.gclient_entries\n\ndeps/darwin-x86_64/libv8_debug.a\ndeps/.gclient_previous*\nc.out\n.idea/*\n/v8go.test\n"
        },
        {
          "name": ".gitmodules",
          "type": "blob",
          "size": 0.2119140625,
          "content": "[submodule \"deps/v8\"]\n\tpath = deps/v8\n\turl = https://chromium.googlesource.com/v8/v8.git\n[submodule \"deps/depot_tools\"]\n\tpath = deps/depot_tools\n\turl = https://chromium.googlesource.com/chromium/tools/depot_tools.git\n"
        },
        {
          "name": "CHANGELOG.md",
          "type": "blob",
          "size": 5.4287109375,
          "content": "# Changelog\nAll notable changes to this project will be documented in this file.\n\nThe format is based on [Keep a Changelog](https://keepachangelog.com/en/1.0.0/),\nand this project adheres to [Semantic Versioning](https://semver.org/spec/v2.0.0.html).\n\n## [v0.10.0] - 2023-04-10\n\n### Changed\n- Required Go version changed to 1.17 (needed for SharedArrayBuffer support)\n\n### Added\n- Support for getting the underlying data (as a `[]byte`) from a SharedArrayBuffer\n\n### Fixed\n- Upgrade to V8 11.1.277.13\n\n\n## [v0.9.0] - 2023-03-30\n\n### Fixed\n- Upgrade to V8 11.1.277.13\n\n## [v0.8.0] - 2023-01-19\n\n### Added\n- Added support for Value.release() and FunctionCallbackInfo.release(). This is useful when using v8go in a long-running context.\n\n### Fixed\n- Use string length to ensure null character-containing strings in Go/JS are not terminated early.\n- Object.Set with an empty key string is now supported\n- Upgrade to V8 10.9.194.9\n- Upgrade V8 build OS to Ubuntu 22.04\n\n## [v0.7.0] - 2021-12-09\n\n### Added\n- Support for calling constructors functions with NewInstance on Function\n- Access \"this\" from function callback\n- value.SameValue(otherValue) function to compare values for sameness\n- Undefined, Null functions to get these constant values for the isolate\n- Support for calling a method on an object.\n- Support for calling `IsExecutionTerminating` on isolate to check if execution is still terminating.\n- Support for setting and getting internal fields for template object instances\n- Support for CPU profiling\n- Add V8 build for Apple Silicon\n- Add support for throwing an exception directly via the isolate's ThrowException function.\n- Support for compiling a context-dependent UnboundScript which can be run in any context of the isolate it was compiled in.\n- Support for creating a code cache from an UnboundScript which can be used to create an UnboundScript in other isolates\nto run a pre-compiled script in new contexts.\n- Included compile error location in `%+v` formatting of JSError\n- Enable i18n support\n\n### Changed\n- Removed error return value from NewIsolate which never fails\n- Removed error return value from NewContext which never fails\n- Removed error return value from Context.Isolate() which never fails\n- Removed error return value from NewObjectTemplate and NewFunctionTemplate. Panic if given a nil argument.\n- Function Call accepts receiver as first argument. This **subtle breaking change** will compile old code but interpret the first argument as the receiver. Use `Undefined` to prepend an argument to fix old Call use.\n- Removed Windows support until its build issues are addressed.\n- Upgrade to V8 9.6.180.12\n\n### Fixed\n- Add some missing error propagation\n- Fix crash from template finalizer releasing V8 data, let it be disposed with the isolate\n- Fix crash by keeping alive the template while its C++ pointer is still being used\n- Fix crash from accessing function template callbacks outside of `RunScript`, such as in `JSONStringify`\n\n## [v0.6.0] - 2021-05-11\n\n### Added\n- Promise resolver and promise result\n- Convert a Value to a Function and invoke it. Thanks to [@robfig](https://github.com/robfig)\n- Windows static binary. Thanks to [@cleiner](https://github.com/cleiner)\n- Setting/unsetting of V8 feature flags\n- Register promise callbacks in Go. Thanks to [@robfig](https://github.com/robfig)\n- Get Function from a template for a given context. Thanks to [@robfig](https://github.com/robfig)\n\n### Changed\n- Upgrade to V8 9.0.257.18\n\n### Fixed\n- Go GC attempting to free C memory (via finalizer) of values after an Isolate is disposed causes a panic\n\n## [v0.5.1] - 2021-02-19\n\n### Fixed\n- Memory being held by Values after the associated Context is closed\n\n## [v0.5.0] - 2021-02-08\n\n### Added\n- Support for the BigInt value to the big.Int Go type\n- Create Object Templates with primitive values, including other Object Templates\n- Configure Object Template as the global object of any new Context\n- Function Templates with callbacks to Go\n- Value to Object type, including Get/Set/Has/Delete methods\n- Get Global Object from the Context\n- Convert an Object Template to an instance of an Object\n\n### Changed\n- NewContext() API has been improved to handle optional global object, as well as optional Isolate\n- Package error messages are now prefixed with `v8go` rather than the struct name\n- Deprecated `iso.Close()` in favor of `iso.Dispose()` to keep consistancy with the C++ API\n- Upgraded V8 to 8.8.278.14\n- Licence BSD 3-Clause (same as V8 and Go)\n\n## [v0.4.0] - 2021-01-14\n\n### Added\n- Value methods for checking value kind (is string, number, array etc)\n- C formatting via `clang-format` to aid future development\n- Support of vendoring with `go mod vendor`\n- Value methods to convert to primitive data types\n\n### Changed\n- Use g++ (default for cgo) for linux builds of the static v8 lib\n\n## [v0.3.0] - 2020-12-18\n\n### Added\n- Support for Windows via [MSYS2](https://www.msys2.org/). Thanks to [@neptoess](https://github.com/neptoess)\n\n### Changed\n- Upgraded V8 to 8.7.220.31\n\n## [v0.2.0] - 2020-01-25\n\n### Added\n- Manually dispose of the isolate when required\n- Monitor isolate heap statistics. Thanks to [@mehrdadrad](https://github.com/mehrdadrad)\n\n### Changed\n- Upgrade V8 to 8.0.426.15\n\n## [v0.1.0] - 2019-09-22\n\n### Changed\n- Upgrade V8 to 7.7.299.9\n\n## [v0.0.1] - 2019-09-2020\n\n### Added\n- Create V8 Isolate\n- Create Contexts\n- Run JavaScript scripts\n- Get Values back from JavaScript in Go\n- Get detailed JavaScript errors in Go, including stack traces\n- Terminate long running scripts from any Goroutine\n"
        },
        {
          "name": "CONTRIBUTING.md",
          "type": "blob",
          "size": 1.62109375,
          "content": "# How to contribute\n\n**Working on your first Pull Request?** You can learn how from this *free* series [How to Contribute to an Open Source Project on GitHub](https://egghead.io/series/how-to-contribute-to-an-open-source-project-on-github)\n\n## Guidelines for Pull Requests\n\nHow to get your contributions merged smoothly and quickly.\n\n* Create **small PRs** that are narrowly focused on **addressing a single concern**. We often times receive PRs that are trying to fix several things at a time, but only one fix is considered acceptable, nothing gets merged and both author's & review's time is wasted. Create more PRs to address different concerns and everyone will be happy.\n\n* For speculative changes, consider opening an issue and discussing it first.\n\n* Provide a good **PR description** as a record of **what** change is being made and **why** it was made. Link to a github issue if it exists.\n\n* Unless your PR is trivial, you should expect there will be reviewer comments that you'll need to address before merging. We expect you to be reasonably responsive to those comments, otherwise the PR will be closed after 2-3 weeks of inactivity.\n\n* Maintain **clean commit history** and use **meaningful commit messages**. PRs with messy commit history are difficult to review and won't be merged. Use `rebase -i upstream/master` to curate your commit history and/or to bring in latest changes from master (but avoid rebasing in the middle of a code review).\n\n* Keep your PR up to date with upstream/master (if there are merge conflicts, we can't really merge your change).\n\n* Exceptions to the rules can be made if there's a compelling reason for doing so.\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.5126953125,
          "content": "Copyright (c) 2019 Roger Chapman and the v8go contributors.\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are met:\n\n   1. Redistributions of source code must retain the above copyright notice,\n      this list of conditions and the following disclaimer.\n\n   2. Redistributions in binary form must reproduce the above copyright notice,\n      this list of conditions and the following disclaimer in the documentation\n      and/or other materials provided with the distribution.\n\n   3. Neither the name of the copyright holder nor the names of its\n      contributors may be used to endorse or promote products derived from\n      this software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\nAND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\nIMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\nFOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\nDAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\nSERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\nCAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\nOR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 14.09765625,
          "content": "# Execute JavaScript from Go\n\n<a href=\"https://github.com/rogchap/v8go/releases\"><img src=\"https://img.shields.io/github/v/release/rogchap/v8go\" alt=\"Github release\"></a>\n[![Go Report Card](https://goreportcard.com/badge/rogchap.com/v8go)](https://goreportcard.com/report/rogchap.com/v8go)\n[![Go Reference](https://pkg.go.dev/badge/rogchap.com/v8go.svg)](https://pkg.go.dev/rogchap.com/v8go)\n[![CI](https://github.com/rogchap/v8go/workflows/CI/badge.svg)](https://github.com/rogchap/v8go/actions?query=workflow%3ACI)\n![V8 Build](https://github.com/rogchap/v8go/workflows/V8%20Build/badge.svg)\n[![codecov](https://codecov.io/gh/rogchap/v8go/branch/master/graph/badge.svg?token=VHZwzGm3dV)](https://codecov.io/gh/rogchap/v8go)\n[![FOSSA Status](https://app.fossa.com/api/projects/custom%2B22862%2Fgit%40github.com%3Arogchap%2Fv8go.git.svg?type=shield)](https://app.fossa.com/projects/custom%2B22862%2Fgit%40github.com%3Arogchap%2Fv8go.git?ref=badge_shield)\n[![#v8go Slack Channel](https://img.shields.io/badge/slack-%23v8go-4A154B?logo=slack)](https://gophers.slack.com/channels/v8go)\n\n<img src=\"gopher.jpg\" width=\"200px\" alt=\"V8 Gopher based on original artwork from the amazing Renee French\" />\n\n## Usage\n\n```go\nimport v8 \"rogchap.com/v8go\"\n```\n\n### Running a script\n\n```go\nctx := v8.NewContext() // creates a new V8 context with a new Isolate aka VM\nctx.RunScript(\"const add = (a, b) => a + b\", \"math.js\") // executes a script on the global context\nctx.RunScript(\"const result = add(3, 4)\", \"main.js\") // any functions previously added to the context can be called\nval, _ := ctx.RunScript(\"result\", \"value.js\") // return a value in JavaScript back to Go\nfmt.Printf(\"addition result: %s\", val)\n```\n\n### One VM, many contexts\n\n```go\niso := v8.NewIsolate() // creates a new JavaScript VM\nctx1 := v8.NewContext(iso) // new context within the VM\nctx1.RunScript(\"const multiply = (a, b) => a * b\", \"math.js\")\n\nctx2 := v8.NewContext(iso) // another context on the same VM\nif _, err := ctx2.RunScript(\"multiply(3, 4)\", \"main.js\"); err != nil {\n  // this will error as multiply is not defined in this context\n}\n```\n\n### JavaScript function with Go callback\n\n```go\niso := v8.NewIsolate() // create a new VM\n// a template that represents a JS function\nprintfn := v8.NewFunctionTemplate(iso, func(info *v8.FunctionCallbackInfo) *v8.Value {\n    fmt.Printf(\"%v\", info.Args()) // when the JS function is called this Go callback will execute\n    return nil // you can return a value back to the JS caller if required\n})\nglobal := v8.NewObjectTemplate(iso) // a template that represents a JS Object\nglobal.Set(\"print\", printfn) // sets the \"print\" property of the Object to our function\nctx := v8.NewContext(iso, global) // new Context with the global Object set to our object template\nctx.RunScript(\"print('foo')\", \"print.js\") // will execute the Go callback with a single argunent 'foo'\n```\n\n### Update a JavaScript object from Go\n\n```go\nctx := v8.NewContext() // new context with a default VM\nobj := ctx.Global() // get the global object from the context\nobj.Set(\"version\", \"v1.0.0\") // set the property \"version\" on the object\nval, _ := ctx.RunScript(\"version\", \"version.js\") // global object will have the property set within the JS VM\nfmt.Printf(\"version: %s\", val)\n\nif obj.Has(\"version\") { // check if a property exists on the object\n    obj.Delete(\"version\") // remove the property from the object\n}\n```\n\n### JavaScript errors\n\n```go\nval, err := ctx.RunScript(src, filename)\nif err != nil {\n  e := err.(*v8.JSError) // JavaScript errors will be returned as the JSError struct\n  fmt.Println(e.Message) // the message of the exception thrown\n  fmt.Println(e.Location) // the filename, line number and the column where the error occured\n  fmt.Println(e.StackTrace) // the full stack trace of the error, if available\n\n  fmt.Printf(\"javascript error: %v\", e) // will format the standard error message\n  fmt.Printf(\"javascript stack trace: %+v\", e) // will format the full error stack trace\n}\n```\n\n### Pre-compile context-independent scripts to speed-up execution times\n\nFor scripts that are large or are repeatedly run in different contexts,\nit is beneficial to compile the script once and used the cached data from that\ncompilation to avoid recompiling every time you want to run it.\n\n```go\nsource := \"const multiply = (a, b) => a * b\"\niso1 := v8.NewIsolate() // creates a new JavaScript VM\nctx1 := v8.NewContext(iso1) // new context within the VM\nscript1, _ := iso1.CompileUnboundScript(source, \"math.js\", v8.CompileOptions{}) // compile script to get cached data\nval, _ := script1.Run(ctx1)\n\ncachedData := script1.CreateCodeCache()\n\niso2 := v8.NewIsolate() // create a new JavaScript VM\nctx2 := v8.NewContext(iso2) // new context within the VM\n\nscript2, _ := iso2.CompileUnboundScript(source, \"math.js\", v8.CompileOptions{CachedData: cachedData}) // compile script in new isolate with cached data\nval, _ = script2.Run(ctx2)\n```\n\n### Terminate long running scripts\n\n```go\nvals := make(chan *v8.Value, 1)\nerrs := make(chan error, 1)\n\ngo func() {\n    val, err := ctx.RunScript(script, \"forever.js\") // exec a long running script\n    if err != nil {\n        errs <- err\n        return\n    }\n    vals <- val\n}()\n\nselect {\ncase val := <- vals:\n    // success\ncase err := <- errs:\n    // javascript error\ncase <- time.After(200 * time.Milliseconds):\n    vm := ctx.Isolate() // get the Isolate from the context\n    vm.TerminateExecution() // terminate the execution\n    err := <- errs // will get a termination error back from the running script\n}\n```\n\n### CPU Profiler\n\n```go\nfunc createProfile() {\n\tiso := v8.NewIsolate()\n\tctx := v8.NewContext(iso)\n\tcpuProfiler := v8.NewCPUProfiler(iso)\n\n\tcpuProfiler.StartProfiling(\"my-profile\")\n\n\tctx.RunScript(profileScript, \"script.js\") # this script is defined in cpuprofiler_test.go\n\tval, _ := ctx.Global().Get(\"start\")\n\tfn, _ := val.AsFunction()\n\tfn.Call(ctx.Global())\n\n\tcpuProfile := cpuProfiler.StopProfiling(\"my-profile\")\n\n\tprintTree(\"\", cpuProfile.GetTopDownRoot()) # helper function to print the profile\n}\n\nfunc printTree(nest string, node *v8.CPUProfileNode) {\n\tfmt.Printf(\"%s%s %s:%d:%d\\n\", nest, node.GetFunctionName(), node.GetScriptResourceName(), node.GetLineNumber(), node.GetColumnNumber())\n\tcount := node.GetChildrenCount()\n\tif count == 0 {\n\t\treturn\n\t}\n\tnest = fmt.Sprintf(\"%s  \", nest)\n\tfor i := 0; i < count; i++ {\n\t\tprintTree(nest, node.GetChild(i))\n\t}\n}\n\n// Output\n// (root) :0:0\n//   (program) :0:0\n//   start script.js:23:15\n//     foo script.js:15:13\n//       delay script.js:12:15\n//         loop script.js:1:14\n//       bar script.js:13:13\n//         delay script.js:12:15\n//           loop script.js:1:14\n//       baz script.js:14:13\n//         delay script.js:12:15\n//           loop script.js:1:14\n//   (garbage collector) :0:0\n```\n\n## Documentation\n\nGo Reference & more examples: https://pkg.go.dev/rogchap.com/v8go\n\n### Support\n\nIf you would like to ask questions about this library or want to keep up-to-date with the latest changes and releases,\nplease join the [**#v8go**](https://gophers.slack.com/channels/v8go) channel on Gophers Slack. [Click here to join the Gophers Slack community!](https://invite.slack.golangbridge.org/)\n\n### Windows\n\nThere used to be Windows binary support. For further information see, [PR #234](https://github.com/rogchap/v8go/pull/234).\n\nThe v8go library would welcome contributions from anyone able to get an external windows\nbuild of the V8 library linking with v8go, using the version of V8 checked out in the\n`deps/v8` git submodule, and documentation of the process involved. This process will likely\ninvolve passing a linker flag when building v8go (e.g. using the `CGO_LDFLAGS` environment\nvariable.\n\n## V8 dependency\n\nV8 version: **9.0.257.18** (April 2021)\n\nIn order to make `v8go` usable as a standard Go package, prebuilt static libraries of V8\nare included for Linux and macOS. you *should not* require to build V8 yourself.\n\nDue to security concerns of binary blobs hiding malicious code, the V8 binary is built via CI *ONLY*.\n\n## Project Goals\n\nTo provide a high quality, idiomatic, Go binding to the [V8 C++ API](https://v8.github.io/api/head/index.html).\n\nThe API should match the original API as closely as possible, but with an API that Gophers (Go enthusiasts) expect. For\nexample: using multiple return values to return both result and error from a function, rather than throwing an\nexception.\n\nThis project also aims to keep up-to-date with the latest (stable) release of V8.\n\n## License\n\n[![FOSSA Status](https://app.fossa.com/api/projects/custom%2B22862%2Fgit%40github.com%3Arogchap%2Fv8go.git.svg?type=large)](https://app.fossa.com/projects/custom%2B22862%2Fgit%40github.com%3Arogchap%2Fv8go.git?ref=badge_large)\n\n## Development\n\n### Recompile V8 with debug info and debug checks\n\n[Aside from data races, Go should be memory-safe](https://research.swtch.com/gorace) and v8go should preserve this property by adding the necessary checks to return an error or panic on these unsupported code paths. Release builds of v8go don't include debugging information for the V8 library since it significantly adds to the binary size, slows down compilation and shouldn't be needed by users of v8go. However, if a v8go bug causes a crash (e.g. during new feature development) then it can be helpful to build V8 with debugging information to get a C++ backtrace with line numbers. The following steps will not only do that, but also enable V8 debug checking, which can help with catching misuse of the V8 API.\n\n1) Make sure to clone the projects submodules (ie. the V8's `depot_tools` project): `git submodule update --init --recursive`\n1) Build the V8 binary for your OS: `deps/build.py --debug`. V8 is a large project, and building the binary can take up to 30 minutes.\n1) Build the executable to debug, using `go build` for commands or `go test -c` for tests. You may need to add the `-ldflags=-compressdwarf=false` option to disable debug information compression so this information can be read by the debugger (e.g. lldb that comes with Xcode v12.5.1, the latest Xcode released at the time of writing)\n1) Run the executable with a debugger (e.g. `lldb -- ./v8go.test -test.run TestThatIsCrashing`, `run` to start execution then use `bt` to print a bracktrace after it breaks on a crash), since backtraces printed by Go or V8 don't currently include line number information.\n\n### Upgrading the V8 binaries\n\nWe have the [upgradev8](https://github.com/rogchap/v8go/.github/workflow/v8upgrade.yml) workflow.\nThe workflow is triggered every day or manually.\n\nIf the current [v8_version](https://github.com/rogchap/v8go/deps/v8_version) is different from the latest stable version, the workflow takes care of fetching the latest stable v8 files and copying them into `deps/include`. The last step of the workflow opens a new PR with the branch name `v8_upgrade/<v8-version>` with all the changes.\n\nThe next steps are:\n\n1) The build is not yet triggered automatically. To trigger it manually, go to the [V8\nBuild](https://github.com/rogchap/v8go/actions?query=workflow%3A%22V8+Build%22) Github Action, Select \"Run workflow\",\nand select your pushed branch eg. `v8_upgrade/<v8-version>`.\n1) Once built, this should open 3 PRs against your branch to add the `libv8.a` for Linux (for x86_64) and macOS for x86_64 and arm64; merge\nthese PRs into your branch. You are now ready to raise the PR against `master` with the latest version of V8.\n\n### Flushing after C/C++ standard library printing for debugging\n\nWhen using the C/C++ standard library functions for printing (e.g. `printf`), then the output will be buffered by default.\nThis can cause some confusion, especially because the test binary (created through `go test`) does not flush the buffer\nat exit (at the time of writing). When standard output is the terminal, then it will use line buffering and flush when\na new line is printed, otherwise (e.g. if the output is redirected to a pipe or file) it will be fully buffered and not even\nflush at the end of a line. When the test binary is executed through `go test .` (e.g. instead of\nseparately compiled with `go test -c` and run with `./v8go.test`) Go may redirect standard output internally, resulting in\nstandard output being fully buffered.\n\nA simple way to avoid this problem is to flush the standard output stream after printing with the `fflush(stdout);` statement.\nNot relying on the flushing at exit can also help ensure the output is printed before a crash.\n\n### Local leak checking\n\nLeak checking is automatically done in CI, but it can be useful to do locally to debug leaks.\n\nLeak checking is done using the [Leak Sanitizer](https://clang.llvm.org/docs/LeakSanitizer.html) which\nis a part of LLVM. As such, compiling with clang as the C/C++ compiler seems to produce more complete\nbacktraces (unfortunately still only of the system stack at the time of writing).\n\nFor instance, on a Debian-based Linux system, you can use `sudo apt-get install clang-12` to install a\nrecent version of clang.  Then CC and CXX environment variables are needed to use that compiler. With\nthat compiler, the tests can be run as follows\n\n```\nCC=clang-12 CXX=clang++-12 go test -c --tags leakcheck && ./v8go.test\n```\n\nThe separate compile and link commands are currently needed to get line numbers in the backtrace.\n\nOn macOS, leak checking isn't available with the version of clang that comes with Xcode, so a separate\ncompiler installation is needed.  For example, with homebrew, `brew install llvm` will install a version\nof clang with support for this. The ASAN_OPTIONS environment variable will also be needed to run the code\nwith leak checking enabled, since it isn't enabled by default on macOS. E.g. with the homebrew\ninstallation of llvm, the tests can be run with\n\n```\nCXX=/usr/local/opt/llvm/bin/clang++ CC=/usr/local/opt/llvm/bin/clang go test -c --tags leakcheck -ldflags=-compressdwarf=false\nASAN_OPTIONS=detect_leaks=1 ./v8go.test\n```\n\nThe `-ldflags=-compressdwarf=false` is currently (with clang 13) needed to get line numbers in the backtrace.\n\n### Formatting\n\nGo has `go fmt`, C has `clang-format`. Any changes to the `v8go.h|cc` should be formated with `clang-format` with the\n\"Chromium\" Coding style. This can be done easily by running the `go generate` command.\n\n`brew install clang-format` to install on macOS.\n\n---\n\nV8 Gopher image based on original artwork from the amazing [Renee French](http://reneefrench.blogspot.com).\n"
        },
        {
          "name": "backports.go",
          "type": "blob",
          "size": 0.3828125,
          "content": "package v8go\n\nimport \"time\"\n\n// Backport time.UnixMicro from go 1.17 - https://pkg.go.dev/time#UnixMicro\n// timeUnixMicro accepts microseconds and converts to nanoseconds to be used\n// with time.Unix which returns the local Time corresponding to the given Unix time,\n// usec microseconds since January 1, 1970 UTC.\nfunc timeUnixMicro(usec int64) time.Time {\n\treturn time.Unix(0, usec*1000)\n}\n"
        },
        {
          "name": "cgo.go",
          "type": "blob",
          "size": 1.05078125,
          "content": "// Copyright 2019 Roger Chapman and the v8go contributors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\npackage v8go\n\n//go:generate clang-format -i --verbose -style=Chromium v8go.h v8go.cc\n\n// #cgo CXXFLAGS: -fno-rtti -fPIC -std=c++17 -DV8_COMPRESS_POINTERS -DV8_31BIT_SMIS_ON_64BIT_ARCH -I${SRCDIR}/deps/include -Wall -DV8_ENABLE_SANDBOX\n// #cgo LDFLAGS: -pthread -lv8\n// #cgo darwin,amd64 LDFLAGS: -L${SRCDIR}/deps/darwin_x86_64\n// #cgo darwin,arm64 LDFLAGS: -L${SRCDIR}/deps/darwin_arm64\n// #cgo linux,amd64 LDFLAGS: -L${SRCDIR}/deps/linux_x86_64 -ldl\n// #cgo linux,arm64 LDFLAGS: -L${SRCDIR}/deps/linux_arm64 -ldl\nimport \"C\"\n\n// These imports forces `go mod vendor` to pull in all the folders that\n// contain V8 libraries and headers which otherwise would be ignored.\n// DO NOT REMOVE\nimport (\n\t_ \"rogchap.com/v8go/deps/darwin_arm64\"\n\t_ \"rogchap.com/v8go/deps/darwin_x86_64\"\n\t_ \"rogchap.com/v8go/deps/include\"\n\t_ \"rogchap.com/v8go/deps/linux_arm64\"\n\t_ \"rogchap.com/v8go/deps/linux_x86_64\"\n)\n"
        },
        {
          "name": "context.go",
          "type": "blob",
          "size": 4.3193359375,
          "content": "// Copyright 2019 Roger Chapman and the v8go contributors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\npackage v8go\n\n// #include <stdlib.h>\n// #include \"v8go.h\"\nimport \"C\"\nimport (\n\t\"runtime\"\n\t\"sync\"\n\t\"unsafe\"\n)\n\n// Due to the limitations of passing pointers to C from Go we need to create\n// a registry so that we can lookup the Context from any given callback from V8.\n// This is similar to what is described here: https://github.com/golang/go/wiki/cgo#function-variables\ntype ctxRef struct {\n\tctx      *Context\n\trefCount int\n}\n\nvar ctxMutex sync.RWMutex\nvar ctxRegistry = make(map[int]*ctxRef)\nvar ctxSeq = 0\n\n// Context is a global root execution environment that allows separate,\n// unrelated, JavaScript applications to run in a single instance of V8.\ntype Context struct {\n\tref int\n\tptr C.ContextPtr\n\tiso *Isolate\n}\n\ntype contextOptions struct {\n\tiso   *Isolate\n\tgTmpl *ObjectTemplate\n}\n\n// ContextOption sets options such as Isolate and Global Template to the NewContext\ntype ContextOption interface {\n\tapply(*contextOptions)\n}\n\n// NewContext creates a new JavaScript context; if no Isolate is passed as a\n// ContextOption than a new Isolate will be created.\nfunc NewContext(opt ...ContextOption) *Context {\n\topts := contextOptions{}\n\tfor _, o := range opt {\n\t\tif o != nil {\n\t\t\to.apply(&opts)\n\t\t}\n\t}\n\n\tif opts.iso == nil {\n\t\topts.iso = NewIsolate()\n\t}\n\n\tif opts.gTmpl == nil {\n\t\topts.gTmpl = &ObjectTemplate{&template{}}\n\t}\n\n\tctxMutex.Lock()\n\tctxSeq++\n\tref := ctxSeq\n\tctxMutex.Unlock()\n\n\tctx := &Context{\n\t\tref: ref,\n\t\tptr: C.NewContext(opts.iso.ptr, opts.gTmpl.ptr, C.int(ref)),\n\t\tiso: opts.iso,\n\t}\n\tctx.register()\n\truntime.KeepAlive(opts.gTmpl)\n\treturn ctx\n}\n\n// Isolate gets the current context's parent isolate.\nfunc (c *Context) Isolate() *Isolate {\n\treturn c.iso\n}\n\nfunc (c *Context) RetainedValueCount() int {\n\tctxMutex.Lock()\n\tdefer ctxMutex.Unlock()\n\treturn int(C.ContextRetainedValueCount(c.ptr))\n}\n\n// RunScript executes the source JavaScript; origin (a.k.a. filename) provides a\n// reference for the script and used in the stack trace if there is an error.\n// error will be of type `JSError` if not nil.\nfunc (c *Context) RunScript(source string, origin string) (*Value, error) {\n\tcSource := C.CString(source)\n\tcOrigin := C.CString(origin)\n\tdefer C.free(unsafe.Pointer(cSource))\n\tdefer C.free(unsafe.Pointer(cOrigin))\n\n\trtn := C.RunScript(c.ptr, cSource, cOrigin)\n\treturn valueResult(c, rtn)\n}\n\n// Global returns the global proxy object.\n// Global proxy object is a thin wrapper whose prototype points to actual\n// context's global object with the properties like Object, etc. This is\n// done that way for security reasons.\n// Please note that changes to global proxy object prototype most probably\n// would break the VM — V8 expects only global object as a prototype of\n// global proxy object.\nfunc (c *Context) Global() *Object {\n\tvalPtr := C.ContextGlobal(c.ptr)\n\tv := &Value{valPtr, c}\n\treturn &Object{v}\n}\n\n// PerformMicrotaskCheckpoint runs the default MicrotaskQueue until empty.\n// This is used to make progress on Promises.\nfunc (c *Context) PerformMicrotaskCheckpoint() {\n\tC.IsolatePerformMicrotaskCheckpoint(c.iso.ptr)\n}\n\n// Close will dispose the context and free the memory.\n// Access to any values associated with the context after calling Close may panic.\nfunc (c *Context) Close() {\n\tc.deregister()\n\tC.ContextFree(c.ptr)\n\tc.ptr = nil\n}\n\nfunc (c *Context) register() {\n\tctxMutex.Lock()\n\tr := ctxRegistry[c.ref]\n\tif r == nil {\n\t\tr = &ctxRef{ctx: c}\n\t\tctxRegistry[c.ref] = r\n\t}\n\tr.refCount++\n\tctxMutex.Unlock()\n}\n\nfunc (c *Context) deregister() {\n\tctxMutex.Lock()\n\tdefer ctxMutex.Unlock()\n\tr := ctxRegistry[c.ref]\n\tif r == nil {\n\t\treturn\n\t}\n\tr.refCount--\n\tif r.refCount <= 0 {\n\t\tdelete(ctxRegistry, c.ref)\n\t}\n}\n\nfunc getContext(ref int) *Context {\n\tctxMutex.RLock()\n\tdefer ctxMutex.RUnlock()\n\tr := ctxRegistry[ref]\n\tif r == nil {\n\t\treturn nil\n\t}\n\treturn r.ctx\n}\n\n//export goContext\nfunc goContext(ref int) C.ContextPtr {\n\tctx := getContext(ref)\n\treturn ctx.ptr\n}\n\nfunc valueResult(ctx *Context, rtn C.RtnValue) (*Value, error) {\n\tif rtn.value == nil {\n\t\treturn nil, newJSError(rtn.error)\n\t}\n\treturn &Value{rtn.value, ctx}, nil\n}\n\nfunc objectResult(ctx *Context, rtn C.RtnValue) (*Object, error) {\n\tif rtn.value == nil {\n\t\treturn nil, newJSError(rtn.error)\n\t}\n\treturn &Object{&Value{rtn.value, ctx}}, nil\n}\n"
        },
        {
          "name": "context_test.go",
          "type": "blob",
          "size": 4.421875,
          "content": "// Copyright 2019 Roger Chapman and the v8go contributors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\npackage v8go_test\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"testing\"\n\n\tv8 \"rogchap.com/v8go\"\n)\n\nfunc TestContextExec(t *testing.T) {\n\tt.Parallel()\n\tctx := v8.NewContext(nil)\n\tdefer ctx.Isolate().Dispose()\n\tdefer ctx.Close()\n\n\tctx.RunScript(`const add = (a, b) => a + b`, \"add.js\")\n\tval, _ := ctx.RunScript(`add(3, 4)`, \"main.js\")\n\trtn := val.String()\n\tif rtn != \"7\" {\n\t\tt.Errorf(\"script returned an unexpected value: expected %q, got %q\", \"7\", rtn)\n\t}\n\n\t_, err := ctx.RunScript(`add`, \"func.js\")\n\tif err != nil {\n\t\tt.Errorf(\"error not expected: %v\", err)\n\t}\n\n\tiso := ctx.Isolate()\n\tctx2 := v8.NewContext(iso)\n\tdefer ctx2.Close()\n\t_, err = ctx2.RunScript(`add`, \"ctx2.js\")\n\tif err == nil {\n\t\tt.Error(\"error expected but was <nil>\")\n\t}\n}\n\nfunc TestJSExceptions(t *testing.T) {\n\tt.Parallel()\n\n\ttests := [...]struct {\n\t\tname   string\n\t\tsource string\n\t\torigin string\n\t\terr    string\n\t}{\n\t\t{\"SyntaxError\", \"bad js syntax\", \"syntax.js\", \"SyntaxError: Unexpected identifier 'js'\"},\n\t\t{\"ReferenceError\", \"add()\", \"add.js\", \"ReferenceError: add is not defined\"},\n\t}\n\n\tctx := v8.NewContext(nil)\n\tdefer ctx.Isolate().Dispose()\n\tdefer ctx.Close()\n\n\tfor _, tt := range tests {\n\t\ttt := tt\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\t_, err := ctx.RunScript(tt.source, tt.origin)\n\t\t\tif err == nil {\n\t\t\t\tt.Error(\"error expected but got <nil>\")\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif err.Error() != tt.err {\n\t\t\t\tt.Errorf(\"expected %q, got %q\", tt.err, err.Error())\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestContextRegistry(t *testing.T) {\n\tt.Parallel()\n\n\tctx := v8.NewContext()\n\tdefer ctx.Isolate().Dispose()\n\tdefer ctx.Close()\n\n\tctxref := ctx.Ref()\n\n\tc1 := v8.GetContext(ctxref)\n\tif c1 == nil {\n\t\tt.Error(\"expected context, but got <nil>\")\n\t}\n\tif c1 != ctx {\n\t\tt.Errorf(\"contexts should match %p != %p\", c1, ctx)\n\t}\n\n\tctx.Close()\n\n\tc2 := v8.GetContext(ctxref)\n\tif c2 != nil {\n\t\tt.Error(\"expected context to be <nil> after close\")\n\t}\n}\n\nfunc TestMemoryLeak(t *testing.T) {\n\tt.Parallel()\n\n\tiso := v8.NewIsolate()\n\tdefer iso.Dispose()\n\n\tfor i := 0; i < 6000; i++ {\n\t\tctx := v8.NewContext(iso)\n\t\t_ = ctx.Global()\n\t\t// _ = obj.String()\n\t\t_, _ = ctx.RunScript(\"2\", \"\")\n\t\tctx.Close()\n\t}\n\tif n := iso.GetHeapStatistics().NumberOfNativeContexts; n >= 6000 {\n\t\tt.Errorf(\"Context not being GC'd, got %d native contexts\", n)\n\t}\n}\n\n// https://github.com/rogchap/v8go/issues/186\nfunc TestRegistryFromJSON(t *testing.T) {\n\tt.Parallel()\n\n\tiso := v8.NewIsolate()\n\tdefer iso.Dispose()\n\n\tglobal := v8.NewObjectTemplate(iso)\n\terr := global.Set(\"location\", v8.NewFunctionTemplate(iso, func(info *v8.FunctionCallbackInfo) *v8.Value {\n\t\tv, err := v8.NewValue(iso, \"world\")\n\t\tfatalIf(t, err)\n\t\treturn v\n\t}))\n\tfatalIf(t, err)\n\n\tctx := v8.NewContext(iso, global)\n\tdefer ctx.Close()\n\n\tv, err := ctx.RunScript(`\n\t\tnew Proxy({\n\t\t\t\"hello\": \"unknown\"\n\t\t}, {\n\t\t\tget: function () {\n\t\t\t\treturn location()\n\t\t\t},\n\t\t})\n\t`, \"main.js\")\n\tfatalIf(t, err)\n\n\ts, err := v8.JSONStringify(ctx, v)\n\tfatalIf(t, err)\n\n\texpected := `{\"hello\":\"world\"}`\n\tif s != expected {\n\t\tt.Fatalf(\"expected %q, got %q\", expected, s)\n\t}\n}\n\nfunc BenchmarkContext(b *testing.B) {\n\tb.ReportAllocs()\n\tiso := v8.NewIsolate()\n\tdefer iso.Dispose()\n\tfor n := 0; n < b.N; n++ {\n\t\tctx := v8.NewContext(iso)\n\t\tctx.RunScript(script, \"main.js\")\n\t\tstr, _ := json.Marshal(makeObject())\n\t\tcmd := fmt.Sprintf(\"process(%s)\", str)\n\t\tctx.RunScript(cmd, \"cmd.js\")\n\t\tctx.Close()\n\t}\n}\n\nfunc ExampleContext() {\n\tctx := v8.NewContext()\n\tdefer ctx.Isolate().Dispose()\n\tdefer ctx.Close()\n\tctx.RunScript(\"const add = (a, b) => a + b\", \"math.js\")\n\tctx.RunScript(\"const result = add(3, 4)\", \"main.js\")\n\tval, _ := ctx.RunScript(\"result\", \"value.js\")\n\tfmt.Println(val)\n\t// Output:\n\t// 7\n}\n\nfunc ExampleContext_isolate() {\n\tiso := v8.NewIsolate()\n\tdefer iso.Dispose()\n\tctx1 := v8.NewContext(iso)\n\tdefer ctx1.Close()\n\tctx1.RunScript(\"const foo = 'bar'\", \"context_one.js\")\n\tval, _ := ctx1.RunScript(\"foo\", \"foo.js\")\n\tfmt.Println(val)\n\n\tctx2 := v8.NewContext(iso)\n\tdefer ctx2.Close()\n\t_, err := ctx2.RunScript(\"foo\", \"context_two.js\")\n\tfmt.Println(err)\n\t// Output:\n\t// bar\n\t// ReferenceError: foo is not defined\n}\n\nfunc ExampleContext_globalTemplate() {\n\tiso := v8.NewIsolate()\n\tdefer iso.Dispose()\n\tobj := v8.NewObjectTemplate(iso)\n\tobj.Set(\"version\", \"v1.0.0\")\n\tctx := v8.NewContext(iso, obj)\n\tdefer ctx.Close()\n\tval, _ := ctx.RunScript(\"version\", \"main.js\")\n\tfmt.Println(val)\n\t// Output:\n\t// v1.0.0\n}\n"
        },
        {
          "name": "cpuprofile.go",
          "type": "blob",
          "size": 1.2978515625,
          "content": "// Copyright 2021 the v8go contributors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\npackage v8go\n\n/*\n#include \"v8go.h\"\n*/\nimport \"C\"\nimport \"time\"\n\ntype CPUProfile struct {\n\tp *C.CPUProfile\n\n\t// The CPU profile title.\n\ttitle string\n\n\t// root is the root node of the top down call tree.\n\troot *CPUProfileNode\n\n\t// startTimeOffset is the time when the profile recording was started\n\t// since some unspecified starting point.\n\tstartTimeOffset time.Duration\n\n\t// endTimeOffset is the time when the profile recording was stopped\n\t// since some unspecified starting point.\n\t// The point is equal to the starting point used by startTimeOffset.\n\tendTimeOffset time.Duration\n}\n\n// Returns CPU profile title.\nfunc (c *CPUProfile) GetTitle() string {\n\treturn c.title\n}\n\n// Returns the root node of the top down call tree.\nfunc (c *CPUProfile) GetTopDownRoot() *CPUProfileNode {\n\treturn c.root\n}\n\n// Returns the duration of the profile.\nfunc (c *CPUProfile) GetDuration() time.Duration {\n\treturn c.endTimeOffset - c.startTimeOffset\n}\n\n// Deletes the profile and removes it from CpuProfiler's list.\n// All pointers to nodes previously returned become invalid.\nfunc (c *CPUProfile) Delete() {\n\tif c.p == nil {\n\t\treturn\n\t}\n\tC.CPUProfileDelete(c.p)\n\tc.p = nil\n}\n"
        },
        {
          "name": "cpuprofile_test.go",
          "type": "blob",
          "size": 1.5712890625,
          "content": "// Copyright 2021 the v8go contributors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\npackage v8go_test\n\nimport (\n\t\"testing\"\n\n\tv8 \"rogchap.com/v8go\"\n)\n\nfunc TestCPUProfile(t *testing.T) {\n\tt.Parallel()\n\n\tctx := v8.NewContext(nil)\n\tiso := ctx.Isolate()\n\tdefer iso.Dispose()\n\tdefer ctx.Close()\n\n\tcpuProfiler := v8.NewCPUProfiler(iso)\n\tdefer cpuProfiler.Dispose()\n\n\ttitle := \"cpuprofiletest\"\n\tcpuProfiler.StartProfiling(title)\n\n\t_, err := ctx.RunScript(profileScript, \"script.js\")\n\tfatalIf(t, err)\n\tval, err := ctx.Global().Get(\"start\")\n\tfatalIf(t, err)\n\tfn, err := val.AsFunction()\n\tfatalIf(t, err)\n\t_, err = fn.Call(ctx.Global())\n\tfatalIf(t, err)\n\n\tcpuProfile := cpuProfiler.StopProfiling(title)\n\tdefer cpuProfile.Delete()\n\n\tif cpuProfile.GetTitle() != title {\n\t\tt.Fatalf(\"expected title %s, but got %s\", title, cpuProfile.GetTitle())\n\t}\n\n\troot := cpuProfile.GetTopDownRoot()\n\tif root == nil {\n\t\tt.Fatal(\"expected root not to be nil\")\n\t}\n\tif root.GetFunctionName() != \"(root)\" {\n\t\tt.Errorf(\"expected (root), but got %v\", root.GetFunctionName())\n\t}\n\n\tif cpuProfile.GetDuration() <= 0 {\n\t\tt.Fatalf(\"expected positive profile duration (%s)\", cpuProfile.GetDuration())\n\t}\n}\n\nfunc TestCPUProfile_Delete(t *testing.T) {\n\tt.Parallel()\n\n\tiso := v8.NewIsolate()\n\tdefer iso.Dispose()\n\n\tcpuProfiler := v8.NewCPUProfiler(iso)\n\tdefer cpuProfiler.Dispose()\n\n\tcpuProfiler.StartProfiling(\"cpuprofiletest\")\n\tcpuProfile := cpuProfiler.StopProfiling(\"cpuprofiletest\")\n\tcpuProfile.Delete()\n\t// noop when called multiple times\n\tcpuProfile.Delete()\n}\n"
        },
        {
          "name": "cpuprofilenode.go",
          "type": "blob",
          "size": 2.3662109375,
          "content": "// Copyright 2021 the v8go contributors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\npackage v8go\n\ntype CPUProfileNode struct {\n\t// The id of the current node, unique within the tree.\n\tnodeId int\n\n\t// The id of the script where the function originates.\n\tscriptId int\n\n\t// The resource name for script from where the function originates.\n\tscriptResourceName string\n\n\t// The function name (empty string for anonymous functions.)\n\tfunctionName string\n\n\t// The number of the line where the function originates.\n\tlineNumber int\n\n\t// The number of the column where the function originates.\n\tcolumnNumber int\n\n\t// The count of samples where the function was currently executing.\n\thitCount int\n\n\t// The bailout reason for the function if the optimization was disabled for it.\n\tbailoutReason string\n\n\t// The children node of this node.\n\tchildren []*CPUProfileNode\n\n\t// The parent node of this node.\n\tparent *CPUProfileNode\n}\n\n// Returns node id.\nfunc (c *CPUProfileNode) GetNodeId() int {\n\treturn c.nodeId\n}\n\n// Returns id for script from where the function originates.\nfunc (c *CPUProfileNode) GetScriptId() int {\n\treturn c.scriptId\n}\n\n// Returns function name (empty string for anonymous functions.)\nfunc (c *CPUProfileNode) GetFunctionName() string {\n\treturn c.functionName\n}\n\n// Returns resource name for script from where the function originates.\nfunc (c *CPUProfileNode) GetScriptResourceName() string {\n\treturn c.scriptResourceName\n}\n\n// Returns number of the line where the function originates.\nfunc (c *CPUProfileNode) GetLineNumber() int {\n\treturn c.lineNumber\n}\n\n// Returns number of the column where the function originates.\nfunc (c *CPUProfileNode) GetColumnNumber() int {\n\treturn c.columnNumber\n}\n\n// Returns count of samples where the function was currently executing.\nfunc (c *CPUProfileNode) GetHitCount() int {\n\treturn c.hitCount\n}\n\n// Returns the bailout reason for the function if the optimization was disabled for it.\nfunc (c *CPUProfileNode) GetBailoutReason() string {\n\treturn c.bailoutReason\n}\n\n// Retrieves the ancestor node, or nil if the root.\nfunc (c *CPUProfileNode) GetParent() *CPUProfileNode {\n\treturn c.parent\n}\n\nfunc (c *CPUProfileNode) GetChildrenCount() int {\n\treturn len(c.children)\n}\n\n// Retrieves a child node by index.\nfunc (c *CPUProfileNode) GetChild(index int) *CPUProfileNode {\n\treturn c.children[index]\n}\n"
        },
        {
          "name": "cpuprofilenode_test.go",
          "type": "blob",
          "size": 3.0361328125,
          "content": "// Copyright 2021 the v8go contributors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\npackage v8go_test\n\nimport (\n\t\"testing\"\n\n\tv8 \"rogchap.com/v8go\"\n)\n\nfunc TestCPUProfileNode(t *testing.T) {\n\tt.Parallel()\n\n\tctx := v8.NewContext(nil)\n\tiso := ctx.Isolate()\n\tdefer iso.Dispose()\n\tdefer ctx.Close()\n\n\tcpuProfiler := v8.NewCPUProfiler(iso)\n\tdefer cpuProfiler.Dispose()\n\n\ttitle := \"cpuprofilenodetest\"\n\tcpuProfiler.StartProfiling(title)\n\n\t_, err := ctx.RunScript(profileScript, \"script.js\")\n\tfatalIf(t, err)\n\tval, err := ctx.Global().Get(\"start\")\n\tfatalIf(t, err)\n\tfn, err := val.AsFunction()\n\tfatalIf(t, err)\n\ttimeout, err := v8.NewValue(iso, int32(1000))\n\tfatalIf(t, err)\n\t_, err = fn.Call(ctx.Global(), timeout)\n\tfatalIf(t, err)\n\n\tcpuProfile := cpuProfiler.StopProfiling(title)\n\tif cpuProfile == nil {\n\t\tt.Fatal(\"expected profile not to be nil\")\n\t}\n\tdefer cpuProfile.Delete()\n\n\trootNode := cpuProfile.GetTopDownRoot()\n\tif rootNode == nil {\n\t\tt.Fatal(\"expected top down root not to be nil\")\n\t}\n\tcount := rootNode.GetChildrenCount()\n\tvar startNode *v8.CPUProfileNode\n\tfor i := 0; i < count; i++ {\n\t\tif rootNode.GetChild(i).GetFunctionName() == \"start\" {\n\t\t\tstartNode = rootNode.GetChild(i)\n\t\t}\n\t}\n\tif startNode == nil {\n\t\tt.Fatal(\"expected node not to be nil\")\n\t}\n\tcheckNode(t, startNode, \"script.js\", \"start\", 23, 15)\n\n\tparentName := startNode.GetParent().GetFunctionName()\n\tif parentName != \"(root)\" {\n\t\tt.Fatalf(\"expected (root), but got %v\", parentName)\n\t}\n\n\tfooNode := findChild(t, startNode, \"foo\")\n\tcheckNode(t, fooNode, \"script.js\", \"foo\", 15, 13)\n\n\tdelayNode := findChild(t, fooNode, \"delay\")\n\tcheckNode(t, delayNode, \"script.js\", \"delay\", 12, 15)\n\n\tbarNode := findChild(t, fooNode, \"bar\")\n\tcheckNode(t, barNode, \"script.js\", \"bar\", 13, 13)\n\n\tloopNode := findChild(t, delayNode, \"loop\")\n\tcheckNode(t, loopNode, \"script.js\", \"loop\", 1, 14)\n\n\tbazNode := findChild(t, fooNode, \"baz\")\n\tcheckNode(t, bazNode, \"script.js\", \"baz\", 14, 13)\n}\n\nfunc findChild(t *testing.T, node *v8.CPUProfileNode, functionName string) *v8.CPUProfileNode {\n\tt.Helper()\n\n\tvar child *v8.CPUProfileNode\n\tcount := node.GetChildrenCount()\n\tfor i := 0; i < count; i++ {\n\t\tif node.GetChild(i).GetFunctionName() == functionName {\n\t\t\tchild = node.GetChild(i)\n\t\t}\n\t}\n\tif child == nil {\n\t\tt.Fatal(\"failed to find child node\")\n\t}\n\treturn child\n}\n\nfunc checkNode(t *testing.T, node *v8.CPUProfileNode, scriptResourceName string, functionName string, line, column int) {\n\tt.Helper()\n\n\tif node.GetFunctionName() != functionName {\n\t\tt.Fatalf(\"expected node to have function name %s, but got %s\", functionName, node.GetFunctionName())\n\t}\n\tif node.GetScriptResourceName() != scriptResourceName {\n\t\tt.Fatalf(\"expected node to have script resource name %s, but got %s\", scriptResourceName, node.GetScriptResourceName())\n\t}\n\tif node.GetLineNumber() != line {\n\t\tt.Fatalf(\"expected node at line %d, but got %d\", line, node.GetLineNumber())\n\t}\n\tif node.GetColumnNumber() != column {\n\t\tt.Fatalf(\"expected node at column %d, but got %d\", column, node.GetColumnNumber())\n\t}\n}\n"
        },
        {
          "name": "cpuprofiler.go",
          "type": "blob",
          "size": 2.5615234375,
          "content": "// Copyright 2021 the v8go contributors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\npackage v8go\n\n/*\n#include <stdlib.h>\n#include \"v8go.h\"\n*/\nimport \"C\"\nimport (\n\t\"time\"\n\t\"unsafe\"\n)\n\ntype CPUProfiler struct {\n\tp   *C.CPUProfiler\n\tiso *Isolate\n}\n\n// CPUProfiler is used to control CPU profiling.\nfunc NewCPUProfiler(iso *Isolate) *CPUProfiler {\n\tprofiler := C.NewCPUProfiler(iso.ptr)\n\treturn &CPUProfiler{\n\t\tp:   profiler,\n\t\tiso: iso,\n\t}\n}\n\n// Dispose will dispose the profiler.\nfunc (c *CPUProfiler) Dispose() {\n\tif c.p == nil {\n\t\treturn\n\t}\n\n\tC.CPUProfilerDispose(c.p)\n\tc.p = nil\n}\n\n// StartProfiling starts collecting a CPU profile. Title may be an empty string. Several\n// profiles may be collected at once. Attempts to start collecting several\n// profiles with the same title are silently ignored.\nfunc (c *CPUProfiler) StartProfiling(title string) {\n\tif c.p == nil || c.iso.ptr == nil {\n\t\tpanic(\"profiler or isolate are nil\")\n\t}\n\n\ttstr := C.CString(title)\n\tdefer C.free(unsafe.Pointer(tstr))\n\n\tC.CPUProfilerStartProfiling(c.p, tstr)\n}\n\n// Stops collecting CPU profile with a given title and returns it.\n// If the title given is empty, finishes the last profile started.\nfunc (c *CPUProfiler) StopProfiling(title string) *CPUProfile {\n\tif c.p == nil || c.iso.ptr == nil {\n\t\tpanic(\"profiler or isolate are nil\")\n\t}\n\n\ttstr := C.CString(title)\n\tdefer C.free(unsafe.Pointer(tstr))\n\n\tprofile := C.CPUProfilerStopProfiling(c.p, tstr)\n\n\treturn &CPUProfile{\n\t\tp:               profile,\n\t\ttitle:           C.GoString(profile.title),\n\t\troot:            newCPUProfileNode(profile.root, nil),\n\t\tstartTimeOffset: time.Duration(profile.startTime) * time.Millisecond,\n\t\tendTimeOffset:   time.Duration(profile.endTime) * time.Millisecond,\n\t}\n}\n\nfunc newCPUProfileNode(node *C.CPUProfileNode, parent *CPUProfileNode) *CPUProfileNode {\n\tn := &CPUProfileNode{\n\t\tnodeId:             int(node.nodeId),\n\t\tscriptId:           int(node.scriptId),\n\t\tscriptResourceName: C.GoString(node.scriptResourceName),\n\t\tfunctionName:       C.GoString(node.functionName),\n\t\tlineNumber:         int(node.lineNumber),\n\t\tcolumnNumber:       int(node.columnNumber),\n\t\thitCount:           int(node.hitCount),\n\t\tbailoutReason:      C.GoString(node.bailoutReason),\n\t\tparent:             parent,\n\t}\n\n\tif node.childrenCount > 0 {\n\t\tn.children = make([]*CPUProfileNode, node.childrenCount)\n\t\tfor i, child := range (*[1 << 28]*C.CPUProfileNode)(unsafe.Pointer(node.children))[:node.childrenCount:node.childrenCount] {\n\t\t\tn.children[i] = newCPUProfileNode(child, n)\n\t\t}\n\t}\n\n\treturn n\n}\n"
        },
        {
          "name": "cpuprofiler_test.go",
          "type": "blob",
          "size": 2.326171875,
          "content": "// Copyright 2021 the v8go contributors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\npackage v8go_test\n\nimport (\n\t\"testing\"\n\n\tv8 \"rogchap.com/v8go\"\n)\n\nfunc TestCPUProfiler_Dispose(t *testing.T) {\n\tt.Parallel()\n\n\tiso := v8.NewIsolate()\n\tdefer iso.Dispose()\n\tcpuProfiler := v8.NewCPUProfiler(iso)\n\n\tcpuProfiler.Dispose()\n\t// noop when called multiple times\n\tcpuProfiler.Dispose()\n\n\t// verify panics when profiler disposed\n\tif recoverPanic(func() { cpuProfiler.StartProfiling(\"\") }) == nil {\n\t\tt.Error(\"expected panic\")\n\t}\n\n\tif recoverPanic(func() { cpuProfiler.StopProfiling(\"\") }) == nil {\n\t\tt.Error(\"expected panic\")\n\t}\n\n\tcpuProfiler = v8.NewCPUProfiler(iso)\n\tdefer cpuProfiler.Dispose()\n\tiso.Dispose()\n\n\t// verify panics when isolate disposed\n\tif recoverPanic(func() { cpuProfiler.StartProfiling(\"\") }) == nil {\n\t\tt.Error(\"expected panic\")\n\t}\n\n\tif recoverPanic(func() { cpuProfiler.StopProfiling(\"\") }) == nil {\n\t\tt.Error(\"expected panic\")\n\t}\n}\n\nfunc TestCPUProfiler(t *testing.T) {\n\tt.Parallel()\n\n\tctx := v8.NewContext(nil)\n\tiso := ctx.Isolate()\n\tdefer iso.Dispose()\n\tdefer ctx.Close()\n\n\tcpuProfiler := v8.NewCPUProfiler(iso)\n\tdefer cpuProfiler.Dispose()\n\n\ttitle := \"cpuprofilertest\"\n\tcpuProfiler.StartProfiling(title)\n\n\t_, err := ctx.RunScript(profileScript, \"script.js\")\n\tfatalIf(t, err)\n\tval, err := ctx.Global().Get(\"start\")\n\tfatalIf(t, err)\n\tfn, err := val.AsFunction()\n\tfatalIf(t, err)\n\ttimeout, err := v8.NewValue(iso, int32(0))\n\tfatalIf(t, err)\n\t_, err = fn.Call(ctx.Global(), timeout)\n\tfatalIf(t, err)\n\n\tcpuProfile := cpuProfiler.StopProfiling(title)\n\tdefer cpuProfile.Delete()\n\n\tif cpuProfile.GetTitle() != title {\n\t\tt.Errorf(\"expected %s, but got %s\", title, cpuProfile.GetTitle())\n\t}\n}\n\nconst profileScript = `function loop(timeout) {\n  this.mmm = 0;\n  var start = Date.now();\n  while (Date.now() - start < timeout) {\n    var n = 10;\n    while(n > 1) {\n      n--;\n      this.mmm += n * n * n;\n    }\n  }\n}\nfunction delay() { try { loop(10); } catch(e) { } }\nfunction bar() { delay(); }\nfunction baz() { delay(); }\nfunction foo() {\n    try {\n       delay();\n       bar();\n       delay();\n       baz();\n    } catch (e) { }\n}\nfunction start(timeout) {\n  var start = Date.now();\n  do {\n    foo();\n    var duration = Date.now() - start;\n  } while (duration < timeout);\n  return duration;\n};`\n"
        },
        {
          "name": "deps",
          "type": "tree",
          "content": null
        },
        {
          "name": "errors.go",
          "type": "blob",
          "size": 1.73828125,
          "content": "// Copyright 2019 Roger Chapman and the v8go contributors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\npackage v8go\n\n// #include <stdlib.h>\n// #include \"v8go.h\"\nimport \"C\"\nimport (\n\t\"fmt\"\n\t\"io\"\n\t\"unsafe\"\n)\n\n// JSError is an error that is returned if there is are any\n// JavaScript exceptions handled in the context. When used with the fmt\n// verb `%+v`, will output the JavaScript stack trace, if available.\ntype JSError struct {\n\tMessage    string\n\tLocation   string\n\tStackTrace string\n}\n\nfunc newJSError(rtnErr C.RtnError) error {\n\terr := &JSError{\n\t\tMessage:    C.GoString(rtnErr.msg),\n\t\tLocation:   C.GoString(rtnErr.location),\n\t\tStackTrace: C.GoString(rtnErr.stack),\n\t}\n\tC.free(unsafe.Pointer(rtnErr.msg))\n\tC.free(unsafe.Pointer(rtnErr.location))\n\tC.free(unsafe.Pointer(rtnErr.stack))\n\treturn err\n}\n\nfunc (e *JSError) Error() string {\n\treturn e.Message\n}\n\n// Format implements the fmt.Formatter interface to provide a custom formatter\n// primarily to output the javascript stack trace with %+v\nfunc (e *JSError) Format(s fmt.State, verb rune) {\n\tswitch verb {\n\tcase 'v':\n\t\tif s.Flag('+') && e.StackTrace != \"\" {\n\t\t\t// The StackTrace starts with the Message, so only the former needs to be printed\n\t\t\tio.WriteString(s, e.StackTrace)\n\n\t\t\t// If it was a compile time error, then there wouldn't be a runtime stack trace,\n\t\t\t// but StackTrace will still include the Message, making them equal. In this case,\n\t\t\t// we want to include the Location where the compilation failed.\n\t\t\tif e.StackTrace == e.Message && e.Location != \"\" {\n\t\t\t\tfmt.Fprintf(s, \" (at %s)\", e.Location)\n\t\t\t}\n\t\t\treturn\n\t\t}\n\t\tfallthrough\n\tcase 's':\n\t\tio.WriteString(s, e.Message)\n\tcase 'q':\n\t\tfmt.Fprintf(s, \"%q\", e.Message)\n\t}\n}\n"
        },
        {
          "name": "errors_test.go",
          "type": "blob",
          "size": 2.76953125,
          "content": "// Copyright 2019 Roger Chapman and the v8go contributors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\npackage v8go_test\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n\n\tv8 \"rogchap.com/v8go\"\n)\n\nfunc TestJSErrorFormat(t *testing.T) {\n\tt.Parallel()\n\ttests := [...]struct {\n\t\tname            string\n\t\terr             error\n\t\tdefaultVerb     string\n\t\tdefaultVerbFlag string\n\t\tstringVerb      string\n\t\tquoteVerb       string\n\t}{\n\t\t{\"WithStack\", &v8.JSError{Message: \"msg\", StackTrace: \"stack\"}, \"msg\", \"stack\", \"msg\", `\"msg\"`},\n\t\t{\"WithoutStack\", &v8.JSError{Message: \"msg\"}, \"msg\", \"msg\", \"msg\", `\"msg\"`},\n\t}\n\n\tfor _, tt := range tests {\n\t\ttt := tt\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tt.Parallel()\n\t\t\tif s := fmt.Sprintf(\"%v\", tt.err); s != tt.defaultVerb {\n\t\t\t\tt.Errorf(\"incorrect format for %%v: %s\", s)\n\t\t\t}\n\t\t\tif s := fmt.Sprintf(\"%+v\", tt.err); s != tt.defaultVerbFlag {\n\t\t\t\tt.Errorf(\"incorrect format for %%+v: %s\", s)\n\t\t\t}\n\t\t\tif s := fmt.Sprintf(\"%s\", tt.err); s != tt.stringVerb {\n\t\t\t\tt.Errorf(\"incorrect format for %%s: %s\", s)\n\t\t\t}\n\t\t\tif s := fmt.Sprintf(\"%q\", tt.err); s != tt.quoteVerb {\n\t\t\t\tt.Errorf(\"incorrect format for %%q: %s\", s)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestJSErrorOutput(t *testing.T) {\n\tt.Parallel()\n\tctx := v8.NewContext(nil)\n\tdefer ctx.Isolate().Dispose()\n\tdefer ctx.Close()\n\n\tmath := `\n\tfunction add(a, b) {\n\t\treturn a + b;\n\t}\n\n\tfunction addMore(a, b) {\n\t\treturn add(a, c);\n\t}`\n\n\tmain := `\n\tlet a = add(3, 5);\n\tlet b = addMore(a, 6);\n\tb;\n\t`\n\n\tctx.RunScript(math, \"math.js\")\n\t_, err := ctx.RunScript(main, \"main.js\")\n\tif err == nil {\n\t\tt.Error(\"expected error but got <nil>\")\n\t\treturn\n\t}\n\te, ok := err.(*v8.JSError)\n\tif !ok {\n\t\tt.Errorf(\"expected error of type JSError, got %T\", err)\n\t}\n\tif e.Message != \"ReferenceError: c is not defined\" {\n\t\tt.Errorf(\"unexpected error message: %q\", e.Message)\n\t}\n\tif e.Location != \"math.js:7:17\" {\n\t\tt.Errorf(\"unexpected error location: %q\", e.Location)\n\t}\n\texpectedStack := `ReferenceError: c is not defined\n    at addMore (math.js:7:17)\n    at main.js:3:10`\n\n\tif e.StackTrace != expectedStack {\n\t\tt.Errorf(\"unexpected error stack trace: %q\", e.StackTrace)\n\t}\n}\n\nfunc TestJSErrorFormat_forSyntaxError(t *testing.T) {\n\tt.Parallel()\n\tiso := v8.NewIsolate()\n\tdefer iso.Dispose()\n\tctx := v8.NewContext(iso)\n\tdefer ctx.Close()\n\n\tscript := `\n\t\tlet x = 1;\n\t\tlet y = x + ;\n\t\tlet z = x + z;\n\t`\n\t_, err := ctx.RunScript(script, \"xyz.js\")\n\tjsErr := err.(*v8.JSError)\n\tif jsErr.StackTrace != jsErr.Message {\n\t\tt.Errorf(\"unexpected StackTrace %q not equal to Message %q\", jsErr.StackTrace, jsErr.Message)\n\t}\n\tif jsErr.Location == \"\" {\n\t\tt.Errorf(\"missing Location\")\n\t}\n\n\tmsg := fmt.Sprintf(\"%+v\", err)\n\tif msg != \"SyntaxError: Unexpected token ';' (at xyz.js:3:15)\" {\n\t\tt.Errorf(\"unexpected verbose error message: %q\", msg)\n\t}\n}\n"
        },
        {
          "name": "export_test.go",
          "type": "blob",
          "size": 0.619140625,
          "content": "// Copyright 2019 Roger Chapman and the v8go contributors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\npackage v8go\n\n// RegisterCallback is exported for testing only.\nfunc (i *Isolate) RegisterCallback(cb FunctionCallback) int {\n\treturn i.registerCallback(cb)\n}\n\n// GetCallback is exported for testing only.\nfunc (i *Isolate) GetCallback(ref int) FunctionCallback {\n\treturn i.getCallback(ref)\n}\n\n// GetContext is exported for testing only.\nvar GetContext = getContext\n\n// Ref is exported for testing only.\nfunc (c *Context) Ref() int {\n\treturn c.ref\n}\n"
        },
        {
          "name": "function.go",
          "type": "blob",
          "size": 1.3359375,
          "content": "// Copyright 2021 Roger Chapman and the v8go contributors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\npackage v8go\n\n// #include \"v8go.h\"\nimport \"C\"\nimport (\n\t\"unsafe\"\n)\n\n// Function is a JavaScript function.\ntype Function struct {\n\t*Value\n}\n\n// Call this JavaScript function with the given arguments.\nfunc (fn *Function) Call(recv Valuer, args ...Valuer) (*Value, error) {\n\tvar argptr *C.ValuePtr\n\tif len(args) > 0 {\n\t\tvar cArgs = make([]C.ValuePtr, len(args))\n\t\tfor i, arg := range args {\n\t\t\tcArgs[i] = arg.value().ptr\n\t\t}\n\t\targptr = (*C.ValuePtr)(unsafe.Pointer(&cArgs[0]))\n\t}\n\trtn := C.FunctionCall(fn.ptr, recv.value().ptr, C.int(len(args)), argptr)\n\treturn valueResult(fn.ctx, rtn)\n}\n\n// Invoke a constructor function to create an object instance.\nfunc (fn *Function) NewInstance(args ...Valuer) (*Object, error) {\n\tvar argptr *C.ValuePtr\n\tif len(args) > 0 {\n\t\tvar cArgs = make([]C.ValuePtr, len(args))\n\t\tfor i, arg := range args {\n\t\t\tcArgs[i] = arg.value().ptr\n\t\t}\n\t\targptr = (*C.ValuePtr)(unsafe.Pointer(&cArgs[0]))\n\t}\n\trtn := C.FunctionNewInstance(fn.ptr, C.int(len(args)), argptr)\n\treturn objectResult(fn.ctx, rtn)\n}\n\n// Return the source map url for a function.\nfunc (fn *Function) SourceMapUrl() *Value {\n\tptr := C.FunctionSourceMapUrl(fn.ptr)\n\treturn &Value{ptr, fn.ctx}\n}\n"
        },
        {
          "name": "function_template.go",
          "type": "blob",
          "size": 3.0009765625,
          "content": "// Copyright 2021 Roger Chapman and the v8go contributors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\npackage v8go\n\n// #include <stdlib.h>\n// #include \"v8go.h\"\nimport \"C\"\nimport (\n\t\"runtime\"\n\t\"unsafe\"\n)\n\n// FunctionCallback is a callback that is executed in Go when a function is executed in JS.\ntype FunctionCallback func(info *FunctionCallbackInfo) *Value\n\n// FunctionCallbackInfo is the argument that is passed to a FunctionCallback.\ntype FunctionCallbackInfo struct {\n\tctx  *Context\n\targs []*Value\n\tthis *Object\n}\n\n// Context is the current context that the callback is being executed in.\nfunc (i *FunctionCallbackInfo) Context() *Context {\n\treturn i.ctx\n}\n\n// This returns the receiver object \"this\".\nfunc (i *FunctionCallbackInfo) This() *Object {\n\treturn i.this\n}\n\n// Args returns a slice of the value arguments that are passed to the JS function.\nfunc (i *FunctionCallbackInfo) Args() []*Value {\n\treturn i.args\n}\n\nfunc (i *FunctionCallbackInfo) Release() {\n\tfor _, arg := range i.args {\n\t\targ.Release()\n\t}\n\ti.this.Release()\n}\n\n// FunctionTemplate is used to create functions at runtime.\n// There can only be one function created from a FunctionTemplate in a context.\n// The lifetime of the created function is equal to the lifetime of the context.\ntype FunctionTemplate struct {\n\t*template\n}\n\n// NewFunctionTemplate creates a FunctionTemplate for a given callback.\nfunc NewFunctionTemplate(iso *Isolate, callback FunctionCallback) *FunctionTemplate {\n\tif iso == nil {\n\t\tpanic(\"nil Isolate argument not supported\")\n\t}\n\tif callback == nil {\n\t\tpanic(\"nil FunctionCallback argument not supported\")\n\t}\n\n\tcbref := iso.registerCallback(callback)\n\n\ttmpl := &template{\n\t\tptr: C.NewFunctionTemplate(iso.ptr, C.int(cbref)),\n\t\tiso: iso,\n\t}\n\truntime.SetFinalizer(tmpl, (*template).finalizer)\n\treturn &FunctionTemplate{tmpl}\n}\n\n// GetFunction returns an instance of this function template bound to the given context.\nfunc (tmpl *FunctionTemplate) GetFunction(ctx *Context) *Function {\n\trtn := C.FunctionTemplateGetFunction(tmpl.ptr, ctx.ptr)\n\truntime.KeepAlive(tmpl)\n\tval, err := valueResult(ctx, rtn)\n\tif err != nil {\n\t\tpanic(err) // TODO: Consider returning the error\n\t}\n\treturn &Function{val}\n}\n\n// Note that ideally `thisAndArgs` would be split into two separate arguments, but they were combined\n// to workaround an ERROR_COMMITMENT_LIMIT error on windows that was detected in CI.\n//\n//export goFunctionCallback\nfunc goFunctionCallback(ctxref int, cbref int, thisAndArgs *C.ValuePtr, argsCount int) C.ValuePtr {\n\tctx := getContext(ctxref)\n\n\tthis := *thisAndArgs\n\tinfo := &FunctionCallbackInfo{\n\t\tctx:  ctx,\n\t\tthis: &Object{&Value{ptr: this, ctx: ctx}},\n\t\targs: make([]*Value, argsCount),\n\t}\n\n\targv := (*[1 << 30]C.ValuePtr)(unsafe.Pointer(thisAndArgs))[1 : argsCount+1 : argsCount+1]\n\tfor i, v := range argv {\n\t\tval := &Value{ptr: v, ctx: ctx}\n\t\tinfo.args[i] = val\n\t}\n\n\tcallbackFunc := ctx.iso.getCallback(cbref)\n\tif val := callbackFunc(info); val != nil {\n\t\treturn val.ptr\n\t}\n\treturn nil\n}\n"
        },
        {
          "name": "function_template_fetch_test.go",
          "type": "blob",
          "size": 1.423828125,
          "content": "// Copyright 2021 Roger Chapman and the v8go contributors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\n// Ignore leaks within Go standard libraries http/https support code.\n// The getaddrinfo detected leaks can be avoided using GODEBUG=netdns=go but\n// currently there are more for loading system root certificates on macOS.\n//go:build !leakcheck || !darwin\n// +build !leakcheck !darwin\n\npackage v8go_test\n\nimport (\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"strings\"\n\n\tv8 \"rogchap.com/v8go\"\n)\n\nfunc ExampleFunctionTemplate_fetch() {\n\tiso := v8.NewIsolate()\n\tdefer iso.Dispose()\n\tglobal := v8.NewObjectTemplate(iso)\n\n\tfetchfn := v8.NewFunctionTemplate(iso, func(info *v8.FunctionCallbackInfo) *v8.Value {\n\t\targs := info.Args()\n\t\turl := args[0].String()\n\n\t\tresolver, _ := v8.NewPromiseResolver(info.Context())\n\n\t\tgo func() {\n\t\t\tres, _ := http.Get(url)\n\t\t\tbody, _ := ioutil.ReadAll(res.Body)\n\t\t\tval, _ := v8.NewValue(iso, string(body))\n\t\t\tresolver.Resolve(val)\n\t\t}()\n\t\treturn resolver.GetPromise().Value\n\t})\n\tglobal.Set(\"fetch\", fetchfn, v8.ReadOnly)\n\n\tctx := v8.NewContext(iso, global)\n\tdefer ctx.Close()\n\tval, _ := ctx.RunScript(\"fetch('https://rogchap.com/v8go')\", \"\")\n\tprom, _ := val.AsPromise()\n\n\t// wait for the promise to resolve\n\tfor prom.State() == v8.Pending {\n\t\tcontinue\n\t}\n\tfmt.Printf(\"%s\\n\", strings.Split(prom.Result().String(), \"\\n\")[0])\n\t// Output:\n\t// <!DOCTYPE html>\n}\n"
        },
        {
          "name": "function_template_test.go",
          "type": "blob",
          "size": 3.9912109375,
          "content": "// Copyright 2021 Roger Chapman and the v8go contributors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\npackage v8go_test\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n\n\tv8 \"rogchap.com/v8go\"\n)\n\nfunc TestFunctionTemplate(t *testing.T) {\n\tt.Parallel()\n\n\tiso := v8.NewIsolate()\n\tdefer iso.Dispose()\n\tfn := v8.NewFunctionTemplate(iso, func(*v8.FunctionCallbackInfo) *v8.Value { return nil })\n\tif fn == nil {\n\t\tt.Error(\"expected FunctionTemplate, but got <nil>\")\n\t}\n}\n\nfunc TestFunctionTemplate_panic_on_nil_isolate(t *testing.T) {\n\tt.Parallel()\n\n\tdefer func() {\n\t\tif err := recover(); err == nil {\n\t\t\tt.Error(\"expected panic\")\n\t\t}\n\t}()\n\tv8.NewFunctionTemplate(nil, func(*v8.FunctionCallbackInfo) *v8.Value {\n\t\tt.Error(\"unexpected call\")\n\t\treturn nil\n\t})\n}\n\nfunc TestFunctionTemplate_panic_on_nil_callback(t *testing.T) {\n\tt.Parallel()\n\n\tdefer func() {\n\t\tif err := recover(); err == nil {\n\t\t\tt.Error(\"expected panic\")\n\t\t}\n\t}()\n\tiso := v8.NewIsolate()\n\tdefer iso.Dispose()\n\tv8.NewFunctionTemplate(iso, nil)\n}\nfunc TestFunctionTemplate_generates_values(t *testing.T) {\n\tt.Parallel()\n\n\tiso := v8.NewIsolate()\n\tdefer iso.Dispose()\n\tglobal := v8.NewObjectTemplate(iso)\n\tprintfn := v8.NewFunctionTemplate(iso, func(info *v8.FunctionCallbackInfo) *v8.Value {\n\t\tfmt.Printf(\"%+v\\n\", info.Args())\n\t\treturn nil\n\t})\n\tglobal.Set(\"print\", printfn, v8.ReadOnly)\n\tctx := v8.NewContext(iso, global)\n\tdefer ctx.Close()\n\tctx.RunScript(\"print('foo', 'bar', 0, 1)\", \"\")\n\tif ctx.RetainedValueCount() != 6 {\n\t\tt.Errorf(\"expected 6 retained values, got: %d\", ctx.RetainedValueCount())\n\t}\n}\n\nfunc TestFunctionTemplate_releases_values(t *testing.T) {\n\tt.Parallel()\n\n\tiso := v8.NewIsolate()\n\tdefer iso.Dispose()\n\tglobal := v8.NewObjectTemplate(iso)\n\tprintfn := v8.NewFunctionTemplate(iso, func(info *v8.FunctionCallbackInfo) *v8.Value {\n\t\tdefer info.Release()\n\t\tfmt.Printf(\"%+v\\n\", info.Args())\n\t\treturn nil\n\t})\n\tglobal.Set(\"print\", printfn, v8.ReadOnly)\n\tctx := v8.NewContext(iso, global)\n\tdefer ctx.Close()\n\tctx.RunScript(\"print('foo', 'bar', 0, 1)\", \"\")\n\t// there is a constant factor associated with the global.\n\tif ctx.RetainedValueCount() != 1 {\n\t\tt.Errorf(\"expected 1 retained values, got: %d\", ctx.RetainedValueCount())\n\t}\n}\n\nfunc TestFunctionTemplateGetFunction(t *testing.T) {\n\tt.Parallel()\n\n\tiso := v8.NewIsolate()\n\tdefer iso.Dispose()\n\tctx := v8.NewContext(iso)\n\tdefer ctx.Close()\n\n\tvar args *v8.FunctionCallbackInfo\n\ttmpl := v8.NewFunctionTemplate(iso, func(info *v8.FunctionCallbackInfo) *v8.Value {\n\t\targs = info\n\t\treply, _ := v8.NewValue(iso, \"hello\")\n\t\treturn reply\n\t})\n\tfn := tmpl.GetFunction(ctx)\n\tten, err := v8.NewValue(iso, int32(10))\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tret, err := fn.Call(v8.Undefined(iso), ten)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif len(args.Args()) != 1 || args.Args()[0].String() != \"10\" {\n\t\tt.Fatalf(\"expected args [10], got: %+v\", args.Args())\n\t}\n\tif !ret.IsString() || ret.String() != \"hello\" {\n\t\tt.Fatalf(\"expected return value of 'hello', was: %v\", ret)\n\t}\n}\n\nfunc TestFunctionCallbackInfoThis(t *testing.T) {\n\tt.Parallel()\n\n\tiso := v8.NewIsolate()\n\tdefer iso.Dispose()\n\n\tfoo := v8.NewObjectTemplate(iso)\n\tfoo.Set(\"name\", \"foobar\")\n\n\tvar this *v8.Object\n\tbarfn := v8.NewFunctionTemplate(iso, func(info *v8.FunctionCallbackInfo) *v8.Value {\n\t\tthis = info.This()\n\t\treturn nil\n\t})\n\tfoo.Set(\"bar\", barfn)\n\n\tglobal := v8.NewObjectTemplate(iso)\n\tglobal.Set(\"foo\", foo)\n\n\tctx := v8.NewContext(iso, global)\n\tdefer ctx.Close()\n\tctx.RunScript(\"foo.bar()\", \"\")\n\n\tv, _ := this.Get(\"name\")\n\tif v.String() != \"foobar\" {\n\t\tt.Errorf(\"expected this.name to be foobar, but got %q\", v)\n\t}\n}\n\nfunc ExampleFunctionTemplate() {\n\tiso := v8.NewIsolate()\n\tdefer iso.Dispose()\n\tglobal := v8.NewObjectTemplate(iso)\n\tprintfn := v8.NewFunctionTemplate(iso, func(info *v8.FunctionCallbackInfo) *v8.Value {\n\t\tfmt.Printf(\"%+v\\n\", info.Args())\n\t\treturn nil\n\t})\n\tglobal.Set(\"print\", printfn, v8.ReadOnly)\n\tctx := v8.NewContext(iso, global)\n\tdefer ctx.Close()\n\tctx.RunScript(\"print('foo', 'bar', 0, 1)\", \"\")\n\t// Output:\n\t// [foo bar 0 1]\n}\n"
        },
        {
          "name": "function_test.go",
          "type": "blob",
          "size": 4.82421875,
          "content": "// Copyright 2021 Roger Chapman and the v8go contributors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\npackage v8go_test\n\nimport (\n\t\"testing\"\n\n\tv8 \"rogchap.com/v8go\"\n)\n\nfunc TestFunctionCall(t *testing.T) {\n\tt.Parallel()\n\n\tctx := v8.NewContext()\n\tiso := ctx.Isolate()\n\tdefer iso.Dispose()\n\tdefer ctx.Close()\n\n\t_, err := ctx.RunScript(\"function add(a, b) { return a + b; }\", \"\")\n\tfatalIf(t, err)\n\taddValue, err := ctx.Global().Get(\"add\")\n\tfatalIf(t, err)\n\n\targ1, err := v8.NewValue(iso, int32(1))\n\tfatalIf(t, err)\n\n\tfn, _ := addValue.AsFunction()\n\tresultValue, err := fn.Call(v8.Undefined(iso), arg1, arg1)\n\tfatalIf(t, err)\n\n\tif resultValue.Int32() != 2 {\n\t\tt.Errorf(\"expected 1 + 1 = 2, got: %v\", resultValue.DetailString())\n\t}\n}\n\nfunc TestFunctionCallToGoFunc(t *testing.T) {\n\tt.Parallel()\n\n\tiso := v8.NewIsolate()\n\tdefer iso.Dispose()\n\tglobal := v8.NewObjectTemplate(iso)\n\n\tcalled := false\n\tprintfn := v8.NewFunctionTemplate(iso, func(info *v8.FunctionCallbackInfo) *v8.Value {\n\t\tcalled = true\n\t\treturn nil\n\t})\n\n\terr := global.Set(\"print\", printfn, v8.ReadOnly)\n\tfatalIf(t, err)\n\n\tctx := v8.NewContext(iso, global)\n\tdefer ctx.Close()\n\n\tval, err := ctx.RunScript(`(a, b) => { print(\"foo\"); }`, \"\")\n\tfatalIf(t, err)\n\tfn, err := val.AsFunction()\n\tfatalIf(t, err)\n\tresultValue, err := fn.Call(v8.Undefined(iso))\n\tfatalIf(t, err)\n\n\tif !called {\n\t\tt.Errorf(\"expected my function to be called, wasn't\")\n\t}\n\tif !resultValue.IsUndefined() {\n\t\tt.Errorf(\"expected undefined, got: %v\", resultValue.DetailString())\n\t}\n}\n\nfunc TestFunctionCallWithObjectReceiver(t *testing.T) {\n\tt.Parallel()\n\n\tiso := v8.NewIsolate()\n\tdefer iso.Dispose()\n\tglobal := v8.NewObjectTemplate(iso)\n\n\tctx := v8.NewContext(iso, global)\n\tdefer ctx.Close()\n\tval, err := ctx.RunScript(`class Obj { constructor(input) { this.input = input } print() { return this.input.toString() } }; new Obj(\"some val\")`, \"\")\n\tfatalIf(t, err)\n\tobj, err := val.AsObject()\n\tfatalIf(t, err)\n\tfnVal, err := obj.Get(\"print\")\n\tfatalIf(t, err)\n\tfn, err := fnVal.AsFunction()\n\tfatalIf(t, err)\n\tresultValue, err := fn.Call(obj)\n\tfatalIf(t, err)\n\n\tif !resultValue.IsString() || resultValue.String() != \"some val\" {\n\t\tt.Errorf(\"expected 'some val', got: %v\", resultValue.DetailString())\n\t}\n}\n\nfunc TestFunctionCallError(t *testing.T) {\n\tt.Parallel()\n\n\tctx := v8.NewContext()\n\tiso := ctx.Isolate()\n\tdefer iso.Dispose()\n\tdefer ctx.Close()\n\n\t_, err := ctx.RunScript(\"function throws() { throw 'error'; }\", \"script.js\")\n\tfatalIf(t, err)\n\taddValue, err := ctx.Global().Get(\"throws\")\n\tfatalIf(t, err)\n\n\tfn, _ := addValue.AsFunction()\n\t_, err = fn.Call(v8.Undefined(iso))\n\tif err == nil {\n\t\tt.Errorf(\"expected an error, got none\")\n\t}\n\tgot := *(err.(*v8.JSError))\n\twant := v8.JSError{Message: \"error\", Location: \"script.js:1:21\"}\n\tif got != want {\n\t\tt.Errorf(\"want %+v, got: %+v\", want, got)\n\t}\n}\n\nfunc TestFunctionSourceMapUrl(t *testing.T) {\n\tt.Parallel()\n\n\tctx := v8.NewContext()\n\tdefer ctx.Isolate().Dispose()\n\tdefer ctx.Close()\n\t_, err := ctx.RunScript(\"function add(a, b) { return a + b; }; //# sourceMappingURL=main.js.map\", \"main.js\")\n\tfatalIf(t, err)\n\taddValue, err := ctx.Global().Get(\"add\")\n\tfatalIf(t, err)\n\n\tfn, _ := addValue.AsFunction()\n\n\tresultVal := fn.SourceMapUrl()\n\tif resultVal.String() != \"main.js.map\" {\n\t\tt.Errorf(\"expected main.js.map, got %v\", resultVal.String())\n\t}\n\n\t_, err = ctx.RunScript(\"function sub(a, b) { return a - b; };\", \"\")\n\tfatalIf(t, err)\n\tsubValue, err := ctx.Global().Get(\"sub\")\n\tfatalIf(t, err)\n\n\tsubFn, _ := subValue.AsFunction()\n\tresultVal = subFn.SourceMapUrl()\n\tif !resultVal.IsUndefined() {\n\t\tt.Errorf(\"expected undefined, got: %v\", resultVal.DetailString())\n\t}\n}\n\nfunc TestFunctionNewInstance(t *testing.T) {\n\tt.Parallel()\n\n\tctx := v8.NewContext()\n\tdefer ctx.Isolate().Dispose()\n\tdefer ctx.Close()\n\n\tiso := ctx.Isolate()\n\n\tvalue, err := ctx.Global().Get(\"Error\")\n\tfatalIf(t, err)\n\tfn, err := value.AsFunction()\n\tfatalIf(t, err)\n\tmessageObj, err := v8.NewValue(iso, \"test message\")\n\tfatalIf(t, err)\n\terrObj, err := fn.NewInstance(messageObj)\n\tfatalIf(t, err)\n\n\tmessage, err := errObj.Get(\"message\")\n\tfatalIf(t, err)\n\tif !message.IsString() {\n\t\tt.Error(\"missing error message\")\n\t}\n\twant := \"test message\"\n\tgot := message.String()\n\tif got != want {\n\t\tt.Errorf(\"want %+v, got: %+v\", want, got)\n\t}\n}\n\nfunc TestFunctionNewInstanceError(t *testing.T) {\n\tt.Parallel()\n\n\tctx := v8.NewContext()\n\tdefer ctx.Isolate().Dispose()\n\tdefer ctx.Close()\n\n\t_, err := ctx.RunScript(\"function throws() { throw 'error'; }\", \"script.js\")\n\tfatalIf(t, err)\n\tthrowsValue, err := ctx.Global().Get(\"throws\")\n\tfatalIf(t, err)\n\tfn, _ := throwsValue.AsFunction()\n\n\t_, err = fn.NewInstance()\n\tif err == nil {\n\t\tt.Errorf(\"expected an error, got none\")\n\t}\n\tgot := *(err.(*v8.JSError))\n\twant := v8.JSError{Message: \"error\", Location: \"script.js:1:21\"}\n\tif got != want {\n\t\tt.Errorf(\"want %+v, got: %+v\", want, got)\n\t}\n}\n"
        },
        {
          "name": "go.mod",
          "type": "blob",
          "size": 0.0322265625,
          "content": "module rogchap.com/v8go\n\ngo 1.17\n"
        },
        {
          "name": "go.sum",
          "type": "blob",
          "size": 0,
          "content": ""
        },
        {
          "name": "gopher.jpg",
          "type": "blob",
          "size": 27.9345703125,
          "content": null
        },
        {
          "name": "helpers_test.go",
          "type": "blob",
          "size": 0.2392578125,
          "content": "package v8go_test\n\nimport \"testing\"\n\nfunc fatalIf(t *testing.T, err error) {\n\tt.Helper()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n}\n\nfunc recoverPanic(f func()) (recovered interface{}) {\n\tdefer func() {\n\t\trecovered = recover()\n\t}()\n\tf()\n\treturn nil\n}\n"
        },
        {
          "name": "intl_test.go",
          "type": "blob",
          "size": 1.6884765625,
          "content": "// Copyright 2021 the v8go contributors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\npackage v8go_test\n\nimport (\n\t\"testing\"\n\n\tv8 \"rogchap.com/v8go\"\n)\n\nfunc TestIntlSupport(t *testing.T) {\n\tt.Parallel()\n\n\tctx := v8.NewContext(nil)\n\tiso := ctx.Isolate()\n\tdefer iso.Dispose()\n\tdefer ctx.Close()\n\n\tv, err := ctx.RunScript(\"typeof Intl === 'object'\", \"test.js\")\n\tfatalIf(t, err)\n\tif !v.Boolean() {\n\t\tt.Fatalf(\"expected value to be true, but was false\")\n\t}\n\n\tv, err = ctx.RunScript(\"new Intl.NumberFormat()\", \"test.js\")\n\tfatalIf(t, err)\n\tif v.String() != \"[object Intl.NumberFormat]\" {\n\t\tt.Fatalf(\"expected value to be [object Intl.NumberFormat], but was %v\", v)\n\t}\n\n\tv, err = ctx.RunScript(\"new Intl.DateTimeFormat('es', { month: 'long' }).format(new Date(9E8))\", \"test.js\")\n\tfatalIf(t, err)\n\tif v.String() != \"enero\" {\n\t\tt.Fatalf(\"expected value to be enero, but was %v\", v)\n\t}\n\n\t// Example from the node.js documentation:\n\t// https://github.com/nodejs/node/blob/2e2a6fecd9b1aaffcb932fcc415439f359c84fdd/doc/api/intl.md?plain=1#L175-L183\n\tscript := `const hasFullICU = (() => {\ntry {\n\tconst january = new Date(9e8);\n\tconst spanish = new Intl.DateTimeFormat('es', { month: 'long' });\n\treturn spanish.format(january) === 'enero';\n} catch (err) {\n\treturn false;\n}\n})(); hasFullICU`\n\n\tv, err = ctx.RunScript(script, \"test.js\")\n\tfatalIf(t, err)\n\tif !v.Boolean() {\n\t\tt.Fatalf(\"expected value to be true, but was %v\", v)\n\t}\n\n\tv, err = ctx.RunScript(\"var number = 123456.789; new Intl.NumberFormat('de-DE').format(number)\", \"test.js\")\n\tfatalIf(t, err)\n\tif v.String() != \"123.456,789\" {\n\t\tt.Fatalf(\"expected value to be %v, but was %v\", \"123.456,789\", v)\n\t}\n}\n"
        },
        {
          "name": "isolate.go",
          "type": "blob",
          "size": 5.3701171875,
          "content": "// Copyright 2019 Roger Chapman and the v8go contributors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\npackage v8go\n\n// #include <stdlib.h>\n// #include \"v8go.h\"\nimport \"C\"\n\nimport (\n\t\"sync\"\n\t\"unsafe\"\n)\n\nvar v8once sync.Once\n\n// Isolate is a JavaScript VM instance with its own heap and\n// garbage collector. Most applications will create one isolate\n// with many V8 contexts for execution.\ntype Isolate struct {\n\tptr C.IsolatePtr\n\n\tcbMutex sync.RWMutex\n\tcbSeq   int\n\tcbs     map[int]FunctionCallback\n\n\tnull      *Value\n\tundefined *Value\n}\n\n// HeapStatistics represents V8 isolate heap statistics\ntype HeapStatistics struct {\n\tTotalHeapSize            uint64\n\tTotalHeapSizeExecutable  uint64\n\tTotalPhysicalSize        uint64\n\tTotalAvailableSize       uint64\n\tUsedHeapSize             uint64\n\tHeapSizeLimit            uint64\n\tMallocedMemory           uint64\n\tExternalMemory           uint64\n\tPeakMallocedMemory       uint64\n\tNumberOfNativeContexts   uint64\n\tNumberOfDetachedContexts uint64\n}\n\n// NewIsolate creates a new V8 isolate. Only one thread may access\n// a given isolate at a time, but different threads may access\n// different isolates simultaneously.\n// When an isolate is no longer used its resources should be freed\n// by calling iso.Dispose().\n// An *Isolate can be used as a v8go.ContextOption to create a new\n// Context, rather than creating a new default Isolate.\nfunc NewIsolate() *Isolate {\n\tinitializeIfNecessary()\n\tiso := &Isolate{\n\t\tptr: C.NewIsolate(),\n\t\tcbs: make(map[int]FunctionCallback),\n\t}\n\tiso.null = newValueNull(iso)\n\tiso.undefined = newValueUndefined(iso)\n\treturn iso\n}\n\n// TerminateExecution terminates forcefully the current thread\n// of JavaScript execution in the given isolate.\nfunc (i *Isolate) TerminateExecution() {\n\tC.IsolateTerminateExecution(i.ptr)\n}\n\n// IsExecutionTerminating returns whether V8 is currently terminating\n// Javascript execution. If true, there are still JavaScript frames\n// on the stack and the termination exception is still active.\nfunc (i *Isolate) IsExecutionTerminating() bool {\n\treturn C.IsolateIsExecutionTerminating(i.ptr) == 1\n}\n\ntype CompileOptions struct {\n\tCachedData *CompilerCachedData\n\n\tMode CompileMode\n}\n\n// CompileUnboundScript will create an UnboundScript (i.e. context-indepdent)\n// using the provided source JavaScript, origin (a.k.a. filename), and options.\n// If options contain a non-null CachedData, compilation of the script will use\n// that code cache.\n// error will be of type `JSError` if not nil.\nfunc (i *Isolate) CompileUnboundScript(source, origin string, opts CompileOptions) (*UnboundScript, error) {\n\tcSource := C.CString(source)\n\tcOrigin := C.CString(origin)\n\tdefer C.free(unsafe.Pointer(cSource))\n\tdefer C.free(unsafe.Pointer(cOrigin))\n\n\tvar cOptions C.CompileOptions\n\tif opts.CachedData != nil {\n\t\tif opts.Mode != 0 {\n\t\t\tpanic(\"On CompileOptions, Mode and CachedData can't both be set\")\n\t\t}\n\t\tcOptions.compileOption = C.ScriptCompilerConsumeCodeCache\n\t\tcOptions.cachedData = C.ScriptCompilerCachedData{\n\t\t\tdata:   (*C.uchar)(unsafe.Pointer(&opts.CachedData.Bytes[0])),\n\t\t\tlength: C.int(len(opts.CachedData.Bytes)),\n\t\t}\n\t} else {\n\t\tcOptions.compileOption = C.int(opts.Mode)\n\t}\n\n\trtn := C.IsolateCompileUnboundScript(i.ptr, cSource, cOrigin, cOptions)\n\tif rtn.ptr == nil {\n\t\treturn nil, newJSError(rtn.error)\n\t}\n\tif opts.CachedData != nil {\n\t\topts.CachedData.Rejected = int(rtn.cachedDataRejected) == 1\n\t}\n\treturn &UnboundScript{\n\t\tptr: rtn.ptr,\n\t\tiso: i,\n\t}, nil\n}\n\n// GetHeapStatistics returns heap statistics for an isolate.\nfunc (i *Isolate) GetHeapStatistics() HeapStatistics {\n\ths := C.IsolationGetHeapStatistics(i.ptr)\n\n\treturn HeapStatistics{\n\t\tTotalHeapSize:            uint64(hs.total_heap_size),\n\t\tTotalHeapSizeExecutable:  uint64(hs.total_heap_size_executable),\n\t\tTotalPhysicalSize:        uint64(hs.total_physical_size),\n\t\tTotalAvailableSize:       uint64(hs.total_available_size),\n\t\tUsedHeapSize:             uint64(hs.used_heap_size),\n\t\tHeapSizeLimit:            uint64(hs.heap_size_limit),\n\t\tMallocedMemory:           uint64(hs.malloced_memory),\n\t\tExternalMemory:           uint64(hs.external_memory),\n\t\tPeakMallocedMemory:       uint64(hs.peak_malloced_memory),\n\t\tNumberOfNativeContexts:   uint64(hs.number_of_native_contexts),\n\t\tNumberOfDetachedContexts: uint64(hs.number_of_detached_contexts),\n\t}\n}\n\n// Dispose will dispose the Isolate VM; subsequent calls will panic.\nfunc (i *Isolate) Dispose() {\n\tif i.ptr == nil {\n\t\treturn\n\t}\n\tC.IsolateDispose(i.ptr)\n\ti.ptr = nil\n}\n\n// ThrowException schedules an exception to be thrown when returning to\n// JavaScript. When an exception has been scheduled it is illegal to invoke\n// any JavaScript operation; the caller must return immediately and only after\n// the exception has been handled does it become legal to invoke JavaScript operations.\nfunc (i *Isolate) ThrowException(value *Value) *Value {\n\tif i.ptr == nil {\n\t\tpanic(\"Isolate has been disposed\")\n\t}\n\treturn &Value{\n\t\tptr: C.IsolateThrowException(i.ptr, value.ptr),\n\t}\n}\n\n// Deprecated: use `iso.Dispose()`.\nfunc (i *Isolate) Close() {\n\ti.Dispose()\n}\n\nfunc (i *Isolate) apply(opts *contextOptions) {\n\topts.iso = i\n}\n\nfunc (i *Isolate) registerCallback(cb FunctionCallback) int {\n\ti.cbMutex.Lock()\n\ti.cbSeq++\n\tref := i.cbSeq\n\ti.cbs[ref] = cb\n\ti.cbMutex.Unlock()\n\treturn ref\n}\n\nfunc (i *Isolate) getCallback(ref int) FunctionCallback {\n\ti.cbMutex.RLock()\n\tdefer i.cbMutex.RUnlock()\n\treturn i.cbs[ref]\n}\n"
        },
        {
          "name": "isolate_test.go",
          "type": "blob",
          "size": 7.1552734375,
          "content": "// Copyright 2019 Roger Chapman and the v8go contributors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\npackage v8go_test\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"math/rand\"\n\t\"strings\"\n\t\"testing\"\n\n\tv8 \"rogchap.com/v8go\"\n)\n\nfunc TestIsolateTerminateExecution(t *testing.T) {\n\tt.Parallel()\n\tiso := v8.NewIsolate()\n\tdefer iso.Dispose()\n\n\tif iso.IsExecutionTerminating() {\n\t\tt.Error(\"expected no execution to be terminating\")\n\t}\n\n\tvar terminating bool\n\tfooFn := v8.NewFunctionTemplate(iso, func(info *v8.FunctionCallbackInfo) *v8.Value {\n\t\tloop, _ := info.Args()[0].AsFunction()\n\t\tgo func() {\n\t\t\tiso.TerminateExecution()\n\t\t}()\n\t\tloop.Call(v8.Undefined(iso))\n\n\t\tterminating = iso.IsExecutionTerminating()\n\t\treturn nil\n\t})\n\n\tglobal := v8.NewObjectTemplate(iso)\n\tglobal.Set(\"foo\", fooFn)\n\n\tctx := v8.NewContext(iso, global)\n\tdefer ctx.Close()\n\n\tscript := `function loop() { while (true) { } }; foo(loop);`\n\t_, e := ctx.RunScript(script, \"forever.js\")\n\tif e == nil || !strings.HasPrefix(e.Error(), \"ExecutionTerminated\") {\n\t\tt.Errorf(\"unexpected error: %v\", e)\n\t}\n\n\tif !terminating {\n\t\tt.Error(\"expected execution to have been terminating in function\")\n\t}\n}\n\nfunc TestIsolateCompileUnboundScript(t *testing.T) {\n\ts := \"function foo() { return 'bar'; }; foo()\"\n\n\ti1 := v8.NewIsolate()\n\tdefer i1.Dispose()\n\tc1 := v8.NewContext(i1)\n\tdefer c1.Close()\n\n\t_, err := i1.CompileUnboundScript(\"invalid js\", \"filename\", v8.CompileOptions{})\n\tif err == nil {\n\t\tt.Fatal(\"expected error\")\n\t}\n\n\tus, err := i1.CompileUnboundScript(s, \"script.js\", v8.CompileOptions{Mode: v8.CompileModeEager})\n\tfatalIf(t, err)\n\n\tval, err := us.Run(c1)\n\tfatalIf(t, err)\n\tif val.String() != \"bar\" {\n\t\tt.Fatalf(\"invalid value returned, expected bar got %v\", val)\n\t}\n\n\tcachedData := us.CreateCodeCache()\n\n\ti2 := v8.NewIsolate()\n\tdefer i2.Dispose()\n\tc2 := v8.NewContext(i2)\n\tdefer c2.Close()\n\n\topts := v8.CompileOptions{CachedData: cachedData}\n\tusWithCachedData, err := i2.CompileUnboundScript(s, \"script.js\", opts)\n\tfatalIf(t, err)\n\tif usWithCachedData == nil {\n\t\tt.Fatal(\"expected unbound script from cached data not to be nil\")\n\t}\n\tif opts.CachedData.Rejected {\n\t\tt.Fatal(\"expected cached data to be used, not rejected\")\n\t}\n\n\tval, err = usWithCachedData.Run(c2)\n\tfatalIf(t, err)\n\tif val.String() != \"bar\" {\n\t\tt.Fatalf(\"invalid value returned, expected bar got %v\", val)\n\t}\n}\n\nfunc TestIsolateCompileUnboundScript_CachedDataRejected(t *testing.T) {\n\ts := \"function foo() { return 'bar'; }; foo()\"\n\tiso := v8.NewIsolate()\n\tdefer iso.Dispose()\n\n\t// Try to compile an unbound script using cached data that does not match this source\n\topts := v8.CompileOptions{CachedData: &v8.CompilerCachedData{Bytes: []byte(\"Math.sqrt(4)\")}}\n\tus, err := iso.CompileUnboundScript(s, \"script.js\", opts)\n\tfatalIf(t, err)\n\tif !opts.CachedData.Rejected {\n\t\tt.Error(\"expected cached data to be rejected\")\n\t}\n\n\tctx := v8.NewContext(iso)\n\tdefer ctx.Close()\n\n\t// Verify that unbound script is still compiled and able to be used\n\tval, err := us.Run(ctx)\n\tfatalIf(t, err)\n\tif val.String() != \"bar\" {\n\t\tt.Errorf(\"invalid value returned, expected bar got %v\", val)\n\t}\n}\n\nfunc TestIsolateCompileUnboundScript_InvalidOptions(t *testing.T) {\n\tiso := v8.NewIsolate()\n\tdefer iso.Dispose()\n\n\topts := v8.CompileOptions{\n\t\tCachedData: &v8.CompilerCachedData{Bytes: []byte(\"unused\")},\n\t\tMode:       v8.CompileModeEager,\n\t}\n\tpanicErr := recoverPanic(func() { iso.CompileUnboundScript(\"console.log(1)\", \"script.js\", opts) })\n\tif panicErr == nil {\n\t\tt.Error(\"expected panic\")\n\t}\n\tif panicErr != \"On CompileOptions, Mode and CachedData can't both be set\" {\n\t\tt.Errorf(\"unexpected panic: %v\\n\", panicErr)\n\t}\n}\n\nfunc TestIsolateGetHeapStatistics(t *testing.T) {\n\tt.Parallel()\n\tiso := v8.NewIsolate()\n\tdefer iso.Dispose()\n\tctx1 := v8.NewContext(iso)\n\tdefer ctx1.Close()\n\tctx2 := v8.NewContext(iso)\n\tdefer ctx2.Close()\n\n\ths := iso.GetHeapStatistics()\n\n\tif hs.NumberOfNativeContexts != 3 {\n\t\tt.Error(\"expect NumberOfNativeContexts return 3, got\", hs.NumberOfNativeContexts)\n\t}\n\n\tif hs.NumberOfDetachedContexts != 0 {\n\t\tt.Error(\"expect NumberOfDetachedContexts return 0, got\", hs.NumberOfDetachedContexts)\n\t}\n}\n\nfunc TestCallbackRegistry(t *testing.T) {\n\tt.Parallel()\n\n\tiso := v8.NewIsolate()\n\tdefer iso.Dispose()\n\tcb := func(*v8.FunctionCallbackInfo) *v8.Value { return nil }\n\n\tcb0 := iso.GetCallback(0)\n\tif cb0 != nil {\n\t\tt.Error(\"expected callback function to be <nil>\")\n\t}\n\tref1 := iso.RegisterCallback(cb)\n\tif ref1 != 1 {\n\t\tt.Errorf(\"expected callback ref == 1, got %d\", ref1)\n\t}\n\tcb1 := iso.GetCallback(1)\n\tif fmt.Sprintf(\"%p\", cb1) != fmt.Sprintf(\"%p\", cb) {\n\t\tt.Errorf(\"unexpected callback function; want %p, got %p\", cb, cb1)\n\t}\n}\n\nfunc TestIsolateDispose(t *testing.T) {\n\tt.Parallel()\n\n\tiso := v8.NewIsolate()\n\tif iso.GetHeapStatistics().TotalHeapSize == 0 {\n\t\tt.Error(\"Isolate incorrectly allocated\")\n\t}\n\n\tiso.Dispose()\n\t// noop when called multiple times\n\tiso.Dispose()\n\t// deprecated\n\tiso.Close()\n\n\tif iso.GetHeapStatistics().TotalHeapSize != 0 {\n\t\tt.Error(\"Isolate not disposed correctly\")\n\t}\n}\n\nfunc TestIsolateThrowException(t *testing.T) {\n\tt.Parallel()\n\tiso := v8.NewIsolate()\n\n\tstrErr, _ := v8.NewValue(iso, \"some type error\")\n\n\tthrowError := func(val *v8.Value) {\n\t\tv := iso.ThrowException(val)\n\n\t\tif !v.IsNullOrUndefined() {\n\t\t\tt.Error(\"expected result to be null or undefined\")\n\t\t}\n\t}\n\n\t// Function that throws a simple string error from within the function. It is meant\n\t// to emulate when an error is returned within Go.\n\tfn := v8.NewFunctionTemplate(iso, func(info *v8.FunctionCallbackInfo) *v8.Value {\n\t\tthrowError(strErr)\n\n\t\treturn nil\n\t})\n\n\t// Function that is passed a TypeError from JavaScript.\n\tfn2 := v8.NewFunctionTemplate(iso, func(info *v8.FunctionCallbackInfo) *v8.Value {\n\t\ttypeErr := info.Args()[0]\n\n\t\tthrowError(typeErr)\n\n\t\treturn nil\n\t})\n\n\tglobal := v8.NewObjectTemplate(iso)\n\tglobal.Set(\"foo\", fn)\n\tglobal.Set(\"foo2\", fn2)\n\n\tctx := v8.NewContext(iso, global)\n\n\t_, e := ctx.RunScript(\"foo()\", \"foo.js\")\n\n\tif e.Error() != \"some type error\" {\n\t\tt.Errorf(\"expected \\\"some type error\\\" error but got: %v\", e)\n\t}\n\n\t_, e = ctx.RunScript(\"foo2(new TypeError('this is a test'))\", \"foo.js\")\n\n\tif e.Error() != \"TypeError: this is a test\" {\n\t\tt.Errorf(\"expected \\\"TypeError: this is a test\\\" error but got: %v\", e)\n\t}\n\n\tctx.Close()\n\tiso.Dispose()\n\tif recoverPanic(func() { iso.ThrowException(strErr) }) == nil {\n\t\tt.Error(\"expected panic\")\n\t}\n}\n\nfunc BenchmarkIsolateInitialization(b *testing.B) {\n\tb.ReportAllocs()\n\tfor n := 0; n < b.N; n++ {\n\t\tvm := v8.NewIsolate()\n\t\tvm.Close() // force disposal of the VM\n\t}\n}\n\nfunc BenchmarkIsolateInitAndRun(b *testing.B) {\n\tb.ReportAllocs()\n\tfor n := 0; n < b.N; n++ {\n\t\tvm := v8.NewIsolate()\n\t\tctx := v8.NewContext(vm)\n\t\tctx.RunScript(script, \"main.js\")\n\t\tstr, _ := json.Marshal(makeObject())\n\t\tcmd := fmt.Sprintf(\"process(%s)\", str)\n\t\tctx.RunScript(cmd, \"cmd.js\")\n\t\tctx.Close()\n\t\tvm.Close() // force disposal of the VM\n\t}\n}\n\nconst script = `\n\tconst process = (record) => {\n\t\tconst res = [];\n\t\tfor (let [k, v] of Object.entries(record)) {\n\t\t\tres.push({\n\t\t\t\tname: k,\n\t\t\t\tvalue: v,\n\t\t\t});\n\t\t}\n\t\treturn JSON.stringify(res);\n\t};\n`\n\nfunc makeObject() interface{} {\n\treturn map[string]interface{}{\n\t\t\"a\": rand.Intn(1000000),\n\t\t\"b\": \"AAAABBBBAAAABBBBAAAABBBBAAAABBBBAAAABBBB\",\n\t}\n}\n"
        },
        {
          "name": "json.go",
          "type": "blob",
          "size": 1.1650390625,
          "content": "// Copyright 2021 Roger Chapman and the v8go contributors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\npackage v8go\n\n// #include <stdlib.h>\n// #include \"v8go.h\"\nimport \"C\"\nimport (\n\t\"errors\"\n\t\"unsafe\"\n)\n\n// JSONParse tries to parse the string and returns it as *Value if successful.\n// Any JS errors will be returned as `JSError`.\nfunc JSONParse(ctx *Context, str string) (*Value, error) {\n\tif ctx == nil {\n\t\treturn nil, errors.New(\"v8go: Context is required\")\n\t}\n\tcstr := C.CString(str)\n\tdefer C.free(unsafe.Pointer(cstr))\n\n\trtn := C.JSONParse(ctx.ptr, cstr)\n\treturn valueResult(ctx, rtn)\n}\n\n// JSONStringify tries to stringify the JSON-serializable object value and returns it as string.\nfunc JSONStringify(ctx *Context, val Valuer) (string, error) {\n\tif val == nil || val.value() == nil {\n\t\treturn \"\", errors.New(\"v8go: Value is required\")\n\t}\n\t// If a nil context is passed we'll use the context/isolate that created the value.\n\tvar ctxPtr C.ContextPtr\n\tif ctx != nil {\n\t\tctxPtr = ctx.ptr\n\t}\n\n\tstr := C.JSONStringify(ctxPtr, val.value().ptr)\n\tdefer C.free(unsafe.Pointer(str))\n\treturn C.GoString(str), nil\n}\n"
        },
        {
          "name": "json_test.go",
          "type": "blob",
          "size": 1.3544921875,
          "content": "// Copyright 2021 Roger Chapman and the v8 contributors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\npackage v8go_test\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n\n\tv8 \"rogchap.com/v8go\"\n)\n\nfunc TestJSONParse(t *testing.T) {\n\tt.Parallel()\n\n\tif _, err := v8.JSONParse(nil, \"{}\"); err == nil {\n\t\tt.Error(\"expected error but got <nil>\")\n\t}\n\tctx := v8.NewContext()\n\tdefer ctx.Isolate().Dispose()\n\tdefer ctx.Close()\n\t_, err := v8.JSONParse(ctx, \"{\")\n\tif err == nil {\n\t\tt.Error(\"expected error but got <nil>\")\n\t\treturn\n\t}\n\n\tif _, ok := err.(*v8.JSError); !ok {\n\t\tt.Errorf(\"expected error to be of type JSError, got: %T\", err)\n\t}\n}\n\nfunc TestJSONStringify(t *testing.T) {\n\tt.Parallel()\n\n\tctx := v8.NewContext()\n\tdefer ctx.Isolate().Dispose()\n\tdefer ctx.Close()\n\tif _, err := v8.JSONStringify(ctx, nil); err == nil {\n\t\tt.Error(\"expected error but got <nil>\")\n\t}\n}\n\nfunc ExampleJSONParse() {\n\tctx := v8.NewContext()\n\tdefer ctx.Isolate().Dispose()\n\tdefer ctx.Close()\n\tval, _ := v8.JSONParse(ctx, `{\"foo\": \"bar\"}`)\n\tfmt.Println(val)\n\t// Output:\n\t// [object Object]\n}\n\nfunc ExampleJSONStringify() {\n\tctx := v8.NewContext()\n\tdefer ctx.Isolate().Dispose()\n\tdefer ctx.Close()\n\tval, _ := v8.JSONParse(ctx, `{\n\t\t\"a\": 1,\n\t\t\"b\": \"foo\"\n\t}`)\n\tjsonStr, _ := v8.JSONStringify(ctx, val)\n\tfmt.Println(jsonStr)\n\t// Output:\n\t// {\"a\":1,\"b\":\"foo\"}\n}\n"
        },
        {
          "name": "leak_test.go",
          "type": "blob",
          "size": 0.3701171875,
          "content": "// Copyright 2021 the v8go contributors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\n//go:build leakcheck\n// +build leakcheck\n\npackage v8go_test\n\nimport (\n\t\"os\"\n\t\"testing\"\n\n\t\"rogchap.com/v8go\"\n)\n\nfunc TestMain(m *testing.M) {\n\texitCode := m.Run()\n\tv8go.DoLeakSanitizerCheck()\n\tos.Exit(exitCode)\n}\n"
        },
        {
          "name": "leakcheck.go",
          "type": "blob",
          "size": 0.5205078125,
          "content": "// Copyright 2021 the v8go contributors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\n//go:build leakcheck\n// +build leakcheck\n\npackage v8go\n\n// #cgo CPPFLAGS: -fsanitize=address\n// #cgo LDFLAGS: -fsanitize=address\n//\n// #include <sanitizer/lsan_interface.h>\nimport \"C\"\n\nimport \"runtime\"\n\n// Call LLVM Leak Sanitizer's at-exit hook that doesn't\n// get called automatically by Go.\nfunc DoLeakSanitizerCheck() {\n\truntime.GC()\n\tC.__lsan_do_leak_check()\n}\n"
        },
        {
          "name": "object.go",
          "type": "blob",
          "size": 4.638671875,
          "content": "// Copyright 2021 Roger Chapman and the v8go contributors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\npackage v8go\n\n// #include <stdlib.h>\n// #include \"v8go.h\"\nimport \"C\"\nimport (\n\t\"fmt\"\n\t\"math/big\"\n\t\"unsafe\"\n)\n\n// Object is a JavaScript object (ECMA-262, 4.3.3)\ntype Object struct {\n\t*Value\n}\n\nfunc (o *Object) MethodCall(methodName string, args ...Valuer) (*Value, error) {\n\tckey := C.CString(methodName)\n\tdefer C.free(unsafe.Pointer(ckey))\n\n\tgetRtn := C.ObjectGet(o.ptr, ckey)\n\tprop, err := valueResult(o.ctx, getRtn)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tfn, err := prop.AsFunction()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn fn.Call(o, args...)\n}\n\nfunc coerceValue(iso *Isolate, val interface{}) (*Value, error) {\n\tswitch v := val.(type) {\n\tcase string, int32, uint32, int64, uint64, float64, bool, *big.Int:\n\t\t// ignoring error as code cannot reach the error state as we are already\n\t\t// validating the new value types in this case statement\n\t\tvalue, _ := NewValue(iso, v)\n\t\treturn value, nil\n\tcase Valuer:\n\t\treturn v.value(), nil\n\tdefault:\n\t\treturn nil, fmt.Errorf(\"v8go: unsupported object property type `%T`\", v)\n\t}\n}\n\n// Set will set a property on the Object to a given value.\n// Supports all value types, eg: Object, Array, Date, Set, Map etc\n// If the value passed is a Go supported primitive (string, int32, uint32, int64, uint64, float64, big.Int)\n// then a *Value will be created and set as the value property.\nfunc (o *Object) Set(key string, val interface{}) error {\n\tvalue, err := coerceValue(o.ctx.iso, val)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tckey := C.CString(key)\n\tdefer C.free(unsafe.Pointer(ckey))\n\tC.ObjectSet(o.ptr, ckey, value.ptr)\n\treturn nil\n}\n\n// Set will set a given index on the Object to a given value.\n// Supports all value types, eg: Object, Array, Date, Set, Map etc\n// If the value passed is a Go supported primitive (string, int32, uint32, int64, uint64, float64, big.Int)\n// then a *Value will be created and set as the value property.\nfunc (o *Object) SetIdx(idx uint32, val interface{}) error {\n\tvalue, err := coerceValue(o.ctx.iso, val)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tC.ObjectSetIdx(o.ptr, C.uint32_t(idx), value.ptr)\n\n\treturn nil\n}\n\n// SetInternalField sets the value of an internal field for an ObjectTemplate instance.\n// Panics if the index isn't in the range set by (*ObjectTemplate).SetInternalFieldCount.\nfunc (o *Object) SetInternalField(idx uint32, val interface{}) error {\n\tvalue, err := coerceValue(o.ctx.iso, val)\n\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tinserted := C.ObjectSetInternalField(o.ptr, C.int(idx), value.ptr)\n\n\tif inserted == 0 {\n\t\tpanic(fmt.Errorf(\"index out of range [%v] with length %v\", idx, o.InternalFieldCount()))\n\t}\n\n\treturn nil\n}\n\n// InternalFieldCount returns the number of internal fields this Object has.\nfunc (o *Object) InternalFieldCount() uint32 {\n\tcount := C.ObjectInternalFieldCount(o.ptr)\n\treturn uint32(count)\n}\n\n// Get tries to get a Value for a given Object property key.\nfunc (o *Object) Get(key string) (*Value, error) {\n\tckey := C.CString(key)\n\tdefer C.free(unsafe.Pointer(ckey))\n\n\trtn := C.ObjectGet(o.ptr, ckey)\n\treturn valueResult(o.ctx, rtn)\n}\n\n// GetInternalField gets the Value set by SetInternalField for the given index\n// or the JS undefined value if the index hadn't been set.\n// Panics if given an out of range index.\nfunc (o *Object) GetInternalField(idx uint32) *Value {\n\trtn := C.ObjectGetInternalField(o.ptr, C.int(idx))\n\tif rtn == nil {\n\t\tpanic(fmt.Errorf(\"index out of range [%v] with length %v\", idx, o.InternalFieldCount()))\n\t}\n\treturn &Value{rtn, o.ctx}\n\n}\n\n// GetIdx tries to get a Value at a give Object index.\nfunc (o *Object) GetIdx(idx uint32) (*Value, error) {\n\trtn := C.ObjectGetIdx(o.ptr, C.uint32_t(idx))\n\treturn valueResult(o.ctx, rtn)\n}\n\n// Has calls the abstract operation HasProperty(O, P) described in ECMA-262, 7.3.10.\n// Returns true, if the object has the property, either own or on the prototype chain.\nfunc (o *Object) Has(key string) bool {\n\tckey := C.CString(key)\n\tdefer C.free(unsafe.Pointer(ckey))\n\treturn C.ObjectHas(o.ptr, ckey) != 0\n}\n\n// HasIdx returns true if the object has a value at the given index.\nfunc (o *Object) HasIdx(idx uint32) bool {\n\treturn C.ObjectHasIdx(o.ptr, C.uint32_t(idx)) != 0\n}\n\n// Delete returns true if successful in deleting a named property on the object.\nfunc (o *Object) Delete(key string) bool {\n\tckey := C.CString(key)\n\tdefer C.free(unsafe.Pointer(ckey))\n\treturn C.ObjectDelete(o.ptr, ckey) != 0\n}\n\n// DeleteIdx returns true if successful in deleting a value at a given index of the object.\nfunc (o *Object) DeleteIdx(idx uint32) bool {\n\treturn C.ObjectDeleteIdx(o.ptr, C.uint32_t(idx)) != 0\n}\n"
        },
        {
          "name": "object_template.go",
          "type": "blob",
          "size": 2.1572265625,
          "content": "// Copyright 2020 Roger Chapman and the v8go contributors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\npackage v8go\n\n// #include <stdlib.h>\n// #include \"v8go.h\"\nimport \"C\"\nimport (\n\t\"errors\"\n\t\"runtime\"\n)\n\n// PropertyAttribute are the attribute flags for a property on an Object.\n// Typical usage when setting an Object or TemplateObject property, and\n// can also be validated when accessing a property.\ntype PropertyAttribute uint8\n\nconst (\n\t// None.\n\tNone PropertyAttribute = 0\n\t// ReadOnly, ie. not writable.\n\tReadOnly PropertyAttribute = 1 << iota\n\t// DontEnum, ie. not enumerable.\n\tDontEnum\n\t// DontDelete, ie. not configurable.\n\tDontDelete\n)\n\n// ObjectTemplate is used to create objects at runtime.\n// Properties added to an ObjectTemplate are added to each object created from the ObjectTemplate.\ntype ObjectTemplate struct {\n\t*template\n}\n\n// NewObjectTemplate creates a new ObjectTemplate.\n// The *ObjectTemplate can be used as a v8go.ContextOption to create a global object in a Context.\nfunc NewObjectTemplate(iso *Isolate) *ObjectTemplate {\n\tif iso == nil {\n\t\tpanic(\"nil Isolate argument not supported\")\n\t}\n\n\ttmpl := &template{\n\t\tptr: C.NewObjectTemplate(iso.ptr),\n\t\tiso: iso,\n\t}\n\truntime.SetFinalizer(tmpl, (*template).finalizer)\n\treturn &ObjectTemplate{tmpl}\n}\n\n// NewInstance creates a new Object based on the template.\nfunc (o *ObjectTemplate) NewInstance(ctx *Context) (*Object, error) {\n\tif ctx == nil {\n\t\treturn nil, errors.New(\"v8go: Context cannot be <nil>\")\n\t}\n\n\trtn := C.ObjectTemplateNewInstance(o.ptr, ctx.ptr)\n\truntime.KeepAlive(o)\n\treturn objectResult(ctx, rtn)\n}\n\n// SetInternalFieldCount sets the number of internal fields that instances of this\n// template will have.\nfunc (o *ObjectTemplate) SetInternalFieldCount(fieldCount uint32) {\n\tC.ObjectTemplateSetInternalFieldCount(o.ptr, C.int(fieldCount))\n}\n\n// InternalFieldCount returns the number of internal fields that instances of this\n// template will have.\nfunc (o *ObjectTemplate) InternalFieldCount() uint32 {\n\treturn uint32(C.ObjectTemplateInternalFieldCount(o.ptr))\n}\n\nfunc (o *ObjectTemplate) apply(opts *contextOptions) {\n\topts.gTmpl = o\n}\n"
        },
        {
          "name": "object_template_test.go",
          "type": "blob",
          "size": 3.34375,
          "content": "// Copyright 2020 Roger Chapman and the v8go contributors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\npackage v8go_test\n\nimport (\n\t\"math/big\"\n\t\"runtime\"\n\t\"testing\"\n\n\tv8 \"rogchap.com/v8go\"\n)\n\nfunc TestObjectTemplate(t *testing.T) {\n\tt.Parallel()\n\tiso := v8.NewIsolate()\n\tdefer iso.Dispose()\n\tobj := v8.NewObjectTemplate(iso)\n\n\tsetError := func(t *testing.T, err error) {\n\t\tif err != nil {\n\t\t\tt.Errorf(\"failed to set property: %v\", err)\n\t\t}\n\t}\n\n\tval, _ := v8.NewValue(iso, \"bar\")\n\tobjVal := v8.NewObjectTemplate(iso)\n\tbigbigint, _ := new(big.Int).SetString(\"36893488147419099136\", 10) // larger than a single word size (64bit)\n\tbigbignegint, _ := new(big.Int).SetString(\"-36893488147419099136\", 10)\n\n\ttests := [...]struct {\n\t\tname  string\n\t\tvalue interface{}\n\t}{\n\t\t{\"str\", \"foo\"},\n\t\t{\"i32\", int32(1)},\n\t\t{\"u32\", uint32(1)},\n\t\t{\"i64\", int64(1)},\n\t\t{\"u64\", uint64(1)},\n\t\t{\"float64\", float64(1)},\n\t\t{\"bigint\", big.NewInt(1)},\n\t\t{\"biguint\", new(big.Int).SetUint64(1 << 63)},\n\t\t{\"bigbigint\", bigbigint},\n\t\t{\"bigbignegint\", bigbignegint},\n\t\t{\"bool\", true},\n\t\t{\"val\", val},\n\t\t{\"obj\", objVal},\n\t}\n\n\tfor _, tt := range tests {\n\t\ttt := tt\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tsetError(t, obj.Set(tt.name, tt.value, 0))\n\t\t})\n\t}\n}\n\nfunc TestObjectTemplate_panic_on_nil_isolate(t *testing.T) {\n\tt.Parallel()\n\n\tdefer func() {\n\t\tif err := recover(); err == nil {\n\t\t\tt.Error(\"expected panic\")\n\t\t}\n\t}()\n\tv8.NewObjectTemplate(nil)\n}\n\nfunc TestGlobalObjectTemplate(t *testing.T) {\n\tt.Parallel()\n\tiso := v8.NewIsolate()\n\tdefer iso.Dispose()\n\ttests := [...]struct {\n\t\tglobal   func() *v8.ObjectTemplate\n\t\tsource   string\n\t\tvalidate func(t *testing.T, val *v8.Value)\n\t}{\n\t\t{\n\t\t\tfunc() *v8.ObjectTemplate {\n\t\t\t\tgbl := v8.NewObjectTemplate(iso)\n\t\t\t\tgbl.Set(\"foo\", \"bar\")\n\t\t\t\treturn gbl\n\t\t\t},\n\t\t\t\"foo\",\n\t\t\tfunc(t *testing.T, val *v8.Value) {\n\t\t\t\tif !val.IsString() {\n\t\t\t\t\tt.Errorf(\"expect value %q to be of type String\", val)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tif val.String() != \"bar\" {\n\t\t\t\t\tt.Errorf(\"unexpected value: %v\", val)\n\t\t\t\t}\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tfunc() *v8.ObjectTemplate {\n\t\t\t\tfoo := v8.NewObjectTemplate(iso)\n\t\t\t\tfoo.Set(\"bar\", \"baz\")\n\t\t\t\tgbl := v8.NewObjectTemplate(iso)\n\t\t\t\tgbl.Set(\"foo\", foo)\n\t\t\t\treturn gbl\n\t\t\t},\n\t\t\t\"foo.bar\",\n\t\t\tfunc(t *testing.T, val *v8.Value) {\n\t\t\t\tif val.String() != \"baz\" {\n\t\t\t\t\tt.Errorf(\"unexpected value: %v\", val)\n\t\t\t\t}\n\t\t\t},\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\ttt := tt\n\t\tt.Run(tt.source, func(t *testing.T) {\n\t\t\tctx := v8.NewContext(iso, tt.global())\n\t\t\tval, err := ctx.RunScript(tt.source, \"test.js\")\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"unexpected error runing script: %v\", err)\n\t\t\t}\n\t\t\ttt.validate(t, val)\n\t\t\tctx.Close()\n\t\t})\n\t}\n}\n\nfunc TestObjectTemplateNewInstance(t *testing.T) {\n\tt.Parallel()\n\tiso := v8.NewIsolate()\n\tdefer iso.Dispose()\n\ttmpl := v8.NewObjectTemplate(iso)\n\tif _, err := tmpl.NewInstance(nil); err == nil {\n\t\tt.Error(\"expected error but got <nil>\")\n\t}\n\n\ttmpl.Set(\"foo\", \"bar\")\n\tctx := v8.NewContext(iso)\n\tdefer ctx.Close()\n\tobj, _ := tmpl.NewInstance(ctx)\n\tif foo, _ := obj.Get(\"foo\"); foo.String() != \"bar\" {\n\t\tt.Errorf(\"unexpected value for object property: %v\", foo)\n\t}\n}\n\nfunc TestObjectTemplate_garbageCollection(t *testing.T) {\n\tt.Parallel()\n\n\tiso := v8.NewIsolate()\n\n\ttmpl := v8.NewObjectTemplate(iso)\n\ttmpl.Set(\"foo\", \"bar\")\n\tctx := v8.NewContext(iso, tmpl)\n\n\tctx.Close()\n\tiso.Dispose()\n\n\truntime.GC()\n}\n"
        },
        {
          "name": "object_test.go",
          "type": "blob",
          "size": 5.5205078125,
          "content": "// Copyright 2021 Roger Chapman and the v8go contributors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\npackage v8go_test\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n\n\tv8 \"rogchap.com/v8go\"\n)\n\nfunc TestObjectMethodCall(t *testing.T) {\n\tt.Parallel()\n\n\tctx := v8.NewContext()\n\tiso := ctx.Isolate()\n\tdefer iso.Dispose()\n\tdefer ctx.Close()\n\tval, _ := ctx.RunScript(`class Obj { constructor(input) { this.input = input, this.prop = \"\" } print() { return this.input.toString() } }; new Obj(\"some val\")`, \"\")\n\tobj, _ := val.AsObject()\n\tval, err := obj.MethodCall(\"print\")\n\tfatalIf(t, err)\n\tif val.String() != \"some val\" {\n\t\tt.Errorf(\"unexpected value: %q\", val)\n\t}\n\t_, err = obj.MethodCall(\"prop\")\n\tif err == nil {\n\t\tt.Errorf(\"expected an error, got none\")\n\t}\n\n\tval, err = ctx.RunScript(`class Obj2 { print(str) { return str.toString() }; get fails() { throw \"error\" } }; new Obj2()`, \"\")\n\tfatalIf(t, err)\n\tobj, _ = val.AsObject()\n\targ, _ := v8.NewValue(iso, \"arg\")\n\tval, err = obj.MethodCall(\"print\", arg)\n\tfatalIf(t, err)\n\tif val.String() != \"arg\" {\n\t\tt.Errorf(\"unexpected value: %q\", val)\n\t}\n\t_, err = obj.MethodCall(\"fails\")\n\tif err == nil {\n\t\tt.Errorf(\"expected an error, got none\")\n\t}\n}\n\nfunc TestObjectSet(t *testing.T) {\n\tt.Parallel()\n\n\tctx := v8.NewContext()\n\tdefer ctx.Isolate().Dispose()\n\tdefer ctx.Close()\n\tval, _ := ctx.RunScript(\"const foo = {}; foo\", \"\")\n\tobj, _ := val.AsObject()\n\tif err := obj.Set(\"bar\", \"baz\"); err != nil {\n\t\tt.Errorf(\"unexpected error: %v\", err)\n\t}\n\tbaz, _ := ctx.RunScript(\"foo.bar\", \"\")\n\tif baz.String() != \"baz\" {\n\t\tt.Errorf(\"unexpected value: %q\", baz)\n\t}\n\n\tif err := obj.Set(\"\", \"zero\"); err != nil {\n\t\tt.Errorf(\"unexpected error: %v\", err)\n\t}\n\tval, err := ctx.RunScript(\"foo['']\", \"\")\n\tfatalIf(t, err)\n\tif val.String() != \"zero\" {\n\t\tt.Errorf(\"unexpected value: %q\", val)\n\t}\n\n\tif err := obj.Set(\"a\", nil); err == nil {\n\t\tt.Error(\"expected error but got <nil>\")\n\t}\n\tif err := obj.Set(\"a\", 0); err == nil {\n\t\tt.Error(\"expected error but got <nil>\")\n\t}\n\tif err := obj.SetIdx(10, \"ten\"); err != nil {\n\t\tt.Errorf(\"unexpected error: %v\", err)\n\t}\n\tif err := obj.SetIdx(10, t); err == nil {\n\t\tt.Error(\"expected error but got <nil>\")\n\t}\n\tif ten, _ := ctx.RunScript(\"foo[10]\", \"\"); ten.String() != \"ten\" {\n\t\tt.Errorf(\"unexpected value: %q\", ten)\n\t}\n}\n\nfunc TestObjectInternalFields(t *testing.T) {\n\tiso := v8.NewIsolate()\n\tdefer iso.Dispose()\n\tctx := v8.NewContext(iso)\n\tdefer ctx.Close()\n\n\ttmpl := v8.NewObjectTemplate(iso)\n\tobj, err := tmpl.NewInstance(ctx)\n\tfatalIf(t, err)\n\tif count := obj.InternalFieldCount(); count != 0 {\n\t\tt.Errorf(\"expected 0 got %v\", count)\n\t}\n\tif recoverPanic(func() { obj.GetInternalField(0) }) == nil {\n\t\tt.Error(\"expected panic\")\n\t}\n\n\ttmpl = v8.NewObjectTemplate(iso)\n\ttmpl.SetInternalFieldCount(1)\n\tif count := tmpl.InternalFieldCount(); count != 1 {\n\t\tt.Errorf(\"expected 1 got %v\", count)\n\t}\n\n\tobj, err = tmpl.NewInstance(ctx)\n\tfatalIf(t, err)\n\tif count := obj.InternalFieldCount(); count != 1 {\n\t\tt.Errorf(\"expected 1 got %v\", count)\n\t}\n\n\tif v := obj.GetInternalField(0); !v.SameValue(v8.Undefined(iso)) {\n\t\tt.Errorf(\"unexpected value: %q\", v)\n\t}\n\n\tif err := obj.SetInternalField(0, t); err == nil {\n\t\tt.Error(\"expected unsupported value error\")\n\t}\n\n\terr = obj.SetInternalField(0, \"baz\")\n\tfatalIf(t, err)\n\tif v := obj.GetInternalField(0); v.String() != \"baz\" {\n\t\tt.Errorf(\"unexpected value: %q\", v)\n\t}\n\n\tif recoverPanic(func() { obj.SetInternalField(1, \"baz\") }) == nil {\n\t\tt.Error(\"expected panic from index out of bounds\")\n\t}\n}\n\nfunc TestObjectGet(t *testing.T) {\n\tt.Parallel()\n\n\tctx := v8.NewContext()\n\tdefer ctx.Isolate().Dispose()\n\tdefer ctx.Close()\n\tval, _ := ctx.RunScript(\"const foo = { bar: 'baz'}; foo\", \"\")\n\tobj, _ := val.AsObject()\n\tif bar, _ := obj.Get(\"bar\"); bar.String() != \"baz\" {\n\t\tt.Errorf(\"unexpected value: %q\", bar)\n\t}\n\tif baz, _ := obj.Get(\"baz\"); !baz.IsUndefined() {\n\t\tt.Errorf(\"unexpected value: %q\", baz)\n\t}\n\tctx.RunScript(\"foo[5] = 5\", \"\")\n\tif five, _ := obj.GetIdx(5); five.Integer() != 5 {\n\t\tt.Errorf(\"unexpected value: %q\", five)\n\t}\n\tif u, _ := obj.GetIdx(55); !u.IsUndefined() {\n\t\tt.Errorf(\"unexpected value: %q\", u)\n\t}\n}\n\nfunc TestObjectHas(t *testing.T) {\n\tt.Parallel()\n\n\tctx := v8.NewContext()\n\tdefer ctx.Isolate().Dispose()\n\tdefer ctx.Close()\n\tval, _ := ctx.RunScript(\"const foo = {a: 1, '2': 2}; foo\", \"\")\n\tobj, _ := val.AsObject()\n\tif !obj.Has(\"a\") {\n\t\tt.Error(\"expected true, got false\")\n\t}\n\tif obj.Has(\"c\") {\n\t\tt.Error(\"expected false, got true\")\n\t}\n\tif !obj.HasIdx(2) {\n\t\tt.Error(\"expected true, got false\")\n\t}\n\tif obj.HasIdx(1) {\n\t\tt.Error(\"expected false, got true\")\n\t}\n}\n\nfunc TestObjectDelete(t *testing.T) {\n\tt.Parallel()\n\n\tctx := v8.NewContext()\n\tdefer ctx.Isolate().Dispose()\n\tdefer ctx.Close()\n\tval, _ := ctx.RunScript(\"const foo = { bar: 'baz', '2': 2}; foo\", \"\")\n\tobj, _ := val.AsObject()\n\tif !obj.Has(\"bar\") {\n\t\tt.Error(\"expected property to exist\")\n\t}\n\tif !obj.Delete(\"bar\") {\n\t\tt.Error(\"expected delete to return true, got false\")\n\t}\n\tif obj.Has(\"bar\") {\n\t\tt.Error(\"expected property to be deleted\")\n\t}\n\tif !obj.DeleteIdx(2) {\n\t\tt.Error(\"expected delete to return true, got false\")\n\t}\n\n}\n\nfunc ExampleObject_global() {\n\tiso := v8.NewIsolate()\n\tdefer iso.Dispose()\n\tctx := v8.NewContext(iso)\n\tdefer ctx.Close()\n\tglobal := ctx.Global()\n\n\tconsole := v8.NewObjectTemplate(iso)\n\tlogfn := v8.NewFunctionTemplate(iso, func(info *v8.FunctionCallbackInfo) *v8.Value {\n\t\tfmt.Println(info.Args()[0])\n\t\treturn nil\n\t})\n\tconsole.Set(\"log\", logfn)\n\tconsoleObj, _ := console.NewInstance(ctx)\n\n\tglobal.Set(\"console\", consoleObj)\n\tctx.RunScript(\"console.log('foo')\", \"\")\n\t// Output:\n\t// foo\n}\n"
        },
        {
          "name": "promise.go",
          "type": "blob",
          "size": 3.6591796875,
          "content": "// Copyright 2021 Roger Chapman and the v8go contributors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\npackage v8go\n\n// #include <stdlib.h>\n// #include \"v8go.h\"\nimport \"C\"\nimport (\n\t\"errors\"\n)\n\n// PromiseState is the state of the Promise.\ntype PromiseState int\n\nconst (\n\tPending PromiseState = iota\n\tFulfilled\n\tRejected\n)\n\n// PromiseResolver is the resolver object for the promise.\n// Most cases will create a new PromiseResolver and return\n// the associated Promise from the resolver.\ntype PromiseResolver struct {\n\t*Object\n\tprom *Promise\n}\n\n// Promise is the JavaScript promise object defined in ES6\ntype Promise struct {\n\t*Object\n}\n\n// NewPromiseResolver creates a new Promise resolver for the given context.\n// The associated Promise will be in a Pending state.\nfunc NewPromiseResolver(ctx *Context) (*PromiseResolver, error) {\n\tif ctx == nil {\n\t\treturn nil, errors.New(\"v8go: Context is required\")\n\t}\n\trtn := C.NewPromiseResolver(ctx.ptr)\n\tobj, err := objectResult(ctx, rtn)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn &PromiseResolver{obj, nil}, nil\n}\n\n// GetPromise returns the associated Promise object for this resolver.\n// The Promise object is unique to the resolver and returns the same object\n// on multiple calls.\nfunc (r *PromiseResolver) GetPromise() *Promise {\n\tif r.prom == nil {\n\t\tptr := C.PromiseResolverGetPromise(r.ptr)\n\t\tval := &Value{ptr, r.ctx}\n\t\tr.prom = &Promise{&Object{val}}\n\t}\n\treturn r.prom\n}\n\n// Resolve invokes the Promise resolve state with the given value.\n// The Promise state will transition from Pending to Fulfilled.\nfunc (r *PromiseResolver) Resolve(val Valuer) bool {\n\treturn C.PromiseResolverResolve(r.ptr, val.value().ptr) != 0\n}\n\n// Reject invokes the Promise reject state with the given value.\n// The Promise state will transition from Pending to Rejected.\nfunc (r *PromiseResolver) Reject(err *Value) bool {\n\treturn C.PromiseResolverReject(r.ptr, err.ptr) != 0\n}\n\n// State returns the current state of the Promise.\nfunc (p *Promise) State() PromiseState {\n\treturn PromiseState(C.PromiseState(p.ptr))\n}\n\n// Result is the value result of the Promise. The Promise must\n// NOT be in a Pending state, otherwise may panic. Call promise.State()\n// to validate state before calling for the result.\nfunc (p *Promise) Result() *Value {\n\tptr := C.PromiseResult(p.ptr)\n\tval := &Value{ptr, p.ctx}\n\treturn val\n}\n\n// Then accepts 1 or 2 callbacks.\n// The first is invoked when the promise has been fulfilled.\n// The second is invoked when the promise has been rejected.\n// The returned Promise resolves after the callback finishes execution.\n//\n// V8 only invokes the callback when processing \"microtasks\".\n// The default MicrotaskPolicy processes them when the call depth decreases to 0.\n// Call (*Context).PerformMicrotaskCheckpoint to trigger it manually.\nfunc (p *Promise) Then(cbs ...FunctionCallback) *Promise {\n\tvar rtn C.RtnValue\n\tswitch len(cbs) {\n\tcase 1:\n\t\tcbID := p.ctx.iso.registerCallback(cbs[0])\n\t\trtn = C.PromiseThen(p.ptr, C.int(cbID))\n\tcase 2:\n\t\tcbID1 := p.ctx.iso.registerCallback(cbs[0])\n\t\tcbID2 := p.ctx.iso.registerCallback(cbs[1])\n\t\trtn = C.PromiseThen2(p.ptr, C.int(cbID1), C.int(cbID2))\n\n\tdefault:\n\t\tpanic(\"1 or 2 callbacks required\")\n\t}\n\tobj, err := objectResult(p.ctx, rtn)\n\tif err != nil {\n\t\tpanic(err) // TODO: Return error\n\t}\n\treturn &Promise{obj}\n}\n\n// Catch invokes the given function if the promise is rejected.\n// See Then for other details.\nfunc (p *Promise) Catch(cb FunctionCallback) *Promise {\n\tcbID := p.ctx.iso.registerCallback(cb)\n\trtn := C.PromiseCatch(p.ptr, C.int(cbID))\n\tobj, err := objectResult(p.ctx, rtn)\n\tif err != nil {\n\t\tpanic(err) // TODO: Return error\n\t}\n\treturn &Promise{obj}\n}\n"
        },
        {
          "name": "promise_test.go",
          "type": "blob",
          "size": 3.361328125,
          "content": "// Copyright 2021 Roger Chapman and the v8go contributors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\npackage v8go_test\n\nimport (\n\t\"testing\"\n\n\tv8 \"rogchap.com/v8go\"\n)\n\nfunc TestPromiseFulfilled(t *testing.T) {\n\tt.Parallel()\n\n\tiso := v8.NewIsolate()\n\tdefer iso.Dispose()\n\tctx := v8.NewContext(iso)\n\tdefer ctx.Close()\n\n\tif _, err := v8.NewPromiseResolver(nil); err == nil {\n\t\tt.Error(\"expected error with <nil> Context\")\n\t}\n\n\tres1, _ := v8.NewPromiseResolver(ctx)\n\tprom1 := res1.GetPromise()\n\tif s := prom1.State(); s != v8.Pending {\n\t\tt.Errorf(\"unexpected state for Promise, want Pending (0) got: %v\", s)\n\t}\n\n\tvar thenInfo *v8.FunctionCallbackInfo\n\tprom1thenVal := prom1.Then(func(info *v8.FunctionCallbackInfo) *v8.Value {\n\t\tthenInfo = info\n\t\treturn nil\n\t})\n\tprom1then, _ := prom1thenVal.AsPromise()\n\tif prom1then.State() != v8.Pending {\n\t\tt.Errorf(\"unexpected state for dependent Promise, want Pending got: %v\", prom1then.State())\n\t}\n\tif thenInfo != nil {\n\t\tt.Error(\"unexpected call of Then prior to resolving the promise\")\n\t}\n\n\tval1, _ := v8.NewValue(iso, \"foo\")\n\tres1.Resolve(val1)\n\n\tif s := prom1.State(); s != v8.Fulfilled {\n\t\tt.Fatalf(\"unexpected state for Promise, want Fulfilled (1) got: %v\", s)\n\t}\n\n\tif result := prom1.Result(); result.String() != val1.String() {\n\t\tt.Errorf(\"expected the Promise result to match the resolve value, but got: %s\", result)\n\t}\n\n\tif thenInfo == nil {\n\t\tt.Errorf(\"expected Then to be called, was not\")\n\t}\n\tif len(thenInfo.Args()) != 1 || thenInfo.Args()[0].String() != \"foo\" {\n\t\tt.Errorf(\"expected promise to be called with [foo] args, was: %+v\", thenInfo.Args())\n\t}\n}\n\nfunc TestPromiseRejected(t *testing.T) {\n\tt.Parallel()\n\n\tiso := v8.NewIsolate()\n\tdefer iso.Dispose()\n\tctx := v8.NewContext(iso)\n\tdefer ctx.Close()\n\n\tres2, _ := v8.NewPromiseResolver(ctx)\n\tval2, _ := v8.NewValue(iso, \"Bad Foo\")\n\tres2.Reject(val2)\n\n\tprom2 := res2.GetPromise()\n\tif s := prom2.State(); s != v8.Rejected {\n\t\tt.Fatalf(\"unexpected state for Promise, want Rejected (2) got: %v\", s)\n\t}\n\n\tvar thenInfo *v8.FunctionCallbackInfo\n\tvar then2Fulfilled, then2Rejected bool\n\tprom2.\n\t\tCatch(func(info *v8.FunctionCallbackInfo) *v8.Value {\n\t\t\tthenInfo = info\n\t\t\treturn nil\n\t\t}).\n\t\tThen(\n\t\t\tfunc(_ *v8.FunctionCallbackInfo) *v8.Value {\n\t\t\t\tthen2Fulfilled = true\n\t\t\t\treturn nil\n\t\t\t},\n\t\t\tfunc(_ *v8.FunctionCallbackInfo) *v8.Value {\n\t\t\t\tthen2Rejected = true\n\t\t\t\treturn nil\n\t\t\t},\n\t\t)\n\tctx.PerformMicrotaskCheckpoint()\n\tif thenInfo == nil {\n\t\tt.Fatalf(\"expected Then to be called on already-resolved promise, but was not\")\n\t}\n\tif len(thenInfo.Args()) != 1 || thenInfo.Args()[0].String() != val2.String() {\n\t\tt.Fatalf(\"expected [%v], was: %+v\", val2, thenInfo.Args())\n\t}\n\n\tif !then2Fulfilled {\n\t\tt.Fatalf(\"expected call to onFulfilled, got none\")\n\t}\n\tif then2Rejected {\n\t\tt.Fatalf(\"unexpectedly called onRejected\")\n\t}\n}\n\nfunc TestPromiseThenPanic(t *testing.T) {\n\tt.Parallel()\n\n\tiso := v8.NewIsolate()\n\tdefer iso.Dispose()\n\tctx := v8.NewContext(iso)\n\tdefer ctx.Close()\n\n\tres, _ := v8.NewPromiseResolver(ctx)\n\tprom := res.GetPromise()\n\n\tt.Run(\"no callbacks\", func(t *testing.T) {\n\t\tdefer func() { recover() }()\n\t\tprom.Then()\n\t\tt.Errorf(\"expected a panic\")\n\t})\n\tt.Run(\"3 callbacks\", func(t *testing.T) {\n\t\tdefer func() { recover() }()\n\t\tfn := func(_ *v8.FunctionCallbackInfo) *v8.Value { return nil }\n\t\tprom.Then(fn, fn, fn)\n\t\tt.Errorf(\"expected a panic\")\n\t})\n}\n"
        },
        {
          "name": "script_compiler.go",
          "type": "blob",
          "size": 0.435546875,
          "content": "// Copyright 2021 the v8go contributors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\npackage v8go\n\n// #include \"v8go.h\"\nimport \"C\"\n\ntype CompileMode C.int\n\nvar (\n\tCompileModeDefault = CompileMode(C.ScriptCompilerNoCompileOptions)\n\tCompileModeEager   = CompileMode(C.ScriptCompilerEagerCompile)\n)\n\ntype CompilerCachedData struct {\n\tBytes    []byte\n\tRejected bool\n}\n"
        },
        {
          "name": "template.go",
          "type": "blob",
          "size": 2.107421875,
          "content": "// Copyright 2021 Roger Chapman and the v8go contributors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\npackage v8go\n\n// #include <stdlib.h>\n// #include \"v8go.h\"\nimport \"C\"\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"math/big\"\n\t\"runtime\"\n\t\"unsafe\"\n)\n\ntype template struct {\n\tptr C.TemplatePtr\n\tiso *Isolate\n}\n\n// Set adds a property to each instance created by this template.\n// The property must be defined either as a primitive value, or a template.\n// If the value passed is a Go supported primitive (string, int32, uint32, int64, uint64, float64, big.Int)\n// then a value will be created and set as the value property.\nfunc (t *template) Set(name string, val interface{}, attributes ...PropertyAttribute) error {\n\tcname := C.CString(name)\n\tdefer C.free(unsafe.Pointer(cname))\n\n\tvar attrs PropertyAttribute\n\tfor _, a := range attributes {\n\t\tattrs |= a\n\t}\n\n\tswitch v := val.(type) {\n\tcase string, int32, uint32, int64, uint64, float64, bool, *big.Int:\n\t\tnewVal, err := NewValue(t.iso, v)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"v8go: unable to create new value: %v\", err)\n\t\t}\n\t\tC.TemplateSetValue(t.ptr, cname, newVal.ptr, C.int(attrs))\n\tcase *ObjectTemplate:\n\t\tC.TemplateSetTemplate(t.ptr, cname, v.ptr, C.int(attrs))\n\t\truntime.KeepAlive(v)\n\tcase *FunctionTemplate:\n\t\tC.TemplateSetTemplate(t.ptr, cname, v.ptr, C.int(attrs))\n\t\truntime.KeepAlive(v)\n\tcase *Value:\n\t\tif v.IsObject() || v.IsExternal() {\n\t\t\treturn errors.New(\"v8go: unsupported property: value type must be a primitive or use a template\")\n\t\t}\n\t\tC.TemplateSetValue(t.ptr, cname, v.ptr, C.int(attrs))\n\tdefault:\n\t\treturn fmt.Errorf(\"v8go: unsupported property type `%T`, must be one of string, int32, uint32, int64, uint64, float64, *big.Int, *v8go.Value, *v8go.ObjectTemplate or *v8go.FunctionTemplate\", v)\n\t}\n\truntime.KeepAlive(t)\n\n\treturn nil\n}\n\nfunc (t *template) finalizer() {\n\t// Using v8::PersistentBase::Reset() wouldn't be thread-safe to do from\n\t// this finalizer goroutine so just free the wrapper and let the template\n\t// itself get cleaned up when the isolate is disposed.\n\tC.TemplateFreeWrapper(t.ptr)\n\tt.ptr = nil\n}\n"
        },
        {
          "name": "unbound_script.go",
          "type": "blob",
          "size": 1.16796875,
          "content": "// Copyright 2021 the v8go contributors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\npackage v8go\n\n// #include <stdlib.h>\n// #include \"v8go.h\"\nimport \"C\"\nimport \"unsafe\"\n\ntype UnboundScript struct {\n\tptr C.UnboundScriptPtr\n\tiso *Isolate\n}\n\n// Run will bind the unbound script to the provided context and run it.\n// If the context provided does not belong to the same isolate that the script\n// was compiled in, Run will panic.\n// If an error occurs, it will be of type `JSError`.\nfunc (u *UnboundScript) Run(ctx *Context) (*Value, error) {\n\tif ctx.Isolate() != u.iso {\n\t\tpanic(\"attempted to run unbound script in a context that belongs to a different isolate\")\n\t}\n\trtn := C.UnboundScriptRun(ctx.ptr, u.ptr)\n\treturn valueResult(ctx, rtn)\n}\n\n// Create a code cache from the unbound script.\nfunc (u *UnboundScript) CreateCodeCache() *CompilerCachedData {\n\trtn := C.UnboundScriptCreateCodeCache(u.iso.ptr, u.ptr)\n\n\tcachedData := &CompilerCachedData{\n\t\tBytes:    []byte(C.GoBytes(unsafe.Pointer(rtn.data), rtn.length)),\n\t\tRejected: int(rtn.rejected) == 1,\n\t}\n\tC.ScriptCompilerCachedDataDelete(rtn)\n\treturn cachedData\n}\n"
        },
        {
          "name": "unbound_script_test.go",
          "type": "blob",
          "size": 1.060546875,
          "content": "// Copyright 2021 the v8go contributors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\npackage v8go_test\n\nimport (\n\t\"testing\"\n\n\tv8 \"rogchap.com/v8go\"\n)\n\nfunc TestUnboundScriptRun_OnlyInTheSameIsolate(t *testing.T) {\n\tstr := \"function foo() { return 'bar'; }; foo()\"\n\ti1 := v8.NewIsolate()\n\tdefer i1.Dispose()\n\n\tus, err := i1.CompileUnboundScript(str, \"script.js\", v8.CompileOptions{})\n\tfatalIf(t, err)\n\n\tc1 := v8.NewContext(i1)\n\tdefer c1.Close()\n\n\tval, err := us.Run(c1)\n\tfatalIf(t, err)\n\tif val.String() != \"bar\" {\n\t\tt.Fatalf(\"invalid value returned, expected bar got %v\", val)\n\t}\n\n\tc2 := v8.NewContext(i1)\n\tdefer c2.Close()\n\n\tval, err = us.Run(c2)\n\tfatalIf(t, err)\n\tif val.String() != \"bar\" {\n\t\tt.Fatalf(\"invalid value returned, expected bar got %v\", val)\n\t}\n\n\ti2 := v8.NewIsolate()\n\tdefer i2.Dispose()\n\ti2c1 := v8.NewContext(i2)\n\tdefer i2c1.Close()\n\n\tif recoverPanic(func() { us.Run(i2c1) }) == nil {\n\t\tt.Error(\"expected panic running unbound script in a context belonging to a different isolate\")\n\t}\n}\n"
        },
        {
          "name": "v8go.cc",
          "type": "blob",
          "size": 44.259765625,
          "content": "// Copyright 2019 Roger Chapman and the v8go contributors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\n#include \"v8go.h\"\n\n#include <stdio.h>\n\n#include <cstdlib>\n#include <cstring>\n#include <iostream>\n#include <sstream>\n#include <string>\n#include <unordered_map>\n#include <vector>\n\n#include \"_cgo_export.h\"\n\nusing namespace v8;\n\nauto default_platform = platform::NewDefaultPlatform();\nArrayBuffer::Allocator* default_allocator;\n\nconst int ScriptCompilerNoCompileOptions = ScriptCompiler::kNoCompileOptions;\nconst int ScriptCompilerConsumeCodeCache = ScriptCompiler::kConsumeCodeCache;\nconst int ScriptCompilerEagerCompile = ScriptCompiler::kEagerCompile;\n\nstruct m_ctx {\n  Isolate* iso;\n  std::unordered_map<long, m_value*> vals;\n  std::vector<m_unboundScript*> unboundScripts;\n  Persistent<Context> ptr;\n  long nextValId;\n};\n\nstruct m_value {\n  long id;\n  Isolate* iso;\n  m_ctx* ctx;\n  Persistent<Value, CopyablePersistentTraits<Value>> ptr;\n};\n\nstruct m_template {\n  Isolate* iso;\n  Persistent<Template> ptr;\n};\n\nstruct m_unboundScript {\n  Persistent<UnboundScript> ptr;\n};\n\nconst char* CopyString(std::string str) {\n  int len = str.length();\n  char* mem = (char*)malloc(len + 1);\n  memcpy(mem, str.data(), len);\n  mem[len] = 0;\n  return mem;\n}\n\nconst char* CopyString(String::Utf8Value& value) {\n  if (value.length() == 0) {\n    return nullptr;\n  }\n  return CopyString(std::string(*value, value.length()));\n}\n\nstatic RtnError ExceptionError(TryCatch& try_catch,\n                               Isolate* iso,\n                               Local<Context> ctx) {\n  HandleScope handle_scope(iso);\n\n  RtnError rtn = {nullptr, nullptr, nullptr};\n\n  if (try_catch.HasTerminated()) {\n    rtn.msg =\n        CopyString(\"ExecutionTerminated: script execution has been terminated\");\n    return rtn;\n  }\n\n  String::Utf8Value exception(iso, try_catch.Exception());\n  rtn.msg = CopyString(exception);\n\n  Local<Message> msg = try_catch.Message();\n  if (!msg.IsEmpty()) {\n    String::Utf8Value origin(iso, msg->GetScriptOrigin().ResourceName());\n    std::ostringstream sb;\n    sb << *origin;\n    Maybe<int> line = try_catch.Message()->GetLineNumber(ctx);\n    if (line.IsJust()) {\n      sb << \":\" << line.ToChecked();\n    }\n    Maybe<int> start = try_catch.Message()->GetStartColumn(ctx);\n    if (start.IsJust()) {\n      sb << \":\"\n         << start.ToChecked() + 1;  // + 1 to match output from stack trace\n    }\n    rtn.location = CopyString(sb.str());\n  }\n\n  Local<Value> mstack;\n  if (try_catch.StackTrace(ctx).ToLocal(&mstack)) {\n    String::Utf8Value stack(iso, mstack);\n    rtn.stack = CopyString(stack);\n  }\n\n  return rtn;\n}\n\nm_value* tracked_value(m_ctx* ctx, m_value* val) {\n  // (rogchap) we track values against a context so that when the context is\n  // closed (either manually or GC'd by Go) we can also release all the\n  // values associated with the context;\n  if (val->id == 0) {\n    val->id = ++ctx->nextValId;\n    ctx->vals[val->id] = val;\n  }\n\n  return val;\n}\n\nm_unboundScript* tracked_unbound_script(m_ctx* ctx, m_unboundScript* us) {\n  ctx->unboundScripts.push_back(us);\n\n  return us;\n}\n\nextern \"C\" {\n\n/********** Isolate **********/\n\n#define ISOLATE_SCOPE(iso)           \\\n  Locker locker(iso);                \\\n  Isolate::Scope isolate_scope(iso); \\\n  HandleScope handle_scope(iso);\n\n#define ISOLATE_SCOPE_INTERNAL_CONTEXT(iso) \\\n  ISOLATE_SCOPE(iso);                       \\\n  m_ctx* ctx = isolateInternalContext(iso);\n\nvoid Init() {\n#ifdef _WIN32\n  V8::InitializeExternalStartupData(\".\");\n#endif\n  V8::InitializePlatform(default_platform.get());\n  V8::Initialize();\n\n  default_allocator = ArrayBuffer::Allocator::NewDefaultAllocator();\n  return;\n}\n\nIsolatePtr NewIsolate() {\n  Isolate::CreateParams params;\n  params.array_buffer_allocator = default_allocator;\n  Isolate* iso = Isolate::New(params);\n  Locker locker(iso);\n  Isolate::Scope isolate_scope(iso);\n  HandleScope handle_scope(iso);\n\n  iso->SetCaptureStackTraceForUncaughtExceptions(true);\n\n  // Create a Context for internal use\n  m_ctx* ctx = new m_ctx;\n  ctx->ptr.Reset(iso, Context::New(iso));\n  ctx->iso = iso;\n  iso->SetData(0, ctx);\n\n  return iso;\n}\n\nstatic inline m_ctx* isolateInternalContext(Isolate* iso) {\n  return static_cast<m_ctx*>(iso->GetData(0));\n}\n\nvoid IsolatePerformMicrotaskCheckpoint(IsolatePtr iso) {\n  ISOLATE_SCOPE(iso)\n  iso->PerformMicrotaskCheckpoint();\n}\n\nvoid IsolateDispose(IsolatePtr iso) {\n  if (iso == nullptr) {\n    return;\n  }\n  ContextFree(isolateInternalContext(iso));\n\n  iso->Dispose();\n}\n\nvoid IsolateTerminateExecution(IsolatePtr iso) {\n  iso->TerminateExecution();\n}\n\nint IsolateIsExecutionTerminating(IsolatePtr iso) {\n  return iso->IsExecutionTerminating();\n}\n\nIsolateHStatistics IsolationGetHeapStatistics(IsolatePtr iso) {\n  if (iso == nullptr) {\n    return IsolateHStatistics{0};\n  }\n  v8::HeapStatistics hs;\n  iso->GetHeapStatistics(&hs);\n\n  return IsolateHStatistics{hs.total_heap_size(),\n                            hs.total_heap_size_executable(),\n                            hs.total_physical_size(),\n                            hs.total_available_size(),\n                            hs.used_heap_size(),\n                            hs.heap_size_limit(),\n                            hs.malloced_memory(),\n                            hs.external_memory(),\n                            hs.peak_malloced_memory(),\n                            hs.number_of_native_contexts(),\n                            hs.number_of_detached_contexts()};\n}\n\nRtnUnboundScript IsolateCompileUnboundScript(IsolatePtr iso,\n                                             const char* s,\n                                             const char* o,\n                                             CompileOptions opts) {\n  ISOLATE_SCOPE_INTERNAL_CONTEXT(iso);\n  TryCatch try_catch(iso);\n  Local<Context> local_ctx = ctx->ptr.Get(iso);\n  Context::Scope context_scope(local_ctx);\n\n  RtnUnboundScript rtn = {};\n\n  Local<String> src =\n      String::NewFromUtf8(iso, s, NewStringType::kNormal).ToLocalChecked();\n  Local<String> ogn =\n      String::NewFromUtf8(iso, o, NewStringType::kNormal).ToLocalChecked();\n\n  ScriptCompiler::CompileOptions option =\n      static_cast<ScriptCompiler::CompileOptions>(opts.compileOption);\n\n  ScriptCompiler::CachedData* cached_data = nullptr;\n\n  if (opts.cachedData.data) {\n    cached_data = new ScriptCompiler::CachedData(opts.cachedData.data,\n                                                 opts.cachedData.length);\n  }\n\n  ScriptOrigin script_origin(iso, ogn);\n\n  ScriptCompiler::Source source(src, script_origin, cached_data);\n\n  Local<UnboundScript> unbound_script;\n  if (!ScriptCompiler::CompileUnboundScript(iso, &source, option)\n           .ToLocal(&unbound_script)) {\n    rtn.error = ExceptionError(try_catch, iso, local_ctx);\n    return rtn;\n  };\n\n  if (cached_data) {\n    rtn.cachedDataRejected = cached_data->rejected;\n  }\n\n  m_unboundScript* us = new m_unboundScript;\n  us->ptr.Reset(iso, unbound_script);\n  rtn.ptr = tracked_unbound_script(ctx, us);\n  return rtn;\n}\n\n/********** Exceptions & Errors **********/\n\nValuePtr IsolateThrowException(IsolatePtr iso, ValuePtr value) {\n  ISOLATE_SCOPE(iso);\n  m_ctx* ctx = value->ctx;\n\n  Local<Value> throw_ret_val = iso->ThrowException(value->ptr.Get(iso));\n\n  m_value* new_val = new m_value;\n  new_val->id = 0;\n  new_val->iso = iso;\n  new_val->ctx = ctx;\n  new_val->ptr =\n      Persistent<Value, CopyablePersistentTraits<Value>>(iso, throw_ret_val);\n\n  return tracked_value(ctx, new_val);\n}\n\n/********** CpuProfiler **********/\n\nCPUProfiler* NewCPUProfiler(IsolatePtr iso_ptr) {\n  Isolate* iso = static_cast<Isolate*>(iso_ptr);\n  Locker locker(iso);\n  Isolate::Scope isolate_scope(iso);\n  HandleScope handle_scope(iso);\n\n  CPUProfiler* c = new CPUProfiler;\n  c->iso = iso;\n  c->ptr = CpuProfiler::New(iso);\n  return c;\n}\n\nvoid CPUProfilerDispose(CPUProfiler* profiler) {\n  if (profiler->ptr == nullptr) {\n    return;\n  }\n  profiler->ptr->Dispose();\n\n  delete profiler;\n}\n\nvoid CPUProfilerStartProfiling(CPUProfiler* profiler, const char* title) {\n  if (profiler->iso == nullptr) {\n    return;\n  }\n\n  Locker locker(profiler->iso);\n  Isolate::Scope isolate_scope(profiler->iso);\n  HandleScope handle_scope(profiler->iso);\n\n  Local<String> title_str =\n      String::NewFromUtf8(profiler->iso, title, NewStringType::kNormal)\n          .ToLocalChecked();\n  profiler->ptr->StartProfiling(title_str);\n}\n\nCPUProfileNode* NewCPUProfileNode(const CpuProfileNode* ptr_) {\n  int count = ptr_->GetChildrenCount();\n  CPUProfileNode** children = new CPUProfileNode*[count];\n  for (int i = 0; i < count; ++i) {\n    children[i] = NewCPUProfileNode(ptr_->GetChild(i));\n  }\n\n  CPUProfileNode* root = new CPUProfileNode{\n      ptr_,\n      ptr_->GetNodeId(),\n      ptr_->GetScriptId(),\n      ptr_->GetScriptResourceNameStr(),\n      ptr_->GetFunctionNameStr(),\n      ptr_->GetLineNumber(),\n      ptr_->GetColumnNumber(),\n      ptr_->GetHitCount(),\n      ptr_->GetBailoutReason(),\n      count,\n      children,\n  };\n  return root;\n}\n\nCPUProfile* CPUProfilerStopProfiling(CPUProfiler* profiler, const char* title) {\n  if (profiler->iso == nullptr) {\n    return nullptr;\n  }\n\n  Locker locker(profiler->iso);\n  Isolate::Scope isolate_scope(profiler->iso);\n  HandleScope handle_scope(profiler->iso);\n\n  Local<String> title_str =\n      String::NewFromUtf8(profiler->iso, title, NewStringType::kNormal)\n          .ToLocalChecked();\n\n  CPUProfile* profile = new CPUProfile;\n  profile->ptr = profiler->ptr->StopProfiling(title_str);\n\n  Local<String> str = profile->ptr->GetTitle();\n  String::Utf8Value t(profiler->iso, str);\n  profile->title = CopyString(t);\n\n  CPUProfileNode* root = NewCPUProfileNode(profile->ptr->GetTopDownRoot());\n  profile->root = root;\n\n  profile->startTime = profile->ptr->GetStartTime();\n  profile->endTime = profile->ptr->GetEndTime();\n\n  return profile;\n}\n\nvoid CPUProfileNodeDelete(CPUProfileNode* node) {\n  for (int i = 0; i < node->childrenCount; ++i) {\n    CPUProfileNodeDelete(node->children[i]);\n  }\n\n  delete[] node->children;\n  delete node;\n}\n\nvoid CPUProfileDelete(CPUProfile* profile) {\n  if (profile->ptr == nullptr) {\n    return;\n  }\n  profile->ptr->Delete();\n  free((void*)profile->title);\n\n  CPUProfileNodeDelete(profile->root);\n\n  delete profile;\n}\n\n/********** Template **********/\n\n#define LOCAL_TEMPLATE(tmpl_ptr)     \\\n  Isolate* iso = tmpl_ptr->iso;      \\\n  Locker locker(iso);                \\\n  Isolate::Scope isolate_scope(iso); \\\n  HandleScope handle_scope(iso);     \\\n  Local<Template> tmpl = tmpl_ptr->ptr.Get(iso);\n\nvoid TemplateFreeWrapper(TemplatePtr tmpl) {\n  tmpl->ptr.Empty();  // Just does `val_ = 0;` without calling V8::DisposeGlobal\n  delete tmpl;\n}\n\nvoid TemplateSetValue(TemplatePtr ptr,\n                      const char* name,\n                      ValuePtr val,\n                      int attributes) {\n  LOCAL_TEMPLATE(ptr);\n\n  Local<String> prop_name =\n      String::NewFromUtf8(iso, name, NewStringType::kNormal).ToLocalChecked();\n  tmpl->Set(prop_name, val->ptr.Get(iso), (PropertyAttribute)attributes);\n}\n\nvoid TemplateSetTemplate(TemplatePtr ptr,\n                         const char* name,\n                         TemplatePtr obj,\n                         int attributes) {\n  LOCAL_TEMPLATE(ptr);\n\n  Local<String> prop_name =\n      String::NewFromUtf8(iso, name, NewStringType::kNormal).ToLocalChecked();\n  tmpl->Set(prop_name, obj->ptr.Get(iso), (PropertyAttribute)attributes);\n}\n\n/********** ObjectTemplate **********/\n\nTemplatePtr NewObjectTemplate(IsolatePtr iso) {\n  Locker locker(iso);\n  Isolate::Scope isolate_scope(iso);\n  HandleScope handle_scope(iso);\n\n  m_template* ot = new m_template;\n  ot->iso = iso;\n  ot->ptr.Reset(iso, ObjectTemplate::New(iso));\n  return ot;\n}\n\nRtnValue ObjectTemplateNewInstance(TemplatePtr ptr, ContextPtr ctx) {\n  LOCAL_TEMPLATE(ptr);\n  TryCatch try_catch(iso);\n  Local<Context> local_ctx = ctx->ptr.Get(iso);\n  Context::Scope context_scope(local_ctx);\n\n  RtnValue rtn = {};\n\n  Local<ObjectTemplate> obj_tmpl = tmpl.As<ObjectTemplate>();\n  Local<Object> obj;\n  if (!obj_tmpl->NewInstance(local_ctx).ToLocal(&obj)) {\n    rtn.error = ExceptionError(try_catch, iso, local_ctx);\n    return rtn;\n  }\n\n  m_value* val = new m_value;\n  val->id = 0;\n  val->iso = iso;\n  val->ctx = ctx;\n  val->ptr = Persistent<Value, CopyablePersistentTraits<Value>>(iso, obj);\n  rtn.value = tracked_value(ctx, val);\n  return rtn;\n}\n\nvoid ObjectTemplateSetInternalFieldCount(TemplatePtr ptr, int field_count) {\n  LOCAL_TEMPLATE(ptr);\n\n  Local<ObjectTemplate> obj_tmpl = tmpl.As<ObjectTemplate>();\n  obj_tmpl->SetInternalFieldCount(field_count);\n}\n\nint ObjectTemplateInternalFieldCount(TemplatePtr ptr) {\n  LOCAL_TEMPLATE(ptr);\n\n  Local<ObjectTemplate> obj_tmpl = tmpl.As<ObjectTemplate>();\n  return obj_tmpl->InternalFieldCount();\n}\n\n/********** FunctionTemplate **********/\n\nstatic void FunctionTemplateCallback(const FunctionCallbackInfo<Value>& info) {\n  Isolate* iso = info.GetIsolate();\n  ISOLATE_SCOPE(iso);\n\n  // This callback function can be called from any Context, which we only know\n  // at runtime. We extract the Context reference from the embedder data so that\n  // we can use the context registry to match the Context on the Go side\n  Local<Context> local_ctx = iso->GetCurrentContext();\n  int ctx_ref = local_ctx->GetEmbedderData(1).As<Integer>()->Value();\n  m_ctx* ctx = goContext(ctx_ref);\n\n  int callback_ref = info.Data().As<Integer>()->Value();\n\n  m_value* _this = new m_value;\n  _this->id = 0;\n  _this->iso = iso;\n  _this->ctx = ctx;\n  _this->ptr.Reset(iso, Persistent<Value, CopyablePersistentTraits<Value>>(\n                            iso, info.This()));\n\n  int args_count = info.Length();\n  ValuePtr thisAndArgs[args_count + 1];\n  thisAndArgs[0] = tracked_value(ctx, _this);\n  ValuePtr* args = thisAndArgs + 1;\n  for (int i = 0; i < args_count; i++) {\n    m_value* val = new m_value;\n    val->id = 0;\n    val->iso = iso;\n    val->ctx = ctx;\n    val->ptr.Reset(\n        iso, Persistent<Value, CopyablePersistentTraits<Value>>(iso, info[i]));\n    args[i] = tracked_value(ctx, val);\n  }\n\n  ValuePtr val =\n      goFunctionCallback(ctx_ref, callback_ref, thisAndArgs, args_count);\n  if (val != nullptr) {\n    info.GetReturnValue().Set(val->ptr.Get(iso));\n  } else {\n    info.GetReturnValue().SetUndefined();\n  }\n}\n\nTemplatePtr NewFunctionTemplate(IsolatePtr iso, int callback_ref) {\n  Locker locker(iso);\n  Isolate::Scope isolate_scope(iso);\n  HandleScope handle_scope(iso);\n\n  // (rogchap) We only need to store one value, callback_ref, into the\n  // C++ callback function data, but if we needed to store more items we could\n  // use an V8::Array; this would require the internal context from\n  // iso->GetData(0)\n  Local<Integer> cbData = Integer::New(iso, callback_ref);\n\n  m_template* ot = new m_template;\n  ot->iso = iso;\n  ot->ptr.Reset(iso,\n                FunctionTemplate::New(iso, FunctionTemplateCallback, cbData));\n  return ot;\n}\n\nRtnValue FunctionTemplateGetFunction(TemplatePtr ptr, ContextPtr ctx) {\n  LOCAL_TEMPLATE(ptr);\n  TryCatch try_catch(iso);\n  Local<Context> local_ctx = ctx->ptr.Get(iso);\n  Context::Scope context_scope(local_ctx);\n\n  Local<FunctionTemplate> fn_tmpl = tmpl.As<FunctionTemplate>();\n  RtnValue rtn = {};\n  Local<Function> fn;\n  if (!fn_tmpl->GetFunction(local_ctx).ToLocal(&fn)) {\n    rtn.error = ExceptionError(try_catch, iso, local_ctx);\n    return rtn;\n  }\n\n  m_value* val = new m_value;\n  val->id = 0;\n  val->iso = iso;\n  val->ctx = ctx;\n  val->ptr = Persistent<Value, CopyablePersistentTraits<Value>>(iso, fn);\n  rtn.value = tracked_value(ctx, val);\n  return rtn;\n}\n\n/********** Context **********/\n\n#define LOCAL_CONTEXT(ctx)                      \\\n  Isolate* iso = ctx->iso;                      \\\n  Locker locker(iso);                           \\\n  Isolate::Scope isolate_scope(iso);            \\\n  HandleScope handle_scope(iso);                \\\n  TryCatch try_catch(iso);                      \\\n  Local<Context> local_ctx = ctx->ptr.Get(iso); \\\n  Context::Scope context_scope(local_ctx);\n\nContextPtr NewContext(IsolatePtr iso,\n                      TemplatePtr global_template_ptr,\n                      int ref) {\n  Locker locker(iso);\n  Isolate::Scope isolate_scope(iso);\n  HandleScope handle_scope(iso);\n\n  Local<ObjectTemplate> global_template;\n  if (global_template_ptr != nullptr) {\n    global_template = global_template_ptr->ptr.Get(iso).As<ObjectTemplate>();\n  } else {\n    global_template = ObjectTemplate::New(iso);\n  }\n\n  // For function callbacks we need a reference to the context, but because of\n  // the complexities of C -> Go function pointers, we store a reference to the\n  // context as a simple integer identifier; this can then be used on the Go\n  // side to lookup the context in the context registry. We use slot 1 as slot 0\n  // has special meaning for the Chrome debugger.\n  Local<Context> local_ctx = Context::New(iso, nullptr, global_template);\n  local_ctx->SetEmbedderData(1, Integer::New(iso, ref));\n\n  m_ctx* ctx = new m_ctx;\n  ctx->ptr.Reset(iso, local_ctx);\n  ctx->iso = iso;\n  return ctx;\n}\n\nint ContextRetainedValueCount(ContextPtr ctx) {\n  return ctx->vals.size();\n}\n\nvoid ContextFree(ContextPtr ctx) {\n  if (ctx == nullptr) {\n    return;\n  }\n  ctx->ptr.Reset();\n\n  for (auto it = ctx->vals.begin(); it != ctx->vals.end(); ++it) {\n    auto value = it->second;\n    value->ptr.Reset();\n    delete value;\n  }\n  ctx->vals.clear();\n\n  for (m_unboundScript* us : ctx->unboundScripts) {\n    us->ptr.Reset();\n    delete us;\n  }\n\n  delete ctx;\n}\n\nRtnValue RunScript(ContextPtr ctx, const char* source, const char* origin) {\n  LOCAL_CONTEXT(ctx);\n\n  RtnValue rtn = {};\n\n  MaybeLocal<String> maybeSrc =\n      String::NewFromUtf8(iso, source, NewStringType::kNormal);\n  MaybeLocal<String> maybeOgn =\n      String::NewFromUtf8(iso, origin, NewStringType::kNormal);\n  Local<String> src, ogn;\n  if (!maybeSrc.ToLocal(&src) || !maybeOgn.ToLocal(&ogn)) {\n    rtn.error = ExceptionError(try_catch, iso, local_ctx);\n    return rtn;\n  }\n\n  ScriptOrigin script_origin(iso, ogn);\n  Local<Script> script;\n  if (!Script::Compile(local_ctx, src, &script_origin).ToLocal(&script)) {\n    rtn.error = ExceptionError(try_catch, iso, local_ctx);\n    return rtn;\n  }\n  Local<Value> result;\n  if (!script->Run(local_ctx).ToLocal(&result)) {\n    rtn.error = ExceptionError(try_catch, iso, local_ctx);\n    return rtn;\n  }\n  m_value* val = new m_value;\n  val->id = 0;\n  val->iso = iso;\n  val->ctx = ctx;\n  val->ptr = Persistent<Value, CopyablePersistentTraits<Value>>(iso, result);\n\n  rtn.value = tracked_value(ctx, val);\n  return rtn;\n}\n\n/********** UnboundScript & ScriptCompilerCachedData **********/\n\nScriptCompilerCachedData* UnboundScriptCreateCodeCache(\n    IsolatePtr iso,\n    UnboundScriptPtr us_ptr) {\n  ISOLATE_SCOPE(iso);\n\n  Local<UnboundScript> unbound_script = us_ptr->ptr.Get(iso);\n\n  ScriptCompiler::CachedData* cached_data =\n      ScriptCompiler::CreateCodeCache(unbound_script);\n\n  ScriptCompilerCachedData* cd = new ScriptCompilerCachedData;\n  cd->ptr = cached_data;\n  cd->data = cached_data->data;\n  cd->length = cached_data->length;\n  cd->rejected = cached_data->rejected;\n  return cd;\n}\n\nvoid ScriptCompilerCachedDataDelete(ScriptCompilerCachedData* cached_data) {\n  delete cached_data->ptr;\n  delete cached_data;\n}\n\n// This can only run in contexts that belong to the same isolate\n// the script was compiled in\nRtnValue UnboundScriptRun(ContextPtr ctx, UnboundScriptPtr us_ptr) {\n  LOCAL_CONTEXT(ctx)\n\n  RtnValue rtn = {};\n\n  Local<UnboundScript> unbound_script = us_ptr->ptr.Get(iso);\n\n  Local<Script> script = unbound_script->BindToCurrentContext();\n  Local<Value> result;\n  if (!script->Run(local_ctx).ToLocal(&result)) {\n    rtn.error = ExceptionError(try_catch, iso, local_ctx);\n    return rtn;\n  }\n  m_value* val = new m_value;\n  val->id = 0;\n  val->iso = iso;\n  val->ctx = ctx;\n  val->ptr = Persistent<Value, CopyablePersistentTraits<Value>>(iso, result);\n\n  rtn.value = tracked_value(ctx, val);\n  return rtn;\n}\n\nRtnValue JSONParse(ContextPtr ctx, const char* str) {\n  LOCAL_CONTEXT(ctx);\n  RtnValue rtn = {};\n\n  Local<String> v8Str;\n  if (!String::NewFromUtf8(iso, str, NewStringType::kNormal).ToLocal(&v8Str)) {\n    rtn.error = ExceptionError(try_catch, iso, local_ctx);\n  }\n\n  Local<Value> result;\n  if (!JSON::Parse(local_ctx, v8Str).ToLocal(&result)) {\n    rtn.error = ExceptionError(try_catch, iso, local_ctx);\n    return rtn;\n  }\n  m_value* val = new m_value;\n  val->id = 0;\n  val->iso = iso;\n  val->ctx = ctx;\n  val->ptr = Persistent<Value, CopyablePersistentTraits<Value>>(iso, result);\n\n  rtn.value = tracked_value(ctx, val);\n  return rtn;\n}\n\nconst char* JSONStringify(ContextPtr ctx, ValuePtr val) {\n  Isolate* iso;\n  Local<Context> local_ctx;\n\n  if (ctx != nullptr) {\n    iso = ctx->iso;\n  } else {\n    iso = val->iso;\n  }\n\n  Locker locker(iso);\n  Isolate::Scope isolate_scope(iso);\n  HandleScope handle_scope(iso);\n\n  if (ctx != nullptr) {\n    local_ctx = ctx->ptr.Get(iso);\n  } else {\n    if (val->ctx != nullptr) {\n      local_ctx = val->ctx->ptr.Get(iso);\n    } else {\n      m_ctx* ctx = isolateInternalContext(iso);\n      local_ctx = ctx->ptr.Get(iso);\n    }\n  }\n\n  Context::Scope context_scope(local_ctx);\n\n  Local<String> str;\n  if (!JSON::Stringify(local_ctx, val->ptr.Get(iso)).ToLocal(&str)) {\n    return nullptr;\n  }\n  String::Utf8Value json(iso, str);\n  return CopyString(json);\n}\n\nvoid ValueRelease(ValuePtr ptr) {\n  if (ptr == nullptr) {\n    return;\n  }\n\n  ptr->ctx->vals.erase(ptr->id);\n  ptr->ptr.Reset();\n  delete ptr;\n}\n\nValuePtr ContextGlobal(ContextPtr ctx) {\n  LOCAL_CONTEXT(ctx);\n  m_value* val = new m_value;\n  val->id = 0;\n\n  val->iso = iso;\n  val->ctx = ctx;\n  val->ptr = Persistent<Value, CopyablePersistentTraits<Value>>(\n      iso, local_ctx->Global());\n\n  return tracked_value(ctx, val);\n}\n\n/********** Value **********/\n\n#define LOCAL_VALUE(val)                   \\\n  Isolate* iso = val->iso;                 \\\n  Locker locker(iso);                      \\\n  Isolate::Scope isolate_scope(iso);       \\\n  HandleScope handle_scope(iso);           \\\n  TryCatch try_catch(iso);                 \\\n  m_ctx* ctx = val->ctx;                   \\\n  Local<Context> local_ctx;                \\\n  if (ctx != nullptr) {                    \\\n    local_ctx = ctx->ptr.Get(iso);         \\\n  } else {                                 \\\n    ctx = isolateInternalContext(iso);     \\\n    local_ctx = ctx->ptr.Get(iso);         \\\n  }                                        \\\n  Context::Scope context_scope(local_ctx); \\\n  Local<Value> value = val->ptr.Get(iso);\n\nValuePtr NewValueInteger(IsolatePtr iso, int32_t v) {\n  ISOLATE_SCOPE_INTERNAL_CONTEXT(iso);\n  m_value* val = new m_value;\n  val->id = 0;\n  val->iso = iso;\n  val->ctx = ctx;\n  val->ptr = Persistent<Value, CopyablePersistentTraits<Value>>(\n      iso, Integer::New(iso, v));\n  return tracked_value(ctx, val);\n}\n\nValuePtr NewValueIntegerFromUnsigned(IsolatePtr iso, uint32_t v) {\n  ISOLATE_SCOPE_INTERNAL_CONTEXT(iso);\n  m_value* val = new m_value;\n  val->id = 0;\n  val->iso = iso;\n  val->ctx = ctx;\n  val->ptr = Persistent<Value, CopyablePersistentTraits<Value>>(\n      iso, Integer::NewFromUnsigned(iso, v));\n  return tracked_value(ctx, val);\n}\n\nRtnValue NewValueString(IsolatePtr iso, const char* v, int v_length) {\n  ISOLATE_SCOPE_INTERNAL_CONTEXT(iso);\n  TryCatch try_catch(iso);\n  RtnValue rtn = {};\n  Local<String> str;\n  if (!String::NewFromUtf8(iso, v, NewStringType::kNormal, v_length)\n           .ToLocal(&str)) {\n    rtn.error = ExceptionError(try_catch, iso, ctx->ptr.Get(iso));\n    return rtn;\n  }\n  m_value* val = new m_value;\n  val->id = 0;\n  val->iso = iso;\n  val->ctx = ctx;\n  val->ptr = Persistent<Value, CopyablePersistentTraits<Value>>(iso, str);\n  rtn.value = tracked_value(ctx, val);\n  return rtn;\n}\n\nValuePtr NewValueNull(IsolatePtr iso) {\n  ISOLATE_SCOPE_INTERNAL_CONTEXT(iso);\n  m_value* val = new m_value;\n  val->id = 0;\n  val->iso = iso;\n  val->ctx = ctx;\n  val->ptr = Persistent<Value, CopyablePersistentTraits<Value>>(iso, Null(iso));\n  return tracked_value(ctx, val);\n}\n\nValuePtr NewValueUndefined(IsolatePtr iso) {\n  ISOLATE_SCOPE_INTERNAL_CONTEXT(iso);\n  m_value* val = new m_value;\n  val->id = 0;\n  val->iso = iso;\n  val->ctx = ctx;\n  val->ptr =\n      Persistent<Value, CopyablePersistentTraits<Value>>(iso, Undefined(iso));\n  return tracked_value(ctx, val);\n}\n\nValuePtr NewValueBoolean(IsolatePtr iso, int v) {\n  ISOLATE_SCOPE_INTERNAL_CONTEXT(iso);\n  m_value* val = new m_value;\n  val->id = 0;\n  val->iso = iso;\n  val->ctx = ctx;\n  val->ptr = Persistent<Value, CopyablePersistentTraits<Value>>(\n      iso, Boolean::New(iso, v));\n  return tracked_value(ctx, val);\n}\n\nValuePtr NewValueNumber(IsolatePtr iso, double v) {\n  ISOLATE_SCOPE_INTERNAL_CONTEXT(iso);\n  m_value* val = new m_value;\n  val->id = 0;\n  val->iso = iso;\n  val->ctx = ctx;\n  val->ptr = Persistent<Value, CopyablePersistentTraits<Value>>(\n      iso, Number::New(iso, v));\n  return tracked_value(ctx, val);\n}\n\nValuePtr NewValueBigInt(IsolatePtr iso, int64_t v) {\n  ISOLATE_SCOPE_INTERNAL_CONTEXT(iso);\n  m_value* val = new m_value;\n  val->id = 0;\n  val->iso = iso;\n  val->ctx = ctx;\n  val->ptr = Persistent<Value, CopyablePersistentTraits<Value>>(\n      iso, BigInt::New(iso, v));\n  return tracked_value(ctx, val);\n}\n\nValuePtr NewValueBigIntFromUnsigned(IsolatePtr iso, uint64_t v) {\n  ISOLATE_SCOPE_INTERNAL_CONTEXT(iso);\n  m_value* val = new m_value;\n  val->id = 0;\n  val->iso = iso;\n  val->ctx = ctx;\n  val->ptr = Persistent<Value, CopyablePersistentTraits<Value>>(\n      iso, BigInt::NewFromUnsigned(iso, v));\n  return tracked_value(ctx, val);\n}\n\nRtnValue NewValueBigIntFromWords(IsolatePtr iso,\n                                 int sign_bit,\n                                 int word_count,\n                                 const uint64_t* words) {\n  ISOLATE_SCOPE_INTERNAL_CONTEXT(iso);\n  TryCatch try_catch(iso);\n  Local<Context> local_ctx = ctx->ptr.Get(iso);\n\n  RtnValue rtn = {};\n  Local<BigInt> bigint;\n  if (!BigInt::NewFromWords(local_ctx, sign_bit, word_count, words)\n           .ToLocal(&bigint)) {\n    rtn.error = ExceptionError(try_catch, iso, local_ctx);\n    return rtn;\n  }\n  m_value* val = new m_value;\n  val->id = 0;\n  val->iso = iso;\n  val->ctx = ctx;\n  val->ptr = Persistent<Value, CopyablePersistentTraits<Value>>(iso, bigint);\n  rtn.value = tracked_value(ctx, val);\n  return rtn;\n}\n\nconst uint32_t* ValueToArrayIndex(ValuePtr ptr) {\n  LOCAL_VALUE(ptr);\n  Local<Uint32> array_index;\n  if (!value->ToArrayIndex(local_ctx).ToLocal(&array_index)) {\n    return nullptr;\n  }\n\n  uint32_t* idx = (uint32_t*)malloc(sizeof(uint32_t));\n  *idx = array_index->Value();\n  return idx;\n}\n\nint ValueToBoolean(ValuePtr ptr) {\n  LOCAL_VALUE(ptr);\n  return value->BooleanValue(iso);\n}\n\nint32_t ValueToInt32(ValuePtr ptr) {\n  LOCAL_VALUE(ptr);\n  return value->Int32Value(local_ctx).ToChecked();\n}\n\nint64_t ValueToInteger(ValuePtr ptr) {\n  LOCAL_VALUE(ptr);\n  return value->IntegerValue(local_ctx).ToChecked();\n}\n\ndouble ValueToNumber(ValuePtr ptr) {\n  LOCAL_VALUE(ptr);\n  return value->NumberValue(local_ctx).ToChecked();\n}\n\nRtnString ValueToDetailString(ValuePtr ptr) {\n  LOCAL_VALUE(ptr);\n  RtnString rtn = {0};\n  Local<String> str;\n  if (!value->ToDetailString(local_ctx).ToLocal(&str)) {\n    rtn.error = ExceptionError(try_catch, iso, local_ctx);\n    return rtn;\n  }\n  String::Utf8Value ds(iso, str);\n  rtn.data = CopyString(ds);\n  rtn.length = ds.length();\n  return rtn;\n}\n\nRtnString ValueToString(ValuePtr ptr) {\n  LOCAL_VALUE(ptr);\n  RtnString rtn = {0};\n  // String::Utf8Value will result in an empty string if conversion to a string\n  // fails\n  // TODO: Consider propagating the JS error. A fallback value could be returned\n  // in Value.String()\n  String::Utf8Value src(iso, value);\n  char* data = static_cast<char*>(malloc(src.length()));\n  memcpy(data, *src, src.length());\n  rtn.data = data;\n  rtn.length = src.length();\n  return rtn;\n}\n\nuint32_t ValueToUint32(ValuePtr ptr) {\n  LOCAL_VALUE(ptr);\n  return value->Uint32Value(local_ctx).ToChecked();\n}\n\nValueBigInt ValueToBigInt(ValuePtr ptr) {\n  LOCAL_VALUE(ptr);\n  Local<BigInt> bint;\n  if (!value->ToBigInt(local_ctx).ToLocal(&bint)) {\n    return {nullptr, 0};\n  }\n\n  int word_count = bint->WordCount();\n  int sign_bit = 0;\n  uint64_t* words = (uint64_t*)malloc(sizeof(uint64_t) * word_count);\n  bint->ToWordsArray(&sign_bit, &word_count, words);\n  ValueBigInt rtn = {words, word_count, sign_bit};\n  return rtn;\n}\n\nRtnValue ValueToObject(ValuePtr ptr) {\n  LOCAL_VALUE(ptr);\n  RtnValue rtn = {};\n  Local<Object> obj;\n  if (!value->ToObject(local_ctx).ToLocal(&obj)) {\n    rtn.error = ExceptionError(try_catch, iso, local_ctx);\n    return rtn;\n  }\n  m_value* new_val = new m_value;\n  new_val->id = 0;\n  new_val->iso = iso;\n  new_val->ctx = ctx;\n  new_val->ptr = Persistent<Value, CopyablePersistentTraits<Value>>(iso, obj);\n  rtn.value = tracked_value(ctx, new_val);\n  return rtn;\n}\n\nint ValueSameValue(ValuePtr val1, ValuePtr val2) {\n  Isolate* iso = val1->iso;\n  ISOLATE_SCOPE(iso);\n  Local<Value> value1 = val1->ptr.Get(iso);\n  Local<Value> value2 = val2->ptr.Get(iso);\n\n  return value1->SameValue(value2);\n}\n\nint ValueIsUndefined(ValuePtr ptr) {\n  LOCAL_VALUE(ptr);\n  return value->IsUndefined();\n}\n\nint ValueIsNull(ValuePtr ptr) {\n  LOCAL_VALUE(ptr);\n  return value->IsNull();\n}\n\nint ValueIsNullOrUndefined(ValuePtr ptr) {\n  LOCAL_VALUE(ptr);\n  return value->IsNullOrUndefined();\n}\n\nint ValueIsTrue(ValuePtr ptr) {\n  LOCAL_VALUE(ptr);\n  return value->IsTrue();\n}\n\nint ValueIsFalse(ValuePtr ptr) {\n  LOCAL_VALUE(ptr);\n  return value->IsFalse();\n}\n\nint ValueIsName(ValuePtr ptr) {\n  LOCAL_VALUE(ptr);\n  return value->IsName();\n}\n\nint ValueIsString(ValuePtr ptr) {\n  LOCAL_VALUE(ptr);\n  return value->IsString();\n}\n\nint ValueIsSymbol(ValuePtr ptr) {\n  LOCAL_VALUE(ptr);\n  return value->IsSymbol();\n}\n\nint ValueIsFunction(ValuePtr ptr) {\n  LOCAL_VALUE(ptr);\n  return value->IsFunction();\n}\n\nint ValueIsObject(ValuePtr ptr) {\n  LOCAL_VALUE(ptr);\n  return value->IsObject();\n}\n\nint ValueIsBigInt(ValuePtr ptr) {\n  LOCAL_VALUE(ptr);\n  return value->IsBigInt();\n}\n\nint ValueIsBoolean(ValuePtr ptr) {\n  LOCAL_VALUE(ptr);\n  return value->IsBoolean();\n}\n\nint ValueIsNumber(ValuePtr ptr) {\n  LOCAL_VALUE(ptr);\n  return value->IsNumber();\n}\n\nint ValueIsExternal(ValuePtr ptr) {\n  LOCAL_VALUE(ptr);\n  return value->IsExternal();\n}\n\nint ValueIsInt32(ValuePtr ptr) {\n  LOCAL_VALUE(ptr);\n  return value->IsInt32();\n}\n\nint ValueIsUint32(ValuePtr ptr) {\n  LOCAL_VALUE(ptr);\n  return value->IsUint32();\n}\n\nint ValueIsDate(ValuePtr ptr) {\n  LOCAL_VALUE(ptr);\n  return value->IsDate();\n}\n\nint ValueIsArgumentsObject(ValuePtr ptr) {\n  LOCAL_VALUE(ptr);\n  return value->IsArgumentsObject();\n}\n\nint ValueIsBigIntObject(ValuePtr ptr) {\n  LOCAL_VALUE(ptr);\n  return value->IsBigIntObject();\n}\n\nint ValueIsNumberObject(ValuePtr ptr) {\n  LOCAL_VALUE(ptr);\n  return value->IsNumberObject();\n}\n\nint ValueIsStringObject(ValuePtr ptr) {\n  LOCAL_VALUE(ptr);\n  return value->IsStringObject();\n}\n\nint ValueIsSymbolObject(ValuePtr ptr) {\n  LOCAL_VALUE(ptr);\n  return value->IsSymbolObject();\n}\n\nint ValueIsNativeError(ValuePtr ptr) {\n  LOCAL_VALUE(ptr);\n  return value->IsNativeError();\n}\n\nint ValueIsRegExp(ValuePtr ptr) {\n  LOCAL_VALUE(ptr);\n  return value->IsRegExp();\n}\n\nint ValueIsAsyncFunction(ValuePtr ptr) {\n  LOCAL_VALUE(ptr);\n  return value->IsAsyncFunction();\n}\n\nint ValueIsGeneratorFunction(ValuePtr ptr) {\n  LOCAL_VALUE(ptr);\n  return value->IsGeneratorFunction();\n}\n\nint ValueIsGeneratorObject(ValuePtr ptr) {\n  LOCAL_VALUE(ptr);\n  return value->IsGeneratorObject();\n}\n\nint ValueIsPromise(ValuePtr ptr) {\n  LOCAL_VALUE(ptr);\n  return value->IsPromise();\n}\n\nint ValueIsMap(ValuePtr ptr) {\n  LOCAL_VALUE(ptr);\n  return value->IsMap();\n}\n\nint ValueIsSet(ValuePtr ptr) {\n  LOCAL_VALUE(ptr);\n  return value->IsSet();\n}\n\nint ValueIsMapIterator(ValuePtr ptr) {\n  LOCAL_VALUE(ptr);\n  return value->IsMapIterator();\n}\n\nint ValueIsSetIterator(ValuePtr ptr) {\n  LOCAL_VALUE(ptr);\n  return value->IsSetIterator();\n}\n\nint ValueIsWeakMap(ValuePtr ptr) {\n  LOCAL_VALUE(ptr);\n  return value->IsWeakMap();\n}\n\nint ValueIsWeakSet(ValuePtr ptr) {\n  LOCAL_VALUE(ptr);\n  return value->IsWeakSet();\n}\n\nint ValueIsArray(ValuePtr ptr) {\n  LOCAL_VALUE(ptr);\n  return value->IsArray();\n}\n\nint ValueIsArrayBuffer(ValuePtr ptr) {\n  LOCAL_VALUE(ptr);\n  return value->IsArrayBuffer();\n}\n\nint ValueIsArrayBufferView(ValuePtr ptr) {\n  LOCAL_VALUE(ptr);\n  return value->IsArrayBufferView();\n}\n\nint ValueIsTypedArray(ValuePtr ptr) {\n  LOCAL_VALUE(ptr);\n  return value->IsTypedArray();\n}\n\nint ValueIsUint8Array(ValuePtr ptr) {\n  LOCAL_VALUE(ptr);\n  return value->IsUint8Array();\n}\n\nint ValueIsUint8ClampedArray(ValuePtr ptr) {\n  LOCAL_VALUE(ptr);\n  return value->IsUint8ClampedArray();\n}\n\nint ValueIsInt8Array(ValuePtr ptr) {\n  LOCAL_VALUE(ptr);\n  return value->IsInt8Array();\n}\n\nint ValueIsUint16Array(ValuePtr ptr) {\n  LOCAL_VALUE(ptr);\n  return value->IsUint16Array();\n}\n\nint ValueIsInt16Array(ValuePtr ptr) {\n  LOCAL_VALUE(ptr);\n  return value->IsInt16Array();\n}\n\nint ValueIsUint32Array(ValuePtr ptr) {\n  LOCAL_VALUE(ptr);\n  return value->IsUint32Array();\n}\n\nint ValueIsInt32Array(ValuePtr ptr) {\n  LOCAL_VALUE(ptr);\n  return value->IsInt32Array();\n}\n\nint ValueIsFloat32Array(ValuePtr ptr) {\n  LOCAL_VALUE(ptr);\n  return value->IsFloat32Array();\n}\n\nint ValueIsFloat64Array(ValuePtr ptr) {\n  LOCAL_VALUE(ptr);\n  return value->IsFloat64Array();\n}\n\nint ValueIsBigInt64Array(ValuePtr ptr) {\n  LOCAL_VALUE(ptr);\n  return value->IsBigInt64Array();\n}\n\nint ValueIsBigUint64Array(ValuePtr ptr) {\n  LOCAL_VALUE(ptr);\n  return value->IsBigUint64Array();\n}\n\nint ValueIsDataView(ValuePtr ptr) {\n  LOCAL_VALUE(ptr);\n  return value->IsDataView();\n}\n\nint ValueIsSharedArrayBuffer(ValuePtr ptr) {\n  LOCAL_VALUE(ptr);\n  return value->IsSharedArrayBuffer();\n}\n\nint ValueIsProxy(ValuePtr ptr) {\n  LOCAL_VALUE(ptr);\n  return value->IsProxy();\n}\n\nint ValueIsWasmModuleObject(ValuePtr ptr) {\n  LOCAL_VALUE(ptr);\n  return value->IsWasmModuleObject();\n}\n\nint ValueIsModuleNamespaceObject(ValuePtr ptr) {\n  LOCAL_VALUE(ptr);\n  return value->IsModuleNamespaceObject();\n}\n\n/********** Object **********/\n\n#define LOCAL_OBJECT(ptr) \\\n  LOCAL_VALUE(ptr)        \\\n  Local<Object> obj = value.As<Object>()\n\nvoid ObjectSet(ValuePtr ptr, const char* key, ValuePtr prop_val) {\n  LOCAL_OBJECT(ptr);\n  Local<String> key_val =\n      String::NewFromUtf8(iso, key, NewStringType::kNormal).ToLocalChecked();\n  obj->Set(local_ctx, key_val, prop_val->ptr.Get(iso)).Check();\n}\n\nvoid ObjectSetIdx(ValuePtr ptr, uint32_t idx, ValuePtr prop_val) {\n  LOCAL_OBJECT(ptr);\n  obj->Set(local_ctx, idx, prop_val->ptr.Get(iso)).Check();\n}\n\nint ObjectSetInternalField(ValuePtr ptr, int idx, ValuePtr val_ptr) {\n  LOCAL_OBJECT(ptr);\n  m_value* prop_val = static_cast<m_value*>(val_ptr);\n\n  if (idx >= obj->InternalFieldCount()) {\n    return 0;\n  }\n\n  obj->SetInternalField(idx, prop_val->ptr.Get(iso));\n\n  return 1;\n}\n\nint ObjectInternalFieldCount(ValuePtr ptr) {\n  LOCAL_OBJECT(ptr);\n  return obj->InternalFieldCount();\n}\n\nRtnValue ObjectGet(ValuePtr ptr, const char* key) {\n  LOCAL_OBJECT(ptr);\n  RtnValue rtn = {};\n\n  Local<String> key_val;\n  if (!String::NewFromUtf8(iso, key, NewStringType::kNormal)\n           .ToLocal(&key_val)) {\n    rtn.error = ExceptionError(try_catch, iso, local_ctx);\n    return rtn;\n  }\n  Local<Value> result;\n  if (!obj->Get(local_ctx, key_val).ToLocal(&result)) {\n    rtn.error = ExceptionError(try_catch, iso, local_ctx);\n    return rtn;\n  }\n  m_value* new_val = new m_value;\n  new_val->id = 0;\n  new_val->iso = iso;\n  new_val->ctx = ctx;\n  new_val->ptr =\n      Persistent<Value, CopyablePersistentTraits<Value>>(iso, result);\n\n  rtn.value = tracked_value(ctx, new_val);\n  return rtn;\n}\n\nValuePtr ObjectGetInternalField(ValuePtr ptr, int idx) {\n  LOCAL_OBJECT(ptr);\n\n  if (idx >= obj->InternalFieldCount()) {\n    return nullptr;\n  }\n\n  Local<Value> result = obj->GetInternalField(idx);\n\n  m_value* new_val = new m_value;\n  new_val->id = 0;\n  new_val->iso = iso;\n  new_val->ctx = ctx;\n  new_val->ptr =\n      Persistent<Value, CopyablePersistentTraits<Value>>(iso, result);\n\n  return tracked_value(ctx, new_val);\n}\n\nRtnValue ObjectGetIdx(ValuePtr ptr, uint32_t idx) {\n  LOCAL_OBJECT(ptr);\n  RtnValue rtn = {};\n\n  Local<Value> result;\n  if (!obj->Get(local_ctx, idx).ToLocal(&result)) {\n    rtn.error = ExceptionError(try_catch, iso, local_ctx);\n    return rtn;\n  }\n  m_value* new_val = new m_value;\n  new_val->id = 0;\n  new_val->iso = iso;\n  new_val->ctx = ctx;\n  new_val->ptr =\n      Persistent<Value, CopyablePersistentTraits<Value>>(iso, result);\n\n  rtn.value = tracked_value(ctx, new_val);\n  return rtn;\n}\n\nint ObjectHas(ValuePtr ptr, const char* key) {\n  LOCAL_OBJECT(ptr);\n  Local<String> key_val =\n      String::NewFromUtf8(iso, key, NewStringType::kNormal).ToLocalChecked();\n  return obj->Has(local_ctx, key_val).ToChecked();\n}\n\nint ObjectHasIdx(ValuePtr ptr, uint32_t idx) {\n  LOCAL_OBJECT(ptr);\n  return obj->Has(local_ctx, idx).ToChecked();\n}\n\nint ObjectDelete(ValuePtr ptr, const char* key) {\n  LOCAL_OBJECT(ptr);\n  Local<String> key_val =\n      String::NewFromUtf8(iso, key, NewStringType::kNormal).ToLocalChecked();\n  return obj->Delete(local_ctx, key_val).ToChecked();\n}\n\nint ObjectDeleteIdx(ValuePtr ptr, uint32_t idx) {\n  LOCAL_OBJECT(ptr);\n  return obj->Delete(local_ctx, idx).ToChecked();\n}\n\n/********** Promise **********/\n\nRtnValue NewPromiseResolver(ContextPtr ctx) {\n  LOCAL_CONTEXT(ctx);\n  RtnValue rtn = {};\n  Local<Promise::Resolver> resolver;\n  if (!Promise::Resolver::New(local_ctx).ToLocal(&resolver)) {\n    rtn.error = ExceptionError(try_catch, iso, local_ctx);\n    return rtn;\n  }\n  m_value* val = new m_value;\n  val->id = 0;\n  val->iso = iso;\n  val->ctx = ctx;\n  val->ptr = Persistent<Value, CopyablePersistentTraits<Value>>(iso, resolver);\n  rtn.value = tracked_value(ctx, val);\n  return rtn;\n}\n\nValuePtr PromiseResolverGetPromise(ValuePtr ptr) {\n  LOCAL_VALUE(ptr);\n  Local<Promise::Resolver> resolver = value.As<Promise::Resolver>();\n  Local<Promise> promise = resolver->GetPromise();\n  m_value* promise_val = new m_value;\n  promise_val->id = 0;\n  promise_val->iso = iso;\n  promise_val->ctx = ctx;\n  promise_val->ptr =\n      Persistent<Value, CopyablePersistentTraits<Value>>(iso, promise);\n  return tracked_value(ctx, promise_val);\n}\n\nint PromiseResolverResolve(ValuePtr ptr, ValuePtr resolve_val) {\n  LOCAL_VALUE(ptr);\n  Local<Promise::Resolver> resolver = value.As<Promise::Resolver>();\n  return resolver->Resolve(local_ctx, resolve_val->ptr.Get(iso)).ToChecked();\n}\n\nint PromiseResolverReject(ValuePtr ptr, ValuePtr reject_val) {\n  LOCAL_VALUE(ptr);\n  Local<Promise::Resolver> resolver = value.As<Promise::Resolver>();\n  return resolver->Reject(local_ctx, reject_val->ptr.Get(iso)).ToChecked();\n}\n\nint PromiseState(ValuePtr ptr) {\n  LOCAL_VALUE(ptr)\n  Local<Promise> promise = value.As<Promise>();\n  return promise->State();\n}\n\nRtnValue PromiseThen(ValuePtr ptr, int callback_ref) {\n  LOCAL_VALUE(ptr)\n  RtnValue rtn = {};\n  Local<Promise> promise = value.As<Promise>();\n  Local<Integer> cbData = Integer::New(iso, callback_ref);\n  Local<Function> func;\n  if (!Function::New(local_ctx, FunctionTemplateCallback, cbData)\n           .ToLocal(&func)) {\n    rtn.error = ExceptionError(try_catch, iso, local_ctx);\n    return rtn;\n  }\n  Local<Promise> result;\n  if (!promise->Then(local_ctx, func).ToLocal(&result)) {\n    rtn.error = ExceptionError(try_catch, iso, local_ctx);\n    return rtn;\n  }\n  m_value* result_val = new m_value;\n  result_val->id = 0;\n  result_val->iso = iso;\n  result_val->ctx = ctx;\n  result_val->ptr =\n      Persistent<Value, CopyablePersistentTraits<Value>>(iso, result);\n  rtn.value = tracked_value(ctx, result_val);\n  return rtn;\n}\n\nRtnValue PromiseThen2(ValuePtr ptr, int on_fulfilled_ref, int on_rejected_ref) {\n  LOCAL_VALUE(ptr)\n  RtnValue rtn = {};\n  Local<Promise> promise = value.As<Promise>();\n  Local<Integer> onFulfilledData = Integer::New(iso, on_fulfilled_ref);\n  Local<Function> onFulfilledFunc;\n  if (!Function::New(local_ctx, FunctionTemplateCallback, onFulfilledData)\n           .ToLocal(&onFulfilledFunc)) {\n    rtn.error = ExceptionError(try_catch, iso, local_ctx);\n    return rtn;\n  }\n  Local<Integer> onRejectedData = Integer::New(iso, on_rejected_ref);\n  Local<Function> onRejectedFunc;\n  if (!Function::New(local_ctx, FunctionTemplateCallback, onRejectedData)\n           .ToLocal(&onRejectedFunc)) {\n    rtn.error = ExceptionError(try_catch, iso, local_ctx);\n    return rtn;\n  }\n  Local<Promise> result;\n  if (!promise->Then(local_ctx, onFulfilledFunc, onRejectedFunc)\n           .ToLocal(&result)) {\n    rtn.error = ExceptionError(try_catch, iso, local_ctx);\n    return rtn;\n  }\n  m_value* result_val = new m_value;\n  result_val->id = 0;\n  result_val->iso = iso;\n  result_val->ctx = ctx;\n  result_val->ptr =\n      Persistent<Value, CopyablePersistentTraits<Value>>(iso, result);\n  rtn.value = tracked_value(ctx, result_val);\n  return rtn;\n}\n\nRtnValue PromiseCatch(ValuePtr ptr, int callback_ref) {\n  LOCAL_VALUE(ptr)\n  RtnValue rtn = {};\n  Local<Promise> promise = value.As<Promise>();\n  Local<Integer> cbData = Integer::New(iso, callback_ref);\n  Local<Function> func;\n  if (!Function::New(local_ctx, FunctionTemplateCallback, cbData)\n           .ToLocal(&func)) {\n    rtn.error = ExceptionError(try_catch, iso, local_ctx);\n    return rtn;\n  }\n  Local<Promise> result;\n  if (!promise->Catch(local_ctx, func).ToLocal(&result)) {\n    rtn.error = ExceptionError(try_catch, iso, local_ctx);\n    return rtn;\n  }\n  m_value* result_val = new m_value;\n  result_val->id = 0;\n  result_val->iso = iso;\n  result_val->ctx = ctx;\n  result_val->ptr =\n      Persistent<Value, CopyablePersistentTraits<Value>>(iso, result);\n  rtn.value = tracked_value(ctx, result_val);\n  return rtn;\n}\n\nValuePtr PromiseResult(ValuePtr ptr) {\n  LOCAL_VALUE(ptr)\n  Local<Promise> promise = value.As<Promise>();\n  Local<Value> result = promise->Result();\n  m_value* result_val = new m_value;\n  result_val->id = 0;\n  result_val->iso = iso;\n  result_val->ctx = ctx;\n  result_val->ptr =\n      Persistent<Value, CopyablePersistentTraits<Value>>(iso, result);\n  return tracked_value(ctx, result_val);\n}\n\n/********** Function **********/\n\nstatic void buildCallArguments(Isolate* iso,\n                               Local<Value>* argv,\n                               int argc,\n                               ValuePtr args[]) {\n  for (int i = 0; i < argc; i++) {\n    argv[i] = args[i]->ptr.Get(iso);\n  }\n}\n\nRtnValue FunctionCall(ValuePtr ptr, ValuePtr recv, int argc, ValuePtr args[]) {\n  LOCAL_VALUE(ptr)\n\n  RtnValue rtn = {};\n  Local<Function> fn = Local<Function>::Cast(value);\n  Local<Value> argv[argc];\n  buildCallArguments(iso, argv, argc, args);\n\n  Local<Value> local_recv = recv->ptr.Get(iso);\n\n  Local<Value> result;\n  if (!fn->Call(local_ctx, local_recv, argc, argv).ToLocal(&result)) {\n    rtn.error = ExceptionError(try_catch, iso, local_ctx);\n    return rtn;\n  }\n  m_value* rtnval = new m_value;\n  rtnval->id = 0;\n  rtnval->iso = iso;\n  rtnval->ctx = ctx;\n  rtnval->ptr = Persistent<Value, CopyablePersistentTraits<Value>>(iso, result);\n  rtn.value = tracked_value(ctx, rtnval);\n  return rtn;\n}\n\nRtnValue FunctionNewInstance(ValuePtr ptr, int argc, ValuePtr args[]) {\n  LOCAL_VALUE(ptr)\n  RtnValue rtn = {};\n  Local<Function> fn = Local<Function>::Cast(value);\n  Local<Value> argv[argc];\n  buildCallArguments(iso, argv, argc, args);\n  Local<Object> result;\n  if (!fn->NewInstance(local_ctx, argc, argv).ToLocal(&result)) {\n    rtn.error = ExceptionError(try_catch, iso, local_ctx);\n    return rtn;\n  }\n  m_value* rtnval = new m_value;\n  rtnval->id = 0;\n  rtnval->iso = iso;\n  rtnval->ctx = ctx;\n  rtnval->ptr = Persistent<Value, CopyablePersistentTraits<Value>>(iso, result);\n  rtn.value = tracked_value(ctx, rtnval);\n  return rtn;\n}\n\nValuePtr FunctionSourceMapUrl(ValuePtr ptr) {\n  LOCAL_VALUE(ptr)\n  Local<Function> fn = Local<Function>::Cast(value);\n  Local<Value> result = fn->GetScriptOrigin().SourceMapUrl();\n  m_value* rtnval = new m_value;\n  rtnval->id = 0;\n  rtnval->iso = iso;\n  rtnval->ctx = ctx;\n  rtnval->ptr = Persistent<Value, CopyablePersistentTraits<Value>>(iso, result);\n  return tracked_value(ctx, rtnval);\n}\n\n/********** v8::V8 **********/\n\nconst char* Version() {\n  return V8::GetVersion();\n}\n\nvoid SetFlags(const char* flags) {\n  V8::SetFlagsFromString(flags);\n}\n\n/********** SharedArrayBuffer & BackingStore ***********/\n\nstruct v8BackingStore {\n  v8BackingStore(std::shared_ptr<v8::BackingStore>&& ptr)\n      : backing_store{ptr} {}\n  std::shared_ptr<v8::BackingStore> backing_store;\n};\n\nBackingStorePtr SharedArrayBufferGetBackingStore(ValuePtr ptr) {\n  LOCAL_VALUE(ptr);\n  auto buffer = Local<SharedArrayBuffer>::Cast(value);\n  auto backing_store = buffer->GetBackingStore();\n  auto proxy = new v8BackingStore(std::move(backing_store));\n  return proxy;\n}\n\nvoid BackingStoreRelease(BackingStorePtr ptr) {\n  if (ptr == nullptr) {\n    return;\n  }\n  ptr->backing_store.reset();\n  delete ptr;\n}\n\nvoid* BackingStoreData(BackingStorePtr ptr) {\n  if (ptr == nullptr) {\n    return nullptr;\n  }\n\n  return ptr->backing_store->Data();\n}\n\nsize_t BackingStoreByteLength(BackingStorePtr ptr) {\n  if (ptr == nullptr) {\n    return 0;\n  }\n  return ptr->backing_store->ByteLength();\n}\n}\n"
        },
        {
          "name": "v8go.go",
          "type": "blob",
          "size": 1.12890625,
          "content": "// Copyright 2019 Roger Chapman and the v8go contributors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\n/*\nPackage v8go provides an API to execute JavaScript.\n*/\npackage v8go\n\n// #include \"v8go.h\"\n// #include <stdlib.h>\nimport \"C\"\nimport (\n\t\"strings\"\n\t\"unsafe\"\n)\n\n// Version returns the version of the V8 Engine with the -v8go suffix\nfunc Version() string {\n\treturn C.GoString(C.Version())\n}\n\n// SetFlags sets flags for V8. For possible flags: https://github.com/v8/v8/blob/master/src/flags/flag-definitions.h\n// Flags are expected to be prefixed with `--`, for example: `--harmony`.\n// Flags can be reverted using the `--no` prefix equivalent, for example: `--use_strict` vs `--nouse_strict`.\n// Flags will affect all Isolates created, even after creation.\nfunc SetFlags(flags ...string) {\n\tcflags := C.CString(strings.Join(flags, \" \"))\n\tC.SetFlags(cflags)\n\tC.free(unsafe.Pointer(cflags))\n}\n\nfunc initializeIfNecessary() {\n\tv8once.Do(func() {\n\t\tcflags := C.CString(\"--no-freeze_flags_after_init\")\n\t\tdefer C.free(unsafe.Pointer(cflags))\n\t\tC.SetFlags(cflags)\n\t\tC.Init()\n\t})\n}\n"
        },
        {
          "name": "v8go.h",
          "type": "blob",
          "size": 11.041015625,
          "content": "// Copyright 2019 Roger Chapman and the v8go contributors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\n#ifndef V8GO_H\n#define V8GO_H\n#ifdef __cplusplus\n\n#include \"libplatform/libplatform.h\"\n#include \"v8-profiler.h\"\n#include \"v8.h\"\n\ntypedef v8::Isolate* IsolatePtr;\ntypedef v8::CpuProfiler* CpuProfilerPtr;\ntypedef v8::CpuProfile* CpuProfilePtr;\ntypedef const v8::CpuProfileNode* CpuProfileNodePtr;\ntypedef v8::ScriptCompiler::CachedData* ScriptCompilerCachedDataPtr;\n\nextern \"C\" {\n#else\n// Opaque to cgo, but useful to treat it as a pointer to a distinct type\ntypedef struct v8Isolate v8Isolate;\ntypedef v8Isolate* IsolatePtr;\n\ntypedef struct v8CpuProfiler v8CpuProfiler;\ntypedef v8CpuProfiler* CpuProfilerPtr;\n\ntypedef struct v8CpuProfile v8CpuProfile;\ntypedef v8CpuProfile* CpuProfilePtr;\n\ntypedef struct v8CpuProfileNode v8CpuProfileNode;\ntypedef const v8CpuProfileNode* CpuProfileNodePtr;\n\ntypedef struct v8ScriptCompilerCachedData v8ScriptCompilerCachedData;\ntypedef const v8ScriptCompilerCachedData* ScriptCompilerCachedDataPtr;\n#endif\n\n// Opaque to both C and C++\ntypedef struct v8BackingStore v8BackingStore;\ntypedef v8BackingStore* BackingStorePtr;\n\n#include <stddef.h>\n#include <stdint.h>\n\n// ScriptCompiler::CompileOptions values\nextern const int ScriptCompilerNoCompileOptions;\nextern const int ScriptCompilerConsumeCodeCache;\nextern const int ScriptCompilerEagerCompile;\n\ntypedef struct m_ctx m_ctx;\ntypedef struct m_value m_value;\ntypedef struct m_template m_template;\ntypedef struct m_unboundScript m_unboundScript;\n\ntypedef m_ctx* ContextPtr;\ntypedef m_value* ValuePtr;\ntypedef m_template* TemplatePtr;\ntypedef m_unboundScript* UnboundScriptPtr;\n\ntypedef struct {\n  const char* msg;\n  const char* location;\n  const char* stack;\n} RtnError;\n\ntypedef struct {\n  UnboundScriptPtr ptr;\n  int cachedDataRejected;\n  RtnError error;\n} RtnUnboundScript;\n\ntypedef struct {\n  ScriptCompilerCachedDataPtr ptr;\n  const uint8_t* data;\n  int length;\n  int rejected;\n} ScriptCompilerCachedData;\n\ntypedef struct {\n  ScriptCompilerCachedData cachedData;\n  int compileOption;\n} CompileOptions;\n\ntypedef struct {\n  CpuProfilerPtr ptr;\n  IsolatePtr iso;\n} CPUProfiler;\n\ntypedef struct CPUProfileNode {\n  CpuProfileNodePtr ptr;\n  unsigned nodeId;\n  int scriptId;\n  const char* scriptResourceName;\n  const char* functionName;\n  int lineNumber;\n  int columnNumber;\n  unsigned hitCount;\n  const char* bailoutReason;\n  int childrenCount;\n  struct CPUProfileNode** children;\n} CPUProfileNode;\n\ntypedef struct {\n  CpuProfilePtr ptr;\n  const char* title;\n  CPUProfileNode* root;\n  int64_t startTime;\n  int64_t endTime;\n} CPUProfile;\n\ntypedef struct {\n  ValuePtr value;\n  RtnError error;\n} RtnValue;\n\ntypedef struct {\n  const char* data;\n  int length;\n  RtnError error;\n} RtnString;\n\ntypedef struct {\n  size_t total_heap_size;\n  size_t total_heap_size_executable;\n  size_t total_physical_size;\n  size_t total_available_size;\n  size_t used_heap_size;\n  size_t heap_size_limit;\n  size_t malloced_memory;\n  size_t external_memory;\n  size_t peak_malloced_memory;\n  size_t number_of_native_contexts;\n  size_t number_of_detached_contexts;\n} IsolateHStatistics;\n\ntypedef struct {\n  const uint64_t* word_array;\n  int word_count;\n  int sign_bit;\n} ValueBigInt;\n\nextern void Init();\nextern IsolatePtr NewIsolate();\nextern void IsolatePerformMicrotaskCheckpoint(IsolatePtr ptr);\nextern void IsolateDispose(IsolatePtr ptr);\nextern void IsolateTerminateExecution(IsolatePtr ptr);\nextern int IsolateIsExecutionTerminating(IsolatePtr ptr);\nextern IsolateHStatistics IsolationGetHeapStatistics(IsolatePtr ptr);\n\nextern ValuePtr IsolateThrowException(IsolatePtr iso, ValuePtr value);\n\nextern RtnUnboundScript IsolateCompileUnboundScript(IsolatePtr iso_ptr,\n                                                    const char* source,\n                                                    const char* origin,\n                                                    CompileOptions options);\nextern ScriptCompilerCachedData* UnboundScriptCreateCodeCache(\n    IsolatePtr iso_ptr,\n    UnboundScriptPtr us_ptr);\nextern void ScriptCompilerCachedDataDelete(\n    ScriptCompilerCachedData* cached_data);\nextern RtnValue UnboundScriptRun(ContextPtr ctx_ptr, UnboundScriptPtr us_ptr);\n\nextern CPUProfiler* NewCPUProfiler(IsolatePtr iso_ptr);\nextern void CPUProfilerDispose(CPUProfiler* ptr);\nextern void CPUProfilerStartProfiling(CPUProfiler* ptr, const char* title);\nextern CPUProfile* CPUProfilerStopProfiling(CPUProfiler* ptr,\n                                            const char* title);\nextern void CPUProfileDelete(CPUProfile* ptr);\n\nextern ContextPtr NewContext(IsolatePtr iso_ptr,\n                             TemplatePtr global_template_ptr,\n                             int ref);\nextern int ContextRetainedValueCount(ContextPtr ctx);\nextern void ContextFree(ContextPtr ptr);\nextern RtnValue RunScript(ContextPtr ctx_ptr,\n                          const char* source,\n                          const char* origin);\nextern RtnValue JSONParse(ContextPtr ctx_ptr, const char* str);\nconst char* JSONStringify(ContextPtr ctx_ptr, ValuePtr val_ptr);\nextern ValuePtr ContextGlobal(ContextPtr ctx_ptr);\n\nextern void TemplateFreeWrapper(TemplatePtr ptr);\nextern void TemplateSetValue(TemplatePtr ptr,\n                             const char* name,\n                             ValuePtr val_ptr,\n                             int attributes);\nextern void TemplateSetTemplate(TemplatePtr ptr,\n                                const char* name,\n                                TemplatePtr obj_ptr,\n                                int attributes);\n\nextern TemplatePtr NewObjectTemplate(IsolatePtr iso_ptr);\nextern RtnValue ObjectTemplateNewInstance(TemplatePtr ptr, ContextPtr ctx_ptr);\nextern void ObjectTemplateSetInternalFieldCount(TemplatePtr ptr,\n                                                int field_count);\nextern int ObjectTemplateInternalFieldCount(TemplatePtr ptr);\n\nextern TemplatePtr NewFunctionTemplate(IsolatePtr iso_ptr, int callback_ref);\nextern RtnValue FunctionTemplateGetFunction(TemplatePtr ptr,\n                                            ContextPtr ctx_ptr);\n\nextern ValuePtr NewValueNull(IsolatePtr iso_ptr);\nextern ValuePtr NewValueUndefined(IsolatePtr iso_ptr);\nextern ValuePtr NewValueInteger(IsolatePtr iso_ptr, int32_t v);\nextern ValuePtr NewValueIntegerFromUnsigned(IsolatePtr iso_ptr, uint32_t v);\nextern RtnValue NewValueString(IsolatePtr iso_ptr, const char* v, int v_length);\nextern ValuePtr NewValueBoolean(IsolatePtr iso_ptr, int v);\nextern ValuePtr NewValueNumber(IsolatePtr iso_ptr, double v);\nextern ValuePtr NewValueBigInt(IsolatePtr iso_ptr, int64_t v);\nextern ValuePtr NewValueBigIntFromUnsigned(IsolatePtr iso_ptr, uint64_t v);\nextern RtnValue NewValueBigIntFromWords(IsolatePtr iso_ptr,\n                                        int sign_bit,\n                                        int word_count,\n                                        const uint64_t* words);\nvoid ValueRelease(ValuePtr ptr);\nextern RtnString ValueToString(ValuePtr ptr);\nconst uint32_t* ValueToArrayIndex(ValuePtr ptr);\nint ValueToBoolean(ValuePtr ptr);\nint32_t ValueToInt32(ValuePtr ptr);\nint64_t ValueToInteger(ValuePtr ptr);\ndouble ValueToNumber(ValuePtr ptr);\nRtnString ValueToDetailString(ValuePtr ptr);\nuint32_t ValueToUint32(ValuePtr ptr);\nextern ValueBigInt ValueToBigInt(ValuePtr ptr);\nextern RtnValue ValueToObject(ValuePtr ptr);\nint ValueSameValue(ValuePtr ptr, ValuePtr otherPtr);\nint ValueIsUndefined(ValuePtr ptr);\nint ValueIsNull(ValuePtr ptr);\nint ValueIsNullOrUndefined(ValuePtr ptr);\nint ValueIsTrue(ValuePtr ptr);\nint ValueIsFalse(ValuePtr ptr);\nint ValueIsName(ValuePtr ptr);\nint ValueIsString(ValuePtr ptr);\nint ValueIsSymbol(ValuePtr ptr);\nint ValueIsFunction(ValuePtr ptr);\nint ValueIsObject(ValuePtr ptr);\nint ValueIsBigInt(ValuePtr ptr);\nint ValueIsBoolean(ValuePtr ptr);\nint ValueIsNumber(ValuePtr ptr);\nint ValueIsExternal(ValuePtr ptr);\nint ValueIsInt32(ValuePtr ptr);\nint ValueIsUint32(ValuePtr ptr);\nint ValueIsDate(ValuePtr ptr);\nint ValueIsArgumentsObject(ValuePtr ptr);\nint ValueIsBigIntObject(ValuePtr ptr);\nint ValueIsNumberObject(ValuePtr ptr);\nint ValueIsStringObject(ValuePtr ptr);\nint ValueIsSymbolObject(ValuePtr ptr);\nint ValueIsNativeError(ValuePtr ptr);\nint ValueIsRegExp(ValuePtr ptr);\nint ValueIsAsyncFunction(ValuePtr ptr);\nint ValueIsGeneratorFunction(ValuePtr ptr);\nint ValueIsGeneratorObject(ValuePtr ptr);\nint ValueIsPromise(ValuePtr ptr);\nint ValueIsMap(ValuePtr ptr);\nint ValueIsSet(ValuePtr ptr);\nint ValueIsMapIterator(ValuePtr ptr);\nint ValueIsSetIterator(ValuePtr ptr);\nint ValueIsWeakMap(ValuePtr ptr);\nint ValueIsWeakSet(ValuePtr ptr);\nint ValueIsArray(ValuePtr ptr);\nint ValueIsArrayBuffer(ValuePtr ptr);\nint ValueIsArrayBufferView(ValuePtr ptr);\nint ValueIsTypedArray(ValuePtr ptr);\nint ValueIsUint8Array(ValuePtr ptr);\nint ValueIsUint8ClampedArray(ValuePtr ptr);\nint ValueIsInt8Array(ValuePtr ptr);\nint ValueIsUint16Array(ValuePtr ptr);\nint ValueIsInt16Array(ValuePtr ptr);\nint ValueIsUint32Array(ValuePtr ptr);\nint ValueIsInt32Array(ValuePtr ptr);\nint ValueIsFloat32Array(ValuePtr ptr);\nint ValueIsFloat64Array(ValuePtr ptr);\nint ValueIsBigInt64Array(ValuePtr ptr);\nint ValueIsBigUint64Array(ValuePtr ptr);\nint ValueIsDataView(ValuePtr ptr);\nint ValueIsSharedArrayBuffer(ValuePtr ptr);\nint ValueIsProxy(ValuePtr ptr);\nint ValueIsWasmModuleObject(ValuePtr ptr);\nint ValueIsModuleNamespaceObject(ValuePtr ptr);\n\nextern void ObjectSet(ValuePtr ptr, const char* key, ValuePtr val_ptr);\nextern void ObjectSetIdx(ValuePtr ptr, uint32_t idx, ValuePtr val_ptr);\nextern int ObjectSetInternalField(ValuePtr ptr, int idx, ValuePtr val_ptr);\nextern int ObjectInternalFieldCount(ValuePtr ptr);\nextern RtnValue ObjectGet(ValuePtr ptr, const char* key);\nextern RtnValue ObjectGetIdx(ValuePtr ptr, uint32_t idx);\nextern ValuePtr ObjectGetInternalField(ValuePtr ptr, int idx);\nint ObjectHas(ValuePtr ptr, const char* key);\nint ObjectHasIdx(ValuePtr ptr, uint32_t idx);\nint ObjectDelete(ValuePtr ptr, const char* key);\nint ObjectDeleteIdx(ValuePtr ptr, uint32_t idx);\n\nextern RtnValue NewPromiseResolver(ContextPtr ctx_ptr);\nextern ValuePtr PromiseResolverGetPromise(ValuePtr ptr);\nint PromiseResolverResolve(ValuePtr ptr, ValuePtr val_ptr);\nint PromiseResolverReject(ValuePtr ptr, ValuePtr val_ptr);\nint PromiseState(ValuePtr ptr);\nRtnValue PromiseThen(ValuePtr ptr, int callback_ref);\nRtnValue PromiseThen2(ValuePtr ptr, int on_fulfilled_ref, int on_rejected_ref);\nRtnValue PromiseCatch(ValuePtr ptr, int callback_ref);\nextern ValuePtr PromiseResult(ValuePtr ptr);\n\nextern RtnValue FunctionCall(ValuePtr ptr,\n                             ValuePtr recv,\n                             int argc,\n                             ValuePtr argv[]);\nRtnValue FunctionNewInstance(ValuePtr ptr, int argc, ValuePtr args[]);\nValuePtr FunctionSourceMapUrl(ValuePtr ptr);\n\nconst char* Version();\nextern void SetFlags(const char* flags);\n\nextern BackingStorePtr SharedArrayBufferGetBackingStore(ValuePtr ptr);\nextern void BackingStoreRelease(BackingStorePtr ptr);\nextern void* BackingStoreData(BackingStorePtr ptr);\nextern size_t BackingStoreByteLength(BackingStorePtr ptr);\n\n#ifdef __cplusplus\n}  // extern \"C\"\n#endif\n#endif  // V8GO_H\n"
        },
        {
          "name": "v8go_test.go",
          "type": "blob",
          "size": 0.9970703125,
          "content": "// Copyright 2019 Roger Chapman and the v8go contributors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\npackage v8go_test\n\nimport (\n\t\"regexp\"\n\t\"testing\"\n\n\tv8 \"rogchap.com/v8go\"\n)\n\nfunc TestVersion(t *testing.T) {\n\tt.Parallel()\n\trgx := regexp.MustCompile(`^\\d+\\.\\d+\\.\\d+\\.\\d+-v8go$`)\n\tv := v8.Version()\n\tif !rgx.MatchString(v) {\n\t\tt.Errorf(\"version string is in the incorrect format: %s\", v)\n\t}\n}\n\nfunc TestSetFlag(t *testing.T) {\n\tt.Parallel()\n\tctx := v8.NewContext()\n\tdefer ctx.Isolate().Dispose()\n\tdefer ctx.Close()\n\tif _, err := ctx.RunScript(\"a = 1\", \"default.js\"); err != nil {\n\t\tt.Errorf(\"expected <nil> error, but got: %v\", err)\n\t}\n\tv8.SetFlags(\"--use_strict\")\n\tif _, err := ctx.RunScript(\"b = 1\", \"use_strict.js\"); err == nil {\n\t\tt.Error(\"expected error but got <nil>\")\n\t}\n\tv8.SetFlags(\"--nouse_strict\")\n\tif _, err := ctx.RunScript(\"c = 1\", \"nouse_strict.js\"); err != nil {\n\t\tt.Errorf(\"expected <nil> error, but got: %v\", err)\n\t}\n}\n"
        },
        {
          "name": "value.go",
          "type": "blob",
          "size": 16.45703125,
          "content": "// Copyright 2019 Roger Chapman and the v8go contributors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\npackage v8go\n\n// #include <stdlib.h>\n// #include \"v8go.h\"\nimport \"C\"\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"math/big\"\n\t\"unsafe\"\n)\n\n// Value represents all Javascript values and objects\ntype Value struct {\n\tptr C.ValuePtr\n\tctx *Context\n}\n\n// Valuer is an interface that reperesents anything that extends from a Value\n// eg. Object, Array, Date etc\ntype Valuer interface {\n\tvalue() *Value\n}\n\nfunc (v *Value) value() *Value {\n\treturn v\n}\n\nfunc newValueNull(iso *Isolate) *Value {\n\treturn &Value{\n\t\tptr: C.NewValueNull(iso.ptr),\n\t}\n}\n\nfunc newValueUndefined(iso *Isolate) *Value {\n\treturn &Value{\n\t\tptr: C.NewValueUndefined(iso.ptr),\n\t}\n}\n\n// Undefined returns the `undefined` JS value\nfunc Undefined(iso *Isolate) *Value {\n\treturn iso.undefined\n}\n\n// Null returns the `null` JS value\nfunc Null(iso *Isolate) *Value {\n\treturn iso.null\n}\n\n// NewValue will create a primitive value. Supported values types to create are:\n//\n//\tstring -> V8::String\n//\tint32 -> V8::Integer\n//\tuint32 -> V8::Integer\n//\tint64 -> V8::BigInt\n//\tuint64 -> V8::BigInt\n//\tbool -> V8::Boolean\n//\t*big.Int -> V8::BigInt\nfunc NewValue(iso *Isolate, val interface{}) (*Value, error) {\n\tif iso == nil {\n\t\treturn nil, errors.New(\"v8go: failed to create new Value: Isolate cannot be <nil>\")\n\t}\n\n\tvar rtnVal *Value\n\n\tswitch v := val.(type) {\n\tcase string:\n\t\tcstr := C.CString(v)\n\t\tdefer C.free(unsafe.Pointer(cstr))\n\t\trtn := C.NewValueString(iso.ptr, cstr, C.int(len(v)))\n\t\treturn valueResult(nil, rtn)\n\tcase int32:\n\t\trtnVal = &Value{\n\t\t\tptr: C.NewValueInteger(iso.ptr, C.int(v)),\n\t\t}\n\tcase uint32:\n\t\trtnVal = &Value{\n\t\t\tptr: C.NewValueIntegerFromUnsigned(iso.ptr, C.uint(v)),\n\t\t}\n\tcase int64:\n\t\trtnVal = &Value{\n\t\t\tptr: C.NewValueBigInt(iso.ptr, C.int64_t(v)),\n\t\t}\n\tcase uint64:\n\t\trtnVal = &Value{\n\t\t\tptr: C.NewValueBigIntFromUnsigned(iso.ptr, C.uint64_t(v)),\n\t\t}\n\tcase bool:\n\t\tvar b int\n\t\tif v {\n\t\t\tb = 1\n\t\t}\n\t\trtnVal = &Value{\n\t\t\tptr: C.NewValueBoolean(iso.ptr, C.int(b)),\n\t\t}\n\tcase float64:\n\t\trtnVal = &Value{\n\t\t\tptr: C.NewValueNumber(iso.ptr, C.double(v)),\n\t\t}\n\tcase *big.Int:\n\t\tif v.IsInt64() {\n\t\t\trtnVal = &Value{\n\t\t\t\tptr: C.NewValueBigInt(iso.ptr, C.int64_t(v.Int64())),\n\t\t\t}\n\t\t\tbreak\n\t\t}\n\n\t\tif v.IsUint64() {\n\t\t\trtnVal = &Value{\n\t\t\t\tptr: C.NewValueBigIntFromUnsigned(iso.ptr, C.uint64_t(v.Uint64())),\n\t\t\t}\n\t\t\tbreak\n\t\t}\n\n\t\tvar sign, count int\n\t\tif v.Sign() == -1 {\n\t\t\tsign = 1\n\t\t}\n\t\tbits := v.Bits()\n\t\tcount = len(bits)\n\n\t\twords := make([]C.uint64_t, count, count)\n\t\tfor idx, word := range bits {\n\t\t\twords[idx] = C.uint64_t(word)\n\t\t}\n\n\t\trtn := C.NewValueBigIntFromWords(iso.ptr, C.int(sign), C.int(count), &words[0])\n\t\treturn valueResult(nil, rtn)\n\tdefault:\n\t\treturn nil, fmt.Errorf(\"v8go: unsupported value type `%T`\", v)\n\t}\n\n\treturn rtnVal, nil\n}\n\n// Format implements the fmt.Formatter interface to provide a custom formatter\n// primarily to output the detail string (for debugging) with `%+v` verb.\nfunc (v *Value) Format(s fmt.State, verb rune) {\n\tswitch verb {\n\tcase 'v':\n\t\tif s.Flag('+') {\n\t\t\tio.WriteString(s, v.DetailString())\n\t\t\treturn\n\t\t}\n\t\tfallthrough\n\tcase 's':\n\t\tio.WriteString(s, v.String())\n\tcase 'q':\n\t\tfmt.Fprintf(s, \"%q\", v.String())\n\t}\n}\n\n// ArrayIndex attempts to converts a string to an array index. Returns ok false if conversion fails.\nfunc (v *Value) ArrayIndex() (idx uint32, ok bool) {\n\tarrayIdx := C.ValueToArrayIndex(v.ptr)\n\tdefer C.free(unsafe.Pointer(arrayIdx))\n\tif arrayIdx == nil {\n\t\treturn 0, false\n\t}\n\treturn uint32(*arrayIdx), true\n}\n\n// BigInt perform the equivalent of `BigInt(value)` in JS.\nfunc (v *Value) BigInt() *big.Int {\n\tif v == nil {\n\t\treturn nil\n\t}\n\tbint := C.ValueToBigInt(v.ptr)\n\tdefer C.free(unsafe.Pointer(bint.word_array))\n\tif bint.word_array == nil {\n\t\treturn nil\n\t}\n\twords := (*[1 << 30]big.Word)(unsafe.Pointer(bint.word_array))[:bint.word_count:bint.word_count]\n\n\tabs := make([]big.Word, len(words))\n\tcopy(abs, words)\n\n\tb := &big.Int{}\n\tb.SetBits(abs)\n\n\tif bint.sign_bit == 1 {\n\t\tb.Neg(b)\n\t}\n\n\treturn b\n}\n\n// Boolean perform the equivalent of `Boolean(value)` in JS. This can never fail.\nfunc (v *Value) Boolean() bool {\n\treturn C.ValueToBoolean(v.ptr) != 0\n}\n\n// DetailString provide a string representation of this value usable for debugging.\nfunc (v *Value) DetailString() string {\n\trtn := C.ValueToDetailString(v.ptr)\n\tif rtn.data == nil {\n\t\terr := newJSError(rtn.error)\n\t\tpanic(err) // TODO: Return a fallback value\n\t}\n\tdefer C.free(unsafe.Pointer(rtn.data))\n\treturn C.GoStringN(rtn.data, rtn.length)\n}\n\n// Int32 perform the equivalent of `Number(value)` in JS and convert the result to a\n// signed 32-bit integer by performing the steps in https://tc39.es/ecma262/#sec-toint32.\nfunc (v *Value) Int32() int32 {\n\treturn int32(C.ValueToInt32(v.ptr))\n}\n\n// Integer perform the equivalent of `Number(value)` in JS and convert the result to an integer.\n// Negative values are rounded up, positive values are rounded down. NaN is converted to 0.\n// Infinite values yield undefined results.\nfunc (v *Value) Integer() int64 {\n\treturn int64(C.ValueToInteger(v.ptr))\n}\n\n// Number perform the equivalent of `Number(value)` in JS.\nfunc (v *Value) Number() float64 {\n\treturn float64(C.ValueToNumber(v.ptr))\n}\n\n// Object perform the equivalent of Object(value) in JS.\n// To just cast this value as an Object use AsObject() instead.\nfunc (v *Value) Object() *Object {\n\trtn := C.ValueToObject(v.ptr)\n\tobj, err := objectResult(v.ctx, rtn)\n\tif err != nil {\n\t\tpanic(err) // TODO: Return error\n\t}\n\treturn obj\n}\n\n// String perform the equivalent of `String(value)` in JS. Primitive values\n// are returned as-is, objects will return `[object Object]` and functions will\n// print their definition.\nfunc (v *Value) String() string {\n\ts := C.ValueToString(v.ptr)\n\tdefer C.free(unsafe.Pointer(s.data))\n\treturn C.GoStringN(s.data, C.int(s.length))\n}\n\n// Uint32 perform the equivalent of `Number(value)` in JS and convert the result to an\n// unsigned 32-bit integer by performing the steps in https://tc39.es/ecma262/#sec-touint32.\nfunc (v *Value) Uint32() uint32 {\n\treturn uint32(C.ValueToUint32(v.ptr))\n}\n\n// SameValue returns true if the other value is the same value.\n// This is equivalent to `Object.is(v, other)` in JS.\nfunc (v *Value) SameValue(other *Value) bool {\n\treturn C.ValueSameValue(v.ptr, other.ptr) != 0\n}\n\n// IsUndefined returns true if this value is the undefined value. See ECMA-262 4.3.10.\nfunc (v *Value) IsUndefined() bool {\n\treturn C.ValueIsUndefined(v.ptr) != 0\n}\n\n// IsNull returns true if this value is the null value. See ECMA-262 4.3.11.\nfunc (v *Value) IsNull() bool {\n\treturn C.ValueIsNull(v.ptr) != 0\n}\n\n// IsNullOrUndefined returns true if this value is either the null or the undefined value.\n// See ECMA-262 4.3.11. and 4.3.12\n// This is equivalent to `value == null` in JS.\nfunc (v *Value) IsNullOrUndefined() bool {\n\treturn C.ValueIsNullOrUndefined(v.ptr) != 0\n}\n\n// IsTrue returns true if this value is true.\n// This is not the same as `BooleanValue()`. The latter performs a conversion to boolean,\n// i.e. the result of `Boolean(value)` in JS, whereas this checks `value === true`.\nfunc (v *Value) IsTrue() bool {\n\treturn C.ValueIsTrue(v.ptr) != 0\n}\n\n// IsFalse returns true if this value is false.\n// This is not the same as `!BooleanValue()`. The latter performs a conversion to boolean,\n// i.e. the result of `!Boolean(value)` in JS, whereas this checks `value === false`.\nfunc (v *Value) IsFalse() bool {\n\treturn C.ValueIsFalse(v.ptr) != 0\n}\n\n// IsName returns true if this value is a symbol or a string.\n// This is equivalent to `typeof value === 'string' || typeof value === 'symbol'` in JS.\nfunc (v *Value) IsName() bool {\n\treturn C.ValueIsName(v.ptr) != 0\n}\n\n// IsString returns true if this value is an instance of the String type. See ECMA-262 8.4.\n// This is equivalent to `typeof value === 'string'` in JS.\nfunc (v *Value) IsString() bool {\n\treturn C.ValueIsString(v.ptr) != 0\n}\n\n// IsSymbol returns true if this value is a symbol.\n// This is equivalent to `typeof value === 'symbol'` in JS.\nfunc (v *Value) IsSymbol() bool {\n\treturn C.ValueIsSymbol(v.ptr) != 0\n}\n\n// IsFunction returns true if this value is a function.\n// This is equivalent to `typeof value === 'function'` in JS.\nfunc (v *Value) IsFunction() bool {\n\treturn C.ValueIsFunction(v.ptr) != 0\n}\n\n// IsObject returns true if this value is an object.\nfunc (v *Value) IsObject() bool {\n\treturn v.ctx != nil && C.ValueIsObject(v.ptr) != 0\n}\n\n// IsBigInt returns true if this value is a bigint.\n// This is equivalent to `typeof value === 'bigint'` in JS.\nfunc (v *Value) IsBigInt() bool {\n\treturn C.ValueIsBigInt(v.ptr) != 0\n}\n\n// IsBoolean returns true if this value is boolean.\n// This is equivalent to `typeof value === 'boolean'` in JS.\nfunc (v *Value) IsBoolean() bool {\n\treturn C.ValueIsBoolean(v.ptr) != 0\n}\n\n// IsNumber returns true if this value is a number.\n// This is equivalent to `typeof value === 'number'` in JS.\nfunc (v *Value) IsNumber() bool {\n\treturn C.ValueIsNumber(v.ptr) != 0\n}\n\n// IsExternal returns true if this value is an `External` object.\nfunc (v *Value) IsExternal() bool {\n\t// TODO(rogchap): requires test case\n\treturn v.ctx != nil && C.ValueIsExternal(v.ptr) != 0\n}\n\n// IsInt32 returns true if this value is a 32-bit signed integer.\nfunc (v *Value) IsInt32() bool {\n\treturn C.ValueIsInt32(v.ptr) != 0\n}\n\n// IsUint32 returns true if this value is a 32-bit unsigned integer.\nfunc (v *Value) IsUint32() bool {\n\treturn C.ValueIsUint32(v.ptr) != 0\n}\n\n// IsDate returns true if this value is a `Date`.\nfunc (v *Value) IsDate() bool {\n\treturn C.ValueIsDate(v.ptr) != 0\n}\n\n// IsArgumentsObject returns true if this value is an Arguments object.\nfunc (v *Value) IsArgumentsObject() bool {\n\treturn C.ValueIsArgumentsObject(v.ptr) != 0\n}\n\n// IsBigIntObject returns true if this value is a BigInt object.\nfunc (v *Value) IsBigIntObject() bool {\n\treturn C.ValueIsBigIntObject(v.ptr) != 0\n}\n\n// IsNumberObject returns true if this value is a `Number` object.\nfunc (v *Value) IsNumberObject() bool {\n\treturn C.ValueIsNumberObject(v.ptr) != 0\n}\n\n// IsStringObject returns true if this value is a `String` object.\nfunc (v *Value) IsStringObject() bool {\n\treturn C.ValueIsStringObject(v.ptr) != 0\n}\n\n// IsSymbolObject returns true if this value is a `Symbol` object.\nfunc (v *Value) IsSymbolObject() bool {\n\treturn C.ValueIsSymbolObject(v.ptr) != 0\n}\n\n// IsNativeError returns true if this value is a NativeError.\nfunc (v *Value) IsNativeError() bool {\n\treturn C.ValueIsNativeError(v.ptr) != 0\n}\n\n// IsRegExp returns true if this value is a `RegExp`.\nfunc (v *Value) IsRegExp() bool {\n\treturn C.ValueIsRegExp(v.ptr) != 0\n}\n\n// IsAsyncFunc returns true if this value is an async function.\nfunc (v *Value) IsAsyncFunction() bool {\n\treturn C.ValueIsAsyncFunction(v.ptr) != 0\n}\n\n// Is IsGeneratorFunc returns true if this value is a Generator function.\nfunc (v *Value) IsGeneratorFunction() bool {\n\treturn C.ValueIsGeneratorFunction(v.ptr) != 0\n}\n\n// IsGeneratorObject returns true if this value is a Generator object (iterator).\nfunc (v *Value) IsGeneratorObject() bool {\n\treturn C.ValueIsGeneratorObject(v.ptr) != 0\n}\n\n// IsPromise returns true if this value is a `Promise`.\nfunc (v *Value) IsPromise() bool {\n\treturn C.ValueIsPromise(v.ptr) != 0\n}\n\n// IsMap returns true if this value is a `Map`.\nfunc (v *Value) IsMap() bool {\n\treturn C.ValueIsMap(v.ptr) != 0\n}\n\n// IsSet returns true if this value is a `Set`.\nfunc (v *Value) IsSet() bool {\n\treturn C.ValueIsSet(v.ptr) != 0\n}\n\n// IsMapIterator returns true if this value is a `Map` Iterator.\nfunc (v *Value) IsMapIterator() bool {\n\treturn C.ValueIsMapIterator(v.ptr) != 0\n}\n\n// IsSetIterator returns true if this value is a `Set` Iterator.\nfunc (v *Value) IsSetIterator() bool {\n\treturn C.ValueIsSetIterator(v.ptr) != 0\n}\n\n// IsWeakMap returns true if this value is a `WeakMap`.\nfunc (v *Value) IsWeakMap() bool {\n\treturn C.ValueIsWeakMap(v.ptr) != 0\n}\n\n// IsWeakSet returns true if this value is a `WeakSet`.\nfunc (v *Value) IsWeakSet() bool {\n\treturn C.ValueIsWeakSet(v.ptr) != 0\n}\n\n// IsArray returns true if this value is an array.\n// Note that it will return false for a `Proxy` of an array.\nfunc (v *Value) IsArray() bool {\n\treturn C.ValueIsArray(v.ptr) != 0\n}\n\n// IsArrayBuffer returns true if this value is an `ArrayBuffer`.\nfunc (v *Value) IsArrayBuffer() bool {\n\treturn C.ValueIsArrayBuffer(v.ptr) != 0\n}\n\n// IsArrayBufferView returns true if this value is an `ArrayBufferView`.\nfunc (v *Value) IsArrayBufferView() bool {\n\treturn C.ValueIsArrayBufferView(v.ptr) != 0\n}\n\n// IsTypedArray returns true if this value is one of TypedArrays.\nfunc (v *Value) IsTypedArray() bool {\n\treturn C.ValueIsTypedArray(v.ptr) != 0\n}\n\n// IsUint8Array returns true if this value is an `Uint8Array`.\nfunc (v *Value) IsUint8Array() bool {\n\treturn C.ValueIsUint8Array(v.ptr) != 0\n}\n\n// IsUint8ClampedArray returns true if this value is an `Uint8ClampedArray`.\nfunc (v *Value) IsUint8ClampedArray() bool {\n\treturn C.ValueIsUint8ClampedArray(v.ptr) != 0\n}\n\n// IsInt8Array returns true if this value is an `Int8Array`.\nfunc (v *Value) IsInt8Array() bool {\n\treturn C.ValueIsInt8Array(v.ptr) != 0\n}\n\n// IsUint16Array returns true if this value is an `Uint16Array`.\nfunc (v *Value) IsUint16Array() bool {\n\treturn C.ValueIsUint16Array(v.ptr) != 0\n}\n\n// IsInt16Array returns true if this value is an `Int16Array`.\nfunc (v *Value) IsInt16Array() bool {\n\treturn C.ValueIsInt16Array(v.ptr) != 0\n}\n\n// IsUint32Array returns true if this value is an `Uint32Array`.\nfunc (v *Value) IsUint32Array() bool {\n\treturn C.ValueIsUint32Array(v.ptr) != 0\n}\n\n// IsInt32Array returns true if this value is an `Int32Array`.\nfunc (v *Value) IsInt32Array() bool {\n\treturn C.ValueIsInt32Array(v.ptr) != 0\n}\n\n// IsFloat32Array returns true if this value is a `Float32Array`.\nfunc (v *Value) IsFloat32Array() bool {\n\treturn C.ValueIsFloat32Array(v.ptr) != 0\n}\n\n// IsFloat64Array returns true if this value is a `Float64Array`.\nfunc (v *Value) IsFloat64Array() bool {\n\treturn C.ValueIsFloat64Array(v.ptr) != 0\n}\n\n// IsBigInt64Array returns true if this value is a `BigInt64Array`.\nfunc (v *Value) IsBigInt64Array() bool {\n\treturn C.ValueIsBigInt64Array(v.ptr) != 0\n}\n\n// IsBigUint64Array returns true if this value is a BigUint64Array`.\nfunc (v *Value) IsBigUint64Array() bool {\n\treturn C.ValueIsBigUint64Array(v.ptr) != 0\n}\n\n// IsDataView returns true if this value is a `DataView`.\nfunc (v *Value) IsDataView() bool {\n\treturn C.ValueIsDataView(v.ptr) != 0\n}\n\n// IsSharedArrayBuffer returns true if this value is a `SharedArrayBuffer`.\nfunc (v *Value) IsSharedArrayBuffer() bool {\n\treturn C.ValueIsSharedArrayBuffer(v.ptr) != 0\n}\n\n// IsProxy returns true if this value is a JavaScript `Proxy`.\nfunc (v *Value) IsProxy() bool {\n\treturn C.ValueIsProxy(v.ptr) != 0\n}\n\n// Release this value.  Using the value after calling this function will result in undefined behavior.\nfunc (v *Value) Release() {\n\tC.ValueRelease(v.ptr)\n}\n\n// IsWasmModuleObject returns true if this value is a `WasmModuleObject`.\nfunc (v *Value) IsWasmModuleObject() bool {\n\t// TODO(rogchap): requires test case\n\treturn C.ValueIsWasmModuleObject(v.ptr) != 0\n}\n\n// IsModuleNamespaceObject returns true if the value is a `Module` Namespace `Object`.\nfunc (v *Value) IsModuleNamespaceObject() bool {\n\t// TODO(rogchap): requires test case\n\treturn C.ValueIsModuleNamespaceObject(v.ptr) != 0\n}\n\n// AsObject will cast the value to the Object type. If the value is not an Object\n// then an error is returned. Use `value.Object()` to do the JS equivalent of `Object(value)`.\nfunc (v *Value) AsObject() (*Object, error) {\n\tif !v.IsObject() {\n\t\treturn nil, errors.New(\"v8go: value is not an Object\")\n\t}\n\n\treturn &Object{v}, nil\n}\n\nfunc (v *Value) AsPromise() (*Promise, error) {\n\tif !v.IsPromise() {\n\t\treturn nil, errors.New(\"v8go: value is not a Promise\")\n\t}\n\treturn &Promise{&Object{v}}, nil\n}\n\nfunc (v *Value) AsFunction() (*Function, error) {\n\tif !v.IsFunction() {\n\t\treturn nil, errors.New(\"v8go: value is not a Function\")\n\t}\n\treturn &Function{v}, nil\n}\n\n// MarshalJSON implements the json.Marshaler interface.\nfunc (v *Value) MarshalJSON() ([]byte, error) {\n\tjsonStr, err := JSONStringify(nil, v)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn []byte(jsonStr), nil\n}\n\nfunc (v *Value) SharedArrayBufferGetContents() ([]byte, func(), error) {\n\tif !v.IsSharedArrayBuffer() {\n\t\treturn nil, nil, errors.New(\"v8go: value is not a SharedArrayBuffer\")\n\t}\n\n\tbackingStore := C.SharedArrayBufferGetBackingStore(v.ptr)\n\trelease := func() {\n\t\tC.BackingStoreRelease(backingStore)\n\t}\n\n\tbyte_ptr := (*byte)(unsafe.Pointer(C.BackingStoreData(backingStore)))\n\tbyte_size := C.BackingStoreByteLength(backingStore)\n\tbyte_slice := unsafe.Slice(byte_ptr, byte_size)\n\n\treturn byte_slice, release, nil\n}\n"
        },
        {
          "name": "value_test.go",
          "type": "blob",
          "size": 18.501953125,
          "content": "// Copyright 2019 Roger Chapman and the v8go contributors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\npackage v8go_test\n\nimport (\n\t\"bytes\"\n\t\"fmt\"\n\t\"math\"\n\t\"math/big\"\n\t\"reflect\"\n\t\"runtime\"\n\t\"testing\"\n\n\tv8 \"rogchap.com/v8go\"\n)\n\nfunc TestValueNewBaseCases(t *testing.T) {\n\tt.Parallel()\n\tif _, err := v8.NewValue(nil, \"\"); err == nil {\n\t\tt.Error(\"expected error, but got <nil>\")\n\t}\n\tiso := v8.NewIsolate()\n\tdefer iso.Dispose()\n\tif _, err := v8.NewValue(iso, nil); err == nil {\n\t\tt.Error(\"expected error, but got <nil>\")\n\t}\n\tif _, err := v8.NewValue(iso, struct{}{}); err == nil {\n\t\tt.Error(\"expected error, but got <nil>\")\n\t}\n\n}\n\nfunc TestValueFormatting(t *testing.T) {\n\tt.Parallel()\n\tctx := v8.NewContext(nil)\n\tdefer ctx.Isolate().Dispose()\n\tdefer ctx.Close()\n\n\ttests := [...]struct {\n\t\tsource          string\n\t\tdefaultVerb     string\n\t\tdefaultVerbFlag string\n\t\tstringVerb      string\n\t\tquoteVerb       string\n\t}{\n\t\t{\"new Object()\", \"[object Object]\", \"#<Object>\", \"[object Object]\", `\"[object Object]\"`},\n\t}\n\n\tfor _, tt := range tests {\n\t\ttt := tt\n\t\tt.Run(tt.source, func(t *testing.T) {\n\t\t\tval, _ := ctx.RunScript(tt.source, \"test.js\")\n\t\t\tif s := fmt.Sprintf(\"%v\", val); s != tt.defaultVerb {\n\t\t\t\tt.Errorf(\"incorrect format for %%v: %s\", s)\n\t\t\t}\n\t\t\tif s := fmt.Sprintf(\"%+v\", val); s != tt.defaultVerbFlag {\n\t\t\t\tt.Errorf(\"incorrect format for %%+v: %s\", s)\n\t\t\t}\n\t\t\tif s := fmt.Sprintf(\"%s\", val); s != tt.stringVerb {\n\t\t\t\tt.Errorf(\"incorrect format for %%s: %s\", s)\n\t\t\t}\n\t\t\tif s := fmt.Sprintf(\"%q\", val); s != tt.quoteVerb {\n\t\t\t\tt.Errorf(\"incorrect format for %%q: %s\", s)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestValueString(t *testing.T) {\n\tt.Parallel()\n\tctx := v8.NewContext(nil)\n\tdefer ctx.Isolate().Dispose()\n\tdefer ctx.Close()\n\n\ttests := [...]struct {\n\t\tname   string\n\t\tsource string\n\t\tout    string\n\t}{\n\t\t{\"Number\", `13 * 2`, \"26\"},\n\t\t{\"String\", `\"string\"`, \"string\"},\n\t\t{\"String with null character and non-latin unicode\", `\"a\\x00Ω\"`, \"a\\x00Ω\"},\n\t\t{\"Object\", `let obj = {}; obj`, \"[object Object]\"},\n\t\t{\"Function\", `let fn = function(){}; fn`, \"function(){}\"},\n\t}\n\n\tfor _, tt := range tests {\n\t\ttt := tt\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tresult, _ := ctx.RunScript(tt.source, \"test.js\")\n\t\t\tstr := result.String()\n\t\t\tif str != tt.out {\n\t\t\t\tt.Errorf(\"unexpected result: expected %q, got %q\", tt.out, str)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestNewValue(t *testing.T) {\n\tt.Parallel()\n\tctx := v8.NewContext(nil)\n\tiso := ctx.Isolate()\n\tdefer iso.Dispose()\n\tdefer ctx.Close()\n\n\ttests := []struct {\n\t\tname      string\n\t\tinput     interface{}\n\t\tpredicate string\n\t}{\n\t\t{\"string\", \"s\\x00s\\x00\", `str => str === \"s\\x00s\\x00\"`},\n\t\t{\"int32\", int32(36), `int => int === 36`},\n\t\t{\"bool\", true, `b => b === true`},\n\t}\n\n\tfor _, tt := range tests {\n\t\ttt := tt\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tval, err := ctx.RunScript(tt.predicate, \"test.js\")\n\t\t\tif err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\t\t\tfn, err := val.AsFunction()\n\t\t\tif err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\n\t\t\tjsVal, err := v8.NewValue(iso, tt.input)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\n\t\t\tresult, err := fn.Call(ctx.Global(), jsVal)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\t\t\tif !result.Boolean() {\n\t\t\t\tt.Fatal(\"unexpected result: expected true, got false\")\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestValueDetailString(t *testing.T) {\n\tt.Parallel()\n\tctx := v8.NewContext(nil)\n\tdefer ctx.Isolate().Dispose()\n\tdefer ctx.Close()\n\n\ttests := [...]struct {\n\t\tname   string\n\t\tsource string\n\t\tout    string\n\t}{\n\t\t{\"Number\", `13 * 2`, \"26\"},\n\t\t{\"String\", `\"a string\"`, \"a string\"},\n\t\t{\"Object\", `let obj = {}; obj`, \"#<Object>\"},\n\t\t{\"Function\", `let fn = function(){}; fn`, \"function(){}\"},\n\t}\n\n\tfor _, tt := range tests {\n\t\ttt := tt\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tresult, _ := ctx.RunScript(tt.source, \"test.js\")\n\t\t\tstr := result.DetailString()\n\t\t\tif str != tt.out {\n\t\t\t\tt.Errorf(\"unexpected result: expected %q, got %q\", tt.out, str)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestValueBoolean(t *testing.T) {\n\tt.Parallel()\n\tctx := v8.NewContext(nil)\n\tdefer ctx.Isolate().Dispose()\n\tdefer ctx.Close()\n\n\ttests := [...]struct {\n\t\tsource string\n\t\tout    bool\n\t}{\n\t\t{\"true\", true},\n\t\t{\"false\", false},\n\t\t{\"1\", true},\n\t\t{\"0\", false},\n\t\t{\"null\", false},\n\t\t{\"undefined\", false},\n\t\t{\"''\", false},\n\t\t{\"'foo'\", true},\n\t\t{\"() => {}\", true},\n\t\t{\"{}\", false},\n\t\t{\"{foo:'bar'}\", true},\n\t}\n\n\tfor _, tt := range tests {\n\t\ttt := tt\n\t\tt.Run(tt.source, func(t *testing.T) {\n\t\t\tval, _ := ctx.RunScript(tt.source, \"test.js\")\n\t\t\tif b := val.Boolean(); b != tt.out {\n\t\t\t\tt.Errorf(\"unexpected value: expected %v, got %v\", tt.out, b)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestValueConstants(t *testing.T) {\n\tt.Parallel()\n\tiso := v8.NewIsolate()\n\tdefer iso.Dispose()\n\tctx := v8.NewContext(iso)\n\tdefer ctx.Close()\n\n\ttests := [...]struct {\n\t\tsource string\n\t\tvalue  *v8.Value\n\t\tsame   bool\n\t}{\n\t\t{\"undefined\", v8.Undefined(iso), true},\n\t\t{\"null\", v8.Null(iso), true},\n\t\t{\"undefined\", v8.Null(iso), false},\n\t}\n\n\tfor _, tt := range tests {\n\t\ttt := tt\n\n\t\tval, err := ctx.RunScript(tt.source, \"test.js\")\n\t\tfatalIf(t, err)\n\n\t\tif tt.value.SameValue(val) != tt.same {\n\t\t\tt.Errorf(\"SameValue on JS `%s` and V8 value %+v didn't return %v\",\n\t\t\t\ttt.source, tt.value, tt.same)\n\t\t}\n\t}\n}\n\nfunc TestValueArrayIndex(t *testing.T) {\n\tt.Parallel()\n\tctx := v8.NewContext(nil)\n\tdefer ctx.Isolate().Dispose()\n\tdefer ctx.Close()\n\n\ttests := [...]struct {\n\t\tsource string\n\t\tidx    uint32\n\t\tok     bool\n\t}{\n\t\t{\"1\", 1, true},\n\t\t{\"0\", 0, true},\n\t\t{\"-1\", 0, false},\n\t\t{\"'1'\", 1, true},\n\t\t{\"'-1'\", 0, false},\n\t\t{\"'a'\", 0, false},\n\t\t{\"[1]\", 1, true},\n\t\t{\"['1']\", 1, true},\n\t\t{\"[1, 1]\", 0, false},\n\t\t{\"{}\", 0, false},\n\t}\n\n\tfor _, tt := range tests {\n\t\ttt := tt\n\t\tt.Run(tt.source, func(t *testing.T) {\n\t\t\tval, _ := ctx.RunScript(tt.source, \"test.js\")\n\t\t\tidx, ok := val.ArrayIndex()\n\t\t\tif ok != tt.ok {\n\t\t\t\tt.Errorf(\"unexpected ok: expected %v, got %v\", tt.ok, ok)\n\t\t\t}\n\t\t\tif idx != tt.idx {\n\t\t\t\tt.Errorf(\"unexpected array index: expected %v, got %v\", tt.idx, idx)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestValueInt32(t *testing.T) {\n\tt.Parallel()\n\tctx := v8.NewContext(nil)\n\tdefer ctx.Isolate().Dispose()\n\tdefer ctx.Close()\n\n\ttests := [...]struct {\n\t\tsource   string\n\t\texpected int32\n\t}{\n\t\t{\"0\", 0},\n\t\t{\"1\", 1},\n\t\t{\"-1\", -1},\n\t\t{\"'1'\", 1},\n\t\t{\"1.5\", 1},\n\t\t{\"-1.5\", -1},\n\t\t{\"'a'\", 0},\n\t\t{\"[1]\", 1},\n\t\t{\"[1,1]\", 0},\n\t\t{\"Infinity\", 0},\n\t\t{\"Number.MAX_SAFE_INTEGER\", -1},\n\t\t{\"Number.MIN_SAFE_INTEGER\", 1},\n\t\t{\"Number.NaN\", 0},\n\t\t{\"2_147_483_647\", 1<<31 - 1},\n\t\t{\"-2_147_483_648\", -1 << 31},\n\t\t{\"2_147_483_648\", -1 << 31}, // overflow\n\t}\n\n\tfor _, tt := range tests {\n\t\ttt := tt\n\t\tt.Run(tt.source, func(t *testing.T) {\n\t\t\tval, _ := ctx.RunScript(tt.source, \"test.js\")\n\t\t\tif i32 := val.Int32(); i32 != tt.expected {\n\t\t\t\tt.Errorf(\"unexpected value: expected %v, got %v\", tt.expected, i32)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestValueInteger(t *testing.T) {\n\tt.Parallel()\n\tctx := v8.NewContext(nil)\n\tdefer ctx.Isolate().Dispose()\n\tdefer ctx.Close()\n\n\ttests := [...]struct {\n\t\tsource   string\n\t\texpected int64\n\t}{\n\t\t{\"0\", 0},\n\t\t{\"1\", 1},\n\t\t{\"-1\", -1},\n\t\t{\"'1'\", 1},\n\t\t{\"1.5\", 1},\n\t\t{\"-1.5\", -1},\n\t\t{\"'a'\", 0},\n\t\t{\"[1]\", 1},\n\t\t{\"[1,1]\", 0},\n\t\t{\"Infinity\", 1<<63 - 1},\n\t\t{\"Number.MAX_SAFE_INTEGER\", 1<<53 - 1},\n\t\t{\"Number.MIN_SAFE_INTEGER\", -(1<<53 - 1)},\n\t\t{\"Number.NaN\", 0},\n\t\t{\"9_007_199_254_740_991\", 1<<53 - 1},\n\t\t{\"-9_007_199_254_740_991\", -(1<<53 - 1)},\n\t\t{\"9_223_372_036_854_775_810\", 1<<63 - 1}, // does not overflow, pinned at 2^64 -1\n\t}\n\n\tfor _, tt := range tests {\n\t\ttt := tt\n\t\tt.Run(tt.source, func(t *testing.T) {\n\t\t\tval, _ := ctx.RunScript(tt.source, \"test.js\")\n\t\t\tif i64 := val.Integer(); i64 != tt.expected {\n\t\t\t\tt.Errorf(\"unexpected value: expected %v, got %v\", tt.expected, i64)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestValueNumber(t *testing.T) {\n\tt.Parallel()\n\tctx := v8.NewContext(nil)\n\tdefer ctx.Isolate().Dispose()\n\tdefer ctx.Close()\n\n\ttests := [...]struct {\n\t\tsource   string\n\t\texpected float64\n\t}{\n\t\t{\"0\", 0},\n\t\t{\"1\", 1},\n\t\t{\"-1\", -1},\n\t\t{\"'1'\", 1},\n\t\t{\"1.5\", 1.5},\n\t\t{\"-1.5\", -1.5},\n\t\t{\"'a'\", math.NaN()},\n\t\t{\"[1]\", 1},\n\t\t{\"[1,1]\", math.NaN()},\n\t\t{\"Infinity\", math.Inf(0)},\n\t\t{\"Number.MAX_VALUE\", 1.7976931348623157e+308},\n\t\t{\"Number.MIN_VALUE\", 5e-324},\n\t\t{\"Number.MAX_SAFE_INTEGER\", 1<<53 - 1},\n\t\t{\"Number.NaN\", math.NaN()},\n\t}\n\n\tfor _, tt := range tests {\n\t\ttt := tt\n\t\tt.Run(tt.source, func(t *testing.T) {\n\t\t\tval, _ := ctx.RunScript(tt.source, \"test.js\")\n\t\t\tf64 := val.Number()\n\t\t\tif math.IsNaN(tt.expected) {\n\t\t\t\tif !math.IsNaN(f64) {\n\t\t\t\t\tt.Errorf(\"unexpected value: expected NaN, got %v\", f64)\n\t\t\t\t}\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif f64 != tt.expected {\n\t\t\t\tt.Errorf(\"unexpected value: expected %v, got %v\", tt.expected, f64)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestValueUint32(t *testing.T) {\n\tt.Parallel()\n\tctx := v8.NewContext(nil)\n\tdefer ctx.Isolate().Dispose()\n\tdefer ctx.Close()\n\n\ttests := [...]struct {\n\t\tsource   string\n\t\texpected uint32\n\t}{\n\t\t{\"0\", 0},\n\t\t{\"1\", 1},\n\t\t{\"-1\", 1<<32 - 1}, // overflow\n\t}\n\n\tfor _, tt := range tests {\n\t\ttt := tt\n\t\tt.Run(tt.source, func(t *testing.T) {\n\t\t\tval, _ := ctx.RunScript(tt.source, \"test.js\")\n\t\t\tif u32 := val.Uint32(); u32 != tt.expected {\n\t\t\t\tt.Errorf(\"unexpected value: expected %v, got %v\", tt.expected, u32)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestValueBigInt(t *testing.T) {\n\tt.Parallel()\n\tiso := v8.NewIsolate()\n\tdefer iso.Dispose()\n\n\tx, _ := new(big.Int).SetString(\"36893488147419099136\", 10) // larger than a single word size (64bit)\n\n\ttests := [...]struct {\n\t\tsource   string\n\t\texpected *big.Int\n\t}{\n\t\t{\"BigInt(0)\", &big.Int{}},\n\t\t{\"-1n\", big.NewInt(-1)},\n\t\t{\"new BigInt(1)\", nil}, // bad syntax\n\t\t{\"BigInt(Number.MAX_SAFE_INTEGER)\", big.NewInt(1<<53 - 1)},\n\t\t{\"BigInt(Number.MIN_SAFE_INTEGER)\", new(big.Int).Neg(big.NewInt(1<<53 - 1))},\n\t\t{\"BigInt(Number.MAX_SAFE_INTEGER) * 2n\", big.NewInt(1<<54 - 2)},\n\t\t{\"BigInt(Number.MAX_SAFE_INTEGER) * 4096n\", x},\n\t}\n\n\tfor _, tt := range tests {\n\t\ttt := tt\n\t\tt.Run(tt.source, func(t *testing.T) {\n\t\t\tctx := v8.NewContext(iso)\n\t\t\tdefer ctx.Close()\n\n\t\t\tval, _ := ctx.RunScript(tt.source, \"test.js\")\n\t\t\tb := val.BigInt()\n\t\t\tif b == nil && tt.expected != nil {\n\t\t\t\tt.Errorf(\"uexpected <nil> value\")\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif b != nil && tt.expected == nil {\n\t\t\t\tt.Errorf(\"expected <nil>, but got value: %v\", b)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif b != nil && b.Cmp(tt.expected) != 0 {\n\t\t\t\tt.Errorf(\"unexpected value: expected %v, got %v\", tt.expected, b)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestValueObject(t *testing.T) {\n\tt.Parallel()\n\n\tctx := v8.NewContext()\n\tdefer ctx.Isolate().Dispose()\n\tdefer ctx.Close()\n\n\tval, _ := ctx.RunScript(\"1\", \"\")\n\tif _, err := val.AsObject(); err == nil {\n\t\tt.Error(\"Expected error but got <nil>\")\n\t}\n\tif obj := val.Object(); obj.String() != \"1\" {\n\t\tt.Errorf(\"unexpected object value: %v\", obj)\n\t}\n}\n\nfunc TestValuePromise(t *testing.T) {\n\tt.Parallel()\n\n\tctx := v8.NewContext()\n\tdefer ctx.Isolate().Dispose()\n\tdefer ctx.Close()\n\n\tval, _ := ctx.RunScript(\"1\", \"\")\n\tif _, err := val.AsPromise(); err == nil {\n\t\tt.Error(\"Expected error but got <nil>\")\n\t}\n\tif _, err := ctx.RunScript(\"new Promise(()=>{})\", \"\"); err != nil {\n\t\tt.Errorf(\"Unexpected error: %v\", err)\n\t}\n\n}\n\nfunc TestValueFunction(t *testing.T) {\n\tt.Parallel()\n\n\tctx := v8.NewContext()\n\tdefer ctx.Isolate().Dispose()\n\tdefer ctx.Close()\n\n\tval, _ := ctx.RunScript(\"1\", \"\")\n\tif _, err := val.AsFunction(); err == nil {\n\t\tt.Error(\"Expected error but got <nil>\")\n\t}\n\tval, err := ctx.RunScript(\"(a, b) => { return a + b; }\", \"\")\n\tif err != nil {\n\t\tt.Errorf(\"Unexpected error: %v\", err)\n\t}\n\tif _, err := val.AsFunction(); err != nil {\n\t\tt.Errorf(\"Expected success but got: %v\", err)\n\t}\n\n}\n\nfunc TestValueSameValue(t *testing.T) {\n\tt.Parallel()\n\tiso := v8.NewIsolate()\n\tdefer iso.Dispose()\n\tctx := v8.NewContext(iso)\n\tdefer ctx.Close()\n\n\tobjTempl := v8.NewObjectTemplate(iso)\n\tobj1, err := objTempl.NewInstance(ctx)\n\tfatalIf(t, err)\n\tobj2, err := objTempl.NewInstance(ctx)\n\tfatalIf(t, err)\n\n\tif obj1.Value.SameValue(obj2.Value) != false {\n\t\tt.Errorf(\"SameValue on two different values didn't return false\")\n\t}\n\tif obj1.Value.SameValue(obj1.Value) != true {\n\t\tt.Errorf(\"SameValue on two of the same value didn't return true\")\n\t}\n}\n\nfunc TestValueIsXXX(t *testing.T) {\n\tt.Parallel()\n\tiso := v8.NewIsolate()\n\tdefer iso.Dispose()\n\ttests := [...]struct {\n\t\tsource string\n\t\tassert func(*v8.Value) bool\n\t}{\n\t\t{\"\", (*v8.Value).IsUndefined},\n\t\t{\"let v; v\", (*v8.Value).IsUndefined},\n\t\t{\"null\", (*v8.Value).IsNull},\n\t\t{\"let v; v\", (*v8.Value).IsNullOrUndefined},\n\t\t{\"let v = null; v\", (*v8.Value).IsNullOrUndefined},\n\t\t{\"true\", (*v8.Value).IsTrue},\n\t\t{\"false\", (*v8.Value).IsFalse},\n\t\t{\"'name'\", (*v8.Value).IsName},\n\t\t{\"Symbol()\", (*v8.Value).IsName},\n\t\t{`\"double quote\"`, (*v8.Value).IsString},\n\t\t{\"'single quote'\", (*v8.Value).IsString},\n\t\t{\"`string literal`\", (*v8.Value).IsString},\n\t\t{\"Symbol()\", (*v8.Value).IsSymbol},\n\t\t{\"Symbol('foo')\", (*v8.Value).IsSymbol},\n\t\t{\"() => {}\", (*v8.Value).IsFunction},\n\t\t{\"function v() {}; v\", (*v8.Value).IsFunction},\n\t\t{\"const v = function() {}; v\", (*v8.Value).IsFunction},\n\t\t{\"console.log\", (*v8.Value).IsFunction},\n\t\t{\"Object\", (*v8.Value).IsFunction},\n\t\t{\"class Foo {}; Foo\", (*v8.Value).IsFunction},\n\t\t{\"class Foo { bar() {} }; (new Foo()).bar\", (*v8.Value).IsFunction},\n\t\t{\"function* v(){}; v\", (*v8.Value).IsFunction},\n\t\t{\"async function v(){}; v\", (*v8.Value).IsFunction},\n\t\t{\"Object()\", (*v8.Value).IsObject},\n\t\t{\"new Object\", (*v8.Value).IsObject},\n\t\t{\"var v = {}; v\", (*v8.Value).IsObject},\n\t\t{\"10n\", (*v8.Value).IsBigInt},\n\t\t{\"BigInt(1)\", (*v8.Value).IsBigInt},\n\t\t{\"true\", (*v8.Value).IsBoolean},\n\t\t{\"false\", (*v8.Value).IsBoolean},\n\t\t{\"Boolean()\", (*v8.Value).IsBoolean},\n\t\t{\"(new Boolean).valueOf()\", (*v8.Value).IsBoolean},\n\t\t{\"1\", (*v8.Value).IsNumber},\n\t\t{\"1.1\", (*v8.Value).IsNumber},\n\t\t{\"1_1\", (*v8.Value).IsNumber},\n\t\t{\".1\", (*v8.Value).IsNumber},\n\t\t{\"2e4\", (*v8.Value).IsNumber},\n\t\t{\"0x2\", (*v8.Value).IsNumber},\n\t\t{\"NaN\", (*v8.Value).IsNumber},\n\t\t{\"Infinity\", (*v8.Value).IsNumber},\n\t\t{\"Number(1)\", (*v8.Value).IsNumber},\n\t\t{\"(new Number()).valueOf()\", (*v8.Value).IsNumber},\n\t\t{\"1\", (*v8.Value).IsInt32},\n\t\t{\"-1\", (*v8.Value).IsInt32},\n\t\t{\"1\", (*v8.Value).IsUint32},\n\t\t{\"new Date\", (*v8.Value).IsDate},\n\t\t{\"function foo(){ return arguments }; foo()\", (*v8.Value).IsArgumentsObject},\n\t\t{\"Object(1n)\", (*v8.Value).IsBigIntObject},\n\t\t{\"Object(1)\", (*v8.Value).IsNumberObject},\n\t\t{\"new Number\", (*v8.Value).IsNumberObject},\n\t\t{\"new String\", (*v8.Value).IsStringObject},\n\t\t{\"Object('')\", (*v8.Value).IsStringObject},\n\t\t{\"Object(Symbol())\", (*v8.Value).IsSymbolObject},\n\t\t{\"Error()\", (*v8.Value).IsNativeError},\n\t\t{\"TypeError()\", (*v8.Value).IsNativeError},\n\t\t{\"SyntaxError()\", (*v8.Value).IsNativeError},\n\t\t{\"/./\", (*v8.Value).IsRegExp},\n\t\t{\"RegExp()\", (*v8.Value).IsRegExp},\n\t\t{\"async function v(){}; v\", (*v8.Value).IsAsyncFunction},\n\t\t{\"let v = async () => {}; v\", (*v8.Value).IsAsyncFunction},\n\t\t{\"function* v(){}; v\", (*v8.Value).IsGeneratorFunction},\n\t\t{\"function* v(){}; v()\", (*v8.Value).IsGeneratorObject},\n\t\t{\"new Promise(()=>{})\", (*v8.Value).IsPromise},\n\t\t{\"new Map\", (*v8.Value).IsMap},\n\t\t{\"new Set\", (*v8.Value).IsSet},\n\t\t{\"(new Map).entries()\", (*v8.Value).IsMapIterator},\n\t\t{\"(new Set).entries()\", (*v8.Value).IsSetIterator},\n\t\t{\"new WeakMap\", (*v8.Value).IsWeakMap},\n\t\t{\"new WeakSet\", (*v8.Value).IsWeakSet},\n\t\t{\"new Array\", (*v8.Value).IsArray},\n\t\t{\"Array()\", (*v8.Value).IsArray},\n\t\t{\"[]\", (*v8.Value).IsArray},\n\t\t{\"new ArrayBuffer\", (*v8.Value).IsArrayBuffer},\n\t\t{\"new Int8Array\", (*v8.Value).IsArrayBufferView},\n\t\t{\"new Int8Array\", (*v8.Value).IsTypedArray},\n\t\t{\"new Uint32Array\", (*v8.Value).IsTypedArray},\n\t\t{\"new Uint8Array\", (*v8.Value).IsUint8Array},\n\t\t{\"new Uint8ClampedArray\", (*v8.Value).IsUint8ClampedArray},\n\t\t{\"new Int8Array\", (*v8.Value).IsInt8Array},\n\t\t{\"new Uint16Array\", (*v8.Value).IsUint16Array},\n\t\t{\"new Int16Array\", (*v8.Value).IsInt16Array},\n\t\t{\"new Uint32Array\", (*v8.Value).IsUint32Array},\n\t\t{\"new Int32Array\", (*v8.Value).IsInt32Array},\n\t\t{\"new Float32Array\", (*v8.Value).IsFloat32Array},\n\t\t{\"new Float64Array\", (*v8.Value).IsFloat64Array},\n\t\t{\"new BigInt64Array\", (*v8.Value).IsBigInt64Array},\n\t\t{\"new BigUint64Array\", (*v8.Value).IsBigUint64Array},\n\t\t{\"new DataView(new ArrayBuffer)\", (*v8.Value).IsDataView},\n\t\t{\"new SharedArrayBuffer\", (*v8.Value).IsSharedArrayBuffer},\n\t\t{\"new Proxy({},{})\", (*v8.Value).IsProxy},\n\t}\n\tfor _, tt := range tests {\n\t\ttt := tt\n\t\tt.Run(tt.source, func(t *testing.T) {\n\t\t\tctx := v8.NewContext(iso)\n\t\t\tdefer ctx.Close()\n\n\t\t\tval, err := ctx.RunScript(tt.source, \"test.js\")\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"failed to run script: %v\", err)\n\t\t\t}\n\t\t\tif !tt.assert(val) {\n\t\t\t\tt.Errorf(\"value is false for %s\", runtime.FuncForPC(reflect.ValueOf(tt.assert).Pointer()).Name())\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestValueMarshalJSON(t *testing.T) {\n\tt.Parallel()\n\tiso := v8.NewIsolate()\n\tdefer iso.Dispose()\n\n\ttests := [...]struct {\n\t\tname     string\n\t\tval      func(*v8.Context) *v8.Value\n\t\texpected []byte\n\t}{\n\t\t{\n\t\t\t\"primitive\",\n\t\t\tfunc(ctx *v8.Context) *v8.Value {\n\t\t\t\tval, _ := v8.NewValue(iso, int32(0))\n\t\t\t\treturn val\n\t\t\t},\n\t\t\t[]byte(\"0\"),\n\t\t},\n\t\t{\n\t\t\t\"object\",\n\t\t\tfunc(ctx *v8.Context) *v8.Value {\n\t\t\t\tval, _ := ctx.RunScript(\"let foo = {a:1, b:2}; foo\", \"test.js\")\n\t\t\t\treturn val\n\t\t\t},\n\t\t\t[]byte(`{\"a\":1,\"b\":2}`),\n\t\t},\n\t\t{\n\t\t\t\"objectFunc\",\n\t\t\tfunc(ctx *v8.Context) *v8.Value {\n\t\t\t\tval, _ := ctx.RunScript(\"let foo = {a:1, b:()=>{}}; foo\", \"test.js\")\n\t\t\t\treturn val\n\t\t\t},\n\t\t\t[]byte(`{\"a\":1}`),\n\t\t},\n\t\t{\n\t\t\t\"nil\",\n\t\t\tfunc(ctx *v8.Context) *v8.Value { return nil },\n\t\t\t[]byte(\"\"),\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\ttt := tt\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tctx := v8.NewContext(iso)\n\t\t\tdefer ctx.Close()\n\t\t\tval := tt.val(ctx)\n\t\t\tjson, _ := val.MarshalJSON()\n\t\t\tif !bytes.Equal(json, tt.expected) {\n\t\t\t\tt.Errorf(\"unexpected JSON value: %s\", string(json))\n\t\t\t}\n\n\t\t})\n\t}\n}\n\nfunc TestValueArrayBufferContents(t *testing.T) {\n\tt.Parallel()\n\tiso := v8.NewIsolate()\n\tdefer iso.Dispose()\n\n\tctx := v8.NewContext(iso)\n\tdefer ctx.Close()\n\n\tval, err := ctx.RunScript(`\n\t  (()=>{\n\t\t\tlet buf = new SharedArrayBuffer(1024);\n\t\t\tlet arr = new Int8Array(buf);\n\t\t\tarr[0] = 42;\n\t\t\tarr[1] = 52;\n\t\t\treturn buf;\n\t\t})();\n\t`, \"test.js\")\n\n\tif err != nil {\n\t\tt.Fatalf(\"failed to run script: %v\", err)\n\t}\n\n\tif !val.IsSharedArrayBuffer() {\n\t\tt.Fatalf(\"expected SharedArrayBuffer value\")\n\t}\n\n\tbuf, cleanup, err := val.SharedArrayBufferGetContents()\n\tif err != nil {\n\t\tt.Fatalf(\"error getting array buffer contents: %#v\", err)\n\t}\n\tdefer cleanup()\n\n\tif len(buf) != 1024 {\n\t\tt.Fatalf(\"expected len(buf) to be 1024\")\n\t}\n\n\tif buf[0] != 42 {\n\t\tt.Fatalf(\"expected buf[0] to be 42\")\n\t}\n\n\tif buf[1] != 52 {\n\t\tt.Fatalf(\"expected buf[1] to be 52\")\n\t}\n\n\tif buf[3] != 0 {\n\t\tt.Fatalf(\"expected buf[1] to be 0\")\n\t}\n\n\t// ensure there's an error if we call the method on something that isn't a SharedArrayBuffer\n\tval, err = ctx.RunScript(\"7\", \"test2.js\")\n\tif err != nil {\n\t\tt.Fatalf(\"error running trivial script\")\n\t}\n\t_, _, err = val.SharedArrayBufferGetContents()\n\tif err == nil {\n\t\tt.Fatalf(\"Expected an error trying call SharedArrayBufferGetContents on value of incorrect type\")\n\t}\n}\n"
        }
      ]
    }
  ]
}