{
  "metadata": {
    "timestamp": 1736567071774,
    "page": 657,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjY2MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "didip/tollbooth",
      "stars": 2735,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.021484375,
          "content": "/debug\n/.vscode\n/.idea"
        },
        {
          "name": ".golangci.yml",
          "type": "blob",
          "size": 0.49609375,
          "content": "linters:\n  enable:\n    - revive\n    - govet\n    - unconvert\n    - megacheck\n    - gas\n    - gocyclo\n    - dupl\n    - misspell\n    - unparam\n    - unused\n    - typecheck\n    - ineffassign\n    - stylecheck\n    - gochecknoinits\n    - exportloopref\n    - gocritic\n    - nakedret\n    - gosimple\n    - prealloc\n  fast: false\n  disable-all: true\n\nissues:\n  exclude-rules:\n    - path: _test\\.go\n      linters:\n        - dupl\n    - text: \"Errors unhandled\"\n      linters:\n        - gosec\n  exclude-use-default: false\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.0546875,
          "content": "The MIT License (MIT)\n\nCopyright (c) 2015 Didip Kerabat\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 7.9560546875,
          "content": "[![GoDoc](https://godoc.org/github.com/didip/tollbooth?status.svg)](http://godoc.org/github.com/didip/tollbooth)\n[![license](http://img.shields.io/badge/license-MIT-red.svg?style=flat)](https://raw.githubusercontent.com/didip/tollbooth/master/LICENSE)\n\n## Tollbooth\n\nThis is a generic middleware to rate-limit HTTP requests.\n\n**NOTE 1:** This library is considered finished.\n\n**NOTE 2:** Major version changes are backward-incompatible. `v2.0.0` streamlines the ugliness of the old API.\n\n## Versions\n\n**v1.0.0:** This version maintains the old API but all the thirdparty modules are moved to their own repo.\n\n**v2.x.x:** Brand-new API for the sake of code cleanup, thread safety, & auto-expiring data structures.\n\n**v3.x.x:** Apparently we have been using golang.org/x/time/rate incorrectly. See issue #48. It always limits X number per 1 second. The time duration is not changeable, so it does not make sense to pass TTL to tollbooth.\n\n**v4.x.x:** Float64 for max requests per second\n\n**v5.x.x:** go.mod and go.sum\n\n**v6.x.x:** Replaced `go-cache` with `github.com/go-pkgz/expirable-cache` because `go-cache` leaks goroutines.\n\n**v7.x.x:** Replaced `time/rate` with `embedded time/rate` so that we can support more rate limit headers.\n\n**v8.x.x:** Address `RemoteIP` vulnerability concern by replacing `SetIPLookups` with `SetIPLookup`, an explicit way to pick the IP address.\n\n\n## Five Minute Tutorial\n\n```go\npackage main\n\nimport (\n    \"net/http\"\n\n    \"github.com/didip/tollbooth/v8\"\n    \"github.com/didip/tollbooth/v8/limiter\"\n)\n\nfunc HelloHandler(w http.ResponseWriter, req *http.Request) {\n    w.Write([]byte(\"Hello, World!\"))\n}\n\nfunc main() {\n    // Create a request limiter per handler.\n    lmt := tollbooth.NewLimiter(1, nil)\n\n    // New in version >= 8, you must explicitly define how to pick the IP address.\n    lmt.SetIPLookup(limiter.IPLookup{\n        Name:           \"X-Real-IP\",\n        IndexFromRight: 0,\n    })\n\n    http.Handle(\"/\", tollbooth.LimitFuncHandler(lmt, HelloHandler))\n    http.ListenAndServe(\":12345\", nil)\n}\n```\n\n## Features\n\n1. Rate-limit by request's remote IP, path, methods, custom headers, & basic auth usernames.\n    ```go\n    import (\n        \"time\"\n    \n        \"github.com/didip/tollbooth/v8\"\n        \"github.com/didip/tollbooth/v8/limiter\"\n    )\n\n    lmt := tollbooth.NewLimiter(1, nil)\n\n    // or create a limiter with expirable token buckets\n    // This setting means:\n    // create a 1 request/second limiter and\n    // every token bucket in it will expire 1 hour after it was initially set.\n    lmt = tollbooth.NewLimiter(1, &limiter.ExpirableOptions{DefaultExpirationTTL: time.Hour})\n\n    // New in version >= 8, you must explicitly define how to pick the IP address.\n    // If IP address cannot be found, rate limiter will not be activated.\n    lmt.SetIPLookup(limiter.IPLookup{\n        // The name of lookup method.\n        // Possible options are: RemoteAddr, X-Forwarded-For, X-Real-IP, CF-Connecting-IP\n        // All other headers are considered unknown and will be ignored.\n        Name:            \"X-Real-IP\",\n\n        // The index position to pick the ip address from a comma separated list.\n        // The index goes from right to left.\n        //\n        // When there are multiple of the same headers,\n        // we will concat them together in the order of first to last seen.\n        // And then we pick the IP using this index position.\n        IndexFromRight: 0,\n    })\n\n    // In version >= 8, lmt.SetIPLookups and lmt.GetIPLookups are removed.\n\n    // Limit only GET and POST requests.\n    lmt.SetMethods([]string{\"GET\", \"POST\"})\n\n    // Limit based on basic auth usernames.\n    // You add them on-load, or later as you handle requests.\n    lmt.SetBasicAuthUsers([]string{\"bob\", \"jane\", \"didip\", \"vip\"})\n    // You can remove them later as well.\n    lmt.RemoveBasicAuthUsers([]string{\"vip\"})\n\n    // Limit request headers containing certain values.\n    // You add them on-load, or later as you handle requests.\n    lmt.SetHeader(\"X-Access-Token\", []string{\"abc123\", \"xyz098\"})\n    // You can remove all entries at once.\n    lmt.RemoveHeader(\"X-Access-Token\")\n    // Or remove specific ones.\n    lmt.RemoveHeaderEntries(\"X-Access-Token\", []string{\"limitless-token\"})\n\n    // By the way, the setters are chainable. Example:\n    lmt.SetMethods([]string{\"GET\", \"POST\"}).\n        SetBasicAuthUsers([]string{\"sansa\"}).\n        SetBasicAuthUsers([]string{\"tyrion\"})\n    ```\n\n2. Compose your own middleware by using `LimitByKeys()`.\n\n3. Header entries and basic auth users can expire over time (to conserve memory).\n\n    ```go\n    import \"time\"\n\n    lmt := tollbooth.NewLimiter(1, nil)\n\n    // Set a custom expiration TTL for token bucket.\n    lmt.SetTokenBucketExpirationTTL(time.Hour)\n\n    // Set a custom expiration TTL for basic auth users.\n    lmt.SetBasicAuthExpirationTTL(time.Hour)\n\n    // Set a custom expiration TTL for header entries.\n    lmt.SetHeaderEntryExpirationTTL(time.Hour)\n    ```\n\n4. Upon rejection, the following HTTP response headers are available to users:\n\n    * `X-Rate-Limit-Limit` The maximum request limit.\n\n    * `X-Rate-Limit-Duration` The rate-limiter duration.\n\n    * `X-Rate-Limit-Request-Forwarded-For` The rejected request `X-Forwarded-For`.\n\n    * `X-Rate-Limit-Request-Remote-Addr` The rejected request `RemoteAddr`.\n\n   Upon both success and rejection [RateLimit](https://datatracker.ietf.org/doc/html/draft-ietf-httpapi-ratelimit-headers) headers are sent:\n\n   * `RateLimit-Limit` The maximum request limit within the time window (1s).\n\n   * `RateLimit-Reset` The rate-limiter time window duration in seconds (always 1s).\n\n   * `RateLimit-Remaining` The remaining tokens.\n\n5. Customize your own message or function when limit is reached.\n\n    ```go\n    lmt := tollbooth.NewLimiter(1, nil)\n\n    // New in version >= 8, you must explicitly define how to pick the IP address.\n    lmt.SetIPLookup(limiter.IPLookup{\n        Name:           \"X-Forwarded-For\",\n        IndexFromRight: 0,\n    })\n\n    // Set a custom message.\n    lmt.SetMessage(\"You have reached maximum request limit.\")\n\n    // Set a custom content-type.\n    lmt.SetMessageContentType(\"text/plain; charset=utf-8\")\n\n    // Set a custom function for rejection.\n    lmt.SetOnLimitReached(func(w http.ResponseWriter, r *http.Request) { fmt.Println(\"A request was rejected\") })\n    ```\n\n6. Tollbooth does not require external storage since it uses an algorithm called [Token Bucket](http://en.wikipedia.org/wiki/Token_bucket) [(Go library: golang.org/x/time/rate)](https://godoc.org/golang.org/x/time/rate).\n\n## Other Web Frameworks\n\nSometimes, other frameworks require a little bit of shim to use Tollbooth. These shims below are contributed by the community, so I make no promises on how well they work. The one I am familiar with are: Chi, Gin, and Negroni.\n\n* [Chi](https://github.com/didip/tollbooth_chi)\n\n* [Echo](https://github.com/didip/tollbooth_echo)\n\n* [FastHTTP](https://github.com/didip/tollbooth_fasthttp)\n\n* [Gin](https://github.com/didip/tollbooth_gin)\n\n* [GoRestful](https://github.com/didip/tollbooth_gorestful)\n\n* [HTTPRouter](https://github.com/didip/tollbooth_httprouter)\n\n* [Iris](https://github.com/didip/tollbooth_iris)\n\n* [Negroni](https://github.com/didip/tollbooth_negroni)\n\n## My other Go libraries\n\n* [ErrStack](https://github.com/didip/errstack): A small library to combine errors and also display filename and line number.\n\n* [Stopwatch](https://github.com/didip/stopwatch): A small library to measure latency of things. Useful if you want to report latency data to Graphite.\n\n* [LaborUnion](https://github.com/didip/laborunion): A dynamic worker pool library.\n\n* [Gomet](https://github.com/didip/gomet): Simple HTTP client & server long poll library for Go. Useful for receiving live updates without needing Websocket.\n\n## Contributions\n\nBefore sending a PR with code changes, please make sure altered code is covered with tests which are passing, and that golangci-lint shows no errors.\n\nTo check the linter output, [install it](https://golangci-lint.run/usage/install/#local-installation) and then run `golangci-lint run` in the root directory of the repository.\n"
        },
        {
          "name": "errors",
          "type": "tree",
          "content": null
        },
        {
          "name": "go.mod",
          "type": "blob",
          "size": 0.09765625,
          "content": "module github.com/didip/tollbooth/v8\n\ngo 1.19\n\nrequire github.com/go-pkgz/expirable-cache/v3 v3.0.0\n"
        },
        {
          "name": "go.sum",
          "type": "blob",
          "size": 0.5908203125,
          "content": "github.com/davecgh/go-spew v1.1.1 h1:vj9j/u1bqnvCEfJOwUhtlOARqs3+rkHYY13jYWTU97c=\ngithub.com/go-pkgz/expirable-cache/v3 v3.0.0 h1:u3/gcu3sabLYiTCevoRKv+WzjIn5oo7P8XtiXBeRDLw=\ngithub.com/go-pkgz/expirable-cache/v3 v3.0.0/go.mod h1:2OQiDyEGQalYecLWmXprm3maPXeVb5/6/X7yRPYTzec=\ngithub.com/hashicorp/golang-lru/v2 v2.0.7 h1:a+bsQ5rvGLjzHuww6tVxozPZFVghXaHOwFs4luLUK2k=\ngithub.com/pmezard/go-difflib v1.0.0 h1:4DBwDE0NGyQoBHbLQYPwSUPoCMWR5BEzIk/f1lZbAQM=\ngithub.com/stretchr/testify v1.8.4 h1:CcVxjf3Q8PM0mHUKJCdn+eZZtm5yQwehR5yeSVQQcUk=\ngopkg.in/yaml.v3 v3.0.1 h1:fxVm/GzAzEWqLHuvctI91KS9hhNmmWOoWu0XTYJS7CA=\n"
        },
        {
          "name": "internal",
          "type": "tree",
          "content": null
        },
        {
          "name": "libstring",
          "type": "tree",
          "content": null
        },
        {
          "name": "limiter",
          "type": "tree",
          "content": null
        },
        {
          "name": "tollbooth.go",
          "type": "blob",
          "size": 11.0947265625,
          "content": "// Package tollbooth provides rate-limiting logic to HTTP request handler.\npackage tollbooth\n\nimport (\n\t\"fmt\"\n\t\"math\"\n\t\"net/http\"\n\t\"strings\"\n\n\t\"github.com/didip/tollbooth/v8/errors\"\n\t\"github.com/didip/tollbooth/v8/libstring\"\n\t\"github.com/didip/tollbooth/v8/limiter\"\n)\n\n// setResponseHeaders configures X-Rate-Limit-Limit and X-Rate-Limit-Duration\nfunc setResponseHeaders(lmt *limiter.Limiter, w http.ResponseWriter, r *http.Request) {\n\tw.Header().Add(\"X-Rate-Limit-Limit\", fmt.Sprintf(\"%.2f\", lmt.GetMax()))\n\tw.Header().Add(\"X-Rate-Limit-Duration\", \"1\")\n\n\txForwardedFor := r.Header.Get(\"X-Forwarded-For\")\n\tif strings.TrimSpace(xForwardedFor) != \"\" {\n\t\tw.Header().Add(\"X-Rate-Limit-Request-Forwarded-For\", xForwardedFor)\n\t}\n\n\tw.Header().Add(\"X-Rate-Limit-Request-Remote-Addr\", r.RemoteAddr)\n}\n\n// setRateLimitResponseHeaders configures RateLimit-Limit, RateLimit-Remaining and RateLimit-Reset\n// as seen at https://datatracker.ietf.org/doc/html/draft-ietf-httpapi-ratelimit-headers\nfunc setRateLimitResponseHeaders(lmt *limiter.Limiter, w http.ResponseWriter, tokensLeft int) {\n\tw.Header().Add(\"RateLimit-Limit\", fmt.Sprintf(\"%d\", int(math.Round(lmt.GetMax()))))\n\tw.Header().Add(\"RateLimit-Reset\", \"1\")\n\tw.Header().Add(\"RateLimit-Remaining\", fmt.Sprintf(\"%d\", tokensLeft))\n}\n\n// NewLimiter is a convenience function to limiter.New.\nfunc NewLimiter(max float64, tbOptions *limiter.ExpirableOptions) *limiter.Limiter {\n\treturn limiter.New(tbOptions).\n\t\tSetMax(max).\n\t\tSetBurst(int(math.Max(1, max)))\n}\n\n// LimitByKeys keeps track number of request made by keys separated by pipe.\n// It returns HTTPError when limit is exceeded.\nfunc LimitByKeys(lmt *limiter.Limiter, keys []string) *errors.HTTPError {\n\terr, _ := LimitByKeysAndReturn(lmt, keys)\n\treturn err\n}\n\n// LimitByKeysAndReturn keeps track number of request made by keys separated by pipe.\n// It returns HTTPError when limit is exceeded, and also returns the current limit value.\nfunc LimitByKeysAndReturn(lmt *limiter.Limiter, keys []string) (*errors.HTTPError, int) {\n\tif lmt.LimitReached(strings.Join(keys, \"|\")) {\n\t\treturn &errors.HTTPError{Message: lmt.GetMessage(), StatusCode: lmt.GetStatusCode()}, 0\n\t}\n\n\treturn nil, lmt.Tokens(strings.Join(keys, \"|\"))\n}\n\n// ShouldSkipLimiter is a series of filter that decides if request should be limited or not.\nfunc ShouldSkipLimiter(lmt *limiter.Limiter, r *http.Request) bool {\n\t// ---------------------------------\n\t// Filter by remote ip\n\t// If we are unable to find remoteIP, skip limiter\n\tremoteIP := libstring.RemoteIPFromIPLookup(lmt.GetIPLookup(), r)\n\tremoteIP = libstring.CanonicalizeIP(remoteIP)\n\tif remoteIP == \"\" {\n\t\treturn true\n\t}\n\n\t// ---------------------------------\n\t// Filter by request method\n\tlmtMethods := lmt.GetMethods()\n\tlmtMethodsIsSet := len(lmtMethods) > 0\n\n\tif lmtMethodsIsSet {\n\t\t// If request does not contain all of the methods in limiter,\n\t\t// skip limiter\n\t\trequestMethodDefinedInLimiter := libstring.StringInSlice(lmtMethods, r.Method)\n\n\t\tif !requestMethodDefinedInLimiter {\n\t\t\treturn true\n\t\t}\n\t}\n\n\t// ---------------------------------\n\t// Filter by request headers\n\tlmtHeaders := lmt.GetHeaders()\n\tlmtHeadersIsSet := len(lmtHeaders) > 0\n\n\tif lmtHeadersIsSet {\n\t\t// If request does not contain all of the headers in limiter,\n\t\t// skip limiter\n\t\trequestHeadersDefinedInLimiter := false\n\n\t\tfor headerKey := range lmtHeaders {\n\t\t\treqHeaderValue := r.Header.Get(headerKey)\n\t\t\tif reqHeaderValue != \"\" {\n\t\t\t\trequestHeadersDefinedInLimiter = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\n\t\tif !requestHeadersDefinedInLimiter {\n\t\t\treturn true\n\t\t}\n\n\t\t// ------------------------------\n\t\t// If request contains the header key but not the values,\n\t\t// skip limiter\n\t\trequestHeadersDefinedInLimiter = false\n\n\t\tfor headerKey, headerValues := range lmtHeaders {\n\t\t\tif len(headerValues) == 0 {\n\t\t\t\trequestHeadersDefinedInLimiter = true\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tfor _, headerValue := range headerValues {\n\t\t\t\tif r.Header.Get(headerKey) == headerValue {\n\t\t\t\t\trequestHeadersDefinedInLimiter = true\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif !requestHeadersDefinedInLimiter {\n\t\t\treturn true\n\t\t}\n\t}\n\n\t// ---------------------------------\n\t// Filter by context values\n\tlmtContextValues := lmt.GetContextValues()\n\tlmtContextValuesIsSet := len(lmtContextValues) > 0\n\n\tif lmtContextValuesIsSet {\n\t\t// If request does not contain all of the contexts in limiter,\n\t\t// skip limiter\n\t\trequestContextValuesDefinedInLimiter := false\n\n\t\tfor contextKey := range lmtContextValues {\n\t\t\treqContextValue := fmt.Sprintf(\"%v\", r.Context().Value(contextKey))\n\t\t\tif reqContextValue != \"\" {\n\t\t\t\trequestContextValuesDefinedInLimiter = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\n\t\tif !requestContextValuesDefinedInLimiter {\n\t\t\treturn true\n\t\t}\n\n\t\t// ------------------------------\n\t\t// If request contains the context key but not the values,\n\t\t// skip limiter\n\t\trequestContextValuesDefinedInLimiter = false\n\n\t\tfor contextKey, contextValues := range lmtContextValues {\n\t\t\tfor _, contextValue := range contextValues {\n\t\t\t\tif r.Header.Get(contextKey) == contextValue {\n\t\t\t\t\trequestContextValuesDefinedInLimiter = true\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif !requestContextValuesDefinedInLimiter {\n\t\t\treturn true\n\t\t}\n\t}\n\n\t// ---------------------------------\n\t// Filter by basic auth usernames\n\tlmtBasicAuthUsers := lmt.GetBasicAuthUsers()\n\tlmtBasicAuthUsersIsSet := len(lmtBasicAuthUsers) > 0\n\n\tif lmtBasicAuthUsersIsSet {\n\t\t// If request does not contain all of the basic auth users in limiter,\n\t\t// skip limiter\n\t\trequestAuthUsernameDefinedInLimiter := false\n\n\t\tusername, _, ok := r.BasicAuth()\n\t\tif ok && libstring.StringInSlice(lmtBasicAuthUsers, username) {\n\t\t\trequestAuthUsernameDefinedInLimiter = true\n\t\t}\n\n\t\tif !requestAuthUsernameDefinedInLimiter {\n\t\t\treturn true\n\t\t}\n\t}\n\n\treturn false\n}\n\n// BuildKeys generates a slice of keys to rate-limit by given limiter and request structs.\nfunc BuildKeys(lmt *limiter.Limiter, r *http.Request) [][]string {\n\tremoteIP := libstring.RemoteIPFromIPLookup(lmt.GetIPLookup(), r)\n\tremoteIP = libstring.CanonicalizeIP(remoteIP)\n\tpath := r.URL.Path\n\tsliceKeys := make([][]string, 0)\n\n\tlmtMethods := lmt.GetMethods()\n\tlmtHeaders := lmt.GetHeaders()\n\tlmtContextValues := lmt.GetContextValues()\n\tlmtBasicAuthUsers := lmt.GetBasicAuthUsers()\n\tlmtIgnoreURL := lmt.GetIgnoreURL()\n\n\tlmtHeadersIsSet := len(lmtHeaders) > 0\n\tlmtContextValuesIsSet := len(lmtContextValues) > 0\n\tlmtBasicAuthUsersIsSet := len(lmtBasicAuthUsers) > 0\n\n\tusernameToLimit := \"\"\n\tif lmtBasicAuthUsersIsSet {\n\t\tusername, _, ok := r.BasicAuth()\n\t\tif ok && libstring.StringInSlice(lmtBasicAuthUsers, username) {\n\t\t\tusernameToLimit = username\n\t\t}\n\t}\n\n\theaderValuesToLimit := [][]string{}\n\tif lmtHeadersIsSet {\n\t\tfor headerKey, headerValues := range lmtHeaders {\n\t\t\treqHeaderValue := r.Header.Get(headerKey)\n\t\t\tif reqHeaderValue == \"\" {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tif len(headerValues) == 0 {\n\t\t\t\t// If header values are empty, rate-limit all request containing headerKey.\n\t\t\t\theaderValuesToLimit = append(headerValuesToLimit, []string{headerKey, reqHeaderValue})\n\n\t\t\t} else {\n\t\t\t\t// If header values are not empty, rate-limit all request with headerKey and headerValues.\n\t\t\t\tfor _, headerValue := range headerValues {\n\t\t\t\t\tif r.Header.Get(headerKey) == headerValue {\n\t\t\t\t\t\theaderValuesToLimit = append(headerValuesToLimit, []string{headerKey, headerValue})\n\t\t\t\t\t\tbreak\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tcontextValuesToLimit := [][]string{}\n\tif lmtContextValuesIsSet {\n\t\tfor contextKey, contextValues := range lmtContextValues {\n\t\t\treqContextValue := fmt.Sprintf(\"%v\", r.Context().Value(contextKey))\n\t\t\tif reqContextValue == \"\" {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tif len(contextValues) == 0 {\n\t\t\t\t// If context values are empty, rate-limit all request containing contextKey.\n\t\t\t\tcontextValuesToLimit = append(contextValuesToLimit, []string{contextKey, reqContextValue})\n\n\t\t\t} else {\n\t\t\t\t// If context values are not empty, rate-limit all request with contextKey and contextValues.\n\t\t\t\tfor _, contextValue := range contextValues {\n\t\t\t\t\tif reqContextValue == contextValue {\n\t\t\t\t\t\tcontextValuesToLimit = append(contextValuesToLimit, []string{contextKey, contextValue})\n\t\t\t\t\t\tbreak\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tsliceKey := []string{remoteIP}\n\tif !lmtIgnoreURL {\n\t\tsliceKey = append(sliceKey, path)\n\t}\n\n\tsliceKey = append(sliceKey, lmtMethods...)\n\n\tfor _, header := range headerValuesToLimit {\n\t\tsliceKey = append(sliceKey, header[0], header[1])\n\t}\n\n\tfor _, contextValue := range contextValuesToLimit {\n\t\tsliceKey = append(sliceKey, contextValue[0], contextValue[1])\n\t}\n\n\tsliceKey = append(sliceKey, usernameToLimit)\n\n\tsliceKeys = append(sliceKeys, sliceKey)\n\n\treturn sliceKeys\n}\n\n// LimitByRequest builds keys based on http.Request struct,\n// loops through all the keys, and check if any one of them returns HTTPError.\nfunc LimitByRequest(lmt *limiter.Limiter, w http.ResponseWriter, r *http.Request) *errors.HTTPError {\n\tsetResponseHeaders(lmt, w, r)\n\n\tshouldSkip := ShouldSkipLimiter(lmt, r)\n\tif shouldSkip {\n\t\treturn nil\n\t}\n\n\tsliceKeys := BuildKeys(lmt, r)\n\n\t// Get the lowest value over all keys to return in headers.\n\t// Start with high arbitrary number so that any limit returned would be lower and would\n\t// overwrite the value we start with.\n\tvar tokensLeft = math.MaxInt32\n\n\t// Loop sliceKeys and check if one of them has error.\n\tfor _, keys := range sliceKeys {\n\t\thttpError, keysLimit := LimitByKeysAndReturn(lmt, keys)\n\t\tif tokensLeft > keysLimit {\n\t\t\ttokensLeft = keysLimit\n\t\t}\n\t\tif httpError != nil {\n\t\t\tsetRateLimitResponseHeaders(lmt, w, tokensLeft)\n\t\t\treturn httpError\n\t\t}\n\t}\n\n\tsetRateLimitResponseHeaders(lmt, w, tokensLeft)\n\treturn nil\n}\n\n// LimitHandler is a middleware that performs rate-limiting given http.Handler struct.\nfunc LimitHandler(lmt *limiter.Limiter, next http.Handler) http.Handler {\n\tmiddle := func(w http.ResponseWriter, r *http.Request) {\n\t\thttpError := LimitByRequest(lmt, w, r)\n\t\tif httpError != nil {\n\t\t\tlmt.ExecOnLimitReached(w, r)\n\t\t\tif lmt.GetOverrideDefaultResponseWriter() {\n\t\t\t\treturn\n\t\t\t}\n\t\t\tw.Header().Add(\"Content-Type\", lmt.GetMessageContentType())\n\t\t\tw.WriteHeader(httpError.StatusCode)\n\t\t\tw.Write([]byte(httpError.Message))\n\t\t\treturn\n\t\t}\n\n\t\t// There's no rate-limit error, serve the next handler.\n\t\tnext.ServeHTTP(w, r)\n\t}\n\n\treturn http.HandlerFunc(middle)\n}\n\n// LimitFuncHandler is a middleware that performs rate-limiting given request handler function.\nfunc LimitFuncHandler(lmt *limiter.Limiter, nextFunc func(http.ResponseWriter, *http.Request)) http.Handler {\n\treturn LimitHandler(lmt, http.HandlerFunc(nextFunc))\n}\n\n// HTTPMiddleware wraps http.Handler with tollbooth limiter\nfunc HTTPMiddleware(lmt *limiter.Limiter) func(http.Handler) http.Handler {\n\t// // set IP lookup only if not set\n\tif lmt.GetIPLookup().Name == \"\" {\n\t\tlmt.SetIPLookup(limiter.IPLookup{Name: \"RemoteAddr\"})\n\t}\n\n\treturn func(next http.Handler) http.Handler {\n\t\treturn http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\t\tselect {\n\t\t\tcase <-r.Context().Done():\n\t\t\t\thttp.Error(w, \"Context was canceled\", http.StatusServiceUnavailable)\n\t\t\t\treturn\n\t\t\tdefault:\n\t\t\t\tif httpError := LimitByRequest(lmt, w, r); httpError != nil {\n\t\t\t\t\tlmt.ExecOnLimitReached(w, r)\n\t\t\t\t\tw.Header().Add(\"Content-Type\", lmt.GetMessageContentType())\n\t\t\t\t\tw.WriteHeader(httpError.StatusCode)\n\t\t\t\t\tw.Write([]byte(httpError.Message)) //nolint:gosec // not much we can do here with failed write\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tnext.ServeHTTP(w, r)\n\t\t\t}\n\t\t})\n\t}\n}\n"
        },
        {
          "name": "tollbooth_benchmark_test.go",
          "type": "blob",
          "size": 1.2919921875,
          "content": "package tollbooth\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"strings\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/didip/tollbooth/v8/limiter\"\n)\n\nfunc BenchmarkLimitByKeys(b *testing.B) {\n\tlmt := limiter.New(nil).SetMax(1) // Only 1 request per second is allowed.\n\n\tfor i := 0; i < b.N; i++ {\n\t\tLimitByKeys(lmt, []string{\"127.0.0.1\", \"/\"})\n\t}\n}\n\nfunc BenchmarkLimitByKeysWithExpiringBuckets(b *testing.B) {\n\tlmt := limiter.New(\n\t\t&limiter.ExpirableOptions{DefaultExpirationTTL: time.Minute},\n\t).SetMax(1) // Only 1 request per second is allowed.\n\n\tfor i := 0; i < b.N; i++ {\n\t\tLimitByKeys(lmt, []string{\"127.0.0.1\", \"/\"})\n\t}\n}\n\nfunc BenchmarkBuildKeys(b *testing.B) {\n\tlmt := limiter.New(nil).SetMax(1) // Only 1 request per second is allowed.\n\tlmt.SetIPLookup(limiter.IPLookup{\n\t\tName:           \"X-Real-IP\",\n\t\tIndexFromRight: 0,\n\t}).\n\t\tSetHeaders(make(map[string][]string)).\n\t\tSetHeader(\"X-Real-IP\", []string{\"2601:7:1c82:4097:59a0:a80b:2841:b8c8\"})\n\n\trequest, err := http.NewRequest(\"GET\", \"/\", strings.NewReader(\"Hello, world!\"))\n\tif err != nil {\n\t\tfmt.Printf(\"Unable to create new HTTP request. Error: %v\", err)\n\t}\n\n\trequest.Header.Set(\"X-Real-IP\", lmt.GetHeader(\"X-Real-IP\")[0])\n\tfor i := 0; i < b.N; i++ {\n\t\tsliceKeys := BuildKeys(lmt, request)\n\t\tif len(sliceKeys) == 0 {\n\t\t\tfmt.Print(\"Length of sliceKeys should never be empty.\")\n\t\t}\n\t}\n}\n"
        },
        {
          "name": "tollbooth_bug_report_test.go",
          "type": "blob",
          "size": 6.2509765625,
          "content": "package tollbooth\n\nimport (\n\t\"net/http\"\n\t\"net/http/httptest\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/didip/tollbooth/v8/limiter\"\n)\n\n// See: https://github.com/didip/tollbooth/issues/48\nfunc Test_Issue48_RequestTerminatedEvenOnLowVolumeOnSameIP(t *testing.T) {\n\t// The issue seen by the reporter is that the limiter slowly \"leaks\", causing requests\n\t// to fail after a prolonged period of continuous usage. Try to model that here.\n\t//\n\t// Report stated that a constant 2 requests per second over several minutes would cause\n\t// a limit of 2/req/sec to start returning 429.\n\n\trequestsPerSecond := float64(2)\n\n\tlmt := NewLimiter(requestsPerSecond, nil)\n\tlmt.SetMethods([]string{\"GET\"})\n\n\tlimitReachedCounter := 0\n\tlmt.SetOnLimitReached(func(http.ResponseWriter, *http.Request) { limitReachedCounter++ })\n\n\thandler := LimitHandler(lmt, http.HandlerFunc(func(w http.ResponseWriter, _ *http.Request) {\n\t\tw.Write([]byte(`hello world`))\n\t}))\n\n\ttimeout := time.After(1 * time.Second)\n\tstart := time.Now()\n\n\t// Create the HTTP request\n\treq, _ := http.NewRequest(\"GET\", \"/doesntmatter\", nil)\n\treq.RemoteAddr = \"127.0.0.1\"\n\nTop:\n\tfor {\n\t\tselect {\n\t\tcase <-timeout:\n\t\t\tbreak Top\n\t\tcase <-time.After(500 * time.Millisecond):\n\t\t\trr := httptest.NewRecorder()\n\t\t\thandler.ServeHTTP(rr, req)\n\n\t\t\tif rr.Code != http.StatusOK {\n\t\t\t\tt.Fatalf(\"Should be able to handle %v reqs/second. HTTP status: %v. Expected HTTP status: %v. Failed in %v seconds. limitReachedCounter: %d\", requestsPerSecond, rr.Code, http.StatusOK, time.Since(start).Seconds(), limitReachedCounter)\n\t\t\t}\n\t\t}\n\t}\n\n\tif limitReachedCounter > 0 {\n\t\tt.Fatalf(\"We should never reached the limit, the counter should be 0. limitReachedCounter: %v\", limitReachedCounter)\n\t}\n}\n\nvar issue66HeaderKey = \"X-Customer-ID\"\n\nfunc issue66RateLimiter(h http.HandlerFunc, customerIDs []string) (http.HandlerFunc, *limiter.Limiter) {\n\tallocationLimiter := NewLimiter(1, nil).SetMethods([]string{\"POST\"}).\n\t\tSetIPLookup(limiter.IPLookup{\n\t\t\tName: \"RemoteAddr\",\n\t\t})\n\n\thandler := func(w http.ResponseWriter, r *http.Request) {\n\t\tallocationLimiter.SetHeader(issue66HeaderKey, customerIDs)\n\t\tLimitFuncHandler(allocationLimiter, h).ServeHTTP(w, r)\n\t}\n\n\treturn handler, allocationLimiter\n}\n\n// See: https://github.com/didip/tollbooth/issues/66\nfunc Test_Issue66_CustomRateLimitByHeaderValues(t *testing.T) {\n\tcustomerID1 := \"1234\"\n\tcustomerID2 := \"5678\"\n\n\th := http.HandlerFunc(func(http.ResponseWriter, *http.Request) {})\n\n\th, allocationLimiter := issue66RateLimiter(h, []string{customerID1, customerID2})\n\ttestServer := httptest.NewServer(h)\n\tdefer testServer.Close()\n\n\tclient := &http.Client{}\n\n\t// subtest 1:\n\t// There are 2 different customer ids,\n\t// both should pass rate limiter the 1st time and failed the second time.\n\trequest1, _ := http.NewRequest(\"POST\", testServer.URL, nil)\n\trequest1.Header.Add(issue66HeaderKey, customerID1)\n\n\trequest2, _ := http.NewRequest(\"POST\", testServer.URL, nil)\n\trequest2.Header.Add(issue66HeaderKey, customerID2)\n\n\tfor _, request := range []*http.Request{request1} {\n\t\t// 1st, 200\n\t\tresponse, _ := client.Do(request)\n\t\tif response.StatusCode != http.StatusOK {\n\t\t\tt.Fatalf(`\nCustomer %v must pass rate limiter the first time.\nExpected to receive: %v status code. Got: %v.\nlimiter.headers: %v`,\n\t\t\t\trequest.Header.Get(issue66HeaderKey),\n\t\t\t\thttp.StatusOK, response.StatusCode,\n\t\t\t\tallocationLimiter.GetHeaders())\n\t\t}\n\n\t\t// 2nd, 429\n\t\tresponse, _ = client.Do(request)\n\t\tif response.StatusCode != http.StatusTooManyRequests {\n\t\t\tt.Fatalf(`Both customer must fail rate limiter.\nExpected to receive: %v status code. Got: %v`,\n\t\t\t\thttp.StatusTooManyRequests, response.StatusCode)\n\t\t}\n\t}\n\n\t// subtest 2:\n\t// There is 1 customer not defined in rate limiter.\n\t// S/he should not be rate limited.\n\trequest3, _ := http.NewRequest(\"POST\", testServer.URL, nil)\n\trequest3.Header.Add(issue66HeaderKey, \"777\")\n\n\tfor i := 0; i < 2; i++ {\n\t\tresponse, _ := client.Do(request3)\n\n\t\tif response.StatusCode != http.StatusOK {\n\t\t\tt.Fatalf(`\nCustomer %v must always pass rate limiter.\nExpected to receive: %v status code. Got: %v`,\n\t\t\t\trequest3.Header.Get(issue66HeaderKey),\n\t\t\t\thttp.StatusOK, response.StatusCode)\n\t\t}\n\t}\n}\n\nfunc Test_Issue91_BrokenSetMethod_DontBlockGet(t *testing.T) {\n\trequestsPerSecond := float64(1)\n\n\tlmt := NewLimiter(requestsPerSecond, nil).SetMethods([]string{\"POST\"})\n\n\tmethods := lmt.GetMethods()\n\tif methods[0] != \"POST\" {\n\t\tt.Fatalf(\"Failed to set methods correctly. Expected: POST Got: %v\", methods[0])\n\t}\n\n\t// -------------------------------------------------------------------\n\n\thandler := LimitHandler(lmt, http.HandlerFunc(func(w http.ResponseWriter, _ *http.Request) {\n\t\tw.Write([]byte(`hello world`))\n\t}))\n\n\t// Create GET HTTP request\n\treq, _ := http.NewRequest(\"GET\", \"/doesntmatter\", nil)\n\treq.RemoteAddr = \"127.0.0.1\"\n\n\t// We should never reach the limit because we are sending 10 GET requests and\n\t// we are only limiting POST requests.\n\tfor i := 0; i < 10; i++ {\n\t\tstart := time.Now()\n\n\t\trr := httptest.NewRecorder()\n\t\thandler.ServeHTTP(rr, req)\n\n\t\tif rr.Code != http.StatusOK {\n\t\t\tt.Fatalf(\"Should be able to handle %v reqs/second. HTTP status: %v. Expected HTTP status: %v. Failed in %v microseconds\", requestsPerSecond, rr.Code, http.StatusOK, time.Since(start).Microseconds())\n\t\t}\n\t}\n}\n\nfunc Test_Issue91_BrokenSetMethod_BlockPost(t *testing.T) {\n\trequestsPerSecond := float64(1)\n\n\tlmt := NewLimiter(requestsPerSecond, nil).SetMethods([]string{\"POST\"}).\n\t\tSetIPLookup(limiter.IPLookup{\n\t\t\tName: \"RemoteAddr\",\n\t\t})\n\n\tlimitReachedCounter := 0\n\tlmt.SetOnLimitReached(func(http.ResponseWriter, *http.Request) {\n\t\tlimitReachedCounter++\n\t})\n\n\tmethods := lmt.GetMethods()\n\tif methods[0] != \"POST\" {\n\t\tt.Fatalf(\"Failed to set methods correctly. Expected: POST Got: %v\", methods[0])\n\t}\n\n\t// -------------------------------------------------------------------\n\n\thandler := LimitHandler(lmt, http.HandlerFunc(func(w http.ResponseWriter, _ *http.Request) {\n\t\tw.Write([]byte(`hello world`))\n\t}))\n\n\t// Create POST HTTP request\n\treq, _ := http.NewRequest(\"POST\", \"/blockmeafter2\", nil)\n\treq.RemoteAddr = \"127.0.0.1\"\n\n\t// We should reach the limit because we are sending 2 POST requests and\n\t// our limiter is 1 POST per second.\n\tfor i := 0; i < 2; i++ {\n\t\trr := httptest.NewRecorder()\n\t\thandler.ServeHTTP(rr, req)\n\t}\n\n\tif limitReachedCounter == 0 {\n\t\tt.Fatalf(\"Should have reached limit. Limit reached counter: %d\", limitReachedCounter)\n\t}\n}\n"
        },
        {
          "name": "tollbooth_test.go",
          "type": "blob",
          "size": 23.2236328125,
          "content": "package tollbooth\n\nimport (\n\t\"context\"\n\t\"net/http\"\n\t\"net/http/httptest\"\n\t\"strings\"\n\t\"sync\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/didip/tollbooth/v8/limiter\"\n)\n\nfunc TestLimitByKeys(t *testing.T) {\n\tlmt := NewLimiter(1, nil) // Only 1 request per second is allowed.\n\n\thttperror := LimitByKeys(lmt, []string{\"127.0.0.1\", \"/\"})\n\tif httperror != nil {\n\t\tt.Errorf(\"First time count should not return error. Error: %v\", httperror.Error())\n\t}\n\n\thttperror = LimitByKeys(lmt, []string{\"127.0.0.1\", \"/\"})\n\tif httperror == nil {\n\t\tt.Errorf(\"Second time count should return error because it exceeds 1 request per second.\")\n\t}\n\n\t<-time.After(1 * time.Second)\n\thttperror = LimitByKeys(lmt, []string{\"127.0.0.1\", \"/\"})\n\tif httperror != nil {\n\t\tt.Errorf(\"Third time count should not return error because the 1 second window has passed.\")\n\t}\n}\n\nfunc TestDefaultBuildKeys(t *testing.T) {\n\tlmt := NewLimiter(1, nil).SetIPLookup(limiter.IPLookup{\n\t\tName:           \"X-Real-IP\",\n\t\tIndexFromRight: 0,\n\t})\n\n\trequest, err := http.NewRequest(\"GET\", \"/\", strings.NewReader(\"Hello, world!\"))\n\tif err != nil {\n\t\tt.Errorf(\"Unable to create new HTTP request. Error: %v\", err)\n\t}\n\n\trequest.Header.Set(\"X-Real-IP\", \"2601:7:1c82:4097:59a0:a80b:2841:b8c8\")\n\texpectedIP := \"2601:7:1c82:4097::\"\n\n\tsliceKeys := BuildKeys(lmt, request)\n\tif len(sliceKeys) == 0 {\n\t\tt.Fatal(\"Length of sliceKeys should never be empty.\")\n\t}\n\n\tfor _, keys := range sliceKeys {\n\t\texpectedKeys := [][]string{\n\t\t\t{expectedIP},\n\t\t\t{request.URL.Path},\n\t\t}\n\n\t\tcheckKeys(t, keys, expectedKeys)\n\t}\n}\n\nfunc TestIgnoreURLBuildKeys(t *testing.T) {\n\tlmt := NewLimiter(1, nil).\n\t\tSetIPLookup(limiter.IPLookup{\n\t\t\tName:           \"X-Real-IP\",\n\t\t\tIndexFromRight: 0,\n\t\t}).\n\t\tSetIgnoreURL(true)\n\n\trequest, err := http.NewRequest(\"GET\", \"/\", strings.NewReader(\"Hello, world!\"))\n\tif err != nil {\n\t\tt.Errorf(\"Unable to create new HTTP request. Error: %v\", err)\n\t}\n\n\trequest.Header.Set(\"X-Real-IP\", \"172.217.0.46\")\n\n\tfor _, keys := range BuildKeys(lmt, request) {\n\t\tfor i, keyChunk := range keys {\n\t\t\tif i == 0 && keyChunk != request.Header.Get(\"X-Real-IP\") {\n\t\t\t\tt.Errorf(\"The (%v) chunk should be remote IP. KeyChunk: %v\", i+1, keyChunk)\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc TestBasicAuthBuildKeys(t *testing.T) {\n\tlmt := NewLimiter(1, nil).\n\t\tSetIPLookup(limiter.IPLookup{\n\t\t\tName:           \"X-Real-IP\",\n\t\t\tIndexFromRight: 0,\n\t\t}).\n\t\tSetBasicAuthUsers([]string{\"bro\"})\n\n\trequest, err := http.NewRequest(\"GET\", \"/\", strings.NewReader(\"Hello, world!\"))\n\tif err != nil {\n\t\tt.Errorf(\"Unable to create new HTTP request. Error: %v\", err)\n\t}\n\n\trequest.Header.Set(\"X-Real-IP\", \"2601:7:1c82:4097:59a0:a80b:2841:b8c8\")\n\texpectedIP := \"2601:7:1c82:4097::\"\n\n\trequest.SetBasicAuth(\"bro\", \"tato\")\n\n\tsliceKeys := BuildKeys(lmt, request)\n\tif len(sliceKeys) == 0 {\n\t\tt.Fatal(\"Length of sliceKeys should never be empty.\")\n\t}\n\n\tfor _, keys := range sliceKeys {\n\t\texpectedKeys := [][]string{\n\t\t\t{expectedIP},\n\t\t\t{request.URL.Path},\n\t\t\t{\"bro\"},\n\t\t}\n\n\t\tcheckKeys(t, keys, expectedKeys)\n\t}\n}\n\nfunc TestCustomHeadersBuildKeys(t *testing.T) {\n\tlmt := NewLimiter(1, nil).\n\t\tSetIPLookup(limiter.IPLookup{\n\t\t\tName:           \"X-Real-IP\",\n\t\t\tIndexFromRight: 0,\n\t\t}).\n\t\tSetHeader(\"X-Auth-Token\", []string{\"totally-top-secret\", \"another-secret\"})\n\n\trequest, err := http.NewRequest(\"GET\", \"/\", strings.NewReader(\"Hello, world!\"))\n\tif err != nil {\n\t\tt.Errorf(\"Unable to create new HTTP request. Error: %v\", err)\n\t}\n\n\trequest.Header.Set(\"X-Real-IP\", \"172.217.0.46\")\n\trequest.Header.Set(\"X-Auth-Token\", \"totally-top-secret\")\n\n\tsliceKeys := BuildKeys(lmt, request)\n\tif len(sliceKeys) == 0 {\n\t\tt.Fatal(\"Length of sliceKeys should never be empty.\")\n\t}\n\n\tfor _, keys := range sliceKeys {\n\t\texpectedKeys := [][]string{\n\t\t\t{request.Header.Get(\"X-Real-IP\")},\n\t\t\t{request.URL.Path},\n\t\t\t{\"X-Auth-Token\"},\n\t\t\t{\"totally-top-secret\", \"another-secret\"},\n\t\t}\n\n\t\tcheckKeys(t, keys, expectedKeys)\n\t}\n}\n\nfunc TestRequestMethodBuildKeys(t *testing.T) {\n\tlmt := NewLimiter(1, nil).\n\t\tSetIPLookup(limiter.IPLookup{\n\t\t\tName:           \"X-Real-IP\",\n\t\t\tIndexFromRight: 0,\n\t\t}).\n\t\tSetMethods([]string{\"GET\"})\n\n\trequest, err := http.NewRequest(\"GET\", \"/\", strings.NewReader(\"Hello, world!\"))\n\tif err != nil {\n\t\tt.Errorf(\"Unable to create new HTTP request. Error: %v\", err)\n\t}\n\n\trequest.Header.Set(\"X-Real-IP\", \"2601:7:1c82:4097:59a0:a80b:2841:b8c8\")\n\texpectedIP := \"2601:7:1c82:4097::\"\n\n\tsliceKeys := BuildKeys(lmt, request)\n\tif len(sliceKeys) == 0 {\n\t\tt.Fatal(\"Length of sliceKeys should never be empty.\")\n\t}\n\n\tfor _, keys := range sliceKeys {\n\t\texpectedKeys := [][]string{\n\t\t\t{expectedIP},\n\t\t\t{request.URL.Path},\n\t\t\t{\"GET\"},\n\t\t}\n\n\t\tcheckKeys(t, keys, expectedKeys)\n\t}\n}\n\nfunc TestContextValueBuildKeys(t *testing.T) {\n\tlmt := NewLimiter(1, nil).\n\t\tSetIPLookup(limiter.IPLookup{\n\t\t\tName:           \"X-Real-IP\",\n\t\t\tIndexFromRight: 0,\n\t\t}).\n\t\tSetContextValue(\"API-access-level\", []string{\"basic\"})\n\n\trequest, err := http.NewRequest(\"GET\", \"/\", strings.NewReader(\"Hello, world!\"))\n\tif err != nil {\n\t\tt.Errorf(\"Unable to create new HTTP request. Error: %v\", err)\n\t}\n\n\trequest.Header.Set(\"X-Real-IP\", \"172.217.0.46\")\n\t//nolint:revive,staticcheck // limiter.SetContextValue requires string as a key, so we have to live with that\n\trequest = request.WithContext(context.WithValue(request.Context(), \"API-access-level\", \"basic\"))\n\n\tsliceKeys := BuildKeys(lmt, request)\n\tif len(sliceKeys) == 0 {\n\t\tt.Fatal(\"Length of sliceKeys should never be empty.\")\n\t}\n\n\tfor _, keys := range sliceKeys {\n\t\texpectedKeys := [][]string{\n\t\t\t{request.Header.Get(\"X-Real-IP\")},\n\t\t\t{request.URL.Path},\n\t\t\t{\"API-access-level\"},\n\t\t\t{\"basic\"},\n\t\t}\n\n\t\tcheckKeys(t, keys, expectedKeys)\n\t}\n}\n\nfunc TestRequestMethodAndCustomHeadersBuildKeys(t *testing.T) {\n\tlmt := NewLimiter(1, nil).\n\t\tSetIPLookup(limiter.IPLookup{\n\t\t\tName:           \"X-Real-IP\",\n\t\t\tIndexFromRight: 0,\n\t\t}).\n\t\tSetMethods([]string{\"GET\"}).\n\t\tSetHeader(\"X-Auth-Token\", []string{\"totally-top-secret\", \"another-secret\"})\n\n\trequest, err := http.NewRequest(\"GET\", \"/\", strings.NewReader(\"Hello, world!\"))\n\tif err != nil {\n\t\tt.Errorf(\"Unable to create new HTTP request. Error: %v\", err)\n\t}\n\n\trequest.Header.Set(\"X-Real-IP\", \"2601:7:1c82:4097:59a0:a80b:2841:b8c8\")\n\texpectedIP := \"2601:7:1c82:4097::\"\n\trequest.Header.Set(\"X-Auth-Token\", \"totally-top-secret\")\n\n\tsliceKeys := BuildKeys(lmt, request)\n\tif len(sliceKeys) == 0 {\n\t\tt.Fatal(\"Length of sliceKeys should never be empty.\")\n\t}\n\n\tfor _, keys := range sliceKeys {\n\t\texpectedKeys := [][]string{\n\t\t\t{expectedIP},\n\t\t\t{request.URL.Path},\n\t\t\t{\"GET\"},\n\t\t\t{\"X-Auth-Token\"},\n\t\t\t{\"totally-top-secret\", \"another-secret\"},\n\t\t}\n\n\t\tcheckKeys(t, keys, expectedKeys)\n\t}\n}\n\nfunc TestRequestMethodAndBasicAuthUsersBuildKeys(t *testing.T) {\n\tlmt := NewLimiter(1, nil).\n\t\tSetIPLookup(limiter.IPLookup{\n\t\t\tName:           \"X-Real-IP\",\n\t\t\tIndexFromRight: 0,\n\t\t}).\n\t\tSetMethods([]string{\"GET\"}).\n\t\tSetBasicAuthUsers([]string{\"bro\"})\n\n\trequest, err := http.NewRequest(\"GET\", \"/\", strings.NewReader(\"Hello, world!\"))\n\tif err != nil {\n\t\tt.Errorf(\"Unable to create new HTTP request. Error: %v\", err)\n\t}\n\n\trequest.Header.Set(\"X-Real-IP\", \"172.217.0.46\")\n\trequest.SetBasicAuth(\"bro\", \"tato\")\n\n\tsliceKeys := BuildKeys(lmt, request)\n\tif len(sliceKeys) == 0 {\n\t\tt.Fatal(\"Length of sliceKeys should never be empty.\")\n\t}\n\n\tfor _, keys := range sliceKeys {\n\t\texpectedKeys := [][]string{\n\t\t\t{request.Header.Get(\"X-Real-IP\")},\n\t\t\t{request.URL.Path},\n\t\t\t{\"GET\"},\n\t\t\t{\"bro\"},\n\t\t}\n\n\t\tcheckKeys(t, keys, expectedKeys)\n\t}\n}\n\nfunc TestRequestMethodCustomHeadersAndBasicAuthUsersBuildKeys(t *testing.T) {\n\tlmt := NewLimiter(1, nil).\n\t\tSetIPLookup(limiter.IPLookup{\n\t\t\tName:           \"X-Real-IP\",\n\t\t\tIndexFromRight: 0,\n\t\t}).\n\t\tSetMethods([]string{\"GET\"}).\n\t\tSetHeader(\"X-Auth-Token\", []string{\"totally-top-secret\", \"another-secret\"}).\n\t\tSetBasicAuthUsers([]string{\"bro\"})\n\n\trequest, err := http.NewRequest(\"GET\", \"/\", strings.NewReader(\"Hello, world!\"))\n\tif err != nil {\n\t\tt.Errorf(\"Unable to create new HTTP request. Error: %v\", err)\n\t}\n\n\trequest.Header.Set(\"X-Real-IP\", \"2601:7:1c82:4097:59a0:a80b:2841:b8c8\")\n\texpectedIP := \"2601:7:1c82:4097::\"\n\trequest.Header.Set(\"X-Auth-Token\", \"totally-top-secret\")\n\trequest.SetBasicAuth(\"bro\", \"tato\")\n\n\tsliceKeys := BuildKeys(lmt, request)\n\tif len(sliceKeys) == 0 {\n\t\tt.Fatal(\"Length of sliceKeys should never be empty.\")\n\t}\n\n\tfor _, keys := range sliceKeys {\n\t\texpectedKeys := [][]string{\n\t\t\t{expectedIP},\n\t\t\t{request.URL.Path},\n\t\t\t{\"GET\"},\n\t\t\t{\"X-Auth-Token\"},\n\t\t\t{\"totally-top-secret\", \"another-secret\"},\n\t\t\t{\"bro\"},\n\t\t}\n\n\t\tcheckKeys(t, keys, expectedKeys)\n\t}\n}\n\nfunc TestRequestMethodCustomHeadersAndBasicAuthUsersAndContextValuesBuildKeys(t *testing.T) {\n\tlmt := NewLimiter(1, nil).\n\t\tSetIPLookup(limiter.IPLookup{\n\t\t\tName:           \"X-Real-IP\",\n\t\t\tIndexFromRight: 0,\n\t\t}).\n\t\tSetMethods([]string{\"GET\"}).\n\t\tSetHeader(\"X-Auth-Token\", []string{\"totally-top-secret\", \"another-secret\"}).\n\t\tSetContextValue(\"API-access-level\", []string{\"basic\"}).\n\t\tSetBasicAuthUsers([]string{\"bro\"})\n\n\trequest, err := http.NewRequest(\"GET\", \"/\", strings.NewReader(\"Hello, world!\"))\n\tif err != nil {\n\t\tt.Errorf(\"Unable to create new HTTP request. Error: %v\", err)\n\t}\n\n\trequest.Header.Set(\"X-Real-IP\", \"172.217.0.46\")\n\trequest.Header.Set(\"X-Auth-Token\", \"totally-top-secret\")\n\trequest.SetBasicAuth(\"bro\", \"tato\")\n\t//nolint:revive,staticcheck // limiter.SetContextValue requires string as a key, so we have to live with that\n\trequest = request.WithContext(context.WithValue(request.Context(), \"API-access-level\", \"basic\"))\n\n\tsliceKeys := BuildKeys(lmt, request)\n\tif len(sliceKeys) == 0 {\n\t\tt.Fatal(\"Length of sliceKeys should never be empty.\")\n\t}\n\n\tfor _, keys := range sliceKeys {\n\t\texpectedKeys := [][]string{\n\t\t\t{request.Header.Get(\"X-Real-IP\")},\n\t\t\t{request.URL.Path},\n\t\t\t{\"GET\"},\n\t\t\t{\"X-Auth-Token\"},\n\t\t\t{\"totally-top-secret\", \"another-secret\"},\n\t\t\t{\"API-access-level\"},\n\t\t\t{\"basic\"},\n\t\t\t{\"bro\"},\n\t\t}\n\n\t\tcheckKeys(t, keys, expectedKeys)\n\t}\n}\n\nfunc TestLimitHandler(t *testing.T) {\n\tlmt := limiter.New(nil).SetMax(1).SetBurst(1).\n\t\tSetIPLookup(limiter.IPLookup{\n\t\t\tName:           \"X-Real-IP\",\n\t\t\tIndexFromRight: 0,\n\t\t}).\n\t\tSetMethods([]string{\"POST\"})\n\n\tcounter := 0\n\tlmt.SetOnLimitReached(func(http.ResponseWriter, *http.Request) { counter++ })\n\n\thandler := LimitHandler(lmt, http.HandlerFunc(func(w http.ResponseWriter, _ *http.Request) {\n\t\tw.Write([]byte(`hello world`))\n\t}))\n\n\treq, err := http.NewRequest(\"POST\", \"/doesntmatter\", nil)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\treq.Header.Set(\"X-Real-IP\", \"2601:7:1c82:4097:59a0:a80b:2841:b8c8\")\n\n\trr := httptest.NewRecorder()\n\thandler.ServeHTTP(rr, req)\n\t// Should not be limited\n\tif status := rr.Code; status != http.StatusOK {\n\t\tt.Errorf(\"handler returned wrong status code: got %v want %v\", status, http.StatusOK)\n\t}\n\t// check RateLimit headers\n\tif value := rr.Result().Header[http.CanonicalHeaderKey(\"RateLimit-Limit\")]; len(value) < 1 || value[0] != \"1\" {\n\t\tt.Errorf(\"handler returned wrong value: got %s want %s\", value, \"1\")\n\t}\n\tif value := rr.Result().Header[http.CanonicalHeaderKey(\"RateLimit-Reset\")]; len(value) < 1 || value[0] != \"1\" {\n\t\tt.Errorf(\"handler returned wrong value: got %s want %s\", value, \"1\")\n\t}\n\tif value := rr.Result().Header[http.CanonicalHeaderKey(\"RateLimit-Remaining\")]; len(value) < 1 || value[0] != \"0\" {\n\t\tt.Errorf(\"handler returned wrong value: got %s want %s\", value, \"0\")\n\t}\n\n\tch := make(chan int)\n\tgo func() {\n\t\t// Different address, same /64 prefix\n\t\treq.Header.Set(\"X-Real-IP\", \"2601:7:1c82:4097:59a0:a80b:2841:b8c9\")\n\n\t\trr := httptest.NewRecorder()\n\t\thandler.ServeHTTP(rr, req)\n\t\t// Should be limited\n\t\tif status := rr.Code; status != http.StatusTooManyRequests {\n\t\t\tt.Errorf(\"handler returned wrong status code: got %v want %v\", status, http.StatusTooManyRequests)\n\t\t}\n\t\t// check X-Rate-Limit headers\n\t\tif value := rr.Result().Header[http.CanonicalHeaderKey(\"X-Rate-Limit-Limit\")]; len(value) < 1 || value[0] != \"1.00\" {\n\t\t\tt.Errorf(\"X-Rate-Limit-Limit has wrong value: got %s want %v\", value, \"1.00\")\n\t\t}\n\t\tif value := rr.Result().Header[http.CanonicalHeaderKey(\"X-Rate-Limit-Duration\")]; len(value) < 1 || value[0] != \"1\" {\n\t\t\tt.Errorf(\"X-Rate-Limit-Duration has wrong value: got %s want %v\", value, \"1\")\n\t\t}\n\t\t// check RateLimit headers\n\t\tif value := rr.Result().Header[http.CanonicalHeaderKey(\"RateLimit-Limit\")]; len(value) < 1 || value[0] != \"1\" {\n\t\t\tt.Errorf(\"RateLimit-Limit has wrong value: got %s want %v\", value, \"1\")\n\t\t}\n\t\tif value := rr.Result().Header[http.CanonicalHeaderKey(\"RateLimit-Reset\")]; len(value) < 1 || value[0] != \"1\" {\n\t\t\tt.Errorf(\"RateLimit-Reset has wrong value: got %s want %v\", value, \"1\")\n\t\t}\n\t\tif value := rr.Result().Header[http.CanonicalHeaderKey(\"RateLimit-Remaining\")]; len(value) < 1 || value[0] != \"0\" {\n\t\t\tt.Errorf(\"RateLimit-Remaining has wrong value: got %s want %v\", value, \"0\")\n\t\t}\n\t\t// OnLimitReached should be called\n\t\tif counter != 1 {\n\t\t\tt.Errorf(\"onLimitReached was not called\")\n\t\t}\n\t\tclose(ch)\n\t}()\n\t<-ch // Block until go func is done.\n}\n\nfunc TestOverrideForResponseWriter(t *testing.T) {\n\tlmt := limiter.New(nil).SetMax(1).SetBurst(1).\n\t\tSetIPLookup(limiter.IPLookup{\n\t\t\tName:           \"X-Real-IP\",\n\t\t\tIndexFromRight: 0,\n\t\t}).\n\t\tSetMethods([]string{\"POST\"}).\n\t\tSetOverrideDefaultResponseWriter(true)\n\n\tcounter := 0\n\tlmt.SetOnLimitReached(func(w http.ResponseWriter, _ *http.Request) {\n\t\tw.Header().Add(\"Content-Type\", \"application/json\")\n\t\tw.WriteHeader(http.StatusNotAcceptable)\n\t\tw.Write([]byte(\"rejecting the large amount of requests\"))\n\t\tcounter++\n\t})\n\n\thandler := LimitHandler(lmt, http.HandlerFunc(func(w http.ResponseWriter, _ *http.Request) {\n\t\tw.Write([]byte(`hello world`))\n\t}))\n\n\treq, err := http.NewRequest(\"POST\", \"/doesntmatter\", nil)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\treq.Header.Set(\"X-Real-IP\", \"172.217.0.46\")\n\n\trr := httptest.NewRecorder()\n\thandler.ServeHTTP(rr, req)\n\t// Should not be limited\n\tif status := rr.Code; status != http.StatusOK {\n\t\tt.Errorf(\"handler returned wrong status code: got %v want %v\", status, http.StatusOK)\n\t}\n\n\tch := make(chan int)\n\tgo func() {\n\t\trr := httptest.NewRecorder()\n\t\thandler.ServeHTTP(rr, req)\n\t\t// Should be limited\n\t\tif status := rr.Code; status != http.StatusNotAcceptable {\n\t\t\tt.Errorf(\"handler returned wrong status code: got %v want %v\", status, http.StatusNotAcceptable)\n\t\t}\n\t\t// OnLimitReached should be called\n\t\tif counter != 1 {\n\t\t\tt.Errorf(\"onLimitReached was not called\")\n\t\t}\n\t\tclose(ch)\n\t}()\n\t<-ch // Block until go func is done.\n}\n\nfunc checkKeys(t *testing.T, keys []string, expectedKeys [][]string) {\n\tfor i, keyChunk := range keys {\n\t\tswitch {\n\t\tcase i == 0 && !isInSlice(keyChunk, expectedKeys[0]):\n\t\t\tt.Errorf(\"The (%v) chunk should be remote IP. KeyChunk: %v\", i+1, keyChunk)\n\t\tcase i == 1 && !isInSlice(keyChunk, expectedKeys[1]):\n\t\t\tt.Errorf(\"The (%v) chunk should be request path. KeyChunk: %v\", i+1, keyChunk)\n\t\t}\n\t}\n\n\tfor _, ekeys := range expectedKeys {\n\t\tfound := false\n\t\tfor _, ekey := range ekeys {\n\t\t\tfor _, key := range keys {\n\t\t\t\tif ekey == key {\n\t\t\t\t\tfound = true\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif !found {\n\t\t\tt.Fatalf(\"expectedKeys missing: %v\", strings.Join(ekeys, \" \"))\n\t\t}\n\t}\n}\n\nfunc isInSlice(key string, keys []string) bool {\n\tfor _, sliceKey := range keys {\n\t\tif key == sliceKey {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\ntype LockMap struct {\n\tm map[string]int64\n\tsync.Mutex\n}\n\nfunc (lm *LockMap) Set(key string, value int64) {\n\tlm.Lock()\n\tlm.m[key] = value\n\tlm.Unlock()\n}\n\nfunc (lm *LockMap) Get(key string) (int64, bool) {\n\tlm.Lock()\n\tvalue, ok := lm.m[key]\n\tlm.Unlock()\n\treturn value, ok\n}\n\nfunc (lm *LockMap) Add(key string, incr int64) {\n\tlm.Lock()\n\tif val, ok := lm.m[key]; ok {\n\t\tlm.m[key] = val + incr\n\t} else {\n\t\tlm.m[key] = incr\n\t}\n\tlm.Unlock()\n}\n\nfunc TestLimitHandlerEmptyHeader(t *testing.T) {\n\tlmt := limiter.New(nil).SetMax(1).SetBurst(1)\n\tlmt.SetIPLookup(limiter.IPLookup{\n\t\tName:           \"X-Real-IP\",\n\t\tIndexFromRight: 0,\n\t})\n\tlmt.SetMethods([]string{\"POST\"})\n\tlmt.SetHeader(\"user_id\", []string{})\n\n\tcounterMap := &LockMap{m: map[string]int64{}}\n\tlmt.SetOnLimitReached(func(w http.ResponseWriter, r *http.Request) {\n\t\t_, _ = w, r\n\t\tcounterMap.Add(r.Header.Get(\"user_id\"), 1)\n\t})\n\n\thandler := LimitHandler(lmt, http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\t_ = r\n\t\tw.Write([]byte(`hello world`))\n\t}))\n\n\treq, err := http.NewRequest(\"POST\", \"/doesntmatter\", nil)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\treq.Header.Set(\"X-Real-IP\", \"2601:7:1c82:4097:59a0:a80b:2841:b8c8\")\n\treq.Header.Set(\"user_id\", \"0\")\n\n\trr := httptest.NewRecorder()\n\thandler.ServeHTTP(rr, req)\n\t{ // Should not be limited\n\t\tif status := rr.Code; status != http.StatusOK {\n\t\t\tt.Errorf(\"handler returned wrong status code: got %v want %v\", status, http.StatusOK)\n\t\t}\n\t\t// check RateLimit headers\n\t\tif value := rr.Result().Header[http.CanonicalHeaderKey(\"RateLimit-Limit\")]; len(value) < 1 || value[0] != \"1\" {\n\t\t\tt.Errorf(\"handler returned wrong value: got %s want %s\", value, \"1\")\n\t\t}\n\t\tif value := rr.Result().Header[http.CanonicalHeaderKey(\"RateLimit-Reset\")]; len(value) < 1 || value[0] != \"1\" {\n\t\t\tt.Errorf(\"handler returned wrong value: got %s want %s\", value, \"1\")\n\t\t}\n\t\tif value := rr.Result().Header[http.CanonicalHeaderKey(\"RateLimit-Remaining\")]; len(value) < 1 || value[0] != \"0\" {\n\t\t\tt.Errorf(\"handler returned wrong value: got %s want %s\", value, \"0\")\n\t\t}\n\t}\n\n\twg := sync.WaitGroup{}\n\twg.Add(1)\n\n\t// same user_id, should be limited\n\tgo func() {\n\t\tdefer wg.Done()\n\n\t\treq1, _ := http.NewRequest(\"POST\", \"/doesntmatter\", nil)\n\t\treq1.Header.Set(\"X-Real-IP\", \"2601:7:1c82:4097:59a0:a80b:2841:b8c8\")\n\t\treq1.Header.Set(\"user_id\", \"0\")\n\t\trr := httptest.NewRecorder()\n\t\thandler.ServeHTTP(rr, req1)\n\t\t// Should be limited\n\t\t{\n\t\t\tif status := rr.Code; status != http.StatusTooManyRequests {\n\t\t\t\tt.Errorf(\"handler returned wrong status code: got %v want %v\", status, http.StatusTooManyRequests)\n\t\t\t}\n\t\t\t// check X-Rate-Limit headers\n\t\t\tif value := rr.Result().Header[http.CanonicalHeaderKey(\"X-Rate-Limit-Limit\")]; len(value) < 1 || value[0] != \"1.00\" {\n\t\t\t\tt.Errorf(\"X-Rate-Limit-Limit has wrong value: got %s want %v\", value, \"1.00\")\n\t\t\t}\n\t\t\tif value := rr.Result().Header[http.CanonicalHeaderKey(\"X-Rate-Limit-Duration\")]; len(value) < 1 || value[0] != \"1\" {\n\t\t\t\tt.Errorf(\"X-Rate-Limit-Duration has wrong value: got %s want %v\", value, \"1\")\n\t\t\t}\n\t\t\t// check RateLimit headers\n\t\t\tif value := rr.Result().Header[http.CanonicalHeaderKey(\"RateLimit-Limit\")]; len(value) < 1 || value[0] != \"1\" {\n\t\t\t\tt.Errorf(\"RateLimit-Limit has wrong value: got %s want %v\", value, \"1\")\n\t\t\t}\n\t\t\tif value := rr.Result().Header[http.CanonicalHeaderKey(\"RateLimit-Reset\")]; len(value) < 1 || value[0] != \"1\" {\n\t\t\t\tt.Errorf(\"RateLimit-Reset has wrong value: got %s want %v\", value, \"1\")\n\t\t\t}\n\t\t\tif value := rr.Result().Header[http.CanonicalHeaderKey(\"RateLimit-Remaining\")]; len(value) < 1 || value[0] != \"0\" {\n\t\t\t\tt.Errorf(\"RateLimit-Remaining has wrong value: got %s want %v\", value, \"0\")\n\t\t\t}\n\t\t\t// OnLimitReached should be called\n\t\t\tif aint, ok := counterMap.Get(req1.Header.Get(\"user_id\")); ok {\n\t\t\t\tif aint == 0 {\n\t\t\t\t\tt.Errorf(\"onLimitReached was not called\")\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}()\n\n\twg.Wait() // Block until go func is done.\n}\n\nfunc TestHTTPMiddleware(t *testing.T) {\n\tt.Run(\"basic request\", func(t *testing.T) {\n\t\tlmt := NewLimiter(1, nil)\n\t\thandler := http.HandlerFunc(func(w http.ResponseWriter, _ *http.Request) {\n\t\t\tw.WriteHeader(http.StatusOK)\n\t\t})\n\t\twrapped := HTTPMiddleware(lmt)(handler)\n\t\tw := httptest.NewRecorder()\n\t\tr := httptest.NewRequest(http.MethodGet, \"/test\", nil)\n\t\tr.RemoteAddr = \"127.0.0.1:12345\"\n\t\twrapped.ServeHTTP(w, r)\n\t\tif w.Code != http.StatusOK {\n\t\t\tt.Errorf(\"expected status %d, got %d\", http.StatusOK, w.Code)\n\t\t}\n\t})\n\n\tt.Run(\"rate limit exceeded\", func(t *testing.T) {\n\t\tlmt := NewLimiter(0.1, nil) // only allow one request per 10 seconds\n\t\thandler := http.HandlerFunc(func(w http.ResponseWriter, _ *http.Request) {\n\t\t\tw.WriteHeader(http.StatusOK)\n\t\t})\n\t\twrapped := HTTPMiddleware(lmt)(handler)\n\n\t\t// first request\n\t\tw1 := httptest.NewRecorder()\n\t\tr1 := httptest.NewRequest(http.MethodGet, \"/test\", nil)\n\t\tr1.RemoteAddr = \"127.0.0.1:12345\"\n\t\twrapped.ServeHTTP(w1, r1)\n\t\tif w1.Code != http.StatusOK {\n\t\t\tt.Errorf(\"first request: expected status %d, got %d\", http.StatusOK, w1.Code)\n\t\t}\n\n\t\t// immediate second request should fail\n\t\tw2 := httptest.NewRecorder()\n\t\tr2 := httptest.NewRequest(http.MethodGet, \"/test\", nil)\n\t\tr2.RemoteAddr = \"127.0.0.1:12345\"\n\t\twrapped.ServeHTTP(w2, r2)\n\t\tif w2.Code != http.StatusTooManyRequests {\n\t\t\tt.Errorf(\"second request: expected status %d, got %d\", http.StatusTooManyRequests, w2.Code)\n\t\t}\n\t\tif !strings.Contains(w2.Body.String(), \"maximum request limit\") {\n\t\t\tt.Errorf(\"expected error message containing 'maximum request limit', got %q\", w2.Body.String())\n\t\t}\n\t})\n\n\tt.Run(\"context cancelled\", func(t *testing.T) {\n\t\tlmt := NewLimiter(1, nil)\n\t\thandler := http.HandlerFunc(func(w http.ResponseWriter, _ *http.Request) {\n\t\t\tw.WriteHeader(http.StatusOK)\n\t\t})\n\t\twrapped := HTTPMiddleware(lmt)(handler)\n\t\tw := httptest.NewRecorder()\n\t\tr := httptest.NewRequest(http.MethodGet, \"/test\", nil)\n\t\tctx, cancel := context.WithCancel(r.Context())\n\t\tcancel()\n\t\tr = r.WithContext(ctx)\n\t\twrapped.ServeHTTP(w, r)\n\t\tif w.Code != http.StatusServiceUnavailable {\n\t\t\tt.Errorf(\"expected status %d, got %d\", http.StatusServiceUnavailable, w.Code)\n\t\t}\n\t\tif !strings.Contains(w.Body.String(), \"Context was canceled\") {\n\t\t\tt.Errorf(\"expected error message containing 'Context was canceled', got %q\", w.Body.String())\n\t\t}\n\t})\n\n\tt.Run(\"custom error handler\", func(t *testing.T) {\n\t\tlmt := NewLimiter(0.1, nil) // only allow one request per 10 seconds\n\t\tcustomMsg := \"custom limit reached\"\n\t\tlmt.SetMessage(customMsg)\n\n\t\thandler := http.HandlerFunc(func(w http.ResponseWriter, _ *http.Request) {\n\t\t\tw.WriteHeader(http.StatusOK)\n\t\t})\n\t\twrapped := HTTPMiddleware(lmt)(handler)\n\n\t\t// first request\n\t\tw1 := httptest.NewRecorder()\n\t\tr1 := httptest.NewRequest(http.MethodGet, \"/test\", nil)\n\t\tr1.RemoteAddr = \"127.0.0.1:12345\"\n\t\twrapped.ServeHTTP(w1, r1)\n\t\tif w1.Code != http.StatusOK {\n\t\t\tt.Errorf(\"first request: expected status %d, got %d\", http.StatusOK, w1.Code)\n\t\t}\n\n\t\t// immediate second request should fail\n\t\tw2 := httptest.NewRecorder()\n\t\tr2 := httptest.NewRequest(http.MethodGet, \"/test\", nil)\n\t\tr2.RemoteAddr = \"127.0.0.1:12345\"\n\t\twrapped.ServeHTTP(w2, r2)\n\t\tif w2.Code != http.StatusTooManyRequests {\n\t\t\tt.Errorf(\"second request: expected status %d, got %d\", http.StatusTooManyRequests, w2.Code)\n\t\t}\n\t\tif !strings.Contains(w2.Body.String(), customMsg) {\n\t\t\tt.Errorf(\"expected error message containing %q, got %q\", customMsg, w2.Body.String())\n\t\t}\n\t})\n\n\tt.Run(\"custom IP lookup\", func(t *testing.T) {\n\t\tlmt := NewLimiter(0.1, nil)\n\t\tlmt.SetIPLookup(limiter.IPLookup{Name: \"X-Real-IP\"})\n\t\thandler := http.HandlerFunc(func(w http.ResponseWriter, _ *http.Request) {\n\t\t\tw.WriteHeader(http.StatusOK)\n\t\t})\n\t\twrapped := HTTPMiddleware(lmt)(handler)\n\n\t\t// first request with IP1\n\t\tw1 := httptest.NewRecorder()\n\t\tr1 := httptest.NewRequest(http.MethodGet, \"/test\", nil)\n\t\tr1.Header.Set(\"X-Real-IP\", \"5.5.5.5\")\n\t\twrapped.ServeHTTP(w1, r1)\n\t\tif w1.Code != http.StatusOK {\n\t\t\tt.Errorf(\"first request: expected status %d, got %d\", http.StatusOK, w1.Code)\n\t\t}\n\n\t\t// second request with IP1 should fail\n\t\tw2 := httptest.NewRecorder()\n\t\tr2 := httptest.NewRequest(http.MethodGet, \"/test\", nil)\n\t\tr2.Header.Set(\"X-Real-IP\", \"5.5.5.5\")\n\t\twrapped.ServeHTTP(w2, r2)\n\t\tif w2.Code != http.StatusTooManyRequests {\n\t\t\tt.Errorf(\"second request: expected status %d, got %d\", http.StatusTooManyRequests, w2.Code)\n\t\t}\n\n\t\t// request with IP2 should pass\n\t\tw3 := httptest.NewRecorder()\n\t\tr3 := httptest.NewRequest(http.MethodGet, \"/test\", nil)\n\t\tr3.Header.Set(\"X-Real-IP\", \"6.6.6.6\")\n\t\twrapped.ServeHTTP(w3, r3)\n\t\tif w3.Code != http.StatusOK {\n\t\t\tt.Errorf(\"third request: expected status %d, got %d\", http.StatusOK, w3.Code)\n\t\t}\n\t})\n}\n"
        }
      ]
    }
  ]
}