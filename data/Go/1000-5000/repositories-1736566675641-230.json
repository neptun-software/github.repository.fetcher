{
  "metadata": {
    "timestamp": 1736566675641,
    "page": 230,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjIzMA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "uber-archive/go-torch",
      "stars": 3959,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".dockerignore",
          "type": "blob",
          "size": 0.0068359375,
          "content": "vendor\n"
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.060546875,
          "content": "go-torch\n\n*.test\n*.svg\n\n*.log\n*.tmp\n\nGodeps/_workspace\nvendor\n"
        },
        {
          "name": ".test-cover.sh",
          "type": "blob",
          "size": 0.5341796875,
          "content": "#!/bin/bash\n\nset -x\n\nexport GO15VENDOREXPERIMENT=1\n\necho \"mode: set\" > acc.out\nFAIL=0\n\n# List all packages to run tests for\nPACKAGES=$(glide novendor)\ngo test -i $PACKAGES\nfor dir in $PACKAGES;\ndo\n  go test -coverprofile=profile.out $dir || FAIL=$?\n  if [ -f profile.out ]\n  then\n    cat profile.out | grep -v \"mode: set\" | grep -v \"mocks.go\" >> acc.out\n    rm profile.out\n  fi\ndone\n\n# Failures have incomplete results, so don't send\nif [ \"$FAIL\" -eq 0 ]; then\n  goveralls -service=travis-ci -v -coverprofile=acc.out\nfi\n\nrm -f acc.out\n\nexit $FAIL\n"
        },
        {
          "name": ".travis.yml",
          "type": "blob",
          "size": 0.2548828125,
          "content": "---\nlanguage: go\n\n# 1.4 will probably work, but we don't test it since we use vendor.\ngo:\n  - 1.5\n  - 1.6\n  - 1.7\n  - tip\n\ninstall:\n  - go get github.com/Masterminds/glide\n  - go get -u github.com/mattn/goveralls\n  - glide install\n\nscript:\n  - ./.test-cover.sh\n"
        },
        {
          "name": "Dockerfile",
          "type": "blob",
          "size": 0.6953125,
          "content": "FROM golang:1.9-alpine\n\nENV PATH $PATH:/opt/flamegraph\nENV FLAMEGRAPH_SHA a93d905911c07c96a73b35ddbcb5ddb2f39da4b6\n\nRUN apk --update add git && \\\n    apk add curl && \\\n    curl -OL https://github.com/Masterminds/glide/releases/download/v0.12.3/glide-v0.12.3-linux-amd64.tar.gz && \\\n    tar -xzf glide-v0.12.3-linux-amd64.tar.gz && \\\n    mv linux-amd64/glide /usr/bin && \\\n    apk add perl && \\\n    git clone git://github.com/brendangregg/FlameGraph.git /opt/flamegraph && \\\n    ( cd /opt/flamegraph && \\\n      git reset --hard $FLAMEGRAPH_SHA && \\\n      rm -rf .git )\n\nCOPY . /go/src/github.com/uber/go-torch\n\nRUN cd /go/src/github.com/uber/go-torch && glide install && go install ./...\n\nENTRYPOINT [\"go-torch\"]\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.0498046875,
          "content": "Copyright (c) [INSERT_YEAR] Uber Technologies, Inc.\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE."
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 5.8671875,
          "content": "# go-torch [![Build Status](https://travis-ci.org/uber/go-torch.svg?branch=master)](https://travis-ci.org/uber/go-torch) [![Coverage Status](http://coveralls.io/repos/uber/go-torch/badge.svg?branch=master&service=github)](http://coveralls.io/github/uber/go-torch?branch=master) [![GoDoc](https://godoc.org/github.com/uber/go-torch?status.svg)](https://godoc.org/github.com/uber/go-torch)\n\n## go-torch is deprecated, use pprof instead\n\nAs of Go 1.11, flamegraph visualizations are available in `go tool pprof` directly!\n\n```\n# This will listen on :8081 and open a browser.\n# Change :8081 to a port of your choice.\n$ go tool pprof -http=\":8081\" [binary] [profile]\n```\n\nIf you cannot use Go 1.11, you can get the latest `pprof` tool and use it instead:\n\n```\n# Get the pprof tool directly\n$ go get -u github.com/google/pprof\n\n$ pprof -http=\":8081\" [binary] [profile]\n```\n\n## Synopsis\n\nTool for stochastically profiling Go programs. Collects stack traces and\nsynthesizes them into a flame graph. Uses Go's built in [pprof][] library.\n\n[pprof]: https://golang.org/pkg/net/http/pprof/\n\n## Example Flame Graph\n\n[![Inception](http://uber.github.io/go-torch/meta.svg)](http://uber.github.io/go-torch/meta.svg)\n\n## Basic Usage\n\n```\n$ go-torch -h\nUsage:\n  go-torch [options] [binary] <profile source>\n\npprof Options:\n  -u, --url=         Base URL of your Go program (default: http://localhost:8080)\n  -s, --suffix=      URL path of pprof profile (default: /debug/pprof/profile)\n  -b, --binaryinput= File path of previously saved binary profile. (binary profile is anything accepted by https://golang.org/cmd/pprof)\n      --binaryname=  File path of the binary that the binaryinput is for, used for pprof inputs\n  -t, --seconds=     Number of seconds to profile for (default: 30)\n      --pprofArgs=   Extra arguments for pprof\n\nOutput Options:\n  -f, --file=        Output file name (must be .svg) (default: torch.svg)\n  -p, --print        Print the generated svg to stdout instead of writing to file\n  -r, --raw          Print the raw call graph output to stdout instead of creating a flame graph; use with Brendan Gregg's flame graph perl script (see https://github.com/brendangregg/FlameGraph)\n      --title=       Graph title to display in the output file (default: Flame Graph)\n      --width=       Generated graph width (default: 1200)\n      --hash         Colors are keyed by function name hash\n      --colors=      Set color palette. Valid choices are: hot (default), mem, io, wakeup, chain, java,\n                     js, perl, red, green, blue, aqua, yellow, purple, orange\n      --hash         Graph colors are keyed by function name hash\n      --cp           Graph use consistent palette (palette.map)\n      --inverted     Icicle graph\nHelp Options:\n  -h, --help         Show this help message\n```\n\n### Write flamegraph using /debug/pprof endpoint\n\nThe default options will hit `http://localhost:8080/debug/pprof/profile` for\na 30 second CPU profile, and write it out to torch.svg\n\n```\n$ go-torch\nINFO[19:10:58] Run pprof command: go tool pprof -raw -seconds 30 http://localhost:8080/debug/pprof/profile\nINFO[19:11:03] Writing svg to torch.svg\n```\n\nYou can customize the base URL by using `-u`\n\n```\n$ go-torch -u http://my-service:8080/\nINFO[19:10:58] Run pprof command: go tool pprof -raw -seconds 30 http://my-service:8080/debug/pprof/profile\nINFO[19:11:03] Writing svg to torch.svg\n```\n\nOr change the number of seconds to profile using `--seconds`:\n\n```\n$ go-torch --seconds 5\nINFO[19:10:58] Run pprof command: go tool pprof -raw -seconds 5 http://localhost:8080/debug/pprof/profile\nINFO[19:11:03] Writing svg to torch.svg\n```\n\n\n### Using pprof arguments\n\n`go-torch` will pass through arguments to `go tool pprof`, which lets you take\nexisting pprof commands and easily make them work with `go-torch`.\n\nFor example, after creating a CPU profile from a benchmark:\n```\n$ go test -bench . -cpuprofile=cpu.prof\n\n# This creates a cpu.prof file, and the $PKG.test binary.\n```\n\nThe same arguments that can be used with `go tool pprof` will also work\nwith `go-torch`:\n```\n$ go tool pprof main.test cpu.prof\n\n# Same arguments work with go-torch\n$ go-torch main.test cpu.prof\nINFO[19:00:29] Run pprof command: go tool pprof -raw -seconds 30 main.test cpu.prof\nINFO[19:00:29] Writing svg to torch.svg\n```\n\n\nFlags that are not handled by `go-torch` are passed through as well:\n```\n$ go-torch --alloc_objects main.test mem.prof\nINFO[19:00:29] Run pprof command: go tool pprof -raw -seconds 30 --alloc_objects main.test mem.prof\nINFO[19:00:29] Writing svg to torch.svg\n```\n\n## Integrating With Your Application\n\nTo add profiling endpoints in your application, follow the official\nGo docs [here][].\nIf your application is already running a server on the DefaultServeMux,\njust add this import to your application.\n\n[here]: https://golang.org/pkg/net/http/pprof/\n\n```go\nimport _ \"net/http/pprof\"\n```\n\nIf your application is not using the DefaultServeMux, you can still easily\nexpose pprof endpoints by manually registering the net/http/pprof handlers or by\nusing a library like [this one](https://github.com/e-dard/netbug).\n\n## Installation\n\n```\n$ go get github.com/uber/go-torch\n```\n\nYou can also use go-torch using docker:\n```\n$ docker run uber/go-torch -u http://[address-of-host] -p > torch.svg\n```\n\nUsing `-p` will print the SVG to standard out, which can then be redirected\nto a file. This avoids mounting volumes to a container.\n\n### Get the flame graph script:\n\nWhen using the `go-torch` binary locally, you will need the Flamegraph scripts\nin your `PATH`:\n\n```\n$ cd $GOPATH/src/github.com/uber/go-torch\n$ git clone https://github.com/brendangregg/FlameGraph.git\n```\n\n## Development and Testing\n\n### Install the Go dependencies:\n\n```\n$ go get github.com/Masterminds/glide\n$ cd $GOPATH/src/github.com/uber/go-torch\n$ glide install\n```\n\n### Run the Tests\n\n```\n$ go test ./...\nok    github.com/uber/go-torch   0.012s\nok    github.com/uber/go-torch/graph   0.017s\nok    github.com/uber/go-torch/visualization 0.052s\n```\n"
        },
        {
          "name": "glide.lock",
          "type": "blob",
          "size": 0.919921875,
          "content": "hash: e02633304cb0e642a7f236a49dd73b0c5b9bddb3e2b35272191bdc16c6e62baa\nupdated: 2017-01-18T09:23:43.933063939-08:00\nimports:\n- name: github.com/fatih/color\n  version: 42c364ba490082e4815b5222728711b3440603eb\n- name: github.com/jessevdk/go-flags\n  version: 4e64e4a4e2552194cf594243e23aa9baf3b4297e\n- name: github.com/mattn/go-colorable\n  version: d228849504861217f796da67fae4f6e347643f15\n- name: github.com/mattn/go-isatty\n  version: 30a891c33c7cde7b02a981314b4228ec99380cca\n- name: golang.org/x/sys\n  version: d75a52659825e75fff6158388dddc6a5b04f9ba5\n  subpackages:\n  - unix\ntestImports:\n- name: github.com/davecgh/go-spew\n  version: 04cdfd42973bb9c8589fd6a731800cf222fde1a9\n  subpackages:\n  - spew\n- name: github.com/pmezard/go-difflib\n  version: d8ed2627bdf02c080bf22230dbb337003b7aba2d\n  subpackages:\n  - difflib\n- name: github.com/stretchr/testify\n  version: 2402e8e7a02fc811447d11f881aa9746cdc57983\n  subpackages:\n  - assert\n  - require\n"
        },
        {
          "name": "glide.yaml",
          "type": "blob",
          "size": 0.2041015625,
          "content": "package: github.com/uber/go-torch\nimport:\n- package: github.com/fatih/color\n- package: github.com/jessevdk/go-flags\ntestImport:\n- package: github.com/stretchr/testify\n  subpackages:\n    - assert\n    - require\n"
        },
        {
          "name": "main.go",
          "type": "blob",
          "size": 6.1083984375,
          "content": "// Copyright (c) 2015 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n// Package main is the entry point of go-torch, a stochastic flame graph\n// profiler for Go programs.\npackage main\n\nimport (\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"os\"\n\t\"strconv\"\n\t\"strings\"\n\n\t\"github.com/uber/go-torch/pprof\"\n\t\"github.com/uber/go-torch/renderer\"\n\t\"github.com/uber/go-torch/torchlog\"\n\n\tgflags \"github.com/jessevdk/go-flags\"\n)\n\n// options are the parameters for go-torch.\ntype options struct {\n\tPProfOptions pprof.Options `group:\"pprof Options\"`\n\tOutputOpts   outputOptions `group:\"Output Options\"`\n}\n\ntype outputOptions struct {\n\tFile              string `short:\"f\" long:\"file\" default:\"torch.svg\" description:\"Output file name (must be .svg)\"`\n\tPrint             bool   `short:\"p\" long:\"print\" description:\"Print the generated svg to stdout instead of writing to file\"`\n\tRaw               bool   `short:\"r\" long:\"raw\" description:\"Print the raw call graph output to stdout instead of creating a flame graph; use with Brendan Gregg's flame graph perl script (see https://github.com/brendangregg/FlameGraph)\"`\n\tTitle             string `long:\"title\" default:\"Flame Graph\" description:\"Graph title to display in the output file\"`\n\tWidth             int64  `long:\"width\" default:\"1200\" description:\"Generated graph width\"`\n\tHash              bool   `long:\"hash\" description:\"Colors are keyed by function name hash\"`\n\tColors            string `long:\"colors\" default:\"\" description:\"set color palette. choices are: hot (default), mem, io, wakeup, chain, java, js, perl, red, green, blue, aqua, yellow, purple, orange\"`\n\tConsistentPalette bool   `long:\"cp\" description:\"Use consistent palette (palette.map)\"`\n\tReverse           bool   `long:\"reverse\" description:\"Generate stack-reversed flame graph\"`\n\tInverted          bool   `long:\"inverted\" description:\"icicle graph\"`\n}\n\n// main is the entry point of the application\nfunc main() {\n\tif err := runWithArgs(os.Args[1:]...); err != nil {\n\t\ttorchlog.Fatalf(\"Failed: %v\", err)\n\t}\n}\n\nfunc runWithArgs(args ...string) error {\n\topts := &options{}\n\n\tparser := gflags.NewParser(opts, gflags.Default|gflags.IgnoreUnknown)\n\tparser.Usage = \"[options] [binary] <profile source>\"\n\n\tremaining, err := parser.ParseArgs(args)\n\tif err != nil {\n\t\tif flagErr, ok := err.(*gflags.Error); ok && flagErr.Type == gflags.ErrHelp {\n\t\t\tos.Exit(0)\n\t\t}\n\t\treturn fmt.Errorf(\"could not parse options: %v\", err)\n\t}\n\tif err := validateOptions(opts); err != nil {\n\t\treturn fmt.Errorf(\"invalid options: %v\", err)\n\t}\n\n\treturn runWithOptions(opts, remaining)\n}\n\nfunc runWithOptions(allOpts *options, remaining []string) error {\n\tpprofRawOutput, err := pprof.GetRaw(allOpts.PProfOptions, remaining)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"could not get raw output from pprof: %v\", err)\n\t}\n\n\tprofile, err := pprof.ParseRaw(pprofRawOutput)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"could not parse raw pprof output: %v\", err)\n\t}\n\n\tsampleIndex := pprof.SelectSample(remaining, profile.SampleNames)\n\tflameInput, err := renderer.ToFlameInput(profile, sampleIndex)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"could not convert stacks to flamegraph input: %v\", err)\n\t}\n\n\topts := allOpts.OutputOpts\n\tif opts.Raw {\n\t\ttorchlog.Print(\"Printing raw flamegraph input to stdout\")\n\t\tfmt.Printf(\"%s\\n\", flameInput)\n\t\treturn nil\n\t}\n\n\tvar flameGraphArgs = buildFlameGraphArgs(opts)\n\tflameGraph, err := renderer.GenerateFlameGraph(flameInput, flameGraphArgs...)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"could not generate flame graph: %v\", err)\n\t}\n\n\tif opts.Print {\n\t\ttorchlog.Print(\"Printing svg to stdout\")\n\t\tfmt.Printf(\"%s\\n\", flameGraph)\n\t\treturn nil\n\t}\n\n\ttorchlog.Printf(\"Writing svg to %v\", opts.File)\n\tif err := ioutil.WriteFile(opts.File, flameGraph, 0666); err != nil {\n\t\treturn fmt.Errorf(\"could not write output file: %v\", err)\n\t}\n\n\treturn nil\n}\n\nfunc validateOptions(opts *options) error {\n\tfile := opts.OutputOpts.File\n\tif file != \"\" && !strings.HasSuffix(file, \".svg\") {\n\t\treturn fmt.Errorf(\"output file must end in .svg\")\n\t}\n\tif opts.PProfOptions.TimeSeconds < 1 {\n\t\treturn fmt.Errorf(\"seconds must be an integer greater than 0\")\n\t}\n\n\t// extra FlameGraph options\n\tif opts.OutputOpts.Title == \"\" {\n\t\treturn fmt.Errorf(\"flamegraph title should not be empty\")\n\t}\n\tif opts.OutputOpts.Width <= 0 {\n\t\treturn fmt.Errorf(\"flamegraph default width is 1200 pixels\")\n\t}\n\tif opts.OutputOpts.Colors != \"\" {\n\t\tswitch opts.OutputOpts.Colors {\n\t\tcase \"hot\", \"mem\", \"io\", \"wakeup\", \"chain\", \"java\", \"js\", \"perl\", \"red\", \"green\", \"blue\", \"aqua\", \"yellow\", \"purple\", \"orange\":\n\t\t\t// valid\n\t\tdefault:\n\t\t\treturn fmt.Errorf(\"unknown flamegraph colors %q\", opts.OutputOpts.Colors)\n\t\t}\n\t}\n\n\treturn nil\n}\n\nfunc buildFlameGraphArgs(opts outputOptions) []string {\n\tvar args []string\n\n\tif opts.Title != \"\" {\n\t\targs = append(args, \"--title\", opts.Title)\n\t}\n\n\tif opts.Width > 0 {\n\t\targs = append(args, \"--width\", strconv.FormatInt(opts.Width, 10))\n\t}\n\n\tif opts.Colors != \"\" {\n\t\targs = append(args, \"--colors\", opts.Colors)\n\t}\n\n\tif opts.Hash {\n\t\targs = append(args, \"--hash\")\n\t}\n\n\tif opts.ConsistentPalette {\n\t\targs = append(args, \"--cp\")\n\t}\n\n\tif opts.Reverse {\n\t\targs = append(args, \"--reverse\")\n\t}\n\n\tif opts.Inverted {\n\t\targs = append(args, \"--inverted\")\n\t}\n\n\treturn args\n}\n"
        },
        {
          "name": "main_test.go",
          "type": "blob",
          "size": 6.212890625,
          "content": "// Copyright (c) 2015 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\npackage main\n\nimport (\n\t\"bufio\"\n\t\"io/ioutil\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"reflect\"\n\t\"strings\"\n\t\"testing\"\n\n\tgflags \"github.com/jessevdk/go-flags\"\n)\n\nconst testPProfInputFile = \"./pprof/testdata/pprof.1.pb.gz\"\n\nfunc getDefaultOptions() *options {\n\topts := &options{}\n\tif _, err := gflags.ParseArgs(opts, nil); err != nil {\n\t\tpanic(err)\n\t}\n\topts.PProfOptions.BinaryFile = testPProfInputFile\n\treturn opts\n}\n\nfunc TestBadArgs(t *testing.T) {\n\terr := runWithArgs(\"-t\", \"asd\")\n\tif err == nil {\n\t\tt.Fatalf(\"expected run with bad arguments to fail\")\n\t}\n\n\texpectedSubstr := []string{\n\t\t\"could not parse options\",\n\t\t\"invalid argument\",\n\t}\n\tfor _, substr := range expectedSubstr {\n\t\tif !strings.Contains(err.Error(), substr) {\n\t\t\tt.Errorf(\"error is missing message: %v\", substr)\n\t\t}\n\t}\n}\n\nfunc TestMain(t *testing.T) {\n\tos.Args = []string{\"go-torch\", \"--raw\", \"--binaryinput\", testPProfInputFile}\n\tmain()\n\t// Test should not fatal.\n}\n\nfunc TestMainRemaining(t *testing.T) {\n\tos.Args = []string{\"go-torch\", \"--raw\", testPProfInputFile}\n\tmain()\n\t// Test should not fatal.\n}\n\nfunc TestInvalidOptions(t *testing.T) {\n\ttests := []struct {\n\t\targs         []string\n\t\terrorMessage string\n\t}{\n\t\t{\n\t\t\targs:         []string{\"--file\", \"bad.jpg\"},\n\t\t\terrorMessage: \"must end in .svg\",\n\t\t},\n\t\t{\n\t\t\targs:         []string{\"-t\", \"0\"},\n\t\t\terrorMessage: \"seconds must be an integer greater than 0\",\n\t\t},\n\t\t{\n\t\t\targs:         []string{\"--title\", \"\"},\n\t\t\terrorMessage: \"flamegraph title should not be empty\",\n\t\t},\n\t\t{\n\t\t\targs:         []string{\"--width\", \"0\"},\n\t\t\terrorMessage: \"flamegraph default width is 1200 pixels\",\n\t\t},\n\t\t{\n\t\t\targs:         []string{\"--colors\", \"foo\"},\n\t\t\terrorMessage: \"unknown flamegraph colors \\\"foo\\\"\",\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\terr := runWithArgs(tt.args...)\n\t\tif err == nil {\n\t\t\tt.Errorf(\"Expected error when running with: %v\", tt.args)\n\t\t\tcontinue\n\t\t}\n\n\t\tif !strings.Contains(err.Error(), tt.errorMessage) {\n\t\t\tt.Errorf(\"Error missing message, got %v want message %v\", err.Error(), tt.errorMessage)\n\t\t}\n\t}\n}\n\nfunc TestRunRaw(t *testing.T) {\n\topts := getDefaultOptions()\n\topts.OutputOpts.Raw = true\n\n\tif err := runWithOptions(opts, nil); err != nil {\n\t\tt.Fatalf(\"Run with Raw failed: %v\", err)\n\t}\n}\n\nfunc TestFlameGraphArgs(t *testing.T) {\n\topts := getDefaultOptions()\n\topts.OutputOpts.Raw = true\n\n\topts.OutputOpts.Hash = true\n\topts.OutputOpts.Colors = \"perl\"\n\topts.OutputOpts.ConsistentPalette = true\n\topts.OutputOpts.Reverse = true\n\topts.OutputOpts.Inverted = true\n\n\texpectedCommandWithArgs := []string{\"--title\", \"Flame Graph\", \"--width\", \"1200\", \"--colors\", \"perl\",\n\t\t\"--hash\", \"--cp\", \"--reverse\", \"--inverted\"}\n\n\tif !reflect.DeepEqual(expectedCommandWithArgs, buildFlameGraphArgs(opts.OutputOpts)) {\n\t\tt.Fatalf(\"Invalid extra FlameGraph arguments!\")\n\t}\n\n\tif err := runWithOptions(opts, nil); err != nil {\n\t\tt.Fatalf(\"Run with extra FlameGraph arguments failed: %v\", err)\n\t}\n}\n\nfunc getTempFilename(t *testing.T, suffix string) string {\n\tf, err := ioutil.TempFile(\"\", \"\")\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to create temp file: %v\", err)\n\t}\n\n\tdefer f.Close()\n\treturn f.Name() + suffix\n}\n\nfunc TestRunFile(t *testing.T) {\n\topts := getDefaultOptions()\n\topts.OutputOpts.File = getTempFilename(t, \".svg\")\n\n\twithScriptsInPath(t, func() {\n\t\tif err := runWithOptions(opts, nil); err != nil {\n\t\t\tt.Fatalf(\"Run with Print failed: %v\", err)\n\t\t}\n\n\t\tf, err := os.Open(opts.OutputOpts.File)\n\t\tif err != nil {\n\t\t\tt.Errorf(\"Failed to open output file: %v\", err)\n\t\t}\n\t\tdefer f.Close()\n\n\t\t// Our fake flamegraph scripts just add script names to the output.\n\t\treader := bufio.NewReader(f)\n\t\tline1, err := reader.ReadString('\\n')\n\t\tif err != nil {\n\t\t\tt.Errorf(\"Failed to read line 1 in output file: %v\", err)\n\t\t}\n\t\tif !strings.Contains(line1, \"flamegraph.pl\") {\n\t\t\tt.Errorf(\"Output file has not been processed by flame graph scripts\")\n\t\t}\n\t})\n}\n\nfunc TestRunBadFile(t *testing.T) {\n\topts := getDefaultOptions()\n\topts.OutputOpts.File = \"/dev/zero/invalid/file\"\n\n\twithScriptsInPath(t, func() {\n\t\tif err := runWithOptions(opts, nil); err == nil {\n\t\t\tt.Fatalf(\"Run with bad file expected to fail\")\n\t\t}\n\t})\n}\n\nfunc TestRunPrint(t *testing.T) {\n\topts := getDefaultOptions()\n\topts.OutputOpts.Print = true\n\n\twithScriptsInPath(t, func() {\n\t\tif err := runWithOptions(opts, nil); err != nil {\n\t\t\tt.Fatalf(\"Run with Print failed: %v\", err)\n\t\t}\n\t\t// TODO(prashantv): Verify that output is printed to stdout.\n\t})\n}\n\n// scriptsPath is used to cache the fake scripts if we've already created it.\nvar scriptsPath string\n\nfunc withScriptsInPath(t *testing.T, f func()) {\n\toldPath := os.Getenv(\"PATH\")\n\tdefer os.Setenv(\"PATH\", oldPath)\n\n\t// Create a temporary directory with fake flamegraph scripts if we haven't already.\n\tif scriptsPath == \"\" {\n\t\tvar err error\n\t\tscriptsPath, err = ioutil.TempDir(\"\", \"go-torch-scripts\")\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"Failed to create temporary scripts dir: %v\", err)\n\t\t}\n\n\t\t// Create scripts in this path.\n\t\tconst scriptContents = `#!/bin/sh\n\t\techo $0\n\t\tcat\n\t\t`\n\t\tscriptFile := filepath.Join(scriptsPath, \"flamegraph.pl\")\n\t\tif err := ioutil.WriteFile(scriptFile, []byte(scriptContents), 0777); err != nil {\n\t\t\tt.Errorf(\"Failed to create script %v: %v\", scriptFile, err)\n\t\t}\n\t}\n\n\tos.Setenv(\"PATH\", scriptsPath+\":\"+oldPath)\n\tf()\n}\n"
        },
        {
          "name": "pprof",
          "type": "tree",
          "content": null
        },
        {
          "name": "renderer",
          "type": "tree",
          "content": null
        },
        {
          "name": "stack",
          "type": "tree",
          "content": null
        },
        {
          "name": "torchlog",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}