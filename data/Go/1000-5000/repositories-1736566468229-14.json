{
  "metadata": {
    "timestamp": 1736566468229,
    "page": 14,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjIw",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "pterm/pterm",
      "stars": 4933,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.333984375,
          "content": "# Binaries for programs and plugins\n*.exe\n*.exe~\n*.dll\n*.so\n*.dylib\n\n# Test binary, built with `go test -c`\n*.test\n\n# Output of the go coverage tool, specifically when used with LiteIDE\n*.out\n\n# Dependency directories (remove the comment below to include it)\nvendor/\n\n# This is where we test stuff\n/experimenting/*\n\n/.history\n/.vscode\n/.idea\n"
        },
        {
          "name": ".golangci.yml",
          "type": "blob",
          "size": 1.806640625,
          "content": "linters-settings:\n  gocritic:\n    enabled-tags:\n      - diagnostic\n      - experimental\n      - opinionated\n      - performance\n      - style\n    disabled-checks:\n      - dupImport\n      - ifElseChain\n      - octalLiteral\n      - whyNoLint\n      - wrapperFunc\n      - exitAfterDefer\n      - hugeParam\n      - ptrToRefParam\n      - paramTypeCombine\n      - unnamedResult\n  #  maligned:\n  #    suggest-new: true\n  misspell:\n    locale: US\nlinters:\n  disable-all: true\n  enable:\n    - gocritic\n    - gosec\n    - govet\n    - ineffassign\n    - unconvert\n    - gosimple\n    - godox\n    - whitespace\n    - staticcheck\n  #    - bodyclose\n  #    - maligned\n  #    - godot\n  #    - deadcode\n  #    - depguard\n  #    - dogsled\n  #    - dupl\n  #    - errcheck\n  #    - exhaustive\n  #    - funlen\n  #    - gochecknoinits\n  #    - goconst\n  #    - gocyclo\n  #    - gofmt\n  #    - goimports\n  #    - golint\n  #    - gomnd\n  #    - goprintffuncname\n  #    - lll\n  #    - misspell\n  #    - nakedret\n  #    - noctx\n  #    - nolintlint\n  #    - rowserrcheck\n  #    - scopelint\n  #    - structcheck\n  #    - stylecheck\n  #    - typecheck\n  #    - unparam\n  #    - unused\n  #    - varcheck\n  #    - whitespace\n  #   - asciicheck\n  #   - gochecknoglobals\n  #   - gocognit\n  #   - goerr113\n  #   - nestif\n  #   - prealloc\n  #   - testpackage\n  #   - wsl\nissues:\n  # Excluding configuration per-path, per-linter, per-text and per-source\n  exclude-rules:\n    - path: _test\\.go\n      linters:\n        - gocyclo\n        - errcheck\n        - dupl\n        - gosec\n        - gocritic\n    # https://github.com/go-critic/go-critic/issues/926\n    - linters:\n        - gocritic\n      text: \"unnecessaryDefer:\"\n    - linters:\n        - gocritic\n      text: \"preferDecodeRune:\"\nservice:\n  golangci-lint-version: 1.31.x # use the fixed version to not introduce new linters unexpectedly\n\n"
        },
        {
          "name": "CODE_OF_CONDUCT.md",
          "type": "blob",
          "size": 3.275390625,
          "content": "# Contributor Covenant Code of Conduct\n\n## Our Pledge\n\nIn the interest of fostering an open and welcoming environment, we as\ncontributors and maintainers pledge to making participation in our project and\nour community a harassment-free experience for everyone, regardless of age, body\nsize, disability, ethnicity, sex characteristics, gender identity and expression,\nlevel of experience, education, socio-economic status, nationality, personal\nappearance, race, religion, or sexual identity and orientation.\n\n## Our Standards\n\nExamples of behavior that contributes to creating a positive environment\ninclude:\n\n* Using welcoming and inclusive language\n* Being respectful of differing viewpoints and experiences\n* Gracefully accepting constructive criticism\n* Focusing on what is best for the community\n* Showing empathy towards other community members\n\nExamples of unacceptable behavior by participants include:\n\n* The use of sexualized language or imagery and unwelcome sexual attention or\n advances\n* Trolling, insulting/derogatory comments, and personal or political attacks\n* Public or private harassment\n* Publishing others' private information, such as a physical or electronic\n address, without explicit permission\n* Other conduct which could reasonably be considered inappropriate in a\n professional setting\n\n## Our Responsibilities\n\nProject maintainers are responsible for clarifying the standards of acceptable\nbehavior and are expected to take appropriate and fair corrective action in\nresponse to any instances of unacceptable behavior.\n\nProject maintainers have the right and responsibility to remove, edit, or\nreject comments, commits, code, wiki edits, issues, and other contributions\nthat are not aligned to this Code of Conduct, or to ban temporarily or\npermanently any contributor for other behaviors that they deem inappropriate,\nthreatening, offensive, or harmful.\n\n## Scope\n\nThis Code of Conduct applies both within project spaces and in public spaces\nwhen an individual is representing the project or its community. Examples of\nrepresenting a project or community include using an official project e-mail\naddress, posting via an official social media account, or acting as an appointed\nrepresentative at an online or offline event. Representation of a project may be\nfurther defined and clarified by project maintainers.\n\n## Enforcement\n\nInstances of abusive, harassing, or otherwise unacceptable behavior may be\nreported by contacting the project team at pterm@marvinjwendt.com. All\ncomplaints will be reviewed and investigated and will result in a response that\nis deemed necessary and appropriate to the circumstances. The project team is\nobligated to maintain confidentiality with regard to the reporter of an incident.\nFurther details of specific enforcement policies may be posted separately.\n\nProject maintainers who do not follow or enforce the Code of Conduct in good\nfaith may face temporary or permanent repercussions as determined by other\nmembers of the project's leadership.\n\n## Attribution\n\nThis Code of Conduct is adapted from the [Contributor Covenant][homepage], version 1.4,\navailable at https://www.contributor-covenant.org/version/1/4/code-of-conduct.html\n\n[homepage]: https://www.contributor-covenant.org\n\nFor answers to common questions about this code of conduct, see\nhttps://www.contributor-covenant.org/faq\n"
        },
        {
          "name": "CONTRIBUTING.md",
          "type": "blob",
          "size": 5.7978515625,
          "content": "# Contributing to PTerm\n\n> This document explains how to participate in the development of PTerm.\\\nIf your goal is to report a bug instead of programming PTerm, you can do so [here](https://github.com/pterm/pterm/issues?q=is%3Aissue+is%3Aopen+sort%3Aupdated-desc).\n\n## Best practise\n\nWe enforce some best practises, especially made for PTerm, to provide a clean and consistent user experience.\n\n### Styles\n\nStyles should always be consumed as pointers. That way, the user can change the style of printers globally.\n\n## Creating a new printer\n\n> In this chapter we will show you how to create a new printer.\n\n### `TextPrinter` Template\n```go\npackage pterm\n\ntype TemplatePrinter struct{\n\t// TODO: Add printer settings here\n}\n\n// Sprint formats using the default formats for its operands and returns the resulting string.\n// Spaces are added between operands when neither is a string.\nfunc (p TemplatePrinter) Sprint(a ...any) string {\n\tpanic(\"write printer code here\")\n}\n\n// Sprintln formats using the default formats for its operands and returns the resulting string.\n// Spaces are always added between operands and a newline is appended.\nfunc (p TemplatePrinter) Sprintln(a ...any) string {\n\treturn Sprintln(p.Sprint(a...))\n}\n\n// Sprintf formats according to a format specifier and returns the resulting string.\nfunc (p TemplatePrinter) Sprintf(format string, a ...any) string {\n\treturn p.Sprint(Sprintf(format, a...))\n}\n\n// Print formats using the default formats for its operands and writes to standard output.\n// Spaces are added between operands when neither is a string.\n// It returns the number of bytes written and any write error encountered.\nfunc (p TemplatePrinter) Print(a ...any) *TextPrinter {\n\tPrint(p.Sprint(a...))\n\ttp := TextPrinter(p)\n\treturn &tp\n}\n\n// Println formats using the default formats for its operands and writes to standard output.\n// Spaces are always added between operands and a newline is appended.\n// It returns the number of bytes written and any write error encountered.\nfunc (p TemplatePrinter) Println(a ...any) *TextPrinter {\n\tPrintln(p.Sprint(a...))\n    tp := TextPrinter(p)\n    return &tp\n}\n\n// Printf formats according to a format specifier and writes to standard output.\n// It returns the number of bytes written and any write error encountered.\nfunc (p TemplatePrinter) Printf(format string, a ...any) *TextPrinter {\n\tPrint(p.Sprintf(format, a...))\n\ttp := TextPrinter(p)\n\treturn &tp\n}\n```\n\n### `RenderablePrinter` Template\n\n```go\npackage pterm\n\ntype TemplatePrinter struct{\n\t// TODO: Add printer settings here\n}\n\n// Srender renders the Template as a string.\nfunc (p TemplatePrinter) Srender() (string, error) {\n\tvar ret strings.Builder\n\n    return ret.String(), nil\n}\n\n// Render prints the Template to the terminal.\nfunc (p TemplatePrinter) Render() error {\n\ts, err := p.Srender()\n    if err != nil {\n        return err\n    }\n    Println(s)\n\n    return nil\n}\n```\n\n### `LivePrinter` Template\n\n```go\n// Start the TemplatePrinter.\npackage pterm\nimport \"github.com/pterm/pterm\"\n\ntype TemplatePrinter struct{\n\n}\n\n\nfunc (s TemplatePrinter) Start(text...any) (*TemplatePrinter, error) { // TODO: Replace Template with actual printer.\n\t// TODO: start logic\n\treturn &s, nil\n}\n\n// Stop terminates the TemplatePrinter immediately.\n// The TemplatePrinter will not resolve into anything.\nfunc (s *TemplatePrinter) Stop() error {\n\t// TODO: stop logic\n    return nil\n}\n\n// GenericStart runs Start, but returns a LivePrinter.\n// This is used for the interface LivePrinter.\n// You most likely want to use Start instead of this in your program.\nfunc (s *TemplatePrinter) GenericStart() (*LivePrinter, error) {\n\t_, err := s.Start()\n\tlp := LivePrinter(s)\n\treturn &lp, err\n}\n\n// GenericStop runs Stop, but returns a LivePrinter.\n// This is used for the interface LivePrinter.\n// You most likely want to use Stop instead of this in your program.\nfunc (s *TemplatePrinter) GenericStop() (*LivePrinter, error) {\n\terr := s.Stop()\n\tlp := LivePrinter(s)\n\treturn &lp, err\n}\n```\n\n## Writing Tests\n\n> Each method of PTerm must be tested.\n\n### Required tests for every printer\n\n#### Nil Check\n\n> This ensures that a printer without set values will not produce errors.\n\n```go\nfunc TestTemplatePrinterNilPrint(t *testing.T) { // TODO: Replace \"Template\" with actual printer name.\n\tp := TemplatePrinter{} // TODO: Replace \"Template\" with actual printer name.\n\tp.Println(\"Hello, World!\")\n}\n```\n\n#### `WithXxx()` Methods\n\n> Each method, which starts with `With` can be tested by checking if it actually creates a new printer and sets the value.\n\nExample from `SectionPrinter`:\n\n```go\nfunc TestSectionPrinter_WithStyle(t *testing.T) {\n\tp := SectionPrinter{}\n\ts := NewStyle(FgRed, BgRed, Bold)\n\tp2 := p.WithStyle(s)\n\n\tassert.Equal(t, s, p2.Style)\n\tassert.Empty(t, p.Style)\n}\n\nfunc TestSectionPrinter_WithTopPadding(t *testing.T) {\n\tp := SectionPrinter{}\n\tp2 := p.WithTopPadding(1337)\n\n\tassert.Equal(t, 1337, p2.TopPadding)\n\tassert.Empty(t, p.TopPadding)\n}\n```\n\n### `TextPrinter` Tests Template\n\n```go\nfunc TestTemplatePrinterPrintMethods(t *testing.T) { // TODO: Replace \"Template\" with actual printer name.\n\tp := DefaultTemplate // TODO: Replace \"Template\" with actual printer name.\n\n\tt.Run(\"Print\", func(t *testing.T) {\n\t\ttestPrintContains(t, func(w io.Writer, a any) {\n\t\t\tp.Print(a)\n\t\t})\n\t})\n\n\tt.Run(\"Printf\", func(t *testing.T) {\n\t\ttestPrintfContains(t, func(w io.Writer, format string, a any) {\n\t\t\tp.Printf(format, a)\n\t\t})\n\t})\n\n\tt.Run(\"Println\", func(t *testing.T) {\n\t\ttestPrintlnContains(t, func(w io.Writer, a any) {\n\t\t\tp.Println(a)\n\t\t})\n\t})\n\n\tt.Run(\"Sprint\", func(t *testing.T) {\n\t\ttestSprintContains(t, func(a any) string {\n\t\t\treturn p.Sprint(a)\n\t\t})\n\t})\n\n\tt.Run(\"Sprintf\", func(t *testing.T) {\n\t\ttestSprintfContains(t, func(format string, a any) string {\n\t\t\treturn p.Sprintf(format, a)\n\t\t})\n\t})\n\n\tt.Run(\"Sprintln\", func(t *testing.T) {\n\t\ttestSprintlnContains(t, func(a any) string {\n\t\t\treturn p.Sprintln(a)\n\t\t})\n\t})\n}\n```\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.037109375,
          "content": "MIT License\n\nCopyright (c) 2020 pterm\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 105.7421875,
          "content": "<!--suppress HtmlDeprecatedAttribute -->\n\n<h1 align=\"center\">💻 PTerm | Pretty Terminal Printer</h1>\n<p align=\"center\">A modern Go framework to make beautiful CLIs</p>\n\n<p align=\"center\">\n\n<a href=\"https://github.com/pterm/pterm/releases\" style=\"text-decoration: none\">\n<img src=\"https://img.shields.io/github/v/release/pterm/pterm?style=flat-square\" alt=\"Latest Release\">\n</a>\n\n<a href=\"https://github.com/pterm/pterm/stargazers\" style=\"text-decoration: none\">\n<img src=\"https://img.shields.io/github/stars/pterm/pterm.svg?style=flat-square\" alt=\"Stars\">\n</a>\n\n<a href=\"https://github.com/pterm/pterm/fork\" style=\"text-decoration: none\">\n<img src=\"https://img.shields.io/github/forks/pterm/pterm.svg?style=flat-square\" alt=\"Forks\">\n</a>\n\n<a href=\"https://opensource.org/licenses/MIT\" style=\"text-decoration: none\">\n<img src=\"https://img.shields.io/badge/License-MIT-yellow.svg?style=flat-square\" alt=\"License: MIT\">\n</a>\n\n<a href=\"https://codecov.io/gh/pterm/pterm\" style=\"text-decoration: none\">\n<img src=\"https://img.shields.io/codecov/c/gh/pterm/pterm?color=magenta&logo=codecov&style=flat-square\" alt=\"Downloads\">\n</a>\n\n<a href=\"https://codecov.io/gh/pterm/pterm\" style=\"text-decoration: none\">\n<!-- unittestcount:start --><img src=\"https://img.shields.io/badge/Unit_Tests-28774-magenta?style=flat-square\" alt=\"Forks\"><!-- unittestcount:end -->\n</a>\n\n<br/>\n\n<a href=\"https://github.com/pterm/pterm/releases\" style=\"text-decoration: none\">\n<img src=\"https://img.shields.io/badge/platform-windows%20%7C%20macos%20%7C%20linux-informational?style=for-the-badge\" alt=\"Downloads\">\n</a>\n\n <a href=\"https://marvin.ws/twitter\">\n        <img src=\"https://img.shields.io/badge/Twitter-%40MarvinJWendt-1DA1F2?logo=twitter&style=for-the-badge\"/>\n    </a>\n\n<br/>\n<br/>\n\n<a href=\"https://github.com/pterm/pterm/tree/master/_examples/demo/demo\" style=\"text-decoration: none\">\n<img src=\"https://raw.githubusercontent.com/pterm/pterm/master/_examples/demo/demo/animation.svg\" alt=\"PTerm\">\n</a>\n<p align=\"center\"><a href=\"https://github.com/pterm/pterm/tree/master/_examples/demo/demo\" >Show Demo Code</p></p>\n\n</p>\n\n---\n\n<p align=\"center\">\n<strong><a href=\"https://pterm.sh\">PTerm.sh</a></strong>\n|\n<strong><a href=\"#-installation\">Installation</a></strong>\n|\n<strong><a href=\"https://docs.pterm.sh/getting-started\">Getting Started</a></strong>\n|\n<strong><a href=\"https://docs.pterm.sh/\">Documentation</a></strong>\n|\n<strong><a href=\"https://github.com/pterm/pterm/tree/master/_examples\">Examples</a></strong>\n|\n<strong><a href=\"https://github.com/pterm/pterm/discussions?discussions_q=category%3AQ%26A\">Q&A</a></strong>\n|\n<strong><a href=\"https://discord.gg/vE2dNkfAmF\">Discord</a></strong>\n</p>\n\n---\n\n## 📦 Installation\n\nTo make PTerm available in your project, you can run the following command.\\\nMake sure to run this command inside your project, when you're using go modules 😉\n\n```sh\ngo get github.com/pterm/pterm\n```\n\n## ⭐ Main Features\n\n| Feature          | Description                                         |\n|------------------|-----------------------------------------------------|\n| 🪀 Easy to use    | PTerm emphasizes ease of use, with [examples](#-examples) and consistent component design. |\n| 🤹‍♀️ Cross-Platform | PTerm works on various OS and terminals, including `Windows CMD`, `macOS iTerm2`, and in CI systems like `GitHub Actions`. |\n| 🧪 Well tested    | A high test coverage and <!-- unittestcount2:start -->`28774`<!-- unittestcount2:end --> automated tests ensure PTerm's reliability. |\n| ✨ Consistent Colors | PTerm uses the [ANSI color scheme](https://en.wikipedia.org/wiki/ANSI_escape_code#3/4_bit) for uniformity and supports `TrueColor` for advanced terminals. |\n| 📚 Component system | PTerm's flexible `Printers` can be used individually or combined to generate beautiful console output. |\n| 🛠 Configurable   | PTerm is ready to use without configuration but allows easy customization for unique terminal output. |\n| ✏ Documentation  | Access comprehensive docs on [pkg.go.dev](https://pkg.go.dev/github.com/pterm/pterm#section-documentation) and view practical examples in the [examples section](#-examples). |\n\n### Printers (Components)\n\n<div align=\"center\">\n\n<!-- printers:start -->\n| Feature | Feature | Feature | Feature | Feature |\n| :-------: | :-------: | :-------: | :-------: | :-------: |\n| Area <br/> [(Examples)](https://github.com/pterm/pterm/tree/master/_examples/area) |Barchart <br/> [(Examples)](https://github.com/pterm/pterm/tree/master/_examples/barchart) |Basictext <br/> [(Examples)](https://github.com/pterm/pterm/tree/master/_examples/basictext) |Bigtext <br/> [(Examples)](https://github.com/pterm/pterm/tree/master/_examples/bigtext) |Box <br/> [(Examples)](https://github.com/pterm/pterm/tree/master/_examples/box) |\n| Bulletlist <br/> [(Examples)](https://github.com/pterm/pterm/tree/master/_examples/bulletlist) |Center <br/> [(Examples)](https://github.com/pterm/pterm/tree/master/_examples/center) |Coloring <br/> [(Examples)](https://github.com/pterm/pterm/tree/master/_examples/coloring) |Header <br/> [(Examples)](https://github.com/pterm/pterm/tree/master/_examples/header) |Heatmap <br/> [(Examples)](https://github.com/pterm/pterm/tree/master/_examples/heatmap) |\n| Interactive confirm <br/> [(Examples)](https://github.com/pterm/pterm/tree/master/_examples/interactive_confirm) |Interactive continue <br/> [(Examples)](https://github.com/pterm/pterm/tree/master/_examples/interactive_continue) |Interactive multiselect <br/> [(Examples)](https://github.com/pterm/pterm/tree/master/_examples/interactive_multiselect) |Interactive select <br/> [(Examples)](https://github.com/pterm/pterm/tree/master/_examples/interactive_select) |Interactive textinput <br/> [(Examples)](https://github.com/pterm/pterm/tree/master/_examples/interactive_textinput) |\n| Logger <br/> [(Examples)](https://github.com/pterm/pterm/tree/master/_examples/logger) |Multiple-live-printers <br/> [(Examples)](https://github.com/pterm/pterm/tree/master/_examples/multiple-live-printers) |Panel <br/> [(Examples)](https://github.com/pterm/pterm/tree/master/_examples/panel) |Paragraph <br/> [(Examples)](https://github.com/pterm/pterm/tree/master/_examples/paragraph) |Prefix <br/> [(Examples)](https://github.com/pterm/pterm/tree/master/_examples/prefix) |\n| Progressbar <br/> [(Examples)](https://github.com/pterm/pterm/tree/master/_examples/progressbar) |Section <br/> [(Examples)](https://github.com/pterm/pterm/tree/master/_examples/section) |Slog <br/> [(Examples)](https://github.com/pterm/pterm/tree/master/_examples/slog) |Spinner <br/> [(Examples)](https://github.com/pterm/pterm/tree/master/_examples/spinner) |Style <br/> [(Examples)](https://github.com/pterm/pterm/tree/master/_examples/style) |\n| Table <br/> [(Examples)](https://github.com/pterm/pterm/tree/master/_examples/table) |Test.sh <br/> [(Examples)](https://github.com/pterm/pterm/tree/master/_examples/test.sh) |Theme <br/> [(Examples)](https://github.com/pterm/pterm/tree/master/_examples/theme) |Tree <br/> [(Examples)](https://github.com/pterm/pterm/tree/master/_examples/tree) | | \n<!-- printers:end -->\n\n</div>\n\n---\n\n<div align=\"center\">\n\n### 🦸‍♂️ Sponsors\n\n<img src=\"https://resources.jetbrains.com/storage/products/company/brand/logos/jb_beam.svg\" />\n\n---\n\n</div>\n\n## 🧪 Examples\n\n<p align=\"center\">\n<table>\n<tbody>\n<td align=\"center\">\n<img width=\"2000\" height=\"0\"><br>\n<a href=\"https://github.com/pterm/pterm/tree/master/_examples\">‼️ You can find all the examples, in a much better structure and their source code, in \"_examples\" ‼️</a><br>\n<sub>Click on the link above to show the examples folder.</sub>\n<img width=\"2000\" height=\"0\">\n</td>\n</tbody>\n</table>\n</p>\n\n<!-- examples:start -->\n### area/demo\n\n![Animation](https://raw.githubusercontent.com/pterm/pterm/master/_examples/area/demo/animation.svg)\n\n<details>\n\n<summary>SHOW SOURCE</summary>\n\n```go\npackage main\n\nimport (\n\t\"time\"\n\n\t\"github.com/pterm/pterm\"\n\t\"github.com/pterm/pterm/putils\"\n)\n\nfunc main() {\n\t// Print an informational message using PTerm's Info printer.\n\t// This message will stay in place while the area updates.\n\tpterm.Info.Println(\"The previous text will stay in place, while the area updates.\")\n\n\t// Print two new lines as spacer.\n\tpterm.Print(\"\\n\\n\")\n\n\t// Start the Area printer from PTerm's DefaultArea, with the Center option.\n\t// The Area printer allows us to update a specific area of the console output.\n\t// The returned 'area' object is used to control the area updates.\n\tarea, _ := pterm.DefaultArea.WithCenter().Start()\n\n\t// Loop 10 times to update the area with the current time.\n\tfor i := 0; i < 10; i++ {\n\t\t// Get the current time, format it as \"15:04:05\" (hour:minute:second), and convert it to a string.\n\t\t// Then, create a BigText from the time string using PTerm's DefaultBigText and putils NewLettersFromString.\n\t\t// The Srender() function is used to save the BigText as a string.\n\t\tstr, _ := pterm.DefaultBigText.WithLetters(putils.LettersFromString(time.Now().Format(\"15:04:05\"))).Srender()\n\n\t\t// Update the Area contents with the current time string.\n\t\tarea.Update(str)\n\n\t\t// Sleep for a second before the next update.\n\t\ttime.Sleep(time.Second)\n\t}\n\n\t// Stop the Area printer after all updates are done.\n\tarea.Stop()\n}\n\n```\n\n</details>\n\n### area/center\n\n![Animation](https://raw.githubusercontent.com/pterm/pterm/master/_examples/area/center/animation.svg)\n\n<details>\n\n<summary>SHOW SOURCE</summary>\n\n```go\npackage main\n\nimport (\n\t\"time\"\n\n\t\"github.com/pterm/pterm\"\n)\n\nfunc main() {\n\t// Start a new default area in the center of the terminal.\n\t// The Start() function returns the created area and an error.\n\tarea, _ := pterm.DefaultArea.WithCenter().Start()\n\n\t// Loop 5 times to simulate a dynamic update.\n\tfor i := 0; i < 5; i++ {\n\t\t// Update the content of the area with the current count.\n\t\t// The Sprintf function is used to format the string.\n\t\tarea.Update(pterm.Sprintf(\"Current count: %d\\nAreas can update their content dynamically!\", i))\n\n\t\t// Pause for a second to simulate a time-consuming task.\n\t\ttime.Sleep(time.Second)\n\t}\n\n\t// Stop the area after all updates are done.\n\tarea.Stop()\n}\n\n```\n\n</details>\n\n### area/default\n\n![Animation](https://raw.githubusercontent.com/pterm/pterm/master/_examples/area/default/animation.svg)\n\n<details>\n\n<summary>SHOW SOURCE</summary>\n\n```go\npackage main\n\nimport (\n\t\"time\"\n\n\t\"github.com/pterm/pterm\"\n)\n\nfunc main() {\n\t// Start a new default area and get a reference to it.\n\t// The second return value is an error which is ignored here.\n\tarea, _ := pterm.DefaultArea.Start()\n\n\t// Loop 5 times\n\tfor i := 0; i < 5; i++ {\n\t\t// Update the content of the area dynamically.\n\t\t// Here we're just displaying the current count.\n\t\tarea.Update(pterm.Sprintf(\"Current count: %d\\nAreas can update their content dynamically!\", i))\n\n\t\t// Pause for a second before the next update.\n\t\ttime.Sleep(time.Second)\n\t}\n\n\t// Stop the area after all updates are done.\n\t// This will clean up and free resources used by the area.\n\tarea.Stop()\n}\n\n```\n\n</details>\n\n### area/dynamic-chart\n\n![Animation](https://raw.githubusercontent.com/pterm/pterm/master/_examples/area/dynamic-chart/animation.svg)\n\n<details>\n\n<summary>SHOW SOURCE</summary>\n\n```go\npackage main\n\nimport (\n\t\"time\"\n\n\t\"github.com/pterm/pterm\"\n)\n\nfunc main() {\n\t// Start a new fullscreen centered area.\n\t// This area will be used to display the bar chart.\n\tarea, _ := pterm.DefaultArea.WithFullscreen().WithCenter().Start()\n\t// Ensure the area stops updating when we're done.\n\tdefer area.Stop()\n\n\t// Loop to update the bar chart 10 times.\n\tfor i := 0; i < 10; i++ {\n\t\t// Create a new bar chart with dynamic bars.\n\t\t// The bars will change based on the current iteration.\n\t\tbarchart := pterm.DefaultBarChart.WithBars(dynamicBars(i))\n\t\t// Render the bar chart to a string.\n\t\t// This string will be used to update the area.\n\t\tcontent, _ := barchart.Srender()\n\t\t// Update the area with the new bar chart.\n\t\tarea.Update(content)\n\t\t// Wait for half a second before the next update.\n\t\ttime.Sleep(500 * time.Millisecond)\n\t}\n}\n\n// dynamicBars generates a set of bars for the bar chart.\n// The bars will change based on the current iteration.\nfunc dynamicBars(i int) pterm.Bars {\n\treturn pterm.Bars{\n\t\t{Label: \"A\", Value: 10},     // A static bar.\n\t\t{Label: \"B\", Value: 20 * i}, // A bar that grows with each iteration.\n\t\t{Label: \"C\", Value: 30},     // Another static bar.\n\t\t{Label: \"D\", Value: 40 + i}, // A bar that grows slowly with each iteration.\n\t}\n}\n\n```\n\n</details>\n\n### area/fullscreen\n\n![Animation](https://raw.githubusercontent.com/pterm/pterm/master/_examples/area/fullscreen/animation.svg)\n\n<details>\n\n<summary>SHOW SOURCE</summary>\n\n```go\npackage main\n\nimport (\n\t\"time\"\n\n\t\"github.com/pterm/pterm\"\n)\n\nfunc main() {\n\t// Start a new fullscreen area. This will return an area instance and an error.\n\t// The underscore (_) is used to ignore the error.\n\tarea, _ := pterm.DefaultArea.WithFullscreen().Start()\n\n\t// Loop 5 times to update the area content.\n\tfor i := 0; i < 5; i++ {\n\t\t// Update the content of the area with the current count.\n\t\t// The Sprintf function is used to format the string.\n\t\tarea.Update(pterm.Sprintf(\"Current count: %d\\nAreas can update their content dynamically!\", i))\n\n\t\t// Pause for a second before the next update.\n\t\ttime.Sleep(time.Second)\n\t}\n\n\t// Stop the area after all updates are done.\n\tarea.Stop()\n}\n\n```\n\n</details>\n\n### area/fullscreen-center\n\n![Animation](https://raw.githubusercontent.com/pterm/pterm/master/_examples/area/fullscreen-center/animation.svg)\n\n<details>\n\n<summary>SHOW SOURCE</summary>\n\n```go\npackage main\n\nimport (\n\t\"time\"\n\n\t\"github.com/pterm/pterm\"\n)\n\nfunc main() {\n\t// Initialize a new PTerm area with fullscreen and center options\n\t// The Start() function returns the created area and an error (ignored here)\n\tarea, _ := pterm.DefaultArea.WithFullscreen().WithCenter().Start()\n\n\t// Loop 5 times to demonstrate dynamic content update\n\tfor i := 0; i < 5; i++ {\n\t\t// Update the content of the area with the current count\n\t\t// The Sprintf function is used to format the string with the count\n\t\tarea.Update(pterm.Sprintf(\"Current count: %d\\nAreas can update their content dynamically!\", i))\n\n\t\t// Pause for a second\n\t\ttime.Sleep(time.Second)\n\t}\n\n\t// Stop the area after all updates are done\n\t// This will clear the area and return the terminal to its normal state\n\tarea.Stop()\n}\n\n```\n\n</details>\n\n### barchart/demo\n\n![Animation](https://raw.githubusercontent.com/pterm/pterm/master/_examples/barchart/demo/animation.svg)\n\n<details>\n\n<summary>SHOW SOURCE</summary>\n\n```go\npackage main\n\nimport (\n\t\"github.com/pterm/pterm\"\n)\n\nfunc main() {\n\t// Define the bars for the chart\n\tbars := []pterm.Bar{\n\t\t{Label: \"Bar 1\", Value: 5},\n\t\t{Label: \"Bar 2\", Value: 3},\n\t\t{Label: \"Longer Label\", Value: 7},\n\t}\n\n\t// Print an informational message\n\tpterm.Info.Println(\"Chart example with positive only values (bars use 100% of chart area)\")\n\n\t// Create a bar chart with the defined bars and render it\n\t// The DefaultBarChart is used as a base, and the bars are added with the WithBars option\n\t// The Render function is then called to display the chart\n\tpterm.DefaultBarChart.WithBars(bars).Render()\n\n\t// Create a horizontal bar chart with the defined bars and render it\n\t// The DefaultBarChart is used as a base, the chart is made horizontal with the WithHorizontal option, and the bars are added with the WithBars option\n\t// The Render function is then called to display the chart\n\tpterm.DefaultBarChart.WithHorizontal().WithBars(bars).Render()\n}\n\n```\n\n</details>\n\n### barchart/custom-height\n\n![Animation](https://raw.githubusercontent.com/pterm/pterm/master/_examples/barchart/custom-height/animation.svg)\n\n<details>\n\n<summary>SHOW SOURCE</summary>\n\n```go\npackage main\n\nimport \"github.com/pterm/pterm\"\n\nfunc main() {\n\t// Define a slice of Bar structs. Each struct represents a bar in the chart.\n\t// The Label field is the name of the bar and the Value field is the height of the bar.\n\tbars := []pterm.Bar{\n\t\t{Label: \"A\", Value: 10},\n\t\t{Label: \"B\", Value: 20},\n\t\t{Label: \"C\", Value: 30},\n\t\t{Label: \"D\", Value: 40},\n\t\t{Label: \"E\", Value: 50},\n\t\t{Label: \"F\", Value: 40},\n\t\t{Label: \"G\", Value: 30},\n\t\t{Label: \"H\", Value: 20},\n\t\t{Label: \"I\", Value: 10},\n\t}\n\n\t// Create and render a bar chart with the defined bars and a height of 5.\n\t// The WithBars method is used to set the bars of the chart.\n\t// The WithHeight method is used to set the height of the chart.\n\t// The Render method is used to display the chart in the terminal.\n\tpterm.DefaultBarChart.WithBars(bars).WithHeight(5).Render()\n}\n\n```\n\n</details>\n\n### barchart/custom-width\n\n![Animation](https://raw.githubusercontent.com/pterm/pterm/master/_examples/barchart/custom-width/animation.svg)\n\n<details>\n\n<summary>SHOW SOURCE</summary>\n\n```go\npackage main\n\nimport \"github.com/pterm/pterm\"\n\nfunc main() {\n\t// Define the data for the bar chart\n\tbarData := []pterm.Bar{\n\t\t{Label: \"A\", Value: 10},\n\t\t{Label: \"B\", Value: 20},\n\t\t{Label: \"C\", Value: 30},\n\t\t{Label: \"D\", Value: 40},\n\t\t{Label: \"E\", Value: 50},\n\t\t{Label: \"F\", Value: 40},\n\t\t{Label: \"G\", Value: 30},\n\t\t{Label: \"H\", Value: 20},\n\t\t{Label: \"I\", Value: 10},\n\t}\n\n\t// Create a bar chart with the defined data\n\t// The chart is horizontal and has a width of 5\n\t// The Render() function is called to display the chart\n\tpterm.DefaultBarChart.WithBars(barData).WithHorizontal().WithWidth(5).Render()\n}\n\n```\n\n</details>\n\n### barchart/default\n\n![Animation](https://raw.githubusercontent.com/pterm/pterm/master/_examples/barchart/default/animation.svg)\n\n<details>\n\n<summary>SHOW SOURCE</summary>\n\n```go\npackage main\n\nimport \"github.com/pterm/pterm\"\n\nfunc main() {\n\t// Define the data for the bar chart. Each bar is represented by a `pterm.Bar` struct.\n\t// The `Label` field represents the label of the bar, and the `Value` field represents the value of the bar.\n\tbars := []pterm.Bar{\n\t\t{Label: \"A\", Value: 10},\n\t\t{Label: \"B\", Value: 20},\n\t\t{Label: \"C\", Value: 30},\n\t\t{Label: \"D\", Value: 40},\n\t\t{Label: \"E\", Value: 50},\n\t\t{Label: \"F\", Value: 40},\n\t\t{Label: \"G\", Value: 30},\n\t\t{Label: \"H\", Value: 20},\n\t\t{Label: \"I\", Value: 10},\n\t}\n\n\t// Use the `DefaultBarChart` from the `pterm` package to create a bar chart.\n\t// The `WithBars` method is used to set the bars of the chart.\n\t// The `Render` method is used to display the chart.\n\tpterm.DefaultBarChart.WithBars(bars).Render()\n}\n\n```\n\n</details>\n\n### barchart/horizontal\n\n![Animation](https://raw.githubusercontent.com/pterm/pterm/master/_examples/barchart/horizontal/animation.svg)\n\n<details>\n\n<summary>SHOW SOURCE</summary>\n\n```go\npackage main\n\nimport \"github.com/pterm/pterm\"\n\nfunc main() {\n\t// Define the data for the bar chart\n\tbars := []pterm.Bar{\n\t\t{Label: \"A\", Value: 10},\n\t\t{Label: \"B\", Value: 20},\n\t\t{Label: \"C\", Value: 30},\n\t\t{Label: \"D\", Value: 40},\n\t\t{Label: \"E\", Value: 50},\n\t\t{Label: \"F\", Value: 40},\n\t\t{Label: \"G\", Value: 30},\n\t\t{Label: \"H\", Value: 20},\n\t\t{Label: \"I\", Value: 10},\n\t}\n\n\t// Create a bar chart with the defined data\n\t// The chart is displayed horizontally\n\t// The Render() function is called to display the chart\n\tpterm.DefaultBarChart.WithBars(bars).WithHorizontal().Render()\n}\n\n```\n\n</details>\n\n### barchart/horizontal-show-value\n\n![Animation](https://raw.githubusercontent.com/pterm/pterm/master/_examples/barchart/horizontal-show-value/animation.svg)\n\n<details>\n\n<summary>SHOW SOURCE</summary>\n\n```go\npackage main\n\nimport \"github.com/pterm/pterm\"\n\nfunc main() {\n\t// Define the data for the bar chart\n\tbarData := []pterm.Bar{\n\t\t{Label: \"A\", Value: 10},\n\t\t{Label: \"B\", Value: 20},\n\t\t{Label: \"C\", Value: 30},\n\t\t{Label: \"D\", Value: 40},\n\t\t{Label: \"E\", Value: 50},\n\t\t{Label: \"F\", Value: 40},\n\t\t{Label: \"G\", Value: 30},\n\t\t{Label: \"H\", Value: 20},\n\t\t{Label: \"I\", Value: 10},\n\t}\n\n\t// Create a bar chart with the defined data\n\t// The chart is horizontal and displays the value of each bar\n\t// The Render() function is called to display the chart\n\tpterm.DefaultBarChart.WithBars(barData).WithHorizontal().WithShowValue().Render()\n}\n\n```\n\n</details>\n\n### barchart/mixed-values\n\n![Animation](https://raw.githubusercontent.com/pterm/pterm/master/_examples/barchart/mixed-values/animation.svg)\n\n<details>\n\n<summary>SHOW SOURCE</summary>\n\n```go\npackage main\n\nimport (\n\t\"github.com/pterm/pterm\"\n)\n\nfunc main() {\n\t// Define a set of bars for the chart.\n\t// Each bar has a label and a value.\n\tbars := []pterm.Bar{\n\t\t{Label: \"Bar 1\", Value: 2},\n\t\t{Label: \"Bar 2\", Value: -3},\n\t\t{Label: \"Bar 3\", Value: -2},\n\t\t{Label: \"Bar 4\", Value: 5},\n\t\t{Label: \"Longer Label\", Value: 7},\n\t}\n\n\t// Print a section header.\n\t// This is useful for separating different parts of the output.\n\tpterm.DefaultSection.Println(\"Chart example with mixed values (note screen space usage in case when ABSOLUTE values of negative and positive parts are differ too much)\")\n\n\t// Create a bar chart with the defined bars.\n\t// The chart will display the value of each bar.\n\t// The Render() function is called to display the chart.\n\tpterm.DefaultBarChart.WithBars(bars).WithShowValue().Render()\n\n\t// Create a horizontal bar chart with the same bars.\n\t// The chart will display the value of each bar.\n\t// The Render() function is called to display the chart.\n\tpterm.DefaultBarChart.WithHorizontal().WithBars(bars).WithShowValue().Render()\n}\n\n```\n\n</details>\n\n### barchart/negative-values\n\n![Animation](https://raw.githubusercontent.com/pterm/pterm/master/_examples/barchart/negative-values/animation.svg)\n\n<details>\n\n<summary>SHOW SOURCE</summary>\n\n```go\npackage main\n\nimport (\n\t\"github.com/pterm/pterm\"\n)\n\nfunc main() {\n\t// Define a set of bars with negative values.\n\t// Each bar is represented by a struct with a label and a value.\n\tnegativeBars := pterm.Bars{\n\t\t{Label: \"Bar 1\", Value: -5},\n\t\t{Label: \"Bar 2\", Value: -3},\n\t\t{Label: \"Longer Label\", Value: -7},\n\t}\n\n\t// Print an informational message to the console.\n\tpterm.Info.Println(\"Chart example with negative only values (bars use 100% of chart area)\")\n\n\t// Create a vertical bar chart with the defined bars.\n\t// The WithShowValue() option is used to display the value of each bar in the chart.\n\t// The Render() method is called to draw the chart.\n\t_ = pterm.DefaultBarChart.WithBars(negativeBars).WithShowValue().Render()\n\n\t// Create a horizontal bar chart with the same bars.\n\t// The WithHorizontal() option is used to orient the chart horizontally.\n\t// The WithShowValue() option and Render() method are used in the same way as before.\n\t_ = pterm.DefaultBarChart.WithHorizontal().WithBars(negativeBars).WithShowValue().Render()\n}\n\n```\n\n</details>\n\n### barchart/show-value\n\n![Animation](https://raw.githubusercontent.com/pterm/pterm/master/_examples/barchart/show-value/animation.svg)\n\n<details>\n\n<summary>SHOW SOURCE</summary>\n\n```go\npackage main\n\nimport \"github.com/pterm/pterm\"\n\nfunc main() {\n\t// Define a slice of bars for the bar chart. Each bar is represented by a struct\n\t// with a Label and a Value. The Label is a string that represents the name of the bar,\n\t// and the Value is an integer that represents the height of the bar.\n\tbars := []pterm.Bar{\n\t\t{Label: \"A\", Value: 10},\n\t\t{Label: \"B\", Value: 20},\n\t\t{Label: \"C\", Value: 30},\n\t\t{Label: \"D\", Value: 40},\n\t\t{Label: \"E\", Value: 50},\n\t\t{Label: \"F\", Value: 40},\n\t\t{Label: \"G\", Value: 30},\n\t\t{Label: \"H\", Value: 20},\n\t\t{Label: \"I\", Value: 10},\n\t}\n\n\t// Create a bar chart with the defined bars using the DefaultBarChart object from PTerm.\n\t// Chain the WithBars method to set the bars of the chart.\n\t// Chain the WithShowValue method to display the value of each bar on the chart.\n\t// Finally, call the Render method to display the chart.\n\tpterm.DefaultBarChart.WithBars(bars).WithShowValue().Render()\n}\n\n```\n\n</details>\n\n### basictext/demo\n\n![Animation](https://raw.githubusercontent.com/pterm/pterm/master/_examples/basictext/demo/animation.svg)\n\n<details>\n\n<summary>SHOW SOURCE</summary>\n\n```go\npackage main\n\nimport \"github.com/pterm/pterm\"\n\nfunc main() {\n\t// The DefaultBasicText is a basic text printer provided by PTerm.\n\t// It is used to print text without any special formatting.\n\tpterm.DefaultBasicText.Println(\"Default basic text printer.\")\n\n\t// The DefaultBasicText can be used in any context that requires a TextPrinter.\n\t// Here, we're using it with the LightMagenta function to color a portion of the text.\n\tpterm.DefaultBasicText.Println(\"Can be used in any\" + pterm.LightMagenta(\" TextPrinter \") + \"context.\")\n\n\t// The DefaultBasicText is also useful for resolving progress bars and spinners.\n}\n\n```\n\n</details>\n\n### bigtext/demo\n\n![Animation](https://raw.githubusercontent.com/pterm/pterm/master/_examples/bigtext/demo/animation.svg)\n\n<details>\n\n<summary>SHOW SOURCE</summary>\n\n```go\npackage main\n\nimport (\n\t\"github.com/pterm/pterm\"\n\t\"github.com/pterm/pterm/putils\"\n)\n\nfunc main() {\n\t// Create a large text with the LetterStyle from the standard theme.\n\t// This is useful for creating title screens.\n\tpterm.DefaultBigText.WithLetters(putils.LettersFromString(\"PTerm\")).Render()\n\n\t// Create a large text with differently colored letters.\n\t// Here, the first letter 'P' is colored cyan and the rest 'Term' is colored light magenta.\n\t// This can be used to highlight specific parts of the text.\n\tpterm.DefaultBigText.WithLetters(\n\t\tputils.LettersFromStringWithStyle(\"P\", pterm.FgCyan.ToStyle()),\n\t\tputils.LettersFromStringWithStyle(\"Term\", pterm.FgLightMagenta.ToStyle()),\n\t).Render()\n\n\t// Create a large text with a specific RGB color.\n\t// This can be used when you need a specific color that is not available in the standard colors.\n\t// Here, the color is gold (RGB: 255, 215, 0).\n\tpterm.DefaultBigText.WithLetters(\n\t\tputils.LettersFromStringWithRGB(\"PTerm\", pterm.NewRGB(255, 215, 0)),\n\t).Render()\n}\n\n```\n\n</details>\n\n### bigtext/colored\n\n![Animation](https://raw.githubusercontent.com/pterm/pterm/master/_examples/bigtext/colored/animation.svg)\n\n<details>\n\n<summary>SHOW SOURCE</summary>\n\n```go\npackage main\n\nimport (\n\t\"github.com/pterm/pterm\"\n\t\"github.com/pterm/pterm/putils\"\n)\n\nfunc main() {\n\t// Initialize a big text display with the letters \"P\" and \"Term\"\n\t// \"P\" is displayed in cyan and \"Term\" is displayed in light magenta\n\tpterm.DefaultBigText.WithLetters(\n\t\tputils.LettersFromStringWithStyle(\"P\", pterm.FgCyan.ToStyle()),\n\t\tputils.LettersFromStringWithStyle(\"Term\", pterm.FgLightMagenta.ToStyle())).\n\t\tRender() // Render the big text to the terminal\n}\n\n```\n\n</details>\n\n### bigtext/default\n\n![Animation](https://raw.githubusercontent.com/pterm/pterm/master/_examples/bigtext/default/animation.svg)\n\n<details>\n\n<summary>SHOW SOURCE</summary>\n\n```go\npackage main\n\nimport (\n\t\"github.com/pterm/pterm\"\n\t\"github.com/pterm/pterm/putils\"\n)\n\nfunc main() {\n\t// Define the text to be rendered\n\tvar text = \"PTerm\"\n\n\t// Convert the text into a format suitable for PTerm\n\tvar letters = putils.LettersFromString(text)\n\n\t// Render the text using PTerm's default big text style\n\tpterm.DefaultBigText.WithLetters(letters).Render()\n}\n\n```\n\n</details>\n\n### box/demo\n\n![Animation](https://raw.githubusercontent.com/pterm/pterm/master/_examples/box/demo/animation.svg)\n\n<details>\n\n<summary>SHOW SOURCE</summary>\n\n```go\npackage main\n\nimport \"github.com/pterm/pterm\"\n\nfunc main() {\n\t// Print an informational message.\n\tpterm.Info.Println(\"This might not be rendered correctly on GitHub,\\nbut it will work in a real terminal.\\nThis is because GitHub does not use a monospaced font by default for SVGs\")\n\n\t// Create three panels with text, some of them with titles.\n\t// The panels are created using the DefaultBox style.\n\tpanel1 := pterm.DefaultBox.Sprint(\"Lorem ipsum dolor sit amet,\\nconsectetur adipiscing elit,\\nsed do eiusmod tempor incididunt\\nut labore et dolore\\nmagna aliqua.\")\n\tpanel2 := pterm.DefaultBox.WithTitle(\"title\").Sprint(\"Ut enim ad minim veniam,\\nquis nostrud exercitation\\nullamco laboris\\nnisi ut aliquip\\nex ea commodo\\nconsequat.\")\n\tpanel3 := pterm.DefaultBox.WithTitle(\"bottom center title\").WithTitleBottomCenter().Sprint(\"Duis aute irure\\ndolor in reprehenderit\\nin voluptate velit esse cillum\\ndolore eu fugiat\\nnulla pariatur.\")\n\n\t// Combine the panels into a layout using the DefaultPanel style.\n\t// The layout is a 2D grid, with each row being an array of panels.\n\t// In this case, the first row contains panel1 and panel2, and the second row contains only panel3.\n\tpanels, _ := pterm.DefaultPanel.WithPanels(pterm.Panels{\n\t\t{{Data: panel1}, {Data: panel2}},\n\t\t{{Data: panel3}},\n\t}).Srender()\n\n\t// Print the panels layout inside a box with a title.\n\t// The box is created using the DefaultBox style, with the title positioned at the bottom right.\n\tpterm.DefaultBox.WithTitle(\"Lorem Ipsum\").WithTitleBottomRight().WithRightPadding(0).WithBottomPadding(0).Println(panels)\n}\n\n```\n\n</details>\n\n### box/custom-padding\n\n![Animation](https://raw.githubusercontent.com/pterm/pterm/master/_examples/box/custom-padding/animation.svg)\n\n<details>\n\n<summary>SHOW SOURCE</summary>\n\n```go\npackage main\n\nimport \"github.com/pterm/pterm\"\n\nfunc main() {\n\t// Create a default box with custom padding options and print \"Hello, World!\" inside it.\n\tpterm.DefaultBox.WithRightPadding(10).WithLeftPadding(10).WithTopPadding(2).WithBottomPadding(2).Println(\"Hello, World!\")\n}\n\n```\n\n</details>\n\n### box/default\n\n![Animation](https://raw.githubusercontent.com/pterm/pterm/master/_examples/box/default/animation.svg)\n\n<details>\n\n<summary>SHOW SOURCE</summary>\n\n```go\npackage main\n\nimport \"github.com/pterm/pterm\"\n\nfunc main() {\n\t// Create a default box with PTerm and print a message in it.\n\t// The DefaultBox.Println method automatically starts, prints the message, and stops the box.\n\tpterm.DefaultBox.Println(\"Hello, World!\")\n}\n\n```\n\n</details>\n\n### box/title\n\n![Animation](https://raw.githubusercontent.com/pterm/pterm/master/_examples/box/title/animation.svg)\n\n<details>\n\n<summary>SHOW SOURCE</summary>\n\n```go\npackage main\n\nimport \"github.com/pterm/pterm\"\n\nfunc main() {\n\t// Create a default box with specified padding\n\tpaddedBox := pterm.DefaultBox.WithLeftPadding(4).WithRightPadding(4).WithTopPadding(1).WithBottomPadding(1)\n\n\t// Define a title for the box\n\ttitle := pterm.LightRed(\"I'm a box!\")\n\n\t// Create boxes with the title positioned differently and containing different content\n\tbox1 := paddedBox.WithTitle(title).Sprint(\"Hello, World!\\n      1\")                         // Title at default position (top left)\n\tbox2 := paddedBox.WithTitle(title).WithTitleTopCenter().Sprint(\"Hello, World!\\n      2\")    // Title at top center\n\tbox3 := paddedBox.WithTitle(title).WithTitleTopRight().Sprint(\"Hello, World!\\n      3\")     // Title at top right\n\tbox4 := paddedBox.WithTitle(title).WithTitleBottomRight().Sprint(\"Hello, World!\\n      4\")  // Title at bottom right\n\tbox5 := paddedBox.WithTitle(title).WithTitleBottomCenter().Sprint(\"Hello, World!\\n      5\") // Title at bottom center\n\tbox6 := paddedBox.WithTitle(title).WithTitleBottomLeft().Sprint(\"Hello, World!\\n      6\")   // Title at bottom left\n\tbox7 := paddedBox.WithTitle(title).WithTitleTopLeft().Sprint(\"Hello, World!\\n      7\")      // Title at top left\n\n\t// Render the boxes in a panel layout\n\tpterm.DefaultPanel.WithPanels([][]pterm.Panel{\n\t\t{{box1}, {box2}, {box3}},\n\t\t{{box4}, {box5}, {box6}},\n\t\t{{box7}},\n\t}).Render()\n}\n\n```\n\n</details>\n\n### bulletlist/demo\n\n![Animation](https://raw.githubusercontent.com/pterm/pterm/master/_examples/bulletlist/demo/animation.svg)\n\n<details>\n\n<summary>SHOW SOURCE</summary>\n\n```go\npackage main\n\nimport (\n\t\"github.com/pterm/pterm\"\n\t\"github.com/pterm/pterm/putils\"\n)\n\nfunc main() {\n\t// Define a list of bullet list items with different levels.\n\tbulletListItems := []pterm.BulletListItem{\n\t\t{Level: 0, Text: \"Level 0\"}, // Level 0 item\n\t\t{Level: 1, Text: \"Level 1\"}, // Level 1 item\n\t\t{Level: 2, Text: \"Level 2\"}, // Level 2 item\n\t}\n\n\t// Use the default bullet list style to render the list items.\n\tpterm.DefaultBulletList.WithItems(bulletListItems).Render()\n\n\t// Define a string with different levels of indentation.\n\ttext := `0\n 1\n  2\n   3`\n\n\t// Convert the indented string to a bullet list and render it.\n\tputils.BulletListFromString(text, \" \").Render()\n}\n\n```\n\n</details>\n\n### bulletlist/customized\n\n![Animation](https://raw.githubusercontent.com/pterm/pterm/master/_examples/bulletlist/customized/animation.svg)\n\n<details>\n\n<summary>SHOW SOURCE</summary>\n\n```go\npackage main\n\nimport (\n\t\"github.com/pterm/pterm\"\n)\n\nfunc main() {\n\t// Define a list of bullet list items with different styles and levels.\n\tbulletListItems := []pterm.BulletListItem{\n\t\t{\n\t\t\tLevel:       0,                            // Level 0 (top level)\n\t\t\tText:        \"Blue\",                       // Text to display\n\t\t\tTextStyle:   pterm.NewStyle(pterm.FgBlue), // Text color\n\t\t\tBulletStyle: pterm.NewStyle(pterm.FgRed),  // Bullet color\n\t\t},\n\t\t{\n\t\t\tLevel:       1,                                  // Level 1 (sub-item)\n\t\t\tText:        \"Green\",                            // Text to display\n\t\t\tTextStyle:   pterm.NewStyle(pterm.FgGreen),      // Text color\n\t\t\tBullet:      \"-\",                                // Custom bullet symbol\n\t\t\tBulletStyle: pterm.NewStyle(pterm.FgLightWhite), // Bullet color\n\t\t},\n\t\t{\n\t\t\tLevel:       2,                              // Level 2 (sub-sub-item)\n\t\t\tText:        \"Cyan\",                         // Text to display\n\t\t\tTextStyle:   pterm.NewStyle(pterm.FgCyan),   // Text color\n\t\t\tBullet:      \">\",                            // Custom bullet symbol\n\t\t\tBulletStyle: pterm.NewStyle(pterm.FgYellow), // Bullet color\n\t\t},\n\t}\n\n\t// Create a bullet list with the defined items and render it.\n\tpterm.DefaultBulletList.WithItems(bulletListItems).Render()\n}\n\n```\n\n</details>\n\n### center/demo\n\n![Animation](https://raw.githubusercontent.com/pterm/pterm/master/_examples/center/demo/animation.svg)\n\n<details>\n\n<summary>SHOW SOURCE</summary>\n\n```go\npackage main\n\nimport (\n\t\"github.com/pterm/pterm\"\n\t\"github.com/pterm/pterm/putils\"\n)\n\nfunc main() {\n\t// Print a block of text centered in the terminal\n\tpterm.DefaultCenter.Println(\"This text is centered!\\nIt centers the whole block by default.\\nIn that way you can do stuff like this:\")\n\n\t// Generate BigLetters and store in 's'\n\ts, _ := pterm.DefaultBigText.WithLetters(putils.LettersFromString(\"PTerm\")).Srender()\n\n\t// Print the BigLetters 's' centered in the terminal\n\tpterm.DefaultCenter.Println(s)\n\n\t// Print each line of the text separately centered in the terminal\n\tpterm.DefaultCenter.WithCenterEachLineSeparately().Println(\"This text is centered!\\nBut each line is\\ncentered\\nseparately\")\n}\n\n```\n\n</details>\n\n### coloring/demo\n\n![Animation](https://raw.githubusercontent.com/pterm/pterm/master/_examples/coloring/demo/animation.svg)\n\n<details>\n\n<summary>SHOW SOURCE</summary>\n\n```go\npackage main\n\nimport \"github.com/pterm/pterm\"\n\nfunc main() {\n\t// Create a table with different foreground and background colors.\n\tpterm.DefaultTable.WithData([][]string{\n\t\t{pterm.FgBlack.Sprint(\"Black\"), pterm.FgRed.Sprint(\"Red\"), pterm.FgGreen.Sprint(\"Green\"), pterm.FgYellow.Sprint(\"Yellow\")},\n\t\t{\"\", pterm.FgLightRed.Sprint(\"Light Red\"), pterm.FgLightGreen.Sprint(\"Light Green\"), pterm.FgLightYellow.Sprint(\"Light Yellow\")},\n\t\t{pterm.BgBlack.Sprint(\"Black\"), pterm.BgRed.Sprint(\"Red\"), pterm.BgGreen.Sprint(\"Green\"), pterm.BgYellow.Sprint(\"Yellow\")},\n\t\t{\"\", pterm.BgLightRed.Sprint(\"Light Red\"), pterm.BgLightGreen.Sprint(\"Light Green\"), pterm.BgLightYellow.Sprint(\"Light Yellow\")},\n\t\t{pterm.FgBlue.Sprint(\"Blue\"), pterm.FgMagenta.Sprint(\"Magenta\"), pterm.FgCyan.Sprint(\"Cyan\"), pterm.FgWhite.Sprint(\"White\")},\n\t\t{pterm.FgLightBlue.Sprint(\"Light Blue\"), pterm.FgLightMagenta.Sprint(\"Light Magenta\"), pterm.FgLightCyan.Sprint(\"Light Cyan\"), pterm.FgLightWhite.Sprint(\"Light White\")},\n\t\t{pterm.BgBlue.Sprint(\"Blue\"), pterm.BgMagenta.Sprint(\"Magenta\"), pterm.BgCyan.Sprint(\"Cyan\"), pterm.BgWhite.Sprint(\"White\")},\n\t\t{pterm.BgLightBlue.Sprint(\"Light Blue\"), pterm.BgLightMagenta.Sprint(\"Light Magenta\"), pterm.BgLightCyan.Sprint(\"Light Cyan\"), pterm.BgLightWhite.Sprint(\"Light White\")},\n\t}).Render() // Render the table.\n\n\tpterm.Println()\n\n\t// Print words in different colors.\n\tpterm.Println(pterm.Red(\"Hello, \") + pterm.Green(\"World\") + pterm.Cyan(\"!\"))\n\tpterm.Println(pterm.Red(\"Even \" + pterm.Cyan(\"nested \") + pterm.Green(\"colors \") + \"are supported!\"))\n\n\tpterm.Println()\n\n\t// Create a new style with a red background, light green foreground, and bold text.\n\tstyle := pterm.NewStyle(pterm.BgRed, pterm.FgLightGreen, pterm.Bold)\n\t// Print text using the created style.\n\tstyle.Println(\"This text uses a style and is bold and light green with a red background!\")\n}\n\n```\n\n</details>\n\n### coloring/disable-output\n\n![Animation](https://raw.githubusercontent.com/pterm/pterm/master/_examples/coloring/disable-output/animation.svg)\n\n<details>\n\n<summary>SHOW SOURCE</summary>\n\n```go\npackage main\n\nimport \"github.com/pterm/pterm\"\n\nfunc main() {\n\t// Loop from 0 to 14\n\tfor i := 0; i < 15; i++ {\n\t\tswitch i {\n\t\tcase 5:\n\t\t\t// At the 5th iteration, print a message and disable the output\n\t\t\tpterm.Info.Println(\"Disabled Output!\")\n\t\t\tpterm.DisableOutput()\n\t\tcase 10:\n\t\t\t// At the 10th iteration, enable the output and print a message\n\t\t\tpterm.EnableOutput()\n\t\t\tpterm.Info.Println(\"Enabled Output!\")\n\t\t}\n\n\t\t// Print a progress message for each iteration\n\t\tpterm.Printf(\"Printing something... [%d/%d]\\n\", i, 15)\n\t}\n}\n\n```\n\n</details>\n\n### coloring/fade-colors\n\n![Animation](https://raw.githubusercontent.com/pterm/pterm/master/_examples/coloring/fade-colors/animation.svg)\n\n<details>\n\n<summary>SHOW SOURCE</summary>\n\n```go\npackage main\n\nimport (\n\t\"github.com/pterm/pterm\"\n)\n\nfunc main() {\n\t// Print an informational message.\n\tpterm.Info.Println(\"RGB colors only work in Terminals which support TrueColor.\")\n\n\t// Define the start and end points for the color gradient.\n\tstartColor := pterm.NewRGB(0, 255, 255) // Cyan\n\tendColor := pterm.NewRGB(255, 0, 255)   // Magenta\n\n\t// Get the terminal height to determine the gradient range.\n\tterminalHeight := pterm.GetTerminalHeight()\n\n\t// Loop over the range of the terminal height to create a color gradient.\n\tfor i := 0; i < terminalHeight-2; i++ {\n\t\t// Calculate the fade factor for the current step in the gradient.\n\t\tfadeFactor := float32(i) / float32(terminalHeight-2)\n\n\t\t// Create a color that represents the current step in the gradient.\n\t\tcurrentColor := startColor.Fade(0, 1, fadeFactor, endColor)\n\n\t\t// Print a string with the current color.\n\t\tcurrentColor.Println(\"Hello, World!\")\n\t}\n}\n\n```\n\n</details>\n\n### coloring/fade-colors-rgb-style\n\n![Animation](https://raw.githubusercontent.com/pterm/pterm/master/_examples/coloring/fade-colors-rgb-style/animation.svg)\n\n<details>\n\n<summary>SHOW SOURCE</summary>\n\n```go\npackage main\n\nimport (\n\t\"strings\"\n\n\t\"github.com/pterm/pterm\"\n)\n\nfunc main() {\n\t// Define RGB colors\n\twhite := pterm.NewRGB(255, 255, 255)\n\tgrey := pterm.NewRGB(128, 128, 128)\n\tblack := pterm.NewRGB(0, 0, 0)\n\tred := pterm.NewRGB(255, 0, 0)\n\tpurple := pterm.NewRGB(255, 0, 255)\n\tgreen := pterm.NewRGB(0, 255, 0)\n\n\t// Define strings to be printed\n\tstr1 := \"RGB colors only work in Terminals which support TrueColor.\"\n\tstr2 := \"The background and foreground colors can be customized individually.\"\n\tstr3 := \"Styles can also be applied. For example: Bold or Italic.\"\n\n\t// Print first string with color fading from white to purple\n\tprintFadedString(str1, white, purple, grey, black)\n\n\t// Print second string with color fading from purple to red\n\tprintFadedString(str2, black, purple, red, red)\n\n\t// Print third string with color fading from white to green and style changes\n\tprintStyledString(str3, white, green, red, black)\n}\n\n// printFadedString prints a string with color fading effect\nfunc printFadedString(str string, fgStart, fgEnd, bgStart, bgEnd pterm.RGB) {\n\tstrs := strings.Split(str, \"\")\n\tvar result string\n\tfor i := 0; i < len(str); i++ {\n\t\t// Create a style with color fading effect\n\t\tstyle := pterm.NewRGBStyle(fgStart.Fade(0, float32(len(str)), float32(i), fgEnd), bgStart.Fade(0, float32(len(str)), float32(i), bgEnd))\n\t\t// Append styled letter to result string\n\t\tresult += style.Sprint(strs[i])\n\t}\n\tpterm.Println(result)\n}\n\n// printStyledString prints a string with color fading and style changes\nfunc printStyledString(str string, fgStart, fgEnd, bgStart, bgEnd pterm.RGB) {\n\tstrs := strings.Split(str, \"\")\n\tvar result string\n\tboldStr := strings.Split(\"Bold\", \"\")\n\titalicStr := strings.Split(\"Italic\", \"\")\n\tbold, italic := 0, 0\n\tfor i := 0; i < len(str); i++ {\n\t\t// Create a style with color fading effect\n\t\tstyle := pterm.NewRGBStyle(fgStart.Fade(0, float32(len(str)), float32(i), fgEnd), bgStart.Fade(0, float32(len(str)), float32(i), bgEnd))\n\t\t// Check if the next letters are \"Bold\" or \"Italic\" and add the corresponding style\n\t\tif bold < len(boldStr) && i+len(boldStr)-bold <= len(strs) && strings.Join(strs[i:i+len(boldStr)-bold], \"\") == strings.Join(boldStr[bold:], \"\") {\n\t\t\tstyle = style.AddOptions(pterm.Bold)\n\t\t\tbold++\n\t\t} else if italic < len(italicStr) && i+len(italicStr)-italic < len(strs) && strings.Join(strs[i:i+len(italicStr)-italic], \"\") == strings.Join(italicStr[italic:], \"\") {\n\t\t\tstyle = style.AddOptions(pterm.Italic)\n\t\t\titalic++\n\t\t}\n\t\t// Append styled letter to result string\n\t\tresult += style.Sprint(strs[i])\n\t}\n\tpterm.Println(result)\n}\n\n```\n\n</details>\n\n### coloring/fade-multiple-colors\n\n![Animation](https://raw.githubusercontent.com/pterm/pterm/master/_examples/coloring/fade-multiple-colors/animation.svg)\n\n<details>\n\n<summary>SHOW SOURCE</summary>\n\n```go\npackage main\n\nimport (\n\t\"strings\"\n\n\t\"github.com/pterm/pterm\"\n)\n\nfunc main() {\n\t// Define RGB values for gradient points.\n\tstartColor := pterm.NewRGB(0, 255, 255)\n\tfirstPoint := pterm.NewRGB(255, 0, 255)\n\tsecondPoint := pterm.NewRGB(255, 0, 0)\n\tthirdPoint := pterm.NewRGB(0, 255, 0)\n\tendColor := pterm.NewRGB(255, 255, 255)\n\n\t// Define the string to be printed.\n\tstr := \"RGB colors only work in Terminals which support TrueColor.\"\n\tstrs := strings.Split(str, \"\")\n\n\t// Initialize an empty string for the faded info.\n\tvar fadeInfo string\n\n\t// Loop over the string length to create a gradient effect.\n\tfor i := 0; i < len(str); i++ {\n\t\t// Append each character of the string with a faded color to the info string.\n\t\tfadeInfo += startColor.Fade(0, float32(len(str)), float32(i), firstPoint).Sprint(strs[i])\n\t}\n\n\t// Print the info string with gradient effect.\n\tpterm.Info.Println(fadeInfo)\n\n\t// Get the terminal height.\n\tterminalHeight := pterm.GetTerminalHeight()\n\n\t// Loop over the terminal height to print \"Hello, World!\" with a gradient effect.\n\tfor i := 0; i < terminalHeight-2; i++ {\n\t\t// Print the string with a color that fades from startColor to endColor.\n\t\tstartColor.Fade(0, float32(terminalHeight-2), float32(i), firstPoint, secondPoint, thirdPoint, endColor).Println(\"Hello, World!\")\n\t}\n}\n\n```\n\n</details>\n\n### coloring/override-default-printers\n\n![Animation](https://raw.githubusercontent.com/pterm/pterm/master/_examples/coloring/override-default-printers/animation.svg)\n\n<details>\n\n<summary>SHOW SOURCE</summary>\n\n```go\npackage main\n\nimport \"github.com/pterm/pterm\"\n\nfunc main() {\n\t// Print a default error message with PTerm's built-in Error style.\n\tpterm.Error.Println(\"This is the default Error\")\n\n\t// Override the default error prefix with a new text and style.\n\tpterm.Error.Prefix = pterm.Prefix{Text: \"OVERRIDE\", Style: pterm.NewStyle(pterm.BgCyan, pterm.FgRed)}\n\n\t// Print the error message again, this time with the overridden prefix.\n\tpterm.Error.Println(\"This is the default Error after the prefix was overridden\")\n}\n\n```\n\n</details>\n\n### coloring/print-color-rgb\n\n![Animation](https://raw.githubusercontent.com/pterm/pterm/master/_examples/coloring/print-color-rgb/animation.svg)\n\n<details>\n\n<summary>SHOW SOURCE</summary>\n\n```go\npackage main\n\nimport \"github.com/pterm/pterm\"\n\nfunc main() {\n\t// Create a new RGB color with values 178, 44, 199.\n\t// This color will be used for the text.\n\tpterm.NewRGB(178, 44, 199).Println(\"This text is printed with a custom RGB!\")\n\n\t// Create a new RGB color with values 15, 199, 209.\n\t// This color will be used for the text.\n\tpterm.NewRGB(15, 199, 209).Println(\"This text is printed with a custom RGB!\")\n\n\t// Create a new RGB color with values 201, 144, 30.\n\t// This color will be used for the background.\n\t// The 'true' argument indicates that the color is for the background.\n\tpterm.NewRGB(201, 144, 30, true).Println(\"This text is printed with a custom RGB background!\")\n}\n\n```\n\n</details>\n\n### coloring/print-color-rgb-style\n\n![Animation](https://raw.githubusercontent.com/pterm/pterm/master/_examples/coloring/print-color-rgb-style/animation.svg)\n\n<details>\n\n<summary>SHOW SOURCE</summary>\n\n```go\npackage main\n\nimport (\n\t\"github.com/pterm/pterm\"\n)\n\nfunc main() {\n\t// Define RGB colors for foreground and background.\n\tforegroundRGB := pterm.RGB{R: 187, G: 80, B: 0}\n\tbackgroundRGB := pterm.RGB{R: 0, G: 50, B: 123}\n\n\t// Create a new RGB style with the defined foreground and background colors.\n\trgbStyle := pterm.NewRGBStyle(foregroundRGB, backgroundRGB)\n\n\t// Print a string with the custom RGB style.\n\trgbStyle.Println(\"This text is not styled.\")\n\n\t// Add the 'Bold' option to the RGB style and print a string with this style.\n\trgbStyle.AddOptions(pterm.Bold).Println(\"This text is bold.\")\n\n\t// Add the 'Italic' option to the RGB style and print a string with this style.\n\trgbStyle.AddOptions(pterm.Italic).Println(\"This text is italic.\")\n}\n\n```\n\n</details>\n\n### demo/demo\n\n![Animation](https://raw.githubusercontent.com/pterm/pterm/master/_examples/demo/demo/animation.svg)\n\n<details>\n\n<summary>SHOW SOURCE</summary>\n\n```go\npackage main\n\nimport (\n\t\"flag\"\n\t\"math/rand\"\n\t\"reflect\"\n\t\"strconv\"\n\t\"strings\"\n\t\"time\"\n\n\t\"github.com/pterm/pterm\"\n\t\"github.com/pterm/pterm/putils\"\n)\n\n// Speed the demo up, by setting this flag.\n// Usefull for debugging.\n// Example:\n//\n//\tgo run main.go -speedup\nvar speedup = flag.Bool(\"speedup\", false, \"Speed up the demo\")\nvar skipIntro = flag.Bool(\"skip-intro\", false, \"Skips the intro\")\nvar second = time.Second\n\nvar pseudoProgramList = strings.Split(\"pseudo-excel pseudo-photoshop pseudo-chrome pseudo-outlook pseudo-explorer \"+\n\t\"pseudo-git pseudo-vsc pseudo-intellij pseudo-minecraft pseudo-scoop pseudo-chocolatey\", \" \")\n\nfunc main() {\n\tsetup() // Setup the demo (flags etc.)\n\n\t// Show intro\n\tif !*skipIntro {\n\t\tintroScreen()\n\t\tclear()\n\t}\n\n\tshowcase(\"Structured Logging\", 5, func() {\n\t\tlogger := pterm.DefaultLogger.\n\t\t\tWithLevel(pterm.LogLevelTrace)\n\n\t\tlogger.Trace(\"Doing not so important stuff\", logger.Args(\"priority\", \"super low\"))\n\n\t\ttime.Sleep(time.Second * 3)\n\n\t\tinterstingStuff := map[string]any{\n\t\t\t\"when were crayons invented\":  \"1903\",\n\t\t\t\"what is the meaning of life\": 42,\n\t\t\t\"is this interesting\":         true,\n\t\t}\n\t\tlogger.Debug(\"This might be interesting\", logger.ArgsFromMap(interstingStuff))\n\t\ttime.Sleep(time.Second * 3)\n\n\t\tlogger.Info(\"That was actually interesting\", logger.Args(\"such\", \"wow\"))\n\t\ttime.Sleep(time.Second * 3)\n\t\tlogger.Warn(\"Oh no, I see an error coming to us!\", logger.Args(\"speed\", 88, \"measures\", \"mph\"))\n\t\ttime.Sleep(time.Second * 3)\n\t\tlogger.Error(\"Damn, here it is!\", logger.Args(\"error\", \"something went wrong\"))\n\t\ttime.Sleep(time.Second * 3)\n\t\tlogger.Info(\"But what's really cool is, that you can print very long logs, and PTerm will automatically wrap them for you! Say goodbye to text, that has weird line breaks!\", logger.Args(\"very\", \"long\"))\n\t})\n\n\tshowcase(\"Progress bar\", 2, func() {\n\t\tpb, _ := pterm.DefaultProgressbar.WithTotal(len(pseudoProgramList)).WithTitle(\"Installing stuff\").Start()\n\t\tfor i := 0; i < pb.Total; i++ {\n\t\t\tpb.UpdateTitle(\"Installing \" + pseudoProgramList[i])\n\t\t\tif pseudoProgramList[i] == \"pseudo-minecraft\" {\n\t\t\t\tpterm.Warning.Println(\"Could not install pseudo-minecraft\\nThe company policy forbids games.\")\n\t\t\t} else {\n\t\t\t\tpterm.Success.Println(\"Installing \" + pseudoProgramList[i])\n\t\t\t}\n\t\t\tpb.Increment()\n\t\t\ttime.Sleep(second / 2)\n\t\t}\n\t\tpb.Stop()\n\t})\n\n\tshowcase(\"Spinner\", 2, func() {\n\t\tlist := pseudoProgramList[7:]\n\t\tspinner, _ := pterm.DefaultSpinner.Start(\"Installing stuff\")\n\t\tfor i := 0; i < len(list); i++ {\n\t\t\tspinner.UpdateText(\"Installing \" + list[i])\n\t\t\tif list[i] == \"pseudo-minecraft\" {\n\t\t\t\tpterm.Warning.Println(\"Could not install pseudo-minecraft\\nThe company policy forbids games.\")\n\t\t\t} else {\n\t\t\t\tpterm.Success.Println(\"Installing \" + list[i])\n\t\t\t}\n\t\t\ttime.Sleep(second)\n\t\t}\n\t\tspinner.Success()\n\t})\n\n\tshowcase(\"Live Output\", 2, func() {\n\t\tpterm.Info.Println(\"You can use an Area to display changing output:\")\n\t\tpterm.Println()\n\t\tarea, _ := pterm.DefaultArea.WithCenter().Start() // Start the Area printer, with the Center option.\n\t\tfor i := 0; i < 10; i++ {\n\t\t\tstr, _ := pterm.DefaultBigText.WithLetters(putils.LettersFromString(time.Now().Format(\"15:04:05\"))).Srender() // Save current time in str.\n\t\t\tarea.Update(str)                                                                                              // Update Area contents.\n\t\t\ttime.Sleep(time.Second)\n\t\t}\n\t\tarea.Stop()\n\t})\n\n\tshowcase(\"Tables\", 4, func() {\n\t\tfor i := 0; i < 3; i++ {\n\t\t\tpterm.Println()\n\t\t}\n\t\ttd := [][]string{\n\t\t\t{\"Library\", \"Description\"},\n\t\t\t{\"PTerm\", \"Make beautiful CLIs\"},\n\t\t\t{\"Testza\", \"Programmer friendly test framework\"},\n\t\t\t{\"Cursor\", \"Move the cursor around the terminal\"},\n\t\t}\n\t\ttable, _ := pterm.DefaultTable.WithHasHeader().WithData(td).Srender()\n\t\tboxedTable, _ := pterm.DefaultTable.WithHasHeader().WithData(td).WithBoxed().Srender()\n\t\tpterm.DefaultCenter.Println(table)\n\t\tpterm.DefaultCenter.Println(boxedTable)\n\t})\n\n\tshowcase(\"TrueColor Support\", 7, func() {\n\t\tfrom := pterm.NewRGB(0, 255, 255) // This RGB value is used as the gradients start point.\n\t\tto := pterm.NewRGB(255, 0, 255)   // This RGB value is used as the gradients first point.\n\n\t\tstr := \"If your terminal has TrueColor support, you can use RGB colors!\\nYou can even fade them :)\\n\\nLorem ipsum dolor sit amet, consetetur sadipscing elitr, sed diam nonumy eirmod tempor invidunt ut labore et dolore magna aliquyam erat, sed diam voluptua. At vero eos et accusam et justo duo dolores et ea rebum. Stet clita kasd gubergren, no sea takimata sanctus est Lorem ipsum dolor sit amet. Lorem ipsum dolor sit amet, consetetur sadipscing elitr, sed diam nonumy eirmod tempor invidunt ut labore et dolore magna aliquyam erat, sed diam voluptua. At vero eos et accusam et justo duo dolores et ea rebum. Stet clita kasd gubergren, no sea takimata sanctus est Lorem ipsum dolor sit amet.\"\n\t\tstrs := strings.Split(str, \"\")\n\t\tvar fadeInfo string // String which will be used to print info.\n\t\t// For loop over the range of the string length.\n\t\tfor i := 0; i < len(str); i++ {\n\t\t\t// Append faded letter to info string.\n\t\t\tfadeInfo += from.Fade(0, float32(len(str)), float32(i), to).Sprint(strs[i])\n\t\t}\n\t\tpterm.DefaultCenter.WithCenterEachLineSeparately().Println(fadeInfo)\n\t})\n\n\tshowcase(\"Fully Customizable\", 2, func() {\n\t\tfor i := 0; i < 4; i++ {\n\t\t\tpterm.Println()\n\t\t}\n\t\ttext := \"All printers are fully customizable!\"\n\t\tarea := pterm.DefaultArea.WithCenter()\n\t\tarea.Update(pterm.DefaultBox.Sprintln(text))\n\t\ttime.Sleep(second)\n\t\tarea.Update(pterm.DefaultBox.WithTopPadding(1).Sprintln(text))\n\t\ttime.Sleep(second / 3)\n\t\tarea.Update(pterm.DefaultBox.WithTopPadding(1).WithBottomPadding(1).Sprintln(text))\n\t\ttime.Sleep(second / 3)\n\t\tarea.Update(pterm.DefaultBox.WithTopPadding(1).WithBottomPadding(1).WithLeftPadding(1).Sprintln(text))\n\t\ttime.Sleep(second / 3)\n\t\tarea.Update(pterm.DefaultBox.WithTopPadding(1).WithBottomPadding(1).WithLeftPadding(1).WithRightPadding(1).Sprintln(text))\n\t\ttime.Sleep(second / 3)\n\t\tarea.Update(pterm.DefaultBox.WithTopPadding(1).WithBottomPadding(1).WithLeftPadding(1).WithRightPadding(1).WithTitle(\"Some title!\").WithTitleTopLeft().Sprintln(text))\n\t\ttime.Sleep(second / 3)\n\t\tarea.Update(pterm.DefaultBox.WithTopPadding(1).WithBottomPadding(1).WithLeftPadding(1).WithRightPadding(1).WithTitle(\"Some title!\").WithTitleTopCenter().Sprintln(text))\n\t\ttime.Sleep(second / 3)\n\t\tarea.Update(pterm.DefaultBox.WithTopPadding(1).WithBottomPadding(1).WithLeftPadding(1).WithRightPadding(1).WithTitle(\"Some title!\").WithTitleTopRight().Sprintln(text))\n\t\ttime.Sleep(second / 3)\n\t\tarea.Update(pterm.DefaultBox.WithTopPadding(1).WithBottomPadding(1).WithLeftPadding(1).WithRightPadding(1).WithTitle(\"Some title!\").WithTitleBottomRight().Sprintln(text))\n\t\ttime.Sleep(second / 3)\n\t\tarea.Update(pterm.DefaultBox.WithTopPadding(1).WithBottomPadding(1).WithLeftPadding(1).WithRightPadding(1).WithTitle(\"Some title!\").WithTitleBottomCenter().Sprintln(text))\n\t\ttime.Sleep(second / 3)\n\t\tarea.Update(pterm.DefaultBox.WithTopPadding(1).WithBottomPadding(1).WithLeftPadding(1).WithRightPadding(1).WithTitle(\"Some title!\").WithTitleBottomLeft().Sprintln(text))\n\t\ttime.Sleep(second / 3)\n\t\tarea.Update(pterm.DefaultBox.WithTopPadding(1).WithBottomPadding(1).WithLeftPadding(1).WithRightPadding(1).WithBoxStyle(pterm.NewStyle(pterm.FgCyan)).Sprintln(text))\n\t\ttime.Sleep(second / 5)\n\t\tarea.Update(pterm.DefaultBox.WithTopPadding(1).WithBottomPadding(1).WithLeftPadding(1).WithRightPadding(1).WithBoxStyle(pterm.NewStyle(pterm.FgRed)).Sprintln(text))\n\t\ttime.Sleep(second / 5)\n\t\tarea.Update(pterm.DefaultBox.WithTopPadding(1).WithBottomPadding(1).WithLeftPadding(1).WithRightPadding(1).WithBoxStyle(pterm.NewStyle(pterm.FgGreen)).Sprintln(text))\n\t\ttime.Sleep(second / 5)\n\t\tarea.Update(pterm.DefaultBox.WithTopPadding(1).\n\t\t\tWithBottomPadding(1).\n\t\t\tWithLeftPadding(1).\n\t\t\tWithRightPadding(1).\n\t\t\tWithHorizontalString(\"═\").\n\t\t\tWithVerticalString(\"║\").\n\t\t\tWithBottomLeftCornerString(\"╗\").\n\t\t\tWithBottomRightCornerString(\"╔\").\n\t\t\tWithTopLeftCornerString(\"╝\").\n\t\t\tWithTopRightCornerString(\"╚\").\n\t\t\tSprintln(text))\n\t\tarea.Stop()\n\t})\n\n\tshowcase(\"Themes\", 2, func() {\n\t\tpterm.Info.Println(\"You can change the color theme of PTerm easily to fit your needs!\\nThis is the default one:\")\n\t\ttime.Sleep(second / 2)\n\t\t// Print every value of the default theme with its own style.\n\t\tv := reflect.ValueOf(pterm.ThemeDefault)\n\t\ttypeOfS := v.Type()\n\n\t\tif typeOfS == reflect.TypeOf(pterm.Theme{}) {\n\t\t\tfor i := 0; i < v.NumField(); i++ {\n\t\t\t\tfield, ok := v.Field(i).Interface().(pterm.Style)\n\t\t\t\tif ok {\n\t\t\t\t\tfield.Println(typeOfS.Field(i).Name)\n\t\t\t\t}\n\t\t\t\ttime.Sleep(time.Millisecond * 250)\n\t\t\t}\n\t\t}\n\t})\n\n\tshowcase(\"And much more!\", 3, func() {\n\t\tfor i := 0; i < 4; i++ {\n\t\t\tpterm.Println()\n\t\t}\n\t\tbox := pterm.DefaultBox.\n\t\t\tWithBottomPadding(1).\n\t\t\tWithTopPadding(1).\n\t\t\tWithLeftPadding(3).\n\t\t\tWithRightPadding(3).\n\t\t\tSprintf(\"Have fun exploring %s!\", pterm.Cyan(\"PTerm\"))\n\t\tpterm.DefaultCenter.Println(box)\n\t})\n}\n\nfunc setup() {\n\tflag.Parse()\n\tif *speedup {\n\t\tsecond = time.Millisecond * 200\n\t}\n}\n\nfunc introScreen() {\n\tptermLogo, _ := pterm.DefaultBigText.WithLetters(\n\t\tputils.LettersFromStringWithStyle(\"P\", pterm.NewStyle(pterm.FgLightCyan)),\n\t\tputils.LettersFromStringWithStyle(\"Term\", pterm.NewStyle(pterm.FgLightMagenta))).\n\t\tSrender()\n\n\tpterm.DefaultCenter.Print(ptermLogo)\n\n\tpterm.DefaultCenter.Print(pterm.DefaultHeader.WithFullWidth().WithBackgroundStyle(pterm.NewStyle(pterm.BgLightBlue)).WithMargin(10).Sprint(\"PTDP - PTerm Demo Program\"))\n\n\tpterm.Info.Println(\"This animation was generated with the latest version of PTerm!\" +\n\t\t\"\\nPTerm works on nearly every terminal and operating system.\" +\n\t\t\"\\nIt's super easy to use!\" +\n\t\t\"\\nIf you want, you can customize everything :)\" +\n\t\t\"\\nYou can see the code of this demo in the \" + pterm.LightMagenta(\"./_examples/demo\") + \" directory.\" +\n\t\t\"\\n\" +\n\t\t\"\\nThis demo was updated at: \" + pterm.Green(time.Now().Format(\"02 Jan 2006 - 15:04:05 MST\")))\n\tpterm.Println()\n\tintroSpinner, _ := pterm.DefaultSpinner.WithShowTimer(false).WithRemoveWhenDone(true).Start(\"Waiting for 15 seconds...\")\n\ttime.Sleep(second)\n\tfor i := 14; i > 0; i-- {\n\t\tif i > 1 {\n\t\t\tintroSpinner.UpdateText(\"Waiting for \" + strconv.Itoa(i) + \" seconds...\")\n\t\t} else {\n\t\t\tintroSpinner.UpdateText(\"Waiting for \" + strconv.Itoa(i) + \" second...\")\n\t\t}\n\t\ttime.Sleep(second)\n\t}\n\tintroSpinner.Stop()\n}\n\nfunc clear() {\n\tprint(\"\\033[H\\033[2J\")\n}\n\nfunc showcase(title string, seconds int, content func()) {\n\tpterm.DefaultHeader.WithBackgroundStyle(pterm.NewStyle(pterm.BgLightBlue)).WithFullWidth().Println(title)\n\tpterm.Println()\n\ttime.Sleep(second / 2)\n\tcontent()\n\ttime.Sleep(second * time.Duration(seconds))\n\tprint(\"\\033[H\\033[2J\")\n}\n\nfunc randomInt(min, max int) int {\n\trand.Seed(time.Now().UnixNano())\n\treturn rand.Intn(max-min+1) + min\n}\n\n```\n\n</details>\n\n### header/demo\n\n![Animation](https://raw.githubusercontent.com/pterm/pterm/master/_examples/header/demo/animation.svg)\n\n<details>\n\n<summary>SHOW SOURCE</summary>\n\n```go\npackage main\n\nimport \"github.com/pterm/pterm\"\n\nfunc main() {\n\t// Print a default header.\n\t// This uses the default settings of PTerm to print a header.\n\tpterm.DefaultHeader.Println(\"This is the default header!\")\n\n\t// Print a spacer line for better readability.\n\tpterm.Println()\n\n\t// Print a full-width header.\n\t// This uses the WithFullWidth() option of PTerm to print a header that spans the full width of the terminal.\n\tpterm.DefaultHeader.WithFullWidth().Println(\"This is a full-width header.\")\n}\n\n```\n\n</details>\n\n### header/custom\n\n![Animation](https://raw.githubusercontent.com/pterm/pterm/master/_examples/header/custom/animation.svg)\n\n<details>\n\n<summary>SHOW SOURCE</summary>\n\n```go\npackage main\n\nimport \"github.com/pterm/pterm\"\n\nfunc main() {\n\t// Customize the DefaultHeader with a cyan background, black text, and a margin of 15.\n\tpterm.DefaultHeader.WithMargin(15).WithBackgroundStyle(pterm.NewStyle(pterm.BgCyan)).WithTextStyle(pterm.NewStyle(pterm.FgBlack)).Println(\"This is a custom header!\")\n\n\t// Define a new HeaderPrinter with a red background, black text, and a margin of 20.\n\tnewHeader := pterm.HeaderPrinter{\n\t\tTextStyle:       pterm.NewStyle(pterm.FgBlack),\n\t\tBackgroundStyle: pterm.NewStyle(pterm.BgRed),\n\t\tMargin:          20,\n\t}\n\n\t// Print the custom header using the new HeaderPrinter.\n\tnewHeader.Println(\"This is a custom header!\")\n}\n\n```\n\n</details>\n\n### heatmap/demo\n\n![Animation](https://raw.githubusercontent.com/pterm/pterm/master/_examples/heatmap/demo/animation.svg)\n\n<details>\n\n<summary>SHOW SOURCE</summary>\n\n```go\npackage main\n\nimport (\n\t\"github.com/pterm/pterm\"\n)\n\nfunc main() {\n\t// Define the data for the heatmap. Each sub-array represents a row in the heatmap.\n\tdata := [][]float32{\n\t\t{0.9, 0.2, -0.7, 0.4, -0.5, 0.6, -0.3, 0.8, -0.1, -1.0, 0.1, -0.8, 0.3},\n\t\t{0.2, -0.7, -0.5, -0.3, -0.1, 0.1, 0.3, 0.5, 0.9, -0.9, -0.7, -0.5, -0.3},\n\t\t{0.4, 0.4, -0.3, -1.0, 0.3, -0.2, -0.9, 0.5, -0.3, -1.0, 0.6, -0.2, -0.9},\n\t\t{0.9, -0.5, -0.1, 0.3, 1, -0.7, -0.3, 0.1, 0.7, -0.9, -0.5, 0.2, 0.6},\n\t\t{0.5, 0.6, 0.1, -0.2, -0.7, 0.8, 0.6, 0.1, -0.5, -0.7, 0.7, 0.3, 0.0},\n\t}\n\n\t// Define the labels for the X and Y axes of the heatmap.\n\theaderData := pterm.HeatmapAxis{\n\t\tXAxis: []string{\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\"},\n\t\tYAxis: []string{\"1\", \"2\", \"3\", \"4\", \"5\"},\n\t}\n\n\t// Create a heatmap with the defined data and axis labels, and enable RGB colors.\n\t// Then render the heatmap.\n\tpterm.DefaultHeatmap.WithAxisData(headerData).WithData(data).WithEnableRGB().Render()\n}\n\n```\n\n</details>\n\n### heatmap/custom_colors\n\n![Animation](https://raw.githubusercontent.com/pterm/pterm/master/_examples/heatmap/custom_colors/animation.svg)\n\n<details>\n\n<summary>SHOW SOURCE</summary>\n\n```go\npackage main\n\nimport (\n\t\"github.com/pterm/pterm\"\n)\n\nfunc main() {\n\t// Define the data for the heatmap\n\tdata := [][]float32{\n\t\t{0.9, 0.2, -0.7, 0.4, -0.5, 0.6, -0.3, 0.8, -0.1, -1.0, 0.1, -0.8, 0.3},\n\t\t{0.2, -0.7, -0.5, -0.3, -0.1, 0.1, 0.3, 0.5, 0.9, -0.9, -0.7, -0.5, -0.3},\n\t\t{0.4, 0.4, -0.3, -1.0, 0.3, -0.2, -0.9, 0.5, -0.3, -1.0, 0.6, -0.2, -0.9},\n\t\t{0.9, -0.5, -0.1, 0.3, 1, -0.7, -0.3, 0.1, 0.7, -0.9, -0.5, 0.2, 0.6},\n\t\t{0.5, 0.6, 0.1, -0.2, -0.7, 0.8, 0.6, 0.1, -0.5, -0.7, 0.7, 0.3, 0.0},\n\t}\n\n\t// Define the axis labels for the heatmap\n\theaderData := pterm.HeatmapAxis{\n\t\tXAxis: []string{\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\"},\n\t\tYAxis: []string{\"1\", \"2\", \"3\", \"4\", \"5\"},\n\t}\n\n\t// Print an informational message\n\tpterm.Info.Println(\"The following table has no rgb (supported by every terminal), no axis data and a legend.\")\n\tpterm.Println()\n\n\t// Create the heatmap with the defined data and options, and render it\n\tpterm.DefaultHeatmap.\n\t\tWithData(data).\n\t\tWithBoxed(false).\n\t\tWithAxisData(headerData).\n\t\tWithLegend(false).\n\t\tWithColors(pterm.BgBlue, pterm.BgRed, pterm.BgGreen, pterm.BgYellow).\n\t\tWithLegend().\n\t\tRender()\n}\n\n```\n\n</details>\n\n### heatmap/custom_legend\n\n![Animation](https://raw.githubusercontent.com/pterm/pterm/master/_examples/heatmap/custom_legend/animation.svg)\n\n<details>\n\n<summary>SHOW SOURCE</summary>\n\n```go\npackage main\n\nimport (\n\t\"github.com/pterm/pterm\"\n)\n\nfunc main() {\n\t// Define the data for the heatmap\n\tdata := [][]float32{\n\t\t{0.9, 0.2, -0.7, 0.4, -0.5, 0.6, -0.3, 0.8, -0.1, -1.0, 0.1, -0.8, 0.3},\n\t\t{0.2, -0.7, -0.5, -0.3, -0.1, 0.1, 0.3, 0.5, 0.9, -0.9, -0.7, -0.5, -0.3},\n\t\t{0.4, 0.4, -0.3, -1.0, 0.3, -0.2, -0.9, 0.5, -0.3, -1.0, 0.6, -0.2, -0.9},\n\t\t{0.9, -0.5, -0.1, 0.3, 1, -0.7, -0.3, 0.1, 0.7, -0.9, -0.5, 0.2, 0.6},\n\t\t{0.5, 0.6, 0.1, -0.2, -0.7, 0.8, 0.6, 0.1, -0.5, -0.7, 0.7, 0.3, 0.0},\n\t}\n\n\t// Define the header data for the heatmap\n\theaderData := pterm.HeatmapAxis{\n\t\tXAxis: []string{\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\"},\n\t\tYAxis: []string{\"1\", \"2\", \"3\", \"4\", \"5\"},\n\t}\n\n\t// Print an informational message\n\tpterm.Info.Println(\"The following table has rgb (not supported by every terminal), axis data and a custom legend.\")\n\tpterm.Println()\n\n\t// Create the heatmap with the defined data and options\n\t// Options are chained in a single line for simplicity\n\tpterm.DefaultHeatmap.\n\t\tWithData(data).\n\t\tWithBoxed(false).\n\t\tWithAxisData(headerData).\n\t\tWithEnableRGB().\n\t\tWithLegendLabel(\"custom\").\n\t\tWithLegendOnlyColoredCells().\n\t\tRender() // Render the heatmap\n}\n\n```\n\n</details>\n\n### heatmap/custom_rgb\n\n![Animation](https://raw.githubusercontent.com/pterm/pterm/master/_examples/heatmap/custom_rgb/animation.svg)\n\n<details>\n\n<summary>SHOW SOURCE</summary>\n\n```go\npackage main\n\nimport (\n\t\"github.com/pterm/pterm\"\n)\n\nfunc main() {\n\t// Define the data for the heatmap.\n\tdata := [][]float32{\n\t\t{0.9, 0.2, -0.7, 0.4, -0.5, 0.6, -0.3, 0.8, -0.1, -1.0, 0.1, -0.8, 0.3},\n\t\t{0.2, -0.7, -0.5, -0.3, -0.1, 0.1, 0.3, 0.5, 0.9, -0.9, -0.7, -0.5, -0.3},\n\t\t{0.4, 0.4, -0.3, -1.0, 0.3, -0.2, -0.9, 0.5, -0.3, -1.0, 0.6, -0.2, -0.9},\n\t\t{0.9, -0.5, -0.1, 0.3, 1, -0.7, -0.3, 0.1, 0.7, -0.9, -0.5, 0.2, 0.6},\n\t\t{0.5, 0.6, 0.1, -0.2, -0.7, 0.8, 0.6, 0.1, -0.5, -0.7, 0.7, 0.3, 0.0},\n\t}\n\n\t// Define the axis labels for the heatmap.\n\taxisLabels := pterm.HeatmapAxis{\n\t\tXAxis: []string{\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\"},\n\t\tYAxis: []string{\"1\", \"2\", \"3\", \"4\", \"5\"},\n\t}\n\n\t// Print an informational message.\n\tpterm.Info.Println(\"The following table has rgb (not supported by every terminal), axis data and a legend.\")\n\tpterm.Println()\n\n\t// Define the color range for the heatmap.\n\trgbRange := []pterm.RGB{\n\t\tpterm.NewRGB(0, 0, 255),\n\t\tpterm.NewRGB(255, 0, 0),\n\t\tpterm.NewRGB(0, 255, 0),\n\t\tpterm.NewRGB(255, 255, 0),\n\t}\n\n\t// Create and render the heatmap.\n\tpterm.DefaultHeatmap.\n\t\tWithData(data).\n\t\tWithBoxed(false).\n\t\tWithAxisData(axisLabels).\n\t\tWithEnableRGB().\n\t\tWithRGBRange(rgbRange...).\n\t\tRender()\n}\n\n```\n\n</details>\n\n### heatmap/no_grid\n\n![Animation](https://raw.githubusercontent.com/pterm/pterm/master/_examples/heatmap/no_grid/animation.svg)\n\n<details>\n\n<summary>SHOW SOURCE</summary>\n\n```go\npackage main\n\nimport (\n\t\"github.com/pterm/pterm\"\n)\n\nfunc main() {\n\t// Define the data for the heatmap.\n\tdata := [][]float32{\n\t\t{0.9, 0.2, -0.7, 0.4, -0.5, 0.6, -0.3, 0.8, -0.1, -1.0, 0.1, -0.8, 0.3},\n\t\t{0.2, -0.7, -0.5, -0.3, -0.1, 0.1, 0.3, 0.5, 0.9, -0.9, -0.7, -0.5, -0.3},\n\t\t{0.4, 0.4, -0.3, -1.0, 0.3, -0.2, -0.9, 0.5, -0.3, -1.0, 0.6, -0.2, -0.9},\n\t\t{0.9, -0.5, -0.1, 0.3, 1, -0.7, -0.3, 0.1, 0.7, -0.9, -0.5, 0.2, 0.6},\n\t\t{0.5, 0.6, 0.1, -0.2, -0.7, 0.8, 0.6, 0.1, -0.5, -0.7, 0.7, 0.3, 0.0},\n\t}\n\n\t// Define the axis data for the heatmap.\n\taxisData := pterm.HeatmapAxis{\n\t\tXAxis: []string{\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\"},\n\t\tYAxis: []string{\"1\", \"2\", \"3\", \"4\", \"5\"},\n\t}\n\n\t// Print an informational message.\n\tpterm.Info.Println(\"The following table has rgb (not supported by every terminal), axis data and a legend.\")\n\tpterm.Println()\n\n\t// Create the heatmap with the defined data and options, then render it.\n\tpterm.DefaultHeatmap.WithData(data).WithBoxed(false).WithAxisData(axisData).WithEnableRGB().WithLegend().WithGrid(false).Render()\n}\n\n```\n\n</details>\n\n### heatmap/separated\n\n![Animation](https://raw.githubusercontent.com/pterm/pterm/master/_examples/heatmap/separated/animation.svg)\n\n<details>\n\n<summary>SHOW SOURCE</summary>\n\n```go\npackage main\n\nimport \"github.com/pterm/pterm\"\n\nfunc main() {\n\t// Define the data for the heatmap.\n\tdata := [][]float32{\n\t\t{0.9, 0.2, -0.7, 0.4, -0.5, 0.6, -0.3, 0.8, -0.1, -1.0, 0.1, -0.8, 0.3},\n\t\t{0.2, -0.7, -0.5, -0.3, -0.1, 0.1, 0.3, 0.5, 0.9, -0.9, -0.7, -0.5, -0.3},\n\t\t{0.4, 0.4, -0.3, -1.0, 0.3, -0.2, -0.9, 0.5, -0.3, -1.0, 0.6, -0.2, -0.9},\n\t\t{0.9, -0.5, -0.1, 0.3, 1, -0.7, -0.3, 0.1, 0.7, -0.9, -0.5, 0.2, 0.6},\n\t\t{0.5, 0.6, 0.1, -0.2, -0.7, 0.8, 0.6, 0.1, -0.5, -0.7, 0.7, 0.3, 0.0},\n\t}\n\n\t// Define the axis labels for the heatmap.\n\theaderData := pterm.HeatmapAxis{\n\t\tXAxis: []string{\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\"},\n\t\tYAxis: []string{\"1\", \"2\", \"3\", \"4\", \"5\"},\n\t}\n\n\t// Print an informational message.\n\tpterm.Info.Println(\"The following table has no rgb (supported by every terminal), no axis data and no legend.\")\n\tpterm.Println()\n\n\t// Create the heatmap with the specified data and options, and render it.\n\tpterm.DefaultHeatmap.WithData(data).WithBoxed(false).WithAxisData(headerData).WithLegend(false).Render()\n}\n\n```\n\n</details>\n\n### interactive_confirm/demo\n\n![Animation](https://raw.githubusercontent.com/pterm/pterm/master/_examples/interactive_confirm/demo/animation.svg)\n\n<details>\n\n<summary>SHOW SOURCE</summary>\n\n```go\npackage main\n\nimport (\n\t\"github.com/pterm/pterm\"\n)\n\nfunc main() {\n\t// Show an interactive confirmation dialog and get the result.\n\tresult, _ := pterm.DefaultInteractiveConfirm.Show()\n\n\t// Print a blank line for better readability.\n\tpterm.Println()\n\n\t// Print the user's answer in a formatted way.\n\tpterm.Info.Printfln(\"You answered: %s\", boolToText(result))\n}\n\n// boolToText converts a boolean value to a colored text.\n// If the value is true, it returns a green \"Yes\".\n// If the value is false, it returns a red \"No\".\nfunc boolToText(b bool) string {\n\tif b {\n\t\treturn pterm.Green(\"Yes\")\n\t}\n\treturn pterm.Red(\"No\")\n}\n\n```\n\n</details>\n\n### interactive_continue/demo\n\n![Animation](https://raw.githubusercontent.com/pterm/pterm/master/_examples/interactive_continue/demo/animation.svg)\n\n<details>\n\n<summary>SHOW SOURCE</summary>\n\n```go\npackage main\n\nimport (\n\t\"github.com/pterm/pterm\"\n)\n\nfunc main() {\n\t// Create an interactive continue prompt with default settings\n\t// This will pause the program execution until the user presses enter\n\t// The message displayed is \"Press 'Enter' to continue...\"\n\tprompt := pterm.DefaultInteractiveContinue\n\n\t// Show the prompt and wait for user input\n\t// The returned result is the user's input (should be empty as it's a continue prompt)\n\t// The second return value is an error which is ignored here\n\tresult, _ := prompt.Show()\n\n\t// Print a blank line for better readability\n\tpterm.Println()\n\n\t// Print the user's input with an info prefix\n\t// As this is a continue prompt, the input should be empty\n\tpterm.Info.Printfln(\"You answered: %s\", result)\n}\n\n```\n\n</details>\n\n### interactive_multiselect/demo\n\n![Animation](https://raw.githubusercontent.com/pterm/pterm/master/_examples/interactive_multiselect/demo/animation.svg)\n\n<details>\n\n<summary>SHOW SOURCE</summary>\n\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"github.com/pterm/pterm\"\n)\n\nfunc main() {\n\t// Initialize an empty slice to hold the options.\n\tvar options []string\n\n\t// Populate the options slice with 100 options.\n\tfor i := 0; i < 100; i++ {\n\t\toptions = append(options, fmt.Sprintf(\"Option %d\", i))\n\t}\n\n\t// Add 5 more options to the slice, indicating the availability of fuzzy searching.\n\tfor i := 0; i < 5; i++ {\n\t\toptions = append(options, fmt.Sprintf(\"You can use fuzzy searching (%d)\", i))\n\t}\n\n\t// Use PTerm's interactive multiselect to present the options to the user and capture their selections.\n\t// The Show() method displays the options and waits for user input.\n\tselectedOptions, _ := pterm.DefaultInteractiveMultiselect.WithOptions(options).Show()\n\n\t// Print the selected options, highlighted in green.\n\tpterm.Info.Printfln(\"Selected options: %s\", pterm.Green(selectedOptions))\n}\n\n```\n\n</details>\n\n### interactive_multiselect/custom-checkmarks\n\n![Animation](https://raw.githubusercontent.com/pterm/pterm/master/_examples/interactive_multiselect/custom-checkmarks/animation.svg)\n\n<details>\n\n<summary>SHOW SOURCE</summary>\n\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"github.com/pterm/pterm\"\n)\n\nfunc main() {\n\t// Initialize an empty slice to hold the options\n\tvar options []string\n\n\t// Populate the options slice with 5 options\n\tfor i := 0; i < 5; i++ {\n\t\toptions = append(options, fmt.Sprintf(\"Option %d\", i))\n\t}\n\n\t// Create a new interactive multiselect printer with the options\n\t// Disable the filter and define the checkmark symbols\n\tprinter := pterm.DefaultInteractiveMultiselect.\n\t\tWithOptions(options).\n\t\tWithFilter(false).\n\t\tWithCheckmark(&pterm.Checkmark{Checked: pterm.Green(\"+\"), Unchecked: pterm.Red(\"-\")})\n\n\t// Show the interactive multiselect and get the selected options\n\tselectedOptions, _ := printer.Show()\n\n\t// Print the selected options\n\tpterm.Info.Printfln(\"Selected options: %s\", pterm.Green(selectedOptions))\n}\n\n```\n\n</details>\n\n### interactive_multiselect/custom-keys\n\n![Animation](https://raw.githubusercontent.com/pterm/pterm/master/_examples/interactive_multiselect/custom-keys/animation.svg)\n\n<details>\n\n<summary>SHOW SOURCE</summary>\n\n```go\npackage main\n\nimport (\n\t\"atomicgo.dev/keyboard/keys\"\n\t\"fmt\"\n\t\"github.com/pterm/pterm\"\n)\n\nfunc main() {\n\t// Initialize an empty slice to hold the options\n\tvar options []string\n\n\t// Populate the options slice with 5 options\n\tfor i := 0; i < 5; i++ {\n\t\toptions = append(options, fmt.Sprintf(\"Option %d\", i))\n\t}\n\n\t// Create a new interactive multiselect printer with the options\n\t// Disable the filter and set the keys for confirming and selecting options\n\tprinter := pterm.DefaultInteractiveMultiselect.\n\t\tWithOptions(options).\n\t\tWithFilter(false).\n\t\tWithKeyConfirm(keys.Enter).\n\t\tWithKeySelect(keys.Space)\n\n\t// Show the interactive multiselect and get the selected options\n\tselectedOptions, _ := printer.Show()\n\n\t// Print the selected options\n\tpterm.Info.Printfln(\"Selected options: %s\", pterm.Green(selectedOptions))\n}\n\n```\n\n</details>\n\n### interactive_select/demo\n\n![Animation](https://raw.githubusercontent.com/pterm/pterm/master/_examples/interactive_select/demo/animation.svg)\n\n<details>\n\n<summary>SHOW SOURCE</summary>\n\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"github.com/pterm/pterm\"\n)\n\nfunc main() {\n\t// Initialize an empty slice to hold the options\n\tvar options []string\n\n\t// Generate 100 options and add them to the options slice\n\tfor i := 0; i < 100; i++ {\n\t\toptions = append(options, fmt.Sprintf(\"Option %d\", i))\n\t}\n\n\t// Generate 5 additional options with a specific message and add them to the options slice\n\tfor i := 0; i < 5; i++ {\n\t\toptions = append(options, fmt.Sprintf(\"You can use fuzzy searching (%d)\", i))\n\t}\n\n\t// Use PTerm's interactive select feature to present the options to the user and capture their selection\n\t// The Show() method displays the options and waits for the user's input\n\tselectedOption, _ := pterm.DefaultInteractiveSelect.WithOptions(options).Show()\n\n\t// Display the selected option to the user with a green color for emphasis\n\tpterm.Info.Printfln(\"Selected option: %s\", pterm.Green(selectedOption))\n}\n\n```\n\n</details>\n\n### interactive_textinput/demo\n\n![Animation](https://raw.githubusercontent.com/pterm/pterm/master/_examples/interactive_textinput/demo/animation.svg)\n\n<details>\n\n<summary>SHOW SOURCE</summary>\n\n```go\npackage main\n\nimport (\n\t\"github.com/pterm/pterm\"\n)\n\nfunc main() {\n\t// Create an interactive text input with single line input mode and show it\n\tresult, _ := pterm.DefaultInteractiveTextInput.Show()\n\n\t// Print a blank line for better readability\n\tpterm.Println()\n\n\t// Print the user's answer with an info prefix\n\tpterm.Info.Printfln(\"You answered: %s\", result)\n}\n\n```\n\n</details>\n\n### interactive_textinput/default-value\n\n![Animation](https://raw.githubusercontent.com/pterm/pterm/master/_examples/interactive_textinput/default-value/animation.svg)\n\n<details>\n\n<summary>SHOW SOURCE</summary>\n\n```go\npackage main\n\nimport (\n\t\"github.com/pterm/pterm\"\n)\n\nfunc main() {\n\t// Create an interactive text input with single line input mode and show it\n\tresult, _ := pterm.DefaultInteractiveTextInput.WithDefaultValue(\"Some default value\").Show()\n\n\t// Print a blank line for better readability\n\tpterm.Println()\n\n\t// Print the user's answer with an info prefix\n\tpterm.Info.Printfln(\"You answered: %s\", result)\n}\n\n```\n\n</details>\n\n### interactive_textinput/multi-line\n\n![Animation](https://raw.githubusercontent.com/pterm/pterm/master/_examples/interactive_textinput/multi-line/animation.svg)\n\n<details>\n\n<summary>SHOW SOURCE</summary>\n\n```go\npackage main\n\nimport (\n\t\"github.com/pterm/pterm\"\n)\n\nfunc main() {\n\t// Create a default interactive text input with multi-line enabled.\n\t// This allows the user to input multiple lines of text.\n\ttextInput := pterm.DefaultInteractiveTextInput.WithMultiLine()\n\n\t// Show the text input to the user and store the result.\n\t// The second return value (an error) is ignored with '_'.\n\tresult, _ := textInput.Show()\n\n\t// Print a blank line for better readability in the output.\n\tpterm.Println()\n\n\t// Print the user's input prefixed with an informational message.\n\t// The '%s' placeholder is replaced with the user's input.\n\tpterm.Info.Printfln(\"You answered: %s\", result)\n}\n\n```\n\n</details>\n\n### interactive_textinput/password\n\n![Animation](https://raw.githubusercontent.com/pterm/pterm/master/_examples/interactive_textinput/password/animation.svg)\n\n<details>\n\n<summary>SHOW SOURCE</summary>\n\n```go\npackage main\n\nimport \"github.com/pterm/pterm\"\n\nfunc main() {\n\t// Create an interactive text input with a mask for password input\n\tpasswordInput := pterm.DefaultInteractiveTextInput.WithMask(\"*\")\n\n\t// Show the password input prompt and store the result\n\tresult, _ := passwordInput.Show(\"Enter your password\")\n\n\t// Get the default logger from PTerm\n\tlogger := pterm.DefaultLogger\n\n\t// Log the received password (masked)\n\t// Note: In a real-world application, you should never log passwords\n\tlogger.Info(\"Password received\", logger.Args(\"password\", result))\n}\n\n```\n\n</details>\n\n### logger/demo\n\n![Animation](https://raw.githubusercontent.com/pterm/pterm/master/_examples/logger/demo/animation.svg)\n\n<details>\n\n<summary>SHOW SOURCE</summary>\n\n```go\npackage main\n\nimport (\n\t\"github.com/pterm/pterm\"\n\t\"time\"\n)\n\nfunc main() {\n\t// Create a logger with trace level\n\tlogger := pterm.DefaultLogger.WithLevel(pterm.LogLevelTrace)\n\n\t// Log a trace level message\n\tlogger.Trace(\"Doing not so important stuff\", logger.Args(\"priority\", \"super low\"))\n\n\t// Pause for 3 seconds\n\tsleep()\n\n\t// Define a map with interesting stuff\n\tinterstingStuff := map[string]any{\n\t\t\"when were crayons invented\":  \"1903\",\n\t\t\"what is the meaning of life\": 42,\n\t\t\"is this interesting\":         true,\n\t}\n\n\t// Log a debug level message with arguments from the map\n\tlogger.Debug(\"This might be interesting\", logger.ArgsFromMap(interstingStuff))\n\n\t// Pause for 3 seconds\n\tsleep()\n\n\t// Log an info level message\n\tlogger.Info(\"That was actually interesting\", logger.Args(\"such\", \"wow\"))\n\n\t// Pause for 3 seconds\n\tsleep()\n\n\t// Log a warning level message\n\tlogger.Warn(\"Oh no, I see an error coming to us!\", logger.Args(\"speed\", 88, \"measures\", \"mph\"))\n\n\t// Pause for 3 seconds\n\tsleep()\n\n\t// Log an error level message\n\tlogger.Error(\"Damn, here it is!\", logger.Args(\"error\", \"something went wrong\"))\n\n\t// Pause for 3 seconds\n\tsleep()\n\n\t// Log an info level message with a long text that will be automatically wrapped\n\tlogger.Info(\"But what's really cool is, that you can print very long logs, and PTerm will automatically wrap them for you! Say goodbye to text, that has weird line breaks!\", logger.Args(\"very\", \"long\"))\n\n\t// Pause for 3 seconds\n\tsleep()\n\n\t// Log a fatal level message\n\tlogger.Fatal(\"Oh no, this process is getting killed!\", logger.Args(\"fatal\", true))\n}\n\n// Function to pause the execution for 3 seconds\nfunc sleep() {\n\ttime.Sleep(time.Second * 3)\n}\n\n```\n\n</details>\n\n### logger/custom-key-styles\n\n![Animation](https://raw.githubusercontent.com/pterm/pterm/master/_examples/logger/custom-key-styles/animation.svg)\n\n<details>\n\n<summary>SHOW SOURCE</summary>\n\n```go\npackage main\n\nimport \"github.com/pterm/pterm\"\n\nfunc main() {\n\t// Create a logger with a level of Trace or higher.\n\tlogger := pterm.DefaultLogger.WithLevel(pterm.LogLevelTrace)\n\n\t// Define a new style for the \"priority\" key.\n\tpriorityStyle := map[string]pterm.Style{\n\t\t\"priority\": *pterm.NewStyle(pterm.FgRed),\n\t}\n\n\t// Overwrite all key styles with the new map.\n\tlogger = logger.WithKeyStyles(priorityStyle)\n\n\t// Log an info message. The \"priority\" key will be displayed in red.\n\tlogger.Info(\"The priority key should now be red\", logger.Args(\"priority\", \"low\", \"foo\", \"bar\"))\n\n\t// Define a new style for the \"foo\" key.\n\tfooStyle := *pterm.NewStyle(pterm.FgBlue)\n\n\t// Append the new style to the existing ones.\n\tlogger.AppendKeyStyle(\"foo\", fooStyle)\n\n\t// Log another info message. The \"foo\" key will be displayed in blue.\n\tlogger.Info(\"The foo key should now be blue\", logger.Args(\"priority\", \"low\", \"foo\", \"bar\"))\n}\n\n```\n\n</details>\n\n### logger/default\n\n![Animation](https://raw.githubusercontent.com/pterm/pterm/master/_examples/logger/default/animation.svg)\n\n<details>\n\n<summary>SHOW SOURCE</summary>\n\n```go\npackage main\n\nimport (\n\t\"github.com/pterm/pterm\"\n\t\"time\"\n)\n\nfunc main() {\n\t// Create a logger with a level of Trace or higher.\n\tlogger := pterm.DefaultLogger.WithLevel(pterm.LogLevelTrace)\n\n\t// Log a trace message with additional arguments.\n\tlogger.Trace(\"Doing not so important stuff\", logger.Args(\"priority\", \"super low\"))\n\n\t// Create a map of interesting stuff.\n\tinterstingStuff := map[string]any{\n\t\t\"when were crayons invented\":  \"1903\",\n\t\t\"what is the meaning of life\": 42,\n\t\t\"is this interesting\":         true,\n\t}\n\n\t// Log a debug message with arguments from a map.\n\tlogger.Debug(\"This might be interesting\", logger.ArgsFromMap(interstingStuff))\n\n\t// Log an info message with additional arguments.\n\tlogger.Info(\"That was actually interesting\", logger.Args(\"such\", \"wow\"))\n\n\t// Log a warning message with additional arguments.\n\tlogger.Warn(\"Oh no, I see an error coming to us!\", logger.Args(\"speed\", 88, \"measures\", \"mph\"))\n\n\t// Log an error message with additional arguments.\n\tlogger.Error(\"Damn, here it is!\", logger.Args(\"error\", \"something went wrong\"))\n\n\t// Log an info message with additional arguments. PTerm will automatically wrap long logs.\n\tlogger.Info(\"But what's really cool is, that you can print very long logs, and PTerm will automatically wrap them for you! Say goodbye to text, that has weird line breaks!\", logger.Args(\"very\", \"long\"))\n\n\t// Pause for 2 seconds.\n\ttime.Sleep(time.Second * 2)\n\n\t// Log a fatal message with additional arguments. This will terminate the process.\n\tlogger.Fatal(\"Oh no, this process is getting killed!\", logger.Args(\"fatal\", true))\n}\n\n```\n\n</details>\n\n### logger/json\n\n![Animation](https://raw.githubusercontent.com/pterm/pterm/master/_examples/logger/json/animation.svg)\n\n<details>\n\n<summary>SHOW SOURCE</summary>\n\n```go\npackage main\n\nimport \"github.com/pterm/pterm\"\n\nfunc main() {\n\t// Create a logger with Trace level and JSON formatter\n\tlogger := pterm.DefaultLogger.WithLevel(pterm.LogLevelTrace).WithFormatter(pterm.LogFormatterJSON)\n\n\t// Log a Trace level message with additional arguments\n\tlogger.Trace(\"Doing not so important stuff\", logger.Args(\"priority\", \"super low\"))\n\n\t// Create a map of interesting stuff\n\tinterestingStuff := map[string]any{\n\t\t\"when were crayons invented\":  \"1903\",\n\t\t\"what is the meaning of life\": 42,\n\t\t\"is this interesting\":         true,\n\t}\n\n\t// Log a Debug level message with arguments from the map\n\tlogger.Debug(\"This might be interesting\", logger.ArgsFromMap(interestingStuff))\n\n\t// Log Info, Warn, Error, and Fatal level messages with additional arguments\n\tlogger.Info(\"That was actually interesting\", logger.Args(\"such\", \"wow\"))\n\tlogger.Warn(\"Oh no, I see an error coming to us!\", logger.Args(\"speed\", 88, \"measures\", \"mph\"))\n\tlogger.Error(\"Damn, here it is!\", logger.Args(\"error\", \"something went wrong\"))\n\tlogger.Info(\"But what's really cool is, that you can print very long logs, and PTerm will automatically wrap them for you! Say goodbye to text, that has weird line breaks!\", logger.Args(\"very\", \"long\"))\n\tlogger.Fatal(\"Oh no, this process is getting killed!\", logger.Args(\"fatal\", true))\n}\n\n```\n\n</details>\n\n### logger/with-caller\n\n![Animation](https://raw.githubusercontent.com/pterm/pterm/master/_examples/logger/with-caller/animation.svg)\n\n<details>\n\n<summary>SHOW SOURCE</summary>\n\n```go\npackage main\n\nimport \"github.com/pterm/pterm\"\n\nfunc main() {\n\t// Create a logger with Trace level and caller information\n\tlogger := pterm.DefaultLogger.WithLevel(pterm.LogLevelTrace).WithCaller()\n\n\t// Log a trace message with additional arguments\n\tlogger.Trace(\"Doing not so important stuff\", logger.Args(\"priority\", \"super low\"))\n\n\t// Create a map of interesting stuff\n\tinterestingStuff := map[string]any{\n\t\t\"when were crayons invented\":  \"1903\",\n\t\t\"what is the meaning of life\": 42,\n\t\t\"is this interesting\":         true,\n\t}\n\n\t// Log a debug message with arguments from a map\n\tlogger.Debug(\"This might be interesting\", logger.ArgsFromMap(interestingStuff))\n\n\t// Log an info message with additional arguments\n\tlogger.Info(\"That was actually interesting\", logger.Args(\"such\", \"wow\"))\n\n\t// Log a warning message with additional arguments\n\tlogger.Warn(\"Oh no, I see an error coming to us!\", logger.Args(\"speed\", 88, \"measures\", \"mph\"))\n\n\t// Log an error message with additional arguments\n\tlogger.Error(\"Damn, here it is!\", logger.Args(\"error\", \"something went wrong\"))\n\n\t// Log an info message with additional arguments. PTerm will automatically wrap long logs.\n\tlogger.Info(\"But what's really cool is, that you can print very long logs, and PTerm will automatically wrap them for you! Say goodbye to text, that has weird line breaks!\", logger.Args(\"very\", \"long\"))\n\n\t// Log a fatal message with additional arguments. This will terminate the process.\n\tlogger.Fatal(\"Oh no, this process is getting killed!\", logger.Args(\"fatal\", true))\n}\n\n```\n\n</details>\n\n### multiple-live-printers/demo\n\n![Animation](https://raw.githubusercontent.com/pterm/pterm/master/_examples/multiple-live-printers/demo/animation.svg)\n\n<details>\n\n<summary>SHOW SOURCE</summary>\n\n```go\npackage main\n\nimport (\n\t\"time\"\n\n\t\"github.com/pterm/pterm\"\n)\n\nfunc main() {\n\t// Create a multi printer for managing multiple printers\n\tmulti := pterm.DefaultMultiPrinter\n\n\t// Create two spinners with their own writers\n\tspinner1, _ := pterm.DefaultSpinner.WithWriter(multi.NewWriter()).Start(\"Spinner 1\")\n\tspinner2, _ := pterm.DefaultSpinner.WithWriter(multi.NewWriter()).Start(\"Spinner 2\")\n\n\t// Create five progress bars with their own writers and a total of 100\n\tpb1, _ := pterm.DefaultProgressbar.WithTotal(100).WithWriter(multi.NewWriter()).Start(\"Progressbar 1\")\n\tpb2, _ := pterm.DefaultProgressbar.WithTotal(100).WithWriter(multi.NewWriter()).Start(\"Progressbar 2\")\n\tpb3, _ := pterm.DefaultProgressbar.WithTotal(100).WithWriter(multi.NewWriter()).Start(\"Progressbar 3\")\n\tpb4, _ := pterm.DefaultProgressbar.WithTotal(100).WithWriter(multi.NewWriter()).Start(\"Progressbar 4\")\n\tpb5, _ := pterm.DefaultProgressbar.WithTotal(100).WithWriter(multi.NewWriter()).Start(\"Progressbar 5\")\n\n\t// Start the multi printer\n\tmulti.Start()\n\n\t// Increment progress bars and spinners based on certain conditions\n\tfor i := 1; i <= 100; i++ {\n\t\tpb1.Increment() // Increment progress bar 1 every iteration\n\n\t\tif i%2 == 0 {\n\t\t\tpb2.Add(3) // Add 3 to progress bar 2 every even iteration\n\t\t}\n\n\t\tif i%5 == 0 {\n\t\t\tpb3.Increment() // Increment progress bar 3 every 5th iteration\n\t\t}\n\n\t\tif i%10 == 0 {\n\t\t\tpb4.Increment() // Increment progress bar 4 every 10th iteration\n\t\t}\n\n\t\tif i%3 == 0 {\n\t\t\tpb5.Increment() // Increment progress bar 5 every 3rd iteration\n\t\t}\n\n\t\tif i%50 == 0 {\n\t\t\tspinner1.Success(\"Spinner 1 is done!\") // Mark spinner 1 as successful every 50th iteration\n\t\t}\n\n\t\tif i%60 == 0 {\n\t\t\tspinner2.Fail(\"Spinner 2 failed!\") // Mark spinner 2 as failed every 60th iteration\n\t\t}\n\n\t\ttime.Sleep(time.Millisecond * 50) // Sleep for 50 milliseconds between each iteration\n\t}\n\n\t// Stop the multi printer\n\tmulti.Stop()\n}\n\n```\n\n</details>\n\n### panel/demo\n\n![Animation](https://raw.githubusercontent.com/pterm/pterm/master/_examples/panel/demo/animation.svg)\n\n<details>\n\n<summary>SHOW SOURCE</summary>\n\n```go\npackage main\n\nimport \"github.com/pterm/pterm\"\n\nfunc main() {\n\t// Define panels in a 2D grid system\n\tpanels := pterm.Panels{\n\t\t{\n\t\t\t{Data: \"This is the first panel\"},\n\t\t\t{Data: pterm.DefaultHeader.Sprint(\"Hello, World!\")},\n\t\t\t{Data: \"This\\npanel\\ncontains\\nmultiple\\nlines\"},\n\t\t},\n\t\t{\n\t\t\t{Data: pterm.Red(\"This is another\\npanel line\")},\n\t\t\t{Data: \"This is the second panel\\nwith a new line\"},\n\t\t},\n\t}\n\n\t// Render the panels with a padding of 5\n\t_ = pterm.DefaultPanel.WithPanels(panels).WithPadding(5).Render()\n}\n\n```\n\n</details>\n\n### paragraph/demo\n\n![Animation](https://raw.githubusercontent.com/pterm/pterm/master/_examples/paragraph/demo/animation.svg)\n\n<details>\n\n<summary>SHOW SOURCE</summary>\n\n```go\npackage main\n\nimport \"github.com/pterm/pterm\"\n\nfunc main() {\n\t// Using the default paragraph printer to print a long text.\n\t// The text is split at the spaces, which is useful for continuous text of all kinds.\n\t// The line width can be manually adjusted if needed.\n\tpterm.DefaultParagraph.Println(\"This is the default paragraph printer. As you can see, no words are separated, \" +\n\t\t\"but the text is split at the spaces. This is useful for continuous text of all kinds. You can manually change the line width if you want to.\" +\n\t\t\"Lorem ipsum dolor sit amet, consetetur sadipscing elitr, sed diam nonumy eirmod tempor invidunt ut labore et dolore magna aliquyam\")\n\n\t// Printing a line space for separation.\n\tpterm.Println()\n\n\t// Printing a long text without using the paragraph printer.\n\t// The default Println() function is used here, which does not provide intelligent splitting.\n\tpterm.Println(\"This text is written with the default Println() function. No intelligent splitting here.\" +\n\t\t\"Lorem ipsum dolor sit amet, consetetur sadipscing elitr, sed diam nonumy eirmod tempor invidunt ut labore et dolore magna aliquyam\")\n}\n\n```\n\n</details>\n\n### paragraph/customized\n\n![Animation](https://raw.githubusercontent.com/pterm/pterm/master/_examples/paragraph/customized/animation.svg)\n\n<details>\n\n<summary>SHOW SOURCE</summary>\n\n```go\npackage main\n\nimport \"github.com/pterm/pterm\"\n\nfunc main() {\n\t// Define a long text to be printed as a paragraph.\n\tlongText := \"This is a custom paragraph printer. As you can see, no words are separated, \" +\n\t\t\"but the text is split at the spaces. This is useful for continuous text of all kinds. You can manually change the line width if you want to.\" +\n\t\t\"Lorem ipsum dolor sit amet, consetetur sadipscing elitr, sed diam nonumy eirmod tempor invidunt ut labore et dolore magna aliquyam\"\n\n\t// Print the long text as a paragraph with a custom maximal width of 60 characters.\n\tpterm.DefaultParagraph.WithMaxWidth(60).Println(longText)\n\n\t// Print a line space to separate the paragraph from the following text.\n\tpterm.Println()\n\n\t// Define another long text to be printed without a paragraph printer.\n\tlongTextWithoutParagraph := \"This text is written with the default Println() function. No intelligent splitting here.\" +\n\t\t\"Lorem ipsum dolor sit amet, consetetur sadipscing elitr, sed diam nonumy eirmod tempor invidunt ut labore et dolore magna aliquyam\"\n\n\t// Print the long text without using a paragraph printer.\n\tpterm.Println(longTextWithoutParagraph)\n}\n\n```\n\n</details>\n\n### prefix/demo\n\n![Animation](https://raw.githubusercontent.com/pterm/pterm/master/_examples/prefix/demo/animation.svg)\n\n<details>\n\n<summary>SHOW SOURCE</summary>\n\n```go\npackage main\n\nimport \"github.com/pterm/pterm\"\n\nfunc main() {\n\t// Enable debug messages in PTerm.\n\tpterm.EnableDebugMessages()\n\n\t// Print a debug message with PTerm.\n\tpterm.Debug.Println(\"Hello, World!\")\n\n\t// Print an informational message with PTerm.\n\tpterm.Info.Println(\"Hello, World!\")\n\n\t// Print a success message with PTerm.\n\tpterm.Success.Println(\"Hello, World!\")\n\n\t// Print a warning message with PTerm.\n\tpterm.Warning.Println(\"Hello, World!\")\n\n\t// Print an error message with PTerm. This will also display the filename and line number in the terminal.\n\tpterm.Error.Println(\"Errors show the filename and linenumber inside the terminal!\")\n\n\t// Print an informational message with PTerm, with line number.\n\t// This demonstrates that other PrefixPrinters can also display line numbers.\n\tpterm.Info.WithShowLineNumber().Println(\"Other PrefixPrinters can do that too!\")\n\n\t// Temporarily set Fatal to false, so that the CI won't crash.\n\t// This will print a fatal message with PTerm, but won't terminate the program.\n\tpterm.Fatal.WithFatal(false).Println(\"Hello, World!\")\n}\n\n```\n\n</details>\n\n### progressbar/demo\n\n![Animation](https://raw.githubusercontent.com/pterm/pterm/master/_examples/progressbar/demo/animation.svg)\n\n<details>\n\n<summary>SHOW SOURCE</summary>\n\n```go\npackage main\n\nimport (\n\t\"strings\"\n\t\"time\"\n\n\t\"github.com/pterm/pterm\"\n)\n\n// Slice of strings representing names of pseudo applications to be downloaded.\nvar fakeInstallList = strings.Split(\"pseudo-excel pseudo-photoshop pseudo-chrome pseudo-outlook pseudo-explorer \"+\n\t\"pseudo-dops pseudo-git pseudo-vsc pseudo-intellij pseudo-minecraft pseudo-scoop pseudo-chocolatey\", \" \")\n\nfunc main() {\n\t// Create a progressbar with the total steps equal to the number of items in fakeInstallList.\n\t// Set the initial title of the progressbar to \"Downloading stuff\".\n\tp, _ := pterm.DefaultProgressbar.WithTotal(len(fakeInstallList)).WithTitle(\"Downloading stuff\").Start()\n\n\t// Loop over each item in the fakeInstallList.\n\tfor i := 0; i < p.Total; i++ {\n\t\t// Simulate a slow download for the 7th item.\n\t\tif i == 6 {\n\t\t\ttime.Sleep(time.Second * 3)\n\t\t}\n\n\t\t// Update the title of the progressbar with the current item being downloaded.\n\t\tp.UpdateTitle(\"Downloading \" + fakeInstallList[i])\n\n\t\t// Print a success message for the current download. This will be printed above the progressbar.\n\t\tpterm.Success.Println(\"Downloading \" + fakeInstallList[i])\n\n\t\t// Increment the progressbar by one to indicate progress.\n\t\tp.Increment()\n\n\t\t// Pause for 350 milliseconds to simulate the time taken for each download.\n\t\ttime.Sleep(time.Millisecond * 350)\n\t}\n}\n\n```\n\n</details>\n\n### progressbar/multiple\n\n![Animation](https://raw.githubusercontent.com/pterm/pterm/master/_examples/progressbar/multiple/animation.svg)\n\n<details>\n\n<summary>SHOW SOURCE</summary>\n\n```go\npackage main\n\nimport (\n\t\"time\"\n\n\t\"github.com/pterm/pterm\"\n)\n\nfunc main() {\n\t// Create a multi printer instance from the default one\n\tmulti := pterm.DefaultMultiPrinter\n\n\t// Create five progress bars with a total of 100 units each, and assign each a new writer from the multi printer\n\tpb1, _ := pterm.DefaultProgressbar.WithTotal(100).WithWriter(multi.NewWriter()).Start(\"Progressbar 1\")\n\tpb2, _ := pterm.DefaultProgressbar.WithTotal(100).WithWriter(multi.NewWriter()).Start(\"Progressbar 2\")\n\tpb3, _ := pterm.DefaultProgressbar.WithTotal(100).WithWriter(multi.NewWriter()).Start(\"Progressbar 3\")\n\tpb4, _ := pterm.DefaultProgressbar.WithTotal(100).WithWriter(multi.NewWriter()).Start(\"Progressbar 4\")\n\tpb5, _ := pterm.DefaultProgressbar.WithTotal(100).WithWriter(multi.NewWriter()).Start(\"Progressbar 5\")\n\n\t// Start the multi printer\n\tmulti.Start()\n\n\t// Loop to increment progress bars based on certain conditions\n\tfor i := 1; i <= 100; i++ {\n\t\tpb1.Increment() // Increment the first progress bar at each iteration\n\n\t\tif i%2 == 0 {\n\t\t\tpb2.Add(3) // Add 3 units to the second progress bar at every even iteration\n\t\t}\n\n\t\tif i%5 == 0 {\n\t\t\tpb3.Increment() // Increment the third progress bar at every fifth iteration\n\t\t}\n\n\t\tif i%10 == 0 {\n\t\t\tpb4.Increment() // Increment the fourth progress bar at every tenth iteration\n\t\t}\n\n\t\tif i%3 == 0 {\n\t\t\tpb5.Increment() // Increment the fifth progress bar at every third iteration\n\t\t}\n\n\t\ttime.Sleep(time.Millisecond * 50) // Pause for 50 milliseconds at each iteration\n\t}\n\n\t// Stop the multi printer\n\tmulti.Stop()\n}\n\n```\n\n</details>\n\n### section/demo\n\n![Animation](https://raw.githubusercontent.com/pterm/pterm/master/_examples/section/demo/animation.svg)\n\n<details>\n\n<summary>SHOW SOURCE</summary>\n\n```go\npackage main\n\nimport \"github.com/pterm/pterm\"\n\nfunc main() {\n\t// Create a section with level one and print it.\n\tpterm.DefaultSection.Println(\"This is a section!\")\n\n\t// Print an informational message.\n\tpterm.Info.Println(\"And here is some text.\\nThis text could be anything.\\nBasically it's just a placeholder\")\n\n\t// Create a section with level two and print it.\n\tpterm.DefaultSection.WithLevel(2).Println(\"This is another section!\")\n\n\t// Print another informational message.\n\tpterm.Info.Println(\"And this is\\nmore placeholder text\")\n}\n\n```\n\n</details>\n\n### slog/demo\n\n![Animation](https://raw.githubusercontent.com/pterm/pterm/master/_examples/slog/demo/animation.svg)\n\n<details>\n\n<summary>SHOW SOURCE</summary>\n\n```go\npackage main\n\nimport (\n\t\"log/slog\"\n\n\t\"github.com/pterm/pterm\"\n)\n\nfunc main() {\n\t// Create a new slog handler with the default PTerm logger\n\thandler := pterm.NewSlogHandler(&pterm.DefaultLogger)\n\n\t// Create a new slog logger with the handler\n\tlogger := slog.New(handler)\n\n\t// Log a debug message (won't show by default)\n\tlogger.Debug(\"This is a debug message that won't show\")\n\n\t// Change the log level to debug to enable debug messages\n\tpterm.DefaultLogger.Level = pterm.LogLevelDebug\n\n\t// Log a debug message (will show because debug level is enabled)\n\tlogger.Debug(\"This is a debug message\", \"changedLevel\", true)\n\n\t// Log an info message\n\tlogger.Info(\"This is an info message\")\n\n\t// Log a warning message\n\tlogger.Warn(\"This is a warning message\")\n\n\t// Log an error message\n\tlogger.Error(\"This is an error message\")\n}\n\n```\n\n</details>\n\n### spinner/demo\n\n![Animation](https://raw.githubusercontent.com/pterm/pterm/master/_examples/spinner/demo/animation.svg)\n\n<details>\n\n<summary>SHOW SOURCE</summary>\n\n```go\npackage main\n\nimport (\n\t\"time\"\n\n\t\"github.com/pterm/pterm\"\n)\n\nfunc main() {\n\t// Create and start a fork of the default spinner.\n\tspinnerInfo, _ := pterm.DefaultSpinner.Start(\"Some informational action...\")\n\ttime.Sleep(time.Second * 2) // Simulate 3 seconds of processing something.\n\tspinnerInfo.Info()          // Resolve spinner with information message.\n\n\t// Create and start a fork of the default spinner.\n\tspinnerSuccess, _ := pterm.DefaultSpinner.Start(\"Doing something important... (will succeed)\")\n\ttime.Sleep(time.Second * 2) // Simulate 3 seconds of processing something.\n\tspinnerSuccess.Success()    // Resolve spinner with success message.\n\n\t// Create and start a fork of the default spinner.\n\tspinnerWarning, _ := pterm.DefaultSpinner.Start(\"Doing something important... (will warn)\")\n\ttime.Sleep(time.Second * 2) // Simulate 3 seconds of processing something.\n\tspinnerWarning.Warning()    // Resolve spinner with warning message.\n\n\t// Create and start a fork of the default spinner.\n\tspinnerFail, _ := pterm.DefaultSpinner.Start(\"Doing something important... (will fail)\")\n\ttime.Sleep(time.Second * 2) // Simulate 3 seconds of processing something.\n\tspinnerFail.Fail()          // Resolve spinner with error message.\n\n\t// Create and start a fork of the default spinner.\n\tspinnerNochange, _ := pterm.DefaultSpinner.Start(\"Checking something important... (will result in no change)\")\n\t// Replace the InfoPrinter with a custom \"NOCHG\" one\n\tspinnerNochange.InfoPrinter = &pterm.PrefixPrinter{\n\t\tMessageStyle: &pterm.Style{pterm.FgLightBlue},\n\t\tPrefix: pterm.Prefix{\n\t\t\tStyle: &pterm.Style{pterm.FgBlack, pterm.BgLightBlue},\n\t\t\tText:  \" NOCHG \",\n\t\t},\n\t}\n\ttime.Sleep(time.Second * 2)                     // Simulate 3 seconds of processing something.\n\tspinnerNochange.Info(\"No change were required\") // Resolve spinner with error message.\n\n\t// Create and start a fork of the default spinner.\n\tspinnerLiveText, _ := pterm.DefaultSpinner.Start(\"Doing a lot of stuff...\")\n\ttime.Sleep(time.Second)                          // Simulate 2 seconds of processing something.\n\tspinnerLiveText.UpdateText(\"It's really much\")   // Update spinner text.\n\ttime.Sleep(time.Second)                          // Simulate 2 seconds of processing something.\n\tspinnerLiveText.UpdateText(\"We're nearly done!\") // Update spinner text.\n\ttime.Sleep(time.Second)                          // Simulate 2 seconds of processing something.\n\tspinnerLiveText.Success(\"Finally!\")              // Resolve spinner with success message.\n}\n\n```\n\n</details>\n\n### spinner/multiple\n\n![Animation](https://raw.githubusercontent.com/pterm/pterm/master/_examples/spinner/multiple/animation.svg)\n\n<details>\n\n<summary>SHOW SOURCE</summary>\n\n```go\npackage main\n\nimport (\n\t\"time\"\n\n\t\"github.com/pterm/pterm\"\n)\n\nfunc main() {\n\t// Create a multi printer. This allows multiple spinners to print simultaneously.\n\tmulti := pterm.DefaultMultiPrinter\n\n\t// Create and start spinner 1 with a new writer from the multi printer.\n\t// The spinner will display the message \"Spinner 1\".\n\tspinner1, _ := pterm.DefaultSpinner.WithWriter(multi.NewWriter()).Start(\"Spinner 1\")\n\n\t// Create and start spinner 2 with a new writer from the multi printer.\n\t// The spinner will display the message \"Spinner 2\".\n\tspinner2, _ := pterm.DefaultSpinner.WithWriter(multi.NewWriter()).Start(\"Spinner 2\")\n\n\t// Create and start spinner 3 with a new writer from the multi printer.\n\t// The spinner will display the message \"Spinner 3\".\n\tspinner3, _ := pterm.DefaultSpinner.WithWriter(multi.NewWriter()).Start(\"Spinner 3\")\n\n\t// Start the multi printer. This will start printing all the spinners.\n\tmulti.Start()\n\n\t// Wait for 1 second.\n\ttime.Sleep(time.Millisecond * 1000)\n\n\t// Stop spinner 1 with a success message.\n\tspinner1.Success(\"Spinner 1 is done!\")\n\n\t// Wait for 750 milliseconds.\n\ttime.Sleep(time.Millisecond * 750)\n\n\t// Stop spinner 2 with a failure message.\n\tspinner2.Fail(\"Spinner 2 failed!\")\n\n\t// Wait for 500 milliseconds.\n\ttime.Sleep(time.Millisecond * 500)\n\n\t// Stop spinner 3 with a warning message.\n\tspinner3.Warning(\"Spinner 3 has a warning!\")\n\n\t// Stop the multi printer. This will stop printing all the spinners.\n\tmulti.Stop()\n}\n\n```\n\n</details>\n\n### style/demo\n\n![Animation](https://raw.githubusercontent.com/pterm/pterm/master/_examples/style/demo/animation.svg)\n\n<details>\n\n<summary>SHOW SOURCE</summary>\n\n```go\npackage main\n\nimport \"github.com/pterm/pterm\"\n\nfunc main() {\n\t// Define a primary style with light cyan foreground, gray background, and bold text\n\tprimary := pterm.NewStyle(pterm.FgLightCyan, pterm.BgGray, pterm.Bold)\n\n\t// Define a secondary style with light green foreground, white background, and italic text\n\tsecondary := pterm.NewStyle(pterm.FgLightGreen, pterm.BgWhite, pterm.Italic)\n\n\t// Print \"Hello, World!\" with the primary style\n\tprimary.Println(\"Hello, World!\")\n\n\t// Print \"Hello, World!\" with the secondary style\n\tsecondary.Println(\"Hello, World!\")\n}\n\n```\n\n</details>\n\n### table/demo\n\n![Animation](https://raw.githubusercontent.com/pterm/pterm/master/_examples/table/demo/animation.svg)\n\n<details>\n\n<summary>SHOW SOURCE</summary>\n\n```go\npackage main\n\nimport \"github.com/pterm/pterm\"\n\nfunc main() {\n\t// Define the data for the first table\n\ttableData1 := pterm.TableData{\n\t\t{\"Firstname\", \"Lastname\", \"Email\", \"Note\"},\n\t\t{\"Paul\", \"Dean\", \"augue@velitAliquam.co.uk\", \"\"},\n\t\t{\"Callie\", \"Mckay\", \"nunc.sed@est.com\", \"这是一个测试, haha!\"},\n\t\t{\"Libby\", \"Camacho\", \"lobortis@semper.com\", \"just a test, hey!\"},\n\t\t{\"张\", \"小宝\", \"zhang@example.com\", \"\"},\n\t}\n\n\t// Create a table with a header and the defined data, then render it\n\tpterm.DefaultTable.WithHasHeader().WithData(tableData1).Render()\n\n\tpterm.Println() // Blank line\n\n\t// Define the data for the second table\n\ttableData2 := pterm.TableData{\n\t\t{\"Firstname\", \"Lastname\", \"Email\"},\n\t\t{\"Paul\\n\\nNewline\", \"Dean\", \"augue@velitAliquam.co.uk\"},\n\t\t{\"Callie\", \"Mckay\", \"nunc.sed@est.com\\nNewline\"},\n\t\t{\"Libby\", \"Camacho\", \"lobortis@semper.com\"},\n\t\t{\"张\", \"小宝\", \"zhang@example.com\"},\n\t}\n\n\t// Create another table with a header and the defined data, then render it\n\tpterm.DefaultTable.WithHasHeader().WithData(tableData2).Render()\n}\n\n```\n\n</details>\n\n### table/alternate-row-style\n\n![Animation](https://raw.githubusercontent.com/pterm/pterm/master/_examples/table/alternate-row-style/animation.svg)\n\n<details>\n\n<summary>SHOW SOURCE</summary>\n\n```go\npackage main\n\nimport \"github.com/pterm/pterm\"\n\nfunc main() {\n\t// Define the data for the table.\n\t// Each inner slice represents a row in the table.\n\t// The first row is considered as the header of the table.\n\talternateStyle := pterm.NewStyle(pterm.BgDarkGray)\n\n\ttableData := pterm.TableData{\n\t\t{\"Firstname\", \"Lastname\", \"Email\", \"Note\"},\n\t\t{\"Paul\", \"Dean\", \"augue@velitAliquam.co.uk\", \"\"},\n\t\t{\"Callie\", \"Mckay\", \"nunc.sed@est.com\", \"这是一个测试, haha!\"},\n\t\t{\"Libby\", \"Camacho\", \"lobortis@semper.com\", \"just a test, hey!\"},\n\t\t{\"张\", \"小宝\", \"zhang@example.com\", \"\"},\n\t}\n\n\t// Create a table with the defined data.\n\t// The table has a header and is boxed.\n\t// Finally, render the table to print it.\n\tpterm.DefaultTable.WithHasHeader().WithBoxed().WithData(tableData).WithAlternateRowStyle(alternateStyle).Render()\n}\n\n```\n\n</details>\n\n### table/boxed\n\n![Animation](https://raw.githubusercontent.com/pterm/pterm/master/_examples/table/boxed/animation.svg)\n\n<details>\n\n<summary>SHOW SOURCE</summary>\n\n```go\npackage main\n\nimport \"github.com/pterm/pterm\"\n\nfunc main() {\n\t// Define the data for the table.\n\t// Each inner slice represents a row in the table.\n\t// The first row is considered as the header of the table.\n\ttableData := pterm.TableData{\n\t\t{\"Firstname\", \"Lastname\", \"Email\", \"Note\"},\n\t\t{\"Paul\", \"Dean\", \"augue@velitAliquam.co.uk\", \"\"},\n\t\t{\"Callie\", \"Mckay\", \"nunc.sed@est.com\", \"这是一个测试, haha!\"},\n\t\t{\"Libby\", \"Camacho\", \"lobortis@semper.com\", \"just a test, hey!\"},\n\t\t{\"张\", \"小宝\", \"zhang@example.com\", \"\"},\n\t}\n\n\t// Create a table with the defined data.\n\t// The table has a header and is boxed.\n\t// Finally, render the table to print it.\n\tpterm.DefaultTable.WithHasHeader().WithBoxed().WithData(tableData).Render()\n}\n\n```\n\n</details>\n\n### table/multiple-lines\n\n![Animation](https://raw.githubusercontent.com/pterm/pterm/master/_examples/table/multiple-lines/animation.svg)\n\n<details>\n\n<summary>SHOW SOURCE</summary>\n\n```go\npackage main\n\nimport \"github.com/pterm/pterm\"\n\nfunc main() {\n\t// Define the data for the table.\n\tdata := pterm.TableData{\n\t\t{\"Firstname\", \"Lastname\", \"Email\"},\n\t\t{\"Paul\\n\\nNewline\", \"Dean\", \"augue@velitAliquam.co.uk\"},\n\t\t{\"Callie\", \"Mckay\", \"nunc.sed@est.com\\nNewline\"},\n\t\t{\"Libby\", \"Camacho\", \"lobortis@semper.com\"},\n\t\t{\"张\", \"小宝\", \"zhang@example.com\"},\n\t}\n\n\t// Create and render the table.\n\t// The options are chained in a single line for simplicity.\n\t// The table has a header, a row separator, and a header row separator.\n\tpterm.DefaultTable.WithHasHeader().WithRowSeparator(\"-\").WithHeaderRowSeparator(\"-\").WithData(data).Render()\n}\n\n```\n\n</details>\n\n### table/right-alignment\n\n![Animation](https://raw.githubusercontent.com/pterm/pterm/master/_examples/table/right-alignment/animation.svg)\n\n<details>\n\n<summary>SHOW SOURCE</summary>\n\n```go\npackage main\n\nimport \"github.com/pterm/pterm\"\n\nfunc main() {\n\t// Define the data for the table.\n\t// Each inner slice represents a row in the table.\n\t// The first row is considered as the header.\n\ttableData := pterm.TableData{\n\t\t{\"Firstname\", \"Lastname\", \"Email\", \"Note\"},\n\t\t{\"Paul\", \"Dean\", \"augue@velitAliquam.co.uk\", \"\"},\n\t\t{\"Callie\", \"Mckay\", \"nunc.sed@est.com\", \"这是一个测试, haha!\"},\n\t\t{\"Libby\", \"Camacho\", \"lobortis@semper.com\", \"just a test, hey!\"},\n\t\t{\"张\", \"小宝\", \"zhang@example.com\", \"\"},\n\t}\n\n\t// Create a table with the defined data.\n\t// The table has a header and the text in the cells is right-aligned.\n\t// The Render() method is used to print the table to the console.\n\tpterm.DefaultTable.WithHasHeader().WithRightAlignment().WithData(tableData).Render()\n}\n\n```\n\n</details>\n\n### theme/demo\n\n![Animation](https://raw.githubusercontent.com/pterm/pterm/master/_examples/theme/demo/animation.svg)\n\n<details>\n\n<summary>SHOW SOURCE</summary>\n\n```go\npackage main\n\nimport (\n\t\"github.com/pterm/pterm\"\n\t\"reflect\"\n\t\"time\"\n)\n\nfunc main() {\n\t// Print an informational message about the default theme styles.\n\tpterm.Info.Println(\"These are the default theme styles.\\nYou can modify them easily to your personal preference,\\nor create new themes from scratch :)\")\n\n\t// Print a blank line for better readability.\n\tpterm.Println()\n\n\t// Get the value and type of the default theme.\n\tv := reflect.ValueOf(pterm.ThemeDefault)\n\ttypeOfS := v.Type()\n\n\t// Check if the type of the default theme is 'pterm.Theme'.\n\tif typeOfS == reflect.TypeOf(pterm.Theme{}) {\n\t\t// Iterate over each field in the default theme.\n\t\tfor i := 0; i < v.NumField(); i++ {\n\t\t\t// Try to convert the field to 'pterm.Style'.\n\t\t\tfield, ok := v.Field(i).Interface().(pterm.Style)\n\t\t\tif ok {\n\t\t\t\t// Print the field name using its own style.\n\t\t\t\tfield.Println(typeOfS.Field(i).Name)\n\t\t\t}\n\t\t\t// Pause for a quarter of a second to make the output easier to read.\n\t\t\ttime.Sleep(time.Millisecond * 250)\n\t\t}\n\t}\n}\n\n```\n\n</details>\n\n### tree/demo\n\n![Animation](https://raw.githubusercontent.com/pterm/pterm/master/_examples/tree/demo/animation.svg)\n\n<details>\n\n<summary>SHOW SOURCE</summary>\n\n```go\npackage main\n\nimport (\n\t\"github.com/pterm/pterm\"\n)\n\nfunc main() {\n\t// Define a tree structure using pterm.TreeNode\n\ttree := pterm.TreeNode{\n\t\t// The top node of the tree\n\t\tText: \"Top node\",\n\t\t// The children of the top node\n\t\tChildren: []pterm.TreeNode{{\n\t\t\t// A child node\n\t\t\tText: \"Child node\",\n\t\t\t// The children of the child node\n\t\t\tChildren: []pterm.TreeNode{\n\t\t\t\t// Grandchildren nodes\n\t\t\t\t{Text: \"Grandchild node\"},\n\t\t\t\t{Text: \"Grandchild node\"},\n\t\t\t\t{Text: \"Grandchild node\"},\n\t\t\t},\n\t\t}},\n\t}\n\n\t// Render the tree with the defined structure as the root\n\tpterm.DefaultTree.WithRoot(tree).Render()\n}\n\n```\n\n</details>\n\n### tree/from-leveled-list\n\n![Animation](https://raw.githubusercontent.com/pterm/pterm/master/_examples/tree/from-leveled-list/animation.svg)\n\n<details>\n\n<summary>SHOW SOURCE</summary>\n\n```go\npackage main\n\nimport (\n\t\"github.com/pterm/pterm\"\n\t\"github.com/pterm/pterm/putils\"\n)\n\nfunc main() {\n\t// Define a leveled list to represent the structure of the directories.\n\tleveledList := pterm.LeveledList{\n\t\t{Level: 0, Text: \"C:\"},\n\t\t{Level: 1, Text: \"Users\"},\n\t\t{Level: 1, Text: \"Windows\"},\n\t\t{Level: 1, Text: \"Programs\"},\n\t\t{Level: 1, Text: \"Programs(x86)\"},\n\t\t{Level: 1, Text: \"dev\"},\n\t\t{Level: 0, Text: \"D:\"},\n\t\t{Level: 0, Text: \"E:\"},\n\t\t{Level: 1, Text: \"Movies\"},\n\t\t{Level: 1, Text: \"Music\"},\n\t\t{Level: 2, Text: \"LinkinPark\"},\n\t\t{Level: 1, Text: \"Games\"},\n\t\t{Level: 2, Text: \"Shooter\"},\n\t\t{Level: 3, Text: \"CallOfDuty\"},\n\t\t{Level: 3, Text: \"CS:GO\"},\n\t\t{Level: 3, Text: \"Battlefield\"},\n\t\t{Level: 4, Text: \"Battlefield 1\"},\n\t\t{Level: 4, Text: \"Battlefield 2\"},\n\t\t{Level: 0, Text: \"F:\"},\n\t\t{Level: 1, Text: \"dev\"},\n\t\t{Level: 2, Text: \"dops\"},\n\t\t{Level: 2, Text: \"PTerm\"},\n\t}\n\n\t// Convert the leveled list into a tree structure.\n\troot := putils.TreeFromLeveledList(leveledList)\n\troot.Text = \"Computer\" // Set the root node text.\n\n\t// Render the tree structure using the default tree printer.\n\tpterm.DefaultTree.WithRoot(root).Render()\n}\n\n```\n\n</details>\n\n\n<!-- examples:end -->\n\n\n---\n\n> GitHub [@pterm](https://github.com/pterm) &nbsp;&middot;&nbsp;\n> Author [@MarvinJWendt](https://github.com/MarvinJWendt)\n> | [PTerm.sh](https://pterm.sh)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
        },
        {
          "name": "SECURITY.md",
          "type": "blob",
          "size": 1.453125,
          "content": "# PTerm Security Policy\nThis security policy applies to the PTerm GitHub repository and outlines the process for reporting security issues and handling security incidents. The primary goal of this policy is to ensure the safety and integrity of the PTerm codebase and to minimize the impact of security incidents on our users.\n\n## 1. Overview\nPTerm is a command-line interface (CLI) tool library, and we believe the security risks associated with it are minimal. However, we recognize that vulnerabilities can still arise, and we are committed to addressing them promptly and transparently.\n\n## 2. Reporting Security Issues\nIf you discover a security issue in PTerm, please follow these steps:\n\nOpen a new issue in the PTerm GitHub repository, describing the security problem in detail.\n\n## 3. Vulnerable Dependencies\nIf a dependency of PTerm is found to be vulnerable or infected and requires immediate updates, please follow these steps:\n\n1. Open a new issue in the PTerm GitHub repository, describing the vulnerable dependency and the need for an update.\n2. *Optional: Contact @MarvinJWendt directly via Twitter or Discord to alert them to the issue.*\n\n## 4. Incident Response\nUpon receiving a security report, the PTerm team will:\n\n1. Acknowledge receipt of the report and review the issue.\n2. Investigate the issue and determine the severity and impact.\n3. Develop and implement a fix or mitigation plan, as necessary.\n4. Update the PTerm repository and notify users, if applicable.\n"
        },
        {
          "name": "_examples",
          "type": "tree",
          "content": null
        },
        {
          "name": "area_printer.go",
          "type": "blob",
          "size": 3.2236328125,
          "content": "package pterm\n\nimport (\n\t\"io\"\n\t\"strings\"\n\n\t\"atomicgo.dev/cursor\"\n\n\t\"github.com/pterm/pterm/internal\"\n)\n\n// DefaultArea is the default area printer.\nvar DefaultArea = AreaPrinter{}\n\n// AreaPrinter prints an area which can be updated easily.\n// use this printer for live output like charts, algorithm visualizations, simulations and even games.\ntype AreaPrinter struct {\n\tRemoveWhenDone bool\n\tFullscreen     bool\n\tCenter         bool\n\n\tcontent  string\n\tisActive bool\n\n\tarea *cursor.Area\n}\n\n// GetContent returns the current area content.\nfunc (p *AreaPrinter) GetContent() string {\n\treturn p.content\n}\n\n// WithRemoveWhenDone removes the AreaPrinter content after it is stopped.\nfunc (p AreaPrinter) WithRemoveWhenDone(b ...bool) *AreaPrinter {\n\tp.RemoveWhenDone = internal.WithBoolean(b)\n\treturn &p\n}\n\n// WithFullscreen sets the AreaPrinter height the same height as the terminal, making it fullscreen.\nfunc (p AreaPrinter) WithFullscreen(b ...bool) *AreaPrinter {\n\tp.Fullscreen = internal.WithBoolean(b)\n\treturn &p\n}\n\n// WithCenter centers the AreaPrinter content to the terminal.\nfunc (p AreaPrinter) WithCenter(b ...bool) *AreaPrinter {\n\tp.Center = internal.WithBoolean(b)\n\treturn &p\n}\n\n// SetWriter sets the writer for the AreaPrinter.\nfunc (p *AreaPrinter) SetWriter(writer io.Writer) {\n\n}\n\n// Update overwrites the content of the AreaPrinter.\n// Can be used live.\nfunc (p *AreaPrinter) Update(text ...any) {\n\tif p.area == nil {\n\t\tnewArea := cursor.NewArea()\n\t\tp.area = &newArea\n\t}\n\tstr := Sprint(text...)\n\tp.content = str\n\n\tif p.Center {\n\t\tstr = DefaultCenter.Sprint(str)\n\t}\n\n\tif p.Fullscreen {\n\t\tstr = strings.TrimRight(str, \"\\n\")\n\t\theight := GetTerminalHeight()\n\t\tcontentHeight := strings.Count(str, \"\\n\")\n\n\t\ttopPadding := 0\n\t\tbottomPadding := height - contentHeight - 2\n\n\t\tif p.Center {\n\t\t\ttopPadding = (bottomPadding / 2) + 1\n\t\t\tbottomPadding /= 2\n\t\t}\n\n\t\tif height > contentHeight {\n\t\t\tstr = strings.Repeat(\"\\n\", topPadding) + str\n\t\t\tstr += strings.Repeat(\"\\n\", bottomPadding)\n\t\t}\n\t}\n\tp.area.Update(str)\n}\n\n// Start the AreaPrinter.\nfunc (p *AreaPrinter) Start(text ...any) (*AreaPrinter, error) {\n\tp.isActive = true\n\tstr := Sprint(text...)\n\tnewArea := cursor.NewArea()\n\tp.area = &newArea\n\n\tp.Update(str)\n\n\treturn p, nil\n}\n\n// Stop terminates the AreaPrinter immediately.\n// The AreaPrinter will not resolve into anything.\nfunc (p *AreaPrinter) Stop() error {\n\tif !p.isActive {\n\t\treturn nil\n\t}\n\tp.isActive = false\n\tif p.RemoveWhenDone {\n\t\tp.Clear()\n\t}\n\treturn nil\n}\n\n// GenericStart runs Start, but returns a LivePrinter.\n// This is used for the interface LivePrinter.\n// You most likely want to use Start instead of this in your program.\nfunc (p *AreaPrinter) GenericStart() (*LivePrinter, error) {\n\t_, _ = p.Start()\n\tlp := LivePrinter(p)\n\treturn &lp, nil\n}\n\n// GenericStop runs Stop, but returns a LivePrinter.\n// This is used for the interface LivePrinter.\n// You most likely want to use Stop instead of this in your program.\nfunc (p *AreaPrinter) GenericStop() (*LivePrinter, error) {\n\t_ = p.Stop()\n\tlp := LivePrinter(p)\n\treturn &lp, nil\n}\n\n// Clear is a Wrapper function that clears the content of the Area\n// moves the cursor to the bottom of the terminal, clears n lines upwards from\n// the current position and moves the cursor again.\nfunc (p *AreaPrinter) Clear() {\n\tp.area.Clear()\n}\n"
        },
        {
          "name": "area_printer_test.go",
          "type": "blob",
          "size": 3.2822265625,
          "content": "package pterm_test\n\nimport (\n\t\"os\"\n\t\"testing\"\n\n\t\"github.com/MarvinJWendt/testza\"\n\t\"github.com/pterm/pterm\"\n)\n\nfunc TestAreaPrinter_NilPrint(t *testing.T) {\n\toriginalStdout := os.Stdout\n\tos.Stdout = os.NewFile(0, os.DevNull) // Set os.Stdout to DevNull to hide output from cursor.Area\n\n\tp := pterm.AreaPrinter{}\n\tp.Update(\"asd\")\n\n\tos.Stdout = originalStdout // Restore original os.Stdout\n}\n\nfunc TestAreaPrinter_GenericStart(t *testing.T) {\n\toriginalStdout := os.Stdout\n\tos.Stdout = os.NewFile(0, os.DevNull) // Set os.Stdout to DevNull to hide output from cursor.Area\n\n\tp := pterm.DefaultArea\n\tp.GenericStart()\n\n\tos.Stdout = originalStdout // Restore original os.Stdout\n}\n\nfunc TestAreaPrinter_GenericStartRawOutput(t *testing.T) {\n\toriginalStdout := os.Stdout\n\tos.Stdout = os.NewFile(0, os.DevNull) // Set os.Stdout to DevNull to hide output from cursor.Area\n\n\tpterm.DisableStyling()\n\tp := pterm.DefaultArea\n\tp.GenericStart()\n\tpterm.EnableStyling()\n\n\tos.Stdout = originalStdout // Restore original os.Stdout\n}\n\nfunc TestAreaPrinter_GenericStop(t *testing.T) {\n\toriginalStdout := os.Stdout\n\tos.Stdout = os.NewFile(0, os.DevNull) // Set os.Stdout to DevNull to hide output from cursor.Area\n\n\tp := pterm.DefaultArea\n\tp.GenericStop()\n\n\tos.Stdout = originalStdout // Restore original os.Stdout\n}\n\nfunc TestAreaPrinter_RemoveWhenDone(t *testing.T) {\n\toriginalStdout := os.Stdout\n\tos.Stdout = os.NewFile(0, os.DevNull) // Set os.Stdout to DevNull to hide output from cursor.Area\n\n\ta, _ := pterm.DefaultArea.WithRemoveWhenDone().Start()\n\n\ta.Update(\"asd\")\n\ta.Stop()\n\n\tos.Stdout = originalStdout // Restore original os.Stdout\n}\n\nfunc TestAreaPrinter_CenterFullscreen(t *testing.T) {\n\toriginalStdout := os.Stdout\n\tos.Stdout = os.NewFile(0, os.DevNull) // Set os.Stdout to DevNull to hide output from cursor.Area\n\n\ta, _ := pterm.DefaultArea.WithRemoveWhenDone().WithFullscreen().WithCenter().Start()\n\n\ta.Update(\"asd\")\n\ta.Stop()\n\n\tos.Stdout = originalStdout // Restore original os.Stdout\n}\n\nfunc TestAreaPrinter_GetContent(t *testing.T) {\n\toriginalStdout := os.Stdout\n\tos.Stdout = os.NewFile(0, os.DevNull) // Set os.Stdout to DevNull to hide output from cursor.Area\n\n\ta, _ := pterm.DefaultArea.Start()\n\n\tfor _, printable := range printables {\n\t\ta.Update(printable)\n\t\ttestza.AssertEqual(t, a.GetContent(), pterm.Sprint(printable))\n\t}\n\n\ta.Stop()\n\n\tos.Stdout = originalStdout // Restore original os.Stdout\n}\n\nfunc TestAreaPrinter_WithRemoveWhenDone(t *testing.T) {\n\toriginalStdout := os.Stdout\n\tos.Stdout = os.NewFile(0, os.DevNull) // Set os.Stdout to DevNull to hide output from cursor.Area\n\n\tp := pterm.AreaPrinter{}\n\tp2 := p.WithRemoveWhenDone()\n\n\ttestza.AssertTrue(t, p2.RemoveWhenDone)\n\n\tos.Stdout = originalStdout // Restore original os.Stdout\n}\n\nfunc TestAreaPrinter_WithFullscreen(t *testing.T) {\n\toriginalStdout := os.Stdout\n\tos.Stdout = os.NewFile(0, os.DevNull) // Set os.Stdout to DevNull to hide output from cursor.Area\n\n\tp := pterm.AreaPrinter{}\n\tp2 := p.WithFullscreen()\n\n\ttestza.AssertTrue(t, p2.Fullscreen)\n\n\tos.Stdout = originalStdout // Restore original os.Stdout\n}\n\nfunc TestAreaPrinter_Clear(t *testing.T) {\n\toriginalStdout := os.Stdout\n\tos.Stdout = os.NewFile(0, os.DevNull) // Set os.Stdout to DevNull to hide output from cursor.Area\n\n\tp := pterm.AreaPrinter{}\n\tp.Update(\"asd\")\n\n\tp.Clear()\n\n\tos.Stdout = originalStdout // Restore original os.Stdout\n}\n"
        },
        {
          "name": "atoms.go",
          "type": "blob",
          "size": 0.82421875,
          "content": "package pterm\n\n// Checkmark is used in the interactive multiselect printer.\ntype Checkmark struct {\n\tChecked   string\n\tUnchecked string\n}\n\n// Bars is used to display multiple Bar.\ntype Bars []Bar\n\n// Bar is used in bar charts.\ntype Bar struct {\n\tLabel      string\n\tValue      int\n\tStyle      *Style\n\tLabelStyle *Style\n}\n\n// WithLabel returns a new Bar with a specific option.\nfunc (p Bar) WithLabel(s string) *Bar {\n\tp.Label = s\n\treturn &p\n}\n\n// WithLabelStyle returns a new Bar with a specific option.\nfunc (p Bar) WithLabelStyle(style *Style) *Bar {\n\tp.LabelStyle = style\n\treturn &p\n}\n\n// WithValue returns a new Bar with a specific option.\nfunc (p Bar) WithValue(value int) *Bar {\n\tp.Value = value\n\treturn &p\n}\n\n// WithStyle returns a new Bar with a specific option.\nfunc (p Bar) WithStyle(style *Style) *Bar {\n\tp.Style = style\n\treturn &p\n}\n"
        },
        {
          "name": "atoms_test.go",
          "type": "blob",
          "size": 0.84375,
          "content": "package pterm_test\n\nimport (\n\t\"testing\"\n\n\t\"github.com/MarvinJWendt/testza\"\n\t\"github.com/pterm/pterm\"\n)\n\nfunc TestBar_WithLabel(t *testing.T) {\n\tp := pterm.Bar{}\n\ts := \"X\"\n\tp2 := p.WithLabel(s)\n\n\ttestza.AssertEqual(t, s, p2.Label)\n\ttestza.AssertZero(t, p.Label)\n}\n\nfunc TestBar_WithStyle(t *testing.T) {\n\tp := pterm.Bar{}\n\ts := pterm.NewStyle(pterm.FgRed, pterm.BgBlue, pterm.Bold)\n\tp2 := p.WithStyle(s)\n\n\ttestza.AssertEqual(t, s, p2.Style)\n\ttestza.AssertZero(t, p.Style)\n}\n\nfunc TestBar_WithValue(t *testing.T) {\n\tp := pterm.Bar{}\n\ts := 1337\n\tp2 := p.WithValue(s)\n\n\ttestza.AssertEqual(t, s, p2.Value)\n\ttestza.AssertZero(t, p.Value)\n}\n\nfunc TestBar_WithLabelStyle(t *testing.T) {\n\tp := pterm.Bar{}\n\ts := pterm.NewStyle(pterm.FgRed, pterm.BgBlue, pterm.Bold)\n\tp2 := p.WithLabelStyle(s)\n\n\ttestza.AssertEqual(t, s, p2.LabelStyle)\n\ttestza.AssertZero(t, p.LabelStyle)\n}\n"
        },
        {
          "name": "barchart.go",
          "type": "blob",
          "size": 12.923828125,
          "content": "package pterm\n\nimport (\n\t\"io\"\n\t\"strconv\"\n\t\"strings\"\n\n\t\"github.com/mattn/go-runewidth\"\n\n\t\"github.com/pterm/pterm/internal\"\n)\n\n// BarChartPrinter is used to print bar charts.\ntype BarChartPrinter struct {\n\tWriter     io.Writer\n\tBars       Bars\n\tHorizontal bool\n\tShowValue  bool\n\t// Height sets the maximum height of a vertical bar chart.\n\t// The default is calculated to fit into the terminal.\n\t// Ignored if Horizontal is set to true.\n\tHeight int\n\t// Width sets the maximum width of a horizontal bar chart.\n\t// The default is calculated to fit into the terminal.\n\t// Ignored if Horizontal is set to false.\n\tWidth                  int\n\tVerticalBarCharacter   string\n\tHorizontalBarCharacter string\n}\n\nvar (\n\t// DefaultBarChart is the default BarChartPrinter.\n\tDefaultBarChart = BarChartPrinter{\n\t\tHorizontal:             false,\n\t\tVerticalBarCharacter:   \"██\",\n\t\tHorizontalBarCharacter: \"█\",\n\t\t// keep in sync with RecalculateTerminalSize()\n\t\tHeight: GetTerminalHeight() * 2 / 3,\n\t\tWidth:  GetTerminalWidth() * 2 / 3,\n\t}\n)\n\n// WithBars returns a new BarChartPrinter with a specific option.\nfunc (p BarChartPrinter) WithBars(bars Bars) *BarChartPrinter {\n\tp.Bars = bars\n\treturn &p\n}\n\n// WithVerticalBarCharacter returns a new BarChartPrinter with a specific option.\nfunc (p BarChartPrinter) WithVerticalBarCharacter(char string) *BarChartPrinter {\n\tp.VerticalBarCharacter = char\n\treturn &p\n}\n\n// WithHorizontalBarCharacter returns a new BarChartPrinter with a specific option.\nfunc (p BarChartPrinter) WithHorizontalBarCharacter(char string) *BarChartPrinter {\n\tp.HorizontalBarCharacter = char\n\treturn &p\n}\n\n// WithHorizontal returns a new BarChartPrinter with a specific option.\nfunc (p BarChartPrinter) WithHorizontal(b ...bool) *BarChartPrinter {\n\tb2 := internal.WithBoolean(b)\n\tp.Horizontal = b2\n\treturn &p\n}\n\n// WithHeight returns a new BarChartPrinter with a specific option.\nfunc (p BarChartPrinter) WithHeight(value int) *BarChartPrinter {\n\tp.Height = value\n\treturn &p\n}\n\n// WithWidth returns a new BarChartPrinter with a specific option.\nfunc (p BarChartPrinter) WithWidth(value int) *BarChartPrinter {\n\tp.Width = value\n\treturn &p\n}\n\n// WithShowValue returns a new BarChartPrinter with a specific option.\nfunc (p BarChartPrinter) WithShowValue(b ...bool) *BarChartPrinter {\n\tp.ShowValue = internal.WithBoolean(b)\n\treturn &p\n}\n\n// WithWriter sets the custom Writer.\nfunc (p BarChartPrinter) WithWriter(writer io.Writer) *BarChartPrinter {\n\tp.Writer = writer\n\treturn &p\n}\n\nfunc (p BarChartPrinter) getRawOutput() string {\n\tvar ret string\n\n\tfor _, bar := range p.Bars {\n\t\tret += Sprintfln(\"%s: %d\", bar.Label, bar.Value)\n\t}\n\n\treturn ret\n}\n\n// Srender renders the BarChart as a string.\nfunc (p BarChartPrinter) Srender() (string, error) {\n\tmaxAbsValue := func(value1 int, value2 int) int {\n\t\tmin := value1\n\t\tmax := value2\n\n\t\tif value1 > value2 {\n\t\t\tmin = value2\n\t\t\tmax = value1\n\t\t}\n\n\t\tmaxAbs := max\n\n\t\tif min < 0 && -min > max { // This is to avoid something like \"int(math.Abs(float64(minBarValue)))\"\n\t\t\tmaxAbs = -min // (--) == (+)\n\t\t}\n\n\t\treturn maxAbs\n\t}\n\n\tabs := func(value int) int {\n\t\tif value < 0 {\n\t\t\treturn -value\n\t\t}\n\n\t\treturn value\n\t}\n\t// =================================== VERTICAL BARS RENDERER ======================================================\n\n\ttype renderParams struct {\n\t\trepeatCount             int\n\t\tbar                     Bar\n\t\tpositiveChartPartHeight int\n\t\tnegativeChartPartHeight int\n\t\tpositiveChartPartWidth  int\n\t\tnegativeChartPartWidth  int\n\t\tindent                  string\n\t\tshowValue               bool\n\t\tmoveUp                  bool\n\t\tmoveRight               bool\n\t}\n\n\trenderPositiveVerticalBar := func(renderedBarRef *string, rParams renderParams) {\n\t\tif rParams.showValue {\n\t\t\t*renderedBarRef += Sprint(rParams.indent + strconv.Itoa(rParams.bar.Value) + rParams.indent + \"\\n\")\n\t\t}\n\n\t\tfor i := rParams.positiveChartPartHeight; i > 0; i-- {\n\t\t\tif i > rParams.repeatCount {\n\t\t\t\t*renderedBarRef += rParams.indent + \"  \" + rParams.indent + \" \\n\"\n\t\t\t} else {\n\t\t\t\t*renderedBarRef += rParams.indent + rParams.bar.Style.Sprint(p.VerticalBarCharacter) + rParams.indent + \" \\n\"\n\t\t\t}\n\t\t}\n\n\t\t// Used when we draw diagram with both POSITIVE and NEGATIVE values.\n\t\t// In such case we separately draw top and bottom half of chart.\n\t\t// And we need MOVE UP positive part to top part of chart,\n\t\t// technically by adding empty pillars with height == height of chart's bottom part.\n\t\tif rParams.moveUp {\n\t\t\tfor i := 0; i <= rParams.negativeChartPartHeight; i++ {\n\t\t\t\t*renderedBarRef += rParams.indent + \"  \" + rParams.indent + \" \\n\"\n\t\t\t}\n\t\t}\n\t}\n\n\trenderNegativeVerticalBar := func(renderedBarRef *string, rParams renderParams) {\n\t\tfor i := 0; i > -rParams.negativeChartPartHeight; i-- {\n\t\t\tif i > rParams.repeatCount {\n\t\t\t\t*renderedBarRef += rParams.indent + rParams.bar.Style.Sprint(p.VerticalBarCharacter) + rParams.indent + \" \\n\"\n\t\t\t} else {\n\t\t\t\t*renderedBarRef += rParams.indent + \"  \" + rParams.indent + \" \\n\"\n\t\t\t}\n\t\t}\n\n\t\tif rParams.showValue {\n\t\t\t*renderedBarRef += Sprint(rParams.indent + strconv.Itoa(rParams.bar.Value) + rParams.indent + \"\\n\")\n\t\t}\n\t}\n\n\t// =================================== HORIZONTAL BARS RENDERER ====================================================\n\trenderPositiveHorizontalBar := func(renderedBarRef *string, rParams renderParams) {\n\t\tif rParams.moveRight {\n\t\t\tfor i := 0; i < rParams.negativeChartPartWidth; i++ {\n\t\t\t\t*renderedBarRef += \" \"\n\t\t\t}\n\t\t}\n\n\t\tfor i := 0; i < rParams.positiveChartPartWidth; i++ {\n\t\t\tif i < rParams.repeatCount {\n\t\t\t\t*renderedBarRef += rParams.bar.Style.Sprint(p.HorizontalBarCharacter)\n\t\t\t} else {\n\t\t\t\t*renderedBarRef += \" \"\n\t\t\t}\n\t\t}\n\n\t\tif rParams.showValue {\n\t\t\t// For positive horizontal bars we add one more space before adding value,\n\t\t\t// so they will be well aligned with negative values, which have \"-\" sign before them\n\t\t\t*renderedBarRef += \" \"\n\n\t\t\t*renderedBarRef += \" \" + strconv.Itoa(rParams.bar.Value)\n\t\t}\n\t}\n\n\trenderNegativeHorizontalBar := func(renderedBarRef *string, rParams renderParams) {\n\t\tfor i := -rParams.negativeChartPartWidth; i < 0; i++ {\n\t\t\tif i < rParams.repeatCount {\n\t\t\t\t*renderedBarRef += \" \"\n\t\t\t} else {\n\t\t\t\t*renderedBarRef += rParams.bar.Style.Sprint(p.HorizontalBarCharacter)\n\t\t\t}\n\t\t}\n\n\t\t// In order to print values well-aligned (in case when we have both - positive and negative part of chart),\n\t\t// we should insert an indent with width == width of positive chart part\n\t\tif rParams.positiveChartPartWidth > 0 {\n\t\t\tfor i := 0; i < rParams.positiveChartPartWidth; i++ {\n\t\t\t\t*renderedBarRef += \" \"\n\t\t\t}\n\t\t}\n\n\t\tif rParams.showValue {\n\t\t\t/*\n\t\t\t\tThis is in order to achieve this effect:\n\t\t\t\t 0\n\t\t\t\t-15\n\t\t\t\t 0\n\t\t\t\t-19\n\n\t\t\t\tINSTEAD OF THIS:\n\n\t\t\t\t0\n\t\t\t\t-15\n\t\t\t\t0\n\t\t\t\t-19\n\t\t\t*/\n\t\t\tif rParams.repeatCount == 0 {\n\t\t\t\t*renderedBarRef += \" \"\n\t\t\t}\n\n\t\t\t*renderedBarRef += \" \" + strconv.Itoa(rParams.bar.Value)\n\t\t}\n\t}\n\t// =================================================================================================================\n\n\tif RawOutput {\n\t\treturn p.getRawOutput(), nil\n\t}\n\tfor i, bar := range p.Bars {\n\t\tif bar.Style == nil {\n\t\t\tp.Bars[i].Style = &ThemeDefault.BarStyle\n\t\t}\n\n\t\tif bar.LabelStyle == nil {\n\t\t\tp.Bars[i].LabelStyle = &ThemeDefault.BarLabelStyle\n\t\t}\n\n\t\tp.Bars[i].Label = p.Bars[i].LabelStyle.Sprint(bar.Label)\n\t}\n\n\tvar ret strings.Builder\n\n\tvar maxLabelHeight int\n\tvar maxBarValue int\n\tvar minBarValue int\n\tvar maxAbsBarValue int\n\tvar rParams renderParams\n\n\tfor _, bar := range p.Bars {\n\t\tif bar.Value > maxBarValue {\n\t\t\tmaxBarValue = bar.Value\n\t\t}\n\t\tif bar.Value < minBarValue {\n\t\t\tminBarValue = bar.Value\n\t\t}\n\t\tlabelHeight := len(strings.Split(bar.Label, \"\\n\"))\n\t\tif labelHeight > maxLabelHeight {\n\t\t\tmaxLabelHeight = labelHeight\n\t\t}\n\t}\n\n\tmaxAbsBarValue = maxAbsValue(maxBarValue, minBarValue)\n\n\tif p.Horizontal {\n\t\tpanels := Panels{[]Panel{{}, {}}}\n\n\t\trParams.showValue = p.ShowValue\n\t\trParams.positiveChartPartWidth = p.Width\n\t\trParams.negativeChartPartWidth = p.Width\n\n\t\t// If chart will consist of two parts - positive and negative - we should recalculate max bars WIDTH in LEFT and RIGHT parts\n\t\tif minBarValue < 0 && maxBarValue > 0 {\n\t\t\trParams.positiveChartPartWidth = abs(internal.MapRangeToRange(-float32(maxAbsBarValue), float32(maxAbsBarValue), -float32(p.Width)/2, float32(p.Width)/2, float32(maxBarValue)))\n\t\t\trParams.negativeChartPartWidth = abs(internal.MapRangeToRange(-float32(maxAbsBarValue), float32(maxAbsBarValue), -float32(p.Width)/2, float32(p.Width)/2, float32(minBarValue)))\n\t\t}\n\n\t\tfor _, bar := range p.Bars {\n\t\t\trParams.bar = bar\n\t\t\tpanels[0][0].Data += \"\\n\" + bar.Label\n\t\t\tpanels[0][1].Data += \"\\n\"\n\n\t\t\tif minBarValue >= 0 {\n\t\t\t\t// As we don't have negative values, draw only positive (right) part of the chart:\n\t\t\t\trParams.repeatCount = internal.MapRangeToRange(0, float32(maxAbsBarValue), 0, float32(p.Width), float32(bar.Value))\n\t\t\t\trParams.moveRight = false\n\n\t\t\t\trenderPositiveHorizontalBar(&panels[0][1].Data, rParams)\n\t\t\t} else if maxBarValue <= 0 {\n\t\t\t\t// As we have only negative values, draw only negative (left) part of the chart:\n\t\t\t\trParams.repeatCount = internal.MapRangeToRange(-float32(maxAbsBarValue), 0, -float32(p.Width), 0, float32(bar.Value))\n\t\t\t\trParams.positiveChartPartWidth = 0\n\n\t\t\t\trenderNegativeHorizontalBar(&panels[0][1].Data, rParams)\n\t\t\t} else {\n\t\t\t\t// We have positive and negative values, so draw both (left+right) parts of the chart:\n\t\t\t\trParams.repeatCount = internal.MapRangeToRange(-float32(maxAbsBarValue), float32(maxAbsBarValue), -float32(p.Width)/2, float32(p.Width)/2, float32(bar.Value))\n\n\t\t\t\tif bar.Value >= 0 {\n\t\t\t\t\trParams.moveRight = true\n\n\t\t\t\t\trenderPositiveHorizontalBar(&panels[0][1].Data, rParams)\n\t\t\t\t}\n\n\t\t\t\tif bar.Value < 0 {\n\t\t\t\t\trenderNegativeHorizontalBar(&panels[0][1].Data, rParams)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tresult, _ := DefaultPanel.WithPanels(panels).Srender()\n\t\treturn result, nil\n\t} else {\n\t\trenderedBars := make([]string, len(p.Bars))\n\n\t\trParams.showValue = p.ShowValue\n\t\trParams.positiveChartPartHeight = p.Height\n\t\trParams.negativeChartPartHeight = p.Height\n\n\t\t// If chart will consist of two parts - positive and negative - we should recalculate max bars height in top and bottom parts\n\t\tif minBarValue < 0 && maxBarValue > 0 {\n\t\t\trParams.positiveChartPartHeight = abs(internal.MapRangeToRange(-float32(maxAbsBarValue), float32(maxAbsBarValue), -float32(p.Height)/2, float32(p.Height)/2, float32(maxBarValue)))\n\t\t\trParams.negativeChartPartHeight = abs(internal.MapRangeToRange(-float32(maxAbsBarValue), float32(maxAbsBarValue), -float32(p.Height)/2, float32(p.Height)/2, float32(minBarValue)))\n\t\t}\n\n\t\tfor i, bar := range p.Bars {\n\t\t\tvar renderedBar string\n\t\t\trParams.bar = bar\n\t\t\trParams.indent = strings.Repeat(\" \", internal.GetStringMaxWidth(RemoveColorFromString(bar.Label))/2)\n\n\t\t\tif minBarValue >= 0 {\n\t\t\t\t// As we don't have negative values, draw only positive (top) part of the chart:\n\t\t\t\trParams.repeatCount = internal.MapRangeToRange(0, float32(maxAbsBarValue), 0, float32(p.Height), float32(bar.Value))\n\t\t\t\trParams.moveUp = false // Don't MOVE UP as we have ONLY positive part of chart.\n\n\t\t\t\trenderPositiveVerticalBar(&renderedBar, rParams)\n\t\t\t} else if maxBarValue <= 0 {\n\t\t\t\t// As we have only negative values, draw only negative (bottom) part of the chart:\n\t\t\t\trParams.repeatCount = internal.MapRangeToRange(-float32(maxAbsBarValue), 0, -float32(p.Height), 0, float32(bar.Value))\n\n\t\t\t\trenderNegativeVerticalBar(&renderedBar, rParams)\n\t\t\t} else {\n\t\t\t\t// We have positive and negative values, so draw both (top+bottom) parts of the chart:\n\t\t\t\trParams.repeatCount = internal.MapRangeToRange(-float32(maxAbsBarValue), float32(maxAbsBarValue), -float32(p.Height)/2, float32(p.Height)/2, float32(bar.Value))\n\n\t\t\t\tif bar.Value >= 0 {\n\t\t\t\t\trParams.moveUp = true // MOVE UP positive part, because we have both positive and negative parts of chart.\n\n\t\t\t\t\trenderPositiveVerticalBar(&renderedBar, rParams)\n\t\t\t\t}\n\n\t\t\t\tif bar.Value < 0 {\n\t\t\t\t\trenderNegativeVerticalBar(&renderedBar, rParams)\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tlabelHeight := len(strings.Split(bar.Label, \"\\n\"))\n\t\t\trenderedBars[i] = renderedBar + bar.Label + strings.Repeat(\"\\n\", maxLabelHeight-labelHeight) + \" \"\n\t\t}\n\n\t\tvar maxBarHeight int\n\n\t\tfor _, bar := range renderedBars {\n\t\t\ttotalBarHeight := len(strings.Split(bar, \"\\n\"))\n\t\t\tif totalBarHeight > maxBarHeight {\n\t\t\t\tmaxBarHeight = totalBarHeight\n\t\t\t}\n\t\t}\n\n\t\tfor i, bar := range renderedBars {\n\t\t\ttotalBarHeight := len(strings.Split(bar, \"\\n\"))\n\t\t\tif totalBarHeight < maxBarHeight {\n\t\t\t\trenderedBars[i] = strings.Repeat(\"\\n\", maxBarHeight-totalBarHeight) + renderedBars[i]\n\t\t\t}\n\t\t}\n\n\t\tfor i := 0; i <= maxBarHeight; i++ {\n\t\t\tfor _, barString := range renderedBars {\n\t\t\t\tvar barLine string\n\t\t\t\tletterLines := strings.Split(barString, \"\\n\")\n\t\t\t\tmaxBarWidth := internal.GetStringMaxWidth(RemoveColorFromString(barString))\n\t\t\t\tif len(letterLines) > i {\n\t\t\t\t\tbarLine = letterLines[i]\n\t\t\t\t}\n\t\t\t\tletterLineLength := runewidth.StringWidth(RemoveColorFromString(barLine))\n\t\t\t\tif letterLineLength < maxBarWidth {\n\t\t\t\t\tbarLine += strings.Repeat(\" \", maxBarWidth-letterLineLength)\n\t\t\t\t}\n\t\t\t\tret.WriteString(barLine)\n\t\t\t}\n\t\t\tret.WriteByte('\\n')\n\t\t}\n\t}\n\n\treturn ret.String(), nil\n}\n\n// Render prints the Template to the terminal.\nfunc (p BarChartPrinter) Render() error {\n\ts, _ := p.Srender()\n\tFprintln(p.Writer, s)\n\n\treturn nil\n}\n"
        },
        {
          "name": "barchart_test.go",
          "type": "blob",
          "size": 9.9677734375,
          "content": "package pterm_test\n\nimport (\n\t\"os\"\n\t\"testing\"\n\n\t\"github.com/MarvinJWendt/testza\"\n\t\"github.com/pterm/pterm\"\n)\n\nfunc TestBarChartPrinterNilPrint(t *testing.T) {\n\tproxyToDevNull()\n\tp := pterm.BarChartPrinter{}\n\terr := p.Render()\n\tif err != nil {\n\t\tpanic(err)\n\t}\n}\n\nfunc TestBarChartPrinter_NilStylePrint(t *testing.T) {\n\tbars := pterm.Bars{\n\t\tpterm.Bar{\n\t\t\tLabel: \"Bar 1\",\n\t\t\tValue: 5,\n\t\t},\n\t\tpterm.Bar{\n\t\t\tLabel: \"Bar 2\",\n\t\t\tValue: 3,\n\t\t},\n\t\tpterm.Bar{\n\t\t\tLabel: \"Longer Label\",\n\t\t\tValue: 7,\n\t\t},\n\t}\n\n\tpterm.DefaultBarChart.WithBars(bars).Render()\n}\n\n// VERTICAL bars + MIXED values test\nfunc TestBarChartPrinter_RenderExample(t *testing.T) {\n\tbars := pterm.Bars{\n\t\tpterm.Bar{\n\t\t\tLabel: \"Bar 1\",\n\t\t\tValue: 5,\n\t\t\tStyle: pterm.NewStyle(pterm.FgCyan),\n\t\t},\n\t\tpterm.Bar{\n\t\t\tLabel: \"Bar 2\",\n\t\t\tValue: 3,\n\t\t\tStyle: pterm.NewStyle(pterm.FgCyan),\n\t\t},\n\t\tpterm.Bar{\n\t\t\tLabel: \"Long Label Example\",\n\t\t\tValue: 7,\n\t\t\tStyle: pterm.NewStyle(pterm.FgCyan),\n\t\t},\n\t\tpterm.Bar{\n\t\t\tLabel: \"Zero\",\n\t\t\tValue: 0,\n\t\t\tStyle: pterm.NewStyle(pterm.FgCyan),\n\t\t},\n\t\tpterm.Bar{\n\t\t\tLabel: \"Negative Value\",\n\t\t\tValue: -4,\n\t\t\tStyle: pterm.NewStyle(pterm.FgCyan),\n\t\t},\n\t\tpterm.Bar{\n\t\t\tLabel: \"NV\",\n\t\t\tValue: -5,\n\t\t\tStyle: pterm.NewStyle(pterm.FgCyan),\n\t\t},\n\t}\n\n\tpterm.DefaultBarChart.WithBars(bars).Render()\n}\n\n// VERTICAL bars + NEGATIVE values test\nfunc TestBarChartPrinter_RenderNegativeBarValues(t *testing.T) {\n\tpterm.DefaultBarChart.WithShowValue().WithBars(pterm.Bars{\n\t\tpterm.Bar{\n\t\t\tLabel: \"Test\",\n\t\t\tValue: -1337,\n\t\t\tStyle: pterm.NewStyle(pterm.FgRed, pterm.BgBlue, pterm.Bold),\n\t\t},\n\t\tpterm.Bar{\n\t\t\tLabel: \"Test\",\n\t\t\tValue: -1000,\n\t\t\tStyle: pterm.NewStyle(pterm.FgRed, pterm.BgBlue, pterm.Bold),\n\t\t},\n\t\tpterm.Bar{\n\t\t\tLabel: \"Test\",\n\t\t\tValue: -950,\n\t\t\tStyle: pterm.NewStyle(pterm.FgRed, pterm.BgBlue, pterm.Bold),\n\t\t},\n\t\tpterm.Bar{\n\t\t\tLabel: \"Test\",\n\t\t\tValue: -1500,\n\t\t\tStyle: pterm.NewStyle(pterm.FgRed, pterm.BgBlue, pterm.Bold),\n\t\t},\n\t\tpterm.Bar{\n\t\t\tLabel: \"Test\",\n\t\t\tValue: -10,\n\t\t\tStyle: pterm.NewStyle(pterm.FgRed, pterm.BgBlue, pterm.Bold),\n\t\t},\n\t\tpterm.Bar{\n\t\t\tLabel: \"Test\",\n\t\t\tValue: -100,\n\t\t\tStyle: pterm.NewStyle(pterm.FgRed, pterm.BgBlue, pterm.Bold),\n\t\t},\n\t}).Render()\n}\n\n// VERTICAL bars + POSITIVE values test\nfunc TestBarChartPrinter_RenderPositiveBarValues(t *testing.T) {\n\tpterm.DefaultBarChart.WithShowValue().WithBars(pterm.Bars{\n\t\tpterm.Bar{\n\t\t\tLabel: \"Test\",\n\t\t\tValue: 1000,\n\t\t\tStyle: pterm.NewStyle(pterm.FgRed, pterm.BgBlue, pterm.Bold),\n\t\t},\n\t\tpterm.Bar{\n\t\t\tLabel: \"Test\",\n\t\t\tValue: 1400,\n\t\t\tStyle: pterm.NewStyle(pterm.FgRed, pterm.BgBlue, pterm.Bold),\n\t\t},\n\t\tpterm.Bar{\n\t\t\tLabel: \"Test\",\n\t\t\tValue: 900,\n\t\t\tStyle: pterm.NewStyle(pterm.FgRed, pterm.BgBlue, pterm.Bold),\n\t\t},\n\t}).Render()\n}\n\n// VERTICAL bars + ZERO values test\nfunc TestBarChartPrinter_RenderZeroBarValues(t *testing.T) {\n\tpterm.DefaultBarChart.WithShowValue().WithBars(pterm.Bars{\n\t\tpterm.Bar{\n\t\t\tLabel: \"Test\",\n\t\t\tValue: 0,\n\t\t\tStyle: pterm.NewStyle(pterm.FgRed, pterm.BgBlue, pterm.Bold),\n\t\t},\n\t\tpterm.Bar{\n\t\t\tLabel: \"Test\",\n\t\t\tValue: 0,\n\t\t\tStyle: pterm.NewStyle(pterm.FgRed, pterm.BgBlue, pterm.Bold),\n\t\t},\n\t}).Render()\n}\n\n// HORIZONTAL bars + MIXED values test\nfunc TestBarChartPrinter_RenderExampleHorizontal(t *testing.T) {\n\tpterm.DefaultBarChart.WithShowValue().WithHorizontal().WithBars(pterm.Bars{\n\t\tpterm.Bar{\n\t\t\tLabel: \"Test\",\n\t\t\tValue: 1337,\n\t\t\tStyle: pterm.NewStyle(pterm.FgRed, pterm.BgBlue, pterm.Bold),\n\t\t},\n\t\tpterm.Bar{\n\t\t\tLabel: \"Test\",\n\t\t\tValue: 1000,\n\t\t\tStyle: pterm.NewStyle(pterm.FgRed, pterm.BgBlue, pterm.Bold),\n\t\t},\n\t\tpterm.Bar{\n\t\t\tLabel: \"Zero\",\n\t\t\tValue: 0,\n\t\t\tStyle: pterm.NewStyle(pterm.FgRed, pterm.BgBlue, pterm.Bold),\n\t\t},\n\t\tpterm.Bar{\n\t\t\tLabel: \"Test\",\n\t\t\tValue: -800,\n\t\t\tStyle: pterm.NewStyle(pterm.FgRed, pterm.BgBlue, pterm.Bold),\n\t\t},\n\t\tpterm.Bar{\n\t\t\tLabel: \"Test\",\n\t\t\tValue: -500,\n\t\t\tStyle: pterm.NewStyle(pterm.FgRed, pterm.BgBlue, pterm.Bold),\n\t\t},\n\t}).Render()\n}\n\n// HORIZONTAL bars + NEGATIVE values test\nfunc TestBarChartPrinter_RenderNegativeBarValuesHorizontal(t *testing.T) {\n\tpterm.DefaultBarChart.WithShowValue().WithHorizontal().WithBars(pterm.Bars{\n\t\tpterm.Bar{\n\t\t\tLabel: \"Test\",\n\t\t\tValue: -999,\n\t\t\tStyle: pterm.NewStyle(pterm.FgRed, pterm.BgBlue, pterm.Bold),\n\t\t},\n\t\tpterm.Bar{\n\t\t\tLabel: \"Test\",\n\t\t\tValue: -500,\n\t\t\tStyle: pterm.NewStyle(pterm.FgRed, pterm.BgBlue, pterm.Bold),\n\t\t},\n\t\tpterm.Bar{\n\t\t\tLabel: \"Test\",\n\t\t\tValue: -653,\n\t\t\tStyle: pterm.NewStyle(pterm.FgRed, pterm.BgBlue, pterm.Bold),\n\t\t},\n\t\tpterm.Bar{\n\t\t\tLabel: \"Test\",\n\t\t\tValue: 0,\n\t\t\tStyle: pterm.NewStyle(pterm.FgRed, pterm.BgBlue, pterm.Bold),\n\t\t},\n\t\tpterm.Bar{\n\t\t\tLabel: \"Test\",\n\t\t\tValue: -20,\n\t\t\tStyle: pterm.NewStyle(pterm.FgRed, pterm.BgBlue, pterm.Bold),\n\t\t},\n\t\tpterm.Bar{\n\t\t\tLabel: \"Test\",\n\t\t\tValue: -100,\n\t\t\tStyle: pterm.NewStyle(pterm.FgRed, pterm.BgBlue, pterm.Bold),\n\t\t},\n\t\tpterm.Bar{\n\t\t\tLabel: \"Test\",\n\t\t\tValue: 0,\n\t\t\tStyle: pterm.NewStyle(pterm.FgRed, pterm.BgBlue, pterm.Bold),\n\t\t},\n\t\tpterm.Bar{\n\t\t\tLabel: \"Test\",\n\t\t\tValue: -30,\n\t\t\tStyle: pterm.NewStyle(pterm.FgRed, pterm.BgBlue, pterm.Bold),\n\t\t},\n\t}).Render()\n}\n\n// HORIZONTAL bars + POSITIVE values test\nfunc TestBarChartPrinter_RenderPositiveBarValuesHorizontal(t *testing.T) {\n\tpterm.DefaultBarChart.WithShowValue().WithHorizontal().WithBars(pterm.Bars{\n\t\tpterm.Bar{\n\t\t\tLabel: \"Test\",\n\t\t\tValue: 30,\n\t\t\tStyle: pterm.NewStyle(pterm.FgRed, pterm.BgBlue, pterm.Bold),\n\t\t},\n\t\tpterm.Bar{\n\t\t\tLabel: \"Test\",\n\t\t\tValue: 70,\n\t\t\tStyle: pterm.NewStyle(pterm.FgRed, pterm.BgBlue, pterm.Bold),\n\t\t},\n\t\tpterm.Bar{\n\t\t\tLabel: \"Test\",\n\t\t\tValue: 80,\n\t\t\tStyle: pterm.NewStyle(pterm.FgRed, pterm.BgBlue, pterm.Bold),\n\t\t},\n\t\tpterm.Bar{\n\t\t\tLabel: \"Test\",\n\t\t\tValue: 90,\n\t\t\tStyle: pterm.NewStyle(pterm.FgRed, pterm.BgBlue, pterm.Bold),\n\t\t},\n\t\tpterm.Bar{\n\t\t\tLabel: \"Test\",\n\t\t\tValue: 40,\n\t\t\tStyle: pterm.NewStyle(pterm.FgRed, pterm.BgBlue, pterm.Bold),\n\t\t},\n\t\tpterm.Bar{\n\t\t\tLabel: \"Test\",\n\t\t\tValue: 30,\n\t\t\tStyle: pterm.NewStyle(pterm.FgRed, pterm.BgBlue, pterm.Bold),\n\t\t},\n\t}).Render()\n}\n\n// HORIZONTAL bars + ZERO values test\nfunc TestBarChartPrinter_RenderZeroBarValuesHorizontal(t *testing.T) {\n\tpterm.DefaultBarChart.WithShowValue().WithHorizontal().WithBars(pterm.Bars{\n\t\tpterm.Bar{\n\t\t\tLabel: \"Test\",\n\t\t\tValue: 0,\n\t\t\tStyle: pterm.NewStyle(pterm.FgRed, pterm.BgBlue, pterm.Bold),\n\t\t},\n\t\tpterm.Bar{\n\t\t\tLabel: \"Test\",\n\t\t\tValue: 0,\n\t\t\tStyle: pterm.NewStyle(pterm.FgRed, pterm.BgBlue, pterm.Bold),\n\t\t},\n\t}).Render()\n}\n\nfunc TestBarChartPrinter_RenderExampleRawOutput(t *testing.T) {\n\tpterm.DisableStyling()\n\tbars := pterm.Bars{\n\t\tpterm.Bar{\n\t\t\tLabel: \"Bar 1\",\n\t\t\tValue: 5,\n\t\t\tStyle: pterm.NewStyle(pterm.FgCyan),\n\t\t},\n\t\tpterm.Bar{\n\t\t\tLabel: \"Bar 2\",\n\t\t\tValue: 3,\n\t\t\tStyle: pterm.NewStyle(pterm.FgCyan),\n\t\t},\n\t\tpterm.Bar{\n\t\t\tLabel: \"Long Label Example\",\n\t\t\tValue: 7,\n\t\t\tStyle: pterm.NewStyle(pterm.FgCyan),\n\t\t},\n\t\tpterm.Bar{\n\t\t\tLabel: \"Zero\",\n\t\t\tValue: 0,\n\t\t\tStyle: pterm.NewStyle(pterm.FgCyan),\n\t\t},\n\t\tpterm.Bar{\n\t\t\tLabel: \"Negative Value\",\n\t\t\tValue: -4,\n\t\t\tStyle: pterm.NewStyle(pterm.FgCyan),\n\t\t},\n\t\tpterm.Bar{\n\t\t\tLabel: \"NV\",\n\t\t\tValue: -5,\n\t\t\tStyle: pterm.NewStyle(pterm.FgCyan),\n\t\t},\n\t}\n\n\tpterm.DefaultBarChart.WithBars(bars).Render()\n\tpterm.EnableStyling()\n}\n\nfunc TestBarChartPrinter_RenderMultipleLineLabel(t *testing.T) {\n\tpterm.DefaultBarChart.WithShowValue().WithBars(pterm.Bars{\n\t\tpterm.Bar{\n\t\t\tLabel: \"Test\",\n\t\t\tValue: -1337,\n\t\t\tStyle: pterm.NewStyle(pterm.FgRed, pterm.BgBlue, pterm.Bold),\n\t\t},\n\t\tpterm.Bar{\n\t\t\tLabel: \"Test\\nNew Line\",\n\t\t\tValue: -1337,\n\t\t\tStyle: pterm.NewStyle(pterm.FgRed, pterm.BgBlue, pterm.Bold),\n\t\t},\n\t\tpterm.Bar{\n\t\t\tLabel: \"Test\",\n\t\t\tValue: -1337,\n\t\t\tStyle: pterm.NewStyle(pterm.FgRed, pterm.BgBlue, pterm.Bold),\n\t\t},\n\t}).Render()\n}\n\nfunc TestBarChartPrinter_RenderLowBarValues(t *testing.T) {\n\tpterm.DefaultBarChart.WithShowValue().WithBars(pterm.Bars{\n\t\tpterm.Bar{\n\t\t\tLabel: \"Test\",\n\t\t\tValue: 1,\n\t\t\tStyle: pterm.NewStyle(pterm.FgRed, pterm.BgBlue, pterm.Bold),\n\t\t},\n\t\tpterm.Bar{\n\t\t\tLabel: \"Test\",\n\t\t\tValue: 1,\n\t\t\tStyle: pterm.NewStyle(pterm.FgRed, pterm.BgBlue, pterm.Bold),\n\t\t},\n\t}).Render()\n}\n\nfunc TestBarChartPrinter_Render(t *testing.T) {\n\tpterm.DefaultBarChart.WithShowValue().WithBars(pterm.Bars{\n\t\tpterm.Bar{\n\t\t\tLabel: \"Test\",\n\t\t\tValue: 1337,\n\t\t\tStyle: pterm.NewStyle(pterm.FgRed, pterm.BgBlue, pterm.Bold),\n\t\t},\n\t\tpterm.Bar{\n\t\t\tLabel: \"Test\",\n\t\t\tValue: 1337,\n\t\t\tStyle: pterm.NewStyle(pterm.FgRed, pterm.BgBlue, pterm.Bold),\n\t\t},\n\t}).Render()\n}\n\nfunc TestBarChartPrinter_WithHorizontalBarCharacter(t *testing.T) {\n\tp := pterm.BarChartPrinter{}\n\ts := \"X\"\n\tp2 := p.WithHorizontalBarCharacter(s)\n\n\ttestza.AssertEqual(t, s, p2.HorizontalBarCharacter)\n\ttestza.AssertZero(t, p.HorizontalBarCharacter)\n}\n\nfunc TestBarChartPrinter_WithVerticalBarCharacter(t *testing.T) {\n\tp := pterm.BarChartPrinter{}\n\ts := \"X\"\n\tp2 := p.WithVerticalBarCharacter(s)\n\n\ttestza.AssertEqual(t, s, p2.VerticalBarCharacter)\n\ttestza.AssertZero(t, p.VerticalBarCharacter)\n}\n\nfunc TestBarChartPrinter_WithBars(t *testing.T) {\n\tp := pterm.BarChartPrinter{}\n\ts := pterm.Bars{\n\t\tpterm.Bar{\n\t\t\tLabel: \"Test\",\n\t\t\tValue: 1337,\n\t\t\tStyle: pterm.NewStyle(pterm.FgRed, pterm.BgBlue, pterm.Bold),\n\t\t},\n\t\tpterm.Bar{\n\t\t\tLabel: \"Test\",\n\t\t\tValue: 1337,\n\t\t\tStyle: pterm.NewStyle(pterm.FgRed, pterm.BgBlue, pterm.Bold),\n\t\t},\n\t}\n\tp2 := p.WithBars(s)\n\n\ttestza.AssertEqual(t, s, p2.Bars)\n\ttestza.AssertZero(t, p.Bars)\n}\n\nfunc TestBarChartPrinter_WithHeight(t *testing.T) {\n\tp := pterm.BarChartPrinter{}\n\ts := 1337\n\tp2 := p.WithHeight(s)\n\n\ttestza.AssertEqual(t, s, p2.Height)\n\ttestza.AssertZero(t, p.Height)\n}\n\nfunc TestBarChartPrinter_WithHorizontal(t *testing.T) {\n\tp := pterm.BarChartPrinter{}\n\ts := true\n\tp2 := p.WithHorizontal(s)\n\n\ttestza.AssertEqual(t, s, p2.Horizontal)\n\ttestza.AssertZero(t, p.Horizontal)\n}\n\nfunc TestBarChartPrinter_WithShowValue(t *testing.T) {\n\tp := pterm.BarChartPrinter{}\n\ts := true\n\tp2 := p.WithShowValue(s)\n\n\ttestza.AssertEqual(t, s, p2.ShowValue)\n\ttestza.AssertZero(t, p.ShowValue)\n}\n\nfunc TestBarChartPrinter_WithWidth(t *testing.T) {\n\tp := pterm.BarChartPrinter{}\n\ts := 1337\n\tp2 := p.WithWidth(s)\n\n\ttestza.AssertEqual(t, s, p2.Width)\n\ttestza.AssertZero(t, p.Width)\n}\n\nfunc TestBarChartPrinter_WithWriter(t *testing.T) {\n\tp := pterm.BarChartPrinter{}\n\ts := os.Stderr\n\tp2 := p.WithWriter(s)\n\n\ttestza.AssertEqual(t, s, p2.Writer)\n\ttestza.AssertZero(t, p.Writer)\n}\n"
        },
        {
          "name": "basic_text_printer.go",
          "type": "blob",
          "size": 3.806640625,
          "content": "package pterm\n\nimport (\n\t\"fmt\"\n\t\"io\"\n)\n\nvar (\n\t// DefaultBasicText returns a default BasicTextPrinter, which can be used to print text as is.\n\t// No default style is present for BasicTextPrinter.\n\tDefaultBasicText = BasicTextPrinter{}\n)\n\n// BasicTextPrinter is the printer used to print the input as-is or as specified by user formatting.\ntype BasicTextPrinter struct {\n\tStyle  *Style\n\tWriter io.Writer\n}\n\n// WithStyle adds a style to the printer.\nfunc (p BasicTextPrinter) WithStyle(style *Style) *BasicTextPrinter {\n\tp.Style = style\n\treturn &p\n}\n\nfunc (p BasicTextPrinter) WithWriter(writer io.Writer) *BasicTextPrinter {\n\tp.Writer = writer\n\treturn &p\n}\n\n// Sprint formats using the default formats for its operands and returns the resulting string.\n// Spaces are added between operands when neither is a string.\nfunc (p BasicTextPrinter) Sprint(a ...any) string {\n\tif p.Style == nil {\n\t\tp.Style = NewStyle()\n\t}\n\treturn p.Style.Sprint(a...)\n}\n\n// Sprintln formats using the default formats for its operands and returns the resulting string.\n// Spaces are always added between operands and a newline is appended.\nfunc (p BasicTextPrinter) Sprintln(a ...any) string {\n\tstr := fmt.Sprintln(a...)\n\treturn Sprintln(p.Sprint(str))\n}\n\n// Sprintf formats according to a format specifier and returns the resulting string.\nfunc (p BasicTextPrinter) Sprintf(format string, a ...any) string {\n\treturn p.Sprint(Sprintf(format, a...))\n}\n\n// Sprintfln formats according to a format specifier and returns the resulting string.\n// Spaces are always added between operands and a newline is appended.\nfunc (p BasicTextPrinter) Sprintfln(format string, a ...any) string {\n\treturn p.Sprintf(format, a...) + \"\\n\"\n}\n\n// Print formats using the default formats for its operands and writes to provided writer.\n// Spaces are added between operands when neither is a string.\n// It returns the number of bytes written and any write error encountered.\nfunc (p *BasicTextPrinter) Print(a ...any) *TextPrinter {\n\tFprint(p.Writer, p.Sprint(a...))\n\ttp := TextPrinter(p)\n\treturn &tp\n}\n\n// Println formats using the default formats for its operands and writes to provided writer.\n// Spaces are always added between operands and a newline is appended.\n// It returns the number of bytes written and any write error encountered.\nfunc (p *BasicTextPrinter) Println(a ...any) *TextPrinter {\n\tFprint(p.Writer, p.Sprintln(a...))\n\ttp := TextPrinter(p)\n\treturn &tp\n}\n\n// Printf formats according to a format specifier and writes to provided writer.\n// It returns the number of bytes written and any write error encountered.\nfunc (p *BasicTextPrinter) Printf(format string, a ...any) *TextPrinter {\n\tFprint(p.Writer, p.Sprintf(format, a...))\n\ttp := TextPrinter(p)\n\treturn &tp\n}\n\n// Printfln formats according to a format specifier and writes to provided writer.\n// Spaces are always added between operands and a newline is appended.\n// It returns the number of bytes written and any write error encountered.\nfunc (p *BasicTextPrinter) Printfln(format string, a ...any) *TextPrinter {\n\tFprint(p.Writer, p.Sprintfln(format, a...))\n\ttp := TextPrinter(p)\n\treturn &tp\n}\n\n// PrintOnError prints every error which is not nil.\n// If every error is nil, nothing will be printed.\n// This can be used for simple error checking.\nfunc (p *BasicTextPrinter) PrintOnError(a ...any) *TextPrinter {\n\tfor _, arg := range a {\n\t\tif err, ok := arg.(error); ok {\n\t\t\tif err != nil {\n\t\t\t\tp.Println(err)\n\t\t\t}\n\t\t}\n\t}\n\n\ttp := TextPrinter(p)\n\treturn &tp\n}\n\n// PrintOnErrorf wraps every error which is not nil and prints it.\n// If every error is nil, nothing will be printed.\n// This can be used for simple error checking.\nfunc (p *BasicTextPrinter) PrintOnErrorf(format string, a ...any) *TextPrinter {\n\tfor _, arg := range a {\n\t\tif err, ok := arg.(error); ok {\n\t\t\tif err != nil {\n\t\t\t\tp.Println(fmt.Errorf(format, err))\n\t\t\t}\n\t\t}\n\t}\n\n\ttp := TextPrinter(p)\n\treturn &tp\n}\n"
        },
        {
          "name": "basic_text_printer_test.go",
          "type": "blob",
          "size": 2.470703125,
          "content": "package pterm_test\n\nimport (\n\t\"errors\"\n\t\"io\"\n\t\"os\"\n\t\"testing\"\n\n\t\"github.com/MarvinJWendt/testza\"\n\n\t\"github.com/pterm/pterm\"\n)\n\nfunc TestBasicTextPrinterNilPrint(t *testing.T) {\n\tproxyToDevNull()\n\tp := pterm.BasicTextPrinter{}\n\tp.Println(\"Hello, World!\")\n}\n\nfunc TestBasicTextPrinterPrintMethods(t *testing.T) {\n\tp := pterm.DefaultBasicText\n\n\tt.Run(\"Print\", func(t *testing.T) {\n\t\ttestPrintContains(t, func(w io.Writer, a any) {\n\t\t\tp.Print(a)\n\t\t})\n\t})\n\n\tt.Run(\"Printf\", func(t *testing.T) {\n\t\ttestPrintfContains(t, func(w io.Writer, format string, a any) {\n\t\t\tp.Printf(format, a)\n\t\t})\n\t})\n\n\tt.Run(\"Printfln\", func(t *testing.T) {\n\t\ttestPrintflnContains(t, func(w io.Writer, format string, a any) {\n\t\t\tp.Printfln(format, a)\n\t\t})\n\t})\n\n\tt.Run(\"Println\", func(t *testing.T) {\n\t\ttestPrintlnContains(t, func(w io.Writer, a any) {\n\t\t\tp.Println(a)\n\t\t})\n\t})\n\n\tt.Run(\"Sprint\", func(t *testing.T) {\n\t\ttestSprintContains(t, func(a any) string {\n\t\t\treturn p.Sprint(a)\n\t\t})\n\t})\n\n\tt.Run(\"Sprintf\", func(t *testing.T) {\n\t\ttestSprintfContains(t, func(format string, a any) string {\n\t\t\treturn p.Sprintf(format, a)\n\t\t})\n\t})\n\n\tt.Run(\"Sprintfln\", func(t *testing.T) {\n\t\ttestSprintflnContains(t, func(format string, a any) string {\n\t\t\treturn p.Sprintfln(format, a)\n\t\t})\n\t})\n\n\tt.Run(\"Sprintln\", func(t *testing.T) {\n\t\ttestSprintlnContains(t, func(a any) string {\n\t\t\treturn p.Sprintln(a)\n\t\t})\n\t})\n\n\tt.Run(\"PrintOnError\", func(t *testing.T) {\n\t\tresult := captureStdout(func(w io.Writer) {\n\t\t\tp.PrintOnError(errors.New(\"hello world\"))\n\t\t})\n\t\ttestza.AssertContains(t, result, \"hello world\")\n\t})\n\n\tt.Run(\"PrintIfError_WithoutError\", func(t *testing.T) {\n\t\tresult := captureStdout(func(w io.Writer) {\n\t\t\tp.PrintOnError(nil)\n\t\t})\n\t\ttestza.AssertZero(t, result)\n\t})\n\n\tt.Run(\"PrintOnErrorf\", func(t *testing.T) {\n\t\tresult := captureStdout(func(w io.Writer) {\n\t\t\tp.PrintOnErrorf(\"wrapping error : %w\", errors.New(\"hello world\"))\n\t\t})\n\t\ttestza.AssertContains(t, result, \"hello world\")\n\t})\n\n\tt.Run(\"PrintIfError_WithoutErrorf\", func(t *testing.T) {\n\t\tresult := captureStdout(func(w io.Writer) {\n\t\t\tp.PrintOnErrorf(\"\", nil)\n\t\t})\n\t\ttestza.AssertZero(t, result)\n\t})\n}\n\nfunc TestBasicTextPrinter_WithStyle(t *testing.T) {\n\ts := pterm.NewStyle(pterm.FgRed, pterm.BgBlue, pterm.Bold)\n\tp := pterm.BasicTextPrinter{}\n\tp2 := p.WithStyle(s)\n\n\ttestza.AssertEqual(t, s, p2.Style)\n}\n\nfunc TestBasicTextPrinter_WithWriter(t *testing.T) {\n\tp := pterm.BasicTextPrinter{}\n\ts := os.Stderr\n\tp2 := p.WithWriter(s)\n\n\ttestza.AssertEqual(t, s, p2.Writer)\n\ttestza.AssertZero(t, p.Writer)\n}\n"
        },
        {
          "name": "bigtext_printer.go",
          "type": "blob",
          "size": 10.384765625,
          "content": "package pterm\n\nimport (\n\t\"io\"\n\t\"strings\"\n\n\t\"github.com/gookit/color\"\n\n\t\"github.com/mattn/go-runewidth\"\n\n\t\"github.com/pterm/pterm/internal\"\n)\n\n// Letters is a slice of Letter.\ntype Letters []Letter\n\n// Letter is an object, which holds a string and a specific Style for it.\ntype Letter struct {\n\tString string\n\tStyle  *Style\n\tRGB    RGB\n}\n\n// WithStyle returns a new Letter with a specific Style.\nfunc (l Letter) WithStyle(style *Style) *Letter {\n\tl.Style = style\n\treturn &l\n}\n\n// WithRGB returns a new Letter with a specific RGB color (overwrites style).\nfunc (l Letter) WithRGB(rgb RGB) *Letter {\n\tl.RGB = rgb\n\treturn &l\n}\n\n// WithString returns a new Letter with a specific String.\nfunc (l Letter) WithString(s string) *Letter {\n\tl.String = s\n\treturn &l\n}\n\n// BigTextPrinter renders big text.\n// You can use this as title screen for your application.\ntype BigTextPrinter struct {\n\t// BigCharacters holds the map from a normal character to it's big version.\n\tBigCharacters map[string]string\n\tLetters       Letters\n\tWriter        io.Writer\n}\n\n// WithBigCharacters returns a new BigTextPrinter with specific BigCharacters.\nfunc (p BigTextPrinter) WithBigCharacters(chars map[string]string) *BigTextPrinter {\n\tp.BigCharacters = chars\n\treturn &p\n}\n\n// WithLetters returns a new BigTextPrinter with specific Letters\nfunc (p BigTextPrinter) WithLetters(letters ...Letters) *BigTextPrinter {\n\tl := Letters{}\n\tfor _, letter := range letters {\n\t\tl = append(l, letter...)\n\t}\n\tp.Letters = l\n\treturn &p\n}\n\n// WithWriter sets the custom Writer.\nfunc (p BigTextPrinter) WithWriter(writer io.Writer) *BigTextPrinter {\n\tp.Writer = writer\n\treturn &p\n}\n\n// Srender renders the BigText as a string.\nfunc (p BigTextPrinter) Srender() (string, error) {\n\tvar ret strings.Builder\n\n\tif RawOutput {\n\t\tfor _, letter := range p.Letters {\n\t\t\tret.WriteString(letter.String)\n\t\t}\n\t\treturn ret.String(), nil\n\t}\n\n\tvar bigLetters Letters\n\tfor _, l := range p.Letters {\n\t\tif val, ok := p.BigCharacters[l.String]; ok {\n\t\t\tbigLetters = append(bigLetters, Letter{\n\t\t\t\tString: val,\n\t\t\t\tStyle:  l.Style,\n\t\t\t\tRGB:    l.RGB,\n\t\t\t})\n\t\t}\n\t}\n\n\tvar maxHeight int\n\n\tfor _, l := range bigLetters {\n\t\th := strings.Count(l.String, \"\\n\")\n\t\tif h > maxHeight {\n\t\t\tmaxHeight = h\n\t\t}\n\t}\n\n\tfor i := 0; i <= maxHeight; i++ {\n\t\tfor _, letter := range bigLetters {\n\t\t\tvar letterLine string\n\t\t\tletterLines := strings.Split(letter.String, \"\\n\")\n\t\t\tmaxLetterWidth := internal.GetStringMaxWidth(letter.String)\n\t\t\tif len(letterLines) > i {\n\t\t\t\tletterLine = letterLines[i]\n\t\t\t}\n\t\t\tletterLineLength := runewidth.StringWidth(letterLine)\n\t\t\tif letterLineLength < maxLetterWidth {\n\t\t\t\tletterLine += strings.Repeat(\" \", maxLetterWidth-letterLineLength)\n\t\t\t}\n\n\t\t\tif letter.RGB != (RGB{}) && (color.IsSupportRGBColor() || internal.RunsInCi()) {\n\t\t\t\tret.WriteString(letter.RGB.Sprint(letterLine))\n\t\t\t} else {\n\t\t\t\tret.WriteString(letter.Style.Sprint(letterLine))\n\t\t\t}\n\t\t}\n\t\tret.WriteByte('\\n')\n\t}\n\n\treturn ret.String(), nil\n}\n\n// Render prints the BigText to the terminal.\nfunc (p BigTextPrinter) Render() error {\n\ts, _ := p.Srender()\n\tFprintln(p.Writer, s)\n\n\treturn nil\n}\n\n// DefaultBigText contains default values for BigTextPrinter.\nvar DefaultBigText = BigTextPrinter{\n\tBigCharacters: map[string]string{\n\t\t\"a\": ` █████  \n██   ██ \n███████ \n██   ██ \n██   ██ `,\n\t\t\"A\": ` █████  \n██   ██ \n███████ \n██   ██ \n██   ██ `,\n\t\t\"b\": `██████  \n██   ██ \n██████  \n██   ██ \n██████`,\n\t\t\"B\": `██████  \n██   ██ \n██████  \n██   ██ \n██████`,\n\t\t\"c\": ` ██████ \n██      \n██      \n██      \n ██████`,\n\t\t\"C\": ` ██████ \n██      \n██      \n██      \n ██████`,\n\t\t\"d\": `██████  \n██   ██ \n██   ██ \n██   ██ \n██████ `,\n\t\t\"D\": `██████  \n██   ██ \n██   ██ \n██   ██ \n██████ `,\n\t\t\"e\": `███████ \n██      \n█████   \n██      \n███████`,\n\t\t\"E\": `███████ \n██      \n█████   \n██      \n███████`,\n\t\t\"f\": `███████ \n██      \n█████   \n██      \n██     `,\n\t\t\"F\": `███████ \n██      \n█████   \n██      \n██     `,\n\t\t\"g\": ` ██████  \n██       \n██   ███ \n██    ██ \n ██████  `,\n\t\t\"G\": ` ██████  \n██       \n██   ███ \n██    ██ \n ██████  `,\n\t\t\"h\": `██   ██ \n██   ██ \n███████ \n██   ██ \n██   ██ `,\n\t\t\"H\": `██   ██ \n██   ██ \n███████ \n██   ██ \n██   ██ `,\n\t\t\"i\": `██ \n██ \n██ \n██ \n██`,\n\t\t\"I\": `██ \n██ \n██ \n██ \n██`,\n\t\t\"j\": `     ██ \n     ██ \n     ██ \n██   ██ \n █████ `,\n\t\t\"J\": `     ██ \n     ██ \n     ██ \n██   ██ \n █████ `,\n\t\t\"k\": `██   ██ \n██  ██  \n█████   \n██  ██  \n██   ██`,\n\t\t\"K\": `██   ██ \n██  ██  \n█████   \n██  ██  \n██   ██`,\n\t\t\"l\": `██      \n██      \n██      \n██      \n███████ `,\n\t\t\"L\": `██      \n██      \n██      \n██      \n███████ `,\n\t\t\"m\": `███    ███ \n████  ████ \n██ ████ ██ \n██  ██  ██ \n██      ██`,\n\t\t\"M\": `███    ███ \n████  ████ \n██ ████ ██ \n██  ██  ██ \n██      ██`,\n\t\t\"n\": `███    ██ \n████   ██ \n██ ██  ██ \n██  ██ ██ \n██   ████`,\n\t\t\"N\": `███    ██ \n████   ██ \n██ ██  ██ \n██  ██ ██ \n██   ████`,\n\t\t\"o\": ` ██████  \n██    ██ \n██    ██ \n██    ██ \n ██████  `,\n\t\t\"O\": ` ██████  \n██    ██ \n██    ██ \n██    ██ \n ██████  `,\n\t\t\"p\": `██████  \n██   ██ \n██████  \n██      \n██     `,\n\t\t\"P\": `██████  \n██   ██ \n██████  \n██      \n██     `,\n\t\t\"q\": ` ██████  \n██    ██ \n██    ██ \n██ ▄▄ ██ \n ██████  \n    ▀▀   `,\n\t\t\"Q\": ` ██████  \n██    ██ \n██    ██ \n██ ▄▄ ██ \n ██████  \n    ▀▀   `,\n\t\t\"r\": `██████  \n██   ██ \n██████  \n██   ██ \n██   ██`,\n\t\t\"R\": `██████  \n██   ██ \n██████  \n██   ██ \n██   ██`,\n\t\t\"s\": `███████ \n██      \n███████ \n     ██ \n███████`,\n\t\t\"S\": `███████ \n██      \n███████ \n     ██ \n███████`,\n\t\t\"t\": `████████ \n   ██    \n   ██    \n   ██    \n   ██    `,\n\t\t\"T\": `████████ \n   ██    \n   ██    \n   ██    \n   ██    `,\n\t\t\"u\": `██    ██ \n██    ██ \n██    ██ \n██    ██ \n ██████ `,\n\t\t\"U\": `██    ██ \n██    ██ \n██    ██ \n██    ██ \n ██████ `,\n\t\t\"v\": `██    ██ \n██    ██ \n██    ██ \n ██  ██  \n  ████   `,\n\t\t\"V\": `██    ██ \n██    ██ \n██    ██ \n ██  ██  \n  ████   `,\n\t\t\"w\": `██     ██ \n██     ██ \n██  █  ██ \n██ ███ ██ \n ███ ███ `,\n\t\t\"W\": `██     ██ \n██     ██ \n██  █  ██ \n██ ███ ██ \n ███ ███ `,\n\t\t\"x\": `██   ██ \n ██ ██  \n  ███   \n ██ ██  \n██   ██ `,\n\t\t\"X\": `██   ██ \n ██ ██  \n  ███   \n ██ ██  \n██   ██ `,\n\t\t\"y\": `██    ██ \n ██  ██  \n  ████   \n   ██    \n   ██   `,\n\t\t\"Y\": `██    ██ \n ██  ██  \n  ████   \n   ██    \n   ██   `,\n\t\t\"z\": `███████ \n   ███  \n  ███   \n ███    \n███████`,\n\t\t\"Z\": `███████ \n   ███  \n  ███   \n ███    \n███████`,\n\t\t\"0\": ` ██████  \n██  ████ \n██ ██ ██ \n████  ██ \n ██████ `,\n\t\t\"1\": ` ██ \n███ \n ██ \n ██ \n ██ `,\n\t\t\"2\": `██████  \n     ██ \n █████  \n██      \n███████ `,\n\t\t\"3\": `██████  \n     ██ \n █████  \n     ██ \n██████ `,\n\t\t\"4\": `██   ██ \n██   ██ \n███████ \n     ██ \n     ██ `,\n\t\t\"5\": `███████ \n██      \n███████ \n     ██ \n███████`,\n\t\t\"6\": ` ██████  \n██       \n███████  \n██    ██ \n ██████ `,\n\t\t\"7\": `███████ \n     ██ \n    ██  \n   ██   \n   ██`,\n\t\t\"8\": ` █████  \n██   ██ \n █████  \n██   ██ \n █████ `,\n\t\t\"9\": ` █████  \n██   ██ \n ██████ \n     ██ \n █████ `,\n\t\t\" \": \"    \",\n\t\t\"!\": `██ \n██ \n██ \n   \n██ `,\n\t\t\"$\": `▄▄███▄▄·\n██      \n███████ \n     ██ \n███████ \n  ▀▀▀  `,\n\t\t\"%\": `██  ██ \n   ██  \n  ██   \n ██    \n██  ██`,\n\t\t\"/\": `    ██ \n   ██  \n  ██   \n ██    \n██   `,\n\t\t\"(\": ` ██ \n██  \n██  \n██  \n ██ `,\n\t\t\")\": `██  \n ██ \n ██ \n ██ \n██  `,\n\t\t\"?\": `██████  \n     ██ \n  ▄███  \n  ▀▀    \n  ██   `,\n\t\t\"[\": `███ \n██  \n██  \n██  \n███`,\n\t\t\"]\": `███ \n ██ \n ██ \n ██ \n███ `,\n\t\t\".\": `   \n   \n   \n   \n██`,\n\t\t\",\": `   \n   \n   \n   \n▄█`,\n\t\t\"-\": `      \n      \n█████ \n      \n      \n     `,\n\t\t\"<\": `  ██ \n ██  \n██   \n ██  \n  ██ `,\n\t\t\">\": `██   \n ██  \n  ██ \n ██  \n██ `,\n\t\t\"*\": `      \n▄ ██ ▄\n ████ \n▀ ██ ▀\n     `,\n\t\t\"#\": ` ██  ██  \n████████ \n ██  ██  \n████████ \n ██  ██ `,\n\t\t\"_\": `        \n        \n        \n        \n███████ `,\n\t\t\":\": `   \n██ \n   \n   \n██ `,\n\t\t\"°\": ` ████  \n██  ██ \n ████  \n       \n      `,\n\t},\n}\n"
        },
        {
          "name": "bigtext_printer_test.go",
          "type": "blob",
          "size": 3.701171875,
          "content": "package pterm_test\n\nimport (\n\t\"fmt\"\n\t\"os\"\n\t\"strings\"\n\t\"testing\"\n\n\t\"github.com/MarvinJWendt/testza\"\n\n\t\"github.com/pterm/pterm\"\n)\n\nfunc TestBigTextPrinterNilPrint(t *testing.T) {\n\tp := pterm.BigTextPrinter{}\n\tp.Render()\n}\n\nfunc TestBigTextPrinter_Render(t *testing.T) {\n\tprinter := pterm.DefaultBigText.WithLetters(pterm.NewLettersFromString(\"Hello\"))\n\tcontent, err := printer.Srender()\n\n\ttestza.AssertNoError(t, err)\n\ttestza.AssertNotZero(t, content)\n}\n\nfunc TestBigTextPrinter_RenderRGB(t *testing.T) {\n\tprinter := pterm.DefaultBigText.WithLetters(pterm.NewLettersFromStringWithRGB(\"Hello\", pterm.NewRGB(255, 0, 0)))\n\tcontent, err := printer.Srender()\n\n\ttestza.AssertNoError(t, err)\n\ttestza.AssertNotZero(t, content)\n}\n\nfunc TestBigTextPrinter_RenderRawOutput(t *testing.T) {\n\tprinter := pterm.DefaultBigText.WithLetters(pterm.NewLettersFromString(\"Hello\"))\n\n\tpterm.DisableStyling()\n\tcontent, err := printer.Srender()\n\tpterm.EnableStyling()\n\n\ttestza.AssertNoError(t, err)\n\ttestza.AssertNotZero(t, content)\n}\n\nfunc TestBigTextPrinter_WithBigCharacters(t *testing.T) {\n\te := map[string]string{\"a\": \"b\", \"c\": \"d\"}\n\tp := pterm.BigTextPrinter{}\n\tp2 := p.WithBigCharacters(e)\n\n\ttestza.AssertEqual(t, e, p2.BigCharacters)\n\ttestza.AssertZero(t, p.BigCharacters)\n}\n\nfunc TestBigTextPrinter_WithLetters(t *testing.T) {\n\te := pterm.Letters{\n\t\tpterm.Letter{\n\t\t\tString: \"test\",\n\t\t\tStyle:  pterm.NewStyle(pterm.FgRed, pterm.BgBlue, pterm.Bold),\n\t\t},\n\t\tpterm.Letter{\n\t\t\tString: \"test2\",\n\t\t\tStyle:  pterm.NewStyle(pterm.FgRed, pterm.BgBlue, pterm.Bold),\n\t\t},\n\t}\n\tp := pterm.BigTextPrinter{}\n\tp2 := p.WithLetters(e)\n\n\ttestza.AssertEqual(t, e, p2.Letters)\n\ttestza.AssertZero(t, p.Letters)\n}\n\nfunc TestLetter_WithString(t *testing.T) {\n\te := \"Hello, World!\"\n\tp := pterm.Letter{}\n\tp2 := p.WithString(e)\n\n\ttestza.AssertEqual(t, e, p2.String)\n\ttestza.AssertZero(t, p.String)\n}\n\nfunc TestLetter_WithStyle(t *testing.T) {\n\tp := pterm.Letter{}\n\ts := pterm.NewStyle(pterm.FgRed, pterm.BgRed, pterm.Bold)\n\tp2 := p.WithStyle(s)\n\n\ttestza.AssertEqual(t, s, p2.Style)\n\ttestza.AssertZero(t, p.Style)\n}\n\nfunc TestLetter_WithRGB(t *testing.T) {\n\tp := pterm.Letter{}\n\trgb := pterm.NewRGB(0, 0, 0)\n\tp2 := p.WithRGB(rgb)\n\n\ttestza.AssertEqual(t, rgb, p2.RGB)\n\ttestza.AssertZero(t, p.RGB)\n}\n\nfunc TestNewLettersFromText(t *testing.T) {\n\te := pterm.Letters{\n\t\tpterm.Letter{\n\t\t\tString: \"a\",\n\t\t\tStyle:  &pterm.ThemeDefault.LetterStyle,\n\t\t},\n\t\tpterm.Letter{\n\t\t\tString: \"b\",\n\t\t\tStyle:  &pterm.ThemeDefault.LetterStyle,\n\t\t},\n\t}\n\tp := pterm.NewLettersFromString(\"ab\")\n\n\ttestza.AssertEqual(t, e, p)\n}\n\nfunc TestNewLettersFromTextWithStyle(t *testing.T) {\n\te := pterm.Letters{\n\t\tpterm.Letter{\n\t\t\tString: \"a\",\n\t\t\tStyle:  pterm.NewStyle(pterm.FgRed, pterm.BgBlue, pterm.Bold),\n\t\t},\n\t\tpterm.Letter{\n\t\t\tString: \"b\",\n\t\t\tStyle:  pterm.NewStyle(pterm.FgRed, pterm.BgBlue, pterm.Bold),\n\t\t},\n\t}\n\tp := pterm.NewLettersFromStringWithStyle(\"ab\", pterm.NewStyle(pterm.FgRed, pterm.BgBlue, pterm.Bold))\n\n\ttestza.AssertEqual(t, e, p)\n}\n\nfunc TestNewLettersFromTextWithRGB(t *testing.T) {\n\te := pterm.Letters{\n\t\tpterm.Letter{\n\t\t\tString: \"a\",\n\t\t\tStyle:  pterm.NewStyle(),\n\t\t\tRGB:    pterm.NewRGB(0, 0, 0),\n\t\t},\n\t\tpterm.Letter{\n\t\t\tString: \"b\",\n\t\t\tStyle:  pterm.NewStyle(),\n\t\t\tRGB:    pterm.NewRGB(0, 0, 0),\n\t\t},\n\t}\n\tp := pterm.NewLettersFromStringWithRGB(\"ab\", pterm.NewRGB(0, 0, 0))\n\n\ttestza.AssertEqual(t, e, p)\n}\n\nfunc TestDefaultLettersMaxHeight(t *testing.T) {\n\tmaxHeight := 5\n\tchars := pterm.DefaultBigText.BigCharacters\n\tfor s, l := range chars {\n\t\th := strings.Count(l, \"\\n\")\n\t\ttestza.AssertTrue(t, h <= maxHeight, fmt.Sprintf(\"'%s' is too high\", s))\n\t}\n}\n\nfunc TestBigTextPrinter_WithWriter(t *testing.T) {\n\tp := pterm.BigTextPrinter{}\n\ts := os.Stderr\n\tp2 := p.WithWriter(s)\n\n\ttestza.AssertEqual(t, s, p2.Writer)\n\ttestza.AssertZero(t, p.Writer)\n}\n"
        },
        {
          "name": "box_printer.go",
          "type": "blob",
          "size": 13.158203125,
          "content": "package pterm\n\nimport (\n\t\"fmt\"\n\t\"io\"\n\t\"strings\"\n\n\t\"github.com/mattn/go-runewidth\"\n\n\t\"github.com/pterm/pterm/internal\"\n)\n\n// BoxPrinter is able to render a box around printables.\ntype BoxPrinter struct {\n\tTitle                   string\n\tTitleTopLeft            bool\n\tTitleTopRight           bool\n\tTitleTopCenter          bool\n\tTitleBottomLeft         bool\n\tTitleBottomRight        bool\n\tTitleBottomCenter       bool\n\tTextStyle               *Style\n\tVerticalString          string\n\tBoxStyle                *Style\n\tHorizontalString        string\n\tTopRightCornerString    string\n\tTopLeftCornerString     string\n\tBottomLeftCornerString  string\n\tBottomRightCornerString string\n\tTopPadding              int\n\tBottomPadding           int\n\tRightPadding            int\n\tLeftPadding             int\n\tWriter                  io.Writer\n}\n\n// DefaultBox is the default BoxPrinter.\nvar DefaultBox = BoxPrinter{\n\tVerticalString:          \"|\",\n\tTopRightCornerString:    \"└\",\n\tTopLeftCornerString:     \"┘\",\n\tBottomLeftCornerString:  \"┐\",\n\tBottomRightCornerString: \"┌\",\n\tHorizontalString:        \"─\",\n\tBoxStyle:                &ThemeDefault.BoxStyle,\n\tTextStyle:               &ThemeDefault.BoxTextStyle,\n\tRightPadding:            1,\n\tLeftPadding:             1,\n\tTopPadding:              0,\n\tBottomPadding:           0,\n\tTitleTopLeft:            true,\n}\n\n// WithTitle returns a new box with a specific Title.\nfunc (p BoxPrinter) WithTitle(str string) *BoxPrinter {\n\tp.Title = str\n\treturn &p\n}\n\n// WithTitleTopLeft returns a new box with a specific Title alignment.\nfunc (p BoxPrinter) WithTitleTopLeft(b ...bool) *BoxPrinter {\n\tb2 := internal.WithBoolean(b)\n\tp.TitleTopLeft = b2\n\tp.TitleTopRight = false\n\tp.TitleTopCenter = false\n\tp.TitleBottomLeft = false\n\tp.TitleBottomRight = false\n\tp.TitleBottomCenter = false\n\treturn &p\n}\n\n// WithTitleTopRight returns a new box with a specific Title alignment.\nfunc (p BoxPrinter) WithTitleTopRight(b ...bool) *BoxPrinter {\n\tb2 := internal.WithBoolean(b)\n\tp.TitleTopLeft = false\n\tp.TitleTopRight = b2\n\tp.TitleTopCenter = false\n\tp.TitleBottomLeft = false\n\tp.TitleBottomRight = false\n\tp.TitleBottomCenter = false\n\treturn &p\n}\n\n// WithTitleTopCenter returns a new box with a specific Title alignment.\nfunc (p BoxPrinter) WithTitleTopCenter(b ...bool) *BoxPrinter {\n\tb2 := internal.WithBoolean(b)\n\tp.TitleTopLeft = false\n\tp.TitleTopRight = false\n\tp.TitleTopCenter = b2\n\tp.TitleBottomLeft = false\n\tp.TitleBottomRight = false\n\tp.TitleBottomCenter = false\n\treturn &p\n}\n\n// WithTitleBottomLeft returns a new box with a specific Title alignment.\nfunc (p BoxPrinter) WithTitleBottomLeft(b ...bool) *BoxPrinter {\n\tb2 := internal.WithBoolean(b)\n\tp.TitleTopLeft = false\n\tp.TitleTopRight = false\n\tp.TitleTopCenter = false\n\tp.TitleBottomLeft = b2\n\tp.TitleBottomRight = false\n\tp.TitleBottomCenter = false\n\treturn &p\n}\n\n// WithTitleBottomRight returns a new box with a specific Title alignment.\nfunc (p BoxPrinter) WithTitleBottomRight(b ...bool) *BoxPrinter {\n\tb2 := internal.WithBoolean(b)\n\tp.TitleTopLeft = false\n\tp.TitleTopRight = false\n\tp.TitleTopCenter = false\n\tp.TitleBottomLeft = false\n\tp.TitleBottomRight = b2\n\tp.TitleBottomCenter = false\n\treturn &p\n}\n\n// WithTitleBottomCenter returns a new box with a specific Title alignment.\nfunc (p BoxPrinter) WithTitleBottomCenter(b ...bool) *BoxPrinter {\n\tb2 := internal.WithBoolean(b)\n\tp.TitleTopLeft = false\n\tp.TitleTopRight = false\n\tp.TitleTopCenter = false\n\tp.TitleBottomLeft = false\n\tp.TitleBottomRight = false\n\tp.TitleBottomCenter = b2\n\treturn &p\n}\n\n// WithBoxStyle returns a new box with a specific box Style.\nfunc (p BoxPrinter) WithBoxStyle(style *Style) *BoxPrinter {\n\tp.BoxStyle = style\n\treturn &p\n}\n\n// WithTextStyle returns a new box with a specific text Style.\nfunc (p BoxPrinter) WithTextStyle(style *Style) *BoxPrinter {\n\tp.TextStyle = style\n\treturn &p\n}\n\n// WithTopRightCornerString returns a new box with a specific TopRightCornerString.\nfunc (p BoxPrinter) WithTopRightCornerString(str string) *BoxPrinter {\n\tp.TopRightCornerString = str\n\treturn &p\n}\n\n// WithTopLeftCornerString returns a new box with a specific TopLeftCornerString.\nfunc (p BoxPrinter) WithTopLeftCornerString(str string) *BoxPrinter {\n\tp.TopLeftCornerString = str\n\treturn &p\n}\n\n// WithBottomRightCornerString returns a new box with a specific BottomRightCornerString.\nfunc (p BoxPrinter) WithBottomRightCornerString(str string) *BoxPrinter {\n\tp.BottomRightCornerString = str\n\treturn &p\n}\n\n// WithBottomLeftCornerString returns a new box with a specific BottomLeftCornerString.\nfunc (p BoxPrinter) WithBottomLeftCornerString(str string) *BoxPrinter {\n\tp.BottomLeftCornerString = str\n\treturn &p\n}\n\n// WithVerticalString returns a new box with a specific VerticalString.\nfunc (p BoxPrinter) WithVerticalString(str string) *BoxPrinter {\n\tp.VerticalString = str\n\treturn &p\n}\n\n// WithHorizontalString returns a new box with a specific HorizontalString.\nfunc (p BoxPrinter) WithHorizontalString(str string) *BoxPrinter {\n\tp.HorizontalString = str\n\treturn &p\n}\n\n// WithTopPadding returns a new box with a specific TopPadding.\nfunc (p BoxPrinter) WithTopPadding(padding int) *BoxPrinter {\n\tif padding < 0 {\n\t\tpadding = 0\n\t}\n\tp.TopPadding = padding\n\treturn &p\n}\n\n// WithBottomPadding returns a new box with a specific BottomPadding.\nfunc (p BoxPrinter) WithBottomPadding(padding int) *BoxPrinter {\n\tif padding < 0 {\n\t\tpadding = 0\n\t}\n\tp.BottomPadding = padding\n\treturn &p\n}\n\n// WithRightPadding returns a new box with a specific RightPadding.\nfunc (p BoxPrinter) WithRightPadding(padding int) *BoxPrinter {\n\tif padding < 0 {\n\t\tpadding = 0\n\t}\n\tp.RightPadding = padding\n\treturn &p\n}\n\n// WithLeftPadding returns a new box with a specific LeftPadding.\nfunc (p BoxPrinter) WithLeftPadding(padding int) *BoxPrinter {\n\tif padding < 0 {\n\t\tpadding = 0\n\t}\n\tp.LeftPadding = padding\n\treturn &p\n}\n\n// WithWriter sets the custom Writer.\nfunc (p BoxPrinter) WithWriter(writer io.Writer) *BoxPrinter {\n\tp.Writer = writer\n\treturn &p\n}\n\n// Sprint formats using the default formats for its operands and returns the resulting string.\n// Spaces are added between operands when neither is a string.\nfunc (p BoxPrinter) Sprint(a ...any) string {\n\tif p.BoxStyle == nil {\n\t\tp.BoxStyle = &ThemeDefault.BoxStyle\n\t}\n\tif p.TextStyle == nil {\n\t\tp.TextStyle = &ThemeDefault.BoxTextStyle\n\t}\n\tmaxWidth := internal.GetStringMaxWidth(Sprint(a...))\n\n\tvar topLine string\n\tvar bottomLine string\n\n\tif p.Title == \"\" {\n\t\ttopLine = p.BoxStyle.Sprint(p.BottomRightCornerString) + strings.Repeat(p.BoxStyle.Sprint(p.HorizontalString),\n\t\t\tmaxWidth+p.LeftPadding+p.RightPadding) + p.BoxStyle.Sprint(p.BottomLeftCornerString)\n\t\tbottomLine = p.BoxStyle.Sprint(p.TopRightCornerString) + strings.Repeat(p.BoxStyle.Sprint(p.HorizontalString),\n\t\t\tmaxWidth+p.LeftPadding+p.RightPadding) + p.BoxStyle.Sprint(p.TopLeftCornerString)\n\t} else {\n\t\tp.Title = strings.ReplaceAll(p.Title, \"\\n\", \" \")\n\t\tif (maxWidth + p.RightPadding + p.LeftPadding - 4) < internal.GetStringMaxWidth(p.Title) {\n\t\t\tp.RightPadding = internal.GetStringMaxWidth(p.Title) - (maxWidth + p.RightPadding + p.LeftPadding - 5)\n\t\t}\n\t\tif p.TitleTopLeft {\n\t\t\ttopLine = p.BoxStyle.Sprint(p.BottomRightCornerString) + internal.AddTitleToLine(p.Title, p.BoxStyle.Sprint(p.HorizontalString), maxWidth+p.LeftPadding+p.RightPadding, true) + p.BoxStyle.Sprint(p.BottomLeftCornerString)\n\t\t\tbottomLine = p.BoxStyle.Sprint(p.TopRightCornerString) + strings.Repeat(p.BoxStyle.Sprint(p.HorizontalString),\n\t\t\t\tmaxWidth+p.LeftPadding+p.RightPadding) + p.BoxStyle.Sprint(p.TopLeftCornerString)\n\t\t} else if p.TitleTopRight {\n\t\t\ttopLine = p.BoxStyle.Sprint(p.BottomRightCornerString) + internal.AddTitleToLine(p.Title, p.BoxStyle.Sprint(p.HorizontalString), maxWidth+p.LeftPadding+p.RightPadding, false) + p.BoxStyle.Sprint(p.BottomLeftCornerString)\n\t\t\tbottomLine = p.BoxStyle.Sprint(p.TopRightCornerString) + strings.Repeat(p.BoxStyle.Sprint(p.HorizontalString),\n\t\t\t\tmaxWidth+p.LeftPadding+p.RightPadding) + p.BoxStyle.Sprint(p.TopLeftCornerString)\n\t\t} else if p.TitleTopCenter {\n\t\t\ttopLine = p.BoxStyle.Sprint(p.BottomRightCornerString) + internal.AddTitleToLineCenter(p.Title, p.BoxStyle.Sprint(p.HorizontalString), maxWidth+p.LeftPadding+p.RightPadding) + p.BoxStyle.Sprint(p.BottomLeftCornerString)\n\t\t\tbottomLine = p.BoxStyle.Sprint(p.TopRightCornerString) + strings.Repeat(p.BoxStyle.Sprint(p.HorizontalString),\n\t\t\t\tmaxWidth+p.LeftPadding+p.RightPadding) + p.BoxStyle.Sprint(p.TopLeftCornerString)\n\t\t} else if p.TitleBottomLeft {\n\t\t\ttopLine = p.BoxStyle.Sprint(p.BottomRightCornerString) + strings.Repeat(p.BoxStyle.Sprint(p.HorizontalString),\n\t\t\t\tmaxWidth+p.LeftPadding+p.RightPadding) + p.BoxStyle.Sprint(p.BottomLeftCornerString)\n\t\t\tbottomLine = p.BoxStyle.Sprint(p.TopRightCornerString) + internal.AddTitleToLine(p.Title, p.BoxStyle.Sprint(p.HorizontalString), maxWidth+p.LeftPadding+p.RightPadding, true) + p.BoxStyle.Sprint(p.TopLeftCornerString)\n\t\t} else if p.TitleBottomRight {\n\t\t\ttopLine = p.BoxStyle.Sprint(p.BottomRightCornerString) + strings.Repeat(p.BoxStyle.Sprint(p.HorizontalString),\n\t\t\t\tmaxWidth+p.LeftPadding+p.RightPadding) + p.BoxStyle.Sprint(p.BottomLeftCornerString)\n\t\t\tbottomLine = p.BoxStyle.Sprint(p.TopRightCornerString) + internal.AddTitleToLine(p.Title, p.BoxStyle.Sprint(p.HorizontalString), maxWidth+p.LeftPadding+p.RightPadding, false) + p.BoxStyle.Sprint(p.TopLeftCornerString)\n\t\t} else if p.TitleBottomCenter {\n\t\t\ttopLine = p.BoxStyle.Sprint(p.BottomRightCornerString) + strings.Repeat(p.BoxStyle.Sprint(p.HorizontalString),\n\t\t\t\tmaxWidth+p.LeftPadding+p.RightPadding) + p.BoxStyle.Sprint(p.BottomLeftCornerString)\n\t\t\tbottomLine = p.BoxStyle.Sprint(p.TopRightCornerString) + internal.AddTitleToLineCenter(p.Title, p.BoxStyle.Sprint(p.HorizontalString), maxWidth+p.LeftPadding+p.RightPadding) + p.BoxStyle.Sprint(p.TopLeftCornerString)\n\t\t}\n\t}\n\n\tboxString := strings.Repeat(\"\\n\", p.TopPadding) + Sprint(a...) + strings.Repeat(\"\\n\", p.BottomPadding)\n\n\tss := strings.Split(boxString, \"\\n\")\n\tfor i, s2 := range ss {\n\t\tif runewidth.StringWidth(RemoveColorFromString(s2)) < maxWidth {\n\t\t\tss[i] = p.BoxStyle.Sprint(p.VerticalString) + strings.Repeat(\" \", p.LeftPadding) + p.TextStyle.Sprint(s2) +\n\t\t\t\tstrings.Repeat(\" \", maxWidth-runewidth.StringWidth(RemoveColorFromString(s2))+p.RightPadding) +\n\t\t\t\tp.BoxStyle.Sprint(p.VerticalString)\n\t\t} else {\n\t\t\tss[i] = p.BoxStyle.Sprint(p.VerticalString) + strings.Repeat(\" \", p.LeftPadding) + p.TextStyle.Sprint(s2) +\n\t\t\t\tstrings.Repeat(\" \", p.RightPadding) + p.BoxStyle.Sprint(p.VerticalString)\n\t\t}\n\t}\n\treturn topLine + \"\\n\" + strings.Join(ss, \"\\n\") + \"\\n\" + bottomLine\n}\n\n// Sprintln formats using the default formats for its operands and returns the resulting string.\n// Spaces are always added between operands and a newline is appended.\nfunc (p BoxPrinter) Sprintln(a ...any) string {\n\treturn p.Sprint(strings.TrimSuffix(Sprintln(a...), \"\\n\")) + \"\\n\"\n}\n\n// Sprintf formats according to a format specifier and returns the resulting string.\nfunc (p BoxPrinter) Sprintf(format string, a ...any) string {\n\treturn p.Sprint(Sprintf(format, a...))\n}\n\n// Sprintfln formats according to a format specifier and returns the resulting string.\n// Spaces are always added between operands and a newline is appended.\nfunc (p BoxPrinter) Sprintfln(format string, a ...any) string {\n\treturn p.Sprintf(format, a...) + \"\\n\"\n}\n\n// Print formats using the default formats for its operands and writes to standard output.\n// Spaces are added between operands when neither is a string.\n// It returns the number of bytes written and any write error encountered.\nfunc (p BoxPrinter) Print(a ...any) *TextPrinter {\n\tFprint(p.Writer, p.Sprint(a...))\n\ttp := TextPrinter(p)\n\treturn &tp\n}\n\n// Println formats using the default formats for its operands and writes to standard output.\n// Spaces are always added between operands and a newline is appended.\n// It returns the number of bytes written and any write error encountered.\nfunc (p BoxPrinter) Println(a ...any) *TextPrinter {\n\tFprint(p.Writer, p.Sprintln(a...))\n\ttp := TextPrinter(p)\n\treturn &tp\n}\n\n// Printf formats according to a format specifier and writes to standard output.\n// It returns the number of bytes written and any write error encountered.\nfunc (p BoxPrinter) Printf(format string, a ...any) *TextPrinter {\n\tFprint(p.Writer, p.Sprintf(format, a...))\n\ttp := TextPrinter(p)\n\treturn &tp\n}\n\n// Printfln formats according to a format specifier and writes to standard output.\n// Spaces are always added between operands and a newline is appended.\n// It returns the number of bytes written and any write error encountered.\nfunc (p BoxPrinter) Printfln(format string, a ...any) *TextPrinter {\n\tFprint(p.Writer, p.Sprintfln(format, a...))\n\ttp := TextPrinter(p)\n\treturn &tp\n}\n\n// PrintOnError prints every error which is not nil.\n// If every error is nil, nothing will be printed.\n// This can be used for simple error checking.\nfunc (p BoxPrinter) PrintOnError(a ...any) *TextPrinter {\n\tfor _, arg := range a {\n\t\tif err, ok := arg.(error); ok {\n\t\t\tif err != nil {\n\t\t\t\tp.Println(err)\n\t\t\t}\n\t\t}\n\t}\n\n\ttp := TextPrinter(p)\n\treturn &tp\n}\n\n// PrintOnErrorf wraps every error which is not nil and prints it.\n// If every error is nil, nothing will be printed.\n// This can be used for simple error checking.\nfunc (p BoxPrinter) PrintOnErrorf(format string, a ...any) *TextPrinter {\n\tfor _, arg := range a {\n\t\tif err, ok := arg.(error); ok {\n\t\t\tif err != nil {\n\t\t\t\tp.Println(fmt.Errorf(format, err))\n\t\t\t}\n\t\t}\n\t}\n\n\ttp := TextPrinter(p)\n\treturn &tp\n}\n"
        },
        {
          "name": "box_printer_test.go",
          "type": "blob",
          "size": 8.41796875,
          "content": "package pterm_test\n\nimport (\n\t\"errors\"\n\t\"io\"\n\t\"os\"\n\t\"testing\"\n\n\t\"github.com/MarvinJWendt/testza\"\n\n\t\"github.com/pterm/pterm\"\n)\n\nfunc TestBoxPrinterNilPrint(t *testing.T) {\n\tp := pterm.BoxPrinter{}\n\tp.Println(\"Hello, World!\")\n}\n\nfunc TestBoxPrinterPrintMethods(t *testing.T) {\n\tp := pterm.DefaultBox\n\n\tt.Run(\"Print\", func(t *testing.T) {\n\t\ttestPrintContains(t, func(w io.Writer, a any) {\n\t\t\tp.Print(a)\n\t\t})\n\t})\n\n\tt.Run(\"Printf\", func(t *testing.T) {\n\t\ttestPrintfContains(t, func(w io.Writer, format string, a any) {\n\t\t\tp.Printf(format, a)\n\t\t})\n\t})\n\n\tt.Run(\"Printfln\", func(t *testing.T) {\n\t\ttestPrintflnContains(t, func(w io.Writer, format string, a any) {\n\t\t\tp.Printfln(format, a)\n\t\t})\n\t})\n\n\tt.Run(\"Println\", func(t *testing.T) {\n\t\ttestPrintlnContains(t, func(w io.Writer, a any) {\n\t\t\tp.Println(a)\n\t\t})\n\t})\n\n\tt.Run(\"Sprint\", func(t *testing.T) {\n\t\ttestSprintContains(t, func(a any) string {\n\t\t\treturn p.Sprint(a)\n\t\t})\n\t})\n\n\tt.Run(\"SprintWithTitle\", func(t *testing.T) {\n\t\ttestSprintContains(t, func(a any) string {\n\t\t\treturn p.WithTitle(\"a\").Sprint(a)\n\t\t})\n\t})\n\n\tt.Run(\"Sprintf\", func(t *testing.T) {\n\t\ttestSprintfContains(t, func(format string, a any) string {\n\t\t\treturn p.Sprintf(format, a)\n\t\t})\n\t})\n\n\tt.Run(\"Sprintfln\", func(t *testing.T) {\n\t\ttestSprintflnContains(t, func(format string, a any) string {\n\t\t\treturn p.Sprintfln(format, a)\n\t\t})\n\t})\n\n\tt.Run(\"Sprintln\", func(t *testing.T) {\n\t\ttestSprintlnContains(t, func(a any) string {\n\t\t\treturn p.Sprintln(a)\n\t\t})\n\t})\n\n\tt.Run(\"SprintMultipleLines\", func(t *testing.T) {\n\t\ttestSprintContains(t, func(a any) string {\n\t\t\treturn p.Sprint(\"testing\\ntesting2\" + pterm.Sprint(a))\n\t\t})\n\t})\n\n\tt.Run(\"PrintOnError\", func(t *testing.T) {\n\t\tresult := captureStdout(func(w io.Writer) {\n\t\t\tp.PrintOnError(errors.New(\"hello world\"))\n\t\t})\n\t\ttestza.AssertContains(t, result, \"hello world\")\n\t})\n\n\tt.Run(\"PrintIfError_WithoutError\", func(t *testing.T) {\n\t\tresult := captureStdout(func(w io.Writer) {\n\t\t\tp.PrintOnError(nil)\n\t\t})\n\t\ttestza.AssertZero(t, result)\n\t})\n\n\tt.Run(\"PrintOnErrorf\", func(t *testing.T) {\n\t\tresult := captureStdout(func(w io.Writer) {\n\t\t\tp.PrintOnErrorf(\"wrapping error : %w\", errors.New(\"hello world\"))\n\t\t})\n\t\ttestza.AssertContains(t, result, \"hello world\")\n\t})\n\n\tt.Run(\"PrintIfError_WithoutErrorf\", func(t *testing.T) {\n\t\tresult := captureStdout(func(w io.Writer) {\n\t\t\tp.PrintOnErrorf(\"\", nil)\n\t\t})\n\t\ttestza.AssertZero(t, result)\n\t})\n}\n\nfunc TestBoxPrinter_WithBottomLeftCornerString(t *testing.T) {\n\tp := pterm.BoxPrinter{}\n\tp2 := p.WithBottomLeftCornerString(\"-\")\n\n\ttestza.AssertEqual(t, \"-\", p2.BottomLeftCornerString)\n\ttestza.AssertZero(t, p.BottomLeftCornerString)\n}\n\nfunc TestBoxPrinter_WithBottomPadding(t *testing.T) {\n\tp := pterm.BoxPrinter{}\n\tp2 := p.WithBottomPadding(5)\n\n\ttestza.AssertEqual(t, 5, p2.BottomPadding)\n\ttestza.AssertZero(t, p.BottomPadding)\n}\n\nfunc TestBoxPrinter_WithBottomRightCornerString(t *testing.T) {\n\tp := pterm.BoxPrinter{}\n\tp2 := p.WithBottomRightCornerString(\"-\")\n\n\ttestza.AssertEqual(t, \"-\", p2.BottomRightCornerString)\n\ttestza.AssertZero(t, p.BottomRightCornerString)\n}\n\nfunc TestBoxPrinter_WithTitle(t *testing.T) {\n\tp := pterm.BoxPrinter{}\n\tp2 := p.WithTitle(\"-\")\n\n\ttestza.AssertEqual(t, \"-\", p2.Title)\n\ttestza.AssertZero(t, p.Title)\n}\n\nfunc TestBoxPrinter_WithTitleTopLeft(t *testing.T) {\n\tp := pterm.BoxPrinter{}\n\tp2 := p.WithTitleTopLeft()\n\n\ttestza.AssertEqual(t, true, p2.TitleTopLeft)\n\ttestza.AssertEqual(t, false, p.TitleTopLeft)\n}\n\nfunc TestBoxPrinter_WithTitleTopRight(t *testing.T) {\n\tp := pterm.BoxPrinter{}\n\tp2 := p.WithTitleTopRight()\n\n\ttestza.AssertEqual(t, true, p2.TitleTopRight)\n\ttestza.AssertEqual(t, false, p.TitleTopRight)\n}\n\nfunc TestBoxPrinter_WithTitleTopCenter(t *testing.T) {\n\tp := pterm.BoxPrinter{}\n\tp2 := p.WithTitleTopCenter()\n\n\ttestza.AssertEqual(t, true, p2.TitleTopCenter)\n\ttestza.AssertEqual(t, false, p.TitleTopCenter)\n}\n\nfunc TestBoxPrinter_WithTitleBottomRight(t *testing.T) {\n\tp := pterm.BoxPrinter{}\n\tp2 := p.WithTitleBottomRight()\n\n\ttestza.AssertEqual(t, true, p2.TitleBottomRight)\n\ttestza.AssertEqual(t, false, p.TitleBottomRight)\n}\n\nfunc TestBoxPrinter_WithTitleBottomLeft(t *testing.T) {\n\tp := pterm.BoxPrinter{}\n\tp2 := p.WithTitleBottomLeft()\n\n\ttestza.AssertEqual(t, true, p2.TitleBottomLeft)\n\ttestza.AssertEqual(t, false, p.TitleBottomLeft)\n}\n\nfunc TestBoxPrinter_WithTitleBottomCenter(t *testing.T) {\n\tp := pterm.BoxPrinter{}\n\tp2 := p.WithTitleBottomCenter()\n\n\ttestza.AssertEqual(t, true, p2.TitleBottomCenter)\n\ttestza.AssertEqual(t, false, p.TitleBottomCenter)\n}\n\nfunc TestBoxPrinter_WithTitleWithTitleBottomLeft(t *testing.T) {\n\tp := pterm.BoxPrinter{}\n\tp2 := p.WithTitleBottomLeft().WithTitle(\"a\").Sprint(\"Lorem Ipsum\")\n\n\ttestza.AssertContains(t, p2, \"Lorem Ipsum\")\n}\n\nfunc TestBoxPrinter_WithTitleWithTitleTopLeft(t *testing.T) {\n\tp := pterm.BoxPrinter{}\n\tp2 := p.WithTitleTopLeft().WithTitle(\"a\").Sprint(\"Lorem Ipsum\")\n\n\ttestza.AssertContains(t, p2, \"Lorem Ipsum\")\n}\n\nfunc TestBoxPrinter_WithTitleWithTitleBottomRight(t *testing.T) {\n\tp := pterm.BoxPrinter{}\n\tp2 := p.WithTitleBottomRight().WithTitle(\"a\").Sprint(\"Lorem Ipsum\")\n\n\ttestza.AssertContains(t, p2, \"Lorem Ipsum\")\n}\n\nfunc TestBoxPrinter_WithTitleWithTitleTopRight(t *testing.T) {\n\tp := pterm.BoxPrinter{}\n\tp2 := p.WithTitleTopRight().WithTitle(\"a\").Sprint(\"Lorem Ipsum\")\n\n\ttestza.AssertContains(t, p2, \"Lorem Ipsum\")\n}\n\nfunc TestBoxPrinter_WithTitleWithTitleTopCenter(t *testing.T) {\n\tp := pterm.BoxPrinter{}\n\tp2 := p.WithTitleTopCenter().WithTitle(\"a\").Sprint(\"Lorem Ipsum\")\n\n\ttestza.AssertContains(t, p2, \"Lorem Ipsum\")\n}\n\nfunc TestBoxPrinter_WithTitleWithTitleBottomCenter(t *testing.T) {\n\tp := pterm.BoxPrinter{}\n\tp2 := p.WithTitleBottomCenter().WithTitle(\"a\").Sprint(\"Lorem Ipsum\")\n\n\ttestza.AssertContains(t, p2, \"Lorem Ipsum\")\n}\n\nfunc TestBoxPrinter_WithBoxStyle(t *testing.T) {\n\tp := pterm.BoxPrinter{}\n\ts := pterm.NewStyle(pterm.FgRed, pterm.BgRed, pterm.Bold)\n\tp2 := p.WithBoxStyle(s)\n\n\ttestza.AssertEqual(t, s, p2.BoxStyle)\n\ttestza.AssertZero(t, p.BoxStyle)\n}\n\nfunc TestBoxPrinter_WithLeftPadding(t *testing.T) {\n\tp := pterm.BoxPrinter{}\n\tp2 := p.WithLeftPadding(5)\n\n\ttestza.AssertEqual(t, 5, p2.LeftPadding)\n\ttestza.AssertZero(t, p.LeftPadding)\n}\n\nfunc TestBoxPrinter_WithRightPadding(t *testing.T) {\n\tp := pterm.BoxPrinter{}\n\tp2 := p.WithRightPadding(5)\n\n\ttestza.AssertEqual(t, 5, p2.RightPadding)\n\ttestza.AssertZero(t, p.RightPadding)\n}\n\nfunc TestBoxPrinter_WithTextStyle(t *testing.T) {\n\tp := pterm.BoxPrinter{}\n\ts := pterm.NewStyle(pterm.FgRed, pterm.BgRed, pterm.Bold)\n\tp2 := p.WithTextStyle(s)\n\n\ttestza.AssertEqual(t, s, p2.TextStyle)\n\ttestza.AssertZero(t, p.TextStyle)\n}\n\nfunc TestBoxPrinter_WithTopLeftCornerString(t *testing.T) {\n\tp := pterm.BoxPrinter{}\n\tp2 := p.WithTopLeftCornerString(\"-\")\n\n\ttestza.AssertEqual(t, \"-\", p2.TopLeftCornerString)\n\ttestza.AssertZero(t, p.TopLeftCornerString)\n}\n\nfunc TestBoxPrinter_WithTopPadding(t *testing.T) {\n\tp := pterm.BoxPrinter{}\n\tp2 := p.WithTopPadding(5)\n\n\ttestza.AssertEqual(t, 5, p2.TopPadding)\n\ttestza.AssertZero(t, p.TopPadding)\n}\n\nfunc TestBoxPrinter_WithInvalidTopPadding(t *testing.T) {\n\tp := pterm.BoxPrinter{}\n\tp2 := p.WithTopPadding(-5)\n\n\ttestza.AssertEqual(t, 0, p2.TopPadding)\n\ttestza.AssertZero(t, p.TopPadding)\n}\n\nfunc TestBoxPrinter_WithInvalidBottomPadding(t *testing.T) {\n\tp := pterm.BoxPrinter{}\n\tp2 := p.WithBottomPadding(-5)\n\n\ttestza.AssertEqual(t, 0, p2.BottomPadding)\n\ttestza.AssertZero(t, p.BottomPadding)\n}\n\nfunc TestBoxPrinter_WithInvalidLeftPadding(t *testing.T) {\n\tp := pterm.BoxPrinter{}\n\tp2 := p.WithLeftPadding(-5)\n\n\ttestza.AssertEqual(t, 0, p2.LeftPadding)\n\ttestza.AssertZero(t, p.LeftPadding)\n}\n\nfunc TestBoxPrinter_WithInvalidRightPadding(t *testing.T) {\n\tp := pterm.BoxPrinter{}\n\tp2 := p.WithRightPadding(-5)\n\n\ttestza.AssertEqual(t, 0, p2.RightPadding)\n\ttestza.AssertZero(t, p.RightPadding)\n}\n\nfunc TestBoxPrinter_WithTopRightCornerString(t *testing.T) {\n\tp := pterm.BoxPrinter{}\n\tp2 := p.WithTopRightCornerString(\"-\")\n\n\ttestza.AssertEqual(t, \"-\", p2.TopRightCornerString)\n\ttestza.AssertZero(t, p.TopRightCornerString)\n}\n\nfunc TestBoxPrinter_WithVerticalString(t *testing.T) {\n\tp := pterm.BoxPrinter{}\n\tp2 := p.WithVerticalString(\"-\")\n\n\ttestza.AssertEqual(t, \"-\", p2.VerticalString)\n\ttestza.AssertZero(t, p.VerticalString)\n}\n\nfunc TestBoxPrinter_WithHorizontalString(t *testing.T) {\n\tp := pterm.BoxPrinter{}\n\tp2 := p.WithHorizontalString(\"-\")\n\n\ttestza.AssertEqual(t, \"-\", p2.HorizontalString)\n\ttestza.AssertZero(t, p.HorizontalString)\n}\n\nfunc TestBoxPrinter_WithWriter(t *testing.T) {\n\tp := pterm.BoxPrinter{}\n\ts := os.Stderr\n\tp2 := p.WithWriter(s)\n\n\ttestza.AssertEqual(t, s, p2.Writer)\n\ttestza.AssertZero(t, p.Writer)\n}\n"
        },
        {
          "name": "bulletlist_printer.go",
          "type": "blob",
          "size": 3.466796875,
          "content": "package pterm\n\nimport (\n\t\"io\"\n\t\"strings\"\n)\n\n// BulletListItem is able to render a ListItem.\ntype BulletListItem struct {\n\tLevel       int\n\tText        string\n\tTextStyle   *Style\n\tBullet      string\n\tBulletStyle *Style\n}\n\n// WithLevel returns a new BulletListItem with a specific Level.\nfunc (p BulletListItem) WithLevel(level int) *BulletListItem {\n\tp.Level = level\n\treturn &p\n}\n\n// WithText returns a new BulletListItem with a specific Text.\nfunc (p BulletListItem) WithText(text string) *BulletListItem {\n\tp.Text = text\n\treturn &p\n}\n\n// WithTextStyle returns a new BulletListItem with a specific TextStyle.\nfunc (p BulletListItem) WithTextStyle(style *Style) *BulletListItem {\n\tp.TextStyle = style\n\treturn &p\n}\n\n// WithBullet returns a new BulletListItem with a specific Prefix.\nfunc (p BulletListItem) WithBullet(bullet string) *BulletListItem {\n\tp.Bullet = bullet\n\treturn &p\n}\n\n// WithBulletStyle returns a new BulletListItem with a specific BulletStyle.\nfunc (p BulletListItem) WithBulletStyle(style *Style) *BulletListItem {\n\tp.BulletStyle = style\n\treturn &p\n}\n\n// DefaultBulletList contains standards, which can be used to print a BulletListPrinter.\nvar DefaultBulletList = BulletListPrinter{\n\tBullet:      \"•\",\n\tTextStyle:   &ThemeDefault.BulletListTextStyle,\n\tBulletStyle: &ThemeDefault.BulletListBulletStyle,\n}\n\n// BulletListPrinter is able to render a list.\ntype BulletListPrinter struct {\n\tItems       []BulletListItem\n\tTextStyle   *Style\n\tBullet      string\n\tBulletStyle *Style\n\tWriter      io.Writer\n}\n\n// WithItems returns a new list with specific Items.\nfunc (l BulletListPrinter) WithItems(items []BulletListItem) *BulletListPrinter {\n\tl.Items = append(l.Items, items...)\n\treturn &l\n}\n\n// WithTextStyle returns a new list with a specific text style.\nfunc (l BulletListPrinter) WithTextStyle(style *Style) *BulletListPrinter {\n\tl.TextStyle = style\n\treturn &l\n}\n\n// WithBullet returns a new list with a specific bullet.\nfunc (l BulletListPrinter) WithBullet(bullet string) *BulletListPrinter {\n\tl.Bullet = bullet\n\treturn &l\n}\n\n// WithBulletStyle returns a new list with a specific bullet style.\nfunc (l BulletListPrinter) WithBulletStyle(style *Style) *BulletListPrinter {\n\tl.BulletStyle = style\n\treturn &l\n}\n\n// WithWriter sets the custom Writer.\nfunc (l BulletListPrinter) WithWriter(writer io.Writer) *BulletListPrinter {\n\tl.Writer = writer\n\treturn &l\n}\n\n// Render prints the list to the terminal.\nfunc (l BulletListPrinter) Render() error {\n\ts, _ := l.Srender()\n\tFprintln(l.Writer, s)\n\n\treturn nil\n}\n\n// Srender renders the list as a string.\nfunc (l BulletListPrinter) Srender() (string, error) {\n\tvar ret strings.Builder\n\tfor _, item := range l.Items {\n\t\tif item.TextStyle == nil {\n\t\t\tif l.TextStyle == nil {\n\t\t\t\titem.TextStyle = &ThemeDefault.BulletListTextStyle\n\t\t\t} else {\n\t\t\t\titem.TextStyle = l.TextStyle\n\t\t\t}\n\t\t}\n\t\tif item.BulletStyle == nil {\n\t\t\tif l.BulletStyle == nil {\n\t\t\t\titem.BulletStyle = &ThemeDefault.BulletListBulletStyle\n\t\t\t} else {\n\t\t\t\titem.BulletStyle = l.BulletStyle\n\t\t\t}\n\t\t}\n\n\t\tsplit := strings.Split(item.Text, \"\\n\")\n\t\tfor i, line := range split {\n\t\t\tret.WriteString(strings.Repeat(\" \", item.Level))\n\t\t\tif i == 0 {\n\t\t\t\tif item.Bullet == \"\" {\n\t\t\t\t\tret.WriteString(item.BulletStyle.Sprint(l.Bullet))\n\t\t\t\t} else {\n\t\t\t\t\tret.WriteString(item.BulletStyle.Sprint(item.Bullet))\n\t\t\t\t}\n\t\t\t\tret.WriteByte(' ')\n\t\t\t} else {\n\t\t\t\tret.WriteString(strings.Repeat(\" \", len(item.Bullet)))\n\t\t\t\tret.WriteString(\"  \")\n\t\t\t}\n\t\t\tret.WriteString(item.TextStyle.Sprint(line))\n\t\t\tret.WriteByte('\\n')\n\t\t}\n\t}\n\treturn ret.String(), nil\n}\n"
        },
        {
          "name": "bulletlist_printer_test.go",
          "type": "blob",
          "size": 3.7080078125,
          "content": "package pterm_test\n\nimport (\n\t\"fmt\"\n\t\"io\"\n\t\"os\"\n\t\"testing\"\n\n\t\"github.com/MarvinJWendt/testza\"\n\t\"github.com/pterm/pterm\"\n)\n\nfunc TestBulletListPrinterNilPrint(t *testing.T) {\n\tp := pterm.BulletListPrinter{}\n\tp.Render()\n}\n\nfunc TestBulletListPrinter_Render(t *testing.T) {\n\ttestPrintContains(t, func(w io.Writer, a any) {\n\t\tpterm.DefaultBulletList.WithItems([]pterm.BulletListItem{\n\t\t\t{Level: 0, Text: fmt.Sprint(a)},\n\t\t}).Render()\n\t})\n}\n\nfunc TestBulletListPrinter_RenderWithoutStyle(t *testing.T) {\n\ttestPrintContains(t, func(w io.Writer, a any) {\n\t\tpterm.BulletListPrinter{}.WithItems([]pterm.BulletListItem{\n\t\t\t{Level: 0, Text: fmt.Sprint(a)},\n\t\t}).Render()\n\t})\n}\n\nfunc TestBulletListPrinter_RenderWithBullet(t *testing.T) {\n\ttestPrintContains(t, func(w io.Writer, a any) {\n\t\tpterm.DefaultBulletList.WithItems([]pterm.BulletListItem{\n\t\t\t{\n\t\t\t\tLevel:  0,\n\t\t\t\tText:   fmt.Sprint(a),\n\t\t\t\tBullet: \"-\",\n\t\t\t},\n\t\t}).Render()\n\t})\n}\n\nfunc TestBulletListPrinter_Srender(t *testing.T) {\n\ttestSprintContainsWithoutError(t, func(a any) (string, error) {\n\t\treturn pterm.DefaultBulletList.WithItems([]pterm.BulletListItem{\n\t\t\t{Level: 0, Text: fmt.Sprint(a)},\n\t\t}).Srender()\n\t})\n}\n\nfunc TestBulletListPrinter_WithBullet(t *testing.T) {\n\tp := pterm.BulletListPrinter{}\n\tp2 := p.WithBullet(\"-\")\n\n\ttestza.AssertEqual(t, \"-\", p2.Bullet)\n\ttestza.AssertZero(t, p.Bullet)\n}\n\nfunc TestBulletListPrinter_WithBulletStyle(t *testing.T) {\n\tp := pterm.BulletListPrinter{}\n\ts := pterm.NewStyle(pterm.FgRed, pterm.BgRed, pterm.Bold)\n\tp2 := p.WithBulletStyle(s)\n\n\ttestza.AssertEqual(t, s, p2.BulletStyle)\n\ttestza.AssertZero(t, p.BulletStyle)\n}\n\nfunc TestBulletListPrinter_WithItems(t *testing.T) {\n\tp := pterm.BulletListPrinter{}\n\tli := []pterm.BulletListItem{{\n\t\tLevel:       0,\n\t\tText:        \"test\",\n\t\tTextStyle:   nil,\n\t\tBullet:      \"+\",\n\t\tBulletStyle: nil,\n\t}}\n\tp2 := p.WithItems(li)\n\n\ttestza.AssertEqual(t, li, p2.Items)\n\ttestza.AssertZero(t, p.Items)\n}\n\nfunc TestBulletListPrinter_WithTextStyle(t *testing.T) {\n\tp := pterm.BulletListPrinter{}\n\ts := pterm.NewStyle(pterm.FgRed, pterm.BgRed, pterm.Bold)\n\tp2 := p.WithTextStyle(s)\n\n\ttestza.AssertEqual(t, s, p2.TextStyle)\n\ttestza.AssertZero(t, p.TextStyle)\n}\n\nfunc TestBulletListItem_WithBullet(t *testing.T) {\n\tp := pterm.BulletListItem{}\n\tp2 := p.WithBullet(\"-\")\n\n\ttestza.AssertEqual(t, \"-\", p2.Bullet)\n\ttestza.AssertZero(t, p.Bullet)\n}\n\nfunc TestBulletListItem_WithBulletStyle(t *testing.T) {\n\tp := pterm.BulletListItem{}\n\ts := pterm.NewStyle(pterm.FgRed, pterm.BgRed, pterm.Bold)\n\tp2 := p.WithBulletStyle(s)\n\n\ttestza.AssertEqual(t, s, p2.BulletStyle)\n\ttestza.AssertZero(t, p.BulletStyle)\n}\n\nfunc TestBulletListItem_WithLevel(t *testing.T) {\n\tp := pterm.BulletListItem{}\n\tp2 := p.WithLevel(1)\n\n\ttestza.AssertEqual(t, 1, p2.Level)\n\ttestza.AssertZero(t, p.Level)\n}\n\nfunc TestBulletListItem_WithText(t *testing.T) {\n\tp := pterm.BulletListItem{}\n\tp2 := p.WithText(\"test\")\n\n\ttestza.AssertEqual(t, \"test\", p2.Text)\n\ttestza.AssertZero(t, p.Text)\n}\n\nfunc TestBulletListItem_WithTextStyle(t *testing.T) {\n\tp := pterm.BulletListItem{}\n\ts := pterm.NewStyle(pterm.FgRed, pterm.BgRed, pterm.Bold)\n\tp2 := p.WithTextStyle(s)\n\n\ttestza.AssertEqual(t, s, p2.TextStyle)\n\ttestza.AssertZero(t, p.TextStyle)\n}\n\nfunc TestNewBulletListFromString(t *testing.T) {\n\tp := *pterm.DefaultBulletList.WithItems([]pterm.BulletListItem{\n\t\t{Level: 0, Text: \"0\"},\n\t\t{Level: 1, Text: \"1\"},\n\t\t{Level: 2, Text: \"2\"},\n\t\t{Level: 3, Text: \"3\"},\n\t\t{Level: 4, Text: \"4\"},\n\t\t{Level: 5, Text: \"5\"},\n\t})\n\n\ts := `0\n 1\n  2\n   3\n    4\n     5`\n\tp2 := pterm.NewBulletListFromString(s, \" \")\n\n\ttestza.AssertEqual(t, p, p2)\n}\n\nfunc TestBulletListPrinter_WithWriter(t *testing.T) {\n\tp := pterm.BulletListPrinter{}\n\ts := os.Stderr\n\tp2 := p.WithWriter(s)\n\n\ttestza.AssertEqual(t, s, p2.Writer)\n\ttestza.AssertZero(t, p.Writer)\n}\n"
        },
        {
          "name": "center_printer.go",
          "type": "blob",
          "size": 4.6630859375,
          "content": "package pterm\n\nimport (\n\t\"fmt\"\n\t\"io\"\n\t\"strings\"\n\n\t\"github.com/mattn/go-runewidth\"\n\n\t\"github.com/pterm/pterm/internal\"\n)\n\n// DefaultCenter is the default CenterPrinter.\nvar DefaultCenter = CenterPrinter{\n\tCenterEachLineSeparately: false,\n}\n\n// CenterPrinter prints centered text.\ntype CenterPrinter struct {\n\tCenterEachLineSeparately bool\n\tWriter                   io.Writer\n}\n\n// WithCenterEachLineSeparately centers each line separately.\nfunc (p CenterPrinter) WithCenterEachLineSeparately(b ...bool) *CenterPrinter {\n\tbt := internal.WithBoolean(b)\n\tp.CenterEachLineSeparately = bt\n\treturn &p\n}\n\n// WithWriter sets the custom Writer.\nfunc (p CenterPrinter) WithWriter(writer io.Writer) *CenterPrinter {\n\tp.Writer = writer\n\treturn &p\n}\n\n// Sprint formats using the default formats for its operands and returns the resulting string.\n// Spaces are added between operands when neither is a string.\nfunc (p CenterPrinter) Sprint(a ...any) string {\n\tif RawOutput {\n\t\treturn Sprint(a...)\n\t}\n\n\tlines := strings.Split(Sprint(a...), \"\\n\")\n\n\tvar ret strings.Builder\n\n\tif p.CenterEachLineSeparately {\n\t\tfor _, line := range lines {\n\t\t\tmargin := (GetTerminalWidth() - runewidth.StringWidth(RemoveColorFromString(line))) / 2\n\t\t\tif margin >= 1 {\n\t\t\t\tret.WriteString(strings.Repeat(\" \", margin))\n\t\t\t}\n\t\t\tret.WriteString(line)\n\t\t\tret.WriteByte('\\n')\n\t\t}\n\t\treturn ret.String()\n\t}\n\n\tvar maxLineWidth int\n\n\tfor _, line := range lines {\n\t\tlineLength := runewidth.StringWidth(RemoveColorFromString(line))\n\t\tif maxLineWidth < lineLength {\n\t\t\tmaxLineWidth = lineLength\n\t\t}\n\t}\n\n\tindent := GetTerminalWidth() - maxLineWidth\n\n\tif indent/2 < 1 {\n\t\tfor _, line := range lines {\n\t\t\tret.WriteString(line)\n\t\t\tret.WriteByte('\\n')\n\t\t}\n\n\t\treturn ret.String()\n\t}\n\n\tfor _, line := range lines {\n\t\tret.WriteString(strings.Repeat(\" \", indent/2))\n\t\tret.WriteString(line)\n\t\tret.WriteByte('\\n')\n\t}\n\n\treturn ret.String()\n}\n\n// Sprintln formats using the default formats for its operands and returns the resulting string.\n// Spaces are always added between operands and a newline is appended.\nfunc (p CenterPrinter) Sprintln(a ...any) string {\n\treturn p.Sprint(Sprintln(a...))\n}\n\n// Sprintf formats according to a format specifier and returns the resulting string.\nfunc (p CenterPrinter) Sprintf(format string, a ...any) string {\n\treturn p.Sprint(Sprintf(format, a...))\n}\n\n// Sprintfln formats according to a format specifier and returns the resulting string.\n// Spaces are always added between operands and a newline is appended.\nfunc (p CenterPrinter) Sprintfln(format string, a ...any) string {\n\treturn p.Sprintf(format, a...) + \"\\n\"\n}\n\n// Print formats using the default formats for its operands and writes to standard output.\n// Spaces are added between operands when neither is a string.\n// It returns the number of bytes written and any write error encountered.\nfunc (p CenterPrinter) Print(a ...any) *TextPrinter {\n\tFprint(p.Writer, p.Sprint(a...))\n\ttp := TextPrinter(p)\n\treturn &tp\n}\n\n// Println formats using the default formats for its operands and writes to standard output.\n// Spaces are always added between operands and a newline is appended.\n// It returns the number of bytes written and any write error encountered.\nfunc (p CenterPrinter) Println(a ...any) *TextPrinter {\n\tFprint(p.Writer, p.Sprintln(a...))\n\ttp := TextPrinter(p)\n\treturn &tp\n}\n\n// Printf formats according to a format specifier and writes to standard output.\n// It returns the number of bytes written and any write error encountered.\nfunc (p CenterPrinter) Printf(format string, a ...any) *TextPrinter {\n\tFprint(p.Writer, p.Sprintf(format, a...))\n\ttp := TextPrinter(p)\n\treturn &tp\n}\n\n// Printfln formats according to a format specifier and writes to standard output.\n// Spaces are always added between operands and a newline is appended.\n// It returns the number of bytes written and any write error encountered.\nfunc (p CenterPrinter) Printfln(format string, a ...any) *TextPrinter {\n\tFprint(p.Writer, p.Sprintfln(format, a...))\n\ttp := TextPrinter(p)\n\treturn &tp\n}\n\n// PrintOnError prints every error which is not nil.\n// If every error is nil, nothing will be printed.\n// This can be used for simple error checking.\nfunc (p CenterPrinter) PrintOnError(a ...any) *TextPrinter {\n\tfor _, arg := range a {\n\t\tif err, ok := arg.(error); ok {\n\t\t\tif err != nil {\n\t\t\t\tp.Println(err)\n\t\t\t}\n\t\t}\n\t}\n\n\ttp := TextPrinter(p)\n\treturn &tp\n}\n\n// PrintOnErrorf wraps every error which is not nil and prints it.\n// If every error is nil, nothing will be printed.\n// This can be used for simple error checking.\nfunc (p CenterPrinter) PrintOnErrorf(format string, a ...any) *TextPrinter {\n\tfor _, arg := range a {\n\t\tif err, ok := arg.(error); ok {\n\t\t\tif err != nil {\n\t\t\t\tp.Println(fmt.Errorf(format, err))\n\t\t\t}\n\t\t}\n\t}\n\n\ttp := TextPrinter(p)\n\treturn &tp\n}\n"
        },
        {
          "name": "center_printer_test.go",
          "type": "blob",
          "size": 3.8388671875,
          "content": "package pterm_test\n\nimport (\n\t\"errors\"\n\t\"io\"\n\t\"os\"\n\t\"testing\"\n\n\t\"github.com/MarvinJWendt/testza\"\n\n\t\"github.com/pterm/pterm\"\n)\n\nfunc TestCenterPrinter_WithCenterEachLineSeparately(t *testing.T) {\n\tp := pterm.CenterPrinter{}\n\tp2 := p.WithCenterEachLineSeparately()\n\n\ttestza.AssertTrue(t, p2.CenterEachLineSeparately)\n\ttestza.AssertFalse(t, p.CenterEachLineSeparately)\n}\n\nfunc TestCenterPrinterPrintMethods(t *testing.T) {\n\tp := pterm.DefaultCenter\n\n\tt.Run(\"Print\", func(t *testing.T) {\n\t\ttestPrintContains(t, func(w io.Writer, a any) {\n\t\t\tp.Print(a)\n\t\t})\n\t})\n\n\tt.Run(\"Printf\", func(t *testing.T) {\n\t\ttestPrintfContains(t, func(w io.Writer, format string, a any) {\n\t\t\tp.Printf(format, a)\n\t\t})\n\t})\n\n\tt.Run(\"Printfln\", func(t *testing.T) {\n\t\ttestPrintflnContains(t, func(w io.Writer, format string, a any) {\n\t\t\tp.Printfln(format, a)\n\t\t})\n\t})\n\n\tt.Run(\"Println\", func(t *testing.T) {\n\t\ttestPrintlnContains(t, func(w io.Writer, a any) {\n\t\t\tp.Println(a)\n\t\t})\n\t})\n\n\tt.Run(\"Sprint\", func(t *testing.T) {\n\t\ttestSprintContains(t, func(a any) string {\n\t\t\treturn p.Sprint(a)\n\t\t})\n\t})\n\n\tt.Run(\"Sprintf\", func(t *testing.T) {\n\t\ttestSprintfContains(t, func(format string, a any) string {\n\t\t\treturn p.Sprintf(format, a)\n\t\t})\n\t})\n\n\tt.Run(\"Sprintfln\", func(t *testing.T) {\n\t\ttestSprintflnContains(t, func(format string, a any) string {\n\t\t\treturn p.Sprintfln(format, a)\n\t\t})\n\t})\n\n\tt.Run(\"Sprintln\", func(t *testing.T) {\n\t\ttestSprintlnContains(t, func(a any) string {\n\t\t\treturn p.Sprintln(a)\n\t\t})\n\t})\n\n\tt.Run(\"PrintOnError\", func(t *testing.T) {\n\t\tresult := captureStdout(func(w io.Writer) {\n\t\t\tp.PrintOnError(errors.New(\"hello world\"))\n\t\t})\n\t\ttestza.AssertContains(t, result, \"hello world\")\n\t})\n\n\tt.Run(\"PrintIfError_WithoutError\", func(t *testing.T) {\n\t\tresult := captureStdout(func(w io.Writer) {\n\t\t\tp.PrintOnError(nil)\n\t\t})\n\t\ttestza.AssertZero(t, result)\n\t})\n\n\tt.Run(\"PrintOnErrorf\", func(t *testing.T) {\n\t\tresult := captureStdout(func(w io.Writer) {\n\t\t\tp.PrintOnErrorf(\"wrapping error : %w\", errors.New(\"hello world\"))\n\t\t})\n\t\ttestza.AssertContains(t, result, \"hello world\")\n\t})\n\n\tt.Run(\"PrintIfError_WithoutErrorf\", func(t *testing.T) {\n\t\tresult := captureStdout(func(w io.Writer) {\n\t\t\tp.PrintOnErrorf(\"\", nil)\n\t\t})\n\t\ttestza.AssertZero(t, result)\n\t})\n}\n\nfunc TestCenterPrinterPrintMethodsCenterSeparately(t *testing.T) {\n\tp := pterm.DefaultCenter.WithCenterEachLineSeparately()\n\n\tt.Run(\"Print\", func(t *testing.T) {\n\t\ttestPrintContains(t, func(w io.Writer, a any) {\n\t\t\tp.Print(a)\n\t\t})\n\t})\n\n\tt.Run(\"Printf\", func(t *testing.T) {\n\t\ttestPrintfContains(t, func(w io.Writer, format string, a any) {\n\t\t\tp.Printf(format, a)\n\t\t})\n\t})\n\n\tt.Run(\"Println\", func(t *testing.T) {\n\t\ttestPrintlnContains(t, func(w io.Writer, a any) {\n\t\t\tp.Println(a)\n\t\t})\n\t})\n\n\tt.Run(\"Sprint\", func(t *testing.T) {\n\t\ttestSprintContains(t, func(a any) string {\n\t\t\treturn p.Sprint(a)\n\t\t})\n\t})\n\n\tt.Run(\"Sprintf\", func(t *testing.T) {\n\t\ttestSprintfContains(t, func(format string, a any) string {\n\t\t\treturn p.Sprintf(format, a)\n\t\t})\n\t})\n\n\tt.Run(\"Sprintln\", func(t *testing.T) {\n\t\ttestSprintlnContains(t, func(a any) string {\n\t\t\treturn p.Sprintln(a)\n\t\t})\n\t})\n}\n\nfunc TestCenterPrinter_SprintLineLongerThanTerminal(t *testing.T) {\n\tp := pterm.DefaultCenter\n\tp2 := p.Sprint(\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\")\n\n\ttestza.AssertContains(t, p2, \"a\")\n}\n\nfunc TestCenterPrinter_SprintLineLongerThanTerminalWithCenterEachLineSeparately(t *testing.T) {\n\tp := pterm.DefaultCenter\n\tp2 := p.WithCenterEachLineSeparately().Sprint(\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\")\n\n\ttestza.AssertContains(t, p2, \"a\")\n}\n\nfunc TestCenterPrinter_WithWriter(t *testing.T) {\n\tp := pterm.CenterPrinter{}\n\ts := os.Stderr\n\tp2 := p.WithWriter(s)\n\n\ttestza.AssertEqual(t, s, p2.Writer)\n\ttestza.AssertZero(t, p.Writer)\n}\n"
        },
        {
          "name": "ci",
          "type": "tree",
          "content": null
        },
        {
          "name": "codecov.yml",
          "type": "blob",
          "size": 0.126953125,
          "content": "coverage:\n  status:\n    project:\n      default:\n        informational: true\n    patch:\n      default:\n        informational: true\n"
        },
        {
          "name": "color.go",
          "type": "blob",
          "size": 10.5087890625,
          "content": "package pterm\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\n\t\"github.com/gookit/color\"\n)\n\n// PrintColor is false if PTerm should not print colored output.\nvar PrintColor = true\n\n// EnableColor enables colors.\nfunc EnableColor() {\n\tcolor.Enable = true\n\tPrintColor = true\n}\n\n// DisableColor disables colors.\nfunc DisableColor() {\n\tcolor.Enable = false\n\tPrintColor = false\n}\n\n// Foreground colors. basic foreground colors 30 - 37.\nconst (\n\tFgBlack Color = iota + 30\n\tFgRed\n\tFgGreen\n\tFgYellow\n\tFgBlue\n\tFgMagenta\n\tFgCyan\n\tFgWhite\n\t// FgDefault revert default FG.\n\tFgDefault Color = 39\n)\n\n// Extra foreground color 90 - 97.\nconst (\n\tFgDarkGray Color = iota + 90\n\tFgLightRed\n\tFgLightGreen\n\tFgLightYellow\n\tFgLightBlue\n\tFgLightMagenta\n\tFgLightCyan\n\tFgLightWhite\n\t// FgGray is an alias of FgDarkGray.\n\tFgGray Color = 90\n)\n\n// Background colors. basic background colors 40 - 47.\nconst (\n\tBgBlack Color = iota + 40\n\tBgRed\n\tBgGreen\n\tBgYellow // BgBrown like yellow\n\tBgBlue\n\tBgMagenta\n\tBgCyan\n\tBgWhite\n\t// BgDefault reverts to the default background.\n\tBgDefault Color = 49\n)\n\n// Extra background color 100 - 107.\nconst (\n\tBgDarkGray Color = iota + 100\n\tBgLightRed\n\tBgLightGreen\n\tBgLightYellow\n\tBgLightBlue\n\tBgLightMagenta\n\tBgLightCyan\n\tBgLightWhite\n\t// BgGray is an alias of BgDarkGray.\n\tBgGray Color = 100\n)\n\n// Option settings.\nconst (\n\tReset Color = iota\n\tBold\n\tFuzzy\n\tItalic\n\tUnderscore\n\tBlink\n\tFastBlink\n\tReverse\n\tConcealed\n\tStrikethrough\n)\n\nvar (\n\t// Red is an alias for FgRed.Sprint.\n\tRed = FgRed.Sprint\n\t// Cyan is an alias for FgCyan.Sprint.\n\tCyan = FgCyan.Sprint\n\t// Gray is an alias for FgGray.Sprint.\n\tGray = FgGray.Sprint\n\t// Blue is an alias for FgBlue.Sprint.\n\tBlue = FgBlue.Sprint\n\t// Black is an alias for FgBlack.Sprint.\n\tBlack = FgBlack.Sprint\n\t// Green is an alias for FgGreen.Sprint.\n\tGreen = FgGreen.Sprint\n\t// White is an alias for FgWhite.Sprint.\n\tWhite = FgWhite.Sprint\n\t// Yellow is an alias for FgYellow.Sprint.\n\tYellow = FgYellow.Sprint\n\t// Magenta is an alias for FgMagenta.Sprint.\n\tMagenta = FgMagenta.Sprint\n\n\t// Normal is an alias for FgDefault.Sprint.\n\tNormal = FgDefault.Sprint\n\n\t// extra light.\n\n\t// LightRed is a shortcut for FgLightRed.Sprint.\n\tLightRed = FgLightRed.Sprint\n\t// LightCyan is a shortcut for FgLightCyan.Sprint.\n\tLightCyan = FgLightCyan.Sprint\n\t// LightBlue is a shortcut for FgLightBlue.Sprint.\n\tLightBlue = FgLightBlue.Sprint\n\t// LightGreen is a shortcut for FgLightGreen.Sprint.\n\tLightGreen = FgLightGreen.Sprint\n\t// LightWhite is a shortcut for FgLightWhite.Sprint.\n\tLightWhite = FgLightWhite.Sprint\n\t// LightYellow is a shortcut for FgLightYellow.Sprint.\n\tLightYellow = FgLightYellow.Sprint\n\t// LightMagenta is a shortcut for FgLightMagenta.Sprint.\n\tLightMagenta = FgLightMagenta.Sprint\n)\n\n// Color is a number which will be used to color strings in the terminal.\ntype Color uint8\n\n// Sprintln formats using the default formats for its operands and returns the resulting string.\n// Spaces are always added between operands and a newline is appended.\n// Input will be colored with the parent Color.\nfunc (c Color) Sprintln(a ...any) string {\n\tstr := fmt.Sprintln(a...)\n\treturn c.Sprint(str)\n}\n\n// Sprint formats using the default formats for its operands and returns the resulting string.\n// Spaces are added between operands when neither is a string.\n// Input will be colored with the parent Color.\nfunc (c Color) Sprint(a ...any) string {\n\tmessage := Sprint(a...)\n\tmessageLines := strings.Split(message, \"\\n\")\n\tfor i, line := range messageLines {\n\t\tmessageLines[i] = color.RenderCode(c.String(), strings.ReplaceAll(line, color.ResetSet, Sprintf(\"\\x1b[0m\\u001B[%sm\", c.String())))\n\t}\n\tmessage = strings.Join(messageLines, \"\\n\")\n\treturn message\n}\n\n// Sprintf formats according to a format specifier and returns the resulting string.\n// Input will be colored with the parent Color.\nfunc (c Color) Sprintf(format string, a ...any) string {\n\treturn c.Sprint(Sprintf(format, a...))\n}\n\n// Sprintfln formats according to a format specifier and returns the resulting string.\n// Spaces are always added between operands and a newline is appended.\n// Input will be colored with the parent Color.\nfunc (c Color) Sprintfln(format string, a ...any) string {\n\treturn c.Sprint(Sprintf(format, a...) + \"\\n\")\n}\n\n// Println formats using the default formats for its operands and writes to standard output.\n// Spaces are always added between operands and a newline is appended.\n// It returns the number of bytes written and any write error encountered.\n// Input will be colored with the parent Color.\nfunc (c Color) Println(a ...any) *TextPrinter {\n\tPrint(c.Sprintln(a...))\n\ttc := TextPrinter(c)\n\treturn &tc\n}\n\n// Print formats using the default formats for its operands and writes to standard output.\n// Spaces are added between operands when neither is a string.\n// It returns the number of bytes written and any write error encountered.\n// Input will be colored with the parent Color.\nfunc (c Color) Print(a ...any) *TextPrinter {\n\tPrint(c.Sprint(a...))\n\ttc := TextPrinter(c)\n\treturn &tc\n}\n\n// Printf formats according to a format specifier and writes to standard output.\n// It returns the number of bytes written and any write error encountered.\n// Input will be colored with the parent Color.\nfunc (c Color) Printf(format string, a ...any) *TextPrinter {\n\tPrint(c.Sprintf(format, a...))\n\ttc := TextPrinter(c)\n\treturn &tc\n}\n\n// Printfln formats according to a format specifier and writes to standard output.\n// Spaces are always added between operands and a newline is appended.\n// It returns the number of bytes written and any write error encountered.\n// Input will be colored with the parent Color.\nfunc (c Color) Printfln(format string, a ...any) *TextPrinter {\n\tPrint(c.Sprintfln(format, a...))\n\ttp := TextPrinter(c)\n\treturn &tp\n}\n\n// PrintOnError prints every error which is not nil.\n// If every error is nil, nothing will be printed.\n// This can be used for simple error checking.\nfunc (c Color) PrintOnError(a ...any) *TextPrinter {\n\tfor _, arg := range a {\n\t\tif err, ok := arg.(error); ok {\n\t\t\tif err != nil {\n\t\t\t\tc.Println(err)\n\t\t\t}\n\t\t}\n\t}\n\n\ttp := TextPrinter(c)\n\treturn &tp\n}\n\n// PrintOnErrorf wraps every error which is not nil and prints it.\n// If every error is nil, nothing will be printed.\n// This can be used for simple error checking.\nfunc (c Color) PrintOnErrorf(format string, a ...any) *TextPrinter {\n\tfor _, arg := range a {\n\t\tif err, ok := arg.(error); ok {\n\t\t\tif err != nil {\n\t\t\t\tc.Println(fmt.Errorf(format, err))\n\t\t\t}\n\t\t}\n\t}\n\n\ttp := TextPrinter(c)\n\treturn &tp\n}\n\n// String converts the color to a string. eg \"35\".\nfunc (c Color) String() string {\n\treturn fmt.Sprintf(\"%d\", c)\n}\n\n// ToStyle converts the color to a style.\nfunc (c Color) ToStyle() *Style {\n\treturn &Style{c}\n}\n\n// Style is a collection of colors.\n// Can include foreground, background and styling (eg. Bold, Underscore, etc.) colors.\ntype Style []Color\n\n// NewStyle returns a new Style.\n// Accepts multiple colors.\nfunc NewStyle(colors ...Color) *Style {\n\tret := Style{}\n\tfor _, c := range colors {\n\t\tret = append(ret, c)\n\t}\n\treturn &ret\n}\n\n// Add styles to the current Style.\nfunc (s Style) Add(styles ...Style) Style {\n\tret := s\n\n\tfor _, st := range styles {\n\t\tret = append(ret, st...)\n\t}\n\n\treturn ret\n}\n\n// RemoveColor removes the given colors from the Style.\nfunc (s Style) RemoveColor(colors ...Color) Style {\n\tret := s\n\n\tfor _, c := range colors {\n\t\t// remove via index\n\t\tfor i := 0; i < len(ret); i++ {\n\t\t\tif ret[i] == c {\n\t\t\t\tret = append(ret[:i], ret[i+1:]...)\n\t\t\t\ti--\n\t\t\t}\n\t\t}\n\t}\n\n\treturn ret\n}\n\n// Sprint formats using the default formats for its operands and returns the resulting string.\n// Spaces are added between operands when neither is a string.\n// Input will be colored with the parent Style.\nfunc (s Style) Sprint(a ...any) string {\n\tmessage := Sprint(a...)\n\tmessageLines := strings.Split(message, \"\\n\")\n\tfor i, line := range messageLines {\n\t\tmessageLines[i] = color.RenderCode(s.String(), strings.ReplaceAll(line, color.ResetSet, Sprintf(\"\\x1b[0m\\u001B[%sm\", s.String())))\n\t}\n\tmessage = strings.Join(messageLines, \"\\n\")\n\treturn color.RenderCode(s.String(), message)\n}\n\n// Sprintln formats using the default formats for its operands and returns the resulting string.\n// Spaces are always added between operands and a newline is appended.\n// Input will be colored with the parent Style.\nfunc (s Style) Sprintln(a ...any) string {\n\treturn s.Sprint(a...) + \"\\n\"\n}\n\n// Sprintf formats according to a format specifier and returns the resulting string.\n// Input will be colored with the parent Style.\nfunc (s Style) Sprintf(format string, a ...any) string {\n\treturn s.Sprint(Sprintf(format, a...))\n}\n\n// Sprintfln formats according to a format specifier and returns the resulting string.\n// Spaces are always added between operands and a newline is appended.\n// Input will be colored with the parent Style.\nfunc (s Style) Sprintfln(format string, a ...any) string {\n\treturn s.Sprint(Sprintf(format, a...) + \"\\n\")\n}\n\n// Print formats using the default formats for its operands and writes to standard output.\n// Spaces are added between operands when neither is a string.\n// It returns the number of bytes written and any write error encountered.\n// Input will be colored with the parent Style.\nfunc (s Style) Print(a ...any) {\n\tPrint(s.Sprint(a...))\n}\n\n// Println formats using the default formats for its operands and writes to standard output.\n// Spaces are always added between operands and a newline is appended.\n// It returns the number of bytes written and any write error encountered.\n// Input will be colored with the parent Style.\nfunc (s Style) Println(a ...any) {\n\tPrintln(s.Sprint(a...))\n}\n\n// Printf formats according to a format specifier and writes to standard output.\n// It returns the number of bytes written and any write error encountered.\n// Input will be colored with the parent Style.\nfunc (s Style) Printf(format string, a ...any) {\n\tPrint(s.Sprintf(format, a...))\n}\n\n// Printfln formats according to a format specifier and writes to standard output.\n// Spaces are always added between operands and a newline is appended.\n// It returns the number of bytes written and any write error encountered.\n// Input will be colored with the parent Style.\nfunc (s Style) Printfln(format string, a ...any) {\n\tPrint(s.Sprintfln(format, a...))\n}\n\n// Code convert to code string. returns like \"32;45;3\".\nfunc (s Style) Code() string {\n\treturn s.String()\n}\n\n// String convert to code string. returns like \"32;45;3\".\nfunc (s Style) String() string {\n\treturn colors2code(s...)\n}\n\n// Converts colors to code.\n// Return format: \"32;45;3\".\nfunc colors2code(colors ...Color) string {\n\tif len(colors) == 0 {\n\t\treturn \"\"\n\t}\n\n\tvar codes []string\n\tfor _, c := range colors {\n\t\tcodes = append(codes, c.String())\n\t}\n\n\treturn strings.Join(codes, \";\")\n}\n"
        },
        {
          "name": "color_test.go",
          "type": "blob",
          "size": 4.9228515625,
          "content": "package pterm_test\n\nimport (\n\t\"errors\"\n\t\"io\"\n\t\"testing\"\n\n\t\"github.com/MarvinJWendt/testza\"\n\t\"github.com/gookit/color\"\n\n\t\"github.com/pterm/pterm\"\n\t\"github.com/pterm/pterm/internal\"\n)\n\nfunc TestStylePrinterPrintMethods(t *testing.T) {\n\tp := pterm.NewStyle(pterm.FgRed, pterm.BgBlue, pterm.Bold)\n\n\tt.Run(\"Print\", func(t *testing.T) {\n\t\ttestPrintContains(t, func(w io.Writer, a any) {\n\t\t\tp.Print(a)\n\t\t})\n\t})\n\n\tt.Run(\"Printf\", func(t *testing.T) {\n\t\ttestPrintfContains(t, func(w io.Writer, format string, a any) {\n\t\t\tp.Printf(format, a)\n\t\t})\n\t})\n\n\tt.Run(\"Printfln\", func(t *testing.T) {\n\t\ttestPrintflnContains(t, func(w io.Writer, format string, a any) {\n\t\t\tp.Printfln(format, a)\n\t\t})\n\t})\n\n\tt.Run(\"Println\", func(t *testing.T) {\n\t\ttestPrintlnContains(t, func(w io.Writer, a any) {\n\t\t\tp.Println(a)\n\t\t})\n\t})\n\n\tt.Run(\"Sprint\", func(t *testing.T) {\n\t\ttestSprintContains(t, func(a any) string {\n\t\t\treturn p.Sprint(a)\n\t\t})\n\t})\n\n\tt.Run(\"Sprintf\", func(t *testing.T) {\n\t\ttestSprintfContains(t, func(format string, a any) string {\n\t\t\treturn p.Sprintf(format, a)\n\t\t})\n\t})\n\n\tt.Run(\"Sprintfln\", func(t *testing.T) {\n\t\ttestSprintflnContains(t, func(format string, a any) string {\n\t\t\treturn p.Sprintfln(format, a)\n\t\t})\n\t})\n\n\tt.Run(\"Sprintln\", func(t *testing.T) {\n\t\ttestSprintlnContains(t, func(a any) string {\n\t\t\treturn p.Sprintln(a)\n\t\t})\n\t})\n}\n\nfunc TestRemoveColorFromString(t *testing.T) {\n\tfor _, randomString := range internal.RandomStrings {\n\t\ttestString := pterm.Cyan(randomString)\n\t\ttestza.AssertEqual(t, randomString, pterm.RemoveColorFromString(testString))\n\t}\n}\n\nfunc TestColorPrinterPrintMethods(t *testing.T) {\n\tp := pterm.Color(16)\n\n\tt.Run(\"Print\", func(t *testing.T) {\n\t\ttestPrintContains(t, func(w io.Writer, a any) {\n\t\t\tp.Print(a)\n\t\t})\n\t})\n\n\tt.Run(\"Printf\", func(t *testing.T) {\n\t\ttestPrintfContains(t, func(w io.Writer, format string, a any) {\n\t\t\tp.Printf(format, a)\n\t\t})\n\t})\n\n\tt.Run(\"Printfln\", func(t *testing.T) {\n\t\ttestPrintflnContains(t, func(w io.Writer, format string, a any) {\n\t\t\tp.Printfln(format, a)\n\t\t})\n\t})\n\n\tt.Run(\"Println\", func(t *testing.T) {\n\t\ttestPrintlnContains(t, func(w io.Writer, a any) {\n\t\t\tp.Println(a)\n\t\t})\n\t})\n\n\tt.Run(\"Sprint\", func(t *testing.T) {\n\t\ttestSprintContains(t, func(a any) string {\n\t\t\treturn p.Sprint(a)\n\t\t})\n\t})\n\n\tt.Run(\"Sprintf\", func(t *testing.T) {\n\t\ttestSprintfContains(t, func(format string, a any) string {\n\t\t\treturn p.Sprintf(format, a)\n\t\t})\n\t})\n\n\tt.Run(\"Sprintfln\", func(t *testing.T) {\n\t\ttestSprintflnContains(t, func(format string, a any) string {\n\t\t\treturn p.Sprintfln(format, a)\n\t\t})\n\t})\n\n\tt.Run(\"Sprintln\", func(t *testing.T) {\n\t\ttestSprintlnContains(t, func(a any) string {\n\t\t\treturn p.Sprintln(a)\n\t\t})\n\t})\n\n\tt.Run(\"PrintOnError\", func(t *testing.T) {\n\t\tresult := captureStdout(func(w io.Writer) {\n\t\t\tp.PrintOnError(errors.New(\"hello world\"))\n\t\t})\n\t\ttestza.AssertContains(t, result, \"hello world\")\n\t})\n\n\tt.Run(\"PrintIfError_WithoutError\", func(t *testing.T) {\n\t\tresult := captureStdout(func(w io.Writer) {\n\t\t\tp.PrintOnError(nil)\n\t\t})\n\t\ttestza.AssertZero(t, result)\n\t})\n\n\tt.Run(\"PrintOnErrorf\", func(t *testing.T) {\n\t\tresult := captureStdout(func(w io.Writer) {\n\t\t\tp.PrintOnErrorf(\"wrapping error : %w\", errors.New(\"hello world\"))\n\t\t})\n\t\ttestza.AssertContains(t, result, \"hello world\")\n\t})\n\n\tt.Run(\"PrintIfError_WithoutErrorf\", func(t *testing.T) {\n\t\tresult := captureStdout(func(w io.Writer) {\n\t\t\tp.PrintOnErrorf(\"\", nil)\n\t\t})\n\t\ttestza.AssertZero(t, result)\n\t})\n}\n\nfunc TestNewStyle(t *testing.T) {\n\ts := pterm.NewStyle(pterm.FgRed, pterm.BgBlue, pterm.Bold)\n\ttestza.AssertEqual(t, s, &pterm.Style{pterm.FgRed, pterm.BgBlue, pterm.Bold})\n}\n\nfunc TestColor_ToStyle(t *testing.T) {\n\ts := pterm.FgCyan.ToStyle()\n\ttestza.AssertEqual(t, s, &pterm.Style{pterm.FgCyan})\n}\n\nfunc TestStyle_Add(t *testing.T) {\n\ttestza.AssertEqual(t, pterm.Style{pterm.FgRed, pterm.BgGreen}, pterm.Style{pterm.FgRed}.Add(pterm.Style{pterm.BgGreen}))\n\ttestza.AssertEqual(t, pterm.Style{pterm.FgRed, pterm.BgGreen, pterm.Bold}, pterm.Style{pterm.FgRed}.Add(pterm.Style{pterm.BgGreen}).Add(pterm.Style{pterm.Bold}))\n\ttestza.AssertEqual(t, pterm.Style{pterm.FgRed, pterm.BgGreen, pterm.Bold}, pterm.Style{pterm.FgRed}.Add(pterm.Style{pterm.BgGreen, pterm.Bold}))\n\ttestza.AssertEqual(t, pterm.Style{pterm.FgRed, pterm.BgGreen, pterm.Bold}, pterm.Style{pterm.FgRed}.Add(pterm.Style{pterm.BgGreen}, pterm.Style{pterm.Bold}))\n}\n\nfunc TestStyle_Code(t *testing.T) {\n\ttestza.AssertNotZero(t, pterm.NewStyle(pterm.FgRed, pterm.BgBlue, pterm.Bold).Code())\n}\n\nfunc TestStyle_String(t *testing.T) {\n\ttestza.AssertNotZero(t, pterm.NewStyle(pterm.FgRed, pterm.BgBlue, pterm.Bold).String())\n}\n\nfunc TestEnableColor(t *testing.T) {\n\tpterm.EnableColor()\n\ttestza.AssertTrue(t, color.Enable)\n\ttestza.AssertTrue(t, pterm.PrintColor)\n}\n\nfunc TestDisableColor(t *testing.T) {\n\tpterm.DisableColor()\n\ttestza.AssertFalse(t, color.Enable)\n\ttestza.AssertFalse(t, pterm.PrintColor)\n}\n\nfunc TestDisabledColorDoesPrintPlainString(t *testing.T) {\n\tpterm.DisableColor()\n\ttestza.AssertEqual(t, \"Hello, World!\", pterm.FgRed.Sprint(\"Hello, World!\"))\n}\n"
        },
        {
          "name": "conventionalcommit.json",
          "type": "blob",
          "size": 1.701171875,
          "content": "{\n  \"types\": {\n    \"refactor\": {\n      \"description\": \"Changes which neither fix a bug nor add a feature\",\n    },\n    \"fix\": {\n      \"description\": \"Changes which patch a bug\"\n    },\n    \"feat\": {\n      \"description\": \"Changes which introduce a new feature\"\n    },\n    \"build\": {\n      \"description\": \"Changes which affect the build system or external dependencies (example scopes: gulp, broccoli, npm)\"\n    },\n    \"chore\": {\n      \"description\": \"Changes which aren’t user-facing\"\n    },\n    \"style\": {\n      \"description\": \"Changes which don't affect code logic.\\nWhite-spaces, formatting, missing semi-colons, etc\"\n    },\n    \"test\": {\n      \"description\": \"Changes which add missing tests or correct existing tests\"\n    },\n    \"docs\": {\n      \"description\": \"Changes which affect documentation\",\n      \"scopes\": {\n        \"pterm-sh\": {},\n        \"examples\": {},\n        \"readme\": {},\n        \"contributing\": {}\n      }\n    },\n    \"perf\": {\n      \"description\": \"Changes which improve performance\"\n    },\n    \"ci\": {\n      \"description\": \"Changes which affect CI configuration files and scripts (example scopes: travis, circle, browser-stack, sauce-labs)\"\n    },\n    \"revert\": {\n      \"description\": \"Changes which revert a previous commit\"\n    }\n  },\n  \"footerTypes\": [\n    {\n      \"name\": \"BREAKING CHANGE\",\n      \"description\": \"The commit introduces breaking API changes\"\n    },\n    {\n      \"name\": \"Closes\",\n      \"description\": \"The commit closes issues or pull requests\"\n    },\n    {\n      \"name\": \"Implements\",\n      \"description\": \"The commit implements features\"\n    },\n    {\n      \"name\": \"Co-authored-by\",\n      \"description\": \"The commit is co-authored by another person (for multiple people use one line each)\"\n    }\n  ]\n}\n"
        },
        {
          "name": "coverage.txt",
          "type": "blob",
          "size": 57.732421875,
          "content": "mode: atomic\ngithub.com/pterm/pterm/internal/percentage.go:6.49,8.2 1 8\ngithub.com/pterm/pterm/internal/percentage.go:11.54,13.2 1 4\ngithub.com/pterm/pterm/internal/remove_and_count_prefix.go:7.66,11.2 3 0\ngithub.com/pterm/pterm/internal/title_in_line.go:10.71,12.10 2 0\ngithub.com/pterm/pterm/internal/title_in_line.go:18.2,18.12 1 0\ngithub.com/pterm/pterm/internal/title_in_line.go:12.10,14.3 1 0\ngithub.com/pterm/pterm/internal/title_in_line.go:14.8,16.3 1 0\ngithub.com/pterm/pterm/internal/title_in_line.go:22.66,30.2 5 0\ngithub.com/pterm/pterm/internal/map_range_to_range.go:3.75,4.26 1 4\ngithub.com/pterm/pterm/internal/map_range_to_range.go:7.2,7.73 1 4\ngithub.com/pterm/pterm/internal/map_range_to_range.go:4.26,6.3 1 0\ngithub.com/pterm/pterm/internal/max_text_width.go:11.38,14.24 3 0\ngithub.com/pterm/pterm/internal/max_text_width.go:19.2,19.12 1 0\ngithub.com/pterm/pterm/internal/max_text_width.go:14.24,15.55 1 0\ngithub.com/pterm/pterm/internal/max_text_width.go:15.55,17.4 1 0\ngithub.com/pterm/pterm/internal/center_text.go:10.48,13.32 3 2\ngithub.com/pterm/pterm/internal/center_text.go:36.2,37.26 2 2\ngithub.com/pterm/pterm/internal/center_text.go:41.2,41.39 1 2\ngithub.com/pterm/pterm/internal/center_text.go:13.32,14.41 1 4\ngithub.com/pterm/pterm/internal/center_text.go:14.41,17.32 3 1\ngithub.com/pterm/pterm/internal/center_text.go:24.4,24.41 1 1\ngithub.com/pterm/pterm/internal/center_text.go:17.32,18.31 1 11\ngithub.com/pterm/pterm/internal/center_text.go:22.5,22.52 1 11\ngithub.com/pterm/pterm/internal/center_text.go:18.31,21.6 2 2\ngithub.com/pterm/pterm/internal/center_text.go:24.41,28.5 3 3\ngithub.com/pterm/pterm/internal/center_text.go:29.9,33.4 3 3\ngithub.com/pterm/pterm/internal/center_text.go:37.26,39.3 1 6\ngithub.com/pterm/pterm/internal/longest_line.go:11.49,14.29 3 0\ngithub.com/pterm/pterm/internal/longest_line.go:20.2,20.16 1 0\ngithub.com/pterm/pterm/internal/longest_line.go:14.29,15.101 1 0\ngithub.com/pterm/pterm/internal/longest_line.go:15.101,17.4 1 0\ngithub.com/pterm/pterm/internal/with_boolean.go:4.33,5.17 1 0\ngithub.com/pterm/pterm/internal/with_boolean.go:8.2,8.13 1 0\ngithub.com/pterm/pterm/internal/with_boolean.go:5.17,7.3 1 0\ngithub.com/pterm/pterm/putils/download-with-progressbar.go:20.58,25.2 4 0\ngithub.com/pterm/pterm/putils/download-with-progressbar.go:29.121,32.16 3 0\ngithub.com/pterm/pterm/putils/download-with-progressbar.go:36.2,37.16 2 0\ngithub.com/pterm/pterm/putils/download-with-progressbar.go:41.2,45.16 4 0\ngithub.com/pterm/pterm/putils/download-with-progressbar.go:49.2,50.73 2 0\ngithub.com/pterm/pterm/putils/download-with-progressbar.go:55.2,56.16 2 0\ngithub.com/pterm/pterm/putils/download-with-progressbar.go:60.2,61.12 2 0\ngithub.com/pterm/pterm/putils/download-with-progressbar.go:32.16,34.3 1 0\ngithub.com/pterm/pterm/putils/download-with-progressbar.go:37.16,40.3 2 0\ngithub.com/pterm/pterm/putils/download-with-progressbar.go:45.16,47.3 1 0\ngithub.com/pterm/pterm/putils/download-with-progressbar.go:50.73,53.3 2 0\ngithub.com/pterm/pterm/putils/download-with-progressbar.go:56.16,58.3 1 0\ngithub.com/pterm/pterm/putils/download-with-progressbar.go:66.96,68.2 1 0\ngithub.com/pterm/pterm/putils/run-with-spinner.go:6.103,8.16 2 0\ngithub.com/pterm/pterm/putils/run-with-spinner.go:12.2,15.12 3 0\ngithub.com/pterm/pterm/putils/run-with-spinner.go:8.16,10.3 1 0\ngithub.com/pterm/pterm/putils/run-with-spinner.go:19.107,21.2 1 0\ngithub.com/pterm/pterm/putils/stats.go:11.70,13.29 2 0\ngithub.com/pterm/pterm/putils/stats.go:25.2,29.12 3 0\ngithub.com/pterm/pterm/putils/stats.go:13.29,18.17 4 0\ngithub.com/pterm/pterm/putils/stats.go:22.3,22.20 1 0\ngithub.com/pterm/pterm/putils/stats.go:18.17,20.4 1 0\ngithub.com/pterm/pterm/putils/tabledata-from-struct-slice.go:13.105,15.32 2 0\ngithub.com/pterm/pterm/putils/tabledata-from-struct-slice.go:18.2,21.30 3 0\ngithub.com/pterm/pterm/putils/tabledata-from-struct-slice.go:26.2,26.33 1 0\ngithub.com/pterm/pterm/putils/tabledata-from-struct-slice.go:30.2,33.33 3 0\ngithub.com/pterm/pterm/putils/tabledata-from-struct-slice.go:37.2,44.33 4 0\ngithub.com/pterm/pterm/putils/tabledata-from-struct-slice.go:52.2,52.26 1 0\ngithub.com/pterm/pterm/putils/tabledata-from-struct-slice.go:61.2,63.22 2 0\ngithub.com/pterm/pterm/putils/tabledata-from-struct-slice.go:15.32,17.3 1 0\ngithub.com/pterm/pterm/putils/tabledata-from-struct-slice.go:21.30,24.3 2 0\ngithub.com/pterm/pterm/putils/tabledata-from-struct-slice.go:26.33,28.3 1 0\ngithub.com/pterm/pterm/putils/tabledata-from-struct-slice.go:33.33,35.3 1 0\ngithub.com/pterm/pterm/putils/tabledata-from-struct-slice.go:44.33,45.16 1 0\ngithub.com/pterm/pterm/putils/tabledata-from-struct-slice.go:45.16,47.4 1 0\ngithub.com/pterm/pterm/putils/tabledata-from-struct-slice.go:47.9,49.4 1 0\ngithub.com/pterm/pterm/putils/tabledata-from-struct-slice.go:52.26,55.34 3 0\ngithub.com/pterm/pterm/putils/tabledata-from-struct-slice.go:59.3,59.36 1 0\ngithub.com/pterm/pterm/putils/tabledata-from-struct-slice.go:55.34,58.4 2 0\ngithub.com/pterm/pterm/putils/tabledata-from-struct-slice.go:69.79,71.2 1 0\ngithub.com/pterm/pterm/putils/tabledata_from_csv.go:11.56,13.2 1 1\ngithub.com/pterm/pterm/putils/tabledata_from_separated_values.go:13.99,14.57 1 3\ngithub.com/pterm/pterm/putils/tabledata_from_separated_values.go:18.2,18.8 1 3\ngithub.com/pterm/pterm/putils/tabledata_from_separated_values.go:14.57,16.3 1 6\ngithub.com/pterm/pterm/putils/tabledata_from_tsv.go:11.56,13.2 1 1\ngithub.com/pterm/pterm/rgb.go:23.42,25.2 1 14316\ngithub.com/pterm/pterm/rgb.go:28.32,30.2 1 28640\ngithub.com/pterm/pterm/rgb.go:33.45,38.19 4 12\ngithub.com/pterm/pterm/rgb.go:41.2,41.19 1 12\ngithub.com/pterm/pterm/rgb.go:45.2,46.16 2 8\ngithub.com/pterm/pterm/rgb.go:49.2,55.8 2 7\ngithub.com/pterm/pterm/rgb.go:38.19,40.3 1 4\ngithub.com/pterm/pterm/rgb.go:41.19,43.3 1 4\ngithub.com/pterm/pterm/rgb.go:46.16,48.3 1 1\ngithub.com/pterm/pterm/rgb.go:59.62,60.13 1 14416\ngithub.com/pterm/pterm/rgb.go:65.2,65.19 1 14416\ngithub.com/pterm/pterm/rgb.go:85.2,85.10 1 1\ngithub.com/pterm/pterm/rgb.go:60.13,64.3 3 2\ngithub.com/pterm/pterm/rgb.go:65.19,71.3 1 14411\ngithub.com/pterm/pterm/rgb.go:71.8,71.25 1 5\ngithub.com/pterm/pterm/rgb.go:71.25,74.18 3 4\ngithub.com/pterm/pterm/rgb.go:74.18,76.4 1 1\ngithub.com/pterm/pterm/rgb.go:76.9,77.36 1 3\ngithub.com/pterm/pterm/rgb.go:77.36,79.24 2 3\ngithub.com/pterm/pterm/rgb.go:79.24,81.6 1 3\ngithub.com/pterm/pterm/rgb.go:90.46,92.2 1 4224\ngithub.com/pterm/pterm/rgb.go:96.48,98.2 1 1950\ngithub.com/pterm/pterm/rgb.go:101.62,103.2 1 2052\ngithub.com/pterm/pterm/rgb.go:107.64,109.2 1 1944\ngithub.com/pterm/pterm/rgb.go:114.51,118.2 3 54\ngithub.com/pterm/pterm/rgb.go:123.53,127.2 3 978\ngithub.com/pterm/pterm/rgb.go:131.67,135.2 3 54\ngithub.com/pterm/pterm/rgb.go:140.69,144.2 3 972\ngithub.com/pterm/pterm/rgb.go:149.58,150.24 1 6\ngithub.com/pterm/pterm/rgb.go:158.2,159.12 2 6\ngithub.com/pterm/pterm/rgb.go:150.24,151.33 1 6\ngithub.com/pterm/pterm/rgb.go:151.33,152.18 1 3\ngithub.com/pterm/pterm/rgb.go:152.18,154.5 1 3\ngithub.com/pterm/pterm/rgb.go:165.74,166.24 1 6\ngithub.com/pterm/pterm/rgb.go:174.2,175.12 2 6\ngithub.com/pterm/pterm/rgb.go:166.24,167.33 1 6\ngithub.com/pterm/pterm/rgb.go:167.33,168.18 1 3\ngithub.com/pterm/pterm/rgb.go:168.18,170.5 1 3\ngithub.com/pterm/pterm/bigtext_printer.go:17.48,19.2 1 3\ngithub.com/pterm/pterm/bigtext_printer.go:22.71,26.23 3 6\ngithub.com/pterm/pterm/bigtext_printer.go:33.2,33.10 1 6\ngithub.com/pterm/pterm/bigtext_printer.go:26.23,31.3 1 19\ngithub.com/pterm/pterm/bigtext_printer.go:37.64,41.23 3 2\ngithub.com/pterm/pterm/bigtext_printer.go:49.2,49.10 1 2\ngithub.com/pterm/pterm/bigtext_printer.go:41.23,47.3 1 7\ngithub.com/pterm/pterm/bigtext_printer.go:60.49,63.2 2 1\ngithub.com/pterm/pterm/bigtext_printer.go:66.42,69.2 2 1\ngithub.com/pterm/pterm/bigtext_printer.go:72.46,75.2 2 1\ngithub.com/pterm/pterm/bigtext_printer.go:87.84,90.2 2 1\ngithub.com/pterm/pterm/bigtext_printer.go:93.73,95.33 2 5\ngithub.com/pterm/pterm/bigtext_printer.go:98.2,99.11 2 5\ngithub.com/pterm/pterm/bigtext_printer.go:95.33,97.3 1 6\ngithub.com/pterm/pterm/bigtext_printer.go:103.76,106.2 2 0\ngithub.com/pterm/pterm/bigtext_printer.go:109.51,112.15 2 8\ngithub.com/pterm/pterm/bigtext_printer.go:119.2,120.30 2 5\ngithub.com/pterm/pterm/bigtext_printer.go:130.2,132.31 2 5\ngithub.com/pterm/pterm/bigtext_printer.go:139.2,139.34 1 5\ngithub.com/pterm/pterm/bigtext_printer.go:161.2,161.17 1 5\ngithub.com/pterm/pterm/bigtext_printer.go:112.15,113.36 1 3\ngithub.com/pterm/pterm/bigtext_printer.go:116.3,116.18 1 3\ngithub.com/pterm/pterm/bigtext_printer.go:113.36,115.4 1 15\ngithub.com/pterm/pterm/bigtext_printer.go:120.30,121.47 1 20\ngithub.com/pterm/pterm/bigtext_printer.go:121.47,127.4 1 20\ngithub.com/pterm/pterm/bigtext_printer.go:132.31,134.20 2 20\ngithub.com/pterm/pterm/bigtext_printer.go:134.20,136.4 1 4\ngithub.com/pterm/pterm/bigtext_printer.go:139.34,140.37 1 21\ngithub.com/pterm/pterm/bigtext_printer.go:158.3,158.14 1 21\ngithub.com/pterm/pterm/bigtext_printer.go:140.37,144.28 4 100\ngithub.com/pterm/pterm/bigtext_printer.go:147.4,148.41 2 100\ngithub.com/pterm/pterm/bigtext_printer.go:152.4,152.29 1 100\ngithub.com/pterm/pterm/bigtext_printer.go:144.28,146.5 1 100\ngithub.com/pterm/pterm/bigtext_printer.go:148.41,150.5 1 7\ngithub.com/pterm/pterm/bigtext_printer.go:152.29,154.5 1 25\ngithub.com/pterm/pterm/bigtext_printer.go:154.10,156.5 1 75\ngithub.com/pterm/pterm/bigtext_printer.go:165.40,170.2 3 7\ngithub.com/pterm/pterm/panel_printer.go:36.63,39.2 2 96\ngithub.com/pterm/pterm/panel_printer.go:42.62,43.17 1 2\ngithub.com/pterm/pterm/panel_printer.go:46.2,47.11 2 2\ngithub.com/pterm/pterm/panel_printer.go:43.17,45.3 1 1\ngithub.com/pterm/pterm/panel_printer.go:51.74,52.23 1 20\ngithub.com/pterm/pterm/panel_printer.go:55.2,56.11 2 20\ngithub.com/pterm/pterm/panel_printer.go:52.23,54.3 1 1\ngithub.com/pterm/pterm/panel_printer.go:60.68,64.2 3 19\ngithub.com/pterm/pterm/panel_printer.go:67.75,70.2 2 19\ngithub.com/pterm/pterm/panel_printer.go:73.72,76.2 2 0\ngithub.com/pterm/pterm/panel_printer.go:78.45,80.33 2 45\ngithub.com/pterm/pterm/panel_printer.go:86.2,86.12 1 45\ngithub.com/pterm/pterm/panel_printer.go:80.33,81.32 1 99\ngithub.com/pterm/pterm/panel_printer.go:84.3,84.14 1 99\ngithub.com/pterm/pterm/panel_printer.go:81.32,83.4 1 117\ngithub.com/pterm/pterm/panel_printer.go:90.49,93.15 2 96\ngithub.com/pterm/pterm/panel_printer.go:97.2,97.26 1 51\ngithub.com/pterm/pterm/panel_printer.go:103.2,103.36 1 51\ngithub.com/pterm/pterm/panel_printer.go:111.2,111.26 1 51\ngithub.com/pterm/pterm/panel_printer.go:119.2,121.23 2 51\ngithub.com/pterm/pterm/panel_printer.go:131.2,131.35 1 51\ngithub.com/pterm/pterm/panel_printer.go:181.2,181.17 1 51\ngithub.com/pterm/pterm/panel_printer.go:93.15,95.3 1 45\ngithub.com/pterm/pterm/panel_printer.go:97.26,98.31 1 104\ngithub.com/pterm/pterm/panel_printer.go:98.31,100.4 1 126\ngithub.com/pterm/pterm/panel_printer.go:103.36,104.27 1 9\ngithub.com/pterm/pterm/panel_printer.go:104.27,105.32 1 18\ngithub.com/pterm/pterm/panel_printer.go:105.32,107.5 1 27\ngithub.com/pterm/pterm/panel_printer.go:111.26,112.27 1 104\ngithub.com/pterm/pterm/panel_printer.go:112.27,113.32 1 54\ngithub.com/pterm/pterm/panel_printer.go:113.32,115.5 1 72\ngithub.com/pterm/pterm/panel_printer.go:121.23,122.34 1 9\ngithub.com/pterm/pterm/panel_printer.go:122.34,123.29 1 27\ngithub.com/pterm/pterm/panel_printer.go:123.29,124.68 1 27\ngithub.com/pterm/pterm/panel_printer.go:124.68,126.6 1 21\ngithub.com/pterm/pterm/panel_printer.go:131.35,136.31 3 104\ngithub.com/pterm/pterm/panel_printer.go:140.3,140.40 1 104\ngithub.com/pterm/pterm/panel_printer.go:144.3,144.38 1 104\ngithub.com/pterm/pterm/panel_printer.go:151.3,151.34 1 104\ngithub.com/pterm/pterm/panel_printer.go:136.31,138.4 1 126\ngithub.com/pterm/pterm/panel_printer.go:140.40,142.4 1 126\ngithub.com/pterm/pterm/panel_printer.go:144.38,146.26 2 126\ngithub.com/pterm/pterm/panel_printer.go:146.26,148.5 1 104\ngithub.com/pterm/pterm/panel_printer.go:151.34,152.22 1 215\ngithub.com/pterm/pterm/panel_printer.go:152.22,153.43 1 215\ngithub.com/pterm/pterm/panel_printer.go:176.5,176.16 1 215\ngithub.com/pterm/pterm/panel_printer.go:153.43,157.28 4 312\ngithub.com/pterm/pterm/panel_printer.go:160.6,160.30 1 312\ngithub.com/pterm/pterm/panel_printer.go:163.6,164.28 2 312\ngithub.com/pterm/pterm/panel_printer.go:173.6,174.23 2 312\ngithub.com/pterm/pterm/panel_printer.go:157.28,159.7 1 285\ngithub.com/pterm/pterm/panel_printer.go:160.30,162.7 1 276\ngithub.com/pterm/pterm/panel_printer.go:164.28,165.44 1 285\ngithub.com/pterm/pterm/panel_printer.go:165.44,167.8 1 87\ngithub.com/pterm/pterm/panel_printer.go:168.12,169.51 1 27\ngithub.com/pterm/pterm/panel_printer.go:169.51,171.8 1 17\ngithub.com/pterm/pterm/panel_printer.go:185.38,190.2 3 92\ngithub.com/pterm/pterm/tree_printer.go:51.63,54.2 2 1\ngithub.com/pterm/pterm/tree_printer.go:57.63,60.2 2 1\ngithub.com/pterm/pterm/tree_printer.go:63.70,66.2 2 1\ngithub.com/pterm/pterm/tree_printer.go:69.75,72.2 2 1\ngithub.com/pterm/pterm/tree_printer.go:75.66,78.2 2 1\ngithub.com/pterm/pterm/tree_printer.go:81.64,84.2 2 1\ngithub.com/pterm/pterm/tree_printer.go:87.59,90.2 2 8\ngithub.com/pterm/pterm/tree_printer.go:94.58,95.16 1 2\ngithub.com/pterm/pterm/tree_printer.go:98.2,99.11 2 2\ngithub.com/pterm/pterm/tree_printer.go:95.16,97.3 1 1\ngithub.com/pterm/pterm/tree_printer.go:103.70,106.2 2 0\ngithub.com/pterm/pterm/tree_printer.go:109.37,114.2 3 3\ngithub.com/pterm/pterm/tree_printer.go:117.48,118.24 1 4\ngithub.com/pterm/pterm/tree_printer.go:121.2,121.24 1 4\ngithub.com/pterm/pterm/tree_printer.go:125.2,125.50 1 4\ngithub.com/pterm/pterm/tree_printer.go:118.24,120.3 1 2\ngithub.com/pterm/pterm/tree_printer.go:121.24,123.3 1 2\ngithub.com/pterm/pterm/tree_printer.go:131.73,133.28 2 12\ngithub.com/pterm/pterm/tree_printer.go:154.2,154.12 1 12\ngithub.com/pterm/pterm/tree_printer.go:133.28,134.22 1 32\ngithub.com/pterm/pterm/tree_printer.go:134.22,135.31 1 21\ngithub.com/pterm/pterm/tree_printer.go:135.31,138.5 1 17\ngithub.com/pterm/pterm/tree_printer.go:138.10,142.5 2 4\ngithub.com/pterm/pterm/tree_printer.go:143.9,143.30 1 11\ngithub.com/pterm/pterm/tree_printer.go:143.30,144.31 1 11\ngithub.com/pterm/pterm/tree_printer.go:144.31,147.5 1 7\ngithub.com/pterm/pterm/tree_printer.go:147.10,151.5 2 4\ngithub.com/pterm/pterm/tree_printer.go:158.68,159.32 1 11\ngithub.com/pterm/pterm/tree_printer.go:163.2,168.42 2 9\ngithub.com/pterm/pterm/tree_printer.go:192.2,192.14 1 9\ngithub.com/pterm/pterm/tree_printer.go:159.32,161.3 1 2\ngithub.com/pterm/pterm/tree_printer.go:168.42,171.23 2 86\ngithub.com/pterm/pterm/tree_printer.go:176.3,176.35 1 86\ngithub.com/pterm/pterm/tree_printer.go:182.3,182.37 1 86\ngithub.com/pterm/pterm/tree_printer.go:186.3,189.5 1 86\ngithub.com/pterm/pterm/tree_printer.go:171.23,174.4 2 1\ngithub.com/pterm/pterm/tree_printer.go:176.35,177.52 1 77\ngithub.com/pterm/pterm/tree_printer.go:177.52,179.5 1 1\ngithub.com/pterm/pterm/tree_printer.go:182.37,185.4 2 97\ngithub.com/pterm/pterm/basic_text_printer.go:21.69,24.2 2 1\ngithub.com/pterm/pterm/basic_text_printer.go:26.80,29.2 2 0\ngithub.com/pterm/pterm/basic_text_printer.go:33.59,34.20 1 1371\ngithub.com/pterm/pterm/basic_text_printer.go:37.2,37.29 1 1371\ngithub.com/pterm/pterm/basic_text_printer.go:34.20,36.3 1 1371\ngithub.com/pterm/pterm/basic_text_printer.go:42.61,45.2 2 651\ngithub.com/pterm/pterm/basic_text_printer.go:48.75,50.2 1 684\ngithub.com/pterm/pterm/basic_text_printer.go:54.77,56.2 1 648\ngithub.com/pterm/pterm/basic_text_printer.go:61.65,65.2 3 18\ngithub.com/pterm/pterm/basic_text_printer.go:70.67,74.2 3 327\ngithub.com/pterm/pterm/basic_text_printer.go:78.81,82.2 3 18\ngithub.com/pterm/pterm/basic_text_printer.go:87.83,91.2 3 324\ngithub.com/pterm/pterm/basic_text_printer.go:96.72,97.24 1 2\ngithub.com/pterm/pterm/basic_text_printer.go:105.2,106.12 2 2\ngithub.com/pterm/pterm/basic_text_printer.go:97.24,98.33 1 2\ngithub.com/pterm/pterm/basic_text_printer.go:98.33,99.18 1 1\ngithub.com/pterm/pterm/basic_text_printer.go:99.18,101.5 1 1\ngithub.com/pterm/pterm/basic_text_printer.go:112.88,113.24 1 2\ngithub.com/pterm/pterm/basic_text_printer.go:121.2,122.12 2 2\ngithub.com/pterm/pterm/basic_text_printer.go:113.24,114.33 1 2\ngithub.com/pterm/pterm/basic_text_printer.go:114.33,115.18 1 1\ngithub.com/pterm/pterm/basic_text_printer.go:115.18,117.5 1 1\ngithub.com/pterm/pterm/print.go:12.36,14.2 1 13790\ngithub.com/pterm/pterm/print.go:18.38,20.2 1 253647\ngithub.com/pterm/pterm/print.go:23.54,25.2 1 139826\ngithub.com/pterm/pterm/print.go:29.56,31.2 1 30\ngithub.com/pterm/pterm/print.go:34.40,37.2 2 6291\ngithub.com/pterm/pterm/print.go:40.39,42.2 1 29128\ngithub.com/pterm/pterm/print.go:47.30,49.2 1 3576\ngithub.com/pterm/pterm/print.go:54.32,56.2 1 432\ngithub.com/pterm/pterm/print.go:60.46,62.2 1 14\ngithub.com/pterm/pterm/print.go:67.48,69.2 1 14\ngithub.com/pterm/pterm/print.go:74.37,75.24 1 2\ngithub.com/pterm/pterm/print.go:75.24,76.33 1 2\ngithub.com/pterm/pterm/print.go:76.33,77.18 1 1\ngithub.com/pterm/pterm/print.go:77.18,79.5 1 1\ngithub.com/pterm/pterm/print.go:87.53,88.24 1 2\ngithub.com/pterm/pterm/print.go:88.24,89.33 1 2\ngithub.com/pterm/pterm/print.go:89.33,90.18 1 1\ngithub.com/pterm/pterm/print.go:90.18,92.5 1 1\ngithub.com/pterm/pterm/print.go:100.49,101.13 1 13753\ngithub.com/pterm/pterm/print.go:105.2,108.48 3 13715\ngithub.com/pterm/pterm/print.go:116.2,116.48 1 13715\ngithub.com/pterm/pterm/print.go:124.2,124.14 1 13715\ngithub.com/pterm/pterm/print.go:128.2,131.48 2 13715\ngithub.com/pterm/pterm/print.go:101.13,103.3 1 38\ngithub.com/pterm/pterm/print.go:108.48,109.19 1 19966\ngithub.com/pterm/pterm/print.go:109.19,113.4 3 14278\ngithub.com/pterm/pterm/print.go:116.48,117.23 1 3131\ngithub.com/pterm/pterm/print.go:117.23,121.4 3 283\ngithub.com/pterm/pterm/print.go:124.14,126.3 1 10861\ngithub.com/pterm/pterm/print.go:131.48,132.19 1 19966\ngithub.com/pterm/pterm/print.go:132.19,134.4 1 14278\ngithub.com/pterm/pterm/print.go:141.51,144.2 1 173\ngithub.com/pterm/pterm/print.go:152.31,153.13 1 12\ngithub.com/pterm/pterm/print.go:157.2,157.34 1 6\ngithub.com/pterm/pterm/print.go:153.13,155.3 1 6\ngithub.com/pterm/pterm/print.go:161.45,162.13 1 7041\ngithub.com/pterm/pterm/print.go:166.2,166.37 1 7035\ngithub.com/pterm/pterm/print.go:162.13,164.3 1 6\ngithub.com/pterm/pterm/print.go:170.53,172.2 1 36443\ngithub.com/pterm/pterm/print.go:174.35,176.2 1 76\ngithub.com/pterm/pterm/print.go:178.26,180.2 1 14561\ngithub.com/pterm/pterm/progressbar_printer.go:63.72,66.2 2 3\ngithub.com/pterm/pterm/progressbar_printer.go:71.76,74.2 2 1\ngithub.com/pterm/pterm/progressbar_printer.go:77.70,80.2 2 9\ngithub.com/pterm/pterm/progressbar_printer.go:83.74,86.2 2 1\ngithub.com/pterm/pterm/progressbar_printer.go:89.79,92.2 2 1\ngithub.com/pterm/pterm/progressbar_printer.go:95.80,98.2 2 1\ngithub.com/pterm/pterm/progressbar_printer.go:101.103,104.2 2 1\ngithub.com/pterm/pterm/progressbar_printer.go:107.80,110.2 2 1\ngithub.com/pterm/pterm/progressbar_printer.go:113.74,116.2 2 1\ngithub.com/pterm/pterm/progressbar_printer.go:119.74,122.2 2 1\ngithub.com/pterm/pterm/progressbar_printer.go:125.79,128.2 2 1\ngithub.com/pterm/pterm/progressbar_printer.go:131.78,134.2 2 1\ngithub.com/pterm/pterm/progressbar_printer.go:137.76,140.2 2 1\ngithub.com/pterm/pterm/progressbar_printer.go:143.79,146.2 2 2\ngithub.com/pterm/pterm/progressbar_printer.go:149.76,152.2 2 1\ngithub.com/pterm/pterm/progressbar_printer.go:155.84,158.2 2 0\ngithub.com/pterm/pterm/progressbar_printer.go:161.62,164.2 2 12\ngithub.com/pterm/pterm/progressbar_printer.go:167.76,171.2 3 14291\ngithub.com/pterm/pterm/progressbar_printer.go:174.67,175.25 1 14315\ngithub.com/pterm/pterm/progressbar_printer.go:178.2,178.23 1 14315\ngithub.com/pterm/pterm/progressbar_printer.go:181.2,181.18 1 14315\ngithub.com/pterm/pterm/progressbar_printer.go:185.2,189.21 4 14314\ngithub.com/pterm/pterm/progressbar_printer.go:197.2,206.17 5 14314\ngithub.com/pterm/pterm/progressbar_printer.go:209.2,209.17 1 14314\ngithub.com/pterm/pterm/progressbar_printer.go:213.2,215.22 2 14314\ngithub.com/pterm/pterm/progressbar_printer.go:218.2,218.23 1 14314\ngithub.com/pterm/pterm/progressbar_printer.go:222.2,226.39 4 14314\ngithub.com/pterm/pterm/progressbar_printer.go:230.2,231.26 2 14314\ngithub.com/pterm/pterm/progressbar_printer.go:237.2,237.16 1 14314\ngithub.com/pterm/pterm/progressbar_printer.go:240.2,240.10 1 14314\ngithub.com/pterm/pterm/progressbar_printer.go:175.25,177.3 1 2\ngithub.com/pterm/pterm/progressbar_printer.go:178.23,180.3 1 2\ngithub.com/pterm/pterm/progressbar_printer.go:181.18,183.3 1 1\ngithub.com/pterm/pterm/progressbar_printer.go:189.21,191.3 1 1\ngithub.com/pterm/pterm/progressbar_printer.go:191.8,191.44 1 14313\ngithub.com/pterm/pterm/progressbar_printer.go:191.44,193.3 1 1\ngithub.com/pterm/pterm/progressbar_printer.go:193.8,195.3 1 14312\ngithub.com/pterm/pterm/progressbar_printer.go:206.17,208.3 1 14313\ngithub.com/pterm/pterm/progressbar_printer.go:209.17,211.3 1 14313\ngithub.com/pterm/pterm/progressbar_printer.go:215.22,217.3 1 14313\ngithub.com/pterm/pterm/progressbar_printer.go:218.23,220.3 1 14313\ngithub.com/pterm/pterm/progressbar_printer.go:226.39,228.3 1 14312\ngithub.com/pterm/pterm/progressbar_printer.go:231.26,233.3 1 37\ngithub.com/pterm/pterm/progressbar_printer.go:233.8,235.3 1 14277\ngithub.com/pterm/pterm/progressbar_printer.go:237.16,239.3 1 6871\ngithub.com/pterm/pterm/progressbar_printer.go:244.65,245.18 1 18\ngithub.com/pterm/pterm/progressbar_printer.go:249.2,252.26 3 17\ngithub.com/pterm/pterm/progressbar_printer.go:255.2,255.10 1 17\ngithub.com/pterm/pterm/progressbar_printer.go:245.18,247.3 1 1\ngithub.com/pterm/pterm/progressbar_printer.go:252.26,254.3 1 1\ngithub.com/pterm/pterm/progressbar_printer.go:259.66,260.30 1 7\ngithub.com/pterm/pterm/progressbar_printer.go:263.2,269.16 5 7\ngithub.com/pterm/pterm/progressbar_printer.go:260.30,262.3 1 1\ngithub.com/pterm/pterm/progressbar_printer.go:273.66,274.17 1 10\ngithub.com/pterm/pterm/progressbar_printer.go:277.2,278.22 2 3\ngithub.com/pterm/pterm/progressbar_printer.go:284.2,284.15 1 3\ngithub.com/pterm/pterm/progressbar_printer.go:274.17,276.3 1 7\ngithub.com/pterm/pterm/progressbar_printer.go:278.22,281.3 2 1\ngithub.com/pterm/pterm/progressbar_printer.go:281.8,283.3 1 2\ngithub.com/pterm/pterm/progressbar_printer.go:290.66,294.2 3 2\ngithub.com/pterm/pterm/progressbar_printer.go:299.65,303.2 3 1\ngithub.com/pterm/pterm/progressbar_printer.go:306.61,308.2 1 14314\ngithub.com/pterm/pterm/progressbar_printer.go:310.56,313.2 2 14313\ngithub.com/pterm/pterm/prefix_printer.go:101.65,104.2 2 10\ngithub.com/pterm/pterm/prefix_printer.go:107.62,110.2 2 100\ngithub.com/pterm/pterm/prefix_printer.go:113.70,116.2 2 5\ngithub.com/pterm/pterm/prefix_printer.go:122.60,125.2 2 11\ngithub.com/pterm/pterm/prefix_printer.go:128.69,131.2 2 95\ngithub.com/pterm/pterm/prefix_printer.go:136.63,139.2 2 75\ngithub.com/pterm/pterm/prefix_printer.go:144.72,147.2 2 5\ngithub.com/pterm/pterm/prefix_printer.go:150.74,153.2 2 0\ngithub.com/pterm/pterm/prefix_printer.go:157.57,159.39 2 10852\ngithub.com/pterm/pterm/prefix_printer.go:163.2,163.15 1 10762\ngithub.com/pterm/pterm/prefix_printer.go:171.2,171.27 1 5110\ngithub.com/pterm/pterm/prefix_printer.go:174.2,174.26 1 5110\ngithub.com/pterm/pterm/prefix_printer.go:177.2,177.27 1 5110\ngithub.com/pterm/pterm/prefix_printer.go:181.2,184.32 3 5110\ngithub.com/pterm/pterm/prefix_printer.go:189.2,190.33 2 5110\ngithub.com/pterm/pterm/prefix_printer.go:202.2,204.22 2 5110\ngithub.com/pterm/pterm/prefix_printer.go:209.2,209.13 1 5110\ngithub.com/pterm/pterm/prefix_printer.go:213.2,213.20 1 5110\ngithub.com/pterm/pterm/prefix_printer.go:159.39,161.3 1 90\ngithub.com/pterm/pterm/prefix_printer.go:163.15,164.26 1 5652\ngithub.com/pterm/pterm/prefix_printer.go:164.26,166.4 1 5607\ngithub.com/pterm/pterm/prefix_printer.go:166.9,168.4 1 45\ngithub.com/pterm/pterm/prefix_printer.go:171.27,173.3 1 1\ngithub.com/pterm/pterm/prefix_printer.go:174.26,176.3 1 1663\ngithub.com/pterm/pterm/prefix_printer.go:177.27,179.3 1 1\ngithub.com/pterm/pterm/prefix_printer.go:184.32,187.3 2 3095\ngithub.com/pterm/pterm/prefix_printer.go:190.33,191.13 1 5133\ngithub.com/pterm/pterm/prefix_printer.go:191.13,193.26 2 5110\ngithub.com/pterm/pterm/prefix_printer.go:196.4,196.35 1 5110\ngithub.com/pterm/pterm/prefix_printer.go:193.26,195.5 1 50\ngithub.com/pterm/pterm/prefix_printer.go:197.9,199.4 1 23\ngithub.com/pterm/pterm/prefix_printer.go:204.22,207.3 2 45\ngithub.com/pterm/pterm/prefix_printer.go:209.13,211.3 1 3095\ngithub.com/pterm/pterm/prefix_printer.go:218.58,219.39 1 6600\ngithub.com/pterm/pterm/prefix_printer.go:222.2,223.22 2 6510\ngithub.com/pterm/pterm/prefix_printer.go:219.39,221.3 1 90\ngithub.com/pterm/pterm/prefix_printer.go:227.72,228.39 1 3695\ngithub.com/pterm/pterm/prefix_printer.go:231.2,231.40 1 3605\ngithub.com/pterm/pterm/prefix_printer.go:228.39,230.3 1 90\ngithub.com/pterm/pterm/prefix_printer.go:236.74,237.39 1 3330\ngithub.com/pterm/pterm/prefix_printer.go:240.2,240.39 1 3240\ngithub.com/pterm/pterm/prefix_printer.go:237.39,239.3 1 90\ngithub.com/pterm/pterm/prefix_printer.go:246.62,248.39 2 420\ngithub.com/pterm/pterm/prefix_printer.go:251.2,253.12 3 410\ngithub.com/pterm/pterm/prefix_printer.go:248.39,250.3 1 10\ngithub.com/pterm/pterm/prefix_printer.go:259.64,261.39 2 3280\ngithub.com/pterm/pterm/prefix_printer.go:264.2,266.12 3 3270\ngithub.com/pterm/pterm/prefix_printer.go:261.39,263.3 1 10\ngithub.com/pterm/pterm/prefix_printer.go:271.78,273.39 2 190\ngithub.com/pterm/pterm/prefix_printer.go:276.2,278.12 3 180\ngithub.com/pterm/pterm/prefix_printer.go:273.39,275.3 1 10\ngithub.com/pterm/pterm/prefix_printer.go:284.80,286.39 2 1630\ngithub.com/pterm/pterm/prefix_printer.go:289.2,291.12 3 1620\ngithub.com/pterm/pterm/prefix_printer.go:286.39,288.3 1 10\ngithub.com/pterm/pterm/prefix_printer.go:299.69,300.24 1 10\ngithub.com/pterm/pterm/prefix_printer.go:308.2,309.12 2 10\ngithub.com/pterm/pterm/prefix_printer.go:300.24,301.33 1 10\ngithub.com/pterm/pterm/prefix_printer.go:301.33,302.18 1 5\ngithub.com/pterm/pterm/prefix_printer.go:302.18,304.5 1 5\ngithub.com/pterm/pterm/prefix_printer.go:315.85,316.24 1 10\ngithub.com/pterm/pterm/prefix_printer.go:324.2,325.12 2 10\ngithub.com/pterm/pterm/prefix_printer.go:316.24,317.33 1 10\ngithub.com/pterm/pterm/prefix_printer.go:317.33,318.18 1 5\ngithub.com/pterm/pterm/prefix_printer.go:318.18,320.5 1 5\ngithub.com/pterm/pterm/prefix_printer.go:329.52,331.2 1 5115\ngithub.com/pterm/pterm/prefix_printer.go:346.35,347.13 1 5480\ngithub.com/pterm/pterm/prefix_printer.go:347.13,348.12 1 5\ngithub.com/pterm/pterm/area_printer.go:28.43,30.2 1 9\ngithub.com/pterm/pterm/area_printer.go:33.65,36.2 2 3\ngithub.com/pterm/pterm/area_printer.go:39.61,42.2 2 2\ngithub.com/pterm/pterm/area_printer.go:45.57,48.2 2 1\ngithub.com/pterm/pterm/area_printer.go:52.51,53.19 1 18\ngithub.com/pterm/pterm/area_printer.go:57.2,60.14 3 18\ngithub.com/pterm/pterm/area_printer.go:64.2,64.18 1 18\ngithub.com/pterm/pterm/area_printer.go:82.2,82.20 1 18\ngithub.com/pterm/pterm/area_printer.go:53.19,56.3 2 2\ngithub.com/pterm/pterm/area_printer.go:60.14,62.3 1 2\ngithub.com/pterm/pterm/area_printer.go:64.18,72.15 6 2\ngithub.com/pterm/pterm/area_printer.go:77.3,77.29 1 2\ngithub.com/pterm/pterm/area_printer.go:72.15,75.4 2 2\ngithub.com/pterm/pterm/area_printer.go:77.29,80.4 2 2\ngithub.com/pterm/pterm/area_printer.go:86.72,95.2 6 5\ngithub.com/pterm/pterm/area_printer.go:99.36,101.22 2 4\ngithub.com/pterm/pterm/area_printer.go:104.2,104.12 1 4\ngithub.com/pterm/pterm/area_printer.go:101.22,103.3 1 2\ngithub.com/pterm/pterm/area_printer.go:110.60,114.2 3 2\ngithub.com/pterm/pterm/area_printer.go:119.59,123.2 3 1\ngithub.com/pterm/pterm/area_printer.go:128.31,130.2 1 3\ngithub.com/pterm/pterm/bulletlist_printer.go:11.77,13.25 2 2\ngithub.com/pterm/pterm/bulletlist_printer.go:16.2,16.42 1 2\ngithub.com/pterm/pterm/bulletlist_printer.go:13.25,15.3 1 8\ngithub.com/pterm/pterm/bulletlist_printer.go:20.78,26.2 2 8\ngithub.com/pterm/pterm/bulletlist_printer.go:38.62,41.2 2 1\ngithub.com/pterm/pterm/bulletlist_printer.go:44.63,47.2 2 1\ngithub.com/pterm/pterm/bulletlist_printer.go:50.69,53.2 2 1\ngithub.com/pterm/pterm/bulletlist_printer.go:56.67,59.2 2 1\ngithub.com/pterm/pterm/bulletlist_printer.go:62.71,65.2 2 1\ngithub.com/pterm/pterm/bulletlist_printer.go:68.74,70.2 1 2\ngithub.com/pterm/pterm/bulletlist_printer.go:89.81,92.2 2 76\ngithub.com/pterm/pterm/bulletlist_printer.go:95.75,98.2 2 1\ngithub.com/pterm/pterm/bulletlist_printer.go:101.73,104.2 2 1\ngithub.com/pterm/pterm/bulletlist_printer.go:107.77,110.2 2 1\ngithub.com/pterm/pterm/bulletlist_printer.go:113.82,116.2 2 0\ngithub.com/pterm/pterm/bulletlist_printer.go:119.43,124.2 3 56\ngithub.com/pterm/pterm/bulletlist_printer.go:127.54,129.31 2 74\ngithub.com/pterm/pterm/bulletlist_printer.go:150.2,150.17 1 74\ngithub.com/pterm/pterm/bulletlist_printer.go:129.31,130.28 1 74\ngithub.com/pterm/pterm/bulletlist_printer.go:137.3,137.30 1 74\ngithub.com/pterm/pterm/bulletlist_printer.go:144.3,144.24 1 74\ngithub.com/pterm/pterm/bulletlist_printer.go:130.28,131.26 1 74\ngithub.com/pterm/pterm/bulletlist_printer.go:131.26,133.5 1 18\ngithub.com/pterm/pterm/bulletlist_printer.go:133.10,135.5 1 56\ngithub.com/pterm/pterm/bulletlist_printer.go:137.30,138.28 1 74\ngithub.com/pterm/pterm/bulletlist_printer.go:138.28,140.5 1 18\ngithub.com/pterm/pterm/bulletlist_printer.go:140.10,142.5 1 56\ngithub.com/pterm/pterm/bulletlist_printer.go:144.24,146.4 1 56\ngithub.com/pterm/pterm/bulletlist_printer.go:146.9,148.4 1 18\ngithub.com/pterm/pterm/header_printer.go:35.67,38.2 2 1\ngithub.com/pterm/pterm/header_printer.go:41.73,44.2 2 3\ngithub.com/pterm/pterm/header_printer.go:47.62,50.2 2 3\ngithub.com/pterm/pterm/header_printer.go:53.64,56.2 2 21\ngithub.com/pterm/pterm/header_printer.go:59.74,62.2 2 0\ngithub.com/pterm/pterm/header_printer.go:66.56,67.15 1 1393\ngithub.com/pterm/pterm/header_printer.go:71.2,71.24 1 664\ngithub.com/pterm/pterm/header_printer.go:74.2,74.30 1 664\ngithub.com/pterm/pterm/header_printer.go:78.2,85.17 5 664\ngithub.com/pterm/pterm/header_printer.go:98.2,101.17 3 664\ngithub.com/pterm/pterm/header_printer.go:108.2,109.49 2 664\ngithub.com/pterm/pterm/header_printer.go:117.2,119.12 2 664\ngithub.com/pterm/pterm/header_printer.go:67.15,69.3 1 729\ngithub.com/pterm/pterm/header_printer.go:71.24,73.3 1 3\ngithub.com/pterm/pterm/header_printer.go:74.30,76.3 1 3\ngithub.com/pterm/pterm/header_printer.go:85.17,88.3 2 11\ngithub.com/pterm/pterm/header_printer.go:88.8,89.42 1 653\ngithub.com/pterm/pterm/header_printer.go:89.42,92.4 2 1\ngithub.com/pterm/pterm/header_printer.go:92.9,95.4 2 652\ngithub.com/pterm/pterm/header_printer.go:101.17,104.3 2 11\ngithub.com/pterm/pterm/header_printer.go:104.8,106.3 1 653\ngithub.com/pterm/pterm/header_printer.go:109.49,112.69 3 666\ngithub.com/pterm/pterm/header_printer.go:115.3,115.67 1 666\ngithub.com/pterm/pterm/header_printer.go:112.69,114.4 1 8\ngithub.com/pterm/pterm/header_printer.go:122.47,125.32 3 664\ngithub.com/pterm/pterm/header_printer.go:146.2,147.26 2 664\ngithub.com/pterm/pterm/header_printer.go:151.2,151.39 1 664\ngithub.com/pterm/pterm/header_printer.go:125.32,126.65 1 664\ngithub.com/pterm/pterm/header_printer.go:126.65,129.32 3 2\ngithub.com/pterm/pterm/header_printer.go:136.4,136.41 1 2\ngithub.com/pterm/pterm/header_printer.go:129.32,130.31 1 272\ngithub.com/pterm/pterm/header_printer.go:134.5,134.52 1 272\ngithub.com/pterm/pterm/header_printer.go:130.31,133.6 2 2\ngithub.com/pterm/pterm/header_printer.go:136.41,139.5 2 4\ngithub.com/pterm/pterm/header_printer.go:140.9,143.4 2 662\ngithub.com/pterm/pterm/header_printer.go:147.26,149.3 1 666\ngithub.com/pterm/pterm/header_printer.go:156.58,158.2 1 652\ngithub.com/pterm/pterm/header_printer.go:161.72,163.2 1 684\ngithub.com/pterm/pterm/header_printer.go:167.74,169.2 1 648\ngithub.com/pterm/pterm/header_printer.go:174.62,178.2 3 36\ngithub.com/pterm/pterm/header_printer.go:183.64,187.2 3 328\ngithub.com/pterm/pterm/header_printer.go:191.78,195.2 3 18\ngithub.com/pterm/pterm/header_printer.go:200.80,204.2 3 324\ngithub.com/pterm/pterm/header_printer.go:209.69,210.24 1 2\ngithub.com/pterm/pterm/header_printer.go:218.2,219.12 2 2\ngithub.com/pterm/pterm/header_printer.go:210.24,211.33 1 2\ngithub.com/pterm/pterm/header_printer.go:211.33,212.18 1 1\ngithub.com/pterm/pterm/header_printer.go:212.18,214.5 1 1\ngithub.com/pterm/pterm/header_printer.go:225.85,226.24 1 2\ngithub.com/pterm/pterm/header_printer.go:234.2,235.12 2 2\ngithub.com/pterm/pterm/header_printer.go:226.24,227.33 1 2\ngithub.com/pterm/pterm/header_printer.go:227.33,228.18 1 1\ngithub.com/pterm/pterm/header_printer.go:228.18,230.5 1 1\ngithub.com/pterm/pterm/center_printer.go:25.79,29.2 3 3\ngithub.com/pterm/pterm/center_printer.go:32.74,35.2 2 0\ngithub.com/pterm/pterm/center_printer.go:39.56,40.15 1 2096\ngithub.com/pterm/pterm/center_printer.go:44.2,48.32 3 998\ngithub.com/pterm/pterm/center_printer.go:60.2,62.29 2 655\ngithub.com/pterm/pterm/center_printer.go:69.2,71.18 2 655\ngithub.com/pterm/pterm/center_printer.go:79.2,79.29 1 653\ngithub.com/pterm/pterm/center_printer.go:83.2,83.12 1 653\ngithub.com/pterm/pterm/center_printer.go:40.15,42.3 1 1098\ngithub.com/pterm/pterm/center_printer.go:48.32,49.30 1 343\ngithub.com/pterm/pterm/center_printer.go:57.3,57.13 1 343\ngithub.com/pterm/pterm/center_printer.go:49.30,51.18 2 649\ngithub.com/pterm/pterm/center_printer.go:51.18,53.5 1 1\ngithub.com/pterm/pterm/center_printer.go:53.10,55.5 1 648\ngithub.com/pterm/pterm/center_printer.go:62.29,64.32 2 971\ngithub.com/pterm/pterm/center_printer.go:64.32,66.4 1 654\ngithub.com/pterm/pterm/center_printer.go:71.18,72.30 1 2\ngithub.com/pterm/pterm/center_printer.go:76.3,76.13 1 2\ngithub.com/pterm/pterm/center_printer.go:72.30,74.4 1 5\ngithub.com/pterm/pterm/center_printer.go:79.29,81.3 1 966\ngithub.com/pterm/pterm/center_printer.go:88.58,90.2 1 1298\ngithub.com/pterm/pterm/center_printer.go:93.72,95.2 1 720\ngithub.com/pterm/pterm/center_printer.go:99.74,101.2 1 648\ngithub.com/pterm/pterm/center_printer.go:106.61,110.2 3 38\ngithub.com/pterm/pterm/center_printer.go:115.63,119.2 3 650\ngithub.com/pterm/pterm/center_printer.go:123.77,127.2 3 36\ngithub.com/pterm/pterm/center_printer.go:132.79,136.2 3 324\ngithub.com/pterm/pterm/center_printer.go:141.68,142.24 1 2\ngithub.com/pterm/pterm/center_printer.go:150.2,151.12 2 2\ngithub.com/pterm/pterm/center_printer.go:142.24,143.33 1 2\ngithub.com/pterm/pterm/center_printer.go:143.33,144.18 1 1\ngithub.com/pterm/pterm/center_printer.go:144.18,146.5 1 1\ngithub.com/pterm/pterm/center_printer.go:157.84,158.24 1 2\ngithub.com/pterm/pterm/center_printer.go:166.2,167.12 2 2\ngithub.com/pterm/pterm/center_printer.go:158.24,159.33 1 2\ngithub.com/pterm/pterm/center_printer.go:159.33,160.18 1 1\ngithub.com/pterm/pterm/center_printer.go:160.18,162.5 1 1\ngithub.com/pterm/pterm/table_printer.go:48.61,51.2 2 1\ngithub.com/pterm/pterm/table_printer.go:54.62,57.2 2 9\ngithub.com/pterm/pterm/table_printer.go:60.67,63.2 2 1\ngithub.com/pterm/pterm/table_printer.go:66.78,69.2 2 4\ngithub.com/pterm/pterm/table_printer.go:72.79,75.2 2 1\ngithub.com/pterm/pterm/table_printer.go:78.69,81.2 2 1\ngithub.com/pterm/pterm/table_printer.go:84.70,87.2 2 1\ngithub.com/pterm/pterm/table_printer.go:90.72,93.2 2 3\ngithub.com/pterm/pterm/table_printer.go:96.73,99.2 2 1\ngithub.com/pterm/pterm/table_printer.go:102.63,105.2 2 9\ngithub.com/pterm/pterm/table_printer.go:108.71,109.50 1 1\ngithub.com/pterm/pterm/table_printer.go:112.2,112.11 1 1\ngithub.com/pterm/pterm/table_printer.go:109.50,111.3 1 1\ngithub.com/pterm/pterm/table_printer.go:116.58,119.2 2 1\ngithub.com/pterm/pterm/table_printer.go:122.66,127.2 4 2\ngithub.com/pterm/pterm/table_printer.go:130.67,135.2 4 2\ngithub.com/pterm/pterm/table_printer.go:138.72,141.2 2 0\ngithub.com/pterm/pterm/table_printer.go:144.49,145.20 1 10\ngithub.com/pterm/pterm/table_printer.go:148.2,148.29 1 10\ngithub.com/pterm/pterm/table_printer.go:151.2,151.26 1 10\ngithub.com/pterm/pterm/table_printer.go:154.2,154.38 1 10\ngithub.com/pterm/pterm/table_printer.go:157.2,157.32 1 10\ngithub.com/pterm/pterm/table_printer.go:161.2,164.29 3 10\ngithub.com/pterm/pterm/table_printer.go:173.2,173.30 1 10\ngithub.com/pterm/pterm/table_printer.go:202.2,204.13 2 10\ngithub.com/pterm/pterm/table_printer.go:208.2,208.17 1 10\ngithub.com/pterm/pterm/table_printer.go:145.20,147.3 1 1\ngithub.com/pterm/pterm/table_printer.go:148.29,150.3 1 1\ngithub.com/pterm/pterm/table_printer.go:151.26,153.3 1 1\ngithub.com/pterm/pterm/table_printer.go:154.38,156.3 1 1\ngithub.com/pterm/pterm/table_printer.go:157.32,159.3 1 1\ngithub.com/pterm/pterm/table_printer.go:164.29,165.31 1 41\ngithub.com/pterm/pterm/table_printer.go:165.31,167.41 2 123\ngithub.com/pterm/pterm/table_printer.go:167.41,169.5 1 33\ngithub.com/pterm/pterm/table_printer.go:173.30,175.31 2 41\ngithub.com/pterm/pterm/table_printer.go:191.3,191.59 1 41\ngithub.com/pterm/pterm/table_printer.go:195.3,195.61 1 41\ngithub.com/pterm/pterm/table_printer.go:199.3,199.14 1 41\ngithub.com/pterm/pterm/table_printer.go:175.31,179.33 3 123\ngithub.com/pterm/pterm/table_printer.go:184.4,184.30 1 123\ngithub.com/pterm/pterm/table_printer.go:179.33,182.5 2 82\ngithub.com/pterm/pterm/table_printer.go:184.30,186.5 1 24\ngithub.com/pterm/pterm/table_printer.go:186.10,188.5 1 99\ngithub.com/pterm/pterm/table_printer.go:191.59,193.4 1 3\ngithub.com/pterm/pterm/table_printer.go:195.61,197.4 1 4\ngithub.com/pterm/pterm/table_printer.go:204.13,206.3 1 1\ngithub.com/pterm/pterm/table_printer.go:211.82,213.22 2 123\ngithub.com/pterm/pterm/table_printer.go:216.2,216.64 1 111\ngithub.com/pterm/pterm/table_printer.go:213.22,215.3 1 12\ngithub.com/pterm/pterm/table_printer.go:219.75,221.2 1 3\ngithub.com/pterm/pterm/table_printer.go:223.69,225.2 1 4\ngithub.com/pterm/pterm/table_printer.go:228.38,233.2 3 9\ngithub.com/pterm/pterm/barchart.go:44.63,47.2 2 14\ngithub.com/pterm/pterm/barchart.go:50.81,53.2 2 1\ngithub.com/pterm/pterm/barchart.go:56.83,59.2 2 1\ngithub.com/pterm/pterm/barchart.go:62.69,66.2 3 5\ngithub.com/pterm/pterm/barchart.go:69.65,72.2 2 1\ngithub.com/pterm/pterm/barchart.go:75.64,78.2 2 1\ngithub.com/pterm/pterm/barchart.go:81.68,84.2 2 11\ngithub.com/pterm/pterm/barchart.go:87.78,90.2 2 0\ngithub.com/pterm/pterm/barchart.go:92.48,95.29 2 1\ngithub.com/pterm/pterm/barchart.go:99.2,99.12 1 1\ngithub.com/pterm/pterm/barchart.go:95.29,97.3 1 6\ngithub.com/pterm/pterm/barchart.go:103.52,104.50 1 15\ngithub.com/pterm/pterm/barchart.go:122.2,122.29 1 15\ngithub.com/pterm/pterm/barchart.go:131.2,144.82 2 15\ngithub.com/pterm/pterm/barchart.go:168.2,168.82 1 15\ngithub.com/pterm/pterm/barchart.go:183.2,183.84 1 15\ngithub.com/pterm/pterm/barchart.go:207.2,207.84 1 15\ngithub.com/pterm/pterm/barchart.go:248.2,248.15 1 15\ngithub.com/pterm/pterm/barchart.go:251.2,251.29 1 14\ngithub.com/pterm/pterm/barchart.go:263.2,271.29 7 14\ngithub.com/pterm/pterm/barchart.go:284.2,286.18 2 14\ngithub.com/pterm/pterm/barchart.go:415.2,415.17 1 10\ngithub.com/pterm/pterm/barchart.go:104.50,108.22 3 14\ngithub.com/pterm/pterm/barchart.go:113.3,115.28 2 14\ngithub.com/pterm/pterm/barchart.go:119.3,119.16 1 14\ngithub.com/pterm/pterm/barchart.go:108.22,111.4 2 11\ngithub.com/pterm/pterm/barchart.go:115.28,117.4 1 4\ngithub.com/pterm/pterm/barchart.go:122.29,123.16 1 4\ngithub.com/pterm/pterm/barchart.go:127.3,127.15 1 2\ngithub.com/pterm/pterm/barchart.go:123.16,125.4 1 2\ngithub.com/pterm/pterm/barchart.go:144.82,145.24 1 16\ngithub.com/pterm/pterm/barchart.go:149.3,149.56 1 16\ngithub.com/pterm/pterm/barchart.go:161.3,161.21 1 16\ngithub.com/pterm/pterm/barchart.go:145.24,147.4 1 9\ngithub.com/pterm/pterm/barchart.go:149.56,150.31 1 560\ngithub.com/pterm/pterm/barchart.go:150.31,152.5 1 180\ngithub.com/pterm/pterm/barchart.go:152.10,154.5 1 380\ngithub.com/pterm/pterm/barchart.go:161.21,162.58 1 4\ngithub.com/pterm/pterm/barchart.go:162.58,164.5 1 60\ngithub.com/pterm/pterm/barchart.go:168.82,169.57 1 14\ngithub.com/pterm/pterm/barchart.go:177.3,177.24 1 14\ngithub.com/pterm/pterm/barchart.go:169.57,170.31 1 508\ngithub.com/pterm/pterm/barchart.go:170.31,172.5 1 393\ngithub.com/pterm/pterm/barchart.go:172.10,174.5 1 115\ngithub.com/pterm/pterm/barchart.go:177.24,179.4 1 12\ngithub.com/pterm/pterm/barchart.go:183.84,184.24 1 11\ngithub.com/pterm/pterm/barchart.go:190.3,190.55 1 11\ngithub.com/pterm/pterm/barchart.go:198.3,198.24 1 11\ngithub.com/pterm/pterm/barchart.go:184.24,185.56 1 3\ngithub.com/pterm/pterm/barchart.go:185.56,187.5 1 45\ngithub.com/pterm/pterm/barchart.go:190.55,191.31 1 502\ngithub.com/pterm/pterm/barchart.go:191.31,193.5 1 243\ngithub.com/pterm/pterm/barchart.go:193.10,195.5 1 259\ngithub.com/pterm/pterm/barchart.go:198.24,204.4 2 11\ngithub.com/pterm/pterm/barchart.go:207.84,208.56 1 10\ngithub.com/pterm/pterm/barchart.go:218.3,218.41 1 10\ngithub.com/pterm/pterm/barchart.go:224.3,224.24 1 10\ngithub.com/pterm/pterm/barchart.go:208.56,209.31 1 454\ngithub.com/pterm/pterm/barchart.go:209.31,211.5 1 310\ngithub.com/pterm/pterm/barchart.go:211.10,213.5 1 144\ngithub.com/pterm/pterm/barchart.go:218.41,219.56 1 2\ngithub.com/pterm/pterm/barchart.go:219.56,221.5 1 52\ngithub.com/pterm/pterm/barchart.go:224.24,239.32 1 10\ngithub.com/pterm/pterm/barchart.go:243.4,243.60 1 10\ngithub.com/pterm/pterm/barchart.go:239.32,241.5 1 2\ngithub.com/pterm/pterm/barchart.go:248.15,250.3 1 1\ngithub.com/pterm/pterm/barchart.go:251.29,252.23 1 51\ngithub.com/pterm/pterm/barchart.go:256.3,256.28 1 51\ngithub.com/pterm/pterm/barchart.go:260.3,260.59 1 51\ngithub.com/pterm/pterm/barchart.go:252.23,254.4 1 3\ngithub.com/pterm/pterm/barchart.go:256.28,258.4 1 48\ngithub.com/pterm/pterm/barchart.go:271.29,272.30 1 51\ngithub.com/pterm/pterm/barchart.go:275.3,275.30 1 51\ngithub.com/pterm/pterm/barchart.go:278.3,279.35 2 51\ngithub.com/pterm/pterm/barchart.go:272.30,274.4 1 13\ngithub.com/pterm/pterm/barchart.go:275.30,277.4 1 8\ngithub.com/pterm/pterm/barchart.go:279.35,281.4 1 15\ngithub.com/pterm/pterm/barchart.go:286.18,294.41 5 4\ngithub.com/pterm/pterm/barchart.go:299.3,299.30 1 4\ngithub.com/pterm/pterm/barchart.go:331.3,332.18 2 4\ngithub.com/pterm/pterm/barchart.go:294.41,297.4 2 1\ngithub.com/pterm/pterm/barchart.go:299.30,304.24 4 21\ngithub.com/pterm/pterm/barchart.go:304.24,310.5 3 8\ngithub.com/pterm/pterm/barchart.go:310.10,310.31 1 13\ngithub.com/pterm/pterm/barchart.go:310.31,316.5 3 8\ngithub.com/pterm/pterm/barchart.go:316.10,320.23 2 5\ngithub.com/pterm/pterm/barchart.go:326.5,326.22 1 5\ngithub.com/pterm/pterm/barchart.go:320.23,324.6 2 3\ngithub.com/pterm/pterm/barchart.go:326.22,328.6 1 2\ngithub.com/pterm/pterm/barchart.go:333.8,341.41 5 10\ngithub.com/pterm/pterm/barchart.go:346.3,346.30 1 10\ngithub.com/pterm/pterm/barchart.go:381.3,383.36 2 10\ngithub.com/pterm/pterm/barchart.go:390.3,390.36 1 10\ngithub.com/pterm/pterm/barchart.go:397.3,397.38 1 10\ngithub.com/pterm/pterm/barchart.go:341.41,344.4 2 1\ngithub.com/pterm/pterm/barchart.go:346.30,351.24 4 30\ngithub.com/pterm/pterm/barchart.go:377.4,378.102 2 30\ngithub.com/pterm/pterm/barchart.go:351.24,357.5 3 12\ngithub.com/pterm/pterm/barchart.go:357.10,357.31 1 18\ngithub.com/pterm/pterm/barchart.go:357.31,362.5 2 12\ngithub.com/pterm/pterm/barchart.go:362.10,366.23 2 6\ngithub.com/pterm/pterm/barchart.go:372.5,372.22 1 6\ngithub.com/pterm/pterm/barchart.go:366.23,370.6 2 4\ngithub.com/pterm/pterm/barchart.go:372.22,374.6 1 2\ngithub.com/pterm/pterm/barchart.go:383.36,385.37 2 30\ngithub.com/pterm/pterm/barchart.go:385.37,387.5 1 9\ngithub.com/pterm/pterm/barchart.go:390.36,392.37 2 30\ngithub.com/pterm/pterm/barchart.go:392.37,394.5 1 2\ngithub.com/pterm/pterm/barchart.go:397.38,398.43 1 383\ngithub.com/pterm/pterm/barchart.go:411.4,411.15 1 383\ngithub.com/pterm/pterm/barchart.go:398.43,402.29 4 1257\ngithub.com/pterm/pterm/barchart.go:405.5,406.39 2 1257\ngithub.com/pterm/pterm/barchart.go:409.5,409.19 1 1257\ngithub.com/pterm/pterm/barchart.go:402.29,404.6 1 1227\ngithub.com/pterm/pterm/barchart.go:406.39,408.6 1 712\ngithub.com/pterm/pterm/barchart.go:419.41,424.2 3 14\ngithub.com/pterm/pterm/pterm.go:22.13,24.2 1 1\ngithub.com/pterm/pterm/pterm.go:27.21,29.2 1 1\ngithub.com/pterm/pterm/pterm.go:32.22,34.2 1 2\ngithub.com/pterm/pterm/pterm.go:37.28,39.2 1 31\ngithub.com/pterm/pterm/pterm.go:42.29,44.2 1 36\ngithub.com/pterm/pterm/pterm.go:48.22,51.2 2 14223\ngithub.com/pterm/pterm/pterm.go:56.23,59.2 2 14223\ngithub.com/pterm/pterm/pterm.go:62.32,67.2 3 10\ngithub.com/pterm/pterm/terminal.go:24.29,25.29 1 30970\ngithub.com/pterm/pterm/terminal.go:28.2,29.14 2 7\ngithub.com/pterm/pterm/terminal.go:25.29,27.3 1 30963\ngithub.com/pterm/pterm/terminal.go:33.30,34.30 1 17\ngithub.com/pterm/pterm/terminal.go:37.2,38.15 2 4\ngithub.com/pterm/pterm/terminal.go:34.30,36.3 1 13\ngithub.com/pterm/pterm/terminal.go:42.55,43.57 1 13\ngithub.com/pterm/pterm/terminal.go:46.2,47.12 2 12\ngithub.com/pterm/pterm/terminal.go:50.2,50.12 1 12\ngithub.com/pterm/pterm/terminal.go:53.2,53.16 1 12\ngithub.com/pterm/pterm/terminal.go:56.2,56.18 1 12\ngithub.com/pterm/pterm/terminal.go:43.57,45.3 1 1\ngithub.com/pterm/pterm/terminal.go:47.12,49.3 1 12\ngithub.com/pterm/pterm/terminal.go:50.12,52.3 1 12\ngithub.com/pterm/pterm/terminal.go:53.16,55.3 1 12\ngithub.com/pterm/pterm/terminal.go:60.51,64.2 3 10\ngithub.com/pterm/pterm/paragraph_printer.go:23.69,26.2 2 1\ngithub.com/pterm/pterm/paragraph_printer.go:29.80,32.2 2 0\ngithub.com/pterm/pterm/paragraph_printer.go:36.59,37.15 1 1373\ngithub.com/pterm/pterm/paragraph_printer.go:41.2,42.21 2 653\ngithub.com/pterm/pterm/paragraph_printer.go:45.2,47.33 3 652\ngithub.com/pterm/pterm/paragraph_printer.go:57.2,57.16 1 652\ngithub.com/pterm/pterm/paragraph_printer.go:37.15,39.3 1 720\ngithub.com/pterm/pterm/paragraph_printer.go:42.21,44.3 1 1\ngithub.com/pterm/pterm/paragraph_printer.go:47.33,48.30 1 405\ngithub.com/pterm/pterm/paragraph_printer.go:48.30,51.4 2 3\ngithub.com/pterm/pterm/paragraph_printer.go:51.9,54.4 2 402\ngithub.com/pterm/pterm/paragraph_printer.go:62.61,64.2 1 651\ngithub.com/pterm/pterm/paragraph_printer.go:67.75,69.2 1 684\ngithub.com/pterm/pterm/paragraph_printer.go:73.77,75.2 1 648\ngithub.com/pterm/pterm/paragraph_printer.go:80.65,84.2 3 20\ngithub.com/pterm/pterm/paragraph_printer.go:89.67,93.2 3 327\ngithub.com/pterm/pterm/paragraph_printer.go:97.81,101.2 3 18\ngithub.com/pterm/pterm/paragraph_printer.go:106.83,110.2 3 324\ngithub.com/pterm/pterm/paragraph_printer.go:115.72,116.24 1 2\ngithub.com/pterm/pterm/paragraph_printer.go:124.2,125.12 2 2\ngithub.com/pterm/pterm/paragraph_printer.go:116.24,117.33 1 2\ngithub.com/pterm/pterm/paragraph_printer.go:117.33,118.18 1 1\ngithub.com/pterm/pterm/paragraph_printer.go:118.18,120.5 1 1\ngithub.com/pterm/pterm/paragraph_printer.go:131.88,132.24 1 2\ngithub.com/pterm/pterm/paragraph_printer.go:140.2,141.12 2 2\ngithub.com/pterm/pterm/paragraph_printer.go:132.24,133.33 1 2\ngithub.com/pterm/pterm/paragraph_printer.go:133.33,134.18 1 1\ngithub.com/pterm/pterm/paragraph_printer.go:134.18,136.5 1 1\ngithub.com/pterm/pterm/section_printer.go:30.65,33.2 2 2\ngithub.com/pterm/pterm/section_printer.go:36.62,39.2 2 4\ngithub.com/pterm/pterm/section_printer.go:42.74,45.2 2 1\ngithub.com/pterm/pterm/section_printer.go:48.69,51.2 2 2\ngithub.com/pterm/pterm/section_printer.go:54.72,57.2 2 2\ngithub.com/pterm/pterm/section_printer.go:60.76,63.2 2 0\ngithub.com/pterm/pterm/section_printer.go:67.57,68.20 1 1379\ngithub.com/pterm/pterm/section_printer.go:72.2,74.36 2 1379\ngithub.com/pterm/pterm/section_printer.go:78.2,78.17 1 1379\ngithub.com/pterm/pterm/section_printer.go:82.2,84.39 2 1379\ngithub.com/pterm/pterm/section_printer.go:88.2,88.12 1 1379\ngithub.com/pterm/pterm/section_printer.go:68.20,70.3 1 1\ngithub.com/pterm/pterm/section_printer.go:74.36,76.3 1 1375\ngithub.com/pterm/pterm/section_printer.go:78.17,80.3 1 1378\ngithub.com/pterm/pterm/section_printer.go:84.39,86.3 1 1375\ngithub.com/pterm/pterm/section_printer.go:93.59,96.2 2 657\ngithub.com/pterm/pterm/section_printer.go:99.73,101.2 1 686\ngithub.com/pterm/pterm/section_printer.go:105.75,107.2 1 650\ngithub.com/pterm/pterm/section_printer.go:112.63,116.2 3 18\ngithub.com/pterm/pterm/section_printer.go:121.65,125.2 3 333\ngithub.com/pterm/pterm/section_printer.go:129.79,133.2 3 18\ngithub.com/pterm/pterm/section_printer.go:138.81,142.2 3 326\ngithub.com/pterm/pterm/section_printer.go:147.70,148.24 1 2\ngithub.com/pterm/pterm/section_printer.go:156.2,157.12 2 2\ngithub.com/pterm/pterm/section_printer.go:148.24,149.33 1 2\ngithub.com/pterm/pterm/section_printer.go:149.33,150.18 1 1\ngithub.com/pterm/pterm/section_printer.go:150.18,152.5 1 1\ngithub.com/pterm/pterm/section_printer.go:163.86,164.24 1 2\ngithub.com/pterm/pterm/section_printer.go:172.2,173.12 2 2\ngithub.com/pterm/pterm/section_printer.go:164.24,165.33 1 2\ngithub.com/pterm/pterm/section_printer.go:165.33,166.18 1 1\ngithub.com/pterm/pterm/section_printer.go:166.18,168.5 1 1\ngithub.com/pterm/pterm/color.go:14.20,17.2 2 14224\ngithub.com/pterm/pterm/color.go:20.21,23.2 2 14225\ngithub.com/pterm/pterm/color.go:142.50,145.2 2 650\ngithub.com/pterm/pterm/color.go:150.48,153.36 3 73138\ngithub.com/pterm/pterm/color.go:156.2,157.16 2 73138\ngithub.com/pterm/pterm/color.go:153.36,155.3 1 74532\ngithub.com/pterm/pterm/color.go:162.64,164.2 1 36\ngithub.com/pterm/pterm/color.go:169.66,171.2 1 648\ngithub.com/pterm/pterm/color.go:177.55,181.2 3 326\ngithub.com/pterm/pterm/color.go:187.53,191.2 3 18\ngithub.com/pterm/pterm/color.go:196.69,200.2 3 18\ngithub.com/pterm/pterm/color.go:206.71,210.2 3 324\ngithub.com/pterm/pterm/color.go:215.60,216.24 1 2\ngithub.com/pterm/pterm/color.go:224.2,225.12 2 2\ngithub.com/pterm/pterm/color.go:216.24,217.33 1 2\ngithub.com/pterm/pterm/color.go:217.33,218.18 1 1\ngithub.com/pterm/pterm/color.go:218.18,220.5 1 1\ngithub.com/pterm/pterm/color.go:231.76,232.24 1 2\ngithub.com/pterm/pterm/color.go:240.2,241.12 2 2\ngithub.com/pterm/pterm/color.go:232.24,233.33 1 2\ngithub.com/pterm/pterm/color.go:233.33,234.18 1 1\ngithub.com/pterm/pterm/color.go:234.18,236.5 1 1\ngithub.com/pterm/pterm/color.go:245.32,247.2 1 327052\ngithub.com/pterm/pterm/color.go:255.39,257.27 2 3313\ngithub.com/pterm/pterm/color.go:260.2,260.13 1 3313\ngithub.com/pterm/pterm/color.go:257.27,259.3 1 726\ngithub.com/pterm/pterm/color.go:264.43,267.28 2 5\ngithub.com/pterm/pterm/color.go:271.2,271.12 1 5\ngithub.com/pterm/pterm/color.go:267.28,269.3 1 6\ngithub.com/pterm/pterm/color.go:277.48,280.36 3 46526\ngithub.com/pterm/pterm/color.go:283.2,284.46 2 46526\ngithub.com/pterm/pterm/color.go:280.36,282.3 1 48484\ngithub.com/pterm/pterm/color.go:290.50,292.2 1 324\ngithub.com/pterm/pterm/color.go:296.64,298.2 1 36\ngithub.com/pterm/pterm/color.go:303.66,305.2 1 648\ngithub.com/pterm/pterm/color.go:311.40,313.2 1 18\ngithub.com/pterm/pterm/color.go:319.42,321.2 1 324\ngithub.com/pterm/pterm/color.go:326.56,328.2 1 18\ngithub.com/pterm/pterm/color.go:334.58,336.2 1 324\ngithub.com/pterm/pterm/color.go:339.30,341.2 1 1\ngithub.com/pterm/pterm/color.go:344.32,346.2 1 143496\ngithub.com/pterm/pterm/color.go:350.42,351.22 1 143496\ngithub.com/pterm/pterm/color.go:355.2,356.27 2 138007\ngithub.com/pterm/pterm/color.go:360.2,360.33 1 138007\ngithub.com/pterm/pterm/color.go:351.22,353.3 1 5489\ngithub.com/pterm/pterm/color.go:356.27,358.3 1 177988\ngithub.com/pterm/pterm/theme.go:93.52,96.2 2 1\ngithub.com/pterm/pterm/theme.go:99.54,102.2 2 1\ngithub.com/pterm/pterm/theme.go:105.54,108.2 2 1\ngithub.com/pterm/pterm/theme.go:111.56,114.2 2 1\ngithub.com/pterm/pterm/theme.go:117.55,120.2 2 1\ngithub.com/pterm/pterm/theme.go:123.59,126.2 2 1\ngithub.com/pterm/pterm/theme.go:129.58,132.2 2 1\ngithub.com/pterm/pterm/theme.go:135.59,138.2 2 1\ngithub.com/pterm/pterm/theme.go:141.58,144.2 2 1\ngithub.com/pterm/pterm/theme.go:147.57,150.2 2 1\ngithub.com/pterm/pterm/theme.go:153.56,156.2 2 1\ngithub.com/pterm/pterm/theme.go:159.57,162.2 2 1\ngithub.com/pterm/pterm/theme.go:165.56,168.2 2 1\ngithub.com/pterm/pterm/theme.go:171.63,174.2 2 1\ngithub.com/pterm/pterm/theme.go:177.62,180.2 2 1\ngithub.com/pterm/pterm/theme.go:183.59,186.2 2 1\ngithub.com/pterm/pterm/theme.go:189.61,192.2 2 1\ngithub.com/pterm/pterm/theme.go:195.51,198.2 2 1\ngithub.com/pterm/pterm/theme.go:201.57,204.2 2 1\ngithub.com/pterm/pterm/theme.go:207.56,210.2 2 1\ngithub.com/pterm/pterm/theme.go:213.49,216.2 2 1\ngithub.com/pterm/pterm/theme.go:219.53,222.2 2 1\ngithub.com/pterm/pterm/theme.go:225.48,228.2 2 1\ngithub.com/pterm/pterm/theme.go:231.52,234.2 2 1\ngithub.com/pterm/pterm/theme.go:237.53,240.2 2 1\ngithub.com/pterm/pterm/theme.go:243.48,246.2 2 1\ngithub.com/pterm/pterm/atoms.go:15.39,18.2 2 1\ngithub.com/pterm/pterm/atoms.go:21.48,24.2 2 1\ngithub.com/pterm/pterm/atoms.go:27.40,30.2 2 1\ngithub.com/pterm/pterm/atoms.go:33.43,36.2 2 1\ngithub.com/pterm/pterm/box_printer.go:55.55,58.2 2 25\ngithub.com/pterm/pterm/box_printer.go:61.61,70.2 8 2\ngithub.com/pterm/pterm/box_printer.go:73.62,82.2 8 2\ngithub.com/pterm/pterm/box_printer.go:85.63,94.2 8 2\ngithub.com/pterm/pterm/box_printer.go:97.64,106.2 8 2\ngithub.com/pterm/pterm/box_printer.go:109.65,118.2 8 2\ngithub.com/pterm/pterm/box_printer.go:121.66,130.2 8 2\ngithub.com/pterm/pterm/box_printer.go:133.60,136.2 2 1\ngithub.com/pterm/pterm/box_printer.go:139.61,142.2 2 1\ngithub.com/pterm/pterm/box_printer.go:145.70,148.2 2 1\ngithub.com/pterm/pterm/box_printer.go:151.69,154.2 2 1\ngithub.com/pterm/pterm/box_printer.go:157.73,160.2 2 1\ngithub.com/pterm/pterm/box_printer.go:163.72,166.2 2 1\ngithub.com/pterm/pterm/box_printer.go:169.64,172.2 2 1\ngithub.com/pterm/pterm/box_printer.go:175.66,178.2 2 1\ngithub.com/pterm/pterm/box_printer.go:181.61,182.17 1 2\ngithub.com/pterm/pterm/box_printer.go:185.2,186.11 2 2\ngithub.com/pterm/pterm/box_printer.go:182.17,184.3 1 1\ngithub.com/pterm/pterm/box_printer.go:190.64,191.17 1 2\ngithub.com/pterm/pterm/box_printer.go:194.2,195.11 2 2\ngithub.com/pterm/pterm/box_printer.go:191.17,193.3 1 1\ngithub.com/pterm/pterm/box_printer.go:199.63,200.17 1 2\ngithub.com/pterm/pterm/box_printer.go:203.2,204.11 2 2\ngithub.com/pterm/pterm/box_printer.go:200.17,202.3 1 1\ngithub.com/pterm/pterm/box_printer.go:208.62,209.17 1 2\ngithub.com/pterm/pterm/box_printer.go:212.2,213.11 2 2\ngithub.com/pterm/pterm/box_printer.go:209.17,211.3 1 1\ngithub.com/pterm/pterm/box_printer.go:217.68,220.2 2 0\ngithub.com/pterm/pterm/box_printer.go:224.53,225.23 1 1441\ngithub.com/pterm/pterm/box_printer.go:228.2,228.24 1 1441\ngithub.com/pterm/pterm/box_printer.go:231.2,236.19 4 1441\ngithub.com/pterm/pterm/box_printer.go:273.2,276.24 3 1441\ngithub.com/pterm/pterm/box_printer.go:286.2,286.68 1 1441\ngithub.com/pterm/pterm/box_printer.go:225.23,227.3 1 7\ngithub.com/pterm/pterm/box_printer.go:228.24,230.3 1 7\ngithub.com/pterm/pterm/box_printer.go:236.19,241.3 2 1417\ngithub.com/pterm/pterm/box_printer.go:241.8,243.92 2 24\ngithub.com/pterm/pterm/box_printer.go:246.3,246.21 1 24\ngithub.com/pterm/pterm/box_printer.go:243.92,245.4 1 6\ngithub.com/pterm/pterm/box_printer.go:246.21,250.4 2 19\ngithub.com/pterm/pterm/box_printer.go:250.9,250.29 1 5\ngithub.com/pterm/pterm/box_printer.go:250.29,254.4 2 1\ngithub.com/pterm/pterm/box_printer.go:254.9,254.30 1 4\ngithub.com/pterm/pterm/box_printer.go:254.30,258.4 2 1\ngithub.com/pterm/pterm/box_printer.go:258.9,258.31 1 3\ngithub.com/pterm/pterm/box_printer.go:258.31,262.4 2 1\ngithub.com/pterm/pterm/box_printer.go:262.9,262.32 1 2\ngithub.com/pterm/pterm/box_printer.go:262.32,266.4 2 1\ngithub.com/pterm/pterm/box_printer.go:266.9,266.33 1 1\ngithub.com/pterm/pterm/box_printer.go:266.33,270.4 2 1\ngithub.com/pterm/pterm/box_printer.go:276.24,277.66 1 1477\ngithub.com/pterm/pterm/box_printer.go:277.66,281.4 1 36\ngithub.com/pterm/pterm/box_printer.go:281.9,284.4 1 1441\ngithub.com/pterm/pterm/box_printer.go:291.55,293.2 1 651\ngithub.com/pterm/pterm/box_printer.go:296.69,298.2 1 684\ngithub.com/pterm/pterm/box_printer.go:302.71,304.2 1 648\ngithub.com/pterm/pterm/box_printer.go:309.58,313.2 3 18\ngithub.com/pterm/pterm/box_printer.go:318.60,322.2 3 327\ngithub.com/pterm/pterm/box_printer.go:326.74,330.2 3 18\ngithub.com/pterm/pterm/box_printer.go:335.76,339.2 3 324\ngithub.com/pterm/pterm/box_printer.go:344.65,345.24 1 2\ngithub.com/pterm/pterm/box_printer.go:353.2,354.12 2 2\ngithub.com/pterm/pterm/box_printer.go:345.24,346.33 1 2\ngithub.com/pterm/pterm/box_printer.go:346.33,347.18 1 1\ngithub.com/pterm/pterm/box_printer.go:347.18,349.5 1 1\ngithub.com/pterm/pterm/box_printer.go:360.81,361.24 1 2\ngithub.com/pterm/pterm/box_printer.go:369.2,370.12 2 2\ngithub.com/pterm/pterm/box_printer.go:361.24,362.33 1 2\ngithub.com/pterm/pterm/box_printer.go:362.33,363.18 1 1\ngithub.com/pterm/pterm/box_printer.go:363.18,365.5 1 1\ngithub.com/pterm/pterm/spinner_printer.go:51.63,54.2 2 1\ngithub.com/pterm/pterm/spinner_printer.go:57.74,60.2 2 1\ngithub.com/pterm/pterm/spinner_printer.go:63.65,66.2 2 1\ngithub.com/pterm/pterm/spinner_printer.go:69.72,72.2 2 2\ngithub.com/pterm/pterm/spinner_printer.go:75.72,78.2 2 1\ngithub.com/pterm/pterm/spinner_printer.go:81.71,84.2 2 2\ngithub.com/pterm/pterm/spinner_printer.go:87.66,90.2 2 2\ngithub.com/pterm/pterm/spinner_printer.go:93.87,96.2 2 1\ngithub.com/pterm/pterm/spinner_printer.go:99.70,102.2 2 1\ngithub.com/pterm/pterm/spinner_printer.go:105.76,108.2 2 0\ngithub.com/pterm/pterm/spinner_printer.go:112.50,114.16 2 17\ngithub.com/pterm/pterm/spinner_printer.go:118.2,118.15 1 17\ngithub.com/pterm/pterm/spinner_printer.go:114.16,117.3 2 16\ngithub.com/pterm/pterm/spinner_printer.go:118.15,120.3 1 1\ngithub.com/pterm/pterm/spinner_printer.go:124.77,129.20 4 10\ngithub.com/pterm/pterm/spinner_printer.go:133.2,133.15 1 10\ngithub.com/pterm/pterm/spinner_printer.go:137.2,137.12 1 10\ngithub.com/pterm/pterm/spinner_printer.go:154.2,154.16 1 10\ngithub.com/pterm/pterm/spinner_printer.go:129.20,131.3 1 5\ngithub.com/pterm/pterm/spinner_printer.go:133.15,135.3 1 6\ngithub.com/pterm/pterm/spinner_printer.go:137.12,138.18 1 10\ngithub.com/pterm/pterm/spinner_printer.go:138.18,139.35 1 536530\ngithub.com/pterm/pterm/spinner_printer.go:139.35,140.33 1 93756\ngithub.com/pterm/pterm/spinner_printer.go:144.5,145.20 2 6\ngithub.com/pterm/pterm/spinner_printer.go:148.5,150.24 3 6\ngithub.com/pterm/pterm/spinner_printer.go:140.33,141.14 1 93898\ngithub.com/pterm/pterm/spinner_printer.go:145.20,147.6 1 5\ngithub.com/pterm/pterm/spinner_printer.go:159.39,161.22 2 65\ngithub.com/pterm/pterm/spinner_printer.go:167.2,167.12 1 65\ngithub.com/pterm/pterm/spinner_printer.go:161.22,164.3 2 2\ngithub.com/pterm/pterm/spinner_printer.go:164.8,166.3 1 63\ngithub.com/pterm/pterm/spinner_printer.go:173.63,177.2 3 2\ngithub.com/pterm/pterm/spinner_printer.go:182.62,186.2 3 3\ngithub.com/pterm/pterm/spinner_printer.go:190.58,191.29 1 19\ngithub.com/pterm/pterm/spinner_printer.go:195.2,195.23 1 19\ngithub.com/pterm/pterm/spinner_printer.go:198.2,200.14 3 19\ngithub.com/pterm/pterm/spinner_printer.go:191.29,193.3 1 1\ngithub.com/pterm/pterm/spinner_printer.go:195.23,197.3 1 1\ngithub.com/pterm/pterm/spinner_printer.go:205.55,206.26 1 19\ngithub.com/pterm/pterm/spinner_printer.go:210.2,210.23 1 19\ngithub.com/pterm/pterm/spinner_printer.go:213.2,215.14 3 19\ngithub.com/pterm/pterm/spinner_printer.go:206.26,208.3 1 1\ngithub.com/pterm/pterm/spinner_printer.go:210.23,212.3 1 1\ngithub.com/pterm/pterm/spinner_printer.go:220.58,221.29 1 19\ngithub.com/pterm/pterm/spinner_printer.go:225.2,225.23 1 19\ngithub.com/pterm/pterm/spinner_printer.go:228.2,230.14 3 19\ngithub.com/pterm/pterm/spinner_printer.go:221.29,223.3 1 1\ngithub.com/pterm/pterm/spinner_printer.go:225.23,227.3 1 1\n"
        },
        {
          "name": "deprecated.go",
          "type": "blob",
          "size": 3.892578125,
          "content": "package pterm\n\nimport (\n\t\"strconv\"\n\t\"strings\"\n\n\t\"github.com/pterm/pterm/internal\"\n)\n\n// NewLettersFromString creates a Letters object from a string, which is prefilled with the LetterStyle from ThemeDefault.\n// You can override the ThemeDefault LetterStyle if you want to.\n//\n// Deprecated: use putils.LettersFromString instead.\nfunc NewLettersFromString(text string) Letters {\n\treturn NewLettersFromStringWithStyle(text, &ThemeDefault.LetterStyle)\n}\n\n// NewLettersFromStringWithStyle creates a Letters object from a string and applies a Style to it.\n//\n// Deprecated: use putils.LettersFromStringWithStyle instead.\nfunc NewLettersFromStringWithStyle(text string, style *Style) Letters {\n\ts := strings.Split(text, \"\")\n\tl := Letters{}\n\n\tfor _, s2 := range s {\n\t\tl = append(l, Letter{\n\t\t\tString: s2,\n\t\t\tStyle:  style,\n\t\t})\n\t}\n\n\treturn l\n}\n\n// NewLettersFromStringWithRGB creates a Letters object from a string and applies an RGB color to it (overwrites style).\n//\n// Deprecated: use putils.LettersFromStringWithRGB instead.\nfunc NewLettersFromStringWithRGB(text string, rgb RGB) Letters {\n\ts := strings.Split(text, \"\")\n\tl := Letters{}\n\n\tfor _, s2 := range s {\n\t\tl = append(l, Letter{\n\t\t\tString: s2,\n\t\t\tStyle:  &Style{},\n\t\t\tRGB:    rgb,\n\t\t})\n\t}\n\n\treturn l\n}\n\n// NewBulletListFromStrings returns a BulletListPrinter with Text using the NewTreeListItemFromString method.\n//\n// Deprecated: use putils.BulletListFromStrings instead.\nfunc NewBulletListFromStrings(s []string, padding string) BulletListPrinter {\n\tvar lis []BulletListItem\n\tfor _, line := range s {\n\t\tlis = append(lis, NewBulletListItemFromString(line, padding))\n\t}\n\treturn *DefaultBulletList.WithItems(lis)\n}\n\n// NewBulletListItemFromString returns a BulletListItem with a Text. The padding is counted in the Text to define the Level of the ListItem.\n//\n// Deprecated: use putils.BulletListItemFromString instead.\nfunc NewBulletListItemFromString(text string, padding string) BulletListItem {\n\ts, l := internal.RemoveAndCountPrefix(text, padding)\n\treturn BulletListItem{\n\t\tLevel: l,\n\t\tText:  s,\n\t}\n}\n\n// NewBulletListFromString returns a BulletListPrinter with Text using the NewTreeListItemFromString method, splitting after return (\\n).\n//\n// Deprecated: use putils.BulletListFromString instead.\nfunc NewBulletListFromString(s string, padding string) BulletListPrinter {\n\treturn NewBulletListFromStrings(strings.Split(s, \"\\n\"), padding)\n}\n\n// NewTreeFromLeveledList converts a TreeItems list to a TreeNode and returns it.\n//\n// Deprecated: use putils.TreeFromLeveledList instead.\nfunc NewTreeFromLeveledList(leveledListItems LeveledList) TreeNode {\n\tif len(leveledListItems) == 0 {\n\t\treturn TreeNode{}\n\t}\n\n\troot := &TreeNode{\n\t\tChildren: []TreeNode{},\n\t\tText:     leveledListItems[0].Text,\n\t}\n\n\tfor i, record := range leveledListItems {\n\t\tlast := root\n\n\t\tif record.Level < 0 {\n\t\t\trecord.Level = 0\n\t\t\tleveledListItems[i].Level = 0\n\t\t}\n\n\t\tif len(leveledListItems)-1 != i {\n\t\t\tif leveledListItems[i+1].Level-1 > record.Level {\n\t\t\t\tleveledListItems[i+1].Level = record.Level + 1\n\t\t\t}\n\t\t}\n\n\t\tfor i := 0; i < record.Level; i++ {\n\t\t\tlastIndex := len(last.Children) - 1\n\t\t\tlast = &last.Children[lastIndex]\n\t\t}\n\t\tlast.Children = append(last.Children, TreeNode{\n\t\t\tChildren: []TreeNode{},\n\t\t\tText:     record.Text,\n\t\t})\n\t}\n\n\treturn *root\n}\n\n// NewRGBFromHEX converts a HEX and returns a new RGB.\n//\n// Deprecated: use putils.RGBFromHEX instead.\nfunc NewRGBFromHEX(hex string) (RGB, error) {\n\thex = strings.ToLower(hex)\n\thex = strings.ReplaceAll(hex, \"#\", \"\")\n\thex = strings.ReplaceAll(hex, \"0x\", \"\")\n\n\tif len(hex) == 3 {\n\t\thex = string([]byte{hex[0], hex[0], hex[1], hex[1], hex[2], hex[2]})\n\t}\n\tif len(hex) != 6 {\n\t\treturn RGB{}, ErrHexCodeIsInvalid\n\t}\n\n\ti64, err := strconv.ParseInt(hex, 16, 32)\n\tif err != nil {\n\t\treturn RGB{}, err\n\t}\n\tc := int(i64)\n\t// #nosec G115\n\treturn RGB{\n\t\tR: uint8(c >> 16),             //nolint:gosec\n\t\tG: uint8((c & 0x00FF00) >> 8), //nolint:gosec\n\t\tB: uint8(c & 0x0000FF),        //nolint:gosec\n\t}, nil\n}\n"
        },
        {
          "name": "docs",
          "type": "tree",
          "content": null
        },
        {
          "name": "errors.go",
          "type": "blob",
          "size": 0.5029296875,
          "content": "package pterm\n\nimport \"errors\"\n\nvar (\n\t// ErrTerminalSizeNotDetectable - the terminal size can not be detected and the fallback values are used.\n\tErrTerminalSizeNotDetectable = errors.New(\"terminal size could not be detected - using fallback value\")\n\n\t// ErrHexCodeIsInvalid - the given HEX code is invalid.\n\tErrHexCodeIsInvalid = errors.New(\"hex code is not valid\")\n\n\t// ErrKeyWithoutValue - an odd number of arguments was passed to a pterm Logger's Args method.\n\tErrKeyWithoutValue = \"ERROR: key_without_value\"\n)\n"
        },
        {
          "name": "go.mod",
          "type": "blob",
          "size": 0.724609375,
          "content": "module github.com/pterm/pterm\n\ngo 1.21\n\nrequire (\n\tatomicgo.dev/cursor v0.2.0\n\tatomicgo.dev/keyboard v0.2.9\n\tatomicgo.dev/schedule v0.1.0\n\tgithub.com/MarvinJWendt/testza v0.5.2\n\tgithub.com/gookit/color v1.5.4\n\tgithub.com/lithammer/fuzzysearch v1.1.8\n\tgithub.com/mattn/go-runewidth v0.0.16\n\tgolang.org/x/term v0.26.0\n\tgolang.org/x/text v0.20.0\n)\n\nrequire (\n\tatomicgo.dev/assert v0.0.2 // indirect\n\tgithub.com/containerd/console v1.0.3 // indirect\n\tgithub.com/davecgh/go-spew v1.1.1 // indirect\n\tgithub.com/klauspost/cpuid/v2 v2.2.3 // indirect\n\tgithub.com/rivo/uniseg v0.4.4 // indirect\n\tgithub.com/sergi/go-diff v1.2.0 // indirect\n\tgithub.com/xo/terminfo v0.0.0-20220910002029-abceb7e1c41e // indirect\n\tgolang.org/x/sys v0.27.0 // indirect\n)\n"
        },
        {
          "name": "go.sum",
          "type": "blob",
          "size": 10.455078125,
          "content": "atomicgo.dev/assert v0.0.2 h1:FiKeMiZSgRrZsPo9qn/7vmr7mCsh5SZyXY4YGYiYwrg=\natomicgo.dev/assert v0.0.2/go.mod h1:ut4NcI3QDdJtlmAxQULOmA13Gz6e2DWbSAS8RUOmNYQ=\natomicgo.dev/cursor v0.2.0 h1:H6XN5alUJ52FZZUkI7AlJbUc1aW38GWZalpYRPpoPOw=\natomicgo.dev/cursor v0.2.0/go.mod h1:Lr4ZJB3U7DfPPOkbH7/6TOtJ4vFGHlgj1nc+n900IpU=\natomicgo.dev/keyboard v0.2.9 h1:tOsIid3nlPLZ3lwgG8KZMp/SFmr7P0ssEN5JUsm78K8=\natomicgo.dev/keyboard v0.2.9/go.mod h1:BC4w9g00XkxH/f1HXhW2sXmJFOCWbKn9xrOunSFtExQ=\natomicgo.dev/schedule v0.1.0 h1:nTthAbhZS5YZmgYbb2+DH8uQIZcTlIrd4eYr3UQxEjs=\natomicgo.dev/schedule v0.1.0/go.mod h1:xeUa3oAkiuHYh8bKiQBRojqAMq3PXXbJujjb0hw8pEU=\ngithub.com/MarvinJWendt/testza v0.1.0/go.mod h1:7AxNvlfeHP7Z/hDQ5JtE3OKYT3XFUeLCDE2DQninSqs=\ngithub.com/MarvinJWendt/testza v0.2.1/go.mod h1:God7bhG8n6uQxwdScay+gjm9/LnO4D3kkcZX4hv9Rp8=\ngithub.com/MarvinJWendt/testza v0.2.8/go.mod h1:nwIcjmr0Zz+Rcwfh3/4UhBp7ePKVhuBExvZqnKYWlII=\ngithub.com/MarvinJWendt/testza v0.2.10/go.mod h1:pd+VWsoGUiFtq+hRKSU1Bktnn+DMCSrDrXDpX2bG66k=\ngithub.com/MarvinJWendt/testza v0.2.12/go.mod h1:JOIegYyV7rX+7VZ9r77L/eH6CfJHHzXjB69adAhzZkI=\ngithub.com/MarvinJWendt/testza v0.3.0/go.mod h1:eFcL4I0idjtIx8P9C6KkAuLgATNKpX4/2oUqKc6bF2c=\ngithub.com/MarvinJWendt/testza v0.4.2/go.mod h1:mSdhXiKH8sg/gQehJ63bINcCKp7RtYewEjXsvsVUPbE=\ngithub.com/MarvinJWendt/testza v0.5.2 h1:53KDo64C1z/h/d/stCYCPY69bt/OSwjq5KpFNwi+zB4=\ngithub.com/MarvinJWendt/testza v0.5.2/go.mod h1:xu53QFE5sCdjtMCKk8YMQ2MnymimEctc4n3EjyIYvEY=\ngithub.com/atomicgo/cursor v0.0.1/go.mod h1:cBON2QmmrysudxNBFthvMtN32r3jxVRIvzkUiF/RuIk=\ngithub.com/containerd/console v1.0.3 h1:lIr7SlA5PxZyMV30bDW0MGbiOPXwc63yRuCP0ARubLw=\ngithub.com/containerd/console v1.0.3/go.mod h1:7LqA/THxQ86k76b8c/EMSiaJ3h1eZkMkXar0TQ1gf3U=\ngithub.com/davecgh/go-spew v1.1.0/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=\ngithub.com/davecgh/go-spew v1.1.1 h1:vj9j/u1bqnvCEfJOwUhtlOARqs3+rkHYY13jYWTU97c=\ngithub.com/davecgh/go-spew v1.1.1/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=\ngithub.com/gookit/color v1.4.2/go.mod h1:fqRyamkC1W8uxl+lxCQxOT09l/vYfZ+QeiX3rKQHCoQ=\ngithub.com/gookit/color v1.5.0/go.mod h1:43aQb+Zerm/BWh2GnrgOQm7ffz7tvQXEKV6BFMl7wAo=\ngithub.com/gookit/color v1.5.4 h1:FZmqs7XOyGgCAxmWyPslpiok1k05wmY3SJTytgvYFs0=\ngithub.com/gookit/color v1.5.4/go.mod h1:pZJOeOS8DM43rXbp4AZo1n9zCU2qjpcRko0b6/QJi9w=\ngithub.com/klauspost/cpuid/v2 v2.0.9/go.mod h1:FInQzS24/EEf25PyTYn52gqo7WaD8xa0213Md/qVLRg=\ngithub.com/klauspost/cpuid/v2 v2.0.10/go.mod h1:g2LTdtYhdyuGPqyWyv7qRAmj1WBqxuObKfj5c0PQa7c=\ngithub.com/klauspost/cpuid/v2 v2.0.12/go.mod h1:g2LTdtYhdyuGPqyWyv7qRAmj1WBqxuObKfj5c0PQa7c=\ngithub.com/klauspost/cpuid/v2 v2.2.3 h1:sxCkb+qR91z4vsqw4vGGZlDgPz3G7gjaLyK3V8y70BU=\ngithub.com/klauspost/cpuid/v2 v2.2.3/go.mod h1:RVVoqg1df56z8g3pUjL/3lE5UfnlrJX8tyFgg4nqhuY=\ngithub.com/kr/pretty v0.1.0/go.mod h1:dAy3ld7l9f0ibDNOQOHHMYYIIbhfbHSm3C4ZsoJORNo=\ngithub.com/kr/pty v1.1.1/go.mod h1:pFQYn66WHrOpPYNljwOMqo10TkYh1fy3cYio2l3bCsQ=\ngithub.com/kr/text v0.1.0/go.mod h1:4Jbv+DJW3UT/LiOwJeYQe1efqtUx/iVham/4vfdArNI=\ngithub.com/lithammer/fuzzysearch v1.1.8 h1:/HIuJnjHuXS8bKaiTMeeDlW2/AyIWk2brx1V8LFgLN4=\ngithub.com/lithammer/fuzzysearch v1.1.8/go.mod h1:IdqeyBClc3FFqSzYq/MXESsS4S0FsZ5ajtkr5xPLts4=\ngithub.com/mattn/go-runewidth v0.0.13/go.mod h1:Jdepj2loyihRzMpdS35Xk/zdY8IAYHsh153qUoGf23w=\ngithub.com/mattn/go-runewidth v0.0.16 h1:E5ScNMtiwvlvB5paMFdw9p4kSQzbXFikJ5SQO6TULQc=\ngithub.com/mattn/go-runewidth v0.0.16/go.mod h1:Jdepj2loyihRzMpdS35Xk/zdY8IAYHsh153qUoGf23w=\ngithub.com/pmezard/go-difflib v1.0.0 h1:4DBwDE0NGyQoBHbLQYPwSUPoCMWR5BEzIk/f1lZbAQM=\ngithub.com/pmezard/go-difflib v1.0.0/go.mod h1:iKH77koFhYxTK1pcRnkKkqfTogsbg7gZNVY4sRDYZ/4=\ngithub.com/pterm/pterm v0.12.27/go.mod h1:PhQ89w4i95rhgE+xedAoqous6K9X+r6aSOI2eFF7DZI=\ngithub.com/pterm/pterm v0.12.29/go.mod h1:WI3qxgvoQFFGKGjGnJR849gU0TsEOvKn5Q8LlY1U7lg=\ngithub.com/pterm/pterm v0.12.30/go.mod h1:MOqLIyMOgmTDz9yorcYbcw+HsgoZo3BQfg2wtl3HEFE=\ngithub.com/pterm/pterm v0.12.31/go.mod h1:32ZAWZVXD7ZfG0s8qqHXePte42kdz8ECtRyEejaWgXU=\ngithub.com/pterm/pterm v0.12.33/go.mod h1:x+h2uL+n7CP/rel9+bImHD5lF3nM9vJj80k9ybiiTTE=\ngithub.com/pterm/pterm v0.12.36/go.mod h1:NjiL09hFhT/vWjQHSj1athJpx6H8cjpHXNAK5bUw8T8=\ngithub.com/pterm/pterm v0.12.40/go.mod h1:ffwPLwlbXxP+rxT0GsgDTzS3y3rmpAO1NMjUkGTYf8s=\ngithub.com/rivo/uniseg v0.2.0/go.mod h1:J6wj4VEh+S6ZtnVlnTBMWIodfgj8LQOQFoIToxlJtxc=\ngithub.com/rivo/uniseg v0.4.4 h1:8TfxU8dW6PdqD27gjM8MVNuicgxIjxpm4K7x4jp8sis=\ngithub.com/rivo/uniseg v0.4.4/go.mod h1:FN3SvrM+Zdj16jyLfmOkMNblXMcoc8DfTHruCPUcx88=\ngithub.com/sergi/go-diff v1.2.0 h1:XU+rvMAioB0UC3q1MFrIQy4Vo5/4VsRDQQXHsEya6xQ=\ngithub.com/sergi/go-diff v1.2.0/go.mod h1:STckp+ISIX8hZLjrqAeVduY0gWCT9IjLuqbuNXdaHfM=\ngithub.com/stretchr/objx v0.1.0/go.mod h1:HFkY916IF+rwdDfMAkV7OtwuqBVzrE8GR6GFx+wExME=\ngithub.com/stretchr/testify v1.4.0/go.mod h1:j7eGeouHqKxXV5pUuKE4zz7dFj8WfuZ+81PSLYec5m4=\ngithub.com/stretchr/testify v1.6.1/go.mod h1:6Fq8oRcR53rry900zMqJjRRixrwX3KX962/h/Wwjteg=\ngithub.com/stretchr/testify v1.7.0/go.mod h1:6Fq8oRcR53rry900zMqJjRRixrwX3KX962/h/Wwjteg=\ngithub.com/stretchr/testify v1.8.4 h1:CcVxjf3Q8PM0mHUKJCdn+eZZtm5yQwehR5yeSVQQcUk=\ngithub.com/stretchr/testify v1.8.4/go.mod h1:sz/lmYIOXD/1dqDmKjjqLyZ2RngseejIcXlSw2iwfAo=\ngithub.com/xo/terminfo v0.0.0-20210125001918-ca9a967f8778/go.mod h1:2MuV+tbUrU1zIOPMxZ5EncGwgmMJsa+9ucAQZXxsObs=\ngithub.com/xo/terminfo v0.0.0-20220910002029-abceb7e1c41e h1:JVG44RsyaB9T2KIHavMF/ppJZNG9ZpyihvCd0w101no=\ngithub.com/xo/terminfo v0.0.0-20220910002029-abceb7e1c41e/go.mod h1:RbqR21r5mrJuqunuUZ/Dhy/avygyECGrLceyNeo4LiM=\ngithub.com/yuin/goldmark v1.4.13/go.mod h1:6yULJ656Px+3vBD8DxQVa3kxgyrAnzto9xy5taEt/CY=\ngolang.org/x/crypto v0.0.0-20190308221718-c2843e01d9a2/go.mod h1:djNgcEr1/C05ACkg1iLfiJU5Ep61QUkGW8qpdssI0+w=\ngolang.org/x/crypto v0.0.0-20210921155107-089bfa567519/go.mod h1:GvvjBRRGRdwPK5ydBHafDWAxML/pGHZbMvKqRZ5+Abc=\ngolang.org/x/exp v0.0.0-20220909182711-5c715a9e8561 h1:MDc5xs78ZrZr3HMQugiXOAkSZtfTpbJLDr/lwfgO53E=\ngolang.org/x/exp v0.0.0-20220909182711-5c715a9e8561/go.mod h1:cyybsKvd6eL0RnXn6p/Grxp8F5bW7iYuBgsNCOHpMYE=\ngolang.org/x/mod v0.6.0-dev.0.20220419223038-86c51ed26bb4/go.mod h1:jJ57K6gSWd91VN4djpZkiMVwK6gcyfeH4XE8wZrZaV4=\ngolang.org/x/mod v0.8.0/go.mod h1:iBbtSCu2XBx23ZKBPSOrRkjjQPZFPuis4dIYUhu/chs=\ngolang.org/x/net v0.0.0-20190620200207-3b0461eec859/go.mod h1:z5CRVTTTmAJ677TzLLGU+0bjPO0LkuOLi4/5GtJWs/s=\ngolang.org/x/net v0.0.0-20210226172049-e18ecbb05110/go.mod h1:m0MpNAwzfU5UDzcl9v0D8zg8gWTRqZa9RBIspLL5mdg=\ngolang.org/x/net v0.0.0-20220722155237-a158d28d115b/go.mod h1:XRhObCWvk6IyKnWLug+ECip1KBveYUHfp+8e9klMJ9c=\ngolang.org/x/net v0.6.0/go.mod h1:2Tu9+aMcznHK/AK1HMvgo6xiTLG5rD5rZLDS+rp2Bjs=\ngolang.org/x/sync v0.0.0-20190423024810-112230192c58/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=\ngolang.org/x/sync v0.0.0-20220722155255-886fb9371eb4/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=\ngolang.org/x/sync v0.1.0/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=\ngolang.org/x/sys v0.0.0-20190215142949-d0b11bdaac8a/go.mod h1:STP8DvDyc/dI5b8T5hshtkjS+E42TnysNCUPdjciGhY=\ngolang.org/x/sys v0.0.0-20201119102817-f84b799fce68/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20210124154548-22da62e12c0c/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20210330210617-4fbd30eecc44/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20210615035016-665e8c7367d1/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\ngolang.org/x/sys v0.0.0-20211013075003-97ac67df715c/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\ngolang.org/x/sys v0.0.0-20220319134239-a9b59b0215f8/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\ngolang.org/x/sys v0.0.0-20220520151302-bc2c85ada10a/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\ngolang.org/x/sys v0.0.0-20220704084225-05e143d24a9e/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\ngolang.org/x/sys v0.0.0-20220722155257-8c9f86f7a55f/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\ngolang.org/x/sys v0.5.0/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\ngolang.org/x/sys v0.27.0 h1:wBqf8DvsY9Y/2P8gAfPDEYNuS30J4lPHJxXSb/nJZ+s=\ngolang.org/x/sys v0.27.0/go.mod h1:/VUhepiaJMQUp4+oa/7Zr1D23ma6VTLIYjOOTFZPUcA=\ngolang.org/x/term v0.0.0-20201126162022-7de9c90e9dd1/go.mod h1:bj7SfCRtBDWHUb9snDiAeCFNEtKQo2Wmx5Cou7ajbmo=\ngolang.org/x/term v0.0.0-20210220032956-6a3ed077a48d/go.mod h1:bj7SfCRtBDWHUb9snDiAeCFNEtKQo2Wmx5Cou7ajbmo=\ngolang.org/x/term v0.0.0-20210615171337-6886f2dfbf5b/go.mod h1:jbD1KX2456YbFQfuXm/mYQcufACuNUgVhRMnK/tPxf8=\ngolang.org/x/term v0.0.0-20210927222741-03fcf44c2211/go.mod h1:jbD1KX2456YbFQfuXm/mYQcufACuNUgVhRMnK/tPxf8=\ngolang.org/x/term v0.5.0/go.mod h1:jMB1sMXY+tzblOD4FWmEbocvup2/aLOaQEp7JmGp78k=\ngolang.org/x/term v0.26.0 h1:WEQa6V3Gja/BhNxg540hBip/kkaYtRg3cxg4oXSw4AU=\ngolang.org/x/term v0.26.0/go.mod h1:Si5m1o57C5nBNQo5z1iq+XDijt21BDBDp2bK0QI8e3E=\ngolang.org/x/text v0.3.0/go.mod h1:NqM8EUOU14njkJ3fqMW+pc6Ldnwhi/IjpwHt7yyuwOQ=\ngolang.org/x/text v0.3.3/go.mod h1:5Zoc/QRtKVWzQhOtBMvqHzDpF6irO9z98xDceosuGiQ=\ngolang.org/x/text v0.3.7/go.mod h1:u+2+/6zg+i71rQMx5EYifcz6MCKuco9NR6JIITiCfzQ=\ngolang.org/x/text v0.7.0/go.mod h1:mrYo+phRRbMaCq/xk9113O4dZlRixOauAjOtrjsXDZ8=\ngolang.org/x/text v0.9.0/go.mod h1:e1OnstbJyHTd6l/uOt8jFFHp6TRDWZR/bV3emEE/zU8=\ngolang.org/x/text v0.20.0 h1:gK/Kv2otX8gz+wn7Rmb3vT96ZwuoxnQlY+HlJVj7Qug=\ngolang.org/x/text v0.20.0/go.mod h1:D4IsuqiFMhST5bX19pQ9ikHC2GsaKyk/oF+pn3ducp4=\ngolang.org/x/tools v0.0.0-20180917221912-90fa682c2a6e/go.mod h1:n7NCudcB/nEzxVGmLbDWY5pfWTLqBcC2KZ6jyYvM4mQ=\ngolang.org/x/tools v0.0.0-20191119224855-298f0cb1881e/go.mod h1:b+2E5dAYhXwXZwtnZ6UAqBI28+e2cm9otk0dWdXHAEo=\ngolang.org/x/tools v0.1.12/go.mod h1:hNGJHUnrk76NpqgfD5Aqm5Crs+Hm0VOH/i9J2+nxYbc=\ngolang.org/x/tools v0.6.0/go.mod h1:Xwgl3UAJ/d3gWutnCtw505GrjyAbvKui8lOU390QaIU=\ngolang.org/x/xerrors v0.0.0-20190717185122-a985d3407aa7/go.mod h1:I/5z698sn9Ka8TeJc9MKroUUfqBBauWjQqLJ2OPfmY0=\ngopkg.in/check.v1 v0.0.0-20161208181325-20d25e280405/go.mod h1:Co6ibVJAznAaIkqp8huTwlJQCZ016jof/cbN4VW5Yz0=\ngopkg.in/check.v1 v1.0.0-20190902080502-41f04d3bba15/go.mod h1:Co6ibVJAznAaIkqp8huTwlJQCZ016jof/cbN4VW5Yz0=\ngopkg.in/yaml.v2 v2.2.2/go.mod h1:hI93XBmqTisBFMUTm0b8Fm+jr3Dg1NNxqwp+5A1VGuI=\ngopkg.in/yaml.v2 v2.2.4/go.mod h1:hI93XBmqTisBFMUTm0b8Fm+jr3Dg1NNxqwp+5A1VGuI=\ngopkg.in/yaml.v3 v3.0.0-20200313102051-9f266ea9e77c/go.mod h1:K4uyk7z7BCEPqu6E+C64Yfv1cQ7kz7rIZviUmN+EgEM=\ngopkg.in/yaml.v3 v3.0.0-20210107192922-496545a6307b/go.mod h1:K4uyk7z7BCEPqu6E+C64Yfv1cQ7kz7rIZviUmN+EgEM=\ngopkg.in/yaml.v3 v3.0.1 h1:fxVm/GzAzEWqLHuvctI91KS9hhNmmWOoWu0XTYJS7CA=\ngopkg.in/yaml.v3 v3.0.1/go.mod h1:K4uyk7z7BCEPqu6E+C64Yfv1cQ7kz7rIZviUmN+EgEM=\n"
        },
        {
          "name": "header_printer.go",
          "type": "blob",
          "size": 6.9169921875,
          "content": "package pterm\n\nimport (\n\t\"fmt\"\n\t\"io\"\n\t\"strings\"\n\n\t\"github.com/mattn/go-runewidth\"\n\n\t\"github.com/pterm/pterm/internal\"\n)\n\nvar (\n\t// DefaultHeader returns the printer for a default header text.\n\t// Defaults to LightWhite, Bold Text and a Gray DefaultHeader background.\n\tDefaultHeader = HeaderPrinter{\n\t\tTextStyle:       &ThemeDefault.HeaderTextStyle,\n\t\tBackgroundStyle: &ThemeDefault.HeaderBackgroundStyle,\n\t\tMargin:          5,\n\t}\n)\n\n// HeaderPrinter contains the data used to craft a header.\n// A header is printed as a big box with text in it.\n// Can be used as title screens or section separator.\ntype HeaderPrinter struct {\n\tTextStyle       *Style\n\tBackgroundStyle *Style\n\tMargin          int\n\tFullWidth       bool\n\tWriter          io.Writer\n}\n\n// WithTextStyle returns a new HeaderPrinter with changed\nfunc (p HeaderPrinter) WithTextStyle(style *Style) *HeaderPrinter {\n\tp.TextStyle = style\n\treturn &p\n}\n\n// WithBackgroundStyle changes the background styling of the header.\nfunc (p HeaderPrinter) WithBackgroundStyle(style *Style) *HeaderPrinter {\n\tp.BackgroundStyle = style\n\treturn &p\n}\n\n// WithMargin changes the background styling of the header.\nfunc (p HeaderPrinter) WithMargin(margin int) *HeaderPrinter {\n\tp.Margin = margin\n\treturn &p\n}\n\n// WithFullWidth enables full width on a HeaderPrinter.\nfunc (p HeaderPrinter) WithFullWidth(b ...bool) *HeaderPrinter {\n\tp.FullWidth = internal.WithBoolean(b)\n\treturn &p\n}\n\n// WithWriter sets the custom Writer.\nfunc (p HeaderPrinter) WithWriter(writer io.Writer) *HeaderPrinter {\n\tp.Writer = writer\n\treturn &p\n}\n\n// Sprint formats using the default formats for its operands and returns the resulting string.\n// Spaces are added between operands when neither is a string.\nfunc (p HeaderPrinter) Sprint(a ...any) string {\n\tif RawOutput {\n\t\treturn Sprint(a...)\n\t}\n\n\tif p.TextStyle == nil {\n\t\tp.TextStyle = NewStyle()\n\t}\n\tif p.BackgroundStyle == nil {\n\t\tp.BackgroundStyle = NewStyle()\n\t}\n\n\ttext := Sprint(a...)\n\n\tvar blankLine string\n\n\tlongestLine := internal.ReturnLongestLine(text, \"\\n\")\n\tlongestLineLen := runewidth.StringWidth(RemoveColorFromString(longestLine)) + p.Margin*2\n\n\tif p.FullWidth {\n\t\ttext = splitText(text, GetTerminalWidth()-p.Margin*2)\n\t\tblankLine = strings.Repeat(\" \", GetTerminalWidth())\n\t} else {\n\t\tif longestLineLen > GetTerminalWidth() {\n\t\t\ttext = splitText(text, GetTerminalWidth()-p.Margin*2)\n\t\t\tblankLine = strings.Repeat(\" \", GetTerminalWidth())\n\t\t} else {\n\t\t\ttext = splitText(text, longestLineLen-p.Margin*2)\n\t\t\tblankLine = strings.Repeat(\" \", longestLineLen)\n\t\t}\n\t}\n\n\tvar marginString string\n\tvar ret strings.Builder\n\n\tif p.FullWidth {\n\t\tlongestLineLen = runewidth.StringWidth(RemoveColorFromString(internal.ReturnLongestLine(text, \"\\n\")))\n\t\tmarginString = strings.Repeat(\" \", (GetTerminalWidth()-longestLineLen)/2)\n\t} else {\n\t\tmarginString = strings.Repeat(\" \", p.Margin)\n\t}\n\n\tret.WriteString(p.BackgroundStyle.Sprint(blankLine))\n\tret.WriteByte('\\n')\n\tfor _, line := range strings.Split(text, \"\\n\") {\n\t\tline = strings.ReplaceAll(line, \"\\n\", \"\")\n\t\tline = marginString + line + marginString\n\t\tif runewidth.StringWidth(line) < runewidth.StringWidth(blankLine) {\n\t\t\tline += strings.Repeat(\" \", runewidth.StringWidth(blankLine)-runewidth.StringWidth(line))\n\t\t}\n\t\tret.WriteString(p.BackgroundStyle.Sprint(p.TextStyle.Sprint(line)))\n\t\tret.WriteByte('\\n')\n\t}\n\tret.WriteString(p.BackgroundStyle.Sprint(blankLine))\n\tret.WriteByte('\\n')\n\n\treturn ret.String()\n}\n\nfunc splitText(text string, width int) string {\n\tvar lines []string\n\tlinesTmp := strings.Split(text, \"\\n\")\n\tfor _, line := range linesTmp {\n\t\tif runewidth.StringWidth(RemoveColorFromString(line)) > width {\n\t\t\textraLines := []string{\"\"}\n\t\t\textraLinesCounter := 0\n\t\t\tfor i, letter := range line {\n\t\t\t\tif i%width == 0 && i != 0 {\n\t\t\t\t\textraLinesCounter++\n\t\t\t\t\textraLines = append(extraLines, \"\")\n\t\t\t\t}\n\t\t\t\textraLines[extraLinesCounter] += string(letter)\n\t\t\t}\n\t\t\tfor _, extraLine := range extraLines {\n\t\t\t\textraLine += \"\\n\"\n\t\t\t\tlines = append(lines, extraLine)\n\t\t\t}\n\t\t} else {\n\t\t\tline += \"\\n\"\n\t\t\tlines = append(lines, line)\n\t\t}\n\t}\n\n\tvar line string\n\tfor _, s := range lines {\n\t\tline += s\n\t}\n\n\treturn strings.TrimSuffix(line, \"\\n\")\n}\n\n// Sprintln formats using the default formats for its operands and returns the resulting string.\n// Spaces are always added between operands and a newline is appended.\nfunc (p HeaderPrinter) Sprintln(a ...any) string {\n\treturn p.Sprint(strings.TrimSuffix(Sprintln(a...), \"\\n\"))\n}\n\n// Sprintf formats according to a format specifier and returns the resulting string.\nfunc (p HeaderPrinter) Sprintf(format string, a ...any) string {\n\treturn p.Sprint(Sprintf(format, a...))\n}\n\n// Sprintfln formats according to a format specifier and returns the resulting string.\n// Spaces are always added between operands and a newline is appended.\nfunc (p HeaderPrinter) Sprintfln(format string, a ...any) string {\n\treturn p.Sprintf(format, a...) + \"\\n\"\n}\n\n// Print formats using the default formats for its operands and writes to standard output.\n// Spaces are added between operands when neither is a string.\n// It returns the number of bytes written and any write error encountered.\nfunc (p *HeaderPrinter) Print(a ...any) *TextPrinter {\n\tFprint(p.Writer, p.Sprint(a...))\n\ttp := TextPrinter(p)\n\treturn &tp\n}\n\n// Println formats using the default formats for its operands and writes to standard output.\n// Spaces are always added between operands and a newline is appended.\n// It returns the number of bytes written and any write error encountered.\nfunc (p *HeaderPrinter) Println(a ...any) *TextPrinter {\n\tFprint(p.Writer, p.Sprintln(a...))\n\ttp := TextPrinter(p)\n\treturn &tp\n}\n\n// Printf formats according to a format specifier and writes to standard output.\n// It returns the number of bytes written and any write error encountered.\nfunc (p *HeaderPrinter) Printf(format string, a ...any) *TextPrinter {\n\tFprint(p.Writer, p.Sprintf(format, a...))\n\ttp := TextPrinter(p)\n\treturn &tp\n}\n\n// Printfln formats according to a format specifier and writes to standard output.\n// Spaces are always added between operands and a newline is appended.\n// It returns the number of bytes written and any write error encountered.\nfunc (p *HeaderPrinter) Printfln(format string, a ...any) *TextPrinter {\n\tFprint(p.Writer, p.Sprintfln(format, a...))\n\ttp := TextPrinter(p)\n\treturn &tp\n}\n\n// PrintOnError prints every error which is not nil.\n// If every error is nil, nothing will be printed.\n// This can be used for simple error checking.\nfunc (p *HeaderPrinter) PrintOnError(a ...any) *TextPrinter {\n\tfor _, arg := range a {\n\t\tif err, ok := arg.(error); ok {\n\t\t\tif err != nil {\n\t\t\t\tp.Println(err)\n\t\t\t}\n\t\t}\n\t}\n\n\ttp := TextPrinter(p)\n\treturn &tp\n}\n\n// PrintOnErrorf wraps every error which is not nil and prints it.\n// If every error is nil, nothing will be printed.\n// This can be used for simple error checking.\nfunc (p *HeaderPrinter) PrintOnErrorf(format string, a ...any) *TextPrinter {\n\tfor _, arg := range a {\n\t\tif err, ok := arg.(error); ok {\n\t\t\tif err != nil {\n\t\t\t\tp.Println(fmt.Errorf(format, err))\n\t\t\t}\n\t\t}\n\t}\n\n\ttp := TextPrinter(p)\n\treturn &tp\n}\n"
        },
        {
          "name": "header_printer_test.go",
          "type": "blob",
          "size": 3.6826171875,
          "content": "package pterm_test\n\nimport (\n\t\"errors\"\n\t\"io\"\n\t\"os\"\n\t\"testing\"\n\n\t\"github.com/MarvinJWendt/testza\"\n\n\t\"github.com/pterm/pterm\"\n)\n\nfunc TestHeaderPrinterNilPrint(t *testing.T) {\n\tp := pterm.HeaderPrinter{}\n\tp.Println(\"Hello, World!\")\n}\n\nfunc TestHeaderPrinterPrintMethods(t *testing.T) {\n\tp := pterm.DefaultHeader\n\n\tt.Run(\"Print\", func(t *testing.T) {\n\t\ttestPrintContains(t, func(w io.Writer, a any) {\n\t\t\tp.Print(a)\n\t\t})\n\t})\n\n\tt.Run(\"PrintWithFullWidth\", func(t *testing.T) {\n\t\ttestPrintContains(t, func(w io.Writer, a any) {\n\t\t\tp2 := p.WithFullWidth()\n\t\t\tp2.Print(a)\n\t\t})\n\t})\n\n\tt.Run(\"Printf\", func(t *testing.T) {\n\t\ttestPrintfContains(t, func(w io.Writer, format string, a any) {\n\t\t\tp.Printf(format, a)\n\t\t})\n\t})\n\n\tt.Run(\"Printfln\", func(t *testing.T) {\n\t\ttestPrintflnContains(t, func(w io.Writer, format string, a any) {\n\t\t\tp.Printfln(format, a)\n\t\t})\n\t})\n\n\tt.Run(\"Println\", func(t *testing.T) {\n\t\ttestPrintlnContains(t, func(w io.Writer, a any) {\n\t\t\tp.Println(a)\n\t\t})\n\t})\n\n\tt.Run(\"Sprint\", func(t *testing.T) {\n\t\ttestSprintContains(t, func(a any) string {\n\t\t\treturn p.Sprint(a)\n\t\t})\n\t})\n\n\tt.Run(\"Sprintf\", func(t *testing.T) {\n\t\ttestSprintfContains(t, func(format string, a any) string {\n\t\t\treturn p.Sprintf(format, a)\n\t\t})\n\t})\n\n\tt.Run(\"Sprintfln\", func(t *testing.T) {\n\t\ttestSprintflnContains(t, func(format string, a any) string {\n\t\t\treturn p.Sprintfln(format, a)\n\t\t})\n\t})\n\n\tt.Run(\"Sprintln\", func(t *testing.T) {\n\t\ttestSprintlnContains(t, func(a any) string {\n\t\t\treturn p.Sprintln(a)\n\t\t})\n\t})\n\n\tt.Run(\"PrintOnError\", func(t *testing.T) {\n\t\tresult := captureStdout(func(w io.Writer) {\n\t\t\tp.PrintOnError(errors.New(\"hello world\"))\n\t\t})\n\t\ttestza.AssertContains(t, result, \"hello world\")\n\t})\n\n\tt.Run(\"PrintIfError_WithoutError\", func(t *testing.T) {\n\t\tresult := captureStdout(func(w io.Writer) {\n\t\t\tp.PrintOnError(nil)\n\t\t})\n\t\ttestza.AssertZero(t, result)\n\t})\n\n\tt.Run(\"PrintOnErrorf\", func(t *testing.T) {\n\t\tresult := captureStdout(func(w io.Writer) {\n\t\t\tp.PrintOnErrorf(\"wrapping error : %w\", errors.New(\"hello world\"))\n\t\t})\n\t\ttestza.AssertContains(t, result, \"hello world\")\n\t})\n\n\tt.Run(\"PrintIfError_WithoutErrorf\", func(t *testing.T) {\n\t\tresult := captureStdout(func(w io.Writer) {\n\t\t\tp.PrintOnErrorf(\"\", nil)\n\t\t})\n\t\ttestza.AssertZero(t, result)\n\t})\n}\n\nfunc TestHeaderPrinter_WithBackgroundStyle(t *testing.T) {\n\ts := pterm.NewStyle(pterm.FgRed, pterm.BgGray, pterm.Bold)\n\tp := pterm.HeaderPrinter{}\n\tp2 := p.WithBackgroundStyle(s)\n\n\ttestza.AssertEqual(t, s, p2.BackgroundStyle)\n}\n\nfunc TestHeaderPrinter_WithFullWidth(t *testing.T) {\n\tp := pterm.HeaderPrinter{}\n\tp2 := p.WithFullWidth()\n\n\ttestza.AssertEqual(t, true, p2.FullWidth)\n}\n\nfunc TestHeaderPrinter_WithFullWidthToLongForTerminal(t *testing.T) {\n\tp := pterm.HeaderPrinter{}\n\tp2 := p.WithFullWidth().Sprint(\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\")\n\n\ttestza.AssertContains(t, p2, \"a\")\n}\n\nfunc TestHeaderPrinter_ToLongForTerminal(t *testing.T) {\n\tp := pterm.HeaderPrinter{}\n\tp2 := p.Sprint(\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\")\n\n\ttestza.AssertContains(t, p2, \"a\")\n}\n\nfunc TestHeaderPrinter_WithMargin(t *testing.T) {\n\tp := pterm.HeaderPrinter{}\n\tp2 := p.WithMargin(1337)\n\n\ttestza.AssertEqual(t, 1337, p2.Margin)\n}\n\nfunc TestHeaderPrinter_WithTextStyle(t *testing.T) {\n\ts := pterm.NewStyle(pterm.FgRed, pterm.BgGray, pterm.Bold)\n\tp := pterm.HeaderPrinter{}\n\tp2 := p.WithTextStyle(s)\n\n\ttestza.AssertEqual(t, s, p2.TextStyle)\n}\n\nfunc TestHeaderPrinter_WithWriter(t *testing.T) {\n\tp := pterm.HeaderPrinter{}\n\ts := os.Stderr\n\tp2 := p.WithWriter(s)\n\n\ttestza.AssertEqual(t, s, p2.Writer)\n\ttestza.AssertZero(t, p.Writer)\n}\n"
        },
        {
          "name": "heatmap_printer.go",
          "type": "blob",
          "size": 19.8212890625,
          "content": "package pterm\n\nimport (\n\t\"bytes\"\n\t\"errors\"\n\t\"io\"\n\t\"math\"\n\t\"strings\"\n\n\t\"github.com/pterm/pterm/internal\"\n)\n\n// DefaultHeatmap contains standards, which can be used to print a HeatmapPrinter.\nvar DefaultHeatmap = HeatmapPrinter{\n\tAxisStyle:                  &ThemeDefault.HeatmapHeaderStyle,\n\tSeparatorStyle:             &ThemeDefault.HeatmapSeparatorStyle,\n\tVerticalSeparator:          \"│\",\n\tTopRightCornerSeparator:    \"└\",\n\tTopLeftCornerSeparator:     \"┘\",\n\tBottomLeftCornerSeparator:  \"┐\",\n\tBottomRightCornerSeparator: \"┌\",\n\tHorizontalSeparator:        \"─\",\n\tTSeparator:                 \"┬\",\n\tTReverseSeparator:          \"┴\",\n\tLSeparator:                 \"├\",\n\tLReverseSeparator:          \"┤\",\n\tTCrossSeparator:            \"┼\",\n\tLegendLabel:                \"Legend\",\n\tBoxed:                      true,\n\tGrid:                       true,\n\tLegend:                     true,\n\tTextRGB:                    RGB{0, 0, 0, false},\n\tRGBRange:                   []RGB{{R: 255, G: 0, B: 0, Background: true}, {R: 255, G: 165, B: 0, Background: true}, {R: 0, G: 255, B: 0, Background: true}},\n\tTextColor:                  FgBlack,\n\tColors:                     []Color{BgRed, BgLightRed, BgYellow, BgLightYellow, BgLightGreen, BgGreen},\n\n\tEnableRGB: false,\n}\n\n// HeatmapData is the type that contains the data of a HeatmapPrinter.\ntype HeatmapData [][]float32\n\ntype HeatmapAxis struct {\n\tXAxis []string\n\tYAxis []string\n}\n\n// HeatmapPrinter is able to render tables.\ntype HeatmapPrinter struct {\n\tHasHeader                  bool\n\tAxisStyle                  *Style\n\tVerticalSeparator          string\n\tTopRightCornerSeparator    string\n\tTopLeftCornerSeparator     string\n\tBottomLeftCornerSeparator  string\n\tBottomRightCornerSeparator string\n\tHorizontalSeparator        string\n\tTSeparator                 string\n\tTReverseSeparator          string\n\tLSeparator                 string\n\tLReverseSeparator          string\n\tTCrossSeparator            string\n\tLegendLabel                string\n\tSeparatorStyle             *Style\n\tData                       HeatmapData\n\tAxis                       HeatmapAxis\n\tBoxed                      bool\n\tGrid                       bool\n\tOnlyColoredCells           bool\n\tLegendOnlyColoredCells     bool\n\tEnableComplementaryColor   bool\n\tLegend                     bool\n\tCellSize                   int\n\tColors                     []Color\n\tTextColor                  Color\n\tEnableRGB                  bool\n\tRGBRange                   []RGB\n\tTextRGB                    RGB\n\tWriter                     io.Writer\n\n\tminValue float32\n\tmaxValue float32\n\n\trgbLegendValue int\n}\n\nvar complementaryColors = map[Color]Color{\n\tBgBlack:        FgLightWhite,\n\tBgRed:          FgCyan,\n\tBgGreen:        FgMagenta,\n\tBgYellow:       FgBlue,\n\tBgBlue:         FgYellow,\n\tBgMagenta:      FgGreen,\n\tBgCyan:         FgRed,\n\tBgWhite:        FgBlack,\n\tBgDefault:      FgBlack,\n\tBgDarkGray:     FgLightWhite,\n\tBgLightRed:     FgLightCyan,\n\tBgLightGreen:   FgLightMagenta,\n\tBgLightYellow:  FgLightBlue,\n\tBgLightBlue:    FgLightYellow,\n\tBgLightMagenta: FgLightGreen,\n\tBgLightCyan:    FgLightRed,\n\tBgLightWhite:   FgBlack,\n}\n\n// WithAxisData returns a new HeatmapPrinter, where the first line and row are headers.\nfunc (p HeatmapPrinter) WithAxisData(hd HeatmapAxis) *HeatmapPrinter {\n\tp.HasHeader = true\n\tp.Axis = hd\n\treturn &p\n}\n\n// WithAxisStyle returns a new HeatmapPrinter with a specific AxisStyle.\nfunc (p HeatmapPrinter) WithAxisStyle(style *Style) *HeatmapPrinter {\n\tp.AxisStyle = style\n\treturn &p\n}\n\n// WithSeparatorStyle returns a new HeatmapPrinter with a specific SeparatorStyle.\nfunc (p HeatmapPrinter) WithSeparatorStyle(style *Style) *HeatmapPrinter {\n\tp.SeparatorStyle = style\n\treturn &p\n}\n\n// WithData returns a new HeatmapPrinter with specific Data.\nfunc (p HeatmapPrinter) WithData(data [][]float32) *HeatmapPrinter {\n\tp.Data = data\n\treturn &p\n}\n\n// WithTextColor returns a new HeatmapPrinter with a specific TextColor.\n// This sets EnableComplementaryColor to false.\nfunc (p HeatmapPrinter) WithTextColor(color Color) *HeatmapPrinter {\n\tp.TextColor = color\n\tp.EnableComplementaryColor = false\n\treturn &p\n}\n\n// WithTextRGB returns a new HeatmapPrinter with a specific TextRGB.\n// This sets EnableComplementaryColor to false.\nfunc (p HeatmapPrinter) WithTextRGB(rgb RGB) *HeatmapPrinter {\n\tp.TextRGB = rgb\n\tp.EnableComplementaryColor = false\n\treturn &p\n}\n\n// WithBoxed returns a new HeatmapPrinter with a box around the table.\n// If set to true, Grid will be set to true too.\nfunc (p HeatmapPrinter) WithBoxed(b ...bool) *HeatmapPrinter {\n\tp.Boxed = internal.WithBoolean(b)\n\tif p.Boxed && !p.Grid {\n\t\tp.Grid = true\n\t}\n\treturn &p\n}\n\n// WithGrid returns a new HeatmapPrinter with a grid.\n// If set to false, Boxed will be set to false too.\nfunc (p HeatmapPrinter) WithGrid(b ...bool) *HeatmapPrinter {\n\tb2 := internal.WithBoolean(b)\n\tp.Grid = b2\n\tif !b2 && p.Boxed {\n\t\tp.Boxed = false\n\t}\n\treturn &p\n}\n\n// WithEnableRGB returns a new HeatmapPrinter with RGB colors.\nfunc (p HeatmapPrinter) WithEnableRGB(b ...bool) *HeatmapPrinter {\n\tp.EnableRGB = internal.WithBoolean(b)\n\treturn &p\n}\n\n// WithOnlyColoredCells returns a new HeatmapPrinter with only colored cells.\nfunc (p HeatmapPrinter) WithOnlyColoredCells(b ...bool) *HeatmapPrinter {\n\tb2 := internal.WithBoolean(b)\n\tp.OnlyColoredCells = b2\n\treturn &p\n}\n\n// WithLegendOnlyColoredCells returns a new HeatmapPrinter with legend with only colored cells.\n// This sets the Legend to true.\nfunc (p HeatmapPrinter) WithLegendOnlyColoredCells(b ...bool) *HeatmapPrinter {\n\tb2 := internal.WithBoolean(b)\n\tp.LegendOnlyColoredCells = b2\n\tif b2 {\n\t\tp.Legend = true\n\t}\n\treturn &p\n}\n\n// WithEnableComplementaryColor returns a new HeatmapPrinter with complement color.\nfunc (p HeatmapPrinter) WithEnableComplementaryColor(b ...bool) *HeatmapPrinter {\n\tp.EnableComplementaryColor = internal.WithBoolean(b)\n\treturn &p\n}\n\n// WithLegend returns a new HeatmapPrinter with a legend.\nfunc (p HeatmapPrinter) WithLegend(b ...bool) *HeatmapPrinter {\n\tp.Legend = internal.WithBoolean(b)\n\treturn &p\n}\n\n// WithCellSize returns a new HeatmapPrinter with a specific cell size.\n// This only works if there is no header and OnlyColoredCells == true!\nfunc (p HeatmapPrinter) WithCellSize(i int) *HeatmapPrinter {\n\tp.CellSize = i\n\treturn &p\n}\n\n// WithLegendLabel returns a new HeatmapPrinter with a specific legend tag.\n// This sets the Legend to true.\nfunc (p HeatmapPrinter) WithLegendLabel(s string) *HeatmapPrinter {\n\tp.LegendLabel = s\n\tp.Legend = true\n\treturn &p\n}\n\n// WithRGBRange returns a new HeatmapPrinter with a specific RGBRange.\nfunc (p HeatmapPrinter) WithRGBRange(rgb ...RGB) *HeatmapPrinter {\n\tp.RGBRange = rgb\n\treturn &p\n}\n\n// WithColors returns a new HeatmapPrinter with a specific Colors.\nfunc (p HeatmapPrinter) WithColors(colors ...Color) *HeatmapPrinter {\n\tp.Colors = colors\n\treturn &p\n}\n\n// WithWriter sets the Writer.\nfunc (p HeatmapPrinter) WithWriter(writer io.Writer) *HeatmapPrinter {\n\tp.Writer = writer\n\treturn &p\n}\n\n// Srender renders the HeatmapPrinter as a string.\nfunc (p HeatmapPrinter) Srender() (string, error) {\n\tif err := p.errCheck(); err != nil {\n\t\treturn \"\", err\n\t}\n\n\tif p.SeparatorStyle == nil {\n\t\tp.SeparatorStyle = DefaultHeatmap.SeparatorStyle\n\t}\n\tif p.AxisStyle == nil {\n\t\tp.AxisStyle = DefaultHeatmap.AxisStyle\n\t}\n\n\tif RawOutput {\n\t\tp.Legend = false\n\t}\n\n\tbuffer := bytes.NewBufferString(\"\")\n\txAmount := len(p.Data[0]) - 1\n\tyAmount := len(p.Data) - 1\n\tp.minValue, p.maxValue = minMaxFloat32(p.Data)\n\n\tvar data string\n\tfor _, datum := range p.Data {\n\t\tfor _, f := range datum {\n\t\t\tdata += Sprintf(\"%v\\n\", f)\n\t\t}\n\t}\n\n\tif p.HasHeader {\n\t\tdata, xAmount, yAmount = p.computeAxisData(data, xAmount, yAmount)\n\t}\n\n\tcolWidth := internal.GetStringMaxWidth(data)\n\tlegendColWidth := colWidth + 2\n\n\tif p.OnlyColoredCells && (p.CellSize > colWidth || !p.HasHeader) {\n\t\tcolWidth = p.CellSize\n\t}\n\n\tif p.Boxed {\n\t\tp.renderSeparatorRow(buffer, colWidth, xAmount, true)\n\t}\n\n\tp.renderData(buffer, colWidth, xAmount, yAmount)\n\n\tif p.HasHeader {\n\t\tp.renderHeader(buffer, colWidth, xAmount)\n\t}\n\n\tif p.Boxed {\n\t\tp.renderSeparatorRow(buffer, colWidth, xAmount, false)\n\t}\n\n\tif p.Legend {\n\t\tp.renderLegend(buffer, legendColWidth)\n\t}\n\n\tbuffer.WriteString(\"\\n\")\n\n\treturn buffer.String(), nil\n}\n\nfunc (p HeatmapPrinter) computeAxisData(data string, xAmount, yAmount int) (string, int, int) {\n\tvar header string\n\tfor _, h := range p.Axis.XAxis {\n\t\theader += h + \"\\n\"\n\t}\n\tfor _, h := range p.Axis.YAxis {\n\t\theader += h + \"\\n\"\n\t}\n\n\tif p.OnlyColoredCells {\n\t\tdata = header\n\t} else {\n\t\tdata += header\n\t}\n\txAmount++\n\tyAmount++\n\n\tp.Axis.YAxis = append(p.Axis.YAxis, \"\")\n\n\treturn data, xAmount, yAmount\n}\n\nfunc (p HeatmapPrinter) renderSeparatorRow(buffer *bytes.Buffer, colWidth, xAmount int, top bool) {\n\ttSep := p.TReverseSeparator\n\trightSep := p.TopRightCornerSeparator\n\tleftSep := p.TopLeftCornerSeparator\n\n\tif top {\n\t\ttSep = p.TSeparator\n\t\trightSep = p.BottomRightCornerSeparator\n\t\tleftSep = p.BottomLeftCornerSeparator\n\t} else {\n\t\tbuffer.WriteString(\"\\n\")\n\t}\n\tbuffer.WriteString(p.SeparatorStyle.Sprint(rightSep))\n\tfor i := 0; i < xAmount+1; i++ {\n\t\tbuffer.WriteString(strings.Repeat(p.SeparatorStyle.Sprint(p.HorizontalSeparator), colWidth))\n\t\tif i < xAmount {\n\t\t\tbuffer.WriteString(p.SeparatorStyle.Sprint(tSep))\n\t\t}\n\t}\n\tbuffer.WriteString(p.SeparatorStyle.Sprint(leftSep))\n\n\tif top {\n\t\tbuffer.WriteString(\"\\n\")\n\t}\n}\n\nfunc (p HeatmapPrinter) renderLegend(buffer *bytes.Buffer, legendColWidth int) {\n\tbuffer.WriteString(\"\\n\")\n\tbuffer.WriteString(\"\\n\")\n\tif p.Boxed {\n\t\tp.boxLegend(buffer, p.LegendLabel, legendColWidth)\n\t} else {\n\t\tp.generateLegend(buffer, p.LegendLabel, legendColWidth)\n\t}\n}\n\nfunc (p HeatmapPrinter) renderHeader(buffer *bytes.Buffer, colWidth int, xAmount int) {\n\tbuffer.WriteString(\"\\n\")\n\tif p.Boxed {\n\t\tbuffer.WriteString(p.SeparatorStyle.Sprint(p.LSeparator))\n\t}\n\tif p.Grid {\n\t\tfor i := 0; i < xAmount+1; i++ {\n\t\t\tbuffer.WriteString(strings.Repeat(p.SeparatorStyle.Sprint(p.HorizontalSeparator), colWidth))\n\t\t\tif i < xAmount {\n\t\t\t\tbuffer.WriteString(p.SeparatorStyle.Sprint(p.TCrossSeparator))\n\t\t\t}\n\t\t}\n\t}\n\tif p.Boxed {\n\t\tbuffer.WriteString(p.SeparatorStyle.Sprint(p.LReverseSeparator))\n\t}\n\tif p.Grid {\n\t\tbuffer.WriteString(\"\\n\")\n\t}\n\tfor j, f := range p.Axis.XAxis {\n\t\tif j == 0 {\n\t\t\tif p.Boxed {\n\t\t\t\tbuffer.WriteString(p.SeparatorStyle.Sprint(p.VerticalSeparator))\n\t\t\t}\n\t\t\tct := internal.CenterText(\" \", colWidth)\n\t\t\tif len(ct) < colWidth {\n\t\t\t\tct += strings.Repeat(\" \", colWidth-len(ct))\n\t\t\t}\n\t\t\tbuffer.WriteString(p.AxisStyle.Sprint(ct))\n\t\t\tif p.Grid {\n\t\t\t\tbuffer.WriteString(p.SeparatorStyle.Sprint(p.VerticalSeparator))\n\t\t\t}\n\t\t}\n\t\tvar ct string\n\t\tct = internal.CenterText(Sprintf(\"%v\", f), colWidth)\n\t\tif len(ct) < colWidth {\n\t\t\tct += strings.Repeat(\" \", colWidth-len(ct))\n\t\t}\n\t\tbuffer.WriteString(p.AxisStyle.Sprint(ct))\n\n\t\tif j < xAmount {\n\t\t\tif !p.Boxed && j == xAmount-1 {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif p.Grid {\n\t\t\t\tbuffer.WriteString(p.SeparatorStyle.Sprint(p.VerticalSeparator))\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc (p HeatmapPrinter) renderData(buffer *bytes.Buffer, colWidth int, xAmount int, yAmount int) {\n\tfor i, datum := range p.Data {\n\t\tif p.Boxed {\n\t\t\tbuffer.WriteString(p.SeparatorStyle.Sprint(p.VerticalSeparator))\n\t\t}\n\t\tfor j, f := range datum {\n\t\t\tif j == 0 && p.HasHeader {\n\t\t\t\tct := internal.CenterText(p.Axis.YAxis[i], colWidth)\n\t\t\t\tif len(ct) < colWidth {\n\t\t\t\t\tct += strings.Repeat(\" \", colWidth-len(ct))\n\t\t\t\t}\n\t\t\t\tbuffer.WriteString(p.AxisStyle.Sprint(ct))\n\t\t\t\tif p.Grid {\n\t\t\t\t\tbuffer.WriteString(p.SeparatorStyle.Sprint(p.VerticalSeparator))\n\t\t\t\t}\n\t\t\t}\n\t\t\tvar ct string\n\t\t\tif p.OnlyColoredCells {\n\t\t\t\tct = internal.CenterText(\" \", colWidth)\n\t\t\t} else {\n\t\t\t\tct = internal.CenterText(Sprintf(\"%v\", f), colWidth)\n\t\t\t}\n\t\t\tif len(ct) < colWidth {\n\t\t\t\tif len(Sprintf(\"%v\", f)) == 1 {\n\t\t\t\t\tct += strings.Repeat(\" \", colWidth-len(ct))\n\t\t\t\t} else {\n\t\t\t\t\tct = strings.Repeat(\" \", colWidth-len(ct)) + ct\n\t\t\t\t}\n\t\t\t}\n\t\t\tif p.EnableRGB {\n\t\t\t\trgb := p.RGBRange[0].Fade(p.minValue, p.maxValue, f, p.RGBRange[1:]...)\n\t\t\t\trgbStyle := NewRGBStyle(p.TextRGB, rgb)\n\t\t\t\tif p.EnableComplementaryColor {\n\t\t\t\t\tcomplimentary := NewRGB(internal.Complementary(rgb.R, rgb.G, rgb.B))\n\t\t\t\t\trgbStyle = NewRGBStyle(complimentary, rgb)\n\t\t\t\t}\n\t\t\t\tbuffer.WriteString(rgbStyle.Sprint(ct))\n\t\t\t} else {\n\t\t\t\tcolor := getColor(p.minValue, p.maxValue, f, p.Colors...)\n\t\t\t\tfgColor := p.TextColor\n\t\t\t\tif p.EnableComplementaryColor {\n\t\t\t\t\tfgColor = complementaryColors[color]\n\t\t\t\t}\n\t\t\t\tbuffer.WriteString(fgColor.Sprint(color.Sprintf(\"%s\", ct)))\n\t\t\t}\n\t\t\tif j < xAmount {\n\t\t\t\tif !p.Boxed && p.HasHeader && j == xAmount-1 {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\tif p.Grid {\n\t\t\t\t\tbuffer.WriteString(p.SeparatorStyle.Sprint(p.VerticalSeparator))\n\t\t\t\t}\n\t\t\t}\n\t\t\tif p.Boxed && !p.HasHeader && j == xAmount {\n\t\t\t\tbuffer.WriteString(p.SeparatorStyle.Sprint(p.VerticalSeparator))\n\t\t\t}\n\t\t}\n\n\t\tif i < yAmount {\n\t\t\tif p.HasHeader && i == yAmount-1 {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tbuffer.WriteString(\"\\n\")\n\t\t\tif p.Boxed {\n\t\t\t\tbuffer.WriteString(p.SeparatorStyle.Sprint(p.LSeparator))\n\t\t\t}\n\t\t\tif p.Grid {\n\t\t\t\tfor i := 0; i < xAmount+1; i++ {\n\t\t\t\t\tbuffer.WriteString(strings.Repeat(p.SeparatorStyle.Sprint(p.HorizontalSeparator), colWidth))\n\t\t\t\t\tif i < xAmount {\n\t\t\t\t\t\tbuffer.WriteString(p.SeparatorStyle.Sprint(p.TCrossSeparator))\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif p.Boxed {\n\t\t\t\tbuffer.WriteString(p.SeparatorStyle.Sprint(p.LReverseSeparator))\n\t\t\t}\n\t\t\tif p.Grid {\n\t\t\t\tbuffer.WriteString(\"\\n\")\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc (p HeatmapPrinter) generateLegend(buffer *bytes.Buffer, legend string, legendColWidth int) {\n\tbuffer.WriteString(p.AxisStyle.Sprint(legend))\n\tif p.Grid {\n\t\tbuffer.WriteString(p.SeparatorStyle.Sprintf(\"%s\", p.VerticalSeparator))\n\t} else {\n\t\tbuffer.WriteString(\" \")\n\t}\n\tif p.EnableRGB {\n\t\tp.generateRGBLegend(buffer, legendColWidth)\n\t} else {\n\t\tp.generateColorLegend(buffer, legendColWidth)\n\t}\n}\n\nfunc (p HeatmapPrinter) generateColorLegend(buffer *bytes.Buffer, legendColWidth int) {\n\tfor i, color := range p.Colors {\n\t\t// the first color is the min value and the last color is the max value\n\t\tvar f float32\n\t\tif i == 0 {\n\t\t\tf = p.minValue\n\t\t} else if i == len(p.Colors)-1 {\n\t\t\tf = p.maxValue\n\t\t} else {\n\t\t\tf = p.minValue + (p.maxValue-p.minValue)*float32(i)/float32(len(p.Colors)-1)\n\t\t}\n\t\tfgColor := p.TextColor\n\t\tif p.EnableComplementaryColor {\n\t\t\tfgColor = complementaryColors[color]\n\t\t}\n\t\tbuffer.WriteString(fgColor.Sprint(color.Sprint(centerAndShorten(f, legendColWidth, p.LegendOnlyColoredCells))))\n\t\tif p.Grid && i < len(p.Colors)-1 && !p.LegendOnlyColoredCells {\n\t\t\tbuffer.WriteString(p.SeparatorStyle.Sprintf(\"%s\", p.VerticalSeparator))\n\t\t}\n\t}\n}\n\nfunc (p HeatmapPrinter) generateRGBLegend(buffer *bytes.Buffer, legendColWidth int) {\n\tp.rgbLegendValue = 10\n\tsteps := len(p.RGBRange)\n\tif steps < p.rgbLegendValue {\n\t\tsteps = p.rgbLegendValue\n\t}\n\tif p.LegendOnlyColoredCells {\n\t\tsteps *= 3\n\t}\n\tfor i := 0; i < steps; i++ {\n\t\t// the first color is the min value and the last color is the max value\n\t\tvar f float32\n\t\tif i == 0 {\n\t\t\tf = p.minValue\n\t\t} else if i == steps-1 {\n\t\t\tf = p.maxValue\n\t\t} else {\n\t\t\tf = p.minValue + (p.maxValue-p.minValue)*float32(i)/float32(steps-1)\n\t\t}\n\t\trgb := p.RGBRange[0].Fade(p.minValue, p.maxValue, f, p.RGBRange[1:]...)\n\t\trgbStyle := NewRGBStyle(p.TextRGB, rgb)\n\t\tif p.EnableComplementaryColor {\n\t\t\tcomplimentary := NewRGB(internal.Complementary(rgb.R, rgb.G, rgb.B))\n\t\t\trgbStyle = NewRGBStyle(complimentary, rgb)\n\t\t}\n\t\tif p.LegendOnlyColoredCells {\n\t\t\tbuffer.WriteString(rgbStyle.Sprint(centerAndShorten(f, 1, p.LegendOnlyColoredCells)))\n\t\t} else {\n\t\t\tbuffer.WriteString(rgbStyle.Sprint(centerAndShorten(f, legendColWidth, p.LegendOnlyColoredCells)))\n\t\t}\n\t\tif p.Grid && i < steps-1 && !p.LegendOnlyColoredCells {\n\t\t\tbuffer.WriteString(p.SeparatorStyle.Sprintf(\"%s\", p.VerticalSeparator))\n\t\t}\n\t}\n}\n\nfunc (p HeatmapPrinter) boxLegend(buffer *bytes.Buffer, legend string, legendColWidth int) {\n\tbuffer.WriteString(p.SeparatorStyle.Sprint(p.BottomRightCornerSeparator))\n\n\tp.generateSeparatorRow(buffer, legend, legendColWidth, true)\n\n\tbuffer.WriteString(p.SeparatorStyle.Sprint(p.BottomLeftCornerSeparator))\n\tbuffer.WriteString(\"\\n\")\n\tbuffer.WriteString(p.SeparatorStyle.Sprintf(\"%s\", p.VerticalSeparator))\n\n\tp.generateLegend(buffer, legend, legendColWidth)\n\n\tbuffer.WriteString(p.SeparatorStyle.Sprintf(\"%s\", p.VerticalSeparator))\n\tbuffer.WriteString(\"\\n\")\n\n\tbuffer.WriteString(p.SeparatorStyle.Sprint(p.TopRightCornerSeparator))\n\n\tp.generateSeparatorRow(buffer, legend, legendColWidth, false)\n\n\tbuffer.WriteString(p.SeparatorStyle.Sprint(p.TopLeftCornerSeparator))\n}\n\nfunc (p HeatmapPrinter) generateSeparatorRow(buffer *bytes.Buffer, legend string, legendColWidth int, top bool) {\n\tp.rgbLegendValue = 10\n\tsteps := len(p.RGBRange)\n\tif steps < p.rgbLegendValue {\n\t\tsteps = p.rgbLegendValue\n\t}\n\tif p.LegendOnlyColoredCells {\n\t\tsteps *= 3\n\t}\n\n\tvar xValue int\n\tif p.EnableRGB {\n\t\txValue = len(p.RGBRange)\n\t\tif xValue < p.rgbLegendValue {\n\t\t\txValue = p.rgbLegendValue\n\t\t}\n\t} else {\n\t\txValue = len(p.Colors)\n\t}\n\n\tfor i := 0; i < xValue+1; i++ {\n\t\tif i == 0 {\n\t\t\tfirstLength := len(legend)\n\t\t\tbuffer.WriteString(strings.Repeat(p.SeparatorStyle.Sprint(p.HorizontalSeparator), firstLength))\n\t\t} else {\n\t\t\tif p.LegendOnlyColoredCells {\n\t\t\t\tif p.EnableRGB {\n\t\t\t\t\tbuffer.WriteString(strings.Repeat(p.SeparatorStyle.Sprint(p.HorizontalSeparator), steps/(xValue)))\n\t\t\t\t} else {\n\t\t\t\t\tbuffer.WriteString(strings.Repeat(p.SeparatorStyle.Sprint(p.HorizontalSeparator), legendColWidth))\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tbuffer.WriteString(strings.Repeat(p.SeparatorStyle.Sprint(p.HorizontalSeparator), legendColWidth))\n\t\t\t}\n\t\t}\n\t\tif i < xValue && !p.LegendOnlyColoredCells || i == 0 {\n\t\t\tif top {\n\t\t\t\tbuffer.WriteString(p.SeparatorStyle.Sprint(p.TSeparator))\n\t\t\t} else {\n\t\t\t\tbuffer.WriteString(p.SeparatorStyle.Sprint(p.TReverseSeparator))\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc centerAndShorten(f float32, lineLength int, onlyColor bool) string {\n\tvalue := \"\"\n\tif !onlyColor {\n\t\tvalue = Sprintf(\"%.2v\", f)\n\t}\n\tif len(value) > lineLength {\n\t\tvalue = value[:lineLength]\n\t\tif strings.HasSuffix(value, \".\") {\n\t\t\tvalue = Sprintf(\"%.1v\", f)\n\t\t\tlineLength = len(value)\n\t\t}\n\t}\n\tct := internal.CenterText(value, lineLength)\n\tif len(ct) < lineLength {\n\t\tif len(Sprintf(\"%v\", f)) == 1 {\n\t\t\tct += strings.Repeat(\" \", lineLength-len(ct))\n\t\t} else {\n\t\t\tct = strings.Repeat(\" \", lineLength-len(ct)) + ct\n\t\t}\n\t}\n\n\treturn ct\n}\n\nfunc getColor(minStep float32, maxStep float32, current float32, colors ...Color) Color {\n\t// split the range into equal parts\n\t// and assign a color to each part\n\t// the last color is assigned to the max value\n\t// and the first color to the min value\n\t// the rest of the colors are assigned to the\n\t// middle values\n\tstep := (maxStep - minStep) / float32(len(colors))\n\tfor i := range colors {\n\t\tif current >= minStep+float32(i)*step && current < minStep+float32(i+1)*step {\n\t\t\treturn colors[i]\n\t\t}\n\t}\n\treturn colors[len(colors)-1]\n}\n\n// Render prints the HeatmapPrinter to the terminal.\nfunc (p HeatmapPrinter) Render() error {\n\ts, err := p.Srender()\n\tif err != nil {\n\t\treturn err\n\t}\n\tFprintln(p.Writer, s)\n\n\treturn nil\n}\n\nfunc (p HeatmapPrinter) errCheck() error {\n\tif p.HasHeader {\n\t\tif p.Axis.XAxis == nil {\n\t\t\treturn errors.New(\"x axis is nil\")\n\t\t}\n\t\tif p.Axis.YAxis == nil {\n\t\t\treturn errors.New(\"y axis is nil\")\n\t\t}\n\n\t\tif len(p.Axis.XAxis) == 0 {\n\t\t\treturn errors.New(\"x axis is empty\")\n\t\t}\n\t\tif len(p.Axis.YAxis) == 0 {\n\t\t\treturn errors.New(\"y axis is empty\")\n\t\t}\n\n\t\tfor i := 1; i < len(p.Data); i++ {\n\t\t\tif len(p.Data[i]) != len(p.Axis.XAxis) {\n\t\t\t\treturn errors.New(\"x axis length does not match data\")\n\t\t\t}\n\t\t}\n\t\tif len(p.Axis.YAxis) != len(p.Data) {\n\t\t\treturn errors.New(\"y axis length does not match data\")\n\t\t}\n\t}\n\n\tif p.Data == nil {\n\t\treturn errors.New(\"data is nil\")\n\t}\n\n\tif len(p.Data) == 0 {\n\t\treturn errors.New(\"data is empty\")\n\t}\n\n\t// check if p.Data[n] has the same length\n\tfor i := 1; i < len(p.Data); i++ {\n\t\tif len(p.Data[i]) != len(p.Data[0]) {\n\t\t\treturn errors.New(\"data is not rectangular\")\n\t\t}\n\t}\n\n\treturn nil\n}\n\n// return min and max value of a slice\nfunc minMaxFloat32(s [][]float32) (float32, float32) {\n\tvar minslice, maxslice float32\n\tminslice = math.MaxFloat32\n\tmaxslice = -math.MaxFloat32\n\n\tfor _, r := range s {\n\t\tfor _, c := range r {\n\t\t\tif c < minslice {\n\t\t\t\tminslice = c\n\t\t\t}\n\t\t\tif c > maxslice {\n\t\t\t\tmaxslice = c\n\t\t\t}\n\t\t}\n\t}\n\treturn minslice, maxslice\n}\n"
        },
        {
          "name": "heatmap_printer_test.go",
          "type": "blob",
          "size": 3.5927734375,
          "content": "package pterm_test\n\nimport (\n\t\"os\"\n\t\"testing\"\n\n\t\"github.com/MarvinJWendt/testza\"\n\n\t\"github.com/pterm/pterm\"\n)\n\nfunc TestHeatmapPrinter_NilPrint(t *testing.T) {\n\tp := pterm.HeatmapPrinter{}\n\tp.Render()\n}\n\nfunc TestHeatmapPrinter_SRender(t *testing.T) {\n\td := [][]float32{\n\t\t{-1, -0.9, -0.8},\n\t\t{-1, -0.9, -0.8},\n\t\t{-1, -0.9, -0.8},\n\t}\n\n\thd := pterm.HeatmapAxis{\n\t\tXAxis: []string{\"a\", \"b\", \"c\"},\n\t\tYAxis: []string{\"1\", \"2\", \"3\"},\n\t}\n\t// WithGrid\n\tprinter := pterm.DefaultHeatmap.WithAxisData(hd).WithData(d)\n\tcontent, err := printer.Srender()\n\n\ttestza.AssertNoError(t, err)\n\ttestza.AssertNotNil(t, content)\n\n\t// WithoutGrid\n\tprinter = pterm.DefaultHeatmap.WithAxisData(hd).WithData(d).WithGrid(false)\n\tcontent, err = printer.Srender()\n\n\ttestza.AssertNoError(t, err)\n\ttestza.AssertNotNil(t, content)\n\n\t// WithColouredCells\n\tprinter = pterm.DefaultHeatmap.WithAxisData(hd).WithData(d).WithOnlyColoredCells()\n\tcontent, err = printer.Srender()\n\n\ttestza.AssertNoError(t, err)\n\ttestza.AssertNotNil(t, content)\n\n\t// WithoutStyle\n\tprinter = pterm.DefaultHeatmap.WithAxisData(hd).WithData(d).WithAxisStyle(nil)\n\tcontent, err = printer.Srender()\n\n\ttestza.AssertNoError(t, err)\n\ttestza.AssertNotNil(t, content)\n\n\t// WithoutSeparatorStyle\n\tprinter = pterm.DefaultHeatmap.WithAxisData(hd).WithData(d).WithSeparatorStyle(nil)\n\tcontent, err = printer.Srender()\n\n\ttestza.AssertNoError(t, err)\n\ttestza.AssertNotNil(t, content)\n\n\t// WithEnableRGB\n\tprinter = pterm.DefaultHeatmap.WithAxisData(hd).WithData(d).WithEnableRGB(true)\n\tcontent, err = printer.Srender()\n\n\ttestza.AssertNoError(t, err)\n\ttestza.AssertNotNil(t, content)\n}\n\nfunc TestHeatmapPrinter_WithAxisData(t *testing.T) {\n\thd := pterm.HeatmapAxis{\n\t\tXAxis: []string{\"a\", \"b\", \"c\"},\n\t\tYAxis: []string{\"1\", \"2\", \"3\"},\n\t}\n\n\th := pterm.DefaultHeatmap.WithAxisData(hd)\n\n\ttestza.AssertTrue(t, h.HasHeader)\n\ttestza.AssertEqual(t, hd, h.Axis)\n}\n\nfunc TestHeatmapPrinter_WithAxisStyle(t *testing.T) {\n\ts := pterm.NewStyle(pterm.FgRed, pterm.BgBlue, pterm.Bold)\n\tp := pterm.HeatmapPrinter{}\n\tp2 := p.WithAxisStyle(s)\n\n\ttestza.AssertEqual(t, s, p2.AxisStyle)\n}\n\nfunc TestHeatmapPrinter_WithSeparatorStyle(t *testing.T) {\n\ts := pterm.NewStyle(pterm.FgRed, pterm.BgBlue, pterm.Bold)\n\th := pterm.HeatmapPrinter{}\n\th2 := h.WithSeparatorStyle(s)\n\n\ttestza.AssertEqual(t, s, h2.SeparatorStyle)\n}\n\nfunc TestHeatmapPrinter_WithData(t *testing.T) {\n\tproxyToDevNull()\n\td := [][]float32{\n\t\t{-1, -0.9, -0.8, -0.7, -0.6},\n\t\t{-1, -0.9, -0.8, -0.7, -0.6},\n\t}\n\n\th := pterm.HeatmapPrinter{}\n\th2 := h.WithData(d)\n\n\ttestza.AssertEqualValues(t, d, h2.Data)\n}\n\nfunc TestHeatmapPrinter_WithBoxed(t *testing.T) {\n\th := pterm.HeatmapPrinter{}\n\th2 := h.WithBoxed(true)\n\n\ttestza.AssertTrue(t, h2.Boxed)\n}\n\nfunc TestHeatmapPrinter_WithGrid(t *testing.T) {\n\th := pterm.HeatmapPrinter{}\n\th2 := h.WithGrid(true)\n\n\ttestza.AssertTrue(t, h2.Grid)\n}\n\nfunc TestHeatmapPrinter_WithoutGrid(t *testing.T) {\n\th := pterm.DefaultHeatmap\n\th2 := h.WithGrid(false)\n\n\ttestza.AssertFalse(t, h2.Grid)\n\ttestza.AssertFalse(t, h2.Boxed)\n}\n\nfunc TestHeatmapPrinter_WithRGB(t *testing.T) {\n\th := pterm.HeatmapPrinter{}\n\th2 := h.WithEnableRGB(true)\n\n\ttestza.AssertTrue(t, h2.EnableRGB)\n}\n\nfunc TestHeatmapPrinter_WithOnlyColoredCells(t *testing.T) {\n\th := pterm.HeatmapPrinter{}\n\th2 := h.WithOnlyColoredCells(true)\n\n\ttestza.AssertTrue(t, h2.OnlyColoredCells)\n}\n\nfunc TestHeatmapPrinter_WithCellSize(t *testing.T) {\n\th := pterm.HeatmapPrinter{}\n\th2 := h.WithCellSize(1)\n\n\ttestza.AssertEqual(t, 1, h2.CellSize)\n}\n\nfunc TestHeatmapPrinter_WithWriter(t *testing.T) {\n\th := pterm.HeatmapPrinter{}\n\ts := os.Stderr\n\th2 := h.WithWriter(s)\n\n\ttestza.AssertEqual(t, s, h2.Writer)\n\ttestza.AssertZero(t, h.Writer)\n}\n"
        },
        {
          "name": "interactive_confirm_printer.go",
          "type": "blob",
          "size": 4.9091796875,
          "content": "package pterm\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\n\t\"atomicgo.dev/cursor\"\n\t\"atomicgo.dev/keyboard\"\n\t\"atomicgo.dev/keyboard/keys\"\n\n\t\"github.com/pterm/pterm/internal\"\n)\n\n// DefaultInteractiveConfirm is the default InteractiveConfirm printer.\n// Pressing \"y\" will return true, \"n\" will return false.\n// Pressing enter without typing \"y\" or \"n\" will return the configured default value (by default set to \"no\").\nvar DefaultInteractiveConfirm = InteractiveConfirmPrinter{\n\tDefaultValue: false,\n\tDefaultText:  \"Please confirm\",\n\tTextStyle:    &ThemeDefault.PrimaryStyle,\n\tConfirmText:  \"Yes\",\n\tConfirmStyle: &ThemeDefault.SuccessMessageStyle,\n\tRejectText:   \"No\",\n\tRejectStyle:  &ThemeDefault.ErrorMessageStyle,\n\tSuffixStyle:  &ThemeDefault.SecondaryStyle,\n\tDelimiter:    \": \",\n}\n\n// InteractiveConfirmPrinter is a printer for interactive confirm prompts.\ntype InteractiveConfirmPrinter struct {\n\tDefaultValue    bool\n\tDefaultText     string\n\tDelimiter       string\n\tTextStyle       *Style\n\tConfirmText     string\n\tConfirmStyle    *Style\n\tRejectText      string\n\tRejectStyle     *Style\n\tSuffixStyle     *Style\n\tOnInterruptFunc func()\n}\n\n// WithDefaultText sets the default text.\nfunc (p InteractiveConfirmPrinter) WithDefaultText(text string) *InteractiveConfirmPrinter {\n\tp.DefaultText = text\n\treturn &p\n}\n\n// WithDefaultValue sets the default value, which will be returned when the user presses enter without typing \"y\" or \"n\".\nfunc (p InteractiveConfirmPrinter) WithDefaultValue(value bool) *InteractiveConfirmPrinter {\n\tp.DefaultValue = value\n\treturn &p\n}\n\n// WithTextStyle sets the text style.\nfunc (p InteractiveConfirmPrinter) WithTextStyle(style *Style) *InteractiveConfirmPrinter {\n\tp.TextStyle = style\n\treturn &p\n}\n\n// WithConfirmText sets the confirm text.\nfunc (p InteractiveConfirmPrinter) WithConfirmText(text string) *InteractiveConfirmPrinter {\n\tp.ConfirmText = text\n\treturn &p\n}\n\n// WithConfirmStyle sets the confirm style.\nfunc (p InteractiveConfirmPrinter) WithConfirmStyle(style *Style) *InteractiveConfirmPrinter {\n\tp.ConfirmStyle = style\n\treturn &p\n}\n\n// WithRejectText sets the reject text.\nfunc (p InteractiveConfirmPrinter) WithRejectText(text string) *InteractiveConfirmPrinter {\n\tp.RejectText = text\n\treturn &p\n}\n\n// WithRejectStyle sets the reject style.\nfunc (p InteractiveConfirmPrinter) WithRejectStyle(style *Style) *InteractiveConfirmPrinter {\n\tp.RejectStyle = style\n\treturn &p\n}\n\n// WithSuffixStyle sets the suffix style.\nfunc (p InteractiveConfirmPrinter) WithSuffixStyle(style *Style) *InteractiveConfirmPrinter {\n\tp.SuffixStyle = style\n\treturn &p\n}\n\n// OnInterrupt sets the function to execute on exit of the input reader\nfunc (p InteractiveConfirmPrinter) WithOnInterruptFunc(exitFunc func()) *InteractiveConfirmPrinter {\n\tp.OnInterruptFunc = exitFunc\n\treturn &p\n}\n\n// WithDelimiter sets the delimiter between the message and the input.\nfunc (p InteractiveConfirmPrinter) WithDelimiter(delimiter string) *InteractiveConfirmPrinter {\n\tp.Delimiter = delimiter\n\treturn &p\n}\n\n// Show shows the confirm prompt.\n//\n// Example:\n//\n//\tresult, _ := pterm.DefaultInteractiveConfirm.Show(\"Are you sure?\")\n//\tpterm.Println(result)\nfunc (p InteractiveConfirmPrinter) Show(text ...string) (bool, error) {\n\t// should be the first defer statement to make sure it is executed last\n\t// and all the needed cleanup can be done before\n\tcancel, exit := internal.NewCancelationSignal(p.OnInterruptFunc)\n\tdefer exit()\n\n\tvar result bool\n\n\tif len(text) == 0 || text[0] == \"\" {\n\t\ttext = []string{p.DefaultText}\n\t}\n\n\tp.TextStyle.Print(text[0] + \" \" + p.getSuffix() + p.Delimiter)\n\ty, n := p.getShortHandles()\n\n\tvar interrupted bool\n\terr := keyboard.Listen(func(keyInfo keys.Key) (stop bool, err error) {\n\t\tkey := keyInfo.Code\n\t\tchar := strings.ToLower(keyInfo.String())\n\t\tif err != nil {\n\t\t\treturn false, fmt.Errorf(\"failed to get key: %w\", err)\n\t\t}\n\n\t\tswitch key {\n\t\tcase keys.RuneKey:\n\t\t\tswitch char {\n\t\t\tcase y:\n\t\t\t\tp.ConfirmStyle.Print(p.ConfirmText)\n\t\t\t\tPrintln()\n\t\t\t\tresult = true\n\t\t\t\treturn true, nil\n\t\t\tcase n:\n\t\t\t\tp.RejectStyle.Print(p.RejectText)\n\t\t\t\tPrintln()\n\t\t\t\tresult = false\n\t\t\t\treturn true, nil\n\t\t\t}\n\t\tcase keys.Enter:\n\t\t\tif p.DefaultValue {\n\t\t\t\tp.ConfirmStyle.Print(p.ConfirmText)\n\t\t\t} else {\n\t\t\t\tp.RejectStyle.Print(p.RejectText)\n\t\t\t}\n\t\t\tPrintln()\n\t\t\tresult = p.DefaultValue\n\t\t\treturn true, nil\n\t\tcase keys.CtrlC:\n\t\t\tcancel()\n\t\t\tinterrupted = true\n\t\t\treturn true, nil\n\t\t}\n\t\treturn false, nil\n\t})\n\tif !interrupted {\n\t\tcursor.StartOfLine()\n\t}\n\treturn result, err\n}\n\n// getShortHandles returns the short hand answers for the confirmation prompt\nfunc (p InteractiveConfirmPrinter) getShortHandles() (string, string) {\n\ty := strings.ToLower(string([]rune(p.ConfirmText)[0]))\n\tn := strings.ToLower(string([]rune(p.RejectText)[0]))\n\n\treturn y, n\n}\n\n// getSuffix returns the confirmation prompt suffix\nfunc (p InteractiveConfirmPrinter) getSuffix() string {\n\ty, n := p.getShortHandles()\n\tif p.DefaultValue {\n\t\ty = strings.ToUpper(y)\n\t} else {\n\t\tn = strings.ToUpper(n)\n\t}\n\n\treturn p.SuffixStyle.Sprintf(\"[%s/%s]\", y, n)\n}\n"
        },
        {
          "name": "interactive_confirm_printer_test.go",
          "type": "blob",
          "size": 3.8896484375,
          "content": "package pterm_test\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n\n\t\"atomicgo.dev/keyboard\"\n\t\"atomicgo.dev/keyboard/keys\"\n\t\"github.com/MarvinJWendt/testza\"\n\n\t\"github.com/pterm/pterm\"\n)\n\nfunc TestInteractiveConfirmPrinter_Show_yes(t *testing.T) {\n\tgo func() {\n\t\tkeyboard.SimulateKeyPress('y')\n\t}()\n\tresult, _ := pterm.DefaultInteractiveConfirm.Show()\n\ttestza.AssertTrue(t, result)\n}\n\nfunc TestInteractiveConfirmPrinter_Show_no(t *testing.T) {\n\tgo func() {\n\t\tkeyboard.SimulateKeyPress('n')\n\t}()\n\tresult, _ := pterm.DefaultInteractiveConfirm.Show()\n\ttestza.AssertFalse(t, result)\n}\n\nfunc TestInteractiveConfirmPrinter_WithDefaultValue(t *testing.T) {\n\tp := pterm.DefaultInteractiveConfirm.WithDefaultValue(true)\n\ttestza.AssertTrue(t, p.DefaultValue)\n}\n\nfunc TestInteractiveConfirmPrinter_WithDefaultValue_false(t *testing.T) {\n\tgo func() {\n\t\tkeyboard.SimulateKeyPress(keys.Enter)\n\t}()\n\tp := pterm.DefaultInteractiveConfirm.WithDefaultValue(false)\n\tresult, _ := p.Show()\n\ttestza.AssertFalse(t, result)\n}\n\nfunc TestInteractiveConfirmPrinter_WithDefaultValue_true(t *testing.T) {\n\tgo func() {\n\t\tkeyboard.SimulateKeyPress(keys.Enter)\n\t}()\n\tp := pterm.DefaultInteractiveConfirm.WithDefaultValue(true)\n\tresult, _ := p.Show()\n\ttestza.AssertTrue(t, result)\n}\n\nfunc TestInteractiveConfirmPrinter_WithConfirmStyle(t *testing.T) {\n\tstyle := pterm.NewStyle(pterm.FgRed)\n\tp := pterm.DefaultInteractiveConfirm.WithConfirmStyle(style)\n\ttestza.AssertEqual(t, p.ConfirmStyle, style)\n}\n\nfunc TestInteractiveConfirmPrinter_WithConfirmText(t *testing.T) {\n\tp := pterm.DefaultInteractiveConfirm.WithConfirmText(\"confirm\")\n\ttestza.AssertEqual(t, p.ConfirmText, \"confirm\")\n}\n\nfunc TestInteractiveConfirmPrinter_WithDefaultText(t *testing.T) {\n\tp := pterm.DefaultInteractiveConfirm.WithDefaultText(\"default\")\n\ttestza.AssertEqual(t, p.DefaultText, \"default\")\n}\n\nfunc TestInteractiveConfirmPrinter_WithDelimiter(t *testing.T) {\n\tp := pterm.DefaultInteractiveConfirm.WithDelimiter(\">>\")\n\ttestza.AssertEqual(t, p.Delimiter, \">>\")\n}\n\nfunc TestInteractiveConfirmPrinter_WithRejectStyle(t *testing.T) {\n\tstyle := pterm.NewStyle(pterm.FgRed)\n\tp := pterm.DefaultInteractiveConfirm.WithRejectStyle(style)\n\ttestza.AssertEqual(t, p.RejectStyle, style)\n}\n\nfunc TestInteractiveConfirmPrinter_WithRejectText(t *testing.T) {\n\tp := pterm.DefaultInteractiveConfirm.WithRejectText(\"reject\")\n\ttestza.AssertEqual(t, p.RejectText, \"reject\")\n}\n\nfunc TestInteractiveConfirmPrinter_CustomAnswers(t *testing.T) {\n\tp := pterm.DefaultInteractiveConfirm.WithRejectText(\"reject\").WithConfirmText(\"accept\")\n\ttests := []struct {\n\t\tname     string\n\t\tkey      rune\n\t\texpected bool\n\t}{\n\t\t{\n\t\t\tname:     \"Accept_upper_case\",\n\t\t\tkey:      'A',\n\t\t\texpected: true,\n\t\t},\n\t\t{\n\t\t\tname:     \"Accept_lower\",\n\t\t\tkey:      'a',\n\t\t\texpected: true,\n\t\t},\n\t\t{\n\t\t\tname:     \"Reject_upper_case\",\n\t\t\tkey:      'R',\n\t\t\texpected: false,\n\t\t},\n\t\t{\n\t\t\tname:     \"Reject_lower_case\",\n\t\t\tkey:      'r',\n\t\t\texpected: false,\n\t\t},\n\t}\n\tfor _, tc := range tests {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tgo func() {\n\t\t\t\tkeyboard.SimulateKeyPress(tc.key)\n\t\t\t}()\n\t\t\tresult, _ := p.Show()\n\t\t\ttestza.AssertEqual(t, result, tc.expected)\n\t\t})\n\t}\n}\n\nfunc TestInteractiveConfirmPrinter_WithSuffixStyle(t *testing.T) {\n\tstyle := pterm.NewStyle(pterm.FgRed)\n\tp := pterm.DefaultInteractiveConfirm.WithSuffixStyle(style)\n\ttestza.AssertEqual(t, p.SuffixStyle, style)\n}\n\nfunc TestInteractiveConfirmPrinter_WithTextStyle(t *testing.T) {\n\tstyle := pterm.NewStyle(pterm.FgRed)\n\tp := pterm.DefaultInteractiveConfirm.WithTextStyle(style)\n\ttestza.AssertEqual(t, p.TextStyle, style)\n}\n\nfunc TestInteractiveConfirmPrinter_WithOnInterruptFunc(t *testing.T) {\n\t// OnInterrupt function defaults to nil\n\tpd := pterm.InteractiveConfirmPrinter{}\n\ttestza.AssertNil(t, pd.OnInterruptFunc)\n\n\t// Verify OnInterrupt is set\n\texitfunc := func() {}\n\tp := pterm.DefaultInteractiveConfirm.WithOnInterruptFunc(exitfunc)\n\ttestza.AssertEqual(t, reflect.ValueOf(p.OnInterruptFunc).Pointer(), reflect.ValueOf(exitfunc).Pointer())\n}\n"
        },
        {
          "name": "interactive_continue_printer.go",
          "type": "blob",
          "size": 5.720703125,
          "content": "package pterm\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\n\t\"atomicgo.dev/cursor\"\n\t\"atomicgo.dev/keyboard\"\n\t\"atomicgo.dev/keyboard/keys\"\n\t\"golang.org/x/text/cases\"\n\t\"golang.org/x/text/language\"\n\n\t\"github.com/pterm/pterm/internal\"\n)\n\n// DefaultInteractiveContinue is the default InteractiveContinue printer.\n// Pressing \"y\" will return yes, \"n\" will return no, \"a\" returns all and \"s\" returns stop.\n// Pressing enter without typing any letter will return the configured default value (by default set to \"yes\", the fisrt option).\nvar DefaultInteractiveContinue = InteractiveContinuePrinter{\n\tDefaultValueIndex: 0,\n\tDefaultText:       \"Do you want to continue\",\n\tTextStyle:         &ThemeDefault.PrimaryStyle,\n\tOptions:           []string{\"yes\", \"no\", \"all\", \"cancel\"},\n\tOptionsStyle:      &ThemeDefault.SuccessMessageStyle,\n\tSuffixStyle:       &ThemeDefault.SecondaryStyle,\n\tDelimiter:         \": \",\n}\n\n// InteractiveContinuePrinter is a printer for interactive continue prompts.\ntype InteractiveContinuePrinter struct {\n\tDefaultValueIndex int\n\tDefaultText       string\n\tDelimiter         string\n\tTextStyle         *Style\n\tOptions           []string\n\tOptionsStyle      *Style\n\tHandles           []string\n\tShowShortHandles  bool\n\tSuffixStyle       *Style\n}\n\n// WithDefaultText sets the default text.\nfunc (p InteractiveContinuePrinter) WithDefaultText(text string) *InteractiveContinuePrinter {\n\tp.DefaultText = text\n\treturn &p\n}\n\n// WithDefaultValueIndex sets the default value, which will be returned when the user presses enter without typing any letter.\nfunc (p InteractiveContinuePrinter) WithDefaultValueIndex(value int) *InteractiveContinuePrinter {\n\tif value >= len(p.Options) {\n\t\tpanic(\"Index out of range\")\n\t}\n\tp.DefaultValueIndex = value\n\treturn &p\n}\n\n// WithDefaultValue sets the default value, which will be returned when the user presses enter without typing any letter.\nfunc (p InteractiveContinuePrinter) WithDefaultValue(value string) *InteractiveContinuePrinter {\n\tfor i, o := range p.Options {\n\t\tif o == value {\n\t\t\tp.DefaultValueIndex = i\n\t\t\tbreak\n\t\t}\n\t}\n\treturn &p\n}\n\n// WithTextStyle sets the text style.\nfunc (p InteractiveContinuePrinter) WithTextStyle(style *Style) *InteractiveContinuePrinter {\n\tp.TextStyle = style\n\treturn &p\n}\n\n// WithOptions sets the options.\nfunc (p InteractiveContinuePrinter) WithOptions(options []string) *InteractiveContinuePrinter {\n\tp.Options = options\n\treturn &p\n}\n\n// WithHandles allows you to customize the short handles for the answers.\nfunc (p InteractiveContinuePrinter) WithHandles(handles []string) *InteractiveContinuePrinter {\n\tif len(handles) != len(p.Options) {\n\t\tWarning.Printf(\"%v is not a valid set of handles\", handles)\n\t\tp.setDefaultHandles()\n\t\treturn &p\n\t}\n\tp.Handles = handles\n\treturn &p\n}\n\n// WithShowShortHandles will set ShowShortHandles to true\n// this makes the printer display the shorthand options instead their shorthand version.\nfunc (p InteractiveContinuePrinter) WithShowShortHandles(b ...bool) *InteractiveContinuePrinter {\n\tp.ShowShortHandles = internal.WithBoolean(b)\n\treturn &p\n}\n\n// WithOptionsStyle sets the continue style.\nfunc (p InteractiveContinuePrinter) WithOptionsStyle(style *Style) *InteractiveContinuePrinter {\n\tp.OptionsStyle = style\n\treturn &p\n}\n\n// WithSuffixStyle sets the suffix style.\nfunc (p InteractiveContinuePrinter) WithSuffixStyle(style *Style) *InteractiveContinuePrinter {\n\tp.SuffixStyle = style\n\treturn &p\n}\n\n// WithDelimiter sets the delimiter between the message and the input.\nfunc (p InteractiveContinuePrinter) WithDelimiter(delimiter string) *InteractiveContinuePrinter {\n\tp.Delimiter = delimiter\n\treturn &p\n}\n\n// Show shows the continue prompt.\n//\n// Example:\n//\n//\tresult, _ := pterm.DefaultInteractiveContinue.Show(\"Do you want to apply the changes?\")\n//\tpterm.Println(result)\nfunc (p InteractiveContinuePrinter) Show(text ...string) (string, error) {\n\tvar result string\n\n\tif len(text) == 0 || text[0] == \"\" {\n\t\ttext = []string{p.DefaultText}\n\t}\n\n\tp.TextStyle.Print(text[0] + \" \" + p.getSuffix() + p.Delimiter)\n\n\terr := keyboard.Listen(func(keyInfo keys.Key) (stop bool, err error) {\n\t\tif err != nil {\n\t\t\treturn false, fmt.Errorf(\"failed to get key: %w\", err)\n\t\t}\n\t\tkey := keyInfo.Code\n\t\tchar := keyInfo.String()\n\n\t\tswitch key {\n\t\tcase keys.RuneKey:\n\t\t\tfor i, c := range p.Handles {\n\t\t\t\tif !p.ShowShortHandles {\n\t\t\t\t\tc = string([]rune(c)[0])\n\t\t\t\t}\n\t\t\t\tif char == c || (i == p.DefaultValueIndex && strings.EqualFold(c, char)) {\n\t\t\t\t\tp.OptionsStyle.Print(p.Options[i])\n\t\t\t\t\tPrintln()\n\t\t\t\t\tresult = p.Options[i]\n\t\t\t\t\treturn true, nil\n\t\t\t\t}\n\t\t\t}\n\t\tcase keys.Enter:\n\t\t\tp.OptionsStyle.Print(p.Options[p.DefaultValueIndex])\n\t\t\tPrintln()\n\t\t\tresult = p.Options[p.DefaultValueIndex]\n\t\t\treturn true, nil\n\t\tcase keys.CtrlC:\n\t\t\tinternal.Exit(1)\n\t\t\treturn true, nil\n\t\t}\n\t\treturn false, nil\n\t})\n\tcursor.StartOfLine()\n\treturn result, err\n}\n\n// getShortHandles returns the short hand answers for the continueation prompt\nfunc (p InteractiveContinuePrinter) getShortHandles() []string {\n\tvar handles []string\n\tfor _, option := range p.Options {\n\t\thandles = append(handles, strings.ToLower(string([]rune(option)[0])))\n\t}\n\thandles[p.DefaultValueIndex] = strings.ToUpper(handles[p.DefaultValueIndex])\n\n\treturn handles\n}\n\n// setDefaultHandles initialises the handles\nfunc (p *InteractiveContinuePrinter) setDefaultHandles() {\n\tif p.ShowShortHandles {\n\t\tp.Handles = p.getShortHandles()\n\t}\n\n\tif len(p.Handles) == 0 {\n\t\tp.Handles = make([]string, len(p.Options))\n\t\tcopy(p.Handles, p.Options)\n\t\tp.Handles[p.DefaultValueIndex] = cases.Title(language.Und, cases.Compact).String(p.Handles[p.DefaultValueIndex])\n\t}\n}\n\n// getSuffix returns the continuation prompt suffix\nfunc (p *InteractiveContinuePrinter) getSuffix() string {\n\tif p.Handles == nil || len(p.Handles) != len(p.Options) {\n\t\tp.setDefaultHandles()\n\t}\n\n\treturn p.SuffixStyle.Sprintf(\"[%s]\", strings.Join(p.Handles, \"/\"))\n}\n"
        },
        {
          "name": "interactive_continue_printer_test.go",
          "type": "blob",
          "size": 4.669921875,
          "content": "package pterm_test\n\nimport (\n\t\"testing\"\n\n\t\"atomicgo.dev/keyboard\"\n\t\"atomicgo.dev/keyboard/keys\"\n\t\"github.com/MarvinJWendt/testza\"\n\n\t\"github.com/pterm/pterm\"\n)\n\nfunc TestInteractiveContinuePrinter_Show_yes(t *testing.T) {\n\tgo func() {\n\t\tkeyboard.SimulateKeyPress('y')\n\t}()\n\tresult, _ := pterm.DefaultInteractiveContinue.Show()\n\ttestza.AssertEqual(t, result, \"yes\")\n\tgo func() {\n\t\tkeyboard.SimulateKeyPress('Y')\n\t}()\n\tresult, _ = pterm.DefaultInteractiveContinue.Show()\n\ttestza.AssertEqual(t, result, \"yes\")\n}\n\nfunc TestInteractiveContinuePrinter_Show_no(t *testing.T) {\n\tgo func() {\n\t\tkeyboard.SimulateKeyPress('n')\n\t}()\n\tresult, _ := pterm.DefaultInteractiveContinue.Show()\n\ttestza.AssertEqual(t, result, \"no\")\n}\n\nfunc TestInteractiveContinuePrinter_WithDefaultValueIndes(t *testing.T) {\n\tp := pterm.DefaultInteractiveContinue.WithDefaultValueIndex(1)\n\ttestza.AssertEqual(t, p.DefaultValueIndex, 1)\n}\n\nfunc TestInteractiveContinuePrinter_WithDefaultValue_yes(t *testing.T) {\n\tgo func() {\n\t\tkeyboard.SimulateKeyPress(keys.Enter)\n\t}()\n\tp := pterm.DefaultInteractiveContinue.WithDefaultValue(\"yes\")\n\tresult, _ := p.Show()\n\ttestza.AssertEqual(t, result, \"yes\")\n}\n\nfunc TestInteractiveContinuePrinter_WithDefaultValue_no(t *testing.T) {\n\tp := pterm.DefaultInteractiveContinue.WithDefaultValue(\"no\")\n\tgo func() {\n\t\tkeyboard.SimulateKeyPress(keys.Enter)\n\t}()\n\tresult, _ := p.Show()\n\ttestza.AssertEqual(t, result, \"no\")\n\tgo func() {\n\t\tkeyboard.SimulateKeyPress('n')\n\t}()\n\tresult, _ = p.Show()\n\ttestza.AssertEqual(t, result, \"no\")\n\tgo func() {\n\t\tkeyboard.SimulateKeyPress('N')\n\t}()\n\tresult, _ = p.Show()\n\ttestza.AssertEqual(t, result, \"no\")\n}\n\nfunc TestInteractiveContinuePrinter_WithShowShortHandles(t *testing.T) {\n\tp := pterm.DefaultInteractiveContinue.WithShowShortHandles()\n\ttestza.AssertTrue(t, p.ShowShortHandles)\n\tgo func() {\n\t\tkeyboard.SimulateKeyPress('n')\n\t}()\n\tresult, _ := p.Show()\n\ttestza.AssertEqual(t, result, \"no\")\n}\n\nfunc TestInteractiveContinuePrinter_WithOptionsStyle(t *testing.T) {\n\tstyle := pterm.NewStyle(pterm.FgRed)\n\tp := pterm.DefaultInteractiveContinue.WithOptionsStyle(style)\n\ttestza.AssertEqual(t, p.OptionsStyle, style)\n}\n\nfunc TestInteractiveContinuePrinter_WithOptions(t *testing.T) {\n\tp := pterm.DefaultInteractiveContinue.WithOptions([]string{\"next\", \"stop\", \"continue\"})\n\ttestza.AssertEqual(t, p.Options, []string{\"next\", \"stop\", \"continue\"})\n}\n\nfunc TestInteractiveContinuePrinter_WithHandles(t *testing.T) {\n\tp := pterm.DefaultInteractiveContinue.WithOptions([]string{\"yes\", \"no\", \"always\", \"never\"}).WithHandles([]string{\"y\", \"n\", \"a\", \"N\"})\n\ttestza.AssertEqual(t, p.Handles, []string{\"y\", \"n\", \"a\", \"N\"})\n\ttests := []struct {\n\t\tname     string\n\t\tkey      rune\n\t\texpected string\n\t}{\n\t\t{\n\t\t\tname:     \"Yes\",\n\t\t\tkey:      'y',\n\t\t\texpected: \"yes\",\n\t\t},\n\t\t{\n\t\t\tname:     \"No\",\n\t\t\tkey:      'n',\n\t\t\texpected: \"no\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Always\",\n\t\t\tkey:      'a',\n\t\t\texpected: \"always\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Never\",\n\t\t\tkey:      'N',\n\t\t\texpected: \"never\",\n\t\t},\n\t}\n\tfor _, tc := range tests {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tgo func() {\n\t\t\t\tkeyboard.SimulateKeyPress(tc.key)\n\t\t\t}()\n\t\t\tresult, _ := p.Show()\n\t\t\ttestza.AssertEqual(t, result, tc.expected)\n\t\t})\n\t}\n\tp.DefaultValueIndex = 1\n\tgo func() {\n\t\tkeyboard.SimulateKeyPress(keys.Enter)\n\t}()\n\tresult, _ := p.Show()\n\ttestza.AssertEqual(t, result, \"no\")\n}\n\nfunc TestInteractiveContinuePrinter_WithDefaultText(t *testing.T) {\n\tp := pterm.DefaultInteractiveContinue.WithDefaultText(\"default\")\n\ttestza.AssertEqual(t, p.DefaultText, \"default\")\n}\n\nfunc TestInteractiveContinuePrinter_WithDelimiter(t *testing.T) {\n\tp := pterm.DefaultInteractiveContinue.WithDelimiter(\">>\")\n\ttestza.AssertEqual(t, p.Delimiter, \">>\")\n}\n\nfunc TestInteractiveContinuePrinter_CustomAnswers(t *testing.T) {\n\tp := pterm.DefaultInteractiveContinue.WithOptions([]string{\"next\", \"stop\", \"continue\"})\n\ttests := []struct {\n\t\tname     string\n\t\tkey      rune\n\t\texpected string\n\t}{\n\t\t{\n\t\t\tname:     \"Next\",\n\t\t\tkey:      'n',\n\t\t\texpected: \"next\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Stop\",\n\t\t\tkey:      's',\n\t\t\texpected: \"stop\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Continue\",\n\t\t\tkey:      'c',\n\t\t\texpected: \"continue\",\n\t\t},\n\t}\n\tfor _, tc := range tests {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tgo func() {\n\t\t\t\tkeyboard.SimulateKeyPress(tc.key)\n\t\t\t}()\n\t\t\tresult, _ := p.Show()\n\t\t\ttestza.AssertEqual(t, result, tc.expected)\n\t\t})\n\t}\n}\n\nfunc TestInteractiveContinuePrinter_WithSuffixStyle(t *testing.T) {\n\tstyle := pterm.NewStyle(pterm.FgRed)\n\tp := pterm.DefaultInteractiveContinue.WithSuffixStyle(style)\n\ttestza.AssertEqual(t, p.SuffixStyle, style)\n}\n\nfunc TestInteractiveContinuePrinter_WithTextStyle(t *testing.T) {\n\tstyle := pterm.NewStyle(pterm.FgRed)\n\tp := pterm.DefaultInteractiveContinue.WithTextStyle(style)\n\ttestza.AssertEqual(t, p.TextStyle, style)\n}\n"
        },
        {
          "name": "interactive_multiselect_printer.go",
          "type": "blob",
          "size": 11.578125,
          "content": "package pterm\n\nimport (\n\t\"fmt\"\n\t\"sort\"\n\t\"strings\"\n\n\t\"atomicgo.dev/cursor\"\n\t\"atomicgo.dev/keyboard\"\n\t\"atomicgo.dev/keyboard/keys\"\n\t\"github.com/lithammer/fuzzysearch/fuzzy\"\n\n\t\"github.com/pterm/pterm/internal\"\n)\n\nvar (\n\t// DefaultInteractiveMultiselect is the default InteractiveMultiselect printer.\n\tDefaultInteractiveMultiselect = InteractiveMultiselectPrinter{\n\t\tTextStyle:      &ThemeDefault.PrimaryStyle,\n\t\tDefaultText:    \"Please select your options\",\n\t\tOptions:        []string{},\n\t\tOptionStyle:    &ThemeDefault.DefaultText,\n\t\tDefaultOptions: []string{},\n\t\tMaxHeight:      5,\n\t\tSelector:       \">\",\n\t\tSelectorStyle:  &ThemeDefault.SecondaryStyle,\n\t\tFilter:         true,\n\t\tKeySelect:      keys.Enter,\n\t\tKeyConfirm:     keys.Tab,\n\t\tCheckmark:      &ThemeDefault.Checkmark,\n\t}\n)\n\n// InteractiveMultiselectPrinter is a printer for interactive multiselect menus.\ntype InteractiveMultiselectPrinter struct {\n\tDefaultText     string\n\tTextStyle       *Style\n\tOptions         []string\n\tOptionStyle     *Style\n\tDefaultOptions  []string\n\tMaxHeight       int\n\tSelector        string\n\tSelectorStyle   *Style\n\tFilter          bool\n\tCheckmark       *Checkmark\n\tOnInterruptFunc func()\n\n\tselectedOption        int\n\tselectedOptions       []int\n\ttext                  string\n\tfuzzySearchString     string\n\tfuzzySearchMatches    []string\n\tdisplayedOptions      []string\n\tdisplayedOptionsStart int\n\tdisplayedOptionsEnd   int\n\n\t// KeySelect is the select key. It cannot be keys.Space when Filter is enabled.\n\tKeySelect keys.KeyCode\n\n\t// KeyConfirm is the confirm key. It cannot be keys.Space when Filter is enabled.\n\tKeyConfirm keys.KeyCode\n}\n\n// WithOptions sets the options.\nfunc (p InteractiveMultiselectPrinter) WithOptions(options []string) *InteractiveMultiselectPrinter {\n\tp.Options = options\n\treturn &p\n}\n\n// WithDefaultOptions sets the default options.\nfunc (p InteractiveMultiselectPrinter) WithDefaultOptions(options []string) *InteractiveMultiselectPrinter {\n\tp.DefaultOptions = options\n\treturn &p\n}\n\n// WithDefaultText sets the default text.\nfunc (p InteractiveMultiselectPrinter) WithDefaultText(text string) *InteractiveMultiselectPrinter {\n\tp.DefaultText = text\n\treturn &p\n}\n\n// WithMaxHeight sets the maximum height of the select menu.\nfunc (p InteractiveMultiselectPrinter) WithMaxHeight(maxHeight int) *InteractiveMultiselectPrinter {\n\tp.MaxHeight = maxHeight\n\treturn &p\n}\n\n// WithFilter sets the Filter option\nfunc (p InteractiveMultiselectPrinter) WithFilter(b ...bool) *InteractiveMultiselectPrinter {\n\tp.Filter = internal.WithBoolean(b)\n\treturn &p\n}\n\n// WithKeySelect sets the confirm key\n// It cannot be keys.Space when Filter is enabled.\nfunc (p InteractiveMultiselectPrinter) WithKeySelect(keySelect keys.KeyCode) *InteractiveMultiselectPrinter {\n\tp.KeySelect = keySelect\n\treturn &p\n}\n\n// WithKeyConfirm sets the confirm key\n// It cannot be keys.Space when Filter is enabled.\nfunc (p InteractiveMultiselectPrinter) WithKeyConfirm(keyConfirm keys.KeyCode) *InteractiveMultiselectPrinter {\n\tp.KeyConfirm = keyConfirm\n\treturn &p\n}\n\n// WithCheckmark sets the checkmark\nfunc (p InteractiveMultiselectPrinter) WithCheckmark(checkmark *Checkmark) *InteractiveMultiselectPrinter {\n\tp.Checkmark = checkmark\n\treturn &p\n}\n\n// OnInterrupt sets the function to execute on exit of the input reader\nfunc (p InteractiveMultiselectPrinter) WithOnInterruptFunc(exitFunc func()) *InteractiveMultiselectPrinter {\n\tp.OnInterruptFunc = exitFunc\n\treturn &p\n}\n\n// Show shows the interactive multiselect menu and returns the selected entry.\nfunc (p *InteractiveMultiselectPrinter) Show(text ...string) ([]string, error) {\n\t// should be the first defer statement to make sure it is executed last\n\t// and all the needed cleanup can be done before\n\tcancel, exit := internal.NewCancelationSignal(p.OnInterruptFunc)\n\tdefer exit()\n\n\tif len(text) == 0 || Sprint(text[0]) == \"\" {\n\t\ttext = []string{p.DefaultText}\n\t}\n\n\tp.text = p.TextStyle.Sprint(text[0])\n\tp.fuzzySearchMatches = append([]string{}, p.Options...)\n\n\tif p.MaxHeight == 0 {\n\t\tp.MaxHeight = DefaultInteractiveMultiselect.MaxHeight\n\t}\n\n\tmaxHeight := p.MaxHeight\n\tif maxHeight > len(p.fuzzySearchMatches) {\n\t\tmaxHeight = len(p.fuzzySearchMatches)\n\t}\n\n\tif len(p.Options) == 0 {\n\t\treturn nil, fmt.Errorf(\"no options provided\")\n\t}\n\n\tp.displayedOptions = append([]string{}, p.fuzzySearchMatches[:maxHeight]...)\n\tp.displayedOptionsStart = 0\n\tp.displayedOptionsEnd = maxHeight\n\n\tfor _, option := range p.DefaultOptions {\n\t\tp.selectOption(option)\n\t}\n\n\tarea, err := DefaultArea.Start(p.renderSelectMenu())\n\tdefer area.Stop()\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"could not start area: %w\", err)\n\t}\n\n\tif p.Filter && (p.KeyConfirm == keys.Space || p.KeySelect == keys.Space) {\n\t\treturn nil, fmt.Errorf(\"if filter/search is active, keys.Space can not be used for KeySelect or KeyConfirm\")\n\t}\n\n\tarea.Update(p.renderSelectMenu())\n\n\tcursor.Hide()\n\tdefer cursor.Show()\n\terr = keyboard.Listen(func(keyInfo keys.Key) (stop bool, err error) {\n\t\tkey := keyInfo.Code\n\n\t\tif p.MaxHeight > len(p.fuzzySearchMatches) {\n\t\t\tmaxHeight = len(p.fuzzySearchMatches)\n\t\t} else {\n\t\t\tmaxHeight = p.MaxHeight\n\t\t}\n\n\t\tswitch key {\n\t\tcase p.KeyConfirm:\n\t\t\tif len(p.fuzzySearchMatches) == 0 {\n\t\t\t\treturn false, nil\n\t\t\t}\n\t\t\tarea.Update(p.renderFinishedMenu())\n\t\t\treturn true, nil\n\t\tcase p.KeySelect:\n\t\t\tif len(p.fuzzySearchMatches) > 0 {\n\t\t\t\t// Select option if not already selected\n\t\t\t\tp.selectOption(p.fuzzySearchMatches[p.selectedOption])\n\t\t\t}\n\t\t\tarea.Update(p.renderSelectMenu())\n\t\tcase keys.RuneKey:\n\t\t\tif p.Filter {\n\t\t\t\t// Fuzzy search for options\n\t\t\t\t// append to fuzzy search string\n\t\t\t\tp.fuzzySearchString += keyInfo.String()\n\t\t\t\tp.selectedOption = 0\n\t\t\t\tp.displayedOptionsStart = 0\n\t\t\t\tp.displayedOptionsEnd = maxHeight\n\t\t\t\tp.displayedOptions = append([]string{}, p.fuzzySearchMatches[:maxHeight]...)\n\t\t\t}\n\t\t\tarea.Update(p.renderSelectMenu())\n\t\tcase keys.Space:\n\t\t\tif p.Filter {\n\t\t\t\tp.fuzzySearchString += \" \"\n\t\t\t\tp.selectedOption = 0\n\t\t\t\tarea.Update(p.renderSelectMenu())\n\t\t\t}\n\t\tcase keys.Backspace:\n\t\t\t// Remove last character from fuzzy search string\n\t\t\tif p.fuzzySearchString != \"\" {\n\t\t\t\t// Handle UTF-8 characters\n\t\t\t\tp.fuzzySearchString = string([]rune(p.fuzzySearchString)[:len([]rune(p.fuzzySearchString))-1])\n\t\t\t}\n\n\t\t\tif p.fuzzySearchString == \"\" {\n\t\t\t\tp.fuzzySearchMatches = append([]string{}, p.Options...)\n\t\t\t}\n\n\t\t\tp.renderSelectMenu()\n\n\t\t\tif len(p.fuzzySearchMatches) > p.MaxHeight {\n\t\t\t\tmaxHeight = p.MaxHeight\n\t\t\t} else {\n\t\t\t\tmaxHeight = len(p.fuzzySearchMatches)\n\t\t\t}\n\n\t\t\tp.selectedOption = 0\n\t\t\tp.displayedOptionsStart = 0\n\t\t\tp.displayedOptionsEnd = maxHeight\n\t\t\tp.displayedOptions = append([]string{}, p.fuzzySearchMatches[p.displayedOptionsStart:p.displayedOptionsEnd]...)\n\n\t\t\tarea.Update(p.renderSelectMenu())\n\t\tcase keys.Left:\n\t\t\t// Unselect all options\n\t\t\tp.selectedOptions = []int{}\n\t\t\tarea.Update(p.renderSelectMenu())\n\t\tcase keys.Right:\n\t\t\t// Select all options\n\t\t\tp.selectedOptions = []int{}\n\t\t\tfor i := 0; i < len(p.Options); i++ {\n\t\t\t\tp.selectedOptions = append(p.selectedOptions, i)\n\t\t\t}\n\t\t\tarea.Update(p.renderSelectMenu())\n\t\tcase keys.Up, keys.CtrlP:\n\t\t\tif len(p.fuzzySearchMatches) == 0 {\n\t\t\t\treturn false, nil\n\t\t\t}\n\t\t\tif p.selectedOption > 0 {\n\t\t\t\tp.selectedOption--\n\t\t\t\tif p.selectedOption < p.displayedOptionsStart {\n\t\t\t\t\tp.displayedOptionsStart--\n\t\t\t\t\tp.displayedOptionsEnd--\n\t\t\t\t\tif p.displayedOptionsStart < 0 {\n\t\t\t\t\t\tp.displayedOptionsStart = 0\n\t\t\t\t\t\tp.displayedOptionsEnd = maxHeight\n\t\t\t\t\t}\n\t\t\t\t\tp.displayedOptions = append([]string{}, p.fuzzySearchMatches[p.displayedOptionsStart:p.displayedOptionsEnd]...)\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tp.selectedOption = len(p.fuzzySearchMatches) - 1\n\t\t\t\tp.displayedOptionsStart = len(p.fuzzySearchMatches) - maxHeight\n\t\t\t\tp.displayedOptionsEnd = len(p.fuzzySearchMatches)\n\t\t\t\tp.displayedOptions = append([]string{}, p.fuzzySearchMatches[p.displayedOptionsStart:p.displayedOptionsEnd]...)\n\t\t\t}\n\n\t\t\tarea.Update(p.renderSelectMenu())\n\t\tcase keys.Down, keys.CtrlN:\n\t\t\tif len(p.fuzzySearchMatches) == 0 {\n\t\t\t\treturn false, nil\n\t\t\t}\n\t\t\tp.displayedOptions = p.fuzzySearchMatches[:maxHeight]\n\t\t\tif p.selectedOption < len(p.fuzzySearchMatches)-1 {\n\t\t\t\tp.selectedOption++\n\t\t\t\tif p.selectedOption >= p.displayedOptionsEnd {\n\t\t\t\t\tp.displayedOptionsStart++\n\t\t\t\t\tp.displayedOptionsEnd++\n\t\t\t\t\tp.displayedOptions = append([]string{}, p.fuzzySearchMatches[p.displayedOptionsStart:p.displayedOptionsEnd]...)\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tp.selectedOption = 0\n\t\t\t\tp.displayedOptionsStart = 0\n\t\t\t\tp.displayedOptionsEnd = maxHeight\n\t\t\t\tp.displayedOptions = append([]string{}, p.fuzzySearchMatches[p.displayedOptionsStart:p.displayedOptionsEnd]...)\n\t\t\t}\n\n\t\t\tarea.Update(p.renderSelectMenu())\n\t\tcase keys.CtrlC:\n\t\t\tcancel()\n\t\t\treturn true, nil\n\t\t}\n\n\t\treturn false, nil\n\t})\n\tif err != nil {\n\t\tError.Println(err)\n\t\treturn nil, fmt.Errorf(\"failed to start keyboard listener: %w\", err)\n\t}\n\n\tvar result []string\n\tfor _, selectedOption := range p.selectedOptions {\n\t\tresult = append(result, p.Options[selectedOption])\n\t}\n\n\treturn result, nil\n}\n\nfunc (p InteractiveMultiselectPrinter) findOptionByText(text string) int {\n\tfor i, option := range p.Options {\n\t\tif option == text {\n\t\t\treturn i\n\t\t}\n\t}\n\treturn -1\n}\n\nfunc (p *InteractiveMultiselectPrinter) isSelected(optionText string) bool {\n\tfor _, selectedOption := range p.selectedOptions {\n\t\tif p.Options[selectedOption] == optionText {\n\t\t\treturn true\n\t\t}\n\t}\n\n\treturn false\n}\n\nfunc (p *InteractiveMultiselectPrinter) selectOption(optionText string) {\n\tif p.isSelected(optionText) {\n\t\t// Remove from selected options\n\t\tfor i, selectedOption := range p.selectedOptions {\n\t\t\tif p.Options[selectedOption] == optionText {\n\t\t\t\tp.selectedOptions = append(p.selectedOptions[:i], p.selectedOptions[i+1:]...)\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t} else {\n\t\t// Add to selected options\n\t\tp.selectedOptions = append(p.selectedOptions, p.findOptionByText(optionText))\n\t}\n}\n\nfunc (p *InteractiveMultiselectPrinter) renderSelectMenu() string {\n\tvar content strings.Builder\n\tcontent.WriteString(Sprintf(\"%s: %s\\n\", p.text, p.fuzzySearchString))\n\n\t// find options that match fuzzy search string\n\trankedResults := fuzzy.RankFindFold(p.fuzzySearchString, p.Options)\n\t// map rankedResults to fuzzySearchMatches\n\tp.fuzzySearchMatches = []string{}\n\tif len(rankedResults) != len(p.Options) {\n\t\tsort.Sort(rankedResults)\n\t}\n\tfor _, result := range rankedResults {\n\t\tp.fuzzySearchMatches = append(p.fuzzySearchMatches, result.Target)\n\t}\n\n\tindexMapper := make([]string, len(p.fuzzySearchMatches))\n\tfor i := 0; i < len(p.fuzzySearchMatches); i++ {\n\t\t// if in displayed options range\n\t\tif i >= p.displayedOptionsStart && i < p.displayedOptionsEnd {\n\t\t\tindexMapper[i] = p.fuzzySearchMatches[i]\n\t\t}\n\t}\n\n\tfor i, option := range indexMapper {\n\t\tif option == \"\" {\n\t\t\tcontinue\n\t\t}\n\t\tvar checkmark string\n\t\tif p.isSelected(option) {\n\t\t\tcheckmark = fmt.Sprintf(\"[%s]\", p.Checkmark.Checked)\n\t\t} else {\n\t\t\tcheckmark = fmt.Sprintf(\"[%s]\", p.Checkmark.Unchecked)\n\t\t}\n\t\tif i == p.selectedOption {\n\t\t\tcontent.WriteString(Sprintf(\"%s %s %s\\n\", p.renderSelector(), checkmark, option))\n\t\t} else {\n\t\t\tcontent.WriteString(Sprintf(\"  %s %s\\n\", checkmark, option))\n\t\t}\n\t}\n\n\thelp := fmt.Sprintf(\"%s: %s | %s: %s | left: %s | right: %s\", p.KeySelect, Bold.Sprint(\"select\"), p.KeyConfirm, Bold.Sprint(\"confirm\"), Bold.Sprint(\"none\"), Bold.Sprint(\"all\"))\n\tif p.Filter {\n\t\thelp += fmt.Sprintf(\"| type to %s\", Bold.Sprint(\"filter\"))\n\t}\n\tcontent.WriteString(ThemeDefault.SecondaryStyle.Sprintfln(\"%s\", help))\n\n\treturn content.String()\n}\n\nfunc (p InteractiveMultiselectPrinter) renderFinishedMenu() string {\n\tvar content string\n\tcontent += Sprintf(\"%s: %s\\n\", p.text, p.fuzzySearchString)\n\tfor _, option := range p.selectedOptions {\n\t\tcontent += Sprintf(\"  %s %s\\n\", p.renderSelector(), p.Options[option])\n\t}\n\n\treturn content\n}\n\nfunc (p InteractiveMultiselectPrinter) renderSelector() string {\n\treturn p.SelectorStyle.Sprint(p.Selector)\n}\n"
        },
        {
          "name": "interactive_multiselect_printer_test.go",
          "type": "blob",
          "size": 3.4736328125,
          "content": "package pterm_test\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n\n\t\"atomicgo.dev/keyboard\"\n\t\"atomicgo.dev/keyboard/keys\"\n\t\"github.com/MarvinJWendt/testza\"\n\n\t\"github.com/pterm/pterm\"\n)\n\nfunc TestInteractiveMultiselectPrinter_Show(t *testing.T) {\n\tgo func() {\n\t\tkeyboard.SimulateKeyPress(keys.Down)\n\t\tkeyboard.SimulateKeyPress(keys.Down)\n\t\tkeyboard.SimulateKeyPress(keys.Enter)\n\t\tkeyboard.SimulateKeyPress(keys.Tab)\n\t}()\n\tresult, _ := pterm.DefaultInteractiveMultiselect.WithOptions([]string{\"a\", \"b\", \"c\", \"d\", \"e\"}).WithDefaultOptions([]string{\"b\"}).Show()\n\ttestza.AssertEqual(t, []string{\"b\", \"c\"}, result)\n}\n\nfunc TestInteractiveMultiselectPrinter_Show_MaxHeightSlidingWindow(t *testing.T) {\n\tgo func() {\n\t\tkeyboard.SimulateKeyPress(keys.Up)\n\t\tkeyboard.SimulateKeyPress(keys.Up)\n\t\tkeyboard.SimulateKeyPress(keys.Enter)\n\t\tkeyboard.SimulateKeyPress(keys.Tab)\n\t}()\n\tresult, _ := pterm.DefaultInteractiveMultiselect.WithOptions([]string{\"a\", \"b\", \"c\", \"d\", \"e\", \"f\"}).WithDefaultOptions([]string{\"b\"}).Show()\n\ttestza.AssertEqual(t, []string{\"b\", \"e\"}, result)\n}\n\nfunc TestInteractiveMultiselectPrinter_Show_AlternateNavigationKeys(t *testing.T) {\n\tgo func() {\n\t\tkeyboard.SimulateKeyPress(keys.CtrlN)\n\t\tkeyboard.SimulateKeyPress(keys.CtrlN)\n\t\tkeyboard.SimulateKeyPress(keys.CtrlN)\n\t\tkeyboard.SimulateKeyPress(keys.CtrlP)\n\t\tkeyboard.SimulateKeyPress(keys.Enter)\n\t\tkeyboard.SimulateKeyPress(keys.Tab)\n\t}()\n\tresult, _ := pterm.DefaultInteractiveMultiselect.WithOptions([]string{\"a\", \"b\", \"c\", \"d\", \"e\"}).WithDefaultOptions([]string{\"b\"}).Show()\n\ttestza.AssertEqual(t, []string{\"b\", \"c\"}, result)\n}\n\nfunc TestInteractiveMultiselectPrinter_WithDefaultText(t *testing.T) {\n\tp := pterm.DefaultInteractiveMultiselect.WithDefaultText(\"default\")\n\ttestza.AssertEqual(t, p.DefaultText, \"default\")\n}\n\nfunc TestInteractiveMultiselectPrinter_WithDefaultOption(t *testing.T) {\n\tp := pterm.DefaultInteractiveMultiselect.WithDefaultOptions([]string{\"default\"})\n\ttestza.AssertEqual(t, p.DefaultOptions, []string{\"default\"})\n}\n\nfunc TestInteractiveMultiselectPrinter_WithOptions(t *testing.T) {\n\tp := pterm.DefaultInteractiveMultiselect.WithOptions([]string{\"a\", \"b\", \"c\"})\n\ttestza.AssertEqual(t, p.Options, []string{\"a\", \"b\", \"c\"})\n}\n\nfunc TestInteractiveMultiselectPrinter_WithMaxHeight(t *testing.T) {\n\tp := pterm.DefaultInteractiveMultiselect.WithMaxHeight(1337)\n\ttestza.AssertEqual(t, p.MaxHeight, 1337)\n}\n\nfunc TestInteractiveMultiselectPrinter_WithKeySelect(t *testing.T) {\n\tp := pterm.DefaultInteractiveMultiselect.WithKeySelect(keys.Left).WithOptions([]string{\"a\", \"b\", \"c\"})\n\ttestza.AssertEqual(t, p.KeySelect, keys.Left)\n}\n\nfunc TestInteractiveMultiselectPrinter_WithKeyConfirm(t *testing.T) {\n\tp := pterm.DefaultInteractiveMultiselect.WithKeyConfirm(keys.Left).WithOptions([]string{\"a\", \"b\", \"c\"})\n\ttestza.AssertEqual(t, p.KeyConfirm, keys.Left)\n}\n\nfunc TestInteractiveMultiselectPrinter_WithCheckmark(t *testing.T) {\n\tp := pterm.DefaultInteractiveMultiselect.WithCheckmark(&pterm.Checkmark{Checked: \"+\", Unchecked: \"-\"}).WithOptions([]string{\"a\", \"b\", \"c\"})\n\ttestza.AssertEqual(t, p.Checkmark, &pterm.Checkmark{Checked: \"+\", Unchecked: \"-\"})\n}\n\nfunc TestInteractiveMultiselectPrinter_WithOnInterruptFunc(t *testing.T) {\n\t// OnInterrupt function defaults to nil\n\tpd := pterm.InteractiveMultiselectPrinter{}\n\ttestza.AssertNil(t, pd.OnInterruptFunc)\n\n\t// Verify OnInterrupt is set\n\texitfunc := func() {}\n\tp := pterm.DefaultInteractiveMultiselect.WithOnInterruptFunc(exitfunc)\n\ttestza.AssertEqual(t, reflect.ValueOf(p.OnInterruptFunc).Pointer(), reflect.ValueOf(exitfunc).Pointer())\n}\n"
        },
        {
          "name": "interactive_select_printer.go",
          "type": "blob",
          "size": 8.9111328125,
          "content": "package pterm\n\nimport (\n\t\"fmt\"\n\t\"math\"\n\t\"sort\"\n\t\"strings\"\n\n\t\"atomicgo.dev/cursor\"\n\t\"atomicgo.dev/keyboard\"\n\t\"atomicgo.dev/keyboard/keys\"\n\t\"github.com/lithammer/fuzzysearch/fuzzy\"\n\t\"github.com/pterm/pterm/internal\"\n)\n\nvar (\n\t// DefaultInteractiveSelect is the default InteractiveSelect printer.\n\tDefaultInteractiveSelect = InteractiveSelectPrinter{\n\t\tTextStyle:     &ThemeDefault.PrimaryStyle,\n\t\tDefaultText:   \"Please select an option\",\n\t\tOptions:       []string{},\n\t\tOptionStyle:   &ThemeDefault.DefaultText,\n\t\tDefaultOption: \"\",\n\t\tMaxHeight:     5,\n\t\tSelector:      \">\",\n\t\tSelectorStyle: &ThemeDefault.SecondaryStyle,\n\t\tFilter:        true,\n\t}\n)\n\n// InteractiveSelectPrinter is a printer for interactive select menus.\ntype InteractiveSelectPrinter struct {\n\tTextStyle       *Style\n\tDefaultText     string\n\tOptions         []string\n\tOptionStyle     *Style\n\tDefaultOption   string\n\tMaxHeight       int\n\tSelector        string\n\tSelectorStyle   *Style\n\tOnInterruptFunc func()\n\tFilter          bool\n\n\tselectedOption        int\n\tresult                string\n\ttext                  string\n\tfuzzySearchString     string\n\tfuzzySearchMatches    []string\n\tdisplayedOptions      []string\n\tdisplayedOptionsStart int\n\tdisplayedOptionsEnd   int\n}\n\n// WithDefaultText sets the default text.\nfunc (p InteractiveSelectPrinter) WithDefaultText(text string) *InteractiveSelectPrinter {\n\tp.DefaultText = text\n\treturn &p\n}\n\n// WithOptions sets the options.\nfunc (p InteractiveSelectPrinter) WithOptions(options []string) *InteractiveSelectPrinter {\n\tp.Options = options\n\treturn &p\n}\n\n// WithDefaultOption sets the default options.\nfunc (p InteractiveSelectPrinter) WithDefaultOption(option string) *InteractiveSelectPrinter {\n\tp.DefaultOption = option\n\treturn &p\n}\n\n// WithMaxHeight sets the maximum height of the select menu.\nfunc (p InteractiveSelectPrinter) WithMaxHeight(maxHeight int) *InteractiveSelectPrinter {\n\tp.MaxHeight = maxHeight\n\treturn &p\n}\n\n// OnInterrupt sets the function to execute on exit of the input reader\nfunc (p InteractiveSelectPrinter) WithOnInterruptFunc(exitFunc func()) *InteractiveSelectPrinter {\n\tp.OnInterruptFunc = exitFunc\n\treturn &p\n}\n\n// WithFilter sets the Filter option\nfunc (p InteractiveSelectPrinter) WithFilter(b ...bool) *InteractiveSelectPrinter {\n\tp.Filter = internal.WithBoolean(b)\n\treturn &p\n}\n\n// Show shows the interactive select menu and returns the selected entry.\nfunc (p *InteractiveSelectPrinter) Show(text ...string) (string, error) {\n\t// should be the first defer statement to make sure it is executed last\n\t// and all the needed cleanup can be done before\n\tcancel, exit := internal.NewCancelationSignal(p.OnInterruptFunc)\n\tdefer exit()\n\n\tif len(text) == 0 || Sprint(text[0]) == \"\" {\n\t\ttext = []string{p.DefaultText}\n\t}\n\n\tp.text = p.TextStyle.Sprint(text[0])\n\tp.fuzzySearchMatches = append([]string{}, p.Options...)\n\n\tif p.MaxHeight == 0 {\n\t\tp.MaxHeight = DefaultInteractiveSelect.MaxHeight\n\t}\n\n\tmaxHeight := p.MaxHeight\n\tif maxHeight > len(p.fuzzySearchMatches) {\n\t\tmaxHeight = len(p.fuzzySearchMatches)\n\t}\n\n\tif len(p.Options) == 0 {\n\t\treturn \"\", fmt.Errorf(\"no options provided\")\n\t}\n\n\tp.displayedOptions = append([]string{}, p.fuzzySearchMatches[:maxHeight]...)\n\tp.displayedOptionsStart = 0\n\tp.displayedOptionsEnd = maxHeight\n\n\t// Get index of default option\n\tif p.DefaultOption != \"\" {\n\t\tfor i, option := range p.Options {\n\t\t\tif option == p.DefaultOption {\n\t\t\t\tp.selectedOption = i\n\t\t\t\tif i > 0 && len(p.Options) > maxHeight {\n\t\t\t\t\tp.displayedOptionsEnd = int(math.Min(float64(i-1+maxHeight), float64(len(p.Options))))\n\t\t\t\t\tp.displayedOptionsStart = p.displayedOptionsEnd - maxHeight\n\t\t\t\t} else {\n\t\t\t\t\tp.displayedOptionsStart = 0\n\t\t\t\t\tp.displayedOptionsEnd = maxHeight\n\t\t\t\t}\n\t\t\t\tp.displayedOptions = p.Options[p.displayedOptionsStart:p.displayedOptionsEnd]\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}\n\n\tarea, err := DefaultArea.Start(p.renderSelectMenu())\n\tdefer area.Stop()\n\tif err != nil {\n\t\treturn \"\", fmt.Errorf(\"could not start area: %w\", err)\n\t}\n\n\tarea.Update(p.renderSelectMenu())\n\n\tcursor.Hide()\n\tdefer cursor.Show()\n\n\terr = keyboard.Listen(func(keyInfo keys.Key) (stop bool, err error) {\n\t\tkey := keyInfo.Code\n\n\t\tif p.MaxHeight > len(p.fuzzySearchMatches) {\n\t\t\tmaxHeight = len(p.fuzzySearchMatches)\n\t\t} else {\n\t\t\tmaxHeight = p.MaxHeight\n\t\t}\n\n\t\tswitch key {\n\t\tcase keys.RuneKey:\n\t\t\tif p.Filter {\n\t\t\t\t// Fuzzy search for options\n\t\t\t\t// append to fuzzy search string\n\t\t\t\tp.fuzzySearchString += keyInfo.String()\n\t\t\t\tp.selectedOption = 0\n\t\t\t\tp.displayedOptionsStart = 0\n\t\t\t\tp.displayedOptionsEnd = maxHeight\n\t\t\t\tp.displayedOptions = append([]string{}, p.fuzzySearchMatches[:maxHeight]...)\n\t\t\t\tarea.Update(p.renderSelectMenu())\n\t\t\t}\n\t\tcase keys.Space:\n\t\t\tp.fuzzySearchString += \" \"\n\t\t\tp.selectedOption = 0\n\t\t\tarea.Update(p.renderSelectMenu())\n\t\tcase keys.Backspace:\n\t\t\t// Remove last character from fuzzy search string\n\t\t\tif p.fuzzySearchString != \"\" {\n\t\t\t\t// Handle UTF-8 characters\n\t\t\t\tp.fuzzySearchString = string([]rune(p.fuzzySearchString)[:len([]rune(p.fuzzySearchString))-1])\n\t\t\t}\n\n\t\t\tif p.fuzzySearchString == \"\" {\n\t\t\t\tp.fuzzySearchMatches = append([]string{}, p.Options...)\n\t\t\t}\n\n\t\t\tp.renderSelectMenu()\n\n\t\t\tif len(p.fuzzySearchMatches) > p.MaxHeight {\n\t\t\t\tmaxHeight = p.MaxHeight\n\t\t\t} else {\n\t\t\t\tmaxHeight = len(p.fuzzySearchMatches)\n\t\t\t}\n\n\t\t\tp.selectedOption = 0\n\t\t\tp.displayedOptionsStart = 0\n\t\t\tp.displayedOptionsEnd = maxHeight\n\t\t\tp.displayedOptions = append([]string{}, p.fuzzySearchMatches[p.displayedOptionsStart:p.displayedOptionsEnd]...)\n\n\t\t\tarea.Update(p.renderSelectMenu())\n\t\tcase keys.Up, keys.CtrlP:\n\t\t\tif len(p.fuzzySearchMatches) == 0 {\n\t\t\t\treturn false, nil\n\t\t\t}\n\t\t\tif p.selectedOption > 0 {\n\t\t\t\tp.selectedOption--\n\t\t\t\tif p.selectedOption < p.displayedOptionsStart {\n\t\t\t\t\tp.displayedOptionsStart--\n\t\t\t\t\tp.displayedOptionsEnd--\n\t\t\t\t\tif p.displayedOptionsStart < 0 {\n\t\t\t\t\t\tp.displayedOptionsStart = 0\n\t\t\t\t\t\tp.displayedOptionsEnd = maxHeight\n\t\t\t\t\t}\n\t\t\t\t\tp.displayedOptions = append([]string{}, p.fuzzySearchMatches[p.displayedOptionsStart:p.displayedOptionsEnd]...)\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tp.selectedOption = len(p.fuzzySearchMatches) - 1\n\t\t\t\tp.displayedOptionsStart = len(p.fuzzySearchMatches) - maxHeight\n\t\t\t\tp.displayedOptionsEnd = len(p.fuzzySearchMatches)\n\t\t\t\tp.displayedOptions = append([]string{}, p.fuzzySearchMatches[p.displayedOptionsStart:p.displayedOptionsEnd]...)\n\t\t\t}\n\n\t\t\tarea.Update(p.renderSelectMenu())\n\t\tcase keys.Down, keys.CtrlN:\n\t\t\tif len(p.fuzzySearchMatches) == 0 {\n\t\t\t\treturn false, nil\n\t\t\t}\n\t\t\tp.displayedOptions = p.fuzzySearchMatches[:maxHeight]\n\t\t\tif p.selectedOption < len(p.fuzzySearchMatches)-1 {\n\t\t\t\tp.selectedOption++\n\t\t\t\tif p.selectedOption >= p.displayedOptionsEnd {\n\t\t\t\t\tp.displayedOptionsStart++\n\t\t\t\t\tp.displayedOptionsEnd++\n\t\t\t\t\tp.displayedOptions = append([]string{}, p.fuzzySearchMatches[p.displayedOptionsStart:p.displayedOptionsEnd]...)\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tp.selectedOption = 0\n\t\t\t\tp.displayedOptionsStart = 0\n\t\t\t\tp.displayedOptionsEnd = maxHeight\n\t\t\t\tp.displayedOptions = append([]string{}, p.fuzzySearchMatches[p.displayedOptionsStart:p.displayedOptionsEnd]...)\n\t\t\t}\n\n\t\t\tarea.Update(p.renderSelectMenu())\n\t\tcase keys.CtrlC:\n\t\t\tcancel()\n\t\t\treturn true, nil\n\t\tcase keys.Enter:\n\t\t\tif len(p.fuzzySearchMatches) == 0 {\n\t\t\t\treturn false, nil\n\t\t\t}\n\t\t\tarea.Update(p.renderFinishedMenu())\n\t\t\treturn true, nil\n\t\t}\n\n\t\treturn false, nil\n\t})\n\tif err != nil {\n\t\tError.Println(err)\n\t\treturn \"\", fmt.Errorf(\"failed to start keyboard listener: %w\", err)\n\t}\n\n\treturn p.result, nil\n}\n\nfunc (p *InteractiveSelectPrinter) renderSelectMenu() string {\n\tvar content strings.Builder\n\tif p.Filter {\n\t\tcontent.WriteString(Sprintf(\"%s %s: %s\\n\", p.text, p.SelectorStyle.Sprint(\"[type to search]\"), p.fuzzySearchString))\n\t} else {\n\t\tcontent.WriteString(Sprintf(\"%s:\\n\", p.text))\n\t}\n\n\t// find options that match fuzzy search string\n\trankedResults := fuzzy.RankFindFold(p.fuzzySearchString, p.Options)\n\t// map rankedResults to fuzzySearchMatches\n\tp.fuzzySearchMatches = []string{}\n\tif len(rankedResults) != len(p.Options) {\n\t\tsort.Sort(rankedResults)\n\t}\n\tfor _, result := range rankedResults {\n\t\tp.fuzzySearchMatches = append(p.fuzzySearchMatches, result.Target)\n\t}\n\n\tif len(p.fuzzySearchMatches) != 0 {\n\t\tp.result = p.fuzzySearchMatches[p.selectedOption]\n\t}\n\n\tindexMapper := make([]string, len(p.fuzzySearchMatches))\n\tfor i := 0; i < len(p.fuzzySearchMatches); i++ {\n\t\t// if in displayed options range\n\t\tif i >= p.displayedOptionsStart && i < p.displayedOptionsEnd {\n\t\t\tindexMapper[i] = p.fuzzySearchMatches[i]\n\t\t}\n\t}\n\n\tfor i, option := range indexMapper {\n\t\tif option == \"\" {\n\t\t\tcontinue\n\t\t}\n\t\tif i == p.selectedOption {\n\t\t\tcontent.WriteString(Sprintf(\"%s %s\\n\", p.renderSelector(), p.OptionStyle.Sprint(option)))\n\t\t} else {\n\t\t\tcontent.WriteString(Sprintf(\"  %s\\n\", p.OptionStyle.Sprint(option)))\n\t\t}\n\t}\n\n\treturn content.String()\n}\n\nfunc (p InteractiveSelectPrinter) renderFinishedMenu() string {\n\tvar content string\n\tcontent += Sprintf(\"%s: %s\\n\", p.text, p.fuzzySearchString)\n\tcontent += Sprintf(\"  %s %s\\n\", p.renderSelector(), p.result)\n\n\treturn content\n}\n\nfunc (p InteractiveSelectPrinter) renderSelector() string {\n\treturn p.SelectorStyle.Sprint(p.Selector)\n}\n"
        },
        {
          "name": "interactive_select_printer_test.go",
          "type": "blob",
          "size": 2.5693359375,
          "content": "package pterm_test\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n\n\t\"atomicgo.dev/keyboard\"\n\t\"atomicgo.dev/keyboard/keys\"\n\t\"github.com/MarvinJWendt/testza\"\n\n\t\"github.com/pterm/pterm\"\n)\n\nfunc TestInteractiveSelectPrinter_Show(t *testing.T) {\n\tgo func() {\n\t\tkeyboard.SimulateKeyPress(keys.Down)\n\t\tkeyboard.SimulateKeyPress(keys.Down)\n\t\tkeyboard.SimulateKeyPress(keys.Enter)\n\t}()\n\tresult, _ := pterm.DefaultInteractiveSelect.WithOptions([]string{\"a\", \"b\", \"c\", \"d\", \"e\"}).WithDefaultOption(\"b\").Show()\n\ttestza.AssertEqual(t, \"d\", result)\n}\n\nfunc TestInteractiveSelectPrinter_Show_MaxHeightSlidingWindow(t *testing.T) {\n\tgo func() {\n\t\tkeyboard.SimulateKeyPress(keys.Up)\n\t\tkeyboard.SimulateKeyPress(keys.Up)\n\t\tkeyboard.SimulateKeyPress(keys.Enter)\n\t}()\n\tresult, _ := pterm.DefaultInteractiveSelect.WithOptions([]string{\"a\", \"b\", \"c\", \"d\", \"e\", \"f\"}).WithDefaultOption(\"e\").Show()\n\ttestza.AssertEqual(t, \"c\", result)\n}\n\nfunc TestInteractiveSelectPrinter_Show_AlternateNavigationKeys(t *testing.T) {\n\tgo func() {\n\t\tkeyboard.SimulateKeyPress(keys.CtrlN)\n\t\tkeyboard.SimulateKeyPress(keys.CtrlN)\n\t\tkeyboard.SimulateKeyPress(keys.CtrlP)\n\t\tkeyboard.SimulateKeyPress(keys.Enter)\n\t}()\n\tresult, _ := pterm.DefaultInteractiveSelect.WithOptions([]string{\"a\", \"b\", \"c\", \"d\", \"e\"}).WithDefaultOption(\"b\").Show()\n\ttestza.AssertEqual(t, \"c\", result)\n}\n\nfunc TestInteractiveSelectPrinter_WithDefaultText(t *testing.T) {\n\tp := pterm.DefaultInteractiveSelect.WithDefaultText(\"default\")\n\ttestza.AssertEqual(t, p.DefaultText, \"default\")\n}\n\nfunc TestInteractiveSelectPrinter_WithDefaultOption(t *testing.T) {\n\tp := pterm.DefaultInteractiveSelect.WithDefaultOption(\"default\")\n\ttestza.AssertEqual(t, p.DefaultOption, \"default\")\n}\n\nfunc TestInteractiveSelectPrinter_WithOptions(t *testing.T) {\n\tp := pterm.DefaultInteractiveSelect.WithOptions([]string{\"a\", \"b\", \"c\"})\n\ttestza.AssertEqual(t, p.Options, []string{\"a\", \"b\", \"c\"})\n}\n\nfunc TestInteractiveSelectPrinter_WithMaxHeight(t *testing.T) {\n\tp := pterm.DefaultInteractiveSelect.WithMaxHeight(1337)\n\ttestza.AssertEqual(t, p.MaxHeight, 1337)\n}\n\nfunc TestInteractiveSelectPrinter_WithOnInterruptFunc(t *testing.T) {\n\t// OnInterrupt function defaults to nil\n\tpd := pterm.InteractiveSelectPrinter{}\n\ttestza.AssertNil(t, pd.OnInterruptFunc)\n\n\t// Verify OnInterrupt is set\n\texitfunc := func() {}\n\tp := pterm.DefaultInteractiveSelect.WithOnInterruptFunc(exitfunc)\n\ttestza.AssertEqual(t, reflect.ValueOf(p.OnInterruptFunc).Pointer(), reflect.ValueOf(exitfunc).Pointer())\n}\n\nfunc TestInteractiveSelectPrinter_WithFilter(t *testing.T) {\n\tp := pterm.DefaultInteractiveSelect.WithFilter(false)\n\ttestza.AssertEqual(t, p.Filter, false)\n}\n"
        },
        {
          "name": "interactive_textinput_printer.go",
          "type": "blob",
          "size": 8.5439453125,
          "content": "package pterm\n\nimport (\n\t\"strings\"\n\n\t\"atomicgo.dev/cursor\"\n\t\"atomicgo.dev/keyboard\"\n\t\"atomicgo.dev/keyboard/keys\"\n\t\"github.com/mattn/go-runewidth\"\n\n\t\"github.com/pterm/pterm/internal\"\n)\n\n// DefaultInteractiveTextInput is the default InteractiveTextInput printer.\nvar DefaultInteractiveTextInput = InteractiveTextInputPrinter{\n\tDefaultText: \"Input text\",\n\tDelimiter:   \": \",\n\tTextStyle:   &ThemeDefault.PrimaryStyle,\n\tMask:        \"\",\n}\n\n// InteractiveTextInputPrinter is a printer for interactive select menus.\ntype InteractiveTextInputPrinter struct {\n\tTextStyle       *Style\n\tDefaultText     string\n\tDefaultValue    string\n\tDelimiter       string\n\tMultiLine       bool\n\tMask            string\n\tOnInterruptFunc func()\n\n\tinput         []string\n\tcursorXPos    int\n\tcursorYPos    int\n\ttext          string\n\tstartedTyping bool\n\tvalueStyle    *Style\n}\n\n// WithDefaultText sets the default text.\nfunc (p InteractiveTextInputPrinter) WithDefaultText(text string) *InteractiveTextInputPrinter {\n\tp.DefaultText = text\n\treturn &p\n}\n\n// WithDefaultValue sets the default value.\nfunc (p InteractiveTextInputPrinter) WithDefaultValue(value string) *InteractiveTextInputPrinter {\n\tp.DefaultValue = value\n\treturn &p\n}\n\n// WithTextStyle sets the text style.\nfunc (p InteractiveTextInputPrinter) WithTextStyle(style *Style) *InteractiveTextInputPrinter {\n\tp.TextStyle = style\n\treturn &p\n}\n\n// WithMultiLine sets the multi line flag.\nfunc (p InteractiveTextInputPrinter) WithMultiLine(multiLine ...bool) *InteractiveTextInputPrinter {\n\tp.MultiLine = internal.WithBoolean(multiLine)\n\treturn &p\n}\n\n// WithMask sets the mask.\nfunc (p InteractiveTextInputPrinter) WithMask(mask string) *InteractiveTextInputPrinter {\n\tp.Mask = mask\n\treturn &p\n}\n\n// WithOnInterruptFunc sets the function to execute on exit of the input reader\nfunc (p InteractiveTextInputPrinter) WithOnInterruptFunc(exitFunc func()) *InteractiveTextInputPrinter {\n\tp.OnInterruptFunc = exitFunc\n\treturn &p\n}\n\n// WithDelimiter sets the delimiter between the message and the input.\nfunc (p InteractiveTextInputPrinter) WithDelimiter(delimiter string) *InteractiveTextInputPrinter {\n\tp.Delimiter = delimiter\n\treturn &p\n}\n\n// Show shows the interactive select menu and returns the selected entry.\nfunc (p InteractiveTextInputPrinter) Show(text ...string) (string, error) {\n\t// should be the first defer statement to make sure it is executed last\n\t// and all the needed cleanup can be done before\n\tcancel, exit := internal.NewCancelationSignal(p.OnInterruptFunc)\n\tdefer exit()\n\n\tvar areaText string\n\n\tif len(text) == 0 || text[0] == \"\" {\n\t\ttext = []string{p.DefaultText}\n\t}\n\n\tif p.MultiLine {\n\t\tareaText = p.TextStyle.Sprintfln(\"%s %s %s\", text[0], ThemeDefault.SecondaryStyle.Sprint(\"[Press tab to submit]\"), p.Delimiter)\n\t} else {\n\t\tareaText = p.TextStyle.Sprintf(\"%s%s\", text[0], p.Delimiter)\n\t}\n\n\tp.text = areaText\n\tarea := cursor.NewArea()\n\tarea.Update(areaText)\n\tarea.StartOfLine()\n\n\tif !p.MultiLine {\n\t\tcursor.Right(runewidth.StringWidth(RemoveColorFromString(areaText)))\n\t}\n\n\tif p.DefaultValue != \"\" {\n\t\tp.input = append(p.input, p.DefaultValue)\n\t\tp.updateArea(&area)\n\t}\n\n\terr := keyboard.Listen(func(key keys.Key) (stop bool, err error) {\n\t\tif !p.MultiLine {\n\t\t\tp.cursorYPos = 0\n\t\t}\n\t\tif len(p.input) == 0 {\n\t\t\tp.input = append(p.input, \"\")\n\t\t}\n\n\t\tswitch key.Code {\n\t\tcase keys.Tab:\n\t\t\tif p.MultiLine {\n\t\t\t\tarea.Bottom()\n\t\t\t\treturn true, nil\n\t\t\t}\n\t\tcase keys.Enter:\n\t\t\tif p.DefaultValue != \"\" && !p.startedTyping {\n\t\t\t\tfor i := range p.input {\n\t\t\t\t\tp.input[i] = RemoveColorFromString(p.input[i])\n\t\t\t\t}\n\n\t\t\t\tif p.MultiLine {\n\t\t\t\t\tarea.Bottom()\n\t\t\t\t}\n\t\t\t\treturn true, nil\n\t\t\t}\n\n\t\t\tif p.MultiLine {\n\t\t\t\tif key.AltPressed {\n\t\t\t\t\tp.cursorXPos = 0\n\t\t\t\t}\n\t\t\t\tappendAfterY := append([]string{}, p.input[p.cursorYPos+1:]...)\n\t\t\t\tappendAfterX := string(append([]rune{}, []rune(p.input[p.cursorYPos])[len([]rune(p.input[p.cursorYPos]))+p.cursorXPos:]...))\n\t\t\t\tp.input[p.cursorYPos] = string(append([]rune{}, []rune(p.input[p.cursorYPos])[:len([]rune(p.input[p.cursorYPos]))+p.cursorXPos]...))\n\t\t\t\tp.input = append(p.input[:p.cursorYPos+1], appendAfterX)\n\t\t\t\tp.input = append(p.input, appendAfterY...)\n\t\t\t\tp.cursorYPos++\n\t\t\t\tp.cursorXPos = -internal.GetStringMaxWidth(p.input[p.cursorYPos])\n\t\t\t\tcursor.StartOfLine()\n\t\t\t} else {\n\t\t\t\treturn true, nil\n\t\t\t}\n\t\tcase keys.RuneKey:\n\t\t\tif !p.startedTyping {\n\t\t\t\tp.startedTyping = true\n\t\t\t}\n\t\t\tp.input[p.cursorYPos] = string(append([]rune(p.input[p.cursorYPos])[:len([]rune(p.input[p.cursorYPos]))+p.cursorXPos], append([]rune(key.String()), []rune(p.input[p.cursorYPos])[len([]rune(p.input[p.cursorYPos]))+p.cursorXPos:]...)...))\n\t\tcase keys.Space:\n\t\t\tif !p.startedTyping {\n\t\t\t\tp.startedTyping = true\n\t\t\t}\n\t\t\tp.input[p.cursorYPos] = string(append([]rune(p.input[p.cursorYPos])[:len([]rune(p.input[p.cursorYPos]))+p.cursorXPos], append([]rune(\" \"), []rune(p.input[p.cursorYPos])[len([]rune(p.input[p.cursorYPos]))+p.cursorXPos:]...)...))\n\t\tcase keys.Backspace:\n\t\t\tif !p.startedTyping {\n\t\t\t\tp.startedTyping = true\n\t\t\t}\n\t\t\tif len([]rune(p.input[p.cursorYPos]))+p.cursorXPos > 0 {\n\t\t\t\tp.input[p.cursorYPos] = string(append([]rune(p.input[p.cursorYPos])[:len([]rune(p.input[p.cursorYPos]))-1+p.cursorXPos], []rune(p.input[p.cursorYPos])[len([]rune(p.input[p.cursorYPos]))+p.cursorXPos:]...))\n\t\t\t} else if p.cursorYPos > 0 {\n\t\t\t\tp.input[p.cursorYPos-1] += p.input[p.cursorYPos]\n\t\t\t\tappendAfterY := append([]string{}, p.input[p.cursorYPos+1:]...)\n\t\t\t\tp.input = append(p.input[:p.cursorYPos], appendAfterY...)\n\t\t\t\tp.cursorXPos = 0\n\t\t\t\tp.cursorYPos--\n\t\t\t}\n\t\tcase keys.Delete:\n\t\t\tif !p.startedTyping {\n\t\t\t\tp.input = []string{\"\"}\n\t\t\t\tp.startedTyping = true\n\t\t\t\treturn false, nil\n\t\t\t}\n\t\t\tif len([]rune(p.input[p.cursorYPos]))+p.cursorXPos < len([]rune(p.input[p.cursorYPos])) {\n\t\t\t\tp.input[p.cursorYPos] = string(append([]rune(p.input[p.cursorYPos])[:len([]rune(p.input[p.cursorYPos]))+p.cursorXPos], []rune(p.input[p.cursorYPos])[len([]rune(p.input[p.cursorYPos]))+p.cursorXPos+1:]...))\n\t\t\t\tp.cursorXPos++\n\t\t\t} else if p.cursorYPos < len(p.input)-1 {\n\t\t\t\tp.input[p.cursorYPos] += p.input[p.cursorYPos+1]\n\t\t\t\tappendAfterY := append([]string{}, p.input[p.cursorYPos+2:]...)\n\t\t\t\tp.input = append(p.input[:p.cursorYPos+1], appendAfterY...)\n\t\t\t\tp.cursorXPos = 0\n\t\t\t}\n\t\tcase keys.CtrlC:\n\t\t\tcancel()\n\t\t\treturn true, nil\n\t\tcase keys.Down:\n\t\t\tif !p.MultiLine {\n\t\t\t\treturn false, nil\n\t\t\t}\n\t\t\tif !p.startedTyping {\n\t\t\t\tp.input = []string{\"\"}\n\t\t\t\tp.startedTyping = true\n\t\t\t}\n\t\t\tif p.cursorYPos+1 < len(p.input) {\n\t\t\t\tp.cursorXPos = (internal.GetStringMaxWidth(p.input[p.cursorYPos]) + p.cursorXPos) - internal.GetStringMaxWidth(p.input[p.cursorYPos+1])\n\t\t\t\tif p.cursorXPos > 0 {\n\t\t\t\t\tp.cursorXPos = 0\n\t\t\t\t}\n\t\t\t\tp.cursorYPos++\n\t\t\t}\n\t\tcase keys.Up:\n\t\t\tif !p.MultiLine {\n\t\t\t\treturn false, nil\n\t\t\t}\n\t\t\tif !p.startedTyping {\n\t\t\t\tp.input = []string{\"\"}\n\t\t\t\tp.startedTyping = true\n\t\t\t}\n\t\t\tif p.cursorYPos > 0 {\n\t\t\t\tp.cursorXPos = (internal.GetStringMaxWidth(p.input[p.cursorYPos]) + p.cursorXPos) - internal.GetStringMaxWidth(p.input[p.cursorYPos-1])\n\t\t\t\tif p.cursorXPos > 0 {\n\t\t\t\t\tp.cursorXPos = 0\n\t\t\t\t}\n\t\t\t\tp.cursorYPos--\n\t\t\t}\n\t\t}\n\n\t\tif internal.GetStringMaxWidth(p.input[p.cursorYPos]) > 0 {\n\t\t\tswitch key.Code {\n\t\t\tcase keys.Right:\n\t\t\t\tif p.cursorXPos < 0 {\n\t\t\t\t\tp.cursorXPos++\n\t\t\t\t} else if p.cursorYPos < len(p.input)-1 {\n\t\t\t\t\tp.cursorYPos++\n\t\t\t\t\tp.cursorXPos = -internal.GetStringMaxWidth(p.input[p.cursorYPos])\n\t\t\t\t}\n\t\t\tcase keys.Left:\n\t\t\t\tif p.cursorXPos+internal.GetStringMaxWidth(p.input[p.cursorYPos]) > 0 {\n\t\t\t\t\tp.cursorXPos--\n\t\t\t\t} else if p.cursorYPos > 0 {\n\t\t\t\t\tp.cursorYPos--\n\t\t\t\t\tp.cursorXPos = 0\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tp.updateArea(&area)\n\n\t\treturn false, nil\n\t})\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\t// Add new line\n\tPrintln()\n\n\tfor i, s := range p.input {\n\t\tif i < len(p.input)-1 {\n\t\t\tareaText += s + \"\\n\"\n\t\t} else {\n\t\t\tareaText += s\n\t\t}\n\t}\n\n\tif !p.startedTyping {\n\t\treturn p.DefaultValue, nil\n\t}\n\n\treturn strings.ReplaceAll(areaText, p.text, \"\"), nil\n}\n\nfunc (p InteractiveTextInputPrinter) updateArea(area *cursor.Area) string {\n\tif !p.MultiLine {\n\t\tp.cursorYPos = 0\n\t}\n\tareaText := p.text\n\n\tfor i, s := range p.input {\n\t\tif i < len(p.input)-1 {\n\t\t\tareaText += s + \"\\n\"\n\t\t} else {\n\t\t\tareaText += s\n\t\t}\n\t}\n\n\tif p.Mask != \"\" {\n\t\tareaText = p.text + strings.Repeat(p.Mask, internal.GetStringMaxWidth(areaText)-internal.GetStringMaxWidth(p.text))\n\t}\n\n\tif p.cursorXPos+internal.GetStringMaxWidth(p.input[p.cursorYPos]) < 1 {\n\t\tp.cursorXPos = -internal.GetStringMaxWidth(p.input[p.cursorYPos])\n\t}\n\n\tarea.Update(Gray(areaText))\n\tarea.Top()\n\tarea.Down(p.cursorYPos + 1)\n\tarea.StartOfLine()\n\tif p.MultiLine {\n\t\tcursor.Right(internal.GetStringMaxWidth(p.input[p.cursorYPos]) + p.cursorXPos)\n\t} else {\n\t\tcursor.Right(internal.GetStringMaxWidth(areaText) + p.cursorXPos)\n\t}\n\treturn areaText\n}\n"
        },
        {
          "name": "interactive_textinput_printer_test.go",
          "type": "blob",
          "size": 7.396484375,
          "content": "package pterm_test\n\nimport (\n\t\"os\"\n\t\"reflect\"\n\t\"testing\"\n\t\"time\"\n\n\t\"atomicgo.dev/keyboard\"\n\t\"atomicgo.dev/keyboard/keys\"\n\t\"github.com/MarvinJWendt/testza\"\n\n\t\"github.com/pterm/pterm\"\n\t\"github.com/pterm/pterm/internal\"\n)\n\nfunc TestInteractiveTextInputPrinter_WithDefaultText(t *testing.T) {\n\tp := pterm.DefaultInteractiveTextInput.WithDefaultText(\"default\")\n\ttestza.AssertEqual(t, p.DefaultText, \"default\")\n}\n\nfunc TestInteractiveTextInputPrinter_WithDefaultValue(t *testing.T) {\n\tp := pterm.DefaultInteractiveTextInput.WithDefaultValue(\"default\")\n\ttestza.AssertEqual(t, p.DefaultValue, \"default\")\n}\n\nfunc TestInteractiveTextInputPrinter_WithDelimiter(t *testing.T) {\n\tp := pterm.DefaultInteractiveTextInput.WithDelimiter(\">>\")\n\ttestza.AssertEqual(t, p.Delimiter, \">>\")\n}\n\nfunc TestInteractiveTextInputPrinter_WithMultiLine_true(t *testing.T) {\n\tp := pterm.DefaultInteractiveTextInput.WithMultiLine()\n\ttestza.AssertTrue(t, p.MultiLine)\n}\n\nfunc TestInteractiveTextInputPrinter_WithMultiLine_false(t *testing.T) {\n\tp := pterm.DefaultInteractiveTextInput.WithMultiLine(false)\n\ttestza.AssertFalse(t, p.MultiLine)\n}\n\nfunc TestInteractiveTextInputPrinter_WithTextStyle(t *testing.T) {\n\tstyle := pterm.NewStyle(pterm.FgRed)\n\tp := pterm.DefaultInteractiveTextInput.WithTextStyle(style)\n\ttestza.AssertEqual(t, p.TextStyle, style)\n}\n\nfunc TestInteractiveTextInputPrinter_WithMask(t *testing.T) {\n\tgo func() {\n\t\ttime.Sleep(1 * time.Millisecond)\n\t\tkeyboard.SimulateKeyPress('a')\n\t\tkeyboard.SimulateKeyPress('b')\n\t\tkeyboard.SimulateKeyPress('c')\n\t\tkeyboard.SimulateKeyPress(keys.Enter)\n\t}()\n\tresult, _ := pterm.DefaultInteractiveTextInput.WithMask(\"*\").Show()\n\ttestza.AssertEqual(t, \"abc\", result)\n}\n\nfunc TestInteractiveTextInputPrinter_WithCancel(t *testing.T) {\n\texitCalled := false\n\tinternal.DefaultExitFunc = func(code int) {\n\t\texitCalled = true\n\t}\n\tdefer func() { internal.DefaultExitFunc = os.Exit }()\n\n\tgo func() {\n\t\ttime.Sleep(1 * time.Millisecond)\n\t\tkeyboard.SimulateKeyPress(keys.CtrlC)\n\t}()\n\n\tresult, _ := pterm.DefaultInteractiveTextInput.WithMask(\"*\").Show()\n\ttestza.AssertEqual(t, \"\", result)\n\n\tif !exitCalled {\n\t\tt.Errorf(\"Expected exit to be called on Ctrl+C\")\n\t}\n}\n\nfunc TestInteractiveTextInputPrinter_OnEnter(t *testing.T) {\n\tgo func() {\n\t\tkeyboard.SimulateKeyPress(keys.Enter)\n\t}()\n\tresult, _ := pterm.DefaultInteractiveTextInput.WithDefaultValue(\"default\").Show()\n\ttestza.AssertEqual(t, \"default\", result)\n}\n\nfunc TestInteractiveTextInputPrinter_Editable(t *testing.T) {\n\tgo func() {\n\t\t// change `default` to `deffaultt` by simulating cursor moves `left`, `right` and inserting\n\t\t// keys on current cursor positions.\n\t\tkeyboard.SimulateKeyPress(keys.Left)\n\t\tkeyboard.SimulateKeyPress(keys.Left)\n\t\tkeyboard.SimulateKeyPress(keys.Left)\n\t\tkeyboard.SimulateKeyPress(keys.Left)\n\t\tkeyboard.SimulateKeyPress(keys.Key{Code: keys.RuneKey, Runes: []rune{'f'}})\n\t\tkeyboard.SimulateKeyPress(keys.Right)\n\t\tkeyboard.SimulateKeyPress(keys.Right)\n\t\tkeyboard.SimulateKeyPress(keys.Right)\n\t\tkeyboard.SimulateKeyPress(keys.Key{Code: keys.RuneKey, Runes: []rune{'t'}})\n\t\tkeyboard.SimulateKeyPress(keys.Enter)\n\t}()\n\n\tresult, _ := pterm.DefaultInteractiveTextInput.WithDefaultValue(\"default\").Show()\n\ttestza.AssertEqual(t, \"deffaultt\", result)\n}\n\nfunc TestInteractiveTextInputPrinter_WithMultiLineOnTab(t *testing.T) {\n\tgo func() {\n\t\tkeyboard.SimulateKeyPress(keys.Tab)\n\t}()\n\tresult, _ := pterm.DefaultInteractiveTextInput.\n\t\tWithMultiLine(true).\n\t\tWithDefaultValue(\"default\").Show()\n\ttestza.AssertEqual(t, \"default\", result)\n}\n\nfunc TestInteractiveTextInputPrinter_WithMultiLineOnUp(t *testing.T) {\n\tgo func() {\n\t\ttime.Sleep(1 * time.Millisecond)\n\t\tkeyboard.SimulateKeyPress(keys.Backspace)\n\t\tkeyboard.SimulateKeyPress(keys.Enter)\n\t\tkeyboard.SimulateKeyPress(\"second line\")\n\t\tkeyboard.SimulateKeyPress(keys.Up)\n\t\tkeyboard.SimulateKeyPress(\"first line\")\n\t\tkeyboard.SimulateKeyPress(keys.Tab)\n\t}()\n\tresult, _ := pterm.DefaultInteractiveTextInput.\n\t\tWithMultiLine(true).Show()\n\ttestza.AssertEqual(t, \"first line\\nsecond line\", result)\n}\n\nfunc TestInteractiveTextInputPrinter_WithMultiLineOnDown(t *testing.T) {\n\tgo func() {\n\t\ttime.Sleep(1 * time.Millisecond)\n\t\tkeyboard.SimulateKeyPress(\"a\")\n\t\tkeyboard.SimulateKeyPress(keys.Enter)\n\t\tkeyboard.SimulateKeyPress(keys.Enter)\n\t\tkeyboard.SimulateKeyPress(keys.Up)\n\t\tkeyboard.SimulateKeyPress(\"b\")\n\t\tkeyboard.SimulateKeyPress(keys.Down)\n\t\tkeyboard.SimulateKeyPress(\"c\")\n\t\tkeyboard.SimulateKeyPress(keys.Tab)\n\t}()\n\tresult, _ := pterm.DefaultInteractiveTextInput.\n\t\tWithMultiLine(true).Show()\n\ttestza.AssertEqual(t, \"a\\nb\\nc\", result)\n}\n\nfunc TestInteractiveTextInputPrinter_WithMultiLineOnLeft(t *testing.T) {\n\tgo func() {\n\t\ttime.Sleep(1 * time.Millisecond)\n\t\tkeyboard.SimulateKeyPress(keys.Backspace)\n\t\tkeyboard.SimulateKeyPress(keys.Enter)\n\t\tkeyboard.SimulateKeyPress(\"a\")\n\t\tkeyboard.SimulateKeyPress(keys.Left)\n\t\tkeyboard.SimulateKeyPress(keys.Left)\n\t\tkeyboard.SimulateKeyPress(\"b\")\n\t\tkeyboard.SimulateKeyPress(keys.Tab)\n\t}()\n\tresult, _ := pterm.DefaultInteractiveTextInput.\n\t\tWithMultiLine(true).Show()\n\ttestza.AssertEqual(t, \"b\\na\", result)\n}\n\nfunc TestInteractiveTextInputPrinter_WithMultiLineOnRight(t *testing.T) {\n\tgo func() {\n\t\ttime.Sleep(1 * time.Millisecond)\n\t\tkeyboard.SimulateKeyPress('a')\n\t\tkeyboard.SimulateKeyPress(keys.Enter)\n\t\tkeyboard.SimulateKeyPress(keys.Up)\n\t\tkeyboard.SimulateKeyPress(keys.Right)\n\t\tkeyboard.SimulateKeyPress(keys.Right)\n\t\tkeyboard.SimulateKeyPress(\"b\")\n\t\tkeyboard.SimulateKeyPress(keys.Tab)\n\t}()\n\tresult, _ := pterm.DefaultInteractiveTextInput.\n\t\tWithMultiLine(true).Show()\n\ttestza.AssertEqual(t, \"a\\nb\", result)\n}\n\nfunc TestInteractiveTextInputPrinter_OnBackspace(t *testing.T) {\n\tgo func() {\n\t\tkeyboard.SimulateKeyPress(keys.Backspace)\n\t\tkeyboard.SimulateKeyPress(keys.Enter)\n\t}()\n\tresult, _ := pterm.DefaultInteractiveTextInput.\n\t\tWithDefaultValue(\"a\").Show()\n\ttestza.AssertEqual(t, \"\", result)\n}\n\nfunc TestInteractiveTextInputPrinter_WithMultiLineOnDelete(t *testing.T) {\n\tgo func() {\n\t\tkeyboard.SimulateKeyPress(keys.Backspace)\n\t\tkeyboard.SimulateKeyPress(keys.Enter)\n\t\tkeyboard.SimulateKeyPress('a')\n\t\tkeyboard.SimulateKeyPress(keys.Up)\n\t\tkeyboard.SimulateKeyPress(keys.Delete)\n\t\tkeyboard.SimulateKeyPress(keys.Tab)\n\t}()\n\tresult, _ := pterm.DefaultInteractiveTextInput.\n\t\tWithMultiLine(true).\n\t\tWithDefaultValue(\"a\").Show()\n\ttestza.AssertEqual(t, \"a\", result)\n}\n\nfunc TestInteractiveTextInputPrinter_WithMultiLineOnBackspace(t *testing.T) {\n\tgo func() {\n\t\tkeyboard.SimulateKeyPress(keys.Backspace)\n\t\tkeyboard.SimulateKeyPress(keys.Enter)\n\t\tkeyboard.SimulateKeyPress(keys.Backspace)\n\t\tkeyboard.SimulateKeyPress(keys.Tab)\n\t}()\n\tresult, _ := pterm.DefaultInteractiveTextInput.\n\t\tWithMultiLine(true).\n\t\tWithDefaultValue(\"a\").Show()\n\ttestza.AssertEqual(t, \"\", result)\n}\n\nfunc TestInteractiveTextInputPrinter_WithMultiLineOnLeftRight(t *testing.T) {\n\tgo func() {\n\t\ttime.Sleep(1 * time.Millisecond)\n\t\tkeyboard.SimulateKeyPress(\"a\")\n\t\tkeyboard.SimulateKeyPress(keys.Enter)\n\t\tkeyboard.SimulateKeyPress(\"b\")\n\t\tkeyboard.SimulateKeyPress(keys.Tab)\n\t}()\n\tresult, _ := pterm.DefaultInteractiveTextInput.\n\t\tWithMultiLine(true).\n\t\tShow(\"Enter\")\n\ttestza.AssertEqual(t, \"a\\nb\", result)\n}\n\nfunc TestInteractiveTextInputPrinter_WithOnInterruptFunc(t *testing.T) {\n\t// OnInterrupt function defaults to nil\n\tpd := pterm.InteractiveTextInputPrinter{}\n\ttestza.AssertNil(t, pd.OnInterruptFunc)\n\n\t// Verify OnInterrupt is set\n\texitfunc := func() {}\n\tp := pterm.DefaultInteractiveTextInput.WithOnInterruptFunc(exitfunc)\n\ttestza.AssertEqual(t, reflect.ValueOf(p.OnInterruptFunc).Pointer(), reflect.ValueOf(exitfunc).Pointer())\n}\n"
        },
        {
          "name": "interface_live_printer.go",
          "type": "blob",
          "size": 0.5615234375,
          "content": "package pterm\n\nimport \"io\"\n\n// LivePrinter is a printer which can update it's output live.\ntype LivePrinter interface {\n\t// GenericStart runs Start, but returns a LivePrinter.\n\t// This is used for the interface LivePrinter.\n\t// You most likely want to use Start instead of this in your program.\n\tGenericStart() (*LivePrinter, error)\n\n\t// GenericStop runs Stop, but returns a LivePrinter.\n\t// This is used for the interface LivePrinter.\n\t// You most likely want to use Stop instead of this in your program.\n\tGenericStop() (*LivePrinter, error)\n\n\tSetWriter(writer io.Writer)\n}\n"
        },
        {
          "name": "interface_renderable_printer.go",
          "type": "blob",
          "size": 0.271484375,
          "content": "package pterm\n\n// RenderPrinter is used to display renderable content.\n// Example for renderable content is a Table.\ntype RenderPrinter interface {\n\t// Render the XXX to the terminal.\n\tRender() error\n\n\t// Srender returns the rendered string of XXX.\n\tSrender() (string, error)\n}\n"
        },
        {
          "name": "interface_text_printer.go",
          "type": "blob",
          "size": 2.2421875,
          "content": "package pterm\n\n// TextPrinter contains methods to print formatted text to the console or return it as a string.\ntype TextPrinter interface {\n\t// Sprint formats using the default formats for its operands and returns the resulting string.\n\t// Spaces are added between operands when neither is a string.\n\tSprint(a ...any) string\n\n\t// Sprintln formats using the default formats for its operands and returns the resulting string.\n\t// Spaces are always added between operands and a newline is appended.\n\tSprintln(a ...any) string\n\n\t// Sprintf formats according to a format specifier and returns the resulting string.\n\tSprintf(format string, a ...any) string\n\n\t// Sprintfln formats according to a format specifier and returns the resulting string.\n\t// Spaces are always added between operands and a newline is appended.\n\tSprintfln(format string, a ...any) string\n\n\t// Print formats using the default formats for its operands and writes to standard output.\n\t// Spaces are added between operands when neither is a string.\n\t// It returns the number of bytes written and any write error encountered.\n\tPrint(a ...any) *TextPrinter\n\n\t// Println formats using the default formats for its operands and writes to standard output.\n\t// Spaces are always added between operands and a newline is appended.\n\t// It returns the number of bytes written and any write error encountered.\n\tPrintln(a ...any) *TextPrinter\n\n\t// Printf formats according to a format specifier and writes to standard output.\n\t// It returns the number of bytes written and any write error encountered.\n\tPrintf(format string, a ...any) *TextPrinter\n\n\t// Printfln formats according to a format specifier and writes to standard output.\n\t// Spaces are always added between operands and a newline is appended.\n\t// It returns the number of bytes written and any write error encountered.\n\tPrintfln(format string, a ...any) *TextPrinter\n\n\t// PrintOnError prints every error which is not nil.\n\t// If every error is nil, nothing will be printed.\n\t// This can be used for simple error checking.\n\tPrintOnError(a ...any) *TextPrinter\n\n\t// PrintOnErrorf wraps every error which is not nil and prints it.\n\t// If every error is nil, nothing will be printed.\n\t// This can be used for simple error checking.\n\tPrintOnErrorf(format string, a ...any) *TextPrinter\n}\n"
        },
        {
          "name": "internal",
          "type": "tree",
          "content": null
        },
        {
          "name": "logger.go",
          "type": "blob",
          "size": 10.533203125,
          "content": "package pterm\n\nimport (\n\t\"encoding/json\"\n\t\"io\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"runtime\"\n\t\"strings\"\n\t\"sync\"\n\t\"time\"\n\n\t\"github.com/pterm/pterm/internal\"\n)\n\ntype LogLevel int\n\n// Style returns the style of the log level.\nfunc (l LogLevel) Style() Style {\n\tbaseStyle := NewStyle(Bold)\n\tswitch l {\n\tcase LogLevelTrace:\n\t\treturn baseStyle.Add(*FgCyan.ToStyle())\n\tcase LogLevelDebug:\n\t\treturn baseStyle.Add(*FgBlue.ToStyle())\n\tcase LogLevelInfo:\n\t\treturn baseStyle.Add(*FgGreen.ToStyle())\n\tcase LogLevelWarn:\n\t\treturn baseStyle.Add(*FgYellow.ToStyle())\n\tcase LogLevelError:\n\t\treturn baseStyle.Add(*FgRed.ToStyle())\n\tcase LogLevelFatal:\n\t\treturn baseStyle.Add(*FgRed.ToStyle())\n\tcase LogLevelPrint:\n\t\treturn baseStyle.Add(*FgWhite.ToStyle())\n\t}\n\n\treturn baseStyle.Add(*FgWhite.ToStyle())\n}\n\nfunc (l LogLevel) String() string {\n\tswitch l {\n\tcase LogLevelDisabled:\n\t\treturn \"\"\n\tcase LogLevelTrace:\n\t\treturn \"TRACE\"\n\tcase LogLevelDebug:\n\t\treturn \"DEBUG\"\n\tcase LogLevelInfo:\n\t\treturn \"INFO\"\n\tcase LogLevelWarn:\n\t\treturn \"WARN\"\n\tcase LogLevelError:\n\t\treturn \"ERROR\"\n\tcase LogLevelFatal:\n\t\treturn \"FATAL\"\n\tcase LogLevelPrint:\n\t\treturn \"PRINT\"\n\t}\n\treturn \"Unknown\"\n}\n\nconst (\n\t// LogLevelDisabled does never print.\n\tLogLevelDisabled LogLevel = iota\n\t// LogLevelTrace is the log level for traces.\n\tLogLevelTrace\n\t// LogLevelDebug is the log level for debug.\n\tLogLevelDebug\n\t// LogLevelInfo is the log level for info.\n\tLogLevelInfo\n\t// LogLevelWarn is the log level for warnings.\n\tLogLevelWarn\n\t// LogLevelError is the log level for errors.\n\tLogLevelError\n\t// LogLevelFatal is the log level for fatal errors.\n\tLogLevelFatal\n\t// LogLevelPrint is the log level for printing.\n\tLogLevelPrint\n)\n\n// LogFormatter is the log formatter.\n// Can be either LogFormatterColorful or LogFormatterJSON.\ntype LogFormatter int\n\nconst (\n\t// LogFormatterColorful is a colorful log formatter.\n\tLogFormatterColorful LogFormatter = iota\n\t// LogFormatterJSON is a JSON log formatter.\n\tLogFormatterJSON\n)\n\n// DefaultLogger is the default logger.\nvar DefaultLogger = Logger{\n\tFormatter:  LogFormatterColorful,\n\tWriter:     os.Stdout,\n\tLevel:      LogLevelInfo,\n\tShowTime:   true,\n\tTimeFormat: \"2006-01-02 15:04:05\",\n\tMaxWidth:   80,\n\tKeyStyles: map[string]Style{\n\t\t\"error\":  *NewStyle(FgRed, Bold),\n\t\t\"err\":    *NewStyle(FgRed, Bold),\n\t\t\"caller\": *NewStyle(FgGray, Bold),\n\t},\n}\n\n// loggerMutex syncs all loggers, so that they don't print at the exact same time.\nvar loggerMutex sync.Mutex\n\ntype Logger struct {\n\t// Formatter is the log formatter of the logger.\n\tFormatter LogFormatter\n\t// Writer is the writer of the logger.\n\tWriter io.Writer\n\t// Level is the log level of the logger.\n\tLevel LogLevel\n\t// ShowCaller defines if the logger should print the caller.\n\tShowCaller bool\n\t// CallerOffset defines the offset of the caller.\n\tCallerOffset int\n\t// ShowTime defines if the logger should print a timestamp.\n\tShowTime bool\n\t// TimestampLayout defines the layout of the timestamp.\n\tTimeFormat string\n\t// KeyStyles defines the styles for specific keys.\n\tKeyStyles map[string]Style\n\t// MaxWidth defines the maximum width of the logger.\n\t// If the text (including the arguments) is longer than the max width, it will be split into multiple lines.\n\tMaxWidth int\n}\n\n// WithFormatter sets the log formatter of the logger.\nfunc (l Logger) WithFormatter(formatter LogFormatter) *Logger {\n\tl.Formatter = formatter\n\treturn &l\n}\n\n// WithWriter sets the writer of the logger.\nfunc (l Logger) WithWriter(writer io.Writer) *Logger {\n\tl.Writer = writer\n\treturn &l\n}\n\n// WithLevel sets the log level of the logger.\nfunc (l Logger) WithLevel(level LogLevel) *Logger {\n\tl.Level = level\n\treturn &l\n}\n\n// WithCaller enables or disables the caller.\nfunc (l Logger) WithCaller(b ...bool) *Logger {\n\tl.ShowCaller = internal.WithBoolean(b)\n\treturn &l\n}\n\n// WithCallerOffset sets the caller offset.\nfunc (l Logger) WithCallerOffset(offset int) *Logger {\n\tl.CallerOffset = offset\n\treturn &l\n}\n\n// WithTime enables or disables the timestamp.\nfunc (l Logger) WithTime(b ...bool) *Logger {\n\tl.ShowTime = internal.WithBoolean(b)\n\treturn &l\n}\n\n// WithTimeFormat sets the timestamp layout.\nfunc (l Logger) WithTimeFormat(format string) *Logger {\n\tl.TimeFormat = format\n\treturn &l\n}\n\n// WithKeyStyles sets the style for a specific key.\nfunc (l Logger) WithKeyStyles(styles map[string]Style) *Logger {\n\tl.KeyStyles = styles\n\treturn &l\n}\n\n// WithMaxWidth sets the maximum width of the logger.\nfunc (l Logger) WithMaxWidth(width int) *Logger {\n\tl.MaxWidth = width\n\treturn &l\n}\n\n// AppendKeyStyles appends a style for a specific key.\nfunc (l Logger) AppendKeyStyles(styles map[string]Style) *Logger {\n\tfor k, v := range styles {\n\t\tl.KeyStyles[k] = v\n\t}\n\treturn &l\n}\n\n// AppendKeyStyle appends a style for a specific key.\nfunc (l Logger) AppendKeyStyle(key string, style Style) *Logger {\n\tl.KeyStyles[key] = style\n\treturn &l\n}\n\n// CanPrint checks if the logger can print a specific log level.\nfunc (l Logger) CanPrint(level LogLevel) bool {\n\tif l.Level == LogLevelDisabled {\n\t\treturn false\n\t}\n\treturn l.Level <= level\n}\n\n// Args converts any arguments to a slice of LoggerArgument.\nfunc (l Logger) Args(args ...any) []LoggerArgument {\n\tvar loggerArgs []LoggerArgument\n\n\t// args are in the format of: key, value, key, value, key, value, ...\n\targs = l.sanitizeArgs(args)\n\n\tfor i := 0; i < len(args); i += 2 {\n\t\tkey := Sprint(args[i])\n\t\tvalue := args[i+1]\n\n\t\tloggerArgs = append(loggerArgs, LoggerArgument{\n\t\t\tKey:   key,\n\t\t\tValue: value,\n\t\t})\n\t}\n\n\treturn loggerArgs\n}\n\n// ArgsFromMap converts a map to a slice of LoggerArgument.\nfunc (l Logger) ArgsFromMap(m map[string]any) []LoggerArgument {\n\tvar loggerArgs []LoggerArgument\n\n\tfor k, v := range m {\n\t\tloggerArgs = append(loggerArgs, LoggerArgument{\n\t\t\tKey:   k,\n\t\t\tValue: v,\n\t\t})\n\t}\n\n\treturn loggerArgs\n}\n\n// sanitizeArgs inserts an error message into an args slice if an odd number of arguments is provided.\nfunc (l Logger) sanitizeArgs(args []any) []any {\n\tnumArgs := len(args)\n\tif numArgs > 0 && numArgs%2 != 0 {\n\t\tif numArgs > 1 {\n\t\t\tlastArg := args[numArgs-1]\n\t\t\targs = append(args[:numArgs-1], []any{ErrKeyWithoutValue, lastArg}...)\n\t\t} else {\n\t\t\targs = []any{ErrKeyWithoutValue, args[0]}\n\t\t}\n\t}\n\treturn args\n}\n\nfunc (l Logger) getCallerInfo() (path string, line int) {\n\tif !l.ShowCaller {\n\t\treturn\n\t}\n\n\t_, path, line, _ = runtime.Caller(l.CallerOffset + 4)\n\t_, callerBase, _, _ := runtime.Caller(0)\n\tbasepath := filepath.Dir(callerBase)\n\tbasepath = strings.ReplaceAll(basepath, \"\\\\\", \"/\")\n\n\tpath = strings.TrimPrefix(path, basepath)\n\n\treturn\n}\n\nfunc (l Logger) combineArgs(args ...[]LoggerArgument) []LoggerArgument {\n\tvar result []LoggerArgument\n\n\tfor _, arg := range args {\n\t\tresult = append(result, arg...)\n\t}\n\n\treturn result\n}\n\nfunc (l Logger) print(level LogLevel, msg string, args []LoggerArgument) {\n\tif !l.CanPrint(level) {\n\t\treturn\n\t}\n\n\tvar line string\n\n\tswitch l.Formatter {\n\tcase LogFormatterColorful:\n\t\tline = l.renderColorful(level, msg, args)\n\tcase LogFormatterJSON:\n\t\tline = l.renderJSON(level, msg, args)\n\t}\n\n\tloggerMutex.Lock()\n\tdefer loggerMutex.Unlock()\n\n\tFprintln(l.Writer, line)\n}\n\nfunc (l Logger) renderColorful(level LogLevel, msg string, args []LoggerArgument) (result string) {\n\tif l.ShowTime {\n\t\tresult += Gray(time.Now().Format(l.TimeFormat)) + \" \"\n\t}\n\n\tif GetTerminalWidth() > 0 && GetTerminalWidth() < l.MaxWidth {\n\t\tl.MaxWidth = GetTerminalWidth()\n\t}\n\n\tvar argumentsInNewLine bool\n\n\tresult += level.Style().Sprintf(\"%-5s\", level.String()) + \" \"\n\n\t// if msg is too long, wrap it to multiple lines with the same length\n\tremainingWidth := l.MaxWidth - internal.GetStringMaxWidth(result)\n\tif internal.GetStringMaxWidth(msg) > remainingWidth {\n\t\targumentsInNewLine = true\n\t\tmsg = DefaultParagraph.WithMaxWidth(remainingWidth).Sprint(msg)\n\t\tpadding := len(time.Now().Format(l.TimeFormat) + \" \")\n\t\tmsg = strings.ReplaceAll(msg, \"\\n\", \"\\n\"+strings.Repeat(\" \", padding)+\"  │   \")\n\t}\n\n\tresult += msg\n\n\tif l.ShowCaller {\n\t\tpath, line := l.getCallerInfo()\n\t\targs = append(args, LoggerArgument{\n\t\t\tKey:   \"caller\",\n\t\t\tValue: FgGray.Sprintf(\"%s:%d\", path, line),\n\t\t})\n\t}\n\n\targuments := make([]string, len(args))\n\n\t// add arguments\n\tif len(args) > 0 {\n\t\tfor i, arg := range args {\n\t\t\tif style, ok := l.KeyStyles[arg.Key]; ok {\n\t\t\t\targuments[i] = style.Sprintf(\"%s: \", arg.Key)\n\t\t\t} else {\n\t\t\t\targuments[i] = level.Style().Sprintf(\"%s: \", arg.Key)\n\t\t\t}\n\n\t\t\targuments[i] += Sprintf(\"%s\", Sprint(arg.Value))\n\t\t}\n\t}\n\n\tfullLine := result + \" \" + strings.Join(arguments, \" \")\n\n\t// if the full line is too long, wrap the arguments to multiple lines\n\tif internal.GetStringMaxWidth(fullLine) > l.MaxWidth {\n\t\targumentsInNewLine = true\n\t}\n\n\tif !argumentsInNewLine {\n\t\tresult = fullLine\n\t} else {\n\t\tpadding := 4\n\t\tif l.ShowTime {\n\t\t\tpadding = len(time.Time{}.Format(l.TimeFormat)) + 3\n\t\t}\n\n\t\tfor i, argument := range arguments {\n\t\t\tvar pipe string\n\t\t\tif i < len(arguments)-1 {\n\t\t\t\tpipe = \"├\"\n\t\t\t} else {\n\t\t\t\tpipe = \"└\"\n\t\t\t}\n\t\t\tresult += \"\\n\" + strings.Repeat(\" \", padding) + pipe + \" \" + argument\n\t\t}\n\t}\n\n\treturn\n}\n\nfunc (l Logger) renderJSON(level LogLevel, msg string, args []LoggerArgument) string {\n\tm := l.argsToMap(args)\n\n\tm[\"level\"] = level.String()\n\tm[\"timestamp\"] = time.Now().Format(l.TimeFormat)\n\tm[\"msg\"] = msg\n\n\tif file, line := l.getCallerInfo(); file != \"\" {\n\t\tm[\"caller\"] = Sprintf(\"%s:%d\", file, line)\n\t}\n\n\tb, _ := json.Marshal(m)\n\treturn string(b)\n}\n\nfunc (l Logger) argsToMap(args []LoggerArgument) map[string]any {\n\tm := make(map[string]any)\n\n\tfor _, arg := range args {\n\t\tm[arg.Key] = arg.Value\n\t}\n\n\treturn m\n}\n\n// Trace prints a trace log.\nfunc (l Logger) Trace(msg string, args ...[]LoggerArgument) {\n\tl.print(LogLevelTrace, msg, l.combineArgs(args...))\n}\n\n// Debug prints a debug log.\nfunc (l Logger) Debug(msg string, args ...[]LoggerArgument) {\n\tl.print(LogLevelDebug, msg, l.combineArgs(args...))\n}\n\n// Info prints an info log.\nfunc (l Logger) Info(msg string, args ...[]LoggerArgument) {\n\tl.print(LogLevelInfo, msg, l.combineArgs(args...))\n}\n\n// Warn prints a warning log.\nfunc (l Logger) Warn(msg string, args ...[]LoggerArgument) {\n\tl.print(LogLevelWarn, msg, l.combineArgs(args...))\n}\n\n// Error prints an error log.\nfunc (l Logger) Error(msg string, args ...[]LoggerArgument) {\n\tl.print(LogLevelError, msg, l.combineArgs(args...))\n}\n\n// Fatal prints a fatal log and exits the program.\nfunc (l Logger) Fatal(msg string, args ...[]LoggerArgument) {\n\tl.print(LogLevelFatal, msg, l.combineArgs(args...))\n\tif l.CanPrint(LogLevelFatal) {\n\t\tos.Exit(1)\n\t}\n}\n\n// Print prints a log.\nfunc (l Logger) Print(msg string, args ...[]LoggerArgument) {\n\tl.print(LogLevelPrint, msg, l.combineArgs(args...))\n}\n\n// LoggerArgument is a key-value pair for a logger.\ntype LoggerArgument struct {\n\t// Key is the key of the argument.\n\tKey string\n\t// Value is the value of the argument.\n\tValue any\n}\n"
        },
        {
          "name": "logger_test.go",
          "type": "blob",
          "size": 0.7919921875,
          "content": "package pterm\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc Test_sanitizeArgs(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\targs     []any\n\t\texpected []any\n\t}{\n\t\t{\n\t\t\tname:     \"pass_zero_args\",\n\t\t\targs:     []any{},\n\t\t\texpected: []any{},\n\t\t},\n\t\t{\n\t\t\tname:     \"pass_one_arg\",\n\t\t\targs:     []any{\"foo\"},\n\t\t\texpected: []any{ErrKeyWithoutValue, \"foo\"},\n\t\t},\n\t\t{\n\t\t\tname:     \"pass_two_args\",\n\t\t\targs:     []any{\"foo\", \"bar\"},\n\t\t\texpected: []any{\"foo\", \"bar\"},\n\t\t},\n\t\t{\n\t\t\tname:     \"pass_three_args\",\n\t\t\targs:     []any{\"foo\", \"bar\", \"baz\"},\n\t\t\texpected: []any{\"foo\", \"bar\", ErrKeyWithoutValue, \"baz\"},\n\t\t},\n\t}\n\tl := Logger{}\n\tfor _, tt := range tests {\n\t\tif got := l.sanitizeArgs(tt.args); !reflect.DeepEqual(got, tt.expected) {\n\t\t\tt.Errorf(\"sanitizeArgs: got: %v, expected: %v\", got, tt.expected)\n\t\t}\n\t}\n}\n"
        },
        {
          "name": "multi_live_printer.go",
          "type": "blob",
          "size": 2.7001953125,
          "content": "package pterm\n\nimport (\n\t\"atomicgo.dev/schedule\"\n\t\"bytes\"\n\t\"io\"\n\t\"os\"\n\t\"strings\"\n\t\"time\"\n)\n\nvar DefaultMultiPrinter = MultiPrinter{\n\tprinters:    []LivePrinter{},\n\tWriter:      os.Stdout,\n\tUpdateDelay: time.Millisecond * 200,\n\n\tbuffers: []*bytes.Buffer{},\n\tarea:    DefaultArea,\n}\n\ntype MultiPrinter struct {\n\tIsActive    bool\n\tWriter      io.Writer\n\tUpdateDelay time.Duration\n\n\tprinters []LivePrinter\n\tbuffers  []*bytes.Buffer\n\tarea     AreaPrinter\n}\n\n// SetWriter sets the writer for the AreaPrinter.\nfunc (p *MultiPrinter) SetWriter(writer io.Writer) {\n\tp.Writer = writer\n}\n\n// WithWriter returns a fork of the MultiPrinter with a new writer.\nfunc (p MultiPrinter) WithWriter(writer io.Writer) *MultiPrinter {\n\tp.Writer = writer\n\treturn &p\n}\n\n// WithUpdateDelay returns a fork of the MultiPrinter with a new update delay.\nfunc (p MultiPrinter) WithUpdateDelay(delay time.Duration) *MultiPrinter {\n\tp.UpdateDelay = delay\n\treturn &p\n}\n\nfunc (p *MultiPrinter) NewWriter() io.Writer {\n\tbuf := bytes.NewBufferString(\"\")\n\tp.buffers = append(p.buffers, buf)\n\treturn buf\n}\n\n// getString returns all buffers appended and separated by a newline.\nfunc (p *MultiPrinter) getString() string {\n\tvar buffer bytes.Buffer\n\tfor _, b := range p.buffers {\n\t\ts := b.String()\n\t\ts = strings.Trim(s, \"\\n\")\n\n\t\tparts := strings.Split(s, \"\\r\") // only get the last override\n\t\ts = parts[len(parts)-1]\n\n\t\t// check if s is empty, if so get one part before, repeat until not empty\n\t\tfor s == \"\" {\n\t\t\tparts = parts[:len(parts)-1]\n\t\t\ts = parts[len(parts)-1]\n\t\t}\n\n\t\ts = strings.Trim(s, \"\\n\\r\")\n\t\tbuffer.WriteString(s)\n\t\tbuffer.WriteString(\"\\n\")\n\t}\n\treturn buffer.String()\n}\n\nfunc (p *MultiPrinter) Start() (*MultiPrinter, error) {\n\tp.IsActive = true\n\tfor _, printer := range p.printers {\n\t\tprinter.GenericStart()\n\t}\n\n\tschedule.Every(p.UpdateDelay, func() bool {\n\t\tif !p.IsActive {\n\t\t\treturn false\n\t\t}\n\n\t\tp.area.Update(p.getString())\n\n\t\treturn true\n\t})\n\n\treturn p, nil\n}\n\nfunc (p *MultiPrinter) Stop() (*MultiPrinter, error) {\n\tp.IsActive = false\n\tfor _, printer := range p.printers {\n\t\tprinter.GenericStop()\n\t}\n\ttime.Sleep(time.Millisecond * 20)\n\tp.area.Update(p.getString())\n\tp.area.Stop()\n\n\treturn p, nil\n}\n\n// GenericStart runs Start, but returns a LivePrinter.\n// This is used for the interface LivePrinter.\n// You most likely want to use Start instead of this in your program.\nfunc (p MultiPrinter) GenericStart() (*LivePrinter, error) {\n\tp2, _ := p.Start()\n\tlp := LivePrinter(p2)\n\treturn &lp, nil\n}\n\n// GenericStop runs Stop, but returns a LivePrinter.\n// This is used for the interface LivePrinter.\n// You most likely want to use Stop instead of this in your program.\nfunc (p MultiPrinter) GenericStop() (*LivePrinter, error) {\n\tp2, _ := p.Stop()\n\tlp := LivePrinter(p2)\n\treturn &lp, nil\n}\n"
        },
        {
          "name": "panel_printer.go",
          "type": "blob",
          "size": 4.3408203125,
          "content": "package pterm\n\nimport (\n\t\"io\"\n\t\"strings\"\n\n\t\"github.com/mattn/go-runewidth\"\n\n\t\"github.com/pterm/pterm/internal\"\n)\n\n// Panel contains the data, which should be printed inside a PanelPrinter.\ntype Panel struct {\n\tData string\n}\n\n// Panels is a two dimensional coordinate system for Panel.\ntype Panels [][]Panel\n\n// DefaultPanel is the default PanelPrinter.\nvar DefaultPanel = PanelPrinter{\n\tPadding: 1,\n}\n\n// PanelPrinter prints content in boxes.\ntype PanelPrinter struct {\n\tPanels          Panels\n\tPadding         int\n\tBottomPadding   int\n\tSameColumnWidth bool\n\tBoxPrinter      BoxPrinter\n\tWriter          io.Writer\n}\n\n// WithPanels returns a new PanelPrinter with specific options.\nfunc (p PanelPrinter) WithPanels(panels Panels) *PanelPrinter {\n\tp.Panels = panels\n\treturn &p\n}\n\n// WithPadding returns a new PanelPrinter with specific options.\nfunc (p PanelPrinter) WithPadding(padding int) *PanelPrinter {\n\tif padding < 0 {\n\t\tpadding = 0\n\t}\n\tp.Padding = padding\n\treturn &p\n}\n\n// WithBottomPadding returns a new PanelPrinter with specific options.\nfunc (p PanelPrinter) WithBottomPadding(bottomPadding int) *PanelPrinter {\n\tif bottomPadding < 0 {\n\t\tbottomPadding = 0\n\t}\n\tp.BottomPadding = bottomPadding\n\treturn &p\n}\n\n// WithSameColumnWidth returns a new PanelPrinter with specific options.\nfunc (p PanelPrinter) WithSameColumnWidth(b ...bool) *PanelPrinter {\n\tp.SameColumnWidth = internal.WithBoolean(b)\n\treturn &p\n}\n\n// WithBoxPrinter returns a new PanelPrinter with specific options.\nfunc (p PanelPrinter) WithBoxPrinter(boxPrinter BoxPrinter) *PanelPrinter {\n\tp.BoxPrinter = boxPrinter\n\treturn &p\n}\n\n// WithWriter sets the custom Writer.\nfunc (p PanelPrinter) WithWriter(writer io.Writer) *PanelPrinter {\n\tp.Writer = writer\n\treturn &p\n}\n\nfunc (p PanelPrinter) getRawOutput() string {\n\tvar ret strings.Builder\n\tfor _, panel := range p.Panels {\n\t\tfor _, panel2 := range panel {\n\t\t\tret.WriteString(panel2.Data)\n\t\t\tret.WriteString(\"\\n\\n\")\n\t\t}\n\t\tret.WriteByte('\\n')\n\t}\n\treturn ret.String()\n}\n\n// Srender renders the Template as a string.\nfunc (p PanelPrinter) Srender() (string, error) {\n\tvar ret strings.Builder\n\n\tif RawOutput {\n\t\treturn p.getRawOutput(), nil\n\t}\n\n\tfor i := range p.Panels {\n\t\tfor i2 := range p.Panels[i] {\n\t\t\tp.Panels[i][i2].Data = strings.TrimSuffix(p.Panels[i][i2].Data, \"\\n\")\n\t\t}\n\t}\n\n\tif p.BoxPrinter != (BoxPrinter{}) {\n\t\tfor i := range p.Panels {\n\t\t\tfor i2 := range p.Panels[i] {\n\t\t\t\tp.Panels[i][i2].Data = p.BoxPrinter.Sprint(p.Panels[i][i2].Data)\n\t\t\t}\n\t\t}\n\t}\n\n\tfor i := range p.Panels {\n\t\tif len(p.Panels)-1 != i {\n\t\t\tfor i2 := range p.Panels[i] {\n\t\t\t\tp.Panels[i][i2].Data += strings.Repeat(\"\\n\", p.BottomPadding)\n\t\t\t}\n\t\t}\n\t}\n\n\tcolumnMaxHeightMap := make(map[int]int)\n\n\tif p.SameColumnWidth {\n\t\tfor _, panel := range p.Panels {\n\t\t\tfor i, p2 := range panel {\n\t\t\t\tif columnMaxHeightMap[i] < internal.GetStringMaxWidth(p2.Data) {\n\t\t\t\t\tcolumnMaxHeightMap[i] = internal.GetStringMaxWidth(p2.Data)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfor _, boxLine := range p.Panels {\n\t\tvar maxHeight int\n\n\t\tvar renderedPanels []string\n\n\t\tfor _, box := range boxLine {\n\t\t\trenderedPanels = append(renderedPanels, box.Data)\n\t\t}\n\n\t\tfor i, panel := range renderedPanels {\n\t\t\trenderedPanels[i] = strings.ReplaceAll(panel, \"\\n\", Reset.Sprint()+\"\\n\")\n\t\t}\n\n\t\tfor _, box := range renderedPanels {\n\t\t\theight := len(strings.Split(box, \"\\n\"))\n\t\t\tif height > maxHeight {\n\t\t\t\tmaxHeight = height\n\t\t\t}\n\t\t}\n\n\t\tfor i := 0; i < maxHeight; i++ {\n\t\t\tif maxHeight != i {\n\t\t\t\tfor j, letter := range renderedPanels {\n\t\t\t\t\tvar letterLine string\n\t\t\t\t\tletterLines := strings.Split(letter, \"\\n\")\n\t\t\t\t\tvar maxLetterWidth int\n\t\t\t\t\tif !p.SameColumnWidth {\n\t\t\t\t\t\tmaxLetterWidth = internal.GetStringMaxWidth(letter)\n\t\t\t\t\t}\n\t\t\t\t\tif len(letterLines) > i {\n\t\t\t\t\t\tletterLine = letterLines[i]\n\t\t\t\t\t}\n\t\t\t\t\tletterLineLength := runewidth.StringWidth(RemoveColorFromString(letterLine))\n\t\t\t\t\tif !p.SameColumnWidth {\n\t\t\t\t\t\tif letterLineLength < maxLetterWidth {\n\t\t\t\t\t\t\tletterLine += strings.Repeat(\" \", maxLetterWidth-letterLineLength)\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif letterLineLength < columnMaxHeightMap[j] {\n\t\t\t\t\t\t\tletterLine += strings.Repeat(\" \", columnMaxHeightMap[j]-letterLineLength)\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tletterLine += strings.Repeat(\" \", p.Padding)\n\t\t\t\t\tret.WriteString(letterLine)\n\t\t\t\t}\n\t\t\t\tret.WriteByte('\\n')\n\t\t\t}\n\t\t}\n\t}\n\n\treturn ret.String(), nil\n}\n\n// Render prints the Template to the terminal.\nfunc (p PanelPrinter) Render() error {\n\ts, _ := p.Srender()\n\tFprintln(p.Writer, s)\n\n\treturn nil\n}\n"
        },
        {
          "name": "panel_printer_test.go",
          "type": "blob",
          "size": 3.833984375,
          "content": "package pterm_test\n\nimport (\n\t\"io\"\n\t\"os\"\n\t\"testing\"\n\n\t\"github.com/MarvinJWendt/testza\"\n\t\"github.com/pterm/pterm\"\n)\n\nfunc TestPanelPrinterNilPrint(t *testing.T) {\n\tp := pterm.PanelPrinter{}\n\terr := p.Render()\n\ttestza.AssertNoError(t, err)\n}\n\nfunc TestPanelPrinterNilPrintWithPanels(t *testing.T) {\n\tpanels := pterm.Panels{\n\t\t{\n\t\t\t{Data: \"Hello, World\"},\n\t\t},\n\t}\n\tp := pterm.PanelPrinter{}.WithPanels(panels)\n\terr := p.Render()\n\ttestza.AssertNoError(t, err)\n}\n\nfunc TestPanelPrinter_Render(t *testing.T) {\n\ttestPrintContains(t, func(w io.Writer, a any) {\n\t\tpanels := pterm.Panels{\n\t\t\t{{Data: pterm.Sprint(a)}},\n\t\t}\n\t\tp := pterm.PanelPrinter{}.WithPanels(panels)\n\t\terr := p.Render()\n\t\ttestza.AssertNoError(t, err)\n\t})\n}\n\nfunc TestPanelPrinter_RenderMultiplePanels(t *testing.T) {\n\ttestPrintContains(t, func(w io.Writer, a any) {\n\t\tpanels := pterm.Panels{\n\t\t\t{{Data: pterm.Sprint(\"a\\nbc\\ndef\")}, {Data: pterm.Sprint(\"abcd\")}},\n\t\t\t{{Data: pterm.Sprint(a)}},\n\t\t}\n\t\tp := pterm.PanelPrinter{}.WithPanels(panels)\n\t\terr := p.Render()\n\t\ttestza.AssertNoError(t, err)\n\t})\n}\n\nfunc TestPanelPrinter_RenderMultiplePanelsWithBorder(t *testing.T) {\n\ttestPrintContains(t, func(w io.Writer, a any) {\n\t\tpanels := pterm.Panels{\n\t\t\t{{Data: pterm.Sprint(\"a\\nbc\\ndef\")}, {Data: pterm.Sprint(\"abcd\")}},\n\t\t\t{{Data: pterm.Sprint(a)}},\n\t\t}\n\t\tp := pterm.PanelPrinter{}.WithPanels(panels).WithBoxPrinter(pterm.DefaultBox)\n\t\terr := p.Render()\n\t\ttestza.AssertNoError(t, err)\n\t})\n}\n\nfunc TestPanelPrinter_RenderWithSameColumnWidth(t *testing.T) {\n\ttestPrintContains(t, func(w io.Writer, a any) {\n\t\tpanels := pterm.Panels{\n\t\t\t{{Data: pterm.Sprint(a)}},\n\t\t\t{{Data: pterm.Sprint(\"test\")}},\n\t\t\t{{Data: pterm.Sprint(\"Hello, World!\")}},\n\t\t}\n\t\tp := pterm.PanelPrinter{}.WithPanels(panels).WithSameColumnWidth()\n\t\terr := p.Render()\n\t\ttestza.AssertNoError(t, err)\n\t})\n}\n\nfunc TestPanelPrinter_RenderWithBottomPadding(t *testing.T) {\n\ttestPrintContains(t, func(w io.Writer, a any) {\n\t\tpanels := pterm.Panels{\n\t\t\t{{Data: pterm.Sprint(a)}},\n\t\t\t{{Data: pterm.Sprint(\"test\")}},\n\t\t\t{{Data: pterm.Sprint(\"Hello, World!\")}},\n\t\t}\n\t\tp := pterm.PanelPrinter{}.WithPanels(panels).WithBottomPadding(1)\n\t\terr := p.Render()\n\t\ttestza.AssertNoError(t, err)\n\t})\n}\n\nfunc TestPanelPrinter_WithPanels(t *testing.T) {\n\tpanels := pterm.Panels{\n\t\t{\n\t\t\t{Data: \"Hello, World!\"},\n\t\t},\n\t}\n\tp := pterm.PanelPrinter{}\n\tp2 := p.WithPanels(panels)\n\n\ttestza.AssertEqual(t, panels, p2.Panels)\n\ttestza.AssertZero(t, p.Panels)\n}\n\nfunc TestPanelPrinter_WithPadding(t *testing.T) {\n\tpadding := 1337\n\tp := pterm.PanelPrinter{}\n\tp2 := p.WithPadding(padding)\n\n\ttestza.AssertEqual(t, padding, p2.Padding)\n\ttestza.AssertZero(t, p.Padding)\n}\n\nfunc TestPanelPrinter_WithInvalidPadding(t *testing.T) {\n\tpadding := -5\n\tp := pterm.PanelPrinter{}\n\tp2 := p.WithPadding(padding)\n\n\ttestza.AssertEqual(t, 0, p2.Padding)\n\ttestza.AssertZero(t, p.Padding)\n}\n\nfunc TestPanelPrinter_WithBottomPadding(t *testing.T) {\n\tpadding := 1337\n\tp := pterm.PanelPrinter{}\n\tp2 := p.WithBottomPadding(padding)\n\n\ttestza.AssertEqual(t, padding, p2.BottomPadding)\n\ttestza.AssertZero(t, p.BottomPadding)\n}\n\nfunc TestPanelPrinter_WithInvalidBottomPadding(t *testing.T) {\n\tpadding := -5\n\tp := pterm.PanelPrinter{}\n\tp2 := p.WithBottomPadding(padding)\n\n\ttestza.AssertEqual(t, 0, p2.BottomPadding)\n\ttestza.AssertZero(t, p.BottomPadding)\n}\n\nfunc TestPanelPrinter_WithSameColumnWidth(t *testing.T) {\n\tp := pterm.PanelPrinter{}\n\tp2 := p.WithSameColumnWidth()\n\n\ttestza.AssertTrue(t, p2.SameColumnWidth)\n\ttestza.AssertFalse(t, p.SameColumnWidth)\n}\n\nfunc TestPanelPrinter_WithBoxPrinter(t *testing.T) {\n\tp := pterm.PanelPrinter{}\n\tp2 := p.WithBoxPrinter(pterm.DefaultBox)\n\n\ttestza.AssertEqual(t, pterm.DefaultBox, p2.BoxPrinter)\n\ttestza.AssertZero(t, p.BoxPrinter)\n}\n\nfunc TestPanelPrinter_WithWriter(t *testing.T) {\n\tp := pterm.PanelPrinter{}\n\ts := os.Stderr\n\tp2 := p.WithWriter(s)\n\n\ttestza.AssertEqual(t, s, p2.Writer)\n\ttestza.AssertZero(t, p.Writer)\n}\n"
        },
        {
          "name": "paragraph_printer.go",
          "type": "blob",
          "size": 4.2109375,
          "content": "package pterm\n\nimport (\n\t\"fmt\"\n\t\"io\"\n\t\"strings\"\n)\n\n// DefaultParagraph contains the default values for a ParagraphPrinter.\nvar DefaultParagraph = ParagraphPrinter{\n\tMaxWidth: GetTerminalWidth(),\n}\n\n// ParagraphPrinter can print paragraphs to a fixed line width.\n// The text will split between words, so that words will stick together.\n// It's like in a book.\ntype ParagraphPrinter struct {\n\tMaxWidth int\n\tWriter   io.Writer\n}\n\n// WithMaxWidth returns a new ParagraphPrinter with a specific MaxWidth\nfunc (p ParagraphPrinter) WithMaxWidth(width int) *ParagraphPrinter {\n\tp.MaxWidth = width\n\treturn &p\n}\n\n// WithWriter sets the custom Writer.\nfunc (p ParagraphPrinter) WithWriter(writer io.Writer) *ParagraphPrinter {\n\tp.Writer = writer\n\treturn &p\n}\n\n// Sprint formats using the default formats for its operands and returns the resulting string.\n// Spaces are added between operands when neither is a string.\nfunc (p ParagraphPrinter) Sprint(a ...any) string {\n\tif RawOutput {\n\t\treturn Sprint(a...)\n\t}\n\n\twords := strings.Fields(strings.TrimSpace(Sprint(a...)))\n\tif len(words) == 0 {\n\t\treturn \"\"\n\t}\n\twrapped := words[0]\n\tspaceLeft := p.MaxWidth - len(wrapped)\n\tfor _, word := range words[1:] {\n\t\tif len(word)+1 > spaceLeft {\n\t\t\twrapped += \"\\n\" + word\n\t\t\tspaceLeft = p.MaxWidth - len(word)\n\t\t} else {\n\t\t\twrapped += \" \" + word\n\t\t\tspaceLeft -= 1 + len(word)\n\t\t}\n\t}\n\n\treturn wrapped\n}\n\n// Sprintln formats using the default formats for its operands and returns the resulting string.\n// Spaces are always added between operands and a newline is appended.\nfunc (p ParagraphPrinter) Sprintln(a ...any) string {\n\treturn p.Sprint(Sprintln(a...)) + \"\\n\"\n}\n\n// Sprintf formats according to a format specifier and returns the resulting string.\nfunc (p ParagraphPrinter) Sprintf(format string, a ...any) string {\n\treturn p.Sprint(Sprintf(format, a...))\n}\n\n// Sprintfln formats according to a format specifier and returns the resulting string.\n// Spaces are always added between operands and a newline is appended.\nfunc (p ParagraphPrinter) Sprintfln(format string, a ...any) string {\n\treturn p.Sprintf(format, a...) + \"\\n\"\n}\n\n// Print formats using the default formats for its operands and writes to standard output.\n// Spaces are added between operands when neither is a string.\n// It returns the number of bytes written and any write error encountered.\nfunc (p *ParagraphPrinter) Print(a ...any) *TextPrinter {\n\tFprint(p.Writer, p.Sprint(a...))\n\ttp := TextPrinter(p)\n\treturn &tp\n}\n\n// Println formats using the default formats for its operands and writes to standard output.\n// Spaces are always added between operands and a newline is appended.\n// It returns the number of bytes written and any write error encountered.\nfunc (p *ParagraphPrinter) Println(a ...any) *TextPrinter {\n\tFprint(p.Writer, p.Sprintln(a...))\n\ttp := TextPrinter(p)\n\treturn &tp\n}\n\n// Printf formats according to a format specifier and writes to standard output.\n// It returns the number of bytes written and any write error encountered.\nfunc (p *ParagraphPrinter) Printf(format string, a ...any) *TextPrinter {\n\tFprint(p.Writer, p.Sprintf(format, a...))\n\ttp := TextPrinter(p)\n\treturn &tp\n}\n\n// Printfln formats according to a format specifier and writes to standard output.\n// Spaces are always added between operands and a newline is appended.\n// It returns the number of bytes written and any write error encountered.\nfunc (p *ParagraphPrinter) Printfln(format string, a ...any) *TextPrinter {\n\tFprint(p.Writer, p.Sprintfln(format, a...))\n\ttp := TextPrinter(p)\n\treturn &tp\n}\n\n// PrintOnError prints every error which is not nil.\n// If every error is nil, nothing will be printed.\n// This can be used for simple error checking.\nfunc (p *ParagraphPrinter) PrintOnError(a ...any) *TextPrinter {\n\tfor _, arg := range a {\n\t\tif err, ok := arg.(error); ok {\n\t\t\tif err != nil {\n\t\t\t\tp.Println(err)\n\t\t\t}\n\t\t}\n\t}\n\n\ttp := TextPrinter(p)\n\treturn &tp\n}\n\n// PrintOnErrorf wraps every error which is not nil and prints it.\n// If every error is nil, nothing will be printed.\n// This can be used for simple error checking.\nfunc (p *ParagraphPrinter) PrintOnErrorf(format string, a ...any) *TextPrinter {\n\tfor _, arg := range a {\n\t\tif err, ok := arg.(error); ok {\n\t\t\tif err != nil {\n\t\t\t\tp.Println(fmt.Errorf(format, err))\n\t\t\t}\n\t\t}\n\t}\n\n\ttp := TextPrinter(p)\n\treturn &tp\n}\n"
        },
        {
          "name": "paragraph_printer_test.go",
          "type": "blob",
          "size": 2.802734375,
          "content": "package pterm_test\n\nimport (\n\t\"errors\"\n\t\"io\"\n\t\"os\"\n\t\"testing\"\n\n\t\"github.com/MarvinJWendt/testza\"\n\n\t\"github.com/pterm/pterm\"\n)\n\nfunc TestParagraphPrinterNilPrint(t *testing.T) {\n\tp := pterm.ParagraphPrinter{}\n\tp.Println(\"Hello, World!\")\n}\n\nfunc TestParagraphPrinterPrintMethods(t *testing.T) {\n\tp := pterm.DefaultParagraph\n\n\tt.Run(\"Print\", func(t *testing.T) {\n\t\ttestPrintContains(t, func(w io.Writer, a any) {\n\t\t\tp.Print(a)\n\t\t})\n\t})\n\n\tt.Run(\"PrintWithLongText\", func(t *testing.T) {\n\t\tproxyToDevNull()\n\t\ttestza.AssertNotZero(t, p.Print(\"This is a longer text to test the paragraph printer. I don't know when this text will be long enough so I will just write until I get the feeling that it's enough. Maybe about now.\"))\n\t})\n\n\tt.Run(\"PrintWithoutText\", func(t *testing.T) {\n\t\tproxyToDevNull()\n\t\ttestza.AssertNotZero(t, p.Print(\"\"))\n\t})\n\n\tt.Run(\"Printf\", func(t *testing.T) {\n\t\ttestPrintfContains(t, func(w io.Writer, format string, a any) {\n\t\t\tp.Printf(format, a)\n\t\t})\n\t})\n\n\tt.Run(\"Printfln\", func(t *testing.T) {\n\t\ttestPrintflnContains(t, func(w io.Writer, format string, a any) {\n\t\t\tp.Printfln(format, a)\n\t\t})\n\t})\n\n\tt.Run(\"Println\", func(t *testing.T) {\n\t\ttestPrintlnContains(t, func(w io.Writer, a any) {\n\t\t\tp.Println(a)\n\t\t})\n\t})\n\n\tt.Run(\"Sprint\", func(t *testing.T) {\n\t\ttestSprintContains(t, func(a any) string {\n\t\t\treturn p.Sprint(a)\n\t\t})\n\t})\n\n\tt.Run(\"Sprintf\", func(t *testing.T) {\n\t\ttestSprintfContains(t, func(format string, a any) string {\n\t\t\treturn p.Sprintf(format, a)\n\t\t})\n\t})\n\n\tt.Run(\"Sprintfln\", func(t *testing.T) {\n\t\ttestSprintflnContains(t, func(format string, a any) string {\n\t\t\treturn p.Sprintfln(format, a)\n\t\t})\n\t})\n\n\tt.Run(\"Sprintln\", func(t *testing.T) {\n\t\ttestSprintlnContains(t, func(a any) string {\n\t\t\treturn p.Sprintln(a)\n\t\t})\n\t})\n\n\tt.Run(\"PrintOnError\", func(t *testing.T) {\n\t\tresult := captureStdout(func(w io.Writer) {\n\t\t\tp.PrintOnError(errors.New(\"hello world\"))\n\t\t})\n\t\ttestza.AssertContains(t, result, \"hello world\")\n\t})\n\n\tt.Run(\"PrintIfError_WithoutError\", func(t *testing.T) {\n\t\tresult := captureStdout(func(w io.Writer) {\n\t\t\tp.PrintOnError(nil)\n\t\t})\n\t\ttestza.AssertZero(t, result)\n\t})\n\n\tt.Run(\"PrintOnErrorf\", func(t *testing.T) {\n\t\tresult := captureStdout(func(w io.Writer) {\n\t\t\tp.PrintOnErrorf(\"wrapping error : %w\", errors.New(\"hello world\"))\n\t\t})\n\t\ttestza.AssertContains(t, result, \"hello world\")\n\t})\n\n\tt.Run(\"PrintIfError_WithoutErrorf\", func(t *testing.T) {\n\t\tresult := captureStdout(func(w io.Writer) {\n\t\t\tp.PrintOnErrorf(\"\", nil)\n\t\t})\n\t\ttestza.AssertZero(t, result)\n\t})\n}\n\nfunc TestParagraphPrinter_WithMaxWidth(t *testing.T) {\n\tp := pterm.ParagraphPrinter{}\n\tp2 := p.WithMaxWidth(1337)\n\n\ttestza.AssertEqual(t, 1337, p2.MaxWidth)\n}\n\nfunc TestParagraphPrinter_WithWriter(t *testing.T) {\n\tp := pterm.ParagraphPrinter{}\n\ts := os.Stderr\n\tp2 := p.WithWriter(s)\n\n\ttestza.AssertEqual(t, s, p2.Writer)\n\ttestza.AssertZero(t, p.Writer)\n}\n"
        },
        {
          "name": "prefix_printer.go",
          "type": "blob",
          "size": 10.2080078125,
          "content": "package pterm\n\nimport (\n\t\"fmt\"\n\t\"io\"\n\t\"runtime\"\n\t\"strings\"\n\n\t\"github.com/pterm/pterm/internal\"\n)\n\nvar (\n\t// GrayBoxStyle wraps text in a gray box.\n\tGrayBoxStyle = NewStyle(BgGray, FgLightWhite)\n)\n\nvar (\n\t// Info returns a PrefixPrinter, which can be used to print text with an \"info\" Prefix.\n\tInfo = PrefixPrinter{\n\t\tMessageStyle: &ThemeDefault.InfoMessageStyle,\n\t\tPrefix: Prefix{\n\t\t\tStyle: &ThemeDefault.InfoPrefixStyle,\n\t\t\tText:  \"INFO\",\n\t\t},\n\t\tWriter: defaultWriter,\n\t}\n\n\t// Warning returns a PrefixPrinter, which can be used to print text with a \"warning\" Prefix.\n\tWarning = PrefixPrinter{\n\t\tMessageStyle: &ThemeDefault.WarningMessageStyle,\n\t\tPrefix: Prefix{\n\t\t\tStyle: &ThemeDefault.WarningPrefixStyle,\n\t\t\tText:  \"WARNING\",\n\t\t},\n\t\tWriter: defaultWriter,\n\t}\n\n\t// Success returns a PrefixPrinter, which can be used to print text with a \"success\" Prefix.\n\tSuccess = PrefixPrinter{\n\t\tMessageStyle: &ThemeDefault.SuccessMessageStyle,\n\t\tPrefix: Prefix{\n\t\t\tStyle: &ThemeDefault.SuccessPrefixStyle,\n\t\t\tText:  \"SUCCESS\",\n\t\t},\n\t\tWriter: defaultWriter,\n\t}\n\n\t// Error returns a PrefixPrinter, which can be used to print text with an \"error\" Prefix.\n\tError = PrefixPrinter{\n\t\tMessageStyle: &ThemeDefault.ErrorMessageStyle,\n\t\tPrefix: Prefix{\n\t\t\tStyle: &ThemeDefault.ErrorPrefixStyle,\n\t\t\tText:  \" ERROR \",\n\t\t},\n\t\tWriter: defaultWriter,\n\t}\n\n\t// Fatal returns a PrefixPrinter, which can be used to print text with an \"fatal\" Prefix.\n\t// NOTICE: Fatal terminates the application immediately!\n\tFatal = PrefixPrinter{\n\t\tMessageStyle: &ThemeDefault.FatalMessageStyle,\n\t\tPrefix: Prefix{\n\t\t\tStyle: &ThemeDefault.FatalPrefixStyle,\n\t\t\tText:  \" FATAL \",\n\t\t},\n\t\tFatal:  true,\n\t\tWriter: defaultWriter,\n\t}\n\n\t// Debug Prints debug messages. By default it will only print if PrintDebugMessages is true.\n\t// You can change PrintDebugMessages with EnableDebugMessages and DisableDebugMessages, or by setting the variable itself.\n\tDebug = PrefixPrinter{\n\t\tMessageStyle: &ThemeDefault.DebugMessageStyle,\n\t\tPrefix: Prefix{\n\t\t\tText:  \" DEBUG \",\n\t\t\tStyle: &ThemeDefault.DebugPrefixStyle,\n\t\t},\n\t\tDebugger: true,\n\t\tWriter:   defaultWriter,\n\t}\n\n\t// Description returns a PrefixPrinter, which can be used to print text with a \"description\" Prefix.\n\tDescription = PrefixPrinter{\n\t\tMessageStyle: &ThemeDefault.DescriptionMessageStyle,\n\t\tPrefix: Prefix{\n\t\t\tStyle: &ThemeDefault.DescriptionPrefixStyle,\n\t\t\tText:  \"Description\",\n\t\t},\n\t\tWriter: defaultWriter,\n\t}\n)\n\n// PrefixPrinter is the printer used to print a Prefix.\ntype PrefixPrinter struct {\n\tPrefix           Prefix\n\tScope            Scope\n\tMessageStyle     *Style\n\tFatal            bool\n\tShowLineNumber   bool\n\tLineNumberOffset int\n\tWriter           io.Writer\n\t// If Debugger is true, the printer will only print if PrintDebugMessages is set to true.\n\t// You can change PrintDebugMessages with EnableDebugMessages and DisableDebugMessages, or by setting the variable itself.\n\tDebugger bool\n}\n\n// WithPrefix adds a custom prefix to the printer.\nfunc (p PrefixPrinter) WithPrefix(prefix Prefix) *PrefixPrinter {\n\tp.Prefix = prefix\n\treturn &p\n}\n\n// WithScope adds a scope to the Prefix.\nfunc (p PrefixPrinter) WithScope(scope Scope) *PrefixPrinter {\n\tp.Scope = scope\n\treturn &p\n}\n\n// WithMessageStyle adds a custom prefix to the printer.\nfunc (p PrefixPrinter) WithMessageStyle(style *Style) *PrefixPrinter {\n\tp.MessageStyle = style\n\treturn &p\n}\n\n// WithFatal sets if the printer should panic after printing.\n// NOTE:\n// The printer will only panic if either PrefixPrinter.Println, PrefixPrinter.Print\n// or PrefixPrinter.Printf is called.\nfunc (p PrefixPrinter) WithFatal(b ...bool) *PrefixPrinter {\n\tp.Fatal = internal.WithBoolean(b)\n\treturn &p\n}\n\n// WithShowLineNumber sets if the printer should print the line number from where it's called in a go file.\nfunc (p PrefixPrinter) WithShowLineNumber(b ...bool) *PrefixPrinter {\n\tp.ShowLineNumber = internal.WithBoolean(b)\n\treturn &p\n}\n\n// WithDebugger returns a new Printer with specific Debugger value.\n// If Debugger is true, the printer will only print if PrintDebugMessages is set to true.\n// You can change PrintDebugMessages with EnableDebugMessages and DisableDebugMessages, or by setting the variable itself.\nfunc (p PrefixPrinter) WithDebugger(b ...bool) *PrefixPrinter {\n\tp.Debugger = internal.WithBoolean(b)\n\treturn &p\n}\n\n// WithLineNumberOffset can be used to exclude a specific amount of calls in the call stack.\n// If you make a wrapper function for example, you can set this to one.\n// The printed line number will then be the line number where your wrapper function is called.\nfunc (p PrefixPrinter) WithLineNumberOffset(offset int) *PrefixPrinter {\n\tp.LineNumberOffset = offset\n\treturn &p\n}\n\n// WithWriter sets the custom Writer.\nfunc (p PrefixPrinter) WithWriter(writer io.Writer) *PrefixPrinter {\n\tp.Writer = writer\n\treturn &p\n}\n\n// Sprint formats using the default formats for its operands and returns the resulting string.\n// Spaces are added between operands when neither is a string.\nfunc (p *PrefixPrinter) Sprint(a ...any) string {\n\tm := Sprint(a...)\n\tif p.Debugger && !PrintDebugMessages {\n\t\treturn \"\"\n\t}\n\n\tif RawOutput {\n\t\tif p.Prefix.Text != \"\" {\n\t\t\treturn Sprintf(\"%s: %s\", strings.TrimSpace(p.Prefix.Text), Sprint(a...))\n\t\t} else {\n\t\t\treturn Sprint(a...)\n\t\t}\n\t}\n\n\tif p.Prefix.Style == nil {\n\t\tp.Prefix.Style = NewStyle()\n\t}\n\tif p.Scope.Style == nil {\n\t\tp.Scope.Style = NewStyle()\n\t}\n\tif p.MessageStyle == nil {\n\t\tp.MessageStyle = NewStyle()\n\t}\n\n\tvar ret strings.Builder\n\tvar newLine bool\n\n\tif strings.HasSuffix(m, \"\\n\") {\n\t\tm = strings.TrimRight(m, \"\\n\")\n\t\tnewLine = true\n\t}\n\n\tmessageLines := strings.Split(m, \"\\n\")\n\tfor i, m := range messageLines {\n\t\tif i == 0 {\n\t\t\tret.WriteString(p.GetFormattedPrefix())\n\t\t\tret.WriteByte(' ')\n\t\t\tif p.Scope.Text != \"\" {\n\t\t\t\tret.WriteString(NewStyle(*p.Scope.Style...).Sprint(\" (\" + p.Scope.Text + \") \"))\n\t\t\t}\n\t\t\tret.WriteString(p.MessageStyle.Sprint(m))\n\t\t} else {\n\t\t\tret.WriteByte('\\n')\n\t\t\tret.WriteString(p.Prefix.Style.Sprint(strings.Repeat(\" \", len([]rune(p.Prefix.Text))+2)))\n\t\t\tret.WriteByte(' ')\n\t\t\tret.WriteString(p.MessageStyle.Sprint(m))\n\t\t}\n\t}\n\n\tif p.ShowLineNumber {\n\t\t_, fileName, line, _ := runtime.Caller(3 + p.LineNumberOffset)\n\t\tret.WriteString(FgGray.Sprint(\"\\n└ \" + fmt.Sprintf(\"(%s:%d)\\n\", fileName, line)))\n\t\tnewLine = false\n\t}\n\n\tif newLine {\n\t\tret.WriteByte('\\n')\n\t}\n\n\treturn Sprint(ret.String())\n}\n\n// Sprintln formats using the default formats for its operands and returns the resulting string.\n// Spaces are always added between operands and a newline is appended.\nfunc (p PrefixPrinter) Sprintln(a ...any) string {\n\tif p.Debugger && !PrintDebugMessages {\n\t\treturn \"\"\n\t}\n\tstr := fmt.Sprintln(a...)\n\treturn p.Sprint(str)\n}\n\n// Sprintf formats according to a format specifier and returns the resulting string.\nfunc (p PrefixPrinter) Sprintf(format string, a ...any) string {\n\tif p.Debugger && !PrintDebugMessages {\n\t\treturn \"\"\n\t}\n\treturn p.Sprint(Sprintf(format, a...))\n}\n\n// Sprintfln formats according to a format specifier and returns the resulting string.\n// Spaces are always added between operands and a newline is appended.\nfunc (p PrefixPrinter) Sprintfln(format string, a ...any) string {\n\tif p.Debugger && !PrintDebugMessages {\n\t\treturn \"\"\n\t}\n\treturn p.Sprintf(format, a...) + \"\\n\"\n}\n\n// Print formats using the default formats for its operands and writes to standard output.\n// Spaces are added between operands when neither is a string.\n// It returns the number of bytes written and any write error encountered.\nfunc (p *PrefixPrinter) Print(a ...any) *TextPrinter {\n\ttp := TextPrinter(p)\n\tif p.Debugger && !PrintDebugMessages {\n\t\treturn &tp\n\t}\n\tp.LineNumberOffset--\n\tFprint(p.Writer, p.Sprint(a...))\n\tp.LineNumberOffset++\n\tcheckFatal(p)\n\treturn &tp\n}\n\n// Println formats using the default formats for its operands and writes to standard output.\n// Spaces are always added between operands and a newline is appended.\n// It returns the number of bytes written and any write error encountered.\nfunc (p *PrefixPrinter) Println(a ...any) *TextPrinter {\n\ttp := TextPrinter(p)\n\tif p.Debugger && !PrintDebugMessages {\n\t\treturn &tp\n\t}\n\tFprint(p.Writer, p.Sprintln(a...))\n\tcheckFatal(p)\n\treturn &tp\n}\n\n// Printf formats according to a format specifier and writes to standard output.\n// It returns the number of bytes written and any write error encountered.\nfunc (p *PrefixPrinter) Printf(format string, a ...any) *TextPrinter {\n\ttp := TextPrinter(p)\n\tif p.Debugger && !PrintDebugMessages {\n\t\treturn &tp\n\t}\n\tFprint(p.Writer, p.Sprintf(format, a...))\n\tcheckFatal(p)\n\treturn &tp\n}\n\n// Printfln formats according to a format specifier and writes to standard output.\n// Spaces are always added between operands and a newline is appended.\n// It returns the number of bytes written and any write error encountered.\nfunc (p *PrefixPrinter) Printfln(format string, a ...any) *TextPrinter {\n\ttp := TextPrinter(p)\n\tif p.Debugger && !PrintDebugMessages {\n\t\treturn &tp\n\t}\n\tp.LineNumberOffset++\n\tFprint(p.Writer, p.Sprintfln(format, a...))\n\tp.LineNumberOffset--\n\tcheckFatal(p)\n\treturn &tp\n}\n\n// PrintOnError prints every error which is not nil.\n// If every error is nil, nothing will be printed.\n// This can be used for simple error checking.\n//\n// Note: Use WithFatal(true) or Fatal to panic after first non nil error.\nfunc (p *PrefixPrinter) PrintOnError(a ...any) *TextPrinter {\n\tfor _, arg := range a {\n\t\tif err, ok := arg.(error); ok {\n\t\t\tif err != nil {\n\t\t\t\tp.Println(err)\n\t\t\t}\n\t\t}\n\t}\n\n\ttp := TextPrinter(p)\n\treturn &tp\n}\n\n// PrintOnErrorf wraps every error which is not nil and prints it.\n// If every error is nil, nothing will be printed.\n// This can be used for simple error checking.\nfunc (p *PrefixPrinter) PrintOnErrorf(format string, a ...any) *TextPrinter {\n\tfor _, arg := range a {\n\t\tif err, ok := arg.(error); ok {\n\t\t\tif err != nil {\n\t\t\t\tp.Println(fmt.Errorf(format, err))\n\t\t\t}\n\t\t}\n\t}\n\n\ttp := TextPrinter(p)\n\treturn &tp\n}\n\n// GetFormattedPrefix returns the Prefix as a styled text string.\nfunc (p PrefixPrinter) GetFormattedPrefix() string {\n\treturn p.Prefix.Style.Sprint(\" \" + p.Prefix.Text + \" \")\n}\n\n// Prefix contains the data used as the beginning of a printed text via a PrefixPrinter.\ntype Prefix struct {\n\tText  string\n\tStyle *Style\n}\n\n// Scope contains the data of the optional scope of a prefix.\n// If it has a text, it will be printed after the Prefix in brackets.\ntype Scope struct {\n\tText  string\n\tStyle *Style\n}\n\nfunc checkFatal(p *PrefixPrinter) {\n\tif p.Fatal {\n\t\tpanic(\"\")\n\t}\n}\n"
        },
        {
          "name": "prefix_printer_test.go",
          "type": "blob",
          "size": 9.7685546875,
          "content": "package pterm_test\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"os\"\n\t\"testing\"\n\n\t\"github.com/MarvinJWendt/testza\"\n\n\t\"github.com/pterm/pterm\"\n)\n\nvar prefixPrinters = []pterm.PrefixPrinter{pterm.Info, pterm.Success, pterm.Warning, pterm.Error, *pterm.Fatal.WithFatal(false)}\n\nfunc TestPrefixPrinterNilPrint(t *testing.T) {\n\tproxyToDevNull()\n\tp := pterm.PrefixPrinter{}\n\tp.Println(\"Hello, World!\")\n}\n\nfunc TestPrefixPrinterPrintMethods(t *testing.T) {\n\tfor _, p := range prefixPrinters {\n\t\tt.Run(\"Print\", func(t *testing.T) {\n\t\t\ttestPrintContains(t, func(w io.Writer, a any) {\n\t\t\t\tp.WithWriter(w).Print(a)\n\t\t\t})\n\t\t})\n\n\t\tt.Run(\"PrintWithScope\", func(t *testing.T) {\n\t\t\ttestPrintContains(t, func(w io.Writer, a any) {\n\t\t\t\tp2 := p.WithScope(pterm.Scope{\n\t\t\t\t\tText:  \"test\",\n\t\t\t\t\tStyle: pterm.NewStyle(pterm.FgRed, pterm.BgBlue, pterm.Bold),\n\t\t\t\t})\n\t\t\t\tp2.WithWriter(w).Print(a)\n\t\t\t})\n\t\t})\n\n\t\tt.Run(\"PrintWithShowLineNumber\", func(t *testing.T) {\n\t\t\ttestPrintContains(t, func(w io.Writer, a any) {\n\t\t\t\tp2 := p.WithShowLineNumber().WithWriter(w)\n\t\t\t\tp2.Print(a)\n\t\t\t})\n\t\t})\n\n\t\tt.Run(\"PrintWithMultipleLines\", func(t *testing.T) {\n\t\t\tp2 := p.WithScope(pterm.Scope{\n\t\t\t\tText:  \"test\",\n\t\t\t\tStyle: pterm.NewStyle(pterm.FgRed, pterm.BgBlue, pterm.Bold),\n\t\t\t})\n\t\t\tp2.Print(\"This text\\nhas\\nmultiple\\nlines\")\n\t\t})\n\n\t\tt.Run(\"Printf\", func(t *testing.T) {\n\t\t\ttestPrintfContains(t, func(w io.Writer, format string, a any) {\n\t\t\t\tp.WithWriter(w).Printf(format, a)\n\t\t\t})\n\t\t})\n\n\t\tt.Run(\"Printfln\", func(t *testing.T) {\n\t\t\ttestPrintflnContains(t, func(w io.Writer, format string, a any) {\n\t\t\t\tp.WithWriter(w).Printfln(format, a)\n\t\t\t})\n\t\t})\n\n\t\tt.Run(\"Println\", func(t *testing.T) {\n\t\t\ttestPrintlnContains(t, func(w io.Writer, a any) {\n\t\t\t\tp.WithWriter(w).Println(a)\n\t\t\t})\n\t\t})\n\n\t\tt.Run(\"Sprint\", func(t *testing.T) {\n\t\t\ttestSprintContains(t, func(a any) string {\n\t\t\t\treturn p.Sprint(a)\n\t\t\t})\n\t\t})\n\n\t\tt.Run(\"Sprintf\", func(t *testing.T) {\n\t\t\ttestSprintfContains(t, func(format string, a any) string {\n\t\t\t\treturn p.Sprintf(format, a)\n\t\t\t})\n\t\t})\n\n\t\tt.Run(\"Sprintfln\", func(t *testing.T) {\n\t\t\ttestSprintflnContains(t, func(format string, a any) string {\n\t\t\t\treturn p.Sprintfln(format, a)\n\t\t\t})\n\t\t})\n\n\t\tt.Run(\"Sprintln\", func(t *testing.T) {\n\t\t\ttestSprintlnContains(t, func(a any) string {\n\t\t\t\treturn p.Sprintln(a)\n\t\t\t})\n\t\t})\n\n\t\tt.Run(\"PrintOnError\", func(t *testing.T) {\n\t\t\tresult := captureStdout(func(w io.Writer) {\n\t\t\t\tp.WithWriter(w).PrintOnError(errors.New(\"hello world\"))\n\t\t\t})\n\t\t\ttestza.AssertContains(t, result, \"hello world\")\n\t\t})\n\n\t\tt.Run(\"PrintIfError_WithoutError\", func(t *testing.T) {\n\t\t\tresult := captureStdout(func(w io.Writer) {\n\t\t\t\tp.WithWriter(w).PrintOnError(nil)\n\t\t\t})\n\t\t\ttestza.AssertZero(t, result)\n\t\t})\n\n\t\tt.Run(\"PrintOnErrorf\", func(t *testing.T) {\n\t\t\tresult := captureStdout(func(w io.Writer) {\n\t\t\t\tp.WithWriter(w).PrintOnErrorf(\"wrapping error : %w\", errors.New(\"hello world\"))\n\t\t\t})\n\t\t\ttestza.AssertContains(t, result, \"hello world\")\n\t\t})\n\n\t\tt.Run(\"PrintIfError_WithoutErrorf\", func(t *testing.T) {\n\t\t\tresult := captureStdout(func(w io.Writer) {\n\t\t\t\tp.WithWriter(w).PrintOnErrorf(\"\", nil)\n\t\t\t})\n\t\t\ttestza.AssertZero(t, result)\n\t\t})\n\t}\n}\n\nfunc TestPrefixPrinterWithoutPrefix(t *testing.T) {\n\tpterm.DisableStyling()\n\tfor _, p := range prefixPrinters {\n\t\tp2 := p.WithPrefix(pterm.Prefix{})\n\t\tt.Run(\"\", func(t *testing.T) {\n\t\t\tfor _, printable := range printables {\n\t\t\t\tret := captureStdout(func(w io.Writer) {\n\t\t\t\t\tp2.WithWriter(w).Print(printable)\n\t\t\t\t})\n\t\t\t\ttestza.AssertEqual(t, ret, fmt.Sprint(printable))\n\t\t\t}\n\t\t})\n\t}\n\tpterm.EnableStyling()\n}\n\nfunc TestSprintfWithNewLineEnding(t *testing.T) {\n\tfor _, p := range prefixPrinters {\n\t\tt.Run(\"\", func(t *testing.T) {\n\t\t\ttestza.AssertNotContains(t, \"\\n\\n\", p.Sprintf(\"%s\\n\\n\\n\\n\", \"Hello, World!\"))\n\t\t})\n\t}\n}\n\nfunc TestPrefixPrinter_GetFormattedPrefix(t *testing.T) {\n\tfor _, p := range prefixPrinters {\n\t\tt.Run(\"\", func(t *testing.T) {\n\t\t\ttestza.AssertNotZero(t, p.GetFormattedPrefix())\n\t\t})\n\t}\n}\n\nfunc TestPrefixPrinter_WithFatal(t *testing.T) {\n\tfor _, p := range prefixPrinters {\n\t\tt.Run(\"\", func(t *testing.T) {\n\t\t\tp2 := p.WithFatal()\n\n\t\t\ttestza.AssertEqual(t, true, p2.Fatal)\n\t\t})\n\t}\n}\n\nfunc TestPrefixPrinter_WithShowLineNumber(t *testing.T) {\n\tfor _, p := range prefixPrinters {\n\t\tt.Run(\"\", func(t *testing.T) {\n\t\t\tp2 := p.WithShowLineNumber()\n\n\t\t\ttestza.AssertEqual(t, true, p2.ShowLineNumber)\n\t\t})\n\t}\n}\n\nfunc TestPrefixPrinter_WithMessageStyle(t *testing.T) {\n\tfor _, p := range prefixPrinters {\n\t\tt.Run(\"\", func(t *testing.T) {\n\t\t\ts := pterm.NewStyle(pterm.FgRed, pterm.BgBlue, pterm.Bold)\n\t\t\tp2 := p.WithMessageStyle(s)\n\n\t\t\ttestza.AssertEqual(t, s, p2.MessageStyle)\n\t\t})\n\t}\n}\n\nfunc TestPrefixPrinter_WithPrefix(t *testing.T) {\n\tfor _, p := range prefixPrinters {\n\t\tt.Run(\"\", func(t *testing.T) {\n\t\t\ts := pterm.Prefix{\n\t\t\t\tText:  \"test\",\n\t\t\t\tStyle: pterm.NewStyle(pterm.FgRed, pterm.BgBlue, pterm.Bold),\n\t\t\t}\n\t\t\tp2 := p.WithPrefix(s)\n\n\t\t\ttestza.AssertEqual(t, s, p2.Prefix)\n\t\t})\n\t}\n}\n\nfunc TestPrefixPrinter_WithScope(t *testing.T) {\n\tfor _, p := range prefixPrinters {\n\t\tt.Run(\"\", func(t *testing.T) {\n\t\t\ts := pterm.Scope{\n\t\t\t\tText:  \"test\",\n\t\t\t\tStyle: pterm.NewStyle(pterm.FgRed, pterm.BgBlue, pterm.Bold),\n\t\t\t}\n\t\t\tp2 := p.WithScope(s)\n\n\t\t\ttestza.AssertEqual(t, s, p2.Scope)\n\t\t})\n\t}\n}\n\nfunc Test_checkFatal(t *testing.T) {\n\tfor _, p := range prefixPrinters {\n\t\tt.Run(\"\", func(t *testing.T) {\n\t\t\tp2 := p.WithFatal()\n\t\t\ttestza.AssertPanics(t, func() {\n\t\t\t\tp2.Println(\"Hello, World!\")\n\t\t\t})\n\t\t})\n\t}\n}\n\nfunc TestPrefixPrinter_WithDebugger(t *testing.T) {\n\tfor _, p := range prefixPrinters {\n\t\tt.Run(\"\", func(t *testing.T) {\n\t\t\tp2 := p.WithDebugger()\n\n\t\t\ttestza.AssertTrue(t, p2.Debugger)\n\t\t})\n\t}\n}\n\nfunc TestPrefixPrinter_PrintWithDebugger(t *testing.T) {\n\tfor _, p := range prefixPrinters {\n\t\tt.Run(\"\", func(t *testing.T) {\n\t\t\tp2 := p.WithDebugger()\n\t\t\tpterm.EnableDebugMessages()\n\t\t\ttestPrintContains(t, func(w io.Writer, a any) {\n\t\t\t\tp2.WithWriter(w).Print(a)\n\t\t\t})\n\t\t})\n\t}\n}\n\nfunc TestPrefixPrinter_PrintlnWithDebugger(t *testing.T) {\n\tfor _, p := range prefixPrinters {\n\t\tt.Run(\"\", func(t *testing.T) {\n\t\t\tp2 := p.WithDebugger()\n\t\t\tpterm.EnableDebugMessages()\n\t\t\ttestPrintlnContains(t, func(w io.Writer, a any) {\n\t\t\t\tp2.WithWriter(w).Println(a)\n\t\t\t})\n\t\t})\n\t}\n}\n\nfunc TestPrefixPrinter_PrintfWithDebugger(t *testing.T) {\n\tfor _, p := range prefixPrinters {\n\t\tt.Run(\"\", func(t *testing.T) {\n\t\t\tp2 := p.WithDebugger()\n\t\t\tpterm.EnableDebugMessages()\n\t\t\ttestPrintfContains(t, func(w io.Writer, format string, a any) {\n\t\t\t\tp2.WithWriter(w).Printf(format, a)\n\t\t\t})\n\t\t})\n\t}\n}\n\nfunc TestPrefixPrinter_SprintWithDebugger(t *testing.T) {\n\tfor _, p := range prefixPrinters {\n\t\tt.Run(\"\", func(t *testing.T) {\n\t\t\tp2 := p.WithDebugger()\n\t\t\tpterm.EnableDebugMessages()\n\t\t\ttestSprintContains(t, func(a any) string {\n\t\t\t\treturn p2.Sprint(a)\n\t\t\t})\n\t\t})\n\t}\n}\n\nfunc TestPrefixPrinter_SprintlnWithDebugger(t *testing.T) {\n\tfor _, p := range prefixPrinters {\n\t\tt.Run(\"\", func(t *testing.T) {\n\t\t\tp2 := p.WithDebugger()\n\t\t\tpterm.EnableDebugMessages()\n\t\t\ttestSprintlnContains(t, func(a any) string {\n\t\t\t\treturn p2.Sprintln(a)\n\t\t\t})\n\t\t})\n\t}\n}\n\nfunc TestPrefixPrinter_SprintfWithDebugger(t *testing.T) {\n\tfor _, p := range prefixPrinters {\n\t\tt.Run(\"\", func(t *testing.T) {\n\t\t\tp2 := p.WithDebugger()\n\t\t\tpterm.EnableDebugMessages()\n\t\t\ttestSprintfContains(t, func(format string, a any) string {\n\t\t\t\treturn p2.Sprintf(format, a)\n\t\t\t})\n\t\t})\n\t}\n}\n\nfunc TestPrefixPrinter_PrintWithoutDebugger(t *testing.T) {\n\tfor _, p := range prefixPrinters {\n\t\tt.Run(\"\", func(t *testing.T) {\n\t\t\tp2 := p.WithDebugger()\n\t\t\tpterm.DisableDebugMessages()\n\t\t\ttestDoesNotOutput(t, func(w io.Writer) {\n\t\t\t\tp2.Print(\"Hello, World!\")\n\t\t\t})\n\t\t})\n\t}\n}\n\nfunc TestPrefixPrinter_PrintlnWithoutDebugger(t *testing.T) {\n\tfor _, p := range prefixPrinters {\n\t\tt.Run(\"\", func(t *testing.T) {\n\t\t\tp2 := p.WithDebugger()\n\t\t\tpterm.DisableDebugMessages()\n\t\t\ttestDoesNotOutput(t, func(w io.Writer) {\n\t\t\t\tp2.Println(\"Hello, World!\")\n\t\t\t})\n\t\t})\n\t}\n}\n\nfunc TestPrefixPrinter_PrintfWithoutDebugger(t *testing.T) {\n\tfor _, p := range prefixPrinters {\n\t\tt.Run(\"\", func(t *testing.T) {\n\t\t\tp2 := p.WithDebugger()\n\t\t\tpterm.DisableDebugMessages()\n\t\t\ttestDoesNotOutput(t, func(w io.Writer) {\n\t\t\t\tp2.Printf(\"Hello, World!\")\n\t\t\t})\n\t\t})\n\t}\n}\n\nfunc TestPrefixPrinter_PrintflnWithoutDebugger(t *testing.T) {\n\tfor _, p := range prefixPrinters {\n\t\tt.Run(\"\", func(t *testing.T) {\n\t\t\tp2 := p.WithDebugger()\n\t\t\tpterm.DisableDebugMessages()\n\t\t\ttestDoesNotOutput(t, func(w io.Writer) {\n\t\t\t\tp2.Printfln(\"Hello, World!\")\n\t\t\t})\n\t\t})\n\t}\n}\n\nfunc TestPrefixPrinter_SprintWithoutDebugger(t *testing.T) {\n\tfor _, p := range prefixPrinters {\n\t\tt.Run(\"\", func(t *testing.T) {\n\t\t\tp2 := p.WithDebugger()\n\t\t\ttestEmpty(t, func(a any) string {\n\t\t\t\treturn p2.Sprint(a)\n\t\t\t})\n\t\t})\n\t}\n}\n\nfunc TestPrefixPrinter_SprintlnWithoutDebugger(t *testing.T) {\n\tfor _, p := range prefixPrinters {\n\t\tt.Run(\"\", func(t *testing.T) {\n\t\t\tp2 := p.WithDebugger()\n\t\t\tpterm.DisableDebugMessages()\n\t\t\ttestEmpty(t, func(a any) string {\n\t\t\t\treturn p2.Sprintln(a)\n\t\t\t})\n\t\t})\n\t}\n}\n\nfunc TestPrefixPrinter_SprintfWithoutDebugger(t *testing.T) {\n\tfor _, p := range prefixPrinters {\n\t\tt.Run(\"\", func(t *testing.T) {\n\t\t\tp2 := p.WithDebugger()\n\t\t\tpterm.DisableDebugMessages()\n\t\t\ttestEmpty(t, func(a any) string {\n\t\t\t\treturn p2.Sprintf(\"Hello, %s!\", a)\n\t\t\t})\n\t\t})\n\t}\n}\n\nfunc TestPrefixPrinter_SprintflnWithoutDebugger(t *testing.T) {\n\tfor _, p := range prefixPrinters {\n\t\tt.Run(\"\", func(t *testing.T) {\n\t\t\tp2 := p.WithDebugger()\n\t\t\tpterm.DisableDebugMessages()\n\t\t\ttestEmpty(t, func(a any) string {\n\t\t\t\treturn p2.Sprintfln(\"Hello, %s!\", a)\n\t\t\t})\n\t\t})\n\t}\n}\n\nfunc TestPrefixPrinter_WithLineNumberOffset(t *testing.T) {\n\tfor _, p := range prefixPrinters {\n\t\tt.Run(\"\", func(t *testing.T) {\n\t\t\tp2 := p.WithLineNumberOffset(1337)\n\n\t\t\ttestza.AssertEqual(t, 1337, p2.LineNumberOffset)\n\t\t})\n\t}\n}\n\nfunc TestPrefixPrinter_WithWriter(t *testing.T) {\n\tfor _, p := range prefixPrinters {\n\t\tt.Run(\"\", func(t *testing.T) {\n\t\t\ts := os.Stderr\n\t\t\tp2 := p.WithWriter(s)\n\n\t\t\ttestza.AssertEqual(t, s, p2.Writer)\n\t\t})\n\t}\n}\n"
        },
        {
          "name": "print.go",
          "type": "blob",
          "size": 5.01953125,
          "content": "package pterm\n\nimport (\n\t\"fmt\"\n\t\"io\"\n\t\"os\"\n\t\"strings\"\n\n\t\"github.com/gookit/color\"\n)\n\nvar defaultWriter io.Writer = os.Stdout\n\n// SetDefaultOutput sets the default output of pterm.\nfunc SetDefaultOutput(w io.Writer) {\n\tdefaultWriter = w\n\tcolor.SetOutput(w)\n}\n\n// Sprint formats using the default formats for its operands and returns the resulting string.\n// Spaces are added between operands when neither is a string.\nfunc Sprint(a ...any) string {\n\treturn color.Sprint(a...)\n}\n\n// Sprintf formats according to a format specifier and returns the resulting string.\nfunc Sprintf(format string, a ...any) string {\n\treturn color.Sprintf(format, a...)\n}\n\n// Sprintfln formats according to a format specifier and returns the resulting string.\n// Spaces are always added between operands and a newline is appended.\nfunc Sprintfln(format string, a ...any) string {\n\treturn color.Sprintf(format, a...) + \"\\n\"\n}\n\n// Sprintln returns what Println would print to the terminal.\nfunc Sprintln(a ...any) string {\n\tstr := fmt.Sprintln(a...)\n\treturn Sprint(str)\n}\n\n// Sprinto returns what Printo would print.\nfunc Sprinto(a ...any) string {\n\treturn \"\\r\" + Sprint(a...)\n}\n\n// Print formats using the default formats for its operands and writes to standard output.\n// Spaces are added between operands when neither is a string.\n// It returns the number of bytes written and any write error encountered.\nfunc Print(a ...any) {\n\tFprint(defaultWriter, a...)\n}\n\n// Println formats using the default formats for its operands and writes to standard output.\n// Spaces are always added between operands and a newline is appended.\n// It returns the number of bytes written and any write error encountered.\nfunc Println(a ...any) {\n\tPrint(Sprintln(a...))\n}\n\n// Printf formats according to a format specifier and writes to standard output.\n// It returns the number of bytes written and any write error encountered.\nfunc Printf(format string, a ...any) {\n\tPrint(Sprintf(format, a...))\n}\n\n// Printfln formats according to a format specifier and writes to standard output.\n// Spaces are always added between operands and a newline is appended.\n// It returns the number of bytes written and any write error encountered.\nfunc Printfln(format string, a ...any) {\n\tPrint(Sprintfln(format, a...))\n}\n\n// PrintOnError prints every error which is not nil.\n// If every error is nil, nothing will be printed.\n// This can be used for simple error checking.\nfunc PrintOnError(a ...any) {\n\tfor _, arg := range a {\n\t\tif err, ok := arg.(error); ok {\n\t\t\tif err != nil {\n\t\t\t\tPrintln(err)\n\t\t\t}\n\t\t}\n\t}\n}\n\n// PrintOnErrorf wraps every error which is not nil and prints it.\n// If every error is nil, nothing will be printed.\n// This can be used for simple error checking.\nfunc PrintOnErrorf(format string, a ...any) {\n\tfor _, arg := range a {\n\t\tif err, ok := arg.(error); ok {\n\t\t\tif err != nil {\n\t\t\t\tPrintln(fmt.Errorf(format, err))\n\t\t\t}\n\t\t}\n\t}\n}\n\n// Fprint formats using the default formats for its operands and writes to w.\n// Spaces are added between operands when neither is a string.\n// It returns the number of bytes written and any write error encountered.\nfunc Fprint(writer io.Writer, a ...any) {\n\tif !Output {\n\t\treturn\n\t}\n\n\tvar ret string\n\tvar printed bool\n\n\tfor _, bar := range ActiveProgressBarPrinters {\n\t\tif bar.IsActive && (bar.Writer == writer || bar.Writer == os.Stderr) {\n\t\t\tret += sClearLine()\n\t\t\tret += Sprinto(a...)\n\t\t\tprinted = true\n\t\t}\n\t}\n\n\tfor _, spinner := range activeSpinnerPrinters {\n\t\tif spinner.IsActive && (spinner.Writer == writer || spinner.Writer == os.Stderr) {\n\t\t\tret += sClearLine()\n\t\t\tret += Sprinto(a...)\n\t\t\tprinted = true\n\t\t}\n\t}\n\n\tif !printed {\n\t\tret = color.Sprint(Sprint(a...))\n\t}\n\n\tif writer != nil {\n\t\tcolor.Fprint(writer, Sprint(ret))\n\t} else {\n\t\tcolor.Print(Sprint(ret))\n\t}\n\n\t// Refresh all progressbars in case they were overwritten previously. Reference: #302\n\tfor _, bar := range ActiveProgressBarPrinters {\n\t\tif bar.IsActive {\n\t\t\tbar.UpdateTitle(bar.Title)\n\t\t}\n\t}\n}\n\n// Fprintln formats using the default formats for its operands and writes to w.\n// Spaces are always added between operands and a newline is appended.\n// It returns the number of bytes written and any write error encountered.\nfunc Fprintln(writer io.Writer, a ...any) {\n\tFprint(writer, Sprint(a...)+\"\\n\")\n}\n\n// Printo overrides the current line in a terminal.\n// If the current line is empty, the text will be printed like with pterm.Print.\n// Example:\n//\n//\tpterm.Printo(\"Hello, World\")\n//\ttime.Sleep(time.Second)\n//\tpterm.Printo(\"Hello, Earth!\")\nfunc Printo(a ...any) {\n\tif !Output {\n\t\treturn\n\t}\n\n\tcolor.Print(\"\\r\" + Sprint(a...))\n}\n\n// Fprinto prints Printo to a custom writer.\nfunc Fprinto(w io.Writer, a ...any) {\n\tif !Output {\n\t\treturn\n\t}\n\tif w != nil {\n\t\tcolor.Fprint(w, \"\\r\", Sprint(a...))\n\t} else {\n\t\tcolor.Print(\"\\r\", Sprint(a...))\n\t}\n}\n\n// RemoveColorFromString removes color codes from a string.\nfunc RemoveColorFromString(a ...any) string {\n\treturn color.ClearCode(Sprint(a...))\n}\n\nfunc fClearLine(writer io.Writer) {\n\tFprinto(writer, strings.Repeat(\" \", GetTerminalWidth()))\n}\n\nfunc sClearLine() string {\n\treturn Sprinto(strings.Repeat(\" \", GetTerminalWidth()))\n}\n"
        },
        {
          "name": "print_test.go",
          "type": "blob",
          "size": 8.4267578125,
          "content": "package pterm_test\n\nimport (\n\t\"errors\"\n\t\"io\"\n\t\"os\"\n\t\"testing\"\n\n\t\"github.com/MarvinJWendt/testza\"\n\n\t\"github.com/pterm/pterm\"\n\t\"github.com/pterm/pterm/internal\"\n)\n\n// pterm.Sprint functions\n\nfunc TestSprint(t *testing.T) {\n\tfor _, randomString := range internal.RandomStrings {\n\t\ttestza.AssertEqual(t, randomString, pterm.Sprint(randomString))\n\t}\n}\n\nfunc TestSprintf(t *testing.T) {\n\tfor _, randomString := range internal.RandomStrings {\n\t\ttestza.AssertEqual(t, randomString, pterm.Sprintf(\"%s\", randomString))\n\t}\n\ttestza.AssertEqual(t, \"Hello, World!\", pterm.Sprintf(\"Hello, %s!\", \"World\"))\n}\n\nfunc TestSprintfln(t *testing.T) {\n\tfor _, randomString := range internal.RandomStrings {\n\t\ttestza.AssertEqual(t, randomString+\"\\n\", pterm.Sprintfln(\"%s\", randomString))\n\t}\n\ttestza.AssertEqual(t, \"Hello, World!\\n\", pterm.Sprintfln(\"Hello, %s!\", \"World\"))\n}\n\nfunc TestSprintln(t *testing.T) {\n\tfor _, randomString := range internal.RandomStrings {\n\t\ttestza.AssertEqual(t, randomString+\"\\n\", pterm.Sprintln(randomString))\n\t}\n}\n\nfunc TestSprinto(t *testing.T) {\n\tfor _, randomString := range internal.RandomStrings {\n\t\ttestza.AssertEqual(t, \"\\r\"+randomString, pterm.Sprinto(randomString))\n\t}\n}\n\n// Print functions\n\nfunc TestPrint(t *testing.T) {\n\tt.Run(\"enabled output\", func(t *testing.T) {\n\t\tpterm.Output = true\n\t\tfor _, randomString := range internal.RandomStrings {\n\t\t\tout := captureStdout(func(w io.Writer) {\n\t\t\t\tpterm.Print(randomString)\n\t\t\t})\n\t\t\ttestza.AssertEqual(t, randomString, out)\n\t\t}\n\t})\n\n\tt.Run(\"disabled output\", func(t *testing.T) {\n\t\tpterm.Output = false\n\t\tfor _, randomString := range internal.RandomStrings {\n\t\t\tout := captureStdout(func(w io.Writer) {\n\t\t\t\tpterm.Print(randomString)\n\t\t\t})\n\t\t\ttestza.AssertEqual(t, \"\", out)\n\t\t}\n\t\tpterm.Output = true\n\t})\n}\n\nfunc TestPrintln(t *testing.T) {\n\tt.Run(\"enabled output\", func(t *testing.T) {\n\t\tpterm.Output = true\n\t\tfor _, randomString := range internal.RandomStrings {\n\t\t\tout := captureStdout(func(w io.Writer) {\n\t\t\t\tpterm.Println(randomString)\n\t\t\t})\n\t\t\ttestza.AssertEqual(t, randomString+\"\\n\", out)\n\t\t}\n\t})\n\n\tt.Run(\"disabled output\", func(t *testing.T) {\n\t\tpterm.Output = false\n\t\tfor _, randomString := range internal.RandomStrings {\n\t\t\tout := captureStdout(func(w io.Writer) {\n\t\t\t\tpterm.Println(randomString)\n\t\t\t})\n\t\t\ttestza.AssertEqual(t, \"\", out)\n\t\t}\n\t\tpterm.Output = true\n\t})\n}\n\nfunc TestPrintf(t *testing.T) {\n\tt.Run(\"enabled output\", func(t *testing.T) {\n\t\tpterm.Output = true\n\t\tfor _, randomString := range internal.RandomStrings {\n\t\t\tout := captureStdout(func(w io.Writer) {\n\t\t\t\tpterm.Printf(\"%s\", randomString)\n\t\t\t})\n\t\t\ttestza.AssertEqual(t, randomString, out)\n\t\t}\n\t\tout := captureStdout(func(w io.Writer) {\n\t\t\tpterm.Printf(\"Hello, %s!\", \"World\")\n\t\t})\n\t\ttestza.AssertEqual(t, \"Hello, World!\", out)\n\t})\n\n\tt.Run(\"disabled output\", func(t *testing.T) {\n\t\tpterm.Output = false\n\t\tfor _, randomString := range internal.RandomStrings {\n\t\t\tout := captureStdout(func(w io.Writer) {\n\t\t\t\tpterm.Printf(\"%s\", randomString)\n\t\t\t})\n\t\t\ttestza.AssertEqual(t, \"\", out)\n\t\t}\n\t\tout := captureStdout(func(w io.Writer) {\n\t\t\tpterm.Printf(\"Hello, %s!\", \"World\")\n\t\t})\n\t\ttestza.AssertEqual(t, \"\", out)\n\t\tpterm.Output = true\n\t})\n}\n\nfunc TestPrintfln(t *testing.T) {\n\tt.Run(\"enabled output\", func(t *testing.T) {\n\t\tpterm.Output = true\n\t\tfor _, randomString := range internal.RandomStrings {\n\t\t\tout := captureStdout(func(w io.Writer) {\n\t\t\t\tpterm.Printfln(\"%s\", randomString)\n\t\t\t})\n\t\t\ttestza.AssertEqual(t, randomString+\"\\n\", out)\n\t\t}\n\t\tout := captureStdout(func(w io.Writer) {\n\t\t\tpterm.Printfln(\"Hello, %s!\", \"World\")\n\t\t})\n\t\ttestza.AssertEqual(t, \"Hello, World!\\n\", out)\n\t})\n\n\tt.Run(\"disabled output\", func(t *testing.T) {\n\t\tpterm.Output = false\n\t\tfor _, randomString := range internal.RandomStrings {\n\t\t\tout := captureStdout(func(w io.Writer) {\n\t\t\t\tpterm.Printfln(\"%s\", randomString)\n\t\t\t})\n\t\t\ttestza.AssertEqual(t, \"\", out)\n\t\t}\n\t\tout := captureStdout(func(w io.Writer) {\n\t\t\tpterm.Printfln(\"Hello, %s!\", \"World\")\n\t\t})\n\t\ttestza.AssertEqual(t, \"\", out)\n\t\tpterm.Output = true\n\t})\n}\n\nfunc TestFprint(t *testing.T) {\n\tt.Run(\"enabled output\", func(t *testing.T) {\n\t\tpterm.Output = true\n\t\tfor _, randomString := range internal.RandomStrings {\n\t\t\tout := captureStdout(func(w io.Writer) {\n\t\t\t\t// set default to null to confirm that its correctly using the provided writer\n\t\t\t\tpterm.SetDefaultOutput(nil)\n\t\t\t\tpterm.Fprint(w, randomString)\n\t\t\t})\n\t\t\ttestza.AssertEqual(t, randomString, out)\n\t\t}\n\t})\n\n\tt.Run(\"confirm defaults to default output when no writer provided\", func(t *testing.T) {\n\t\tpterm.Output = true\n\t\tfor _, randomString := range internal.RandomStrings {\n\t\t\tout := captureStdout(func(w io.Writer) {\n\t\t\t\tpterm.Fprint(nil, randomString)\n\t\t\t})\n\t\t\ttestza.AssertEqual(t, randomString, out)\n\t\t}\n\t})\n\n\tt.Run(\"disabled output\", func(t *testing.T) {\n\t\tpterm.Output = false\n\t\tfor _, randomString := range internal.RandomStrings {\n\t\t\tout := captureStdout(func(w io.Writer) {\n\t\t\t\tpterm.Fprint(w, randomString)\n\t\t\t})\n\t\t\ttestza.AssertEqual(t, \"\", out)\n\t\t}\n\t\tpterm.Output = true\n\t})\n}\n\nfunc TestFprintln(t *testing.T) {\n\tt.Run(\"enabled output\", func(t *testing.T) {\n\t\tpterm.Output = true\n\t\tfor _, randomString := range internal.RandomStrings {\n\t\t\tout := captureStdout(func(w io.Writer) {\n\t\t\t\t// set default to null to confirm that its correctly using the provided writer\n\t\t\t\tpterm.SetDefaultOutput(nil)\n\t\t\t\tpterm.Fprintln(w, randomString)\n\t\t\t})\n\t\t\ttestza.AssertEqual(t, randomString+\"\\n\", out)\n\t\t}\n\t})\n\n\tt.Run(\"confirm defaults to default output when no writer provided\", func(t *testing.T) {\n\t\tpterm.Output = true\n\t\tfor _, randomString := range internal.RandomStrings {\n\t\t\tout := captureStdout(func(w io.Writer) {\n\t\t\t\tpterm.Fprintln(nil, randomString)\n\t\t\t})\n\t\t\ttestza.AssertEqual(t, randomString+\"\\n\", out)\n\t\t}\n\t})\n\n\tt.Run(\"disabled output\", func(t *testing.T) {\n\t\tpterm.Output = false\n\t\tfor _, randomString := range internal.RandomStrings {\n\t\t\tout := captureStdout(func(w io.Writer) {\n\t\t\t\tpterm.Fprintln(w, randomString)\n\t\t\t})\n\t\t\ttestza.AssertEqual(t, \"\", out)\n\t\t}\n\t\tpterm.Output = true\n\t})\n}\n\nfunc TestPrinto(t *testing.T) {\n\tt.Run(\"enabled output\", func(t *testing.T) {\n\t\tpterm.Output = true\n\t\tfor _, randomString := range internal.RandomStrings {\n\t\t\tout := captureStdout(func(w io.Writer) {\n\t\t\t\tpterm.Printo(randomString)\n\t\t\t})\n\t\t\ttestza.AssertEqual(t, \"\\r\"+randomString, out)\n\t\t}\n\t})\n\n\tt.Run(\"disabled output\", func(t *testing.T) {\n\t\tpterm.Output = false\n\t\tfor _, randomString := range internal.RandomStrings {\n\t\t\tout := captureStdout(func(w io.Writer) {\n\t\t\t\tpterm.Printo(randomString)\n\t\t\t})\n\t\t\ttestza.AssertEqual(t, \"\", out)\n\t\t}\n\t\tpterm.Output = false\n\t})\n}\n\nfunc TestFprinto(t *testing.T) {\n\tt.Run(\"enabled output\", func(t *testing.T) {\n\t\tpterm.Output = true\n\t\tfor _, randomString := range internal.RandomStrings {\n\t\t\tout := captureStdout(func(w io.Writer) {\n\t\t\t\t// set default to null to confirm that its correctly using the provided writer\n\t\t\t\tpterm.SetDefaultOutput(nil)\n\t\t\t\tpterm.Fprinto(w, randomString)\n\t\t\t})\n\t\t\ttestza.AssertEqual(t, \"\\r\"+randomString, out)\n\t\t}\n\t})\n\n\tt.Run(\"confirm defaults to default output when no writer provided\", func(t *testing.T) {\n\t\tpterm.Output = true\n\t\tfor _, randomString := range internal.RandomStrings {\n\t\t\tout := captureStdout(func(w io.Writer) {\n\t\t\t\tpterm.Fprinto(nil, randomString)\n\t\t\t})\n\t\t\ttestza.AssertEqual(t, \"\\r\"+randomString, out)\n\t\t}\n\t})\n\n\tt.Run(\"disabled output\", func(t *testing.T) {\n\t\tpterm.Output = false\n\t\tfor _, randomString := range internal.RandomStrings {\n\t\t\tout := captureStdout(func(w io.Writer) {\n\t\t\t\tpterm.Fprinto(w, randomString)\n\t\t\t})\n\t\t\ttestza.AssertEqual(t, \"\", out)\n\t\t}\n\t\tpterm.Output = true\n\t})\n}\n\nfunc TestSetDefaultOutput(t *testing.T) {\n\tpterm.SetDefaultOutput(os.Stdout)\n}\n\nfunc TestPrintOnError(t *testing.T) {\n\tt.Run(\"PrintOnError\", func(t *testing.T) {\n\t\tresult := captureStdout(func(w io.Writer) {\n\t\t\tpterm.PrintOnError(errors.New(\"hello world\"))\n\t\t})\n\t\ttestza.AssertContains(t, result, \"hello world\")\n\t})\n}\n\nfunc TestPrintIfError_WithoutError(t *testing.T) {\n\tt.Run(\"PrintIfError_WithoutError\", func(t *testing.T) {\n\t\tresult := captureStdout(func(w io.Writer) {\n\t\t\tpterm.PrintOnError(nil)\n\t\t})\n\t\ttestza.AssertZero(t, result)\n\t})\n}\n\nfunc TestPrintOnErrorf(t *testing.T) {\n\tt.Run(\"PrintOnErrorf\", func(t *testing.T) {\n\t\tresult := captureStdout(func(w io.Writer) {\n\t\t\tpterm.PrintOnErrorf(\"wrapping error : %w\", errors.New(\"hello world\"))\n\t\t})\n\t\ttestza.AssertContains(t, result, \"hello world\")\n\t})\n}\n\nfunc TestPrintIfErrorf_WithoutError(t *testing.T) {\n\tt.Run(\"PrintIfErrorf_WithoutError\", func(t *testing.T) {\n\t\tresult := captureStdout(func(w io.Writer) {\n\t\t\tpterm.PrintOnErrorf(\"\", nil)\n\t\t})\n\t\ttestza.AssertZero(t, result)\n\t})\n}\n"
        },
        {
          "name": "progressbar_printer.go",
          "type": "blob",
          "size": 9.4013671875,
          "content": "package pterm\n\nimport (\n\t\"atomicgo.dev/cursor\"\n\t\"atomicgo.dev/schedule\"\n\t\"fmt\"\n\t\"io\"\n\t\"math\"\n\t\"os\"\n\t\"strings\"\n\t\"time\"\n\n\t\"github.com/gookit/color\"\n\n\t\"github.com/pterm/pterm/internal\"\n)\n\n// ActiveProgressBarPrinters contains all running ProgressbarPrinters.\n// Generally, there should only be one active ProgressbarPrinter at a time.\nvar ActiveProgressBarPrinters []*ProgressbarPrinter\n\n// DefaultProgressbar is the default ProgressbarPrinter.\nvar DefaultProgressbar = ProgressbarPrinter{\n\tTotal:                     100,\n\tBarCharacter:              \"█\",\n\tLastCharacter:             \"█\",\n\tElapsedTimeRoundingFactor: time.Second,\n\tBarStyle:                  &ThemeDefault.ProgressbarBarStyle,\n\tTitleStyle:                &ThemeDefault.ProgressbarTitleStyle,\n\tShowTitle:                 true,\n\tShowCount:                 true,\n\tShowPercentage:            true,\n\tShowElapsedTime:           true,\n\tBarFiller:                 Gray(\"█\"),\n\tMaxWidth:                  80,\n\tWriter:                    os.Stderr,\n}\n\n// ProgressbarPrinter shows a progress animation in the terminal.\ntype ProgressbarPrinter struct {\n\tTitle                     string\n\tTotal                     int\n\tCurrent                   int\n\tBarCharacter              string\n\tLastCharacter             string\n\tElapsedTimeRoundingFactor time.Duration\n\tBarFiller                 string\n\tMaxWidth                  int\n\n\tShowElapsedTime bool\n\tShowCount       bool\n\tShowTitle       bool\n\tShowPercentage  bool\n\tRemoveWhenDone  bool\n\n\tTitleStyle *Style\n\tBarStyle   *Style\n\n\tIsActive bool\n\n\tstartedAt    time.Time\n\trerenderTask *schedule.Task\n\n\tWriter io.Writer\n}\n\n// WithTitle sets the name of the ProgressbarPrinter.\nfunc (p ProgressbarPrinter) WithTitle(name string) *ProgressbarPrinter {\n\tp.Title = name\n\treturn &p\n}\n\n// WithMaxWidth sets the maximum width of the ProgressbarPrinter.\n// If the terminal is smaller than the given width, the terminal width will be used instead.\n// If the width is set to zero, or below, the terminal width will be used.\nfunc (p ProgressbarPrinter) WithMaxWidth(maxWidth int) *ProgressbarPrinter {\n\tp.MaxWidth = maxWidth\n\treturn &p\n}\n\n// WithTotal sets the total value of the ProgressbarPrinter.\nfunc (p ProgressbarPrinter) WithTotal(total int) *ProgressbarPrinter {\n\tp.Total = total\n\treturn &p\n}\n\n// WithCurrent sets the current value of the ProgressbarPrinter.\nfunc (p ProgressbarPrinter) WithCurrent(current int) *ProgressbarPrinter {\n\tp.Current = current\n\treturn &p\n}\n\n// WithBarCharacter sets the bar character of the ProgressbarPrinter.\nfunc (p ProgressbarPrinter) WithBarCharacter(char string) *ProgressbarPrinter {\n\tp.BarCharacter = char\n\treturn &p\n}\n\n// WithLastCharacter sets the last character of the ProgressbarPrinter.\nfunc (p ProgressbarPrinter) WithLastCharacter(char string) *ProgressbarPrinter {\n\tp.LastCharacter = char\n\treturn &p\n}\n\n// WithElapsedTimeRoundingFactor sets the rounding factor of the elapsed time.\nfunc (p ProgressbarPrinter) WithElapsedTimeRoundingFactor(duration time.Duration) *ProgressbarPrinter {\n\tp.ElapsedTimeRoundingFactor = duration\n\treturn &p\n}\n\n// WithShowElapsedTime sets if the elapsed time should be displayed in the ProgressbarPrinter.\nfunc (p ProgressbarPrinter) WithShowElapsedTime(b ...bool) *ProgressbarPrinter {\n\tp.ShowElapsedTime = internal.WithBoolean(b)\n\treturn &p\n}\n\n// WithShowCount sets if the total and current count should be displayed in the ProgressbarPrinter.\nfunc (p ProgressbarPrinter) WithShowCount(b ...bool) *ProgressbarPrinter {\n\tp.ShowCount = internal.WithBoolean(b)\n\treturn &p\n}\n\n// WithShowTitle sets if the title should be displayed in the ProgressbarPrinter.\nfunc (p ProgressbarPrinter) WithShowTitle(b ...bool) *ProgressbarPrinter {\n\tp.ShowTitle = internal.WithBoolean(b)\n\treturn &p\n}\n\n// WithShowPercentage sets if the completed percentage should be displayed in the ProgressbarPrinter.\nfunc (p ProgressbarPrinter) WithShowPercentage(b ...bool) *ProgressbarPrinter {\n\tp.ShowPercentage = internal.WithBoolean(b)\n\treturn &p\n}\n\n// WithStartedAt sets the time when the ProgressbarPrinter started.\nfunc (p ProgressbarPrinter) WithStartedAt(t time.Time) *ProgressbarPrinter {\n\tp.startedAt = t\n\treturn &p\n}\n\n// WithTitleStyle sets the style of the title.\nfunc (p ProgressbarPrinter) WithTitleStyle(style *Style) *ProgressbarPrinter {\n\tp.TitleStyle = style\n\treturn &p\n}\n\n// WithBarStyle sets the style of the bar.\nfunc (p ProgressbarPrinter) WithBarStyle(style *Style) *ProgressbarPrinter {\n\tp.BarStyle = style\n\treturn &p\n}\n\n// WithRemoveWhenDone sets if the ProgressbarPrinter should be removed when it is done.\nfunc (p ProgressbarPrinter) WithRemoveWhenDone(b ...bool) *ProgressbarPrinter {\n\tp.RemoveWhenDone = internal.WithBoolean(b)\n\treturn &p\n}\n\n// WithBarFiller sets the filler character for the ProgressbarPrinter.\nfunc (p ProgressbarPrinter) WithBarFiller(char string) *ProgressbarPrinter {\n\tp.BarFiller = char\n\treturn &p\n}\n\n// WithWriter sets the custom Writer.\nfunc (p ProgressbarPrinter) WithWriter(writer io.Writer) *ProgressbarPrinter {\n\tp.Writer = writer\n\treturn &p\n}\n\n// SetWriter sets the custom Writer.\nfunc (p *ProgressbarPrinter) SetWriter(writer io.Writer) {\n\tp.Writer = writer\n}\n\n// SetStartedAt sets the time when the ProgressbarPrinter started.\nfunc (p *ProgressbarPrinter) SetStartedAt(t time.Time) {\n\tp.startedAt = t\n}\n\n// ResetTimer resets the timer of the ProgressbarPrinter.\nfunc (p *ProgressbarPrinter) ResetTimer() {\n\tp.startedAt = time.Now()\n}\n\n// Increment current value by one.\nfunc (p *ProgressbarPrinter) Increment() *ProgressbarPrinter {\n\tp.Add(1)\n\treturn p\n}\n\n// UpdateTitle updates the title and re-renders the progressbar\nfunc (p *ProgressbarPrinter) UpdateTitle(title string) *ProgressbarPrinter {\n\tp.Title = title\n\tp.updateProgress()\n\treturn p\n}\n\n// This is the update logic, renders the progressbar\nfunc (p *ProgressbarPrinter) updateProgress() *ProgressbarPrinter {\n\tFprinto(p.Writer, p.getString())\n\treturn p\n}\n\nfunc (p *ProgressbarPrinter) getString() string {\n\tif !p.IsActive {\n\t\treturn \"\"\n\t}\n\tif p.TitleStyle == nil {\n\t\tp.TitleStyle = NewStyle()\n\t}\n\tif p.BarStyle == nil {\n\t\tp.BarStyle = NewStyle()\n\t}\n\tif p.Total == 0 {\n\t\treturn \"\"\n\t}\n\n\tvar before string\n\tvar after string\n\tvar width int\n\n\tif p.MaxWidth <= 0 {\n\t\twidth = GetTerminalWidth()\n\t} else if GetTerminalWidth() < p.MaxWidth {\n\t\twidth = GetTerminalWidth()\n\t} else {\n\t\twidth = p.MaxWidth\n\t}\n\n\tif p.ShowTitle {\n\t\tbefore += p.TitleStyle.Sprint(p.Title) + \" \"\n\t}\n\tif p.ShowCount {\n\t\tpadding := 1 + int(math.Log10(float64(p.Total)))\n\t\tbefore += Gray(\"[\") + LightWhite(fmt.Sprintf(\"%0*d\", padding, p.Current)) + Gray(\"/\") + LightWhite(p.Total) + Gray(\"]\") + \" \"\n\t}\n\n\tafter += \" \"\n\n\tif p.ShowPercentage {\n\t\tcurrentPercentage := int(internal.PercentageRound(float64(int64(p.Total)), float64(int64(p.Current))))\n\t\tdecoratorCurrentPercentage := color.RGB(NewRGB(255, 0, 0).Fade(0, float32(p.Total), float32(p.Current), NewRGB(0, 255, 0)).GetValues()).\n\t\t\tSprintf(\"%3d%%\", currentPercentage)\n\t\tafter += decoratorCurrentPercentage + \" \"\n\t}\n\tif p.ShowElapsedTime {\n\t\tafter += \"| \" + p.parseElapsedTime()\n\t}\n\n\tbarMaxLength := width - len(RemoveColorFromString(before)) - len(RemoveColorFromString(after)) - 1\n\n\tbarCurrentLength := (p.Current * barMaxLength) / p.Total\n\tvar barFiller string\n\tif barMaxLength-barCurrentLength > 0 {\n\t\tbarFiller = strings.Repeat(p.BarFiller, barMaxLength-barCurrentLength)\n\t}\n\n\tbar := barFiller\n\tif barCurrentLength > 0 {\n\t\tbar = p.BarStyle.Sprint(strings.Repeat(p.BarCharacter, barCurrentLength)+p.LastCharacter) + bar\n\t}\n\n\treturn before + bar + after\n}\n\n// Add to current value.\nfunc (p *ProgressbarPrinter) Add(count int) *ProgressbarPrinter {\n\tif p.Total == 0 {\n\t\treturn nil\n\t}\n\n\tp.Current += count\n\tp.updateProgress()\n\n\tif p.Current >= p.Total {\n\t\tp.Total = p.Current\n\t\tp.updateProgress()\n\t\tp.Stop()\n\t}\n\treturn p\n}\n\n// Start the ProgressbarPrinter.\nfunc (p ProgressbarPrinter) Start(title ...any) (*ProgressbarPrinter, error) {\n\tcursor.Hide()\n\tif RawOutput && p.ShowTitle {\n\t\tFprintln(p.Writer, p.Title)\n\t}\n\tp.IsActive = true\n\tif len(title) != 0 {\n\t\tp.Title = Sprint(title...)\n\t}\n\tActiveProgressBarPrinters = append(ActiveProgressBarPrinters, &p)\n\tp.startedAt = time.Now()\n\n\tp.updateProgress()\n\n\tif p.ShowElapsedTime {\n\t\tp.rerenderTask = schedule.Every(time.Second, func() bool {\n\t\t\tp.updateProgress()\n\t\t\treturn true\n\t\t})\n\t}\n\n\treturn &p, nil\n}\n\n// Stop the ProgressbarPrinter.\nfunc (p *ProgressbarPrinter) Stop() (*ProgressbarPrinter, error) {\n\tif p.rerenderTask != nil && p.rerenderTask.IsActive() {\n\t\tp.rerenderTask.Stop()\n\t}\n\tcursor.Show()\n\n\tif !p.IsActive {\n\t\treturn p, nil\n\t}\n\tp.IsActive = false\n\tif p.RemoveWhenDone {\n\t\tfClearLine(p.Writer)\n\t\tFprinto(p.Writer)\n\t} else {\n\t\tFprintln(p.Writer)\n\t}\n\treturn p, nil\n}\n\n// GenericStart runs Start, but returns a LivePrinter.\n// This is used for the interface LivePrinter.\n// You most likely want to use Start instead of this in your program.\nfunc (p *ProgressbarPrinter) GenericStart() (*LivePrinter, error) {\n\tp2, _ := p.Start()\n\tlp := LivePrinter(p2)\n\treturn &lp, nil\n}\n\n// GenericStop runs Stop, but returns a LivePrinter.\n// This is used for the interface LivePrinter.\n// You most likely want to use Stop instead of this in your program.\nfunc (p *ProgressbarPrinter) GenericStop() (*LivePrinter, error) {\n\tp2, _ := p.Stop()\n\tlp := LivePrinter(p2)\n\treturn &lp, nil\n}\n\n// GetElapsedTime returns the elapsed time, since the ProgressbarPrinter was started.\nfunc (p *ProgressbarPrinter) GetElapsedTime() time.Duration {\n\treturn time.Since(p.startedAt)\n}\n\nfunc (p *ProgressbarPrinter) parseElapsedTime() string {\n\ts := p.GetElapsedTime().Round(p.ElapsedTimeRoundingFactor).String()\n\treturn s\n}\n"
        },
        {
          "name": "progressbar_printer_test.go",
          "type": "blob",
          "size": 6.369140625,
          "content": "package pterm_test\n\nimport (\n\t\"io\"\n\t\"os\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/MarvinJWendt/testza\"\n\t\"github.com/pterm/pterm\"\n)\n\nfunc TestProgressbarPrinter_Add(t *testing.T) {\n\tproxyToDevNull()\n\tp := pterm.DefaultProgressbar.WithTotal(2000)\n\tp.Add(1337)\n\ttestza.AssertEqual(t, 1337, p.Current)\n\tp.Stop()\n}\n\nfunc TestProgressbarPrinter_Add_With(t *testing.T) {\n\tproxyToDevNull()\n\tw := pterm.GetTerminalWidth()\n\th := pterm.GetTerminalHeight()\n\tpterm.SetForcedTerminalSize(1, 1)\n\tp := pterm.DefaultProgressbar.WithTotal(2000)\n\tp.Add(1337)\n\ttestza.AssertEqual(t, 1337, p.Current)\n\tp.Stop()\n\tpterm.SetForcedTerminalSize(w, h)\n}\n\nfunc TestProgressbarPrinter_AddWithNoStyle(t *testing.T) {\n\tproxyToDevNull()\n\tp := pterm.ProgressbarPrinter{}.WithTotal(2000)\n\tp.Add(1337)\n\ttestza.AssertEqual(t, 1337, p.Current)\n\tp.Stop()\n}\n\nfunc TestProgressbarPrinter_AddWithTotalOfZero(t *testing.T) {\n\tproxyToDevNull()\n\tp := pterm.ProgressbarPrinter{}.WithTotal(0)\n\tp.Add(1337)\n\ttestza.AssertEqual(t, 0, p.Current)\n\tp.Stop()\n}\n\nfunc TestProgressbarPrinter_AddTotalEqualsCurrent(t *testing.T) {\n\tproxyToDevNull()\n\tp := pterm.DefaultProgressbar.WithTotal(1)\n\tp.Start()\n\tp.Add(1)\n\ttestza.AssertEqual(t, 1, p.Current)\n\ttestza.AssertFalse(t, p.IsActive)\n\tp.Stop()\n}\n\nfunc TestProgressbarPrinter_RemoveWhenDone(t *testing.T) {\n\tproxyToDevNull()\n\tp, err := pterm.DefaultProgressbar.WithTotal(2).WithRemoveWhenDone().Start()\n\ttestza.AssertNoError(t, err)\n\tp.Stop()\n\tp.Add(1)\n\ttestza.AssertEqual(t, 1, p.Current)\n\ttestza.AssertFalse(t, p.IsActive)\n}\n\nfunc TestProgressbarPrinter_StartWithTitle(t *testing.T) {\n\tp := pterm.DefaultProgressbar\n\tp2, _ := p.Start(\"Title\")\n\ttestza.AssertEqual(t, \"Title\", p2.Title)\n\tp.Stop()\n}\n\nfunc TestProgressbarPrinter_GenericStart(t *testing.T) {\n\tp := pterm.DefaultProgressbar\n\tp.GenericStart()\n}\n\nfunc TestProgressbarPrinter_GenericStartRawOutput(t *testing.T) {\n\tpterm.DisableStyling()\n\tp := pterm.DefaultProgressbar\n\tp.GenericStart()\n\tpterm.EnableStyling()\n}\n\nfunc TestProgressbarPrinter_GenericStop(t *testing.T) {\n\tp, err := pterm.DefaultProgressbar.Start()\n\ttestza.AssertNoError(t, err)\n\tp.GenericStop()\n}\n\nfunc TestProgressbarPrinter_GetElapsedTime(t *testing.T) {\n\tp := pterm.DefaultProgressbar\n\tp.Start()\n\tp.Stop()\n\ttestza.AssertNotZero(t, p.GetElapsedTime())\n}\n\nfunc TestProgressbarPrinter_Increment(t *testing.T) {\n\tp := pterm.DefaultProgressbar.WithTotal(2000)\n\tp.Increment()\n\ttestza.AssertEqual(t, 1, p.Current)\n}\n\nfunc TestProgressbarPrinter_WithBarStyle(t *testing.T) {\n\ts := pterm.NewStyle(pterm.FgRed, pterm.BgBlue, pterm.Bold)\n\tp := pterm.ProgressbarPrinter{}\n\tp2 := p.WithBarStyle(s)\n\n\ttestza.AssertEqual(t, s, p2.BarStyle)\n}\n\nfunc TestProgressbarPrinter_WithCurrent(t *testing.T) {\n\tp := pterm.ProgressbarPrinter{}\n\tp2 := p.WithCurrent(10)\n\n\ttestza.AssertEqual(t, 10, p2.Current)\n}\n\nfunc TestProgressbarPrinter_WithElapsedTimeRoundingFactor(t *testing.T) {\n\tp := pterm.ProgressbarPrinter{}\n\tp2 := p.WithElapsedTimeRoundingFactor(time.Hour)\n\n\ttestza.AssertEqual(t, time.Hour, p2.ElapsedTimeRoundingFactor)\n}\n\nfunc TestProgressbarPrinter_WithLastCharacter(t *testing.T) {\n\tp := pterm.ProgressbarPrinter{}\n\tp2 := p.WithLastCharacter(\">\")\n\n\ttestza.AssertEqual(t, \">\", p2.LastCharacter)\n}\n\nfunc TestProgressbarPrinter_WithBarCharacter(t *testing.T) {\n\tp := pterm.ProgressbarPrinter{}\n\tp2 := p.WithBarCharacter(\"-\")\n\n\ttestza.AssertEqual(t, \"-\", p2.BarCharacter)\n}\n\nfunc TestProgressbarPrinter_WithRemoveWhenDone(t *testing.T) {\n\tp := pterm.ProgressbarPrinter{}\n\tp2 := p.WithRemoveWhenDone()\n\n\ttestza.AssertTrue(t, p2.RemoveWhenDone)\n}\n\nfunc TestProgressbarPrinter_WithShowCount(t *testing.T) {\n\tp := pterm.ProgressbarPrinter{}\n\tp2 := p.WithShowCount()\n\n\ttestza.AssertTrue(t, p2.ShowCount)\n}\n\nfunc TestProgressbarPrinter_WithShowElapsedTime(t *testing.T) {\n\tp := pterm.ProgressbarPrinter{}\n\tp2 := p.WithShowElapsedTime()\n\n\ttestza.AssertTrue(t, p2.ShowElapsedTime)\n}\n\nfunc TestProgressbarPrinter_WithShowPercentage(t *testing.T) {\n\tp := pterm.ProgressbarPrinter{}\n\tp2 := p.WithShowPercentage()\n\n\ttestza.AssertTrue(t, p2.ShowPercentage)\n}\n\nfunc TestProgressbarPrinter_WithShowTitle(t *testing.T) {\n\tp := pterm.ProgressbarPrinter{}\n\tp2 := p.WithShowTitle()\n\n\ttestza.AssertTrue(t, p2.ShowTitle)\n}\n\nfunc TestProgressbarPrinter_WithTitle(t *testing.T) {\n\tp := pterm.ProgressbarPrinter{}\n\tp2 := p.WithTitle(\"test\")\n\n\ttestza.AssertEqual(t, \"test\", p2.Title)\n}\n\nfunc TestProgressbarPrinter_WithTitleStyle(t *testing.T) {\n\ts := pterm.NewStyle(pterm.FgRed, pterm.BgBlue, pterm.Bold)\n\tp := pterm.ProgressbarPrinter{}\n\tp2 := p.WithTitleStyle(s)\n\n\ttestza.AssertEqual(t, s, p2.TitleStyle)\n}\n\nfunc TestProgressbarPrinter_WithTotal(t *testing.T) {\n\tp := pterm.ProgressbarPrinter{}\n\tp2 := p.WithTotal(1337)\n\n\ttestza.AssertEqual(t, 1337, p2.Total)\n}\n\nfunc TestProgressbarPrinter_WithMaxWidth(t *testing.T) {\n\tp := pterm.ProgressbarPrinter{}\n\tp2 := p.WithMaxWidth(1337)\n\n\ttestza.AssertEqual(t, 1337, p2.MaxWidth)\n}\n\nfunc TestProgressbarPrinter_WithBarFiller(t *testing.T) {\n\tp := pterm.ProgressbarPrinter{}\n\tp2 := p.WithBarFiller(\"-\")\n\n\ttestza.AssertEqual(t, \"-\", p2.BarFiller)\n}\n\nfunc TestProgressbarPrinter_UpdateTitle(t *testing.T) {\n\tp := pterm.ProgressbarPrinter{}\n\tp2 := p.WithTitle(\"test\")\n\tp2.UpdateTitle(\"test2\")\n\n\ttestza.AssertEqual(t, \"test2\", p2.Title)\n}\n\nfunc TestProgressbarPrinter_WithWriter(t *testing.T) {\n\tp := pterm.ProgressbarPrinter{}\n\ts := os.Stderr\n\tp2 := p.WithWriter(s)\n\n\ttestza.AssertEqual(t, s, p2.Writer)\n\ttestza.AssertZero(t, p.Writer)\n}\n\nfunc TestProgressbarPrinter_OutputToWriters(t *testing.T) {\n\ttestCases := map[string]struct {\n\t\taction                func(*pterm.ProgressbarPrinter)\n\t\texpectOutputToContain string\n\t}{\n\t\t\"ExpectUpdatedTitleToBeWrittenToStderr\": {\n\t\t\taction: func(pb *pterm.ProgressbarPrinter) {\n\t\t\t\tpb.UpdateTitle(\"Updated text\")\n\t\t\t},\n\t\t\texpectOutputToContain: \"Updated text\",\n\t\t},\n\t}\n\n\tfor testTitle, testCase := range testCases {\n\t\tt.Run(testTitle, func(t *testing.T) {\n\t\t\tstderr, err := testza.CaptureStderr(func(w io.Writer) error {\n\t\t\t\tpb, err := pterm.DefaultProgressbar.WithTitle(\"Hello world\").WithWriter(os.Stderr).Start()\n\t\t\t\ttime.Sleep(time.Second) // Required otherwise the goroutine doesn't run and the text isnt outputted\n\t\t\t\ttestza.AssertNoError(t, err)\n\t\t\t\ttestCase.action(pb)\n\t\t\t\ttime.Sleep(time.Second) // Required otherwise the goroutine doesn't run and the text isnt updated\n\t\t\t\treturn nil\n\t\t\t})\n\n\t\t\ttestza.AssertNoError(t, err)\n\t\t\ttestza.AssertContains(t, stderr, \"Hello world\")\n\t\t\ttestza.AssertContains(t, stderr, testCase.expectOutputToContain)\n\t\t})\n\t}\n}\n"
        },
        {
          "name": "pterm.go",
          "type": "blob",
          "size": 2.138671875,
          "content": "// Package pterm is a modern go module to beautify console output.\n// It can be used without configuration, but if desired, everything can be customized down to the smallest detail.\n//\n// Official docs are available at: https://docs.pterm.sh\n//\n// View the animated examples here: https://github.com/pterm/pterm#-examples\npackage pterm\n\nimport (\n\t\"github.com/gookit/color\"\n)\n\nvar (\n\t// Output completely disables output from pterm if set to false. Can be used in CLI application quiet mode.\n\tOutput = true\n\n\t// PrintDebugMessages sets if messages printed by the DebugPrinter should be printed.\n\tPrintDebugMessages = false\n\n\t// RawOutput is set to true if pterm.DisableStyling() was called.\n\t// The variable indicates that PTerm will not add additional styling to text.\n\t// Use pterm.DisableStyling() or pterm.EnableStyling() to change this variable.\n\t// Changing this variable directly, will disable or enable the output of colored text.\n\tRawOutput = false\n)\n\nfunc init() {\n\tcolor.ForceColor()\n}\n\n// EnableOutput enables the output of PTerm.\nfunc EnableOutput() {\n\tOutput = true\n}\n\n// DisableOutput disables the output of PTerm.\nfunc DisableOutput() {\n\tOutput = false\n}\n\n// EnableDebugMessages enables the output of debug printers.\nfunc EnableDebugMessages() {\n\tPrintDebugMessages = true\n}\n\n// DisableDebugMessages disables the output of debug printers.\nfunc DisableDebugMessages() {\n\tPrintDebugMessages = false\n}\n\n// EnableStyling enables the default PTerm styling.\n// This also calls EnableColor.\nfunc EnableStyling() {\n\tRawOutput = false\n\tEnableColor()\n}\n\n// DisableStyling sets PTerm to RawOutput mode and disables all of PTerms styling.\n// You can use this to print to text files etc.\n// This also calls DisableColor.\nfunc DisableStyling() {\n\tRawOutput = true\n\tDisableColor()\n}\n\n// RecalculateTerminalSize updates already initialized terminal dimensions. Has to be called after a terminal resize to guarantee proper rendering. Applies only to new instances.\nfunc RecalculateTerminalSize() {\n\t// keep in sync with DefaultBarChart\n\tDefaultBarChart.Width = GetTerminalWidth() * 2 / 3\n\tDefaultBarChart.Height = GetTerminalHeight() * 2 / 3\n\tDefaultParagraph.MaxWidth = GetTerminalWidth()\n}\n"
        },
        {
          "name": "pterm_test.go",
          "type": "blob",
          "size": 2.1015625,
          "content": "package pterm_test\n\nimport (\n\t\"github.com/MarvinJWendt/testza\"\n\t\"github.com/pterm/pterm\"\n\t\"testing\"\n)\n\nfunc TestDisableDebugMessages(t *testing.T) {\n\tpterm.PrintDebugMessages = true\n\tpterm.DisableDebugMessages()\n\ttestza.AssertFalse(t, pterm.PrintDebugMessages)\n}\n\nfunc TestEnableDebugMessages(t *testing.T) {\n\tpterm.EnableDebugMessages()\n\ttestza.AssertTrue(t, pterm.PrintDebugMessages)\n}\n\nfunc TestDisableOutput(t *testing.T) {\n\tpterm.DisableOutput()\n\ttestza.AssertFalse(t, pterm.Output)\n}\n\nfunc TestEnableOutput(t *testing.T) {\n\tpterm.DisableOutput()\n\tpterm.EnableOutput()\n\ttestza.AssertTrue(t, pterm.Output)\n}\n\nfunc TestDisableStyling(t *testing.T) {\n\tpterm.RawOutput = false\n\tpterm.DisableStyling()\n\ttestza.AssertTrue(t, pterm.RawOutput)\n}\n\nfunc TestEnableStyling(t *testing.T) {\n\tpterm.RawOutput = true\n\tpterm.EnableStyling()\n\ttestza.AssertFalse(t, pterm.RawOutput)\n}\n\nfunc TestInterfaceImplementation(t *testing.T) {\n\t// If a printer doesn't fit into the slice, the printer doesn't has the right interface anymore.\n\t_ = []pterm.TextPrinter{&pterm.DefaultBasicText, pterm.DefaultBox, pterm.DefaultCenter, &pterm.DefaultHeader, &pterm.DefaultParagraph, &pterm.Info, &pterm.DefaultSection, pterm.FgRed, pterm.NewRGB(0, 0, 0)}\n\t_ = []pterm.LivePrinter{&pterm.DefaultProgressbar, &pterm.DefaultSpinner}\n\t_ = []pterm.RenderPrinter{pterm.DefaultBarChart, pterm.DefaultBigText, pterm.DefaultBulletList, pterm.DefaultPanel, pterm.DefaultTable, pterm.DefaultTree}\n}\n\nfunc TestRecalculateTerminalSize(t *testing.T) {\n\t// save existing values\n\tprevBarChartWidth := pterm.DefaultBarChart.Width\n\tprevBarChartHeight := pterm.DefaultBarChart.Height\n\tprevParagraphMaxWidth := pterm.DefaultParagraph.MaxWidth\n\tw := pterm.GetTerminalWidth()\n\th := pterm.GetTerminalHeight()\n\t// double the terminal size\n\tpterm.SetForcedTerminalSize(w*2, h*2)\n\t// assert the values doubled\n\ttestza.AssertEqual(t, prevBarChartWidth*2, pterm.DefaultBarChart.Width)\n\ttestza.AssertEqual(t, prevBarChartHeight*2, pterm.DefaultBarChart.Height)\n\ttestza.AssertEqual(t, prevParagraphMaxWidth*2, pterm.DefaultParagraph.MaxWidth)\n\t// revert the terminal size\n\tpterm.SetForcedTerminalSize(w, h)\n}\n"
        },
        {
          "name": "putils",
          "type": "tree",
          "content": null
        },
        {
          "name": "rgb.go",
          "type": "blob",
          "size": 9.0341796875,
          "content": "package pterm\n\nimport (\n\t\"fmt\"\n\n\t\"github.com/gookit/color\"\n\n\t\"github.com/pterm/pterm/internal\"\n)\n\n// RGB color model is an additive color model in which red, green, and blue light are added together in various ways to reproduce a broad array of colors.\n// The name of the model comes from the initials of the three additive primary colors, red, green, and blue.\n// https://en.wikipedia.org/wiki/RGB_color_model\ntype RGB struct {\n\tR          uint8\n\tG          uint8\n\tB          uint8\n\tBackground bool\n}\n\ntype RGBStyle struct {\n\tOptions                []Color\n\tForeground, Background RGB\n\n\thasBg bool\n}\n\n// NewRGBStyle returns a new RGBStyle.\n// The foreground color is required, the background color is optional.\n// The colors will be set as is, ignoring the RGB.Background property.\nfunc NewRGBStyle(foreground RGB, background ...RGB) RGBStyle {\n\tvar s RGBStyle\n\ts.Foreground = foreground\n\tif len(background) > 0 {\n\t\ts.Background = background[0]\n\t\ts.hasBg = true\n\t}\n\treturn s\n}\n\n// AddOptions adds options to the RGBStyle.\nfunc (p RGBStyle) AddOptions(opts ...Color) RGBStyle {\n\tp.Options = append(p.Options, opts...)\n\treturn p\n}\n\n// Print formats using the default formats for its operands and writes to standard output.\n// Spaces are added between operands when neither is a string.\n// It returns the number of bytes written and any write error encountered.\nfunc (p RGBStyle) Print(a ...any) *TextPrinter {\n\tPrint(p.Sprint(a...))\n\ttp := TextPrinter(p)\n\treturn &tp\n}\n\n// Println formats using the default formats for its operands and writes to standard output.\n// Spaces are always added between operands and a newline is appended.\n// It returns the number of bytes written and any write error encountered.\nfunc (p RGBStyle) Println(a ...any) *TextPrinter {\n\tPrintln(p.Sprint(a...))\n\ttp := TextPrinter(p)\n\treturn &tp\n}\n\n// Printf formats according to a format specifier and writes to standard output.\n// It returns the number of bytes written and any write error encountered.\nfunc (p RGBStyle) Printf(format string, a ...any) *TextPrinter {\n\tPrintf(format, p.Sprint(a...))\n\ttp := TextPrinter(p)\n\treturn &tp\n}\n\n// Printfln formats according to a format specifier and writes to standard output.\n// Spaces are always added between operands and a newline is appended.\n// It returns the number of bytes written and any write error encountered.\nfunc (p RGBStyle) Printfln(format string, a ...any) *TextPrinter {\n\tPrintf(format, p.Sprint(a...))\n\ttp := TextPrinter(p)\n\treturn &tp\n}\n\n// PrintOnError prints every error which is not nil.\n// If every error is nil, nothing will be printed.\n// This can be used for simple error checking.\nfunc (p RGBStyle) PrintOnError(a ...any) *TextPrinter {\n\tfor _, arg := range a {\n\t\tif err, ok := arg.(error); ok {\n\t\t\tif err != nil {\n\t\t\t\tp.Println(err)\n\t\t\t}\n\t\t}\n\t}\n\n\ttp := TextPrinter(p)\n\treturn &tp\n}\n\n// PrintOnErrorf wraps every error which is not nil and prints it.\n// If every error is nil, nothing will be printed.\n// This can be used for simple error checking.\nfunc (p RGBStyle) PrintOnErrorf(format string, a ...any) *TextPrinter {\n\tfor _, arg := range a {\n\t\tif err, ok := arg.(error); ok {\n\t\t\tif err != nil {\n\t\t\t\tp.Println(fmt.Errorf(format, err))\n\t\t\t}\n\t\t}\n\t}\n\n\ttp := TextPrinter(p)\n\treturn &tp\n}\n\n// Sprint formats using the default formats for its operands and returns the resulting string.\n// Spaces are added between operands when neither is a string.\nfunc (p RGBStyle) Sprint(a ...any) string {\n\tvar rgbStyle *color.RGBStyle\n\tif !p.hasBg {\n\t\trgbStyle = color.NewRGBStyle(color.RGB(p.Foreground.R, p.Foreground.G, p.Foreground.B))\n\t} else {\n\t\trgbStyle = color.NewRGBStyle(color.RGB(p.Foreground.R, p.Foreground.G, p.Foreground.B), color.RGB(p.Background.R, p.Background.G, p.Background.B))\n\t}\n\tif len(p.Options) > 0 {\n\t\tfor _, opt := range p.Options {\n\t\t\trgbStyle.AddOpts(color.Color(opt))\n\t\t}\n\t}\n\treturn rgbStyle.Sprint(a...)\n}\n\n// Sprintln formats using the default formats for its operands and returns the resulting string.\n// Spaces are always added between operands and a newline is appended.\nfunc (p RGBStyle) Sprintln(a ...any) string {\n\treturn p.Sprint(a...) + \"\\n\"\n}\n\n// Sprintf formats according to a format specifier and returns the resulting string.\nfunc (p RGBStyle) Sprintf(format string, a ...any) string {\n\treturn p.Sprint(Sprintf(format, a...))\n}\n\n// Sprintfln formats according to a format specifier and returns the resulting string.\n// Spaces are always added between operands and a newline is appended.\nfunc (p RGBStyle) Sprintfln(format string, a ...any) string {\n\treturn p.Sprintf(format, a...) + \"\\n\"\n}\n\n// GetValues returns the RGB values separately.\nfunc (p RGB) GetValues() (r, g, b uint8) {\n\treturn p.R, p.G, p.B\n}\n\n// NewRGB returns a new RGB.\nfunc NewRGB(r, g, b uint8, background ...bool) RGB {\n\tvar bg bool\n\n\tif len(background) > 0 {\n\t\tbg = background[0]\n\t}\n\n\treturn RGB{R: r, G: g, B: b, Background: bg}\n}\n\n// Fade fades one RGB value (over other RGB values) to another RGB value, by giving the function a minimum, maximum and current value.\nfunc (p RGB) Fade(minRGB, maxRGB, current float32, end ...RGB) RGB {\n\tif maxRGB == current {\n\t\treturn end[len(end)-1]\n\t}\n\tif minRGB < 0 {\n\t\tmaxRGB -= minRGB\n\t\tcurrent -= minRGB\n\t\tminRGB = 0\n\t}\n\t// #nosec G115\n\tif len(end) == 1 {\n\t\treturn RGB{\n\t\t\tR:          uint8(internal.MapRangeToRange(minRGB, maxRGB, float32(p.R), float32(end[0].R), current)), //nolint:gosec\n\t\t\tG:          uint8(internal.MapRangeToRange(minRGB, maxRGB, float32(p.G), float32(end[0].G), current)), //nolint:gosec\n\t\t\tB:          uint8(internal.MapRangeToRange(minRGB, maxRGB, float32(p.B), float32(end[0].B), current)), //nolint:gosec\n\t\t\tBackground: p.Background,\n\t\t}\n\t} else if len(end) > 1 {\n\t\tf := (maxRGB - minRGB) / float32(len(end))\n\t\ttempCurrent := current\n\t\tif f > current {\n\t\t\treturn p.Fade(minRGB, f, current, end[0])\n\t\t} else {\n\t\t\tfor i := 0; i < len(end)-1; i++ {\n\t\t\t\ttempCurrent -= f\n\t\t\t\tif f > tempCurrent {\n\t\t\t\t\treturn end[i].Fade(minRGB, minRGB+f, tempCurrent, end[i+1])\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn p\n}\n\n// Sprint formats using the default formats for its operands and returns the resulting string.\n// Spaces are added between operands when neither is a string.\nfunc (p RGB) Sprint(a ...any) string {\n\tif p.Background {\n\t\treturn color.RGB(p.R, p.G, p.B, p.Background).Sprint(a...) + \"\\033[0m\\033[K\"\n\t}\n\treturn color.RGB(p.R, p.G, p.B, p.Background).Sprint(a...)\n}\n\n// Sprintln formats using the default formats for its operands and returns the resulting string.\n// Spaces are always added between operands and a newline is appended.\nfunc (p RGB) Sprintln(a ...any) string {\n\treturn p.Sprint(Sprintln(a...))\n}\n\n// Sprintf formats according to a format specifier and returns the resulting string.\nfunc (p RGB) Sprintf(format string, a ...any) string {\n\treturn p.Sprint(Sprintf(format, a...))\n}\n\n// Sprintfln formats according to a format specifier and returns the resulting string.\n// Spaces are always added between operands and a newline is appended.\nfunc (p RGB) Sprintfln(format string, a ...any) string {\n\treturn p.Sprintf(format, a...) + \"\\n\"\n}\n\n// Print formats using the default formats for its operands and writes to standard output.\n// Spaces are added between operands when neither is a string.\n// It returns the number of bytes written and any write error encountered.\nfunc (p RGB) Print(a ...any) *TextPrinter {\n\tPrint(p.Sprint(a...))\n\ttp := TextPrinter(p)\n\treturn &tp\n}\n\n// Println formats using the default formats for its operands and writes to standard output.\n// Spaces are always added between operands and a newline is appended.\n// It returns the number of bytes written and any write error encountered.\nfunc (p RGB) Println(a ...any) *TextPrinter {\n\tPrint(p.Sprintln(a...))\n\ttp := TextPrinter(p)\n\treturn &tp\n}\n\n// Printf formats according to a format specifier and writes to standard output.\n// It returns the number of bytes written and any write error encountered.\nfunc (p RGB) Printf(format string, a ...any) *TextPrinter {\n\tPrint(p.Sprintf(format, a...))\n\ttp := TextPrinter(p)\n\treturn &tp\n}\n\n// Printfln formats according to a format specifier and writes to standard output.\n// Spaces are always added between operands and a newline is appended.\n// It returns the number of bytes written and any write error encountered.\nfunc (p RGB) Printfln(format string, a ...any) *TextPrinter {\n\tPrint(p.Sprintfln(format, a...))\n\ttp := TextPrinter(p)\n\treturn &tp\n}\n\n// PrintOnError prints every error which is not nil.\n// If every error is nil, nothing will be printed.\n// This can be used for simple error checking.\nfunc (p RGB) PrintOnError(a ...any) *TextPrinter {\n\tfor _, arg := range a {\n\t\tif err, ok := arg.(error); ok {\n\t\t\tif err != nil {\n\t\t\t\tp.Println(err)\n\t\t\t}\n\t\t}\n\t}\n\n\ttp := TextPrinter(p)\n\treturn &tp\n}\n\n// PrintOnErrorf wraps every error which is not nil and prints it.\n// If every error is nil, nothing will be printed.\n// This can be used for simple error checking.\nfunc (p RGB) PrintOnErrorf(format string, a ...any) *TextPrinter {\n\tfor _, arg := range a {\n\t\tif err, ok := arg.(error); ok {\n\t\t\tif err != nil {\n\t\t\t\tp.Println(fmt.Errorf(format, err))\n\t\t\t}\n\t\t}\n\t}\n\n\ttp := TextPrinter(p)\n\treturn &tp\n}\n\nfunc (p RGB) ToRGBStyle() RGBStyle {\n\tif p.Background {\n\t\treturn RGBStyle{Background: p}\n\t}\n\n\treturn RGBStyle{Foreground: p}\n}\n"
        },
        {
          "name": "rgb_test.go",
          "type": "blob",
          "size": 12.3193359375,
          "content": "package pterm_test\n\nimport (\n\t\"errors\"\n\t\"io\"\n\t\"reflect\"\n\t\"strconv\"\n\t\"testing\"\n\n\t\"github.com/MarvinJWendt/testza\"\n\n\t\"github.com/pterm/pterm\"\n)\n\nfunc TestNewRGB(t *testing.T) {\n\ttype args struct {\n\t\tr uint8\n\t\tg uint8\n\t\tb uint8\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant pterm.RGB\n\t}{\n\t\t{name: \"1\", args: args{0, 0, 0}, want: pterm.RGB{0, 0, 0, false}},\n\t\t{name: \"3\", args: args{255, 255, 255}, want: pterm.RGB{255, 255, 255, false}},\n\t\t{name: \"4\", args: args{127, 127, 127}, want: pterm.RGB{127, 127, 127, false}},\n\t\t{name: \"5\", args: args{1, 2, 3}, want: pterm.RGB{1, 2, 3, false}},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := pterm.NewRGB(tt.args.r, tt.args.g, tt.args.b); !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"NewRGB() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestNewRGBFromHEX(t *testing.T) {\n\ttests := []struct {\n\t\thex  string\n\t\twant pterm.RGB\n\t}{\n\t\t{hex: \"#ff0009\", want: pterm.RGB{R: 255, G: 0, B: 9}},\n\t\t{hex: \"ff0009\", want: pterm.RGB{R: 255, G: 0, B: 9}},\n\t\t{hex: \"ff00090x\", want: pterm.RGB{R: 255, G: 0, B: 9}},\n\t\t{hex: \"ff00090X\", want: pterm.RGB{R: 255, G: 0, B: 9}},\n\t\t{hex: \"#fba\", want: pterm.RGB{R: 255, G: 187, B: 170}},\n\t\t{hex: \"fba\", want: pterm.RGB{R: 255, G: 187, B: 170}},\n\t\t{hex: \"fba0x\", want: pterm.RGB{R: 255, G: 187, B: 170}},\n\t}\n\tfor _, test := range tests {\n\t\tt.Run(\"\", func(t *testing.T) {\n\t\t\trgb, err := pterm.NewRGBFromHEX(test.hex)\n\t\t\ttestza.AssertEqual(t, test.want, rgb)\n\t\t\ttestza.AssertNoError(t, err)\n\t\t})\n\t}\n\ttestsFail := []struct {\n\t\thex  string\n\t\twant error\n\t}{\n\t\t{hex: \"faba0x\", want: pterm.ErrHexCodeIsInvalid},\n\t\t{hex: \"faba\", want: pterm.ErrHexCodeIsInvalid},\n\t\t{hex: \"#faba\", want: pterm.ErrHexCodeIsInvalid},\n\t\t{hex: \"faba0x\", want: pterm.ErrHexCodeIsInvalid},\n\t\t{hex: \"fax\", want: strconv.ErrSyntax},\n\t}\n\tfor _, test := range testsFail {\n\t\tt.Run(\"\", func(t *testing.T) {\n\t\t\t_, err := pterm.NewRGBFromHEX(test.hex)\n\t\t\ttestza.AssertTrue(t, errors.Is(err, test.want))\n\t\t})\n\t}\n}\n\nfunc TestRGB_Fade(t *testing.T) {\n\ttype fields struct {\n\t\tR uint8\n\t\tG uint8\n\t\tB uint8\n\t}\n\ttype args struct {\n\t\tmin     float32\n\t\tmax     float32\n\t\tcurrent float32\n\t\tend     []pterm.RGB\n\t}\n\ttests := []struct {\n\t\tname   string\n\t\tfields fields\n\t\targs   args\n\t\twant   pterm.RGB\n\t}{\n\t\t{name: \"Middle\", fields: fields{0, 0, 0}, args: args{min: 0, max: 100, current: 50, end: []pterm.RGB{{255, 255, 255, false}}}, want: pterm.RGB{127, 127, 127, false}},\n\t\t{name: \"ZeroToZero\", fields: fields{0, 0, 0}, args: args{min: 0, max: 100, current: 50, end: []pterm.RGB{{0, 0, 0, false}}}, want: pterm.RGB{0, 0, 0, false}},\n\t\t{name: \"DifferentValues\", fields: fields{0, 1, 2}, args: args{min: 0, max: 100, current: 50, end: []pterm.RGB{{0, 1, 2, false}}}, want: pterm.RGB{0, 1, 2, false}},\n\t\t{name: \"NegativeRangeMiddle\", fields: fields{0, 0, 0}, args: args{min: -50, max: 50, current: 0, end: []pterm.RGB{{255, 255, 255, false}}}, want: pterm.RGB{127, 127, 127, false}},\n\t\t{name: \"NegativeRangeMiddleMultipleRGB\", fields: fields{0, 0, 0}, args: args{min: -50, max: 50, current: 0, end: []pterm.RGB{{127, 127, 127, false}, {255, 255, 255, false}}}, want: pterm.RGB{127, 127, 127, false}},\n\t\t{name: \"MiddleMultipleRGB\", fields: fields{0, 0, 0}, args: args{min: 0, max: 100, current: 50, end: []pterm.RGB{{127, 127, 127, false}, {255, 255, 255, false}}}, want: pterm.RGB{127, 127, 127, false}},\n\t\t{name: \"1/4MultipleRGB\", fields: fields{0, 0, 0}, args: args{min: 0, max: 100, current: 25, end: []pterm.RGB{{255, 255, 255, false}, {255, 255, 255, false}}}, want: pterm.RGB{127, 127, 127, false}},\n\t\t{name: \"MiddleMultipleRGBPositiveMin\", fields: fields{0, 0, 0}, args: args{min: 10, max: 110, current: 60, end: []pterm.RGB{{127, 127, 127, false}, {255, 255, 255, false}}}, want: pterm.RGB{127, 127, 127, false}},\n\t\t{name: \"MiddleNoRGB\", fields: fields{0, 0, 0}, args: args{min: 10, max: 110, current: 60, end: []pterm.RGB{}}, want: pterm.RGB{0, 0, 0, false}},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tp := pterm.RGB{\n\t\t\t\tR: tt.fields.R,\n\t\t\t\tG: tt.fields.G,\n\t\t\t\tB: tt.fields.B,\n\t\t\t}\n\t\t\tif got := p.Fade(tt.args.min, tt.args.max, tt.args.current, tt.args.end...); !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"Fade() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestRGB_GetValues(t *testing.T) {\n\ttype fields struct {\n\t\tR uint8\n\t\tG uint8\n\t\tB uint8\n\t}\n\ttests := []struct {\n\t\tname   string\n\t\tfields fields\n\t\twantR  uint8\n\t\twantG  uint8\n\t\twantB  uint8\n\t}{\n\t\t{name: \"Zero\", fields: fields{R: 0, G: 0, B: 0}, wantR: uint8(0), wantG: uint8(0), wantB: uint8(0)},\n\t\t{name: \"Max\", fields: fields{R: 255, G: 255, B: 255}, wantR: uint8(255), wantG: uint8(255), wantB: uint8(255)},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tp := pterm.RGB{\n\t\t\t\tR: tt.fields.R,\n\t\t\t\tG: tt.fields.G,\n\t\t\t\tB: tt.fields.B,\n\t\t\t}\n\t\t\tgotR, gotG, gotB := p.GetValues()\n\t\t\tif gotR != tt.wantR {\n\t\t\t\tt.Errorf(\"GetValues() gotR = %v, want %v\", gotR, tt.wantR)\n\t\t\t}\n\t\t\tif gotG != tt.wantG {\n\t\t\t\tt.Errorf(\"GetValues() gotG = %v, want %v\", gotG, tt.wantG)\n\t\t\t}\n\t\t\tif gotB != tt.wantB {\n\t\t\t\tt.Errorf(\"GetValues() gotB = %v, want %v\", gotB, tt.wantB)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestRGB_Print(t *testing.T) {\n\tRGBs := []pterm.RGB{{0, 0, 0, false}, {127, 127, 127, false}, {255, 255, 255, false}}\n\n\tfor _, rgb := range RGBs {\n\t\tt.Run(pterm.Sprintf(\"%v %v %v\", rgb.R, rgb.G, rgb.B), func(t *testing.T) {\n\t\t\ttestPrintContains(t, func(w io.Writer, a any) {\n\t\t\t\tp := rgb.Print(a)\n\t\t\t\ttestza.AssertNotNil(t, p)\n\t\t\t})\n\t\t})\n\t}\n}\n\nfunc TestRGB_Printf(t *testing.T) {\n\tRGBs := []pterm.RGB{{0, 0, 0, false}, {127, 127, 127, false}, {255, 255, 255, false}}\n\n\tfor _, rgb := range RGBs {\n\t\tt.Run(pterm.Sprintf(\"%v %v %v\", rgb.R, rgb.G, rgb.B), func(t *testing.T) {\n\t\t\ttestPrintfContains(t, func(w io.Writer, format string, a any) {\n\t\t\t\tp := rgb.Printf(format, a)\n\t\t\t\ttestza.AssertNotNil(t, p)\n\t\t\t})\n\t\t})\n\t}\n}\n\nfunc TestRGB_Printfln(t *testing.T) {\n\tRGBs := []pterm.RGB{{0, 0, 0, false}, {127, 127, 127, false}, {255, 255, 255, false}}\n\n\tfor _, rgb := range RGBs {\n\t\tt.Run(pterm.Sprintfln(\"%v %v %v\", rgb.R, rgb.G, rgb.B), func(t *testing.T) {\n\t\t\ttestPrintflnContains(t, func(w io.Writer, format string, a any) {\n\t\t\t\tp := rgb.Printfln(format, a)\n\t\t\t\ttestza.AssertNotNil(t, p)\n\t\t\t})\n\t\t})\n\t}\n}\n\nfunc TestRGB_Println(t *testing.T) {\n\tRGBs := []pterm.RGB{{0, 0, 0, false}, {127, 127, 127, false}, {255, 255, 255, false}}\n\n\tfor _, rgb := range RGBs {\n\t\tt.Run(pterm.Sprintf(\"%v %v %v\", rgb.R, rgb.G, rgb.B), func(t *testing.T) {\n\t\t\ttestPrintlnContains(t, func(w io.Writer, a any) {\n\t\t\t\tp := rgb.Println(a)\n\t\t\t\ttestza.AssertNotNil(t, p)\n\t\t\t})\n\t\t})\n\t}\n}\n\nfunc TestRGB_Sprint(t *testing.T) {\n\tRGBs := []pterm.RGB{{0, 0, 0, false}, {127, 127, 127, false}, {255, 255, 255, false}}\n\n\tfor _, rgb := range RGBs {\n\t\tt.Run(pterm.Sprintf(\"%v %v %v\", rgb.R, rgb.G, rgb.B), func(t *testing.T) {\n\t\t\ttestSprintContains(t, func(a any) string {\n\t\t\t\treturn rgb.Sprint(a)\n\t\t\t})\n\t\t})\n\t}\n}\n\nfunc TestRGB_Sprintf(t *testing.T) {\n\tRGBs := []pterm.RGB{{0, 0, 0, false}, {127, 127, 127, false}, {255, 255, 255, false}}\n\n\tfor _, rgb := range RGBs {\n\t\tt.Run(\"\", func(t *testing.T) {\n\t\t\ttestSprintfContains(t, func(format string, a any) string {\n\t\t\t\treturn rgb.Sprintf(format, a)\n\t\t\t})\n\t\t})\n\t}\n}\n\nfunc TestRGB_Sprintfln(t *testing.T) {\n\tRGBs := []pterm.RGB{{0, 0, 0, false}, {127, 127, 127, false}, {255, 255, 255, false}}\n\n\tfor _, rgb := range RGBs {\n\t\tt.Run(\"\", func(t *testing.T) {\n\t\t\ttestSprintflnContains(t, func(format string, a any) string {\n\t\t\t\treturn rgb.Sprintfln(format, a)\n\t\t\t})\n\t\t})\n\t}\n}\n\nfunc TestRGB_Sprintln(t *testing.T) {\n\tRGBs := []pterm.RGB{{0, 0, 0, false}, {127, 127, 127, false}, {255, 255, 255, false}}\n\n\tfor _, rgb := range RGBs {\n\t\tt.Run(pterm.Sprintf(\"%v %v %v\", rgb.R, rgb.G, rgb.B), func(t *testing.T) {\n\t\t\ttestSprintlnContains(t, func(a any) string {\n\t\t\t\treturn rgb.Sprintln(a)\n\t\t\t})\n\t\t})\n\t}\n}\n\nfunc TestRGB_PrintOnError(t *testing.T) {\n\tRGBs := []pterm.RGB{{0, 0, 0, false}, {127, 127, 127, false}, {255, 255, 255, false}}\n\n\tfor _, rgb := range RGBs {\n\t\tt.Run(\"PrintOnError\", func(t *testing.T) {\n\t\t\tresult := captureStdout(func(w io.Writer) {\n\t\t\t\trgb.PrintOnError(errors.New(\"hello world\"))\n\t\t\t})\n\t\t\ttestza.AssertContains(t, result, \"hello world\")\n\t\t})\n\t}\n}\n\nfunc TestRGB_PrintIfError_WithoutError(t *testing.T) {\n\tRGBs := []pterm.RGB{{0, 0, 0, false}, {127, 127, 127, false}, {255, 255, 255, false}}\n\n\tfor _, rgb := range RGBs {\n\t\tt.Run(\"PrintIfError_WithoutError\", func(t *testing.T) {\n\t\t\tresult := captureStdout(func(w io.Writer) {\n\t\t\t\trgb.PrintOnError(nil)\n\t\t\t})\n\t\t\ttestza.AssertZero(t, result)\n\t\t})\n\t}\n}\n\nfunc TestRGB_PrintOnErrorf(t *testing.T) {\n\tRGBs := []pterm.RGB{{0, 0, 0, false}, {127, 127, 127, false}, {255, 255, 255, false}}\n\n\tfor _, rgb := range RGBs {\n\t\tt.Run(\"PrintOnErrorf\", func(t *testing.T) {\n\t\t\tresult := captureStdout(func(w io.Writer) {\n\t\t\t\trgb.PrintOnErrorf(\"wrapping error : %w\", errors.New(\"hello world\"))\n\t\t\t})\n\t\t\ttestza.AssertContains(t, result, \"hello world\")\n\t\t})\n\t}\n}\n\nfunc TestRGB_PrintIfError_WithoutErrorf(t *testing.T) {\n\tRGBs := []pterm.RGB{{0, 0, 0, false}, {127, 127, 127, false}, {255, 255, 255, false}}\n\n\tfor _, rgb := range RGBs {\n\t\tt.Run(\"PrintIfError_WithoutErrorf\", func(t *testing.T) {\n\t\t\tresult := captureStdout(func(w io.Writer) {\n\t\t\t\trgb.PrintOnErrorf(\"\", nil)\n\t\t\t})\n\t\t\ttestza.AssertZero(t, result)\n\t\t})\n\t}\n}\n\nfunc TestRGBStyle_PrintOnError(t *testing.T) {\n\tRGBs := []pterm.RGBStyle{{Foreground: pterm.RGB{R: 10, G: 10, B: 10}}, {Foreground: pterm.RGB{R: 0, G: 0, B: 255}, Background: pterm.RGB{R: 255, G: 0, B: 255}, Options: []pterm.Color{pterm.Bold}},\n\t\t{Foreground: pterm.RGB{R: 0, G: 0, B: 255}, Background: pterm.RGB{R: 255, G: 0, B: 255}, Options: []pterm.Color{pterm.Bold, pterm.Italic}}}\n\tfor _, rgb := range RGBs {\n\t\tt.Run(\"PrintOnError\", func(t *testing.T) {\n\t\t\tresult := captureStdout(func(w io.Writer) {\n\t\t\t\trgb.PrintOnError(errors.New(\"hello world\"))\n\t\t\t})\n\t\t\ttestza.AssertContains(t, result, \"hello world\")\n\t\t})\n\t}\n}\n\nfunc TestRGBStyle_PrintIfError_WithoutError(t *testing.T) {\n\tRGBs := []pterm.RGBStyle{{Foreground: pterm.RGB{R: 10, G: 10, B: 10}}, {Foreground: pterm.RGB{R: 0, G: 0, B: 255}, Background: pterm.RGB{R: 255, G: 0, B: 255}, Options: []pterm.Color{pterm.Bold}},\n\t\t{Foreground: pterm.RGB{R: 0, G: 0, B: 255}, Background: pterm.RGB{R: 255, G: 0, B: 255}, Options: []pterm.Color{pterm.Bold, pterm.Italic}}}\n\tfor _, rgb := range RGBs {\n\t\tt.Run(\"PrintIfError_WithoutError\", func(t *testing.T) {\n\t\t\tresult := captureStdout(func(w io.Writer) {\n\t\t\t\trgb.PrintOnError(nil)\n\t\t\t})\n\t\t\ttestza.AssertZero(t, result)\n\t\t})\n\t}\n}\n\nfunc TestRGBStyle_PrintOnErrorf(t *testing.T) {\n\tRGBs := []pterm.RGBStyle{{Foreground: pterm.RGB{R: 10, G: 10, B: 10}}, {Foreground: pterm.RGB{R: 0, G: 0, B: 255}, Background: pterm.RGB{R: 255, G: 0, B: 255}, Options: []pterm.Color{pterm.Bold}},\n\t\t{Foreground: pterm.RGB{R: 0, G: 0, B: 255}, Background: pterm.RGB{R: 255, G: 0, B: 255}, Options: []pterm.Color{pterm.Bold, pterm.Italic}}}\n\tfor _, rgb := range RGBs {\n\t\tt.Run(\"PrintOnErrorf\", func(t *testing.T) {\n\t\t\tresult := captureStdout(func(w io.Writer) {\n\t\t\t\trgb.PrintOnErrorf(\"wrapping error : %w\", errors.New(\"hello world\"))\n\t\t\t})\n\t\t\ttestza.AssertContains(t, result, \"hello world\")\n\t\t})\n\t}\n}\n\nfunc TestRGBStyle_PrintIfError_WithoutErrorf(t *testing.T) {\n\tRGBs := []pterm.RGBStyle{{Foreground: pterm.RGB{R: 10, G: 10, B: 10}}, {Foreground: pterm.RGB{R: 0, G: 0, B: 255}, Background: pterm.RGB{R: 255, G: 0, B: 255}, Options: []pterm.Color{pterm.Bold}},\n\t\t{Foreground: pterm.RGB{R: 0, G: 0, B: 255}, Background: pterm.RGB{R: 255, G: 0, B: 255}, Options: []pterm.Color{pterm.Bold, pterm.Italic}}}\n\tfor _, rgb := range RGBs {\n\t\tt.Run(\"PrintIfError_WithoutErrorf\", func(t *testing.T) {\n\t\t\tresult := captureStdout(func(w io.Writer) {\n\t\t\t\trgb.PrintOnErrorf(\"\", nil)\n\t\t\t})\n\t\t\ttestza.AssertZero(t, result)\n\t\t})\n\t}\n}\n\nfunc TestRGBStyle_NewRGBStyle(t *testing.T) {\n\tRGBs := []pterm.RGBStyle{{Foreground: pterm.RGB{R: 10, G: 10, B: 10}}, {Foreground: pterm.RGB{R: 0, G: 0, B: 255}, Background: pterm.RGB{R: 255, G: 0, B: 255}, Options: []pterm.Color{pterm.Bold}},\n\t\t{Foreground: pterm.RGB{R: 0, G: 0, B: 255}, Background: pterm.RGB{R: 255, G: 0, B: 255}, Options: []pterm.Color{pterm.Bold, pterm.Italic}}}\n\tfor _, rgb := range RGBs {\n\t\tt.Run(\"NewRGBStyle\", func(t *testing.T) {\n\t\t\tresult := pterm.NewRGBStyle(rgb.Foreground, rgb.Background)\n\t\t\tif len(rgb.Options) > 0 {\n\t\t\t\tresult = result.AddOptions(rgb.Options...)\n\t\t\t}\n\t\t\ttestza.AssertEqual(t, rgb.Foreground, result.Foreground)\n\t\t\ttestza.AssertEqual(t, rgb.Background, result.Background)\n\t\t\ttestza.AssertEqual(t, rgb.Options, result.Options)\n\t\t})\n\t}\n}\n"
        },
        {
          "name": "section_printer.go",
          "type": "blob",
          "size": 5.00390625,
          "content": "package pterm\n\nimport (\n\t\"fmt\"\n\t\"io\"\n\t\"strings\"\n)\n\n// DefaultSection is the default section printer.\nvar DefaultSection = SectionPrinter{\n\tStyle:           &ThemeDefault.SectionStyle,\n\tLevel:           1,\n\tTopPadding:      1,\n\tBottomPadding:   1,\n\tIndentCharacter: \"#\",\n}\n\n// SectionPrinter prints a new section title.\n// It can be used to structure longer text, or different chapters of your program.\ntype SectionPrinter struct {\n\tStyle           *Style\n\tLevel           int\n\tIndentCharacter string\n\tTopPadding      int\n\tBottomPadding   int\n\tWriter          io.Writer\n}\n\n// WithStyle returns a new SectionPrinter with a specific style.\nfunc (p SectionPrinter) WithStyle(style *Style) *SectionPrinter {\n\tp.Style = style\n\treturn &p\n}\n\n// WithLevel returns a new SectionPrinter with a specific level.\nfunc (p SectionPrinter) WithLevel(level int) *SectionPrinter {\n\tp.Level = level\n\treturn &p\n}\n\n// WithIndentCharacter returns a new SectionPrinter with a specific IndentCharacter.\nfunc (p SectionPrinter) WithIndentCharacter(char string) *SectionPrinter {\n\tp.IndentCharacter = char\n\treturn &p\n}\n\n// WithTopPadding returns a new SectionPrinter with a specific top padding.\nfunc (p SectionPrinter) WithTopPadding(padding int) *SectionPrinter {\n\tp.TopPadding = padding\n\treturn &p\n}\n\n// WithBottomPadding returns a new SectionPrinter with a specific top padding.\nfunc (p SectionPrinter) WithBottomPadding(padding int) *SectionPrinter {\n\tp.BottomPadding = padding\n\treturn &p\n}\n\n// WithWriter sets the custom Writer.\nfunc (p SectionPrinter) WithWriter(writer io.Writer) *SectionPrinter {\n\tp.Writer = writer\n\treturn &p\n}\n\n// Sprint formats using the default formats for its operands and returns the resulting string.\n// Spaces are added between operands when neither is a string.\nfunc (p SectionPrinter) Sprint(a ...any) string {\n\tif p.Style == nil {\n\t\tp.Style = NewStyle()\n\t}\n\n\tvar ret strings.Builder\n\n\tfor i := 0; i < p.TopPadding; i++ {\n\t\tret.WriteByte('\\n')\n\t}\n\n\tif p.Level > 0 {\n\t\tret.WriteString(strings.Repeat(p.IndentCharacter, p.Level))\n\t\tret.WriteByte(' ')\n\t}\n\n\tret.WriteString(p.Style.Sprint(a...))\n\n\tfor i := 0; i < p.BottomPadding; i++ {\n\t\tret.WriteByte('\\n')\n\t}\n\n\treturn ret.String()\n}\n\n// Sprintln formats using the default formats for its operands and returns the resulting string.\n// Spaces are always added between operands and a newline is appended.\nfunc (p SectionPrinter) Sprintln(a ...any) string {\n\tstr := fmt.Sprintln(a...)\n\treturn Sprint(p.Sprint(str))\n}\n\n// Sprintf formats according to a format specifier and returns the resulting string.\nfunc (p SectionPrinter) Sprintf(format string, a ...any) string {\n\treturn p.Sprint(Sprintf(format, a...))\n}\n\n// Sprintfln formats according to a format specifier and returns the resulting string.\n// Spaces are always added between operands and a newline is appended.\nfunc (p SectionPrinter) Sprintfln(format string, a ...any) string {\n\treturn p.Sprintf(format, a...) + \"\\n\"\n}\n\n// Print formats using the default formats for its operands and writes to standard output.\n// Spaces are added between operands when neither is a string.\n// It returns the number of bytes written and any write error encountered.\nfunc (p *SectionPrinter) Print(a ...any) *TextPrinter {\n\tFprint(p.Writer, p.Sprint(a...))\n\ttp := TextPrinter(p)\n\treturn &tp\n}\n\n// Println formats using the default formats for its operands and writes to standard output.\n// Spaces are always added between operands and a newline is appended.\n// It returns the number of bytes written and any write error encountered.\nfunc (p *SectionPrinter) Println(a ...any) *TextPrinter {\n\tFprint(p.Writer, p.Sprintln(a...))\n\ttp := TextPrinter(p)\n\treturn &tp\n}\n\n// Printf formats according to a format specifier and writes to standard output.\n// It returns the number of bytes written and any write error encountered.\nfunc (p *SectionPrinter) Printf(format string, a ...any) *TextPrinter {\n\tFprint(p.Writer, p.Sprintf(format, a...))\n\ttp := TextPrinter(p)\n\treturn &tp\n}\n\n// Printfln formats according to a format specifier and writes to standard output.\n// Spaces are always added between operands and a newline is appended.\n// It returns the number of bytes written and any write error encountered.\nfunc (p *SectionPrinter) Printfln(format string, a ...any) *TextPrinter {\n\tFprint(p.Writer, p.Sprintfln(format, a...))\n\ttp := TextPrinter(p)\n\treturn &tp\n}\n\n// PrintOnError prints every error which is not nil.\n// If every error is nil, nothing will be printed.\n// This can be used for simple error checking.\nfunc (p *SectionPrinter) PrintOnError(a ...any) *TextPrinter {\n\tfor _, arg := range a {\n\t\tif err, ok := arg.(error); ok {\n\t\t\tif err != nil {\n\t\t\t\tp.Println(err)\n\t\t\t}\n\t\t}\n\t}\n\n\ttp := TextPrinter(p)\n\treturn &tp\n}\n\n// PrintOnErrorf wraps every error which is not nil and prints it.\n// If every error is nil, nothing will be printed.\n// This can be used for simple error checking.\nfunc (p *SectionPrinter) PrintOnErrorf(format string, a ...any) *TextPrinter {\n\tfor _, arg := range a {\n\t\tif err, ok := arg.(error); ok {\n\t\t\tif err != nil {\n\t\t\t\tp.Println(fmt.Errorf(format, err))\n\t\t\t}\n\t\t}\n\t}\n\n\ttp := TextPrinter(p)\n\treturn &tp\n}\n"
        },
        {
          "name": "section_printer_test.go",
          "type": "blob",
          "size": 3.25,
          "content": "package pterm_test\n\nimport (\n\t\"errors\"\n\t\"io\"\n\t\"os\"\n\t\"testing\"\n\n\t\"github.com/MarvinJWendt/testza\"\n\n\t\"github.com/pterm/pterm\"\n)\n\nfunc TestSectionPrinterNilPrint(t *testing.T) {\n\tp := pterm.SectionPrinter{}\n\tp.Println(\"Hello, World!\")\n}\n\nfunc TestSectionPrinterPrintMethods(t *testing.T) {\n\tp := pterm.DefaultSection\n\n\tt.Run(\"Print\", func(t *testing.T) {\n\t\ttestPrintContains(t, func(w io.Writer, a any) {\n\t\t\tp.Print(a)\n\t\t})\n\t})\n\n\tt.Run(\"Printf\", func(t *testing.T) {\n\t\ttestPrintfContains(t, func(w io.Writer, format string, a any) {\n\t\t\tp.Printf(format, a)\n\t\t})\n\t})\n\n\tt.Run(\"Printfln\", func(t *testing.T) {\n\t\ttestPrintflnContains(t, func(w io.Writer, format string, a any) {\n\t\t\tp.Printfln(format, a)\n\t\t})\n\t})\n\n\tt.Run(\"Println\", func(t *testing.T) {\n\t\ttestPrintlnContains(t, func(w io.Writer, a any) {\n\t\t\tp.Println(a)\n\t\t})\n\t})\n\n\tt.Run(\"Sprint\", func(t *testing.T) {\n\t\ttestSprintContains(t, func(a any) string {\n\t\t\treturn p.Sprint(a)\n\t\t})\n\t})\n\n\tt.Run(\"Sprintf\", func(t *testing.T) {\n\t\ttestSprintfContains(t, func(format string, a any) string {\n\t\t\treturn p.Sprintf(format, a)\n\t\t})\n\t})\n\n\tt.Run(\"Sprintfln\", func(t *testing.T) {\n\t\ttestSprintflnContains(t, func(format string, a any) string {\n\t\t\treturn p.Sprintfln(format, a)\n\t\t})\n\t})\n\n\tt.Run(\"Sprintln\", func(t *testing.T) {\n\t\ttestSprintlnContains(t, func(a any) string {\n\t\t\treturn p.Sprintln(a)\n\t\t})\n\t})\n\n\tt.Run(\"PrintOnError\", func(t *testing.T) {\n\t\tresult := captureStdout(func(w io.Writer) {\n\t\t\tp.PrintOnError(errors.New(\"hello world\"))\n\t\t})\n\t\ttestza.AssertContains(t, result, \"hello world\")\n\t})\n\n\tt.Run(\"PrintIfError_WithoutError\", func(t *testing.T) {\n\t\tresult := captureStdout(func(w io.Writer) {\n\t\t\tp.PrintOnError(nil)\n\t\t})\n\t\ttestza.AssertZero(t, result)\n\t})\n\n\tt.Run(\"PrintOnErrorf\", func(t *testing.T) {\n\t\tresult := captureStdout(func(w io.Writer) {\n\t\t\tp.PrintOnErrorf(\"wrapping error : %w\", errors.New(\"hello world\"))\n\t\t})\n\t\ttestza.AssertContains(t, result, \"hello world\")\n\t})\n\n\tt.Run(\"PrintIfError_WithoutErrorf\", func(t *testing.T) {\n\t\tresult := captureStdout(func(w io.Writer) {\n\t\t\tp.PrintOnErrorf(\"\", nil)\n\t\t})\n\t\ttestza.AssertZero(t, result)\n\t})\n}\n\nfunc TestSectionPrinter_WithBottomPadding(t *testing.T) {\n\tp := pterm.SectionPrinter{}\n\tp2 := p.WithBottomPadding(1337)\n\n\ttestza.AssertEqual(t, 1337, p2.BottomPadding)\n\ttestza.AssertZero(t, p.BottomPadding)\n}\n\nfunc TestSectionPrinter_WithLevel(t *testing.T) {\n\tp := pterm.SectionPrinter{}\n\tp2 := p.WithLevel(1337)\n\n\ttestza.AssertEqual(t, 1337, p2.Level)\n\ttestza.AssertZero(t, p.Level)\n}\n\nfunc TestSectionPrinter_WithStyle(t *testing.T) {\n\tp := pterm.SectionPrinter{}\n\ts := pterm.NewStyle(pterm.FgRed, pterm.BgRed, pterm.Bold)\n\tp2 := p.WithStyle(s)\n\n\ttestza.AssertEqual(t, s, p2.Style)\n\ttestza.AssertZero(t, p.Style)\n}\n\nfunc TestSectionPrinter_WithTopPadding(t *testing.T) {\n\tp := pterm.SectionPrinter{}\n\tp2 := p.WithTopPadding(1337)\n\n\ttestza.AssertEqual(t, 1337, p2.TopPadding)\n\ttestza.AssertZero(t, p.TopPadding)\n}\n\nfunc TestSectionPrinter_WithIndentCharacter(t *testing.T) {\n\tp := pterm.SectionPrinter{}\n\tp2 := p.WithIndentCharacter(\"#\")\n\n\ttestza.AssertEqual(t, \"#\", p2.IndentCharacter)\n\ttestza.AssertZero(t, p.IndentCharacter)\n}\n\nfunc TestSectionPrinter_WithWriter(t *testing.T) {\n\tp := pterm.SectionPrinter{}\n\ts := os.Stderr\n\tp2 := p.WithWriter(s)\n\n\ttestza.AssertEqual(t, s, p2.Writer)\n\ttestza.AssertZero(t, p.Writer)\n}\n"
        },
        {
          "name": "slog_handler.go",
          "type": "blob",
          "size": 2.0703125,
          "content": "package pterm\n\nimport (\n\t\"context\"\n\n\t\"log/slog\"\n)\n\ntype SlogHandler struct {\n\tlogger *Logger\n\tattrs  []slog.Attr\n}\n\n// Enabled returns true if the given level is enabled.\nfunc (s *SlogHandler) Enabled(ctx context.Context, level slog.Level) bool {\n\tswitch level {\n\tcase slog.LevelDebug:\n\t\treturn s.logger.CanPrint(LogLevelDebug)\n\tcase slog.LevelInfo:\n\t\treturn s.logger.CanPrint(LogLevelInfo)\n\tcase slog.LevelWarn:\n\t\treturn s.logger.CanPrint(LogLevelWarn)\n\tcase slog.LevelError:\n\t\treturn s.logger.CanPrint(LogLevelError)\n\t}\n\treturn false\n}\n\n// Handle handles the given record.\nfunc (s *SlogHandler) Handle(ctx context.Context, record slog.Record) error {\n\tlevel := record.Level\n\tmessage := record.Message\n\n\t// Convert slog Attrs to a map.\n\tkeyValsMap := make(map[string]any)\n\n\trecord.Attrs(func(attr slog.Attr) bool {\n\t\tkeyValsMap[attr.Key] = attr.Value\n\t\treturn true\n\t})\n\n\tfor _, attr := range s.attrs {\n\t\tkeyValsMap[attr.Key] = attr.Value\n\t}\n\n\targs := s.logger.ArgsFromMap(keyValsMap)\n\n\t// Wrapping args inside another slice to match [][]LoggerArgument\n\targsWrapped := [][]LoggerArgument{args}\n\n\tlogger := s.logger\n\n\t// Must be done here, see https://github.com/pterm/pterm/issues/608#issuecomment-1876001650\n\tif logger.CallerOffset == 0 {\n\t\tlogger = logger.WithCallerOffset(3)\n\t}\n\n\tswitch level {\n\tcase slog.LevelDebug:\n\t\tlogger.Debug(message, argsWrapped...)\n\tcase slog.LevelInfo:\n\t\tlogger.Info(message, argsWrapped...)\n\tcase slog.LevelWarn:\n\t\tlogger.Warn(message, argsWrapped...)\n\tcase slog.LevelError:\n\t\tlogger.Error(message, argsWrapped...)\n\tdefault:\n\t\tlogger.Print(message, argsWrapped...)\n\t}\n\n\treturn nil\n}\n\n// WithAttrs returns a new handler with the given attributes.\nfunc (s *SlogHandler) WithAttrs(attrs []slog.Attr) slog.Handler {\n\tnewS := *s\n\tnewS.attrs = attrs\n\treturn &newS\n}\n\n// WithGroup is not yet supported.\nfunc (s *SlogHandler) WithGroup(name string) slog.Handler {\n\t// Grouping is not yet supported by pterm.\n\treturn s\n}\n\n// NewSlogHandler returns a new logging handler that can be intrgrated with log/slog.\nfunc NewSlogHandler(logger *Logger) *SlogHandler {\n\treturn &SlogHandler{logger: logger}\n}\n"
        },
        {
          "name": "spinner_printer.go",
          "type": "blob",
          "size": 7.0732421875,
          "content": "package pterm\n\nimport (\n\t\"io\"\n\t\"os\"\n\t\"time\"\n\n\t\"github.com/pterm/pterm/internal\"\n)\n\nvar activeSpinnerPrinters []*SpinnerPrinter\n\n// DefaultSpinner is the default SpinnerPrinter.\nvar DefaultSpinner = SpinnerPrinter{\n\tSequence:            []string{\"▀ \", \" ▀\", \" ▄\", \"▄ \"},\n\tStyle:               &ThemeDefault.SpinnerStyle,\n\tDelay:               time.Millisecond * 200,\n\tShowTimer:           true,\n\tTimerRoundingFactor: time.Second,\n\tTimerStyle:          &ThemeDefault.TimerStyle,\n\tMessageStyle:        &ThemeDefault.SpinnerTextStyle,\n\tInfoPrinter:         &Info,\n\tSuccessPrinter:      &Success,\n\tFailPrinter:         &Error,\n\tWarningPrinter:      &Warning,\n\tWriter:              os.Stderr,\n}\n\n// SpinnerPrinter is a loading animation, which can be used if the progress is unknown.\n// It's an animation loop, which can have a text and supports throwing errors or warnings.\n// A TextPrinter is used to display all outputs, after the SpinnerPrinter is done.\ntype SpinnerPrinter struct {\n\tText                string\n\tSequence            []string\n\tStyle               *Style\n\tDelay               time.Duration\n\tMessageStyle        *Style\n\tInfoPrinter         TextPrinter\n\tSuccessPrinter      TextPrinter\n\tFailPrinter         TextPrinter\n\tWarningPrinter      TextPrinter\n\tRemoveWhenDone      bool\n\tShowTimer           bool\n\tTimerRoundingFactor time.Duration\n\tTimerStyle          *Style\n\n\tIsActive bool\n\n\tstartedAt       time.Time\n\tcurrentSequence string\n\n\tWriter io.Writer\n}\n\n// WithText adds a text to the SpinnerPrinter.\nfunc (s SpinnerPrinter) WithText(text string) *SpinnerPrinter {\n\ts.Text = text\n\treturn &s\n}\n\n// WithSequence adds a sequence to the SpinnerPrinter.\nfunc (s SpinnerPrinter) WithSequence(sequence ...string) *SpinnerPrinter {\n\ts.Sequence = sequence\n\treturn &s\n}\n\n// WithStyle adds a style to the SpinnerPrinter.\nfunc (s SpinnerPrinter) WithStyle(style *Style) *SpinnerPrinter {\n\ts.Style = style\n\treturn &s\n}\n\n// WithDelay adds a delay to the SpinnerPrinter.\nfunc (s SpinnerPrinter) WithDelay(delay time.Duration) *SpinnerPrinter {\n\ts.Delay = delay\n\treturn &s\n}\n\n// WithMessageStyle adds a style to the SpinnerPrinter message.\nfunc (s SpinnerPrinter) WithMessageStyle(style *Style) *SpinnerPrinter {\n\ts.MessageStyle = style\n\treturn &s\n}\n\n// WithRemoveWhenDone removes the SpinnerPrinter after it is done.\nfunc (s SpinnerPrinter) WithRemoveWhenDone(b ...bool) *SpinnerPrinter {\n\ts.RemoveWhenDone = internal.WithBoolean(b)\n\treturn &s\n}\n\n// WithShowTimer shows how long the spinner is running.\nfunc (s SpinnerPrinter) WithShowTimer(b ...bool) *SpinnerPrinter {\n\ts.ShowTimer = internal.WithBoolean(b)\n\treturn &s\n}\n\n// WithStartedAt sets the time when the SpinnerPrinter started.\nfunc (s SpinnerPrinter) WithStartedAt(t time.Time) *SpinnerPrinter {\n\ts.startedAt = t\n\treturn &s\n}\n\n// WithTimerRoundingFactor sets the rounding factor for the timer.\nfunc (s SpinnerPrinter) WithTimerRoundingFactor(factor time.Duration) *SpinnerPrinter {\n\ts.TimerRoundingFactor = factor\n\treturn &s\n}\n\n// WithTimerStyle adds a style to the SpinnerPrinter timer.\nfunc (s SpinnerPrinter) WithTimerStyle(style *Style) *SpinnerPrinter {\n\ts.TimerStyle = style\n\treturn &s\n}\n\n// WithWriter sets the custom Writer.\nfunc (p SpinnerPrinter) WithWriter(writer io.Writer) *SpinnerPrinter {\n\tp.Writer = writer\n\treturn &p\n}\n\n// SetWriter sets the custom Writer.\nfunc (p *SpinnerPrinter) SetWriter(writer io.Writer) {\n\tp.Writer = writer\n}\n\n// ResetTimer resets the timer of the SpinnerPrinter.\nfunc (s *SpinnerPrinter) ResetTimer() {\n\ts.startedAt = time.Now()\n}\n\n// SetStartedAt sets the time when the SpinnerPrinter started.\nfunc (s *SpinnerPrinter) SetStartedAt(t time.Time) {\n\ts.startedAt = t\n}\n\n// UpdateText updates the message of the active SpinnerPrinter.\n// Can be used live.\nfunc (s *SpinnerPrinter) UpdateText(text string) {\n\ts.Text = text\n\tif !RawOutput {\n\t\tFprinto(s.Writer, s.Style.Sprint(s.currentSequence)+\" \"+s.MessageStyle.Sprint(s.Text))\n\t} else {\n\t\tFprintln(s.Writer, s.Text)\n\t}\n}\n\n// Start the SpinnerPrinter.\nfunc (s SpinnerPrinter) Start(text ...any) (*SpinnerPrinter, error) {\n\ts.IsActive = true\n\ts.startedAt = time.Now()\n\tactiveSpinnerPrinters = append(activeSpinnerPrinters, &s)\n\n\tif len(text) != 0 {\n\t\ts.Text = Sprint(text...)\n\t}\n\n\tif RawOutput {\n\t\tFprintln(s.Writer, s.Text)\n\t}\n\n\tgo func() {\n\t\tfor s.IsActive {\n\t\t\tfor _, seq := range s.Sequence {\n\t\t\t\tif !s.IsActive {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\tif RawOutput {\n\t\t\t\t\ttime.Sleep(s.Delay)\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\n\t\t\t\tvar timer string\n\t\t\t\tif s.ShowTimer {\n\t\t\t\t\ttimer = \" (\" + time.Since(s.startedAt).Round(s.TimerRoundingFactor).String() + \")\"\n\t\t\t\t}\n\t\t\t\tFprinto(s.Writer, s.Style.Sprint(seq)+\" \"+s.MessageStyle.Sprint(s.Text)+s.TimerStyle.Sprint(timer))\n\t\t\t\ts.currentSequence = seq\n\t\t\t\ttime.Sleep(s.Delay)\n\t\t\t}\n\t\t}\n\t}()\n\treturn &s, nil\n}\n\n// Stop terminates the SpinnerPrinter immediately.\n// The SpinnerPrinter will not resolve into anything.\nfunc (s *SpinnerPrinter) Stop() error {\n\tif !s.IsActive {\n\t\treturn nil\n\t}\n\ts.IsActive = false\n\tif s.RemoveWhenDone {\n\t\tfClearLine(s.Writer)\n\t\tFprinto(s.Writer)\n\t} else {\n\t\tFprintln(s.Writer)\n\t}\n\treturn nil\n}\n\n// GenericStart runs Start, but returns a LivePrinter.\n// This is used for the interface LivePrinter.\n// You most likely want to use Start instead of this in your program.\nfunc (s *SpinnerPrinter) GenericStart() (*LivePrinter, error) {\n\tp2, _ := s.Start()\n\tlp := LivePrinter(p2)\n\treturn &lp, nil\n}\n\n// GenericStop runs Stop, but returns a LivePrinter.\n// This is used for the interface LivePrinter.\n// You most likely want to use Stop instead of this in your program.\nfunc (s *SpinnerPrinter) GenericStop() (*LivePrinter, error) {\n\t_ = s.Stop()\n\tlp := LivePrinter(s)\n\treturn &lp, nil\n}\n\n// Info displays an info message\n// If no message is given, the text of the SpinnerPrinter will be reused as the default message.\nfunc (s *SpinnerPrinter) Info(message ...any) {\n\tif s.InfoPrinter == nil {\n\t\ts.InfoPrinter = &Info\n\t}\n\n\tif len(message) == 0 {\n\t\tmessage = []any{s.Text}\n\t}\n\tfClearLine(s.Writer)\n\tFprinto(s.Writer, s.InfoPrinter.Sprint(message...))\n\t_ = s.Stop()\n}\n\n// Success displays the success printer.\n// If no message is given, the text of the SpinnerPrinter will be reused as the default message.\nfunc (s *SpinnerPrinter) Success(message ...any) {\n\tif s.SuccessPrinter == nil {\n\t\ts.SuccessPrinter = &Success\n\t}\n\n\tif len(message) == 0 {\n\t\tmessage = []any{s.Text}\n\t}\n\tfClearLine(s.Writer)\n\tFprinto(s.Writer, s.SuccessPrinter.Sprint(message...))\n\t_ = s.Stop()\n}\n\n// Fail displays the fail printer.\n// If no message is given, the text of the SpinnerPrinter will be reused as the default message.\nfunc (s *SpinnerPrinter) Fail(message ...any) {\n\tif s.FailPrinter == nil {\n\t\ts.FailPrinter = &Error\n\t}\n\n\tif len(message) == 0 {\n\t\tmessage = []any{s.Text}\n\t}\n\tfClearLine(s.Writer)\n\tFprinto(s.Writer, s.FailPrinter.Sprint(message...))\n\t_ = s.Stop()\n}\n\n// Warning displays the warning printer.\n// If no message is given, the text of the SpinnerPrinter will be reused as the default message.\nfunc (s *SpinnerPrinter) Warning(message ...any) {\n\tif s.WarningPrinter == nil {\n\t\ts.WarningPrinter = &Warning\n\t}\n\n\tif len(message) == 0 {\n\t\tmessage = []any{s.Text}\n\t}\n\tfClearLine(s.Writer)\n\tFprinto(s.Writer, s.WarningPrinter.Sprint(message...))\n\t_ = s.Stop()\n}\n"
        },
        {
          "name": "spinner_printer_test.go",
          "type": "blob",
          "size": 6.771484375,
          "content": "package pterm_test\n\nimport (\n\t\"io\"\n\t\"os\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/MarvinJWendt/testza\"\n\t\"github.com/pterm/pterm\"\n)\n\nfunc TestSpinnerPrinter_NilPrint(t *testing.T) {\n\tp := pterm.SpinnerPrinter{}\n\tp.Info()\n\tp.Success()\n\tp.Warning()\n\tp.Fail()\n}\n\nfunc TestSpinnerPrinter_Fail(t *testing.T) {\n\ttestPrintContains(t, func(w io.Writer, a any) {\n\t\tpterm.DefaultSpinner.WithWriter(w).Fail(a)\n\t})\n}\n\nfunc TestSpinnerPrinter_GenericStart(t *testing.T) {\n\tp := pterm.DefaultSpinner\n\tp.GenericStart()\n\tp.GenericStop()\n}\n\nfunc TestSpinnerPrinter_GenericStartRawOutput(t *testing.T) {\n\tpterm.DisableStyling()\n\tp := pterm.DefaultSpinner\n\tp.GenericStart()\n\tp.GenericStop()\n\tpterm.EnableStyling()\n}\n\nfunc TestSpinnerPrinter_GenericStop(t *testing.T) {\n\tp := pterm.DefaultSpinner\n\tp.GenericStop()\n}\n\nfunc TestSpinnerPrinter_Info(t *testing.T) {\n\ttestPrintContains(t, func(w io.Writer, a any) {\n\t\tpterm.DefaultSpinner.WithWriter(w).Info(a)\n\t})\n}\n\nfunc TestSpinnerPrinter_Success(t *testing.T) {\n\ttestPrintContains(t, func(w io.Writer, a any) {\n\t\tpterm.DefaultSpinner.WithWriter(w).Success(a)\n\t})\n}\n\nfunc TestSpinnerPrinter_UpdateText(t *testing.T) {\n\tt.Run(\"Simple\", func(t *testing.T) {\n\t\tp := pterm.DefaultSpinner\n\t\tp.Start()\n\t\tp.UpdateText(\"test\")\n\n\t\ttestza.AssertEqual(t, \"test\", p.Text)\n\t})\n\n\tt.Run(\"Override\", func(t *testing.T) {\n\t\tout := captureStdout(func(w io.Writer) {\n\t\t\t// Set a really long delay to make sure text doesn't get updated before function returns.\n\t\t\tp := pterm.DefaultSpinner.WithDelay(1 * time.Hour).WithWriter(w)\n\t\t\tp.Start(\"An initial long message\")\n\t\t\tp.UpdateText(\"A short message\")\n\t\t})\n\t\ttestza.AssertContains(t, out, \"A short message\")\n\t})\n}\n\nfunc TestSpinnerPrinter_UpdateTextRawOutput(t *testing.T) {\n\tpterm.DisableStyling()\n\tp := pterm.DefaultSpinner\n\tp.Start()\n\tp.UpdateText(\"test\")\n\n\ttestza.AssertEqual(t, \"test\", p.Text)\n\tp.Stop()\n\tpterm.EnableStyling()\n}\n\nfunc TestSpinnerPrinter_Warning(t *testing.T) {\n\ttestPrintContains(t, func(w io.Writer, a any) {\n\t\tpterm.DefaultSpinner.WithWriter(w).Warning(a)\n\t})\n}\n\nfunc TestSpinnerPrinter_WithDelay(t *testing.T) {\n\tp := pterm.SpinnerPrinter{}\n\tp2 := p.WithDelay(time.Second)\n\n\ttestza.AssertEqual(t, time.Second, p2.Delay)\n}\n\nfunc TestSpinnerPrinter_WithMessageStyle(t *testing.T) {\n\ts := pterm.NewStyle(pterm.FgRed, pterm.BgBlue, pterm.Bold)\n\tp := pterm.SpinnerPrinter{}\n\tp2 := p.WithMessageStyle(s)\n\n\ttestza.AssertEqual(t, s, p2.MessageStyle)\n}\n\nfunc TestSpinnerPrinter_WithRemoveWhenDone(t *testing.T) {\n\tp := pterm.SpinnerPrinter{}\n\tp2 := p.WithRemoveWhenDone()\n\n\ttestza.AssertTrue(t, p2.RemoveWhenDone)\n}\n\nfunc TestSpinnerPrinter_WithSequence(t *testing.T) {\n\tp := pterm.SpinnerPrinter{}\n\tp2 := p.WithSequence(\"a\", \"b\", \"c\")\n\n\ttestza.AssertEqual(t, []string{\"a\", \"b\", \"c\"}, p2.Sequence)\n}\n\nfunc TestSpinnerPrinter_WithStyle(t *testing.T) {\n\ts := pterm.NewStyle(pterm.FgRed, pterm.BgBlue, pterm.Bold)\n\tp := pterm.SpinnerPrinter{}\n\tp2 := p.WithStyle(s)\n\n\ttestza.AssertEqual(t, s, p2.Style)\n}\n\nfunc TestSpinnerPrinter_WithText(t *testing.T) {\n\tp := pterm.SpinnerPrinter{}\n\tp2 := p.WithText(\"test\")\n\n\ttestza.AssertEqual(t, \"test\", p2.Text)\n}\n\nfunc TestSpinnerPrinter_WithShowTimer(t *testing.T) {\n\tp := pterm.SpinnerPrinter{}\n\tp2 := p.WithShowTimer()\n\n\ttestza.AssertTrue(t, p2.ShowTimer)\n}\n\nfunc TestSpinnerPrinter_WithTimerStyle(t *testing.T) {\n\ts := pterm.NewStyle(pterm.FgRed, pterm.BgBlue, pterm.Bold)\n\tp := pterm.SpinnerPrinter{}\n\tp2 := p.WithTimerStyle(s)\n\n\ttestza.AssertEqual(t, s, p2.TimerStyle)\n}\n\nfunc TestSpinnerPrinter_WithTimerRoundingFactor(t *testing.T) {\n\ts := time.Millisecond * 200\n\tp := pterm.SpinnerPrinter{}\n\tp2 := p.WithTimerRoundingFactor(s)\n\n\ttestza.AssertEqual(t, s, p2.TimerRoundingFactor)\n}\n\nfunc TestSpinnerPrinter_WithRawOutput(t *testing.T) {\n\tpterm.RawOutput = true\n\ts, _ := pterm.DefaultSpinner.Start()\n\tgo func() {\n\t\ttime.Sleep(time.Millisecond * 50)\n\t\ts.Stop()\n\t\tpterm.RawOutput = false\n\t}()\n}\n\nfunc TestSpinnerPrinter_DifferentVariations(t *testing.T) {\n\ttype fields struct {\n\t\tText           string\n\t\tSequence       []string\n\t\tStyle          *pterm.Style\n\t\tDelay          time.Duration\n\t\tMessageStyle   *pterm.Style\n\t\tInfoPrinter    pterm.TextPrinter\n\t\tSuccessPrinter pterm.TextPrinter\n\t\tFailPrinter    pterm.TextPrinter\n\t\tWarningPrinter pterm.TextPrinter\n\t\tRemoveWhenDone bool\n\t\tIsActive       bool\n\t}\n\ttype args struct {\n\t\ttext []any\n\t}\n\ttests := []struct {\n\t\tname   string\n\t\tfields fields\n\t\targs   args\n\t}{\n\t\t{name: \"WithText\", fields: fields{Text: \"test\"}, args: args{}},\n\t\t{name: \"WithText\", fields: fields{}, args: args{[]any{\"test\"}}},\n\t\t{name: \"WithRemoveWhenDone\", fields: fields{RemoveWhenDone: true}, args: args{}},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\ts := pterm.SpinnerPrinter{\n\t\t\t\tText:           tt.fields.Text,\n\t\t\t\tSequence:       tt.fields.Sequence,\n\t\t\t\tStyle:          tt.fields.Style,\n\t\t\t\tDelay:          tt.fields.Delay,\n\t\t\t\tMessageStyle:   tt.fields.MessageStyle,\n\t\t\t\tInfoPrinter:    tt.fields.InfoPrinter,\n\t\t\t\tSuccessPrinter: tt.fields.SuccessPrinter,\n\t\t\t\tFailPrinter:    tt.fields.FailPrinter,\n\t\t\t\tWarningPrinter: tt.fields.WarningPrinter,\n\t\t\t\tRemoveWhenDone: tt.fields.RemoveWhenDone,\n\t\t\t\tIsActive:       tt.fields.IsActive,\n\t\t\t}\n\t\t\ts.Start(tt.args.text)\n\t\t\ts.Stop()\n\t\t})\n\t}\n}\n\nfunc TestSpinnerPrinter_WithWriter(t *testing.T) {\n\tp := pterm.SpinnerPrinter{}\n\ts := os.Stderr\n\tp2 := p.WithWriter(s)\n\n\ttestza.AssertEqual(t, s, p2.Writer)\n\ttestza.AssertZero(t, p.Writer)\n}\n\nfunc TestSpinnerPrinter_OutputToWriters(t *testing.T) {\n\ttestCases := map[string]struct {\n\t\taction                func(*pterm.SpinnerPrinter)\n\t\texpectOutputToContain string\n\t}{\n\t\t\"ExpectWarningMessageToBeWrittenToStderr\": {\n\t\t\taction:                func(sp *pterm.SpinnerPrinter) { sp.Warning(\"A warning\") },\n\t\t\texpectOutputToContain: \"A warning\",\n\t\t},\n\t\t\"ExpectFailMessageToBeWrittenToStderr\": {\n\t\t\taction:                func(sp *pterm.SpinnerPrinter) { sp.Fail(\"An error\") },\n\t\t\texpectOutputToContain: \"An error\",\n\t\t},\n\t\t\"ExpectUpdatedTextToBeWrittenToStderr\": {\n\t\t\taction: func(sp *pterm.SpinnerPrinter) {\n\t\t\t\tsp.UpdateText(\"Updated text\")\n\t\t\t},\n\t\t\texpectOutputToContain: \"Updated text\",\n\t\t},\n\t}\n\n\tfor testTitle, testCase := range testCases {\n\t\tt.Run(testTitle, func(t *testing.T) {\n\t\t\tstderr, err := testza.CaptureStderr(func(w io.Writer) error {\n\t\t\t\tsp, err := pterm.DefaultSpinner.WithText(\"Hello world\").WithWriter(os.Stderr).Start()\n\t\t\t\ttime.Sleep(time.Second) // Required otherwise the goroutine doesn't run and the text isnt outputted\n\t\t\t\ttestza.AssertNoError(t, err)\n\t\t\t\ttestCase.action(sp)\n\t\t\t\ttime.Sleep(time.Second) // Required otherwise the goroutine doesn't run and the text isnt updated\n\t\t\t\treturn nil\n\t\t\t})\n\n\t\t\ttestza.AssertNoError(t, err)\n\t\t\ttestza.AssertContains(t, stderr, \"Hello world\")\n\t\t\ttestza.AssertContains(t, stderr, testCase.expectOutputToContain)\n\t\t})\n\t}\n}\n\n// func TestClearActiveSpinners(t *testing.T) {\n// \tactiveSpinnerPrinters = []*pterm.SpinnerPrinter{}\n// }\n"
        },
        {
          "name": "table_printer.go",
          "type": "blob",
          "size": 7.9189453125,
          "content": "package pterm\n\nimport (\n\t\"encoding/csv\"\n\t\"io\"\n\t\"strings\"\n\n\t\"github.com/pterm/pterm/internal\"\n)\n\n// DefaultTable contains standards, which can be used to print a TablePrinter.\nvar DefaultTable = TablePrinter{\n\tStyle:                   &ThemeDefault.TableStyle,\n\tHeaderStyle:             &ThemeDefault.TableHeaderStyle,\n\tHeaderRowSeparator:      \"\",\n\tHeaderRowSeparatorStyle: &ThemeDefault.TableSeparatorStyle,\n\tSeparator:               \" | \",\n\tSeparatorStyle:          &ThemeDefault.TableSeparatorStyle,\n\tRowSeparator:            \"\",\n\tRowSeparatorStyle:       &ThemeDefault.TableSeparatorStyle,\n\tLeftAlignment:           true,\n\tRightAlignment:          false,\n}\n\n// TableData is the type that contains the data of a TablePrinter.\ntype TableData [][]string\n\n// TablePrinter is able to render tables.\ntype TablePrinter struct {\n\tStyle                   *Style\n\tHasHeader               bool\n\tHeaderStyle             *Style\n\tHeaderRowSeparator      string\n\tHeaderRowSeparatorStyle *Style\n\tSeparator               string\n\tSeparatorStyle          *Style\n\tRowSeparator            string\n\tRowSeparatorStyle       *Style\n\tData                    TableData\n\tBoxed                   bool\n\tLeftAlignment           bool\n\tRightAlignment          bool\n\tWriter                  io.Writer\n\tAlternateRowStyle       *Style\n}\n\n// WithStyle returns a new TablePrinter with a specific Style.\nfunc (p TablePrinter) WithStyle(style *Style) *TablePrinter {\n\tp.Style = style\n\treturn &p\n}\n\n// WithHasHeader returns a new TablePrinter, where the first line is marked as a header.\nfunc (p TablePrinter) WithHasHeader(b ...bool) *TablePrinter {\n\tp.HasHeader = internal.WithBoolean(b)\n\treturn &p\n}\n\n// WithHeaderStyle returns a new TablePrinter with a specific HeaderStyle.\nfunc (p TablePrinter) WithHeaderStyle(style *Style) *TablePrinter {\n\tp.HeaderStyle = style\n\treturn &p\n}\n\n// WithHeaderRowSeparator returns a new TablePrinter with a specific header HeaderRowSeparator.\nfunc (p TablePrinter) WithHeaderRowSeparator(separator string) *TablePrinter {\n\tp.HeaderRowSeparator = separator\n\treturn &p\n}\n\n// WithHeaderRowSeparatorStyle returns a new TablePrinter with a specific header HeaderRowSeparatorStyle.\nfunc (p TablePrinter) WithHeaderRowSeparatorStyle(style *Style) *TablePrinter {\n\tp.HeaderRowSeparatorStyle = style\n\treturn &p\n}\n\n// WithSeparator returns a new TablePrinter with a specific separator.\nfunc (p TablePrinter) WithSeparator(separator string) *TablePrinter {\n\tp.Separator = separator\n\treturn &p\n}\n\n// WithSeparatorStyle returns a new TablePrinter with a specific SeparatorStyle.\nfunc (p TablePrinter) WithSeparatorStyle(style *Style) *TablePrinter {\n\tp.SeparatorStyle = style\n\treturn &p\n}\n\n// WithRowSeparator returns a new TablePrinter with a specific RowSeparator.\nfunc (p TablePrinter) WithRowSeparator(separator string) *TablePrinter {\n\tp.RowSeparator = separator\n\treturn &p\n}\n\n// WithRowSeparatorStyle returns a new TablePrinter with a specific RowSeparatorStyle.\nfunc (p TablePrinter) WithRowSeparatorStyle(style *Style) *TablePrinter {\n\tp.RowSeparatorStyle = style\n\treturn &p\n}\n\n// WithData returns a new TablePrinter with specific Data.\nfunc (p TablePrinter) WithData(data [][]string) *TablePrinter {\n\tp.Data = data\n\treturn &p\n}\n\n// WithCSVReader returns a new TablePrinter with specified Data extracted from CSV.\nfunc (p TablePrinter) WithCSVReader(reader *csv.Reader) *TablePrinter {\n\tif records, err := reader.ReadAll(); err == nil {\n\t\tp.Data = records\n\t}\n\treturn &p\n}\n\n// WithBoxed returns a new TablePrinter with a box around the table.\nfunc (p TablePrinter) WithBoxed(b ...bool) *TablePrinter {\n\tp.Boxed = internal.WithBoolean(b)\n\treturn &p\n}\n\n// WithLeftAlignment returns a new TablePrinter with left alignment.\nfunc (p TablePrinter) WithLeftAlignment(b ...bool) *TablePrinter {\n\tb2 := internal.WithBoolean(b)\n\tp.LeftAlignment = b2\n\tp.RightAlignment = false\n\treturn &p\n}\n\n// WithRightAlignment returns a new TablePrinter with right alignment.\nfunc (p TablePrinter) WithRightAlignment(b ...bool) *TablePrinter {\n\tb2 := internal.WithBoolean(b)\n\tp.LeftAlignment = false\n\tp.RightAlignment = b2\n\treturn &p\n}\n\n// WithWriter sets the Writer.\nfunc (p TablePrinter) WithWriter(writer io.Writer) *TablePrinter {\n\tp.Writer = writer\n\treturn &p\n}\n\n// WithAlternateRowStyle returns a new TablePrinter with a specific AlternateRowStyle.\nfunc (p TablePrinter) WithAlternateRowStyle(style *Style) *TablePrinter {\n\tp.AlternateRowStyle = style\n\treturn &p\n}\n\ntype table struct {\n\trows            []row\n\tmaxColumnWidths []int\n}\n\ntype row struct {\n\theight int\n\tcells  []cell\n}\n\ntype cell struct {\n\twidth  int\n\theight int\n\tlines  []string\n}\n\n// Srender renders the TablePrinter as a string.\nfunc (p TablePrinter) Srender() (string, error) {\n\tif p.Style == nil {\n\t\tp.Style = NewStyle()\n\t}\n\tif p.SeparatorStyle == nil {\n\t\tp.SeparatorStyle = NewStyle()\n\t}\n\tif p.HeaderStyle == nil {\n\t\tp.HeaderStyle = NewStyle()\n\t}\n\tif p.HeaderRowSeparatorStyle == nil {\n\t\tp.HeaderRowSeparatorStyle = NewStyle()\n\t}\n\tif p.RowSeparatorStyle == nil {\n\t\tp.RowSeparatorStyle = NewStyle()\n\t}\n\n\tvar t table\n\n\t// convert data to table and calculate values\n\tfor _, rRaw := range p.Data {\n\t\tvar r row\n\t\tfor _, cRaw := range rRaw {\n\t\t\tvar c cell\n\t\t\tc.lines = strings.Split(cRaw, \"\\n\")\n\t\t\tc.height = len(c.lines)\n\t\t\tfor _, l := range c.lines {\n\t\t\t\tif maxWidth := internal.GetStringMaxWidth(l); maxWidth > c.width {\n\t\t\t\t\tc.width = maxWidth\n\t\t\t\t}\n\t\t\t}\n\t\t\tr.cells = append(r.cells, c)\n\t\t\tif c.height > r.height {\n\t\t\t\tr.height = c.height\n\t\t\t}\n\t\t}\n\n\t\t// set max column widths of table\n\t\tfor i, c := range r.cells {\n\t\t\tif len(t.maxColumnWidths) <= i {\n\t\t\t\tt.maxColumnWidths = append(t.maxColumnWidths, c.width)\n\t\t\t} else if c.width > t.maxColumnWidths[i] {\n\t\t\t\tt.maxColumnWidths[i] = c.width\n\t\t\t}\n\t\t}\n\n\t\tt.rows = append(t.rows, r)\n\t}\n\n\tvar maxRowWidth int\n\tfor _, r := range t.rows {\n\t\trowWidth := internal.GetStringMaxWidth(p.renderRow(t, r))\n\t\tif rowWidth > maxRowWidth {\n\t\t\tmaxRowWidth = rowWidth\n\t\t}\n\t}\n\n\t// render table\n\tvar ret strings.Builder\n\n\tfor i, r := range t.rows {\n\t\tif i == 0 && p.HasHeader {\n\t\t\tret.WriteString(p.HeaderStyle.Sprint(p.renderRow(t, r)))\n\n\t\t\tif p.HeaderRowSeparator != \"\" {\n\t\t\t\tret.WriteString(strings.Repeat(p.HeaderRowSeparatorStyle.Sprint(p.HeaderRowSeparator), maxRowWidth))\n\t\t\t\tret.WriteByte('\\n')\n\t\t\t}\n\t\t\tcontinue\n\t\t}\n\n\t\t// Apply AlternateRowStyle if needed\n\t\tif i%2 == 1 && p.AlternateRowStyle != nil {\n\t\t\tret.WriteString(p.AlternateRowStyle.Sprint(p.renderRow(t, r)))\n\t\t} else {\n\t\t\tret.WriteString(p.renderRow(t, r))\n\t\t}\n\n\t\tif p.RowSeparator != \"\" && i < len(t.rows)-1 {\n\t\t\tret.WriteString(strings.Repeat(p.RowSeparatorStyle.Sprint(p.RowSeparator), maxRowWidth) + \"\\n\")\n\t\t}\n\t}\n\n\tif p.Boxed {\n\t\treturn DefaultBox.Sprint(strings.TrimSuffix(ret.String(), \"\\n\")), nil\n\t}\n\n\treturn ret.String(), nil\n}\n\n// renderRow renders a row.\n// It merges the cells of a row into one string.\n// Each line of each cell is merged with the same line of the other cells.\nfunc (p TablePrinter) renderRow(t table, r row) string {\n\tvar s string\n\n\t// Merge lines of cells and add separator\n\t// Use t.maxColumnWidths to add padding to corresponding cell\n\t// A newline in a cell should be in the same column as original cell\n\tfor i := 0; i < r.height; i++ {\n\t\tfor j, c := range r.cells {\n\t\t\tvar currentLine string\n\t\t\tif i < len(c.lines) {\n\t\t\t\tcurrentLine = c.lines[i]\n\t\t\t}\n\t\t\tpaddingForLine := t.maxColumnWidths[j] - internal.GetStringMaxWidth(currentLine)\n\n\t\t\t// Add right alignment if necessary\n\t\t\tif p.RightAlignment {\n\t\t\t\ts += strings.Repeat(\" \", paddingForLine)\n\t\t\t}\n\n\t\t\t// Add line content\n\t\t\tif i < len(c.lines) {\n\t\t\t\ts += c.lines[i]\n\t\t\t}\n\n\t\t\t// Add padding for left alignment, except for last column\n\t\t\tif j < len(r.cells)-1 {\n\t\t\t\tif p.LeftAlignment {\n\t\t\t\t\ts += strings.Repeat(\" \", paddingForLine)\n\t\t\t\t}\n\t\t\t\ts += p.SeparatorStyle.Sprint(p.Separator)\n\t\t\t} else if p.LeftAlignment {\n\t\t\t\t// Add padding after last column\n\t\t\t\ts += strings.Repeat(\" \", paddingForLine)\n\t\t\t}\n\t\t}\n\t\ts += \"\\n\"\n\t}\n\n\treturn s\n}\n\n// Render prints the TablePrinter to the terminal.\nfunc (p TablePrinter) Render() error {\n\ts, _ := p.Srender()\n\tFprintln(p.Writer, s)\n\n\treturn nil\n}\n"
        },
        {
          "name": "table_printer_test.go",
          "type": "blob",
          "size": 5.3837890625,
          "content": "package pterm_test\n\nimport (\n\t\"encoding/csv\"\n\t\"io\"\n\t\"os\"\n\t\"testing\"\n\n\t\"github.com/MarvinJWendt/testza\"\n\n\t\"github.com/pterm/pterm\"\n)\n\nfunc TestTablePrinter_NilPrint(t *testing.T) {\n\tp := pterm.TablePrinter{}\n\tp.Render()\n}\n\nfunc TestTablePrinter_Render(t *testing.T) {\n\td := pterm.TableData{\n\t\t{\"Firstname\", \"Lastname\", \"Email\"},\n\t\t{\"Paul\", \"Dean\", \"nisi.dictum.augue@velitAliquam.co.uk\"},\n\t\t{\"Callie\", \"Mckay\", \"egestas.nunc.sed@est.com\"},\n\t\t{\"Libby\", \"Camacho\", \"aliquet.lobortis@semper.com\"},\n\t}\n\t// WithLeftAlignment\n\tprinter := pterm.DefaultTable.WithHasHeader().WithLeftAlignment().WithData(d)\n\tcontent, err := printer.Srender()\n\n\ttestza.AssertNoError(t, err)\n\ttestza.AssertNotNil(t, content)\n\t// WithRightAlignment\n\tprinter = pterm.DefaultTable.WithHasHeader().WithRightAlignment().WithData(d)\n\tcontent, err = printer.Srender()\n\n\ttestza.AssertNoError(t, err)\n\ttestza.AssertNotNil(t, content)\n}\n\nfunc TestTablePrinterWithAlternateStyle_Render(t *testing.T) {\n\td := pterm.TableData{\n\t\t{\"Firstname\", \"Lastname\", \"Email\"},\n\t\t{\"Paul\", \"Dean\", \"nisi.dictum.augue@velitAliquam.co.uk\"},\n\t\t{\"Callie\", \"Mckay\", \"egestas.nunc.sed@est.com\"},\n\t\t{\"Libby\", \"Camacho\", \"aliquet.lobortis@semper.com\"},\n\t}\n\n\t// Define the alternate row style\n\talternateStyle := pterm.NewStyle(pterm.BgDarkGray)\n\n\t// Create a printer with the alternate row style\n\tprinter := pterm.DefaultTable.WithHasHeader().WithAlternateRowStyle(alternateStyle).WithData(d)\n\tcontent, err := printer.Srender()\n\ttestza.AssertNoError(t, err)\n\ttestza.AssertNotNil(t, content)\n}\n\nfunc TestTablePrinterWithRowSeparators_Render(t *testing.T) {\n\td := pterm.TableData{\n\t\t{\"Firstname\", \"Lastname\", \"Email\"},\n\t\t{\"Paul\", \"Dean\", \"nisi.dictum.augue@velitAliquam.co.uk\"},\n\t\t{\"Callie\", \"Mckay\", \"egestas.nunc.sed@est.com\"},\n\t\t{\"Libby\", \"Camacho\", \"aliquet.lobortis@semper.com\"},\n\t}\n\t// WithHeaderSeparator\n\tprinter := pterm.DefaultTable.WithHasHeader().WithHeaderRowSeparator(\"=\").WithData(d)\n\tcontent, err := printer.Srender()\n\ttestza.AssertNoError(t, err)\n\ttestza.AssertNotNil(t, content)\n\t// WithRowSeparator\n\tprinter = pterm.DefaultTable.WithHasHeader().WithRowSeparator(\"-\").WithData(d)\n\tcontent, err = printer.Srender()\n\ttestza.AssertNoError(t, err)\n\ttestza.AssertNotNil(t, content)\n\t// WithHeaderRowSeparator & WithRowSeparator\n\tprinter = pterm.DefaultTable.WithHasHeader().WithHeaderRowSeparator(\"=\").WithRowSeparator(\"-\").WithData(d)\n\tcontent, err = printer.Srender()\n\ttestza.AssertNoError(t, err)\n\ttestza.AssertNotNil(t, content)\n}\n\nfunc TestTablePrinter_WithCSVReader(t *testing.T) {\n\tcontent := captureStdout(func(w io.Writer) {\n\t\tr := csv.NewReader(&outBuf)\n\t\tp := pterm.TablePrinter{}\n\t\tp.WithCSVReader(r)\n\t})\n\ttestza.AssertNotNil(t, content)\n}\n\nfunc TestTablePrinter_WithBoxed(t *testing.T) {\n\t_, err := pterm.DefaultTable.WithBoxed().Srender()\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n}\n\nfunc TestTablePrinter_WithData(t *testing.T) {\n\tproxyToDevNull()\n\td := pterm.TableData{\n\t\t{\"Firstname\", \"Lastname\", \"Email\"},\n\t\t{\"Paul\", \"Dean\", \"nisi.dictum.augue@velitAliquam.co.uk\"},\n\t\t{\"Callie\", \"Mckay\", \"egestas.nunc.sed@est.com\"},\n\t\t{\"Libby\", \"Camacho\", \"aliquet.lobortis@semper.com\"},\n\t}\n\tp := pterm.TablePrinter{}\n\tp2 := p.WithData(d)\n\n\ttestza.AssertEqual(t, d, p2.Data)\n}\n\nfunc TestTablePrinter_WithHasHeader(t *testing.T) {\n\tp := pterm.TablePrinter{}\n\tp2 := p.WithHasHeader()\n\n\ttestza.AssertTrue(t, p2.HasHeader)\n}\n\nfunc TestTablePrinter_WithHeaderStyle(t *testing.T) {\n\ts := pterm.NewStyle(pterm.FgRed, pterm.BgBlue, pterm.Bold)\n\tp := pterm.TablePrinter{}\n\tp2 := p.WithHeaderStyle(s)\n\n\ttestza.AssertEqual(t, s, p2.HeaderStyle)\n}\n\nfunc TestTablePrinter_WithSeparator(t *testing.T) {\n\tp := pterm.TablePrinter{}\n\tp2 := p.WithSeparator(\"-\")\n\n\ttestza.AssertEqual(t, \"-\", p2.Separator)\n}\n\nfunc TestTablePrinter_WithSeparatorStyle(t *testing.T) {\n\ts := pterm.NewStyle(pterm.FgRed, pterm.BgBlue, pterm.Bold)\n\tp := pterm.TablePrinter{}\n\tp2 := p.WithSeparatorStyle(s)\n\n\ttestza.AssertEqual(t, s, p2.SeparatorStyle)\n}\n\nfunc TestTablePrinter_WithHeaderRowSeparator(t *testing.T) {\n\tp := pterm.TablePrinter{}\n\tp2 := p.WithHeaderRowSeparator(\"-\")\n\n\ttestza.AssertEqual(t, \"-\", p2.HeaderRowSeparator)\n}\n\nfunc TestTablePrinter_WithHeaderRowSeparatorStyle(t *testing.T) {\n\ts := pterm.NewStyle(pterm.FgRed, pterm.BgBlue, pterm.Bold)\n\tp := pterm.TablePrinter{}\n\tp2 := p.WithHeaderRowSeparatorStyle(s)\n\n\ttestza.AssertEqual(t, s, p2.HeaderRowSeparatorStyle)\n}\n\nfunc TestTablePrinter_WithRowSeparator(t *testing.T) {\n\tp := pterm.TablePrinter{}\n\tp2 := p.WithRowSeparator(\"-\")\n\n\ttestza.AssertEqual(t, \"-\", p2.RowSeparator)\n}\n\nfunc TestTablePrinter_WithRowSeparatorStyle(t *testing.T) {\n\ts := pterm.NewStyle(pterm.FgRed, pterm.BgBlue, pterm.Bold)\n\tp := pterm.TablePrinter{}\n\tp2 := p.WithRowSeparatorStyle(s)\n\n\ttestza.AssertEqual(t, s, p2.RowSeparatorStyle)\n}\n\nfunc TestTablePrinter_WithStyle(t *testing.T) {\n\ts := pterm.NewStyle(pterm.FgRed, pterm.BgBlue, pterm.Bold)\n\tp := pterm.TablePrinter{}\n\tp2 := p.WithStyle(s)\n\n\ttestza.AssertEqual(t, s, p2.Style)\n}\n\nfunc TestTablePrinter_WithLeftAlignment(t *testing.T) {\n\ts := true\n\tp := pterm.TablePrinter{}\n\tp2 := p.WithLeftAlignment(s)\n\n\ttestza.AssertEqual(t, s, p2.LeftAlignment)\n}\n\nfunc TestTablePrinter_WithRightAlignment(t *testing.T) {\n\ts := true\n\tp := pterm.TablePrinter{}\n\tp2 := p.WithRightAlignment(s)\n\n\ttestza.AssertEqual(t, s, p2.RightAlignment)\n}\n\nfunc TestTablePrinter_WithWriter(t *testing.T) {\n\tp := pterm.TablePrinter{}\n\ts := os.Stderr\n\tp2 := p.WithWriter(s)\n\n\ttestza.AssertEqual(t, s, p2.Writer)\n\ttestza.AssertZero(t, p.Writer)\n}\n"
        },
        {
          "name": "terminal.go",
          "type": "blob",
          "size": 1.7763671875,
          "content": "package pterm\n\nimport (\n\t\"os\"\n\n\t\"golang.org/x/term\"\n)\n\n// FallbackTerminalWidth is the value used for GetTerminalWidth, if the actual width can not be detected\n// You can override that value if necessary.\nvar FallbackTerminalWidth = 80\n\n// FallbackTerminalHeight is the value used for GetTerminalHeight, if the actual height can not be detected\n// You can override that value if necessary.\nvar FallbackTerminalHeight = 10\n\n// forcedTerminalWidth, when set along with forcedTerminalHeight, forces the terminal width value.\nvar forcedTerminalWidth int = 0\n\n// forcedTerminalHeight, when set along with forcedTerminalWidth, forces the terminal height value.\nvar forcedTerminalHeight int = 0\n\n// GetTerminalWidth returns the terminal width of the active terminal.\nfunc GetTerminalWidth() int {\n\tif forcedTerminalWidth > 0 {\n\t\treturn forcedTerminalWidth\n\t}\n\twidth, _, _ := GetTerminalSize()\n\treturn width\n}\n\n// GetTerminalHeight returns the terminal height of the active terminal.\nfunc GetTerminalHeight() int {\n\tif forcedTerminalHeight > 0 {\n\t\treturn forcedTerminalHeight\n\t}\n\t_, height, _ := GetTerminalSize()\n\treturn height\n}\n\n// GetTerminalSize returns the width and the height of the active terminal.\nfunc GetTerminalSize() (width, height int, err error) {\n\tif forcedTerminalWidth > 0 && forcedTerminalHeight > 0 {\n\t\treturn forcedTerminalWidth, forcedTerminalHeight, nil\n\t}\n\tw, h, err := term.GetSize(int(os.Stdout.Fd()))\n\tif w <= 0 {\n\t\tw = FallbackTerminalWidth\n\t}\n\tif h <= 0 {\n\t\th = FallbackTerminalHeight\n\t}\n\tif err != nil {\n\t\terr = ErrTerminalSizeNotDetectable\n\t}\n\treturn w, h, err\n}\n\n// setForcedTerminalSize turns off terminal size autodetection. Usuful for unified tests.\nfunc SetForcedTerminalSize(width int, height int) {\n\tforcedTerminalWidth = width\n\tforcedTerminalHeight = height\n\tRecalculateTerminalSize()\n}\n"
        },
        {
          "name": "terminal_test.go",
          "type": "blob",
          "size": 1.4189453125,
          "content": "package pterm_test\n\nimport (\n\t\"os\"\n\t\"testing\"\n\n\t\"github.com/MarvinJWendt/testza\"\n\t\"github.com/pterm/pterm\"\n\t\"golang.org/x/term\"\n)\n\nfunc TestSetForcedTerminalSize(t *testing.T) {\n\tpterm.SetForcedTerminalSize(1, 1)\n\tw, h, _ := pterm.GetTerminalSize()\n\ttestza.AssertEqual(t, w, 1)\n\ttestza.AssertEqual(t, h, 1)\n\tw = pterm.GetTerminalWidth()\n\th = pterm.GetTerminalHeight()\n\ttestza.AssertEqual(t, w, 1)\n\ttestza.AssertEqual(t, h, 1)\n}\n\nfunc autodetectTerminalSize() (int, int) {\n\texpectedW, expectedH, _ := term.GetSize(int(os.Stdout.Fd()))\n\t// CI goes to fallback values\n\tif expectedW <= 0 {\n\t\texpectedW = pterm.FallbackTerminalWidth\n\t\texpectedH = pterm.FallbackTerminalHeight\n\t}\n\treturn expectedW, expectedH\n}\n\nfunc TestGetTerminalSizeAutodetect(t *testing.T) {\n\t// enable autodetection\n\tpterm.SetForcedTerminalSize(0, 0)\n\texpectedW, expectedH := autodetectTerminalSize()\n\tw, h, _ := pterm.GetTerminalSize()\n\ttestza.AssertEqual(t, expectedW, w)\n\ttestza.AssertEqual(t, expectedH, h)\n\t// disable autodetection\n\tpterm.SetForcedTerminalSize(terminalWidth, terminalHeight)\n}\n\nfunc TestGetTerminalSizeAutodetect2(t *testing.T) {\n\t// enable autodetection\n\tpterm.SetForcedTerminalSize(0, 0)\n\texpectedW, expectedH := autodetectTerminalSize()\n\tw := pterm.GetTerminalWidth()\n\th := pterm.GetTerminalHeight()\n\ttestza.AssertEqual(t, expectedW, w)\n\ttestza.AssertEqual(t, expectedH, h)\n\t// disable autodetection\n\tpterm.SetForcedTerminalSize(terminalWidth, terminalHeight)\n}\n"
        },
        {
          "name": "theme.go",
          "type": "blob",
          "size": 7.8115234375,
          "content": "package pterm\n\nvar (\n\t// ThemeDefault is the default theme used by PTerm.\n\t// If this variable is overwritten, the new value is used as default theme.\n\tThemeDefault = Theme{\n\t\tDefaultText:             Style{FgDefault, BgDefault},\n\t\tPrimaryStyle:            Style{FgLightCyan},\n\t\tSecondaryStyle:          Style{FgLightMagenta},\n\t\tHighlightStyle:          Style{Bold, FgYellow},\n\t\tInfoMessageStyle:        Style{FgLightCyan},\n\t\tInfoPrefixStyle:         Style{FgBlack, BgCyan},\n\t\tSuccessMessageStyle:     Style{FgGreen},\n\t\tSuccessPrefixStyle:      Style{FgBlack, BgGreen},\n\t\tWarningMessageStyle:     Style{FgYellow},\n\t\tWarningPrefixStyle:      Style{FgBlack, BgYellow},\n\t\tErrorMessageStyle:       Style{FgLightRed},\n\t\tErrorPrefixStyle:        Style{FgBlack, BgLightRed},\n\t\tFatalMessageStyle:       Style{FgLightRed},\n\t\tFatalPrefixStyle:        Style{FgBlack, BgLightRed},\n\t\tDescriptionMessageStyle: Style{FgDefault},\n\t\tDescriptionPrefixStyle:  Style{FgLightWhite, BgDarkGray},\n\t\tScopeStyle:              Style{FgGray},\n\t\tProgressbarBarStyle:     Style{FgCyan},\n\t\tProgressbarTitleStyle:   Style{FgLightCyan},\n\t\tHeaderTextStyle:         Style{FgLightWhite, Bold},\n\t\tHeaderBackgroundStyle:   Style{BgGray},\n\t\tSpinnerStyle:            Style{FgLightCyan},\n\t\tSpinnerTextStyle:        Style{FgLightWhite},\n\t\tTableStyle:              Style{FgDefault},\n\t\tTableHeaderStyle:        Style{FgLightCyan},\n\t\tTableSeparatorStyle:     Style{FgGray},\n\t\tHeatmapStyle:            Style{FgDefault},\n\t\tHeatmapHeaderStyle:      Style{FgLightCyan},\n\t\tHeatmapSeparatorStyle:   Style{FgDefault},\n\t\tSectionStyle:            Style{Bold, FgYellow},\n\t\tBulletListTextStyle:     Style{FgDefault},\n\t\tBulletListBulletStyle:   Style{FgGray},\n\t\tTreeStyle:               Style{FgGray},\n\t\tTreeTextStyle:           Style{FgDefault},\n\t\tLetterStyle:             Style{FgDefault},\n\t\tDebugMessageStyle:       Style{FgGray},\n\t\tDebugPrefixStyle:        Style{FgBlack, BgGray},\n\t\tBoxStyle:                Style{FgDefault},\n\t\tBoxTextStyle:            Style{FgDefault},\n\t\tBarLabelStyle:           Style{FgLightCyan},\n\t\tBarStyle:                Style{FgCyan},\n\t\tTimerStyle:              Style{FgGray},\n\t\tCheckmark: Checkmark{\n\t\t\tChecked:   Green(\"✓\"),\n\t\t\tUnchecked: Red(\"✗\"),\n\t\t},\n\t}\n)\n\n// Theme for PTerm.\n// Theme contains every Style used in PTerm. You can create own themes for your application or use one\n// of the existing themes.\ntype Theme struct {\n\tDefaultText             Style\n\tPrimaryStyle            Style\n\tSecondaryStyle          Style\n\tHighlightStyle          Style\n\tInfoMessageStyle        Style\n\tInfoPrefixStyle         Style\n\tSuccessMessageStyle     Style\n\tSuccessPrefixStyle      Style\n\tWarningMessageStyle     Style\n\tWarningPrefixStyle      Style\n\tErrorMessageStyle       Style\n\tErrorPrefixStyle        Style\n\tFatalMessageStyle       Style\n\tFatalPrefixStyle        Style\n\tDescriptionMessageStyle Style\n\tDescriptionPrefixStyle  Style\n\tScopeStyle              Style\n\tProgressbarBarStyle     Style\n\tProgressbarTitleStyle   Style\n\tHeaderTextStyle         Style\n\tHeaderBackgroundStyle   Style\n\tSpinnerStyle            Style\n\tSpinnerTextStyle        Style\n\tTimerStyle              Style\n\tTableStyle              Style\n\tTableHeaderStyle        Style\n\tTableSeparatorStyle     Style\n\tHeatmapStyle            Style\n\tHeatmapHeaderStyle      Style\n\tHeatmapSeparatorStyle   Style\n\tSectionStyle            Style\n\tBulletListTextStyle     Style\n\tBulletListBulletStyle   Style\n\tTreeStyle               Style\n\tTreeTextStyle           Style\n\tLetterStyle             Style\n\tDebugMessageStyle       Style\n\tDebugPrefixStyle        Style\n\tBoxStyle                Style\n\tBoxTextStyle            Style\n\tBarLabelStyle           Style\n\tBarStyle                Style\n\tCheckmark               Checkmark\n}\n\n// WithPrimaryStyle returns a new theme with overridden value.\nfunc (t Theme) WithPrimaryStyle(style Style) Theme {\n\tt.PrimaryStyle = style\n\treturn t\n}\n\n// WithSecondaryStyle returns a new theme with overridden value.\nfunc (t Theme) WithSecondaryStyle(style Style) Theme {\n\tt.SecondaryStyle = style\n\treturn t\n}\n\n// WithHighlightStyle returns a new theme with overridden value.\nfunc (t Theme) WithHighlightStyle(style Style) Theme {\n\tt.HighlightStyle = style\n\treturn t\n}\n\n// WithInfoMessageStyle returns a new theme with overridden value.\nfunc (t Theme) WithInfoMessageStyle(style Style) Theme {\n\tt.InfoMessageStyle = style\n\treturn t\n}\n\n// WithInfoPrefixStyle returns a new theme with overridden value.\nfunc (t Theme) WithInfoPrefixStyle(style Style) Theme {\n\tt.InfoPrefixStyle = style\n\treturn t\n}\n\n// WithSuccessMessageStyle returns a new theme with overridden value.\nfunc (t Theme) WithSuccessMessageStyle(style Style) Theme {\n\tt.SuccessMessageStyle = style\n\treturn t\n}\n\n// WithSuccessPrefixStyle returns a new theme with overridden value.\nfunc (t Theme) WithSuccessPrefixStyle(style Style) Theme {\n\tt.SuccessPrefixStyle = style\n\treturn t\n}\n\n// WithWarningMessageStyle returns a new theme with overridden value.\nfunc (t Theme) WithWarningMessageStyle(style Style) Theme {\n\tt.WarningMessageStyle = style\n\treturn t\n}\n\n// WithWarningPrefixStyle returns a new theme with overridden value.\nfunc (t Theme) WithWarningPrefixStyle(style Style) Theme {\n\tt.WarningPrefixStyle = style\n\treturn t\n}\n\n// WithErrorMessageStyle returns a new theme with overridden value.\nfunc (t Theme) WithErrorMessageStyle(style Style) Theme {\n\tt.ErrorMessageStyle = style\n\treturn t\n}\n\n// WithErrorPrefixStyle returns a new theme with overridden value.\nfunc (t Theme) WithErrorPrefixStyle(style Style) Theme {\n\tt.ErrorPrefixStyle = style\n\treturn t\n}\n\n// WithFatalMessageStyle returns a new theme with overridden value.\nfunc (t Theme) WithFatalMessageStyle(style Style) Theme {\n\tt.FatalMessageStyle = style\n\treturn t\n}\n\n// WithFatalPrefixStyle returns a new theme with overridden value.\nfunc (t Theme) WithFatalPrefixStyle(style Style) Theme {\n\tt.FatalPrefixStyle = style\n\treturn t\n}\n\n// WithDescriptionMessageStyle returns a new theme with overridden value.\nfunc (t Theme) WithDescriptionMessageStyle(style Style) Theme {\n\tt.DescriptionMessageStyle = style\n\treturn t\n}\n\n// WithDescriptionPrefixStyle returns a new theme with overridden value.\nfunc (t Theme) WithDescriptionPrefixStyle(style Style) Theme {\n\tt.DescriptionPrefixStyle = style\n\treturn t\n}\n\n// WithBulletListTextStyle returns a new theme with overridden value.\nfunc (t Theme) WithBulletListTextStyle(style Style) Theme {\n\tt.BulletListTextStyle = style\n\treturn t\n}\n\n// WithBulletListBulletStyle returns a new theme with overridden value.\nfunc (t Theme) WithBulletListBulletStyle(style Style) Theme {\n\tt.BulletListBulletStyle = style\n\treturn t\n}\n\n// WithLetterStyle returns a new theme with overridden value.\nfunc (t Theme) WithLetterStyle(style Style) Theme {\n\tt.LetterStyle = style\n\treturn t\n}\n\n// WithDebugMessageStyle returns a new theme with overridden value.\nfunc (t Theme) WithDebugMessageStyle(style Style) Theme {\n\tt.DebugMessageStyle = style\n\treturn t\n}\n\n// WithDebugPrefixStyle returns a new theme with overridden value.\nfunc (t Theme) WithDebugPrefixStyle(style Style) Theme {\n\tt.DebugPrefixStyle = style\n\treturn t\n}\n\n// WithTreeStyle returns a new theme with overridden value.\nfunc (t Theme) WithTreeStyle(style Style) Theme {\n\tt.TreeStyle = style\n\treturn t\n}\n\n// WithTreeTextStyle returns a new theme with overridden value.\nfunc (t Theme) WithTreeTextStyle(style Style) Theme {\n\tt.TreeTextStyle = style\n\treturn t\n}\n\n// WithBoxStyle returns a new theme with overridden value.\nfunc (t Theme) WithBoxStyle(style Style) Theme {\n\tt.BoxStyle = style\n\treturn t\n}\n\n// WithBoxTextStyle returns a new theme with overridden value.\nfunc (t Theme) WithBoxTextStyle(style Style) Theme {\n\tt.BoxTextStyle = style\n\treturn t\n}\n\n// WithBarLabelStyle returns a new theme with overridden value.\nfunc (t Theme) WithBarLabelStyle(style Style) Theme {\n\tt.BarLabelStyle = style\n\treturn t\n}\n\n// WithBarStyle returns a new theme with overridden value.\nfunc (t Theme) WithBarStyle(style Style) Theme {\n\tt.BarStyle = style\n\treturn t\n}\n"
        },
        {
          "name": "theme_test.go",
          "type": "blob",
          "size": 5.470703125,
          "content": "package pterm_test\n\nimport (\n\t\"testing\"\n\n\t\"github.com/MarvinJWendt/testza\"\n\t\"github.com/pterm/pterm\"\n)\n\nfunc TestTheme_WithDescriptionMessageStyle(t *testing.T) {\n\ts := pterm.Style{pterm.FgRed, pterm.BgBlue, pterm.Bold}\n\tp := pterm.Theme{}\n\tp2 := p.WithDescriptionMessageStyle(s)\n\n\ttestza.AssertEqual(t, s, p2.DescriptionMessageStyle)\n}\n\nfunc TestTheme_WithDescriptionPrefixStyle(t *testing.T) {\n\ts := pterm.Style{pterm.FgRed, pterm.BgBlue, pterm.Bold}\n\tp := pterm.Theme{}\n\tp2 := p.WithDescriptionPrefixStyle(s)\n\n\ttestza.AssertEqual(t, s, p2.DescriptionPrefixStyle)\n}\n\nfunc TestTheme_WithErrorMessageStyle(t *testing.T) {\n\ts := pterm.Style{pterm.FgRed, pterm.BgBlue, pterm.Bold}\n\tp := pterm.Theme{}\n\tp2 := p.WithErrorMessageStyle(s)\n\n\ttestza.AssertEqual(t, s, p2.ErrorMessageStyle)\n}\n\nfunc TestTheme_WithErrorPrefixStyle(t *testing.T) {\n\ts := pterm.Style{pterm.FgRed, pterm.BgBlue, pterm.Bold}\n\tp := pterm.Theme{}\n\tp2 := p.WithErrorPrefixStyle(s)\n\n\ttestza.AssertEqual(t, s, p2.ErrorPrefixStyle)\n}\n\nfunc TestTheme_WithFatalMessageStyle(t *testing.T) {\n\ts := pterm.Style{pterm.FgRed, pterm.BgBlue, pterm.Bold}\n\tp := pterm.Theme{}\n\tp2 := p.WithFatalMessageStyle(s)\n\n\ttestza.AssertEqual(t, s, p2.FatalMessageStyle)\n}\n\nfunc TestTheme_WithFatalPrefixStyle(t *testing.T) {\n\ts := pterm.Style{pterm.FgRed, pterm.BgBlue, pterm.Bold}\n\tp := pterm.Theme{}\n\tp2 := p.WithFatalPrefixStyle(s)\n\n\ttestza.AssertEqual(t, s, p2.FatalPrefixStyle)\n}\n\nfunc TestTheme_WithHighlightStyle(t *testing.T) {\n\ts := pterm.Style{pterm.FgRed, pterm.BgBlue, pterm.Bold}\n\tp := pterm.Theme{}\n\tp2 := p.WithHighlightStyle(s)\n\n\ttestza.AssertEqual(t, s, p2.HighlightStyle)\n}\n\nfunc TestTheme_WithInfoMessageStyle(t *testing.T) {\n\ts := pterm.Style{pterm.FgRed, pterm.BgBlue, pterm.Bold}\n\tp := pterm.Theme{}\n\tp2 := p.WithInfoMessageStyle(s)\n\n\ttestza.AssertEqual(t, s, p2.InfoMessageStyle)\n}\n\nfunc TestTheme_WithInfoPrefixStyle(t *testing.T) {\n\ts := pterm.Style{pterm.FgRed, pterm.BgBlue, pterm.Bold}\n\tp := pterm.Theme{}\n\tp2 := p.WithInfoPrefixStyle(s)\n\n\ttestza.AssertEqual(t, s, p2.InfoPrefixStyle)\n}\n\nfunc TestTheme_WithPrimaryStyle(t *testing.T) {\n\ts := pterm.Style{pterm.FgRed, pterm.BgBlue, pterm.Bold}\n\tp := pterm.Theme{}\n\tp2 := p.WithPrimaryStyle(s)\n\n\ttestza.AssertEqual(t, s, p2.PrimaryStyle)\n}\n\nfunc TestTheme_WithSecondaryStyle(t *testing.T) {\n\ts := pterm.Style{pterm.FgRed, pterm.BgBlue, pterm.Bold}\n\tp := pterm.Theme{}\n\tp2 := p.WithSecondaryStyle(s)\n\n\ttestza.AssertEqual(t, s, p2.SecondaryStyle)\n}\n\nfunc TestTheme_WithSuccessMessageStyle(t *testing.T) {\n\ts := pterm.Style{pterm.FgRed, pterm.BgBlue, pterm.Bold}\n\tp := pterm.Theme{}\n\tp2 := p.WithSuccessMessageStyle(s)\n\n\ttestza.AssertEqual(t, s, p2.SuccessMessageStyle)\n}\n\nfunc TestTheme_WithSuccessPrefixStyle(t *testing.T) {\n\ts := pterm.Style{pterm.FgRed, pterm.BgBlue, pterm.Bold}\n\tp := pterm.Theme{}\n\tp2 := p.WithSuccessPrefixStyle(s)\n\n\ttestza.AssertEqual(t, s, p2.SuccessPrefixStyle)\n}\n\nfunc TestTheme_WithWarningMessageStyle(t *testing.T) {\n\ts := pterm.Style{pterm.FgRed, pterm.BgBlue, pterm.Bold}\n\tp := pterm.Theme{}\n\tp2 := p.WithWarningMessageStyle(s)\n\n\ttestza.AssertEqual(t, s, p2.WarningMessageStyle)\n}\n\nfunc TestTheme_WithWarningPrefixStyle(t *testing.T) {\n\ts := pterm.Style{pterm.FgRed, pterm.BgBlue, pterm.Bold}\n\tp := pterm.Theme{}\n\tp2 := p.WithWarningPrefixStyle(s)\n\n\ttestza.AssertEqual(t, s, p2.WarningPrefixStyle)\n}\n\nfunc TestTheme_WithBulletListBulletStyle(t *testing.T) {\n\ts := pterm.Style{pterm.FgRed, pterm.BgBlue, pterm.Bold}\n\tp := pterm.Theme{}\n\tp2 := p.WithBulletListBulletStyle(s)\n\n\ttestza.AssertEqual(t, s, p2.BulletListBulletStyle)\n}\n\nfunc TestTheme_WithBulletListTextStyle(t *testing.T) {\n\ts := pterm.Style{pterm.FgRed, pterm.BgBlue, pterm.Bold}\n\tp := pterm.Theme{}\n\tp2 := p.WithBulletListTextStyle(s)\n\n\ttestza.AssertEqual(t, s, p2.BulletListTextStyle)\n}\n\nfunc TestTheme_WithLetterStyle(t *testing.T) {\n\ts := pterm.Style{pterm.FgRed, pterm.BgBlue, pterm.Bold}\n\tp := pterm.Theme{}\n\tp2 := p.WithLetterStyle(s)\n\n\ttestza.AssertEqual(t, s, p2.LetterStyle)\n}\n\nfunc TestTheme_WithDebugMessageStyle(t *testing.T) {\n\ts := pterm.Style{pterm.FgRed, pterm.BgBlue, pterm.Bold}\n\tp := pterm.Theme{}\n\tp2 := p.WithDebugMessageStyle(s)\n\n\ttestza.AssertEqual(t, s, p2.DebugMessageStyle)\n}\n\nfunc TestTheme_WithDebugPrefixStyle(t *testing.T) {\n\ts := pterm.Style{pterm.FgRed, pterm.BgBlue, pterm.Bold}\n\tp := pterm.Theme{}\n\tp2 := p.WithDebugPrefixStyle(s)\n\n\ttestza.AssertEqual(t, s, p2.DebugPrefixStyle)\n}\n\nfunc TestTheme_WithTreeStyle(t *testing.T) {\n\ts := pterm.Style{pterm.FgRed, pterm.BgBlue, pterm.Bold}\n\tp := pterm.Theme{}\n\tp2 := p.WithTreeStyle(s)\n\n\ttestza.AssertEqual(t, s, p2.TreeStyle)\n}\n\nfunc TestTheme_WithTreeTextStyle(t *testing.T) {\n\ts := pterm.Style{pterm.FgRed, pterm.BgBlue, pterm.Bold}\n\tp := pterm.Theme{}\n\tp2 := p.WithTreeTextStyle(s)\n\n\ttestza.AssertEqual(t, s, p2.TreeTextStyle)\n}\n\nfunc TestTheme_WithBoxStyle(t *testing.T) {\n\ts := pterm.Style{pterm.FgRed, pterm.BgBlue, pterm.Bold}\n\tp := pterm.Theme{}\n\tp2 := p.WithBoxStyle(s)\n\n\ttestza.AssertEqual(t, s, p2.BoxStyle)\n}\n\nfunc TestTheme_WithBoxTextStyle(t *testing.T) {\n\ts := pterm.Style{pterm.FgRed, pterm.BgBlue, pterm.Bold}\n\tp := pterm.Theme{}\n\tp2 := p.WithBoxTextStyle(s)\n\n\ttestza.AssertEqual(t, s, p2.BoxTextStyle)\n}\n\nfunc TestTheme_WithBarLabelStyle(t *testing.T) {\n\ts := pterm.Style{pterm.FgRed, pterm.BgBlue, pterm.Bold}\n\tp := pterm.Theme{}\n\tp2 := p.WithBarLabelStyle(s)\n\n\ttestza.AssertEqual(t, s, p2.BarLabelStyle)\n}\n\nfunc TestTheme_WithBarStyle(t *testing.T) {\n\ts := pterm.Style{pterm.FgRed, pterm.BgBlue, pterm.Bold}\n\tp := pterm.Theme{}\n\tp2 := p.WithBarStyle(s)\n\n\ttestza.AssertEqual(t, s, p2.BarStyle)\n}\n"
        },
        {
          "name": "tree_printer.go",
          "type": "blob",
          "size": 4.8310546875,
          "content": "package pterm\n\nimport (\n\t\"io\"\n\t\"strings\"\n)\n\n// TreeNode is used as items in a TreePrinter.\ntype TreeNode struct {\n\tChildren []TreeNode\n\tText     string\n}\n\n// LeveledList is a list, which contains multiple LeveledListItem.\ntype LeveledList []LeveledListItem\n\n// LeveledListItem combines a text with a specific level.\n// The level is the indent, which would normally be seen in a BulletListPrinter.\ntype LeveledListItem struct {\n\tLevel int\n\tText  string\n}\n\n// DefaultTree contains standards, which can be used to render a TreePrinter.\nvar DefaultTree = TreePrinter{\n\tTreeStyle:            &ThemeDefault.TreeStyle,\n\tTextStyle:            &ThemeDefault.TreeTextStyle,\n\tTopRightCornerString: \"└\",\n\tHorizontalString:     \"─\",\n\tTopRightDownString:   \"├\",\n\tVerticalString:       \"│\",\n\tRightDownLeftString:  \"┬\",\n\tIndent:               2,\n}\n\n// TreePrinter is able to render a list.\ntype TreePrinter struct {\n\tRoot                 TreeNode\n\tTreeStyle            *Style\n\tTextStyle            *Style\n\tTopRightCornerString string\n\tTopRightDownString   string\n\tHorizontalString     string\n\tVerticalString       string\n\tRightDownLeftString  string\n\tIndent               int\n\tWriter               io.Writer\n}\n\n// WithTreeStyle returns a new list with a specific tree style.\nfunc (p TreePrinter) WithTreeStyle(style *Style) *TreePrinter {\n\tp.TreeStyle = style\n\treturn &p\n}\n\n// WithTextStyle returns a new list with a specific text style.\nfunc (p TreePrinter) WithTextStyle(style *Style) *TreePrinter {\n\tp.TextStyle = style\n\treturn &p\n}\n\n// WithTopRightCornerString returns a new list with a specific TopRightCornerString.\nfunc (p TreePrinter) WithTopRightCornerString(s string) *TreePrinter {\n\tp.TopRightCornerString = s\n\treturn &p\n}\n\n// WithTopRightDownStringOngoing returns a new list with a specific TopRightDownString.\nfunc (p TreePrinter) WithTopRightDownStringOngoing(s string) *TreePrinter {\n\tp.TopRightDownString = s\n\treturn &p\n}\n\n// WithHorizontalString returns a new list with a specific HorizontalString.\nfunc (p TreePrinter) WithHorizontalString(s string) *TreePrinter {\n\tp.HorizontalString = s\n\treturn &p\n}\n\n// WithVerticalString returns a new list with a specific VerticalString.\nfunc (p TreePrinter) WithVerticalString(s string) *TreePrinter {\n\tp.VerticalString = s\n\treturn &p\n}\n\n// WithRoot returns a new list with a specific Root.\nfunc (p TreePrinter) WithRoot(root TreeNode) *TreePrinter {\n\tp.Root = root\n\treturn &p\n}\n\n// WithIndent returns a new list with a specific amount of spacing between the levels.\n// Indent must be at least 1.\nfunc (p TreePrinter) WithIndent(indent int) *TreePrinter {\n\tif indent < 1 {\n\t\tindent = 1\n\t}\n\tp.Indent = indent\n\treturn &p\n}\n\n// WithWriter sets the Writer.\nfunc (p TreePrinter) WithWriter(writer io.Writer) *TreePrinter {\n\tp.Writer = writer\n\treturn &p\n}\n\n// Render prints the list to the terminal.\nfunc (p TreePrinter) Render() error {\n\ts, _ := p.Srender()\n\tFprintln(p.Writer, s)\n\n\treturn nil\n}\n\n// Srender renders the list as a string.\nfunc (p TreePrinter) Srender() (string, error) {\n\tif p.TreeStyle == nil {\n\t\tp.TreeStyle = NewStyle()\n\t}\n\tif p.TextStyle == nil {\n\t\tp.TextStyle = NewStyle()\n\t}\n\n\tvar result strings.Builder\n\tif p.Root.Text != \"\" {\n\t\tresult.WriteString(p.TextStyle.Sprint(p.Root.Text))\n\t\tresult.WriteByte('\\n')\n\t}\n\tresult.WriteString(walkOverTree(p.Root.Children, p, \"\"))\n\treturn result.String(), nil\n}\n\n// walkOverTree is a recursive function,\n// which analyzes a TreePrinter and connects the items with specific characters.\n// Returns TreePrinter as string.\nfunc walkOverTree(list []TreeNode, p TreePrinter, prefix string) string {\n\tvar ret string\n\tfor i, item := range list {\n\t\tif len(list) > i+1 { // if not last in list\n\t\t\tif len(item.Children) == 0 { // if there are no children\n\t\t\t\tret += prefix + p.TreeStyle.Sprint(p.TopRightDownString) + strings.Repeat(p.TreeStyle.Sprint(p.HorizontalString), p.Indent) +\n\t\t\t\t\tp.TextStyle.Sprint(item.Text) + \"\\n\"\n\t\t\t} else { // if there are children\n\t\t\t\tret += prefix + p.TreeStyle.Sprint(p.TopRightDownString) + strings.Repeat(p.TreeStyle.Sprint(p.HorizontalString), p.Indent-1) +\n\t\t\t\t\tp.TreeStyle.Sprint(p.RightDownLeftString) + p.TextStyle.Sprint(item.Text) + \"\\n\"\n\t\t\t\tret += walkOverTree(item.Children, p, prefix+p.TreeStyle.Sprint(p.VerticalString)+strings.Repeat(\" \", p.Indent-1))\n\t\t\t}\n\t\t} else if len(list) == i+1 { // if last in list\n\t\t\tif len(item.Children) == 0 { // if there are no children\n\t\t\t\tret += prefix + p.TreeStyle.Sprint(p.TopRightCornerString) + strings.Repeat(p.TreeStyle.Sprint(p.HorizontalString), p.Indent) +\n\t\t\t\t\tp.TextStyle.Sprint(item.Text) + \"\\n\"\n\t\t\t} else { // if there are children\n\t\t\t\tret += prefix + p.TreeStyle.Sprint(p.TopRightCornerString) + strings.Repeat(p.TreeStyle.Sprint(p.HorizontalString), p.Indent-1) +\n\t\t\t\t\tp.TreeStyle.Sprint(p.RightDownLeftString) + p.TextStyle.Sprint(item.Text) + \"\\n\"\n\t\t\t\tret += walkOverTree(item.Children, p, prefix+strings.Repeat(\" \", p.Indent))\n\t\t\t}\n\t\t}\n\t}\n\treturn ret\n}\n"
        },
        {
          "name": "tree_printer_test.go",
          "type": "blob",
          "size": 6.609375,
          "content": "package pterm_test\n\nimport (\n\t\"os\"\n\t\"testing\"\n\n\t\"github.com/MarvinJWendt/testza\"\n\t\"github.com/pterm/pterm\"\n)\n\nfunc TestTreePrinterNilPrint(t *testing.T) {\n\tpterm.TreePrinter{}.Render()\n\tprinter := pterm.TreePrinter{}.WithRoot(pterm.NewTreeFromLeveledList(pterm.LeveledList{pterm.LeveledListItem{Text: \"Hello, World!\", Level: 0}}))\n\tcontent, err := printer.Srender()\n\n\ttestza.AssertNoError(t, err)\n\ttestza.AssertNotNil(t, content)\n}\n\nfunc TestTreePrinter_Render(t *testing.T) {\n\tpterm.DefaultTree.WithRoot(pterm.NewTreeFromLeveledList([]pterm.LeveledListItem{\n\t\t{Level: 0, Text: \"Hello, World!\"},\n\t\t{Level: 0, Text: \"0.0\"},\n\t\t{Level: 1, Text: \"0.1\"},\n\t\t{Level: 1, Text: \"0.2\"},\n\t\t{Level: 0, Text: \"1.0\"},\n\t\t{Level: 0, Text: \"2.0\"},\n\t\t{Level: 1, Text: \"2.1\"},\n\t\t{Level: 1, Text: \"2.2\"},\n\t\t{Level: 2, Text: \"2.2.1\"},\n\t\t{Level: 1, Text: \"2.3\"},\n\t})).Render()\n}\n\nfunc TestTreePrinter_NewTreeFromLeveledList(t *testing.T) {\n\tp := pterm.DefaultTree\n\tp2 := p.WithRoot(pterm.NewTreeFromLeveledList(pterm.LeveledList{\n\t\tpterm.LeveledListItem{Level: 0, Text: \"0.0\"},\n\t\tpterm.LeveledListItem{Level: 1, Text: \"0.1\"},\n\t\tpterm.LeveledListItem{Level: 1, Text: \"0.2\"},\n\t\tpterm.LeveledListItem{Level: 0, Text: \"1.0\"},\n\t\tpterm.LeveledListItem{Level: 0, Text: \"2.0\"},\n\t\tpterm.LeveledListItem{Level: 1, Text: \"2.1\"},\n\t\tpterm.LeveledListItem{Level: 1, Text: \"2.2\"},\n\t\tpterm.LeveledListItem{Level: 2, Text: \"2.2.1\"},\n\t\tpterm.LeveledListItem{Level: 1, Text: \"2.3\"}}))\n\n\ttestza.AssertEqual(t, pterm.NewTreeFromLeveledList(pterm.LeveledList{\n\t\tpterm.LeveledListItem{Level: 0, Text: \"0.0\"},\n\t\tpterm.LeveledListItem{Level: 1, Text: \"0.1\"},\n\t\tpterm.LeveledListItem{Level: 1, Text: \"0.2\"},\n\t\tpterm.LeveledListItem{Level: 0, Text: \"1.0\"},\n\t\tpterm.LeveledListItem{Level: 0, Text: \"2.0\"},\n\t\tpterm.LeveledListItem{Level: 1, Text: \"2.1\"},\n\t\tpterm.LeveledListItem{Level: 1, Text: \"2.2\"},\n\t\tpterm.LeveledListItem{Level: 2, Text: \"2.2.1\"},\n\t\tpterm.LeveledListItem{Level: 1, Text: \"2.3\"}}), p2.Root)\n\ttestza.AssertZero(t, p.Root)\n}\n\nfunc TestTreePrinter_NewTreeFromLeveledListLevelInvalidIncrease(t *testing.T) {\n\tp := pterm.DefaultTree\n\tp2 := p.WithRoot(pterm.NewTreeFromLeveledList(pterm.LeveledList{\n\t\tpterm.LeveledListItem{Level: 0, Text: \"0.0\"},\n\t\tpterm.LeveledListItem{Level: 1, Text: \"0.1\"},\n\t\tpterm.LeveledListItem{Level: 1, Text: \"0.2\"},\n\t\tpterm.LeveledListItem{Level: 0, Text: \"1.0\"},\n\t\tpterm.LeveledListItem{Level: 0, Text: \"2.0\"},\n\t\tpterm.LeveledListItem{Level: 1, Text: \"2.1\"},\n\t\tpterm.LeveledListItem{Level: 1, Text: \"2.2\"},\n\t\tpterm.LeveledListItem{Level: 2, Text: \"2.2.1\"},\n\t\tpterm.LeveledListItem{Level: 10, Text: \"2.3\"}}))\n\n\ttestza.AssertEqual(t, pterm.NewTreeFromLeveledList(pterm.LeveledList{\n\t\tpterm.LeveledListItem{Level: 0, Text: \"0.0\"},\n\t\tpterm.LeveledListItem{Level: 1, Text: \"0.1\"},\n\t\tpterm.LeveledListItem{Level: 1, Text: \"0.2\"},\n\t\tpterm.LeveledListItem{Level: 0, Text: \"1.0\"},\n\t\tpterm.LeveledListItem{Level: 0, Text: \"2.0\"},\n\t\tpterm.LeveledListItem{Level: 1, Text: \"2.1\"},\n\t\tpterm.LeveledListItem{Level: 1, Text: \"2.2\"},\n\t\tpterm.LeveledListItem{Level: 2, Text: \"2.2.1\"},\n\t\tpterm.LeveledListItem{Level: 3, Text: \"2.3\"}}), p2.Root)\n\ttestza.AssertZero(t, p.Root)\n}\n\nfunc TestTreePrinter_NewTreeFromLeveledListEmptyList(t *testing.T) {\n\tp := pterm.DefaultTree\n\tp2 := p.WithRoot(pterm.NewTreeFromLeveledList(pterm.LeveledList{}))\n\n\ttestza.AssertEqual(t, pterm.NewTreeFromLeveledList(pterm.LeveledList{}), p2.Root)\n\ttestza.AssertZero(t, p.Root)\n}\n\nfunc TestTreePrinter_NewTreeFromLeveledListNegativeLevel(t *testing.T) {\n\tp := pterm.DefaultTree\n\tp2 := p.WithRoot(pterm.NewTreeFromLeveledList(pterm.LeveledList{\n\t\tpterm.LeveledListItem{Level: 0, Text: \"0.0\"},\n\t\tpterm.LeveledListItem{Level: 1, Text: \"0.1\"},\n\t\tpterm.LeveledListItem{Level: 1, Text: \"0.2\"},\n\t\tpterm.LeveledListItem{Level: 0, Text: \"1.0\"},\n\t\tpterm.LeveledListItem{Level: 0, Text: \"2.0\"},\n\t\tpterm.LeveledListItem{Level: 1, Text: \"2.1\"},\n\t\tpterm.LeveledListItem{Level: 1, Text: \"2.2\"},\n\t\tpterm.LeveledListItem{Level: 2, Text: \"2.2.1\"},\n\t\tpterm.LeveledListItem{Level: -5, Text: \"2.3\"}}))\n\n\ttestza.AssertEqual(t, pterm.NewTreeFromLeveledList(pterm.LeveledList{\n\t\tpterm.LeveledListItem{Level: 0, Text: \"0.0\"},\n\t\tpterm.LeveledListItem{Level: 1, Text: \"0.1\"},\n\t\tpterm.LeveledListItem{Level: 1, Text: \"0.2\"},\n\t\tpterm.LeveledListItem{Level: 0, Text: \"1.0\"},\n\t\tpterm.LeveledListItem{Level: 0, Text: \"2.0\"},\n\t\tpterm.LeveledListItem{Level: 1, Text: \"2.1\"},\n\t\tpterm.LeveledListItem{Level: 1, Text: \"2.2\"},\n\t\tpterm.LeveledListItem{Level: 2, Text: \"2.2.1\"},\n\t\tpterm.LeveledListItem{Level: 0, Text: \"2.3\"}}), p2.Root)\n\ttestza.AssertZero(t, p.Root)\n}\n\nfunc TestTreePrinter_WithHorizontalString(t *testing.T) {\n\tp := pterm.TreePrinter{}\n\tp2 := p.WithHorizontalString(\"-\")\n\n\ttestza.AssertEqual(t, \"-\", p2.HorizontalString)\n\ttestza.AssertZero(t, p.HorizontalString)\n}\n\nfunc TestTreePrinter_WithRoot(t *testing.T) {\n\tp := pterm.TreePrinter{}\n\tp2 := p.WithRoot(pterm.TreeNode{\n\t\tChildren: nil,\n\t\tText:     \"Hello, World!\",\n\t})\n\n\ttestza.AssertEqual(t, pterm.TreeNode{\n\t\tChildren: nil,\n\t\tText:     \"Hello, World!\",\n\t}, p2.Root)\n\ttestza.AssertZero(t, p.Root)\n}\n\nfunc TestTreePrinter_WithTreeStyle(t *testing.T) {\n\tp := pterm.TreePrinter{}\n\ts := pterm.NewStyle(pterm.FgRed, pterm.BgRed, pterm.Bold)\n\tp2 := p.WithTreeStyle(s)\n\n\ttestza.AssertEqual(t, s, p2.TreeStyle)\n\ttestza.AssertZero(t, p.TreeStyle)\n}\n\nfunc TestTreePrinter_WithTextStyle(t *testing.T) {\n\tp := pterm.TreePrinter{}\n\ts := pterm.NewStyle(pterm.FgRed, pterm.BgRed, pterm.Bold)\n\tp2 := p.WithTextStyle(s)\n\n\ttestza.AssertEqual(t, s, p2.TextStyle)\n\ttestza.AssertZero(t, p.TextStyle)\n}\n\nfunc TestTreePrinter_WithTopRightCornerString(t *testing.T) {\n\tp := pterm.TreePrinter{}\n\tp2 := p.WithTopRightCornerString(\"-\")\n\n\ttestza.AssertEqual(t, \"-\", p2.TopRightCornerString)\n\ttestza.AssertZero(t, p.TopRightCornerString)\n}\n\nfunc TestTreePrinter_WithTopRightDownStringOngoing(t *testing.T) {\n\tp := pterm.TreePrinter{}\n\tp2 := p.WithTopRightDownStringOngoing(\"-\")\n\n\ttestza.AssertEqual(t, \"-\", p2.TopRightDownString)\n\ttestza.AssertZero(t, p.TopRightDownString)\n}\n\nfunc TestTreePrinter_WithVerticalString(t *testing.T) {\n\tp := pterm.TreePrinter{}\n\tp2 := p.WithVerticalString(\"-\")\n\n\ttestza.AssertEqual(t, \"-\", p2.VerticalString)\n\ttestza.AssertZero(t, p.VerticalString)\n}\n\nfunc TestTreePrinter_WithIndent(t *testing.T) {\n\tp := pterm.TreePrinter{}\n\tp2 := p.WithIndent(3)\n\n\ttestza.AssertEqual(t, 3, p2.Indent)\n\ttestza.AssertZero(t, p.Indent)\n}\n\nfunc TestTreePrinter_WithIndentInvalid(t *testing.T) {\n\tp := pterm.TreePrinter{}\n\tp2 := p.WithIndent(0)\n\n\ttestza.AssertEqual(t, 1, p2.Indent)\n\ttestza.AssertZero(t, p.Indent)\n}\n\nfunc TestTreePrinter_WithWriter(t *testing.T) {\n\tp := pterm.TreePrinter{}\n\ts := os.Stderr\n\tp2 := p.WithWriter(s)\n\n\ttestza.AssertEqual(t, s, p2.Writer)\n\ttestza.AssertZero(t, p.Writer)\n}\n"
        },
        {
          "name": "utils_test.go",
          "type": "blob",
          "size": 6.5595703125,
          "content": "package pterm_test\n\nimport (\n\t\"bytes\"\n\t\"fmt\"\n\t\"io\"\n\t\"os\"\n\t\"testing\"\n\n\t\"github.com/MarvinJWendt/testza\"\n\t\"github.com/pterm/pterm\"\n)\n\nvar printables = []any{\"Hello, World!\", 1337, true, false, -1337, 'c', 1.5, \"\\\\\", \"%s\"}\nvar terminalWidth = 80\nvar terminalHeight = 60\n\nfunc TestMain(m *testing.M) {\n\tpterm.SetForcedTerminalSize(terminalWidth, terminalHeight)\n\tsetupStdoutCapture()\n\texitVal := m.Run()\n\tteardownStdoutCapture()\n\tos.Exit(exitVal)\n}\n\n// testPrintContains can be used to test Print methods.\nfunc testPrintContains(t *testing.T, logic func(w io.Writer, a any)) {\n\tt.Helper()\n\n\tfor _, printable := range printables {\n\t\tt.Run(fmt.Sprint(printable), func(t *testing.T) {\n\t\t\tt.Helper()\n\n\t\t\ts := captureStdout(func(w io.Writer) {\n\t\t\t\tlogic(w, printable)\n\t\t\t})\n\t\t\ttestza.AssertContains(t, s, fmt.Sprint(printable))\n\t\t})\n\t\tpterm.DisableStyling()\n\t\tt.Run(fmt.Sprint(printable), func(t *testing.T) {\n\t\t\tt.Helper()\n\n\t\t\ts := captureStdout(func(w io.Writer) {\n\t\t\t\tlogic(w, printable)\n\t\t\t})\n\t\t\ttestza.AssertContains(t, s, fmt.Sprint(printable))\n\t\t})\n\t\tpterm.EnableStyling()\n\t}\n}\n\n// testPrintfContains can be used to test Printf methods.\nfunc testPrintfContains(t *testing.T, logic func(w io.Writer, format string, a any)) {\n\tfor _, printable := range printables {\n\t\tt.Run(fmt.Sprint(printable), func(t *testing.T) {\n\t\t\ts := captureStdout(func(w io.Writer) {\n\t\t\t\tlogic(w, \"Hello, %v!\", printable)\n\t\t\t})\n\t\t\ttestza.AssertContains(t, s, fmt.Sprintf(\"Hello, %v!\", fmt.Sprint(printable)))\n\t\t})\n\t\tpterm.DisableStyling()\n\t\tt.Run(fmt.Sprint(printable), func(t *testing.T) {\n\t\t\ts := captureStdout(func(w io.Writer) {\n\t\t\t\tlogic(w, \"Hello, %v!\", printable)\n\t\t\t})\n\t\t\ttestza.AssertContains(t, s, fmt.Sprintf(\"Hello, %v!\", fmt.Sprint(printable)))\n\t\t})\n\t\tpterm.EnableStyling()\n\t}\n}\n\n// testPrintflnContains can be used to test Printfln methods.\nfunc testPrintflnContains(t *testing.T, logic func(w io.Writer, format string, a any)) {\n\tfor _, printable := range printables {\n\t\tt.Run(fmt.Sprint(printable), func(t *testing.T) {\n\t\t\ttestPrintfContains(t, logic)\n\t\t})\n\t\tpterm.DisableStyling()\n\t\tt.Run(fmt.Sprint(printable), func(t *testing.T) {\n\t\t\ttestPrintfContains(t, logic)\n\t\t})\n\t\tpterm.EnableStyling()\n\t}\n}\n\n// testPrintlnContains can be used to test Println methods.\nfunc testPrintlnContains(t *testing.T, logic func(w io.Writer, a any)) {\n\tfor _, printable := range printables {\n\t\tt.Run(fmt.Sprint(printable), func(t *testing.T) {\n\t\t\tt.Helper()\n\n\t\t\ttestPrintContains(t, logic)\n\t\t})\n\t\tpterm.DisableStyling()\n\t\tt.Run(fmt.Sprint(printable), func(t *testing.T) {\n\t\t\tt.Helper()\n\n\t\t\ttestPrintContains(t, logic)\n\t\t})\n\t\tpterm.EnableStyling()\n\t}\n}\n\n// testSprintContains can be used to test Sprint methods.\nfunc testSprintContains(t *testing.T, logic func(a any) string) {\n\tfor _, printable := range printables {\n\t\tt.Run(fmt.Sprint(printable), func(t *testing.T) {\n\t\t\ttestza.AssertContains(t, logic(printable), fmt.Sprint(printable))\n\t\t})\n\t\tpterm.DisableStyling()\n\t\tt.Run(fmt.Sprint(printable), func(t *testing.T) {\n\t\t\ttestza.AssertContains(t, logic(printable), fmt.Sprint(printable))\n\t\t})\n\t\tpterm.EnableStyling()\n\t}\n}\n\n// testSprintContainsWithoutError can be used to test Sprint methods which return an error.\nfunc testSprintContainsWithoutError(t *testing.T, logic func(a any) (string, error)) {\n\tfor _, printable := range printables {\n\t\tt.Run(fmt.Sprint(printable), func(t *testing.T) {\n\t\t\ts, err := logic(printable)\n\t\t\ttestza.AssertContains(t, s, fmt.Sprint(printable))\n\t\t\ttestza.AssertNoError(t, err)\n\t\t})\n\t\tpterm.DisableStyling()\n\t\tt.Run(fmt.Sprint(printable), func(t *testing.T) {\n\t\t\ts, err := logic(printable)\n\t\t\ttestza.AssertContains(t, s, fmt.Sprint(printable))\n\t\t\ttestza.AssertNoError(t, err)\n\t\t})\n\t\tpterm.EnableStyling()\n\t}\n}\n\n// testSprintfContains can be used to test Sprintf methods.\nfunc testSprintfContains(t *testing.T, logic func(format string, a any) string) {\n\tfor _, printable := range printables {\n\t\tt.Run(fmt.Sprint(printable), func(t *testing.T) {\n\t\t\ttestza.AssertContains(t, logic(\"Hello, %v!\", printable), fmt.Sprintf(\"Hello, %v!\", printable))\n\t\t})\n\t\tpterm.DisableStyling()\n\t\tt.Run(fmt.Sprint(printable), func(t *testing.T) {\n\t\t\ttestza.AssertContains(t, logic(\"Hello, %v!\", printable), fmt.Sprintf(\"Hello, %v!\", printable))\n\t\t})\n\t\tpterm.EnableStyling()\n\t}\n}\n\n// testSprintflnContains can be used to test Sprintfln methods.\nfunc testSprintflnContains(t *testing.T, logic func(format string, a any) string) {\n\tfor _, printable := range printables {\n\t\tt.Run(fmt.Sprint(printable), func(t *testing.T) {\n\t\t\ttestSprintfContains(t, logic)\n\t\t})\n\t\tpterm.DisableStyling()\n\t\tt.Run(fmt.Sprint(printable), func(t *testing.T) {\n\t\t\ttestSprintfContains(t, logic)\n\t\t})\n\t\tpterm.EnableStyling()\n\t}\n}\n\n// testSprintlnContains can be used to test Sprintln methods.\nfunc testSprintlnContains(t *testing.T, logic func(a any) string) {\n\tfor _, printable := range printables {\n\t\tt.Run(fmt.Sprint(printable), func(t *testing.T) {\n\t\t\ttestSprintContains(t, logic)\n\t\t})\n\t\tpterm.DisableStyling()\n\t\tt.Run(fmt.Sprint(printable), func(t *testing.T) {\n\t\t\ttestSprintContains(t, logic)\n\t\t})\n\t\tpterm.EnableStyling()\n\t}\n}\n\n// testDoesOutput can be used to test if something is outputted to stdout.\nfunc testDoesOutput(t *testing.T, logic func(w io.Writer)) {\n\ttestza.AssertNotZero(t, captureStdout(logic))\n\tpterm.DisableStyling()\n\ttestza.AssertNotZero(t, captureStdout(logic))\n\tpterm.EnableStyling()\n}\n\n// testEmpty checks that a function does not return a string.\nfunc testEmpty(t *testing.T, logic func(a any) string) {\n\tfor _, printable := range printables {\n\t\ttestza.AssertZero(t, logic(printable))\n\t\tpterm.DisableStyling()\n\t\ttestza.AssertZero(t, logic(printable))\n\t\tpterm.EnableStyling()\n\t}\n}\n\n// testDoesNotOutput can be used, to test that something does not output anything to stdout.\nfunc testDoesNotOutput(t *testing.T, logic func(w io.Writer)) {\n\ttestza.AssertZero(t, captureStdout(logic))\n\tpterm.DisableStyling()\n\ttestza.AssertZero(t, captureStdout(logic))\n\tpterm.EnableStyling()\n}\n\nvar outBuf bytes.Buffer\n\n// setupStdoutCapture sets up a fake stdout capture.\nfunc setupStdoutCapture() {\n\toutBuf.Reset()\n\tpterm.SetDefaultOutput(&outBuf)\n}\n\n// teardownStdoutCapture restores the real stdout.\nfunc teardownStdoutCapture() {\n\tpterm.SetDefaultOutput(os.Stdout)\n}\n\n// captureStdout simulates capturing of os.stdout with a buffer and returns what was written to the screen\nfunc captureStdout(f func(w io.Writer)) string {\n\tsetupStdoutCapture()\n\tf(&outBuf)\n\treturn readStdout()\n}\n\n// readStdout reads the current stdout buffor. Assumes setupStdoutCapture() has been called before.\nfunc readStdout() string {\n\tcontent := outBuf.String()\n\toutBuf.Reset()\n\treturn content\n}\n\nfunc proxyToDevNull() {\n\tpterm.SetDefaultOutput(os.NewFile(0, os.DevNull))\n}\n"
        }
      ]
    }
  ]
}