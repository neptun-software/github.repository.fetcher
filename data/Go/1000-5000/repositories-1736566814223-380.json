{
  "metadata": {
    "timestamp": 1736566814223,
    "page": 380,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjM4MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "kkdai/youtube",
      "stars": 3481,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.0634765625,
          "content": "/.idea\n/.vscode\ndownload_test\n/bin\n/dist\n/output\n*.out\n.DS_Store\n"
        },
        {
          "name": ".golangci.yml",
          "type": "blob",
          "size": 0.2509765625,
          "content": "issues:\n  exclude:\n  - Subprocess launched with function call\n  # Excluding configuration per-path, per-linter, per-text and per-source\n  exclude-rules:\n    # Exclude some linters from running on tests files.\n    - path: cmd/\n      text: InsecureSkipVerify\n"
        },
        {
          "name": ".goreleaser.yml",
          "type": "blob",
          "size": 0.314453125,
          "content": "project_name: youtubedr\n\nenv:\n  # Build without CGO to don't depend on specific glibc versions\n  - CGO_ENABLED=0\n\nbuilds:\n  - main: ./cmd/youtubedr\n    binary: youtubedr\n    goos:\n      - windows\n      - darwin\n      - linux\n      - freebsd\n    goarch:\n      - amd64\n      - arm\n      - arm64\n    flags:\n      - -trimpath\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.05078125,
          "content": "The MIT License (MIT)\n\nCopyright (c) 2015 Evan Lin\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n\n"
        },
        {
          "name": "Makefile",
          "type": "blob",
          "size": 1.515625,
          "content": "FILES_TO_FMT      ?= $(shell find . -path ./vendor -prune -o -name '*.go' -print)\nLOGLEVEL\t?= debug\n\n## help: Show makefile commands\n.PHONY: help\nhelp: Makefile\n\t@echo \"---- Project: kkdai/youtube ----\"\n\t@echo \" Usage: make COMMAND\"\n\t@echo\n\t@echo \" Management Commands:\"\n\t@sed -n 's/^##//p' $< | column -t -s ':' |  sed -e 's/^/ /'\n\t@echo\n\n## build: Build project\n.PHONY: build\nbuild:\n\tgoreleaser --rm-dist\n\n## deps: Ensures fresh go.mod and go.sum\n.PHONY: deps\ndeps:\n\tgo mod tidy\n\tgo mod verify\n\n## lint: Run golangci-lint check\n.PHONY: lint\nlint:\n\tcommand -v golangci-lint || curl -sSfL https://raw.githubusercontent.com/golangci/golangci-lint/master/install.sh | sh -s -- -b $$(go env GOPATH)/bin $(GOLANGCI_LINT_VERSION)\n\techo \"golangci-lint checking...\"\n\tgolangci-lint run --timeout=30m --enable=misspell --enable=gosec --enable=gofmt --enable=goimports --enable=revive ./cmd/... ./...\n\tgo vet ./...\n\n## format: Formats Go code\n.PHONY: format\nformat:\n\t@echo \">> formatting code\"\n\t@gofmt -s -w $(FILES_TO_FMT)\n\n## test-unit: Run all Youtube Go unit tests\n.PHONY: test-unit\ntest-unit:\n\tLOGLEVEL=${LOGLEVEL} go test -v -cover ./...\n\n## test-integration: Run all Youtube Go integration tests\n.PHONY: test-integration\ntest-integration:\n\tmkdir -p output\n\trm -f output/*\n\tLOGLEVEL=${LOGLEVEL} ARTIFACTS=output go test -v -race -covermode=atomic -coverprofile=coverage.out -tags=integration ./...\n\n.PHONY: coverage.out\ncoverage.out:\n\n## clean: Clean files and downloaded videos from builds during development\n.PHONY: clean\nclean:\n\trm -rf dist *.mp4 *.mkv\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 5.40234375,
          "content": "Download Youtube Video in Golang\n==================\n\n[![GitHub license](https://img.shields.io/badge/license-MIT-blue.svg)](https://raw.githubusercontent.com/kkdai/youtube/master/LICENSE)\n[![Go Reference](https://pkg.go.dev/badge/github.com/kkdai/youtube.svg)](https://pkg.go.dev/github.com/kkdai/youtube/v2)\n[![Build Status](https://github.com/kkdai/youtube/workflows/go/badge.svg?branch=master)](https://github.com/kkdai/youtube/actions)\n[![Coverage](https://codecov.io/gh/kkdai/youtube/branch/master/graph/badge.svg)](https://codecov.io/gh/kkdai/youtube)\n[![](https://goreportcard.com/badge/github.com/kkdai/youtube)](https://goreportcard.com/badge/github.com/kkdai/youtube)\n\n\nThis package is a Youtube video download package, for more detail refer [https://github.com/ytdl-org/youtube-dl](https://github.com/ytdl-org/youtube-dl) for more download options.\n\nThis tool is meant to be used to download CC0 licenced content, we do not support nor recommend using it for illegal activities.\n\n## Overview\n  * [Install](#installation)\n  * [Usage](#usage)\n  * [Example: Download video from \\[dotGo 2015 - Rob Pike - Simplicity is Complicated\\]](#download-dotGo-2015-rob-pike-video)\n\n## Installation\n\n### Run Manually\n\n```shell\ngit clone https://github.com/kkdai/youtube.git && cd youtube\ngo run ./cmd/youtubedr\n```\n\n### Install via Go\n\nPlease ensure you have installed Go 1.22 or later.\n\n```shell\ngo install github.com/kkdai/youtube/v2/cmd/youtubedr@latest\n```\n\n### Mac\n\n```shell\nbrew install youtubedr\n```\n\n### in Termux\n```shell\npkg install youtubedr\n```\n###  You can also find this package in\n- [archlinux](https://aur.archlinux.org/packages/youtubedr/)  (thanks to [cjsthompson](https://github.com/cjsthompson))\n- [Termux package](https://github.com/termux/termux-packages/tree/master/packages/youtubedr) (thanks to [kcubeterm](https://github.com/kcubeterm))\n- [Homebrew](https://formulae.brew.sh/formula/youtubedr) (thanks to [kkc](https://github.com/kkc))\n\n## Usage\n\n### Use the binary directly\nIt's really simple to use, just get the video id from youtube url - ex: `https://www.youtube.com/watch?v=rFejpH_tAHM`, the video id is `rFejpH_tAHM`\n\n```shell\nyoutubedr download rFejpH_tAHM\nyoutubedr download https://www.youtube.com/watch?v=rFejpH_tAHM\n```\n\n\n### Use this package in your golang program\n\nPlease check out the [example_test.go](example_test.go) for example code.\n\n\n## Example:\n * ### Get information of dotGo-2015-rob-pike video for downloading\n\n    Download video from [dotGo 2015 - Rob Pike - Simplicity is Complicated](https://www.youtube.com/watch?v=rFejpH_tAHM)\n\n    ```\n    youtubedr info https://www.youtube.com/watch?v=rFejpH_tAHM\n\n   Title: dotGo 2015 - Rob Pike - Simplicity is Complicated\n   Author: dotconferences\n   -----available streams-----\n   itag:  18 , quality: medium , type: video/mp4; codecs=\"avc1.42001E, mp4a.40.2\"\n   itag:  22 , quality:  hd720 , type: video/mp4; codecs=\"avc1.64001F, mp4a.40.2\"\n   itag: 137 , quality: hd1080 , type: video/mp4; codecs=\"avc1.640028\"\n   itag: 248 , quality: hd1080 , type: video/webm; codecs=\"vp9\"\n   ........\n    ```\n * ### Download dotGo-2015-rob-pike-video\n\n    Download video from [dotGo 2015 - Rob Pike - Simplicity is Complicated](https://www.youtube.com/watch?v=rFejpH_tAHM)\n\n    ```\n    youtubedr download https://www.youtube.com/watch?v=rFejpH_tAHM\n    ```\n\n * ### Download video to specific folder and name\n\n\tDownload video from [dotGo 2015 - Rob Pike - Simplicity is Complicated](https://www.youtube.com/watch?v=rFejpH_tAHM) to current directory and name the file to simplicity-is-complicated.mp4\n\n\t```\n\tyoutubedr download -d ./ -o simplicity-is-complicated.mp4 https://www.youtube.com/watch?v=rFejpH_tAHM\n\t```\n\n * ### Download video with specific quality\n\n\tDownload video from [dotGo 2015 - Rob Pike - Simplicity is Complicated](https://www.youtube.com/watch?v=rFejpH_tAHM) with specific quality\n\n\t```\n\tyoutubedr download -q medium https://www.youtube.com/watch?v=rFejpH_tAHM\n\t```\n\n   #### Special case by quality hd1080:\n   Installation of ffmpeg is necessary for hd1080\n   ```\n   ffmpeg   //check ffmpeg is installed, if not please download ffmpeg and set to your PATH.\n   youtubedr download -q hd1080 https://www.youtube.com/watch?v=rFejpH_tAHM\n   ```\n\n\n * ### Download video with specific itag\n\n    Download video from [dotGo 2015 - Rob Pike - Simplicity is Complicated](https://www.youtube.com/watch?v=rFejpH_tAHM)\n\n    ```\n    youtubedr download -q 18 https://www.youtube.com/watch?v=rFejpH_tAHM\n    ```\n\n## How it works\n\n- Parse the video ID you input in URL\n\t- ex: `https://www.youtube.com/watch?v=rFejpH_tAHM`, the video id is `rFejpH_tAHM`\n- Get video information via video id.\n\t- Use URL: `http://youtube.com/get_video_info?video_id=`\n- Parse and decode video information.\n\t- Download URL in \"url=\"\n\t- title in \"title=\"\n- Download video from URL\n\t- Need the string combination of \"url\"\n\n## Inspired\n- [https://github.com/ytdl-org/youtube-dl](https://github.com/ytdl-org/youtube-dl)\n- [https://github.com/lepidosteus/youtube-dl](https://github.com/lepidosteus/youtube-dl)\n- [拆解 Youtube 影片下載位置](http://hkgoldenmra.blogspot.tw/2013/05/youtube.html)\n- [iawia002/annie](https://github.com/iawia002/annie)\n- [How to get url from obfuscate video info: youtube video downloader with php](https://stackoverflow.com/questions/60607291/youtube-video-downloader-with-php)\n\n\n## Project52\nIt is one of my [project 52](https://github.com/kkdai/project52).\n\n\n## License\nThis package is licensed under MIT license. See LICENSE for details.\n"
        },
        {
          "name": "YoutubeChange.md",
          "type": "blob",
          "size": 0.3544921875,
          "content": "Tracking Youtube decipher change\n\n### 2022/01/21:\n\n#### action objects:\n\nvar $z={fA:function(a){a.reverse()},S2:function(a,b){a.splice(0,b)},l6:function(a,b){var c=a[0];a[0]=a[b%a.length];a[b%a.length]=c}};\n#### actions function:\n\nNpa=function(a){a=a.split(\"\");$z.S2(a,3);$z.fA(a,45);$z.l6(a,31);$z.S2(a,1);$z.fA(a,63);$z.S2(a,2);$z.fA(a,68);return a.join(\"\")};\n\n"
        },
        {
          "name": "artifacts.go",
          "type": "blob",
          "size": 0.6328125,
          "content": "package youtube\n\nimport (\n\t\"log/slog\"\n\t\"os\"\n\t\"path/filepath\"\n)\n\n// destination for artifacts, used by integration tests\nvar artifactsFolder = os.Getenv(\"ARTIFACTS\")\n\nfunc writeArtifact(name string, content []byte) {\n\t// Ensure folder exists\n\terr := os.MkdirAll(artifactsFolder, os.ModePerm)\n\tif err != nil {\n\t\tslog.Error(\"unable to create artifacts folder\", \"path\", artifactsFolder, \"error\", err)\n\t\treturn\n\t}\n\n\tpath := filepath.Join(artifactsFolder, name)\n\terr = os.WriteFile(path, content, 0600)\n\n\tlog := slog.With(\"path\", path)\n\tif err != nil {\n\t\tlog.Error(\"unable to write artifact\", \"error\", err)\n\t} else {\n\t\tlog.Debug(\"artifact created\")\n\t}\n}\n"
        },
        {
          "name": "client.go",
          "type": "blob",
          "size": 16.376953125,
          "content": "package youtube\n\nimport (\n\t\"bytes\"\n\t\"context\"\n\t\"encoding/json\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"log/slog\"\n\t\"math/rand\"\n\t\"net/http\"\n\t\"net/url\"\n\t\"strconv\"\n\t\"sync/atomic\"\n)\n\nconst (\n\tSize1Kb  = 1024\n\tSize1Mb  = Size1Kb * 1024\n\tSize10Mb = Size1Mb * 10\n\n\tplayerParams = \"CgIQBg==\"\n)\n\nvar ErrNoFormat = errors.New(\"no video format provided\")\n\n// DefaultClient type to use. No reason to change but you could if you wanted to.\nvar DefaultClient = IOSClient\n\n// Client offers methods to download video metadata and video streams.\ntype Client struct {\n\t// HTTPClient can be used to set a custom HTTP client.\n\t// If not set, http.DefaultClient will be used\n\tHTTPClient *http.Client\n\n\t// MaxRoutines to use when downloading a video.\n\tMaxRoutines int\n\n\t// ChunkSize to use when downloading videos in chunks. Default is Size10Mb.\n\tChunkSize int64\n\n\t// playerCache caches the JavaScript code of a player response\n\tplayerCache playerCache\n\n\tclient *clientInfo\n\n\tconsentID string\n}\n\nfunc (c *Client) assureClient() {\n\tif c.client == nil {\n\t\tc.client = &DefaultClient\n\t}\n}\n\n// GetVideo fetches video metadata\nfunc (c *Client) GetVideo(url string) (*Video, error) {\n\treturn c.GetVideoContext(context.Background(), url)\n}\n\n// GetVideoContext fetches video metadata with a context\nfunc (c *Client) GetVideoContext(ctx context.Context, url string) (*Video, error) {\n\tid, err := ExtractVideoID(url)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"extractVideoID failed: %w\", err)\n\t}\n\n\treturn c.videoFromID(ctx, id)\n}\n\nfunc (c *Client) videoFromID(ctx context.Context, id string) (*Video, error) {\n\tc.assureClient()\n\n\tbody, err := c.videoDataByInnertube(ctx, id)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tv := Video{\n\t\tID: id,\n\t}\n\n\t// return early if all good\n\tif err = v.parseVideoInfo(body); err == nil {\n\t\treturn &v, nil\n\t}\n\n\t// If the uploader has disabled embedding the video on other sites, parse video page\n\tif errors.Is(err, ErrNotPlayableInEmbed) {\n\t\t// additional parameters are required to access clips with sensitiv content\n\t\thtml, err := c.httpGetBodyBytes(ctx, \"https://www.youtube.com/watch?v=\"+id+\"&bpctr=9999999999&has_verified=1\")\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\treturn &v, v.parseVideoPage(html)\n\t}\n\n\t// If the uploader marked the video as inappropriate for some ages, use embed player\n\tif errors.Is(err, ErrLoginRequired) {\n\t\tc.client = &EmbeddedClient\n\n\t\tbodyEmbed, errEmbed := c.videoDataByInnertube(ctx, id)\n\t\tif errEmbed == nil {\n\t\t\terrEmbed = v.parseVideoInfo(bodyEmbed)\n\t\t}\n\n\t\tif errEmbed == nil {\n\t\t\treturn &v, nil\n\t\t}\n\n\t\t// private video clearly not age-restricted and thus should be explicit\n\t\tif errEmbed == ErrVideoPrivate {\n\t\t\treturn &v, errEmbed\n\t\t}\n\n\t\t// wrapping error so its clear whats happened\n\t\treturn &v, fmt.Errorf(\"can't bypass age restriction: %w\", errEmbed)\n\t}\n\n\t// undefined error\n\treturn &v, err\n}\n\ntype innertubeRequest struct {\n\tVideoID         string            `json:\"videoId,omitempty\"`\n\tBrowseID        string            `json:\"browseId,omitempty\"`\n\tContinuation    string            `json:\"continuation,omitempty\"`\n\tContext         inntertubeContext `json:\"context\"`\n\tPlaybackContext *playbackContext  `json:\"playbackContext,omitempty\"`\n\tContentCheckOK  bool              `json:\"contentCheckOk,omitempty\"`\n\tRacyCheckOk     bool              `json:\"racyCheckOk,omitempty\"`\n\tParams          string            `json:\"params\"`\n}\n\ntype playbackContext struct {\n\tContentPlaybackContext contentPlaybackContext `json:\"contentPlaybackContext\"`\n}\n\ntype contentPlaybackContext struct {\n\t// SignatureTimestamp string `json:\"signatureTimestamp\"`\n\tHTML5Preference string `json:\"html5Preference\"`\n}\n\ntype inntertubeContext struct {\n\tClient innertubeClient `json:\"client\"`\n}\n\ntype innertubeClient struct {\n\tHL                string `json:\"hl\"`\n\tGL                string `json:\"gl\"`\n\tClientName        string `json:\"clientName\"`\n\tClientVersion     string `json:\"clientVersion\"`\n\tAndroidSDKVersion int    `json:\"androidSDKVersion,omitempty\"`\n\tUserAgent         string `json:\"userAgent,omitempty\"`\n\tTimeZone          string `json:\"timeZone\"`\n\tUTCOffset         int    `json:\"utcOffsetMinutes\"`\n\tDeviceModel       string `json:\"deviceModel,omitempty\"`\n}\n\n// client info for the innertube API\ntype clientInfo struct {\n\tname           string\n\tkey            string\n\tversion        string\n\tuserAgent      string\n\tandroidVersion int\n\tdeviceModel    string\n}\n\nvar (\n\t// WebClient, better to use Android client but go ahead.\n\tWebClient = clientInfo{\n\t\tname:      \"WEB\",\n\t\tversion:   \"2.20220801.00.00\",\n\t\tkey:       \"AIzaSyAO_FJ2SlqU8Q4STEHLGCilw_Y9_11qcW8\",\n\t\tuserAgent: \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36\",\n\t}\n\n\t// AndroidClient, download go brrrrrr.\n\tAndroidClient = clientInfo{\n\t\tname:           \"ANDROID\",\n\t\tversion:        \"18.11.34\",\n\t\tkey:            \"AIzaSyA8eiZmM1FaDVjRy-df2KTyQ_vz_yYM39w\",\n\t\tuserAgent:      \"com.google.android.youtube/18.11.34 (Linux; U; Android 11) gzip\",\n\t\tandroidVersion: 30,\n\t}\n\n\t// IOSClient Client based brrrr.\n\tIOSClient = clientInfo{\n\t\tname:        \"IOS\",\n\t\tversion:     \"19.45.4\",\n\t\tkey:         \"AIzaSyAO_FJ2SlqU8Q4STEHLGCilw_Y9_11qcW8\",\n\t\tuserAgent:   \"com.google.ios.youtube/19.45.4 (iPhone16,2; U; CPU iOS 18_1_0 like Mac OS X;)\",\n\t\tdeviceModel: \"iPhone16,2\",\n\t}\n\n\t// EmbeddedClient, not really tested.\n\tEmbeddedClient = clientInfo{\n\t\tname:      \"WEB_EMBEDDED_PLAYER\",\n\t\tversion:   \"1.19700101\",\n\t\tkey:       \"AIzaSyAO_FJ2SlqU8Q4STEHLGCilw_Y9_11qcW8\", // seems like same key works for both clients\n\t\tuserAgent: \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36\",\n\t}\n)\n\nfunc (c *Client) videoDataByInnertube(ctx context.Context, id string) ([]byte, error) {\n\tdata := innertubeRequest{\n\t\tVideoID:        id,\n\t\tContext:        prepareInnertubeContext(*c.client),\n\t\tContentCheckOK: true,\n\t\tRacyCheckOk:    true,\n\t\t// Params:                   playerParams,\n\t\tPlaybackContext: &playbackContext{\n\t\t\tContentPlaybackContext: contentPlaybackContext{\n\t\t\t\t// SignatureTimestamp: sts,\n\t\t\t\tHTML5Preference: \"HTML5_PREF_WANTS\",\n\t\t\t},\n\t\t},\n\t}\n\n\treturn c.httpPostBodyBytes(ctx, \"https://www.youtube.com/youtubei/v1/player?key=\"+c.client.key, data)\n}\n\nfunc (c *Client) transcriptDataByInnertube(ctx context.Context, id string, lang string) ([]byte, error) {\n\tdata := innertubeRequest{\n\t\tContext: prepareInnertubeContext(*c.client),\n\t\tParams:  transcriptVideoID(id, lang),\n\t}\n\n\treturn c.httpPostBodyBytes(ctx, \"https://www.youtube.com/youtubei/v1/get_transcript?key=\"+c.client.key, data)\n}\n\nfunc prepareInnertubeContext(clientInfo clientInfo) inntertubeContext {\n\treturn inntertubeContext{\n\t\tClient: innertubeClient{\n\t\t\tHL:                \"en\",\n\t\t\tGL:                \"US\",\n\t\t\tTimeZone:          \"UTC\",\n\t\t\tDeviceModel:       clientInfo.deviceModel,\n\t\t\tClientName:        clientInfo.name,\n\t\t\tClientVersion:     clientInfo.version,\n\t\t\tAndroidSDKVersion: clientInfo.androidVersion,\n\t\t\tUserAgent:         clientInfo.userAgent,\n\t\t},\n\t}\n}\n\nfunc prepareInnertubePlaylistData(ID string, continuation bool, clientInfo clientInfo) innertubeRequest {\n\tcontext := prepareInnertubeContext(clientInfo)\n\n\tif continuation {\n\t\treturn innertubeRequest{\n\t\t\tContext:        context,\n\t\t\tContinuation:   ID,\n\t\t\tContentCheckOK: true,\n\t\t\tRacyCheckOk:    true,\n\t\t\tParams:         playerParams,\n\t\t}\n\t}\n\n\treturn innertubeRequest{\n\t\tContext:        context,\n\t\tBrowseID:       \"VL\" + ID,\n\t\tContentCheckOK: true,\n\t\tRacyCheckOk:    true,\n\t\tParams:         playerParams,\n\t}\n}\n\n// transcriptVideoID encodes the video ID to the param used to fetch transcripts.\nfunc transcriptVideoID(videoID string, lang string) string {\n\tlangCode := encTranscriptLang(lang)\n\n\t// This can be optionally appened to the Sprintf str, not sure what it means\n\t// *3engagement-panel-searchable-transcript-search-panel\\x30\\x00\\x38\\x01\\x40\\x01\n\treturn base64Enc(fmt.Sprintf(\"\\n\\x0b%s\\x12\\x12%s\\x18\\x01\", videoID, langCode))\n}\n\nfunc encTranscriptLang(languageCode string) string {\n\ts := fmt.Sprintf(\"\\n\\x03asr\\x12\\x02%s\\x1a\\x00\", languageCode)\n\ts = base64PadEnc(s)\n\n\treturn url.QueryEscape(s)\n}\n\n// GetPlaylist fetches playlist metadata\nfunc (c *Client) GetPlaylist(url string) (*Playlist, error) {\n\treturn c.GetPlaylistContext(context.Background(), url)\n}\n\n// GetPlaylistContext fetches playlist metadata, with a context, along with a list of Videos, and some basic information\n// for these videos. Playlist entries cannot be downloaded, as they lack all the required metadata, but\n// can be used to enumerate all IDs, Authors, Titles, etc.\nfunc (c *Client) GetPlaylistContext(ctx context.Context, url string) (*Playlist, error) {\n\tc.assureClient()\n\n\tid, err := extractPlaylistID(url)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"extractPlaylistID failed: %w\", err)\n\t}\n\n\tdata := prepareInnertubePlaylistData(id, false, *c.client)\n\tbody, err := c.httpPostBodyBytes(ctx, \"https://www.youtube.com/youtubei/v1/browse?key=\"+c.client.key, data)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tp := &Playlist{ID: id}\n\treturn p, p.parsePlaylistInfo(ctx, c, body)\n}\n\nfunc (c *Client) VideoFromPlaylistEntry(entry *PlaylistEntry) (*Video, error) {\n\treturn c.videoFromID(context.Background(), entry.ID)\n}\n\nfunc (c *Client) VideoFromPlaylistEntryContext(ctx context.Context, entry *PlaylistEntry) (*Video, error) {\n\treturn c.videoFromID(ctx, entry.ID)\n}\n\n// GetStream returns the stream and the total size for a specific format\nfunc (c *Client) GetStream(video *Video, format *Format) (io.ReadCloser, int64, error) {\n\treturn c.GetStreamContext(context.Background(), video, format)\n}\n\n// GetStreamContext returns the stream and the total size for a specific format with a context.\nfunc (c *Client) GetStreamContext(ctx context.Context, video *Video, format *Format) (io.ReadCloser, int64, error) {\n\turl, err := c.GetStreamURL(video, format)\n\tif err != nil {\n\t\treturn nil, 0, err\n\t}\n\n\treq, err := http.NewRequestWithContext(ctx, http.MethodGet, url, nil)\n\tif err != nil {\n\t\treturn nil, 0, err\n\t}\n\n\tr, w := io.Pipe()\n\tcontentLength := format.ContentLength\n\n\tif contentLength == 0 {\n\t\t// some videos don't have length information\n\t\tcontentLength = c.downloadOnce(req, w, format)\n\t} else {\n\t\t// we have length information, let's download by chunks!\n\t\tc.downloadChunked(ctx, req, w, format)\n\t}\n\n\treturn r, contentLength, nil\n}\n\nfunc (c *Client) downloadOnce(req *http.Request, w *io.PipeWriter, _ *Format) int64 {\n\tresp, err := c.httpDo(req)\n\tif err != nil {\n\t\tw.CloseWithError(err) //nolint:errcheck\n\t\treturn 0\n\t}\n\n\tgo func() {\n\t\tdefer resp.Body.Close()\n\t\t_, err := io.Copy(w, resp.Body)\n\t\tif err == nil {\n\t\t\tw.Close()\n\t\t} else {\n\t\t\tw.CloseWithError(err) //nolint:errcheck\n\t\t}\n\t}()\n\n\tcontentLength := resp.Header.Get(\"Content-Length\")\n\tlength, _ := strconv.ParseInt(contentLength, 10, 64)\n\n\treturn length\n}\n\nfunc (c *Client) getChunkSize() int64 {\n\tif c.ChunkSize > 0 {\n\t\treturn c.ChunkSize\n\t}\n\n\treturn Size10Mb\n}\n\nfunc (c *Client) getMaxRoutines(limit int) int {\n\troutines := 10\n\n\tif c.MaxRoutines > 0 {\n\t\troutines = c.MaxRoutines\n\t}\n\n\tif limit > 0 && routines > limit {\n\t\troutines = limit\n\t}\n\n\treturn routines\n}\n\nfunc (c *Client) downloadChunked(ctx context.Context, req *http.Request, w *io.PipeWriter, format *Format) {\n\tchunks := getChunks(format.ContentLength, c.getChunkSize())\n\tmaxRoutines := c.getMaxRoutines(len(chunks))\n\n\tcancelCtx, cancel := context.WithCancel(ctx)\n\tabort := func(err error) {\n\t\tw.CloseWithError(err)\n\t\tcancel()\n\t}\n\n\tcurrentChunk := atomic.Uint32{}\n\tfor i := 0; i < maxRoutines; i++ {\n\t\tgo func() {\n\t\t\tfor {\n\t\t\t\tchunkIndex := int(currentChunk.Add(1)) - 1\n\t\t\t\tif chunkIndex >= len(chunks) {\n\t\t\t\t\t// no more chunks\n\t\t\t\t\treturn\n\t\t\t\t}\n\n\t\t\t\tchunk := &chunks[chunkIndex]\n\t\t\t\terr := c.downloadChunk(req.Clone(cancelCtx), chunk)\n\t\t\t\tclose(chunk.data)\n\n\t\t\t\tif err != nil {\n\t\t\t\t\tabort(err)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}\n\t\t}()\n\t}\n\n\tgo func() {\n\t\t// copy chunks into the PipeWriter\n\t\tfor i := 0; i < len(chunks); i++ {\n\t\t\tselect {\n\t\t\tcase <-cancelCtx.Done():\n\t\t\t\tabort(context.Canceled)\n\t\t\t\treturn\n\t\t\tcase data := <-chunks[i].data:\n\t\t\t\t_, err := io.Copy(w, bytes.NewBuffer(data))\n\t\t\t\tif err != nil {\n\t\t\t\t\tabort(err)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// everything succeeded\n\t\tw.Close()\n\t}()\n}\n\n// GetStreamURL returns the url for a specific format\nfunc (c *Client) GetStreamURL(video *Video, format *Format) (string, error) {\n\treturn c.GetStreamURLContext(context.Background(), video, format)\n}\n\n// GetStreamURLContext returns the url for a specific format with a context\nfunc (c *Client) GetStreamURLContext(ctx context.Context, video *Video, format *Format) (string, error) {\n\tif format == nil {\n\t\treturn \"\", ErrNoFormat\n\t}\n\n\tc.assureClient()\n\n\tif format.URL != \"\" {\n\t\tif c.client.androidVersion > 0 {\n\t\t\treturn format.URL, nil\n\t\t}\n\n\t\treturn c.unThrottle(ctx, video.ID, format.URL)\n\t}\n\n\t// TODO: check rest of this function, is it redundant?\n\n\tcipher := format.Cipher\n\tif cipher == \"\" {\n\t\treturn \"\", ErrCipherNotFound\n\t}\n\n\turi, err := c.decipherURL(ctx, video.ID, cipher)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\treturn uri, err\n}\n\n// httpDo sends an HTTP request and returns an HTTP response.\nfunc (c *Client) httpDo(req *http.Request) (*http.Response, error) {\n\tclient := c.HTTPClient\n\tif client == nil {\n\t\tclient = http.DefaultClient\n\t}\n\n\treq.Header.Set(\"User-Agent\", c.client.userAgent)\n\treq.Header.Set(\"Origin\", \"https://youtube.com\")\n\treq.Header.Set(\"Sec-Fetch-Mode\", \"navigate\")\n\n\tif len(c.consentID) == 0 {\n\t\tc.consentID = strconv.Itoa(rand.Intn(899) + 100) //nolint:gosec\n\t}\n\n\treq.AddCookie(&http.Cookie{\n\t\tName:   \"CONSENT\",\n\t\tValue:  \"YES+cb.20210328-17-p0.en+FX+\" + c.consentID,\n\t\tPath:   \"/\",\n\t\tDomain: \".youtube.com\",\n\t})\n\n\tres, err := client.Do(req)\n\n\tlog := slog.With(\"method\", req.Method, \"url\", req.URL)\n\n\tif err == nil && res.StatusCode != http.StatusOK {\n\t\terr = ErrUnexpectedStatusCode(res.StatusCode)\n\t\tres.Body.Close()\n\t\tres = nil\n\t}\n\n\tif err != nil {\n\t\tlog.Debug(\"HTTP request failed\", \"error\", err)\n\t} else {\n\t\tlog.Debug(\"HTTP request succeeded\", \"status\", res.Status)\n\t}\n\n\treturn res, err\n}\n\n// httpGet does a HTTP GET request, checks the response to be a 200 OK and returns it\nfunc (c *Client) httpGet(ctx context.Context, url string) (*http.Response, error) {\n\treq, err := http.NewRequestWithContext(ctx, http.MethodGet, url, nil)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tresp, err := c.httpDo(req)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif resp.StatusCode != http.StatusOK {\n\t\tresp.Body.Close()\n\t\treturn nil, ErrUnexpectedStatusCode(resp.StatusCode)\n\t}\n\n\treturn resp, nil\n}\n\n// httpGetBodyBytes reads the whole HTTP body and returns it\nfunc (c *Client) httpGetBodyBytes(ctx context.Context, url string) ([]byte, error) {\n\tresp, err := c.httpGet(ctx, url)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer resp.Body.Close()\n\n\treturn io.ReadAll(resp.Body)\n}\n\n// httpPost does a HTTP POST request with a body, checks the response to be a 200 OK and returns it\nfunc (c *Client) httpPost(ctx context.Context, url string, body interface{}) (*http.Response, error) {\n\tdata, err := json.Marshal(body)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treq, err := http.NewRequestWithContext(ctx, http.MethodPost, url, bytes.NewReader(data))\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treq.Header.Set(\"X-Youtube-Client-Name\", \"3\")\n\treq.Header.Set(\"X-Youtube-Client-Version\", c.client.version)\n\treq.Header.Set(\"Content-Type\", \"application/json\")\n\treq.Header.Set(\"Accept\", \"text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8\")\n\n\tresp, err := c.httpDo(req)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif resp.StatusCode != http.StatusOK {\n\t\tresp.Body.Close()\n\t\treturn nil, ErrUnexpectedStatusCode(resp.StatusCode)\n\t}\n\n\treturn resp, nil\n}\n\n// httpPostBodyBytes reads the whole HTTP body and returns it\nfunc (c *Client) httpPostBodyBytes(ctx context.Context, url string, body interface{}) ([]byte, error) {\n\tresp, err := c.httpPost(ctx, url, body)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer resp.Body.Close()\n\n\treturn io.ReadAll(resp.Body)\n}\n\n// downloadChunk writes the response data into the data channel of the chunk.\n// Downloading in multiple chunks is much faster:\n// https://github.com/kkdai/youtube/pull/190\nfunc (c *Client) downloadChunk(req *http.Request, chunk *chunk) error {\n\tq := req.URL.Query()\n\tq.Set(\"range\", fmt.Sprintf(\"%d-%d\", chunk.start, chunk.end))\n\treq.URL.RawQuery = q.Encode()\n\n\tresp, err := c.httpDo(req)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer resp.Body.Close()\n\n\tif resp.StatusCode != http.StatusOK {\n\t\treturn ErrUnexpectedStatusCode(resp.StatusCode)\n\t}\n\n\texpected := int(chunk.end-chunk.start) + 1\n\tdata, err := io.ReadAll(resp.Body)\n\tn := len(data)\n\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif n != expected {\n\t\treturn fmt.Errorf(\"chunk at offset %d has invalid size: expected=%d actual=%d\", chunk.start, expected, n)\n\t}\n\n\tchunk.data <- data\n\n\treturn nil\n}\n"
        },
        {
          "name": "client_test.go",
          "type": "blob",
          "size": 7.6103515625,
          "content": "package youtube\n\nimport (\n\t\"io\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/stretchr/testify/assert\"\n\t\"github.com/stretchr/testify/require\"\n\t\"golang.org/x/net/context\"\n)\n\nconst (\n\tdwlURL    string = \"https://www.youtube.com/watch?v=rFejpH_tAHM\"\n\tstreamURL string = \"https://www.youtube.com/watch?v=a9LDPn-MO4I\"\n\terrURL    string = \"https://www.youtube.com/watch?v=I8oGsuQ\"\n)\n\nvar testClient = Client{}\nvar testWebClient = Client{client: &WebClient}\n\nfunc TestParseVideo(t *testing.T) {\n\tvideo, err := testClient.GetVideo(dwlURL)\n\tassert.NoError(t, err)\n\tassert.NotNil(t, video)\n\n\t_, err = testClient.GetVideo(errURL)\n\tassert.IsType(t, err, &ErrPlayabiltyStatus{})\n}\n\nfunc TestYoutube_findVideoID(t *testing.T) {\n\ttype args struct {\n\t\turl string\n\t}\n\ttests := []struct {\n\t\tname        string\n\t\targs        args\n\t\twantErr     bool\n\t\texpectedErr error\n\t}{\n\t\t{\n\t\t\tname: \"valid url\",\n\t\t\targs: args{\n\t\t\t\tdwlURL,\n\t\t\t},\n\t\t\twantErr:     false,\n\t\t\texpectedErr: nil,\n\t\t},\n\t\t{\n\t\t\tname: \"valid id\",\n\t\t\targs: args{\n\t\t\t\t\"rFejpH_tAHM\",\n\t\t\t},\n\t\t\twantErr:     false,\n\t\t\texpectedErr: nil,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid character in id\",\n\t\t\targs: args{\n\t\t\t\t\"<M13\",\n\t\t\t},\n\t\t\twantErr:     true,\n\t\t\texpectedErr: ErrInvalidCharactersInVideoID,\n\t\t},\n\t\t{\n\t\t\tname: \"video id is less than 10 characters\",\n\t\t\targs: args{\n\t\t\t\t\"rFejpH\",\n\t\t\t},\n\t\t\twantErr:     true,\n\t\t\texpectedErr: ErrVideoIDMinLength,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif _, err := ExtractVideoID(tt.args.url); (err != nil) != tt.wantErr || err != tt.expectedErr {\n\t\t\t\tt.Errorf(\"extractVideoID() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestGetVideoWithoutManifestURL(t *testing.T) {\n\tassert, require := assert.New(t), require.New(t)\n\n\tvideo, err := testClient.GetVideo(dwlURL)\n\trequire.NoError(err, \"get video\")\n\trequire.NotNil(video)\n\n\tassert.NotEmpty(video.Thumbnails)\n\tassert.Greater(len(video.Thumbnails), 0)\n\tassert.NotEmpty(video.Thumbnails[0].URL)\n\tassert.Empty(video.HLSManifestURL)\n\tassert.Empty(video.DASHManifestURL)\n\n\tassert.NotEmpty(video.CaptionTracks)\n\tassert.Greater(len(video.CaptionTracks), 0)\n\tassert.NotEmpty(video.CaptionTracks[0].BaseURL)\n\n\tassert.Equal(\"rFejpH_tAHM\", video.ID)\n\tassert.Equal(\"dotGo 2015 - Rob Pike - Simplicity is Complicated\", video.Title)\n\tassert.Equal(\"dotconferences\", video.Author)\n\tassert.GreaterOrEqual(video.Duration, 1390*time.Second)\n\tassert.Contains(video.Description, \"Go is often described as a simple language.\")\n\n\t// Publishing date doesn't seem to be present in android client\n\t// assert.Equal(\"2015-12-02 00:00:00 +0000 UTC\", video.PublishDate.String())\n}\n\nfunc TestWebClientGetVideoWithoutManifestURL(t *testing.T) {\n\tassert, require := assert.New(t), require.New(t)\n\n\tvideo, err := testWebClient.GetVideo(dwlURL)\n\trequire.NoError(err, \"get video\")\n\trequire.NotNil(video)\n\n\tassert.NotEmpty(video.Thumbnails)\n\tassert.Greater(len(video.Thumbnails), 0)\n\tassert.NotEmpty(video.Thumbnails[0].URL)\n\tassert.Empty(video.HLSManifestURL)\n\tassert.Empty(video.DASHManifestURL)\n\n\tassert.NotEmpty(video.CaptionTracks)\n\tassert.Greater(len(video.CaptionTracks), 0)\n\tassert.NotEmpty(video.CaptionTracks[0].BaseURL)\n\n\tassert.Equal(\"rFejpH_tAHM\", video.ID)\n\tassert.Equal(\"dotGo 2015 - Rob Pike - Simplicity is Complicated\", video.Title)\n\tassert.Equal(\"dotconferences\", video.Author)\n\tassert.GreaterOrEqual(video.Duration, 1390*time.Second)\n\tassert.Contains(video.Description, \"Go is often described as a simple language.\")\n\n\t// Publishing date and channel handle are present in web client\n\t//assert.Equal(\"2015-12-02 00:00:00 +0000 UTC\", video.PublishDate.String())\n\n\tassert.Equal(\"@dotconferences\", video.ChannelHandle)\n}\n\nfunc TestGetVideoWithManifestURL(t *testing.T) {\n\tassert, require := assert.New(t), require.New(t)\n\n\tvideo, err := testClient.GetVideo(streamURL)\n\trequire.NoError(err)\n\trequire.NotNil(video)\n\n\tassert.NotEmpty(video.Formats)\n\tassert.NotEmpty(video.Thumbnails)\n\tassert.Greater(len(video.Thumbnails), 0)\n\tassert.NotEmpty(video.Thumbnails[0].URL)\n\n\tformat := video.Formats[0]\n\tr, size, err := testClient.GetStream(video, &format)\n\tif assert.NoError(err) {\n\t\tr.Close()\n\t}\n\tassert.NotZero(size)\n}\n\nfunc TestGetVideo_MultiLanguage(t *testing.T) {\n\tassert, require := assert.New(t), require.New(t)\n\tvideo, err := testClient.GetVideo(\"https://www.youtube.com/watch?v=pU9sHwNKc2c\")\n\trequire.NoError(err)\n\trequire.NotNil(video)\n\n\t// collect languages\n\tvar languageNames, lanaguageIDs []string\n\tfor _, format := range video.Formats {\n\t\tif format.AudioTrack != nil {\n\t\t\tlanguageNames = append(languageNames, format.LanguageDisplayName())\n\t\t\tlanaguageIDs = append(lanaguageIDs, format.AudioTrack.ID)\n\t\t}\n\t}\n\n\tassert.Contains(languageNames, \"English original\")\n\tassert.Contains(languageNames, \"Portuguese (Brazil)\")\n\tassert.Contains(lanaguageIDs, \"en.4\")\n\tassert.Contains(lanaguageIDs, \"pt-BR.3\")\n\n\tassert.Empty(video.Formats.Language(\"Does not exist\"))\n\tassert.NotEmpty(video.Formats.Language(\"English original\"))\n}\n\nfunc TestGetStream(t *testing.T) {\n\tassert, require := assert.New(t), require.New(t)\n\n\texpectedSize := 988479\n\n\t// Create testclient to enforce re-using of routines\n\ttestClient := Client{\n\t\tMaxRoutines: 10,\n\t\tChunkSize:   int64(expectedSize) / 11,\n\t}\n\n\t// Download should not last longer than a minute.\n\t// Otherwise we assume Youtube is throtteling us.\n\tctx, cancel := context.WithTimeout(context.Background(), time.Minute)\n\tdefer cancel()\n\n\tvideo, err := testClient.GetVideoContext(ctx, \"https://www.youtube.com/watch?v=BaW_jenozKc\")\n\trequire.NoError(err)\n\trequire.NotNil(video)\n\trequire.Greater(len(video.Formats), 0)\n\n\treader, size, err := testClient.GetStreamContext(ctx, video, &video.Formats[0])\n\trequire.NoError(err)\n\tassert.EqualValues(expectedSize, size)\n\n\tdata, err := io.ReadAll(reader)\n\trequire.NoError(err)\n\tassert.Len(data, int(size))\n}\n\nfunc TestGetPlaylist(t *testing.T) {\n\tassert, require := assert.New(t), require.New(t)\n\n\tplaylist, err := testClient.GetPlaylist(\"https://www.youtube.com/playlist?list=PL59FEE129ADFF2B12\")\n\trequire.NoError(err)\n\trequire.NotNil(playlist)\n\n\tassert.Equal(playlist.Title, \"Test Playlist\")\n\tassert.Equal(playlist.Description, \"\")\n\tassert.Equal(playlist.Author, \"GoogleVoice\")\n\tassert.Equal(len(playlist.Videos), 8)\n\n\tv := playlist.Videos[7]\n\tassert.Equal(v.ID, \"dsUXAEzaC3Q\")\n\tassert.Equal(v.Title, \"Michael Jackson - Bad (Shortened Version)\")\n\tassert.Equal(v.Author, \"Michael Jackson\")\n\tassert.Equal(v.Duration, 4*time.Minute+20*time.Second)\n\n\tassert.NotEmpty(v.Thumbnails)\n\tassert.NotEmpty(v.Thumbnails[0].URL)\n}\n\nfunc TestGetBigPlaylist(t *testing.T) {\n\tassert, require := assert.New(t), require.New(t)\n\n\tplaylist, err := testClient.GetPlaylist(\"https://www.youtube.com/playlist?list=PLTC7VQ12-9raqhLCx1S1E_ic35t94dj28\")\n\trequire.NoError(err)\n\trequire.NotNil(playlist)\n\n\tassert.NotEmpty(playlist.Title)\n\tassert.NotEmpty(playlist.Description)\n\tassert.NotEmpty(playlist.Author)\n\n\tassert.Greater(len(playlist.Videos), 300)\n\tassert.NotEmpty(playlist.Videos[300].ID)\n\n\tt.Logf(\"Playlist Title: %s, Video Count: %d\", playlist.Title, len(playlist.Videos))\n}\n\nfunc TestClient_httpGetBodyBytes(t *testing.T) {\n\ttests := []struct {\n\t\turl           string\n\t\terrorContains string\n\t}{\n\t\t{\"unknown://\", \"unsupported protocol scheme\"},\n\t\t{\"invalid\\nurl\", \"invalid control character in URL\"},\n\t\t{\"http://unknown-host/\", \"dial tcp\"},\n\t\t{\"https://www.google.com/404\", \"unexpected status code: 404\"},\n\t\t{\"http://example.com/\", \"\"},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.url, func(t *testing.T) {\n\t\t\tctx, cancel := context.WithTimeout(context.Background(), time.Second)\n\t\t\tdefer cancel()\n\t\t\t_, err := testClient.httpGetBodyBytes(ctx, tt.url)\n\n\t\t\tif tt.errorContains == \"\" {\n\t\t\t\tassert.NoError(t, err)\n\t\t\t} else if assert.Error(t, err) {\n\t\t\t\tassert.Contains(t, err.Error(), tt.errorContains)\n\t\t\t}\n\t\t})\n\t}\n}\n"
        },
        {
          "name": "cmd",
          "type": "tree",
          "content": null
        },
        {
          "name": "decipher.go",
          "type": "blob",
          "size": 6.697265625,
          "content": "package youtube\n\nimport (\n\t\"bytes\"\n\t\"context\"\n\t\"errors\"\n\t\"fmt\"\n\t\"net/url\"\n\t\"regexp\"\n\t\"strconv\"\n\n\t\"github.com/dop251/goja\"\n)\n\nfunc (c *Client) decipherURL(ctx context.Context, videoID string, cipher string) (string, error) {\n\tparams, err := url.ParseQuery(cipher)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\turi, err := url.Parse(params.Get(\"url\"))\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\tquery := uri.Query()\n\n\tconfig, err := c.getPlayerConfig(ctx, videoID)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\t// decrypt s-parameter\n\tbs, err := config.decrypt([]byte(params.Get(\"s\")))\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\tquery.Add(params.Get(\"sp\"), string(bs))\n\n\tquery, err = c.decryptNParam(config, query)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\turi.RawQuery = query.Encode()\n\n\treturn uri.String(), nil\n}\n\n// see https://github.com/kkdai/youtube/pull/244\nfunc (c *Client) unThrottle(ctx context.Context, videoID string, urlString string) (string, error) {\n\tconfig, err := c.getPlayerConfig(ctx, videoID)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\turi, err := url.Parse(urlString)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\t// for debugging\n\tif artifactsFolder != \"\" {\n\t\twriteArtifact(\"video-\"+videoID+\".url\", []byte(uri.String()))\n\t}\n\n\tquery, err := c.decryptNParam(config, uri.Query())\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\turi.RawQuery = query.Encode()\n\treturn uri.String(), nil\n}\n\nfunc (c *Client) decryptNParam(config playerConfig, query url.Values) (url.Values, error) {\n\t// decrypt n-parameter\n\tnSig := query.Get(\"v\")\n\tlog := Logger.With(\"n\", nSig)\n\n\tif nSig != \"\" {\n\t\tnDecoded, err := config.decodeNsig(nSig)\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"unable to decode nSig: %w\", err)\n\t\t}\n\t\tquery.Set(\"v\", nDecoded)\n\t\tlog = log.With(\"decoded\", nDecoded)\n\t}\n\n\tlog.Debug(\"nParam\")\n\n\treturn query, nil\n}\n\nconst (\n\tjsvarStr   = \"[a-zA-Z_\\\\$][a-zA-Z_0-9]*\"\n\treverseStr = \":function\\\\(a\\\\)\\\\{\" +\n\t\t\"(?:return )?a\\\\.reverse\\\\(\\\\)\" +\n\t\t\"\\\\}\"\n\tspliceStr = \":function\\\\(a,b\\\\)\\\\{\" +\n\t\t\"a\\\\.splice\\\\(0,b\\\\)\" +\n\t\t\"\\\\}\"\n\tswapStr = \":function\\\\(a,b\\\\)\\\\{\" +\n\t\t\"var c=a\\\\[0\\\\];a\\\\[0\\\\]=a\\\\[b(?:%a\\\\.length)?\\\\];a\\\\[b(?:%a\\\\.length)?\\\\]=c(?:;return a)?\" +\n\t\t\"\\\\}\"\n)\n\nvar (\n\tnFunctionNameRegexp = regexp.MustCompile(\"\\\\.get\\\\(\\\"n\\\"\\\\)\\\\)&&\\\\(b=([a-zA-Z0-9$]{0,3})\\\\[(\\\\d+)\\\\](.+)\\\\|\\\\|([a-zA-Z0-9]{0,3})\")\n\tactionsObjRegexp    = regexp.MustCompile(fmt.Sprintf(\n\t\t\"var (%s)=\\\\{((?:(?:%s%s|%s%s|%s%s),?\\\\n?)+)\\\\};\", jsvarStr, jsvarStr, swapStr, jsvarStr, spliceStr, jsvarStr, reverseStr))\n\n\tactionsFuncRegexp = regexp.MustCompile(fmt.Sprintf(\n\t\t\"function(?: %s)?\\\\(a\\\\)\\\\{\"+\n\t\t\t\"a=a\\\\.split\\\\(\\\"\\\"\\\\);\\\\s*\"+\n\t\t\t\"((?:(?:a=)?%s\\\\.%s\\\\(a,\\\\d+\\\\);)+)\"+\n\t\t\t\"return a\\\\.join\\\\(\\\"\\\"\\\\)\"+\n\t\t\t\"\\\\}\", jsvarStr, jsvarStr, jsvarStr))\n\n\treverseRegexp = regexp.MustCompile(fmt.Sprintf(\"(?m)(?:^|,)(%s)%s\", jsvarStr, reverseStr))\n\tspliceRegexp  = regexp.MustCompile(fmt.Sprintf(\"(?m)(?:^|,)(%s)%s\", jsvarStr, spliceStr))\n\tswapRegexp    = regexp.MustCompile(fmt.Sprintf(\"(?m)(?:^|,)(%s)%s\", jsvarStr, swapStr))\n)\n\nfunc (config playerConfig) decodeNsig(encoded string) (string, error) {\n\tfBody, err := config.getNFunction()\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\treturn evalJavascript(fBody, encoded)\n}\n\nfunc evalJavascript(jsFunction, arg string) (string, error) {\n\tconst myName = \"myFunction\"\n\n\tvm := goja.New()\n\t_, err := vm.RunString(myName + \"=\" + jsFunction)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\tvar output func(string) string\n\terr = vm.ExportTo(vm.Get(myName), &output)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\treturn output(arg), nil\n}\n\nfunc (config playerConfig) getNFunction() (string, error) {\n\tnameResult := nFunctionNameRegexp.FindSubmatch(config)\n\tif len(nameResult) == 0 {\n\t\treturn \"\", errors.New(\"unable to extract n-function name\")\n\t}\n\n\tvar name string\n\tif idx, _ := strconv.Atoi(string(nameResult[2])); idx == 0 {\n\t\tname = string(nameResult[4])\n\t} else {\n\t\tname = string(nameResult[1])\n\t}\n\n\treturn config.extraFunction(name)\n\n}\n\nfunc (config playerConfig) extraFunction(name string) (string, error) {\n\t// find the beginning of the function\n\tdef := []byte(name + \"=function(\")\n\tstart := bytes.Index(config, def)\n\tif start < 1 {\n\t\treturn \"\", fmt.Errorf(\"unable to extract n-function body: looking for '%s'\", def)\n\t}\n\n\t// start after the first curly bracket\n\tpos := start + bytes.IndexByte(config[start:], '{') + 1\n\n\tvar strChar byte\n\n\t// find the bracket closing the function\n\tfor brackets := 1; brackets > 0; pos++ {\n\t\tb := config[pos]\n\t\tswitch b {\n\t\tcase '{':\n\t\t\tif strChar == 0 {\n\t\t\t\tbrackets++\n\t\t\t}\n\t\tcase '}':\n\t\t\tif strChar == 0 {\n\t\t\t\tbrackets--\n\t\t\t}\n\t\tcase '`', '\"', '\\'':\n\t\t\tif config[pos-1] == '\\\\' && config[pos-2] != '\\\\' {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif strChar == 0 {\n\t\t\t\tstrChar = b\n\t\t\t} else if strChar == b {\n\t\t\t\tstrChar = 0\n\t\t\t}\n\t\t}\n\t}\n\n\treturn string(config[start:pos]), nil\n}\n\nfunc (config playerConfig) decrypt(cyphertext []byte) ([]byte, error) {\n\toperations, err := config.parseDecipherOps()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// apply operations\n\tbs := []byte(cyphertext)\n\tfor _, op := range operations {\n\t\tbs = op(bs)\n\t}\n\n\treturn bs, nil\n}\n\n/*\nparses decipher operations from https://youtube.com/s/player/4fbb4d5b/player_ias.vflset/en_US/base.js\n\nvar Mt={\nsplice:function(a,b){a.splice(0,b)},\nreverse:function(a){a.reverse()},\nEQ:function(a,b){var c=a[0];a[0]=a[b%a.length];a[b%a.length]=c}};\n\na=a.split(\"\");\nMt.splice(a,3);\nMt.EQ(a,39);\nMt.splice(a,2);\nMt.EQ(a,1);\nMt.splice(a,1);\nMt.EQ(a,35);\nMt.EQ(a,51);\nMt.splice(a,2);\nMt.reverse(a,52);\nreturn a.join(\"\")\n*/\nfunc (config playerConfig) parseDecipherOps() (operations []DecipherOperation, err error) {\n\tobjResult := actionsObjRegexp.FindSubmatch(config)\n\tfuncResult := actionsFuncRegexp.FindSubmatch(config)\n\tif len(objResult) < 3 || len(funcResult) < 2 {\n\t\treturn nil, fmt.Errorf(\"error parsing signature tokens (#obj=%d, #func=%d)\", len(objResult), len(funcResult))\n\t}\n\n\tobj := objResult[1]\n\tobjBody := objResult[2]\n\tfuncBody := funcResult[1]\n\n\tvar reverseKey, spliceKey, swapKey string\n\n\tif result := reverseRegexp.FindSubmatch(objBody); len(result) > 1 {\n\t\treverseKey = string(result[1])\n\t}\n\tif result := spliceRegexp.FindSubmatch(objBody); len(result) > 1 {\n\t\tspliceKey = string(result[1])\n\t}\n\tif result := swapRegexp.FindSubmatch(objBody); len(result) > 1 {\n\t\tswapKey = string(result[1])\n\t}\n\n\tregex, err := regexp.Compile(fmt.Sprintf(\"(?:a=)?%s\\\\.(%s|%s|%s)\\\\(a,(\\\\d+)\\\\)\", regexp.QuoteMeta(string(obj)), regexp.QuoteMeta(reverseKey), regexp.QuoteMeta(spliceKey), regexp.QuoteMeta(swapKey)))\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tvar ops []DecipherOperation\n\tfor _, s := range regex.FindAllSubmatch(funcBody, -1) {\n\t\tswitch string(s[1]) {\n\t\tcase reverseKey:\n\t\t\tops = append(ops, reverseFunc)\n\t\tcase swapKey:\n\t\t\targ, _ := strconv.Atoi(string(s[2]))\n\t\t\tops = append(ops, newSwapFunc(arg))\n\t\tcase spliceKey:\n\t\t\targ, _ := strconv.Atoi(string(s[2]))\n\t\t\tops = append(ops, newSpliceFunc(arg))\n\t\t}\n\t}\n\treturn ops, nil\n}\n"
        },
        {
          "name": "decipher_operations.go",
          "type": "blob",
          "size": 0.439453125,
          "content": "package youtube\n\ntype DecipherOperation func([]byte) []byte\n\nfunc newSpliceFunc(pos int) DecipherOperation {\n\treturn func(bs []byte) []byte {\n\t\treturn bs[pos:]\n\t}\n}\n\nfunc newSwapFunc(arg int) DecipherOperation {\n\treturn func(bs []byte) []byte {\n\t\tpos := arg % len(bs)\n\t\tbs[0], bs[pos] = bs[pos], bs[0]\n\t\treturn bs\n\t}\n}\n\nfunc reverseFunc(bs []byte) []byte {\n\tl, r := 0, len(bs)-1\n\tfor l < r {\n\t\tbs[l], bs[r] = bs[r], bs[l]\n\t\tl++\n\t\tr--\n\t}\n\treturn bs\n}\n"
        },
        {
          "name": "doc.go",
          "type": "blob",
          "size": 0.078125,
          "content": "/*\nPackage youtube implement youtube download package in go.\n*/\npackage youtube\n"
        },
        {
          "name": "downloader",
          "type": "tree",
          "content": null
        },
        {
          "name": "errors.go",
          "type": "blob",
          "size": 1.431640625,
          "content": "package youtube\n\nimport (\n\t\"fmt\"\n)\n\nconst (\n\tErrCipherNotFound             = constError(\"cipher not found\")\n\tErrSignatureTimestampNotFound = constError(\"signature timestamp not found\")\n\tErrInvalidCharactersInVideoID = constError(\"invalid characters in video id\")\n\tErrVideoIDMinLength           = constError(\"the video id must be at least 10 characters long\")\n\tErrReadOnClosedResBody        = constError(\"http: read on closed response body\")\n\tErrNotPlayableInEmbed         = constError(\"embedding of this video has been disabled\")\n\tErrLoginRequired              = constError(\"login required to confirm your age\")\n\tErrVideoPrivate               = constError(\"user restricted access to this video\")\n\tErrInvalidPlaylist            = constError(\"no playlist detected or invalid playlist ID\")\n)\n\ntype constError string\n\nfunc (e constError) Error() string {\n\treturn string(e)\n}\n\ntype ErrPlayabiltyStatus struct {\n\tStatus string\n\tReason string\n}\n\nfunc (err ErrPlayabiltyStatus) Error() string {\n\treturn fmt.Sprintf(\"cannot playback and download, status: %s, reason: %s\", err.Status, err.Reason)\n}\n\n// ErrUnexpectedStatusCode is returned on unexpected HTTP status codes\ntype ErrUnexpectedStatusCode int\n\nfunc (err ErrUnexpectedStatusCode) Error() string {\n\treturn fmt.Sprintf(\"unexpected status code: %d\", err)\n}\n\ntype ErrPlaylistStatus struct {\n\tReason string\n}\n\nfunc (err ErrPlaylistStatus) Error() string {\n\treturn fmt.Sprintf(\"could not load playlist: %s\", err.Reason)\n}\n"
        },
        {
          "name": "errors_test.go",
          "type": "blob",
          "size": 0.5947265625,
          "content": "package youtube\n\nimport (\n\t\"strconv\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestErrors(t *testing.T) {\n\tt.Parallel()\n\n\ttests := []struct {\n\t\terr      error\n\t\texpected string\n\t}{\n\t\t{ErrUnexpectedStatusCode(404), \"unexpected status code: 404\"},\n\t\t{ErrPlayabiltyStatus{\"invalid\", \"for that reason\"}, \"cannot playback and download, status: invalid, reason: for that reason\"},\n\t\t{ErrPlaylistStatus{\"for that reason\"}, \"could not load playlist: for that reason\"},\n\t}\n\tfor i, tt := range tests {\n\t\tt.Run(strconv.Itoa(i), func(t *testing.T) {\n\t\t\tassert.EqualError(t, tt.err, tt.expected)\n\t\t})\n\t}\n}\n"
        },
        {
          "name": "example_test.go",
          "type": "blob",
          "size": 1.7314453125,
          "content": "package youtube_test\n\nimport (\n\t\"fmt\"\n\t\"io\"\n\t\"os\"\n\t\"strings\"\n\n\t\"github.com/kkdai/youtube/v2\"\n)\n\n// ExampleDownload : Example code for how to use this package for download video.\nfunc ExampleClient() {\n\tvideoID := \"BaW_jenozKc\"\n\tclient := youtube.Client{}\n\n\tvideo, err := client.GetVideo(videoID)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\tformats := video.Formats.WithAudioChannels() // only get videos with audio\n\tstream, _, err := client.GetStream(video, &formats[0])\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tdefer stream.Close()\n\n\tfile, err := os.Create(\"video.mp4\")\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tdefer file.Close()\n\n\t_, err = io.Copy(file, stream)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n}\n\n// Example usage for playlists: downloading and checking information.\nfunc ExamplePlaylist() {\n\tplaylistID := \"PLQZgI7en5XEgM0L1_ZcKmEzxW1sCOVZwP\"\n\tclient := youtube.Client{}\n\n\tplaylist, err := client.GetPlaylist(playlistID)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\t/* ----- Enumerating playlist videos ----- */\n\theader := fmt.Sprintf(\"Playlist %s by %s\", playlist.Title, playlist.Author)\n\tprintln(header)\n\tprintln(strings.Repeat(\"=\", len(header)) + \"\\n\")\n\n\tfor k, v := range playlist.Videos {\n\t\tfmt.Printf(\"(%d) %s - '%s'\\n\", k+1, v.Author, v.Title)\n\t}\n\n\t/* ----- Downloading the 1st video ----- */\n\tentry := playlist.Videos[0]\n\tvideo, err := client.VideoFromPlaylistEntry(entry)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\t// Now it's fully loaded.\n\n\tfmt.Printf(\"Downloading %s by '%s'!\\n\", video.Title, video.Author)\n\n\tstream, _, err := client.GetStream(video, &video.Formats[0])\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\tfile, err := os.Create(\"video.mp4\")\n\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\tdefer file.Close()\n\t_, err = io.Copy(file, stream)\n\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\tprintln(\"Downloaded /video.mp4\")\n}\n"
        },
        {
          "name": "fetch_testdata_helper.go",
          "type": "blob",
          "size": 0.6318359375,
          "content": "//go:build fetch\n// +build fetch\n\npackage youtube\n\nimport (\n\t\"fmt\"\n\t\"io\"\n\t\"net/http\"\n\t\"os\"\n)\n\nfunc init() {\n\tFetchTestData()\n}\n\n// ran via go generate to fetch and update the playlist response data\nfunc FetchTestData() {\n\tf, err := os.Create(testPlaylistResponseDataFile)\n\texitOnError(err)\n\trequestURL := fmt.Sprintf(playlistFetchURL, testPlaylistID)\n\tresp, err := http.Get(requestURL)\n\texitOnError(err)\n\tdefer resp.Body.Close()\n\tn, err := io.Copy(f, resp.Body)\n\texitOnError(err)\n\tfmt.Printf(\"Successfully fetched playlist %s (%d bytes)\\n\", testPlaylistID, n)\n}\n\nfunc exitOnError(err error) {\n\tif err != nil {\n\t\tfmt.Println(err)\n\t\tos.Exit(1)\n\t}\n}\n"
        },
        {
          "name": "format_list.go",
          "type": "blob",
          "size": 4.330078125,
          "content": "package youtube\n\nimport (\n\t\"sort\"\n\t\"strconv\"\n\t\"strings\"\n)\n\ntype FormatList []Format\n\n// Type returns a new FormatList filtered by itag\nfunc (list FormatList) Select(f func(Format) bool) (result FormatList) {\n\tfor i := range list {\n\t\tif f(list[i]) {\n\t\t\tresult = append(result, list[i])\n\t\t}\n\t}\n\treturn result\n}\n\n// Type returns a new FormatList filtered by itag\nfunc (list FormatList) Itag(itagNo int) FormatList {\n\treturn list.Select(func(f Format) bool {\n\t\treturn f.ItagNo == itagNo\n\t})\n}\n\n// Type returns a new FormatList filtered by mime type\nfunc (list FormatList) Type(value string) FormatList {\n\treturn list.Select(func(f Format) bool {\n\t\treturn strings.Contains(f.MimeType, value)\n\t})\n}\n\n// Type returns a new FormatList filtered by display name\nfunc (list FormatList) Language(displayName string) FormatList {\n\treturn list.Select(func(f Format) bool {\n\t\treturn f.LanguageDisplayName() == displayName\n\t})\n}\n\n// Quality returns a new FormatList filtered by quality, quality label or itag,\n// but not audio quality\nfunc (list FormatList) Quality(quality string) FormatList {\n\titag, _ := strconv.Atoi(quality)\n\n\treturn list.Select(func(f Format) bool {\n\t\treturn itag == f.ItagNo || strings.Contains(f.Quality, quality) || strings.Contains(f.QualityLabel, quality)\n\t})\n}\n\n// AudioChannels returns a new FormatList filtered by the matching AudioChannels\nfunc (list FormatList) AudioChannels(n int) FormatList {\n\treturn list.Select(func(f Format) bool {\n\t\treturn f.AudioChannels == n\n\t})\n}\n\n// AudioChannels returns a new FormatList filtered by the matching AudioChannels\nfunc (list FormatList) WithAudioChannels() FormatList {\n\treturn list.Select(func(f Format) bool {\n\t\treturn f.AudioChannels > 0\n\t})\n}\n\n// FilterQuality reduces the format list to formats matching the quality\nfunc (v *Video) FilterQuality(quality string) {\n\tv.Formats = v.Formats.Quality(quality)\n\tv.Formats.Sort()\n}\n\n// Sort sorts all formats fields\nfunc (list FormatList) Sort() {\n\tsort.SliceStable(list, func(i, j int) bool {\n\t\treturn sortFormat(i, j, list)\n\t})\n}\n\n// sortFormat sorts video by resolution, FPS, codec (av01, vp9, avc1), bitrate\n// sorts audio by default, codec (mp4, opus), channels, bitrate, sample rate\nfunc sortFormat(i int, j int, formats FormatList) bool {\n\n\t// Sort by Width\n\tif formats[i].Width == formats[j].Width {\n\t\t// Format 137 downloads slowly, give it less priority\n\t\t// see https://github.com/kkdai/youtube/pull/171\n\t\tswitch 137 {\n\t\tcase formats[i].ItagNo:\n\t\t\treturn false\n\t\tcase formats[j].ItagNo:\n\t\t\treturn true\n\t\t}\n\n\t\t// Sort by FPS\n\t\tif formats[i].FPS == formats[j].FPS {\n\t\t\tif formats[i].FPS == 0 && formats[i].AudioChannels > 0 && formats[j].AudioChannels > 0 {\n\t\t\t\t// Audio\n\t\t\t\t// Sort by default\n\t\t\t\tif (formats[i].AudioTrack == nil && formats[j].AudioTrack == nil) || (formats[i].AudioTrack != nil && formats[j].AudioTrack != nil && formats[i].AudioTrack.AudioIsDefault == formats[j].AudioTrack.AudioIsDefault) {\n\t\t\t\t\t// Sort by codec\n\t\t\t\t\tcodec := map[int]int{}\n\t\t\t\t\tfor _, index := range []int{i, j} {\n\t\t\t\t\t\tif strings.Contains(formats[index].MimeType, \"mp4\") {\n\t\t\t\t\t\t\tcodec[index] = 1\n\t\t\t\t\t\t} else if strings.Contains(formats[index].MimeType, \"opus\") {\n\t\t\t\t\t\t\tcodec[index] = 2\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif codec[i] == codec[j] {\n\t\t\t\t\t\t// Sort by Audio Channel\n\t\t\t\t\t\tif formats[i].AudioChannels == formats[j].AudioChannels {\n\t\t\t\t\t\t\t// Sort by Audio Bitrate\n\t\t\t\t\t\t\tif formats[i].Bitrate == formats[j].Bitrate {\n\t\t\t\t\t\t\t\t// Sort by Audio Sample Rate\n\t\t\t\t\t\t\t\treturn formats[i].AudioSampleRate > formats[j].AudioSampleRate\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn formats[i].Bitrate > formats[j].Bitrate\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn formats[i].AudioChannels > formats[j].AudioChannels\n\t\t\t\t\t}\n\t\t\t\t\treturn codec[i] < codec[j]\n\t\t\t\t} else if formats[i].AudioTrack != nil && formats[i].AudioTrack.AudioIsDefault {\n\t\t\t\t\treturn true\n\t\t\t\t}\n\t\t\t\treturn false\n\t\t\t}\n\t\t\t// Video\n\t\t\t// Sort by codec\n\t\t\tcodec := map[int]int{}\n\t\t\tfor _, index := range []int{i, j} {\n\t\t\t\tif strings.Contains(formats[index].MimeType, \"av01\") {\n\t\t\t\t\tcodec[index] = 1\n\t\t\t\t} else if strings.Contains(formats[index].MimeType, \"vp9\") {\n\t\t\t\t\tcodec[index] = 2\n\t\t\t\t} else if strings.Contains(formats[index].MimeType, \"avc1\") {\n\t\t\t\t\tcodec[index] = 3\n\t\t\t\t}\n\t\t\t}\n\t\t\tif codec[i] == codec[j] {\n\t\t\t\t// Sort by Audio Bitrate\n\t\t\t\treturn formats[i].Bitrate > formats[j].Bitrate\n\t\t\t}\n\t\t\treturn codec[i] < codec[j]\n\t\t}\n\t\treturn formats[i].FPS > formats[j].FPS\n\t}\n\treturn formats[i].Width > formats[j].Width\n}\n"
        },
        {
          "name": "format_list_test.go",
          "type": "blob",
          "size": 2.4208984375,
          "content": "package youtube\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\ntype filter struct {\n\tQuality       string\n\tItagNo        int\n\tMimeType      string\n\tLanguage      string\n\tAudioChannels int\n}\n\nfunc (list FormatList) Filter(filter filter) FormatList {\n\tif filter.ItagNo > 0 {\n\t\tlist = list.Itag(filter.ItagNo)\n\t}\n\tif filter.AudioChannels > 0 {\n\t\tlist = list.AudioChannels(filter.AudioChannels)\n\t}\n\tif filter.Quality != \"\" {\n\t\tlist = list.Quality(filter.Quality)\n\t}\n\tif filter.MimeType != \"\" {\n\t\tlist = list.Type(filter.MimeType)\n\t}\n\tif filter.Language != \"\" {\n\t\tlist = list.Language(filter.Language)\n\t}\n\treturn list\n}\n\nfunc TestFormatList_Filter(t *testing.T) {\n\tt.Parallel()\n\n\tformat1 := Format{\n\t\tItagNo:       1,\n\t\tQuality:      \"medium\",\n\t\tQualityLabel: \"360p\",\n\t}\n\n\tformat2 := Format{\n\t\tItagNo:        2,\n\t\tQuality:       \"large\",\n\t\tQualityLabel:  \"480p\",\n\t\tMimeType:      `video/mp4; codecs=\"avc1.42001E, mp4a.40.2\"`,\n\t\tAudioChannels: 1,\n\t}\n\n\tformatStereo := Format{\n\t\tItagNo:        3,\n\t\tURL:           \"stereo\",\n\t\tAudioChannels: 2,\n\t}\n\n\tlist := FormatList{\n\t\tformat1,\n\t\tformat2,\n\t\tformatStereo,\n\t}\n\n\ttests := []struct {\n\t\tname string\n\t\targs filter\n\t\twant []Format\n\t}{\n\t\t{\n\t\t\tname: \"empty list with quality small\",\n\t\t\targs: filter{\n\t\t\t\tQuality: \"small\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"empty list with other itagNo\",\n\t\t\targs: filter{\n\t\t\t\tItagNo: 99,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"empty list with other mimeType\",\n\t\t\targs: filter{\n\t\t\t\tMimeType: \"other\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"empty list with other audioChannels\",\n\t\t\targs: filter{\n\t\t\t\tAudioChannels: 7,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"audioChannels stereo\",\n\t\t\targs: filter{\n\t\t\t\tAudioChannels: formatStereo.AudioChannels,\n\t\t\t},\n\t\t\twant: []Format{formatStereo},\n\t\t},\n\t\t{\n\t\t\tname: \"find by medium quality\",\n\t\t\targs: filter{\n\t\t\t\tQuality: \"medium\",\n\t\t\t},\n\t\t\twant: []Format{format1},\n\t\t},\n\t\t{\n\t\t\tname: \"find by 480p\",\n\t\t\targs: filter{\n\t\t\t\tQuality: \"480p\",\n\t\t\t},\n\t\t\twant: []Format{format2},\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tformats := list.Filter(tt.args)\n\n\t\t\tif tt.want == nil {\n\t\t\t\tassert.Empty(t, formats)\n\t\t\t} else {\n\t\t\t\tassert.Equal(t, tt.want, []Format(formats))\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestFormatList_Sort(t *testing.T) {\n\tt.Parallel()\n\n\tlist := FormatList{\n\t\t{Width: 512},\n\t\t{Width: 768, MimeType: \"mp4\"},\n\t\t{Width: 768, MimeType: \"opus\"},\n\t}\n\n\tlist.Sort()\n\n\tassert.Equal(t, FormatList{\n\t\t{Width: 768, MimeType: \"mp4\"},\n\t\t{Width: 768, MimeType: \"opus\"},\n\t\t{Width: 512},\n\t}, list)\n}\n"
        },
        {
          "name": "go.mod",
          "type": "blob",
          "size": 1.8955078125,
          "content": "module github.com/kkdai/youtube/v2\n\ngo 1.22.0\n\ntoolchain go1.23.3\n\nrequire (\n\tgithub.com/bitly/go-simplejson v0.5.1\n\tgithub.com/dop251/goja v0.0.0-20241024094426-79f3a7efcdbd\n\tgithub.com/mitchellh/go-homedir v1.1.0\n\tgithub.com/olekukonko/tablewriter v0.0.5\n\tgithub.com/spf13/cobra v1.8.1\n\tgithub.com/spf13/pflag v1.0.5\n\tgithub.com/spf13/viper v1.19.0\n\tgithub.com/stretchr/testify v1.10.0\n\tgithub.com/vbauerster/mpb/v5 v5.4.0\n\tgolang.org/x/net v0.31.0\n)\n\nrequire (\n\tgithub.com/VividCortex/ewma v1.2.0 // indirect\n\tgithub.com/acarl005/stripansi v0.0.0-20180116102854-5a71ef0e047d // indirect\n\tgithub.com/davecgh/go-spew v1.1.2-0.20180830191138-d8f796af33cc // indirect\n\tgithub.com/dlclark/regexp2 v1.11.4 // indirect\n\tgithub.com/fsnotify/fsnotify v1.8.0 // indirect\n\tgithub.com/go-sourcemap/sourcemap v2.1.4+incompatible // indirect\n\tgithub.com/google/pprof v0.0.0-20241203143554-1e3fdc7de467 // indirect\n\tgithub.com/hashicorp/hcl v1.0.0 // indirect\n\tgithub.com/inconshreveable/mousetrap v1.1.0 // indirect\n\tgithub.com/magiconair/properties v1.8.7 // indirect\n\tgithub.com/mattn/go-runewidth v0.0.16 // indirect\n\tgithub.com/mitchellh/mapstructure v1.5.0 // indirect\n\tgithub.com/pelletier/go-toml/v2 v2.2.3 // indirect\n\tgithub.com/pmezard/go-difflib v1.0.1-0.20181226105442-5d4384ee4fb2 // indirect\n\tgithub.com/rivo/uniseg v0.4.7 // indirect\n\tgithub.com/rogpeppe/go-internal v1.13.1 // indirect\n\tgithub.com/sagikazarmark/locafero v0.6.0 // indirect\n\tgithub.com/sagikazarmark/slog-shim v0.1.0 // indirect\n\tgithub.com/sourcegraph/conc v0.3.0 // indirect\n\tgithub.com/spf13/afero v1.11.0 // indirect\n\tgithub.com/spf13/cast v1.7.0 // indirect\n\tgithub.com/subosito/gotenv v1.6.0 // indirect\n\tgo.uber.org/multierr v1.11.0 // indirect\n\tgolang.org/x/exp v0.0.0-20241108190413-2d47ceb2692f // indirect\n\tgolang.org/x/sys v0.27.0 // indirect\n\tgolang.org/x/text v0.20.0 // indirect\n\tgopkg.in/ini.v1 v1.67.0 // indirect\n\tgopkg.in/yaml.v3 v3.0.1 // indirect\n)\n"
        },
        {
          "name": "go.sum",
          "type": "blob",
          "size": 8.623046875,
          "content": "github.com/Masterminds/semver/v3 v3.2.1 h1:RN9w6+7QoMeJVGyfmbcgs28Br8cvmnucEXnY0rYXWg0=\ngithub.com/Masterminds/semver/v3 v3.2.1/go.mod h1:qvl/7zhW3nngYb5+80sSMF+FG2BjYrf8m9wsX0PNOMQ=\ngithub.com/VividCortex/ewma v1.1.1/go.mod h1:2Tkkvm3sRDVXaiyucHiACn4cqf7DpdyLvmxzcbUokwA=\ngithub.com/VividCortex/ewma v1.2.0 h1:f58SaIzcDXrSy3kWaHNvuJgJ3Nmz59Zji6XoJR/q1ow=\ngithub.com/VividCortex/ewma v1.2.0/go.mod h1:nz4BbCtbLyFDeC9SUHbtcT5644juEuWfUAUnGx7j5l4=\ngithub.com/acarl005/stripansi v0.0.0-20180116102854-5a71ef0e047d h1:licZJFw2RwpHMqeKTCYkitsPqHNxTmd4SNR5r94FGM8=\ngithub.com/acarl005/stripansi v0.0.0-20180116102854-5a71ef0e047d/go.mod h1:asat636LX7Bqt5lYEZ27JNDcqxfjdBQuJ/MM4CN/Lzo=\ngithub.com/bitly/go-simplejson v0.5.1 h1:xgwPbetQScXt1gh9BmoJ6j9JMr3TElvuIyjR8pgdoow=\ngithub.com/bitly/go-simplejson v0.5.1/go.mod h1:YOPVLzCfwK14b4Sff3oP1AmGhI9T9Vsg84etUnlyp+Q=\ngithub.com/cpuguy83/go-md2man/v2 v2.0.4/go.mod h1:tgQtvFlXSQOSOSIRvRPT7W67SCa46tRHOmNcaadrF8o=\ngithub.com/davecgh/go-spew v1.1.1/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=\ngithub.com/davecgh/go-spew v1.1.2-0.20180830191138-d8f796af33cc h1:U9qPSI2PIWSS1VwoXQT9A3Wy9MM3WgvqSxFWenqJduM=\ngithub.com/davecgh/go-spew v1.1.2-0.20180830191138-d8f796af33cc/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=\ngithub.com/dlclark/regexp2 v1.11.4 h1:rPYF9/LECdNymJufQKmri9gV604RvvABwgOA8un7yAo=\ngithub.com/dlclark/regexp2 v1.11.4/go.mod h1:DHkYz0B9wPfa6wondMfaivmHpzrQ3v9q8cnmRbL6yW8=\ngithub.com/dop251/goja v0.0.0-20241024094426-79f3a7efcdbd h1:QMSNEh9uQkDjyPwu/J541GgSH+4hw+0skJDIj9HJ3mE=\ngithub.com/dop251/goja v0.0.0-20241024094426-79f3a7efcdbd/go.mod h1:MxLav0peU43GgvwVgNbLAj1s/bSGboKkhuULvq/7hx4=\ngithub.com/frankban/quicktest v1.14.6 h1:7Xjx+VpznH+oBnejlPUj8oUpdxnVs4f8XU8WnHkI4W8=\ngithub.com/frankban/quicktest v1.14.6/go.mod h1:4ptaffx2x8+WTWXmUCuVU6aPUX1/Mz7zb5vbUoiM6w0=\ngithub.com/fsnotify/fsnotify v1.8.0 h1:dAwr6QBTBZIkG8roQaJjGof0pp0EeF+tNV7YBP3F/8M=\ngithub.com/fsnotify/fsnotify v1.8.0/go.mod h1:8jBTzvmWwFyi3Pb8djgCCO5IBqzKJ/Jwo8TRcHyHii0=\ngithub.com/go-sourcemap/sourcemap v2.1.4+incompatible h1:a+iTbH5auLKxaNwQFg0B+TCYl6lbukKPc7b5x0n1s6Q=\ngithub.com/go-sourcemap/sourcemap v2.1.4+incompatible/go.mod h1:F8jJfvm2KbVjc5NqelyYJmf/v5J0dwNLS2mL4sNA1Jg=\ngithub.com/google/go-cmp v0.6.0 h1:ofyhxvXcZhMsU5ulbFiLKl/XBFqE1GSq7atu8tAmTRI=\ngithub.com/google/go-cmp v0.6.0/go.mod h1:17dUlkBOakJ0+DkrSSNjCkIjxS6bF9zb3elmeNGIjoY=\ngithub.com/google/pprof v0.0.0-20241203143554-1e3fdc7de467 h1:keEZFtbLJugfE0qHn+Ge1JCE71spzkchQobDf3mzS/4=\ngithub.com/google/pprof v0.0.0-20241203143554-1e3fdc7de467/go.mod h1:vavhavw2zAxS5dIdcRluK6cSGGPlZynqzFM8NdvU144=\ngithub.com/hashicorp/hcl v1.0.0 h1:0Anlzjpi4vEasTeNFn2mLJgTSwt0+6sfsiTG8qcWGx4=\ngithub.com/hashicorp/hcl v1.0.0/go.mod h1:E5yfLk+7swimpb2L/Alb/PJmXilQ/rhwaUYs4T20WEQ=\ngithub.com/inconshreveable/mousetrap v1.1.0 h1:wN+x4NVGpMsO7ErUn/mUI3vEoE6Jt13X2s0bqwp9tc8=\ngithub.com/inconshreveable/mousetrap v1.1.0/go.mod h1:vpF70FUmC8bwa3OWnCshd2FqLfsEA9PFc4w1p2J65bw=\ngithub.com/kr/pretty v0.3.1 h1:flRD4NNwYAUpkphVc1HcthR4KEIFJ65n8Mw5qdRn3LE=\ngithub.com/kr/pretty v0.3.1/go.mod h1:hoEshYVHaxMs3cyo3Yncou5ZscifuDolrwPKZanG3xk=\ngithub.com/kr/text v0.2.0 h1:5Nx0Ya0ZqY2ygV366QzturHI13Jq95ApcVaJBhpS+AY=\ngithub.com/kr/text v0.2.0/go.mod h1:eLer722TekiGuMkidMxC/pM04lWEeraHUUmBw8l2grE=\ngithub.com/magiconair/properties v1.8.7 h1:IeQXZAiQcpL9mgcAe1Nu6cX9LLw6ExEHKjN0VQdvPDY=\ngithub.com/magiconair/properties v1.8.7/go.mod h1:Dhd985XPs7jluiymwWYZ0G4Z61jb3vdS329zhj2hYo0=\ngithub.com/mattn/go-runewidth v0.0.9/go.mod h1:H031xJmbD/WCDINGzjvQ9THkh0rPKHF+m2gUSrubnMI=\ngithub.com/mattn/go-runewidth v0.0.16 h1:E5ScNMtiwvlvB5paMFdw9p4kSQzbXFikJ5SQO6TULQc=\ngithub.com/mattn/go-runewidth v0.0.16/go.mod h1:Jdepj2loyihRzMpdS35Xk/zdY8IAYHsh153qUoGf23w=\ngithub.com/mitchellh/go-homedir v1.1.0 h1:lukF9ziXFxDFPkA1vsr5zpc1XuPDn/wFntq5mG+4E0Y=\ngithub.com/mitchellh/go-homedir v1.1.0/go.mod h1:SfyaCUpYCn1Vlf4IUYiD9fPX4A5wJrkLzIz1N1q0pr0=\ngithub.com/mitchellh/mapstructure v1.5.0 h1:jeMsZIYE/09sWLaz43PL7Gy6RuMjD2eJVyuac5Z2hdY=\ngithub.com/mitchellh/mapstructure v1.5.0/go.mod h1:bFUtVrKA4DC2yAKiSyO/QUcy7e+RRV2QTWOzhPopBRo=\ngithub.com/olekukonko/tablewriter v0.0.5 h1:P2Ga83D34wi1o9J6Wh1mRuqd4mF/x/lgBS7N7AbDhec=\ngithub.com/olekukonko/tablewriter v0.0.5/go.mod h1:hPp6KlRPjbx+hW8ykQs1w3UBbZlj6HuIJcUGPhkA7kY=\ngithub.com/pelletier/go-toml/v2 v2.2.3 h1:YmeHyLY8mFWbdkNWwpr+qIL2bEqT0o95WSdkNHvL12M=\ngithub.com/pelletier/go-toml/v2 v2.2.3/go.mod h1:MfCQTFTvCcUyyvvwm1+G6H/jORL20Xlb6rzQu9GuUkc=\ngithub.com/pmezard/go-difflib v1.0.1-0.20181226105442-5d4384ee4fb2 h1:Jamvg5psRIccs7FGNTlIRMkT8wgtp5eCXdBlqhYGL6U=\ngithub.com/pmezard/go-difflib v1.0.1-0.20181226105442-5d4384ee4fb2/go.mod h1:iKH77koFhYxTK1pcRnkKkqfTogsbg7gZNVY4sRDYZ/4=\ngithub.com/rivo/uniseg v0.2.0/go.mod h1:J6wj4VEh+S6ZtnVlnTBMWIodfgj8LQOQFoIToxlJtxc=\ngithub.com/rivo/uniseg v0.4.7 h1:WUdvkW8uEhrYfLC4ZzdpI2ztxP1I582+49Oc5Mq64VQ=\ngithub.com/rivo/uniseg v0.4.7/go.mod h1:FN3SvrM+Zdj16jyLfmOkMNblXMcoc8DfTHruCPUcx88=\ngithub.com/rogpeppe/go-internal v1.13.1 h1:KvO1DLK/DRN07sQ1LQKScxyZJuNnedQ5/wKSR38lUII=\ngithub.com/rogpeppe/go-internal v1.13.1/go.mod h1:uMEvuHeurkdAXX61udpOXGD/AzZDWNMNyH2VO9fmH0o=\ngithub.com/russross/blackfriday/v2 v2.1.0/go.mod h1:+Rmxgy9KzJVeS9/2gXHxylqXiyQDYRxCVz55jmeOWTM=\ngithub.com/sagikazarmark/locafero v0.6.0 h1:ON7AQg37yzcRPU69mt7gwhFEBwxI6P9T4Qu3N51bwOk=\ngithub.com/sagikazarmark/locafero v0.6.0/go.mod h1:77OmuIc6VTraTXKXIs/uvUxKGUXjE1GbemJYHqdNjX0=\ngithub.com/sagikazarmark/slog-shim v0.1.0 h1:diDBnUNK9N/354PgrxMywXnAwEr1QZcOr6gto+ugjYE=\ngithub.com/sagikazarmark/slog-shim v0.1.0/go.mod h1:SrcSrq8aKtyuqEI1uvTDTK1arOWRIczQRv+GVI1AkeQ=\ngithub.com/sourcegraph/conc v0.3.0 h1:OQTbbt6P72L20UqAkXXuLOj79LfEanQ+YQFNpLA9ySo=\ngithub.com/sourcegraph/conc v0.3.0/go.mod h1:Sdozi7LEKbFPqYX2/J+iBAM6HpqSLTASQIKqDmF7Mt0=\ngithub.com/spf13/afero v1.11.0 h1:WJQKhtpdm3v2IzqG8VMqrr6Rf3UYpEF239Jy9wNepM8=\ngithub.com/spf13/afero v1.11.0/go.mod h1:GH9Y3pIexgf1MTIWtNGyogA5MwRIDXGUr+hbWNoBjkY=\ngithub.com/spf13/cast v1.7.0 h1:ntdiHjuueXFgm5nzDRdOS4yfT43P5Fnud6DH50rz/7w=\ngithub.com/spf13/cast v1.7.0/go.mod h1:ancEpBxwJDODSW/UG4rDrAqiKolqNNh2DX3mk86cAdo=\ngithub.com/spf13/cobra v1.8.1 h1:e5/vxKd/rZsfSJMUX1agtjeTDf+qv1/JdBF8gg5k9ZM=\ngithub.com/spf13/cobra v1.8.1/go.mod h1:wHxEcudfqmLYa8iTfL+OuZPbBZkmvliBWKIezN3kD9Y=\ngithub.com/spf13/pflag v1.0.5 h1:iy+VFUOCP1a+8yFto/drg2CJ5u0yRoB7fZw3DKv/JXA=\ngithub.com/spf13/pflag v1.0.5/go.mod h1:McXfInJRrz4CZXVZOBLb0bTZqETkiAhM9Iw0y3An2Bg=\ngithub.com/spf13/viper v1.19.0 h1:RWq5SEjt8o25SROyN3z2OrDB9l7RPd3lwTWU8EcEdcI=\ngithub.com/spf13/viper v1.19.0/go.mod h1:GQUN9bilAbhU/jgc1bKs99f/suXKeUMct8Adx5+Ntkg=\ngithub.com/stretchr/testify v1.10.0 h1:Xv5erBjTwe/5IxqUQTdXv5kgmIvbHo3QQyRwhJsOfJA=\ngithub.com/stretchr/testify v1.10.0/go.mod h1:r2ic/lqez/lEtzL7wO/rwa5dbSLXVDPFyf8C91i36aY=\ngithub.com/subosito/gotenv v1.6.0 h1:9NlTDc1FTs4qu0DDq7AEtTPNw6SVm7uBMsUCUjABIf8=\ngithub.com/subosito/gotenv v1.6.0/go.mod h1:Dk4QP5c2W3ibzajGcXpNraDfq2IrhjMIvMSWPKKo0FU=\ngithub.com/vbauerster/mpb/v5 v5.4.0 h1:n8JPunifvQvh6P1D1HAl2Ur9YcmKT1tpoUuiea5mlmg=\ngithub.com/vbauerster/mpb/v5 v5.4.0/go.mod h1:fi4wVo7BVQ22QcvFObm+VwliQXlV1eBT8JDaKXR4JGI=\ngo.uber.org/multierr v1.11.0 h1:blXXJkSxSSfBVBlC76pxqeO+LN3aDfLQo+309xJstO0=\ngo.uber.org/multierr v1.11.0/go.mod h1:20+QtiLqy0Nd6FdQB9TLXag12DsQkrbs3htMFfDN80Y=\ngolang.org/x/exp v0.0.0-20241108190413-2d47ceb2692f h1:XdNn9LlyWAhLVp6P/i8QYBW+hlyhrhei9uErw2B5GJo=\ngolang.org/x/exp v0.0.0-20241108190413-2d47ceb2692f/go.mod h1:D5SMRVC3C2/4+F/DB1wZsLRnSNimn2Sp/NPsCrsv8ak=\ngolang.org/x/net v0.31.0 h1:68CPQngjLL0r2AlUKiSxtQFKvzRVbnzLwMUn5SzcLHo=\ngolang.org/x/net v0.31.0/go.mod h1:P4fl1q7dY2hnZFxEk4pPSkDHF+QqjitcnDjUQyMM+pM=\ngolang.org/x/sys v0.0.0-20201218084310-7d0127a74742/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.27.0 h1:wBqf8DvsY9Y/2P8gAfPDEYNuS30J4lPHJxXSb/nJZ+s=\ngolang.org/x/sys v0.27.0/go.mod h1:/VUhepiaJMQUp4+oa/7Zr1D23ma6VTLIYjOOTFZPUcA=\ngolang.org/x/text v0.20.0 h1:gK/Kv2otX8gz+wn7Rmb3vT96ZwuoxnQlY+HlJVj7Qug=\ngolang.org/x/text v0.20.0/go.mod h1:D4IsuqiFMhST5bX19pQ9ikHC2GsaKyk/oF+pn3ducp4=\ngopkg.in/check.v1 v0.0.0-20161208181325-20d25e280405/go.mod h1:Co6ibVJAznAaIkqp8huTwlJQCZ016jof/cbN4VW5Yz0=\ngopkg.in/check.v1 v1.0.0-20190902080502-41f04d3bba15 h1:YR8cESwS4TdDjEe65xsg0ogRM/Nc3DYOhEAlW+xobZo=\ngopkg.in/check.v1 v1.0.0-20190902080502-41f04d3bba15/go.mod h1:Co6ibVJAznAaIkqp8huTwlJQCZ016jof/cbN4VW5Yz0=\ngopkg.in/ini.v1 v1.67.0 h1:Dgnx+6+nfE+IfzjUEISNeydPJh9AXNNsWbGP9KzCsOA=\ngopkg.in/ini.v1 v1.67.0/go.mod h1:pNLf8WUiyNEtQjuu5G5vTm06TEv9tsIgeAvK8hOrP4k=\ngopkg.in/yaml.v2 v2.4.0 h1:D8xgwECY7CYvx+Y2n4sBz93Jn9JRvxdiyyo8CTfuKaY=\ngopkg.in/yaml.v2 v2.4.0/go.mod h1:RDklbk79AGWmwhnvt/jBztapEOGDOx6ZbXqjP6csGnQ=\ngopkg.in/yaml.v3 v3.0.1 h1:fxVm/GzAzEWqLHuvctI91KS9hhNmmWOoWu0XTYJS7CA=\ngopkg.in/yaml.v3 v3.0.1/go.mod h1:K4uyk7z7BCEPqu6E+C64Yfv1cQ7kz7rIZviUmN+EgEM=\n"
        },
        {
          "name": "itag_test.go",
          "type": "blob",
          "size": 0.349609375,
          "content": "package youtube\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/require\"\n)\n\nfunc TestYoutube_GetItagInfo(t *testing.T) {\n\trequire := require.New(t)\n\tclient := Client{}\n\n\t// url from issue #25\n\turl := \"https://www.youtube.com/watch?v=rFejpH_tAHM\"\n\tvideo, err := client.GetVideo(url)\n\trequire.NoError(err)\n\trequire.GreaterOrEqual(len(video.Formats), 24)\n}\n"
        },
        {
          "name": "logger.go",
          "type": "blob",
          "size": 0.5390625,
          "content": "package youtube\n\nimport (\n\t\"fmt\"\n\t\"log/slog\"\n\t\"os\"\n)\n\n// The global logger for all Client instances\nvar Logger = getLogger(os.Getenv(\"LOGLEVEL\"))\n\nfunc SetLogLevel(value string) {\n\tLogger = getLogger(value)\n}\n\nfunc getLogger(logLevel string) *slog.Logger {\n\tlevelVar := slog.LevelVar{}\n\n\tif logLevel != \"\" {\n\t\tif err := levelVar.UnmarshalText([]byte(logLevel)); err != nil {\n\t\t\tpanic(fmt.Sprintf(\"Invalid log level %s: %v\", logLevel, err))\n\t\t}\n\t}\n\n\treturn slog.New(slog.NewTextHandler(os.Stderr, &slog.HandlerOptions{\n\t\tLevel: levelVar.Level(),\n\t}))\n}\n"
        },
        {
          "name": "player_cache.go",
          "type": "blob",
          "size": 0.873046875,
          "content": "package youtube\n\nimport (\n\t\"time\"\n)\n\nconst defaultCacheExpiration = time.Minute * time.Duration(5)\n\ntype playerCache struct {\n\tkey       string\n\texpiredAt time.Time\n\tconfig    playerConfig\n}\n\n// Get : get cache  when it has same video id and not expired\nfunc (s playerCache) Get(key string) playerConfig {\n\treturn s.GetCacheBefore(key, time.Now())\n}\n\n// GetCacheBefore : can pass time for testing\nfunc (s playerCache) GetCacheBefore(key string, time time.Time) playerConfig {\n\tif key == s.key && s.expiredAt.After(time) {\n\t\treturn s.config\n\t}\n\treturn nil\n}\n\n// Set : set cache with default expiration\nfunc (s *playerCache) Set(key string, operations playerConfig) {\n\ts.setWithExpiredTime(key, operations, time.Now().Add(defaultCacheExpiration))\n}\n\nfunc (s *playerCache) setWithExpiredTime(key string, config playerConfig, time time.Time) {\n\ts.key = key\n\ts.config = config\n\ts.expiredAt = time\n}\n"
        },
        {
          "name": "player_cache_test.go",
          "type": "blob",
          "size": 1.3798828125,
          "content": "package youtube\n\nimport (\n\t\"testing\"\n\t\"time\"\n)\n\nfunc TestPlayerCache(t *testing.T) {\n\ttype args struct {\n\t\tsetVideoID string\n\t\tgetVideoID string\n\t\texpiredAt  string\n\t\tgetCacheAt string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant []byte\n\t}{\n\t\t{\n\t\t\tname: \"Get cache data with video id\",\n\t\t\targs: args{\n\t\t\t\tsetVideoID: \"test\",\n\t\t\t\tgetVideoID: \"test\",\n\t\t\t\texpiredAt:  \"2021-01-01 00:01:00\",\n\t\t\t\tgetCacheAt: \"2021-01-01 00:00:00\",\n\t\t\t},\n\t\t\twant: []byte(\"playerdata\"),\n\t\t},\n\t\t{\n\t\t\tname: \"Get nil when cache is expired\",\n\t\t\targs: args{\n\t\t\t\tsetVideoID: \"test\",\n\t\t\t\tgetVideoID: \"test\",\n\t\t\t\texpiredAt:  \"2021-01-01 00:00:00\",\n\t\t\t\tgetCacheAt: \"2021-01-01 00:00:00\",\n\t\t\t},\n\t\t\twant: nil,\n\t\t},\n\t\t{\n\t\t\tname: \"Get nil when video id is not cached\",\n\t\t\targs: args{\n\t\t\t\tsetVideoID: \"test\",\n\t\t\t\tgetVideoID: \"not test\",\n\t\t\t\texpiredAt:  \"2021-01-01 00:00:01\",\n\t\t\t\tgetCacheAt: \"2021-01-01 00:00:00\",\n\t\t\t},\n\t\t\twant: nil,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\ts := playerCache{}\n\t\t\ttimeFormat := \"2006-01-02 15:04:05\"\n\t\t\texpiredAt, _ := time.Parse(timeFormat, tt.args.expiredAt)\n\t\t\ts.setWithExpiredTime(tt.args.setVideoID, []byte(\"playerdata\"), expiredAt)\n\t\t\tgetCacheAt, _ := time.Parse(timeFormat, tt.args.getCacheAt)\n\t\t\tif got := s.GetCacheBefore(tt.args.getVideoID, getCacheAt); len(got) != len(tt.want) {\n\t\t\t\tt.Errorf(\"GetCacheBefore() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n"
        },
        {
          "name": "player_parse.go",
          "type": "blob",
          "size": 1.37109375,
          "content": "package youtube\n\nimport (\n\t\"context\"\n\t\"errors\"\n\t\"fmt\"\n\t\"log\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"regexp\"\n\t\"strings\"\n)\n\ntype playerConfig []byte\n\nvar basejsPattern = regexp.MustCompile(`(/s/player/\\w+/player_ias.vflset/\\w+/base.js)`)\n\nfunc (c *Client) getPlayerConfig(ctx context.Context, videoID string) (playerConfig, error) {\n\tembedURL := fmt.Sprintf(\"https://youtube.com/embed/%s?hl=en\", videoID)\n\tembedBody, err := c.httpGetBodyBytes(ctx, embedURL)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// example: /s/player/f676c671/player_ias.vflset/en_US/base.js\n\tplayerPath := string(basejsPattern.Find(embedBody))\n\tif playerPath == \"\" {\n\t\treturn nil, errors.New(\"unable to find basejs URL in playerConfig\")\n\t}\n\n\t// for debugging\n\tvar artifactName string\n\tif artifactsFolder != \"\" {\n\t\tparts := strings.SplitN(playerPath, \"/\", 5)\n\t\tartifactName = \"player-\" + parts[3] + \".js\"\n\t\tlinkName := filepath.Join(artifactsFolder, \"video-\"+videoID+\".js\")\n\t\tif err := os.Symlink(artifactName, linkName); err != nil {\n\t\t\tlog.Printf(\"unable to create symlink %s: %v\", linkName, err)\n\t\t}\n\t}\n\n\tconfig := c.playerCache.Get(playerPath)\n\tif config != nil {\n\t\treturn config, nil\n\t}\n\n\tconfig, err = c.httpGetBodyBytes(ctx, \"https://youtube.com\"+playerPath)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// for debugging\n\tif artifactName != \"\" {\n\t\twriteArtifact(artifactName, config)\n\t}\n\n\tc.playerCache.Set(playerPath, config)\n\treturn config, nil\n}\n"
        },
        {
          "name": "playlist.go",
          "type": "blob",
          "size": 6.62109375,
          "content": "package youtube\n\nimport (\n\t\"context\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"regexp\"\n\t\"runtime/debug\"\n\t\"strconv\"\n\t\"time\"\n\n\tsjson \"github.com/bitly/go-simplejson\"\n)\n\nvar (\n\tplaylistIDRegex    = regexp.MustCompile(\"^[A-Za-z0-9_-]{13,42}$\")\n\tplaylistInURLRegex = regexp.MustCompile(\"[&?]list=([A-Za-z0-9_-]{13,42})(&.*)?$\")\n)\n\ntype Playlist struct {\n\tID          string\n\tTitle       string\n\tDescription string\n\tAuthor      string\n\tVideos      []*PlaylistEntry\n}\n\ntype PlaylistEntry struct {\n\tID         string\n\tTitle      string\n\tAuthor     string\n\tDuration   time.Duration\n\tThumbnails Thumbnails\n}\n\nfunc extractPlaylistID(url string) (string, error) {\n\tif playlistIDRegex.Match([]byte(url)) {\n\t\treturn url, nil\n\t}\n\n\tmatches := playlistInURLRegex.FindStringSubmatch(url)\n\n\tif matches != nil {\n\t\treturn matches[1], nil\n\t}\n\n\treturn \"\", ErrInvalidPlaylist\n}\n\n// structs for playlist extraction\n\n// Title: metadata.playlistMetadataRenderer.title | sidebar.playlistSidebarRenderer.items[0].playlistSidebarPrimaryInfoRenderer.title.runs[0].text\n// Description: metadata.playlistMetadataRenderer.description\n// Author: sidebar.playlistSidebarRenderer.items[1].playlistSidebarSecondaryInfoRenderer.videoOwner.videoOwnerRenderer.title.runs[0].text\n\n// Videos: contents.twoColumnBrowseResultsRenderer.tabs[0].tabRenderer.content.sectionListRenderer.contents[0].itemSectionRenderer.contents[0].playlistVideoListRenderer.contents\n// ID: .videoId\n// Title: title.runs[0].text\n// Author: .shortBylineText.runs[0].text\n// Duration: .lengthSeconds\n// Thumbnails .thumbnails\n\n// TODO?: Author thumbnails: sidebar.playlistSidebarRenderer.items[0].playlistSidebarPrimaryInfoRenderer.thumbnailRenderer.playlistVideoThumbnailRenderer.thumbnail.thumbnails\nfunc (p *Playlist) parsePlaylistInfo(ctx context.Context, client *Client, body []byte) (err error) {\n\tvar j *sjson.Json\n\tj, err = sjson.NewJson(body)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tdefer func() {\n\t\tstack := debug.Stack()\n\t\tif r := recover(); r != nil {\n\t\t\terr = fmt.Errorf(\"JSON parsing error: %v\\n%s\", r, stack)\n\t\t}\n\t}()\n\n\trenderer := j.GetPath(\"alerts\").GetIndex(0).GetPath(\"alertRenderer\")\n\tif renderer != nil && renderer.GetPath(\"type\").MustString() == \"ERROR\" {\n\t\tmessage := renderer.GetPath(\"text\", \"runs\").GetIndex(0).GetPath(\"text\").MustString()\n\n\t\treturn ErrPlaylistStatus{Reason: message}\n\t}\n\n\t// Metadata can be located in multiple places depending on client type\n\tvar metadata *sjson.Json\n\tif node, ok := j.CheckGet(\"metadata\"); ok {\n\t\tmetadata = node\n\t} else if node, ok := j.CheckGet(\"header\"); ok {\n\t\tmetadata = node\n\t} else {\n\t\treturn fmt.Errorf(\"no playlist header / metadata found\")\n\t}\n\n\tmetadata = metadata.Get(\"playlistHeaderRenderer\")\n\n\tp.Title = sjsonGetText(metadata, \"title\")\n\tp.Description = sjsonGetText(metadata, \"description\", \"descriptionText\")\n\tp.Author = j.GetPath(\"sidebar\", \"playlistSidebarRenderer\", \"items\").GetIndex(1).\n\t\tGetPath(\"playlistSidebarSecondaryInfoRenderer\", \"videoOwner\", \"videoOwnerRenderer\", \"title\", \"runs\").\n\t\tGetIndex(0).Get(\"text\").MustString()\n\n\tif len(p.Author) == 0 {\n\t\tp.Author = sjsonGetText(metadata, \"owner\", \"ownerText\")\n\t}\n\n\tcontents, ok := j.CheckGet(\"contents\")\n\tif !ok {\n\t\treturn fmt.Errorf(\"contents not found in json body\")\n\t}\n\n\t// contents can have different keys with same child structure\n\tfirstPart := getFirstKeyJSON(contents).GetPath(\"tabs\").GetIndex(0).\n\t\tGetPath(\"tabRenderer\", \"content\", \"sectionListRenderer\", \"contents\").GetIndex(0)\n\n\t// This extra nested item is only set with the web client\n\tif n := firstPart.GetPath(\"itemSectionRenderer\", \"contents\").GetIndex(0); isValidJSON(n) {\n\t\tfirstPart = n\n\t}\n\n\tvJSON, err := firstPart.GetPath(\"playlistVideoListRenderer\", \"contents\").MarshalJSON()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif len(vJSON) <= 4 {\n\t\treturn fmt.Errorf(\"no video data found in JSON\")\n\t}\n\n\tentries, continuation, err := extractPlaylistEntries(vJSON)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif len(continuation) == 0 {\n\t\tcontinuation = getContinuation(firstPart.Get(\"playlistVideoListRenderer\"))\n\t}\n\n\tif len(entries) == 0 {\n\t\treturn fmt.Errorf(\"no videos found in playlist\")\n\t}\n\n\tp.Videos = entries\n\n\tfor continuation != \"\" {\n\t\tdata := prepareInnertubePlaylistData(continuation, true, *client.client)\n\n\t\tbody, err := client.httpPostBodyBytes(ctx, \"https://www.youtube.com/youtubei/v1/browse?key=\"+client.client.key, data)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tj, err := sjson.NewJson(body)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tnext := j.GetPath(\"onResponseReceivedActions\").GetIndex(0).\n\t\t\tGetPath(\"appendContinuationItemsAction\", \"continuationItems\")\n\n\t\tif !isValidJSON(next) {\n\t\t\tnext = j.GetPath(\"continuationContents\", \"playlistVideoListContinuation\", \"contents\")\n\t\t}\n\n\t\tvJSON, err := next.MarshalJSON()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tentries, token, err := extractPlaylistEntries(vJSON)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tif len(token) > 0 {\n\t\t\tcontinuation = token\n\t\t} else {\n\t\t\tcontinuation = getContinuation(j.GetPath(\"continuationContents\", \"playlistVideoListContinuation\"))\n\t\t}\n\n\t\tp.Videos = append(p.Videos, entries...)\n\t}\n\n\treturn err\n}\n\nfunc extractPlaylistEntries(data []byte) ([]*PlaylistEntry, string, error) {\n\tvar vids []*videosJSONExtractor\n\n\tif err := json.Unmarshal(data, &vids); err != nil {\n\t\treturn nil, \"\", err\n\t}\n\n\tentries := make([]*PlaylistEntry, 0, len(vids))\n\n\tvar continuation string\n\tfor _, v := range vids {\n\t\tif v.Renderer == nil {\n\t\t\tif v.Continuation.Endpoint.Command.Token != \"\" {\n\t\t\t\tcontinuation = v.Continuation.Endpoint.Command.Token\n\t\t\t}\n\n\t\t\tcontinue\n\t\t}\n\n\t\tentries = append(entries, v.PlaylistEntry())\n\t}\n\n\treturn entries, continuation, nil\n}\n\ntype videosJSONExtractor struct {\n\tRenderer *struct {\n\t\tID        string   `json:\"videoId\"`\n\t\tTitle     withRuns `json:\"title\"`\n\t\tAuthor    withRuns `json:\"shortBylineText\"`\n\t\tDuration  string   `json:\"lengthSeconds\"`\n\t\tThumbnail struct {\n\t\t\tThumbnails []Thumbnail `json:\"thumbnails\"`\n\t\t} `json:\"thumbnail\"`\n\t} `json:\"playlistVideoRenderer\"`\n\tContinuation struct {\n\t\tEndpoint struct {\n\t\t\tCommand struct {\n\t\t\t\tToken string `json:\"token\"`\n\t\t\t} `json:\"continuationCommand\"`\n\t\t} `json:\"continuationEndpoint\"`\n\t} `json:\"continuationItemRenderer\"`\n}\n\nfunc (vje videosJSONExtractor) PlaylistEntry() *PlaylistEntry {\n\tds, err := strconv.Atoi(vje.Renderer.Duration)\n\tif err != nil {\n\t\tpanic(\"invalid video duration: \" + vje.Renderer.Duration)\n\t}\n\treturn &PlaylistEntry{\n\t\tID:         vje.Renderer.ID,\n\t\tTitle:      vje.Renderer.Title.String(),\n\t\tAuthor:     vje.Renderer.Author.String(),\n\t\tDuration:   time.Second * time.Duration(ds),\n\t\tThumbnails: vje.Renderer.Thumbnail.Thumbnails,\n\t}\n}\n\ntype withRuns struct {\n\tRuns []struct {\n\t\tText string `json:\"text\"`\n\t} `json:\"runs\"`\n}\n\nfunc (wr withRuns) String() string {\n\tif len(wr.Runs) > 0 {\n\t\treturn wr.Runs[0].Text\n\t}\n\treturn \"\"\n}\n"
        },
        {
          "name": "playlist_test.go",
          "type": "blob",
          "size": 1.40625,
          "content": "package youtube\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestYoutube_extractPlaylistID(t *testing.T) {\n\ttests := []struct {\n\t\tname          string\n\t\turl           string\n\t\texpectedID    string\n\t\texpectedError error\n\t}{\n\t\t{\n\t\t\t\"pass-1\",\n\t\t\t\"https://www.youtube.com/watch?v=9UL390els7M&list=PLqAfPOrmacr963ATEroh67fbvjmTzTEx5\",\n\t\t\t\"PLqAfPOrmacr963ATEroh67fbvjmTzTEx5\",\n\t\t\tnil,\n\t\t},\n\n\t\t{\n\t\t\t\"pass-2\",\n\t\t\t\"PLqAfPOrmacr963ATEroh67fbvjmTzTEx5\",\n\t\t\t\"PLqAfPOrmacr963ATEroh67fbvjmTzTEx5\",\n\t\t\tnil,\n\t\t},\n\t\t{\n\t\t\t\"pass-3\",\n\t\t\t\"&list=PLqAfPOrmacr963ATEroh67fbvjmTzTEx5\",\n\t\t\t\"PLqAfPOrmacr963ATEroh67fbvjmTzTEx5\",\n\t\t\tnil,\n\t\t},\n\t\t{\n\t\t\t\"pass-4 (extra params)\",\n\t\t\t\"https://www.youtube.com/watch?v=9UL390els7M&list=PLqAfPOrmacr963ATEroh67fbvjmTzTEx5&foo=bar&baz=babar\",\n\t\t\t\"PLqAfPOrmacr963ATEroh67fbvjmTzTEx5\",\n\t\t\tnil,\n\t\t},\n\t\t{\n\t\t\t\"pass-5\",\n\t\t\t\"https://www.youtube.com/watch?v=-T4THwne8IE&list=RD-T4THwne8IE\",\n\t\t\t\"RD-T4THwne8IE\",\n\t\t\tnil,\n\t\t},\n\t\t{\n\t\t\t\"fail-1-playlist-id-44-char\",\n\t\t\t\"https://www.youtube.com/watch?v=9UL390els7M&list=PLqAfPOrmacr963ATEroh67fbvjmTzTEx5X1212404244\", \"\",\n\t\t\tErrInvalidPlaylist,\n\t\t},\n\t\t{\n\t\t\t\"fail-2\",\n\t\t\t\"\", \"\",\n\t\t\tErrInvalidPlaylist,\n\t\t},\n\t\t{\n\t\t\t\"fail-3\",\n\t\t\t\"awevqevqwev\", \"\",\n\t\t\tErrInvalidPlaylist,\n\t\t},\n\t}\n\n\tfor _, v := range tests {\n\t\tt.Run(v.name, func(t *testing.T) {\n\t\t\tid, err := extractPlaylistID(v.url)\n\n\t\t\tassert.Equal(t, v.expectedError, err)\n\t\t\tassert.Equal(t, v.expectedID, id)\n\t\t})\n\t}\n}\n"
        },
        {
          "name": "response_data.go",
          "type": "blob",
          "size": 5.14453125,
          "content": "package youtube\n\ntype playerResponseData struct {\n\tCaptions struct {\n\t\tPlayerCaptionsTracklistRenderer struct {\n\t\t\tCaptionTracks []CaptionTrack `json:\"captionTracks\"`\n\t\t\tAudioTracks   []struct {\n\t\t\t\tCaptionTrackIndices []int `json:\"captionTrackIndices\"`\n\t\t\t} `json:\"audioTracks\"`\n\t\t\tTranslationLanguages []struct {\n\t\t\t\tLanguageCode string `json:\"languageCode\"`\n\t\t\t\tLanguageName struct {\n\t\t\t\t\tSimpleText string `json:\"simpleText\"`\n\t\t\t\t} `json:\"languageName\"`\n\t\t\t} `json:\"translationLanguages\"`\n\t\t\tDefaultAudioTrackIndex int `json:\"defaultAudioTrackIndex\"`\n\t\t} `json:\"playerCaptionsTracklistRenderer\"`\n\t} `json:\"captions\"`\n\n\tPlayabilityStatus struct {\n\t\tStatus          string `json:\"status\"`\n\t\tReason          string `json:\"reason\"`\n\t\tPlayableInEmbed bool   `json:\"playableInEmbed\"`\n\t\tMiniplayer      struct {\n\t\t\tMiniplayerRenderer struct {\n\t\t\t\tPlaybackMode string `json:\"playbackMode\"`\n\t\t\t} `json:\"miniplayerRenderer\"`\n\t\t} `json:\"miniplayer\"`\n\t\tContextParams string `json:\"contextParams\"`\n\t} `json:\"playabilityStatus\"`\n\tStreamingData struct {\n\t\tExpiresInSeconds string   `json:\"expiresInSeconds\"`\n\t\tFormats          []Format `json:\"formats\"`\n\t\tAdaptiveFormats  []Format `json:\"adaptiveFormats\"`\n\t\tDashManifestURL  string   `json:\"dashManifestUrl\"`\n\t\tHlsManifestURL   string   `json:\"hlsManifestUrl\"`\n\t} `json:\"streamingData\"`\n\tVideoDetails struct {\n\t\tVideoID          string   `json:\"videoId\"`\n\t\tTitle            string   `json:\"title\"`\n\t\tLengthSeconds    string   `json:\"lengthSeconds\"`\n\t\tKeywords         []string `json:\"keywords\"`\n\t\tChannelID        string   `json:\"channelId\"`\n\t\tIsOwnerViewing   bool     `json:\"isOwnerViewing\"`\n\t\tShortDescription string   `json:\"shortDescription\"`\n\t\tIsCrawlable      bool     `json:\"isCrawlable\"`\n\t\tThumbnail        struct {\n\t\t\tThumbnails []Thumbnail `json:\"thumbnails\"`\n\t\t} `json:\"thumbnail\"`\n\t\tAverageRating     float64 `json:\"averageRating\"`\n\t\tAllowRatings      bool    `json:\"allowRatings\"`\n\t\tViewCount         string  `json:\"viewCount\"`\n\t\tAuthor            string  `json:\"author\"`\n\t\tIsPrivate         bool    `json:\"isPrivate\"`\n\t\tIsUnpluggedCorpus bool    `json:\"isUnpluggedCorpus\"`\n\t\tIsLiveContent     bool    `json:\"isLiveContent\"`\n\t} `json:\"videoDetails\"`\n\tMicroformat struct {\n\t\tPlayerMicroformatRenderer struct {\n\t\t\tThumbnail struct {\n\t\t\t\tThumbnails []struct {\n\t\t\t\t\tURL    string `json:\"url\"`\n\t\t\t\t\tWidth  int    `json:\"width\"`\n\t\t\t\t\tHeight int    `json:\"height\"`\n\t\t\t\t} `json:\"thumbnails\"`\n\t\t\t} `json:\"thumbnail\"`\n\t\t\tTitle struct {\n\t\t\t\tSimpleText string `json:\"simpleText\"`\n\t\t\t} `json:\"title\"`\n\t\t\tDescription struct {\n\t\t\t\tSimpleText string `json:\"simpleText\"`\n\t\t\t} `json:\"description\"`\n\t\t\tLengthSeconds      string   `json:\"lengthSeconds\"`\n\t\t\tOwnerProfileURL    string   `json:\"ownerProfileUrl\"`\n\t\t\tExternalChannelID  string   `json:\"externalChannelId\"`\n\t\t\tIsFamilySafe       bool     `json:\"isFamilySafe\"`\n\t\t\tAvailableCountries []string `json:\"availableCountries\"`\n\t\t\tIsUnlisted         bool     `json:\"isUnlisted\"`\n\t\t\tHasYpcMetadata     bool     `json:\"hasYpcMetadata\"`\n\t\t\tViewCount          string   `json:\"viewCount\"`\n\t\t\tCategory           string   `json:\"category\"`\n\t\t\tPublishDate        string   `json:\"publishDate\"`\n\t\t\tOwnerChannelName   string   `json:\"ownerChannelName\"`\n\t\t\tUploadDate         string   `json:\"uploadDate\"`\n\t\t} `json:\"playerMicroformatRenderer\"`\n\t} `json:\"microformat\"`\n}\n\ntype Format struct {\n\tItagNo           int    `json:\"itag\"`\n\tURL              string `json:\"url\"`\n\tMimeType         string `json:\"mimeType\"`\n\tQuality          string `json:\"quality\"`\n\tCipher           string `json:\"signatureCipher\"`\n\tBitrate          int    `json:\"bitrate\"`\n\tFPS              int    `json:\"fps\"`\n\tWidth            int    `json:\"width\"`\n\tHeight           int    `json:\"height\"`\n\tLastModified     string `json:\"lastModified\"`\n\tContentLength    int64  `json:\"contentLength,string\"`\n\tQualityLabel     string `json:\"qualityLabel\"`\n\tProjectionType   string `json:\"projectionType\"`\n\tAverageBitrate   int    `json:\"averageBitrate\"`\n\tAudioQuality     string `json:\"audioQuality\"`\n\tApproxDurationMs string `json:\"approxDurationMs\"`\n\tAudioSampleRate  string `json:\"audioSampleRate\"`\n\tAudioChannels    int    `json:\"audioChannels\"`\n\n\t// InitRange is only available for adaptive formats\n\tInitRange *struct {\n\t\tStart string `json:\"start\"`\n\t\tEnd   string `json:\"end\"`\n\t} `json:\"initRange\"`\n\n\t// IndexRange is only available for adaptive formats\n\tIndexRange *struct {\n\t\tStart string `json:\"start\"`\n\t\tEnd   string `json:\"end\"`\n\t} `json:\"indexRange\"`\n\n\t// AudioTrack is only available for videos with multiple audio track languages\n\tAudioTrack *struct {\n\t\tDisplayName    string `json:\"displayName\"`\n\t\tID             string `json:\"id\"`\n\t\tAudioIsDefault bool   `json:\"audioIsDefault\"`\n\t}\n}\n\nfunc (f *Format) LanguageDisplayName() string {\n\tif f.AudioTrack == nil {\n\t\treturn \"\"\n\t}\n\treturn f.AudioTrack.DisplayName\n}\n\ntype Thumbnails []Thumbnail\n\ntype Thumbnail struct {\n\tURL    string\n\tWidth  uint\n\tHeight uint\n}\n\ntype CaptionTrack struct {\n\tBaseURL string `json:\"baseUrl\"`\n\tName    struct {\n\t\tSimpleText string `json:\"simpleText\"`\n\t} `json:\"name\"`\n\tVssID          string `json:\"vssId\"`\n\tLanguageCode   string `json:\"languageCode\"`\n\tKind           string `json:\"kind,omitempty\"`\n\tIsTranslatable bool   `json:\"isTranslatable\"`\n}\n"
        },
        {
          "name": "transcript.go",
          "type": "blob",
          "size": 5.5712890625,
          "content": "package youtube\n\nimport (\n\t\"context\"\n\t\"encoding/json\"\n\t\"errors\"\n\t\"fmt\"\n\t\"strconv\"\n\t\"strings\"\n)\n\nvar (\n\tErrTranscriptDisabled = errors.New(\"transcript is disabled on this video\")\n)\n\n// TranscriptSegment is a single transcipt segment spanning a few milliseconds.\ntype TranscriptSegment struct {\n\t// Text is the transcipt text.\n\tText string `json:\"text\"`\n\n\t// StartMs is the start timestamp in ms.\n\tStartMs int `json:\"offset\"`\n\n\t// OffsetText e.g. '4:00'.\n\tOffsetText string `json:\"offsetText\"`\n\n\t// Duration the transcript segment spans in ms.\n\tDuration int `json:\"duration\"`\n}\n\nfunc (tr TranscriptSegment) String() string {\n\treturn tr.OffsetText + \" - \" + strings.TrimSpace(tr.Text)\n}\n\ntype VideoTranscript []TranscriptSegment\n\nfunc (vt VideoTranscript) String() string {\n\tvar str string\n\tfor _, tr := range vt {\n\t\tstr += tr.String() + \"\\n\"\n\t}\n\n\treturn str\n}\n\n// GetTranscript fetches the video transcript if available.\n//\n// Not all videos have transcripts, only relatively new videos.\n// If transcripts are disabled or not available, ErrTranscriptDisabled is returned.\nfunc (c *Client) GetTranscript(video *Video, lang string) (VideoTranscript, error) {\n\treturn c.GetTranscriptCtx(context.Background(), video, lang)\n}\n\n// GetTranscriptCtx fetches the video transcript if available.\n//\n// Not all videos have transcripts, only relatively new videos.\n// If transcripts are disabled or not available, ErrTranscriptDisabled is returned.\nfunc (c *Client) GetTranscriptCtx(ctx context.Context, video *Video, lang string) (VideoTranscript, error) {\n\tc.assureClient()\n\n\tif video == nil || video.ID == \"\" {\n\t\treturn nil, fmt.Errorf(\"no video provided\")\n\t}\n\n\tbody, err := c.transcriptDataByInnertube(ctx, video.ID, lang)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\ttranscript, err := parseTranscript(body)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn transcript, nil\n}\n\nfunc parseTranscript(body []byte) (VideoTranscript, error) {\n\tvar resp transcriptResp\n\tif err := json.Unmarshal(body, &resp); err != nil {\n\t\treturn nil, err\n\t}\n\n\tif len(resp.Actions) > 0 {\n\t\t// Android client response\n\t\tif app := resp.Actions[0].AppSegment; app != nil {\n\t\t\treturn getSegments(app)\n\t\t}\n\n\t\t// Web client response\n\t\tif web := resp.Actions[0].WebSegment; web != nil {\n\t\t\treturn nil, fmt.Errorf(\"not implemented\")\n\t\t}\n\t}\n\n\treturn nil, ErrTranscriptDisabled\n}\n\ntype segmenter interface {\n\tParseSegments() []TranscriptSegment\n}\n\nfunc getSegments(f segmenter) (VideoTranscript, error) {\n\tif segments := f.ParseSegments(); len(segments) > 0 {\n\t\treturn segments, nil\n\t}\n\n\treturn nil, ErrTranscriptDisabled\n}\n\n// transcriptResp is the JSON structure as returned by the transcript API.\ntype transcriptResp struct {\n\tActions []struct {\n\t\tAppSegment *appData `json:\"elementsCommand\"`\n\t\tWebSegment *webData `json:\"updateEngagementPanelAction\"`\n\t} `json:\"actions\"`\n}\n\ntype appData struct {\n\tTEC struct {\n\t\tArgs struct {\n\t\t\tListArgs struct {\n\t\t\t\tOw struct {\n\t\t\t\t\tInitialSeg []struct {\n\t\t\t\t\t\tTranscriptSegment struct {\n\t\t\t\t\t\t\tStartMs string `json:\"startMs\"`\n\t\t\t\t\t\t\tEndMs   string `json:\"endMs\"`\n\t\t\t\t\t\t\tText    struct {\n\t\t\t\t\t\t\t\tString struct {\n\t\t\t\t\t\t\t\t\t// Content is the actual transctipt text\n\t\t\t\t\t\t\t\t\tContent string `json:\"content\"`\n\t\t\t\t\t\t\t\t} `json:\"elementsAttributedString\"`\n\t\t\t\t\t\t\t} `json:\"snippet\"`\n\t\t\t\t\t\t\tStartTimeText struct {\n\t\t\t\t\t\t\t\tString struct {\n\t\t\t\t\t\t\t\t\t// Content is the fomratted timestamp, e.g. '4:00'\n\t\t\t\t\t\t\t\t\tContent string `json:\"content\"`\n\t\t\t\t\t\t\t\t} `json:\"elementsAttributedString\"`\n\t\t\t\t\t\t\t} `json:\"startTimeText\"`\n\t\t\t\t\t\t} `json:\"transcriptSegmentRenderer\"`\n\t\t\t\t\t} `json:\"initialSegments\"`\n\t\t\t\t} `json:\"overwrite\"`\n\t\t\t} `json:\"transformTranscriptSegmentListArguments\"`\n\t\t} `json:\"arguments\"`\n\t} `json:\"transformEntityCommand\"`\n}\n\nfunc (s *appData) ParseSegments() []TranscriptSegment {\n\trawSegments := s.TEC.Args.ListArgs.Ow.InitialSeg\n\tsegments := make([]TranscriptSegment, 0, len(rawSegments))\n\n\tfor _, segment := range rawSegments {\n\t\tstartMs, _ := strconv.Atoi(segment.TranscriptSegment.StartMs)\n\t\tendMs, _ := strconv.Atoi(segment.TranscriptSegment.EndMs)\n\n\t\tsegments = append(segments, TranscriptSegment{\n\t\t\tText:       segment.TranscriptSegment.Text.String.Content,\n\t\t\tStartMs:    startMs,\n\t\t\tOffsetText: segment.TranscriptSegment.StartTimeText.String.Content,\n\t\t\tDuration:   endMs - startMs,\n\t\t})\n\t}\n\n\treturn segments\n}\n\ntype webData struct {\n\tContent struct {\n\t\tTR struct {\n\t\t\tBody struct {\n\t\t\t\tTBR struct {\n\t\t\t\t\tCues []struct {\n\t\t\t\t\t\tTranscript struct {\n\t\t\t\t\t\t\tFormattedStartOffset struct {\n\t\t\t\t\t\t\t\tSimpleText string `json:\"simpleText\"`\n\t\t\t\t\t\t\t} `json:\"formattedStartOffset\"`\n\t\t\t\t\t\t\tCues []struct {\n\t\t\t\t\t\t\t\tTranscriptCueRenderer struct {\n\t\t\t\t\t\t\t\t\tCue struct {\n\t\t\t\t\t\t\t\t\t\tSimpleText string `json:\"simpleText\"`\n\t\t\t\t\t\t\t\t\t} `json:\"cue\"`\n\t\t\t\t\t\t\t\t\tStartOffsetMs string `json:\"startOffsetMs\"`\n\t\t\t\t\t\t\t\t\tDurationMs    string `json:\"durationMs\"`\n\t\t\t\t\t\t\t\t} `json:\"transcriptCueRenderer\"`\n\t\t\t\t\t\t\t} `json:\"cues\"`\n\t\t\t\t\t\t} `json:\"transcriptCueGroupRenderer\"`\n\t\t\t\t\t} `json:\"cueGroups\"`\n\t\t\t\t} `json:\"transcriptSearchPanelRenderer\"`\n\t\t\t} `json:\"content\"`\n\t\t} `json:\"transcriptRenderer\"`\n\t} `json:\"content\"`\n}\n\nfunc (s *webData) ParseSegments() []TranscriptSegment {\n\t// TODO: doesn't actually work now, check json.\n\tcues := s.Content.TR.Body.TBR.Cues\n\tsegments := make([]TranscriptSegment, 0, len(cues))\n\n\tfor _, s := range cues {\n\t\tformatted := s.Transcript.FormattedStartOffset.SimpleText\n\t\tsegment := s.Transcript.Cues[0].TranscriptCueRenderer\n\t\tstart, _ := strconv.Atoi(segment.StartOffsetMs)\n\t\tduration, _ := strconv.Atoi(segment.DurationMs)\n\n\t\tsegments = append(segments, TranscriptSegment{\n\t\t\tText:       segment.Cue.SimpleText,\n\t\t\tStartMs:    start,\n\t\t\tOffsetText: formatted,\n\t\t\tDuration:   duration,\n\t\t})\n\t}\n\n\treturn segments\n}\n"
        },
        {
          "name": "transcript_test.go",
          "type": "blob",
          "size": 1.2607421875,
          "content": "package youtube\n\nimport (\n\t\"strconv\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/require\"\n)\n\nfunc TestTranscript(t *testing.T) {\n\tvideo := &Video{ID: \"9_MbW9FK1fA\"}\n\n\ttranscript, err := testClient.GetTranscript(video, \"en\")\n\trequire.NoError(t, err, \"get transcript\")\n\trequire.Greater(t, len(transcript), 0, \"no transcript segments found\")\n\n\tfor i, segment := range transcript {\n\t\tindex := strconv.Itoa(i)\n\n\t\trequire.NotEmpty(t, segment.Text, \"text \"+index)\n\t\trequire.NotEmpty(t, segment.Duration, \"duration \"+index)\n\t\trequire.NotEmpty(t, segment.OffsetText, \"offset \"+index)\n\n\t\tif i != 0 {\n\t\t\trequire.NotEmpty(t, segment.StartMs, \"startMs \"+index)\n\t\t}\n\t}\n\n\tt.Log(transcript.String())\n}\n\nfunc TestTranscriptOtherLanguage(t *testing.T) {\n\tvideo := &Video{ID: \"AXwDvYh2-uk\"}\n\n\ttranscript, err := testClient.GetTranscript(video, \"id\")\n\trequire.NoError(t, err, \"get transcript\")\n\trequire.Greater(t, len(transcript), 0, \"no transcript segments found\")\n\n\tfor i, segment := range transcript {\n\t\tindex := strconv.Itoa(i)\n\n\t\trequire.NotEmpty(t, segment.Text, \"text \"+index)\n\t\trequire.NotEmpty(t, segment.Duration, \"duration \"+index)\n\t\trequire.NotEmpty(t, segment.OffsetText, \"offset \"+index)\n\n\t\tif i != 0 {\n\t\t\trequire.NotEmpty(t, segment.StartMs, \"startMs \"+index)\n\t\t}\n\t}\n\n\tt.Log(transcript.String())\n}\n"
        },
        {
          "name": "utils.go",
          "type": "blob",
          "size": 1.6259765625,
          "content": "package youtube\n\nimport (\n\t\"encoding/base64\"\n\n\tsjson \"github.com/bitly/go-simplejson\"\n)\n\ntype chunk struct {\n\tstart int64\n\tend   int64\n\tdata  chan []byte\n}\n\nfunc getChunks(totalSize, chunkSize int64) []chunk {\n\tvar chunks []chunk\n\n\tfor start := int64(0); start < totalSize; start += chunkSize {\n\t\tend := chunkSize + start - 1\n\t\tif end > totalSize-1 {\n\t\t\tend = totalSize - 1\n\t\t}\n\n\t\tchunks = append(chunks, chunk{start, end, make(chan []byte, 1)})\n\t}\n\n\treturn chunks\n}\n\nfunc getFirstKeyJSON(j *sjson.Json) *sjson.Json {\n\tm, err := j.Map()\n\tif err != nil {\n\t\treturn j\n\t}\n\n\tfor key := range m {\n\t\treturn j.Get(key)\n\t}\n\n\treturn j\n}\n\nfunc isValidJSON(j *sjson.Json) bool {\n\tb, err := j.MarshalJSON()\n\tif err != nil {\n\t\treturn false\n\t}\n\n\tif len(b) <= 4 {\n\t\treturn false\n\t}\n\n\treturn true\n}\n\nfunc sjsonGetText(j *sjson.Json, paths ...string) string {\n\tfor _, path := range paths {\n\t\tif isValidJSON(j.Get(path)) {\n\t\t\tj = j.Get(path)\n\t\t}\n\t}\n\n\tif text, err := j.String(); err == nil {\n\t\treturn text\n\t}\n\n\tif isValidJSON(j.Get(\"text\")) {\n\t\treturn j.Get(\"text\").MustString()\n\t}\n\n\tif p := j.Get(\"runs\"); isValidJSON(p) {\n\t\tvar text string\n\n\t\tfor i := 0; i < len(p.MustArray()); i++ {\n\t\t\tif textNode := p.GetIndex(i).Get(\"text\"); isValidJSON(textNode) {\n\t\t\t\ttext += textNode.MustString()\n\t\t\t}\n\t\t}\n\n\t\treturn text\n\t}\n\n\treturn \"\"\n}\n\nfunc getContinuation(j *sjson.Json) string {\n\treturn j.GetPath(\"continuations\").\n\t\tGetIndex(0).GetPath(\"nextContinuationData\", \"continuation\").MustString()\n}\n\nfunc base64PadEnc(str string) string {\n\treturn base64.StdEncoding.EncodeToString([]byte(str))\n}\n\nfunc base64Enc(str string) string {\n\treturn base64.RawStdEncoding.EncodeToString([]byte(str))\n}\n"
        },
        {
          "name": "utils_test.go",
          "type": "blob",
          "size": 0.6015625,
          "content": "package youtube\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/require\"\n)\n\nfunc TestGetChunks1(t *testing.T) {\n\trequire := require.New(t)\n\tchunks := getChunks(13, 5)\n\n\trequire.Len(chunks, 3)\n\trequire.EqualValues(0, chunks[0].start)\n\trequire.EqualValues(4, chunks[0].end)\n\trequire.EqualValues(5, chunks[1].start)\n\trequire.EqualValues(9, chunks[1].end)\n\trequire.EqualValues(10, chunks[2].start)\n\trequire.EqualValues(12, chunks[2].end)\n}\n\nfunc TestGetChunks_length(t *testing.T) {\n\trequire := require.New(t)\n\trequire.Len(getChunks(10, 9), 2)\n\trequire.Len(getChunks(10, 10), 1)\n\trequire.Len(getChunks(10, 11), 1)\n}\n"
        },
        {
          "name": "video.go",
          "type": "blob",
          "size": 4.1689453125,
          "content": "package youtube\n\nimport (\n\t\"encoding/json\"\n\t\"errors\"\n\t\"fmt\"\n\t\"net/url\"\n\t\"regexp\"\n\t\"sort\"\n\t\"strconv\"\n\t\"strings\"\n\t\"time\"\n)\n\ntype Video struct {\n\tID              string\n\tTitle           string\n\tDescription     string\n\tAuthor          string\n\tChannelID       string\n\tChannelHandle   string\n\tViews           int\n\tDuration        time.Duration\n\tPublishDate     time.Time\n\tFormats         FormatList\n\tThumbnails      Thumbnails\n\tDASHManifestURL string // URI of the DASH manifest file\n\tHLSManifestURL  string // URI of the HLS manifest file\n\tCaptionTracks   []CaptionTrack\n}\n\nconst dateFormat = \"2006-01-02\"\n\nfunc (v *Video) parseVideoInfo(body []byte) error {\n\tvar prData playerResponseData\n\tif err := json.Unmarshal(body, &prData); err != nil {\n\t\treturn fmt.Errorf(\"unable to parse player response JSON: %w\", err)\n\t}\n\n\tif err := v.isVideoFromInfoDownloadable(prData); err != nil {\n\t\treturn err\n\t}\n\n\treturn v.extractDataFromPlayerResponse(prData)\n}\n\nfunc (v *Video) isVideoFromInfoDownloadable(prData playerResponseData) error {\n\treturn v.isVideoDownloadable(prData, false)\n}\n\nvar playerResponsePattern = regexp.MustCompile(`var ytInitialPlayerResponse\\s*=\\s*(\\{.+?\\});`)\n\nfunc (v *Video) parseVideoPage(body []byte) error {\n\tinitialPlayerResponse := playerResponsePattern.FindSubmatch(body)\n\tif initialPlayerResponse == nil || len(initialPlayerResponse) < 2 {\n\t\treturn errors.New(\"no ytInitialPlayerResponse found in the server's answer\")\n\t}\n\n\tvar prData playerResponseData\n\tif err := json.Unmarshal(initialPlayerResponse[1], &prData); err != nil {\n\t\treturn fmt.Errorf(\"unable to parse player response JSON: %w\", err)\n\t}\n\n\tif err := v.isVideoFromPageDownloadable(prData); err != nil {\n\t\treturn err\n\t}\n\n\treturn v.extractDataFromPlayerResponse(prData)\n}\n\nfunc (v *Video) isVideoFromPageDownloadable(prData playerResponseData) error {\n\treturn v.isVideoDownloadable(prData, true)\n}\n\nfunc (v *Video) isVideoDownloadable(prData playerResponseData, isVideoPage bool) error {\n\t// Check if video is downloadable\n\tswitch prData.PlayabilityStatus.Status {\n\tcase \"OK\":\n\t\treturn nil\n\tcase \"LOGIN_REQUIRED\":\n\t\t// for some reason they use same status message for age-restricted and private videos\n\t\tif strings.HasPrefix(prData.PlayabilityStatus.Reason, \"This video is private\") {\n\t\t\treturn ErrVideoPrivate\n\t\t}\n\t\treturn ErrLoginRequired\n\t}\n\n\tif !isVideoPage && !prData.PlayabilityStatus.PlayableInEmbed {\n\t\treturn ErrNotPlayableInEmbed\n\t}\n\n\treturn &ErrPlayabiltyStatus{\n\t\tStatus: prData.PlayabilityStatus.Status,\n\t\tReason: prData.PlayabilityStatus.Reason,\n\t}\n}\n\nfunc (v *Video) extractDataFromPlayerResponse(prData playerResponseData) error {\n\tv.Title = prData.VideoDetails.Title\n\tv.Description = prData.VideoDetails.ShortDescription\n\tv.Author = prData.VideoDetails.Author\n\tv.Thumbnails = prData.VideoDetails.Thumbnail.Thumbnails\n\tv.ChannelID = prData.VideoDetails.ChannelID\n\tv.CaptionTracks = prData.Captions.PlayerCaptionsTracklistRenderer.CaptionTracks\n\n\tif views, _ := strconv.Atoi(prData.VideoDetails.ViewCount); views > 0 {\n\t\tv.Views = views\n\t}\n\n\tif seconds, _ := strconv.Atoi(prData.VideoDetails.LengthSeconds); seconds > 0 {\n\t\tv.Duration = time.Duration(seconds) * time.Second\n\t}\n\n\tif seconds, _ := strconv.Atoi(prData.Microformat.PlayerMicroformatRenderer.LengthSeconds); seconds > 0 {\n\t\tv.Duration = time.Duration(seconds) * time.Second\n\t}\n\n\tif str := prData.Microformat.PlayerMicroformatRenderer.PublishDate; str != \"\" {\n\t\tv.PublishDate, _ = time.Parse(dateFormat, str)\n\t}\n\n\tif profileURL, err := url.Parse(prData.Microformat.PlayerMicroformatRenderer.OwnerProfileURL); err == nil && len(profileURL.Path) > 1 {\n\t\tv.ChannelHandle = profileURL.Path[1:]\n\t}\n\n\t// Assign Streams\n\tv.Formats = append(prData.StreamingData.Formats, prData.StreamingData.AdaptiveFormats...)\n\tif len(v.Formats) == 0 {\n\t\treturn errors.New(\"no formats found in the server's answer\")\n\t}\n\n\t// Sort formats by bitrate\n\tsort.SliceStable(v.Formats, v.SortBitrateDesc)\n\n\tv.HLSManifestURL = prData.StreamingData.HlsManifestURL\n\tv.DASHManifestURL = prData.StreamingData.DashManifestURL\n\n\treturn nil\n}\n\nfunc (v *Video) SortBitrateDesc(i int, j int) bool {\n\treturn v.Formats[i].Bitrate > v.Formats[j].Bitrate\n}\n\nfunc (v *Video) SortBitrateAsc(i int, j int) bool {\n\treturn v.Formats[i].Bitrate < v.Formats[j].Bitrate\n}\n"
        },
        {
          "name": "video_id.go",
          "type": "blob",
          "size": 0.7802734375,
          "content": "package youtube\n\nimport (\n\t\"regexp\"\n\t\"strings\"\n)\n\nvar videoRegexpList = []*regexp.Regexp{\n\tregexp.MustCompile(`(?:v|embed|shorts|watch\\?v)(?:=|/)([^\"&?/=%]{11})`),\n\tregexp.MustCompile(`(?:=|/)([^\"&?/=%]{11})`),\n\tregexp.MustCompile(`([^\"&?/=%]{11})`),\n}\n\n// ExtractVideoID extracts the videoID from the given string\nfunc ExtractVideoID(videoID string) (string, error) {\n\tif strings.Contains(videoID, \"youtu\") || strings.ContainsAny(videoID, \"\\\"?&/<%=\") {\n\t\tfor _, re := range videoRegexpList {\n\t\t\tif isMatch := re.MatchString(videoID); isMatch {\n\t\t\t\tsubs := re.FindStringSubmatch(videoID)\n\t\t\t\tvideoID = subs[1]\n\t\t\t}\n\t\t}\n\t}\n\n\tif strings.ContainsAny(videoID, \"?&/<%=\") {\n\t\treturn \"\", ErrInvalidCharactersInVideoID\n\t}\n\n\tif len(videoID) < 10 {\n\t\treturn \"\", ErrVideoIDMinLength\n\t}\n\n\treturn videoID, nil\n}\n"
        },
        {
          "name": "video_test.go",
          "type": "blob",
          "size": 3.8203125,
          "content": "package youtube\n\nimport (\n\t\"io\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/stretchr/testify/require\"\n)\n\nfunc ExampleClient_GetStream() {\n\tvideo, err := testClient.GetVideo(\"https://www.youtube.com/watch?v=9_MbW9FK1fA\")\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\t// Typically youtube only provides separate streams for video and audio.\n\t// If you want audio and video combined, take a look a the downloader package.\n\tformats := video.Formats.Quality(\"medium\")\n\treader, _, err := testClient.GetStream(video, &formats[0])\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\t// do something with the reader\n\n\treader.Close()\n}\n\nfunc TestSimpleTest(t *testing.T) {\n\tvideo, err := testClient.GetVideo(\"https://www.youtube.com/watch?v=9_MbW9FK1fA\")\n\trequire.NoError(t, err, \"get body\")\n\n\t_, err = testClient.GetTranscript(video, \"en\")\n\trequire.NoError(t, err, \"get transcript\")\n\n\t// Typically youtube only provides separate streams for video and audio.\n\t// If you want audio and video combined, take a look a the downloader package.\n\tformats := video.Formats.Quality(\"hd1080\")\n\trequire.NotEmpty(t, formats)\n\n\tstart := time.Now()\n\treader, _, err := testClient.GetStream(video, &formats[0])\n\trequire.NoError(t, err, \"get stream\")\n\n\tt.Log(\"Duration Milliseconds: \", time.Since(start).Milliseconds())\n\n\t// do something with the reader\n\tb, err := io.ReadAll(reader)\n\trequire.NoError(t, err, \"read body\")\n\n\tt.Log(\"Downloaded \", len(b))\n}\n\nfunc TestDownload_Regular(t *testing.T) {\n\ttestcases := []struct {\n\t\tname       string\n\t\turl        string\n\t\toutputFile string\n\t\titagNo     int\n\t\tquality    string\n\t}{\n\t\t{\n\t\t\t// Video from issue #25\n\t\t\tname:       \"default\",\n\t\t\turl:        \"https://www.youtube.com/watch?v=54e6lBE3BoQ\",\n\t\t\toutputFile: \"default_test.mp4\",\n\t\t\tquality:    \"\",\n\t\t},\n\t\t{\n\t\t\t// Video from issue #25\n\t\t\tname:       \"quality:medium\",\n\t\t\turl:        \"https://www.youtube.com/watch?v=54e6lBE3BoQ\",\n\t\t\toutputFile: \"medium_test.mp4\",\n\t\t\tquality:    \"medium\",\n\t\t},\n\t\t{\n\t\t\tname: \"without-filename\",\n\t\t\turl:  \"https://www.youtube.com/watch?v=n3kPvBCYT3E\",\n\t\t},\n\t\t{\n\t\t\tname:       \"Format\",\n\t\t\turl:        \"https://www.youtube.com/watch?v=54e6lBE3BoQ\",\n\t\t\toutputFile: \"muxedstream_test.mp4\",\n\t\t\titagNo:     18,\n\t\t},\n\t\t{\n\t\t\tname:       \"AdaptiveFormat_video\",\n\t\t\turl:        \"https://www.youtube.com/watch?v=54e6lBE3BoQ\",\n\t\t\toutputFile: \"adaptiveStream_video_test.m4v\",\n\t\t\titagNo:     134,\n\t\t},\n\t\t{\n\t\t\tname:       \"AdaptiveFormat_audio\",\n\t\t\turl:        \"https://www.youtube.com/watch?v=54e6lBE3BoQ\",\n\t\t\toutputFile: \"adaptiveStream_audio_test.m4a\",\n\t\t\titagNo:     140,\n\t\t},\n\t\t{\n\t\t\t// Video from issue #138\n\t\t\tname:       \"NotPlayableInEmbed\",\n\t\t\turl:        \"https://www.youtube.com/watch?v=gr-IqFcNExY\",\n\t\t\toutputFile: \"not_playable_in_embed.mp4\",\n\t\t},\n\t}\n\tfor _, tc := range testcases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\trequire := require.New(t)\n\n\t\t\tvideo, err := testClient.GetVideo(tc.url)\n\t\t\trequire.NoError(err)\n\n\t\t\tformats := video.Formats\n\t\t\tif tc.itagNo > 0 {\n\t\t\t\tformats = formats.Itag(tc.itagNo)\n\t\t\t\trequire.NotEmpty(formats)\n\t\t\t}\n\n\t\t\turl, err := testClient.GetStreamURL(video, &video.Formats[0])\n\t\t\trequire.NoError(err)\n\t\t\trequire.NotEmpty(url)\n\t\t})\n\t}\n}\n\nfunc TestDownload_WhenPlayabilityStatusIsNotOK(t *testing.T) {\n\ttestcases := []struct {\n\t\tissue   string\n\t\tvideoID string\n\t\terr     string\n\t}{\n\t\t{\n\t\t\tissue:   \"issue#65\",\n\t\t\tvideoID: \"9ja-K2FslBU\",\n\t\t\terr:     `status: ERROR`,\n\t\t},\n\t\t{\n\t\t\tissue:   \"issue#59\",\n\t\t\tvideoID: \"yZIXLfi8CZQ\",\n\t\t\terr:     ErrVideoPrivate.Error(),\n\t\t},\n\t}\n\n\tfor _, tc := range testcases {\n\t\tt.Run(tc.issue, func(t *testing.T) {\n\t\t\t_, err := testClient.GetVideo(tc.videoID)\n\t\t\trequire.Error(t, err)\n\t\t\trequire.Contains(t, err.Error(), tc.err)\n\t\t})\n\t}\n}\n\n// See https://github.com/kkdai/youtube/pull/238\nfunc TestDownload_SensitiveContent(t *testing.T) {\n\t_, err := testClient.GetVideo(\"MS91knuzoOA\")\n\trequire.EqualError(t, err, \"can't bypass age restriction: embedding of this video has been disabled\")\n}\n"
        }
      ]
    }
  ]
}