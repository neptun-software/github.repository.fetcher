{
  "metadata": {
    "timestamp": 1736567222745,
    "page": 818,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjgyMA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "GeertJohan/go.rice",
      "stars": 2423,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.0859375,
          "content": "/example/example\n/example/example.exe\n/rice/rice\n/rice/rice.exe\n\n*.rice-box.go\n.wercker\n"
        },
        {
          "name": ".travis.yml",
          "type": "blob",
          "size": 0.1962890625,
          "content": "language: go\n\ngo:\n    - master\n    - 1.11.x\n    - 1.10.x\n    - 1.9.x\n    - 1.8.x\n\ninstall:\n    - go get -t ./...\n    - env\nscript:\n    - go build -x ./...\n    - go test -cover ./...\n    - go vet ./...\n"
        },
        {
          "name": "AUTHORS",
          "type": "blob",
          "size": 0.12890625,
          "content": "Geert-Johan Riemer <geertjohan@geertjohan.net>\nPaul Maddox <paul.maddox@gmail.com>\nVincent Petithory <vincent.petithory@gmail.com>\n\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.2724609375,
          "content": "Copyright (c) 2013, Geert-Johan Riemer\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are met:\n\n1. Redistributions of source code must retain the above copyright notice, this\n   list of conditions and the following disclaimer.\n2. Redistributions in binary form must reproduce the above copyright notice,\n   this list of conditions and the following disclaimer in the documentation\n   and/or other materials provided with the distribution.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\nANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\nWARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR\nANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\nLOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\nON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\nSOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE."
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 5.90625,
          "content": "# go.rice\n\n[![Build Status](https://travis-ci.org/GeertJohan/go.rice.png)](https://travis-ci.org/GeertJohan/go.rice)\n[![Godoc](https://img.shields.io/badge/godoc-go.rice-blue.svg?style=flat-square)](https://godoc.org/github.com/GeertJohan/go.rice)\n\ngo.rice is a [Go](http://golang.org) package that makes working with resources such as html,js,css,images and templates easy. During development `go.rice` will load required files directly from disk. Upon deployment it's easy to add all resource files to a executable using the `rice` tool, without changing the source code for your package. go.rice provides methods to add resources to a binary in different scenarios.\n\n## What does it do\n\nThe first thing go.rice does is finding the correct absolute path for your resource files. Say you are executing a binary in your home directory, but your `html-files` are in `$GOPATH/src/yourApplication/html-files`. `go.rice` will lookup the correct path for that directory (relative to the location of yourApplication). All you have to do is include the resources using `rice.FindBox(\"html-files\")`.\n\nThis works fine when the source is available to the machine executing the binary, which is the case when installing the executable with `go get` or `go install`. But it does not work when you wish to provide a single binary without source. This is where the `rice` tool comes in. It analyses source code and finds call's to `rice.FindBox(..)`. Then it adds the required directories to the executable binary, There are two strategies to do this. You can 'embed' the assets by generating go source code and then compile them into the executable binary, or you can 'append' the assets to the executable binary after compiling. In both cases the `rice.FindBox(..)` call detects the embedded or appended resources and load those, instead of looking up files from disk.\n\n## Installation\n\nUse `go install` to install the package the `rice` tool.\n\n```bash\ngo install github.com/GeertJohan/go.rice@latest\ngo install github.com/GeertJohan/go.rice/rice@latest\n```\n\n## Package usage\n\nImport the package: `import \"github.com/GeertJohan/go.rice\"`\n\nServing a static content folder over HTTP with a rice Box:\n\n```go\nhttp.Handle(\"/\", http.FileServer(rice.MustFindBox(\"http-files\").HTTPBox()))\nhttp.ListenAndServe(\":8080\", nil)\n```\n\nServe a static content folder over HTTP at a non-root location:\n\n```go\nbox := rice.MustFindBox(\"cssfiles\")\ncssFileServer := http.StripPrefix(\"/css/\", http.FileServer(box.HTTPBox()))\nhttp.Handle(\"/css/\", cssFileServer)\nhttp.ListenAndServe(\":8080\", nil)\n```\n\nNote the *trailing slash* in `/css/` in both the call to\n`http.StripPrefix` and `http.Handle`.\n\nLoading a template:\n\n```go\n// find a rice.Box\ntemplateBox, err := rice.FindBox(\"example-templates\")\nif err != nil {\n\tlog.Fatal(err)\n}\n// get file contents as string\ntemplateString, err := templateBox.String(\"message.tmpl\")\nif err != nil {\n\tlog.Fatal(err)\n}\n// parse and execute the template\ntmplMessage, err := template.New(\"message\").Parse(templateString)\nif err != nil {\n\tlog.Fatal(err)\n}\ntmplMessage.Execute(os.Stdout, map[string]string{\"Message\": \"Hello, world!\"})\n\n```\n\nNever call `FindBox()` or `MustFindBox()` from an `init()` function, as there is no guarantee the boxes are loaded at that time.\n\n### Calling FindBox and MustFindBox\n\nAlways call `FindBox()` or `MustFindBox()` with string literals e.g. `FindBox(\"example\")`. Do not use string constants or variables. This will prevent the rice tool to fail with error `Error: found call to rice.FindBox, but argument must be a string literal.`.\n\n## Tool usage\n\nThe `rice` tool lets you add the resources to a binary executable so the files are not loaded from the filesystem anymore. This creates a 'standalone' executable. There are multiple strategies to add the resources and assets to a binary, each has pro's and con's but all will work without requiring changes to the way you load the resources.\n\n### `rice embed-go`: Embed resources by generating Go source code\n\nExecute this method before building. It generates a single Go source file called *rice-box.go* for each package. The generated go file contains all assets. The Go tool compiles this into the binary.\n\nThe downside with this option is that the generated go source file can become large, which may slow down compilation and requires more memory to compile.\n\nExecute the following commands:\n\n```bash\nrice embed-go\ngo build\n```\n\n*A Note on Symbolic Links*: `embed-go` uses the `os.Walk` function from the standard library.  The `os.Walk` function does **not** follow symbolic links. When creating a box, be aware that any symbolic links inside your box's directory are not followed. When the box itself is a symbolic link, the rice tool resolves its actual location before adding the contents.\n\n### `rice append`: Append resources to executable as zip file\n\nThis method changes an already built executable. It appends the resources as zip file to the binary. It makes compilation a lot faster. Using the append method works great for adding large assets to an executable binary.\n\nA downside for appending is that it does not provide a working Seek method.\n\nRun the following commands to create a standalone executable.\n\n```bash\ngo build -o example\nrice append --exec example\n```\n\n## Help information\n\nRun `rice --help` for information about all flags and subcommands.\n\nYou can use the `--help` flag on each sub-command. For example: `rice append --help`.\n\n## Order of precedence\n\nWhen opening a new box, the `rice.FindBox(..)` tries to locate the resources in the following order:\n\n- embedded (generated as `rice-box.go`)\n- appended (appended to the binary executable after compiling)\n- 'live' from filesystem\n\n## License\n\nThis project is licensed under a Simplified BSD license. Please read the [LICENSE file][license].\n\n## Package documentation\n\nYou will find package documentation at [godoc.org/github.com/GeertJohan/go.rice][godoc].\n\n[license]: https://github.com/GeertJohan/go.rice/blob/master/LICENSE\n[godoc]: http://godoc.org/github.com/GeertJohan/go.rice\n"
        },
        {
          "name": "appended.go",
          "type": "blob",
          "size": 3.515625,
          "content": "package rice\n\nimport (\n\t\"archive/zip\"\n\t\"log\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"strings\"\n\t\"time\"\n\n\t\"github.com/daaku/go.zipexe\"\n)\n\n// appendedBox defines an appended box\ntype appendedBox struct {\n\tName  string                   // box name\n\tFiles map[string]*appendedFile // appended files (*zip.File) by full path\n\tTime  time.Time\n}\n\ntype appendedFile struct {\n\tzipFile  *zip.File\n\tdir      bool\n\tdirInfo  *appendedDirInfo\n\tchildren []*appendedFile\n\tcontent  []byte\n}\n\n// appendedBoxes is a public register of appendes boxes\nvar appendedBoxes = make(map[string]*appendedBox)\n\nfunc init() {\n\t// find if exec is appended\n\tthisFile, err := os.Executable()\n\tif err != nil {\n\t\treturn // not appended or cant find self executable\n\t}\n\tthisFile, err = filepath.EvalSymlinks(thisFile)\n\tif err != nil {\n\t\treturn\n\t}\n\tcloser, rd, err := zipexe.OpenCloser(thisFile)\n\tif err != nil {\n\t\treturn // not appended\n\t}\n\tdefer closer.Close()\n\n\tfor _, f := range rd.File {\n\t\t// get box and file name from f.Name\n\t\tfileParts := strings.SplitN(strings.TrimLeft(filepath.ToSlash(f.Name), \"/\"), \"/\", 2)\n\t\tboxName := fileParts[0]\n\t\tvar fileName string\n\t\tif len(fileParts) > 1 {\n\t\t\tfileName = fileParts[1]\n\t\t}\n\n\t\t// find box or create new one if doesn't exist\n\t\tbox := appendedBoxes[boxName]\n\t\tif box == nil {\n\t\t\tbox = &appendedBox{\n\t\t\t\tName:  boxName,\n\t\t\t\tFiles: make(map[string]*appendedFile),\n\t\t\t\tTime:  f.ModTime(),\n\t\t\t}\n\t\t\tappendedBoxes[boxName] = box\n\t\t}\n\n\t\t// create and add file to box\n\t\taf := &appendedFile{\n\t\t\tzipFile: f,\n\t\t}\n\t\tif f.Comment == \"dir\" {\n\t\t\taf.dir = true\n\t\t\taf.dirInfo = &appendedDirInfo{\n\t\t\t\tname: filepath.Base(af.zipFile.Name),\n\t\t\t\ttime: af.zipFile.ModTime(),\n\t\t\t}\n\t\t} else {\n\t\t\t// this is a file, we need it's contents so we can create a bytes.Reader when the file is opened\n\t\t\t// make a new byteslice\n\t\t\taf.content = make([]byte, af.zipFile.FileInfo().Size())\n\t\t\t// ignore reading empty files from zip (empty file still is a valid file to be read though!)\n\t\t\tif len(af.content) > 0 {\n\t\t\t\t// open io.ReadCloser\n\t\t\t\trc, err := af.zipFile.Open()\n\t\t\t\tif err != nil {\n\t\t\t\t\taf.content = nil // this will cause an error when the file is being opened or seeked (which is good)\n\t\t\t\t\t// TODO: it's quite blunt to just log this stuff. but this is in init, so rice.Debug can't be changed yet..\n\t\t\t\t\tlog.Printf(\"error opening appended file %s: %v\", af.zipFile.Name, err)\n\t\t\t\t} else {\n\t\t\t\t\t_, err = rc.Read(af.content)\n\t\t\t\t\trc.Close()\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\taf.content = nil // this will cause an error when the file is being opened or seeked (which is good)\n\t\t\t\t\t\t// TODO: it's quite blunt to just log this stuff. but this is in init, so rice.Debug can't be changed yet..\n\t\t\t\t\t\tlog.Printf(\"error reading data for appended file %s: %v\", af.zipFile.Name, err)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// add appendedFile to box file list\n\t\tbox.Files[fileName] = af\n\n\t\t// add to parent dir (if any)\n\t\tdirName := filepath.Dir(fileName)\n\t\tif dirName == \".\" {\n\t\t\tdirName = \"\"\n\t\t}\n\t\tif fileName != \"\" { // don't make box root dir a child of itself\n\t\t\tif dir := box.Files[dirName]; dir != nil {\n\t\t\t\tdir.children = append(dir.children, af)\n\t\t\t}\n\t\t}\n\t}\n}\n\n// implements os.FileInfo.\n// used for Readdir()\ntype appendedDirInfo struct {\n\tname string\n\ttime time.Time\n}\n\nfunc (adi *appendedDirInfo) Name() string {\n\treturn adi.name\n}\nfunc (adi *appendedDirInfo) Size() int64 {\n\treturn 0\n}\nfunc (adi *appendedDirInfo) Mode() os.FileMode {\n\treturn os.ModeDir\n}\nfunc (adi *appendedDirInfo) ModTime() time.Time {\n\treturn adi.time\n}\nfunc (adi *appendedDirInfo) IsDir() bool {\n\treturn true\n}\nfunc (adi *appendedDirInfo) Sys() interface{} {\n\treturn nil\n}\n"
        },
        {
          "name": "box.go",
          "type": "blob",
          "size": 7.84765625,
          "content": "package rice\n\nimport (\n\t\"bytes\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"runtime\"\n\t\"strings\"\n\t\"time\"\n\n\t\"github.com/GeertJohan/go.rice/embedded\"\n)\n\n// Box abstracts a directory for resources/files.\n// It can either load files from disk, or from embedded code (when `rice --embed` was ran).\ntype Box struct {\n\tname         string\n\tabsolutePath string\n\tembed        *embedded.EmbeddedBox\n\tappendd      *appendedBox\n}\n\nvar defaultLocateOrder = []LocateMethod{LocateEmbedded, LocateAppended, LocateFS}\n\nfunc findBox(name string, order []LocateMethod) (*Box, error) {\n\tb := &Box{name: name}\n\n\t// no support for absolute paths since gopath can be different on different machines.\n\t// therefore, required box must be located relative to package requiring it.\n\tif filepath.IsAbs(name) {\n\t\treturn nil, errors.New(\"given name/path is absolute\")\n\t}\n\n\tvar err error\n\tfor _, method := range order {\n\t\tswitch method {\n\t\tcase LocateEmbedded:\n\t\t\tif embed := embedded.EmbeddedBoxes[name]; embed != nil {\n\t\t\t\tb.embed = embed\n\t\t\t\treturn b, nil\n\t\t\t}\n\n\t\tcase LocateAppended:\n\t\t\tappendedBoxName := strings.Replace(name, `/`, `-`, -1)\n\t\t\tif appendd := appendedBoxes[appendedBoxName]; appendd != nil {\n\t\t\t\tb.appendd = appendd\n\t\t\t\treturn b, nil\n\t\t\t}\n\n\t\tcase LocateFS:\n\t\t\t// resolve absolute directory path\n\t\t\terr := b.resolveAbsolutePathFromCaller()\n\t\t\tif err != nil {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\t// check if absolutePath exists on filesystem\n\t\t\tinfo, err := os.Stat(b.absolutePath)\n\t\t\tif err != nil {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\t// check if absolutePath is actually a directory\n\t\t\tif !info.IsDir() {\n\t\t\t\terr = errors.New(\"given name/path is not a directory\")\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\treturn b, nil\n\t\tcase LocateWorkingDirectory:\n\t\t\t// resolve absolute directory path\n\t\t\terr := b.resolveAbsolutePathFromWorkingDirectory()\n\t\t\tif err != nil {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\t// check if absolutePath exists on filesystem\n\t\t\tinfo, err := os.Stat(b.absolutePath)\n\t\t\tif err != nil {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\t// check if absolutePath is actually a directory\n\t\t\tif !info.IsDir() {\n\t\t\t\terr = errors.New(\"given name/path is not a directory\")\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\treturn b, nil\n\t\t}\n\t}\n\n\tif err == nil {\n\t\terr = fmt.Errorf(\"could not locate box %q\", name)\n\t}\n\n\treturn nil, err\n}\n\n// FindBox returns a Box instance for given name.\n// When the given name is a relative path, it's base path will be the calling pkg/cmd's source root.\n// When the given name is absolute, it's absolute. derp.\n// Make sure the path doesn't contain any sensitive information as it might be placed into generated go source (embedded).\nfunc FindBox(name string) (*Box, error) {\n\treturn findBox(name, defaultLocateOrder)\n}\n\n// MustFindBox returns a Box instance for given name, like FindBox does.\n// It does not return an error, instead it panics when an error occurs.\nfunc MustFindBox(name string) *Box {\n\tbox, err := findBox(name, defaultLocateOrder)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\treturn box\n}\n\n// This is injected as a mutable function literal so that we can mock it out in\n// tests and return a fixed test file.\nvar resolveAbsolutePathFromCaller = func(name string, nStackFrames int) (string, error) {\n\t_, callingGoFile, _, ok := runtime.Caller(nStackFrames)\n\tif !ok {\n\t\treturn \"\", errors.New(\"couldn't find caller on stack\")\n\t}\n\n\t// resolve to proper path\n\tpkgDir := filepath.Dir(callingGoFile)\n\t// fix for go cover\n\tconst coverPath = \"_test/_obj_test\"\n\tif !filepath.IsAbs(pkgDir) {\n\t\tif i := strings.Index(pkgDir, coverPath); i >= 0 {\n\t\t\tpkgDir = pkgDir[:i] + pkgDir[i+len(coverPath):]            // remove coverPath\n\t\t\tpkgDir = filepath.Join(os.Getenv(\"GOPATH\"), \"src\", pkgDir) // make absolute\n\t\t}\n\t}\n\treturn filepath.Join(pkgDir, name), nil\n}\n\nfunc (b *Box) resolveAbsolutePathFromCaller() error {\n\tpath, err := resolveAbsolutePathFromCaller(b.name, 4)\n\tif err != nil {\n\t\treturn err\n\t}\n\tb.absolutePath = path\n\treturn nil\n\n}\n\nfunc (b *Box) resolveAbsolutePathFromWorkingDirectory() error {\n\tpath, err := os.Getwd()\n\tif err != nil {\n\t\treturn err\n\t}\n\tb.absolutePath = filepath.Join(path, b.name)\n\treturn nil\n}\n\n// IsEmbedded indicates wether this box was embedded into the application\nfunc (b *Box) IsEmbedded() bool {\n\treturn b.embed != nil\n}\n\n// IsAppended indicates wether this box was appended to the application\nfunc (b *Box) IsAppended() bool {\n\treturn b.appendd != nil\n}\n\n// Time returns how actual the box is.\n// When the box is embedded, it's value is saved in the embedding code.\n// When the box is live, this methods returns time.Now()\nfunc (b *Box) Time() time.Time {\n\tif b.IsEmbedded() {\n\t\treturn b.embed.Time\n\t}\n\n\tif b.IsAppended() {\n\t\treturn b.appendd.Time\n\t}\n\n\treturn time.Now()\n}\n\n// Open opens a File from the box\n// If there is an error, it will be of type *os.PathError.\nfunc (b *Box) Open(name string) (*File, error) {\n\tif Debug {\n\t\tfmt.Printf(\"Open(%s)\\n\", name)\n\t}\n\n\tif b.IsEmbedded() {\n\t\tif Debug {\n\t\t\tfmt.Println(\"Box is embedded\")\n\t\t}\n\n\t\t// trim prefix (paths are relative to box)\n\t\tname = strings.TrimLeft(name, \"/\")\n\t\tif Debug {\n\t\t\tfmt.Printf(\"Trying %s\\n\", name)\n\t\t}\n\n\t\t// search for file\n\t\tef := b.embed.Files[name]\n\t\tif ef == nil {\n\t\t\tif Debug {\n\t\t\t\tfmt.Println(\"Didn't find file in embed\")\n\t\t\t}\n\t\t\t// file not found, try dir\n\t\t\ted := b.embed.Dirs[name]\n\t\t\tif ed == nil {\n\t\t\t\tif Debug {\n\t\t\t\t\tfmt.Println(\"Didn't find dir in embed\")\n\t\t\t\t}\n\t\t\t\t// dir not found, error out\n\t\t\t\treturn nil, &os.PathError{\n\t\t\t\t\tOp:   \"open\",\n\t\t\t\t\tPath: name,\n\t\t\t\t\tErr:  os.ErrNotExist,\n\t\t\t\t}\n\t\t\t}\n\t\t\tif Debug {\n\t\t\t\tfmt.Println(\"Found dir. Returning virtual dir\")\n\t\t\t}\n\t\t\tvd := newVirtualDir(ed)\n\t\t\treturn &File{virtualD: vd}, nil\n\t\t}\n\n\t\t// box is embedded\n\t\tif Debug {\n\t\t\tfmt.Println(\"Found file. Returning virtual file\")\n\t\t}\n\t\tvf := newVirtualFile(ef)\n\t\treturn &File{virtualF: vf}, nil\n\t}\n\n\tif b.IsAppended() {\n\t\t// trim prefix (paths are relative to box)\n\t\tname = strings.TrimLeft(name, \"/\")\n\n\t\t// search for file\n\t\tappendedFile := b.appendd.Files[name]\n\t\tif appendedFile == nil {\n\t\t\treturn nil, &os.PathError{\n\t\t\t\tOp:   \"open\",\n\t\t\t\tPath: name,\n\t\t\t\tErr:  os.ErrNotExist,\n\t\t\t}\n\t\t}\n\n\t\t// create new file\n\t\tf := &File{\n\t\t\tappendedF: appendedFile,\n\t\t}\n\n\t\t// if this file is a directory, we want to be able to read and seek\n\t\tif !appendedFile.dir {\n\t\t\t// looks like malformed data in zip, error now\n\t\t\tif appendedFile.content == nil {\n\t\t\t\treturn nil, &os.PathError{\n\t\t\t\t\tOp:   \"open\",\n\t\t\t\t\tPath: \"name\",\n\t\t\t\t\tErr:  errors.New(\"error reading data from zip file\"),\n\t\t\t\t}\n\t\t\t}\n\t\t\t// create new bytes.Reader\n\t\t\tf.appendedFileReader = bytes.NewReader(appendedFile.content)\n\t\t}\n\n\t\t// all done\n\t\treturn f, nil\n\t}\n\n\t// perform os open\n\tif Debug {\n\t\tfmt.Printf(\"Using os.Open(%s)\", filepath.Join(b.absolutePath, name))\n\t}\n\tfile, err := os.Open(filepath.Join(b.absolutePath, name))\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn &File{realF: file}, nil\n}\n\n// Bytes returns the content of the file with given name as []byte.\nfunc (b *Box) Bytes(name string) ([]byte, error) {\n\tfile, err := b.Open(name)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer file.Close()\n\n\tcontent, err := ioutil.ReadAll(file)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn content, nil\n}\n\n// MustBytes returns the content of the file with given name as []byte.\n// panic's on error.\nfunc (b *Box) MustBytes(name string) []byte {\n\tbts, err := b.Bytes(name)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\treturn bts\n}\n\n// String returns the content of the file with given name as string.\nfunc (b *Box) String(name string) (string, error) {\n\t// check if box is embedded, optimized fast path\n\tif b.IsEmbedded() {\n\t\t// find file in embed\n\t\tef := b.embed.Files[name]\n\t\tif ef == nil {\n\t\t\treturn \"\", os.ErrNotExist\n\t\t}\n\t\t// return as string\n\t\treturn ef.Content, nil\n\t}\n\n\tbts, err := b.Bytes(name)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\treturn string(bts), nil\n}\n\n// MustString returns the content of the file with given name as string.\n// panic's on error.\nfunc (b *Box) MustString(name string) string {\n\tstr, err := b.String(name)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\treturn str\n}\n\n// Name returns the name of the box\nfunc (b *Box) Name() string {\n\treturn b.name\n}\n"
        },
        {
          "name": "config.go",
          "type": "blob",
          "size": 1.4677734375,
          "content": "package rice\n\n// LocateMethod defines how a box is located.\ntype LocateMethod int\n\nconst (\n\tLocateFS               = LocateMethod(iota) // Locate on the filesystem according to package path.\n\tLocateAppended                              // Locate boxes appended to the executable.\n\tLocateEmbedded                              // Locate embedded boxes.\n\tLocateWorkingDirectory                      // Locate on the binary working directory\n)\n\n// Config allows customizing the box lookup behavior.\ntype Config struct {\n\t// LocateOrder defines the priority order that boxes are searched for. By\n\t// default, the package global FindBox searches for embedded boxes first,\n\t// then appended boxes, and then finally boxes on the filesystem.  That\n\t// search order may be customized by provided the ordered list here. Leaving\n\t// out a particular method will omit that from the search space. For\n\t// example, []LocateMethod{LocateEmbedded, LocateAppended} will never search\n\t// the filesystem for boxes.\n\tLocateOrder []LocateMethod\n}\n\n// FindBox searches for boxes using the LocateOrder of the config.\nfunc (c *Config) FindBox(boxName string) (*Box, error) {\n\treturn findBox(boxName, c.LocateOrder)\n}\n\n// MustFindBox searches for boxes using the LocateOrder of the config, like\n// FindBox does.  It does not return an error, instead it panics when an error\n// occurs.\nfunc (c *Config) MustFindBox(boxName string) *Box {\n\tbox, err := findBox(boxName, c.LocateOrder)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\treturn box\n}\n"
        },
        {
          "name": "config_test.go",
          "type": "blob",
          "size": 3.3955078125,
          "content": "package rice\n\nimport (\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"testing\"\n\n\t\"github.com/GeertJohan/go.rice/embedded\"\n)\n\n// For all test code in this package, define a set of test boxes.\nvar eb1 *embedded.EmbeddedBox\nvar ab1, ab2 *appendedBox\nvar fsb1, fsb2, fsb3 string // paths to filesystem boxes\nfunc init() {\n\tvar err error\n\n\t// Box1 exists in all three locations.\n\teb1 = &embedded.EmbeddedBox{Name: \"box1\"}\n\tembedded.RegisterEmbeddedBox(eb1.Name, eb1)\n\tab1 = &appendedBox{Name: \"box1\"}\n\tappendedBoxes[\"box1\"] = ab1\n\tfsb1, err = ioutil.TempDir(\"\", \"box1\")\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\t// Box2 exists in only appended and FS.\n\tab2 = &appendedBox{Name: \"box2\"}\n\tappendedBoxes[\"box2\"] = ab2\n\tfsb2, err = ioutil.TempDir(\"\", \"box2\")\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\t// Box3 exists only on disk.\n\tfsb3, err = ioutil.TempDir(\"\", \"box3\")\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\t// Also, replace the default filesystem lookup path to directly support the\n\t// on-disk temp directories.\n\tresolveAbsolutePathFromCaller = func(name string, n int) (string, error) {\n\t\tif name == \"box1\" {\n\t\t\treturn fsb1, nil\n\t\t} else if name == \"box2\" {\n\t\t\treturn fsb2, nil\n\t\t} else if name == \"box3\" {\n\t\t\treturn fsb3, nil\n\t\t}\n\t\treturn \"\", fmt.Errorf(\"Unknown box name: %q\", name)\n\t}\n}\n\nfunc TestDefaultLookupOrder(t *testing.T) {\n\t// Box1 exists in all three, so the default order should find the embedded.\n\tb, err := FindBox(\"box1\")\n\tif err != nil {\n\t\tt.Fatalf(\"Expected to find box1, got error: %v\", err)\n\t}\n\tif b.embed != eb1 {\n\t\tt.Fatalf(\"Expected to find embedded box, but got %#v\", b)\n\t}\n\n\t// Box2 exists in appended and FS, so find the appended.\n\tb2, err := FindBox(\"box2\")\n\tif err != nil {\n\t\tt.Fatalf(\"Expected to find box2, got error: %v\", err)\n\t}\n\tif b2.appendd != ab2 {\n\t\tt.Fatalf(\"Expected to find appended box, but got %#v\", b2)\n\t}\n\n\t// Box3 exists only on FS, so find it there.\n\tb3, err := FindBox(\"box3\")\n\tif err != nil {\n\t\tt.Fatalf(\"Expected to find box3, got error: %v\", err)\n\t}\n\tif b3.absolutePath != fsb3 {\n\t\tt.Fatalf(\"Expected to find FS box, but got %#v\", b3)\n\t}\n}\n\nfunc TestConfigLocateOrder(t *testing.T) {\n\tcfg := Config{LocateOrder: []LocateMethod{LocateFS, LocateAppended, LocateEmbedded}}\n\tfsb := []string{fsb1, fsb2, fsb3}\n\t// All 3 boxes have a FS backend, so we should always find that.\n\tfor i, boxName := range []string{\"box1\", \"box2\", \"box3\"} {\n\t\tb, err := cfg.FindBox(boxName)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"Expected to find %q, got error: %v\", boxName, err)\n\t\t}\n\t\tif b.absolutePath != fsb[i] {\n\t\t\tt.Fatalf(\"Expected to find FS box, but got %#v\", b)\n\t\t}\n\t}\n\n\tcfg.LocateOrder = []LocateMethod{LocateAppended, LocateFS, LocateEmbedded}\n\t{\n\t\tb, err := cfg.FindBox(\"box3\")\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"Expected to find box3, got error: %v\", err)\n\t\t}\n\t\tif b.absolutePath != fsb3 {\n\t\t\tt.Fatalf(\"Expected to find FS box, but got %#v\", b)\n\t\t}\n\t}\n\t{\n\t\tb, err := cfg.FindBox(\"box2\")\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"Expected to find box2, got error: %v\", err)\n\t\t}\n\t\tif b.appendd != ab2 {\n\t\t\tt.Fatalf(\"Expected to find appended box, but got %#v\", b)\n\t\t}\n\t}\n\n\t// What if we don't list all the locate methods?\n\tcfg.LocateOrder = []LocateMethod{LocateEmbedded}\n\t{\n\t\tb, err := cfg.FindBox(\"box2\")\n\t\tif err == nil {\n\t\t\tt.Fatalf(\"Expected not to find box2, but something was found: %#v\", b)\n\t\t}\n\t}\n\t{\n\t\tb, err := cfg.FindBox(\"box1\")\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"Expected to find box2, got error: %v\", err)\n\t\t}\n\t\tif b.embed != eb1 {\n\t\t\tt.Fatalf(\"Expected to find embedded box, but got %#v\", b)\n\t\t}\n\t}\n}\n"
        },
        {
          "name": "debug.go",
          "type": "blob",
          "size": 0.0791015625,
          "content": "package rice\n\n// Debug can be set to true to enable debugging.\nvar Debug = false\n"
        },
        {
          "name": "embedded.go",
          "type": "blob",
          "size": 2.20703125,
          "content": "package rice\n\nimport (\n\t\"os\"\n\t\"time\"\n\n\t\"github.com/GeertJohan/go.rice/embedded\"\n)\n\n// re-type to make exported methods invisible to user (godoc)\n// they're not required for the user\n// embeddedDirInfo implements os.FileInfo\ntype embeddedDirInfo embedded.EmbeddedDir\n\n// Name returns the base name of the directory\n// (implementing os.FileInfo)\nfunc (ed *embeddedDirInfo) Name() string {\n\treturn ed.Filename\n}\n\n// Size always returns 0\n// (implementing os.FileInfo)\nfunc (ed *embeddedDirInfo) Size() int64 {\n\treturn 0\n}\n\n// Mode returns the file mode bits\n// (implementing os.FileInfo)\nfunc (ed *embeddedDirInfo) Mode() os.FileMode {\n\treturn os.FileMode(0555 | os.ModeDir) // dr-xr-xr-x\n}\n\n// ModTime returns the modification time\n// (implementing os.FileInfo)\nfunc (ed *embeddedDirInfo) ModTime() time.Time {\n\treturn ed.DirModTime\n}\n\n// IsDir returns the abbreviation for Mode().IsDir() (always true)\n// (implementing os.FileInfo)\nfunc (ed *embeddedDirInfo) IsDir() bool {\n\treturn true\n}\n\n// Sys returns the underlying data source (always nil)\n// (implementing os.FileInfo)\nfunc (ed *embeddedDirInfo) Sys() interface{} {\n\treturn nil\n}\n\n// re-type to make exported methods invisible to user (godoc)\n// they're not required for the user\n// embeddedFileInfo implements os.FileInfo\ntype embeddedFileInfo embedded.EmbeddedFile\n\n// Name returns the base name of the file\n// (implementing os.FileInfo)\nfunc (ef *embeddedFileInfo) Name() string {\n\treturn ef.Filename\n}\n\n// Size returns the length in bytes for regular files; system-dependent for others\n// (implementing os.FileInfo)\nfunc (ef *embeddedFileInfo) Size() int64 {\n\treturn int64(len(ef.Content))\n}\n\n// Mode returns the file mode bits\n// (implementing os.FileInfo)\nfunc (ef *embeddedFileInfo) Mode() os.FileMode {\n\treturn os.FileMode(0555) // r-xr-xr-x\n}\n\n// ModTime returns the modification time\n// (implementing os.FileInfo)\nfunc (ef *embeddedFileInfo) ModTime() time.Time {\n\treturn ef.FileModTime\n}\n\n// IsDir returns the abbreviation for Mode().IsDir() (always false)\n// (implementing os.FileInfo)\nfunc (ef *embeddedFileInfo) IsDir() bool {\n\treturn false\n}\n\n// Sys returns the underlying data source (always nil)\n// (implementing os.FileInfo)\nfunc (ef *embeddedFileInfo) Sys() interface{} {\n\treturn nil\n}\n"
        },
        {
          "name": "embedded",
          "type": "tree",
          "content": null
        },
        {
          "name": "example",
          "type": "tree",
          "content": null
        },
        {
          "name": "file.go",
          "type": "blob",
          "size": 4.4443359375,
          "content": "package rice\n\nimport (\n\t\"bytes\"\n\t\"errors\"\n\t\"os\"\n\t\"path/filepath\"\n)\n\n// File implements the io.Reader, io.Seeker, io.Closer and http.File interfaces\ntype File struct {\n\t// File abstracts file methods so the user doesn't see the difference between rice.virtualFile, rice.virtualDir and os.File\n\t// TODO: maybe use internal File interface and four implementations: *os.File, appendedFile, virtualFile, virtualDir\n\n\t// real file on disk\n\trealF *os.File\n\n\t// when embedded (go)\n\tvirtualF *virtualFile\n\tvirtualD *virtualDir\n\n\t// when appended (zip)\n\tappendedF          *appendedFile\n\tappendedFileReader *bytes.Reader\n\t// TODO: is appendedFileReader subject of races? Might need a lock here..\n}\n\n// Close is like (*os.File).Close()\n// Visit http://golang.org/pkg/os/#File.Close for more information\nfunc (f *File) Close() error {\n\tif f.appendedF != nil {\n\t\tif f.appendedFileReader == nil {\n\t\t\treturn errors.New(\"already closed\")\n\t\t}\n\t\tf.appendedFileReader = nil\n\t\treturn nil\n\t}\n\tif f.virtualF != nil {\n\t\treturn f.virtualF.close()\n\t}\n\tif f.virtualD != nil {\n\t\treturn f.virtualD.close()\n\t}\n\treturn f.realF.Close()\n}\n\n// Stat is like (*os.File).Stat()\n// Visit http://golang.org/pkg/os/#File.Stat for more information\nfunc (f *File) Stat() (os.FileInfo, error) {\n\tif f.appendedF != nil {\n\t\tif f.appendedF.dir {\n\t\t\treturn f.appendedF.dirInfo, nil\n\t\t}\n\t\tif f.appendedFileReader == nil {\n\t\t\treturn nil, errors.New(\"file is closed\")\n\t\t}\n\t\treturn f.appendedF.zipFile.FileInfo(), nil\n\t}\n\tif f.virtualF != nil {\n\t\treturn f.virtualF.stat()\n\t}\n\tif f.virtualD != nil {\n\t\treturn f.virtualD.stat()\n\t}\n\treturn f.realF.Stat()\n}\n\n// Readdir is like (*os.File).Readdir()\n// Visit http://golang.org/pkg/os/#File.Readdir for more information\nfunc (f *File) Readdir(count int) ([]os.FileInfo, error) {\n\tif f.appendedF != nil {\n\t\tif f.appendedF.dir {\n\t\t\tfi := make([]os.FileInfo, 0, len(f.appendedF.children))\n\t\t\tfor _, childAppendedFile := range f.appendedF.children {\n\t\t\t\tif childAppendedFile.dir {\n\t\t\t\t\tfi = append(fi, childAppendedFile.dirInfo)\n\t\t\t\t} else {\n\t\t\t\t\tfi = append(fi, childAppendedFile.zipFile.FileInfo())\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn fi, nil\n\t\t}\n\t\t//++ TODO: is os.ErrInvalid the correct error for Readdir on file?\n\t\treturn nil, os.ErrInvalid\n\t}\n\tif f.virtualF != nil {\n\t\treturn f.virtualF.readdir(count)\n\t}\n\tif f.virtualD != nil {\n\t\treturn f.virtualD.readdir(count)\n\t}\n\treturn f.realF.Readdir(count)\n}\n\n// Readdirnames is like (*os.File).Readdirnames()\n// Visit http://golang.org/pkg/os/#File.Readdirnames for more information\nfunc (f *File) Readdirnames(count int) ([]string, error) {\n\tif f.appendedF != nil {\n\t\tif f.appendedF.dir {\n\t\t\tnames := make([]string, 0, len(f.appendedF.children))\n\t\t\tfor _, childAppendedFile := range f.appendedF.children {\n\t\t\t\tif childAppendedFile.dir {\n\t\t\t\t\tnames = append(names, childAppendedFile.dirInfo.name)\n\t\t\t\t} else {\n\t\t\t\t\tnames = append(names, childAppendedFile.zipFile.FileInfo().Name())\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn names, nil\n\t\t}\n\t\t// os.ErrInvalid to match the os.SyscallError (readdirent: invalid argument) that os.File returns\n\t\treturn nil, os.ErrInvalid\n\t}\n\tif f.virtualF != nil {\n\t\treturn f.virtualF.readdirnames(count)\n\t}\n\tif f.virtualD != nil {\n\t\treturn f.virtualD.readdirnames(count)\n\t}\n\treturn f.realF.Readdirnames(count)\n}\n\n// Read is like (*os.File).Read()\n// Visit http://golang.org/pkg/os/#File.Read for more information\nfunc (f *File) Read(bts []byte) (int, error) {\n\tif f.appendedF != nil {\n\t\tif f.appendedFileReader == nil {\n\t\t\treturn 0, &os.PathError{\n\t\t\t\tOp:   \"read\",\n\t\t\t\tPath: filepath.Base(f.appendedF.zipFile.Name),\n\t\t\t\tErr:  errors.New(\"file is closed\"),\n\t\t\t}\n\t\t}\n\t\tif f.appendedF.dir {\n\t\t\treturn 0, &os.PathError{\n\t\t\t\tOp:   \"read\",\n\t\t\t\tPath: filepath.Base(f.appendedF.zipFile.Name),\n\t\t\t\tErr:  errors.New(\"is a directory\"),\n\t\t\t}\n\t\t}\n\t\treturn f.appendedFileReader.Read(bts)\n\t}\n\tif f.virtualF != nil {\n\t\treturn f.virtualF.read(bts)\n\t}\n\tif f.virtualD != nil {\n\t\treturn f.virtualD.read(bts)\n\t}\n\treturn f.realF.Read(bts)\n}\n\n// Seek is like (*os.File).Seek()\n// Visit http://golang.org/pkg/os/#File.Seek for more information\nfunc (f *File) Seek(offset int64, whence int) (int64, error) {\n\tif f.appendedF != nil {\n\t\tif f.appendedFileReader == nil {\n\t\t\treturn 0, &os.PathError{\n\t\t\t\tOp:   \"seek\",\n\t\t\t\tPath: filepath.Base(f.appendedF.zipFile.Name),\n\t\t\t\tErr:  errors.New(\"file is closed\"),\n\t\t\t}\n\t\t}\n\t\treturn f.appendedFileReader.Seek(offset, whence)\n\t}\n\tif f.virtualF != nil {\n\t\treturn f.virtualF.seek(offset, whence)\n\t}\n\tif f.virtualD != nil {\n\t\treturn f.virtualD.seek(offset, whence)\n\t}\n\treturn f.realF.Seek(offset, whence)\n}\n"
        },
        {
          "name": "go.mod",
          "type": "blob",
          "size": 0.3134765625,
          "content": "module github.com/GeertJohan/go.rice\n\ngo 1.12\n\nrequire (\n\tgithub.com/GeertJohan/go.incremental v1.0.0\n\tgithub.com/akavel/rsrc v0.8.0\n\tgithub.com/daaku/go.zipexe v1.0.2\n\tgithub.com/davecgh/go-spew v1.1.1\n\tgithub.com/jessevdk/go-flags v1.4.0\n\tgithub.com/nkovacs/streamquote v1.0.0\n\tgithub.com/valyala/fasttemplate v1.0.1\n)\n"
        },
        {
          "name": "go.sum",
          "type": "blob",
          "size": 1.3828125,
          "content": "github.com/GeertJohan/go.incremental v1.0.0 h1:7AH+pY1XUgQE4Y1HcXYaMqAI0m9yrFqo/jt0CW30vsg=\ngithub.com/GeertJohan/go.incremental v1.0.0/go.mod h1:6fAjUhbVuX1KcMD3c8TEgVUqmo4seqhv0i0kdATSkM0=\ngithub.com/akavel/rsrc v0.8.0 h1:zjWn7ukO9Kc5Q62DOJCcxGpXC18RawVtYAGdz2aLlfw=\ngithub.com/akavel/rsrc v0.8.0/go.mod h1:uLoCtb9J+EyAqh+26kdrTgmzRBFPGOolLWKpdxkKq+c=\ngithub.com/daaku/go.zipexe v1.0.2 h1:Zg55YLYTr7M9wjKn8SY/WcpuuEi+kR2u4E8RhvpyXmk=\ngithub.com/daaku/go.zipexe v1.0.2/go.mod h1:5xWogtqlYnfBXkSB1o9xysukNP9GTvaNkqzUZbt3Bw8=\ngithub.com/davecgh/go-spew v1.1.1 h1:vj9j/u1bqnvCEfJOwUhtlOARqs3+rkHYY13jYWTU97c=\ngithub.com/davecgh/go-spew v1.1.1/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=\ngithub.com/jessevdk/go-flags v1.4.0 h1:4IU2WS7AumrZ/40jfhf4QVDMsQwqA7VEHozFRrGARJA=\ngithub.com/jessevdk/go-flags v1.4.0/go.mod h1:4FA24M0QyGHXBuZZK/XkWh8h0e1EYbRYJSGM75WSRxI=\ngithub.com/nkovacs/streamquote v1.0.0 h1:PmVIV08Zlx2lZK5fFZlMZ04eHcDTIFJCv/5/0twVUow=\ngithub.com/nkovacs/streamquote v1.0.0/go.mod h1:BN+NaZ2CmdKqUuTUXUEm9j95B2TRbpOWpxbJYzzgUsc=\ngithub.com/valyala/bytebufferpool v1.0.0 h1:GqA5TC/0021Y/b9FG4Oi9Mr3q7XYx6KllzawFIhcdPw=\ngithub.com/valyala/bytebufferpool v1.0.0/go.mod h1:6bBcMArwyJ5K/AmCkWv1jt77kVWyCJ6HpOuEn7z0Csc=\ngithub.com/valyala/fasttemplate v1.0.1 h1:tY9CJiPnMXf1ERmG2EyK7gNUd+c6RKGD0IfU8WdUSz8=\ngithub.com/valyala/fasttemplate v1.0.1/go.mod h1:UQGH1tvbgY+Nz5t2n7tXsz52dQxojPUpymEIMZ47gx8=\n"
        },
        {
          "name": "http.go",
          "type": "blob",
          "size": 0.4853515625,
          "content": "package rice\n\nimport (\n\t\"net/http\"\n)\n\n// HTTPBox implements http.FileSystem which allows the use of Box with a http.FileServer.\n//   e.g.: http.Handle(\"/\", http.FileServer(rice.MustFindBox(\"http-files\").HTTPBox()))\ntype HTTPBox struct {\n\t*Box\n}\n\n// HTTPBox creates a new HTTPBox from an existing Box\nfunc (b *Box) HTTPBox() *HTTPBox {\n\treturn &HTTPBox{b}\n}\n\n// Open returns a File using the http.File interface\nfunc (hb *HTTPBox) Open(name string) (http.File, error) {\n\treturn hb.Box.Open(name)\n}\n"
        },
        {
          "name": "rice",
          "type": "tree",
          "content": null
        },
        {
          "name": "sort.go",
          "type": "blob",
          "size": 0.7724609375,
          "content": "package rice\n\nimport \"os\"\n\n// SortByName allows an array of os.FileInfo objects\n// to be easily sorted by filename using sort.Sort(SortByName(array))\ntype SortByName []os.FileInfo\n\nfunc (f SortByName) Len() int           { return len(f) }\nfunc (f SortByName) Less(i, j int) bool { return f[i].Name() < f[j].Name() }\nfunc (f SortByName) Swap(i, j int)      { f[i], f[j] = f[j], f[i] }\n\n// SortByModified allows an array of os.FileInfo objects\n// to be easily sorted by modified date using sort.Sort(SortByModified(array))\ntype SortByModified []os.FileInfo\n\nfunc (f SortByModified) Len() int           { return len(f) }\nfunc (f SortByModified) Less(i, j int) bool { return f[i].ModTime().Unix() > f[j].ModTime().Unix() }\nfunc (f SortByModified) Swap(i, j int)      { f[i], f[j] = f[j], f[i] }\n"
        },
        {
          "name": "virtual.go",
          "type": "blob",
          "size": 6.8837890625,
          "content": "package rice\n\nimport (\n\t\"errors\"\n\t\"io\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"sort\"\n\n\t\"github.com/GeertJohan/go.rice/embedded\"\n)\n\n//++ TODO: IDEA: merge virtualFile and virtualDir, this decreases work done by rice.File\n\n// virtualFile is a 'stateful' virtual file.\n// virtualFile wraps an *EmbeddedFile for a call to Box.Open() and virtualizes 'read cursor' (offset) and 'closing'.\n// virtualFile is only internally visible and should be exposed through rice.File\ntype virtualFile struct {\n\t*embedded.EmbeddedFile       // the actual embedded file, embedded to obtain methods\n\toffset                 int64 // read position on the virtual file\n\tclosed                 bool  // closed when true\n}\n\n// create a new virtualFile for given EmbeddedFile\nfunc newVirtualFile(ef *embedded.EmbeddedFile) *virtualFile {\n\tvf := &virtualFile{\n\t\tEmbeddedFile: ef,\n\t\toffset:       0,\n\t\tclosed:       false,\n\t}\n\treturn vf\n}\n\n//++ TODO check for nil pointers in all these methods. When so: return os.PathError with Err: os.ErrInvalid\n\nfunc (vf *virtualFile) close() error {\n\tif vf.closed {\n\t\treturn &os.PathError{\n\t\t\tOp:   \"close\",\n\t\t\tPath: vf.EmbeddedFile.Filename,\n\t\t\tErr:  errors.New(\"already closed\"),\n\t\t}\n\t}\n\tvf.EmbeddedFile = nil\n\tvf.closed = true\n\treturn nil\n}\n\nfunc (vf *virtualFile) stat() (os.FileInfo, error) {\n\tif vf.closed {\n\t\treturn nil, &os.PathError{\n\t\t\tOp:   \"stat\",\n\t\t\tPath: vf.EmbeddedFile.Filename,\n\t\t\tErr:  errors.New(\"bad file descriptor\"),\n\t\t}\n\t}\n\treturn (*embeddedFileInfo)(vf.EmbeddedFile), nil\n}\n\nfunc (vf *virtualFile) readdir(count int) ([]os.FileInfo, error) {\n\tif vf.closed {\n\t\treturn nil, &os.PathError{\n\t\t\tOp:   \"readdir\",\n\t\t\tPath: vf.EmbeddedFile.Filename,\n\t\t\tErr:  errors.New(\"bad file descriptor\"),\n\t\t}\n\t}\n\treturn nil, os.ErrInvalid\n}\n\nfunc (vf *virtualFile) readdirnames(count int) ([]string, error) {\n\tif vf.closed {\n\t\treturn nil, &os.PathError{\n\t\t\tOp:   \"readdirnames\",\n\t\t\tPath: vf.EmbeddedFile.Filename,\n\t\t\tErr:  errors.New(\"bad file descriptor\"),\n\t\t}\n\t}\n\treturn nil, os.ErrInvalid\n}\n\nfunc (vf *virtualFile) read(bts []byte) (int, error) {\n\tif vf.closed {\n\t\treturn 0, &os.PathError{\n\t\t\tOp:   \"read\",\n\t\t\tPath: vf.EmbeddedFile.Filename,\n\t\t\tErr:  errors.New(\"bad file descriptor\"),\n\t\t}\n\t}\n\n\tend := vf.offset + int64(len(bts))\n\n\tif end >= int64(len(vf.Content)) {\n\t\t// end of file, so return what we have + EOF\n\t\tn := copy(bts, vf.Content[vf.offset:])\n\t\tvf.offset = 0\n\t\treturn n, io.EOF\n\t}\n\n\tn := copy(bts, vf.Content[vf.offset:end])\n\tvf.offset += int64(n)\n\treturn n, nil\n\n}\n\nfunc (vf *virtualFile) seek(offset int64, whence int) (int64, error) {\n\tif vf.closed {\n\t\treturn 0, &os.PathError{\n\t\t\tOp:   \"seek\",\n\t\t\tPath: vf.EmbeddedFile.Filename,\n\t\t\tErr:  errors.New(\"bad file descriptor\"),\n\t\t}\n\t}\n\tvar e error\n\n\t//++ TODO: check if this is correct implementation for seek\n\tswitch whence {\n\tcase os.SEEK_SET:\n\t\t//++ check if new offset isn't out of bounds, set e when it is, then break out of switch\n\t\tvf.offset = offset\n\tcase os.SEEK_CUR:\n\t\t//++ check if new offset isn't out of bounds, set e when it is, then break out of switch\n\t\tvf.offset += offset\n\tcase os.SEEK_END:\n\t\t//++ check if new offset isn't out of bounds, set e when it is, then break out of switch\n\t\tvf.offset = int64(len(vf.EmbeddedFile.Content)) - offset\n\t}\n\n\tif e != nil {\n\t\treturn 0, &os.PathError{\n\t\t\tOp:   \"seek\",\n\t\t\tPath: vf.Filename,\n\t\t\tErr:  e,\n\t\t}\n\t}\n\n\treturn vf.offset, nil\n}\n\n// virtualDir is a 'stateful' virtual directory.\n// virtualDir wraps an *EmbeddedDir for a call to Box.Open() and virtualizes 'closing'.\n// virtualDir is only internally visible and should be exposed through rice.File\ntype virtualDir struct {\n\t*embedded.EmbeddedDir\n\toffset int // readdir position on the directory\n\tclosed bool\n}\n\n// create a new virtualDir for given EmbeddedDir\nfunc newVirtualDir(ed *embedded.EmbeddedDir) *virtualDir {\n\tvd := &virtualDir{\n\t\tEmbeddedDir: ed,\n\t\toffset:      0,\n\t\tclosed:      false,\n\t}\n\treturn vd\n}\n\nfunc (vd *virtualDir) close() error {\n\t//++ TODO: needs sync mutex?\n\tif vd.closed {\n\t\treturn &os.PathError{\n\t\t\tOp:   \"close\",\n\t\t\tPath: vd.EmbeddedDir.Filename,\n\t\t\tErr:  errors.New(\"already closed\"),\n\t\t}\n\t}\n\tvd.closed = true\n\treturn nil\n}\n\nfunc (vd *virtualDir) stat() (os.FileInfo, error) {\n\tif vd.closed {\n\t\treturn nil, &os.PathError{\n\t\t\tOp:   \"stat\",\n\t\t\tPath: vd.EmbeddedDir.Filename,\n\t\t\tErr:  errors.New(\"bad file descriptor\"),\n\t\t}\n\t}\n\treturn (*embeddedDirInfo)(vd.EmbeddedDir), nil\n}\n\nfunc (vd *virtualDir) readdir(n int) ([]os.FileInfo, error) {\n\n\tif vd.closed {\n\t\treturn nil, &os.PathError{\n\t\t\tOp:   \"readdir\",\n\t\t\tPath: vd.EmbeddedDir.Filename,\n\t\t\tErr:  errors.New(\"bad file descriptor\"),\n\t\t}\n\t}\n\n\t// Build up the array of our contents\n\tvar files []os.FileInfo\n\n\t// Add the child directories\n\tfor _, child := range vd.ChildDirs {\n\t\tchild.Filename = filepath.Base(child.Filename)\n\t\tfiles = append(files, (*embeddedDirInfo)(child))\n\t}\n\n\t// Add the child files\n\tfor _, child := range vd.ChildFiles {\n\t\tchild.Filename = filepath.Base(child.Filename)\n\t\tfiles = append(files, (*embeddedFileInfo)(child))\n\t}\n\n\t// Sort it by filename (lexical order)\n\tsort.Sort(SortByName(files))\n\n\t// Return all contents if that's what is requested\n\tif n <= 0 {\n\t\tvd.offset = 0\n\t\treturn files, nil\n\t}\n\n\t// If user has requested past the end of our list\n\t// return what we can and send an EOF\n\tif vd.offset+n >= len(files) {\n\t\toffset := vd.offset\n\t\tvd.offset = 0\n\t\treturn files[offset:], io.EOF\n\t}\n\n\toffset := vd.offset\n\tvd.offset += n\n\treturn files[offset : offset+n], nil\n\n}\n\nfunc (vd *virtualDir) readdirnames(n int) ([]string, error) {\n\n\tif vd.closed {\n\t\treturn nil, &os.PathError{\n\t\t\tOp:   \"readdir\",\n\t\t\tPath: vd.EmbeddedDir.Filename,\n\t\t\tErr:  errors.New(\"bad file descriptor\"),\n\t\t}\n\t}\n\n\t// Build up the array of our contents\n\tvar files []string\n\n\t// Add the child directories\n\tfor _, child := range vd.ChildDirs {\n\t\tfiles = append(files, filepath.Base(child.Filename))\n\t}\n\n\t// Add the child files\n\tfor _, child := range vd.ChildFiles {\n\t\tfiles = append(files, filepath.Base(child.Filename))\n\t}\n\n\t// Sort it by filename (lexical order)\n\tsort.Strings(files)\n\n\t// Return all contents if that's what is requested\n\tif n <= 0 {\n\t\tvd.offset = 0\n\t\treturn files, nil\n\t}\n\n\t// If user has requested past the end of our list\n\t// return what we can and send an EOF\n\tif vd.offset+n >= len(files) {\n\t\toffset := vd.offset\n\t\tvd.offset = 0\n\t\treturn files[offset:], io.EOF\n\t}\n\n\toffset := vd.offset\n\tvd.offset += n\n\treturn files[offset : offset+n], nil\n}\n\nfunc (vd *virtualDir) read(bts []byte) (int, error) {\n\tif vd.closed {\n\t\treturn 0, &os.PathError{\n\t\t\tOp:   \"read\",\n\t\t\tPath: vd.EmbeddedDir.Filename,\n\t\t\tErr:  errors.New(\"bad file descriptor\"),\n\t\t}\n\t}\n\treturn 0, &os.PathError{\n\t\tOp:   \"read\",\n\t\tPath: vd.EmbeddedDir.Filename,\n\t\tErr:  errors.New(\"is a directory\"),\n\t}\n}\n\nfunc (vd *virtualDir) seek(offset int64, whence int) (int64, error) {\n\tif vd.closed {\n\t\treturn 0, &os.PathError{\n\t\t\tOp:   \"seek\",\n\t\t\tPath: vd.EmbeddedDir.Filename,\n\t\t\tErr:  errors.New(\"bad file descriptor\"),\n\t\t}\n\t}\n\treturn 0, &os.PathError{\n\t\tOp:   \"seek\",\n\t\tPath: vd.Filename,\n\t\tErr:  errors.New(\"is a directory\"),\n\t}\n}\n"
        },
        {
          "name": "walk.go",
          "type": "blob",
          "size": 2.349609375,
          "content": "package rice\n\nimport (\n\t\"os\"\n\t\"path/filepath\"\n\t\"sort\"\n\t\"strings\"\n)\n\n// Walk is like filepath.Walk()\n// Visit http://golang.org/pkg/path/filepath/#Walk for more information\nfunc (b *Box) Walk(path string, walkFn filepath.WalkFunc) error {\n\n\tpathFile, err := b.Open(path)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer pathFile.Close()\n\n\tpathInfo, err := pathFile.Stat()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif b.IsAppended() || b.IsEmbedded() {\n\t\treturn b.walk(path, pathInfo, walkFn)\n\t}\n\n\t// We don't have any embedded or appended box so use live filesystem mode\n\treturn filepath.Walk(filepath.Join(b.absolutePath, path), func(path string, info os.FileInfo, err error) error {\n\n\t\t// Strip out the box name from the returned paths\n\t\tpath = strings.TrimPrefix(path, b.absolutePath+string(os.PathSeparator))\n\t\treturn walkFn(path, info, err)\n\n\t})\n\n}\n\n// walk recursively descends path.\n// See walk() in $GOROOT/src/pkg/path/filepath/path.go\nfunc (b *Box) walk(path string, info os.FileInfo, walkFn filepath.WalkFunc) error {\n\n\terr := walkFn(path, info, nil)\n\tif err != nil {\n\t\tif info.IsDir() && err == filepath.SkipDir {\n\t\t\treturn nil\n\t\t}\n\t\treturn err\n\t}\n\n\tif !info.IsDir() {\n\t\treturn nil\n\t}\n\n\tnames, err := b.readDirNames(path)\n\tif err != nil {\n\t\treturn walkFn(path, info, err)\n\t}\n\n\tfor _, name := range names {\n\n\t\tfilename := filepath.ToSlash(filepath.Join(path, name))\n\t\tfileObject, err := b.Open(filename)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tdefer fileObject.Close()\n\n\t\tfileInfo, err := fileObject.Stat()\n\t\tif err != nil {\n\t\t\tif err := walkFn(filename, fileInfo, err); err != nil && err != filepath.SkipDir {\n\t\t\t\treturn err\n\t\t\t}\n\t\t} else {\n\t\t\terr = b.walk(filename, fileInfo, walkFn)\n\t\t\tif err != nil {\n\t\t\t\tif !fileInfo.IsDir() || err != filepath.SkipDir {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn nil\n\n}\n\n// readDirNames reads the directory named by path and returns a sorted list of directory entries.\n// See readDirNames() in $GOROOT/pkg/path/filepath/path.go\nfunc (b *Box) readDirNames(path string) ([]string, error) {\n\n\tf, err := b.Open(path)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer f.Close()\n\n\tstat, err := f.Stat()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif !stat.IsDir() {\n\t\treturn nil, nil\n\t}\n\n\tinfos, err := f.Readdir(0)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tvar names []string\n\n\tfor _, info := range infos {\n\t\tnames = append(names, info.Name())\n\t}\n\n\tsort.Strings(names)\n\treturn names, nil\n\n}\n"
        }
      ]
    }
  ]
}