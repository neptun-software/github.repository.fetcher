{
  "metadata": {
    "timestamp": 1736566596096,
    "page": 149,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjE1MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "olekukonko/tablewriter",
      "stars": 4328,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.2744140625,
          "content": "# Created by .ignore support plugin (hsz.mobi)\n### Go template\n# Binaries for programs and plugins\n*.exe\n*.exe~\n*.dll\n*.so\n*.dylib\n\n# Test binary, build with `go test -c`\n*.test\n\n# Output of the go coverage tool, specifically when used with LiteIDE\n*.out\n\n\n# folders\n.idea\n.vscode\n"
        },
        {
          "name": "LICENSE.md",
          "type": "blob",
          "size": 1.033203125,
          "content": "Copyright (C) 2014 by Oleku Konko\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 15.021484375,
          "content": "ASCII Table Writer\n=========\n\n[![ci](https://github.com/olekukonko/tablewriter/workflows/ci/badge.svg?branch=master)](https://github.com/olekukonko/tablewriter/actions?query=workflow%3Aci)\n[![Total views](https://img.shields.io/sourcegraph/rrc/github.com/olekukonko/tablewriter.svg)](https://sourcegraph.com/github.com/olekukonko/tablewriter)\n[![Godoc](https://godoc.org/github.com/olekukonko/tablewriter?status.svg)](https://godoc.org/github.com/olekukonko/tablewriter)\n\nGenerate ASCII table on the fly ...  Installation is simple as\n\n    go get github.com/olekukonko/tablewriter\n\n\n#### Features\n- Automatic Padding\n- Support Multiple Lines\n- Supports Alignment\n- Support Custom Separators\n- Automatic Alignment of numbers & percentage\n- Write directly to http , file etc via `io.Writer`\n- Read directly from CSV file\n- Optional row line via `SetRowLine`\n- Normalise table header\n- Make CSV Headers optional\n- Enable or disable table border\n- Set custom footer support\n- Optional identical cells merging\n- Set custom caption\n- Optional reflowing of paragraphs in multi-line cells.\n\n#### Example   1 - Basic\n```go\ndata := [][]string{\n    []string{\"A\", \"The Good\", \"500\"},\n    []string{\"B\", \"The Very very Bad Man\", \"288\"},\n    []string{\"C\", \"The Ugly\", \"120\"},\n    []string{\"D\", \"The Gopher\", \"800\"},\n}\n\ntable := tablewriter.NewWriter(os.Stdout)\ntable.SetHeader([]string{\"Name\", \"Sign\", \"Rating\"})\n\nfor _, v := range data {\n    table.Append(v)\n}\ntable.Render() // Send output\n```\n\n##### Output  1\n```\n+------+-----------------------+--------+\n| NAME |         SIGN          | RATING |\n+------+-----------------------+--------+\n|  A   |       The Good        |    500 |\n|  B   | The Very very Bad Man |    288 |\n|  C   |       The Ugly        |    120 |\n|  D   |      The Gopher       |    800 |\n+------+-----------------------+--------+\n```\n\n#### Example 2 - Without Border / Footer / Bulk Append\n```go\ndata := [][]string{\n    []string{\"1/1/2014\", \"Domain name\", \"2233\", \"$10.98\"},\n    []string{\"1/1/2014\", \"January Hosting\", \"2233\", \"$54.95\"},\n    []string{\"1/4/2014\", \"February Hosting\", \"2233\", \"$51.00\"},\n    []string{\"1/4/2014\", \"February Extra Bandwidth\", \"2233\", \"$30.00\"},\n}\n\ntable := tablewriter.NewWriter(os.Stdout)\ntable.SetHeader([]string{\"Date\", \"Description\", \"CV2\", \"Amount\"})\ntable.SetFooter([]string{\"\", \"\", \"Total\", \"$146.93\"}) // Add Footer\ntable.EnableBorder(false)                                // Set Border to false\ntable.AppendBulk(data)                                // Add Bulk Data\ntable.Render()\n```\n\n##### Output 2\n```\n\n    DATE   |       DESCRIPTION        |  CV2  | AMOUNT\n-----------+--------------------------+-------+----------\n  1/1/2014 | Domain name              |  2233 | $10.98\n  1/1/2014 | January Hosting          |  2233 | $54.95\n  1/4/2014 | February Hosting         |  2233 | $51.00\n  1/4/2014 | February Extra Bandwidth |  2233 | $30.00\n-----------+--------------------------+-------+----------\n                                        TOTAL | $146 93\n                                      --------+----------\n\n```\n\n\n#### Example 3 - CSV\n```go\ntable, _ := tablewriter.NewCSV(os.Stdout, \"testdata/test_info.csv\", true)\ntable.SetAlignment(tablewriter.ALIGN_LEFT)   // Set Alignment\ntable.Render()\n```\n\n##### Output 3\n```\n+----------+--------------+------+-----+---------+----------------+\n|  FIELD   |     TYPE     | NULL | KEY | DEFAULT |     EXTRA      |\n+----------+--------------+------+-----+---------+----------------+\n| user_id  | smallint(5)  | NO   | PRI | NULL    | auto_increment |\n| username | varchar(10)  | NO   |     | NULL    |                |\n| password | varchar(100) | NO   |     | NULL    |                |\n+----------+--------------+------+-----+---------+----------------+\n```\n\n#### Example 4  - Custom Separator\n```go\ntable, _ := tablewriter.NewCSV(os.Stdout, \"testdata/test.csv\", true)\ntable.SetRowLine(true)         // Enable row line\n\n// Change table lines\ntable.SetCenterSeparator(\"*\")\ntable.SetColumnSeparator(\"╪\")\ntable.SetRowSeparator(\"-\")\n\ntable.SetAlignment(tablewriter.ALIGN_LEFT)\ntable.Render()\n```\n\n##### Output 4\n```\n*------------*-----------*---------*\n╪ FIRST NAME ╪ LAST NAME ╪   SSN   ╪\n*------------*-----------*---------*\n╪ John       ╪ Barry     ╪ 123456  ╪\n*------------*-----------*---------*\n╪ Kathy      ╪ Smith     ╪ 687987  ╪\n*------------*-----------*---------*\n╪ Bob        ╪ McCornick ╪ 3979870 ╪\n*------------*-----------*---------*\n```\n\n#### Example 5 - Markdown Format\n```go\ndata := [][]string{\n\t[]string{\"1/1/2014\", \"Domain name\", \"2233\", \"$10.98\"},\n\t[]string{\"1/1/2014\", \"January Hosting\", \"2233\", \"$54.95\"},\n\t[]string{\"1/4/2014\", \"February Hosting\", \"2233\", \"$51.00\"},\n\t[]string{\"1/4/2014\", \"February Extra Bandwidth\", \"2233\", \"$30.00\"},\n}\n\ntable := tablewriter.NewWriter(os.Stdout)\ntable.SetHeader([]string{\"Date\", \"Description\", \"CV2\", \"Amount\"})\ntable.SetBorders(tablewriter.Border{Left: true, Top: false, Right: true, Bottom: false})\ntable.SetCenterSeparator(\"|\")\ntable.AppendBulk(data) // Add Bulk Data\ntable.Render()\n```\n\n##### Output 5\n```\n|   DATE   |       DESCRIPTION        | CV2  | AMOUNT |\n|----------|--------------------------|------|--------|\n| 1/1/2014 | Domain name              | 2233 | $10.98 |\n| 1/1/2014 | January Hosting          | 2233 | $54.95 |\n| 1/4/2014 | February Hosting         | 2233 | $51.00 |\n| 1/4/2014 | February Extra Bandwidth | 2233 | $30.00 |\n```\n\n#### Example 6  - Identical cells merging\n```go\ndata := [][]string{\n  []string{\"1/1/2014\", \"Domain name\", \"1234\", \"$10.98\"},\n  []string{\"1/1/2014\", \"January Hosting\", \"2345\", \"$54.95\"},\n  []string{\"1/4/2014\", \"February Hosting\", \"3456\", \"$51.00\"},\n  []string{\"1/4/2014\", \"February Extra Bandwidth\", \"4567\", \"$30.00\"},\n}\n\ntable := tablewriter.NewWriter(os.Stdout)\ntable.SetHeader([]string{\"Date\", \"Description\", \"CV2\", \"Amount\"})\ntable.SetFooter([]string{\"\", \"\", \"Total\", \"$146.93\"})\ntable.SetAutoMergeCells(true)\ntable.SetRowLine(true)\ntable.AppendBulk(data)\ntable.Render()\n```\n\n##### Output 6\n```\n+----------+--------------------------+-------+---------+\n|   DATE   |       DESCRIPTION        |  CV2  | AMOUNT  |\n+----------+--------------------------+-------+---------+\n| 1/1/2014 | Domain name              |  1234 | $10.98  |\n+          +--------------------------+-------+---------+\n|          | January Hosting          |  2345 | $54.95  |\n+----------+--------------------------+-------+---------+\n| 1/4/2014 | February Hosting         |  3456 | $51.00  |\n+          +--------------------------+-------+---------+\n|          | February Extra Bandwidth |  4567 | $30.00  |\n+----------+--------------------------+-------+---------+\n|                                       TOTAL | $146 93 |\n+----------+--------------------------+-------+---------+\n```\n\n#### Example 7  - Identical cells merging (specify the column index to merge)\n```go\ndata := [][]string{\n  []string{\"1/1/2014\", \"Domain name\", \"1234\", \"$10.98\"},\n  []string{\"1/1/2014\", \"January Hosting\", \"1234\", \"$10.98\"},\n  []string{\"1/4/2014\", \"February Hosting\", \"3456\", \"$51.00\"},\n  []string{\"1/4/2014\", \"February Extra Bandwidth\", \"4567\", \"$30.00\"},\n}\n\ntable := tablewriter.NewWriter(os.Stdout)\ntable.SetHeader([]string{\"Date\", \"Description\", \"CV2\", \"Amount\"})\ntable.SetFooter([]string{\"\", \"\", \"Total\", \"$146.93\"})\ntable.SetAutoMergeCellsByColumnIndex([]int{2, 3})\ntable.SetRowLine(true)\ntable.AppendBulk(data)\ntable.Render()\n```\n\n##### Output 7\n```\n+----------+--------------------------+-------+---------+\n|   DATE   |       DESCRIPTION        |  CV2  | AMOUNT  |\n+----------+--------------------------+-------+---------+\n| 1/1/2014 | Domain name              |  1234 | $10.98  |\n+----------+--------------------------+       +         +\n| 1/1/2014 | January Hosting          |       |         |\n+----------+--------------------------+-------+---------+\n| 1/4/2014 | February Hosting         |  3456 | $51.00  |\n+----------+--------------------------+-------+---------+\n| 1/4/2014 | February Extra Bandwidth |  4567 | $30.00  |\n+----------+--------------------------+-------+---------+\n|                                       TOTAL | $146.93 |\n+----------+--------------------------+-------+---------+\n```\n\n\n#### Table with color\n```go\ndata := [][]string{\n\t[]string{\"1/1/2014\", \"Domain name\", \"2233\", \"$10.98\"},\n\t[]string{\"1/1/2014\", \"January Hosting\", \"2233\", \"$54.95\"},\n\t[]string{\"1/4/2014\", \"February Hosting\", \"2233\", \"$51.00\"},\n\t[]string{\"1/4/2014\", \"February Extra Bandwidth\", \"2233\", \"$30.00\"},\n}\n\ntable := tablewriter.NewWriter(os.Stdout)\ntable.SetHeader([]string{\"Date\", \"Description\", \"CV2\", \"Amount\"})\ntable.SetFooter([]string{\"\", \"\", \"Total\", \"$146.93\"}) // Add Footer\ntable.EnableBorder(false)                                // Set Border to false\n\ntable.SetHeaderColor(tablewriter.Colors{tablewriter.Bold, tablewriter.BgGreenColor},\n\ttablewriter.Colors{tablewriter.FgHiRedColor, tablewriter.Bold, tablewriter.BgBlackColor},\n\ttablewriter.Colors{tablewriter.BgRedColor, tablewriter.FgWhiteColor},\n\ttablewriter.Colors{tablewriter.BgCyanColor, tablewriter.FgWhiteColor})\n\ntable.SetColumnColor(tablewriter.Colors{tablewriter.Bold, tablewriter.FgHiBlackColor},\n\ttablewriter.Colors{tablewriter.Bold, tablewriter.FgHiRedColor},\n\ttablewriter.Colors{tablewriter.Bold, tablewriter.FgHiBlackColor},\n\ttablewriter.Colors{tablewriter.Bold, tablewriter.FgBlackColor})\n\ntable.SetFooterColor(tablewriter.Colors{}, tablewriter.Colors{},\n\ttablewriter.Colors{tablewriter.Bold},\n\ttablewriter.Colors{tablewriter.FgHiRedColor})\n\ntable.AppendBulk(data)\ntable.Render()\n```\n\n#### Table with color Output\n![Table with Color](https://cloud.githubusercontent.com/assets/6460392/21101956/bbc7b356-c0a1-11e6-9f36-dba694746efc.png)\n\n#### Example - 8 Table Cells with Color\n\nIndividual Cell Colors from `func Rich` take precedence over Column Colors\n\n```go\ndata := [][]string{\n\t[]string{\"Test1Merge\", \"HelloCol2 - 1\", \"HelloCol3 - 1\", \"HelloCol4 - 1\"},\n\t[]string{\"Test1Merge\", \"HelloCol2 - 2\", \"HelloCol3 - 2\", \"HelloCol4 - 2\"},\n\t[]string{\"Test1Merge\", \"HelloCol2 - 3\", \"HelloCol3 - 3\", \"HelloCol4 - 3\"},\n\t[]string{\"Test2Merge\", \"HelloCol2 - 4\", \"HelloCol3 - 4\", \"HelloCol4 - 4\"},\n\t[]string{\"Test2Merge\", \"HelloCol2 - 5\", \"HelloCol3 - 5\", \"HelloCol4 - 5\"},\n\t[]string{\"Test2Merge\", \"HelloCol2 - 6\", \"HelloCol3 - 6\", \"HelloCol4 - 6\"},\n\t[]string{\"Test2Merge\", \"HelloCol2 - 7\", \"HelloCol3 - 7\", \"HelloCol4 - 7\"},\n\t[]string{\"Test3Merge\", \"HelloCol2 - 8\", \"HelloCol3 - 8\", \"HelloCol4 - 8\"},\n\t[]string{\"Test3Merge\", \"HelloCol2 - 9\", \"HelloCol3 - 9\", \"HelloCol4 - 9\"},\n\t[]string{\"Test3Merge\", \"HelloCol2 - 10\", \"HelloCol3 -10\", \"HelloCol4 - 10\"},\n}\n\ntable := tablewriter.NewWriter(os.Stdout)\ntable.SetHeader([]string{\"Col1\", \"Col2\", \"Col3\", \"Col4\"})\ntable.SetFooter([]string{\"\", \"\", \"Footer3\", \"Footer4\"})\ntable.EnableBorder(false)\n\ntable.SetHeaderColor(tablewriter.Colors{tablewriter.Bold, tablewriter.BgGreenColor},\n\ttablewriter.Colors{tablewriter.FgHiRedColor, tablewriter.Bold, tablewriter.BgBlackColor},\n\ttablewriter.Colors{tablewriter.BgRedColor, tablewriter.FgWhiteColor},\n\ttablewriter.Colors{tablewriter.BgCyanColor, tablewriter.FgWhiteColor})\n\ntable.SetColumnColor(tablewriter.Colors{tablewriter.Bold, tablewriter.FgHiBlackColor},\n\ttablewriter.Colors{tablewriter.Bold, tablewriter.FgHiRedColor},\n\ttablewriter.Colors{tablewriter.Bold, tablewriter.FgHiBlackColor},\n\ttablewriter.Colors{tablewriter.Bold, tablewriter.FgBlackColor})\n\ntable.SetFooterColor(tablewriter.Colors{}, tablewriter.Colors{},\n\ttablewriter.Colors{tablewriter.Bold},\n\ttablewriter.Colors{tablewriter.FgHiRedColor})\n\ncolorData1 := []string{\"TestCOLOR1Merge\", \"HelloCol2 - COLOR1\", \"HelloCol3 - COLOR1\", \"HelloCol4 - COLOR1\"}\ncolorData2 := []string{\"TestCOLOR2Merge\", \"HelloCol2 - COLOR2\", \"HelloCol3 - COLOR2\", \"HelloCol4 - COLOR2\"}\n\nfor i, row := range data {\n\tif i == 4 {\n\t\ttable.Rich(colorData1, []tablewriter.Colors{tablewriter.Colors{}, tablewriter.Colors{tablewriter.Normal, tablewriter.FgCyanColor}, tablewriter.Colors{tablewriter.Bold, tablewriter.FgWhiteColor}, tablewriter.Colors{}})\n\t\ttable.Rich(colorData2, []tablewriter.Colors{tablewriter.Colors{tablewriter.Normal, tablewriter.FgMagentaColor}, tablewriter.Colors{}, tablewriter.Colors{tablewriter.Bold, tablewriter.BgRedColor}, tablewriter.Colors{tablewriter.FgHiGreenColor, tablewriter.Italic, tablewriter.BgHiCyanColor}})\n\t}\n\ttable.Append(row)\n}\n\ntable.SetAutoMergeCells(true)\ntable.Render()\n\n```\n\n##### Table cells with color Output\n![Table cells with Color](https://user-images.githubusercontent.com/9064687/63969376-bcd88d80-ca6f-11e9-9466-c3d954700b25.png)\n\n#### Example 9 - Set table caption\n```go\ndata := [][]string{\n    []string{\"A\", \"The Good\", \"500\"},\n    []string{\"B\", \"The Very very Bad Man\", \"288\"},\n    []string{\"C\", \"The Ugly\", \"120\"},\n    []string{\"D\", \"The Gopher\", \"800\"},\n}\n\ntable := tablewriter.NewWriter(os.Stdout)\ntable.SetHeader([]string{\"Name\", \"Sign\", \"Rating\"})\ntable.SetCaption(true, \"Movie ratings.\")\n\nfor _, v := range data {\n    table.Append(v)\n}\ntable.Render() // Send output\n```\n\nNote: Caption text will wrap with total width of rendered table.\n\n##### Output 9\n```\n+------+-----------------------+--------+\n| NAME |         SIGN          | RATING |\n+------+-----------------------+--------+\n|  A   |       The Good        |    500 |\n|  B   | The Very very Bad Man |    288 |\n|  C   |       The Ugly        |    120 |\n|  D   |      The Gopher       |    800 |\n+------+-----------------------+--------+\nMovie ratings.\n```\n\n#### Example 10 - Set NoWhiteSpace and TablePadding option\n```go\ndata := [][]string{\n    {\"node1.example.com\", \"Ready\", \"compute\", \"1.11\"},\n    {\"node2.example.com\", \"Ready\", \"compute\", \"1.11\"},\n    {\"node3.example.com\", \"Ready\", \"compute\", \"1.11\"},\n    {\"node4.example.com\", \"NotReady\", \"compute\", \"1.11\"},\n}\n\ntable := tablewriter.NewWriter(os.Stdout)\ntable.SetHeader([]string{\"Name\", \"Status\", \"Role\", \"Version\"})\ntable.SetAutoWrapText(false)\ntable.SetAutoFormatHeaders(true)\ntable.SetHeaderAlignment(tablewriter.ALIGN_LEFT)\ntable.SetAlignment(tablewriter.ALIGN_LEFT)\ntable.SetCenterSeparator(\"\")\ntable.SetColumnSeparator(\"\")\ntable.SetRowSeparator(\"\")\ntable.SetHeaderLine(false)\ntable.EnableBorder(false)\ntable.SetTablePadding(\"\\t\") // pad with tabs\ntable.SetNoWhiteSpace(true)\ntable.AppendBulk(data) // Add Bulk Data\ntable.Render()\n```\n\n##### Output 10\n```\nNAME             \tSTATUS  \tROLE   \tVERSION \nnode1.example.com\tReady   \tcompute\t1.11   \t\nnode2.example.com\tReady   \tcompute\t1.11   \t\nnode3.example.com\tReady   \tcompute\t1.11   \t\nnode4.example.com\tNotReady\tcompute\t1.11   \t\n```\n\n#### Render table into a string\n\nInstead of rendering the table to `io.Stdout` you can also render it into a string. Go 1.10 introduced the `strings.Builder` type which implements the `io.Writer` interface and can therefore be used for this task. Example:\n\n```go\npackage main\n\nimport (\n    \"strings\"\n    \"fmt\"\n\n    \"github.com/olekukonko/tablewriter\"\n)\n\nfunc main() {\n    tableString := &strings.Builder{}\n    table := tablewriter.NewWriter(tableString)\n\n    /*\n     * Code to fill the table\n     */\n\n    table.Render()\n\n    fmt.Println(tableString.String())\n}\n```\n\n#### TODO\n- ~~Import Directly from CSV~~  - `done`\n- ~~Support for `SetFooter`~~  - `done`\n- ~~Support for `SetBorder`~~  - `done`\n- ~~Support table with uneven rows~~ - `done`\n- ~~Support custom alignment~~\n- General Improvement & Optimisation\n- `NewHTML` Parse table from HTML\n"
        },
        {
          "name": "csv.go",
          "type": "blob",
          "size": 1.3193359375,
          "content": "// Copyright 2014 Oleku Konko All rights reserved.\n// Use of this source code is governed by a MIT\n// license that can be found in the LICENSE file.\n\n// This module is a Table Writer  API for the Go Programming Language.\n// The protocols were written in pure Go and works on windows and unix systems\n\npackage tablewriter\n\nimport (\n\t\"encoding/csv\"\n\t\"io\"\n\t\"os\"\n)\n\n// NewCSV Start A new table by importing from a CSV file\n// Takes io.Writer and csv File name\nfunc NewCSV(writer io.Writer, fileName string, hasHeader bool) (*Table, error) {\n\tfile, err := os.Open(fileName)\n\tif err != nil {\n\t\treturn &Table{}, err\n\t}\n\tdefer file.Close()\n\tcsvReader := csv.NewReader(file)\n\tt, err := NewCSVReader(writer, csvReader, hasHeader)\n\treturn t, err\n}\n\n// NewCSVReader Start a New Table Writer with csv.Reader\n// This enables customisation such as reader.Comma = ';'\n// See http://golang.org/src/pkg/encoding/csv/reader.go?s=3213:3671#L94\nfunc NewCSVReader(writer io.Writer, csvReader *csv.Reader, hasHeader bool) (*Table, error) {\n\tt := NewWriter(writer)\n\tif hasHeader {\n\t\t// Read the first row\n\t\theaders, err := csvReader.Read()\n\t\tif err != nil {\n\t\t\treturn &Table{}, err\n\t\t}\n\t\tt.SetHeader(headers)\n\t}\n\tfor {\n\t\trecord, err := csvReader.Read()\n\t\tif err == io.EOF {\n\t\t\tbreak\n\t\t} else if err != nil {\n\t\t\treturn &Table{}, err\n\t\t}\n\t\tt.Append(record)\n\t}\n\treturn t, nil\n}\n"
        },
        {
          "name": "csv2table",
          "type": "tree",
          "content": null
        },
        {
          "name": "go.mod",
          "type": "blob",
          "size": 0.0947265625,
          "content": "module github.com/olekukonko/tablewriter\n\ngo 1.12\n\nrequire github.com/mattn/go-runewidth v0.0.10\n"
        },
        {
          "name": "go.sum",
          "type": "blob",
          "size": 0.333984375,
          "content": "github.com/mattn/go-runewidth v0.0.10 h1:CoZ3S2P7pvtP45xOtBw+/mDL2z0RKI576gSkzRRpdGg=\ngithub.com/mattn/go-runewidth v0.0.10/go.mod h1:RAqKPSqVFrSLVXbA8x7dzmKdmGzieGRCM46jaSJTDAk=\ngithub.com/rivo/uniseg v0.1.0 h1:+2KBaVoUmb9XzDsrx/Ct0W/EYOSFf/nWTauy++DprtY=\ngithub.com/rivo/uniseg v0.1.0/go.mod h1:J6wj4VEh+S6ZtnVlnTBMWIodfgj8LQOQFoIToxlJtxc=\n"
        },
        {
          "name": "table.go",
          "type": "blob",
          "size": 26.0986328125,
          "content": "// Copyright 2014 Oleku Konko All rights reserved.\n// Use of this source code is governed by a MIT\n// license that can be found in the LICENSE file.\n\n// This module is a Table Writer  API for the Go Programming Language.\n// The protocols were written in pure Go and works on windows and unix systems\n\n// Package tablewriter Create & Generate text based table\npackage tablewriter\n\nimport (\n\t\"bytes\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"reflect\"\n\t\"regexp\"\n\t\"strings\"\n)\n\nconst (\n\tMAX_ROW_WIDTH = 30\n)\n\nconst (\n\tCENTER  = \"+\"\n\tROW     = \"-\"\n\tCOLUMN  = \"|\"\n\tSPACE   = \" \"\n\tNEWLINE = \"\\n\"\n)\n\nconst (\n\tALIGN_DEFAULT = iota\n\tALIGN_CENTER\n\tALIGN_RIGHT\n\tALIGN_LEFT\n)\n\nvar (\n\tdecimal = regexp.MustCompile(`^-?(?:\\d{1,3}(?:,\\d{3})*|\\d+)(?:\\.\\d+)?$`)\n\tpercent = regexp.MustCompile(`^-?\\d+\\.?\\d*$%$`)\n)\n\ntype Border struct {\n\tLeft   bool\n\tRight  bool\n\tTop    bool\n\tBottom bool\n}\n\ntype symbolID int\n\n// Symbol ID constants which indicates the compass points, in order NESW, where\n// a given symbol has connections to. The order here matches the order of box\n// drawing unicode symbols.\nconst (\n\tsymEW symbolID = iota\n\tsymNS\n\tsymES\n\tsymSW\n\tsymNE\n\tsymNW\n\tsymNES\n\tsymNSW\n\tsymESW\n\tsymNEW\n\tsymNESW\n)\n\ntype Table struct {\n\tout                     io.Writer\n\trows                    [][]string\n\tlines                   [][][]string\n\tcs                      map[int]int\n\trs                      map[int]int\n\theaders                 [][]string\n\tfooters                 [][]string\n\tcaption                 bool\n\tcaptionText             string\n\tautoFmt                 bool\n\tautoWrap                bool\n\treflowText              bool\n\tmW                      int\n\tsyms                    []string\n\tpCenter                 string\n\tpRow                    string\n\tpColumn                 string\n\ttColumn                 int\n\ttRow                    int\n\thAlign                  int\n\tfAlign                  int\n\talign                   int\n\tnewLine                 string\n\trowLine                 bool\n\tautoMergeCells          bool\n\tcolumnsToAutoMergeCells map[int]bool\n\tnoWhiteSpace            bool\n\ttablePadding            string\n\thdrLine                 bool\n\tborders                 Border\n\tcolSize                 int\n\theaderParams            []string\n\tcolumnsParams           []string\n\tfooterParams            []string\n\tcolumnsAlign            []int\n}\n\n// NewWriter Start New Table\n// Take io.Writer Directly\nfunc NewWriter(writer io.Writer) *Table {\n\tt := &Table{\n\t\tout:           writer,\n\t\trows:          [][]string{},\n\t\tlines:         [][][]string{},\n\t\tcs:            make(map[int]int),\n\t\trs:            make(map[int]int),\n\t\theaders:       [][]string{},\n\t\tfooters:       [][]string{},\n\t\tcaption:       false,\n\t\tcaptionText:   \"Table caption.\",\n\t\tautoFmt:       true,\n\t\tautoWrap:      true,\n\t\treflowText:    true,\n\t\tmW:            MAX_ROW_WIDTH,\n\t\tsyms:          simpleSyms(CENTER, ROW, COLUMN),\n\t\tpCenter:       CENTER,\n\t\tpRow:          ROW,\n\t\tpColumn:       COLUMN,\n\t\ttColumn:       -1,\n\t\ttRow:          -1,\n\t\thAlign:        ALIGN_DEFAULT,\n\t\tfAlign:        ALIGN_DEFAULT,\n\t\talign:         ALIGN_DEFAULT,\n\t\tnewLine:       NEWLINE,\n\t\trowLine:       false,\n\t\thdrLine:       true,\n\t\tborders:       Border{Left: true, Right: true, Bottom: true, Top: true},\n\t\tcolSize:       -1,\n\t\theaderParams:  []string{},\n\t\tcolumnsParams: []string{},\n\t\tfooterParams:  []string{},\n\t\tcolumnsAlign:  []int{}}\n\treturn t\n}\n\n// Render table output\nfunc (t *Table) Render() {\n\tif t.borders.Top {\n\t\tt.printLine(true, false)\n\t}\n\tt.printHeading()\n\tif t.autoMergeCells {\n\t\tt.printRowsMergeCells()\n\t} else {\n\t\tt.printRows()\n\t}\n\tif !t.rowLine && t.borders.Bottom {\n\t\tt.printLine(false, len(t.footers) == 0)\n\t}\n\tt.printFooter()\n\n\tif t.caption {\n\t\tt.printCaption()\n\t}\n}\n\nconst (\n\theaderRowIdx = -1\n\tfooterRowIdx = -2\n)\n\n// SetHeader Set table header\nfunc (t *Table) SetHeader(keys []string) {\n\tt.colSize = len(keys)\n\tfor i, v := range keys {\n\t\tlines := t.parseDimension(v, i, headerRowIdx)\n\t\tt.headers = append(t.headers, lines)\n\t}\n}\n\n// SetFooter Set table Footer\nfunc (t *Table) SetFooter(keys []string) {\n\t//t.colSize = len(keys)\n\tfor i, v := range keys {\n\t\tlines := t.parseDimension(v, i, footerRowIdx)\n\t\tt.footers = append(t.footers, lines)\n\t}\n}\n\n// SetCaption Set table Caption\nfunc (t *Table) SetCaption(caption bool, captionText ...string) {\n\tt.caption = caption\n\tif len(captionText) == 1 {\n\t\tt.captionText = captionText[0]\n\t}\n}\n\n// SetAutoFormatHeaders Turn header autoformatting on/off. Default is on (true).\nfunc (t *Table) SetAutoFormatHeaders(auto bool) {\n\tt.autoFmt = auto\n}\n\n// SetAutoWrapText Turn automatic multiline text adjustment on/off. Default is on (true).\nfunc (t *Table) SetAutoWrapText(auto bool) {\n\tt.autoWrap = auto\n}\n\n// SetReflowDuringAutoWrap Turn automatic reflowing of multiline text when rewrapping. Default is on (true).\nfunc (t *Table) SetReflowDuringAutoWrap(auto bool) {\n\tt.reflowText = auto\n}\n\n// SetColWidth Set the Default column width\nfunc (t *Table) SetColWidth(width int) {\n\tt.mW = width\n}\n\n// SetColMinWidth Set the minimal width for a column\nfunc (t *Table) SetColMinWidth(column int, width int) {\n\tt.cs[column] = width\n}\n\n// SetColumnSeparator Set the Column Separator\nfunc (t *Table) SetColumnSeparator(sep string) {\n\tt.pColumn = sep\n\tt.syms = simpleSyms(t.pCenter, t.pRow, t.pColumn)\n}\n\n// SetRowSeparator Set the Row Separator\nfunc (t *Table) SetRowSeparator(sep string) {\n\tt.pRow = sep\n\tt.syms = simpleSyms(t.pCenter, t.pRow, t.pColumn)\n}\n\n// SetCenterSeparator Set the center Separator\nfunc (t *Table) SetCenterSeparator(sep string) {\n\tt.pCenter = sep\n\tt.syms = simpleSyms(t.pCenter, t.pRow, t.pColumn)\n}\n\n// SetHeaderAlignment Set Header Alignment\nfunc (t *Table) SetHeaderAlignment(hAlign int) {\n\tt.hAlign = hAlign\n}\n\n// SetFooterAlignment Set Footer Alignment\nfunc (t *Table) SetFooterAlignment(fAlign int) {\n\tt.fAlign = fAlign\n}\n\n// SetAlignment Set Table Alignment\nfunc (t *Table) SetAlignment(align int) {\n\tt.align = align\n}\n\n// SetNoWhiteSpace Set No White Space\nfunc (t *Table) SetNoWhiteSpace(allow bool) {\n\tt.noWhiteSpace = allow\n}\n\n// SetTablePadding Set Table Padding\nfunc (t *Table) SetTablePadding(padding string) {\n\tt.tablePadding = padding\n}\n\n// SetColumnAlignment Set Column Alignment\nfunc (t *Table) SetColumnAlignment(keys []int) {\n\tfor _, v := range keys {\n\t\tswitch v {\n\t\tcase ALIGN_CENTER:\n\t\t\tbreak\n\t\tcase ALIGN_LEFT:\n\t\t\tbreak\n\t\tcase ALIGN_RIGHT:\n\t\t\tbreak\n\t\tdefault:\n\t\t\tv = ALIGN_DEFAULT\n\t\t}\n\t\tt.columnsAlign = append(t.columnsAlign, v)\n\t}\n}\n\n// SetNewLine Set New Line\nfunc (t *Table) SetNewLine(nl string) {\n\tt.newLine = nl\n}\n\n// SetHeaderLine Set Header Line\n// This would enable / disable a line after the header\nfunc (t *Table) SetHeaderLine(line bool) {\n\tt.hdrLine = line\n}\n\n// SetRowLine Set Row Line\n// This would enable / disable a line on each row of the table\nfunc (t *Table) SetRowLine(line bool) {\n\tt.rowLine = line\n}\n\n// SetAutoMergeCells Set Auto Merge Cells\n// This would enable / disable the merge of cells with identical values\nfunc (t *Table) SetAutoMergeCells(auto bool) {\n\tt.autoMergeCells = auto\n}\n\n// SetAutoMergeCellsByColumnIndex Set Auto Merge Cells By Column Index\n// This would enable / disable the merge of cells with identical values for specific columns\n// If cols is empty, it is the same as `SetAutoMergeCells(true)`.\nfunc (t *Table) SetAutoMergeCellsByColumnIndex(cols []int) {\n\tt.autoMergeCells = true\n\tif len(cols) > 0 {\n\t\tm := make(map[int]bool)\n\t\tfor _, col := range cols {\n\t\t\tm[col] = true\n\t\t}\n\t\tt.columnsToAutoMergeCells = m\n\t}\n}\n\n// SetBorder Set Table Border\n// This would enable / disable line around the table\n// Deprecated: use EnableBorder\nfunc (t *Table) SetBorder(border bool) {\n\tt.EnableBorder(border)\n}\n\n// EnableBorder Set Table Border\n// This would enable / disable line around the table\nfunc (t *Table) EnableBorder(border bool) {\n\tt.SetBorders(Border{border, border, border, border})\n}\n\n// SetBorders SetBorder Set Custom Table Border\nfunc (t *Table) SetBorders(border Border) {\n\tt.borders = border\n}\n\n// SetStructs sets header and rows from slice of struct.\n// If something that is not a slice is passed, error will be returned.\n// The tag specified by \"tablewriter\" for the struct becomes the header.\n// If not specified or empty, the field name will be used.\n// The field of the first element of the slice is used as the header.\n// If the element implements fmt.Stringer, the result will be used.\n// And the slice contains nil, it will be skipped without rendering.\nfunc (t *Table) SetStructs(v interface{}) error {\n\tif v == nil {\n\t\treturn errors.New(\"nil value\")\n\t}\n\tvt := reflect.TypeOf(v)\n\tvv := reflect.ValueOf(v)\n\tswitch vt.Kind() {\n\tcase reflect.Slice, reflect.Array:\n\t\tif vv.Len() < 1 {\n\t\t\treturn errors.New(\"empty value\")\n\t\t}\n\n\t\t// check first element to set header\n\t\tfirst := vv.Index(0)\n\t\te := first.Type()\n\t\tswitch e.Kind() {\n\t\tcase reflect.Struct:\n\t\t\t// OK\n\t\tcase reflect.Ptr:\n\t\t\tif first.IsNil() {\n\t\t\t\treturn errors.New(\"the first element is nil\")\n\t\t\t}\n\t\t\te = first.Elem().Type()\n\t\t\tif e.Kind() != reflect.Struct {\n\t\t\t\treturn fmt.Errorf(\"invalid kind %s\", e.Kind())\n\t\t\t}\n\t\tdefault:\n\t\t\treturn fmt.Errorf(\"invalid kind %s\", e.Kind())\n\t\t}\n\t\tn := e.NumField()\n\t\theaders := make([]string, n)\n\t\tfor i := 0; i < n; i++ {\n\t\t\tf := e.Field(i)\n\t\t\theader := f.Tag.Get(\"tablewriter\")\n\t\t\tif header == \"\" {\n\t\t\t\theader = f.Name\n\t\t\t}\n\t\t\theaders[i] = header\n\t\t}\n\t\tt.SetHeader(headers)\n\n\t\tfor i := 0; i < vv.Len(); i++ {\n\t\t\titem := reflect.Indirect(vv.Index(i))\n\t\t\titemType := reflect.TypeOf(item)\n\t\t\tswitch itemType.Kind() {\n\t\t\tcase reflect.Struct:\n\t\t\t\t// OK\n\t\t\tdefault:\n\t\t\t\treturn fmt.Errorf(\"invalid item type %v\", itemType.Kind())\n\t\t\t}\n\t\t\tif !item.IsValid() {\n\t\t\t\t// skip rendering\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tnf := item.NumField()\n\t\t\tif n != nf {\n\t\t\t\treturn errors.New(\"invalid num of field\")\n\t\t\t}\n\t\t\trows := make([]string, nf)\n\t\t\tfor j := 0; j < nf; j++ {\n\t\t\t\tf := reflect.Indirect(item.Field(j))\n\t\t\t\tif f.Kind() == reflect.Ptr {\n\t\t\t\t\tf = f.Elem()\n\t\t\t\t}\n\t\t\t\tif f.IsValid() {\n\t\t\t\t\tif s, ok := f.Interface().(fmt.Stringer); ok {\n\t\t\t\t\t\trows[j] = s.String()\n\t\t\t\t\t\tcontinue\n\t\t\t\t\t}\n\t\t\t\t\trows[j] = fmt.Sprint(f)\n\t\t\t\t} else {\n\t\t\t\t\trows[j] = \"nil\"\n\t\t\t\t}\n\t\t\t}\n\t\t\tt.Append(rows)\n\t\t}\n\tdefault:\n\t\treturn fmt.Errorf(\"invalid type %T\", v)\n\t}\n\treturn nil\n}\n\n// Append row to table\nfunc (t *Table) Append(row []string) {\n\trowSize := len(t.headers)\n\tif rowSize > t.colSize {\n\t\tt.colSize = rowSize\n\t}\n\n\tn := len(t.lines)\n\tline := [][]string{}\n\tfor i, v := range row {\n\n\t\t// Detect string  width\n\t\t// Detect String height\n\t\t// Break strings into words\n\t\tout := t.parseDimension(v, i, n)\n\n\t\t// Append broken words\n\t\tline = append(line, out)\n\t}\n\tt.lines = append(t.lines, line)\n}\n\n// Rich Append row to table with color attributes\nfunc (t *Table) Rich(row []string, colors []Colors) {\n\trowSize := len(t.headers)\n\tif rowSize > t.colSize {\n\t\tt.colSize = rowSize\n\t}\n\n\tn := len(t.lines)\n\tline := [][]string{}\n\tfor i, v := range row {\n\n\t\t// Detect string  width\n\t\t// Detect String height\n\t\t// Break strings into words\n\t\tout := t.parseDimension(v, i, n)\n\n\t\tif len(colors) > i {\n\t\t\tcolor := colors[i]\n\t\t\tout[0] = format(out[0], color)\n\t\t}\n\n\t\t// Append broken words\n\t\tline = append(line, out)\n\t}\n\tt.lines = append(t.lines, line)\n}\n\n// AppendBulk Allow Support for Bulk Append\n// Eliminates repeated for loops\nfunc (t *Table) AppendBulk(rows [][]string) {\n\tfor _, row := range rows {\n\t\tt.Append(row)\n\t}\n}\n\n// NumLines to get the number of lines\nfunc (t *Table) NumLines() int {\n\treturn len(t.lines)\n}\n\n// ClearRows Clear rows\nfunc (t *Table) ClearRows() {\n\tt.lines = [][][]string{}\n}\n\n// ClearFooter Clear footer\nfunc (t *Table) ClearFooter() {\n\tt.footers = [][]string{}\n}\n\n// Center based on position and border.\nfunc (t *Table) center(i int, isFirstRow, isLastRow bool) string {\n\tif i == -1 {\n\t\tif !t.borders.Left {\n\t\t\treturn t.syms[symEW]\n\t\t}\n\t\tif isFirstRow {\n\t\t\treturn t.syms[symES]\n\t\t}\n\t\tif isLastRow {\n\t\t\treturn t.syms[symNE]\n\t\t}\n\t\treturn t.syms[symNES]\n\t}\n\n\tif i == len(t.cs)-1 {\n\t\tif !t.borders.Right {\n\t\t\treturn t.syms[symEW]\n\t\t}\n\t\tif isFirstRow {\n\t\t\treturn t.syms[symSW]\n\t\t}\n\t\tif isLastRow {\n\t\t\treturn t.syms[symNW]\n\t\t}\n\t\treturn t.syms[symNSW]\n\t}\n\n\tif isFirstRow {\n\t\treturn t.syms[symESW]\n\t}\n\tif isLastRow {\n\t\treturn t.syms[symNEW]\n\t}\n\treturn t.syms[symNESW]\n}\n\n// Print line based on row width\nfunc (t *Table) printLine(isFirst, isLast bool) {\n\tfmt.Fprint(t.out, t.center(-1, isFirst, isLast))\n\tfor i := 0; i < len(t.cs); i++ {\n\t\tv := t.cs[i]\n\t\tfmt.Fprintf(t.out, \"%s%s%s%s\",\n\t\t\tt.syms[symEW],\n\t\t\tstrings.Repeat(t.syms[symEW], v),\n\t\t\tt.syms[symEW],\n\t\t\tt.center(i, isFirst, isLast))\n\t}\n\tfmt.Fprint(t.out, t.newLine)\n}\n\n// Print line based on row width with our without cell separator\nfunc (t *Table) printLineOptionalCellSeparators(nl bool, displayCellSeparator []bool) {\n\tfmt.Fprint(t.out, t.syms[symNES])\n\tcenterSym := symNESW\n\tfor i := 0; i < len(t.cs); i++ {\n\t\tv := t.cs[i]\n\t\tif i == len(t.cs)-1 {\n\t\t\tcenterSym = symNSW\n\t\t}\n\t\tif i > len(displayCellSeparator) || displayCellSeparator[i] {\n\t\t\t// Display the cell separator\n\t\t\tfmt.Fprintf(t.out, \"%s%s%s%s\",\n\t\t\t\tt.syms[symEW],\n\t\t\t\tstrings.Repeat(string(t.syms[symEW]), v),\n\t\t\t\tt.syms[symEW],\n\t\t\t\tt.syms[centerSym])\n\t\t} else {\n\t\t\t// Don't display the cell separator for this cell\n\t\t\tfmt.Fprintf(t.out, \"%s%s\",\n\t\t\t\tstrings.Repeat(\" \", v+2),\n\t\t\t\tt.syms[centerSym])\n\t\t}\n\t}\n\tif nl {\n\t\tfmt.Fprint(t.out, t.newLine)\n\t}\n}\n\n// Return the PadRight function if align is left, PadLeft if align is right,\n// and Pad by default\nfunc pad(align int) func(string, string, int) string {\n\tpadFunc := Pad\n\tswitch align {\n\tcase ALIGN_LEFT:\n\t\tpadFunc = PadRight\n\tcase ALIGN_RIGHT:\n\t\tpadFunc = PadLeft\n\t}\n\treturn padFunc\n}\n\n// Print heading information\nfunc (t *Table) printHeading() {\n\t// Check if headers is available\n\tif len(t.headers) < 1 {\n\t\treturn\n\t}\n\n\t// Identify last column\n\tend := len(t.cs) - 1\n\n\t// Get pad function\n\tpadFunc := pad(t.hAlign)\n\n\t// Checking for ANSI escape sequences for header\n\tis_esc_seq := false\n\tif len(t.headerParams) > 0 {\n\t\tis_esc_seq = true\n\t}\n\n\t// Maximum height.\n\tmax := t.rs[headerRowIdx]\n\n\t// Print Heading\n\tfor x := 0; x < max; x++ {\n\t\t// Check if border is set\n\t\t// Replace with space if not set\n\t\tif !t.noWhiteSpace {\n\t\t\tfmt.Fprint(t.out, ConditionString(t.borders.Left, t.syms[symNS], SPACE))\n\t\t}\n\n\t\tfor y := 0; y <= end; y++ {\n\t\t\tv := t.cs[y]\n\t\t\th := \"\"\n\n\t\t\tif y < len(t.headers) && x < len(t.headers[y]) {\n\t\t\t\th = t.headers[y][x]\n\t\t\t}\n\t\t\tif t.autoFmt {\n\t\t\t\th = Title(h)\n\t\t\t}\n\t\t\tpad := ConditionString((y == end && !t.borders.Left), SPACE, t.syms[symNS])\n\t\t\tif t.noWhiteSpace {\n\t\t\t\tpad = ConditionString((y == end && !t.borders.Left), SPACE, t.tablePadding)\n\t\t\t}\n\t\t\tif is_esc_seq {\n\t\t\t\tif !t.noWhiteSpace {\n\t\t\t\t\tfmt.Fprintf(t.out, \" %s %s\",\n\t\t\t\t\t\tformat(padFunc(h, SPACE, v),\n\t\t\t\t\t\t\tt.headerParams[y]), pad)\n\t\t\t\t} else {\n\t\t\t\t\tfmt.Fprintf(t.out, \"%s %s\",\n\t\t\t\t\t\tformat(padFunc(h, SPACE, v),\n\t\t\t\t\t\t\tt.headerParams[y]), pad)\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif !t.noWhiteSpace {\n\t\t\t\t\tfmt.Fprintf(t.out, \" %s %s\",\n\t\t\t\t\t\tpadFunc(h, SPACE, v),\n\t\t\t\t\t\tpad)\n\t\t\t\t} else {\n\t\t\t\t\t// the spaces between breaks the kube formatting\n\t\t\t\t\tfmt.Fprintf(t.out, \"%s%s\",\n\t\t\t\t\t\tpadFunc(h, SPACE, v),\n\t\t\t\t\t\tpad)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// Next line\n\t\tfmt.Fprint(t.out, t.newLine)\n\t}\n\tif t.hdrLine {\n\t\tt.printLine(false, false)\n\t}\n}\n\n// Print heading information\nfunc (t *Table) printFooter() {\n\t// Check if headers is available\n\tif len(t.footers) < 1 {\n\t\treturn\n\t}\n\n\t// Only print line if border is not set\n\tif !t.borders.Bottom {\n\t\tt.printLine(false, false)\n\t}\n\n\t// Identify last column\n\tend := len(t.cs) - 1\n\n\t// Get pad function\n\tpadFunc := pad(t.fAlign)\n\n\t// Checking for ANSI escape sequences for header\n\tis_esc_seq := false\n\tif len(t.footerParams) > 0 {\n\t\tis_esc_seq = true\n\t}\n\n\t// Maximum height.\n\tmax := t.rs[footerRowIdx]\n\n\t// Print Footer\n\tfor i := 0; i < (len(t.cs) - len(t.footers)); i++ {\n\t\tlines := t.parseDimension(\" \", len(t.footers), footerRowIdx)\n\t\tt.footers = append(t.footers, lines)\n\t}\n\terasePad := make([]bool, len(t.footers))\n\tfor x := 0; x < max; x++ {\n\t\t// Check if border is set\n\t\t// Replace with space if not set\n\t\tfmt.Fprint(t.out, ConditionString(t.borders.Bottom, t.syms[symNS], SPACE))\n\n\t\tfor y := 0; y <= end; y++ {\n\t\t\tv := t.cs[y]\n\t\t\tf := \"\"\n\t\t\tif y < len(t.footers) && x < len(t.footers[y]) {\n\t\t\t\tf = t.footers[y][x]\n\t\t\t}\n\t\t\tif t.autoFmt {\n\t\t\t\tf = Title(f)\n\t\t\t}\n\t\t\tpad := ConditionString((y == end && !t.borders.Top), SPACE, t.syms[symNS])\n\n\t\t\tif erasePad[y] || (x == 0 && len(f) == 0) {\n\t\t\t\tpad = SPACE\n\t\t\t\terasePad[y] = true\n\t\t\t}\n\n\t\t\tif is_esc_seq {\n\t\t\t\tfmt.Fprintf(t.out, \" %s %s\",\n\t\t\t\t\tformat(padFunc(f, SPACE, v),\n\t\t\t\t\t\tt.footerParams[y]), pad)\n\t\t\t} else {\n\t\t\t\tfmt.Fprintf(t.out, \" %s %s\",\n\t\t\t\t\tpadFunc(f, SPACE, v),\n\t\t\t\t\tpad)\n\t\t\t}\n\n\t\t\t//fmt.Fprintf(t.out, \" %s %s\",\n\t\t\t//\tpadFunc(f, SPACE, v),\n\t\t\t//\tpad)\n\t\t}\n\t\t// Next line\n\t\tfmt.Fprint(t.out, t.newLine)\n\t}\n\n\thasPrinted := false\n\n\tfor i := 0; i <= end; i++ {\n\t\tv := t.cs[i]\n\t\tpad := t.syms[symEW]\n\t\tcenter := t.syms[symNEW]\n\t\tlength := len(t.footers[i][0])\n\n\t\tif length > 0 {\n\t\t\thasPrinted = true\n\t\t}\n\n\t\t// Set center to be space if length is 0\n\t\tif length == 0 && !t.borders.Right {\n\t\t\tcenter = SPACE\n\t\t}\n\n\t\t// Print first junction\n\t\tif i == 0 {\n\t\t\tif length > 0 && !t.borders.Left {\n\t\t\t\tcenter = t.syms[symEW]\n\t\t\t} else if center != SPACE {\n\t\t\t\tcenter = t.syms[symNE]\n\t\t\t}\n\t\t\tfmt.Fprint(t.out, center)\n\t\t}\n\n\t\t// Pad With space of length is 0\n\t\tif length == 0 {\n\t\t\tpad = SPACE\n\t\t}\n\t\t// Ignore left space as it has printed before\n\t\tif hasPrinted || t.borders.Left {\n\t\t\tpad = t.syms[symEW]\n\t\t\tcenter = t.syms[symNEW]\n\t\t}\n\n\t\t// Change Center end position\n\t\tif center != SPACE {\n\t\t\tif i == end {\n\t\t\t\tif t.borders.Right {\n\t\t\t\t\tcenter = t.syms[symNW]\n\t\t\t\t} else {\n\t\t\t\t\tcenter = t.syms[symEW]\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Change Center start position\n\t\tif center == SPACE {\n\t\t\tif i < end && len(t.footers[i+1][0]) != 0 {\n\t\t\t\tif !t.borders.Left {\n\t\t\t\t\tcenter = t.syms[symEW]\n\t\t\t\t} else {\n\t\t\t\t\tcenter = t.syms[symNEW]\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Print the footer\n\t\tfmt.Fprintf(t.out, \"%s%s%s%s\",\n\t\t\tpad,\n\t\t\tstrings.Repeat(string(pad), v),\n\t\t\tpad,\n\t\t\tcenter)\n\n\t}\n\n\tfmt.Fprint(t.out, t.newLine)\n}\n\n// Print caption text\nfunc (t *Table) printCaption() {\n\twidth := t.getTableWidth()\n\tparagraph, _ := WrapString(t.captionText, width)\n\tfor linecount := 0; linecount < len(paragraph); linecount++ {\n\t\tfmt.Fprintln(t.out, paragraph[linecount])\n\t}\n}\n\n// Calculate the total number of characters in a row\nfunc (t *Table) getTableWidth() int {\n\tvar chars int\n\tfor _, v := range t.cs {\n\t\tchars += v\n\t}\n\n\t// Add chars, spaces, seperators to calculate the total width of the table.\n\t// ncols := t.colSize\n\t// spaces := ncols * 2\n\t// seps := ncols + 1\n\n\treturn (chars + (3 * t.colSize) + 2)\n}\n\n// printRows - print all the rows\nfunc (t *Table) printRows() {\n\tfor i, lines := range t.lines {\n\t\tt.printRow(lines, i)\n\t}\n}\n\n// fillAlignment - fill the alignment\nfunc (t *Table) fillAlignment(num int) {\n\tif len(t.columnsAlign) < num {\n\t\tt.columnsAlign = make([]int, num)\n\t\tfor i := range t.columnsAlign {\n\t\t\tt.columnsAlign[i] = t.align\n\t\t}\n\t}\n}\n\n// Print Row Information\n// Adjust column alignment based on type\nfunc (t *Table) printRow(columns [][]string, rowIdx int) {\n\t// Get Maximum Height\n\tmax := t.rs[rowIdx]\n\ttotal := len(columns)\n\n\t// TODO Fix uneven col size\n\t// if total < t.colSize {\n\t//\tfor n := t.colSize - total; n < t.colSize ; n++ {\n\t//\t\tcolumns = append(columns, []string{SPACE})\n\t//\t\tt.cs[n] = t.mW\n\t//\t}\n\t//}\n\n\t// Pad Each Height\n\tpads := []int{}\n\n\t// Checking for ANSI escape sequences for columns\n\tis_esc_seq := false\n\tif len(t.columnsParams) > 0 {\n\t\tis_esc_seq = true\n\t}\n\tt.fillAlignment(total)\n\n\tfor i, line := range columns {\n\t\tlength := len(line)\n\t\tpad := max - length\n\t\tpads = append(pads, pad)\n\t\tfor n := 0; n < pad; n++ {\n\t\t\tcolumns[i] = append(columns[i], \"  \")\n\t\t}\n\t}\n\t//fmt.Println(max, \"\\n\")\n\tfor x := 0; x < max; x++ {\n\t\tfor y := 0; y < total; y++ {\n\n\t\t\t// Check if border is set\n\t\t\tif !t.noWhiteSpace {\n\t\t\t\tfmt.Fprint(t.out, ConditionString((!t.borders.Left && y == 0), SPACE, t.syms[symNS]))\n\t\t\t\tfmt.Fprintf(t.out, SPACE)\n\t\t\t}\n\n\t\t\tstr := columns[y][x]\n\n\t\t\t// Embedding escape sequence with column value\n\t\t\tif is_esc_seq {\n\t\t\t\tstr = format(str, t.columnsParams[y])\n\t\t\t}\n\n\t\t\t// This would print alignment\n\t\t\t// Default alignment  would use multiple configuration\n\t\t\tswitch t.columnsAlign[y] {\n\t\t\tcase ALIGN_CENTER: //\n\t\t\t\tfmt.Fprintf(t.out, \"%s\", Pad(str, SPACE, t.cs[y]))\n\t\t\tcase ALIGN_RIGHT:\n\t\t\t\tfmt.Fprintf(t.out, \"%s\", PadLeft(str, SPACE, t.cs[y]))\n\t\t\tcase ALIGN_LEFT:\n\t\t\t\tfmt.Fprintf(t.out, \"%s\", PadRight(str, SPACE, t.cs[y]))\n\t\t\tdefault:\n\t\t\t\tif decimal.MatchString(strings.TrimSpace(str)) || percent.MatchString(strings.TrimSpace(str)) {\n\t\t\t\t\tfmt.Fprintf(t.out, \"%s\", PadLeft(str, SPACE, t.cs[y]))\n\t\t\t\t} else {\n\t\t\t\t\tfmt.Fprintf(t.out, \"%s\", PadRight(str, SPACE, t.cs[y]))\n\n\t\t\t\t\t// TODO Custom alignment per column\n\t\t\t\t\t//if max == 1 || pads[y] > 0 {\n\t\t\t\t\t//\tfmt.Fprintf(t.out, \"%s\", Pad(str, SPACE, t.cs[y]))\n\t\t\t\t\t//} else {\n\t\t\t\t\t//\tfmt.Fprintf(t.out, \"%s\", PadRight(str, SPACE, t.cs[y]))\n\t\t\t\t\t//}\n\n\t\t\t\t}\n\t\t\t}\n\t\t\tif !t.noWhiteSpace {\n\t\t\t\tfmt.Fprintf(t.out, SPACE)\n\t\t\t} else {\n\t\t\t\tfmt.Fprintf(t.out, t.tablePadding)\n\t\t\t}\n\t\t}\n\t\t// Check if border is set\n\t\t// Replace with space if not set\n\t\tif !t.noWhiteSpace {\n\t\t\tfmt.Fprint(t.out, ConditionString(t.borders.Left, t.syms[symNS], SPACE))\n\t\t}\n\t\tfmt.Fprint(t.out, t.newLine)\n\t}\n\n\tif t.rowLine {\n\t\tt.printLine(false, rowIdx == len(t.lines)-1 && len(t.footers) == 0)\n\t}\n}\n\n// Print the rows of the table and merge the cells that are identical\nfunc (t *Table) printRowsMergeCells() {\n\tvar previousLine []string\n\tvar displayCellBorder []bool\n\tvar tmpWriter bytes.Buffer\n\tfor i, lines := range t.lines {\n\t\t// We store the display of the current line in a tmp writer, as we need to know which border needs to be print above\n\t\tpreviousLine, displayCellBorder = t.printRowMergeCells(&tmpWriter, lines, i, previousLine)\n\t\tif i > 0 { //We don't need to print borders above first line\n\t\t\tif t.rowLine {\n\t\t\t\tt.printLineOptionalCellSeparators(true, displayCellBorder)\n\t\t\t}\n\t\t}\n\t\ttmpWriter.WriteTo(t.out)\n\t}\n\t//Print the end of the table\n\tif t.rowLine {\n\t\tt.printLine(false, true)\n\t}\n}\n\n// Print Row Information to a writer and merge identical cells.\n// Adjust column alignment based on type\nfunc (t *Table) printRowMergeCells(writer io.Writer, columns [][]string, rowIdx int, previousLine []string) ([]string, []bool) {\n\t// Get Maximum Height\n\tmax := t.rs[rowIdx]\n\ttotal := len(columns)\n\n\t// Pad Each Height\n\tpads := []int{}\n\n\t// Checking for ANSI escape sequences for columns\n\tisEscSeq := false\n\tif len(t.columnsParams) > 0 {\n\t\tisEscSeq = true\n\t}\n\tfor i, line := range columns {\n\t\tlength := len(line)\n\t\tpad := max - length\n\t\tpads = append(pads, pad)\n\t\tfor n := 0; n < pad; n++ {\n\t\t\tcolumns[i] = append(columns[i], \"  \")\n\t\t}\n\t}\n\n\tvar displayCellBorder []bool\n\tt.fillAlignment(total)\n\tfor x := 0; x < max; x++ {\n\t\tfor y := 0; y < total; y++ {\n\n\t\t\t// Check if border is set\n\t\t\tfmt.Fprint(writer, ConditionString((!t.borders.Left && y == 0), SPACE, t.syms[symNS]))\n\n\t\t\tfmt.Fprintf(writer, SPACE)\n\n\t\t\tstr := columns[y][x]\n\n\t\t\t// Embedding escape sequence with column value\n\t\t\tif isEscSeq {\n\t\t\t\tstr = format(str, t.columnsParams[y])\n\t\t\t}\n\n\t\t\tif t.autoMergeCells {\n\t\t\t\tvar mergeCell bool\n\t\t\t\tif t.columnsToAutoMergeCells != nil {\n\t\t\t\t\t// Check to see if the column index is in columnsToAutoMergeCells.\n\t\t\t\t\tif t.columnsToAutoMergeCells[y] {\n\t\t\t\t\t\tmergeCell = true\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t// columnsToAutoMergeCells was not set.\n\t\t\t\t\tmergeCell = true\n\t\t\t\t}\n\t\t\t\t//Store the full line to merge mutli-lines cells\n\t\t\t\tfullLine := strings.TrimRight(strings.Join(columns[y], \" \"), \" \")\n\t\t\t\tif len(previousLine) > y && fullLine == previousLine[y] && fullLine != \"\" && mergeCell {\n\t\t\t\t\t// If this cell is identical to the one above but not empty, we don't display the border and keep the cell empty.\n\t\t\t\t\tdisplayCellBorder = append(displayCellBorder, false)\n\t\t\t\t\tstr = \"\"\n\t\t\t\t} else {\n\t\t\t\t\t// First line or different content, keep the content and print the cell border\n\t\t\t\t\tdisplayCellBorder = append(displayCellBorder, true)\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// This would print alignment\n\t\t\t// Default alignment  would use multiple configuration\n\t\t\tswitch t.columnsAlign[y] {\n\t\t\tcase ALIGN_CENTER: //\n\t\t\t\tfmt.Fprintf(writer, \"%s\", Pad(str, SPACE, t.cs[y]))\n\t\t\tcase ALIGN_RIGHT:\n\t\t\t\tfmt.Fprintf(writer, \"%s\", PadLeft(str, SPACE, t.cs[y]))\n\t\t\tcase ALIGN_LEFT:\n\t\t\t\tfmt.Fprintf(writer, \"%s\", PadRight(str, SPACE, t.cs[y]))\n\t\t\tdefault:\n\t\t\t\tif decimal.MatchString(strings.TrimSpace(str)) || percent.MatchString(strings.TrimSpace(str)) {\n\t\t\t\t\tfmt.Fprintf(writer, \"%s\", PadLeft(str, SPACE, t.cs[y]))\n\t\t\t\t} else {\n\t\t\t\t\tfmt.Fprintf(writer, \"%s\", PadRight(str, SPACE, t.cs[y]))\n\t\t\t\t}\n\t\t\t}\n\t\t\tfmt.Fprintf(writer, SPACE)\n\t\t}\n\t\t// Check if border is set\n\t\t// Replace with space if not set\n\t\tfmt.Fprint(writer, ConditionString(t.borders.Left, t.syms[symNS], SPACE))\n\t\tfmt.Fprint(writer, t.newLine)\n\t}\n\n\t//The new previous line is the current one\n\tpreviousLine = make([]string, total)\n\tfor y := 0; y < total; y++ {\n\t\tpreviousLine[y] = strings.TrimRight(strings.Join(columns[y], \" \"), \" \") //Store the full line for multi-lines cells\n\t}\n\t//Returns the newly added line and wether or not a border should be displayed above.\n\treturn previousLine, displayCellBorder\n}\n\n// parseDimension - parse table dimensions\nfunc (t *Table) parseDimension(str string, colKey, rowKey int) []string {\n\tvar (\n\t\traw      []string\n\t\tmaxWidth int\n\t)\n\n\traw = getLines(str)\n\tmaxWidth = 0\n\tfor _, line := range raw {\n\t\tif w := DisplayWidth(line); w > maxWidth {\n\t\t\tmaxWidth = w\n\t\t}\n\t}\n\n\t// If wrapping, ensure that all paragraphs in the cell fit in the\n\t// specified width.\n\tif t.autoWrap {\n\t\t// If there's a maximum allowed width for wrapping, use that.\n\t\tif maxWidth > t.mW {\n\t\t\tmaxWidth = t.mW\n\t\t}\n\n\t\t// In the process of doing so, we need to recompute maxWidth. This\n\t\t// is because perhaps a word in the cell is longer than the\n\t\t// allowed maximum width in t.mW.\n\t\tnewMaxWidth := maxWidth\n\t\tnewRaw := make([]string, 0, len(raw))\n\n\t\tif t.reflowText {\n\t\t\t// Make a single paragraph of everything.\n\t\t\traw = []string{strings.Join(raw, \" \")}\n\t\t}\n\t\tfor i, para := range raw {\n\t\t\tparaLines, _ := WrapString(para, maxWidth)\n\t\t\tfor _, line := range paraLines {\n\t\t\t\tif w := DisplayWidth(line); w > newMaxWidth {\n\t\t\t\t\tnewMaxWidth = w\n\t\t\t\t}\n\t\t\t}\n\t\t\tif i > 0 {\n\t\t\t\tnewRaw = append(newRaw, \" \")\n\t\t\t}\n\t\t\tnewRaw = append(newRaw, paraLines...)\n\t\t}\n\t\traw = newRaw\n\t\tmaxWidth = newMaxWidth\n\t}\n\n\t// Store the new known maximum width.\n\tv, ok := t.cs[colKey]\n\tif !ok || v < maxWidth || v == 0 {\n\t\tt.cs[colKey] = maxWidth\n\t}\n\n\t// Remember the number of lines for the row printer.\n\th := len(raw)\n\tv, ok = t.rs[rowKey]\n\n\tif !ok || v < h || v == 0 {\n\t\tt.rs[rowKey] = h\n\t}\n\t//fmt.Printf(\"Raw %+v %d\\n\", raw, len(raw))\n\treturn raw\n}\n"
        },
        {
          "name": "table_test.go",
          "type": "blob",
          "size": 57.822265625,
          "content": "// Copyright 2014 Oleku Konko All rights reserved.\n// Use of this source code is governed by a MIT\n// license that can be found in the LICENSE file.\n\n// This module is a Table Writer  API for the Go Programming Language.\n// The protocols were written in pure Go and works on windows and unix systems\n\npackage tablewriter\n\nimport (\n\t\"bytes\"\n\t\"fmt\"\n\t\"io\"\n\t\"os\"\n\t\"reflect\"\n\t\"strings\"\n\t\"testing\"\n)\n\nfunc checkEqual(t *testing.T, got, want interface{}, msgs ...interface{}) {\n\tt.Helper()\n\tif !reflect.DeepEqual(got, want) {\n\t\tbuf := bytes.Buffer{}\n\t\tbuf.WriteString(\"got:\\n[%v]\\nwant:\\n[%v]\\n\")\n\t\tfor _, v := range msgs {\n\t\t\tbuf.WriteString(v.(string))\n\t\t}\n\t\tt.Errorf(buf.String(), got, want)\n\t}\n}\n\nfunc ExampleShort() {\n\tdata := [][]string{\n\t\t{\"A\", \"The Good\", \"500\"},\n\t\t{\"B\", \"The Very very Bad Man\", \"288\"},\n\t\t{\"C\", \"The Ugly\", \"120\"},\n\t\t{\"D\", \"The Gopher\", \"800\"},\n\t}\n\n\ttable := NewWriter(os.Stdout)\n\ttable.SetHeader([]string{\"Name\", \"Sign\", \"Rating\"})\n\n\tfor _, v := range data {\n\t\ttable.Append(v)\n\t}\n\ttable.Render()\n\n\t// Output: +------+-----------------------+--------+\n\t// | NAME |         SIGN          | RATING |\n\t// +------+-----------------------+--------+\n\t// | A    | The Good              |    500 |\n\t// | B    | The Very very Bad Man |    288 |\n\t// | C    | The Ugly              |    120 |\n\t// | D    | The Gopher            |    800 |\n\t// +------+-----------------------+--------+\n}\n\nfunc ExampleTable() {\n\tdata := [][]string{\n\t\t{\"Learn East has computers with adapted keyboards with enlarged print etc\", \"  Some Data  \", \" Another Data\"},\n\t\t{\"Instead of lining up the letters all \", \"the way across, he splits the keyboard in two\", \"Like most ergonomic keyboards\", \"See Data\"},\n\t}\n\n\ttable := NewWriter(os.Stdout)\n\ttable.SetHeader([]string{\"Name\", \"Sign\", \"Rating\"})\n\ttable.SetCenterSeparator(\"*\")\n\ttable.SetRowSeparator(\"=\")\n\n\tfor _, v := range data {\n\t\ttable.Append(v)\n\t}\n\ttable.Render()\n\n\t// Output: *================================*================================*===============================*==========*\n\t// |              NAME              |              SIGN              |            RATING             |          |\n\t// *================================*================================*===============================*==========*\n\t// | Learn East has computers       | Some Data                      | Another Data                  |\n\t// | with adapted keyboards with    |                                |                               |\n\t// | enlarged print etc             |                                |                               |\n\t// | Instead of lining up the       | the way across, he splits the  | Like most ergonomic keyboards | See Data |\n\t// | letters all                    | keyboard in two                |                               |          |\n\t// *================================*================================*===============================*==========*\n}\n\nfunc ExampleNewCSV() {\n\ttable, _ := NewCSV(os.Stdout, \"testdata/test.csv\", true)\n\ttable.SetCenterSeparator(\"*\")\n\ttable.SetRowSeparator(\"=\")\n\n\ttable.Render()\n\n\t// Output: *============*===========*=========*\n\t// | FIRST NAME | LAST NAME |   SSN   |\n\t// *============*===========*=========*\n\t// | John       | Barry     |  123456 |\n\t// | Kathy      | Smith     |  687987 |\n\t// | Bob        | McCornick | 3979870 |\n\t// *============*===========*=========*\n}\n\nfunc ExampleTable_SetUnicodeHV() {\n\tdata := [][]string{\n\t\t{\"Regular\", \"regular line\", \"1\"},\n\t\t{\"Thick\", \"particularly thick line\", \"2\"},\n\t\t{\"Double\", \"double line\", \"3\"},\n\t}\n\n\ttable := NewWriter(os.Stdout)\n\ttable.SetFooter([]string{\"Constant\", \"Meaning\", \"Seq\"})\n\ttable.SetUnicodeHV(Double, Regular)\n\ttable.AppendBulk(data)\n\ttable.Render()\n\n\t// Output:\n\t// ╒══════════╤═════════════════════════╤═════╕\n\t// │ Regular  │ regular line            │   1 │\n\t// │ Thick    │ particularly thick line │   2 │\n\t// │ Double   │ double line             │   3 │\n\t// ╞══════════╪═════════════════════════╪═════╡\n\t// │ CONSTANT │         MEANING         │ SEQ │\n\t// ╘══════════╧═════════════════════════╧═════╛\n}\n\nfunc TestUnicodeRegularThick(t *testing.T) {\n\tdata := [][]string{\n\t\t{\"Regular\", \"regular line\", \"1\"},\n\t\t{\"Thick\", \"particularly thick line\", \"2\"},\n\t\t{\"Double\", \"double line\", \"3\"},\n\t}\n\tbuf := &bytes.Buffer{}\n\tbuf.WriteRune('\\n') // Makes the want literal easier to read.\n\n\ttable := NewWriter(buf)\n\ttable.SetHeader([]string{\"Constant\", \"Meaning\", \"Seq\"})\n\ttable.SetUnicodeHV(Regular, Thick)\n\ttable.AppendBulk(data)\n\ttable.Render()\n\n\twant := `\n┎──────────┰─────────────────────────┰─────┒\n┃ CONSTANT ┃         MEANING         ┃ SEQ ┃\n┠──────────╂─────────────────────────╂─────┨\n┃ Regular  ┃ regular line            ┃   1 ┃\n┃ Thick    ┃ particularly thick line ┃   2 ┃\n┃ Double   ┃ double line             ┃   3 ┃\n┖──────────┸─────────────────────────┸─────┚\n`\n\tcheckEqual(t, buf.String(), want, \"Unicode without thick vertical lines failed\")\n}\n\nfunc TestUnicodeWithoutBorder(t *testing.T) {\n\tdata := [][]string{\n\t\t{\"Regular\", \"regular line\", \"1\"},\n\t\t{\"Thick\", \"particularly thick line\", \"2\"},\n\t\t{\"Double\", \"double line\", \"3\"},\n\t}\n\tbuf := &bytes.Buffer{}\n\tbuf.WriteRune('\\n') // Makes the want literal easier to read.\n\n\ttable := NewWriter(buf)\n\ttable.SetHeader([]string{\"Constant\", \"Meaning\", \"Seq\"})\n\ttable.SetFooter([]string{\"Constant\", \"Meaning\", \"Seq\"})\n\ttable.SetUnicodeHV(Regular, Regular)\n\ttable.EnableBorder(false)\n\ttable.AppendBulk(data)\n\ttable.Render()\n\n\twant := strings.ReplaceAll(`\n  CONSTANT │         MEANING         │ SEQ  $\n───────────┼─────────────────────────┼──────$\n  Regular  │ regular line            │   1  $\n  Thick    │ particularly thick line │   2  $\n  Double   │ double line             │   3  $\n───────────┼─────────────────────────┼──────$\n  CONSTANT │         MEANING         │ SEQ  $\n───────────┴─────────────────────────┴──────$\n`, \"$\", \"\") // The $ only serve to make the trailing spaces more visible.\n\tcheckEqual(t, buf.String(), want, \"Unicode without border failed\")\n}\n\nfunc TestUnicodeWithoutHeader(t *testing.T) {\n\tdata := [][]string{\n\t\t{\"Regular\", \"regular line\", \"1\"},\n\t\t{\"Thick\", \"particularly thick line\", \"2\"},\n\t\t{\"Double\", \"double line\", \"3\"},\n\t}\n\tbuf := &bytes.Buffer{}\n\tbuf.WriteRune('\\n') // Makes the want literal easier to read.\n\n\ttable := NewWriter(buf)\n\ttable.SetUnicodeHV(Regular, Regular)\n\ttable.AppendBulk(data)\n\ttable.Render()\n\n\twant := `\n┌─────────┬─────────────────────────┬───┐\n│ Regular │ regular line            │ 1 │\n│ Thick   │ particularly thick line │ 2 │\n│ Double  │ double line             │ 3 │\n└─────────┴─────────────────────────┴───┘\n`\n\tcheckEqual(t, buf.String(), want, \"Unicode without border failed\")\n}\n\nfunc TestUnicodeWithoutBorderOrHeader(t *testing.T) {\n\tdata := [][]string{\n\t\t{\"Regular\", \"regular line\", \"1\"},\n\t\t{\"Thick\", \"particularly thick line\", \"2\"},\n\t\t{\"Double\", \"double line\", \"3\"},\n\t}\n\tbuf := &bytes.Buffer{}\n\tbuf.WriteRune('\\n') // Makes the want literal easier to read.\n\n\ttable := NewWriter(buf)\n\ttable.SetUnicodeHV(Regular, Regular)\n\ttable.EnableBorder(false)\n\ttable.AppendBulk(data)\n\ttable.Render()\n\n\twant := strings.ReplaceAll(`\n  Regular │ regular line            │ 1  $\n  Thick   │ particularly thick line │ 2  $\n  Double  │ double line             │ 3  $\n`, \"$\", \"\") // The $ only serve to make the trailing spaces more visible.\n\tcheckEqual(t, buf.String(), want, \"Unicode without border failed\")\n}\n\n// TestNumLines to test the numbers of lines\nfunc TestNumLines(t *testing.T) {\n\tdata := [][]string{\n\t\t{\"A\", \"The Good\", \"500\"},\n\t\t{\"B\", \"The Very very Bad Man\", \"288\"},\n\t\t{\"C\", \"The Ugly\", \"120\"},\n\t\t{\"D\", \"The Gopher\", \"800\"},\n\t}\n\n\tbuf := &bytes.Buffer{}\n\ttable := NewWriter(buf)\n\ttable.SetHeader([]string{\"Name\", \"Sign\", \"Rating\"})\n\n\tfor i, v := range data {\n\t\ttable.Append(v)\n\t\tcheckEqual(t, table.NumLines(), i+1, \"Number of lines failed\")\n\t}\n\n\tcheckEqual(t, table.NumLines(), len(data), \"Number of lines failed\")\n}\n\nfunc TestCSVInfo(t *testing.T) {\n\tbuf := &bytes.Buffer{}\n\ttable, err := NewCSV(buf, \"testdata/test_info.csv\", true)\n\tif err != nil {\n\t\tt.Error(err)\n\t\treturn\n\t}\n\ttable.SetAlignment(ALIGN_LEFT)\n\ttable.EnableBorder(false)\n\ttable.Render()\n\n\tgot := buf.String()\n\twant := `   FIELD   |     TYPE     | NULL | KEY | DEFAULT |     EXTRA       \n-----------+--------------+------+-----+---------+-----------------\n  user_id  | smallint(5)  | NO   | PRI | NULL    | auto_increment  \n  username | varchar(10)  | NO   |     | NULL    |                 \n  password | varchar(100) | NO   |     | NULL    |                 \n`\n\tcheckEqual(t, got, want, \"CSV info failed\")\n}\n\nfunc TestCSVSeparator(t *testing.T) {\n\tbuf := &bytes.Buffer{}\n\ttable, err := NewCSV(buf, \"testdata/test.csv\", true)\n\tif err != nil {\n\t\tt.Error(err)\n\t\treturn\n\t}\n\ttable.SetRowLine(true)\n\ttable.SetCenterSeparator(\"+\")\n\ttable.SetColumnSeparator(\"|\")\n\ttable.SetRowSeparator(\"-\")\n\ttable.SetAlignment(ALIGN_LEFT)\n\ttable.Render()\n\n\twant := `+------------+-----------+---------+\n| FIRST NAME | LAST NAME |   SSN   |\n+------------+-----------+---------+\n| John       | Barry     | 123456  |\n+------------+-----------+---------+\n| Kathy      | Smith     | 687987  |\n+------------+-----------+---------+\n| Bob        | McCornick | 3979870 |\n+------------+-----------+---------+\n`\n\n\tcheckEqual(t, buf.String(), want, \"CSV info failed\")\n}\n\nfunc TestNoBorder(t *testing.T) {\n\tdata := [][]string{\n\t\t{\"1/1/2014\", \"Domain name\", \"2233\", \"$10.98\"},\n\t\t{\"1/1/2014\", \"January Hosting\", \"2233\", \"$54.95\"},\n\t\t{\"\", \"    (empty)\\n    (empty)\", \"\", \"\"},\n\t\t{\"1/4/2014\", \"February Hosting\", \"2233\", \"$51.00\"},\n\t\t{\"1/4/2014\", \"February Extra Bandwidth\", \"2233\", \"$30.00\"},\n\t\t{\"1/4/2014\", \"    (Discount)\", \"2233\", \"-$1.00\"},\n\t}\n\n\tvar buf bytes.Buffer\n\ttable := NewWriter(&buf)\n\ttable.SetAutoWrapText(false)\n\ttable.SetHeader([]string{\"Date\", \"Description\", \"CV2\", \"Amount\"})\n\ttable.SetFooter([]string{\"\", \"\", \"Total\", \"$145.93\"}) // Add Footer\n\ttable.EnableBorder(false)                             // Set Border to false\n\ttable.AppendBulk(data)                                // Add Bulk Data\n\ttable.Render()\n\n\twant := `    DATE   |       DESCRIPTION        |  CV2  | AMOUNT   \n-----------+--------------------------+-------+----------\n  1/1/2014 | Domain name              |  2233 | $10.98   \n  1/1/2014 | January Hosting          |  2233 | $54.95   \n           |     (empty)              |       |          \n           |     (empty)              |       |          \n  1/4/2014 | February Hosting         |  2233 | $51.00   \n  1/4/2014 | February Extra Bandwidth |  2233 | $30.00   \n  1/4/2014 |     (Discount)           |  2233 | -$1.00   \n-----------+--------------------------+-------+----------\n                                        TOTAL | $145.93  \n                                      --------+----------\n`\n\n\tcheckEqual(t, buf.String(), want, \"border table rendering failed\")\n}\n\nfunc TestNoBorderUnicode(t *testing.T) {\n\tdata := [][]string{\n\t\t{\"1/1/2014\", \"Domain name\", \"2233\", \"$10.98\"},\n\t\t{\"1/1/2014\", \"January Hosting\", \"2233\", \"$54.95\"},\n\t\t{\"\", \"    (empty)\\n    (empty)\", \"\", \"\"},\n\t\t{\"1/4/2014\", \"February Hosting\", \"2233\", \"$51.00\"},\n\t\t{\"1/4/2014\", \"February Extra Bandwidth\", \"2233\", \"$30.00\"},\n\t\t{\"1/4/2014\", \"    (Discount)\", \"2233\", \"-$1.00\"},\n\t}\n\n\tvar buf bytes.Buffer\n\tbuf.WriteRune('\\n') // Makes the want literal easier to read.\n\ttable := NewWriter(&buf)\n\ttable.SetAutoWrapText(false)\n\ttable.SetHeader([]string{\"Date\", \"Description\", \"CV2\", \"Amount\"})\n\ttable.SetFooter([]string{\"\", \"\", \"Total\", \"$145.93\"}) // Add Footer\n\ttable.EnableBorder(false)                             // Set Border to false\n\ttable.AppendBulk(data)                                // Add Bulk Data\n\ttable.SetUnicodeHV(Regular, Regular)\n\ttable.Render()\n\n\twant := `\n    DATE   │       DESCRIPTION        │  CV2  │ AMOUNT   \n───────────┼──────────────────────────┼───────┼──────────\n  1/1/2014 │ Domain name              │  2233 │ $10.98   \n  1/1/2014 │ January Hosting          │  2233 │ $54.95   \n           │     (empty)              │       │          \n           │     (empty)              │       │          \n  1/4/2014 │ February Hosting         │  2233 │ $51.00   \n  1/4/2014 │ February Extra Bandwidth │  2233 │ $30.00   \n  1/4/2014 │     (Discount)           │  2233 │ -$1.00   \n───────────┴──────────────────────────┴───────┼──────────\n                                        TOTAL │ $145.93  \n                                      ────────┴──────────\n`\n\t// The above is what we actually would prefer, but the below is what the code\n\t// currently generates. Fixes welcome.\n\twant = `\n    DATE   │       DESCRIPTION        │  CV2  │ AMOUNT   \n───────────┼──────────────────────────┼───────┼──────────\n  1/1/2014 │ Domain name              │  2233 │ $10.98   \n  1/1/2014 │ January Hosting          │  2233 │ $54.95   \n           │     (empty)              │       │          \n           │     (empty)              │       │          \n  1/4/2014 │ February Hosting         │  2233 │ $51.00   \n  1/4/2014 │ February Extra Bandwidth │  2233 │ $30.00   \n  1/4/2014 │     (Discount)           │  2233 │ -$1.00   \n───────────┼──────────────────────────┼───────┼──────────\n                                        TOTAL │ $145.93  \n                                      ────────┴──────────\n`\n\n\tcheckEqual(t, buf.String(), want, \"border table rendering failed\")\n}\n\nfunc TestWithBorder(t *testing.T) {\n\tdata := [][]string{\n\t\t{\"1/1/2014\", \"Domain name\", \"2233\", \"$10.98\"},\n\t\t{\"1/1/2014\", \"January Hosting\", \"2233\", \"$54.95\"},\n\t\t{\"\", \"    (empty)\\n    (empty)\", \"\", \"\"},\n\t\t{\"1/4/2014\", \"February Hosting\", \"2233\", \"$51.00\"},\n\t\t{\"1/4/2014\", \"February Extra Bandwidth\", \"2233\", \"$30.00\"},\n\t\t{\"1/4/2014\", \"    (Discount)\", \"2233\", \"-$1.00\"},\n\t}\n\n\tvar buf bytes.Buffer\n\ttable := NewWriter(&buf)\n\ttable.SetAutoWrapText(false)\n\ttable.SetHeader([]string{\"Date\", \"Description\", \"CV2\", \"Amount\"})\n\ttable.SetFooter([]string{\"\", \"\", \"Total\", \"$145.93\"}) // Add Footer\n\ttable.AppendBulk(data)                                // Add Bulk Data\n\ttable.Render()\n\n\twant := `+----------+--------------------------+-------+---------+\n|   DATE   |       DESCRIPTION        |  CV2  | AMOUNT  |\n+----------+--------------------------+-------+---------+\n| 1/1/2014 | Domain name              |  2233 | $10.98  |\n| 1/1/2014 | January Hosting          |  2233 | $54.95  |\n|          |     (empty)              |       |         |\n|          |     (empty)              |       |         |\n| 1/4/2014 | February Hosting         |  2233 | $51.00  |\n| 1/4/2014 | February Extra Bandwidth |  2233 | $30.00  |\n| 1/4/2014 |     (Discount)           |  2233 | -$1.00  |\n+----------+--------------------------+-------+---------+\n|                                       TOTAL | $145.93 |\n+----------+--------------------------+-------+---------+\n`\n\n\tcheckEqual(t, buf.String(), want, \"border table rendering failed\")\n}\n\nfunc TestWithBorderUnicode(t *testing.T) {\n\tdata := [][]string{\n\t\t{\"1/1/2014\", \"Domain name\", \"2233\", \"$10.98\"},\n\t\t{\"1/1/2014\", \"January Hosting\", \"2233\", \"$54.95\"},\n\t\t{\"\", \"    (empty)\\n    (empty)\", \"\", \"\"},\n\t\t{\"1/4/2014\", \"February Hosting\", \"2233\", \"$51.00\"},\n\t\t{\"1/4/2014\", \"February Extra Bandwidth\", \"2233\", \"$30.00\"},\n\t\t{\"1/4/2014\", \"    (Discount)\", \"2233\", \"-$1.00\"},\n\t}\n\n\tvar buf bytes.Buffer\n\tbuf.WriteRune('\\n') // Makes the want literal easier to read.\n\ttable := NewWriter(&buf)\n\ttable.SetAutoWrapText(false)\n\ttable.SetHeader([]string{\"Date\", \"Description\", \"CV2\", \"Amount\"})\n\ttable.SetFooter([]string{\"\", \"\", \"Total\", \"$145.93\"}) // Add Footer\n\ttable.AppendBulk(data)                                // Add Bulk Data\n\ttable.SetUnicodeHV(Regular, Regular)\n\ttable.Render()\n\n\twant := `\n┌──────────┬──────────────────────────┬───────┬─────────┐\n│   DATE   │       DESCRIPTION        │  CV2  │ AMOUNT  │\n├──────────┼──────────────────────────┼───────┼─────────┤\n│ 1/1/2014 │ Domain name              │  2233 │ $10.98  │\n│ 1/1/2014 │ January Hosting          │  2233 │ $54.95  │\n│          │     (empty)              │       │         │\n│          │     (empty)              │       │         │\n│ 1/4/2014 │ February Hosting         │  2233 │ $51.00  │\n│ 1/4/2014 │ February Extra Bandwidth │  2233 │ $30.00  │\n│ 1/4/2014 │     (Discount)           │  2233 │ -$1.00  │\n├──────────┴──────────────────────────┴───────┼─────────┤\n│                                       TOTAL │ $145.93 │\n└─────────────────────────────────────────────┴─────────┘\n`\n\t// The above is what we actually would prefer, but the below is what the code\n\t// currently generates. Fixes welcome.\n\twant = `\n┌──────────┬──────────────────────────┬───────┬─────────┐\n│   DATE   │       DESCRIPTION        │  CV2  │ AMOUNT  │\n├──────────┼──────────────────────────┼───────┼─────────┤\n│ 1/1/2014 │ Domain name              │  2233 │ $10.98  │\n│ 1/1/2014 │ January Hosting          │  2233 │ $54.95  │\n│          │     (empty)              │       │         │\n│          │     (empty)              │       │         │\n│ 1/4/2014 │ February Hosting         │  2233 │ $51.00  │\n│ 1/4/2014 │ February Extra Bandwidth │  2233 │ $30.00  │\n│ 1/4/2014 │     (Discount)           │  2233 │ -$1.00  │\n├──────────┼──────────────────────────┼───────┼─────────┤\n│                                       TOTAL │ $145.93 │\n└──────────┴──────────────────────────┴───────┴─────────┘\n`\n\n\tcheckEqual(t, buf.String(), want, \"border table rendering failed\")\n}\n\nfunc TestPrintingInMarkdown(t *testing.T) {\n\tdata := [][]string{\n\t\t{\"1/1/2014\", \"Domain name\", \"2233\", \"$10.98\"},\n\t\t{\"1/1/2014\", \"January Hosting\", \"2233\", \"$54.95\"},\n\t\t{\"1/4/2014\", \"February Hosting\", \"2233\", \"$51.00\"},\n\t\t{\"1/4/2014\", \"February Extra Bandwidth\", \"2233\", \"$30.00\"},\n\t}\n\n\tvar buf bytes.Buffer\n\ttable := NewWriter(&buf)\n\ttable.SetHeader([]string{\"Date\", \"Description\", \"CV2\", \"Amount\"})\n\ttable.AppendBulk(data) // Add Bulk Data\n\ttable.SetBorders(Border{Left: true, Top: false, Right: true, Bottom: false})\n\ttable.SetCenterSeparator(\"|\")\n\ttable.Render()\n\n\twant := `|   DATE   |       DESCRIPTION        | CV2  | AMOUNT |\n|----------|--------------------------|------|--------|\n| 1/1/2014 | Domain name              | 2233 | $10.98 |\n| 1/1/2014 | January Hosting          | 2233 | $54.95 |\n| 1/4/2014 | February Hosting         | 2233 | $51.00 |\n| 1/4/2014 | February Extra Bandwidth | 2233 | $30.00 |\n`\n\tcheckEqual(t, buf.String(), want, \"border table rendering failed\")\n}\n\nfunc TestPrintHeading(t *testing.T) {\n\tvar buf bytes.Buffer\n\ttable := NewWriter(&buf)\n\ttable.SetHeader([]string{\"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\", \"a\", \"b\", \"c\"})\n\ttable.printHeading()\n\twant := `| 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | A | B | C |\n+---+---+---+---+---+---+---+---+---+---+---+---+\n`\n\tcheckEqual(t, buf.String(), want, \"header rendering failed\")\n}\n\nfunc TestPrintHeadingWithoutAutoFormat(t *testing.T) {\n\tvar buf bytes.Buffer\n\ttable := NewWriter(&buf)\n\ttable.SetHeader([]string{\"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\", \"a\", \"b\", \"c\"})\n\ttable.SetAutoFormatHeaders(false)\n\ttable.printHeading()\n\twant := `| 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | a | b | c |\n+---+---+---+---+---+---+---+---+---+---+---+---+\n`\n\tcheckEqual(t, buf.String(), want, \"header rendering failed\")\n}\n\nfunc TestPrintFooter(t *testing.T) {\n\tvar buf bytes.Buffer\n\ttable := NewWriter(&buf)\n\ttable.SetHeader([]string{\"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\", \"a\", \"b\", \"c\"})\n\ttable.SetFooter([]string{\"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\", \"a\", \"b\", \"c\"})\n\ttable.printFooter()\n\twant := `| 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | A | B | C |\n+---+---+---+---+---+---+---+---+---+---+---+---+\n`\n\tcheckEqual(t, buf.String(), want, \"footer rendering failed\")\n}\n\nfunc TestPrintFooterWithoutAutoFormat(t *testing.T) {\n\tvar buf bytes.Buffer\n\ttable := NewWriter(&buf)\n\ttable.SetAutoFormatHeaders(false)\n\ttable.SetHeader([]string{\"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\", \"a\", \"b\", \"c\"})\n\ttable.SetFooter([]string{\"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\", \"a\", \"b\", \"c\"})\n\ttable.printFooter()\n\twant := `| 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | a | b | c |\n+---+---+---+---+---+---+---+---+---+---+---+---+\n`\n\tcheckEqual(t, buf.String(), want, \"footer rendering failed\")\n}\n\nfunc TestPrintShortCaption(t *testing.T) {\n\tvar buf bytes.Buffer\n\tdata := [][]string{\n\t\t{\"A\", \"The Good\", \"500\"},\n\t\t{\"B\", \"The Very very Bad Man\", \"288\"},\n\t\t{\"C\", \"The Ugly\", \"120\"},\n\t\t{\"D\", \"The Gopher\", \"800\"},\n\t}\n\n\ttable := NewWriter(&buf)\n\ttable.SetHeader([]string{\"Name\", \"Sign\", \"Rating\"})\n\ttable.SetCaption(true, \"Short caption.\")\n\n\tfor _, v := range data {\n\t\ttable.Append(v)\n\t}\n\ttable.Render()\n\n\twant := `+------+-----------------------+--------+\n| NAME |         SIGN          | RATING |\n+------+-----------------------+--------+\n| A    | The Good              |    500 |\n| B    | The Very very Bad Man |    288 |\n| C    | The Ugly              |    120 |\n| D    | The Gopher            |    800 |\n+------+-----------------------+--------+\nShort caption.\n`\n\tcheckEqual(t, buf.String(), want, \"long caption for short example rendering failed\")\n}\n\nfunc TestPrintLongCaptionWithShortExample(t *testing.T) {\n\tvar buf bytes.Buffer\n\tdata := [][]string{\n\t\t{\"A\", \"The Good\", \"500\"},\n\t\t{\"B\", \"The Very very Bad Man\", \"288\"},\n\t\t{\"C\", \"The Ugly\", \"120\"},\n\t\t{\"D\", \"The Gopher\", \"800\"},\n\t}\n\n\ttable := NewWriter(&buf)\n\ttable.SetHeader([]string{\"Name\", \"Sign\", \"Rating\"})\n\ttable.SetCaption(true, \"This is a very long caption. The text should wrap. If not, we have a problem that needs to be solved.\")\n\n\tfor _, v := range data {\n\t\ttable.Append(v)\n\t}\n\ttable.Render()\n\n\twant := `+------+-----------------------+--------+\n| NAME |         SIGN          | RATING |\n+------+-----------------------+--------+\n| A    | The Good              |    500 |\n| B    | The Very very Bad Man |    288 |\n| C    | The Ugly              |    120 |\n| D    | The Gopher            |    800 |\n+------+-----------------------+--------+\nThis is a very long caption. The text\nshould wrap. If not, we have a problem\nthat needs to be solved.\n`\n\tcheckEqual(t, buf.String(), want, \"long caption for short example rendering failed\")\n}\n\nfunc TestPrintCaptionWithFooter(t *testing.T) {\n\tdata := [][]string{\n\t\t{\"1/1/2014\", \"Domain name\", \"2233\", \"$10.98\"},\n\t\t{\"1/1/2014\", \"January Hosting\", \"2233\", \"$54.95\"},\n\t\t{\"1/4/2014\", \"February Hosting\", \"2233\", \"$51.00\"},\n\t\t{\"1/4/2014\", \"February Extra Bandwidth\", \"2233\", \"$30.00\"},\n\t}\n\n\tvar buf bytes.Buffer\n\ttable := NewWriter(&buf)\n\ttable.SetHeader([]string{\"Date\", \"Description\", \"CV2\", \"Amount\"})\n\ttable.SetFooter([]string{\"\", \"\", \"Total\", \"$146.93\"})                                                  // Add Footer\n\ttable.SetCaption(true, \"This is a very long caption. The text should wrap to the width of the table.\") // Add caption\n\ttable.EnableBorder(false)                                                                              // Set Border to false\n\ttable.AppendBulk(data)                                                                                 // Add Bulk Data\n\ttable.Render()\n\n\twant := `    DATE   |       DESCRIPTION        |  CV2  | AMOUNT   \n-----------+--------------------------+-------+----------\n  1/1/2014 | Domain name              |  2233 | $10.98   \n  1/1/2014 | January Hosting          |  2233 | $54.95   \n  1/4/2014 | February Hosting         |  2233 | $51.00   \n  1/4/2014 | February Extra Bandwidth |  2233 | $30.00   \n-----------+--------------------------+-------+----------\n                                        TOTAL | $146.93  \n                                      --------+----------\nThis is a very long caption. The text should wrap to the\nwidth of the table.\n`\n\tcheckEqual(t, buf.String(), want, \"border table rendering failed\")\n}\n\nfunc TestPrintLongCaptionWithLongExample(t *testing.T) {\n\tvar buf bytes.Buffer\n\tdata := [][]string{\n\t\t{\"Learn East has computers with adapted keyboards with enlarged print etc\", \"Some Data\", \"Another Data\"},\n\t\t{\"Instead of lining up the letters all\", \"the way across, he splits the keyboard in two\", \"Like most ergonomic keyboards\"},\n\t}\n\n\ttable := NewWriter(&buf)\n\ttable.SetCaption(true, \"This is a very long caption. The text should wrap. If not, we have a problem that needs to be solved.\")\n\ttable.SetHeader([]string{\"Name\", \"Sign\", \"Rating\"})\n\n\tfor _, v := range data {\n\t\ttable.Append(v)\n\t}\n\ttable.Render()\n\n\twant := `+--------------------------------+--------------------------------+-------------------------------+\n|              NAME              |              SIGN              |            RATING             |\n+--------------------------------+--------------------------------+-------------------------------+\n| Learn East has computers       | Some Data                      | Another Data                  |\n| with adapted keyboards with    |                                |                               |\n| enlarged print etc             |                                |                               |\n| Instead of lining up the       | the way across, he splits the  | Like most ergonomic keyboards |\n| letters all                    | keyboard in two                |                               |\n+--------------------------------+--------------------------------+-------------------------------+\nThis is a very long caption. The text should wrap. If not, we have a problem that needs to be\nsolved.\n`\n\tcheckEqual(t, buf.String(), want, \"long caption for long example rendering failed\")\n}\n\nfunc Example_autowrap() {\n\tvar multiline = `A multiline\nstring with some lines being really long.`\n\n\tconst (\n\t\ttestRow = iota\n\t\ttestHeader\n\t\ttestFooter\n\t\ttestFooter2\n\t)\n\tfor mode := testRow; mode <= testFooter2; mode++ {\n\t\tfor _, autoFmt := range []bool{false, true} {\n\t\t\tif mode == testRow && autoFmt {\n\t\t\t\t// Nothing special to test, skip\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tfor _, autoWrap := range []bool{false, true} {\n\t\t\t\tfor _, reflow := range []bool{false, true} {\n\t\t\t\t\tif !autoWrap && reflow {\n\t\t\t\t\t\t// Invalid configuration, skip\n\t\t\t\t\t\tcontinue\n\t\t\t\t\t}\n\t\t\t\t\tfmt.Println(\"mode\", mode, \"autoFmt\", autoFmt, \"autoWrap\", autoWrap, \"reflow\", reflow)\n\t\t\t\t\tt := NewWriter(os.Stdout)\n\t\t\t\t\tt.SetAutoFormatHeaders(autoFmt)\n\t\t\t\t\tt.SetAutoWrapText(autoWrap)\n\t\t\t\t\tt.SetReflowDuringAutoWrap(reflow)\n\t\t\t\t\tif mode == testHeader {\n\t\t\t\t\t\tt.SetHeader([]string{\"woo\", multiline})\n\t\t\t\t\t} else {\n\t\t\t\t\t\tt.SetHeader([]string{\"woo\", \"waa\"})\n\t\t\t\t\t}\n\t\t\t\t\tif mode == testRow {\n\t\t\t\t\t\tt.Append([]string{\"woo\", multiline})\n\t\t\t\t\t} else {\n\t\t\t\t\t\tt.Append([]string{\"woo\", \"waa\"})\n\t\t\t\t\t}\n\t\t\t\t\tif mode == testFooter {\n\t\t\t\t\t\tt.SetFooter([]string{\"woo\", multiline})\n\t\t\t\t\t} else if mode == testFooter2 {\n\t\t\t\t\t\tt.SetFooter([]string{\"\", multiline})\n\t\t\t\t\t} else {\n\t\t\t\t\t\tt.SetFooter([]string{\"woo\", \"waa\"})\n\t\t\t\t\t}\n\t\t\t\t\tt.Render()\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfmt.Println()\n\t}\n\n\t// Output:\n\t// mode 0 autoFmt false autoWrap false reflow false\n\t// +-----+-------------------------------------------+\n\t// | woo |                    waa                    |\n\t// +-----+-------------------------------------------+\n\t// | woo | A multiline                               |\n\t// |     | string with some lines being really long. |\n\t// +-----+-------------------------------------------+\n\t// | woo |                    waa                    |\n\t// +-----+-------------------------------------------+\n\t// mode 0 autoFmt false autoWrap true reflow false\n\t// +-----+--------------------------------+\n\t// | woo |              waa               |\n\t// +-----+--------------------------------+\n\t// | woo | A multiline                    |\n\t// |     |                                |\n\t// |     | string with some lines being   |\n\t// |     | really long.                   |\n\t// +-----+--------------------------------+\n\t// | woo |              waa               |\n\t// +-----+--------------------------------+\n\t// mode 0 autoFmt false autoWrap true reflow true\n\t// +-----+--------------------------------+\n\t// | woo |              waa               |\n\t// +-----+--------------------------------+\n\t// | woo | A multiline string with some   |\n\t// |     | lines being really long.       |\n\t// +-----+--------------------------------+\n\t// | woo |              waa               |\n\t// +-----+--------------------------------+\n\t//\n\t// mode 1 autoFmt false autoWrap false reflow false\n\t// +-----+-------------------------------------------+\n\t// | woo |                A multiline                |\n\t// |     | string with some lines being really long. |\n\t// +-----+-------------------------------------------+\n\t// | woo | waa                                       |\n\t// +-----+-------------------------------------------+\n\t// | woo |                    waa                    |\n\t// +-----+-------------------------------------------+\n\t// mode 1 autoFmt false autoWrap true reflow false\n\t// +-----+--------------------------------+\n\t// | woo |          A multiline           |\n\t// |     |                                |\n\t// |     |  string with some lines being  |\n\t// |     |          really long.          |\n\t// +-----+--------------------------------+\n\t// | woo | waa                            |\n\t// +-----+--------------------------------+\n\t// | woo |              waa               |\n\t// +-----+--------------------------------+\n\t// mode 1 autoFmt false autoWrap true reflow true\n\t// +-----+--------------------------------+\n\t// | woo |  A multiline string with some  |\n\t// |     |    lines being really long.    |\n\t// +-----+--------------------------------+\n\t// | woo | waa                            |\n\t// +-----+--------------------------------+\n\t// | woo |              waa               |\n\t// +-----+--------------------------------+\n\t// mode 1 autoFmt true autoWrap false reflow false\n\t// +-----+-------------------------------------------+\n\t// | WOO |                A MULTILINE                |\n\t// |     | STRING WITH SOME LINES BEING REALLY LONG  |\n\t// +-----+-------------------------------------------+\n\t// | woo | waa                                       |\n\t// +-----+-------------------------------------------+\n\t// | WOO |                    WAA                    |\n\t// +-----+-------------------------------------------+\n\t// mode 1 autoFmt true autoWrap true reflow false\n\t// +-----+--------------------------------+\n\t// | WOO |          A MULTILINE           |\n\t// |     |                                |\n\t// |     |  STRING WITH SOME LINES BEING  |\n\t// |     |          REALLY LONG           |\n\t// +-----+--------------------------------+\n\t// | woo | waa                            |\n\t// +-----+--------------------------------+\n\t// | WOO |              WAA               |\n\t// +-----+--------------------------------+\n\t// mode 1 autoFmt true autoWrap true reflow true\n\t// +-----+--------------------------------+\n\t// | WOO |  A MULTILINE STRING WITH SOME  |\n\t// |     |    LINES BEING REALLY LONG     |\n\t// +-----+--------------------------------+\n\t// | woo | waa                            |\n\t// +-----+--------------------------------+\n\t// | WOO |              WAA               |\n\t// +-----+--------------------------------+\n\t//\n\t// mode 2 autoFmt false autoWrap false reflow false\n\t// +-----+-------------------------------------------+\n\t// | woo |                    waa                    |\n\t// +-----+-------------------------------------------+\n\t// | woo | waa                                       |\n\t// +-----+-------------------------------------------+\n\t// | woo |                A multiline                |\n\t// |     | string with some lines being really long. |\n\t// +-----+-------------------------------------------+\n\t// mode 2 autoFmt false autoWrap true reflow false\n\t// +-----+--------------------------------+\n\t// | woo |              waa               |\n\t// +-----+--------------------------------+\n\t// | woo | waa                            |\n\t// +-----+--------------------------------+\n\t// | woo |          A multiline           |\n\t// |     |                                |\n\t// |     |  string with some lines being  |\n\t// |     |          really long.          |\n\t// +-----+--------------------------------+\n\t// mode 2 autoFmt false autoWrap true reflow true\n\t// +-----+--------------------------------+\n\t// | woo |              waa               |\n\t// +-----+--------------------------------+\n\t// | woo | waa                            |\n\t// +-----+--------------------------------+\n\t// | woo |  A multiline string with some  |\n\t// |     |    lines being really long.    |\n\t// +-----+--------------------------------+\n\t// mode 2 autoFmt true autoWrap false reflow false\n\t// +-----+-------------------------------------------+\n\t// | WOO |                    WAA                    |\n\t// +-----+-------------------------------------------+\n\t// | woo | waa                                       |\n\t// +-----+-------------------------------------------+\n\t// | WOO |                A MULTILINE                |\n\t// |     | STRING WITH SOME LINES BEING REALLY LONG  |\n\t// +-----+-------------------------------------------+\n\t// mode 2 autoFmt true autoWrap true reflow false\n\t// +-----+--------------------------------+\n\t// | WOO |              WAA               |\n\t// +-----+--------------------------------+\n\t// | woo | waa                            |\n\t// +-----+--------------------------------+\n\t// | WOO |          A MULTILINE           |\n\t// |     |                                |\n\t// |     |  STRING WITH SOME LINES BEING  |\n\t// |     |          REALLY LONG           |\n\t// +-----+--------------------------------+\n\t// mode 2 autoFmt true autoWrap true reflow true\n\t// +-----+--------------------------------+\n\t// | WOO |              WAA               |\n\t// +-----+--------------------------------+\n\t// | woo | waa                            |\n\t// +-----+--------------------------------+\n\t// | WOO |  A MULTILINE STRING WITH SOME  |\n\t// |     |    LINES BEING REALLY LONG     |\n\t// +-----+--------------------------------+\n\t//\n\t// mode 3 autoFmt false autoWrap false reflow false\n\t// +-----+-------------------------------------------+\n\t// | woo |                    waa                    |\n\t// +-----+-------------------------------------------+\n\t// | woo | waa                                       |\n\t// +-----+-------------------------------------------+\n\t// |                      A multiline                |\n\t// |       string with some lines being really long. |\n\t// +-----+-------------------------------------------+\n\t// mode 3 autoFmt false autoWrap true reflow false\n\t// +-----+--------------------------------+\n\t// | woo |              waa               |\n\t// +-----+--------------------------------+\n\t// | woo | waa                            |\n\t// +-----+--------------------------------+\n\t// |                A multiline           |\n\t// |                                      |\n\t// |        string with some lines being  |\n\t// |                really long.          |\n\t// +-----+--------------------------------+\n\t// mode 3 autoFmt false autoWrap true reflow true\n\t// +-----+--------------------------------+\n\t// | woo |              waa               |\n\t// +-----+--------------------------------+\n\t// | woo | waa                            |\n\t// +-----+--------------------------------+\n\t// |        A multiline string with some  |\n\t// |          lines being really long.    |\n\t// +-----+--------------------------------+\n\t// mode 3 autoFmt true autoWrap false reflow false\n\t// +-----+-------------------------------------------+\n\t// | WOO |                    WAA                    |\n\t// +-----+-------------------------------------------+\n\t// | woo | waa                                       |\n\t// +-----+-------------------------------------------+\n\t// |                      A MULTILINE                |\n\t// |       STRING WITH SOME LINES BEING REALLY LONG  |\n\t// +-----+-------------------------------------------+\n\t// mode 3 autoFmt true autoWrap true reflow false\n\t// +-----+--------------------------------+\n\t// | WOO |              WAA               |\n\t// +-----+--------------------------------+\n\t// | woo | waa                            |\n\t// +-----+--------------------------------+\n\t// |                A MULTILINE           |\n\t// |                                      |\n\t// |        STRING WITH SOME LINES BEING  |\n\t// |                REALLY LONG           |\n\t// +-----+--------------------------------+\n\t// mode 3 autoFmt true autoWrap true reflow true\n\t// +-----+--------------------------------+\n\t// | WOO |              WAA               |\n\t// +-----+--------------------------------+\n\t// | woo | waa                            |\n\t// +-----+--------------------------------+\n\t// |        A MULTILINE STRING WITH SOME  |\n\t// |          LINES BEING REALLY LONG     |\n\t// +-----+--------------------------------+\n}\n\nfunc TestPrintLine(t *testing.T) {\n\theader := make([]string, 12)\n\tval := \" \"\n\twant := \"\"\n\tfor i := range header {\n\t\theader[i] = val\n\t\twant = fmt.Sprintf(\"%s+-%s-\", want, strings.Replace(val, \" \", \"-\", -1))\n\t\tval = val + \" \"\n\t}\n\twant = want + \"+\\n\"\n\tvar buf bytes.Buffer\n\ttable := NewWriter(&buf)\n\ttable.SetHeader(header)\n\ttable.printLine(false, false)\n\tcheckEqual(t, buf.String(), want, \"line rendering failed\")\n}\n\nfunc TestAnsiStrip(t *testing.T) {\n\theader := make([]string, 12)\n\tval := \" \"\n\twant := \"\"\n\tfor i := range header {\n\t\theader[i] = \"\\033[43;30m\" + val + \"\\033[00m\"\n\t\twant = fmt.Sprintf(\"%s+-%s-\", want, strings.Replace(val, \" \", \"-\", -1))\n\t\tval = val + \" \"\n\t}\n\twant = want + \"+\\n\"\n\tvar buf bytes.Buffer\n\ttable := NewWriter(&buf)\n\ttable.SetHeader(header)\n\ttable.printLine(false, false)\n\tcheckEqual(t, buf.String(), want, \"line rendering failed\")\n}\n\nfunc NewCustomizedTable(out io.Writer) *Table {\n\ttable := NewWriter(out)\n\ttable.SetCenterSeparator(\"\")\n\ttable.SetColumnSeparator(\"\")\n\ttable.SetRowSeparator(\"\")\n\ttable.EnableBorder(false)\n\ttable.SetAlignment(ALIGN_LEFT)\n\ttable.SetHeader([]string{})\n\treturn table\n}\n\nfunc TestSubclass(t *testing.T) {\n\tbuf := new(bytes.Buffer)\n\ttable := NewCustomizedTable(buf)\n\n\tdata := [][]string{\n\t\t{\"A\", \"The Good\", \"500\"},\n\t\t{\"B\", \"The Very very Bad Man\", \"288\"},\n\t\t{\"C\", \"The Ugly\", \"120\"},\n\t\t{\"D\", \"The Gopher\", \"800\"},\n\t}\n\n\tfor _, v := range data {\n\t\ttable.Append(v)\n\t}\n\ttable.Render()\n\n\twant := `  A  The Good               500  \n  B  The Very very Bad Man  288  \n  C  The Ugly               120  \n  D  The Gopher             800  \n`\n\tcheckEqual(t, buf.String(), want, \"test subclass failed\")\n}\n\nfunc TestAutoMergeRows(t *testing.T) {\n\tdata := [][]string{\n\t\t{\"A\", \"The Good\", \"500\"},\n\t\t{\"A\", \"The Very very Bad Man\", \"288\"},\n\t\t{\"B\", \"The Very very Bad Man\", \"120\"},\n\t\t{\"B\", \"The Very very Bad Man\", \"200\"},\n\t}\n\tvar buf bytes.Buffer\n\ttable := NewWriter(&buf)\n\ttable.SetHeader([]string{\"Name\", \"Sign\", \"Rating\"})\n\n\tfor _, v := range data {\n\t\ttable.Append(v)\n\t}\n\ttable.SetAutoMergeCells(true)\n\ttable.Render()\n\twant := `+------+-----------------------+--------+\n| NAME |         SIGN          | RATING |\n+------+-----------------------+--------+\n| A    | The Good              |    500 |\n|      | The Very very Bad Man |    288 |\n| B    |                       |    120 |\n|      |                       |    200 |\n+------+-----------------------+--------+\n`\n\tgot := buf.String()\n\tif got != want {\n\t\tt.Errorf(\"\\ngot:\\n%s\\nwant:\\n%s\\n\", got, want)\n\t}\n\n\tbuf.Reset()\n\ttable = NewWriter(&buf)\n\ttable.SetHeader([]string{\"Name\", \"Sign\", \"Rating\"})\n\n\tfor _, v := range data {\n\t\ttable.Append(v)\n\t}\n\ttable.SetAutoMergeCells(true)\n\ttable.SetRowLine(true)\n\ttable.Render()\n\twant = `+------+-----------------------+--------+\n| NAME |         SIGN          | RATING |\n+------+-----------------------+--------+\n| A    | The Good              |    500 |\n+      +-----------------------+--------+\n|      | The Very very Bad Man |    288 |\n+------+                       +--------+\n| B    |                       |    120 |\n+      +                       +--------+\n|      |                       |    200 |\n+------+-----------------------+--------+\n`\n\tcheckEqual(t, buf.String(), want)\n\n\tbuf.Reset()\n\ttable = NewWriter(&buf)\n\ttable.SetHeader([]string{\"Name\", \"Sign\", \"Rating\"})\n\n\tdataWithlongText := [][]string{\n\t\t{\"A\", \"The Good\", \"500\"},\n\t\t{\"A\", \"The Very very very very very Bad Man\", \"288\"},\n\t\t{\"B\", \"The Very very very very very Bad Man\", \"120\"},\n\t\t{\"C\", \"The Very very Bad Man\", \"200\"},\n\t}\n\ttable.AppendBulk(dataWithlongText)\n\ttable.SetAutoMergeCells(true)\n\ttable.SetRowLine(true)\n\ttable.Render()\n\twant = `+------+--------------------------------+--------+\n| NAME |              SIGN              | RATING |\n+------+--------------------------------+--------+\n| A    | The Good                       |    500 |\n+      +--------------------------------+--------+\n|      | The Very very very very very   |    288 |\n|      | Bad Man                        |        |\n+------+                                +--------+\n| B    |                                |    120 |\n|      |                                |        |\n+------+--------------------------------+--------+\n| C    | The Very very Bad Man          |    200 |\n+------+--------------------------------+--------+\n`\n\tcheckEqual(t, buf.String(), want)\n\n\tbuf.Reset()\n\ttable = NewWriter(&buf)\n\ttable.SetHeader([]string{\"Name\", \"Sign\", \"Rating\"})\n\n\tdataWithlongText2 := [][]string{\n\t\t{\"A\", \"The Good\", \"500\"},\n\t\t{\"A\", \"The Very very very very very Bad Man\", \"288\"},\n\t\t{\"B\", \"The Very very Bad Man\", \"120\"},\n\t}\n\ttable.AppendBulk(dataWithlongText2)\n\ttable.SetAutoMergeCells(true)\n\ttable.SetRowLine(true)\n\ttable.Render()\n\twant = `+------+--------------------------------+--------+\n| NAME |              SIGN              | RATING |\n+------+--------------------------------+--------+\n| A    | The Good                       |    500 |\n+      +--------------------------------+--------+\n|      | The Very very very very very   |    288 |\n|      | Bad Man                        |        |\n+------+--------------------------------+--------+\n| B    | The Very very Bad Man          |    120 |\n+------+--------------------------------+--------+\n`\n\tcheckEqual(t, buf.String(), want)\n}\n\nfunc TestAutoMergeRowsUnicode(t *testing.T) {\n\tdata := [][]string{\n\t\t{\"A\", \"The Good\", \"500\"},\n\t\t{\"A\", \"The Very very Bad Man\", \"288\"},\n\t\t{\"B\", \"The Very very Bad Man\", \"120\"},\n\t\t{\"B\", \"The Very very Bad Man\", \"200\"},\n\t}\n\tvar buf bytes.Buffer\n\tbuf.WriteRune('\\n') // Makes the want literal easier to read.\n\ttable := NewWriter(&buf)\n\ttable.SetHeader([]string{\"Name\", \"Sign\", \"Rating\"})\n\ttable.AppendBulk(data)\n\ttable.SetAutoMergeCells(true)\n\ttable.SetRowLine(true)\n\ttable.SetUnicodeHV(Regular, Regular)\n\ttable.Render()\n\twant := `\n┌──────┬───────────────────────┬────────┐\n│ NAME │         SIGN          │ RATING │\n├──────┼───────────────────────┼────────┤\n│ A    │ The Good              │    500 │\n│      ├───────────────────────┼────────┤\n│      │ The Very very Bad Man │    288 │\n├──────┤                       ├────────┤\n│ B    │                       │    120 │\n│      │                       ├────────┤\n│      │                       │    200 │\n└──────┴───────────────────────┴────────┘\n`\n\t// The above is what we actually would prefer, but the below is what the code\n\t// currently generates. Fixes welcome.\n\twant = `\n┌──────┬───────────────────────┬────────┐\n│ NAME │         SIGN          │ RATING │\n├──────┼───────────────────────┼────────┤\n│ A    │ The Good              │    500 │\n├      ┼───────────────────────┼────────┤\n│      │ The Very very Bad Man │    288 │\n├──────┼                       ┼────────┤\n│ B    │                       │    120 │\n├      ┼                       ┼────────┤\n│      │                       │    200 │\n└──────┴───────────────────────┴────────┘\n`\n\tcheckEqual(t, buf.String(), want)\n}\n\nfunc TestClearRows(t *testing.T) {\n\tdata := [][]string{\n\t\t{\"1/1/2014\", \"Domain name\", \"2233\", \"$10.98\"},\n\t}\n\n\tvar buf bytes.Buffer\n\ttable := NewWriter(&buf)\n\ttable.SetAutoWrapText(false)\n\ttable.SetHeader([]string{\"Date\", \"Description\", \"CV2\", \"Amount\"})\n\ttable.SetFooter([]string{\"\", \"\", \"Total\", \"$145.93\"}) // Add Footer\n\ttable.AppendBulk(data)                                // Add Bulk Data\n\ttable.Render()\n\n\toriginalWant := `+----------+-------------+-------+---------+\n|   DATE   | DESCRIPTION |  CV2  | AMOUNT  |\n+----------+-------------+-------+---------+\n| 1/1/2014 | Domain name |  2233 | $10.98  |\n+----------+-------------+-------+---------+\n|                          TOTAL | $145.93 |\n+----------+-------------+-------+---------+\n`\n\twant := originalWant\n\n\tcheckEqual(t, buf.String(), want, \"table clear rows failed\")\n\n\tbuf.Reset()\n\ttable.ClearRows()\n\ttable.Render()\n\n\twant = `+----------+-------------+-------+---------+\n|   DATE   | DESCRIPTION |  CV2  | AMOUNT  |\n+----------+-------------+-------+---------+\n+----------+-------------+-------+---------+\n|                          TOTAL | $145.93 |\n+----------+-------------+-------+---------+\n`\n\n\tcheckEqual(t, buf.String(), want, \"table clear rows failed\")\n\n\tbuf.Reset()\n\ttable.AppendBulk(data) // Add Bulk Data\n\ttable.Render()\n\n\twant = `+----------+-------------+-------+---------+\n|   DATE   | DESCRIPTION |  CV2  | AMOUNT  |\n+----------+-------------+-------+---------+\n| 1/1/2014 | Domain name |  2233 | $10.98  |\n+----------+-------------+-------+---------+\n|                          TOTAL | $145.93 |\n+----------+-------------+-------+---------+\n`\n\n\tcheckEqual(t, buf.String(), want, \"table clear rows failed\")\n}\n\nfunc TestClearFooters(t *testing.T) {\n\tdata := [][]string{\n\t\t{\"1/1/2014\", \"Domain name\", \"2233\", \"$10.98\"},\n\t}\n\n\tvar buf bytes.Buffer\n\ttable := NewWriter(&buf)\n\ttable.SetAutoWrapText(false)\n\ttable.SetHeader([]string{\"Date\", \"Description\", \"CV2\", \"Amount\"})\n\ttable.SetFooter([]string{\"\", \"\", \"Total\", \"$145.93\"}) // Add Footer\n\ttable.AppendBulk(data)                                // Add Bulk Data\n\ttable.Render()\n\n\tbuf.Reset()\n\ttable.ClearFooter()\n\ttable.Render()\n\n\twant := `+----------+-------------+-------+---------+\n|   DATE   | DESCRIPTION |  CV2  | AMOUNT  |\n+----------+-------------+-------+---------+\n| 1/1/2014 | Domain name |  2233 | $10.98  |\n+----------+-------------+-------+---------+\n`\n\n\tcheckEqual(t, buf.String(), want)\n}\n\nfunc TestMoreDataColumnsThanHeaders(t *testing.T) {\n\tvar (\n\t\tbuf    = &bytes.Buffer{}\n\t\ttable  = NewWriter(buf)\n\t\theader = []string{\"A\", \"B\", \"C\"}\n\t\tdata   = [][]string{\n\t\t\t{\"a\", \"b\", \"c\", \"d\"},\n\t\t\t{\"1\", \"2\", \"3\", \"4\"},\n\t\t}\n\t\twant = `+---+---+---+---+\n| A | B | C |   |\n+---+---+---+---+\n| a | b | c | d |\n| 1 | 2 | 3 | 4 |\n+---+---+---+---+\n`\n\t)\n\ttable.SetHeader(header)\n\t// table.SetFooter(ctx.tableCtx.footer)\n\ttable.AppendBulk(data)\n\ttable.Render()\n\n\tcheckEqual(t, buf.String(), want)\n}\n\nfunc TestMoreFooterColumnsThanHeaders(t *testing.T) {\n\tvar (\n\t\tbuf    = &bytes.Buffer{}\n\t\ttable  = NewWriter(buf)\n\t\theader = []string{\"A\", \"B\", \"C\"}\n\t\tdata   = [][]string{\n\t\t\t{\"a\", \"b\", \"c\", \"d\"},\n\t\t\t{\"1\", \"2\", \"3\", \"4\"},\n\t\t}\n\t\tfooter = []string{\"a\", \"b\", \"c\", \"d\", \"e\"}\n\t\twant   = `+---+---+---+---+---+\n| A | B | C |   |   |\n+---+---+---+---+---+\n| a | b | c | d |\n| 1 | 2 | 3 | 4 |\n+---+---+---+---+---+\n| A | B | C | D | E |\n+---+---+---+---+---+\n`\n\t)\n\ttable.SetHeader(header)\n\ttable.SetFooter(footer)\n\ttable.AppendBulk(data)\n\ttable.Render()\n\n\tcheckEqual(t, buf.String(), want)\n}\n\nfunc TestLessFooterColumnsThanHeaders(t *testing.T) {\n\tvar (\n\t\tbuf    = &bytes.Buffer{}\n\t\ttable  = NewWriter(buf)\n\t\theader = []string{\"A\", \"B\", \"C\"}\n\t\tdata   = [][]string{\n\t\t\t{\"1\", \"2\", \"3\"},\n\t\t}\n\t\tfooter = []string{\"a\", \"b\"}\n\t\twant   = `+---+---+---+\n| A | B | C |\n+---+---+---+\n| 1 | 2 | 3 |\n+---+---+---+\n| A | B |   |\n+---+---+---+\n`\n\t)\n\ttable.SetHeader(header)\n\ttable.SetFooter(footer)\n\ttable.AppendBulk(data)\n\ttable.Render()\n\n\tcheckEqual(t, buf.String(), want)\n}\n\nfunc TestSetColMinWidth(t *testing.T) {\n\tvar (\n\t\tbuf    = &bytes.Buffer{}\n\t\ttable  = NewWriter(buf)\n\t\theader = []string{\"AAA\", \"BBB\", \"CCC\"}\n\t\tdata   = [][]string{\n\t\t\t{\"a\", \"b\", \"c\"},\n\t\t\t{\"1\", \"2\", \"3\"},\n\t\t}\n\t\tfooter = []string{\"a\", \"b\", \"cccc\"}\n\t\twant   = `+-----+-----+-------+\n| AAA | BBB |  CCC  |\n+-----+-----+-------+\n| a   | b   | c     |\n|   1 |   2 |     3 |\n+-----+-----+-------+\n|  A  |  B  | CCCC  |\n+-----+-----+-------+\n`\n\t)\n\ttable.SetHeader(header)\n\ttable.SetFooter(footer)\n\ttable.AppendBulk(data)\n\ttable.SetColMinWidth(2, 5)\n\ttable.Render()\n\n\tcheckEqual(t, buf.String(), want)\n}\n\nfunc TestWrapString(t *testing.T) {\n\twant := []string{\"ああああああああああああああああああああああああ\", \"あああああああ\"}\n\tgot, _ := WrapString(\"ああああああああああああああああああああああああ あああああああ\", 55)\n\tcheckEqual(t, got, want)\n}\n\nfunc TestNumberAlign(t *testing.T) {\n\tvar (\n\t\tbuf   = &bytes.Buffer{}\n\t\ttable = NewWriter(buf)\n\t\tdata  = [][]string{\n\t\t\t{\"AAAAAAAAAAAAA\", \"BBBBBBBBBBBBB\", \"CCCCCCCCCCCCCC\"},\n\t\t\t{\"A\", \"B\", \"C\"},\n\t\t\t{\"123456789\", \"2\", \"3\"},\n\t\t\t{\"1\", \"2\", \"123,456,789\"},\n\t\t\t{\"1\", \"123,456.789\", \"3\"},\n\t\t\t{\"-123,456\", \"-2\", \"-3\"},\n\t\t}\n\t\twant = `+---------------+---------------+----------------+\n| AAAAAAAAAAAAA | BBBBBBBBBBBBB | CCCCCCCCCCCCCC |\n| A             | B             | C              |\n|     123456789 |             2 |              3 |\n|             1 |             2 |    123,456,789 |\n|             1 |   123,456.789 |              3 |\n|      -123,456 |            -2 |             -3 |\n+---------------+---------------+----------------+\n`\n\t)\n\ttable.AppendBulk(data)\n\ttable.Render()\n\n\tcheckEqual(t, buf.String(), want)\n}\n\nfunc TestCustomAlign(t *testing.T) {\n\tvar (\n\t\tbuf    = &bytes.Buffer{}\n\t\ttable  = NewWriter(buf)\n\t\theader = []string{\"AAA\", \"BBB\", \"CCC\"}\n\t\tdata   = [][]string{\n\t\t\t{\"a\", \"b\", \"c\"},\n\t\t\t{\"1\", \"2\", \"3\"},\n\t\t}\n\t\tfooter = []string{\"a\", \"b\", \"cccc\"}\n\t\twant   = `+-----+-----+-------+\n| AAA | BBB |  CCC  |\n+-----+-----+-------+\n| a   |  b  |     c |\n| 1   |  2  |     3 |\n+-----+-----+-------+\n|  A  |  B  | CCCC  |\n+-----+-----+-------+\n`\n\t)\n\ttable.SetHeader(header)\n\ttable.SetFooter(footer)\n\ttable.AppendBulk(data)\n\ttable.SetColMinWidth(2, 5)\n\ttable.SetColumnAlignment([]int{ALIGN_LEFT, ALIGN_CENTER, ALIGN_RIGHT})\n\ttable.Render()\n\n\tcheckEqual(t, buf.String(), want)\n}\n\nfunc TestTitle(t *testing.T) {\n\tts := []struct {\n\t\ttext string\n\t\twant string\n\t}{\n\t\t{\"\", \"\"},\n\t\t{\"foo\", \"FOO\"},\n\t\t{\"Foo\", \"FOO\"},\n\t\t{\"foO\", \"FOO\"},\n\t\t{\".foo\", \"FOO\"},\n\t\t{\"foo.\", \"FOO\"},\n\t\t{\".foo.\", \"FOO\"},\n\t\t{\".foo.bar.\", \"FOO BAR\"},\n\t\t{\"_foo\", \"FOO\"},\n\t\t{\"foo_\", \"FOO\"},\n\t\t{\"_foo_\", \"FOO\"},\n\t\t{\"_foo_bar_\", \"FOO BAR\"},\n\t\t{\" foo\", \"FOO\"},\n\t\t{\"foo \", \"FOO\"},\n\t\t{\" foo \", \"FOO\"},\n\t\t{\" foo bar \", \"FOO BAR\"},\n\t\t{\"0.1\", \"0.1\"},\n\t\t{\"FOO 0.1\", \"FOO 0.1\"},\n\t\t{\".1 0.1\", \".1 0.1\"},\n\t\t{\"1. 0.1\", \"1. 0.1\"},\n\t\t{\"1. 0.\", \"1. 0.\"},\n\t\t{\".1. 0.\", \".1. 0.\"},\n\t\t{\".$ . $.\", \"$ . $\"},\n\t\t{\".$. $.\", \"$  $\"},\n\t}\n\tfor _, tt := range ts {\n\t\tgot := Title(tt.text)\n\t\tif got != tt.want {\n\t\t\tt.Errorf(\"want %q, bot got %q\", tt.want, got)\n\t\t}\n\t}\n}\n\nfunc TestKubeFormat(t *testing.T) {\n\tdata := [][]string{\n\t\t{\"1/1/2014\", \"jan_hosting\", \"2233\", \"$10.98\"},\n\t\t{\"1/1/2014\", \"feb_hosting\", \"2233\", \"$54.95\"},\n\t\t{\"1/4/2014\", \"feb_extra_bandwidth\", \"2233\", \"$51.00\"},\n\t\t{\"1/4/2014\", \"mar_hosting\", \"2233\", \"$30.00\"},\n\t}\n\n\tvar buf bytes.Buffer\n\ttable := NewWriter(&buf)\n\ttable.SetHeader([]string{\"Date\", \"Description\", \"CV2\", \"Amount\"})\n\ttable.SetAutoWrapText(false)\n\ttable.SetAutoFormatHeaders(true)\n\ttable.SetHeaderAlignment(ALIGN_LEFT)\n\ttable.SetAlignment(ALIGN_LEFT)\n\ttable.SetCenterSeparator(\"\")\n\ttable.SetColumnSeparator(\"\")\n\ttable.SetRowSeparator(\"\")\n\ttable.SetHeaderLine(false)\n\ttable.EnableBorder(false)\n\ttable.SetTablePadding(\"\\t\") // pad with tabs\n\ttable.SetNoWhiteSpace(true)\n\ttable.AppendBulk(data) // Add Bulk Data\n\ttable.Render()\n\n\twant := `DATE    \tDESCRIPTION        \tCV2 \tAMOUNT \n1/1/2014\tjan_hosting        \t2233\t$10.98\t\n1/1/2014\tfeb_hosting        \t2233\t$54.95\t\n1/4/2014\tfeb_extra_bandwidth\t2233\t$51.00\t\n1/4/2014\tmar_hosting        \t2233\t$30.00\t\n`\n\n\tcheckEqual(t, buf.String(), want, \"kube format rendering failed\")\n}\n\ntype testStringerType struct{}\n\nfunc (t testStringerType) String() string { return \"testStringerType\" }\n\nfunc TestStructs(t *testing.T) {\n\ttype testType struct {\n\t\tA string\n\t\tB int\n\t\tC testStringerType\n\t\tD bool `tablewriter:\"DD\"`\n\t}\n\ttype testType2 struct {\n\t\tA *string\n\t\tB *int\n\t\tC *testStringerType\n\t\tD *bool `tablewriter:\"DD\"`\n\t}\n\ttype testType3 struct {\n\t\tA **string\n\t\tB **int\n\t\tC **testStringerType\n\t\tD **bool `tablewriter:\"DD\"`\n\t}\n\ta := \"a\"\n\tb := 1\n\tc := testStringerType{}\n\td := true\n\n\tap := &a\n\tbp := &b\n\tcp := &c\n\tdp := &d\n\n\ttests := []struct {\n\t\tname    string\n\t\tvalues  interface{}\n\t\twantErr bool\n\t\twant    string\n\t}{\n\t\t{\n\t\t\tname: \"slice of struct\",\n\t\t\tvalues: []testType{\n\t\t\t\t{A: \"AAA\", B: 11, D: true},\n\t\t\t\t{A: \"BBB\", B: 22},\n\t\t\t},\n\t\t\twant: `\n+-----+----+------------------+-------+\n|  A  | B  |        C         |  DD   |\n+-----+----+------------------+-------+\n| AAA | 11 | testStringerType | true  |\n| BBB | 22 | testStringerType | false |\n+-----+----+------------------+-------+\n`,\n\t\t},\n\t\t{\n\t\t\tname: \"slice of struct pointer\",\n\t\t\tvalues: []*testType{\n\t\t\t\t{A: \"AAA\", B: 11, D: true},\n\t\t\t\t{A: \"BBB\", B: 22},\n\t\t\t},\n\t\t\twant: `\n+-----+----+------------------+-------+\n|  A  | B  |        C         |  DD   |\n+-----+----+------------------+-------+\n| AAA | 11 | testStringerType | true  |\n| BBB | 22 | testStringerType | false |\n+-----+----+------------------+-------+\n`,\n\t\t},\n\t\t{\n\t\t\tname: \"pointer field\",\n\t\t\tvalues: []*testType2{\n\t\t\t\t{A: &a, B: &b, C: &c, D: &d},\n\t\t\t},\n\t\t\twant: `\n+---+---+------------------+------+\n| A | B |        C         |  DD  |\n+---+---+------------------+------+\n| a | 1 | testStringerType | true |\n+---+---+------------------+------+\n`,\n\t\t},\n\t\t{\n\t\t\tname: \"nil pointer field\",\n\t\t\tvalues: []*testType2{\n\t\t\t\t{A: nil, B: nil, C: nil, D: nil},\n\t\t\t},\n\t\t\twant: `\n+-----+-----+-----+-----+\n|  A  |  B  |  C  | DD  |\n+-----+-----+-----+-----+\n| nil | nil | nil | nil |\n+-----+-----+-----+-----+\n`,\n\t\t},\n\t\t{\n\t\t\tname: \"typed nil pointer field\",\n\t\t\tvalues: []*testType2{\n\t\t\t\t{A: (*string)(nil), B: (*int)(nil), C: (*testStringerType)(nil), D: (*bool)(nil)},\n\t\t\t},\n\t\t\twant: `\n+-----+-----+-----+-----+\n|  A  |  B  |  C  | DD  |\n+-----+-----+-----+-----+\n| nil | nil | nil | nil |\n+-----+-----+-----+-----+\n`,\n\t\t},\n\t\t{\n\t\t\tname: \"pointer of pointer field\",\n\t\t\tvalues: []*testType3{\n\t\t\t\t{A: &ap, B: &bp, C: &cp, D: &dp},\n\t\t\t},\n\t\t\twant: `\n+---+---+------------------+------+\n| A | B |        C         |  DD  |\n+---+---+------------------+------+\n| a | 1 | testStringerType | true |\n+---+---+------------------+------+\n`,\n\t\t},\n\t\t{\n\t\t\tname:    \"invalid input\",\n\t\t\tvalues:  interface{}(1),\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname:    \"invalid input\",\n\t\t\tvalues:  testType{},\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname:    \"invalid input\",\n\t\t\tvalues:  &testType{},\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname:    \"nil value\",\n\t\t\tvalues:  nil,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname:    \"the first element is nil\",\n\t\t\tvalues:  []*testType{nil, nil},\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname:    \"empty slice\",\n\t\t\tvalues:  []testType{},\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"mixed slice\", // TODO: Should we support this case?\n\t\t\tvalues: []interface{}{\n\t\t\t\ttestType{A: \"a\", B: 2, C: c, D: false},\n\t\t\t\ttestType2{A: &a, B: &b, C: &c, D: &d},\n\t\t\t\ttestType3{A: &ap, B: &bp, C: &cp, D: &dp},\n\t\t\t},\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"skip nil element\",\n\t\t\tvalues: []*testType{\n\t\t\t\t{A: \"a\", B: 1, D: true},\n\t\t\t\tnil,\n\t\t\t\tnil,\n\t\t\t\t{A: \"A\", B: 3, D: false},\n\t\t\t},\n\t\t\twant: `\n+---+---+------------------+-------+\n| A | B |        C         |  DD   |\n+---+---+------------------+-------+\n| a | 1 | testStringerType | true  |\n| A | 3 | testStringerType | false |\n+---+---+------------------+-------+\n`,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tvar buf bytes.Buffer\n\t\t\ttable := NewWriter(&buf)\n\t\t\terr := table.SetStructs(tt.values)\n\t\t\tif tt.wantErr != (err != nil) {\n\t\t\t\tt.Fatal(tt.wantErr, err)\n\t\t\t}\n\t\t\tif tt.wantErr {\n\t\t\t\tt.Log(err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\ttable.Render()\n\t\t\tcheckEqual(t, buf.String(), strings.TrimPrefix(tt.want, \"\\n\"))\n\t\t})\n\t}\n}\n"
        },
        {
          "name": "table_unicode.go",
          "type": "blob",
          "size": 1.55859375,
          "content": "package tablewriter\n\nimport \"errors\"\n\ntype UnicodeLineStyle int\n\nconst (\n\tRegular UnicodeLineStyle = iota\n\tThick\n\tDouble\n)\n\nconst (\n\tsymsRR = \"─│┌┐└┘├┤┬┴┼\"\n\tsymsTT = \"━┃┏┓┗┛┣┫┳┻╋\"\n\tsymsDD = \"═║╔╗╚╝╠╣╦╩╬\"\n\tsymsRT = \"─┃┎┒┖┚┠┨┰┸╂\"\n\tsymsTR = \"━│┍┑┕┙┝┥┯┷┿\"\n\tsymsRD = \"─║╓╖╙╜╟╢╥╨╫\"\n\tsymsDR = \"═│╒╕╘╛╞╡╤╧╪\"\n)\n\nfunc simpleSyms(center, row, column string) []string {\n\treturn []string{row, column, center, center, center, center, center, center, center, center, center}\n}\n\n// Use unicode box drawing symbols to achieve the specified line styles.\n// Note that combinations of thick and double lines are not supported.\n// Will return an error in case of unsupported combinations.\nfunc (t *Table) SetUnicodeHV(horizontal, vertical UnicodeLineStyle) error {\n\tvar syms string\n\tswitch {\n\tcase horizontal == Regular && vertical == Regular:\n\t\tsyms = symsRR\n\tcase horizontal == Thick && vertical == Thick:\n\t\tsyms = symsTT\n\tcase horizontal == Double && vertical == Double:\n\t\tsyms = symsDD\n\tcase horizontal == Regular && vertical == Thick:\n\t\tsyms = symsRT\n\tcase horizontal == Thick && vertical == Regular:\n\t\tsyms = symsTR\n\tcase horizontal == Regular && vertical == Double:\n\t\tsyms = symsRD\n\tcase horizontal == Double && vertical == Regular:\n\t\tsyms = symsDR\n\tdefault:\n\t\treturn errors.New(\"Unsupported combination of unicode line styles\")\n\t}\n\tt.syms = make([]string, 0, 11)\n\tfor _, sym := range []rune(syms) {\n\t\tt.syms = append(t.syms, string(sym))\n\t}\n\treturn nil\n}\n"
        },
        {
          "name": "table_with_color.go",
          "type": "blob",
          "size": 2.4609375,
          "content": "package tablewriter\n\nimport (\n\t\"fmt\"\n\t\"strconv\"\n\t\"strings\"\n)\n\nconst ESC = \"\\033\"\nconst SEP = \";\"\n\nconst (\n\tBgBlackColor int = iota + 40\n\tBgRedColor\n\tBgGreenColor\n\tBgYellowColor\n\tBgBlueColor\n\tBgMagentaColor\n\tBgCyanColor\n\tBgWhiteColor\n)\n\nconst (\n\tFgBlackColor int = iota + 30\n\tFgRedColor\n\tFgGreenColor\n\tFgYellowColor\n\tFgBlueColor\n\tFgMagentaColor\n\tFgCyanColor\n\tFgWhiteColor\n)\n\nconst (\n\tBgHiBlackColor int = iota + 100\n\tBgHiRedColor\n\tBgHiGreenColor\n\tBgHiYellowColor\n\tBgHiBlueColor\n\tBgHiMagentaColor\n\tBgHiCyanColor\n\tBgHiWhiteColor\n)\n\nconst (\n\tFgHiBlackColor int = iota + 90\n\tFgHiRedColor\n\tFgHiGreenColor\n\tFgHiYellowColor\n\tFgHiBlueColor\n\tFgHiMagentaColor\n\tFgHiCyanColor\n\tFgHiWhiteColor\n)\n\nconst (\n\tNormal          = 0\n\tBold            = 1\n\tUnderlineSingle = 4\n\tItalic\n)\n\ntype Colors []int\n\nfunc startFormat(seq string) string {\n\treturn fmt.Sprintf(\"%s[%sm\", ESC, seq)\n}\n\nfunc stopFormat() string {\n\treturn fmt.Sprintf(\"%s[%dm\", ESC, Normal)\n}\n\n// Making the SGR (Select Graphic Rendition) sequence.\nfunc makeSequence(codes []int) string {\n\tcodesInString := []string{}\n\tfor _, code := range codes {\n\t\tcodesInString = append(codesInString, strconv.Itoa(code))\n\t}\n\treturn strings.Join(codesInString, SEP)\n}\n\n// Adding ANSI escape  sequences before and after string\nfunc format(s string, codes interface{}) string {\n\tvar seq string\n\n\tswitch v := codes.(type) {\n\n\tcase string:\n\t\tseq = v\n\tcase []int:\n\t\tseq = makeSequence(v)\n\tcase Colors:\n\t\tseq = makeSequence(v)\n\tdefault:\n\t\treturn s\n\t}\n\n\tif len(seq) == 0 {\n\t\treturn s\n\t}\n\treturn startFormat(seq) + s + stopFormat()\n}\n\n// Adding header colors (ANSI codes)\nfunc (t *Table) SetHeaderColor(colors ...Colors) {\n\tif t.colSize != len(colors) {\n\t\tpanic(\"Number of header colors must be equal to number of headers.\")\n\t}\n\tfor i := 0; i < len(colors); i++ {\n\t\tt.headerParams = append(t.headerParams, makeSequence(colors[i]))\n\t}\n}\n\n// Adding column colors (ANSI codes)\nfunc (t *Table) SetColumnColor(colors ...Colors) {\n\tif t.colSize != len(colors) {\n\t\tpanic(\"Number of column colors must be equal to number of headers.\")\n\t}\n\tfor i := 0; i < len(colors); i++ {\n\t\tt.columnsParams = append(t.columnsParams, makeSequence(colors[i]))\n\t}\n}\n\n// Adding column colors (ANSI codes)\nfunc (t *Table) SetFooterColor(colors ...Colors) {\n\tif len(t.footers) != len(colors) {\n\t\tpanic(\"Number of footer colors must be equal to number of footer.\")\n\t}\n\tfor i := 0; i < len(colors); i++ {\n\t\tt.footerParams = append(t.footerParams, makeSequence(colors[i]))\n\t}\n}\n\nfunc Color(colors ...int) []int {\n\treturn colors\n}\n"
        },
        {
          "name": "testdata",
          "type": "tree",
          "content": null
        },
        {
          "name": "util.go",
          "type": "blob",
          "size": 2.23828125,
          "content": "// Copyright 2014 Oleku Konko All rights reserved.\n// Use of this source code is governed by a MIT\n// license that can be found in the LICENSE file.\n\n// This module is a Table Writer  API for the Go Programming Language.\n// The protocols were written in pure Go and works on windows and unix systems\n\npackage tablewriter\n\nimport (\n\t\"math\"\n\t\"regexp\"\n\t\"strings\"\n\n\t\"github.com/mattn/go-runewidth\"\n)\n\nvar ansi = regexp.MustCompile(\"\\033\\\\[(?:[0-9]{1,3}(?:;[0-9]{1,3})*)?[m|K]\")\n\nfunc DisplayWidth(str string) int {\n\treturn runewidth.StringWidth(ansi.ReplaceAllLiteralString(str, \"\"))\n}\n\n// ConditionString Simple Condition for string\n// Returns value based on condition\nfunc ConditionString(cond bool, valid, inValid string) string {\n\tif cond {\n\t\treturn valid\n\t}\n\treturn inValid\n}\n\nfunc isNumOrSpace(r rune) bool {\n\treturn ('0' <= r && r <= '9') || r == ' '\n}\n\n// Title Format Table Header\n// Replace _ , . and spaces\nfunc Title(name string) string {\n\torigLen := len(name)\n\trs := []rune(name)\n\tfor i, r := range rs {\n\t\tswitch r {\n\t\tcase '_':\n\t\t\trs[i] = ' '\n\t\tcase '.':\n\t\t\t// ignore floating number 0.0\n\t\t\tif (i != 0 && !isNumOrSpace(rs[i-1])) || (i != len(rs)-1 && !isNumOrSpace(rs[i+1])) {\n\t\t\t\trs[i] = ' '\n\t\t\t}\n\t\t}\n\t}\n\tname = string(rs)\n\tname = strings.TrimSpace(name)\n\tif len(name) == 0 && origLen > 0 {\n\t\t// Keep at least one character. This is important to preserve\n\t\t// empty lines in multi-line headers/footers.\n\t\tname = \" \"\n\t}\n\treturn strings.ToUpper(name)\n}\n\n// Pad String\n// Attempts to place string in the center\nfunc Pad(s, pad string, width int) string {\n\tgap := width - DisplayWidth(s)\n\tif gap > 0 {\n\t\tgapLeft := int(math.Ceil(float64(gap / 2)))\n\t\tgapRight := gap - gapLeft\n\t\treturn strings.Repeat(string(pad), gapLeft) + s + strings.Repeat(string(pad), gapRight)\n\t}\n\treturn s\n}\n\n// PadRight Pad String Right position\n// This would place string at the left side of the screen\nfunc PadRight(s, pad string, width int) string {\n\tgap := width - DisplayWidth(s)\n\tif gap > 0 {\n\t\treturn s + strings.Repeat(string(pad), gap)\n\t}\n\treturn s\n}\n\n// PadLeft Pad String Left position\n// This would place string at the right side of the screen\nfunc PadLeft(s, pad string, width int) string {\n\tgap := width - DisplayWidth(s)\n\tif gap > 0 {\n\t\treturn strings.Repeat(string(pad), gap) + s\n\t}\n\treturn s\n}\n"
        },
        {
          "name": "wrap.go",
          "type": "blob",
          "size": 3.0712890625,
          "content": "// Copyright 2014 Oleku Konko All rights reserved.\n// Use of this source code is governed by a MIT\n// license that can be found in the LICENSE file.\n\n// This module is a Table Writer  API for the Go Programming Language.\n// The protocols were written in pure Go and works on windows and unix systems\n\npackage tablewriter\n\nimport (\n\t\"math\"\n\t\"strings\"\n\t\"unicode\"\n\n\t\"github.com/mattn/go-runewidth\"\n)\n\nconst (\n\tnl = \"\\n\"\n\tsp = \" \"\n)\n\nconst defaultPenalty = 1e5\n\n// WrapString wraps s into a paragraph of lines of length lim, with minimal\n// raggedness.\nfunc WrapString(s string, lim int) ([]string, int) {\n\tif s == sp {\n\t\treturn []string{sp}, lim\n\t}\n\twords := splitWords(s)\n\tif len(words) == 0 {\n\t\treturn []string{\"\"}, lim\n\t}\n\tvar lines []string\n\tmax := 0\n\tfor _, v := range words {\n\t\tmax = runewidth.StringWidth(v)\n\t\tif max > lim {\n\t\t\tlim = max\n\t\t}\n\t}\n\tfor _, line := range WrapWords(words, 1, lim, defaultPenalty) {\n\t\tlines = append(lines, strings.Join(line, sp))\n\t}\n\treturn lines, lim\n}\n\nfunc splitWords(s string) []string {\n\twords := make([]string, 0, len(s)/5)\n\tvar wordBegin int\n\twordPending := false\n\tfor i, c := range s {\n\t\tif unicode.IsSpace(c) {\n\t\t\tif wordPending {\n\t\t\t\twords = append(words, s[wordBegin:i])\n\t\t\t\twordPending = false\n\t\t\t}\n\t\t\tcontinue\n\t\t}\n\t\tif !wordPending {\n\t\t\twordBegin = i\n\t\t\twordPending = true\n\t\t}\n\t}\n\tif wordPending {\n\t\twords = append(words, s[wordBegin:])\n\t}\n\treturn words\n}\n\n// WrapWords is the low-level line-breaking algorithm, useful if you need more\n// control over the details of the text wrapping process. For most uses,\n// WrapString will be sufficient and more convenient.\n//\n// WrapWords splits a list of words into lines with minimal \"raggedness\",\n// treating each rune as one unit, accounting for spc units between adjacent\n// words on each line, and attempting to limit lines to lim units. Raggedness\n// is the total error over all lines, where error is the square of the\n// difference of the length of the line and lim. Too-long lines (which only\n// happen when a single word is longer than lim units) have pen penalty units\n// added to the error.\nfunc WrapWords(words []string, spc, lim, pen int) [][]string {\n\tn := len(words)\n\tif n == 0 {\n\t\treturn nil\n\t}\n\tlengths := make([]int, n)\n\tfor i := 0; i < n; i++ {\n\t\tlengths[i] = runewidth.StringWidth(words[i])\n\t}\n\tnbrk := make([]int, n)\n\tcost := make([]int, n)\n\tfor i := range cost {\n\t\tcost[i] = math.MaxInt32\n\t}\n\tremainderLen := lengths[n-1]\n\tfor i := n - 1; i >= 0; i-- {\n\t\tif i < n-1 {\n\t\t\tremainderLen += spc + lengths[i]\n\t\t}\n\t\tif remainderLen <= lim {\n\t\t\tcost[i] = 0\n\t\t\tnbrk[i] = n\n\t\t\tcontinue\n\t\t}\n\t\tphraseLen := lengths[i]\n\t\tfor j := i + 1; j < n; j++ {\n\t\t\tif j > i+1 {\n\t\t\t\tphraseLen += spc + lengths[j-1]\n\t\t\t}\n\t\t\td := lim - phraseLen\n\t\t\tc := d*d + cost[j]\n\t\t\tif phraseLen > lim {\n\t\t\t\tc += pen // too-long lines get a worse penalty\n\t\t\t}\n\t\t\tif c < cost[i] {\n\t\t\t\tcost[i] = c\n\t\t\t\tnbrk[i] = j\n\t\t\t}\n\t\t}\n\t}\n\tvar lines [][]string\n\ti := 0\n\tfor i < n {\n\t\tlines = append(lines, words[i:nbrk[i]])\n\t\ti = nbrk[i]\n\t}\n\treturn lines\n}\n\n// getLines decomposes a multiline string into a slice of strings.\nfunc getLines(s string) []string {\n\treturn strings.Split(s, nl)\n}\n"
        },
        {
          "name": "wrap_test.go",
          "type": "blob",
          "size": 3.5185546875,
          "content": "// Copyright 2014 Oleku Konko All rights reserved.\n// Use of this source code is governed by a MIT\n// license that can be found in the LICENSE file.\n\n// This module is a Table Writer  API for the Go Programming Language.\n// The protocols were written in pure Go and works on windows and unix systems\n\npackage tablewriter\n\nimport (\n\t\"os\"\n\t\"reflect\"\n\t\"runtime\"\n\t\"strings\"\n\t\"testing\"\n\n\t\"github.com/mattn/go-runewidth\"\n)\n\nvar text = \"The quick brown fox jumps over the lazy dog.\"\n\nfunc TestWrap(t *testing.T) {\n\texp := []string{\n\t\t\"The\", \"quick\", \"brown\", \"fox\",\n\t\t\"jumps\", \"over\", \"the\", \"lazy\", \"dog.\"}\n\n\tgot, _ := WrapString(text, 6)\n\tcheckEqual(t, len(got), len(exp))\n}\n\nfunc TestWrapOneLine(t *testing.T) {\n\texp := \"The quick brown fox jumps over the lazy dog.\"\n\twords, _ := WrapString(text, 500)\n\tcheckEqual(t, strings.Join(words, string(sp)), exp)\n\n}\n\nfunc TestUnicode(t *testing.T) {\n\tinput := \"Česká řeřicha\"\n\tvar wordsUnicode []string\n\tif runewidth.IsEastAsian() {\n\t\twordsUnicode, _ = WrapString(input, 14)\n\t} else {\n\t\twordsUnicode, _ = WrapString(input, 13)\n\t}\n\t// input contains 13 (or 14 for CJK) runes, so it fits on one line.\n\tcheckEqual(t, len(wordsUnicode), 1)\n}\n\nfunc TestDisplayWidth(t *testing.T) {\n\tinput := \"Česká řeřicha\"\n\twant := 13\n\tif runewidth.IsEastAsian() {\n\t\twant = 14\n\t}\n\tif n := DisplayWidth(input); n != want {\n\t\tt.Errorf(\"Wants: %d Got: %d\", want, n)\n\t}\n\tinput = \"\\033[43;30m\" + input + \"\\033[00m\"\n\tcheckEqual(t, DisplayWidth(input), want)\n}\n\n// WrapString was extremely memory greedy, it performed insane number of\n// allocations for what it was doing. See BenchmarkWrapString for details.\nfunc TestWrapStringAllocation(t *testing.T) {\n\toriginalTextBytes, err := os.ReadFile(\"testdata/long-text.txt\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\toriginalText := string(originalTextBytes)\n\n\twantWrappedBytes, err := os.ReadFile(\"testdata/long-text-wrapped.txt\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\twantWrappedText := string(wantWrappedBytes)\n\n\tvar ms runtime.MemStats\n\truntime.ReadMemStats(&ms)\n\theapAllocBefore := int64(ms.HeapAlloc / 1024 / 1024)\n\n\t// When\n\tgotLines, gotLim := WrapString(originalText, 80)\n\n\t// Then\n\twantLim := 80\n\tif gotLim != wantLim {\n\t\tt.Errorf(\"Invalid limit: want=%d, got=%d\", wantLim, gotLim)\n\t}\n\n\tgotWrappedText := strings.Join(gotLines, \"\\n\")\n\tif gotWrappedText != wantWrappedText {\n\t\tt.Errorf(\"Invalid lines: want=\\n%s\\n got=\\n%s\", wantWrappedText, gotWrappedText)\n\t}\n\n\truntime.ReadMemStats(&ms)\n\theapAllocAfter := int64(ms.HeapAlloc / 1024 / 1024)\n\theapAllocDelta := heapAllocAfter - heapAllocBefore\n\tif heapAllocDelta > 1 {\n\t\tt.Fatalf(\"heap allocation should not be greater than 1Mb, got=%dMb\", heapAllocDelta)\n\t}\n}\n\n// Before optimization:\n// BenchmarkWrapString-16    \t       1\t2490331031 ns/op\t2535184104 B/op\t50905550 allocs/op\n// After optimization:\n// BenchmarkWrapString-16    \t    1652\t    658098 ns/op\t    230223 B/op\t    5176 allocs/op\nfunc BenchmarkWrapString(b *testing.B) {\n\td, err := os.ReadFile(\"testdata/long-text.txt\")\n\tif err != nil {\n\t\tb.Fatal(err)\n\t}\n\tfor i := 0; i < b.N; i++ {\n\t\tWrapString(string(d), 128)\n\t}\n}\n\nfunc TestSplitWords(t *testing.T) {\n\tfor _, tt := range []struct {\n\t\tin  string\n\t\tout []string\n\t}{{\n\t\tin:  \"\",\n\t\tout: []string{},\n\t}, {\n\t\tin:  \"a\",\n\t\tout: []string{\"a\"},\n\t}, {\n\t\tin:  \"a b\",\n\t\tout: []string{\"a\", \"b\"},\n\t}, {\n\t\tin:  \"   a   b   \",\n\t\tout: []string{\"a\", \"b\"},\n\t}, {\n\t\tin:  \"\\r\\na\\t\\t \\r\\t b\\r\\n  \",\n\t\tout: []string{\"a\", \"b\"},\n\t}} {\n\t\tt.Run(tt.in, func(t *testing.T) {\n\t\t\tgot := splitWords(tt.in)\n\t\t\tif !reflect.DeepEqual(tt.out, got) {\n\t\t\t\tt.Errorf(\"want=%s, got=%s\", tt.out, got)\n\t\t\t}\n\t\t})\n\t}\n}\n"
        }
      ]
    }
  ]
}