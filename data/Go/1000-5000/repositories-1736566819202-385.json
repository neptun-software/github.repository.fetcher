{
  "metadata": {
    "timestamp": 1736566819202,
    "page": 385,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjM5MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "go-ini/ini",
      "stars": 3475,
      "defaultBranch": "main",
      "files": [
        {
          "name": ".editorconfig",
          "type": "blob",
          "size": 0.1787109375,
          "content": "# http://editorconfig.org\n\nroot = true\n\n[*]\ncharset = utf-8\nend_of_line = lf\ninsert_final_newline = true\ntrim_trailing_whitespace = true\n\n[*_test.go]\ntrim_trailing_whitespace = false\n"
        },
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.1123046875,
          "content": "testdata/conf_out.ini\nini.sublime-project\nini.sublime-workspace\ntestdata/conf_reflect.ini\n.idea\n/.vscode\n.DS_Store\n"
        },
        {
          "name": ".golangci.yml",
          "type": "blob",
          "size": 0.45703125,
          "content": "linters-settings:\n  staticcheck:\n    checks: [\n      \"all\",\n      \"-SA1019\" # There are valid use cases of strings.Title\n    ]\n  nakedret:\n    max-func-lines: 0 # Disallow any unnamed return statement\n\nlinters:\n  enable:\n    - deadcode\n    - errcheck\n    - gosimple\n    - govet\n    - ineffassign\n    - staticcheck\n    - structcheck\n    - typecheck\n    - unused\n    - varcheck\n    - nakedret\n    - gofmt\n    - rowserrcheck\n    - unconvert\n    - goimports\n    - unparam\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 10.0126953125,
          "content": "Apache License\nVersion 2.0, January 2004\nhttp://www.apache.org/licenses/\n\nTERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION\n\n1. Definitions.\n\n\"License\" shall mean the terms and conditions for use, reproduction, and\ndistribution as defined by Sections 1 through 9 of this document.\n\n\"Licensor\" shall mean the copyright owner or entity authorized by the copyright\nowner that is granting the License.\n\n\"Legal Entity\" shall mean the union of the acting entity and all other entities\nthat control, are controlled by, or are under common control with that entity.\nFor the purposes of this definition, \"control\" means (i) the power, direct or\nindirect, to cause the direction or management of such entity, whether by\ncontract or otherwise, or (ii) ownership of fifty percent (50%) or more of the\noutstanding shares, or (iii) beneficial ownership of such entity.\n\n\"You\" (or \"Your\") shall mean an individual or Legal Entity exercising\npermissions granted by this License.\n\n\"Source\" form shall mean the preferred form for making modifications, including\nbut not limited to software source code, documentation source, and configuration\nfiles.\n\n\"Object\" form shall mean any form resulting from mechanical transformation or\ntranslation of a Source form, including but not limited to compiled object code,\ngenerated documentation, and conversions to other media types.\n\n\"Work\" shall mean the work of authorship, whether in Source or Object form, made\navailable under the License, as indicated by a copyright notice that is included\nin or attached to the work (an example is provided in the Appendix below).\n\n\"Derivative Works\" shall mean any work, whether in Source or Object form, that\nis based on (or derived from) the Work and for which the editorial revisions,\nannotations, elaborations, or other modifications represent, as a whole, an\noriginal work of authorship. For the purposes of this License, Derivative Works\nshall not include works that remain separable from, or merely link (or bind by\nname) to the interfaces of, the Work and Derivative Works thereof.\n\n\"Contribution\" shall mean any work of authorship, including the original version\nof the Work and any modifications or additions to that Work or Derivative Works\nthereof, that is intentionally submitted to Licensor for inclusion in the Work\nby the copyright owner or by an individual or Legal Entity authorized to submit\non behalf of the copyright owner. For the purposes of this definition,\n\"submitted\" means any form of electronic, verbal, or written communication sent\nto the Licensor or its representatives, including but not limited to\ncommunication on electronic mailing lists, source code control systems, and\nissue tracking systems that are managed by, or on behalf of, the Licensor for\nthe purpose of discussing and improving the Work, but excluding communication\nthat is conspicuously marked or otherwise designated in writing by the copyright\nowner as \"Not a Contribution.\"\n\n\"Contributor\" shall mean Licensor and any individual or Legal Entity on behalf\nof whom a Contribution has been received by Licensor and subsequently\nincorporated within the Work.\n\n2. Grant of Copyright License.\n\nSubject to the terms and conditions of this License, each Contributor hereby\ngrants to You a perpetual, worldwide, non-exclusive, no-charge, royalty-free,\nirrevocable copyright license to reproduce, prepare Derivative Works of,\npublicly display, publicly perform, sublicense, and distribute the Work and such\nDerivative Works in Source or Object form.\n\n3. Grant of Patent License.\n\nSubject to the terms and conditions of this License, each Contributor hereby\ngrants to You a perpetual, worldwide, non-exclusive, no-charge, royalty-free,\nirrevocable (except as stated in this section) patent license to make, have\nmade, use, offer to sell, sell, import, and otherwise transfer the Work, where\nsuch license applies only to those patent claims licensable by such Contributor\nthat are necessarily infringed by their Contribution(s) alone or by combination\nof their Contribution(s) with the Work to which such Contribution(s) was\nsubmitted. If You institute patent litigation against any entity (including a\ncross-claim or counterclaim in a lawsuit) alleging that the Work or a\nContribution incorporated within the Work constitutes direct or contributory\npatent infringement, then any patent licenses granted to You under this License\nfor that Work shall terminate as of the date such litigation is filed.\n\n4. Redistribution.\n\nYou may reproduce and distribute copies of the Work or Derivative Works thereof\nin any medium, with or without modifications, and in Source or Object form,\nprovided that You meet the following conditions:\n\nYou must give any other recipients of the Work or Derivative Works a copy of\nthis License; and\nYou must cause any modified files to carry prominent notices stating that You\nchanged the files; and\nYou must retain, in the Source form of any Derivative Works that You distribute,\nall copyright, patent, trademark, and attribution notices from the Source form\nof the Work, excluding those notices that do not pertain to any part of the\nDerivative Works; and\nIf the Work includes a \"NOTICE\" text file as part of its distribution, then any\nDerivative Works that You distribute must include a readable copy of the\nattribution notices contained within such NOTICE file, excluding those notices\nthat do not pertain to any part of the Derivative Works, in at least one of the\nfollowing places: within a NOTICE text file distributed as part of the\nDerivative Works; within the Source form or documentation, if provided along\nwith the Derivative Works; or, within a display generated by the Derivative\nWorks, if and wherever such third-party notices normally appear. The contents of\nthe NOTICE file are for informational purposes only and do not modify the\nLicense. You may add Your own attribution notices within Derivative Works that\nYou distribute, alongside or as an addendum to the NOTICE text from the Work,\nprovided that such additional attribution notices cannot be construed as\nmodifying the License.\nYou may add Your own copyright statement to Your modifications and may provide\nadditional or different license terms and conditions for use, reproduction, or\ndistribution of Your modifications, or for any such Derivative Works as a whole,\nprovided Your use, reproduction, and distribution of the Work otherwise complies\nwith the conditions stated in this License.\n\n5. Submission of Contributions.\n\nUnless You explicitly state otherwise, any Contribution intentionally submitted\nfor inclusion in the Work by You to the Licensor shall be under the terms and\nconditions of this License, without any additional terms or conditions.\nNotwithstanding the above, nothing herein shall supersede or modify the terms of\nany separate license agreement you may have executed with Licensor regarding\nsuch Contributions.\n\n6. Trademarks.\n\nThis License does not grant permission to use the trade names, trademarks,\nservice marks, or product names of the Licensor, except as required for\nreasonable and customary use in describing the origin of the Work and\nreproducing the content of the NOTICE file.\n\n7. Disclaimer of Warranty.\n\nUnless required by applicable law or agreed to in writing, Licensor provides the\nWork (and each Contributor provides its Contributions) on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied,\nincluding, without limitation, any warranties or conditions of TITLE,\nNON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A PARTICULAR PURPOSE. You are\nsolely responsible for determining the appropriateness of using or\nredistributing the Work and assume any risks associated with Your exercise of\npermissions under this License.\n\n8. Limitation of Liability.\n\nIn no event and under no legal theory, whether in tort (including negligence),\ncontract, or otherwise, unless required by applicable law (such as deliberate\nand grossly negligent acts) or agreed to in writing, shall any Contributor be\nliable to You for damages, including any direct, indirect, special, incidental,\nor consequential damages of any character arising as a result of this License or\nout of the use or inability to use the Work (including but not limited to\ndamages for loss of goodwill, work stoppage, computer failure or malfunction, or\nany and all other commercial damages or losses), even if such Contributor has\nbeen advised of the possibility of such damages.\n\n9. Accepting Warranty or Additional Liability.\n\nWhile redistributing the Work or Derivative Works thereof, You may choose to\noffer, and charge a fee for, acceptance of support, warranty, indemnity, or\nother liability obligations and/or rights consistent with this License. However,\nin accepting such obligations, You may act only on Your own behalf and on Your\nsole responsibility, not on behalf of any other Contributor, and only if You\nagree to indemnify, defend, and hold each Contributor harmless for any liability\nincurred by, or claims asserted against, such Contributor by reason of your\naccepting any such warranty or additional liability.\n\nEND OF TERMS AND CONDITIONS\n\nAPPENDIX: How to apply the Apache License to your work\n\nTo apply the Apache License to your work, attach the following boilerplate\nnotice, with the fields enclosed by brackets \"[]\" replaced with your own\nidentifying information. (Don't include the brackets!) The text should be\nenclosed in the appropriate comment syntax for the file format. We also\nrecommend that a file or class name and description of purpose be included on\nthe same \"printed page\" as the copyright notice for easier identification within\nthird-party archives.\n\n   Copyright 2014 Unknwon\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n     http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n"
        },
        {
          "name": "Makefile",
          "type": "blob",
          "size": 0.2333984375,
          "content": ".PHONY: build test bench vet coverage\n\nbuild: vet bench\n\ntest:\n\tgo test -v -cover -race\n\nbench:\n\tgo test -v -cover -test.bench=. -test.benchmem\n\nvet:\n\tgo vet\n\ncoverage:\n\tgo test -coverprofile=c.out && go tool cover -html=c.out && rm c.out\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 1.6669921875,
          "content": "# INI\n\n[![GitHub Workflow Status](https://img.shields.io/github/checks-status/go-ini/ini/main?logo=github&style=for-the-badge)](https://github.com/go-ini/ini/actions?query=branch%3Amain)\n[![codecov](https://img.shields.io/codecov/c/github/go-ini/ini/master?logo=codecov&style=for-the-badge)](https://codecov.io/gh/go-ini/ini)\n[![GoDoc](https://img.shields.io/badge/GoDoc-Reference-blue?style=for-the-badge&logo=go)](https://pkg.go.dev/github.com/go-ini/ini?tab=doc)\n[![Sourcegraph](https://img.shields.io/badge/view%20on-Sourcegraph-brightgreen.svg?style=for-the-badge&logo=sourcegraph)](https://sourcegraph.com/github.com/go-ini/ini)\n\n![](https://avatars0.githubusercontent.com/u/10216035?v=3&s=200)\n\nPackage ini provides INI file read and write functionality in Go.\n\n## Features\n\n- Load from multiple data sources(file, `[]byte`, `io.Reader` and `io.ReadCloser`) with overwrites.\n- Read with recursion values.\n- Read with parent-child sections.\n- Read with auto-increment key names.\n- Read with multiple-line values.\n- Read with tons of helper methods.\n- Read and convert values to Go types.\n- Read and **WRITE** comments of sections and keys.\n- Manipulate sections, keys and comments with ease.\n- Keep sections and keys in order as you parse and save.\n\n## Installation\n\nThe minimum requirement of Go is **1.13**.\n\n```sh\n$ go get gopkg.in/ini.v1\n```\n\nPlease add `-u` flag to update in the future.\n\n## Getting Help\n\n- [Getting Started](https://ini.unknwon.io/docs/intro/getting_started)\n- [API Documentation](https://gowalker.org/gopkg.in/ini.v1)\n- 中国大陆镜像：https://ini.unknwon.cn\n\n## License\n\nThis project is under Apache v2 License. See the [LICENSE](LICENSE) file for the full license text.\n"
        },
        {
          "name": "bench_test.go",
          "type": "blob",
          "size": 2.529296875,
          "content": "// Copyright 2017 Unknwon\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"): you may\n// not use this file except in compliance with the License. You may obtain\n// a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n// WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n// License for the specific language governing permissions and limitations\n// under the License.\n\npackage ini\n\nimport (\n\t\"testing\"\n)\n\nfunc newTestFile(block bool) *File {\n\tc, _ := Load([]byte(confData))\n\tc.BlockMode = block\n\treturn c\n}\n\nfunc Benchmark_Key_Value(b *testing.B) {\n\tc := newTestFile(true)\n\tfor i := 0; i < b.N; i++ {\n\t\tc.Section(\"\").Key(\"NAME\").Value()\n\t}\n}\n\nfunc Benchmark_Key_Value_NonBlock(b *testing.B) {\n\tc := newTestFile(false)\n\tfor i := 0; i < b.N; i++ {\n\t\tc.Section(\"\").Key(\"NAME\").Value()\n\t}\n}\n\nfunc Benchmark_Key_Value_ViaSection(b *testing.B) {\n\tc := newTestFile(true)\n\tsec := c.Section(\"\")\n\tfor i := 0; i < b.N; i++ {\n\t\tsec.Key(\"NAME\").Value()\n\t}\n}\n\nfunc Benchmark_Key_Value_ViaSection_NonBlock(b *testing.B) {\n\tc := newTestFile(false)\n\tsec := c.Section(\"\")\n\tfor i := 0; i < b.N; i++ {\n\t\tsec.Key(\"NAME\").Value()\n\t}\n}\n\nfunc Benchmark_Key_Value_Direct(b *testing.B) {\n\tc := newTestFile(true)\n\tkey := c.Section(\"\").Key(\"NAME\")\n\tfor i := 0; i < b.N; i++ {\n\t\tkey.Value()\n\t}\n}\n\nfunc Benchmark_Key_Value_Direct_NonBlock(b *testing.B) {\n\tc := newTestFile(false)\n\tkey := c.Section(\"\").Key(\"NAME\")\n\tfor i := 0; i < b.N; i++ {\n\t\tkey.Value()\n\t}\n}\n\nfunc Benchmark_Key_String(b *testing.B) {\n\tc := newTestFile(true)\n\tfor i := 0; i < b.N; i++ {\n\t\t_ = c.Section(\"\").Key(\"NAME\").String()\n\t}\n}\n\nfunc Benchmark_Key_String_NonBlock(b *testing.B) {\n\tc := newTestFile(false)\n\tfor i := 0; i < b.N; i++ {\n\t\t_ = c.Section(\"\").Key(\"NAME\").String()\n\t}\n}\n\nfunc Benchmark_Key_String_ViaSection(b *testing.B) {\n\tc := newTestFile(true)\n\tsec := c.Section(\"\")\n\tfor i := 0; i < b.N; i++ {\n\t\t_ = sec.Key(\"NAME\").String()\n\t}\n}\n\nfunc Benchmark_Key_String_ViaSection_NonBlock(b *testing.B) {\n\tc := newTestFile(false)\n\tsec := c.Section(\"\")\n\tfor i := 0; i < b.N; i++ {\n\t\t_ = sec.Key(\"NAME\").String()\n\t}\n}\n\nfunc Benchmark_Key_SetValue(b *testing.B) {\n\tc := newTestFile(true)\n\tfor i := 0; i < b.N; i++ {\n\t\tc.Section(\"\").Key(\"NAME\").SetValue(\"10\")\n\t}\n}\n\nfunc Benchmark_Key_SetValue_VisSection(b *testing.B) {\n\tc := newTestFile(true)\n\tsec := c.Section(\"\")\n\tfor i := 0; i < b.N; i++ {\n\t\tsec.Key(\"NAME\").SetValue(\"10\")\n\t}\n}\n"
        },
        {
          "name": "codecov.yml",
          "type": "blob",
          "size": 0.2392578125,
          "content": "coverage:\n  range: \"60...95\"\n  status:\n    project:\n      default:\n        threshold: 1%\n        informational: true\n    patch:\n      defualt:\n        only_pulls: true\n        informational: true\n\ncomment:\n  layout: 'diff'\n\ngithub_checks: false\n"
        },
        {
          "name": "data_source.go",
          "type": "blob",
          "size": 1.91796875,
          "content": "// Copyright 2019 Unknwon\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"): you may\n// not use this file except in compliance with the License. You may obtain\n// a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n// WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n// License for the specific language governing permissions and limitations\n// under the License.\n\npackage ini\n\nimport (\n\t\"bytes\"\n\t\"fmt\"\n\t\"io\"\n\t\"io/ioutil\"\n\t\"os\"\n)\n\nvar (\n\t_ dataSource = (*sourceFile)(nil)\n\t_ dataSource = (*sourceData)(nil)\n\t_ dataSource = (*sourceReadCloser)(nil)\n)\n\n// dataSource is an interface that returns object which can be read and closed.\ntype dataSource interface {\n\tReadCloser() (io.ReadCloser, error)\n}\n\n// sourceFile represents an object that contains content on the local file system.\ntype sourceFile struct {\n\tname string\n}\n\nfunc (s sourceFile) ReadCloser() (_ io.ReadCloser, err error) {\n\treturn os.Open(s.name)\n}\n\n// sourceData represents an object that contains content in memory.\ntype sourceData struct {\n\tdata []byte\n}\n\nfunc (s *sourceData) ReadCloser() (io.ReadCloser, error) {\n\treturn ioutil.NopCloser(bytes.NewReader(s.data)), nil\n}\n\n// sourceReadCloser represents an input stream with Close method.\ntype sourceReadCloser struct {\n\treader io.ReadCloser\n}\n\nfunc (s *sourceReadCloser) ReadCloser() (io.ReadCloser, error) {\n\treturn s.reader, nil\n}\n\nfunc parseDataSource(source interface{}) (dataSource, error) {\n\tswitch s := source.(type) {\n\tcase string:\n\t\treturn sourceFile{s}, nil\n\tcase []byte:\n\t\treturn &sourceData{s}, nil\n\tcase io.ReadCloser:\n\t\treturn &sourceReadCloser{s}, nil\n\tcase io.Reader:\n\t\treturn &sourceReadCloser{ioutil.NopCloser(s)}, nil\n\tdefault:\n\t\treturn nil, fmt.Errorf(\"error parsing data source: unknown type %q\", s)\n\t}\n}\n"
        },
        {
          "name": "deprecated.go",
          "type": "blob",
          "size": 0.7724609375,
          "content": "// Copyright 2019 Unknwon\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"): you may\n// not use this file except in compliance with the License. You may obtain\n// a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n// WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n// License for the specific language governing permissions and limitations\n// under the License.\n\npackage ini\n\nvar (\n\t// Deprecated: Use \"DefaultSection\" instead.\n\tDEFAULT_SECTION = DefaultSection\n\t// Deprecated: AllCapsUnderscore converts to format ALL_CAPS_UNDERSCORE.\n\tAllCapsUnderscore = SnackCase\n)\n"
        },
        {
          "name": "error.go",
          "type": "blob",
          "size": 1.4619140625,
          "content": "// Copyright 2016 Unknwon\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"): you may\n// not use this file except in compliance with the License. You may obtain\n// a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n// WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n// License for the specific language governing permissions and limitations\n// under the License.\n\npackage ini\n\nimport (\n\t\"fmt\"\n)\n\n// ErrDelimiterNotFound indicates the error type of no delimiter is found which there should be one.\ntype ErrDelimiterNotFound struct {\n\tLine string\n}\n\n// IsErrDelimiterNotFound returns true if the given error is an instance of ErrDelimiterNotFound.\nfunc IsErrDelimiterNotFound(err error) bool {\n\t_, ok := err.(ErrDelimiterNotFound)\n\treturn ok\n}\n\nfunc (err ErrDelimiterNotFound) Error() string {\n\treturn fmt.Sprintf(\"key-value delimiter not found: %s\", err.Line)\n}\n\n// ErrEmptyKeyName indicates the error type of no key name is found which there should be one.\ntype ErrEmptyKeyName struct {\n\tLine string\n}\n\n// IsErrEmptyKeyName returns true if the given error is an instance of ErrEmptyKeyName.\nfunc IsErrEmptyKeyName(err error) bool {\n\t_, ok := err.(ErrEmptyKeyName)\n\treturn ok\n}\n\nfunc (err ErrEmptyKeyName) Error() string {\n\treturn fmt.Sprintf(\"empty key name: %s\", err.Line)\n}\n"
        },
        {
          "name": "file.go",
          "type": "blob",
          "size": 13.6298828125,
          "content": "// Copyright 2017 Unknwon\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"): you may\n// not use this file except in compliance with the License. You may obtain\n// a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n// WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n// License for the specific language governing permissions and limitations\n// under the License.\n\npackage ini\n\nimport (\n\t\"bytes\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"io/ioutil\"\n\t\"os\"\n\t\"strings\"\n\t\"sync\"\n)\n\n// File represents a combination of one or more INI files in memory.\ntype File struct {\n\toptions     LoadOptions\n\tdataSources []dataSource\n\n\t// Should make things safe, but sometimes doesn't matter.\n\tBlockMode bool\n\tlock      sync.RWMutex\n\n\t// To keep data in order.\n\tsectionList []string\n\t// To keep track of the index of a section with same name.\n\t// This meta list is only used with non-unique section names are allowed.\n\tsectionIndexes []int\n\n\t// Actual data is stored here.\n\tsections map[string][]*Section\n\n\tNameMapper\n\tValueMapper\n}\n\n// newFile initializes File object with given data sources.\nfunc newFile(dataSources []dataSource, opts LoadOptions) *File {\n\tif len(opts.KeyValueDelimiters) == 0 {\n\t\topts.KeyValueDelimiters = \"=:\"\n\t}\n\tif len(opts.KeyValueDelimiterOnWrite) == 0 {\n\t\topts.KeyValueDelimiterOnWrite = \"=\"\n\t}\n\tif len(opts.ChildSectionDelimiter) == 0 {\n\t\topts.ChildSectionDelimiter = \".\"\n\t}\n\n\treturn &File{\n\t\tBlockMode:   true,\n\t\tdataSources: dataSources,\n\t\tsections:    make(map[string][]*Section),\n\t\toptions:     opts,\n\t}\n}\n\n// Empty returns an empty file object.\nfunc Empty(opts ...LoadOptions) *File {\n\tvar opt LoadOptions\n\tif len(opts) > 0 {\n\t\topt = opts[0]\n\t}\n\n\t// Ignore error here, we are sure our data is good.\n\tf, _ := LoadSources(opt, []byte(\"\"))\n\treturn f\n}\n\n// NewSection creates a new section.\nfunc (f *File) NewSection(name string) (*Section, error) {\n\tif len(name) == 0 {\n\t\treturn nil, errors.New(\"empty section name\")\n\t}\n\n\tif (f.options.Insensitive || f.options.InsensitiveSections) && name != DefaultSection {\n\t\tname = strings.ToLower(name)\n\t}\n\n\tif f.BlockMode {\n\t\tf.lock.Lock()\n\t\tdefer f.lock.Unlock()\n\t}\n\n\tif !f.options.AllowNonUniqueSections && inSlice(name, f.sectionList) {\n\t\treturn f.sections[name][0], nil\n\t}\n\n\tf.sectionList = append(f.sectionList, name)\n\n\t// NOTE: Append to indexes must happen before appending to sections,\n\t// otherwise index will have off-by-one problem.\n\tf.sectionIndexes = append(f.sectionIndexes, len(f.sections[name]))\n\n\tsec := newSection(f, name)\n\tf.sections[name] = append(f.sections[name], sec)\n\n\treturn sec, nil\n}\n\n// NewRawSection creates a new section with an unparseable body.\nfunc (f *File) NewRawSection(name, body string) (*Section, error) {\n\tsection, err := f.NewSection(name)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tsection.isRawSection = true\n\tsection.rawBody = body\n\treturn section, nil\n}\n\n// NewSections creates a list of sections.\nfunc (f *File) NewSections(names ...string) (err error) {\n\tfor _, name := range names {\n\t\tif _, err = f.NewSection(name); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\n// GetSection returns section by given name.\nfunc (f *File) GetSection(name string) (*Section, error) {\n\tsecs, err := f.SectionsByName(name)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn secs[0], err\n}\n\n// HasSection returns true if the file contains a section with given name.\nfunc (f *File) HasSection(name string) bool {\n\tsection, _ := f.GetSection(name)\n\treturn section != nil\n}\n\n// SectionsByName returns all sections with given name.\nfunc (f *File) SectionsByName(name string) ([]*Section, error) {\n\tif len(name) == 0 {\n\t\tname = DefaultSection\n\t}\n\tif f.options.Insensitive || f.options.InsensitiveSections {\n\t\tname = strings.ToLower(name)\n\t}\n\n\tif f.BlockMode {\n\t\tf.lock.RLock()\n\t\tdefer f.lock.RUnlock()\n\t}\n\n\tsecs := f.sections[name]\n\tif len(secs) == 0 {\n\t\treturn nil, fmt.Errorf(\"section %q does not exist\", name)\n\t}\n\n\treturn secs, nil\n}\n\n// Section assumes named section exists and returns a zero-value when not.\nfunc (f *File) Section(name string) *Section {\n\tsec, err := f.GetSection(name)\n\tif err != nil {\n\t\tif name == \"\" {\n\t\t\tname = DefaultSection\n\t\t}\n\t\tsec, _ = f.NewSection(name)\n\t\treturn sec\n\t}\n\treturn sec\n}\n\n// SectionWithIndex assumes named section exists and returns a new section when not.\nfunc (f *File) SectionWithIndex(name string, index int) *Section {\n\tsecs, err := f.SectionsByName(name)\n\tif err != nil || len(secs) <= index {\n\t\t// NOTE: It's OK here because the only possible error is empty section name,\n\t\t// but if it's empty, this piece of code won't be executed.\n\t\tnewSec, _ := f.NewSection(name)\n\t\treturn newSec\n\t}\n\n\treturn secs[index]\n}\n\n// Sections returns a list of Section stored in the current instance.\nfunc (f *File) Sections() []*Section {\n\tif f.BlockMode {\n\t\tf.lock.RLock()\n\t\tdefer f.lock.RUnlock()\n\t}\n\n\tsections := make([]*Section, len(f.sectionList))\n\tfor i, name := range f.sectionList {\n\t\tsections[i] = f.sections[name][f.sectionIndexes[i]]\n\t}\n\treturn sections\n}\n\n// ChildSections returns a list of child sections of given section name.\nfunc (f *File) ChildSections(name string) []*Section {\n\treturn f.Section(name).ChildSections()\n}\n\n// SectionStrings returns list of section names.\nfunc (f *File) SectionStrings() []string {\n\tlist := make([]string, len(f.sectionList))\n\tcopy(list, f.sectionList)\n\treturn list\n}\n\n// DeleteSection deletes a section or all sections with given name.\nfunc (f *File) DeleteSection(name string) {\n\tsecs, err := f.SectionsByName(name)\n\tif err != nil {\n\t\treturn\n\t}\n\n\tfor i := 0; i < len(secs); i++ {\n\t\t// For non-unique sections, it is always needed to remove the first one so\n\t\t// in the next iteration, the subsequent section continue having index 0.\n\t\t// Ignoring the error as index 0 never returns an error.\n\t\t_ = f.DeleteSectionWithIndex(name, 0)\n\t}\n}\n\n// DeleteSectionWithIndex deletes a section with given name and index.\nfunc (f *File) DeleteSectionWithIndex(name string, index int) error {\n\tif !f.options.AllowNonUniqueSections && index != 0 {\n\t\treturn fmt.Errorf(\"delete section with non-zero index is only allowed when non-unique sections is enabled\")\n\t}\n\n\tif len(name) == 0 {\n\t\tname = DefaultSection\n\t}\n\tif f.options.Insensitive || f.options.InsensitiveSections {\n\t\tname = strings.ToLower(name)\n\t}\n\n\tif f.BlockMode {\n\t\tf.lock.Lock()\n\t\tdefer f.lock.Unlock()\n\t}\n\n\t// Count occurrences of the sections\n\toccurrences := 0\n\n\tsectionListCopy := make([]string, len(f.sectionList))\n\tcopy(sectionListCopy, f.sectionList)\n\n\tfor i, s := range sectionListCopy {\n\t\tif s != name {\n\t\t\tcontinue\n\t\t}\n\n\t\tif occurrences == index {\n\t\t\tif len(f.sections[name]) <= 1 {\n\t\t\t\tdelete(f.sections, name) // The last one in the map\n\t\t\t} else {\n\t\t\t\tf.sections[name] = append(f.sections[name][:index], f.sections[name][index+1:]...)\n\t\t\t}\n\n\t\t\t// Fix section lists\n\t\t\tf.sectionList = append(f.sectionList[:i], f.sectionList[i+1:]...)\n\t\t\tf.sectionIndexes = append(f.sectionIndexes[:i], f.sectionIndexes[i+1:]...)\n\n\t\t} else if occurrences > index {\n\t\t\t// Fix the indices of all following sections with this name.\n\t\t\tf.sectionIndexes[i-1]--\n\t\t}\n\n\t\toccurrences++\n\t}\n\n\treturn nil\n}\n\nfunc (f *File) reload(s dataSource) error {\n\tr, err := s.ReadCloser()\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer r.Close()\n\n\treturn f.parse(r)\n}\n\n// Reload reloads and parses all data sources.\nfunc (f *File) Reload() (err error) {\n\tfor _, s := range f.dataSources {\n\t\tif err = f.reload(s); err != nil {\n\t\t\t// In loose mode, we create an empty default section for nonexistent files.\n\t\t\tif os.IsNotExist(err) && f.options.Loose {\n\t\t\t\t_ = f.parse(bytes.NewBuffer(nil))\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\treturn err\n\t\t}\n\t\tif f.options.ShortCircuit {\n\t\t\treturn nil\n\t\t}\n\t}\n\treturn nil\n}\n\n// Append appends one or more data sources and reloads automatically.\nfunc (f *File) Append(source interface{}, others ...interface{}) error {\n\tds, err := parseDataSource(source)\n\tif err != nil {\n\t\treturn err\n\t}\n\tf.dataSources = append(f.dataSources, ds)\n\tfor _, s := range others {\n\t\tds, err = parseDataSource(s)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tf.dataSources = append(f.dataSources, ds)\n\t}\n\treturn f.Reload()\n}\n\nfunc (f *File) writeToBuffer(indent string) (*bytes.Buffer, error) {\n\tequalSign := DefaultFormatLeft + f.options.KeyValueDelimiterOnWrite + DefaultFormatRight\n\n\tif PrettyFormat || PrettyEqual {\n\t\tequalSign = fmt.Sprintf(\" %s \", f.options.KeyValueDelimiterOnWrite)\n\t}\n\n\t// Use buffer to make sure target is safe until finish encoding.\n\tbuf := bytes.NewBuffer(nil)\n\tlastSectionIdx := len(f.sectionList) - 1\n\tfor i, sname := range f.sectionList {\n\t\tsec := f.SectionWithIndex(sname, f.sectionIndexes[i])\n\t\tif len(sec.Comment) > 0 {\n\t\t\t// Support multiline comments\n\t\t\tlines := strings.Split(sec.Comment, LineBreak)\n\t\t\tfor i := range lines {\n\t\t\t\tif lines[i][0] != '#' && lines[i][0] != ';' {\n\t\t\t\t\tlines[i] = \"; \" + lines[i]\n\t\t\t\t} else {\n\t\t\t\t\tlines[i] = lines[i][:1] + \" \" + strings.TrimSpace(lines[i][1:])\n\t\t\t\t}\n\n\t\t\t\tif _, err := buf.WriteString(lines[i] + LineBreak); err != nil {\n\t\t\t\t\treturn nil, err\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif i > 0 || DefaultHeader || (i == 0 && strings.ToUpper(sec.name) != DefaultSection) {\n\t\t\tif _, err := buf.WriteString(\"[\" + sname + \"]\" + LineBreak); err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t} else {\n\t\t\t// Write nothing if default section is empty\n\t\t\tif len(sec.keyList) == 0 {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t}\n\n\t\tisLastSection := i == lastSectionIdx\n\t\tif sec.isRawSection {\n\t\t\tif _, err := buf.WriteString(sec.rawBody); err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\n\t\t\tif PrettySection && !isLastSection {\n\t\t\t\t// Put a line between sections\n\t\t\t\tif _, err := buf.WriteString(LineBreak); err != nil {\n\t\t\t\t\treturn nil, err\n\t\t\t\t}\n\t\t\t}\n\t\t\tcontinue\n\t\t}\n\n\t\t// Count and generate alignment length and buffer spaces using the\n\t\t// longest key. Keys may be modified if they contain certain characters so\n\t\t// we need to take that into account in our calculation.\n\t\talignLength := 0\n\t\tif PrettyFormat {\n\t\t\tfor _, kname := range sec.keyList {\n\t\t\t\tkeyLength := len(kname)\n\t\t\t\t// First case will surround key by ` and second by \"\"\"\n\t\t\t\tif strings.Contains(kname, \"\\\"\") || strings.ContainsAny(kname, f.options.KeyValueDelimiters) {\n\t\t\t\t\tkeyLength += 2\n\t\t\t\t} else if strings.Contains(kname, \"`\") {\n\t\t\t\t\tkeyLength += 6\n\t\t\t\t}\n\n\t\t\t\tif keyLength > alignLength {\n\t\t\t\t\talignLength = keyLength\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\talignSpaces := bytes.Repeat([]byte(\" \"), alignLength)\n\n\tKeyList:\n\t\tfor _, kname := range sec.keyList {\n\t\t\tkey := sec.Key(kname)\n\t\t\tif len(key.Comment) > 0 {\n\t\t\t\tif len(indent) > 0 && sname != DefaultSection {\n\t\t\t\t\tbuf.WriteString(indent)\n\t\t\t\t}\n\n\t\t\t\t// Support multiline comments\n\t\t\t\tlines := strings.Split(key.Comment, LineBreak)\n\t\t\t\tfor i := range lines {\n\t\t\t\t\tif lines[i][0] != '#' && lines[i][0] != ';' {\n\t\t\t\t\t\tlines[i] = \"; \" + strings.TrimSpace(lines[i])\n\t\t\t\t\t} else {\n\t\t\t\t\t\tlines[i] = lines[i][:1] + \" \" + strings.TrimSpace(lines[i][1:])\n\t\t\t\t\t}\n\n\t\t\t\t\tif _, err := buf.WriteString(lines[i] + LineBreak); err != nil {\n\t\t\t\t\t\treturn nil, err\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif len(indent) > 0 && sname != DefaultSection {\n\t\t\t\tbuf.WriteString(indent)\n\t\t\t}\n\n\t\t\tswitch {\n\t\t\tcase key.isAutoIncrement:\n\t\t\t\tkname = \"-\"\n\t\t\tcase strings.Contains(kname, \"\\\"\") || strings.ContainsAny(kname, f.options.KeyValueDelimiters):\n\t\t\t\tkname = \"`\" + kname + \"`\"\n\t\t\tcase strings.Contains(kname, \"`\"):\n\t\t\t\tkname = `\"\"\"` + kname + `\"\"\"`\n\t\t\t}\n\n\t\t\twriteKeyValue := func(val string) (bool, error) {\n\t\t\t\tif _, err := buf.WriteString(kname); err != nil {\n\t\t\t\t\treturn false, err\n\t\t\t\t}\n\n\t\t\t\tif key.isBooleanType {\n\t\t\t\t\tbuf.WriteString(LineBreak)\n\t\t\t\t\treturn true, nil\n\t\t\t\t}\n\n\t\t\t\t// Write out alignment spaces before \"=\" sign\n\t\t\t\tif PrettyFormat {\n\t\t\t\t\tbuf.Write(alignSpaces[:alignLength-len(kname)])\n\t\t\t\t}\n\n\t\t\t\t// In case key value contains \"\\n\", \"`\", \"\\\"\", \"#\" or \";\"\n\t\t\t\tif strings.ContainsAny(val, \"\\n`\") {\n\t\t\t\t\tval = `\"\"\"` + val + `\"\"\"`\n\t\t\t\t} else if !f.options.IgnoreInlineComment && strings.ContainsAny(val, \"#;\") {\n\t\t\t\t\tval = \"`\" + val + \"`\"\n\t\t\t\t} else if len(strings.TrimSpace(val)) != len(val) {\n\t\t\t\t\tval = `\"` + val + `\"`\n\t\t\t\t}\n\t\t\t\tif _, err := buf.WriteString(equalSign + val + LineBreak); err != nil {\n\t\t\t\t\treturn false, err\n\t\t\t\t}\n\t\t\t\treturn false, nil\n\t\t\t}\n\n\t\t\tshadows := key.ValueWithShadows()\n\t\t\tif len(shadows) == 0 {\n\t\t\t\tif _, err := writeKeyValue(\"\"); err != nil {\n\t\t\t\t\treturn nil, err\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor _, val := range shadows {\n\t\t\t\texitLoop, err := writeKeyValue(val)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn nil, err\n\t\t\t\t} else if exitLoop {\n\t\t\t\t\tcontinue KeyList\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor _, val := range key.nestedValues {\n\t\t\t\tif _, err := buf.WriteString(indent + \"  \" + val + LineBreak); err != nil {\n\t\t\t\t\treturn nil, err\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif PrettySection && !isLastSection {\n\t\t\t// Put a line between sections\n\t\t\tif _, err := buf.WriteString(LineBreak); err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t}\n\t}\n\n\treturn buf, nil\n}\n\n// WriteToIndent writes content into io.Writer with given indention.\n// If PrettyFormat has been set to be true,\n// it will align \"=\" sign with spaces under each section.\nfunc (f *File) WriteToIndent(w io.Writer, indent string) (int64, error) {\n\tbuf, err := f.writeToBuffer(indent)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\treturn buf.WriteTo(w)\n}\n\n// WriteTo writes file content into io.Writer.\nfunc (f *File) WriteTo(w io.Writer) (int64, error) {\n\treturn f.WriteToIndent(w, \"\")\n}\n\n// SaveToIndent writes content to file system with given value indention.\nfunc (f *File) SaveToIndent(filename, indent string) error {\n\t// Note: Because we are truncating with os.Create,\n\t// \tso it's safer to save to a temporary file location and rename after done.\n\tbuf, err := f.writeToBuffer(indent)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn ioutil.WriteFile(filename, buf.Bytes(), 0666)\n}\n\n// SaveTo writes content to file system.\nfunc (f *File) SaveTo(filename string) error {\n\treturn f.SaveToIndent(filename, \"\")\n}\n"
        },
        {
          "name": "file_test.go",
          "type": "blob",
          "size": 13.0498046875,
          "content": "// Copyright 2017 Unknwon\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"): you may\n// not use this file except in compliance with the License. You may obtain\n// a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n// WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n// License for the specific language governing permissions and limitations\n// under the License.\n\npackage ini\n\nimport (\n\t\"bytes\"\n\t\"io/ioutil\"\n\t\"runtime\"\n\t\"sort\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n\t\"github.com/stretchr/testify/require\"\n)\n\nfunc TestEmpty(t *testing.T) {\n\tf := Empty()\n\trequire.NotNil(t, f)\n\n\t// Should only have the default section\n\tassert.Len(t, f.Sections(), 1)\n\n\t// Default section should not contain any key\n\tassert.Len(t, f.Section(\"\").Keys(), 0)\n}\n\nfunc TestFile_NewSection(t *testing.T) {\n\tf := Empty()\n\trequire.NotNil(t, f)\n\n\tsec, err := f.NewSection(\"author\")\n\trequire.NoError(t, err)\n\trequire.NotNil(t, sec)\n\tassert.Equal(t, \"author\", sec.Name())\n\n\tassert.Equal(t, []string{DefaultSection, \"author\"}, f.SectionStrings())\n\n\tt.Run(\"with duplicated name\", func(t *testing.T) {\n\t\tsec, err := f.NewSection(\"author\")\n\t\trequire.NoError(t, err)\n\t\trequire.NotNil(t, sec)\n\n\t\t// Does nothing if section already exists\n\t\tassert.Equal(t, []string{DefaultSection, \"author\"}, f.SectionStrings())\n\t})\n\n\tt.Run(\"with empty string\", func(t *testing.T) {\n\t\t_, err := f.NewSection(\"\")\n\t\trequire.Error(t, err)\n\t})\n}\n\nfunc TestFile_NonUniqueSection(t *testing.T) {\n\tt.Run(\"read and write non-unique sections\", func(t *testing.T) {\n\t\tf, err := LoadSources(LoadOptions{\n\t\t\tAllowNonUniqueSections: true,\n\t\t}, []byte(`[Interface]\nAddress = 192.168.2.1\nPrivateKey = <server's privatekey>\nListenPort = 51820\n\n[Peer]\nPublicKey = <client's publickey>\nAllowedIPs = 192.168.2.2/32\n\n[Peer]\nPublicKey = <client2's publickey>\nAllowedIPs = 192.168.2.3/32`))\n\t\trequire.NoError(t, err)\n\t\trequire.NotNil(t, f)\n\n\t\tsec, err := f.NewSection(\"Peer\")\n\t\trequire.NoError(t, err)\n\t\trequire.NotNil(t, f)\n\n\t\t_, _ = sec.NewKey(\"PublicKey\", \"<client3's publickey>\")\n\t\t_, _ = sec.NewKey(\"AllowedIPs\", \"192.168.2.4/32\")\n\n\t\tvar buf bytes.Buffer\n\t\t_, err = f.WriteTo(&buf)\n\t\trequire.NoError(t, err)\n\t\tstr := buf.String()\n\t\tassert.Equal(t, `[Interface]\nAddress    = 192.168.2.1\nPrivateKey = <server's privatekey>\nListenPort = 51820\n\n[Peer]\nPublicKey  = <client's publickey>\nAllowedIPs = 192.168.2.2/32\n\n[Peer]\nPublicKey  = <client2's publickey>\nAllowedIPs = 192.168.2.3/32\n\n[Peer]\nPublicKey  = <client3's publickey>\nAllowedIPs = 192.168.2.4/32\n`, str)\n\t})\n\n\tt.Run(\"delete non-unique section\", func(t *testing.T) {\n\t\tf, err := LoadSources(LoadOptions{\n\t\t\tAllowNonUniqueSections: true,\n\t\t}, []byte(`[Interface]\nAddress    = 192.168.2.1\nPrivateKey = <server's privatekey>\nListenPort = 51820\n\n[Peer]\nPublicKey  = <client's publickey>\nAllowedIPs = 192.168.2.2/32\n\n[Peer]\nPublicKey  = <client2's publickey>\nAllowedIPs = 192.168.2.3/32\n\n[Peer]\nPublicKey  = <client3's publickey>\nAllowedIPs = 192.168.2.4/32\n\n`))\n\t\trequire.NoError(t, err)\n\t\trequire.NotNil(t, f)\n\n\t\terr = f.DeleteSectionWithIndex(\"Peer\", 1)\n\t\trequire.NoError(t, err)\n\n\t\tvar buf bytes.Buffer\n\t\t_, err = f.WriteTo(&buf)\n\t\trequire.NoError(t, err)\n\t\tstr := buf.String()\n\t\tassert.Equal(t, `[Interface]\nAddress    = 192.168.2.1\nPrivateKey = <server's privatekey>\nListenPort = 51820\n\n[Peer]\nPublicKey  = <client's publickey>\nAllowedIPs = 192.168.2.2/32\n\n[Peer]\nPublicKey  = <client3's publickey>\nAllowedIPs = 192.168.2.4/32\n`, str)\n\t})\n\n\tt.Run(\"delete all sections\", func(t *testing.T) {\n\t\tf := Empty(LoadOptions{\n\t\t\tAllowNonUniqueSections: true,\n\t\t})\n\t\trequire.NotNil(t, f)\n\n\t\t_ = f.NewSections(\"Interface\", \"Peer\", \"Peer\")\n\t\tassert.Equal(t, []string{DefaultSection, \"Interface\", \"Peer\", \"Peer\"}, f.SectionStrings())\n\t\tf.DeleteSection(\"Peer\")\n\t\tassert.Equal(t, []string{DefaultSection, \"Interface\"}, f.SectionStrings())\n\t})\n}\n\nfunc TestFile_NewRawSection(t *testing.T) {\n\tf := Empty()\n\trequire.NotNil(t, f)\n\n\tsec, err := f.NewRawSection(\"comments\", `1111111111111111111000000000000000001110000\n111111111111111111100000000000111000000000`)\n\trequire.NoError(t, err)\n\trequire.NotNil(t, sec)\n\tassert.Equal(t, \"comments\", sec.Name())\n\n\tassert.Equal(t, []string{DefaultSection, \"comments\"}, f.SectionStrings())\n\tassert.Equal(t, `1111111111111111111000000000000000001110000\n111111111111111111100000000000111000000000`, f.Section(\"comments\").Body())\n\n\tt.Run(\"with duplicated name\", func(t *testing.T) {\n\t\tsec, err := f.NewRawSection(\"comments\", `1111111111111111111000000000000000001110000`)\n\t\trequire.NoError(t, err)\n\t\trequire.NotNil(t, sec)\n\t\tassert.Equal(t, []string{DefaultSection, \"comments\"}, f.SectionStrings())\n\n\t\t// Overwrite previous existed section\n\t\tassert.Equal(t, `1111111111111111111000000000000000001110000`, f.Section(\"comments\").Body())\n\t})\n\n\tt.Run(\"with empty string\", func(t *testing.T) {\n\t\t_, err := f.NewRawSection(\"\", \"\")\n\t\trequire.Error(t, err)\n\t})\n}\n\nfunc TestFile_NewSections(t *testing.T) {\n\tf := Empty()\n\trequire.NotNil(t, f)\n\n\tassert.NoError(t, f.NewSections(\"package\", \"author\"))\n\tassert.Equal(t, []string{DefaultSection, \"package\", \"author\"}, f.SectionStrings())\n\n\tt.Run(\"with duplicated name\", func(t *testing.T) {\n\t\tassert.NoError(t, f.NewSections(\"author\", \"features\"))\n\n\t\t// Ignore section already exists\n\t\tassert.Equal(t, []string{DefaultSection, \"package\", \"author\", \"features\"}, f.SectionStrings())\n\t})\n\n\tt.Run(\"with empty string\", func(t *testing.T) {\n\t\tassert.Error(t, f.NewSections(\"\", \"\"))\n\t})\n}\n\nfunc TestFile_GetSection(t *testing.T) {\n\tf, err := Load(fullConf)\n\trequire.NoError(t, err)\n\trequire.NotNil(t, f)\n\n\tsec, err := f.GetSection(\"author\")\n\trequire.NoError(t, err)\n\trequire.NotNil(t, sec)\n\tassert.Equal(t, \"author\", sec.Name())\n\n\tt.Run(\"section not exists\", func(t *testing.T) {\n\t\t_, err := f.GetSection(\"404\")\n\t\trequire.Error(t, err)\n\t})\n}\n\nfunc TestFile_HasSection(t *testing.T) {\n\tf, err := Load(fullConf)\n\trequire.NoError(t, err)\n\trequire.NotNil(t, f)\n\n\tsec := f.HasSection(\"author\")\n\tassert.True(t, sec)\n\n\tt.Run(\"section not exists\", func(t *testing.T) {\n\t\tnonexistent := f.HasSection(\"404\")\n\t\tassert.False(t, nonexistent)\n\t})\n}\n\nfunc TestFile_Section(t *testing.T) {\n\tt.Run(\"get a section\", func(t *testing.T) {\n\t\tf, err := Load(fullConf)\n\t\trequire.NoError(t, err)\n\t\trequire.NotNil(t, f)\n\n\t\tsec := f.Section(\"author\")\n\t\trequire.NotNil(t, sec)\n\t\tassert.Equal(t, \"author\", sec.Name())\n\n\t\tt.Run(\"section not exists\", func(t *testing.T) {\n\t\t\tsec := f.Section(\"404\")\n\t\t\trequire.NotNil(t, sec)\n\t\t\tassert.Equal(t, \"404\", sec.Name())\n\t\t})\n\t})\n\n\tt.Run(\"get default section in lower case with insensitive load\", func(t *testing.T) {\n\t\tf, err := InsensitiveLoad([]byte(`\n[default]\nNAME = ini\nVERSION = v1`))\n\t\trequire.NoError(t, err)\n\t\trequire.NotNil(t, f)\n\n\t\tassert.Equal(t, \"ini\", f.Section(\"\").Key(\"name\").String())\n\t\tassert.Equal(t, \"v1\", f.Section(\"\").Key(\"version\").String())\n\t})\n\n\tt.Run(\"get sections after deletion\", func(t *testing.T) {\n\t\tf, err := Load([]byte(`\n[RANDOM]\n`))\n\t\trequire.NoError(t, err)\n\t\trequire.NotNil(t, f)\n\n\t\tsectionNames := f.SectionStrings()\n\t\tsort.Strings(sectionNames)\n\t\tassert.Equal(t, []string{DefaultSection, \"RANDOM\"}, sectionNames)\n\n\t\tfor _, currentSection := range sectionNames {\n\t\t\tf.DeleteSection(currentSection)\n\t\t}\n\n\t\tfor sectionParam, expectedSectionName := range map[string]string{\n\t\t\t\"\":       DefaultSection,\n\t\t\t\"RANDOM\": \"RANDOM\",\n\t\t} {\n\t\t\tsec := f.Section(sectionParam)\n\t\t\trequire.NotNil(t, sec)\n\t\t\tassert.Equal(t, expectedSectionName, sec.Name())\n\t\t}\n\t})\n\n}\n\nfunc TestFile_Sections(t *testing.T) {\n\tf, err := Load(fullConf)\n\trequire.NoError(t, err)\n\trequire.NotNil(t, f)\n\n\tsecs := f.Sections()\n\tnames := []string{DefaultSection, \"author\", \"package\", \"package.sub\", \"features\", \"types\", \"array\", \"note\", \"comments\", \"string escapes\", \"advance\"}\n\tassert.Len(t, secs, len(names))\n\tfor i, name := range names {\n\t\tassert.Equal(t, name, secs[i].Name())\n\t}\n}\n\nfunc TestFile_ChildSections(t *testing.T) {\n\tf, err := Load([]byte(`\n[node]\n[node.biz1]\n[node.biz2]\n[node.biz3]\n[node.bizN]\n`))\n\trequire.NoError(t, err)\n\trequire.NotNil(t, f)\n\n\tchildren := f.ChildSections(\"node\")\n\tnames := []string{\"node.biz1\", \"node.biz2\", \"node.biz3\", \"node.bizN\"}\n\tassert.Len(t, children, len(names))\n\tfor i, name := range names {\n\t\tassert.Equal(t, name, children[i].Name())\n\t}\n}\n\nfunc TestFile_SectionStrings(t *testing.T) {\n\tf, err := Load(fullConf)\n\trequire.NoError(t, err)\n\trequire.NotNil(t, f)\n\n\tassert.Equal(t, []string{DefaultSection, \"author\", \"package\", \"package.sub\", \"features\", \"types\", \"array\", \"note\", \"comments\", \"string escapes\", \"advance\"}, f.SectionStrings())\n}\n\nfunc TestFile_DeleteSection(t *testing.T) {\n\tt.Run(\"delete a section\", func(t *testing.T) {\n\t\tf := Empty()\n\t\trequire.NotNil(t, f)\n\n\t\t_ = f.NewSections(\"author\", \"package\", \"features\")\n\t\tf.DeleteSection(\"features\")\n\t\tf.DeleteSection(\"\")\n\t\tassert.Equal(t, []string{\"author\", \"package\"}, f.SectionStrings())\n\t})\n\n\tt.Run(\"delete default section\", func(t *testing.T) {\n\t\tf := Empty()\n\t\trequire.NotNil(t, f)\n\n\t\tf.Section(\"\").Key(\"foo\").SetValue(\"bar\")\n\t\tf.Section(\"section1\").Key(\"key1\").SetValue(\"value1\")\n\t\tf.DeleteSection(\"\")\n\t\tassert.Equal(t, []string{\"section1\"}, f.SectionStrings())\n\n\t\tvar buf bytes.Buffer\n\t\t_, err := f.WriteTo(&buf)\n\t\trequire.NoError(t, err)\n\n\t\tassert.Equal(t, `[section1]\nkey1 = value1\n`, buf.String())\n\t})\n\n\tt.Run(\"delete a section with InsensitiveSections\", func(t *testing.T) {\n\t\tf := Empty(LoadOptions{InsensitiveSections: true})\n\t\trequire.NotNil(t, f)\n\n\t\t_ = f.NewSections(\"author\", \"package\", \"features\")\n\t\tf.DeleteSection(\"FEATURES\")\n\t\tf.DeleteSection(\"\")\n\t\tassert.Equal(t, []string{\"author\", \"package\"}, f.SectionStrings())\n\t})\n}\n\nfunc TestFile_Append(t *testing.T) {\n\tf := Empty()\n\trequire.NotNil(t, f)\n\n\tassert.NoError(t, f.Append(minimalConf, []byte(`\n[author]\nNAME = Unknwon`)))\n\n\tt.Run(\"with bad input\", func(t *testing.T) {\n\t\tassert.Error(t, f.Append(123))\n\t\tassert.Error(t, f.Append(minimalConf, 123))\n\t})\n}\n\nfunc TestFile_WriteTo(t *testing.T) {\n\tif runtime.GOOS == \"windows\" {\n\t\tt.Skip(\"Skipping testing on Windows\")\n\t}\n\n\tt.Run(\"write content to somewhere\", func(t *testing.T) {\n\t\tf, err := Load(fullConf)\n\t\trequire.NoError(t, err)\n\t\trequire.NotNil(t, f)\n\n\t\tf.Section(\"author\").Comment = `Information about package author\n# Bio can be written in multiple lines.`\n\t\tf.Section(\"author\").Key(\"NAME\").Comment = \"This is author name\"\n\t\t_, _ = f.Section(\"note\").NewBooleanKey(\"boolean_key\")\n\t\t_, _ = f.Section(\"note\").NewKey(\"more\", \"notes\")\n\n\t\tvar buf bytes.Buffer\n\t\t_, err = f.WriteTo(&buf)\n\t\trequire.NoError(t, err)\n\n\t\tgolden := \"testdata/TestFile_WriteTo.golden\"\n\t\tif *update {\n\t\t\trequire.NoError(t, ioutil.WriteFile(golden, buf.Bytes(), 0644))\n\t\t}\n\n\t\texpected, err := ioutil.ReadFile(golden)\n\t\trequire.NoError(t, err)\n\t\tassert.Equal(t, string(expected), buf.String())\n\t})\n\n\tt.Run(\"support multiline comments\", func(t *testing.T) {\n\t\tf, err := Load([]byte(`\n# \n# general.domain\n# \n# Domain name of XX system.\ndomain      = mydomain.com\n`))\n\t\trequire.NoError(t, err)\n\n\t\tf.Section(\"\").Key(\"test\").Comment = \"Multiline\\nComment\"\n\n\t\tvar buf bytes.Buffer\n\t\t_, err = f.WriteTo(&buf)\n\t\trequire.NoError(t, err)\n\n\t\tassert.Equal(t, `# \n# general.domain\n# \n# Domain name of XX system.\ndomain = mydomain.com\n; Multiline\n; Comment\ntest   = \n`, buf.String())\n\n\t})\n\n\tt.Run(\"keep leading and trailing spaces in value\", func(t *testing.T) {\n\t\tf, _ := Load([]byte(`[foo]\nbar1 = '  val ue1 '\nbar2 = \"\"\"  val ue2 \"\"\"\nbar3 = \"  val ue3 \"\n`))\n\t\trequire.NotNil(t, f)\n\n\t\tvar buf bytes.Buffer\n\t\t_, err := f.WriteTo(&buf)\n\t\trequire.NoError(t, err)\n\t\tassert.Equal(t, `[foo]\nbar1 = \"  val ue1 \"\nbar2 = \"  val ue2 \"\nbar3 = \"  val ue3 \"\n`, buf.String())\n\t})\n}\n\nfunc TestFile_SaveTo(t *testing.T) {\n\tf, err := Load(fullConf)\n\trequire.NoError(t, err)\n\trequire.NotNil(t, f)\n\n\tassert.NoError(t, f.SaveTo(\"testdata/conf_out.ini\"))\n\tassert.NoError(t, f.SaveToIndent(\"testdata/conf_out.ini\", \"\\t\"))\n}\n\nfunc TestFile_WriteToWithOutputDelimiter(t *testing.T) {\n\tf, err := LoadSources(LoadOptions{\n\t\tKeyValueDelimiterOnWrite: \"->\",\n\t}, []byte(`[Others]\nCities = HangZhou|Boston\nVisits = 1993-10-07T20:17:05Z, 1993-10-07T20:17:05Z\nYears = 1993,1994\nNumbers = 10010,10086\nAges = 18,19\nPopulations = 12345678,98765432\nCoordinates = 192.168,10.11\nFlags       = true,false\nNote = Hello world!`))\n\trequire.NoError(t, err)\n\trequire.NotNil(t, f)\n\n\tvar actual bytes.Buffer\n\tvar expected = []byte(`[Others]\nCities      -> HangZhou|Boston\nVisits      -> 1993-10-07T20:17:05Z, 1993-10-07T20:17:05Z\nYears       -> 1993,1994\nNumbers     -> 10010,10086\nAges        -> 18,19\nPopulations -> 12345678,98765432\nCoordinates -> 192.168,10.11\nFlags       -> true,false\nNote        -> Hello world!\n`)\n\t_, err = f.WriteTo(&actual)\n\trequire.NoError(t, err)\n\n\tassert.Equal(t, expected, actual.Bytes())\n}\n\n// Inspired by https://github.com/go-ini/ini/issues/207\nfunc TestReloadAfterShadowLoad(t *testing.T) {\n\tf, err := ShadowLoad([]byte(`\n[slice]\nv = 1\nv = 2\nv = 3\n`))\n\trequire.NoError(t, err)\n\trequire.NotNil(t, f)\n\n\tassert.Equal(t, []string{\"1\", \"2\", \"3\"}, f.Section(\"slice\").Key(\"v\").ValueWithShadows())\n\n\trequire.NoError(t, f.Reload())\n\tassert.Equal(t, []string{\"1\", \"2\", \"3\"}, f.Section(\"slice\").Key(\"v\").ValueWithShadows())\n}\n"
        },
        {
          "name": "helper.go",
          "type": "blob",
          "size": 0.7021484375,
          "content": "// Copyright 2019 Unknwon\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"): you may\n// not use this file except in compliance with the License. You may obtain\n// a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n// WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n// License for the specific language governing permissions and limitations\n// under the License.\n\npackage ini\n\nfunc inSlice(str string, s []string) bool {\n\tfor _, v := range s {\n\t\tif str == v {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n"
        },
        {
          "name": "helper_test.go",
          "type": "blob",
          "size": 0.7783203125,
          "content": "// Copyright 2019 Unknwon\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"): you may\n// not use this file except in compliance with the License. You may obtain\n// a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n// WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n// License for the specific language governing permissions and limitations\n// under the License.\n\npackage ini\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestIsInSlice(t *testing.T) {\n\tss := []string{\"a\", \"b\", \"c\"}\n\tassert.True(t, inSlice(\"a\", ss))\n\tassert.False(t, inSlice(\"d\", ss))\n}\n"
        },
        {
          "name": "ini.go",
          "type": "blob",
          "size": 7.8623046875,
          "content": "// Copyright 2014 Unknwon\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"): you may\n// not use this file except in compliance with the License. You may obtain\n// a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n// WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n// License for the specific language governing permissions and limitations\n// under the License.\n\n// Package ini provides INI file read and write functionality in Go.\npackage ini\n\nimport (\n\t\"os\"\n\t\"regexp\"\n\t\"runtime\"\n\t\"strings\"\n)\n\nconst (\n\t// Maximum allowed depth when recursively substituing variable names.\n\tdepthValues = 99\n)\n\nvar (\n\t// DefaultSection is the name of default section. You can use this var or the string literal.\n\t// In most of cases, an empty string is all you need to access the section.\n\tDefaultSection = \"DEFAULT\"\n\n\t// LineBreak is the delimiter to determine or compose a new line.\n\t// This variable will be changed to \"\\r\\n\" automatically on Windows at package init time.\n\tLineBreak = \"\\n\"\n\n\t// Variable regexp pattern: %(variable)s\n\tvarPattern = regexp.MustCompile(`%\\(([^)]+)\\)s`)\n\n\t// DefaultHeader explicitly writes default section header.\n\tDefaultHeader = false\n\n\t// PrettySection indicates whether to put a line between sections.\n\tPrettySection = true\n\t// PrettyFormat indicates whether to align \"=\" sign with spaces to produce pretty output\n\t// or reduce all possible spaces for compact format.\n\tPrettyFormat = true\n\t// PrettyEqual places spaces around \"=\" sign even when PrettyFormat is false.\n\tPrettyEqual = false\n\t// DefaultFormatLeft places custom spaces on the left when PrettyFormat and PrettyEqual are both disabled.\n\tDefaultFormatLeft = \"\"\n\t// DefaultFormatRight places custom spaces on the right when PrettyFormat and PrettyEqual are both disabled.\n\tDefaultFormatRight = \"\"\n)\n\nvar inTest = len(os.Args) > 0 && strings.HasSuffix(strings.TrimSuffix(os.Args[0], \".exe\"), \".test\")\n\nfunc init() {\n\tif runtime.GOOS == \"windows\" && !inTest {\n\t\tLineBreak = \"\\r\\n\"\n\t}\n}\n\n// LoadOptions contains all customized options used for load data source(s).\ntype LoadOptions struct {\n\t// Loose indicates whether the parser should ignore nonexistent files or return error.\n\tLoose bool\n\t// Insensitive indicates whether the parser forces all section and key names to lowercase.\n\tInsensitive bool\n\t// InsensitiveSections indicates whether the parser forces all section to lowercase.\n\tInsensitiveSections bool\n\t// InsensitiveKeys indicates whether the parser forces all key names to lowercase.\n\tInsensitiveKeys bool\n\t// IgnoreContinuation indicates whether to ignore continuation lines while parsing.\n\tIgnoreContinuation bool\n\t// IgnoreInlineComment indicates whether to ignore comments at the end of value and treat it as part of value.\n\tIgnoreInlineComment bool\n\t// SkipUnrecognizableLines indicates whether to skip unrecognizable lines that do not conform to key/value pairs.\n\tSkipUnrecognizableLines bool\n\t// ShortCircuit indicates whether to ignore other configuration sources after loaded the first available configuration source.\n\tShortCircuit bool\n\t// AllowBooleanKeys indicates whether to allow boolean type keys or treat as value is missing.\n\t// This type of keys are mostly used in my.cnf.\n\tAllowBooleanKeys bool\n\t// AllowShadows indicates whether to keep track of keys with same name under same section.\n\tAllowShadows bool\n\t// AllowNestedValues indicates whether to allow AWS-like nested values.\n\t// Docs: http://docs.aws.amazon.com/cli/latest/topic/config-vars.html#nested-values\n\tAllowNestedValues bool\n\t// AllowPythonMultilineValues indicates whether to allow Python-like multi-line values.\n\t// Docs: https://docs.python.org/3/library/configparser.html#supported-ini-file-structure\n\t// Relevant quote:  Values can also span multiple lines, as long as they are indented deeper\n\t// than the first line of the value.\n\tAllowPythonMultilineValues bool\n\t// SpaceBeforeInlineComment indicates whether to allow comment symbols (\\# and \\;) inside value.\n\t// Docs: https://docs.python.org/2/library/configparser.html\n\t// Quote: Comments may appear on their own in an otherwise empty line, or may be entered in lines holding values or section names.\n\t// In the latter case, they need to be preceded by a whitespace character to be recognized as a comment.\n\tSpaceBeforeInlineComment bool\n\t// UnescapeValueDoubleQuotes indicates whether to unescape double quotes inside value to regular format\n\t// when value is surrounded by double quotes, e.g. key=\"a \\\"value\\\"\" => key=a \"value\"\n\tUnescapeValueDoubleQuotes bool\n\t// UnescapeValueCommentSymbols indicates to unescape comment symbols (\\# and \\;) inside value to regular format\n\t// when value is NOT surrounded by any quotes.\n\t// Note: UNSTABLE, behavior might change to only unescape inside double quotes but may noy necessary at all.\n\tUnescapeValueCommentSymbols bool\n\t// UnparseableSections stores a list of blocks that are allowed with raw content which do not otherwise\n\t// conform to key/value pairs. Specify the names of those blocks here.\n\tUnparseableSections []string\n\t// KeyValueDelimiters is the sequence of delimiters that are used to separate key and value. By default, it is \"=:\".\n\tKeyValueDelimiters string\n\t// KeyValueDelimiterOnWrite is the delimiter that are used to separate key and value output. By default, it is \"=\".\n\tKeyValueDelimiterOnWrite string\n\t// ChildSectionDelimiter is the delimiter that is used to separate child sections. By default, it is \".\".\n\tChildSectionDelimiter string\n\t// PreserveSurroundedQuote indicates whether to preserve surrounded quote (single and double quotes).\n\tPreserveSurroundedQuote bool\n\t// DebugFunc is called to collect debug information (currently only useful to debug parsing Python-style multiline values).\n\tDebugFunc DebugFunc\n\t// ReaderBufferSize is the buffer size of the reader in bytes.\n\tReaderBufferSize int\n\t// AllowNonUniqueSections indicates whether to allow sections with the same name multiple times.\n\tAllowNonUniqueSections bool\n\t// AllowDuplicateShadowValues indicates whether values for shadowed keys should be deduplicated.\n\tAllowDuplicateShadowValues bool\n}\n\n// DebugFunc is the type of function called to log parse events.\ntype DebugFunc func(message string)\n\n// LoadSources allows caller to apply customized options for loading from data source(s).\nfunc LoadSources(opts LoadOptions, source interface{}, others ...interface{}) (_ *File, err error) {\n\tsources := make([]dataSource, len(others)+1)\n\tsources[0], err = parseDataSource(source)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tfor i := range others {\n\t\tsources[i+1], err = parseDataSource(others[i])\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\tf := newFile(sources, opts)\n\tif err = f.Reload(); err != nil {\n\t\treturn nil, err\n\t}\n\treturn f, nil\n}\n\n// Load loads and parses from INI data sources.\n// Arguments can be mixed of file name with string type, or raw data in []byte.\n// It will return error if list contains nonexistent files.\nfunc Load(source interface{}, others ...interface{}) (*File, error) {\n\treturn LoadSources(LoadOptions{}, source, others...)\n}\n\n// LooseLoad has exactly same functionality as Load function\n// except it ignores nonexistent files instead of returning error.\nfunc LooseLoad(source interface{}, others ...interface{}) (*File, error) {\n\treturn LoadSources(LoadOptions{Loose: true}, source, others...)\n}\n\n// InsensitiveLoad has exactly same functionality as Load function\n// except it forces all section and key names to be lowercased.\nfunc InsensitiveLoad(source interface{}, others ...interface{}) (*File, error) {\n\treturn LoadSources(LoadOptions{Insensitive: true}, source, others...)\n}\n\n// ShadowLoad has exactly same functionality as Load function\n// except it allows have shadow keys.\nfunc ShadowLoad(source interface{}, others ...interface{}) (*File, error) {\n\treturn LoadSources(LoadOptions{AllowShadows: true}, source, others...)\n}\n"
        },
        {
          "name": "ini_test.go",
          "type": "blob",
          "size": 48.2646484375,
          "content": "// Copyright 2014 Unknwon\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"): you may\n// not use this file except in compliance with the License. You may obtain\n// a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n// WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n// License for the specific language governing permissions and limitations\n// under the License.\n\npackage ini\n\nimport (\n\t\"bytes\"\n\t\"flag\"\n\t\"io/ioutil\"\n\t\"path/filepath\"\n\t\"runtime\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n\t\"github.com/stretchr/testify/require\"\n)\n\nconst (\n\tconfData = `\n\t; Package name\n\tNAME        = ini\n\t; Package version\n\tVERSION     = v1\n\t; Package import path\n\tIMPORT_PATH = gopkg.in/%(NAME)s.%(VERSION)s\n\t\n\t# Information about package author\n\t# Bio can be written in multiple lines.\n\t[author]\n\tNAME   = Unknwon  ; Succeeding comment\n\tE-MAIL = fake@localhost\n\tGITHUB = https://github.com/%(NAME)s\n\tBIO    = \"\"\"Gopher.\n\tCoding addict.\n\tGood man.\n\t\"\"\"  # Succeeding comment`\n\tminimalConf  = \"testdata/minimal.ini\"\n\tfullConf     = \"testdata/full.ini\"\n\tnotFoundConf = \"testdata/404.ini\"\n)\n\nvar update = flag.Bool(\"update\", false, \"Update .golden files\")\n\nfunc TestLoad(t *testing.T) {\n\tt.Run(\"load from good data sources\", func(t *testing.T) {\n\t\tf, err := Load(\n\t\t\t\"testdata/minimal.ini\",\n\t\t\t[]byte(\"NAME = ini\\nIMPORT_PATH = gopkg.in/%(NAME)s.%(VERSION)s\"),\n\t\t\tbytes.NewReader([]byte(`VERSION = v1`)),\n\t\t\tioutil.NopCloser(bytes.NewReader([]byte(\"[author]\\nNAME = Unknwon\"))),\n\t\t)\n\t\trequire.NoError(t, err)\n\t\trequire.NotNil(t, f)\n\n\t\t// Validate values make sure all sources are loaded correctly\n\t\tsec := f.Section(\"\")\n\t\tassert.Equal(t, \"ini\", sec.Key(\"NAME\").String())\n\t\tassert.Equal(t, \"v1\", sec.Key(\"VERSION\").String())\n\t\tassert.Equal(t, \"gopkg.in/ini.v1\", sec.Key(\"IMPORT_PATH\").String())\n\n\t\tsec = f.Section(\"author\")\n\t\tassert.Equal(t, \"Unknwon\", sec.Key(\"NAME\").String())\n\t\tassert.Equal(t, \"u@gogs.io\", sec.Key(\"E-MAIL\").String())\n\t})\n\n\tt.Run(\"load from bad data sources\", func(t *testing.T) {\n\t\tt.Run(\"invalid input\", func(t *testing.T) {\n\t\t\t_, err := Load(notFoundConf)\n\t\t\trequire.Error(t, err)\n\t\t})\n\n\t\tt.Run(\"unsupported type\", func(t *testing.T) {\n\t\t\t_, err := Load(123)\n\t\t\trequire.Error(t, err)\n\t\t})\n\t})\n\n\tt.Run(\"cannot properly parse INI files containing `#` or `;` in value\", func(t *testing.T) {\n\t\tf, err := Load([]byte(`\n\t[author]\n\tNAME = U#n#k#n#w#o#n\n\tGITHUB = U;n;k;n;w;o;n\n\t`))\n\t\trequire.NoError(t, err)\n\t\trequire.NotNil(t, f)\n\n\t\tsec := f.Section(\"author\")\n\t\tnameValue := sec.Key(\"NAME\").String()\n\t\tgithubValue := sec.Key(\"GITHUB\").String()\n\t\tassert.Equal(t, \"U\", nameValue)\n\t\tassert.Equal(t, \"U\", githubValue)\n\t})\n\n\tt.Run(\"cannot parse small python-compatible INI files\", func(t *testing.T) {\n\t\tf, err := Load([]byte(`\n[long]\nlong_rsa_private_key = -----BEGIN RSA PRIVATE KEY-----\n   foo\n   bar\n   foobar\n   barfoo\n   -----END RSA PRIVATE KEY-----\n`))\n\t\trequire.Error(t, err)\n\t\tassert.Nil(t, f)\n\t\tassert.Equal(t, \"key-value delimiter not found: foo\\n\", err.Error())\n\t})\n\n\tt.Run(\"cannot parse big python-compatible INI files\", func(t *testing.T) {\n\t\tf, err := Load([]byte(`\n[long]\nlong_rsa_private_key = -----BEGIN RSA PRIVATE KEY-----\n   1foo\n   2bar\n   3foobar\n   4barfoo\n   5foo\n   6bar\n   7foobar\n   8barfoo\n   9foo\n   10bar\n   11foobar\n   12barfoo\n   13foo\n   14bar\n   15foobar\n   16barfoo\n   17foo\n   18bar\n   19foobar\n   20barfoo\n   21foo\n   22bar\n   23foobar\n   24barfoo\n   25foo\n   26bar\n   27foobar\n   28barfoo\n   29foo\n   30bar\n   31foobar\n   32barfoo\n   33foo\n   34bar\n   35foobar\n   36barfoo\n   37foo\n   38bar\n   39foobar\n   40barfoo\n   41foo\n   42bar\n   43foobar\n   44barfoo\n   45foo\n   46bar\n   47foobar\n   48barfoo\n   49foo\n   50bar\n   51foobar\n   52barfoo\n   53foo\n   54bar\n   55foobar\n   56barfoo\n   57foo\n   58bar\n   59foobar\n   60barfoo\n   61foo\n   62bar\n   63foobar\n   64barfoo\n   65foo\n   66bar\n   67foobar\n   68barfoo\n   69foo\n   70bar\n   71foobar\n   72barfoo\n   73foo\n   74bar\n   75foobar\n   76barfoo\n   77foo\n   78bar\n   79foobar\n   80barfoo\n   81foo\n   82bar\n   83foobar\n   84barfoo\n   85foo\n   86bar\n   87foobar\n   88barfoo\n   89foo\n   90bar\n   91foobar\n   92barfoo\n   93foo\n   94bar\n   95foobar\n   96barfoo\n   -----END RSA PRIVATE KEY-----\n`))\n\t\trequire.Error(t, err)\n\t\tassert.Nil(t, f)\n\t\tassert.Equal(t, \"key-value delimiter not found: 1foo\\n\", err.Error())\n\t})\n}\n\nfunc TestLooseLoad(t *testing.T) {\n\tf, err := LoadSources(LoadOptions{Loose: true}, notFoundConf, minimalConf)\n\trequire.NoError(t, err)\n\trequire.NotNil(t, f)\n\n\tt.Run(\"inverse case\", func(t *testing.T) {\n\t\t_, err = Load(notFoundConf)\n\t\trequire.Error(t, err)\n\t})\n}\n\nfunc TestInsensitiveLoad(t *testing.T) {\n\tt.Run(\"insensitive to section and key names\", func(t *testing.T) {\n\t\tf, err := InsensitiveLoad(minimalConf)\n\t\trequire.NoError(t, err)\n\t\trequire.NotNil(t, f)\n\n\t\tassert.Equal(t, \"u@gogs.io\", f.Section(\"Author\").Key(\"e-mail\").String())\n\n\t\tt.Run(\"write out\", func(t *testing.T) {\n\t\t\tvar buf bytes.Buffer\n\t\t\t_, err := f.WriteTo(&buf)\n\t\t\trequire.NoError(t, err)\n\t\t\tassert.Equal(t, `[author]\ne-mail = u@gogs.io\n`,\n\t\t\t\tbuf.String(),\n\t\t\t)\n\t\t})\n\n\t\tt.Run(\"inverse case\", func(t *testing.T) {\n\t\t\tf, err := Load(minimalConf)\n\t\t\trequire.NoError(t, err)\n\t\t\trequire.NotNil(t, f)\n\n\t\t\tassert.Empty(t, f.Section(\"Author\").Key(\"e-mail\").String())\n\t\t})\n\t})\n\n\t// Ref: https://github.com/go-ini/ini/issues/198\n\tt.Run(\"insensitive load with default section\", func(t *testing.T) {\n\t\tf, err := InsensitiveLoad([]byte(`\nuser = unknwon\n[profile]\nemail = unknwon@local\n`))\n\t\trequire.NoError(t, err)\n\t\trequire.NotNil(t, f)\n\n\t\tassert.Equal(t, \"unknwon\", f.Section(DefaultSection).Key(\"user\").String())\n\t})\n}\n\nfunc TestLoadSources(t *testing.T) {\n\tt.Run(\"with true `AllowPythonMultilineValues`\", func(t *testing.T) {\n\t\tt.Run(\"ignore nonexistent files\", func(t *testing.T) {\n\t\t\tf, err := LoadSources(LoadOptions{AllowPythonMultilineValues: true, Loose: true}, notFoundConf, minimalConf)\n\t\t\trequire.NoError(t, err)\n\t\t\trequire.NotNil(t, f)\n\n\t\t\tt.Run(\"inverse case\", func(t *testing.T) {\n\t\t\t\t_, err = LoadSources(LoadOptions{AllowPythonMultilineValues: true}, notFoundConf)\n\t\t\t\trequire.Error(t, err)\n\t\t\t})\n\t\t})\n\n\t\tt.Run(\"insensitive to section and key names\", func(t *testing.T) {\n\t\t\tf, err := LoadSources(LoadOptions{AllowPythonMultilineValues: true, Insensitive: true}, minimalConf)\n\t\t\trequire.NoError(t, err)\n\t\t\trequire.NotNil(t, f)\n\n\t\t\tassert.Equal(t, \"u@gogs.io\", f.Section(\"Author\").Key(\"e-mail\").String())\n\n\t\t\tt.Run(\"write out\", func(t *testing.T) {\n\t\t\t\tvar buf bytes.Buffer\n\t\t\t\t_, err := f.WriteTo(&buf)\n\t\t\t\trequire.NoError(t, err)\n\t\t\t\tassert.Equal(t, `[author]\ne-mail = u@gogs.io\n`,\n\t\t\t\t\tbuf.String(),\n\t\t\t\t)\n\t\t\t})\n\n\t\t\tt.Run(\"inverse case\", func(t *testing.T) {\n\t\t\t\tf, err := LoadSources(LoadOptions{AllowPythonMultilineValues: true}, minimalConf)\n\t\t\t\trequire.NoError(t, err)\n\t\t\t\trequire.NotNil(t, f)\n\n\t\t\t\tassert.Empty(t, f.Section(\"Author\").Key(\"e-mail\").String())\n\t\t\t})\n\t\t})\n\n\t\tt.Run(\"insensitive to sections and sensitive to key names\", func(t *testing.T) {\n\t\t\tf, err := LoadSources(LoadOptions{InsensitiveSections: true}, minimalConf)\n\t\t\trequire.NoError(t, err)\n\t\t\trequire.NotNil(t, f)\n\n\t\t\tassert.Equal(t, \"u@gogs.io\", f.Section(\"Author\").Key(\"E-MAIL\").String())\n\n\t\t\tt.Run(\"write out\", func(t *testing.T) {\n\t\t\t\tvar buf bytes.Buffer\n\t\t\t\t_, err := f.WriteTo(&buf)\n\t\t\t\trequire.NoError(t, err)\n\t\t\t\tassert.Equal(t, `[author]\nE-MAIL = u@gogs.io\n`,\n\t\t\t\t\tbuf.String(),\n\t\t\t\t)\n\t\t\t})\n\n\t\t\tt.Run(\"inverse case\", func(t *testing.T) {\n\t\t\t\tf, err := LoadSources(LoadOptions{}, minimalConf)\n\t\t\t\trequire.NoError(t, err)\n\t\t\t\trequire.NotNil(t, f)\n\n\t\t\t\tassert.Empty(t, f.Section(\"Author\").Key(\"e-mail\").String())\n\t\t\t})\n\t\t})\n\n\t\tt.Run(\"sensitive to sections and insensitive to key names\", func(t *testing.T) {\n\t\t\tf, err := LoadSources(LoadOptions{InsensitiveKeys: true}, minimalConf)\n\t\t\trequire.NoError(t, err)\n\t\t\trequire.NotNil(t, f)\n\n\t\t\tassert.Equal(t, \"u@gogs.io\", f.Section(\"author\").Key(\"e-mail\").String())\n\n\t\t\tt.Run(\"write out\", func(t *testing.T) {\n\t\t\t\tvar buf bytes.Buffer\n\t\t\t\t_, err := f.WriteTo(&buf)\n\t\t\t\trequire.NoError(t, err)\n\t\t\t\tassert.Equal(t, `[author]\ne-mail = u@gogs.io\n`,\n\t\t\t\t\tbuf.String(),\n\t\t\t\t)\n\t\t\t})\n\n\t\t\tt.Run(\"inverse case\", func(t *testing.T) {\n\t\t\t\tf, err := LoadSources(LoadOptions{}, minimalConf)\n\t\t\t\trequire.NoError(t, err)\n\t\t\t\trequire.NotNil(t, f)\n\n\t\t\t\tassert.Empty(t, f.Section(\"Author\").Key(\"e-mail\").String())\n\t\t\t})\n\t\t})\n\n\t\tt.Run(\"ignore continuation lines\", func(t *testing.T) {\n\t\t\tf, err := LoadSources(LoadOptions{\n\t\t\t\tAllowPythonMultilineValues: true,\n\t\t\t\tIgnoreContinuation:         true,\n\t\t\t}, []byte(`\nkey1=a\\b\\\nkey2=c\\d\\\nkey3=value`))\n\t\t\trequire.NoError(t, err)\n\t\t\trequire.NotNil(t, f)\n\n\t\t\tassert.Equal(t, `a\\b\\`, f.Section(\"\").Key(\"key1\").String())\n\t\t\tassert.Equal(t, `c\\d\\`, f.Section(\"\").Key(\"key2\").String())\n\t\t\tassert.Equal(t, \"value\", f.Section(\"\").Key(\"key3\").String())\n\n\t\t\tt.Run(\"inverse case\", func(t *testing.T) {\n\t\t\t\tf, err := LoadSources(LoadOptions{AllowPythonMultilineValues: true}, []byte(`\nkey1=a\\b\\\nkey2=c\\d\\`))\n\t\t\t\trequire.NoError(t, err)\n\t\t\t\trequire.NotNil(t, f)\n\n\t\t\t\tassert.Equal(t, `a\\bkey2=c\\d`, f.Section(\"\").Key(\"key1\").String())\n\t\t\t})\n\t\t})\n\n\t\tt.Run(\"ignore inline comments\", func(t *testing.T) {\n\t\t\tf, err := LoadSources(LoadOptions{\n\t\t\t\tAllowPythonMultilineValues: true,\n\t\t\t\tIgnoreInlineComment:        true,\n\t\t\t}, []byte(`\nkey1=value ;comment\nkey2=value2 #comment2\nkey3=val#ue #comment3`))\n\t\t\trequire.NoError(t, err)\n\t\t\trequire.NotNil(t, f)\n\n\t\t\tassert.Equal(t, `value ;comment`, f.Section(\"\").Key(\"key1\").String())\n\t\t\tassert.Equal(t, `value2 #comment2`, f.Section(\"\").Key(\"key2\").String())\n\t\t\tassert.Equal(t, `val#ue #comment3`, f.Section(\"\").Key(\"key3\").String())\n\n\t\t\tt.Run(\"inverse case\", func(t *testing.T) {\n\t\t\t\tf, err := LoadSources(LoadOptions{AllowPythonMultilineValues: true}, []byte(`\nkey1=value ;comment\nkey2=value2 #comment2`))\n\t\t\t\trequire.NoError(t, err)\n\t\t\t\trequire.NotNil(t, f)\n\n\t\t\t\tassert.Equal(t, `value`, f.Section(\"\").Key(\"key1\").String())\n\t\t\t\tassert.Equal(t, `;comment`, f.Section(\"\").Key(\"key1\").Comment)\n\t\t\t\tassert.Equal(t, `value2`, f.Section(\"\").Key(\"key2\").String())\n\t\t\t\tassert.Equal(t, `#comment2`, f.Section(\"\").Key(\"key2\").Comment)\n\t\t\t})\n\t\t})\n\n\t\tt.Run(\"skip unrecognizable lines\", func(t *testing.T) {\n\t\t\tf, err := LoadSources(LoadOptions{\n\t\t\t\tSkipUnrecognizableLines: true,\n\t\t\t}, []byte(`\nGenerationDepth: 13\n\nBiomeRarityScale: 100\n\n################\n# Biome Groups #\n################\n\nBiomeGroup(NormalBiomes, 3, 99, RoofedForestEnchanted, ForestSakura, FloatingJungle\nBiomeGroup(IceBiomes, 4, 85, Ice Plains)\n\n= RainForest\n`))\n\t\t\trequire.NoError(t, err)\n\t\t\trequire.NotNil(t, f)\n\n\t\t\tassert.Equal(t, \"13\", f.Section(\"\").Key(\"GenerationDepth\").String())\n\t\t\tassert.Equal(t, \"100\", f.Section(\"\").Key(\"BiomeRarityScale\").String())\n\t\t\tassert.False(t, f.Section(\"\").HasKey(\"BiomeGroup\"))\n\t\t})\n\n\t\tt.Run(\"allow boolean type keys\", func(t *testing.T) {\n\t\t\tf, err := LoadSources(LoadOptions{\n\t\t\t\tAllowPythonMultilineValues: true,\n\t\t\t\tAllowBooleanKeys:           true,\n\t\t\t}, []byte(`\nkey1=hello\n#key2\nkey3`))\n\t\t\trequire.NoError(t, err)\n\t\t\trequire.NotNil(t, f)\n\n\t\t\tassert.Equal(t, []string{\"key1\", \"key3\"}, f.Section(\"\").KeyStrings())\n\t\t\tassert.True(t, f.Section(\"\").Key(\"key3\").MustBool(false))\n\n\t\t\tt.Run(\"write out\", func(t *testing.T) {\n\t\t\t\tvar buf bytes.Buffer\n\t\t\t\t_, err := f.WriteTo(&buf)\n\t\t\t\trequire.NoError(t, err)\n\t\t\t\tassert.Equal(t, `key1 = hello\n# key2\nkey3\n`,\n\t\t\t\t\tbuf.String(),\n\t\t\t\t)\n\t\t\t})\n\n\t\t\tt.Run(\"inverse case\", func(t *testing.T) {\n\t\t\t\t_, err := LoadSources(LoadOptions{AllowPythonMultilineValues: true}, []byte(`\nkey1=hello\n#key2\nkey3`))\n\t\t\t\trequire.Error(t, err)\n\t\t\t})\n\t\t})\n\n\t\tt.Run(\"allow shadow keys\", func(t *testing.T) {\n\t\t\tf, err := LoadSources(LoadOptions{AllowShadows: true, AllowPythonMultilineValues: true}, []byte(`\n[remote \"origin\"]\nurl = https://github.com/Antergone/test1.git\nurl = https://github.com/Antergone/test2.git\nfetch = +refs/heads/*:refs/remotes/origin/*`))\n\t\t\trequire.NoError(t, err)\n\t\t\trequire.NotNil(t, f)\n\n\t\t\tassert.Equal(t, \"https://github.com/Antergone/test1.git\", f.Section(`remote \"origin\"`).Key(\"url\").String())\n\t\t\tassert.Equal(\n\t\t\t\tt,\n\t\t\t\t[]string{\n\t\t\t\t\t\"https://github.com/Antergone/test1.git\",\n\t\t\t\t\t\"https://github.com/Antergone/test2.git\",\n\t\t\t\t},\n\t\t\t\tf.Section(`remote \"origin\"`).Key(\"url\").ValueWithShadows(),\n\t\t\t)\n\t\t\tassert.Equal(t, \"+refs/heads/*:refs/remotes/origin/*\", f.Section(`remote \"origin\"`).Key(\"fetch\").String())\n\n\t\t\tt.Run(\"write out\", func(t *testing.T) {\n\t\t\t\tvar buf bytes.Buffer\n\t\t\t\t_, err := f.WriteTo(&buf)\n\t\t\t\trequire.NoError(t, err)\n\t\t\t\tassert.Equal(t, `[remote \"origin\"]\nurl   = https://github.com/Antergone/test1.git\nurl   = https://github.com/Antergone/test2.git\nfetch = +refs/heads/*:refs/remotes/origin/*\n`,\n\t\t\t\t\tbuf.String(),\n\t\t\t\t)\n\t\t\t})\n\n\t\t\tt.Run(\"inverse case\", func(t *testing.T) {\n\t\t\t\tf, err := LoadSources(LoadOptions{AllowPythonMultilineValues: true}, []byte(`\n[remote \"origin\"]\nurl = https://github.com/Antergone/test1.git\nurl = https://github.com/Antergone/test2.git`))\n\t\t\t\trequire.NoError(t, err)\n\t\t\t\trequire.NotNil(t, f)\n\n\t\t\t\tassert.Equal(t, \"https://github.com/Antergone/test2.git\", f.Section(`remote \"origin\"`).Key(\"url\").String())\n\t\t\t})\n\t\t})\n\n\t\tt.Run(\"unescape double quotes inside value\", func(t *testing.T) {\n\t\t\tf, err := LoadSources(LoadOptions{\n\t\t\t\tAllowPythonMultilineValues: true,\n\t\t\t\tUnescapeValueDoubleQuotes:  true,\n\t\t\t}, []byte(`\ncreate_repo=\"创建了仓库 <a href=\\\"%s\\\">%s</a>\"`))\n\t\t\trequire.NoError(t, err)\n\t\t\trequire.NotNil(t, f)\n\n\t\t\tassert.Equal(t, `创建了仓库 <a href=\"%s\">%s</a>`, f.Section(\"\").Key(\"create_repo\").String())\n\n\t\t\tt.Run(\"inverse case\", func(t *testing.T) {\n\t\t\t\tf, err := LoadSources(LoadOptions{AllowPythonMultilineValues: true}, []byte(`\ncreate_repo=\"创建了仓库 <a href=\\\"%s\\\">%s</a>\"`))\n\t\t\t\trequire.NoError(t, err)\n\t\t\t\trequire.NotNil(t, f)\n\n\t\t\t\tassert.Equal(t, `\"创建了仓库 <a href=\\\"%s\\\">%s</a>\"`, f.Section(\"\").Key(\"create_repo\").String())\n\t\t\t})\n\t\t})\n\n\t\tt.Run(\"unescape comment symbols inside value\", func(t *testing.T) {\n\t\t\tf, err := LoadSources(LoadOptions{\n\t\t\t\tAllowPythonMultilineValues:  true,\n\t\t\t\tIgnoreInlineComment:         true,\n\t\t\t\tUnescapeValueCommentSymbols: true,\n\t\t\t}, []byte(`\nkey = test value <span style=\"color: %s\\; background: %s\">more text</span>\n`))\n\t\t\trequire.NoError(t, err)\n\t\t\trequire.NotNil(t, f)\n\n\t\t\tassert.Equal(t, `test value <span style=\"color: %s; background: %s\">more text</span>`, f.Section(\"\").Key(\"key\").String())\n\t\t})\n\n\t\tt.Run(\"can parse small python-compatible INI files\", func(t *testing.T) {\n\t\t\tf, err := LoadSources(LoadOptions{\n\t\t\t\tAllowPythonMultilineValues: true,\n\t\t\t\tInsensitive:                true,\n\t\t\t\tUnparseableSections:        []string{\"core_lesson\", \"comments\"},\n\t\t\t}, []byte(`\n[long]\nlong_rsa_private_key = -----BEGIN RSA PRIVATE KEY-----\n  foo\n  bar\n  foobar\n  barfoo\n  -----END RSA PRIVATE KEY-----\nmultiline_list =\n  first\n  second\n  third\n`))\n\t\t\trequire.NoError(t, err)\n\t\t\trequire.NotNil(t, f)\n\n\t\t\tassert.Equal(t, \"-----BEGIN RSA PRIVATE KEY-----\\n  foo\\n  bar\\n  foobar\\n  barfoo\\n  -----END RSA PRIVATE KEY-----\", f.Section(\"long\").Key(\"long_rsa_private_key\").String())\n\t\t\tassert.Equal(t, \"\\n  first\\n  second\\n  third\", f.Section(\"long\").Key(\"multiline_list\").String())\n\t\t})\n\n\t\tt.Run(\"can parse big python-compatible INI files\", func(t *testing.T) {\n\t\t\tf, err := LoadSources(LoadOptions{\n\t\t\t\tAllowPythonMultilineValues: true,\n\t\t\t\tInsensitive:                true,\n\t\t\t\tUnparseableSections:        []string{\"core_lesson\", \"comments\"},\n\t\t\t}, []byte(`\n[long]\nlong_rsa_private_key = -----BEGIN RSA PRIVATE KEY-----\n   1foo\n   2bar\n   3foobar\n   4barfoo\n   5foo\n   6bar\n   7foobar\n   8barfoo\n   9foo\n   10bar\n   11foobar\n   12barfoo\n   13foo\n   14bar\n   15foobar\n   16barfoo\n   17foo\n   18bar\n   19foobar\n   20barfoo\n   21foo\n   22bar\n   23foobar\n   24barfoo\n   25foo\n   26bar\n   27foobar\n   28barfoo\n   29foo\n   30bar\n   31foobar\n   32barfoo\n   33foo\n   34bar\n   35foobar\n   36barfoo\n   37foo\n   38bar\n   39foobar\n   40barfoo\n   41foo\n   42bar\n   43foobar\n   44barfoo\n   45foo\n   46bar\n   47foobar\n   48barfoo\n   49foo\n   50bar\n   51foobar\n   52barfoo\n   53foo\n   54bar\n   55foobar\n   56barfoo\n   57foo\n   58bar\n   59foobar\n   60barfoo\n   61foo\n   62bar\n   63foobar\n   64barfoo\n   65foo\n   66bar\n   67foobar\n   68barfoo\n   69foo\n   70bar\n   71foobar\n   72barfoo\n   73foo\n   74bar\n   75foobar\n   76barfoo\n   77foo\n   78bar\n   79foobar\n   80barfoo\n   81foo\n   82bar\n   83foobar\n   84barfoo\n   85foo\n   86bar\n   87foobar\n   88barfoo\n   89foo\n   90bar\n   91foobar\n   92barfoo\n   93foo\n   94bar\n   95foobar\n   96barfoo\n   -----END RSA PRIVATE KEY-----\n`))\n\t\t\trequire.NoError(t, err)\n\t\t\trequire.NotNil(t, f)\n\n\t\t\tassert.Equal(t, `-----BEGIN RSA PRIVATE KEY-----\n   1foo\n   2bar\n   3foobar\n   4barfoo\n   5foo\n   6bar\n   7foobar\n   8barfoo\n   9foo\n   10bar\n   11foobar\n   12barfoo\n   13foo\n   14bar\n   15foobar\n   16barfoo\n   17foo\n   18bar\n   19foobar\n   20barfoo\n   21foo\n   22bar\n   23foobar\n   24barfoo\n   25foo\n   26bar\n   27foobar\n   28barfoo\n   29foo\n   30bar\n   31foobar\n   32barfoo\n   33foo\n   34bar\n   35foobar\n   36barfoo\n   37foo\n   38bar\n   39foobar\n   40barfoo\n   41foo\n   42bar\n   43foobar\n   44barfoo\n   45foo\n   46bar\n   47foobar\n   48barfoo\n   49foo\n   50bar\n   51foobar\n   52barfoo\n   53foo\n   54bar\n   55foobar\n   56barfoo\n   57foo\n   58bar\n   59foobar\n   60barfoo\n   61foo\n   62bar\n   63foobar\n   64barfoo\n   65foo\n   66bar\n   67foobar\n   68barfoo\n   69foo\n   70bar\n   71foobar\n   72barfoo\n   73foo\n   74bar\n   75foobar\n   76barfoo\n   77foo\n   78bar\n   79foobar\n   80barfoo\n   81foo\n   82bar\n   83foobar\n   84barfoo\n   85foo\n   86bar\n   87foobar\n   88barfoo\n   89foo\n   90bar\n   91foobar\n   92barfoo\n   93foo\n   94bar\n   95foobar\n   96barfoo\n   -----END RSA PRIVATE KEY-----`,\n\t\t\t\tf.Section(\"long\").Key(\"long_rsa_private_key\").String(),\n\t\t\t)\n\t\t})\n\n\t\tt.Run(\"allow unparsable sections\", func(t *testing.T) {\n\t\t\tf, err := LoadSources(LoadOptions{\n\t\t\t\tAllowPythonMultilineValues: true,\n\t\t\t\tInsensitive:                true,\n\t\t\t\tUnparseableSections:        []string{\"core_lesson\", \"comments\"},\n\t\t\t}, []byte(`\nLesson_Location = 87\nLesson_Status = C\nScore = 3\nTime = 00:02:30\n\n[CORE_LESSON]\nmy lesson state data – 1111111111111111111000000000000000001110000\n111111111111111111100000000000111000000000 – end my lesson state data\n\n[COMMENTS]\n<1><L.Slide#2> This slide has the fuel listed in the wrong units <e.1>\n`))\n\t\t\trequire.NoError(t, err)\n\t\t\trequire.NotNil(t, f)\n\n\t\t\tassert.Equal(t, \"3\", f.Section(\"\").Key(\"score\").String())\n\t\t\tassert.Empty(t, f.Section(\"\").Body())\n\t\t\tassert.Equal(t, `my lesson state data – 1111111111111111111000000000000000001110000\n111111111111111111100000000000111000000000 – end my lesson state data`,\n\t\t\t\tf.Section(\"core_lesson\").Body(),\n\t\t\t)\n\t\t\tassert.Equal(t, `<1><L.Slide#2> This slide has the fuel listed in the wrong units <e.1>`, f.Section(\"comments\").Body())\n\n\t\t\tt.Run(\"write out\", func(t *testing.T) {\n\t\t\t\tvar buf bytes.Buffer\n\t\t\t\t_, err := f.WriteTo(&buf)\n\t\t\t\trequire.NoError(t, err)\n\t\t\t\tassert.Equal(t, `lesson_location = 87\nlesson_status   = C\nscore           = 3\ntime            = 00:02:30\n\n[core_lesson]\nmy lesson state data – 1111111111111111111000000000000000001110000\n111111111111111111100000000000111000000000 – end my lesson state data\n\n[comments]\n<1><L.Slide#2> This slide has the fuel listed in the wrong units <e.1>\n`,\n\t\t\t\t\tbuf.String(),\n\t\t\t\t)\n\t\t\t})\n\n\t\t\tt.Run(\"inverse case\", func(t *testing.T) {\n\t\t\t\t_, err := LoadSources(LoadOptions{AllowPythonMultilineValues: true}, []byte(`\n[CORE_LESSON]\nmy lesson state data – 1111111111111111111000000000000000001110000\n111111111111111111100000000000111000000000 – end my lesson state data`))\n\t\t\t\trequire.Error(t, err)\n\t\t\t})\n\t\t})\n\n\t\tt.Run(\"and false `SpaceBeforeInlineComment`\", func(t *testing.T) {\n\t\t\tt.Run(\"cannot parse INI files containing `#` or `;` in value\", func(t *testing.T) {\n\t\t\t\tf, err := LoadSources(\n\t\t\t\t\tLoadOptions{AllowPythonMultilineValues: false, SpaceBeforeInlineComment: false},\n\t\t\t\t\t[]byte(`\n[author]\nNAME = U#n#k#n#w#o#n\nGITHUB = U;n;k;n;w;o;n\n`))\n\t\t\t\trequire.NoError(t, err)\n\t\t\t\trequire.NotNil(t, f)\n\t\t\t\tsec := f.Section(\"author\")\n\t\t\t\tnameValue := sec.Key(\"NAME\").String()\n\t\t\t\tgithubValue := sec.Key(\"GITHUB\").String()\n\t\t\t\tassert.Equal(t, \"U\", nameValue)\n\t\t\t\tassert.Equal(t, \"U\", githubValue)\n\t\t\t})\n\t\t})\n\n\t\tt.Run(\"and true `SpaceBeforeInlineComment`\", func(t *testing.T) {\n\t\t\tt.Run(\"can parse INI files containing `#` or `;` in value\", func(t *testing.T) {\n\t\t\t\tf, err := LoadSources(\n\t\t\t\t\tLoadOptions{AllowPythonMultilineValues: false, SpaceBeforeInlineComment: true},\n\t\t\t\t\t[]byte(`\n[author]\nNAME = U#n#k#n#w#o#n\nGITHUB = U;n;k;n;w;o;n\n`))\n\t\t\t\trequire.NoError(t, err)\n\t\t\t\trequire.NotNil(t, f)\n\t\t\t\tsec := f.Section(\"author\")\n\t\t\t\tnameValue := sec.Key(\"NAME\").String()\n\t\t\t\tgithubValue := sec.Key(\"GITHUB\").String()\n\t\t\t\tassert.Equal(t, \"U#n#k#n#w#o#n\", nameValue)\n\t\t\t\tassert.Equal(t, \"U;n;k;n;w;o;n\", githubValue)\n\t\t\t})\n\t\t})\n\t})\n\n\tt.Run(\"with false `AllowPythonMultilineValues`\", func(t *testing.T) {\n\t\tt.Run(\"ignore nonexistent files\", func(t *testing.T) {\n\t\t\tf, err := LoadSources(LoadOptions{\n\t\t\t\tAllowPythonMultilineValues: false,\n\t\t\t\tLoose:                      true,\n\t\t\t}, notFoundConf, minimalConf)\n\t\t\trequire.NoError(t, err)\n\t\t\trequire.NotNil(t, f)\n\n\t\t\tt.Run(\"inverse case\", func(t *testing.T) {\n\t\t\t\t_, err = LoadSources(LoadOptions{\n\t\t\t\t\tAllowPythonMultilineValues: false,\n\t\t\t\t}, notFoundConf)\n\t\t\t\trequire.Error(t, err)\n\t\t\t})\n\t\t})\n\n\t\tt.Run(\"insensitive to section and key names\", func(t *testing.T) {\n\t\t\tf, err := LoadSources(LoadOptions{\n\t\t\t\tAllowPythonMultilineValues: false,\n\t\t\t\tInsensitive:                true,\n\t\t\t}, minimalConf)\n\t\t\trequire.NoError(t, err)\n\t\t\trequire.NotNil(t, f)\n\n\t\t\tassert.Equal(t, \"u@gogs.io\", f.Section(\"Author\").Key(\"e-mail\").String())\n\n\t\t\tt.Run(\"write out\", func(t *testing.T) {\n\t\t\t\tvar buf bytes.Buffer\n\t\t\t\t_, err := f.WriteTo(&buf)\n\t\t\t\trequire.NoError(t, err)\n\t\t\t\tassert.Equal(t, `[author]\ne-mail = u@gogs.io\n`,\n\t\t\t\t\tbuf.String(),\n\t\t\t\t)\n\t\t\t})\n\n\t\t\tt.Run(\"inverse case\", func(t *testing.T) {\n\t\t\t\tf, err := LoadSources(LoadOptions{\n\t\t\t\t\tAllowPythonMultilineValues: false,\n\t\t\t\t}, minimalConf)\n\t\t\t\trequire.NoError(t, err)\n\t\t\t\trequire.NotNil(t, f)\n\n\t\t\t\tassert.Empty(t, f.Section(\"Author\").Key(\"e-mail\").String())\n\t\t\t})\n\t\t})\n\n\t\tt.Run(\"ignore continuation lines\", func(t *testing.T) {\n\t\t\tf, err := LoadSources(LoadOptions{\n\t\t\t\tAllowPythonMultilineValues: false,\n\t\t\t\tIgnoreContinuation:         true,\n\t\t\t}, []byte(`\nkey1=a\\b\\\nkey2=c\\d\\\nkey3=value`))\n\t\t\trequire.NoError(t, err)\n\t\t\trequire.NotNil(t, f)\n\n\t\t\tassert.Equal(t, `a\\b\\`, f.Section(\"\").Key(\"key1\").String())\n\t\t\tassert.Equal(t, `c\\d\\`, f.Section(\"\").Key(\"key2\").String())\n\t\t\tassert.Equal(t, \"value\", f.Section(\"\").Key(\"key3\").String())\n\n\t\t\tt.Run(\"inverse case\", func(t *testing.T) {\n\t\t\t\tf, err := LoadSources(LoadOptions{AllowPythonMultilineValues: false}, []byte(`\nkey1=a\\b\\\nkey2=c\\d\\`))\n\t\t\t\trequire.NoError(t, err)\n\t\t\t\trequire.NotNil(t, f)\n\n\t\t\t\tassert.Equal(t, `a\\bkey2=c\\d`, f.Section(\"\").Key(\"key1\").String())\n\t\t\t})\n\t\t})\n\n\t\tt.Run(\"ignore inline comments\", func(t *testing.T) {\n\t\t\tf, err := LoadSources(LoadOptions{\n\t\t\t\tAllowPythonMultilineValues: false,\n\t\t\t\tIgnoreInlineComment:        true,\n\t\t\t}, []byte(`\nkey1=value ;comment\nkey2=value2 #comment2\nkey3=val#ue #comment3`))\n\t\t\trequire.NoError(t, err)\n\t\t\trequire.NotNil(t, f)\n\n\t\t\tassert.Equal(t, `value ;comment`, f.Section(\"\").Key(\"key1\").String())\n\t\t\tassert.Equal(t, `value2 #comment2`, f.Section(\"\").Key(\"key2\").String())\n\t\t\tassert.Equal(t, `val#ue #comment3`, f.Section(\"\").Key(\"key3\").String())\n\n\t\t\tt.Run(\"inverse case\", func(t *testing.T) {\n\t\t\t\tf, err := LoadSources(LoadOptions{AllowPythonMultilineValues: false}, []byte(`\nkey1=value ;comment\nkey2=value2 #comment2`))\n\t\t\t\trequire.NoError(t, err)\n\t\t\t\trequire.NotNil(t, f)\n\n\t\t\t\tassert.Equal(t, `value`, f.Section(\"\").Key(\"key1\").String())\n\t\t\t\tassert.Equal(t, `;comment`, f.Section(\"\").Key(\"key1\").Comment)\n\t\t\t\tassert.Equal(t, `value2`, f.Section(\"\").Key(\"key2\").String())\n\t\t\t\tassert.Equal(t, `#comment2`, f.Section(\"\").Key(\"key2\").Comment)\n\t\t\t})\n\t\t})\n\n\t\tt.Run(\"allow boolean type keys\", func(t *testing.T) {\n\t\t\tf, err := LoadSources(LoadOptions{\n\t\t\t\tAllowPythonMultilineValues: false,\n\t\t\t\tAllowBooleanKeys:           true,\n\t\t\t}, []byte(`\nkey1=hello\n#key2\nkey3`))\n\t\t\trequire.NoError(t, err)\n\t\t\trequire.NotNil(t, f)\n\n\t\t\tassert.Equal(t, []string{\"key1\", \"key3\"}, f.Section(\"\").KeyStrings())\n\t\t\tassert.True(t, f.Section(\"\").Key(\"key3\").MustBool(false))\n\n\t\t\tt.Run(\"write out\", func(t *testing.T) {\n\t\t\t\tvar buf bytes.Buffer\n\t\t\t\t_, err := f.WriteTo(&buf)\n\t\t\t\trequire.NoError(t, err)\n\t\t\t\tassert.Equal(t, `key1 = hello\n# key2\nkey3\n`,\n\t\t\t\t\tbuf.String(),\n\t\t\t\t)\n\t\t\t})\n\n\t\t\tt.Run(\"inverse case\", func(t *testing.T) {\n\t\t\t\t_, err := LoadSources(LoadOptions{AllowPythonMultilineValues: false}, []byte(`\nkey1=hello\n#key2\nkey3`))\n\t\t\t\trequire.Error(t, err)\n\t\t\t})\n\t\t})\n\n\t\tt.Run(\"allow shadow keys\", func(t *testing.T) {\n\t\t\tf, err := LoadSources(LoadOptions{AllowPythonMultilineValues: false, AllowShadows: true}, []byte(`\n[remote \"origin\"]\nurl = https://github.com/Antergone/test1.git\nurl = https://github.com/Antergone/test2.git\nfetch = +refs/heads/*:refs/remotes/origin/*`))\n\t\t\trequire.NoError(t, err)\n\t\t\trequire.NotNil(t, f)\n\n\t\t\tassert.Equal(t, \"https://github.com/Antergone/test1.git\", f.Section(`remote \"origin\"`).Key(\"url\").String())\n\t\t\tassert.Equal(\n\t\t\t\tt,\n\t\t\t\t[]string{\n\t\t\t\t\t\"https://github.com/Antergone/test1.git\",\n\t\t\t\t\t\"https://github.com/Antergone/test2.git\",\n\t\t\t\t},\n\t\t\t\tf.Section(`remote \"origin\"`).Key(\"url\").ValueWithShadows(),\n\t\t\t)\n\t\t\tassert.Equal(t, \"+refs/heads/*:refs/remotes/origin/*\", f.Section(`remote \"origin\"`).Key(\"fetch\").String())\n\n\t\t\tt.Run(\"write out\", func(t *testing.T) {\n\t\t\t\tvar buf bytes.Buffer\n\t\t\t\t_, err := f.WriteTo(&buf)\n\t\t\t\trequire.NoError(t, err)\n\t\t\t\tassert.Equal(t, `[remote \"origin\"]\nurl   = https://github.com/Antergone/test1.git\nurl   = https://github.com/Antergone/test2.git\nfetch = +refs/heads/*:refs/remotes/origin/*\n`,\n\t\t\t\t\tbuf.String(),\n\t\t\t\t)\n\t\t\t})\n\n\t\t\tt.Run(\"inverse case\", func(t *testing.T) {\n\t\t\t\tf, err := LoadSources(LoadOptions{AllowPythonMultilineValues: false}, []byte(`\n[remote \"origin\"]\nurl = https://github.com/Antergone/test1.git\nurl = https://github.com/Antergone/test2.git`))\n\t\t\t\trequire.NoError(t, err)\n\t\t\t\trequire.NotNil(t, f)\n\n\t\t\t\tassert.Equal(t, \"https://github.com/Antergone/test2.git\", f.Section(`remote \"origin\"`).Key(\"url\").String())\n\t\t\t})\n\t\t})\n\n\t\tt.Run(\"unescape double quotes inside value\", func(t *testing.T) {\n\t\t\tf, err := LoadSources(LoadOptions{\n\t\t\t\tAllowPythonMultilineValues: false,\n\t\t\t\tUnescapeValueDoubleQuotes:  true,\n\t\t\t}, []byte(`\ncreate_repo=\"创建了仓库 <a href=\\\"%s\\\">%s</a>\"`))\n\t\t\trequire.NoError(t, err)\n\t\t\trequire.NotNil(t, f)\n\n\t\t\tassert.Equal(t, `创建了仓库 <a href=\"%s\">%s</a>`, f.Section(\"\").Key(\"create_repo\").String())\n\n\t\t\tt.Run(\"inverse case\", func(t *testing.T) {\n\t\t\t\tf, err := LoadSources(LoadOptions{AllowPythonMultilineValues: false}, []byte(`\ncreate_repo=\"创建了仓库 <a href=\\\"%s\\\">%s</a>\"`))\n\t\t\t\trequire.NoError(t, err)\n\t\t\t\trequire.NotNil(t, f)\n\n\t\t\t\tassert.Equal(t, `\"创建了仓库 <a href=\\\"%s\\\">%s</a>\"`, f.Section(\"\").Key(\"create_repo\").String())\n\t\t\t})\n\t\t})\n\n\t\tt.Run(\"unescape comment symbols inside value\", func(t *testing.T) {\n\t\t\tf, err := LoadSources(LoadOptions{\n\t\t\t\tAllowPythonMultilineValues:  false,\n\t\t\t\tIgnoreInlineComment:         true,\n\t\t\t\tUnescapeValueCommentSymbols: true,\n\t\t\t}, []byte(`\nkey = test value <span style=\"color: %s\\; background: %s\">more text</span>\n`))\n\t\t\trequire.NoError(t, err)\n\t\t\trequire.NotNil(t, f)\n\n\t\t\tassert.Equal(t, `test value <span style=\"color: %s; background: %s\">more text</span>`, f.Section(\"\").Key(\"key\").String())\n\t\t})\n\n\t\tt.Run(\"cannot parse small python-compatible INI files\", func(t *testing.T) {\n\t\t\tf, err := LoadSources(LoadOptions{AllowPythonMultilineValues: false}, []byte(`\n[long]\nlong_rsa_private_key = -----BEGIN RSA PRIVATE KEY-----\n  foo\n  bar\n  foobar\n  barfoo\n  -----END RSA PRIVATE KEY-----\n`))\n\t\t\trequire.Error(t, err)\n\t\t\tassert.Nil(t, f)\n\t\t\tassert.Equal(t, \"key-value delimiter not found: foo\\n\", err.Error())\n\t\t})\n\n\t\tt.Run(\"cannot parse big python-compatible INI files\", func(t *testing.T) {\n\t\t\tf, err := LoadSources(LoadOptions{AllowPythonMultilineValues: false}, []byte(`\n[long]\nlong_rsa_private_key = -----BEGIN RSA PRIVATE KEY-----\n  1foo\n  2bar\n  3foobar\n  4barfoo\n  5foo\n  6bar\n  7foobar\n  8barfoo\n  9foo\n  10bar\n  11foobar\n  12barfoo\n  13foo\n  14bar\n  15foobar\n  16barfoo\n  17foo\n  18bar\n  19foobar\n  20barfoo\n  21foo\n  22bar\n  23foobar\n  24barfoo\n  25foo\n  26bar\n  27foobar\n  28barfoo\n  29foo\n  30bar\n  31foobar\n  32barfoo\n  33foo\n  34bar\n  35foobar\n  36barfoo\n  37foo\n  38bar\n  39foobar\n  40barfoo\n  41foo\n  42bar\n  43foobar\n  44barfoo\n  45foo\n  46bar\n  47foobar\n  48barfoo\n  49foo\n  50bar\n  51foobar\n  52barfoo\n  53foo\n  54bar\n  55foobar\n  56barfoo\n  57foo\n  58bar\n  59foobar\n  60barfoo\n  61foo\n  62bar\n  63foobar\n  64barfoo\n  65foo\n  66bar\n  67foobar\n  68barfoo\n  69foo\n  70bar\n  71foobar\n  72barfoo\n  73foo\n  74bar\n  75foobar\n  76barfoo\n  77foo\n  78bar\n  79foobar\n  80barfoo\n  81foo\n  82bar\n  83foobar\n  84barfoo\n  85foo\n  86bar\n  87foobar\n  88barfoo\n  89foo\n  90bar\n  91foobar\n  92barfoo\n  93foo\n  94bar\n  95foobar\n  96barfoo\n  -----END RSA PRIVATE KEY-----\n`))\n\t\t\trequire.Error(t, err)\n\t\t\tassert.Nil(t, f)\n\t\t\tassert.Equal(t, \"key-value delimiter not found: 1foo\\n\", err.Error())\n\t\t})\n\n\t\tt.Run(\"allow unparsable sections\", func(t *testing.T) {\n\t\t\tf, err := LoadSources(LoadOptions{\n\t\t\t\tAllowPythonMultilineValues: false,\n\t\t\t\tInsensitive:                true,\n\t\t\t\tUnparseableSections:        []string{\"core_lesson\", \"comments\"},\n\t\t\t}, []byte(`\nLesson_Location = 87\nLesson_Status = C\nScore = 3\nTime = 00:02:30\n\n[CORE_LESSON]\nmy lesson state data – 1111111111111111111000000000000000001110000\n111111111111111111100000000000111000000000 – end my lesson state data\n\n[COMMENTS]\n<1><L.Slide#2> This slide has the fuel listed in the wrong units <e.1>\n`))\n\t\t\trequire.NoError(t, err)\n\t\t\trequire.NotNil(t, f)\n\n\t\t\tassert.Equal(t, \"3\", f.Section(\"\").Key(\"score\").String())\n\t\t\tassert.Empty(t, f.Section(\"\").Body())\n\t\t\tassert.Equal(t, `my lesson state data – 1111111111111111111000000000000000001110000\n111111111111111111100000000000111000000000 – end my lesson state data`,\n\t\t\t\tf.Section(\"core_lesson\").Body(),\n\t\t\t)\n\t\t\tassert.Equal(t, `<1><L.Slide#2> This slide has the fuel listed in the wrong units <e.1>`, f.Section(\"comments\").Body())\n\n\t\t\tt.Run(\"write out\", func(t *testing.T) {\n\t\t\t\tvar buf bytes.Buffer\n\t\t\t\t_, err := f.WriteTo(&buf)\n\t\t\t\trequire.NoError(t, err)\n\t\t\t\tassert.Equal(t, `lesson_location = 87\nlesson_status   = C\nscore           = 3\ntime            = 00:02:30\n\n[core_lesson]\nmy lesson state data – 1111111111111111111000000000000000001110000\n111111111111111111100000000000111000000000 – end my lesson state data\n\n[comments]\n<1><L.Slide#2> This slide has the fuel listed in the wrong units <e.1>\n`,\n\t\t\t\t\tbuf.String(),\n\t\t\t\t)\n\t\t\t})\n\n\t\t\tt.Run(\"inverse case\", func(t *testing.T) {\n\t\t\t\t_, err := LoadSources(LoadOptions{AllowPythonMultilineValues: false}, []byte(`\n[CORE_LESSON]\nmy lesson state data – 1111111111111111111000000000000000001110000\n111111111111111111100000000000111000000000 – end my lesson state data`))\n\t\t\t\trequire.Error(t, err)\n\t\t\t})\n\t\t})\n\n\t\tt.Run(\"and false `SpaceBeforeInlineComment`\", func(t *testing.T) {\n\t\t\tt.Run(\"cannot parse INI files containing `#` or `;` in value\", func(t *testing.T) {\n\t\t\t\tf, err := LoadSources(\n\t\t\t\t\tLoadOptions{AllowPythonMultilineValues: true, SpaceBeforeInlineComment: false},\n\t\t\t\t\t[]byte(`\n[author]\nNAME = U#n#k#n#w#o#n\nGITHUB = U;n;k;n;w;o;n\n`))\n\t\t\t\trequire.NoError(t, err)\n\t\t\t\trequire.NotNil(t, f)\n\t\t\t\tsec := f.Section(\"author\")\n\t\t\t\tnameValue := sec.Key(\"NAME\").String()\n\t\t\t\tgithubValue := sec.Key(\"GITHUB\").String()\n\t\t\t\tassert.Equal(t, \"U\", nameValue)\n\t\t\t\tassert.Equal(t, \"U\", githubValue)\n\t\t\t})\n\t\t})\n\n\t\tt.Run(\"and true `SpaceBeforeInlineComment`\", func(t *testing.T) {\n\t\t\tt.Run(\"can parse INI files containing `#` or `;` in value\", func(t *testing.T) {\n\t\t\t\tf, err := LoadSources(\n\t\t\t\t\tLoadOptions{AllowPythonMultilineValues: true, SpaceBeforeInlineComment: true},\n\t\t\t\t\t[]byte(`\n[author]\nNAME = U#n#k#n#w#o#n\nGITHUB = U;n;k;n;w;o;n\n`))\n\t\t\t\trequire.NoError(t, err)\n\t\t\t\trequire.NotNil(t, f)\n\t\t\t\tsec := f.Section(\"author\")\n\t\t\t\tnameValue := sec.Key(\"NAME\").String()\n\t\t\t\tgithubValue := sec.Key(\"GITHUB\").String()\n\t\t\t\tassert.Equal(t, \"U#n#k#n#w#o#n\", nameValue)\n\t\t\t\tassert.Equal(t, \"U;n;k;n;w;o;n\", githubValue)\n\t\t\t})\n\t\t})\n\t})\n\n\tt.Run(\"with `ChildSectionDelimiter` ':'\", func(t *testing.T) {\n\t\tt.Run(\"get all keys of parent sections\", func(t *testing.T) {\n\t\t\tf := Empty(LoadOptions{ChildSectionDelimiter: \":\"})\n\t\t\trequire.NotNil(t, f)\n\n\t\t\tk, err := f.Section(\"package\").NewKey(\"NAME\", \"ini\")\n\t\t\trequire.NoError(t, err)\n\t\t\tassert.NotNil(t, k)\n\t\t\tk, err = f.Section(\"package\").NewKey(\"VERSION\", \"v1\")\n\t\t\trequire.NoError(t, err)\n\t\t\tassert.NotNil(t, k)\n\t\t\tk, err = f.Section(\"package\").NewKey(\"IMPORT_PATH\", \"gopkg.in/ini.v1\")\n\t\t\trequire.NoError(t, err)\n\t\t\tassert.NotNil(t, k)\n\n\t\t\tkeys := f.Section(\"package:sub:sub2\").ParentKeys()\n\t\t\tnames := []string{\"NAME\", \"VERSION\", \"IMPORT_PATH\"}\n\t\t\tassert.Equal(t, len(names), len(keys))\n\t\t\tfor i, name := range names {\n\t\t\t\tassert.Equal(t, name, keys[i].Name())\n\t\t\t}\n\t\t})\n\n\t\tt.Run(\"getting and setting values\", func(t *testing.T) {\n\t\t\tf, err := LoadSources(LoadOptions{ChildSectionDelimiter: \":\"}, fullConf)\n\t\t\trequire.NoError(t, err)\n\t\t\trequire.NotNil(t, f)\n\n\t\t\tt.Run(\"get parent-keys that are available to the child section\", func(t *testing.T) {\n\t\t\t\tparentKeys := f.Section(\"package:sub\").ParentKeys()\n\t\t\t\tassert.NotNil(t, parentKeys)\n\t\t\t\tfor _, k := range parentKeys {\n\t\t\t\t\tassert.Equal(t, \"CLONE_URL\", k.Name())\n\t\t\t\t}\n\t\t\t})\n\n\t\t\tt.Run(\"get parent section value\", func(t *testing.T) {\n\t\t\t\tassert.Equal(t, \"https://gopkg.in/ini.v1\", f.Section(\"package:sub\").Key(\"CLONE_URL\").String())\n\t\t\t\tassert.Equal(t, \"https://gopkg.in/ini.v1\", f.Section(\"package:fake:sub\").Key(\"CLONE_URL\").String())\n\t\t\t})\n\t\t})\n\n\t\tt.Run(\"get child sections by parent name\", func(t *testing.T) {\n\t\t\tf, err := LoadSources(LoadOptions{ChildSectionDelimiter: \":\"}, []byte(`\n[node]\n[node:biz1]\n[node:biz2]\n[node.biz3]\n[node.bizN]\n`))\n\t\t\trequire.NoError(t, err)\n\t\t\trequire.NotNil(t, f)\n\n\t\t\tchildren := f.ChildSections(\"node\")\n\t\t\tnames := []string{\"node:biz1\", \"node:biz2\"}\n\t\t\tassert.Equal(t, len(names), len(children))\n\t\t\tfor i, name := range names {\n\t\t\t\tassert.Equal(t, name, children[i].Name())\n\t\t\t}\n\t\t})\n\t})\n\n\tt.Run(\"ShortCircuit\", func(t *testing.T) {\n\t\tt.Run(\"load the first available configuration, ignore other configuration\", func(t *testing.T) {\n\t\t\tf, err := LoadSources(LoadOptions{ShortCircuit: true}, minimalConf, []byte(`key1 = value1`))\n\t\t\trequire.NotNil(t, f)\n\t\t\trequire.NoError(t, err)\n\t\t\tvar buf bytes.Buffer\n\t\t\t_, err = f.WriteTo(&buf)\n\t\t\trequire.NoError(t, err)\n\t\t\tassert.Equal(t, `[author]\nE-MAIL = u@gogs.io\n`,\n\t\t\t\tbuf.String(),\n\t\t\t)\n\t\t})\n\n\t\tt.Run(\"return an error when fail to load\", func(t *testing.T) {\n\t\t\tf, err := LoadSources(LoadOptions{ShortCircuit: true}, notFoundConf, minimalConf)\n\t\t\tassert.Nil(t, f)\n\t\t\trequire.Error(t, err)\n\t\t})\n\n\t\tt.Run(\"used with Loose to ignore errors that the file does not exist\", func(t *testing.T) {\n\t\t\tf, err := LoadSources(LoadOptions{ShortCircuit: true, Loose: true}, notFoundConf, minimalConf)\n\t\t\trequire.NotNil(t, f)\n\t\t\trequire.NoError(t, err)\n\t\t\tvar buf bytes.Buffer\n\t\t\t_, err = f.WriteTo(&buf)\n\t\t\trequire.NoError(t, err)\n\t\t\tassert.Equal(t, `[author]\nE-MAIL = u@gogs.io\n`,\n\t\t\t\tbuf.String(),\n\t\t\t)\n\t\t})\n\n\t\tt.Run(\"ensure all sources are loaded without ShortCircuit\", func(t *testing.T) {\n\t\t\tf, err := LoadSources(LoadOptions{ShortCircuit: false}, minimalConf, []byte(`key1 = value1`))\n\t\t\trequire.NotNil(t, f)\n\t\t\trequire.NoError(t, err)\n\t\t\tvar buf bytes.Buffer\n\t\t\t_, err = f.WriteTo(&buf)\n\t\t\trequire.NoError(t, err)\n\t\t\tassert.Equal(t, `key1 = value1\n\n[author]\nE-MAIL = u@gogs.io\n`,\n\t\t\t\tbuf.String(),\n\t\t\t)\n\t\t})\n\t})\n}\n\nfunc Test_KeyValueDelimiters(t *testing.T) {\n\tt.Run(\"custom key-value delimiters\", func(t *testing.T) {\n\t\tf, err := LoadSources(LoadOptions{\n\t\t\tKeyValueDelimiters: \"?!\",\n\t\t}, []byte(`\n[section]\nkey1?value1\nkey2!value2\n`))\n\t\trequire.NoError(t, err)\n\t\trequire.NotNil(t, f)\n\n\t\tassert.Equal(t, \"value1\", f.Section(\"section\").Key(\"key1\").String())\n\t\tassert.Equal(t, \"value2\", f.Section(\"section\").Key(\"key2\").String())\n\t})\n}\n\nfunc Test_PreserveSurroundedQuote(t *testing.T) {\n\tt.Run(\"preserve surrounded quote test\", func(t *testing.T) {\n\t\tf, err := LoadSources(LoadOptions{\n\t\t\tPreserveSurroundedQuote: true,\n\t\t}, []byte(`\n[section]\nkey1 = \"value1\"\nkey2 = value2\n`))\n\t\trequire.NoError(t, err)\n\t\trequire.NotNil(t, f)\n\n\t\tassert.Equal(t, \"\\\"value1\\\"\", f.Section(\"section\").Key(\"key1\").String())\n\t\tassert.Equal(t, \"value2\", f.Section(\"section\").Key(\"key2\").String())\n\t})\n\n\tt.Run(\"preserve surrounded quote test inverse test\", func(t *testing.T) {\n\t\tf, err := LoadSources(LoadOptions{\n\t\t\tPreserveSurroundedQuote: false,\n\t\t}, []byte(`\n[section]\nkey1 = \"value1\"\nkey2 = value2\n`))\n\t\trequire.NoError(t, err)\n\t\trequire.NotNil(t, f)\n\n\t\tassert.Equal(t, \"value1\", f.Section(\"section\").Key(\"key1\").String())\n\t\tassert.Equal(t, \"value2\", f.Section(\"section\").Key(\"key2\").String())\n\t})\n}\n\ntype testData struct {\n\tValue1 string `ini:\"value1\"`\n\tValue2 string `ini:\"value2\"`\n\tValue3 string `ini:\"value3\"`\n}\n\nfunc TestPythonMultiline(t *testing.T) {\n\tif runtime.GOOS == \"windows\" {\n\t\tt.Skip(\"Skipping testing on Windows\")\n\t}\n\n\tpath := filepath.Join(\"testdata\", \"multiline.ini\")\n\tf, err := LoadSources(LoadOptions{\n\t\tAllowPythonMultilineValues: true,\n\t\tReaderBufferSize:           64 * 1024,\n\t}, path)\n\trequire.NoError(t, err)\n\trequire.NotNil(t, f)\n\tassert.Len(t, f.Sections(), 1)\n\n\tdefaultSection := f.Section(\"\")\n\tassert.NotNil(t, f.Section(\"\"))\n\n\tvar testData testData\n\terr = defaultSection.MapTo(&testData)\n\trequire.NoError(t, err)\n\tassert.Equal(t, \"some text here\\n\\tsome more text here\\n\\t\\n\\tthere is an empty line above and below\\n\\t\", testData.Value1)\n\tassert.Equal(t, \"there is an empty line above\\n    that is not indented so it should not be part\\n    of the value\", testData.Value2)\n\tassert.Equal(t, `.\n \n Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Eu consequat ac felis donec et odio pellentesque diam volutpat. Mauris commodo quis imperdiet massa tincidunt nunc. Interdum velit euismod in pellentesque. Nisl condimentum id venenatis a condimentum vitae sapien pellentesque. Nascetur ridiculus mus mauris vitae. Posuere urna nec tincidunt praesent semper feugiat. Lorem donec massa sapien faucibus et molestie ac feugiat sed. Ipsum dolor sit amet consectetur adipiscing elit. Enim sed faucibus turpis in eu mi. A diam sollicitudin tempor id. Quam nulla porttitor massa id neque aliquam vestibulum morbi blandit.\n \n Lectus sit amet est placerat in egestas. At risus viverra adipiscing at in tellus integer. Tristique senectus et netus et malesuada fames ac. In hac habitasse platea dictumst. Purus in mollis nunc sed. Pellentesque sit amet porttitor eget dolor morbi. Elit at imperdiet dui accumsan sit amet nulla. Cursus in hac habitasse platea dictumst. Bibendum arcu vitae elementum curabitur. Faucibus ornare suspendisse sed nisi lacus. In vitae turpis massa sed. Libero nunc consequat interdum varius sit amet. Molestie a iaculis at erat pellentesque.\n \n Dui faucibus in ornare quam viverra orci sagittis eu. Purus in mollis nunc sed id semper. Sed arcu non odio euismod lacinia at. Quis commodo odio aenean sed adipiscing diam donec. Quisque id diam vel quam elementum pulvinar. Lorem ipsum dolor sit amet. Purus ut faucibus pulvinar elementum integer enim neque volutpat ac. Fermentum posuere urna nec tincidunt praesent semper feugiat nibh sed. Gravida rutrum quisque non tellus orci. Ipsum dolor sit amet consectetur adipiscing elit pellentesque habitant. Et sollicitudin ac orci phasellus egestas tellus rutrum tellus pellentesque. Eget gravida cum sociis natoque penatibus et magnis. Elementum eu facilisis sed odio morbi quis commodo. Mollis nunc sed id semper risus in hendrerit gravida rutrum. Lorem dolor sed viverra ipsum.\n \n Pellentesque adipiscing commodo elit at imperdiet dui accumsan sit amet. Justo eget magna fermentum iaculis eu non diam. Condimentum mattis pellentesque id nibh tortor id aliquet lectus. Tellus molestie nunc non blandit massa enim. Mauris ultrices eros in cursus turpis. Purus viverra accumsan in nisl nisi scelerisque. Quis lectus nulla at volutpat. Purus ut faucibus pulvinar elementum integer enim. In pellentesque massa placerat duis ultricies lacus sed turpis. Elit sed vulputate mi sit amet mauris commodo. Tellus elementum sagittis vitae et. Duis tristique sollicitudin nibh sit amet commodo nulla facilisi nullam. Lectus vestibulum mattis ullamcorper velit sed ullamcorper morbi tincidunt ornare. Libero id faucibus nisl tincidunt eget nullam. Mattis aliquam faucibus purus in massa tempor. Fames ac turpis egestas sed tempus urna. Gravida in fermentum et sollicitudin ac orci phasellus egestas.\n \n Blandit turpis cursus in hac habitasse. Sed id semper risus in. Amet porttitor eget dolor morbi non arcu. Rhoncus est pellentesque elit ullamcorper dignissim cras tincidunt. Ut morbi tincidunt augue interdum velit. Lorem mollis aliquam ut porttitor leo a. Nunc eget lorem dolor sed viverra. Scelerisque mauris pellentesque pulvinar pellentesque. Elit at imperdiet dui accumsan sit amet. Eget magna fermentum iaculis eu non diam phasellus vestibulum lorem. Laoreet non curabitur gravida arcu ac tortor dignissim. Tortor pretium viverra suspendisse potenti nullam ac tortor vitae purus. Lacus sed viverra tellus in hac habitasse platea dictumst vestibulum. Viverra adipiscing at in tellus. Duis at tellus at urna condimentum. Eget gravida cum sociis natoque penatibus et magnis dis parturient. Pharetra massa massa ultricies mi quis hendrerit.\n \n Mauris pellentesque pulvinar pellentesque habitant morbi tristique. Maecenas volutpat blandit aliquam etiam. Sed turpis tincidunt id aliquet. Eget duis at tellus at urna condimentum. Pellentesque habitant morbi tristique senectus et. Amet aliquam id diam maecenas. Volutpat est velit egestas dui id. Vulputate eu scelerisque felis imperdiet proin fermentum leo vel orci. Massa sed elementum tempus egestas sed sed risus pretium. Quam quisque id diam vel quam elementum pulvinar etiam non. Sapien faucibus et molestie ac. Ipsum dolor sit amet consectetur adipiscing. Viverra orci sagittis eu volutpat. Leo urna molestie at elementum. Commodo viverra maecenas accumsan lacus. Non sodales neque sodales ut etiam sit amet. Habitant morbi tristique senectus et netus et malesuada fames. Habitant morbi tristique senectus et netus et malesuada. Blandit aliquam etiam erat velit scelerisque in. Varius duis at consectetur lorem donec massa sapien faucibus et.\n \n Augue mauris augue neque gravida in. Odio ut sem nulla pharetra diam sit amet nisl suscipit. Nulla aliquet enim tortor at auctor urna nunc id. Morbi tristique senectus et netus et malesuada fames ac. Quam id leo in vitae turpis massa sed elementum tempus. Ipsum faucibus vitae aliquet nec ullamcorper sit amet risus nullam. Maecenas volutpat blandit aliquam etiam erat velit scelerisque in. Sagittis nisl rhoncus mattis rhoncus urna neque viverra justo. Massa tempor nec feugiat nisl pretium. Vulputate sapien nec sagittis aliquam malesuada bibendum arcu vitae elementum. Enim lobortis scelerisque fermentum dui faucibus in ornare. Faucibus ornare suspendisse sed nisi lacus. Morbi tristique senectus et netus et malesuada fames. Malesuada pellentesque elit eget gravida cum sociis natoque penatibus et. Dictum non consectetur a erat nam at. Leo urna molestie at elementum eu facilisis sed odio morbi. Quam id leo in vitae turpis massa. Neque egestas congue quisque egestas diam in arcu. Varius morbi enim nunc faucibus a pellentesque sit. Aliquet enim tortor at auctor urna.\n \n Elit scelerisque mauris pellentesque pulvinar pellentesque habitant morbi tristique. Luctus accumsan tortor posuere ac. Eu ultrices vitae auctor eu augue ut lectus arcu bibendum. Pretium nibh ipsum consequat nisl vel pretium lectus. Aliquam etiam erat velit scelerisque in dictum. Sem et tortor consequat id porta nibh venenatis cras sed. A scelerisque purus semper eget duis at tellus at urna. At auctor urna nunc id. Ornare quam viverra orci sagittis eu volutpat odio. Nisl purus in mollis nunc sed id semper. Ornare suspendisse sed nisi lacus sed. Consectetur lorem donec massa sapien faucibus et. Ipsum dolor sit amet consectetur adipiscing elit ut. Porta nibh venenatis cras sed. Dignissim diam quis enim lobortis scelerisque. Quam nulla porttitor massa id. Tellus molestie nunc non blandit massa.\n \n Malesuada fames ac turpis egestas. Suscipit tellus mauris a diam maecenas. Turpis in eu mi bibendum neque egestas. Venenatis tellus in metus vulputate eu scelerisque felis imperdiet. Quis imperdiet massa tincidunt nunc pulvinar sapien et. Urna duis convallis convallis tellus id. Velit egestas dui id ornare arcu odio. Consectetur purus ut faucibus pulvinar elementum integer enim neque. Aenean sed adipiscing diam donec adipiscing tristique. Tortor aliquam nulla facilisi cras fermentum odio eu. Diam in arcu cursus euismod quis viverra nibh cras.\n \n Id ornare arcu odio ut sem. Arcu dictum varius duis at consectetur lorem donec massa sapien. Proin libero nunc consequat interdum varius sit. Ut eu sem integer vitae justo. Vitae elementum curabitur vitae nunc. Diam quam nulla porttitor massa. Lectus mauris ultrices eros in cursus turpis massa tincidunt dui. Natoque penatibus et magnis dis parturient montes. Pellentesque habitant morbi tristique senectus et netus et malesuada fames. Libero nunc consequat interdum varius sit. Rhoncus dolor purus non enim praesent. Pellentesque sit amet porttitor eget. Nibh tortor id aliquet lectus proin nibh. Fermentum iaculis eu non diam phasellus vestibulum lorem sed.\n \n Eu feugiat pretium nibh ipsum consequat nisl vel pretium lectus. Habitant morbi tristique senectus et netus et malesuada fames ac. Urna condimentum mattis pellentesque id. Lorem sed risus ultricies tristique nulla aliquet enim tortor at. Ipsum dolor sit amet consectetur adipiscing elit. Convallis a cras semper auctor neque vitae tempus quam. A diam sollicitudin tempor id eu nisl nunc mi ipsum. Maecenas sed enim ut sem viverra aliquet eget. Massa enim nec dui nunc mattis enim. Nam aliquam sem et tortor consequat. Adipiscing commodo elit at imperdiet dui accumsan sit amet nulla. Nullam eget felis eget nunc lobortis. Mauris a diam maecenas sed enim ut sem viverra. Ornare massa eget egestas purus. In hac habitasse platea dictumst. Ut tortor pretium viverra suspendisse potenti nullam ac tortor. Nisl nunc mi ipsum faucibus. At varius vel pharetra vel. Mauris ultrices eros in cursus turpis massa tincidunt.`,\n\t\ttestData.Value3,\n\t)\n}\n\nfunc TestPythonMultiline_EOF(t *testing.T) {\n\tif runtime.GOOS == \"windows\" {\n\t\tt.Skip(\"Skipping testing on Windows\")\n\t}\n\n\tpath := filepath.Join(\"testdata\", \"multiline_eof.ini\")\n\tf, err := LoadSources(LoadOptions{\n\t\tAllowPythonMultilineValues: true,\n\t\tReaderBufferSize:           64 * 1024,\n\t}, path)\n\trequire.NoError(t, err)\n\trequire.NotNil(t, f)\n\tassert.Len(t, f.Sections(), 1)\n\n\tdefaultSection := f.Section(\"\")\n\tassert.NotNil(t, f.Section(\"\"))\n\n\tvar testData testData\n\terr = defaultSection.MapTo(&testData)\n\trequire.NoError(t, err)\n\tassert.Equal(t, \"some text here\\n\\tsome more text here 2\", testData.Value1)\n}\n\nfunc Test_NestedValuesSpanningSections(t *testing.T) {\n\tt.Run(\"basic nested value\", func(t *testing.T) {\n\t\tf, err := LoadSources(LoadOptions{\n\t\t\tAllowNestedValues: true,\n\t\t}, []byte(`\n[section]\nkey1 = value1\nkey2 =\n  nested1 = nestedvalue1\n`))\n\t\trequire.NoError(t, err)\n\t\trequire.NotNil(t, f)\n\n\t\tassert.Equal(t, \"value1\", f.Section(\"section\").Key(\"key1\").String())\n\t\tassert.Equal(t, \"\", f.Section(\"section\").Key(\"key2\").String())\n\t\tassert.Equal(t, []string{\"nested1 = nestedvalue1\"}, f.Section(\"section\").Key(\"key2\").NestedValues())\n\t})\n\n\tt.Run(\"no nested values\", func(t *testing.T) {\n\t\tf, err := LoadSources(LoadOptions{\n\t\t\tAllowNestedValues: true,\n\t\t}, []byte(`\n[section]\nkey1 = value1\nkey2 =\n`))\n\t\trequire.NoError(t, err)\n\t\trequire.NotNil(t, f)\n\n\t\tassert.Equal(t, \"value1\", f.Section(\"section\").Key(\"key1\").String())\n\t\tassert.Equal(t, \"\", f.Section(\"section\").Key(\"key2\").String())\n\t})\n\n\tt.Run(\"no nested values and following sections\", func(t *testing.T) {\n\t\tf, err := LoadSources(LoadOptions{\n\t\t\tAllowNestedValues: true,\n\t\t}, []byte(`\n[section]\nkey1 = value1\nkey2 =\n\n[section2]\nkey3 = value3\n`))\n\t\trequire.NoError(t, err)\n\t\trequire.NotNil(t, f)\n\n\t\tassert.Equal(t, \"value1\", f.Section(\"section\").Key(\"key1\").String())\n\t\tassert.Equal(t, \"\", f.Section(\"section\").Key(\"key2\").String())\n\t\tassert.Equal(t, \"value3\", f.Section(\"section2\").Key(\"key3\").String())\n\t})\n\n\tt.Run(\"no nested values and following sections with indentation\", func(t *testing.T) {\n\t\tf, err := LoadSources(LoadOptions{\n\t\t\tAllowNestedValues: true,\n\t\t}, []byte(`\n[section]\nkey1 = value1\nkey2 =\n\n[section2]\n  key3 = value3\n`))\n\t\trequire.NoError(t, err)\n\t\trequire.NotNil(t, f)\n\n\t\tassert.Equal(t, \"value1\", f.Section(\"section\").Key(\"key1\").String())\n\t\tassert.Equal(t, \"\", f.Section(\"section\").Key(\"key2\").String())\n\t\tassert.Equal(t, \"value3\", f.Section(\"section2\").Key(\"key3\").String())\n\t})\n}\n"
        },
        {
          "name": "key.go",
          "type": "blob",
          "size": 23.8330078125,
          "content": "// Copyright 2014 Unknwon\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"): you may\n// not use this file except in compliance with the License. You may obtain\n// a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n// WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n// License for the specific language governing permissions and limitations\n// under the License.\n\npackage ini\n\nimport (\n\t\"bytes\"\n\t\"errors\"\n\t\"fmt\"\n\t\"strconv\"\n\t\"strings\"\n\t\"time\"\n)\n\n// Key represents a key under a section.\ntype Key struct {\n\ts               *Section\n\tComment         string\n\tname            string\n\tvalue           string\n\tisAutoIncrement bool\n\tisBooleanType   bool\n\n\tisShadow bool\n\tshadows  []*Key\n\n\tnestedValues []string\n}\n\n// newKey simply return a key object with given values.\nfunc newKey(s *Section, name, val string) *Key {\n\treturn &Key{\n\t\ts:     s,\n\t\tname:  name,\n\t\tvalue: val,\n\t}\n}\n\nfunc (k *Key) addShadow(val string) error {\n\tif k.isShadow {\n\t\treturn errors.New(\"cannot add shadow to another shadow key\")\n\t} else if k.isAutoIncrement || k.isBooleanType {\n\t\treturn errors.New(\"cannot add shadow to auto-increment or boolean key\")\n\t}\n\n\tif !k.s.f.options.AllowDuplicateShadowValues {\n\t\t// Deduplicate shadows based on their values.\n\t\tif k.value == val {\n\t\t\treturn nil\n\t\t}\n\t\tfor i := range k.shadows {\n\t\t\tif k.shadows[i].value == val {\n\t\t\t\treturn nil\n\t\t\t}\n\t\t}\n\t}\n\n\tshadow := newKey(k.s, k.name, val)\n\tshadow.isShadow = true\n\tk.shadows = append(k.shadows, shadow)\n\treturn nil\n}\n\n// AddShadow adds a new shadow key to itself.\nfunc (k *Key) AddShadow(val string) error {\n\tif !k.s.f.options.AllowShadows {\n\t\treturn errors.New(\"shadow key is not allowed\")\n\t}\n\treturn k.addShadow(val)\n}\n\nfunc (k *Key) addNestedValue(val string) error {\n\tif k.isAutoIncrement || k.isBooleanType {\n\t\treturn errors.New(\"cannot add nested value to auto-increment or boolean key\")\n\t}\n\n\tk.nestedValues = append(k.nestedValues, val)\n\treturn nil\n}\n\n// AddNestedValue adds a nested value to the key.\nfunc (k *Key) AddNestedValue(val string) error {\n\tif !k.s.f.options.AllowNestedValues {\n\t\treturn errors.New(\"nested value is not allowed\")\n\t}\n\treturn k.addNestedValue(val)\n}\n\n// ValueMapper represents a mapping function for values, e.g. os.ExpandEnv\ntype ValueMapper func(string) string\n\n// Name returns name of key.\nfunc (k *Key) Name() string {\n\treturn k.name\n}\n\n// Value returns raw value of key for performance purpose.\nfunc (k *Key) Value() string {\n\treturn k.value\n}\n\n// ValueWithShadows returns raw values of key and its shadows if any. Shadow\n// keys with empty values are ignored from the returned list.\nfunc (k *Key) ValueWithShadows() []string {\n\tif len(k.shadows) == 0 {\n\t\tif k.value == \"\" {\n\t\t\treturn []string{}\n\t\t}\n\t\treturn []string{k.value}\n\t}\n\n\tvals := make([]string, 0, len(k.shadows)+1)\n\tif k.value != \"\" {\n\t\tvals = append(vals, k.value)\n\t}\n\tfor _, s := range k.shadows {\n\t\tif s.value != \"\" {\n\t\t\tvals = append(vals, s.value)\n\t\t}\n\t}\n\treturn vals\n}\n\n// NestedValues returns nested values stored in the key.\n// It is possible returned value is nil if no nested values stored in the key.\nfunc (k *Key) NestedValues() []string {\n\treturn k.nestedValues\n}\n\n// transformValue takes a raw value and transforms to its final string.\nfunc (k *Key) transformValue(val string) string {\n\tif k.s.f.ValueMapper != nil {\n\t\tval = k.s.f.ValueMapper(val)\n\t}\n\n\t// Fail-fast if no indicate char found for recursive value\n\tif !strings.Contains(val, \"%\") {\n\t\treturn val\n\t}\n\tfor i := 0; i < depthValues; i++ {\n\t\tvr := varPattern.FindString(val)\n\t\tif len(vr) == 0 {\n\t\t\tbreak\n\t\t}\n\n\t\t// Take off leading '%(' and trailing ')s'.\n\t\tnoption := vr[2 : len(vr)-2]\n\n\t\t// Search in the same section.\n\t\t// If not found or found the key itself, then search again in default section.\n\t\tnk, err := k.s.GetKey(noption)\n\t\tif err != nil || k == nk {\n\t\t\tnk, _ = k.s.f.Section(\"\").GetKey(noption)\n\t\t\tif nk == nil {\n\t\t\t\t// Stop when no results found in the default section,\n\t\t\t\t// and returns the value as-is.\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\n\t\t// Substitute by new value and take off leading '%(' and trailing ')s'.\n\t\tval = strings.Replace(val, vr, nk.value, -1)\n\t}\n\treturn val\n}\n\n// String returns string representation of value.\nfunc (k *Key) String() string {\n\treturn k.transformValue(k.value)\n}\n\n// Validate accepts a validate function which can\n// return modifed result as key value.\nfunc (k *Key) Validate(fn func(string) string) string {\n\treturn fn(k.String())\n}\n\n// parseBool returns the boolean value represented by the string.\n//\n// It accepts 1, t, T, TRUE, true, True, YES, yes, Yes, y, ON, on, On,\n// 0, f, F, FALSE, false, False, NO, no, No, n, OFF, off, Off.\n// Any other value returns an error.\nfunc parseBool(str string) (value bool, err error) {\n\tswitch str {\n\tcase \"1\", \"t\", \"T\", \"true\", \"TRUE\", \"True\", \"YES\", \"yes\", \"Yes\", \"y\", \"ON\", \"on\", \"On\":\n\t\treturn true, nil\n\tcase \"0\", \"f\", \"F\", \"false\", \"FALSE\", \"False\", \"NO\", \"no\", \"No\", \"n\", \"OFF\", \"off\", \"Off\":\n\t\treturn false, nil\n\t}\n\treturn false, fmt.Errorf(\"parsing \\\"%s\\\": invalid syntax\", str)\n}\n\n// Bool returns bool type value.\nfunc (k *Key) Bool() (bool, error) {\n\treturn parseBool(k.String())\n}\n\n// Float64 returns float64 type value.\nfunc (k *Key) Float64() (float64, error) {\n\treturn strconv.ParseFloat(k.String(), 64)\n}\n\n// Int returns int type value.\nfunc (k *Key) Int() (int, error) {\n\tv, err := strconv.ParseInt(k.String(), 0, 64)\n\treturn int(v), err\n}\n\n// Int64 returns int64 type value.\nfunc (k *Key) Int64() (int64, error) {\n\treturn strconv.ParseInt(k.String(), 0, 64)\n}\n\n// Uint returns uint type valued.\nfunc (k *Key) Uint() (uint, error) {\n\tu, e := strconv.ParseUint(k.String(), 0, 64)\n\treturn uint(u), e\n}\n\n// Uint64 returns uint64 type value.\nfunc (k *Key) Uint64() (uint64, error) {\n\treturn strconv.ParseUint(k.String(), 0, 64)\n}\n\n// Duration returns time.Duration type value.\nfunc (k *Key) Duration() (time.Duration, error) {\n\treturn time.ParseDuration(k.String())\n}\n\n// TimeFormat parses with given format and returns time.Time type value.\nfunc (k *Key) TimeFormat(format string) (time.Time, error) {\n\treturn time.Parse(format, k.String())\n}\n\n// Time parses with RFC3339 format and returns time.Time type value.\nfunc (k *Key) Time() (time.Time, error) {\n\treturn k.TimeFormat(time.RFC3339)\n}\n\n// MustString returns default value if key value is empty.\nfunc (k *Key) MustString(defaultVal string) string {\n\tval := k.String()\n\tif len(val) == 0 {\n\t\tk.value = defaultVal\n\t\treturn defaultVal\n\t}\n\treturn val\n}\n\n// MustBool always returns value without error,\n// it returns false if error occurs.\nfunc (k *Key) MustBool(defaultVal ...bool) bool {\n\tval, err := k.Bool()\n\tif len(defaultVal) > 0 && err != nil {\n\t\tk.value = strconv.FormatBool(defaultVal[0])\n\t\treturn defaultVal[0]\n\t}\n\treturn val\n}\n\n// MustFloat64 always returns value without error,\n// it returns 0.0 if error occurs.\nfunc (k *Key) MustFloat64(defaultVal ...float64) float64 {\n\tval, err := k.Float64()\n\tif len(defaultVal) > 0 && err != nil {\n\t\tk.value = strconv.FormatFloat(defaultVal[0], 'f', -1, 64)\n\t\treturn defaultVal[0]\n\t}\n\treturn val\n}\n\n// MustInt always returns value without error,\n// it returns 0 if error occurs.\nfunc (k *Key) MustInt(defaultVal ...int) int {\n\tval, err := k.Int()\n\tif len(defaultVal) > 0 && err != nil {\n\t\tk.value = strconv.FormatInt(int64(defaultVal[0]), 10)\n\t\treturn defaultVal[0]\n\t}\n\treturn val\n}\n\n// MustInt64 always returns value without error,\n// it returns 0 if error occurs.\nfunc (k *Key) MustInt64(defaultVal ...int64) int64 {\n\tval, err := k.Int64()\n\tif len(defaultVal) > 0 && err != nil {\n\t\tk.value = strconv.FormatInt(defaultVal[0], 10)\n\t\treturn defaultVal[0]\n\t}\n\treturn val\n}\n\n// MustUint always returns value without error,\n// it returns 0 if error occurs.\nfunc (k *Key) MustUint(defaultVal ...uint) uint {\n\tval, err := k.Uint()\n\tif len(defaultVal) > 0 && err != nil {\n\t\tk.value = strconv.FormatUint(uint64(defaultVal[0]), 10)\n\t\treturn defaultVal[0]\n\t}\n\treturn val\n}\n\n// MustUint64 always returns value without error,\n// it returns 0 if error occurs.\nfunc (k *Key) MustUint64(defaultVal ...uint64) uint64 {\n\tval, err := k.Uint64()\n\tif len(defaultVal) > 0 && err != nil {\n\t\tk.value = strconv.FormatUint(defaultVal[0], 10)\n\t\treturn defaultVal[0]\n\t}\n\treturn val\n}\n\n// MustDuration always returns value without error,\n// it returns zero value if error occurs.\nfunc (k *Key) MustDuration(defaultVal ...time.Duration) time.Duration {\n\tval, err := k.Duration()\n\tif len(defaultVal) > 0 && err != nil {\n\t\tk.value = defaultVal[0].String()\n\t\treturn defaultVal[0]\n\t}\n\treturn val\n}\n\n// MustTimeFormat always parses with given format and returns value without error,\n// it returns zero value if error occurs.\nfunc (k *Key) MustTimeFormat(format string, defaultVal ...time.Time) time.Time {\n\tval, err := k.TimeFormat(format)\n\tif len(defaultVal) > 0 && err != nil {\n\t\tk.value = defaultVal[0].Format(format)\n\t\treturn defaultVal[0]\n\t}\n\treturn val\n}\n\n// MustTime always parses with RFC3339 format and returns value without error,\n// it returns zero value if error occurs.\nfunc (k *Key) MustTime(defaultVal ...time.Time) time.Time {\n\treturn k.MustTimeFormat(time.RFC3339, defaultVal...)\n}\n\n// In always returns value without error,\n// it returns default value if error occurs or doesn't fit into candidates.\nfunc (k *Key) In(defaultVal string, candidates []string) string {\n\tval := k.String()\n\tfor _, cand := range candidates {\n\t\tif val == cand {\n\t\t\treturn val\n\t\t}\n\t}\n\treturn defaultVal\n}\n\n// InFloat64 always returns value without error,\n// it returns default value if error occurs or doesn't fit into candidates.\nfunc (k *Key) InFloat64(defaultVal float64, candidates []float64) float64 {\n\tval := k.MustFloat64()\n\tfor _, cand := range candidates {\n\t\tif val == cand {\n\t\t\treturn val\n\t\t}\n\t}\n\treturn defaultVal\n}\n\n// InInt always returns value without error,\n// it returns default value if error occurs or doesn't fit into candidates.\nfunc (k *Key) InInt(defaultVal int, candidates []int) int {\n\tval := k.MustInt()\n\tfor _, cand := range candidates {\n\t\tif val == cand {\n\t\t\treturn val\n\t\t}\n\t}\n\treturn defaultVal\n}\n\n// InInt64 always returns value without error,\n// it returns default value if error occurs or doesn't fit into candidates.\nfunc (k *Key) InInt64(defaultVal int64, candidates []int64) int64 {\n\tval := k.MustInt64()\n\tfor _, cand := range candidates {\n\t\tif val == cand {\n\t\t\treturn val\n\t\t}\n\t}\n\treturn defaultVal\n}\n\n// InUint always returns value without error,\n// it returns default value if error occurs or doesn't fit into candidates.\nfunc (k *Key) InUint(defaultVal uint, candidates []uint) uint {\n\tval := k.MustUint()\n\tfor _, cand := range candidates {\n\t\tif val == cand {\n\t\t\treturn val\n\t\t}\n\t}\n\treturn defaultVal\n}\n\n// InUint64 always returns value without error,\n// it returns default value if error occurs or doesn't fit into candidates.\nfunc (k *Key) InUint64(defaultVal uint64, candidates []uint64) uint64 {\n\tval := k.MustUint64()\n\tfor _, cand := range candidates {\n\t\tif val == cand {\n\t\t\treturn val\n\t\t}\n\t}\n\treturn defaultVal\n}\n\n// InTimeFormat always parses with given format and returns value without error,\n// it returns default value if error occurs or doesn't fit into candidates.\nfunc (k *Key) InTimeFormat(format string, defaultVal time.Time, candidates []time.Time) time.Time {\n\tval := k.MustTimeFormat(format)\n\tfor _, cand := range candidates {\n\t\tif val == cand {\n\t\t\treturn val\n\t\t}\n\t}\n\treturn defaultVal\n}\n\n// InTime always parses with RFC3339 format and returns value without error,\n// it returns default value if error occurs or doesn't fit into candidates.\nfunc (k *Key) InTime(defaultVal time.Time, candidates []time.Time) time.Time {\n\treturn k.InTimeFormat(time.RFC3339, defaultVal, candidates)\n}\n\n// RangeFloat64 checks if value is in given range inclusively,\n// and returns default value if it's not.\nfunc (k *Key) RangeFloat64(defaultVal, min, max float64) float64 {\n\tval := k.MustFloat64()\n\tif val < min || val > max {\n\t\treturn defaultVal\n\t}\n\treturn val\n}\n\n// RangeInt checks if value is in given range inclusively,\n// and returns default value if it's not.\nfunc (k *Key) RangeInt(defaultVal, min, max int) int {\n\tval := k.MustInt()\n\tif val < min || val > max {\n\t\treturn defaultVal\n\t}\n\treturn val\n}\n\n// RangeInt64 checks if value is in given range inclusively,\n// and returns default value if it's not.\nfunc (k *Key) RangeInt64(defaultVal, min, max int64) int64 {\n\tval := k.MustInt64()\n\tif val < min || val > max {\n\t\treturn defaultVal\n\t}\n\treturn val\n}\n\n// RangeTimeFormat checks if value with given format is in given range inclusively,\n// and returns default value if it's not.\nfunc (k *Key) RangeTimeFormat(format string, defaultVal, min, max time.Time) time.Time {\n\tval := k.MustTimeFormat(format)\n\tif val.Unix() < min.Unix() || val.Unix() > max.Unix() {\n\t\treturn defaultVal\n\t}\n\treturn val\n}\n\n// RangeTime checks if value with RFC3339 format is in given range inclusively,\n// and returns default value if it's not.\nfunc (k *Key) RangeTime(defaultVal, min, max time.Time) time.Time {\n\treturn k.RangeTimeFormat(time.RFC3339, defaultVal, min, max)\n}\n\n// Strings returns list of string divided by given delimiter.\nfunc (k *Key) Strings(delim string) []string {\n\tstr := k.String()\n\tif len(str) == 0 {\n\t\treturn []string{}\n\t}\n\n\trunes := []rune(str)\n\tvals := make([]string, 0, 2)\n\tvar buf bytes.Buffer\n\tescape := false\n\tidx := 0\n\tfor {\n\t\tif escape {\n\t\t\tescape = false\n\t\t\tif runes[idx] != '\\\\' && !strings.HasPrefix(string(runes[idx:]), delim) {\n\t\t\t\tbuf.WriteRune('\\\\')\n\t\t\t}\n\t\t\tbuf.WriteRune(runes[idx])\n\t\t} else {\n\t\t\tif runes[idx] == '\\\\' {\n\t\t\t\tescape = true\n\t\t\t} else if strings.HasPrefix(string(runes[idx:]), delim) {\n\t\t\t\tidx += len(delim) - 1\n\t\t\t\tvals = append(vals, strings.TrimSpace(buf.String()))\n\t\t\t\tbuf.Reset()\n\t\t\t} else {\n\t\t\t\tbuf.WriteRune(runes[idx])\n\t\t\t}\n\t\t}\n\t\tidx++\n\t\tif idx == len(runes) {\n\t\t\tbreak\n\t\t}\n\t}\n\n\tif buf.Len() > 0 {\n\t\tvals = append(vals, strings.TrimSpace(buf.String()))\n\t}\n\n\treturn vals\n}\n\n// StringsWithShadows returns list of string divided by given delimiter.\n// Shadows will also be appended if any.\nfunc (k *Key) StringsWithShadows(delim string) []string {\n\tvals := k.ValueWithShadows()\n\tresults := make([]string, 0, len(vals)*2)\n\tfor i := range vals {\n\t\tif len(vals) == 0 {\n\t\t\tcontinue\n\t\t}\n\n\t\tresults = append(results, strings.Split(vals[i], delim)...)\n\t}\n\n\tfor i := range results {\n\t\tresults[i] = k.transformValue(strings.TrimSpace(results[i]))\n\t}\n\treturn results\n}\n\n// Float64s returns list of float64 divided by given delimiter. Any invalid input will be treated as zero value.\nfunc (k *Key) Float64s(delim string) []float64 {\n\tvals, _ := k.parseFloat64s(k.Strings(delim), true, false)\n\treturn vals\n}\n\n// Ints returns list of int divided by given delimiter. Any invalid input will be treated as zero value.\nfunc (k *Key) Ints(delim string) []int {\n\tvals, _ := k.parseInts(k.Strings(delim), true, false)\n\treturn vals\n}\n\n// Int64s returns list of int64 divided by given delimiter. Any invalid input will be treated as zero value.\nfunc (k *Key) Int64s(delim string) []int64 {\n\tvals, _ := k.parseInt64s(k.Strings(delim), true, false)\n\treturn vals\n}\n\n// Uints returns list of uint divided by given delimiter. Any invalid input will be treated as zero value.\nfunc (k *Key) Uints(delim string) []uint {\n\tvals, _ := k.parseUints(k.Strings(delim), true, false)\n\treturn vals\n}\n\n// Uint64s returns list of uint64 divided by given delimiter. Any invalid input will be treated as zero value.\nfunc (k *Key) Uint64s(delim string) []uint64 {\n\tvals, _ := k.parseUint64s(k.Strings(delim), true, false)\n\treturn vals\n}\n\n// Bools returns list of bool divided by given delimiter. Any invalid input will be treated as zero value.\nfunc (k *Key) Bools(delim string) []bool {\n\tvals, _ := k.parseBools(k.Strings(delim), true, false)\n\treturn vals\n}\n\n// TimesFormat parses with given format and returns list of time.Time divided by given delimiter.\n// Any invalid input will be treated as zero value (0001-01-01 00:00:00 +0000 UTC).\nfunc (k *Key) TimesFormat(format, delim string) []time.Time {\n\tvals, _ := k.parseTimesFormat(format, k.Strings(delim), true, false)\n\treturn vals\n}\n\n// Times parses with RFC3339 format and returns list of time.Time divided by given delimiter.\n// Any invalid input will be treated as zero value (0001-01-01 00:00:00 +0000 UTC).\nfunc (k *Key) Times(delim string) []time.Time {\n\treturn k.TimesFormat(time.RFC3339, delim)\n}\n\n// ValidFloat64s returns list of float64 divided by given delimiter. If some value is not float, then\n// it will not be included to result list.\nfunc (k *Key) ValidFloat64s(delim string) []float64 {\n\tvals, _ := k.parseFloat64s(k.Strings(delim), false, false)\n\treturn vals\n}\n\n// ValidInts returns list of int divided by given delimiter. If some value is not integer, then it will\n// not be included to result list.\nfunc (k *Key) ValidInts(delim string) []int {\n\tvals, _ := k.parseInts(k.Strings(delim), false, false)\n\treturn vals\n}\n\n// ValidInt64s returns list of int64 divided by given delimiter. If some value is not 64-bit integer,\n// then it will not be included to result list.\nfunc (k *Key) ValidInt64s(delim string) []int64 {\n\tvals, _ := k.parseInt64s(k.Strings(delim), false, false)\n\treturn vals\n}\n\n// ValidUints returns list of uint divided by given delimiter. If some value is not unsigned integer,\n// then it will not be included to result list.\nfunc (k *Key) ValidUints(delim string) []uint {\n\tvals, _ := k.parseUints(k.Strings(delim), false, false)\n\treturn vals\n}\n\n// ValidUint64s returns list of uint64 divided by given delimiter. If some value is not 64-bit unsigned\n// integer, then it will not be included to result list.\nfunc (k *Key) ValidUint64s(delim string) []uint64 {\n\tvals, _ := k.parseUint64s(k.Strings(delim), false, false)\n\treturn vals\n}\n\n// ValidBools returns list of bool divided by given delimiter. If some value is not 64-bit unsigned\n// integer, then it will not be included to result list.\nfunc (k *Key) ValidBools(delim string) []bool {\n\tvals, _ := k.parseBools(k.Strings(delim), false, false)\n\treturn vals\n}\n\n// ValidTimesFormat parses with given format and returns list of time.Time divided by given delimiter.\nfunc (k *Key) ValidTimesFormat(format, delim string) []time.Time {\n\tvals, _ := k.parseTimesFormat(format, k.Strings(delim), false, false)\n\treturn vals\n}\n\n// ValidTimes parses with RFC3339 format and returns list of time.Time divided by given delimiter.\nfunc (k *Key) ValidTimes(delim string) []time.Time {\n\treturn k.ValidTimesFormat(time.RFC3339, delim)\n}\n\n// StrictFloat64s returns list of float64 divided by given delimiter or error on first invalid input.\nfunc (k *Key) StrictFloat64s(delim string) ([]float64, error) {\n\treturn k.parseFloat64s(k.Strings(delim), false, true)\n}\n\n// StrictInts returns list of int divided by given delimiter or error on first invalid input.\nfunc (k *Key) StrictInts(delim string) ([]int, error) {\n\treturn k.parseInts(k.Strings(delim), false, true)\n}\n\n// StrictInt64s returns list of int64 divided by given delimiter or error on first invalid input.\nfunc (k *Key) StrictInt64s(delim string) ([]int64, error) {\n\treturn k.parseInt64s(k.Strings(delim), false, true)\n}\n\n// StrictUints returns list of uint divided by given delimiter or error on first invalid input.\nfunc (k *Key) StrictUints(delim string) ([]uint, error) {\n\treturn k.parseUints(k.Strings(delim), false, true)\n}\n\n// StrictUint64s returns list of uint64 divided by given delimiter or error on first invalid input.\nfunc (k *Key) StrictUint64s(delim string) ([]uint64, error) {\n\treturn k.parseUint64s(k.Strings(delim), false, true)\n}\n\n// StrictBools returns list of bool divided by given delimiter or error on first invalid input.\nfunc (k *Key) StrictBools(delim string) ([]bool, error) {\n\treturn k.parseBools(k.Strings(delim), false, true)\n}\n\n// StrictTimesFormat parses with given format and returns list of time.Time divided by given delimiter\n// or error on first invalid input.\nfunc (k *Key) StrictTimesFormat(format, delim string) ([]time.Time, error) {\n\treturn k.parseTimesFormat(format, k.Strings(delim), false, true)\n}\n\n// StrictTimes parses with RFC3339 format and returns list of time.Time divided by given delimiter\n// or error on first invalid input.\nfunc (k *Key) StrictTimes(delim string) ([]time.Time, error) {\n\treturn k.StrictTimesFormat(time.RFC3339, delim)\n}\n\n// parseBools transforms strings to bools.\nfunc (k *Key) parseBools(strs []string, addInvalid, returnOnInvalid bool) ([]bool, error) {\n\tvals := make([]bool, 0, len(strs))\n\tparser := func(str string) (interface{}, error) {\n\t\tval, err := parseBool(str)\n\t\treturn val, err\n\t}\n\trawVals, err := k.doParse(strs, addInvalid, returnOnInvalid, parser)\n\tif err == nil {\n\t\tfor _, val := range rawVals {\n\t\t\tvals = append(vals, val.(bool))\n\t\t}\n\t}\n\treturn vals, err\n}\n\n// parseFloat64s transforms strings to float64s.\nfunc (k *Key) parseFloat64s(strs []string, addInvalid, returnOnInvalid bool) ([]float64, error) {\n\tvals := make([]float64, 0, len(strs))\n\tparser := func(str string) (interface{}, error) {\n\t\tval, err := strconv.ParseFloat(str, 64)\n\t\treturn val, err\n\t}\n\trawVals, err := k.doParse(strs, addInvalid, returnOnInvalid, parser)\n\tif err == nil {\n\t\tfor _, val := range rawVals {\n\t\t\tvals = append(vals, val.(float64))\n\t\t}\n\t}\n\treturn vals, err\n}\n\n// parseInts transforms strings to ints.\nfunc (k *Key) parseInts(strs []string, addInvalid, returnOnInvalid bool) ([]int, error) {\n\tvals := make([]int, 0, len(strs))\n\tparser := func(str string) (interface{}, error) {\n\t\tval, err := strconv.ParseInt(str, 0, 64)\n\t\treturn val, err\n\t}\n\trawVals, err := k.doParse(strs, addInvalid, returnOnInvalid, parser)\n\tif err == nil {\n\t\tfor _, val := range rawVals {\n\t\t\tvals = append(vals, int(val.(int64)))\n\t\t}\n\t}\n\treturn vals, err\n}\n\n// parseInt64s transforms strings to int64s.\nfunc (k *Key) parseInt64s(strs []string, addInvalid, returnOnInvalid bool) ([]int64, error) {\n\tvals := make([]int64, 0, len(strs))\n\tparser := func(str string) (interface{}, error) {\n\t\tval, err := strconv.ParseInt(str, 0, 64)\n\t\treturn val, err\n\t}\n\n\trawVals, err := k.doParse(strs, addInvalid, returnOnInvalid, parser)\n\tif err == nil {\n\t\tfor _, val := range rawVals {\n\t\t\tvals = append(vals, val.(int64))\n\t\t}\n\t}\n\treturn vals, err\n}\n\n// parseUints transforms strings to uints.\nfunc (k *Key) parseUints(strs []string, addInvalid, returnOnInvalid bool) ([]uint, error) {\n\tvals := make([]uint, 0, len(strs))\n\tparser := func(str string) (interface{}, error) {\n\t\tval, err := strconv.ParseUint(str, 0, 64)\n\t\treturn val, err\n\t}\n\n\trawVals, err := k.doParse(strs, addInvalid, returnOnInvalid, parser)\n\tif err == nil {\n\t\tfor _, val := range rawVals {\n\t\t\tvals = append(vals, uint(val.(uint64)))\n\t\t}\n\t}\n\treturn vals, err\n}\n\n// parseUint64s transforms strings to uint64s.\nfunc (k *Key) parseUint64s(strs []string, addInvalid, returnOnInvalid bool) ([]uint64, error) {\n\tvals := make([]uint64, 0, len(strs))\n\tparser := func(str string) (interface{}, error) {\n\t\tval, err := strconv.ParseUint(str, 0, 64)\n\t\treturn val, err\n\t}\n\trawVals, err := k.doParse(strs, addInvalid, returnOnInvalid, parser)\n\tif err == nil {\n\t\tfor _, val := range rawVals {\n\t\t\tvals = append(vals, val.(uint64))\n\t\t}\n\t}\n\treturn vals, err\n}\n\ntype Parser func(str string) (interface{}, error)\n\n// parseTimesFormat transforms strings to times in given format.\nfunc (k *Key) parseTimesFormat(format string, strs []string, addInvalid, returnOnInvalid bool) ([]time.Time, error) {\n\tvals := make([]time.Time, 0, len(strs))\n\tparser := func(str string) (interface{}, error) {\n\t\tval, err := time.Parse(format, str)\n\t\treturn val, err\n\t}\n\trawVals, err := k.doParse(strs, addInvalid, returnOnInvalid, parser)\n\tif err == nil {\n\t\tfor _, val := range rawVals {\n\t\t\tvals = append(vals, val.(time.Time))\n\t\t}\n\t}\n\treturn vals, err\n}\n\n// doParse transforms strings to different types\nfunc (k *Key) doParse(strs []string, addInvalid, returnOnInvalid bool, parser Parser) ([]interface{}, error) {\n\tvals := make([]interface{}, 0, len(strs))\n\tfor _, str := range strs {\n\t\tval, err := parser(str)\n\t\tif err != nil && returnOnInvalid {\n\t\t\treturn nil, err\n\t\t}\n\t\tif err == nil || addInvalid {\n\t\t\tvals = append(vals, val)\n\t\t}\n\t}\n\treturn vals, nil\n}\n\n// SetValue changes key value.\nfunc (k *Key) SetValue(v string) {\n\tif k.s.f.BlockMode {\n\t\tk.s.f.lock.Lock()\n\t\tdefer k.s.f.lock.Unlock()\n\t}\n\n\tk.value = v\n\tk.s.keysHash[k.name] = v\n}\n"
        },
        {
          "name": "key_test.go",
          "type": "blob",
          "size": 19.806640625,
          "content": "// Copyright 2014 Unknwon\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"): you may\n// not use this file except in compliance with the License. You may obtain\n// a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n// WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n// License for the specific language governing permissions and limitations\n// under the License.\n\npackage ini\n\nimport (\n\t\"bytes\"\n\t\"fmt\"\n\t\"runtime\"\n\t\"strings\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/stretchr/testify/assert\"\n\t\"github.com/stretchr/testify/require\"\n)\n\nfunc TestKey_AddShadow(t *testing.T) {\n\tt.Run(\"add shadow to a key\", func(t *testing.T) {\n\t\tf, err := ShadowLoad([]byte(`\n[notes]\n-: note1`))\n\t\trequire.NoError(t, err)\n\t\trequire.NotNil(t, f)\n\n\t\tk, err := f.Section(\"\").NewKey(\"NAME\", \"ini\")\n\t\trequire.NoError(t, err)\n\t\trequire.NotNil(t, k)\n\n\t\tassert.NoError(t, k.AddShadow(\"ini.v1\"))\n\t\tassert.Equal(t, []string{\"ini\", \"ini.v1\"}, k.ValueWithShadows())\n\n\t\tt.Run(\"add shadow to boolean key\", func(t *testing.T) {\n\t\t\tk, err := f.Section(\"\").NewBooleanKey(\"published\")\n\t\t\trequire.NoError(t, err)\n\t\t\trequire.NotNil(t, k)\n\t\t\tassert.Error(t, k.AddShadow(\"beta\"))\n\t\t})\n\n\t\tt.Run(\"add shadow to auto-increment key\", func(t *testing.T) {\n\t\t\tassert.Error(t, f.Section(\"notes\").Key(\"#1\").AddShadow(\"beta\"))\n\t\t})\n\n\t\tt.Run(\"deduplicate an existing value\", func(t *testing.T) {\n\t\t\tk := f.Section(\"\").Key(\"NAME\")\n\t\t\tassert.NoError(t, k.AddShadow(\"ini\"))\n\t\t\tassert.Equal(t, []string{\"ini\", \"ini.v1\"}, k.ValueWithShadows())\n\t\t})\n\n\t\tt.Run(\"ignore empty shadow values\", func(t *testing.T) {\n\t\t\tk := f.Section(\"\").Key(\"empty\")\n\t\t\tassert.NoError(t, k.AddShadow(\"\"))\n\t\t\tassert.NoError(t, k.AddShadow(\"ini\"))\n\t\t\tassert.Equal(t, []string{\"ini\"}, k.ValueWithShadows())\n\t\t})\n\t})\n\n\tt.Run(\"allow duplicate shadowed values\", func(t *testing.T) {\n\t\tf := Empty(LoadOptions{\n\t\t\tAllowShadows:               true,\n\t\t\tAllowDuplicateShadowValues: true,\n\t\t})\n\t\trequire.NotNil(t, f)\n\n\t\tk, err := f.Section(\"\").NewKey(\"NAME\", \"ini\")\n\t\trequire.NoError(t, err)\n\t\trequire.NotNil(t, k)\n\n\t\tassert.NoError(t, k.AddShadow(\"ini.v1\"))\n\t\tassert.NoError(t, k.AddShadow(\"ini\"))\n\t\tassert.NoError(t, k.AddShadow(\"ini\"))\n\t\tassert.Equal(t, []string{\"ini\", \"ini.v1\", \"ini\", \"ini\"}, k.ValueWithShadows())\n\t})\n\n\tt.Run(\"shadow is not allowed\", func(t *testing.T) {\n\t\tf := Empty()\n\t\trequire.NotNil(t, f)\n\n\t\tk, err := f.Section(\"\").NewKey(\"NAME\", \"ini\")\n\t\trequire.NoError(t, err)\n\t\trequire.NotNil(t, k)\n\n\t\tassert.Error(t, k.AddShadow(\"ini.v1\"))\n\t})\n}\n\n// Helpers for slice tests.\nfunc float64sEqual(t *testing.T, values []float64, expected ...float64) {\n\tt.Helper()\n\n\tassert.Len(t, values, len(expected))\n\tfor i, v := range expected {\n\t\tassert.Equal(t, v, values[i])\n\t}\n}\n\nfunc intsEqual(t *testing.T, values []int, expected ...int) {\n\tt.Helper()\n\n\tassert.Len(t, values, len(expected))\n\tfor i, v := range expected {\n\t\tassert.Equal(t, v, values[i])\n\t}\n}\n\nfunc int64sEqual(t *testing.T, values []int64, expected ...int64) {\n\tt.Helper()\n\n\tassert.Len(t, values, len(expected))\n\tfor i, v := range expected {\n\t\tassert.Equal(t, v, values[i])\n\t}\n}\n\nfunc uintsEqual(t *testing.T, values []uint, expected ...uint) {\n\tt.Helper()\n\n\tassert.Len(t, values, len(expected))\n\tfor i, v := range expected {\n\t\tassert.Equal(t, v, values[i])\n\t}\n}\n\nfunc uint64sEqual(t *testing.T, values []uint64, expected ...uint64) {\n\tt.Helper()\n\n\tassert.Len(t, values, len(expected))\n\tfor i, v := range expected {\n\t\tassert.Equal(t, v, values[i])\n\t}\n}\n\nfunc boolsEqual(t *testing.T, values []bool, expected ...bool) {\n\tt.Helper()\n\n\tassert.Len(t, values, len(expected))\n\tfor i, v := range expected {\n\t\tassert.Equal(t, v, values[i])\n\t}\n}\n\nfunc timesEqual(t *testing.T, values []time.Time, expected ...time.Time) {\n\tt.Helper()\n\n\tassert.Len(t, values, len(expected))\n\tfor i, v := range expected {\n\t\tassert.Equal(t, v.String(), values[i].String())\n\t}\n}\n\nfunc TestKey_Helpers(t *testing.T) {\n\tt.Run(\"getting and setting values\", func(t *testing.T) {\n\t\tf, err := Load(fullConf)\n\t\trequire.NoError(t, err)\n\t\trequire.NotNil(t, f)\n\n\t\tt.Run(\"get string representation\", func(t *testing.T) {\n\t\t\tsec := f.Section(\"\")\n\t\t\trequire.NotNil(t, sec)\n\t\t\tassert.Equal(t, \"ini\", sec.Key(\"NAME\").Value())\n\t\t\tassert.Equal(t, \"ini\", sec.Key(\"NAME\").String())\n\t\t\tassert.Equal(t, \"ini\", sec.Key(\"NAME\").Validate(func(in string) string {\n\t\t\t\treturn in\n\t\t\t}))\n\t\t\tassert.Equal(t, \"; Package name\", sec.Key(\"NAME\").Comment)\n\t\t\tassert.Equal(t, \"gopkg.in/ini.v1\", sec.Key(\"IMPORT_PATH\").String())\n\n\t\t\tt.Run(\"with ValueMapper\", func(t *testing.T) {\n\t\t\t\tf.ValueMapper = func(in string) string {\n\t\t\t\t\tif in == \"gopkg.in/%(NAME)s.%(VERSION)s\" {\n\t\t\t\t\t\treturn \"github.com/go-ini/ini\"\n\t\t\t\t\t}\n\t\t\t\t\treturn in\n\t\t\t\t}\n\t\t\t\tassert.Equal(t, \"github.com/go-ini/ini\", sec.Key(\"IMPORT_PATH\").String())\n\t\t\t})\n\t\t})\n\n\t\tt.Run(\"get values in non-default section\", func(t *testing.T) {\n\t\t\tsec := f.Section(\"author\")\n\t\t\trequire.NotNil(t, sec)\n\t\t\tassert.Equal(t, \"Unknwon\", sec.Key(\"NAME\").String())\n\t\t\tassert.Equal(t, \"https://github.com/Unknwon\", sec.Key(\"GITHUB\").String())\n\n\t\t\tsec = f.Section(\"package\")\n\t\t\trequire.NotNil(t, sec)\n\t\t\tassert.Equal(t, \"https://gopkg.in/ini.v1\", sec.Key(\"CLONE_URL\").String())\n\t\t})\n\n\t\tt.Run(\"get auto-increment key names\", func(t *testing.T) {\n\t\t\tkeys := f.Section(\"features\").Keys()\n\t\t\tfor i, k := range keys {\n\t\t\t\tassert.Equal(t, fmt.Sprintf(\"#%d\", i+1), k.Name())\n\t\t\t}\n\t\t})\n\n\t\tt.Run(\"get parent-keys that are available to the child section\", func(t *testing.T) {\n\t\t\tparentKeys := f.Section(\"package.sub\").ParentKeys()\n\t\t\tfor _, k := range parentKeys {\n\t\t\t\tassert.Equal(t, \"CLONE_URL\", k.Name())\n\t\t\t}\n\t\t})\n\n\t\tt.Run(\"get overwrite value\", func(t *testing.T) {\n\t\t\tassert.Equal(t, \"u@gogs.io\", f.Section(\"author\").Key(\"E-MAIL\").String())\n\t\t})\n\n\t\tt.Run(\"get sections\", func(t *testing.T) {\n\t\t\tsections := f.Sections()\n\t\t\tfor i, name := range []string{DefaultSection, \"author\", \"package\", \"package.sub\", \"features\", \"types\", \"array\", \"note\", \"comments\", \"string escapes\", \"advance\"} {\n\t\t\t\tassert.Equal(t, name, sections[i].Name())\n\t\t\t}\n\t\t})\n\n\t\tt.Run(\"get parent section value\", func(t *testing.T) {\n\t\t\tassert.Equal(t, \"https://gopkg.in/ini.v1\", f.Section(\"package.sub\").Key(\"CLONE_URL\").String())\n\t\t\tassert.Equal(t, \"https://gopkg.in/ini.v1\", f.Section(\"package.fake.sub\").Key(\"CLONE_URL\").String())\n\t\t})\n\n\t\tt.Run(\"get multiple line value\", func(t *testing.T) {\n\t\t\tif runtime.GOOS == \"windows\" {\n\t\t\t\tt.Skip(\"Skipping testing on Windows\")\n\t\t\t}\n\n\t\t\tassert.Equal(t, \"Gopher.\\nCoding addict.\\nGood man.\\n\", f.Section(\"author\").Key(\"BIO\").String())\n\t\t})\n\n\t\tt.Run(\"get values with type\", func(t *testing.T) {\n\t\t\tsec := f.Section(\"types\")\n\t\t\tv1, err := sec.Key(\"BOOL\").Bool()\n\t\t\trequire.NoError(t, err)\n\t\t\tassert.True(t, v1)\n\n\t\t\tv1, err = sec.Key(\"BOOL_FALSE\").Bool()\n\t\t\trequire.NoError(t, err)\n\t\t\tassert.False(t, v1)\n\n\t\t\tv2, err := sec.Key(\"FLOAT64\").Float64()\n\t\t\trequire.NoError(t, err)\n\t\t\tassert.Equal(t, 1.25, v2)\n\n\t\t\tv3, err := sec.Key(\"INT\").Int()\n\t\t\trequire.NoError(t, err)\n\t\t\tassert.Equal(t, 10, v3)\n\n\t\t\tv4, err := sec.Key(\"INT\").Int64()\n\t\t\trequire.NoError(t, err)\n\t\t\tassert.Equal(t, int64(10), v4)\n\n\t\t\tv5, err := sec.Key(\"UINT\").Uint()\n\t\t\trequire.NoError(t, err)\n\t\t\tassert.Equal(t, uint(3), v5)\n\n\t\t\tv6, err := sec.Key(\"UINT\").Uint64()\n\t\t\trequire.NoError(t, err)\n\t\t\tassert.Equal(t, uint64(3), v6)\n\n\t\t\tti, err := time.Parse(time.RFC3339, \"2015-01-01T20:17:05Z\")\n\t\t\trequire.NoError(t, err)\n\t\t\tv7, err := sec.Key(\"TIME\").Time()\n\t\t\trequire.NoError(t, err)\n\t\t\tassert.Equal(t, ti.String(), v7.String())\n\n\t\t\tv8, err := sec.Key(\"HEX_NUMBER\").Int()\n\t\t\trequire.NoError(t, err)\n\t\t\tassert.Equal(t, 0x3000, v8)\n\n\t\t\tt.Run(\"must get values with type\", func(t *testing.T) {\n\t\t\t\tassert.Equal(t, \"str\", sec.Key(\"STRING\").MustString(\"404\"))\n\t\t\t\tassert.True(t, sec.Key(\"BOOL\").MustBool())\n\t\t\t\tassert.Equal(t, float64(1.25), sec.Key(\"FLOAT64\").MustFloat64())\n\t\t\t\tassert.Equal(t, int(10), sec.Key(\"INT\").MustInt())\n\t\t\t\tassert.Equal(t, int64(10), sec.Key(\"INT\").MustInt64())\n\t\t\t\tassert.Equal(t, uint(3), sec.Key(\"UINT\").MustUint())\n\t\t\t\tassert.Equal(t, uint64(3), sec.Key(\"UINT\").MustUint64())\n\t\t\t\tassert.Equal(t, ti.String(), sec.Key(\"TIME\").MustTime().String())\n\t\t\t\tassert.Equal(t, 0x3000, sec.Key(\"HEX_NUMBER\").MustInt())\n\n\t\t\t\tdur, err := time.ParseDuration(\"2h45m\")\n\t\t\t\trequire.NoError(t, err)\n\t\t\t\tassert.Equal(t, dur.Seconds(), sec.Key(\"DURATION\").MustDuration().Seconds())\n\n\t\t\t\tt.Run(\"must get values with default value\", func(t *testing.T) {\n\t\t\t\t\tassert.Equal(t, \"404\", sec.Key(\"STRING_404\").MustString(\"404\"))\n\t\t\t\t\tassert.True(t, sec.Key(\"BOOL_404\").MustBool(true))\n\t\t\t\t\tassert.Equal(t, float64(2.5), sec.Key(\"FLOAT64_404\").MustFloat64(2.5))\n\t\t\t\t\tassert.Equal(t, int(15), sec.Key(\"INT_404\").MustInt(15))\n\t\t\t\t\tassert.Equal(t, int64(15), sec.Key(\"INT64_404\").MustInt64(15))\n\t\t\t\t\tassert.Equal(t, uint(6), sec.Key(\"UINT_404\").MustUint(6))\n\t\t\t\t\tassert.Equal(t, uint64(6), sec.Key(\"UINT64_404\").MustUint64(6))\n\t\t\t\t\tassert.Equal(t, 0x3001, sec.Key(\"HEX_NUMBER_404\").MustInt(0x3001))\n\n\t\t\t\t\tti, err := time.Parse(time.RFC3339, \"2014-01-01T20:17:05Z\")\n\t\t\t\t\trequire.NoError(t, err)\n\t\t\t\t\tassert.Equal(t, ti.String(), sec.Key(\"TIME_404\").MustTime(ti).String())\n\n\t\t\t\t\tassert.Equal(t, dur.Seconds(), sec.Key(\"DURATION_404\").MustDuration(dur).Seconds())\n\n\t\t\t\t\tt.Run(\"must should set default as key value\", func(t *testing.T) {\n\t\t\t\t\t\tassert.Equal(t, \"404\", sec.Key(\"STRING_404\").String())\n\t\t\t\t\t\tassert.Equal(t, \"true\", sec.Key(\"BOOL_404\").String())\n\t\t\t\t\t\tassert.Equal(t, \"2.5\", sec.Key(\"FLOAT64_404\").String())\n\t\t\t\t\t\tassert.Equal(t, \"15\", sec.Key(\"INT_404\").String())\n\t\t\t\t\t\tassert.Equal(t, \"15\", sec.Key(\"INT64_404\").String())\n\t\t\t\t\t\tassert.Equal(t, \"6\", sec.Key(\"UINT_404\").String())\n\t\t\t\t\t\tassert.Equal(t, \"6\", sec.Key(\"UINT64_404\").String())\n\t\t\t\t\t\tassert.Equal(t, \"2014-01-01T20:17:05Z\", sec.Key(\"TIME_404\").String())\n\t\t\t\t\t\tassert.Equal(t, \"2h45m0s\", sec.Key(\"DURATION_404\").String())\n\t\t\t\t\t\tassert.Equal(t, \"12289\", sec.Key(\"HEX_NUMBER_404\").String())\n\t\t\t\t\t})\n\t\t\t\t})\n\t\t\t})\n\t\t})\n\n\t\tt.Run(\"get value with candidates\", func(t *testing.T) {\n\t\t\tsec := f.Section(\"types\")\n\t\t\tassert.Equal(t, \"str\", sec.Key(\"STRING\").In(\"\", []string{\"str\", \"arr\", \"types\"}))\n\t\t\tassert.Equal(t, float64(1.25), sec.Key(\"FLOAT64\").InFloat64(0, []float64{1.25, 2.5, 3.75}))\n\t\t\tassert.Equal(t, int(10), sec.Key(\"INT\").InInt(0, []int{10, 20, 30}))\n\t\t\tassert.Equal(t, int64(10), sec.Key(\"INT\").InInt64(0, []int64{10, 20, 30}))\n\t\t\tassert.Equal(t, uint(3), sec.Key(\"UINT\").InUint(0, []uint{3, 6, 9}))\n\t\t\tassert.Equal(t, uint64(3), sec.Key(\"UINT\").InUint64(0, []uint64{3, 6, 9}))\n\n\t\t\tzt, err := time.Parse(time.RFC3339, \"0001-01-01T01:00:00Z\")\n\t\t\trequire.NoError(t, err)\n\t\t\tti, err := time.Parse(time.RFC3339, \"2015-01-01T20:17:05Z\")\n\t\t\trequire.NoError(t, err)\n\t\t\tassert.Equal(t, ti.String(), sec.Key(\"TIME\").InTime(zt, []time.Time{ti, time.Now(), time.Now().Add(1 * time.Second)}).String())\n\n\t\t\tt.Run(\"get value with candidates and default value\", func(t *testing.T) {\n\t\t\t\tassert.Equal(t, \"str\", sec.Key(\"STRING_404_2\").In(\"str\", []string{\"str\", \"arr\", \"types\"}))\n\t\t\t\tassert.Equal(t, float64(1.25), sec.Key(\"FLOAT64_404_2\").InFloat64(1.25, []float64{1.25, 2.5, 3.75}))\n\t\t\t\tassert.Equal(t, int(10), sec.Key(\"INT_404_2\").InInt(10, []int{10, 20, 30}))\n\t\t\t\tassert.Equal(t, int64(10), sec.Key(\"INT64_404_2\").InInt64(10, []int64{10, 20, 30}))\n\t\t\t\tassert.Equal(t, uint(3), sec.Key(\"UINT_404_2\").InUint(3, []uint{3, 6, 9}))\n\t\t\t\tassert.Equal(t, uint64(3), sec.Key(\"UINT_404_2\").InUint64(3, []uint64{3, 6, 9}))\n\t\t\t\tassert.Equal(t, ti.String(), sec.Key(\"TIME_404_2\").InTime(ti, []time.Time{time.Now(), time.Now(), time.Now().Add(1 * time.Second)}).String())\n\t\t\t})\n\t\t})\n\n\t\tt.Run(\"get values in range\", func(t *testing.T) {\n\t\t\tsec := f.Section(\"types\")\n\t\t\tassert.Equal(t, float64(1.25), sec.Key(\"FLOAT64\").RangeFloat64(0, 1, 2))\n\t\t\tassert.Equal(t, int(10), sec.Key(\"INT\").RangeInt(0, 10, 20))\n\t\t\tassert.Equal(t, int64(10), sec.Key(\"INT\").RangeInt64(0, 10, 20))\n\n\t\t\tminT, err := time.Parse(time.RFC3339, \"0001-01-01T01:00:00Z\")\n\t\t\trequire.NoError(t, err)\n\t\t\tmidT, err := time.Parse(time.RFC3339, \"2013-01-01T01:00:00Z\")\n\t\t\trequire.NoError(t, err)\n\t\t\tmaxT, err := time.Parse(time.RFC3339, \"9999-01-01T01:00:00Z\")\n\t\t\trequire.NoError(t, err)\n\t\t\tti, err := time.Parse(time.RFC3339, \"2015-01-01T20:17:05Z\")\n\t\t\trequire.NoError(t, err)\n\t\t\tassert.Equal(t, ti.String(), sec.Key(\"TIME\").RangeTime(ti, minT, maxT).String())\n\n\t\t\tt.Run(\"get value in range with default value\", func(t *testing.T) {\n\t\t\t\tassert.Equal(t, float64(5), sec.Key(\"FLOAT64\").RangeFloat64(5, 0, 1))\n\t\t\t\tassert.Equal(t, 7, sec.Key(\"INT\").RangeInt(7, 0, 5))\n\t\t\t\tassert.Equal(t, int64(7), sec.Key(\"INT\").RangeInt64(7, 0, 5))\n\t\t\t\tassert.Equal(t, ti.String(), sec.Key(\"TIME\").RangeTime(ti, minT, midT).String())\n\t\t\t})\n\t\t})\n\n\t\tt.Run(\"get values into slice\", func(t *testing.T) {\n\t\t\tsec := f.Section(\"array\")\n\t\t\tassert.Equal(t, \"en,zh,de\", strings.Join(sec.Key(\"STRINGS\").Strings(\",\"), \",\"))\n\t\t\tassert.Equal(t, 0, len(sec.Key(\"STRINGS_404\").Strings(\",\")))\n\n\t\t\tvals1 := sec.Key(\"FLOAT64S\").Float64s(\",\")\n\t\t\tfloat64sEqual(t, vals1, 1.1, 2.2, 3.3)\n\n\t\t\tvals2 := sec.Key(\"INTS\").Ints(\",\")\n\t\t\tintsEqual(t, vals2, 1, 2, 3)\n\n\t\t\tvals3 := sec.Key(\"INTS\").Int64s(\",\")\n\t\t\tint64sEqual(t, vals3, 1, 2, 3)\n\n\t\t\tvals4 := sec.Key(\"UINTS\").Uints(\",\")\n\t\t\tuintsEqual(t, vals4, 1, 2, 3)\n\n\t\t\tvals5 := sec.Key(\"UINTS\").Uint64s(\",\")\n\t\t\tuint64sEqual(t, vals5, 1, 2, 3)\n\n\t\t\tvals6 := sec.Key(\"BOOLS\").Bools(\",\")\n\t\t\tboolsEqual(t, vals6, true, false, false)\n\n\t\t\tti, err := time.Parse(time.RFC3339, \"2015-01-01T20:17:05Z\")\n\t\t\trequire.NoError(t, err)\n\t\t\tvals7 := sec.Key(\"TIMES\").Times(\",\")\n\t\t\ttimesEqual(t, vals7, ti, ti, ti)\n\t\t})\n\n\t\tt.Run(\"test string slice escapes\", func(t *testing.T) {\n\t\t\tsec := f.Section(\"string escapes\")\n\t\t\tassert.Equal(t, []string{\"value1\", \"value2\", \"value3\"}, sec.Key(\"key1\").Strings(\",\"))\n\t\t\tassert.Equal(t, []string{\"value1, value2\"}, sec.Key(\"key2\").Strings(\",\"))\n\t\t\tassert.Equal(t, []string{`val\\ue1`, \"value2\"}, sec.Key(\"key3\").Strings(\",\"))\n\t\t\tassert.Equal(t, []string{`value1\\`, `value\\\\2`}, sec.Key(\"key4\").Strings(\",\"))\n\t\t\tassert.Equal(t, []string{\"value1,, value2\"}, sec.Key(\"key5\").Strings(\",,\"))\n\t\t\tassert.Equal(t, []string{\"aaa\", \"bbb and space\", \"ccc\"}, sec.Key(\"key6\").Strings(\" \"))\n\t\t})\n\n\t\tt.Run(\"get valid values into slice\", func(t *testing.T) {\n\t\t\tsec := f.Section(\"array\")\n\t\t\tvals1 := sec.Key(\"FLOAT64S\").ValidFloat64s(\",\")\n\t\t\tfloat64sEqual(t, vals1, 1.1, 2.2, 3.3)\n\n\t\t\tvals2 := sec.Key(\"INTS\").ValidInts(\",\")\n\t\t\tintsEqual(t, vals2, 1, 2, 3)\n\n\t\t\tvals3 := sec.Key(\"INTS\").ValidInt64s(\",\")\n\t\t\tint64sEqual(t, vals3, 1, 2, 3)\n\n\t\t\tvals4 := sec.Key(\"UINTS\").ValidUints(\",\")\n\t\t\tuintsEqual(t, vals4, 1, 2, 3)\n\n\t\t\tvals5 := sec.Key(\"UINTS\").ValidUint64s(\",\")\n\t\t\tuint64sEqual(t, vals5, 1, 2, 3)\n\n\t\t\tvals6 := sec.Key(\"BOOLS\").ValidBools(\",\")\n\t\t\tboolsEqual(t, vals6, true, false, false)\n\n\t\t\tti, err := time.Parse(time.RFC3339, \"2015-01-01T20:17:05Z\")\n\t\t\trequire.NoError(t, err)\n\t\t\tvals7 := sec.Key(\"TIMES\").ValidTimes(\",\")\n\t\t\ttimesEqual(t, vals7, ti, ti, ti)\n\t\t})\n\n\t\tt.Run(\"get values one type into slice of another type\", func(t *testing.T) {\n\t\t\tsec := f.Section(\"array\")\n\t\t\tvals1 := sec.Key(\"STRINGS\").ValidFloat64s(\",\")\n\t\t\tassert.Empty(t, vals1)\n\n\t\t\tvals2 := sec.Key(\"STRINGS\").ValidInts(\",\")\n\t\t\tassert.Empty(t, vals2)\n\n\t\t\tvals3 := sec.Key(\"STRINGS\").ValidInt64s(\",\")\n\t\t\tassert.Empty(t, vals3)\n\n\t\t\tvals4 := sec.Key(\"STRINGS\").ValidUints(\",\")\n\t\t\tassert.Empty(t, vals4)\n\n\t\t\tvals5 := sec.Key(\"STRINGS\").ValidUint64s(\",\")\n\t\t\tassert.Empty(t, vals5)\n\n\t\t\tvals6 := sec.Key(\"STRINGS\").ValidBools(\",\")\n\t\t\tassert.Empty(t, vals6)\n\n\t\t\tvals7 := sec.Key(\"STRINGS\").ValidTimes(\",\")\n\t\t\tassert.Empty(t, vals7)\n\t\t})\n\n\t\tt.Run(\"get valid values into slice without errors\", func(t *testing.T) {\n\t\t\tsec := f.Section(\"array\")\n\t\t\tvals1, err := sec.Key(\"FLOAT64S\").StrictFloat64s(\",\")\n\t\t\trequire.NoError(t, err)\n\t\t\tfloat64sEqual(t, vals1, 1.1, 2.2, 3.3)\n\n\t\t\tvals2, err := sec.Key(\"INTS\").StrictInts(\",\")\n\t\t\trequire.NoError(t, err)\n\t\t\tintsEqual(t, vals2, 1, 2, 3)\n\n\t\t\tvals3, err := sec.Key(\"INTS\").StrictInt64s(\",\")\n\t\t\trequire.NoError(t, err)\n\t\t\tint64sEqual(t, vals3, 1, 2, 3)\n\n\t\t\tvals4, err := sec.Key(\"UINTS\").StrictUints(\",\")\n\t\t\trequire.NoError(t, err)\n\t\t\tuintsEqual(t, vals4, 1, 2, 3)\n\n\t\t\tvals5, err := sec.Key(\"UINTS\").StrictUint64s(\",\")\n\t\t\trequire.NoError(t, err)\n\t\t\tuint64sEqual(t, vals5, 1, 2, 3)\n\n\t\t\tvals6, err := sec.Key(\"BOOLS\").StrictBools(\",\")\n\t\t\trequire.NoError(t, err)\n\t\t\tboolsEqual(t, vals6, true, false, false)\n\n\t\t\tti, err := time.Parse(time.RFC3339, \"2015-01-01T20:17:05Z\")\n\t\t\trequire.NoError(t, err)\n\t\t\tvals7, err := sec.Key(\"TIMES\").StrictTimes(\",\")\n\t\t\trequire.NoError(t, err)\n\t\t\ttimesEqual(t, vals7, ti, ti, ti)\n\t\t})\n\n\t\tt.Run(\"get invalid values into slice\", func(t *testing.T) {\n\t\t\tsec := f.Section(\"array\")\n\t\t\tvals1, err := sec.Key(\"STRINGS\").StrictFloat64s(\",\")\n\t\t\tassert.Empty(t, vals1)\n\t\t\tassert.Error(t, err)\n\n\t\t\tvals2, err := sec.Key(\"STRINGS\").StrictInts(\",\")\n\t\t\tassert.Empty(t, vals2)\n\t\t\tassert.Error(t, err)\n\n\t\t\tvals3, err := sec.Key(\"STRINGS\").StrictInt64s(\",\")\n\t\t\tassert.Empty(t, vals3)\n\t\t\tassert.Error(t, err)\n\n\t\t\tvals4, err := sec.Key(\"STRINGS\").StrictUints(\",\")\n\t\t\tassert.Empty(t, vals4)\n\t\t\tassert.Error(t, err)\n\n\t\t\tvals5, err := sec.Key(\"STRINGS\").StrictUint64s(\",\")\n\t\t\tassert.Empty(t, vals5)\n\t\t\tassert.Error(t, err)\n\n\t\t\tvals6, err := sec.Key(\"STRINGS\").StrictBools(\",\")\n\t\t\tassert.Empty(t, vals6)\n\t\t\tassert.Error(t, err)\n\n\t\t\tvals7, err := sec.Key(\"STRINGS\").StrictTimes(\",\")\n\t\t\tassert.Empty(t, vals7)\n\t\t\tassert.Error(t, err)\n\t\t})\n\t})\n}\n\nfunc TestKey_ValueWithShadows(t *testing.T) {\n\tt.Run(\"\", func(t *testing.T) {\n\t\tf, err := ShadowLoad([]byte(`\nkeyName = value1\nkeyName = value2\n`))\n\t\trequire.NoError(t, err)\n\t\trequire.NotNil(t, f)\n\n\t\tk := f.Section(\"\").Key(\"FakeKey\")\n\t\trequire.NotNil(t, k)\n\t\tassert.Equal(t, []string{}, k.ValueWithShadows())\n\n\t\tk = f.Section(\"\").Key(\"keyName\")\n\t\trequire.NotNil(t, k)\n\t\tassert.Equal(t, []string{\"value1\", \"value2\"}, k.ValueWithShadows())\n\t})\n}\n\nfunc TestKey_StringsWithShadows(t *testing.T) {\n\tt.Run(\"get strings of shadows of a key\", func(t *testing.T) {\n\t\tf, err := ShadowLoad([]byte(\"\"))\n\t\trequire.NoError(t, err)\n\t\trequire.NotNil(t, f)\n\n\t\tk, err := f.Section(\"\").NewKey(\"NUMS\", \"1,2\")\n\t\trequire.NoError(t, err)\n\t\trequire.NotNil(t, k)\n\t\tk, err = f.Section(\"\").NewKey(\"NUMS\", \"4,5,6\")\n\t\trequire.NoError(t, err)\n\t\trequire.NotNil(t, k)\n\n\t\tassert.Equal(t, []string{\"1\", \"2\", \"4\", \"5\", \"6\"}, k.StringsWithShadows(\",\"))\n\t})\n}\n\nfunc TestKey_SetValue(t *testing.T) {\n\tt.Run(\"set value of key\", func(t *testing.T) {\n\t\tf := Empty()\n\t\trequire.NotNil(t, f)\n\n\t\tk, err := f.Section(\"\").NewKey(\"NAME\", \"ini\")\n\t\trequire.NoError(t, err)\n\t\trequire.NotNil(t, k)\n\t\tassert.Equal(t, \"ini\", k.Value())\n\n\t\tk.SetValue(\"ini.v1\")\n\t\tassert.Equal(t, \"ini.v1\", k.Value())\n\t})\n}\n\nfunc TestKey_NestedValues(t *testing.T) {\n\tt.Run(\"read and write nested values\", func(t *testing.T) {\n\t\tf, err := LoadSources(LoadOptions{\n\t\t\tAllowNestedValues: true,\n\t\t}, []byte(`\naws_access_key_id = foo\naws_secret_access_key = bar\nregion = us-west-2\ns3 =\n  max_concurrent_requests=10\n  max_queue_size=1000`))\n\t\trequire.NoError(t, err)\n\t\trequire.NotNil(t, f)\n\n\t\tassert.Equal(t, []string{\"max_concurrent_requests=10\", \"max_queue_size=1000\"}, f.Section(\"\").Key(\"s3\").NestedValues())\n\n\t\tvar buf bytes.Buffer\n\t\t_, err = f.WriteTo(&buf)\n\t\trequire.NoError(t, err)\n\t\tassert.Equal(t, `aws_access_key_id     = foo\naws_secret_access_key = bar\nregion                = us-west-2\ns3                    = \n  max_concurrent_requests=10\n  max_queue_size=1000\n`,\n\t\t\tbuf.String(),\n\t\t)\n\t})\n}\n\nfunc TestRecursiveValues(t *testing.T) {\n\tt.Run(\"recursive values should not reflect on same key\", func(t *testing.T) {\n\t\tf, err := Load([]byte(`\nNAME = ini\nexpires = yes\n[package]\nNAME = %(NAME)s\nexpires = %(expires)s`))\n\t\trequire.NoError(t, err)\n\t\trequire.NotNil(t, f)\n\n\t\tassert.Equal(t, \"ini\", f.Section(\"package\").Key(\"NAME\").String())\n\t\tassert.Equal(t, \"yes\", f.Section(\"package\").Key(\"expires\").String())\n\t})\n\n\tt.Run(\"recursive value with no target found\", func(t *testing.T) {\n\t\tf, err := Load([]byte(`\n[foo]\nbar = %(missing)s\n`))\n\t\trequire.NoError(t, err)\n\t\trequire.NotNil(t, f)\n\n\t\tassert.Equal(t, \"%(missing)s\", f.Section(\"foo\").Key(\"bar\").String())\n\t})\n}\n"
        },
        {
          "name": "parser.go",
          "type": "blob",
          "size": 12.75390625,
          "content": "// Copyright 2015 Unknwon\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"): you may\n// not use this file except in compliance with the License. You may obtain\n// a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n// WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n// License for the specific language governing permissions and limitations\n// under the License.\n\npackage ini\n\nimport (\n\t\"bufio\"\n\t\"bytes\"\n\t\"fmt\"\n\t\"io\"\n\t\"regexp\"\n\t\"strconv\"\n\t\"strings\"\n\t\"unicode\"\n)\n\nconst minReaderBufferSize = 4096\n\nvar pythonMultiline = regexp.MustCompile(`^([\\t\\f ]+)(.*)`)\n\ntype parserOptions struct {\n\tIgnoreContinuation          bool\n\tIgnoreInlineComment         bool\n\tAllowPythonMultilineValues  bool\n\tSpaceBeforeInlineComment    bool\n\tUnescapeValueDoubleQuotes   bool\n\tUnescapeValueCommentSymbols bool\n\tPreserveSurroundedQuote     bool\n\tDebugFunc                   DebugFunc\n\tReaderBufferSize            int\n}\n\ntype parser struct {\n\tbuf     *bufio.Reader\n\toptions parserOptions\n\n\tisEOF   bool\n\tcount   int\n\tcomment *bytes.Buffer\n}\n\nfunc (p *parser) debug(format string, args ...interface{}) {\n\tif p.options.DebugFunc != nil {\n\t\tp.options.DebugFunc(fmt.Sprintf(format, args...))\n\t}\n}\n\nfunc newParser(r io.Reader, opts parserOptions) *parser {\n\tsize := opts.ReaderBufferSize\n\tif size < minReaderBufferSize {\n\t\tsize = minReaderBufferSize\n\t}\n\n\treturn &parser{\n\t\tbuf:     bufio.NewReaderSize(r, size),\n\t\toptions: opts,\n\t\tcount:   1,\n\t\tcomment: &bytes.Buffer{},\n\t}\n}\n\n// BOM handles header of UTF-8, UTF-16 LE and UTF-16 BE's BOM format.\n// http://en.wikipedia.org/wiki/Byte_order_mark#Representations_of_byte_order_marks_by_encoding\nfunc (p *parser) BOM() error {\n\tmask, err := p.buf.Peek(2)\n\tif err != nil && err != io.EOF {\n\t\treturn err\n\t} else if len(mask) < 2 {\n\t\treturn nil\n\t}\n\n\tswitch {\n\tcase mask[0] == 254 && mask[1] == 255:\n\t\tfallthrough\n\tcase mask[0] == 255 && mask[1] == 254:\n\t\t_, err = p.buf.Read(mask)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\tcase mask[0] == 239 && mask[1] == 187:\n\t\tmask, err := p.buf.Peek(3)\n\t\tif err != nil && err != io.EOF {\n\t\t\treturn err\n\t\t} else if len(mask) < 3 {\n\t\t\treturn nil\n\t\t}\n\t\tif mask[2] == 191 {\n\t\t\t_, err = p.buf.Read(mask)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc (p *parser) readUntil(delim byte) ([]byte, error) {\n\tdata, err := p.buf.ReadBytes(delim)\n\tif err != nil {\n\t\tif err == io.EOF {\n\t\t\tp.isEOF = true\n\t\t} else {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\treturn data, nil\n}\n\nfunc cleanComment(in []byte) ([]byte, bool) {\n\ti := bytes.IndexAny(in, \"#;\")\n\tif i == -1 {\n\t\treturn nil, false\n\t}\n\treturn in[i:], true\n}\n\nfunc readKeyName(delimiters string, in []byte) (string, int, error) {\n\tline := string(in)\n\n\t// Check if key name surrounded by quotes.\n\tvar keyQuote string\n\tif line[0] == '\"' {\n\t\tif len(line) > 6 && line[0:3] == `\"\"\"` {\n\t\t\tkeyQuote = `\"\"\"`\n\t\t} else {\n\t\t\tkeyQuote = `\"`\n\t\t}\n\t} else if line[0] == '`' {\n\t\tkeyQuote = \"`\"\n\t}\n\n\t// Get out key name\n\tvar endIdx int\n\tif len(keyQuote) > 0 {\n\t\tstartIdx := len(keyQuote)\n\t\t// FIXME: fail case -> \"\"\"\"\"\"name\"\"\"=value\n\t\tpos := strings.Index(line[startIdx:], keyQuote)\n\t\tif pos == -1 {\n\t\t\treturn \"\", -1, fmt.Errorf(\"missing closing key quote: %s\", line)\n\t\t}\n\t\tpos += startIdx\n\n\t\t// Find key-value delimiter\n\t\ti := strings.IndexAny(line[pos+startIdx:], delimiters)\n\t\tif i < 0 {\n\t\t\treturn \"\", -1, ErrDelimiterNotFound{line}\n\t\t}\n\t\tendIdx = pos + i\n\t\treturn strings.TrimSpace(line[startIdx:pos]), endIdx + startIdx + 1, nil\n\t}\n\n\tendIdx = strings.IndexAny(line, delimiters)\n\tif endIdx < 0 {\n\t\treturn \"\", -1, ErrDelimiterNotFound{line}\n\t}\n\tif endIdx == 0 {\n\t\treturn \"\", -1, ErrEmptyKeyName{line}\n\t}\n\n\treturn strings.TrimSpace(line[0:endIdx]), endIdx + 1, nil\n}\n\nfunc (p *parser) readMultilines(line, val, valQuote string) (string, error) {\n\tfor {\n\t\tdata, err := p.readUntil('\\n')\n\t\tif err != nil {\n\t\t\treturn \"\", err\n\t\t}\n\t\tnext := string(data)\n\n\t\tpos := strings.LastIndex(next, valQuote)\n\t\tif pos > -1 {\n\t\t\tval += next[:pos]\n\n\t\t\tcomment, has := cleanComment([]byte(next[pos:]))\n\t\t\tif has {\n\t\t\t\tp.comment.Write(bytes.TrimSpace(comment))\n\t\t\t}\n\t\t\tbreak\n\t\t}\n\t\tval += next\n\t\tif p.isEOF {\n\t\t\treturn \"\", fmt.Errorf(\"missing closing key quote from %q to %q\", line, next)\n\t\t}\n\t}\n\treturn val, nil\n}\n\nfunc (p *parser) readContinuationLines(val string) (string, error) {\n\tfor {\n\t\tdata, err := p.readUntil('\\n')\n\t\tif err != nil {\n\t\t\treturn \"\", err\n\t\t}\n\t\tnext := strings.TrimSpace(string(data))\n\n\t\tif len(next) == 0 {\n\t\t\tbreak\n\t\t}\n\t\tval += next\n\t\tif val[len(val)-1] != '\\\\' {\n\t\t\tbreak\n\t\t}\n\t\tval = val[:len(val)-1]\n\t}\n\treturn val, nil\n}\n\n// hasSurroundedQuote check if and only if the first and last characters\n// are quotes \\\" or \\'.\n// It returns false if any other parts also contain same kind of quotes.\nfunc hasSurroundedQuote(in string, quote byte) bool {\n\treturn len(in) >= 2 && in[0] == quote && in[len(in)-1] == quote &&\n\t\tstrings.IndexByte(in[1:], quote) == len(in)-2\n}\n\nfunc (p *parser) readValue(in []byte, bufferSize int) (string, error) {\n\n\tline := strings.TrimLeftFunc(string(in), unicode.IsSpace)\n\tif len(line) == 0 {\n\t\tif p.options.AllowPythonMultilineValues && len(in) > 0 && in[len(in)-1] == '\\n' {\n\t\t\treturn p.readPythonMultilines(line, bufferSize)\n\t\t}\n\t\treturn \"\", nil\n\t}\n\n\tvar valQuote string\n\tif len(line) > 3 && line[0:3] == `\"\"\"` {\n\t\tvalQuote = `\"\"\"`\n\t} else if line[0] == '`' {\n\t\tvalQuote = \"`\"\n\t} else if p.options.UnescapeValueDoubleQuotes && line[0] == '\"' {\n\t\tvalQuote = `\"`\n\t}\n\n\tif len(valQuote) > 0 {\n\t\tstartIdx := len(valQuote)\n\t\tpos := strings.LastIndex(line[startIdx:], valQuote)\n\t\t// Check for multi-line value\n\t\tif pos == -1 {\n\t\t\treturn p.readMultilines(line, line[startIdx:], valQuote)\n\t\t}\n\n\t\tif p.options.UnescapeValueDoubleQuotes && valQuote == `\"` {\n\t\t\treturn strings.Replace(line[startIdx:pos+startIdx], `\\\"`, `\"`, -1), nil\n\t\t}\n\t\treturn line[startIdx : pos+startIdx], nil\n\t}\n\n\tlastChar := line[len(line)-1]\n\t// Won't be able to reach here if value only contains whitespace\n\tline = strings.TrimSpace(line)\n\ttrimmedLastChar := line[len(line)-1]\n\n\t// Check continuation lines when desired\n\tif !p.options.IgnoreContinuation && trimmedLastChar == '\\\\' {\n\t\treturn p.readContinuationLines(line[:len(line)-1])\n\t}\n\n\t// Check if ignore inline comment\n\tif !p.options.IgnoreInlineComment {\n\t\tvar i int\n\t\tif p.options.SpaceBeforeInlineComment {\n\t\t\ti = strings.Index(line, \" #\")\n\t\t\tif i == -1 {\n\t\t\t\ti = strings.Index(line, \" ;\")\n\t\t\t}\n\n\t\t} else {\n\t\t\ti = strings.IndexAny(line, \"#;\")\n\t\t}\n\n\t\tif i > -1 {\n\t\t\tp.comment.WriteString(line[i:])\n\t\t\tline = strings.TrimSpace(line[:i])\n\t\t}\n\n\t}\n\n\t// Trim single and double quotes\n\tif (hasSurroundedQuote(line, '\\'') ||\n\t\thasSurroundedQuote(line, '\"')) && !p.options.PreserveSurroundedQuote {\n\t\tline = line[1 : len(line)-1]\n\t} else if len(valQuote) == 0 && p.options.UnescapeValueCommentSymbols {\n\t\tline = strings.ReplaceAll(line, `\\;`, \";\")\n\t\tline = strings.ReplaceAll(line, `\\#`, \"#\")\n\t} else if p.options.AllowPythonMultilineValues && lastChar == '\\n' {\n\t\treturn p.readPythonMultilines(line, bufferSize)\n\t}\n\n\treturn line, nil\n}\n\nfunc (p *parser) readPythonMultilines(line string, bufferSize int) (string, error) {\n\tparserBufferPeekResult, _ := p.buf.Peek(bufferSize)\n\tpeekBuffer := bytes.NewBuffer(parserBufferPeekResult)\n\n\tfor {\n\t\tpeekData, peekErr := peekBuffer.ReadBytes('\\n')\n\t\tif peekErr != nil && peekErr != io.EOF {\n\t\t\tp.debug(\"readPythonMultilines: failed to peek with error: %v\", peekErr)\n\t\t\treturn \"\", peekErr\n\t\t}\n\n\t\tp.debug(\"readPythonMultilines: parsing %q\", string(peekData))\n\n\t\tpeekMatches := pythonMultiline.FindStringSubmatch(string(peekData))\n\t\tp.debug(\"readPythonMultilines: matched %d parts\", len(peekMatches))\n\t\tfor n, v := range peekMatches {\n\t\t\tp.debug(\"   %d: %q\", n, v)\n\t\t}\n\n\t\t// Return if not a Python multiline value.\n\t\tif len(peekMatches) != 3 {\n\t\t\tp.debug(\"readPythonMultilines: end of value, got: %q\", line)\n\t\t\treturn line, nil\n\t\t}\n\n\t\t// Advance the parser reader (buffer) in-sync with the peek buffer.\n\t\t_, err := p.buf.Discard(len(peekData))\n\t\tif err != nil {\n\t\t\tp.debug(\"readPythonMultilines: failed to skip to the end, returning error\")\n\t\t\treturn \"\", err\n\t\t}\n\n\t\tline += \"\\n\" + peekMatches[0]\n\t}\n}\n\n// parse parses data through an io.Reader.\nfunc (f *File) parse(reader io.Reader) (err error) {\n\tp := newParser(reader, parserOptions{\n\t\tIgnoreContinuation:          f.options.IgnoreContinuation,\n\t\tIgnoreInlineComment:         f.options.IgnoreInlineComment,\n\t\tAllowPythonMultilineValues:  f.options.AllowPythonMultilineValues,\n\t\tSpaceBeforeInlineComment:    f.options.SpaceBeforeInlineComment,\n\t\tUnescapeValueDoubleQuotes:   f.options.UnescapeValueDoubleQuotes,\n\t\tUnescapeValueCommentSymbols: f.options.UnescapeValueCommentSymbols,\n\t\tPreserveSurroundedQuote:     f.options.PreserveSurroundedQuote,\n\t\tDebugFunc:                   f.options.DebugFunc,\n\t\tReaderBufferSize:            f.options.ReaderBufferSize,\n\t})\n\tif err = p.BOM(); err != nil {\n\t\treturn fmt.Errorf(\"BOM: %v\", err)\n\t}\n\n\t// Ignore error because default section name is never empty string.\n\tname := DefaultSection\n\tif f.options.Insensitive || f.options.InsensitiveSections {\n\t\tname = strings.ToLower(DefaultSection)\n\t}\n\tsection, _ := f.NewSection(name)\n\n\t// This \"last\" is not strictly equivalent to \"previous one\" if current key is not the first nested key\n\tvar isLastValueEmpty bool\n\tvar lastRegularKey *Key\n\n\tvar line []byte\n\tvar inUnparseableSection bool\n\n\t// NOTE: Iterate and increase `currentPeekSize` until\n\t// the size of the parser buffer is found.\n\t// TODO(unknwon): When Golang 1.10 is the lowest version supported, replace with `parserBufferSize := p.buf.Size()`.\n\tparserBufferSize := 0\n\t// NOTE: Peek 4kb at a time.\n\tcurrentPeekSize := minReaderBufferSize\n\n\tif f.options.AllowPythonMultilineValues {\n\t\tfor {\n\t\t\tpeekBytes, _ := p.buf.Peek(currentPeekSize)\n\t\t\tpeekBytesLength := len(peekBytes)\n\n\t\t\tif parserBufferSize >= peekBytesLength {\n\t\t\t\tbreak\n\t\t\t}\n\n\t\t\tcurrentPeekSize *= 2\n\t\t\tparserBufferSize = peekBytesLength\n\t\t}\n\t}\n\n\tfor !p.isEOF {\n\t\tline, err = p.readUntil('\\n')\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tif f.options.AllowNestedValues &&\n\t\t\tisLastValueEmpty && len(line) > 0 {\n\t\t\tif line[0] == ' ' || line[0] == '\\t' {\n\t\t\t\terr = lastRegularKey.addNestedValue(string(bytes.TrimSpace(line)))\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t\tcontinue\n\t\t\t}\n\t\t}\n\n\t\tline = bytes.TrimLeftFunc(line, unicode.IsSpace)\n\t\tif len(line) == 0 {\n\t\t\tcontinue\n\t\t}\n\n\t\t// Comments\n\t\tif line[0] == '#' || line[0] == ';' {\n\t\t\t// Note: we do not care ending line break,\n\t\t\t// it is needed for adding second line,\n\t\t\t// so just clean it once at the end when set to value.\n\t\t\tp.comment.Write(line)\n\t\t\tcontinue\n\t\t}\n\n\t\t// Section\n\t\tif line[0] == '[' {\n\t\t\t// Read to the next ']' (TODO: support quoted strings)\n\t\t\tcloseIdx := bytes.LastIndexByte(line, ']')\n\t\t\tif closeIdx == -1 {\n\t\t\t\treturn fmt.Errorf(\"unclosed section: %s\", line)\n\t\t\t}\n\n\t\t\tname := string(line[1:closeIdx])\n\t\t\tsection, err = f.NewSection(name)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t\tcomment, has := cleanComment(line[closeIdx+1:])\n\t\t\tif has {\n\t\t\t\tp.comment.Write(comment)\n\t\t\t}\n\n\t\t\tsection.Comment = strings.TrimSpace(p.comment.String())\n\n\t\t\t// Reset auto-counter and comments\n\t\t\tp.comment.Reset()\n\t\t\tp.count = 1\n\t\t\t// Nested values can't span sections\n\t\t\tisLastValueEmpty = false\n\n\t\t\tinUnparseableSection = false\n\t\t\tfor i := range f.options.UnparseableSections {\n\t\t\t\tif f.options.UnparseableSections[i] == name ||\n\t\t\t\t\t((f.options.Insensitive || f.options.InsensitiveSections) && strings.EqualFold(f.options.UnparseableSections[i], name)) {\n\t\t\t\t\tinUnparseableSection = true\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t}\n\t\t\tcontinue\n\t\t}\n\n\t\tif inUnparseableSection {\n\t\t\tsection.isRawSection = true\n\t\t\tsection.rawBody += string(line)\n\t\t\tcontinue\n\t\t}\n\n\t\tkname, offset, err := readKeyName(f.options.KeyValueDelimiters, line)\n\t\tif err != nil {\n\t\t\tswitch {\n\t\t\t// Treat as boolean key when desired, and whole line is key name.\n\t\t\tcase IsErrDelimiterNotFound(err):\n\t\t\t\tswitch {\n\t\t\t\tcase f.options.AllowBooleanKeys:\n\t\t\t\t\tkname, err := p.readValue(line, parserBufferSize)\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\treturn err\n\t\t\t\t\t}\n\t\t\t\t\tkey, err := section.NewBooleanKey(kname)\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\treturn err\n\t\t\t\t\t}\n\t\t\t\t\tkey.Comment = strings.TrimSpace(p.comment.String())\n\t\t\t\t\tp.comment.Reset()\n\t\t\t\t\tcontinue\n\n\t\t\t\tcase f.options.SkipUnrecognizableLines:\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\tcase IsErrEmptyKeyName(err) && f.options.SkipUnrecognizableLines:\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\treturn err\n\t\t}\n\n\t\t// Auto increment.\n\t\tisAutoIncr := false\n\t\tif kname == \"-\" {\n\t\t\tisAutoIncr = true\n\t\t\tkname = \"#\" + strconv.Itoa(p.count)\n\t\t\tp.count++\n\t\t}\n\n\t\tvalue, err := p.readValue(line[offset:], parserBufferSize)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tisLastValueEmpty = len(value) == 0\n\n\t\tkey, err := section.NewKey(kname, value)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tkey.isAutoIncrement = isAutoIncr\n\t\tkey.Comment = strings.TrimSpace(p.comment.String())\n\t\tp.comment.Reset()\n\t\tlastRegularKey = key\n\t}\n\treturn nil\n}\n"
        },
        {
          "name": "parser_test.go",
          "type": "blob",
          "size": 1.8916015625,
          "content": "// Copyright 2016 Unknwon\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"): you may\n// not use this file except in compliance with the License. You may obtain\n// a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n// WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n// License for the specific language governing permissions and limitations\n// under the License.\n\npackage ini\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n\t\"github.com/stretchr/testify/require\"\n)\n\nfunc TestBOM(t *testing.T) {\n\tt.Run(\"test handling BOM\", func(t *testing.T) {\n\t\tt.Run(\"UTF-8-BOM\", func(t *testing.T) {\n\t\t\tf, err := Load(\"testdata/UTF-8-BOM.ini\")\n\t\t\trequire.NoError(t, err)\n\t\t\trequire.NotNil(t, f)\n\n\t\t\tassert.Equal(t, \"example@email.com\", f.Section(\"author\").Key(\"E-MAIL\").String())\n\t\t})\n\n\t\tt.Run(\"UTF-16-LE-BOM\", func(t *testing.T) {\n\t\t\tf, err := Load(\"testdata/UTF-16-LE-BOM.ini\")\n\t\t\trequire.NoError(t, err)\n\t\t\trequire.NotNil(t, f)\n\t\t})\n\n\t\tt.Run(\"UTF-16-BE-BOM\", func(t *testing.T) {\n\t\t})\n\t})\n}\n\nfunc TestBadLoad(t *testing.T) {\n\tt.Run(\"load with bad data\", func(t *testing.T) {\n\t\tt.Run(\"bad section name\", func(t *testing.T) {\n\t\t\t_, err := Load([]byte(\"[]\"))\n\t\t\trequire.Error(t, err)\n\n\t\t\t_, err = Load([]byte(\"[\"))\n\t\t\trequire.Error(t, err)\n\t\t})\n\n\t\tt.Run(\"bad keys\", func(t *testing.T) {\n\t\t\t_, err := Load([]byte(`\"\"\"name`))\n\t\t\trequire.Error(t, err)\n\n\t\t\t_, err = Load([]byte(`\"\"\"name\"\"\"`))\n\t\t\trequire.Error(t, err)\n\n\t\t\t_, err = Load([]byte(`\"\"=1`))\n\t\t\trequire.Error(t, err)\n\n\t\t\t_, err = Load([]byte(`=`))\n\t\t\trequire.Error(t, err)\n\n\t\t\t_, err = Load([]byte(`name`))\n\t\t\trequire.Error(t, err)\n\t\t})\n\n\t\tt.Run(\"bad values\", func(t *testing.T) {\n\t\t\t_, err := Load([]byte(`name=\"\"\"Unknwon`))\n\t\t\trequire.Error(t, err)\n\t\t})\n\t})\n}\n"
        },
        {
          "name": "section.go",
          "type": "blob",
          "size": 5.9169921875,
          "content": "// Copyright 2014 Unknwon\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"): you may\n// not use this file except in compliance with the License. You may obtain\n// a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n// WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n// License for the specific language governing permissions and limitations\n// under the License.\n\npackage ini\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"strings\"\n)\n\n// Section represents a config section.\ntype Section struct {\n\tf        *File\n\tComment  string\n\tname     string\n\tkeys     map[string]*Key\n\tkeyList  []string\n\tkeysHash map[string]string\n\n\tisRawSection bool\n\trawBody      string\n}\n\nfunc newSection(f *File, name string) *Section {\n\treturn &Section{\n\t\tf:        f,\n\t\tname:     name,\n\t\tkeys:     make(map[string]*Key),\n\t\tkeyList:  make([]string, 0, 10),\n\t\tkeysHash: make(map[string]string),\n\t}\n}\n\n// Name returns name of Section.\nfunc (s *Section) Name() string {\n\treturn s.name\n}\n\n// Body returns rawBody of Section if the section was marked as unparseable.\n// It still follows the other rules of the INI format surrounding leading/trailing whitespace.\nfunc (s *Section) Body() string {\n\treturn strings.TrimSpace(s.rawBody)\n}\n\n// SetBody updates body content only if section is raw.\nfunc (s *Section) SetBody(body string) {\n\tif !s.isRawSection {\n\t\treturn\n\t}\n\ts.rawBody = body\n}\n\n// NewKey creates a new key to given section.\nfunc (s *Section) NewKey(name, val string) (*Key, error) {\n\tif len(name) == 0 {\n\t\treturn nil, errors.New(\"error creating new key: empty key name\")\n\t} else if s.f.options.Insensitive || s.f.options.InsensitiveKeys {\n\t\tname = strings.ToLower(name)\n\t}\n\n\tif s.f.BlockMode {\n\t\ts.f.lock.Lock()\n\t\tdefer s.f.lock.Unlock()\n\t}\n\n\tif inSlice(name, s.keyList) {\n\t\tif s.f.options.AllowShadows {\n\t\t\tif err := s.keys[name].addShadow(val); err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t} else {\n\t\t\ts.keys[name].value = val\n\t\t\ts.keysHash[name] = val\n\t\t}\n\t\treturn s.keys[name], nil\n\t}\n\n\ts.keyList = append(s.keyList, name)\n\ts.keys[name] = newKey(s, name, val)\n\ts.keysHash[name] = val\n\treturn s.keys[name], nil\n}\n\n// NewBooleanKey creates a new boolean type key to given section.\nfunc (s *Section) NewBooleanKey(name string) (*Key, error) {\n\tkey, err := s.NewKey(name, \"true\")\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tkey.isBooleanType = true\n\treturn key, nil\n}\n\n// GetKey returns key in section by given name.\nfunc (s *Section) GetKey(name string) (*Key, error) {\n\tif s.f.BlockMode {\n\t\ts.f.lock.RLock()\n\t}\n\tif s.f.options.Insensitive || s.f.options.InsensitiveKeys {\n\t\tname = strings.ToLower(name)\n\t}\n\tkey := s.keys[name]\n\tif s.f.BlockMode {\n\t\ts.f.lock.RUnlock()\n\t}\n\n\tif key == nil {\n\t\t// Check if it is a child-section.\n\t\tsname := s.name\n\t\tfor {\n\t\t\tif i := strings.LastIndex(sname, s.f.options.ChildSectionDelimiter); i > -1 {\n\t\t\t\tsname = sname[:i]\n\t\t\t\tsec, err := s.f.GetSection(sname)\n\t\t\t\tif err != nil {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\treturn sec.GetKey(name)\n\t\t\t}\n\t\t\tbreak\n\t\t}\n\t\treturn nil, fmt.Errorf(\"error when getting key of section %q: key %q not exists\", s.name, name)\n\t}\n\treturn key, nil\n}\n\n// HasKey returns true if section contains a key with given name.\nfunc (s *Section) HasKey(name string) bool {\n\tkey, _ := s.GetKey(name)\n\treturn key != nil\n}\n\n// Deprecated: Use \"HasKey\" instead.\nfunc (s *Section) Haskey(name string) bool {\n\treturn s.HasKey(name)\n}\n\n// HasValue returns true if section contains given raw value.\nfunc (s *Section) HasValue(value string) bool {\n\tif s.f.BlockMode {\n\t\ts.f.lock.RLock()\n\t\tdefer s.f.lock.RUnlock()\n\t}\n\n\tfor _, k := range s.keys {\n\t\tif value == k.value {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\n// Key assumes named Key exists in section and returns a zero-value when not.\nfunc (s *Section) Key(name string) *Key {\n\tkey, err := s.GetKey(name)\n\tif err != nil {\n\t\t// It's OK here because the only possible error is empty key name,\n\t\t// but if it's empty, this piece of code won't be executed.\n\t\tkey, _ = s.NewKey(name, \"\")\n\t\treturn key\n\t}\n\treturn key\n}\n\n// Keys returns list of keys of section.\nfunc (s *Section) Keys() []*Key {\n\tkeys := make([]*Key, len(s.keyList))\n\tfor i := range s.keyList {\n\t\tkeys[i] = s.Key(s.keyList[i])\n\t}\n\treturn keys\n}\n\n// ParentKeys returns list of keys of parent section.\nfunc (s *Section) ParentKeys() []*Key {\n\tvar parentKeys []*Key\n\tsname := s.name\n\tfor {\n\t\tif i := strings.LastIndex(sname, s.f.options.ChildSectionDelimiter); i > -1 {\n\t\t\tsname = sname[:i]\n\t\t\tsec, err := s.f.GetSection(sname)\n\t\t\tif err != nil {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tparentKeys = append(parentKeys, sec.Keys()...)\n\t\t} else {\n\t\t\tbreak\n\t\t}\n\n\t}\n\treturn parentKeys\n}\n\n// KeyStrings returns list of key names of section.\nfunc (s *Section) KeyStrings() []string {\n\tlist := make([]string, len(s.keyList))\n\tcopy(list, s.keyList)\n\treturn list\n}\n\n// KeysHash returns keys hash consisting of names and values.\nfunc (s *Section) KeysHash() map[string]string {\n\tif s.f.BlockMode {\n\t\ts.f.lock.RLock()\n\t\tdefer s.f.lock.RUnlock()\n\t}\n\n\thash := make(map[string]string, len(s.keysHash))\n\tfor key, value := range s.keysHash {\n\t\thash[key] = value\n\t}\n\treturn hash\n}\n\n// DeleteKey deletes a key from section.\nfunc (s *Section) DeleteKey(name string) {\n\tif s.f.BlockMode {\n\t\ts.f.lock.Lock()\n\t\tdefer s.f.lock.Unlock()\n\t}\n\n\tfor i, k := range s.keyList {\n\t\tif k == name {\n\t\t\ts.keyList = append(s.keyList[:i], s.keyList[i+1:]...)\n\t\t\tdelete(s.keys, name)\n\t\t\tdelete(s.keysHash, name)\n\t\t\treturn\n\t\t}\n\t}\n}\n\n// ChildSections returns a list of child sections of current section.\n// For example, \"[parent.child1]\" and \"[parent.child12]\" are child sections\n// of section \"[parent]\".\nfunc (s *Section) ChildSections() []*Section {\n\tprefix := s.name + s.f.options.ChildSectionDelimiter\n\tchildren := make([]*Section, 0, 3)\n\tfor _, name := range s.f.sectionList {\n\t\tif strings.HasPrefix(name, prefix) {\n\t\t\tchildren = append(children, s.f.sections[name]...)\n\t\t}\n\t}\n\treturn children\n}\n"
        },
        {
          "name": "section_test.go",
          "type": "blob",
          "size": 8.0927734375,
          "content": "// Copyright 2014 Unknwon\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"): you may\n// not use this file except in compliance with the License. You may obtain\n// a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n// WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n// License for the specific language governing permissions and limitations\n// under the License.\n\npackage ini\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n\t\"github.com/stretchr/testify/require\"\n)\n\nfunc TestSection_SetBody(t *testing.T) {\n\tt.Run(\"set body of raw section\", func(t *testing.T) {\n\t\tf := Empty()\n\t\trequire.NotNil(t, f)\n\n\t\tsec, err := f.NewRawSection(\"comments\", `1111111111111111111000000000000000001110000\n111111111111111111100000000000111000000000`)\n\t\trequire.NoError(t, err)\n\t\trequire.NotNil(t, sec)\n\t\tassert.Equal(t, `1111111111111111111000000000000000001110000\n111111111111111111100000000000111000000000`, sec.Body())\n\n\t\tsec.SetBody(\"1111111111111111111000000000000000001110000\")\n\t\tassert.Equal(t, `1111111111111111111000000000000000001110000`, sec.Body())\n\n\t\tt.Run(\"set for non-raw section\", func(t *testing.T) {\n\t\t\tsec, err := f.NewSection(\"author\")\n\t\t\trequire.NoError(t, err)\n\t\t\trequire.NotNil(t, sec)\n\t\t\tassert.Empty(t, sec.Body())\n\n\t\t\tsec.SetBody(\"1111111111111111111000000000000000001110000\")\n\t\t\tassert.Empty(t, sec.Body())\n\t\t})\n\t})\n}\n\nfunc TestSection_NewKey(t *testing.T) {\n\tt.Run(\"create a new key\", func(t *testing.T) {\n\t\tf := Empty()\n\t\trequire.NotNil(t, f)\n\n\t\tk, err := f.Section(\"\").NewKey(\"NAME\", \"ini\")\n\t\trequire.NoError(t, err)\n\t\trequire.NotNil(t, k)\n\t\tassert.Equal(t, \"NAME\", k.Name())\n\t\tassert.Equal(t, \"ini\", k.Value())\n\n\t\tt.Run(\"with duplicated name\", func(t *testing.T) {\n\t\t\tk, err := f.Section(\"\").NewKey(\"NAME\", \"ini.v1\")\n\t\t\trequire.NoError(t, err)\n\t\t\trequire.NotNil(t, k)\n\n\t\t\t// Overwrite previous existed key\n\t\t\tassert.Equal(t, \"ini.v1\", k.Value())\n\t\t})\n\n\t\tt.Run(\"with empty string\", func(t *testing.T) {\n\t\t\t_, err := f.Section(\"\").NewKey(\"\", \"\")\n\t\t\trequire.Error(t, err)\n\t\t})\n\t})\n\n\tt.Run(\"create keys with same name and allow shadow\", func(t *testing.T) {\n\t\tf, err := ShadowLoad([]byte(\"\"))\n\t\trequire.NoError(t, err)\n\t\trequire.NotNil(t, f)\n\n\t\tk, err := f.Section(\"\").NewKey(\"NAME\", \"ini\")\n\t\trequire.NoError(t, err)\n\t\trequire.NotNil(t, k)\n\t\tk, err = f.Section(\"\").NewKey(\"NAME\", \"ini.v1\")\n\t\trequire.NoError(t, err)\n\t\trequire.NotNil(t, k)\n\n\t\tassert.Equal(t, []string{\"ini\", \"ini.v1\"}, k.ValueWithShadows())\n\t})\n}\n\nfunc TestSection_NewBooleanKey(t *testing.T) {\n\tt.Run(\"create a new boolean key\", func(t *testing.T) {\n\t\tf := Empty()\n\t\trequire.NotNil(t, f)\n\n\t\tk, err := f.Section(\"\").NewBooleanKey(\"start-ssh-server\")\n\t\trequire.NoError(t, err)\n\t\trequire.NotNil(t, k)\n\t\tassert.Equal(t, \"start-ssh-server\", k.Name())\n\t\tassert.Equal(t, \"true\", k.Value())\n\n\t\tt.Run(\"with empty string\", func(t *testing.T) {\n\t\t\t_, err := f.Section(\"\").NewBooleanKey(\"\")\n\t\t\trequire.Error(t, err)\n\t\t})\n\t})\n}\n\nfunc TestSection_GetKey(t *testing.T) {\n\tt.Run(\"get a key\", func(t *testing.T) {\n\t\tf := Empty()\n\t\trequire.NotNil(t, f)\n\n\t\tk, err := f.Section(\"\").NewKey(\"NAME\", \"ini\")\n\t\trequire.NoError(t, err)\n\t\trequire.NotNil(t, k)\n\n\t\tk, err = f.Section(\"\").GetKey(\"NAME\")\n\t\trequire.NoError(t, err)\n\t\trequire.NotNil(t, k)\n\t\tassert.Equal(t, \"NAME\", k.Name())\n\t\tassert.Equal(t, \"ini\", k.Value())\n\n\t\tt.Run(\"key not exists\", func(t *testing.T) {\n\t\t\t_, err := f.Section(\"\").GetKey(\"404\")\n\t\t\trequire.Error(t, err)\n\t\t})\n\n\t\tt.Run(\"key exists in parent section\", func(t *testing.T) {\n\t\t\tk, err := f.Section(\"parent\").NewKey(\"AGE\", \"18\")\n\t\t\trequire.NoError(t, err)\n\t\t\trequire.NotNil(t, k)\n\n\t\t\tk, err = f.Section(\"parent.child.son\").GetKey(\"AGE\")\n\t\t\trequire.NoError(t, err)\n\t\t\trequire.NotNil(t, k)\n\t\t\tassert.Equal(t, \"18\", k.Value())\n\t\t})\n\t})\n}\n\nfunc TestSection_HasKey(t *testing.T) {\n\tt.Run(\"check if a key exists\", func(t *testing.T) {\n\t\tf := Empty()\n\t\trequire.NotNil(t, f)\n\n\t\tk, err := f.Section(\"\").NewKey(\"NAME\", \"ini\")\n\t\trequire.NoError(t, err)\n\t\trequire.NotNil(t, k)\n\n\t\tassert.True(t, f.Section(\"\").HasKey(\"NAME\"))\n\t\tassert.True(t, f.Section(\"\").HasKey(\"NAME\"))\n\t\tassert.False(t, f.Section(\"\").HasKey(\"404\"))\n\t\tassert.False(t, f.Section(\"\").HasKey(\"404\"))\n\t})\n}\n\nfunc TestSection_HasValue(t *testing.T) {\n\tt.Run(\"check if contains a value in any key\", func(t *testing.T) {\n\t\tf := Empty()\n\t\trequire.NotNil(t, f)\n\n\t\tk, err := f.Section(\"\").NewKey(\"NAME\", \"ini\")\n\t\trequire.NoError(t, err)\n\t\trequire.NotNil(t, k)\n\n\t\tassert.True(t, f.Section(\"\").HasValue(\"ini\"))\n\t\tassert.False(t, f.Section(\"\").HasValue(\"404\"))\n\t})\n}\n\nfunc TestSection_Key(t *testing.T) {\n\tt.Run(\"get a key\", func(t *testing.T) {\n\t\tf := Empty()\n\t\trequire.NotNil(t, f)\n\n\t\tk, err := f.Section(\"\").NewKey(\"NAME\", \"ini\")\n\t\trequire.NoError(t, err)\n\t\trequire.NotNil(t, k)\n\n\t\tk = f.Section(\"\").Key(\"NAME\")\n\t\trequire.NotNil(t, k)\n\t\tassert.Equal(t, \"NAME\", k.Name())\n\t\tassert.Equal(t, \"ini\", k.Value())\n\n\t\tt.Run(\"key not exists\", func(t *testing.T) {\n\t\t\tk := f.Section(\"\").Key(\"404\")\n\t\t\trequire.NotNil(t, k)\n\t\t\tassert.Equal(t, \"404\", k.Name())\n\t\t})\n\n\t\tt.Run(\"key exists in parent section\", func(t *testing.T) {\n\t\t\tk, err := f.Section(\"parent\").NewKey(\"AGE\", \"18\")\n\t\t\trequire.NoError(t, err)\n\t\t\trequire.NotNil(t, k)\n\n\t\t\tk = f.Section(\"parent.child.son\").Key(\"AGE\")\n\t\t\trequire.NotNil(t, k)\n\t\t\tassert.Equal(t, \"18\", k.Value())\n\t\t})\n\t})\n}\n\nfunc TestSection_Keys(t *testing.T) {\n\tt.Run(\"get all keys in a section\", func(t *testing.T) {\n\t\tf := Empty()\n\t\trequire.NotNil(t, f)\n\n\t\tk, err := f.Section(\"\").NewKey(\"NAME\", \"ini\")\n\t\trequire.NoError(t, err)\n\t\trequire.NotNil(t, k)\n\t\tk, err = f.Section(\"\").NewKey(\"VERSION\", \"v1\")\n\t\trequire.NoError(t, err)\n\t\trequire.NotNil(t, k)\n\t\tk, err = f.Section(\"\").NewKey(\"IMPORT_PATH\", \"gopkg.in/ini.v1\")\n\t\trequire.NoError(t, err)\n\t\trequire.NotNil(t, k)\n\n\t\tkeys := f.Section(\"\").Keys()\n\t\tnames := []string{\"NAME\", \"VERSION\", \"IMPORT_PATH\"}\n\t\tassert.Equal(t, len(names), len(keys))\n\t\tfor i, name := range names {\n\t\t\tassert.Equal(t, name, keys[i].Name())\n\t\t}\n\t})\n}\n\nfunc TestSection_ParentKeys(t *testing.T) {\n\tt.Run(\"get all keys of parent sections\", func(t *testing.T) {\n\t\tf := Empty()\n\t\trequire.NotNil(t, f)\n\n\t\tk, err := f.Section(\"package\").NewKey(\"NAME\", \"ini\")\n\t\trequire.NoError(t, err)\n\t\trequire.NotNil(t, k)\n\t\tk, err = f.Section(\"package\").NewKey(\"VERSION\", \"v1\")\n\t\trequire.NoError(t, err)\n\t\trequire.NotNil(t, k)\n\t\tk, err = f.Section(\"package\").NewKey(\"IMPORT_PATH\", \"gopkg.in/ini.v1\")\n\t\trequire.NoError(t, err)\n\t\trequire.NotNil(t, k)\n\n\t\tkeys := f.Section(\"package.sub.sub2\").ParentKeys()\n\t\tnames := []string{\"NAME\", \"VERSION\", \"IMPORT_PATH\"}\n\t\tassert.Equal(t, len(names), len(keys))\n\t\tfor i, name := range names {\n\t\t\tassert.Equal(t, name, keys[i].Name())\n\t\t}\n\t})\n}\n\nfunc TestSection_KeyStrings(t *testing.T) {\n\tt.Run(\"get all key names in a section\", func(t *testing.T) {\n\t\tf := Empty()\n\t\trequire.NotNil(t, f)\n\n\t\tk, err := f.Section(\"\").NewKey(\"NAME\", \"ini\")\n\t\trequire.NoError(t, err)\n\t\trequire.NotNil(t, k)\n\t\tk, err = f.Section(\"\").NewKey(\"VERSION\", \"v1\")\n\t\trequire.NoError(t, err)\n\t\trequire.NotNil(t, k)\n\t\tk, err = f.Section(\"\").NewKey(\"IMPORT_PATH\", \"gopkg.in/ini.v1\")\n\t\trequire.NoError(t, err)\n\t\trequire.NotNil(t, k)\n\n\t\tassert.Equal(t, []string{\"NAME\", \"VERSION\", \"IMPORT_PATH\"}, f.Section(\"\").KeyStrings())\n\t})\n}\n\nfunc TestSection_KeyHash(t *testing.T) {\n\tt.Run(\"get clone of key hash\", func(t *testing.T) {\n\t\tf, err := Load([]byte(`\nkey = one\n[log]\nname = app\nfile = a.log\n`), []byte(`\nkey = two\n[log]\nname = app2\nfile = b.log\n`))\n\t\trequire.NoError(t, err)\n\t\trequire.NotNil(t, f)\n\n\t\tassert.Equal(t, \"two\", f.Section(\"\").Key(\"key\").String())\n\n\t\thash := f.Section(\"log\").KeysHash()\n\t\trelation := map[string]string{\n\t\t\t\"name\": \"app2\",\n\t\t\t\"file\": \"b.log\",\n\t\t}\n\t\tfor k, v := range hash {\n\t\t\tassert.Equal(t, relation[k], v)\n\t\t}\n\t})\n}\n\nfunc TestSection_DeleteKey(t *testing.T) {\n\tt.Run(\"delete a key\", func(t *testing.T) {\n\t\tf := Empty()\n\t\trequire.NotNil(t, f)\n\n\t\tk, err := f.Section(\"\").NewKey(\"NAME\", \"ini\")\n\t\trequire.NoError(t, err)\n\t\trequire.NotNil(t, k)\n\n\t\tassert.True(t, f.Section(\"\").HasKey(\"NAME\"))\n\t\tf.Section(\"\").DeleteKey(\"NAME\")\n\t\tassert.False(t, f.Section(\"\").HasKey(\"NAME\"))\n\t})\n}\n"
        },
        {
          "name": "struct.go",
          "type": "blob",
          "size": 20.7021484375,
          "content": "// Copyright 2014 Unknwon\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"): you may\n// not use this file except in compliance with the License. You may obtain\n// a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n// WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n// License for the specific language governing permissions and limitations\n// under the License.\n\npackage ini\n\nimport (\n\t\"bytes\"\n\t\"errors\"\n\t\"fmt\"\n\t\"reflect\"\n\t\"strings\"\n\t\"time\"\n\t\"unicode\"\n)\n\n// NameMapper represents a ini tag name mapper.\ntype NameMapper func(string) string\n\n// Built-in name getters.\nvar (\n\t// SnackCase converts to format SNACK_CASE.\n\tSnackCase NameMapper = func(raw string) string {\n\t\tnewstr := make([]rune, 0, len(raw))\n\t\tfor i, chr := range raw {\n\t\t\tif isUpper := 'A' <= chr && chr <= 'Z'; isUpper {\n\t\t\t\tif i > 0 {\n\t\t\t\t\tnewstr = append(newstr, '_')\n\t\t\t\t}\n\t\t\t}\n\t\t\tnewstr = append(newstr, unicode.ToUpper(chr))\n\t\t}\n\t\treturn string(newstr)\n\t}\n\t// TitleUnderscore converts to format title_underscore.\n\tTitleUnderscore NameMapper = func(raw string) string {\n\t\tnewstr := make([]rune, 0, len(raw))\n\t\tfor i, chr := range raw {\n\t\t\tif isUpper := 'A' <= chr && chr <= 'Z'; isUpper {\n\t\t\t\tif i > 0 {\n\t\t\t\t\tnewstr = append(newstr, '_')\n\t\t\t\t}\n\t\t\t\tchr -= 'A' - 'a'\n\t\t\t}\n\t\t\tnewstr = append(newstr, chr)\n\t\t}\n\t\treturn string(newstr)\n\t}\n)\n\nfunc (s *Section) parseFieldName(raw, actual string) string {\n\tif len(actual) > 0 {\n\t\treturn actual\n\t}\n\tif s.f.NameMapper != nil {\n\t\treturn s.f.NameMapper(raw)\n\t}\n\treturn raw\n}\n\nfunc parseDelim(actual string) string {\n\tif len(actual) > 0 {\n\t\treturn actual\n\t}\n\treturn \",\"\n}\n\nvar reflectTime = reflect.TypeOf(time.Now()).Kind()\n\n// setSliceWithProperType sets proper values to slice based on its type.\nfunc setSliceWithProperType(key *Key, field reflect.Value, delim string, allowShadow, isStrict bool) error {\n\tvar strs []string\n\tif allowShadow {\n\t\tstrs = key.StringsWithShadows(delim)\n\t} else {\n\t\tstrs = key.Strings(delim)\n\t}\n\n\tnumVals := len(strs)\n\tif numVals == 0 {\n\t\treturn nil\n\t}\n\n\tvar vals interface{}\n\tvar err error\n\n\tsliceOf := field.Type().Elem().Kind()\n\tswitch sliceOf {\n\tcase reflect.String:\n\t\tvals = strs\n\tcase reflect.Int:\n\t\tvals, err = key.parseInts(strs, true, false)\n\tcase reflect.Int64:\n\t\tvals, err = key.parseInt64s(strs, true, false)\n\tcase reflect.Uint:\n\t\tvals, err = key.parseUints(strs, true, false)\n\tcase reflect.Uint64:\n\t\tvals, err = key.parseUint64s(strs, true, false)\n\tcase reflect.Float64:\n\t\tvals, err = key.parseFloat64s(strs, true, false)\n\tcase reflect.Bool:\n\t\tvals, err = key.parseBools(strs, true, false)\n\tcase reflectTime:\n\t\tvals, err = key.parseTimesFormat(time.RFC3339, strs, true, false)\n\tdefault:\n\t\treturn fmt.Errorf(\"unsupported type '[]%s'\", sliceOf)\n\t}\n\tif err != nil && isStrict {\n\t\treturn err\n\t}\n\n\tslice := reflect.MakeSlice(field.Type(), numVals, numVals)\n\tfor i := 0; i < numVals; i++ {\n\t\tswitch sliceOf {\n\t\tcase reflect.String:\n\t\t\tslice.Index(i).Set(reflect.ValueOf(vals.([]string)[i]))\n\t\tcase reflect.Int:\n\t\t\tslice.Index(i).Set(reflect.ValueOf(vals.([]int)[i]))\n\t\tcase reflect.Int64:\n\t\t\tslice.Index(i).Set(reflect.ValueOf(vals.([]int64)[i]))\n\t\tcase reflect.Uint:\n\t\t\tslice.Index(i).Set(reflect.ValueOf(vals.([]uint)[i]))\n\t\tcase reflect.Uint64:\n\t\t\tslice.Index(i).Set(reflect.ValueOf(vals.([]uint64)[i]))\n\t\tcase reflect.Float64:\n\t\t\tslice.Index(i).Set(reflect.ValueOf(vals.([]float64)[i]))\n\t\tcase reflect.Bool:\n\t\t\tslice.Index(i).Set(reflect.ValueOf(vals.([]bool)[i]))\n\t\tcase reflectTime:\n\t\t\tslice.Index(i).Set(reflect.ValueOf(vals.([]time.Time)[i]))\n\t\t}\n\t}\n\tfield.Set(slice)\n\treturn nil\n}\n\nfunc wrapStrictError(err error, isStrict bool) error {\n\tif isStrict {\n\t\treturn err\n\t}\n\treturn nil\n}\n\n// setWithProperType sets proper value to field based on its type,\n// but it does not return error for failing parsing,\n// because we want to use default value that is already assigned to struct.\nfunc setWithProperType(t reflect.Type, key *Key, field reflect.Value, delim string, allowShadow, isStrict bool) error {\n\tvt := t\n\tisPtr := t.Kind() == reflect.Ptr\n\tif isPtr {\n\t\tvt = t.Elem()\n\t}\n\tswitch vt.Kind() {\n\tcase reflect.String:\n\t\tstringVal := key.String()\n\t\tif isPtr {\n\t\t\tfield.Set(reflect.ValueOf(&stringVal))\n\t\t} else if len(stringVal) > 0 {\n\t\t\tfield.SetString(key.String())\n\t\t}\n\tcase reflect.Bool:\n\t\tboolVal, err := key.Bool()\n\t\tif err != nil {\n\t\t\treturn wrapStrictError(err, isStrict)\n\t\t}\n\t\tif isPtr {\n\t\t\tfield.Set(reflect.ValueOf(&boolVal))\n\t\t} else {\n\t\t\tfield.SetBool(boolVal)\n\t\t}\n\tcase reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:\n\t\t// ParseDuration will not return err for `0`, so check the type name\n\t\tif vt.Name() == \"Duration\" {\n\t\t\tdurationVal, err := key.Duration()\n\t\t\tif err != nil {\n\t\t\t\tif intVal, err := key.Int64(); err == nil {\n\t\t\t\t\tfield.SetInt(intVal)\n\t\t\t\t\treturn nil\n\t\t\t\t}\n\t\t\t\treturn wrapStrictError(err, isStrict)\n\t\t\t}\n\t\t\tif isPtr {\n\t\t\t\tfield.Set(reflect.ValueOf(&durationVal))\n\t\t\t} else if int64(durationVal) > 0 {\n\t\t\t\tfield.Set(reflect.ValueOf(durationVal))\n\t\t\t}\n\t\t\treturn nil\n\t\t}\n\n\t\tintVal, err := key.Int64()\n\t\tif err != nil {\n\t\t\treturn wrapStrictError(err, isStrict)\n\t\t}\n\t\tif isPtr {\n\t\t\tpv := reflect.New(t.Elem())\n\t\t\tpv.Elem().SetInt(intVal)\n\t\t\tfield.Set(pv)\n\t\t} else {\n\t\t\tfield.SetInt(intVal)\n\t\t}\n\t//\tbyte is an alias for uint8, so supporting uint8 breaks support for byte\n\tcase reflect.Uint, reflect.Uint16, reflect.Uint32, reflect.Uint64:\n\t\tdurationVal, err := key.Duration()\n\t\t// Skip zero value\n\t\tif err == nil && uint64(durationVal) > 0 {\n\t\t\tif isPtr {\n\t\t\t\tfield.Set(reflect.ValueOf(&durationVal))\n\t\t\t} else {\n\t\t\t\tfield.Set(reflect.ValueOf(durationVal))\n\t\t\t}\n\t\t\treturn nil\n\t\t}\n\n\t\tuintVal, err := key.Uint64()\n\t\tif err != nil {\n\t\t\treturn wrapStrictError(err, isStrict)\n\t\t}\n\t\tif isPtr {\n\t\t\tpv := reflect.New(t.Elem())\n\t\t\tpv.Elem().SetUint(uintVal)\n\t\t\tfield.Set(pv)\n\t\t} else {\n\t\t\tfield.SetUint(uintVal)\n\t\t}\n\n\tcase reflect.Float32, reflect.Float64:\n\t\tfloatVal, err := key.Float64()\n\t\tif err != nil {\n\t\t\treturn wrapStrictError(err, isStrict)\n\t\t}\n\t\tif isPtr {\n\t\t\tpv := reflect.New(t.Elem())\n\t\t\tpv.Elem().SetFloat(floatVal)\n\t\t\tfield.Set(pv)\n\t\t} else {\n\t\t\tfield.SetFloat(floatVal)\n\t\t}\n\tcase reflectTime:\n\t\ttimeVal, err := key.Time()\n\t\tif err != nil {\n\t\t\treturn wrapStrictError(err, isStrict)\n\t\t}\n\t\tif isPtr {\n\t\t\tfield.Set(reflect.ValueOf(&timeVal))\n\t\t} else {\n\t\t\tfield.Set(reflect.ValueOf(timeVal))\n\t\t}\n\tcase reflect.Slice:\n\t\treturn setSliceWithProperType(key, field, delim, allowShadow, isStrict)\n\tdefault:\n\t\treturn fmt.Errorf(\"unsupported type %q\", t)\n\t}\n\treturn nil\n}\n\nfunc parseTagOptions(tag string) (rawName string, omitEmpty bool, allowShadow bool, allowNonUnique bool, extends bool) {\n\topts := strings.SplitN(tag, \",\", 5)\n\trawName = opts[0]\n\tfor _, opt := range opts[1:] {\n\t\tomitEmpty = omitEmpty || (opt == \"omitempty\")\n\t\tallowShadow = allowShadow || (opt == \"allowshadow\")\n\t\tallowNonUnique = allowNonUnique || (opt == \"nonunique\")\n\t\textends = extends || (opt == \"extends\")\n\t}\n\treturn rawName, omitEmpty, allowShadow, allowNonUnique, extends\n}\n\n// mapToField maps the given value to the matching field of the given section.\n// The sectionIndex is the index (if non unique sections are enabled) to which the value should be added.\nfunc (s *Section) mapToField(val reflect.Value, isStrict bool, sectionIndex int, sectionName string) error {\n\tif val.Kind() == reflect.Ptr {\n\t\tval = val.Elem()\n\t}\n\ttyp := val.Type()\n\n\tfor i := 0; i < typ.NumField(); i++ {\n\t\tfield := val.Field(i)\n\t\ttpField := typ.Field(i)\n\n\t\ttag := tpField.Tag.Get(\"ini\")\n\t\tif tag == \"-\" {\n\t\t\tcontinue\n\t\t}\n\n\t\trawName, _, allowShadow, allowNonUnique, extends := parseTagOptions(tag)\n\t\tfieldName := s.parseFieldName(tpField.Name, rawName)\n\t\tif len(fieldName) == 0 || !field.CanSet() {\n\t\t\tcontinue\n\t\t}\n\n\t\tisStruct := tpField.Type.Kind() == reflect.Struct\n\t\tisStructPtr := tpField.Type.Kind() == reflect.Ptr && tpField.Type.Elem().Kind() == reflect.Struct\n\t\tisAnonymousPtr := tpField.Type.Kind() == reflect.Ptr && tpField.Anonymous\n\t\tif isAnonymousPtr {\n\t\t\tfield.Set(reflect.New(tpField.Type.Elem()))\n\t\t}\n\n\t\tif extends && (isAnonymousPtr || (isStruct && tpField.Anonymous)) {\n\t\t\tif isStructPtr && field.IsNil() {\n\t\t\t\tfield.Set(reflect.New(tpField.Type.Elem()))\n\t\t\t}\n\t\t\tfieldSection := s\n\t\t\tif rawName != \"\" {\n\t\t\t\tsectionName = s.name + s.f.options.ChildSectionDelimiter + rawName\n\t\t\t\tif secs, err := s.f.SectionsByName(sectionName); err == nil && sectionIndex < len(secs) {\n\t\t\t\t\tfieldSection = secs[sectionIndex]\n\t\t\t\t}\n\t\t\t}\n\t\t\tif err := fieldSection.mapToField(field, isStrict, sectionIndex, sectionName); err != nil {\n\t\t\t\treturn fmt.Errorf(\"map to field %q: %v\", fieldName, err)\n\t\t\t}\n\t\t} else if isAnonymousPtr || isStruct || isStructPtr {\n\t\t\tif secs, err := s.f.SectionsByName(fieldName); err == nil {\n\t\t\t\tif len(secs) <= sectionIndex {\n\t\t\t\t\treturn fmt.Errorf(\"there are not enough sections (%d <= %d) for the field %q\", len(secs), sectionIndex, fieldName)\n\t\t\t\t}\n\t\t\t\t// Only set the field to non-nil struct value if we have a section for it.\n\t\t\t\t// Otherwise, we end up with a non-nil struct ptr even though there is no data.\n\t\t\t\tif isStructPtr && field.IsNil() {\n\t\t\t\t\tfield.Set(reflect.New(tpField.Type.Elem()))\n\t\t\t\t}\n\t\t\t\tif err = secs[sectionIndex].mapToField(field, isStrict, sectionIndex, fieldName); err != nil {\n\t\t\t\t\treturn fmt.Errorf(\"map to field %q: %v\", fieldName, err)\n\t\t\t\t}\n\t\t\t\tcontinue\n\t\t\t}\n\t\t}\n\n\t\t// Map non-unique sections\n\t\tif allowNonUnique && tpField.Type.Kind() == reflect.Slice {\n\t\t\tnewField, err := s.mapToSlice(fieldName, field, isStrict)\n\t\t\tif err != nil {\n\t\t\t\treturn fmt.Errorf(\"map to slice %q: %v\", fieldName, err)\n\t\t\t}\n\n\t\t\tfield.Set(newField)\n\t\t\tcontinue\n\t\t}\n\n\t\tif key, err := s.GetKey(fieldName); err == nil {\n\t\t\tdelim := parseDelim(tpField.Tag.Get(\"delim\"))\n\t\t\tif err = setWithProperType(tpField.Type, key, field, delim, allowShadow, isStrict); err != nil {\n\t\t\t\treturn fmt.Errorf(\"set field %q: %v\", fieldName, err)\n\t\t\t}\n\t\t}\n\t}\n\treturn nil\n}\n\n// mapToSlice maps all sections with the same name and returns the new value.\n// The type of the Value must be a slice.\nfunc (s *Section) mapToSlice(secName string, val reflect.Value, isStrict bool) (reflect.Value, error) {\n\tsecs, err := s.f.SectionsByName(secName)\n\tif err != nil {\n\t\treturn reflect.Value{}, err\n\t}\n\n\ttyp := val.Type().Elem()\n\tfor i, sec := range secs {\n\t\telem := reflect.New(typ)\n\t\tif err = sec.mapToField(elem, isStrict, i, sec.name); err != nil {\n\t\t\treturn reflect.Value{}, fmt.Errorf(\"map to field from section %q: %v\", secName, err)\n\t\t}\n\n\t\tval = reflect.Append(val, elem.Elem())\n\t}\n\treturn val, nil\n}\n\n// mapTo maps a section to object v.\nfunc (s *Section) mapTo(v interface{}, isStrict bool) error {\n\ttyp := reflect.TypeOf(v)\n\tval := reflect.ValueOf(v)\n\tif typ.Kind() == reflect.Ptr {\n\t\ttyp = typ.Elem()\n\t\tval = val.Elem()\n\t} else {\n\t\treturn errors.New(\"not a pointer to a struct\")\n\t}\n\n\tif typ.Kind() == reflect.Slice {\n\t\tnewField, err := s.mapToSlice(s.name, val, isStrict)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tval.Set(newField)\n\t\treturn nil\n\t}\n\n\treturn s.mapToField(val, isStrict, 0, s.name)\n}\n\n// MapTo maps section to given struct.\nfunc (s *Section) MapTo(v interface{}) error {\n\treturn s.mapTo(v, false)\n}\n\n// StrictMapTo maps section to given struct in strict mode,\n// which returns all possible error including value parsing error.\nfunc (s *Section) StrictMapTo(v interface{}) error {\n\treturn s.mapTo(v, true)\n}\n\n// MapTo maps file to given struct.\nfunc (f *File) MapTo(v interface{}) error {\n\treturn f.Section(\"\").MapTo(v)\n}\n\n// StrictMapTo maps file to given struct in strict mode,\n// which returns all possible error including value parsing error.\nfunc (f *File) StrictMapTo(v interface{}) error {\n\treturn f.Section(\"\").StrictMapTo(v)\n}\n\n// MapToWithMapper maps data sources to given struct with name mapper.\nfunc MapToWithMapper(v interface{}, mapper NameMapper, source interface{}, others ...interface{}) error {\n\tcfg, err := Load(source, others...)\n\tif err != nil {\n\t\treturn err\n\t}\n\tcfg.NameMapper = mapper\n\treturn cfg.MapTo(v)\n}\n\n// StrictMapToWithMapper maps data sources to given struct with name mapper in strict mode,\n// which returns all possible error including value parsing error.\nfunc StrictMapToWithMapper(v interface{}, mapper NameMapper, source interface{}, others ...interface{}) error {\n\tcfg, err := Load(source, others...)\n\tif err != nil {\n\t\treturn err\n\t}\n\tcfg.NameMapper = mapper\n\treturn cfg.StrictMapTo(v)\n}\n\n// MapTo maps data sources to given struct.\nfunc MapTo(v, source interface{}, others ...interface{}) error {\n\treturn MapToWithMapper(v, nil, source, others...)\n}\n\n// StrictMapTo maps data sources to given struct in strict mode,\n// which returns all possible error including value parsing error.\nfunc StrictMapTo(v, source interface{}, others ...interface{}) error {\n\treturn StrictMapToWithMapper(v, nil, source, others...)\n}\n\n// reflectSliceWithProperType does the opposite thing as setSliceWithProperType.\nfunc reflectSliceWithProperType(key *Key, field reflect.Value, delim string, allowShadow bool) error {\n\tslice := field.Slice(0, field.Len())\n\tif field.Len() == 0 {\n\t\treturn nil\n\t}\n\tsliceOf := field.Type().Elem().Kind()\n\n\tif allowShadow {\n\t\tvar keyWithShadows *Key\n\t\tfor i := 0; i < field.Len(); i++ {\n\t\t\tvar val string\n\t\t\tswitch sliceOf {\n\t\t\tcase reflect.String:\n\t\t\t\tval = slice.Index(i).String()\n\t\t\tcase reflect.Int, reflect.Int64:\n\t\t\t\tval = fmt.Sprint(slice.Index(i).Int())\n\t\t\tcase reflect.Uint, reflect.Uint64:\n\t\t\t\tval = fmt.Sprint(slice.Index(i).Uint())\n\t\t\tcase reflect.Float64:\n\t\t\t\tval = fmt.Sprint(slice.Index(i).Float())\n\t\t\tcase reflect.Bool:\n\t\t\t\tval = fmt.Sprint(slice.Index(i).Bool())\n\t\t\tcase reflectTime:\n\t\t\t\tval = slice.Index(i).Interface().(time.Time).Format(time.RFC3339)\n\t\t\tdefault:\n\t\t\t\treturn fmt.Errorf(\"unsupported type '[]%s'\", sliceOf)\n\t\t\t}\n\n\t\t\tif i == 0 {\n\t\t\t\tkeyWithShadows = newKey(key.s, key.name, val)\n\t\t\t} else {\n\t\t\t\t_ = keyWithShadows.AddShadow(val)\n\t\t\t}\n\t\t}\n\t\t*key = *keyWithShadows\n\t\treturn nil\n\t}\n\n\tvar buf bytes.Buffer\n\tfor i := 0; i < field.Len(); i++ {\n\t\tswitch sliceOf {\n\t\tcase reflect.String:\n\t\t\tbuf.WriteString(slice.Index(i).String())\n\t\tcase reflect.Int, reflect.Int64:\n\t\t\tbuf.WriteString(fmt.Sprint(slice.Index(i).Int()))\n\t\tcase reflect.Uint, reflect.Uint64:\n\t\t\tbuf.WriteString(fmt.Sprint(slice.Index(i).Uint()))\n\t\tcase reflect.Float64:\n\t\t\tbuf.WriteString(fmt.Sprint(slice.Index(i).Float()))\n\t\tcase reflect.Bool:\n\t\t\tbuf.WriteString(fmt.Sprint(slice.Index(i).Bool()))\n\t\tcase reflectTime:\n\t\t\tbuf.WriteString(slice.Index(i).Interface().(time.Time).Format(time.RFC3339))\n\t\tdefault:\n\t\t\treturn fmt.Errorf(\"unsupported type '[]%s'\", sliceOf)\n\t\t}\n\t\tbuf.WriteString(delim)\n\t}\n\tkey.SetValue(buf.String()[:buf.Len()-len(delim)])\n\treturn nil\n}\n\n// reflectWithProperType does the opposite thing as setWithProperType.\nfunc reflectWithProperType(t reflect.Type, key *Key, field reflect.Value, delim string, allowShadow bool) error {\n\tswitch t.Kind() {\n\tcase reflect.String:\n\t\tkey.SetValue(field.String())\n\tcase reflect.Bool:\n\t\tkey.SetValue(fmt.Sprint(field.Bool()))\n\tcase reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:\n\t\tkey.SetValue(fmt.Sprint(field.Int()))\n\tcase reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64:\n\t\tkey.SetValue(fmt.Sprint(field.Uint()))\n\tcase reflect.Float32, reflect.Float64:\n\t\tkey.SetValue(fmt.Sprint(field.Float()))\n\tcase reflectTime:\n\t\tkey.SetValue(fmt.Sprint(field.Interface().(time.Time).Format(time.RFC3339)))\n\tcase reflect.Slice:\n\t\treturn reflectSliceWithProperType(key, field, delim, allowShadow)\n\tcase reflect.Ptr:\n\t\tif !field.IsNil() {\n\t\t\treturn reflectWithProperType(t.Elem(), key, field.Elem(), delim, allowShadow)\n\t\t}\n\tdefault:\n\t\treturn fmt.Errorf(\"unsupported type %q\", t)\n\t}\n\treturn nil\n}\n\n// CR: copied from encoding/json/encode.go with modifications of time.Time support.\n// TODO: add more test coverage.\nfunc isEmptyValue(v reflect.Value) bool {\n\tswitch v.Kind() {\n\tcase reflect.Array, reflect.Map, reflect.Slice, reflect.String:\n\t\treturn v.Len() == 0\n\tcase reflect.Bool:\n\t\treturn !v.Bool()\n\tcase reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:\n\t\treturn v.Int() == 0\n\tcase reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64, reflect.Uintptr:\n\t\treturn v.Uint() == 0\n\tcase reflect.Float32, reflect.Float64:\n\t\treturn v.Float() == 0\n\tcase reflect.Interface, reflect.Ptr:\n\t\treturn v.IsNil()\n\tcase reflectTime:\n\t\tt, ok := v.Interface().(time.Time)\n\t\treturn ok && t.IsZero()\n\t}\n\treturn false\n}\n\n// StructReflector is the interface implemented by struct types that can extract themselves into INI objects.\ntype StructReflector interface {\n\tReflectINIStruct(*File) error\n}\n\nfunc (s *Section) reflectFrom(val reflect.Value) error {\n\tif val.Kind() == reflect.Ptr {\n\t\tval = val.Elem()\n\t}\n\ttyp := val.Type()\n\n\tfor i := 0; i < typ.NumField(); i++ {\n\t\tif !val.Field(i).CanInterface() {\n\t\t\tcontinue\n\t\t}\n\n\t\tfield := val.Field(i)\n\t\ttpField := typ.Field(i)\n\n\t\ttag := tpField.Tag.Get(\"ini\")\n\t\tif tag == \"-\" {\n\t\t\tcontinue\n\t\t}\n\n\t\trawName, omitEmpty, allowShadow, allowNonUnique, extends := parseTagOptions(tag)\n\t\tif omitEmpty && isEmptyValue(field) {\n\t\t\tcontinue\n\t\t}\n\n\t\tif r, ok := field.Interface().(StructReflector); ok {\n\t\t\treturn r.ReflectINIStruct(s.f)\n\t\t}\n\n\t\tfieldName := s.parseFieldName(tpField.Name, rawName)\n\t\tif len(fieldName) == 0 || !field.CanSet() {\n\t\t\tcontinue\n\t\t}\n\n\t\tif extends && tpField.Anonymous && (tpField.Type.Kind() == reflect.Ptr || tpField.Type.Kind() == reflect.Struct) {\n\t\t\tif err := s.reflectFrom(field); err != nil {\n\t\t\t\treturn fmt.Errorf(\"reflect from field %q: %v\", fieldName, err)\n\t\t\t}\n\t\t\tcontinue\n\t\t}\n\n\t\tif (tpField.Type.Kind() == reflect.Ptr && tpField.Type.Elem().Kind() == reflect.Struct) ||\n\t\t\t(tpField.Type.Kind() == reflect.Struct && tpField.Type.Name() != \"Time\") {\n\t\t\t// Note: The only error here is section doesn't exist.\n\t\t\tsec, err := s.f.GetSection(fieldName)\n\t\t\tif err != nil {\n\t\t\t\t// Note: fieldName can never be empty here, ignore error.\n\t\t\t\tsec, _ = s.f.NewSection(fieldName)\n\t\t\t}\n\n\t\t\t// Add comment from comment tag\n\t\t\tif len(sec.Comment) == 0 {\n\t\t\t\tsec.Comment = tpField.Tag.Get(\"comment\")\n\t\t\t}\n\n\t\t\tif err = sec.reflectFrom(field); err != nil {\n\t\t\t\treturn fmt.Errorf(\"reflect from field %q: %v\", fieldName, err)\n\t\t\t}\n\t\t\tcontinue\n\t\t}\n\n\t\tif allowNonUnique && tpField.Type.Kind() == reflect.Slice {\n\t\t\tslice := field.Slice(0, field.Len())\n\t\t\tif field.Len() == 0 {\n\t\t\t\treturn nil\n\t\t\t}\n\t\t\tsliceOf := field.Type().Elem().Kind()\n\n\t\t\tfor i := 0; i < field.Len(); i++ {\n\t\t\t\tif sliceOf != reflect.Struct && sliceOf != reflect.Ptr {\n\t\t\t\t\treturn fmt.Errorf(\"field %q is not a slice of pointer or struct\", fieldName)\n\t\t\t\t}\n\n\t\t\t\tsec, err := s.f.NewSection(fieldName)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\n\t\t\t\t// Add comment from comment tag\n\t\t\t\tif len(sec.Comment) == 0 {\n\t\t\t\t\tsec.Comment = tpField.Tag.Get(\"comment\")\n\t\t\t\t}\n\n\t\t\t\tif err := sec.reflectFrom(slice.Index(i)); err != nil {\n\t\t\t\t\treturn fmt.Errorf(\"reflect from field %q: %v\", fieldName, err)\n\t\t\t\t}\n\t\t\t}\n\t\t\tcontinue\n\t\t}\n\n\t\t// Note: Same reason as section.\n\t\tkey, err := s.GetKey(fieldName)\n\t\tif err != nil {\n\t\t\tkey, _ = s.NewKey(fieldName, \"\")\n\t\t}\n\n\t\t// Add comment from comment tag\n\t\tif len(key.Comment) == 0 {\n\t\t\tkey.Comment = tpField.Tag.Get(\"comment\")\n\t\t}\n\n\t\tdelim := parseDelim(tpField.Tag.Get(\"delim\"))\n\t\tif err = reflectWithProperType(tpField.Type, key, field, delim, allowShadow); err != nil {\n\t\t\treturn fmt.Errorf(\"reflect field %q: %v\", fieldName, err)\n\t\t}\n\n\t}\n\treturn nil\n}\n\n// ReflectFrom reflects section from given struct. It overwrites existing ones.\nfunc (s *Section) ReflectFrom(v interface{}) error {\n\ttyp := reflect.TypeOf(v)\n\tval := reflect.ValueOf(v)\n\n\tif s.name != DefaultSection && s.f.options.AllowNonUniqueSections &&\n\t\t(typ.Kind() == reflect.Slice || typ.Kind() == reflect.Ptr) {\n\t\t// Clear sections to make sure none exists before adding the new ones\n\t\ts.f.DeleteSection(s.name)\n\n\t\tif typ.Kind() == reflect.Ptr {\n\t\t\tsec, err := s.f.NewSection(s.name)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\treturn sec.reflectFrom(val.Elem())\n\t\t}\n\n\t\tslice := val.Slice(0, val.Len())\n\t\tsliceOf := val.Type().Elem().Kind()\n\t\tif sliceOf != reflect.Ptr {\n\t\t\treturn fmt.Errorf(\"not a slice of pointers\")\n\t\t}\n\n\t\tfor i := 0; i < slice.Len(); i++ {\n\t\t\tsec, err := s.f.NewSection(s.name)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t\terr = sec.reflectFrom(slice.Index(i))\n\t\t\tif err != nil {\n\t\t\t\treturn fmt.Errorf(\"reflect from %dth field: %v\", i, err)\n\t\t\t}\n\t\t}\n\n\t\treturn nil\n\t}\n\n\tif typ.Kind() == reflect.Ptr {\n\t\tval = val.Elem()\n\t} else {\n\t\treturn errors.New(\"not a pointer to a struct\")\n\t}\n\n\treturn s.reflectFrom(val)\n}\n\n// ReflectFrom reflects file from given struct.\nfunc (f *File) ReflectFrom(v interface{}) error {\n\treturn f.Section(\"\").ReflectFrom(v)\n}\n\n// ReflectFromWithMapper reflects data sources from given struct with name mapper.\nfunc ReflectFromWithMapper(cfg *File, v interface{}, mapper NameMapper) error {\n\tcfg.NameMapper = mapper\n\treturn cfg.ReflectFrom(v)\n}\n\n// ReflectFrom reflects data sources from given struct.\nfunc ReflectFrom(cfg *File, v interface{}) error {\n\treturn ReflectFromWithMapper(cfg, v, nil)\n}\n"
        },
        {
          "name": "struct_test.go",
          "type": "blob",
          "size": 22.8857421875,
          "content": "// Copyright 2014 Unknwon\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"): you may\n// not use this file except in compliance with the License. You may obtain\n// a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n// WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n// License for the specific language governing permissions and limitations\n// under the License.\n\npackage ini\n\nimport (\n\t\"bytes\"\n\t\"fmt\"\n\t\"strings\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/stretchr/testify/assert\"\n\t\"github.com/stretchr/testify/require\"\n)\n\ntype testNested struct {\n\tCities      []string `delim:\"|\"`\n\tVisits      []time.Time\n\tYears       []int\n\tNumbers     []int64\n\tAges        []uint\n\tPopulations []uint64\n\tCoordinates []float64\n\tFlags       []bool\n\tNote        string\n\tUnused      int `ini:\"-\"`\n}\n\ntype TestEmbeded struct {\n\tGPA float64\n}\n\ntype testStruct struct {\n\tName           string `ini:\"NAME\"`\n\tAge            int\n\tMale           bool\n\tMoney          float64\n\tBorn           time.Time\n\tTime           time.Duration `ini:\"Duration\"`\n\tOldVersionTime time.Duration\n\tOthers         testNested\n\tOthersPtr      *testNested\n\tNilPtr         *testNested\n\t*TestEmbeded   `ini:\"grade\"`\n\tUnused         int `ini:\"-\"`\n\tUnsigned       uint\n\tOmitted        bool     `ini:\"omitthis,omitempty\"`\n\tShadows        []string `ini:\",allowshadow\"`\n\tShadowInts     []int    `ini:\"Shadows,allowshadow\"`\n\tBoolPtr        *bool\n\tBoolPtrNil     *bool\n\tFloatPtr       *float64\n\tFloatPtrNil    *float64\n\tIntPtr         *int\n\tIntPtrNil      *int\n\tUintPtr        *uint\n\tUintPtrNil     *uint\n\tStringPtr      *string\n\tStringPtrNil   *string\n\tTimePtr        *time.Time\n\tTimePtrNil     *time.Time\n\tDurationPtr    *time.Duration\n\tDurationPtrNil *time.Duration\n}\n\ntype testInterface struct {\n\tAddress    string\n\tListenPort int\n\tPrivateKey string\n}\n\ntype testPeer struct {\n\tPublicKey    string\n\tPresharedKey string\n\tAllowedIPs   []string `delim:\",\"`\n}\n\ntype testNonUniqueSectionsStruct struct {\n\tInterface testInterface\n\tPeer      []testPeer `ini:\",nonunique\"`\n}\n\ntype BaseStruct struct {\n\tBase bool\n}\n\ntype testExtend struct {\n\tBaseStruct `ini:\",extends\"`\n\tExtend     bool\n}\n\nconst confDataStruct = `\nNAME = Unknwon\nAge = 21\nMale = true\nMoney = 1.25\nBorn = 1993-10-07T20:17:05Z\nDuration = 2h45m\nOldVersionTime = 30\nUnsigned = 3\nomitthis = true\nShadows = 1, 2\nShadows = 3, 4\nBoolPtr = false\nFloatPtr = 0\nIntPtr = 0\nUintPtr = 0\nStringPtr = \"\"\nTimePtr = 0001-01-01T00:00:00Z\nDurationPtr = 0s\n\n[Others]\nCities = HangZhou|Boston\nVisits = 1993-10-07T20:17:05Z, 1993-10-07T20:17:05Z\nYears = 1993,1994\nNumbers = 10010,10086\nAges = 18,19\nPopulations = 12345678,98765432\nCoordinates = 192.168,10.11\nFlags       = true,false\nNote = Hello world!\n\n[OthersPtr]\nCities = HangZhou|Boston\nVisits = 1993-10-07T20:17:05Z, 1993-10-07T20:17:05Z\nYears = 1993,1994\nNumbers = 10010,10086\nAges = 18,19\nPopulations = 12345678,98765432\nCoordinates = 192.168,10.11\nFlags       = true,false\nNote = Hello world!\n\n[grade]\nGPA = 2.8\n\n[foo.bar]\nHere = there\nWhen = then\n\n[extended]\nBase = true\nExtend = true\n`\n\nconst confNonUniqueSectionDataStruct = `[Interface]\nAddress    = 10.2.0.1/24\nListenPort = 34777\nPrivateKey = privServerKey\n\n[Peer]\nPublicKey    = pubClientKey\nPresharedKey = psKey\nAllowedIPs   = 10.2.0.2/32,fd00:2::2/128\n\n[Peer]\nPublicKey    = pubClientKey2\nPresharedKey = psKey2\nAllowedIPs   = 10.2.0.3/32,fd00:2::3/128\n`\n\ntype unsupport struct {\n\tByte byte\n}\n\ntype unsupport2 struct {\n\tOthers struct {\n\t\tCities byte\n\t}\n}\n\ntype Unsupport3 struct {\n\tCities byte\n}\n\ntype unsupport4 struct {\n\t*Unsupport3 `ini:\"Others\"`\n}\n\ntype defaultValue struct {\n\tName     string\n\tAge      int\n\tMale     bool\n\tOptional *bool\n\tMoney    float64\n\tBorn     time.Time\n\tCities   []string\n}\n\ntype fooBar struct {\n\tHere, When string\n}\n\nconst invalidDataConfStruct = `\nName = \nAge = age\nMale = 123\nMoney = money\nBorn = nil\nCities = \n`\n\nfunc Test_MapToStruct(t *testing.T) {\n\tt.Run(\"map to struct\", func(t *testing.T) {\n\t\tt.Run(\"map file to struct\", func(t *testing.T) {\n\t\t\tts := new(testStruct)\n\t\t\tassert.NoError(t, MapTo(ts, []byte(confDataStruct)))\n\n\t\t\tassert.Equal(t, \"Unknwon\", ts.Name)\n\t\t\tassert.Equal(t, 21, ts.Age)\n\t\t\tassert.True(t, ts.Male)\n\t\t\tassert.Equal(t, 1.25, ts.Money)\n\t\t\tassert.Equal(t, uint(3), ts.Unsigned)\n\n\t\t\tti, err := time.Parse(time.RFC3339, \"1993-10-07T20:17:05Z\")\n\t\t\trequire.NoError(t, err)\n\t\t\tassert.Equal(t, ti.String(), ts.Born.String())\n\n\t\t\tdur, err := time.ParseDuration(\"2h45m\")\n\t\t\trequire.NoError(t, err)\n\t\t\tassert.Equal(t, dur.Seconds(), ts.Time.Seconds())\n\n\t\t\tassert.Equal(t, 30*time.Second, ts.OldVersionTime*time.Second)\n\n\t\t\tassert.Equal(t, \"HangZhou,Boston\", strings.Join(ts.Others.Cities, \",\"))\n\t\t\tassert.Equal(t, ti.String(), ts.Others.Visits[0].String())\n\t\t\tassert.Equal(t, \"[1993 1994]\", fmt.Sprint(ts.Others.Years))\n\t\t\tassert.Equal(t, \"[10010 10086]\", fmt.Sprint(ts.Others.Numbers))\n\t\t\tassert.Equal(t, \"[18 19]\", fmt.Sprint(ts.Others.Ages))\n\t\t\tassert.Equal(t, \"[12345678 98765432]\", fmt.Sprint(ts.Others.Populations))\n\t\t\tassert.Equal(t, \"[192.168 10.11]\", fmt.Sprint(ts.Others.Coordinates))\n\t\t\tassert.Equal(t, \"[true false]\", fmt.Sprint(ts.Others.Flags))\n\t\t\tassert.Equal(t, \"Hello world!\", ts.Others.Note)\n\t\t\tassert.Equal(t, 2.8, ts.TestEmbeded.GPA)\n\n\t\t\tassert.Equal(t, \"HangZhou,Boston\", strings.Join(ts.OthersPtr.Cities, \",\"))\n\t\t\tassert.Equal(t, ti.String(), ts.OthersPtr.Visits[0].String())\n\t\t\tassert.Equal(t, \"[1993 1994]\", fmt.Sprint(ts.OthersPtr.Years))\n\t\t\tassert.Equal(t, \"[10010 10086]\", fmt.Sprint(ts.OthersPtr.Numbers))\n\t\t\tassert.Equal(t, \"[18 19]\", fmt.Sprint(ts.OthersPtr.Ages))\n\t\t\tassert.Equal(t, \"[12345678 98765432]\", fmt.Sprint(ts.OthersPtr.Populations))\n\t\t\tassert.Equal(t, \"[192.168 10.11]\", fmt.Sprint(ts.OthersPtr.Coordinates))\n\t\t\tassert.Equal(t, \"[true false]\", fmt.Sprint(ts.OthersPtr.Flags))\n\t\t\tassert.Equal(t, \"Hello world!\", ts.OthersPtr.Note)\n\n\t\t\tassert.Nil(t, ts.NilPtr)\n\n\t\t\tassert.Equal(t, false, *ts.BoolPtr)\n\t\t\tassert.Nil(t, ts.BoolPtrNil)\n\t\t\tassert.Equal(t, float64(0), *ts.FloatPtr)\n\t\t\tassert.Nil(t, ts.FloatPtrNil)\n\t\t\tassert.Equal(t, 0, *ts.IntPtr)\n\t\t\tassert.Nil(t, ts.IntPtrNil)\n\t\t\tassert.Equal(t, uint(0), *ts.UintPtr)\n\t\t\tassert.Nil(t, ts.UintPtrNil)\n\t\t\tassert.Equal(t, \"\", *ts.StringPtr)\n\t\t\tassert.Nil(t, ts.StringPtrNil)\n\t\t\tassert.NotNil(t, *ts.TimePtr)\n\t\t\tassert.Nil(t, ts.TimePtrNil)\n\t\t\tassert.Equal(t, time.Duration(0), *ts.DurationPtr)\n\t\t\tassert.Nil(t, ts.DurationPtrNil)\n\t\t})\n\n\t\tt.Run(\"map section to struct\", func(t *testing.T) {\n\t\t\tfoobar := new(fooBar)\n\t\t\tf, err := Load([]byte(confDataStruct))\n\t\t\trequire.NoError(t, err)\n\n\t\t\tassert.NoError(t, f.Section(\"foo.bar\").MapTo(foobar))\n\t\t\tassert.Equal(t, \"there\", foobar.Here)\n\t\t\tassert.Equal(t, \"then\", foobar.When)\n\t\t})\n\n\t\tt.Run(\"map to non-pointer struct\", func(t *testing.T) {\n\t\t\tf, err := Load([]byte(confDataStruct))\n\t\t\trequire.NoError(t, err)\n\t\t\trequire.NotNil(t, f)\n\n\t\t\tassert.Error(t, f.MapTo(testStruct{}))\n\t\t})\n\n\t\tt.Run(\"map to unsupported type\", func(t *testing.T) {\n\t\t\tf, err := Load([]byte(confDataStruct))\n\t\t\trequire.NoError(t, err)\n\t\t\trequire.NotNil(t, f)\n\n\t\t\tf.NameMapper = func(raw string) string {\n\t\t\t\tif raw == \"Byte\" {\n\t\t\t\t\treturn \"NAME\"\n\t\t\t\t}\n\t\t\t\treturn raw\n\t\t\t}\n\t\t\tassert.Error(t, f.MapTo(&unsupport{}))\n\t\t\tassert.Error(t, f.MapTo(&unsupport2{}))\n\t\t\tassert.Error(t, f.MapTo(&unsupport4{}))\n\t\t})\n\n\t\tt.Run(\"map to omitempty field\", func(t *testing.T) {\n\t\t\tts := new(testStruct)\n\t\t\tassert.NoError(t, MapTo(ts, []byte(confDataStruct)))\n\n\t\t\tassert.Equal(t, true, ts.Omitted)\n\t\t})\n\n\t\tt.Run(\"map with shadows\", func(t *testing.T) {\n\t\t\tf, err := LoadSources(LoadOptions{AllowShadows: true}, []byte(confDataStruct))\n\t\t\trequire.NoError(t, err)\n\t\t\tts := new(testStruct)\n\t\t\tassert.NoError(t, f.MapTo(ts))\n\n\t\t\tassert.Equal(t, \"1 2 3 4\", strings.Join(ts.Shadows, \" \"))\n\t\t\tassert.Equal(t, \"[1 2 3 4]\", fmt.Sprintf(\"%v\", ts.ShadowInts))\n\t\t})\n\n\t\tt.Run(\"map from invalid data source\", func(t *testing.T) {\n\t\t\tassert.Error(t, MapTo(&testStruct{}, \"hi\"))\n\t\t})\n\n\t\tt.Run(\"map to wrong types and gain default values\", func(t *testing.T) {\n\t\t\tf, err := Load([]byte(invalidDataConfStruct))\n\t\t\trequire.NoError(t, err)\n\n\t\t\tti, err := time.Parse(time.RFC3339, \"1993-10-07T20:17:05Z\")\n\t\t\trequire.NoError(t, err)\n\t\t\tdv := &defaultValue{\"Joe\", 10, true, nil, 1.25, ti, []string{\"HangZhou\", \"Boston\"}}\n\t\t\tassert.NoError(t, f.MapTo(dv))\n\t\t\tassert.Equal(t, \"Joe\", dv.Name)\n\t\t\tassert.Equal(t, 10, dv.Age)\n\t\t\tassert.True(t, dv.Male)\n\t\t\tassert.Equal(t, 1.25, dv.Money)\n\t\t\tassert.Equal(t, ti.String(), dv.Born.String())\n\t\t\tassert.Equal(t, \"HangZhou,Boston\", strings.Join(dv.Cities, \",\"))\n\t\t})\n\n\t\tt.Run(\"map to extended base\", func(t *testing.T) {\n\t\t\tf, err := Load([]byte(confDataStruct))\n\t\t\trequire.NoError(t, err)\n\t\t\trequire.NotNil(t, f)\n\t\t\tte := testExtend{}\n\t\t\tassert.NoError(t, f.Section(\"extended\").MapTo(&te))\n\t\t\tassert.True(t, te.Base)\n\t\t\tassert.True(t, te.Extend)\n\t\t})\n\t})\n\n\tt.Run(\"map to struct in strict mode\", func(t *testing.T) {\n\t\tf, err := Load([]byte(`\nname=bruce\nage=a30`))\n\t\trequire.NoError(t, err)\n\n\t\ttype Strict struct {\n\t\t\tName string `ini:\"name\"`\n\t\t\tAge  int    `ini:\"age\"`\n\t\t}\n\t\ts := new(Strict)\n\n\t\tassert.Error(t, f.Section(\"\").StrictMapTo(s))\n\t})\n\n\tt.Run(\"map slice in strict mode\", func(t *testing.T) {\n\t\tf, err := Load([]byte(`\nnames=alice, bruce`))\n\t\trequire.NoError(t, err)\n\n\t\ttype Strict struct {\n\t\t\tNames []string `ini:\"names\"`\n\t\t}\n\t\ts := new(Strict)\n\n\t\tassert.NoError(t, f.Section(\"\").StrictMapTo(s))\n\t\tassert.Equal(t, \"[alice bruce]\", fmt.Sprint(s.Names))\n\t})\n}\n\nfunc Test_MapToStructNonUniqueSections(t *testing.T) {\n\tt.Run(\"map to struct non unique\", func(t *testing.T) {\n\t\tt.Run(\"map file to struct non unique\", func(t *testing.T) {\n\t\t\tf, err := LoadSources(LoadOptions{AllowNonUniqueSections: true}, []byte(confNonUniqueSectionDataStruct))\n\t\t\trequire.NoError(t, err)\n\t\t\tts := new(testNonUniqueSectionsStruct)\n\n\t\t\tassert.NoError(t, f.MapTo(ts))\n\n\t\t\tassert.Equal(t, \"10.2.0.1/24\", ts.Interface.Address)\n\t\t\tassert.Equal(t, 34777, ts.Interface.ListenPort)\n\t\t\tassert.Equal(t, \"privServerKey\", ts.Interface.PrivateKey)\n\n\t\t\tassert.Equal(t, \"pubClientKey\", ts.Peer[0].PublicKey)\n\t\t\tassert.Equal(t, \"psKey\", ts.Peer[0].PresharedKey)\n\t\t\tassert.Equal(t, \"10.2.0.2/32\", ts.Peer[0].AllowedIPs[0])\n\t\t\tassert.Equal(t, \"fd00:2::2/128\", ts.Peer[0].AllowedIPs[1])\n\n\t\t\tassert.Equal(t, \"pubClientKey2\", ts.Peer[1].PublicKey)\n\t\t\tassert.Equal(t, \"psKey2\", ts.Peer[1].PresharedKey)\n\t\t\tassert.Equal(t, \"10.2.0.3/32\", ts.Peer[1].AllowedIPs[0])\n\t\t\tassert.Equal(t, \"fd00:2::3/128\", ts.Peer[1].AllowedIPs[1])\n\t\t})\n\n\t\tt.Run(\"map non unique section to struct\", func(t *testing.T) {\n\t\t\tnewPeer := new(testPeer)\n\t\t\tnewPeerSlice := make([]testPeer, 0)\n\n\t\t\tf, err := LoadSources(LoadOptions{AllowNonUniqueSections: true}, []byte(confNonUniqueSectionDataStruct))\n\t\t\trequire.NoError(t, err)\n\n\t\t\t// try only first one\n\t\t\tassert.NoError(t, f.Section(\"Peer\").MapTo(newPeer))\n\t\t\tassert.Equal(t, \"pubClientKey\", newPeer.PublicKey)\n\t\t\tassert.Equal(t, \"psKey\", newPeer.PresharedKey)\n\t\t\tassert.Equal(t, \"10.2.0.2/32\", newPeer.AllowedIPs[0])\n\t\t\tassert.Equal(t, \"fd00:2::2/128\", newPeer.AllowedIPs[1])\n\n\t\t\t// try all\n\t\t\tassert.NoError(t, f.Section(\"Peer\").MapTo(&newPeerSlice))\n\t\t\tassert.Equal(t, \"pubClientKey\", newPeerSlice[0].PublicKey)\n\t\t\tassert.Equal(t, \"psKey\", newPeerSlice[0].PresharedKey)\n\t\t\tassert.Equal(t, \"10.2.0.2/32\", newPeerSlice[0].AllowedIPs[0])\n\t\t\tassert.Equal(t, \"fd00:2::2/128\", newPeerSlice[0].AllowedIPs[1])\n\n\t\t\tassert.Equal(t, \"pubClientKey2\", newPeerSlice[1].PublicKey)\n\t\t\tassert.Equal(t, \"psKey2\", newPeerSlice[1].PresharedKey)\n\t\t\tassert.Equal(t, \"10.2.0.3/32\", newPeerSlice[1].AllowedIPs[0])\n\t\t\tassert.Equal(t, \"fd00:2::3/128\", newPeerSlice[1].AllowedIPs[1])\n\t\t})\n\n\t\tt.Run(\"map non unique sections with subsections to struct\", func(t *testing.T) {\n\t\t\tiniFile, err := LoadSources(LoadOptions{AllowNonUniqueSections: true}, strings.NewReader(`\n[Section]\nFieldInSubSection = 1\nFieldInSubSection2 = 2\nFieldInSection = 3\n\n[Section]\nFieldInSubSection = 4\nFieldInSubSection2 = 5\nFieldInSection = 6\n`))\n\t\t\trequire.NoError(t, err)\n\n\t\t\ttype SubSection struct {\n\t\t\t\tFieldInSubSection string `ini:\"FieldInSubSection\"`\n\t\t\t}\n\t\t\ttype SubSection2 struct {\n\t\t\t\tFieldInSubSection2 string `ini:\"FieldInSubSection2\"`\n\t\t\t}\n\n\t\t\ttype Section struct {\n\t\t\t\tSubSection     `ini:\"Section\"`\n\t\t\t\tSubSection2    `ini:\"Section\"`\n\t\t\t\tFieldInSection string `ini:\"FieldInSection\"`\n\t\t\t}\n\n\t\t\ttype File struct {\n\t\t\t\tSections []Section `ini:\"Section,nonunique\"`\n\t\t\t}\n\n\t\t\tf := new(File)\n\t\t\terr = iniFile.MapTo(f)\n\t\t\trequire.NoError(t, err)\n\n\t\t\tassert.Equal(t, \"1\", f.Sections[0].FieldInSubSection)\n\t\t\tassert.Equal(t, \"2\", f.Sections[0].FieldInSubSection2)\n\t\t\tassert.Equal(t, \"3\", f.Sections[0].FieldInSection)\n\n\t\t\tassert.Equal(t, \"4\", f.Sections[1].FieldInSubSection)\n\t\t\tassert.Equal(t, \"5\", f.Sections[1].FieldInSubSection2)\n\t\t\tassert.Equal(t, \"6\", f.Sections[1].FieldInSection)\n\t\t})\n\t})\n}\n\nfunc Test_ReflectFromStruct(t *testing.T) {\n\tt.Run(\"reflect from struct\", func(t *testing.T) {\n\t\ttype Embeded struct {\n\t\t\tDates       []time.Time `delim:\"|\" comment:\"Time data\"`\n\t\t\tPlaces      []string\n\t\t\tYears       []int\n\t\t\tNumbers     []int64\n\t\t\tAges        []uint\n\t\t\tPopulations []uint64\n\t\t\tCoordinates []float64\n\t\t\tFlags       []bool\n\t\t\tNone        []int\n\t\t}\n\t\ttype Author struct {\n\t\t\tName      string `ini:\"NAME\"`\n\t\t\tMale      bool\n\t\t\tOptional  *bool\n\t\t\tAge       int `comment:\"Author's age\"`\n\t\t\tHeight    uint\n\t\t\tGPA       float64\n\t\t\tDate      time.Time\n\t\t\tNeverMind string `ini:\"-\"`\n\t\t\tignored   string\n\t\t\t*Embeded  `ini:\"infos\" comment:\"Embeded section\"`\n\t\t}\n\n\t\tti, err := time.Parse(time.RFC3339, \"1993-10-07T20:17:05Z\")\n\t\trequire.NoError(t, err)\n\t\ta := &Author{\"Unknwon\", true, nil, 21, 100, 2.8, ti, \"\", \"ignored\",\n\t\t\t&Embeded{\n\t\t\t\t[]time.Time{ti, ti},\n\t\t\t\t[]string{\"HangZhou\", \"Boston\"},\n\t\t\t\t[]int{1993, 1994},\n\t\t\t\t[]int64{10010, 10086},\n\t\t\t\t[]uint{18, 19},\n\t\t\t\t[]uint64{12345678, 98765432},\n\t\t\t\t[]float64{192.168, 10.11},\n\t\t\t\t[]bool{true, false},\n\t\t\t\t[]int{},\n\t\t\t}}\n\t\tcfg := Empty()\n\t\tassert.NoError(t, ReflectFrom(cfg, a))\n\n\t\tvar buf bytes.Buffer\n\t\t_, err = cfg.WriteTo(&buf)\n\t\trequire.NoError(t, err)\n\t\tassert.Equal(t, `NAME     = Unknwon\nMale     = true\nOptional = \n; Author's age\nAge      = 21\nHeight   = 100\nGPA      = 2.8\nDate     = 1993-10-07T20:17:05Z\n\n; Embeded section\n[infos]\n; Time data\nDates       = 1993-10-07T20:17:05Z|1993-10-07T20:17:05Z\nPlaces      = HangZhou,Boston\nYears       = 1993,1994\nNumbers     = 10010,10086\nAges        = 18,19\nPopulations = 12345678,98765432\nCoordinates = 192.168,10.11\nFlags       = true,false\nNone        = \n`,\n\t\t\tbuf.String(),\n\t\t)\n\n\t\tt.Run(\"reflect from non-point struct\", func(t *testing.T) {\n\t\t\tassert.Error(t, ReflectFrom(cfg, Author{}))\n\t\t})\n\n\t\tt.Run(\"reflect from struct with omitempty\", func(t *testing.T) {\n\t\t\tcfg := Empty()\n\t\t\ttype SpecialStruct struct {\n\t\t\t\tFirstName  string    `ini:\"first_name\"`\n\t\t\t\tLastName   string    `ini:\"last_name,omitempty\"`\n\t\t\t\tJustOmitMe string    `ini:\"omitempty\"`\n\t\t\t\tLastLogin  time.Time `ini:\"last_login,omitempty\"`\n\t\t\t\tLastLogin2 time.Time `ini:\",omitempty\"`\n\t\t\t\tNotEmpty   int       `ini:\"omitempty\"`\n\t\t\t\tNumber     int64     `ini:\",omitempty\"`\n\t\t\t\tAges       uint      `ini:\",omitempty\"`\n\t\t\t\tPopulation uint64    `ini:\",omitempty\"`\n\t\t\t\tCoordinate float64   `ini:\",omitempty\"`\n\t\t\t\tFlag       bool      `ini:\",omitempty\"`\n\t\t\t\tNote       *string   `ini:\",omitempty\"`\n\t\t\t}\n\t\t\tspecial := &SpecialStruct{\n\t\t\t\tFirstName: \"John\",\n\t\t\t\tLastName:  \"Doe\",\n\t\t\t\tNotEmpty:  9,\n\t\t\t}\n\n\t\t\tassert.NoError(t, ReflectFrom(cfg, special))\n\n\t\t\tvar buf bytes.Buffer\n\t\t\t_, err = cfg.WriteTo(&buf)\n\t\t\tassert.Equal(t, `first_name = John\nlast_name  = Doe\nomitempty  = 9\n`,\n\t\t\t\tbuf.String(),\n\t\t\t)\n\t\t})\n\n\t\tt.Run(\"reflect from struct with non-anonymous structure pointer\", func(t *testing.T) {\n\t\t\tcfg := Empty()\n\t\t\ttype Rpc struct {\n\t\t\t\tEnable  bool   `ini:\"enable\"`\n\t\t\t\tType    string `ini:\"type\"`\n\t\t\t\tAddress string `ini:\"addr\"`\n\t\t\t\tName    string `ini:\"name\"`\n\t\t\t}\n\t\t\ttype Cfg struct {\n\t\t\t\tRpc *Rpc `ini:\"rpc\"`\n\t\t\t}\n\n\t\t\tconfig := &Cfg{\n\t\t\t\tRpc: &Rpc{\n\t\t\t\t\tEnable:  true,\n\t\t\t\t\tType:    \"type\",\n\t\t\t\t\tAddress: \"address\",\n\t\t\t\t\tName:    \"name\",\n\t\t\t\t},\n\t\t\t}\n\t\t\tassert.NoError(t, cfg.ReflectFrom(config))\n\n\t\t\tvar buf bytes.Buffer\n\t\t\t_, err = cfg.WriteTo(&buf)\n\t\t\tassert.Equal(t, `[rpc]\nenable = true\ntype   = type\naddr   = address\nname   = name\n`,\n\t\t\t\tbuf.String(),\n\t\t\t)\n\t\t})\n\t})\n}\n\nfunc Test_ReflectFromStructNonUniqueSections(t *testing.T) {\n\tt.Run(\"reflect from struct with non unique sections\", func(t *testing.T) {\n\t\tnonUnique := &testNonUniqueSectionsStruct{\n\t\t\tInterface: testInterface{\n\t\t\t\tAddress:    \"10.2.0.1/24\",\n\t\t\t\tListenPort: 34777,\n\t\t\t\tPrivateKey: \"privServerKey\",\n\t\t\t},\n\t\t\tPeer: []testPeer{\n\t\t\t\t{\n\t\t\t\t\tPublicKey:    \"pubClientKey\",\n\t\t\t\t\tPresharedKey: \"psKey\",\n\t\t\t\t\tAllowedIPs:   []string{\"10.2.0.2/32,fd00:2::2/128\"},\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tPublicKey:    \"pubClientKey2\",\n\t\t\t\t\tPresharedKey: \"psKey2\",\n\t\t\t\t\tAllowedIPs:   []string{\"10.2.0.3/32,fd00:2::3/128\"},\n\t\t\t\t},\n\t\t\t},\n\t\t}\n\n\t\tcfg := Empty(LoadOptions{\n\t\t\tAllowNonUniqueSections: true,\n\t\t})\n\n\t\tassert.NoError(t, ReflectFrom(cfg, nonUnique))\n\n\t\tvar buf bytes.Buffer\n\t\t_, err := cfg.WriteTo(&buf)\n\t\trequire.NoError(t, err)\n\t\tassert.Equal(t, confNonUniqueSectionDataStruct, buf.String())\n\n\t\t// note: using ReflectFrom from should overwrite the existing sections\n\t\terr = cfg.Section(\"Peer\").ReflectFrom([]*testPeer{\n\t\t\t{\n\t\t\t\tPublicKey:    \"pubClientKey3\",\n\t\t\t\tPresharedKey: \"psKey3\",\n\t\t\t\tAllowedIPs:   []string{\"10.2.0.4/32,fd00:2::4/128\"},\n\t\t\t},\n\t\t\t{\n\t\t\t\tPublicKey:    \"pubClientKey4\",\n\t\t\t\tPresharedKey: \"psKey4\",\n\t\t\t\tAllowedIPs:   []string{\"10.2.0.5/32,fd00:2::5/128\"},\n\t\t\t},\n\t\t})\n\n\t\trequire.NoError(t, err)\n\n\t\tbuf = bytes.Buffer{}\n\t\t_, err = cfg.WriteTo(&buf)\n\t\trequire.NoError(t, err)\n\t\tassert.Equal(t, `[Interface]\nAddress    = 10.2.0.1/24\nListenPort = 34777\nPrivateKey = privServerKey\n\n[Peer]\nPublicKey    = pubClientKey3\nPresharedKey = psKey3\nAllowedIPs   = 10.2.0.4/32,fd00:2::4/128\n\n[Peer]\nPublicKey    = pubClientKey4\nPresharedKey = psKey4\nAllowedIPs   = 10.2.0.5/32,fd00:2::5/128\n`,\n\t\t\tbuf.String(),\n\t\t)\n\n\t\t// note: using ReflectFrom from should overwrite the existing sections\n\t\terr = cfg.Section(\"Peer\").ReflectFrom(&testPeer{\n\t\t\tPublicKey:    \"pubClientKey5\",\n\t\t\tPresharedKey: \"psKey5\",\n\t\t\tAllowedIPs:   []string{\"10.2.0.6/32,fd00:2::6/128\"},\n\t\t})\n\n\t\trequire.NoError(t, err)\n\n\t\tbuf = bytes.Buffer{}\n\t\t_, err = cfg.WriteTo(&buf)\n\t\trequire.NoError(t, err)\n\t\tassert.Equal(t, `[Interface]\nAddress    = 10.2.0.1/24\nListenPort = 34777\nPrivateKey = privServerKey\n\n[Peer]\nPublicKey    = pubClientKey5\nPresharedKey = psKey5\nAllowedIPs   = 10.2.0.6/32,fd00:2::6/128\n`,\n\t\t\tbuf.String(),\n\t\t)\n\t})\n}\n\n// Inspired by https://github.com/go-ini/ini/issues/196\nfunc TestMapToAndReflectFromStructWithShadows(t *testing.T) {\n\tt.Run(\"map to struct and then reflect with shadows should generate original config content\", func(t *testing.T) {\n\t\ttype include struct {\n\t\t\tPaths []string `ini:\"path,omitempty,allowshadow\"`\n\t\t}\n\n\t\tcfg, err := LoadSources(LoadOptions{\n\t\t\tAllowShadows: true,\n\t\t}, []byte(`\n[include]\npath = /tmp/gpm-profiles/test5.profile\npath = /tmp/gpm-profiles/test1.profile`))\n\t\trequire.NoError(t, err)\n\n\t\tsec := cfg.Section(\"include\")\n\t\tinc := new(include)\n\t\terr = sec.MapTo(inc)\n\t\trequire.NoError(t, err)\n\n\t\terr = sec.ReflectFrom(inc)\n\t\trequire.NoError(t, err)\n\n\t\tvar buf bytes.Buffer\n\t\t_, err = cfg.WriteTo(&buf)\n\t\trequire.NoError(t, err)\n\t\tassert.Equal(t, `[include]\npath = /tmp/gpm-profiles/test5.profile\npath = /tmp/gpm-profiles/test1.profile\n`,\n\t\t\tbuf.String(),\n\t\t)\n\n\t\tt.Run(\"reflect from struct with shadows\", func(t *testing.T) {\n\t\t\tcfg := Empty(LoadOptions{\n\t\t\t\tAllowShadows: true,\n\t\t\t})\n\t\t\ttype ShadowStruct struct {\n\t\t\t\tStringArray      []string    `ini:\"sa,allowshadow\"`\n\t\t\t\tEmptyStringArrat []string    `ini:\"empty,omitempty,allowshadow\"`\n\t\t\t\tAllowshadow      []string    `ini:\"allowshadow,allowshadow\"`\n\t\t\t\tDates            []time.Time `ini:\",allowshadow\"`\n\t\t\t\tPlaces           []string    `ini:\",allowshadow\"`\n\t\t\t\tYears            []int       `ini:\",allowshadow\"`\n\t\t\t\tNumbers          []int64     `ini:\",allowshadow\"`\n\t\t\t\tAges             []uint      `ini:\",allowshadow\"`\n\t\t\t\tPopulations      []uint64    `ini:\",allowshadow\"`\n\t\t\t\tCoordinates      []float64   `ini:\",allowshadow\"`\n\t\t\t\tFlags            []bool      `ini:\",allowshadow\"`\n\t\t\t\tNone             []int       `ini:\",allowshadow\"`\n\t\t\t}\n\n\t\t\tshadow := &ShadowStruct{\n\t\t\t\tStringArray: []string{\"s1\", \"s2\"},\n\t\t\t\tAllowshadow: []string{\"s3\", \"s4\"},\n\t\t\t\tDates: []time.Time{time.Date(2020, 9, 12, 00, 00, 00, 651387237, time.UTC),\n\t\t\t\t\ttime.Date(2020, 9, 12, 00, 00, 00, 651387237, time.UTC)},\n\t\t\t\tPlaces:      []string{\"HangZhou\", \"Boston\"},\n\t\t\t\tYears:       []int{1993, 1994},\n\t\t\t\tNumbers:     []int64{10010, 10086},\n\t\t\t\tAges:        []uint{18, 19},\n\t\t\t\tPopulations: []uint64{12345678, 98765432},\n\t\t\t\tCoordinates: []float64{192.168, 10.11},\n\t\t\t\tFlags:       []bool{true, false},\n\t\t\t\tNone:        []int{},\n\t\t\t}\n\n\t\t\tassert.NoError(t, ReflectFrom(cfg, shadow))\n\n\t\t\tvar buf bytes.Buffer\n\t\t\t_, err := cfg.WriteTo(&buf)\n\t\t\trequire.NoError(t, err)\n\t\t\tassert.Equal(t, `sa          = s1\nsa          = s2\nallowshadow = s3\nallowshadow = s4\nDates       = 2020-09-12T00:00:00Z\nPlaces      = HangZhou\nPlaces      = Boston\nYears       = 1993\nYears       = 1994\nNumbers     = 10010\nNumbers     = 10086\nAges        = 18\nAges        = 19\nPopulations = 12345678\nPopulations = 98765432\nCoordinates = 192.168\nCoordinates = 10.11\nFlags       = true\nFlags       = false\nNone        = \n`,\n\t\t\t\tbuf.String(),\n\t\t\t)\n\t\t})\n\t})\n}\n\ntype testMapper struct {\n\tPackageName string\n}\n\nfunc Test_NameGetter(t *testing.T) {\n\tt.Run(\"test name mappers\", func(t *testing.T) {\n\t\tassert.NoError(t, MapToWithMapper(&testMapper{}, TitleUnderscore, []byte(\"packag_name=ini\")))\n\n\t\tcfg, err := Load([]byte(\"PACKAGE_NAME=ini\"))\n\t\trequire.NoError(t, err)\n\t\trequire.NotNil(t, cfg)\n\n\t\tcfg.NameMapper = SnackCase\n\t\ttg := new(testMapper)\n\t\tassert.NoError(t, cfg.MapTo(tg))\n\t\tassert.Equal(t, \"ini\", tg.PackageName)\n\t})\n}\n\ntype testDurationStruct struct {\n\tDuration time.Duration `ini:\"Duration\"`\n}\n\nfunc Test_Duration(t *testing.T) {\n\tt.Run(\"duration less than 16m50s\", func(t *testing.T) {\n\t\tds := new(testDurationStruct)\n\t\tassert.NoError(t, MapTo(ds, []byte(\"Duration=16m49s\")))\n\n\t\tdur, err := time.ParseDuration(\"16m49s\")\n\t\trequire.NoError(t, err)\n\t\tassert.Equal(t, dur.Seconds(), ds.Duration.Seconds())\n\t})\n}\n\ntype Employer struct {\n\tName  string\n\tTitle string\n}\n\ntype Employers []*Employer\n\nfunc (es Employers) ReflectINIStruct(f *File) error {\n\tfor _, e := range es {\n\t\tf.Section(e.Name).Key(\"Title\").SetValue(e.Title)\n\t}\n\treturn nil\n}\n\n// Inspired by https://github.com/go-ini/ini/issues/199\nfunc Test_StructReflector(t *testing.T) {\n\tt.Run(\"reflect with StructReflector interface\", func(t *testing.T) {\n\t\tp := &struct {\n\t\t\tFirstName string\n\t\t\tEmployer  Employers\n\t\t}{\n\t\t\tFirstName: \"Andrew\",\n\t\t\tEmployer: []*Employer{\n\t\t\t\t{\n\t\t\t\t\tName:  `Employer \"VMware\"`,\n\t\t\t\t\tTitle: \"Staff II Engineer\",\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tName:  `Employer \"EMC\"`,\n\t\t\t\t\tTitle: \"Consultant Engineer\",\n\t\t\t\t},\n\t\t\t},\n\t\t}\n\n\t\tf := Empty()\n\t\tassert.NoError(t, f.ReflectFrom(p))\n\n\t\tvar buf bytes.Buffer\n\t\t_, err := f.WriteTo(&buf)\n\t\trequire.NoError(t, err)\n\n\t\tassert.Equal(t, `FirstName = Andrew\n\n[Employer \"VMware\"]\nTitle = Staff II Engineer\n\n[Employer \"EMC\"]\nTitle = Consultant Engineer\n`,\n\t\t\tbuf.String(),\n\t\t)\n\t})\n}\n"
        },
        {
          "name": "testdata",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}