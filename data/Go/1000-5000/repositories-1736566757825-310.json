{
  "metadata": {
    "timestamp": 1736566757825,
    "page": 310,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjMxMA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "hoisie/web",
      "stars": 3671,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.0888671875,
          "content": "*.6\n*.8\n*.o\n*.so\n*.out\n*.go~\n*.cgo?.*\n_cgo_*\n_obj\n_test\n_testmain.go\n*.swp\n_site\n.DS_Store\n"
        },
        {
          "name": ".travis.yml",
          "type": "blob",
          "size": 0.1318359375,
          "content": "language: go\n\ngo:\n  - 1.3\n  - 1.4\n  - 1.5\n  - 1.6\n\ninstall: go get\n\nscript:\n  - diff -u <(echo -n) <(gofmt -d -s .)\n  - go test -short\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.033203125,
          "content": "Copyright (c) 2009 Michael Hoisie\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n"
        },
        {
          "name": "Readme.md",
          "type": "blob",
          "size": 2.572265625,
          "content": "[![Build Status](https://travis-ci.org/hoisie/web.svg?branch=master)](https://travis-ci.org/hoisie/web)\n\n# web.go\n\nweb.go is the simplest way to write web applications in the Go programming language. It's ideal for writing simple, performant backend web services. \n\n## Overview\n\nweb.go should be familiar to people who've developed websites with higher-level web frameworks like sinatra or web.py. It is designed to be a lightweight web framework that doesn't impose any scaffolding on the user. Some features include:\n\n* Routing to url handlers based on regular expressions\n* Secure cookies\n* Support for fastcgi and scgi\n* Web applications are compiled to native code. This means very fast execution and page render speed\n* Efficiently serving static files\n\n## Installation\n\nMake sure you have the a working Go environment. See the [install instructions](http://golang.org/doc/install.html). web.go targets the Go `release` branch.\n\nTo install web.go, simply run:\n\n    go get github.com/hoisie/web\n\nTo compile it from source:\n\n    git clone git://github.com/hoisie/web.git\n    cd web && go build\n\n## Example\n```go\npackage main\n    \nimport (\n    \"github.com/hoisie/web\"\n)\n    \nfunc hello(val string) string { return \"hello \" + val } \n    \nfunc main() {\n    web.Get(\"/(.*)\", hello)\n    web.Run(\"0.0.0.0:9999\")\n}\n```\n\nTo run the application, put the code in a file called hello.go and run:\n\n    go run hello.go\n    \nYou can point your browser to http://localhost:9999/world . \n\n### Getting parameters\n\nRoute handlers may contain a pointer to web.Context as their first parameter. This variable serves many purposes -- it contains information about the request, and it provides methods to control the http connection. For instance, to iterate over the web parameters, either from the URL of a GET request, or the form data of a POST request, you can access `ctx.Params`, which is a `map[string]string`:\n\n```go\npackage main\n\nimport (\n    \"github.com/hoisie/web\"\n)\n    \nfunc hello(ctx *web.Context, val string) { \n    for k,v := range ctx.Params {\n\t\tprintln(k, v)\n\t}\n}   \n    \nfunc main() {\n    web.Get(\"/(.*)\", hello)\n    web.Run(\"0.0.0.0:9999\")\n}\n```\n\nIn this example, if you visit `http://localhost:9999/?a=1&b=2`, you'll see the following printed out in the terminal:\n\n    a 1\n    b 2\n\n## Documentation\n\nAPI docs are hosted at https://hoisie.github.io/web/\n\nIf you use web.go, I'd greatly appreciate a quick message about what you're building with it. This will help me get a sense of usage patterns, and helps me focus development efforts on features that people will actually use. \n\n## About\n\nweb.go was written by Michael Hoisie\n\n\n"
        },
        {
          "name": "examples",
          "type": "tree",
          "content": null
        },
        {
          "name": "fcgi.go",
          "type": "blob",
          "size": 0.4638671875,
          "content": "package web\n\nimport (\n\t\"net\"\n\t\"net/http/fcgi\"\n)\n\nfunc (s *Server) listenAndServeFcgi(addr string) error {\n\tvar l net.Listener\n\tvar err error\n\n\t//if the path begins with a \"/\", assume it's a unix address\n\tif addr[0] == '/' {\n\t\tl, err = net.Listen(\"unix\", addr)\n\t} else {\n\t\tl, err = net.Listen(\"tcp\", addr)\n\t}\n\n\t//save the listener so it can be closed\n\ts.l = l\n\n\tif err != nil {\n\t\ts.Logger.Println(\"FCGI listen error\", err.Error())\n\t\treturn err\n\t}\n\treturn fcgi.Serve(s.l, s)\n}\n"
        },
        {
          "name": "helpers.go",
          "type": "blob",
          "size": 2.8994140625,
          "content": "package web\n\nimport (\n\t\"bytes\"\n\t\"encoding/base64\"\n\t\"errors\"\n\t\"net/http\"\n\t\"net/url\"\n\t\"os\"\n\t\"regexp\"\n\t\"strings\"\n\t\"time\"\n)\n\n// internal utility methods\nfunc webTime(t time.Time) string {\n\tftime := t.Format(time.RFC1123)\n\tif strings.HasSuffix(ftime, \"UTC\") {\n\t\tftime = ftime[0:len(ftime)-3] + \"GMT\"\n\t}\n\treturn ftime\n}\n\nfunc dirExists(dir string) bool {\n\td, e := os.Stat(dir)\n\tswitch {\n\tcase e != nil:\n\t\treturn false\n\tcase !d.IsDir():\n\t\treturn false\n\t}\n\n\treturn true\n}\n\nfunc fileExists(dir string) bool {\n\tinfo, err := os.Stat(dir)\n\tif err != nil {\n\t\treturn false\n\t}\n\n\treturn !info.IsDir()\n}\n\n// Urlencode is a helper method that converts a map into URL-encoded form data.\n// It is a useful when constructing HTTP POST requests.\nfunc Urlencode(data map[string]string) string {\n\tvar buf bytes.Buffer\n\tfor k, v := range data {\n\t\tbuf.WriteString(url.QueryEscape(k))\n\t\tbuf.WriteByte('=')\n\t\tbuf.WriteString(url.QueryEscape(v))\n\t\tbuf.WriteByte('&')\n\t}\n\ts := buf.String()\n\treturn s[0 : len(s)-1]\n}\n\nvar slugRegex = regexp.MustCompile(`(?i:[^a-z0-9\\-_])`)\n\n// Slug is a helper function that returns the URL slug for string s.\n// It's used to return clean, URL-friendly strings that can be\n// used in routing.\nfunc Slug(s string, sep string) string {\n\tif s == \"\" {\n\t\treturn \"\"\n\t}\n\tslug := slugRegex.ReplaceAllString(s, sep)\n\tif slug == \"\" {\n\t\treturn \"\"\n\t}\n\tquoted := regexp.QuoteMeta(sep)\n\tsepRegex := regexp.MustCompile(\"(\" + quoted + \"){2,}\")\n\tslug = sepRegex.ReplaceAllString(slug, sep)\n\tsepEnds := regexp.MustCompile(\"^\" + quoted + \"|\" + quoted + \"$\")\n\tslug = sepEnds.ReplaceAllString(slug, \"\")\n\treturn strings.ToLower(slug)\n}\n\n// NewCookie is a helper method that returns a new http.Cookie object.\n// Duration is specified in seconds. If the duration is zero, the cookie is permanent.\n// This can be used in conjunction with ctx.SetCookie.\nfunc NewCookie(name string, value string, age int64) *http.Cookie {\n\tvar utctime time.Time\n\tif age == 0 {\n\t\t// 2^31 - 1 seconds (roughly 2038)\n\t\tutctime = time.Unix(2147483647, 0)\n\t} else {\n\t\tutctime = time.Unix(time.Now().Unix()+age, 0)\n\t}\n\treturn &http.Cookie{Name: name, Value: value, Expires: utctime}\n}\n\n// GetBasicAuth returns the decoded user and password from the context's\n// 'Authorization' header.\nfunc (ctx *Context) GetBasicAuth() (string, string, error) {\n\tif len(ctx.Request.Header[\"Authorization\"]) == 0 {\n\t\treturn \"\", \"\", errors.New(\"No Authorization header provided\")\n\t}\n\tauthHeader := ctx.Request.Header[\"Authorization\"][0]\n\tauthString := strings.Split(string(authHeader), \" \")\n\tif authString[0] != \"Basic\" {\n\t\treturn \"\", \"\", errors.New(\"Not Basic Authentication\")\n\t}\n\tdecodedAuth, err := base64.StdEncoding.DecodeString(authString[1])\n\tif err != nil {\n\t\treturn \"\", \"\", err\n\t}\n\tauthSlice := strings.Split(string(decodedAuth), \":\")\n\tif len(authSlice) != 2 {\n\t\treturn \"\", \"\", errors.New(\"Error delimiting authString into username/password. Malformed input: \" + authString[1])\n\t}\n\treturn authSlice[0], authSlice[1], nil\n}\n"
        },
        {
          "name": "scgi.go",
          "type": "blob",
          "size": 3.556640625,
          "content": "package web\n\nimport (\n\t\"bufio\"\n\t\"bytes\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"net\"\n\t\"net/http\"\n\t\"net/http/cgi\"\n\t\"strconv\"\n\t\"strings\"\n)\n\ntype scgiBody struct {\n\treader io.Reader\n\tconn   io.ReadWriteCloser\n\tclosed bool\n}\n\nfunc (b *scgiBody) Read(p []byte) (n int, err error) {\n\tif b.closed {\n\t\treturn 0, errors.New(\"SCGI read after close\")\n\t}\n\treturn b.reader.Read(p)\n}\n\nfunc (b *scgiBody) Close() error {\n\tb.closed = true\n\treturn b.conn.Close()\n}\n\ntype scgiConn struct {\n\tfd           io.ReadWriteCloser\n\treq          *http.Request\n\theaders      http.Header\n\twroteHeaders bool\n}\n\nfunc (conn *scgiConn) WriteHeader(status int) {\n\tif !conn.wroteHeaders {\n\t\tconn.wroteHeaders = true\n\n\t\tvar buf bytes.Buffer\n\t\ttext := http.StatusText(status)\n\n\t\tfmt.Fprintf(&buf, \"HTTP/1.1 %d %s\\r\\n\", status, text)\n\n\t\tfor k, v := range conn.headers {\n\t\t\tfor _, i := range v {\n\t\t\t\tbuf.WriteString(k + \": \" + i + \"\\r\\n\")\n\t\t\t}\n\t\t}\n\n\t\tbuf.WriteString(\"\\r\\n\")\n\t\tconn.fd.Write(buf.Bytes())\n\t}\n}\n\nfunc (conn *scgiConn) Header() http.Header {\n\treturn conn.headers\n}\n\nfunc (conn *scgiConn) Write(data []byte) (n int, err error) {\n\tif !conn.wroteHeaders {\n\t\tconn.WriteHeader(200)\n\t}\n\n\tif conn.req.Method == \"HEAD\" {\n\t\treturn 0, errors.New(\"Body Not Allowed\")\n\t}\n\n\treturn conn.fd.Write(data)\n}\n\nfunc (conn *scgiConn) Close() { conn.fd.Close() }\n\nfunc (conn *scgiConn) finishRequest() error {\n\tvar buf bytes.Buffer\n\tif !conn.wroteHeaders {\n\t\tconn.wroteHeaders = true\n\n\t\tfor k, v := range conn.headers {\n\t\t\tfor _, i := range v {\n\t\t\t\tbuf.WriteString(k + \": \" + i + \"\\r\\n\")\n\t\t\t}\n\t\t}\n\n\t\tbuf.WriteString(\"\\r\\n\")\n\t\tconn.fd.Write(buf.Bytes())\n\t}\n\treturn nil\n}\n\nfunc (s *Server) readScgiRequest(fd io.ReadWriteCloser) (*http.Request, error) {\n\treader := bufio.NewReader(fd)\n\tline, err := reader.ReadString(':')\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tlength, err := strconv.Atoi(line[0 : len(line)-1])\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif length > 16384 {\n\t\treturn nil, errors.New(\"Max header size is 16k\")\n\t}\n\theaderData := make([]byte, length)\n\t_, err = reader.Read(headerData)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tb, err := reader.ReadByte()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\t// discard the trailing comma\n\tif b != ',' {\n\t\treturn nil, errors.New(\"SCGI protocol error: missing comma\")\n\t}\n\theaderList := bytes.Split(headerData, []byte{0})\n\theaders := map[string]string{}\n\tfor i := 0; i < len(headerList)-1; i += 2 {\n\t\theaders[string(headerList[i])] = string(headerList[i+1])\n\t}\n\thttpReq, err := cgi.RequestFromMap(headers)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif httpReq.ContentLength > 0 {\n\t\thttpReq.Body = &scgiBody{\n\t\t\treader: io.LimitReader(reader, httpReq.ContentLength),\n\t\t\tconn:   fd,\n\t\t}\n\t} else {\n\t\thttpReq.Body = &scgiBody{reader: reader, conn: fd}\n\t}\n\treturn httpReq, nil\n}\n\nfunc (s *Server) handleScgiRequest(fd io.ReadWriteCloser) {\n\tdefer fd.Close()\n\treq, err := s.readScgiRequest(fd)\n\tif err != nil {\n\t\ts.Logger.Println(\"Error reading SCGI request: %q\", err.Error())\n\t\treturn\n\t}\n\tsc := scgiConn{fd, req, make(map[string][]string), false}\n\ts.routeHandler(req, &sc)\n\tsc.finishRequest()\n}\n\nfunc (s *Server) listenAndServeScgi(addr string) error {\n\n\tvar l net.Listener\n\tvar err error\n\n\t//if the path begins with a \"/\", assume it's a unix address\n\tif strings.HasPrefix(addr, \"/\") {\n\t\tl, err = net.Listen(\"unix\", addr)\n\t} else {\n\t\tl, err = net.Listen(\"tcp\", addr)\n\t}\n\n\t//save the listener so it can be closed\n\ts.l = l\n\n\tif err != nil {\n\t\ts.Logger.Println(\"SCGI listen error\", err.Error())\n\t\treturn err\n\t}\n\n\tfor {\n\t\tfd, err := l.Accept()\n\t\tif err != nil {\n\t\t\ts.Logger.Println(\"SCGI accept error\", err.Error())\n\t\t\treturn err\n\t\t}\n\t\tgo s.handleScgiRequest(fd)\n\t}\n\treturn nil\n}\n"
        },
        {
          "name": "secure_cookie.go",
          "type": "blob",
          "size": 2.875,
          "content": "package web\n\nimport (\n\t\"bytes\"\n\t\"crypto/aes\"\n\t\"crypto/cipher\"\n\t\"crypto/hmac\"\n\t\"crypto/rand\"\n\t\"crypto/sha512\"\n\t\"encoding/base64\"\n\t\"errors\"\n\t\"golang.org/x/crypto/pbkdf2\"\n\t\"io\"\n\t\"strings\"\n)\n\nconst (\n\tpbkdf2Iterations = 64000\n\tkeySize          = 32\n)\n\nvar (\n\tErrMissingCookieSecret = errors.New(\"Secret Key for secure cookies has not been set. Assign one to web.Config.CookieSecret.\")\n\tErrInvalidKey          = errors.New(\"The keys for secure cookies have not been initialized. Ensure that a Run* method is being called\")\n)\n\nfunc (ctx *Context) SetSecureCookie(name string, val string, age int64) error {\n\tserver := ctx.Server\n\tif len(server.Config.CookieSecret) == 0 {\n\t\treturn ErrMissingCookieSecret\n\t}\n\tif len(server.encKey) == 0 || len(server.signKey) == 0 {\n\t\treturn ErrInvalidKey\n\t}\n\tciphertext, err := encrypt([]byte(val), server.encKey)\n\tif err != nil {\n\t\treturn err\n\t}\n\tsig := sign(ciphertext, server.signKey)\n\tdata := base64.StdEncoding.EncodeToString(ciphertext) + \"|\" + base64.StdEncoding.EncodeToString(sig)\n\tctx.SetCookie(NewCookie(name, data, age))\n\treturn nil\n}\n\nfunc (ctx *Context) GetSecureCookie(name string) (string, bool) {\n\tfor _, cookie := range ctx.Request.Cookies() {\n\t\tif cookie.Name != name {\n\t\t\tcontinue\n\t\t}\n\t\tparts := strings.SplitN(cookie.Value, \"|\", 2)\n\t\tif len(parts) != 2 {\n\t\t\treturn \"\", false\n\t\t}\n\t\tciphertext, err := base64.StdEncoding.DecodeString(parts[0])\n\t\tif err != nil {\n\t\t\treturn \"\", false\n\t\t}\n\t\tsig, err := base64.StdEncoding.DecodeString(parts[1])\n\t\tif err != nil {\n\t\t\treturn \"\", false\n\t\t}\n\t\texpectedSig := sign([]byte(ciphertext), ctx.Server.signKey)\n\t\tif !bytes.Equal(expectedSig, sig) {\n\t\t\treturn \"\", false\n\t\t}\n\t\tplaintext, err := decrypt(ciphertext, ctx.Server.encKey)\n\t\tif err != nil {\n\t\t\treturn \"\", false\n\t\t}\n\t\treturn string(plaintext), true\n\t}\n\treturn \"\", false\n}\n\nfunc genKey(password string, salt string) []byte {\n\treturn pbkdf2.Key([]byte(password), []byte(salt), pbkdf2Iterations, keySize, sha512.New)\n}\n\nfunc encrypt(plaintext []byte, key []byte) ([]byte, error) {\n\taesCipher, err := aes.NewCipher(key)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tciphertext := make([]byte, aes.BlockSize+len(plaintext))\n\tiv := ciphertext[:aes.BlockSize]\n\tif _, err := io.ReadFull(rand.Reader, iv); err != nil {\n\t\treturn nil, err\n\t}\n\tstream := cipher.NewCTR(aesCipher, iv)\n\tstream.XORKeyStream(ciphertext[aes.BlockSize:], plaintext)\n\treturn ciphertext, nil\n}\n\nfunc decrypt(ciphertext []byte, key []byte) ([]byte, error) {\n\tif len(ciphertext) <= aes.BlockSize {\n\t\treturn nil, errors.New(\"Invalid cipher text\")\n\t}\n\taesCipher, err := aes.NewCipher(key)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tplaintext := make([]byte, len(ciphertext)-aes.BlockSize)\n\tstream := cipher.NewCTR(aesCipher, ciphertext[:aes.BlockSize])\n\tstream.XORKeyStream(plaintext, ciphertext[aes.BlockSize:])\n\treturn plaintext, nil\n}\n\nfunc sign(data []byte, key []byte) []byte {\n\tmac := hmac.New(sha512.New, key)\n\tmac.Write(data)\n\treturn mac.Sum(nil)\n}\n"
        },
        {
          "name": "server.go",
          "type": "blob",
          "size": 10.869140625,
          "content": "package web\n\nimport (\n\t\"bytes\"\n\t\"crypto/tls\"\n\t\"fmt\"\n\t\"golang.org/x/net/websocket\"\n\t\"log\"\n\t\"net\"\n\t\"net/http\"\n\t\"net/http/pprof\"\n\t\"os\"\n\t\"path\"\n\t\"reflect\"\n\t\"regexp\"\n\t\"runtime\"\n\t\"strconv\"\n\t\"strings\"\n\t\"time\"\n)\n\n// ServerConfig is configuration for server objects.\ntype ServerConfig struct {\n\tStaticDir    string\n\tAddr         string\n\tPort         int\n\tCookieSecret string\n\tRecoverPanic bool\n\tProfiler     bool\n\tColorOutput  bool\n}\n\n// Server represents a web.go server.\ntype Server struct {\n\tConfig *ServerConfig\n\troutes []route\n\tLogger *log.Logger\n\tEnv    map[string]interface{}\n\t//save the listener so it can be closed\n\tl       net.Listener\n\tencKey  []byte\n\tsignKey []byte\n}\n\nfunc NewServer() *Server {\n\treturn &Server{\n\t\tConfig: Config,\n\t\tLogger: log.New(os.Stdout, \"\", log.Ldate|log.Ltime),\n\t\tEnv:    map[string]interface{}{},\n\t}\n}\n\nfunc (s *Server) initServer() {\n\tif s.Config == nil {\n\t\ts.Config = &ServerConfig{}\n\t}\n\n\tif s.Logger == nil {\n\t\ts.Logger = log.New(os.Stdout, \"\", log.Ldate|log.Ltime)\n\t}\n\n\tif len(s.Config.CookieSecret) > 0 {\n\t\ts.Logger.Println(\"Generating cookie encryption keys\")\n\t\ts.encKey = genKey(s.Config.CookieSecret, \"encryption key salt\")\n\t\ts.signKey = genKey(s.Config.CookieSecret, \"signature key salt\")\n\t}\n}\n\ntype route struct {\n\tr           string\n\tcr          *regexp.Regexp\n\tmethod      string\n\thandler     reflect.Value\n\thttpHandler http.Handler\n}\n\nfunc (s *Server) addRoute(r string, method string, handler interface{}) {\n\tcr, err := regexp.Compile(r)\n\tif err != nil {\n\t\ts.Logger.Printf(\"Error in route regex %q\\n\", r)\n\t\treturn\n\t}\n\n\tswitch handler.(type) {\n\tcase http.Handler:\n\t\ts.routes = append(s.routes, route{r: r, cr: cr, method: method, httpHandler: handler.(http.Handler)})\n\tcase reflect.Value:\n\t\tfv := handler.(reflect.Value)\n\t\ts.routes = append(s.routes, route{r: r, cr: cr, method: method, handler: fv})\n\tdefault:\n\t\tfv := reflect.ValueOf(handler)\n\t\ts.routes = append(s.routes, route{r: r, cr: cr, method: method, handler: fv})\n\t}\n}\n\n// ServeHTTP is the interface method for Go's http server package\nfunc (s *Server) ServeHTTP(c http.ResponseWriter, req *http.Request) {\n\ts.Process(c, req)\n}\n\n// Process invokes the routing system for server s\nfunc (s *Server) Process(c http.ResponseWriter, req *http.Request) {\n\troute := s.routeHandler(req, c)\n\tif route != nil {\n\t\troute.httpHandler.ServeHTTP(c, req)\n\t}\n}\n\n// Get adds a handler for the 'GET' http method for server s.\nfunc (s *Server) Get(route string, handler interface{}) {\n\ts.addRoute(route, \"GET\", handler)\n}\n\n// Post adds a handler for the 'POST' http method for server s.\nfunc (s *Server) Post(route string, handler interface{}) {\n\ts.addRoute(route, \"POST\", handler)\n}\n\n// Put adds a handler for the 'PUT' http method for server s.\nfunc (s *Server) Put(route string, handler interface{}) {\n\ts.addRoute(route, \"PUT\", handler)\n}\n\n// Delete adds a handler for the 'DELETE' http method for server s.\nfunc (s *Server) Delete(route string, handler interface{}) {\n\ts.addRoute(route, \"DELETE\", handler)\n}\n\n// Match adds a handler for an arbitrary http method for server s.\nfunc (s *Server) Match(method string, route string, handler interface{}) {\n\ts.addRoute(route, method, handler)\n}\n\n// Add a custom http.Handler. Will have no effect when running as FCGI or SCGI.\nfunc (s *Server) Handle(route string, method string, httpHandler http.Handler) {\n\ts.addRoute(route, method, httpHandler)\n}\n\n//Adds a handler for websockets. Only for webserver mode. Will have no effect when running as FCGI or SCGI.\nfunc (s *Server) Websocket(route string, httpHandler websocket.Handler) {\n\ts.addRoute(route, \"GET\", httpHandler)\n}\n\n// Run starts the web application and serves HTTP requests for s\nfunc (s *Server) Run(addr string) {\n\ts.initServer()\n\n\tmux := http.NewServeMux()\n\tif s.Config.Profiler {\n\t\tmux.Handle(\"/debug/pprof/cmdline\", http.HandlerFunc(pprof.Cmdline))\n\t\tmux.Handle(\"/debug/pprof/profile\", http.HandlerFunc(pprof.Profile))\n\t\tmux.Handle(\"/debug/pprof/heap\", pprof.Handler(\"heap\"))\n\t\tmux.Handle(\"/debug/pprof/symbol\", http.HandlerFunc(pprof.Symbol))\n\t}\n\tmux.Handle(\"/\", s)\n\n\tl, err := net.Listen(\"tcp\", addr)\n\tif err != nil {\n\t\tlog.Fatal(\"ListenAndServe:\", err)\n\t}\n\n\ts.Logger.Printf(\"web.go serving %s\\n\", l.Addr())\n\n\ts.l = l\n\terr = http.Serve(s.l, mux)\n\ts.l.Close()\n}\n\n// RunFcgi starts the web application and serves FastCGI requests for s.\nfunc (s *Server) RunFcgi(addr string) {\n\ts.initServer()\n\ts.Logger.Printf(\"web.go serving fcgi %s\\n\", addr)\n\ts.listenAndServeFcgi(addr)\n}\n\n// RunScgi starts the web application and serves SCGI requests for s.\nfunc (s *Server) RunScgi(addr string) {\n\ts.initServer()\n\ts.Logger.Printf(\"web.go serving scgi %s\\n\", addr)\n\ts.listenAndServeScgi(addr)\n}\n\n// RunTLS starts the web application and serves HTTPS requests for s.\nfunc (s *Server) RunTLS(addr string, config *tls.Config) error {\n\ts.initServer()\n\tmux := http.NewServeMux()\n\tmux.Handle(\"/\", s)\n\n\tl, err := tls.Listen(\"tcp\", addr, config)\n\tif err != nil {\n\t\tlog.Fatal(\"Listen:\", err)\n\t\treturn err\n\t}\n\ts.Logger.Printf(\"web.go serving %s\\n\", l.Addr())\n\n\ts.l = l\n\treturn http.Serve(s.l, mux)\n}\n\n// Close stops server s.\nfunc (s *Server) Close() {\n\tif s.l != nil {\n\t\ts.l.Close()\n\t}\n}\n\n// safelyCall invokes `function` in recover block\nfunc (s *Server) safelyCall(function reflect.Value, args []reflect.Value) (resp []reflect.Value, e interface{}) {\n\tdefer func() {\n\t\tif err := recover(); err != nil {\n\t\t\tif !s.Config.RecoverPanic {\n\t\t\t\t// go back to panic\n\t\t\t\tpanic(err)\n\t\t\t} else {\n\t\t\t\te = err\n\t\t\t\tresp = nil\n\t\t\t\ts.Logger.Println(\"Handler crashed with error\", err)\n\t\t\t\tfor i := 1; ; i += 1 {\n\t\t\t\t\t_, file, line, ok := runtime.Caller(i)\n\t\t\t\t\tif !ok {\n\t\t\t\t\t\tbreak\n\t\t\t\t\t}\n\t\t\t\t\ts.Logger.Println(file, line)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}()\n\treturn function.Call(args), nil\n}\n\n// requiresContext determines whether 'handlerType' contains\n// an argument to 'web.Ctx' as its first argument\nfunc requiresContext(handlerType reflect.Type) bool {\n\t//if the method doesn't take arguments, no\n\tif handlerType.NumIn() == 0 {\n\t\treturn false\n\t}\n\n\t//if the first argument is not a pointer, no\n\ta0 := handlerType.In(0)\n\tif a0.Kind() != reflect.Ptr {\n\t\treturn false\n\t}\n\t//if the first argument is a context, yes\n\tif a0.Elem() == contextType {\n\t\treturn true\n\t}\n\n\treturn false\n}\n\n// tryServingFile attempts to serve a static file, and returns\n// whether or not the operation is successful.\n// It checks the following directories for the file, in order:\n// 1) Config.StaticDir\n// 2) The 'static' directory in the parent directory of the executable.\n// 3) The 'static' directory in the current working directory\nfunc (s *Server) tryServingFile(name string, req *http.Request, w http.ResponseWriter) bool {\n\t//try to serve a static file\n\tif s.Config.StaticDir != \"\" {\n\t\tstaticFile := path.Join(s.Config.StaticDir, name)\n\t\tif fileExists(staticFile) {\n\t\t\thttp.ServeFile(w, req, staticFile)\n\t\t\treturn true\n\t\t}\n\t} else {\n\t\tfor _, staticDir := range defaultStaticDirs {\n\t\t\tstaticFile := path.Join(staticDir, name)\n\t\t\tif fileExists(staticFile) {\n\t\t\t\thttp.ServeFile(w, req, staticFile)\n\t\t\t\treturn true\n\t\t\t}\n\t\t}\n\t}\n\treturn false\n}\n\nfunc (s *Server) logRequest(ctx Context, sTime time.Time) {\n\t//log the request\n\treq := ctx.Request\n\trequestPath := req.URL.Path\n\n\tduration := time.Now().Sub(sTime)\n\tvar client string\n\n\t// We suppose RemoteAddr is of the form Ip:Port as specified in the Request\n\t// documentation at http://golang.org/pkg/net/http/#Request\n\tpos := strings.LastIndex(req.RemoteAddr, \":\")\n\tif pos > 0 {\n\t\tclient = req.RemoteAddr[0:pos]\n\t} else {\n\t\tclient = req.RemoteAddr\n\t}\n\n\tvar logEntry bytes.Buffer\n\tlogEntry.WriteString(client)\n\tlogEntry.WriteString(\" - \" + s.ttyGreen(req.Method+\" \"+requestPath))\n\tlogEntry.WriteString(\" - \" + duration.String())\n\tif len(ctx.Params) > 0 {\n\t\tlogEntry.WriteString(\" - \" + s.ttyWhite(fmt.Sprintf(\"Params: %v\\n\", ctx.Params)))\n\t}\n\tctx.Server.Logger.Print(logEntry.String())\n}\n\nfunc (s *Server) ttyGreen(msg string) string {\n\treturn s.ttyColor(msg, ttyCodes.green)\n}\n\nfunc (s *Server) ttyWhite(msg string) string {\n\treturn s.ttyColor(msg, ttyCodes.white)\n}\n\nfunc (s *Server) ttyColor(msg string, colorCode string) string {\n\tif s.Config.ColorOutput {\n\t\treturn colorCode + msg + ttyCodes.reset\n\t} else {\n\t\treturn msg\n\t}\n}\n\n// the main route handler in web.go\n// Tries to handle the given request.\n// Finds the route matching the request, and execute the callback associated\n// with it.  In case of custom http handlers, this function returns an \"unused\"\n// route. The caller is then responsible for calling the httpHandler associated\n// with the returned route.\nfunc (s *Server) routeHandler(req *http.Request, w http.ResponseWriter) (unused *route) {\n\trequestPath := req.URL.Path\n\tctx := Context{req, map[string]string{}, s, w}\n\n\t//set some default headers\n\tctx.SetHeader(\"Server\", \"web.go\", true)\n\ttm := time.Now().UTC()\n\n\t//ignore errors from ParseForm because it's usually harmless.\n\treq.ParseForm()\n\tif len(req.Form) > 0 {\n\t\tfor k, v := range req.Form {\n\t\t\tctx.Params[k] = v[0]\n\t\t}\n\t}\n\n\tdefer s.logRequest(ctx, tm)\n\n\tctx.SetHeader(\"Date\", webTime(tm), true)\n\n\tif req.Method == \"GET\" || req.Method == \"HEAD\" {\n\t\tif s.tryServingFile(requestPath, req, w) {\n\t\t\treturn\n\t\t}\n\t}\n\n\tfor i := 0; i < len(s.routes); i++ {\n\t\troute := s.routes[i]\n\t\tcr := route.cr\n\t\t//if the methods don't match, skip this handler (except HEAD can be used in place of GET)\n\t\tif req.Method != route.method && !(req.Method == \"HEAD\" && route.method == \"GET\") {\n\t\t\tcontinue\n\t\t}\n\n\t\tif !cr.MatchString(requestPath) {\n\t\t\tcontinue\n\t\t}\n\t\tmatch := cr.FindStringSubmatch(requestPath)\n\n\t\tif len(match[0]) != len(requestPath) {\n\t\t\tcontinue\n\t\t}\n\n\t\tif route.httpHandler != nil {\n\t\t\tunused = &route\n\t\t\t// We can not handle custom http handlers here, give back to the caller.\n\t\t\treturn\n\t\t}\n\n\t\t// set the default content-type\n\t\tctx.SetHeader(\"Content-Type\", \"text/html; charset=utf-8\", true)\n\n\t\tvar args []reflect.Value\n\t\thandlerType := route.handler.Type()\n\t\tif requiresContext(handlerType) {\n\t\t\targs = append(args, reflect.ValueOf(&ctx))\n\t\t}\n\t\tfor _, arg := range match[1:] {\n\t\t\targs = append(args, reflect.ValueOf(arg))\n\t\t}\n\n\t\tret, err := s.safelyCall(route.handler, args)\n\t\tif err != nil {\n\t\t\t//there was an error or panic while calling the handler\n\t\t\tctx.Abort(500, \"Server Error\")\n\t\t}\n\t\tif len(ret) == 0 {\n\t\t\treturn\n\t\t}\n\n\t\tsval := ret[0]\n\n\t\tvar content []byte\n\n\t\tif sval.Kind() == reflect.String {\n\t\t\tcontent = []byte(sval.String())\n\t\t} else if sval.Kind() == reflect.Slice && sval.Type().Elem().Kind() == reflect.Uint8 {\n\t\t\tcontent = sval.Interface().([]byte)\n\t\t}\n\t\tctx.SetHeader(\"Content-Length\", strconv.Itoa(len(content)), true)\n\t\t_, err = ctx.ResponseWriter.Write(content)\n\t\tif err != nil {\n\t\t\tctx.Server.Logger.Println(\"Error during write: \", err)\n\t\t}\n\t\treturn\n\t}\n\n\t// try serving index.html or index.htm\n\tif req.Method == \"GET\" || req.Method == \"HEAD\" {\n\t\tif s.tryServingFile(path.Join(requestPath, \"index.html\"), req, w) {\n\t\t\treturn\n\t\t} else if s.tryServingFile(path.Join(requestPath, \"index.htm\"), req, w) {\n\t\t\treturn\n\t\t}\n\t}\n\tctx.Abort(404, \"Page not found\")\n\treturn\n}\n\n// SetLogger sets the logger for server s\nfunc (s *Server) SetLogger(logger *log.Logger) {\n\ts.Logger = logger\n}\n"
        },
        {
          "name": "ttycolors.go",
          "type": "blob",
          "size": 0.447265625,
          "content": "package web\n\nimport (\n\t\"golang.org/x/crypto/ssh/terminal\"\n\t\"syscall\"\n)\n\nvar ttyCodes struct {\n\tgreen string\n\twhite string\n\treset string\n}\n\nfunc init() {\n\tttyCodes.green = ttyBold(\"32\")\n\tttyCodes.white = ttyBold(\"37\")\n\tttyCodes.reset = ttyEscape(\"0\")\n}\n\nfunc ttyBold(code string) string {\n\treturn ttyEscape(\"1;\" + code)\n}\n\nfunc ttyEscape(code string) string {\n\tif terminal.IsTerminal(syscall.Stdout) {\n\t\treturn \"\\x1b[\" + code + \"m\"\n\t} else {\n\t\treturn \"\"\n\t}\n}\n"
        },
        {
          "name": "web.go",
          "type": "blob",
          "size": 6.0498046875,
          "content": "// Package web is a lightweight web framework for Go. It's ideal for\n// writing simple, performant backend web services.\npackage web\n\nimport (\n\t\"crypto/tls\"\n\t\"golang.org/x/net/websocket\"\n\t\"log\"\n\t\"mime\"\n\t\"net/http\"\n\t\"os\"\n\t\"path\"\n\t\"reflect\"\n\t\"strings\"\n)\n\n// A Context object is created for every incoming HTTP request, and is\n// passed to handlers as an optional first argument. It provides information\n// about the request, including the http.Request object, the GET and POST params,\n// and acts as a Writer for the response.\ntype Context struct {\n\tRequest *http.Request\n\tParams  map[string]string\n\tServer  *Server\n\thttp.ResponseWriter\n}\n\n// WriteString writes string data into the response object.\nfunc (ctx *Context) WriteString(content string) {\n\tctx.ResponseWriter.Write([]byte(content))\n}\n\n// Abort is a helper method that sends an HTTP header and an optional\n// body. It is useful for returning 4xx or 5xx errors.\n// Once it has been called, any return value from the handler will\n// not be written to the response.\nfunc (ctx *Context) Abort(status int, body string) {\n\tctx.SetHeader(\"Content-Type\", \"text/html; charset=utf-8\", true)\n\tctx.ResponseWriter.WriteHeader(status)\n\tctx.ResponseWriter.Write([]byte(body))\n}\n\n// Redirect is a helper method for 3xx redirects.\nfunc (ctx *Context) Redirect(status int, url_ string) {\n\tctx.ResponseWriter.Header().Set(\"Location\", url_)\n\tctx.ResponseWriter.WriteHeader(status)\n\tctx.ResponseWriter.Write([]byte(\"Redirecting to: \" + url_))\n}\n\n//BadRequest writes a 400 HTTP response\nfunc (ctx *Context) BadRequest() {\n\tctx.ResponseWriter.WriteHeader(400)\n}\n\n// Notmodified writes a 304 HTTP response\nfunc (ctx *Context) NotModified() {\n\tctx.ResponseWriter.WriteHeader(304)\n}\n\n//Unauthorized writes a 401 HTTP response\nfunc (ctx *Context) Unauthorized() {\n\tctx.ResponseWriter.WriteHeader(401)\n}\n\n//Forbidden writes a 403 HTTP response\nfunc (ctx *Context) Forbidden() {\n\tctx.ResponseWriter.WriteHeader(403)\n}\n\n// NotFound writes a 404 HTTP response\nfunc (ctx *Context) NotFound(message string) {\n\tctx.ResponseWriter.WriteHeader(404)\n\tctx.ResponseWriter.Write([]byte(message))\n}\n\n// ContentType sets the Content-Type header for an HTTP response.\n// For example, ctx.ContentType(\"json\") sets the content-type to \"application/json\"\n// If the supplied value contains a slash (/) it is set as the Content-Type\n// verbatim. The return value is the content type as it was\n// set, or an empty string if none was found.\nfunc (ctx *Context) ContentType(val string) string {\n\tvar ctype string\n\tif strings.ContainsRune(val, '/') {\n\t\tctype = val\n\t} else {\n\t\tif !strings.HasPrefix(val, \".\") {\n\t\t\tval = \".\" + val\n\t\t}\n\t\tctype = mime.TypeByExtension(val)\n\t}\n\tif ctype != \"\" {\n\t\tctx.Header().Set(\"Content-Type\", ctype)\n\t}\n\treturn ctype\n}\n\n// SetHeader sets a response header. If `unique` is true, the current value\n// of that header will be overwritten . If false, it will be appended.\nfunc (ctx *Context) SetHeader(hdr string, val string, unique bool) {\n\tif unique {\n\t\tctx.Header().Set(hdr, val)\n\t} else {\n\t\tctx.Header().Add(hdr, val)\n\t}\n}\n\n// SetCookie adds a cookie header to the response.\nfunc (ctx *Context) SetCookie(cookie *http.Cookie) {\n\tctx.SetHeader(\"Set-Cookie\", cookie.String(), false)\n}\n\n// small optimization: cache the context type instead of repeteadly calling reflect.Typeof\nvar contextType reflect.Type\n\nvar defaultStaticDirs []string\n\nfunc init() {\n\tcontextType = reflect.TypeOf(Context{})\n\t//find the location of the exe file\n\twd, _ := os.Getwd()\n\targ0 := path.Clean(os.Args[0])\n\tvar exeFile string\n\tif strings.HasPrefix(arg0, \"/\") {\n\t\texeFile = arg0\n\t} else {\n\t\t//TODO for robustness, search each directory in $PATH\n\t\texeFile = path.Join(wd, arg0)\n\t}\n\tparent, _ := path.Split(exeFile)\n\tdefaultStaticDirs = append(defaultStaticDirs, path.Join(parent, \"static\"))\n\tdefaultStaticDirs = append(defaultStaticDirs, path.Join(wd, \"static\"))\n\treturn\n}\n\n// Process invokes the main server's routing system.\nfunc Process(c http.ResponseWriter, req *http.Request) {\n\tmainServer.Process(c, req)\n}\n\n// Run starts the web application and serves HTTP requests for the main server.\nfunc Run(addr string) {\n\tmainServer.Run(addr)\n}\n\n// RunTLS starts the web application and serves HTTPS requests for the main server.\nfunc RunTLS(addr string, config *tls.Config) {\n\tmainServer.RunTLS(addr, config)\n}\n\n// RunScgi starts the web application and serves SCGI requests for the main server.\nfunc RunScgi(addr string) {\n\tmainServer.RunScgi(addr)\n}\n\n// RunFcgi starts the web application and serves FastCGI requests for the main server.\nfunc RunFcgi(addr string) {\n\tmainServer.RunFcgi(addr)\n}\n\n// Close stops the main server.\nfunc Close() {\n\tmainServer.Close()\n}\n\n// Get adds a handler for the 'GET' http method in the main server.\nfunc Get(route string, handler interface{}) {\n\tmainServer.Get(route, handler)\n}\n\n// Post adds a handler for the 'POST' http method in the main server.\nfunc Post(route string, handler interface{}) {\n\tmainServer.addRoute(route, \"POST\", handler)\n}\n\n// Put adds a handler for the 'PUT' http method in the main server.\nfunc Put(route string, handler interface{}) {\n\tmainServer.addRoute(route, \"PUT\", handler)\n}\n\n// Delete adds a handler for the 'DELETE' http method in the main server.\nfunc Delete(route string, handler interface{}) {\n\tmainServer.addRoute(route, \"DELETE\", handler)\n}\n\n// Match adds a handler for an arbitrary http method in the main server.\nfunc Match(method string, route string, handler interface{}) {\n\tmainServer.addRoute(route, method, handler)\n}\n\n// Add a custom http.Handler. Will have no effect when running as FCGI or SCGI.\nfunc Handle(route string, method string, httpHandler http.Handler) {\n\tmainServer.Handle(route, method, httpHandler)\n}\n\n//Adds a handler for websockets. Only for webserver mode. Will have no effect when running as FCGI or SCGI.\nfunc Websocket(route string, httpHandler websocket.Handler) {\n\tmainServer.Websocket(route, httpHandler)\n}\n\n// SetLogger sets the logger for the main server.\nfunc SetLogger(logger *log.Logger) {\n\tmainServer.Logger = logger\n}\n\n// Config is the configuration of the main server.\nvar Config = &ServerConfig{\n\tRecoverPanic: true,\n\tColorOutput:  true,\n}\n\nvar mainServer = NewServer()\n"
        },
        {
          "name": "web_test.go",
          "type": "blob",
          "size": 19.3212890625,
          "content": "package web\n\nimport (\n\t\"bytes\"\n\t\"encoding/base64\"\n\t\"encoding/json\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"io/ioutil\"\n\t\"log\"\n\t\"net/http\"\n\t\"net/url\"\n\t\"runtime\"\n\t\"strconv\"\n\t\"strings\"\n\t\"testing\"\n)\n\nfunc init() {\n\truntime.GOMAXPROCS(runtime.NumCPU())\n}\n\n// ioBuffer is a helper that implements io.ReadWriteCloser,\n// which is helpful in imitating a net.Conn\ntype ioBuffer struct {\n\tinput  *bytes.Buffer\n\toutput *bytes.Buffer\n\tclosed bool\n}\n\nfunc (buf *ioBuffer) Write(p []uint8) (n int, err error) {\n\tif buf.closed {\n\t\treturn 0, errors.New(\"Write after Close on ioBuffer\")\n\t}\n\treturn buf.output.Write(p)\n}\n\nfunc (buf *ioBuffer) Read(p []byte) (n int, err error) {\n\tif buf.closed {\n\t\treturn 0, errors.New(\"Read after Close on ioBuffer\")\n\t}\n\treturn buf.input.Read(p)\n}\n\n//noop\nfunc (buf *ioBuffer) Close() error {\n\tbuf.closed = true\n\treturn nil\n}\n\ntype testResponse struct {\n\tstatusCode int\n\tstatus     string\n\tbody       string\n\theaders    map[string][]string\n\tcookies    map[string]string\n}\n\nfunc buildTestResponse(buf *bytes.Buffer) *testResponse {\n\n\tresponse := testResponse{headers: make(map[string][]string), cookies: make(map[string]string)}\n\ts := buf.String()\n\tcontents := strings.SplitN(s, \"\\r\\n\\r\\n\", 2)\n\n\theader := contents[0]\n\n\tif len(contents) > 1 {\n\t\tresponse.body = contents[1]\n\t}\n\n\theaders := strings.Split(header, \"\\r\\n\")\n\n\tstatusParts := strings.SplitN(headers[0], \" \", 3)\n\tresponse.statusCode, _ = strconv.Atoi(statusParts[1])\n\n\tfor _, h := range headers[1:] {\n\t\tsplit := strings.SplitN(h, \":\", 2)\n\t\tname := strings.TrimSpace(split[0])\n\t\tvalue := strings.TrimSpace(split[1])\n\t\tif _, ok := response.headers[name]; !ok {\n\t\t\tresponse.headers[name] = []string{}\n\t\t}\n\n\t\tnewheaders := make([]string, len(response.headers[name])+1)\n\t\tcopy(newheaders, response.headers[name])\n\t\tnewheaders[len(newheaders)-1] = value\n\t\tresponse.headers[name] = newheaders\n\n\t\t//if the header is a cookie, set it\n\t\tif name == \"Set-Cookie\" {\n\t\t\ti := strings.Index(value, \";\")\n\t\t\tcookie := value[0:i]\n\t\t\tcookieParts := strings.SplitN(cookie, \"=\", 2)\n\t\t\tresponse.cookies[strings.TrimSpace(cookieParts[0])] = strings.TrimSpace(cookieParts[1])\n\t\t}\n\t}\n\n\treturn &response\n}\n\nfunc getTestResponse(method string, path string, body string, headers map[string][]string, cookies []*http.Cookie) *testResponse {\n\treq := buildTestRequest(method, path, body, headers, cookies)\n\tvar buf bytes.Buffer\n\n\ttcpb := ioBuffer{input: nil, output: &buf}\n\tc := scgiConn{wroteHeaders: false, req: req, headers: make(map[string][]string), fd: &tcpb}\n\tmainServer.Process(&c, req)\n\treturn buildTestResponse(&buf)\n}\n\nfunc testGet(path string, headers map[string]string) *testResponse {\n\tvar header http.Header\n\tfor k, v := range headers {\n\t\theader.Set(k, v)\n\t}\n\treturn getTestResponse(\"GET\", path, \"\", header, nil)\n}\n\ntype Test struct {\n\tmethod         string\n\tpath           string\n\theaders        map[string][]string\n\tbody           string\n\texpectedStatus int\n\texpectedBody   string\n}\n\n//initialize the routes\nfunc init() {\n\tmainServer.SetLogger(log.New(ioutil.Discard, \"\", 0))\n\tGet(\"/\", func() string { return \"index\" })\n\tGet(\"/panic\", func() { panic(0) })\n\tGet(\"/echo/(.*)\", func(s string) string { return s })\n\tGet(\"/multiecho/(.*)/(.*)/(.*)/(.*)\", func(a, b, c, d string) string { return a + b + c + d })\n\tPost(\"/post/echo/(.*)\", func(s string) string { return s })\n\tPost(\"/post/echoparam/(.*)\", func(ctx *Context, name string) string { return ctx.Params[name] })\n\n\tGet(\"/error/code/(.*)\", func(ctx *Context, code string) string {\n\t\tn, _ := strconv.Atoi(code)\n\t\tmessage := http.StatusText(n)\n\t\tctx.Abort(n, message)\n\t\treturn \"\"\n\t})\n\n\tGet(\"/error/notfound/(.*)\", func(ctx *Context, message string) { ctx.NotFound(message) })\n\n\tGet(\"/error/badrequest\", func(ctx *Context) { ctx.BadRequest() })\n\tPost(\"/error/badrequest\", func(ctx *Context) { ctx.BadRequest() })\n\n\tGet(\"/error/unauthorized\", func(ctx *Context) { ctx.Unauthorized() })\n\tPost(\"/error/unauthorized\", func(ctx *Context) { ctx.Unauthorized() })\n\n\tGet(\"/error/forbidden\", func(ctx *Context) { ctx.Forbidden() })\n\tPost(\"/error/forbidden\", func(ctx *Context) { ctx.Forbidden() })\n\n\tPost(\"/posterror/code/(.*)/(.*)\", func(ctx *Context, code string, message string) string {\n\t\tn, _ := strconv.Atoi(code)\n\t\tctx.Abort(n, message)\n\t\treturn \"\"\n\t})\n\n\tGet(\"/writetest\", func(ctx *Context) { ctx.WriteString(\"hello\") })\n\n\tPost(\"/securecookie/set/(.+)/(.+)\", func(ctx *Context, name string, val string) string {\n\t\tctx.SetSecureCookie(name, val, 60)\n\t\treturn \"\"\n\t})\n\n\tGet(\"/securecookie/get/(.+)\", func(ctx *Context, name string) string {\n\t\tval, ok := ctx.GetSecureCookie(name)\n\t\tif !ok {\n\t\t\treturn \"\"\n\t\t}\n\t\treturn val\n\t})\n\tGet(\"/getparam\", func(ctx *Context) string { return ctx.Params[\"a\"] })\n\tGet(\"/fullparams\", func(ctx *Context) string {\n\t\treturn strings.Join(ctx.Request.Form[\"a\"], \",\")\n\t})\n\n\tGet(\"/json\", func(ctx *Context) string {\n\t\tctx.ContentType(\"json\")\n\t\tdata, _ := json.Marshal(ctx.Params)\n\t\treturn string(data)\n\t})\n\n\tGet(\"/jsonbytes\", func(ctx *Context) []byte {\n\t\tctx.ContentType(\"json\")\n\t\tdata, _ := json.Marshal(ctx.Params)\n\t\treturn data\n\t})\n\n\tPost(\"/parsejson\", func(ctx *Context) string {\n\t\tvar tmp = struct {\n\t\t\tA string\n\t\t\tB string\n\t\t}{}\n\t\tjson.NewDecoder(ctx.Request.Body).Decode(&tmp)\n\t\treturn tmp.A + \" \" + tmp.B\n\t})\n\n\tMatch(\"OPTIONS\", \"/options\", func(ctx *Context) {\n\t\tctx.SetHeader(\"Access-Control-Allow-Methods\", \"POST, GET, OPTIONS\", true)\n\t\tctx.SetHeader(\"Access-Control-Max-Age\", \"1000\", true)\n\t\tctx.WriteHeader(200)\n\t})\n\n\tGet(\"/dupeheader\", func(ctx *Context) string {\n\t\tctx.SetHeader(\"Server\", \"myserver\", true)\n\t\treturn \"\"\n\t})\n\n\tGet(\"/authorization\", func(ctx *Context) string {\n\t\tuser, pass, err := ctx.GetBasicAuth()\n\t\tif err != nil {\n\t\t\treturn \"fail\"\n\t\t}\n\t\treturn user + pass\n\t})\n}\n\nvar tests = []Test{\n\t{\"GET\", \"/\", nil, \"\", 200, \"index\"},\n\t{\"GET\", \"/echo/hello\", nil, \"\", 200, \"hello\"},\n\t{\"GET\", \"/echo/hello\", nil, \"\", 200, \"hello\"},\n\t{\"GET\", \"/multiecho/a/b/c/d\", nil, \"\", 200, \"abcd\"},\n\t{\"POST\", \"/post/echo/hello\", nil, \"\", 200, \"hello\"},\n\t{\"POST\", \"/post/echo/hello\", nil, \"\", 200, \"hello\"},\n\t{\"POST\", \"/post/echoparam/a\", map[string][]string{\"Content-Type\": {\"application/x-www-form-urlencoded\"}}, \"a=hello\", 200, \"hello\"},\n\t{\"POST\", \"/post/echoparam/c?c=hello\", nil, \"\", 200, \"hello\"},\n\t{\"POST\", \"/post/echoparam/a\", map[string][]string{\"Content-Type\": {\"application/x-www-form-urlencoded\"}}, \"a=hello\\x00\", 200, \"hello\\x00\"},\n\t//long url\n\t{\"GET\", \"/echo/\" + strings.Repeat(\"0123456789\", 100), nil, \"\", 200, strings.Repeat(\"0123456789\", 100)},\n\t{\"GET\", \"/writetest\", nil, \"\", 200, \"hello\"},\n\t{\"GET\", \"/error/badrequest\", nil, \"\", 400, \"\"},\n\t{\"POST\", \"/error/badrequest\", nil, \"\", 400, \"\"},\n\t{\"GET\", \"/error/unauthorized\", nil, \"\", 401, \"\"},\n\t{\"POST\", \"/error/unauthorized\", nil, \"\", 401, \"\"},\n\t{\"GET\", \"/error/forbidden\", nil, \"\", 403, \"\"},\n\t{\"POST\", \"/error/forbidden\", nil, \"\", 403, \"\"},\n\t{\"GET\", \"/error/notfound/notfound\", nil, \"\", 404, \"notfound\"},\n\t{\"GET\", \"/doesnotexist\", nil, \"\", 404, \"Page not found\"},\n\t{\"POST\", \"/doesnotexist\", nil, \"\", 404, \"Page not found\"},\n\t{\"GET\", \"/error/code/500\", nil, \"\", 500, http.StatusText(500)},\n\t{\"POST\", \"/posterror/code/410/failedrequest\", nil, \"\", 410, \"failedrequest\"},\n\t{\"GET\", \"/getparam?a=abcd\", nil, \"\", 200, \"abcd\"},\n\t{\"GET\", \"/getparam?b=abcd\", nil, \"\", 200, \"\"},\n\t{\"GET\", \"/fullparams?a=1&a=2&a=3\", nil, \"\", 200, \"1,2,3\"},\n\t{\"GET\", \"/panic\", nil, \"\", 500, \"Server Error\"},\n\t{\"GET\", \"/json?a=1&b=2\", nil, \"\", 200, `{\"a\":\"1\",\"b\":\"2\"}`},\n\t{\"GET\", \"/jsonbytes?a=1&b=2\", nil, \"\", 200, `{\"a\":\"1\",\"b\":\"2\"}`},\n\t{\"POST\", \"/parsejson\", map[string][]string{\"Content-Type\": {\"application/json\"}}, `{\"a\":\"hello\", \"b\":\"world\"}`, 200, \"hello world\"},\n\t//{\"GET\", \"/testenv\", \"\", 200, \"hello world\"},\n\t{\"GET\", \"/authorization\", map[string][]string{\"Authorization\": {BuildBasicAuthCredentials(\"foo\", \"bar\")}}, \"\", 200, \"foobar\"},\n\t{\"GET\", \"/authorization\", nil, \"\", 200, \"fail\"},\n}\n\nfunc buildTestRequest(method string, path string, body string, headers map[string][]string, cookies []*http.Cookie) *http.Request {\n\thost := \"127.0.0.1\"\n\tport := \"80\"\n\trawurl := \"http://\" + host + \":\" + port + path\n\turl_, _ := url.Parse(rawurl)\n\tproto := \"HTTP/1.1\"\n\n\tif headers == nil {\n\t\theaders = map[string][]string{}\n\t}\n\n\theaders[\"User-Agent\"] = []string{\"web.go test\"}\n\tif method == \"POST\" {\n\t\theaders[\"Content-Length\"] = []string{fmt.Sprintf(\"%d\", len(body))}\n\t\tif headers[\"Content-Type\"] == nil {\n\t\t\theaders[\"Content-Type\"] = []string{\"text/plain\"}\n\t\t}\n\t}\n\n\treq := http.Request{Method: method,\n\t\tURL:    url_,\n\t\tProto:  proto,\n\t\tHost:   host,\n\t\tHeader: http.Header(headers),\n\t\tBody:   ioutil.NopCloser(bytes.NewBufferString(body)),\n\t}\n\n\tfor _, cookie := range cookies {\n\t\treq.AddCookie(cookie)\n\t}\n\treturn &req\n}\n\nfunc TestRouting(t *testing.T) {\n\tfor _, test := range tests {\n\t\tresp := getTestResponse(test.method, test.path, test.body, test.headers, nil)\n\n\t\tif resp.statusCode != test.expectedStatus {\n\t\t\tt.Fatalf(\"%v(%v) expected status %d got %d\", test.method, test.path, test.expectedStatus, resp.statusCode)\n\t\t}\n\t\tif resp.body != test.expectedBody {\n\t\t\tt.Fatalf(\"%v(%v) expected %q got %q\", test.method, test.path, test.expectedBody, resp.body)\n\t\t}\n\t\tif cl, ok := resp.headers[\"Content-Length\"]; ok {\n\t\t\tclExp, _ := strconv.Atoi(cl[0])\n\t\t\tclAct := len(resp.body)\n\t\t\tif clExp != clAct {\n\t\t\t\tt.Fatalf(\"Content-length doesn't match. expected %d got %d\", clExp, clAct)\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc TestHead(t *testing.T) {\n\tfor _, test := range tests {\n\n\t\tif test.method != \"GET\" {\n\t\t\tcontinue\n\t\t}\n\t\tgetresp := getTestResponse(\"GET\", test.path, test.body, test.headers, nil)\n\t\theadresp := getTestResponse(\"HEAD\", test.path, test.body, test.headers, nil)\n\n\t\tif getresp.statusCode != headresp.statusCode {\n\t\t\tt.Fatalf(\"head and get status differ. expected %d got %d\", getresp.statusCode, headresp.statusCode)\n\t\t}\n\t\tif len(headresp.body) != 0 {\n\t\t\tt.Fatalf(\"head request arrived with a body\")\n\t\t}\n\n\t\tvar cl []string\n\t\tvar getcl, headcl int\n\t\tvar hascl1, hascl2 bool\n\n\t\tif cl, hascl1 = getresp.headers[\"Content-Length\"]; hascl1 {\n\t\t\tgetcl, _ = strconv.Atoi(cl[0])\n\t\t}\n\n\t\tif cl, hascl2 = headresp.headers[\"Content-Length\"]; hascl2 {\n\t\t\theadcl, _ = strconv.Atoi(cl[0])\n\t\t}\n\n\t\tif hascl1 != hascl2 {\n\t\t\tt.Fatalf(\"head and get: one has content-length, one doesn't\")\n\t\t}\n\n\t\tif hascl1 == true && getcl != headcl {\n\t\t\tt.Fatalf(\"head and get content-length differ\")\n\t\t}\n\t}\n}\n\nfunc buildTestScgiRequest(method string, path string, body string, headers map[string][]string) *bytes.Buffer {\n\tvar headerBuf bytes.Buffer\n\tscgiHeaders := make(map[string]string)\n\n\theaderBuf.WriteString(\"CONTENT_LENGTH\")\n\theaderBuf.WriteByte(0)\n\theaderBuf.WriteString(fmt.Sprintf(\"%d\", len(body)))\n\theaderBuf.WriteByte(0)\n\n\tscgiHeaders[\"REQUEST_METHOD\"] = method\n\tscgiHeaders[\"HTTP_HOST\"] = \"127.0.0.1\"\n\tscgiHeaders[\"REQUEST_URI\"] = path\n\tscgiHeaders[\"SERVER_PORT\"] = \"80\"\n\tscgiHeaders[\"SERVER_PROTOCOL\"] = \"HTTP/1.1\"\n\tscgiHeaders[\"USER_AGENT\"] = \"web.go test framework\"\n\n\tfor k, v := range headers {\n\t\t//Skip content-length\n\t\tif k == \"Content-Length\" {\n\t\t\tcontinue\n\t\t}\n\t\tkey := \"HTTP_\" + strings.ToUpper(strings.Replace(k, \"-\", \"_\", -1))\n\t\tscgiHeaders[key] = v[0]\n\t}\n\tfor k, v := range scgiHeaders {\n\t\theaderBuf.WriteString(k)\n\t\theaderBuf.WriteByte(0)\n\t\theaderBuf.WriteString(v)\n\t\theaderBuf.WriteByte(0)\n\t}\n\theaderData := headerBuf.Bytes()\n\n\tvar buf bytes.Buffer\n\t//extra 1 is for the comma at the end\n\tdlen := len(headerData)\n\tfmt.Fprintf(&buf, \"%d:\", dlen)\n\tbuf.Write(headerData)\n\tbuf.WriteByte(',')\n\tbuf.WriteString(body)\n\treturn &buf\n}\n\nfunc TestScgi(t *testing.T) {\n\tfor _, test := range tests {\n\t\treq := buildTestScgiRequest(test.method, test.path, test.body, test.headers)\n\t\tvar output bytes.Buffer\n\t\tnb := ioBuffer{input: req, output: &output}\n\t\tmainServer.handleScgiRequest(&nb)\n\t\tresp := buildTestResponse(&output)\n\n\t\tif resp.statusCode != test.expectedStatus {\n\t\t\tt.Fatalf(\"expected status %d got %d\", test.expectedStatus, resp.statusCode)\n\t\t}\n\n\t\tif resp.body != test.expectedBody {\n\t\t\tt.Fatalf(\"Scgi expected %q got %q\", test.expectedBody, resp.body)\n\t\t}\n\t}\n}\n\nfunc TestScgiHead(t *testing.T) {\n\tfor _, test := range tests {\n\n\t\tif test.method != \"GET\" {\n\t\t\tcontinue\n\t\t}\n\n\t\treq := buildTestScgiRequest(\"GET\", test.path, test.body, make(map[string][]string))\n\t\tvar output bytes.Buffer\n\t\tnb := ioBuffer{input: req, output: &output}\n\t\tmainServer.handleScgiRequest(&nb)\n\t\tgetresp := buildTestResponse(&output)\n\n\t\treq = buildTestScgiRequest(\"HEAD\", test.path, test.body, make(map[string][]string))\n\t\tvar output2 bytes.Buffer\n\t\tnb = ioBuffer{input: req, output: &output2}\n\t\tmainServer.handleScgiRequest(&nb)\n\t\theadresp := buildTestResponse(&output2)\n\n\t\tif getresp.statusCode != headresp.statusCode {\n\t\t\tt.Fatalf(\"head and get status differ. expected %d got %d\", getresp.statusCode, headresp.statusCode)\n\t\t}\n\t\tif len(headresp.body) != 0 {\n\t\t\tt.Fatalf(\"head request arrived with a body\")\n\t\t}\n\n\t\tvar cl []string\n\t\tvar getcl, headcl int\n\t\tvar hascl1, hascl2 bool\n\n\t\tif cl, hascl1 = getresp.headers[\"Content-Length\"]; hascl1 {\n\t\t\tgetcl, _ = strconv.Atoi(cl[0])\n\t\t}\n\n\t\tif cl, hascl2 = headresp.headers[\"Content-Length\"]; hascl2 {\n\t\t\theadcl, _ = strconv.Atoi(cl[0])\n\t\t}\n\n\t\tif hascl1 != hascl2 {\n\t\t\tt.Fatalf(\"head and get: one has content-length, one doesn't\")\n\t\t}\n\n\t\tif hascl1 == true && getcl != headcl {\n\t\t\tt.Fatalf(\"head and get content-length differ\")\n\t\t}\n\t}\n}\n\nfunc TestReadScgiRequest(t *testing.T) {\n\theaders := map[string][]string{\"User-Agent\": {\"web.go\"}}\n\treq := buildTestScgiRequest(\"POST\", \"/hello\", \"Hello world!\", headers)\n\tvar s Server\n\thttpReq, err := s.readScgiRequest(&ioBuffer{input: req, output: nil})\n\tif err != nil {\n\t\tt.Fatalf(\"Error while reading SCGI request: \", err.Error())\n\t}\n\tif httpReq.ContentLength != 12 {\n\t\tt.Fatalf(\"Content length mismatch, expected %d, got %d \", 12, httpReq.ContentLength)\n\t}\n\tvar body bytes.Buffer\n\tio.Copy(&body, httpReq.Body)\n\tif body.String() != \"Hello world!\" {\n\t\tt.Fatalf(\"Body mismatch, expected %q, got %q \", \"Hello world!\", body.String())\n\t}\n}\n\nfunc makeCookie(vals map[string]string) []*http.Cookie {\n\tvar cookies []*http.Cookie\n\tfor k, v := range vals {\n\t\tc := &http.Cookie{\n\t\t\tName:  k,\n\t\t\tValue: v,\n\t\t}\n\t\tcookies = append(cookies, c)\n\t}\n\treturn cookies\n}\n\nfunc TestSecureCookie(t *testing.T) {\n\tmainServer.Config.CookieSecret = \"7C19QRmwf3mHZ9CPAaPQ0hsWeufKd\"\n\tmainServer.initServer()\n\tresp1 := getTestResponse(\"POST\", \"/securecookie/set/a/1\", \"\", nil, nil)\n\tsval, ok := resp1.cookies[\"a\"]\n\tif !ok {\n\t\tt.Fatalf(\"Failed to get cookie \")\n\t}\n\tcookies := makeCookie(map[string]string{\"a\": sval})\n\n\tresp2 := getTestResponse(\"GET\", \"/securecookie/get/a\", \"\", nil, cookies)\n\n\tif resp2.body != \"1\" {\n\t\tt.Fatalf(\"SecureCookie test failed\")\n\t}\n}\n\nfunc TestEmptySecureCookie(t *testing.T) {\n\tmainServer.Config.CookieSecret = \"7C19QRmwf3mHZ9CPAaPQ0hsWeufKd\"\n\tcookies := makeCookie(map[string]string{\"empty\": \"\"})\n\n\tresp2 := getTestResponse(\"GET\", \"/securecookie/get/empty\", \"\", nil, cookies)\n\n\tif resp2.body != \"\" {\n\t\tt.Fatalf(\"Expected an empty secure cookie\")\n\t}\n}\n\nfunc TestEarlyClose(t *testing.T) {\n\tvar server1 Server\n\tserver1.Close()\n}\n\nfunc TestOptions(t *testing.T) {\n\tresp := getTestResponse(\"OPTIONS\", \"/options\", \"\", nil, nil)\n\tif resp.headers[\"Access-Control-Allow-Methods\"][0] != \"POST, GET, OPTIONS\" {\n\t\tt.Fatalf(\"TestOptions - Access-Control-Allow-Methods failed\")\n\t}\n\tif resp.headers[\"Access-Control-Max-Age\"][0] != \"1000\" {\n\t\tt.Fatalf(\"TestOptions - Access-Control-Max-Age failed\")\n\t}\n}\n\nfunc TestSlug(t *testing.T) {\n\ttests := [][]string{\n\t\t{\"\", \"\"},\n\t\t{\"a\", \"a\"},\n\t\t{\"a/b\", \"a-b\"},\n\t\t{\"a b\", \"a-b\"},\n\t\t{\"a////b\", \"a-b\"},\n\t\t{\" a////b \", \"a-b\"},\n\t\t{\" Manowar / Friends \", \"manowar-friends\"},\n\t}\n\n\tfor _, test := range tests {\n\t\tv := Slug(test[0], \"-\")\n\t\tif v != test[1] {\n\t\t\tt.Fatalf(\"TestSlug(%v) failed, expected %v, got %v\", test[0], test[1], v)\n\t\t}\n\t}\n}\n\n// tests that we don't duplicate headers\nfunc TestDuplicateHeader(t *testing.T) {\n\tresp := testGet(\"/dupeheader\", nil)\n\tif len(resp.headers[\"Server\"]) > 1 {\n\t\tt.Fatalf(\"Expected only one header, got %#v\", resp.headers[\"Server\"])\n\t}\n\tif resp.headers[\"Server\"][0] != \"myserver\" {\n\t\tt.Fatalf(\"Incorrect header, exp 'myserver', got %q\", resp.headers[\"Server\"][0])\n\t}\n}\n\n// test that output contains ASCII color codes by default\nfunc TestColorOutputDefault(t *testing.T) {\n\ts := NewServer()\n\tvar logOutput bytes.Buffer\n\tlogger := log.New(&logOutput, \"\", 0)\n\ts.Logger = logger\n\ts.Get(\"/test\", func() string {\n\t\treturn \"test\"\n\t})\n\treq := buildTestRequest(\"GET\", \"/test\", \"\", nil, nil)\n\tvar buf bytes.Buffer\n\tiob := ioBuffer{input: nil, output: &buf}\n\tc := scgiConn{wroteHeaders: false, req: req, headers: make(map[string][]string), fd: &iob}\n\ts.Process(&c, req)\n\tif !strings.Contains(logOutput.String(), \"\\x1b\") {\n\t\tt.Fatalf(\"The default log output does not seem to be colored\")\n\t}\n}\n\n// test that output contains ASCII color codes by default\nfunc TestNoColorOutput(t *testing.T) {\n\ts := NewServer()\n\ts.Config.ColorOutput = false\n\tvar logOutput bytes.Buffer\n\tlogger := log.New(&logOutput, \"\", 0)\n\ts.Logger = logger\n\ts.Get(\"/test\", func() string {\n\t\treturn \"test\"\n\t})\n\treq := buildTestRequest(\"GET\", \"/test\", \"\", nil, nil)\n\tvar buf bytes.Buffer\n\tiob := ioBuffer{input: nil, output: &buf}\n\tc := scgiConn{wroteHeaders: false, req: req, headers: make(map[string][]string), fd: &iob}\n\ts.Process(&c, req)\n\tif strings.Contains(logOutput.String(), \"\\x1b\") {\n\t\tt.Fatalf(\"The log contains color escape codes\")\n\t}\n}\n\n// a malformed SCGI request should be discarded and not cause a panic\nfunc TestMaformedScgiRequest(t *testing.T) {\n\tvar headerBuf bytes.Buffer\n\n\theaderBuf.WriteString(\"CONTENT_LENGTH\")\n\theaderBuf.WriteByte(0)\n\theaderBuf.WriteString(\"0\")\n\theaderBuf.WriteByte(0)\n\theaderData := headerBuf.Bytes()\n\n\tvar buf bytes.Buffer\n\tfmt.Fprintf(&buf, \"%d:\", len(headerData))\n\tbuf.Write(headerData)\n\tbuf.WriteByte(',')\n\n\tvar output bytes.Buffer\n\tnb := ioBuffer{input: &buf, output: &output}\n\tmainServer.handleScgiRequest(&nb)\n\tif !nb.closed {\n\t\tt.Fatalf(\"The connection should have been closed\")\n\t}\n}\n\ntype TestHandler struct{}\n\nfunc (t *TestHandler) ServeHTTP(c http.ResponseWriter, req *http.Request) {\n}\n\n// When a custom HTTP handler is used, the Content-Type header should not be set to a default.\n// Go's FileHandler does not replace the Content-Type header if it is already set.\nfunc TestCustomHandlerContentType(t *testing.T) {\n\ts := NewServer()\n\ts.SetLogger(log.New(ioutil.Discard, \"\", 0))\n\ts.Handle(\"/testHandler\", \"GET\", &TestHandler{})\n\treq := buildTestRequest(\"GET\", \"/testHandler\", \"\", nil, nil)\n\tc := scgiConn{wroteHeaders: false, req: req, headers: make(map[string][]string), fd: nil}\n\ts.Process(&c, req)\n\tif c.headers[\"Content-Type\"] != nil {\n\t\tt.Fatalf(\"A default Content-Type should not be present when using a custom HTTP handler\")\n\t}\n}\n\nfunc BuildBasicAuthCredentials(user string, pass string) string {\n\ts := user + \":\" + pass\n\treturn \"Basic \" + base64.StdEncoding.EncodeToString([]byte(s))\n}\n\nfunc BenchmarkProcessGet(b *testing.B) {\n\ts := NewServer()\n\ts.SetLogger(log.New(ioutil.Discard, \"\", 0))\n\ts.Get(\"/echo/(.*)\", func(s string) string {\n\t\treturn s\n\t})\n\treq := buildTestRequest(\"GET\", \"/echo/hi\", \"\", nil, nil)\n\tvar buf bytes.Buffer\n\tiob := ioBuffer{input: nil, output: &buf}\n\tc := scgiConn{wroteHeaders: false, req: req, headers: make(map[string][]string), fd: &iob}\n\tb.ReportAllocs()\n\tb.ResetTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\ts.Process(&c, req)\n\t}\n}\n\nfunc BenchmarkProcessPost(b *testing.B) {\n\ts := NewServer()\n\ts.SetLogger(log.New(ioutil.Discard, \"\", 0))\n\ts.Post(\"/echo/(.*)\", func(s string) string {\n\t\treturn s\n\t})\n\treq := buildTestRequest(\"POST\", \"/echo/hi\", \"\", nil, nil)\n\tvar buf bytes.Buffer\n\tiob := ioBuffer{input: nil, output: &buf}\n\tc := scgiConn{wroteHeaders: false, req: req, headers: make(map[string][]string), fd: &iob}\n\tb.ReportAllocs()\n\tb.ResetTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\ts.Process(&c, req)\n\t}\n}\n"
        }
      ]
    }
  ]
}