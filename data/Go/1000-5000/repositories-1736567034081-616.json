{
  "metadata": {
    "timestamp": 1736567034081,
    "page": 616,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjYyMA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "juju/ratelimit",
      "stars": 2822,
      "defaultBranch": "master",
      "files": [
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 8.8134765625,
          "content": "All files in this repository are licensed as follows. If you contribute\nto this repository, it is assumed that you license your contribution\nunder the same license unless you state otherwise.\n\nAll files Copyright (C) 2015 Canonical Ltd. unless otherwise specified in the file.\n\nThis software is licensed under the LGPLv3, included below.\n\nAs a special exception to the GNU Lesser General Public License version 3\n(\"LGPL3\"), the copyright holders of this Library give you permission to\nconvey to a third party a Combined Work that links statically or dynamically\nto this Library without providing any Minimal Corresponding Source or\nMinimal Application Code as set out in 4d or providing the installation\ninformation set out in section 4e, provided that you comply with the other\nprovisions of LGPL3 and provided that you meet, for the Application the\nterms and conditions of the license(s) which apply to the Application.\n\nExcept as stated in this special exception, the provisions of LGPL3 will\ncontinue to comply in full to this Library. If you modify this Library, you\nmay apply this exception to your version of this Library, but you are not\nobliged to do so. If you do not wish to do so, delete this exception\nstatement from your version. This exception does not (and cannot) modify any\nlicense terms which apply to the Application, with which you must still\ncomply.\n\n\n                   GNU LESSER GENERAL PUBLIC LICENSE\n                       Version 3, 29 June 2007\n\n Copyright (C) 2007 Free Software Foundation, Inc. <http://fsf.org/>\n Everyone is permitted to copy and distribute verbatim copies\n of this license document, but changing it is not allowed.\n\n\n  This version of the GNU Lesser General Public License incorporates\nthe terms and conditions of version 3 of the GNU General Public\nLicense, supplemented by the additional permissions listed below.\n\n  0. Additional Definitions.\n\n  As used herein, \"this License\" refers to version 3 of the GNU Lesser\nGeneral Public License, and the \"GNU GPL\" refers to version 3 of the GNU\nGeneral Public License.\n\n  \"The Library\" refers to a covered work governed by this License,\nother than an Application or a Combined Work as defined below.\n\n  An \"Application\" is any work that makes use of an interface provided\nby the Library, but which is not otherwise based on the Library.\nDefining a subclass of a class defined by the Library is deemed a mode\nof using an interface provided by the Library.\n\n  A \"Combined Work\" is a work produced by combining or linking an\nApplication with the Library.  The particular version of the Library\nwith which the Combined Work was made is also called the \"Linked\nVersion\".\n\n  The \"Minimal Corresponding Source\" for a Combined Work means the\nCorresponding Source for the Combined Work, excluding any source code\nfor portions of the Combined Work that, considered in isolation, are\nbased on the Application, and not on the Linked Version.\n\n  The \"Corresponding Application Code\" for a Combined Work means the\nobject code and/or source code for the Application, including any data\nand utility programs needed for reproducing the Combined Work from the\nApplication, but excluding the System Libraries of the Combined Work.\n\n  1. Exception to Section 3 of the GNU GPL.\n\n  You may convey a covered work under sections 3 and 4 of this License\nwithout being bound by section 3 of the GNU GPL.\n\n  2. Conveying Modified Versions.\n\n  If you modify a copy of the Library, and, in your modifications, a\nfacility refers to a function or data to be supplied by an Application\nthat uses the facility (other than as an argument passed when the\nfacility is invoked), then you may convey a copy of the modified\nversion:\n\n   a) under this License, provided that you make a good faith effort to\n   ensure that, in the event an Application does not supply the\n   function or data, the facility still operates, and performs\n   whatever part of its purpose remains meaningful, or\n\n   b) under the GNU GPL, with none of the additional permissions of\n   this License applicable to that copy.\n\n  3. Object Code Incorporating Material from Library Header Files.\n\n  The object code form of an Application may incorporate material from\na header file that is part of the Library.  You may convey such object\ncode under terms of your choice, provided that, if the incorporated\nmaterial is not limited to numerical parameters, data structure\nlayouts and accessors, or small macros, inline functions and templates\n(ten or fewer lines in length), you do both of the following:\n\n   a) Give prominent notice with each copy of the object code that the\n   Library is used in it and that the Library and its use are\n   covered by this License.\n\n   b) Accompany the object code with a copy of the GNU GPL and this license\n   document.\n\n  4. Combined Works.\n\n  You may convey a Combined Work under terms of your choice that,\ntaken together, effectively do not restrict modification of the\nportions of the Library contained in the Combined Work and reverse\nengineering for debugging such modifications, if you also do each of\nthe following:\n\n   a) Give prominent notice with each copy of the Combined Work that\n   the Library is used in it and that the Library and its use are\n   covered by this License.\n\n   b) Accompany the Combined Work with a copy of the GNU GPL and this license\n   document.\n\n   c) For a Combined Work that displays copyright notices during\n   execution, include the copyright notice for the Library among\n   these notices, as well as a reference directing the user to the\n   copies of the GNU GPL and this license document.\n\n   d) Do one of the following:\n\n       0) Convey the Minimal Corresponding Source under the terms of this\n       License, and the Corresponding Application Code in a form\n       suitable for, and under terms that permit, the user to\n       recombine or relink the Application with a modified version of\n       the Linked Version to produce a modified Combined Work, in the\n       manner specified by section 6 of the GNU GPL for conveying\n       Corresponding Source.\n\n       1) Use a suitable shared library mechanism for linking with the\n       Library.  A suitable mechanism is one that (a) uses at run time\n       a copy of the Library already present on the user's computer\n       system, and (b) will operate properly with a modified version\n       of the Library that is interface-compatible with the Linked\n       Version.\n\n   e) Provide Installation Information, but only if you would otherwise\n   be required to provide such information under section 6 of the\n   GNU GPL, and only to the extent that such information is\n   necessary to install and execute a modified version of the\n   Combined Work produced by recombining or relinking the\n   Application with a modified version of the Linked Version. (If\n   you use option 4d0, the Installation Information must accompany\n   the Minimal Corresponding Source and Corresponding Application\n   Code. If you use option 4d1, you must provide the Installation\n   Information in the manner specified by section 6 of the GNU GPL\n   for conveying Corresponding Source.)\n\n  5. Combined Libraries.\n\n  You may place library facilities that are a work based on the\nLibrary side by side in a single library together with other library\nfacilities that are not Applications and are not covered by this\nLicense, and convey such a combined library under terms of your\nchoice, if you do both of the following:\n\n   a) Accompany the combined library with a copy of the same work based\n   on the Library, uncombined with any other library facilities,\n   conveyed under the terms of this License.\n\n   b) Give prominent notice with the combined library that part of it\n   is a work based on the Library, and explaining where to find the\n   accompanying uncombined form of the same work.\n\n  6. Revised Versions of the GNU Lesser General Public License.\n\n  The Free Software Foundation may publish revised and/or new versions\nof the GNU Lesser General Public License from time to time. Such new\nversions will be similar in spirit to the present version, but may\ndiffer in detail to address new problems or concerns.\n\n  Each version is given a distinguishing version number. If the\nLibrary as you received it specifies that a certain numbered version\nof the GNU Lesser General Public License \"or any later version\"\napplies to it, you have the option of following the terms and\nconditions either of that published version or of any later version\npublished by the Free Software Foundation. If the Library as you\nreceived it does not specify a version number of the GNU Lesser\nGeneral Public License, you may choose any version of the GNU Lesser\nGeneral Public License ever published by the Free Software Foundation.\n\n  If the Library as you received it specifies that a proxy can decide\nwhether future versions of the GNU Lesser General Public License shall\napply, that proxy's public statement of acceptance of any version is\npermanent authorization for you to choose that version for the\nLibrary.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 3.8466796875,
          "content": "# ratelimit\n--\n    import \"github.com/juju/ratelimit\"\n\nThe ratelimit package provides an efficient token bucket implementation. See\nhttp://en.wikipedia.org/wiki/Token_bucket.\n\n## Usage\n\n#### func  Reader\n\n```go\nfunc Reader(r io.Reader, bucket *Bucket) io.Reader\n```\nReader returns a reader that is rate limited by the given token bucket. Each\ntoken in the bucket represents one byte.\n\n#### func  Writer\n\n```go\nfunc Writer(w io.Writer, bucket *Bucket) io.Writer\n```\nWriter returns a writer that is rate limited by the given token bucket. Each\ntoken in the bucket represents one byte.\n\n#### type Bucket\n\n```go\ntype Bucket struct {\n}\n```\n\nBucket represents a token bucket that fills at a predetermined rate. Methods on\nBucket may be called concurrently.\n\n#### func  NewBucket\n\n```go\nfunc NewBucket(fillInterval time.Duration, capacity int64) *Bucket\n```\nNewBucket returns a new token bucket that fills at the rate of one token every\nfillInterval, up to the given maximum capacity. Both arguments must be positive.\nThe bucket is initially full.\n\n#### func  NewBucketWithQuantum\n\n```go\nfunc NewBucketWithQuantum(fillInterval time.Duration, capacity, quantum int64) *Bucket\n```\nNewBucketWithQuantum is similar to NewBucket, but allows the specification of\nthe quantum size - quantum tokens are added every fillInterval.\n\n#### func  NewBucketWithRate\n\n```go\nfunc NewBucketWithRate(rate float64, capacity int64) *Bucket\n```\nNewBucketWithRate returns a token bucket that fills the bucket at the rate of\nrate tokens per second up to the given maximum capacity. Because of limited\nclock resolution, at high rates, the actual rate may be up to 1% different from\nthe specified rate.\n\n#### func (*Bucket) Available\n\n```go\nfunc (tb *Bucket) Available() int64\n```\nAvailable returns the number of available tokens. It will be negative\nwhen there are consumers waiting for tokens. Note that if this\nreturns greater than zero, it does not guarantee that calls that take\ntokens from the buffer will succeed, as the number of available\ntokens could have changed in the meantime. This method is intended\nprimarily for metrics reporting and debugging.\n\n#### func (*Bucket) Rate\n\n```go\nfunc (tb *Bucket) Rate() float64\n```\nRate returns the fill rate of the bucket, in tokens per second.\n\n#### func (*Bucket) Take\n\n```go\nfunc (tb *Bucket) Take(count int64) time.Duration\n```\nTake takes count tokens from the bucket without blocking. It returns the time\nthat the caller should wait until the tokens are actually available.\n\nNote that if the request is irrevocable - there is no way to return tokens to\nthe bucket once this method commits us to taking them.\n\n#### func (*Bucket) TakeAvailable\n\n```go\nfunc (tb *Bucket) TakeAvailable(count int64) int64\n```\nTakeAvailable takes up to count immediately available tokens from the bucket. It\nreturns the number of tokens removed, or zero if there are no available tokens.\nIt does not block.\n\n#### func (*Bucket) TakeMaxDuration\n\n```go\nfunc (tb *Bucket) TakeMaxDuration(count int64, maxWait time.Duration) (time.Duration, bool)\n```\nTakeMaxDuration is like Take, except that it will only take tokens from the\nbucket if the wait time for the tokens is no greater than maxWait.\n\nIf it would take longer than maxWait for the tokens to become available, it does\nnothing and reports false, otherwise it returns the time that the caller should\nwait until the tokens are actually available, and reports true.\n\n#### func (*Bucket) Wait\n\n```go\nfunc (tb *Bucket) Wait(count int64)\n```\nWait takes count tokens from the bucket, waiting until they are available.\n\n#### func (*Bucket) WaitMaxDuration\n\n```go\nfunc (tb *Bucket) WaitMaxDuration(count int64, maxWait time.Duration) bool\n```\nWaitMaxDuration is like Wait except that it will only take tokens from the\nbucket if it needs to wait for no greater than maxWait. It reports whether any\ntokens have been removed from the bucket If no tokens have been removed, it\nreturns immediately.\n"
        },
        {
          "name": "ratelimit.go",
          "type": "blob",
          "size": 10.9765625,
          "content": "// Copyright 2014 Canonical Ltd.\n// Licensed under the LGPLv3 with static-linking exception.\n// See LICENCE file for details.\n\n// Package ratelimit provides an efficient token bucket implementation\n// that can be used to limit the rate of arbitrary things.\n// See http://en.wikipedia.org/wiki/Token_bucket.\npackage ratelimit\n\nimport (\n\t\"math\"\n\t\"strconv\"\n\t\"sync\"\n\t\"time\"\n)\n\n// The algorithm that this implementation uses does computational work\n// only when tokens are removed from the bucket, and that work completes\n// in short, bounded-constant time (Bucket.Wait benchmarks at 175ns on\n// my laptop).\n//\n// Time is measured in equal measured ticks, a given interval\n// (fillInterval) apart. On each tick a number of tokens (quantum) are\n// added to the bucket.\n//\n// When any of the methods are called the bucket updates the number of\n// tokens that are in the bucket, and it records the current tick\n// number too. Note that it doesn't record the current time - by\n// keeping things in units of whole ticks, it's easy to dish out tokens\n// at exactly the right intervals as measured from the start time.\n//\n// This allows us to calculate the number of tokens that will be\n// available at some time in the future with a few simple arithmetic\n// operations.\n//\n// The main reason for being able to transfer multiple tokens on each tick\n// is so that we can represent rates greater than 1e9 (the resolution of the Go\n// time package) tokens per second, but it's also useful because\n// it means we can easily represent situations like \"a person gets\n// five tokens an hour, replenished on the hour\".\n\n// Bucket represents a token bucket that fills at a predetermined rate.\n// Methods on Bucket may be called concurrently.\ntype Bucket struct {\n\tclock Clock\n\n\t// startTime holds the moment when the bucket was\n\t// first created and ticks began.\n\tstartTime time.Time\n\n\t// capacity holds the overall capacity of the bucket.\n\tcapacity int64\n\n\t// quantum holds how many tokens are added on\n\t// each tick.\n\tquantum int64\n\n\t// fillInterval holds the interval between each tick.\n\tfillInterval time.Duration\n\n\t// mu guards the fields below it.\n\tmu sync.Mutex\n\n\t// availableTokens holds the number of available\n\t// tokens as of the associated latestTick.\n\t// It will be negative when there are consumers\n\t// waiting for tokens.\n\tavailableTokens int64\n\n\t// latestTick holds the latest tick for which\n\t// we know the number of tokens in the bucket.\n\tlatestTick int64\n}\n\n// NewBucket returns a new token bucket that fills at the\n// rate of one token every fillInterval, up to the given\n// maximum capacity. Both arguments must be\n// positive. The bucket is initially full.\nfunc NewBucket(fillInterval time.Duration, capacity int64) *Bucket {\n\treturn NewBucketWithClock(fillInterval, capacity, nil)\n}\n\n// NewBucketWithClock is identical to NewBucket but injects a testable clock\n// interface.\nfunc NewBucketWithClock(fillInterval time.Duration, capacity int64, clock Clock) *Bucket {\n\treturn NewBucketWithQuantumAndClock(fillInterval, capacity, 1, clock)\n}\n\n// rateMargin specifes the allowed variance of actual\n// rate from specified rate. 1% seems reasonable.\nconst rateMargin = 0.01\n\n// NewBucketWithRate returns a token bucket that fills the bucket\n// at the rate of rate tokens per second up to the given\n// maximum capacity. Because of limited clock resolution,\n// at high rates, the actual rate may be up to 1% different from the\n// specified rate.\nfunc NewBucketWithRate(rate float64, capacity int64) *Bucket {\n\treturn NewBucketWithRateAndClock(rate, capacity, nil)\n}\n\n// NewBucketWithRateAndClock is identical to NewBucketWithRate but injects a\n// testable clock interface.\nfunc NewBucketWithRateAndClock(rate float64, capacity int64, clock Clock) *Bucket {\n\t// Use the same bucket each time through the loop\n\t// to save allocations.\n\ttb := NewBucketWithQuantumAndClock(1, capacity, 1, clock)\n\tfor quantum := int64(1); quantum < 1<<50; quantum = nextQuantum(quantum) {\n\t\tfillInterval := time.Duration(1e9 * float64(quantum) / rate)\n\t\tif fillInterval <= 0 {\n\t\t\tcontinue\n\t\t}\n\t\ttb.fillInterval = fillInterval\n\t\ttb.quantum = quantum\n\t\tif diff := math.Abs(tb.Rate() - rate); diff/rate <= rateMargin {\n\t\t\treturn tb\n\t\t}\n\t}\n\tpanic(\"cannot find suitable quantum for \" + strconv.FormatFloat(rate, 'g', -1, 64))\n}\n\n// nextQuantum returns the next quantum to try after q.\n// We grow the quantum exponentially, but slowly, so we\n// get a good fit in the lower numbers.\nfunc nextQuantum(q int64) int64 {\n\tq1 := q * 11 / 10\n\tif q1 == q {\n\t\tq1++\n\t}\n\treturn q1\n}\n\n// NewBucketWithQuantum is similar to NewBucket, but allows\n// the specification of the quantum size - quantum tokens\n// are added every fillInterval.\nfunc NewBucketWithQuantum(fillInterval time.Duration, capacity, quantum int64) *Bucket {\n\treturn NewBucketWithQuantumAndClock(fillInterval, capacity, quantum, nil)\n}\n\n// NewBucketWithQuantumAndClock is like NewBucketWithQuantum, but\n// also has a clock argument that allows clients to fake the passing\n// of time. If clock is nil, the system clock will be used.\nfunc NewBucketWithQuantumAndClock(fillInterval time.Duration, capacity, quantum int64, clock Clock) *Bucket {\n\tif clock == nil {\n\t\tclock = realClock{}\n\t}\n\tif fillInterval <= 0 {\n\t\tpanic(\"token bucket fill interval is not > 0\")\n\t}\n\tif capacity <= 0 {\n\t\tpanic(\"token bucket capacity is not > 0\")\n\t}\n\tif quantum <= 0 {\n\t\tpanic(\"token bucket quantum is not > 0\")\n\t}\n\treturn &Bucket{\n\t\tclock:           clock,\n\t\tstartTime:       clock.Now(),\n\t\tlatestTick:      0,\n\t\tfillInterval:    fillInterval,\n\t\tcapacity:        capacity,\n\t\tquantum:         quantum,\n\t\tavailableTokens: capacity,\n\t}\n}\n\n// Wait takes count tokens from the bucket, waiting until they are\n// available.\nfunc (tb *Bucket) Wait(count int64) {\n\tif d := tb.Take(count); d > 0 {\n\t\ttb.clock.Sleep(d)\n\t}\n}\n\n// WaitMaxDuration is like Wait except that it will\n// only take tokens from the bucket if it needs to wait\n// for no greater than maxWait. It reports whether\n// any tokens have been removed from the bucket\n// If no tokens have been removed, it returns immediately.\nfunc (tb *Bucket) WaitMaxDuration(count int64, maxWait time.Duration) bool {\n\td, ok := tb.TakeMaxDuration(count, maxWait)\n\tif d > 0 {\n\t\ttb.clock.Sleep(d)\n\t}\n\treturn ok\n}\n\nconst infinityDuration time.Duration = 0x7fffffffffffffff\n\n// Take takes count tokens from the bucket without blocking. It returns\n// the time that the caller should wait until the tokens are actually\n// available.\n//\n// Note that if the request is irrevocable - there is no way to return\n// tokens to the bucket once this method commits us to taking them.\nfunc (tb *Bucket) Take(count int64) time.Duration {\n\ttb.mu.Lock()\n\tdefer tb.mu.Unlock()\n\td, _ := tb.take(tb.clock.Now(), count, infinityDuration)\n\treturn d\n}\n\n// TakeMaxDuration is like Take, except that\n// it will only take tokens from the bucket if the wait\n// time for the tokens is no greater than maxWait.\n//\n// If it would take longer than maxWait for the tokens\n// to become available, it does nothing and reports false,\n// otherwise it returns the time that the caller should\n// wait until the tokens are actually available, and reports\n// true.\nfunc (tb *Bucket) TakeMaxDuration(count int64, maxWait time.Duration) (time.Duration, bool) {\n\ttb.mu.Lock()\n\tdefer tb.mu.Unlock()\n\treturn tb.take(tb.clock.Now(), count, maxWait)\n}\n\n// TakeAvailable takes up to count immediately available tokens from the\n// bucket. It returns the number of tokens removed, or zero if there are\n// no available tokens. It does not block.\nfunc (tb *Bucket) TakeAvailable(count int64) int64 {\n\ttb.mu.Lock()\n\tdefer tb.mu.Unlock()\n\treturn tb.takeAvailable(tb.clock.Now(), count)\n}\n\n// takeAvailable is the internal version of TakeAvailable - it takes the\n// current time as an argument to enable easy testing.\nfunc (tb *Bucket) takeAvailable(now time.Time, count int64) int64 {\n\tif count <= 0 {\n\t\treturn 0\n\t}\n\ttb.adjustavailableTokens(tb.currentTick(now))\n\tif tb.availableTokens <= 0 {\n\t\treturn 0\n\t}\n\tif count > tb.availableTokens {\n\t\tcount = tb.availableTokens\n\t}\n\ttb.availableTokens -= count\n\treturn count\n}\n\n// Available returns the number of available tokens. It will be negative\n// when there are consumers waiting for tokens. Note that if this\n// returns greater than zero, it does not guarantee that calls that take\n// tokens from the buffer will succeed, as the number of available\n// tokens could have changed in the meantime. This method is intended\n// primarily for metrics reporting and debugging.\nfunc (tb *Bucket) Available() int64 {\n\treturn tb.available(tb.clock.Now())\n}\n\n// available is the internal version of available - it takes the current time as\n// an argument to enable easy testing.\nfunc (tb *Bucket) available(now time.Time) int64 {\n\ttb.mu.Lock()\n\tdefer tb.mu.Unlock()\n\ttb.adjustavailableTokens(tb.currentTick(now))\n\treturn tb.availableTokens\n}\n\n// Capacity returns the capacity that the bucket was created with.\nfunc (tb *Bucket) Capacity() int64 {\n\treturn tb.capacity\n}\n\n// Rate returns the fill rate of the bucket, in tokens per second.\nfunc (tb *Bucket) Rate() float64 {\n\treturn 1e9 * float64(tb.quantum) / float64(tb.fillInterval)\n}\n\n// take is the internal version of Take - it takes the current time as\n// an argument to enable easy testing.\nfunc (tb *Bucket) take(now time.Time, count int64, maxWait time.Duration) (time.Duration, bool) {\n\tif count <= 0 {\n\t\treturn 0, true\n\t}\n\n\ttick := tb.currentTick(now)\n\ttb.adjustavailableTokens(tick)\n\tavail := tb.availableTokens - count\n\tif avail >= 0 {\n\t\ttb.availableTokens = avail\n\t\treturn 0, true\n\t}\n\t// Round up the missing tokens to the nearest multiple\n\t// of quantum - the tokens won't be available until\n\t// that tick.\n\n\t// endTick holds the tick when all the requested tokens will\n\t// become available.\n\tendTick := tick + (-avail+tb.quantum-1)/tb.quantum\n\tendTime := tb.startTime.Add(time.Duration(endTick) * tb.fillInterval)\n\twaitTime := endTime.Sub(now)\n\tif waitTime > maxWait {\n\t\treturn 0, false\n\t}\n\ttb.availableTokens = avail\n\treturn waitTime, true\n}\n\n// currentTick returns the current time tick, measured\n// from tb.startTime.\nfunc (tb *Bucket) currentTick(now time.Time) int64 {\n\treturn int64(now.Sub(tb.startTime) / tb.fillInterval)\n}\n\n// adjustavailableTokens adjusts the current number of tokens\n// available in the bucket at the given time, which must\n// be in the future (positive) with respect to tb.latestTick.\nfunc (tb *Bucket) adjustavailableTokens(tick int64) {\n\tlastTick := tb.latestTick\n\ttb.latestTick = tick\n\tif tb.availableTokens >= tb.capacity {\n\t\treturn\n\t}\n\ttb.availableTokens += (tick - lastTick) * tb.quantum\n\tif tb.availableTokens > tb.capacity {\n\t\ttb.availableTokens = tb.capacity\n\t}\n\treturn\n}\n\n// Clock represents the passage of time in a way that\n// can be faked out for tests.\ntype Clock interface {\n\t// Now returns the current time.\n\tNow() time.Time\n\t// Sleep sleeps for at least the given duration.\n\tSleep(d time.Duration)\n}\n\n// realClock implements Clock in terms of standard time functions.\ntype realClock struct{}\n\n// Now implements Clock.Now by calling time.Now.\nfunc (realClock) Now() time.Time {\n\treturn time.Now()\n}\n\n// Now implements Clock.Sleep by calling time.Sleep.\nfunc (realClock) Sleep(d time.Duration) {\n\ttime.Sleep(d)\n}\n"
        },
        {
          "name": "ratelimit_test.go",
          "type": "blob",
          "size": 9.755859375,
          "content": "// Copyright 2014 Canonical Ltd.\n// Licensed under the LGPLv3 with static-linking exception.\n// See LICENCE file for details.\n\npackage ratelimit\n\nimport (\n\t\"math\"\n\t\"testing\"\n\t\"time\"\n\n\tgc \"gopkg.in/check.v1\"\n)\n\nfunc TestPackage(t *testing.T) {\n\tgc.TestingT(t)\n}\n\ntype rateLimitSuite struct{}\n\nvar _ = gc.Suite(rateLimitSuite{})\n\ntype takeReq struct {\n\ttime       time.Duration\n\tcount      int64\n\texpectWait time.Duration\n}\n\nvar takeTests = []struct {\n\tabout        string\n\tfillInterval time.Duration\n\tcapacity     int64\n\treqs         []takeReq\n}{{\n\tabout:        \"serial requests\",\n\tfillInterval: 250 * time.Millisecond,\n\tcapacity:     10,\n\treqs: []takeReq{{\n\t\ttime:       0,\n\t\tcount:      0,\n\t\texpectWait: 0,\n\t}, {\n\t\ttime:       0,\n\t\tcount:      10,\n\t\texpectWait: 0,\n\t}, {\n\t\ttime:       0,\n\t\tcount:      1,\n\t\texpectWait: 250 * time.Millisecond,\n\t}, {\n\t\ttime:       250 * time.Millisecond,\n\t\tcount:      1,\n\t\texpectWait: 250 * time.Millisecond,\n\t}},\n}, {\n\tabout:        \"concurrent requests\",\n\tfillInterval: 250 * time.Millisecond,\n\tcapacity:     10,\n\treqs: []takeReq{{\n\t\ttime:       0,\n\t\tcount:      10,\n\t\texpectWait: 0,\n\t}, {\n\t\ttime:       0,\n\t\tcount:      2,\n\t\texpectWait: 500 * time.Millisecond,\n\t}, {\n\t\ttime:       0,\n\t\tcount:      2,\n\t\texpectWait: 1000 * time.Millisecond,\n\t}, {\n\t\ttime:       0,\n\t\tcount:      1,\n\t\texpectWait: 1250 * time.Millisecond,\n\t}},\n}, {\n\tabout:        \"more than capacity\",\n\tfillInterval: 1 * time.Millisecond,\n\tcapacity:     10,\n\treqs: []takeReq{{\n\t\ttime:       0,\n\t\tcount:      10,\n\t\texpectWait: 0,\n\t}, {\n\t\ttime:       20 * time.Millisecond,\n\t\tcount:      15,\n\t\texpectWait: 5 * time.Millisecond,\n\t}},\n}, {\n\tabout:        \"sub-quantum time\",\n\tfillInterval: 10 * time.Millisecond,\n\tcapacity:     10,\n\treqs: []takeReq{{\n\t\ttime:       0,\n\t\tcount:      10,\n\t\texpectWait: 0,\n\t}, {\n\t\ttime:       7 * time.Millisecond,\n\t\tcount:      1,\n\t\texpectWait: 3 * time.Millisecond,\n\t}, {\n\t\ttime:       8 * time.Millisecond,\n\t\tcount:      1,\n\t\texpectWait: 12 * time.Millisecond,\n\t}},\n}, {\n\tabout:        \"within capacity\",\n\tfillInterval: 10 * time.Millisecond,\n\tcapacity:     5,\n\treqs: []takeReq{{\n\t\ttime:       0,\n\t\tcount:      5,\n\t\texpectWait: 0,\n\t}, {\n\t\ttime:       60 * time.Millisecond,\n\t\tcount:      5,\n\t\texpectWait: 0,\n\t}, {\n\t\ttime:       60 * time.Millisecond,\n\t\tcount:      1,\n\t\texpectWait: 10 * time.Millisecond,\n\t}, {\n\t\ttime:       80 * time.Millisecond,\n\t\tcount:      2,\n\t\texpectWait: 10 * time.Millisecond,\n\t}},\n}}\n\nvar availTests = []struct {\n\tabout        string\n\tcapacity     int64\n\tfillInterval time.Duration\n\ttake         int64\n\tsleep        time.Duration\n\n\texpectCountAfterTake  int64\n\texpectCountAfterSleep int64\n}{{\n\tabout:                 \"should fill tokens after interval\",\n\tcapacity:              5,\n\tfillInterval:          time.Second,\n\ttake:                  5,\n\tsleep:                 time.Second,\n\texpectCountAfterTake:  0,\n\texpectCountAfterSleep: 1,\n}, {\n\tabout:                 \"should fill tokens plus existing count\",\n\tcapacity:              2,\n\tfillInterval:          time.Second,\n\ttake:                  1,\n\tsleep:                 time.Second,\n\texpectCountAfterTake:  1,\n\texpectCountAfterSleep: 2,\n}, {\n\tabout:                 \"shouldn't fill before interval\",\n\tcapacity:              2,\n\tfillInterval:          2 * time.Second,\n\ttake:                  1,\n\tsleep:                 time.Second,\n\texpectCountAfterTake:  1,\n\texpectCountAfterSleep: 1,\n}, {\n\tabout:                 \"should fill only once after 1*interval before 2*interval\",\n\tcapacity:              2,\n\tfillInterval:          2 * time.Second,\n\ttake:                  1,\n\tsleep:                 3 * time.Second,\n\texpectCountAfterTake:  1,\n\texpectCountAfterSleep: 2,\n}}\n\nfunc (rateLimitSuite) TestTake(c *gc.C) {\n\tfor i, test := range takeTests {\n\t\ttb := NewBucket(test.fillInterval, test.capacity)\n\t\tfor j, req := range test.reqs {\n\t\t\td, ok := tb.take(tb.startTime.Add(req.time), req.count, infinityDuration)\n\t\t\tc.Assert(ok, gc.Equals, true)\n\t\t\tif d != req.expectWait {\n\t\t\t\tc.Fatalf(\"test %d.%d, %s, got %v want %v\", i, j, test.about, d, req.expectWait)\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc (rateLimitSuite) TestTakeMaxDuration(c *gc.C) {\n\tfor i, test := range takeTests {\n\t\ttb := NewBucket(test.fillInterval, test.capacity)\n\t\tfor j, req := range test.reqs {\n\t\t\tif req.expectWait > 0 {\n\t\t\t\td, ok := tb.take(tb.startTime.Add(req.time), req.count, req.expectWait-1)\n\t\t\t\tc.Assert(ok, gc.Equals, false)\n\t\t\t\tc.Assert(d, gc.Equals, time.Duration(0))\n\t\t\t}\n\t\t\td, ok := tb.take(tb.startTime.Add(req.time), req.count, req.expectWait)\n\t\t\tc.Assert(ok, gc.Equals, true)\n\t\t\tif d != req.expectWait {\n\t\t\t\tc.Fatalf(\"test %d.%d, %s, got %v want %v\", i, j, test.about, d, req.expectWait)\n\t\t\t}\n\t\t}\n\t}\n}\n\ntype takeAvailableReq struct {\n\ttime   time.Duration\n\tcount  int64\n\texpect int64\n}\n\nvar takeAvailableTests = []struct {\n\tabout        string\n\tfillInterval time.Duration\n\tcapacity     int64\n\treqs         []takeAvailableReq\n}{{\n\tabout:        \"serial requests\",\n\tfillInterval: 250 * time.Millisecond,\n\tcapacity:     10,\n\treqs: []takeAvailableReq{{\n\t\ttime:   0,\n\t\tcount:  0,\n\t\texpect: 0,\n\t}, {\n\t\ttime:   0,\n\t\tcount:  10,\n\t\texpect: 10,\n\t}, {\n\t\ttime:   0,\n\t\tcount:  1,\n\t\texpect: 0,\n\t}, {\n\t\ttime:   250 * time.Millisecond,\n\t\tcount:  1,\n\t\texpect: 1,\n\t}},\n}, {\n\tabout:        \"concurrent requests\",\n\tfillInterval: 250 * time.Millisecond,\n\tcapacity:     10,\n\treqs: []takeAvailableReq{{\n\t\ttime:   0,\n\t\tcount:  5,\n\t\texpect: 5,\n\t}, {\n\t\ttime:   0,\n\t\tcount:  2,\n\t\texpect: 2,\n\t}, {\n\t\ttime:   0,\n\t\tcount:  5,\n\t\texpect: 3,\n\t}, {\n\t\ttime:   0,\n\t\tcount:  1,\n\t\texpect: 0,\n\t}},\n}, {\n\tabout:        \"more than capacity\",\n\tfillInterval: 1 * time.Millisecond,\n\tcapacity:     10,\n\treqs: []takeAvailableReq{{\n\t\ttime:   0,\n\t\tcount:  10,\n\t\texpect: 10,\n\t}, {\n\t\ttime:   20 * time.Millisecond,\n\t\tcount:  15,\n\t\texpect: 10,\n\t}},\n}, {\n\tabout:        \"within capacity\",\n\tfillInterval: 10 * time.Millisecond,\n\tcapacity:     5,\n\treqs: []takeAvailableReq{{\n\t\ttime:   0,\n\t\tcount:  5,\n\t\texpect: 5,\n\t}, {\n\t\ttime:   60 * time.Millisecond,\n\t\tcount:  5,\n\t\texpect: 5,\n\t}, {\n\t\ttime:   70 * time.Millisecond,\n\t\tcount:  1,\n\t\texpect: 1,\n\t}},\n}}\n\nfunc (rateLimitSuite) TestTakeAvailable(c *gc.C) {\n\tfor i, test := range takeAvailableTests {\n\t\ttb := NewBucket(test.fillInterval, test.capacity)\n\t\tfor j, req := range test.reqs {\n\t\t\td := tb.takeAvailable(tb.startTime.Add(req.time), req.count)\n\t\t\tif d != req.expect {\n\t\t\t\tc.Fatalf(\"test %d.%d, %s, got %v want %v\", i, j, test.about, d, req.expect)\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc (rateLimitSuite) TestPanics(c *gc.C) {\n\tc.Assert(func() { NewBucket(0, 1) }, gc.PanicMatches, \"token bucket fill interval is not > 0\")\n\tc.Assert(func() { NewBucket(-2, 1) }, gc.PanicMatches, \"token bucket fill interval is not > 0\")\n\tc.Assert(func() { NewBucket(1, 0) }, gc.PanicMatches, \"token bucket capacity is not > 0\")\n\tc.Assert(func() { NewBucket(1, -2) }, gc.PanicMatches, \"token bucket capacity is not > 0\")\n}\n\nfunc isCloseTo(x, y, tolerance float64) bool {\n\treturn math.Abs(x-y)/y < tolerance\n}\n\nfunc (rateLimitSuite) TestRate(c *gc.C) {\n\ttb := NewBucket(1, 1)\n\tif !isCloseTo(tb.Rate(), 1e9, 0.00001) {\n\t\tc.Fatalf(\"got %v want 1e9\", tb.Rate())\n\t}\n\ttb = NewBucket(2*time.Second, 1)\n\tif !isCloseTo(tb.Rate(), 0.5, 0.00001) {\n\t\tc.Fatalf(\"got %v want 0.5\", tb.Rate())\n\t}\n\ttb = NewBucketWithQuantum(100*time.Millisecond, 1, 5)\n\tif !isCloseTo(tb.Rate(), 50, 0.00001) {\n\t\tc.Fatalf(\"got %v want 50\", tb.Rate())\n\t}\n}\n\nfunc checkRate(c *gc.C, rate float64) {\n\ttb := NewBucketWithRate(rate, 1<<62)\n\tif !isCloseTo(tb.Rate(), rate, rateMargin) {\n\t\tc.Fatalf(\"got %g want %v\", tb.Rate(), rate)\n\t}\n\td, ok := tb.take(tb.startTime, 1<<62, infinityDuration)\n\tc.Assert(ok, gc.Equals, true)\n\tc.Assert(d, gc.Equals, time.Duration(0))\n\n\t// Check that the actual rate is as expected by\n\t// asking for a not-quite multiple of the bucket's\n\t// quantum and checking that the wait time\n\t// correct.\n\td, ok = tb.take(tb.startTime, tb.quantum*2-tb.quantum/2, infinityDuration)\n\tc.Assert(ok, gc.Equals, true)\n\texpectTime := 1e9 * float64(tb.quantum) * 2 / rate\n\tif !isCloseTo(float64(d), expectTime, rateMargin) {\n\t\tc.Fatalf(\"rate %g: got %g want %v\", rate, float64(d), expectTime)\n\t}\n}\n\nfunc (rateLimitSuite) NewBucketWithRate(c *gc.C) {\n\tfor rate := float64(1); rate < 1e6; rate += 7 {\n\t\tcheckRate(c, rate)\n\t}\n\tfor _, rate := range []float64{\n\t\t1024 * 1024 * 1024,\n\t\t1e-5,\n\t\t0.9e-5,\n\t\t0.5,\n\t\t0.9,\n\t\t0.9e8,\n\t\t3e12,\n\t\t4e18,\n\t\tfloat64(1<<63 - 1),\n\t} {\n\t\tcheckRate(c, rate)\n\t\tcheckRate(c, rate/3)\n\t\tcheckRate(c, rate*1.3)\n\t}\n}\n\nfunc TestAvailable(t *testing.T) {\n\tfor i, tt := range availTests {\n\t\ttb := NewBucket(tt.fillInterval, tt.capacity)\n\t\tif c := tb.takeAvailable(tb.startTime, tt.take); c != tt.take {\n\t\t\tt.Fatalf(\"#%d: %s, take = %d, want = %d\", i, tt.about, c, tt.take)\n\t\t}\n\t\tif c := tb.available(tb.startTime); c != tt.expectCountAfterTake {\n\t\t\tt.Fatalf(\"#%d: %s, after take, available = %d, want = %d\", i, tt.about, c, tt.expectCountAfterTake)\n\t\t}\n\t\tif c := tb.available(tb.startTime.Add(tt.sleep)); c != tt.expectCountAfterSleep {\n\t\t\tt.Fatalf(\"#%d: %s, after some time it should fill in new tokens, available = %d, want = %d\",\n\t\t\t\ti, tt.about, c, tt.expectCountAfterSleep)\n\t\t}\n\t}\n\n}\n\nfunc TestNoBonusTokenAfterBucketIsFull(t *testing.T) {\n\ttb := NewBucketWithQuantum(time.Second*1, 100, 20)\n\tcurAvail := tb.Available()\n\tif curAvail != 100 {\n\t\tt.Fatalf(\"initially: actual available = %d, expected = %d\", curAvail, 100)\n\t}\n\n\ttime.Sleep(time.Second * 5)\n\n\tcurAvail = tb.Available()\n\tif curAvail != 100 {\n\t\tt.Fatalf(\"after pause: actual available = %d, expected = %d\", curAvail, 100)\n\t}\n\n\tcnt := tb.TakeAvailable(100)\n\tif cnt != 100 {\n\t\tt.Fatalf(\"taking: actual taken count = %d, expected = %d\", cnt, 100)\n\t}\n\n\tcurAvail = tb.Available()\n\tif curAvail != 0 {\n\t\tt.Fatalf(\"after taken: actual available = %d, expected = %d\", curAvail, 0)\n\t}\n}\n\nfunc BenchmarkWait(b *testing.B) {\n\ttb := NewBucket(1, 16*1024)\n\tfor i := b.N - 1; i >= 0; i-- {\n\t\ttb.Wait(1)\n\t}\n}\n\nfunc BenchmarkNewBucket(b *testing.B) {\n\tfor i := b.N - 1; i >= 0; i-- {\n\t\tNewBucketWithRate(4e18, 1<<62)\n\t}\n}\n"
        },
        {
          "name": "reader.go",
          "type": "blob",
          "size": 0.9755859375,
          "content": "// Copyright 2014 Canonical Ltd.\n// Licensed under the LGPLv3 with static-linking exception.\n// See LICENCE file for details.\n\npackage ratelimit\n\nimport \"io\"\n\ntype reader struct {\n\tr      io.Reader\n\tbucket *Bucket\n}\n\n// Reader returns a reader that is rate limited by\n// the given token bucket. Each token in the bucket\n// represents one byte.\nfunc Reader(r io.Reader, bucket *Bucket) io.Reader {\n\treturn &reader{\n\t\tr:      r,\n\t\tbucket: bucket,\n\t}\n}\n\nfunc (r *reader) Read(buf []byte) (int, error) {\n\tn, err := r.r.Read(buf)\n\tif n <= 0 {\n\t\treturn n, err\n\t}\n\tr.bucket.Wait(int64(n))\n\treturn n, err\n}\n\ntype writer struct {\n\tw      io.Writer\n\tbucket *Bucket\n}\n\n// Writer returns a reader that is rate limited by\n// the given token bucket. Each token in the bucket\n// represents one byte.\nfunc Writer(w io.Writer, bucket *Bucket) io.Writer {\n\treturn &writer{\n\t\tw:      w,\n\t\tbucket: bucket,\n\t}\n}\n\nfunc (w *writer) Write(buf []byte) (int, error) {\n\tw.bucket.Wait(int64(len(buf)))\n\treturn w.w.Write(buf)\n}\n"
        }
      ]
    }
  ]
}