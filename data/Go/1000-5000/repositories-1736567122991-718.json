{
  "metadata": {
    "timestamp": 1736567122991,
    "page": 718,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjcyMA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "signintech/gopdf",
      "stars": 2619,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.7060546875,
          "content": "##android\n# built application files\n*.apk\n*.ap_\n\n# files for the dex VM\n*.dex\n\n# Java class files\n*.class\n\n# generated files\nbin/\ngen/\npkg/\n*.jar\n# Local configuration file (sdk path, etc)\nlocal.properties\n\n##eclipse\n*.pydevproject\n.project\n.metadata\nbin/**\ntmp/**\ntmp/**/*\n*.tmp\n*.bak\n*.swp\n*~.nib\nlocal.properties\n.classpath\n.settings/\n.loadpath\n\n# External tool builders\n.externalToolBuilders/\n\n# Locally stored \"Eclipse launch configurations\"\n*.launch\n\n# CDT-specific\n.cproject\n\n# PDT-specific\n.buildpath\n\n##tmp\n*~\n*.bak\n\nproguard-project.txt\n/project.properties\nlint.xml\n.bzr\n\nfontmaker/tmp/\nfontmaker/fontmaker\nfontmaker/ttf/\n\n*.orig\n\n.vscode\ntest/out/\ntest/debug.test\n*.test\n*.out\n.DS_Store\n.idea\n.scannerwork\n\n*.pdf"
        },
        {
          "name": "Changelog.md",
          "type": "blob",
          "size": 0.1279296875,
          "content": "### May 2016\n\nRemove old function\n- ```GoPdf.AddFont(family string, ifont IFont, zfontpath string)```.\n- Remove all font map file.\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.052734375,
          "content": "The MIT License (MIT)\n\nCopyright (c) 2015 signintech\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 12.26171875,
          "content": "# gopdf\n\ngopdf is a simple library for generating PDF document written in Go lang.\n\nA minimum version of Go 1.13 is required.\n\n#### Features\n\n- Unicode subfont embedding. (Chinese, Japanese, Korean, etc.)\n- Draw line, oval, rect, curve\n- Draw image ( jpg, png )\n  - Set image mask\n- Password protection\n- Font [kerning](https://en.wikipedia.org/wiki/Kerning)\n\n## Installation\n\n```\ngo get -u github.com/signintech/gopdf\n```\n\n### Print text\n\n```go\n\npackage main\nimport (\n\t\"log\"\n\t\"github.com/signintech/gopdf\"\n)\n\nfunc main() {\n\n\tpdf := gopdf.GoPdf{}\n\tpdf.Start(gopdf.Config{ PageSize: *gopdf.PageSizeA4 })\n\tpdf.AddPage()\n\terr := pdf.AddTTFFont(\"wts11\", \"../ttf/wts11.ttf\")\n\tif err != nil {\n\t\tlog.Print(err.Error())\n\t\treturn\n\t}\n\n\terr = pdf.SetFont(\"wts11\", \"\", 14)\n\tif err != nil {\n\t\tlog.Print(err.Error())\n\t\treturn\n\t}\n\tpdf.Cell(nil, \"您好\")\n\tpdf.WritePdf(\"hello.pdf\")\n\n}\n\n```\n\n### Set text color using RGB color model\n\n```go\npdf.SetTextColor(156, 197, 140)\npdf.Cell(nil, \"您好\")\n```\n\n### Set text color using CMYK color model\n\n```go\npdf.SetTextColorCMYK(0, 6, 14, 0)\npdf.Cell(nil, \"Hello\")\n```\n\n### Image\n\n```go\n\npackage main\nimport (\n\t\"log\"\n\t\"github.com/signintech/gopdf\"\n)\n\nfunc main() {\n\tpdf := gopdf.GoPdf{}\n\tpdf.Start(gopdf.Config{PageSize: *gopdf.PageSizeA4 })\n\tpdf.AddPage()\n\tvar err error\n\terr = pdf.AddTTFFont(\"loma\", \"../ttf/Loma.ttf\")\n\tif err != nil {\n\t\tlog.Print(err.Error())\n\t\treturn\n\t}\n\n\tpdf.Image(\"../imgs/gopher.jpg\", 200, 50, nil) //print image\n\terr = pdf.SetFont(\"loma\", \"\", 14)\n\tif err != nil {\n\t\tlog.Print(err.Error())\n\t\treturn\n\t}\n\tpdf.SetXY(250, 200) //move current location\n\tpdf.Cell(nil, \"gopher and gopher\") //print text\n\n\tpdf.WritePdf(\"image.pdf\")\n}\n```\n\n### Links\n\n```go\n\npackage main\n\nimport (\n\t\"log\"\n\t\"github.com/signintech/gopdf\"\n)\n\nfunc main()  {\n\tpdf := gopdf.GoPdf{}\n\tpdf.Start(gopdf.Config{ PageSize: *gopdf.PageSizeA4 })\n\tpdf.AddPage()\n\terr := pdf.AddTTFFont(\"times\", \"./test/res/times.ttf\")\n\tif err != nil {\n\t\tlog.Print(err.Error())\n\t\treturn\n\t}\n\n\terr = pdf.SetFont(\"times\", \"\", 14)\n\tif err != nil {\n\t\tlog.Print(err.Error())\n\t\treturn\n\t}\n\n\tpdf.SetXY(30, 40)\n\tpdf.Text(\"Link to example.com\")\n\tpdf.AddExternalLink(\"http://example.com/\", 27.5, 28, 125, 15)\n\n\tpdf.SetXY(30, 70)\n\tpdf.Text(\"Link to second page\")\n\tpdf.AddInternalLink(\"anchor\", 27.5, 58, 120, 15)\n\n\tpdf.AddPage()\n\tpdf.SetXY(30, 100)\n\tpdf.SetAnchor(\"anchor\")\n\tpdf.Text(\"Anchor position\")\n\n\tpdf.WritePdf(\"hello.tmp.pdf\")\n\n}\n```\n\n### Header and Footer\n\n```go\n\npackage main\n\nimport (\n    \"log\"\n    \"github.com/signintech/gopdf\"\n)\n\nfunc main() {\n    pdf := gopdf.GoPdf{}\n    pdf.Start(gopdf.Config{ PageSize: *gopdf.PageSizeA4 })\n\n    err := pdf.AddTTFFont(\"font1\", \"./test/res/font1.ttf\")\n    if err != nil {\n        log.Print(err.Error())\n        return\n    }\n\n    err = pdf.SetFont(\"font1\", \"\", 14)\n    if err != nil {\n        log.Print(err.Error())\n        return\n    }\n\n    pdf.AddHeader(func() {\n        pdf.SetY(5)\n        pdf.Cell(nil, \"header\")\n    })\n    pdf.AddFooter(func() {\n        pdf.SetY(825)\n        pdf.Cell(nil, \"footer\")\n    })\n\n    pdf.AddPage()\n    pdf.SetY(400)\n    pdf.Text(\"page 1 content\")\n    pdf.AddPage()\n    pdf.SetY(400)\n    pdf.Text(\"page 2 content\")\n\n    pdf.WritePdf(\"header-footer.tmp.pdf\")\n\n}\n\n```\n\n### Draw line\n\n```go\npdf.SetLineWidth(2)\npdf.SetLineType(\"dashed\")\npdf.Line(10, 30, 585, 30)\n```\n\n### Draw oval\n\n```go\npdf.SetLineWidth(1)\npdf.Oval(100, 200, 500, 500)\n```\n\n### Draw polygon\n\n```go\npdf.SetStrokeColor(255, 0, 0)\npdf.SetLineWidth(2)\npdf.SetFillColor(0, 255, 0)\npdf.Polygon([]gopdf.Point{{X: 10, Y: 30}, {X: 585, Y: 200}, {X: 585, Y: 250}}, \"DF\")\n```\n\n### Draw rectangle with round corner\n\n```go\npdf.SetStrokeColor(255, 0, 0)\npdf.SetLineWidth(2)\npdf.SetFillColor(0, 255, 0)\nerr := pdf.Rectangle(196.6, 336.8, 398.3, 379.3, \"DF\", 3, 10)\nif err != nil {\n\treturn err\n}\n```\n\n### Draw rectangle with round corner using CMYK color model\n\n```go\npdf.SetStrokeColorCMYK(88, 49, 0, 0)\npdf.SetLineWidth(2)\npdf.SetFillColorCMYK(0, 5, 89, 0)\nerr := pdf.Rectangle(196.6, 336.8, 398.3, 379.3, \"DF\", 3, 10)\nif err != nil {\n\treturn err\n}\n```\n\n### Rotation text or image\n\n```go\npdf.SetXY(100, 100)\npdf.Rotate(270.0, 100.0, 100.0)\npdf.Text(\"Hello...\")\npdf.RotateReset() //reset\n```\n\n### Set transparency\n\nRead about [transparency in pdf](https://www.adobe.com/content/dam/acom/en/devnet/acrobat/pdfs/PDF32000_2008.pdf) `(page 320, section 11)`\n\n```go\n// alpha - value of transparency, can be between `0` and `1`\n// blendMode - default value is `/Normal` - read about [blendMode and kinds of its](https://www.adobe.com/content/dam/acom/en/devnet/acrobat/pdfs/PDF32000_2008.pdf) `(page 325, section 11.3.5)`\n\ntransparency := Transparency{\n\tAlpha: 0.5,\n\tBlendModeType: \"\",\n}\npdf.SetTransparency(transparency Transparency)\n```\n\n### Password protection\n\n```go\npackage main\n\nimport (\n\t\"log\"\n\n\t\"github.com/signintech/gopdf\"\n)\n\n\nfunc main() {\n\n\tpdf := gopdf.GoPdf{}\n\tpdf.Start(gopdf.Config{\n\t\tPageSize: *gopdf.PageSizeA4,\n\t\tProtection: gopdf.PDFProtectionConfig{\n\t\t\tUseProtection: true,\n\t\t\tPermissions: gopdf.PermissionsPrint | gopdf.PermissionsCopy | gopdf.PermissionsModify,\n\t\t\tOwnerPass:   []byte(\"123456\"),\n\t\t\tUserPass:    []byte(\"123456789\")},\n\t})\n\n\tpdf.AddPage()\n\tpdf.AddTTFFont(\"loma\", \"../ttf/loma.ttf\")\n\tpdf.Cell(nil,\"Hi\")\n\tpdf.WritePdf(\"protect.pdf\")\n}\n\n```\n\n### Import existing PDF\n\nImport existing PDF power by package [gofpdi](https://github.com/phpdave11/gofpdi) created by @phpdave11 (thank you :smile:)\n\n```go\npackage main\n\nimport (\n        \"github.com/signintech/gopdf\"\n        \"io\"\n        \"net/http\"\n        \"os\"\n)\n\nfunc main() {\n        var err error\n\n        // Download a Font\n        fontUrl := \"https://github.com/google/fonts/raw/master/ofl/daysone/DaysOne-Regular.ttf\"\n        if err = DownloadFile(\"example-font.ttf\", fontUrl); err != nil {\n            panic(err)\n        }\n\n        // Download a PDF\n        fileUrl := \"https://tcpdf.org/files/examples/example_012.pdf\"\n        if err = DownloadFile(\"example-pdf.pdf\", fileUrl); err != nil {\n            panic(err)\n        }\n\n        pdf := gopdf.GoPdf{}\n        pdf.Start(gopdf.Config{PageSize: *gopdf.PageSizeA4})\n\n        pdf.AddPage()\n\n        err = pdf.AddTTFFont(\"daysone\", \"example-font.ttf\")\n        if err != nil {\n            panic(err)\n        }\n\n        err = pdf.SetFont(\"daysone\", \"\", 20)\n        if err != nil {\n            panic(err)\n        }\n\n        // Color the page\n        pdf.SetLineWidth(0.1)\n        pdf.SetFillColor(124, 252, 0) //setup fill color\n        pdf.RectFromUpperLeftWithStyle(50, 100, 400, 600, \"FD\")\n        pdf.SetFillColor(0, 0, 0)\n\n        pdf.SetXY(50, 50)\n        pdf.Cell(nil, \"Import existing PDF into GoPDF Document\")\n\n        // Import page 1\n        tpl1 := pdf.ImportPage(\"example-pdf.pdf\", 1, \"/MediaBox\")\n\n        // Draw pdf onto page\n        pdf.UseImportedTemplate(tpl1, 50, 100, 400, 0)\n\n        pdf.WritePdf(\"example.pdf\")\n\n}\n\n// DownloadFile will download a url to a local file. It's efficient because it will\n// write as it downloads and not load the whole file into memory.\nfunc DownloadFile(filepath string, url string) error {\n        // Get the data\n        resp, err := http.Get(url)\n        if err != nil {\n            return err\n        }\n        defer resp.Body.Close()\n\n        // Create the file\n        out, err := os.Create(filepath)\n        if err != nil {\n            return err\n        }\n        defer out.Close()\n\n        // Write the body to file\n        _, err = io.Copy(out, resp.Body)\n        return err\n}\n\n```\n\n### Possible to set [Trim-box](https://wiki.scribus.net/canvas/PDF_Boxes_:_mediabox,_cropbox,_bleedbox,_trimbox,_artbox)\n\n```go\npackage main\n\nimport (\n\t\"log\"\n\n\t\"github.com/signintech/gopdf\"\n)\n\nfunc main() {\n\n    pdf := gopdf.GoPdf{}\n    mm6ToPx := 22.68\n\n    // Base trim-box\n    pdf.Start(gopdf.Config{\n        PageSize: *gopdf.PageSizeA4,\n        TrimBox: gopdf.Box{Left: mm6ToPx, Top: mm6ToPx, Right: gopdf.PageSizeA4.W - mm6ToPx, Bottom: gopdf.PageSizeA4.H - mm6ToPx},\n    })\n\n    // Page trim-box\n    opt := gopdf.PageOption{\n        PageSize: *gopdf.PageSizeA4,\n        TrimBox: &gopdf.Box{Left: mm6ToPx, Top: mm6ToPx, Right: gopdf.PageSizeA4.W - mm6ToPx, Bottom: gopdf.PageSizeA4.H - mm6ToPx},\n    }\n    pdf.AddPageWithOption(opt)\n\n    if err := pdf.AddTTFFont(\"wts11\", \"../ttf/wts11.ttf\"); err != nil {\n        log.Print(err.Error())\n        return\n    }\n\n    if err := pdf.SetFont(\"wts11\", \"\", 14); err != nil {\n        log.Print(err.Error())\n        return\n    }\n\n    pdf.Cell(nil,\"Hi\")\n    pdf.WritePdf(\"hello.pdf\")\n}\n\n```\n\n### Placeholder.\n\n> this function(s) made for experimental. There may be changes in the future.\n\nWith the placeholder function(s), you can create a placeholder to define a position. To make room for text to be add later.\n\nThere are 2 related function(s):\n\n- **PlaceHolderText(...)** used to create a placeholder to fill in text later.\n- **FillInPlaceHoldText(...)** used for filling in text into the placeholder that was created with **PlaceHolderText**.\n\nUse case: For example, when you want to print the \"total number of pages\" on every page in pdf file, but you don't know the \"total number of pages\" until you have created all the pages.\nYou can use **func PlaceHolderText** to create the point where you want \"total number of pages\" to be printed. And then when you have created all the pages so you know the \"total number of pages\", you call **FillInPlaceHoldText(...)**. This function will take the text (in this case, text is \"total number of pages\") replace at the point that been created since **func PlaceHolderText**.\n\n```go\nfunc main(){\n    \tpdf := GoPdf{}\n\tpdf.Start(Config{PageSize: *PageSizeA4})\n\tpdf.AddTTFFont(\"font1\", \"font1.ttf\")\n\tpdf.SetFont(\"font1\", \"\", 14) }\n\n\tfor i := 0; i < 5; i++ {\n\t\tpdf.AddPage()\n        \tpdf.Br(20)\n        \t//create PlaceHolder\n\t\terr = pdf.PlaceHolderText(\"totalnumber\", 30)\n\t\tif err != nil {\n\t\t\tlog.Print(err.Error())\n\t\t\treturn\n\t\t}\n\n\t}\n\n    \t//fillin text to PlaceHolder\n\terr = pdf.FillInPlaceHoldText(\"totalnumber\",fmt.Sprintf(\"%d\", 5), Left)\n\tif err != nil {\n\t\tlog.Print(err.Error())\n\t\treturn\n\t}\n\n\tpdf.WritePdf(\"placeholder_text.pdf\")\n}\n```\n\n### Table Create\n```go\npackage main\n\nimport (\n    \"fmt\"\n\n    \"github.com/signintech/gopdf\"\n)\n\nfunc main() {\n\n\t// Create a new PDF document\n\tpdf := &gopdf.GoPdf{}\n\t// Start the PDF with a custom page size (we'll adjust it later)\n\tpdf.Start(gopdf.Config{PageSize: gopdf.Rect{W: 430, H: 200}})\n\t// Add a new page to the document\n\tpdf.AddPage()\n\n\t pdf.AddTTFFont(\"font1\", \"./font1.ttf\")\n\tpdf.SetFont(\"font1\", \"\", 11)\n\t\n\tpdf.AddTTFFont(\"font2\", \"./font2.ttf\")\n\tpdf.SetFont(\"font2\", \"\", 11)\n\t\n\t// Set the starting Y position for the table\n\ttableStartY := 10.0\n\t// Set the left margin for the table\n\tmarginLeft := 10.0\n\n\t// Create a new table layout\n\ttable := pdf.NewTableLayout(marginLeft, tableStartY, 25, 5)\n\n\t// Add columns to the table\n\ttable.AddColumn(\"CODE\", 50, \"left\")\n\ttable.AddColumn(\"DESCRIPTION\", 200, \"left\")\n\ttable.AddColumn(\"QTY.\", 40, \"right\")\n\ttable.AddColumn(\"PRICE\", 60, \"right\")\n\ttable.AddColumn(\"TOTAL\", 60, \"right\")\n\n\t// Add rows to the table\n\ttable.AddRow([]string{\"001\", \"Product A\", \"2\", \"10.00\", \"20.00\"})\n\ttable.AddRow([]string{\"002\", \"Product B\", \"1\", \"15.00\", \"15.00\"})\n\ttable.AddRow([]string{\"003\", \"Product C\", \"3\", \"5.00\", \"15.00\"})\n\n\t// Set the style for table cells\n\ttable.SetTableStyle(gopdf.CellStyle{\n\t\tBorderStyle: gopdf.BorderStyle{\n\t\t\tTop:    true,\n\t\t\tLeft:   true,\n\t\t\tBottom: true,\n\t\t\tRight:  true,\n\t\t\tWidth:  1.0,\n\t\t},\n\t\tFillColor: gopdf.RGBColor{R: 255, G: 255, B: 255},\n\t\tTextColor: gopdf.RGBColor{R: 0, G: 0, B: 0},\n\t\tFontSize:  10,\n\t})\n\n\t// Set the style for table header\n\ttable.SetHeaderStyle(gopdf.CellStyle{\n\t\tBorderStyle: gopdf.BorderStyle{\n\t\t\tTop:      true,\n\t\t\tLeft:     true,\n\t\t\tBottom:   true,\n\t\t\tRight:    true,\n\t\t\tWidth:    2.0,\n\t\t\tRGBColor: gopdf.RGBColor{R: 100, G: 150, B: 255},\n\t\t},\n\t\tFillColor: gopdf.RGBColor{R: 255, G: 200, B: 200},\n\t\tTextColor: gopdf.RGBColor{R: 255, G: 100, B: 100},\n\t\tFont:      \"font2\",\n\t\tFontSize:  12,\n\t})\n\n\ttable.SetCellStyle(gopdf.CellStyle{\n\t\tBorderStyle: gopdf.BorderStyle{\n\t\t\tRight:    true,\n\t\t\tBottom:   true,\n\t\t\tWidth:    0.5,\n\t\t\tRGBColor: gopdf.RGBColor{R: 0, G: 0, B: 0},\n\t\t},\n\t\tFillColor: gopdf.RGBColor{R: 255, G: 255, B: 255},\n\t\tTextColor: gopdf.RGBColor{R: 0, G: 0, B: 0},\n\t\tFont:      \"font1\",\n\t\tFontSize:  10,\n\t})\n\n\t// Draw the table\n\ttable.DrawTable()\n\n\n\t// Save the PDF to the specified path\n     pdf.WritePdf(\"table.pdf\")\n\n}\n```\n\nresult:\n![table](./examples/table/table_example.jpg)\n\n\nvisit https://github.com/oneplus1000/gopdfsample for more samples.\n"
        },
        {
          "name": "annot_obj.go",
          "type": "blob",
          "size": 1.3486328125,
          "content": "package gopdf\n\nimport (\n\t\"fmt\"\n\t\"io\"\n\t\"strings\"\n)\n\ntype annotObj struct {\n\tlinkOption\n\tGetRoot func() *GoPdf\n}\n\nfunc (o annotObj) init(f func() *GoPdf) {\n}\n\nfunc (o annotObj) getType() string {\n\treturn \"Annot\"\n}\n\nfunc (o annotObj) write(w io.Writer, objID int) error {\n\tif o.url != \"\" {\n\t\treturn o.writeExternalLink(w, o.linkOption, objID)\n\t} else {\n\t\treturn o.writeInternalLink(w, o.linkOption)\n\t}\n}\n\nfunc (o annotObj) writeExternalLink(w io.Writer, l linkOption, objID int) error {\n\tprotection := o.GetRoot().protection()\n\turl := l.url\n\tif protection != nil {\n\t\ttmp, err := rc4Cip(protection.objectkey(objID), []byte(url))\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\turl = string(tmp)\n\t}\n\turl = strings.Replace(url, \"\\\\\", \"\\\\\\\\\", -1)\n\turl = strings.Replace(url, \"(\", \"\\\\(\", -1)\n\turl = strings.Replace(url, \")\", \"\\\\)\", -1)\n\turl = strings.Replace(url, \"\\r\", \"\\\\r\", -1)\n\n\t_, err := fmt.Fprintf(w, \"<</Type /Annot /Subtype /Link /Rect [%.2f %.2f %.2f %.2f] /Border [0 0 0] /A <</S /URI /URI (%s)>>>>\\n\",\n\t\tl.x, l.y, l.x+l.w, l.y-l.h, url)\n\treturn err\n}\n\nfunc (o annotObj) writeInternalLink(w io.Writer, l linkOption) error {\n\ta, ok := o.GetRoot().anchors[l.anchor]\n\tif !ok {\n\t\treturn nil\n\t}\n\t_, err := fmt.Fprintf(w, \"<</Type /Annot /Subtype /Link /Rect [%.2f %.2f %.2f %.2f] /Border [0 0 0] /Dest [%d 0 R /XYZ 0 %.2f null]>>\\n\",\n\t\tl.x, l.y, l.x+l.w, l.y-l.h, a.page+1, a.y)\n\treturn err\n}\n"
        },
        {
          "name": "box.go",
          "type": "blob",
          "size": 0.9326171875,
          "content": "package gopdf\n\ntype Box struct {\n\tLeft, Top, Right, Bottom float64\n\tunitOverride             defaultUnitConfig\n}\n\n// UnitsToPoints converts the box coordinates to Points. When this is called it is assumed the values of the box are in Units\nfunc (box *Box) UnitsToPoints(t int) (b *Box) {\n\tif box == nil {\n\t\treturn\n\t}\n\n\tunitCfg := defaultUnitConfig{Unit: t}\n\tif box.unitOverride.getUnit() != UnitUnset {\n\t\tunitCfg = box.unitOverride\n\t}\n\n\tb = &Box{\n\t\tLeft:   box.Left,\n\t\tTop:    box.Top,\n\t\tRight:  box.Right,\n\t\tBottom: box.Bottom,\n\t}\n\tunitsToPointsVar(unitCfg, &b.Left, &b.Top, &b.Right, &b.Bottom)\n\treturn\n}\n\nfunc (box *Box) unitsToPoints(unitCfg unitConfigurator) (b *Box) {\n\tif box == nil {\n\t\treturn\n\t}\n\n\tif box.unitOverride.getUnit() != UnitUnset {\n\t\tunitCfg = box.unitOverride\n\t}\n\n\tb = &Box{\n\t\tLeft:   box.Left,\n\t\tTop:    box.Top,\n\t\tRight:  box.Right,\n\t\tBottom: box.Bottom,\n\t}\n\tunitsToPointsVar(unitCfg, &b.Left, &b.Top, &b.Right, &b.Bottom)\n\treturn\n}\n"
        },
        {
          "name": "break_option.go",
          "type": "blob",
          "size": 1.357421875,
          "content": "package gopdf\n\n// BreakMode type for text break modes.\ntype BreakMode int\n\nconst (\n\t// BreakModeStrict causes the text-line to break immediately in case the current character would not fit into\n\t// the processed text-line. The separator (if provided) will be attached accordingly as a line suffix\n\t// to stay within the defined width.\n\tBreakModeStrict BreakMode = iota\n\n\t// BreakModeIndicatorSensitive will try to break the current line based on the last index of a provided\n\t// BreakIndicator. If no indicator sensitive break can be performed a strict break will be performed,\n\t// potentially working with the given separator as a suffix.\n\tBreakModeIndicatorSensitive\n)\n\nvar (\n\t// DefaultBreakOption will cause the text to break mid-word without any separator suffixes.\n\tDefaultBreakOption = BreakOption{\n\t\tMode:           BreakModeStrict,\n\t\tBreakIndicator: 0,\n\t\tSeparator:      \"\",\n\t}\n)\n\n// BreakOption allows to configure the behavior of splitting or breaking larger texts via SplitTextWithOption.\ntype BreakOption struct {\n\t// Mode defines the mode which should be used\n\tMode BreakMode\n\t// BreakIndicator is taken into account when using indicator sensitive mode to avoid mid-word line breaks\n\tBreakIndicator rune\n\t// Separator will act as a suffix for mid-word breaks when using strict mode\n\tSeparator string\n}\n\nfunc (bo BreakOption) HasSeparator() bool {\n\treturn bo.Separator != \"\"\n}\n"
        },
        {
          "name": "buff.go",
          "type": "blob",
          "size": 0.673828125,
          "content": "package gopdf\n\n// Buff for pdf content\ntype Buff struct {\n\tposition int\n\tdatas    []byte\n}\n\n// Write : write []byte to buffer\nfunc (b *Buff) Write(p []byte) (int, error) {\n\tfor len(b.datas) < b.position+len(p) {\n\t\tb.datas = append(b.datas, 0)\n\t}\n\ti := 0\n\tmax := len(p)\n\tfor i < max {\n\t\tb.datas[i+b.position] = p[i]\n\t\ti++\n\t}\n\tb.position += i\n\treturn 0, nil\n}\n\n// Len : len of buffer\nfunc (b *Buff) Len() int {\n\treturn len(b.datas)\n}\n\n// Bytes : get bytes\nfunc (b *Buff) Bytes() []byte {\n\treturn b.datas\n}\n\n// Position : get current position\nfunc (b *Buff) Position() int {\n\treturn b.position\n}\n\n// SetPosition : set current position\nfunc (b *Buff) SetPosition(pos int) {\n\tb.position = pos\n}\n"
        },
        {
          "name": "buff_write.go",
          "type": "blob",
          "size": 0.912109375,
          "content": "package gopdf\n\nimport \"io\"\n\n// WriteUInt32  writes a 32-bit unsigned integer value to w io.Writer\nfunc WriteUInt32(w io.Writer, v uint) error {\n\ta := byte(v >> 24)\n\tb := byte(v >> 16)\n\tc := byte(v >> 8)\n\td := byte(v)\n\t_, err := w.Write([]byte{a, b, c, d})\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}\n\n// WriteUInt16 writes a 16-bit unsigned integer value to w io.Writer\nfunc WriteUInt16(w io.Writer, v uint) error {\n\n\ta := byte(v >> 8)\n\tb := byte(v)\n\t_, err := w.Write([]byte{a, b})\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}\n\n// WriteTag writes string value to w io.Writer\nfunc WriteTag(w io.Writer, tag string) error {\n\tb := []byte(tag)\n\t_, err := w.Write(b)\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}\n\n// WriteBytes writes []byte value to w io.Writer\nfunc WriteBytes(w io.Writer, data []byte, offset int, count int) error {\n\n\t_, err := w.Write(data[offset : offset+count])\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}\n"
        },
        {
          "name": "buff_write_test.go",
          "type": "blob",
          "size": 0.841796875,
          "content": "package gopdf\n\nimport (\n\t\"bytes\"\n\t\"testing\"\n)\n\nfunc TestWriteUInt32(t *testing.T) {\n\tvar buff bytes.Buffer\n\terr := WriteUInt32(&buff, 65536)\n\tif err != nil {\n\t\tt.Errorf(\"%s\", err.Error())\n\t}\n\n\tb := buff.Bytes()\n\tif b[0] != 0 || b[1] != 1 || b[2] != 0 || b[3] != 0 {\n\t\tt.Errorf(\"WriteUInt64 fail\")\n\t}\n}\n\n/*\nfunc TestFloat(t *testing.T){\n\ta := float64(1170.08)\n    b := float64(1013.08)\n    c := float64(54673.00)\n    d := float64(131588.00)\n    e := float64(54236.52)\n\tsum := a + b + c + d + e\n\tif sum != 242680.68 {\n\t\tt.Errorf(\"!242680.68\")\n\t}\n}*/\n\nfunc TestEncodeUTF8(t *testing.T) {\n\tstr := \"Boonchai Manasirisuk\"\n\tbuff := encodeUtf8(str)\n\tif buff != \"0042006F006F006E00630068006100690020004D0061006E0061007300690072006900730075006B\" {\n\t\tt.Error(\"not match\")\n\t}\n}\n\n/*\nfunc TestInfoDate(t *testing.T) {\n\tstr := infodate(time.Now())\n\tfmt.Printf(\"%s\\n\", str)\n}*/\n"
        },
        {
          "name": "buffer_pool.go",
          "type": "blob",
          "size": 0.4248046875,
          "content": "package gopdf\n\nimport (\n\t\"bytes\"\n\t\"sync\"\n)\n\n// buffer pool to reduce GC\nvar buffers = sync.Pool{\n\t// New is called when a new instance is needed\n\tNew: func() interface{} {\n\t\treturn new(bytes.Buffer)\n\t},\n}\n\n// GetBuffer fetches a buffer from the pool\nfunc GetBuffer() *bytes.Buffer {\n\treturn buffers.Get().(*bytes.Buffer)\n}\n\n// PutBuffer returns a buffer to the pool\nfunc PutBuffer(buf *bytes.Buffer) {\n\tbuf.Reset()\n\tbuffers.Put(buf)\n}\n"
        },
        {
          "name": "cache_contact_color_rgb.go",
          "type": "blob",
          "size": 0.373046875,
          "content": "package gopdf\n\nimport (\n\t\"fmt\"\n\t\"io\"\n)\n\nconst colorTypeStrokeRGB = \"RG\"\n\nconst colorTypeFillRGB = \"rg\"\n\ntype cacheContentColorRGB struct {\n\tcolorType string\n\tr, g, b   uint8\n}\n\nfunc (c *cacheContentColorRGB) write(w io.Writer, protection *PDFProtection) error {\n\tfmt.Fprintf(w, \"%.3f %.3f %.3f %s\\n\", float64(c.r)/255, float64(c.g)/255, float64(c.b)/255, c.colorType)\n\treturn nil\n}\n"
        },
        {
          "name": "cache_content_color_cmyk.go",
          "type": "blob",
          "size": 0.3994140625,
          "content": "package gopdf\n\nimport (\n\t\"fmt\"\n\t\"io\"\n)\n\nconst colorTypeStrokeCMYK = \"K\"\n\nconst colorTypeFillCMYK = \"k\"\n\ntype cacheContentColorCMYK struct {\n\tcolorType  string\n\tc, m, y, k uint8\n}\n\nfunc (c *cacheContentColorCMYK) write(w io.Writer, protection *PDFProtection) error {\n\tfmt.Fprintf(w, \"%.2f %.2f %.2f %.2f %s\\n\", float64(c.c)/100, float64(c.m)/100, float64(c.y)/100, float64(c.k)/100, c.colorType)\n\treturn nil\n}\n"
        },
        {
          "name": "cache_content_custom_line_type.go",
          "type": "blob",
          "size": 0.283203125,
          "content": "package gopdf\n\nimport (\n\t\"fmt\"\n\t\"io\"\n)\n\ntype cacheContentCustomLineType struct {\n\tdashArray []float64\n\tdashPhase float64\n}\n\nfunc (c *cacheContentCustomLineType) write(w io.Writer, protection *PDFProtection) error {\n\tfmt.Fprintf(w, \"%0.2f %0.2f d\\n\", c.dashArray, c.dashPhase)\n\treturn nil\n}\n"
        },
        {
          "name": "cache_content_gray.go",
          "type": "blob",
          "size": 0.2998046875,
          "content": "package gopdf\n\nimport (\n\t\"fmt\"\n\t\"io\"\n)\n\nconst grayTypeFill = \"g\"\nconst grayTypeStroke = \"G\"\n\ntype cacheContentGray struct {\n\tgrayType string\n\tscale    float64\n}\n\nfunc (c *cacheContentGray) write(w io.Writer, protection *PDFProtection) error {\n\tfmt.Fprintf(w, \"%.2f %s\\n\", c.scale, c.grayType)\n\treturn nil\n}\n"
        },
        {
          "name": "cache_content_image.go",
          "type": "blob",
          "size": 2.8779296875,
          "content": "package gopdf\n\nimport (\n\t\"fmt\"\n\t\"io\"\n)\n\ntype cacheContentImage struct {\n\twithMask         bool\n\tmaskAngle        float64\n\timageAngle       float64\n\tverticalFlip     bool\n\thorizontalFlip   bool\n\tindex            int\n\tx                float64\n\ty                float64\n\tpageHeight       float64\n\trect             Rect\n\tcrop             *CropOptions\n\textGStateIndexes []int\n}\n\nfunc (c *cacheContentImage) openImageRotateTrMt(writer io.Writer, protection *PDFProtection) error {\n\tw := c.rect.W\n\th := c.rect.H\n\n\tif c.crop != nil {\n\t\tw = c.crop.Width\n\t\th = c.crop.Height\n\t}\n\n\tx := c.x + w/2\n\ty := c.y + h/2\n\n\tcacheRotate := cacheContentRotate{\n\t\tx:          x,\n\t\ty:          y,\n\t\tpageHeight: c.pageHeight,\n\t\tangle:      c.imageAngle,\n\t}\n\tif err := cacheRotate.write(writer, protection); err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\nfunc (c *cacheContentImage) closeImageRotateTrMt(writer io.Writer, protection *PDFProtection) error {\n\tresetCacheRotate := cacheContentRotate{isReset: true}\n\n\treturn resetCacheRotate.write(writer, protection)\n}\n\nfunc (c *cacheContentImage) computeMaskImageRotateTrMt() string {\n\tangle := c.maskAngle + c.imageAngle\n\tif angle == 0 {\n\t\treturn \"\"\n\t}\n\n\tx := c.x + c.rect.W/2\n\ty := c.y + c.rect.H/2\n\n\trotateMat := computeRotateTransformationMatrix(x, y, angle, c.pageHeight)\n\n\treturn rotateMat\n}\n\nfunc (c *cacheContentImage) write(writer io.Writer, protection *PDFProtection) error {\n\twidth := c.rect.W\n\theight := c.rect.H\n\n\tif !c.withMask {\n\t\tif err := c.openImageRotateTrMt(writer, protection); err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tdefer c.closeImageRotateTrMt(writer, protection)\n\t}\n\n\tcontentStream := \"q\\n\"\n\n\tfor _, extGStateIndex := range c.extGStateIndexes {\n\t\tcontentStream += fmt.Sprintf(\"/GS%d gs\\n\", extGStateIndex)\n\t}\n\n\tif c.horizontalFlip || c.verticalFlip {\n\t\tfh := \"1\"\n\t\tif c.horizontalFlip {\n\t\t\tfh = \"-1\"\n\t\t}\n\n\t\tfv := \"1\"\n\t\tif c.verticalFlip {\n\t\t\tfv = \"-1\"\n\t\t}\n\n\t\tcontentStream += fmt.Sprintf(\"%s 0 0 %s 0 0 cm\\n\", fh, fv)\n\t}\n\n\tx := c.x\n\ty := c.pageHeight - c.y\n\n\tif c.crop != nil {\n\t\tclippingX := x\n\t\tif c.horizontalFlip {\n\t\t\tclippingX = -clippingX - c.crop.Width\n\t\t}\n\n\t\tclippingY := y - c.crop.Height\n\t\tif c.verticalFlip {\n\t\t\tclippingY = -clippingY - c.crop.Height\n\t\t}\n\n\t\tcontentStream += fmt.Sprintf(\"%0.2f %0.2f %0.2f %0.2f re W* n\\n\", clippingX, clippingY, c.crop.Width, c.crop.Height)\n\n\t\tx -= c.crop.X\n\t\tif c.horizontalFlip {\n\t\t\tx = -x - width\n\t\t}\n\n\t\ty += c.crop.Y - height\n\t\tif c.verticalFlip {\n\t\t\ty = -y - height\n\t\t}\n\t} else {\n\t\ty -= height\n\n\t\tif c.horizontalFlip {\n\t\t\tx = -x - width\n\t\t}\n\n\t\tif c.verticalFlip {\n\t\t\ty = -y - height\n\t\t}\n\t}\n\n\tvar maskImageRotateMat string\n\tif c.withMask {\n\t\tmaskImageRotateMat = c.computeMaskImageRotateTrMt()\n\t}\n\n\tcontentStream += fmt.Sprintf(\"q\\n %s %0.2f 0 0\\n %0.2f %0.2f %0.2f cm /I%d Do \\nQ\\n\", maskImageRotateMat, width, height, x, y, c.index+1)\n\n\tcontentStream += \"Q\\n\"\n\n\tif _, err := io.WriteString(writer, contentStream); err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n"
        },
        {
          "name": "cache_content_imported_object.go",
          "type": "blob",
          "size": 0.4482421875,
          "content": "package gopdf\n\nimport (\n\t\"fmt\"\n\t\"io\"\n)\n\ntype cacheContentImportedTemplate struct {\n\tpageHeight float64\n\ttplName    string\n\tscaleX     float64\n\tscaleY     float64\n\ttX         float64\n\ttY         float64\n}\n\nfunc (c *cacheContentImportedTemplate) write(w io.Writer, protection *PDFProtection) error {\n\tc.tY += c.pageHeight\n\tfmt.Fprintf(w, \"q 0 J 1 w 0 j 0 G 0 g q %.4F 0 0 %.4F %.4F %.4F cm %s Do Q Q\\n\", c.scaleX, c.scaleY, c.tX, c.tY, c.tplName)\n\treturn nil\n}\n"
        },
        {
          "name": "cache_content_line.go",
          "type": "blob",
          "size": 0.53515625,
          "content": "package gopdf\n\nimport (\n\t\"fmt\"\n\t\"io\"\n)\n\ntype cacheContentLine struct {\n\tpageHeight float64\n\tx1         float64\n\ty1         float64\n\tx2         float64\n\ty2         float64\n\topts       lineOptions\n}\n\nfunc (c *cacheContentLine) write(w io.Writer, protection *PDFProtection) error {\n\tfmt.Fprintf(w, \"q\\n\")\n\tfor _, extGStateIndex := range c.opts.extGStateIndexes {\n\t\tfmt.Fprintf(w, \"/GS%d gs\\n\", extGStateIndex)\n\t}\n\tfmt.Fprintf(w, \"%0.2f %0.2f m %0.2f %0.2f l S\\n\", c.x1, c.pageHeight-c.y1, c.x2, c.pageHeight-c.y2)\n\tfmt.Fprintf(w, \"Q\\n\")\n\treturn nil\n}\n"
        },
        {
          "name": "cache_content_line_type.go",
          "type": "blob",
          "size": 0.3408203125,
          "content": "package gopdf\n\nimport (\n\t\"fmt\"\n\t\"io\"\n)\n\ntype cacheContentLineType struct {\n\tlineType string\n}\n\nfunc (c *cacheContentLineType) write(w io.Writer, protection *PDFProtection) error {\n\tswitch c.lineType {\n\tcase \"dashed\":\n\t\tfmt.Fprint(w, \"[5] 2 d\\n\")\n\tcase \"dotted\":\n\t\tfmt.Fprint(w, \"[2 3] 11 d\\n\")\n\tdefault:\n\t\tfmt.Fprint(w, \"[] 0 d\\n\")\n\t}\n\treturn nil\n}\n"
        },
        {
          "name": "cache_content_line_width.go",
          "type": "blob",
          "size": 0.2255859375,
          "content": "package gopdf\n\nimport (\n\t\"fmt\"\n\t\"io\"\n)\n\ntype cacheContentLineWidth struct {\n\twidth float64\n}\n\nfunc (c *cacheContentLineWidth) write(w io.Writer, protection *PDFProtection) error {\n\tfmt.Fprintf(w, \"%.2f w\\n\", c.width)\n\treturn nil\n}\n"
        },
        {
          "name": "cache_content_oval.go",
          "type": "blob",
          "size": 1.2138671875,
          "content": "package gopdf\n\nimport (\n\t\"fmt\"\n\t\"io\"\n)\n\ntype cacheContentOval struct {\n\tpageHeight float64\n\tx1         float64\n\ty1         float64\n\tx2         float64\n\ty2         float64\n}\n\nfunc (c *cacheContentOval) write(w io.Writer, protection *PDFProtection) error {\n\n\th := c.pageHeight\n\tx1 := c.x1\n\ty1 := c.y1\n\tx2 := c.x2\n\ty2 := c.y2\n\n\tcp := 0.55228                              // Magnification of the control point\n\tv1 := [2]float64{x1 + (x2-x1)/2, h - y2}   // Vertex of the lower\n\tv2 := [2]float64{x2, h - (y1 + (y2-y1)/2)} // .. Right\n\tv3 := [2]float64{x1 + (x2-x1)/2, h - y1}   // .. Upper\n\tv4 := [2]float64{x1, h - (y1 + (y2-y1)/2)} // .. Left\n\n\tfmt.Fprintf(w, \"%0.2f %0.2f m\\n\", v1[0], v1[1])\n\tfmt.Fprintf(w,\n\t\t\"%0.2f %0.2f %0.2f %0.2f %0.2f %0.2f c\\n\",\n\t\tv1[0]+(x2-x1)/2*cp, v1[1], v2[0], v2[1]-(y2-y1)/2*cp, v2[0], v2[1],\n\t)\n\tfmt.Fprintf(w,\n\t\t\"%0.2f %0.2f %0.2f %0.2f %0.2f %0.2f c\\n\",\n\t\tv2[0], v2[1]+(y2-y1)/2*cp, v3[0]+(x2-x1)/2*cp, v3[1], v3[0], v3[1],\n\t)\n\tfmt.Fprintf(w,\n\t\t\"%0.2f %0.2f %0.2f %0.2f %0.2f %0.2f c\\n\",\n\t\tv3[0]-(x2-x1)/2*cp, v3[1], v4[0], v4[1]+(y2-y1)/2*cp, v4[0], v4[1],\n\t)\n\tfmt.Fprintf(w,\n\t\t\"%0.2f %0.2f %0.2f %0.2f %0.2f %0.2f c S\\n\",\n\t\tv4[0], v4[1]-(y2-y1)/2*cp, v1[0]-(x2-x1)/2*cp, v1[1], v1[0], v1[1],\n\t)\n\n\treturn nil\n}\n"
        },
        {
          "name": "cache_content_polygon.go",
          "type": "blob",
          "size": 0.736328125,
          "content": "package gopdf\n\nimport (\n\t\"fmt\"\n\t\"io\"\n)\n\ntype cacheContentPolygon struct {\n\tpageHeight float64\n\tstyle      string\n\tpoints     []Point\n\topts       polygonOptions\n}\n\nfunc (c *cacheContentPolygon) write(w io.Writer, protection *PDFProtection) error {\n\n\tfmt.Fprintf(w, \"q\\n\")\n\tfor _, extGStateIndex := range c.opts.extGStateIndexes {\n\t\tfmt.Fprintf(w, \"/GS%d gs\\n\", extGStateIndex)\n\t}\n\n\tfor i, point := range c.points {\n\t\tfmt.Fprintf(w, \"%.2f %.2f\", point.X, c.pageHeight-point.Y)\n\t\tif i == 0 {\n\t\t\tfmt.Fprintf(w, \" m \")\n\t\t} else {\n\t\t\tfmt.Fprintf(w, \" l \")\n\t\t}\n\n\t}\n\n\tif c.style == \"F\" {\n\t\tfmt.Fprintf(w, \" f\\n\")\n\t} else if c.style == \"FD\" || c.style == \"DF\" {\n\t\tfmt.Fprintf(w, \" b\\n\")\n\t} else {\n\t\tfmt.Fprintf(w, \" s\\n\")\n\t}\n\n\tfmt.Fprintf(w, \"Q\\n\")\n\treturn nil\n}\n"
        },
        {
          "name": "cache_content_rectangle.go",
          "type": "blob",
          "size": 1.1181640625,
          "content": "package gopdf\n\nimport (\n\t\"fmt\"\n\t\"io\"\n)\n\ntype cacheContentRectangle struct {\n\tpageHeight       float64\n\tx                float64\n\ty                float64\n\twidth            float64\n\theight           float64\n\tstyle            PaintStyle\n\textGStateIndexes []int\n}\n\nfunc NewCacheContentRectangle(pageHeight float64, rectOpts DrawableRectOptions) ICacheContent {\n\tif rectOpts.PaintStyle == \"\" {\n\t\trectOpts.PaintStyle = DrawPaintStyle\n\t}\n\n\treturn cacheContentRectangle{\n\t\tx:                rectOpts.X,\n\t\ty:                rectOpts.Y,\n\t\twidth:            rectOpts.W,\n\t\theight:           rectOpts.H,\n\t\tpageHeight:       pageHeight,\n\t\tstyle:            rectOpts.PaintStyle,\n\t\textGStateIndexes: rectOpts.extGStateIndexes,\n\t}\n}\n\nfunc (c cacheContentRectangle) write(w io.Writer, protection *PDFProtection) error {\n\tstream := \"q\\n\"\n\n\tfor _, extGStateIndex := range c.extGStateIndexes {\n\t\tstream += fmt.Sprintf(\"/GS%d gs\\n\", extGStateIndex)\n\t}\n\n\tstream += fmt.Sprintf(\"%0.2f %0.2f %0.2f %0.2f re %s\\n\", c.x, c.pageHeight-c.y, c.width, c.height, c.style)\n\n\tstream += \"Q\\n\"\n\n\tif _, err := io.WriteString(w, stream); err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n"
        },
        {
          "name": "cache_content_rotate.go",
          "type": "blob",
          "size": 0.875,
          "content": "package gopdf\n\nimport (\n\t\"fmt\"\n\t\"io\"\n\t\"math\"\n)\n\ntype cacheContentRotate struct {\n\tisReset     bool\n\tpageHeight  float64\n\tangle, x, y float64\n}\n\nfunc (cc *cacheContentRotate) write(w io.Writer, protection *PDFProtection) error {\n\tif cc.isReset == true {\n\t\tif _, err := io.WriteString(w, \"Q\\n\"); err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\treturn nil\n\t}\n\n\tmatrix := computeRotateTransformationMatrix(cc.x, cc.y, cc.angle, cc.pageHeight)\n\tcontentStream := fmt.Sprintf(\"q\\n %s\", matrix)\n\n\tif _, err := io.WriteString(w, contentStream); err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\nfunc computeRotateTransformationMatrix(x, y, degreeAngle, pageHeight float64) string {\n\tradianAngle := degreeAngle * (math.Pi / 180)\n\n\tc := math.Cos(radianAngle)\n\ts := math.Sin(radianAngle)\n\tcy := pageHeight - y\n\n\treturn fmt.Sprintf(\"%.5f %.5f %.5f\\n %.5f %.2f %.2f cm\\n 1 0 0\\n 1 %.2f %.2f cm\\n\", c, s, -s, c, x, cy, -x, -cy)\n}\n"
        },
        {
          "name": "cache_content_text.go",
          "type": "blob",
          "size": 11.4345703125,
          "content": "package gopdf\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"math\"\n\t\"strconv\"\n)\n\nconst defaultCoefLineHeight = float64(1)\nconst defaultCoefUnderlinePosition = float64(1)\nconst defaultcoefUnderlineThickness = float64(1)\n\n// ContentTypeCell cell\nconst ContentTypeCell = 0\n\n// ContentTypeText text\nconst ContentTypeText = 1\n\nvar ErrContentTypeNotFound = errors.New(\"contentType not found\")\n\ntype cacheContentText struct {\n\t//---setup---\n\trectangle      *Rect\n\ttextColor      ICacheColorText\n\tgrayFill       float64\n\ttxtColorMode   string\n\tfontCountIndex int //Curr.FontFontCount+1\n\tfontSize       float64\n\tfontStyle      int\n\tcharSpacing    float64\n\tsetXCount      int //จำนวนครั้งที่ใช้ setX\n\tx, y           float64\n\tfontSubset     *SubsetFontObj\n\tpageheight     float64\n\tcontentType    int\n\tcellOpt        CellOption\n\tlineWidth      float64\n\ttext           string\n\t//---result---\n\tcellWidthPdfUnit, textWidthPdfUnit float64\n\tcellHeightPdfUnit                  float64\n\tisPlaceHolder                      bool\n}\n\nfunc (c *cacheContentText) isSame(cache cacheContentText) bool {\n\tif c.rectangle != nil {\n\t\t//if rectangle != nil we assume this is not same content\n\t\treturn false\n\t}\n\n\t// if both colors are nil we assume them equal\n\tif ((c.textColor == nil && cache.textColor == nil) ||\n\t\t(c.textColor != nil && c.textColor.equal(cache.textColor))) &&\n\t\tc.grayFill == cache.grayFill &&\n\t\tc.fontCountIndex == cache.fontCountIndex &&\n\t\tc.fontSize == cache.fontSize &&\n\t\tc.fontStyle == cache.fontStyle &&\n\t\tc.charSpacing == cache.charSpacing &&\n\t\tc.setXCount == cache.setXCount &&\n\t\tc.y == cache.y &&\n\t\tc.isPlaceHolder == cache.isPlaceHolder {\n\t\treturn true\n\t}\n\n\treturn false\n}\n\nfunc (c *cacheContentText) setPageHeight(pageheight float64) {\n\tc.pageheight = pageheight\n}\n\nfunc (c *cacheContentText) pageHeight() float64 {\n\treturn c.pageheight //841.89\n}\n\nfunc convertTypoUnit(val float64, unitsPerEm uint, fontSize float64) float64 {\n\tval = val * 1000.00 / float64(unitsPerEm)\n\treturn val * fontSize / 1000.0\n}\n\nfunc (c *cacheContentText) calTypoAscender() float64 {\n\treturn convertTypoUnit(float64(c.fontSubset.ttfp.TypoAscender()), c.fontSubset.ttfp.UnitsPerEm(), float64(c.fontSize))\n}\n\nfunc (c *cacheContentText) calTypoDescender() float64 {\n\treturn convertTypoUnit(float64(c.fontSubset.ttfp.TypoDescender()), c.fontSubset.ttfp.UnitsPerEm(), float64(c.fontSize))\n}\n\nfunc (c *cacheContentText) calY() (float64, error) {\n\tpageHeight := c.pageHeight()\n\tif c.contentType == ContentTypeText {\n\t\treturn pageHeight - c.y, nil\n\t} else if c.contentType == ContentTypeCell {\n\t\ty := float64(0.0)\n\t\tif c.cellOpt.Align&Bottom == Bottom {\n\t\t\ty = pageHeight - c.y - c.cellHeightPdfUnit - c.calTypoDescender()\n\t\t} else if c.cellOpt.Align&Middle == Middle {\n\t\t\ty = pageHeight - c.y - c.cellHeightPdfUnit*0.5 - (c.calTypoDescender()+c.calTypoAscender())*0.5\n\t\t} else {\n\t\t\t//top\n\t\t\ty = pageHeight - c.y - c.calTypoAscender()\n\t\t}\n\n\t\treturn y, nil\n\t}\n\treturn 0.0, ErrContentTypeNotFound\n}\n\nfunc (c *cacheContentText) calX() (float64, error) {\n\tif c.contentType == ContentTypeText {\n\t\treturn c.x, nil\n\t} else if c.contentType == ContentTypeCell {\n\t\tx := float64(0.0)\n\t\tif c.cellOpt.Align&Right == Right {\n\t\t\tx = c.x + c.cellWidthPdfUnit - c.textWidthPdfUnit\n\t\t} else if c.cellOpt.Align&Center == Center {\n\t\t\tx = c.x + c.cellWidthPdfUnit*0.5 - c.textWidthPdfUnit*0.5\n\t\t} else {\n\t\t\tx = c.x\n\t\t}\n\t\treturn x, nil\n\t}\n\treturn 0.0, ErrContentTypeNotFound\n}\n\n// FormatFloatTrim converts a float64 into a string, like Sprintf(\"%.3f\")\n// but with trailing zeroes (and possibly \".\") removed\nfunc FormatFloatTrim(floatval float64) (formatted string) {\n\tconst precisionFactor = 1000.0\n\troundedFontSize := math.Round(precisionFactor*floatval) / precisionFactor\n\treturn strconv.FormatFloat(roundedFontSize, 'f', -1, 64)\n}\n\nfunc (c *cacheContentText) write(w io.Writer, protection *PDFProtection) error {\n\tx, err := c.calX()\n\tif err != nil {\n\t\treturn err\n\t}\n\ty, err := c.calY()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tfor _, extGStateIndex := range c.cellOpt.extGStateIndexes {\n\t\tlinkToGSObj := fmt.Sprintf(\"/GS%d gs\\n\", extGStateIndex)\n\t\tif _, err := io.WriteString(w, linkToGSObj); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\tif _, err := io.WriteString(w, \"BT\\n\"); err != nil {\n\t\treturn err\n\t}\n\n\tfmt.Fprintf(w, \"%0.2f %0.2f TD\\n\", x, y)\n\tfmt.Fprintf(w, \"/F%d %s Tf %s Tc\\n\", c.fontCountIndex, FormatFloatTrim(c.fontSize), FormatFloatTrim(c.charSpacing))\n\n\tif c.txtColorMode == \"color\" {\n\t\tc.textColor.write(w, protection)\n\t}\n\tio.WriteString(w, \"[<\")\n\n\tunitsPerEm := int(c.fontSubset.ttfp.UnitsPerEm())\n\tvar leftRune rune\n\tvar leftRuneIndex uint\n\tfor i, r := range c.text {\n\n\t\tglyphindex, err := c.fontSubset.CharIndex(r)\n\t\tif err == ErrCharNotFound {\n\t\t\tcontinue\n\t\t} else if err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tpairvalPdfUnit := 0\n\t\tif i > 0 && c.fontSubset.ttfFontOption.UseKerning { //kerning\n\t\t\tpairval := kern(c.fontSubset, leftRune, r, leftRuneIndex, glyphindex)\n\t\t\tpairvalPdfUnit = convertTTFUnit2PDFUnit(int(pairval), unitsPerEm)\n\t\t\tif pairvalPdfUnit != 0 {\n\t\t\t\tfmt.Fprintf(w, \">%d<\", (-1)*pairvalPdfUnit)\n\t\t\t}\n\t\t}\n\n\t\tfmt.Fprintf(w, \"%04X\", glyphindex)\n\t\tleftRune = r\n\t\tleftRuneIndex = glyphindex\n\t}\n\n\tio.WriteString(w, \">] TJ\\n\")\n\tio.WriteString(w, \"ET\\n\")\n\n\tif c.fontStyle&Underline == Underline {\n\t\tif err := c.underline(w); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\tc.drawBorder(w)\n\n\treturn nil\n}\n\nfunc (c *cacheContentText) drawBorder(w io.Writer) error {\n\n\t//stream.WriteString(fmt.Sprintf(\"%.2f w\\n\", 0.1))\n\tlineOffset := c.lineWidth * 0.5\n\n\tif c.cellOpt.Border&Top == Top {\n\n\t\tstartX := c.x - lineOffset\n\t\tstartY := c.pageHeight() - c.y\n\t\tendX := c.x + c.cellWidthPdfUnit + lineOffset\n\t\tendY := startY\n\t\t_, err := fmt.Fprintf(w, \"%0.2f %0.2f m %0.2f %0.2f l s\\n\", startX, startY, endX, endY)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\tif c.cellOpt.Border&Left == Left {\n\t\tstartX := c.x\n\t\tstartY := c.pageHeight() - c.y\n\t\tendX := c.x\n\t\tendY := startY - c.cellHeightPdfUnit\n\t\t_, err := fmt.Fprintf(w, \"%0.2f %0.2f m %0.2f %0.2f l s\\n\", startX, startY, endX, endY)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\tif c.cellOpt.Border&Right == Right {\n\t\tstartX := c.x + c.cellWidthPdfUnit\n\t\tstartY := c.pageHeight() - c.y\n\t\tendX := c.x + c.cellWidthPdfUnit\n\t\tendY := startY - c.cellHeightPdfUnit\n\t\t_, err := fmt.Fprintf(w, \"%0.2f %0.2f m %0.2f %0.2f l s\\n\", startX, startY, endX, endY)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\tif c.cellOpt.Border&Bottom == Bottom {\n\t\tstartX := c.x - lineOffset\n\t\tstartY := c.pageHeight() - c.y - c.cellHeightPdfUnit\n\t\tendX := c.x + c.cellWidthPdfUnit + lineOffset\n\t\tendY := startY\n\t\t_, err := fmt.Fprintf(w, \"%0.2f %0.2f m %0.2f %0.2f l s\\n\", startX, startY, endX, endY)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\treturn nil\n}\n\nfunc (c *cacheContentText) underline(w io.Writer) error {\n\tif c.fontSubset == nil {\n\t\treturn errors.New(\"error AppendUnderline not found font\")\n\t}\n\n\tcoefLineHeight := defaultCoefLineHeight\n\tif c.cellOpt.CoefLineHeight != 0 {\n\t\tcoefLineHeight = c.cellOpt.CoefLineHeight\n\t}\n\n\tcoefUnderlinePosition := defaultCoefUnderlinePosition\n\tif c.cellOpt.CoefUnderlinePosition != 0 {\n\t\tcoefUnderlinePosition = c.cellOpt.CoefUnderlinePosition\n\t}\n\n\tcoefUnderlineThickness := defaultcoefUnderlineThickness\n\tif c.cellOpt.CoefUnderlineThickness != 0 {\n\t\tcoefUnderlineThickness = c.cellOpt.CoefUnderlineThickness\n\t}\n\n\tascenderPx := c.fontSubset.GetAscenderPx(c.fontSize)\n\tdescenderPx := -c.fontSubset.GetDescenderPx(c.fontSize)\n\n\tcontentHeight := ascenderPx + descenderPx\n\tvirtualHeight := coefLineHeight * float64(c.fontSize)\n\tleading := (contentHeight - virtualHeight) / 2\n\n\tbaseline := ascenderPx + leading\n\n\tunderlinePositionPx := c.fontSubset.GetUnderlinePositionPx(c.fontSize) * coefUnderlinePosition\n\tunderlineThicknessPx := c.fontSubset.GetUnderlineThicknessPx(c.fontSize) * coefUnderlineThickness\n\n\tyUnderlinePosition := c.pageHeight() - c.y + underlinePositionPx - baseline\n\tif _, err := fmt.Fprintf(w, \"%0.2f %0.2f %0.2f %0.2f re f\\n\", c.x, yUnderlinePosition, c.cellWidthPdfUnit, underlineThicknessPx); err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\nfunc (c *cacheContentText) createContent() (float64, float64, error) {\n\n\tcellWidthPdfUnit, cellHeightPdfUnit, textWidthPdfUnit, err := createContent(c.fontSubset, c.text, c.fontSize, c.charSpacing, c.rectangle)\n\tif err != nil {\n\t\treturn 0, 0, err\n\t}\n\tc.cellWidthPdfUnit = cellWidthPdfUnit\n\tc.cellHeightPdfUnit = cellHeightPdfUnit\n\tc.textWidthPdfUnit = textWidthPdfUnit\n\treturn cellWidthPdfUnit, cellHeightPdfUnit, nil\n}\n\nfunc createContent(f *SubsetFontObj, text string, fontSize float64, charSpacing float64, rectangle *Rect) (float64, float64, float64, error) {\n\n\tunitsPerEm := int(f.ttfp.UnitsPerEm())\n\tvar leftRune rune\n\tvar leftRuneIndex uint\n\tsumWidth := int(0)\n\t//fmt.Printf(\"unitsPerEm = %d\", unitsPerEm)\n\tfor i, r := range text {\n\n\t\tglyphindex, err := f.CharIndex(r)\n\t\tif err == ErrCharNotFound {\n\t\t\tcontinue\n\t\t} else if err != nil {\n\t\t\treturn 0, 0, 0, err\n\t\t}\n\n\t\tpairvalPdfUnit := 0\n\t\tif i > 0 && f.ttfFontOption.UseKerning { //kerning\n\t\t\tpairval := kern(f, leftRune, r, leftRuneIndex, glyphindex)\n\t\t\tpairvalPdfUnit = convertTTFUnit2PDFUnit(int(pairval), unitsPerEm)\n\t\t}\n\n\t\twidth, err := f.CharWidth(r)\n\t\tif err != nil {\n\t\t\treturn 0, 0, 0, err\n\t\t}\n\n\t\tunitsPerPt := float64(unitsPerEm) / fontSize\n\t\tspaceWidthInPt := unitsPerPt * charSpacing\n\t\tspaceWidthPdfUnit := convertTTFUnit2PDFUnit(int(spaceWidthInPt), unitsPerEm)\n\n\t\tsumWidth += int(width) + int(pairvalPdfUnit) + spaceWidthPdfUnit\n\t\tleftRune = r\n\t\tleftRuneIndex = glyphindex\n\t}\n\n\tcellWidthPdfUnit := float64(0)\n\tcellHeightPdfUnit := float64(0)\n\tif rectangle == nil {\n\t\tcellWidthPdfUnit = float64(sumWidth) * (float64(fontSize) / 1000.0)\n\t\ttypoAscender := convertTypoUnit(float64(f.ttfp.TypoAscender()), f.ttfp.UnitsPerEm(), float64(fontSize))\n\t\ttypoDescender := convertTypoUnit(float64(f.ttfp.TypoDescender()), f.ttfp.UnitsPerEm(), float64(fontSize))\n\t\tcellHeightPdfUnit = typoAscender - typoDescender\n\t} else {\n\t\tcellWidthPdfUnit = rectangle.W\n\t\tcellHeightPdfUnit = rectangle.H\n\t}\n\ttextWidthPdfUnit := float64(sumWidth) * (float64(fontSize) / 1000.0)\n\treturn cellWidthPdfUnit, cellHeightPdfUnit, textWidthPdfUnit, nil\n}\n\nfunc kern(f *SubsetFontObj, leftRune rune, rightRune rune, leftIndex uint, rightIndex uint) int16 {\n\n\tpairVal := int16(0)\n\tif haveKerning, kval := f.KernValueByLeft(leftIndex); haveKerning {\n\t\tif ok, v := kval.ValueByRight(rightIndex); ok {\n\t\t\tpairVal = v\n\t\t}\n\t}\n\n\tif f.funcKernOverride != nil {\n\t\tpairVal = f.funcKernOverride(\n\t\t\tleftRune,\n\t\t\trightRune,\n\t\t\tleftIndex,\n\t\t\trightIndex,\n\t\t\tpairVal,\n\t\t)\n\t}\n\treturn pairVal\n}\n\n// CacheContent Export cacheContent\ntype CacheContent struct {\n\tcacheContentText\n}\n\n// Setup setup all information for cacheContent\nfunc (c *CacheContent) Setup(rectangle *Rect,\n\ttextColor ICacheColorText,\n\tgrayFill float64,\n\tfontCountIndex int, //Curr.FontFontCount+1\n\tfontSize float64,\n\tfontStyle int,\n\tcharSpacing float64,\n\tsetXCount int, //จำนวนครั้งที่ใช้ setX\n\tx, y float64,\n\tfontSubset *SubsetFontObj,\n\tpageheight float64,\n\tcontentType int,\n\tcellOpt CellOption,\n\tlineWidth float64,\n) {\n\tc.cacheContentText = cacheContentText{\n\t\tfontSubset:     fontSubset,\n\t\trectangle:      rectangle,\n\t\ttextColor:      textColor,\n\t\tgrayFill:       grayFill,\n\t\tfontCountIndex: fontCountIndex,\n\t\tfontSize:       fontSize,\n\t\tfontStyle:      fontStyle,\n\t\tcharSpacing:    charSpacing,\n\t\tsetXCount:      setXCount,\n\t\tx:              x,\n\t\ty:              y,\n\t\tpageheight:     pageheight,\n\t\tcontentType:    ContentTypeCell,\n\t\tcellOpt:        cellOpt,\n\t\tlineWidth:      lineWidth,\n\t}\n}\n\n// WriteTextToContent write text to content\nfunc (c *CacheContent) WriteTextToContent(text string) {\n\tc.cacheContentText.text += text\n}\n"
        },
        {
          "name": "cache_content_text_color_cmyk.go",
          "type": "blob",
          "size": 0.544921875,
          "content": "package gopdf\n\nimport (\n\t\"fmt\"\n\t\"io\"\n)\n\ntype cacheContentTextColorCMYK struct {\n\tc, m, y, k uint8\n}\n\nfunc (c cacheContentTextColorCMYK) write(w io.Writer, protection *PDFProtection) error {\n\tfmt.Fprintf(w, \"%.2f %.2f %.2f %.2f %s\\n\", float64(c.c)/100, float64(c.m)/100, float64(c.y)/100, float64(c.k)/100, colorTypeFillCMYK)\n\treturn nil\n}\n\nfunc (c cacheContentTextColorCMYK) equal(obj ICacheColorText) bool {\n\tcmyk, ok := obj.(cacheContentTextColorCMYK)\n\tif !ok {\n\t\treturn false\n\t}\n\n\treturn c.c == cmyk.c && c.m == cmyk.m && c.y == cmyk.y && c.k == cmyk.k\n}\n"
        },
        {
          "name": "cache_content_text_color_rgb.go",
          "type": "blob",
          "size": 0.494140625,
          "content": "package gopdf\n\nimport (\n\t\"fmt\"\n\t\"io\"\n)\n\ntype cacheContentTextColorRGB struct {\n\tr, g, b uint8\n}\n\nfunc (c cacheContentTextColorRGB) write(w io.Writer, protection *PDFProtection) error {\n\tfmt.Fprintf(w, \"%.3f %.3f %.3f %s\\n\", float64(c.r)/255, float64(c.g)/255, float64(c.b)/255, colorTypeFillRGB)\n\treturn nil\n}\n\nfunc (c cacheContentTextColorRGB) equal(obj ICacheColorText) bool {\n\trgb, ok := obj.(cacheContentTextColorRGB)\n\tif !ok {\n\t\treturn false\n\t}\n\n\treturn c.r == rgb.r && c.g == rgb.g && c.b == rgb.b\n}\n"
        },
        {
          "name": "cache_contnent_curve.go",
          "type": "blob",
          "size": 0.7705078125,
          "content": "package gopdf\n\nimport (\n\t\"fmt\"\n\t\"io\"\n)\n\ntype cacheContentCurve struct {\n\tpageHeight float64\n\tx0         float64\n\ty0         float64\n\tx1         float64\n\ty1         float64\n\tx2         float64\n\ty2         float64\n\tx3         float64\n\ty3         float64\n\tstyle      string\n}\n\nfunc (c *cacheContentCurve) write(w io.Writer, protection *PDFProtection) error {\n\n\th := c.pageHeight\n\tx0 := c.x0\n\ty0 := c.y0\n\tx1 := c.x1\n\ty1 := c.y1\n\tx2 := c.x2\n\ty2 := c.y2\n\tx3 := c.x3\n\ty3 := c.y3\n\tstyle := c.style\n\n\t//cp := 0.55228\n\tfmt.Fprintf(w, \"%0.2f %0.2f m\\n\", x0, h-y0)\n\tfmt.Fprintf(w,\n\t\t\"%0.2f %0.2f %0.2f %0.2f %0.2f %0.2f c\",\n\t\tx1, h-y1, x2, h-y2, x3, h-y3,\n\t)\n\top := \"S\"\n\tif style == \"F\" {\n\t\top = \"f\"\n\t} else if style == \"FD\" || style == \"DF\" {\n\t\top = \"B\"\n\t}\n\tfmt.Fprintf(w, \" %s\\n\", op)\n\treturn nil\n}\n"
        },
        {
          "name": "catalog_obj.go",
          "type": "blob",
          "size": 0.6953125,
          "content": "package gopdf\n\nimport (\n\t\"fmt\"\n\t\"io\"\n)\n\n// CatalogObj : catalog dictionary\ntype CatalogObj struct { //impl IObj\n\toutlinesObjID int\n}\n\nfunc (c *CatalogObj) init(funcGetRoot func() *GoPdf) {\n\tc.outlinesObjID = -1\n\n}\n\nfunc (c *CatalogObj) getType() string {\n\treturn \"Catalog\"\n}\n\nfunc (c *CatalogObj) write(w io.Writer, objID int) error {\n\tio.WriteString(w, \"<<\\n\")\n\tfmt.Fprintf(w, \"  /Type /%s\\n\", c.getType())\n\tio.WriteString(w, \"  /Pages 2 0 R\\n\")\n\tif c.outlinesObjID >= 0 {\n\t\tio.WriteString(w, \"  /PageMode /UseOutlines\\n\")\n\t\tfmt.Fprintf(w, \"  /Outlines %d 0 R\\n\", c.outlinesObjID)\n\t}\n\tio.WriteString(w, \">>\\n\")\n\treturn nil\n}\n\nfunc (c *CatalogObj) SetIndexObjOutlines(index int) {\n\tc.outlinesObjID = index + 1\n}\n"
        },
        {
          "name": "cell_option.go",
          "type": "blob",
          "size": 0.9150390625,
          "content": "package gopdf\n\n// Left left\nconst Left = 8 //001000\n// Top top\nconst Top = 4 //000100\n// Right right\nconst Right = 2 //000010\n// Bottom bottom\nconst Bottom = 1 //000001\n// Center center\nconst Center = 16 //010000\n// Middle middle\nconst Middle = 32 //100000\n// AllBorders allborders\nconst AllBorders = 15 //001111\n\n// CellOption cell option\ntype CellOption struct {\n\tAlign                  int //Allows to align the text. Possible values are: Left,Center,Right,Top,Bottom,Middle\n\tBorder                 int //Indicates if borders must be drawn around the cell. Possible values are: Left, Top, Right, Bottom, ALL\n\tFloat                  int //Indicates where the current position should go after the call. Possible values are: Right, Bottom\n\tTransparency           *Transparency\n\tCoefUnderlinePosition  float64\n\tCoefLineHeight         float64\n\tCoefUnderlineThickness float64\n\tBreakOption            *BreakOption\n\n\textGStateIndexes []int\n}\n"
        },
        {
          "name": "cid_font_obj.go",
          "type": "blob",
          "size": 1.537109375,
          "content": "package gopdf\n\nimport (\n\t\"fmt\"\n\t\"io\"\n)\n\n// CIDFontObj is a CID-keyed font.\n// cf. https://www.adobe.com/content/dam/acom/en/devnet/font/pdfs/5014.CIDFont_Spec.pdf\ntype CIDFontObj struct {\n\tPtrToSubsetFontObj        *SubsetFontObj\n\tindexObjSubfontDescriptor int\n}\n\nfunc (ci *CIDFontObj) init(funcGetRoot func() *GoPdf) {\n}\n\n// SetIndexObjSubfontDescriptor set  indexObjSubfontDescriptor\nfunc (ci *CIDFontObj) SetIndexObjSubfontDescriptor(index int) {\n\tci.indexObjSubfontDescriptor = index\n}\n\nfunc (ci *CIDFontObj) getType() string {\n\treturn \"CIDFont\"\n}\n\nfunc (ci *CIDFontObj) write(w io.Writer, objID int) error {\n\tio.WriteString(w, \"<<\\n\")\n\tfmt.Fprintf(w, \"/BaseFont /%s\\n\", CreateEmbeddedFontSubsetName(ci.PtrToSubsetFontObj.GetFamily()))\n\tio.WriteString(w, \"/CIDSystemInfo\\n\")\n\tio.WriteString(w, \"<<\\n\")\n\tio.WriteString(w, \"  /Ordering (Identity)\\n\")\n\tio.WriteString(w, \"  /Registry (Adobe)\\n\")\n\tio.WriteString(w, \"  /Supplement 0\\n\")\n\tio.WriteString(w, \">>\\n\")\n\tfmt.Fprintf(w, \"/FontDescriptor %d 0 R\\n\", ci.indexObjSubfontDescriptor+1) //TODO fix\n\tio.WriteString(w, \"/Subtype /CIDFontType2\\n\")\n\tio.WriteString(w, \"/Type /Font\\n\")\n\tglyphIndexs := ci.PtrToSubsetFontObj.CharacterToGlyphIndex.AllVals()\n\tio.WriteString(w, \"/W [\")\n\tfor _, v := range glyphIndexs {\n\t\twidth := ci.PtrToSubsetFontObj.GlyphIndexToPdfWidth(v)\n\t\tfmt.Fprintf(w, \"%d[%d]\", v, width)\n\t}\n\tio.WriteString(w, \"]\\n\")\n\tio.WriteString(w, \">>\\n\")\n\treturn nil\n}\n\n// SetPtrToSubsetFontObj set PtrToSubsetFontObj\nfunc (ci *CIDFontObj) SetPtrToSubsetFontObj(ptr *SubsetFontObj) {\n\tci.PtrToSubsetFontObj = ptr\n}\n"
        },
        {
          "name": "config.go",
          "type": "blob",
          "size": 4.3134765625,
          "content": "package gopdf\n\n// The units that can be used in the document\nconst (\n\tUnitUnset = iota // No units were set, when conversion is called on nothing will happen\n\tUnitPT           // Points\n\tUnitMM           // Millimeters\n\tUnitCM           // Centimeters\n\tUnitIN           // Inches\n\tUnitPX           // Pixels\n\n\t// The math needed to convert units to points\n\tconversionUnitPT = 1.0\n\tconversionUnitMM = 72.0 / 25.4\n\tconversionUnitCM = 72.0 / 2.54\n\tconversionUnitIN = 72.0\n\t//We use a dpi of 96 dpi as the default, so we get a conversionUnitPX = 3.0 / 4.0, which comes from 72.0 / 96.0.\n\t//If you want to change this value, you can change it at Config.ConversionForUnit\n\t//example: If you use dpi at 300.0\n\t//pdf.Start(gopdf.Config{PageSize: *gopdf.PageSizeA4, ConversionForUnit: 72.0 / 300.0 })\n\tconversionUnitPX = 3.0 / 4.0\n)\n\n// The units that can be used in the document (for backward compatibility)\n// Deprecated: Use UnitUnset,UnitPT,UnitMM,UnitCM,UnitIN  instead\nconst (\n\tUnit_Unset = UnitUnset // No units were set, when conversion is called on nothing will happen\n\tUnit_PT    = UnitPT    // Points\n\tUnit_MM    = UnitMM    // Millimeters\n\tUnit_CM    = UnitCM    // Centimeters\n\tUnit_IN    = UnitIN    // Inches\n\tUnit_PX    = UnitPX    // Pixels\n)\n\n// Config static config\ntype Config struct {\n\tUnit int // The unit type to use when composing the document.\n\t//Value that use to convert units to points.\n\t//If this variable is not 0. This value will be used to calculate the unit conversion instead of the existing const value in the system.\n\t//And if this variable is not 0. Value ​​in Config.Unit will not be used.\n\tConversionForUnit float64\n\tTrimBox           Box                 // The default trim box for all pages in the document\n\tPageSize          Rect                // The default page size for all pages in the document\n\tK                 float64             // Not sure\n\tProtection        PDFProtectionConfig // Protection settings\n}\n\nfunc (c Config) getUnit() int {\n\treturn c.Unit\n}\nfunc (c Config) getConversionForUnit() float64 {\n\treturn c.ConversionForUnit\n}\n\n// PDFProtectionConfig config of pdf protection\ntype PDFProtectionConfig struct {\n\tUseProtection bool\n\tPermissions   int\n\tUserPass      []byte\n\tOwnerPass     []byte\n}\n\n// UnitsToPoints converts units of the provided type to points\nfunc UnitsToPoints(t int, u float64) float64 {\n\treturn unitsToPoints(defaultUnitConfig{Unit: t}, u)\n}\n\nfunc unitsToPoints(unitCfg unitConfigurator, u float64) float64 {\n\tif unitCfg.getConversionForUnit() != 0 {\n\t\treturn u * unitCfg.getConversionForUnit()\n\t}\n\tswitch unitCfg.getUnit() {\n\tcase UnitPT:\n\t\treturn u * conversionUnitPT\n\tcase UnitMM:\n\t\treturn u * conversionUnitMM\n\tcase UnitCM:\n\t\treturn u * conversionUnitCM\n\tcase UnitIN:\n\t\treturn u * conversionUnitIN\n\tcase UnitPX:\n\t\treturn u * conversionUnitPX\n\tdefault:\n\t\treturn u\n\t}\n}\n\n// PointsToUnits converts points to the provided units\nfunc PointsToUnits(t int, u float64) float64 {\n\treturn pointsToUnits(defaultUnitConfig{Unit: t}, u)\n}\n\nfunc pointsToUnits(unitCfg unitConfigurator, u float64) float64 {\n\tif unitCfg.getConversionForUnit() != 0 {\n\t\treturn u * unitCfg.getConversionForUnit()\n\t}\n\tswitch unitCfg.getUnit() {\n\tcase UnitPT:\n\t\treturn u / conversionUnitPT\n\tcase UnitMM:\n\t\treturn u / conversionUnitMM\n\tcase UnitCM:\n\t\treturn u / conversionUnitCM\n\tcase UnitIN:\n\t\treturn u / conversionUnitIN\n\tcase UnitPX:\n\t\treturn u / conversionUnitPX\n\tdefault:\n\t\treturn u\n\t}\n}\n\n// UnitsToPointsVar converts units of the provided type to points for all variables supplied\nfunc UnitsToPointsVar(t int, u ...*float64) {\n\tunitsToPointsVar(defaultUnitConfig{Unit: t}, u...)\n}\n\nfunc unitsToPointsVar(unitCfg unitConfigurator, u ...*float64) {\n\tfor x := 0; x < len(u); x++ {\n\t\t*u[x] = unitsToPoints(unitCfg, *u[x])\n\t}\n}\n\n// PointsToUnitsVar converts points to the provided units for all variables supplied\nfunc PointsToUnitsVar(t int, u ...*float64) {\n\tpointsToUnitsVar(defaultUnitConfig{Unit: t}, u...)\n}\n\nfunc pointsToUnitsVar(unitCfg unitConfigurator, u ...*float64) {\n\tfor x := 0; x < len(u); x++ {\n\t\t*u[x] = pointsToUnits(unitCfg, *u[x])\n\t}\n}\n\ntype unitConfigurator interface {\n\tgetUnit() int\n\tgetConversionForUnit() float64\n}\n\ntype defaultUnitConfig struct {\n\tUnit              int\n\tConversionForUnit float64\n}\n\nfunc (d defaultUnitConfig) getUnit() int {\n\treturn d.Unit\n}\nfunc (d defaultUnitConfig) getConversionForUnit() float64 {\n\treturn d.ConversionForUnit\n}\n"
        },
        {
          "name": "content_obj.go",
          "type": "blob",
          "size": 12.4736328125,
          "content": "package gopdf\n\nimport (\n\t\"compress/zlib\"\n\t\"fmt\"\n\t\"io\"\n\t\"strings\"\n)\n\n// ContentObj content object\ntype ContentObj struct { //impl IObj\n\tlistCache listCacheContent\n\t//text bytes.Buffer\n\tgetRoot func() *GoPdf\n}\n\nfunc (c *ContentObj) protection() *PDFProtection {\n\treturn c.getRoot().protection()\n}\n\nfunc (c *ContentObj) init(funcGetRoot func() *GoPdf) {\n\tc.getRoot = funcGetRoot\n}\n\nfunc (c *ContentObj) write(w io.Writer, objID int) error {\n\tbuff := GetBuffer()\n\tdefer PutBuffer(buff)\n\n\tisFlate := (c.getRoot().compressLevel != zlib.NoCompression)\n\tif isFlate {\n\t\tww, err := zlib.NewWriterLevel(buff, c.getRoot().compressLevel)\n\t\tif err != nil {\n\t\t\t// should never happen...\n\t\t\treturn err\n\t\t}\n\t\tif err := c.listCache.write(ww, c.protection()); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif err := ww.Close(); err != nil {\n\t\t\treturn err\n\t\t}\n\t} else {\n\t\tif err := c.listCache.write(buff, c.protection()); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\tif _, err := io.WriteString(w, \"<<\\n\"); err != nil {\n\t\treturn err\n\t}\n\n\tif isFlate {\n\t\tif _, err := io.WriteString(w, \"/Filter/FlateDecode\"); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\tif _, err := fmt.Fprintf(w, \"/Length %d\\n\", buff.Len()); err != nil {\n\t\treturn err\n\t}\n\tif _, err := io.WriteString(w, \">>\\n\"); err != nil {\n\t\treturn err\n\t}\n\tif _, err := io.WriteString(w, \"stream\\n\"); err != nil {\n\t\treturn err\n\t}\n\n\tif c.protection() != nil {\n\t\ttmp, err := rc4Cip(c.protection().objectkey(objID), buff.Bytes())\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tif _, err := w.Write(tmp); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif _, err := io.WriteString(w, \"\\n\"); err != nil {\n\t\t\treturn err\n\t\t}\n\t} else {\n\t\tif _, err := buff.WriteTo(w); err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tif isFlate {\n\t\t\tif _, err := io.WriteString(w, \"\\n\"); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t}\n\tif _, err := io.WriteString(w, \"endstream\\n\"); err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\nfunc (c *ContentObj) getType() string {\n\treturn \"Content\"\n}\n\n// AppendStreamText append text\nfunc (c *ContentObj) appendStreamPlaceHolderText(placeHolderWidth float64) error {\n\n\t//support only CURRENT_FONT_TYPE_SUBSET\n\ttextColor := c.getRoot().curr.textColor()\n\tgrayFill := c.getRoot().curr.grayFill\n\tfontCountIndex := c.getRoot().curr.FontFontCount + 1\n\tfontSize := c.getRoot().curr.FontSize\n\tfontStyle := c.getRoot().curr.FontStyle\n\tcharSpacing := c.getRoot().curr.CharSpacing\n\tx := c.getRoot().curr.X\n\ty := c.getRoot().curr.Y\n\tsetXCount := c.getRoot().curr.setXCount\n\tfontSubset := c.getRoot().curr.FontISubset\n\n\tcellOption := CellOption{Transparency: c.getRoot().curr.transparency}\n\n\tcache := cacheContentText{\n\t\tfontSubset:     fontSubset,\n\t\trectangle:      nil,\n\t\ttextColor:      textColor,\n\t\tgrayFill:       grayFill,\n\t\tfontCountIndex: fontCountIndex,\n\t\tfontSize:       fontSize,\n\t\tfontStyle:      fontStyle,\n\t\tcharSpacing:    charSpacing,\n\t\tsetXCount:      setXCount,\n\t\tx:              x,\n\t\ty:              y,\n\t\tcellOpt:        cellOption,\n\t\tpageheight:     c.getRoot().curr.pageSize.H,\n\t\tcontentType:    ContentTypeText,\n\t\tlineWidth:      c.getRoot().curr.lineWidth,\n\t\ttxtColorMode:   c.getRoot().curr.txtColorMode,\n\t\tisPlaceHolder:  true,\n\t}\n\n\t//var err error\n\t//c.getRoot().curr.X, c.getRoot().curr.Y, err = c.listCache.appendContentText(cache, \"\")\n\t//if err != nil {\n\t//\treturn err\n\t//}\n\tc.listCache.append(&cache)\n\tc.getRoot().curr.X += placeHolderWidth\n\n\treturn nil\n}\n\n// AppendStreamText append text\nfunc (c *ContentObj) AppendStreamText(text string) error {\n\n\t//support only CURRENT_FONT_TYPE_SUBSET\n\ttextColor := c.getRoot().curr.textColor()\n\tgrayFill := c.getRoot().curr.grayFill\n\tfontCountIndex := c.getRoot().curr.FontFontCount + 1\n\tfontSize := c.getRoot().curr.FontSize\n\tfontStyle := c.getRoot().curr.FontStyle\n\tcharSpacing := c.getRoot().curr.CharSpacing\n\tx := c.getRoot().curr.X\n\ty := c.getRoot().curr.Y\n\tsetXCount := c.getRoot().curr.setXCount\n\tfontSubset := c.getRoot().curr.FontISubset\n\n\tcellOption := CellOption{Transparency: c.getRoot().curr.transparency}\n\n\tcache := cacheContentText{\n\t\tfontSubset:     fontSubset,\n\t\trectangle:      nil,\n\t\ttextColor:      textColor,\n\t\tgrayFill:       grayFill,\n\t\tfontCountIndex: fontCountIndex,\n\t\tfontSize:       fontSize,\n\t\tfontStyle:      fontStyle,\n\t\tcharSpacing:    charSpacing,\n\t\tsetXCount:      setXCount,\n\t\tx:              x,\n\t\ty:              y,\n\t\tcellOpt:        cellOption,\n\t\tpageheight:     c.getRoot().curr.pageSize.H,\n\t\tcontentType:    ContentTypeText,\n\t\tlineWidth:      c.getRoot().curr.lineWidth,\n\t\ttxtColorMode:   c.getRoot().curr.txtColorMode,\n\t}\n\n\tvar err error\n\tc.getRoot().curr.X, c.getRoot().curr.Y, err = c.listCache.appendContentText(cache, text)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\n// AppendStreamSubsetFont add stream of text\nfunc (c *ContentObj) AppendStreamSubsetFont(rectangle *Rect, text string, cellOpt CellOption) error {\n\n\ttextColor := c.getRoot().curr.textColor()\n\tgrayFill := c.getRoot().curr.grayFill\n\tfontCountIndex := c.getRoot().curr.FontFontCount + 1\n\tfontSize := c.getRoot().curr.FontSize\n\tfontStyle := c.getRoot().curr.FontStyle\n\tcharSpacing := c.getRoot().curr.CharSpacing\n\tx := c.getRoot().curr.X\n\ty := c.getRoot().curr.Y\n\tsetXCount := c.getRoot().curr.setXCount\n\tfontSubset := c.getRoot().curr.FontISubset\n\n\tcache := cacheContentText{\n\t\tfontSubset:     fontSubset,\n\t\trectangle:      rectangle,\n\t\ttextColor:      textColor,\n\t\tgrayFill:       grayFill,\n\t\tfontCountIndex: fontCountIndex,\n\t\tfontSize:       fontSize,\n\t\tfontStyle:      fontStyle,\n\t\tcharSpacing:    charSpacing,\n\t\tsetXCount:      setXCount,\n\t\tx:              x,\n\t\ty:              y,\n\t\tpageheight:     c.getRoot().curr.pageSize.H,\n\t\tcontentType:    ContentTypeCell,\n\t\tcellOpt:        cellOpt,\n\t\tlineWidth:      c.getRoot().curr.lineWidth,\n\t\ttxtColorMode:   c.getRoot().curr.txtColorMode,\n\t}\n\tvar err error\n\tc.getRoot().curr.X, c.getRoot().curr.Y, err = c.listCache.appendContentText(cache, text)\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}\n\n// AppendStreamLine append line\nfunc (c *ContentObj) AppendStreamLine(x1 float64, y1 float64, x2 float64, y2 float64, lineOpts lineOptions) {\n\t//h := c.getRoot().config.PageSize.H\n\t//c.stream.WriteString(fmt.Sprintf(\"%0.2f %0.2f m %0.2f %0.2f l s\\n\", x1, h-y1, x2, h-y2))\n\tvar cache cacheContentLine\n\tcache.pageHeight = c.getRoot().curr.pageSize.H\n\tcache.x1 = x1\n\tcache.y1 = y1\n\tcache.x2 = x2\n\tcache.y2 = y2\n\tcache.opts = lineOpts\n\tc.listCache.append(&cache)\n}\n\n// AppendStreamImportedTemplate append imported template\nfunc (c *ContentObj) AppendStreamImportedTemplate(tplName string, scaleX float64, scaleY float64, tX float64, tY float64) {\n\tvar cache cacheContentImportedTemplate\n\tcache.pageHeight = c.getRoot().curr.pageSize.H\n\tcache.tplName = tplName\n\tcache.scaleX = scaleX\n\tcache.scaleY = scaleY\n\tcache.tX = tX\n\tcache.tY = tY\n\tc.listCache.append(&cache)\n}\n\nfunc (c *ContentObj) AppendStreamRectangle(opts DrawableRectOptions) {\n\tcache := NewCacheContentRectangle(c.getRoot().curr.pageSize.H, opts)\n\tc.listCache.append(cache)\n}\n\n// AppendStreamOval append oval\nfunc (c *ContentObj) AppendStreamOval(x1 float64, y1 float64, x2 float64, y2 float64) {\n\tvar cache cacheContentOval\n\tcache.pageHeight = c.getRoot().curr.pageSize.H\n\tcache.x1 = x1\n\tcache.y1 = y1\n\tcache.x2 = x2\n\tcache.y2 = y2\n\tc.listCache.append(&cache)\n}\n\n// AppendStreamCurve draw curve\n//   - x0, y0: Start point\n//   - x1, y1: Control point 1\n//   - x2, y2: Control point 2\n//   - x3, y3: End point\n//   - style: Style of rectangule (draw and/or fill: D, F, DF, FD)\n//     D or empty string: draw. This is the default value.\n//     F: fill\n//     DF or FD: draw and fill\nfunc (c *ContentObj) AppendStreamCurve(x0 float64, y0 float64, x1 float64, y1 float64, x2 float64, y2 float64, x3 float64, y3 float64, style string) {\n\tvar cache cacheContentCurve\n\tcache.pageHeight = c.getRoot().curr.pageSize.H\n\tcache.x0 = x0\n\tcache.y0 = y0\n\tcache.x1 = x1\n\tcache.y1 = y1\n\tcache.x2 = x2\n\tcache.y2 = y2\n\tcache.x3 = x3\n\tcache.y3 = y3\n\tcache.style = strings.ToUpper(strings.TrimSpace(style))\n\tc.listCache.append(&cache)\n}\n\n// AppendStreamSetLineWidth : set line width\nfunc (c *ContentObj) AppendStreamSetLineWidth(w float64) {\n\tvar cache cacheContentLineWidth\n\tcache.width = w\n\tc.listCache.append(&cache)\n}\n\n// AppendStreamSetLineType : Set linetype [solid, dashed, dotted]\nfunc (c *ContentObj) AppendStreamSetLineType(t string) {\n\tvar cache cacheContentLineType\n\tcache.lineType = t\n\tc.listCache.append(&cache)\n}\n\n// AppendStreamSetCustomLineType : set a custom line type\nfunc (c *ContentObj) AppendStreamSetCustomLineType(a []float64, p float64) {\n\tvar cache cacheContentCustomLineType\n\tcache.dashArray = a\n\tcache.dashPhase = p\n\tc.listCache.append(&cache)\n}\n\n// AppendStreamSetGrayFill  set the grayscale fills\nfunc (c *ContentObj) AppendStreamSetGrayFill(w float64) {\n\tw = fixRange10(w)\n\tvar cache cacheContentGray\n\tcache.grayType = grayTypeFill\n\tcache.scale = w\n\tc.listCache.append(&cache)\n}\n\n// AppendStreamSetGrayStroke  set the grayscale stroke\nfunc (c *ContentObj) AppendStreamSetGrayStroke(w float64) {\n\tw = fixRange10(w)\n\tvar cache cacheContentGray\n\tcache.grayType = grayTypeStroke\n\tcache.scale = w\n\tc.listCache.append(&cache)\n}\n\n// AppendStreamSetColorStroke  set the color stroke\nfunc (c *ContentObj) AppendStreamSetColorStroke(r uint8, g uint8, b uint8) {\n\tvar cache cacheContentColorRGB\n\tcache.colorType = colorTypeStrokeRGB\n\tcache.r = r\n\tcache.g = g\n\tcache.b = b\n\tc.listCache.append(&cache)\n}\n\n// AppendStreamSetColorFill  set the color fill\nfunc (c *ContentObj) AppendStreamSetColorFill(r uint8, g uint8, b uint8) {\n\tvar cache cacheContentColorRGB\n\tcache.colorType = colorTypeFillRGB\n\tcache.r = r\n\tcache.g = g\n\tcache.b = b\n\tc.listCache.append(&cache)\n}\n\n// AppendStreamSetColorStrokeCMYK  set the color stroke in CMYK color mode\nfunc (c *ContentObj) AppendStreamSetColorStrokeCMYK(cy, m, y, k uint8) {\n\tvar cache cacheContentColorCMYK\n\tcache.colorType = colorTypeStrokeCMYK\n\tcache.c = cy\n\tcache.m = m\n\tcache.y = y\n\tcache.k = k\n\tc.listCache.append(&cache)\n}\n\n// AppendStreamSetColorFillCMYK  set the color fill in CMYK color mode\nfunc (c *ContentObj) AppendStreamSetColorFillCMYK(cy, m, y, k uint8) {\n\tvar cache cacheContentColorCMYK\n\tcache.colorType = colorTypeFillCMYK\n\tcache.c = cy\n\tcache.m = m\n\tcache.y = y\n\tcache.k = k\n\tc.listCache.append(&cache)\n}\n\nfunc (c *ContentObj) GetCacheContentImage(index int, opts ImageOptions) *cacheContentImage {\n\th := c.getRoot().curr.pageSize.H\n\n\twithMask := false\n\tmaskAngle := float64(0)\n\n\tif opts.Mask != nil {\n\t\twithMask = true\n\t\tmaskAngle = opts.Mask.DegreeAngle\n\t}\n\n\treturn &cacheContentImage{\n\t\twithMask:         withMask,\n\t\timageAngle:       opts.DegreeAngle,\n\t\tmaskAngle:        maskAngle,\n\t\tpageHeight:       h,\n\t\tindex:            index,\n\t\tx:                opts.X,\n\t\ty:                opts.Y,\n\t\trect:             *opts.Rect,\n\t\tcrop:             opts.Crop,\n\t\tverticalFlip:     opts.VerticalFlip,\n\t\thorizontalFlip:   opts.HorizontalFlip,\n\t\textGStateIndexes: opts.extGStateIndexes,\n\t}\n}\n\n// AppendStreamImage append image\nfunc (c *ContentObj) AppendStreamImage(index int, opts ImageOptions) {\n\tcache := c.GetCacheContentImage(index, opts)\n\tc.listCache.append(cache)\n}\n\n// AppendStreamPolygon append polygon\nfunc (c *ContentObj) AppendStreamPolygon(points []Point, style string, opts polygonOptions) {\n\tvar cache cacheContentPolygon\n\tcache.points = points\n\tcache.style = style\n\tcache.pageHeight = c.getRoot().curr.pageSize.H\n\tcache.opts = opts\n\tc.listCache.append(&cache)\n}\n\nfunc (c *ContentObj) appendRotate(angle, x, y float64) {\n\tvar cache cacheContentRotate\n\tcache.isReset = false\n\tcache.pageHeight = c.getRoot().curr.pageSize.H\n\tcache.angle = angle\n\tcache.x = x\n\tcache.y = y\n\tc.listCache.append(&cache)\n}\n\nfunc (c *ContentObj) appendRotateReset() {\n\tvar cache cacheContentRotate\n\tcache.isReset = true\n\tc.listCache.append(&cache)\n}\n\n// ContentObjCalTextHeight : calculates height of text.\nfunc ContentObjCalTextHeight(fontsize int) float64 {\n\treturn ContentObjCalTextHeightPrecise(float64(fontsize))\n}\n\n// ContentObjCalTextHeightPrecise : like ContentObjCalTextHeight,\n// but fontsize float64\nfunc ContentObjCalTextHeightPrecise(fontsize float64) float64 {\n\treturn (float64(fontsize) * 0.7)\n}\n\n// When setting colour and grayscales the value has to be between 0.00 and 1.00\n// This function takes a float64 and returns 0.0 if it is less than 0.0 and 1.0 if it\n// is more than 1.0\nfunc fixRange10(val float64) float64 {\n\tif val < 0.0 {\n\t\treturn 0.0\n\t}\n\tif val > 1.0 {\n\t\treturn 1.0\n\t}\n\treturn val\n}\n\nfunc convertTTFUnit2PDFUnit(n int, upem int) int {\n\tvar ret int\n\tif n < 0 {\n\t\trest1 := n % upem\n\t\tstorrest := 1000 * rest1\n\t\t//ledd2 := (storrest != 0 ? rest1 / storrest : 0);\n\t\tledd2 := 0\n\t\tif storrest != 0 {\n\t\t\tledd2 = rest1 / storrest\n\t\t} else {\n\t\t\tledd2 = 0\n\t\t}\n\t\tret = -((-1000*n)/upem - int(ledd2))\n\t} else {\n\t\tret = (n/upem)*1000 + ((n%upem)*1000)/upem\n\t}\n\treturn ret\n}\n"
        },
        {
          "name": "current.go",
          "type": "blob",
          "size": 1.2216796875,
          "content": "package gopdf\n\n// Current current state\ntype Current struct {\n\tsetXCount int //many times we go func SetX()\n\tX         float64\n\tY         float64\n\n\t//font\n\tIndexOfFontObj int\n\tCountOfFont    int\n\tCountOfL       int\n\n\tFontSize      float64\n\tFontStyle     int // Regular|Bold|Italic|Underline\n\tFontFontCount int\n\tFontType      int // CURRENT_FONT_TYPE_IFONT or  CURRENT_FONT_TYPE_SUBSET\n\n\tCharSpacing float64\n\n\tFontISubset *SubsetFontObj // FontType == CURRENT_FONT_TYPE_SUBSET\n\n\t//page\n\tIndexOfPageObj int\n\n\t//img\n\tCountOfImg int\n\t//cache of image in pdf file\n\tImgCaches map[int]ImageCache\n\n\t//text color mode\n\ttxtColorMode string //color, gray\n\n\t//text color\n\ttxtColor ICacheColorText\n\n\t//text grayscale\n\tgrayFill float64\n\t//draw grayscale\n\tgrayStroke float64\n\n\tlineWidth float64\n\n\t//current page size\n\tpageSize *Rect\n\n\t//current trim box\n\ttrimBox *Box\n\n\tsMasksMap       SMaskMap\n\textGStatesMap   ExtGStatesMap\n\ttransparency    *Transparency\n\ttransparencyMap TransparencyMap\n}\n\nfunc (c *Current) setTextColor(color ICacheColorText) {\n\tc.txtColor = color\n}\n\nfunc (c *Current) textColor() ICacheColorText {\n\treturn c.txtColor\n}\n\n// ImageCache is metadata for caching images.\ntype ImageCache struct {\n\tPath  string //ID or Path\n\tIndex int\n\tRect  *Rect\n}\n"
        },
        {
          "name": "debug",
          "type": "tree",
          "content": null
        },
        {
          "name": "device_rgb_obj.go",
          "type": "blob",
          "size": 0.841796875,
          "content": "package gopdf\n\nimport (\n\t\"fmt\"\n\t\"io\"\n)\n\n// DeviceRGBObj  DeviceRGB\ntype DeviceRGBObj struct {\n\tdata    []byte\n\tgetRoot func() *GoPdf\n}\n\nfunc (d *DeviceRGBObj) init(funcGetRoot func() *GoPdf) {\n\td.getRoot = funcGetRoot\n}\n\nfunc (d *DeviceRGBObj) protection() *PDFProtection {\n\treturn d.getRoot().protection()\n}\n\nfunc (d *DeviceRGBObj) getType() string {\n\treturn \"devicergb\"\n}\n\n// สร้าง ข้อมูลใน pdf\nfunc (d *DeviceRGBObj) write(w io.Writer, objID int) error {\n\n\tio.WriteString(w, \"<<\\n\")\n\tfmt.Fprintf(w, \"/Length %d\\n\", len(d.data))\n\tio.WriteString(w, \">>\\n\")\n\tio.WriteString(w, \"stream\\n\")\n\tif d.protection() != nil {\n\t\ttmp, err := rc4Cip(d.protection().objectkey(objID), d.data)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tw.Write(tmp)\n\t\tio.WriteString(w, \"\\n\")\n\t} else {\n\t\tw.Write(d.data)\n\t}\n\tio.WriteString(w, \"endstream\\n\")\n\n\treturn nil\n}\n"
        },
        {
          "name": "embedfont_obj.go",
          "type": "blob",
          "size": 1.140625,
          "content": "package gopdf\n\nimport (\n\t\"fmt\"\n\t\"io\"\n\t\"os\"\n)\n\n// EmbedFontObj is an embedded font object.\ntype EmbedFontObj struct {\n\tData      string\n\tzfontpath string\n\tfont      IFont\n\tgetRoot   func() *GoPdf\n}\n\nfunc (e *EmbedFontObj) init(funcGetRoot func() *GoPdf) {\n\te.getRoot = funcGetRoot\n}\n\nfunc (e *EmbedFontObj) protection() *PDFProtection {\n\treturn e.getRoot().protection()\n}\n\nfunc (e *EmbedFontObj) write(w io.Writer, objID int) error {\n\tb, err := os.ReadFile(e.zfontpath)\n\tif err != nil {\n\t\treturn err\n\t}\n\tfmt.Fprintf(w, \"<</Length %d\\n\", len(b))\n\tio.WriteString(w, \"/Filter /FlateDecode\\n\")\n\tfmt.Fprintf(w, \"/Length1 %d\\n\", e.font.GetOriginalsize())\n\tio.WriteString(w, \">>\\n\")\n\tio.WriteString(w, \"stream\\n\")\n\tif e.protection() != nil {\n\t\ttmp, err := rc4Cip(e.protection().objectkey(objID), b)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tw.Write(tmp)\n\t\tio.WriteString(w, \"\\n\")\n\t} else {\n\t\tw.Write(b)\n\t}\n\tio.WriteString(w, \"\\nendstream\\n\")\n\treturn nil\n}\n\nfunc (e *EmbedFontObj) getType() string {\n\treturn \"EmbedFont\"\n}\n\n// SetFont sets the font of an embedded font object.\nfunc (e *EmbedFontObj) SetFont(font IFont, zfontpath string) {\n\te.font = font\n\te.zfontpath = zfontpath\n}\n"
        },
        {
          "name": "encoding_obj.go",
          "type": "blob",
          "size": 0.6552734375,
          "content": "package gopdf\n\nimport (\n\t\"io\"\n)\n\n// EncodingObj is a font object.\ntype EncodingObj struct {\n\tfont IFont\n}\n\nfunc (e *EncodingObj) init(funcGetRoot func() *GoPdf) {\n\n}\nfunc (e *EncodingObj) getType() string {\n\treturn \"Encoding\"\n}\nfunc (e *EncodingObj) write(w io.Writer, objID int) error {\n\tio.WriteString(w, \"<</Type /Encoding /BaseEncoding /WinAnsiEncoding /Differences [\")\n\tio.WriteString(w, e.font.GetDiff())\n\tio.WriteString(w, \"]>>\\n\")\n\treturn nil\n}\n\n// SetFont sets the font of an encoding object.\nfunc (e *EncodingObj) SetFont(font IFont) {\n\te.font = font\n}\n\n// GetFont gets the font from an encoding object.\nfunc (e *EncodingObj) GetFont() IFont {\n\treturn e.font\n}\n"
        },
        {
          "name": "encryption_obj.go",
          "type": "blob",
          "size": 0.9462890625,
          "content": "package gopdf\n\nimport (\n\t\"fmt\"\n\t\"io\"\n\t\"strings\"\n)\n\n// EncryptionObj  encryption object res\ntype EncryptionObj struct {\n\tuValue []byte //U entry in pdf document\n\toValue []byte //O entry in pdf document\n\tpValue int    //P entry in pdf document\n}\n\nfunc (e *EncryptionObj) init(func() *GoPdf) {\n\n}\n\nfunc (e *EncryptionObj) getType() string {\n\treturn \"Encryption\"\n}\n\nfunc (e *EncryptionObj) write(w io.Writer, objID int) error {\n\tio.WriteString(w, \"<<\\n\")\n\tio.WriteString(w, \"/Filter /Standard\\n\")\n\tio.WriteString(w, \"/V 1\\n\")\n\tio.WriteString(w, \"/R 2\\n\")\n\tfmt.Fprintf(w, \"/O (%s)\\n\", e.escape(e.oValue))\n\tfmt.Fprintf(w, \"/U (%s)\\n\", e.escape(e.uValue))\n\tfmt.Fprintf(w, \"/P %d\\n\", e.pValue)\n\tio.WriteString(w, \">>\\n\")\n\treturn nil\n}\n\nfunc (e *EncryptionObj) escape(b []byte) string {\n\ts := string(b)\n\ts = strings.Replace(s, \"\\\\\", \"\\\\\\\\\", -1)\n\ts = strings.Replace(s, \"(\", \"\\\\(\", -1)\n\ts = strings.Replace(s, \")\", \"\\\\)\", -1)\n\ts = strings.Replace(s, \"\\r\", \"\\\\r\", -1)\n\treturn s\n}\n"
        },
        {
          "name": "examples",
          "type": "tree",
          "content": null
        },
        {
          "name": "ext_g_state_obj.go",
          "type": "blob",
          "size": 2.7646484375,
          "content": "package gopdf\n\nimport (\n\t\"fmt\"\n\t\"io\"\n\t\"sync\"\n\n\t\"errors\"\n)\n\n// TODO: add all fields https://www.adobe.com/content/dam/acom/en/devnet/acrobat/pdfs/PDF32000_2008.pdf 8.4.5 page 128\ntype ExtGState struct {\n\tIndex      int\n\tca         *float64\n\tCA         *float64\n\tBM         *BlendModeType\n\tSMaskIndex *int\n}\n\ntype ExtGStateOptions struct {\n\tStrokingCA    *float64\n\tNonStrokingCa *float64\n\tBlendMode     *BlendModeType\n\tSMaskIndex    *int\n}\n\nfunc (extOpt ExtGStateOptions) GetId() string {\n\tid := \"\"\n\tif extOpt.StrokingCA != nil {\n\t\tid += fmt.Sprintf(\"CA_%.3f;\", *extOpt.StrokingCA)\n\t}\n\tif extOpt.NonStrokingCa != nil {\n\t\tid += fmt.Sprintf(\"ca_%.3f;\", *extOpt.NonStrokingCa)\n\t}\n\tif extOpt.BlendMode != nil {\n\t\tid += fmt.Sprintf(\"BM_%s;\", *extOpt.BlendMode)\n\t}\n\tif extOpt.SMaskIndex != nil {\n\t\tid += fmt.Sprintf(\"SMask_%d_0_R;\", *extOpt.SMaskIndex)\n\t}\n\n\treturn id\n}\n\nfunc GetCachedExtGState(opts ExtGStateOptions, gp *GoPdf) (ExtGState, error) {\n\textGState, ok := gp.curr.extGStatesMap.Find(opts)\n\tif !ok {\n\t\textGState = ExtGState{\n\t\t\tBM:         opts.BlendMode,\n\t\t\tCA:         opts.StrokingCA,\n\t\t\tca:         opts.NonStrokingCa,\n\t\t\tSMaskIndex: opts.SMaskIndex,\n\t\t}\n\n\t\textGState.Index = gp.addObj(extGState)\n\n\t\tpdfObj := gp.pdfObjs[gp.indexOfProcSet]\n\t\tprocset, ok := pdfObj.(*ProcSetObj)\n\t\tif !ok {\n\t\t\treturn ExtGState{}, errors.New(\"can't convert pdfobject to procsetobj\")\n\t\t}\n\n\t\tprocset.ExtGStates = append(procset.ExtGStates, ExtGS{Index: extGState.Index})\n\n\t\tgp.curr.extGStatesMap.Save(opts.GetId(), extGState)\n\n\t\t//extGState = extGState\n\t}\n\n\treturn extGState, nil\n}\n\nfunc (egs ExtGState) init(func() *GoPdf) {}\n\nfunc (egs ExtGState) getType() string {\n\treturn \"ExtGState\"\n}\n\nfunc (egs ExtGState) write(w io.Writer, objID int) error {\n\tcontent := \"<<\\n\"\n\tcontent += \"\\t/Type /ExtGState\\n\"\n\n\tif egs.ca != nil {\n\t\tcontent += fmt.Sprintf(\"\\t/ca %.3F\\n\", *egs.ca)\n\t}\n\tif egs.CA != nil {\n\t\tcontent += fmt.Sprintf(\"\\t/CA %.3F\\n\", *egs.CA)\n\t}\n\tif egs.BM != nil {\n\t\tcontent += fmt.Sprintf(\"\\t/BM %s\\n\", *egs.BM)\n\t}\n\n\tif egs.SMaskIndex != nil {\n\t\tcontent += fmt.Sprintf(\"\\t/SMask %d 0 R\\n\", *egs.SMaskIndex+1)\n\t}\n\n\tcontent += \">>\\n\"\n\n\tif _, err := io.WriteString(w, content); err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\ntype ExtGStatesMap struct {\n\tsyncer sync.Mutex\n\ttable  map[string]ExtGState\n}\n\nfunc NewExtGStatesMap() ExtGStatesMap {\n\treturn ExtGStatesMap{\n\t\tsyncer: sync.Mutex{},\n\t\ttable:  make(map[string]ExtGState),\n\t}\n}\n\nfunc (extm *ExtGStatesMap) Find(extGState ExtGStateOptions) (ExtGState, bool) {\n\tkey := extGState.GetId()\n\n\textm.syncer.Lock()\n\tdefer extm.syncer.Unlock()\n\n\tt, ok := extm.table[key]\n\tif !ok {\n\t\treturn ExtGState{}, false\n\t}\n\n\treturn t, ok\n\n}\n\nfunc (tm *ExtGStatesMap) Save(id string, extGState ExtGState) ExtGState {\n\ttm.syncer.Lock()\n\tdefer tm.syncer.Unlock()\n\n\ttm.table[id] = extGState\n\n\treturn extGState\n}\n"
        },
        {
          "name": "font_obj.go",
          "type": "blob",
          "size": 1.3984375,
          "content": "package gopdf\n\nimport (\n\t\"fmt\"\n\t\"io\"\n)\n\n// FontObj font obj\ntype FontObj struct {\n\tFamily string\n\t//Style string\n\t//Size int\n\tIsEmbedFont bool\n\n\tindexObjWidth          int\n\tindexObjFontDescriptor int\n\tindexObjEncoding       int\n\n\tFont        IFont\n\tCountOfFont int\n}\n\nfunc (f *FontObj) init(funcGetRoot func() *GoPdf) {\n\tf.IsEmbedFont = false\n\t//me.CountOfFont = -1\n}\n\nfunc (f *FontObj) write(w io.Writer, objID int) error {\n\tbaseFont := f.Family\n\tif f.Font != nil {\n\t\tbaseFont = f.Font.GetName()\n\t}\n\n\tio.WriteString(w, \"<<\\n\")\n\tfmt.Fprintf(w, \"  /Type /%s\\n\", f.getType())\n\tio.WriteString(w, \"  /Subtype /TrueType\\n\")\n\tfmt.Fprintf(w, \"  /BaseFont /%s\\n\", baseFont)\n\tif f.IsEmbedFont {\n\t\tio.WriteString(w, \"  /FirstChar 32 /LastChar 255\\n\")\n\t\tfmt.Fprintf(w, \"  /Widths %d 0 R\\n\", f.indexObjWidth)\n\t\tfmt.Fprintf(w, \"  /FontDescriptor %d 0 R\\n\", f.indexObjFontDescriptor)\n\t\tfmt.Fprintf(w, \"  /Encoding %d 0 R\\n\", f.indexObjEncoding)\n\t}\n\tio.WriteString(w, \">>\\n\")\n\treturn nil\n}\n\nfunc (f *FontObj) getType() string {\n\treturn \"Font\"\n}\n\n// SetIndexObjWidth sets the width of a font object.\nfunc (f *FontObj) SetIndexObjWidth(index int) {\n\tf.indexObjWidth = index\n}\n\n// SetIndexObjFontDescriptor sets the font descriptor.\nfunc (f *FontObj) SetIndexObjFontDescriptor(index int) {\n\tf.indexObjFontDescriptor = index\n}\n\n// SetIndexObjEncoding sets the encoding.\nfunc (f *FontObj) SetIndexObjEncoding(index int) {\n\tf.indexObjEncoding = index\n}\n"
        },
        {
          "name": "font_option.go",
          "type": "blob",
          "size": 0.5625,
          "content": "package gopdf\n\nimport (\n\t\"strings\"\n)\n\n// Regular - font style regular\nconst Regular = 0 //000000\n// Italic - font style italic\nconst Italic = 1 //000001\n// Bold - font style bold\nconst Bold = 2 //000010\n// Underline - font style underline\nconst Underline = 4 //000100\n\nfunc getConvertedStyle(fontStyle string) (style int) {\n\tfontStyle = strings.ToUpper(fontStyle)\n\tif strings.Contains(fontStyle, \"B\") {\n\t\tstyle = style | Bold\n\t}\n\tif strings.Contains(fontStyle, \"I\") {\n\t\tstyle = style | Italic\n\t}\n\tif strings.Contains(fontStyle, \"U\") {\n\t\tstyle = style | Underline\n\t}\n\treturn\n}\n"
        },
        {
          "name": "fontconverthelper.go",
          "type": "blob",
          "size": 0.59765625,
          "content": "package gopdf\n\nimport (\n\t\"strconv\"\n\t//\"fmt\"\n\t\"bytes\"\n)\n\n// FontConvertHelperCw2Str converts main ASCII characters of a FontCW to a string.\nfunc FontConvertHelperCw2Str(cw FontCw) string {\n\tbuff := new(bytes.Buffer)\n\tbuff.WriteString(\" \")\n\ti := 32\n\tfor i <= 255 {\n\t\tbuff.WriteString(strconv.Itoa(cw[byte(i)]) + \" \")\n\t\ti++\n\t}\n\treturn buff.String()\n}\n\n// FontConvertHelper_Cw2Str converts main ASCII characters of a FontCW to a string. (for backward compatibility)\n// Deprecated: Use FontConvertHelperCw2Str(cw FontCw) instead\nfunc FontConvertHelper_Cw2Str(cw FontCw) string {\n\treturn FontConvertHelperCw2Str(cw)\n}\n"
        },
        {
          "name": "fontdescriptor_obj.go",
          "type": "blob",
          "size": 1.099609375,
          "content": "package gopdf\n\nimport (\n\t\"fmt\"\n\t\"io\"\n)\n\n// FontDescriptorObj is a font descriptor object.\ntype FontDescriptorObj struct {\n\tfont              IFont\n\tfontFileObjRelate string\n}\n\nfunc (f *FontDescriptorObj) init(funcGetRoot func() *GoPdf) {\n\n}\n\nfunc (f *FontDescriptorObj) write(w io.Writer, objID int) error {\n\n\tfmt.Fprintf(w, \"<</Type /FontDescriptor /FontName /%s \", f.font.GetName())\n\tdescs := f.font.GetDesc()\n\ti := 0\n\tmax := len(descs)\n\tfor i < max {\n\t\tfmt.Fprintf(w, \"/%s %s \", descs[i].Key, descs[i].Val)\n\t\ti++\n\t}\n\n\tif f.getType() == \"Type1\" {\n\t\tio.WriteString(w, \"/FontFile \")\n\t} else {\n\t\tio.WriteString(w, \"/FontFile2 \")\n\t}\n\n\tio.WriteString(w, f.fontFileObjRelate)\n\tio.WriteString(w, \">>\\n\")\n\n\treturn nil\n}\n\nfunc (f *FontDescriptorObj) getType() string {\n\treturn \"FontDescriptor\"\n}\n\n// SetFont sets the font in descriptor.\nfunc (f *FontDescriptorObj) SetFont(font IFont) {\n\tf.font = font\n}\n\n// GetFont gets font from descriptor.\nfunc (f *FontDescriptorObj) GetFont() IFont {\n\treturn f.font\n}\n\n// SetFontFileObjRelate ???\nfunc (f *FontDescriptorObj) SetFontFileObjRelate(relate string) {\n\tf.fontFileObjRelate = relate\n}\n"
        },
        {
          "name": "fontmaker",
          "type": "tree",
          "content": null
        },
        {
          "name": "fontsizefloat64_test.go",
          "type": "blob",
          "size": 3.669921875,
          "content": "package gopdf\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestContentObjCalTextHeight(t *testing.T) {\n\tintfontsize := 7\n\thave := ContentObjCalTextHeight(intfontsize)\n\twant := float64(intfontsize) * 0.7\n\tif have != want {\n\t\tt.Errorf(\"ContentObjCalTextHeight(%d) = %f; want %f\\n\", intfontsize, have, want)\n\t}\n\n\tfloatfontsize := 7.2\n\thave = ContentObjCalTextHeightPrecise(floatfontsize)\n\twant = float64(floatfontsize) * 0.7\n\tif have != want {\n\t\tt.Errorf(\"ContentObjCalTextHeight(%d) = %f; want %f\\n\", intfontsize, have, want)\n\t}\n\n}\n\nfunc TestSetFontCheckGetX(t *testing.T) {\n\tprefix := \"Afont\"\n\tfont := \"test/res/LiberationSerif-Regular.ttf\"\n\tpdf := GoPdf{}\n\tpdf.Start(Config{Unit: UnitPT, PageSize: *PageSizeA4})\n\tpdf.AddPage()\n\tif err := pdf.AddTTFFontWithOption(prefix, font, TtfOption{UseKerning: true}); err != nil {\n\t\tt.Error(err)\n\t}\n\n\t// Baseline: SetFont(int) + AddText\n\tif err := pdf.SetFont(prefix, \"\", int(50)); err != nil {\n\t\tt.Error(err)\n\t}\n\n\tpdf.SetXY(30.0, 30.0)\n\tpdf.Text(prefix)\n\twantx, wanty := pdf.GetX(), pdf.GetY()\n\n\t// ensure that GetX, GetY work as expected\n\tpdf.SetXY(30.0, 30.0)\n\tpdf.Text(prefix + prefix)\n\thavex, havey := pdf.GetX(), pdf.GetY()\n\tif havex <= wantx || havey != wanty {\n\t\tt.Errorf(\"wanted (x,y) => (x', y') with x<x' and y==y', got (%f, %f) => (%f, %f)\\n\", wantx, wanty, havex, havey)\n\t}\n}\n\nfunc moveAndAdd(pdf *GoPdf, prefix string) (float64, float64) {\n\tpdf.SetXY(30.0, 30.0)\n\tpdf.Text(prefix)\n\treturn pdf.GetX(), pdf.GetY()\n}\nfunc setup(t *testing.T) (string, *GoPdf, float64, float64) {\n\tprefix := \"Afont\"\n\tfont := \"test/res/LiberationSerif-Regular.ttf\"\n\tpdf := GoPdf{}\n\tpdf.Start(Config{Unit: UnitPT, PageSize: *PageSizeA4})\n\tpdf.AddPage()\n\tif err := pdf.AddTTFFontWithOption(prefix, font, TtfOption{UseKerning: true}); err != nil {\n\t\tt.Error(err)\n\t}\n\n\t// Baseline: SetFont(int) + AddText\n\tif err := pdf.SetFont(prefix, \"\", int(50)); err != nil {\n\t\tt.Error(err)\n\t}\n\thx, hy := moveAndAdd(&pdf, prefix)\n\treturn prefix, &pdf, hx, hy\n}\nfunc TestSetFontWithFloat(t *testing.T) {\n\tprefix, pdf, wantx, wanty := setup(t)\n\t// try it with fontsize = float64(50)\n\tif err := pdf.SetFont(prefix, \"\", float64(50)); err != nil {\n\t\tt.Error(err)\n\t}\n\thavex, havey := moveAndAdd(pdf, prefix)\n\tif (havex != wantx) || (havey != wanty) {\n\t\tt.Errorf(\"SetFont(float64) + '%s' => \\nhave = %f, %f;\\nwant = %f,%f\\n\",\n\t\t\tprefix, havex, havey, wantx, wanty)\n\t}\n}\n\nfunc TestSetFontWithUint(t *testing.T) {\n\tprefix, pdf, wantx, wanty := setup(t)\n\t// try it with fontsize = uint8(50)\n\tif err := pdf.SetFont(prefix, \"\", uint8(50)); err != nil {\n\t\tt.Error(err)\n\t}\n\thavex, havey := moveAndAdd(pdf, prefix)\n\tif (havex != wantx) || (havey != wanty) {\n\t\tt.Errorf(\"SetFont(uint8) + AddText => %f, %f; want = %f,%f\\n\",\n\t\t\thavex, havey, wantx, wanty)\n\t}\n}\nfunc TestSetFontWithString(t *testing.T) {\n\tprefix, pdf, _, _ := setup(t)\n\t// Try with a string\n\terr := pdf.SetFont(prefix, \"\", string(\"50\"))\n\tif err == nil {\n\t\tt.Errorf(\"SetFont(string) + AddText: Should have gotten an error!\\n\")\n\t}\n}\n\nfunc ExampleFormatFloatTrim() {\n\tfmt.Printf(\"/F1 %s Tf\\n\", FormatFloatTrim(10))\n\tfmt.Printf(\"/F1 %s Tf\\n\", FormatFloatTrim(10.0))\n\tfmt.Printf(\"/F1 %s Tf\\n\", FormatFloatTrim(10.01))\n\tfmt.Printf(\"/F1 %s Tf\\n\", FormatFloatTrim(10.001))\n\tfmt.Printf(\"/F1 %s Tf\\n\", FormatFloatTrim(10.0001))\n\tfmt.Printf(\"/F1 %s Tf\\n\", FormatFloatTrim(10.00001))\n\tfmt.Printf(\"/F1 %s Tf\\n\", FormatFloatTrim(9.99999))\n\tfmt.Printf(\"/F1 %s Tf\\n\", FormatFloatTrim(9.9999))\n\tfmt.Printf(\"/F1 %s Tf\\n\", FormatFloatTrim(9.999))\n\tfmt.Printf(\"/F1 %s Tf\\n\", FormatFloatTrim(9.99))\n\tfmt.Printf(\"/F1 %s Tf\\n\", FormatFloatTrim(9.9))\n\t// Output: /F1 10 Tf\n\t// /F1 10 Tf\n\t// /F1 10.01 Tf\n\t// /F1 10.001 Tf\n\t// /F1 10 Tf\n\t// /F1 10 Tf\n\t// /F1 10 Tf\n\t// /F1 10 Tf\n\t// /F1 9.999 Tf\n\t// /F1 9.99 Tf\n\t// /F1 9.9 Tf\n}\n"
        },
        {
          "name": "func_kern_override.go",
          "type": "blob",
          "size": 0.1806640625,
          "content": "package gopdf\n\n// FuncKernOverride  return your custome pair value\ntype FuncKernOverride func(\n\tleftRune rune,\n\trightRune rune,\n\tleftPair uint,\n\trightPair uint,\n\tpairVal int16,\n) int16\n"
        },
        {
          "name": "go.mod",
          "type": "blob",
          "size": 0.1162109375,
          "content": "module github.com/signintech/gopdf\n\ngo 1.13\n\nrequire github.com/phpdave11/gofpdi v1.0.14-0.20211212211723-1f10f9844311\n"
        },
        {
          "name": "go.sum",
          "type": "blob",
          "size": 0.38671875,
          "content": "github.com/phpdave11/gofpdi v1.0.14-0.20211212211723-1f10f9844311 h1:zyWXQ6vu27ETMpYsEMAsisQ+GqJ4e1TPvSNfdOPF0no=\ngithub.com/phpdave11/gofpdi v1.0.14-0.20211212211723-1f10f9844311/go.mod h1:vBmVV0Do6hSBHC8uKUQ71JGW+ZGQq74llk/7bXwjDoI=\ngithub.com/pkg/errors v0.8.1 h1:iURUrRGxPUNPdy5/HRSm+Yj6okJ6UtLINN0Q9M4+h3I=\ngithub.com/pkg/errors v0.8.1/go.mod h1:bwawxfHBFNV+L2hUp1rHADufV3IMtnDRdf1r5NINEl0=\n"
        },
        {
          "name": "gopdf.go",
          "type": "blob",
          "size": 63.66015625,
          "content": "package gopdf\n\nimport (\n\t\"bufio\"\n\t\"bytes\"\n\t\"compress/zlib\" // for constants\n\t\"errors\"\n\t\"fmt\"\n\t\"image\"\n\t\"image/jpeg\"\n\t\"image/png\"\n\t\"io\"\n\t\"log\"\n\t\"math\"\n\t\"os\"\n\t\"strconv\"\n\t\"strings\"\n\t\"time\"\n\n\t\"github.com/phpdave11/gofpdi\"\n)\n\nconst subsetFont = \"SubsetFont\"\n\n// the default margin if no margins are set\nconst defaultMargin = 10.0 //for backward compatible\n\nvar ErrEmptyString = errors.New(\"empty string\")\n\nvar ErrMissingFontFamily = errors.New(\"font family not found\")\n\nvar ErrUndefinedCacheContentImage = errors.New(\"cacheContentImage is undefined\")\n\nvar ErrInvalidRectangleCoordinates = errors.New(\"Invalid coordinates for the rectangle\")\n\nvar ErrInvalidRectangleRadius = errors.New(\"Radius length cannot exceed rectangle height or width\")\n\n// GoPdf : A simple library for generating PDF written in Go lang\ntype GoPdf struct {\n\n\t//page Margin\n\t//leftMargin float64\n\t//topMargin  float64\n\tmargins Margins\n\n\tpdfObjs []IObj\n\tconfig  Config\n\tanchors map[string]anchorOption\n\n\tindexOfCatalogObj int\n\n\t/*---index ของ obj สำคัญๆ เก็บเพื่อลด loop ตอนค้นหา---*/\n\t//index ของ obj pages\n\tindexOfPagesObj int\n\n\t//number of pages\n\tnumOfPagesObj int\n\n\t//index ของ obj page อันแรก\n\tindexOfFirstPageObj int\n\n\t//ต่ำแหน่งปัจจุบัน\n\tcurr Current\n\n\tindexEncodingObjFonts []int\n\tindexOfContent        int\n\n\t//index ของ procset ซึ่งควรจะมีอันเดียว\n\tindexOfProcSet int\n\n\t//IsUnderline bool\n\n\t// Buffer for io.Reader compliance\n\tbuf bytes.Buffer\n\n\t//pdf PProtection\n\tpdfProtection   *PDFProtection\n\tencryptionObjID int\n\n\t// content streams only\n\tcompressLevel int\n\n\t//info\n\tisUseInfo bool\n\tinfo      *PdfInfo\n\n\t//outlines\n\toutlines           *OutlinesObj\n\tindexOfOutlinesObj int\n\n\t//header and footer functions\n\theaderFunc func()\n\tfooterFunc func()\n\n\t// gofpdi free pdf document importer\n\tfpdi *gofpdi.Importer\n\n\t//placeholder text\n\tplaceHolderTexts map[string]([]placeHolderTextInfo)\n}\n\ntype DrawableRectOptions struct {\n\tRect\n\tX            float64\n\tY            float64\n\tPaintStyle   PaintStyle\n\tTransparency *Transparency\n\n\textGStateIndexes []int\n}\n\ntype CropOptions struct {\n\tX      float64\n\tY      float64\n\tWidth  float64\n\tHeight float64\n}\n\ntype ImageOptions struct {\n\tDegreeAngle    float64\n\tVerticalFlip   bool\n\tHorizontalFlip bool\n\tX              float64\n\tY              float64\n\tRect           *Rect\n\tMask           *MaskOptions\n\tCrop           *CropOptions\n\tTransparency   *Transparency\n\n\textGStateIndexes []int\n}\ntype ImageFromOption struct {\n\tFormat string //jpeg,png\n\tX      float64\n\tY      float64\n\tRect   *Rect\n}\n\ntype MaskOptions struct {\n\tImageOptions\n\tBBox   *[4]float64\n\tHolder ImageHolder\n}\n\ntype lineOptions struct {\n\textGStateIndexes []int\n}\n\ntype polygonOptions struct {\n\textGStateIndexes []int\n}\n\n// SetLineWidth : set line width\nfunc (gp *GoPdf) SetLineWidth(width float64) {\n\tgp.curr.lineWidth = gp.UnitsToPoints(width)\n\tgp.getContent().AppendStreamSetLineWidth(gp.UnitsToPoints(width))\n}\n\n// SetCompressLevel : set compress Level for content streams\n// Possible values for level:\n//\n//\t-2 HuffmanOnly, -1 DefaultCompression (which is level 6)\n//\t 0 No compression,\n//\t 1 fastest compression, but not very good ratio\n//\t 9 best compression, but slowest\nfunc (gp *GoPdf) SetCompressLevel(level int) {\n\terrfmt := \"compress level too %s, using %s instead\\n\"\n\tif level < -2 { //-2 = zlib.HuffmanOnly\n\t\tfmt.Fprintf(os.Stderr, errfmt, \"small\", \"DefaultCompression\")\n\t\tlevel = zlib.DefaultCompression\n\t} else if level > zlib.BestCompression {\n\t\tfmt.Fprintf(os.Stderr, errfmt, \"big\", \"BestCompression\")\n\t\tlevel = zlib.BestCompression\n\t\treturn\n\t}\n\t// sanity check complete\n\tgp.compressLevel = level\n}\n\n// SetNoCompression : compressLevel = 0\nfunc (gp *GoPdf) SetNoCompression() {\n\tgp.compressLevel = zlib.NoCompression\n}\n\n// SetLineType : set line type  (\"dashed\" ,\"dotted\")\n//\n//\tUsage:\n//\tpdf.SetLineType(\"dashed\")\n//\tpdf.Line(50, 200, 550, 200)\n//\tpdf.SetLineType(\"dotted\")\n//\tpdf.Line(50, 400, 550, 400)\nfunc (gp *GoPdf) SetLineType(linetype string) {\n\tgp.getContent().AppendStreamSetLineType(linetype)\n}\n\n// SetCustomLineType : set custom line type\n//\n//\tUsage:\n//\tpdf.SetCustomLineType([]float64{0.8, 0.8}, 0)\n//\tpdf.Line(50, 200, 550, 200)\nfunc (gp *GoPdf) SetCustomLineType(dashArray []float64, dashPhase float64) {\n\tfor i := range dashArray {\n\t\tgp.UnitsToPointsVar(&dashArray[i])\n\t}\n\tgp.UnitsToPointsVar(&dashPhase)\n\tgp.getContent().AppendStreamSetCustomLineType(dashArray, dashPhase)\n}\n\n// Line : draw line\n//\n//\tUsage:\n//\tpdf.SetTransparency(gopdf.Transparency{Alpha: 0.5,BlendModeType: gopdf.ColorBurn})\n//\tpdf.SetLineType(\"dotted\")\n//\tpdf.SetStrokeColor(255, 0, 0)\n//\tpdf.SetLineWidth(2)\n//\tpdf.Line(10, 30, 585, 30)\n//\tpdf.ClearTransparency()\nfunc (gp *GoPdf) Line(x1 float64, y1 float64, x2 float64, y2 float64) {\n\tgp.UnitsToPointsVar(&x1, &y1, &x2, &y2)\n\ttransparency, err := gp.getCachedTransparency(nil)\n\tif err != nil {\n\t\ttransparency = nil\n\t}\n\tvar opts = lineOptions{}\n\tif transparency != nil {\n\t\topts.extGStateIndexes = append(opts.extGStateIndexes, transparency.extGStateIndex)\n\t}\n\tgp.getContent().AppendStreamLine(x1, y1, x2, y2, opts)\n}\n\n// RectFromLowerLeft : draw rectangle from lower-left corner (x, y)\nfunc (gp *GoPdf) RectFromLowerLeft(x float64, y float64, wdth float64, hght float64) {\n\tgp.UnitsToPointsVar(&x, &y, &wdth, &hght)\n\n\topts := DrawableRectOptions{\n\t\tX:          x,\n\t\tY:          y,\n\t\tPaintStyle: DrawPaintStyle,\n\t\tRect:       Rect{W: wdth, H: hght},\n\t}\n\n\tgp.getContent().AppendStreamRectangle(opts)\n}\n\n// RectFromUpperLeft : draw rectangle from upper-left corner (x, y)\nfunc (gp *GoPdf) RectFromUpperLeft(x float64, y float64, wdth float64, hght float64) {\n\tgp.UnitsToPointsVar(&x, &y, &wdth, &hght)\n\n\topts := DrawableRectOptions{\n\t\tX:          x,\n\t\tY:          y + hght,\n\t\tPaintStyle: DrawPaintStyle,\n\t\tRect:       Rect{W: wdth, H: hght},\n\t}\n\n\tgp.getContent().AppendStreamRectangle(opts)\n}\n\n// RectFromLowerLeftWithStyle : draw rectangle from lower-left corner (x, y)\n//   - style: Style of rectangule (draw and/or fill: D, F, DF, FD)\n//     D or empty string: draw. This is the default value.\n//     F: fill\n//     DF or FD: draw and fill\nfunc (gp *GoPdf) RectFromLowerLeftWithStyle(x float64, y float64, wdth float64, hght float64, style string) {\n\topts := DrawableRectOptions{\n\t\tX: x,\n\t\tY: y,\n\t\tRect: Rect{\n\t\t\tH: hght,\n\t\t\tW: wdth,\n\t\t},\n\t\tPaintStyle: parseStyle(style),\n\t}\n\tgp.RectFromLowerLeftWithOpts(opts)\n}\n\nfunc (gp *GoPdf) RectFromLowerLeftWithOpts(opts DrawableRectOptions) error {\n\tgp.UnitsToPointsVar(&opts.X, &opts.Y, &opts.W, &opts.H)\n\n\timageTransparency, err := gp.getCachedTransparency(opts.Transparency)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif imageTransparency != nil {\n\t\topts.extGStateIndexes = append(opts.extGStateIndexes, imageTransparency.extGStateIndex)\n\t}\n\n\tgp.getContent().AppendStreamRectangle(opts)\n\n\treturn nil\n}\n\n// RectFromUpperLeftWithStyle : draw rectangle from upper-left corner (x, y)\n//   - style: Style of rectangule (draw and/or fill: D, F, DF, FD)\n//     D or empty string: draw. This is the default value.\n//     F: fill\n//     DF or FD: draw and fill\nfunc (gp *GoPdf) RectFromUpperLeftWithStyle(x float64, y float64, wdth float64, hght float64, style string) {\n\topts := DrawableRectOptions{\n\t\tX: x,\n\t\tY: y,\n\t\tRect: Rect{\n\t\t\tH: hght,\n\t\t\tW: wdth,\n\t\t},\n\t\tPaintStyle: parseStyle(style),\n\t}\n\tgp.RectFromUpperLeftWithOpts(opts)\n}\n\nfunc (gp *GoPdf) RectFromUpperLeftWithOpts(opts DrawableRectOptions) error {\n\tgp.UnitsToPointsVar(&opts.X, &opts.Y, &opts.W, &opts.H)\n\n\topts.Y += opts.H\n\n\timageTransparency, err := gp.getCachedTransparency(opts.Transparency)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif imageTransparency != nil {\n\t\topts.extGStateIndexes = append(opts.extGStateIndexes, imageTransparency.extGStateIndex)\n\t}\n\n\tgp.getContent().AppendStreamRectangle(opts)\n\n\treturn nil\n}\n\n// Oval : draw oval\nfunc (gp *GoPdf) Oval(x1 float64, y1 float64, x2 float64, y2 float64) {\n\tgp.UnitsToPointsVar(&x1, &y1, &x2, &y2)\n\tgp.getContent().AppendStreamOval(x1, y1, x2, y2)\n}\n\n// Br : new line\nfunc (gp *GoPdf) Br(h float64) {\n\tgp.UnitsToPointsVar(&h)\n\tgp.curr.Y += h\n\tgp.curr.X = gp.margins.Left\n}\n\n// SetGrayFill set the grayscale for the fill, takes a float64 between 0.0 and 1.0\nfunc (gp *GoPdf) SetGrayFill(grayScale float64) {\n\tgp.curr.txtColorMode = \"gray\"\n\tgp.curr.grayFill = grayScale\n\tgp.getContent().AppendStreamSetGrayFill(grayScale)\n}\n\n// SetGrayStroke set the grayscale for the stroke, takes a float64 between 0.0 and 1.0\nfunc (gp *GoPdf) SetGrayStroke(grayScale float64) {\n\tgp.curr.grayStroke = grayScale\n\tgp.getContent().AppendStreamSetGrayStroke(grayScale)\n}\n\n// SetX : set current position X\nfunc (gp *GoPdf) SetX(x float64) {\n\tgp.UnitsToPointsVar(&x)\n\tgp.curr.setXCount++\n\tgp.curr.X = x\n}\n\n// GetX : get current position X\nfunc (gp *GoPdf) GetX() float64 {\n\treturn gp.PointsToUnits(gp.curr.X)\n}\n\n// SetNewY : set current position y, and modified y if add a new page.\n// Example:\n// For example, if the page height is set to 841px, MarginTop is 20px,\n// MarginBottom is 10px, and the height of the element(such as text) to be inserted is 25px,\n// because 10<25, you need to add another page and set y to 20px.\n// Because of called AddPage(), X is set to MarginLeft, so you should specify X if needed,\n// or make sure SetX() is after SetNewY(), or using SetNewXY().\n// SetNewYIfNoOffset is more suitable for scenarios where the offset does not change, such as pdf.Image().\nfunc (gp *GoPdf) SetNewY(y float64, h float64) {\n\tgp.UnitsToPointsVar(&y)\n\tgp.UnitsToPointsVar(&h)\n\tif gp.curr.Y+h > gp.curr.pageSize.H-gp.MarginBottom() {\n\t\tgp.AddPage()\n\t\ty = gp.MarginTop() // reset to top of the page.\n\t}\n\tgp.curr.Y = y\n}\n\n// SetNewYIfNoOffset : set current position y, and modified y if add a new page.\n// Example:\n// For example, if the page height is set to 841px, MarginTop is 20px,\n// MarginBottom is 10px, and the height of the element(such as image) to be inserted is 200px,\n// because 10<200, you need to add another page and set y to 20px.\n// Tips: gp.curr.X and gp.curr.Y do not change when pdf.Image() is called.\nfunc (gp *GoPdf) SetNewYIfNoOffset(y float64, h float64) {\n\tgp.UnitsToPointsVar(&y)\n\tgp.UnitsToPointsVar(&h)\n\tif y+h > gp.curr.pageSize.H-gp.MarginBottom() { // using new y(*y) instead of gp.curr.Y\n\t\tgp.AddPage()\n\t\ty = gp.MarginTop() // reset to top of the page.\n\t}\n\tgp.curr.Y = y\n}\n\n// SetNewXY : set current position x and y, and modified y if add a new page.\n// Example:\n// For example, if the page height is set to 841px, MarginTop is 20px,\n// MarginBottom is 10px, and the height of the element to be inserted is 25px,\n// because 10<25, you need to add another page and set y to 20px.\n// Because of AddPage(), X is set to MarginLeft, so you should specify X if needed,\n// or make sure SetX() is after SetNewY().\nfunc (gp *GoPdf) SetNewXY(y float64, x, h float64) {\n\tgp.UnitsToPointsVar(&y)\n\tgp.UnitsToPointsVar(&h)\n\tif gp.curr.Y+h > gp.curr.pageSize.H-gp.MarginBottom() {\n\t\tgp.AddPage()\n\t\ty = gp.MarginTop() // reset to top of the page.\n\t}\n\tgp.curr.Y = y\n\tgp.SetX(x)\n}\n\n/*\n//experimental\nfunc (gp *GoPdf) SetNewY(y float64, h float64) float64 {\n\tgp.UnitsToPointsVar(&y)\n\tgp.UnitsToPointsVar(&h)\n\tif gp.curr.Y+h > gp.curr.pageSize.H-gp.MarginBottom() {\n\t\tgp.AddPage()\n\t\ty = gp.MarginTop() // reset to top of the page.\n\t}\n\tgp.curr.Y = y\n\treturn gp.GetY()\n}\n\n//experimental\nfunc (gp *GoPdf) SetNewYIfNoOffset(y float64, h float64) float64 {\n\tgp.UnitsToPointsVar(&y)\n\tgp.UnitsToPointsVar(&h)\n\tif y+h > gp.curr.pageSize.H-gp.MarginBottom() { // using new y(*y) instead of gp.curr.Y\n\t\tgp.AddPage()\n\t\ty = gp.MarginTop() // reset to top of the page.\n\t}\n\tgp.curr.Y = y\n\treturn gp.GetY()\n}\n\n//experimental\nfunc (gp *GoPdf) SetNewXY(y float64, x, h float64) float64{\n\tgp.UnitsToPointsVar(&y)\n\tgp.UnitsToPointsVar(&h)\n\tif gp.curr.Y+h > gp.curr.pageSize.H-gp.MarginBottom() {\n\t\tgp.AddPage()\n\t\ty = gp.MarginTop() // reset to top of the page.\n\t}\n\tgp.curr.Y = y\n\tgp.SetX(x)\n\treturn gp.GetY()\n}\n*/\n\n// SetY : set current position y\nfunc (gp *GoPdf) SetY(y float64) {\n\tgp.UnitsToPointsVar(&y)\n\tgp.curr.Y = y\n}\n\n// GetY : get current position y\nfunc (gp *GoPdf) GetY() float64 {\n\treturn gp.PointsToUnits(gp.curr.Y)\n}\n\n// SetXY : set current position x and y\nfunc (gp *GoPdf) SetXY(x, y float64) {\n\tgp.UnitsToPointsVar(&x)\n\tgp.curr.setXCount++\n\tgp.curr.X = x\n\n\tgp.UnitsToPointsVar(&y)\n\tgp.curr.Y = y\n}\n\n// ImageByHolder : draw image by ImageHolder\nfunc (gp *GoPdf) ImageByHolder(img ImageHolder, x float64, y float64, rect *Rect) error {\n\tgp.UnitsToPointsVar(&x, &y)\n\n\trect = rect.UnitsToPoints(gp.config.Unit)\n\n\timageOptions := ImageOptions{\n\t\tX:    x,\n\t\tY:    y,\n\t\tRect: rect,\n\t}\n\n\treturn gp.imageByHolder(img, imageOptions)\n}\n\nfunc (gp *GoPdf) ImageByHolderWithOptions(img ImageHolder, opts ImageOptions) error {\n\tgp.UnitsToPointsVar(&opts.X, &opts.Y)\n\n\topts.Rect = opts.Rect.UnitsToPoints(gp.config.Unit)\n\n\timageTransparency, err := gp.getCachedTransparency(opts.Transparency)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif imageTransparency != nil {\n\t\topts.extGStateIndexes = append(opts.extGStateIndexes, imageTransparency.extGStateIndex)\n\t}\n\n\tif opts.Mask != nil {\n\t\tmaskTransparency, err := gp.getCachedTransparency(opts.Mask.ImageOptions.Transparency)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tif maskTransparency != nil {\n\t\t\topts.Mask.ImageOptions.extGStateIndexes = append(opts.Mask.ImageOptions.extGStateIndexes, maskTransparency.extGStateIndex)\n\t\t}\n\n\t\tgp.UnitsToPointsVar(&opts.Mask.ImageOptions.X, &opts.Mask.ImageOptions.Y)\n\t\topts.Mask.ImageOptions.Rect = opts.Mask.ImageOptions.Rect.UnitsToPoints(gp.config.Unit)\n\n\t\textGStateIndex, err := gp.maskHolder(opts.Mask.Holder, *opts.Mask)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\topts.extGStateIndexes = append(opts.extGStateIndexes, extGStateIndex)\n\t}\n\n\treturn gp.imageByHolder(img, opts)\n}\n\nfunc (gp *GoPdf) maskHolder(img ImageHolder, opts MaskOptions) (int, error) {\n\tvar cacheImage *ImageCache\n\tvar cacheContentImage *cacheContentImage\n\n\tfor _, imgcache := range gp.curr.ImgCaches {\n\t\tif img.ID() == imgcache.Path {\n\t\t\tcacheImage = &imgcache\n\t\t\tbreak\n\t\t}\n\t}\n\n\tif cacheImage == nil {\n\t\tmaskImgobj := &ImageObj{IsMask: true}\n\t\tmaskImgobj.init(func() *GoPdf {\n\t\t\treturn gp\n\t\t})\n\t\tmaskImgobj.setProtection(gp.protection())\n\n\t\terr := maskImgobj.SetImage(img)\n\t\tif err != nil {\n\t\t\treturn 0, err\n\t\t}\n\n\t\tif opts.Rect == nil {\n\t\t\tif opts.Rect, err = maskImgobj.getRect(); err != nil {\n\t\t\t\treturn 0, err\n\t\t\t}\n\t\t}\n\n\t\tif err := maskImgobj.parse(); err != nil {\n\t\t\treturn 0, err\n\t\t}\n\n\t\tif gp.indexOfProcSet != -1 {\n\t\t\tindex := gp.addObj(maskImgobj)\n\t\t\tcacheContentImage = gp.getContent().GetCacheContentImage(index, opts.ImageOptions)\n\t\t\tprocset := gp.pdfObjs[gp.indexOfProcSet].(*ProcSetObj)\n\t\t\tprocset.RelateXobjs = append(procset.RelateXobjs, RelateXobject{IndexOfObj: index})\n\n\t\t\timgcache := ImageCache{\n\t\t\t\tIndex: index,\n\t\t\t\tPath:  img.ID(),\n\t\t\t\tRect:  opts.Rect,\n\t\t\t}\n\t\t\tgp.curr.ImgCaches[index] = imgcache\n\t\t\tgp.curr.CountOfImg++\n\t\t}\n\t} else {\n\t\tif opts.Rect == nil {\n\t\t\topts.Rect = gp.curr.ImgCaches[cacheImage.Index].Rect\n\t\t}\n\n\t\tcacheContentImage = gp.getContent().GetCacheContentImage(cacheImage.Index, opts.ImageOptions)\n\t}\n\n\tif cacheContentImage != nil {\n\t\textGStateInd, err := gp.createTransparencyXObjectGroup(cacheContentImage, opts)\n\t\tif err != nil {\n\t\t\treturn 0, err\n\t\t}\n\n\t\treturn extGStateInd, nil\n\t}\n\n\treturn 0, ErrUndefinedCacheContentImage\n}\n\nfunc (gp *GoPdf) createTransparencyXObjectGroup(image *cacheContentImage, opts MaskOptions) (int, error) {\n\tbbox := opts.BBox\n\tif bbox == nil {\n\t\tbbox = &[4]float64{\n\t\t\t// correct BBox values is [opts.X, gp.curr.pageSize.H - opts.Y - opts.Rect.H, opts.X + opts.Rect.W, gp.curr.pageSize.H - opts.Y]\n\t\t\t// but if compress pdf through ghostscript result file can't open correctly in mac viewer, because mac viewer can't parse BBox value correctly\n\t\t\t// all other viewers parse BBox correctly (like Adobe Acrobat Reader, Chrome, even Internet Explorer)\n\t\t\t// that's why we need to set [0, 0, gp.curr.pageSize.W, gp.curr.pageSize.H]\n\t\t\t-gp.curr.pageSize.W * 2,\n\t\t\t-gp.curr.pageSize.H * 2,\n\t\t\tgp.curr.pageSize.W * 2,\n\t\t\tgp.curr.pageSize.H * 2,\n\t\t\t// Also, Chrome pdf viewer incorrectly recognize BBox value, that's why we need to set twice as much value\n\t\t\t// for every mask element will be displayed\n\t\t}\n\t}\n\n\tgroupOpts := TransparencyXObjectGroupOptions{\n\t\tBBox:             *bbox,\n\t\tExtGStateIndexes: opts.extGStateIndexes,\n\t\tXObjects:         []cacheContentImage{*image},\n\t}\n\n\ttransparencyXObjectGroup, err := GetCachedTransparencyXObjectGroup(groupOpts, gp)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\n\tsMaskOptions := SMaskOptions{\n\t\tSubtype:                       SMaskLuminositySubtype,\n\t\tTransparencyXObjectGroupIndex: transparencyXObjectGroup.Index,\n\t}\n\tsMask := GetCachedMask(sMaskOptions, gp)\n\n\textGStateOpts := ExtGStateOptions{SMaskIndex: &sMask.Index}\n\textGState, err := GetCachedExtGState(extGStateOpts, gp)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\n\treturn extGState.Index + 1, nil\n}\n\nfunc (gp *GoPdf) imageByHolder(img ImageHolder, opts ImageOptions) error {\n\tcacheImageIndex := -1\n\n\tfor _, imgcache := range gp.curr.ImgCaches {\n\t\tif img.ID() == imgcache.Path {\n\t\t\tcacheImageIndex = imgcache.Index\n\t\t\tbreak\n\t\t}\n\t}\n\n\tif cacheImageIndex == -1 { //new image\n\n\t\t//create img object\n\t\timgobj := new(ImageObj)\n\t\tif opts.Mask != nil {\n\t\t\timgobj.SplittedMask = true\n\t\t}\n\n\t\timgobj.init(func() *GoPdf {\n\t\t\treturn gp\n\t\t})\n\t\timgobj.setProtection(gp.protection())\n\n\t\terr := imgobj.SetImage(img)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tif opts.Rect == nil {\n\t\t\tif opts.Rect, err = imgobj.getRect(); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\n\t\terr = imgobj.parse()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tindex := gp.addObj(imgobj)\n\t\tif gp.indexOfProcSet != -1 {\n\t\t\t//ยัดรูป\n\t\t\tprocset := gp.pdfObjs[gp.indexOfProcSet].(*ProcSetObj)\n\t\t\tgp.getContent().AppendStreamImage(index, opts)\n\t\t\tprocset.RelateXobjs = append(procset.RelateXobjs, RelateXobject{IndexOfObj: index})\n\t\t\t//เก็บข้อมูลรูปเอาไว้\n\t\t\tvar imgcache ImageCache\n\t\t\timgcache.Index = index\n\t\t\timgcache.Path = img.ID()\n\t\t\timgcache.Rect = opts.Rect\n\t\t\tgp.curr.ImgCaches[index] = imgcache\n\t\t\tgp.curr.CountOfImg++\n\t\t}\n\n\t\tif imgobj.haveSMask() {\n\t\t\tsmaskObj, err := imgobj.createSMask()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\timgobj.imginfo.smarkObjID = gp.addObj(smaskObj)\n\t\t}\n\n\t\tif imgobj.isColspaceIndexed() {\n\t\t\tdRGB, err := imgobj.createDeviceRGB()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tdRGB.getRoot = func() *GoPdf {\n\t\t\t\treturn gp\n\t\t\t}\n\t\t\timgobj.imginfo.deviceRGBObjID = gp.addObj(dRGB)\n\t\t}\n\n\t} else { //same img\n\t\tif opts.Rect == nil {\n\t\t\topts.Rect = gp.curr.ImgCaches[cacheImageIndex].Rect\n\t\t}\n\n\t\tgp.getContent().AppendStreamImage(cacheImageIndex, opts)\n\t}\n\treturn nil\n}\n\n// Image : draw image\nfunc (gp *GoPdf) Image(picPath string, x float64, y float64, rect *Rect) error {\n\tgp.UnitsToPointsVar(&x, &y)\n\trect = rect.UnitsToPoints(gp.config.Unit)\n\timgh, err := ImageHolderByPath(picPath)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\timageOptions := ImageOptions{\n\t\tX:    x,\n\t\tY:    y,\n\t\tRect: rect,\n\t}\n\n\treturn gp.imageByHolder(imgh, imageOptions)\n}\n\nfunc (gp *GoPdf) ImageFrom(img image.Image, x float64, y float64, rect *Rect) error {\n\treturn gp.ImageFromWithOption(img, ImageFromOption{\n\t\tFormat: \"png\",\n\t\tX:      x,\n\t\tY:      y,\n\t\tRect:   rect,\n\t})\n}\n\nfunc (gp *GoPdf) ImageFromWithOption(img image.Image, opts ImageFromOption) error {\n\tif img == nil {\n\t\treturn errors.New(\"Invalid image\")\n\t}\n\n\tgp.UnitsToPointsVar(&opts.X, &opts.Y)\n\topts.Rect = opts.Rect.UnitsToPoints(gp.config.Unit)\n\tr, w := io.Pipe()\n\tgo func() {\n\t\tbw := bufio.NewWriter(w)\n\t\tvar err error\n\t\tswitch opts.Format {\n\t\tcase \"png\":\n\t\t\terr = png.Encode(bw, img)\n\t\tcase \"jpeg\":\n\t\t\terr = jpeg.Encode(bw, img, nil)\n\t\t}\n\n\t\tbw.Flush()\n\t\tif err != nil {\n\t\t\tw.CloseWithError(err)\n\t\t} else {\n\t\t\tw.Close()\n\t\t}\n\t}()\n\n\timgh, err := ImageHolderByReader(bufio.NewReader(r))\n\tif err != nil {\n\t\treturn err\n\t}\n\n\timageOptions := ImageOptions{\n\t\tX:    opts.X,\n\t\tY:    opts.Y,\n\t\tRect: opts.Rect,\n\t}\n\n\treturn gp.imageByHolder(imgh, imageOptions)\n}\n\n// AddPage : add new page\nfunc (gp *GoPdf) AddPage() {\n\temptyOpt := PageOption{}\n\tgp.AddPageWithOption(emptyOpt)\n}\n\n// AddPageWithOption  : add new page with option\nfunc (gp *GoPdf) AddPageWithOption(opt PageOption) {\n\topt.TrimBox = opt.TrimBox.UnitsToPoints(gp.config.Unit)\n\topt.PageSize = opt.PageSize.UnitsToPoints(gp.config.Unit)\n\n\tpage := new(PageObj)\n\tpage.init(func() *GoPdf {\n\t\treturn gp\n\t})\n\n\tif !opt.isEmpty() { //use page option\n\t\tpage.setOption(opt)\n\t\tgp.curr.pageSize = opt.PageSize\n\n\t\tif opt.isTrimBoxSet() {\n\t\t\tgp.curr.trimBox = opt.TrimBox\n\t\t}\n\t} else { //use default\n\t\tgp.curr.pageSize = &gp.config.PageSize\n\t\tgp.curr.trimBox = &gp.config.TrimBox\n\t}\n\n\tpage.ResourcesRelate = strconv.Itoa(gp.indexOfProcSet+1) + \" 0 R\"\n\tindex := gp.addObj(page)\n\tif gp.indexOfFirstPageObj == -1 {\n\t\tgp.indexOfFirstPageObj = index\n\t}\n\tgp.curr.IndexOfPageObj = index\n\n\tgp.numOfPagesObj++\n\n\t//reset\n\tgp.indexOfContent = -1\n\tgp.resetCurrXY()\n\n\tif gp.headerFunc != nil {\n\t\tgp.headerFunc()\n\t\tgp.resetCurrXY()\n\t}\n\n\tif gp.footerFunc != nil {\n\t\tgp.footerFunc()\n\t\tgp.resetCurrXY()\n\t}\n}\n\nfunc (gp *GoPdf) AddOutline(title string) {\n\tgp.outlines.AddOutline(gp.curr.IndexOfPageObj+1, title)\n}\n\n// AddOutlineWithPosition add an outline with position\nfunc (gp *GoPdf) AddOutlineWithPosition(title string) *OutlineObj {\n\treturn gp.outlines.AddOutlinesWithPosition(gp.curr.IndexOfPageObj+1, title, gp.config.PageSize.H-gp.curr.Y+20)\n}\n\n// AddHeader - add a header function, if present this will be automatically called by AddPage()\nfunc (gp *GoPdf) AddHeader(f func()) {\n\tgp.headerFunc = f\n}\n\n// AddFooter - add a footer function, if present this will be automatically called by AddPage()\nfunc (gp *GoPdf) AddFooter(f func()) {\n\tgp.footerFunc = f\n}\n\n// Start : init gopdf\nfunc (gp *GoPdf) Start(config Config) {\n\n\tgp.start(config)\n\n}\n\nfunc (gp *GoPdf) StartWithImporter(config Config, importer *gofpdi.Importer) {\n\n\tgp.start(config, importer)\n\n}\n\nfunc (gp *GoPdf) start(config Config, importer ...*gofpdi.Importer) {\n\n\tgp.config = config\n\tgp.init(importer...)\n\t//init all basic obj\n\tcatalog := new(CatalogObj)\n\tcatalog.init(func() *GoPdf {\n\t\treturn gp\n\t})\n\tpages := new(PagesObj)\n\tpages.init(func() *GoPdf {\n\t\treturn gp\n\t})\n\tgp.outlines = new(OutlinesObj)\n\tgp.outlines.init(func() *GoPdf {\n\t\treturn gp\n\t})\n\tgp.indexOfCatalogObj = gp.addObj(catalog)\n\tgp.indexOfPagesObj = gp.addObj(pages)\n\tgp.indexOfOutlinesObj = gp.addObj(gp.outlines)\n\tgp.outlines.SetIndexObjOutlines(gp.indexOfOutlinesObj)\n\n\t//indexOfProcSet\n\tprocset := new(ProcSetObj)\n\tprocset.init(func() *GoPdf {\n\t\treturn gp\n\t})\n\tgp.indexOfProcSet = gp.addObj(procset)\n\n\tif gp.isUseProtection() {\n\t\tgp.pdfProtection = gp.createProtection()\n\t}\n\n\tgp.placeHolderTexts = make(map[string][]placeHolderTextInfo)\n\n}\n\n// convertNumericToFloat64 : accept numeric types, return float64-value\nfunc convertNumericToFloat64(size interface{}) (fontSize float64, err error) {\n\tswitch size := size.(type) {\n\tcase float32:\n\t\treturn float64(size), nil\n\tcase float64:\n\t\treturn float64(size), nil\n\tcase int:\n\t\treturn float64(size), nil\n\tcase int16:\n\t\treturn float64(size), nil\n\tcase int32:\n\t\treturn float64(size), nil\n\tcase int64:\n\t\treturn float64(size), nil\n\tcase int8:\n\t\treturn float64(size), nil\n\tcase uint:\n\t\treturn float64(size), nil\n\tcase uint16:\n\t\treturn float64(size), nil\n\tcase uint32:\n\t\treturn float64(size), nil\n\tcase uint64:\n\t\treturn float64(size), nil\n\tcase uint8:\n\t\treturn float64(size), nil\n\tdefault:\n\t\treturn 0.0, fmt.Errorf(\"fontSize must be of type (u)int* or float*, not %T\", size)\n\t}\n}\n\n// SetFontWithStyle : set font style support Regular or Underline\n// for Bold|Italic should be loaded appropriate fonts with same styles defined\n// size MUST be uint*, int* or float64*\nfunc (gp *GoPdf) SetFontWithStyle(family string, style int, size interface{}) error {\n\tfontSize, err := convertNumericToFloat64(size)\n\tif err != nil {\n\t\treturn err\n\t}\n\tfound := false\n\ti := 0\n\tmax := len(gp.pdfObjs)\n\tfor i < max {\n\t\tif gp.pdfObjs[i].getType() == subsetFont {\n\t\t\tobj := gp.pdfObjs[i]\n\t\t\tsub, ok := obj.(*SubsetFontObj)\n\t\t\tif ok {\n\t\t\t\tif sub.GetFamily() == family && sub.GetTtfFontOption().Style == style&^Underline {\n\t\t\t\t\tgp.curr.FontSize = fontSize\n\t\t\t\t\tgp.curr.FontStyle = style\n\t\t\t\t\tgp.curr.FontFontCount = sub.CountOfFont\n\t\t\t\t\tgp.curr.FontISubset = sub\n\t\t\t\t\tfound = true\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\ti++\n\t}\n\n\tif !found {\n\t\treturn ErrMissingFontFamily\n\t}\n\n\treturn nil\n}\n\n// SetFont : set font style support \"\" or \"U\"\n// for \"B\" and \"I\" should be loaded appropriate fonts with same styles defined\n// size MUST be uint*, int* or float64*\nfunc (gp *GoPdf) SetFont(family string, style string, size interface{}) error {\n\treturn gp.SetFontWithStyle(family, getConvertedStyle(style), size)\n}\n\n// SetFontSize : set the font size (and only the font size) of the currently\n// active font\nfunc (gp *GoPdf) SetFontSize(fontSize float64) error {\n\tgp.curr.FontSize = fontSize\n\treturn nil\n}\n\n// SetCharSpacing : set the character spacing of the currently active font\nfunc (gp *GoPdf) SetCharSpacing(charSpacing float64) error {\n\tgp.UnitsToPointsVar(&charSpacing)\n\tgp.curr.CharSpacing = charSpacing\n\treturn nil\n}\n\n// WritePdf : write pdf file\nfunc (gp *GoPdf) WritePdf(pdfPath string) error {\n\treturn os.WriteFile(pdfPath, gp.GetBytesPdf(), 0644)\n}\n\n// WriteTo implements the io.WriterTo interface and can\n// be used to stream the PDF as it is compiled to an io.Writer.\nfunc (gp *GoPdf) WriteTo(w io.Writer) (n int64, err error) {\n\treturn gp.compilePdf(w)\n}\n\n// Write streams the pdf as it is compiled to an io.Writer\n//\n// Deprecated: use the WriteTo method instead.\nfunc (gp *GoPdf) Write(w io.Writer) error {\n\t_, err := gp.compilePdf(w)\n\treturn err\n}\n\nfunc (gp *GoPdf) Read(p []byte) (int, error) {\n\tif gp.buf.Len() == 0 && gp.buf.Cap() == 0 {\n\t\tif _, err := gp.compilePdf(&gp.buf); err != nil {\n\t\t\treturn 0, err\n\t\t}\n\t}\n\treturn gp.buf.Read(p)\n}\n\n// Close clears the gopdf buffer.\nfunc (gp *GoPdf) Close() error {\n\tgp.buf = bytes.Buffer{}\n\treturn nil\n}\n\nfunc (gp *GoPdf) compilePdf(w io.Writer) (n int64, err error) {\n\tgp.prepare()\n\terr = gp.Close()\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\tmax := len(gp.pdfObjs)\n\twriter := newCountingWriter(w)\n\tfmt.Fprint(writer, \"%PDF-1.7\\n%����\\n\\n\")\n\tlinelens := make([]int64, max)\n\ti := 0\n\n\tfor i < max {\n\t\tobjID := i + 1\n\t\tlinelens[i] = writer.offset\n\t\tpdfObj := gp.pdfObjs[i]\n\t\tfmt.Fprintf(writer, \"%d 0 obj\\n\", objID)\n\t\tpdfObj.write(writer, objID)\n\t\tio.WriteString(writer, \"endobj\\n\\n\")\n\t\ti++\n\t}\n\tgp.xref(writer, writer.offset, linelens, i)\n\treturn writer.offset, nil\n}\n\ntype (\n\tcountingWriter struct {\n\t\toffset int64\n\t\twriter io.Writer\n\t}\n)\n\nfunc newCountingWriter(w io.Writer) *countingWriter {\n\treturn &countingWriter{writer: w}\n}\n\nfunc (cw *countingWriter) Write(b []byte) (int, error) {\n\tn, err := cw.writer.Write(b)\n\tcw.offset += int64(n)\n\treturn n, err\n}\n\n// GetBytesPdfReturnErr : get bytes of pdf file\nfunc (gp *GoPdf) GetBytesPdfReturnErr() ([]byte, error) {\n\terr := gp.Close()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\t_, err = gp.compilePdf(&gp.buf)\n\treturn gp.buf.Bytes(), err\n}\n\n// GetBytesPdf : get bytes of pdf file\nfunc (gp *GoPdf) GetBytesPdf() []byte {\n\tb, err := gp.GetBytesPdfReturnErr()\n\tif err != nil {\n\t\tlog.Fatalf(\"%s\", err.Error())\n\t}\n\treturn b\n}\n\n// Text write text start at current x,y ( current y is the baseline of text )\nfunc (gp *GoPdf) Text(text string) error {\n\n\ttext, err := gp.curr.FontISubset.AddChars(text)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\terr = gp.getContent().AppendStreamText(text)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\n// CellWithOption create cell of text ( use current x,y is upper-left corner of cell)\nfunc (gp *GoPdf) CellWithOption(rectangle *Rect, text string, opt CellOption) error {\n\ttransparency, err := gp.getCachedTransparency(opt.Transparency)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif transparency != nil {\n\t\topt.extGStateIndexes = append(opt.extGStateIndexes, transparency.extGStateIndex)\n\t}\n\n\trectangle = rectangle.UnitsToPoints(gp.config.Unit)\n\ttext, err = gp.curr.FontISubset.AddChars(text)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif err := gp.getContent().AppendStreamSubsetFont(rectangle, text, opt); err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\n// Cell : create cell of text ( use current x,y is upper-left corner of cell)\n// Note that this has no effect on Rect.H pdf (now). Fix later :-)\nfunc (gp *GoPdf) Cell(rectangle *Rect, text string) error {\n\trectangle = rectangle.UnitsToPoints(gp.config.Unit)\n\tdefaultopt := CellOption{\n\t\tAlign:  Left | Top,\n\t\tBorder: 0,\n\t\tFloat:  Right,\n\t}\n\n\ttext, err := gp.curr.FontISubset.AddChars(text)\n\tif err != nil {\n\t\treturn err\n\t}\n\terr = gp.getContent().AppendStreamSubsetFont(rectangle, text, defaultopt)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\n// MultiCell : create of text with line breaks ( use current x,y is upper-left corner of cell)\nfunc (gp *GoPdf) MultiCell(rectangle *Rect, text string) error {\n\tvar line []rune\n\tx := gp.GetX()\n\tvar totalLineHeight float64\n\tlength := len([]rune(text))\n\n\t// get lineHeight\n\ttext, err := gp.curr.FontISubset.AddChars(text)\n\tif err != nil {\n\t\treturn err\n\t}\n\t_, lineHeight, _, err := createContent(gp.curr.FontISubset, text, gp.curr.FontSize, gp.curr.CharSpacing, nil)\n\tif err != nil {\n\t\treturn err\n\t}\n\tgp.PointsToUnitsVar(&lineHeight)\n\n\tfor i, v := range []rune(text) {\n\t\tif totalLineHeight+lineHeight > rectangle.H {\n\t\t\tbreak\n\t\t}\n\t\tlineWidth, _ := gp.MeasureTextWidth(string(line))\n\t\truneWidth, _ := gp.MeasureTextWidth(string(v))\n\n\t\tif lineWidth+runeWidth > rectangle.W {\n\t\t\tgp.Cell(&Rect{W: rectangle.W, H: lineHeight}, string(line))\n\t\t\tgp.Br(lineHeight)\n\t\t\tgp.SetX(x)\n\t\t\ttotalLineHeight = totalLineHeight + lineHeight\n\t\t\tline = nil\n\t\t}\n\n\t\tline = append(line, v)\n\n\t\tif i == length-1 {\n\t\t\tgp.Cell(&Rect{W: rectangle.W, H: lineHeight}, string(line))\n\t\t\tgp.Br(lineHeight)\n\t\t\tgp.SetX(x)\n\t\t}\n\t}\n\treturn nil\n}\n\n// IsFitMultiCell : check whether the rectangle's area is big enough for the text\nfunc (gp *GoPdf) IsFitMultiCell(rectangle *Rect, text string) (bool, float64, error) {\n\tvar line []rune\n\tvar totalLineHeight float64\n\tlength := len([]rune(text))\n\n\t// get lineHeight\n\ttext, err := gp.curr.FontISubset.AddChars(text)\n\tif err != nil {\n\t\treturn false, totalLineHeight, err\n\t}\n\t_, lineHeight, _, err := createContent(gp.curr.FontISubset, text, gp.curr.FontSize, gp.curr.CharSpacing, nil)\n\n\tif err != nil {\n\t\treturn false, totalLineHeight, err\n\t}\n\tgp.PointsToUnitsVar(&lineHeight)\n\n\tfor i, v := range []rune(text) {\n\t\tif totalLineHeight+lineHeight > rectangle.H {\n\t\t\treturn false, totalLineHeight, nil\n\t\t}\n\t\tlineWidth, _ := gp.MeasureTextWidth(string(line))\n\t\truneWidth, _ := gp.MeasureTextWidth(string(v))\n\n\t\tif lineWidth+runeWidth > rectangle.W {\n\t\t\ttotalLineHeight += lineHeight\n\t\t\tline = nil\n\t\t}\n\n\t\tline = append(line, v)\n\n\t\tif i == length-1 {\n\t\t\ttotalLineHeight += lineHeight\n\t\t}\n\t}\n\n\tok := true\n\tif totalLineHeight > rectangle.H {\n\t\tok = false\n\t}\n\n\treturn ok, totalLineHeight, nil\n}\n\n// IsFitMultiCellWithNewline : similar to IsFitMultiCell, but process char newline as Br\nfunc (gp *GoPdf) IsFitMultiCellWithNewline(rectangle *Rect, text string) (bool, float64, error) {\n\tr := *rectangle\n\tstrs := strings.Split(text, \"\\n\")\n\n\tfor _, s := range strs {\n\t\tok, height, err := gp.IsFitMultiCell(&r, s)\n\t\tif err != nil || !ok {\n\t\t\treturn false, 0, err\n\t\t}\n\t\tr.H -= height\n\t}\n\n\treturn true, rectangle.H - r.H, nil\n}\n\n// MultiCellWithOption create of text with line breaks ( use current x,y is upper-left corner of cell)\nfunc (gp *GoPdf) MultiCellWithOption(rectangle *Rect, text string, opt CellOption) error {\n\tif opt.BreakOption == nil {\n\t\topt.BreakOption = &DefaultBreakOption\n\t}\n\n\ttransparency, err := gp.getCachedTransparency(opt.Transparency)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif transparency != nil {\n\t\topt.extGStateIndexes = append(opt.extGStateIndexes, transparency.extGStateIndex)\n\t}\n\n\tx := gp.GetX()\n\n\t// get lineHeight\n\titext, err := gp.curr.FontISubset.AddChars(text)\n\tif err != nil {\n\t\treturn err\n\t}\n\t_, lineHeight, _, err := createContent(gp.curr.FontISubset, itext, gp.curr.FontSize, gp.curr.CharSpacing, nil)\n\tif err != nil {\n\t\treturn err\n\t}\n\tgp.PointsToUnitsVar(&lineHeight)\n\n\ttextSplits, err := gp.SplitTextWithOption(text, rectangle.W, opt.BreakOption)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tfor _, text := range textSplits {\n\t\tgp.CellWithOption(&Rect{W: rectangle.W, H: rectangle.H}, string(text), opt)\n\t\tgp.Br(lineHeight)\n\t\tgp.SetX(x)\n\t}\n\n\treturn nil\n}\n\n// SplitText splits text into multiple lines based on width performing potential mid-word breaks.\nfunc (gp *GoPdf) SplitText(text string, width float64) ([]string, error) {\n\treturn gp.SplitTextWithOption(text, width, &DefaultBreakOption)\n}\n\n// SplitTextWithWordWrap behaves the same way SplitText does but performs a word-wrap considering spaces in case\n// a text line split would split a word.\nfunc (gp *GoPdf) SplitTextWithWordWrap(text string, width float64) ([]string, error) {\n\treturn gp.SplitTextWithOption(text, width, &BreakOption{\n\t\tMode:           BreakModeIndicatorSensitive,\n\t\tBreakIndicator: ' ',\n\t})\n}\n\n// SplitTextWithOption splits a text into multiple lines based on the current font size of the document.\n// BreakOptions allow to define the behavior of the split (strict or sensitive). For more information see BreakOption.\nfunc (gp *GoPdf) SplitTextWithOption(text string, width float64, opt *BreakOption) ([]string, error) {\n\t// fallback to default break option\n\tif opt == nil {\n\t\topt = &DefaultBreakOption\n\t}\n\tvar lineText []rune\n\tvar lineTexts []string\n\tutf8Texts := []rune(text)\n\tutf8TextsLen := len(utf8Texts) // utf8 string quantity\n\tif utf8TextsLen == 0 {\n\t\treturn lineTexts, ErrEmptyString\n\t}\n\tseparatorWidth, err := gp.MeasureTextWidth(opt.Separator)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\t// possible (not conflicting) position of the separator within the currently processed line\n\tseparatorIdx := 0\n\tfor i := 0; i < utf8TextsLen; i++ {\n\t\tlineWidth, err := gp.MeasureTextWidth(string(lineText))\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\truneWidth, err := gp.MeasureTextWidth(string(utf8Texts[i]))\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\t// mid-word break required since the max width of the given rect is exceeded\n\t\tif lineWidth+runeWidth > width && utf8Texts[i] != '\\n' {\n\t\t\t// forceBreak will be set to true in case an indicator sensitive break was not possible which will cause\n\t\t\t// strict break to not exceed the desired width\n\t\t\tforceBreak := false\n\t\t\tif opt.Mode == BreakModeIndicatorSensitive {\n\t\t\t\tforceBreak = !performIndicatorSensitiveLineBreak(&lineTexts, &lineText, &i, opt)\n\t\t\t}\n\t\t\t// BreakModeStrict breaks immediately with an optionally available separator\n\t\t\tif opt.Mode == BreakModeStrict || forceBreak {\n\t\t\t\tperformStrictLineBreak(&lineTexts, &lineText, &i, separatorIdx, opt)\n\t\t\t}\n\t\t\tcontinue\n\t\t}\n\t\t// regular break due to a new line rune\n\t\tif utf8Texts[i] == '\\n' {\n\t\t\tlineTexts = append(lineTexts, string(lineText))\n\t\t\tlineText = lineText[0:0]\n\t\t\tcontinue\n\t\t}\n\t\t// end of text\n\t\tif i == utf8TextsLen-1 {\n\t\t\tlineText = append(lineText, utf8Texts[i])\n\t\t\tlineTexts = append(lineTexts, string(lineText))\n\t\t}\n\t\t// store overall index when separator would still fit in the currently processed text-line\n\t\tif opt.HasSeparator() && lineWidth+runeWidth+separatorWidth <= width {\n\t\t\tseparatorIdx = i\n\t\t}\n\t\tlineText = append(lineText, utf8Texts[i])\n\t}\n\treturn lineTexts, nil\n}\n\n// [experimental]\n// PlaceHolderText Create a text placehold for fillin text later with function FillInPlaceHoldText.\nfunc (gp *GoPdf) PlaceHolderText(placeHolderName string, placeHolderWidth float64) error {\n\n\t//placeHolderText := fmt.Sprintf(\"{%s}\", placeHolderName)\n\t_, err := gp.curr.FontISubset.AddChars(\"\")\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tgp.PointsToUnitsVar(&placeHolderWidth)\n\terr = gp.getContent().appendStreamPlaceHolderText(placeHolderWidth)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tcontent := gp.pdfObjs[gp.indexOfContent].(*ContentObj)\n\tindexInContent := len(content.listCache.caches) - 1\n\tindexOfContent := gp.indexOfContent\n\tfontISubset := gp.curr.FontISubset\n\n\tgp.placeHolderTexts[placeHolderName] = append(\n\t\tgp.placeHolderTexts[placeHolderName],\n\t\tplaceHolderTextInfo{\n\t\t\tindexOfContent:   indexOfContent,\n\t\t\tindexInContent:   indexInContent,\n\t\t\tfontISubset:      fontISubset,\n\t\t\tplaceHolderWidth: placeHolderWidth,\n\t\t\tfontSize:         gp.curr.FontSize,\n\t\t\tcharSpacing:      gp.curr.CharSpacing,\n\t\t},\n\t)\n\n\treturn nil\n}\n\n// [experimental]\n// fill in text that created by function PlaceHolderText\n// align: Left,Right,Center\nfunc (gp *GoPdf) FillInPlaceHoldText(placeHolderName string, text string, align int) error {\n\n\tinfos, ok := gp.placeHolderTexts[placeHolderName]\n\tif !ok {\n\t\treturn errors.New(\"placeHolderName not found\")\n\t}\n\n\tfor _, info := range infos {\n\t\tcontent, ok := gp.pdfObjs[info.indexOfContent].(*ContentObj)\n\t\tif !ok {\n\t\t\treturn errors.New(\"gp.pdfObjs is not *ContentObj\")\n\t\t}\n\t\tcontentText, ok := content.listCache.caches[info.indexInContent].(*cacheContentText)\n\t\tif !ok {\n\t\t\treturn errors.New(\"listCache.caches is not *cacheContentText\")\n\t\t}\n\t\tinfo.fontISubset.AddChars(text)\n\t\tcontentText.text = text\n\n\t\t//Calculate position\n\t\t_, _, textWidthPdfUnit, err := createContent(gp.curr.FontISubset, text, info.fontSize, info.charSpacing, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\twidth := pointsToUnits(gp.config, textWidthPdfUnit)\n\n\t\tif align == Right {\n\t\t\tdiff := info.placeHolderWidth - width\n\t\t\tcontentText.x = contentText.x + diff\n\t\t} else if align == Center {\n\t\t\tdiff := info.placeHolderWidth - width\n\t\t\tcontentText.x = contentText.x + diff/2\n\t\t}\n\t}\n\n\treturn nil\n}\n\nfunc performIndicatorSensitiveLineBreak(lineTexts *[]string, lineText *[]rune, i *int, opt *BreakOption) bool {\n\tbrIdx := breakIndicatorIndex(*lineText, opt.BreakIndicator)\n\tif brIdx > 0 {\n\t\tdiff := len(*lineText) - brIdx\n\t\t*lineText = (*lineText)[0:brIdx]\n\t\t*lineTexts = append(*lineTexts, string(*lineText))\n\t\t*lineText = (*lineText)[0:0]\n\t\t*i -= diff\n\t\treturn true\n\t}\n\treturn false\n}\n\nfunc performStrictLineBreak(lineTexts *[]string, lineText *[]rune, i *int, separatorIdx int, opt *BreakOption) {\n\tif opt.HasSeparator() && separatorIdx > -1 {\n\t\t// trim the line to the last possible index with an appended separator\n\t\ttrimIdx := *i - separatorIdx\n\t\t*lineText = (*lineText)[0 : len(*lineText)-trimIdx]\n\t\t// append separator to the line\n\t\t*lineText = append(*lineText, []rune(opt.Separator)...)\n\t\t*lineTexts = append(*lineTexts, string(*lineText))\n\t\t*lineText = (*lineText)[0:0]\n\t\t*i = separatorIdx - 1\n\t\treturn\n\t}\n\t*lineTexts = append(*lineTexts, string(*lineText))\n\t*lineText = (*lineText)[0:0]\n\t*i--\n}\n\n// breakIndicatorIndex returns the index where a text line (i.e. rune slice) can be split \"gracefully\" by checking on\n// the break indicator.\n// In case no possible break can be identified -1 is returned.\nfunc breakIndicatorIndex(text []rune, bi rune) int {\n\tfor i := len(text) - 1; i > 0; i-- {\n\t\tif text[i] == bi {\n\t\t\treturn i\n\t\t}\n\t}\n\treturn -1\n}\n\n// ImportPage imports a page and return template id.\n// gofpdi code\nfunc (gp *GoPdf) ImportPage(sourceFile string, pageno int, box string) int {\n\t// Set source file for fpdi\n\tgp.fpdi.SetSourceFile(sourceFile)\n\n\t// gofpdi needs to know where to start the object id at.\n\t// By default, it starts at 1, but gopdf adds a few objects initially.\n\tstartObjID := gp.GetNextObjectID()\n\n\t// Set gofpdi next object ID to  whatever the value of startObjID is\n\tgp.fpdi.SetNextObjectID(startObjID)\n\n\t// Import page\n\ttpl := gp.fpdi.ImportPage(pageno, box)\n\n\t// Import objects into current pdf document\n\ttplObjIDs := gp.fpdi.PutFormXobjects()\n\n\t// Set template names and ids in gopdf\n\tgp.ImportTemplates(tplObjIDs)\n\n\t// Get a map[int]string of the imported objects.\n\t// The map keys will be the ID of each object.\n\timported := gp.fpdi.GetImportedObjects()\n\n\t// Import gofpdi objects into gopdf, starting at whatever the value of startObjID is\n\tgp.ImportObjects(imported, startObjID)\n\n\t// Return template ID\n\treturn tpl\n}\n\n// ImportPageStream imports page using a stream.\n// Return template id after importing.\n// gofpdi code\nfunc (gp *GoPdf) ImportPageStream(sourceStream *io.ReadSeeker, pageno int, box string) int {\n\t// Set source file for fpdi\n\tgp.fpdi.SetSourceStream(sourceStream)\n\n\t// gofpdi needs to know where to start the object id at.\n\t// By default, it starts at 1, but gopdf adds a few objects initially.\n\tstartObjID := gp.GetNextObjectID()\n\n\t// Set gofpdi next object ID to  whatever the value of startObjID is\n\tgp.fpdi.SetNextObjectID(startObjID)\n\n\t// Import page\n\ttpl := gp.fpdi.ImportPage(pageno, box)\n\n\t// Import objects into current pdf document\n\ttplObjIDs := gp.fpdi.PutFormXobjects()\n\n\t// Set template names and ids in gopdf\n\tgp.ImportTemplates(tplObjIDs)\n\n\t// Get a map[int]string of the imported objects.\n\t// The map keys will be the ID of each object.\n\timported := gp.fpdi.GetImportedObjects()\n\n\t// Import gofpdi objects into gopdf, starting at whatever the value of startObjID is\n\tgp.ImportObjects(imported, startObjID)\n\n\t// Return template ID\n\treturn tpl\n}\n\n// UseImportedTemplate draws an imported PDF page.\nfunc (gp *GoPdf) UseImportedTemplate(tplid int, x float64, y float64, w float64, h float64) {\n\tgp.UnitsToPointsVar(&x, &y, &w, &h)\n\t// Get template values to draw\n\ttplName, scaleX, scaleY, tX, tY := gp.fpdi.UseTemplate(tplid, x, y, w, h)\n\tgp.getContent().AppendStreamImportedTemplate(tplName, scaleX, scaleY, tX, tY)\n}\n\n// ImportPagesFromSource imports pages from a source pdf.\n// The source can be a file path, byte slice, or (*)io.ReadSeeker.\nfunc (gp *GoPdf) ImportPagesFromSource(source interface{}, box string) error {\n\tswitch v := source.(type) {\n\tcase string:\n\t\t// Set source file for fpdi\n\t\tgp.fpdi.SetSourceFile(v)\n\tcase []byte:\n\t\t// Set source stream for fpdi\n\t\trs := io.ReadSeeker(bytes.NewReader(v))\n\t\tgp.fpdi.SetSourceStream(&rs)\n\tcase io.ReadSeeker:\n\t\t// Set source stream for fpdi\n\t\tgp.fpdi.SetSourceStream(&v)\n\tcase *io.ReadSeeker:\n\t\t// Set source stream for fpdi\n\t\tgp.fpdi.SetSourceStream(v)\n\tdefault:\n\t\treturn errors.New(\"source type not supported\")\n\t}\n\n\t// Get number of pages from source file\n\tpages := gp.fpdi.GetNumPages()\n\n\t// Get page sizes from source file\n\tsizes := gp.fpdi.GetPageSizes()\n\n\tfor i := 0; i < pages; i++ {\n\t\tpageno := i + 1\n\n\t\t// Get the size of the page\n\t\tsize, ok := sizes[pageno][box]\n\t\tif !ok {\n\t\t\treturn errors.New(\"can not get page size\")\n\t\t}\n\n\t\t// Add a new page to the document\n\t\tgp.AddPage()\n\n\t\t// gofpdi needs to know where to start the object id at.\n\t\t// By default, it starts at 1, but gopdf adds a few objects initially.\n\t\tstartObjID := gp.GetNextObjectID()\n\n\t\t// Set gofpdi next object ID to  whatever the value of startObjID is\n\t\tgp.fpdi.SetNextObjectID(startObjID)\n\n\t\t// Import page\n\t\ttpl := gp.fpdi.ImportPage(pageno, box)\n\n\t\t// Import objects into current pdf document\n\t\ttplObjIDs := gp.fpdi.PutFormXobjects()\n\n\t\t// Set template names and ids in gopdf\n\t\tgp.ImportTemplates(tplObjIDs)\n\n\t\t// Get a map[int]string of the imported objects.\n\t\t// The map keys will be the ID of each object.\n\t\timported := gp.fpdi.GetImportedObjects()\n\n\t\t// Import gofpdi objects into gopdf, starting at whatever the value of startObjID is\n\t\tgp.ImportObjects(imported, startObjID)\n\n\t\t// Draws the imported template on the current page\n\t\tgp.UseImportedTemplate(tpl, 0, 0, size[\"w\"], size[\"h\"])\n\t}\n\n\treturn nil\n}\n\n// GetNextObjectID gets the next object ID so that gofpdi knows where to start the object IDs.\nfunc (gp *GoPdf) GetNextObjectID() int {\n\treturn len(gp.pdfObjs) + 1\n}\n\n// GetNumberOfPages gets the number of pages from the PDF.\nfunc (gp *GoPdf) GetNumberOfPages() int {\n\treturn gp.numOfPagesObj\n}\n\n// ImportObjects imports objects from gofpdi into current document.\nfunc (gp *GoPdf) ImportObjects(objs map[int]string, startObjID int) {\n\tfor i := startObjID; i < len(objs)+startObjID; i++ {\n\t\tif objs[i] != \"\" {\n\t\t\tgp.addObj(&ImportedObj{Data: objs[i]})\n\t\t}\n\t}\n}\n\n// ImportTemplates names into procset dictionary.\nfunc (gp *GoPdf) ImportTemplates(tpls map[string]int) {\n\tprocset := gp.pdfObjs[gp.indexOfProcSet].(*ProcSetObj)\n\tfor tplName, tplID := range tpls {\n\t\tprocset.ImportedTemplateIds[tplName] = tplID\n\t}\n}\n\n// AddExternalLink adds a new external link.\nfunc (gp *GoPdf) AddExternalLink(url string, x, y, w, h float64) {\n\tgp.UnitsToPointsVar(&x, &y, &w, &h)\n\n\tlinkOpt := linkOption{x, gp.config.PageSize.H - y, w, h, url, \"\"}\n\tgp.addLink(linkOpt)\n}\n\n// AddInternalLink adds a new internal link.\nfunc (gp *GoPdf) AddInternalLink(anchor string, x, y, w, h float64) {\n\tgp.UnitsToPointsVar(&x, &y, &w, &h)\n\n\tlinkOpt := linkOption{x, gp.config.PageSize.H - y, w, h, \"\", anchor}\n\tgp.addLink(linkOpt)\n}\n\nfunc (gp *GoPdf) addLink(option linkOption) {\n\tpage := gp.pdfObjs[gp.curr.IndexOfPageObj].(*PageObj)\n\tlinkObj := gp.addObj(annotObj{option, func() *GoPdf {\n\t\treturn gp\n\t}})\n\tpage.LinkObjIds = append(page.LinkObjIds, linkObj+1)\n}\n\n// SetAnchor creates a new anchor.\nfunc (gp *GoPdf) SetAnchor(name string) {\n\ty := gp.config.PageSize.H - gp.curr.Y + float64(gp.curr.FontSize)\n\tgp.anchors[name] = anchorOption{gp.curr.IndexOfPageObj, y}\n}\n\n// AddTTFFontByReader adds font data by reader.\nfunc (gp *GoPdf) AddTTFFontData(family string, fontData []byte) error {\n\treturn gp.AddTTFFontDataWithOption(family, fontData, defaultTtfFontOption())\n}\n\n// AddTTFFontDataWithOption adds font data with option.\nfunc (gp *GoPdf) AddTTFFontDataWithOption(family string, fontData []byte, option TtfOption) error {\n\tsubsetFont := new(SubsetFontObj)\n\tsubsetFont.init(func() *GoPdf {\n\t\treturn gp\n\t})\n\tsubsetFont.SetTtfFontOption(option)\n\tsubsetFont.SetFamily(family)\n\terr := subsetFont.SetTTFData(fontData)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn gp.setSubsetFontObject(subsetFont, family, option)\n}\n\n// AddTTFFontByReader adds font file by reader.\nfunc (gp *GoPdf) AddTTFFontByReader(family string, rd io.Reader) error {\n\treturn gp.AddTTFFontByReaderWithOption(family, rd, defaultTtfFontOption())\n}\n\n// AddTTFFontByReaderWithOption adds font file by reader with option.\nfunc (gp *GoPdf) AddTTFFontByReaderWithOption(family string, rd io.Reader, option TtfOption) error {\n\tsubsetFont := new(SubsetFontObj)\n\tsubsetFont.init(func() *GoPdf {\n\t\treturn gp\n\t})\n\tsubsetFont.SetTtfFontOption(option)\n\tsubsetFont.SetFamily(family)\n\terr := subsetFont.SetTTFByReader(rd)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn gp.setSubsetFontObject(subsetFont, family, option)\n}\n\n// setSubsetFontObject sets SubsetFontObj.\n// The given SubsetFontObj is expected to be configured in advance.\nfunc (gp *GoPdf) setSubsetFontObject(subsetFont *SubsetFontObj, family string, option TtfOption) error {\n\tunicodemap := new(UnicodeMap)\n\tunicodemap.init(func() *GoPdf {\n\t\treturn gp\n\t})\n\tunicodemap.setProtection(gp.protection())\n\tunicodemap.SetPtrToSubsetFontObj(subsetFont)\n\tunicodeindex := gp.addObj(unicodemap)\n\n\tpdfdic := new(PdfDictionaryObj)\n\tpdfdic.init(func() *GoPdf {\n\t\treturn gp\n\t})\n\tpdfdic.setProtection(gp.protection())\n\tpdfdic.SetPtrToSubsetFontObj(subsetFont)\n\tpdfdicindex := gp.addObj(pdfdic)\n\n\tsubfontdesc := new(SubfontDescriptorObj)\n\tsubfontdesc.init(func() *GoPdf {\n\t\treturn gp\n\t})\n\tsubfontdesc.SetPtrToSubsetFontObj(subsetFont)\n\tsubfontdesc.SetIndexObjPdfDictionary(pdfdicindex)\n\tsubfontdescindex := gp.addObj(subfontdesc)\n\n\tcidfont := new(CIDFontObj)\n\tcidfont.init(func() *GoPdf {\n\t\treturn gp\n\t})\n\tcidfont.SetPtrToSubsetFontObj(subsetFont)\n\tcidfont.SetIndexObjSubfontDescriptor(subfontdescindex)\n\tcidindex := gp.addObj(cidfont)\n\n\tsubsetFont.SetIndexObjCIDFont(cidindex)\n\tsubsetFont.SetIndexObjUnicodeMap(unicodeindex)\n\tindex := gp.addObj(subsetFont) //add หลังสุด\n\n\tif gp.indexOfProcSet != -1 {\n\t\tprocset := gp.pdfObjs[gp.indexOfProcSet].(*ProcSetObj)\n\t\tif !procset.Relates.IsContainsFamilyAndStyle(family, option.Style&^Underline) {\n\t\t\tprocset.Relates = append(procset.Relates, RelateFont{Family: family, IndexOfObj: index, CountOfFont: gp.curr.CountOfFont, Style: option.Style &^ Underline})\n\t\t\tsubsetFont.CountOfFont = gp.curr.CountOfFont\n\t\t\tgp.curr.CountOfFont++\n\t\t}\n\t}\n\treturn nil\n}\n\n// AddTTFFontWithOption : add font file\nfunc (gp *GoPdf) AddTTFFontWithOption(family string, ttfpath string, option TtfOption) error {\n\n\tif _, err := os.Stat(ttfpath); os.IsNotExist(err) {\n\t\treturn err\n\t}\n\tdata, err := os.ReadFile(ttfpath)\n\tif err != nil {\n\t\treturn err\n\t}\n\trd := bytes.NewReader(data)\n\treturn gp.AddTTFFontByReaderWithOption(family, rd, option)\n}\n\n// AddTTFFont : add font file\nfunc (gp *GoPdf) AddTTFFont(family string, ttfpath string) error {\n\treturn gp.AddTTFFontWithOption(family, ttfpath, defaultTtfFontOption())\n}\n\n// KernOverride override kern value\nfunc (gp *GoPdf) KernOverride(family string, fn FuncKernOverride) error {\n\ti := 0\n\tmax := len(gp.pdfObjs)\n\tfor i < max {\n\t\tif gp.pdfObjs[i].getType() == subsetFont {\n\t\t\tobj := gp.pdfObjs[i]\n\t\t\tsub, ok := obj.(*SubsetFontObj)\n\t\t\tif ok {\n\t\t\t\tif sub.GetFamily() == family {\n\t\t\t\t\tsub.funcKernOverride = fn\n\t\t\t\t\treturn nil\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\ti++\n\t}\n\treturn ErrMissingFontFamily\n}\n\n// SetTextColor :  function sets the text color\nfunc (gp *GoPdf) SetTextColor(r uint8, g uint8, b uint8) {\n\tgp.curr.txtColorMode = \"color\"\n\trgb := cacheContentTextColorRGB{\n\t\tr: r,\n\t\tg: g,\n\t\tb: b,\n\t}\n\tgp.curr.setTextColor(rgb)\n}\n\nfunc (gp *GoPdf) SetTextColorCMYK(c, m, y, k uint8) {\n\tgp.curr.txtColorMode = \"color\"\n\tcmyk := cacheContentTextColorCMYK{\n\t\tc: c,\n\t\tm: m,\n\t\ty: y,\n\t\tk: k,\n\t}\n\tgp.curr.setTextColor(cmyk)\n}\n\n// SetStrokeColor set the color for the stroke\nfunc (gp *GoPdf) SetStrokeColor(r uint8, g uint8, b uint8) {\n\tgp.getContent().AppendStreamSetColorStroke(r, g, b)\n}\n\n// SetFillColor set the color for the stroke\nfunc (gp *GoPdf) SetFillColor(r uint8, g uint8, b uint8) {\n\tgp.getContent().AppendStreamSetColorFill(r, g, b)\n}\n\n// SetStrokeColorCMYK set the color for the stroke in CMYK color mode\nfunc (gp *GoPdf) SetStrokeColorCMYK(c, m, y, k uint8) {\n\tgp.getContent().AppendStreamSetColorStrokeCMYK(c, m, y, k)\n}\n\n// SetFillColorCMYK set the color for the fill in CMYK color mode\nfunc (gp *GoPdf) SetFillColorCMYK(c, m, y, k uint8) {\n\tgp.getContent().AppendStreamSetColorFillCMYK(c, m, y, k)\n}\n\n// MeasureTextWidth : measure Width of text (use current font)\nfunc (gp *GoPdf) MeasureTextWidth(text string) (float64, error) {\n\n\ttext, err := gp.curr.FontISubset.AddChars(text) //AddChars for create CharacterToGlyphIndex\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\n\t_, _, textWidthPdfUnit, err := createContent(gp.curr.FontISubset, text, gp.curr.FontSize, gp.curr.CharSpacing, nil)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\treturn pointsToUnits(gp.config, textWidthPdfUnit), nil\n}\n\n// MeasureCellHeightByText : measure Height of cell by text (use current font)\nfunc (gp *GoPdf) MeasureCellHeightByText(text string) (float64, error) {\n\n\ttext, err := gp.curr.FontISubset.AddChars(text) //AddChars for create CharacterToGlyphIndex\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\n\t_, cellHeightPdfUnit, _, err := createContent(gp.curr.FontISubset, text, gp.curr.FontSize, gp.curr.CharSpacing, nil)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\treturn pointsToUnits(gp.config, cellHeightPdfUnit), nil\n}\n\n// Curve Draws a Bézier curve (the Bézier curve is tangent to the line between the control points at either end of the curve)\n// Parameters:\n// - x0, y0: Start point\n// - x1, y1: Control point 1\n// - x2, y2: Control point 2\n// - x3, y3: End point\n// - style: Style of rectangule (draw and/or fill: D, F, DF, FD)\nfunc (gp *GoPdf) Curve(x0 float64, y0 float64, x1 float64, y1 float64, x2 float64, y2 float64, x3 float64, y3 float64, style string) {\n\tgp.UnitsToPointsVar(&x0, &y0, &x1, &y1, &x2, &y2, &x3, &y3)\n\tgp.getContent().AppendStreamCurve(x0, y0, x1, y1, x2, y2, x3, y3, style)\n}\n\n/*\n//SetProtection set permissions as well as user and owner passwords\nfunc (gp *GoPdf) SetProtection(permissions int, userPass []byte, ownerPass []byte) {\n\tgp.pdfProtection = new(PDFProtection)\n\tgp.pdfProtection.setProtection(permissions, userPass, ownerPass)\n}*/\n\n// SetInfo set Document Information Dictionary\nfunc (gp *GoPdf) SetInfo(info PdfInfo) {\n\tgp.info = &info\n\tgp.isUseInfo = true\n}\n\n// GetInfo get Document Information Dictionary\nfunc (gp *GoPdf) GetInfo() PdfInfo {\n\treturn *gp.info\n}\n\n// Rotate rotate text or image\n// angle is angle in degrees.\n// x, y is rotation center\nfunc (gp *GoPdf) Rotate(angle, x, y float64) {\n\tgp.UnitsToPointsVar(&x, &y)\n\tgp.getContent().appendRotate(angle, x, y)\n}\n\n// RotateReset reset rotate\nfunc (gp *GoPdf) RotateReset() {\n\tgp.getContent().appendRotateReset()\n}\n\n// Polygon : draw polygon\n//   - style: Style of polygon (draw and/or fill: D, F, DF, FD)\n//     D or empty string: draw. This is the default value.\n//     F: fill\n//     DF or FD: draw and fill\n//\n// Usage:\n//\n//\t pdf.SetStrokeColor(255, 0, 0)\n//\t\tpdf.SetLineWidth(2)\n//\t\tpdf.SetFillColor(0, 255, 0)\n//\t\tpdf.Polygon([]gopdf.Point{{X: 10, Y: 30}, {X: 585, Y: 200}, {X: 585, Y: 250}}, \"DF\")\nfunc (gp *GoPdf) Polygon(points []Point, style string) {\n\n\ttransparency, err := gp.getCachedTransparency(nil)\n\tif err != nil {\n\t\ttransparency = nil\n\t}\n\n\tvar opts = polygonOptions{}\n\tif transparency != nil {\n\t\topts.extGStateIndexes = append(opts.extGStateIndexes, transparency.extGStateIndex)\n\t}\n\n\tvar pointReals []Point\n\tfor _, p := range points {\n\t\tx := p.X\n\t\ty := p.Y\n\t\tgp.UnitsToPointsVar(&x, &y)\n\t\tpointReals = append(pointReals, Point{X: x, Y: y})\n\t}\n\tgp.getContent().AppendStreamPolygon(pointReals, style, opts)\n}\n\n// Rectangle : draw rectangle, and add radius input to make a round corner, it helps to calculate the round corner coordinates and use Polygon functions to draw rectangle\n//   - style: Style of Rectangle (draw and/or fill: D, F, DF, FD)\n//     D or empty string: draw. This is the default value.\n//     F: fill\n//     DF or FD: draw and fill\n//\n// Usage:\n//\n//\t pdf.SetStrokeColor(255, 0, 0)\n//\t\tpdf.SetLineWidth(2)\n//\t\tpdf.SetFillColor(0, 255, 0)\n//\t\tpdf.Rectangle(196.6, 336.8, 398.3, 379.3, \"DF\", 3, 10)\nfunc (gp *GoPdf) Rectangle(x0 float64, y0 float64, x1 float64, y1 float64, style string, radius float64, radiusPointNum int) error {\n\tif x1 <= x0 || y1 <= y0 {\n\t\treturn ErrInvalidRectangleCoordinates\n\t}\n\tif radiusPointNum <= 0 || radius <= 0 {\n\t\t//draw rectangle without round corner\n\t\tpoints := []Point{}\n\t\tpoints = append(points, Point{X: x0, Y: y0})\n\t\tpoints = append(points, Point{X: x1, Y: y0})\n\t\tpoints = append(points, Point{X: x1, Y: y1})\n\t\tpoints = append(points, Point{X: x0, Y: y1})\n\t\tgp.Polygon(points, style)\n\n\t} else {\n\n\t\tif radius > (x1-x0) || radius > (y1-y0) {\n\t\t\treturn ErrInvalidRectangleCoordinates\n\t\t}\n\n\t\tdegrees := []float64{}\n\t\tangle := float64(90) / float64(radiusPointNum+1)\n\t\taccAngle := angle\n\t\tfor accAngle < float64(90) {\n\t\t\tdegrees = append(degrees, accAngle)\n\t\t\taccAngle += angle\n\t\t}\n\n\t\tradians := []float64{}\n\t\tfor _, v := range degrees {\n\t\t\tradians = append(radians, v*math.Pi/180)\n\t\t}\n\n\t\tpoints := []Point{}\n\t\tpoints = append(points, Point{X: x0, Y: (y0 + radius)})\n\t\tfor _, v := range radians {\n\t\t\toffsetX := radius * math.Cos(v)\n\t\t\toffsetY := radius * math.Sin(v)\n\t\t\tx := x0 + radius - offsetX\n\t\t\ty := y0 + radius - offsetY\n\t\t\tpoints = append(points, Point{X: x, Y: y})\n\t\t}\n\t\tpoints = append(points, Point{X: (x0 + radius), Y: y0})\n\n\t\tpoints = append(points, Point{X: (x1 - radius), Y: y0})\n\t\tfor i := range radians {\n\t\t\tv := radians[len(radians)-1-i]\n\t\t\toffsetX := radius * math.Cos(v)\n\t\t\toffsetY := radius * math.Sin(v)\n\t\t\tx := x1 - radius + offsetX\n\t\t\ty := y0 + radius - offsetY\n\t\t\tpoints = append(points, Point{X: x, Y: y})\n\t\t}\n\t\tpoints = append(points, Point{X: x1, Y: (y0 + radius)})\n\n\t\tpoints = append(points, Point{X: x1, Y: (y1 - radius)})\n\t\tfor _, v := range radians {\n\t\t\toffsetX := radius * math.Cos(v)\n\t\t\toffsetY := radius * math.Sin(v)\n\t\t\tx := x1 - radius + offsetX\n\t\t\ty := y1 - radius + offsetY\n\t\t\tpoints = append(points, Point{X: x, Y: y})\n\t\t}\n\t\tpoints = append(points, Point{X: (x1 - radius), Y: y1})\n\n\t\tpoints = append(points, Point{X: (x0 + radius), Y: y1})\n\t\tfor i := range radians {\n\t\t\tv := radians[len(radians)-1-i]\n\t\t\toffsetX := radius * math.Cos(v)\n\t\t\toffsetY := radius * math.Sin(v)\n\t\t\tx := x0 + radius - offsetX\n\t\t\ty := y1 - radius + offsetY\n\t\t\tpoints = append(points, Point{X: x, Y: y})\n\t\t}\n\t\tpoints = append(points, Point{X: x0, Y: y1 - radius})\n\n\t\tgp.Polygon(points, style)\n\t}\n\treturn nil\n}\n\n/*---private---*/\n\n// init\nfunc (gp *GoPdf) init(importer ...*gofpdi.Importer) {\n\tgp.pdfObjs = []IObj{}\n\tgp.buf = bytes.Buffer{}\n\tgp.indexEncodingObjFonts = []int{}\n\tgp.pdfProtection = nil\n\tgp.encryptionObjID = 0\n\tgp.isUseInfo = false\n\tgp.info = nil\n\n\t//default\n\tgp.margins = Margins{\n\t\tLeft:   defaultMargin,\n\t\tTop:    defaultMargin,\n\t\tRight:  defaultMargin,\n\t\tBottom: defaultMargin,\n\t}\n\n\t//init curr\n\tgp.resetCurrXY()\n\tgp.curr = Current{}\n\tgp.curr.IndexOfPageObj = -1\n\tgp.curr.CountOfFont = 0\n\tgp.curr.CountOfL = 0\n\tgp.curr.CountOfImg = 0                       //img\n\tgp.curr.ImgCaches = make(map[int]ImageCache) //= *new([]ImageCache)\n\tgp.curr.sMasksMap = NewSMaskMap()\n\tgp.curr.extGStatesMap = NewExtGStatesMap()\n\tgp.curr.transparencyMap = NewTransparencyMap()\n\tgp.anchors = make(map[string]anchorOption)\n\tgp.curr.txtColorMode = \"gray\"\n\n\t//init index\n\tgp.indexOfPagesObj = -1\n\tgp.indexOfFirstPageObj = -1\n\tgp.indexOfContent = -1\n\n\t//No underline\n\t//gp.IsUnderline = false\n\tgp.curr.lineWidth = 1\n\n\t// default to zlib.DefaultCompression\n\tgp.compressLevel = zlib.DefaultCompression\n\n\t// change the unit type\n\tgp.config.PageSize = *gp.config.PageSize.unitsToPoints(gp.config)\n\tgp.config.TrimBox = *gp.config.TrimBox.unitsToPoints(gp.config)\n\n\t// init gofpdi free pdf document importer\n\tgp.fpdi = importerOrDefault(importer...)\n\n}\n\nfunc importerOrDefault(importer ...*gofpdi.Importer) *gofpdi.Importer {\n\tif len(importer) != 0 {\n\t\treturn importer[len(importer)-1]\n\t}\n\treturn gofpdi.NewImporter()\n}\n\nfunc (gp *GoPdf) resetCurrXY() {\n\tgp.curr.X = gp.margins.Left\n\tgp.curr.Y = gp.margins.Top\n}\n\n// UnitsToPoints converts the units to the documents unit type\nfunc (gp *GoPdf) UnitsToPoints(u float64) float64 {\n\treturn unitsToPoints(gp.config, u)\n}\n\n// UnitsToPointsVar converts the units to the documents unit type for all variables passed in\nfunc (gp *GoPdf) UnitsToPointsVar(u ...*float64) {\n\tunitsToPointsVar(gp.config, u...)\n}\n\n// PointsToUnits converts the points to the documents unit type\nfunc (gp *GoPdf) PointsToUnits(u float64) float64 {\n\treturn pointsToUnits(gp.config, u)\n}\n\n// PointsToUnitsVar converts the points to the documents unit type for all variables passed in\nfunc (gp *GoPdf) PointsToUnitsVar(u ...*float64) {\n\tpointsToUnitsVar(gp.config, u...)\n}\n\nfunc (gp *GoPdf) isUseProtection() bool {\n\treturn gp.config.Protection.UseProtection\n}\n\nfunc (gp *GoPdf) createProtection() *PDFProtection {\n\tvar prot PDFProtection\n\tprot.setProtection(\n\t\tgp.config.Protection.Permissions,\n\t\tgp.config.Protection.UserPass,\n\t\tgp.config.Protection.OwnerPass,\n\t)\n\treturn &prot\n}\n\nfunc (gp *GoPdf) protection() *PDFProtection {\n\treturn gp.pdfProtection\n}\n\nfunc (gp *GoPdf) prepare() {\n\n\tif gp.isUseProtection() {\n\t\tencObj := gp.pdfProtection.encryptionObj()\n\t\tgp.addObj(encObj)\n\t}\n\n\tif gp.outlines.Count() > 0 {\n\t\tcatalogObj := gp.pdfObjs[gp.indexOfCatalogObj].(*CatalogObj)\n\t\tcatalogObj.SetIndexObjOutlines(gp.indexOfOutlinesObj)\n\t}\n\n\tif gp.indexOfPagesObj != -1 {\n\t\tindexCurrPage := -1\n\t\tpagesObj := gp.pdfObjs[gp.indexOfPagesObj].(*PagesObj)\n\t\ti := 0 //gp.indexOfFirstPageObj\n\t\tmax := len(gp.pdfObjs)\n\t\tfor i < max {\n\t\t\tobjtype := gp.pdfObjs[i].getType()\n\t\t\tswitch objtype {\n\t\t\tcase \"Page\":\n\t\t\t\tpagesObj.Kids = fmt.Sprintf(\"%s %d 0 R \", pagesObj.Kids, i+1)\n\t\t\t\tpagesObj.PageCount++\n\t\t\t\tindexCurrPage = i\n\t\t\tcase \"Content\":\n\t\t\t\tif indexCurrPage != -1 {\n\t\t\t\t\tgp.pdfObjs[indexCurrPage].(*PageObj).Contents = fmt.Sprintf(\"%s %d 0 R \", gp.pdfObjs[indexCurrPage].(*PageObj).Contents, i+1)\n\t\t\t\t}\n\t\t\tcase \"Font\":\n\t\t\t\ttmpfont := gp.pdfObjs[i].(*FontObj)\n\t\t\t\tj := 0\n\t\t\t\tjmax := len(gp.indexEncodingObjFonts)\n\t\t\t\tfor j < jmax {\n\t\t\t\t\ttmpencoding := gp.pdfObjs[gp.indexEncodingObjFonts[j]].(*EncodingObj).GetFont()\n\t\t\t\t\tif tmpfont.Family == tmpencoding.GetFamily() { //ใส่ ข้อมูลของ embed font\n\t\t\t\t\t\ttmpfont.IsEmbedFont = true\n\t\t\t\t\t\ttmpfont.SetIndexObjEncoding(gp.indexEncodingObjFonts[j] + 1)\n\t\t\t\t\t\ttmpfont.SetIndexObjWidth(gp.indexEncodingObjFonts[j] + 2)\n\t\t\t\t\t\ttmpfont.SetIndexObjFontDescriptor(gp.indexEncodingObjFonts[j] + 3)\n\t\t\t\t\t\tbreak\n\t\t\t\t\t}\n\t\t\t\t\tj++\n\t\t\t\t}\n\t\t\tcase \"Encryption\":\n\t\t\t\tgp.encryptionObjID = i + 1\n\t\t\t}\n\t\t\ti++\n\t\t}\n\t}\n}\n\nfunc (gp *GoPdf) xref(w io.Writer, xrefbyteoffset int64, linelens []int64, i int) error {\n\n\tio.WriteString(w, \"xref\\n\")\n\tfmt.Fprintf(w, \"0 %d\\n\", i+1)\n\tio.WriteString(w, \"0000000000 65535 f \\n\")\n\tj := 0\n\tmax := len(linelens)\n\tfor j < max {\n\t\tlinelen := linelens[j]\n\t\tfmt.Fprintf(w, \"%s 00000 n \\n\", gp.formatXrefline(linelen))\n\t\tj++\n\t}\n\tio.WriteString(w, \"trailer\\n\")\n\tio.WriteString(w, \"<<\\n\")\n\tfmt.Fprintf(w, \"/Size %d\\n\", max+1)\n\tio.WriteString(w, \"/Root 1 0 R\\n\")\n\tif gp.isUseProtection() {\n\t\tfmt.Fprintf(w, \"/Encrypt %d 0 R\\n\", gp.encryptionObjID)\n\t\tio.WriteString(w, \"/ID [()()]\\n\")\n\t}\n\tif gp.isUseInfo {\n\t\tgp.writeInfo(w)\n\t}\n\tio.WriteString(w, \">>\\n\")\n\tio.WriteString(w, \"startxref\\n\")\n\tfmt.Fprintf(w, \"%d\", xrefbyteoffset)\n\tio.WriteString(w, \"\\n%%EOF\\n\")\n\n\treturn nil\n}\n\nfunc (gp *GoPdf) writeInfo(w io.Writer) {\n\tvar zerotime time.Time\n\tio.WriteString(w, \"/Info <<\\n\")\n\n\tif gp.info.Author != \"\" {\n\t\tfmt.Fprintf(w, \"/Author <FEFF%s>\\n\", encodeUtf8(gp.info.Author))\n\t}\n\n\tif gp.info.Title != \"\" {\n\t\tfmt.Fprintf(w, \"/Title <FEFF%s>\\n\", encodeUtf8(gp.info.Title))\n\t}\n\n\tif gp.info.Subject != \"\" {\n\t\tfmt.Fprintf(w, \"/Subject <FEFF%s>\\n\", encodeUtf8(gp.info.Subject))\n\t}\n\n\tif gp.info.Creator != \"\" {\n\t\tfmt.Fprintf(w, \"/Creator <FEFF%s>\\n\", encodeUtf8(gp.info.Creator))\n\t}\n\n\tif gp.info.Producer != \"\" {\n\t\tfmt.Fprintf(w, \"/Producer <FEFF%s>\\n\", encodeUtf8(gp.info.Producer))\n\t}\n\n\tif !zerotime.Equal(gp.info.CreationDate) {\n\t\tfmt.Fprintf(w, \"/CreationDate(D:%s)\\n\", infodate(gp.info.CreationDate))\n\t}\n\n\tio.WriteString(w, \" >>\\n\")\n}\n\n// ปรับ xref ให้เป็น 10 หลัก\nfunc (gp *GoPdf) formatXrefline(n int64) string {\n\tstr := strconv.FormatInt(n, 10)\n\tfor len(str) < 10 {\n\t\tstr = \"0\" + str\n\t}\n\treturn str\n}\n\nfunc (gp *GoPdf) addObj(iobj IObj) int {\n\tindex := len(gp.pdfObjs)\n\tgp.pdfObjs = append(gp.pdfObjs, iobj)\n\treturn index\n}\n\nfunc (gp *GoPdf) getContent() *ContentObj {\n\tvar content *ContentObj\n\tif gp.indexOfContent <= -1 {\n\t\tcontent = new(ContentObj)\n\t\tcontent.init(func() *GoPdf {\n\t\t\treturn gp\n\t\t})\n\t\tgp.indexOfContent = gp.addObj(content)\n\t} else {\n\t\tcontent = gp.pdfObjs[gp.indexOfContent].(*ContentObj)\n\t}\n\treturn content\n}\n\nfunc encodeUtf8(str string) string {\n\tvar buff bytes.Buffer\n\tfor _, r := range str {\n\t\tc := fmt.Sprintf(\"%X\", r)\n\t\tfor len(c) < 4 {\n\t\t\tc = \"0\" + c\n\t\t}\n\t\tbuff.WriteString(c)\n\t}\n\treturn buff.String()\n}\n\nfunc infodate(t time.Time) string {\n\tft := t.Format(\"20060102150405-07'00'\")\n\treturn ft\n}\n\n// SetTransparency sets transparency.\n// alpha: \t\tvalue from 0 (transparent) to 1 (opaque)\n// blendMode:   blend mode, one of the following:\n//\n//\tNormal, Multiply, Screen, Overlay, Darken, Lighten, ColorDodge, ColorBurn,\n//\tHardLight, SoftLight, Difference, Exclusion, Hue, Saturation, Color, Luminosity\nfunc (gp *GoPdf) SetTransparency(transparency Transparency) error {\n\tt, err := gp.saveTransparency(&transparency)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tgp.curr.transparency = t\n\n\treturn nil\n}\n\nfunc (gp *GoPdf) ClearTransparency() {\n\tgp.curr.transparency = nil\n}\n\nfunc (gp *GoPdf) getCachedTransparency(transparency *Transparency) (*Transparency, error) {\n\tif transparency == nil {\n\t\ttransparency = gp.curr.transparency\n\t} else {\n\t\tcached, err := gp.saveTransparency(transparency)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\ttransparency = cached\n\t}\n\n\treturn transparency, nil\n}\n\nfunc (gp *GoPdf) saveTransparency(transparency *Transparency) (*Transparency, error) {\n\tcached, ok := gp.curr.transparencyMap.Find(*transparency)\n\tif ok {\n\t\treturn &cached, nil\n\t} else if transparency.Alpha != DefaultAplhaValue {\n\t\tbm := transparency.BlendModeType\n\t\topts := ExtGStateOptions{\n\t\t\tBlendMode:     &bm,\n\t\t\tStrokingCA:    &transparency.Alpha,\n\t\t\tNonStrokingCa: &transparency.Alpha,\n\t\t}\n\n\t\textGState, err := GetCachedExtGState(opts, gp)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\ttransparency.extGStateIndex = extGState.Index + 1\n\n\t\tgp.curr.transparencyMap.Save(*transparency)\n\n\t\treturn transparency, nil\n\t}\n\n\treturn nil, nil\n}\n\n// IsCurrFontContainGlyph defines is current font contains to a glyph\n// r:           any rune\nfunc (gp *GoPdf) IsCurrFontContainGlyph(r rune) (bool, error) {\n\tfontISubset := gp.curr.FontISubset\n\tif fontISubset == nil {\n\t\treturn false, nil\n\t}\n\n\tglyphIndex, err := fontISubset.CharCodeToGlyphIndex(r)\n\tif err == ErrGlyphNotFound {\n\t\treturn false, nil\n\t} else if err != nil {\n\t\treturn false, err\n\t}\n\n\tif glyphIndex == 0 {\n\t\treturn false, nil\n\t}\n\n\treturn true, nil\n}\n\n// SetPage set current page\nfunc (gp *GoPdf) SetPage(pageno int) error {\n\tvar pageIndex int\n\tfor i := 0; i < len(gp.pdfObjs); i++ {\n\t\tswitch gp.pdfObjs[i].(type) {\n\t\tcase *ContentObj:\n\t\t\tpageIndex += 1\n\t\t\tif pageIndex == pageno {\n\t\t\t\tgp.indexOfContent = i\n\t\t\t\treturn nil\n\t\t\t}\n\t\t}\n\t}\n\n\treturn errors.New(\"invalid page number\")\n}\n\n//tool for validate pdf https://www.pdf-online.com/osa/validate.aspx\n"
        },
        {
          "name": "gopdf_test.go",
          "type": "blob",
          "size": 17.908203125,
          "content": "package gopdf\n\nimport (\n\t\"bytes\"\n\t\"errors\"\n\t\"io\"\n\t\"log\"\n\t\"os\"\n\t\"testing\"\n)\n\nfunc BenchmarkPdfWithImageHolder(b *testing.B) {\n\n\terr := initTesting()\n\tif err != nil {\n\t\tb.Error(err)\n\t\treturn\n\t}\n\n\tpdf := GoPdf{}\n\tpdf.Start(Config{PageSize: *PageSizeA4})\n\tpdf.AddPage()\n\terr = pdf.AddTTFFont(\"LiberationSerif-Regular\", \"./test/res/LiberationSerif-Regular.ttf\")\n\tif err != nil {\n\t\tb.Error(err)\n\t\treturn\n\t}\n\n\terr = pdf.SetFont(\"LiberationSerif-Regular\", \"\", 14)\n\tif err != nil {\n\t\tlog.Print(err.Error())\n\t\treturn\n\t}\n\n\tbytesOfImg, err := os.ReadFile(\"./test/res/chilli.jpg\")\n\tif err != nil {\n\t\tb.Error(err)\n\t\treturn\n\t}\n\n\timgH, err := ImageHolderByBytes(bytesOfImg)\n\tif err != nil {\n\t\tb.Error(err)\n\t\treturn\n\t}\n\tfor i := 0; i < b.N; i++ {\n\t\tpdf.ImageByHolder(imgH, 20.0, float64(i)*2.0, nil)\n\t}\n\n\tpdf.SetXY(250, 200)\n\tpdf.Cell(nil, \"gopher and gopher\")\n\n\tpdf.WritePdf(\"./test/out/image_bench.pdf\")\n}\n\nfunc TestPdfWithImageHolder(t *testing.T) {\n\terr := initTesting()\n\tif err != nil {\n\t\tt.Error(err)\n\t\treturn\n\t}\n\n\tpdf := setupDefaultA4PDF(t)\n\tpdf.AddPage()\n\n\tbytesOfImg, err := os.ReadFile(\"./test/res/PNG_transparency_demonstration_1.png\")\n\tif err != nil {\n\t\tt.Error(err)\n\t\treturn\n\t}\n\n\timgH, err := ImageHolderByBytes(bytesOfImg)\n\tif err != nil {\n\t\tt.Error(err)\n\t\treturn\n\t}\n\n\terr = pdf.ImageByHolder(imgH, 20.0, 20, nil)\n\tif err != nil {\n\t\tt.Error(err)\n\t\treturn\n\t}\n\n\terr = pdf.ImageByHolder(imgH, 20.0, 200, nil)\n\tif err != nil {\n\t\tt.Error(err)\n\t\treturn\n\t}\n\n\tpdf.SetXY(250, 200)\n\tpdf.Cell(nil, \"gopher and gopher\")\n\n\tpdf.WritePdf(\"./test/out/image_test.pdf\")\n}\n\nfunc TestPdfWithImageHolderGif(t *testing.T) {\n\terr := initTesting()\n\tif err != nil {\n\t\tt.Error(err)\n\t\treturn\n\t}\n\n\tpdf := setupDefaultA4PDF(t)\n\tpdf.AddPage()\n\n\tbytesOfImg, err := os.ReadFile(\"./test/res/gopher03.gif\")\n\tif err != nil {\n\t\tt.Error(err)\n\t\treturn\n\t}\n\n\timgH, err := ImageHolderByBytes(bytesOfImg)\n\tif err != nil {\n\t\tt.Error(err)\n\t\treturn\n\t}\n\n\terr = pdf.ImageByHolder(imgH, 20.0, 20, nil)\n\tif err != nil {\n\t\tt.Error(err)\n\t\treturn\n\t}\n\n\terr = pdf.ImageByHolder(imgH, 20.0, 200, nil)\n\tif err != nil {\n\t\tt.Error(err)\n\t\treturn\n\t}\n\n\tpdf.SetXY(250, 200)\n\tpdf.Cell(nil, \"gopher and gopher\")\n\n\tpdf.WritePdf(\"./test/out/image_test_gif.pdf\")\n}\n\nfunc TestRetrievingNumberOfPdfPage(t *testing.T) {\n\tpdf := setupDefaultA4PDF(t)\n\tif pdf.GetNumberOfPages() != 0 {\n\t\tt.Error(\"Invalid starting number of pages, should be 0\")\n\t\treturn\n\t}\n\tpdf.AddPage()\n\n\tbytesOfImg, err := os.ReadFile(\"./test/res/gopher01.jpg\")\n\tif err != nil {\n\t\tt.Error(err)\n\t\treturn\n\t}\n\n\timgH, err := ImageHolderByBytes(bytesOfImg)\n\tif err != nil {\n\t\tt.Error(err)\n\t\treturn\n\t}\n\n\terr = pdf.ImageByHolder(imgH, 20.0, 20, nil)\n\tif err != nil {\n\t\tt.Error(err)\n\t\treturn\n\t}\n\n\tif pdf.GetNumberOfPages() != 1 {\n\t\tt.Error(err)\n\t\treturn\n\t}\n\n\tpdf.SetXY(250, 200)\n\tpdf.Cell(nil, \"gopher and gopher\")\n\n\tpdf.AddPage()\n\n\tpdf.SetXY(250, 200)\n\tpdf.Cell(nil, \"gopher and gopher again\")\n\n\tif pdf.GetNumberOfPages() != 2 {\n\t\tt.Error(err)\n\t\treturn\n\t}\n\n\tpdf.WritePdf(\"./test/out/number_of_pages_test.pdf\")\n}\n\nfunc TestImageCrop(t *testing.T) {\n\tpdf := setupDefaultA4PDF(t)\n\tif pdf.GetNumberOfPages() != 0 {\n\t\tt.Error(\"Invalid starting number of pages, should be 0\")\n\t\treturn\n\t}\n\n\tpdf.AddPage()\n\n\tbytesOfImg, err := os.ReadFile(\"./test/res/gopher01.jpg\")\n\tif err != nil {\n\t\tt.Error(err)\n\t\treturn\n\t}\n\n\timgH, err := ImageHolderByBytes(bytesOfImg)\n\tif err != nil {\n\t\tt.Error(err)\n\t\treturn\n\t}\n\n\t//err = pdf.ImageByHolder(imgH, 20.0, 20, nil)\n\terr = pdf.ImageByHolderWithOptions(imgH, ImageOptions{\n\t\t//VerticalFlip: true,\n\t\t//HorizontalFlip: true,\n\t\tRect: &Rect{\n\t\t\tW: 100,\n\t\t\tH: 100,\n\t\t},\n\t\tCrop: &CropOptions{\n\t\t\tX:      0,\n\t\t\tY:      0,\n\t\t\tWidth:  10,\n\t\t\tHeight: 100,\n\t\t},\n\t})\n\tif err != nil {\n\t\tt.Error(err)\n\t\treturn\n\t}\n\n\tif pdf.GetNumberOfPages() != 1 {\n\t\tt.Error(err)\n\t\treturn\n\t}\n\n\tpdf.SetXY(250, 200)\n\tpdf.Cell(nil, \"gopher and gopher\")\n\n\tpdf.AddPage()\n\n\tpdf.SetXY(250, 200)\n\tpdf.Cell(nil, \"gopher and gopher again\")\n\n\tif pdf.GetNumberOfPages() != 2 {\n\t\tt.Error(err)\n\t\treturn\n\t}\n\n\tpdf.WritePdf(\"./test/out/image_crop.pdf\")\n}\n\nfunc BenchmarkAddTTFFontByReader(b *testing.B) {\n\tttf, err := os.Open(\"test/res/LiberationSerif-Regular.ttf\")\n\tif err != nil {\n\t\tb.Error(err)\n\t\treturn\n\t}\n\tdefer ttf.Close()\n\n\tfontData, err := io.ReadAll(ttf)\n\tif err != nil {\n\t\tb.Error(err)\n\t\treturn\n\t}\n\n\tfor n := 0; n < b.N; n++ {\n\t\tpdf := &GoPdf{}\n\t\tpdf.Start(Config{PageSize: *PageSizeA4})\n\t\tif err := pdf.AddTTFFontByReader(\"LiberationSerif-Regular\", bytes.NewReader(fontData)); err != nil {\n\t\t\treturn\n\t\t}\n\t}\n}\n\n/*\nfunc TestBuffer(t *testing.T) {\n\tb := bytes.NewReader([]byte(\"ssssssss\"))\n\n\tb1, err := ioutil.ReadAll(b)\n\tif err != nil {\n\t\tt.Error(err)\n\t\treturn\n\t}\n\tfmt.Printf(\"->%s\\n\", string(b1))\n\tb.Seek(0, 0)\n\tb2, err := ioutil.ReadAll(b)\n\tif err != nil {\n\t\tt.Error(err)\n\t\treturn\n\t}\n\n\tfmt.Printf(\"+>%s\\n\", string(b2))\n}*/\n\nfunc BenchmarkAddTTFFontData(b *testing.B) {\n\tttf, err := os.Open(\"test/res/LiberationSerif-Regular.ttf\")\n\tif err != nil {\n\t\tb.Error(err)\n\t\treturn\n\t}\n\tdefer ttf.Close()\n\n\tfontData, err := io.ReadAll(ttf)\n\tif err != nil {\n\t\tb.Error(err)\n\t\treturn\n\t}\n\n\tfor n := 0; n < b.N; n++ {\n\t\tpdf := &GoPdf{}\n\t\tpdf.Start(Config{PageSize: *PageSizeA4})\n\t\tif err := pdf.AddTTFFontData(\"LiberationSerif-Regular\", fontData); err != nil {\n\t\t\treturn\n\t\t}\n\t}\n}\n\nfunc TestReuseFontData(t *testing.T) {\n\tttf, err := os.Open(\"test/res/LiberationSerif-Regular.ttf\")\n\tif err != nil {\n\t\tt.Error(err)\n\t\treturn\n\t}\n\tdefer ttf.Close()\n\n\tfontData, err := io.ReadAll(ttf)\n\tif err != nil {\n\t\tt.Error(err)\n\t\treturn\n\t}\n\n\tpdf1 := &GoPdf{}\n\trst1, err := generatePDFBytesByAddTTFFontData(pdf1, fontData)\n\tif err != nil {\n\t\tt.Error(err)\n\t\treturn\n\t}\n\n\t// Reuse the parsed font data.\n\tpdf2 := &GoPdf{}\n\trst2, err := generatePDFBytesByAddTTFFontData(pdf2, fontData)\n\tif err != nil {\n\t\tt.Error(err)\n\t\treturn\n\t}\n\n\tif bytes.Compare(rst1, rst2) != 0 {\n\t\tt.Error(errors.New(\"The generated files must be exactly the same.\"))\n\t\treturn\n\t}\n\n\tif err := writeFile(\"./test/out/result1_by_parsed_ttf_font.pdf\", rst1, 0644); err != nil {\n\t\tt.Error(err)\n\t\treturn\n\t}\n\tif err := writeFile(\"./test/out/result2_by_parsed_ttf_font.pdf\", rst1, 0644); err != nil {\n\t\tt.Error(err)\n\t\treturn\n\t}\n}\n\nfunc writeFile(name string, data []byte, perm os.FileMode) error {\n\tf, err := os.OpenFile(name, os.O_WRONLY|os.O_CREATE|os.O_TRUNC, perm)\n\tif err != nil {\n\t\treturn err\n\t}\n\t_, err = f.Write(data)\n\tif err1 := f.Close(); err1 != nil && err == nil {\n\t\terr = err1\n\t}\n\treturn err\n}\n\nfunc generatePDFBytesByAddTTFFontData(pdf *GoPdf, fontData []byte) ([]byte, error) {\n\tpdf.Start(Config{PageSize: *PageSizeA4})\n\tif pdf.GetNumberOfPages() != 0 {\n\t\treturn nil, errors.New(\"Invalid starting number of pages, should be 0\")\n\t}\n\n\tif err := pdf.AddTTFFontData(\"LiberationSerif-Regular\", fontData); err != nil {\n\t\treturn nil, err\n\t}\n\n\tif err := pdf.SetFont(\"LiberationSerif-Regular\", \"\", 14); err != nil {\n\t\treturn nil, err\n\t}\n\n\tpdf.AddPage()\n\tif err := pdf.Text(\"Test PDF content.\"); err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn pdf.GetBytesPdfReturnErr()\n}\n\nfunc TestWhiteTransparent(t *testing.T) {\n\terr := initTesting()\n\tif err != nil {\n\t\tt.Error(err)\n\t\treturn\n\t}\n\t// create pdf.\n\tpdf := GoPdf{}\n\tpdf.Start(Config{PageSize: *PageSizeA4})\n\tpdf.AddPage()\n\n\tvar glyphNotFoundOfLiberationSerif []rune\n\terr = pdf.AddTTFFontWithOption(\"LiberationSerif-Regular\", \"test/res/LiberationSerif-Regular.ttf\", TtfOption{\n\t\tOnGlyphNotFound: func(r rune) { //call when can not find glyph inside ttf file.\n\t\t\tglyphNotFoundOfLiberationSerif = append(glyphNotFoundOfLiberationSerif, r)\n\t\t\t//log.Printf(\"glyph not found %c\", r)\n\t\t},\n\t})\n\tif err != nil {\n\t\tt.Error(err)\n\t\treturn\n\t}\n\terr = pdf.SetFont(\"LiberationSerif-Regular\", \"\", 14)\n\tif err != nil {\n\t\tt.Error(err)\n\t\treturn\n\t}\n\t// write text.\n\top := CellOption{Align: Left | Middle}\n\trect := Rect{W: 20, H: 30}\n\tpdf.SetXY(350, 50)\n\terr = pdf.Cell(&rect, \"あい\")\n\t//err = pdf.CellWithOption(&rect, \"あい\", op)\n\t//err = pdf.CellWithOption(&rect, \"あ\", op)\n\t//err = pdf.CellWithOption(&rect, \"a\", op)\n\tif err != nil {\n\t\tt.Error(err)\n\t\treturn\n\t}\n\tpdf.SetY(100)\n\terr = pdf.CellWithOption(&rect, \"abcdef.\", op)\n\tif err != nil {\n\t\tt.Error(err)\n\t\treturn\n\t}\n\n\t//coz あ and い  not contain in \"test/res/LiberationSerif-Regular.ttf\"\n\tif len(glyphNotFoundOfLiberationSerif) != 2 {\n\t\tt.Error(err)\n\t\treturn\n\t}\n\n\t//pdf.SetNoCompression()\n\terr = pdf.WritePdf(\"./test/out/white_transparent.pdf\")\n\tif err != nil {\n\t\tt.Error(err)\n\t\treturn\n\t}\n\n}\n\nfunc TestRectangle(t *testing.T) {\n\terr := initTesting()\n\tif err != nil {\n\t\tt.Error(err)\n\t\treturn\n\t}\n\t// create pdf.\n\tpdf := GoPdf{}\n\tpdf.Start(Config{PageSize: *PageSizeA4})\n\tpdf.AddPage()\n\n\tpdf.SetStrokeColor(240, 98, 146)\n\tpdf.SetLineWidth(1)\n\tpdf.SetFillColor(255, 255, 255)\n\t// draw rectangle with round radius\n\terr = pdf.Rectangle(100.6, 150.8, 150.3, 379.3, \"DF\", 20, 10)\n\tif err != nil {\n\t\tt.Error(err)\n\t\treturn\n\t}\n\n\t// draw rectangle with round radius but less point number\n\terr = pdf.Rectangle(200.6, 150.8, 250.3, 379.3, \"DF\", 20, 2)\n\tif err != nil {\n\t\tt.Error(err)\n\t\treturn\n\t}\n\n\tpdf.SetStrokeColor(240, 98, 146)\n\tpdf.SetLineWidth(1)\n\tpdf.SetFillColor(255, 255, 255)\n\t// draw rectangle directly\n\terr = pdf.Rectangle(100.6, 50.8, 130, 150, \"DF\", 0, 0)\n\tif err != nil {\n\t\tt.Error(err)\n\t\treturn\n\t}\n\n\terr = pdf.WritePdf(\"./test/out/rectangle_with_round_corner.pdf\")\n\tif err != nil {\n\t\tt.Error(err)\n\t\treturn\n\t}\n}\n\nfunc TestWhiteTransparent195(t *testing.T) {\n\terr := initTesting()\n\tif err != nil {\n\t\tt.Error(err)\n\t\treturn\n\t}\n\t// create pdf.\n\tpdf := GoPdf{}\n\tpdf.Start(Config{PageSize: *PageSizeA4})\n\tpdf.AddPage()\n\n\tvar glyphNotFoundOfLiberationSerif []rune\n\t//err = pdf.AddTTFFontWithOption(\"LiberationSerif-Regular\", \"/Users/oneplus/Code/Work/gopdf_old/test/res/Meera-Regular.ttf\", TtfOption{\n\terr = pdf.AddTTFFontWithOption(\"LiberationSerif-Regular\", \"test/res/LiberationSerif-Regular.ttf\", TtfOption{\n\t\tOnGlyphNotFound: func(r rune) { //call when can not find glyph inside ttf file.\n\t\t\tglyphNotFoundOfLiberationSerif = append(glyphNotFoundOfLiberationSerif, r)\n\t\t},\n\t\tOnGlyphNotFoundSubstitute: func(r rune) rune {\n\t\t\t//return r\n\t\t\treturn rune('\\u20b0') //(U+25A1) = “□”\n\t\t},\n\t})\n\tif err != nil {\n\t\tt.Error(err)\n\t\treturn\n\t}\n\terr = pdf.SetFont(\"LiberationSerif-Regular\", \"\", 14)\n\tif err != nil {\n\t\tt.Error(err)\n\t\treturn\n\t}\n\t// write text.\n\top := CellOption{Align: Left | Middle}\n\trect := Rect{W: 20, H: 30}\n\tpdf.SetXY(350, 50)\n\t//err = pdf.Cell(&rect, \"あいうえ\") // OK.\n\t//err = pdf.Cell(&rect, \"あうう\") // OK.\n\terr = pdf.CellWithOption(&rect, \"あいうえ\", op) // NG. \"abcdef.\" is White/Transparent.\n\t//err = pdf.Cell(&rect, \" あいうえ\") // NG. \"abcdef.\" is White/Transparent.\n\t// err = pdf.Cell(&rect, \"あいうえ \") // NG. \"abcdef.\" is White/Transparent.\n\tif err != nil {\n\t\tt.Error(err)\n\t\treturn\n\t}\n\tpdf.SetY(100)\n\terr = pdf.CellWithOption(&rect, \"abcกdef.\", op)\n\tif err != nil {\n\t\tt.Error(err)\n\t\treturn\n\t}\n\n\t//coz あ い う え  not contain in \"test/res/LiberationSerif-Regular.ttf\"\n\t// if len(glyphNotFoundOfLiberationSerif) != 4 {\n\t// \tt.Error(err)\n\t// \treturn\n\t// }\n\n\tpdf.SetNoCompression()\n\terr = pdf.WritePdf(\"./test/out/white_transparent195.pdf\")\n\tif err != nil {\n\t\tt.Error(err)\n\t\treturn\n\t}\n}\n\nfunc TestClearValue(t *testing.T) {\n\terr := initTesting()\n\tif err != nil {\n\t\tt.Error(err)\n\t\treturn\n\t}\n\n\tpdf := GoPdf{}\n\tpdf.Start(Config{PageSize: *PageSizeA4, Protection: PDFProtectionConfig{\n\t\tUseProtection: true,\n\t\tOwnerPass:     []byte(\"123456\"),\n\t\tUserPass:      []byte(\"123456\"),\n\t}})\n\tpdf.AddPage()\n\terr = pdf.AddTTFFont(\"LiberationSerif-Regular\", \"./test/res/LiberationSerif-Regular.ttf\")\n\tif err != nil {\n\t\tt.Error(err)\n\t\treturn\n\t}\n\n\terr = pdf.SetFont(\"LiberationSerif-Regular\", \"\", 14)\n\tif err != nil {\n\t\tlog.Print(err.Error())\n\t\treturn\n\t}\n\n\tbytesOfImg, err := os.ReadFile(\"./test/res/PNG_transparency_demonstration_1.png\")\n\tif err != nil {\n\t\tt.Error(err)\n\t\treturn\n\t}\n\n\timgH, err := ImageHolderByBytes(bytesOfImg)\n\tif err != nil {\n\t\tt.Error(err)\n\t\treturn\n\t}\n\n\terr = pdf.ImageByHolder(imgH, 20.0, 20, nil)\n\tif err != nil {\n\t\tt.Error(err)\n\t\treturn\n\t}\n\n\tpdf.SetXY(250, 200)\n\tpdf.Cell(nil, \"gopher and gopher\")\n\tpdf.SetInfo(PdfInfo{\n\t\tTitle: \"xx\",\n\t})\n\tpdf.WritePdf(\"./test/out/test_clear_value.pdf\")\n\n\t//reset\n\tpdf.Start(Config{PageSize: *PageSizeA4})\n\n\tpdf2 := GoPdf{}\n\tpdf2.Start(Config{PageSize: *PageSizeA4})\n\n\t//check\n\tif pdf.margins != pdf2.margins {\n\t\tt.Fatal(\"pdf.margins != pdf2.margins\")\n\t}\n\n\tif len(pdf2.pdfObjs) != len(pdf.pdfObjs) {\n\t\tt.Fatalf(\"len(pdf2.pdfObjs) != len(pdf.pdfObjs)\")\n\t}\n\n\tif len(pdf.anchors) > 0 {\n\t\tt.Fatalf(\"len( pdf.anchors) = %d\", len(pdf.anchors))\n\t}\n\n\tif len(pdf.indexEncodingObjFonts) != len(pdf2.indexEncodingObjFonts) {\n\t\tt.Fatalf(\"len(pdf.indexEncodingObjFonts) != len(pdf2.indexEncodingObjFonts)\")\n\t}\n\n\tif pdf.indexOfContent != pdf2.indexOfContent {\n\t\tt.Fatalf(\"pdf.indexOfContent != pdf2.indexOfContent\")\n\t}\n\n\tif pdf.buf.Len() > 0 {\n\t\tt.Fatalf(\"pdf.buf.Len() > 0\")\n\t}\n\n\tif pdf.pdfProtection != nil {\n\t\tt.Fatalf(\"pdf.pdfProtection is not nil\")\n\t}\n\tif pdf.encryptionObjID != 0 {\n\t\tt.Fatalf(\"encryptionObjID %d\", pdf.encryptionObjID)\n\t}\n\n\tif pdf.info != nil {\n\t\tt.Fatalf(\"pdf.info %v\", pdf.info)\n\t}\n}\n\nfunc TestSplitTextWithOptions(t *testing.T) {\n\terr := initTesting()\n\tif err != nil {\n\t\tt.Error(err)\n\t\treturn\n\t}\n\n\tpdf := setupDefaultA4PDF(t)\n\n\tvar splitTextTests = []struct {\n\t\tname string\n\t\tin   string\n\t\topts *BreakOption\n\t\texp  []string\n\t}{\n\t\t{\n\t\t\t\"strict breaks no separator\",\n\t\t\t\"Lorem ipsum dolor sit amet, consetetur\",\n\t\t\t&DefaultBreakOption,\n\t\t\t[]string{\"Lorem ipsum dol\", \"or sit amet, conse\", \"tetur\"},\n\t\t},\n\t\t{\n\t\t\t\"no options given\",\n\t\t\t\"Lorem ipsum dolor sit amet, consetetur\",\n\t\t\tnil,\n\t\t\t[]string{\"Lorem ipsum dol\", \"or sit amet, conse\", \"tetur\"},\n\t\t},\n\t\t{\n\t\t\t\"strict breaks with separator\",\n\t\t\t\"Lorem ipsum dolor sit amet, consetetur\",\n\t\t\t&BreakOption{\n\t\t\t\tSeparator: \"-\",\n\t\t\t\tMode:      BreakModeStrict,\n\t\t\t},\n\t\t\t[]string{\"Lorem ipsum d-\", \"olor sit amet, c-\", \"onsetetur\"},\n\t\t},\n\t\t{\n\t\t\t\"text with possible word-wrap\",\n\t\t\t\"Lorem ipsum dolor sit amet, consetetur\",\n\t\t\t&BreakOption{\n\t\t\t\tBreakIndicator: ' ',\n\t\t\t\tMode:           BreakModeIndicatorSensitive,\n\t\t\t},\n\t\t\t[]string{\"Lorem ipsum\", \"dolor sit amet,\", \"consetetur\"},\n\t\t},\n\t\t{\n\t\t\t\"text without possible word-wrap\",\n\t\t\t\"Loremipsumdolorsitamet,consetetur\",\n\t\t\t&BreakOption{\n\t\t\t\tBreakIndicator: ' ',\n\t\t\t\tMode:           BreakModeIndicatorSensitive,\n\t\t\t},\n\t\t\t[]string{\"Loremipsumdolo\", \"rsitamet,consetet\", \"ur\"},\n\t\t},\n\t\t{\n\t\t\t\"text with only empty spaces\",\n\t\t\t\"                                                \",\n\t\t\t&BreakOption{\n\t\t\t\tBreakIndicator: ' ',\n\t\t\t\tMode:           BreakModeIndicatorSensitive,\n\t\t\t},\n\t\t\t[]string{\"                           \", \"                    \"},\n\t\t},\n\t}\n\n\tfor _, tt := range splitTextTests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tlines, err := pdf.SplitTextWithOption(tt.in, 100, tt.opts)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\t\t\tif len(lines) != len(tt.exp) {\n\t\t\t\tt.Fatalf(\"amount of expected and split lines invalid. Expected: %d, result: %d\", len(tt.exp), len(lines))\n\t\t\t}\n\t\t\tfor i, e := range tt.exp {\n\t\t\t\tif e != lines[i] {\n\t\t\t\t\tt.Fatalf(\"split text invalid. Expected: '%s', result: '%s'\", e, lines[i])\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestTextColor(t *testing.T) {\n\terr := initTesting()\n\tif err != nil {\n\t\tt.Error(err)\n\t\treturn\n\t}\n\n\t// create pdf.\n\tpdf := GoPdf{}\n\tpdf.Start(Config{PageSize: *PageSizeA4})\n\tpdf.AddPage()\n\terr = pdf.AddTTFFont(\"LiberationSerif\", \"./test/res/LiberationSerif-Regular.ttf\")\n\tif err != nil {\n\t\tt.Error(err)\n\t\treturn\n\t}\n\n\terr = pdf.SetFont(\"LiberationSerif\", \"\", 14)\n\tif err != nil {\n\t\tt.Error(err)\n\t\treturn\n\t}\n\n\tpdf.SetTextColor(255, 0, 2)\n\tpdf.Br(20)\n\tpdf.Cell(nil, \"a\")\n\n\tpdf.SetTextColorCMYK(0, 6, 14, 0)\n\tpdf.Br(20)\n\tpdf.Cell(nil, \"b\")\n\n\terr = pdf.WritePdf(\"./test/out/colored_text.pdf\")\n\tif err != nil {\n\t\tt.Error(err)\n\t\treturn\n\t}\n}\n\nfunc TestAddHeaderFooter(t *testing.T) {\n\terr := initTesting()\n\tif err != nil {\n\t\tt.Error(err)\n\t\treturn\n\t}\n\n\t// create pdf.\n\tpdf := GoPdf{}\n\tpdf.Start(Config{PageSize: *PageSizeA4})\n\n\terr = pdf.AddTTFFont(\"LiberationSerif-Regular\", \"./test/res/LiberationSerif-Regular.ttf\")\n\tif err != nil {\n\t\tt.Error(err)\n\t\treturn\n\t}\n\n\terr = pdf.SetFont(\"LiberationSerif-Regular\", \"\", 14)\n\tif err != nil {\n\t\tlog.Print(err.Error())\n\t\treturn\n\t}\n\n\tpdf.AddHeader(func() {\n\t\tpdf.SetY(5)\n\t\tpdf.Cell(nil, \"header\")\n\t})\n\tpdf.AddFooter(func() {\n\t\tpdf.SetY(825)\n\t\tpdf.Cell(nil, \"footer\")\n\t})\n\n\tpdf.AddPage()\n\tpdf.SetY(400)\n\tpdf.Text(\"page 1 content\")\n\tpdf.AddPage()\n\tpdf.SetY(400)\n\tpdf.Text(\"page 2 content\")\n\n\terr = pdf.WritePdf(\"./test/out/header_footer.pdf\")\n\tif err != nil {\n\t\tt.Error(err)\n\t\treturn\n\t}\n}\n\nfunc initTesting() error {\n\terr := os.MkdirAll(\"./test/out\", 0777)\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}\n\n// setupDefaultA4PDF creates an A4 sized pdf with a plain configuration adding and setting the required fonts for\n// further processing. Tests will fail in case adding or setting the font fails.\nfunc setupDefaultA4PDF(t *testing.T) *GoPdf {\n\tpdf := GoPdf{}\n\tpdf.Start(Config{PageSize: *PageSizeA4})\n\terr := pdf.AddTTFFont(\"LiberationSerif-Regular\", \"./test/res/LiberationSerif-Regular.ttf\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\terr = pdf.SetFont(\"LiberationSerif-Regular\", \"\", 14)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\treturn &pdf\n}\n\nfunc TestImportPagesFromFile(t *testing.T) {\n\terr := os.MkdirAll(\"./test/out\", 0777)\n\tif err != nil {\n\t\tt.Error(err)\n\t\treturn\n\t}\n\n\tpdf := GoPdf{}\n\tpdf.Start(Config{PageSize: *PageSizeA4})\n\n\terr = pdf.ImportPagesFromSource(\"./examples/outline_example/outline_demo.pdf\", \"/MediaBox\")\n\tif err != nil {\n\t\tt.Error(err)\n\t\treturn\n\t}\n\n\terr = pdf.AddTTFFont(\"LiberationSerif-Regular\", \"./test/res/LiberationSerif-Regular.ttf\")\n\tif err != nil {\n\t\tt.Error(err)\n\t\treturn\n\t}\n\terr = pdf.SetFont(\"LiberationSerif-Regular\", \"\", 14)\n\n\terr = pdf.SetPage(1)\n\tif err != nil {\n\t\tt.Error(err)\n\t\treturn\n\t}\n\tpdf.SetXY(350, 50)\n\terr = pdf.Cell(&Rect{W: 20, H: 30}, \"Hello World\")\n\tif err != nil {\n\t\tt.Error(err)\n\t\treturn\n\t}\n\terr = pdf.SetPage(2)\n\tif err != nil {\n\t\tt.Error(err)\n\t\treturn\n\t}\n\tpdf.SetXY(350, 50)\n\terr = pdf.Cell(&Rect{W: 20, H: 30}, \"Hello World\")\n\tif err != nil {\n\t\tt.Error(err)\n\t\treturn\n\t}\n\terr = pdf.SetPage(3)\n\tif err != nil {\n\t\tt.Error(err)\n\t\treturn\n\t}\n\tpdf.SetXY(350, 50)\n\terr = pdf.Cell(&Rect{W: 20, H: 30}, \"Hello World\")\n\tif err != nil {\n\t\tt.Error(err)\n\t\treturn\n\t}\n\n\terr = pdf.WritePdf(\"./test/out/open-existing-pdf.pdf\")\n\tif err != nil {\n\t\tt.Error(err)\n\t\treturn\n\t}\n}\n"
        },
        {
          "name": "i_cache_color_text.go",
          "type": "blob",
          "size": 0.095703125,
          "content": "package gopdf\n\ntype ICacheColorText interface {\n\tICacheContent\n\tequal(obj ICacheColorText) bool\n}\n"
        },
        {
          "name": "i_cache_contneter.go",
          "type": "blob",
          "size": 0.1162109375,
          "content": "package gopdf\n\nimport (\n\t\"io\"\n)\n\ntype ICacheContent interface {\n\twrite(w io.Writer, protection *PDFProtection) error\n}\n"
        },
        {
          "name": "ifont.go",
          "type": "blob",
          "size": 0.634765625,
          "content": "package gopdf\n\n// IFont represents a font interface.\ntype IFont interface {\n\tInit()\n\tGetType() string\n\tGetName() string\n\tGetDesc() []FontDescItem\n\tGetUp() int\n\tGetUt() int\n\tGetCw() FontCw\n\tGetEnc() string\n\tGetDiff() string\n\tGetOriginalsize() int\n\n\tSetFamily(family string)\n\tGetFamily() string\n}\n\n// FontCw maps characters to integers.\ntype FontCw map[byte]int\n\n// FontDescItem is a (key, value) pair.\ntype FontDescItem struct {\n\tKey string\n\tVal string\n}\n\n// // Chr\n// func Chr(n int) byte {\n// \treturn byte(n) //ToByte(fmt.Sprintf(\"%c\", n ))\n// }\n\n// ToByte returns the first byte of a string.\nfunc ToByte(chr string) byte {\n\treturn []byte(chr)[0]\n}\n"
        },
        {
          "name": "image_holder.go",
          "type": "blob",
          "size": 1.3896484375,
          "content": "package gopdf\n\nimport (\n\t\"bytes\"\n\t\"crypto/md5\"\n\t\"fmt\"\n\t\"io\"\n\t\"os\"\n)\n\n// ImageHolder hold image data\ntype ImageHolder interface {\n\tID() string\n\tio.Reader\n}\n\n// ImageHolderByBytes create ImageHolder by []byte\nfunc ImageHolderByBytes(b []byte) (ImageHolder, error) {\n\treturn newImageBuff(b)\n}\n\n// ImageHolderByPath create ImageHolder by image path\nfunc ImageHolderByPath(path string) (ImageHolder, error) {\n\treturn newImageBuffByPath(path)\n}\n\n// ImageHolderByReader create ImageHolder by io.Reader\nfunc ImageHolderByReader(r io.Reader) (ImageHolder, error) {\n\treturn newImageBuffByReader(r)\n}\n\n// imageBuff image holder (impl ImageHolder)\ntype imageBuff struct {\n\tid string\n\tbytes.Buffer\n}\n\nfunc newImageBuff(b []byte) (*imageBuff, error) {\n\th := md5.New()\n\t_, err := h.Write(b)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tvar i imageBuff\n\ti.id = fmt.Sprintf(\"%x\", h.Sum(nil))\n\ti.Write(b)\n\treturn &i, nil\n}\n\nfunc newImageBuffByPath(path string) (*imageBuff, error) {\n\tvar i imageBuff\n\ti.id = path\n\tb, err := os.ReadFile(path)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\ti.Write(b)\n\treturn &i, nil\n}\n\nfunc newImageBuffByReader(r io.Reader) (*imageBuff, error) {\n\n\tb, err := io.ReadAll(r)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\th := md5.New()\n\t_, err = h.Write(b)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tvar i imageBuff\n\ti.id = fmt.Sprintf(\"%x\", h.Sum(nil))\n\ti.Write(b)\n\treturn &i, nil\n}\n\nfunc (i *imageBuff) ID() string {\n\treturn i.id\n}\n"
        },
        {
          "name": "image_obj.go",
          "type": "blob",
          "size": 3.658203125,
          "content": "package gopdf\n\nimport (\n\t\"bytes\"\n\t\"fmt\"\n\t\"image\"\n\n\t// Packages image/jpeg and image/png are not used explicitly in the code below,\n\t// but are imported for their initialization side-effect, which allows\n\t// image.Decode to understand JPEG formatted images.\n\t_ \"image/jpeg\"\n\t_ \"image/png\"\n\t\"io\"\n\t\"log\"\n\t\"os\"\n)\n\n// ImageObj image object\ntype ImageObj struct {\n\t//imagepath string\n\tIsMask        bool\n\tSplittedMask  bool\n\trawImgReader  *bytes.Reader\n\timginfo       imgInfo\n\tpdfProtection *PDFProtection\n\t//getRoot func() *GoPdf\n}\n\nfunc (i *ImageObj) init(funcGetRoot func() *GoPdf) {\n\n}\n\nfunc (i *ImageObj) setProtection(p *PDFProtection) {\n\ti.pdfProtection = p\n}\n\nfunc (i *ImageObj) protection() *PDFProtection {\n\treturn i.pdfProtection\n}\n\nfunc (i *ImageObj) write(w io.Writer, objID int) error {\n\tdata := i.imginfo.data\n\n\tif i.IsMask {\n\t\tdata = i.imginfo.smask\n\t\tif err := writeMaskImgProps(w, i.imginfo); err != nil {\n\t\t\treturn err\n\t\t}\n\t} else {\n\t\tif err := writeImgProps(w, i.imginfo, i.SplittedMask); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\tif _, err := fmt.Fprintf(w, \"\\t/Length %d\\n>>\\n\", len(data)); err != nil {\n\t\treturn err\n\t}\n\n\tif _, err := io.WriteString(w, \"stream\\n\"); err != nil {\n\t\treturn err\n\t}\n\n\tif i.protection() != nil {\n\t\ttmp, err := rc4Cip(i.protection().objectkey(objID), data)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tif _, err := w.Write(tmp); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif _, err := io.WriteString(w, \"\\n\"); err != nil {\n\t\t\treturn err\n\t\t}\n\t} else {\n\t\tif _, err := w.Write(data); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\tif _, err := io.WriteString(w, \"\\nendstream\\n\"); err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\nfunc (i *ImageObj) isColspaceIndexed() bool {\n\treturn isColspaceIndexed(i.imginfo)\n}\n\nfunc (i *ImageObj) haveSMask() bool {\n\treturn haveSMask(i.imginfo)\n}\n\nfunc (i *ImageObj) createSMask() (*SMask, error) {\n\tvar smk SMask\n\tsmk.setProtection(i.protection())\n\tsmk.w = i.imginfo.w\n\tsmk.h = i.imginfo.h\n\tsmk.colspace = \"DeviceGray\"\n\tsmk.bitsPerComponent = \"8\"\n\tsmk.filter = i.imginfo.filter\n\tsmk.data = i.imginfo.smask\n\tsmk.decodeParms = fmt.Sprintf(\"/Predictor 15 /Colors 1 /BitsPerComponent 8 /Columns %d\", i.imginfo.w)\n\treturn &smk, nil\n}\n\nfunc (i *ImageObj) createDeviceRGB() (*DeviceRGBObj, error) {\n\tvar dRGB DeviceRGBObj\n\tdRGB.data = i.imginfo.pal\n\treturn &dRGB, nil\n}\n\nfunc (i *ImageObj) getType() string {\n\treturn \"Image\"\n}\n\n// SetImagePath set image path\nfunc (i *ImageObj) SetImagePath(path string) error {\n\n\tfile, err := os.Open(path)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer file.Close()\n\n\terr = i.SetImage(file)\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}\n\n// SetImage set image\nfunc (i *ImageObj) SetImage(r io.Reader) error {\n\n\tdata, err := io.ReadAll(r)\n\tif err != nil {\n\t\treturn err\n\t}\n\ti.rawImgReader = bytes.NewReader(data)\n\n\treturn nil\n}\n\n// GetRect get rect of img\nfunc (i *ImageObj) GetRect() *Rect {\n\n\trect, err := i.getRect()\n\tif err != nil {\n\t\tlog.Fatalf(\"%+v\", err)\n\t}\n\treturn rect\n}\n\n// GetRect get rect of img\nfunc (i *ImageObj) getRect() (*Rect, error) {\n\n\ti.rawImgReader.Seek(0, 0)\n\tm, _, err := image.Decode(i.rawImgReader)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\timageRect := m.Bounds()\n\tk := 1\n\tw := -128 //init\n\th := -128 //init\n\tif w < 0 {\n\t\tw = -imageRect.Dx() * 72 / w / k\n\t}\n\tif h < 0 {\n\t\th = -imageRect.Dy() * 72 / h / k\n\t}\n\tif w == 0 {\n\t\tw = h * imageRect.Dx() / imageRect.Dy()\n\t}\n\tif h == 0 {\n\t\th = w * imageRect.Dy() / imageRect.Dx()\n\t}\n\n\tvar rect = new(Rect)\n\trect.H = float64(h)\n\trect.W = float64(w)\n\n\treturn rect, nil\n}\n\nfunc (i *ImageObj) parse() error {\n\n\ti.rawImgReader.Seek(0, 0)\n\timginfo, err := parseImg(i.rawImgReader)\n\tif err != nil {\n\t\treturn err\n\t}\n\ti.imginfo = imginfo\n\n\treturn nil\n}\n\n// Parse parse img\nfunc (i *ImageObj) Parse() error {\n\treturn i.parse()\n}\n"
        },
        {
          "name": "image_obj_parse.go",
          "type": "blob",
          "size": 10.4375,
          "content": "package gopdf\n\nimport (\n\t\"bytes\"\n\t\"compress/zlib\"\n\t\"encoding/binary\"\n\t\"errors\"\n\t\"fmt\"\n\t\"image\"\n\t\"image/color\"\n\t_ \"image/gif\"\n\t\"image/png\"\n\t\"io\"\n\t\"os\"\n\t\"strings\"\n)\n\ntype ColorSpaces string\n\nconst (\n\tDeviceGray = \"DeviceGray\"\n)\n\nfunc writeMaskImgProps(w io.Writer, imginfo imgInfo) error {\n\tif err := writeBaseImgProps(w, imginfo, DeviceGray); err != nil {\n\t\treturn err\n\t}\n\n\tdecode := \"\\t/DecodeParms <<\\n\"\n\tdecode += \"\\t\\t/Predictor 15\\n\"\n\tdecode += \"\\t\\t/Colors 1\\n\"\n\tdecode += \"\\t\\t/BitsPerComponent 8\\n\"\n\tdecode += fmt.Sprintf(\"\\t\\t/Columns %d\\n\", imginfo.w)\n\tdecode += \"\\t>>\\n\"\n\n\tif _, err := io.WriteString(w, decode); err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\nfunc writeImgProps(w io.Writer, imginfo imgInfo, splittedMask bool) error {\n\tif err := writeBaseImgProps(w, imginfo, imginfo.colspace); err != nil {\n\t\treturn err\n\t}\n\n\tif strings.TrimSpace(imginfo.decodeParms) != \"\" {\n\t\tif _, err := fmt.Fprintf(w, \"\\t/DecodeParms <<%s>>\\n\", imginfo.decodeParms); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\tif splittedMask {\n\t\treturn nil\n\t}\n\n\tif imginfo.trns != nil && len(imginfo.trns) > 0 {\n\t\tj := 0\n\t\tcontent := \"\\t/Mask [\"\n\t\tmax := len(imginfo.trns)\n\n\t\tfor j < max {\n\t\t\tcontent += fmt.Sprintf(\"\\t\\t%d \", imginfo.trns[j])\n\t\t\tcontent += fmt.Sprintf(\"\\t\\t%d \", imginfo.trns[j])\n\t\t\tj++\n\t\t}\n\n\t\tcontent += \"\\t]\\n\"\n\n\t\tif _, err := io.WriteString(w, content); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\tif haveSMask(imginfo) {\n\t\tif _, err := fmt.Fprintf(w, \"\\t/SMask %d 0 R\\n\", imginfo.smarkObjID+1); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\treturn nil\n}\n\nfunc writeBaseImgProps(w io.Writer, imginfo imgInfo, colorSpace string) error {\n\tcontent := \"<<\\n\"\n\tcontent += \"\\t/Type /XObject\\n\"\n\tcontent += \"\\t/Subtype /Image\\n\"\n\tcontent += fmt.Sprintf(\"\\t/Width %d\\n\", imginfo.w)\n\tcontent += fmt.Sprintf(\"\\t/Height %d\\n\", imginfo.h)\n\n\tif isColspaceIndexed(imginfo) {\n\t\tsize := len(imginfo.pal)/3 - 1\n\t\tcontent += fmt.Sprintf(\"\\t/ColorSpace [/Indexed /DeviceRGB %d %d 0 R]\\n\", size, imginfo.deviceRGBObjID+1)\n\t} else {\n\t\tcontent += fmt.Sprintf(\"\\t/ColorSpace /%s\\n\", colorSpace)\n\t\tif imginfo.colspace == \"DeviceCMYK\" {\n\t\t\tcontent += \"\\t/Decode [1 0 1 0 1 0 1 0]\\n\"\n\t\t}\n\t}\n\n\tcontent += fmt.Sprintf(\"\\t/BitsPerComponent %s\\n\", imginfo.bitsPerComponent)\n\n\tif strings.TrimSpace(imginfo.filter) != \"\" {\n\t\tcontent += fmt.Sprintf(\"\\t/Filter /%s\\n\", imginfo.filter)\n\t}\n\n\tif _, err := io.WriteString(w, content); err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\nfunc isColspaceIndexed(imginfo imgInfo) bool {\n\tif imginfo.colspace == \"Indexed\" {\n\t\treturn true\n\t}\n\treturn false\n}\n\nfunc haveSMask(imginfo imgInfo) bool {\n\tif imginfo.smask != nil && len(imginfo.smask) > 0 {\n\t\treturn true\n\t}\n\treturn false\n}\n\nfunc parseImgByPath(path string) (imgInfo, error) {\n\tdata, err := os.ReadFile(path)\n\tif err != nil {\n\t\treturn imgInfo{}, err\n\t}\n\treturn parseImg(bytes.NewReader(data))\n}\n\nfunc parseImg(raw *bytes.Reader) (imgInfo, error) {\n\t// fmt.Printf(\"----------\\n\")\n\tvar info imgInfo\n\traw.Seek(0, 0)\n\timgConfig, formatname, err := image.DecodeConfig(raw)\n\tif err != nil {\n\t\treturn info, err\n\t}\n\tinfo.formatName = formatname\n\n\tif formatname == \"jpeg\" {\n\n\t\terr = parseImgJpg(&info, imgConfig)\n\t\tif err != nil {\n\t\t\treturn info, err\n\t\t}\n\t\traw.Seek(0, 0)\n\t\tinfo.data, err = io.ReadAll(raw)\n\t\tif err != nil {\n\t\t\treturn info, err\n\t\t}\n\n\t} else if formatname == \"png\" {\n\t\terr = parsePng(raw, &info, imgConfig)\n\t\tif err != nil {\n\t\t\treturn info, err\n\t\t}\n\t} else if formatname == \"gif\" {\n\t\t// Convert to png\n\t\traw.Seek(0, 0)\n\t\tvar img image.Image\n\t\timg, _, err = image.Decode(raw)\n\t\tif err != nil {\n\t\t\treturn info, err\n\t\t}\n\t\tpngBuf := new(bytes.Buffer)\n\t\terr = png.Encode(pngBuf, img)\n\t\tif err != nil {\n\t\t\treturn info, err\n\t\t}\n\t\tinfo, err = parseImg(bytes.NewReader(pngBuf.Bytes()))\n\t\tif err != nil {\n\t\t\treturn info, err\n\t\t}\n\t} else {\n\t\treturn info, fmt.Errorf(\"Image format %v is not supported\", formatname)\n\t}\n\n\t// fmt.Printf(\"%#v\\n\", info)\n\n\treturn info, nil\n}\n\nfunc parseImgJpg(info *imgInfo, imgConfig image.Config) error {\n\tswitch imgConfig.ColorModel {\n\tcase color.YCbCrModel:\n\t\tinfo.colspace = \"DeviceRGB\"\n\tcase color.GrayModel:\n\t\tinfo.colspace = \"DeviceGray\"\n\tcase color.CMYKModel:\n\t\tinfo.colspace = \"DeviceCMYK\"\n\tdefault:\n\t\treturn errors.New(\"color model not support\")\n\t}\n\tinfo.bitsPerComponent = \"8\"\n\tinfo.filter = \"DCTDecode\"\n\n\tinfo.h = imgConfig.Height\n\tinfo.w = imgConfig.Width\n\n\treturn nil\n}\n\nvar pngMagicNumber = []byte{0x89, 0x50, 0x4e, 0x47, 0x0d, 0x0a, 0x1a, 0x0a}\nvar pngIHDR = []byte{0x49, 0x48, 0x44, 0x52}\n\nfunc parsePng(f *bytes.Reader, info *imgInfo, imgConfig image.Config) error {\n\t// f := bytes.NewReader(raw)\n\tf.Seek(0, 0)\n\tb, err := readBytes(f, 8)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif !bytes.Equal(b, pngMagicNumber) {\n\t\treturn errors.New(\"Not a PNG file\")\n\t}\n\n\tf.Seek(4, 1) // skip header chunk\n\tb, err = readBytes(f, 4)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif !bytes.Equal(b, pngIHDR) {\n\t\treturn errors.New(\"Incorrect PNG file\")\n\t}\n\n\tw, err := readInt(f)\n\tif err != nil {\n\t\treturn err\n\t}\n\th, err := readInt(f)\n\tif err != nil {\n\t\treturn err\n\t}\n\t// fmt.Printf(\"w=%d h=%d\\n\", w, h)\n\n\tbpc, err := readBytes(f, 1)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif bpc[0] > 8 {\n\t\treturn errors.New(\"16-bit depth not supported\")\n\t}\n\n\tct, err := readBytes(f, 1)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tvar colspace string\n\tswitch ct[0] {\n\tcase 0, 4:\n\t\tcolspace = \"DeviceGray\"\n\tcase 2, 6:\n\t\tcolspace = \"DeviceRGB\"\n\tcase 3:\n\t\tcolspace = \"Indexed\"\n\tdefault:\n\t\treturn errors.New(\"Unknown color type\")\n\t}\n\n\tcompressionMethod, err := readBytes(f, 1)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif compressionMethod[0] != 0 {\n\t\treturn errors.New(\"Unknown compression method\")\n\t}\n\n\tfilterMethod, err := readBytes(f, 1)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif filterMethod[0] != 0 {\n\t\treturn errors.New(\"Unknown filter method\")\n\t}\n\n\tinterlacing, err := readBytes(f, 1)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif interlacing[0] != 0 {\n\t\treturn errors.New(\"Interlacing not supported\")\n\t}\n\n\t_, err = f.Seek(4, 1) // skip\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// decodeParms := \"/Predictor 15 /Colors '.($colspace=='DeviceRGB' ? 3 : 1).' /BitsPerComponent '.$bpc.' /Columns '.$w;\n\n\tvar pal []byte\n\tvar trns []byte\n\tvar data []byte\n\tfor {\n\t\tun, err := readUInt(f)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tn := int(un)\n\t\ttyp, err := readBytes(f, 4)\n\t\t// fmt.Printf(\">>>>%+v-%s-%d\\n\", typ, string(typ), n)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tif string(typ) == \"PLTE\" {\n\t\t\tpal, err = readBytes(f, n)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\t_, err = f.Seek(int64(4), 1) // skip\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t} else if string(typ) == \"tRNS\" {\n\n\t\t\tvar t []byte\n\t\t\tt, err = readBytes(f, n)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t\tif ct[0] == 0 {\n\t\t\t\ttrns = []byte{(t[1])}\n\t\t\t} else if ct[0] == 2 {\n\t\t\t\ttrns = []byte{t[1], t[3], t[5]}\n\t\t\t} else {\n\t\t\t\tpos := strings.Index(string(t), \"\\x00\")\n\t\t\t\tif pos >= 0 {\n\t\t\t\t\ttrns = []byte{byte(pos)}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t_, err = f.Seek(int64(4), 1) // skip\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t} else if string(typ) == \"IDAT\" {\n\t\t\t// fmt.Printf(\"n=%d\\n\\n\", n)\n\t\t\tvar d []byte\n\t\t\td, err = readBytes(f, n)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tdata = append(data, d...)\n\t\t\t_, err = f.Seek(int64(4), 1) // skip\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t} else if string(typ) == \"IEND\" {\n\t\t\tbreak\n\t\t} else {\n\t\t\t_, err = f.Seek(int64(n+4), 1) // skip\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\n\t\tif n <= 0 {\n\t\t\tbreak\n\t\t}\n\t} // end for\n\n\t// info.data = data //ok\n\tinfo.trns = trns\n\tinfo.pal = pal\n\n\t// fmt.Printf(\"data= %x\", md5.Sum(data))\n\n\tif colspace == \"Indexed\" && strings.TrimSpace(string(pal)) == \"\" {\n\t\treturn errors.New(\"Missing palette\")\n\t}\n\n\tinfo.w = w\n\tinfo.h = h\n\tinfo.colspace = colspace\n\tinfo.bitsPerComponent = fmt.Sprintf(\"%d\", int(bpc[0]))\n\tinfo.filter = \"FlateDecode\"\n\n\tcolors := 1\n\tif colspace == \"DeviceRGB\" {\n\t\tcolors = 3\n\t}\n\tinfo.decodeParms = fmt.Sprintf(\"/Predictor 15 /Colors  %d /BitsPerComponent %s /Columns %d\", colors, info.bitsPerComponent, w)\n\n\t// fmt.Printf(\"%d = ct[0]\\n\", ct[0])\n\t// fmt.Printf(\"%x\\n\", md5.Sum(data))\n\tif ct[0] >= 4 {\n\t\tzipReader, err := zlib.NewReader(bytes.NewReader(data))\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tdefer zipReader.Close()\n\t\tafterZipData, err := io.ReadAll(zipReader)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tvar color []byte\n\t\tvar alpha []byte\n\t\tif ct[0] == 4 {\n\t\t\t// Gray image\n\t\t\tlength := 2 * w\n\t\t\ti := 0\n\t\t\tfor i < h {\n\t\t\t\tpos := (1 + length) * i\n\t\t\t\tcolor = append(color, afterZipData[pos])\n\t\t\t\talpha = append(alpha, afterZipData[pos])\n\t\t\t\tline := afterZipData[pos+1 : pos+length+1]\n\t\t\t\tj := 0\n\t\t\t\tmax := len(line)\n\t\t\t\tfor j < max {\n\t\t\t\t\tcolor = append(color, line[j])\n\t\t\t\t\tj++\n\t\t\t\t\talpha = append(alpha, line[j])\n\t\t\t\t\tj++\n\t\t\t\t}\n\t\t\t\ti++\n\t\t\t}\n\t\t\t// fmt.Print(\"aaaaa\")\n\n\t\t} else {\n\t\t\t// RGB image\n\t\t\tlength := 4 * w\n\t\t\ti := 0\n\t\t\tfor i < h {\n\t\t\t\tpos := (1 + length) * i\n\t\t\t\tcolor = append(color, afterZipData[pos])\n\t\t\t\talpha = append(alpha, afterZipData[pos])\n\t\t\t\tline := afterZipData[pos+1 : pos+length+1]\n\t\t\t\tj := 0\n\t\t\t\tmax := len(line)\n\t\t\t\tfor j < max {\n\t\t\t\t\tcolor = append(color, line[j:j+3]...)\n\t\t\t\t\talpha = append(alpha, line[j+3])\n\t\t\t\t\tj = j + 4\n\t\t\t\t}\n\n\t\t\t\ti++\n\t\t\t}\n\t\t}\n\n\t\tinfo.smask, err = compress(alpha)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tinfo.data, err = compress(color)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t} else {\n\t\tinfo.data = data\n\t}\n\n\treturn nil\n}\n\nfunc compress(data []byte) ([]byte, error) {\n\tvar results []byte\n\tvar buff bytes.Buffer\n\tzwr, err := zlib.NewWriterLevel(&buff, zlib.BestSpeed)\n\n\tif err != nil {\n\t\treturn results, err\n\t}\n\t_, err = zwr.Write(data)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tzwr.Close()\n\treturn buff.Bytes(), nil\n}\n\nfunc readUInt(f *bytes.Reader) (uint, error) {\n\tbuff, err := readBytes(f, 4)\n\t// fmt.Printf(\"%#v\\n\\n\", buff)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\tn := binary.BigEndian.Uint32(buff)\n\treturn uint(n), nil\n}\n\nfunc readInt(f *bytes.Reader) (int, error) {\n\tu, err := readUInt(f)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\tv := int(u)\n\treturn v, nil\n}\n\nfunc readBytes(f *bytes.Reader, len int) ([]byte, error) {\n\tb := make([]byte, len)\n\t_, err := f.Read(b)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn b, nil\n}\n\nfunc isDeviceRGB(formatname string, img *image.Image) bool {\n\tif _, ok := (*img).(*image.YCbCr); ok {\n\t\treturn true\n\t} else if _, ok := (*img).(*image.NRGBA); ok {\n\t\treturn true\n\t}\n\treturn false\n}\n\n// ImgReactagleToWH  Rectangle to W and H\nfunc ImgReactagleToWH(imageRect image.Rectangle) (float64, float64) {\n\tk := 1\n\tw := -128 // init\n\th := -128 // init\n\tif w < 0 {\n\t\tw = -imageRect.Dx() * 72 / w / k\n\t}\n\tif h < 0 {\n\t\th = -imageRect.Dy() * 72 / h / k\n\t}\n\tif w == 0 {\n\t\tw = h * imageRect.Dx() / imageRect.Dy()\n\t}\n\tif h == 0 {\n\t\th = w * imageRect.Dy() / imageRect.Dx()\n\t}\n\treturn float64(w), float64(h)\n}\n"
        },
        {
          "name": "image_obj_test.go",
          "type": "blob",
          "size": 1.453125,
          "content": "package gopdf\n\nimport (\n\t\"testing\"\n)\n\nfunc TestImagePares(t *testing.T) {\n\n\tvar err error\n\t_, err = parseImgByPath(\"test/res/gopher01.jpg\")\n\tif err != nil {\n\t\tt.Error(err)\n\t\t//return\n\t}\n\n\t_, err = parseImgByPath(\"test/res/gopher01_g_mode.jpg\")\n\tif err != nil {\n\t\tt.Error(err)\n\t\t//return\n\t}\n\n\t_, err = parseImgByPath(\"test/res/gopher01_i_mode.jpg\")\n\tif err != nil {\n\t\tt.Error(err)\n\t\t//return\n\t}\n\n\t//Channel_digital_image_CMYK_color.jpg\n\t_, err = parseImgByPath(\"test/res/Channel_digital_image_CMYK_color.jpg\")\n\tif err != nil {\n\t\tt.Error(err)\n\t\t//return\n\t}\n\n\t_, err = parseImgByPath(\"test/res/gopher02.png\")\n\tif err != nil {\n\t\tt.Error(err)\n\t\treturn\n\t}\n\n\t_, err = parseImgByPath(\"test/res/gopher02.png\")\n\tif err != nil {\n\t\tt.Error(err)\n\t\treturn\n\t}\n\n\t_, err = parseImgByPath(\"test/res/gopher03.gif\")\n\tif err != nil {\n\t\tt.Error(err)\n\t\treturn\n\t}\n\n\t_, err = parseImgByPath(\"test/res/gopher03_color.gif\")\n\tif err != nil {\n\t\tt.Error(err)\n\t\treturn\n\t}\n\n}\n\nfunc TestImage02Pares(t *testing.T) {\n\n\tvar err error\n\t//_, err = parseImgByPath(\"test/res/OpenOffice.org_1.1_official_main_logo_2col_trans.png\")\n\n\t_, err = parseImgByPath(\"./test/res/PNG_transparency_demonstration_1.png\")\n\tif err != nil {\n\t\tt.Error(err)\n\t\t//return\n\t}\n}\n\nfunc TestImage03Pares(t *testing.T) {\n\n\tvar err error\n\t_, err = parseImgByPath(\"test/res/OpenOffice.org_1.1_official_main_logo_2col_trans.png\")\n\n\t//_, err = parseImgByPath(\"./test/res/PNG_transparency_demonstration_1.png\")\n\tif err != nil {\n\t\tt.Error(err)\n\t\t//return\n\t}\n}\n"
        },
        {
          "name": "img_info.go",
          "type": "blob",
          "size": 0.3369140625,
          "content": "package gopdf\n\ntype imgInfo struct {\n\tw, h int\n\t//src              string\n\tformatName       string\n\tcolspace         string\n\tbitsPerComponent string\n\tfilter           string\n\tdecodeParms      string\n\ttrns             []byte\n\tsmask            []byte\n\tsmarkObjID       int\n\tpal              []byte\n\tdeviceRGBObjID   int\n\tdata             []byte\n}\n"
        },
        {
          "name": "imported_obj.go",
          "type": "blob",
          "size": 0.3544921875,
          "content": "package gopdf\n\nimport (\n\t\"io\"\n)\n\n// ImportedObj : imported object\ntype ImportedObj struct { //impl IObj\n\tData string\n}\n\nfunc (c *ImportedObj) init(funcGetRoot func() *GoPdf) {\n\n}\n\nfunc (c *ImportedObj) getType() string {\n\treturn \"Imported\"\n}\n\nfunc (c *ImportedObj) write(w io.Writer, objID int) error {\n\tif c != nil {\n\t\tio.WriteString(w, c.Data)\n\t}\n\treturn nil\n}\n"
        },
        {
          "name": "iobj.go",
          "type": "blob",
          "size": 0.1650390625,
          "content": "package gopdf\n\nimport (\n\t\"io\"\n)\n\n// IObj inteface for all pdf object\ntype IObj interface {\n\tinit(func() *GoPdf)\n\tgetType() string\n\twrite(w io.Writer, objID int) error\n}\n"
        },
        {
          "name": "kern_test.go",
          "type": "blob",
          "size": 1.775390625,
          "content": "package gopdf\n\nimport (\n\t\"errors\"\n\t\"log\"\n\t\"testing\"\n)\n\nfunc TestKern01(t *testing.T) {\n\tWo, err := kern01(\"test/res/LiberationSerif-Regular.ttf\", \"LiberationSerif-Regular\", 'W', 'o')\n\tif err != nil {\n\t\tt.Error(err)\n\t\treturn\n\t}\n\n\tif Wo != -80 {\n\t\tt.Errorf(\"Wo must be -80 (but %d)\", Wo)\n\t\t//return\n\t}\n\n\tWi, err := kern01(\"test/res/LiberationSerif-Regular.ttf\", \"LiberationSerif-Regular\", 'W', 'i')\n\tif err != nil {\n\t\tt.Error(err)\n\t\treturn\n\t}\n\n\tif Wi != -40 {\n\t\tt.Errorf(\"Wi must be -40 (but %d)\", Wi)\n\t\t//return\n\t}\n\n}\n\nfunc kern01(font string, prefix string, leftRune rune, rightRune rune) (int, error) {\n\tpdf := GoPdf{}\n\tpdf.Start(Config{Unit: UnitPT, PageSize: *PageSizeA4})\n\tpdf.AddPage()\n\terr := pdf.AddTTFFontWithOption(prefix, font, TtfOption{\n\t\tUseKerning: true,\n\t})\n\tif err != nil {\n\t\tlog.Print(err.Error())\n\t\treturn 0, err\n\t}\n\n\terr = pdf.SetFont(prefix, \"\", 50)\n\tif err != nil {\n\t\tlog.Print(err.Error())\n\t\treturn 0, err\n\t}\n\n\tgindexleftRune, err := pdf.curr.FontISubset.CharCodeToGlyphIndex(leftRune)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\n\tgindexrightRune, err := pdf.curr.FontISubset.CharCodeToGlyphIndex(rightRune)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\t//fmt.Printf(\"gindexleftRune = %d  gindexrightRune=%d \\n\", gindexleftRune, gindexrightRune)\n\tkernTb := pdf.curr.FontISubset.ttfp.Kern()\n\n\t//fmt.Printf(\"UnitsPerEm = %d\\n\", pdf.Curr.FontISubset.ttfp.UnitsPerEm())\n\n\t//fmt.Printf(\"len =%d\\n\", len(kernTb.Kerning))\n\tfor left, kval := range kernTb.Kerning {\n\t\tif left == gindexleftRune {\n\t\t\tfor right, val := range kval {\n\t\t\t\tif right == gindexrightRune {\n\t\t\t\t\t//fmt.Printf(\"left=%d right= %d  val=%d\\n\", left, right, val)\n\t\t\t\t\tvalPdfUnit := convertTTFUnit2PDFUnit(int(val), int(pdf.curr.FontISubset.ttfp.UnitsPerEm()))\n\t\t\t\t\treturn valPdfUnit, nil\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak\n\t\t}\n\t}\n\n\treturn 0, errors.New(\"not found\")\n}\n"
        },
        {
          "name": "link_option.go",
          "type": "blob",
          "size": 0.150390625,
          "content": "package gopdf\n\ntype anchorOption struct {\n\tpage int\n\ty    float64\n}\n\ntype linkOption struct {\n\tx, y, w, h float64\n\turl        string\n\tanchor     string\n}\n"
        },
        {
          "name": "list_cache_content.go",
          "type": "blob",
          "size": 1.4072265625,
          "content": "package gopdf\n\nimport \"io\"\n\ntype listCacheContent struct {\n\tcaches []ICacheContent\n}\n\nfunc (l *listCacheContent) last() ICacheContent {\n\tmax := len(l.caches)\n\tif max > 0 {\n\t\treturn l.caches[max-1]\n\t}\n\treturn nil\n}\n\nfunc (l *listCacheContent) append(cache ICacheContent) {\n\tl.caches = append(l.caches, cache)\n}\n\nfunc (l *listCacheContent) appendContentText(cache cacheContentText, text string) (float64, float64, error) {\n\n\tx := cache.x\n\ty := cache.y\n\n\tmustMakeNewCache := true\n\tvar cacheFont *cacheContentText\n\tvar ok bool\n\tlast := l.last()\n\tif cacheFont, ok = last.(*cacheContentText); ok {\n\t\tif cacheFont != nil {\n\t\t\tif cacheFont.isSame(cache) {\n\t\t\t\tmustMakeNewCache = false\n\t\t\t}\n\t\t}\n\t}\n\n\tif mustMakeNewCache { //make new cell\n\t\tl.caches = append(l.caches, &cache)\n\t\tcacheFont = &cache\n\t}\n\n\t//start add text\n\tcacheFont.text += text\n\n\t//re-create content\n\ttextWidthPdfUnit, textHeightPdfUnit, err := cacheFont.createContent()\n\tif err != nil {\n\t\treturn x, y, err\n\t}\n\n\tif cacheFont.cellOpt.Float == 0 || cacheFont.cellOpt.Float&Right == Right || cacheFont.contentType == ContentTypeText {\n\t\tx = cacheFont.x + textWidthPdfUnit\n\t}\n\tif cacheFont.cellOpt.Float&Bottom == Bottom {\n\t\ty = cacheFont.y + textHeightPdfUnit\n\t}\n\n\treturn x, y, nil\n}\n\nfunc (l *listCacheContent) write(w io.Writer, protection *PDFProtection) error {\n\tfor _, cache := range l.caches {\n\t\tif err := cache.write(w, protection); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n"
        },
        {
          "name": "map_of_character_To_glyph_index.go",
          "type": "blob",
          "size": 1.3984375,
          "content": "package gopdf\n\n// MapOfCharacterToGlyphIndex map of CharacterToGlyphIndex\ntype MapOfCharacterToGlyphIndex struct {\n\tkeyIndexs map[rune]int //for search index in keys\n\tKeys      []rune\n\tVals      []uint\n}\n\n// NewMapOfCharacterToGlyphIndex new CharacterToGlyphIndex\nfunc NewMapOfCharacterToGlyphIndex() *MapOfCharacterToGlyphIndex {\n\tvar m MapOfCharacterToGlyphIndex\n\tm.keyIndexs = make(map[rune]int)\n\treturn &m\n}\n\n// KeyExists key is exists?\nfunc (m *MapOfCharacterToGlyphIndex) KeyExists(k rune) bool {\n\t/*for _, key := range m.Keys {\n\t\tif k == key {\n\t\t\treturn true\n\t\t}\n\t}*/\n\tif _, ok := m.keyIndexs[k]; ok {\n\t\treturn true\n\t}\n\treturn false\n}\n\n// Set set key and value to map\nfunc (m *MapOfCharacterToGlyphIndex) Set(k rune, v uint) {\n\tm.keyIndexs[k] = len(m.Keys)\n\tm.Keys = append(m.Keys, k)\n\tm.Vals = append(m.Vals, v)\n}\n\n// Index get index by key\nfunc (m *MapOfCharacterToGlyphIndex) Index(k rune) (int, bool) {\n\t/*for i, key := range m.Keys {\n\t\tif k == key {\n\t\t\treturn i, true\n\t\t}\n\t}*/\n\tif index, ok := m.keyIndexs[k]; ok {\n\t\treturn index, true\n\t}\n\treturn -1, false\n}\n\n// Val get value by Key\nfunc (m *MapOfCharacterToGlyphIndex) Val(k rune) (uint, bool) {\n\ti, ok := m.Index(k)\n\tif !ok {\n\t\treturn 0, false\n\t}\n\treturn m.Vals[i], true\n}\n\n// AllKeys get keys\nfunc (m *MapOfCharacterToGlyphIndex) AllKeys() []rune {\n\treturn m.Keys\n}\n\n// AllVals get all values\nfunc (m *MapOfCharacterToGlyphIndex) AllVals() []uint {\n\treturn m.Vals\n}\n"
        },
        {
          "name": "margin.go",
          "type": "blob",
          "size": 2.052734375,
          "content": "package gopdf\n\n// Margins type.\ntype Margins struct {\n\tLeft, Top, Right, Bottom float64\n}\n\n// SetLeftMargin sets left margin.\nfunc (gp *GoPdf) SetLeftMargin(margin float64) {\n\tgp.UnitsToPointsVar(&margin)\n\tgp.margins.Left = margin\n}\n\n// SetTopMargin sets top margin.\nfunc (gp *GoPdf) SetTopMargin(margin float64) {\n\tgp.UnitsToPointsVar(&margin)\n\tgp.margins.Top = margin\n}\n\n// SetMargins defines the left, top, right and bottom margins. By default, they equal 1 cm. Call this method to change them.\nfunc (gp *GoPdf) SetMargins(left, top, right, bottom float64) {\n\tgp.UnitsToPointsVar(&left, &top, &right, &bottom)\n\tgp.margins = Margins{left, top, right, bottom}\n}\n\n// SetMarginLeft sets the left margin\nfunc (gp *GoPdf) SetMarginLeft(margin float64) {\n\tgp.margins.Left = gp.UnitsToPoints(margin)\n}\n\n// SetMarginTop sets the top margin\nfunc (gp *GoPdf) SetMarginTop(margin float64) {\n\tgp.margins.Top = gp.UnitsToPoints(margin)\n}\n\n// SetMarginRight sets the right margin\nfunc (gp *GoPdf) SetMarginRight(margin float64) {\n\tgp.margins.Right = gp.UnitsToPoints(margin)\n}\n\n// SetMarginBottom set the bottom margin\nfunc (gp *GoPdf) SetMarginBottom(margin float64) {\n\tgp.margins.Bottom = gp.UnitsToPoints(margin)\n}\n\n// Margins gets the current margins, The margins will be converted back to the documents units. Returned values will be in the following order Left, Top, Right, Bottom\nfunc (gp *GoPdf) Margins() (float64, float64, float64, float64) {\n\treturn gp.PointsToUnits(gp.margins.Left),\n\t\tgp.PointsToUnits(gp.margins.Top),\n\t\tgp.PointsToUnits(gp.margins.Right),\n\t\tgp.PointsToUnits(gp.margins.Bottom)\n}\n\n// MarginLeft returns the left margin.\nfunc (gp *GoPdf) MarginLeft() float64 {\n\treturn gp.PointsToUnits(gp.margins.Left)\n}\n\n// MarginTop returns the top margin.\nfunc (gp *GoPdf) MarginTop() float64 {\n\treturn gp.PointsToUnits(gp.margins.Top)\n}\n\n// MarginRight returns the right margin.\nfunc (gp *GoPdf) MarginRight() float64 {\n\treturn gp.PointsToUnits(gp.margins.Right)\n}\n\n// MarginBottom returns the bottom margin.\nfunc (gp *GoPdf) MarginBottom() float64 {\n\treturn gp.PointsToUnits(gp.margins.Bottom)\n}\n"
        },
        {
          "name": "outlines_obj.go",
          "type": "blob",
          "size": 4.41796875,
          "content": "package gopdf\n\nimport (\n\t\"fmt\"\n\t\"io\"\n)\n\n// OutlinesObj : outlines dictionary\ntype OutlinesObj struct { //impl IObj\n\tgetRoot func() *GoPdf\n\n\tindex   int\n\tfirst   int\n\tlast    int\n\tcount   int\n\tlastObj *OutlineObj\n}\n\nfunc (o *OutlinesObj) init(funcGetRoot func() *GoPdf) {\n\to.getRoot = funcGetRoot\n\to.first = -1\n\to.last = -1\n}\n\nfunc (o *OutlinesObj) getType() string {\n\treturn \"Outlines\"\n}\n\nfunc (o *OutlinesObj) write(w io.Writer, objID int) error {\n\tcontent := \"<<\\n\"\n\tcontent += fmt.Sprintf(\"\\t/Type /%s\\n\", o.getType())\n\tcontent += fmt.Sprintf(\"\\t/Count %d\\n\", o.count)\n\n\tif o.first >= 0 {\n\t\tcontent += fmt.Sprintf(\"\\t/First %d 0 R\\n\", o.first)\n\t}\n\n\tif o.last >= 0 {\n\t\tcontent += fmt.Sprintf(\"\\t/Last %d 0 R\\n\", o.last)\n\t}\n\n\tcontent += \">>\\n\"\n\n\tif _, err := io.WriteString(w, content); err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\nfunc (o *OutlinesObj) SetIndexObjOutlines(index int) {\n\to.index = index\n}\n\nfunc (o *OutlinesObj) AddOutline(dest int, title string) {\n\too := &OutlineObj{title: title, dest: dest, parent: o.index, prev: o.last, next: -1}\n\to.last = o.getRoot().addObj(oo) + 1\n\tif o.first <= 0 {\n\t\to.first = o.last\n\t}\n\tif o.lastObj != nil {\n\t\to.lastObj.next = o.last\n\t}\n\to.lastObj = oo\n\to.count++\n}\n\n// AddOutlinesWithPosition add outlines with position\nfunc (o *OutlinesObj) AddOutlinesWithPosition(dest int, title string, y float64) *OutlineObj {\n\too := &OutlineObj{title: title, dest: dest, parent: o.index, prev: o.last, next: -1, height: y}\n\to.last = o.getRoot().addObj(oo) + 1\n\tif o.first <= 0 {\n\t\to.first = o.last\n\t}\n\tif o.lastObj != nil {\n\t\to.lastObj.next = o.last\n\t}\n\to.lastObj = oo\n\to.count++\n\too.index = o.last\n\treturn oo\n}\n\nfunc (o *OutlinesObj) Count() int {\n\treturn o.count\n}\n\n// OutlineObj include attribute of outline\ntype OutlineObj struct { //impl IObj\n\ttitle  string\n\tindex  int\n\tdest   int\n\tparent int\n\tprev   int\n\tnext   int\n\tfirst  int\n\tlast   int\n\theight float64\n}\n\nfunc (o *OutlineObj) init(funcGetRoot func() *GoPdf) {\n}\n\nfunc (o *OutlineObj) SetFirst(first int) {\n\to.first = first\n}\n\nfunc (o *OutlineObj) SetLast(last int) {\n\to.last = last\n}\n\nfunc (o *OutlineObj) SetPrev(prev int) {\n\to.prev = prev\n}\n\nfunc (o *OutlineObj) SetNext(next int) {\n\to.next = next\n}\n\nfunc (o *OutlineObj) SetParent(parent int) {\n\to.parent = parent\n}\n\nfunc (o *OutlineObj) GetIndex() int {\n\treturn o.index\n}\n\nfunc (o *OutlineObj) getType() string {\n\treturn \"Outline\"\n}\n\n//func (o *OutlineObj) write(w io.Writer, objID int) error {\n//\tio.WriteString(w, \"<<\\n\")\n//\tfmt.Fprintf(w, \"  /Parent %d 0 R\\n\", o.parent)\n//\tif o.prev >= 0 {\n//\t\tfmt.Fprintf(w, \"  /Prev %d 0 R\\n\", o.prev)\n//\t}\n//\tif o.next >= 0 {\n//\t\tfmt.Fprintf(w, \"  /Next %d 0 R\\n\", o.next)\n//\t}\n//\tfmt.Fprintf(w, \"  /Dest [ %d 0 R /XYZ null null null ]\\n\", o.dest)\n//\tfmt.Fprintf(w, \"  /Title <FEFF%s>\\n\", encodeUtf8(o.title))\n//\tio.WriteString(w, \">>\\n\")\n//\treturn nil\n//}\n\nfunc (o *OutlineObj) write(w io.Writer, objID int) error {\n\tio.WriteString(w, \"<<\\n\")\n\tfmt.Fprintf(w, \"  /Parent %d 0 R\\n\", o.parent)\n\tif o.prev >= 0 {\n\t\tfmt.Fprintf(w, \"  /Prev %d 0 R\\n\", o.prev)\n\t}\n\tif o.next >= 0 {\n\t\tfmt.Fprintf(w, \"  /Next %d 0 R\\n\", o.next)\n\t}\n\tif o.first > 0 {\n\t\tfmt.Fprintf(w, \"  /First %d 0 R\\n\", o.first)\n\t}\n\tif o.last > 0 {\n\t\tfmt.Fprintf(w, \"  /Last %d 0 R\\n\", o.last)\n\t}\n\tfmt.Fprintf(w, \"  /Dest [ %d 0 R /XYZ 90 %f 0 ]\\n\", o.dest, o.height)\n\tfmt.Fprintf(w, \"  /Title <FEFF%s>\\n\", encodeUtf8(o.title))\n\tio.WriteString(w, \">>\\n\")\n\treturn nil\n}\n\n// OutlineNode is a node of outline\ntype OutlineNode struct {\n\tObj      *OutlineObj\n\tChildren []*OutlineNode\n}\n\n// OutlineNodes are all nodes of outline\ntype OutlineNodes []*OutlineNode\n\n// Parse parse outline nodes\nfunc (objs OutlineNodes) Parse() {\n\tfor i, obj := range objs {\n\t\tif i == 0 {\n\t\t\tobj.Obj.SetPrev(-1)\n\t\t} else {\n\t\t\tobj.Obj.SetNext(objs[i-1].Obj.GetIndex())\n\t\t}\n\t\tif i == len(objs)-1 {\n\t\t\tobj.Obj.SetNext(-1)\n\t\t} else {\n\t\t\tobj.Obj.SetNext(objs[i+1].Obj.GetIndex())\n\t\t}\n\t\tobj.Parse()\n\t}\n\n}\n\n// Parse parse outline\nfunc (obj OutlineNode) Parse() {\n\tif obj.Children == nil || len(obj.Children) == 0 {\n\t\treturn\n\t}\n\tfor i, children := range obj.Children {\n\t\tif i == 0 {\n\t\t\tobj.Obj.SetFirst(children.Obj.GetIndex())\n\t\t\tchildren.Obj.SetPrev(-1)\n\t\t}\n\t\tif i == len(obj.Children)-1 {\n\t\t\tobj.Obj.SetLast(children.Obj.GetIndex())\n\t\t\tchildren.Obj.SetNext(-1)\n\t\t}\n\t\tif i != 0 {\n\t\t\tchildren.Obj.SetPrev(obj.Children[i-1].Obj.GetIndex())\n\t\t}\n\t\tif i != len(obj.Children)-1 {\n\t\t\tchildren.Obj.SetNext(obj.Children[i+1].Obj.GetIndex())\n\t\t}\n\t\tchildren.Obj.SetParent(obj.Obj.GetIndex())\n\t\tchildren.Parse()\n\t}\n}\n"
        },
        {
          "name": "page_obj.go",
          "type": "blob",
          "size": 2.6103515625,
          "content": "package gopdf\n\nimport (\n\t\"fmt\"\n\t\"io\"\n\t\"strings\"\n)\n\n// PageObj pdf page object\ntype PageObj struct { //impl IObj\n\tContents        string\n\tResourcesRelate string\n\tpageOption      PageOption\n\tLinkObjIds      []int\n\tgetRoot         func() *GoPdf\n}\n\nfunc (p *PageObj) init(funcGetRoot func() *GoPdf) {\n\tp.getRoot = funcGetRoot\n\tp.LinkObjIds = make([]int, 0)\n}\n\nfunc (p *PageObj) setOption(opt PageOption) {\n\tp.pageOption = opt\n}\n\nfunc (p *PageObj) write(w io.Writer, objID int) error {\n\tio.WriteString(w, \"<<\\n\")\n\tfmt.Fprintf(w, \"  /Type /%s\\n\", p.getType())\n\tio.WriteString(w, \"  /Parent 2 0 R\\n\")\n\tfmt.Fprintf(w, \"  /Resources %s\\n\", p.ResourcesRelate)\n\n\tvar err error\n\tif len(p.LinkObjIds) > 0 {\n\t\tio.WriteString(w, \"  /Annots [\")\n\t\tfor _, l := range p.LinkObjIds {\n\t\t\t_, err = fmt.Fprintf(w, \"%d 0 R \", l)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t\tio.WriteString(w, \"]\\n\")\n\t}\n\n\t/*me.buffer.WriteString(\"    /Font <<\\n\")\n\ti := 0\n\tmax := len(me.Realtes)\n\tfor i < max {\n\t\trealte := me.Realtes[i]\n\t\tme.buffer.WriteString(fmt.Sprintf(\"      /F%d %d 0 R\\n\",realte.CountOfFont + 1, realte.IndexOfObj + 1))\n\t\ti++\n\t}\n\tme.buffer.WriteString(\"    >>\\n\")*/\n\t//me.buffer.WriteString(\"  >>\\n\")\n\tfmt.Fprintf(w, \"  /Contents %s\\n\", p.Contents) //sample  Contents 8 0 R\n\tif !p.pageOption.isEmpty() {\n\t\tfmt.Fprintf(w, \" /MediaBox [ 0 0 %0.2f %0.2f ]\\n\", p.pageOption.PageSize.W, p.pageOption.PageSize.H)\n\t}\n\tif p.pageOption.isTrimBoxSet() {\n\t\ttrimBox := p.pageOption.TrimBox\n\t\tfmt.Fprintf(w, \" /TrimBox [ %0.2f %0.2f %0.2f %0.2f ]\\n\", trimBox.Left, trimBox.Top, trimBox.Right, trimBox.Bottom)\n\t}\n\tio.WriteString(w, \">>\\n\")\n\treturn nil\n}\n\nfunc (p *PageObj) writeExternalLink(w io.Writer, l linkOption, objID int) error {\n\tprotection := p.getRoot().protection()\n\turl := l.url\n\tif protection != nil {\n\t\ttmp, err := rc4Cip(protection.objectkey(objID), []byte(url))\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\turl = string(tmp)\n\t}\n\turl = strings.Replace(url, \"\\\\\", \"\\\\\\\\\", -1)\n\turl = strings.Replace(url, \"(\", \"\\\\(\", -1)\n\turl = strings.Replace(url, \")\", \"\\\\)\", -1)\n\turl = strings.Replace(url, \"\\r\", \"\\\\r\", -1)\n\n\t_, err := fmt.Fprintf(w, \"<</Type /Annot /Subtype /Link /Rect [%.2f %.2f %.2f %.2f] /Border [0 0 0] /A <</S /URI /URI (%s)>>>>\",\n\t\tl.x, l.y, l.x+l.w, l.y-l.h, url)\n\treturn err\n}\n\nfunc (p *PageObj) writeInternalLink(w io.Writer, l linkOption, anchors map[string]anchorOption) error {\n\ta, ok := anchors[l.anchor]\n\tif !ok {\n\t\treturn nil\n\t}\n\t_, err := fmt.Fprintf(w, \"<</Type /Annot /Subtype /Link /Rect [%.2f %.2f %.2f %.2f] /Border [0 0 0] /Dest [%d 0 R /XYZ 0 %.2f null]>>\",\n\t\tl.x, l.y, l.x+l.w, l.y-l.h, a.page+1, a.y)\n\treturn err\n}\n\nfunc (p *PageObj) getType() string {\n\treturn \"Page\"\n}\n"
        },
        {
          "name": "page_option.go",
          "type": "blob",
          "size": 0.3740234375,
          "content": "package gopdf\n\n// PageOption option of page\ntype PageOption struct {\n\tTrimBox  *Box\n\tPageSize *Rect\n}\n\nfunc (p PageOption) isEmpty() bool {\n\treturn p.PageSize == nil\n}\n\nfunc (p PageOption) isTrimBoxSet() bool {\n\tif p.TrimBox == nil {\n\t\treturn false\n\t}\n\tif p.TrimBox.Top == 0 && p.TrimBox.Left == 0 && p.TrimBox.Bottom == 0 && p.TrimBox.Right == 0 {\n\t\treturn false\n\t}\n\n\treturn true\n}\n"
        },
        {
          "name": "page_sizes.go",
          "type": "blob",
          "size": 2.5625,
          "content": "package gopdf\n\n// PageSizeLetter page format\nvar PageSizeLetter = &Rect{W: 612, H: 792, unitOverride: defaultUnitConfig{Unit: UnitPT}}\n\n// PageSizeLetterSmall page format\nvar PageSizeLetterSmall = &Rect{W: 612, H: 792, unitOverride: defaultUnitConfig{Unit: UnitPT}}\n\n// PageSizeTabloid page format\nvar PageSizeTabloid = &Rect{W: 792, H: 1224, unitOverride: defaultUnitConfig{Unit: UnitPT}}\n\n// PageSizeLedger page format\nvar PageSizeLedger = &Rect{W: 1224, H: 792, unitOverride: defaultUnitConfig{Unit: UnitPT}}\n\n// PageSizeLegal page format\nvar PageSizeLegal = &Rect{W: 612, H: 1008, unitOverride: defaultUnitConfig{Unit: UnitPT}}\n\n// PageSizeStatement page format\nvar PageSizeStatement = &Rect{W: 396, H: 612, unitOverride: defaultUnitConfig{Unit: UnitPT}}\n\n// PageSizeExecutive page format\nvar PageSizeExecutive = &Rect{W: 540, H: 720, unitOverride: defaultUnitConfig{Unit: UnitPT}}\n\n// PageSizeA0 page format\nvar PageSizeA0 = &Rect{W: 2384, H: 3371, unitOverride: defaultUnitConfig{Unit: UnitPT}}\n\n// PageSizeA1 page format\nvar PageSizeA1 = &Rect{W: 1685, H: 2384, unitOverride: defaultUnitConfig{Unit: UnitPT}}\n\n// PageSizeA2 page format\nvar PageSizeA2 = &Rect{W: 1190, H: 1684, unitOverride: defaultUnitConfig{Unit: UnitPT}}\n\n// PageSizeA3 page format\nvar PageSizeA3 = &Rect{W: 842, H: 1190, unitOverride: defaultUnitConfig{Unit: UnitPT}}\n\n// PageSizeA3Landscape page format\nvar PageSizeA3Landscape = &Rect{W: 1190, H: 842, unitOverride: defaultUnitConfig{Unit: UnitPT}}\n\n// PageSizeA4 page format\nvar PageSizeA4 = &Rect{W: 595, H: 842, unitOverride: defaultUnitConfig{Unit: UnitPT}}\n\n// PageSizeA4Landscape page format\nvar PageSizeA4Landscape = &Rect{W: 842, H: 595, unitOverride: defaultUnitConfig{Unit: UnitPT}}\n\n// PageSizeA4Small page format\nvar PageSizeA4Small = &Rect{W: 595, H: 842, unitOverride: defaultUnitConfig{Unit: UnitPT}}\n\n// PageSizeA5 page format\nvar PageSizeA5 = &Rect{W: 420, H: 595, unitOverride: defaultUnitConfig{Unit: UnitPT}}\n\n// PageSizeB4 page format\nvar PageSizeB4 = &Rect{W: 729, H: 1032, unitOverride: defaultUnitConfig{Unit: UnitPT}}\n\n// PageSizeB5 page format\nvar PageSizeB5 = &Rect{W: 516, H: 729, unitOverride: defaultUnitConfig{Unit: UnitPT}}\n\n// PageSizeFolio page format\nvar PageSizeFolio = &Rect{W: 612, H: 936, unitOverride: defaultUnitConfig{Unit: UnitPT}}\n\n// PageSizeQuarto page format\nvar PageSizeQuarto = &Rect{W: 610, H: 780, unitOverride: defaultUnitConfig{Unit: UnitPT}}\n\n// PageSize10x14 page format\nvar PageSize10x14 = &Rect{W: 720, H: 1008, unitOverride: defaultUnitConfig{Unit: UnitPT}}\n\n// // PageSizeEnvelope page format\n// var PageSizeEnvelope\t= Rect{W:???,H:???}\n"
        },
        {
          "name": "pages_obj.go",
          "type": "blob",
          "size": 0.783203125,
          "content": "package gopdf\n\nimport (\n\t\"fmt\"\n\t\"io\"\n)\n\n// PagesObj pdf pages object\ntype PagesObj struct { //impl IObj\n\tPageCount int\n\tKids      string\n\tgetRoot   func() *GoPdf\n}\n\nfunc (p *PagesObj) init(funcGetRoot func() *GoPdf) {\n\tp.PageCount = 0\n\tp.getRoot = funcGetRoot\n}\n\nfunc (p *PagesObj) write(w io.Writer, objID int) error {\n\n\tio.WriteString(w, \"<<\\n\")\n\tfmt.Fprintf(w, \"  /Type /%s\\n\", p.getType())\n\n\trootConfig := p.getRoot().config\n\tfmt.Fprintf(w, \"  /MediaBox [ 0 0 %0.2f %0.2f ]\\n\", rootConfig.PageSize.W, rootConfig.PageSize.H)\n\tfmt.Fprintf(w, \"  /Count %d\\n\", p.PageCount)\n\tfmt.Fprintf(w, \"  /Kids [ %s ]\\n\", p.Kids) //sample Kids [ 3 0 R ]\n\tio.WriteString(w, \">>\\n\")\n\treturn nil\n}\n\nfunc (p *PagesObj) getType() string {\n\treturn \"Pages\"\n}\n\nfunc (p *PagesObj) test() {\n\tfmt.Print(p.getType() + \"\\n\")\n}\n"
        },
        {
          "name": "pdf_dictionary_obj.go",
          "type": "blob",
          "size": 9.3388671875,
          "content": "package gopdf\n\nimport (\n\t\"compress/zlib\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"sort\"\n\n\t\"github.com/signintech/gopdf/fontmaker/core\"\n)\n\n// EntrySelectors entry selectors\nvar EntrySelectors = []int{\n\t0, 0, 1, 1, 2, 2,\n\t2, 2, 3, 3, 3, 3,\n\t3, 3, 3, 3, 4, 4,\n\t4, 4, 4, 4, 4, 4,\n\t4, 4, 4, 4, 4, 4, 4,\n}\n\n// ErrNotSupportShortIndexYet not support none short index yet\nvar ErrNotSupportShortIndexYet = errors.New(\"not support none short index yet\")\n\n// PdfDictionaryObj pdf dictionary object\ntype PdfDictionaryObj struct {\n\tPtrToSubsetFontObj *SubsetFontObj\n\t//getRoot            func() *GoPdf\n\tpdfProtection *PDFProtection\n}\n\nfunc (p *PdfDictionaryObj) init(funcGetRoot func() *GoPdf) {\n\t//p.getRoot = funcGetRoot\n}\n\nfunc (p *PdfDictionaryObj) setProtection(pr *PDFProtection) {\n\tp.pdfProtection = pr\n}\n\nfunc (p *PdfDictionaryObj) protection() *PDFProtection {\n\treturn p.pdfProtection\n}\n\nfunc (p *PdfDictionaryObj) write(w io.Writer, objID int) error {\n\tb, err := p.makeFont()\n\tif err != nil {\n\t\t//log.Panicf(\"%s\", err.Error())\n\t\treturn err\n\t}\n\n\t//zipvar buff bytes.Buffer\n\tzbuff := GetBuffer()\n\tdefer PutBuffer(zbuff)\n\n\tgzipwriter := zlib.NewWriter(zbuff)\n\t_, err = gzipwriter.Write(b)\n\tif err != nil {\n\t\treturn err\n\t}\n\tgzipwriter.Close()\n\n\tfmt.Fprintf(w, \"<</Length %d\\n\", zbuff.Len())\n\tio.WriteString(w, \"/Filter /FlateDecode\\n\")\n\tfmt.Fprintf(w, \"/Length1 %d\\n\", len(b))\n\tio.WriteString(w, \">>\\n\")\n\tio.WriteString(w, \"stream\\n\")\n\tif p.protection() != nil {\n\t\ttmp, err := rc4Cip(p.protection().objectkey(objID), zbuff.Bytes())\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tw.Write(tmp)\n\t\t//p.buffer.WriteString(\"\\n\")\n\t} else {\n\t\tw.Write(zbuff.Bytes())\n\t}\n\tio.WriteString(w, \"\\nendstream\\n\")\n\n\treturn nil\n}\n\nfunc (p *PdfDictionaryObj) getType() string {\n\treturn \"PdfDictionary\"\n}\n\n// SetPtrToSubsetFontObj set subsetFontObj pointer\nfunc (p *PdfDictionaryObj) SetPtrToSubsetFontObj(ptr *SubsetFontObj) {\n\tp.PtrToSubsetFontObj = ptr\n}\n\n// distinctInts distinct number in nn ( value in nn must sorted )\nfunc (p *PdfDictionaryObj) distinctInts(nn []int) []int {\n\tvar buff []int\n\tvar prev = -1\n\tfor _, g := range nn {\n\t\tif g == prev {\n\t\t\tcontinue\n\t\t}\n\t\tbuff = append(buff, g)\n\t\tprev = g\n\t}\n\treturn buff\n}\n\nfunc (p *PdfDictionaryObj) makeGlyfAndLocaTable() ([]byte, []int, error) {\n\tttfp := p.PtrToSubsetFontObj.GetTTFParser()\n\tvar glyf core.TableDirectoryEntry\n\n\tnumGlyphs := int(ttfp.NumGlyphs())\n\n\tglyphArray := p.completeGlyphClosure(p.PtrToSubsetFontObj.CharacterToGlyphIndex)\n\tsort.Ints(glyphArray)\n\tglyphArray = p.distinctInts(glyphArray)\n\tglyphCount := len(glyphArray)\n\n\tsize := 0\n\tfor idx := 0; idx < glyphCount; idx++ {\n\t\tsize += p.getGlyphSize(glyphArray[idx])\n\t}\n\tglyf.Length = uint(size)\n\n\tglyphTable := make([]byte, glyf.PaddedLength())\n\tlocaTable := make([]int, numGlyphs+1)\n\n\tglyphOffset := 0\n\tglyphIndex := 0\n\toldglyph := -1\n\tfor idx := 0; idx < numGlyphs; idx++ {\n\t\tlocaTable[idx] = glyphOffset\n\n\t\tif glyphIndex < glyphCount {\n\t\t\tif glyphArray[glyphIndex] == idx {\n\t\t\t\toldglyph = glyphArray[glyphIndex]\n\t\t\t\tglyphIndex++\n\t\t\t\tbytes := p.getGlyphData(idx)\n\t\t\t\tlength := len(bytes)\n\t\t\t\tif length > 0 {\n\t\t\t\t\tfor i := 0; i < length; i++ {\n\t\t\t\t\t\tglyphTable[glyphOffset+i] = bytes[i]\n\t\t\t\t\t}\n\t\t\t\t\tglyphOffset += length\n\t\t\t\t}\n\t\t\t} else if oldglyph == glyphArray[glyphIndex] {\n\t\t\t\tglyphIndex++\n\t\t\t\tbytes := p.getGlyphData(idx)\n\t\t\t\tlength := len(bytes)\n\t\t\t\tif length > 0 {\n\t\t\t\t\tfor i := 0; i < length; i++ {\n\t\t\t\t\t\tglyphTable[glyphOffset+i] = bytes[i]\n\t\t\t\t\t}\n\t\t\t\t\tglyphOffset += length\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} //end for\n\tlocaTable[numGlyphs] = glyphOffset\n\treturn glyphTable, locaTable, nil\n}\n\nfunc (p *PdfDictionaryObj) getGlyphSize(glyph int) int {\n\n\tttfp := p.PtrToSubsetFontObj.GetTTFParser()\n\tglyf := ttfp.GetTables()[\"glyf\"]\n\tstart := int(glyf.Offset + ttfp.LocaTable[glyph])\n\tnext := int(glyf.Offset + ttfp.LocaTable[glyph+1])\n\treturn next - start\n}\n\nfunc (p *PdfDictionaryObj) getGlyphData(glyph int) []byte {\n\tttfp := p.PtrToSubsetFontObj.GetTTFParser()\n\tglyf := ttfp.GetTables()[\"glyf\"]\n\tstart := int(glyf.Offset + ttfp.LocaTable[glyph])\n\tnext := int(glyf.Offset + ttfp.LocaTable[glyph+1])\n\tcount := next - start\n\tvar data []byte\n\ti := 0\n\tfor i < count {\n\t\tdata = append(data, ttfp.FontData()[start+i])\n\t\ti++\n\t}\n\treturn data\n}\n\nfunc (p *PdfDictionaryObj) makeFont() ([]byte, error) {\n\tvar buff Buff\n\tttfp := p.PtrToSubsetFontObj.GetTTFParser()\n\ttables := make(map[string]core.TableDirectoryEntry)\n\ttables[\"cvt \"] = ttfp.GetTables()[\"cvt \"] //มีช่องว่างด้วยนะ\n\ttables[\"fpgm\"] = ttfp.GetTables()[\"fpgm\"]\n\ttables[\"glyf\"] = ttfp.GetTables()[\"glyf\"]\n\ttables[\"head\"] = ttfp.GetTables()[\"head\"]\n\ttables[\"hhea\"] = ttfp.GetTables()[\"hhea\"]\n\ttables[\"hmtx\"] = ttfp.GetTables()[\"hmtx\"]\n\ttables[\"loca\"] = ttfp.GetTables()[\"loca\"]\n\ttables[\"maxp\"] = ttfp.GetTables()[\"maxp\"]\n\ttables[\"prep\"] = ttfp.GetTables()[\"prep\"]\n\ttableCount := len(tables)\n\tselector := EntrySelectors[tableCount]\n\n\tglyphTable, locaTable, err := p.makeGlyfAndLocaTable()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tWriteUInt32(&buff, 0x00010000)\n\tWriteUInt16(&buff, uint(tableCount))\n\tWriteUInt16(&buff, ((1 << uint(selector)) * 16))\n\tWriteUInt16(&buff, uint(selector))\n\tWriteUInt16(&buff, (uint(tableCount)-(1<<uint(selector)))*16)\n\n\tvar tags []string\n\tfor tag := range tables {\n\t\ttags = append(tags, tag) //copy all tag\n\t}\n\tsort.Strings(tags) //order\n\tidx := 0\n\ttablePosition := int(12 + 16*tableCount)\n\tfor idx < tableCount {\n\t\tentry := tables[tags[idx]]\n\t\t//write data\n\t\toffset := uint64(tablePosition)\n\t\tbuff.SetPosition(tablePosition)\n\t\tif tags[idx] == \"glyf\" {\n\t\t\tentry.Length = uint(len(glyphTable))\n\t\t\tentry.CheckSum = CheckSum(glyphTable)\n\t\t\tWriteBytes(&buff, glyphTable, 0, entry.PaddedLength())\n\t\t} else if tags[idx] == \"loca\" {\n\t\t\tif ttfp.IsShortIndex {\n\t\t\t\tentry.Length = uint(len(locaTable) * 2)\n\t\t\t} else {\n\t\t\t\tentry.Length = uint(len(locaTable) * 4)\n\t\t\t}\n\n\t\t\tdata := make([]byte, entry.PaddedLength())\n\t\t\tlength := len(locaTable)\n\t\t\tbyteIdx := 0\n\t\t\tif ttfp.IsShortIndex {\n\t\t\t\tfor idx := 0; idx < length; idx++ {\n\t\t\t\t\tval := locaTable[idx] / 2\n\t\t\t\t\tdata[byteIdx] = byte(val >> 8)\n\t\t\t\t\tbyteIdx++\n\t\t\t\t\tdata[byteIdx] = byte(val)\n\t\t\t\t\tbyteIdx++\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfor idx := 0; idx < length; idx++ {\n\t\t\t\t\tval := locaTable[idx]\n\t\t\t\t\tdata[byteIdx] = byte(val >> 24)\n\t\t\t\t\tbyteIdx++\n\t\t\t\t\tdata[byteIdx] = byte(val >> 16)\n\t\t\t\t\tbyteIdx++\n\t\t\t\t\tdata[byteIdx] = byte(val >> 8)\n\t\t\t\t\tbyteIdx++\n\t\t\t\t\tdata[byteIdx] = byte(val)\n\t\t\t\t\tbyteIdx++\n\t\t\t\t}\n\t\t\t}\n\t\t\tentry.CheckSum = CheckSum(data)\n\t\t\tWriteBytes(&buff, data, 0, len(data))\n\t\t} else {\n\t\t\tWriteBytes(&buff, ttfp.FontData(), int(entry.Offset), entry.PaddedLength())\n\t\t}\n\t\tendPosition := buff.Position()\n\t\ttablePosition = endPosition\n\n\t\t//write table\n\t\tbuff.SetPosition(idx*16 + 12)\n\t\tWriteTag(&buff, tags[idx])\n\t\tWriteUInt32(&buff, uint(entry.CheckSum))\n\t\tWriteUInt32(&buff, uint(offset)) //offset\n\t\tWriteUInt32(&buff, uint(entry.Length))\n\n\t\ttablePosition = endPosition\n\t\tidx++\n\t}\n\t//DebugSubType(buff.Bytes())\n\t//me.buffer.Write(buff.Bytes())\n\treturn buff.Bytes(), nil\n}\n\nfunc (p *PdfDictionaryObj) completeGlyphClosure(mapOfglyphs *MapOfCharacterToGlyphIndex) []int {\n\tvar glyphArray []int\n\t//copy\n\tisContainZero := false\n\tglyphs := mapOfglyphs.AllVals()\n\tfor _, v := range glyphs {\n\t\tglyphArray = append(glyphArray, int(v))\n\t\tif v == 0 {\n\t\t\tisContainZero = true\n\t\t}\n\t}\n\tif !isContainZero {\n\t\tglyphArray = append(glyphArray, 0)\n\t}\n\n\ti := 0\n\tcount := len(glyphs)\n\tfor i < count {\n\t\tp.AddCompositeGlyphs(&glyphArray, glyphArray[i])\n\t\ti++\n\t}\n\treturn glyphArray\n}\n\n// AddCompositeGlyphs add composite glyph\n// composite glyph is a Unicode entity that can be defined as a sequence of one or more other characters.\nfunc (p *PdfDictionaryObj) AddCompositeGlyphs(glyphArray *[]int, glyph int) {\n\tstart := p.GetOffset(int(glyph))\n\tif start == p.GetOffset(int(glyph)+1) {\n\t\treturn\n\t}\n\n\toffset := start\n\tttfp := p.PtrToSubsetFontObj.GetTTFParser()\n\tfontData := ttfp.FontData()\n\tnumContours, step := ReadShortFromByte(fontData, offset)\n\toffset += step\n\tif numContours >= 0 {\n\t\treturn\n\t}\n\n\toffset += 8\n\tfor {\n\t\tflags, step1 := ReadUShortFromByte(fontData, offset)\n\t\toffset += step1\n\t\tcGlyph, step2 := ReadUShortFromByte(fontData, offset)\n\t\toffset += step2\n\t\t//check cGlyph is contain in glyphArray?\n\t\tglyphContainsKey := false\n\t\tfor _, g := range *glyphArray {\n\t\t\tif g == int(cGlyph) {\n\t\t\t\tglyphContainsKey = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif !glyphContainsKey {\n\t\t\t*glyphArray = append(*glyphArray, int(cGlyph))\n\t\t}\n\n\t\tif (flags & moreComponents) == 0 {\n\t\t\treturn\n\t\t}\n\t\toffsetAppend := 4\n\t\tif (flags & arg1and2areWords) == 0 {\n\t\t\toffsetAppend = 2\n\t\t}\n\t\tif (flags & hasScale) != 0 {\n\t\t\toffsetAppend += 2\n\t\t} else if (flags & xAndYScale) != 0 {\n\t\t\toffsetAppend += 4\n\t\t}\n\t\tif (flags & twoByTwo) != 0 {\n\t\t\toffsetAppend += 8\n\t\t}\n\t\toffset += offsetAppend\n\t}\n}\n\nconst hasScale = 8\nconst moreComponents = 32\nconst arg1and2areWords = 1\nconst xAndYScale = 64\nconst twoByTwo = 128\n\n// GetOffset get offset from glyf table\nfunc (p *PdfDictionaryObj) GetOffset(glyph int) int {\n\tttfp := p.PtrToSubsetFontObj.GetTTFParser()\n\tglyf := ttfp.GetTables()[\"glyf\"]\n\toffset := int(glyf.Offset + ttfp.LocaTable[glyph])\n\treturn offset\n}\n\n// CheckSum check sum\nfunc CheckSum(data []byte) uint {\n\n\tvar byte3, byte2, byte1, byte0 uint64\n\tbyte3 = 0\n\tbyte2 = 0\n\tbyte1 = 0\n\tbyte0 = 0\n\tlength := len(data)\n\ti := 0\n\tfor i < length {\n\t\tbyte3 += uint64(data[i])\n\t\ti++\n\t\tbyte2 += uint64(data[i])\n\t\ti++\n\t\tbyte1 += uint64(data[i])\n\t\ti++\n\t\tbyte0 += uint64(data[i])\n\t\ti++\n\t}\n\t//var result uint32\n\tresult := uint32(byte3<<24) + uint32(byte2<<16) + uint32(byte1<<8) + uint32(byte0)\n\treturn uint(result)\n}\n"
        },
        {
          "name": "pdf_info_obj.go",
          "type": "blob",
          "size": 0.6611328125,
          "content": "package gopdf\n\nimport \"time\"\n\n// PdfInfo Document Information Dictionary\ntype PdfInfo struct {\n\tTitle        string    // The document’s title\n\tAuthor       string    // The name of the person who created the document\n\tSubject      string    // The subject of the document\n\tCreator      string    // If the document was converted to PDF from another format, the name of the application which created the original document\n\tProducer     string    // If the document was converted to PDF from another format, the name of the application that converted the original document to PDF\n\tCreationDate time.Time // The date and time the document was created, in human-readable form\n}\n"
        },
        {
          "name": "pdf_protection.go",
          "type": "blob",
          "size": 3.8798828125,
          "content": "package gopdf\n\nimport (\n\t\"crypto/md5\"\n\t\"crypto/rc4\"\n\t\"encoding/binary\"\n\t\"math/rand\"\n\t\"time\"\n)\n\nconst (\n\t//PermissionsPrint setProtection print\n\tPermissionsPrint = 4\n\t//PermissionsModify setProtection modify\n\tPermissionsModify = 8\n\t//PermissionsCopy setProtection copy\n\tPermissionsCopy = 16\n\t//PermissionsAnnotForms setProtection  annot-forms\n\tPermissionsAnnotForms = 32\n)\n\nvar protectionPadding = []byte{\n\t0x28, 0xBF, 0x4E, 0x5E, 0x4E, 0x75, 0x8A, 0x41, 0x64, 0x00, 0x4E, 0x56, 0xFF, 0xFA, 0x01, 0x08,\n\t0x2E, 0x2E, 0x00, 0xB6, 0xD0, 0x68, 0x3E, 0x80, 0x2F, 0x0C, 0xA9, 0xFE, 0x64, 0x53, 0x69, 0x7A,\n}\n\n// PDFProtection protection in pdf\ntype PDFProtection struct {\n\tencrypted bool   //whether document is protected\n\tuValue    []byte //U entry in pdf document\n\toValue    []byte //O entry in pdf document\n\tpValue    int    //P entry in pdf document\n\t//var $enc_obj_id;         //encryption object id\n\tencryptionKey []byte\n}\n\n// SetProtection set protection information\nfunc (p *PDFProtection) SetProtection(permissions int, userPass []byte, ownerPass []byte) error {\n\treturn p.setProtection(permissions, userPass, ownerPass)\n}\n\nfunc (p *PDFProtection) setProtection(permissions int, userPass []byte, ownerPass []byte) error {\n\tprotection := 192 | permissions\n\tif ownerPass == nil || len(ownerPass) == 0 {\n\t\townerPass = p.randomPass(24)\n\t}\n\treturn p.generateEncryptionKey(userPass, ownerPass, protection)\n}\n\nfunc (p *PDFProtection) generateEncryptionKey(userPass []byte, ownerPass []byte, protection int) error {\n\n\tuserPass = append(userPass, protectionPadding...)\n\tuserPassWithPadding := userPass[0:32]\n\townerPass = append(ownerPass, protectionPadding...)\n\townerPassWithPadding := ownerPass[0:32]\n\n\t//oValue\n\toValue, err := p.createOValue(userPassWithPadding, ownerPassWithPadding)\n\tif err != nil {\n\t\treturn err\n\t}\n\tp.oValue = oValue\n\n\tuValue, err := p.createUValue(userPassWithPadding, oValue, protection)\n\tif err != nil {\n\t\treturn err\n\t}\n\tp.uValue = uValue\n\tp.pValue = -((protection ^ 255) + 1)\n\n\treturn nil\n}\n\n// EncryptionObj get Encryption Object\nfunc (p *PDFProtection) EncryptionObj() *EncryptionObj {\n\treturn p.encryptionObj()\n}\n\nfunc (p *PDFProtection) encryptionObj() *EncryptionObj {\n\tvar en EncryptionObj\n\ten.oValue = p.oValue\n\ten.pValue = p.pValue\n\ten.uValue = p.uValue\n\treturn &en\n}\n\nfunc (p *PDFProtection) createOValue(userPassWithPadding []byte, ownerPassWithPadding []byte) ([]byte, error) {\n\ttmp := md5.Sum(ownerPassWithPadding)\n\townerRC4key := tmp[0:5]\n\tcip, err := rc4.NewCipher(ownerRC4key)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdest := make([]byte, len(userPassWithPadding))\n\tcip.XORKeyStream(dest, userPassWithPadding)\n\treturn dest, nil\n}\n\nfunc (p *PDFProtection) createUValue(userPassWithPadding []byte, oValue []byte, protection int) ([]byte, error) {\n\tm := md5.New()\n\tm.Write(userPassWithPadding)\n\tm.Write(oValue)\n\tm.Write([]byte{byte(protection), byte(0xff), byte(0xff), byte(0xff)})\n\n\ttmp2 := m.Sum(nil)\n\tp.encryptionKey = tmp2[0:5]\n\tcip, err := rc4.NewCipher(p.encryptionKey)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdest := make([]byte, len(protectionPadding))\n\tcip.XORKeyStream(dest, protectionPadding)\n\treturn dest, nil\n}\n\nfunc (p *PDFProtection) randomPass(strlen int) []byte {\n\trand.Seed(time.Now().UTC().UnixNano())\n\tconst chars = \"abcdef0123456789\"\n\tresult := make([]byte, strlen)\n\tfor i := 0; i < strlen; i++ {\n\t\tresult[i] = chars[rand.Intn(len(chars))]\n\t}\n\treturn result\n}\n\n// Objectkey create object key from ObjID\nfunc (p *PDFProtection) Objectkey(objID int) []byte {\n\treturn p.objectkey(objID)\n}\n\nfunc (p *PDFProtection) objectkey(n int) []byte {\n\ttmp := make([]byte, 8, 8)\n\tbinary.LittleEndian.PutUint32(tmp, uint32(n))\n\ttmp2 := append(p.encryptionKey, tmp[0], tmp[1], tmp[2], 0, 0)\n\ttmp3 := md5.Sum(tmp2)\n\treturn tmp3[0:10]\n}\n\nfunc rc4Cip(key []byte, src []byte) ([]byte, error) {\n\tcip, err := rc4.NewCipher(key)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdest := make([]byte, len(src))\n\tcip.XORKeyStream(dest, src)\n\treturn dest, nil\n}\n"
        },
        {
          "name": "pdf_protection_test.go",
          "type": "blob",
          "size": 1.447265625,
          "content": "package gopdf\n\nimport \"testing\"\n\nfunc TestSetProtection(t *testing.T) {\n\n\tvar pp PDFProtection\n\tpp.setProtection(PermissionsPrint|PermissionsCopy|PermissionsModify, []byte(\"5555\"), []byte(\"1234\"))\n\tvar realOValue = []byte{\n\t\t0xbb, 0xb8, 0x04, 0x6d, 0x96, 0xa9, 0x9a, 0x23, 0x46, 0xa9, 0x41, 0x21, 0x06, 0x8c, 0xad, 0x4f, 0x83, 0x5e, 0x5d, 0x0e, 0xcb, 0xb6, 0x20, 0xa8, 0xb7, 0xa3, 0x16, 0x13, 0x3c, 0x8f, 0x02, 0x91,\n\t}\n\n\tvar realUValue = []byte{\n\t\t0x19, 0x27, 0x67, 0x2a, 0x4f, 0x28, 0x64, 0xb3, 0x8b, 0x8b, 0x40, 0x44, 0x2, 0xa2, 0x68, 0x72, 0x2f, 0xe1, 0xb9, 0xf8, 0x4, 0x24, 0x81, 0xe, 0xe8, 0x84, 0xd8, 0x30, 0xd5, 0xe9, 0x8f, 0x24,\n\t}\n\n\tif !isSliceEq(pp.oValue, realOValue) {\n\t\tt.Errorf(\"wrong oValue\")\n\t\treturn\n\t}\n\n\tif !isSliceEq(pp.uValue, realUValue) {\n\t\tt.Errorf(\"wrong oValue\")\n\t\treturn\n\t}\n\n\tif pp.pValue != -36 {\n\t\tt.Errorf(\"wrong pValue\")\n\t\treturn\n\t}\n\n\tvar realObjKey4 = []byte{\n\t\t0xb3, 0x9, 0xe6, 0x55, 0xd8, 0x23, 0xbf, 0xbb, 0xc5, 0xdf,\n\t}\n\tif !isSliceEq(pp.objectkey(4), realObjKey4) {\n\t\tt.Errorf(\"wrong objectkey 4\")\n\t\treturn\n\t}\n\n\tvar realObjKey5 = []byte{\n\t\t0xc4, 0x2c, 0x3e, 0x35, 0x92, 0xbe, 0x5e, 0x25, 0xdd, 0x1b,\n\t}\n\tif !isSliceEq(pp.objectkey(5), realObjKey5) {\n\t\tt.Errorf(\"wrong objectkey 5\")\n\t\treturn\n\t}\n}\n\nfunc isSliceEq(a, b []byte) bool {\n\n\tif a == nil && b == nil {\n\t\treturn true\n\t}\n\n\tif a == nil || b == nil {\n\t\treturn false\n\t}\n\n\tif len(a) != len(b) {\n\t\treturn false\n\t}\n\n\tfor i := range a {\n\t\tif a[i] != b[i] {\n\t\t\treturn false\n\t\t}\n\t}\n\n\treturn true\n}\n"
        },
        {
          "name": "placeholder.go",
          "type": "blob",
          "size": 0.28125,
          "content": "package gopdf\n\ntype PlaceHolderTextOption struct {\n\t//Left 8 , Right 2 ,Center  16\n\tAlign int\n}\n\ntype placeHolderTextInfo struct {\n\tindexOfContent   int\n\tindexInContent   int\n\tfontISubset      *SubsetFontObj\n\tplaceHolderWidth float64\n\tfontSize         float64\n\tcharSpacing      float64\n}\n"
        },
        {
          "name": "placeholder_test.go",
          "type": "blob",
          "size": 2.603515625,
          "content": "package gopdf\n\nimport (\n\t\"fmt\"\n\t\"log\"\n\t\"testing\"\n)\n\nfunc TestPlaceHolderText(t *testing.T) {\n\terr := initTesting()\n\tif err != nil {\n\t\tt.Error(err)\n\t\treturn\n\t}\n\n\tpdf := GoPdf{}\n\tpdf.Start(Config{PageSize: *PageSizeA4})\n\terr = pdf.AddTTFFont(\"LiberationSerif-Regular\", \"./test/res/LiberationSerif-Regular.ttf\")\n\tif err != nil {\n\t\tt.Error(err)\n\t\treturn\n\t}\n\n\tfor i := 0; i < 5; i++ {\n\t\tpdf.AddPage()\n\t\terr = pdf.SetFont(\"LiberationSerif-Regular\", \"\", 14)\n\t\tif err != nil {\n\t\t\tlog.Print(err.Error())\n\t\t\treturn\n\t\t}\n\t\tpdf.Br(10)\n\t\tpdf.SetX(250)\n\t\terr := pdf.Text(fmt.Sprintf(\"%d of \", i+1))\n\t\tif err != nil {\n\t\t\tlog.Print(err.Error())\n\t\t\treturn\n\t\t}\n\t\terr = pdf.PlaceHolderText(\"totalnumber\", 30) //<-- create PlaceHolder\n\t\tif err != nil {\n\t\t\tlog.Print(err.Error())\n\t\t\treturn\n\t\t}\n\t\tpdf.Br(20)\n\n\t\terr = pdf.SetFont(\"LiberationSerif-Regular\", \"\", 11)\n\t\tif err != nil {\n\t\t\tlog.Print(err.Error())\n\t\t\treturn\n\t\t}\n\t\tpdf.Text(\"content content content content content contents...\")\n\t}\n\n\terr = pdf.FillInPlaceHoldText(\"totalnumber\", fmt.Sprintf(\"%d\", 5), Left) //<-- fillin text to PlaceHolder\n\tif err != nil {\n\t\tlog.Print(err.Error())\n\t\treturn\n\t}\n\n\tpdf.WritePdf(\"./test/out/placeholder_text.pdf\")\n}\n\nfunc TestPlaceHolderText2(t *testing.T) {\n\terr := initTesting()\n\tif err != nil {\n\t\tt.Error(err)\n\t\treturn\n\t}\n\n\tpdf := GoPdf{}\n\tpdf.Start(Config{PageSize: *PageSizeA4})\n\terr = pdf.AddTTFFont(\"LiberationSerif-Regular\", \"./test/res/LiberationSerif-Regular.ttf\")\n\tif err != nil {\n\t\tt.Error(err)\n\t\treturn\n\t}\n\n\tfor i := 0; i < 5; i++ {\n\t\tpdf.AddPage()\n\t\terr = pdf.SetFont(\"LiberationSerif-Regular\", \"\", 14)\n\t\tif err != nil {\n\t\t\tlog.Print(err.Error())\n\t\t\treturn\n\t\t}\n\t\tpdf.Br(10)\n\t\tpdf.SetX(250)\n\t\tpdf.Text(\"page\")\n\t\tpagenumberPH := fmt.Sprintf(\"pagenumber_%d\", i)\n\t\terr = pdf.PlaceHolderText(pagenumberPH, 20) //<-- create PlaceHolder\n\t\tif err != nil {\n\t\t\tlog.Print(err.Error())\n\t\t\treturn\n\t\t}\n\n\t\terr := pdf.Text(\"of\")\n\t\tif err != nil {\n\t\t\tlog.Print(err.Error())\n\t\t\treturn\n\t\t}\n\t\terr = pdf.PlaceHolderText(\"totalnumber\", 20) //<-- create PlaceHolder\n\t\tif err != nil {\n\t\t\tlog.Print(err.Error())\n\t\t\treturn\n\t\t}\n\t\tpdf.Br(20)\n\n\t\terr = pdf.SetFont(\"LiberationSerif-Regular\", \"\", 11)\n\t\tif err != nil {\n\t\t\tlog.Print(err.Error())\n\t\t\treturn\n\t\t}\n\t\tpdf.Text(\"content content content content content contents...\")\n\n\t\terr = pdf.FillInPlaceHoldText(pagenumberPH, fmt.Sprintf(\"%d\", i+1), Center) //<-- fillin text to PlaceHolder\n\t\tif err != nil {\n\t\t\tlog.Print(err.Error())\n\t\t\treturn\n\t\t}\n\n\t}\n\n\terr = pdf.FillInPlaceHoldText(\"totalnumber\", fmt.Sprintf(\"%d\", 5), Center) //<-- fillin text to PlaceHolder\n\tif err != nil {\n\t\tlog.Print(err.Error())\n\t\treturn\n\t}\n\n\tpdf.WritePdf(\"./test/out/placeholder_text_2.pdf\")\n}\n"
        },
        {
          "name": "point.go",
          "type": "blob",
          "size": 0.0947265625,
          "content": "package gopdf\n\n// Point a point in a two-dimensional\ntype Point struct {\n\tX float64\n\tY float64\n}\n"
        },
        {
          "name": "procset_obj.go",
          "type": "blob",
          "size": 2.4501953125,
          "content": "package gopdf\n\nimport (\n\t\"fmt\"\n\t\"io\"\n)\n\n// ProcSetObj is a PDF procSet object.\ntype ProcSetObj struct {\n\t//Font\n\tRelates             RelateFonts\n\tRelateXobjs         RelateXobjects\n\tExtGStates          []ExtGS\n\tImportedTemplateIds map[string]int\n\tgetRoot             func() *GoPdf\n}\n\nfunc (pr *ProcSetObj) init(funcGetRoot func() *GoPdf) {\n\tpr.getRoot = funcGetRoot\n\tpr.ImportedTemplateIds = make(map[string]int, 0)\n\tpr.ExtGStates = make([]ExtGS, 0)\n}\n\nfunc (pr *ProcSetObj) write(w io.Writer, objID int) error {\n\tcontent := \"<<\\n\"\n\tcontent += \"\\t/ProcSet [/PDF /Text /ImageB /ImageC /ImageI]\\n\"\n\n\tfonts := \"\\t/Font <<\\n\"\n\tfor _, relate := range pr.Relates {\n\t\tfonts += fmt.Sprintf(\"\\t\\t/F%d %d 0 R\\n\", relate.CountOfFont+1, relate.IndexOfObj+1)\n\t}\n\tfonts += \"\\t>>\\n\"\n\n\tcontent += fonts\n\n\txobjects := \"\\t/XObject <<\\n\"\n\tfor _, XObject := range pr.RelateXobjs {\n\t\txobjects += fmt.Sprintf(\"\\t\\t/I%d %d 0 R\\n\", XObject.IndexOfObj+1, XObject.IndexOfObj+1)\n\t}\n\t// Write imported template name and their ids\n\tfor tplName, objID := range pr.ImportedTemplateIds {\n\t\txobjects += fmt.Sprintf(\"\\t\\t%s %d 0 R\\n\", tplName, objID)\n\t}\n\txobjects += \"\\t>>\\n\"\n\n\tcontent += xobjects\n\n\textGStates := \"\\t/ExtGState <<\\n\"\n\tfor _, extGState := range pr.ExtGStates {\n\t\textGStates += fmt.Sprintf(\"\\t\\t/GS%d %d 0 R\\n\", extGState.Index+1, extGState.Index+1)\n\t}\n\textGStates += \"\\t>>\\n\"\n\n\tcontent += extGStates\n\n\tcontent += \">>\\n\"\n\n\tif _, err := io.WriteString(w, content); err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\nfunc (pr *ProcSetObj) getType() string {\n\treturn \"ProcSet\"\n}\n\n// RelateFonts is a slice of RelateFont.\ntype RelateFonts []RelateFont\n\n// IsContainsFamily checks if font family exists.\nfunc (re *RelateFonts) IsContainsFamily(family string) bool {\n\tfor _, rf := range *re {\n\t\tif rf.Family == family {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\n// IsContainsFamilyAndStyle checks if font with same name and style already exists .\nfunc (re *RelateFonts) IsContainsFamilyAndStyle(family string, style int) bool {\n\tfor _, rf := range *re {\n\t\tif rf.Family == family && rf.Style == style {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\n// RelateFont is a metadata index for fonts?\ntype RelateFont struct {\n\tFamily string\n\t//etc /F1\n\tCountOfFont int\n\t//etc  5 0 R\n\tIndexOfObj int\n\tStyle      int // Regular|Bold|Italic\n}\n\n// RelateXobjects is a slice of RelateXobject.\ntype RelateXobjects []RelateXobject\n\n// RelateXobject is an index for ???\ntype RelateXobject struct {\n\tIndexOfObj int\n}\n\n// ExtGS is ???\ntype ExtGS struct {\n\tIndex int\n}\n"
        },
        {
          "name": "rect.go",
          "type": "blob",
          "size": 1.232421875,
          "content": "package gopdf\n\n// Rect defines a rectangle.\ntype Rect struct {\n\tW            float64\n\tH            float64\n\tunitOverride defaultUnitConfig\n}\n\n// PointsToUnits converts the rectangles width and height to Units. When this is called it is assumed the values of the rectangle are in Points\nfunc (rect *Rect) PointsToUnits(t int) (r *Rect) {\n\tif rect == nil {\n\t\treturn\n\t}\n\n\tunitCfg := defaultUnitConfig{Unit: t}\n\tif rect.unitOverride.getUnit() != UnitUnset {\n\t\tunitCfg = rect.unitOverride\n\t}\n\n\tr = &Rect{W: rect.W, H: rect.H}\n\tpointsToUnitsVar(unitCfg, &r.W, &r.H)\n\treturn\n}\n\n// UnitsToPoints converts the rectanlges width and height to Points. When this is called it is assumed the values of the rectangle are in Units\nfunc (rect *Rect) UnitsToPoints(t int) (r *Rect) {\n\tif rect == nil {\n\t\treturn\n\t}\n\n\tunitCfg := defaultUnitConfig{Unit: t}\n\tif rect.unitOverride.getUnit() != UnitUnset {\n\t\tunitCfg = rect.unitOverride\n\t}\n\n\tr = &Rect{W: rect.W, H: rect.H}\n\tunitsToPointsVar(unitCfg, &r.W, &r.H)\n\treturn\n}\n\nfunc (rect *Rect) unitsToPoints(unitCfg unitConfigurator) (r *Rect) {\n\tif rect == nil {\n\t\treturn\n\t}\n\tif rect.unitOverride.getUnit() != UnitUnset {\n\t\tunitCfg = rect.unitOverride\n\t}\n\tr = &Rect{W: rect.W, H: rect.H}\n\tunitsToPointsVar(unitCfg, &r.W, &r.H)\n\treturn\n}\n"
        },
        {
          "name": "smask_obj.go",
          "type": "blob",
          "size": 2.5654296875,
          "content": "package gopdf\n\nimport (\n\t\"fmt\"\n\t\"io\"\n\t\"sync\"\n)\n\ntype SMaskSubtypes string\n\nconst (\n\tSMaskAlphaSubtype      = \"/Alpha\"\n\tSMaskLuminositySubtype = \"/Luminosity\"\n)\n\n// SMask smask\ntype SMask struct {\n\timgInfo\n\tdata []byte\n\t//getRoot func() *GoPdf\n\tpdfProtection                 *PDFProtection\n\tIndex                         int\n\tTransparencyXObjectGroupIndex int\n\tS                             string\n}\n\ntype SMaskOptions struct {\n\tTransparencyXObjectGroupIndex int\n\tSubtype                       SMaskSubtypes\n}\n\nfunc (smask SMaskOptions) GetId() string {\n\tid := fmt.Sprintf(\"S_%s;G_%d_0_R\", smask.Subtype, smask.TransparencyXObjectGroupIndex)\n\n\treturn id\n}\n\nfunc GetCachedMask(opts SMaskOptions, gp *GoPdf) SMask {\n\tsmask, ok := gp.curr.sMasksMap.Find(opts)\n\tif !ok {\n\t\tsmask = SMask{\n\t\t\tS:                             string(opts.Subtype),\n\t\t\tTransparencyXObjectGroupIndex: opts.TransparencyXObjectGroupIndex,\n\t\t}\n\t\tsmask.Index = gp.addObj(smask)\n\n\t\tgp.curr.sMasksMap.Save(opts.GetId(), smask)\n\t}\n\n\treturn smask\n}\n\nfunc (s SMask) init(func() *GoPdf) {}\n\nfunc (s *SMask) setProtection(p *PDFProtection) {\n\ts.pdfProtection = p\n}\n\nfunc (s SMask) protection() *PDFProtection {\n\treturn s.pdfProtection\n}\n\nfunc (s SMask) getType() string {\n\treturn \"Mask\"\n}\n\nfunc (s SMask) write(w io.Writer, objID int) error {\n\tif s.TransparencyXObjectGroupIndex != 0 {\n\t\tcontent := \"<<\\n\"\n\t\tcontent += \"\\t/Type /Mask\\n\"\n\t\tcontent += fmt.Sprintf(\"\\t/S %s\\n\", s.S)\n\t\tcontent += fmt.Sprintf(\"\\t/G %d 0 R\\n\", s.TransparencyXObjectGroupIndex+1)\n\t\tcontent += \">>\\n\"\n\n\t\tif _, err := io.WriteString(w, content); err != nil {\n\t\t\treturn err\n\t\t}\n\t} else {\n\t\terr := writeImgProps(w, s.imgInfo, false)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tfmt.Fprintf(w, \"/Length %d\\n>>\\n\", len(s.data)) // /Length 62303>>\\n\n\t\tio.WriteString(w, \"stream\\n\")\n\t\tif s.protection() != nil {\n\t\t\ttmp, err := rc4Cip(s.protection().objectkey(objID), s.data)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tw.Write(tmp)\n\t\t\tio.WriteString(w, \"\\n\")\n\t\t} else {\n\t\t\tw.Write(s.data)\n\t\t}\n\t\tio.WriteString(w, \"\\nendstream\\n\")\n\t}\n\n\treturn nil\n}\n\ntype SMaskMap struct {\n\tsyncer sync.Mutex\n\ttable  map[string]SMask\n}\n\nfunc NewSMaskMap() SMaskMap {\n\treturn SMaskMap{\n\t\tsyncer: sync.Mutex{},\n\t\ttable:  make(map[string]SMask),\n\t}\n}\n\nfunc (smask *SMaskMap) Find(sMask SMaskOptions) (SMask, bool) {\n\tkey := sMask.GetId()\n\n\tsmask.syncer.Lock()\n\tdefer smask.syncer.Unlock()\n\n\tt, ok := smask.table[key]\n\tif !ok {\n\t\treturn SMask{}, false\n\t}\n\n\treturn t, ok\n\n}\n\nfunc (smask *SMaskMap) Save(id string, sMask SMask) SMask {\n\tsmask.syncer.Lock()\n\tdefer smask.syncer.Unlock()\n\n\tsmask.table[id] = sMask\n\n\treturn sMask\n}\n"
        },
        {
          "name": "strhelper.go",
          "type": "blob",
          "size": 1.2880859375,
          "content": "package gopdf\n\nimport (\n\t\"math/big\"\n\t\"strings\"\n)\n\n// StrHelperGetStringWidth get string width\nfunc StrHelperGetStringWidth(str string, fontSize int, ifont IFont) float64 {\n\treturn StrHelperGetStringWidthPrecise(str, float64(fontSize), ifont)\n}\n\n// StrHelperGetStringWidthPrecise get string width with real number fontSize\nfunc StrHelperGetStringWidthPrecise(str string, fontSize float64, ifont IFont) float64 {\n\n\tw := 0\n\tbs := []byte(str)\n\ti := 0\n\tmax := len(bs)\n\tfor i < max {\n\t\tw += ifont.GetCw()[bs[i]]\n\t\ti++\n\t}\n\treturn float64(w) * (float64(fontSize) / 1000.0)\n}\n\n// CreateEmbeddedFontSubsetName create Embedded font (subset font) name\nfunc CreateEmbeddedFontSubsetName(name string) string {\n\tname = strings.Replace(name, \" \", \"+\", -1)\n\tname = strings.Replace(name, \"/\", \"+\", -1)\n\treturn name\n}\n\n// ReadShortFromByte read short from byte array\nfunc ReadShortFromByte(data []byte, offset int) (int64, int) {\n\tbuff := data[offset : offset+2]\n\tnum := big.NewInt(0)\n\tnum.SetBytes(buff)\n\tu := num.Uint64()\n\tvar v int64\n\tif u >= 0x8000 {\n\t\tv = int64(u) - 65536\n\t} else {\n\t\tv = int64(u)\n\t}\n\treturn v, 2\n}\n\n// ReadUShortFromByte read ushort from byte array\nfunc ReadUShortFromByte(data []byte, offset int) (uint64, int) {\n\tbuff := data[offset : offset+2]\n\tnum := big.NewInt(0)\n\tnum.SetBytes(buff)\n\treturn num.Uint64(), 2\n}\n"
        },
        {
          "name": "style.go",
          "type": "blob",
          "size": 0.345703125,
          "content": "package gopdf\n\ntype PaintStyle string\n\nconst (\n\tDrawPaintStyle     PaintStyle = \"S\"\n\tFillPaintStyle     PaintStyle = \"f\"\n\tDrawFillPaintStyle PaintStyle = \"B\"\n)\n\nfunc parseStyle(style string) PaintStyle {\n\top := DrawPaintStyle\n\tif style == \"F\" {\n\t\top = FillPaintStyle\n\t} else if style == \"FD\" || style == \"DF\" {\n\t\top = DrawFillPaintStyle\n\t}\n\n\treturn op\n}\n"
        },
        {
          "name": "subfont_descriptor_obj.go",
          "type": "blob",
          "size": 1.9892578125,
          "content": "package gopdf\n\nimport (\n\t\"fmt\"\n\t\"io\"\n\n\t\"github.com/signintech/gopdf/fontmaker/core\"\n)\n\n// SubfontDescriptorObj pdf subfont descriptorObj object\ntype SubfontDescriptorObj struct {\n\tPtrToSubsetFontObj    *SubsetFontObj\n\tindexObjPdfDictionary int\n}\n\nfunc (s *SubfontDescriptorObj) init(func() *GoPdf) {}\n\nfunc (s *SubfontDescriptorObj) getType() string {\n\treturn \"SubFontDescriptor\"\n}\n\nfunc (s *SubfontDescriptorObj) write(w io.Writer, objID int) error {\n\tttfp := s.PtrToSubsetFontObj.GetTTFParser()\n\t//fmt.Printf(\"-->%d\\n\", ttfp.UnitsPerEm())\n\tio.WriteString(w, \"<<\\n\")\n\tio.WriteString(w, \"/Type /FontDescriptor\\n\")\n\tfmt.Fprintf(w, \"/Ascent %d\\n\", DesignUnitsToPdf(ttfp.Ascender(), ttfp.UnitsPerEm()))\n\tfmt.Fprintf(w, \"/CapHeight %d\\n\", DesignUnitsToPdf(ttfp.CapHeight(), ttfp.UnitsPerEm()))\n\tfmt.Fprintf(w, \"/Descent %d\\n\", DesignUnitsToPdf(ttfp.Descender(), ttfp.UnitsPerEm()))\n\tfmt.Fprintf(w, \"/Flags %d\\n\", ttfp.Flag())\n\tfmt.Fprintf(w, \"/FontBBox [%d %d %d %d]\\n\",\n\t\tDesignUnitsToPdf(ttfp.XMin(), ttfp.UnitsPerEm()),\n\t\tDesignUnitsToPdf(ttfp.YMin(), ttfp.UnitsPerEm()),\n\t\tDesignUnitsToPdf(ttfp.XMax(), ttfp.UnitsPerEm()),\n\t\tDesignUnitsToPdf(ttfp.YMax(), ttfp.UnitsPerEm()),\n\t)\n\tfmt.Fprintf(w, \"/FontFile2 %d 0 R\\n\", s.indexObjPdfDictionary+1)\n\tfmt.Fprintf(w, \"/FontName /%s\\n\", CreateEmbeddedFontSubsetName(s.PtrToSubsetFontObj.GetFamily()))\n\tfmt.Fprintf(w, \"/ItalicAngle %d\\n\", ttfp.ItalicAngle())\n\tio.WriteString(w, \"/StemV 0\\n\")\n\tfmt.Fprintf(w, \"/XHeight %d\\n\", DesignUnitsToPdf(ttfp.XHeight(), ttfp.UnitsPerEm()))\n\tio.WriteString(w, \">>\\n\")\n\treturn nil\n}\n\n// SetIndexObjPdfDictionary set PdfDictionary pointer\nfunc (s *SubfontDescriptorObj) SetIndexObjPdfDictionary(index int) {\n\ts.indexObjPdfDictionary = index\n}\n\n// SetPtrToSubsetFontObj set SubsetFont pointer\nfunc (s *SubfontDescriptorObj) SetPtrToSubsetFontObj(ptr *SubsetFontObj) {\n\ts.PtrToSubsetFontObj = ptr\n}\n\n// DesignUnitsToPdf convert unit\nfunc DesignUnitsToPdf(val int, unitsPerEm uint) int {\n\treturn core.Round(float64(float64(val) * 1000.00 / float64(unitsPerEm)))\n}\n"
        },
        {
          "name": "subset_font_obj.go",
          "type": "blob",
          "size": 9.4228515625,
          "content": "package gopdf\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\n\t\"github.com/signintech/gopdf/fontmaker/core\"\n)\n\n// ErrCharNotFound char not found\nvar ErrCharNotFound = errors.New(\"char not found\")\n\n// ErrGlyphNotFound font file not contain glyph\nvar ErrGlyphNotFound = errors.New(\"glyph not found\")\n\n// SubsetFontObj pdf subsetFont object\ntype SubsetFontObj struct {\n\tttfp                  core.TTFParser\n\tFamily                string\n\tCharacterToGlyphIndex *MapOfCharacterToGlyphIndex\n\tCountOfFont           int\n\tindexObjCIDFont       int\n\tindexObjUnicodeMap    int\n\tttfFontOption         TtfOption\n\tfuncKernOverride      FuncKernOverride\n\tfuncGetRoot           func() *GoPdf\n\taddCharsBuff          []rune\n}\n\nfunc (s *SubsetFontObj) init(funcGetRoot func() *GoPdf) {\n\ts.CharacterToGlyphIndex = NewMapOfCharacterToGlyphIndex() //make(map[rune]uint)\n\ts.funcKernOverride = nil\n\ts.funcGetRoot = funcGetRoot\n\n}\n\nfunc (s *SubsetFontObj) write(w io.Writer, objID int) error {\n\t//me.AddChars(\"จ\")\n\tio.WriteString(w, \"<<\\n\")\n\tfmt.Fprintf(w, \"/BaseFont /%s\\n\", CreateEmbeddedFontSubsetName(s.Family))\n\tfmt.Fprintf(w, \"/DescendantFonts [%d 0 R]\\n\", s.indexObjCIDFont+1)\n\tio.WriteString(w, \"/Encoding /Identity-H\\n\")\n\tio.WriteString(w, \"/Subtype /Type0\\n\")\n\tfmt.Fprintf(w, \"/ToUnicode %d 0 R\\n\", s.indexObjUnicodeMap+1)\n\tio.WriteString(w, \"/Type /Font\\n\")\n\tio.WriteString(w, \">>\\n\")\n\treturn nil\n}\n\n// SetIndexObjCIDFont set IndexObjCIDFont\nfunc (s *SubsetFontObj) SetIndexObjCIDFont(index int) {\n\ts.indexObjCIDFont = index\n}\n\n// SetIndexObjUnicodeMap set IndexObjUnicodeMap\nfunc (s *SubsetFontObj) SetIndexObjUnicodeMap(index int) {\n\ts.indexObjUnicodeMap = index\n}\n\n// SetFamily set font family name\nfunc (s *SubsetFontObj) SetFamily(familyname string) {\n\ts.Family = familyname\n}\n\n// GetFamily get font family name\nfunc (s *SubsetFontObj) GetFamily() string {\n\treturn s.Family\n}\n\n// SetTtfFontOption set TtfOption must set before SetTTFByPath\nfunc (s *SubsetFontObj) SetTtfFontOption(option TtfOption) {\n\tif option.OnGlyphNotFoundSubstitute == nil {\n\t\toption.OnGlyphNotFoundSubstitute = DefaultOnGlyphNotFoundSubstitute\n\t}\n\ts.ttfFontOption = option\n}\n\n// GetTtfFontOption get TtfOption must set before SetTTFByPath\nfunc (s *SubsetFontObj) GetTtfFontOption() TtfOption {\n\treturn s.ttfFontOption\n}\n\n// KernValueByLeft find kern value from kern table by left\nfunc (s *SubsetFontObj) KernValueByLeft(left uint) (bool, *core.KernValue) {\n\n\tif !s.ttfFontOption.UseKerning {\n\t\treturn false, nil\n\t}\n\n\tk := s.ttfp.Kern()\n\tif k == nil {\n\t\treturn false, nil\n\t}\n\n\tif kval, ok := k.Kerning[left]; ok {\n\t\treturn true, &kval\n\t}\n\n\treturn false, nil\n}\n\n// SetTTFByPath set ttf\nfunc (s *SubsetFontObj) SetTTFByPath(ttfpath string) error {\n\tuseKerning := s.ttfFontOption.UseKerning\n\ts.ttfp.SetUseKerning(useKerning)\n\terr := s.ttfp.Parse(ttfpath)\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}\n\n// SetTTFByReader set ttf\nfunc (s *SubsetFontObj) SetTTFByReader(rd io.Reader) error {\n\tuseKerning := s.ttfFontOption.UseKerning\n\ts.ttfp.SetUseKerning(useKerning)\n\terr := s.ttfp.ParseByReader(rd)\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}\n\n// SetTTFData set ttf\nfunc (s *SubsetFontObj) SetTTFData(data []byte) error {\n\tuseKerning := s.ttfFontOption.UseKerning\n\ts.ttfp.SetUseKerning(useKerning)\n\terr := s.ttfp.ParseFontData(data)\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}\n\n// AddChars add char to map CharacterToGlyphIndex\nfunc (s *SubsetFontObj) AddChars(txt string) (string, error) {\n\ts.addCharsBuff = s.addCharsBuff[:0]\n\tfor _, runeValue := range txt {\n\t\tif s.CharacterToGlyphIndex.KeyExists(runeValue) {\n\t\t\ts.addCharsBuff = append(s.addCharsBuff, runeValue)\n\t\t\tcontinue\n\t\t}\n\t\tglyphIndex, err := s.CharCodeToGlyphIndex(runeValue)\n\t\tif err == ErrGlyphNotFound {\n\t\t\t//never return error on this, just call function OnGlyphNotFound\n\t\t\tif s.ttfFontOption.OnGlyphNotFound != nil {\n\t\t\t\ts.ttfFontOption.OnGlyphNotFound(runeValue)\n\t\t\t}\n\t\t\t//start: try to find rune for replace\n\t\t\talreadyExists, runeValueReplace, glyphIndexReplace := s.replaceGlyphThatNotFound(runeValue)\n\t\t\tif !alreadyExists {\n\t\t\t\ts.CharacterToGlyphIndex.Set(runeValueReplace, glyphIndexReplace) // [runeValue] = glyphIndex\n\t\t\t}\n\t\t\t//end: try to find rune for replace\n\t\t\ts.addCharsBuff = append(s.addCharsBuff, runeValueReplace)\n\t\t\tcontinue\n\t\t} else if err != nil {\n\t\t\treturn \"\", err\n\t\t}\n\t\ts.CharacterToGlyphIndex.Set(runeValue, glyphIndex) // [runeValue] = glyphIndex\n\t\ts.addCharsBuff = append(s.addCharsBuff, runeValue)\n\t}\n\treturn string(s.addCharsBuff), nil\n}\n\n/*\n//AddChars add char to map CharacterToGlyphIndex\nfunc (s *SubsetFontObj) AddChars(txt string) error {\n\n\tfor _, runeValue := range txt {\n\t\tif s.CharacterToGlyphIndex.KeyExists(runeValue) {\n\t\t\tcontinue\n\t\t}\n\t\tglyphIndex, err := s.CharCodeToGlyphIndex(runeValue)\n\t\tif err == ErrGlyphNotFound {\n\t\t\t//never return error on this, just call function OnGlyphNotFound\n\t\t\tif s.ttfFontOption.OnGlyphNotFound != nil {\n\t\t\t\ts.ttfFontOption.OnGlyphNotFound(runeValue)\n\t\t\t}\n\t\t\t//start: try to find rune for replace\n\t\t\truneValueReplace, glyphIndexReplace, ok := s.replaceGlyphThatNotFound(runeValue)\n\t\t\tif ok {\n\t\t\t\ts.CharacterToGlyphIndex.Set(runeValueReplace, glyphIndexReplace) // [runeValue] = glyphIndex\n\t\t\t}\n\t\t\t//end: try to find rune for replace\n\t\t\tcontinue\n\t\t} else if err != nil {\n\t\t\treturn err\n\t\t}\n\t\ts.CharacterToGlyphIndex.Set(runeValue, glyphIndex) // [runeValue] = glyphIndex\n\t}\n\treturn nil\n}\n*/\n\n// replaceGlyphThatNotFound find glyph to replaced\n// it returns\n// - true if rune already add to CharacterToGlyphIndex\n// - rune for replace\n// - rune for replace is found or not\n// - glyph index for replace\nfunc (s *SubsetFontObj) replaceGlyphThatNotFound(runeNotFound rune) (bool, rune, uint) {\n\tif s.ttfFontOption.OnGlyphNotFoundSubstitute != nil {\n\t\truneForReplace := s.ttfFontOption.OnGlyphNotFoundSubstitute(runeNotFound)\n\t\tif s.CharacterToGlyphIndex.KeyExists(runeForReplace) {\n\t\t\treturn true, runeForReplace, 0\n\t\t}\n\t\tglyphIndexForReplace, err := s.CharCodeToGlyphIndex(runeForReplace)\n\t\tif err != nil {\n\t\t\treturn false, runeForReplace, 0\n\t\t}\n\t\treturn false, runeForReplace, glyphIndexForReplace\n\t}\n\treturn false, runeNotFound, 0\n}\n\n// CharIndex index of char in glyph table\nfunc (s *SubsetFontObj) CharIndex(r rune) (uint, error) {\n\tglyIndex, ok := s.CharacterToGlyphIndex.Val(r)\n\tif ok {\n\t\treturn glyIndex, nil\n\t}\n\treturn 0, ErrCharNotFound\n}\n\n// CharWidth with of char\nfunc (s *SubsetFontObj) CharWidth(r rune) (uint, error) {\n\tglyIndex, ok := s.CharacterToGlyphIndex.Val(r)\n\tif ok {\n\t\treturn s.GlyphIndexToPdfWidth(glyIndex), nil\n\t}\n\treturn 0, ErrCharNotFound\n}\n\nfunc (s *SubsetFontObj) getType() string {\n\treturn \"SubsetFont\"\n}\n\nfunc (s *SubsetFontObj) charCodeToGlyphIndexFormat12(r rune) (uint, error) {\n\n\tvalue := uint(r)\n\tgTbs := s.ttfp.GroupingTables()\n\tfor _, gTb := range gTbs {\n\t\tif value >= gTb.StartCharCode && value <= gTb.EndCharCode {\n\t\t\tgIndex := (value - gTb.StartCharCode) + gTb.GlyphID\n\t\t\treturn gIndex, nil\n\t\t}\n\t}\n\n\treturn uint(0), ErrGlyphNotFound\n}\n\nfunc (s *SubsetFontObj) charCodeToGlyphIndexFormat4(r rune) (uint, error) {\n\tvalue := uint(r)\n\tseg := uint(0)\n\tsegCount := s.ttfp.SegCount\n\tfor seg < segCount {\n\t\tif value <= s.ttfp.EndCount[seg] {\n\t\t\tbreak\n\t\t}\n\t\tseg++\n\t}\n\t//fmt.Printf(\"\\ncccc--->%#v\\n\", me.ttfp.Chars())\n\tif value < s.ttfp.StartCount[seg] {\n\t\treturn 0, ErrGlyphNotFound\n\t}\n\n\tif s.ttfp.IdRangeOffset[seg] == 0 {\n\n\t\treturn (value + s.ttfp.IdDelta[seg]) & 0xFFFF, nil\n\t}\n\t//fmt.Printf(\"IdRangeOffset=%d\\n\", me.ttfp.IdRangeOffset[seg])\n\tidx := s.ttfp.IdRangeOffset[seg]/2 + (value - s.ttfp.StartCount[seg]) - (segCount - seg)\n\n\tif s.ttfp.GlyphIdArray[int(idx)] == uint(0) {\n\t\treturn 0, nil\n\t}\n\n\treturn (s.ttfp.GlyphIdArray[int(idx)] + s.ttfp.IdDelta[seg]) & 0xFFFF, nil\n}\n\n// CharCodeToGlyphIndex gets glyph index from char code.\nfunc (s *SubsetFontObj) CharCodeToGlyphIndex(r rune) (uint, error) {\n\tvalue := uint64(r)\n\tif value <= 0xFFFF {\n\t\tgIndex, err := s.charCodeToGlyphIndexFormat4(r)\n\t\tif err != nil {\n\t\t\treturn 0, err\n\t\t}\n\t\treturn gIndex, nil\n\t}\n\tgIndex, err := s.charCodeToGlyphIndexFormat12(r)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\treturn gIndex, nil\n}\n\n// GlyphIndexToPdfWidth gets width from glyphIndex.\nfunc (s *SubsetFontObj) GlyphIndexToPdfWidth(glyphIndex uint) uint {\n\n\tnumberOfHMetrics := s.ttfp.NumberOfHMetrics()\n\tunitsPerEm := s.ttfp.UnitsPerEm()\n\tif glyphIndex >= numberOfHMetrics {\n\t\tglyphIndex = numberOfHMetrics - 1\n\t}\n\n\twidth := s.ttfp.Widths()[glyphIndex]\n\tif unitsPerEm == 1000 {\n\t\treturn width\n\t}\n\treturn width * 1000 / unitsPerEm\n}\n\n// GetTTFParser gets TTFParser.\nfunc (s *SubsetFontObj) GetTTFParser() *core.TTFParser {\n\treturn &s.ttfp\n}\n\n// GetUnderlineThickness underlineThickness.\nfunc (s *SubsetFontObj) GetUnderlineThickness() int {\n\treturn s.ttfp.UnderlineThickness()\n}\n\nfunc (s *SubsetFontObj) GetUnderlineThicknessPx(fontSize float64) float64 {\n\treturn (float64(s.ttfp.UnderlineThickness()) / float64(s.ttfp.UnitsPerEm())) * fontSize\n}\n\n// GetUnderlinePosition underline position.\nfunc (s *SubsetFontObj) GetUnderlinePosition() int {\n\treturn s.ttfp.UnderlinePosition()\n}\n\nfunc (s *SubsetFontObj) GetUnderlinePositionPx(fontSize float64) float64 {\n\treturn (float64(s.ttfp.UnderlinePosition()) / float64(s.ttfp.UnitsPerEm())) * fontSize\n}\n\nfunc (s *SubsetFontObj) GetAscender() int {\n\treturn s.ttfp.Ascender()\n}\n\nfunc (s *SubsetFontObj) GetAscenderPx(fontSize float64) float64 {\n\treturn (float64(s.ttfp.Ascender()) / float64(s.ttfp.UnitsPerEm())) * fontSize\n}\n\nfunc (s *SubsetFontObj) GetDescender() int {\n\treturn s.ttfp.Descender()\n}\n\nfunc (s *SubsetFontObj) GetDescenderPx(fontSize float64) float64 {\n\treturn (float64(s.ttfp.Descender()) / float64(s.ttfp.UnitsPerEm())) * fontSize\n}\n"
        },
        {
          "name": "table.go",
          "type": "blob",
          "size": 7.146484375,
          "content": "package gopdf\n\n// Represents an RGB color with red, green, and blue components\ntype RGBColor struct {\n\tR uint8 // Red component (0-255)\n\tG uint8 // Green component (0-255)\n\tB uint8 // Blue component (0-255)\n}\n\n// Defines the border style for a cell or table\ntype BorderStyle struct {\n\tTop      bool     // Whether to draw the top border\n\tLeft     bool     // Whether to draw the left border\n\tRight    bool     // Whether to draw the right border\n\tBottom   bool     // Whether to draw the bottom border\n\tWidth    float64  // Width of the border line\n\tRGBColor RGBColor // Color of the border\n}\n\n// Defines the style for a cell, including border, fill, text, and font properties\ntype CellStyle struct {\n\tBorderStyle BorderStyle // Border style for the cell\n\tFillColor   RGBColor    // Background color of the cell\n\tTextColor   RGBColor    // Color of the text in the cell\n\tFont        string      // Font name for the cell text\n\tFontSize    float64     // Font size for the cell text\n}\n\n// Represents the layout of a table\ntype tableLayout struct {\n\tpdf         *GoPdf     // Reference to the GoPdf instance\n\tstartX      float64    // Starting X coordinate of the table\n\tstartY      float64    // Starting Y coordinate of the table\n\trowHeight   float64    // Height of each row in the table\n\tcolumns     []column   // Slice of column definitions\n\trows        [][]string // Slice of rows, each containing cell contents\n\tmaxRows     int        // Maximum number of rows in the table\n\tpadding     float64    // Padding inside each cell\n\tcellOption  CellOption // Options for cell content rendering\n\ttableStyle  CellStyle  // Style for the entire table\n\theaderStyle CellStyle  // Style for the header row\n\tcellStyle   CellStyle  // Style for regular cells\n}\n\n// Represents a column in the table\ntype column struct {\n\theader string  // Header text for the column\n\twidth  float64 // Width of the column\n\talign  string  // Alignment of content within the column\n}\n\n// Creates a new table layout with the given parameters\nfunc (gp *GoPdf) NewTableLayout(startX, startY, rowHeight float64, maxRows int) *tableLayout {\n\treturn &tableLayout{\n\t\tpdf:       gp,\n\t\tstartX:    startX,\n\t\tstartY:    startY,\n\t\trowHeight: rowHeight,\n\t\tmaxRows:   maxRows,\n\t\tpadding:   2.0,\n\t\tcellOption: CellOption{\n\t\t\tBreakOption: &BreakOption{\n\t\t\t\tMode:           BreakModeIndicatorSensitive,\n\t\t\t\tBreakIndicator: ' ',\n\t\t\t},\n\t\t},\n\t\ttableStyle: CellStyle{\n\t\t\tBorderStyle: BorderStyle{\n\t\t\t\tTop: true, Left: true, Right: true, Bottom: true,\n\t\t\t\tWidth:    0.5,\n\t\t\t\tRGBColor: RGBColor{R: 0, G: 0, B: 0},\n\t\t\t},\n\t\t},\n\t\theaderStyle: CellStyle{\n\t\t\tBorderStyle: BorderStyle{\n\t\t\t\tTop: true, Left: true, Right: true, Bottom: true,\n\t\t\t\tWidth:    0.5,\n\t\t\t\tRGBColor: RGBColor{R: 0, G: 0, B: 0},\n\t\t\t},\n\t\t\tFillColor: RGBColor{R: 240, G: 240, B: 240},\n\t\t\tTextColor: RGBColor{R: 0, G: 0, B: 0},\n\t\t},\n\t\tcellStyle: CellStyle{\n\t\t\tBorderStyle: BorderStyle{\n\t\t\t\tTop: true, Left: true, Right: true, Bottom: true,\n\t\t\t\tWidth:    0.5,\n\t\t\t\tRGBColor: RGBColor{R: 0, G: 0, B: 0},\n\t\t\t},\n\t\t\tTextColor: RGBColor{R: 0, G: 0, B: 0},\n\t\t},\n\t}\n}\n\n// Adds a column to the table with the specified header, width, and alignment\nfunc (t *tableLayout) AddColumn(header string, width float64, align string) {\n\tt.columns = append(t.columns, column{header, width, align})\n}\n\n// Adds a row of data to the table\nfunc (t *tableLayout) AddRow(row []string) {\n\tt.rows = append(t.rows, row)\n}\n\n// Sets the style for the entire table\nfunc (t *tableLayout) SetTableStyle(style CellStyle) {\n\tt.tableStyle = style\n}\n\n// Sets the style for the header row\nfunc (t *tableLayout) SetHeaderStyle(style CellStyle) {\n\tt.headerStyle = style\n}\n\n// Sets the style for regular cells\nfunc (t *tableLayout) SetCellStyle(style CellStyle) {\n\tt.cellStyle = style\n}\n\n// DrawTable the entire table on the PDF\nfunc (t *tableLayout) DrawTable() error {\n\tx := t.startX\n\ty := t.startY\n\n\t// Draw the header row\n\tfor _, col := range t.columns {\n\t\tif err := t.drawCell(x, y, col.width, t.rowHeight, col.header, \"center\", true); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tx += col.width\n\t}\n\ty += t.rowHeight\n\n\t// Draw the data rows\n\tfor _, row := range t.rows {\n\t\tx = t.startX\n\t\tfor i, cell := range row {\n\t\t\tif err := t.drawCell(x, y, t.columns[i].width, t.rowHeight, cell, t.columns[i].align, false); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tx += t.columns[i].width\n\t\t}\n\t\ty += t.rowHeight\n\t}\n\n\t// Fill any remaining rows with empty cells\n\tfor i := len(t.rows); i < t.maxRows; i++ {\n\t\tx = t.startX\n\t\tfor _, col := range t.columns {\n\t\t\tif err := t.drawCell(x, y, col.width, t.rowHeight, \"\", col.align, false); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tx += col.width\n\t\t}\n\t\ty += t.rowHeight\n\t}\n\n\t// Draw the outer border of the table and header\n\tif err := t.drawTableAndHeaderBorder(); err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\n// Draws the outer border of the table and header\nfunc (t *tableLayout) drawTableAndHeaderBorder() error {\n\tx1 := t.startX\n\ty1 := t.startY\n\tx2 := t.startX\n\ty2 := t.startY + float64(t.maxRows+1)*t.rowHeight\n\n\tfor _, col := range t.columns {\n\t\tx2 += col.width\n\t}\n\n\t// Draw borders of the table\n\terr := t.drawBorder(x1, y1, x2, y2, t.tableStyle.BorderStyle)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Draw borders of the header\n\treturn t.drawBorder(x1, y1, x2, y1+t.rowHeight, t.headerStyle.BorderStyle)\n}\n\n// Draws a single cell of the table\nfunc (t *tableLayout) drawCell(x, y, width, height float64, content, align string, isHeader bool) error {\n\tstyle := t.cellStyle\n\tif isHeader {\n\t\tstyle = t.headerStyle\n\t}\n\n\t// Fill the cell background if a fill color is specified\n\tif style.FillColor != (RGBColor{}) {\n\t\tt.pdf.SetFillColor(style.FillColor.R, style.FillColor.G, style.FillColor.B)\n\t\tt.pdf.RectFromUpperLeftWithStyle(x, y, width, height, \"F\")\n\t}\n\n\tif !isHeader {\n\t\t// Draw the cell border\n\t\tif err := t.drawBorder(x, y, x+width, y+height, style.BorderStyle); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\t// Calculate the text area within the cell\n\ttextX := x + t.padding\n\ttextY := y + t.padding\n\ttextWidth := width - (2 * t.padding)\n\ttextHeight := height - (2 * t.padding)\n\n\tt.pdf.SetXY(textX, textY)\n\n\t// Set the text alignment\n\tvar textOption = t.cellOption\n\tif align == \"right\" {\n\t\ttextOption.Align = Right | Middle\n\t} else if align == \"center\" {\n\t\ttextOption.Align = Center | Middle\n\t} else {\n\t\ttextOption.Align = Left | Middle\n\t}\n\n\t// Set the text color and font\n\tt.pdf.SetTextColor(style.TextColor.R, style.TextColor.G, style.TextColor.B)\n\tif style.Font != \"\" {\n\t\tt.pdf.SetFont(style.Font, \"\", style.FontSize)\n\t}\n\n\t// Draw the cell content\n\terr := t.pdf.MultiCellWithOption(&Rect{W: textWidth, H: textHeight}, content, textOption)\n\tif err != nil && err.Error() == \"empty string\" {\n\t\terr = nil\n\t}\n\n\treturn err\n}\n\n// Draws a border around a rectangular area\nfunc (t *tableLayout) drawBorder(x1, y1, x2, y2 float64, borderStyle BorderStyle) error {\n\tt.pdf.SetLineWidth(borderStyle.Width)\n\tt.pdf.SetStrokeColor(borderStyle.RGBColor.R, borderStyle.RGBColor.G, borderStyle.RGBColor.B)\n\thalf := borderStyle.Width / 2\n\n\t// Draw each side of the border if specified\n\tif borderStyle.Top {\n\t\tt.pdf.Line(x1-half, y1, x2+half, y1)\n\t}\n\tif borderStyle.Bottom {\n\t\tt.pdf.Line(x1-half, y2, x2+half, y2)\n\t}\n\tif borderStyle.Left {\n\t\tt.pdf.Line(x1, y1-half, x1, y2+half)\n\t}\n\tif borderStyle.Right {\n\t\tt.pdf.Line(x2, y1-half, x2, y2+half)\n\t}\n\n\treturn nil\n}\n"
        },
        {
          "name": "table_test.go",
          "type": "blob",
          "size": 5.61328125,
          "content": "package gopdf_test\n\nimport (\n\t\"testing\"\n\n\t\"github.com/signintech/gopdf\"\n)\n\nfunc TestTable(t *testing.T) {\n\t// Create a new PDF document\n\tpdf := &gopdf.GoPdf{}\n\t// Start the PDF with a custom page size (we'll adjust it later)\n\tpdf.Start(gopdf.Config{PageSize: gopdf.Rect{W: 430, H: 200}})\n\t// Add a new page to the document\n\tpdf.AddPage()\n\n\terr := pdf.AddTTFFont(\"LiberationSerif-Regular\", \"./test/res/LiberationSerif-Regular.ttf\")\n\tif err != nil {\n\t\tt.Fatalf(\"Error loading font: %v\", err)\n\t\treturn\n\t}\n\n\terr = pdf.SetFont(\"LiberationSerif-Regular\", \"\", 11)\n\tif err != nil {\n\t\tt.Fatalf(\"Error set font: %v\", err)\n\t\treturn\n\t}\n\terr = pdf.AddTTFFont(\"Ubuntu-L.ttf\", \"./examples/outline_example/Ubuntu-L.ttf\")\n\tif err != nil {\n\t\tt.Fatalf(\"Error loading font: %v\", err)\n\t\treturn\n\t}\n\n\terr = pdf.SetFont(\"Ubuntu-L.ttf\", \"\", 11)\n\tif err != nil {\n\t\tt.Fatalf(\"Error set font: %v\", err)\n\t\treturn\n\t}\n\n\t// Set the starting Y position for the table\n\ttableStartY := 10.0\n\t// Set the left margin for the table\n\tmarginLeft := 10.0\n\n\t// Create a new table layout\n\ttable := pdf.NewTableLayout(marginLeft, tableStartY, 25, 5)\n\n\t// Add columns to the table\n\ttable.AddColumn(\"CODE\", 50, \"left\")\n\ttable.AddColumn(\"DESCRIPTION\", 200, \"left\")\n\ttable.AddColumn(\"QTY.\", 40, \"right\")\n\ttable.AddColumn(\"PRICE\", 60, \"right\")\n\ttable.AddColumn(\"TOTAL\", 60, \"right\")\n\n\t// Add rows to the table\n\ttable.AddRow([]string{\"001\", \"Product A\", \"2\", \"10.00\", \"20.00\"})\n\ttable.AddRow([]string{\"002\", \"Product B\", \"1\", \"15.00\", \"15.00\"})\n\ttable.AddRow([]string{\"003\", \"Product C\", \"3\", \"5.00\", \"15.00\"})\n\n\t// Set the style for table cells\n\ttable.SetTableStyle(gopdf.CellStyle{\n\t\tBorderStyle: gopdf.BorderStyle{\n\t\t\tTop:    true,\n\t\t\tLeft:   true,\n\t\t\tBottom: true,\n\t\t\tRight:  true,\n\t\t\tWidth:  1.0,\n\t\t},\n\t\tFillColor: gopdf.RGBColor{R: 255, G: 255, B: 255},\n\t\tTextColor: gopdf.RGBColor{R: 0, G: 0, B: 0},\n\t\tFontSize:  10,\n\t})\n\n\t// Set the style for table header\n\ttable.SetHeaderStyle(gopdf.CellStyle{\n\t\tBorderStyle: gopdf.BorderStyle{\n\t\t\tTop:      true,\n\t\t\tLeft:     true,\n\t\t\tBottom:   true,\n\t\t\tRight:    true,\n\t\t\tWidth:    2.0,\n\t\t\tRGBColor: gopdf.RGBColor{R: 100, G: 150, B: 255},\n\t\t},\n\t\tFillColor: gopdf.RGBColor{R: 255, G: 200, B: 200},\n\t\tTextColor: gopdf.RGBColor{R: 255, G: 100, B: 100},\n\t\tFont:      \"Ubuntu-L.ttf\",\n\t\tFontSize:  12,\n\t})\n\n\ttable.SetCellStyle(gopdf.CellStyle{\n\t\tBorderStyle: gopdf.BorderStyle{\n\t\t\tRight:    true,\n\t\t\tBottom:   true,\n\t\t\tWidth:    0.5,\n\t\t\tRGBColor: gopdf.RGBColor{R: 0, G: 0, B: 0},\n\t\t},\n\t\tFillColor: gopdf.RGBColor{R: 255, G: 255, B: 255},\n\t\tTextColor: gopdf.RGBColor{R: 0, G: 0, B: 0},\n\t\tFont:      \"LiberationSerif-Regular\",\n\t\tFontSize:  10,\n\t})\n\n\t// Draw the table\n\terr = table.DrawTable()\n\tif err != nil {\n\t\tt.Errorf(\"Error drawing table: %v\", err)\n\t}\n\n\t// Save the PDF to the specified path\n\terr = pdf.WritePdf(\"examples/table/example_table.pdf\")\n\tif err != nil {\n\t\tt.Errorf(\"Error saving PDF: %v\", err)\n\t}\n}\n\nfunc TestTableCenter(t *testing.T) {\n\t// Create a new PDF document\n\tpdf := &gopdf.GoPdf{}\n\t// Start the PDF with a custom page size (we'll adjust it later)\n\tpdf.Start(gopdf.Config{PageSize: gopdf.Rect{W: 430, H: 200}})\n\t// Add a new page to the document\n\tpdf.AddPage()\n\n\terr := pdf.AddTTFFont(\"LiberationSerif-Regular\", \"./test/res/LiberationSerif-Regular.ttf\")\n\tif err != nil {\n\t\tt.Fatalf(\"Error loading font: %v\", err)\n\t\treturn\n\t}\n\n\terr = pdf.SetFont(\"LiberationSerif-Regular\", \"\", 11)\n\tif err != nil {\n\t\tt.Fatalf(\"Error set font: %v\", err)\n\t\treturn\n\t}\n\terr = pdf.AddTTFFont(\"Ubuntu-L.ttf\", \"./examples/outline_example/Ubuntu-L.ttf\")\n\tif err != nil {\n\t\tt.Fatalf(\"Error loading font: %v\", err)\n\t\treturn\n\t}\n\n\terr = pdf.SetFont(\"Ubuntu-L.ttf\", \"\", 11)\n\tif err != nil {\n\t\tt.Fatalf(\"Error set font: %v\", err)\n\t\treturn\n\t}\n\n\t// Set the starting Y position for the table\n\ttableStartY := 10.0\n\t// Set the left margin for the table\n\tmarginLeft := 10.0\n\n\t// Create a new table layout\n\ttable := pdf.NewTableLayout(marginLeft, tableStartY, 25, 5)\n\n\t// Add columns to the table\n\ttable.AddColumn(\"CODE\", 50, \"center\")\n\ttable.AddColumn(\"DESCRIPTION\", 200, \"center\")\n\ttable.AddColumn(\"QTY.\", 40, \"center\")\n\ttable.AddColumn(\"PRICE\", 60, \"center\")\n\ttable.AddColumn(\"TOTAL\", 60, \"center\")\n\n\t// Add rows to the table\n\ttable.AddRow([]string{\"001\", \"Product A\", \"2\", \"10.00\", \"20.00\"})\n\ttable.AddRow([]string{\"002\", \"Product B\", \"1\", \"15.00\", \"15.00\"})\n\ttable.AddRow([]string{\"003\", \"Product C\", \"3\", \"5.00\", \"15.00\"})\n\n\t// Set the style for table cells\n\ttable.SetTableStyle(gopdf.CellStyle{\n\t\tBorderStyle: gopdf.BorderStyle{\n\t\t\tTop:    true,\n\t\t\tLeft:   true,\n\t\t\tBottom: true,\n\t\t\tRight:  true,\n\t\t\tWidth:  1.0,\n\t\t},\n\t\tFillColor: gopdf.RGBColor{R: 255, G: 255, B: 255},\n\t\tTextColor: gopdf.RGBColor{R: 0, G: 0, B: 0},\n\t\tFontSize:  10,\n\t})\n\n\t// Set the style for table header\n\ttable.SetHeaderStyle(gopdf.CellStyle{\n\t\tBorderStyle: gopdf.BorderStyle{\n\t\t\tTop:      true,\n\t\t\tLeft:     true,\n\t\t\tBottom:   true,\n\t\t\tRight:    true,\n\t\t\tWidth:    2.0,\n\t\t\tRGBColor: gopdf.RGBColor{R: 100, G: 150, B: 255},\n\t\t},\n\t\tFillColor: gopdf.RGBColor{R: 255, G: 200, B: 200},\n\t\tTextColor: gopdf.RGBColor{R: 255, G: 100, B: 100},\n\t\tFont:      \"Ubuntu-L.ttf\",\n\t\tFontSize:  12,\n\t})\n\n\ttable.SetCellStyle(gopdf.CellStyle{\n\t\tBorderStyle: gopdf.BorderStyle{\n\t\t\tRight:    true,\n\t\t\tBottom:   true,\n\t\t\tWidth:    0.5,\n\t\t\tRGBColor: gopdf.RGBColor{R: 0, G: 0, B: 0},\n\t\t},\n\t\tFillColor: gopdf.RGBColor{R: 255, G: 255, B: 255},\n\t\tTextColor: gopdf.RGBColor{R: 0, G: 0, B: 0},\n\t\tFont:      \"LiberationSerif-Regular\",\n\t\tFontSize:  10,\n\t})\n\n\t// Draw the table\n\terr = table.DrawTable()\n\tif err != nil {\n\t\tt.Errorf(\"Error drawing table: %v\", err)\n\t}\n\n\t// Save the PDF to the specified path\n\terr = pdf.WritePdf(\"examples/table/example_table_center.pdf\")\n\tif err != nil {\n\t\tt.Errorf(\"Error saving PDF: %v\", err)\n\t}\n}\n"
        },
        {
          "name": "test",
          "type": "tree",
          "content": null
        },
        {
          "name": "transparency.go",
          "type": "blob",
          "size": 3.005859375,
          "content": "package gopdf\n\nimport (\n\t\"fmt\"\n\t\"sync\"\n\n\t\"errors\"\n)\n\ntype BlendModeType string\n\nconst (\n\tHue             BlendModeType = \"/Hue\"\n\tColor           BlendModeType = \"/Color\"\n\tNormalBlendMode BlendModeType = \"/Normal\"\n\tDarken          BlendModeType = \"/Darken\"\n\tScreen          BlendModeType = \"/Screen\"\n\tOverlay         BlendModeType = \"/Overlay\"\n\tLighten         BlendModeType = \"/Lighten\"\n\tMultiply        BlendModeType = \"/Multiply\"\n\tExclusion       BlendModeType = \"/Exclusion\"\n\tColorBurn       BlendModeType = \"/ColorBurn\"\n\tHardLight       BlendModeType = \"/HardLight\"\n\tSoftLight       BlendModeType = \"/SoftLight\"\n\tDifference      BlendModeType = \"/Difference\"\n\tSaturation      BlendModeType = \"/Saturation\"\n\tLuminosity      BlendModeType = \"/Luminosity\"\n\tColorDodge      BlendModeType = \"/ColorDodge\"\n)\n\nconst DefaultAplhaValue = 1\n\n// Transparency defines an object alpha.\ntype Transparency struct {\n\textGStateIndex int\n\tAlpha          float64\n\tBlendModeType  BlendModeType\n}\n\nfunc NewTransparency(alpha float64, blendModeType string) (Transparency, error) {\n\tif alpha < 0.0 || alpha > 1.0 {\n\t\treturn Transparency{}, fmt.Errorf(\"alpha value is out of range (0.0 - 1.0): %.3f\", alpha)\n\t}\n\n\tbmtType, err := defineBlendModeType(blendModeType)\n\tif err != nil {\n\t\treturn Transparency{}, err\n\t}\n\n\treturn Transparency{\n\t\tAlpha:         alpha,\n\t\tBlendModeType: bmtType,\n\t}, nil\n}\n\nfunc (t Transparency) GetId() string {\n\tkeyStr := fmt.Sprintf(\"%.3f_%s\", t.Alpha, t.BlendModeType)\n\n\treturn keyStr\n}\n\ntype TransparencyMap struct {\n\tsyncer sync.Mutex\n\ttable  map[string]Transparency\n}\n\nfunc NewTransparencyMap() TransparencyMap {\n\treturn TransparencyMap{\n\t\tsyncer: sync.Mutex{},\n\t\ttable:  make(map[string]Transparency),\n\t}\n}\n\nfunc (tm *TransparencyMap) Find(transparency Transparency) (Transparency, bool) {\n\tkey := transparency.GetId()\n\n\ttm.syncer.Lock()\n\tdefer tm.syncer.Unlock()\n\n\tt, ok := tm.table[key]\n\tif !ok {\n\t\treturn Transparency{}, false\n\t}\n\n\treturn t, ok\n\n}\n\nfunc (tm *TransparencyMap) Save(transparency Transparency) Transparency {\n\ttm.syncer.Lock()\n\tdefer tm.syncer.Unlock()\n\n\tkey := transparency.GetId()\n\ttm.table[key] = transparency\n\n\treturn transparency\n}\n\nfunc defineBlendModeType(bmType string) (BlendModeType, error) {\n\tswitch bmType {\n\tcase string(Hue):\n\t\treturn Hue, nil\n\tcase string(Color):\n\t\treturn Color, nil\n\tcase \"\", string(NormalBlendMode):\n\t\treturn NormalBlendMode, nil\n\tcase string(Darken):\n\t\treturn Darken, nil\n\tcase string(Screen):\n\t\treturn Screen, nil\n\tcase string(Overlay):\n\t\treturn Overlay, nil\n\tcase string(Lighten):\n\t\treturn Lighten, nil\n\tcase string(Multiply):\n\t\treturn Multiply, nil\n\tcase string(Exclusion):\n\t\treturn Exclusion, nil\n\tcase string(ColorBurn):\n\t\treturn ColorBurn, nil\n\tcase string(HardLight):\n\t\treturn HardLight, nil\n\tcase string(SoftLight):\n\t\treturn SoftLight, nil\n\tcase string(Difference):\n\t\treturn Difference, nil\n\tcase string(Saturation):\n\t\treturn Saturation, nil\n\tcase string(Luminosity):\n\t\treturn Luminosity, nil\n\tcase string(ColorDodge):\n\t\treturn ColorDodge, nil\n\tdefault:\n\t\treturn \"\", errors.New(\"blend mode is unknown\")\n\t}\n}\n"
        },
        {
          "name": "transparency_xobject_group.go",
          "type": "blob",
          "size": 2.115234375,
          "content": "package gopdf\n\nimport (\n\t\"fmt\"\n\t\"io\"\n)\n\ntype TransparencyXObjectGroup struct {\n\tIndex            int\n\tBBox             [4]float64\n\tMatrix           [6]float64\n\tExtGStateIndexes []int\n\tXObjects         []cacheContentImage\n\n\tgetRoot       func() *GoPdf\n\tpdfProtection *PDFProtection\n}\n\ntype TransparencyXObjectGroupOptions struct {\n\tProtection       *PDFProtection\n\tExtGStateIndexes []int\n\tBBox             [4]float64\n\tXObjects         []cacheContentImage\n}\n\nfunc GetCachedTransparencyXObjectGroup(opts TransparencyXObjectGroupOptions, gp *GoPdf) (TransparencyXObjectGroup, error) {\n\tgroup := TransparencyXObjectGroup{\n\t\tBBox:             opts.BBox,\n\t\tXObjects:         opts.XObjects,\n\t\tpdfProtection:    opts.Protection,\n\t\tExtGStateIndexes: opts.ExtGStateIndexes,\n\t}\n\tgroup.Index = gp.addObj(group)\n\tgroup.init(func() *GoPdf {\n\t\treturn gp\n\t})\n\n\treturn group, nil\n}\n\nfunc (s TransparencyXObjectGroup) init(funcGetRoot func() *GoPdf) {\n\ts.getRoot = funcGetRoot\n}\n\nfunc (s *TransparencyXObjectGroup) setProtection(p *PDFProtection) {\n\ts.pdfProtection = p\n}\n\nfunc (s TransparencyXObjectGroup) protection() *PDFProtection {\n\treturn s.pdfProtection\n}\n\nfunc (s TransparencyXObjectGroup) getType() string {\n\treturn \"XObject\"\n}\n\nfunc (s TransparencyXObjectGroup) write(w io.Writer, objId int) error {\n\tstreamBuff := GetBuffer()\n\tdefer PutBuffer(streamBuff)\n\n\tfor _, XObject := range s.XObjects {\n\t\tif err := XObject.write(streamBuff, nil); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\tcontent := \"<<\\n\"\n\tcontent += \"\\t/FormType 1\\n\"\n\tcontent += \"\\t/Subtype /Form\\n\"\n\tcontent += fmt.Sprintf(\"\\t/Type /%s\\n\", s.getType())\n\tcontent += fmt.Sprintf(\"\\t/Matrix [1 0 0 1 0 0]\\n\")\n\tcontent += fmt.Sprintf(\"\\t/BBox [%.3F %.3F %.3F %.3F]\\n\", s.BBox[0], s.BBox[1], s.BBox[2], s.BBox[3])\n\tcontent += \"\\t/Group<</CS /DeviceGray /S /Transparency>>\\n\"\n\n\tcontent += fmt.Sprintf(\"\\t/Length %d\\n\", len(streamBuff.Bytes()))\n\tcontent += \">>\\n\"\n\tcontent += \"stream\\n\"\n\n\tif _, err := io.WriteString(w, content); err != nil {\n\t\treturn err\n\t}\n\n\tif _, err := w.Write(streamBuff.Bytes()); err != nil {\n\t\treturn err\n\t}\n\n\tif _, err := io.WriteString(w, \"endstream\\n\"); err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n"
        },
        {
          "name": "ttf_option.go",
          "type": "blob",
          "size": 0.646484375,
          "content": "package gopdf\n\n// TtfOption  font option\ntype TtfOption struct {\n\tUseKerning                bool\n\tStyle                     int               //Regular|Bold|Italic\n\tOnGlyphNotFound           func(r rune)      //Called when a glyph cannot be found, just for debugging\n\tOnGlyphNotFoundSubstitute func(r rune) rune //Called when a glyph cannot be found, we can return a new rune to replace it.\n}\n\nfunc defaultTtfFontOption() TtfOption {\n\tvar defa TtfOption\n\tdefa.UseKerning = false\n\tdefa.Style = Regular\n\tdefa.OnGlyphNotFoundSubstitute = DefaultOnGlyphNotFoundSubstitute\n\treturn defa\n}\n\nfunc DefaultOnGlyphNotFoundSubstitute(r rune) rune {\n\treturn rune('\\u0020')\n}\n"
        },
        {
          "name": "unicode_map.go",
          "type": "blob",
          "size": 3.0791015625,
          "content": "package gopdf\n\nimport (\n\t\"fmt\"\n\t\"io\"\n)\n\n// UnicodeMap unicode map\ntype UnicodeMap struct {\n\tPtrToSubsetFontObj *SubsetFontObj\n\t//getRoot            func() *GoPdf\n\tpdfProtection *PDFProtection\n}\n\nfunc (u *UnicodeMap) init(funcGetRoot func() *GoPdf) {\n\t//u.getRoot = funcGetRoot\n}\n\nfunc (u *UnicodeMap) setProtection(p *PDFProtection) {\n\tu.pdfProtection = p\n}\n\nfunc (u *UnicodeMap) protection() *PDFProtection {\n\treturn u.pdfProtection\n}\n\n// SetPtrToSubsetFontObj set pointer to SubsetFontObj\nfunc (u *UnicodeMap) SetPtrToSubsetFontObj(ptr *SubsetFontObj) {\n\tu.PtrToSubsetFontObj = ptr\n}\n\nfunc (u *UnicodeMap) getType() string {\n\treturn \"Unicode\"\n}\n\nfunc (u *UnicodeMap) write(w io.Writer, objID int) error {\n\t//stream\n\t//characterToGlyphIndex := u.PtrToSubsetFontObj.CharacterToGlyphIndex\n\tprefix :=\n\t\t\"/CIDInit /ProcSet findresource begin\\n\" +\n\t\t\t\"12 dict begin\\n\" +\n\t\t\t\"begincmap\\n\" +\n\t\t\t\"/CIDSystemInfo << /Registry (Adobe)/Ordering (UCS)/Supplement 0>> def\\n\" +\n\t\t\t\"/CMapName /Adobe-Identity-UCS def /CMapType 2 def\\n\"\n\tsuffix := \"endcmap CMapName currentdict /CMap defineresource pop end end\"\n\n\tglyphIndexToCharacter := newMapGlyphIndexToCharacter() //make(map[int]rune)\n\tlowIndex := 65536\n\thiIndex := -1\n\n\tkeys := u.PtrToSubsetFontObj.CharacterToGlyphIndex.AllKeys()\n\tfor _, k := range keys {\n\t\tv, _ := u.PtrToSubsetFontObj.CharacterToGlyphIndex.Val(k)\n\t\tindex := int(v)\n\t\tif index < lowIndex {\n\t\t\tlowIndex = index\n\t\t}\n\t\tif index > hiIndex {\n\t\t\thiIndex = index\n\t\t}\n\t\t//glyphIndexToCharacter[index] = k\n\t\tglyphIndexToCharacter.set(index, k)\n\t}\n\n\tbuff := GetBuffer()\n\tdefer PutBuffer(buff)\n\n\tbuff.WriteString(prefix)\n\tbuff.WriteString(\"1 begincodespacerange\\n\")\n\tfmt.Fprintf(buff, \"<%04X><%04X>\\n\", lowIndex, hiIndex)\n\tbuff.WriteString(\"endcodespacerange\\n\")\n\tfmt.Fprintf(buff, \"%d beginbfrange\\n\", glyphIndexToCharacter.size())\n\tindexs := glyphIndexToCharacter.allIndexs()\n\tfor _, k := range indexs {\n\t\tv, _ := glyphIndexToCharacter.runeByIndex(k)\n\t\tfmt.Fprintf(buff, \"<%04X><%04X><%04X>\\n\", k, k, v)\n\t}\n\tbuff.WriteString(\"endbfrange\\n\")\n\tbuff.WriteString(suffix)\n\tbuff.WriteString(\"\\n\")\n\n\tio.WriteString(w, \"<<\\n\")\n\tfmt.Fprintf(w, \"/Length %d\\n\", buff.Len())\n\tio.WriteString(w, \">>\\n\")\n\tio.WriteString(w, \"stream\\n\")\n\tif u.protection() != nil {\n\t\ttmp, err := rc4Cip(u.protection().objectkey(objID), buff.Bytes())\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tw.Write(tmp)\n\t\t//streambuff.WriteString(\"\\n\")\n\t} else {\n\t\tbuff.WriteTo(w)\n\t}\n\tio.WriteString(w, \"endstream\\n\")\n\n\treturn nil\n}\n\ntype mapGlyphIndexToCharacter struct {\n\trunes  []rune\n\tindexs []int\n}\n\nfunc newMapGlyphIndexToCharacter() *mapGlyphIndexToCharacter {\n\tvar m mapGlyphIndexToCharacter\n\treturn &m\n}\n\nfunc (m *mapGlyphIndexToCharacter) set(index int, r rune) {\n\tm.runes = append(m.runes, r)\n\tm.indexs = append(m.indexs, index)\n}\n\nfunc (m *mapGlyphIndexToCharacter) size() int {\n\treturn len(m.indexs)\n}\n\nfunc (m *mapGlyphIndexToCharacter) allIndexs() []int {\n\treturn m.indexs\n}\n\nfunc (m *mapGlyphIndexToCharacter) runeByIndex(index int) (rune, bool) {\n\tvar r rune\n\tok := false\n\tfor i, idx := range m.indexs {\n\t\tif idx == index {\n\t\t\tr = m.runes[i]\n\t\t\tok = true\n\t\t\tbreak\n\t\t}\n\t}\n\treturn r, ok\n}\n"
        }
      ]
    }
  ]
}