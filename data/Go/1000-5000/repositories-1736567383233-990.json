{
  "metadata": {
    "timestamp": 1736567383233,
    "page": 990,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjk5MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "h2non/filetype",
      "stars": 2144,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".editorconfig",
          "type": "blob",
          "size": 0.1826171875,
          "content": "root = true\n\n[*]\nindent_style = tabs\nindent_size = 2\nend_of_line = lf\ncharset = utf-8\ntrim_trailing_whitespace = true\ninsert_final_newline = true\n\n[*.md]\ntrim_trailing_whitespace = false\n"
        },
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.013671875,
          "content": "bin\n.DS_Store\n"
        },
        {
          "name": "History.md",
          "type": "blob",
          "size": 5.3994140625,
          "content": "\nv1.0.3 / 2021-11-21\n===================\n\n  * fix(#108): add application file matchers\n  * Merge pull request #106 from hannesbraun/aiff-support\n  * Add AIFF support\n  * fix(archive): format issue indentation\n  * feat(version): bump patch\n  * Merge pull request #100 from da2018/master\n  * Enhance Zstd support\n  * Merge pull request #98 from cfergeau/zstd\n  * Add zstd support\n  * Merge pull request #99 from cfergeau/byteprefixmatcher\n  * Introduce bytePrefixMatcher helper\n\nv1.1.0 / 2020-06-06\n===================\n\n  * feat: version bump v1.10\n  * feat(ci): add go 1.14\n  * Merge pull request #82 from andrewstucki/sqlite-update\n  * Merge pull request #84 from evanoberholster/master\n  * Better differentiation: between image/x-canon-cr2 and image/tiff\n  * Merge pull request #1 from h2non/master\n  * Update ico filetype per https://www.iana.org/assignments/media-types/image/vnd.microsoft.icon\n  * Update rar filetype per https://www.iana.org/assignments/media-types/application/vnd.rar\n  * Update exe filetype per https://www.iana.org/assignments/media-types/application/vnd.microsoft.portable-executable\n  * Update deb filetype per https://www.iana.org/assignments/media-types/application/vnd.debian.binary-package\n  * Update sqlite filetype per https://www.iana.org/assignments/media-types/application/vnd.sqlite3\n  * Merge pull request #72 from turn88/master\n  * Update document.go\n  * Update document.go\n  * Update document.go\n  * add matchers for office 2003\n\nv1.0.10 / 2019-08-06\n====================\n\n  * Merge pull request #76 from lex-r/fix-matroska-detection\n  * fix: mkv and webm types detection\n\nv1.0.9 / 2019-07-25\n===================\n\n  * Merge pull request #75 from Trane9991/master\n  * add video/3gpp support\n  * fix: use proper iso file mime type\n  * feat: add iso image format\n  * Merge pull request #65 from Fentonz/master\n  * Merge pull request #70 from fanpei91/master\n  * add image/vnd.dwg to README\n  * add image/vnd.dwg support\n  * Added support for .iso files\n\nv1.0.8 / 2019-02-10\n===================\n\n  * refactor(images): heic -> heif\n  * feat(docs): add heif format\n  * Merge pull request #60 from rikonor/master\n  * add heif/heic support\n  * fix(docs): dicom -> dcm\n  * feat: add dicom type\n  * Merge pull request #58 from Fentonz/master\n  * Merge pull request #59 from kmanley/master\n  * fix example; related to h2non/filetype#43\n  * Added DICOM type to archive\n\n\nv1.0.7 / 2019-02-09\n===================\n\n  * Merge pull request #56 from akupila/wasm\n  * add wasm to readme\n  * detect wasm file type\n\nv1.0.6 / 2019-01-22\n===================\n\n  * Merge pull request #55 from ivanlemeshev/master\n  * Added ftypmp4v to MP4 matcher\n  * Merge pull request #54 from aofei/master\n  * chore: add support for Go modules\n  * feat: add support for AAC (audio/aac)\n  * Merge pull request #53 from lynxbyorion/check-for-docoments\n  * Added checks for documents.\n  * Merge pull request #51 from eriken/master\n  * fixed bad mime and import paths\n  * Merge pull request #50 from eriken/jpeg2000_support\n  * fix import paths\n  * jpeg2000 support\n  * Merge pull request #47 from Ma124/master\n  * Merge pull request #49 from amoore614/master\n  * more robust check for .mov files\n  * bugfix: reverse order of matcher key list so user registered matchers appear first\n  * bugfix: store ptr to MatcherKeys in case user registered matchers are used.\n  * update comment\n  * Bump buffer size to 8K to allow for more custom file matching\n  * refactor(readme): update package import path\n  * Merge pull request #48 from kumakichi/support_msooxml\n  * do not use v1\n  * ok, master already changed travis\n  * add fixtures, but MatchReader may not work for some msooxml files, 4096 bytes maybe not enough\n  * support ms ooxml, #40\n  * Fixed misspells\n  * fix(travis): use string notation for matrix items\n  * Merge pull request #42 from bruth/patch-2\n  * refactor(travis): remove Go 1.6, add Go 1.10\n  * Change maximum bytes required for detection\n  * Merge pull request #36 from yiiTT/patch-1\n  * Add MP4 dash and additional ISO formats\n  * Merge pull request #34 from RangelReale/fix-mp4-case\n  * Merge pull request #32 from yiiTT/fix-m4v\n  * Fixed mp4 detection case-sensitivity according to http://www.ftyps.com/\n  * Fix M4v matcher\n\nv1.0.5 / 2017-12-12\n===================\n\n  * Merge pull request #30 from RangelReale/fix_mp4\n  * Fix duplicated item in mp4 fix\n  * Fix MP4 matcher, with information from http://www.file-recovery.com/mp4-signature-format.htm\n  * Merge pull request #28 from ikovic/master\n  * Updated file header example.\n\nv1.0.4 / 2017-11-29\n===================\n\n  * fix: tests and document types matchers\n  * refactor(docs): remove codesponsor\n  * Merge pull request #26 from bienkma/master\n  * Add support check file type: .doc, .docx, .pptx, .ppt, .xls, .xlsx\n  * feat(docs): add code sponsor banner\n  * feat(travis): add go 1.9\n  * Merge pull request #24 from strazzere/patch-1\n  * Fix typo in unknown\n\nv1.0.3 / 2017-08-03\n===================\n\n  * Merge pull request #21 from elemeta/master\n  * Add Elf file as supported matcher archive type\n\nv1.0.2 / 2017-07-26\n===================\n\n  * Merge pull request #20 from marshyski/master\n  * Added RedHat RPM as supported matcher archive type\n  * Merge pull request #19 from nlamirault/patch-1\n  * Fix typo in documentation\n\nv1.0.1 / 2017-02-24\n===================\n\n  * Merge pull request #18 from Impyy/enable-webm\n  * Enable the webm matcher\n  * feat(docs): add Go version badge\n\n1.0.0 / 2016-12-11\n==================\n\n- Initial stable version (v1.0.0).\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.044921875,
          "content": "The MIT License\n\nCopyright (c) Tomas Aparicio\n\nPermission is hereby granted, free of charge, to any person\nobtaining a copy of this software and associated documentation\nfiles (the \"Software\"), to deal in the Software without\nrestriction, including without limitation the rights to use,\ncopy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the\nSoftware is furnished to do so, subject to the following\nconditions:\n\nThe above copyright notice and this permission notice shall be\nincluded in all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\nEXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\nOF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\nNONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\nHOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\nWHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\nFROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\nOTHER DEALINGS IN THE SOFTWARE.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 6.9453125,
          "content": "# filetype [![GoDoc](https://godoc.org/github.com/h2non/filetype?status.svg)](https://godoc.org/github.com/h2non/filetype) [![Go Version](https://img.shields.io/badge/go-v1.0+-green.svg?style=flat)](https://github.com/h2non/gentleman)\n\nSmall and dependency free [Go](https://golang.org) package to infer file and MIME type checking the [magic numbers](<https://en.wikipedia.org/wiki/Magic_number_(programming)#Magic_numbers_in_files>) signature.\n\nFor SVG file type checking, see [go-is-svg](https://github.com/h2non/go-is-svg) package. Python port: [filetype.py](https://github.com/h2non/filetype.py).\n\n## Features\n\n- Supports a [wide range](#supported-types) of file types\n- Provides file extension and proper MIME type\n- File discovery by extension or MIME type\n- File discovery by class (image, video, audio...)\n- Provides a bunch of helpers and file matching shortcuts\n- [Pluggable](#add-additional-file-type-matchers): add custom new types and matchers\n- Simple and semantic API\n- [Blazing fast](#benchmarks), even processing large files\n- Only first 262 bytes representing the max file header is required, so you can just [pass a slice](#file-header)\n- Dependency free (just Go code, no C compilation needed)\n- Cross-platform file recognition\n\n## Installation\n\n```bash\ngo get github.com/h2non/filetype\n```\n\n## API\n\nSee [Godoc](https://godoc.org/github.com/h2non/filetype) reference.\n\n### Subpackages\n\n- [`github.com/h2non/filetype/types`](https://godoc.org/github.com/h2non/filetype/types)\n- [`github.com/h2non/filetype/matchers`](https://godoc.org/github.com/h2non/filetype/matchers)\n\n## Examples\n\n#### Simple file type checking\n\n```go\npackage main\n\nimport (\n  \"fmt\"\n  \"io/ioutil\"\n\n  \"github.com/h2non/filetype\"\n)\n\nfunc main() {\n  buf, _ := ioutil.ReadFile(\"sample.jpg\")\n\n  kind, _ := filetype.Match(buf)\n  if kind == filetype.Unknown {\n    fmt.Println(\"Unknown file type\")\n    return\n  }\n\n  fmt.Printf(\"File type: %s. MIME: %s\\n\", kind.Extension, kind.MIME.Value)\n}\n```\n\n#### Check type class\n\n```go\npackage main\n\nimport (\n  \"fmt\"\n  \"io/ioutil\"\n\n  \"github.com/h2non/filetype\"\n)\n\nfunc main() {\n  buf, _ := ioutil.ReadFile(\"sample.jpg\")\n\n  if filetype.IsImage(buf) {\n    fmt.Println(\"File is an image\")\n  } else {\n    fmt.Println(\"Not an image\")\n  }\n}\n```\n\n#### Supported type\n\n```go\npackage main\n\nimport (\n  \"fmt\"\n\n  \"github.com/h2non/filetype\"\n)\n\nfunc main() {\n  // Check if file is supported by extension\n  if filetype.IsSupported(\"jpg\") {\n    fmt.Println(\"Extension supported\")\n  } else {\n    fmt.Println(\"Extension not supported\")\n  }\n\n  // Check if file is supported by extension\n  if filetype.IsMIMESupported(\"image/jpeg\") {\n    fmt.Println(\"MIME type supported\")\n  } else {\n    fmt.Println(\"MIME type not supported\")\n  }\n}\n```\n\n#### File header\n\n```go\npackage main\n\nimport (\n  \"fmt\"\n  \"os\"\n\n  \"github.com/h2non/filetype\"\n)\n\nfunc main() {\n  // Open a file descriptor\n  file, _ := os.Open(\"movie.mp4\")\n\n  // We only have to pass the file header = first 261 bytes\n  head := make([]byte, 261)\n  file.Read(head)\n\n  if filetype.IsImage(head) {\n    fmt.Println(\"File is an image\")\n  } else {\n    fmt.Println(\"Not an image\")\n  }\n}\n```\n\n#### Add additional file type matchers\n\n```go\npackage main\n\nimport (\n  \"fmt\"\n\n  \"github.com/h2non/filetype\"\n)\n\nvar fooType = filetype.NewType(\"foo\", \"foo/foo\")\n\nfunc fooMatcher(buf []byte) bool {\n  return len(buf) > 1 && buf[0] == 0x01 && buf[1] == 0x02\n}\n\nfunc main() {\n  // Register the new matcher and its type\n  filetype.AddMatcher(fooType, fooMatcher)\n\n  // Check if the new type is supported by extension\n  if filetype.IsSupported(\"foo\") {\n    fmt.Println(\"New supported type: foo\")\n  }\n\n  // Check if the new type is supported by MIME\n  if filetype.IsMIMESupported(\"foo/foo\") {\n    fmt.Println(\"New supported MIME type: foo/foo\")\n  }\n\n  // Try to match the file\n  fooFile := []byte{0x01, 0x02}\n  kind, _ := filetype.Match(fooFile)\n  if kind == filetype.Unknown {\n    fmt.Println(\"Unknown file type\")\n  } else {\n    fmt.Printf(\"File type matched: %s\\n\", kind.Extension)\n  }\n}\n```\n\n## Supported types\n\n#### Image\n\n- **jpg** - `image/jpeg`\n- **png** - `image/png`\n- **gif** - `image/gif`\n- **webp** - `image/webp`\n- **cr2** - `image/x-canon-cr2`\n- **tif** - `image/tiff`\n- **bmp** - `image/bmp`\n- **heif** - `image/heif`\n- **jxr** - `image/vnd.ms-photo`\n- **psd** - `image/vnd.adobe.photoshop`\n- **ico** - `image/vnd.microsoft.icon`\n- **dwg** - `image/vnd.dwg`\n- **avif** - `image/avif`\n\n#### Video\n\n- **mp4** - `video/mp4`\n- **m4v** - `video/x-m4v`\n- **mkv** - `video/x-matroska`\n- **webm** - `video/webm`\n- **mov** - `video/quicktime`\n- **avi** - `video/x-msvideo`\n- **wmv** - `video/x-ms-wmv`\n- **mpg** - `video/mpeg`\n- **flv** - `video/x-flv`\n- **3gp** - `video/3gpp`\n\n#### Audio\n\n- **mid** - `audio/midi`\n- **mp3** - `audio/mpeg`\n- **m4a** - `audio/mp4`\n- **ogg** - `audio/ogg`\n- **flac** - `audio/x-flac`\n- **wav** - `audio/x-wav`\n- **amr** - `audio/amr`\n- **aac** - `audio/aac`\n- **aiff** - `audio/x-aiff`\n\n#### Archive\n\n- **epub** - `application/epub+zip`\n- **zip** - `application/zip`\n- **tar** - `application/x-tar`\n- **rar** - `application/vnd.rar`\n- **gz** - `application/gzip`\n- **bz2** - `application/x-bzip2`\n- **7z** - `application/x-7z-compressed`\n- **xz** - `application/x-xz`\n- **zstd** - `application/zstd`\n- **pdf** - `application/pdf`\n- **exe** - `application/vnd.microsoft.portable-executable`\n- **swf** - `application/x-shockwave-flash`\n- **rtf** - `application/rtf`\n- **iso** - `application/x-iso9660-image`\n- **eot** - `application/octet-stream`\n- **ps** - `application/postscript`\n- **sqlite** - `application/vnd.sqlite3`\n- **nes** - `application/x-nintendo-nes-rom`\n- **crx** - `application/x-google-chrome-extension`\n- **cab** - `application/vnd.ms-cab-compressed`\n- **deb** - `application/vnd.debian.binary-package`\n- **ar** - `application/x-unix-archive`\n- **Z** - `application/x-compress`\n- **lz** - `application/x-lzip`\n- **rpm** - `application/x-rpm`\n- **elf** - `application/x-executable`\n- **dcm** - `application/dicom`\n\n#### Documents\n\n- **doc** - `application/msword`\n- **docx** - `application/vnd.openxmlformats-officedocument.wordprocessingml.document`\n- **xls** - `application/vnd.ms-excel`\n- **xlsx** - `application/vnd.openxmlformats-officedocument.spreadsheetml.sheet`\n- **ppt** - `application/vnd.ms-powerpoint`\n- **pptx** - `application/vnd.openxmlformats-officedocument.presentationml.presentation`\n\n#### Font\n\n- **woff** - `application/font-woff`\n- **woff2** - `application/font-woff`\n- **ttf** - `application/font-sfnt`\n- **otf** - `application/font-sfnt`\n\n#### Application\n\n- **wasm** - `application/wasm`\n- **dex** - `application/vnd.android.dex`\n- **dey** - `application/vnd.android.dey`\n\n## Benchmarks\n\nMeasured using [real files](https://github.com/h2non/filetype/tree/master/fixtures).\n\nEnvironment: OSX x64 i7 2.7 Ghz\n\n```bash\nBenchmarkMatchTar-8    1000000        1083 ns/op\nBenchmarkMatchZip-8    1000000        1162 ns/op\nBenchmarkMatchJpeg-8   1000000        1280 ns/op\nBenchmarkMatchGif-8    1000000        1315 ns/op\nBenchmarkMatchPng-8    1000000        1121 ns/op\n```\n\n## License\n\nMIT - Tomas Aparicio\n"
        },
        {
          "name": "filetype.go",
          "type": "blob",
          "size": 2.20703125,
          "content": "package filetype\n\nimport (\n\t\"errors\"\n\n\t\"github.com/h2non/filetype/matchers\"\n\t\"github.com/h2non/filetype/types\"\n)\n\n// Types stores a map of supported types\nvar Types = types.Types\n\n// NewType creates and registers a new type\nvar NewType = types.NewType\n\n// Unknown represents an unknown file type\nvar Unknown = types.Unknown\n\n// ErrEmptyBuffer represents an empty buffer error\nvar ErrEmptyBuffer = errors.New(\"Empty buffer\")\n\n// ErrUnknownBuffer represents a unknown buffer error\nvar ErrUnknownBuffer = errors.New(\"Unknown buffer type\")\n\n// AddType registers a new file type\nfunc AddType(ext, mime string) types.Type {\n\treturn types.NewType(ext, mime)\n}\n\n// Is checks if a given buffer matches with the given file type extension\nfunc Is(buf []byte, ext string) bool {\n\tkind := types.Get(ext)\n\tif kind != types.Unknown {\n\t\treturn IsType(buf, kind)\n\t}\n\treturn false\n}\n\n// IsExtension semantic alias to Is()\nfunc IsExtension(buf []byte, ext string) bool {\n\treturn Is(buf, ext)\n}\n\n// IsType checks if a given buffer matches with the given file type\nfunc IsType(buf []byte, kind types.Type) bool {\n\tmatcher := matchers.Matchers[kind]\n\tif matcher == nil {\n\t\treturn false\n\t}\n\treturn matcher(buf) != types.Unknown\n}\n\n// IsMIME checks if a given buffer matches with the given MIME type\nfunc IsMIME(buf []byte, mime string) bool {\n\tresult := false\n\ttypes.Types.Range(func(k, v interface{}) bool {\n\t\tkind := v.(types.Type)\n\t\tif kind.MIME.Value == mime {\n\t\t\tmatcher := matchers.Matchers[kind]\n\t\t\tresult = matcher(buf) != types.Unknown\n\t\t\treturn false\n\t\t}\n\t\treturn true\n\t})\n\n\treturn result\n}\n\n// IsSupported checks if a given file extension is supported\nfunc IsSupported(ext string) bool {\n\tresult := false\n\ttypes.Types.Range(func(k, v interface{}) bool {\n\t\tkey := k.(string)\n\t\tif key == ext {\n\t\t\tresult = true\n\t\t\treturn false\n\t\t}\n\t\treturn true\n\t})\n\n\treturn result\n}\n\n// IsMIMESupported checks if a given MIME type is supported\nfunc IsMIMESupported(mime string) bool {\n\tresult := false\n\ttypes.Types.Range(func(k, v interface{}) bool {\n\t\tkind := v.(types.Type)\n\t\tif kind.MIME.Value == mime {\n\t\t\tresult = true\n\t\t\treturn false\n\t\t}\n\t\treturn true\n\t})\n\n\treturn result\n}\n\n// GetType retrieves a Type by file extension\nfunc GetType(ext string) types.Type {\n\treturn types.Get(ext)\n}\n"
        },
        {
          "name": "filetype_test.go",
          "type": "blob",
          "size": 2.53125,
          "content": "package filetype\n\nimport (\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/h2non/filetype/types\"\n)\n\nfunc TestConcurrent(t *testing.T) {\n\tgo func() {\n\t\tfor i := 0; i < 10000; i++ {\n\t\t\ttypes.NewType(\"xml\", \"text/xml\")\n\t\t}\n\t}()\n\tgo func() {\n\t\tfor i := 0; i < 10000; i++ {\n\t\t\ttypes.NewType(\"xml\", \"text/xml\")\n\t\t}\n\t}()\n\n\ttime.Sleep(time.Second * 2)\n}\n\nfunc TestIs(t *testing.T) {\n\tcases := []struct {\n\t\tbuf   []byte\n\t\text   string\n\t\tmatch bool\n\t}{\n\t\t{[]byte{0xFF, 0xD8, 0xFF}, \"jpg\", true},\n\t\t{[]byte{0xFF, 0xD8, 0x00}, \"jpg\", false},\n\t\t{[]byte{0x89, 0x50, 0x4E, 0x47}, \"png\", true},\n\t}\n\n\tfor _, test := range cases {\n\t\tif Is(test.buf, test.ext) != test.match {\n\t\t\tt.Fatalf(\"Invalid match: %s\", test.ext)\n\t\t}\n\t}\n\n}\n\nfunc TestIsType(t *testing.T) {\n\tcases := []struct {\n\t\tbuf   []byte\n\t\tkind  types.Type\n\t\tmatch bool\n\t}{\n\t\t{[]byte{0xFF, 0xD8, 0xFF}, types.Get(\"jpg\"), true},\n\t\t{[]byte{0xFF, 0xD8, 0x00}, types.Get(\"jpg\"), false},\n\t\t{[]byte{0x89, 0x50, 0x4E, 0x47}, types.Get(\"png\"), true},\n\t}\n\n\tfor _, test := range cases {\n\t\tif IsType(test.buf, test.kind) != test.match {\n\t\t\tt.Fatalf(\"Invalid match: %s\", test.kind.Extension)\n\t\t}\n\t}\n}\n\nfunc TestIsMIME(t *testing.T) {\n\tcases := []struct {\n\t\tbuf   []byte\n\t\tmime  string\n\t\tmatch bool\n\t}{\n\t\t{[]byte{0xFF, 0xD8, 0xFF}, \"image/jpeg\", true},\n\t\t{[]byte{0xFF, 0xD8, 0x00}, \"image/jpeg\", false},\n\t\t{[]byte{0x89, 0x50, 0x4E, 0x47}, \"image/png\", true},\n\t}\n\n\tfor _, test := range cases {\n\t\tif IsMIME(test.buf, test.mime) != test.match {\n\t\t\tt.Fatalf(\"Invalid match: %s\", test.mime)\n\t\t}\n\t}\n}\n\nfunc TestIsSupported(t *testing.T) {\n\tcases := []struct {\n\t\text   string\n\t\tmatch bool\n\t}{\n\t\t{\"jpg\", true},\n\t\t{\"jpeg\", false},\n\t\t{\"abc\", false},\n\t\t{\"png\", true},\n\t\t{\"mp4\", true},\n\t\t{\"\", false},\n\t}\n\n\tfor _, test := range cases {\n\t\tif IsSupported(test.ext) != test.match {\n\t\t\tt.Fatalf(\"Invalid match: %s\", test.ext)\n\t\t}\n\t}\n}\n\nfunc TestIsMIMESupported(t *testing.T) {\n\tcases := []struct {\n\t\tmime  string\n\t\tmatch bool\n\t}{\n\t\t{\"image/jpeg\", true},\n\t\t{\"foo/bar\", false},\n\t\t{\"image/png\", true},\n\t\t{\"video/mpeg\", true},\n\t}\n\n\tfor _, test := range cases {\n\t\tif IsMIMESupported(test.mime) != test.match {\n\t\t\tt.Fatalf(\"Invalid match: %s\", test.mime)\n\t\t}\n\t}\n}\n\nfunc TestAddType(t *testing.T) {\n\tAddType(\"foo\", \"foo/foo\")\n\n\tif !IsSupported(\"foo\") {\n\t\tt.Fatalf(\"Not supported extension\")\n\t}\n\n\tif !IsMIMESupported(\"foo/foo\") {\n\t\tt.Fatalf(\"Not supported MIME type\")\n\t}\n}\n\nfunc TestGetType(t *testing.T) {\n\tjpg := GetType(\"jpg\")\n\tif jpg == types.Unknown {\n\t\tt.Fatalf(\"Type should be supported\")\n\t}\n\n\tinvalid := GetType(\"invalid\")\n\tif invalid != Unknown {\n\t\tt.Fatalf(\"Type should not be supported\")\n\t}\n}\n"
        },
        {
          "name": "fixtures",
          "type": "tree",
          "content": null
        },
        {
          "name": "go.mod",
          "type": "blob",
          "size": 0.041015625,
          "content": "module github.com/h2non/filetype\n\ngo 1.13\n"
        },
        {
          "name": "kind.go",
          "type": "blob",
          "size": 2.26171875,
          "content": "package filetype\n\nimport (\n\t\"github.com/h2non/filetype/matchers\"\n\t\"github.com/h2non/filetype/types\"\n)\n\n// Image tries to match a file as image type\nfunc Image(buf []byte) (types.Type, error) {\n\treturn doMatchMap(buf, matchers.Image)\n}\n\n// IsImage checks if the given buffer is an image type\nfunc IsImage(buf []byte) bool {\n\tkind, _ := Image(buf)\n\treturn kind != types.Unknown\n}\n\n// Audio tries to match a file as audio type\nfunc Audio(buf []byte) (types.Type, error) {\n\treturn doMatchMap(buf, matchers.Audio)\n}\n\n// IsAudio checks if the given buffer is an audio type\nfunc IsAudio(buf []byte) bool {\n\tkind, _ := Audio(buf)\n\treturn kind != types.Unknown\n}\n\n// Video tries to match a file as video type\nfunc Video(buf []byte) (types.Type, error) {\n\treturn doMatchMap(buf, matchers.Video)\n}\n\n// IsVideo checks if the given buffer is a video type\nfunc IsVideo(buf []byte) bool {\n\tkind, _ := Video(buf)\n\treturn kind != types.Unknown\n}\n\n// Font tries to match a file as text font type\nfunc Font(buf []byte) (types.Type, error) {\n\treturn doMatchMap(buf, matchers.Font)\n}\n\n// IsFont checks if the given buffer is a font type\nfunc IsFont(buf []byte) bool {\n\tkind, _ := Font(buf)\n\treturn kind != types.Unknown\n}\n\n// Archive tries to match a file as generic archive type\nfunc Archive(buf []byte) (types.Type, error) {\n\treturn doMatchMap(buf, matchers.Archive)\n}\n\n// IsArchive checks if the given buffer is an archive type\nfunc IsArchive(buf []byte) bool {\n\tkind, _ := Archive(buf)\n\treturn kind != types.Unknown\n}\n\n// Document tries to match a file as document type\nfunc Document(buf []byte) (types.Type, error) {\n\treturn doMatchMap(buf, matchers.Document)\n}\n\n// IsDocument checks if the given buffer is an document type\nfunc IsDocument(buf []byte) bool {\n\tkind, _ := Document(buf)\n\treturn kind != types.Unknown\n}\n\n// Application tries to match a file as an application type\nfunc Application(buf []byte) (types.Type, error) {\n\treturn doMatchMap(buf, matchers.Application)\n}\n\n// IsApplication checks if the given buffer is an application type\nfunc IsApplication(buf []byte) bool {\n\tkind, _ := Application(buf)\n\treturn kind != types.Unknown\n}\n\nfunc doMatchMap(buf []byte, machers matchers.Map) (types.Type, error) {\n\tkind := MatchMap(buf, machers)\n\tif kind != types.Unknown {\n\t\treturn kind, nil\n\t}\n\treturn kind, ErrUnknownBuffer\n}\n"
        },
        {
          "name": "kind_test.go",
          "type": "blob",
          "size": 0.7265625,
          "content": "package filetype\n\nimport (\n\t\"testing\"\n)\n\nfunc TestKind(t *testing.T) {\n\tvar cases = []struct {\n\t\tbuf []byte\n\t\text string\n\t}{\n\t\t{[]byte{0xFF, 0xD8, 0xFF}, \"jpg\"},\n\t\t{[]byte{0x89, 0x50, 0x4E, 0x47}, \"png\"},\n\t\t{[]byte{0x89, 0x0, 0x0}, \"unknown\"},\n\t}\n\n\tfor _, test := range cases {\n\t\tkind, _ := Image(test.buf)\n\t\tif kind.Extension != test.ext {\n\t\t\tt.Fatalf(\"Invalid match: %s != %s\", kind.Extension, test.ext)\n\t\t}\n\t}\n}\n\nfunc TestIsKind(t *testing.T) {\n\tvar cases = []struct {\n\t\tbuf   []byte\n\t\tmatch bool\n\t}{\n\t\t{[]byte{0xFF, 0xD8, 0xFF}, true},\n\t\t{[]byte{0x89, 0x50, 0x4E, 0x47}, true},\n\t\t{[]byte{0x89, 0x0, 0x0}, false},\n\t}\n\n\tfor _, test := range cases {\n\t\tif IsImage(test.buf) != test.match {\n\t\t\tt.Fatalf(\"Invalid match: %t\", test.match)\n\t\t}\n\t}\n}\n"
        },
        {
          "name": "match.go",
          "type": "blob",
          "size": 2.1845703125,
          "content": "package filetype\n\nimport (\n\t\"io\"\n\t\"os\"\n\n\t\"github.com/h2non/filetype/matchers\"\n\t\"github.com/h2non/filetype/types\"\n)\n\n// Matchers is an alias to matchers.Matchers\nvar Matchers = matchers.Matchers\n\n// MatcherKeys is an alias to matchers.MatcherKeys\nvar MatcherKeys = &matchers.MatcherKeys\n\n// NewMatcher is an alias to matchers.NewMatcher\nvar NewMatcher = matchers.NewMatcher\n\n// Match infers the file type of a given buffer inspecting its magic numbers signature\nfunc Match(buf []byte) (types.Type, error) {\n\tlength := len(buf)\n\tif length == 0 {\n\t\treturn types.Unknown, ErrEmptyBuffer\n\t}\n\n\tfor _, kind := range *MatcherKeys {\n\t\tchecker := Matchers[kind]\n\t\tmatch := checker(buf)\n\t\tif match != types.Unknown && match.Extension != \"\" {\n\t\t\treturn match, nil\n\t\t}\n\t}\n\n\treturn types.Unknown, nil\n}\n\n// Get is an alias to Match()\nfunc Get(buf []byte) (types.Type, error) {\n\treturn Match(buf)\n}\n\n// MatchFile infers a file type for a file\nfunc MatchFile(filepath string) (types.Type, error) {\n\tfile, err := os.Open(filepath)\n\tif err != nil {\n\t\treturn types.Unknown, err\n\t}\n\tdefer file.Close()\n\n\treturn MatchReader(file)\n}\n\n// MatchReader is convenient wrapper to Match() any Reader\nfunc MatchReader(reader io.Reader) (types.Type, error) {\n\tbuffer := make([]byte, 8192) // 8K makes msooxml tests happy and allows for expanded custom file checks\n\n\t_, err := reader.Read(buffer)\n\tif err != nil && err != io.EOF {\n\t\treturn types.Unknown, err\n\t}\n\n\treturn Match(buffer)\n}\n\n// AddMatcher registers a new matcher type\nfunc AddMatcher(fileType types.Type, matcher matchers.Matcher) matchers.TypeMatcher {\n\treturn matchers.NewMatcher(fileType, matcher)\n}\n\n// Matches checks if the given buffer matches with some supported file type\nfunc Matches(buf []byte) bool {\n\tkind, _ := Match(buf)\n\treturn kind != types.Unknown\n}\n\n// MatchMap performs a file matching against a map of match functions\nfunc MatchMap(buf []byte, matchers matchers.Map) types.Type {\n\tfor kind, matcher := range matchers {\n\t\tif matcher(buf) {\n\t\t\treturn kind\n\t\t}\n\t}\n\treturn types.Unknown\n}\n\n// MatchesMap is an alias to Matches() but using matching against a map of match functions\nfunc MatchesMap(buf []byte, matchers matchers.Map) bool {\n\treturn MatchMap(buf, matchers) != types.Unknown\n}\n"
        },
        {
          "name": "match_test.go",
          "type": "blob",
          "size": 4.95703125,
          "content": "package filetype\n\nimport (\n\t\"bytes\"\n\t\"io\"\n\t\"io/ioutil\"\n\t\"testing\"\n\n\t\"github.com/h2non/filetype/matchers\"\n\t\"github.com/h2non/filetype/types\"\n)\n\nfunc TestMatch(t *testing.T) {\n\tcases := []struct {\n\t\tbuf []byte\n\t\text string\n\t}{\n\t\t{[]byte{0xFF, 0xD8, 0xFF}, \"jpg\"},\n\t\t{[]byte{0xFF, 0xD8, 0x00}, \"unknown\"},\n\t\t{[]byte{0x89, 0x50, 0x4E, 0x47}, \"png\"},\n\t}\n\n\tfor _, test := range cases {\n\t\tmatch, err := Match(test.buf)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"Error: %s\", err)\n\t\t}\n\n\t\tif match.Extension != test.ext {\n\t\t\tt.Fatalf(\"Invalid image type: %s != %s\", match.Extension, test.ext)\n\t\t}\n\t}\n}\n\nfunc TestMatchFile(t *testing.T) {\n\tcases := []struct {\n\t\text string\n\t}{\n\t\t{\"gif\"},\n\t\t{\"jpg\"},\n\t\t{\"png\"},\n\t\t{\"zip\"},\n\t\t{\"tar\"},\n\t\t{\"tif\"},\n\t\t{\"mp4\"},\n\t\t{\"mkv\"},\n\t\t{\"webm\"},\n\t\t{\"docx\"},\n\t\t{\"pptx\"},\n\t\t{\"xlsx\"},\n\t\t{\"mov\"},\n\t\t{\"wasm\"},\n\t\t{\"dwg\"},\n\t\t{\"zst\"},\n\t\t{\"exr\"},\n\t\t{\"avif\"},\n\t}\n\n\tfor _, test := range cases {\n\t\tkind, _ := MatchFile(\"./fixtures/sample.\" + test.ext)\n\t\tif kind.Extension != test.ext {\n\t\t\tt.Fatalf(\"Invalid type: %s != %s\", kind.Extension, test.ext)\n\t\t}\n\t}\n\t// test zstd with skippable frame\n\tkind, _ := MatchFile(\"./fixtures/sample_skippable.zst\")\n\tif kind.Extension != \"zst\" {\n\t\tt.Fatalf(\"Invalid type: %s != %s\", kind.Extension, \"zst\")\n\t}\n}\n\nfunc TestMatchReader(t *testing.T) {\n\tcases := []struct {\n\t\tbuf io.Reader\n\t\text string\n\t}{\n\t\t{bytes.NewBuffer([]byte{0xFF, 0xD8, 0xFF}), \"jpg\"},\n\t\t{bytes.NewBuffer([]byte{0xFF, 0xD8, 0x00}), \"unknown\"},\n\t\t{bytes.NewBuffer([]byte{0x89, 0x50, 0x4E, 0x47}), \"png\"},\n\t}\n\n\tfor _, test := range cases {\n\t\tmatch, err := MatchReader(test.buf)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"Error: %s\", err)\n\t\t}\n\n\t\tif match.Extension != test.ext {\n\t\t\tt.Fatalf(\"Invalid image type: %s\", match.Extension)\n\t\t}\n\t}\n}\n\nfunc TestMatches(t *testing.T) {\n\tcases := []struct {\n\t\tbuf   []byte\n\t\tmatch bool\n\t}{\n\t\t{[]byte{0xFF, 0xD8, 0xFF}, true},\n\t\t{[]byte{0xFF, 0x0, 0x0}, false},\n\t\t{[]byte{0x89, 0x50, 0x4E, 0x47}, true},\n\t}\n\n\tfor _, test := range cases {\n\t\tif Matches(test.buf) != test.match {\n\t\t\tt.Fatalf(\"Do not matches: %#v\", test.buf)\n\t\t}\n\t}\n}\n\nfunc TestAddMatcher(t *testing.T) {\n\tfileType := AddType(\"foo\", \"foo/foo\")\n\n\tAddMatcher(fileType, func(buf []byte) bool {\n\t\treturn len(buf) == 2 && buf[0] == 0x00 && buf[1] == 0x00\n\t})\n\n\tif !Is([]byte{0x00, 0x00}, \"foo\") {\n\t\tt.Fatalf(\"Type cannot match\")\n\t}\n\n\tif !IsSupported(\"foo\") {\n\t\tt.Fatalf(\"Not supported extension\")\n\t}\n\n\tif !IsMIMESupported(\"foo/foo\") {\n\t\tt.Fatalf(\"Not supported MIME type\")\n\t}\n}\n\nfunc TestMatchMap(t *testing.T) {\n\tcases := []struct {\n\t\tbuf  []byte\n\t\tkind types.Type\n\t}{\n\t\t{[]byte{0xFF, 0xD8, 0xFF}, types.Get(\"jpg\")},\n\t\t{[]byte{0x89, 0x50, 0x4E, 0x47}, types.Get(\"png\")},\n\t\t{[]byte{0xFF, 0x0, 0x0}, Unknown},\n\t}\n\n\tfor _, test := range cases {\n\t\tif kind := MatchMap(test.buf, matchers.Image); kind != test.kind {\n\t\t\tt.Fatalf(\"Do not matches: %#v\", test.buf)\n\t\t}\n\t}\n}\n\nfunc TestMatchesMap(t *testing.T) {\n\tcases := []struct {\n\t\tbuf   []byte\n\t\tmatch bool\n\t}{\n\t\t{[]byte{0xFF, 0xD8, 0xFF}, true},\n\t\t{[]byte{0x89, 0x50, 0x4E, 0x47}, true},\n\t\t{[]byte{0xFF, 0x0, 0x0}, false},\n\t}\n\n\tfor _, test := range cases {\n\t\tif match := MatchesMap(test.buf, matchers.Image); match != test.match {\n\t\t\tt.Fatalf(\"Do not matches: %#v\", test.buf)\n\t\t}\n\t}\n}\n\n//\n// Benchmarks\n//\n\nvar tarBuffer, _ = ioutil.ReadFile(\"./fixtures/sample.tar\")\nvar zipBuffer, _ = ioutil.ReadFile(\"./fixtures/sample.zip\")\nvar jpgBuffer, _ = ioutil.ReadFile(\"./fixtures/sample.jpg\")\nvar gifBuffer, _ = ioutil.ReadFile(\"./fixtures/sample.gif\")\nvar pngBuffer, _ = ioutil.ReadFile(\"./fixtures/sample.png\")\nvar xlsxBuffer, _ = ioutil.ReadFile(\"./fixtures/sample.xlsx\")\nvar pptxBuffer, _ = ioutil.ReadFile(\"./fixtures/sample.pptx\")\nvar docxBuffer, _ = ioutil.ReadFile(\"./fixtures/sample.docx\")\nvar dwgBuffer, _ = ioutil.ReadFile(\"./fixtures/sample.dwg\")\nvar mkvBuffer, _ = ioutil.ReadFile(\"./fixtures/sample.mkv\")\nvar webmBuffer, _ = ioutil.ReadFile(\"./fixtures/sample.webm\")\nvar exrBuffer, _ = ioutil.ReadFile(\"./fixtures/sample.exr\")\n\nfunc BenchmarkMatchTar(b *testing.B) {\n\tfor n := 0; n < b.N; n++ {\n\t\tMatch(tarBuffer)\n\t}\n}\n\nfunc BenchmarkMatchZip(b *testing.B) {\n\tfor n := 0; n < b.N; n++ {\n\t\tMatch(zipBuffer)\n\t}\n}\n\nfunc BenchmarkMatchJpeg(b *testing.B) {\n\tfor n := 0; n < b.N; n++ {\n\t\tMatch(jpgBuffer)\n\t}\n}\n\nfunc BenchmarkMatchGif(b *testing.B) {\n\tfor n := 0; n < b.N; n++ {\n\t\tMatch(gifBuffer)\n\t}\n}\n\nfunc BenchmarkMatchPng(b *testing.B) {\n\tfor n := 0; n < b.N; n++ {\n\t\tMatch(pngBuffer)\n\t}\n}\n\nfunc BenchmarkMatchXlsx(b *testing.B) {\n\tfor n := 0; n < b.N; n++ {\n\t\tMatch(xlsxBuffer)\n\t}\n}\n\nfunc BenchmarkMatchPptx(b *testing.B) {\n\tfor n := 0; n < b.N; n++ {\n\t\tMatch(pptxBuffer)\n\t}\n}\n\nfunc BenchmarkMatchDocx(b *testing.B) {\n\tfor n := 0; n < b.N; n++ {\n\t\tMatch(docxBuffer)\n\t}\n}\n\nfunc BenchmarkMatchDwg(b *testing.B) {\n\tfor n := 0; n < b.N; n++ {\n\t\tMatch(dwgBuffer)\n\t}\n}\n\nfunc BenchmarkMatchMkv(b *testing.B) {\n\tfor n := 0; n < b.N; n++ {\n\t\tMatch(mkvBuffer)\n\t}\n}\n\nfunc BenchmarkMatchWebm(b *testing.B) {\n\tfor n := 0; n < b.N; n++ {\n\t\tMatch(webmBuffer)\n\t}\n}\n\nfunc BenchmarkMatchExr(b *testing.B) {\n\tfor n := 0; n < b.N; n++ {\n\t\tMatch(exrBuffer)\n\t}\n}\n"
        },
        {
          "name": "matchers",
          "type": "tree",
          "content": null
        },
        {
          "name": "types",
          "type": "tree",
          "content": null
        },
        {
          "name": "version.go",
          "type": "blob",
          "size": 0.087890625,
          "content": "package filetype\n\n// Version exposes the current package version.\nconst Version = \"1.1.3\"\n"
        }
      ]
    }
  ]
}