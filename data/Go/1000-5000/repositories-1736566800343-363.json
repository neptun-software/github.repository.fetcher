{
  "metadata": {
    "timestamp": 1736566800343,
    "page": 363,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjM3MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "cshum/imagor",
      "stars": 3508,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".dockerignore",
          "type": "blob",
          "size": 0.0703125,
          "content": "**/*~\n.git\n.env\n.idea\nbin\ntmp/\n.DS_Store\n.vscode\nbin/imagor\nprofile.cov\n"
        },
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.0908203125,
          "content": "vendor/\n**/*.log\n**/*.sqlite\n.idea/\n.DS_Store\nbin/\ntmp/\n.vscode/\n.env\nbin/imagor\nprofile.cov\n"
        },
        {
          "name": "CODE_OF_CONDUCT.md",
          "type": "blob",
          "size": 5.103515625,
          "content": "# Contributor Covenant Code of Conduct\n\n## Our Pledge\n\nWe as members, contributors, and leaders pledge to make participation in our\ncommunity a harassment-free experience for everyone, regardless of age, body\nsize, visible or invisible disability, ethnicity, sex characteristics, gender\nidentity and expression, level of experience, education, socio-economic status,\nnationality, personal appearance, race, religion, or sexual identity\nand orientation.\n\nWe pledge to act and interact in ways that contribute to an open, welcoming,\ndiverse, inclusive, and healthy community.\n\n## Our Standards\n\nExamples of behavior that contributes to a positive environment for our\ncommunity include:\n\n* Demonstrating empathy and kindness toward other people\n* Being respectful of differing opinions, viewpoints, and experiences\n* Giving and gracefully accepting constructive feedback\n* Accepting responsibility and apologizing to those affected by our mistakes,\n  and learning from the experience\n* Focusing on what is best not just for us as individuals, but for the\n  overall community\n\nExamples of unacceptable behavior include:\n\n* The use of sexualized language or imagery, and sexual attention or\n  advances of any kind\n* Trolling, insulting or derogatory comments, and personal or political attacks\n* Public or private harassment\n* Publishing others' private information, such as a physical or email\n  address, without their explicit permission\n* Other conduct which could reasonably be considered inappropriate in a\n  professional setting\n\n## Enforcement Responsibilities\n\nCommunity leaders are responsible for clarifying and enforcing our standards of\nacceptable behavior and will take appropriate and fair corrective action in\nresponse to any behavior that they deem inappropriate, threatening, offensive,\nor harmful.\n\nCommunity leaders have the right and responsibility to remove, edit, or reject\ncomments, commits, code, wiki edits, issues, and other contributions that are\nnot aligned to this Code of Conduct, and will communicate reasons for moderation\ndecisions when appropriate.\n\n## Scope\n\nThis Code of Conduct applies within all community spaces, and also applies when\nan individual is officially representing the community in public spaces.\nExamples of representing our community include using an official e-mail address,\nposting via an official social media account, or acting as an appointed\nrepresentative at an online or offline event.\n\n## Enforcement\n\nInstances of abusive, harassing, or otherwise unacceptable behavior may be\nreported to the community leaders responsible for enforcement at\nbib-infra@lists.ugent.be.\nAll complaints will be reviewed and investigated promptly and fairly.\n\nAll community leaders are obligated to respect the privacy and security of the\nreporter of any incident.\n\n## Enforcement Guidelines\n\nCommunity leaders will follow these Community Impact Guidelines in determining\nthe consequences for any action they deem in violation of this Code of Conduct:\n\n### 1. Correction\n\n**Community Impact**: Use of inappropriate language or other behavior deemed\nunprofessional or unwelcome in the community.\n\n**Consequence**: A private, written warning from community leaders, providing\nclarity around the nature of the violation and an explanation of why the\nbehavior was inappropriate. A public apology may be requested.\n\n### 2. Warning\n\n**Community Impact**: A violation through a single incident or series\nof actions.\n\n**Consequence**: A warning with consequences for continued behavior. No\ninteraction with the people involved, including unsolicited interaction with\nthose enforcing the Code of Conduct, for a specified period of time. This\nincludes avoiding interactions in community spaces as well as external channels\nlike social media. Violating these terms may lead to a temporary or\npermanent ban.\n\n### 3. Temporary Ban\n\n**Community Impact**: A serious violation of community standards, including\nsustained inappropriate behavior.\n\n**Consequence**: A temporary ban from any sort of interaction or public\ncommunication with the community for a specified period of time. No public or\nprivate interaction with the people involved, including unsolicited interaction\nwith those enforcing the Code of Conduct, is allowed during this period.\nViolating these terms may lead to a permanent ban.\n\n### 4. Permanent Ban\n\n**Community Impact**: Demonstrating a pattern of violation of community\nstandards, including sustained inappropriate behavior,  harassment of an\nindividual, or aggression toward or disparagement of classes of individuals.\n\n**Consequence**: A permanent ban from any sort of public interaction within\nthe community.\n\n## Attribution\n\nThis Code of Conduct is adapted from the [Contributor Covenant][homepage],\nversion 2.0, available at\nhttps://www.contributor-covenant.org/version/2/0/code_of_conduct.html.\n\nCommunity Impact Guidelines were inspired by [Mozilla's code of conduct\nenforcement ladder](https://github.com/mozilla/diversity).\n\n[homepage]: https://www.contributor-covenant.org\n\nFor answers to common questions about this code of conduct, see the FAQ at\nhttps://www.contributor-covenant.org/faq. Translations are available at\nhttps://www.contributor-covenant.org/translations.\n"
        },
        {
          "name": "Dockerfile",
          "type": "blob",
          "size": 2.6396484375,
          "content": "ARG GOLANG_VERSION=1.23.4\nFROM golang:${GOLANG_VERSION}-bookworm as builder\n\nARG VIPS_VERSION=8.16.0\nARG TARGETARCH\n\nENV PKG_CONFIG_PATH=/usr/local/lib/pkgconfig\n\n# Installs libvips + required libraries\nRUN DEBIAN_FRONTEND=noninteractive \\\n  apt-get update && \\\n  apt-get install --no-install-recommends -y \\\n  ca-certificates \\\n  automake build-essential curl \\\n  meson ninja-build pkg-config \\\n  gobject-introspection gtk-doc-tools libglib2.0-dev libjpeg62-turbo-dev libpng-dev \\\n  libwebp-dev libtiff-dev libexif-dev libxml2-dev libpoppler-glib-dev \\\n  swig libpango1.0-dev libmatio-dev libopenslide-dev libcfitsio-dev libopenjp2-7-dev liblcms2-dev \\\n  libgsf-1-dev libfftw3-dev liborc-0.4-dev librsvg2-dev libimagequant-dev libaom-dev \\\n  libheif-dev libspng-dev libcgif-dev && \\\n  cd /tmp && \\\n    curl -fsSLO https://github.com/libvips/libvips/releases/download/v${VIPS_VERSION}/vips-${VIPS_VERSION}.tar.xz && \\\n    tar xf vips-${VIPS_VERSION}.tar.xz && \\\n    cd vips-${VIPS_VERSION} && \\\n    meson setup _build \\\n    --buildtype=release \\\n    --strip \\\n    --prefix=/usr/local \\\n    --libdir=lib \\\n    -Dgtk_doc=false \\\n    -Dmagick=disabled \\\n    -Dintrospection=disabled && \\\n    ninja -C _build && \\\n    ninja -C _build install && \\\n  ldconfig && \\\n  rm -rf /usr/local/lib/libvips-cpp.* && \\\n  rm -rf /usr/local/lib/*.a && \\\n  rm -rf /usr/local/lib/*.la\n\nWORKDIR ${GOPATH}/src/github.com/cshum/imagor\n\nCOPY go.mod .\nCOPY go.sum .\n\nRUN go mod download\n\nCOPY . .\n\nRUN if [ \"$TARGETARCH\" = \"amd64\" ]; then go test ./...; fi\nRUN go build -o ${GOPATH}/bin/imagor ./cmd/imagor/main.go\n\nFROM debian:bookworm-slim\nLABEL maintainer=\"adrian@cshum.com\"\n\nCOPY --from=builder /usr/local/lib /usr/local/lib\nCOPY --from=builder /etc/ssl/certs /etc/ssl/certs\n\n# Install runtime dependencies\nRUN DEBIAN_FRONTEND=noninteractive \\\n  apt-get update && \\\n  apt-get install --no-install-recommends -y \\\n  procps libglib2.0-0 libjpeg62-turbo libpng16-16 libopenexr-3-1-30 \\\n  libwebp7 libwebpmux3 libwebpdemux2 libtiff6 libexif12 libxml2 libpoppler-glib8 \\\n  libpango1.0-0 libmatio11 libopenslide0 libopenjp2-7 libjemalloc2 \\\n  libgsf-1-114 libfftw3-bin liborc-0.4-0 librsvg2-2 libcfitsio10 libimagequant0 libaom3 libheif1 \\\n  libspng0 libcgif0 && \\\n  ln -s /usr/lib/$(uname -m)-linux-gnu/libjemalloc.so.2 /usr/local/lib/libjemalloc.so && \\\n  apt-get autoremove -y && \\\n  apt-get autoclean && \\\n  apt-get clean && \\\n  rm -rf /var/lib/apt/lists/* /tmp/* /var/tmp/*\n\nCOPY --from=builder /go/bin/imagor /usr/local/bin/imagor\n\nENV VIPS_WARNING=0\nENV MALLOC_ARENA_MAX=2\nENV LD_PRELOAD=/usr/local/lib/libjemalloc.so\n\nENV PORT 8000\n\n# use unprivileged user\nUSER nobody\n\nENTRYPOINT [\"/usr/local/bin/imagor\"]\n\nEXPOSE ${PORT}\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 9.9345703125,
          "content": "                                 Apache License\n                           Version 2.0, January 2004\n                        http://www.apache.org/licenses/\n\n   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION\n\n   1. Definitions.\n\n      \"License\" shall mean the terms and conditions for use, reproduction,\n      and distribution as defined by Sections 1 through 9 of this document.\n\n      \"Licensor\" shall mean the copyright owner or entity authorized by\n      the copyright owner that is granting the License.\n\n      \"Legal Entity\" shall mean the union of the acting entity and all\n      other entities that control, are controlled by, or are under common\n      control with that entity. For the purposes of this definition,\n      \"control\" means (i) the power, direct or indirect, to cause the\n      direction or management of such entity, whether by contract or\n      otherwise, or (ii) ownership of fifty percent (50%) or more of the\n      outstanding shares, or (iii) beneficial ownership of such entity.\n\n      \"You\" (or \"Your\") shall mean an individual or Legal Entity\n      exercising permissions granted by this License.\n\n      \"Source\" form shall mean the preferred form for making modifications,\n      including but not limited to software source code, documentation\n      source, and configuration files.\n\n      \"Object\" form shall mean any form resulting from mechanical\n      transformation or translation of a Source form, including but\n      not limited to compiled object code, generated documentation,\n      and conversions to other media types.\n\n      \"Work\" shall mean the work of authorship, whether in Source or\n      Object form, made available under the License, as indicated by a\n      copyright notice that is included in or attached to the work\n      (an example is provided in the Appendix below).\n\n      \"Derivative Works\" shall mean any work, whether in Source or Object\n      form, that is based on (or derived from) the Work and for which the\n      editorial revisions, annotations, elaborations, or other modifications\n      represent, as a whole, an original work of authorship. For the purposes\n      of this License, Derivative Works shall not include works that remain\n      separable from, or merely link (or bind by name) to the interfaces of,\n      the Work and Derivative Works thereof.\n\n      \"Contribution\" shall mean any work of authorship, including\n      the original version of the Work and any modifications or additions\n      to that Work or Derivative Works thereof, that is intentionally\n      submitted to Licensor for inclusion in the Work by the copyright owner\n      or by an individual or Legal Entity authorized to submit on behalf of\n      the copyright owner. For the purposes of this definition, \"submitted\"\n      means any form of electronic, verbal, or written communication sent\n      to the Licensor or its representatives, including but not limited to\n      communication on electronic mailing lists, source code control systems,\n      and issue tracking systems that are managed by, or on behalf of, the\n      Licensor for the purpose of discussing and improving the Work, but\n      excluding communication that is conspicuously marked or otherwise\n      designated in writing by the copyright owner as \"Not a Contribution.\"\n\n      \"Contributor\" shall mean Licensor and any individual or Legal Entity\n      on behalf of whom a Contribution has been received by Licensor and\n      subsequently incorporated within the Work.\n\n   2. Grant of Copyright License. Subject to the terms and conditions of\n      this License, each Contributor hereby grants to You a perpetual,\n      worldwide, non-exclusive, no-charge, royalty-free, irrevocable\n      copyright license to reproduce, prepare Derivative Works of,\n      publicly display, publicly perform, sublicense, and distribute the\n      Work and such Derivative Works in Source or Object form.\n\n   3. Grant of Patent License. Subject to the terms and conditions of\n      this License, each Contributor hereby grants to You a perpetual,\n      worldwide, non-exclusive, no-charge, royalty-free, irrevocable\n      (except as stated in this section) patent license to make, have made,\n      use, offer to sell, sell, import, and otherwise transfer the Work,\n      where such license applies only to those patent claims licensable\n      by such Contributor that are necessarily infringed by their\n      Contribution(s) alone or by combination of their Contribution(s)\n      with the Work to which such Contribution(s) was submitted. If You\n      institute patent litigation against any entity (including a\n      cross-claim or counterclaim in a lawsuit) alleging that the Work\n      or a Contribution incorporated within the Work constitutes direct\n      or contributory patent infringement, then any patent licenses\n      granted to You under this License for that Work shall terminate\n      as of the date such litigation is filed.\n\n   4. Redistribution. You may reproduce and distribute copies of the\n      Work or Derivative Works thereof in any medium, with or without\n      modifications, and in Source or Object form, provided that You\n      meet the following conditions:\n\n      (a) You must give any other recipients of the Work or\n          Derivative Works a copy of this License; and\n\n      (b) You must cause any modified files to carry prominent notices\n          stating that You changed the files; and\n\n      (c) You must retain, in the Source form of any Derivative Works\n          that You distribute, all copyright, patent, trademark, and\n          attribution notices from the Source form of the Work,\n          excluding those notices that do not pertain to any part of\n          the Derivative Works; and\n\n      (d) If the Work includes a \"NOTICE\" text file as part of its\n          distribution, then any Derivative Works that You distribute must\n          include a readable copy of the attribution notices contained\n          within such NOTICE file, excluding those notices that do not\n          pertain to any part of the Derivative Works, in at least one\n          of the following places: within a NOTICE text file distributed\n          as part of the Derivative Works; within the Source form or\n          documentation, if provided along with the Derivative Works; or,\n          within a display generated by the Derivative Works, if and\n          wherever such third-party notices normally appear. The contents\n          of the NOTICE file are for informational purposes only and\n          do not modify the License. You may add Your own attribution\n          notices within Derivative Works that You distribute, alongside\n          or as an addendum to the NOTICE text from the Work, provided\n          that such additional attribution notices cannot be construed\n          as modifying the License.\n\n      You may add Your own copyright statement to Your modifications and\n      may provide additional or different license terms and conditions\n      for use, reproduction, or distribution of Your modifications, or\n      for any such Derivative Works as a whole, provided Your use,\n      reproduction, and distribution of the Work otherwise complies with\n      the conditions stated in this License.\n\n   5. Submission of Contributions. Unless You explicitly state otherwise,\n      any Contribution intentionally submitted for inclusion in the Work\n      by You to the Licensor shall be under the terms and conditions of\n      this License, without any additional terms or conditions.\n      Notwithstanding the above, nothing herein shall supersede or modify\n      the terms of any separate license agreement you may have executed\n      with Licensor regarding such Contributions.\n\n   6. Trademarks. This License does not grant permission to use the trade\n      names, trademarks, service marks, or product names of the Licensor,\n      except as required for reasonable and customary use in describing the\n      origin of the Work and reproducing the content of the NOTICE file.\n\n   7. Disclaimer of Warranty. Unless required by applicable law or\n      agreed to in writing, Licensor provides the Work (and each\n      Contributor provides its Contributions) on an \"AS IS\" BASIS,\n      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n      implied, including, without limitation, any warranties or conditions\n      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A\n      PARTICULAR PURPOSE. You are solely responsible for determining the\n      appropriateness of using or redistributing the Work and assume any\n      risks associated with Your exercise of permissions under this License.\n\n   8. Limitation of Liability. In no event and under no legal theory,\n      whether in tort (including negligence), contract, or otherwise,\n      unless required by applicable law (such as deliberate and grossly\n      negligent acts) or agreed to in writing, shall any Contributor be\n      liable to You for damages, including any direct, indirect, special,\n      incidental, or consequential damages of any character arising as a\n      result of this License or out of the use or inability to use the\n      Work (including but not limited to damages for loss of goodwill,\n      work stoppage, computer failure or malfunction, or any and all\n      other commercial damages or losses), even if such Contributor\n      has been advised of the possibility of such damages.\n\n   9. Accepting Warranty or Additional Liability. While redistributing\n      the Work or Derivative Works thereof, You may choose to offer,\n      and charge a fee for, acceptance of support, warranty, indemnity,\n      or other liability obligations and/or rights consistent with this\n      License. However, in accepting such obligations, You may act only\n      on Your own behalf and on Your sole responsibility, not on behalf\n      of any other Contributor, and only if You agree to indemnify,\n      defend, and hold each Contributor harmless for any liability\n      incurred by, or claims asserted against, such Contributor by reason\n      of your accepting any such warranty or additional liability.\n\n   END OF TERMS AND CONDITIONS\n"
        },
        {
          "name": "Makefile",
          "type": "blob",
          "size": 0.7900390625,
          "content": "build:\n\tCGO_CFLAGS_ALLOW=-Xpreprocessor go build -o bin/imagor ./cmd/imagor/main.go\n\ntest:\n\tgo clean -testcache && CGO_CFLAGS_ALLOW=-Xpreprocessor go test -coverprofile=profile.cov $(shell go list ./... | grep -v /examples/ | grep -v /cmd/)\n\ndev: build\n\t./bin/imagor -debug -imagor-unsafe\n\nhelp: build\n\t./bin/imagor -h\n\nget:\n\tgo get -v -t -d ./...\n\ndocker-dev-build:\n\tdocker build -t imagor:dev .\n\ndocker-dev-run:\n\ttouch .env\n\tdocker run --rm -p 8000:8000 --env-file .env imagor:dev -debug -imagor-unsafe\n\ndocker-dev: docker-dev-build docker-dev-run\n\n%-tag: VERSION:=$(if $(VERSION),$(VERSION),$$(./bin/imagor -version))\n\ngit-tag:\n\tgit tag \"v$(VERSION)\"\n\tgit push origin \"refs/tags/v$(VERSION)\"\n\nreset-golden:\n\tgit rm -rf testdata/golden\n\tgit commit -m  \"test: reset golden\"\n\tgit push\n\nrelease: build git-tag\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 37.5400390625,
          "content": "# imagor\n\n[![Test Status](https://github.com/cshum/imagor/workflows/test/badge.svg)](https://github.com/cshum/imagor/actions/workflows/test.yml)\n[![Coverage Status](https://coveralls.io/repos/github/cshum/imagor/badge.svg?branch=master)](https://coveralls.io/github/cshum/imagor?branch=master)\n[![Docker Hub](https://img.shields.io/badge/docker-shumc/imagor-blue.svg)](https://hub.docker.com/r/shumc/imagor/)\n[![GitHub Container Registry](https://ghcr-badge.egpl.dev/cshum/imagor/latest_tag?trim=major&label=ghcr.io&ignore=master,develop&color=%23007ec6)](https://github.com/cshum/imagor/pkgs/container/imagor)\n[![Go Reference](https://pkg.go.dev/badge/github.com/cshum/imagor.svg)](https://pkg.go.dev/github.com/cshum/imagor)\n\nimagor is a fast, secure image processing server and Go library.\n\nimagor uses one of the most efficient image processing library\n[libvips](https://www.libvips.org/). It is typically 4-8x [faster](https://github.com/libvips/libvips/wiki/Speed-and-memory-use) than using the quickest ImageMagick and GraphicsMagick settings.\nimagor implements libvips [streaming](https://www.libvips.org/2019/11/29/True-streaming-for-libvips.html) that facilitates parallel processing pipelines, achieving high network throughput.\n\nimagor features a ton of image processing use cases, available as a HTTP server with first-class Docker support. It adopts the [thumbor](https://thumbor.readthedocs.io/en/latest/usage.html#image-endpoint) URL syntax representing a high-performance drop-in replacement.\n\nimagor is a Go library built with speed, security and extensibility in mind. Alongside there is [imagorvideo](https://github.com/cshum/imagorvideo) bringing video thumbnail capability through ffmpeg C bindings.\n\n### Quick Start\n\n```bash\ndocker run -p 8000:8000 shumc/imagor -imagor-unsafe -imagor-auto-webp\n```\n\nOriginal images:\n\n```\nhttps://raw.githubusercontent.com/cshum/imagor/master/testdata/gopher.png\nhttps://raw.githubusercontent.com/cshum/imagor/master/testdata/dancing-banana.gif\nhttps://raw.githubusercontent.com/cshum/imagor/master/testdata/gopher-front.png\n```\n\n<img src=\"https://raw.githubusercontent.com/cshum/imagor/master/testdata/gopher.png\" height=\"100\" /> <img src=\"https://raw.githubusercontent.com/cshum/imagor/master/testdata/dancing-banana.gif\" height=\"100\" /> <img src=\"https://raw.githubusercontent.com/cshum/imagor/master/testdata/gopher-front.png\" height=\"100\" />\n\nTry out the following image URLs:\n\n```\nhttp://localhost:8000/unsafe/fit-in/200x200/filters:fill(white)/https://raw.githubusercontent.com/cshum/imagor/master/testdata/gopher.png\nhttp://localhost:8000/unsafe/200x200/smart/filters:fill(white):format(jpeg):quality(80)/https://raw.githubusercontent.com/cshum/imagor/master/testdata/gopher.png\nhttp://localhost:8000/unsafe/fit-in/-180x180/10x10/filters:hue(290):saturation(100):fill(yellow)/raw.githubusercontent.com/cshum/imagor/master/testdata/gopher.png\nhttp://localhost:8000/unsafe/30x40:100x150/filters:fill(cyan)/raw.githubusercontent.com/cshum/imagor/master/testdata/dancing-banana.gif\nhttp://localhost:8000/unsafe/fit-in/200x150/filters:fill(yellow):watermark(raw.githubusercontent.com/cshum/imagor/master/testdata/gopher-front.png,repeat,bottom,0,40,40)/raw.githubusercontent.com/cshum/imagor/master/testdata/dancing-banana.gif\n```\n\n<img src=\"https://raw.githubusercontent.com/cshum/imagor/master/testdata/demo1.jpg\" height=\"100\" /> <img src=\"https://raw.githubusercontent.com/cshum/imagor/master/testdata/demo2.jpg\" height=\"100\" /> <img src=\"https://raw.githubusercontent.com/cshum/imagor/master/testdata/demo4.jpg\" height=\"100\" /> <img src=\"https://raw.githubusercontent.com/cshum/imagor/master/testdata/demo3.gif\" height=\"100\" /> <img src=\"https://raw.githubusercontent.com/cshum/imagor/master/testdata/demo5.gif\" height=\"100\" />  \n\n### Image Endpoint\n\nimagor endpoint is a series of URL parts which defines the image operations, followed by the image URI:\n\n```\n/HASH|unsafe/trim/AxB:CxD/fit-in/stretch/-Ex-F/GxH:IxJ/HALIGN/VALIGN/smart/filters:NAME(ARGS):NAME(ARGS):.../IMAGE\n```\n\n- `HASH` is the URL signature hash, or `unsafe` if unsafe mode is used\n- `trim` removes surrounding space in images using top-left pixel color\n- `AxB:CxD` means manually crop the image at left-top point `AxB` and right-bottom point `CxD`. Coordinates can also be provided as float values between 0 and 1 (percentage of image dimensions)\n- `fit-in` means that the generated image should not be auto-cropped and otherwise just fit in an imaginary box specified by `ExF`\n- `stretch` means resize the image to `ExF` without keeping its aspect ratios\n- `-Ex-F` means resize the image to be `ExF` of width per height size. The minus signs mean flip horizontally and vertically\n- `GxH:IxJ` add left-top padding `GxH` and right-bottom padding `IxJ`\n- `HALIGN` is horizontal alignment of crop. Accepts `left`, `right` or `center`, defaults to `center`\n- `VALIGN` is vertical alignment of crop. Accepts `top`, `bottom` or `middle`, defaults to `middle`\n- `smart` means using smart detection of focal points\n- `filters` a pipeline of image filter operations to be applied, see filters section\n- `IMAGE` is the image path or URI\n  - For image URI that contains `?` character, this will interfere the URL query and should be encoded with [`encodeURIComponent`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/encodeURIComponent) or equivalent\n\n### Filters\n\nFilters `/filters:NAME(ARGS):NAME(ARGS):.../` is a pipeline of image operations that will be sequentially applied to the image. Examples:\n\n```\n/filters:fill(white):format(jpeg)/\n/filters:hue(290):saturation(100):fill(yellow):format(jpeg):quality(80)/\n/filters:fill(white):watermark(raw.githubusercontent.com/cshum/imagor/master/testdata/gopher-front.png,repeat,bottom,10):format(jpeg)/\n```\n\nimagor supports the following filters:\n\n- `background_color(color)` sets the background color of a transparent image\n  - `color` the color name or hexadecimal rgb expression without the “#” character\n- `blur(sigma)` applies gaussian blur to the image\n- `brightness(amount)` increases or decreases the image brightness\n  - `amount` -100 to 100, the amount in % to increase or decrease the image brightness\n- `contrast(amount)` increases or decreases the image contrast\n  - `amount` -100 to 100, the amount in % to increase or decrease the image contrast\n- `fill(color)` fill the missing area or transparent image with the specified color:\n  - `color` - color name or hexadecimal rgb expression without the “#” character\n    - If color is \"blur\" - missing parts are filled with blurred original image\n    - If color is \"auto\" - the top left image pixel will be chosen as the filling color\n    - If color is \"none\" - the filling would become fully transparent\n- `focal(AxB:CxD)` or `focal(X,Y)` adds a focal region or focal point for custom transformations:\n  - Coordinated by a region of left-top point `AxB` and right-bottom point `CxD`, or a point `X,Y`.\n  - Also accepts float values between 0 and 1 that represents percentage of image dimensions.\n- `format(format)` specifies the output format of the image\n  - `format` accepts jpeg, png, gif, webp, tiff, avif, jp2\n- `grayscale()` changes the image to grayscale\n- `hue(angle)` increases or decreases the image hue\n  - `angle` the angle in degree to increase or decrease the hue rotation\n- `label(text, x, y, size, color[, alpha[, font]])` adds a text label to the image. It can be positioned inside the image with the alignment specified, color and transparency support:\n  - `text` text label, also support url encoded text.\n  - `x` horizontal position that the text label will be in:\n    - Positive number indicate position from the left, negative number from the right.\n    - Number followed by a `p` e.g. 20p means calculating the value from the image width as percentage\n    - `left`,`right`,`center` align left, right or centered respectively\n  - `y` vertical position that the text label will be in:\n    - Positive number indicate position from the top, negative number from the bottom.\n    - Number followed by a `p` e.g. 20p means calculating the value from the image height as percentage\n    - `top`,`bottom`,`center` vertical align top, bottom or centered respectively\n  - `size` - text label font size\n  - `color` - color name or hexadecimal rgb expression without the “#” character\n  - `alpha` - text label transparency, a number between 0 (fully opaque) and 100 (fully transparent).\n  - `font` - text label font type\n- `max_bytes(amount)` automatically degrades the quality of the image until the image is under the specified `amount` of bytes\n- `max_frames(n)` limit maximum number of animation frames `n` to be loaded\n- `orient(angle)` rotates the image before resizing and cropping, according to the angle value\n  - `angle` accepts 0, 90, 180, 270\n- `page(num)` specify page number for PDF, or frame number for animated image, starts from 1\n- `dpi(num)` specify the dpi to render at for PDF and SVG\n- `proportion(percentage)` scales image to the proportion percentage of the image dimension\n- `quality(amount)` changes the overall quality of the image, does nothing for png\n  - `amount` 0 to 100, the quality level in %\n- `rgb(r,g,b)` amount of color in each of the rgb channels in %. Can range from -100 to 100\n- `rotate(angle)` rotates the given image according to the angle value\n  - `angle` accepts 0, 90, 180, 270\n- `round_corner(rx [, ry [, color]])` adds rounded corners to the image with the specified color as background\n  - `rx`, `ry` amount of pixel to use as radius. ry = rx if ry is not provided\n  - `color` the color name or hexadecimal rgb expression without the “#” character\n- `saturation(amount)` increases or decreases the image saturation\n  - `amount` -100 to 100, the amount in % to increase or decrease the image saturation\n- `sharpen(sigma)` sharpens the image\n- `strip_exif()` removes Exif metadata from the resulting image\n- `strip_icc()` removes ICC profile information from the resulting image\n- `strip_metadata()` removes all metadata from the resulting image\n- `upscale()` upscale the image if `fit-in` is used\n- `watermark(image, x, y, alpha [, w_ratio [, h_ratio]])` adds a watermark to the image. It can be positioned inside the image with the alpha channel specified and optionally resized based on the image size by specifying the ratio\n  - `image` watermark image URI, using the same image loader configured for imagor\n  - `x` horizontal position that the watermark will be in:\n    - Positive number indicate position from the left, negative number from the right.\n    - Number followed by a `p` e.g. 20p means calculating the value from the image width as percentage\n    - `left`,`right`,`center` positioned left, right or centered respectively\n    - `repeat` the watermark will be repeated horizontally\n  - `y` vertical position that the watermark will be in:\n    - Positive number indicate position from the top, negative number from the bottom.\n    - Number followed by a `p` e.g. 20p means calculating the value from the image height as percentage\n    - `top`,`bottom`,`center` positioned top, bottom or centered respectively\n    - `repeat` the watermark will be repeated vertically\n  - `alpha` watermark image transparency, a number between 0 (fully opaque) and 100 (fully transparent).\n  - `w_ratio` percentage of the width of the image the watermark should fit-in\n  - `h_ratio` percentage of the height of the image the watermark should fit-in\n\n#### Utility Filters\n\nThese filters do not manipulate images but provide useful utilities to the imagor pipeline:\n\n- `attachment(filename)` returns attachment in the `Content-Disposition` header, and the browser will open a \"Save as\" dialog with `filename`. When `filename` not specified, imagor will get the filename from the image source\n- `expire(timestamp)` adds expiration time to the content. `timestamp` is the unix milliseconds timestamp, e.g. if content is valid for 30s then timestamp would be `Date.now() + 30*1000` in JavaScript.\n- `preview()` skips the result storage even if result storage is enabled. Useful for conditional caching\n- `raw()` response with a raw unprocessed and unchecked source image. Image still loads from loader and storage but skips the result storage\n\n\n### Loader, Storage and Result Storage\n\nimagor `Loader`, `Storage` and `Result Storage` are the building blocks for loading and saving images from various sources:\n\n- `Loader` loads image. Enable `Loader` where you wish to load images from, but without modifying it e.g. static directory.\n- `Storage` loads and saves image. This allows subsequent requests for the same image loads directly from the storage, instead of HTTP source.\n- `Result Storage` loads and saves the processed image. This allows subsequent request of the same parameters loads from the result storage, saving processing resources.\n\nimagor provides built-in adaptors that support HTTP(s), Proxy, File System, AWS S3 and Google Cloud Storage. By default, `HTTP Loader` is used as fallback. You can choose to enable additional adaptors that fit your use cases.\n\n#### File System\n\nDocker Compose example with file system, using mounted volume:\n\n```yaml\nversion: \"3\"\nservices:\n  imagor:\n    image: shumc/imagor:latest\n    volumes:\n      - ./:/mnt/data\n    environment:\n      PORT: 8000\n      IMAGOR_UNSAFE: 1 # unsafe URL for testing\n\n      FILE_LOADER_BASE_DIR: /mnt/data # enable file loader by specifying base dir\n\n      FILE_STORAGE_BASE_DIR: /mnt/data # enable file storage by specifying base dir\n      FILE_STORAGE_MKDIR_PERMISSION: 0755 # optional\n      FILE_STORAGE_WRITE_PERMISSION: 0666 # optional\n\n      FILE_RESULT_STORAGE_BASE_DIR: /mnt/data/result # enable file result storage by specifying base dir\n      FILE_RESULT_STORAGE_MKDIR_PERMISSION: 0755 # optional\n      FILE_RESULT_STORAGE_WRITE_PERMISSION: 0666 # optional\n      \n    ports:\n      - \"8000:8000\"\n```\n\n#### AWS S3\n\nDocker Compose example with AWS S3. Also works with S3 compatible such as MinIO, DigitalOcean Space.\n\n```yaml\nversion: \"3\"\nservices:\n  imagor:\n    image: shumc/imagor:latest\n    environment:\n      PORT: 8000\n      IMAGOR_SECRET: mysecret # secret key for URL signature\n      AWS_ACCESS_KEY_ID: ...\n      AWS_SECRET_ACCESS_KEY: ...\n      AWS_REGION: ...\n\n      S3_LOADER_BUCKET: mybucket # enable S3 loader by specifying bucket\n      S3_LOADER_BASE_DIR: images # optional\n\n      S3_STORAGE_BUCKET: mybucket # enable S3 storage by specifying bucket\n      S3_STORAGE_BASE_DIR: images # optional\n      S3_STORAGE_ACL: public-read # optional - see https://docs.aws.amazon.com/AmazonS3/latest/userguide/acl-overview.html#canned-acl\n\n      S3_RESULT_STORAGE_BUCKET: mybucket # enable S3 result storage by specifying bucket\n      S3_RESULT_STORAGE_BASE_DIR: images/result # optional\n      S3_RESULT_STORAGE_ACL: public-read # optional\n    ports:\n      - \"8000:8000\"\n```\n\n##### Custom S3 Endpoint\n\nConfigure custom S3 endpoint for S3 compatible such as MinIO, DigitalOcean Space:\n\n```yaml\n      S3_ENDPOINT: http://minio:9000\n      S3_FORCE_PATH_STYLE: 1\n```\n\nBy default, S3 prepends bucket name as subdomain to the request URL:\n\n```\nhttp://mybucket.minio:9000/image.jpg\n```\n\nthis may not be desirable for a self-hosted endpoint. You can also switch to [path-style requests](https://docs.aws.amazon.com/AmazonS3/latest/userguide/VirtualHosting.html#path-style-access) using `S3_FORCE_PATH_STYLE=1` such that the host remains unchanged:\n\n```\nhttp://minio:9000/mybucket/image.jpg\n```\n\n##### Different AWS Credentials for S3 Loader, Storage and Result Storage\n\nSet the following environment variables to override the global AWS Credentials for S3 Loader, Storage and Result Storage:\n\n```dotenv\nAWS_LOADER_REGION\nAWS_LOADER_ACCESS_KEY_ID\nAWS_LOADER_SECRET_ACCESS_KEY\nS3_LOADER_ENDPOINT\n\nAWS_STORAGE_REGION\nAWS_STORAGE_ACCESS_KEY_ID\nAWS_STORAGE_SECRET_ACCESS_KEY\nS3_STORAGE_ENDPOINT\n\nAWS_RESULT_STORAGE_REGION\nAWS_RESULT_STORAGE_ACCESS_KEY_ID\nAWS_RESULT_STORAGE_SECRET_ACCESS_KEY\nS3_RESULT_STORAGE_ENDPOINT\n```\n\n#### Google Cloud Storage\n\nDocker Compose example with Google Cloud Storage:\n\n```yaml\nversion: \"3\"\nservices:\n  imagor:\n    image: shumc/imagor:latest\n    volumes:\n      - ./googlesecret:/etc/secrets/google\n    environment:\n      PORT: 8000\n      IMAGOR_SECRET: mysecret # secret key for URL signature\n      GOOGLE_APPLICATION_CREDENTIALS: /etc/secrets/google/appcredentials.json # google cloud secrets file\n\n      GCLOUD_LOADER_BUCKET: mybucket # enable loader by specifying bucket\n      GCLOUD_LOADER_BASE_DIR: images # optional\n\n      GCLOUD_STORAGE_BUCKET: mybucket # enable storage by specifying bucket\n      GCLOUD_STORAGE_BASE_DIR: images # optional\n      GCLOUD_STORAGE_ACL: publicRead # optional - see https://cloud.google.com/storage/docs/json_api/v1/objects/insert\n\n      GCLOUD_RESULT_STORAGE_BUCKET: mybucket # enable result storage by specifying bucket\n      GCLOUD_RESULT_STORAGE_BASE_DIR: images/result # optional\n      GCLOUD_RESULT_STORAGE_ACL: publicRead # optional\n    ports:\n      - \"8000:8000\"\n```\n\n#### Storage and Result Storage Path Style\n\n`Storage` and `Result Storage` path style enables additional hashing rules to the storage path when loading and saving images:\n\n`IMAGOR_STORAGE_PATH_STYLE=digest`\n\n* `foobar.jpg` becomes `e6/86/1a810ff186b4f747ef85f7c53946f0e6d8cb`\n\n`IMAGOR_RESULT_STORAGE_PATH_STYLE=digest`\n\n* `fit-in/16x17/foobar.jpg` becomes `61/4c/9ba1725e8cdd8263a4ad437c56b35f33deba`\n\n`IMAGOR_RESULT_STORAGE_PATH_STYLE=suffix`\n\n* `166x169/top/foobar.jpg` becomes `foobar.45d8ebb31bd4ed80c26e.jpg`\n* `17x19/smart/example.com/foobar` becomes `example.com/foobar.ddd349e092cda6d9c729`\n\n`IMAGOR_RESULT_STORAGE_PATH_STYLE=size`\n\n* `166x169/top/foobar.jpg` becomes `foobar.45d8ebb31bd4ed80c26e_166x169.jpg`\n* `17x19/smart/example.com/foobar` becomes `example.com/foobar.ddd349e092cda6d9c729_17x19`\n\n### Security\n\n#### URL Signature\n\nIn production environment, it is highly recommended turning off `IMAGOR_UNSAFE` and setting up URL signature using `IMAGOR_SECRET`, to prevent DDoS attacks that abuse multiple image operations.\n\nThe URL signature hash is based on SHA digest, created by taking the URL path (excluding `/unsafe/`) with secret. The hash is then Base64 URL encoded.\nAn example in Node.js:\n\n```javascript\nconst crypto = require('crypto');\n\nfunction sign(path, secret) {\n  const hash = crypto.createHmac('sha1', secret)\n          .update(path)\n          .digest('base64')\n          .replace(/\\+/g, '-').replace(/\\//g, '_')\n  return hash + '/' + path\n}\n\nconsole.log(sign('500x500/top/raw.githubusercontent.com/cshum/imagor/master/testdata/gopher.png', 'mysecret'))\n// cST4Ko5_FqwT3BDn-Wf4gO3RFSk=/500x500/top/raw.githubusercontent.com/cshum/imagor/master/testdata/gopher.png\n```\n\n#### Custom HMAC Signer\n\nimagor uses SHA1 HMAC signer by default, the same one used by [thumbor](https://thumbor.readthedocs.io/en/latest/security.html#hmac-method). However, SHA1 is not considered cryptographically secure. If that is a concern it is possible to configure different signing method and truncate length. imagor supports `sha1`, `sha256`, `sha512` signer type:\n\n```dotenv\nIMAGOR_SIGNER_TYPE=sha256\nIMAGOR_SIGNER_TRUNCATE=40\n```\n\nThe Node.js example then becomes:\n\n```javascript\nconst crypto = require('crypto');\n\nfunction sign(path, secret) {\n  const hash = crypto.createHmac('sha256', secret)\n          .update(path)\n          .digest('base64')\n          .slice(0, 40)\n          .replace(/\\+/g, '-').replace(/\\//g, '_')\n  return hash + '/' + path\n}\n\nconsole.log(sign('500x500/top/raw.githubusercontent.com/cshum/imagor/master/testdata/gopher.png', 'mysecret'))\n// IGEn3TxngivD0jy4uuiZim2bdUCvhcnVi1Nm0xGy/500x500/top/raw.githubusercontent.com/cshum/imagor/master/testdata/gopher.png\n```\n\n#### Image Bombs Prevention\n\nimagor checks the image type and its resolution before the actual processing happens. The processing will be rejected if the image dimensions are too big, which protects from so-called \"image bombs\". You can set the max allowed image resolution and dimensions using `VIPS_MAX_RESOLUTION`, `VIPS_MAX_WIDTH`, `VIPS_MAX_HEIGHT`:\n\n```dotenv\nVIPS_MAX_RESOLUTION=16800000\nVIPS_MAX_WIDTH=5000\nVIPS_MAX_HEIGHT=5000\n```\n\n#### Allowed Sources and Base URL\n\nWhitelist specific hosts to restrict loading images only from the allowed sources using `HTTP_LOADER_ALLOWED_SOURCES` or `HTTP_LOADER_ALLOWED_SOURCE_REGEXP`.\n\n- `HTTP_LOADER_ALLOWED_SOURCES` accepts csv wth glob pattern e.g.:\n\n  ```dotenv\n  HTTP_LOADER_ALLOWED_SOURCES=*.foobar.com,my.foobar.com,mybucket.s3.amazonaws.com\n  ```\n\n- `HTTP_LOADER_ALLOWED_SOURCE_REGEXP` accepts a regular expression matching on the full URL e.g.:\n\n  ```dotenv\n  HTTP_LOADER_ALLOWED_SOURCE_REGEXP='^https://raw\\.githubusercontent\\.com/cshum/imagor/.*'\n  ```\n\nAlternatively, it is possible to set a base URL for loading images strictly from one HTTP source. This also trims down the base URL from image endpoint:\n\nExample URL:\n```\nhttp://localhost:8000/unsafe/fit-in/200x150/filters:fill(yellow):watermark(raw.githubusercontent.com/cshum/imagor/master/testdata/gopher-front.png,repeat,bottom,0,40,40)/raw.githubusercontent.com/cshum/imagor/master/testdata/dancing-banana.gif\n```\n\nWith HTTP Loader Base URL config:\n```\nHTTP_LOADER_BASE_URL=https://raw.githubusercontent.com/cshum/imagor/master\n```\n\nThe example URL then becomes:\n```\nhttp://localhost:8000/unsafe/fit-in/200x150/filters:fill(yellow):watermark(testdata/gopher-front.png,repeat,bottom,0,40,40)/testdata/dancing-banana.gif\n```\n\n\n### Metadata and Exif\n\nimagor provides metadata endpoint that extracts information such as image format, resolution and Exif metadata.\nUnder the hood, it tries to retrieve data just enough to extract the header, without reading and processing the whole image in memory.\n\nTo use the metadata endpoint, add `/meta` right after the URL signature hash before the image operations. Example:\n\n```\nhttp://localhost:8000/unsafe/meta/fit-in/50x50/raw.githubusercontent.com/cshum/imagor/master/testdata/Canon_40D.jpg\n```\n\n```jsonc\n{\n  \"format\": \"jpeg\",\n  \"content_type\": \"image/jpeg\",\n  \"width\": 50,\n  \"height\": 34,\n  \"orientation\": 1,\n  \"pages\": 1,\n  \"bands\": 3,\n  \"exif\": {\n    \"ApertureValue\": \"368640/65536\",\n    \"ColorSpace\": 1,\n    \"ComponentsConfiguration\": \"Y Cb Cr -\",\n    \"Compression\": 6,\n    \"DateTime\": \"2008:07:31 10:38:11\",\n    \"ISOSpeedRatings\": 100,\n    \"Make\": \"Canon\",\n    \"MeteringMode\": 5,\n    \"Model\": \"Canon EOS 40D\",\n    //...\n  }\n}\n```\n\nPrepending `/params` to the existing endpoint returns the endpoint attributes in JSON form, useful for previewing the endpoint parameters. Example:\n```bash\ncurl 'http://localhost:8000/params/g5bMqZvxaQK65qFPaP1qlJOTuLM=/fit-in/500x400/0x20/filters:fill(white)/raw.githubusercontent.com/cshum/imagor/master/testdata/gopher.png'\n```\n\n### Go Library\n\nimagor is a Go library built with speed, security and extensibility in mind.\nIt facilitates high-level image processing in a modular architecture made up of a series of Go packages:\n\n- [imagor](https://pkg.go.dev/github.com/cshum/imagor) - the imagor core library\n- [imagorpath](https://pkg.go.dev/github.com/cshum/imagor/imagorpath) - parse and generate imagor endpoint\n- [vips](https://pkg.go.dev/github.com/cshum/imagor/vips) - libvips C bindings with `imagor.Processor` implementation\n- [httploader](https://pkg.go.dev/github.com/cshum/imagor/loader/httploader) - HTTP Loader, an `imagor.Loader` implementation\n- [filestorage](https://pkg.go.dev/github.com/cshum/imagor/storage/filestorage) - File Storage, an `imagor.Storage` implementation\n- [s3storage](https://pkg.go.dev/github.com/cshum/imagor/storage/s3storage) - AWS S3 Storage, an `imagor.Storage` implementation\n- [gcloudstorage](https://pkg.go.dev/github.com/cshum/imagor/storage/gcloudstorage) - Google Cloud Storage, an `imagor.Storage` implementation\n\nInstall [libvips](https://www.libvips.org/) and enable CGO:\n- `brew install vips` for Mac\n- `CGO_CFLAGS_ALLOW=-Xpreprocessor` being set to compile Go\n\nSee example below and also [examples](https://github.com/cshum/imagor/tree/master/examples) folder for various ways you can use imagor:\n\n```go\npackage main\n\nimport (\n\t\"context\"\n\t\"github.com/cshum/imagor\"\n\t\"github.com/cshum/imagor/imagorpath\"\n\t\"github.com/cshum/imagor/loader/httploader\"\n\t\"github.com/cshum/imagor/vips\"\n\t\"io\"\n\t\"os\"\n)\n\nfunc main() {\n\tapp := imagor.New(\n\t\timagor.WithLoaders(httploader.New()),\n\t\timagor.WithProcessors(vips.NewProcessor()),\n\t)\n\tctx := context.Background()\n\tif err := app.Startup(ctx); err != nil {\n\t\tpanic(err)\n\t}\n\tdefer app.Shutdown(ctx)\n\tblob, err := app.Serve(ctx, imagorpath.Params{\n\t\tImage:  \"https://raw.githubusercontent.com/cshum/imagor/master/testdata/gopher.png\",\n\t\tWidth:  500,\n\t\tHeight: 500,\n\t\tSmart:  true,\n\t\tFilters: []imagorpath.Filter{\n\t\t\t{\"fill\", \"white\"},\n\t\t\t{\"format\", \"jpg\"},\n\t\t},\n\t})\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\treader, _, err := blob.NewReader()\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tdefer reader.Close()\n\tfile, err := os.Create(\"gopher.jpg\")\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tdefer file.Close()\n\tif _, err := io.Copy(file, reader); err != nil {\n\t\tpanic(err)\n\t}\n}\n```\n\n### Configuration\n\nimagor supports command-line arguments and environment variables for the arguments equivalent in capitalized snake case, see available options `imagor -h`.\nFor instances `-imagor-secret` would become `IMAGOR_SECRET`:\n\n```bash\n# both are equivalent\n\nimagor -debug -imagor-secret 1234\n\nDEBUG=1 IMAGOR_SECRET=1234 imagor\n```\n\nConfiguration can also be specified in a `.env` environment variable file and referenced with the `-config` flag:\n\n```bash\nimagor -config path/to/config.env\n```\n\nconfig.env:\n\n```dotenv\nPORT=8000\nIMAGOR_SECRET=mysecret\nDEBUG=1\n```\n\n#### Available options\n\n```\nimagor -h\nUsage of imagor:\n  -debug\n        Debug mode\n  -port int\n        Server port (default 8000)\n  -version\n        imagor version\n  -config string\n        Retrieve configuration from the given file (default \".env\")\n\n  -imagor-secret string\n        Secret key for signing imagor URL\n  -imagor-unsafe\n        Unsafe imagor that does not require URL signature. Prone to URL tampering\n  -imagor-auto-webp\n        Output WebP format automatically if browser supports\n  -imagor-auto-avif\n        Output AVIF format automatically if browser supports (experimental)\n  -imagor-base-params string\n        imagor endpoint base params that applies to all resulting images e.g. filters:watermark(example.jpg)\n  -imagor-signer-type string\n        imagor URL signature hasher type: sha1, sha256, sha512 (default \"sha1\")\n  -imagor-signer-truncate int\n        imagor URL signature truncate at length\n  -imagor-result-storage-path-style string\n        imagor result storage path style: original, digest, suffix (default \"original\")\n  -imagor-storage-path-style string\n        imagor storage path style: original, digest (default \"original\")\n  -imagor-cache-header-ttl duration\n        imagor HTTP cache header ttl for successful image response (default 168h0m0s)\n  -imagor-cache-header-swr duration\n        imagor HTTP Cache-Control header stale-while-revalidate for successful image response (default 24h0m0s)\n  -imagor-cache-header-no-cache\n        imagor HTTP Cache-Control header no-cache for successful image response\n  -imagor-request-timeout duration\n        Timeout for performing imagor request (default 30s)\n  -imagor-load-timeout duration\n        Timeout for imagor Loader request, should be smaller than imagor-request-timeout\n  -imagor-save-timeout duration\n        Timeout for saving image to imagor Storage\n  -imagor-process-timeout duration\n        Timeout for image processing\n  -imagor-process-concurrency int\n        Maximum number of image process to be executed simultaneously. Requests that exceed this limit are put in the queue. Set -1 for no limit (default -1)\n  -imagor-process-queue-size int\n        Maximum number of image process that can be put in the queue. Requests that exceed this limit are rejected with HTTP status 429\n  -imagor-base-path-redirect string\n        URL to redirect for imagor / base path e.g. https://www.google.com\n  -imagor-modified-time-check\n        Check modified time of result image against the source image. This eliminates stale result but require more lookups\n  -imagor-disable-params-endpoint\n        imagor disable /params endpoint\n  -imagor-disable-error-body\n        imagor disable response body on error\n\n  -server-address string\n        Server address\n  -server-cors\n        Enable CORS\n  -server-strip-query-string\n        Enable strip query string redirection\n  -server-path-prefix string\n        Server path prefix\n  -server-access-log\n        Enable server access log\n\n  -prometheus-bind string\n        Specify address and port to enable Prometheus metrics, e.g. :5000, prom:7000\n  -prometheus-path string\n        Prometheus metrics path (default \"/\")\n        \n  -http-loader-allowed-sources string\n        HTTP Loader allowed hosts whitelist to load images from if set. Accept csv wth glob pattern e.g. *.google.com,*.github.com.\n  -http-loader-base-url string\n        HTTP Loader base URL that prepends onto existing image path. This overrides the default scheme option.\n  -http-loader-forward-headers string\n        Forward request header to HTTP Loader request by csv e.g. User-Agent,Accept\n  -http-loader-override-response-headers string\n        Override HTTP Loader response header to image response by csv e.g. Cache-Control,Expires\n  -http-loader-forward-client-headers\n        Forward browser client request headers to HTTP Loader request\n  -http-loader-insecure-skip-verify-transport\n        HTTP Loader to use HTTP transport with InsecureSkipVerify true\n  -http-loader-max-allowed-size int\n        HTTP Loader maximum allowed size in bytes for loading images if set\n  -http-loader-proxy-urls string\n        HTTP Loader Proxy URLs. Enable HTTP Loader proxy only if this value present. Accept csv of proxy urls e.g. http://user:pass@host:port,http://user:pass@host:port\n  -http-loader-allowed-source-regexp string\n        HTTP Loader allowed hosts regexp to load images from if set. Combines as OR with allowed host glob pattern sources.\n  -http-loader-proxy-allowed-sources string\n        HTTP Loader Proxy allowed hosts that enable proxy transport, if proxy URLs are set. Accept csv wth glob pattern e.g. *.google.com,*.github.com.\n  -http-loader-default-scheme string\n        HTTP Loader default scheme if not specified by image path. Set \"nil\" to disable default scheme. (default \"https\")\n  -http-loader-accept string\n        HTTP Loader set request Accept header and validate response Content-Type header (default \"*/*\") \n  -http-loader-block-link-local-networks\n        HTTP Loader rejects connections to link local network IP addresses.\n  -http-loader-block-loopback-networks\n        HTTP Loader rejects connections to loopback network IP addresses.\n  -http-loader-block-private-networks\n        HTTP Loader rejects connections to private network IP addresses.\n  -http-loader-block-networks string\n        HTTP Loader rejects connections to link local network IP addresses. This options takes a comma separated list of networks in CIDR notation e.g ::1/128,127.0.0.0/8.\n  -http-loader-disable\n        Disable HTTP Loader\n\n  -file-safe-chars string\n        File safe characters to be excluded from image key escape. Set -- for no-op\n  -file-loader-base-dir string\n        Base directory for File Loader. Enable File Loader only if this value present\n  -file-loader-path-prefix string\n        Base path prefix for File Loader\n  -file-result-storage-base-dir string\n        Base directory for File Result Storage. Enable File Result Storage only if this value present\n  -file-result-storage-mkdir-permission string\n        File Result Storage mkdir permission (default \"0755\")\n  -file-result-storage-path-prefix string\n        Base path prefix for File Result Storage\n  -file-result-storage-write-permission string\n        File Storage write permission (default \"0666\")\n  -file-result-storage-expiration duration\n        File Result Storage expiration duration e.g. 24h. Default no expiration\n  -file-storage-base-dir string\n        Base directory for File Storage. Enable File Storage only if this value present\n  -file-storage-path-prefix string\n        Base path prefix for File Storage\n  -file-storage-mkdir-permission string\n        File Storage mkdir permission (default \"0755\")\n  -file-storage-write-permission string\n        File Storage write permission (default \"0666\")\n  -file-storage-expiration duration\n        File Storage expiration duration e.g. 24h. Default no expiration\n\n  -aws-access-key-id string\n        AWS Access Key ID. Required if using S3 Loader or S3 Storage\n  -aws-region string\n        AWS Region. Required if using S3 Loader or S3 Storage\n  -aws-secret-access-key string\n        AWS Secret Access Key. Required if using S3 Loader or S3 Storage\n  -aws-session-token string\n        AWS Session Token. Optional temporary credentials token\n  -s3-endpoint string\n        Optional S3 Endpoint to override default\n  -s3-safe-chars string\n        S3 safe characters to be excluded from image key escape. Set -- for no-op\n  -s3-force-path-style\n        S3 force the request to use path-style addressing s3.amazonaws.com/bucket/key, instead of bucket.s3.amazonaws.com/key\n  -s3-loader-bucket string\n        S3 Bucket for S3 Loader. Enable S3 Loader only if this value present\n  -s3-loader-base-dir string\n        Base directory for S3 Loader\n  -s3-loader-path-prefix string\n        Base path prefix for S3 Loader\n  -s3-result-storage-bucket string\n        S3 Bucket for S3 Result Storage. Enable S3 Result Storage only if this value present\n  -s3-result-storage-base-dir string\n        Base directory for S3 Result Storage\n  -s3-result-storage-path-prefix string\n        Base path prefix for S3 Result Storage\n  -s3-result-storage-acl string\n        Upload ACL for S3 Result Storage (default \"public-read\")\n  -s3-result-storage-expiration duration\n        S3 Result Storage expiration duration e.g. 24h. Default no expiration\n  -s3-storage-bucket string\n        S3 Bucket for S3 Storage. Enable S3 Storage only if this value present\n  -s3-storage-base-dir string\n        Base directory for S3 Storage\n  -s3-storage-path-prefix string\n        Base path prefix for S3 Storage\n  -s3-storage-acl string\n        Upload ACL for S3 Storage (default \"public-read\")\n  -s3-storage-expiration duration\n        S3 Storage expiration duration e.g. 24h. Default no expiration\n        \n  -aws-loader-access-key-id string\n        AWS Access Key ID for S3 Loader to override global config\n  -aws-loader-region string\n        AWS Region for S3 Loader to override global config\n  -aws-loader-secret-access-key string\n        AWS Secret Access Key for S3 Loader to override global config\n  -aws-loader-session-token string\n        AWS Session Token for S3 Loader to override global config\n  -s3-loader-endpoint string\n        Optional S3 Loader Endpoint to override default\n  -aws-storage-access-key-id string\n        AWS Access Key ID for S3 Storage to override global config\n  -aws-storage-region string\n        AWS Region for S3 Storage to override global config\n  -aws-storage-secret-access-key string\n        AWS Secret Access Key for S3 Storage to override global config\n  -aws-storage-session-token string\n        AWS Session Token for S3 Storage to override global config\n  -s3-storage-endpoint string\n        Optional S3 Storage Endpoint to override default\n  -aws-result-storage-access-key-id string\n        AWS Access Key ID for S3 Result Storage to override global config\n  -aws-result-storage-region string\n        AWS Region for S3 Result Storage to override global config\n  -aws-result-storage-secret-access-key string\n        AWS Secret Access Key for S3 Result Storage to override global config\n  -aws-result-storage-session-token string\n        AWS Session Token for S3 Result Storage to override global config\n  -s3-result-storage-endpoint string\n        Optional S3 Storage Endpoint to override default\n\n  -gcloud-safe-chars string\n        Google Cloud safe characters to be excluded from image key escape. Set -- for no-op\n  -gcloud-loader-base-dir string\n        Base directory for Google Cloud Loader\n  -gcloud-loader-bucket string\n        Bucket name for Google Cloud Storage Loader. Enable Google Cloud Loader only if this value present\n  -gcloud-loader-path-prefix string\n        Base path prefix for Google Cloud Loader\n  -gcloud-result-storage-acl string\n        Upload ACL for Google Cloud Result Storage\n  -gcloud-result-storage-base-dir string\n        Base directory for Google Cloud Result Storage\n  -gcloud-result-storage-bucket string\n        Bucket name for Google Cloud Result Storage. Enable Google Cloud Result Storage only if this value present\n  -gcloud-result-storage-expiration duration\n        Google Cloud Result Storage expiration duration e.g. 24h. Default no expiration\n  -gcloud-result-storage-path-prefix string\n        Base path prefix for Google Cloud Result Storage\n  -gcloud-storage-acl string\n        Upload ACL for Google Cloud Storage\n  -gcloud-storage-base-dir string\n        Base directory for Google Cloud\n  -gcloud-storage-bucket string\n        Bucket name for Google Cloud Storage. Enable Google Cloud Storage only if this value present\n  -gcloud-storage-expiration duration\n        Google Cloud Storage expiration duration e.g. 24h. Default no expiration\n  -gcloud-storage-path-prefix string\n        Base path prefix for Google Cloud Storage\n        \n  -vips-max-animation-frames int\n        VIPS maximum number of animation frames to be loaded. Set 1 to disable animation, -1 for unlimited\n  -vips-disable-blur\n        VIPS disable blur operations for vips processor\n  -vips-disable-filters string\n        VIPS disable filters by csv e.g. blur,watermark,rgb\n  -vips-max-filter-ops int\n        VIPS maximum number of filter operations allowed. Set -1 for unlimited (default -1)\n  -vips-max-width int\n        VIPS max image width\n  -vips-max-height int\n        VIPS max image height\n  -vips-max-resolution int\n        VIPS max image resolution\n  -vips-mozjpeg\n        VIPS enable maximum compression with MozJPEG. Requires mozjpeg to be installed\n  -vips-avif-speed int\n        VIPS avif speed, the lowest is at 0 and the fastest is at 9 (Default 5).\n  -vips-strip-metadata\n        VIPS strips all metadata from the resulting image\n        \n  -sentry-dsn\n        include sentry dsn to integrate imagor with sentry\n```\n"
        },
        {
          "name": "app.json",
          "type": "blob",
          "size": 0.8505859375,
          "content": "{\n    \"name\": \"imagor\",\n    \"description\": \"Fast, Docker-ready image processing server in Go with libvips\",\n    \"keywords\": [\n        \"image\",\n        \"resize-images\",\n        \"crop-image\",\n        \"microservice\",\n        \"docker\",\n        \"jpeg\",\n        \"png\",\n        \"libvips\"\n    ],\n    \"repository\": \"https://github.com/cshum/imagor\",\n    \"stack\": \"container\",\n    \"env\": {\n        \"IMAGOR_UNSAFE\": {\n            \"description\": \"Use Unsafe mode, default 1 for testing. In production environment, it is highly recommended turning off `IMAGOR_UNSAFE` and setting up URL signature using `IMAGOR_SECRET`, to prevent DDoS attacks that abuse multiple image operations.\",\n            \"required\": true,\n            \"value\": \"1\"\n        },\n        \"IMAGOR_SECRET\": {\n            \"description\": \"Secret key for URL signature.\",\n            \"required\": false\n        }\n    }\n}"
        },
        {
          "name": "blob.go",
          "type": "blob",
          "size": 13.2802734375,
          "content": "package imagor\n\nimport (\n\t\"bytes\"\n\t\"encoding/json\"\n\t\"github.com/cshum/imagor/fanoutreader\"\n\t\"github.com/cshum/imagor/seekstream\"\n\t\"io\"\n\t\"net/http\"\n\t\"os\"\n\t\"regexp\"\n\t\"strings\"\n\t\"sync\"\n\t\"time\"\n)\n\n// BlobType blob content type\ntype BlobType int\n\nconst maxMemorySize = int64(100 << 20) // 100MB\n\n// BlobType enum\nconst (\n\tBlobTypeUnknown BlobType = iota\n\tBlobTypeEmpty\n\tBlobTypeMemory\n\tBlobTypeJSON\n\tBlobTypeJPEG\n\tBlobTypePNG\n\tBlobTypeGIF\n\tBlobTypeWEBP\n\tBlobTypeAVIF\n\tBlobTypeHEIF\n\tBlobTypeTIFF\n\tBlobTypeJP2\n\tBlobTypeBMP\n\tBlobTypePDF\n\tBlobTypeSVG\n)\n\n// Blob imagor data blob abstraction\ntype Blob struct {\n\tnewReader     func() (r io.ReadCloser, size int64, err error)\n\tnewReadSeeker func() (rs io.ReadSeekCloser, size int64, err error)\n\tfanout        bool\n\tonce          sync.Once\n\tsniffBuf      []byte\n\terr           error\n\tsize          int64\n\tblobType      BlobType\n\tfilepath      string\n\tcontentType   string\n\tmemory        *memory\n\n\tHeader http.Header\n\tStat   *Stat\n}\n\n// Stat Blob stat attributes\ntype Stat struct {\n\tModifiedTime time.Time\n\tETag         string\n\tSize         int64\n}\n\n// NewBlob creates imagor Blob from io.ReadCloser and size\nfunc NewBlob(newReader func() (reader io.ReadCloser, size int64, err error)) *Blob {\n\treturn &Blob{\n\t\tfanout:    true,\n\t\tnewReader: newReader,\n\t}\n}\n\n// NewBlobFromFile creates imagor Blob from file path and optional file info checks\nfunc NewBlobFromFile(filepath string, checks ...func(os.FileInfo) error) *Blob {\n\tstat, err := os.Stat(filepath)\n\tif os.IsNotExist(err) {\n\t\terr = ErrNotFound\n\t}\n\tif err == nil {\n\t\tfor _, check := range checks {\n\t\t\tif err = check(stat); err != nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}\n\tblob := &Blob{\n\t\terr:      err,\n\t\tfilepath: filepath,\n\t\tfanout:   true,\n\t\tnewReader: func() (io.ReadCloser, int64, error) {\n\t\t\tif err != nil {\n\t\t\t\treturn nil, 0, err\n\t\t\t}\n\t\t\treader, err := os.Open(filepath)\n\t\t\treturn reader, stat.Size(), err\n\t\t},\n\t}\n\tif err == nil && stat != nil {\n\t\tsize := stat.Size()\n\t\tmodTime := stat.ModTime()\n\t\tblob.Stat = &Stat{\n\t\t\tSize:         size,\n\t\t\tModifiedTime: modTime,\n\t\t}\n\t}\n\treturn blob\n}\n\n// NewBlobFromJsonMarshal creates imagor Blob from json marshal of any object\nfunc NewBlobFromJsonMarshal(v any) *Blob {\n\tbuf, err := json.Marshal(v)\n\tsize := int64(len(buf))\n\treturn &Blob{\n\t\terr:      err,\n\t\tblobType: BlobTypeJSON,\n\t\tfanout:   false,\n\t\tnewReader: func() (io.ReadCloser, int64, error) {\n\t\t\trs := bytes.NewReader(buf)\n\t\t\treturn &readSeekNopCloser{ReadSeeker: rs}, size, err\n\t\t},\n\t}\n}\n\n// NewBlobFromBytes creates imagor Blob from []byte buffer\nfunc NewBlobFromBytes(buf []byte) *Blob {\n\tsize := int64(len(buf))\n\treturn &Blob{\n\t\tfanout: false,\n\t\tnewReader: func() (io.ReadCloser, int64, error) {\n\t\t\trs := bytes.NewReader(buf)\n\t\t\treturn &readSeekNopCloser{ReadSeeker: rs}, size, nil\n\t\t},\n\t}\n}\n\n// NewBlobFromMemory creates imagor Blob from raw RGB/RGBA buffer\nfunc NewBlobFromMemory(buf []byte, width, height, bands int) *Blob {\n\treturn &Blob{memory: &memory{\n\t\tdata:   buf,\n\t\twidth:  width,\n\t\theight: height,\n\t\tbands:  bands,\n\t}}\n}\n\n// NewEmptyBlob creates empty imagor Blob\nfunc NewEmptyBlob() *Blob {\n\treturn &Blob{}\n}\n\nvar jpegHeader = []byte(\"\\xFF\\xD8\\xFF\")\nvar gifHeader = []byte(\"\\x47\\x49\\x46\")\nvar webpHeader = []byte(\"\\x57\\x45\\x42\\x50\")\nvar pngHeader = []byte(\"\\x89\\x50\\x4E\\x47\")\nvar bmpHeader = []byte(\"BM\")\nvar pdfHeader = []byte(\"\\x25\\x50\\x44\\x46\")\n\n// https://github.com/strukturag/libheif/blob/master/libheif/heif.cc\nvar ftyp = []byte(\"ftyp\")\nvar heic = []byte(\"heic\")\nvar mif1 = []byte(\"mif1\")\nvar msf1 = []byte(\"msf1\")\nvar avif = []byte(\"avif\")\n\n// Jp2 matches a JPEG 2000 Image file (ISO 15444-1).\nvar jp2 = []byte{0x6a, 0x70, 0x32, 0x20}\n\n// Jpx matches a JPEG 2000 Image file (ISO 15444-2).\nvar jpx = []byte{0x6a, 0x70, 0x78, 0x20}\n\n// Jpm matches a JPEG 2000 Image file (ISO 15444-6).\nvar jpm = []byte{0x6a, 0x70, 0x6D, 0x20}\n\nvar tifII = []byte(\"\\x49\\x49\\x2A\\x00\")\nvar tifMM = []byte(\"\\x4D\\x4D\\x00\\x2A\")\n\nvar jsonPrefix = []byte(`{\"`)\nvar (\n\tsvgComment       = regexp.MustCompile(`(?s)<!--.*?-->`)\n\tsvgTagRegex      = regexp.MustCompile(`(?si)\\A\\s*(?:(<!DOCTYPE\\s+svg([\\s:]+.*?>|>))\\s*)*<svg\\b`)\n\tsvgTagInXMLRegex = regexp.MustCompile(`(?si)\\A<\\?xml\\b.*?\\?>\\s*(?:(<!DOCTYPE\\s+svg([\\s:]+.*?>|>))\\s*)*<svg\\b`)\n)\n\ntype readSeekNopCloser struct {\n\tio.ReadSeeker\n}\n\nfunc (readSeekNopCloser) Close() error { return nil }\n\n// hybridReadSeeker uses io.ReadCloser and switch to io.ReadSeekCloser only when seeked\ntype hybridReadSeeker struct {\n\treader        io.ReadCloser\n\tseeker        io.ReadSeekCloser\n\tnewReadSeeker func() (io.ReadSeekCloser, int64, error)\n}\n\n// Read implements the io.Reader interface.\nfunc (h *hybridReadSeeker) Read(p []byte) (n int, err error) {\n\treturn h.reader.Read(p)\n}\n\n// Seek implements the io.Seeker interface.\nfunc (h *hybridReadSeeker) Seek(offset int64, whence int) (_ int64, err error) {\n\tif h.seeker != nil {\n\t\treturn h.seeker.Seek(offset, whence)\n\t}\n\tif h.seeker, _, err = h.newReadSeeker(); err != nil {\n\t\treturn\n\t}\n\t_ = h.reader.Close()\n\th.reader = h.seeker\n\treturn h.seeker.Seek(offset, whence)\n}\n\n// Close implements the io.Closer interface.\nfunc (h *hybridReadSeeker) Close() (err error) {\n\treturn h.reader.Close()\n}\n\ntype memory struct {\n\tdata   []byte\n\twidth  int\n\theight int\n\tbands  int\n}\n\nfunc newEmptyReader() (io.ReadCloser, int64, error) {\n\treturn &readSeekNopCloser{bytes.NewReader(nil)}, 0, nil\n}\n\nfunc (b *Blob) init() {\n\tb.once.Do(b.doInit)\n}\n\nfunc (b *Blob) doInit() {\n\tif b.err != nil {\n\t\treturn\n\t}\n\tif b.newReader == nil {\n\t\tif b.memory != nil {\n\t\t\tb.blobType = BlobTypeMemory\n\t\t} else {\n\t\t\tb.blobType = BlobTypeEmpty\n\t\t}\n\t\tb.newReader = newEmptyReader\n\t\treturn\n\t}\n\treader, size, err := b.newReader()\n\tif err != nil {\n\t\tb.err = err\n\t}\n\tif reader == nil {\n\t\treturn\n\t}\n\tb.size = size\n\tif _, ok := reader.(io.ReadSeekCloser); ok {\n\t\t// construct seeker factory if source supports seek\n\t\tnewReader := b.newReader\n\t\tb.newReadSeeker = func() (io.ReadSeekCloser, int64, error) {\n\t\t\tr, size, err := newReader()\n\t\t\treturn r.(io.ReadSeekCloser), size, err\n\t\t}\n\t}\n\tif b.fanout && size > 0 && size < maxMemorySize && err == nil {\n\t\t// use fan-out reader if buf size known and within memory size\n\t\t// otherwise create new readers\n\t\tfanout := fanoutreader.New(reader, int(size))\n\t\tb.newReader = func() (io.ReadCloser, int64, error) {\n\t\t\treturn fanout.NewReader(), size, nil\n\t\t}\n\t\treader = fanout.NewReader()\n\t\tif b.newReadSeeker != nil {\n\t\t\tnewReadSeeker := b.newReadSeeker\n\t\t\tb.newReadSeeker = func() (rs io.ReadSeekCloser, _ int64, err error) {\n\t\t\t\treturn &hybridReadSeeker{\n\t\t\t\t\treader:        fanout.NewReader(),\n\t\t\t\t\tnewReadSeeker: newReadSeeker,\n\t\t\t\t}, size, nil\n\t\t\t}\n\t\t}\n\t} else {\n\t\tb.fanout = false\n\t}\n\t// sniff first 512 bytes for type sniffing\n\tb.sniffBuf = make([]byte, 512)\n\tn, err := io.ReadAtLeast(reader, b.sniffBuf, 512)\n\t_ = reader.Close()\n\tif n < 512 {\n\t\tb.sniffBuf = b.sniffBuf[:n]\n\t}\n\tif len(b.sniffBuf) == 0 {\n\t\tb.blobType = BlobTypeEmpty\n\t}\n\tif err != nil &&\n\t\terr != io.ErrUnexpectedEOF &&\n\t\terr != io.EOF {\n\t\tif b.err == nil {\n\t\t\tb.err = err\n\t\t}\n\t\treturn\n\t}\n\tif b.blobType != BlobTypeEmpty && b.blobType != BlobTypeJSON && b.blobType != BlobTypeSVG &&\n\t\tlen(b.sniffBuf) > 24 {\n\t\tif bytes.Equal(b.sniffBuf[:3], jpegHeader) {\n\t\t\tb.blobType = BlobTypeJPEG\n\t\t} else if bytes.Equal(b.sniffBuf[:4], pngHeader) {\n\t\t\tb.blobType = BlobTypePNG\n\t\t} else if bytes.Equal(b.sniffBuf[:3], gifHeader) {\n\t\t\tb.blobType = BlobTypeGIF\n\t\t} else if bytes.Equal(b.sniffBuf[8:12], webpHeader) {\n\t\t\tb.blobType = BlobTypeWEBP\n\t\t} else if bytes.Equal(b.sniffBuf[4:8], ftyp) && bytes.Equal(b.sniffBuf[8:12], avif) {\n\t\t\tb.blobType = BlobTypeAVIF\n\t\t} else if bytes.Equal(b.sniffBuf[4:8], ftyp) && (bytes.Equal(b.sniffBuf[8:12], heic) ||\n\t\t\tbytes.Equal(b.sniffBuf[8:12], mif1) ||\n\t\t\tbytes.Equal(b.sniffBuf[8:12], msf1)) {\n\t\t\tb.blobType = BlobTypeHEIF\n\t\t} else if bytes.Equal(b.sniffBuf[:4], tifII) || bytes.Equal(b.sniffBuf[:4], tifMM) {\n\t\t\tb.blobType = BlobTypeTIFF\n\t\t} else if (bytes.Equal(b.sniffBuf[4:8], []byte{0x6A, 0x50, 0x20, 0x20}) ||\n\t\t\tbytes.Equal(b.sniffBuf[4:8], []byte{0x6A, 0x50, 0x32, 0x20})) && (bytes.Equal(b.sniffBuf[20:24], jp2) ||\n\t\t\tbytes.Equal(b.sniffBuf[20:24], jpm) ||\n\t\t\tbytes.Equal(b.sniffBuf[20:24], jpx)) {\n\t\t\tb.blobType = BlobTypeJP2\n\t\t} else if bytes.Equal(b.sniffBuf[:4], pdfHeader) {\n\t\t\tb.blobType = BlobTypePDF\n\t\t} else if bytes.Equal(b.sniffBuf[:2], bmpHeader) {\n\t\t\tb.blobType = BlobTypeBMP\n\t\t}\n\t}\n\tif b.contentType == \"\" {\n\t\tswitch b.blobType {\n\t\tcase BlobTypeJSON:\n\t\t\tb.contentType = \"application/json\"\n\t\tcase BlobTypeJPEG:\n\t\t\tb.contentType = \"image/jpeg\"\n\t\tcase BlobTypePNG:\n\t\t\tb.contentType = \"image/png\"\n\t\tcase BlobTypeGIF:\n\t\t\tb.contentType = \"image/gif\"\n\t\tcase BlobTypeWEBP:\n\t\t\tb.contentType = \"image/webp\"\n\t\tcase BlobTypeAVIF:\n\t\t\tb.contentType = \"image/avif\"\n\t\tcase BlobTypeHEIF:\n\t\t\tb.contentType = \"image/heif\"\n\t\tcase BlobTypeTIFF:\n\t\t\tb.contentType = \"image/tiff\"\n\t\tcase BlobTypeJP2:\n\t\t\tb.contentType = \"image/jp2\"\n\t\tcase BlobTypePDF:\n\t\t\tb.contentType = \"application/pdf\"\n\t\tcase BlobTypeBMP:\n\t\t\tb.contentType = \"image/bmp\"\n\t\tcase BlobTypeSVG:\n\t\t\tb.contentType = \"image/svg+xml\"\n\t\tdefault:\n\t\t\tb.contentType = http.DetectContentType(b.sniffBuf)\n\t\t}\n\t}\n\tif b.blobType == BlobTypeUnknown {\n\t\tif strings.HasPrefix(b.contentType, \"text/plain\") {\n\t\t\tif bytes.Equal(b.sniffBuf[:2], jsonPrefix) {\n\t\t\t\tb.blobType = BlobTypeJSON\n\t\t\t\tb.contentType = \"application/json\"\n\t\t\t}\n\t\t}\n\t\t// idea taken from https://github.com/go-gitea/gitea/blob/58dfaf3a75a097088376a9c221784b3675ac9c48/modules/typesniffer/typesniffer.go#L98-L107\n\t\tdetectByHTML := strings.HasPrefix(b.contentType, \"text/plain\") || strings.HasPrefix(b.contentType, \"text/html\")\n\t\tdetectByXML := strings.HasPrefix(b.contentType, \"text/xml\")\n\t\tif detectByHTML || detectByXML {\n\t\t\tdataProcessed := svgComment.ReplaceAll(b.sniffBuf, nil)\n\t\t\tdataProcessed = bytes.TrimSpace(dataProcessed)\n\t\t\tif (detectByHTML && svgTagRegex.Match(dataProcessed)) ||\n\t\t\t\t(detectByXML && svgTagInXMLRegex.Match(dataProcessed)) {\n\t\t\t\tb.blobType = BlobTypeSVG\n\t\t\t\tb.contentType = \"image/svg+xml\"\n\t\t\t}\n\t\t}\n\t}\n}\n\n// IsEmpty check if blob is empty\nfunc (b *Blob) IsEmpty() bool {\n\tb.init()\n\treturn b.blobType == BlobTypeEmpty\n}\n\n// SupportsAnimation check if blob supports animation\nfunc (b *Blob) SupportsAnimation() bool {\n\tb.init()\n\treturn b.blobType == BlobTypeGIF || b.blobType == BlobTypeWEBP\n}\n\n// BlobType returns BlobType\nfunc (b *Blob) BlobType() BlobType {\n\tb.init()\n\treturn b.blobType\n}\n\n// Sniff returns first 512 bytes of blob data for type sniffing\nfunc (b *Blob) Sniff() []byte {\n\tb.init()\n\treturn b.sniffBuf\n}\n\n// Size returns Blob size if known\nfunc (b *Blob) Size() int64 {\n\tb.init()\n\treturn b.size\n}\n\n// FilePath returns Blob file path if blob is created from file\nfunc (b *Blob) FilePath() string {\n\treturn b.filepath\n}\n\n// Memory returns memory data if Blob is created from memory\nfunc (b *Blob) Memory() (data []byte, width, height, bands int, ok bool) {\n\tif m := b.memory; m != nil {\n\t\tdata = m.data\n\t\twidth = m.width\n\t\theight = m.height\n\t\tbands = m.bands\n\t\tok = true\n\t}\n\treturn\n}\n\n// SetContentType set Blob content type. which overrides default sniffing if this is set\nfunc (b *Blob) SetContentType(contentType string) {\n\tb.contentType = contentType\n}\n\n// ContentType returns content type\nfunc (b *Blob) ContentType() string {\n\tb.init()\n\treturn b.contentType\n}\n\n// NewReader creates new io.ReadCloser and returns size if known\nfunc (b *Blob) NewReader() (reader io.ReadCloser, size int64, err error) {\n\tb.init()\n\treturn b.newReader()\n}\n\n// NewReadSeeker create read seeker if reader supports seek,\n// or attempts to simulate seek using memory or temp file buffer\nfunc (b *Blob) NewReadSeeker() (io.ReadSeekCloser, int64, error) {\n\tb.init()\n\tif b.newReadSeeker != nil {\n\t\treturn b.newReadSeeker()\n\t}\n\t// if source not seekable, simulate seek with seek stream\n\treader, size, err := b.NewReader()\n\tif err != nil {\n\t\treturn nil, size, err\n\t}\n\tvar buffer seekstream.Buffer\n\tif size > 0 && size < maxMemorySize {\n\t\t// in memory buffer if size is known and less then 100mb\n\t\tbuffer = seekstream.NewMemoryBuffer(size)\n\t} else {\n\t\t// otherwise temp file buffer\n\t\tbuffer, err = seekstream.NewTempFileBuffer(\"\", \"imagor-\")\n\t\tif err != nil {\n\t\t\treturn nil, size, err\n\t\t}\n\t}\n\treturn seekstream.New(reader, buffer), size, err\n}\n\n// ReadAll real all bytes from Blob\nfunc (b *Blob) ReadAll() ([]byte, error) {\n\tb.init()\n\tif b.blobType == BlobTypeEmpty {\n\t\treturn nil, b.err\n\t}\n\treader, size, err := b.NewReader()\n\tif reader != nil {\n\t\tdefer func() {\n\t\t\t_ = reader.Close()\n\t\t}()\n\t\tif size > 0 {\n\t\t\tbuf := make([]byte, size)\n\t\t\ts := int(size)\n\t\t\tn, err2 := io.ReadAtLeast(reader, buf, s)\n\t\t\tif n < s {\n\t\t\t\tbuf = buf[:n]\n\t\t\t}\n\t\t\tif err != nil {\n\t\t\t\treturn buf, err\n\t\t\t}\n\t\t\treturn buf, err2\n\t\t}\n\t\tbuf, err2 := io.ReadAll(reader)\n\t\tif err != nil {\n\t\t\treturn buf, err\n\t\t}\n\t\treturn buf, err2\n\t}\n\treturn nil, err\n}\n\n// Err returns Blob error\nfunc (b *Blob) Err() error {\n\tb.init()\n\treturn b.err\n}\n\nfunc isBlobEmpty(blob *Blob) bool {\n\treturn blob == nil || blob.IsEmpty()\n}\n\nfunc checkBlob(blob *Blob, err error) (*Blob, error) {\n\tif blob != nil && err == nil {\n\t\terr = blob.Err()\n\t}\n\treturn blob, err\n}\n\nfunc getExtension(typ BlobType) (ext string) {\n\tswitch typ {\n\tcase BlobTypeJPEG:\n\t\text = \".jpg\"\n\tcase BlobTypePNG:\n\t\text = \".png\"\n\tcase BlobTypeGIF:\n\t\text = \".gif\"\n\tcase BlobTypeWEBP:\n\t\text = \".webp\"\n\tcase BlobTypeAVIF:\n\t\text = \".avif\"\n\tcase BlobTypeHEIF:\n\t\text = \".heif\"\n\tcase BlobTypeTIFF:\n\t\text = \".tiff\"\n\tcase BlobTypeJP2:\n\t\text = \".jp2\"\n\tcase BlobTypeBMP:\n\t\text = \".bmp\"\n\tcase BlobTypePDF:\n\t\text = \".pdf\"\n\tcase BlobTypeJSON:\n\t\text = \".json\"\n\tcase BlobTypeSVG:\n\t\text = \".svg\"\n\t}\n\treturn\n}\n"
        },
        {
          "name": "blob_test.go",
          "type": "blob",
          "size": 8.771484375,
          "content": "package imagor\n\nimport (\n\t\"bytes\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"os\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n\t\"github.com/stretchr/testify/require\"\n)\n\nfunc doTestBlobReaders(t *testing.T, b *Blob, buf []byte) {\n\tr, size, err := b.NewReader()\n\tassert.NotNil(t, r)\n\tassert.NotEmpty(t, size)\n\tassert.NoError(t, err)\n\n\tbuf2, err := io.ReadAll(r)\n\trequire.NoError(t, err)\n\tassert.NotEmpty(t, buf2)\n\tassert.Equal(t, buf, buf2, \"bytes not equal\")\n\n\trs, size, err := b.NewReadSeeker()\n\tassert.NotNil(t, rs)\n\tassert.NotEmpty(t, size)\n\tassert.NoError(t, err)\n\tdefer rs.Close()\n\n\tbuf3, err := io.ReadAll(rs)\n\trequire.NoError(t, err)\n\tassert.NotEmpty(t, buf3)\n\tassert.Equal(t, buf, buf3, \"bytes not equal\")\n\n\tfor i := 0; i < 3; i++ {\n\t\t_, err = rs.Seek(0, io.SeekStart)\n\t\trequire.NoError(t, err)\n\t\tbuf4, err := io.ReadAll(rs)\n\t\trequire.NoError(t, err)\n\t\tassert.NotEmpty(t, buf4)\n\t\tassert.Equal(t, buf, buf4, \"bytes not equal\")\n\t}\n}\n\nfunc TestBlobTypes(t *testing.T) {\n\ttests := []struct {\n\t\tname              string\n\t\tpath              string\n\t\tcontentType       string\n\t\textension         string\n\t\tbytesType         BlobType\n\t\tsupportsAnimation bool\n\t}{\n\t\t{\n\t\t\tname:        \"jpeg\",\n\t\t\tpath:        \"demo1.jpg\",\n\t\t\tcontentType: \"image/jpeg\",\n\t\t\textension:   \".jpg\",\n\t\t\tbytesType:   BlobTypeJPEG,\n\t\t},\n\t\t{\n\t\t\tname:        \"png\",\n\t\t\tpath:        \"gopher.png\",\n\t\t\tcontentType: \"image/png\",\n\t\t\textension:   \".png\",\n\t\t\tbytesType:   BlobTypePNG,\n\t\t},\n\t\t{\n\t\t\tname:        \"tiff\",\n\t\t\tpath:        \"gopher.tiff\",\n\t\t\tcontentType: \"image/tiff\",\n\t\t\textension:   \".tiff\",\n\t\t\tbytesType:   BlobTypeTIFF,\n\t\t},\n\t\t{\n\t\t\tname:              \"gif\",\n\t\t\tpath:              \"dancing-banana.gif\",\n\t\t\tcontentType:       \"image/gif\",\n\t\t\textension:         \".gif\",\n\t\t\tbytesType:         BlobTypeGIF,\n\t\t\tsupportsAnimation: true,\n\t\t},\n\t\t{\n\t\t\tname:              \"webp\",\n\t\t\tpath:              \"demo3.webp\",\n\t\t\tcontentType:       \"image/webp\",\n\t\t\textension:         \".webp\",\n\t\t\tbytesType:         BlobTypeWEBP,\n\t\t\tsupportsAnimation: true,\n\t\t},\n\t\t{\n\t\t\tname:        \"avif\",\n\t\t\tpath:        \"gopher-front.avif\",\n\t\t\tcontentType: \"image/avif\",\n\t\t\textension:   \".avif\",\n\t\t\tbytesType:   BlobTypeAVIF,\n\t\t},\n\t\t{\n\t\t\tname:        \"heif\",\n\t\t\tpath:        \"gopher-front.heif\",\n\t\t\tcontentType: \"image/heif\",\n\t\t\textension:   \".heif\",\n\t\t\tbytesType:   BlobTypeHEIF,\n\t\t},\n\t\t{\n\t\t\tname:        \"jp2\",\n\t\t\tpath:        \"gopher.jp2\",\n\t\t\tcontentType: \"image/jp2\",\n\t\t\textension:   \".jp2\",\n\t\t\tbytesType:   BlobTypeJP2,\n\t\t},\n\t\t{\n\t\t\tname:        \"pdf\",\n\t\t\tpath:        \"sample.pdf\",\n\t\t\tcontentType: \"application/pdf\",\n\t\t\textension:   \".pdf\",\n\t\t\tbytesType:   BlobTypePDF,\n\t\t},\n\t\t{\n\t\t\tname:        \"bmp\",\n\t\t\tpath:        \"bmp_24.bmp\",\n\t\t\tcontentType: \"image/bmp\",\n\t\t\textension:   \".bmp\",\n\t\t\tbytesType:   BlobTypeBMP,\n\t\t},\n\t\t{\n\t\t\tname:        \"svg\",\n\t\t\tpath:        \"test.svg\",\n\t\t\tcontentType: \"image/svg+xml\",\n\t\t\textension:   \".svg\",\n\t\t\tbytesType:   BlobTypeSVG,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tfilepath := \"testdata/\" + tt.path\n\t\t\tb := NewBlobFromFile(filepath, func(info os.FileInfo) error {\n\t\t\t\t// noop\n\t\t\t\treturn nil\n\t\t\t})\n\t\t\tassert.Equal(t, tt.supportsAnimation, b.SupportsAnimation())\n\t\t\tassert.Equal(t, tt.contentType, b.ContentType())\n\t\t\tassert.Equal(t, filepath, b.FilePath())\n\t\t\tassert.Equal(t, tt.bytesType, b.BlobType())\n\t\t\tassert.Equal(t, tt.extension, getExtension(b.BlobType()))\n\t\t\tassert.False(t, b.IsEmpty())\n\t\t\tassert.NotEmpty(t, b.Sniff())\n\t\t\tassert.NotEmpty(t, b.Size())\n\t\t\trequire.NoError(t, b.Err())\n\n\t\t\tbuf, err := b.ReadAll()\n\t\t\trequire.NoError(t, err)\n\n\t\t\tdoTestBlobReaders(t, b, buf)\n\n\t\t\tb = NewBlobFromBytes(buf)\n\t\t\tassert.Equal(t, tt.supportsAnimation, b.SupportsAnimation())\n\t\t\tassert.Equal(t, tt.contentType, b.ContentType())\n\t\t\tassert.Equal(t, tt.bytesType, b.BlobType())\n\t\t\tassert.False(t, b.IsEmpty())\n\t\t\tassert.NotEmpty(t, b.Sniff())\n\t\t\tassert.NotEmpty(t, b.Size())\n\t\t\trequire.NoError(t, b.Err())\n\n\t\t\tdoTestBlobReaders(t, b, buf)\n\n\t\t\tb = NewBlob(func() (reader io.ReadCloser, size int64, err error) {\n\t\t\t\treturn io.NopCloser(bytes.NewReader(buf)), int64(len(buf)), nil\n\t\t\t})\n\t\t\tassert.Equal(t, tt.supportsAnimation, b.SupportsAnimation())\n\t\t\tassert.Equal(t, tt.contentType, b.ContentType())\n\t\t\tassert.Equal(t, tt.bytesType, b.BlobType())\n\t\t\tassert.False(t, b.IsEmpty())\n\t\t\tassert.NotEmpty(t, b.Sniff())\n\t\t\tassert.NotEmpty(t, b.Size())\n\t\t\trequire.NoError(t, b.Err())\n\n\t\t\tdoTestBlobReaders(t, b, buf)\n\n\t\t\tb = NewBlob(func() (reader io.ReadCloser, size int64, err error) {\n\t\t\t\t// unknown size to force discard fanout\n\t\t\t\treturn io.NopCloser(bytes.NewReader(buf)), 0, nil\n\t\t\t})\n\t\t\tassert.Equal(t, tt.supportsAnimation, b.SupportsAnimation())\n\t\t\tassert.Equal(t, tt.contentType, b.ContentType())\n\t\t\tassert.Equal(t, tt.bytesType, b.BlobType())\n\t\t\tassert.False(t, b.IsEmpty())\n\t\t\tassert.NotEmpty(t, b.Sniff())\n\t\t\tassert.Empty(t, b.Size())\n\t\t\trequire.NoError(t, b.Err())\n\n\t\t\tr, size, err := b.NewReader()\n\t\t\tassert.NotNil(t, r)\n\t\t\tassert.Empty(t, size)\n\t\t\tassert.NoError(t, err)\n\n\t\t\tbuf2, err := io.ReadAll(r)\n\t\t\trequire.NoError(t, err)\n\t\t\tassert.NotEmpty(t, buf2)\n\t\t\tassert.Equal(t, buf, buf2, \"bytes not equal\")\n\n\t\t\trs, size, err := b.NewReadSeeker()\n\t\t\trequire.NoError(t, err)\n\t\t\tdefer rs.Close()\n\t\t\tbuf3, err := io.ReadAll(rs)\n\t\t\trequire.NoError(t, err)\n\t\t\tassert.NotEmpty(t, buf3)\n\t\t\tassert.Equal(t, buf, buf3, \"bytes not equal\")\n\n\t\t\tfor i := 0; i < 3; i++ {\n\t\t\t\t_, err = rs.Seek(0, io.SeekStart)\n\t\t\t\trequire.NoError(t, err)\n\t\t\t\tbuf4, err := io.ReadAll(rs)\n\t\t\t\trequire.NoError(t, err)\n\t\t\t\tassert.NotEmpty(t, buf4)\n\t\t\t\tassert.Equal(t, buf, buf4, \"bytes not equal\")\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestNewEmptyBlob(t *testing.T) {\n\tb := NewBlobFromBytes([]byte{})\n\tassert.Empty(t, b.Sniff())\n\tassert.True(t, b.IsEmpty())\n\tassert.Equal(t, BlobTypeEmpty, b.BlobType())\n\n\tbuf, err := b.ReadAll()\n\tassert.NoError(t, err)\n\tassert.Empty(t, buf)\n\n\tb = NewEmptyBlob()\n\tassert.Equal(t, BlobTypeEmpty, b.BlobType())\n\tassert.True(t, b.IsEmpty())\n\tassert.Empty(t, b.Sniff())\n\tassert.Empty(t, b.Size())\n\n\tbuf, err = b.ReadAll()\n\tassert.NoError(t, err)\n\tassert.Empty(t, buf)\n\n\tr, size, err := b.NewReader()\n\tassert.NoError(t, err)\n\tassert.Empty(t, size)\n\tassert.Empty(t, b.Size())\n\n\tbuf, err = io.ReadAll(r)\n\tassert.NoError(t, err)\n\tassert.Empty(t, buf)\n\n\tf, err := os.CreateTemp(\"\", \"tmpfile-\")\n\trequire.NoError(t, err)\n\tdefer f.Close()\n\tdefer os.Remove(f.Name())\n\tfmt.Println(f.Name())\n\tb = NewBlobFromFile(f.Name())\n\tassert.Equal(t, BlobTypeEmpty, b.BlobType())\n\tassert.True(t, b.IsEmpty())\n\tassert.Empty(t, b.Sniff())\n\tassert.Empty(t, b.Size())\n\n\tbuf, err = b.ReadAll()\n\tassert.NoError(t, err)\n\tassert.Empty(t, buf)\n}\n\nfunc TestNewBlobFromMemory(t *testing.T) {\n\tb := NewEmptyBlob()\n\tdata, width, height, bands, ok := b.Memory()\n\tassert.Empty(t, data)\n\tassert.Empty(t, width)\n\tassert.Empty(t, height)\n\tassert.Empty(t, bands)\n\tassert.False(t, ok)\n\tassert.True(t, b.IsEmpty())\n\tb = NewBlobFromMemory([]byte{167, 169}, 2, 1, 1)\n\tassert.Equal(t, BlobTypeMemory, b.BlobType())\n\tassert.False(t, b.IsEmpty())\n\tdata, width, height, bands, ok = b.Memory()\n\tassert.Equal(t, []byte{167, 169}, data)\n\tassert.Equal(t, 2, width)\n\tassert.Equal(t, 1, height)\n\tassert.Equal(t, 1, bands)\n\tassert.True(t, ok)\n}\n\nfunc TestNewJsonMarshalBlob(t *testing.T) {\n\tb := NewBlobFromJsonMarshal(map[string]string{\n\t\t\"foo\": \"bar\",\n\t})\n\tassert.Equal(t, BlobTypeJSON, b.BlobType())\n\tassert.Equal(t, \"application/json\", b.ContentType())\n\tassert.Equal(t, `{\"foo\":\"bar\"}`, string(b.Sniff()))\n\tbuf, _ := b.ReadAll()\n\tassert.Equal(t, `{\"foo\":\"bar\"}`, string(buf))\n}\n\nfunc TestBlobOverrideContentType(t *testing.T) {\n\tb := NewBlobFromFile(\"testdata/demo1.jpg\")\n\tb.SetContentType(\"foo/bar\")\n\tassert.Equal(t, BlobTypeJPEG, b.BlobType())\n\tassert.Equal(t, \"foo/bar\", b.ContentType())\n}\n\nfunc TestBlobJsonBytes(t *testing.T) {\n\tb := NewBlobFromBytes([]byte(`{\"foo\": \"bar\"}`))\n\tassert.Equal(t, BlobTypeJSON, b.BlobType())\n\tassert.Equal(t, \"application/json\", b.ContentType())\n\tassert.Equal(t, \".json\", getExtension(b.BlobType()))\n}\n\ntype readerFunc func(p []byte) (n int, err error)\n\nfunc (rf readerFunc) Read(p []byte) (n int, err error) { return rf(p) }\n\nfunc TestBlobCreateError(t *testing.T) {\n\te := errors.New(\"some error\")\n\tb := NewBlob(func() (reader io.ReadCloser, size int64, err error) {\n\t\treturn nil, 0, e\n\t})\n\tassert.Equal(t, e, b.Err())\n\tbuf, err := b.ReadAll()\n\tassert.Empty(t, buf)\n\tassert.Equal(t, e, err)\n}\n\nfunc TestBlobReaderError(t *testing.T) {\n\te := errors.New(\"some error\")\n\tbuf, err := os.ReadFile(\"testdata/demo1.jpg\")\n\trequire.NoError(t, err)\n\tvar called int\n\tb := NewBlob(func() (reader io.ReadCloser, size int64, err error) {\n\t\treturn io.NopCloser(readerFunc(func(p []byte) (n int, err error) {\n\t\t\tif called > 4 {\n\t\t\t\treturn 0, e\n\t\t\t}\n\t\t\tcalled++\n\t\t\tif len(p) > 100 {\n\t\t\t\tp = p[:100]\n\t\t\t}\n\t\t\tn = copy(p, buf)\n\t\t\tbuf = buf[n:]\n\t\t\treturn\n\t\t})), int64(len(buf)), nil\n\t})\n\tassert.Equal(t, e, b.Err())\n\tassert.Equal(t, 500, len(b.Sniff()))\n\tbuf, err = b.ReadAll()\n\tassert.Equal(t, 500, len(buf))\n\tassert.Equal(t, e, err)\n}\n"
        },
        {
          "name": "cmd",
          "type": "tree",
          "content": null
        },
        {
          "name": "config",
          "type": "tree",
          "content": null
        },
        {
          "name": "context.go",
          "type": "blob",
          "size": 1.888671875,
          "content": "package imagor\n\nimport (\n\t\"context\"\n\t\"errors\"\n\t\"sync\"\n\t\"time\"\n)\n\ntype contextKey struct {\n\tType int8\n}\n\nvar imagorContextKey = contextKey{1}\nvar detachContextKey = contextKey{2}\n\ntype imagorContextRef struct {\n\tfuncs []func()\n\tl     sync.Mutex\n\n\tBlob *Blob\n}\n\nfunc (r *imagorContextRef) Defer(fn func()) {\n\tr.l.Lock()\n\tr.funcs = append(r.funcs, fn)\n\tr.l.Unlock()\n}\n\nfunc (r *imagorContextRef) Done() {\n\tr.l.Lock()\n\tfor _, fn := range r.funcs {\n\t\tfn()\n\t}\n\tr.funcs = nil\n\tr.l.Unlock()\n}\n\n// withContext context with imagor defer handling and cache\nfunc withContext(ctx context.Context) context.Context {\n\tif r, ok := ctx.Value(imagorContextKey).(*imagorContextRef); ok && r != nil {\n\t\treturn ctx\n\t}\n\tr := &imagorContextRef{}\n\tctx = context.WithValue(ctx, imagorContextKey, r)\n\tgo func() {\n\t\t<-ctx.Done()\n\t\tr.Done()\n\t}()\n\treturn ctx\n}\n\nfunc mustContextRef(ctx context.Context) *imagorContextRef {\n\tif r, ok := ctx.Value(imagorContextKey).(*imagorContextRef); ok && r != nil {\n\t\treturn r\n\t}\n\tpanic(errors.New(\"not imagor context\"))\n}\n\n// contextDefer add func to context, defer called at the end of request\nfunc contextDefer(ctx context.Context, fn func()) {\n\tmustContextRef(ctx).Defer(fn)\n}\n\ntype detachedContext struct {\n\tctx context.Context\n}\n\nfunc (detachedContext) Deadline() (time.Time, bool) {\n\treturn time.Time{}, false\n}\n\nfunc (detachedContext) Done() <-chan struct{} {\n\treturn nil\n}\n\nfunc (detachedContext) Err() error {\n\treturn nil\n}\n\nfunc (d detachedContext) Value(key any) any {\n\tif key == detachContextKey {\n\t\treturn true\n\t}\n\treturn d.ctx.Value(key)\n}\n\n// detachContext returns a context that keeps all the values of its parent context\n// but detaches from cancellation and timeout\nfunc detachContext(ctx context.Context) context.Context {\n\treturn detachedContext{ctx: ctx}\n}\n\n// isDetached returns if context is detached\nfunc isDetached(ctx context.Context) bool {\n\t_, ok := ctx.Value(detachContextKey).(bool)\n\treturn ok\n}\n"
        },
        {
          "name": "context_test.go",
          "type": "blob",
          "size": 1.2470703125,
          "content": "package imagor\n\nimport (\n\t\"context\"\n\t\"github.com/stretchr/testify/assert\"\n\t\"testing\"\n\t\"time\"\n)\n\nfunc TestDefer(t *testing.T) {\n\tvar called int\n\tctx, cancel := context.WithCancel(context.Background())\n\tassert.Panics(t, func() {\n\t\tcontextDefer(ctx, func() {\n\t\t\tt.Fatal(\"should not call\")\n\t\t})\n\t})\n\tctx = withContext(ctx)\n\tcontextDefer(ctx, func() {\n\t\tcalled++\n\t})\n\tcontextDefer(ctx, func() {\n\t\tcalled++\n\t})\n\tcancel()\n\tassert.Equal(t, 0, called, \"should call after signal\")\n\ttime.Sleep(time.Millisecond * 10)\n\tcontextDefer(ctx, func() {\n\t\tcalled++\n\t})\n\tassert.Equal(t, 2, called, \"should count all defers before cancel\")\n}\n\nfunc TestDetachContext(t *testing.T) {\n\tctx, cancel := context.WithTimeout(context.Background(), time.Nanosecond)\n\tdefer cancel()\n\tctx = context.WithValue(ctx, \"foo\", \"bar\")\n\tassert.False(t, isDetached(ctx))\n\ttime.Sleep(time.Millisecond)\n\tassert.Equal(t, ctx.Err(), context.DeadlineExceeded)\n\tctx = detachContext(ctx)\n\tassert.True(t, isDetached(ctx))\n\tassert.Equal(t, \"bar\", ctx.Value(\"foo\"))\n\tassert.NoError(t, ctx.Err())\n\tctx, cancel2 := context.WithTimeout(ctx, time.Millisecond*5)\n\tdefer cancel2()\n\tassert.NoError(t, ctx.Err())\n\tassert.True(t, isDetached(ctx))\n\ttime.Sleep(time.Millisecond * 10)\n\tassert.Equal(t, ctx.Err(), context.DeadlineExceeded)\n}\n"
        },
        {
          "name": "errors.go",
          "type": "blob",
          "size": 3.4052734375,
          "content": "package imagor\n\nimport (\n\t\"context\"\n\t\"errors\"\n\t\"fmt\"\n\t\"net/http\"\n\t\"regexp\"\n\t\"strconv\"\n\t\"strings\"\n\n\t\"github.com/cshum/imagor/imagorpath\"\n)\n\nvar (\n\t// ErrNotFound not found error\n\tErrNotFound = NewError(\"not found\", http.StatusNotFound)\n\t// ErrInvalid syntactic invalid path error\n\tErrInvalid = NewError(\"invalid\", http.StatusBadRequest)\n\t// ErrMethodNotAllowed method not allowed error\n\tErrMethodNotAllowed = NewError(\"method not allowed\", http.StatusMethodNotAllowed)\n\t// ErrSourceNotAllowed http source not allowed error\n\tErrSourceNotAllowed = NewError(\"http source not allowed\", http.StatusForbidden)\n\t// ErrSignatureMismatch URL signature mismatch error\n\tErrSignatureMismatch = NewError(\"url signature mismatch\", http.StatusForbidden)\n\t// ErrTimeout timeout error\n\tErrTimeout = NewError(\"timeout\", http.StatusRequestTimeout)\n\t// ErrExpired expire error\n\tErrExpired = NewError(\"expired\", http.StatusGone)\n\t// ErrUnsupportedFormat unsupported format error\n\tErrUnsupportedFormat = NewError(\"unsupported format\", http.StatusNotAcceptable)\n\t// ErrMaxSizeExceeded maximum size exceeded error\n\tErrMaxSizeExceeded = NewError(\"maximum size exceeded\", http.StatusBadRequest)\n\t// ErrMaxResolutionExceeded maximum resolution exceeded error\n\tErrMaxResolutionExceeded = NewError(\"maximum resolution exceeded\", http.StatusUnprocessableEntity)\n\t// ErrTooManyRequests too many requests error\n\tErrTooManyRequests = NewError(\"too many requests\", http.StatusTooManyRequests)\n\t// ErrInternal internal error\n\tErrInternal = NewError(\"internal error\", http.StatusInternalServerError)\n)\n\nconst errPrefix = \"imagor:\"\n\nvar errMsgRegexp = regexp.MustCompile(fmt.Sprintf(\"^%s ([0-9]+) (.*)$\", errPrefix))\n\n// ErrForward indicator passing imagorpath.Params to next processor\ntype ErrForward struct {\n\timagorpath.Params\n}\n\n// Error implements error\nfunc (p ErrForward) Error() string {\n\treturn fmt.Sprintf(\"%s forward %s\", errPrefix, imagorpath.GeneratePath(p.Params))\n}\n\n// Error imagor error convention\ntype Error struct {\n\tMessage string `json:\"message,omitempty\"`\n\tCode    int    `json:\"status,omitempty\"`\n}\n\ntype timeoutErr interface {\n\tTimeout() bool\n}\n\n// Error implements error\nfunc (e Error) Error() string {\n\treturn fmt.Sprintf(\"%s %d %s\", errPrefix, e.Code, e.Message)\n}\n\n// Timeout indicates if error is timeout\nfunc (e Error) Timeout() bool {\n\treturn e.Code == http.StatusRequestTimeout || e.Code == http.StatusGatewayTimeout\n}\n\n// NewError creates imagor Error from message and status code\nfunc NewError(msg string, code int) Error {\n\treturn Error{Message: msg, Code: code}\n}\n\n// NewErrorFromStatusCode creates imagor Error solely from status code\nfunc NewErrorFromStatusCode(code int) Error {\n\treturn NewError(http.StatusText(code), code)\n}\n\n// WrapError wraps Go error into imagor Error\nfunc WrapError(err error) Error {\n\tif err == nil {\n\t\treturn ErrInternal\n\t}\n\tif e, ok := err.(Error); ok {\n\t\treturn e\n\t}\n\tif _, ok := err.(ErrForward); ok {\n\t\t// ErrForward till the end means no supported processor\n\t\treturn ErrUnsupportedFormat\n\t}\n\tif e, ok := err.(timeoutErr); ok {\n\t\tif e.Timeout() {\n\t\t\treturn ErrTimeout\n\t\t}\n\t}\n\tif errors.Is(err, context.DeadlineExceeded) {\n\t\treturn ErrTimeout\n\t}\n\tif msg := err.Error(); errMsgRegexp.MatchString(msg) {\n\t\tif match := errMsgRegexp.FindStringSubmatch(msg); len(match) == 3 {\n\t\t\tcode, _ := strconv.Atoi(match[1])\n\t\t\treturn NewError(match[2], code)\n\t\t}\n\t}\n\tmsg := strings.Replace(err.Error(), \"\\n\", \"\", -1)\n\treturn NewError(msg, http.StatusInternalServerError)\n}\n"
        },
        {
          "name": "errors_test.go",
          "type": "blob",
          "size": 1.1328125,
          "content": "package imagor\n\nimport (\n\t\"context\"\n\t\"errors\"\n\t\"github.com/cshum/imagor/imagorpath\"\n\t\"github.com/stretchr/testify/assert\"\n\t\"net\"\n\t\"net/http\"\n\t\"net/url\"\n\t\"testing\"\n)\n\nfunc TestWrapError(t *testing.T) {\n\tvar err error\n\tvar e Error\n\n\tassert.Equal(t, WrapError(nil), ErrInternal)\n\n\tassert.Equal(t, ErrMethodNotAllowed, WrapError(ErrMethodNotAllowed))\n\n\terr = NewError(\"errorrrr\", 167)\n\tassert.Equal(t, WrapError(errors.New(err.Error())), err)\n\n\tassert.Equal(t, ErrTimeout, WrapError(context.DeadlineExceeded))\n\n\tassert.Equal(t, true, ErrTimeout.Timeout())\n\n\tassert.Equal(t, ErrTimeout, WrapError(&url.Error{Err: context.DeadlineExceeded}))\n\n\terr = errors.New(\"asdfsdfsaf\")\n\te = WrapError(err)\n\tassert.Equal(t, 500, e.Code)\n\tassert.Contains(t, e.Error(), err.Error())\n\n\te = NewErrorFromStatusCode(403)\n\tassert.Equal(t, 403, e.Code)\n\tassert.Contains(t, e.Error(), http.StatusText(403))\n\n\terr = &net.DNSError{IsTimeout: true}\n\tassert.Equal(t, ErrTimeout, WrapError(err))\n\n\terr = ErrForward{imagorpath.Params{Width: 167, Height: 169, Image: \"foo\"}}\n\tassert.Equal(t, \"imagor: forward 167x169/foo\", err.Error())\n\tassert.Equal(t, ErrUnsupportedFormat, WrapError(err))\n\n}\n"
        },
        {
          "name": "examples",
          "type": "tree",
          "content": null
        },
        {
          "name": "fanoutreader",
          "type": "tree",
          "content": null
        },
        {
          "name": "go.mod",
          "type": "blob",
          "size": 4.1796875,
          "content": "module github.com/cshum/imagor\n\ngo 1.22\n\nrequire (\n\tcloud.google.com/go/storage v1.48.0\n\tgithub.com/TheZeroSlave/zapsentry v1.23.0\n\tgithub.com/aws/aws-sdk-go v1.55.5\n\tgithub.com/fsouza/fake-gcs-server v1.50.2\n\tgithub.com/getsentry/sentry-go v0.30.0\n\tgithub.com/johannesboyne/gofakes3 v0.0.0-20241026070602-0da3aa9c32ca\n\tgithub.com/peterbourgon/ff/v3 v3.4.0\n\tgithub.com/prometheus/client_golang v1.20.5\n\tgithub.com/rs/cors v1.11.1\n\tgithub.com/stretchr/testify v1.10.0\n\tgo.uber.org/zap v1.27.0\n\tgolang.org/x/image v0.23.0\n\tgolang.org/x/sync v0.10.0\n)\n\nrequire (\n\tcel.dev/expr v0.16.1 // indirect\n\tcloud.google.com/go v0.116.0 // indirect\n\tcloud.google.com/go/auth v0.11.0 // indirect\n\tcloud.google.com/go/auth/oauth2adapt v0.2.6 // indirect\n\tcloud.google.com/go/compute/metadata v0.5.2 // indirect\n\tcloud.google.com/go/iam v1.2.2 // indirect\n\tcloud.google.com/go/monitoring v1.21.2 // indirect\n\tcloud.google.com/go/pubsub v1.45.1 // indirect\n\tgithub.com/GoogleCloudPlatform/opentelemetry-operations-go/detectors/gcp v1.24.1 // indirect\n\tgithub.com/GoogleCloudPlatform/opentelemetry-operations-go/exporter/metric v0.48.1 // indirect\n\tgithub.com/GoogleCloudPlatform/opentelemetry-operations-go/internal/resourcemapping v0.48.1 // indirect\n\tgithub.com/beorn7/perks v1.0.1 // indirect\n\tgithub.com/census-instrumentation/opencensus-proto v0.4.1 // indirect\n\tgithub.com/cespare/xxhash/v2 v2.3.0 // indirect\n\tgithub.com/cncf/xds/go v0.0.0-20240905190251-b4127c9b8d78 // indirect\n\tgithub.com/davecgh/go-spew v1.1.1 // indirect\n\tgithub.com/envoyproxy/go-control-plane v0.13.0 // indirect\n\tgithub.com/envoyproxy/protoc-gen-validate v1.1.0 // indirect\n\tgithub.com/felixge/httpsnoop v1.0.4 // indirect\n\tgithub.com/go-logr/logr v1.4.2 // indirect\n\tgithub.com/go-logr/stdr v1.2.2 // indirect\n\tgithub.com/golang/groupcache v0.0.0-20210331224755-41bb18bfe9da // indirect\n\tgithub.com/google/renameio/v2 v2.0.0 // indirect\n\tgithub.com/google/s2a-go v0.1.8 // indirect\n\tgithub.com/google/uuid v1.6.0 // indirect\n\tgithub.com/googleapis/enterprise-certificate-proxy v0.3.4 // indirect\n\tgithub.com/googleapis/gax-go/v2 v2.14.0 // indirect\n\tgithub.com/gorilla/handlers v1.5.2 // indirect\n\tgithub.com/gorilla/mux v1.8.1 // indirect\n\tgithub.com/jmespath/go-jmespath v0.4.0 // indirect\n\tgithub.com/klauspost/compress v1.17.11 // indirect\n\tgithub.com/munnerz/goautoneg v0.0.0-20191010083416-a7dc8b61c822 // indirect\n\tgithub.com/pkg/xattr v0.4.10 // indirect\n\tgithub.com/planetscale/vtprotobuf v0.6.1-0.20240319094008-0393e58bdf10 // indirect\n\tgithub.com/pmezard/go-difflib v1.0.0 // indirect\n\tgithub.com/prometheus/client_model v0.6.1 // indirect\n\tgithub.com/prometheus/common v0.55.0 // indirect\n\tgithub.com/prometheus/procfs v0.15.1 // indirect\n\tgithub.com/ryszard/goskiplist v0.0.0-20150312221310-2dfbae5fcf46 // indirect\n\tgo.opencensus.io v0.24.0 // indirect\n\tgo.opentelemetry.io/contrib/detectors/gcp v1.29.0 // indirect\n\tgo.opentelemetry.io/contrib/instrumentation/google.golang.org/grpc/otelgrpc v0.54.0 // indirect\n\tgo.opentelemetry.io/contrib/instrumentation/net/http/otelhttp v0.54.0 // indirect\n\tgo.opentelemetry.io/otel v1.29.0 // indirect\n\tgo.opentelemetry.io/otel/metric v1.29.0 // indirect\n\tgo.opentelemetry.io/otel/sdk v1.29.0 // indirect\n\tgo.opentelemetry.io/otel/sdk/metric v1.29.0 // indirect\n\tgo.opentelemetry.io/otel/trace v1.29.0 // indirect\n\tgo.shabbyrobe.org/gocovmerge v0.0.0-20230507111327-fa4f82cfbf4d // indirect\n\tgo.uber.org/multierr v1.11.0 // indirect\n\tgolang.org/x/crypto v0.31.0 // indirect\n\tgolang.org/x/net v0.31.0 // indirect\n\tgolang.org/x/oauth2 v0.24.0 // indirect\n\tgolang.org/x/sys v0.28.0 // indirect\n\tgolang.org/x/text v0.21.0 // indirect\n\tgolang.org/x/time v0.8.0 // indirect\n\tgolang.org/x/tools v0.21.1-0.20240508182429-e35e4ccd0d2d // indirect\n\tgoogle.golang.org/api v0.210.0 // indirect\n\tgoogle.golang.org/genproto v0.0.0-20241118233622-e639e219e697 // indirect\n\tgoogle.golang.org/genproto/googleapis/api v0.0.0-20241113202542-65e8d215514f // indirect\n\tgoogle.golang.org/genproto/googleapis/rpc v0.0.0-20241118233622-e639e219e697 // indirect\n\tgoogle.golang.org/grpc v1.67.2 // indirect\n\tgoogle.golang.org/grpc/stats/opentelemetry v0.0.0-20240907200651-3ffb98b2c93a // indirect\n\tgoogle.golang.org/protobuf v1.35.2 // indirect\n\tgopkg.in/yaml.v3 v3.0.1 // indirect\n)\n"
        },
        {
          "name": "go.sum",
          "type": "blob",
          "size": 32.052734375,
          "content": "cel.dev/expr v0.16.1 h1:NR0+oFYzR1CqLFhTAqg3ql59G9VfN8fKq1TCHJ6gq1g=\ncel.dev/expr v0.16.1/go.mod h1:AsGA5zb3WruAEQeQng1RZdGEXmBj0jvMWh6l5SnNuC8=\ncloud.google.com/go v0.26.0/go.mod h1:aQUYkXzVsufM+DwF1aE+0xfcU+56JwCaLick0ClmMTw=\ncloud.google.com/go v0.116.0 h1:B3fRrSDkLRt5qSHWe40ERJvhvnQwdZiHu0bJOpldweE=\ncloud.google.com/go v0.116.0/go.mod h1:cEPSRWPzZEswwdr9BxE6ChEn01dWlTaF05LiC2Xs70U=\ncloud.google.com/go/auth v0.11.0 h1:Ic5SZz2lsvbYcWT5dfjNWgw6tTlGi2Wc8hyQSC9BstA=\ncloud.google.com/go/auth v0.11.0/go.mod h1:xxA5AqpDrvS+Gkmo9RqrGGRh6WSNKKOXhY3zNOr38tI=\ncloud.google.com/go/auth/oauth2adapt v0.2.6 h1:V6a6XDu2lTwPZWOawrAa9HUK+DB2zfJyTuciBG5hFkU=\ncloud.google.com/go/auth/oauth2adapt v0.2.6/go.mod h1:AlmsELtlEBnaNTL7jCj8VQFLy6mbZv0s4Q7NGBeQ5E8=\ncloud.google.com/go/compute/metadata v0.5.2 h1:UxK4uu/Tn+I3p2dYWTfiX4wva7aYlKixAHn3fyqngqo=\ncloud.google.com/go/compute/metadata v0.5.2/go.mod h1:C66sj2AluDcIqakBq/M8lw8/ybHgOZqin2obFxa/E5k=\ncloud.google.com/go/iam v1.2.2 h1:ozUSofHUGf/F4tCNy/mu9tHLTaxZFLOUiKzjcgWHGIA=\ncloud.google.com/go/iam v1.2.2/go.mod h1:0Ys8ccaZHdI1dEUilwzqng/6ps2YB6vRsjIe00/+6JY=\ncloud.google.com/go/kms v1.20.1 h1:og29Wv59uf2FVaZlesaiDAqHFzHaoUyHI3HYp9VUHVg=\ncloud.google.com/go/kms v1.20.1/go.mod h1:LywpNiVCvzYNJWS9JUcGJSVTNSwPwi0vBAotzDqn2nc=\ncloud.google.com/go/logging v1.12.0 h1:ex1igYcGFd4S/RZWOCU51StlIEuey5bjqwH9ZYjHibk=\ncloud.google.com/go/logging v1.12.0/go.mod h1:wwYBt5HlYP1InnrtYI0wtwttpVU1rifnMT7RejksUAM=\ncloud.google.com/go/longrunning v0.6.2 h1:xjDfh1pQcWPEvnfjZmwjKQEcHnpz6lHjfy7Fo0MK+hc=\ncloud.google.com/go/longrunning v0.6.2/go.mod h1:k/vIs83RN4bE3YCswdXC5PFfWVILjm3hpEUlSko4PiI=\ncloud.google.com/go/monitoring v1.21.2 h1:FChwVtClH19E7pJ+e0xUhJPGksctZNVOk2UhMmblmdU=\ncloud.google.com/go/monitoring v1.21.2/go.mod h1:hS3pXvaG8KgWTSz+dAdyzPrGUYmi2Q+WFX8g2hqVEZU=\ncloud.google.com/go/pubsub v1.45.1 h1:ZC/UzYcrmK12THWn1P72z+Pnp2vu/zCZRXyhAfP1hJY=\ncloud.google.com/go/pubsub v1.45.1/go.mod h1:3bn7fTmzZFwaUjllitv1WlsNMkqBgGUb3UdMhI54eCc=\ncloud.google.com/go/storage v1.48.0 h1:FhBDHACbVtdPx7S/AbcKujPWiHvfO6F8OXGgCEbB2+o=\ncloud.google.com/go/storage v1.48.0/go.mod h1:aFoDYNMAjv67lp+xcuZqjUKv/ctmplzQ3wJgodA7b+M=\ncloud.google.com/go/trace v1.11.2 h1:4ZmaBdL8Ng/ajrgKqY5jfvzqMXbrDcBsUGXOT9aqTtI=\ncloud.google.com/go/trace v1.11.2/go.mod h1:bn7OwXd4pd5rFuAnTrzBuoZ4ax2XQeG3qNgYmfCy0Io=\ngithub.com/BurntSushi/toml v0.3.1/go.mod h1:xHWCNGjB5oqiDr8zfno3MHue2Ht5sIBksp03qcyfWMU=\ngithub.com/GoogleCloudPlatform/opentelemetry-operations-go/detectors/gcp v1.24.1 h1:pB2F2JKCj1Znmp2rwxxt1J0Fg0wezTMgWYk5Mpbi1kg=\ngithub.com/GoogleCloudPlatform/opentelemetry-operations-go/detectors/gcp v1.24.1/go.mod h1:itPGVDKf9cC/ov4MdvJ2QZ0khw4bfoo9jzwTJlaxy2k=\ngithub.com/GoogleCloudPlatform/opentelemetry-operations-go/exporter/metric v0.48.1 h1:UQ0AhxogsIRZDkElkblfnwjc3IaltCm2HUMvezQaL7s=\ngithub.com/GoogleCloudPlatform/opentelemetry-operations-go/exporter/metric v0.48.1/go.mod h1:jyqM3eLpJ3IbIFDTKVz2rF9T/xWGW0rIriGwnz8l9Tk=\ngithub.com/GoogleCloudPlatform/opentelemetry-operations-go/internal/cloudmock v0.48.1 h1:oTX4vsorBZo/Zdum6OKPA4o7544hm6smoRv1QjpTwGo=\ngithub.com/GoogleCloudPlatform/opentelemetry-operations-go/internal/cloudmock v0.48.1/go.mod h1:0wEl7vrAD8mehJyohS9HZy+WyEOaQO2mJx86Cvh93kM=\ngithub.com/GoogleCloudPlatform/opentelemetry-operations-go/internal/resourcemapping v0.48.1 h1:8nn+rsCvTq9axyEh382S0PFLBeaFwNsT43IrPWzctRU=\ngithub.com/GoogleCloudPlatform/opentelemetry-operations-go/internal/resourcemapping v0.48.1/go.mod h1:viRWSEhtMZqz1rhwmOVKkWl6SwmVowfL9O2YR5gI2PE=\ngithub.com/TheZeroSlave/zapsentry v1.23.0 h1:TKyzfEL7LRlRr+7AvkukVLZ+jZPC++ebCUv7ZJHl1AU=\ngithub.com/TheZeroSlave/zapsentry v1.23.0/go.mod h1:3DRFLu4gIpnCTD4V9HMCBSaqYP8gYU7mZickrs2/rIY=\ngithub.com/aws/aws-sdk-go v1.44.256/go.mod h1:aVsgQcEevwlmQ7qHE9I3h+dtQgpqhFB+i8Phjh7fkwI=\ngithub.com/aws/aws-sdk-go v1.55.5 h1:KKUZBfBoyqy5d3swXyiC7Q76ic40rYcbqH7qjh59kzU=\ngithub.com/aws/aws-sdk-go v1.55.5/go.mod h1:eRwEWoyTWFMVYVQzKMNHWP5/RV4xIUGMQfXQHfHkpNU=\ngithub.com/beorn7/perks v1.0.1 h1:VlbKKnNfV8bJzeqoa4cOKqO6bYr3WgKZxO8Z16+hsOM=\ngithub.com/beorn7/perks v1.0.1/go.mod h1:G2ZrVWU2WbWT9wwq4/hrbKbnv/1ERSJQ0ibhJ6rlkpw=\ngithub.com/census-instrumentation/opencensus-proto v0.2.1/go.mod h1:f6KPmirojxKA12rnyqOA5BBL4O983OfeGPqjHWSTneU=\ngithub.com/census-instrumentation/opencensus-proto v0.4.1 h1:iKLQ0xPNFxR/2hzXZMrBo8f1j86j5WHzznCCQxV/b8g=\ngithub.com/census-instrumentation/opencensus-proto v0.4.1/go.mod h1:4T9NM4+4Vw91VeyqjLS6ao50K5bOcLKN6Q42XnYaRYw=\ngithub.com/cespare/xxhash/v2 v2.3.0 h1:UL815xU9SqsFlibzuggzjXhog7bL6oX9BbNZnL2UFvs=\ngithub.com/cespare/xxhash/v2 v2.3.0/go.mod h1:VGX0DQ3Q6kWi7AoAeZDth3/j3BFtOZR5XLFGgcrjCOs=\ngithub.com/cevatbarisyilmaz/ara v0.0.4 h1:SGH10hXpBJhhTlObuZzTuFn1rrdmjQImITXnZVPSodc=\ngithub.com/cevatbarisyilmaz/ara v0.0.4/go.mod h1:BfFOxnUd6Mj6xmcvRxHN3Sr21Z1T3U2MYkYOmoQe4Ts=\ngithub.com/client9/misspell v0.3.4/go.mod h1:qj6jICC3Q7zFZvVWo7KLAzC3yx5G7kyvSDkc90ppPyw=\ngithub.com/cncf/udpa/go v0.0.0-20191209042840-269d4d468f6f/go.mod h1:M8M6+tZqaGXZJjfX53e64911xZQV5JYwmTeXPW+k8Sc=\ngithub.com/cncf/xds/go v0.0.0-20240905190251-b4127c9b8d78 h1:QVw89YDxXxEe+l8gU8ETbOasdwEV+avkR75ZzsVV9WI=\ngithub.com/cncf/xds/go v0.0.0-20240905190251-b4127c9b8d78/go.mod h1:W+zGtBO5Y1IgJhy4+A9GOqVhqLpfZi+vwmdNXUehLA8=\ngithub.com/davecgh/go-spew v1.1.0/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=\ngithub.com/davecgh/go-spew v1.1.1 h1:vj9j/u1bqnvCEfJOwUhtlOARqs3+rkHYY13jYWTU97c=\ngithub.com/davecgh/go-spew v1.1.1/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=\ngithub.com/dustin/go-humanize v1.0.1 h1:GzkhY7T5VNhEkwH0PVJgjz+fX1rhBrR7pRT3mDkpeCY=\ngithub.com/dustin/go-humanize v1.0.1/go.mod h1:Mu1zIs6XwVuF/gI1OepvI0qD18qycQx+mFykh5fBlto=\ngithub.com/envoyproxy/go-control-plane v0.9.0/go.mod h1:YTl/9mNaCwkRvm6d1a2C3ymFceY/DCBVvsKhRF0iEA4=\ngithub.com/envoyproxy/go-control-plane v0.9.1-0.20191026205805-5f8ba28d4473/go.mod h1:YTl/9mNaCwkRvm6d1a2C3ymFceY/DCBVvsKhRF0iEA4=\ngithub.com/envoyproxy/go-control-plane v0.9.4/go.mod h1:6rpuAdCZL397s3pYoYcLgu1mIlRU8Am5FuJP05cCM98=\ngithub.com/envoyproxy/go-control-plane v0.13.0 h1:HzkeUz1Knt+3bK+8LG1bxOO/jzWZmdxpwC51i202les=\ngithub.com/envoyproxy/go-control-plane v0.13.0/go.mod h1:GRaKG3dwvFoTg4nj7aXdZnvMg4d7nvT/wl9WgVXn3Q8=\ngithub.com/envoyproxy/protoc-gen-validate v0.1.0/go.mod h1:iSmxcyjqTsJpI2R4NaDN7+kN2VEUnK/pcBlmesArF7c=\ngithub.com/envoyproxy/protoc-gen-validate v1.1.0 h1:tntQDh69XqOCOZsDz0lVJQez/2L6Uu2PdjCQwWCJ3bM=\ngithub.com/envoyproxy/protoc-gen-validate v1.1.0/go.mod h1:sXRDRVmzEbkM7CVcM06s9shE/m23dg3wzjl0UWqJ2q4=\ngithub.com/felixge/httpsnoop v1.0.4 h1:NFTV2Zj1bL4mc9sqWACXbQFVBBg2W3GPvqp8/ESS2Wg=\ngithub.com/felixge/httpsnoop v1.0.4/go.mod h1:m8KPJKqk1gH5J9DgRY2ASl2lWCfGKXixSwevea8zH2U=\ngithub.com/fsouza/fake-gcs-server v1.50.2 h1:ulrS1pavCOCbMZfN5ZPgBRMFWclON9xDsuLBniXtQoE=\ngithub.com/fsouza/fake-gcs-server v1.50.2/go.mod h1:VU6Zgei4647KuT4XER8WHv5Hcj2NIySndyG8gfvwckA=\ngithub.com/getsentry/sentry-go v0.30.0 h1:lWUwDnY7sKHaVIoZ9wYqRHJ5iEmoc0pqcRqFkosKzBo=\ngithub.com/getsentry/sentry-go v0.30.0/go.mod h1:WU9B9/1/sHDqeV8T+3VwwbjeR5MSXs/6aqG3mqZrezA=\ngithub.com/go-errors/errors v1.4.2 h1:J6MZopCL4uSllY1OfXM374weqZFFItUbrImctkmUxIA=\ngithub.com/go-errors/errors v1.4.2/go.mod h1:sIVyrIiJhuEF+Pj9Ebtd6P/rEYROXFi3BopGUQ5a5Og=\ngithub.com/go-ini/ini v1.67.0 h1:z6ZrTEZqSWOTyH2FlglNbNgARyHG8oLW9gMELqKr06A=\ngithub.com/go-ini/ini v1.67.0/go.mod h1:ByCAeIL28uOIIG0E3PJtZPDL8WnHpFKFOtgjp+3Ies8=\ngithub.com/go-logr/logr v1.2.2/go.mod h1:jdQByPbusPIv2/zmleS9BjJVeZ6kBagPoEUsqbVz/1A=\ngithub.com/go-logr/logr v1.4.2 h1:6pFjapn8bFcIbiKo3XT4j/BhANplGihG6tvd+8rYgrY=\ngithub.com/go-logr/logr v1.4.2/go.mod h1:9T104GzyrTigFIr8wt5mBrctHMim0Nb2HLGrmQ40KvY=\ngithub.com/go-logr/stdr v1.2.2 h1:hSWxHoqTgW2S2qGc0LTAI563KZ5YKYRhT3MFKZMbjag=\ngithub.com/go-logr/stdr v1.2.2/go.mod h1:mMo/vtBO5dYbehREoey6XUKy/eSumjCCveDpRre4VKE=\ngithub.com/goccy/go-json v0.10.3 h1:KZ5WoDbxAIgm2HNbYckL0se1fHD6rz5j4ywS6ebzDqA=\ngithub.com/goccy/go-json v0.10.3/go.mod h1:oq7eo15ShAhp70Anwd5lgX2pLfOS3QCiwU/PULtXL6M=\ngithub.com/golang/glog v0.0.0-20160126235308-23def4e6c14b/go.mod h1:SBH7ygxi8pfUlaOkMMuAQtPIUF8ecWP5IEl/CR7VP2Q=\ngithub.com/golang/groupcache v0.0.0-20200121045136-8c9f03a8e57e/go.mod h1:cIg4eruTrX1D+g88fzRXU5OdNfaM+9IcxsU14FzY7Hc=\ngithub.com/golang/groupcache v0.0.0-20210331224755-41bb18bfe9da h1:oI5xCqsCo564l8iNU+DwB5epxmsaqB+rhGL0m5jtYqE=\ngithub.com/golang/groupcache v0.0.0-20210331224755-41bb18bfe9da/go.mod h1:cIg4eruTrX1D+g88fzRXU5OdNfaM+9IcxsU14FzY7Hc=\ngithub.com/golang/mock v1.1.1/go.mod h1:oTYuIxOrZwtPieC+H1uAHpcLFnEyAGVDL/k47Jfbm0A=\ngithub.com/golang/protobuf v1.2.0/go.mod h1:6lQm79b+lXiMfvg/cZm0SGofjICqVBUtrP5yJMmIC1U=\ngithub.com/golang/protobuf v1.3.2/go.mod h1:6lQm79b+lXiMfvg/cZm0SGofjICqVBUtrP5yJMmIC1U=\ngithub.com/golang/protobuf v1.4.0-rc.1/go.mod h1:ceaxUfeHdC40wWswd/P6IGgMaK3YpKi5j83Wpe3EHw8=\ngithub.com/golang/protobuf v1.4.0-rc.1.0.20200221234624-67d41d38c208/go.mod h1:xKAWHe0F5eneWXFV3EuXVDTCmh+JuBKY0li0aMyXATA=\ngithub.com/golang/protobuf v1.4.0-rc.2/go.mod h1:LlEzMj4AhA7rCAGe4KMBDvJI+AwstrUpVNzEA03Pprs=\ngithub.com/golang/protobuf v1.4.0-rc.4.0.20200313231945-b860323f09d0/go.mod h1:WU3c8KckQ9AFe+yFwt9sWVRKCVIyN9cPHBJSNnbL67w=\ngithub.com/golang/protobuf v1.4.0/go.mod h1:jodUvKwWbYaEsadDk5Fwe5c77LiNKVO9IDvqG2KuDX0=\ngithub.com/golang/protobuf v1.4.1/go.mod h1:U8fpvMrcmy5pZrNK1lt4xCsGvpyWQ/VVv6QDs8UjoX8=\ngithub.com/golang/protobuf v1.4.3/go.mod h1:oDoupMAO8OvCJWAcko0GGGIgR6R6ocIYbsSw735rRwI=\ngithub.com/golang/protobuf v1.5.4 h1:i7eJL8qZTpSEXOPTxNKhASYpMn+8e5Q6AdndVa1dWek=\ngithub.com/golang/protobuf v1.5.4/go.mod h1:lnTiLA8Wa4RWRcIUkrtSVa5nRhsEGBg48fD6rSs7xps=\ngithub.com/google/go-cmp v0.2.0/go.mod h1:oXzfMopK8JAjlY9xF4vHSVASa0yLyX7SntLO5aqRK0M=\ngithub.com/google/go-cmp v0.3.0/go.mod h1:8QqcDgzrUqlUb/G2PQTWiueGozuR1884gddMywk6iLU=\ngithub.com/google/go-cmp v0.3.1/go.mod h1:8QqcDgzrUqlUb/G2PQTWiueGozuR1884gddMywk6iLU=\ngithub.com/google/go-cmp v0.4.0/go.mod h1:v8dTdLbMG2kIc/vJvl+f65V22dbkXbowE6jgT/gNBxE=\ngithub.com/google/go-cmp v0.5.0/go.mod h1:v8dTdLbMG2kIc/vJvl+f65V22dbkXbowE6jgT/gNBxE=\ngithub.com/google/go-cmp v0.5.3/go.mod h1:v8dTdLbMG2kIc/vJvl+f65V22dbkXbowE6jgT/gNBxE=\ngithub.com/google/go-cmp v0.6.0 h1:ofyhxvXcZhMsU5ulbFiLKl/XBFqE1GSq7atu8tAmTRI=\ngithub.com/google/go-cmp v0.6.0/go.mod h1:17dUlkBOakJ0+DkrSSNjCkIjxS6bF9zb3elmeNGIjoY=\ngithub.com/google/martian/v3 v3.3.3 h1:DIhPTQrbPkgs2yJYdXU/eNACCG5DVQjySNRNlflZ9Fc=\ngithub.com/google/martian/v3 v3.3.3/go.mod h1:iEPrYcgCF7jA9OtScMFQyAlZZ4YXTKEtJ1E6RWzmBA0=\ngithub.com/google/renameio/v2 v2.0.0 h1:UifI23ZTGY8Tt29JbYFiuyIU3eX+RNFtUwefq9qAhxg=\ngithub.com/google/renameio/v2 v2.0.0/go.mod h1:BtmJXm5YlszgC+TD4HOEEUFgkJP3nLxehU6hfe7jRt4=\ngithub.com/google/s2a-go v0.1.8 h1:zZDs9gcbt9ZPLV0ndSyQk6Kacx2g/X+SKYovpnz3SMM=\ngithub.com/google/s2a-go v0.1.8/go.mod h1:6iNWHTpQ+nfNRN5E00MSdfDwVesa8hhS32PhPO8deJA=\ngithub.com/google/uuid v1.1.2/go.mod h1:TIyPZe4MgqvfeYDBFedMoGGpEw/LqOeaOT+nhxU+yHo=\ngithub.com/google/uuid v1.6.0 h1:NIvaJDMOsjHA8n1jAhLSgzrAzy1Hgr+hNrb57e+94F0=\ngithub.com/google/uuid v1.6.0/go.mod h1:TIyPZe4MgqvfeYDBFedMoGGpEw/LqOeaOT+nhxU+yHo=\ngithub.com/googleapis/enterprise-certificate-proxy v0.3.4 h1:XYIDZApgAnrN1c855gTgghdIA6Stxb52D5RnLI1SLyw=\ngithub.com/googleapis/enterprise-certificate-proxy v0.3.4/go.mod h1:YKe7cfqYXjKGpGvmSg28/fFvhNzinZQm8DGnaburhGA=\ngithub.com/googleapis/gax-go/v2 v2.14.0 h1:f+jMrjBPl+DL9nI4IQzLUxMq7XrAqFYB7hBPqMNIe8o=\ngithub.com/googleapis/gax-go/v2 v2.14.0/go.mod h1:lhBCnjdLrWRaPvLWhmc8IS24m9mr07qSYnHncrgo+zk=\ngithub.com/gorilla/handlers v1.5.2 h1:cLTUSsNkgcwhgRqvCNmdbRWG0A3N4F+M2nWKdScwyEE=\ngithub.com/gorilla/handlers v1.5.2/go.mod h1:dX+xVpaxdSw+q0Qek8SSsl3dfMk3jNddUkMzo0GtH0w=\ngithub.com/gorilla/mux v1.8.1 h1:TuBL49tXwgrFYWhqrNgrUNEY92u81SPhu7sTdzQEiWY=\ngithub.com/gorilla/mux v1.8.1/go.mod h1:AKf9I4AEqPTmMytcMc0KkNouC66V3BtZ4qD5fmWSiMQ=\ngithub.com/jmespath/go-jmespath v0.4.0 h1:BEgLn5cpjn8UN1mAw4NjwDrS35OdebyEtFe+9YPoQUg=\ngithub.com/jmespath/go-jmespath v0.4.0/go.mod h1:T8mJZnbsbmF+m6zOOFylbeCJqk5+pHWvzYPziyZiYoo=\ngithub.com/jmespath/go-jmespath/internal/testify v1.5.1 h1:shLQSRRSCCPj3f2gpwzGwWFoC7ycTf1rcQZHOlsJ6N8=\ngithub.com/jmespath/go-jmespath/internal/testify v1.5.1/go.mod h1:L3OGu8Wl2/fWfCI6z80xFu9LTZmf1ZRjMHUOPmWr69U=\ngithub.com/johannesboyne/gofakes3 v0.0.0-20241026070602-0da3aa9c32ca h1:aLV7i5W7KKNHUwcmPZKDKXut6ZnJ8sdQWYDTKwhIzBU=\ngithub.com/johannesboyne/gofakes3 v0.0.0-20241026070602-0da3aa9c32ca/go.mod h1:t6osVdP++3g4v2awHz4+HFccij23BbdT1rX3W7IijqQ=\ngithub.com/klauspost/compress v1.17.11 h1:In6xLpyWOi1+C7tXUUWv2ot1QvBjxevKAaI6IXrJmUc=\ngithub.com/klauspost/compress v1.17.11/go.mod h1:pMDklpSncoRMuLFrf1W9Ss9KT+0rH90U12bZKk7uwG0=\ngithub.com/klauspost/cpuid/v2 v2.2.8 h1:+StwCXwm9PdpiEkPyzBXIy+M9KUb4ODm0Zarf1kS5BM=\ngithub.com/klauspost/cpuid/v2 v2.2.8/go.mod h1:Lcz8mBdAVJIBVzewtcLocK12l3Y+JytZYpaMropDUws=\ngithub.com/kr/pretty v0.3.1 h1:flRD4NNwYAUpkphVc1HcthR4KEIFJ65n8Mw5qdRn3LE=\ngithub.com/kr/pretty v0.3.1/go.mod h1:hoEshYVHaxMs3cyo3Yncou5ZscifuDolrwPKZanG3xk=\ngithub.com/kr/text v0.2.0 h1:5Nx0Ya0ZqY2ygV366QzturHI13Jq95ApcVaJBhpS+AY=\ngithub.com/kr/text v0.2.0/go.mod h1:eLer722TekiGuMkidMxC/pM04lWEeraHUUmBw8l2grE=\ngithub.com/kylelemons/godebug v1.1.0 h1:RPNrshWIDI6G2gRW9EHilWtl7Z6Sb1BR0xunSBf0SNc=\ngithub.com/kylelemons/godebug v1.1.0/go.mod h1:9/0rRGxNHcop5bhtWyNeEfOS8JIWk580+fNqagV/RAw=\ngithub.com/minio/md5-simd v1.1.2 h1:Gdi1DZK69+ZVMoNHRXJyNcxrMA4dSxoYHZSQbirFg34=\ngithub.com/minio/md5-simd v1.1.2/go.mod h1:MzdKDxYpY2BT9XQFocsiZf/NKVtR7nkE4RoEpN+20RM=\ngithub.com/minio/minio-go/v7 v7.0.78 h1:LqW2zy52fxnI4gg8C2oZviTaKHcBV36scS+RzJnxUFs=\ngithub.com/minio/minio-go/v7 v7.0.78/go.mod h1:84gmIilaX4zcvAWWzJ5Z1WI5axN+hAbM5w25xf8xvC0=\ngithub.com/munnerz/goautoneg v0.0.0-20191010083416-a7dc8b61c822 h1:C3w9PqII01/Oq1c1nUAm88MOHcQC9l5mIlSMApZMrHA=\ngithub.com/munnerz/goautoneg v0.0.0-20191010083416-a7dc8b61c822/go.mod h1:+n7T8mK8HuQTcFwEeznm/DIxMOiR9yIdICNftLE1DvQ=\ngithub.com/peterbourgon/ff/v3 v3.4.0 h1:QBvM/rizZM1cB0p0lGMdmR7HxZeI/ZrBWB4DqLkMUBc=\ngithub.com/peterbourgon/ff/v3 v3.4.0/go.mod h1:zjJVUhx+twciwfDl0zBcFzl4dW8axCRyXE/eKY9RztQ=\ngithub.com/pingcap/errors v0.11.4 h1:lFuQV/oaUMGcD2tqt+01ROSmJs75VG1ToEOkZIZ4nE4=\ngithub.com/pingcap/errors v0.11.4/go.mod h1:Oi8TUi2kEtXXLMJk9l1cGmz20kV3TaQ0usTwv5KuLY8=\ngithub.com/pkg/errors v0.9.1 h1:FEBLx1zS214owpjy7qsBeixbURkuhQAwrK5UwLGTwt4=\ngithub.com/pkg/errors v0.9.1/go.mod h1:bwawxfHBFNV+L2hUp1rHADufV3IMtnDRdf1r5NINEl0=\ngithub.com/pkg/xattr v0.4.10 h1:Qe0mtiNFHQZ296vRgUjRCoPHPqH7VdTOrZx3g0T+pGA=\ngithub.com/pkg/xattr v0.4.10/go.mod h1:di8WF84zAKk8jzR1UBTEWh9AUlIZZ7M/JNt8e9B6ktU=\ngithub.com/planetscale/vtprotobuf v0.6.1-0.20240319094008-0393e58bdf10 h1:GFCKgmp0tecUJ0sJuv4pzYCqS9+RGSn52M3FUwPs+uo=\ngithub.com/planetscale/vtprotobuf v0.6.1-0.20240319094008-0393e58bdf10/go.mod h1:t/avpk3KcrXxUnYOhZhMXJlSEyie6gQbtLq5NM3loB8=\ngithub.com/pmezard/go-difflib v1.0.0 h1:4DBwDE0NGyQoBHbLQYPwSUPoCMWR5BEzIk/f1lZbAQM=\ngithub.com/pmezard/go-difflib v1.0.0/go.mod h1:iKH77koFhYxTK1pcRnkKkqfTogsbg7gZNVY4sRDYZ/4=\ngithub.com/prometheus/client_golang v1.20.5 h1:cxppBPuYhUnsO6yo/aoRol4L7q7UFfdm+bR9r+8l63Y=\ngithub.com/prometheus/client_golang v1.20.5/go.mod h1:PIEt8X02hGcP8JWbeHyeZ53Y/jReSnHgO035n//V5WE=\ngithub.com/prometheus/client_model v0.0.0-20190812154241-14fe0d1b01d4/go.mod h1:xMI15A0UPsDsEKsMN9yxemIoYk6Tm2C1GtYGdfGttqA=\ngithub.com/prometheus/client_model v0.6.1 h1:ZKSh/rekM+n3CeS952MLRAdFwIKqeY8b62p8ais2e9E=\ngithub.com/prometheus/client_model v0.6.1/go.mod h1:OrxVMOVHjw3lKMa8+x6HeMGkHMQyHDk9E3jmP2AmGiY=\ngithub.com/prometheus/common v0.55.0 h1:KEi6DK7lXW/m7Ig5i47x0vRzuBsHuvJdi5ee6Y3G1dc=\ngithub.com/prometheus/common v0.55.0/go.mod h1:2SECS4xJG1kd8XF9IcM1gMX6510RAEL65zxzNImwdc8=\ngithub.com/prometheus/procfs v0.15.1 h1:YagwOFzUgYfKKHX6Dr+sHT7km/hxC76UB0learggepc=\ngithub.com/prometheus/procfs v0.15.1/go.mod h1:fB45yRUv8NstnjriLhBQLuOUt+WW4BsoGhij/e3PBqk=\ngithub.com/rogpeppe/go-internal v1.10.0 h1:TMyTOH3F/DB16zRVcYyreMH6GnZZrwQVAoYjRBZyWFQ=\ngithub.com/rogpeppe/go-internal v1.10.0/go.mod h1:UQnix2H7Ngw/k4C5ijL5+65zddjncjaFoBhdsK/akog=\ngithub.com/rs/cors v1.11.1 h1:eU3gRzXLRK57F5rKMGMZURNdIG4EoAmX8k94r9wXWHA=\ngithub.com/rs/cors v1.11.1/go.mod h1:XyqrcTp5zjWr1wsJ8PIRZssZ8b/WMcMf71DJnit4EMU=\ngithub.com/rs/xid v1.6.0 h1:fV591PaemRlL6JfRxGDEPl69wICngIQ3shQtzfy2gxU=\ngithub.com/rs/xid v1.6.0/go.mod h1:7XoLgs4eV+QndskICGsho+ADou8ySMSjJKDIan90Nz0=\ngithub.com/ryszard/goskiplist v0.0.0-20150312221310-2dfbae5fcf46 h1:GHRpF1pTW19a8tTFrMLUcfWwyC0pnifVo2ClaLq+hP8=\ngithub.com/ryszard/goskiplist v0.0.0-20150312221310-2dfbae5fcf46/go.mod h1:uAQ5PCi+MFsC7HjREoAz1BU+Mq60+05gifQSsHSDG/8=\ngithub.com/spf13/afero v1.2.1/go.mod h1:9ZxEEn6pIJ8Rxe320qSDBk6AsU0r9pR7Q4OcevTdifk=\ngithub.com/stretchr/objx v0.1.0/go.mod h1:HFkY916IF+rwdDfMAkV7OtwuqBVzrE8GR6GFx+wExME=\ngithub.com/stretchr/objx v0.4.0/go.mod h1:YvHI0jy2hoMjB+UWwv71VJQ9isScKT/TqJzVSSt89Yw=\ngithub.com/stretchr/objx v0.5.0/go.mod h1:Yh+to48EsGEfYuaHDzXPcE3xhTkx73EhmCGUpEOglKo=\ngithub.com/stretchr/testify v1.5.1/go.mod h1:5W2xD1RspED5o8YsWQXVCued0rvSQ+mT+I5cxcmMvtA=\ngithub.com/stretchr/testify v1.7.1/go.mod h1:6Fq8oRcR53rry900zMqJjRRixrwX3KX962/h/Wwjteg=\ngithub.com/stretchr/testify v1.8.0/go.mod h1:yNjHg4UonilssWZ8iaSj1OCr/vHnekPRkoO+kdMU+MU=\ngithub.com/stretchr/testify v1.8.1/go.mod h1:w2LPCIKwWwSfY2zedu0+kehJoqGctiVI29o6fzry7u4=\ngithub.com/stretchr/testify v1.10.0 h1:Xv5erBjTwe/5IxqUQTdXv5kgmIvbHo3QQyRwhJsOfJA=\ngithub.com/stretchr/testify v1.10.0/go.mod h1:r2ic/lqez/lEtzL7wO/rwa5dbSLXVDPFyf8C91i36aY=\ngithub.com/yuin/goldmark v1.4.13/go.mod h1:6yULJ656Px+3vBD8DxQVa3kxgyrAnzto9xy5taEt/CY=\ngo.einride.tech/aip v0.68.0 h1:4seM66oLzTpz50u4K1zlJyOXQ3tCzcJN7I22tKkjipw=\ngo.einride.tech/aip v0.68.0/go.mod h1:7y9FF8VtPWqpxuAxl0KQWqaULxW4zFIesD6zF5RIHHg=\ngo.etcd.io/bbolt v1.3.5/go.mod h1:G5EMThwa9y8QZGBClrRx5EY+Yw9kAhnjy3bSjsnlVTQ=\ngo.opencensus.io v0.24.0 h1:y73uSU6J157QMP2kn2r30vwW1A2W2WFwSCGnAVxeaD0=\ngo.opencensus.io v0.24.0/go.mod h1:vNK8G9p7aAivkbmorf4v+7Hgx+Zs0yY+0fOtgBfjQKo=\ngo.opentelemetry.io/contrib/detectors/gcp v1.29.0 h1:TiaiXB4DpGD3sdzNlYQxruQngn5Apwzi1X0DRhuGvDQ=\ngo.opentelemetry.io/contrib/detectors/gcp v1.29.0/go.mod h1:GW2aWZNwR2ZxDLdv8OyC2G8zkRoQBuURgV7RPQgcPoU=\ngo.opentelemetry.io/contrib/instrumentation/google.golang.org/grpc/otelgrpc v0.54.0 h1:r6I7RJCN86bpD/FQwedZ0vSixDpwuWREjW9oRMsmqDc=\ngo.opentelemetry.io/contrib/instrumentation/google.golang.org/grpc/otelgrpc v0.54.0/go.mod h1:B9yO6b04uB80CzjedvewuqDhxJxi11s7/GtiGa8bAjI=\ngo.opentelemetry.io/contrib/instrumentation/net/http/otelhttp v0.54.0 h1:TT4fX+nBOA/+LUkobKGW1ydGcn+G3vRw9+g5HwCphpk=\ngo.opentelemetry.io/contrib/instrumentation/net/http/otelhttp v0.54.0/go.mod h1:L7UH0GbB0p47T4Rri3uHjbpCFYrVrwc1I25QhNPiGK8=\ngo.opentelemetry.io/otel v1.29.0 h1:PdomN/Al4q/lN6iBJEN3AwPvUiHPMlt93c8bqTG5Llw=\ngo.opentelemetry.io/otel v1.29.0/go.mod h1:N/WtXPs1CNCUEx+Agz5uouwCba+i+bJGFicT8SR4NP8=\ngo.opentelemetry.io/otel/exporters/stdout/stdoutmetric v1.29.0 h1:WDdP9acbMYjbKIyJUhTvtzj601sVJOqgWdUxSdR/Ysc=\ngo.opentelemetry.io/otel/exporters/stdout/stdoutmetric v1.29.0/go.mod h1:BLbf7zbNIONBLPwvFnwNHGj4zge8uTCM/UPIVW1Mq2I=\ngo.opentelemetry.io/otel/metric v1.29.0 h1:vPf/HFWTNkPu1aYeIsc98l4ktOQaL6LeSoeV2g+8YLc=\ngo.opentelemetry.io/otel/metric v1.29.0/go.mod h1:auu/QWieFVWx+DmQOUMgj0F8LHWdgalxXqvp7BII/W8=\ngo.opentelemetry.io/otel/sdk v1.29.0 h1:vkqKjk7gwhS8VaWb0POZKmIEDimRCMsopNYnriHyryo=\ngo.opentelemetry.io/otel/sdk v1.29.0/go.mod h1:pM8Dx5WKnvxLCb+8lG1PRNIDxu9g9b9g59Qr7hfAAok=\ngo.opentelemetry.io/otel/sdk/metric v1.29.0 h1:K2CfmJohnRgvZ9UAj2/FhIf/okdWcNdBwe1m8xFXiSY=\ngo.opentelemetry.io/otel/sdk/metric v1.29.0/go.mod h1:6zZLdCl2fkauYoZIOn/soQIDSWFmNSRcICarHfuhNJQ=\ngo.opentelemetry.io/otel/trace v1.29.0 h1:J/8ZNK4XgR7a21DZUAsbF8pZ5Jcw1VhACmnYt39JTi4=\ngo.opentelemetry.io/otel/trace v1.29.0/go.mod h1:eHl3w0sp3paPkYstJOmAimxhiFXPg+MMTlEh3nsQgWQ=\ngo.shabbyrobe.org/gocovmerge v0.0.0-20230507111327-fa4f82cfbf4d h1:Ns9kd1Rwzw7t0BR8XMphenji4SmIoNZPn8zhYmaVKP8=\ngo.shabbyrobe.org/gocovmerge v0.0.0-20230507111327-fa4f82cfbf4d/go.mod h1:92Uoe3l++MlthCm+koNi0tcUCX3anayogF0Pa/sp24k=\ngo.uber.org/goleak v1.3.0 h1:2K3zAYmnTNqV73imy9J1T3WC+gmCePx2hEGkimedGto=\ngo.uber.org/goleak v1.3.0/go.mod h1:CoHD4mav9JJNrW/WLlf7HGZPjdw8EucARQHekz1X6bE=\ngo.uber.org/multierr v1.11.0 h1:blXXJkSxSSfBVBlC76pxqeO+LN3aDfLQo+309xJstO0=\ngo.uber.org/multierr v1.11.0/go.mod h1:20+QtiLqy0Nd6FdQB9TLXag12DsQkrbs3htMFfDN80Y=\ngo.uber.org/zap v1.27.0 h1:aJMhYGrd5QSmlpLMr2MftRKl7t8J8PTZPA732ud/XR8=\ngo.uber.org/zap v1.27.0/go.mod h1:GB2qFLM7cTU87MWRP2mPIjqfIDnGu+VIO4V/SdhGo2E=\ngolang.org/x/crypto v0.0.0-20190308221718-c2843e01d9a2/go.mod h1:djNgcEr1/C05ACkg1iLfiJU5Ep61QUkGW8qpdssI0+w=\ngolang.org/x/crypto v0.0.0-20200622213623-75b288015ac9/go.mod h1:LzIPMQfyMNhhGPhUkYOs5KpL4U8rLKemX1yGLhDgUto=\ngolang.org/x/crypto v0.0.0-20210921155107-089bfa567519/go.mod h1:GvvjBRRGRdwPK5ydBHafDWAxML/pGHZbMvKqRZ5+Abc=\ngolang.org/x/crypto v0.31.0 h1:ihbySMvVjLAeSH1IbfcRTkD/iNscyz8rGzjF/E5hV6U=\ngolang.org/x/crypto v0.31.0/go.mod h1:kDsLvtWBEx7MV9tJOj9bnXsPbxwJQ6csT/x4KIN4Ssk=\ngolang.org/x/exp v0.0.0-20190121172915-509febef88a4/go.mod h1:CJ0aWSM057203Lf6IL+f9T1iT9GByDxfZKAQTCR3kQA=\ngolang.org/x/image v0.23.0 h1:HseQ7c2OpPKTPVzNjG5fwJsOTCiiwS4QdsYi5XU6H68=\ngolang.org/x/image v0.23.0/go.mod h1:wJJBTdLfCCf3tiHa1fNxpZmUI4mmoZvwMCPP0ddoNKY=\ngolang.org/x/lint v0.0.0-20181026193005-c67002cb31c3/go.mod h1:UVdnD1Gm6xHRNCYTkRU2/jEulfH38KcIWyp/GAMgvoE=\ngolang.org/x/lint v0.0.0-20190227174305-5b3e6a55c961/go.mod h1:wehouNa3lNwaWXcvxsM5YxQ5yQlVC4a0KAMCusXpPoU=\ngolang.org/x/lint v0.0.0-20190313153728-d0100b6bd8b3/go.mod h1:6SW0HCj/g11FgYtHlgUYUwCkIfeOF89ocIRzGO/8vkc=\ngolang.org/x/mod v0.6.0-dev.0.20220419223038-86c51ed26bb4/go.mod h1:jJ57K6gSWd91VN4djpZkiMVwK6gcyfeH4XE8wZrZaV4=\ngolang.org/x/mod v0.8.0/go.mod h1:iBbtSCu2XBx23ZKBPSOrRkjjQPZFPuis4dIYUhu/chs=\ngolang.org/x/mod v0.10.0/go.mod h1:iBbtSCu2XBx23ZKBPSOrRkjjQPZFPuis4dIYUhu/chs=\ngolang.org/x/net v0.0.0-20180724234803-3673e40ba225/go.mod h1:mL1N/T3taQHkDXs73rZJwtUhF3w3ftmwwsq0BUmARs4=\ngolang.org/x/net v0.0.0-20180826012351-8a410e7b638d/go.mod h1:mL1N/T3taQHkDXs73rZJwtUhF3w3ftmwwsq0BUmARs4=\ngolang.org/x/net v0.0.0-20190213061140-3a22650c66bd/go.mod h1:mL1N/T3taQHkDXs73rZJwtUhF3w3ftmwwsq0BUmARs4=\ngolang.org/x/net v0.0.0-20190311183353-d8887717615a/go.mod h1:t9HGtf8HONx5eT2rtn7q6eTqICYqUVnKs3thJo3Qplg=\ngolang.org/x/net v0.0.0-20190404232315-eb5bcb51f2a3/go.mod h1:t9HGtf8HONx5eT2rtn7q6eTqICYqUVnKs3thJo3Qplg=\ngolang.org/x/net v0.0.0-20190620200207-3b0461eec859/go.mod h1:z5CRVTTTmAJ677TzLLGU+0bjPO0LkuOLi4/5GtJWs/s=\ngolang.org/x/net v0.0.0-20201110031124-69a78807bb2b/go.mod h1:sp8m0HH+o8qH0wwXwYZr8TS3Oi6o0r6Gce1SSxlDquU=\ngolang.org/x/net v0.0.0-20210226172049-e18ecbb05110/go.mod h1:m0MpNAwzfU5UDzcl9v0D8zg8gWTRqZa9RBIspLL5mdg=\ngolang.org/x/net v0.0.0-20220722155237-a158d28d115b/go.mod h1:XRhObCWvk6IyKnWLug+ECip1KBveYUHfp+8e9klMJ9c=\ngolang.org/x/net v0.1.0/go.mod h1:Cx3nUiGt4eDBEyega/BKRp+/AlGL8hYe7U9odMt2Cco=\ngolang.org/x/net v0.6.0/go.mod h1:2Tu9+aMcznHK/AK1HMvgo6xiTLG5rD5rZLDS+rp2Bjs=\ngolang.org/x/net v0.9.0/go.mod h1:d48xBJpPfHeWQsugry2m+kC02ZBRGRgulfHnEXEuWns=\ngolang.org/x/net v0.31.0 h1:68CPQngjLL0r2AlUKiSxtQFKvzRVbnzLwMUn5SzcLHo=\ngolang.org/x/net v0.31.0/go.mod h1:P4fl1q7dY2hnZFxEk4pPSkDHF+QqjitcnDjUQyMM+pM=\ngolang.org/x/oauth2 v0.0.0-20180821212333-d2e6202438be/go.mod h1:N/0e6XlmueqKjAGxoOufVs8QHGRruUQn6yWY3a++T0U=\ngolang.org/x/oauth2 v0.24.0 h1:KTBBxWqUa0ykRPLtV69rRto9TLXcqYkeswu48x/gvNE=\ngolang.org/x/oauth2 v0.24.0/go.mod h1:XYTD2NtWslqkgxebSiOHnXEap4TF09sJSc7H1sXbhtI=\ngolang.org/x/sync v0.0.0-20180314180146-1d60e4601c6f/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=\ngolang.org/x/sync v0.0.0-20181108010431-42b317875d0f/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=\ngolang.org/x/sync v0.0.0-20190423024810-112230192c58/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=\ngolang.org/x/sync v0.0.0-20220722155255-886fb9371eb4/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=\ngolang.org/x/sync v0.1.0/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=\ngolang.org/x/sync v0.10.0 h1:3NQrjDixjgGwUOCaF8w2+VYHv0Ve/vGYSbdkTa98gmQ=\ngolang.org/x/sync v0.10.0/go.mod h1:Czt+wKu1gCyEFDUtn0jG5QVvpJ6rzVqr5aXyt9drQfk=\ngolang.org/x/sys v0.0.0-20180830151530-49385e6e1522/go.mod h1:STP8DvDyc/dI5b8T5hshtkjS+E42TnysNCUPdjciGhY=\ngolang.org/x/sys v0.0.0-20190215142949-d0b11bdaac8a/go.mod h1:STP8DvDyc/dI5b8T5hshtkjS+E42TnysNCUPdjciGhY=\ngolang.org/x/sys v0.0.0-20190412213103-97732733099d/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20200202164722-d101bd2416d5/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20200930185726-fdedc70b468f/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20201119102817-f84b799fce68/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20210615035016-665e8c7367d1/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\ngolang.org/x/sys v0.0.0-20220408201424-a24fb2fb8a0f/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\ngolang.org/x/sys v0.0.0-20220520151302-bc2c85ada10a/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\ngolang.org/x/sys v0.0.0-20220722155257-8c9f86f7a55f/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\ngolang.org/x/sys v0.1.0/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\ngolang.org/x/sys v0.5.0/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\ngolang.org/x/sys v0.7.0/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\ngolang.org/x/sys v0.28.0 h1:Fksou7UEQUWlKvIdsqzJmUmCX3cZuD2+P3XyyzwMhlA=\ngolang.org/x/sys v0.28.0/go.mod h1:/VUhepiaJMQUp4+oa/7Zr1D23ma6VTLIYjOOTFZPUcA=\ngolang.org/x/term v0.0.0-20201126162022-7de9c90e9dd1/go.mod h1:bj7SfCRtBDWHUb9snDiAeCFNEtKQo2Wmx5Cou7ajbmo=\ngolang.org/x/term v0.0.0-20210927222741-03fcf44c2211/go.mod h1:jbD1KX2456YbFQfuXm/mYQcufACuNUgVhRMnK/tPxf8=\ngolang.org/x/term v0.1.0/go.mod h1:jbD1KX2456YbFQfuXm/mYQcufACuNUgVhRMnK/tPxf8=\ngolang.org/x/term v0.5.0/go.mod h1:jMB1sMXY+tzblOD4FWmEbocvup2/aLOaQEp7JmGp78k=\ngolang.org/x/term v0.7.0/go.mod h1:P32HKFT3hSsZrRxla30E9HqToFYAQPCMs/zFMBUFqPY=\ngolang.org/x/text v0.3.0/go.mod h1:NqM8EUOU14njkJ3fqMW+pc6Ldnwhi/IjpwHt7yyuwOQ=\ngolang.org/x/text v0.3.3/go.mod h1:5Zoc/QRtKVWzQhOtBMvqHzDpF6irO9z98xDceosuGiQ=\ngolang.org/x/text v0.3.7/go.mod h1:u+2+/6zg+i71rQMx5EYifcz6MCKuco9NR6JIITiCfzQ=\ngolang.org/x/text v0.4.0/go.mod h1:mrYo+phRRbMaCq/xk9113O4dZlRixOauAjOtrjsXDZ8=\ngolang.org/x/text v0.7.0/go.mod h1:mrYo+phRRbMaCq/xk9113O4dZlRixOauAjOtrjsXDZ8=\ngolang.org/x/text v0.9.0/go.mod h1:e1OnstbJyHTd6l/uOt8jFFHp6TRDWZR/bV3emEE/zU8=\ngolang.org/x/text v0.21.0 h1:zyQAAkrwaneQ066sspRyJaG9VNi/YJ1NfzcGB3hZ/qo=\ngolang.org/x/text v0.21.0/go.mod h1:4IBbMaMmOPCJ8SecivzSH54+73PCFmPWxNTLm+vZkEQ=\ngolang.org/x/time v0.8.0 h1:9i3RxcPv3PZnitoVGMPDKZSq1xW1gK1Xy3ArNOGZfEg=\ngolang.org/x/time v0.8.0/go.mod h1:3BpzKBy/shNhVucY/MWOyx10tF3SFh9QdLuxbVysPQM=\ngolang.org/x/tools v0.0.0-20180917221912-90fa682c2a6e/go.mod h1:n7NCudcB/nEzxVGmLbDWY5pfWTLqBcC2KZ6jyYvM4mQ=\ngolang.org/x/tools v0.0.0-20190114222345-bf090417da8b/go.mod h1:n7NCudcB/nEzxVGmLbDWY5pfWTLqBcC2KZ6jyYvM4mQ=\ngolang.org/x/tools v0.0.0-20190226205152-f727befe758c/go.mod h1:9Yl7xja0Znq3iFh3HoIrodX9oNMXvdceNzlUR8zjMvY=\ngolang.org/x/tools v0.0.0-20190311212946-11955173bddd/go.mod h1:LCzVGOaR6xXOjkQ3onu1FJEFr0SW1gC7cKk1uF8kGRs=\ngolang.org/x/tools v0.0.0-20190524140312-2c0ae7006135/go.mod h1:RgjU9mgBXZiqYHBnxXauZ1Gv1EHHAz9KjViQ78xBX0Q=\ngolang.org/x/tools v0.0.0-20190829051458-42f498d34c4d/go.mod h1:b+2E5dAYhXwXZwtnZ6UAqBI28+e2cm9otk0dWdXHAEo=\ngolang.org/x/tools v0.0.0-20191119224855-298f0cb1881e/go.mod h1:b+2E5dAYhXwXZwtnZ6UAqBI28+e2cm9otk0dWdXHAEo=\ngolang.org/x/tools v0.1.12/go.mod h1:hNGJHUnrk76NpqgfD5Aqm5Crs+Hm0VOH/i9J2+nxYbc=\ngolang.org/x/tools v0.6.0/go.mod h1:Xwgl3UAJ/d3gWutnCtw505GrjyAbvKui8lOU390QaIU=\ngolang.org/x/tools v0.8.0/go.mod h1:JxBZ99ISMI5ViVkT1tr6tdNmXeTrcpVSD3vZ1RsRdN4=\ngolang.org/x/tools v0.21.1-0.20240508182429-e35e4ccd0d2d h1:vU5i/LfpvrRCpgM/VPfJLg5KjxD3E+hfT1SH+d9zLwg=\ngolang.org/x/tools v0.21.1-0.20240508182429-e35e4ccd0d2d/go.mod h1:aiJjzUbINMkxbQROHiO6hDPo2LHcIPhhQsa9DLh0yGk=\ngolang.org/x/xerrors v0.0.0-20190717185122-a985d3407aa7/go.mod h1:I/5z698sn9Ka8TeJc9MKroUUfqBBauWjQqLJ2OPfmY0=\ngolang.org/x/xerrors v0.0.0-20191204190536-9bdfabe68543/go.mod h1:I/5z698sn9Ka8TeJc9MKroUUfqBBauWjQqLJ2OPfmY0=\ngoogle.golang.org/api v0.210.0 h1:HMNffZ57OoZCRYSbdWVRoqOa8V8NIHLL0CzdBPLztWk=\ngoogle.golang.org/api v0.210.0/go.mod h1:B9XDZGnx2NtyjzVkOVTGrFSAVZgPcbedzKg/gTLwqBs=\ngoogle.golang.org/appengine v1.1.0/go.mod h1:EbEs0AVv82hx2wNQdGPgUI5lhzA/G0D9YwlJXL52JkM=\ngoogle.golang.org/appengine v1.4.0/go.mod h1:xpcJRLb0r/rnEns0DIKYYv+WjYCduHsrkT7/EB5XEv4=\ngoogle.golang.org/genproto v0.0.0-20180817151627-c66870c02cf8/go.mod h1:JiN7NxoALGmiZfu7CAH4rXhgtRTLTxftemlI0sWmxmc=\ngoogle.golang.org/genproto v0.0.0-20190819201941-24fa4b261c55/go.mod h1:DMBHOl98Agz4BDEuKkezgsaosCRResVns1a3J2ZsMNc=\ngoogle.golang.org/genproto v0.0.0-20200526211855-cb27e3aa2013/go.mod h1:NbSheEEYHJ7i3ixzK3sjbqSGDJWnxyFXZblF3eUsNvo=\ngoogle.golang.org/genproto v0.0.0-20241118233622-e639e219e697 h1:ToEetK57OidYuqD4Q5w+vfEnPvPpuTwedCNVohYJfNk=\ngoogle.golang.org/genproto v0.0.0-20241118233622-e639e219e697/go.mod h1:JJrvXBWRZaFMxBufik1a4RpFw4HhgVtBBWQeQgUj2cc=\ngoogle.golang.org/genproto/googleapis/api v0.0.0-20241113202542-65e8d215514f h1:M65LEviCfuZTfrfzwwEoxVtgvfkFkBUbFnRbxCXuXhU=\ngoogle.golang.org/genproto/googleapis/api v0.0.0-20241113202542-65e8d215514f/go.mod h1:Yo94eF2nj7igQt+TiJ49KxjIH8ndLYPZMIRSiRcEbg0=\ngoogle.golang.org/genproto/googleapis/rpc v0.0.0-20241118233622-e639e219e697 h1:LWZqQOEjDyONlF1H6afSWpAL/znlREo2tHfLoe+8LMA=\ngoogle.golang.org/genproto/googleapis/rpc v0.0.0-20241118233622-e639e219e697/go.mod h1:5uTbfoYQed2U9p3KIj2/Zzm02PYhndfdmML0qC3q3FU=\ngoogle.golang.org/grpc v1.19.0/go.mod h1:mqu4LbDTu4XGKhr4mRzUsmM4RtVoemTSY81AxZiDr8c=\ngoogle.golang.org/grpc v1.23.0/go.mod h1:Y5yQAOtifL1yxbo5wqy6BxZv8vAUGQwXBOALyacEbxg=\ngoogle.golang.org/grpc v1.25.1/go.mod h1:c3i+UQWmh7LiEpx4sFZnkU36qjEYZ0imhYfXVyQciAY=\ngoogle.golang.org/grpc v1.27.0/go.mod h1:qbnxyOmOxrQa7FizSgH+ReBfzJrCY1pSN7KXBS8abTk=\ngoogle.golang.org/grpc v1.33.2/go.mod h1:JMHMWHQWaTccqQQlmk3MJZS+GWXOdAesneDmEnv2fbc=\ngoogle.golang.org/grpc v1.67.2 h1:Lq11HW1nr5m4OYV+ZVy2BjOK78/zqnTx24vyDBP1JcQ=\ngoogle.golang.org/grpc v1.67.2/go.mod h1:1gLDyUQU7CTLJI90u3nXZ9ekeghjeM7pTDZlqFNg2AA=\ngoogle.golang.org/grpc/stats/opentelemetry v0.0.0-20240907200651-3ffb98b2c93a h1:UIpYSuWdWHSzjwcAFRLjKcPXFZVVLXGEM23W+NWqipw=\ngoogle.golang.org/grpc/stats/opentelemetry v0.0.0-20240907200651-3ffb98b2c93a/go.mod h1:9i1T9n4ZinTUZGgzENMi8MDDgbGC5mqTS75JAv6xN3A=\ngoogle.golang.org/protobuf v0.0.0-20200109180630-ec00e32a8dfd/go.mod h1:DFci5gLYBciE7Vtevhsrf46CRTquxDuWsQurQQe4oz8=\ngoogle.golang.org/protobuf v0.0.0-20200221191635-4d8936d0db64/go.mod h1:kwYJMbMJ01Woi6D6+Kah6886xMZcty6N08ah7+eCXa0=\ngoogle.golang.org/protobuf v0.0.0-20200228230310-ab0ca4ff8a60/go.mod h1:cfTl7dwQJ+fmap5saPgwCLgHXTUD7jkjRqWcaiX5VyM=\ngoogle.golang.org/protobuf v1.20.1-0.20200309200217-e05f789c0967/go.mod h1:A+miEFZTKqfCUM6K7xSMQL9OKL/b6hQv+e19PK+JZNE=\ngoogle.golang.org/protobuf v1.21.0/go.mod h1:47Nbq4nVaFHyn7ilMalzfO3qCViNmqZ2kzikPIcrTAo=\ngoogle.golang.org/protobuf v1.22.0/go.mod h1:EGpADcykh3NcUnDUJcl1+ZksZNG86OlYog2l/sGQquU=\ngoogle.golang.org/protobuf v1.23.0/go.mod h1:EGpADcykh3NcUnDUJcl1+ZksZNG86OlYog2l/sGQquU=\ngoogle.golang.org/protobuf v1.23.1-0.20200526195155-81db48ad09cc/go.mod h1:EGpADcykh3NcUnDUJcl1+ZksZNG86OlYog2l/sGQquU=\ngoogle.golang.org/protobuf v1.25.0/go.mod h1:9JNX74DMeImyA3h4bdi1ymwjUzf21/xIlbajtzgsN7c=\ngoogle.golang.org/protobuf v1.35.2 h1:8Ar7bF+apOIoThw1EdZl0p1oWvMqTHmpA2fRTyZO8io=\ngoogle.golang.org/protobuf v1.35.2/go.mod h1:9fA7Ob0pmnwhb644+1+CVWFRbNajQ6iRojtC/QF5bRE=\ngopkg.in/check.v1 v0.0.0-20161208181325-20d25e280405/go.mod h1:Co6ibVJAznAaIkqp8huTwlJQCZ016jof/cbN4VW5Yz0=\ngopkg.in/check.v1 v1.0.0-20201130134442-10cb98267c6c h1:Hei/4ADfdWqJk1ZMxUNpqntNwaWcugrBjAiHlqqRiVk=\ngopkg.in/check.v1 v1.0.0-20201130134442-10cb98267c6c/go.mod h1:JHkPIbrfpd72SG/EVd6muEfDQjcINNoR0C8j2r3qZ4Q=\ngopkg.in/mgo.v2 v2.0.0-20180705113604-9856a29383ce/go.mod h1:yeKp02qBN3iKW1OzL3MGk2IdtZzaj7SFntXj72NppTA=\ngopkg.in/yaml.v2 v2.2.2/go.mod h1:hI93XBmqTisBFMUTm0b8Fm+jr3Dg1NNxqwp+5A1VGuI=\ngopkg.in/yaml.v2 v2.2.8/go.mod h1:hI93XBmqTisBFMUTm0b8Fm+jr3Dg1NNxqwp+5A1VGuI=\ngopkg.in/yaml.v2 v2.4.0 h1:D8xgwECY7CYvx+Y2n4sBz93Jn9JRvxdiyyo8CTfuKaY=\ngopkg.in/yaml.v2 v2.4.0/go.mod h1:RDklbk79AGWmwhnvt/jBztapEOGDOx6ZbXqjP6csGnQ=\ngopkg.in/yaml.v3 v3.0.0-20200313102051-9f266ea9e77c/go.mod h1:K4uyk7z7BCEPqu6E+C64Yfv1cQ7kz7rIZviUmN+EgEM=\ngopkg.in/yaml.v3 v3.0.1 h1:fxVm/GzAzEWqLHuvctI91KS9hhNmmWOoWu0XTYJS7CA=\ngopkg.in/yaml.v3 v3.0.1/go.mod h1:K4uyk7z7BCEPqu6E+C64Yfv1cQ7kz7rIZviUmN+EgEM=\nhonnef.co/go/tools v0.0.0-20190102054323-c2f93a96b099/go.mod h1:rf3lG4BRIbNafJWhAfAdb/ePZxsR/4RtNHQocxwk9r4=\nhonnef.co/go/tools v0.0.0-20190523083050-ea95bdfd59fc/go.mod h1:rf3lG4BRIbNafJWhAfAdb/ePZxsR/4RtNHQocxwk9r4=\n"
        },
        {
          "name": "heroku.yml",
          "type": "blob",
          "size": 0.0419921875,
          "content": "build:\n  docker:\n    web: heroku/Dockerfile"
        },
        {
          "name": "heroku",
          "type": "tree",
          "content": null
        },
        {
          "name": "imagor.go",
          "type": "blob",
          "size": 21.650390625,
          "content": "package imagor\n\nimport (\n\t\"context\"\n\t\"encoding/json\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"net/http\"\n\t\"net/url\"\n\t\"path/filepath\"\n\t\"reflect\"\n\t\"strconv\"\n\t\"strings\"\n\t\"sync\"\n\t\"time\"\n\n\t\"github.com/cshum/imagor/imagorpath\"\n\t\"go.uber.org/zap\"\n\t\"golang.org/x/sync/semaphore\"\n\t\"golang.org/x/sync/singleflight\"\n)\n\n// Version imagor version\nconst Version = \"1.4.16\"\n\n// Loader image loader interface\ntype Loader interface {\n\tGet(r *http.Request, key string) (*Blob, error)\n}\n\n// Storage image storage interface\ntype Storage interface {\n\t// Get data Blob by key\n\tGet(r *http.Request, key string) (*Blob, error)\n\n\t// Stat get Blob Stat by key\n\tStat(ctx context.Context, key string) (*Stat, error)\n\n\t// Put data Blob by key\n\tPut(ctx context.Context, key string, blob *Blob) error\n\n\t// Delete delete data Blob by key\n\tDelete(ctx context.Context, key string) error\n}\n\n// LoadFunc function handler for Processor to call loader\ntype LoadFunc func(string) (*Blob, error)\n\n// Processor process image buffer\ntype Processor interface {\n\t// Startup processor startup lifecycle,\n\t// called only once for the application lifetime\n\tStartup(ctx context.Context) error\n\n\t// Process Blob with given params and loader function\n\tProcess(ctx context.Context, blob *Blob, params imagorpath.Params, load LoadFunc) (*Blob, error)\n\n\t// Shutdown processor shutdown lifecycle,\n\t// called only once for the application lifetime\n\tShutdown(ctx context.Context) error\n}\n\n// Imagor main application\ntype Imagor struct {\n\tUnsafe                 bool\n\tSigner                 imagorpath.Signer\n\tStoragePathStyle       imagorpath.StorageHasher\n\tResultStoragePathStyle imagorpath.ResultStorageHasher\n\tBasePathRedirect       string\n\tLoaders                []Loader\n\tStorages               []Storage\n\tResultStorages         []Storage\n\tProcessors             []Processor\n\tRequestTimeout         time.Duration\n\tLoadTimeout            time.Duration\n\tSaveTimeout            time.Duration\n\tProcessTimeout         time.Duration\n\tCacheHeaderTTL         time.Duration\n\tCacheHeaderSWR         time.Duration\n\tProcessConcurrency     int64\n\tProcessQueueSize       int64\n\tAutoWebP               bool\n\tAutoAVIF               bool\n\tModifiedTimeCheck      bool\n\tDisableErrorBody       bool\n\tDisableParamsEndpoint  bool\n\tBaseParams             string\n\tLogger                 *zap.Logger\n\tDebug                  bool\n\n\tg          singleflight.Group\n\tsema       *semaphore.Weighted\n\tqueueSema  *semaphore.Weighted\n\tbaseParams imagorpath.Params\n}\n\n// New create new Imagor\nfunc New(options ...Option) *Imagor {\n\tapp := &Imagor{\n\t\tLogger:         zap.NewNop(),\n\t\tRequestTimeout: time.Second * 30,\n\t\tLoadTimeout:    time.Second * 20,\n\t\tSaveTimeout:    time.Second * 20,\n\t\tProcessTimeout: time.Second * 20,\n\t\tCacheHeaderTTL: time.Hour * 24 * 7,\n\t\tCacheHeaderSWR: time.Hour * 24,\n\t}\n\tfor _, option := range options {\n\t\toption(app)\n\t}\n\tif app.ProcessConcurrency > 0 {\n\t\tapp.sema = semaphore.NewWeighted(app.ProcessConcurrency)\n\t\tapp.queueSema = semaphore.NewWeighted(app.ProcessQueueSize + app.ProcessConcurrency)\n\t}\n\tif app.Debug {\n\t\tapp.debugLog()\n\t}\n\tif app.Signer == nil {\n\t\tapp.Signer = imagorpath.NewDefaultSigner(\"\")\n\t}\n\tapp.BaseParams = strings.TrimSpace(app.BaseParams)\n\tif app.BaseParams != \"\" {\n\t\tapp.BaseParams = strings.TrimSuffix(app.BaseParams, \"/\") + \"/\"\n\t}\n\treturn app\n}\n\n// Startup Imagor startup lifecycle\nfunc (app *Imagor) Startup(ctx context.Context) (err error) {\n\tfor _, processor := range app.Processors {\n\t\tif err = processor.Startup(ctx); err != nil {\n\t\t\treturn\n\t\t}\n\t}\n\treturn\n}\n\n// Shutdown Imagor shutdown lifecycle\nfunc (app *Imagor) Shutdown(ctx context.Context) (err error) {\n\tfor _, processor := range app.Processors {\n\t\tif err = processor.Shutdown(ctx); err != nil {\n\t\t\treturn\n\t\t}\n\t}\n\treturn\n}\n\n// ServeHTTP implements http.Handler for imagor operations\nfunc (app *Imagor) ServeHTTP(w http.ResponseWriter, r *http.Request) {\n\tif r.Method != http.MethodGet && r.Method != http.MethodHead {\n\t\tw.WriteHeader(http.StatusMethodNotAllowed)\n\t\treturn\n\t}\n\tpath := r.URL.EscapedPath()\n\tif path == \"/\" || path == \"\" {\n\t\tif app.BasePathRedirect == \"\" {\n\t\t\tw.Header().Set(\"Content-Type\", \"text/html\")\n\t\t\t_, _ = w.Write([]byte(landing))\n\t\t} else {\n\t\t\thttp.Redirect(w, r, app.BasePathRedirect, http.StatusTemporaryRedirect)\n\t\t}\n\t\treturn\n\t}\n\tp := imagorpath.Parse(path)\n\tif p.Params {\n\t\tif !app.DisableParamsEndpoint {\n\t\t\twriteJSONIndent(w, r, p)\n\t\t}\n\t\treturn\n\t}\n\tblob, err := checkBlob(app.Do(r, p))\n\tif err == ErrInvalid || err == ErrSignatureMismatch {\n\t\tif path2, e := url.QueryUnescape(path); e == nil {\n\t\t\tpath = path2\n\t\t\tp = imagorpath.Parse(path)\n\t\t\tblob, err = checkBlob(app.Do(r, p))\n\t\t}\n\t}\n\tif err != nil {\n\t\tif errors.Is(err, context.Canceled) {\n\t\t\tw.WriteHeader(499)\n\t\t\treturn\n\t\t}\n\t\te := WrapError(err)\n\t\tif app.DisableErrorBody {\n\t\t\tw.WriteHeader(e.Code)\n\t\t\treturn\n\t\t}\n\t\tw.WriteHeader(e.Code)\n\t\twriteJSON(w, r, e)\n\t\treturn\n\t}\n\tif isBlobEmpty(blob) {\n\t\treturn\n\t}\n\tw.Header().Set(\"Content-Type\", blob.ContentType())\n\tw.Header().Set(\"Content-Disposition\", getContentDisposition(p, blob))\n\tsetCacheHeaders(w, r, getTtl(p, app.CacheHeaderTTL), app.CacheHeaderSWR)\n\tif r.Header.Get(\"Imagor-Auto-Format\") != \"\" {\n\t\tw.Header().Add(\"Vary\", \"Accept\")\n\t}\n\tif r.Header.Get(\"Imagor-Raw\") != \"\" {\n\t\tw.Header().Set(\"Content-Security-Policy\", \"script-src 'none'\")\n\t}\n\tif h := blob.Header; h != nil {\n\t\tfor key := range h {\n\t\t\tw.Header().Set(key, h.Get(key))\n\t\t}\n\t}\n\tif checkStatNotModified(w, r, blob.Stat) {\n\t\tw.WriteHeader(http.StatusNotModified)\n\t\treturn\n\t}\n\treader, size, _ := blob.NewReader()\n\twriteBody(w, r, reader, size)\n\treturn\n}\n\n// Serve serves imagor by context and params\nfunc (app *Imagor) Serve(ctx context.Context, p imagorpath.Params) (*Blob, error) {\n\tr, err := http.NewRequestWithContext(ctx, http.MethodGet, \"\", nil)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tp.Path = \"\" // make sure path generated\n\treturn app.Do(r, p)\n}\n\n// ServeBlob serves imagor Blob with context and params, skipping loader and storages\nfunc (app *Imagor) ServeBlob(\n\tctx context.Context, blob *Blob, p imagorpath.Params,\n) (*Blob, error) {\n\tif ctx == nil || blob == nil {\n\t\treturn nil, errors.New(\"imagor: nil context blob\")\n\t}\n\tctx = withContext(ctx)\n\tmustContextRef(ctx).Blob = blob\n\tp.Image = \"\" // make sure blob is used\n\treturn app.Serve(ctx, p)\n}\n\n// Do executes imagor operations\nfunc (app *Imagor) Do(r *http.Request, p imagorpath.Params) (blob *Blob, err error) {\n\tvar ctx = withContext(r.Context())\n\tvar cancel func()\n\tif app.RequestTimeout > 0 {\n\t\tctx, cancel = context.WithTimeout(ctx, app.RequestTimeout)\n\t\tcontextDefer(ctx, cancel)\n\t\tr = r.WithContext(ctx)\n\t}\n\tif !(app.Unsafe && p.Unsafe) && app.Signer != nil && p.Path != \"\" {\n\t\tif hash := app.Signer.Sign(p.Path); hash != p.Hash {\n\t\t\terr = ErrSignatureMismatch\n\t\t\tif app.Debug {\n\t\t\t\tapp.Logger.Debug(\"sign-mismatch\", zap.Any(\"params\", p), zap.String(\"expected\", hash))\n\t\t\t}\n\t\t\treturn\n\t\t}\n\t}\n\tvar isPathChanged bool\n\tif app.BaseParams != \"\" {\n\t\tp = imagorpath.Apply(p, app.BaseParams)\n\t\tisPathChanged = true\n\t}\n\tvar hasFormat, hasPreview, isRaw bool\n\tvar filters = p.Filters\n\tp.Filters = nil\n\tfor _, f := range filters {\n\t\tswitch f.Name {\n\t\tcase \"expire\":\n\t\t\t// expire(timestamp) filter\n\t\t\tif ts, e := strconv.ParseInt(f.Args, 10, 64); e == nil {\n\t\t\t\tif exp := time.UnixMilli(ts); !exp.IsZero() && time.Now().After(exp) {\n\t\t\t\t\terr = ErrExpired\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tr.Header.Set(\"Cache-Control\", \"private\")\n\t\t\t}\n\t\tcase \"format\":\n\t\t\thasFormat = true\n\t\tcase \"raw\":\n\t\t\tr.Header.Set(\"Imagor-Raw\", \"1\")\n\t\t\tisRaw = true\n\t\tcase \"preview\":\n\t\t\tr.Header.Set(\"Cache-Control\", \"no-cache\")\n\t\t\thasPreview = true // disable result storage on preview() filter\n\t\t}\n\t\t// exclude utility filters from result path\n\t\tswitch f.Name {\n\t\tcase \"expire\", \"attachment\":\n\t\t\tisPathChanged = true\n\t\tdefault:\n\t\t\tp.Filters = append(p.Filters, f)\n\t\t}\n\t}\n\t// auto WebP / AVIF\n\tif !hasFormat && (app.AutoWebP || app.AutoAVIF) {\n\t\taccept := r.Header.Get(\"Accept\")\n\t\tif app.AutoAVIF && strings.Contains(accept, \"image/avif\") {\n\t\t\tp.Filters = append(p.Filters, imagorpath.Filter{\n\t\t\t\tName: \"format\",\n\t\t\t\tArgs: \"avif\",\n\t\t\t})\n\t\t\tr.Header.Set(\"Imagor-Auto-Format\", \"avif\") // response Vary: Accept header\n\t\t\tisPathChanged = true\n\t\t} else if app.AutoWebP && strings.Contains(accept, \"image/webp\") {\n\t\t\tp.Filters = append(p.Filters, imagorpath.Filter{\n\t\t\t\tName: \"format\",\n\t\t\t\tArgs: \"webp\",\n\t\t\t})\n\t\t\tr.Header.Set(\"Imagor-Auto-Format\", \"webp\") // response Vary: Accept header\n\t\t\tisPathChanged = true\n\t\t}\n\t}\n\tif isPathChanged || p.Path == \"\" {\n\t\tp.Path = imagorpath.GeneratePath(p)\n\t}\n\tif p.Width < 0 {\n\t\tp.Width = -p.Width\n\t\tp.HFlip = !p.HFlip\n\t}\n\tif p.Height < 0 {\n\t\tp.Height = -p.Height\n\t\tp.VFlip = !p.VFlip\n\t}\n\tvar resultKey string\n\tif p.Image != \"\" && !hasPreview {\n\t\tif app.ResultStoragePathStyle != nil {\n\t\t\tresultKey = app.ResultStoragePathStyle.HashResult(p)\n\t\t} else {\n\t\t\tresultKey = p.Path\n\t\t}\n\t}\n\tload := func(image string) (*Blob, error) {\n\t\tblob, _, err := app.loadStorage(r, image)\n\t\treturn blob, err\n\t}\n\treturn app.suppress(ctx, resultKey, func(ctx context.Context, cb func(*Blob, error)) (*Blob, error) {\n\t\tif resultKey != \"\" && !isRaw {\n\t\t\tif blob := app.loadResult(r, resultKey, p.Image); blob != nil {\n\t\t\t\treturn blob, nil\n\t\t\t}\n\t\t}\n\t\tif app.queueSema != nil && !isRaw {\n\t\t\tif !app.queueSema.TryAcquire(1) {\n\t\t\t\terr = ErrTooManyRequests\n\t\t\t\tif app.Debug {\n\t\t\t\t\tapp.Logger.Debug(\"queue-acquire\", zap.Error(err))\n\t\t\t\t}\n\t\t\t\treturn blob, err\n\t\t\t}\n\t\t\tdefer app.queueSema.Release(1)\n\t\t}\n\t\tif app.sema != nil && !isRaw {\n\t\t\tif err = app.sema.Acquire(ctx, 1); err != nil {\n\t\t\t\tif app.Debug {\n\t\t\t\t\tapp.Logger.Debug(\"acquire\", zap.Error(err))\n\t\t\t\t}\n\t\t\t\treturn blob, err\n\t\t\t}\n\t\t\tdefer app.sema.Release(1)\n\t\t}\n\t\tvar shouldSave bool\n\t\tif blob, shouldSave, err = app.loadStorage(r, p.Image); err != nil {\n\t\t\tif app.Debug {\n\t\t\t\tapp.Logger.Debug(\"load\", zap.Any(\"params\", p), zap.Error(err))\n\t\t\t}\n\t\t\treturn blob, err\n\t\t}\n\t\tvar doneSave chan struct{}\n\t\tif shouldSave {\n\t\t\tdoneSave = make(chan struct{})\n\t\t\tvar storageKey = p.Image\n\t\t\tif app.StoragePathStyle != nil {\n\t\t\t\tstorageKey = app.StoragePathStyle.Hash(p.Image)\n\t\t\t}\n\t\t\tgo func(blob *Blob) {\n\t\t\t\tapp.save(ctx, app.Storages, storageKey, blob)\n\t\t\t\tclose(doneSave)\n\t\t\t}(blob)\n\t\t}\n\t\tif isBlobEmpty(blob) {\n\t\t\treturn blob, err\n\t\t}\n\t\tif !isRaw {\n\t\t\tvar cancel func()\n\t\t\tif app.ProcessTimeout > 0 {\n\t\t\t\tctx, cancel = context.WithTimeout(ctx, app.ProcessTimeout)\n\t\t\t\tcontextDefer(ctx, cancel)\n\t\t\t}\n\t\t\tvar forwardP = p\n\t\t\tfor _, processor := range app.Processors {\n\t\t\t\tb, e := checkBlob(processor.Process(ctx, blob, forwardP, load))\n\t\t\t\tif !isBlobEmpty(b) {\n\t\t\t\t\tif blob != nil && blob.Header != nil && b.Header == nil {\n\t\t\t\t\t\tb.Header = blob.Header // forward blob Header\n\t\t\t\t\t}\n\t\t\t\t\tblob = b // forward Blob to next processor if exists\n\t\t\t\t}\n\t\t\t\tif e == nil {\n\t\t\t\t\tblob = b\n\t\t\t\t\terr = nil\n\t\t\t\t\tif app.Debug {\n\t\t\t\t\t\tapp.Logger.Debug(\"processed\", zap.Any(\"params\", forwardP))\n\t\t\t\t\t}\n\t\t\t\t\tbreak\n\t\t\t\t} else if forward, ok := e.(ErrForward); ok {\n\t\t\t\t\terr = e\n\t\t\t\t\tforwardP = forward.Params\n\t\t\t\t\tif app.Debug {\n\t\t\t\t\t\tapp.Logger.Debug(\"forward\", zap.Any(\"params\", forwardP))\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif ctx.Err() == nil {\n\t\t\t\t\t\terr = e\n\t\t\t\t\t\tapp.Logger.Warn(\"process\", zap.Any(\"params\", p), zap.Error(err))\n\t\t\t\t\t} else {\n\t\t\t\t\t\terr = ctx.Err()\n\t\t\t\t\t}\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif shouldSave {\n\t\t\t// make sure storage saved before response and result storage\n\t\t\t<-doneSave\n\t\t}\n\t\tcb(blob, err)\n\t\tctx = detachContext(ctx)\n\t\tif err == nil && !isBlobEmpty(blob) && resultKey != \"\" && !isRaw &&\n\t\t\tlen(app.ResultStorages) > 0 {\n\t\t\tapp.save(ctx, app.ResultStorages, resultKey, blob)\n\t\t}\n\t\tif err != nil && shouldSave {\n\t\t\tvar storageKey = p.Image\n\t\t\tif app.StoragePathStyle != nil {\n\t\t\t\tstorageKey = app.StoragePathStyle.Hash(p.Image)\n\t\t\t}\n\t\t\tapp.del(ctx, app.Storages, storageKey)\n\t\t}\n\t\treturn blob, err\n\t})\n}\n\nfunc (app *Imagor) requestWithLoadContext(r *http.Request) *http.Request {\n\tvar ctx = r.Context()\n\tvar cancel func()\n\tif app.LoadTimeout > 0 {\n\t\tctx, cancel = context.WithTimeout(ctx, app.LoadTimeout)\n\t\tcontextDefer(ctx, cancel)\n\t\treturn r.WithContext(ctx)\n\t}\n\treturn r\n}\n\nfunc (app *Imagor) loadResult(r *http.Request, resultKey, imageKey string) *Blob {\n\tr = app.requestWithLoadContext(r)\n\tctx := r.Context()\n\tblob, origin, err := fromStorages(r, app.ResultStorages, resultKey)\n\tif err == nil && !isBlobEmpty(blob) {\n\t\tif app.ModifiedTimeCheck && origin != nil && blob.Stat != nil {\n\t\t\tif sourceStat, err2 := app.storageStat(ctx, imageKey); sourceStat != nil && err2 == nil {\n\t\t\t\tif !blob.Stat.ModifiedTime.Before(sourceStat.ModifiedTime) {\n\t\t\t\t\treturn blob\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\treturn blob\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc fromStorages(\n\tr *http.Request, storages []Storage, key string,\n) (blob *Blob, origin Storage, err error) {\n\tfor _, storage := range storages {\n\t\tb, e := checkBlob(storage.Get(r, key))\n\t\tif !isBlobEmpty(b) {\n\t\t\tblob = b\n\t\t\tif e == nil {\n\t\t\t\terr = nil\n\t\t\t\torigin = storage\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t\terr = e\n\t}\n\treturn\n}\n\nfunc (app *Imagor) loadStorage(r *http.Request, key string) (blob *Blob, shouldSave bool, err error) {\n\tr = app.requestWithLoadContext(r)\n\tvar origin Storage\n\tblob, origin, err = app.fromStoragesAndLoaders(r, app.Storages, app.Loaders, key)\n\tif !isBlobEmpty(blob) && origin == nil &&\n\t\tkey != \"\" && err == nil && len(app.Storages) > 0 {\n\t\tshouldSave = true\n\t}\n\treturn\n}\n\nfunc (app *Imagor) fromStoragesAndLoaders(\n\tr *http.Request, storages []Storage, loaders []Loader, image string,\n) (blob *Blob, origin Storage, err error) {\n\tif image == \"\" {\n\t\tref := mustContextRef(r.Context())\n\t\tif ref.Blob == nil {\n\t\t\terr = ErrNotFound\n\t\t} else {\n\t\t\tblob = ref.Blob\n\t\t}\n\t\treturn\n\t}\n\tvar storageKey = image\n\tif app.StoragePathStyle != nil {\n\t\tstorageKey = app.StoragePathStyle.Hash(image)\n\t}\n\tif storageKey != \"\" {\n\t\tblob, origin, err = fromStorages(r, storages, storageKey)\n\t\tif !isBlobEmpty(blob) && origin != nil && err == nil {\n\t\t\treturn\n\t\t}\n\t}\n\tfor _, loader := range loaders {\n\t\tb, e := checkBlob(loader.Get(r, image))\n\t\tif !isBlobEmpty(b) {\n\t\t\tblob = b\n\t\t\tif e == nil {\n\t\t\t\terr = nil\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t\terr = e\n\t}\n\tif err == nil && isBlobEmpty(blob) {\n\t\terr = ErrNotFound\n\t}\n\treturn\n}\n\nfunc (app *Imagor) storageStat(ctx context.Context, key string) (stat *Stat, err error) {\n\tfor _, storage := range app.Storages {\n\t\tif stat, err = storage.Stat(ctx, key); stat != nil && err == nil {\n\t\t\treturn\n\t\t}\n\t}\n\treturn\n}\n\nfunc (app *Imagor) save(ctx context.Context, storages []Storage, key string, blob *Blob) {\n\tif key == \"\" {\n\t\treturn\n\t}\n\tif app.SaveTimeout > 0 {\n\t\tvar cancel func()\n\t\tctx, cancel = context.WithTimeout(ctx, app.SaveTimeout)\n\t\tdefer cancel()\n\t}\n\tvar wg sync.WaitGroup\n\tfor _, storage := range storages {\n\t\twg.Add(1)\n\t\tgo func(storage Storage) {\n\t\t\tdefer wg.Done()\n\t\t\tif err := storage.Put(ctx, key, blob); err != nil {\n\t\t\t\tapp.Logger.Warn(\"save\", zap.String(\"key\", key), zap.Error(err))\n\t\t\t} else if app.Debug {\n\t\t\t\tapp.Logger.Debug(\"saved\", zap.String(\"key\", key))\n\t\t\t}\n\t\t}(storage)\n\t}\n\twg.Wait()\n\treturn\n}\n\nfunc (app *Imagor) del(ctx context.Context, storages []Storage, key string) {\n\tctx = detachContext(ctx)\n\tif app.SaveTimeout > 0 {\n\t\tvar cancel func()\n\t\tctx, cancel = context.WithTimeout(ctx, app.SaveTimeout)\n\t\tdefer cancel()\n\t}\n\tvar wg sync.WaitGroup\n\tfor _, storage := range storages {\n\t\twg.Add(1)\n\t\tgo func(storage Storage) {\n\t\t\tdefer wg.Done()\n\t\t\tif err := storage.Delete(ctx, key); err != nil {\n\t\t\t\tapp.Logger.Warn(\"delete\", zap.String(\"key\", key), zap.Error(err))\n\t\t\t} else if app.Debug {\n\t\t\t\tapp.Logger.Debug(\"deleted\", zap.String(\"key\", key))\n\t\t\t}\n\t\t}(storage)\n\t}\n\twg.Wait()\n\treturn\n}\n\ntype suppressKey struct {\n\tKey string\n}\n\nfunc blobNoop(*Blob, error) {}\n\nfunc (app *Imagor) suppress(\n\tctx context.Context,\n\tkey string, fn func(ctx context.Context, cb func(*Blob, error)) (*Blob, error),\n) (blob *Blob, err error) {\n\tif key == \"\" {\n\t\treturn fn(ctx, blobNoop)\n\t}\n\tif app.Debug {\n\t\tapp.Logger.Debug(\"suppress\", zap.String(\"key\", key))\n\t}\n\tif isAcquired, ok := ctx.Value(suppressKey{key}).(bool); ok && isAcquired {\n\t\t// resolve deadlock\n\t\treturn fn(ctx, blobNoop)\n\t}\n\tchanCb := make(chan singleflight.Result, 1)\n\tcb := func(blob *Blob, err error) {\n\t\tchanCb <- singleflight.Result{Val: blob, Err: err}\n\t}\n\tisCanceled := false\n\tch := app.g.DoChan(key, func() (v interface{}, err error) {\n\t\tv, err = fn(context.WithValue(ctx, suppressKey{key}, true), cb)\n\t\tif errors.Is(err, context.Canceled) {\n\t\t\tapp.g.Forget(key)\n\t\t\tisCanceled = true\n\t\t}\n\t\treturn v, err\n\t})\n\tselect {\n\tcase res := <-ch:\n\t\tif !isCanceled && errors.Is(res.Err, context.Canceled) {\n\t\t\t// resolve canceled\n\t\t\treturn app.suppress(ctx, key, fn)\n\t\t}\n\t\tif res.Val != nil {\n\t\t\treturn res.Val.(*Blob), res.Err\n\t\t}\n\t\treturn nil, res.Err\n\tcase res := <-chanCb:\n\t\treturn res.Val.(*Blob), res.Err\n\tcase <-ctx.Done():\n\t\treturn nil, ctx.Err()\n\t}\n}\n\nfunc (app *Imagor) debugLog() {\n\tif !app.Debug {\n\t\treturn\n\t}\n\tvar loaders, storages, resultStorages, processors []string\n\tfor _, v := range app.Loaders {\n\t\tloaders = append(loaders, getType(v))\n\t}\n\tfor _, v := range app.Storages {\n\t\tstorages = append(storages, getType(v))\n\t}\n\tfor _, v := range app.Processors {\n\t\tprocessors = append(processors, getType(v))\n\t}\n\tfor _, v := range app.ResultStorages {\n\t\tresultStorages = append(resultStorages, getType(v))\n\t}\n\tapp.Logger.Debug(\"imagor\",\n\t\tzap.String(\"version\", Version),\n\t\tzap.Bool(\"unsafe\", app.Unsafe),\n\t\tzap.Duration(\"request_timeout\", app.RequestTimeout),\n\t\tzap.Duration(\"load_timeout\", app.LoadTimeout),\n\t\tzap.Duration(\"process_timeout\", app.ProcessTimeout),\n\t\tzap.Duration(\"save_timeout\", app.SaveTimeout),\n\t\tzap.Int64(\"process_concurrency\", app.ProcessConcurrency),\n\t\tzap.Duration(\"cache_header_ttl\", app.CacheHeaderTTL),\n\t\tzap.Strings(\"loaders\", loaders),\n\t\tzap.Strings(\"storages\", storages),\n\t\tzap.Strings(\"result_storages\", resultStorages),\n\t\tzap.Strings(\"processors\", processors),\n\t)\n}\n\nvar landing = fmt.Sprintf(`\n<!doctype html>\n<html>\n\t<head><title>imagor v%s</title></head>\n\t<body>\n\t\t<h1>imagor v%s</h1>\n\t\t<p><a href=\"https://github.com/cshum/imagor\" target=\"_blank\">https://github.com/cshum/imagor</a></p>\n\t</body>\n</html>\n`, Version, Version)\n\nfunc checkStatNotModified(w http.ResponseWriter, r *http.Request, stat *Stat) bool {\n\tif stat == nil || strings.Contains(r.Header.Get(\"Cache-Control\"), \"no-cache\") {\n\t\treturn false\n\t}\n\tvar isETagMatch, isNotModified bool\n\tvar etag = stat.ETag\n\tif etag == \"\" && stat.Size > 0 && !stat.ModifiedTime.IsZero() {\n\t\tetag = fmt.Sprintf(\n\t\t\t\"%x-%x\", int(stat.ModifiedTime.Unix()), int(stat.Size))\n\t}\n\tif etag != \"\" {\n\t\tw.Header().Set(\"ETag\", etag)\n\t\tif inm := r.Header.Get(\"If-None-Match\"); inm == etag {\n\t\t\tisETagMatch = true\n\t\t}\n\t}\n\tif mTime := stat.ModifiedTime; !mTime.IsZero() {\n\t\tw.Header().Set(\"Last-Modified\", mTime.Format(http.TimeFormat))\n\t\tif ims := r.Header.Get(\"If-Modified-Since\"); ims != \"\" {\n\t\t\tif imsTime, err := time.Parse(http.TimeFormat, ims); err == nil {\n\t\t\t\tisNotModified = mTime.Before(imsTime)\n\t\t\t}\n\t\t}\n\t\tif !isNotModified {\n\t\t\tif ius := r.Header.Get(\"If-Unmodified-Since\"); ius != \"\" {\n\t\t\t\tif iusTime, err := time.Parse(http.TimeFormat, ius); err == nil {\n\t\t\t\t\tisNotModified = mTime.After(iusTime)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn isETagMatch || isNotModified\n}\n\nfunc getTtl(p imagorpath.Params, defaultTtl time.Duration) time.Duration {\n\tfor _, f := range p.Filters {\n\t\tif f.Name == \"expire\" {\n\t\t\tif ts, e := strconv.ParseInt(f.Args, 10, 64); e == nil {\n\t\t\t\tttl := (time.UnixMilli(ts).Sub(time.Now()) + time.Second - 1).Truncate(time.Second)\n\t\t\t\tif ttl <= defaultTtl {\n\t\t\t\t\treturn ttl\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn defaultTtl\n}\n\nfunc setCacheHeaders(w http.ResponseWriter, r *http.Request, ttl, swr time.Duration) {\n\tif strings.Contains(r.Header.Get(\"Cache-Control\"), \"no-cache\") {\n\t\tttl = 0\n\t}\n\texpires := time.Now().Add(ttl)\n\tisPrivate := strings.Contains(r.Header.Get(\"Cache-Control\"), \"private\")\n\tw.Header().Add(\"Expires\", strings.Replace(expires.Format(time.RFC1123), \"UTC\", \"GMT\", -1))\n\tw.Header().Add(\"Cache-Control\", getCacheControl(isPrivate, ttl, swr))\n}\n\nfunc getCacheControl(isPrivate bool, ttl, swr time.Duration) string {\n\tif ttl == 0 {\n\t\treturn \"private, no-cache, no-store, must-revalidate\"\n\t}\n\tvar ttlSec = int64(ttl.Seconds())\n\tvar val = fmt.Sprintf(\"public, s-maxage=%d\", ttlSec)\n\tif isPrivate {\n\t\tval = \"private\"\n\t}\n\tval += fmt.Sprintf(\", max-age=%d, no-transform\", ttlSec)\n\tif swr > 0 && swr < ttl {\n\t\tval += fmt.Sprintf(\", stale-while-revalidate=%d\", int64(swr.Seconds()))\n\t}\n\treturn val\n}\n\nfunc writeJSON(w http.ResponseWriter, r *http.Request, v interface{}) {\n\tbuf, _ := json.Marshal(v)\n\tw.Header().Set(\"Content-Type\", \"application/json\")\n\tw.Header().Set(\"Content-Length\", strconv.Itoa(len(buf)))\n\tif r.Method != http.MethodHead {\n\t\t_, _ = w.Write(buf)\n\t}\n\treturn\n}\n\nfunc writeJSONIndent(w http.ResponseWriter, r *http.Request, v interface{}) {\n\tbuf, _ := json.MarshalIndent(v, \"\", \"  \")\n\tw.Header().Set(\"Content-Type\", \"application/json\")\n\tw.Header().Set(\"Content-Length\", strconv.Itoa(len(buf)))\n\tif r.Method != http.MethodHead {\n\t\t_, _ = w.Write(buf)\n\t}\n\treturn\n}\n\nfunc writeBody(w http.ResponseWriter, r *http.Request, reader io.ReadCloser, size int64) {\n\tdefer func() {\n\t\t_ = reader.Close()\n\t}()\n\tif size > 0 {\n\t\t// total size known, use io.Copy\n\t\tw.Header().Set(\"Content-Length\", strconv.FormatInt(size, 10))\n\t\tif r.Method != http.MethodHead {\n\t\t\t_, _ = io.Copy(w, reader)\n\t\t}\n\t} else {\n\t\t// total size unknown, read all\n\t\tbuf, _ := io.ReadAll(reader)\n\t\tw.Header().Set(\"Content-Length\", strconv.Itoa(len(buf)))\n\t\tif r.Method != http.MethodHead {\n\t\t\t_, _ = w.Write(buf)\n\t\t}\n\t}\n}\n\nfunc getContentDisposition(p imagorpath.Params, blob *Blob) string {\n\tfor _, f := range p.Filters {\n\t\tif f.Name == \"attachment\" {\n\t\t\tfilename := f.Args\n\t\t\tif filename == \"\" {\n\t\t\t\t_, filename = filepath.Split(p.Image)\n\t\t\t}\n\t\t\tfilename = strings.ReplaceAll(filename, `\"`, \"%22\")\n\t\t\tif ext := getExtension(blob.BlobType()); ext != \"\" &&\n\t\t\t\t!(ext == \".jpg\" && strings.HasSuffix(filename, \".jpeg\")) {\n\t\t\t\tfilename = strings.TrimSuffix(filename, ext) + ext\n\t\t\t}\n\t\t\treturn fmt.Sprintf(`attachment; filename=\"%s\"`, filename)\n\t\t}\n\t}\n\treturn \"inline\"\n}\n\nfunc getType(v interface{}) string {\n\tt := reflect.TypeOf(v)\n\tif t.Kind() == reflect.Ptr {\n\t\treturn t.Elem().Name()\n\t}\n\treturn t.Name()\n}\n"
        },
        {
          "name": "imagor_test.go",
          "type": "blob",
          "size": 49.87109375,
          "content": "package imagor\n\nimport (\n\t\"bytes\"\n\t\"context\"\n\t\"crypto/sha256\"\n\t\"encoding/json\"\n\t\"errors\"\n\t\"fmt\"\n\t\"github.com/cshum/imagor/imagorpath\"\n\t\"github.com/stretchr/testify/assert\"\n\t\"github.com/stretchr/testify/require\"\n\t\"go.uber.org/zap\"\n\t\"io\"\n\t\"math/rand\"\n\t\"net/http\"\n\t\"net/http/httptest\"\n\t\"strings\"\n\t\"sync\"\n\t\"testing\"\n\t\"time\"\n)\n\nfunc TestWithUnsafe(t *testing.T) {\n\tlogger := zap.NewExample()\n\tapp := New(WithOptions(\n\t\tWithUnsafe(true),\n\t\tWithLoaders(loaderFunc(func(r *http.Request, image string) (*Blob, error) {\n\t\t\treturn NewBlobFromBytes([]byte(\"foo\")), nil\n\t\t})),\n\t\tWithLogger(logger),\n\t))\n\tassert.Equal(t, false, app.Debug)\n\tassert.Equal(t, logger, app.Logger)\n\n\tw := httptest.NewRecorder()\n\tapp.ServeHTTP(w, httptest.NewRequest(\n\t\thttp.MethodGet, \"https://example.com/unsafe/foo.jpg\", nil))\n\tassert.Equal(t, 200, w.Code)\n\n\tw = httptest.NewRecorder()\n\tapp.ServeHTTP(w, httptest.NewRequest(\n\t\thttp.MethodPost, \"https://example.com/unsafe/foo.jpg\", nil))\n\tassert.Equal(t, 405, w.Code)\n\tassert.Equal(t, \"\", w.Body.String())\n\n\tw = httptest.NewRecorder()\n\tapp.ServeHTTP(w, httptest.NewRequest(\n\t\thttp.MethodGet, \"https://example.com/foo.jpg\", nil))\n\tassert.Equal(t, 403, w.Code)\n\tassert.Equal(t, w.Body.String(), jsonStr(ErrSignatureMismatch))\n}\n\nfunc TestWithInternal(t *testing.T) {\n\tlogger := zap.NewExample()\n\tctx := context.Background()\n\tapp := New(WithOptions(\n\t\tWithLoaders(loaderFunc(func(r *http.Request, image string) (*Blob, error) {\n\t\t\treturn NewBlobFromBytes([]byte(\"foo\")), nil\n\t\t})),\n\t\tWithProcessors(processorFunc(func(ctx context.Context, blob *Blob, p imagorpath.Params, load LoadFunc) (*Blob, error) {\n\t\t\tassert.Contains(t, p.Path, p.Image)\n\t\t\tassert.Positive(t, p.Width)\n\t\t\tassert.Positive(t, p.Height)\n\t\t\treturn blob, nil\n\t\t})),\n\t\tWithLogger(logger),\n\t))\n\tassert.Equal(t, false, app.Debug)\n\tassert.Equal(t, logger, app.Logger)\n\n\tblob, err := app.Serve(ctx, imagorpath.Params{\n\t\tImage: \"foo.jpg\",\n\t\tWidth: 167, Height: 199,\n\t\tPath: \"ghjk\",\n\t})\n\trequire.NoError(t, err)\n\tbuf, err := blob.ReadAll()\n\tassert.Equal(t, \"foo\", string(buf))\n\trequire.NoError(t, err)\n\n\tblob, err = app.Serve(ctx, imagorpath.Params{\n\t\tImage: \"foo.jpg\",\n\t\tWidth: -167, Height: -199,\n\t\tPath: \"ghjk\",\n\t})\n\trequire.NoError(t, err)\n\tbuf, err = blob.ReadAll()\n\tassert.Equal(t, \"foo\", string(buf))\n\trequire.NoError(t, err)\n\n\tblob, err = app.Serve(nil, imagorpath.Params{\n\t\tImage: \"foo.jpg\",\n\t\tWidth: 167, Height: 199,\n\t\tPath: \"ghjk\",\n\t})\n\tassert.Empty(t, blob)\n\tassert.Error(t, err)\n\n\tblob, err = app.ServeBlob(nil, nil, imagorpath.Params{\n\t\tImage: \"foo.jpg\",\n\t\tWidth: 167, Height: 199,\n\t\tPath: \"ghjk\",\n\t})\n\tassert.Empty(t, blob)\n\tassert.Error(t, err)\n\n\tblob, err = app.ServeBlob(ctx, NewBlobFromBytes([]byte(\"asdf\")), imagorpath.Params{\n\t\tImage: \"foo.jpg\",\n\t\tWidth: 167, Height: 199,\n\t\tPath: \"ghjk\",\n\t})\n\trequire.NoError(t, err)\n\tbuf, err = blob.ReadAll()\n\tassert.Equal(t, \"asdf\", string(buf))\n\trequire.NoError(t, err)\n}\n\nfunc TestWithContentDisposition(t *testing.T) {\n\tlogger := zap.NewExample()\n\tapp := New(\n\t\tWithUnsafe(true),\n\t\tWithLoaders(loaderFunc(func(r *http.Request, image string) (*Blob, error) {\n\t\t\treturn NewBlobFromFile(image), nil\n\t\t})),\n\t\tWithResultStorages(saverFunc(func(ctx context.Context, image string, blob *Blob) error {\n\t\t\tassert.NotContains(t, image, \"attachment\")\n\t\t\treturn nil\n\t\t})),\n\t\tWithLogger(logger))\n\tassert.Equal(t, false, app.Debug)\n\tassert.Equal(t, logger, app.Logger)\n\n\tw := httptest.NewRecorder()\n\tapp.ServeHTTP(w, httptest.NewRequest(\n\t\thttp.MethodGet, \"https://example.com/unsafe/testdata/gopher.png\", nil))\n\tassert.Equal(t, 200, w.Code)\n\tassert.Equal(t, \"inline\", w.Header().Get(\"Content-Disposition\"))\n\n\tw = httptest.NewRecorder()\n\tapp.ServeHTTP(w, httptest.NewRequest(\n\t\thttp.MethodGet, \"https://example.com/unsafe/filters:attachment()/testdata/gopher.png\", nil))\n\tassert.Equal(t, 200, w.Code)\n\tassert.Equal(t, `attachment; filename=\"gopher.png\"`, w.Header().Get(\"Content-Disposition\"))\n\n\tw = httptest.NewRecorder()\n\tapp.ServeHTTP(w, httptest.NewRequest(\n\t\thttp.MethodGet, \"https://example.com/unsafe/filters:attachment(foo.png)/testdata/demo1.jpg\", nil))\n\tassert.Equal(t, 200, w.Code)\n\tassert.Equal(t, `attachment; filename=\"foo.png.jpg\"`, w.Header().Get(\"Content-Disposition\"))\n\n\tw = httptest.NewRecorder()\n\tapp.ServeHTTP(w, httptest.NewRequest(\n\t\thttp.MethodGet, \"https://example.com/unsafe/filters:attachment(foo.jpeg)/testdata/demo1.jpg\", nil))\n\tassert.Equal(t, 200, w.Code)\n\tassert.Equal(t, `attachment; filename=\"foo.jpeg\"`, w.Header().Get(\"Content-Disposition\"))\n\n}\n\nfunc TestSuppressDeadlockResolve(t *testing.T) {\n\tctx := context.Background()\n\tapp := New()\n\tf, err := app.suppress(ctx, \"a\", func(ctx context.Context, _ func(*Blob, error)) (*Blob, error) {\n\t\treturn app.suppress(ctx, \"b\", func(ctx context.Context, _ func(*Blob, error)) (*Blob, error) {\n\t\t\treturn app.suppress(ctx, \"a\", func(ctx context.Context, _ func(*Blob, error)) (*Blob, error) {\n\t\t\t\treturn NewEmptyBlob(), nil\n\t\t\t})\n\t\t})\n\t})\n\tassert.Equal(t, NewEmptyBlob(), f)\n\trequire.NoError(t, err)\n}\n\nfunc TestSuppressTimeout(t *testing.T) {\n\tctx, cancel := context.WithTimeout(context.Background(), time.Millisecond*10)\n\tdefer cancel()\n\tapp := New()\n\tf, err := app.suppress(ctx, \"a\", func(ctx context.Context, _ func(*Blob, error)) (*Blob, error) {\n\t\ttime.Sleep(time.Second)\n\t\treturn &Blob{}, nil\n\t})\n\tassert.Nil(t, f)\n\tassert.Equal(t, context.DeadlineExceeded, err)\n}\n\nfunc TestSuppressForgetCanceled(t *testing.T) {\n\tn := 10\n\tapp := New()\n\tvar wg sync.WaitGroup\n\twg.Add(n * 2)\n\tfor i := 0; i < n; i++ {\n\t\tgo func() {\n\t\t\tdefer wg.Done()\n\t\t\t_, err := app.suppress(context.Background(), \"a\", func(ctx context.Context, _ func(*Blob, error)) (*Blob, error) {\n\t\t\t\ttime.Sleep(time.Millisecond)\n\t\t\t\treturn NewEmptyBlob(), nil\n\t\t\t})\n\t\t\tassert.Nil(t, err)\n\t\t}()\n\t\tgo func() {\n\t\t\tdefer wg.Done()\n\t\t\t_, _ = app.suppress(context.Background(), \"a\", func(ctx context.Context, _ func(*Blob, error)) (*Blob, error) {\n\t\t\t\ttime.Sleep(time.Millisecond)\n\t\t\t\treturn nil, context.Canceled\n\t\t\t})\n\t\t}()\n\t}\n\twg.Wait()\n}\n\nfunc TestWithSigner(t *testing.T) {\n\tapp := New(\n\t\tWithDebug(true),\n\t\tWithLogger(zap.NewExample()),\n\t\tWithLoaders(loaderFunc(func(r *http.Request, image string) (*Blob, error) {\n\t\t\treturn NewBlobFromBytes([]byte(\"foo\")), nil\n\t\t})),\n\t\tWithSigner(imagorpath.NewDefaultSigner(\"1234\")))\n\tassert.Equal(t, true, app.Debug)\n\n\tw := httptest.NewRecorder()\n\tapp.ServeHTTP(w, httptest.NewRequest(\n\t\thttp.MethodGet, \"https://example.com/_-19cQt1szHeUV0WyWFntvTImDI=/foo.jpg\", nil))\n\tassert.Equal(t, 200, w.Code)\n\n\tw = httptest.NewRecorder()\n\tapp.ServeHTTP(w, httptest.NewRequest(\n\t\thttp.MethodGet, \"https://example.com/_-19cQt1szHeUV0WyWFntvTIm/foo.jpg\", nil))\n\tassert.Equal(t, 403, w.Code)\n\tassert.Equal(t, w.Body.String(), jsonStr(ErrSignatureMismatch))\n\n\tw = httptest.NewRecorder()\n\tapp.ServeHTTP(w, httptest.NewRequest(\n\t\thttp.MethodGet, \"https://example.com/foo.jpg\", nil))\n\tassert.Equal(t, 403, w.Code)\n\tassert.Equal(t, w.Body.String(), jsonStr(ErrSignatureMismatch))\n}\n\nfunc TestWithCustomSigner(t *testing.T) {\n\tapp := New(\n\t\tWithDebug(true),\n\t\tWithLogger(zap.NewExample()),\n\t\tWithLoaders(loaderFunc(func(r *http.Request, image string) (*Blob, error) {\n\t\t\treturn NewBlobFromBytes([]byte(\"foo\")), nil\n\t\t})),\n\t\tWithSigner(imagorpath.NewHMACSigner(sha256.New, 40, \"1234\")))\n\tassert.Equal(t, true, app.Debug)\n\n\tw := httptest.NewRecorder()\n\tapp.ServeHTTP(w, httptest.NewRequest(\n\t\thttp.MethodGet, \"https://example.com/91DBDJtTFePFnbaj5Qq8JLvq5sM5VTipE685f4Gp/foo.jpg\", nil))\n\tassert.Equal(t, 200, w.Code)\n\n\tw = httptest.NewRecorder()\n\tapp.ServeHTTP(w, httptest.NewRequest(\n\t\thttp.MethodGet, \"https://example.com/_-19cQt1szHeUV0WyWFntvTImDI=/foo.jpg\", nil))\n\tassert.Equal(t, 403, w.Code)\n\tassert.Equal(t, w.Body.String(), jsonStr(ErrSignatureMismatch))\n\n\tw = httptest.NewRecorder()\n\tapp.ServeHTTP(w, httptest.NewRequest(\n\t\thttp.MethodGet, \"https://example.com/foo.jpg\", nil))\n\tassert.Equal(t, 403, w.Code)\n\tassert.Equal(t, w.Body.String(), jsonStr(ErrSignatureMismatch))\n}\n\nfunc TestWithRetryQueryUnescape(t *testing.T) {\n\topts := WithOptions(\n\t\tWithDebug(true),\n\t\tWithLogger(zap.NewExample()),\n\t\tWithLoaders(loaderFunc(func(r *http.Request, image string) (*Blob, error) {\n\t\t\tif image != \"gopher.png\" {\n\t\t\t\treturn nil, ErrInvalid\n\t\t\t}\n\t\t\treturn NewBlobFromBytes([]byte(\"foo\")), nil\n\t\t})),\n\t\tWithProcessors(processorFunc(func(ctx context.Context, blob *Blob, p imagorpath.Params, load LoadFunc) (*Blob, error) {\n\t\t\treturn NewBlobFromBytes([]byte(p.Path)), nil\n\t\t})),\n\t)\n\n\tapp := New(opts, WithUnsafe(true))\n\tw := httptest.NewRecorder()\n\tapp.ServeHTTP(w, httptest.NewRequest(\n\t\thttp.MethodGet, \"https://example.com/unsafe/filters%3Afill%28red%29/gopher.png\", nil))\n\tassert.Equal(t, 200, w.Code)\n\tassert.Equal(t, \"filters:fill(red)/gopher.png\", w.Body.String())\n\n\tapp = New(opts, WithSigner(imagorpath.NewDefaultSigner(\"1234\")))\n\tw = httptest.NewRecorder()\n\tapp.ServeHTTP(w, httptest.NewRequest(\n\t\thttp.MethodGet, \"https://example.com/GSqGN9NrCj-DlGT38BaycScxM9g=/filters%3Afill%28red%29/gopher.png\", nil))\n\tassert.Equal(t, 200, w.Code)\n\tassert.Equal(t, \"filters:fill(red)/gopher.png\", w.Body.String())\n}\n\nfunc TestWithRaw(t *testing.T) {\n\tapp := New(\n\t\tWithDebug(true),\n\t\tWithUnsafe(true),\n\t\tWithLogger(zap.NewExample()),\n\t\tWithLoaders(loaderFunc(func(r *http.Request, image string) (*Blob, error) {\n\t\t\tif image != \"gopher.png\" {\n\t\t\t\treturn nil, ErrInvalid\n\t\t\t}\n\t\t\tblob := NewBlobFromBytes([]byte(\"foo\"))\n\t\t\tblob.SetContentType(\"bar\")\n\t\t\treturn blob, nil\n\t\t})),\n\t\tWithProcessors(processorFunc(func(ctx context.Context, blob *Blob, p imagorpath.Params, load LoadFunc) (*Blob, error) {\n\t\t\tout := NewBlobFromBytes([]byte(p.Path))\n\t\t\tout.SetContentType(\"boom\")\n\t\t\treturn out, nil\n\t\t})),\n\t)\n\tw := httptest.NewRecorder()\n\tapp.ServeHTTP(w, httptest.NewRequest(\n\t\thttp.MethodGet, \"https://example.com/unsafe/filters:fill(red)/gopher.png\", nil))\n\tassert.Equal(t, 200, w.Code)\n\tassert.Equal(t, \"filters:fill(red)/gopher.png\", w.Body.String())\n\tassert.Equal(t, \"boom\", w.Header().Get(\"Content-Type\"))\n\tassert.Empty(t, w.Header().Get(\"Content-Security-Policy\"))\n\n\tw = httptest.NewRecorder()\n\tapp.ServeHTTP(w, httptest.NewRequest(\n\t\thttp.MethodGet, \"https://example.com/unsafe/filters:fill(red):raw()/gopher.png\", nil))\n\tassert.Equal(t, 200, w.Code)\n\tassert.Equal(t, \"foo\", w.Body.String())\n\tassert.Equal(t, \"script-src 'none'\", w.Header().Get(\"Content-Security-Policy\"))\n\tassert.Equal(t, \"bar\", w.Header().Get(\"Content-Type\"))\n}\n\nfunc TestWithOverrideHeader(t *testing.T) {\n\tapp := New(\n\t\tWithDebug(true),\n\t\tWithUnsafe(true),\n\t\tWithLogger(zap.NewExample()),\n\t\tWithLoaders(loaderFunc(func(r *http.Request, image string) (*Blob, error) {\n\t\t\tblob := NewBlobFromBytes([]byte(\"foo\"))\n\t\t\tblob.SetContentType(\"bar\")\n\t\t\tblob.Header = make(http.Header)\n\t\t\tblob.Header.Set(\"Content-Type\", \"tada\")\n\t\t\tblob.Header.Set(\"Foo\", \"bar\")\n\t\t\tblob.Header.Set(\"asdf\", \"fghj\")\n\t\t\treturn blob, nil\n\t\t})),\n\t\tWithProcessors(processorFunc(func(ctx context.Context, blob *Blob, p imagorpath.Params, load LoadFunc) (*Blob, error) {\n\t\t\tout := NewBlobFromBytes([]byte(\"processed\"))\n\t\t\tout.SetContentType(\"boom\")\n\t\t\treturn out, nil\n\t\t})),\n\t)\n\tw := httptest.NewRecorder()\n\tapp.ServeHTTP(w, httptest.NewRequest(\n\t\thttp.MethodGet, \"https://example.com/unsafe/filters:fill(red)/gopher.png\", nil))\n\tassert.Equal(t, 200, w.Code)\n\tassert.Equal(t, \"processed\", w.Body.String())\n\tassert.Equal(t, \"tada\", w.Header().Get(\"Content-Type\"))\n\tassert.Equal(t, \"fghj\", w.Header().Get(\"ASDF\"))\n}\n\nfunc TestNewBlobFromPathNotFound(t *testing.T) {\n\tloader := loaderFunc(func(r *http.Request, image string) (*Blob, error) {\n\t\treturn NewBlobFromFile(\"./non-exists-path\"), nil\n\t})\n\tapp := New(\n\t\tWithDebug(true),\n\t\tWithLogger(zap.NewExample()),\n\t\tWithUnsafe(true),\n\t\tWithLoaders(loader))\n\n\tr := httptest.NewRequest(\n\t\thttp.MethodGet, \"https://example.com/unsafe/foobar\", nil)\n\tw := httptest.NewRecorder()\n\tapp.ServeHTTP(w, r)\n\tassert.Equal(t, 404, w.Code)\n\tassert.Equal(t, jsonStr(ErrNotFound), w.Body.String())\n\n\tapp = New(\n\t\tWithDebug(true),\n\t\tWithLogger(zap.NewExample()),\n\t\tWithUnsafe(true),\n\t\tWithDisableErrorBody(true),\n\t\tWithLoaders(loader))\n\n\tr = httptest.NewRequest(\n\t\thttp.MethodGet, \"https://example.com/unsafe/foobar\", nil)\n\tw = httptest.NewRecorder()\n\tapp.ServeHTTP(w, r)\n\tassert.Equal(t, 404, w.Code)\n\tassert.Empty(t, w.Body.String())\n}\n\nfunc TestWithDisableErrorBody(t *testing.T) {\n\tapp := New(\n\t\tWithDebug(true),\n\t\tWithLogger(zap.NewExample()),\n\t\tWithDisableErrorBody(true),\n\t\tWithSigner(imagorpath.NewDefaultSigner(\"1234\")))\n\tassert.True(t, app.DisableErrorBody)\n\n\tw := httptest.NewRecorder()\n\tapp.ServeHTTP(w, httptest.NewRequest(\n\t\thttp.MethodGet, \"https://example.com/foo.jpg\", nil))\n\tassert.Equal(t, 403, w.Code)\n\tassert.Empty(t, w.Body.String())\n}\n\nfunc TestWithCacheHeaderTTL(t *testing.T) {\n\tloader := loaderFunc(func(r *http.Request, image string) (blob *Blob, err error) {\n\t\treturn NewBlobFromBytes([]byte(\"ok\")), nil\n\t})\n\tt.Run(\"default\", func(t *testing.T) {\n\t\tapp := New(\n\t\t\tWithLogger(zap.NewExample()),\n\t\t\tWithLoaders(loader),\n\t\t\tWithUnsafe(true))\n\t\tw := httptest.NewRecorder()\n\t\tapp.ServeHTTP(w, httptest.NewRequest(\n\t\t\thttp.MethodGet, \"https://example.com/unsafe/foo.jpg\", nil))\n\t\tassert.Equal(t, 200, w.Code)\n\t\tassert.Equal(t, \"public, s-maxage=604800, max-age=604800, no-transform, stale-while-revalidate=86400\", w.Header().Get(\"Cache-Control\"))\n\t})\n\tt.Run(\"custom ttl swr\", func(t *testing.T) {\n\t\tapp := New(\n\t\t\tWithLogger(zap.NewExample()),\n\t\t\tWithCacheHeaderSWR(time.Second*167),\n\t\t\tWithCacheHeaderTTL(time.Second*169),\n\t\t\tWithLoaders(loader),\n\t\t\tWithUnsafe(true))\n\t\tw := httptest.NewRecorder()\n\t\tapp.ServeHTTP(w, httptest.NewRequest(\n\t\t\thttp.MethodGet, \"https://example.com/unsafe/foo.jpg\", nil))\n\t\tassert.Equal(t, 200, w.Code)\n\t\tassert.Equal(t, \"public, s-maxage=169, max-age=169, no-transform, stale-while-revalidate=167\", w.Header().Get(\"Cache-Control\"))\n\t})\n\tt.Run(\"custom ttl swr private\", func(t *testing.T) {\n\t\tapp := New(\n\t\t\tWithLogger(zap.NewExample()),\n\t\t\tWithCacheHeaderSWR(time.Second*167),\n\t\t\tWithCacheHeaderTTL(time.Second*169),\n\t\t\tWithLoaders(loader),\n\t\t\tWithUnsafe(true))\n\t\tw := httptest.NewRecorder()\n\t\tr := httptest.NewRequest(http.MethodGet, \"https://example.com/unsafe/foo.jpg\", nil)\n\t\tr.Header.Set(\"Cache-Control\", \"private\")\n\t\tapp.ServeHTTP(w, r)\n\t\tassert.Equal(t, 200, w.Code)\n\t\tassert.Equal(t, \"private, max-age=169, no-transform, stale-while-revalidate=167\", w.Header().Get(\"Cache-Control\"))\n\t})\n\tt.Run(\"custom ttl no swr\", func(t *testing.T) {\n\t\tapp := New(\n\t\t\tWithLogger(zap.NewExample()),\n\t\t\tWithCacheHeaderSWR(time.Second*169),\n\t\t\tWithCacheHeaderTTL(time.Second*169),\n\t\t\tWithLoaders(loader),\n\t\t\tWithUnsafe(true))\n\t\tw := httptest.NewRecorder()\n\t\tapp.ServeHTTP(w, httptest.NewRequest(\n\t\t\thttp.MethodGet, \"https://example.com/unsafe/foo.jpg\", nil))\n\t\tassert.Equal(t, 200, w.Code)\n\t\tassert.Equal(t, \"public, s-maxage=169, max-age=169, no-transform\", w.Header().Get(\"Cache-Control\"))\n\t})\n\tt.Run(\"no cache\", func(t *testing.T) {\n\t\tapp := New(\n\t\t\tWithLoaders(loader),\n\t\t\tWithCacheHeaderNoCache(true),\n\t\t\tWithUnsafe(true))\n\t\tw := httptest.NewRecorder()\n\t\tapp.ServeHTTP(w, httptest.NewRequest(\n\t\t\thttp.MethodGet, \"https://example.com/unsafe/foo.jpg\", nil))\n\t\tassert.Equal(t, 200, w.Code)\n\t\tassert.NotEmpty(t, w.Header().Get(\"Expires\"))\n\t\tassert.Equal(t, \"private, no-cache, no-store, must-revalidate\", w.Header().Get(\"Cache-Control\"))\n\t})\n}\n\nfunc TestExpire(t *testing.T) {\n\tloader := loaderFunc(func(r *http.Request, image string) (blob *Blob, err error) {\n\t\treturn NewBlobFromBytes([]byte(\"ok\")), nil\n\t})\n\tapp := New(\n\t\tWithLogger(zap.NewExample()),\n\t\tWithCacheHeaderSWR(time.Second*169),\n\t\tWithCacheHeaderTTL(time.Second*169),\n\t\tWithLoaders(loader),\n\t\tWithResultStorages(saverFunc(func(ctx context.Context, image string, blob *Blob) error {\n\t\t\tassert.NotContains(t, image, \"expire\")\n\t\t\treturn nil\n\t\t})),\n\t\tWithUnsafe(true))\n\tw := httptest.NewRecorder()\n\tapp.ServeHTTP(w, httptest.NewRequest(\n\t\thttp.MethodGet, \"https://example.com/unsafe/filters:foo(bar)/foo.jpg\", nil))\n\tassert.Equal(t, 200, w.Code)\n\tassert.Equal(t, \"public, s-maxage=169, max-age=169, no-transform\", w.Header().Get(\"Cache-Control\"))\n\n\tnow := time.Now()\n\ttime.Sleep(time.Millisecond)\n\n\tw = httptest.NewRecorder()\n\tapp.ServeHTTP(w, httptest.NewRequest(\n\t\thttp.MethodGet,\n\t\tfmt.Sprintf(\"https://example.com/unsafe/filters:expire(%d):foo(bar)/foo.jpg\",\n\t\t\tnow.Add(time.Second).UnixMilli(),\n\t\t), nil))\n\tassert.Equal(t, 200, w.Code)\n\tassert.Equal(t, \"private, max-age=1, no-transform\", w.Header().Get(\"Cache-Control\"))\n\n\tw = httptest.NewRecorder()\n\tapp.ServeHTTP(w, httptest.NewRequest(\n\t\thttp.MethodGet,\n\t\tfmt.Sprintf(\"https://example.com/unsafe/filters:expire(%d):foo(bar)/foo.jpg\",\n\t\t\tnow.Add(time.Second*170).UnixMilli(),\n\t\t), nil))\n\tassert.Equal(t, 200, w.Code)\n\tassert.Equal(t, \"private, max-age=169, no-transform\", w.Header().Get(\"Cache-Control\"))\n\n\tw = httptest.NewRecorder()\n\tapp.ServeHTTP(w, httptest.NewRequest(\n\t\thttp.MethodGet,\n\t\tfmt.Sprintf(\"https://example.com/unsafe/filters:expire(%d):foo(bar)/foo.jpg\",\n\t\t\tnow.UnixMilli(),\n\t\t), nil))\n\tassert.Equal(t, 410, w.Code)\n}\n\nfunc TestVersion(t *testing.T) {\n\tapp := New(\n\t\tWithDebug(true),\n\t\tWithLogger(zap.NewExample()),\n\t)\n\n\tr := httptest.NewRequest(\n\t\thttp.MethodGet, \"https://example.com/\", nil)\n\tw := httptest.NewRecorder()\n\tapp.ServeHTTP(w, r)\n\tassert.Equal(t, 200, w.Code)\n\tassert.Contains(t, w.Body.String(), Version)\n}\n\nfunc TestWithBasePathRedirect(t *testing.T) {\n\tapp := New(\n\t\tWithDebug(true),\n\t\tWithBasePathRedirect(\"https://www.bar.com\"),\n\t\tWithLogger(zap.NewExample()),\n\t)\n\tr := httptest.NewRequest(\n\t\thttp.MethodGet, \"https://foo.com/\", nil)\n\tw := httptest.NewRecorder()\n\tapp.ServeHTTP(w, r)\n\tassert.Equal(t, http.StatusTemporaryRedirect, w.Code)\n\tassert.Equal(t, \"https://www.bar.com\", w.Header().Get(\"Location\"))\n}\n\nfunc TestParams(t *testing.T) {\n\tapp := New(\n\t\tWithDebug(true),\n\t\tWithLogger(zap.NewExample()),\n\t\tWithSigner(imagorpath.NewDefaultSigner(\"1234\")))\n\n\tr := httptest.NewRequest(\n\t\thttp.MethodGet, \"https://example.com/params/_-19cQt1szHeUV0WyWFntvTImDI=/foo.jpg\", nil)\n\tw := httptest.NewRecorder()\n\tapp.ServeHTTP(w, r)\n\tassert.Equal(t, 200, w.Code)\n\tbuf, _ := json.MarshalIndent(imagorpath.Parse(r.URL.EscapedPath()), \"\", \"  \")\n\tassert.Equal(t, string(buf), w.Body.String())\n\n\tr = httptest.NewRequest(\n\t\thttp.MethodGet, \"https://example.com/params/foo.jpg\", nil)\n\tw = httptest.NewRecorder()\n\tapp.ServeHTTP(w, r)\n\tassert.Equal(t, 200, w.Code)\n\tbuf, _ = json.MarshalIndent(imagorpath.Parse(r.URL.EscapedPath()), \"\", \"  \")\n\tassert.Equal(t, string(buf), w.Body.String())\n\n\tapp = New(\n\t\tWithDebug(true),\n\t\tWithLogger(zap.NewExample()),\n\t\tWithDisableParamsEndpoint(true),\n\t\tWithSigner(imagorpath.NewDefaultSigner(\"1234\")))\n\tr = httptest.NewRequest(\n\t\thttp.MethodGet, \"https://example.com/params/_-19cQt1szHeUV0WyWFntvTImDI=/foo.jpg\", nil)\n\tw = httptest.NewRecorder()\n\tapp.ServeHTTP(w, r)\n\tassert.Equal(t, 200, w.Code)\n\tassert.Empty(t, w.Body.String())\n}\n\nvar clock time.Time\n\ntype mapStore struct {\n\tl       sync.RWMutex\n\tMap     map[string]*Blob\n\tModTime map[string]time.Time\n\tLoadCnt map[string]int\n\tSaveCnt map[string]int\n\tDelCnt  map[string]int\n}\n\nfunc newMapStore() *mapStore {\n\treturn &mapStore{\n\t\tMap: map[string]*Blob{}, LoadCnt: map[string]int{}, SaveCnt: map[string]int{},\n\t\tDelCnt: map[string]int{}, ModTime: map[string]time.Time{},\n\t}\n}\n\nfunc (s *mapStore) Get(r *http.Request, image string) (*Blob, error) {\n\ts.l.RLock()\n\tdefer s.l.RUnlock()\n\tbuf, ok := s.Map[image]\n\tif !ok {\n\t\treturn nil, ErrNotFound\n\t}\n\tbuf.Stat, _ = s.Stat(r.Context(), image)\n\ts.LoadCnt[image] = s.LoadCnt[image] + 1\n\treturn buf, nil\n}\n\nfunc (s *mapStore) Put(ctx context.Context, image string, blob *Blob) error {\n\ts.l.Lock()\n\tdefer s.l.Unlock()\n\tclock = clock.Add(1)\n\ts.Map[image] = blob\n\ts.SaveCnt[image] = s.SaveCnt[image] + 1\n\ts.ModTime[image] = clock\n\treturn nil\n}\n\nfunc (s *mapStore) Delete(ctx context.Context, image string) error {\n\ts.l.Lock()\n\tdefer s.l.Unlock()\n\tdelete(s.Map, image)\n\ts.DelCnt[image] = s.DelCnt[image] + 1\n\treturn nil\n}\n\nfunc (s *mapStore) Stat(ctx context.Context, image string) (*Stat, error) {\n\ts.l.RLock()\n\tdefer s.l.RUnlock()\n\tt, ok := s.ModTime[image]\n\tif !ok {\n\t\treturn nil, ErrNotFound\n\t}\n\tb, ok := s.Map[image]\n\tif !ok {\n\t\treturn nil, ErrNotFound\n\t}\n\treturn &Stat{\n\t\tModifiedTime: t,\n\t\tSize:         b.Size(),\n\t}, nil\n}\n\nfunc TestWithLoadersStoragesProcessors(t *testing.T) {\n\tstore := newMapStore()\n\tresultStore := newMapStore()\n\tnewFakeBlob := func(str string) *Blob {\n\t\treturn NewBlob(func() (io.ReadCloser, int64, error) {\n\t\t\treturn io.NopCloser(bytes.NewReader([]byte(str))), 0, nil\n\t\t})\n\t}\n\tapp := New(\n\t\tWithDebug(true), WithLogger(zap.NewExample()),\n\t\tWithLoaders(\n\t\t\tloaderFunc(func(r *http.Request, image string) (*Blob, error) {\n\t\t\t\tif image == \"foo\" {\n\t\t\t\t\treturn newFakeBlob(\"bar\"), nil\n\t\t\t\t}\n\t\t\t\tif image == \"bar\" {\n\t\t\t\t\treturn newFakeBlob(\"foo\"), nil\n\t\t\t\t}\n\t\t\t\tif image == \"ping\" {\n\t\t\t\t\treturn newFakeBlob(\"pong\"), nil\n\t\t\t\t}\n\t\t\t\tif image == \"empty\" {\n\t\t\t\t\treturn nil, nil\n\t\t\t\t}\n\t\t\t\treturn nil, ErrNotFound\n\t\t\t}),\n\t\t\tloaderFunc(func(r *http.Request, image string) (*Blob, error) {\n\t\t\t\tif image == \"beep\" {\n\t\t\t\t\treturn newFakeBlob(\"boop\"), nil\n\t\t\t\t}\n\t\t\t\tif image == \"boom\" {\n\t\t\t\t\treturn nil, errors.New(\"unexpected error\")\n\t\t\t\t}\n\t\t\t\tif image == \"poop\" {\n\t\t\t\t\treturn newFakeBlob(\"poop\"), nil\n\t\t\t\t}\n\t\t\t\tif image == \"bond\" {\n\t\t\t\t\treturn newFakeBlob(\"bond\"), nil\n\t\t\t\t}\n\t\t\t\tif image == \"timeout\" {\n\t\t\t\t\treturn newFakeBlob(\"timeout\"), nil\n\t\t\t\t}\n\t\t\t\tif image == \"dood\" {\n\t\t\t\t\treturn newFakeBlob(\"dood\"), errors.New(\"error with value\")\n\t\t\t\t}\n\t\t\t\treturn nil, ErrNotFound\n\t\t\t}),\n\t\t),\n\t\tWithStorages(\n\t\t\tstore,\n\t\t\tsaverFunc(func(ctx context.Context, image string, buf *Blob) error {\n\t\t\t\ttime.Sleep(time.Millisecond * 2)\n\t\t\t\trequire.NotEqual(t, \"dood\", image, \"should not save error\")\n\t\t\t\tassert.Error(t, context.DeadlineExceeded, ctx.Err())\n\t\t\t\treturn ctx.Err()\n\t\t\t}),\n\t\t),\n\t\tWithResultStorages(resultStore),\n\t\tWithProcessors(\n\t\t\tprocessorFunc(func(ctx context.Context, blob *Blob, p imagorpath.Params, load LoadFunc) (*Blob, error) {\n\t\t\t\tbuf, _ := blob.ReadAll()\n\t\t\t\tif string(buf) == \"bar\" {\n\t\t\t\t\tp.Width = 167\n\t\t\t\t\treturn newFakeBlob(\"tar\"), ErrForward{p}\n\t\t\t\t}\n\t\t\t\tif string(buf) == \"poop\" {\n\t\t\t\t\tp.Height = 169\n\t\t\t\t\treturn nil, ErrForward{p}\n\t\t\t\t}\n\t\t\t\tif string(buf) == \"bond\" {\n\t\t\t\t\treturn nil, ErrInternal\n\t\t\t\t}\n\t\t\t\tif string(buf) == \"foo\" {\n\t\t\t\t\tfile, err := load(\"foo\")\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\treturn nil, err\n\t\t\t\t\t}\n\t\t\t\t\treturn file, err\n\t\t\t\t}\n\t\t\t\treturn blob, nil\n\t\t\t}),\n\t\t\tprocessorFunc(func(ctx context.Context, blob *Blob, p imagorpath.Params, load LoadFunc) (*Blob, error) {\n\t\t\t\tbuf, _ := blob.ReadAll()\n\t\t\t\tif string(buf) == \"tar\" {\n\t\t\t\t\tb := newFakeBlob(imagorpath.GeneratePath(p))\n\t\t\t\t\treturn b, nil\n\t\t\t\t}\n\t\t\t\tif string(buf) == \"poop\" {\n\t\t\t\t\tassert.Equal(t, 169, p.Height)\n\t\t\t\t\treturn nil, ErrForward{}\n\t\t\t\t}\n\t\t\t\tif string(buf) == \"bond\" {\n\t\t\t\t\treturn nil, ErrInvalid\n\t\t\t\t}\n\t\t\t\treturn blob, nil\n\t\t\t}),\n\t\t),\n\t\tWithSaveTimeout(time.Millisecond),\n\t\tWithProcessTimeout(time.Second),\n\t\tWithUnsafe(true),\n\t)\n\trequire.NoError(t, app.Startup(context.Background()))\n\tassert.Equal(t, time.Second, app.ProcessTimeout)\n\tassert.Equal(t, time.Millisecond, app.SaveTimeout)\n\tdefer require.NoError(t, app.Shutdown(context.Background()))\n\tt.Parallel()\n\tfor i := 0; i < 2; i++ {\n\t\tt.Run(fmt.Sprintf(\"ok %d\", i), func(t *testing.T) {\n\t\t\tw := httptest.NewRecorder()\n\t\t\tapp.ServeHTTP(w, httptest.NewRequest(\n\t\t\t\thttp.MethodGet, \"https://example.com/unsafe/foo\", nil))\n\t\t\ttime.Sleep(time.Millisecond * 10)\n\t\t\tassert.Equal(t, 200, w.Code)\n\t\t\tassert.Equal(t, \"167x0/foo\", w.Body.String())\n\n\t\t\tw = httptest.NewRecorder()\n\t\t\tapp.ServeHTTP(w, httptest.NewRequest(\n\t\t\t\thttp.MethodGet, \"https://example.com/unsafe/bar\", nil))\n\t\t\ttime.Sleep(time.Millisecond * 10)\n\t\t\tassert.Equal(t, 200, w.Code)\n\t\t\tassert.Equal(t, \"bar\", w.Body.String())\n\n\t\t\tw = httptest.NewRecorder()\n\t\t\tapp.ServeHTTP(w, httptest.NewRequest(\n\t\t\t\thttp.MethodGet, \"https://example.com/unsafe/ping\", nil))\n\t\t\ttime.Sleep(time.Millisecond * 10)\n\t\t\tassert.Equal(t, 200, w.Code)\n\t\t\tassert.Equal(t, \"pong\", w.Body.String())\n\t\t\ttime.Sleep(time.Millisecond * 10) // make sure storage reached\n\t\t\trequire.NotNil(t, store.Map[\"ping\"])\n\t\t\tbuf, err := store.Map[\"ping\"].ReadAll()\n\t\t\trequire.NoError(t, err)\n\t\t\tassert.Equal(t, \"pong\", string(buf))\n\t\t})\n\t\tt.Run(fmt.Sprintf(\"not found on empty path %d\", i), func(t *testing.T) {\n\t\t\tw := httptest.NewRecorder()\n\t\t\tapp.ServeHTTP(w, httptest.NewRequest(\n\t\t\t\thttp.MethodGet, \"https://example.com/unsafe/\", nil))\n\t\t\ttime.Sleep(time.Millisecond * 10)\n\t\t\tassert.Equal(t, 404, w.Code)\n\t\t\tassert.Equal(t, jsonStr(ErrNotFound), w.Body.String())\n\t\t})\n\t\tt.Run(fmt.Sprintf(\"empty %d\", i), func(t *testing.T) {\n\t\t\tw := httptest.NewRecorder()\n\t\t\tapp.ServeHTTP(w, httptest.NewRequest(\n\t\t\t\thttp.MethodGet, \"https://example.com/unsafe/empty\", nil))\n\t\t\ttime.Sleep(time.Millisecond * 10)\n\t\t\tassert.Equal(t, 404, w.Code)\n\t\t\tassert.Equal(t, jsonStr(ErrNotFound), w.Body.String())\n\t\t\tassert.Nil(t, store.Map[\"empty\"])\n\t\t})\n\t\tt.Run(fmt.Sprintf(\"not found on pass %d\", i), func(t *testing.T) {\n\t\t\tw := httptest.NewRecorder()\n\t\t\tapp.ServeHTTP(w, httptest.NewRequest(\n\t\t\t\thttp.MethodGet, \"https://example.com/unsafe/boooo\", nil))\n\t\t\ttime.Sleep(time.Millisecond * 10)\n\t\t\tassert.Equal(t, 404, w.Code)\n\t\t\tassert.Equal(t, jsonStr(ErrNotFound), w.Body.String())\n\t\t})\n\t\tt.Run(fmt.Sprintf(\"unexpected error %d\", i), func(t *testing.T) {\n\t\t\tw := httptest.NewRecorder()\n\t\t\tapp.ServeHTTP(w, httptest.NewRequest(\n\t\t\t\thttp.MethodGet, \"https://example.com/unsafe/boom\", nil))\n\t\t\ttime.Sleep(time.Millisecond * 10)\n\t\t\tassert.Equal(t, 500, w.Code)\n\t\t\tassert.Equal(t, jsonStr(NewError(\"unexpected error\", 500)), w.Body.String())\n\t\t\tassert.Nil(t, store.Map[\"boom\"])\n\t\t})\n\t\tt.Run(fmt.Sprintf(\"error with value %d\", i), func(t *testing.T) {\n\t\t\tw := httptest.NewRecorder()\n\t\t\tapp.ServeHTTP(w, httptest.NewRequest(\n\t\t\t\thttp.MethodGet, \"https://example.com/unsafe/dood\", nil))\n\t\t\ttime.Sleep(time.Millisecond * 10)\n\t\t\tassert.Equal(t, 500, w.Code)\n\t\t\tassert.Equal(t, jsonStr(NewError(\"error with value\", 500)), w.Body.String())\n\t\t\tassert.Nil(t, store.Map[\"dood\"])\n\t\t})\n\t\tt.Run(fmt.Sprintf(\"processor error return original %d\", i), func(t *testing.T) {\n\t\t\tw := httptest.NewRecorder()\n\t\t\tapp.ServeHTTP(w, httptest.NewRequest(\n\t\t\t\thttp.MethodGet, \"https://example.com/unsafe/poop\", nil))\n\t\t\ttime.Sleep(time.Millisecond * 10)\n\t\t\tassert.Equal(t, ErrUnsupportedFormat.Code, w.Code)\n\t\t\tassert.Equal(t, jsonStr(ErrUnsupportedFormat), w.Body.String())\n\t\t\tassert.Nil(t, store.Map[\"poop\"])\n\t\t})\n\t\tt.Run(fmt.Sprintf(\"processor error return last error %d\", i), func(t *testing.T) {\n\t\t\tw := httptest.NewRecorder()\n\t\t\tapp.ServeHTTP(w, httptest.NewRequest(\n\t\t\t\thttp.MethodGet, \"https://example.com/unsafe/bond\", nil))\n\t\t\ttime.Sleep(time.Millisecond * 10)\n\t\t\tassert.Equal(t, ErrInternal.Code, w.Code)\n\t\t\tassert.Equal(t, jsonStr(ErrInternal), w.Body.String())\n\t\t\tassert.Nil(t, store.Map[\"bond\"])\n\t\t})\n\t}\n}\n\nfunc TestWithResultStorageNotModified(t *testing.T) {\n\tresultStore := newMapStore()\n\tapp := New(\n\t\tWithDebug(true),\n\t\tWithLogger(zap.NewExample()),\n\t\tWithResultStorages(resultStore),\n\t\tWithLoaders(loaderFunc(func(r *http.Request, image string) (*Blob, error) {\n\t\t\treturn NewBlobFromBytes([]byte(image)), nil\n\t\t})),\n\t\tWithUnsafe(true),\n\t)\n\tw := httptest.NewRecorder()\n\tr := httptest.NewRequest(\n\t\thttp.MethodGet, \"https://example.com/unsafe/foo\", nil)\n\tapp.ServeHTTP(w, r)\n\ttime.Sleep(time.Millisecond * 10) // make sure storage reached\n\tassert.Equal(t, 200, w.Code)\n\tassert.Equal(t, \"foo\", w.Body.String())\n\tassert.Empty(t, w.Header().Get(\"ETag\"))\n\n\tw = httptest.NewRecorder()\n\tr = httptest.NewRequest(\n\t\thttp.MethodGet, \"https://example.com/unsafe/foo\", nil)\n\tapp.ServeHTTP(w, r)\n\tassert.Equal(t, 200, w.Code)\n\tassert.Equal(t, \"foo\", w.Body.String())\n\tetag := w.Header().Get(\"ETag\")\n\tlastModified := w.Header().Get(\"Last-Modified\")\n\tassert.NotEmpty(t, etag)\n\tassert.NotEmpty(t, lastModified)\n\n\tw = httptest.NewRecorder()\n\tr = httptest.NewRequest(\n\t\thttp.MethodGet, \"https://example.com/unsafe/foo\", nil)\n\tr.Header.Set(\"If-None-Match\", etag)\n\tapp.ServeHTTP(w, r)\n\tassert.Equal(t, 304, w.Code)\n\tassert.Empty(t, w.Body.String())\n\n\tw = httptest.NewRecorder()\n\tr = httptest.NewRequest(\n\t\thttp.MethodGet, \"https://example.com/unsafe/foo\", nil)\n\tr.Header.Set(\"If-None-Match\", etag)\n\tr.Header.Set(\"Cache-Control\", \"no-cache\")\n\tapp.ServeHTTP(w, r)\n\tassert.Equal(t, 200, w.Code)\n\tassert.Equal(t, \"foo\", w.Body.String())\n\n\tw = httptest.NewRecorder()\n\tr = httptest.NewRequest(\n\t\thttp.MethodGet, \"https://example.com/unsafe/foo\", nil)\n\tr.Header.Set(\"If-None-Match\", \"abcd\")\n\tapp.ServeHTTP(w, r)\n\tassert.Equal(t, 200, w.Code)\n\tassert.Equal(t, \"foo\", w.Body.String())\n\n\tw = httptest.NewRecorder()\n\tr = httptest.NewRequest(\n\t\thttp.MethodGet, \"https://example.com/unsafe/foo\", nil)\n\tr.Header.Set(\"If-Modified-Since\", clock.Add(time.Hour).Format(http.TimeFormat))\n\tapp.ServeHTTP(w, r)\n\tassert.Equal(t, 304, w.Code)\n\tassert.Empty(t, w.Body.String())\n\n\tw = httptest.NewRecorder()\n\tr = httptest.NewRequest(\n\t\thttp.MethodGet, \"https://example.com/unsafe/foo\", nil)\n\tr.Header.Set(\"If-Modified-Since\", time.Time{}.Format(http.TimeFormat))\n\tapp.ServeHTTP(w, r)\n\tassert.Equal(t, 200, w.Code)\n\tassert.Equal(t, \"foo\", w.Body.String())\n\n\tw = httptest.NewRecorder()\n\tr = httptest.NewRequest(\n\t\thttp.MethodGet, \"https://example.com/unsafe/foo\", nil)\n\tr.Header.Set(\"If-Unmodified-Since\", time.Time{}.Format(http.TimeFormat))\n\tapp.ServeHTTP(w, r)\n\tassert.Equal(t, 304, w.Code)\n\tassert.Empty(t, w.Body.String())\n}\n\ntype storageKeyFunc func(img string) string\n\nfunc (fn storageKeyFunc) Hash(img string) string {\n\treturn fn(img)\n}\n\ntype resultKeyFunc func(p imagorpath.Params) string\n\nfunc (fn resultKeyFunc) HashResult(p imagorpath.Params) string {\n\treturn fn(p)\n}\n\nfunc TestWithResultStorageHasher(t *testing.T) {\n\tstore := newMapStore()\n\tresultStore := newMapStore()\n\tapp := New(\n\t\tWithDebug(true), WithLogger(zap.NewExample()),\n\t\tWithStorages(store),\n\t\tWithResultStorages(resultStore),\n\t\tWithLoaders(loaderFunc(func(r *http.Request, image string) (*Blob, error) {\n\t\t\treturn NewBlobFromBytes([]byte(image)), nil\n\t\t})),\n\t\tWithResultStoragePathStyle(resultKeyFunc(func(p imagorpath.Params) string {\n\t\t\tif strings.Contains(p.Path, \"bar\") {\n\t\t\t\treturn \"\"\n\t\t\t}\n\t\t\treturn \"prefix:\" + strings.TrimPrefix(p.Path, \"meta/\")\n\t\t})),\n\t\tWithUnsafe(true),\n\t\tWithModifiedTimeCheck(true),\n\t)\n\tw := httptest.NewRecorder()\n\tapp.ServeHTTP(w, httptest.NewRequest(\n\t\thttp.MethodGet, \"https://example.com/unsafe/foo\", nil))\n\ttime.Sleep(time.Millisecond * 10) // make sure storage reached\n\tassert.Equal(t, 200, w.Code)\n\tassert.Equal(t, \"foo\", w.Body.String())\n\n\tw = httptest.NewRecorder()\n\tapp.ServeHTTP(w, httptest.NewRequest(\n\t\thttp.MethodGet, \"https://example.com/unsafe/foo\", nil))\n\ttime.Sleep(time.Millisecond * 10) // make sure storage reached\n\tassert.Equal(t, 200, w.Code)\n\tassert.Equal(t, \"foo\", w.Body.String())\n\n\tassert.Equal(t, 0, store.LoadCnt[\"foo\"])\n\tassert.Equal(t, 1, store.SaveCnt[\"foo\"])\n\tassert.Equal(t, 1, resultStore.LoadCnt[\"prefix:foo\"])\n\tassert.Equal(t, 1, resultStore.SaveCnt[\"prefix:foo\"])\n\tassert.Equal(t, 1, len(resultStore.LoadCnt))\n\tassert.Equal(t, 1, len(resultStore.SaveCnt))\n\n\tw = httptest.NewRecorder()\n\tapp.ServeHTTP(w, httptest.NewRequest(\n\t\thttp.MethodGet, \"https://example.com/unsafe/bar\", nil))\n\ttime.Sleep(time.Millisecond * 10) // make sure storage reached\n\tassert.Equal(t, 200, w.Code)\n\tassert.Equal(t, \"bar\", w.Body.String())\n\n\tw = httptest.NewRecorder()\n\tapp.ServeHTTP(w, httptest.NewRequest(\n\t\thttp.MethodGet, \"https://example.com/unsafe/bar\", nil))\n\ttime.Sleep(time.Millisecond * 10) // make sure storage reached\n\tassert.Equal(t, 200, w.Code)\n\tassert.Equal(t, \"bar\", w.Body.String())\n\n\tassert.Equal(t, 1, store.LoadCnt[\"bar\"])\n\tassert.Equal(t, 1, store.SaveCnt[\"bar\"])\n\tassert.Equal(t, 1, len(resultStore.LoadCnt))\n\tassert.Equal(t, 1, len(resultStore.SaveCnt))\n\n\tw = httptest.NewRecorder()\n\tapp.ServeHTTP(w, httptest.NewRequest(\n\t\thttp.MethodGet, \"https://example.com/unsafe/filters:preview()/hi\", nil))\n\ttime.Sleep(time.Millisecond * 10) // make sure storage reached\n\tassert.Equal(t, 200, w.Code)\n\tassert.Equal(t, \"hi\", w.Body.String())\n\n\tw = httptest.NewRecorder()\n\tapp.ServeHTTP(w, httptest.NewRequest(\n\t\thttp.MethodGet, \"https://example.com/unsafe/filters:preview()/hi\", nil))\n\ttime.Sleep(time.Millisecond * 10) // make sure storage reached\n\tassert.Equal(t, 200, w.Code)\n\tassert.Equal(t, \"hi\", w.Body.String())\n\n\tassert.Equal(t, 1, store.LoadCnt[\"hi\"])\n\tassert.Equal(t, 1, store.SaveCnt[\"hi\"])\n\tassert.Equal(t, 1, len(resultStore.LoadCnt))\n\tassert.Equal(t, 1, len(resultStore.SaveCnt))\n}\n\nfunc TestWithStorageHasher(t *testing.T) {\n\tvar loadCnt = map[string]int{}\n\tstore := newMapStore()\n\tapp := New(\n\t\tWithDebug(true), WithLogger(zap.NewExample()),\n\t\tWithStorages(store),\n\t\tWithLoaders(loaderFunc(func(r *http.Request, image string) (*Blob, error) {\n\t\t\tloadCnt[image]++\n\t\t\treturn NewBlobFromBytes([]byte(image)), nil\n\t\t})),\n\t\tWithStoragePathStyle(storageKeyFunc(func(img string) string {\n\t\t\tif img == \"bar\" {\n\t\t\t\treturn \"\"\n\t\t\t}\n\t\t\treturn \"storage:\" + img\n\t\t})),\n\t\tWithProcessors(processorFunc(func(ctx context.Context, blob *Blob, p imagorpath.Params, load LoadFunc) (*Blob, error) {\n\t\t\tif p.Image == \"err\" {\n\t\t\t\treturn nil, ErrInternal\n\t\t\t}\n\t\t\treturn blob, nil\n\t\t})),\n\t\tWithUnsafe(true),\n\t\tWithModifiedTimeCheck(true),\n\t)\n\tw := httptest.NewRecorder()\n\tapp.ServeHTTP(w, httptest.NewRequest(\n\t\thttp.MethodGet, \"https://example.com/unsafe/foo\", nil))\n\ttime.Sleep(time.Millisecond * 10) // make sure storage reached\n\tassert.Equal(t, 200, w.Code)\n\tassert.Equal(t, \"foo\", w.Body.String())\n\n\tw = httptest.NewRecorder()\n\tapp.ServeHTTP(w, httptest.NewRequest(\n\t\thttp.MethodGet, \"https://example.com/unsafe/foo\", nil))\n\ttime.Sleep(time.Millisecond * 10) // make sure storage reached\n\tassert.Equal(t, 200, w.Code)\n\tassert.Equal(t, \"foo\", w.Body.String())\n\n\tassert.Equal(t, 1, store.LoadCnt[\"storage:foo\"])\n\tassert.Equal(t, 1, store.SaveCnt[\"storage:foo\"])\n\n\tw = httptest.NewRecorder()\n\tapp.ServeHTTP(w, httptest.NewRequest(\n\t\thttp.MethodGet, \"https://example.com/unsafe/bar\", nil))\n\ttime.Sleep(time.Millisecond * 10) // make sure storage reached\n\tassert.Equal(t, 200, w.Code)\n\tassert.Equal(t, \"bar\", w.Body.String())\n\n\tw = httptest.NewRecorder()\n\tapp.ServeHTTP(w, httptest.NewRequest(\n\t\thttp.MethodGet, \"https://example.com/unsafe/bar\", nil))\n\ttime.Sleep(time.Millisecond * 10) // make sure storage reached\n\tassert.Equal(t, 200, w.Code)\n\tassert.Equal(t, \"bar\", w.Body.String())\n\n\tw = httptest.NewRecorder()\n\tapp.ServeHTTP(w, httptest.NewRequest(\n\t\thttp.MethodGet, \"https://example.com/unsafe/err\", nil))\n\ttime.Sleep(time.Millisecond * 10) // make sure storage reached\n\tassert.Equal(t, 500, w.Code)\n\tassert.Equal(t, jsonStr(ErrInternal), w.Body.String())\n\n\tassert.Equal(t, 0, store.LoadCnt[\"storage:bar\"])\n\tassert.Equal(t, 0, store.SaveCnt[\"storage:bar\"])\n\tassert.Equal(t, 1, len(store.LoadCnt))\n\tassert.Equal(t, 2, len(store.SaveCnt))\n\tassert.Equal(t, 1, len(store.DelCnt))\n\tassert.Equal(t, 1, loadCnt[\"foo\"], 1)\n\tassert.Equal(t, 2, loadCnt[\"bar\"], 2)\n\tassert.Equal(t, 1, store.DelCnt[\"storage:err\"])\n}\n\nfunc TestClientCancel(t *testing.T) {\n\tapp := New(\n\t\tWithDebug(true),\n\t\tWithUnsafe(true),\n\t\tWithLogger(zap.NewExample()),\n\t\tWithLoaders(loaderFunc(func(r *http.Request, image string) (*Blob, error) {\n\t\t\ttime.Sleep(time.Second)\n\t\t\treturn NewBlobFromBytes([]byte(image)), nil\n\t\t})),\n\t)\n\tfor i := 0; i < 5; i++ {\n\t\tctx, cancel := context.WithCancel(context.Background())\n\t\tgo func() {\n\t\t\ttime.Sleep(time.Millisecond)\n\t\t\tcancel()\n\t\t}()\n\t\tw := httptest.NewRecorder()\n\t\tr := httptest.NewRequest(http.MethodGet, \"https://example.com/unsafe/foo\", nil).WithContext(ctx)\n\t\tapp.ServeHTTP(w, r)\n\t\tassert.Equal(t, 499, w.Code)\n\t\tassert.Empty(t, w.Body.String())\n\t}\n}\n\nfunc TestWithProcessQueueSize(t *testing.T) {\n\tn := 20\n\tconn := 3\n\tsize := 6\n\tapp := New(\n\t\tWithDebug(true),\n\t\tWithUnsafe(true),\n\t\tWithLogger(zap.NewExample()),\n\t\tWithProcessQueueSize(int64(size)),\n\t\tWithProcessConcurrency(int64(conn)),\n\t\tWithLoaders(loaderFunc(func(r *http.Request, image string) (*Blob, error) {\n\t\t\ttime.Sleep(time.Millisecond * 10) // make sure storage reached\n\t\t\treturn NewBlobFromBytes([]byte(image)), nil\n\t\t})),\n\t)\n\tcnt := make(chan int, n)\n\tfor i := 0; i < n; i++ {\n\t\tgo func(i int) {\n\t\t\tw := httptest.NewRecorder()\n\t\t\tapp.ServeHTTP(w, httptest.NewRequest(\n\t\t\t\thttp.MethodGet, fmt.Sprintf(\"https://example.com/unsafe/%d\", i), nil))\n\t\t\t//fmt.Println(w.Body.String())\n\t\t\tcnt <- w.Code\n\t\t}(i)\n\t}\n\tresult := map[int]int{}\n\tfor i := 0; i < n; i++ {\n\t\tcode := <-cnt\n\t\tresult[code]++\n\t}\n\tassert.Equal(t, size+conn, result[200])\n\tassert.Equal(t, n-size-conn, result[429])\n}\n\nfunc TestWithProcessConcurrency(t *testing.T) {\n\tn := 5\n\tapp := New(\n\t\tWithDebug(true),\n\t\tWithUnsafe(true),\n\t\tWithLogger(zap.NewExample()),\n\t\tWithProcessConcurrency(1),\n\t\tWithRequestTimeout(time.Millisecond*13),\n\t\tWithLoaders(loaderFunc(func(r *http.Request, image string) (*Blob, error) {\n\t\t\ttime.Sleep(time.Millisecond * 10) // make sure storage reached\n\t\t\treturn NewBlobFromBytes([]byte(image)), nil\n\t\t})),\n\t)\n\tcnt := make(chan int, n)\n\tfor i := 0; i < n; i++ {\n\t\tgo func(i int) {\n\t\t\tw := httptest.NewRecorder()\n\t\t\tapp.ServeHTTP(w, httptest.NewRequest(\n\t\t\t\thttp.MethodGet, fmt.Sprintf(\"https://example.com/unsafe/%d\", i), nil))\n\t\t\tcnt <- w.Code\n\t\t}(i)\n\t}\n\tresult := map[int]int{}\n\tfor i := 0; i < n; i++ {\n\t\tcode := <-cnt\n\t\tresult[code]++\n\t}\n\tassert.Equal(t, 1, result[200])\n\tassert.Equal(t, 4, result[429])\n}\n\nfunc TestWithModifiedTimeCheck(t *testing.T) {\n\tstore := newMapStore()\n\tresultStore := newMapStore()\n\tapp := New(\n\t\tWithDebug(true), WithLogger(zap.NewExample()),\n\t\tWithStorages(store),\n\t\tWithResultStorages(resultStore),\n\t\tWithLoaders(loaderFunc(func(r *http.Request, image string) (*Blob, error) {\n\t\t\treturn NewBlobFromBytes([]byte(image)), nil\n\t\t})),\n\t\tWithUnsafe(true),\n\t\tWithModifiedTimeCheck(true),\n\t)\n\tw := httptest.NewRecorder()\n\tapp.ServeHTTP(w, httptest.NewRequest(\n\t\thttp.MethodGet, \"https://example.com/unsafe/foo\", nil))\n\ttime.Sleep(time.Millisecond * 10) // make sure storage reached\n\tassert.Equal(t, 200, w.Code)\n\tassert.Equal(t, \"foo\", w.Body.String())\n\tassert.Equal(t, 0, store.LoadCnt[\"foo\"])\n\tassert.Equal(t, 1, store.SaveCnt[\"foo\"])\n\tassert.Equal(t, 0, resultStore.LoadCnt[\"foo\"])\n\tassert.Equal(t, 1, resultStore.SaveCnt[\"foo\"])\n\n\tw = httptest.NewRecorder()\n\tapp.ServeHTTP(w, httptest.NewRequest(\n\t\thttp.MethodGet, \"https://example.com/unsafe/foo\", nil))\n\ttime.Sleep(time.Millisecond * 10) // make sure storage reached\n\tassert.Equal(t, 200, w.Code)\n\tassert.Equal(t, \"foo\", w.Body.String())\n\tassert.Equal(t, 0, store.LoadCnt[\"foo\"])\n\tassert.Equal(t, 1, store.SaveCnt[\"foo\"])\n\tassert.Equal(t, 1, resultStore.LoadCnt[\"foo\"])\n\tassert.Equal(t, 1, resultStore.SaveCnt[\"foo\"])\n\n\tclock = clock.Add(1)\n\tstore.ModTime[\"foo\"] = clock\n\n\tw = httptest.NewRecorder()\n\tapp.ServeHTTP(w, httptest.NewRequest(\n\t\thttp.MethodGet, \"https://example.com/unsafe/foo\", nil))\n\ttime.Sleep(time.Millisecond * 10) // make sure storage reached\n\tassert.Equal(t, 200, w.Code)\n\tassert.Equal(t, 1, store.LoadCnt[\"foo\"])\n\tassert.Equal(t, 1, store.SaveCnt[\"foo\"])\n\tassert.Equal(t, 2, resultStore.LoadCnt[\"foo\"])\n\tassert.Equal(t, 2, resultStore.SaveCnt[\"foo\"])\n}\n\nfunc TestWithSameStore(t *testing.T) {\n\tstore := newMapStore()\n\tapp := New(\n\t\tWithDebug(true), WithLogger(zap.NewExample()),\n\t\tWithLoaders(\n\t\t\tstore,\n\t\t\tloaderFunc(func(r *http.Request, image string) (*Blob, error) {\n\t\t\t\tif image == \"beep\" {\n\t\t\t\t\treturn NewBlobFromBytes([]byte(\"boop\")), nil\n\t\t\t\t}\n\t\t\t\treturn nil, ErrNotFound\n\t\t\t}),\n\t\t),\n\t\tWithStorages(store),\n\t\tWithSaveTimeout(time.Millisecond),\n\t\tWithProcessTimeout(time.Millisecond*2),\n\t\tWithUnsafe(true),\n\t)\n\tt.Run(\"should not save from same store\", func(t *testing.T) {\n\t\tn := 5\n\t\tfor i := 0; i < n; i++ {\n\t\t\tw := httptest.NewRecorder()\n\t\t\tapp.ServeHTTP(w, httptest.NewRequest(\n\t\t\t\thttp.MethodGet, \"https://example.com/unsafe/beep\", nil))\n\t\t\tassert.Equal(t, 200, w.Code)\n\t\t\tassert.Equal(t, \"boop\", w.Body.String())\n\t\t\ttime.Sleep(time.Millisecond * 10) // make sure storage reached\n\t\t}\n\t\tassert.Equal(t, n-1, store.LoadCnt[\"beep\"])\n\t\tassert.Equal(t, 1, store.SaveCnt[\"beep\"])\n\t})\n}\n\nfunc TestBaseParams(t *testing.T) {\n\tapp := New(\n\t\tWithDebug(true),\n\t\tWithUnsafe(true),\n\t\tWithBaseParams(\"filters:watermark(example.jpg)\"),\n\t\tWithLoaders(loaderFunc(func(r *http.Request, image string) (*Blob, error) {\n\t\t\treturn NewBlobFromBytes([]byte(\"foo\")), nil\n\t\t})),\n\t\tWithProcessors(processorFunc(func(ctx context.Context, blob *Blob, p imagorpath.Params, load LoadFunc) (*Blob, error) {\n\t\t\treturn NewBlobFromBytes([]byte(p.Path)), nil\n\t\t})),\n\t)\n\tw := httptest.NewRecorder()\n\tr := httptest.NewRequest(\n\t\thttp.MethodGet, \"https://example.com/unsafe/fit-in/200x0/filters:format(jpg)/abc.png\", nil)\n\tapp.ServeHTTP(w, r)\n\tassert.Equal(t, 200, w.Code)\n\tassert.Equal(t, \"fit-in/200x0/filters:format(jpg):watermark(example.jpg)/abc.png\", w.Body.String())\n}\n\nfunc TestAutoWebP(t *testing.T) {\n\tfactory := func(isAuto bool) *Imagor {\n\t\treturn New(\n\t\t\tWithDebug(true),\n\t\t\tWithUnsafe(true),\n\t\t\tWithAutoWebP(isAuto),\n\t\t\tWithLoaders(loaderFunc(func(r *http.Request, image string) (*Blob, error) {\n\t\t\t\treturn NewBlobFromBytes([]byte(\"foo\")), nil\n\t\t\t})),\n\t\t\tWithProcessors(processorFunc(func(ctx context.Context, blob *Blob, p imagorpath.Params, load LoadFunc) (*Blob, error) {\n\t\t\t\treturn NewBlobFromBytes([]byte(p.Path)), nil\n\t\t\t})),\n\t\t\tWithDebug(true))\n\t}\n\n\tt.Run(\"supported auto img tag not enabled\", func(t *testing.T) {\n\t\tapp := factory(false)\n\t\tw := httptest.NewRecorder()\n\t\tr := httptest.NewRequest(\n\t\t\thttp.MethodGet, \"https://example.com/unsafe/abc.png\", nil)\n\t\tr.Header.Set(\"Accept\", \"image/avif,image/webp,image/apng,image/svg+xml,image/*,*/*;q=0.8\")\n\t\tapp.ServeHTTP(w, r)\n\t\tassert.Equal(t, 200, w.Code)\n\t\tassert.Equal(t, w.Body.String(), \"abc.png\")\n\t})\n\tt.Run(\"supported auto img tag\", func(t *testing.T) {\n\t\tapp := factory(true)\n\t\tw := httptest.NewRecorder()\n\t\tr := httptest.NewRequest(\n\t\t\thttp.MethodGet, \"https://example.com/unsafe/abc.png\", nil)\n\t\tr.Header.Set(\"Accept\", \"image/avif,image/webp,image/apng,image/svg+xml,image/*,*/*;q=0.8\")\n\t\tapp.ServeHTTP(w, r)\n\t\tassert.Equal(t, 200, w.Code)\n\t\tassert.Equal(t, \"Accept\", w.Header().Get(\"Vary\"))\n\t\tassert.Equal(t, \"filters:format(webp)/abc.png\", w.Body.String())\n\t})\n\tt.Run(\"supported not image tag auto\", func(t *testing.T) {\n\t\tapp := factory(true)\n\t\tw := httptest.NewRecorder()\n\t\tr := httptest.NewRequest(\n\t\t\thttp.MethodGet, \"https://example.com/unsafe/abc.png\", nil)\n\t\tr.Header.Set(\"Accept\", \"text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*\")\n\t\tapp.ServeHTTP(w, r)\n\t\tassert.Equal(t, 200, w.Code)\n\t\tassert.Equal(t, \"Accept\", w.Header().Get(\"Vary\"))\n\t\tassert.Equal(t, w.Body.String(), \"filters:format(webp)/abc.png\")\n\t})\n\tt.Run(\"no supported no auto\", func(t *testing.T) {\n\t\tapp := factory(true)\n\t\tw := httptest.NewRecorder()\n\t\tr := httptest.NewRequest(\n\t\t\thttp.MethodGet, \"https://example.com/unsafe/abc.png\", nil)\n\t\tr.Header.Set(\"Accept\", \"image/apng,image/svg+xml,image/*,*/*;q=0.8\")\n\t\tapp.ServeHTTP(w, r)\n\t\tassert.Equal(t, 200, w.Code)\n\t\tassert.Equal(t, w.Body.String(), \"abc.png\")\n\t})\n\tt.Run(\"explicit format no auto\", func(t *testing.T) {\n\t\tapp := factory(true)\n\t\tw := httptest.NewRecorder()\n\t\tr := httptest.NewRequest(\n\t\t\thttp.MethodGet, \"https://example.com/unsafe/filters:format(jpg)/abc.png\", nil)\n\t\tr.Header.Set(\"Accept\", \"image/avif,image/webp,image/apng,image/svg+xml,image/*,*/*;q=0.8\")\n\t\tapp.ServeHTTP(w, r)\n\t\tassert.Equal(t, 200, w.Code)\n\t\tassert.Equal(t, w.Body.String(), \"filters:format(jpg)/abc.png\")\n\t})\n}\n\nfunc TestAutoAVIF(t *testing.T) {\n\tfactory := func(isAuto bool) *Imagor {\n\t\treturn New(\n\t\t\tWithDebug(true),\n\t\t\tWithUnsafe(true),\n\t\t\tWithAutoAVIF(isAuto),\n\t\t\tWithLoaders(loaderFunc(func(r *http.Request, image string) (*Blob, error) {\n\t\t\t\treturn NewBlobFromBytes([]byte(\"foo\")), nil\n\t\t\t})),\n\t\t\tWithProcessors(processorFunc(func(ctx context.Context, blob *Blob, p imagorpath.Params, load LoadFunc) (*Blob, error) {\n\t\t\t\treturn NewBlobFromBytes([]byte(p.Path)), nil\n\t\t\t})),\n\t\t\tWithDebug(true))\n\t}\n\n\tt.Run(\"supported auto img tag not enabled\", func(t *testing.T) {\n\t\tapp := factory(false)\n\t\tw := httptest.NewRecorder()\n\t\tr := httptest.NewRequest(\n\t\t\thttp.MethodGet, \"https://example.com/unsafe/abc.png\", nil)\n\t\tr.Header.Set(\"Accept\", \"image/avif,image/webp,image/apng,image/svg+xml,image/*,*/*;q=0.8\")\n\t\tapp.ServeHTTP(w, r)\n\t\tassert.Equal(t, 200, w.Code)\n\t\tassert.Equal(t, w.Body.String(), \"abc.png\")\n\t})\n\tt.Run(\"supported auto img tag\", func(t *testing.T) {\n\t\tapp := factory(true)\n\t\tw := httptest.NewRecorder()\n\t\tr := httptest.NewRequest(\n\t\t\thttp.MethodGet, \"https://example.com/unsafe/abc.png\", nil)\n\t\tr.Header.Set(\"Accept\", \"image/avif,image/webp,image/apng,image/svg+xml,image/*,*/*;q=0.8\")\n\t\tapp.ServeHTTP(w, r)\n\t\tassert.Equal(t, 200, w.Code)\n\t\tassert.Equal(t, \"Accept\", w.Header().Get(\"Vary\"))\n\t\tassert.Equal(t, w.Body.String(), \"filters:format(avif)/abc.png\")\n\t})\n\tt.Run(\"supported not image tag auto\", func(t *testing.T) {\n\t\tapp := factory(true)\n\t\tw := httptest.NewRecorder()\n\t\tr := httptest.NewRequest(\n\t\t\thttp.MethodGet, \"https://example.com/unsafe/abc.png\", nil)\n\t\tr.Header.Set(\"Accept\", \"text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*\")\n\t\tapp.ServeHTTP(w, r)\n\t\tassert.Equal(t, 200, w.Code)\n\t\tassert.Equal(t, \"Accept\", w.Header().Get(\"Vary\"))\n\t\tassert.Equal(t, w.Body.String(), \"filters:format(avif)/abc.png\")\n\t})\n\tt.Run(\"no supported no auto\", func(t *testing.T) {\n\t\tapp := factory(true)\n\t\tw := httptest.NewRecorder()\n\t\tr := httptest.NewRequest(\n\t\t\thttp.MethodGet, \"https://example.com/unsafe/abc.png\", nil)\n\t\tr.Header.Set(\"Accept\", \"image/apng,image/svg+xml,image/*,*/*;q=0.8\")\n\t\tapp.ServeHTTP(w, r)\n\t\tassert.Equal(t, 200, w.Code)\n\t\tassert.Equal(t, w.Body.String(), \"abc.png\")\n\t})\n\tt.Run(\"explicit format no auto\", func(t *testing.T) {\n\t\tapp := factory(true)\n\t\tw := httptest.NewRecorder()\n\t\tr := httptest.NewRequest(\n\t\t\thttp.MethodGet, \"https://example.com/unsafe/filters:format(jpg)/abc.png\", nil)\n\t\tr.Header.Set(\"Accept\", \"image/avif,image/webp,image/apng,image/svg+xml,image/*,*/*;q=0.8\")\n\t\tapp.ServeHTTP(w, r)\n\t\tassert.Equal(t, 200, w.Code)\n\t\tassert.Equal(t, w.Body.String(), \"filters:format(jpg)/abc.png\")\n\t})\n}\n\nfunc TestWithTimeout(t *testing.T) {\n\tts := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tif strings.Contains(r.URL.String(), \"sleep\") {\n\t\t\ttime.Sleep(time.Millisecond * 50)\n\t\t}\n\t\t_, _ = w.Write([]byte(\"ok\"))\n\t}))\n\tdefer ts.Close()\n\n\tloader := loaderFunc(func(r *http.Request, image string) (blob *Blob, err error) {\n\t\treq, err := http.NewRequestWithContext(r.Context(), http.MethodGet, image, nil)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tresp, err := http.DefaultClient.Do(req)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tbuf, err := io.ReadAll(resp.Body)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\treturn NewBlobFromBytes(buf), err\n\t})\n\n\ttests := []struct {\n\t\tname string\n\t\tapp  *Imagor\n\t}{\n\t\t{\n\t\t\tname: \"load timeout\",\n\t\t\tapp: New(\n\t\t\t\tWithUnsafe(true),\n\t\t\t\tWithLoadTimeout(time.Millisecond*10),\n\t\t\t\tWithLoaders(loader),\n\t\t\t),\n\t\t},\n\t\t{\n\t\t\tname: \"request timeout\",\n\t\t\tapp: New(\n\t\t\t\tWithUnsafe(true),\n\t\t\t\tWithRequestTimeout(time.Millisecond*10),\n\t\t\t\tWithLoaders(loader),\n\t\t\t),\n\t\t},\n\t\t{\n\t\t\tname: \"load timeout > request timeout\",\n\t\t\tapp: New(\n\t\t\t\tWithUnsafe(true),\n\t\t\t\tWithLoadTimeout(time.Millisecond*10),\n\t\t\t\tWithRequestTimeout(time.Millisecond*100),\n\t\t\t\tWithLoaders(loader),\n\t\t\t),\n\t\t},\n\t\t{\n\t\t\tname: \"load timeout < request timeout\",\n\t\t\tapp: New(\n\t\t\t\tWithUnsafe(true),\n\t\t\t\tWithLoadTimeout(time.Millisecond*100),\n\t\t\t\tWithRequestTimeout(time.Millisecond*10),\n\t\t\t\tWithLoaders(loader),\n\t\t\t),\n\t\t},\n\t\t{\n\t\t\tname: \"process timeout\",\n\t\t\tapp: New(\n\t\t\t\tWithUnsafe(true),\n\t\t\t\tWithRequestTimeout(time.Millisecond*10),\n\t\t\t\tWithLoaders(loaderFunc(func(r *http.Request, image string) (blob *Blob, err error) {\n\t\t\t\t\treturn NewBlobFromBytes([]byte(\"ok\")), nil\n\t\t\t\t})),\n\t\t\t\tWithProcessors(processorFunc(func(ctx context.Context, blob *Blob, p imagorpath.Params, load LoadFunc) (*Blob, error) {\n\t\t\t\t\tif strings.Contains(p.Path, \"sleep\") {\n\t\t\t\t\t\ttime.Sleep(time.Millisecond * 50)\n\t\t\t\t\t}\n\t\t\t\t\treturn blob, nil\n\t\t\t\t})),\n\t\t\t),\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(\"ok\", func(t *testing.T) {\n\t\t\tw := httptest.NewRecorder()\n\t\t\ttt.app.ServeHTTP(w, httptest.NewRequest(\n\t\t\t\thttp.MethodGet, fmt.Sprintf(\"https://example.com/unsafe/%s\", ts.URL), nil))\n\t\t\tassert.Equal(t, 200, w.Code)\n\t\t\tassert.Equal(t, w.Body.String(), \"ok\")\n\t\t})\n\t\tt.Run(\"timeout\", func(t *testing.T) {\n\t\t\tw := httptest.NewRecorder()\n\t\t\ttt.app.ServeHTTP(w, httptest.NewRequest(\n\t\t\t\thttp.MethodGet, fmt.Sprintf(\"https://example.com/unsafe/%s/sleep\", ts.URL), nil))\n\t\t\tassert.Equal(t, http.StatusRequestTimeout, w.Code)\n\t\t\tassert.Equal(t, w.Body.String(), jsonStr(ErrTimeout))\n\t\t})\n\t}\n}\n\nfunc TestSuppression(t *testing.T) {\n\tapp := New(\n\t\tWithDebug(true), WithLogger(zap.NewExample()),\n\t\tWithLoaders(\n\t\t\tloaderFunc(func(r *http.Request, image string) (*Blob, error) {\n\t\t\t\trandBytes := make([]byte, 100)\n\t\t\t\trand.Read(randBytes)\n\t\t\t\ttime.Sleep(time.Millisecond * 100)\n\t\t\t\treturn NewBlobFromBytes(randBytes), nil\n\t\t\t}),\n\t\t),\n\t\tWithUnsafe(true),\n\t)\n\tn := 10\n\ttype res struct {\n\t\tName string\n\t\tVal  string\n\t}\n\tresChan := make(chan res)\n\tdefer close(resChan)\n\tdo := func(image string) {\n\t\tw := httptest.NewRecorder()\n\t\tapp.ServeHTTP(w, httptest.NewRequest(\n\t\t\thttp.MethodGet, \"https://example.com/unsafe/\"+image, nil))\n\t\tassert.Equal(t, 200, w.Code)\n\t\tresChan <- res{image, w.Body.String()}\n\t}\n\tfor i := 0; i < n; i++ {\n\t\t// should suppress calls so every call of same image must be same value\n\t\t// though a and b must be different value\n\t\tgo do(\"a\")\n\t\tgo do(\"b\")\n\t}\n\tresMap := map[string]string{}\n\tfor i := 0; i < n*2; i++ {\n\t\tres := <-resChan\n\t\tif val, ok := resMap[res.Name]; ok {\n\t\t\tassert.Equal(t, val, res.Val)\n\t\t} else {\n\t\t\tresMap[res.Name] = res.Val\n\t\t}\n\t}\n\tassert.NotEqual(t, resMap[\"a\"], resMap[\"b\"])\n}\n\nfunc jsonStr(v interface{}) string {\n\tbuf, _ := json.Marshal(v)\n\treturn string(buf)\n}\n\ntype loaderFunc func(r *http.Request, image string) (blob *Blob, err error)\n\nfunc (f loaderFunc) Get(r *http.Request, image string) (*Blob, error) {\n\treturn f(r, image)\n}\n\ntype saverFunc func(ctx context.Context, image string, blob *Blob) error\n\nfunc (f saverFunc) Get(r *http.Request, image string) (*Blob, error) {\n\t// dummy\n\treturn nil, ErrNotFound\n}\n\nfunc (f saverFunc) Stat(ctx context.Context, image string) (*Stat, error) {\n\t// dummy\n\treturn nil, ErrNotFound\n}\n\nfunc (f saverFunc) Delete(ctx context.Context, image string) error {\n\t// dummy\n\treturn nil\n}\n\nfunc (f saverFunc) Put(ctx context.Context, image string, blob *Blob) error {\n\treturn f(ctx, image, blob)\n}\n\ntype processorFunc func(ctx context.Context, blob *Blob, p imagorpath.Params, load LoadFunc) (*Blob, error)\n\nfunc (f processorFunc) Process(ctx context.Context, blob *Blob, p imagorpath.Params, load LoadFunc) (*Blob, error) {\n\treturn f(ctx, blob, p, load)\n}\nfunc (f processorFunc) Startup(_ context.Context) error {\n\treturn nil\n}\nfunc (f processorFunc) Shutdown(_ context.Context) error {\n\treturn nil\n}\n"
        },
        {
          "name": "imagorpath",
          "type": "tree",
          "content": null
        },
        {
          "name": "loader",
          "type": "tree",
          "content": null
        },
        {
          "name": "metrics",
          "type": "tree",
          "content": null
        },
        {
          "name": "option.go",
          "type": "blob",
          "size": 5.123046875,
          "content": "package imagor\n\nimport (\n\t\"github.com/cshum/imagor/imagorpath\"\n\t\"go.uber.org/zap\"\n\t\"time\"\n)\n\n// Option imagor option\ntype Option func(app *Imagor)\n\n// WithOptions with nested options\nfunc WithOptions(options ...Option) Option {\n\treturn func(app *Imagor) {\n\t\tfor _, option := range options {\n\t\t\tif option != nil {\n\t\t\t\toption(app)\n\t\t\t}\n\t\t}\n\t}\n}\n\n// WithLogger with logger option\nfunc WithLogger(logger *zap.Logger) Option {\n\treturn func(app *Imagor) {\n\t\tif logger != nil {\n\t\t\tapp.Logger = logger\n\t\t}\n\t}\n}\n\n// WithLoaders with loaders option\nfunc WithLoaders(loaders ...Loader) Option {\n\treturn func(app *Imagor) {\n\t\tapp.Loaders = append(app.Loaders, loaders...)\n\t}\n}\n\n// WithStorages with storages option\nfunc WithStorages(savers ...Storage) Option {\n\treturn func(app *Imagor) {\n\t\tapp.Storages = append(app.Storages, savers...)\n\t}\n}\n\n// WithResultStorages with result storages option\nfunc WithResultStorages(savers ...Storage) Option {\n\treturn func(app *Imagor) {\n\t\tapp.ResultStorages = append(app.ResultStorages, savers...)\n\t}\n}\n\n// WithProcessors with processor option\nfunc WithProcessors(processors ...Processor) Option {\n\treturn func(app *Imagor) {\n\t\tapp.Processors = append(app.Processors, processors...)\n\t}\n}\n\n// WithRequestTimeout with request timeout option\nfunc WithRequestTimeout(timeout time.Duration) Option {\n\treturn func(app *Imagor) {\n\t\tif timeout > 0 {\n\t\t\tapp.RequestTimeout = timeout\n\t\t}\n\t}\n}\n\n// WithCacheHeaderTTL with browser cache header ttl option\nfunc WithCacheHeaderTTL(ttl time.Duration) Option {\n\treturn func(app *Imagor) {\n\t\tif ttl > 0 {\n\t\t\tapp.CacheHeaderTTL = ttl\n\t\t}\n\t}\n}\n\n// WithCacheHeaderSWR with browser cache header swr option\nfunc WithCacheHeaderSWR(swr time.Duration) Option {\n\treturn func(app *Imagor) {\n\t\tif swr > 0 {\n\t\t\tapp.CacheHeaderSWR = swr\n\t\t}\n\t}\n}\n\n// WithCacheHeaderNoCache with browser cache header no-cache option\nfunc WithCacheHeaderNoCache(nocache bool) Option {\n\treturn func(app *Imagor) {\n\t\tif nocache {\n\t\t\tapp.CacheHeaderTTL = 0\n\t\t}\n\t}\n}\n\n// WithLoadTimeout with load timeout option for loader and storage\nfunc WithLoadTimeout(timeout time.Duration) Option {\n\treturn func(app *Imagor) {\n\t\tif timeout > 0 {\n\t\t\tapp.LoadTimeout = timeout\n\t\t}\n\t}\n}\n\n// WithSaveTimeout with save timeout option for storage\nfunc WithSaveTimeout(timeout time.Duration) Option {\n\treturn func(app *Imagor) {\n\t\tif timeout > 0 {\n\t\t\tapp.SaveTimeout = timeout\n\t\t}\n\t}\n}\n\n// WithProcessTimeout with process timeout option for processor\nfunc WithProcessTimeout(timeout time.Duration) Option {\n\treturn func(app *Imagor) {\n\t\tif timeout > 0 {\n\t\t\tapp.ProcessTimeout = timeout\n\t\t}\n\t}\n}\n\n// WithProcessConcurrency maximum number of processor call to be executed simultaneously.\nfunc WithProcessConcurrency(concurrency int64) Option {\n\treturn func(app *Imagor) {\n\t\tif concurrency > 0 {\n\t\t\tapp.ProcessConcurrency = concurrency\n\t\t}\n\t}\n}\n\n// WithProcessQueueSize maximum number of processor call that can be put to a queue\nfunc WithProcessQueueSize(size int64) Option {\n\treturn func(app *Imagor) {\n\t\tif size > 0 {\n\t\t\tapp.ProcessQueueSize = size\n\t\t}\n\t}\n}\n\n// WithUnsafe with unsafe option\nfunc WithUnsafe(unsafe bool) Option {\n\treturn func(app *Imagor) {\n\t\tapp.Unsafe = unsafe\n\t}\n}\n\n// WithAutoWebP with auto WebP option based on browser Accept header\nfunc WithAutoWebP(enable bool) Option {\n\treturn func(app *Imagor) {\n\t\tapp.AutoWebP = enable\n\t}\n}\n\n// WithAutoAVIF experimental with auto AVIF option based on browser Accept header\nfunc WithAutoAVIF(enable bool) Option {\n\treturn func(app *Imagor) {\n\t\tapp.AutoAVIF = enable\n\t}\n}\n\n// WithBasePathRedirect with base path redirect option\nfunc WithBasePathRedirect(url string) Option {\n\treturn func(app *Imagor) {\n\t\tapp.BasePathRedirect = url\n\t}\n}\n\n// WithBaseParams with base params string option\nfunc WithBaseParams(params string) Option {\n\treturn func(app *Imagor) {\n\t\tapp.BaseParams = params\n\t}\n}\n\n// WithModifiedTimeCheck with option for modified time check of storage against result storage\nfunc WithModifiedTimeCheck(enabled bool) Option {\n\treturn func(app *Imagor) {\n\t\tapp.ModifiedTimeCheck = enabled\n\t}\n}\n\n// WithDisableErrorBody with disable error body option, resulting empty response on error\nfunc WithDisableErrorBody(disabled bool) Option {\n\treturn func(app *Imagor) {\n\t\tapp.DisableErrorBody = disabled\n\t}\n}\n\n// WithDisableParamsEndpoint with disable imagor /params endpoint\nfunc WithDisableParamsEndpoint(disabled bool) Option {\n\treturn func(app *Imagor) {\n\t\tapp.DisableParamsEndpoint = disabled\n\t}\n}\n\n// WithDebug with debug option\nfunc WithDebug(debug bool) Option {\n\treturn func(app *Imagor) {\n\t\tapp.Debug = debug\n\t}\n}\n\n// WithResultStoragePathStyle with result storage path style hasher option\nfunc WithResultStoragePathStyle(hasher imagorpath.ResultStorageHasher) Option {\n\treturn func(app *Imagor) {\n\t\tif hasher != nil {\n\t\t\tapp.ResultStoragePathStyle = hasher\n\t\t}\n\t}\n}\n\n// WithStoragePathStyle with storage path style hasher option\nfunc WithStoragePathStyle(hasher imagorpath.StorageHasher) Option {\n\treturn func(app *Imagor) {\n\t\tif hasher != nil {\n\t\t\tapp.StoragePathStyle = hasher\n\t\t}\n\t}\n}\n\n// WithSigner with URL signature signer option\nfunc WithSigner(signer imagorpath.Signer) Option {\n\treturn func(app *Imagor) {\n\t\tif signer != nil {\n\t\t\tapp.Signer = signer\n\t\t}\n\t}\n}\n"
        },
        {
          "name": "seekstream",
          "type": "tree",
          "content": null
        },
        {
          "name": "server",
          "type": "tree",
          "content": null
        },
        {
          "name": "storage",
          "type": "tree",
          "content": null
        },
        {
          "name": "testdata",
          "type": "tree",
          "content": null
        },
        {
          "name": "vips",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}