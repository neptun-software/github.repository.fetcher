{
  "metadata": {
    "timestamp": 1736566997746,
    "page": 580,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjU4MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "shunfei/cronsun",
      "stars": 2921,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".editorconfig",
          "type": "blob",
          "size": 0.1064453125,
          "content": "# for vscode extension[editorconfig]\nroot = true\n\n[*.{js,json,html,vue}]\nindent_style = space\nindent_size = 2"
        },
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.193359375,
          "content": "conf/files/*.json\ndist\n.tags\n.tags_sorted_by_file\nbin/*/*server\n.DS_Store\nweb/ui/node_modules\nweb/ui/package-lock.json\nweb/ui/semantic.json\nweb/ui/semantic\nweb/ui/dist\n.vscode\n*npm-debug.log\nvendor\n"
        },
        {
          "name": ".travis.yml",
          "type": "blob",
          "size": 0.21484375,
          "content": "language: go\ngo:\n- 1.11.x\nenv:\n- GO111MODULE=on\ninstall:\n- go mod vendor\n\nbefore_script:\n- go vet -v $(go list ./... | grep -v vendor)\n\nmatrix:\n  include:\n  - go: \"1.11.x\"\n    script: go test -v -race -mod=vendor ./...\n\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 10.501953125,
          "content": "                                 Apache License\n                           Version 2.0, January 2004\n                        http://www.apache.org/licenses/\n\n   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION\n\n   1. Definitions.\n\n      \"License\" shall mean the terms and conditions for use, reproduction,\n      and distribution as defined by Sections 1 through 9 of this document.\n\n      \"Licensor\" shall mean the copyright owner or entity authorized by\n      the copyright owner that is granting the License.\n\n      \"Legal Entity\" shall mean the union of the acting entity and all\n      other entities that control, are controlled by, or are under common\n      control with that entity. For the purposes of this definition,\n      \"control\" means (i) the power, direct or indirect, to cause the\n      direction or management of such entity, whether by contract or\n      otherwise, or (ii) ownership of fifty percent (50%) or more of the\n      outstanding shares, or (iii) beneficial ownership of such entity.\n\n      \"You\" (or \"Your\") shall mean an individual or Legal Entity\n      exercising permissions granted by this License.\n\n      \"Source\" form shall mean the preferred form for making modifications,\n      including but not limited to software source code, documentation\n      source, and configuration files.\n\n      \"Object\" form shall mean any form resulting from mechanical\n      transformation or translation of a Source form, including but\n      not limited to compiled object code, generated documentation,\n      and conversions to other media types.\n\n      \"Work\" shall mean the work of authorship, whether in Source or\n      Object form, made available under the License, as indicated by a\n      copyright notice that is included in or attached to the work\n      (an example is provided in the Appendix below).\n\n      \"Derivative Works\" shall mean any work, whether in Source or Object\n      form, that is based on (or derived from) the Work and for which the\n      editorial revisions, annotations, elaborations, or other modifications\n      represent, as a whole, an original work of authorship. For the purposes\n      of this License, Derivative Works shall not include works that remain\n      separable from, or merely link (or bind by name) to the interfaces of,\n      the Work and Derivative Works thereof.\n\n      \"Contribution\" shall mean any work of authorship, including\n      the original version of the Work and any modifications or additions\n      to that Work or Derivative Works thereof, that is intentionally\n      submitted to Licensor for inclusion in the Work by the copyright owner\n      or by an individual or Legal Entity authorized to submit on behalf of\n      the copyright owner. For the purposes of this definition, \"submitted\"\n      means any form of electronic, verbal, or written communication sent\n      to the Licensor or its representatives, including but not limited to\n      communication on electronic mailing lists, source code control systems,\n      and issue tracking systems that are managed by, or on behalf of, the\n      Licensor for the purpose of discussing and improving the Work, but\n      excluding communication that is conspicuously marked or otherwise\n      designated in writing by the copyright owner as \"Not a Contribution.\"\n\n      \"Contributor\" shall mean Licensor and any individual or Legal Entity\n      on behalf of whom a Contribution has been received by Licensor and\n      subsequently incorporated within the Work.\n\n   2. Grant of Copyright License. Subject to the terms and conditions of\n      this License, each Contributor hereby grants to You a perpetual,\n      worldwide, non-exclusive, no-charge, royalty-free, irrevocable\n      copyright license to reproduce, prepare Derivative Works of,\n      publicly display, publicly perform, sublicense, and distribute the\n      Work and such Derivative Works in Source or Object form.\n\n   3. Grant of Patent License. Subject to the terms and conditions of\n      this License, each Contributor hereby grants to You a perpetual,\n      worldwide, non-exclusive, no-charge, royalty-free, irrevocable\n      (except as stated in this section) patent license to make, have made,\n      use, offer to sell, sell, import, and otherwise transfer the Work,\n      where such license applies only to those patent claims licensable\n      by such Contributor that are necessarily infringed by their\n      Contribution(s) alone or by combination of their Contribution(s)\n      with the Work to which such Contribution(s) was submitted. If You\n      institute patent litigation against any entity (including a\n      cross-claim or counterclaim in a lawsuit) alleging that the Work\n      or a Contribution incorporated within the Work constitutes direct\n      or contributory patent infringement, then any patent licenses\n      granted to You under this License for that Work shall terminate\n      as of the date such litigation is filed.\n\n   4. Redistribution. You may reproduce and distribute copies of the\n      Work or Derivative Works thereof in any medium, with or without\n      modifications, and in Source or Object form, provided that You\n      meet the following conditions:\n\n      (a) You must give any other recipients of the Work or\n          Derivative Works a copy of this License; and\n\n      (b) You must cause any modified files to carry prominent notices\n          stating that You changed the files; and\n\n      (c) You must retain, in the Source form of any Derivative Works\n          that You distribute, all copyright, patent, trademark, and\n          attribution notices from the Source form of the Work,\n          excluding those notices that do not pertain to any part of\n          the Derivative Works; and\n\n      (d) If the Work includes a \"NOTICE\" text file as part of its\n          distribution, then any Derivative Works that You distribute must\n          include a readable copy of the attribution notices contained\n          within such NOTICE file, excluding those notices that do not\n          pertain to any part of the Derivative Works, in at least one\n          of the following places: within a NOTICE text file distributed\n          as part of the Derivative Works; within the Source form or\n          documentation, if provided along with the Derivative Works; or,\n          within a display generated by the Derivative Works, if and\n          wherever such third-party notices normally appear. The contents\n          of the NOTICE file are for informational purposes only and\n          do not modify the License. You may add Your own attribution\n          notices within Derivative Works that You distribute, alongside\n          or as an addendum to the NOTICE text from the Work, provided\n          that such additional attribution notices cannot be construed\n          as modifying the License.\n\n      You may add Your own copyright statement to Your modifications and\n      may provide additional or different license terms and conditions\n      for use, reproduction, or distribution of Your modifications, or\n      for any such Derivative Works as a whole, provided Your use,\n      reproduction, and distribution of the Work otherwise complies with\n      the conditions stated in this License.\n\n   5. Submission of Contributions. Unless You explicitly state otherwise,\n      any Contribution intentionally submitted for inclusion in the Work\n      by You to the Licensor shall be under the terms and conditions of\n      this License, without any additional terms or conditions.\n      Notwithstanding the above, nothing herein shall supersede or modify\n      the terms of any separate license agreement you may have executed\n      with Licensor regarding such Contributions.\n\n   6. Trademarks. This License does not grant permission to use the trade\n      names, trademarks, service marks, or product names of the Licensor,\n      except as required for reasonable and customary use in describing the\n      origin of the Work and reproducing the content of the NOTICE file.\n\n   7. Disclaimer of Warranty. Unless required by applicable law or\n      agreed to in writing, Licensor provides the Work (and each\n      Contributor provides its Contributions) on an \"AS IS\" BASIS,\n      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n      implied, including, without limitation, any warranties or conditions\n      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A\n      PARTICULAR PURPOSE. You are solely responsible for determining the\n      appropriateness of using or redistributing the Work and assume any\n      risks associated with Your exercise of permissions under this License.\n\n   8. Limitation of Liability. In no event and under no legal theory,\n      whether in tort (including negligence), contract, or otherwise,\n      unless required by applicable law (such as deliberate and grossly\n      negligent acts) or agreed to in writing, shall any Contributor be\n      liable to You for damages, including any direct, indirect, special,\n      incidental, or consequential damages of any character arising as a\n      result of this License or out of the use or inability to use the\n      Work (including but not limited to damages for loss of goodwill,\n      work stoppage, computer failure or malfunction, or any and all\n      other commercial damages or losses), even if such Contributor\n      has been advised of the possibility of such damages.\n\n   9. Accepting Warranty or Additional Liability. While redistributing\n      the Work or Derivative Works thereof, You may choose to offer,\n      and charge a fee for, acceptance of support, warranty, indemnity,\n      or other liability obligations and/or rights consistent with this\n      License. However, in accepting such obligations, You may act only\n      on Your own behalf and on Your sole responsibility, not on behalf\n      of any other Contributor, and only if You agree to indemnify,\n      defend, and hold each Contributor harmless for any liability\n      incurred by, or claims asserted against, such Contributor by reason\n      of your accepting any such warranty or additional liability.\n\n   END OF TERMS AND CONDITIONS\n\n\n   Copyright 2017 Sunteng\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n       http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 3.373046875,
          "content": "# cronsun [![Build Status](https://travis-ci.org/shunfei/cronsun.svg?branch=master)](https://travis-ci.org/shunfei/cronsun)\n\n`cronsun` is a distributed cron-style job system. It's similar with `crontab` on stand-alone `*nix`.\n\n[简体中文](README_ZH.md)\n\n## Purpose\n\nThe goal of this project is to make it much easier to manage jobs on lots of machines and provides high availability.\n`cronsun` is different from [Azkaban](https://azkaban.github.io/), [Chronos](https://mesos.github.io/chronos/), [Airflow](https://airflow.incubator.apache.org/).\n\n## Features\n\n- Easy manage jobs on multiple machines\n- Management panel\n- Mail service\n- Multi-language support\n- Simple authentication and accounts manager(default administrator email and password: admin@admin.com/admin)\n\n## Status\n\n`cronsun` has been tested in production for years on hundreds of servers. \nAlthough the current version is not release as an stable version, but we think it is completely available for the production environment.\nWe encourage you to try it, it's easy to use, see how it works for you. We believe you will like this tool.\n\n\n## Architecture\n\n```\n                                                [web]\n                                                  |\n                                     --------------------------\n           (add/del/update/exec jobs)|                        |(query job exec result)\n                                   [etcd]                 [mongodb]\n                                     |                        ^\n                            --------------------              |\n                            |        |         |              |\n                         [node.1]  [node.2]  [node.n]         |\n             (job exec fail)|        |         |              |\n          [send mail]<-----------------------------------------(job exec result)\n\n```\n\n\n## Security\n\n`cronsun` support security with `security.json` config. When `open=true`， job command is only allow local files with special extension on the node.\n\n```json\n{\n    \"open\": true,\n    \"#users\": \"allowed execution users\",\n    \"users\": [\n        \"www\", \"db\"\n    ],\n    \"#ext\": \"allowed execution file extensions\",\n    \"ext\": [\n        \".cron.sh\", \".cron.py\"\n    ]\n}\n```\n\n## Getting started\n\n### Setup / installation\n\nInstall from binary [latest release](https://github.com/shunfei/cronsun/releases/latest)\n\nOr build from source, require `go >= 1.11+`.\n> NOTE: The branch `master` is not in stable, using Cronsun for production please checkout corresponding tags.\n\n```\nexport GO111MODULE=on\ngo get -u github.com/shunfei/cronsun\ncd $GOPATH/src/github.com/shunfei/cronsun\ngo mod vendor\nsh build.sh\n```\n\n### Run\n\n1. Install [MongoDB](http://docs.mongodb.org/manual/installation/)\n2. Install [etcd3](https://github.com/coreos/etcd)\n3. Open and update Etcd(`conf/etcd.json`) and MongoDB(`conf/db.json`) configurations\n4. Start cronnode: `./cronnode -conf conf/base.json`, start cronweb: `./cronweb -conf conf/base.json`\n5. Open `http://127.0.0.1:7079` in browser\n6. Login with username `admin@admin.com` and password `admin`\n\n## Screenshot\n\n**Brief**:\n\n![](doc/img/Cronsun_dashboard_en.png)\n\n**Exec result**:\n\n![](doc/img/Cronsun_log_list_en.png)\n![](doc/img/Cronsun_log_item_en.png)\n\n**Job**:\n\n![](doc/img/Cronsun_job_list_en.png)\n\n![](doc/img/Cronsun_job_new_en.png)\n\n**Node**:\n\n![](doc/img/Cronsun_node_en.png)\n\n## Credits\n\ncron is base on [robfig/cron](https://github.com/robfig/cron)\n"
        },
        {
          "name": "README_ZH.md",
          "type": "blob",
          "size": 4.3955078125,
          "content": "# cronsun [![Build Status](https://travis-ci.org/shunfei/cronsun.svg?branch=master)](https://travis-ci.org/shunfei/cronsun)\n\n`cronsun` 是一个分布式任务系统，单个节点和 `*nix` 机器上的 `crontab` 近似。支持界面管理机器上的任务，支持任务失败邮件提醒，安装简单，使用方便，是替换 `crontab` 一个不错的选择。\n\n`cronsun` 是为了解决多台 `*nix` 机器上`crontab` 任务管理不方便的问题，同时提供任务高可用的支持（当某个节点死机的时候可以自动调度到正常的节点执行）。`cronsun` 和 [Azkaban](https://azkaban.github.io/)、[Chronos](https://mesos.github.io/chronos/)、[Airflow](https://airflow.incubator.apache.org/) 这些不是同一类型的。\n\n> QQ交流群： 123731057\n\n## 项目状态\n\n`cronsun`已经在线上几百台规模的服务器上面稳定运行了一年多了，虽然目前版本不是正式版，但是我们认为是完全可以用于生产环境的。强烈建议你试用下，因为它非常简单易用，同时感受下他的强大，相信你会喜欢上这个工具的。\n\n\n## 特性\n\n- 方便对多台服务器上面的定时任务进行集中式管理\n- 任务调度时间粒度支持到`秒`级别\n- 任务失败自动重试\n- 任务可靠性保障（从N个节点里面挑一个可用节点来执行任务）\n- 简洁易用的管理后台，支持多语言\n- 任务日志查看\n- 任务失败邮件告警（也支持自定义http告警接口）\n- 用户验证与授权 (默认账号密码: admin@admin.com / admin)\n- [可靠性说明](https://github.com/shunfei/cronsun/wiki/%E5%8F%AF%E9%9D%A0%E6%80%A7%E8%AF%B4%E6%98%8E)\n\n\n## 架构\n\n```\n                                                [web]\n                                                  |\n                                     --------------------------\n           (add/del/update/exec jobs)|                        |(query job exec result)\n                                   [etcd]                 [mongodb]\n                                     |                        ^\n                            --------------------              |\n                            |        |         |              |\n                         [node.1]  [node.2]  [node.n]         |\n             (job exec fail)|        |         |              |\n          [send mail]<-----------------------------------------(job exec result)\n\n```\n\n\n## 安全性\n\n`cronsun`是在管理后台添加任务的，所以一旦管理后台泄露出去了，则存在一定的危险性，所以`cronsun`支持`security.json`的安全设置：\n\n```json\n{\n    \"open\": true,\n    \"#users\": \"允许选择运行脚本的用户\",\n    \"users\": [\n        \"www\", \"db\"\n    ],\n    \"#ext\": \"允许添加以下扩展名结束的脚本\",\n    \"ext\": [\n        \".cron.sh\", \".cron.py\"\n    ]\n}\n```\n\n如上设置开启安全限制，则添加和执行任务的时候只允许选择配置里面指定的用户来执行脚本，并且脚本的扩展名要在配置的脚本扩展名限制列表里面。\n\n\n## 开始\n\n### 安装\n\n直接下载执行文件 [latest release](https://github.com/shunfei/cronsun/releases/latest)。\n\n如果你熟悉 `Go`，也可以从源码编译, 要求 `go >= 1.11+`\n\n```\ngo get -u github.com/shunfei/cronsun\ncd $GOPATH/src/github.com/shunfei/cronsun\ngo mod vendor\n# 如果 go mod vendor 下载失败，请尝试 https://goproxy.io\nsh build.sh\n```\n\n### 运行\n\n1. 安装 [MongoDB](http://docs.mongodb.org/manual/installation/)\n2. 安装 [etcd3](https://github.com/coreos/etcd)\n3. 修改 `conf` 相关的配置\n4. 在任务结点启动 `./cronnode -conf conf/base.json`，在管理结点启动 `./cronweb -conf conf/base.json`\n5. 访问管理界面 `http://127.0.0.1:7079/ui/`\n6. 使用用户名 `admin@admin.com` 和密码 `admin` 进行登录\n\n### 关于后台权限\n\n当前实现了一个可选的简单登录认证和帐号管理的功能（首次启用之后默认管理员的邮箱密码是 admin@admin.com/admin），没有详细的权限管理功能。登录控制也可以考虑使用 [aproxy](https://github.com/shunfei/aproxy) ，相关介绍见 [aProxy: 带认证授权和权限控制的反向代理](http://www.cnblogs.com/QLeelulu/p/aproxy.html)。\n\n## 截图\n\n**概要**:\n\n![](doc/img/brief.png)\n\n**执行日志**:\n\n![](doc/img/log.png)\n\n**任务管理**:\n\n![](doc/img/job.png)\n\n![](doc/img/new_job.png)\n\n**结点状态**:\n\n![](doc/img/node.png)\n\n## 致谢\n\ncron is base on [robfig/cron](https://github.com/robfig/cron)\n"
        },
        {
          "name": "account.go",
          "type": "blob",
          "size": 2.2890625,
          "content": "package cronsun\n\nimport (\n\t\"time\"\n\n\t\"gopkg.in/mgo.v2\"\n\t\"gopkg.in/mgo.v2/bson\"\n)\n\nconst (\n\tColl_Account = \"account\"\n)\n\ntype Account struct {\n\tID       bson.ObjectId `bson:\"_id\" json:\"id\"`\n\tRole     Role          `bson:\"role\" json:\"role\"`\n\tEmail    string        `bson:\"email\" json:\"email\"`\n\tPassword string        `bson:\"password\" json:\"password\"`\n\tSalt     string        `bson:\"salt\" json:\"salt\"`\n\tStatus   UserStatus    `bson:\"status\" json:\"status\"`\n\tSession  string        `bson:\"session\" json:\"-\"`\n\t// If true, role and status are unchangeable, email and password can be change by it self only.\n\tUnchangeable bool      `bson:\"unchangeable\" json:\"-\"`\n\tCreateTime   time.Time `bson:\"createTime\" json:\"createTime\"`\n}\n\ntype Role int\n\nconst (\n\tAdministrator Role = 1\n\tDeveloper     Role = 2\n\tReporter      Role = 3\n)\n\nfunc (r Role) Defined() bool {\n\tswitch r {\n\tcase Administrator, Developer, Reporter:\n\t\treturn true\n\t}\n\treturn false\n}\n\nfunc (r Role) String() string {\n\tswitch r {\n\tcase Administrator:\n\t\treturn \"Administrator\"\n\tcase Developer:\n\t\treturn \"Developer\"\n\tcase Reporter:\n\t\treturn \"Reporter\"\n\t}\n\treturn \"Undefined\"\n}\n\ntype UserStatus int\n\nconst (\n\tUserBanned  UserStatus = -1\n\tUserActived UserStatus = 1\n)\n\nfunc (s UserStatus) Defined() bool {\n\tswitch s {\n\tcase UserBanned, UserActived:\n\t\treturn true\n\t}\n\treturn false\n}\n\nfunc GetAccounts(query bson.M) (list []Account, err error) {\n\terr = mgoDB.WithC(Coll_Account, func(c *mgo.Collection) error {\n\t\treturn c.Find(query).All(&list)\n\t})\n\treturn\n}\n\nfunc GetAccountByEmail(email string) (u *Account, err error) {\n\terr = mgoDB.FindOne(Coll_Account, bson.M{\"email\": email}, &u)\n\treturn\n}\n\nfunc CreateAccount(u *Account) error {\n\tu.ID = bson.NewObjectId()\n\tu.CreateTime = time.Now()\n\treturn mgoDB.Insert(Coll_Account, u)\n\n}\n\nfunc UpdateAccount(query bson.M, change bson.M) error {\n\treturn mgoDB.WithC(Coll_Account, func(c *mgo.Collection) error {\n\t\treturn c.Update(query, bson.M{\"$set\": change})\n\t})\n}\n\nfunc BanAccount(email string) error {\n\treturn mgoDB.WithC(Coll_Account, func(c *mgo.Collection) error {\n\t\treturn c.Update(bson.M{\"email\": email}, bson.M{\"$set\": bson.M{\"status\": UserBanned}})\n\t})\n}\n\nfunc EnsureAccountIndex() error {\n\treturn mgoDB.WithC(Coll_Account, func(c *mgo.Collection) error {\n\t\treturn c.EnsureIndex(mgo.Index{\n\t\t\tKey:    []string{\"email\"},\n\t\t\tUnique: true,\n\t\t})\n\t})\n}\n"
        },
        {
          "name": "bin",
          "type": "tree",
          "content": null
        },
        {
          "name": "build.sh",
          "type": "blob",
          "size": 0.548828125,
          "content": "#!/bin/sh\n\nfunction check_code() {\n\tEXCODE=$?\n\tif [ \"$EXCODE\" != \"0\" ]; then\n\t\techo \"build fail.\"\n\t\texit $EXCODE\n\tfi\n}\n\nout=\"dist\"\necho \"build file to ./$out\"\n\nmkdir -p \"$out/conf\"\n\ngo build -o ./$out/cronnode ./bin/node/server.go\ncheck_code\ngo build -o ./$out/cronweb ./bin/web/server.go\ncheck_code\ngo build -o ./$out/csctl ./bin/csctl/cmd.go\ncheck_code\n\nsources=`find ./conf/files -name \"*.json.sample\"`\ncheck_code\nfor source in $sources;do\n\tyes | echo $source|sed \"s/.*\\/\\(.*\\.json\\).*/cp -f & .\\/$out\\/conf\\/\\1/\"|bash\n\tcheck_code\ndone\n\necho \"build success.\"\n"
        },
        {
          "name": "client.go",
          "type": "blob",
          "size": 3.4140625,
          "content": "package cronsun\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"strings\"\n\t\"time\"\n\n\tclient \"github.com/coreos/etcd/clientv3\"\n\n\t\"github.com/shunfei/cronsun/conf\"\n)\n\nvar (\n\tDefalutClient *Client\n)\n\ntype Client struct {\n\t*client.Client\n\n\treqTimeout time.Duration\n}\n\nfunc NewClient(cfg *conf.Conf) (c *Client, err error) {\n\tcli, err := client.New(cfg.Etcd.Copy())\n\tif err != nil {\n\t\treturn\n\t}\n\n\tc = &Client{\n\t\tClient: cli,\n\n\t\treqTimeout: time.Duration(cfg.ReqTimeout) * time.Second,\n\t}\n\treturn\n}\n\nfunc (c *Client) Put(key, val string, opts ...client.OpOption) (*client.PutResponse, error) {\n\tctx, cancel := NewEtcdTimeoutContext(c)\n\tdefer cancel()\n\treturn c.Client.Put(ctx, key, val, opts...)\n}\n\nfunc (c *Client) PutWithModRev(key, val string, rev int64) (*client.PutResponse, error) {\n\tif rev == 0 {\n\t\treturn c.Put(key, val)\n\t}\n\n\tctx, cancel := NewEtcdTimeoutContext(c)\n\ttresp, err := DefalutClient.Txn(ctx).\n\t\tIf(client.Compare(client.ModRevision(key), \"=\", rev)).\n\t\tThen(client.OpPut(key, val)).\n\t\tCommit()\n\tcancel()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif !tresp.Succeeded {\n\t\treturn nil, ErrValueMayChanged\n\t}\n\n\tresp := client.PutResponse(*tresp.Responses[0].GetResponsePut())\n\treturn &resp, nil\n}\n\nfunc (c *Client) Get(key string, opts ...client.OpOption) (*client.GetResponse, error) {\n\tctx, cancel := NewEtcdTimeoutContext(c)\n\tdefer cancel()\n\treturn c.Client.Get(ctx, key, opts...)\n}\n\nfunc (c *Client) Delete(key string, opts ...client.OpOption) (*client.DeleteResponse, error) {\n\tctx, cancel := NewEtcdTimeoutContext(c)\n\tdefer cancel()\n\treturn c.Client.Delete(ctx, key, opts...)\n}\n\nfunc (c *Client) Watch(key string, opts ...client.OpOption) client.WatchChan {\n\treturn c.Client.Watch(context.Background(), key, opts...)\n}\n\nfunc (c *Client) Grant(ttl int64) (*client.LeaseGrantResponse, error) {\n\tctx, cancel := NewEtcdTimeoutContext(c)\n\tdefer cancel()\n\treturn c.Client.Grant(ctx, ttl)\n}\n\nfunc (c *Client) Revoke(id client.LeaseID) (*client.LeaseRevokeResponse, error) {\n\tctx, cancel := context.WithTimeout(context.Background(), c.reqTimeout)\n\tdefer cancel()\n\treturn c.Client.Revoke(ctx, id)\n}\n\nfunc (c *Client) KeepAliveOnce(id client.LeaseID) (*client.LeaseKeepAliveResponse, error) {\n\tctx, cancel := NewEtcdTimeoutContext(c)\n\tdefer cancel()\n\treturn c.Client.KeepAliveOnce(ctx, id)\n}\n\nfunc (c *Client) GetLock(key string, id client.LeaseID) (bool, error) {\n\tkey = conf.Config.Lock + key\n\tctx, cancel := NewEtcdTimeoutContext(c)\n\tresp, err := DefalutClient.Txn(ctx).\n\t\tIf(client.Compare(client.CreateRevision(key), \"=\", 0)).\n\t\tThen(client.OpPut(key, \"\", client.WithLease(id))).\n\t\tCommit()\n\tcancel()\n\n\tif err != nil {\n\t\treturn false, err\n\t}\n\n\treturn resp.Succeeded, nil\n}\n\nfunc (c *Client) DelLock(key string) error {\n\t_, err := c.Delete(conf.Config.Lock + key)\n\treturn err\n}\n\nfunc IsValidAsKeyPath(s string) bool {\n\treturn strings.IndexAny(s, \"/\\\\\") == -1\n}\n\n// etcdTimeoutContext return better error info\ntype etcdTimeoutContext struct {\n\tcontext.Context\n\n\tetcdEndpoints []string\n}\n\nfunc (c *etcdTimeoutContext) Err() error {\n\terr := c.Context.Err()\n\tif err == context.DeadlineExceeded {\n\t\terr = fmt.Errorf(\"%s: etcd(%v) maybe lost\",\n\t\t\terr, c.etcdEndpoints)\n\t}\n\treturn err\n}\n\n// NewEtcdTimeoutContext return a new etcdTimeoutContext\nfunc NewEtcdTimeoutContext(c *Client) (context.Context, context.CancelFunc) {\n\tctx, cancel := context.WithTimeout(context.Background(), c.reqTimeout)\n\tetcdCtx := &etcdTimeoutContext{}\n\tetcdCtx.Context = ctx\n\tetcdCtx.etcdEndpoints = c.Endpoints()\n\treturn etcdCtx, cancel\n}\n"
        },
        {
          "name": "common.go",
          "type": "blob",
          "size": 0.869140625,
          "content": "package cronsun\n\nimport (\n\t\"fmt\"\n\t\"os\"\n\n\t\"github.com/shunfei/cronsun/conf\"\n\t\"github.com/shunfei/cronsun/db\"\n)\n\nvar (\n\tinitialized bool\n\n\t_Uid int\n)\n\nfunc Init(baseConfFile string, watchConfiFile bool) (err error) {\n\tif initialized {\n\t\treturn\n\t}\n\n\t// init id creator\n\tif err = initID(); err != nil {\n\t\treturn fmt.Errorf(\"Init UUID Generator failed: %s\", err)\n\t}\n\n\t// init config\n\tif err = conf.Init(baseConfFile, watchConfiFile); err != nil {\n\t\treturn fmt.Errorf(\"Init Config failed: %s\", err)\n\t}\n\n\t// init etcd client\n\tif DefalutClient, err = NewClient(conf.Config); err != nil {\n\t\treturn fmt.Errorf(\"Connect to ETCD %s failed: %s\",\n\t\t\tconf.Config.Etcd.Endpoints, err)\n\t}\n\n\t// init mongoDB\n\tif mgoDB, err = db.NewMdb(conf.Config.Mgo); err != nil {\n\t\treturn fmt.Errorf(\"Connect to MongoDB %s failed: %s\",\n\t\t\tconf.Config.Mgo.Hosts, err)\n\t}\n\n\t_Uid = os.Getuid()\n\n\tinitialized = true\n\treturn\n}\n"
        },
        {
          "name": "conf",
          "type": "tree",
          "content": null
        },
        {
          "name": "csctl.go",
          "type": "blob",
          "size": 1.37109375,
          "content": "package cronsun\n\nimport (\n\t\"encoding/json\"\n\t\"errors\"\n\n\tclient \"github.com/coreos/etcd/clientv3\"\n\n\t\"github.com/shunfei/cronsun/conf\"\n)\n\nconst (\n\tNodeCmdUnknown NodeCmd = iota\n\tNodeCmdRmOld\n\tNodeCmdSync\n\tNodeCmdMax\n)\n\nvar (\n\tInvalidNodeCmdErr = errors.New(\"invalid node command\")\n\n\tNodeCmds = []string{\n\t\t\"unknown\",\n\t\t\"rmold\",\n\t\t\"sync\",\n\t}\n)\n\ntype NodeCmd int\n\nfunc (cmd NodeCmd) String() string {\n\tif NodeCmdMax <= cmd || cmd <= NodeCmdUnknown {\n\t\treturn \"unknown\"\n\t}\n\treturn NodeCmds[cmd]\n}\n\nfunc ToNodeCmd(cmd string) (NodeCmd, error) {\n\tfor nc := NodeCmdUnknown + 1; nc < NodeCmdMax; nc++ {\n\t\tif cmd == NodeCmds[nc] {\n\t\t\treturn nc, nil\n\t\t}\n\t}\n\treturn NodeCmdUnknown, InvalidNodeCmdErr\n}\n\ntype CsctlCmd struct {\n\t// the command send to node\n\tCmd NodeCmd\n\t// the node ids that needs to execute the command, empty means all node\n\tInclude []string\n\t// the node ids that doesn't need to execute the command, empty means none\n\tExclude []string\n}\n\n// 执行 csctl 发送的命令\n// 注册到 /cronsun/csctl/<cmd>\nfunc PutCsctl(cmd *CsctlCmd) error {\n\tif NodeCmdMax <= cmd.Cmd || cmd.Cmd <= NodeCmdUnknown {\n\t\treturn InvalidNodeCmdErr\n\t}\n\n\tparams, err := json.Marshal(cmd)\n\tif err != nil {\n\t\treturn err\n\t}\n\t_, err = DefalutClient.Put(conf.Config.Csctl+NodeCmds[cmd.Cmd], string(params))\n\treturn err\n}\n\nfunc WatchCsctl() client.WatchChan {\n\treturn DefalutClient.Watch(conf.Config.Csctl, client.WithPrefix())\n}\n"
        },
        {
          "name": "db",
          "type": "tree",
          "content": null
        },
        {
          "name": "doc",
          "type": "tree",
          "content": null
        },
        {
          "name": "errors.go",
          "type": "blob",
          "size": 0.94921875,
          "content": "package cronsun\n\nimport \"errors\"\n\nvar (\n\tErrNotFound        = errors.New(\"Record not found.\")\n\tErrValueMayChanged = errors.New(\"The value has been changed by others on this time.\")\n\n\tErrEmptyJobName        = errors.New(\"Name of job is empty.\")\n\tErrEmptyJobCommand     = errors.New(\"Command of job is empty.\")\n\tErrIllegalJobId        = errors.New(\"Invalid id that includes illegal characters such as '/' '\\\\'.\")\n\tErrIllegalJobGroupName = errors.New(\"Invalid job group name that includes illegal characters such as '/' '\\\\'.\")\n\n\tErrEmptyNodeGroupName = errors.New(\"Name of node group is empty.\")\n\tErrIllegalNodeGroupId = errors.New(\"Invalid node group id that includes illegal characters such as '/'.\")\n\n\tErrSecurityInvalidCmd  = errors.New(\"Security error: the suffix of script file is not on the whitelist.\")\n\tErrSecurityInvalidUser = errors.New(\"Security error: the user is not on the whitelist.\")\n\tErrNilRule             = errors.New(\"invalid job rule, empty timer.\")\n)\n"
        },
        {
          "name": "event",
          "type": "tree",
          "content": null
        },
        {
          "name": "go.mod",
          "type": "blob",
          "size": 3.181640625,
          "content": "module github.com/shunfei/cronsun\n\nrequire (\n\tgithub.com/beorn7/perks v0.0.0-20180321164747-3a771d992973 // indirect\n\tgithub.com/boltdb/bolt v1.3.1 // indirect\n\tgithub.com/cockroachdb/cmux v0.0.0-20170110192607-30d10be49292\n\tgithub.com/coreos/bbolt v1.3.0 // indirect\n\tgithub.com/coreos/etcd v3.3.9+incompatible\n\tgithub.com/coreos/go-semver v0.2.0 // indirect\n\tgithub.com/coreos/go-systemd v0.0.0-20180828140353-eee3db372b31 // indirect\n\tgithub.com/coreos/pkg v0.0.0-20180108230652-97fdf19511ea // indirect\n\tgithub.com/davecgh/go-spew v1.1.1 // indirect\n\tgithub.com/dgrijalva/jwt-go v3.2.0+incompatible // indirect\n\tgithub.com/fsnotify/fsnotify v1.4.7\n\tgithub.com/ghodss/yaml v1.0.0 // indirect\n\tgithub.com/go-gomail/gomail v0.0.0-20160411212932-81ebce5c23df\n\tgithub.com/gofrs/uuid v3.1.0+incompatible\n\tgithub.com/gogo/protobuf v1.1.1 // indirect\n\tgithub.com/golang/glog v0.0.0-20160126235308-23def4e6c14b // indirect\n\tgithub.com/golang/groupcache v0.0.0-20180513044358-24b0969c4cb7 // indirect\n\tgithub.com/golang/protobuf v1.2.0 // indirect\n\tgithub.com/google/btree v0.0.0-20180813153112-4030bb1f1f0c // indirect\n\tgithub.com/gopherjs/gopherjs v0.0.0-20180825215210-0210a2f0f73c // indirect\n\tgithub.com/gorilla/context v1.1.1 // indirect\n\tgithub.com/gorilla/mux v1.6.2\n\tgithub.com/gorilla/websocket v1.4.0 // indirect\n\tgithub.com/grpc-ecosystem/go-grpc-prometheus v1.2.0 // indirect\n\tgithub.com/grpc-ecosystem/grpc-gateway v1.4.1 // indirect\n\tgithub.com/inconshreveable/mousetrap v1.0.0 // indirect\n\tgithub.com/jonboulle/clockwork v0.1.0 // indirect\n\tgithub.com/jtolds/gls v4.2.1+incompatible // indirect\n\tgithub.com/matttproud/golang_protobuf_extensions v1.0.1 // indirect\n\tgithub.com/pkg/errors v0.8.0 // indirect\n\tgithub.com/pmezard/go-difflib v1.0.0 // indirect\n\tgithub.com/prometheus/client_golang v0.8.0 // indirect\n\tgithub.com/prometheus/client_model v0.0.0-20180712105110-5c3871d89910 // indirect\n\tgithub.com/prometheus/common v0.0.0-20180801064454-c7de2306084e // indirect\n\tgithub.com/prometheus/procfs v0.0.0-20180725123919-05ee40e3a273 // indirect\n\tgithub.com/rogpeppe/fastuuid v0.0.0-20150106093220-6724a57986af\n\tgithub.com/sirupsen/logrus v1.0.6 // indirect\n\tgithub.com/smartystreets/assertions v0.0.0-20180820201707-7c9eb446e3cf // indirect\n\tgithub.com/smartystreets/goconvey v0.0.0-20180222194500-ef6db91d284a\n\tgithub.com/soheilhy/cmux v0.1.4 // indirect\n\tgithub.com/spf13/cobra v0.0.3\n\tgithub.com/spf13/pflag v1.0.2 // indirect\n\tgithub.com/stretchr/testify v1.2.2 // indirect\n\tgithub.com/tmc/grpc-websocket-proxy v0.0.0-20171017195756-830351dc03c6 // indirect\n\tgithub.com/ugorji/go/codec v0.0.0-20180831062425-e253f1f20942 // indirect\n\tgithub.com/xiang90/probing v0.0.0-20160813154853-07dd2e8dfe18 // indirect\n\tgo.uber.org/atomic v1.3.2 // indirect\n\tgo.uber.org/multierr v1.1.0 // indirect\n\tgo.uber.org/zap v1.9.1\n\tgolang.org/x/net v0.0.0-20180826012351-8a410e7b638d // indirect\n\tgolang.org/x/sys v0.0.0-20180905080454-ebe1bf3edb33 // indirect\n\tgolang.org/x/text v0.3.0 // indirect\n\tgoogle.golang.org/genproto v0.0.0-20180831171423-11092d34479b // indirect\n\tgoogle.golang.org/grpc v1.14.0 // indirect\n\tgopkg.in/alexcesaro/quotedprintable.v3 v3.0.0-20150716171945-2caba252f4dc // indirect\n\tgopkg.in/mgo.v2 v2.0.0-20180705113604-9856a29383ce\n)\n"
        },
        {
          "name": "go.sum",
          "type": "blob",
          "size": 10.740234375,
          "content": "github.com/beorn7/perks v0.0.0-20180321164747-3a771d992973 h1:xJ4a3vCFaGF/jqvzLMYoU8P317H5OQ+Via4RmuPwCS0=\ngithub.com/beorn7/perks v0.0.0-20180321164747-3a771d992973/go.mod h1:Dwedo/Wpr24TaqPxmxbtue+5NUziq4I4S80YR8gNf3Q=\ngithub.com/boltdb/bolt v1.3.1 h1:JQmyP4ZBrce+ZQu0dY660FMfatumYDLun9hBCUVIkF4=\ngithub.com/boltdb/bolt v1.3.1/go.mod h1:clJnj/oiGkjum5o1McbSZDSLxVThjynRyGBgiAx27Ps=\ngithub.com/cockroachdb/cmux v0.0.0-20170110192607-30d10be49292 h1:dzj1/xcivGjNPwwifh/dWTczkwcuqsXXFHY1X/TZMtw=\ngithub.com/cockroachdb/cmux v0.0.0-20170110192607-30d10be49292/go.mod h1:qRiX68mZX1lGBkTWyp3CLcenw9I94W2dLeRvMzcn9N4=\ngithub.com/coreos/bbolt v1.3.0 h1:HIgH5xUWXT914HCI671AxuTTqjj64UOFr7pHn48LUTI=\ngithub.com/coreos/bbolt v1.3.0/go.mod h1:iRUV2dpdMOn7Bo10OQBFzIJO9kkE559Wcmn+qkEiiKk=\ngithub.com/coreos/etcd v3.3.9+incompatible h1:/pWnp1yEff0z+vBEOBFLZZ22Ux5xoVozEe7X0VFyRNo=\ngithub.com/coreos/etcd v3.3.9+incompatible/go.mod h1:uF7uidLiAD3TWHmW31ZFd/JWoc32PjwdhPthX9715RE=\ngithub.com/coreos/go-semver v0.2.0 h1:3Jm3tLmsgAYcjC+4Up7hJrFBPr+n7rAqYeSw/SZazuY=\ngithub.com/coreos/go-semver v0.2.0/go.mod h1:nnelYz7RCh+5ahJtPPxZlU+153eP4D4r3EedlOD2RNk=\ngithub.com/coreos/go-systemd v0.0.0-20180828140353-eee3db372b31 h1:wRzCUSYhBIk1KvRIlx+nvScCRIxX0iIhSU5h9xj7MUU=\ngithub.com/coreos/go-systemd v0.0.0-20180828140353-eee3db372b31/go.mod h1:F5haX7vjVVG0kc13fIWeqUViNPyEJxv/OmvnBo0Yme4=\ngithub.com/coreos/pkg v0.0.0-20180108230652-97fdf19511ea h1:n2Ltr3SrfQlf/9nOna1DoGKxLx3qTSI8Ttl6Xrqp6mw=\ngithub.com/coreos/pkg v0.0.0-20180108230652-97fdf19511ea/go.mod h1:E3G3o1h8I7cfcXa63jLwjI0eiQQMgzzUDFVpN/nH/eA=\ngithub.com/davecgh/go-spew v1.1.1 h1:vj9j/u1bqnvCEfJOwUhtlOARqs3+rkHYY13jYWTU97c=\ngithub.com/davecgh/go-spew v1.1.1/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=\ngithub.com/dgrijalva/jwt-go v3.2.0+incompatible h1:7qlOGliEKZXTDg6OTjfoBKDXWrumCAMpl/TFQ4/5kLM=\ngithub.com/dgrijalva/jwt-go v3.2.0+incompatible/go.mod h1:E3ru+11k8xSBh+hMPgOLZmtrrCbhqsmaPHjLKYnJCaQ=\ngithub.com/fsnotify/fsnotify v1.4.7 h1:IXs+QLmnXW2CcXuY+8Mzv/fWEsPGWxqefPtCP5CnV9I=\ngithub.com/fsnotify/fsnotify v1.4.7/go.mod h1:jwhsz4b93w/PPRr/qN1Yymfu8t87LnFCMoQvtojpjFo=\ngithub.com/ghodss/yaml v1.0.0 h1:wQHKEahhL6wmXdzwWG11gIVCkOv05bNOh+Rxn0yngAk=\ngithub.com/ghodss/yaml v1.0.0/go.mod h1:4dBDuWmgqj2HViK6kFavaiC9ZROes6MMH2rRYeMEF04=\ngithub.com/go-gomail/gomail v0.0.0-20160411212932-81ebce5c23df h1:Bao6dhmbTA1KFVxmJ6nBoMuOJit2yjEgLJpIMYpop0E=\ngithub.com/go-gomail/gomail v0.0.0-20160411212932-81ebce5c23df/go.mod h1:GJr+FCSXshIwgHBtLglIg9M2l2kQSi6QjVAngtzI08Y=\ngithub.com/gofrs/uuid v3.1.0+incompatible h1:q2rtkjaKT4YEr6E1kamy0Ha4RtepWlQBedyHx0uzKwA=\ngithub.com/gofrs/uuid v3.1.0+incompatible/go.mod h1:b2aQJv3Z4Fp6yNu3cdSllBxTCLRxnplIgP/c0N/04lM=\ngithub.com/gogo/protobuf v1.1.1 h1:72R+M5VuhED/KujmZVcIquuo8mBgX4oVda//DQb3PXo=\ngithub.com/gogo/protobuf v1.1.1/go.mod h1:r8qH/GZQm5c6nD/R0oafs1akxWv10x8SbQlK7atdtwQ=\ngithub.com/golang/glog v0.0.0-20160126235308-23def4e6c14b h1:VKtxabqXZkF25pY9ekfRL6a582T4P37/31XEstQ5p58=\ngithub.com/golang/glog v0.0.0-20160126235308-23def4e6c14b/go.mod h1:SBH7ygxi8pfUlaOkMMuAQtPIUF8ecWP5IEl/CR7VP2Q=\ngithub.com/golang/groupcache v0.0.0-20180513044358-24b0969c4cb7 h1:u4bArs140e9+AfE52mFHOXVFnOSBJBRlzTHrOPLOIhE=\ngithub.com/golang/groupcache v0.0.0-20180513044358-24b0969c4cb7/go.mod h1:cIg4eruTrX1D+g88fzRXU5OdNfaM+9IcxsU14FzY7Hc=\ngithub.com/golang/protobuf v1.2.0 h1:P3YflyNX/ehuJFLhxviNdFxQPkGK5cDcApsge1SqnvM=\ngithub.com/golang/protobuf v1.2.0/go.mod h1:6lQm79b+lXiMfvg/cZm0SGofjICqVBUtrP5yJMmIC1U=\ngithub.com/google/btree v0.0.0-20180813153112-4030bb1f1f0c h1:964Od4U6p2jUkFxvCydnIczKteheJEzHRToSGK3Bnlw=\ngithub.com/google/btree v0.0.0-20180813153112-4030bb1f1f0c/go.mod h1:lNA+9X1NB3Zf8V7Ke586lFgjr2dZNuvo3lPJSGZ5JPQ=\ngithub.com/gopherjs/gopherjs v0.0.0-20180825215210-0210a2f0f73c h1:16eHWuMGvCjSfgRJKqIzapE78onvvTbdi1rMkU00lZw=\ngithub.com/gopherjs/gopherjs v0.0.0-20180825215210-0210a2f0f73c/go.mod h1:wJfORRmW1u3UXTncJ5qlYoELFm8eSnnEO6hX4iZ3EWY=\ngithub.com/gorilla/context v1.1.1 h1:AWwleXJkX/nhcU9bZSnZoi3h/qGYqQAGhq6zZe/aQW8=\ngithub.com/gorilla/context v1.1.1/go.mod h1:kBGZzfjB9CEq2AlWe17Uuf7NDRt0dE0s8S51q0aT7Yg=\ngithub.com/gorilla/mux v1.6.2 h1:Pgr17XVTNXAk3q/r4CpKzC5xBM/qW1uVLV+IhRZpIIk=\ngithub.com/gorilla/mux v1.6.2/go.mod h1:1lud6UwP+6orDFRuTfBEV8e9/aOM/c4fVVCaMa2zaAs=\ngithub.com/gorilla/websocket v1.4.0 h1:WDFjx/TMzVgy9VdMMQi2K2Emtwi2QcUQsztZ/zLaH/Q=\ngithub.com/gorilla/websocket v1.4.0/go.mod h1:E7qHFY5m1UJ88s3WnNqhKjPHQ0heANvMoAMk2YaljkQ=\ngithub.com/grpc-ecosystem/go-grpc-prometheus v1.2.0 h1:Ovs26xHkKqVztRpIrF/92BcuyuQ/YW4NSIpoGtfXNho=\ngithub.com/grpc-ecosystem/go-grpc-prometheus v1.2.0/go.mod h1:8NvIoxWQoOIhqOTXgfV/d3M/q6VIi02HzZEHgUlZvzk=\ngithub.com/grpc-ecosystem/grpc-gateway v1.4.1 h1:pX7cnDwSSmG0dR9yNjCQSSpmsJOqFdT7SzVp5Yl9uVw=\ngithub.com/grpc-ecosystem/grpc-gateway v1.4.1/go.mod h1:RSKVYQBd5MCa4OVpNdGskqpgL2+G+NZTnrVHpWWfpdw=\ngithub.com/inconshreveable/mousetrap v1.0.0 h1:Z8tu5sraLXCXIcARxBp/8cbvlwVa7Z1NHg9XEKhtSvM=\ngithub.com/inconshreveable/mousetrap v1.0.0/go.mod h1:PxqpIevigyE2G7u3NXJIT2ANytuPF1OarO4DADm73n8=\ngithub.com/jonboulle/clockwork v0.1.0 h1:VKV+ZcuP6l3yW9doeqz6ziZGgcynBVQO+obU0+0hcPo=\ngithub.com/jonboulle/clockwork v0.1.0/go.mod h1:Ii8DK3G1RaLaWxj9trq07+26W01tbo22gdxWY5EU2bo=\ngithub.com/jtolds/gls v4.2.1+incompatible h1:fSuqC+Gmlu6l/ZYAoZzx2pyucC8Xza35fpRVWLVmUEE=\ngithub.com/jtolds/gls v4.2.1+incompatible/go.mod h1:QJZ7F/aHp+rZTRtaJ1ow/lLfFfVYBRgL+9YlvaHOwJU=\ngithub.com/matttproud/golang_protobuf_extensions v1.0.1 h1:4hp9jkHxhMHkqkrB3Ix0jegS5sx/RkqARlsWZ6pIwiU=\ngithub.com/matttproud/golang_protobuf_extensions v1.0.1/go.mod h1:D8He9yQNgCq6Z5Ld7szi9bcBfOoFv/3dc6xSMkL2PC0=\ngithub.com/pkg/errors v0.8.0 h1:WdK/asTD0HN+q6hsWO3/vpuAkAr+tw6aNJNDFFf0+qw=\ngithub.com/pkg/errors v0.8.0/go.mod h1:bwawxfHBFNV+L2hUp1rHADufV3IMtnDRdf1r5NINEl0=\ngithub.com/pmezard/go-difflib v1.0.0 h1:4DBwDE0NGyQoBHbLQYPwSUPoCMWR5BEzIk/f1lZbAQM=\ngithub.com/pmezard/go-difflib v1.0.0/go.mod h1:iKH77koFhYxTK1pcRnkKkqfTogsbg7gZNVY4sRDYZ/4=\ngithub.com/prometheus/client_golang v0.8.0 h1:1921Yw9Gc3iSc4VQh3PIoOqgPCZS7G/4xQNVUp8Mda8=\ngithub.com/prometheus/client_golang v0.8.0/go.mod h1:7SWBe2y4D6OKWSNQJUaRYU/AaXPKyh/dDVn+NZz0KFw=\ngithub.com/prometheus/client_model v0.0.0-20180712105110-5c3871d89910 h1:idejC8f05m9MGOsuEi1ATq9shN03HrxNkD/luQvxCv8=\ngithub.com/prometheus/client_model v0.0.0-20180712105110-5c3871d89910/go.mod h1:MbSGuTsp3dbXC40dX6PRTWyKYBIrTGTE9sqQNg2J8bo=\ngithub.com/prometheus/common v0.0.0-20180801064454-c7de2306084e h1:n/3MEhJQjQxrOUCzh1Y3Re6aJUUWRp2M9+Oc3eVn/54=\ngithub.com/prometheus/common v0.0.0-20180801064454-c7de2306084e/go.mod h1:daVV7qP5qjZbuso7PdcryaAu0sAZbrN9i7WWcTMWvro=\ngithub.com/prometheus/procfs v0.0.0-20180725123919-05ee40e3a273 h1:agujYaXJSxSo18YNX3jzl+4G6Bstwt+kqv47GS12uL0=\ngithub.com/prometheus/procfs v0.0.0-20180725123919-05ee40e3a273/go.mod h1:c3At6R/oaqEKCNdg8wHV1ftS6bRYblBhIjjI8uT2IGk=\ngithub.com/rogpeppe/fastuuid v0.0.0-20150106093220-6724a57986af h1:gu+uRPtBe88sKxUCEXRoeCvVG90TJmwhiqRpvdhQFng=\ngithub.com/rogpeppe/fastuuid v0.0.0-20150106093220-6724a57986af/go.mod h1:XWv6SoW27p1b0cqNHllgS5HIMJraePCO15w5zCzIWYg=\ngithub.com/sirupsen/logrus v1.0.6 h1:hcP1GmhGigz/O7h1WVUM5KklBp1JoNS9FggWKdj/j3s=\ngithub.com/sirupsen/logrus v1.0.6/go.mod h1:pMByvHTf9Beacp5x1UXfOR9xyW/9antXMhjMPG0dEzc=\ngithub.com/smartystreets/assertions v0.0.0-20180820201707-7c9eb446e3cf h1:6V1qxN6Usn4jy8unvggSJz/NC790tefw8Zdy6OZS5co=\ngithub.com/smartystreets/assertions v0.0.0-20180820201707-7c9eb446e3cf/go.mod h1:OnSkiWE9lh6wB0YB77sQom3nweQdgAjqCqsofrRNTgc=\ngithub.com/smartystreets/goconvey v0.0.0-20180222194500-ef6db91d284a h1:JSvGDIbmil4Ui/dDdFBExb7/cmkNjyX5F97oglmvCDo=\ngithub.com/smartystreets/goconvey v0.0.0-20180222194500-ef6db91d284a/go.mod h1:XDJAKZRPZ1CvBcN2aX5YOUTYGHki24fSF0Iv48Ibg0s=\ngithub.com/soheilhy/cmux v0.1.4 h1:0HKaf1o97UwFjHH9o5XsHUOF+tqmdA7KEzXLpiyaw0E=\ngithub.com/soheilhy/cmux v0.1.4/go.mod h1:IM3LyeVVIOuxMH7sFAkER9+bJ4dT7Ms6E4xg4kGIyLM=\ngithub.com/spf13/cobra v0.0.3 h1:ZlrZ4XsMRm04Fr5pSFxBgfND2EBVa1nLpiy1stUsX/8=\ngithub.com/spf13/cobra v0.0.3/go.mod h1:1l0Ry5zgKvJasoi3XT1TypsSe7PqH0Sj9dhYf7v3XqQ=\ngithub.com/spf13/pflag v1.0.2 h1:Fy0orTDgHdbnzHcsOgfCN4LtHf0ec3wwtiwJqwvf3Gc=\ngithub.com/spf13/pflag v1.0.2/go.mod h1:DYY7MBk1bdzusC3SYhjObp+wFpr4gzcvqqNjLnInEg4=\ngithub.com/stretchr/testify v1.2.2 h1:bSDNvY7ZPG5RlJ8otE/7V6gMiyenm9RtJ7IUVIAoJ1w=\ngithub.com/stretchr/testify v1.2.2/go.mod h1:a8OnRcib4nhh0OaRAV+Yts87kKdq0PP7pXfy6kDkUVs=\ngithub.com/tmc/grpc-websocket-proxy v0.0.0-20171017195756-830351dc03c6 h1:lYIiVDtZnyTWlNwiAxLj0bbpTcx1BWCFhXjfsvmPdNc=\ngithub.com/tmc/grpc-websocket-proxy v0.0.0-20171017195756-830351dc03c6/go.mod h1:ncp9v5uamzpCO7NfCPTXjqaC+bZgJeR0sMTm6dMHP7U=\ngithub.com/ugorji/go/codec v0.0.0-20180831062425-e253f1f20942 h1:CZORS/4d6i+5FKSAtbRIjlElV2BAFYv/bokcaEVUimQ=\ngithub.com/ugorji/go/codec v0.0.0-20180831062425-e253f1f20942/go.mod h1:VFNgLljTbGfSG7qAOspJ7OScBnGdDN/yBr0sguwnwf0=\ngithub.com/xiang90/probing v0.0.0-20160813154853-07dd2e8dfe18 h1:MPPkRncZLN9Kh4MEFmbnK4h3BD7AUmskWv2+EeZJCCs=\ngithub.com/xiang90/probing v0.0.0-20160813154853-07dd2e8dfe18/go.mod h1:UETIi67q53MR2AWcXfiuqkDkRtnGDLqkBTpCHuJHxtU=\ngo.uber.org/atomic v1.3.2 h1:2Oa65PReHzfn29GpvgsYwloV9AVFHPDk8tYxt2c2tr4=\ngo.uber.org/atomic v1.3.2/go.mod h1:gD2HeocX3+yG+ygLZcrzQJaqmWj9AIm7n08wl/qW/PE=\ngo.uber.org/multierr v1.1.0 h1:HoEmRHQPVSqub6w2z2d2EOVs2fjyFRGyofhKuyDq0QI=\ngo.uber.org/multierr v1.1.0/go.mod h1:wR5kodmAFQ0UK8QlbwjlSNy0Z68gJhDJUG5sjR94q/0=\ngo.uber.org/zap v1.9.1 h1:XCJQEf3W6eZaVwhRBof6ImoYGJSITeKWsyeh3HFu/5o=\ngo.uber.org/zap v1.9.1/go.mod h1:vwi/ZaCAaUcBkycHslxD9B2zi4UTXhF60s6SWpuDF0Q=\ngolang.org/x/net v0.0.0-20180826012351-8a410e7b638d h1:g9qWBGx4puODJTMVyoPrpoxPFgVGd+z1DZwjfRu4d0I=\ngolang.org/x/net v0.0.0-20180826012351-8a410e7b638d/go.mod h1:mL1N/T3taQHkDXs73rZJwtUhF3w3ftmwwsq0BUmARs4=\ngolang.org/x/sys v0.0.0-20180905080454-ebe1bf3edb33 h1:I6FyU15t786LL7oL/hn43zqTuEGr4PN7F4XJ1p4E3Y8=\ngolang.org/x/sys v0.0.0-20180905080454-ebe1bf3edb33/go.mod h1:STP8DvDyc/dI5b8T5hshtkjS+E42TnysNCUPdjciGhY=\ngolang.org/x/text v0.3.0 h1:g61tztE5qeGQ89tm6NTjjM9VPIm088od1l6aSorWRWg=\ngolang.org/x/text v0.3.0/go.mod h1:NqM8EUOU14njkJ3fqMW+pc6Ldnwhi/IjpwHt7yyuwOQ=\ngoogle.golang.org/genproto v0.0.0-20180831171423-11092d34479b h1:lohp5blsw53GBXtLyLNaTXPXS9pJ1tiTw61ZHUoE9Qw=\ngoogle.golang.org/genproto v0.0.0-20180831171423-11092d34479b/go.mod h1:JiN7NxoALGmiZfu7CAH4rXhgtRTLTxftemlI0sWmxmc=\ngoogle.golang.org/grpc v1.14.0 h1:ArxJuB1NWfPY6r9Gp9gqwplT0Ge7nqv9msgu03lHLmo=\ngoogle.golang.org/grpc v1.14.0/go.mod h1:yo6s7OP7yaDglbqo1J04qKzAhqBH6lvTonzMVmEdcZw=\ngopkg.in/alexcesaro/quotedprintable.v3 v3.0.0-20150716171945-2caba252f4dc h1:2gGKlE2+asNV9m7xrywl36YYNnBG5ZQ0r/BOOxqPpmk=\ngopkg.in/alexcesaro/quotedprintable.v3 v3.0.0-20150716171945-2caba252f4dc/go.mod h1:m7x9LTH6d71AHyAX77c9yqWCCa3UKHcVEj9y7hAtKDk=\ngopkg.in/mgo.v2 v2.0.0-20180705113604-9856a29383ce h1:xcEWjVhvbDy+nHP67nPDDpbYrY+ILlfndk4bRioVHaU=\ngopkg.in/mgo.v2 v2.0.0-20180705113604-9856a29383ce/go.mod h1:yeKp02qBN3iKW1OzL3MGk2IdtZzaj7SFntXj72NppTA=\n"
        },
        {
          "name": "group.go",
          "type": "blob",
          "size": 2.3466796875,
          "content": "package cronsun\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"strings\"\n\n\tclient \"github.com/coreos/etcd/clientv3\"\n\n\t\"github.com/shunfei/cronsun/conf\"\n\t\"github.com/shunfei/cronsun/log\"\n)\n\n// 结点类型分组\n// 注册到 /cronsun/group/<id>\ntype Group struct {\n\tID   string `json:\"id\"`\n\tName string `json:\"name\"`\n\n\tNodeIDs []string `json:\"nids\"`\n}\n\nfunc GetGroupById(gid string) (g *Group, err error) {\n\tif len(gid) == 0 {\n\t\treturn\n\t}\n\tresp, err := DefalutClient.Get(conf.Config.Group + gid)\n\tif err != nil || resp.Count == 0 {\n\t\treturn\n\t}\n\n\terr = json.Unmarshal(resp.Kvs[0].Value, &g)\n\treturn\n}\n\n// GetGroups 获取包含 nid 的 group\n// 如果 nid 为空，则获取所有的 group\nfunc GetGroups(nid string) (groups map[string]*Group, err error) {\n\tresp, err := DefalutClient.Get(conf.Config.Group, client.WithPrefix())\n\tif err != nil {\n\t\treturn\n\t}\n\n\tcount := len(resp.Kvs)\n\tgroups = make(map[string]*Group, count)\n\tif count == 0 {\n\t\treturn\n\t}\n\n\tfor _, g := range resp.Kvs {\n\t\tgroup := new(Group)\n\t\tif e := json.Unmarshal(g.Value, group); e != nil {\n\t\t\tlog.Warnf(\"group[%s] umarshal err: %s\", string(g.Key), e.Error())\n\t\t\tcontinue\n\t\t}\n\t\tif len(nid) == 0 || group.Included(nid) {\n\t\t\tgroups[group.ID] = group\n\t\t}\n\t}\n\treturn\n}\n\nfunc WatchGroups() client.WatchChan {\n\treturn DefalutClient.Watch(conf.Config.Group, client.WithPrefix(), client.WithPrevKV())\n}\n\nfunc GetGroupFromKv(key, value []byte) (g *Group, err error) {\n\tg = new(Group)\n\tif err = json.Unmarshal(value, g); err != nil {\n\t\terr = fmt.Errorf(\"group[%s] umarshal err: %s\", string(key), err.Error())\n\t}\n\treturn\n}\n\nfunc DeleteGroupById(id string) (*client.DeleteResponse, error) {\n\treturn DefalutClient.Delete(GroupKey(id))\n}\n\nfunc GroupKey(id string) string {\n\treturn conf.Config.Group + id\n}\n\nfunc (g *Group) Key() string {\n\treturn GroupKey(g.ID)\n}\n\nfunc (g *Group) Put(modRev int64) (*client.PutResponse, error) {\n\tb, err := json.Marshal(g)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn DefalutClient.PutWithModRev(g.Key(), string(b), modRev)\n}\n\nfunc (g *Group) Check() error {\n\tg.ID = strings.TrimSpace(g.ID)\n\tif !IsValidAsKeyPath(g.ID) {\n\t\treturn ErrIllegalNodeGroupId\n\t}\n\n\tg.Name = strings.TrimSpace(g.Name)\n\tif len(g.Name) == 0 {\n\t\treturn ErrEmptyNodeGroupName\n\t}\n\n\treturn nil\n}\n\nfunc (g *Group) Included(nid string) bool {\n\tfor i, count := 0, len(g.NodeIDs); i < count; i++ {\n\t\tif nid == g.NodeIDs[i] {\n\t\t\treturn true\n\t\t}\n\t}\n\n\treturn false\n}\n"
        },
        {
          "name": "id.go",
          "type": "blob",
          "size": 0.2705078125,
          "content": "package cronsun\n\nimport (\n\t\"encoding/hex\"\n\n\t\"github.com/rogpeppe/fastuuid\"\n)\n\nvar generator *fastuuid.Generator\n\nfunc initID() (err error) {\n\tgenerator, err = fastuuid.NewGenerator()\n\treturn\n}\n\nfunc NextID() string {\n\tid := generator.Next()\n\treturn hex.EncodeToString(id[:])\n}\n"
        },
        {
          "name": "job.go",
          "type": "blob",
          "size": 14.7109375,
          "content": "package cronsun\n\nimport (\n\t\"bytes\"\n\t\"context\"\n\t\"encoding/json\"\n\t\"errors\"\n\t\"fmt\"\n\t\"os/exec\"\n\t\"os/user\"\n\t\"runtime\"\n\t\"strconv\"\n\t\"strings\"\n\t\"sync/atomic\"\n\t\"syscall\"\n\t\"time\"\n\n\tclient \"github.com/coreos/etcd/clientv3\"\n\n\t\"github.com/shunfei/cronsun/conf\"\n\t\"github.com/shunfei/cronsun/log\"\n\t\"github.com/shunfei/cronsun/node/cron\"\n\t\"github.com/shunfei/cronsun/utils\"\n)\n\nconst (\n\tDefaultJobGroup = \"default\"\n)\n\nconst (\n\tKindCommon   = iota\n\tKindAlone    // 任何时间段只允许单机执行\n\tKindInterval // 一个任务执行间隔内允许执行一次\n)\n\n// 需要执行的 cron cmd 命令\n// 注册到 /cronsun/cmd/groupName/<id>\ntype Job struct {\n\tID      string     `json:\"id\"`\n\tName    string     `json:\"name\"`\n\tGroup   string     `json:\"group\"`\n\tCommand string     `json:\"cmd\"`\n\tUser    string     `json:\"user\"`\n\tRules   []*JobRule `json:\"rules\"`\n\tPause   bool       `json:\"pause\"`   // 可手工控制的状态\n\tTimeout int64      `json:\"timeout\"` // 任务执行时间超时设置，大于 0 时有效\n\t// 设置任务在单个节点上可以同时允许多少个\n\t// 针对两次任务执行间隔比任务执行时间要长的任务启用\n\tParallels int64 `json:\"parallels\"`\n\t// 执行任务失败重试次数\n\t// 默认为 0，不重试\n\tRetry int `json:\"retry\"`\n\t// 执行任务失败重试时间间隔\n\t// 单位秒，如果不大于 0 则马上重试\n\tInterval int `json:\"interval\"`\n\t// 任务类型\n\t// 0: 普通任务\n\t// 1: 单机任务\n\t// 如果为单机任务，node 加载任务的时候 Parallels 设置 1\n\tKind int `json:\"kind\"`\n\t// 平均执行时间，单位 ms\n\tAvgTime int64 `json:\"avg_time\"`\n\t// 执行失败发送通知\n\tFailNotify bool `json:\"fail_notify\"`\n\t// 发送通知地址\n\tTo []string `json:\"to\"`\n\t// 单独对任务指定日志清除时间\n\tLogExpiration int `json:\"log_expiration\"`\n\n\t// 执行任务的结点，用于记录 job log\n\trunOn    string\n\thostname string\n\tip       string\n\t// 用于存储分隔后的任务\n\tcmd []string\n\t// 控制同时执行任务数\n\tCount *int64 `json:\"-\"`\n}\n\ntype JobRule struct {\n\tID             string   `json:\"id\"`\n\tTimer          string   `json:\"timer\"`\n\tGroupIDs       []string `json:\"gids\"`\n\tNodeIDs        []string `json:\"nids\"`\n\tExcludeNodeIDs []string `json:\"exclude_nids\"`\n\n\tSchedule cron.Schedule `json:\"-\"`\n}\n\n// 任务锁\ntype locker struct {\n\tkind  int\n\tttl   int64\n\tlID   client.LeaseID\n\ttimer *time.Timer\n\tdone  chan struct{}\n}\n\nfunc (l *locker) keepAlive() {\n\tduration := time.Duration(l.ttl)*time.Second - 500*time.Millisecond\n\tl.timer = time.NewTimer(duration)\n\tfor {\n\t\tselect {\n\t\tcase <-l.done:\n\t\t\treturn\n\t\tcase <-l.timer.C:\n\t\t\t_, err := DefalutClient.KeepAliveOnce(l.lID)\n\t\t\tif err != nil {\n\t\t\t\tlog.Warnf(\"lock keep alive err: %s\", err.Error())\n\t\t\t\treturn\n\t\t\t}\n\t\t\tl.timer.Reset(duration)\n\t\t}\n\t}\n}\n\nfunc (l *locker) unlock() {\n\tif l.kind != KindAlone {\n\t\treturn\n\t}\n\n\tclose(l.done)\n\tl.timer.Stop()\n\tif _, err := DefalutClient.Revoke(l.lID); err != nil {\n\t\tlog.Warnf(\"unlock revoke err: %s\", err.Error())\n\t}\n}\n\ntype Cmd struct {\n\t*Job\n\t*JobRule\n}\n\nfunc (c *Cmd) GetID() string {\n\treturn c.Job.ID + c.JobRule.ID\n}\n\nfunc (c *Cmd) Run() {\n\t// 同时执行任务数限制\n\tif c.Job.limit() {\n\t\treturn\n\t}\n\tdefer c.Job.unlimit()\n\n\tif c.Job.Kind != KindCommon {\n\t\tlk := c.lock()\n\t\tif lk == nil {\n\t\t\treturn\n\t\t}\n\t\tdefer lk.unlock()\n\t}\n\n\tif c.Job.Retry <= 0 {\n\t\tc.Job.Run()\n\t\treturn\n\t}\n\n\tfor i := 0; i <= c.Job.Retry; i++ {\n\t\tif c.Job.Run() {\n\t\t\treturn\n\t\t}\n\n\t\tif c.Job.Interval > 0 {\n\t\t\ttime.Sleep(time.Duration(c.Job.Interval) * time.Second)\n\t\t}\n\t}\n}\n\nfunc (j *Job) limit() bool {\n\tif j.Parallels == 0 {\n\t\treturn false\n\t}\n\n\tcount := atomic.AddInt64(j.Count, 1)\n\tif j.Parallels < count {\n\t\tatomic.AddInt64(j.Count, -1)\n\t\tj.Fail(time.Now(), fmt.Sprintf(\"job[%s] running on[%s] running:[%d]\", j.Key(), j.runOn, count))\n\t\treturn true\n\t}\n\n\treturn false\n}\n\nfunc (j *Job) unlimit() {\n\tif j.Parallels == 0 {\n\t\treturn\n\t}\n\tatomic.AddInt64(j.Count, -1)\n}\n\nfunc (j *Job) Init(nodeID, hostname, ip string) {\n\tvar c int64\n\tj.Count, j.runOn, j.hostname, j.ip = &c, nodeID, hostname, ip\n}\n\nfunc (c *Cmd) lockTtl() int64 {\n\tnow := time.Now()\n\tprev := c.JobRule.Schedule.Next(now)\n\tttl := int64(c.JobRule.Schedule.Next(prev).Sub(prev) / time.Second)\n\tif ttl == 0 {\n\t\treturn 0\n\t}\n\n\tif c.Job.Kind == KindInterval {\n\t\tttl -= 2\n\t\tif ttl > conf.Config.LockTtl {\n\t\t\tttl = conf.Config.LockTtl\n\t\t}\n\t\tif ttl < 1 {\n\t\t\tttl = 1\n\t\t}\n\t\treturn ttl\n\t}\n\n\tcost := c.Job.AvgTime / 1e3\n\tif c.Job.AvgTime/1e3-cost*1e3 > 0 {\n\t\tcost += 1\n\t}\n\t// 如果执行间隔时间不大于执行时间，把过期时间设置为执行时间的下限-1\n\t// 以便下次执行的时候，能获取到 lock\n\tif ttl >= cost {\n\t\tttl -= cost\n\t}\n\n\tif ttl > conf.Config.LockTtl {\n\t\tttl = conf.Config.LockTtl\n\t}\n\n\t// 支持的最小时间间隔 2s\n\tif ttl < 2 {\n\t\tttl = 2\n\t}\n\n\treturn ttl\n}\n\nfunc (c *Cmd) newLock() *locker {\n\treturn &locker{\n\t\tkind: c.Job.Kind,\n\t\tttl:  c.lockTtl(),\n\t\tdone: make(chan struct{}),\n\t}\n}\n\nfunc (c *Cmd) lock() *locker {\n\tlk := c.newLock()\n\t// 非法的 rule\n\tif lk.ttl == 0 {\n\t\treturn nil\n\t}\n\n\tresp, err := DefalutClient.Grant(lk.ttl)\n\tif err != nil {\n\t\tlog.Infof(\"job[%s] didn't get a lock, err: %s\", c.Job.Key(), err.Error())\n\t\treturn nil\n\t}\n\n\tok, err := DefalutClient.GetLock(c.Job.ID, resp.ID)\n\tif err != nil {\n\t\tlog.Infof(\"job[%s] didn't get a lock, err: %s\", c.Job.Key(), err.Error())\n\t\treturn nil\n\t}\n\n\tif !ok {\n\t\treturn nil\n\t}\n\n\tlk.lID = resp.ID\n\tif lk.kind == KindAlone {\n\t\tgo lk.keepAlive()\n\t}\n\treturn lk\n}\n\n// 优先取结点里的值，更新 group 时可用 gid 判断是否对 job 进行处理\nfunc (rule *JobRule) included(nid string, gs map[string]*Group) bool {\n\tfor i, count := 0, len(rule.NodeIDs); i < count; i++ {\n\t\tif nid == rule.NodeIDs[i] {\n\t\t\treturn true\n\t\t}\n\t}\n\n\tfor _, gid := range rule.GroupIDs {\n\t\tif g, ok := gs[gid]; ok && g.Included(nid) {\n\t\t\treturn true\n\t\t}\n\t}\n\n\treturn false\n}\n\n// 验证 timer 字段\nfunc (rule *JobRule) Valid() error {\n\t// 注意 interface nil 的比较\n\tif rule.Schedule != nil {\n\t\treturn nil\n\t}\n\n\tif len(rule.Timer) == 0 {\n\t\treturn ErrNilRule\n\t}\n\n\tsch, err := cron.Parse(rule.Timer)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"invalid JobRule[%s], parse err: %s\", rule.Timer, err.Error())\n\t}\n\n\trule.Schedule = sch\n\treturn nil\n}\n\n// Note: this function did't check the job.\nfunc GetJob(group, id string) (job *Job, err error) {\n\tjob, _, err = GetJobAndRev(group, id)\n\treturn\n}\n\nfunc GetJobAndRev(group, id string) (job *Job, rev int64, err error) {\n\tresp, err := DefalutClient.Get(JobKey(group, id))\n\tif err != nil {\n\t\treturn\n\t}\n\n\tif resp.Count == 0 {\n\t\terr = ErrNotFound\n\t\treturn\n\t}\n\n\trev = resp.Kvs[0].ModRevision\n\tif err = json.Unmarshal(resp.Kvs[0].Value, &job); err != nil {\n\t\treturn\n\t}\n\n\tjob.splitCmd()\n\treturn\n}\n\nfunc DeleteJob(group, id string) (resp *client.DeleteResponse, err error) {\n\treturn DefalutClient.Delete(JobKey(group, id))\n}\n\nfunc GetJobs() (jobs map[string]*Job, err error) {\n\tresp, err := DefalutClient.Get(conf.Config.Cmd, client.WithPrefix())\n\tif err != nil {\n\t\treturn\n\t}\n\n\tcount := len(resp.Kvs)\n\tjobs = make(map[string]*Job, count)\n\tif count == 0 {\n\t\treturn\n\t}\n\n\tfor _, j := range resp.Kvs {\n\t\tjob := new(Job)\n\t\tif e := json.Unmarshal(j.Value, job); e != nil {\n\t\t\tlog.Warnf(\"job[%s] umarshal err: %s\", string(j.Key), e.Error())\n\t\t\tcontinue\n\t\t}\n\n\t\tif err := job.Valid(); err != nil {\n\t\t\tlog.Warnf(\"job[%s] is invalid: %s\", string(j.Key), err.Error())\n\t\t\tcontinue\n\t\t}\n\n\t\tjob.alone()\n\t\tjobs[job.ID] = job\n\t}\n\treturn\n}\n\nfunc WatchJobs() client.WatchChan {\n\treturn DefalutClient.Watch(conf.Config.Cmd, client.WithPrefix())\n}\n\nfunc GetJobFromKv(key, value []byte) (job *Job, err error) {\n\tjob = new(Job)\n\tif err = json.Unmarshal(value, job); err != nil {\n\t\terr = fmt.Errorf(\"job[%s] umarshal err: %s\", string(key), err.Error())\n\t\treturn\n\t}\n\n\terr = job.Valid()\n\tjob.alone()\n\treturn\n}\n\nfunc (j *Job) alone() {\n\tif j.Kind == KindAlone {\n\t\tj.Parallels = 1\n\t}\n}\n\nfunc (j *Job) splitCmd() {\n\tps := strings.SplitN(j.Command, \" \", 2)\n\tif len(ps) == 1 {\n\t\tj.cmd = ps\n\t\treturn\n\t}\n\n\tj.cmd = make([]string, 0, 2)\n\tj.cmd = append(j.cmd, ps[0])\n\tj.cmd = append(j.cmd, utils.ParseCmdArguments(ps[1])...)\n}\n\nfunc (j *Job) String() string {\n\tdata, err := json.Marshal(j)\n\tif err != nil {\n\t\treturn err.Error()\n\t}\n\treturn string(data)\n}\n\n// GetNextRunTime return the job's next run time by now,\n// will return zero time if job will not run.\nfunc (j *Job) GetNextRunTime() time.Time {\n\tnextTime := time.Time{}\n\tif len(j.Rules) < 1 {\n\t\treturn nextTime\n\t}\n\tfor i, r := range j.Rules {\n\t\tsch, err := cron.Parse(r.Timer)\n\t\tif err != nil {\n\t\t\treturn nextTime\n\t\t}\n\t\tt := sch.Next(time.Now())\n\t\tif i == 0 || t.UnixNano() < nextTime.UnixNano() {\n\t\t\tnextTime = t\n\t\t}\n\t}\n\treturn nextTime\n}\n\n// Run 执行任务\nfunc (j *Job) Run() bool {\n\tvar (\n\t\tcmd         *exec.Cmd\n\t\tproc        *Process\n\t\tsysProcAttr *syscall.SysProcAttr\n\t\terr         error\n\t)\n\n\tt := time.Now()\n\n\tsysProcAttr, err = j.CreateCmdAttr()\n\tif err != nil {\n\t\tj.Fail(t, err.Error())\n\t\treturn false\n\t}\n\n\t// 超时控制\n\tif j.Timeout > 0 {\n\t\tctx, cancel := context.WithTimeout(context.Background(), time.Duration(j.Timeout)*time.Second)\n\t\tdefer cancel()\n\t\tcmd = exec.CommandContext(ctx, j.cmd[0], j.cmd[1:]...)\n\t} else {\n\t\tcmd = exec.Command(j.cmd[0], j.cmd[1:]...)\n\t}\n\n\tcmd.SysProcAttr = sysProcAttr\n\tvar b bytes.Buffer\n\tcmd.Stdout = &b\n\tcmd.Stderr = &b\n\tif err := cmd.Start(); err != nil {\n\t\tj.Fail(t, fmt.Sprintf(\"%s\\n%s\", b.String(), err.Error()))\n\t\treturn false\n\t}\n\n\tproc = &Process{\n\t\tID:     strconv.Itoa(cmd.Process.Pid),\n\t\tJobID:  j.ID,\n\t\tGroup:  j.Group,\n\t\tNodeID: j.runOn,\n\t\tProcessVal: ProcessVal{\n\t\t\tTime: t,\n\t\t},\n\t}\n\tproc.Start()\n\tdefer proc.Stop()\n\n\tif err := cmd.Wait(); err != nil {\n\t\tj.Fail(t, fmt.Sprintf(\"%s\\n%s\", b.String(), err.Error()))\n\t\treturn false\n\t}\n\n\tj.Success(t, b.String())\n\treturn true\n}\n\nfunc (j *Job) RunWithRecovery() {\n\tdefer func() {\n\t\tif r := recover(); r != nil {\n\t\t\tconst size = 64 << 10\n\t\t\tbuf := make([]byte, size)\n\t\t\tbuf = buf[:runtime.Stack(buf, false)]\n\t\t\tlog.Warnf(\"panic running job: %v\\n%s\", r, buf)\n\t\t}\n\t}()\n\tj.Run()\n}\n\n// 从 etcd 的 key 中取 id\nfunc GetIDFromKey(key string) string {\n\tindex := strings.LastIndex(key, \"/\")\n\tif index < 0 {\n\t\treturn \"\"\n\t}\n\n\treturn key[index+1:]\n}\n\nfunc JobKey(group, id string) string {\n\treturn conf.Config.Cmd + group + \"/\" + id\n}\n\nfunc (j *Job) Key() string {\n\treturn JobKey(j.Group, j.ID)\n}\n\nfunc (j *Job) Check() error {\n\tj.ID = strings.TrimSpace(j.ID)\n\tif !IsValidAsKeyPath(j.ID) {\n\t\treturn ErrIllegalJobId\n\t}\n\n\tj.Name = strings.TrimSpace(j.Name)\n\tif len(j.Name) == 0 {\n\t\treturn ErrEmptyJobName\n\t}\n\n\tj.Group = strings.TrimSpace(j.Group)\n\tif len(j.Group) == 0 {\n\t\tj.Group = DefaultJobGroup\n\t}\n\n\tif !IsValidAsKeyPath(j.Group) {\n\t\treturn ErrIllegalJobGroupName\n\t}\n\n\tif j.LogExpiration < 0 {\n\t\tj.LogExpiration = 0\n\t}\n\n\tj.User = strings.TrimSpace(j.User)\n\n\tfor i := range j.Rules {\n\t\tid := strings.TrimSpace(j.Rules[i].ID)\n\t\tif id == \"\" || strings.HasPrefix(id, \"NEW\") {\n\t\t\tj.Rules[i].ID = NextID()\n\t\t}\n\t}\n\n\t// 不修改 Command 的内容，简单判断是否为空\n\tif len(strings.TrimSpace(j.Command)) == 0 {\n\t\treturn ErrEmptyJobCommand\n\t}\n\n\treturn j.Valid()\n}\n\n// 执行结果写入 mongoDB\nfunc (j *Job) Success(t time.Time, out string) {\n\tCreateJobLog(j, t, out, true)\n}\n\nfunc (j *Job) Fail(t time.Time, msg string) {\n\tj.Notify(t, msg)\n\tCreateJobLog(j, t, msg, false)\n}\n\nfunc (j *Job) Notify(t time.Time, msg string) {\n\tif !conf.Config.Mail.Enable || !j.FailNotify {\n\t\treturn\n\t}\n\n\tts := t.Format(time.RFC3339)\n\tbody := \"Job: \" + j.Key() + \"\\n\" +\n\t\t\"Job name: \" + j.Name + \"\\n\" +\n\t\t\"Job cmd: \" + j.Command + \"\\n\" +\n\t\t\"Node: \" + j.hostname + \"|\" + j.ip + \"[\" + j.runOn + \"]\\n\" +\n\t\t\"Time: \" + ts + \"\\n\" +\n\t\t\"Error: \" + msg\n\n\tm := Message{\n\t\tSubject: \"[Cronsun] node[\" + j.hostname + \"|\" + j.ip + \"] job[\" + j.ShortName() + \"] time[\" + ts + \"] exec failed\",\n\t\tBody:    body,\n\t\tTo:      j.To,\n\t}\n\n\tdata, err := json.Marshal(m)\n\tif err != nil {\n\t\tlog.Warnf(\"job[%s] send notice fail, err: %s\", j.Key(), err.Error())\n\t\treturn\n\t}\n\n\t_, err = DefalutClient.Put(conf.Config.Noticer+\"/\"+j.runOn, string(data))\n\tif err != nil {\n\t\tlog.Warnf(\"job[%s] send notice fail, err: %s\", j.Key(), err.Error())\n\t\treturn\n\t}\n}\n\nfunc (j *Job) Avg(t, et time.Time) {\n\texecTime := int64(et.Sub(t) / time.Millisecond)\n\tif j.AvgTime == 0 {\n\t\tj.AvgTime = execTime\n\t\treturn\n\t}\n\n\tj.AvgTime = (j.AvgTime + execTime) / 2\n}\n\nfunc (j *Job) Cmds(nid string, gs map[string]*Group) (cmds map[string]*Cmd) {\n\tcmds = make(map[string]*Cmd)\n\tif j.Pause {\n\t\treturn\n\t}\n\nLOOP_TIMER_CMD:\n\tfor _, r := range j.Rules {\n\t\tfor _, id := range r.ExcludeNodeIDs {\n\t\t\tif nid == id {\n\t\t\t\t// 在当前定时器规则中，任务不会在该节点执行（节点被排除）\n\t\t\t\t// 但是任务可以在其它定时器中，在该节点被执行\n\t\t\t\t// 比如，一个定时器设置在凌晨 1 点执行，但是此时不想在这个节点执行，然后，\n\t\t\t\t// 同时又设置一个定时器在凌晨 2 点执行，这次这个任务由于某些原因，必须在当前节点执行\n\t\t\t\t// 下面的 LOOP_TIMER 标签，原因同上\n\t\t\t\tcontinue LOOP_TIMER_CMD\n\t\t\t}\n\t\t}\n\n\t\tif r.included(nid, gs) {\n\t\t\tcmd := &Cmd{\n\t\t\t\tJob:     j,\n\t\t\t\tJobRule: r,\n\t\t\t}\n\t\t\tcmds[cmd.GetID()] = cmd\n\t\t}\n\t}\n\n\treturn\n}\n\nfunc (j Job) IsRunOn(nid string, gs map[string]*Group) bool {\nLOOP_TIMER:\n\tfor _, r := range j.Rules {\n\t\tfor _, id := range r.ExcludeNodeIDs {\n\t\t\tif nid == id {\n\t\t\t\tcontinue LOOP_TIMER\n\t\t\t}\n\t\t}\n\n\t\tif r.included(nid, gs) {\n\t\t\treturn true\n\t\t}\n\t}\n\n\treturn false\n}\n\n// 安全选项验证\nfunc (j *Job) Valid() error {\n\tif len(j.cmd) == 0 {\n\t\tj.splitCmd()\n\t}\n\n\tif err := j.ValidRules(); err != nil {\n\t\treturn err\n\t}\n\n\tsecurity := conf.Config.Security\n\tif !security.Open {\n\t\treturn nil\n\t}\n\n\tif !j.validUser() {\n\t\treturn ErrSecurityInvalidUser\n\t}\n\n\tif !j.validCmd() {\n\t\treturn ErrSecurityInvalidCmd\n\t}\n\n\treturn nil\n}\n\nfunc (j *Job) validUser() bool {\n\tif len(conf.Config.Security.Users) == 0 {\n\t\treturn true\n\t}\n\n\tfor _, u := range conf.Config.Security.Users {\n\t\tif j.User == u {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\nfunc (j *Job) validCmd() bool {\n\tif len(conf.Config.Security.Ext) == 0 {\n\t\treturn true\n\t}\n\tfor _, ext := range conf.Config.Security.Ext {\n\t\tif strings.HasSuffix(j.cmd[0], ext) {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\nfunc (j *Job) ValidRules() error {\n\tfor _, r := range j.Rules {\n\t\tif err := r.Valid(); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc (j *Job) ShortName() string {\n\tif len(j.Name) <= 10 {\n\t\treturn j.Name\n\t}\n\n\tnames := []rune(j.Name)\n\tif len(names) <= 10 {\n\t\treturn j.Name\n\t}\n\n\treturn string(names[:10]) + \"...\"\n}\n\nfunc (j *Job) CreateCmdAttr() (*syscall.SysProcAttr, error) {\n\tsysProcAttr := &syscall.SysProcAttr{\n\t\tSetpgid: true,\n\t}\n\n\tif len(j.User) == 0 {\n\t\treturn sysProcAttr, nil\n\t}\n\n\tu, err := user.Lookup(j.User)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tuid, err := strconv.Atoi(u.Uid)\n\tif err != nil {\n\t\treturn nil, errors.New(\"not support run with user on windows\")\n\t}\n\n\tif uid != _Uid {\n\t\tgid, _ := strconv.Atoi(u.Gid)\n\t\tsysProcAttr.Credential = &syscall.Credential{\n\t\t\tUid: uint32(uid),\n\t\t\tGid: uint32(gid),\n\t\t}\n\t}\n\n\treturn sysProcAttr, nil\n}\n"
        },
        {
          "name": "job_log.go",
          "type": "blob",
          "size": 5.3515625,
          "content": "package cronsun\n\nimport (\n\t\"time\"\n\n\t\"gopkg.in/mgo.v2\"\n\t\"gopkg.in/mgo.v2/bson\"\n\n\t\"github.com/shunfei/cronsun/conf\"\n\t\"github.com/shunfei/cronsun/log\"\n)\n\nconst (\n\tColl_JobLog       = \"job_log\"\n\tColl_JobLatestLog = \"job_latest_log\"\n\tColl_Stat         = \"stat\"\n)\n\n// 任务执行记录\ntype JobLog struct {\n\tId        bson.ObjectId `bson:\"_id,omitempty\" json:\"id\"`\n\tJobId     string        `bson:\"jobId\" json:\"jobId\"`               // 任务 Id，索引\n\tJobGroup  string        `bson:\"jobGroup\" json:\"jobGroup\"`         // 任务分组，配合 Id 跳转用\n\tUser      string        `bson:\"user\" json:\"user\"`                 // 执行此次任务的用户\n\tName      string        `bson:\"name\" json:\"name\"`                 // 任务名称\n\tNode      string        `bson:\"node\" json:\"node\"`                 // 运行此次任务的节点 id，索引\n\tHostname  string        `bson:\"hostname\" json:\"hostname\"`         // 运行此次任务的节点主机名称，索引\n\tIP        string        `bson:\"ip\" json:\"ip\"`                     // 运行此次任务的节点主机IP，索引\n\tCommand   string        `bson:\"command\" json:\"command,omitempty\"` // 执行的命令，包括参数\n\tOutput    string        `bson:\"output\" json:\"output,omitempty\"`   // 任务输出的所有内容\n\tSuccess   bool          `bson:\"success\" json:\"success\"`           // 是否执行成功\n\tBeginTime time.Time     `bson:\"beginTime\" json:\"beginTime\"`       // 任务开始执行时间，精确到毫秒，索引\n\tEndTime   time.Time     `bson:\"endTime\" json:\"endTime\"`           // 任务执行完毕时间，精确到毫秒\n\tCleanup   time.Time     `bson:\"cleanup,omitempty\" json:\"-\"`       // 日志清除时间标志\n}\n\ntype JobLatestLog struct {\n\tJobLog   `bson:\",inline\"`\n\tRefLogId string `bson:\"refLogId,omitempty\" json:\"refLogId\"`\n}\n\nfunc GetJobLogById(id bson.ObjectId) (l *JobLog, err error) {\n\terr = mgoDB.FindId(Coll_JobLog, id, &l)\n\treturn\n}\n\nvar selectForJobLogList = bson.M{\"command\": 0, \"output\": 0}\n\nfunc GetJobLogList(query bson.M, page, size int, sort string) (list []*JobLog, total int, err error) {\n\terr = mgoDB.WithC(Coll_JobLog, func(c *mgo.Collection) error {\n\t\ttotal, err = c.Find(query).Count()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn c.Find(query).Select(selectForJobLogList).Sort(sort).Skip((page - 1) * size).Limit(size).All(&list)\n\t})\n\treturn\n}\n\nfunc GetJobLatestLogList(query bson.M, page, size int, sort string) (list []*JobLatestLog, total int, err error) {\n\terr = mgoDB.WithC(Coll_JobLatestLog, func(c *mgo.Collection) error {\n\t\ttotal, err = c.Find(query).Count()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn c.Find(query).Select(selectForJobLogList).Sort(sort).Skip((page - 1) * size).Limit(size).All(&list)\n\t})\n\treturn\n}\n\nfunc GetJobLatestLogListByJobIds(jobIds []string) (m map[string]*JobLatestLog, err error) {\n\tvar list []*JobLatestLog\n\n\terr = mgoDB.WithC(Coll_JobLatestLog, func(c *mgo.Collection) error {\n\t\treturn c.Find(bson.M{\"jobId\": bson.M{\"$in\": jobIds}}).Select(selectForJobLogList).Sort(\"beginTime\").All(&list)\n\t})\n\tif err != nil {\n\t\treturn\n\t}\n\n\tm = make(map[string]*JobLatestLog, len(list))\n\tfor i := range list {\n\t\tm[list[i].JobId] = list[i]\n\t}\n\treturn\n}\n\nfunc CreateJobLog(j *Job, t time.Time, rs string, success bool) {\n\tet := time.Now()\n\tj.Avg(t, et)\n\n\tjl := JobLog{\n\t\tId:    bson.NewObjectId(),\n\t\tJobId: j.ID,\n\n\t\tJobGroup: j.Group,\n\t\tName:     j.Name,\n\t\tUser:     j.User,\n\n\t\tNode:     j.runOn,\n\t\tHostname: j.hostname,\n\t\tIP:       j.ip,\n\n\t\tCommand: j.Command,\n\t\tOutput:  rs,\n\t\tSuccess: success,\n\n\t\tBeginTime: t,\n\t\tEndTime:   et,\n\t}\n\n\tif conf.Config.Web.LogCleaner.EveryMinute > 0 {\n\t\tvar expiration int\n\t\tif j.LogExpiration > 0 {\n\t\t\texpiration = j.LogExpiration\n\t\t} else {\n\t\t\texpiration = conf.Config.Web.LogCleaner.ExpirationDays\n\t\t}\n\t\tjl.Cleanup = jl.EndTime.Add(time.Duration(expiration) * time.Hour * 24)\n\t}\n\n\tif err := mgoDB.Insert(Coll_JobLog, jl); err != nil {\n\t\tlog.Errorf(err.Error())\n\t}\n\n\tlatestLog := &JobLatestLog{\n\t\tRefLogId: jl.Id.Hex(),\n\t\tJobLog:   jl,\n\t}\n\tlatestLog.Id = \"\"\n\tif err := mgoDB.Upsert(Coll_JobLatestLog, bson.M{\"node\": jl.Node, \"hostname\": jl.Hostname, \"ip\": jl.IP, \"jobId\": jl.JobId, \"jobGroup\": jl.JobGroup}, latestLog); err != nil {\n\t\tlog.Errorf(err.Error())\n\t}\n\n\tvar inc = bson.M{\"total\": 1}\n\tif jl.Success {\n\t\tinc[\"successed\"] = 1\n\t} else {\n\t\tinc[\"failed\"] = 1\n\t}\n\n\terr := mgoDB.Upsert(Coll_Stat, bson.M{\"name\": \"job-day\", \"date\": time.Now().Format(\"2006-01-02\")}, bson.M{\"$inc\": inc})\n\tif err != nil {\n\t\tlog.Errorf(\"increase stat.job %s\", err.Error())\n\t}\n\terr = mgoDB.Upsert(Coll_Stat, bson.M{\"name\": \"job\"}, bson.M{\"$inc\": inc})\n\tif err != nil {\n\t\tlog.Errorf(\"increase stat.job %s\", err.Error())\n\t}\n}\n\ntype StatExecuted struct {\n\tTotal     int64  `bson:\"total\" json:\"total\"`\n\tSuccessed int64  `bson:\"successed\" json:\"successed\"`\n\tFailed    int64  `bson:\"failed\" json:\"failed\"`\n\tDate      string `bson:\"date\" json:\"date\"`\n}\n\nfunc JobLogStat() (s *StatExecuted, err error) {\n\terr = mgoDB.FindOne(Coll_Stat, bson.M{\"name\": \"job\"}, &s)\n\treturn\n}\n\nfunc JobLogDailyStat(begin, end time.Time) (ls []*StatExecuted, err error) {\n\tconst oneDay = time.Hour * 24\n\terr = mgoDB.WithC(Coll_Stat, func(c *mgo.Collection) error {\n\t\tdateList := make([]string, 0, 8)\n\n\t\tcur := begin\n\t\tfor {\n\t\t\tdateList = append(dateList, cur.Format(\"2006-01-02\"))\n\t\t\tcur = cur.Add(oneDay)\n\t\t\tif cur.After(end) {\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\treturn c.Find(bson.M{\"name\": \"job-day\", \"date\": bson.M{\"$in\": dateList}}).Sort(\"date\").All(&ls)\n\t})\n\n\treturn\n}\n"
        },
        {
          "name": "log",
          "type": "tree",
          "content": null
        },
        {
          "name": "mdb.go",
          "type": "blob",
          "size": 0.1220703125,
          "content": "package cronsun\n\nimport (\n\t\"github.com/shunfei/cronsun/db\"\n)\n\nvar (\n\tmgoDB *db.Mdb\n)\n\nfunc GetDb() *db.Mdb {\n\treturn mgoDB\n}\n"
        },
        {
          "name": "node.go",
          "type": "blob",
          "size": 3.7939453125,
          "content": "package cronsun\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"os\"\n\t\"strconv\"\n\t\"syscall\"\n\t\"time\"\n\n\tclient \"github.com/coreos/etcd/clientv3\"\n\t\"gopkg.in/mgo.v2\"\n\t\"gopkg.in/mgo.v2/bson\"\n\n\t\"github.com/shunfei/cronsun/conf\"\n\t\"github.com/shunfei/cronsun/log\"\n)\n\nconst (\n\tColl_Node = \"node\"\n)\n\n// 执行 cron cmd 的进程\n// 注册到 /cronsun/node/<id>\ntype Node struct {\n\tID       string `bson:\"_id\" json:\"id\"`  // machine id\n\tPID      string `bson:\"pid\" json:\"pid\"` // 进程 pid\n\tPIDFile  string `bson:\"-\" json:\"-\"`\n\tIP       string `bson:\"ip\" json:\"ip\"` // node ip\n\tHostname string `bson:\"hostname\" json:\"hostname\"`\n\n\tVersion  string    `bson:\"version\" json:\"version\"`\n\tUpTime   time.Time `bson:\"up\" json:\"up\"`     // 启动时间\n\tDownTime time.Time `bson:\"down\" json:\"down\"` // 上次关闭时间\n\n\tAlived    bool `bson:\"alived\" json:\"alived\"` // 是否可用\n\tConnected bool `bson:\"-\" json:\"connected\"`   // 当 Alived 为 true 时有效，表示心跳是否正常\n}\n\nfunc (n *Node) String() string {\n\treturn \"node[\" + n.ID + \"] pid[\" + n.PID + \"]\"\n}\n\nfunc (n *Node) Put(opts ...client.OpOption) (*client.PutResponse, error) {\n\treturn DefalutClient.Put(conf.Config.Node+n.ID, n.PID, opts...)\n}\n\nfunc (n *Node) Del() (*client.DeleteResponse, error) {\n\treturn DefalutClient.Delete(conf.Config.Node + n.ID)\n}\n\n// 判断 node 是否已注册到 etcd\n// 存在则返回进行 pid，不存在返回 -1\nfunc (n *Node) Exist() (pid int, err error) {\n\tresp, err := DefalutClient.Get(conf.Config.Node + n.ID)\n\tif err != nil {\n\t\treturn\n\t}\n\n\tif len(resp.Kvs) == 0 {\n\t\treturn -1, nil\n\t}\n\n\tif pid, err = strconv.Atoi(string(resp.Kvs[0].Value)); err != nil {\n\t\tif _, err = DefalutClient.Delete(conf.Config.Node + n.ID); err != nil {\n\t\t\treturn\n\t\t}\n\t\treturn -1, nil\n\t}\n\n\tp, err := os.FindProcess(pid)\n\tif err != nil {\n\t\treturn -1, nil\n\t}\n\n\t// TODO: 暂时不考虑 linux/unix 以外的系统\n\tif p != nil && p.Signal(syscall.Signal(0)) == nil {\n\t\treturn\n\t}\n\n\treturn -1, nil\n}\n\nfunc GetNodes() (nodes []*Node, err error) {\n\treturn GetNodesBy(nil)\n}\n\nfunc GetNodesBy(query interface{}) (nodes []*Node, err error) {\n\terr = mgoDB.WithC(Coll_Node, func(c *mgo.Collection) error {\n\t\treturn c.Find(query).All(&nodes)\n\t})\n\n\treturn\n}\n\nfunc GetNodesByID(id string) (node *Node, err error) {\n\terr = mgoDB.FindId(Coll_Node, id, &node)\n\treturn\n}\n\nfunc RemoveNode(query interface{}) error {\n\treturn mgoDB.WithC(Coll_Node, func(c *mgo.Collection) error {\n\t\treturn c.Remove(query)\n\t})\n}\n\nfunc ISNodeAlive(id string) (bool, error) {\n\tn := 0\n\terr := mgoDB.WithC(Coll_Node, func(c *mgo.Collection) error {\n\t\tvar e error\n\t\tn, e = c.Find(bson.M{\"_id\": id, \"alived\": true}).Count()\n\t\treturn e\n\t})\n\n\treturn n > 0, err\n}\n\nfunc GetNodeGroups() (list []*Group, err error) {\n\tresp, err := DefalutClient.Get(conf.Config.Group, client.WithPrefix(), client.WithSort(client.SortByKey, client.SortAscend))\n\tif err != nil {\n\t\treturn\n\t}\n\n\tlist = make([]*Group, 0, resp.Count)\n\tfor i := range resp.Kvs {\n\t\tg := Group{}\n\t\terr = json.Unmarshal(resp.Kvs[i].Value, &g)\n\t\tif err != nil {\n\t\t\terr = fmt.Errorf(\"node.GetGroups(key: %s) error: %s\", string(resp.Kvs[i].Key), err.Error())\n\t\t\treturn\n\t\t}\n\t\tlist = append(list, &g)\n\t}\n\n\treturn\n}\n\nfunc WatchNode() client.WatchChan {\n\treturn DefalutClient.Watch(conf.Config.Node, client.WithPrefix())\n}\n\n// On 结点实例启动后，在 mongoDB 中记录存活信息\nfunc (n *Node) On() {\n\tn.Alived, n.Version, n.UpTime = true, Version, time.Now()\n\tn.SyncToMgo()\n}\n\n// On 结点实例停用后，在 mongoDB 中去掉存活信息\nfunc (n *Node) Down() {\n\tn.Alived, n.DownTime = false, time.Now()\n\tn.SyncToMgo()\n}\n\nfunc (n *Node) SyncToMgo() {\n\tif err := mgoDB.Upsert(Coll_Node, bson.M{\"_id\": n.ID}, n); err != nil {\n\t\tlog.Errorf(err.Error())\n\t}\n}\n\n// RmOldInfo remove old version(< 0.3.0) node info\nfunc (n *Node) RmOldInfo() {\n\tRemoveNode(bson.M{\"_id\": n.IP})\n\tDefalutClient.Delete(conf.Config.Node + n.IP)\n}\n"
        },
        {
          "name": "node",
          "type": "tree",
          "content": null
        },
        {
          "name": "noticer.go",
          "type": "blob",
          "size": 4.1357421875,
          "content": "package cronsun\n\nimport (\n\t\"bytes\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"time\"\n\n\tclient \"github.com/coreos/etcd/clientv3\"\n\t\"github.com/go-gomail/gomail\"\n\n\t\"github.com/shunfei/cronsun/conf\"\n\t\"github.com/shunfei/cronsun/log\"\n)\n\ntype Noticer interface {\n\tServe()\n\tSend(*Message)\n}\n\ntype Message struct {\n\tSubject string\n\tBody    string\n\tTo      []string\n}\n\ntype Mail struct {\n\tcf      *conf.MailConf\n\topen    bool\n\tsc      gomail.SendCloser\n\ttimer   *time.Timer\n\tmsgChan chan *Message\n}\n\nfunc NewMail(timeout time.Duration) (m *Mail, err error) {\n\tvar (\n\t\tsc   gomail.SendCloser\n\t\tdone = make(chan struct{})\n\t\tcf   = conf.Config.Mail\n\t)\n\n\t// qq 邮箱的 Auth 出错后， 501 命令超时 2min 才能退出\n\tgo func() {\n\t\tsc, err = cf.Dialer.Dial()\n\t\tclose(done)\n\t}()\n\n\tselect {\n\tcase <-done:\n\tcase <-time.After(timeout):\n\t\terr = fmt.Errorf(\"connect to smtp timeout\")\n\t}\n\n\tif err != nil {\n\t\treturn\n\t}\n\n\tm = &Mail{\n\t\tcf:      cf,\n\t\topen:    true,\n\t\tsc:      sc,\n\t\ttimer:   time.NewTimer(time.Duration(cf.Keepalive) * time.Second),\n\t\tmsgChan: make(chan *Message, 8),\n\t}\n\treturn\n}\n\nfunc (m *Mail) Serve() {\n\tvar err error\n\tsm := gomail.NewMessage()\n\tfor {\n\t\tselect {\n\t\tcase msg := <-m.msgChan:\n\t\t\tm.timer.Reset(time.Duration(m.cf.Keepalive) * time.Second)\n\t\t\tif !m.open {\n\t\t\t\tif m.sc, err = m.cf.Dialer.Dial(); err != nil {\n\t\t\t\t\tlog.Warnf(\"smtp send msg[%+v] err: %s\", msg, err.Error())\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\tm.open = true\n\t\t\t}\n\n\t\t\tsm.Reset()\n\t\t\tsm.SetHeader(\"From\", m.cf.Username)\n\t\t\tsm.SetHeader(\"To\", msg.To...)\n\t\t\tsm.SetHeader(\"Subject\", msg.Subject)\n\t\t\tsm.SetBody(\"text/plain\", msg.Body)\n\t\t\tif err := gomail.Send(m.sc, sm); err != nil {\n\t\t\t\tlog.Warnf(\"smtp send msg[%+v] err: %s\", msg, err.Error())\n\t\t\t}\n\t\tcase <-m.timer.C:\n\t\t\tif m.open {\n\t\t\t\tif err = m.sc.Close(); err != nil {\n\t\t\t\t\tlog.Warnf(\"close smtp server err: %s\", err.Error())\n\t\t\t\t}\n\t\t\t\tm.open = false\n\t\t\t}\n\t\t\tm.timer.Reset(time.Duration(m.cf.Keepalive) * time.Second)\n\t\t}\n\t}\n}\n\nfunc (m *Mail) Send(msg *Message) {\n\tm.msgChan <- msg\n}\n\ntype HttpAPI struct{}\n\nfunc (h *HttpAPI) Serve() {}\n\nfunc (h *HttpAPI) Send(msg *Message) {\n\tbody, err := json.Marshal(msg)\n\tif err != nil {\n\t\tlog.Warnf(\"http api send msg[%+v] err: %s\", msg, err.Error())\n\t\treturn\n\t}\n\n\treq, err := http.NewRequest(\"POST\", conf.Config.Mail.HttpAPI, bytes.NewBuffer(body))\n\tif err != nil {\n\t\treturn\n\t}\n\n\treq.Header.Set(\"Content-Type\", \"application/json\")\n\tresp, err := http.DefaultClient.Do(req)\n\tif err != nil {\n\t\tlog.Warnf(\"http api send msg[%+v] err: %s\", msg, err.Error())\n\t\treturn\n\t}\n\tdefer resp.Body.Close()\n\n\tif resp.StatusCode == 200 {\n\t\treturn\n\t}\n\n\tdata, err := ioutil.ReadAll(resp.Body)\n\tif err != nil {\n\t\tlog.Warnf(\"http api send msg[%+v] err: %s\", msg, err.Error())\n\t\treturn\n\t}\n\tlog.Warnf(\"http api send msg[%+v] err: %s\", msg, string(data))\n\treturn\n}\n\nfunc StartNoticer(n Noticer) {\n\tgo n.Serve()\n\tgo monitorNodes(n)\n\n\trch := DefalutClient.Watch(conf.Config.Noticer, client.WithPrefix())\n\tvar err error\n\tfor wresp := range rch {\n\t\tfor _, ev := range wresp.Events {\n\t\t\tswitch {\n\t\t\tcase ev.IsCreate(), ev.IsModify():\n\t\t\t\tmsg := new(Message)\n\t\t\t\tif err = json.Unmarshal(ev.Kv.Value, msg); err != nil {\n\t\t\t\t\tlog.Warnf(\"msg[%s] umarshal err: %s\", string(ev.Kv.Value), err.Error())\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\n\t\t\t\tif len(conf.Config.Mail.To) > 0 {\n\t\t\t\t\tmsg.To = append(msg.To, conf.Config.Mail.To...)\n\t\t\t\t}\n\t\t\t\tn.Send(msg)\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc monitorNodes(n Noticer) {\n\trch := WatchNode()\n\n\tfor wresp := range rch {\n\t\tfor _, ev := range wresp.Events {\n\t\t\tswitch {\n\t\t\tcase ev.Type == client.EventTypeDelete:\n\t\t\t\tid := GetIDFromKey(string(ev.Kv.Key))\n\t\t\t\tlog.Errorf(\"cronnode DELETE event detected, node UUID: %s\", id)\n\n\t\t\t\tnode, err := GetNodesByID(id)\n\t\t\t\tif err != nil {\n\t\t\t\t\tlog.Warnf(\"failed to fetch node[%s] from mongodb: %s\", id, err.Error())\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\n\t\t\t\tif node.Alived {\n\t\t\t\t\tn.Send(&Message{\n\t\t\t\t\t\tSubject: fmt.Sprintf(\"[Cronsun Warning] Node[%s] break away cluster at %s\",\n\t\t\t\t\t\t\tnode.Hostname, time.Now().Format(time.RFC3339)),\n\t\t\t\t\t\tBody: fmt.Sprintf(\"Cronsun Node breaked away cluster, this might happened when node crash or network problems.\\nUUID: %s\\nHostname: %s\\nIP: %s\\n\", id, node.Hostname, node.IP),\n\t\t\t\t\t\tTo:   conf.Config.Mail.To,\n\t\t\t\t\t})\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n"
        },
        {
          "name": "once.go",
          "type": "blob",
          "size": 0.513671875,
          "content": "package cronsun\n\nimport (\n\tclient \"github.com/coreos/etcd/clientv3\"\n\n\t\"github.com/shunfei/cronsun/conf\"\n)\n\n// 马上执行 job 任务\n// 注册到 /cronsun/once/group/<jobID>\n// value\n// 若执行单个结点，则值为 NodeID\n// 若 job 所在的结点都需执行，则值为空 \"\"\nfunc PutOnce(group, jobID, nodeID string) error {\n\t_, err := DefalutClient.Put(conf.Config.Once+group+\"/\"+jobID, nodeID)\n\treturn err\n}\n\nfunc WatchOnce() client.WatchChan {\n\treturn DefalutClient.Watch(conf.Config.Once, client.WithPrefix())\n}\n"
        },
        {
          "name": "proc.go",
          "type": "blob",
          "size": 4.9599609375,
          "content": "package cronsun\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"strings\"\n\t\"sync\"\n\t\"sync/atomic\"\n\t\"time\"\n\n\tclient \"github.com/coreos/etcd/clientv3\"\n\n\t\"github.com/shunfei/cronsun/conf\"\n\t\"github.com/shunfei/cronsun/log\"\n)\n\nvar (\n\tlID *leaseID\n)\n\n// 维持 lease id 服务\nfunc StartProc() error {\n\tlID = &leaseID{\n\t\tttl:  conf.Config.ProcTtl,\n\t\tlk:   new(sync.RWMutex),\n\t\tdone: make(chan struct{}),\n\t}\n\n\tif lID.ttl == 0 {\n\t\treturn nil\n\t}\n\n\terr := lID.set()\n\tgo lID.keepAlive()\n\treturn err\n}\n\nfunc Reload(i interface{}) {\n\tif lID.ttl == conf.Config.ProcTtl {\n\t\treturn\n\t}\n\n\tclose(lID.done)\n\tlID.done, lID.ttl = make(chan struct{}), conf.Config.ProcTtl\n\tif conf.Config.ProcTtl == 0 {\n\t\treturn\n\t}\n\n\tif err := lID.set(); err != nil {\n\t\tlog.Warnf(\"proc lease id set err: %s\", err.Error())\n\t}\n\tgo lID.keepAlive()\n}\n\nfunc Exit(i interface{}) {\n\tif lID.done != nil {\n\t\tclose(lID.done)\n\t}\n}\n\ntype leaseID struct {\n\tttl int64\n\tID  client.LeaseID\n\tlk  *sync.RWMutex\n\n\tdone chan struct{}\n}\n\nfunc (l *leaseID) get() client.LeaseID {\n\tif l.ttl == 0 {\n\t\treturn -1\n\t}\n\n\tl.lk.RLock()\n\tid := l.ID\n\tl.lk.RUnlock()\n\treturn id\n}\n\nfunc (l *leaseID) set() error {\n\tid := client.LeaseID(-1)\n\tresp, err := DefalutClient.Grant(l.ttl + 2)\n\tif err == nil {\n\t\tid = resp.ID\n\t}\n\n\tl.lk.Lock()\n\tl.ID = id\n\tl.lk.Unlock()\n\treturn err\n}\n\nfunc (l *leaseID) keepAlive() {\n\tduration := time.Duration(l.ttl) * time.Second\n\ttimer := time.NewTimer(duration)\n\tfor {\n\t\tselect {\n\t\tcase <-l.done:\n\t\t\treturn\n\t\tcase <-timer.C:\n\t\t\tif l.ttl == 0 {\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tid := l.get()\n\t\t\tif id > 0 {\n\t\t\t\t_, err := DefalutClient.KeepAliveOnce(l.ID)\n\t\t\t\tif err == nil {\n\t\t\t\t\ttimer.Reset(duration)\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\n\t\t\t\tlog.Warnf(\"proc lease id[%x] keepAlive err: %s, try to reset...\", id, err.Error())\n\t\t\t}\n\n\t\t\tif err := l.set(); err != nil {\n\t\t\t\tlog.Warnf(\"proc lease id set err: %s, try to reset after %d seconds...\", err.Error(), l.ttl)\n\t\t\t} else {\n\t\t\t\tlog.Infof(\"proc set lease id[%x] success\", l.get())\n\t\t\t}\n\t\t\ttimer.Reset(duration)\n\t\t}\n\t}\n}\n\n// 当前执行中的任务信息\n// key: /cronsun/proc/node/group/jobId/pid\n// value: 开始执行时间\n// key 会自动过期，防止进程意外退出后没有清除相关 key，过期时间可配置\ntype Process struct {\n\t// parse from key path\n\tID     string `json:\"id\"` // pid\n\tJobID  string `json:\"jobId\"`\n\tGroup  string `json:\"group\"`\n\tNodeID string `json:\"nodeId\"`\n\t// parse from value\n\tProcessVal\n\n\trunning int32\n\thasPut  int32\n\twg      sync.WaitGroup\n\tdone    chan struct{}\n}\n\ntype ProcessVal struct {\n\tTime   time.Time `json:\"time\"`   // 开始执行时间\n\tKilled bool      `json:\"killed\"` // 是否强制杀死\n}\n\nfunc GetProcFromKey(key string) (proc *Process, err error) {\n\tss := strings.Split(key, \"/\")\n\tvar sslen = len(ss)\n\tif sslen < 5 {\n\t\terr = fmt.Errorf(\"invalid proc key [%s]\", key)\n\t\treturn\n\t}\n\n\tproc = &Process{\n\t\tID:     ss[sslen-1],\n\t\tJobID:  ss[sslen-2],\n\t\tGroup:  ss[sslen-3],\n\t\tNodeID: ss[sslen-4],\n\t}\n\treturn\n}\n\nfunc (p *Process) Key() string {\n\treturn conf.Config.Proc + p.NodeID + \"/\" + p.Group + \"/\" + p.JobID + \"/\" + p.ID\n}\n\nfunc (p *Process) Val() (string, error) {\n\tb, err := json.Marshal(&p.ProcessVal)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\treturn string(b), nil\n}\n\n// 获取节点正在执行任务的数量\nfunc (j *Job) CountRunning() (int64, error) {\n\tresp, err := DefalutClient.Get(conf.Config.Proc+j.runOn+\"/\"+j.Group+\"/\"+j.ID, client.WithPrefix(), client.WithCountOnly())\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\n\treturn resp.Count, nil\n}\n\n// put 出错也进行 del 操作\n// 有可能某种原因，put 命令已经发送到 etcd server\n// 目前已知的 deadline 会出现此情况\nfunc (p *Process) put() (err error) {\n\tif atomic.LoadInt32(&p.running) != 1 {\n\t\treturn\n\t}\n\n\tif !atomic.CompareAndSwapInt32(&p.hasPut, 0, 1) {\n\t\treturn\n\t}\n\n\tid := lID.get()\n\tval, err := p.Val()\n\tif err != nil {\n\t\treturn err\n\t}\n\tif id < 0 {\n\t\tif _, err = DefalutClient.Put(p.Key(), val); err != nil {\n\t\t\treturn\n\t\t}\n\t}\n\n\t_, err = DefalutClient.Put(p.Key(), val, client.WithLease(id))\n\treturn\n}\n\nfunc (p *Process) del() error {\n\tif atomic.LoadInt32(&p.hasPut) != 1 {\n\t\treturn nil\n\t}\n\n\t_, err := DefalutClient.Delete(p.Key())\n\treturn err\n}\n\nfunc (p *Process) Start() {\n\tif p == nil {\n\t\treturn\n\t}\n\n\tif !atomic.CompareAndSwapInt32(&p.running, 0, 1) {\n\t\treturn\n\t}\n\n\tif conf.Config.ProcReq == 0 {\n\t\tif err := p.put(); err != nil {\n\t\t\tlog.Warnf(\"proc put[%s] err: %s\", p.Key(), err.Error())\n\t\t}\n\t\treturn\n\t}\n\n\tp.done = make(chan struct{})\n\tp.wg.Add(1)\n\tgo func() {\n\t\tselect {\n\t\tcase <-p.done:\n\t\tcase <-time.After(time.Duration(conf.Config.ProcReq) * time.Second):\n\t\t\tif err := p.put(); err != nil {\n\t\t\t\tlog.Warnf(\"proc put[%s] err: %s\", p.Key(), err.Error())\n\t\t\t}\n\t\t}\n\t\tp.wg.Done()\n\t}()\n}\n\nfunc (p *Process) Stop() {\n\tif p == nil {\n\t\treturn\n\t}\n\n\tif !atomic.CompareAndSwapInt32(&p.running, 1, 0) {\n\t\treturn\n\t}\n\n\tif p.done != nil {\n\t\tclose(p.done)\n\t}\n\tp.wg.Wait()\n\n\tif err := p.del(); err != nil {\n\t\tlog.Warnf(\"proc del[%s] err: %s\", p.Key(), err.Error())\n\t}\n}\n\nfunc WatchProcs(nid string) client.WatchChan {\n\treturn DefalutClient.Watch(conf.Config.Proc+nid, client.WithPrefix())\n}\n"
        },
        {
          "name": "release.sh",
          "type": "blob",
          "size": 0.314453125,
          "content": "#!/bin/sh\n\nversion=v0.1\nif [[ $# -gt 0 ]]; then\n\tversion=\"$1\"\nfi\n\n\ndeclare -a goos=(\n\tlinux\n\tdarwin\n)\n\nfor os in \"${goos[@]}\"; do\n\texport GOOS=$os GOARCH=amd64\n\techo building $GOOS-$GOARCH\n\tsh build.sh\n\tmv dist cronsun-$version\n\t7z a cronsun-$version-$GOOS-$GOARCH.zip cronsun-$version\n\trm -rf cronsun-$version\n\techo\ndone\n"
        },
        {
          "name": "utils",
          "type": "tree",
          "content": null
        },
        {
          "name": "version.go",
          "type": "blob",
          "size": 0.1572265625,
          "content": "package cronsun\n\nimport (\n\t\"fmt\"\n\t\"runtime\"\n)\n\nconst VersionNumber = \"0.3.5\"\n\nvar (\n\tVersion = fmt.Sprintf(\"v%s (build %s)\", VersionNumber, runtime.Version())\n)\n"
        },
        {
          "name": "web",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}