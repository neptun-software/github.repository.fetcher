{
  "metadata": {
    "timestamp": 1736566663160,
    "page": 217,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjIyMA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "rs/xid",
      "stars": 3999,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".appveyor.yml",
          "type": "blob",
          "size": 0.3271484375,
          "content": "version: 1.0.0.{build}\n\nplatform: x64\n\nbranches:\n  only:\n    - master\n\nclone_folder: c:\\gopath\\src\\github.com\\rs\\xid\n\nenvironment:\n  GOPATH: c:\\gopath\n\ninstall:\n  - echo %PATH%\n  - echo %GOPATH%\n  - set PATH=%GOPATH%\\bin;c:\\go\\bin;%PATH%\n  - go version\n  - go env\n  - go get -t .\n\nbuild_script:\n  - go build\n\ntest_script:\n  - go test\n\n"
        },
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.0244140625,
          "content": "/.idea\n/.vscode\n.DS_Store"
        },
        {
          "name": ".golangci.yml",
          "type": "blob",
          "size": 0.048828125,
          "content": "run:\n  tests: false\n\noutput:\n  sort-results: true\n"
        },
        {
          "name": ".travis.yml",
          "type": "blob",
          "size": 0.08984375,
          "content": "language: go\ngo:\n- \"1.9\"\n- \"1.10\"\n- \"master\"\nmatrix:\n  allow_failures:\n      - go: \"master\"\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.0546875,
          "content": "Copyright (c) 2015 Olivier Poitrey <rs@dailymotion.com>\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is furnished\nto do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 6.5498046875,
          "content": "# Globally Unique ID Generator\n\n[![godoc](http://img.shields.io/badge/godoc-reference-blue.svg?style=flat)](https://godoc.org/github.com/rs/xid) [![license](http://img.shields.io/badge/license-MIT-red.svg?style=flat)](https://raw.githubusercontent.com/rs/xid/master/LICENSE) [![Build Status](https://travis-ci.org/rs/xid.svg?branch=master)](https://travis-ci.org/rs/xid) [![Coverage](http://gocover.io/_badge/github.com/rs/xid)](http://gocover.io/github.com/rs/xid)\n\nPackage xid is a globally unique id generator library, ready to safely be used directly in your server code.\n\nXid uses the Mongo Object ID algorithm to generate globally unique ids with a different serialization ([base32hex](https://datatracker.ietf.org/doc/html/rfc4648#page-10)) to make it shorter when transported as a string:\nhttps://docs.mongodb.org/manual/reference/object-id/\n\n- 4-byte value representing the seconds since the Unix epoch,\n- 3-byte machine identifier,\n- 2-byte process id, and\n- 3-byte counter, starting with a random value.\n\nThe binary representation of the id is compatible with Mongo 12 bytes Object IDs.\nThe string representation is using [base32hex](https://datatracker.ietf.org/doc/html/rfc4648#page-10) (w/o padding) for better space efficiency\nwhen stored in that form (20 bytes). The hex variant of base32 is used to retain the\nsortable property of the id.\n\nXid doesn't use base64 because case sensitivity and the 2 non alphanum chars may be an\nissue when transported as a string between various systems. Base36 wasn't retained either\nbecause 1/ it's not standard 2/ the resulting size is not predictable (not bit aligned)\nand 3/ it would not remain sortable. To validate a base32 `xid`, expect a 20 chars long,\nall lowercase sequence of `a` to `v` letters and `0` to `9` numbers (`[0-9a-v]{20}`).\n\nUUIDs are 16 bytes (128 bits) and 36 chars as string representation. Twitter Snowflake\nids are 8 bytes (64 bits) but require machine/data-center configuration and/or central\ngenerator servers. xid stands in between with 12 bytes (96 bits) and a more compact\nURL-safe string representation (20 chars). No configuration or central generator server\nis required so it can be used directly in server's code.\n\n| Name        | Binary Size | String Size    | Features\n|-------------|-------------|----------------|----------------\n| [UUID]      | 16 bytes    | 36 chars       | configuration free, not sortable\n| [shortuuid] | 16 bytes    | 22 chars       | configuration free, not sortable\n| [Snowflake] | 8 bytes     | up to 20 chars | needs machine/DC configuration, needs central server, sortable\n| [MongoID]   | 12 bytes    | 24 chars       | configuration free, sortable\n| xid         | 12 bytes    | 20 chars       | configuration free, sortable\n\n[UUID]: https://en.wikipedia.org/wiki/Universally_unique_identifier\n[shortuuid]: https://github.com/stochastic-technologies/shortuuid\n[Snowflake]: https://blog.twitter.com/2010/announcing-snowflake\n[MongoID]: https://docs.mongodb.org/manual/reference/object-id/\n\nFeatures:\n\n- Size: 12 bytes (96 bits), smaller than UUID, larger than snowflake\n- Base32 hex encoded by default (20 chars when transported as printable string, still sortable)\n- Non configured, you don't need set a unique machine and/or data center id\n- K-ordered\n- Embedded time with 1 second precision\n- Unicity guaranteed for 16,777,216 (24 bits) unique ids per second and per host/process\n- Lock-free (i.e.: unlike UUIDv1 and v2)\n\nBest used with [zerolog](https://github.com/rs/zerolog)'s\n[RequestIDHandler](https://godoc.org/github.com/rs/zerolog/hlog#RequestIDHandler).\n\nNotes:\n\n- Xid is dependent on the system time, a monotonic counter and so is not cryptographically secure. If unpredictability of IDs is important, you should not use Xids. It is worth noting that most other UUID-like implementations are also not cryptographically secure. You should use libraries that rely on cryptographically secure sources (like /dev/urandom on unix, crypto/rand in golang), if you want a truly random ID generator.\n\nReferences:\n\n- http://www.slideshare.net/davegardnerisme/unique-id-generation-in-distributed-systems\n- https://en.wikipedia.org/wiki/Universally_unique_identifier\n- https://blog.twitter.com/2010/announcing-snowflake\n- Python port by [Graham Abbott](https://github.com/graham): https://github.com/graham/python_xid\n- Scala port by [Egor Kolotaev](https://github.com/kolotaev): https://github.com/kolotaev/ride\n- Rust port by [Kaz Yoshihara](https://github.com/kazk): https://github.com/kazk/xid-rs\n- Python wrapper around the Rust port [Aleksandr Shpak](https://github.com/shpaker): https://github.com/shpaker/epyxid\n- Ruby port by [Valar](https://github.com/valarpirai/): https://github.com/valarpirai/ruby_xid\n- Java port by [0xShamil](https://github.com/0xShamil/): https://github.com/0xShamil/java-xid\n- Dart port by [Peter Bwire](https://github.com/pitabwire): https://pub.dev/packages/xid\n- PostgreSQL port by [Rasmus Holm](https://github.com/crholm): https://github.com/modfin/pg-xid\n- Swift port by [Uditha Atukorala](https://github.com/uatuko): https://github.com/uatuko/swift-xid\n- C++ port by [Uditha Atukorala](https://github.com/uatuko): https://github.com/uatuko/libxid\n- Typescript & Javascript port by [Yiwen AI](https://github.com/yiwen-ai): https://github.com/yiwen-ai/xid-ts\n- Gleam port by [Alexandre Del Vecchio](https://github.com/defgenx): https://github.com/defgenx/gxid\n\n## Install\n\n    go get github.com/rs/xid\n\n## Usage\n\n```go\nguid := xid.New()\n\nprintln(guid.String())\n// Output: 9m4e2mr0ui3e8a215n4g\n```\n\nGet `xid` embedded info:\n\n```go\nguid.Machine()\nguid.Pid()\nguid.Time()\nguid.Counter()\n```\n\n## Benchmark\n\nBenchmark against Go [Maxim Bublis](https://github.com/satori)'s [UUID](https://github.com/satori/go.uuid).\n\n```\nBenchmarkXID        \t20000000\t        91.1 ns/op\t      32 B/op\t       1 allocs/op\nBenchmarkXID-2      \t20000000\t        55.9 ns/op\t      32 B/op\t       1 allocs/op\nBenchmarkXID-4      \t50000000\t        32.3 ns/op\t      32 B/op\t       1 allocs/op\nBenchmarkUUIDv1     \t10000000\t       204 ns/op\t      48 B/op\t       1 allocs/op\nBenchmarkUUIDv1-2   \t10000000\t       160 ns/op\t      48 B/op\t       1 allocs/op\nBenchmarkUUIDv1-4   \t10000000\t       195 ns/op\t      48 B/op\t       1 allocs/op\nBenchmarkUUIDv4     \t 1000000\t      1503 ns/op\t      64 B/op\t       2 allocs/op\nBenchmarkUUIDv4-2   \t 1000000\t      1427 ns/op\t      64 B/op\t       2 allocs/op\nBenchmarkUUIDv4-4   \t 1000000\t      1452 ns/op\t      64 B/op\t       2 allocs/op\n```\n\nNote: UUIDv1 requires a global lock, hence the performance degradation as we add more CPUs.\n\n## Licenses\n\nAll source code is licensed under the [MIT License](https://raw.github.com/rs/xid/master/LICENSE).\n"
        },
        {
          "name": "b",
          "type": "tree",
          "content": null
        },
        {
          "name": "error.go",
          "type": "blob",
          "size": 0.251953125,
          "content": "package xid\n\nconst (\n\t// ErrInvalidID is returned when trying to unmarshal an invalid ID.\n\tErrInvalidID strErr = \"xid: invalid ID\"\n)\n\n// strErr allows declaring errors as constants.\ntype strErr string\n\nfunc (err strErr) Error() string { return string(err) }\n"
        },
        {
          "name": "go.mod",
          "type": "blob",
          "size": 0.033203125,
          "content": "module github.com/rs/xid\n\ngo 1.16\n"
        },
        {
          "name": "hostid_darwin.go",
          "type": "blob",
          "size": 0.6416015625,
          "content": "// +build darwin\n\npackage xid\n\nimport (\n\t\"errors\"\n\t\"os/exec\"\n\t\"strings\"\n)\n\nfunc readPlatformMachineID() (string, error) {\n\tioreg, err := exec.LookPath(\"ioreg\")\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\tcmd := exec.Command(ioreg, \"-rd1\", \"-c\", \"IOPlatformExpertDevice\")\n\tout, err := cmd.CombinedOutput()\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\tfor _, line := range strings.Split(string(out), \"\\n\") {\n\t\tif strings.Contains(line, \"IOPlatformUUID\") {\n\t\t\tparts := strings.SplitAfter(line, `\" = \"`)\n\t\t\tif len(parts) == 2 {\n\t\t\t\tuuid := strings.TrimRight(parts[1], `\"`)\n\t\t\t\treturn strings.ToLower(uuid), nil\n\t\t\t}\n\t\t}\n\t}\n\n\treturn \"\", errors.New(\"cannot find host id\")\n}\n"
        },
        {
          "name": "hostid_fallback.go",
          "type": "blob",
          "size": 0.1611328125,
          "content": "// +build !darwin,!linux,!freebsd,!windows\n\npackage xid\n\nimport \"errors\"\n\nfunc readPlatformMachineID() (string, error) {\n\treturn \"\", errors.New(\"not implemented\")\n}\n"
        },
        {
          "name": "hostid_freebsd.go",
          "type": "blob",
          "size": 0.1357421875,
          "content": "// +build freebsd\n\npackage xid\n\nimport \"syscall\"\n\nfunc readPlatformMachineID() (string, error) {\n\treturn syscall.Sysctl(\"kern.hostuuid\")\n}\n"
        },
        {
          "name": "hostid_linux.go",
          "type": "blob",
          "size": 0.2431640625,
          "content": "// +build linux\n\npackage xid\n\nimport \"os\"\n\nfunc readPlatformMachineID() (string, error) {\n\tb, err := os.ReadFile(\"/etc/machine-id\")\n\tif err != nil || len(b) == 0 {\n\t\tb, err = os.ReadFile(\"/sys/class/dmi/id/product_uuid\")\n\t}\n\treturn string(b), err\n}\n"
        },
        {
          "name": "hostid_windows.go",
          "type": "blob",
          "size": 1.33203125,
          "content": "// +build windows\n\npackage xid\n\nimport (\n\t\"fmt\"\n\t\"syscall\"\n\t\"unsafe\"\n)\n\nfunc readPlatformMachineID() (string, error) {\n\t// source: https://github.com/shirou/gopsutil/blob/master/host/host_syscall.go\n\tvar h syscall.Handle\n\n\tregKeyCryptoPtr, err := syscall.UTF16PtrFromString(`SOFTWARE\\Microsoft\\Cryptography`)\n\tif err != nil {\n\t\treturn \"\", fmt.Errorf(`error reading registry key \"SOFTWARE\\Microsoft\\Cryptography\": %w`, err)\n\t}\n\n\terr = syscall.RegOpenKeyEx(syscall.HKEY_LOCAL_MACHINE, regKeyCryptoPtr, 0, syscall.KEY_READ|syscall.KEY_WOW64_64KEY, &h)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\tdefer func() { _ = syscall.RegCloseKey(h) }()\n\n\tconst syscallRegBufLen = 74 // len(`{`) + len(`abcdefgh-1234-456789012-123345456671` * 2) + len(`}`) // 2 == bytes/UTF16\n\tconst uuidLen = 36\n\n\tvar regBuf [syscallRegBufLen]uint16\n\tbufLen := uint32(syscallRegBufLen)\n\tvar valType uint32\n\n\tmGuidPtr, err := syscall.UTF16PtrFromString(`MachineGuid`)\n\tif err != nil {\n\t\treturn \"\", fmt.Errorf(\"error reading machine GUID: %w\", err)\n\t}\n\n\terr = syscall.RegQueryValueEx(h, mGuidPtr, nil, &valType, (*byte)(unsafe.Pointer(&regBuf[0])), &bufLen)\n\tif err != nil {\n\t\treturn \"\", fmt.Errorf(\"error parsing \")\n\t}\n\n\thostID := syscall.UTF16ToString(regBuf[:])\n\thostIDLen := len(hostID)\n\tif hostIDLen != uuidLen {\n\t\treturn \"\", fmt.Errorf(\"HostID incorrect: %q\\n\", hostID)\n\t}\n\n\treturn hostID, nil\n}\n"
        },
        {
          "name": "id.go",
          "type": "blob",
          "size": 11.01953125,
          "content": "// Package xid is a globally unique id generator suited for web scale\n//\n// Xid is using Mongo Object ID algorithm to generate globally unique ids:\n// https://docs.mongodb.org/manual/reference/object-id/\n//\n//   - 4-byte value representing the seconds since the Unix epoch,\n//   - 3-byte machine identifier,\n//   - 2-byte process id, and\n//   - 3-byte counter, starting with a random value.\n//\n// The binary representation of the id is compatible with Mongo 12 bytes Object IDs.\n// The string representation is using base32 hex (w/o padding) for better space efficiency\n// when stored in that form (20 bytes). The hex variant of base32 is used to retain the\n// sortable property of the id.\n//\n// Xid doesn't use base64 because case sensitivity and the 2 non alphanum chars may be an\n// issue when transported as a string between various systems. Base36 wasn't retained either\n// because 1/ it's not standard 2/ the resulting size is not predictable (not bit aligned)\n// and 3/ it would not remain sortable. To validate a base32 `xid`, expect a 20 chars long,\n// all lowercase sequence of `a` to `v` letters and `0` to `9` numbers (`[0-9a-v]{20}`).\n//\n// UUID is 16 bytes (128 bits), snowflake is 8 bytes (64 bits), xid stands in between\n// with 12 bytes with a more compact string representation ready for the web and no\n// required configuration or central generation server.\n//\n// Features:\n//\n//   - Size: 12 bytes (96 bits), smaller than UUID, larger than snowflake\n//   - Base32 hex encoded by default (16 bytes storage when transported as printable string)\n//   - Non configured, you don't need set a unique machine and/or data center id\n//   - K-ordered\n//   - Embedded time with 1 second precision\n//   - Unicity guaranteed for 16,777,216 (24 bits) unique ids per second and per host/process\n//\n// Best used with xlog's RequestIDHandler (https://godoc.org/github.com/rs/xlog#RequestIDHandler).\n//\n// References:\n//\n//   - http://www.slideshare.net/davegardnerisme/unique-id-generation-in-distributed-systems\n//   - https://en.wikipedia.org/wiki/Universally_unique_identifier\n//   - https://blog.twitter.com/2010/announcing-snowflake\npackage xid\n\nimport (\n\t\"bytes\"\n\t\"crypto/rand\"\n\t\"crypto/sha256\"\n\t\"database/sql/driver\"\n\t\"encoding/binary\"\n\t\"fmt\"\n\t\"hash/crc32\"\n\t\"os\"\n\t\"sort\"\n\t\"sync/atomic\"\n\t\"time\"\n)\n\n// Code inspired from mgo/bson ObjectId\n\n// ID represents a unique request id\ntype ID [rawLen]byte\n\nconst (\n\tencodedLen = 20 // string encoded len\n\trawLen     = 12 // binary raw len\n\n\t// encoding stores a custom version of the base32 encoding with lower case\n\t// letters.\n\tencoding = \"0123456789abcdefghijklmnopqrstuv\"\n)\n\nvar (\n\t// objectIDCounter is atomically incremented when generating a new ObjectId. It's\n\t// used as the counter part of an id. This id is initialized with a random value.\n\tobjectIDCounter = randInt()\n\n\t// machineID is generated once and used in subsequent calls to the New* functions.\n\tmachineID = readMachineID()\n\n\t// pid stores the current process id\n\tpid = os.Getpid()\n\n\tnilID ID\n\n\t// dec is the decoding map for base32 encoding\n\tdec [256]byte\n)\n\nfunc init() {\n\tfor i := 0; i < len(dec); i++ {\n\t\tdec[i] = 0xFF\n\t}\n\tfor i := 0; i < len(encoding); i++ {\n\t\tdec[encoding[i]] = byte(i)\n\t}\n\n\t// If /proc/self/cpuset exists and is not /, we can assume that we are in a\n\t// form of container and use the content of cpuset xor-ed with the PID in\n\t// order get a reasonable machine global unique PID.\n\tb, err := os.ReadFile(\"/proc/self/cpuset\")\n\tif err == nil && len(b) > 1 {\n\t\tpid ^= int(crc32.ChecksumIEEE(b))\n\t}\n}\n\n// readMachineID generates a machine ID, derived from a platform-specific machine ID\n// value, or else the machine's hostname, or else a randomly-generated number.\n// It panics if all of these methods fail.\nfunc readMachineID() []byte {\n\tid := make([]byte, 3)\n\thid, err := readPlatformMachineID()\n\tif err != nil || len(hid) == 0 {\n\t\thid, err = os.Hostname()\n\t}\n\tif err == nil && len(hid) != 0 {\n\t\thw := sha256.New()\n\t\thw.Write([]byte(hid))\n\t\tcopy(id, hw.Sum(nil))\n\t} else {\n\t\t// Fallback to rand number if machine id can't be gathered\n\t\tif _, randErr := rand.Reader.Read(id); randErr != nil {\n\t\t\tpanic(fmt.Errorf(\"xid: cannot get hostname nor generate a random number: %v; %v\", err, randErr))\n\t\t}\n\t}\n\treturn id\n}\n\n// randInt generates a random uint32\nfunc randInt() uint32 {\n\tb := make([]byte, 3)\n\tif _, err := rand.Reader.Read(b); err != nil {\n\t\tpanic(fmt.Errorf(\"xid: cannot generate random number: %v;\", err))\n\t}\n\treturn uint32(b[0])<<16 | uint32(b[1])<<8 | uint32(b[2])\n}\n\n// New generates a globally unique ID\nfunc New() ID {\n\treturn NewWithTime(time.Now())\n}\n\n// NewWithTime generates a globally unique ID with the passed in time\nfunc NewWithTime(t time.Time) ID {\n\tvar id ID\n\t// Timestamp, 4 bytes, big endian\n\tbinary.BigEndian.PutUint32(id[:], uint32(t.Unix()))\n\t// Machine ID, 3 bytes\n\tid[4] = machineID[0]\n\tid[5] = machineID[1]\n\tid[6] = machineID[2]\n\t// Pid, 2 bytes, specs don't specify endianness, but we use big endian.\n\tid[7] = byte(pid >> 8)\n\tid[8] = byte(pid)\n\t// Increment, 3 bytes, big endian\n\ti := atomic.AddUint32(&objectIDCounter, 1)\n\tid[9] = byte(i >> 16)\n\tid[10] = byte(i >> 8)\n\tid[11] = byte(i)\n\treturn id\n}\n\n// FromString reads an ID from its string representation\nfunc FromString(id string) (ID, error) {\n\ti := &ID{}\n\terr := i.UnmarshalText([]byte(id))\n\treturn *i, err\n}\n\n// String returns a base32 hex lowercased with no padding representation of the id (char set is 0-9, a-v).\nfunc (id ID) String() string {\n\ttext := make([]byte, encodedLen)\n\tencode(text, id[:])\n\treturn string(text)\n}\n\n// Encode encodes the id using base32 encoding, writing 20 bytes to dst and return it.\nfunc (id ID) Encode(dst []byte) []byte {\n\tencode(dst, id[:])\n\treturn dst\n}\n\n// MarshalText implements encoding/text TextMarshaler interface\nfunc (id ID) MarshalText() ([]byte, error) {\n\ttext := make([]byte, encodedLen)\n\tencode(text, id[:])\n\treturn text, nil\n}\n\n// MarshalJSON implements encoding/json Marshaler interface\nfunc (id ID) MarshalJSON() ([]byte, error) {\n\tif id.IsNil() {\n\t\treturn []byte(\"null\"), nil\n\t}\n\ttext := make([]byte, encodedLen+2)\n\tencode(text[1:encodedLen+1], id[:])\n\ttext[0], text[encodedLen+1] = '\"', '\"'\n\treturn text, nil\n}\n\n// encode by unrolling the stdlib base32 algorithm + removing all safe checks\nfunc encode(dst, id []byte) {\n\t_ = dst[19]\n\t_ = id[11]\n\n\tdst[19] = encoding[(id[11]<<4)&0x1F]\n\tdst[18] = encoding[(id[11]>>1)&0x1F]\n\tdst[17] = encoding[(id[11]>>6)|(id[10]<<2)&0x1F]\n\tdst[16] = encoding[id[10]>>3]\n\tdst[15] = encoding[id[9]&0x1F]\n\tdst[14] = encoding[(id[9]>>5)|(id[8]<<3)&0x1F]\n\tdst[13] = encoding[(id[8]>>2)&0x1F]\n\tdst[12] = encoding[id[8]>>7|(id[7]<<1)&0x1F]\n\tdst[11] = encoding[(id[7]>>4)|(id[6]<<4)&0x1F]\n\tdst[10] = encoding[(id[6]>>1)&0x1F]\n\tdst[9] = encoding[(id[6]>>6)|(id[5]<<2)&0x1F]\n\tdst[8] = encoding[id[5]>>3]\n\tdst[7] = encoding[id[4]&0x1F]\n\tdst[6] = encoding[id[4]>>5|(id[3]<<3)&0x1F]\n\tdst[5] = encoding[(id[3]>>2)&0x1F]\n\tdst[4] = encoding[id[3]>>7|(id[2]<<1)&0x1F]\n\tdst[3] = encoding[(id[2]>>4)|(id[1]<<4)&0x1F]\n\tdst[2] = encoding[(id[1]>>1)&0x1F]\n\tdst[1] = encoding[(id[1]>>6)|(id[0]<<2)&0x1F]\n\tdst[0] = encoding[id[0]>>3]\n}\n\n// UnmarshalText implements encoding/text TextUnmarshaler interface\nfunc (id *ID) UnmarshalText(text []byte) error {\n\tif len(text) != encodedLen {\n\t\treturn ErrInvalidID\n\t}\n\tfor _, c := range text {\n\t\tif dec[c] == 0xFF {\n\t\t\treturn ErrInvalidID\n\t\t}\n\t}\n\tif !decode(id, text) {\n\t\t*id = nilID\n\t\treturn ErrInvalidID\n\t}\n\treturn nil\n}\n\n// UnmarshalJSON implements encoding/json Unmarshaler interface\nfunc (id *ID) UnmarshalJSON(b []byte) error {\n\ts := string(b)\n\tif s == \"null\" {\n\t\t*id = nilID\n\t\treturn nil\n\t}\n\t// Check the slice length to prevent panic on passing it to UnmarshalText()\n\tif len(b) < 2 {\n\t\treturn ErrInvalidID\n\t}\n\treturn id.UnmarshalText(b[1 : len(b)-1])\n}\n\n// decode by unrolling the stdlib base32 algorithm + customized safe check.\nfunc decode(id *ID, src []byte) bool {\n\t_ = src[19]\n\t_ = id[11]\n\n\tid[11] = dec[src[17]]<<6 | dec[src[18]]<<1 | dec[src[19]]>>4\n\t// check the last byte\n\tif encoding[(id[11]<<4)&0x1F] != src[19] {\n\t\treturn false\n\t}\n\tid[10] = dec[src[16]]<<3 | dec[src[17]]>>2\n\tid[9] = dec[src[14]]<<5 | dec[src[15]]\n\tid[8] = dec[src[12]]<<7 | dec[src[13]]<<2 | dec[src[14]]>>3\n\tid[7] = dec[src[11]]<<4 | dec[src[12]]>>1\n\tid[6] = dec[src[9]]<<6 | dec[src[10]]<<1 | dec[src[11]]>>4\n\tid[5] = dec[src[8]]<<3 | dec[src[9]]>>2\n\tid[4] = dec[src[6]]<<5 | dec[src[7]]\n\tid[3] = dec[src[4]]<<7 | dec[src[5]]<<2 | dec[src[6]]>>3\n\tid[2] = dec[src[3]]<<4 | dec[src[4]]>>1\n\tid[1] = dec[src[1]]<<6 | dec[src[2]]<<1 | dec[src[3]]>>4\n\tid[0] = dec[src[0]]<<3 | dec[src[1]]>>2\n\treturn true\n}\n\n// Time returns the timestamp part of the id.\n// It's a runtime error to call this method with an invalid id.\nfunc (id ID) Time() time.Time {\n\t// First 4 bytes of ObjectId is 32-bit big-endian seconds from epoch.\n\tsecs := int64(binary.BigEndian.Uint32(id[0:4]))\n\treturn time.Unix(secs, 0)\n}\n\n// Machine returns the 3-byte machine id part of the id.\n// It's a runtime error to call this method with an invalid id.\nfunc (id ID) Machine() []byte {\n\treturn id[4:7]\n}\n\n// Pid returns the process id part of the id.\n// It's a runtime error to call this method with an invalid id.\nfunc (id ID) Pid() uint16 {\n\treturn binary.BigEndian.Uint16(id[7:9])\n}\n\n// Counter returns the incrementing value part of the id.\n// It's a runtime error to call this method with an invalid id.\nfunc (id ID) Counter() int32 {\n\tb := id[9:12]\n\t// Counter is stored as big-endian 3-byte value\n\treturn int32(uint32(b[0])<<16 | uint32(b[1])<<8 | uint32(b[2]))\n}\n\n// Value implements the driver.Valuer interface.\nfunc (id ID) Value() (driver.Value, error) {\n\tif id.IsNil() {\n\t\treturn nil, nil\n\t}\n\tb, err := id.MarshalText()\n\treturn string(b), err\n}\n\n// Scan implements the sql.Scanner interface.\nfunc (id *ID) Scan(value interface{}) (err error) {\n\tswitch val := value.(type) {\n\tcase string:\n\t\treturn id.UnmarshalText([]byte(val))\n\tcase []byte:\n\t\treturn id.UnmarshalText(val)\n\tcase nil:\n\t\t*id = nilID\n\t\treturn nil\n\tdefault:\n\t\treturn fmt.Errorf(\"xid: scanning unsupported type: %T\", value)\n\t}\n}\n\n// IsNil Returns true if this is a \"nil\" ID\nfunc (id ID) IsNil() bool {\n\treturn id == nilID\n}\n\n// Alias of IsNil\nfunc (id ID) IsZero() bool {\n\treturn id.IsNil()\n}\n\n// NilID returns a zero value for `xid.ID`.\nfunc NilID() ID {\n\treturn nilID\n}\n\n// Bytes returns the byte array representation of `ID`\nfunc (id ID) Bytes() []byte {\n\treturn id[:]\n}\n\n// FromBytes convert the byte array representation of `ID` back to `ID`\nfunc FromBytes(b []byte) (ID, error) {\n\tvar id ID\n\tif len(b) != rawLen {\n\t\treturn id, ErrInvalidID\n\t}\n\tcopy(id[:], b)\n\treturn id, nil\n}\n\n// Compare returns an integer comparing two IDs. It behaves just like `bytes.Compare`.\n// The result will be 0 if two IDs are identical, -1 if current id is less than the other one,\n// and 1 if current id is greater than the other.\nfunc (id ID) Compare(other ID) int {\n\treturn bytes.Compare(id[:], other[:])\n}\n\ntype sorter []ID\n\nfunc (s sorter) Len() int {\n\treturn len(s)\n}\n\nfunc (s sorter) Less(i, j int) bool {\n\treturn s[i].Compare(s[j]) < 0\n}\n\nfunc (s sorter) Swap(i, j int) {\n\ts[i], s[j] = s[j], s[i]\n}\n\n// Sort sorts an array of IDs inplace.\n// It works by wrapping `[]ID` and use `sort.Sort`.\nfunc Sort(ids []ID) {\n\tsort.Sort(sorter(ids))\n}\n"
        },
        {
          "name": "id_test.go",
          "type": "blob",
          "size": 11.271484375,
          "content": "package xid\n\nimport (\n\t\"bytes\"\n\t\"encoding/json\"\n\t\"errors\"\n\t\"fmt\"\n\t\"math/rand\"\n\t\"reflect\"\n\t\"testing\"\n\t\"testing/quick\"\n\t\"time\"\n)\n\ntype IDParts struct {\n\tid        ID\n\ttimestamp int64\n\tmachine   []byte\n\tpid       uint16\n\tcounter   int32\n}\n\nvar IDs = []IDParts{\n\t{\n\t\tID{0x4d, 0x88, 0xe1, 0x5b, 0x60, 0xf4, 0x86, 0xe4, 0x28, 0x41, 0x2d, 0xc9},\n\t\t1300816219,\n\t\t[]byte{0x60, 0xf4, 0x86},\n\t\t0xe428,\n\t\t4271561,\n\t},\n\t{\n\t\tID{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},\n\t\t0,\n\t\t[]byte{0x00, 0x00, 0x00},\n\t\t0x0000,\n\t\t0,\n\t},\n\t{\n\t\tID{0x00, 0x00, 0x00, 0x00, 0xaa, 0xbb, 0xcc, 0xdd, 0xee, 0x00, 0x00, 0x01},\n\t\t0,\n\t\t[]byte{0xaa, 0xbb, 0xcc},\n\t\t0xddee,\n\t\t1,\n\t},\n}\n\nfunc TestIDPartsExtraction(t *testing.T) {\n\tfor i, v := range IDs {\n\t\tt.Run(fmt.Sprintf(\"Test%d\", i), func(t *testing.T) {\n\t\t\tif got, want := v.id.Time(), time.Unix(v.timestamp, 0); got != want {\n\t\t\t\tt.Errorf(\"Time() = %v, want %v\", got, want)\n\t\t\t}\n\t\t\tif got, want := v.id.Machine(), v.machine; !bytes.Equal(got, want) {\n\t\t\t\tt.Errorf(\"Machine() = %v, want %v\", got, want)\n\t\t\t}\n\t\t\tif got, want := v.id.Pid(), v.pid; got != want {\n\t\t\t\tt.Errorf(\"Pid() = %v, want %v\", got, want)\n\t\t\t}\n\t\t\tif got, want := v.id.Counter(), v.counter; got != want {\n\t\t\t\tt.Errorf(\"Counter() = %v, want %v\", got, want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestPadding(t *testing.T) {\n\tfor i := 0; i < 100000; i++ {\n\t\twantBytes := make([]byte, 20)\n\t\twantBytes[19] = encoding[0]                       // 0\n\t\tcopy(wantBytes[0:13], []byte(\"c6e52g2mrqcjl\")[:]) // c6e52g2mrqcjl44hf170\n\t\tfor j := 0; j < 6; j++ {\n\t\t\twantBytes[13+j] = encoding[rand.Intn(32)]\n\t\t}\n\t\twant := string(wantBytes)\n\t\tid, _ := FromString(want)\n\t\tgot := id.String()\n\t\tif got != want {\n\t\t\tt.Errorf(\"String() = %v, want %v %v\", got, want, wantBytes)\n\t\t}\n\t}\n}\n\nfunc TestNew(t *testing.T) {\n\t// Generate 10 ids\n\tids := make([]ID, 10)\n\tfor i := 0; i < 10; i++ {\n\t\tids[i] = New()\n\t}\n\tfor i := 1; i < 10; i++ {\n\t\tprevID := ids[i-1]\n\t\tid := ids[i]\n\t\t// Test for uniqueness among all other 9 generated ids\n\t\tfor j, tid := range ids {\n\t\t\tif j != i {\n\t\t\t\tif id.Compare(tid) == 0 {\n\t\t\t\t\tt.Errorf(\"generated ID is not unique (%d/%d)\", i, j)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// Check that timestamp was incremented and is within 30 seconds of the previous one\n\t\tsecs := id.Time().Sub(prevID.Time()).Seconds()\n\t\tif secs < 0 || secs > 30 {\n\t\t\tt.Error(\"wrong timestamp in generated ID\")\n\t\t}\n\t\t// Check that machine ids are the same\n\t\tif !bytes.Equal(id.Machine(), prevID.Machine()) {\n\t\t\tt.Error(\"machine ID not equal\")\n\t\t}\n\t\t// Check that pids are the same\n\t\tif id.Pid() != prevID.Pid() {\n\t\t\tt.Error(\"pid not equal\")\n\t\t}\n\t\t// Test for proper increment\n\t\tif got, want := int(id.Counter()-prevID.Counter()), 1; got != want {\n\t\t\tt.Errorf(\"wrong increment in generated ID, delta=%v, want %v\", got, want)\n\t\t}\n\t}\n}\n\nfunc TestIDString(t *testing.T) {\n\tid := ID{0x4d, 0x88, 0xe1, 0x5b, 0x60, 0xf4, 0x86, 0xe4, 0x28, 0x41, 0x2d, 0xc9}\n\tif got, want := id.String(), \"9m4e2mr0ui3e8a215n4g\"; got != want {\n\t\tt.Errorf(\"String() = %v, want %v\", got, want)\n\t}\n}\n\nfunc TestIDEncode(t *testing.T) {\n\tid := ID{0x4d, 0x88, 0xe1, 0x5b, 0x60, 0xf4, 0x86, 0xe4, 0x28, 0x41, 0x2d, 0xc9}\n\ttext := make([]byte, encodedLen)\n\tif got, want := string(id.Encode(text)), \"9m4e2mr0ui3e8a215n4g\"; got != want {\n\t\tt.Errorf(\"Encode() = %v, want %v\", got, want)\n\t}\n}\n\nfunc TestFromString(t *testing.T) {\n\tgot, err := FromString(\"9m4e2mr0ui3e8a215n4g\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\twant := ID{0x4d, 0x88, 0xe1, 0x5b, 0x60, 0xf4, 0x86, 0xe4, 0x28, 0x41, 0x2d, 0xc9}\n\tif got != want {\n\t\tt.Errorf(\"FromString() = %v, want %v\", got, want)\n\t}\n}\n\nfunc TestFromStringInvalid(t *testing.T) {\n\t_, err := FromString(\"invalid\")\n\tif err != ErrInvalidID {\n\t\tt.Errorf(\"FromString(invalid) err=%v, want %v\", err, ErrInvalidID)\n\t}\n\tid, err := FromString(\"c6e52g2mrqcjl44hf179\")\n\tif id != nilID {\n\t\tt.Errorf(\"FromString() =%v, want %v\", id, nilID)\n\t}\n}\n\ntype jsonType struct {\n\tID  *ID\n\tStr string\n}\n\nfunc TestIDJSONMarshaling(t *testing.T) {\n\tid := ID{0x4d, 0x88, 0xe1, 0x5b, 0x60, 0xf4, 0x86, 0xe4, 0x28, 0x41, 0x2d, 0xc9}\n\tv := jsonType{ID: &id, Str: \"test\"}\n\tdata, err := json.Marshal(&v)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif got, want := string(data), `{\"ID\":\"9m4e2mr0ui3e8a215n4g\",\"Str\":\"test\"}`; got != want {\n\t\tt.Errorf(\"json.Marshal() = %v, want %v\", got, want)\n\t}\n}\n\nfunc TestIDJSONUnmarshaling(t *testing.T) {\n\tdata := []byte(`{\"ID\":\"9m4e2mr0ui3e8a215n4g\",\"Str\":\"test\"}`)\n\tv := jsonType{}\n\terr := json.Unmarshal(data, &v)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\twant := ID{0x4d, 0x88, 0xe1, 0x5b, 0x60, 0xf4, 0x86, 0xe4, 0x28, 0x41, 0x2d, 0xc9}\n\tif got := *v.ID; got.Compare(want) != 0 {\n\t\tt.Errorf(\"json.Unmarshal() = %v, want %v\", got, want)\n\t}\n\n}\n\nfunc TestIDJSONUnmarshalingError(t *testing.T) {\n\tv := jsonType{}\n\terr := json.Unmarshal([]byte(`{\"ID\":\"9M4E2MR0UI3E8A215N4G\"}`), &v)\n\tif err != ErrInvalidID {\n\t\tt.Errorf(\"json.Unmarshal() err=%v, want %v\", err, ErrInvalidID)\n\t}\n\terr = json.Unmarshal([]byte(`{\"ID\":\"TYjhW2D0huQoQS\"}`), &v)\n\tif err != ErrInvalidID {\n\t\tt.Errorf(\"json.Unmarshal() err=%v, want %v\", err, ErrInvalidID)\n\t}\n\terr = json.Unmarshal([]byte(`{\"ID\":\"TYjhW2D0huQoQS3kdk\"}`), &v)\n\tif err != ErrInvalidID {\n\t\tt.Errorf(\"json.Unmarshal() err=%v, want %v\", err, ErrInvalidID)\n\t}\n\terr = json.Unmarshal([]byte(`{\"ID\":1}`), &v)\n\tif err != ErrInvalidID {\n\t\tt.Errorf(\"json.Unmarshal() err=%v, want %v\", err, ErrInvalidID)\n\t}\n}\n\nfunc TestIDDriverValue(t *testing.T) {\n\tid := ID{0x4d, 0x88, 0xe1, 0x5b, 0x60, 0xf4, 0x86, 0xe4, 0x28, 0x41, 0x2d, 0xc9}\n\tgot, err := id.Value()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif want := \"9m4e2mr0ui3e8a215n4g\"; got != want {\n\t\tt.Errorf(\"Value() = %v, want %v\", got, want)\n\t}\n}\n\nfunc TestIDDriverScan(t *testing.T) {\n\tgot := ID{}\n\terr := got.Scan(\"9m4e2mr0ui3e8a215n4g\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\twant := ID{0x4d, 0x88, 0xe1, 0x5b, 0x60, 0xf4, 0x86, 0xe4, 0x28, 0x41, 0x2d, 0xc9}\n\tif got.Compare(want) != 0 {\n\t\tt.Errorf(\"Scan() = %v, want %v\", got, want)\n\t}\n}\n\nfunc TestIDDriverScanError(t *testing.T) {\n\tid := ID{}\n\tif got, want := id.Scan(0), errors.New(\"xid: scanning unsupported type: int\"); !reflect.DeepEqual(got, want) {\n\t\tt.Errorf(\"Scan() err=%v, want %v\", got, want)\n\t}\n\tif got, want := id.Scan(\"0\"), ErrInvalidID; got != want {\n\t\tt.Errorf(\"Scan() err=%v, want %v\", got, want)\n\t}\n}\n\nfunc TestIDDriverScanByteFromDatabase(t *testing.T) {\n\tgot := ID{}\n\tbs := []byte(\"9m4e2mr0ui3e8a215n4g\")\n\terr := got.Scan(bs)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\twant := ID{0x4d, 0x88, 0xe1, 0x5b, 0x60, 0xf4, 0x86, 0xe4, 0x28, 0x41, 0x2d, 0xc9}\n\tif got.Compare(want) != 0 {\n\t\tt.Errorf(\"Scan() = %v, want %v\", got, want)\n\t}\n}\n\nfunc BenchmarkNew(b *testing.B) {\n\tb.RunParallel(func(pb *testing.PB) {\n\t\tfor pb.Next() {\n\t\t\t_ = New()\n\t\t}\n\t})\n}\n\nfunc BenchmarkNewString(b *testing.B) {\n\tb.RunParallel(func(pb *testing.PB) {\n\t\tfor pb.Next() {\n\t\t\t_ = New().String()\n\t\t}\n\t})\n}\n\nfunc BenchmarkFromString(b *testing.B) {\n\tb.RunParallel(func(pb *testing.PB) {\n\t\tfor pb.Next() {\n\t\t\t_, _ = FromString(\"9m4e2mr0ui3e8a215n4g\")\n\t\t}\n\t})\n}\n\nfunc TestFromStringQuick(t *testing.T) {\n\tf := func(id1 ID, c byte) bool {\n\t\ts1 := id1.String()\n\t\tfor i := range s1 {\n\t\t\ts2 := []byte(s1)\n\t\t\ts2[i] = c\n\t\t\tid2, err := FromString(string(s2))\n\t\t\tif id1 == id2 && err == nil && c != s1[i] {\n\t\t\t\tt.Logf(\"comparing XIDs:\\na: %q\\nb: %q (index %d changed to %c)\", s1, s2, i, c)\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\t}\n\terr := quick.Check(f, &quick.Config{\n\t\tValues: func(args []reflect.Value, r *rand.Rand) {\n\t\t\ti := r.Intn(len(encoding))\n\t\t\targs[0] = reflect.ValueOf(New())\n\t\t\targs[1] = reflect.ValueOf(byte(encoding[i]))\n\t\t},\n\t\tMaxCount: 1000,\n\t})\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n}\n\nfunc TestFromStringQuickInvalidChars(t *testing.T) {\n\tf := func(id1 ID, c byte) bool {\n\t\ts1 := id1.String()\n\t\tfor i := range s1 {\n\t\t\ts2 := []byte(s1)\n\t\t\ts2[i] = c\n\t\t\tid2, err := FromString(string(s2))\n\t\t\tif id1 == id2 && err == nil && c != s1[i] {\n\t\t\t\tt.Logf(\"comparing XIDs:\\na: %q\\nb: %q (index %d changed to %c)\", s1, s2, i, c)\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\t}\n\terr := quick.Check(f, &quick.Config{\n\t\tValues: func(args []reflect.Value, r *rand.Rand) {\n\t\t\ti := r.Intn(0xFF)\n\t\t\targs[0] = reflect.ValueOf(New())\n\t\t\targs[1] = reflect.ValueOf(byte(i))\n\t\t},\n\t\tMaxCount: 2000,\n\t})\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n}\n\n// func BenchmarkUUIDv1(b *testing.B) {\n// \tb.RunParallel(func(pb *testing.PB) {\n// \t\tfor pb.Next() {\n// \t\t\t_ = uuid.NewV1().String()\n// \t\t}\n// \t})\n// }\n\n// func BenchmarkUUIDv4(b *testing.B) {\n// \tb.RunParallel(func(pb *testing.PB) {\n// \t\tfor pb.Next() {\n// \t\t\t_ = uuid.NewV4().String()\n// \t\t}\n// \t})\n// }\n\nfunc TestID_IsNil(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\tid   ID\n\t\twant bool\n\t}{\n\t\t{\n\t\t\tname: \"ID not nil\",\n\t\t\tid:   New(),\n\t\t\twant: false,\n\t\t},\n\t\t{\n\t\t\tname: \"Nil ID\",\n\t\t\tid:   ID{},\n\t\t\twant: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\ttt := tt\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got, want := tt.id.IsNil(), tt.want; got != want {\n\t\t\t\tt.Errorf(\"IsNil() = %v, want %v\", got, want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestNilID(t *testing.T) {\n\tgot := ID{}\n\tif want := NilID(); !reflect.DeepEqual(got, want) {\n\t\tt.Error(\"NilID() not equal ID{}\")\n\t}\n}\n\nfunc TestNilID_IsNil(t *testing.T) {\n\tif !NilID().IsNil() {\n\t\tt.Error(\"NilID().IsNil() is not true\")\n\t}\n}\n\nfunc TestFromBytes_Invariant(t *testing.T) {\n\twant := New()\n\tgot, err := FromBytes(want.Bytes())\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif got.Compare(want) != 0 {\n\t\tt.Error(\"FromBytes(id.Bytes()) != id\")\n\t}\n}\n\nfunc TestFromBytes_InvalidBytes(t *testing.T) {\n\tcases := []struct {\n\t\tlength     int\n\t\tshouldFail bool\n\t}{\n\t\t{11, true},\n\t\t{12, false},\n\t\t{13, true},\n\t}\n\tfor _, c := range cases {\n\t\tb := make([]byte, c.length)\n\t\t_, err := FromBytes(b)\n\t\tif got, want := err != nil, c.shouldFail; got != want {\n\t\t\tt.Errorf(\"FromBytes() error got %v, want %v\", got, want)\n\t\t}\n\t}\n}\n\nfunc TestID_Compare(t *testing.T) {\n\tpairs := []struct {\n\t\tleft     ID\n\t\tright    ID\n\t\texpected int\n\t}{\n\t\t{IDs[1].id, IDs[0].id, -1},\n\t\t{ID{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, IDs[2].id, -1},\n\t\t{IDs[0].id, IDs[0].id, 0},\n\t}\n\tfor _, p := range pairs {\n\t\tif p.expected != p.left.Compare(p.right) {\n\t\t\tt.Errorf(\"%s Compare to %s should return %d\", p.left, p.right, p.expected)\n\t\t}\n\t\tif -1*p.expected != p.right.Compare(p.left) {\n\t\t\tt.Errorf(\"%s Compare to %s should return %d\", p.right, p.left, -1*p.expected)\n\t\t}\n\t}\n}\n\nvar IDList = []ID{IDs[0].id, IDs[1].id, IDs[2].id}\n\nfunc TestSorter_Len(t *testing.T) {\n\tif got, want := sorter([]ID{}).Len(), 0; got != want {\n\t\tt.Errorf(\"Len() %v, want %v\", got, want)\n\t}\n\tif got, want := sorter(IDList).Len(), 3; got != want {\n\t\tt.Errorf(\"Len() %v, want %v\", got, want)\n\t}\n}\n\nfunc TestSorter_Less(t *testing.T) {\n\tsorter := sorter(IDList)\n\tif !sorter.Less(1, 0) {\n\t\tt.Errorf(\"Less(1, 0) not true\")\n\t}\n\tif sorter.Less(2, 1) {\n\t\tt.Errorf(\"Less(2, 1) true\")\n\t}\n\tif sorter.Less(0, 0) {\n\t\tt.Errorf(\"Less(0, 0) true\")\n\t}\n}\n\nfunc TestSorter_Swap(t *testing.T) {\n\tids := make([]ID, 0)\n\tids = append(ids, IDList...)\n\tsorter := sorter(ids)\n\tsorter.Swap(0, 1)\n\tif got, want := ids[0], IDList[1]; !reflect.DeepEqual(got, want) {\n\t\tt.Error(\"ids[0] != IDList[1]\")\n\t}\n\tif got, want := ids[1], IDList[0]; !reflect.DeepEqual(got, want) {\n\t\tt.Error(\"ids[1] != IDList[0]\")\n\t}\n\tsorter.Swap(2, 2)\n\tif got, want := ids[2], IDList[2]; !reflect.DeepEqual(got, want) {\n\t\tt.Error(\"ids[2], IDList[2]\")\n\t}\n}\n\nfunc TestSort(t *testing.T) {\n\tids := make([]ID, 0)\n\tids = append(ids, IDList...)\n\tSort(ids)\n\tif got, want := ids, []ID{IDList[1], IDList[2], IDList[0]}; !reflect.DeepEqual(got, want) {\n\t\tt.Fail()\n\t}\n}\n"
        }
      ]
    }
  ]
}