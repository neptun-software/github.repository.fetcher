{
  "metadata": {
    "timestamp": 1736566622960,
    "page": 180,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjE4MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "xtaci/kcp-go",
      "stars": 4149,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.2685546875,
          "content": "# Compiled Object files, Static and Dynamic libs (Shared Objects)\n*.o\n*.a\n*.so\n\n# Folders\n_obj\n_test\n/vendor/\n\n# Architecture specific extensions/prefixes\n*.[568vq]\n[568vq].out\n\n*.cgo1.go\n*.cgo2.c\n_cgo_defun.c\n_cgo_gotypes.go\n_cgo_export.*\n\n_testmain.go\n\n*.exe\n*.test\n*.prof\n"
        },
        {
          "name": ".travis.yml",
          "type": "blob",
          "size": 0.349609375,
          "content": "arch:\n    - amd64\n    - ppc64le\nlanguage: go\n\ngo:\n    - 1.11.x\n    - 1.12.x\n    - 1.13.x\n\nenv:\n    - GO111MODULE=on \n\nbefore_install:\n    - go get -t -v ./...\n\ninstall:\n    - go get github.com/xtaci/kcp-go\n\nscript:\n    - go test -coverprofile=coverage.txt -covermode=atomic -bench . -timeout 10m\n\nafter_success:\n    - bash <(curl -s https://codecov.io/bash)\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.0478515625,
          "content": "The MIT License (MIT)\n\nCopyright (c) 2015 xtaci\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 18.6767578125,
          "content": "<img src=\"assets/kcp-go.png\" alt=\"kcp-go\" height=\"50px\" />\n\n\n[![GoDoc][1]][2] [![Powered][9]][10] [![MIT licensed][11]][12] [![Build Status][3]][4] [![Go Report Card][5]][6] [![Coverage Statusd][7]][8]\n\n\n[1]: https://godoc.org/github.com/xtaci/kcp-go?status.svg\n[2]: https://pkg.go.dev/github.com/xtaci/kcp-go\n[3]: https://img.shields.io/github/created-at/xtaci/kcp-go\n[4]: https://img.shields.io/github/created-at/xtaci/kcp-go\n[5]: https://goreportcard.com/badge/github.com/xtaci/kcp-go\n[6]: https://goreportcard.com/report/github.com/xtaci/kcp-go\n[7]: https://codecov.io/gh/xtaci/kcp-go/branch/master/graph/badge.svg\n[8]: https://codecov.io/gh/xtaci/kcp-go\n[9]: https://img.shields.io/badge/KCP-Powered-blue.svg\n[10]: https://github.com/skywind3000/kcp\n[11]: https://img.shields.io/badge/license-MIT-blue.svg\n[12]: LICENSE\n[13]: https://sourcegraph.com/github.com/xtaci/kcp-go/-/badge.svg\n[14]: https://sourcegraph.com/github.com/xtaci/kcp-go?badge\n\n## Introduction\n\n**kcp-go** is a **Reliable-UDP** library for [golang](https://golang.org/). \n\nThis library is designed to provide **smooth, resilient, ordered, error-checked and anonymous** delivery of streams over **UDP** packets. It has been battle-tested with the open-source project [kcptun](https://github.com/xtaci/kcptun). Millions of devices, ranging from low-end MIPS routers to high-end servers, have deployed kcp-go-powered programs in various applications, including **online games, live broadcasting, file synchronization, and network acceleration**.\n\n[Lastest Release](https://github.com/xtaci/kcp-go/releases)\n\n## Features\n\n1. Designed for **latency-sensitive** scenarios.\n2. **Cache-friendly** and **memory-optimized** design, offering extremely **high performance** core.\n3. Handles **>5K concurrent connections** on a single commodity server.\n4. Compatible with [net.Conn](https://golang.org/pkg/net/#Conn) and [net.Listener](https://golang.org/pkg/net/#Listener), serving as a drop-in replacement for [net.TCPConn](https://golang.org/pkg/net/#TCPConn).\n5. [FEC (Forward Error Correction)](https://en.wikipedia.org/wiki/Forward_error_correction) support with [Reed-Solomon Codes](https://en.wikipedia.org/wiki/Reed%E2%80%93Solomon_error_correction).\n6. Packet-level encryption support with [AES](https://en.wikipedia.org/wiki/Advanced_Encryption_Standard), [TEA](https://en.wikipedia.org/wiki/Tiny_Encryption_Algorithm), [3DES](https://en.wikipedia.org/wiki/Triple_DES), [Blowfish](https://en.wikipedia.org/wiki/Blowfish_(cipher)), [Cast5](https://en.wikipedia.org/wiki/CAST-128), [Salsa20](https://en.wikipedia.org/wiki/Salsa20), etc., in [CFB](https://en.wikipedia.org/wiki/Block_cipher_mode_of_operation#Cipher_Feedback_(CFB)) mode, generating completely anonymous packets.\n7. Only **a fixed number of goroutines** are created for the entire server application, with costs in **context switching** between goroutines taken into consideration.\n8. Compatible with [skywind3000's](https://github.com/skywind3000) C version with various improvements.\n9. Platform-dependent optimizations: [sendmmsg](http://man7.org/linux/man-pages/man2/sendmmsg.2.html) and [recvmmsg](http://man7.org/linux/man-pages/man2/recvmmsg.2.html) exploited for Linux.\n\n## Documentation\n\nFor complete documentation, see the associated [Godoc](https://godoc.org/github.com/xtaci/kcp-go).\n\n## Specification\n\n<img src=\"assets/frame.png\" alt=\"Frame Format\" height=\"109px\" />\n\n```\nNONCE:\n  16bytes cryptographically secure random number, nonce changes for every packet.\n  \nCRC32:\n  CRC-32 checksum of data using the IEEE polynomial\n \nFEC TYPE:\n  typeData = 0xF1\n  typeParity = 0xF2\n  \nFEC SEQID:\n  monotonically increasing in range: [0, (0xffffffff/shardSize) * shardSize - 1]\n  \nSIZE:\n  The size of KCP frame plus 2\n\nKCP Header\n+------------------+\n| conv      uint32 |\n+------------------+\n| cmd       uint8  |\n+------------------+\n| frg       uint8  |\n+------------------+\n| wnd      uint16  |\n+------------------+\n| ts       uint32  |\n+------------------+\n| sn       uint32  |\n+------------------+\n| una      uint32  |\n+------------------+\n| rto      uint32  |\n+------------------+\n| xmit     uint32  |\n+------------------+\n| resendts uint32  |\n+------------------+\n| fastack  uint32  |\n+------------------+\n| acked    uint32  |\n+------------------+\n| data     []byte  |\n+------------------+\n```\n\n### Layer-Model of KCP-GO\n```\n+-----------------+\n| SESSION         |\n+-----------------+\n| KCP(ARQ)        |\n+-----------------+\n| FEC(OPTIONAL)   |\n+-----------------+\n| CRYPTO(OPTIONAL)|\n+-----------------+\n| UDP(PACKET)     |\n+-----------------+\n| IP              |\n+-----------------+\n| LINK            |\n+-----------------+\n| PHY             |\n+-----------------+\n```\n\n### Looing for a C++ client?\n1. https://github.com/xtaci/libkcp -- FEC enhanced KCP session library for iOS/Android in C++\n\n## Examples\n\n1. [simple examples](https://github.com/xtaci/kcp-go/tree/master/examples)\n2. [kcptun client](https://github.com/xtaci/kcptun/blob/master/client/main.go)\n3. [kcptun server](https://github.com/xtaci/kcptun/blob/master/server/main.go)\n\n## Benchmark\n```\n===\nModel Name:\tMacBook Pro\nModel Identifier:\tMacBookPro14,1\nProcessor Name:\tIntel Core i5\nProcessor Speed:\t3.1 GHz\nNumber of Processors:\t1\nTotal Number of Cores:\t2\nL2 Cache (per Core):\t256 KB\nL3 Cache:\t4 MB\nMemory:\t8 GB\n===\n\n$ go test -v -run=^$ -bench .\nbeginning tests, encryption:salsa20, fec:10/3\ngoos: darwin\ngoarch: amd64\npkg: github.com/xtaci/kcp-go\nBenchmarkSM4-4                 \t   50000\t     32180 ns/op\t  93.23 MB/s\t       0 B/op\t       0 allocs/op\nBenchmarkAES128-4              \t  500000\t      3285 ns/op\t 913.21 MB/s\t       0 B/op\t       0 allocs/op\nBenchmarkAES192-4              \t  300000\t      3623 ns/op\t 827.85 MB/s\t       0 B/op\t       0 allocs/op\nBenchmarkAES256-4              \t  300000\t      3874 ns/op\t 774.20 MB/s\t       0 B/op\t       0 allocs/op\nBenchmarkTEA-4                 \t  100000\t     15384 ns/op\t 195.00 MB/s\t       0 B/op\t       0 allocs/op\nBenchmarkXOR-4                 \t20000000\t        89.9 ns/op\t33372.00 MB/s\t       0 B/op\t       0 allocs/op\nBenchmarkBlowfish-4            \t   50000\t     26927 ns/op\t 111.41 MB/s\t       0 B/op\t       0 allocs/op\nBenchmarkNone-4                \t30000000\t        45.7 ns/op\t65597.94 MB/s\t       0 B/op\t       0 allocs/op\nBenchmarkCast5-4               \t   50000\t     34258 ns/op\t  87.57 MB/s\t       0 B/op\t       0 allocs/op\nBenchmark3DES-4                \t   10000\t    117149 ns/op\t  25.61 MB/s\t       0 B/op\t       0 allocs/op\nBenchmarkTwofish-4             \t   50000\t     33538 ns/op\t  89.45 MB/s\t       0 B/op\t       0 allocs/op\nBenchmarkXTEA-4                \t   30000\t     45666 ns/op\t  65.69 MB/s\t       0 B/op\t       0 allocs/op\nBenchmarkSalsa20-4             \t  500000\t      3308 ns/op\t 906.76 MB/s\t       0 B/op\t       0 allocs/op\nBenchmarkCRC32-4               \t20000000\t        65.2 ns/op\t15712.43 MB/s\nBenchmarkCsprngSystem-4        \t 1000000\t      1150 ns/op\t  13.91 MB/s\nBenchmarkCsprngMD5-4           \t10000000\t       145 ns/op\t 110.26 MB/s\nBenchmarkCsprngSHA1-4          \t10000000\t       158 ns/op\t 126.54 MB/s\nBenchmarkCsprngNonceMD5-4      \t10000000\t       153 ns/op\t 104.22 MB/s\nBenchmarkCsprngNonceAES128-4   \t100000000\t        19.1 ns/op\t 837.81 MB/s\nBenchmarkFECDecode-4           \t 1000000\t      1119 ns/op\t1339.61 MB/s\t    1606 B/op\t       2 allocs/op\nBenchmarkFECEncode-4           \t 2000000\t       832 ns/op\t1801.83 MB/s\t      17 B/op\t       0 allocs/op\nBenchmarkFlush-4               \t 5000000\t       272 ns/op\t       0 B/op\t       0 allocs/op\nBenchmarkEchoSpeed4K-4         \t    5000\t    259617 ns/op\t  15.78 MB/s\t    5451 B/op\t     149 allocs/op\nBenchmarkEchoSpeed64K-4        \t    1000\t   1706084 ns/op\t  38.41 MB/s\t   56002 B/op\t    1604 allocs/op\nBenchmarkEchoSpeed512K-4       \t     100\t  14345505 ns/op\t  36.55 MB/s\t  482597 B/op\t   13045 allocs/op\nBenchmarkEchoSpeed1M-4         \t      30\t  34859104 ns/op\t  30.08 MB/s\t 1143773 B/op\t   27186 allocs/op\nBenchmarkSinkSpeed4K-4         \t   50000\t     31369 ns/op\t 130.57 MB/s\t    1566 B/op\t      30 allocs/op\nBenchmarkSinkSpeed64K-4        \t    5000\t    329065 ns/op\t 199.16 MB/s\t   21529 B/op\t     453 allocs/op\nBenchmarkSinkSpeed256K-4       \t     500\t   2373354 ns/op\t 220.91 MB/s\t  166332 B/op\t    3554 allocs/op\nBenchmarkSinkSpeed1M-4         \t     300\t   5117927 ns/op\t 204.88 MB/s\t  310378 B/op\t    6988 allocs/op\nPASS\nok  \tgithub.com/xtaci/kcp-go\t50.349s\n```\n\n```\n=== Raspberry Pi 4 ===\n\n➜  kcp-go git:(master) cat /proc/cpuinfo\nprocessor\t: 0\nmodel name\t: ARMv7 Processor rev 3 (v7l)\nBogoMIPS\t: 108.00\nFeatures\t: half thumb fastmult vfp edsp neon vfpv3 tls vfpv4 idiva idivt vfpd32 lpae evtstrm crc32\nCPU implementer\t: 0x41\nCPU architecture: 7\nCPU variant\t: 0x0\nCPU part\t: 0xd08\nCPU revision\t: 3\n\n➜  kcp-go git:(master)  go test -run=^$ -bench .\n2020/01/05 19:25:13 beginning tests, encryption:salsa20, fec:10/3\ngoos: linux\ngoarch: arm\npkg: github.com/xtaci/kcp-go/v5\nBenchmarkSM4-4                     20000             86475 ns/op          34.69 MB/s           0 B/op          0 allocs/op\nBenchmarkAES128-4                  20000             62254 ns/op          48.19 MB/s           0 B/op          0 allocs/op\nBenchmarkAES192-4                  20000             71802 ns/op          41.78 MB/s           0 B/op          0 allocs/op\nBenchmarkAES256-4                  20000             80570 ns/op          37.23 MB/s           0 B/op          0 allocs/op\nBenchmarkTEA-4                     50000             37343 ns/op          80.34 MB/s           0 B/op          0 allocs/op\nBenchmarkXOR-4                    100000             22266 ns/op         134.73 MB/s           0 B/op          0 allocs/op\nBenchmarkBlowfish-4                20000             66123 ns/op          45.37 MB/s           0 B/op          0 allocs/op\nBenchmarkNone-4                  3000000               518 ns/op        5786.77 MB/s           0 B/op          0 allocs/op\nBenchmarkCast5-4                   20000             76705 ns/op          39.11 MB/s           0 B/op          0 allocs/op\nBenchmark3DES-4                     5000            418868 ns/op           7.16 MB/s           0 B/op          0 allocs/op\nBenchmarkTwofish-4                  5000            326896 ns/op           9.18 MB/s           0 B/op          0 allocs/op\nBenchmarkXTEA-4                    10000            114418 ns/op          26.22 MB/s           0 B/op          0 allocs/op\nBenchmarkSalsa20-4                 50000             36736 ns/op          81.66 MB/s           0 B/op          0 allocs/op\nBenchmarkCRC32-4                 1000000              1735 ns/op         589.98 MB/s\nBenchmarkCsprngSystem-4          1000000              2179 ns/op           7.34 MB/s\nBenchmarkCsprngMD5-4             2000000               811 ns/op          19.71 MB/s\nBenchmarkCsprngSHA1-4            2000000               862 ns/op          23.19 MB/s\nBenchmarkCsprngNonceMD5-4        2000000               878 ns/op          18.22 MB/s\nBenchmarkCsprngNonceAES128-4     5000000               326 ns/op          48.97 MB/s\nBenchmarkFECDecode-4              200000              9081 ns/op         165.16 MB/s         140 B/op          1 allocs/op\nBenchmarkFECEncode-4              100000             12039 ns/op         124.59 MB/s          11 B/op          0 allocs/op\nBenchmarkFlush-4                  100000             21704 ns/op               0 B/op          0 allocs/op\nBenchmarkEchoSpeed4K-4              2000            981182 ns/op           4.17 MB/s       12384 B/op        424 allocs/op\nBenchmarkEchoSpeed64K-4              100          10503324 ns/op           6.24 MB/s      123616 B/op       3779 allocs/op\nBenchmarkEchoSpeed512K-4              20         138633802 ns/op           3.78 MB/s     1606584 B/op      29233 allocs/op\nBenchmarkEchoSpeed1M-4                 5         372903568 ns/op           2.81 MB/s     4080504 B/op      63600 allocs/op\nBenchmarkSinkSpeed4K-4             10000            121239 ns/op          33.78 MB/s        4647 B/op        104 allocs/op\nBenchmarkSinkSpeed64K-4             1000           1587906 ns/op          41.27 MB/s       50914 B/op       1115 allocs/op\nBenchmarkSinkSpeed256K-4             100          16277830 ns/op          32.21 MB/s      453027 B/op       9296 allocs/op\nBenchmarkSinkSpeed1M-4               100          31040703 ns/op          33.78 MB/s      898097 B/op      18932 allocs/op\nPASS\nok      github.com/xtaci/kcp-go/v5      64.151s\n```\n\n\n## Typical Flame Graph\n![Flame Graph in kcptun](assets/flame.png)\n\n## Key Design Considerations\n\n### 1. Slice vs. Container/List\n\n`kcp.flush()` loops through the send queue for retransmission checking every 20 ms.\n\nI wrote a benchmark comparing sequential loops through a *slice* and a *container/list* [here](https://github.com/xtaci/notes/blob/master/golang/benchmark2/cachemiss_test.go):\n\n```\nBenchmarkLoopSlice-4   \t2000000000\t         0.39 ns/op\nBenchmarkLoopList-4    \t100000000\t        54.6 ns/op\n```\n\nThe list structure introduces **heavy cache misses** compared to the slice, which has better **locality**. For 5,000 connections with a 32-window size and a 20 ms interval, using a slice costs 6 μs (0.03% CPU) per `kcp.flush()`, while using a list costs 8.7 ms (43.5% CPU).\n\n### 2. Timing Accuracy vs. Syscall clock_gettime\n\nTiming is **critical** to the **RTT estimator**. Inaccurate timing leads to false retransmissions in KCP, but calling `time.Now()` costs 42 cycles (10.5 ns on a 4 GHz CPU, 15.6 ns on my MacBook Pro 2.7 GHz).\n\nThe benchmark for `time.Now()` is [here](https://github.com/xtaci/notes/blob/master/golang/benchmark2/syscall_test.go):\n\n```\nBenchmarkNow-4         \t100000000\t        15.6 ns/op\n```\n\nIn kcp-go, after each `kcp.output()` function call, the current clock time is updated upon return. For a single `kcp.flush()` operation, the current time is queried from the system once. For 5,000 connections, this costs 5000 * 15.6 ns = 78 μs (a fixed cost when no packet needs to be sent). For 10 MB/s data transfer with a 1400 MTU, `kcp.output()` is called around 7500 times, costing 117 μs for `time.Now()` every second.\n\n### 3. Memory Management\n\nPrimary memory allocation is done from a global buffer pool, `xmit.Buf`. In kcp-go, when we need to allocate some bytes, we get them from that pool, which returns a fixed-capacity 1500 bytes (mtuLimit). The rx queue, tx queue, and fec queue all receive bytes from this pool and return them after use to prevent unnecessary zeroing of bytes. The pool mechanism maintains a high watermark for slice objects, allowing these in-flight objects to survive periodic garbage collection, while also being able to return memory to the runtime when idle.\n\n### 4. Information Security\n\nkcp-go is shipped with built-in packet encryption powered by various block encryption algorithms and works in [Cipher Feedback Mode](https://en.wikipedia.org/wiki/Block_cipher_mode_of_operation#Cipher_Feedback_(CFB)). For each packet to be sent, the encryption process starts by encrypting a [nonce](https://en.wikipedia.org/wiki/Cryptographic_nonce) from the [system entropy](https://en.wikipedia.org/wiki//dev/random), ensuring that encryption of the same plaintext never results in the same ciphertext.\n\nThe contents of the packets are completely anonymous with encryption, including the headers (FEC, KCP), checksums, and contents. Note that no matter which encryption method you choose at the upper layer, if you disable encryption, the transmission will be insecure, as the header is ***plaintext*** and susceptible to tampering, such as jamming the *sliding window size*, *round-trip time*, *FEC properties*, and *checksums*. `AES-128` is suggested for minimal encryption, as modern CPUs come with [AES-NI](https://en.wikipedia.org/wiki/AES_instruction_set) instructions and perform better than `salsa20` (check the table above).\n\nOther possible attacks on kcp-go include:\n\n- **[Traffic analysis](https://en.wikipedia.org/wiki/Traffic_analysis):** Data flow on specific websites may have patterns while exchanging data. This type of eavesdropping has been mitigated by adopting [smux](https://github.com/xtaci/smux) to mix data streams and introduce noise. A perfect solution has not yet appeared, but theoretically, shuffling/mixing messages on a larger scale network may mitigate this problem.\n- **[Replay attack](https://en.wikipedia.org/wiki/Replay_attack):** Since asymmetrical encryption has not been introduced into kcp-go, capturing packets and replaying them on a different machine is possible. Note that hijacking the session and decrypting the contents is still *impossible*. Upper layers should use an asymmetrical encryption system to guarantee the authenticity of each message (to process each message exactly once), such as HTTPS/OpenSSL/LibreSSL. Signing requests with private keys can eliminate this type of attack.\n\n## Connection Termination\n\nControl messages like **SYN/FIN/RST** in TCP **are not defined** in KCP. You need a **keepalive/heartbeat mechanism** at the application level. A real-world example is to use a **multiplexing** protocol over the session, such as [smux](https://github.com/xtaci/smux) (which has an embedded keepalive mechanism). See [kcptun](https://github.com/xtaci/kcptun) for an example.\n\n## FAQ\n\n**Q: I'm handling >5K connections on my server, and the CPU utilization is so high.**\n\n**A:** A standalone `agent` or `gate` server for running kcp-go is suggested, not only to reduce CPU utilization but also to improve the **precision** of RTT measurements (timing), which indirectly affects retransmission. Increasing the update `interval` with `SetNoDelay`, such as `conn.SetNoDelay(1, 40, 1, 1)`, will dramatically reduce system load but may lower performance.\n\n**Q: When should I enable FEC?**\n\n**A:** Forward error correction is critical for long-distance transmission because packet loss incurs a huge time penalty. In the complex packet routing networks of the modern world, round-trip time-based loss checks are not always efficient. The significant deviation of RTT samples over long distances usually leads to a larger RTO value in typical RTT estimators, which slows down the transmission.\n\n**Q: Should I enable encryption?**\n\n**A:** Yes, for the security of the protocol, even if the upper layer has encryption.\n\n## Who is using this?\n\n1. https://github.com/xtaci/kcptun -- A Secure Tunnel Based On KCP over UDP.\n2. https://github.com/getlantern/lantern -- Lantern delivers fast access to the open Internet. \n3. https://github.com/smallnest/rpcx -- A RPC service framework based on net/rpc like alibaba Dubbo and weibo Motan.\n4. https://github.com/gonet2/agent -- A gateway for games with stream multiplexing.\n5. https://github.com/syncthing/syncthing -- Open Source Continuous File Synchronization.\n\n## Links\n\n1. https://github.com/xtaci/smux/ -- A Stream Multiplexing Library for golang with least memory\n1. **https://github.com/xtaci/libkcp -- FEC enhanced KCP session library for iOS/Android in C++**\n1. https://github.com/skywind3000/kcp -- A Fast and Reliable ARQ Protocol\n1. https://github.com/klauspost/reedsolomon -- Reed-Solomon Erasure Coding in Go\n"
        },
        {
          "name": "assets",
          "type": "tree",
          "content": null
        },
        {
          "name": "autotune.go",
          "type": "blob",
          "size": 3.0283203125,
          "content": "// The MIT License (MIT)\n//\n// Copyright (c) 2015 xtaci\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.\n\npackage kcp\n\nconst maxAutoTuneSamples = 258\n\n// pulse represents a 0/1 signal with time sequence\ntype pulse struct {\n\tbit bool   // 0 or 1\n\tseq uint32 // sequence of the signal\n}\n\n// autoTune object to detect pulses in a signal\ntype autoTune struct {\n\tpulses [maxAutoTuneSamples]pulse\n}\n\n// Sample adds a signal sample to the pulse buffer\nfunc (tune *autoTune) Sample(bit bool, seq uint32) {\n\t// ensure seq is in range [pulses[0].seq, pulses[0].seq + maxAutoTuneSamples]\n\tif seq >= tune.pulses[0].seq && seq <= tune.pulses[0].seq+maxAutoTuneSamples {\n\t\ttune.pulses[seq%maxAutoTuneSamples] = pulse{bit, seq}\n\t}\n}\n\n// Find a period for a given signal\n// returns -1 if not found\n//\n//\n//   Signal Level\n//       |\n// 1.0   |                 _____           _____\n//       |                |     |         |     |\n// 0.5   |      _____     |     |   _____ |     |   _____\n//       |     |     |    |     |  |     ||     |  |     |\n// 0.0 __|_____|     |____|     |__|     ||     |__|     |_____\n//       |\n//       |-----------------------------------------------------> Time\n//            A     B    C     D  E     F     G  H     I\n\nfunc (tune *autoTune) FindPeriod(bit bool) int {\n\t// last pulse and initial index setup\n\tlastPulse := tune.pulses[0]\n\tidx := 1\n\n\t// left edge\n\tvar leftEdge int\n\tfor ; idx < len(tune.pulses); idx++ {\n\t\tif lastPulse.bit != bit && tune.pulses[idx].bit == bit { // edge found\n\t\t\tif lastPulse.seq+1 == tune.pulses[idx].seq { // ensure edge continuity\n\t\t\t\tleftEdge = idx\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tlastPulse = tune.pulses[idx]\n\t}\n\n\t// right edge\n\tvar rightEdge int\n\tlastPulse = tune.pulses[leftEdge]\n\tidx = leftEdge + 1\n\n\tfor ; idx < len(tune.pulses); idx++ {\n\t\tif lastPulse.seq+1 == tune.pulses[idx].seq { // ensure pulses in this level monotonic\n\t\t\tif lastPulse.bit == bit && tune.pulses[idx].bit != bit { // edge found\n\t\t\t\trightEdge = idx\n\t\t\t\tbreak\n\t\t\t}\n\t\t} else {\n\t\t\treturn -1\n\t\t}\n\t\tlastPulse = tune.pulses[idx]\n\t}\n\n\treturn rightEdge - leftEdge\n}\n"
        },
        {
          "name": "autotune_test.go",
          "type": "blob",
          "size": 2.427734375,
          "content": "// The MIT License (MIT)\n//\n// Copyright (c) 2015 xtaci\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.\n\npackage kcp\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestAutoTune(t *testing.T) {\n\tsignals := []uint32{0, 0, 0, 0, 0, 0}\n\n\ttune := autoTune{}\n\tfor i := 0; i < len(signals); i++ {\n\t\tif signals[i] == 0 {\n\t\t\ttune.Sample(false, uint32(i))\n\t\t} else {\n\t\t\ttune.Sample(true, uint32(i))\n\t\t}\n\t}\n\n\tassert.Equal(t, -1, tune.FindPeriod(false))\n\tassert.Equal(t, -1, tune.FindPeriod(true))\n\n\tsignals = []uint32{1, 0, 1, 0, 0, 1}\n\ttune = autoTune{}\n\tfor i := 0; i < len(signals); i++ {\n\t\tif signals[i] == 0 {\n\t\t\ttune.Sample(false, uint32(i))\n\t\t} else {\n\t\t\ttune.Sample(true, uint32(i))\n\t\t}\n\t}\n\tassert.Equal(t, 1, tune.FindPeriod(false))\n\tassert.Equal(t, 1, tune.FindPeriod(true))\n\n\tsignals = []uint32{1, 0, 0, 0, 0, 1}\n\ttune = autoTune{}\n\tfor i := 0; i < len(signals); i++ {\n\t\tif signals[i] == 0 {\n\t\t\ttune.Sample(false, uint32(i))\n\t\t} else {\n\t\t\ttune.Sample(true, uint32(i))\n\t\t}\n\t}\n\tassert.Equal(t, -1, tune.FindPeriod(true))\n\tassert.Equal(t, 4, tune.FindPeriod(false))\n\n\t// minimal test\n\ttune = autoTune{}\n\tfor i := 0; i < 1024; i++ {\n\t\tif i%maxAutoTuneSamples == 0 {\n\t\t\ttune.Sample(false, uint32(i))\n\t\t} else {\n\t\t\ttune.Sample(true, uint32(i))\n\t\t}\n\t}\n\tassert.NotEqual(t, 0, tune.pulses[0].seq)\n\tminSeq := tune.pulses[0].seq\n\tt.Log(\"minimal seq\", tune.pulses[0].seq)\n\n\ttune.Sample(false, minSeq-1)\n\tassert.Equal(t, minSeq, tune.pulses[0].seq)\n}\n"
        },
        {
          "name": "batchconn.go",
          "type": "blob",
          "size": 1.361328125,
          "content": "// The MIT License (MIT)\n//\n// Copyright (c) 2015 xtaci\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.\n\npackage kcp\n\nimport \"golang.org/x/net/ipv4\"\n\nconst (\n\tbatchSize = 16\n)\n\n// batchConn defines the interface used in batch IO\ntype batchConn interface {\n\tWriteBatch(ms []ipv4.Message, flags int) (int, error)\n\tReadBatch(ms []ipv4.Message, flags int) (int, error)\n}\n"
        },
        {
          "name": "crypt.go",
          "type": "blob",
          "size": 18.2216796875,
          "content": "// The MIT License (MIT)\n//\n// Copyright (c) 2015 xtaci\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.\n\npackage kcp\n\nimport (\n\t\"crypto/aes\"\n\t\"crypto/cipher\"\n\t\"crypto/des\"\n\t\"crypto/sha1\"\n\t\"unsafe\"\n\n\txor \"github.com/templexxx/xorsimd\"\n\t\"github.com/tjfoc/gmsm/sm4\"\n\n\t\"golang.org/x/crypto/blowfish\"\n\t\"golang.org/x/crypto/cast5\"\n\t\"golang.org/x/crypto/pbkdf2\"\n\t\"golang.org/x/crypto/salsa20\"\n\t\"golang.org/x/crypto/tea\"\n\t\"golang.org/x/crypto/twofish\"\n\t\"golang.org/x/crypto/xtea\"\n)\n\nvar (\n\t// a defined initial vector\n\t// https://en.wikipedia.org/wiki/Block_cipher_mode_of_operation#Initialization_vector_.28IV.29\n\t// https://en.wikipedia.org/wiki/Initialization_vector\n\t// actually initial vector is not used in this package, we prepend a random nonce to each outgoing packets.\n\t// though IV is fixed, the first 8 bytes of the encrypted data is always random.\n\tinitialVector = []byte{167, 115, 79, 156, 18, 172, 27, 1, 164, 21, 242, 193, 252, 120, 230, 107}\n\tsaltxor       = `sH3CIVoF#rWLtJo6`\n)\n\n// BlockCrypt defines encryption/decryption methods for a given byte slice.\n// Notes on implementing: the data to be encrypted contains a builtin\n// nonce at the first 16 bytes\ntype BlockCrypt interface {\n\t// Encrypt encrypts the whole block in src into dst.\n\t// Dst and src may point at the same memory.\n\tEncrypt(dst, src []byte)\n\n\t// Decrypt decrypts the whole block in src into dst.\n\t// Dst and src may point at the same memory.\n\tDecrypt(dst, src []byte)\n}\n\ntype salsa20BlockCrypt struct {\n\tkey [32]byte\n}\n\n// NewSalsa20BlockCrypt https://en.wikipedia.org/wiki/Salsa20\nfunc NewSalsa20BlockCrypt(key []byte) (BlockCrypt, error) {\n\tc := new(salsa20BlockCrypt)\n\tcopy(c.key[:], key)\n\treturn c, nil\n}\n\nfunc (c *salsa20BlockCrypt) Encrypt(dst, src []byte) {\n\tsalsa20.XORKeyStream(dst[8:], src[8:], src[:8], &c.key)\n\tcopy(dst[:8], src[:8])\n}\nfunc (c *salsa20BlockCrypt) Decrypt(dst, src []byte) {\n\tsalsa20.XORKeyStream(dst[8:], src[8:], src[:8], &c.key)\n\tcopy(dst[:8], src[:8])\n}\n\ntype sm4BlockCrypt struct {\n\tencbuf [sm4.BlockSize]byte // 64bit alignment enc/dec buffer\n\tdecbuf [2 * sm4.BlockSize]byte\n\tblock  cipher.Block\n}\n\n// NewSM4BlockCrypt https://github.com/tjfoc/gmsm/tree/master/sm4\nfunc NewSM4BlockCrypt(key []byte) (BlockCrypt, error) {\n\tc := new(sm4BlockCrypt)\n\tblock, err := sm4.NewCipher(key)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tc.block = block\n\treturn c, nil\n}\n\nfunc (c *sm4BlockCrypt) Encrypt(dst, src []byte) { encrypt(c.block, dst, src, c.encbuf[:]) }\nfunc (c *sm4BlockCrypt) Decrypt(dst, src []byte) { decrypt(c.block, dst, src, c.decbuf[:]) }\n\ntype twofishBlockCrypt struct {\n\tencbuf [twofish.BlockSize]byte\n\tdecbuf [2 * twofish.BlockSize]byte\n\tblock  cipher.Block\n}\n\n// NewTwofishBlockCrypt https://en.wikipedia.org/wiki/Twofish\nfunc NewTwofishBlockCrypt(key []byte) (BlockCrypt, error) {\n\tc := new(twofishBlockCrypt)\n\tblock, err := twofish.NewCipher(key)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tc.block = block\n\treturn c, nil\n}\n\nfunc (c *twofishBlockCrypt) Encrypt(dst, src []byte) { encrypt(c.block, dst, src, c.encbuf[:]) }\nfunc (c *twofishBlockCrypt) Decrypt(dst, src []byte) { decrypt(c.block, dst, src, c.decbuf[:]) }\n\ntype tripleDESBlockCrypt struct {\n\tencbuf [des.BlockSize]byte\n\tdecbuf [2 * des.BlockSize]byte\n\tblock  cipher.Block\n}\n\n// NewTripleDESBlockCrypt https://en.wikipedia.org/wiki/Triple_DES\nfunc NewTripleDESBlockCrypt(key []byte) (BlockCrypt, error) {\n\tc := new(tripleDESBlockCrypt)\n\tblock, err := des.NewTripleDESCipher(key)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tc.block = block\n\treturn c, nil\n}\n\nfunc (c *tripleDESBlockCrypt) Encrypt(dst, src []byte) { encrypt(c.block, dst, src, c.encbuf[:]) }\nfunc (c *tripleDESBlockCrypt) Decrypt(dst, src []byte) { decrypt(c.block, dst, src, c.decbuf[:]) }\n\ntype cast5BlockCrypt struct {\n\tencbuf [cast5.BlockSize]byte\n\tdecbuf [2 * cast5.BlockSize]byte\n\tblock  cipher.Block\n}\n\n// NewCast5BlockCrypt https://en.wikipedia.org/wiki/CAST-128\nfunc NewCast5BlockCrypt(key []byte) (BlockCrypt, error) {\n\tc := new(cast5BlockCrypt)\n\tblock, err := cast5.NewCipher(key)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tc.block = block\n\treturn c, nil\n}\n\nfunc (c *cast5BlockCrypt) Encrypt(dst, src []byte) { encrypt(c.block, dst, src, c.encbuf[:]) }\nfunc (c *cast5BlockCrypt) Decrypt(dst, src []byte) { decrypt(c.block, dst, src, c.decbuf[:]) }\n\ntype blowfishBlockCrypt struct {\n\tencbuf [blowfish.BlockSize]byte\n\tdecbuf [2 * blowfish.BlockSize]byte\n\tblock  cipher.Block\n}\n\n// NewBlowfishBlockCrypt https://en.wikipedia.org/wiki/Blowfish_(cipher)\nfunc NewBlowfishBlockCrypt(key []byte) (BlockCrypt, error) {\n\tc := new(blowfishBlockCrypt)\n\tblock, err := blowfish.NewCipher(key)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tc.block = block\n\treturn c, nil\n}\n\nfunc (c *blowfishBlockCrypt) Encrypt(dst, src []byte) { encrypt(c.block, dst, src, c.encbuf[:]) }\nfunc (c *blowfishBlockCrypt) Decrypt(dst, src []byte) { decrypt(c.block, dst, src, c.decbuf[:]) }\n\ntype aesBlockCrypt struct {\n\tencbuf [aes.BlockSize]byte\n\tdecbuf [2 * aes.BlockSize]byte\n\tblock  cipher.Block\n}\n\n// NewAESBlockCrypt https://en.wikipedia.org/wiki/Advanced_Encryption_Standard\nfunc NewAESBlockCrypt(key []byte) (BlockCrypt, error) {\n\tc := new(aesBlockCrypt)\n\tblock, err := aes.NewCipher(key)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tc.block = block\n\treturn c, nil\n}\n\nfunc (c *aesBlockCrypt) Encrypt(dst, src []byte) { encrypt(c.block, dst, src, c.encbuf[:]) }\nfunc (c *aesBlockCrypt) Decrypt(dst, src []byte) { decrypt(c.block, dst, src, c.decbuf[:]) }\n\ntype teaBlockCrypt struct {\n\tencbuf [tea.BlockSize]byte\n\tdecbuf [2 * tea.BlockSize]byte\n\tblock  cipher.Block\n}\n\n// NewTEABlockCrypt https://en.wikipedia.org/wiki/Tiny_Encryption_Algorithm\nfunc NewTEABlockCrypt(key []byte) (BlockCrypt, error) {\n\tc := new(teaBlockCrypt)\n\tblock, err := tea.NewCipherWithRounds(key, 16)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tc.block = block\n\treturn c, nil\n}\n\nfunc (c *teaBlockCrypt) Encrypt(dst, src []byte) { encrypt(c.block, dst, src, c.encbuf[:]) }\nfunc (c *teaBlockCrypt) Decrypt(dst, src []byte) { decrypt(c.block, dst, src, c.decbuf[:]) }\n\ntype xteaBlockCrypt struct {\n\tencbuf [xtea.BlockSize]byte\n\tdecbuf [2 * xtea.BlockSize]byte\n\tblock  cipher.Block\n}\n\n// NewXTEABlockCrypt https://en.wikipedia.org/wiki/XTEA\nfunc NewXTEABlockCrypt(key []byte) (BlockCrypt, error) {\n\tc := new(xteaBlockCrypt)\n\tblock, err := xtea.NewCipher(key)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tc.block = block\n\treturn c, nil\n}\n\nfunc (c *xteaBlockCrypt) Encrypt(dst, src []byte) { encrypt(c.block, dst, src, c.encbuf[:]) }\nfunc (c *xteaBlockCrypt) Decrypt(dst, src []byte) { decrypt(c.block, dst, src, c.decbuf[:]) }\n\ntype simpleXORBlockCrypt struct {\n\txortbl []byte\n}\n\n// NewSimpleXORBlockCrypt simple xor with key expanding\nfunc NewSimpleXORBlockCrypt(key []byte) (BlockCrypt, error) {\n\tc := new(simpleXORBlockCrypt)\n\tc.xortbl = pbkdf2.Key(key, []byte(saltxor), 32, mtuLimit, sha1.New)\n\treturn c, nil\n}\n\nfunc (c *simpleXORBlockCrypt) Encrypt(dst, src []byte) { xor.Bytes(dst, src, c.xortbl) }\nfunc (c *simpleXORBlockCrypt) Decrypt(dst, src []byte) { xor.Bytes(dst, src, c.xortbl) }\n\ntype noneBlockCrypt struct{}\n\n// NewNoneBlockCrypt does nothing but copying\nfunc NewNoneBlockCrypt(key []byte) (BlockCrypt, error) {\n\treturn new(noneBlockCrypt), nil\n}\n\nfunc (c *noneBlockCrypt) Encrypt(dst, src []byte) { copy(dst, src) }\nfunc (c *noneBlockCrypt) Decrypt(dst, src []byte) { copy(dst, src) }\n\n// packet encryption with local CFB mode\nfunc encrypt(block cipher.Block, dst, src, buf []byte) {\n\tswitch block.BlockSize() {\n\tcase 8:\n\t\tencrypt8(block, dst, src, buf)\n\tcase 16:\n\t\tencrypt16(block, dst, src, buf)\n\tdefault:\n\t\tpanic(\"unsupported cipher block size\")\n\t}\n}\n\n// optimized encryption for the ciphers which works in 8-bytes\nfunc encrypt8(block cipher.Block, dst, src, buf []byte) {\n\ttbl := buf[:8]\n\tblock.Encrypt(tbl, initialVector)\n\tn := len(src) / 8\n\tbase := 0\n\trepeat := n / 8\n\tleft := n % 8\n\tptr_tbl := (*uint64)(unsafe.Pointer(&tbl[0]))\n\n\tfor i := 0; i < repeat; i++ {\n\t\ts := src[base:][0:64]\n\t\td := dst[base:][0:64]\n\t\t// 1\n\t\t*(*uint64)(unsafe.Pointer(&d[0])) = *(*uint64)(unsafe.Pointer(&s[0])) ^ *ptr_tbl\n\t\tblock.Encrypt(tbl, d[0:8])\n\t\t// 2\n\t\t*(*uint64)(unsafe.Pointer(&d[8])) = *(*uint64)(unsafe.Pointer(&s[8])) ^ *ptr_tbl\n\t\tblock.Encrypt(tbl, d[8:16])\n\t\t// 3\n\t\t*(*uint64)(unsafe.Pointer(&d[16])) = *(*uint64)(unsafe.Pointer(&s[16])) ^ *ptr_tbl\n\t\tblock.Encrypt(tbl, d[16:24])\n\t\t// 4\n\t\t*(*uint64)(unsafe.Pointer(&d[24])) = *(*uint64)(unsafe.Pointer(&s[24])) ^ *ptr_tbl\n\t\tblock.Encrypt(tbl, d[24:32])\n\t\t// 5\n\t\t*(*uint64)(unsafe.Pointer(&d[32])) = *(*uint64)(unsafe.Pointer(&s[32])) ^ *ptr_tbl\n\t\tblock.Encrypt(tbl, d[32:40])\n\t\t// 6\n\t\t*(*uint64)(unsafe.Pointer(&d[40])) = *(*uint64)(unsafe.Pointer(&s[40])) ^ *ptr_tbl\n\t\tblock.Encrypt(tbl, d[40:48])\n\t\t// 7\n\t\t*(*uint64)(unsafe.Pointer(&d[48])) = *(*uint64)(unsafe.Pointer(&s[48])) ^ *ptr_tbl\n\t\tblock.Encrypt(tbl, d[48:56])\n\t\t// 8\n\t\t*(*uint64)(unsafe.Pointer(&d[56])) = *(*uint64)(unsafe.Pointer(&s[56])) ^ *ptr_tbl\n\t\tblock.Encrypt(tbl, d[56:64])\n\t\tbase += 64\n\t}\n\n\tswitch left {\n\tcase 7:\n\t\t*(*uint64)(unsafe.Pointer(&dst[base])) = *(*uint64)(unsafe.Pointer(&src[base])) ^ *ptr_tbl\n\t\tblock.Encrypt(tbl, dst[base:])\n\t\tbase += 8\n\t\tfallthrough\n\tcase 6:\n\t\t*(*uint64)(unsafe.Pointer(&dst[base])) = *(*uint64)(unsafe.Pointer(&src[base])) ^ *ptr_tbl\n\t\tblock.Encrypt(tbl, dst[base:])\n\t\tbase += 8\n\t\tfallthrough\n\tcase 5:\n\t\t*(*uint64)(unsafe.Pointer(&dst[base])) = *(*uint64)(unsafe.Pointer(&src[base])) ^ *ptr_tbl\n\t\tblock.Encrypt(tbl, dst[base:])\n\t\tbase += 8\n\t\tfallthrough\n\tcase 4:\n\t\t*(*uint64)(unsafe.Pointer(&dst[base])) = *(*uint64)(unsafe.Pointer(&src[base])) ^ *ptr_tbl\n\t\tblock.Encrypt(tbl, dst[base:])\n\t\tbase += 8\n\t\tfallthrough\n\tcase 3:\n\t\t*(*uint64)(unsafe.Pointer(&dst[base])) = *(*uint64)(unsafe.Pointer(&src[base])) ^ *ptr_tbl\n\t\tblock.Encrypt(tbl, dst[base:])\n\t\tbase += 8\n\t\tfallthrough\n\tcase 2:\n\t\t*(*uint64)(unsafe.Pointer(&dst[base])) = *(*uint64)(unsafe.Pointer(&src[base])) ^ *ptr_tbl\n\t\tblock.Encrypt(tbl, dst[base:])\n\t\tbase += 8\n\t\tfallthrough\n\tcase 1:\n\t\t*(*uint64)(unsafe.Pointer(&dst[base])) = *(*uint64)(unsafe.Pointer(&src[base])) ^ *ptr_tbl\n\t\tblock.Encrypt(tbl, dst[base:])\n\t\tbase += 8\n\t\tfallthrough\n\tcase 0:\n\t\txorBytes(dst[base:], src[base:], tbl)\n\t}\n}\n\n// optimized encryption for the ciphers which works in 16-bytes\nfunc encrypt16(block cipher.Block, dst, src, buf []byte) {\n\ttbl := buf[:16]\n\tblock.Encrypt(tbl, initialVector)\n\tn := len(src) / 16\n\tbase := 0\n\trepeat := n / 8\n\tleft := n % 8\n\tfor i := 0; i < repeat; i++ {\n\t\ts := src[base:][0:128]\n\t\td := dst[base:][0:128]\n\t\t// 1\n\t\txor.Bytes16Align(d[0:16], s[0:16], tbl)\n\t\tblock.Encrypt(tbl, d[0:16])\n\t\t// 2\n\t\txor.Bytes16Align(d[16:32], s[16:32], tbl)\n\t\tblock.Encrypt(tbl, d[16:32])\n\t\t// 3\n\t\txor.Bytes16Align(d[32:48], s[32:48], tbl)\n\t\tblock.Encrypt(tbl, d[32:48])\n\t\t// 4\n\t\txor.Bytes16Align(d[48:64], s[48:64], tbl)\n\t\tblock.Encrypt(tbl, d[48:64])\n\t\t// 5\n\t\txor.Bytes16Align(d[64:80], s[64:80], tbl)\n\t\tblock.Encrypt(tbl, d[64:80])\n\t\t// 6\n\t\txor.Bytes16Align(d[80:96], s[80:96], tbl)\n\t\tblock.Encrypt(tbl, d[80:96])\n\t\t// 7\n\t\txor.Bytes16Align(d[96:112], s[96:112], tbl)\n\t\tblock.Encrypt(tbl, d[96:112])\n\t\t// 8\n\t\txor.Bytes16Align(d[112:128], s[112:128], tbl)\n\t\tblock.Encrypt(tbl, d[112:128])\n\t\tbase += 128\n\t}\n\n\tswitch left {\n\tcase 7:\n\t\txor.Bytes16Align(dst[base:], src[base:], tbl)\n\t\tblock.Encrypt(tbl, dst[base:])\n\t\tbase += 16\n\t\tfallthrough\n\tcase 6:\n\t\txor.Bytes16Align(dst[base:], src[base:], tbl)\n\t\tblock.Encrypt(tbl, dst[base:])\n\t\tbase += 16\n\t\tfallthrough\n\tcase 5:\n\t\txor.Bytes16Align(dst[base:], src[base:], tbl)\n\t\tblock.Encrypt(tbl, dst[base:])\n\t\tbase += 16\n\t\tfallthrough\n\tcase 4:\n\t\txor.Bytes16Align(dst[base:], src[base:], tbl)\n\t\tblock.Encrypt(tbl, dst[base:])\n\t\tbase += 16\n\t\tfallthrough\n\tcase 3:\n\t\txor.Bytes16Align(dst[base:], src[base:], tbl)\n\t\tblock.Encrypt(tbl, dst[base:])\n\t\tbase += 16\n\t\tfallthrough\n\tcase 2:\n\t\txor.Bytes16Align(dst[base:], src[base:], tbl)\n\t\tblock.Encrypt(tbl, dst[base:])\n\t\tbase += 16\n\t\tfallthrough\n\tcase 1:\n\t\txor.Bytes16Align(dst[base:], src[base:], tbl)\n\t\tblock.Encrypt(tbl, dst[base:])\n\t\tbase += 16\n\t\tfallthrough\n\tcase 0:\n\t\txorBytes(dst[base:], src[base:], tbl)\n\t}\n}\n\n// decryption\nfunc decrypt(block cipher.Block, dst, src, buf []byte) {\n\tswitch block.BlockSize() {\n\tcase 8:\n\t\tdecrypt8(block, dst, src, buf)\n\tcase 16:\n\t\tdecrypt16(block, dst, src, buf)\n\tdefault:\n\t\tpanic(\"unsupported cipher block size\")\n\t}\n}\n\n// decrypt 8 bytes block, all byte slices are supposed to be 64bit aligned\nfunc decrypt8(block cipher.Block, dst, src, buf []byte) {\n\ttbl := buf[0:8]\n\tnext := buf[8:16]\n\tblock.Encrypt(tbl, initialVector)\n\tn := len(src) / 8\n\tbase := 0\n\trepeat := n / 8\n\tleft := n % 8\n\tptr_tbl := (*uint64)(unsafe.Pointer(&tbl[0]))\n\tptr_next := (*uint64)(unsafe.Pointer(&next[0]))\n\n\t// loop unrolling to relieve data dependency\n\tfor i := 0; i < repeat; i++ {\n\t\ts := src[base:][0:64]\n\t\td := dst[base:][0:64]\n\t\t// 1\n\t\tblock.Encrypt(next, s[0:8])\n\t\t*(*uint64)(unsafe.Pointer(&d[0])) = *(*uint64)(unsafe.Pointer(&s[0])) ^ *ptr_tbl\n\t\t// 2\n\t\tblock.Encrypt(tbl, s[8:16])\n\t\t*(*uint64)(unsafe.Pointer(&d[8])) = *(*uint64)(unsafe.Pointer(&s[8])) ^ *ptr_next\n\t\t// 3\n\t\tblock.Encrypt(next, s[16:24])\n\t\t*(*uint64)(unsafe.Pointer(&d[16])) = *(*uint64)(unsafe.Pointer(&s[16])) ^ *ptr_tbl\n\t\t// 4\n\t\tblock.Encrypt(tbl, s[24:32])\n\t\t*(*uint64)(unsafe.Pointer(&d[24])) = *(*uint64)(unsafe.Pointer(&s[24])) ^ *ptr_next\n\t\t// 5\n\t\tblock.Encrypt(next, s[32:40])\n\t\t*(*uint64)(unsafe.Pointer(&d[32])) = *(*uint64)(unsafe.Pointer(&s[32])) ^ *ptr_tbl\n\t\t// 6\n\t\tblock.Encrypt(tbl, s[40:48])\n\t\t*(*uint64)(unsafe.Pointer(&d[40])) = *(*uint64)(unsafe.Pointer(&s[40])) ^ *ptr_next\n\t\t// 7\n\t\tblock.Encrypt(next, s[48:56])\n\t\t*(*uint64)(unsafe.Pointer(&d[48])) = *(*uint64)(unsafe.Pointer(&s[48])) ^ *ptr_tbl\n\t\t// 8\n\t\tblock.Encrypt(tbl, s[56:64])\n\t\t*(*uint64)(unsafe.Pointer(&d[56])) = *(*uint64)(unsafe.Pointer(&s[56])) ^ *ptr_next\n\t\tbase += 64\n\t}\n\n\tswitch left {\n\tcase 7:\n\t\tblock.Encrypt(next, src[base:])\n\t\t*(*uint64)(unsafe.Pointer(&dst[base])) = *(*uint64)(unsafe.Pointer(&src[base])) ^ *(*uint64)(unsafe.Pointer(&tbl[0]))\n\t\ttbl, next = next, tbl\n\t\tbase += 8\n\t\tfallthrough\n\tcase 6:\n\t\tblock.Encrypt(next, src[base:])\n\t\t*(*uint64)(unsafe.Pointer(&dst[base])) = *(*uint64)(unsafe.Pointer(&src[base])) ^ *(*uint64)(unsafe.Pointer(&tbl[0]))\n\t\ttbl, next = next, tbl\n\t\tbase += 8\n\t\tfallthrough\n\tcase 5:\n\t\tblock.Encrypt(next, src[base:])\n\t\t*(*uint64)(unsafe.Pointer(&dst[base])) = *(*uint64)(unsafe.Pointer(&src[base])) ^ *(*uint64)(unsafe.Pointer(&tbl[0]))\n\t\ttbl, next = next, tbl\n\t\tbase += 8\n\t\tfallthrough\n\tcase 4:\n\t\tblock.Encrypt(next, src[base:])\n\t\t*(*uint64)(unsafe.Pointer(&dst[base])) = *(*uint64)(unsafe.Pointer(&src[base])) ^ *(*uint64)(unsafe.Pointer(&tbl[0]))\n\t\ttbl, next = next, tbl\n\t\tbase += 8\n\t\tfallthrough\n\tcase 3:\n\t\tblock.Encrypt(next, src[base:])\n\t\t*(*uint64)(unsafe.Pointer(&dst[base])) = *(*uint64)(unsafe.Pointer(&src[base])) ^ *(*uint64)(unsafe.Pointer(&tbl[0]))\n\t\ttbl, next = next, tbl\n\t\tbase += 8\n\t\tfallthrough\n\tcase 2:\n\t\tblock.Encrypt(next, src[base:])\n\t\t*(*uint64)(unsafe.Pointer(&dst[base])) = *(*uint64)(unsafe.Pointer(&src[base])) ^ *(*uint64)(unsafe.Pointer(&tbl[0]))\n\t\ttbl, next = next, tbl\n\t\tbase += 8\n\t\tfallthrough\n\tcase 1:\n\t\tblock.Encrypt(next, src[base:])\n\t\t*(*uint64)(unsafe.Pointer(&dst[base])) = *(*uint64)(unsafe.Pointer(&src[base])) ^ *(*uint64)(unsafe.Pointer(&tbl[0]))\n\t\ttbl, next = next, tbl\n\t\tbase += 8\n\t\tfallthrough\n\tcase 0:\n\t\txorBytes(dst[base:], src[base:], tbl)\n\t}\n}\n\nfunc decrypt16(block cipher.Block, dst, src, buf []byte) {\n\ttbl := buf[0:16]\n\tnext := buf[16:32]\n\tblock.Encrypt(tbl, initialVector)\n\tn := len(src) / 16\n\tbase := 0\n\trepeat := n / 8\n\tleft := n % 8\n\n\t// loop unrolling to relieve data dependency\n\tfor i := 0; i < repeat; i++ {\n\t\ts := src[base:][0:128]\n\t\td := dst[base:][0:128]\n\t\t// 1\n\t\tblock.Encrypt(next, s[0:16])\n\t\txor.Bytes16Align(d[0:16], s[0:16], tbl)\n\t\t// 2\n\t\tblock.Encrypt(tbl, s[16:32])\n\t\txor.Bytes16Align(d[16:32], s[16:32], next)\n\t\t// 3\n\t\tblock.Encrypt(next, s[32:48])\n\t\txor.Bytes16Align(d[32:48], s[32:48], tbl)\n\t\t// 4\n\t\tblock.Encrypt(tbl, s[48:64])\n\t\txor.Bytes16Align(d[48:64], s[48:64], next)\n\t\t// 5\n\t\tblock.Encrypt(next, s[64:80])\n\t\txor.Bytes16Align(d[64:80], s[64:80], tbl)\n\t\t// 6\n\t\tblock.Encrypt(tbl, s[80:96])\n\t\txor.Bytes16Align(d[80:96], s[80:96], next)\n\t\t// 7\n\t\tblock.Encrypt(next, s[96:112])\n\t\txor.Bytes16Align(d[96:112], s[96:112], tbl)\n\t\t// 8\n\t\tblock.Encrypt(tbl, s[112:128])\n\t\txor.Bytes16Align(d[112:128], s[112:128], next)\n\t\tbase += 128\n\t}\n\n\tswitch left {\n\tcase 7:\n\t\tblock.Encrypt(next, src[base:])\n\t\txor.Bytes16Align(dst[base:], src[base:], tbl)\n\t\ttbl, next = next, tbl\n\t\tbase += 16\n\t\tfallthrough\n\tcase 6:\n\t\tblock.Encrypt(next, src[base:])\n\t\txor.Bytes16Align(dst[base:], src[base:], tbl)\n\t\ttbl, next = next, tbl\n\t\tbase += 16\n\t\tfallthrough\n\tcase 5:\n\t\tblock.Encrypt(next, src[base:])\n\t\txor.Bytes16Align(dst[base:], src[base:], tbl)\n\t\ttbl, next = next, tbl\n\t\tbase += 16\n\t\tfallthrough\n\tcase 4:\n\t\tblock.Encrypt(next, src[base:])\n\t\txor.Bytes16Align(dst[base:], src[base:], tbl)\n\t\ttbl, next = next, tbl\n\t\tbase += 16\n\t\tfallthrough\n\tcase 3:\n\t\tblock.Encrypt(next, src[base:])\n\t\txor.Bytes16Align(dst[base:], src[base:], tbl)\n\t\ttbl, next = next, tbl\n\t\tbase += 16\n\t\tfallthrough\n\tcase 2:\n\t\tblock.Encrypt(next, src[base:])\n\t\txor.Bytes16Align(dst[base:], src[base:], tbl)\n\t\ttbl, next = next, tbl\n\t\tbase += 16\n\t\tfallthrough\n\tcase 1:\n\t\tblock.Encrypt(next, src[base:])\n\t\txor.Bytes16Align(dst[base:], src[base:], tbl)\n\t\ttbl, next = next, tbl\n\t\tbase += 16\n\t\tfallthrough\n\tcase 0:\n\t\txorBytes(dst[base:], src[base:], tbl)\n\t}\n}\n\n// per bytes xors\nfunc xorBytes(dst, a, b []byte) int {\n\tn := len(a)\n\tif len(b) < n {\n\t\tn = len(b)\n\t}\n\tif n == 0 {\n\t\treturn 0\n\t}\n\n\tfor i := 0; i < n; i++ {\n\t\tdst[i] = a[i] ^ b[i]\n\t}\n\treturn n\n}\n"
        },
        {
          "name": "crypt_test.go",
          "type": "blob",
          "size": 5.8896484375,
          "content": "// The MIT License (MIT)\n//\n// Copyright (c) 2015 xtaci\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.\n\npackage kcp\n\nimport (\n\t\"bytes\"\n\t\"crypto/aes\"\n\t\"crypto/md5\"\n\t\"crypto/rand\"\n\t\"crypto/sha1\"\n\t\"hash/crc32\"\n\t\"io\"\n\t\"testing\"\n)\n\nfunc TestSM4(t *testing.T) {\n\tbc, err := NewSM4BlockCrypt(pass[:16])\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tcryptTest(t, bc)\n}\n\nfunc TestAES(t *testing.T) {\n\tbc, err := NewAESBlockCrypt(pass[:32])\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tcryptTest(t, bc)\n}\n\nfunc TestTEA(t *testing.T) {\n\tbc, err := NewTEABlockCrypt(pass[:16])\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tcryptTest(t, bc)\n}\n\nfunc TestXOR(t *testing.T) {\n\tbc, err := NewSimpleXORBlockCrypt(pass[:32])\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tcryptTest(t, bc)\n}\n\nfunc TestBlowfish(t *testing.T) {\n\tbc, err := NewBlowfishBlockCrypt(pass[:32])\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tcryptTest(t, bc)\n}\n\nfunc TestNone(t *testing.T) {\n\tbc, err := NewNoneBlockCrypt(pass[:32])\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tcryptTest(t, bc)\n}\n\nfunc TestCast5(t *testing.T) {\n\tbc, err := NewCast5BlockCrypt(pass[:16])\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tcryptTest(t, bc)\n}\n\nfunc Test3DES(t *testing.T) {\n\tbc, err := NewTripleDESBlockCrypt(pass[:24])\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tcryptTest(t, bc)\n}\n\nfunc TestTwofish(t *testing.T) {\n\tbc, err := NewTwofishBlockCrypt(pass[:32])\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tcryptTest(t, bc)\n}\n\nfunc TestXTEA(t *testing.T) {\n\tbc, err := NewXTEABlockCrypt(pass[:16])\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tcryptTest(t, bc)\n}\n\nfunc TestSalsa20(t *testing.T) {\n\tbc, err := NewSalsa20BlockCrypt(pass[:32])\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tcryptTest(t, bc)\n}\n\nfunc cryptTest(t *testing.T, bc BlockCrypt) {\n\tdata := make([]byte, mtuLimit)\n\tio.ReadFull(rand.Reader, data)\n\tdec := make([]byte, mtuLimit)\n\tenc := make([]byte, mtuLimit)\n\tbc.Encrypt(enc, data)\n\tbc.Decrypt(dec, enc)\n\tif !bytes.Equal(data, dec) {\n\t\tt.Fail()\n\t}\n}\n\nfunc BenchmarkSM4(b *testing.B) {\n\tbc, err := NewSM4BlockCrypt(pass[:16])\n\tif err != nil {\n\t\tb.Fatal(err)\n\t}\n\tbenchCrypt(b, bc)\n}\n\nfunc BenchmarkAES128(b *testing.B) {\n\tbc, err := NewAESBlockCrypt(pass[:16])\n\tif err != nil {\n\t\tb.Fatal(err)\n\t}\n\n\tbenchCrypt(b, bc)\n}\n\nfunc BenchmarkAES192(b *testing.B) {\n\tbc, err := NewAESBlockCrypt(pass[:24])\n\tif err != nil {\n\t\tb.Fatal(err)\n\t}\n\n\tbenchCrypt(b, bc)\n}\n\nfunc BenchmarkAES256(b *testing.B) {\n\tbc, err := NewAESBlockCrypt(pass[:32])\n\tif err != nil {\n\t\tb.Fatal(err)\n\t}\n\n\tbenchCrypt(b, bc)\n}\n\nfunc BenchmarkTEA(b *testing.B) {\n\tbc, err := NewTEABlockCrypt(pass[:16])\n\tif err != nil {\n\t\tb.Fatal(err)\n\t}\n\tbenchCrypt(b, bc)\n}\n\nfunc BenchmarkXOR(b *testing.B) {\n\tbc, err := NewSimpleXORBlockCrypt(pass[:32])\n\tif err != nil {\n\t\tb.Fatal(err)\n\t}\n\tbenchCrypt(b, bc)\n}\n\nfunc BenchmarkBlowfish(b *testing.B) {\n\tbc, err := NewBlowfishBlockCrypt(pass[:32])\n\tif err != nil {\n\t\tb.Fatal(err)\n\t}\n\tbenchCrypt(b, bc)\n}\n\nfunc BenchmarkNone(b *testing.B) {\n\tbc, err := NewNoneBlockCrypt(pass[:32])\n\tif err != nil {\n\t\tb.Fatal(err)\n\t}\n\tbenchCrypt(b, bc)\n}\n\nfunc BenchmarkCast5(b *testing.B) {\n\tbc, err := NewCast5BlockCrypt(pass[:16])\n\tif err != nil {\n\t\tb.Fatal(err)\n\t}\n\tbenchCrypt(b, bc)\n}\n\nfunc Benchmark3DES(b *testing.B) {\n\tbc, err := NewTripleDESBlockCrypt(pass[:24])\n\tif err != nil {\n\t\tb.Fatal(err)\n\t}\n\tbenchCrypt(b, bc)\n}\n\nfunc BenchmarkTwofish(b *testing.B) {\n\tbc, err := NewTwofishBlockCrypt(pass[:32])\n\tif err != nil {\n\t\tb.Fatal(err)\n\t}\n\tbenchCrypt(b, bc)\n}\n\nfunc BenchmarkXTEA(b *testing.B) {\n\tbc, err := NewXTEABlockCrypt(pass[:16])\n\tif err != nil {\n\t\tb.Fatal(err)\n\t}\n\tbenchCrypt(b, bc)\n}\n\nfunc BenchmarkSalsa20(b *testing.B) {\n\tbc, err := NewSalsa20BlockCrypt(pass[:32])\n\tif err != nil {\n\t\tb.Fatal(err)\n\t}\n\tbenchCrypt(b, bc)\n}\n\nfunc benchCrypt(b *testing.B, bc BlockCrypt) {\n\tdata := make([]byte, mtuLimit)\n\tio.ReadFull(rand.Reader, data)\n\tdec := make([]byte, mtuLimit)\n\tenc := make([]byte, mtuLimit)\n\n\tb.ReportAllocs()\n\tb.SetBytes(int64(len(enc) * 2))\n\tb.ResetTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\tbc.Encrypt(enc, data)\n\t\tbc.Decrypt(dec, enc)\n\t}\n}\n\nfunc BenchmarkCRC32(b *testing.B) {\n\tcontent := make([]byte, 1024)\n\tb.SetBytes(int64(len(content)))\n\tfor i := 0; i < b.N; i++ {\n\t\tcrc32.ChecksumIEEE(content)\n\t}\n}\n\nfunc BenchmarkCsprngSystem(b *testing.B) {\n\tdata := make([]byte, md5.Size)\n\tb.SetBytes(int64(len(data)))\n\n\tfor i := 0; i < b.N; i++ {\n\t\tio.ReadFull(rand.Reader, data)\n\t}\n}\n\nfunc BenchmarkCsprngMD5(b *testing.B) {\n\tvar data [md5.Size]byte\n\tb.SetBytes(md5.Size)\n\n\tfor i := 0; i < b.N; i++ {\n\t\tdata = md5.Sum(data[:])\n\t}\n}\nfunc BenchmarkCsprngSHA1(b *testing.B) {\n\tvar data [sha1.Size]byte\n\tb.SetBytes(sha1.Size)\n\n\tfor i := 0; i < b.N; i++ {\n\t\tdata = sha1.Sum(data[:])\n\t}\n}\n\nfunc BenchmarkCsprngNonceMD5(b *testing.B) {\n\tvar ng nonceMD5\n\tng.Init()\n\tb.SetBytes(md5.Size)\n\tdata := make([]byte, md5.Size)\n\tfor i := 0; i < b.N; i++ {\n\t\tng.Fill(data)\n\t}\n}\n\nfunc BenchmarkCsprngNonceAES128(b *testing.B) {\n\tvar ng nonceAES128\n\tng.Init()\n\n\tb.SetBytes(aes.BlockSize)\n\tdata := make([]byte, aes.BlockSize)\n\tfor i := 0; i < b.N; i++ {\n\t\tng.Fill(data)\n\t}\n}\n"
        },
        {
          "name": "entropy.go",
          "type": "blob",
          "size": 2.1708984375,
          "content": "// The MIT License (MIT)\n//\n// Copyright (c) 2015 xtaci\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.\n\npackage kcp\n\nimport (\n\t\"crypto/aes\"\n\t\"crypto/cipher\"\n\t\"crypto/md5\"\n\t\"crypto/rand\"\n\t\"io\"\n)\n\n// Entropy defines a entropy source\n//\n//\tEntropy in this file generate random bits for the first 16-bytes of each packets.\ntype Entropy interface {\n\tInit()\n\tFill(nonce []byte)\n}\n\n// nonceMD5 nonce generator for packet header\ntype nonceMD5 struct {\n\tseed [md5.Size]byte\n}\n\nfunc (n *nonceMD5) Init() { /*nothing required*/ }\n\nfunc (n *nonceMD5) Fill(nonce []byte) {\n\tif n.seed[0] == 0 { // entropy update\n\t\tio.ReadFull(rand.Reader, n.seed[:])\n\t}\n\tn.seed = md5.Sum(n.seed[:])\n\tcopy(nonce, n.seed[:])\n}\n\n// nonceAES128 nonce generator for packet headers\ntype nonceAES128 struct {\n\tseed  [aes.BlockSize]byte\n\tblock cipher.Block\n}\n\nfunc (n *nonceAES128) Init() {\n\tvar key [16]byte //aes-128\n\tio.ReadFull(rand.Reader, key[:])\n\tio.ReadFull(rand.Reader, n.seed[:])\n\tblock, _ := aes.NewCipher(key[:])\n\tn.block = block\n}\n\nfunc (n *nonceAES128) Fill(nonce []byte) {\n\tif n.seed[0] == 0 { // entropy update\n\t\tio.ReadFull(rand.Reader, n.seed[:])\n\t}\n\tn.block.Encrypt(n.seed[:], n.seed[:])\n\tcopy(nonce, n.seed[:])\n}\n"
        },
        {
          "name": "examples",
          "type": "tree",
          "content": null
        },
        {
          "name": "fec.go",
          "type": "blob",
          "size": 12.552734375,
          "content": "// The MIT License (MIT)\n//\n// Copyright (c) 2015 xtaci\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.\n\n// THE GENERALIZED REED-SOLOMON FEC SCHEME\n//\n// Encoding:\n// -----------\n// Message:         | M1 | M2 | M3 | M4 |\n// Generate Parity: | P1 | P2 |\n// Encoded Codeword:| M1 | M2 | M3 | M4 | P1 | P2 |\n//\n// Decoding with Erasures:\n// ------------------------\n// Received:        | M1 | ?? | M3 | M4 | P1 | ?? |\n// Erasures:        |    | E1 |    |    |    | E2 |\n// Syndromes:       S1, S2, ...\n// Error Locator:   Λ(x) = ...\n// Correct Erasures:Determine values for E1 (M2) and E2 (P2).\n// Corrected:       | M1 | M2 | M3 | M4 | P1 | P2 |\n\npackage kcp\n\nimport (\n\t\"encoding/binary\"\n\t\"sync/atomic\"\n\t\"time\"\n\n\t\"github.com/klauspost/reedsolomon\"\n)\n\nconst (\n\tfecHeaderSize      = 6\n\tfecHeaderSizePlus2 = fecHeaderSize + 2 // plus 2B data size\n\ttypeData           = 0xf1\n\ttypeParity         = 0xf2\n\tfecExpire          = 60000\n\trxFECMulti         = 3 // FEC keeps rxFECMulti* (dataShard+parityShard) ordered packets in memory\n)\n\n// fecPacket is a decoded FEC packet\ntype fecPacket []byte\n\nfunc (bts fecPacket) seqid() uint32 { return binary.LittleEndian.Uint32(bts) }\nfunc (bts fecPacket) flag() uint16  { return binary.LittleEndian.Uint16(bts[4:]) }\nfunc (bts fecPacket) data() []byte  { return bts[6:] }\n\n// fecElement has auxcilliary time field\ntype fecElement struct {\n\tfecPacket\n\tts uint32\n}\n\n// fecDecoder for decoding incoming packets\ntype fecDecoder struct {\n\trxlimit      int // queue size limit\n\tdataShards   int\n\tparityShards int\n\tshardSize    int\n\trx           []fecElement // ordered receive queue\n\n\t// caches\n\tdecodeCache [][]byte\n\tflagCache   []bool\n\n\t// RS decoder\n\tcodec reedsolomon.Encoder\n\n\t// auto tune fec parameter\n\tautoTune   autoTune\n\tshouldTune bool\n}\n\nfunc newFECDecoder(dataShards, parityShards int) *fecDecoder {\n\tif dataShards <= 0 || parityShards <= 0 {\n\t\treturn nil\n\t}\n\n\tdec := new(fecDecoder)\n\tdec.dataShards = dataShards\n\tdec.parityShards = parityShards\n\tdec.shardSize = dataShards + parityShards\n\tdec.rxlimit = rxFECMulti * dec.shardSize\n\tcodec, err := reedsolomon.New(dataShards, parityShards)\n\tif err != nil {\n\t\treturn nil\n\t}\n\tdec.codec = codec\n\tdec.decodeCache = make([][]byte, dec.shardSize)\n\tdec.flagCache = make([]bool, dec.shardSize)\n\treturn dec\n}\n\n// decode a fec packet\nfunc (dec *fecDecoder) decode(in fecPacket) (recovered [][]byte) {\n\t// sample to auto FEC tuner\n\tif in.flag() == typeData {\n\t\tdec.autoTune.Sample(true, in.seqid())\n\t} else {\n\t\tdec.autoTune.Sample(false, in.seqid())\n\t}\n\n\t// check if FEC parameters is out of sync\n\tif int(in.seqid())%dec.shardSize < dec.dataShards {\n\t\tif in.flag() != typeData { // expect typeData\n\t\t\tdec.shouldTune = true\n\t\t}\n\t} else {\n\t\tif in.flag() != typeParity {\n\t\t\tdec.shouldTune = true\n\t\t}\n\t}\n\n\t// if signal is out-of-sync, try to detect the pattern in the signal\n\tif dec.shouldTune {\n\t\tautoDS := dec.autoTune.FindPeriod(true)\n\t\tautoPS := dec.autoTune.FindPeriod(false)\n\n\t\t// edges found, we can tune parameters now\n\t\tif autoDS > 0 && autoPS > 0 && autoDS < 256 && autoPS < 256 {\n\t\t\t// and make sure it's different\n\t\t\tif autoDS != dec.dataShards || autoPS != dec.parityShards {\n\t\t\t\tdec.dataShards = autoDS\n\t\t\t\tdec.parityShards = autoPS\n\t\t\t\tdec.shardSize = autoDS + autoPS\n\t\t\t\tdec.rxlimit = rxFECMulti * dec.shardSize\n\t\t\t\tcodec, err := reedsolomon.New(autoDS, autoPS)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn nil\n\t\t\t\t}\n\t\t\t\tdec.codec = codec\n\t\t\t\tdec.decodeCache = make([][]byte, dec.shardSize)\n\t\t\t\tdec.flagCache = make([]bool, dec.shardSize)\n\t\t\t\tdec.shouldTune = false\n\t\t\t\t//log.Println(\"autotune to :\", dec.dataShards, dec.parityShards)\n\t\t\t}\n\t\t}\n\t}\n\n\t// parameters in tuning\n\tif dec.shouldTune {\n\t\treturn nil\n\t}\n\n\t// insertion\n\tn := len(dec.rx) - 1\n\tinsertIdx := 0\n\tfor i := n; i >= 0; i-- {\n\t\tif in.seqid() == dec.rx[i].seqid() { // de-duplicate\n\t\t\treturn nil\n\t\t} else if _itimediff(in.seqid(), dec.rx[i].seqid()) > 0 { // insertion\n\t\t\tinsertIdx = i + 1\n\t\t\tbreak\n\t\t}\n\t}\n\n\t// make a copy\n\tpkt := fecPacket(xmitBuf.Get().([]byte)[:len(in)])\n\tcopy(pkt, in)\n\telem := fecElement{pkt, currentMs()}\n\n\t// insert into ordered rx queue\n\tif insertIdx == n+1 {\n\t\tdec.rx = append(dec.rx, elem)\n\t} else {\n\t\tdec.rx = append(dec.rx, fecElement{})\n\t\tcopy(dec.rx[insertIdx+1:], dec.rx[insertIdx:]) // shift right\n\t\tdec.rx[insertIdx] = elem\n\t}\n\n\t// shard range for current packet\n\t// NOTE: the shard sequence number starts at 0, so we can use mod operation\n\t// to find the beginning of the current shard.\n\t// ALWAYS ALIGNED TO 0\n\tshardBegin := pkt.seqid() - pkt.seqid()%uint32(dec.shardSize)\n\tshardEnd := shardBegin + uint32(dec.shardSize) - 1\n\n\t// Define max search range in ordered queue for current shard\n\tsearchBegin := insertIdx - int(pkt.seqid()%uint32(dec.shardSize))\n\tif searchBegin < 0 {\n\t\tsearchBegin = 0\n\t}\n\tsearchEnd := searchBegin + dec.shardSize - 1\n\tif searchEnd >= len(dec.rx) {\n\t\tsearchEnd = len(dec.rx) - 1\n\t}\n\n\t// check if we have enough shards to recover, if so, we can recover the data and free the shards\n\t// if not, we can keep the shards in memory for future recovery.\n\tif searchEnd-searchBegin+1 >= dec.dataShards {\n\t\tvar numshard, numDataShard, first, maxlen int\n\n\t\t// zero working set for decoding\n\t\tshards := dec.decodeCache\n\t\tshardsflag := dec.flagCache\n\t\tfor k := range dec.decodeCache {\n\t\t\tshards[k] = nil\n\t\t\tshardsflag[k] = false\n\t\t}\n\n\t\t// lookup shards in range [searchBegin, searchEnd] to the working set\n\t\tfor i := searchBegin; i <= searchEnd; i++ {\n\t\t\tseqid := dec.rx[i].seqid()\n\t\t\t// the shard seqid must be in [shardBegin, shardEnd], i.e. the current FEC group\n\t\t\tif _itimediff(seqid, shardEnd) > 0 {\n\t\t\t\tbreak\n\t\t\t} else if _itimediff(seqid, shardBegin) >= 0 {\n\t\t\t\tshards[seqid%uint32(dec.shardSize)] = dec.rx[i].data()\n\t\t\t\tshardsflag[seqid%uint32(dec.shardSize)] = true\n\t\t\t\tnumshard++\n\t\t\t\tif dec.rx[i].flag() == typeData {\n\t\t\t\t\tnumDataShard++\n\t\t\t\t}\n\t\t\t\tif numshard == 1 {\n\t\t\t\t\tfirst = i\n\t\t\t\t}\n\t\t\t\tif len(dec.rx[i].data()) > maxlen {\n\t\t\t\t\tmaxlen = len(dec.rx[i].data())\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// case 1: if there's no loss on data shards\n\t\tif numDataShard == dec.dataShards {\n\t\t\tdec.rx = dec.freeRange(first, numshard, dec.rx)\n\t\t} else if numshard >= dec.dataShards { // case 2: loss on data shards, but it's recoverable from parity shards\n\t\t\t// make the bytes length of each shard equal\n\t\t\tfor k := range shards {\n\t\t\t\tif shards[k] != nil {\n\t\t\t\t\tdlen := len(shards[k])\n\t\t\t\t\tshards[k] = shards[k][:maxlen]\n\t\t\t\t\tclear(shards[k][dlen:])\n\t\t\t\t} else if k < dec.dataShards {\n\t\t\t\t\t// prepare memory for the data recovery\n\t\t\t\t\tshards[k] = xmitBuf.Get().([]byte)[:0]\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Reed-Solomon recovery\n\t\t\tif err := dec.codec.ReconstructData(shards); err == nil {\n\t\t\t\tfor k := range shards[:dec.dataShards] {\n\t\t\t\t\tif !shardsflag[k] {\n\t\t\t\t\t\t// recovered data should be recycled\n\t\t\t\t\t\trecovered = append(recovered, shards[k])\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Free the shards in FIFO immediately\n\t\t\tdec.rx = dec.freeRange(first, numshard, dec.rx)\n\t\t}\n\t}\n\n\t// keep rxlimit in FIFO order\n\tif len(dec.rx) > dec.rxlimit {\n\t\tif dec.rx[0].flag() == typeData {\n\t\t\t// track the effectiveness of FEC\n\t\t\tatomic.AddUint64(&DefaultSnmp.FECShortShards, 1)\n\t\t}\n\t\tdec.rx = dec.freeRange(0, 1, dec.rx)\n\t}\n\n\t// FIFO timeout policy\n\tcurrent := currentMs()\n\tnumExpired := 0\n\tfor k := range dec.rx {\n\t\tif _itimediff(current, dec.rx[k].ts) > fecExpire {\n\t\t\tnumExpired++\n\t\t\tcontinue\n\t\t}\n\t\tbreak\n\t}\n\tif numExpired > 0 {\n\t\tdec.rx = dec.freeRange(0, numExpired, dec.rx)\n\t}\n\treturn\n}\n\n// free a range of fecPacket\nfunc (dec *fecDecoder) freeRange(first, n int, q []fecElement) []fecElement {\n\tfor i := first; i < first+n; i++ { // recycle buffer\n\t\txmitBuf.Put([]byte(q[i].fecPacket))\n\t}\n\n\t// if n is small, we can avoid the copy\n\tif first == 0 && n < cap(q)/2 {\n\t\treturn q[n:]\n\t}\n\n\t// on the other hand, we shift the tail\n\tcopy(q[first:], q[first+n:])\n\treturn q[:len(q)-n]\n}\n\n// release all segments back to xmitBuf\nfunc (dec *fecDecoder) release() {\n\tif n := len(dec.rx); n > 0 {\n\t\tdec.rx = dec.freeRange(0, n, dec.rx)\n\t}\n}\n\ntype (\n\t// fecEncoder for encoding outgoing packets\n\tfecEncoder struct {\n\t\tdataShards   int\n\t\tparityShards int\n\t\tshardSize    int\n\t\tpaws         uint32 // Protect Against Wrapped Sequence numbers\n\t\tnext         uint32 // next seqid\n\n\t\tshardCount int // count the number of datashards collected\n\t\tmaxSize    int // track maximum data length in datashard\n\n\t\theaderOffset  int // FEC header offset\n\t\tpayloadOffset int // FEC payload offset\n\n\t\t// caches\n\t\tshardCache     [][]byte\n\t\tencodeCache    [][]byte\n\t\ttsLatestPacket int64\n\n\t\t// RS encoder\n\t\tcodec reedsolomon.Encoder\n\t}\n)\n\nfunc newFECEncoder(dataShards, parityShards, offset int) *fecEncoder {\n\tif dataShards <= 0 || parityShards <= 0 {\n\t\treturn nil\n\t}\n\tenc := new(fecEncoder)\n\tenc.dataShards = dataShards\n\tenc.parityShards = parityShards\n\tenc.shardSize = dataShards + parityShards\n\tenc.paws = 0xffffffff / uint32(enc.shardSize) * uint32(enc.shardSize)\n\tenc.headerOffset = offset\n\tenc.payloadOffset = enc.headerOffset + fecHeaderSize\n\n\tcodec, err := reedsolomon.New(dataShards, parityShards)\n\tif err != nil {\n\t\treturn nil\n\t}\n\tenc.codec = codec\n\n\t// caches\n\tenc.encodeCache = make([][]byte, enc.shardSize)\n\tenc.shardCache = make([][]byte, enc.shardSize)\n\tfor k := range enc.shardCache {\n\t\tenc.shardCache[k] = make([]byte, mtuLimit)\n\t}\n\treturn enc\n}\n\n// encodes the packet, outputs parity shards if we have collected quorum datashards\n// notice: the contents of 'ps' will be re-written in successive calling\nfunc (enc *fecEncoder) encode(b []byte, rto uint32) (ps [][]byte) {\n\t// The header format:\n\t// | FEC SEQID(4B) | FEC TYPE(2B) | SIZE (2B) | PAYLOAD(SIZE-2) |\n\t// |<-headerOffset                |<-payloadOffset\n\tenc.markData(b[enc.headerOffset:])\n\tbinary.LittleEndian.PutUint16(b[enc.payloadOffset:], uint16(len(b[enc.payloadOffset:])))\n\n\t// copy data from payloadOffset to fec shard cache\n\tsz := len(b)\n\tenc.shardCache[enc.shardCount] = enc.shardCache[enc.shardCount][:sz]\n\tcopy(enc.shardCache[enc.shardCount][enc.payloadOffset:], b[enc.payloadOffset:])\n\tenc.shardCount++\n\n\t// track max datashard length\n\tif sz > enc.maxSize {\n\t\tenc.maxSize = sz\n\t}\n\n\t// Generation of Reed-Solomon Erasure Code\n\tnow := time.Now().UnixMilli()\n\tif enc.shardCount == enc.dataShards {\n\t\t// generate the rs-code only if the data is continuous.\n\t\tif now-enc.tsLatestPacket < int64(rto) {\n\t\t\t// fill '0' into the tail of each datashard\n\t\t\tfor i := 0; i < enc.dataShards; i++ {\n\t\t\t\tshard := enc.shardCache[i]\n\t\t\t\tslen := len(shard)\n\t\t\t\tclear(shard[slen:enc.maxSize])\n\t\t\t}\n\n\t\t\t// construct equal-sized slice with stripped header\n\t\t\tcache := enc.encodeCache\n\t\t\tfor k := range cache {\n\t\t\t\tcache[k] = enc.shardCache[k][enc.payloadOffset:enc.maxSize]\n\t\t\t}\n\n\t\t\t// encoding\n\t\t\tif err := enc.codec.Encode(cache); err == nil {\n\t\t\t\tps = enc.shardCache[enc.dataShards:]\n\t\t\t\tfor k := range ps {\n\t\t\t\t\tenc.markParity(ps[k][enc.headerOffset:])\n\t\t\t\t\tps[k] = ps[k][:enc.maxSize]\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// record the error, and still keep the seqid monotonic increasing\n\t\t\t\tatomic.AddUint64(&DefaultSnmp.FECErrs, 1)\n\t\t\t\tenc.next = (enc.next + uint32(enc.parityShards)) % enc.paws\n\t\t\t}\n\t\t} else {\n\t\t\t// through we do not send non-continuous parity shard, we still increase the next value\n\t\t\t// to keep the seqid aligned with 0 start\n\t\t\tenc.next = (enc.next + uint32(enc.parityShards)) % enc.paws\n\t\t}\n\n\t\t// counters resetting\n\t\tenc.shardCount = 0\n\t\tenc.maxSize = 0\n\t}\n\n\tenc.tsLatestPacket = now\n\n\treturn\n}\n\n// put a stamp on the FEC packet header with seqid and type\nfunc (enc *fecEncoder) markData(data []byte) {\n\tbinary.LittleEndian.PutUint32(data, enc.next)\n\tbinary.LittleEndian.PutUint16(data[4:], typeData)\n\tenc.next = (enc.next + 1) % enc.paws\n}\n\nfunc (enc *fecEncoder) markParity(data []byte) {\n\tbinary.LittleEndian.PutUint32(data, enc.next)\n\tbinary.LittleEndian.PutUint16(data[4:], typeParity)\n\tenc.next = (enc.next + 1) % enc.paws\n}\n"
        },
        {
          "name": "fec_test.go",
          "type": "blob",
          "size": 2.9052734375,
          "content": "// The MIT License (MIT)\n//\n// Copyright (c) 2015 xtaci\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.\n\npackage kcp\n\nimport (\n\t\"encoding/binary\"\n\t\"math/rand\"\n\t\"testing\"\n\t\"time\"\n)\n\nfunc TestFECEncodeConsecutive(t *testing.T) {\n\tconst dataSize = 10\n\tconst paritySize = 3\n\tconst payLoad = 1500\n\n\tencoder := newFECEncoder(dataSize, paritySize, 0)\n\tt.Logf(\"dataSize:%v, paritySize:%v\", dataSize, paritySize)\n\tgroup := 0\n\tsent := 0\n\tfor i := 0; i < 100; i++ {\n\t\tif i%dataSize == 0 {\n\t\t\tgroup++\n\t\t}\n\n\t\tdata := make([]byte, payLoad)\n\t\tduration := time.Duration(rand.Int()%300) * time.Millisecond\n\t\tt.Logf(\"Sleep: %v, packet %v\", duration, sent)\n\t\t<-time.After(duration)\n\n\t\tps := encoder.encode(data, 200)\n\t\tsent++\n\n\t\tif len(ps) > 0 {\n\t\t\tt.Log(\"has parity:\", len(ps))\n\t\t\tfor idx, p := range ps {\n\t\t\t\tseqid := binary.LittleEndian.Uint32(p)\n\t\t\t\texpected := uint32((group-1)*(dataSize+paritySize) + dataSize + idx)\n\t\t\t\tif seqid != expected {\n\t\t\t\t\tt.Fatalf(\"expected parity shard:%v actual seqid %v\", expected, seqid)\n\t\t\t\t}\n\t\t\t}\n\t\t} else if sent%dataSize == 0 {\n\t\t\tt.Log(\"no parity:\", len(ps))\n\t\t}\n\t}\n}\n\nfunc BenchmarkFECDecode(b *testing.B) {\n\tconst dataSize = 10\n\tconst paritySize = 3\n\tconst payLoad = 1500\n\tdecoder := newFECDecoder(dataSize, paritySize)\n\tb.ReportAllocs()\n\tb.SetBytes(payLoad)\n\tfor i := 0; i < b.N; i++ {\n\t\tif rand.Int()%(dataSize+paritySize) == 0 { // random loss\n\t\t\tcontinue\n\t\t}\n\t\tpkt := make([]byte, payLoad)\n\t\tbinary.LittleEndian.PutUint32(pkt, uint32(i))\n\t\tif i%(dataSize+paritySize) >= dataSize {\n\t\t\tbinary.LittleEndian.PutUint16(pkt[4:], typeParity)\n\t\t} else {\n\t\t\tbinary.LittleEndian.PutUint16(pkt[4:], typeData)\n\t\t}\n\t\tdecoder.decode(pkt)\n\t}\n}\n\nfunc BenchmarkFECEncode(b *testing.B) {\n\tconst dataSize = 10\n\tconst paritySize = 3\n\tconst payLoad = 1500\n\n\tb.ReportAllocs()\n\tb.SetBytes(payLoad)\n\tencoder := newFECEncoder(dataSize, paritySize, 0)\n\tfor i := 0; i < b.N; i++ {\n\t\tdata := make([]byte, payLoad)\n\t\tencoder.encode(data, 200)\n\t}\n}\n"
        },
        {
          "name": "go.mod",
          "type": "blob",
          "size": 0.6142578125,
          "content": "module github.com/xtaci/kcp-go/v5\n\nrequire (\n\tgithub.com/klauspost/reedsolomon v1.12.0\n\tgithub.com/pkg/errors v0.9.1\n\tgithub.com/stretchr/testify v1.6.1\n\tgithub.com/templexxx/xorsimd v0.4.3\n\tgithub.com/tjfoc/gmsm v1.4.1\n\tgithub.com/xtaci/lossyconn v0.0.0-20190602105132-8df528c0c9ae\n\tgolang.org/x/crypto v0.21.0\n\tgolang.org/x/net v0.23.0\n)\n\nrequire (\n\tgithub.com/davecgh/go-spew v1.1.0 // indirect\n\tgithub.com/klauspost/cpuid/v2 v2.2.6 // indirect\n\tgithub.com/pmezard/go-difflib v1.0.0 // indirect\n\tgithub.com/templexxx/cpu v0.1.1 // indirect\n\tgolang.org/x/sys v0.18.0 // indirect\n\tgopkg.in/yaml.v3 v3.0.0 // indirect\n)\n\ngo 1.21\n"
        },
        {
          "name": "go.sum",
          "type": "blob",
          "size": 9.6943359375,
          "content": "cloud.google.com/go v0.26.0/go.mod h1:aQUYkXzVsufM+DwF1aE+0xfcU+56JwCaLick0ClmMTw=\ngithub.com/BurntSushi/toml v0.3.1/go.mod h1:xHWCNGjB5oqiDr8zfno3MHue2Ht5sIBksp03qcyfWMU=\ngithub.com/census-instrumentation/opencensus-proto v0.2.1/go.mod h1:f6KPmirojxKA12rnyqOA5BBL4O983OfeGPqjHWSTneU=\ngithub.com/client9/misspell v0.3.4/go.mod h1:qj6jICC3Q7zFZvVWo7KLAzC3yx5G7kyvSDkc90ppPyw=\ngithub.com/cncf/udpa/go v0.0.0-20191209042840-269d4d468f6f/go.mod h1:M8M6+tZqaGXZJjfX53e64911xZQV5JYwmTeXPW+k8Sc=\ngithub.com/davecgh/go-spew v1.1.0 h1:ZDRjVQ15GmhC3fiQ8ni8+OwkZQO4DARzQgrnXU1Liz8=\ngithub.com/davecgh/go-spew v1.1.0/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=\ngithub.com/envoyproxy/go-control-plane v0.9.0/go.mod h1:YTl/9mNaCwkRvm6d1a2C3ymFceY/DCBVvsKhRF0iEA4=\ngithub.com/envoyproxy/go-control-plane v0.9.4/go.mod h1:6rpuAdCZL397s3pYoYcLgu1mIlRU8Am5FuJP05cCM98=\ngithub.com/envoyproxy/protoc-gen-validate v0.1.0/go.mod h1:iSmxcyjqTsJpI2R4NaDN7+kN2VEUnK/pcBlmesArF7c=\ngithub.com/golang/glog v0.0.0-20160126235308-23def4e6c14b/go.mod h1:SBH7ygxi8pfUlaOkMMuAQtPIUF8ecWP5IEl/CR7VP2Q=\ngithub.com/golang/mock v1.1.1/go.mod h1:oTYuIxOrZwtPieC+H1uAHpcLFnEyAGVDL/k47Jfbm0A=\ngithub.com/golang/protobuf v1.2.0/go.mod h1:6lQm79b+lXiMfvg/cZm0SGofjICqVBUtrP5yJMmIC1U=\ngithub.com/golang/protobuf v1.3.2/go.mod h1:6lQm79b+lXiMfvg/cZm0SGofjICqVBUtrP5yJMmIC1U=\ngithub.com/golang/protobuf v1.3.3/go.mod h1:vzj43D7+SQXF/4pzW/hwtAqwc6iTitCiVSaWz5lYuqw=\ngithub.com/golang/protobuf v1.4.0-rc.1/go.mod h1:ceaxUfeHdC40wWswd/P6IGgMaK3YpKi5j83Wpe3EHw8=\ngithub.com/golang/protobuf v1.4.0-rc.1.0.20200221234624-67d41d38c208/go.mod h1:xKAWHe0F5eneWXFV3EuXVDTCmh+JuBKY0li0aMyXATA=\ngithub.com/golang/protobuf v1.4.0-rc.2/go.mod h1:LlEzMj4AhA7rCAGe4KMBDvJI+AwstrUpVNzEA03Pprs=\ngithub.com/golang/protobuf v1.4.0-rc.4.0.20200313231945-b860323f09d0/go.mod h1:WU3c8KckQ9AFe+yFwt9sWVRKCVIyN9cPHBJSNnbL67w=\ngithub.com/golang/protobuf v1.4.0/go.mod h1:jodUvKwWbYaEsadDk5Fwe5c77LiNKVO9IDvqG2KuDX0=\ngithub.com/golang/protobuf v1.4.2/go.mod h1:oDoupMAO8OvCJWAcko0GGGIgR6R6ocIYbsSw735rRwI=\ngithub.com/google/go-cmp v0.2.0/go.mod h1:oXzfMopK8JAjlY9xF4vHSVASa0yLyX7SntLO5aqRK0M=\ngithub.com/google/go-cmp v0.3.0/go.mod h1:8QqcDgzrUqlUb/G2PQTWiueGozuR1884gddMywk6iLU=\ngithub.com/google/go-cmp v0.3.1/go.mod h1:8QqcDgzrUqlUb/G2PQTWiueGozuR1884gddMywk6iLU=\ngithub.com/google/go-cmp v0.4.0/go.mod h1:v8dTdLbMG2kIc/vJvl+f65V22dbkXbowE6jgT/gNBxE=\ngithub.com/klauspost/cpuid/v2 v2.2.6 h1:ndNyv040zDGIDh8thGkXYjnFtiN02M1PVVF+JE/48xc=\ngithub.com/klauspost/cpuid/v2 v2.2.6/go.mod h1:Lcz8mBdAVJIBVzewtcLocK12l3Y+JytZYpaMropDUws=\ngithub.com/klauspost/reedsolomon v1.12.0 h1:I5FEp3xSwVCcEh3F5A7dofEfhXdF/bWhQWPH+XwBFno=\ngithub.com/klauspost/reedsolomon v1.12.0/go.mod h1:EPLZJeh4l27pUGC3aXOjheaoh1I9yut7xTURiW3LQ9Y=\ngithub.com/pkg/errors v0.9.1 h1:FEBLx1zS214owpjy7qsBeixbURkuhQAwrK5UwLGTwt4=\ngithub.com/pkg/errors v0.9.1/go.mod h1:bwawxfHBFNV+L2hUp1rHADufV3IMtnDRdf1r5NINEl0=\ngithub.com/pmezard/go-difflib v1.0.0 h1:4DBwDE0NGyQoBHbLQYPwSUPoCMWR5BEzIk/f1lZbAQM=\ngithub.com/pmezard/go-difflib v1.0.0/go.mod h1:iKH77koFhYxTK1pcRnkKkqfTogsbg7gZNVY4sRDYZ/4=\ngithub.com/prometheus/client_model v0.0.0-20190812154241-14fe0d1b01d4/go.mod h1:xMI15A0UPsDsEKsMN9yxemIoYk6Tm2C1GtYGdfGttqA=\ngithub.com/stretchr/objx v0.1.0/go.mod h1:HFkY916IF+rwdDfMAkV7OtwuqBVzrE8GR6GFx+wExME=\ngithub.com/stretchr/testify v1.6.1 h1:hDPOHmpOpP40lSULcqw7IrRb/u7w6RpDC9399XyoNd0=\ngithub.com/stretchr/testify v1.6.1/go.mod h1:6Fq8oRcR53rry900zMqJjRRixrwX3KX962/h/Wwjteg=\ngithub.com/templexxx/cpu v0.1.1 h1:isxHaxBXpYFWnk2DReuKkigaZyrjs2+9ypIdGP4h+HI=\ngithub.com/templexxx/cpu v0.1.1/go.mod h1:w7Tb+7qgcAlIyX4NhLuDKt78AHA5SzPmq0Wj6HiEnnk=\ngithub.com/templexxx/xorsimd v0.4.3 h1:9AQTFHd7Bhk3dIT7Al2XeBX5DWOvsUPZCuhyAtNbHjU=\ngithub.com/templexxx/xorsimd v0.4.3/go.mod h1:oZQcD6RFDisW2Am58dSAGwwL6rHjbzrlu25VDqfWkQg=\ngithub.com/tjfoc/gmsm v1.4.1 h1:aMe1GlZb+0bLjn+cKTPEvvn9oUEBlJitaZiiBwsbgho=\ngithub.com/tjfoc/gmsm v1.4.1/go.mod h1:j4INPkHWMrhJb38G+J6W4Tw0AbuN8Thu3PbdVYhVcTE=\ngithub.com/xtaci/lossyconn v0.0.0-20190602105132-8df528c0c9ae h1:J0GxkO96kL4WF+AIT3M4mfUVinOCPgf2uUWYFUzN0sM=\ngithub.com/xtaci/lossyconn v0.0.0-20190602105132-8df528c0c9ae/go.mod h1:gXtu8J62kEgmN++bm9BVICuT/e8yiLI2KFobd/TRFsE=\ngolang.org/x/crypto v0.0.0-20190308221718-c2843e01d9a2/go.mod h1:djNgcEr1/C05ACkg1iLfiJU5Ep61QUkGW8qpdssI0+w=\ngolang.org/x/crypto v0.0.0-20200622213623-75b288015ac9/go.mod h1:LzIPMQfyMNhhGPhUkYOs5KpL4U8rLKemX1yGLhDgUto=\ngolang.org/x/crypto v0.0.0-20201012173705-84dcc777aaee/go.mod h1:LzIPMQfyMNhhGPhUkYOs5KpL4U8rLKemX1yGLhDgUto=\ngolang.org/x/crypto v0.21.0 h1:X31++rzVUdKhX5sWmSOFZxx8UW/ldWx55cbf08iNAMA=\ngolang.org/x/crypto v0.21.0/go.mod h1:0BP7YvVV9gBbVKyeTG0Gyn+gZm94bibOW5BjDEYAOMs=\ngolang.org/x/exp v0.0.0-20190121172915-509febef88a4/go.mod h1:CJ0aWSM057203Lf6IL+f9T1iT9GByDxfZKAQTCR3kQA=\ngolang.org/x/lint v0.0.0-20181026193005-c67002cb31c3/go.mod h1:UVdnD1Gm6xHRNCYTkRU2/jEulfH38KcIWyp/GAMgvoE=\ngolang.org/x/lint v0.0.0-20190227174305-5b3e6a55c961/go.mod h1:wehouNa3lNwaWXcvxsM5YxQ5yQlVC4a0KAMCusXpPoU=\ngolang.org/x/lint v0.0.0-20190313153728-d0100b6bd8b3/go.mod h1:6SW0HCj/g11FgYtHlgUYUwCkIfeOF89ocIRzGO/8vkc=\ngolang.org/x/net v0.0.0-20180724234803-3673e40ba225/go.mod h1:mL1N/T3taQHkDXs73rZJwtUhF3w3ftmwwsq0BUmARs4=\ngolang.org/x/net v0.0.0-20180826012351-8a410e7b638d/go.mod h1:mL1N/T3taQHkDXs73rZJwtUhF3w3ftmwwsq0BUmARs4=\ngolang.org/x/net v0.0.0-20190213061140-3a22650c66bd/go.mod h1:mL1N/T3taQHkDXs73rZJwtUhF3w3ftmwwsq0BUmARs4=\ngolang.org/x/net v0.0.0-20190311183353-d8887717615a/go.mod h1:t9HGtf8HONx5eT2rtn7q6eTqICYqUVnKs3thJo3Qplg=\ngolang.org/x/net v0.0.0-20190404232315-eb5bcb51f2a3/go.mod h1:t9HGtf8HONx5eT2rtn7q6eTqICYqUVnKs3thJo3Qplg=\ngolang.org/x/net v0.0.0-20201010224723-4f7140c49acb/go.mod h1:sp8m0HH+o8qH0wwXwYZr8TS3Oi6o0r6Gce1SSxlDquU=\ngolang.org/x/net v0.23.0 h1:7EYJ93RZ9vYSZAIb2x3lnuvqO5zneoD6IvWjuhfxjTs=\ngolang.org/x/net v0.23.0/go.mod h1:JKghWKKOSdJwpW2GEx0Ja7fmaKnMsbu+MWVZTokSYmg=\ngolang.org/x/oauth2 v0.0.0-20180821212333-d2e6202438be/go.mod h1:N/0e6XlmueqKjAGxoOufVs8QHGRruUQn6yWY3a++T0U=\ngolang.org/x/sync v0.0.0-20180314180146-1d60e4601c6f/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=\ngolang.org/x/sync v0.0.0-20181108010431-42b317875d0f/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=\ngolang.org/x/sync v0.0.0-20190423024810-112230192c58/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=\ngolang.org/x/sys v0.0.0-20180830151530-49385e6e1522/go.mod h1:STP8DvDyc/dI5b8T5hshtkjS+E42TnysNCUPdjciGhY=\ngolang.org/x/sys v0.0.0-20190215142949-d0b11bdaac8a/go.mod h1:STP8DvDyc/dI5b8T5hshtkjS+E42TnysNCUPdjciGhY=\ngolang.org/x/sys v0.0.0-20190412213103-97732733099d/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20200930185726-fdedc70b468f/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.5.0/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\ngolang.org/x/sys v0.18.0 h1:DBdB3niSjOA/O0blCZBqDefyWNYveAYMNF1Wum0DYQ4=\ngolang.org/x/sys v0.18.0/go.mod h1:/VUhepiaJMQUp4+oa/7Zr1D23ma6VTLIYjOOTFZPUcA=\ngolang.org/x/text v0.3.0/go.mod h1:NqM8EUOU14njkJ3fqMW+pc6Ldnwhi/IjpwHt7yyuwOQ=\ngolang.org/x/text v0.3.3/go.mod h1:5Zoc/QRtKVWzQhOtBMvqHzDpF6irO9z98xDceosuGiQ=\ngolang.org/x/tools v0.0.0-20180917221912-90fa682c2a6e/go.mod h1:n7NCudcB/nEzxVGmLbDWY5pfWTLqBcC2KZ6jyYvM4mQ=\ngolang.org/x/tools v0.0.0-20190114222345-bf090417da8b/go.mod h1:n7NCudcB/nEzxVGmLbDWY5pfWTLqBcC2KZ6jyYvM4mQ=\ngolang.org/x/tools v0.0.0-20190226205152-f727befe758c/go.mod h1:9Yl7xja0Znq3iFh3HoIrodX9oNMXvdceNzlUR8zjMvY=\ngolang.org/x/tools v0.0.0-20190311212946-11955173bddd/go.mod h1:LCzVGOaR6xXOjkQ3onu1FJEFr0SW1gC7cKk1uF8kGRs=\ngolang.org/x/tools v0.0.0-20190524140312-2c0ae7006135/go.mod h1:RgjU9mgBXZiqYHBnxXauZ1Gv1EHHAz9KjViQ78xBX0Q=\ngolang.org/x/xerrors v0.0.0-20191204190536-9bdfabe68543/go.mod h1:I/5z698sn9Ka8TeJc9MKroUUfqBBauWjQqLJ2OPfmY0=\ngoogle.golang.org/appengine v1.1.0/go.mod h1:EbEs0AVv82hx2wNQdGPgUI5lhzA/G0D9YwlJXL52JkM=\ngoogle.golang.org/appengine v1.4.0/go.mod h1:xpcJRLb0r/rnEns0DIKYYv+WjYCduHsrkT7/EB5XEv4=\ngoogle.golang.org/genproto v0.0.0-20180817151627-c66870c02cf8/go.mod h1:JiN7NxoALGmiZfu7CAH4rXhgtRTLTxftemlI0sWmxmc=\ngoogle.golang.org/genproto v0.0.0-20190819201941-24fa4b261c55/go.mod h1:DMBHOl98Agz4BDEuKkezgsaosCRResVns1a3J2ZsMNc=\ngoogle.golang.org/grpc v1.19.0/go.mod h1:mqu4LbDTu4XGKhr4mRzUsmM4RtVoemTSY81AxZiDr8c=\ngoogle.golang.org/grpc v1.23.0/go.mod h1:Y5yQAOtifL1yxbo5wqy6BxZv8vAUGQwXBOALyacEbxg=\ngoogle.golang.org/grpc v1.25.1/go.mod h1:c3i+UQWmh7LiEpx4sFZnkU36qjEYZ0imhYfXVyQciAY=\ngoogle.golang.org/grpc v1.31.0/go.mod h1:N36X2cJ7JwdamYAgDz+s+rVMFjt3numwzf/HckM8pak=\ngoogle.golang.org/protobuf v0.0.0-20200109180630-ec00e32a8dfd/go.mod h1:DFci5gLYBciE7Vtevhsrf46CRTquxDuWsQurQQe4oz8=\ngoogle.golang.org/protobuf v0.0.0-20200221191635-4d8936d0db64/go.mod h1:kwYJMbMJ01Woi6D6+Kah6886xMZcty6N08ah7+eCXa0=\ngoogle.golang.org/protobuf v0.0.0-20200228230310-ab0ca4ff8a60/go.mod h1:cfTl7dwQJ+fmap5saPgwCLgHXTUD7jkjRqWcaiX5VyM=\ngoogle.golang.org/protobuf v1.20.1-0.20200309200217-e05f789c0967/go.mod h1:A+miEFZTKqfCUM6K7xSMQL9OKL/b6hQv+e19PK+JZNE=\ngoogle.golang.org/protobuf v1.21.0/go.mod h1:47Nbq4nVaFHyn7ilMalzfO3qCViNmqZ2kzikPIcrTAo=\ngoogle.golang.org/protobuf v1.23.0/go.mod h1:EGpADcykh3NcUnDUJcl1+ZksZNG86OlYog2l/sGQquU=\ngopkg.in/check.v1 v0.0.0-20161208181325-20d25e280405 h1:yhCVgyC4o1eVCa2tZl7eS0r+SDo693bJlVdllGtEeKM=\ngopkg.in/check.v1 v0.0.0-20161208181325-20d25e280405/go.mod h1:Co6ibVJAznAaIkqp8huTwlJQCZ016jof/cbN4VW5Yz0=\ngopkg.in/yaml.v3 v3.0.0-20200313102051-9f266ea9e77c/go.mod h1:K4uyk7z7BCEPqu6E+C64Yfv1cQ7kz7rIZviUmN+EgEM=\ngopkg.in/yaml.v3 v3.0.0 h1:hjy8E9ON/egN1tAYqKb61G10WtihqetD4sz2H+8nIeA=\ngopkg.in/yaml.v3 v3.0.0/go.mod h1:K4uyk7z7BCEPqu6E+C64Yfv1cQ7kz7rIZviUmN+EgEM=\nhonnef.co/go/tools v0.0.0-20190102054323-c2f93a96b099/go.mod h1:rf3lG4BRIbNafJWhAfAdb/ePZxsR/4RtNHQocxwk9r4=\nhonnef.co/go/tools v0.0.0-20190523083050-ea95bdfd59fc/go.mod h1:rf3lG4BRIbNafJWhAfAdb/ePZxsR/4RtNHQocxwk9r4=\n"
        },
        {
          "name": "kcp.go",
          "type": "blob",
          "size": 24.697265625,
          "content": "// The MIT License (MIT)\n//\n// Copyright (c) 2015 xtaci\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.\n\npackage kcp\n\nimport (\n\t\"encoding/binary\"\n\t\"sync/atomic\"\n\t\"time\"\n)\n\nconst (\n\tIKCP_RTO_NDL     = 30  // no delay min rto\n\tIKCP_RTO_MIN     = 100 // normal min rto\n\tIKCP_RTO_DEF     = 200\n\tIKCP_RTO_MAX     = 60000\n\tIKCP_CMD_PUSH    = 81 // cmd: push data\n\tIKCP_CMD_ACK     = 82 // cmd: ack\n\tIKCP_CMD_WASK    = 83 // cmd: window probe (ask)\n\tIKCP_CMD_WINS    = 84 // cmd: window size (tell)\n\tIKCP_ASK_SEND    = 1  // need to send IKCP_CMD_WASK\n\tIKCP_ASK_TELL    = 2  // need to send IKCP_CMD_WINS\n\tIKCP_WND_SND     = 32\n\tIKCP_WND_RCV     = 32\n\tIKCP_MTU_DEF     = 1400\n\tIKCP_ACK_FAST    = 3\n\tIKCP_INTERVAL    = 100\n\tIKCP_OVERHEAD    = 24\n\tIKCP_DEADLINK    = 20\n\tIKCP_THRESH_INIT = 2\n\tIKCP_THRESH_MIN  = 2\n\tIKCP_PROBE_INIT  = 7000   // 7 secs to probe window size\n\tIKCP_PROBE_LIMIT = 120000 // up to 120 secs to probe window\n\tIKCP_SN_OFFSET   = 12\n)\n\n// monotonic reference time point\nvar refTime time.Time = time.Now()\n\n// currentMs returns current elapsed monotonic milliseconds since program startup\nfunc currentMs() uint32 { return uint32(time.Since(refTime) / time.Millisecond) }\n\n// output_callback is a prototype which ought capture conn and call conn.Write\ntype output_callback func(buf []byte, size int)\n\n/* encode 8 bits unsigned int */\nfunc ikcp_encode8u(p []byte, c byte) []byte {\n\tp[0] = c\n\treturn p[1:]\n}\n\n/* decode 8 bits unsigned int */\nfunc ikcp_decode8u(p []byte, c *byte) []byte {\n\t*c = p[0]\n\treturn p[1:]\n}\n\n/* encode 16 bits unsigned int (lsb) */\nfunc ikcp_encode16u(p []byte, w uint16) []byte {\n\tbinary.LittleEndian.PutUint16(p, w)\n\treturn p[2:]\n}\n\n/* decode 16 bits unsigned int (lsb) */\nfunc ikcp_decode16u(p []byte, w *uint16) []byte {\n\t*w = binary.LittleEndian.Uint16(p)\n\treturn p[2:]\n}\n\n/* encode 32 bits unsigned int (lsb) */\nfunc ikcp_encode32u(p []byte, l uint32) []byte {\n\tbinary.LittleEndian.PutUint32(p, l)\n\treturn p[4:]\n}\n\n/* decode 32 bits unsigned int (lsb) */\nfunc ikcp_decode32u(p []byte, l *uint32) []byte {\n\t*l = binary.LittleEndian.Uint32(p)\n\treturn p[4:]\n}\n\nfunc _imin_(a, b uint32) uint32 {\n\tif a <= b {\n\t\treturn a\n\t}\n\treturn b\n}\n\nfunc _imax_(a, b uint32) uint32 {\n\tif a >= b {\n\t\treturn a\n\t}\n\treturn b\n}\n\nfunc _ibound_(lower, middle, upper uint32) uint32 {\n\treturn _imin_(_imax_(lower, middle), upper)\n}\n\nfunc _itimediff(later, earlier uint32) int32 {\n\treturn (int32)(later - earlier)\n}\n\n// segment defines a KCP segment\ntype segment struct {\n\tconv     uint32\n\tcmd      uint8\n\tfrg      uint8\n\twnd      uint16\n\tts       uint32\n\tsn       uint32\n\tuna      uint32\n\trto      uint32\n\txmit     uint32\n\tresendts uint32\n\tfastack  uint32\n\tacked    uint32 // mark if the seg has acked\n\tdata     []byte\n}\n\n// encode a segment into buffer\nfunc (seg *segment) encode(ptr []byte) []byte {\n\tptr = ikcp_encode32u(ptr, seg.conv)\n\tptr = ikcp_encode8u(ptr, seg.cmd)\n\tptr = ikcp_encode8u(ptr, seg.frg)\n\tptr = ikcp_encode16u(ptr, seg.wnd)\n\tptr = ikcp_encode32u(ptr, seg.ts)\n\tptr = ikcp_encode32u(ptr, seg.sn)\n\tptr = ikcp_encode32u(ptr, seg.una)\n\tptr = ikcp_encode32u(ptr, uint32(len(seg.data)))\n\tatomic.AddUint64(&DefaultSnmp.OutSegs, 1)\n\treturn ptr\n}\n\n// KCP defines a single KCP connection\ntype KCP struct {\n\tconv, mtu, mss, state                  uint32\n\tsnd_una, snd_nxt, rcv_nxt              uint32\n\tssthresh                               uint32\n\trx_rttvar, rx_srtt                     int32\n\trx_rto, rx_minrto                      uint32\n\tsnd_wnd, rcv_wnd, rmt_wnd, cwnd, probe uint32\n\tinterval, ts_flush                     uint32\n\tnodelay, updated                       uint32\n\tts_probe, probe_wait                   uint32\n\tdead_link, incr                        uint32\n\n\tfastresend     int32\n\tnocwnd, stream int32\n\n\tsnd_queue []segment\n\trcv_queue []segment\n\tsnd_buf   []segment\n\trcv_buf   []segment\n\n\tacklist []ackItem\n\n\tbuffer []byte\n\toutput output_callback\n}\n\ntype ackItem struct {\n\tsn uint32\n\tts uint32\n}\n\n// NewKCP create a new kcp state machine\n//\n// 'conv' must be equal in the connection peers, or else data will be silently rejected.\n//\n// 'output' function will be called whenever these is data to be sent on wire.\nfunc NewKCP(conv uint32, output output_callback) *KCP {\n\tkcp := new(KCP)\n\tkcp.conv = conv\n\tkcp.snd_wnd = IKCP_WND_SND\n\tkcp.rcv_wnd = IKCP_WND_RCV\n\tkcp.rmt_wnd = IKCP_WND_RCV\n\tkcp.mtu = IKCP_MTU_DEF\n\tkcp.mss = kcp.mtu - IKCP_OVERHEAD\n\tkcp.buffer = make([]byte, kcp.mtu)\n\tkcp.rx_rto = IKCP_RTO_DEF\n\tkcp.rx_minrto = IKCP_RTO_MIN\n\tkcp.interval = IKCP_INTERVAL\n\tkcp.ts_flush = IKCP_INTERVAL\n\tkcp.ssthresh = IKCP_THRESH_INIT\n\tkcp.dead_link = IKCP_DEADLINK\n\tkcp.output = output\n\treturn kcp\n}\n\n// newSegment creates a KCP segment\nfunc (kcp *KCP) newSegment(size int) (seg segment) {\n\tseg.data = xmitBuf.Get().([]byte)[:size]\n\treturn\n}\n\n// delSegment recycles a KCP segment\nfunc (kcp *KCP) delSegment(seg *segment) {\n\tif seg.data != nil {\n\t\txmitBuf.Put(seg.data)\n\t\tseg.data = nil\n\t}\n}\n\n// PeekSize checks the size of next message in the recv queue\nfunc (kcp *KCP) PeekSize() (length int) {\n\tif len(kcp.rcv_queue) == 0 {\n\t\treturn -1\n\t}\n\n\tseg := &kcp.rcv_queue[0]\n\tif seg.frg == 0 {\n\t\treturn len(seg.data)\n\t}\n\n\tif len(kcp.rcv_queue) < int(seg.frg+1) {\n\t\treturn -1\n\t}\n\n\tfor k := range kcp.rcv_queue {\n\t\tseg := &kcp.rcv_queue[k]\n\t\tlength += len(seg.data)\n\t\tif seg.frg == 0 {\n\t\t\tbreak\n\t\t}\n\t}\n\treturn\n}\n\n// Receive data from kcp state machine\n//\n// Return number of bytes read.\n//\n// Return -1 when there is no readable data.\n//\n// Return -2 if len(buffer) is smaller than kcp.PeekSize().\nfunc (kcp *KCP) Recv(buffer []byte) (n int) {\n\tpeeksize := kcp.PeekSize()\n\tif peeksize < 0 {\n\t\treturn -1\n\t}\n\n\tif peeksize > len(buffer) {\n\t\treturn -2\n\t}\n\n\tvar fast_recover bool\n\tif len(kcp.rcv_queue) >= int(kcp.rcv_wnd) {\n\t\tfast_recover = true\n\t}\n\n\t// merge fragment\n\tcount := 0\n\tfor k := range kcp.rcv_queue {\n\t\tseg := &kcp.rcv_queue[k]\n\t\tcopy(buffer, seg.data)\n\t\tbuffer = buffer[len(seg.data):]\n\t\tn += len(seg.data)\n\t\tcount++\n\t\tkcp.delSegment(seg)\n\t\tif seg.frg == 0 {\n\t\t\tbreak\n\t\t}\n\t}\n\tif count > 0 {\n\t\tkcp.rcv_queue = kcp.remove_front(kcp.rcv_queue, count)\n\t}\n\n\t// move available data from rcv_buf -> rcv_queue\n\tcount = 0\n\tfor k := range kcp.rcv_buf {\n\t\tseg := &kcp.rcv_buf[k]\n\t\tif seg.sn == kcp.rcv_nxt && len(kcp.rcv_queue)+count < int(kcp.rcv_wnd) {\n\t\t\tkcp.rcv_nxt++\n\t\t\tcount++\n\t\t} else {\n\t\t\tbreak\n\t\t}\n\t}\n\n\tif count > 0 {\n\t\tkcp.rcv_queue = append(kcp.rcv_queue, kcp.rcv_buf[:count]...)\n\t\tkcp.rcv_buf = kcp.remove_front(kcp.rcv_buf, count)\n\t}\n\n\t// fast recover\n\tif len(kcp.rcv_queue) < int(kcp.rcv_wnd) && fast_recover {\n\t\t// ready to send back IKCP_CMD_WINS in ikcp_flush\n\t\t// tell remote my window size\n\t\tkcp.probe |= IKCP_ASK_TELL\n\t}\n\treturn\n}\n\n// Send is user/upper level send, returns below zero for error\nfunc (kcp *KCP) Send(buffer []byte) int {\n\tvar count int\n\tif len(buffer) == 0 {\n\t\treturn -1\n\t}\n\n\t// append to previous segment in streaming mode (if possible)\n\tif kcp.stream != 0 {\n\t\tn := len(kcp.snd_queue)\n\t\tif n > 0 {\n\t\t\tseg := &kcp.snd_queue[n-1]\n\t\t\tif len(seg.data) < int(kcp.mss) {\n\t\t\t\tcapacity := int(kcp.mss) - len(seg.data)\n\t\t\t\textend := capacity\n\t\t\t\tif len(buffer) < capacity {\n\t\t\t\t\textend = len(buffer)\n\t\t\t\t}\n\n\t\t\t\t// grow slice, the underlying cap is guaranteed to\n\t\t\t\t// be larger than kcp.mss\n\t\t\t\toldlen := len(seg.data)\n\t\t\t\tseg.data = seg.data[:oldlen+extend]\n\t\t\t\tcopy(seg.data[oldlen:], buffer)\n\t\t\t\tbuffer = buffer[extend:]\n\t\t\t}\n\t\t}\n\n\t\tif len(buffer) == 0 {\n\t\t\treturn 0\n\t\t}\n\t}\n\n\tif len(buffer) <= int(kcp.mss) {\n\t\tcount = 1\n\t} else {\n\t\tcount = (len(buffer) + int(kcp.mss) - 1) / int(kcp.mss)\n\t}\n\n\tif count > 255 {\n\t\treturn -2\n\t}\n\n\tif count == 0 {\n\t\tcount = 1\n\t}\n\n\tfor i := 0; i < count; i++ {\n\t\tvar size int\n\t\tif len(buffer) > int(kcp.mss) {\n\t\t\tsize = int(kcp.mss)\n\t\t} else {\n\t\t\tsize = len(buffer)\n\t\t}\n\t\tseg := kcp.newSegment(size)\n\t\tcopy(seg.data, buffer[:size])\n\t\tif kcp.stream == 0 { // message mode\n\t\t\tseg.frg = uint8(count - i - 1)\n\t\t} else { // stream mode\n\t\t\tseg.frg = 0\n\t\t}\n\t\tkcp.snd_queue = append(kcp.snd_queue, seg)\n\t\tbuffer = buffer[size:]\n\t}\n\treturn 0\n}\n\nfunc (kcp *KCP) update_ack(rtt int32) {\n\t// https://tools.ietf.org/html/rfc6298\n\tvar rto uint32\n\tif kcp.rx_srtt == 0 {\n\t\tkcp.rx_srtt = rtt\n\t\tkcp.rx_rttvar = rtt >> 1\n\t} else {\n\t\tdelta := rtt - kcp.rx_srtt\n\t\tkcp.rx_srtt += delta >> 3\n\t\tif delta < 0 {\n\t\t\tdelta = -delta\n\t\t}\n\t\tif rtt < kcp.rx_srtt-kcp.rx_rttvar {\n\t\t\t// if the new RTT sample is below the bottom of the range of\n\t\t\t// what an RTT measurement is expected to be.\n\t\t\t// give an 8x reduced weight versus its normal weighting\n\t\t\tkcp.rx_rttvar += (delta - kcp.rx_rttvar) >> 5\n\t\t} else {\n\t\t\tkcp.rx_rttvar += (delta - kcp.rx_rttvar) >> 2\n\t\t}\n\t}\n\trto = uint32(kcp.rx_srtt) + _imax_(kcp.interval, uint32(kcp.rx_rttvar)<<2)\n\tkcp.rx_rto = _ibound_(kcp.rx_minrto, rto, IKCP_RTO_MAX)\n}\n\nfunc (kcp *KCP) shrink_buf() {\n\tif len(kcp.snd_buf) > 0 {\n\t\tseg := &kcp.snd_buf[0]\n\t\tkcp.snd_una = seg.sn\n\t} else {\n\t\tkcp.snd_una = kcp.snd_nxt\n\t}\n}\n\nfunc (kcp *KCP) parse_ack(sn uint32) {\n\tif _itimediff(sn, kcp.snd_una) < 0 || _itimediff(sn, kcp.snd_nxt) >= 0 {\n\t\treturn\n\t}\n\n\tfor k := range kcp.snd_buf {\n\t\tseg := &kcp.snd_buf[k]\n\t\tif sn == seg.sn {\n\t\t\t// mark and free space, but leave the segment here,\n\t\t\t// and wait until `una` to delete this, then we don't\n\t\t\t// have to shift the segments behind forward,\n\t\t\t// which is an expensive operation for large window\n\t\t\tseg.acked = 1\n\t\t\tkcp.delSegment(seg)\n\t\t\tbreak\n\t\t}\n\t\tif _itimediff(sn, seg.sn) < 0 {\n\t\t\tbreak\n\t\t}\n\t}\n}\n\nfunc (kcp *KCP) parse_fastack(sn, ts uint32) {\n\tif _itimediff(sn, kcp.snd_una) < 0 || _itimediff(sn, kcp.snd_nxt) >= 0 {\n\t\treturn\n\t}\n\n\tfor k := range kcp.snd_buf {\n\t\tseg := &kcp.snd_buf[k]\n\t\tif _itimediff(sn, seg.sn) < 0 {\n\t\t\tbreak\n\t\t} else if sn != seg.sn && _itimediff(seg.ts, ts) <= 0 {\n\t\t\tseg.fastack++\n\t\t}\n\t}\n}\n\nfunc (kcp *KCP) parse_una(una uint32) int {\n\tcount := 0\n\tfor k := range kcp.snd_buf {\n\t\tseg := &kcp.snd_buf[k]\n\t\tif _itimediff(una, seg.sn) > 0 {\n\t\t\tkcp.delSegment(seg)\n\t\t\tcount++\n\t\t} else {\n\t\t\tbreak\n\t\t}\n\t}\n\tif count > 0 {\n\t\tkcp.snd_buf = kcp.remove_front(kcp.snd_buf, count)\n\t}\n\treturn count\n}\n\n// ack append\nfunc (kcp *KCP) ack_push(sn, ts uint32) {\n\tkcp.acklist = append(kcp.acklist, ackItem{sn, ts})\n}\n\n// returns true if data has repeated\nfunc (kcp *KCP) parse_data(newseg segment) bool {\n\tsn := newseg.sn\n\tif _itimediff(sn, kcp.rcv_nxt+kcp.rcv_wnd) >= 0 ||\n\t\t_itimediff(sn, kcp.rcv_nxt) < 0 {\n\t\treturn true\n\t}\n\n\tn := len(kcp.rcv_buf) - 1\n\tinsert_idx := 0\n\trepeat := false\n\tfor i := n; i >= 0; i-- {\n\t\tseg := &kcp.rcv_buf[i]\n\t\tif seg.sn == sn {\n\t\t\trepeat = true\n\t\t\tbreak\n\t\t}\n\t\tif _itimediff(sn, seg.sn) > 0 {\n\t\t\tinsert_idx = i + 1\n\t\t\tbreak\n\t\t}\n\t}\n\n\tif !repeat {\n\t\t// replicate the content if it's new\n\t\tdataCopy := xmitBuf.Get().([]byte)[:len(newseg.data)]\n\t\tcopy(dataCopy, newseg.data)\n\t\tnewseg.data = dataCopy\n\n\t\tif insert_idx == n+1 {\n\t\t\tkcp.rcv_buf = append(kcp.rcv_buf, newseg)\n\t\t} else {\n\t\t\tkcp.rcv_buf = append(kcp.rcv_buf, segment{})\n\t\t\tcopy(kcp.rcv_buf[insert_idx+1:], kcp.rcv_buf[insert_idx:])\n\t\t\tkcp.rcv_buf[insert_idx] = newseg\n\t\t}\n\t}\n\n\t// move available data from rcv_buf -> rcv_queue\n\tcount := 0\n\tfor k := range kcp.rcv_buf {\n\t\tseg := &kcp.rcv_buf[k]\n\t\tif seg.sn == kcp.rcv_nxt && len(kcp.rcv_queue)+count < int(kcp.rcv_wnd) {\n\t\t\tkcp.rcv_nxt++\n\t\t\tcount++\n\t\t} else {\n\t\t\tbreak\n\t\t}\n\t}\n\tif count > 0 {\n\t\tkcp.rcv_queue = append(kcp.rcv_queue, kcp.rcv_buf[:count]...)\n\t\tkcp.rcv_buf = kcp.remove_front(kcp.rcv_buf, count)\n\t}\n\n\treturn repeat\n}\n\n// Input a packet into kcp state machine.\n//\n// 'regular' indicates it's a real data packet from remote, and it means it's not generated from ReedSolomon\n// codecs.\n//\n// 'ackNoDelay' will trigger immediate ACK, but surely it will not be efficient in bandwidth\nfunc (kcp *KCP) Input(data []byte, regular, ackNoDelay bool) int {\n\tsnd_una := kcp.snd_una\n\tif len(data) < IKCP_OVERHEAD {\n\t\treturn -1\n\t}\n\n\tvar latest uint32 // the latest ack packet\n\tvar flag int\n\tvar inSegs uint64\n\tvar windowSlides bool\n\n\tfor {\n\t\tvar ts, sn, length, una, conv uint32\n\t\tvar wnd uint16\n\t\tvar cmd, frg uint8\n\n\t\tif len(data) < int(IKCP_OVERHEAD) {\n\t\t\tbreak\n\t\t}\n\n\t\tdata = ikcp_decode32u(data, &conv)\n\t\tif conv != kcp.conv {\n\t\t\treturn -1\n\t\t}\n\n\t\tdata = ikcp_decode8u(data, &cmd)\n\t\tdata = ikcp_decode8u(data, &frg)\n\t\tdata = ikcp_decode16u(data, &wnd)\n\t\tdata = ikcp_decode32u(data, &ts)\n\t\tdata = ikcp_decode32u(data, &sn)\n\t\tdata = ikcp_decode32u(data, &una)\n\t\tdata = ikcp_decode32u(data, &length)\n\t\tif len(data) < int(length) {\n\t\t\treturn -2\n\t\t}\n\n\t\tif cmd != IKCP_CMD_PUSH && cmd != IKCP_CMD_ACK &&\n\t\t\tcmd != IKCP_CMD_WASK && cmd != IKCP_CMD_WINS {\n\t\t\treturn -3\n\t\t}\n\n\t\t// only trust window updates from regular packets. i.e: latest update\n\t\tif regular {\n\t\t\tkcp.rmt_wnd = uint32(wnd)\n\t\t}\n\t\tif kcp.parse_una(una) > 0 {\n\t\t\twindowSlides = true\n\t\t}\n\t\tkcp.shrink_buf()\n\n\t\tif cmd == IKCP_CMD_ACK {\n\t\t\tkcp.parse_ack(sn)\n\t\t\tkcp.parse_fastack(sn, ts)\n\t\t\tflag |= 1\n\t\t\tlatest = ts\n\t\t} else if cmd == IKCP_CMD_PUSH {\n\t\t\trepeat := true\n\t\t\tif _itimediff(sn, kcp.rcv_nxt+kcp.rcv_wnd) < 0 {\n\t\t\t\tkcp.ack_push(sn, ts)\n\t\t\t\tif _itimediff(sn, kcp.rcv_nxt) >= 0 {\n\t\t\t\t\tvar seg segment\n\t\t\t\t\tseg.conv = conv\n\t\t\t\t\tseg.cmd = cmd\n\t\t\t\t\tseg.frg = frg\n\t\t\t\t\tseg.wnd = wnd\n\t\t\t\t\tseg.ts = ts\n\t\t\t\t\tseg.sn = sn\n\t\t\t\t\tseg.una = una\n\t\t\t\t\tseg.data = data[:length] // delayed data copying\n\t\t\t\t\trepeat = kcp.parse_data(seg)\n\t\t\t\t}\n\t\t\t}\n\t\t\tif regular && repeat {\n\t\t\t\tatomic.AddUint64(&DefaultSnmp.RepeatSegs, 1)\n\t\t\t}\n\t\t} else if cmd == IKCP_CMD_WASK {\n\t\t\t// ready to send back IKCP_CMD_WINS in Ikcp_flush\n\t\t\t// tell remote my window size\n\t\t\tkcp.probe |= IKCP_ASK_TELL\n\t\t} else if cmd == IKCP_CMD_WINS {\n\t\t\t// do nothing\n\t\t} else {\n\t\t\treturn -3\n\t\t}\n\n\t\tinSegs++\n\t\tdata = data[length:]\n\t}\n\tatomic.AddUint64(&DefaultSnmp.InSegs, inSegs)\n\n\t// update rtt with the latest ts\n\t// ignore the FEC packet\n\tif flag != 0 && regular {\n\t\tcurrent := currentMs()\n\t\tif _itimediff(current, latest) >= 0 {\n\t\t\tkcp.update_ack(_itimediff(current, latest))\n\t\t}\n\t}\n\n\t// cwnd update when packet arrived\n\tif kcp.nocwnd == 0 {\n\t\tif _itimediff(kcp.snd_una, snd_una) > 0 {\n\t\t\tif kcp.cwnd < kcp.rmt_wnd {\n\t\t\t\tmss := kcp.mss\n\t\t\t\tif kcp.cwnd < kcp.ssthresh {\n\t\t\t\t\tkcp.cwnd++\n\t\t\t\t\tkcp.incr += mss\n\t\t\t\t} else {\n\t\t\t\t\tif kcp.incr < mss {\n\t\t\t\t\t\tkcp.incr = mss\n\t\t\t\t\t}\n\t\t\t\t\tkcp.incr += (mss*mss)/kcp.incr + (mss / 16)\n\t\t\t\t\tif (kcp.cwnd+1)*mss <= kcp.incr {\n\t\t\t\t\t\tif mss > 0 {\n\t\t\t\t\t\t\tkcp.cwnd = (kcp.incr + mss - 1) / mss\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tkcp.cwnd = kcp.incr + mss - 1\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif kcp.cwnd > kcp.rmt_wnd {\n\t\t\t\t\tkcp.cwnd = kcp.rmt_wnd\n\t\t\t\t\tkcp.incr = kcp.rmt_wnd * mss\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif windowSlides { // if window has slided, flush\n\t\tkcp.flush(false)\n\t} else if ackNoDelay && len(kcp.acklist) > 0 { // ack immediately\n\t\tkcp.flush(true)\n\t}\n\treturn 0\n}\n\nfunc (kcp *KCP) wnd_unused() uint16 {\n\tif len(kcp.rcv_queue) < int(kcp.rcv_wnd) {\n\t\treturn uint16(int(kcp.rcv_wnd) - len(kcp.rcv_queue))\n\t}\n\treturn 0\n}\n\n// flush pending data\nfunc (kcp *KCP) flush(ackOnly bool) uint32 {\n\tvar seg segment\n\tseg.conv = kcp.conv\n\tseg.cmd = IKCP_CMD_ACK\n\tseg.wnd = kcp.wnd_unused()\n\tseg.una = kcp.rcv_nxt\n\n\tbuffer := kcp.buffer\n\tptr := buffer\n\n\t// makeSpace makes room for writing\n\tmakeSpace := func(space int) {\n\t\tsize := len(buffer) - len(ptr)\n\t\tif size+space > int(kcp.mtu) {\n\t\t\tkcp.output(buffer, size)\n\t\t\tptr = buffer\n\t\t}\n\t}\n\n\t// flush bytes in buffer if there is any\n\tflushBuffer := func() {\n\t\tsize := len(buffer) - len(ptr)\n\t\tif size > 0 {\n\t\t\tkcp.output(buffer, size)\n\t\t}\n\t}\n\n\t// flush acknowledges\n\tfor i, ack := range kcp.acklist {\n\t\tmakeSpace(IKCP_OVERHEAD)\n\t\t// filter jitters caused by bufferbloat\n\t\tif _itimediff(ack.sn, kcp.rcv_nxt) >= 0 || len(kcp.acklist)-1 == i {\n\t\t\tseg.sn, seg.ts = ack.sn, ack.ts\n\t\t\tptr = seg.encode(ptr)\n\t\t}\n\t}\n\tkcp.acklist = kcp.acklist[0:0]\n\n\tif ackOnly { // flash remain ack segments\n\t\tflushBuffer()\n\t\treturn kcp.interval\n\t}\n\n\t// probe window size (if remote window size equals zero)\n\tif kcp.rmt_wnd == 0 {\n\t\tcurrent := currentMs()\n\t\tif kcp.probe_wait == 0 {\n\t\t\tkcp.probe_wait = IKCP_PROBE_INIT\n\t\t\tkcp.ts_probe = current + kcp.probe_wait\n\t\t} else {\n\t\t\tif _itimediff(current, kcp.ts_probe) >= 0 {\n\t\t\t\tif kcp.probe_wait < IKCP_PROBE_INIT {\n\t\t\t\t\tkcp.probe_wait = IKCP_PROBE_INIT\n\t\t\t\t}\n\t\t\t\tkcp.probe_wait += kcp.probe_wait / 2\n\t\t\t\tif kcp.probe_wait > IKCP_PROBE_LIMIT {\n\t\t\t\t\tkcp.probe_wait = IKCP_PROBE_LIMIT\n\t\t\t\t}\n\t\t\t\tkcp.ts_probe = current + kcp.probe_wait\n\t\t\t\tkcp.probe |= IKCP_ASK_SEND\n\t\t\t}\n\t\t}\n\t} else {\n\t\tkcp.ts_probe = 0\n\t\tkcp.probe_wait = 0\n\t}\n\n\t// flush window probing commands\n\tif (kcp.probe & IKCP_ASK_SEND) != 0 {\n\t\tseg.cmd = IKCP_CMD_WASK\n\t\tmakeSpace(IKCP_OVERHEAD)\n\t\tptr = seg.encode(ptr)\n\t}\n\n\t// flush window probing commands\n\tif (kcp.probe & IKCP_ASK_TELL) != 0 {\n\t\tseg.cmd = IKCP_CMD_WINS\n\t\tmakeSpace(IKCP_OVERHEAD)\n\t\tptr = seg.encode(ptr)\n\t}\n\n\tkcp.probe = 0\n\n\t// calculate window size\n\tcwnd := _imin_(kcp.snd_wnd, kcp.rmt_wnd)\n\tif kcp.nocwnd == 0 {\n\t\tcwnd = _imin_(kcp.cwnd, cwnd)\n\t}\n\n\t// sliding window, controlled by snd_nxt && sna_una+cwnd\n\tnewSegsCount := 0\n\tfor k := range kcp.snd_queue {\n\t\tif _itimediff(kcp.snd_nxt, kcp.snd_una+cwnd) >= 0 {\n\t\t\tbreak\n\t\t}\n\t\tnewseg := kcp.snd_queue[k]\n\t\tnewseg.conv = kcp.conv\n\t\tnewseg.cmd = IKCP_CMD_PUSH\n\t\tnewseg.sn = kcp.snd_nxt\n\t\tkcp.snd_buf = append(kcp.snd_buf, newseg)\n\t\tkcp.snd_nxt++\n\t\tnewSegsCount++\n\t}\n\tif newSegsCount > 0 {\n\t\tkcp.snd_queue = kcp.remove_front(kcp.snd_queue, newSegsCount)\n\t}\n\n\t// calculate resent\n\tresent := uint32(kcp.fastresend)\n\tif kcp.fastresend <= 0 {\n\t\tresent = 0xffffffff\n\t}\n\n\t// check for retransmissions\n\tcurrent := currentMs()\n\tvar change, lostSegs, fastRetransSegs, earlyRetransSegs uint64\n\tminrto := int32(kcp.interval)\n\n\tref := kcp.snd_buf[:len(kcp.snd_buf)] // for bounds check elimination\n\tfor k := range ref {\n\t\tsegment := &ref[k]\n\t\tneedsend := false\n\t\tif segment.acked == 1 {\n\t\t\tcontinue\n\t\t}\n\t\tif segment.xmit == 0 { // initial transmit\n\t\t\tneedsend = true\n\t\t\tsegment.rto = kcp.rx_rto\n\t\t\tsegment.resendts = current + segment.rto\n\t\t} else if segment.fastack >= resent { // fast retransmit\n\t\t\tneedsend = true\n\t\t\tsegment.fastack = 0\n\t\t\tsegment.rto = kcp.rx_rto\n\t\t\tsegment.resendts = current + segment.rto\n\t\t\tchange++\n\t\t\tfastRetransSegs++\n\t\t} else if segment.fastack > 0 && newSegsCount == 0 { // early retransmit\n\t\t\tneedsend = true\n\t\t\tsegment.fastack = 0\n\t\t\tsegment.rto = kcp.rx_rto\n\t\t\tsegment.resendts = current + segment.rto\n\t\t\tchange++\n\t\t\tearlyRetransSegs++\n\t\t} else if _itimediff(current, segment.resendts) >= 0 { // RTO\n\t\t\tneedsend = true\n\t\t\tif kcp.nodelay == 0 {\n\t\t\t\tsegment.rto += kcp.rx_rto\n\t\t\t} else {\n\t\t\t\tsegment.rto += kcp.rx_rto / 2\n\t\t\t}\n\t\t\tsegment.fastack = 0\n\t\t\tsegment.resendts = current + segment.rto\n\t\t\tlostSegs++\n\t\t}\n\n\t\tif needsend {\n\t\t\tcurrent = currentMs()\n\t\t\tsegment.xmit++\n\t\t\tsegment.ts = current\n\t\t\tsegment.wnd = seg.wnd\n\t\t\tsegment.una = seg.una\n\n\t\t\tneed := IKCP_OVERHEAD + len(segment.data)\n\t\t\tmakeSpace(need)\n\t\t\tptr = segment.encode(ptr)\n\t\t\tcopy(ptr, segment.data)\n\t\t\tptr = ptr[len(segment.data):]\n\n\t\t\tif segment.xmit >= kcp.dead_link {\n\t\t\t\tkcp.state = 0xFFFFFFFF\n\t\t\t}\n\t\t}\n\n\t\t// get the nearest rto\n\t\tif rto := _itimediff(segment.resendts, current); rto > 0 && rto < minrto {\n\t\t\tminrto = rto\n\t\t}\n\t}\n\n\t// flash remain segments\n\tflushBuffer()\n\n\t// counter updates\n\tsum := lostSegs\n\tif lostSegs > 0 {\n\t\tatomic.AddUint64(&DefaultSnmp.LostSegs, lostSegs)\n\t}\n\tif fastRetransSegs > 0 {\n\t\tatomic.AddUint64(&DefaultSnmp.FastRetransSegs, fastRetransSegs)\n\t\tsum += fastRetransSegs\n\t}\n\tif earlyRetransSegs > 0 {\n\t\tatomic.AddUint64(&DefaultSnmp.EarlyRetransSegs, earlyRetransSegs)\n\t\tsum += earlyRetransSegs\n\t}\n\tif sum > 0 {\n\t\tatomic.AddUint64(&DefaultSnmp.RetransSegs, sum)\n\t}\n\n\t// cwnd update\n\tif kcp.nocwnd == 0 {\n\t\t// update ssthresh\n\t\t// rate halving, https://tools.ietf.org/html/rfc6937\n\t\tif change > 0 {\n\t\t\tinflight := kcp.snd_nxt - kcp.snd_una\n\t\t\tkcp.ssthresh = inflight / 2\n\t\t\tif kcp.ssthresh < IKCP_THRESH_MIN {\n\t\t\t\tkcp.ssthresh = IKCP_THRESH_MIN\n\t\t\t}\n\t\t\tkcp.cwnd = kcp.ssthresh + resent\n\t\t\tkcp.incr = kcp.cwnd * kcp.mss\n\t\t}\n\n\t\t// congestion control, https://tools.ietf.org/html/rfc5681\n\t\tif lostSegs > 0 {\n\t\t\tkcp.ssthresh = cwnd / 2\n\t\t\tif kcp.ssthresh < IKCP_THRESH_MIN {\n\t\t\t\tkcp.ssthresh = IKCP_THRESH_MIN\n\t\t\t}\n\t\t\tkcp.cwnd = 1\n\t\t\tkcp.incr = kcp.mss\n\t\t}\n\n\t\tif kcp.cwnd < 1 {\n\t\t\tkcp.cwnd = 1\n\t\t\tkcp.incr = kcp.mss\n\t\t}\n\t}\n\n\treturn uint32(minrto)\n}\n\n// (deprecated)\n//\n// Update updates state (call it repeatedly, every 10ms-100ms), or you can ask\n// ikcp_check when to call it again (without ikcp_input/_send calling).\n// 'current' - current timestamp in millisec.\nfunc (kcp *KCP) Update() {\n\tvar slap int32\n\n\tcurrent := currentMs()\n\tif kcp.updated == 0 {\n\t\tkcp.updated = 1\n\t\tkcp.ts_flush = current\n\t}\n\n\tslap = _itimediff(current, kcp.ts_flush)\n\n\tif slap >= 10000 || slap < -10000 {\n\t\tkcp.ts_flush = current\n\t\tslap = 0\n\t}\n\n\tif slap >= 0 {\n\t\tkcp.ts_flush += kcp.interval\n\t\tif _itimediff(current, kcp.ts_flush) >= 0 {\n\t\t\tkcp.ts_flush = current + kcp.interval\n\t\t}\n\t\tkcp.flush(false)\n\t}\n}\n\n// (deprecated)\n//\n// Check determines when should you invoke ikcp_update:\n// returns when you should invoke ikcp_update in millisec, if there\n// is no ikcp_input/_send calling. you can call ikcp_update in that\n// time, instead of call update repeatly.\n// Important to reduce unnacessary ikcp_update invoking. use it to\n// schedule ikcp_update (eg. implementing an epoll-like mechanism,\n// or optimize ikcp_update when handling massive kcp connections)\nfunc (kcp *KCP) Check() uint32 {\n\tcurrent := currentMs()\n\tts_flush := kcp.ts_flush\n\ttm_flush := int32(0x7fffffff)\n\ttm_packet := int32(0x7fffffff)\n\tminimal := uint32(0)\n\tif kcp.updated == 0 {\n\t\treturn current\n\t}\n\n\tif _itimediff(current, ts_flush) >= 10000 ||\n\t\t_itimediff(current, ts_flush) < -10000 {\n\t\tts_flush = current\n\t}\n\n\tif _itimediff(current, ts_flush) >= 0 {\n\t\treturn current\n\t}\n\n\ttm_flush = _itimediff(ts_flush, current)\n\n\tfor k := range kcp.snd_buf {\n\t\tseg := &kcp.snd_buf[k]\n\t\tdiff := _itimediff(seg.resendts, current)\n\t\tif diff <= 0 {\n\t\t\treturn current\n\t\t}\n\t\tif diff < tm_packet {\n\t\t\ttm_packet = diff\n\t\t}\n\t}\n\n\tminimal = uint32(tm_packet)\n\tif tm_packet >= tm_flush {\n\t\tminimal = uint32(tm_flush)\n\t}\n\tif minimal >= kcp.interval {\n\t\tminimal = kcp.interval\n\t}\n\n\treturn current + minimal\n}\n\n// SetMtu changes MTU size, default is 1400\nfunc (kcp *KCP) SetMtu(mtu int) int {\n\tif mtu < 50 || mtu < IKCP_OVERHEAD {\n\t\treturn -1\n\t}\n\n\tbuffer := make([]byte, mtu)\n\tif buffer == nil {\n\t\treturn -2\n\t}\n\n\tkcp.mtu = uint32(mtu)\n\tkcp.mss = kcp.mtu - IKCP_OVERHEAD\n\tkcp.buffer = buffer\n\treturn 0\n}\n\n// NoDelay options\n// fastest: ikcp_nodelay(kcp, 1, 20, 2, 1)\n// nodelay: 0:disable(default), 1:enable\n// interval: internal update timer interval in millisec, default is 100ms\n// resend: 0:disable fast resend(default), 1:enable fast resend\n// nc: 0:normal congestion control(default), 1:disable congestion control\nfunc (kcp *KCP) NoDelay(nodelay, interval, resend, nc int) int {\n\tif nodelay >= 0 {\n\t\tkcp.nodelay = uint32(nodelay)\n\t\tif nodelay != 0 {\n\t\t\tkcp.rx_minrto = IKCP_RTO_NDL\n\t\t} else {\n\t\t\tkcp.rx_minrto = IKCP_RTO_MIN\n\t\t}\n\t}\n\tif interval >= 0 {\n\t\tif interval > 5000 {\n\t\t\tinterval = 5000\n\t\t} else if interval < 10 {\n\t\t\tinterval = 10\n\t\t}\n\t\tkcp.interval = uint32(interval)\n\t}\n\tif resend >= 0 {\n\t\tkcp.fastresend = int32(resend)\n\t}\n\tif nc >= 0 {\n\t\tkcp.nocwnd = int32(nc)\n\t}\n\treturn 0\n}\n\n// WndSize sets maximum window size: sndwnd=32, rcvwnd=32 by default\nfunc (kcp *KCP) WndSize(sndwnd, rcvwnd int) int {\n\tif sndwnd > 0 {\n\t\tkcp.snd_wnd = uint32(sndwnd)\n\t}\n\tif rcvwnd > 0 {\n\t\tkcp.rcv_wnd = uint32(rcvwnd)\n\t}\n\treturn 0\n}\n\n// WaitSnd gets how many packet is waiting to be sent\nfunc (kcp *KCP) WaitSnd() int {\n\treturn len(kcp.snd_buf) + len(kcp.snd_queue)\n}\n\n// remove front n elements from queue\n// if the number of elements to remove is more than half of the size.\n// just shift the rear elements to front, otherwise just reslice q to q[n:]\n// then the cost of runtime.growslice can always be less than n/2\nfunc (kcp *KCP) remove_front(q []segment, n int) []segment {\n\tif n > cap(q)/2 {\n\t\tnewn := copy(q, q[n:])\n\t\treturn q[:newn]\n\t}\n\treturn q[n:]\n}\n\n// Release all cached outgoing segments\nfunc (kcp *KCP) ReleaseTX() {\n\tfor k := range kcp.snd_queue {\n\t\tif kcp.snd_queue[k].data != nil {\n\t\t\txmitBuf.Put(kcp.snd_queue[k].data)\n\t\t}\n\t}\n\tfor k := range kcp.snd_buf {\n\t\tif kcp.snd_buf[k].data != nil {\n\t\t\txmitBuf.Put(kcp.snd_buf[k].data)\n\t\t}\n\t}\n\tkcp.snd_queue = nil\n\tkcp.snd_buf = nil\n}\n"
        },
        {
          "name": "kcp_test.go",
          "type": "blob",
          "size": 4.03125,
          "content": "// The MIT License (MIT)\n//\n// Copyright (c) 2015 xtaci\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.\n\npackage kcp\n\nimport (\n\t\"io\"\n\t\"net\"\n\t\"sync\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/xtaci/lossyconn\"\n)\n\nconst repeat = 16\n\nfunc TestLossyConn1(t *testing.T) {\n\tt.Log(\"testing loss rate 10%, rtt 200ms\")\n\tt.Log(\"testing link with nodelay parameters:1 10 2 1\")\n\tclient, err := lossyconn.NewLossyConn(0.1, 100)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tserver, err := lossyconn.NewLossyConn(0.1, 100)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\ttestlink(t, client, server, 1, 10, 2, 1)\n}\n\nfunc TestLossyConn2(t *testing.T) {\n\tt.Log(\"testing loss rate 20%, rtt 200ms\")\n\tt.Log(\"testing link with nodelay parameters:1 10 2 1\")\n\tclient, err := lossyconn.NewLossyConn(0.2, 100)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tserver, err := lossyconn.NewLossyConn(0.2, 100)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\ttestlink(t, client, server, 1, 10, 2, 1)\n}\n\nfunc TestLossyConn3(t *testing.T) {\n\tt.Log(\"testing loss rate 30%, rtt 200ms\")\n\tt.Log(\"testing link with nodelay parameters:1 10 2 1\")\n\tclient, err := lossyconn.NewLossyConn(0.3, 100)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tserver, err := lossyconn.NewLossyConn(0.3, 100)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\ttestlink(t, client, server, 1, 10, 2, 1)\n}\n\nfunc TestLossyConn4(t *testing.T) {\n\tt.Log(\"testing loss rate 10%, rtt 200ms\")\n\tt.Log(\"testing link with nodelay parameters:1 10 2 0\")\n\tclient, err := lossyconn.NewLossyConn(0.1, 100)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tserver, err := lossyconn.NewLossyConn(0.1, 100)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\ttestlink(t, client, server, 1, 10, 2, 0)\n}\n\nfunc testlink(t *testing.T, client *lossyconn.LossyConn, server *lossyconn.LossyConn, nodelay, interval, resend, nc int) {\n\tt.Log(\"testing with nodelay parameters:\", nodelay, interval, resend, nc)\n\tsess, _ := NewConn2(server.LocalAddr(), nil, 0, 0, client)\n\tlistener, _ := ServeConn(nil, 0, 0, server)\n\techoServer := func(l *Listener) {\n\t\tfor {\n\t\t\tconn, err := l.AcceptKCP()\n\t\t\tif err != nil {\n\t\t\t\treturn\n\t\t\t}\n\t\t\tgo func() {\n\t\t\t\tconn.SetNoDelay(nodelay, interval, resend, nc)\n\t\t\t\tbuf := make([]byte, 65536)\n\t\t\t\tfor {\n\t\t\t\t\tn, err := conn.Read(buf)\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t\tconn.Write(buf[:n])\n\t\t\t\t}\n\t\t\t}()\n\t\t}\n\t}\n\n\techoTester := func(s *UDPSession, raddr net.Addr) {\n\t\ts.SetNoDelay(nodelay, interval, resend, nc)\n\t\tbuf := make([]byte, 64)\n\t\tvar rtt time.Duration\n\t\tfor i := 0; i < repeat; i++ {\n\t\t\tstart := time.Now()\n\t\t\ts.Write(buf)\n\t\t\tio.ReadFull(s, buf)\n\t\t\trtt += time.Since(start)\n\t\t}\n\n\t\tt.Log(\"client:\", client)\n\t\tt.Log(\"server:\", server)\n\t\tt.Log(\"avg rtt:\", rtt/repeat)\n\t\tt.Logf(\"total time: %v for %v round trip:\", rtt, repeat)\n\t}\n\n\tgo echoServer(listener)\n\techoTester(sess, server.LocalAddr())\n}\n\nfunc BenchmarkFlush(b *testing.B) {\n\tkcp := NewKCP(1, func(buf []byte, size int) {})\n\tkcp.snd_buf = make([]segment, 1024)\n\tfor k := range kcp.snd_buf {\n\t\tkcp.snd_buf[k].xmit = 1\n\t\tkcp.snd_buf[k].resendts = currentMs() + 10000\n\t}\n\tb.ResetTimer()\n\tb.ReportAllocs()\n\tvar mu sync.Mutex\n\tfor i := 0; i < b.N; i++ {\n\t\tmu.Lock()\n\t\tkcp.flush(false)\n\t\tmu.Unlock()\n\t}\n}\n"
        },
        {
          "name": "pkg.go",
          "type": "blob",
          "size": 0.3427734375,
          "content": "// Package kcp-go is a Reliable-UDP library for golang.\n//\n// This library intents to provide a smooth, resilient, ordered,\n// error-checked and anonymous delivery of streams over UDP packets.\n//\n// The interfaces of this package aims to be compatible with\n// net.Conn in standard library, but offers powerful features for advanced users.\npackage kcp\n"
        },
        {
          "name": "readloop.go",
          "type": "blob",
          "size": 2.0615234375,
          "content": "// The MIT License (MIT)\n//\n// Copyright (c) 2015 xtaci\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.\n\npackage kcp\n\nimport (\n\t\"sync/atomic\"\n\n\t\"github.com/pkg/errors\"\n)\n\n// defaultReadLoop is the standard procedure for reading from a connection\nfunc (s *UDPSession) defaultReadLoop() {\n\tbuf := make([]byte, mtuLimit)\n\tvar src string\n\tfor {\n\t\tif n, addr, err := s.conn.ReadFrom(buf); err == nil {\n\t\t\tif s.isClosed() {\n\t\t\t\treturn\n\t\t\t}\n\t\t\t// make sure the packet is from the same source\n\t\t\tif src == \"\" { // set source address\n\t\t\t\tsrc = addr.String()\n\t\t\t} else if addr.String() != src {\n\t\t\t\tatomic.AddUint64(&DefaultSnmp.InErrs, 1)\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\ts.packetInput(buf[:n])\n\t\t} else {\n\t\t\ts.notifyReadError(errors.WithStack(err))\n\t\t\treturn\n\t\t}\n\t}\n}\n\n// defaultReadLoop is the standard procedure for reading and accepting connections on a listener\nfunc (l *Listener) defaultMonitor() {\n\tbuf := make([]byte, mtuLimit)\n\tfor {\n\t\tif n, from, err := l.conn.ReadFrom(buf); err == nil {\n\t\t\tl.packetInput(buf[:n], from)\n\t\t} else {\n\t\t\tl.notifyReadError(errors.WithStack(err))\n\t\t\treturn\n\t\t}\n\t}\n}\n"
        },
        {
          "name": "readloop_generic.go",
          "type": "blob",
          "size": 1.2451171875,
          "content": "// The MIT License (MIT)\n//\n// Copyright (c) 2015 xtaci\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.\n\n//go:build !linux\n\npackage kcp\n\nfunc (s *UDPSession) readLoop() {\n\ts.defaultReadLoop()\n}\n\nfunc (l *Listener) monitor() {\n\tl.defaultMonitor()\n}\n"
        },
        {
          "name": "readloop_linux.go",
          "type": "blob",
          "size": 3.6484375,
          "content": "// The MIT License (MIT)\n//\n// Copyright (c) 2015 xtaci\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.\n\n//go:build linux\n// +build linux\n\npackage kcp\n\nimport (\n\t\"net\"\n\t\"os\"\n\t\"sync/atomic\"\n\n\t\"github.com/pkg/errors\"\n\t\"golang.org/x/net/ipv4\"\n\t\"golang.org/x/net/ipv6\"\n)\n\n// readLoop is the optimized version of readLoop for linux utilizing recvmmsg syscall\nfunc (s *UDPSession) readLoop() {\n\t// default version\n\tif s.xconn == nil {\n\t\ts.defaultReadLoop()\n\t\treturn\n\t}\n\n\t// x/net version\n\tvar src string\n\tmsgs := make([]ipv4.Message, batchSize)\n\tfor k := range msgs {\n\t\tmsgs[k].Buffers = [][]byte{make([]byte, mtuLimit)}\n\t}\n\n\tfor {\n\t\tif count, err := s.xconn.ReadBatch(msgs, 0); err == nil {\n\t\t\tif s.isClosed() {\n\t\t\t\treturn\n\t\t\t}\n\t\t\tfor i := 0; i < count; i++ {\n\t\t\t\tmsg := &msgs[i]\n\t\t\t\t// make sure the packet is from the same source\n\t\t\t\tif src == \"\" { // set source address if nil\n\t\t\t\t\tsrc = msg.Addr.String()\n\t\t\t\t} else if msg.Addr.String() != src {\n\t\t\t\t\tatomic.AddUint64(&DefaultSnmp.InErrs, 1)\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\n\t\t\t\t// source and size has validated\n\t\t\t\ts.packetInput(msg.Buffers[0][:msg.N])\n\t\t\t}\n\t\t} else {\n\t\t\t// compatibility issue:\n\t\t\t// for linux kernel<=2.6.32, support for sendmmsg is not available\n\t\t\t// an error of type os.SyscallError will be returned\n\t\t\tif operr, ok := err.(*net.OpError); ok {\n\t\t\t\tif se, ok := operr.Err.(*os.SyscallError); ok {\n\t\t\t\t\tif se.Syscall == \"recvmmsg\" {\n\t\t\t\t\t\ts.defaultReadLoop()\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\ts.notifyReadError(errors.WithStack(err))\n\t\t\treturn\n\t\t}\n\t}\n}\n\n// monitor is the optimized version of monitor for linux utilizing recvmmsg syscall\nfunc (l *Listener) monitor() {\n\tvar xconn batchConn\n\tif _, ok := l.conn.(*net.UDPConn); ok {\n\t\taddr, err := net.ResolveUDPAddr(\"udp\", l.conn.LocalAddr().String())\n\t\tif err == nil {\n\t\t\tif addr.IP.To4() != nil {\n\t\t\t\txconn = ipv4.NewPacketConn(l.conn)\n\t\t\t} else {\n\t\t\t\txconn = ipv6.NewPacketConn(l.conn)\n\t\t\t}\n\t\t}\n\t}\n\n\t// default version\n\tif xconn == nil {\n\t\tl.defaultMonitor()\n\t\treturn\n\t}\n\n\t// x/net version\n\tmsgs := make([]ipv4.Message, batchSize)\n\tfor k := range msgs {\n\t\tmsgs[k].Buffers = [][]byte{make([]byte, mtuLimit)}\n\t}\n\n\tfor {\n\t\tif count, err := xconn.ReadBatch(msgs, 0); err == nil {\n\t\t\tfor i := 0; i < count; i++ {\n\t\t\t\tmsg := &msgs[i]\n\t\t\t\tl.packetInput(msg.Buffers[0][:msg.N], msg.Addr)\n\t\t\t}\n\t\t} else {\n\t\t\t// compatibility issue:\n\t\t\t// for linux kernel<=2.6.32, support for sendmmsg is not available\n\t\t\t// an error of type os.SyscallError will be returned\n\t\t\tif operr, ok := err.(*net.OpError); ok {\n\t\t\t\tif se, ok := operr.Err.(*os.SyscallError); ok {\n\t\t\t\t\tif se.Syscall == \"recvmmsg\" {\n\t\t\t\t\t\tl.defaultMonitor()\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tl.notifyReadError(errors.WithStack(err))\n\t\t\treturn\n\t\t}\n\t}\n}\n"
        },
        {
          "name": "sess.go",
          "type": "blob",
          "size": 33.962890625,
          "content": "// The MIT License (MIT)\n//\n// # Copyright (c) 2015 xtaci\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.\n\n// [THE GENERALIZED DATA PIPELINE FOR KCP-GO]\n//\n// Outgoing Data Pipeline:                        Incoming Data Pipeline:\n// Stream          (Input Data)                   Packet Network  (Network Interface Card)\n//   |                                               |\n//   v                                               v\n// KCP Output      (Reliable Transport Layer)     Reader/Listener (Reception Queue)\n//   |                                               |\n//   v                                               v\n// FEC Encoding    (Forward Error Correction)     Decryption      (Data Security)\n//   |                                               |\n//   v                                               v\n// CRC32 Checksum  (Error Detection)              CRC32 Checksum  (Error Detection)\n//   |                                               |\n//   v                                               v\n// Encryption      (Data Security)                FEC Decoding    (Forward Error Correction)\n//   |                                               |\n//   v                                               v\n// TxQueue         (Transmission Queue)           KCP Input       (Reliable Transport Layer)\n//   |                                               |\n//   v                                               v\n// Packet Network  (Network Transmission)         Stream          (Input Data)\n\npackage kcp\n\nimport (\n\t\"crypto/rand\"\n\t\"encoding/binary\"\n\t\"hash/crc32\"\n\t\"io\"\n\t\"net\"\n\t\"sync\"\n\t\"sync/atomic\"\n\t\"time\"\n\n\t\"github.com/pkg/errors\"\n\t\"golang.org/x/net/ipv4\"\n\t\"golang.org/x/net/ipv6\"\n)\n\nconst (\n\t// 16-bytes nonce for each packet\n\tnonceSize = 16\n\n\t// 4-bytes packet checksum\n\tcrcSize = 4\n\n\t// overall crypto header size\n\tcryptHeaderSize = nonceSize + crcSize\n\n\t// maximum packet size\n\tmtuLimit = 1500\n\n\t// accept backlog\n\tacceptBacklog = 128\n\n\t// max latency for consecutive FEC encoding, in millisecond\n\tmaxFECEncodeLatency = 500\n)\n\nvar (\n\terrInvalidOperation = errors.New(\"invalid operation\")\n\terrTimeout          = errors.New(\"timeout\")\n\terrNotOwner         = errors.New(\"not the owner of this connection\")\n)\n\nvar (\n\t// a system-wide packet buffer shared among sending, receiving and FEC\n\t// to mitigate high-frequency memory allocation for packets, bytes from xmitBuf\n\t// is aligned to 64bit\n\txmitBuf sync.Pool\n)\n\nfunc init() {\n\txmitBuf.New = func() interface{} {\n\t\treturn make([]byte, mtuLimit)\n\t}\n}\n\ntype (\n\t// UDPSession defines a KCP session implemented by UDP\n\tUDPSession struct {\n\t\tconn    net.PacketConn // the underlying packet connection\n\t\townConn bool           // true if we created conn internally, false if provided by caller\n\t\tkcp     *KCP           // KCP ARQ protocol\n\t\tl       *Listener      // pointing to the Listener object if it's been accepted by a Listener\n\t\tblock   BlockCrypt     // block encryption object\n\n\t\t// kcp receiving is based on packets\n\t\t// recvbuf turns packets into stream\n\t\trecvbuf []byte\n\t\tbufptr  []byte\n\n\t\t// FEC codec\n\t\tfecDecoder *fecDecoder\n\t\tfecEncoder *fecEncoder\n\n\t\t// settings\n\t\tremote     net.Addr  // remote peer address\n\t\trd         time.Time // read deadline\n\t\twd         time.Time // write deadline\n\t\theaderSize int       // the header size additional to a KCP frame\n\t\tackNoDelay bool      // send ack immediately for each incoming packet(testing purpose)\n\t\twriteDelay bool      // delay kcp.flush() for Write() for bulk transfer\n\t\tdup        int       // duplicate udp packets(testing purpose)\n\n\t\t// notifications\n\t\tdie          chan struct{} // notify current session has Closed\n\t\tdieOnce      sync.Once\n\t\tchReadEvent  chan struct{} // notify Read() can be called without blocking\n\t\tchWriteEvent chan struct{} // notify Write() can be called without blocking\n\n\t\t// socket error handling\n\t\tsocketReadError      atomic.Value\n\t\tsocketWriteError     atomic.Value\n\t\tchSocketReadError    chan struct{}\n\t\tchSocketWriteError   chan struct{}\n\t\tsocketReadErrorOnce  sync.Once\n\t\tsocketWriteErrorOnce sync.Once\n\n\t\t// nonce generator\n\t\tnonce Entropy\n\n\t\t// packets waiting to be sent on wire\n\t\tchPostProcessing chan []byte\n\n\t\txconn           batchConn // for x/net\n\t\txconnWriteError error\n\n\t\tmu sync.Mutex\n\t}\n\n\tsetReadBuffer interface {\n\t\tSetReadBuffer(bytes int) error\n\t}\n\n\tsetWriteBuffer interface {\n\t\tSetWriteBuffer(bytes int) error\n\t}\n\n\tsetDSCP interface {\n\t\tSetDSCP(int) error\n\t}\n)\n\n// newUDPSession create a new udp session for client or server\nfunc newUDPSession(conv uint32, dataShards, parityShards int, l *Listener, conn net.PacketConn, ownConn bool, remote net.Addr, block BlockCrypt) *UDPSession {\n\tsess := new(UDPSession)\n\tsess.die = make(chan struct{})\n\tsess.nonce = new(nonceAES128)\n\tsess.nonce.Init()\n\tsess.chReadEvent = make(chan struct{}, 1)\n\tsess.chWriteEvent = make(chan struct{}, 1)\n\tsess.chSocketReadError = make(chan struct{})\n\tsess.chSocketWriteError = make(chan struct{})\n\tsess.chPostProcessing = make(chan []byte, acceptBacklog)\n\tsess.remote = remote\n\tsess.conn = conn\n\tsess.ownConn = ownConn\n\tsess.l = l\n\tsess.block = block\n\tsess.recvbuf = make([]byte, mtuLimit)\n\n\t// cast to writebatch conn\n\tif _, ok := conn.(*net.UDPConn); ok {\n\t\taddr, err := net.ResolveUDPAddr(\"udp\", conn.LocalAddr().String())\n\t\tif err == nil {\n\t\t\tif addr.IP.To4() != nil {\n\t\t\t\tsess.xconn = ipv4.NewPacketConn(conn)\n\t\t\t} else {\n\t\t\t\tsess.xconn = ipv6.NewPacketConn(conn)\n\t\t\t}\n\t\t}\n\t}\n\n\t// FEC codec initialization\n\tsess.fecDecoder = newFECDecoder(dataShards, parityShards)\n\tif sess.block != nil {\n\t\tsess.fecEncoder = newFECEncoder(dataShards, parityShards, cryptHeaderSize)\n\t} else {\n\t\tsess.fecEncoder = newFECEncoder(dataShards, parityShards, 0)\n\t}\n\n\t// calculate additional header size introduced by FEC and encryption\n\tif sess.block != nil {\n\t\tsess.headerSize += cryptHeaderSize\n\t}\n\tif sess.fecEncoder != nil {\n\t\tsess.headerSize += fecHeaderSizePlus2\n\t}\n\n\tsess.kcp = NewKCP(conv, func(buf []byte, size int) {\n\t\t// A basic check for the minimum packet size\n\t\tif size >= IKCP_OVERHEAD {\n\t\t\t// make a copy\n\t\t\tbts := xmitBuf.Get().([]byte)[:size+sess.headerSize]\n\t\t\t// copy the data to a new buffer, and reserve header space\n\t\t\tcopy(bts[sess.headerSize:], buf)\n\n\t\t\t// delivery to post processing\n\t\t\tselect {\n\t\t\tcase sess.chPostProcessing <- bts:\n\t\t\tcase <-sess.die:\n\t\t\t\treturn\n\t\t\t}\n\n\t\t}\n\t})\n\n\t// create post-processing goroutine\n\tgo sess.postProcess()\n\n\tif sess.l == nil { // it's a client connection\n\t\tgo sess.readLoop()\n\t\tatomic.AddUint64(&DefaultSnmp.ActiveOpens, 1)\n\t} else {\n\t\tatomic.AddUint64(&DefaultSnmp.PassiveOpens, 1)\n\t}\n\n\t// start per-session updater\n\tSystemTimedSched.Put(sess.update, time.Now())\n\n\tcurrestab := atomic.AddUint64(&DefaultSnmp.CurrEstab, 1)\n\tmaxconn := atomic.LoadUint64(&DefaultSnmp.MaxConn)\n\tif currestab > maxconn {\n\t\tatomic.CompareAndSwapUint64(&DefaultSnmp.MaxConn, maxconn, currestab)\n\t}\n\n\treturn sess\n}\n\n// Read implements net.Conn\nfunc (s *UDPSession) Read(b []byte) (n int, err error) {\nRESET_TIMER:\n\tvar timeout *time.Timer\n\t// deadline for current reading operation\n\tvar c <-chan time.Time\n\tif !s.rd.IsZero() {\n\t\tdelay := time.Until(s.rd)\n\t\ttimeout = time.NewTimer(delay)\n\t\tc = timeout.C\n\t\tdefer timeout.Stop()\n\t}\n\n\tfor {\n\t\ts.mu.Lock()\n\t\t// bufptr points to the current position of recvbuf,\n\t\t// if previous 'b' is insufficient to accommodate the data, the\n\t\t// remaining data will be stored in bufptr for next read.\n\t\tif len(s.bufptr) > 0 {\n\t\t\tn = copy(b, s.bufptr)\n\t\t\ts.bufptr = s.bufptr[n:]\n\t\t\ts.mu.Unlock()\n\t\t\tatomic.AddUint64(&DefaultSnmp.BytesReceived, uint64(n))\n\t\t\treturn n, nil\n\t\t}\n\n\t\tif size := s.kcp.PeekSize(); size > 0 { // peek data size from kcp\n\t\t\t// if 'b' is large enough to accommodate the data, read directly\n\t\t\t// from kcp.recv() to 'b', like 'DMA'.\n\t\t\tif len(b) >= size {\n\t\t\t\ts.kcp.Recv(b)\n\t\t\t\ts.mu.Unlock()\n\t\t\t\tatomic.AddUint64(&DefaultSnmp.BytesReceived, uint64(size))\n\t\t\t\treturn size, nil\n\t\t\t}\n\n\t\t\t// otherwise, read to recvbuf first, then copy to 'b'.\n\t\t\t// dynamically adjust the buffer size to the maximum of 'packet size' when necessary.\n\t\t\tif cap(s.recvbuf) < size {\n\t\t\t\t// usually recvbuf has a size of maximum packet size\n\t\t\t\ts.recvbuf = make([]byte, size)\n\t\t\t}\n\n\t\t\t// resize the length of recvbuf to correspond to data size\n\t\t\ts.recvbuf = s.recvbuf[:size]\n\t\t\ts.kcp.Recv(s.recvbuf)    // read data to recvbuf first\n\t\t\tn = copy(b, s.recvbuf)   // then copy bytes to 'b' as many as possible\n\t\t\ts.bufptr = s.recvbuf[n:] // pointer update\n\n\t\t\ts.mu.Unlock()\n\t\t\tatomic.AddUint64(&DefaultSnmp.BytesReceived, uint64(n))\n\t\t\treturn n, nil\n\t\t}\n\n\t\ts.mu.Unlock()\n\n\t\t// if it runs here, that means we have to block the call, and wait until the\n\t\t// next data packet arrives.\n\t\tselect {\n\t\tcase <-s.chReadEvent:\n\t\t\tif timeout != nil {\n\t\t\t\ttimeout.Stop()\n\t\t\t\tgoto RESET_TIMER\n\t\t\t}\n\t\tcase <-c:\n\t\t\treturn 0, errors.WithStack(errTimeout)\n\t\tcase <-s.chSocketReadError:\n\t\t\treturn 0, s.socketReadError.Load().(error)\n\t\tcase <-s.die:\n\t\t\treturn 0, errors.WithStack(io.ErrClosedPipe)\n\t\t}\n\t}\n}\n\n// Write implements net.Conn\nfunc (s *UDPSession) Write(b []byte) (n int, err error) { return s.WriteBuffers([][]byte{b}) }\n\n// WriteBuffers write a vector of byte slices to the underlying connection\nfunc (s *UDPSession) WriteBuffers(v [][]byte) (n int, err error) {\nRESET_TIMER:\n\tvar timeout *time.Timer\n\tvar c <-chan time.Time\n\tif !s.wd.IsZero() {\n\t\tdelay := time.Until(s.wd)\n\t\ttimeout = time.NewTimer(delay)\n\t\tc = timeout.C\n\t\tdefer timeout.Stop()\n\t}\n\n\tfor {\n\t\t// check for connection close and socket error\n\t\tselect {\n\t\tcase <-s.chSocketWriteError:\n\t\t\treturn 0, s.socketWriteError.Load().(error)\n\t\tcase <-s.die:\n\t\t\treturn 0, errors.WithStack(io.ErrClosedPipe)\n\t\tdefault:\n\t\t}\n\n\t\ts.mu.Lock()\n\n\t\t// make sure write do not overflow the max sliding window on both side\n\t\twaitsnd := s.kcp.WaitSnd()\n\t\tif waitsnd < int(s.kcp.snd_wnd) && waitsnd < int(s.kcp.rmt_wnd) {\n\t\t\t// transmit all data sequentially, make sure every packet size is within 'mss'\n\t\t\tfor _, b := range v {\n\t\t\t\tn += len(b)\n\t\t\t\t// handle each slice for packet splitting\n\t\t\t\tfor {\n\t\t\t\t\tif len(b) <= int(s.kcp.mss) {\n\t\t\t\t\t\ts.kcp.Send(b)\n\t\t\t\t\t\tbreak\n\t\t\t\t\t} else {\n\t\t\t\t\t\ts.kcp.Send(b[:s.kcp.mss])\n\t\t\t\t\t\tb = b[s.kcp.mss:]\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\twaitsnd = s.kcp.WaitSnd()\n\t\t\tif waitsnd >= int(s.kcp.snd_wnd) || waitsnd >= int(s.kcp.rmt_wnd) || !s.writeDelay {\n\t\t\t\t// put the packets on wire immediately if the inflight window is full\n\t\t\t\t// or if we've specified write no delay(NO merging of outgoing bytes)\n\t\t\t\t// we don't have to wait until the periodical update() procedure uncorks.\n\t\t\t\ts.kcp.flush(false)\n\t\t\t}\n\t\t\ts.mu.Unlock()\n\t\t\tatomic.AddUint64(&DefaultSnmp.BytesSent, uint64(n))\n\t\t\treturn n, nil\n\t\t}\n\n\t\ts.mu.Unlock()\n\n\t\t// if it runs here, that means we have to block the call, and wait until the\n\t\t// transmit buffer to become available again.\n\t\tselect {\n\t\tcase <-s.chWriteEvent:\n\t\t\tif timeout != nil {\n\t\t\t\ttimeout.Stop()\n\t\t\t\tgoto RESET_TIMER\n\t\t\t}\n\t\tcase <-c:\n\t\t\treturn 0, errors.WithStack(errTimeout)\n\t\tcase <-s.chSocketWriteError:\n\t\t\treturn 0, s.socketWriteError.Load().(error)\n\t\tcase <-s.die:\n\t\t\treturn 0, errors.WithStack(io.ErrClosedPipe)\n\t\t}\n\t}\n}\n\nfunc (s *UDPSession) isClosed() bool {\n\tselect {\n\tcase <-s.die:\n\t\treturn true\n\tdefault:\n\t\treturn false\n\t}\n}\n\n// Close closes the connection.\nfunc (s *UDPSession) Close() error {\n\tvar once bool\n\ts.dieOnce.Do(func() {\n\t\tclose(s.die)\n\t\tonce = true\n\t})\n\n\tif once {\n\t\tatomic.AddUint64(&DefaultSnmp.CurrEstab, ^uint64(0))\n\n\t\t// try best to send all queued messages especially the data in txqueue\n\t\ts.mu.Lock()\n\t\ts.kcp.flush(false)\n\n\t\t// release pending segments to recyle memory\n\t\ts.kcp.ReleaseTX()\n\t\tif s.fecDecoder != nil {\n\t\t\ts.fecDecoder.release()\n\t\t}\n\t\ts.mu.Unlock()\n\n\t\tif s.l != nil { // belongs to listener\n\t\t\ts.l.closeSession(s.remote)\n\t\t\treturn nil\n\t\t} else if s.ownConn { // client socket close\n\t\t\treturn s.conn.Close()\n\t\t} else {\n\t\t\treturn nil\n\t\t}\n\t} else {\n\t\treturn errors.WithStack(io.ErrClosedPipe)\n\t}\n}\n\n// LocalAddr returns the local network address. The Addr returned is shared by all invocations of LocalAddr, so do not modify it.\nfunc (s *UDPSession) LocalAddr() net.Addr { return s.conn.LocalAddr() }\n\n// RemoteAddr returns the remote network address. The Addr returned is shared by all invocations of RemoteAddr, so do not modify it.\nfunc (s *UDPSession) RemoteAddr() net.Addr { return s.remote }\n\n// SetDeadline sets the deadline associated with the listener. A zero time value disables the deadline.\nfunc (s *UDPSession) SetDeadline(t time.Time) error {\n\ts.mu.Lock()\n\ts.rd = t\n\ts.wd = t\n\ts.mu.Unlock()\n\ts.notifyReadEvent()\n\ts.notifyWriteEvent()\n\treturn nil\n}\n\n// SetReadDeadline implements the Conn SetReadDeadline method.\nfunc (s *UDPSession) SetReadDeadline(t time.Time) error {\n\ts.mu.Lock()\n\ts.rd = t\n\ts.mu.Unlock()\n\ts.notifyReadEvent()\n\treturn nil\n}\n\n// SetWriteDeadline implements the Conn SetWriteDeadline method.\nfunc (s *UDPSession) SetWriteDeadline(t time.Time) error {\n\ts.mu.Lock()\n\ts.wd = t\n\ts.mu.Unlock()\n\ts.notifyWriteEvent()\n\treturn nil\n}\n\n// SetWriteDelay delays write for bulk transfer until the next update interval\nfunc (s *UDPSession) SetWriteDelay(delay bool) {\n\ts.mu.Lock()\n\tdefer s.mu.Unlock()\n\ts.writeDelay = delay\n}\n\n// SetWindowSize set maximum window size\nfunc (s *UDPSession) SetWindowSize(sndwnd, rcvwnd int) {\n\ts.mu.Lock()\n\tdefer s.mu.Unlock()\n\ts.kcp.WndSize(sndwnd, rcvwnd)\n}\n\n// SetMtu sets the maximum transmission unit(not including UDP header)\nfunc (s *UDPSession) SetMtu(mtu int) bool {\n\tif mtu > mtuLimit {\n\t\treturn false\n\t}\n\n\ts.mu.Lock()\n\tdefer s.mu.Unlock()\n\ts.kcp.SetMtu(mtu)\n\treturn true\n}\n\n// Deprecated: toggles the stream mode on/off\nfunc (s *UDPSession) SetStreamMode(enable bool) {\n\ts.mu.Lock()\n\tdefer s.mu.Unlock()\n\tif enable {\n\t\ts.kcp.stream = 1\n\t} else {\n\t\ts.kcp.stream = 0\n\t}\n}\n\n// SetACKNoDelay changes ack flush option, set true to flush ack immediately,\nfunc (s *UDPSession) SetACKNoDelay(nodelay bool) {\n\ts.mu.Lock()\n\tdefer s.mu.Unlock()\n\ts.ackNoDelay = nodelay\n}\n\n// (deprecated)\n//\n// SetDUP duplicates udp packets for kcp output.\nfunc (s *UDPSession) SetDUP(dup int) {\n\ts.mu.Lock()\n\tdefer s.mu.Unlock()\n\ts.dup = dup\n}\n\n// SetNoDelay calls nodelay() of kcp\n// https://github.com/skywind3000/kcp/blob/master/README.en.md#protocol-configuration\nfunc (s *UDPSession) SetNoDelay(nodelay, interval, resend, nc int) {\n\ts.mu.Lock()\n\tdefer s.mu.Unlock()\n\ts.kcp.NoDelay(nodelay, interval, resend, nc)\n}\n\n// SetDSCP sets the 6bit DSCP field in IPv4 header, or 8bit Traffic Class in IPv6 header.\n//\n// if the underlying connection has implemented `func SetDSCP(int) error`, SetDSCP() will invoke\n// this function instead.\n//\n// It has no effect if it's accepted from Listener.\nfunc (s *UDPSession) SetDSCP(dscp int) error {\n\ts.mu.Lock()\n\tdefer s.mu.Unlock()\n\tif s.l != nil {\n\t\treturn errInvalidOperation\n\t}\n\n\t// interface enabled\n\tif ts, ok := s.conn.(setDSCP); ok {\n\t\treturn ts.SetDSCP(dscp)\n\t}\n\n\tif nc, ok := s.conn.(net.Conn); ok {\n\t\tvar succeed bool\n\t\tif err := ipv4.NewConn(nc).SetTOS(dscp << 2); err == nil {\n\t\t\tsucceed = true\n\t\t}\n\t\tif err := ipv6.NewConn(nc).SetTrafficClass(dscp); err == nil {\n\t\t\tsucceed = true\n\t\t}\n\n\t\tif succeed {\n\t\t\treturn nil\n\t\t}\n\t}\n\treturn errInvalidOperation\n}\n\n// SetReadBuffer sets the socket read buffer, no effect if it's accepted from Listener\nfunc (s *UDPSession) SetReadBuffer(bytes int) error {\n\ts.mu.Lock()\n\tdefer s.mu.Unlock()\n\tif s.l == nil {\n\t\tif nc, ok := s.conn.(setReadBuffer); ok {\n\t\t\treturn nc.SetReadBuffer(bytes)\n\t\t}\n\t}\n\treturn errInvalidOperation\n}\n\n// SetWriteBuffer sets the socket write buffer, no effect if it's accepted from Listener\nfunc (s *UDPSession) SetWriteBuffer(bytes int) error {\n\ts.mu.Lock()\n\tdefer s.mu.Unlock()\n\tif s.l == nil {\n\t\tif nc, ok := s.conn.(setWriteBuffer); ok {\n\t\t\treturn nc.SetWriteBuffer(bytes)\n\t\t}\n\t}\n\treturn errInvalidOperation\n}\n\n// Control applys a procedure to the underly socket fd.\n// CAUTION: BE VERY CAREFUL TO USE THIS FUNCTION, YOU MAY BREAK THE PROTOCOL.\nfunc (s *UDPSession) Control(f func(conn net.PacketConn) error) error {\n\tif !s.ownConn {\n\t\treturn errNotOwner\n\t}\n\n\ts.mu.Lock()\n\tdefer s.mu.Unlock()\n\treturn f(s.conn)\n}\n\n// a goroutine to handle post processing of kcp and make the critical section smaller\n// pipeline for outgoing packets (from ARQ to network)\n//\n//\tKCP output -> FEC encoding -> CRC32 integrity -> Encryption -> TxQueue\nfunc (s *UDPSession) postProcess() {\n\ttxqueue := make([]ipv4.Message, 0, acceptBacklog)\n\tchCork := make(chan struct{}, 1)\n\tchDie := s.die\n\n\tfor {\n\t\tselect {\n\t\tcase buf := <-s.chPostProcessing: // dequeue from post processing\n\t\t\tvar ecc [][]byte\n\n\t\t\t// 1. FEC encoding\n\t\t\tif s.fecEncoder != nil {\n\t\t\t\tecc = s.fecEncoder.encode(buf, maxFECEncodeLatency)\n\t\t\t}\n\n\t\t\t// 2&3. crc32 & encryption\n\t\t\tif s.block != nil {\n\t\t\t\ts.nonce.Fill(buf[:nonceSize])\n\t\t\t\tchecksum := crc32.ChecksumIEEE(buf[cryptHeaderSize:])\n\t\t\t\tbinary.LittleEndian.PutUint32(buf[nonceSize:], checksum)\n\t\t\t\ts.block.Encrypt(buf, buf)\n\n\t\t\t\tfor k := range ecc {\n\t\t\t\t\ts.nonce.Fill(ecc[k][:nonceSize])\n\t\t\t\t\tchecksum := crc32.ChecksumIEEE(ecc[k][cryptHeaderSize:])\n\t\t\t\t\tbinary.LittleEndian.PutUint32(ecc[k][nonceSize:], checksum)\n\t\t\t\t\ts.block.Encrypt(ecc[k], ecc[k])\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// 4. TxQueue\n\t\t\tvar msg ipv4.Message\n\t\t\tmsg.Addr = s.remote\n\n\t\t\t// original copy, move buf to txqueue directly\n\t\t\tmsg.Buffers = [][]byte{buf}\n\t\t\ttxqueue = append(txqueue, msg)\n\n\t\t\t// dup copies for testing if set\n\t\t\tfor i := 0; i < s.dup; i++ {\n\t\t\t\tbts := xmitBuf.Get().([]byte)[:len(buf)]\n\t\t\t\tcopy(bts, buf)\n\t\t\t\tmsg.Buffers = [][]byte{bts}\n\t\t\t\ttxqueue = append(txqueue, msg)\n\t\t\t}\n\n\t\t\t// parity\n\t\t\tfor k := range ecc {\n\t\t\t\tbts := xmitBuf.Get().([]byte)[:len(ecc[k])]\n\t\t\t\tcopy(bts, ecc[k])\n\t\t\t\tmsg.Buffers = [][]byte{bts}\n\t\t\t\ttxqueue = append(txqueue, msg)\n\t\t\t}\n\n\t\t\t// notify chCork only when chPostProcessing is empty\n\t\t\tif len(s.chPostProcessing) == 0 {\n\t\t\t\tselect {\n\t\t\t\tcase chCork <- struct{}{}:\n\t\t\t\tdefault:\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// re-enable die channel\n\t\t\tchDie = s.die\n\n\t\tcase <-chCork: // emulate a corked socket\n\t\t\tif len(txqueue) > 0 {\n\t\t\t\ts.tx(txqueue)\n\t\t\t\t// recycle\n\t\t\t\tfor k := range txqueue {\n\t\t\t\t\txmitBuf.Put(txqueue[k].Buffers[0])\n\t\t\t\t\ttxqueue[k].Buffers = nil\n\t\t\t\t}\n\t\t\t\ttxqueue = txqueue[:0]\n\t\t\t}\n\n\t\t\t// re-enable die channel\n\t\t\tchDie = s.die\n\n\t\tcase <-chDie:\n\t\t\t// remaining packets in txqueue should be sent out\n\t\t\tif len(chCork) > 0 || len(s.chPostProcessing) > 0 {\n\t\t\t\tchDie = nil // block chDie temporarily\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\treturn\n\t\t}\n\t}\n}\n\n// sess update to trigger protocol\nfunc (s *UDPSession) update() {\n\tselect {\n\tcase <-s.die:\n\tdefault:\n\t\ts.mu.Lock()\n\t\tinterval := s.kcp.flush(false)\n\t\twaitsnd := s.kcp.WaitSnd()\n\t\tif waitsnd < int(s.kcp.snd_wnd) && waitsnd < int(s.kcp.rmt_wnd) {\n\t\t\ts.notifyWriteEvent()\n\t\t}\n\t\ts.mu.Unlock()\n\t\t// self-synchronized timed scheduling\n\t\tSystemTimedSched.Put(s.update, time.Now().Add(time.Duration(interval)*time.Millisecond))\n\t}\n}\n\n// GetConv gets conversation id of a session\nfunc (s *UDPSession) GetConv() uint32 { return s.kcp.conv }\n\n// GetRTO gets current rto of the session\nfunc (s *UDPSession) GetRTO() uint32 {\n\ts.mu.Lock()\n\tdefer s.mu.Unlock()\n\treturn s.kcp.rx_rto\n}\n\n// GetSRTT gets current srtt of the session\nfunc (s *UDPSession) GetSRTT() int32 {\n\ts.mu.Lock()\n\tdefer s.mu.Unlock()\n\treturn s.kcp.rx_srtt\n}\n\n// GetRTTVar gets current rtt variance of the session\nfunc (s *UDPSession) GetSRTTVar() int32 {\n\ts.mu.Lock()\n\tdefer s.mu.Unlock()\n\treturn s.kcp.rx_rttvar\n}\n\nfunc (s *UDPSession) notifyReadEvent() {\n\tselect {\n\tcase s.chReadEvent <- struct{}{}:\n\tdefault:\n\t}\n}\n\nfunc (s *UDPSession) notifyWriteEvent() {\n\tselect {\n\tcase s.chWriteEvent <- struct{}{}:\n\tdefault:\n\t}\n}\n\nfunc (s *UDPSession) notifyReadError(err error) {\n\ts.socketReadErrorOnce.Do(func() {\n\t\ts.socketReadError.Store(err)\n\t\tclose(s.chSocketReadError)\n\t})\n}\n\nfunc (s *UDPSession) notifyWriteError(err error) {\n\ts.socketWriteErrorOnce.Do(func() {\n\t\ts.socketWriteError.Store(err)\n\t\tclose(s.chSocketWriteError)\n\t})\n}\n\n// packet input pipeline:\n// network -> [decryption ->] [crc32 ->] [FEC ->] [KCP input ->] stream -> application\nfunc (s *UDPSession) packetInput(data []byte) {\n\tdecrypted := false\n\tif s.block != nil && len(data) >= cryptHeaderSize {\n\t\ts.block.Decrypt(data, data)\n\t\tdata = data[nonceSize:]\n\t\tchecksum := crc32.ChecksumIEEE(data[crcSize:])\n\t\tif checksum == binary.LittleEndian.Uint32(data) {\n\t\t\tdata = data[crcSize:]\n\t\t\tdecrypted = true\n\t\t} else {\n\t\t\tatomic.AddUint64(&DefaultSnmp.InCsumErrors, 1)\n\t\t}\n\t} else if s.block == nil {\n\t\tdecrypted = true\n\t}\n\n\tif decrypted && len(data) >= IKCP_OVERHEAD {\n\t\ts.kcpInput(data)\n\t}\n}\n\nfunc (s *UDPSession) kcpInput(data []byte) {\n\tvar kcpInErrors, fecErrs, fecRecovered, fecParityShards uint64\n\n\tfecFlag := binary.LittleEndian.Uint16(data[4:])\n\tif fecFlag == typeData || fecFlag == typeParity { // 16bit kcp cmd [81-84] and frg [0-255] will not overlap with FEC type 0x00f1 0x00f2\n\t\tif len(data) >= fecHeaderSizePlus2 {\n\t\t\tf := fecPacket(data)\n\t\t\tif f.flag() == typeParity {\n\t\t\t\tfecParityShards++\n\t\t\t}\n\n\t\t\t// lock\n\t\t\ts.mu.Lock()\n\t\t\t// if fecDecoder is not initialized, create one with default parameter\n\t\t\t// lazy initialization\n\t\t\tif s.fecDecoder == nil {\n\t\t\t\ts.fecDecoder = newFECDecoder(1, 1)\n\t\t\t}\n\n\t\t\t// FEC decoding\n\t\t\trecovers := s.fecDecoder.decode(f)\n\t\t\tif f.flag() == typeData {\n\t\t\t\tif ret := s.kcp.Input(data[fecHeaderSizePlus2:], true, s.ackNoDelay); ret != 0 {\n\t\t\t\t\tkcpInErrors++\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// If there're some packets recovered from FEC, feed them into kcp\n\t\t\tfor _, r := range recovers {\n\t\t\t\tif len(r) >= 2 { // must be larger than 2bytes\n\t\t\t\t\tsz := binary.LittleEndian.Uint16(r)\n\t\t\t\t\tif int(sz) <= len(r) && sz >= 2 {\n\t\t\t\t\t\tif ret := s.kcp.Input(r[2:sz], false, s.ackNoDelay); ret == 0 {\n\t\t\t\t\t\t\tfecRecovered++\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tkcpInErrors++\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tfecErrs++\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tfecErrs++\n\t\t\t\t}\n\t\t\t\t// recycle the buffer\n\t\t\t\txmitBuf.Put(r)\n\t\t\t}\n\n\t\t\t// to notify the readers to receive the data if there's any\n\t\t\tif n := s.kcp.PeekSize(); n > 0 {\n\t\t\t\ts.notifyReadEvent()\n\t\t\t}\n\n\t\t\t// to notify the writers if the window size allows to send more packets\n\t\t\t// and the remote window size is not full.\n\t\t\twaitsnd := s.kcp.WaitSnd()\n\t\t\tif waitsnd < int(s.kcp.snd_wnd) && waitsnd < int(s.kcp.rmt_wnd) {\n\t\t\t\ts.notifyWriteEvent()\n\t\t\t}\n\t\t\ts.mu.Unlock()\n\t\t} else {\n\t\t\tatomic.AddUint64(&DefaultSnmp.InErrs, 1)\n\t\t}\n\t} else {\n\t\ts.mu.Lock()\n\t\tif ret := s.kcp.Input(data, true, s.ackNoDelay); ret != 0 {\n\t\t\tkcpInErrors++\n\t\t}\n\t\tif n := s.kcp.PeekSize(); n > 0 {\n\t\t\ts.notifyReadEvent()\n\t\t}\n\t\twaitsnd := s.kcp.WaitSnd()\n\t\tif waitsnd < int(s.kcp.snd_wnd) && waitsnd < int(s.kcp.rmt_wnd) {\n\t\t\ts.notifyWriteEvent()\n\t\t}\n\t\ts.mu.Unlock()\n\t}\n\n\tatomic.AddUint64(&DefaultSnmp.InPkts, 1)\n\tatomic.AddUint64(&DefaultSnmp.InBytes, uint64(len(data)))\n\tif fecParityShards > 0 {\n\t\tatomic.AddUint64(&DefaultSnmp.FECParityShards, fecParityShards)\n\t}\n\tif kcpInErrors > 0 {\n\t\tatomic.AddUint64(&DefaultSnmp.KCPInErrors, kcpInErrors)\n\t}\n\tif fecErrs > 0 {\n\t\tatomic.AddUint64(&DefaultSnmp.FECErrs, fecErrs)\n\t}\n\tif fecRecovered > 0 {\n\t\tatomic.AddUint64(&DefaultSnmp.FECRecovered, fecRecovered)\n\t}\n\n}\n\ntype (\n\t// Listener defines a server which will be waiting to accept incoming connections\n\tListener struct {\n\t\tblock        BlockCrypt     // block encryption\n\t\tdataShards   int            // FEC data shard\n\t\tparityShards int            // FEC parity shard\n\t\tconn         net.PacketConn // the underlying packet connection\n\t\townConn      bool           // true if we created conn internally, false if provided by caller\n\n\t\tsessions        map[string]*UDPSession // all sessions accepted by this Listener\n\t\tsessionLock     sync.RWMutex\n\t\tchAccepts       chan *UDPSession // Listen() backlog\n\t\tchSessionClosed chan net.Addr    // session close queue\n\n\t\tdie     chan struct{} // notify the listener has closed\n\t\tdieOnce sync.Once\n\n\t\t// socket error handling\n\t\tsocketReadError     atomic.Value\n\t\tchSocketReadError   chan struct{}\n\t\tsocketReadErrorOnce sync.Once\n\n\t\trd atomic.Value // read deadline for Accept()\n\t}\n)\n\n// packet input stage\nfunc (l *Listener) packetInput(data []byte, addr net.Addr) {\n\tdecrypted := false\n\tif l.block != nil && len(data) >= cryptHeaderSize {\n\t\tl.block.Decrypt(data, data)\n\t\tdata = data[nonceSize:]\n\t\tchecksum := crc32.ChecksumIEEE(data[crcSize:])\n\t\tif checksum == binary.LittleEndian.Uint32(data) {\n\t\t\tdata = data[crcSize:]\n\t\t\tdecrypted = true\n\t\t} else {\n\t\t\tatomic.AddUint64(&DefaultSnmp.InCsumErrors, 1)\n\t\t}\n\t} else if l.block == nil {\n\t\tdecrypted = true\n\t}\n\n\tif decrypted && len(data) >= IKCP_OVERHEAD {\n\t\tl.sessionLock.RLock()\n\t\ts, ok := l.sessions[addr.String()]\n\t\tl.sessionLock.RUnlock()\n\n\t\tvar conv, sn uint32\n\t\tconvRecovered := false\n\t\tfecFlag := binary.LittleEndian.Uint16(data[4:])\n\t\tif fecFlag == typeData || fecFlag == typeParity { // 16bit kcp cmd [81-84] and frg [0-255] will not overlap with FEC type 0x00f1 0x00f2\n\t\t\t// packet with FEC\n\t\t\tif fecFlag == typeData && len(data) >= fecHeaderSizePlus2+IKCP_OVERHEAD {\n\t\t\t\tconv = binary.LittleEndian.Uint32(data[fecHeaderSizePlus2:])\n\t\t\t\tsn = binary.LittleEndian.Uint32(data[fecHeaderSizePlus2+IKCP_SN_OFFSET:])\n\t\t\t\tconvRecovered = true\n\t\t\t}\n\t\t} else {\n\t\t\t// packet without FEC\n\t\t\tconv = binary.LittleEndian.Uint32(data)\n\t\t\tsn = binary.LittleEndian.Uint32(data[IKCP_SN_OFFSET:])\n\t\t\tconvRecovered = true\n\t\t}\n\n\t\tif ok { // existing connection\n\t\t\tif !convRecovered || conv == s.kcp.conv { // parity data or valid conversation\n\t\t\t\ts.kcpInput(data)\n\t\t\t} else if sn == 0 { // should replace current connection\n\t\t\t\ts.Close()\n\t\t\t\ts = nil\n\t\t\t}\n\t\t}\n\n\t\tif s == nil && convRecovered { // new session\n\t\t\tif len(l.chAccepts) < cap(l.chAccepts) { // do not let the new sessions overwhelm accept queue\n\t\t\t\ts := newUDPSession(conv, l.dataShards, l.parityShards, l, l.conn, false, addr, l.block)\n\t\t\t\ts.kcpInput(data)\n\t\t\t\tl.sessionLock.Lock()\n\t\t\t\tl.sessions[addr.String()] = s\n\t\t\t\tl.sessionLock.Unlock()\n\t\t\t\tl.chAccepts <- s\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc (l *Listener) notifyReadError(err error) {\n\tl.socketReadErrorOnce.Do(func() {\n\t\tl.socketReadError.Store(err)\n\t\tclose(l.chSocketReadError)\n\n\t\t// propagate read error to all sessions\n\t\tl.sessionLock.RLock()\n\t\tfor _, s := range l.sessions {\n\t\t\ts.notifyReadError(err)\n\t\t}\n\t\tl.sessionLock.RUnlock()\n\t})\n}\n\n// SetReadBuffer sets the socket read buffer for the Listener\nfunc (l *Listener) SetReadBuffer(bytes int) error {\n\tif nc, ok := l.conn.(setReadBuffer); ok {\n\t\treturn nc.SetReadBuffer(bytes)\n\t}\n\treturn errInvalidOperation\n}\n\n// SetWriteBuffer sets the socket write buffer for the Listener\nfunc (l *Listener) SetWriteBuffer(bytes int) error {\n\tif nc, ok := l.conn.(setWriteBuffer); ok {\n\t\treturn nc.SetWriteBuffer(bytes)\n\t}\n\treturn errInvalidOperation\n}\n\n// SetDSCP sets the 6bit DSCP field in IPv4 header, or 8bit Traffic Class in IPv6 header.\n//\n// if the underlying connection has implemented `func SetDSCP(int) error`, SetDSCP() will invoke\n// this function instead.\nfunc (l *Listener) SetDSCP(dscp int) error {\n\t// interface enabled\n\tif ts, ok := l.conn.(setDSCP); ok {\n\t\treturn ts.SetDSCP(dscp)\n\t}\n\n\tif nc, ok := l.conn.(net.Conn); ok {\n\t\tvar succeed bool\n\t\tif err := ipv4.NewConn(nc).SetTOS(dscp << 2); err == nil {\n\t\t\tsucceed = true\n\t\t}\n\t\tif err := ipv6.NewConn(nc).SetTrafficClass(dscp); err == nil {\n\t\t\tsucceed = true\n\t\t}\n\n\t\tif succeed {\n\t\t\treturn nil\n\t\t}\n\t}\n\treturn errInvalidOperation\n}\n\n// Accept implements the Accept method in the Listener interface; it waits for the next call and returns a generic Conn.\nfunc (l *Listener) Accept() (net.Conn, error) {\n\treturn l.AcceptKCP()\n}\n\n// AcceptKCP accepts a KCP connection\nfunc (l *Listener) AcceptKCP() (*UDPSession, error) {\n\tvar timeout <-chan time.Time\n\tif tdeadline, ok := l.rd.Load().(time.Time); ok && !tdeadline.IsZero() {\n\t\ttimer := time.NewTimer(time.Until(tdeadline))\n\t\tdefer timer.Stop()\n\n\t\ttimeout = timer.C\n\t}\n\n\tselect {\n\tcase <-timeout:\n\t\treturn nil, errors.WithStack(errTimeout)\n\tcase c := <-l.chAccepts:\n\t\treturn c, nil\n\tcase <-l.chSocketReadError:\n\t\treturn nil, l.socketReadError.Load().(error)\n\tcase <-l.die:\n\t\treturn nil, errors.WithStack(io.ErrClosedPipe)\n\t}\n}\n\n// SetDeadline sets the deadline associated with the listener. A zero time value disables the deadline.\nfunc (l *Listener) SetDeadline(t time.Time) error {\n\tl.SetReadDeadline(t)\n\tl.SetWriteDeadline(t)\n\treturn nil\n}\n\n// SetReadDeadline implements the Conn SetReadDeadline method.\nfunc (l *Listener) SetReadDeadline(t time.Time) error {\n\tl.rd.Store(t)\n\treturn nil\n}\n\n// SetWriteDeadline implements the Conn SetWriteDeadline method.\nfunc (l *Listener) SetWriteDeadline(t time.Time) error { return errInvalidOperation }\n\n// Close stops listening on the UDP address, and closes the socket\nfunc (l *Listener) Close() error {\n\tvar once bool\n\tl.dieOnce.Do(func() {\n\t\tclose(l.die)\n\t\tonce = true\n\t})\n\n\tvar err error\n\tif once {\n\t\tif l.ownConn {\n\t\t\terr = l.conn.Close()\n\t\t}\n\t} else {\n\t\terr = errors.WithStack(io.ErrClosedPipe)\n\t}\n\treturn err\n}\n\n// Control applys a procedure to the underly socket fd.\n// CAUTION: BE VERY CAREFUL TO USE THIS FUNCTION, YOU MAY BREAK THE PROTOCOL.\nfunc (l *Listener) Control(f func(conn net.PacketConn) error) error {\n\tl.sessionLock.Lock()\n\tdefer l.sessionLock.Unlock()\n\treturn f(l.conn)\n}\n\n// closeSession notify the listener that a session has closed\nfunc (l *Listener) closeSession(remote net.Addr) (ret bool) {\n\tl.sessionLock.Lock()\n\tdefer l.sessionLock.Unlock()\n\tif _, ok := l.sessions[remote.String()]; ok {\n\t\tdelete(l.sessions, remote.String())\n\t\treturn true\n\t}\n\treturn false\n}\n\n// Addr returns the listener's network address, The Addr returned is shared by all invocations of Addr, so do not modify it.\nfunc (l *Listener) Addr() net.Addr { return l.conn.LocalAddr() }\n\n// Listen listens for incoming KCP packets addressed to the local address laddr on the network \"udp\",\nfunc Listen(laddr string) (net.Listener, error) { return ListenWithOptions(laddr, nil, 0, 0) }\n\n// ListenWithOptions listens for incoming KCP packets addressed to the local address laddr on the network \"udp\" with packet encryption.\n//\n// 'block' is the block encryption algorithm to encrypt packets.\n//\n// 'dataShards', 'parityShards' specify how many parity packets will be generated following the data packets.\n//\n// Check https://github.com/klauspost/reedsolomon for details\nfunc ListenWithOptions(laddr string, block BlockCrypt, dataShards, parityShards int) (*Listener, error) {\n\tudpaddr, err := net.ResolveUDPAddr(\"udp\", laddr)\n\tif err != nil {\n\t\treturn nil, errors.WithStack(err)\n\t}\n\tconn, err := net.ListenUDP(\"udp\", udpaddr)\n\tif err != nil {\n\t\treturn nil, errors.WithStack(err)\n\t}\n\n\treturn serveConn(block, dataShards, parityShards, conn, true)\n}\n\n// ServeConn serves KCP protocol for a single packet connection.\nfunc ServeConn(block BlockCrypt, dataShards, parityShards int, conn net.PacketConn) (*Listener, error) {\n\treturn serveConn(block, dataShards, parityShards, conn, false)\n}\n\nfunc serveConn(block BlockCrypt, dataShards, parityShards int, conn net.PacketConn, ownConn bool) (*Listener, error) {\n\tl := new(Listener)\n\tl.conn = conn\n\tl.ownConn = ownConn\n\tl.sessions = make(map[string]*UDPSession)\n\tl.chAccepts = make(chan *UDPSession, acceptBacklog)\n\tl.chSessionClosed = make(chan net.Addr)\n\tl.die = make(chan struct{})\n\tl.dataShards = dataShards\n\tl.parityShards = parityShards\n\tl.block = block\n\tl.chSocketReadError = make(chan struct{})\n\tgo l.monitor()\n\treturn l, nil\n}\n\n// Dial connects to the remote address \"raddr\" on the network \"udp\" without encryption and FEC\nfunc Dial(raddr string) (net.Conn, error) { return DialWithOptions(raddr, nil, 0, 0) }\n\n// DialWithOptions connects to the remote address \"raddr\" on the network \"udp\" with packet encryption\n//\n// 'block' is the block encryption algorithm to encrypt packets.\n//\n// 'dataShards', 'parityShards' specify how many parity packets will be generated following the data packets.\n//\n// Check https://github.com/klauspost/reedsolomon for details\nfunc DialWithOptions(raddr string, block BlockCrypt, dataShards, parityShards int) (*UDPSession, error) {\n\t// network type detection\n\tudpaddr, err := net.ResolveUDPAddr(\"udp\", raddr)\n\tif err != nil {\n\t\treturn nil, errors.WithStack(err)\n\t}\n\tnetwork := \"udp4\"\n\tif udpaddr.IP.To4() == nil {\n\t\tnetwork = \"udp\"\n\t}\n\n\tconn, err := net.ListenUDP(network, nil)\n\tif err != nil {\n\t\treturn nil, errors.WithStack(err)\n\t}\n\n\tvar convid uint32\n\tbinary.Read(rand.Reader, binary.LittleEndian, &convid)\n\treturn newUDPSession(convid, dataShards, parityShards, nil, conn, true, udpaddr, block), nil\n}\n\n// NewConn4 establishes a session and talks KCP protocol over a packet connection.\nfunc NewConn4(convid uint32, raddr net.Addr, block BlockCrypt, dataShards, parityShards int, ownConn bool, conn net.PacketConn) (*UDPSession, error) {\n\treturn newUDPSession(convid, dataShards, parityShards, nil, conn, ownConn, raddr, block), nil\n}\n\n// NewConn3 establishes a session and talks KCP protocol over a packet connection.\nfunc NewConn3(convid uint32, raddr net.Addr, block BlockCrypt, dataShards, parityShards int, conn net.PacketConn) (*UDPSession, error) {\n\treturn newUDPSession(convid, dataShards, parityShards, nil, conn, false, raddr, block), nil\n}\n\n// NewConn2 establishes a session and talks KCP protocol over a packet connection.\nfunc NewConn2(raddr net.Addr, block BlockCrypt, dataShards, parityShards int, conn net.PacketConn) (*UDPSession, error) {\n\tvar convid uint32\n\tbinary.Read(rand.Reader, binary.LittleEndian, &convid)\n\treturn NewConn3(convid, raddr, block, dataShards, parityShards, conn)\n}\n\n// NewConn establishes a session and talks KCP protocol over a packet connection.\nfunc NewConn(raddr string, block BlockCrypt, dataShards, parityShards int, conn net.PacketConn) (*UDPSession, error) {\n\tudpaddr, err := net.ResolveUDPAddr(\"udp\", raddr)\n\tif err != nil {\n\t\treturn nil, errors.WithStack(err)\n\t}\n\treturn NewConn2(udpaddr, block, dataShards, parityShards, conn)\n}\n"
        },
        {
          "name": "sess_test.go",
          "type": "blob",
          "size": 16.5810546875,
          "content": "// The MIT License (MIT)\n//\n// Copyright (c) 2015 xtaci\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.\n\npackage kcp\n\nimport (\n\t\"bytes\"\n\t\"crypto/rand\"\n\t\"crypto/sha1\"\n\t\"fmt\"\n\t\"io\"\n\t\"log\"\n\t\"net\"\n\t\"net/http\"\n\t_ \"net/http/pprof\"\n\t\"sync\"\n\t\"sync/atomic\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/pkg/errors\"\n\t\"golang.org/x/crypto/pbkdf2\"\n)\n\nvar baseport = uint32(10000)\nvar key = []byte(\"testkey\")\nvar pass = pbkdf2.Key(key, []byte(\"testsalt\"), 4096, 32, sha1.New)\n\nfunc init() {\n\tgo func() {\n\t\tlog.Println(http.ListenAndServe(\"0.0.0.0:6060\", nil))\n\t}()\n\n\tlog.Println(\"beginning tests, encryption:salsa20, fec:10/3\")\n}\n\nfunc dialEcho(port int) (*UDPSession, error) {\n\t//block, _ := NewNoneBlockCrypt(pass)\n\t//block, _ := NewSimpleXORBlockCrypt(pass)\n\t//block, _ := NewTEABlockCrypt(pass[:16])\n\t//block, _ := NewAESBlockCrypt(pass)\n\tblock, _ := NewSalsa20BlockCrypt(pass)\n\tsess, err := DialWithOptions(fmt.Sprintf(\"127.0.0.1:%v\", port), block, 10, 3)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\tsess.SetStreamMode(true)\n\tsess.SetStreamMode(false)\n\tsess.SetStreamMode(true)\n\tsess.SetWindowSize(1024, 1024)\n\tsess.SetReadBuffer(16 * 1024 * 1024)\n\tsess.SetWriteBuffer(16 * 1024 * 1024)\n\tsess.SetStreamMode(true)\n\tsess.SetNoDelay(1, 10, 2, 1)\n\tsess.SetMtu(1400)\n\tsess.SetMtu(1600)\n\tsess.SetMtu(1400)\n\tsess.SetACKNoDelay(true)\n\tsess.SetACKNoDelay(false)\n\tsess.SetDeadline(time.Now().Add(time.Minute))\n\treturn sess, err\n}\n\nfunc dialSink(port int) (*UDPSession, error) {\n\tsess, err := DialWithOptions(fmt.Sprintf(\"127.0.0.1:%v\", port), nil, 0, 0)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\tsess.SetStreamMode(true)\n\tsess.SetWindowSize(1024, 1024)\n\tsess.SetReadBuffer(16 * 1024 * 1024)\n\tsess.SetWriteBuffer(16 * 1024 * 1024)\n\tsess.SetStreamMode(true)\n\tsess.SetNoDelay(1, 10, 2, 1)\n\tsess.SetMtu(1400)\n\tsess.SetACKNoDelay(false)\n\tsess.SetDeadline(time.Now().Add(time.Minute))\n\treturn sess, err\n}\n\nfunc dialTinyBufferEcho(port int) (*UDPSession, error) {\n\t//block, _ := NewNoneBlockCrypt(pass)\n\t//block, _ := NewSimpleXORBlockCrypt(pass)\n\t//block, _ := NewTEABlockCrypt(pass[:16])\n\t//block, _ := NewAESBlockCrypt(pass)\n\tblock, _ := NewSalsa20BlockCrypt(pass)\n\tsess, err := DialWithOptions(fmt.Sprintf(\"127.0.0.1:%v\", port), block, 10, 3)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\treturn sess, err\n}\n\n// ////////////////////////\nfunc listenEcho(port int) (net.Listener, error) {\n\t//block, _ := NewNoneBlockCrypt(pass)\n\t//block, _ := NewSimpleXORBlockCrypt(pass)\n\t//block, _ := NewTEABlockCrypt(pass[:16])\n\t//block, _ := NewAESBlockCrypt(pass)\n\tblock, _ := NewSalsa20BlockCrypt(pass)\n\treturn ListenWithOptions(fmt.Sprintf(\"127.0.0.1:%v\", port), block, 10, 1)\n}\nfunc listenTinyBufferEcho(port int) (net.Listener, error) {\n\t//block, _ := NewNoneBlockCrypt(pass)\n\t//block, _ := NewSimpleXORBlockCrypt(pass)\n\t//block, _ := NewTEABlockCrypt(pass[:16])\n\t//block, _ := NewAESBlockCrypt(pass)\n\tblock, _ := NewSalsa20BlockCrypt(pass)\n\treturn ListenWithOptions(fmt.Sprintf(\"127.0.0.1:%v\", port), block, 10, 3)\n}\n\nfunc listenSink(port int) (net.Listener, error) {\n\treturn ListenWithOptions(fmt.Sprintf(\"127.0.0.1:%v\", port), nil, 0, 0)\n}\n\nfunc echoServer(port int) net.Listener {\n\tl, err := listenEcho(port)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\tgo func() {\n\t\tkcplistener := l.(*Listener)\n\t\tkcplistener.SetReadBuffer(4 * 1024 * 1024)\n\t\tkcplistener.SetWriteBuffer(4 * 1024 * 1024)\n\t\tkcplistener.SetDSCP(46)\n\t\tfor {\n\t\t\ts, err := l.Accept()\n\t\t\tif err != nil {\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\t// coverage test\n\t\t\ts.(*UDPSession).SetReadBuffer(4 * 1024 * 1024)\n\t\t\ts.(*UDPSession).SetWriteBuffer(4 * 1024 * 1024)\n\t\t\tgo handleEcho(s.(*UDPSession))\n\t\t}\n\t}()\n\n\treturn l\n}\n\nfunc sinkServer(port int) net.Listener {\n\tl, err := listenSink(port)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\tgo func() {\n\t\tkcplistener := l.(*Listener)\n\t\tkcplistener.SetReadBuffer(4 * 1024 * 1024)\n\t\tkcplistener.SetWriteBuffer(4 * 1024 * 1024)\n\t\tkcplistener.SetDSCP(46)\n\t\tfor {\n\t\t\ts, err := l.Accept()\n\t\t\tif err != nil {\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tgo handleSink(s.(*UDPSession))\n\t\t}\n\t}()\n\n\treturn l\n}\n\nfunc tinyBufferEchoServer(port int) net.Listener {\n\tl, err := listenTinyBufferEcho(port)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\tgo func() {\n\t\tfor {\n\t\t\ts, err := l.Accept()\n\t\t\tif err != nil {\n\t\t\t\treturn\n\t\t\t}\n\t\t\tgo handleTinyBufferEcho(s.(*UDPSession))\n\t\t}\n\t}()\n\treturn l\n}\n\n///////////////////////////\n\nfunc handleEcho(conn *UDPSession) {\n\tconn.SetStreamMode(true)\n\tconn.SetWindowSize(4096, 4096)\n\tconn.SetNoDelay(1, 10, 2, 1)\n\tconn.SetDSCP(46)\n\tconn.SetMtu(1400)\n\tconn.SetACKNoDelay(false)\n\tconn.SetReadDeadline(time.Now().Add(time.Hour))\n\tconn.SetWriteDeadline(time.Now().Add(time.Hour))\n\tbuf := make([]byte, 65536)\n\tfor {\n\t\tn, err := conn.Read(buf)\n\t\tif err != nil {\n\t\t\treturn\n\t\t}\n\t\tconn.Write(buf[:n])\n\t}\n}\n\nfunc handleSink(conn *UDPSession) {\n\tconn.SetStreamMode(true)\n\tconn.SetWindowSize(4096, 4096)\n\tconn.SetNoDelay(1, 10, 2, 1)\n\tconn.SetDSCP(46)\n\tconn.SetMtu(1400)\n\tconn.SetACKNoDelay(false)\n\tconn.SetReadDeadline(time.Now().Add(time.Hour))\n\tconn.SetWriteDeadline(time.Now().Add(time.Hour))\n\tbuf := make([]byte, 65536)\n\tfor {\n\t\t_, err := conn.Read(buf)\n\t\tif err != nil {\n\t\t\treturn\n\t\t}\n\t}\n}\n\nfunc handleTinyBufferEcho(conn *UDPSession) {\n\tconn.SetStreamMode(true)\n\tbuf := make([]byte, 2)\n\tfor {\n\t\tn, err := conn.Read(buf)\n\t\tif err != nil {\n\t\t\treturn\n\t\t}\n\t\tconn.Write(buf[:n])\n\t}\n}\n\n///////////////////////////\n\nfunc TestTimeout(t *testing.T) {\n\tport := int(atomic.AddUint32(&baseport, 1))\n\tl := echoServer(port)\n\tdefer l.Close()\n\n\tcli, err := dialEcho(port)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tbuf := make([]byte, 10)\n\n\t//timeout\n\tcli.SetDeadline(time.Now().Add(time.Second))\n\t<-time.After(2 * time.Second)\n\tn, err := cli.Read(buf)\n\tif n != 0 || err == nil {\n\t\tt.Fail()\n\t}\n\tcli.Close()\n}\n\nfunc TestSendRecv(t *testing.T) {\n\tport := int(atomic.AddUint32(&baseport, 1))\n\tl := echoServer(port)\n\tdefer l.Close()\n\n\tcli, err := dialEcho(port)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tcli.SetWriteDelay(true)\n\tcli.SetDUP(1)\n\tconst N = 100\n\tbuf := make([]byte, 10)\n\tfor i := 0; i < N; i++ {\n\t\tmsg := fmt.Sprintf(\"hello%v\", i)\n\t\tcli.Write([]byte(msg))\n\t\tif n, err := cli.Read(buf); err == nil {\n\t\t\tif string(buf[:n]) != msg {\n\t\t\t\tt.Fail()\n\t\t\t}\n\t\t} else {\n\t\t\tpanic(err)\n\t\t}\n\t}\n\tcli.Close()\n}\n\nfunc TestSendVector(t *testing.T) {\n\tport := int(atomic.AddUint32(&baseport, 1))\n\tl := echoServer(port)\n\tdefer l.Close()\n\n\tcli, err := dialEcho(port)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tcli.SetWriteDelay(false)\n\tconst N = 100\n\tbuf := make([]byte, 20)\n\tv := make([][]byte, 2)\n\tfor i := 0; i < N; i++ {\n\t\tv[0] = []byte(fmt.Sprintf(\"hello%v\", i))\n\t\tv[1] = []byte(fmt.Sprintf(\"world%v\", i))\n\t\tmsg := fmt.Sprintf(\"hello%vworld%v\", i, i)\n\t\tcli.WriteBuffers(v)\n\t\tif n, err := cli.Read(buf); err == nil {\n\t\t\tif string(buf[:n]) != msg {\n\t\t\t\tt.Error(string(buf[:n]), msg)\n\t\t\t}\n\t\t} else {\n\t\t\tpanic(err)\n\t\t}\n\t}\n\tcli.Close()\n}\n\nfunc TestTinyBufferReceiver(t *testing.T) {\n\tport := int(atomic.AddUint32(&baseport, 1))\n\tl := tinyBufferEchoServer(port)\n\tdefer l.Close()\n\n\tcli, err := dialTinyBufferEcho(port)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tconst N = 100\n\tsnd := byte(0)\n\tfillBuffer := func(buf []byte) {\n\t\tfor i := 0; i < len(buf); i++ {\n\t\t\tbuf[i] = snd\n\t\t\tsnd++\n\t\t}\n\t}\n\n\trcv := byte(0)\n\tcheck := func(buf []byte) bool {\n\t\tfor i := 0; i < len(buf); i++ {\n\t\t\tif buf[i] != rcv {\n\t\t\t\treturn false\n\t\t\t}\n\t\t\trcv++\n\t\t}\n\t\treturn true\n\t}\n\tsndbuf := make([]byte, 7)\n\trcvbuf := make([]byte, 7)\n\tfor i := 0; i < N; i++ {\n\t\tfillBuffer(sndbuf)\n\t\tcli.Write(sndbuf)\n\t\tif n, err := io.ReadFull(cli, rcvbuf); err == nil {\n\t\t\tif !check(rcvbuf[:n]) {\n\t\t\t\tt.Fail()\n\t\t\t}\n\t\t} else {\n\t\t\tpanic(err)\n\t\t}\n\t}\n\tcli.Close()\n}\n\nfunc TestClose(t *testing.T) {\n\tvar n int\n\tvar err error\n\n\tport := int(atomic.AddUint32(&baseport, 1))\n\tl := echoServer(port)\n\tdefer l.Close()\n\n\tcli, err := dialEcho(port)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\t// double close\n\tcli.Close()\n\tif cli.Close() == nil {\n\t\tt.Fatal(\"double close misbehavior\")\n\t}\n\n\t// write after close\n\tbuf := make([]byte, 10)\n\tn, err = cli.Write(buf)\n\tif n != 0 || err == nil {\n\t\tt.Fatal(\"write after close misbehavior\")\n\t}\n\n\t// write, close, read, read\n\tcli, err = dialEcho(port)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tif n, err = cli.Write(buf); err != nil {\n\t\tt.Fatal(\"write misbehavior\")\n\t}\n\n\t// wait until data arrival\n\ttime.Sleep(2 * time.Second)\n\t// drain\n\tcli.Close()\n\tn, err = io.ReadFull(cli, buf)\n\tif err != nil {\n\t\tt.Fatal(\"closed conn drain bytes failed\", err, n)\n\t}\n\n\t// after drain, read should return error\n\tn, err = cli.Read(buf)\n\tif n != 0 || err == nil {\n\t\tt.Fatal(\"write->close->drain->read misbehavior\", err, n)\n\t}\n\tcli.Close()\n}\n\nfunc TestParallel1024CLIENT_64BMSG_64CNT(t *testing.T) {\n\tport := int(atomic.AddUint32(&baseport, 1))\n\tl := echoServer(port)\n\tdefer l.Close()\n\n\tvar wg sync.WaitGroup\n\twg.Add(1024)\n\tfor i := 0; i < 1024; i++ {\n\t\tgo parallel_client(&wg, port)\n\t}\n\twg.Wait()\n}\n\nfunc parallel_client(wg *sync.WaitGroup, port int) (err error) {\n\tcli, err := dialEcho(port)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\terr = echo_tester(cli, 64, 64)\n\tcli.Close()\n\twg.Done()\n\treturn\n}\n\nfunc BenchmarkEchoSpeed4K(b *testing.B) {\n\tspeedclient(b, 4096)\n}\n\nfunc BenchmarkEchoSpeed64K(b *testing.B) {\n\tspeedclient(b, 65536)\n}\n\nfunc BenchmarkEchoSpeed512K(b *testing.B) {\n\tspeedclient(b, 524288)\n}\n\nfunc BenchmarkEchoSpeed1M(b *testing.B) {\n\tspeedclient(b, 1048576)\n}\n\nfunc speedclient(b *testing.B, nbytes int) {\n\tport := int(atomic.AddUint32(&baseport, 1))\n\tl := echoServer(port)\n\tdefer l.Close()\n\n\tb.ReportAllocs()\n\tcli, err := dialEcho(port)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\tif err := echo_tester(cli, nbytes, b.N); err != nil {\n\t\tb.Fail()\n\t}\n\tb.SetBytes(int64(nbytes))\n\tcli.Close()\n}\n\nfunc BenchmarkSinkSpeed4K(b *testing.B) {\n\tsinkclient(b, 4096)\n}\n\nfunc BenchmarkSinkSpeed64K(b *testing.B) {\n\tsinkclient(b, 65536)\n}\n\nfunc BenchmarkSinkSpeed256K(b *testing.B) {\n\tsinkclient(b, 524288)\n}\n\nfunc BenchmarkSinkSpeed1M(b *testing.B) {\n\tsinkclient(b, 1048576)\n}\n\nfunc sinkclient(b *testing.B, nbytes int) {\n\tport := int(atomic.AddUint32(&baseport, 1))\n\tl := sinkServer(port)\n\tdefer l.Close()\n\n\tb.ReportAllocs()\n\tcli, err := dialSink(port)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\tsink_tester(cli, nbytes, b.N)\n\tb.SetBytes(int64(nbytes))\n\tcli.Close()\n}\n\nfunc echo_tester(cli net.Conn, msglen, msgcount int) error {\n\tbuf := make([]byte, msglen)\n\tfor i := 0; i < msgcount; i++ {\n\t\t// send packet\n\t\tif _, err := cli.Write(buf); err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\t// receive packet\n\t\tnrecv := 0\n\t\tfor {\n\t\t\tn, err := cli.Read(buf)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t} else {\n\t\t\t\tnrecv += n\n\t\t\t\tif nrecv == msglen {\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc sink_tester(cli *UDPSession, msglen, msgcount int) error {\n\t// sender\n\tbuf := make([]byte, msglen)\n\tfor i := 0; i < msgcount; i++ {\n\t\tif _, err := cli.Write(buf); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc TestSNMP(t *testing.T) {\n\tt.Log(DefaultSnmp.Copy())\n\tt.Log(DefaultSnmp.Header())\n\tt.Log(DefaultSnmp.ToSlice())\n\tDefaultSnmp.Reset()\n\tt.Log(DefaultSnmp.ToSlice())\n}\n\nfunc TestListenerClose(t *testing.T) {\n\tport := int(atomic.AddUint32(&baseport, 1))\n\tl, err := ListenWithOptions(fmt.Sprintf(\"127.0.0.1:%v\", port), nil, 10, 3)\n\tif err != nil {\n\t\tt.Fail()\n\t}\n\tl.SetReadDeadline(time.Now().Add(time.Second))\n\tl.SetWriteDeadline(time.Now().Add(time.Second))\n\tl.SetDeadline(time.Now().Add(time.Second))\n\ttime.Sleep(2 * time.Second)\n\tif _, err := l.Accept(); err == nil {\n\t\tt.Fail()\n\t}\n\n\tl.Close()\n\tfakeaddr, _ := net.ResolveUDPAddr(\"udp6\", \"127.0.0.1:1111\")\n\tif l.closeSession(fakeaddr) {\n\t\tt.Fail()\n\t}\n}\n\n// A wrapper for net.PacketConn that remembers when Close has been called.\ntype closedFlagPacketConn struct {\n\tnet.PacketConn\n\tClosed bool\n}\n\nfunc (c *closedFlagPacketConn) Close() error {\n\tc.Closed = true\n\treturn c.PacketConn.Close()\n}\n\nfunc newClosedFlagPacketConn(c net.PacketConn) *closedFlagPacketConn {\n\treturn &closedFlagPacketConn{c, false}\n}\n\n// Listener should not close a net.PacketConn that it did not create.\n// https://github.com/xtaci/kcp-go/issues/165\nfunc TestListenerNonOwnedPacketConn(t *testing.T) {\n\t// Create a net.PacketConn not owned by the Listener.\n\tc, err := net.ListenPacket(\"udp\", \"127.0.0.1:0\")\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tdefer c.Close()\n\t// Make it remember when it has been closed.\n\tpconn := newClosedFlagPacketConn(c)\n\n\tl, err := ServeConn(nil, 0, 0, pconn)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tdefer l.Close()\n\n\tif pconn.Closed {\n\t\tt.Fatal(\"non-owned PacketConn closed before Listener.Close()\")\n\t}\n\n\terr = l.Close()\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\tif pconn.Closed {\n\t\tt.Fatal(\"non-owned PacketConn closed after Listener.Close()\")\n\t}\n}\n\n// UDPSession should not close a net.PacketConn that it did not create.\n// https://github.com/xtaci/kcp-go/issues/165\nfunc TestUDPSessionNonOwnedPacketConn(t *testing.T) {\n\tl := sinkServer(0)\n\tdefer l.Close()\n\n\t// Create a net.PacketConn not owned by the UDPSession.\n\tc, err := net.ListenPacket(\"udp\", \"127.0.0.1:0\")\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tdefer c.Close()\n\t// Make it remember when it has been closed.\n\tpconn := newClosedFlagPacketConn(c)\n\n\tclient, err := NewConn2(l.Addr(), nil, 0, 0, pconn)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tdefer client.Close()\n\n\tif pconn.Closed {\n\t\tt.Fatal(\"non-owned PacketConn closed before UDPSession.Close()\")\n\t}\n\n\terr = client.Close()\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\tif pconn.Closed {\n\t\tt.Fatal(\"non-owned PacketConn closed after UDPSession.Close()\")\n\t}\n}\n\n// this function test the data correctness with FEC and encryption enabled\nfunc TestReliability(t *testing.T) {\n\tport := int(atomic.AddUint32(&baseport, 1))\n\tl := echoServer(port)\n\tdefer l.Close()\n\n\tcli, err := dialEcho(port)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tcli.SetWriteDelay(false)\n\tconst N = 100000\n\tbuf := make([]byte, 128)\n\tmsg := make([]byte, 128)\n\n\tfor i := 0; i < N; i++ {\n\t\tio.ReadFull(rand.Reader, msg)\n\t\tcli.Write([]byte(msg))\n\t\tif n, err := io.ReadFull(cli, buf); err == nil {\n\t\t\tif !bytes.Equal(buf[:n], msg) {\n\t\t\t\tt.Fail()\n\t\t\t}\n\t\t} else {\n\t\t\tpanic(err)\n\t\t}\n\t}\n\tcli.Close()\n}\n\nfunc TestControl(t *testing.T) {\n\tport := int(atomic.AddUint32(&baseport, 1))\n\tblock, _ := NewSalsa20BlockCrypt(pass)\n\tl, err := ListenWithOptions(fmt.Sprintf(\"127.0.0.1:%v\", port), block, 10, 1)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\terrorA := errors.New(\"A\")\n\terr = l.Control(func(conn net.PacketConn) error {\n\t\tfmt.Printf(\"Listener Control: conn: %v\\n\", conn)\n\t\treturn errorA\n\t})\n\n\tif err != errorA {\n\t\tt.Fatal(err)\n\t}\n\n\tcli, err := dialEcho(port)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\terrorB := errors.New(\"B\")\n\terr = cli.Control(func(conn net.PacketConn) error {\n\t\tfmt.Printf(\"Client Control: conn: %v\\n\", conn)\n\t\treturn errorB\n\t})\n\n\tif err != errorB {\n\t\tt.Fatal(err)\n\t}\n}\n\nfunc TestSessionReadAfterClosed(t *testing.T) {\n\tus, _ := net.ListenPacket(\"udp\", \"127.0.0.1:0\")\n\tuc, _ := net.ListenPacket(\"udp\", \"127.0.0.1:0\")\n\tdefer us.Close()\n\tdefer uc.Close()\n\n\tknockDoor := func(c net.Conn, myid string) (string, error) {\n\t\tc.SetDeadline(time.Now().Add(time.Second * 3))\n\t\t_, err := c.Write([]byte(myid))\n\t\tc.SetDeadline(time.Time{})\n\t\tif err != nil {\n\t\t\treturn \"\", err\n\t\t}\n\t\tc.SetDeadline(time.Now().Add(time.Second * 3))\n\t\tvar buf [1024]byte\n\t\tn, err := c.Read(buf[:])\n\t\tc.SetDeadline(time.Time{})\n\t\treturn string(buf[:n]), err\n\t}\n\n\tcheck := func(c1, c2 *UDPSession) {\n\t\tdone := make(chan struct{}, 1)\n\t\tgo func() {\n\t\t\trid, err := knockDoor(c2, \"4321\")\n\t\t\tdone <- struct{}{}\n\t\t\tif err != nil {\n\t\t\t\tpanic(err)\n\t\t\t}\n\t\t\tif rid != \"1234\" {\n\t\t\t\tpanic(\"mismatch id\")\n\t\t\t}\n\t\t}()\n\t\trid, err := knockDoor(c1, \"1234\")\n\t\tif err != nil {\n\t\t\tpanic(err)\n\t\t}\n\t\tif rid != \"4321\" {\n\t\t\tpanic(\"mismatch id\")\n\t\t}\n\t\t<-done\n\t}\n\n\tc1, err := NewConn3(0, uc.LocalAddr(), nil, 0, 0, us)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tc2, err := NewConn3(0, us.LocalAddr(), nil, 0, 0, uc)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tcheck(c1, c2)\n\tc1.Close()\n\tc2.Close()\n\t//log.Println(\"conv id 0 is closed\")\n\n\tc1, err = NewConn3(4321, uc.LocalAddr(), nil, 0, 0, us)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tc2, err = NewConn3(4321, us.LocalAddr(), nil, 0, 0, uc)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tcheck(c1, c2)\n}\n"
        },
        {
          "name": "snmp.go",
          "type": "blob",
          "size": 6.2861328125,
          "content": "// The MIT License (MIT)\n//\n// Copyright (c) 2015 xtaci\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.\n\npackage kcp\n\nimport (\n\t\"fmt\"\n\t\"sync/atomic\"\n)\n\n// Snmp defines network statistics indicator\ntype Snmp struct {\n\tBytesSent        uint64 // bytes sent from upper level\n\tBytesReceived    uint64 // bytes received to upper level\n\tMaxConn          uint64 // max number of connections ever reached\n\tActiveOpens      uint64 // accumulated active open connections\n\tPassiveOpens     uint64 // accumulated passive open connections\n\tCurrEstab        uint64 // current number of established connections\n\tInErrs           uint64 // UDP read errors reported from net.PacketConn\n\tInCsumErrors     uint64 // checksum errors from CRC32\n\tKCPInErrors      uint64 // packet iput errors reported from KCP\n\tInPkts           uint64 // incoming packets count\n\tOutPkts          uint64 // outgoing packets count\n\tInSegs           uint64 // incoming KCP segments\n\tOutSegs          uint64 // outgoing KCP segments\n\tInBytes          uint64 // UDP bytes received\n\tOutBytes         uint64 // UDP bytes sent\n\tRetransSegs      uint64 // accmulated retransmited segments\n\tFastRetransSegs  uint64 // accmulated fast retransmitted segments\n\tEarlyRetransSegs uint64 // accmulated early retransmitted segments\n\tLostSegs         uint64 // number of segs inferred as lost\n\tRepeatSegs       uint64 // number of segs duplicated\n\tFECRecovered     uint64 // correct packets recovered from FEC\n\tFECErrs          uint64 // incorrect packets recovered from FEC\n\tFECParityShards  uint64 // FEC segments received\n\tFECShortShards   uint64 // number of data shards that's not enough for recovery\n}\n\nfunc newSnmp() *Snmp {\n\treturn new(Snmp)\n}\n\n// Header returns all field names\nfunc (s *Snmp) Header() []string {\n\treturn []string{\n\t\t\"BytesSent\",\n\t\t\"BytesReceived\",\n\t\t\"MaxConn\",\n\t\t\"ActiveOpens\",\n\t\t\"PassiveOpens\",\n\t\t\"CurrEstab\",\n\t\t\"InErrs\",\n\t\t\"InCsumErrors\",\n\t\t\"KCPInErrors\",\n\t\t\"InPkts\",\n\t\t\"OutPkts\",\n\t\t\"InSegs\",\n\t\t\"OutSegs\",\n\t\t\"InBytes\",\n\t\t\"OutBytes\",\n\t\t\"RetransSegs\",\n\t\t\"FastRetransSegs\",\n\t\t\"EarlyRetransSegs\",\n\t\t\"LostSegs\",\n\t\t\"RepeatSegs\",\n\t\t\"FECParityShards\",\n\t\t\"FECErrs\",\n\t\t\"FECRecovered\",\n\t\t\"FECShortShards\",\n\t}\n}\n\n// ToSlice returns current snmp info as slice\nfunc (s *Snmp) ToSlice() []string {\n\tsnmp := s.Copy()\n\treturn []string{\n\t\tfmt.Sprint(snmp.BytesSent),\n\t\tfmt.Sprint(snmp.BytesReceived),\n\t\tfmt.Sprint(snmp.MaxConn),\n\t\tfmt.Sprint(snmp.ActiveOpens),\n\t\tfmt.Sprint(snmp.PassiveOpens),\n\t\tfmt.Sprint(snmp.CurrEstab),\n\t\tfmt.Sprint(snmp.InErrs),\n\t\tfmt.Sprint(snmp.InCsumErrors),\n\t\tfmt.Sprint(snmp.KCPInErrors),\n\t\tfmt.Sprint(snmp.InPkts),\n\t\tfmt.Sprint(snmp.OutPkts),\n\t\tfmt.Sprint(snmp.InSegs),\n\t\tfmt.Sprint(snmp.OutSegs),\n\t\tfmt.Sprint(snmp.InBytes),\n\t\tfmt.Sprint(snmp.OutBytes),\n\t\tfmt.Sprint(snmp.RetransSegs),\n\t\tfmt.Sprint(snmp.FastRetransSegs),\n\t\tfmt.Sprint(snmp.EarlyRetransSegs),\n\t\tfmt.Sprint(snmp.LostSegs),\n\t\tfmt.Sprint(snmp.RepeatSegs),\n\t\tfmt.Sprint(snmp.FECParityShards),\n\t\tfmt.Sprint(snmp.FECErrs),\n\t\tfmt.Sprint(snmp.FECRecovered),\n\t\tfmt.Sprint(snmp.FECShortShards),\n\t}\n}\n\n// Copy make a copy of current snmp snapshot\nfunc (s *Snmp) Copy() *Snmp {\n\td := newSnmp()\n\td.BytesSent = atomic.LoadUint64(&s.BytesSent)\n\td.BytesReceived = atomic.LoadUint64(&s.BytesReceived)\n\td.MaxConn = atomic.LoadUint64(&s.MaxConn)\n\td.ActiveOpens = atomic.LoadUint64(&s.ActiveOpens)\n\td.PassiveOpens = atomic.LoadUint64(&s.PassiveOpens)\n\td.CurrEstab = atomic.LoadUint64(&s.CurrEstab)\n\td.InErrs = atomic.LoadUint64(&s.InErrs)\n\td.InCsumErrors = atomic.LoadUint64(&s.InCsumErrors)\n\td.KCPInErrors = atomic.LoadUint64(&s.KCPInErrors)\n\td.InPkts = atomic.LoadUint64(&s.InPkts)\n\td.OutPkts = atomic.LoadUint64(&s.OutPkts)\n\td.InSegs = atomic.LoadUint64(&s.InSegs)\n\td.OutSegs = atomic.LoadUint64(&s.OutSegs)\n\td.InBytes = atomic.LoadUint64(&s.InBytes)\n\td.OutBytes = atomic.LoadUint64(&s.OutBytes)\n\td.RetransSegs = atomic.LoadUint64(&s.RetransSegs)\n\td.FastRetransSegs = atomic.LoadUint64(&s.FastRetransSegs)\n\td.EarlyRetransSegs = atomic.LoadUint64(&s.EarlyRetransSegs)\n\td.LostSegs = atomic.LoadUint64(&s.LostSegs)\n\td.RepeatSegs = atomic.LoadUint64(&s.RepeatSegs)\n\td.FECParityShards = atomic.LoadUint64(&s.FECParityShards)\n\td.FECErrs = atomic.LoadUint64(&s.FECErrs)\n\td.FECRecovered = atomic.LoadUint64(&s.FECRecovered)\n\td.FECShortShards = atomic.LoadUint64(&s.FECShortShards)\n\treturn d\n}\n\n// Reset values to zero\nfunc (s *Snmp) Reset() {\n\tatomic.StoreUint64(&s.BytesSent, 0)\n\tatomic.StoreUint64(&s.BytesReceived, 0)\n\tatomic.StoreUint64(&s.MaxConn, 0)\n\tatomic.StoreUint64(&s.ActiveOpens, 0)\n\tatomic.StoreUint64(&s.PassiveOpens, 0)\n\tatomic.StoreUint64(&s.CurrEstab, 0)\n\tatomic.StoreUint64(&s.InErrs, 0)\n\tatomic.StoreUint64(&s.InCsumErrors, 0)\n\tatomic.StoreUint64(&s.KCPInErrors, 0)\n\tatomic.StoreUint64(&s.InPkts, 0)\n\tatomic.StoreUint64(&s.OutPkts, 0)\n\tatomic.StoreUint64(&s.InSegs, 0)\n\tatomic.StoreUint64(&s.OutSegs, 0)\n\tatomic.StoreUint64(&s.InBytes, 0)\n\tatomic.StoreUint64(&s.OutBytes, 0)\n\tatomic.StoreUint64(&s.RetransSegs, 0)\n\tatomic.StoreUint64(&s.FastRetransSegs, 0)\n\tatomic.StoreUint64(&s.EarlyRetransSegs, 0)\n\tatomic.StoreUint64(&s.LostSegs, 0)\n\tatomic.StoreUint64(&s.RepeatSegs, 0)\n\tatomic.StoreUint64(&s.FECParityShards, 0)\n\tatomic.StoreUint64(&s.FECErrs, 0)\n\tatomic.StoreUint64(&s.FECRecovered, 0)\n\tatomic.StoreUint64(&s.FECShortShards, 0)\n}\n\n// DefaultSnmp is the global KCP connection statistics collector\nvar DefaultSnmp *Snmp\n\nfunc init() {\n\tDefaultSnmp = newSnmp()\n}\n"
        },
        {
          "name": "timedsched.go",
          "type": "blob",
          "size": 4.5107421875,
          "content": "// The MIT License (MIT)\n//\n// Copyright (c) 2015 xtaci\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.\n\npackage kcp\n\nimport (\n\t\"container/heap\"\n\t\"runtime\"\n\t\"sync\"\n\t\"time\"\n)\n\n// SystemTimedSched is the library level timed-scheduler\nvar SystemTimedSched *TimedSched = NewTimedSched(runtime.NumCPU())\n\ntype timedFunc struct {\n\texecute func()\n\tts      time.Time\n}\n\n// a heap for sorted timed function\ntype timedFuncHeap []timedFunc\n\nfunc (h timedFuncHeap) Len() int            { return len(h) }\nfunc (h timedFuncHeap) Less(i, j int) bool  { return h[i].ts.Before(h[j].ts) }\nfunc (h timedFuncHeap) Swap(i, j int)       { h[i], h[j] = h[j], h[i] }\nfunc (h *timedFuncHeap) Push(x interface{}) { *h = append(*h, x.(timedFunc)) }\nfunc (h *timedFuncHeap) Pop() interface{} {\n\told := *h\n\tn := len(old)\n\tx := old[n-1]\n\told[n-1].execute = nil // avoid memory leak\n\t*h = old[0 : n-1]\n\treturn x\n}\n\n// TimedSched represents the control struct for timed parallel scheduler\ntype TimedSched struct {\n\t// prepending tasks\n\tprependTasks    []timedFunc\n\tprependLock     sync.Mutex\n\tchPrependNotify chan struct{}\n\n\t// tasks will be distributed through chTask\n\tchTask chan timedFunc\n\n\tdieOnce sync.Once\n\tdie     chan struct{}\n}\n\n// NewTimedSched creates a parallel-scheduler with given parallelization\nfunc NewTimedSched(parallel int) *TimedSched {\n\tts := new(TimedSched)\n\tts.chTask = make(chan timedFunc)\n\tts.die = make(chan struct{})\n\tts.chPrependNotify = make(chan struct{}, 1)\n\n\tfor i := 0; i < parallel; i++ {\n\t\tgo ts.sched()\n\t}\n\tgo ts.prepend()\n\treturn ts\n}\n\n// sched is a goroutine to schedule and execute timed tasks.\nfunc (ts *TimedSched) sched() {\n\ttimer := time.NewTimer(0)\n\tdefer timer.Stop()\n\n\tvar tasks timedFuncHeap\n\tdrained := false\n\tfor {\n\t\tselect {\n\t\tcase task := <-ts.chTask:\n\t\t\tnow := time.Now()\n\t\t\tif now.After(task.ts) {\n\t\t\t\t// already delayed! execute immediately\n\t\t\t\ttask.execute()\n\t\t\t} else {\n\t\t\t\theap.Push(&tasks, task)\n\t\t\t\t// properly reset timer to trigger based on the top element\n\t\t\t\tstopped := timer.Stop()\n\t\t\t\tif !stopped && !drained {\n\t\t\t\t\t<-timer.C\n\t\t\t\t}\n\t\t\t\ttimer.Reset(tasks[0].ts.Sub(now))\n\t\t\t\tdrained = false\n\t\t\t}\n\t\tcase now := <-timer.C:\n\t\t\tdrained = true\n\t\t\tfor tasks.Len() > 0 {\n\t\t\t\tif now.After(tasks[0].ts) {\n\t\t\t\t\theap.Pop(&tasks).(timedFunc).execute()\n\t\t\t\t} else {\n\t\t\t\t\ttimer.Reset(tasks[0].ts.Sub(now))\n\t\t\t\t\tdrained = false\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\tcase <-ts.die:\n\t\t\treturn\n\t\t}\n\t}\n}\n\n// prepend is the front desk goroutine to register tasks\nfunc (ts *TimedSched) prepend() {\n\tvar tasks []timedFunc\n\tfor {\n\t\tselect {\n\t\tcase <-ts.chPrependNotify:\n\t\t\tts.prependLock.Lock()\n\t\t\t// keep cap to reuse slice\n\t\t\tif cap(tasks) < cap(ts.prependTasks) {\n\t\t\t\ttasks = make([]timedFunc, 0, cap(ts.prependTasks))\n\t\t\t}\n\t\t\ttasks = tasks[:len(ts.prependTasks)]\n\t\t\tcopy(tasks, ts.prependTasks)\n\t\t\tfor k := range ts.prependTasks {\n\t\t\t\tts.prependTasks[k].execute = nil // avoid memory leak\n\t\t\t}\n\t\t\tts.prependTasks = ts.prependTasks[:0]\n\t\t\tts.prependLock.Unlock()\n\n\t\t\tfor k := range tasks {\n\t\t\t\tselect {\n\t\t\t\tcase ts.chTask <- tasks[k]:\n\t\t\t\t\ttasks[k].execute = nil // avoid memory leak\n\t\t\t\tcase <-ts.die:\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}\n\t\t\ttasks = tasks[:0]\n\t\tcase <-ts.die:\n\t\t\treturn\n\t\t}\n\t}\n}\n\n// Put a function 'f' awaiting to be executed at 'deadline'\nfunc (ts *TimedSched) Put(f func(), deadline time.Time) {\n\tts.prependLock.Lock()\n\tts.prependTasks = append(ts.prependTasks, timedFunc{f, deadline})\n\tts.prependLock.Unlock()\n\n\tselect {\n\tcase ts.chPrependNotify <- struct{}{}:\n\tdefault:\n\t}\n}\n\n// Close terminates this scheduler\nfunc (ts *TimedSched) Close() { ts.dieOnce.Do(func() { close(ts.die) }) }\n"
        },
        {
          "name": "tx.go",
          "type": "blob",
          "size": 1.642578125,
          "content": "// The MIT License (MIT)\n//\n// Copyright (c) 2015 xtaci\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.\n\npackage kcp\n\nimport (\n\t\"sync/atomic\"\n\n\t\"github.com/pkg/errors\"\n\t\"golang.org/x/net/ipv4\"\n)\n\n// defaultTx is the default procedure to transmit data\nfunc (s *UDPSession) defaultTx(txqueue []ipv4.Message) {\n\tnbytes := 0\n\tnpkts := 0\n\tfor k := range txqueue {\n\t\tif n, err := s.conn.WriteTo(txqueue[k].Buffers[0], txqueue[k].Addr); err == nil {\n\t\t\tnbytes += n\n\t\t\tnpkts++\n\t\t} else {\n\t\t\ts.notifyWriteError(errors.WithStack(err))\n\t\t\tbreak\n\t\t}\n\t}\n\tatomic.AddUint64(&DefaultSnmp.OutPkts, uint64(npkts))\n\tatomic.AddUint64(&DefaultSnmp.OutBytes, uint64(nbytes))\n}\n"
        },
        {
          "name": "tx_generic.go",
          "type": "blob",
          "size": 1.2451171875,
          "content": "// The MIT License (MIT)\n//\n// Copyright (c) 2015 xtaci\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.\n\n//go:build !linux\n\npackage kcp\n\nimport (\n\t\"golang.org/x/net/ipv4\"\n)\n\nfunc (s *UDPSession) tx(txqueue []ipv4.Message) {\n\ts.defaultTx(txqueue)\n}\n"
        },
        {
          "name": "tx_linux.go",
          "type": "blob",
          "size": 2.2509765625,
          "content": "// The MIT License (MIT)\n//\n// Copyright (c) 2015 xtaci\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.\n\n//go:build linux\n\npackage kcp\n\nimport (\n\t\"net\"\n\t\"os\"\n\t\"sync/atomic\"\n\n\t\"github.com/pkg/errors\"\n\t\"golang.org/x/net/ipv4\"\n)\n\n// tx is the optimized procedure to transmit packets utilizing the linux sendmmsg system call\nfunc (s *UDPSession) tx(txqueue []ipv4.Message) {\n\t// default version\n\tif s.xconn == nil || s.xconnWriteError != nil {\n\t\ts.defaultTx(txqueue)\n\t\treturn\n\t}\n\n\t// x/net version\n\tnbytes := 0\n\tnpkts := 0\n\tfor len(txqueue) > 0 {\n\t\tif n, err := s.xconn.WriteBatch(txqueue, 0); err == nil {\n\t\t\tfor k := range txqueue[:n] {\n\t\t\t\tnbytes += len(txqueue[k].Buffers[0])\n\t\t\t}\n\t\t\tnpkts += n\n\t\t\ttxqueue = txqueue[n:]\n\t\t} else {\n\t\t\t// compatibility issue:\n\t\t\t// for linux kernel<=2.6.32, support for sendmmsg is not available\n\t\t\t// an error of type os.SyscallError will be returned\n\t\t\tif operr, ok := err.(*net.OpError); ok {\n\t\t\t\tif se, ok := operr.Err.(*os.SyscallError); ok {\n\t\t\t\t\tif se.Syscall == \"sendmmsg\" {\n\t\t\t\t\t\ts.xconnWriteError = se\n\t\t\t\t\t\ts.defaultTx(txqueue)\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\ts.notifyWriteError(errors.WithStack(err))\n\t\t\tbreak\n\t\t}\n\t}\n\n\tatomic.AddUint64(&DefaultSnmp.OutPkts, uint64(npkts))\n\tatomic.AddUint64(&DefaultSnmp.OutBytes, uint64(nbytes))\n}\n"
        },
        {
          "name": "wireshark",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}