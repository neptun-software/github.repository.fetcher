{
  "metadata": {
    "timestamp": 1736566668482,
    "page": 221,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjIzMA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "google/btree",
      "stars": 3993,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 11.091796875,
          "content": "\n                                 Apache License\n                           Version 2.0, January 2004\n                        http://www.apache.org/licenses/\n\n   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION\n\n   1. Definitions.\n\n      \"License\" shall mean the terms and conditions for use, reproduction,\n      and distribution as defined by Sections 1 through 9 of this document.\n\n      \"Licensor\" shall mean the copyright owner or entity authorized by\n      the copyright owner that is granting the License.\n\n      \"Legal Entity\" shall mean the union of the acting entity and all\n      other entities that control, are controlled by, or are under common\n      control with that entity. For the purposes of this definition,\n      \"control\" means (i) the power, direct or indirect, to cause the\n      direction or management of such entity, whether by contract or\n      otherwise, or (ii) ownership of fifty percent (50%) or more of the\n      outstanding shares, or (iii) beneficial ownership of such entity.\n\n      \"You\" (or \"Your\") shall mean an individual or Legal Entity\n      exercising permissions granted by this License.\n\n      \"Source\" form shall mean the preferred form for making modifications,\n      including but not limited to software source code, documentation\n      source, and configuration files.\n\n      \"Object\" form shall mean any form resulting from mechanical\n      transformation or translation of a Source form, including but\n      not limited to compiled object code, generated documentation,\n      and conversions to other media types.\n\n      \"Work\" shall mean the work of authorship, whether in Source or\n      Object form, made available under the License, as indicated by a\n      copyright notice that is included in or attached to the work\n      (an example is provided in the Appendix below).\n\n      \"Derivative Works\" shall mean any work, whether in Source or Object\n      form, that is based on (or derived from) the Work and for which the\n      editorial revisions, annotations, elaborations, or other modifications\n      represent, as a whole, an original work of authorship. For the purposes\n      of this License, Derivative Works shall not include works that remain\n      separable from, or merely link (or bind by name) to the interfaces of,\n      the Work and Derivative Works thereof.\n\n      \"Contribution\" shall mean any work of authorship, including\n      the original version of the Work and any modifications or additions\n      to that Work or Derivative Works thereof, that is intentionally\n      submitted to Licensor for inclusion in the Work by the copyright owner\n      or by an individual or Legal Entity authorized to submit on behalf of\n      the copyright owner. For the purposes of this definition, \"submitted\"\n      means any form of electronic, verbal, or written communication sent\n      to the Licensor or its representatives, including but not limited to\n      communication on electronic mailing lists, source code control systems,\n      and issue tracking systems that are managed by, or on behalf of, the\n      Licensor for the purpose of discussing and improving the Work, but\n      excluding communication that is conspicuously marked or otherwise\n      designated in writing by the copyright owner as \"Not a Contribution.\"\n\n      \"Contributor\" shall mean Licensor and any individual or Legal Entity\n      on behalf of whom a Contribution has been received by Licensor and\n      subsequently incorporated within the Work.\n\n   2. Grant of Copyright License. Subject to the terms and conditions of\n      this License, each Contributor hereby grants to You a perpetual,\n      worldwide, non-exclusive, no-charge, royalty-free, irrevocable\n      copyright license to reproduce, prepare Derivative Works of,\n      publicly display, publicly perform, sublicense, and distribute the\n      Work and such Derivative Works in Source or Object form.\n\n   3. Grant of Patent License. Subject to the terms and conditions of\n      this License, each Contributor hereby grants to You a perpetual,\n      worldwide, non-exclusive, no-charge, royalty-free, irrevocable\n      (except as stated in this section) patent license to make, have made,\n      use, offer to sell, sell, import, and otherwise transfer the Work,\n      where such license applies only to those patent claims licensable\n      by such Contributor that are necessarily infringed by their\n      Contribution(s) alone or by combination of their Contribution(s)\n      with the Work to which such Contribution(s) was submitted. If You\n      institute patent litigation against any entity (including a\n      cross-claim or counterclaim in a lawsuit) alleging that the Work\n      or a Contribution incorporated within the Work constitutes direct\n      or contributory patent infringement, then any patent licenses\n      granted to You under this License for that Work shall terminate\n      as of the date such litigation is filed.\n\n   4. Redistribution. You may reproduce and distribute copies of the\n      Work or Derivative Works thereof in any medium, with or without\n      modifications, and in Source or Object form, provided that You\n      meet the following conditions:\n\n      (a) You must give any other recipients of the Work or\n          Derivative Works a copy of this License; and\n\n      (b) You must cause any modified files to carry prominent notices\n          stating that You changed the files; and\n\n      (c) You must retain, in the Source form of any Derivative Works\n          that You distribute, all copyright, patent, trademark, and\n          attribution notices from the Source form of the Work,\n          excluding those notices that do not pertain to any part of\n          the Derivative Works; and\n\n      (d) If the Work includes a \"NOTICE\" text file as part of its\n          distribution, then any Derivative Works that You distribute must\n          include a readable copy of the attribution notices contained\n          within such NOTICE file, excluding those notices that do not\n          pertain to any part of the Derivative Works, in at least one\n          of the following places: within a NOTICE text file distributed\n          as part of the Derivative Works; within the Source form or\n          documentation, if provided along with the Derivative Works; or,\n          within a display generated by the Derivative Works, if and\n          wherever such third-party notices normally appear. The contents\n          of the NOTICE file are for informational purposes only and\n          do not modify the License. You may add Your own attribution\n          notices within Derivative Works that You distribute, alongside\n          or as an addendum to the NOTICE text from the Work, provided\n          that such additional attribution notices cannot be construed\n          as modifying the License.\n\n      You may add Your own copyright statement to Your modifications and\n      may provide additional or different license terms and conditions\n      for use, reproduction, or distribution of Your modifications, or\n      for any such Derivative Works as a whole, provided Your use,\n      reproduction, and distribution of the Work otherwise complies with\n      the conditions stated in this License.\n\n   5. Submission of Contributions. Unless You explicitly state otherwise,\n      any Contribution intentionally submitted for inclusion in the Work\n      by You to the Licensor shall be under the terms and conditions of\n      this License, without any additional terms or conditions.\n      Notwithstanding the above, nothing herein shall supersede or modify\n      the terms of any separate license agreement you may have executed\n      with Licensor regarding such Contributions.\n\n   6. Trademarks. This License does not grant permission to use the trade\n      names, trademarks, service marks, or product names of the Licensor,\n      except as required for reasonable and customary use in describing the\n      origin of the Work and reproducing the content of the NOTICE file.\n\n   7. Disclaimer of Warranty. Unless required by applicable law or\n      agreed to in writing, Licensor provides the Work (and each\n      Contributor provides its Contributions) on an \"AS IS\" BASIS,\n      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n      implied, including, without limitation, any warranties or conditions\n      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A\n      PARTICULAR PURPOSE. You are solely responsible for determining the\n      appropriateness of using or redistributing the Work and assume any\n      risks associated with Your exercise of permissions under this License.\n\n   8. Limitation of Liability. In no event and under no legal theory,\n      whether in tort (including negligence), contract, or otherwise,\n      unless required by applicable law (such as deliberate and grossly\n      negligent acts) or agreed to in writing, shall any Contributor be\n      liable to You for damages, including any direct, indirect, special,\n      incidental, or consequential damages of any character arising as a\n      result of this License or out of the use or inability to use the\n      Work (including but not limited to damages for loss of goodwill,\n      work stoppage, computer failure or malfunction, or any and all\n      other commercial damages or losses), even if such Contributor\n      has been advised of the possibility of such damages.\n\n   9. Accepting Warranty or Additional Liability. While redistributing\n      the Work or Derivative Works thereof, You may choose to offer,\n      and charge a fee for, acceptance of support, warranty, indemnity,\n      or other liability obligations and/or rights consistent with this\n      License. However, in accepting such obligations, You may act only\n      on Your own behalf and on Your sole responsibility, not on behalf\n      of any other Contributor, and only if You agree to indemnify,\n      defend, and hold each Contributor harmless for any liability\n      incurred by, or claims asserted against, such Contributor by reason\n      of your accepting any such warranty or additional liability.\n\n   END OF TERMS AND CONDITIONS\n\n   APPENDIX: How to apply the Apache License to your work.\n\n      To apply the Apache License to your work, attach the following\n      boilerplate notice, with the fields enclosed by brackets \"[]\"\n      replaced with your own identifying information. (Don't include\n      the brackets!)  The text should be enclosed in the appropriate\n      comment syntax for the file format. We also recommend that a\n      file or class name and description of purpose be included on the\n      same \"printed page\" as the copyright notice for easier\n      identification within third-party archives.\n\n   Copyright [yyyy] [name of copyright owner]\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n       http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 0.3623046875,
          "content": "# BTree implementation for Go\n\nThis package provides an in-memory B-Tree implementation for Go, useful as\nan ordered, mutable data structure.\n\nThe API is based off of the wonderful\nhttp://godoc.org/github.com/petar/GoLLRB/llrb, and is meant to allow btree to\nact as a drop-in replacement for gollrb trees.\n\nSee http://godoc.org/github.com/google/btree for documentation.\n"
        },
        {
          "name": "btree.go",
          "type": "blob",
          "size": 26.44140625,
          "content": "// Copyright 2014 Google Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n//go:build !go1.18\n// +build !go1.18\n\n// Package btree implements in-memory B-Trees of arbitrary degree.\n//\n// btree implements an in-memory B-Tree for use as an ordered data structure.\n// It is not meant for persistent storage solutions.\n//\n// It has a flatter structure than an equivalent red-black or other binary tree,\n// which in some cases yields better memory usage and/or performance.\n// See some discussion on the matter here:\n//   http://google-opensource.blogspot.com/2013/01/c-containers-that-save-memory-and-time.html\n// Note, though, that this project is in no way related to the C++ B-Tree\n// implementation written about there.\n//\n// Within this tree, each node contains a slice of items and a (possibly nil)\n// slice of children.  For basic numeric values or raw structs, this can cause\n// efficiency differences when compared to equivalent C++ template code that\n// stores values in arrays within the node:\n//   * Due to the overhead of storing values as interfaces (each\n//     value needs to be stored as the value itself, then 2 words for the\n//     interface pointing to that value and its type), resulting in higher\n//     memory use.\n//   * Since interfaces can point to values anywhere in memory, values are\n//     most likely not stored in contiguous blocks, resulting in a higher\n//     number of cache misses.\n// These issues don't tend to matter, though, when working with strings or other\n// heap-allocated structures, since C++-equivalent structures also must store\n// pointers and also distribute their values across the heap.\n//\n// This implementation is designed to be a drop-in replacement to gollrb.LLRB\n// trees, (http://github.com/petar/gollrb), an excellent and probably the most\n// widely used ordered tree implementation in the Go ecosystem currently.\n// Its functions, therefore, exactly mirror those of\n// llrb.LLRB where possible.  Unlike gollrb, though, we currently don't\n// support storing multiple equivalent values.\npackage btree\n\nimport (\n\t\"fmt\"\n\t\"io\"\n\t\"sort\"\n\t\"strings\"\n\t\"sync\"\n)\n\n// Item represents a single object in the tree.\ntype Item interface {\n\t// Less tests whether the current item is less than the given argument.\n\t//\n\t// This must provide a strict weak ordering.\n\t// If !a.Less(b) && !b.Less(a), we treat this to mean a == b (i.e. we can only\n\t// hold one of either a or b in the tree).\n\tLess(than Item) bool\n}\n\nconst (\n\tDefaultFreeListSize = 32\n)\n\nvar (\n\tnilItems    = make(items, 16)\n\tnilChildren = make(children, 16)\n)\n\n// FreeList represents a free list of btree nodes. By default each\n// BTree has its own FreeList, but multiple BTrees can share the same\n// FreeList.\n// Two Btrees using the same freelist are safe for concurrent write access.\ntype FreeList struct {\n\tmu       sync.Mutex\n\tfreelist []*node\n}\n\n// NewFreeList creates a new free list.\n// size is the maximum size of the returned free list.\nfunc NewFreeList(size int) *FreeList {\n\treturn &FreeList{freelist: make([]*node, 0, size)}\n}\n\nfunc (f *FreeList) newNode() (n *node) {\n\tf.mu.Lock()\n\tindex := len(f.freelist) - 1\n\tif index < 0 {\n\t\tf.mu.Unlock()\n\t\treturn new(node)\n\t}\n\tn = f.freelist[index]\n\tf.freelist[index] = nil\n\tf.freelist = f.freelist[:index]\n\tf.mu.Unlock()\n\treturn\n}\n\n// freeNode adds the given node to the list, returning true if it was added\n// and false if it was discarded.\nfunc (f *FreeList) freeNode(n *node) (out bool) {\n\tf.mu.Lock()\n\tif len(f.freelist) < cap(f.freelist) {\n\t\tf.freelist = append(f.freelist, n)\n\t\tout = true\n\t}\n\tf.mu.Unlock()\n\treturn\n}\n\n// ItemIterator allows callers of Ascend* to iterate in-order over portions of\n// the tree.  When this function returns false, iteration will stop and the\n// associated Ascend* function will immediately return.\ntype ItemIterator func(i Item) bool\n\n// New creates a new B-Tree with the given degree.\n//\n// New(2), for example, will create a 2-3-4 tree (each node contains 1-3 items\n// and 2-4 children).\nfunc New(degree int) *BTree {\n\treturn NewWithFreeList(degree, NewFreeList(DefaultFreeListSize))\n}\n\n// NewWithFreeList creates a new B-Tree that uses the given node free list.\nfunc NewWithFreeList(degree int, f *FreeList) *BTree {\n\tif degree <= 1 {\n\t\tpanic(\"bad degree\")\n\t}\n\treturn &BTree{\n\t\tdegree: degree,\n\t\tcow:    &copyOnWriteContext{freelist: f},\n\t}\n}\n\n// items stores items in a node.\ntype items []Item\n\n// insertAt inserts a value into the given index, pushing all subsequent values\n// forward.\nfunc (s *items) insertAt(index int, item Item) {\n\t*s = append(*s, nil)\n\tif index < len(*s) {\n\t\tcopy((*s)[index+1:], (*s)[index:])\n\t}\n\t(*s)[index] = item\n}\n\n// removeAt removes a value at a given index, pulling all subsequent values\n// back.\nfunc (s *items) removeAt(index int) Item {\n\titem := (*s)[index]\n\tcopy((*s)[index:], (*s)[index+1:])\n\t(*s)[len(*s)-1] = nil\n\t*s = (*s)[:len(*s)-1]\n\treturn item\n}\n\n// pop removes and returns the last element in the list.\nfunc (s *items) pop() (out Item) {\n\tindex := len(*s) - 1\n\tout = (*s)[index]\n\t(*s)[index] = nil\n\t*s = (*s)[:index]\n\treturn\n}\n\n// truncate truncates this instance at index so that it contains only the\n// first index items. index must be less than or equal to length.\nfunc (s *items) truncate(index int) {\n\tvar toClear items\n\t*s, toClear = (*s)[:index], (*s)[index:]\n\tfor len(toClear) > 0 {\n\t\ttoClear = toClear[copy(toClear, nilItems):]\n\t}\n}\n\n// find returns the index where the given item should be inserted into this\n// list.  'found' is true if the item already exists in the list at the given\n// index.\nfunc (s items) find(item Item) (index int, found bool) {\n\ti := sort.Search(len(s), func(i int) bool {\n\t\treturn item.Less(s[i])\n\t})\n\tif i > 0 && !s[i-1].Less(item) {\n\t\treturn i - 1, true\n\t}\n\treturn i, false\n}\n\n// children stores child nodes in a node.\ntype children []*node\n\n// insertAt inserts a value into the given index, pushing all subsequent values\n// forward.\nfunc (s *children) insertAt(index int, n *node) {\n\t*s = append(*s, nil)\n\tif index < len(*s) {\n\t\tcopy((*s)[index+1:], (*s)[index:])\n\t}\n\t(*s)[index] = n\n}\n\n// removeAt removes a value at a given index, pulling all subsequent values\n// back.\nfunc (s *children) removeAt(index int) *node {\n\tn := (*s)[index]\n\tcopy((*s)[index:], (*s)[index+1:])\n\t(*s)[len(*s)-1] = nil\n\t*s = (*s)[:len(*s)-1]\n\treturn n\n}\n\n// pop removes and returns the last element in the list.\nfunc (s *children) pop() (out *node) {\n\tindex := len(*s) - 1\n\tout = (*s)[index]\n\t(*s)[index] = nil\n\t*s = (*s)[:index]\n\treturn\n}\n\n// truncate truncates this instance at index so that it contains only the\n// first index children. index must be less than or equal to length.\nfunc (s *children) truncate(index int) {\n\tvar toClear children\n\t*s, toClear = (*s)[:index], (*s)[index:]\n\tfor len(toClear) > 0 {\n\t\ttoClear = toClear[copy(toClear, nilChildren):]\n\t}\n}\n\n// node is an internal node in a tree.\n//\n// It must at all times maintain the invariant that either\n//   * len(children) == 0, len(items) unconstrained\n//   * len(children) == len(items) + 1\ntype node struct {\n\titems    items\n\tchildren children\n\tcow      *copyOnWriteContext\n}\n\nfunc (n *node) mutableFor(cow *copyOnWriteContext) *node {\n\tif n.cow == cow {\n\t\treturn n\n\t}\n\tout := cow.newNode()\n\tif cap(out.items) >= len(n.items) {\n\t\tout.items = out.items[:len(n.items)]\n\t} else {\n\t\tout.items = make(items, len(n.items), cap(n.items))\n\t}\n\tcopy(out.items, n.items)\n\t// Copy children\n\tif cap(out.children) >= len(n.children) {\n\t\tout.children = out.children[:len(n.children)]\n\t} else {\n\t\tout.children = make(children, len(n.children), cap(n.children))\n\t}\n\tcopy(out.children, n.children)\n\treturn out\n}\n\nfunc (n *node) mutableChild(i int) *node {\n\tc := n.children[i].mutableFor(n.cow)\n\tn.children[i] = c\n\treturn c\n}\n\n// split splits the given node at the given index.  The current node shrinks,\n// and this function returns the item that existed at that index and a new node\n// containing all items/children after it.\nfunc (n *node) split(i int) (Item, *node) {\n\titem := n.items[i]\n\tnext := n.cow.newNode()\n\tnext.items = append(next.items, n.items[i+1:]...)\n\tn.items.truncate(i)\n\tif len(n.children) > 0 {\n\t\tnext.children = append(next.children, n.children[i+1:]...)\n\t\tn.children.truncate(i + 1)\n\t}\n\treturn item, next\n}\n\n// maybeSplitChild checks if a child should be split, and if so splits it.\n// Returns whether or not a split occurred.\nfunc (n *node) maybeSplitChild(i, maxItems int) bool {\n\tif len(n.children[i].items) < maxItems {\n\t\treturn false\n\t}\n\tfirst := n.mutableChild(i)\n\titem, second := first.split(maxItems / 2)\n\tn.items.insertAt(i, item)\n\tn.children.insertAt(i+1, second)\n\treturn true\n}\n\n// insert inserts an item into the subtree rooted at this node, making sure\n// no nodes in the subtree exceed maxItems items.  Should an equivalent item be\n// be found/replaced by insert, it will be returned.\nfunc (n *node) insert(item Item, maxItems int) Item {\n\ti, found := n.items.find(item)\n\tif found {\n\t\tout := n.items[i]\n\t\tn.items[i] = item\n\t\treturn out\n\t}\n\tif len(n.children) == 0 {\n\t\tn.items.insertAt(i, item)\n\t\treturn nil\n\t}\n\tif n.maybeSplitChild(i, maxItems) {\n\t\tinTree := n.items[i]\n\t\tswitch {\n\t\tcase item.Less(inTree):\n\t\t\t// no change, we want first split node\n\t\tcase inTree.Less(item):\n\t\t\ti++ // we want second split node\n\t\tdefault:\n\t\t\tout := n.items[i]\n\t\t\tn.items[i] = item\n\t\t\treturn out\n\t\t}\n\t}\n\treturn n.mutableChild(i).insert(item, maxItems)\n}\n\n// get finds the given key in the subtree and returns it.\nfunc (n *node) get(key Item) Item {\n\ti, found := n.items.find(key)\n\tif found {\n\t\treturn n.items[i]\n\t} else if len(n.children) > 0 {\n\t\treturn n.children[i].get(key)\n\t}\n\treturn nil\n}\n\n// min returns the first item in the subtree.\nfunc min(n *node) Item {\n\tif n == nil {\n\t\treturn nil\n\t}\n\tfor len(n.children) > 0 {\n\t\tn = n.children[0]\n\t}\n\tif len(n.items) == 0 {\n\t\treturn nil\n\t}\n\treturn n.items[0]\n}\n\n// max returns the last item in the subtree.\nfunc max(n *node) Item {\n\tif n == nil {\n\t\treturn nil\n\t}\n\tfor len(n.children) > 0 {\n\t\tn = n.children[len(n.children)-1]\n\t}\n\tif len(n.items) == 0 {\n\t\treturn nil\n\t}\n\treturn n.items[len(n.items)-1]\n}\n\n// toRemove details what item to remove in a node.remove call.\ntype toRemove int\n\nconst (\n\tremoveItem toRemove = iota // removes the given item\n\tremoveMin                  // removes smallest item in the subtree\n\tremoveMax                  // removes largest item in the subtree\n)\n\n// remove removes an item from the subtree rooted at this node.\nfunc (n *node) remove(item Item, minItems int, typ toRemove) Item {\n\tvar i int\n\tvar found bool\n\tswitch typ {\n\tcase removeMax:\n\t\tif len(n.children) == 0 {\n\t\t\treturn n.items.pop()\n\t\t}\n\t\ti = len(n.items)\n\tcase removeMin:\n\t\tif len(n.children) == 0 {\n\t\t\treturn n.items.removeAt(0)\n\t\t}\n\t\ti = 0\n\tcase removeItem:\n\t\ti, found = n.items.find(item)\n\t\tif len(n.children) == 0 {\n\t\t\tif found {\n\t\t\t\treturn n.items.removeAt(i)\n\t\t\t}\n\t\t\treturn nil\n\t\t}\n\tdefault:\n\t\tpanic(\"invalid type\")\n\t}\n\t// If we get to here, we have children.\n\tif len(n.children[i].items) <= minItems {\n\t\treturn n.growChildAndRemove(i, item, minItems, typ)\n\t}\n\tchild := n.mutableChild(i)\n\t// Either we had enough items to begin with, or we've done some\n\t// merging/stealing, because we've got enough now and we're ready to return\n\t// stuff.\n\tif found {\n\t\t// The item exists at index 'i', and the child we've selected can give us a\n\t\t// predecessor, since if we've gotten here it's got > minItems items in it.\n\t\tout := n.items[i]\n\t\t// We use our special-case 'remove' call with typ=maxItem to pull the\n\t\t// predecessor of item i (the rightmost leaf of our immediate left child)\n\t\t// and set it into where we pulled the item from.\n\t\tn.items[i] = child.remove(nil, minItems, removeMax)\n\t\treturn out\n\t}\n\t// Final recursive call.  Once we're here, we know that the item isn't in this\n\t// node and that the child is big enough to remove from.\n\treturn child.remove(item, minItems, typ)\n}\n\n// growChildAndRemove grows child 'i' to make sure it's possible to remove an\n// item from it while keeping it at minItems, then calls remove to actually\n// remove it.\n//\n// Most documentation says we have to do two sets of special casing:\n//   1) item is in this node\n//   2) item is in child\n// In both cases, we need to handle the two subcases:\n//   A) node has enough values that it can spare one\n//   B) node doesn't have enough values\n// For the latter, we have to check:\n//   a) left sibling has node to spare\n//   b) right sibling has node to spare\n//   c) we must merge\n// To simplify our code here, we handle cases #1 and #2 the same:\n// If a node doesn't have enough items, we make sure it does (using a,b,c).\n// We then simply redo our remove call, and the second time (regardless of\n// whether we're in case 1 or 2), we'll have enough items and can guarantee\n// that we hit case A.\nfunc (n *node) growChildAndRemove(i int, item Item, minItems int, typ toRemove) Item {\n\tif i > 0 && len(n.children[i-1].items) > minItems {\n\t\t// Steal from left child\n\t\tchild := n.mutableChild(i)\n\t\tstealFrom := n.mutableChild(i - 1)\n\t\tstolenItem := stealFrom.items.pop()\n\t\tchild.items.insertAt(0, n.items[i-1])\n\t\tn.items[i-1] = stolenItem\n\t\tif len(stealFrom.children) > 0 {\n\t\t\tchild.children.insertAt(0, stealFrom.children.pop())\n\t\t}\n\t} else if i < len(n.items) && len(n.children[i+1].items) > minItems {\n\t\t// steal from right child\n\t\tchild := n.mutableChild(i)\n\t\tstealFrom := n.mutableChild(i + 1)\n\t\tstolenItem := stealFrom.items.removeAt(0)\n\t\tchild.items = append(child.items, n.items[i])\n\t\tn.items[i] = stolenItem\n\t\tif len(stealFrom.children) > 0 {\n\t\t\tchild.children = append(child.children, stealFrom.children.removeAt(0))\n\t\t}\n\t} else {\n\t\tif i >= len(n.items) {\n\t\t\ti--\n\t\t}\n\t\tchild := n.mutableChild(i)\n\t\t// merge with right child\n\t\tmergeItem := n.items.removeAt(i)\n\t\tmergeChild := n.children.removeAt(i + 1).mutableFor(n.cow)\n\t\tchild.items = append(child.items, mergeItem)\n\t\tchild.items = append(child.items, mergeChild.items...)\n\t\tchild.children = append(child.children, mergeChild.children...)\n\t\tn.cow.freeNode(mergeChild)\n\t}\n\treturn n.remove(item, minItems, typ)\n}\n\ntype direction int\n\nconst (\n\tdescend = direction(-1)\n\tascend  = direction(+1)\n)\n\n// iterate provides a simple method for iterating over elements in the tree.\n//\n// When ascending, the 'start' should be less than 'stop' and when descending,\n// the 'start' should be greater than 'stop'. Setting 'includeStart' to true\n// will force the iterator to include the first item when it equals 'start',\n// thus creating a \"greaterOrEqual\" or \"lessThanEqual\" rather than just a\n// \"greaterThan\" or \"lessThan\" queries.\nfunc (n *node) iterate(dir direction, start, stop Item, includeStart bool, hit bool, iter ItemIterator) (bool, bool) {\n\tvar ok, found bool\n\tvar index int\n\tswitch dir {\n\tcase ascend:\n\t\tif start != nil {\n\t\t\tindex, _ = n.items.find(start)\n\t\t}\n\t\tfor i := index; i < len(n.items); i++ {\n\t\t\tif len(n.children) > 0 {\n\t\t\t\tif hit, ok = n.children[i].iterate(dir, start, stop, includeStart, hit, iter); !ok {\n\t\t\t\t\treturn hit, false\n\t\t\t\t}\n\t\t\t}\n\t\t\tif !includeStart && !hit && start != nil && !start.Less(n.items[i]) {\n\t\t\t\thit = true\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\thit = true\n\t\t\tif stop != nil && !n.items[i].Less(stop) {\n\t\t\t\treturn hit, false\n\t\t\t}\n\t\t\tif !iter(n.items[i]) {\n\t\t\t\treturn hit, false\n\t\t\t}\n\t\t}\n\t\tif len(n.children) > 0 {\n\t\t\tif hit, ok = n.children[len(n.children)-1].iterate(dir, start, stop, includeStart, hit, iter); !ok {\n\t\t\t\treturn hit, false\n\t\t\t}\n\t\t}\n\tcase descend:\n\t\tif start != nil {\n\t\t\tindex, found = n.items.find(start)\n\t\t\tif !found {\n\t\t\t\tindex = index - 1\n\t\t\t}\n\t\t} else {\n\t\t\tindex = len(n.items) - 1\n\t\t}\n\t\tfor i := index; i >= 0; i-- {\n\t\t\tif start != nil && !n.items[i].Less(start) {\n\t\t\t\tif !includeStart || hit || start.Less(n.items[i]) {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t}\n\t\t\tif len(n.children) > 0 {\n\t\t\t\tif hit, ok = n.children[i+1].iterate(dir, start, stop, includeStart, hit, iter); !ok {\n\t\t\t\t\treturn hit, false\n\t\t\t\t}\n\t\t\t}\n\t\t\tif stop != nil && !stop.Less(n.items[i]) {\n\t\t\t\treturn hit, false //\tcontinue\n\t\t\t}\n\t\t\thit = true\n\t\t\tif !iter(n.items[i]) {\n\t\t\t\treturn hit, false\n\t\t\t}\n\t\t}\n\t\tif len(n.children) > 0 {\n\t\t\tif hit, ok = n.children[0].iterate(dir, start, stop, includeStart, hit, iter); !ok {\n\t\t\t\treturn hit, false\n\t\t\t}\n\t\t}\n\t}\n\treturn hit, true\n}\n\n// Used for testing/debugging purposes.\nfunc (n *node) print(w io.Writer, level int) {\n\tfmt.Fprintf(w, \"%sNODE:%v\\n\", strings.Repeat(\"  \", level), n.items)\n\tfor _, c := range n.children {\n\t\tc.print(w, level+1)\n\t}\n}\n\n// BTree is an implementation of a B-Tree.\n//\n// BTree stores Item instances in an ordered structure, allowing easy insertion,\n// removal, and iteration.\n//\n// Write operations are not safe for concurrent mutation by multiple\n// goroutines, but Read operations are.\ntype BTree struct {\n\tdegree int\n\tlength int\n\troot   *node\n\tcow    *copyOnWriteContext\n}\n\n// copyOnWriteContext pointers determine node ownership... a tree with a write\n// context equivalent to a node's write context is allowed to modify that node.\n// A tree whose write context does not match a node's is not allowed to modify\n// it, and must create a new, writable copy (IE: it's a Clone).\n//\n// When doing any write operation, we maintain the invariant that the current\n// node's context is equal to the context of the tree that requested the write.\n// We do this by, before we descend into any node, creating a copy with the\n// correct context if the contexts don't match.\n//\n// Since the node we're currently visiting on any write has the requesting\n// tree's context, that node is modifiable in place.  Children of that node may\n// not share context, but before we descend into them, we'll make a mutable\n// copy.\ntype copyOnWriteContext struct {\n\tfreelist *FreeList\n}\n\n// Clone clones the btree, lazily.  Clone should not be called concurrently,\n// but the original tree (t) and the new tree (t2) can be used concurrently\n// once the Clone call completes.\n//\n// The internal tree structure of b is marked read-only and shared between t and\n// t2.  Writes to both t and t2 use copy-on-write logic, creating new nodes\n// whenever one of b's original nodes would have been modified.  Read operations\n// should have no performance degredation.  Write operations for both t and t2\n// will initially experience minor slow-downs caused by additional allocs and\n// copies due to the aforementioned copy-on-write logic, but should converge to\n// the original performance characteristics of the original tree.\nfunc (t *BTree) Clone() (t2 *BTree) {\n\t// Create two entirely new copy-on-write contexts.\n\t// This operation effectively creates three trees:\n\t//   the original, shared nodes (old b.cow)\n\t//   the new b.cow nodes\n\t//   the new out.cow nodes\n\tcow1, cow2 := *t.cow, *t.cow\n\tout := *t\n\tt.cow = &cow1\n\tout.cow = &cow2\n\treturn &out\n}\n\n// maxItems returns the max number of items to allow per node.\nfunc (t *BTree) maxItems() int {\n\treturn t.degree*2 - 1\n}\n\n// minItems returns the min number of items to allow per node (ignored for the\n// root node).\nfunc (t *BTree) minItems() int {\n\treturn t.degree - 1\n}\n\nfunc (c *copyOnWriteContext) newNode() (n *node) {\n\tn = c.freelist.newNode()\n\tn.cow = c\n\treturn\n}\n\ntype freeType int\n\nconst (\n\tftFreelistFull freeType = iota // node was freed (available for GC, not stored in freelist)\n\tftStored                       // node was stored in the freelist for later use\n\tftNotOwned                     // node was ignored by COW, since it's owned by another one\n)\n\n// freeNode frees a node within a given COW context, if it's owned by that\n// context.  It returns what happened to the node (see freeType const\n// documentation).\nfunc (c *copyOnWriteContext) freeNode(n *node) freeType {\n\tif n.cow == c {\n\t\t// clear to allow GC\n\t\tn.items.truncate(0)\n\t\tn.children.truncate(0)\n\t\tn.cow = nil\n\t\tif c.freelist.freeNode(n) {\n\t\t\treturn ftStored\n\t\t} else {\n\t\t\treturn ftFreelistFull\n\t\t}\n\t} else {\n\t\treturn ftNotOwned\n\t}\n}\n\n// ReplaceOrInsert adds the given item to the tree.  If an item in the tree\n// already equals the given one, it is removed from the tree and returned.\n// Otherwise, nil is returned.\n//\n// nil cannot be added to the tree (will panic).\nfunc (t *BTree) ReplaceOrInsert(item Item) Item {\n\tif item == nil {\n\t\tpanic(\"nil item being added to BTree\")\n\t}\n\tif t.root == nil {\n\t\tt.root = t.cow.newNode()\n\t\tt.root.items = append(t.root.items, item)\n\t\tt.length++\n\t\treturn nil\n\t} else {\n\t\tt.root = t.root.mutableFor(t.cow)\n\t\tif len(t.root.items) >= t.maxItems() {\n\t\t\titem2, second := t.root.split(t.maxItems() / 2)\n\t\t\toldroot := t.root\n\t\t\tt.root = t.cow.newNode()\n\t\t\tt.root.items = append(t.root.items, item2)\n\t\t\tt.root.children = append(t.root.children, oldroot, second)\n\t\t}\n\t}\n\tout := t.root.insert(item, t.maxItems())\n\tif out == nil {\n\t\tt.length++\n\t}\n\treturn out\n}\n\n// Delete removes an item equal to the passed in item from the tree, returning\n// it.  If no such item exists, returns nil.\nfunc (t *BTree) Delete(item Item) Item {\n\treturn t.deleteItem(item, removeItem)\n}\n\n// DeleteMin removes the smallest item in the tree and returns it.\n// If no such item exists, returns nil.\nfunc (t *BTree) DeleteMin() Item {\n\treturn t.deleteItem(nil, removeMin)\n}\n\n// DeleteMax removes the largest item in the tree and returns it.\n// If no such item exists, returns nil.\nfunc (t *BTree) DeleteMax() Item {\n\treturn t.deleteItem(nil, removeMax)\n}\n\nfunc (t *BTree) deleteItem(item Item, typ toRemove) Item {\n\tif t.root == nil || len(t.root.items) == 0 {\n\t\treturn nil\n\t}\n\tt.root = t.root.mutableFor(t.cow)\n\tout := t.root.remove(item, t.minItems(), typ)\n\tif len(t.root.items) == 0 && len(t.root.children) > 0 {\n\t\toldroot := t.root\n\t\tt.root = t.root.children[0]\n\t\tt.cow.freeNode(oldroot)\n\t}\n\tif out != nil {\n\t\tt.length--\n\t}\n\treturn out\n}\n\n// AscendRange calls the iterator for every value in the tree within the range\n// [greaterOrEqual, lessThan), until iterator returns false.\nfunc (t *BTree) AscendRange(greaterOrEqual, lessThan Item, iterator ItemIterator) {\n\tif t.root == nil {\n\t\treturn\n\t}\n\tt.root.iterate(ascend, greaterOrEqual, lessThan, true, false, iterator)\n}\n\n// AscendLessThan calls the iterator for every value in the tree within the range\n// [first, pivot), until iterator returns false.\nfunc (t *BTree) AscendLessThan(pivot Item, iterator ItemIterator) {\n\tif t.root == nil {\n\t\treturn\n\t}\n\tt.root.iterate(ascend, nil, pivot, false, false, iterator)\n}\n\n// AscendGreaterOrEqual calls the iterator for every value in the tree within\n// the range [pivot, last], until iterator returns false.\nfunc (t *BTree) AscendGreaterOrEqual(pivot Item, iterator ItemIterator) {\n\tif t.root == nil {\n\t\treturn\n\t}\n\tt.root.iterate(ascend, pivot, nil, true, false, iterator)\n}\n\n// Ascend calls the iterator for every value in the tree within the range\n// [first, last], until iterator returns false.\nfunc (t *BTree) Ascend(iterator ItemIterator) {\n\tif t.root == nil {\n\t\treturn\n\t}\n\tt.root.iterate(ascend, nil, nil, false, false, iterator)\n}\n\n// DescendRange calls the iterator for every value in the tree within the range\n// [lessOrEqual, greaterThan), until iterator returns false.\nfunc (t *BTree) DescendRange(lessOrEqual, greaterThan Item, iterator ItemIterator) {\n\tif t.root == nil {\n\t\treturn\n\t}\n\tt.root.iterate(descend, lessOrEqual, greaterThan, true, false, iterator)\n}\n\n// DescendLessOrEqual calls the iterator for every value in the tree within the range\n// [pivot, first], until iterator returns false.\nfunc (t *BTree) DescendLessOrEqual(pivot Item, iterator ItemIterator) {\n\tif t.root == nil {\n\t\treturn\n\t}\n\tt.root.iterate(descend, pivot, nil, true, false, iterator)\n}\n\n// DescendGreaterThan calls the iterator for every value in the tree within\n// the range [last, pivot), until iterator returns false.\nfunc (t *BTree) DescendGreaterThan(pivot Item, iterator ItemIterator) {\n\tif t.root == nil {\n\t\treturn\n\t}\n\tt.root.iterate(descend, nil, pivot, false, false, iterator)\n}\n\n// Descend calls the iterator for every value in the tree within the range\n// [last, first], until iterator returns false.\nfunc (t *BTree) Descend(iterator ItemIterator) {\n\tif t.root == nil {\n\t\treturn\n\t}\n\tt.root.iterate(descend, nil, nil, false, false, iterator)\n}\n\n// Get looks for the key item in the tree, returning it.  It returns nil if\n// unable to find that item.\nfunc (t *BTree) Get(key Item) Item {\n\tif t.root == nil {\n\t\treturn nil\n\t}\n\treturn t.root.get(key)\n}\n\n// Min returns the smallest item in the tree, or nil if the tree is empty.\nfunc (t *BTree) Min() Item {\n\treturn min(t.root)\n}\n\n// Max returns the largest item in the tree, or nil if the tree is empty.\nfunc (t *BTree) Max() Item {\n\treturn max(t.root)\n}\n\n// Has returns true if the given key is in the tree.\nfunc (t *BTree) Has(key Item) bool {\n\treturn t.Get(key) != nil\n}\n\n// Len returns the number of items currently in the tree.\nfunc (t *BTree) Len() int {\n\treturn t.length\n}\n\n// Clear removes all items from the btree.  If addNodesToFreelist is true,\n// t's nodes are added to its freelist as part of this call, until the freelist\n// is full.  Otherwise, the root node is simply dereferenced and the subtree\n// left to Go's normal GC processes.\n//\n// This can be much faster\n// than calling Delete on all elements, because that requires finding/removing\n// each element in the tree and updating the tree accordingly.  It also is\n// somewhat faster than creating a new tree to replace the old one, because\n// nodes from the old tree are reclaimed into the freelist for use by the new\n// one, instead of being lost to the garbage collector.\n//\n// This call takes:\n//   O(1): when addNodesToFreelist is false, this is a single operation.\n//   O(1): when the freelist is already full, it breaks out immediately\n//   O(freelist size):  when the freelist is empty and the nodes are all owned\n//       by this tree, nodes are added to the freelist until full.\n//   O(tree size):  when all nodes are owned by another tree, all nodes are\n//       iterated over looking for nodes to add to the freelist, and due to\n//       ownership, none are.\nfunc (t *BTree) Clear(addNodesToFreelist bool) {\n\tif t.root != nil && addNodesToFreelist {\n\t\tt.root.reset(t.cow)\n\t}\n\tt.root, t.length = nil, 0\n}\n\n// reset returns a subtree to the freelist.  It breaks out immediately if the\n// freelist is full, since the only benefit of iterating is to fill that\n// freelist up.  Returns true if parent reset call should continue.\nfunc (n *node) reset(c *copyOnWriteContext) bool {\n\tfor _, child := range n.children {\n\t\tif !child.reset(c) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn c.freeNode(n) != ftFreelistFull\n}\n\n// Int implements the Item interface for integers.\ntype Int int\n\n// Less returns true if int(a) < int(b).\nfunc (a Int) Less(b Item) bool {\n\treturn a < b.(Int)\n}\n"
        },
        {
          "name": "btree_generic.go",
          "type": "blob",
          "size": 35.2001953125,
          "content": "// Copyright 2014-2022 Google Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n//go:build go1.18\n// +build go1.18\n\n// In Go 1.18 and beyond, a BTreeG generic is created, and BTree is a specific\n// instantiation of that generic for the Item interface, with a backwards-\n// compatible API.  Before go1.18, generics are not supported,\n// and BTree is just an implementation based around the Item interface.\n\n// Package btree implements in-memory B-Trees of arbitrary degree.\n//\n// btree implements an in-memory B-Tree for use as an ordered data structure.\n// It is not meant for persistent storage solutions.\n//\n// It has a flatter structure than an equivalent red-black or other binary tree,\n// which in some cases yields better memory usage and/or performance.\n// See some discussion on the matter here:\n//   http://google-opensource.blogspot.com/2013/01/c-containers-that-save-memory-and-time.html\n// Note, though, that this project is in no way related to the C++ B-Tree\n// implementation written about there.\n//\n// Within this tree, each node contains a slice of items and a (possibly nil)\n// slice of children.  For basic numeric values or raw structs, this can cause\n// efficiency differences when compared to equivalent C++ template code that\n// stores values in arrays within the node:\n//   * Due to the overhead of storing values as interfaces (each\n//     value needs to be stored as the value itself, then 2 words for the\n//     interface pointing to that value and its type), resulting in higher\n//     memory use.\n//   * Since interfaces can point to values anywhere in memory, values are\n//     most likely not stored in contiguous blocks, resulting in a higher\n//     number of cache misses.\n// These issues don't tend to matter, though, when working with strings or other\n// heap-allocated structures, since C++-equivalent structures also must store\n// pointers and also distribute their values across the heap.\n//\n// This implementation is designed to be a drop-in replacement to gollrb.LLRB\n// trees, (http://github.com/petar/gollrb), an excellent and probably the most\n// widely used ordered tree implementation in the Go ecosystem currently.\n// Its functions, therefore, exactly mirror those of\n// llrb.LLRB where possible.  Unlike gollrb, though, we currently don't\n// support storing multiple equivalent values.\n//\n// There are two implementations; those suffixed with 'G' are generics, usable\n// for any type, and require a passed-in \"less\" function to define their ordering.\n// Those without this prefix are specific to the 'Item' interface, and use\n// its 'Less' function for ordering.\npackage btree\n\nimport (\n\t\"fmt\"\n\t\"io\"\n\t\"sort\"\n\t\"strings\"\n\t\"sync\"\n)\n\n// Item represents a single object in the tree.\ntype Item interface {\n\t// Less tests whether the current item is less than the given argument.\n\t//\n\t// This must provide a strict weak ordering.\n\t// If !a.Less(b) && !b.Less(a), we treat this to mean a == b (i.e. we can only\n\t// hold one of either a or b in the tree).\n\tLess(than Item) bool\n}\n\nconst (\n\tDefaultFreeListSize = 32\n)\n\n// FreeListG represents a free list of btree nodes. By default each\n// BTree has its own FreeList, but multiple BTrees can share the same\n// FreeList, in particular when they're created with Clone.\n// Two Btrees using the same freelist are safe for concurrent write access.\ntype FreeListG[T any] struct {\n\tmu       sync.Mutex\n\tfreelist []*node[T]\n}\n\n// NewFreeListG creates a new free list.\n// size is the maximum size of the returned free list.\nfunc NewFreeListG[T any](size int) *FreeListG[T] {\n\treturn &FreeListG[T]{freelist: make([]*node[T], 0, size)}\n}\n\nfunc (f *FreeListG[T]) newNode() (n *node[T]) {\n\tf.mu.Lock()\n\tindex := len(f.freelist) - 1\n\tif index < 0 {\n\t\tf.mu.Unlock()\n\t\treturn new(node[T])\n\t}\n\tn = f.freelist[index]\n\tf.freelist[index] = nil\n\tf.freelist = f.freelist[:index]\n\tf.mu.Unlock()\n\treturn\n}\n\nfunc (f *FreeListG[T]) freeNode(n *node[T]) (out bool) {\n\tf.mu.Lock()\n\tif len(f.freelist) < cap(f.freelist) {\n\t\tf.freelist = append(f.freelist, n)\n\t\tout = true\n\t}\n\tf.mu.Unlock()\n\treturn\n}\n\n// ItemIteratorG allows callers of {A/De}scend* to iterate in-order over portions of\n// the tree.  When this function returns false, iteration will stop and the\n// associated Ascend* function will immediately return.\ntype ItemIteratorG[T any] func(item T) bool\n\n// Ordered represents the set of types for which the '<' operator work.\ntype Ordered interface {\n\t~int | ~int8 | ~int16 | ~int32 | ~int64 | ~uint | ~uint8 | ~uint16 | ~uint32 | ~uint64 | ~float32 | ~float64 | ~string\n}\n\n// Less[T] returns a default LessFunc that uses the '<' operator for types that support it.\nfunc Less[T Ordered]() LessFunc[T] {\n\treturn func(a, b T) bool { return a < b }\n}\n\n// NewOrderedG creates a new B-Tree for ordered types.\nfunc NewOrderedG[T Ordered](degree int) *BTreeG[T] {\n\treturn NewG[T](degree, Less[T]())\n}\n\n// NewG creates a new B-Tree with the given degree.\n//\n// NewG(2), for example, will create a 2-3-4 tree (each node contains 1-3 items\n// and 2-4 children).\n//\n// The passed-in LessFunc determines how objects of type T are ordered.\nfunc NewG[T any](degree int, less LessFunc[T]) *BTreeG[T] {\n\treturn NewWithFreeListG(degree, less, NewFreeListG[T](DefaultFreeListSize))\n}\n\n// NewWithFreeListG creates a new B-Tree that uses the given node free list.\nfunc NewWithFreeListG[T any](degree int, less LessFunc[T], f *FreeListG[T]) *BTreeG[T] {\n\tif degree <= 1 {\n\t\tpanic(\"bad degree\")\n\t}\n\treturn &BTreeG[T]{\n\t\tdegree: degree,\n\t\tcow:    &copyOnWriteContext[T]{freelist: f, less: less},\n\t}\n}\n\n// items stores items in a node.\ntype items[T any] []T\n\n// insertAt inserts a value into the given index, pushing all subsequent values\n// forward.\nfunc (s *items[T]) insertAt(index int, item T) {\n\tvar zero T\n\t*s = append(*s, zero)\n\tif index < len(*s) {\n\t\tcopy((*s)[index+1:], (*s)[index:])\n\t}\n\t(*s)[index] = item\n}\n\n// removeAt removes a value at a given index, pulling all subsequent values\n// back.\nfunc (s *items[T]) removeAt(index int) T {\n\titem := (*s)[index]\n\tcopy((*s)[index:], (*s)[index+1:])\n\tvar zero T\n\t(*s)[len(*s)-1] = zero\n\t*s = (*s)[:len(*s)-1]\n\treturn item\n}\n\n// pop removes and returns the last element in the list.\nfunc (s *items[T]) pop() (out T) {\n\tindex := len(*s) - 1\n\tout = (*s)[index]\n\tvar zero T\n\t(*s)[index] = zero\n\t*s = (*s)[:index]\n\treturn\n}\n\n// truncate truncates this instance at index so that it contains only the\n// first index items. index must be less than or equal to length.\nfunc (s *items[T]) truncate(index int) {\n\tvar toClear items[T]\n\t*s, toClear = (*s)[:index], (*s)[index:]\n\tvar zero T\n\tfor i := 0; i < len(toClear); i++ {\n\t\ttoClear[i] = zero\n\t}\n}\n\n// find returns the index where the given item should be inserted into this\n// list.  'found' is true if the item already exists in the list at the given\n// index.\nfunc (s items[T]) find(item T, less func(T, T) bool) (index int, found bool) {\n\ti := sort.Search(len(s), func(i int) bool {\n\t\treturn less(item, s[i])\n\t})\n\tif i > 0 && !less(s[i-1], item) {\n\t\treturn i - 1, true\n\t}\n\treturn i, false\n}\n\n// node is an internal node in a tree.\n//\n// It must at all times maintain the invariant that either\n//   * len(children) == 0, len(items) unconstrained\n//   * len(children) == len(items) + 1\ntype node[T any] struct {\n\titems    items[T]\n\tchildren items[*node[T]]\n\tcow      *copyOnWriteContext[T]\n}\n\nfunc (n *node[T]) mutableFor(cow *copyOnWriteContext[T]) *node[T] {\n\tif n.cow == cow {\n\t\treturn n\n\t}\n\tout := cow.newNode()\n\tif cap(out.items) >= len(n.items) {\n\t\tout.items = out.items[:len(n.items)]\n\t} else {\n\t\tout.items = make(items[T], len(n.items), cap(n.items))\n\t}\n\tcopy(out.items, n.items)\n\t// Copy children\n\tif cap(out.children) >= len(n.children) {\n\t\tout.children = out.children[:len(n.children)]\n\t} else {\n\t\tout.children = make(items[*node[T]], len(n.children), cap(n.children))\n\t}\n\tcopy(out.children, n.children)\n\treturn out\n}\n\nfunc (n *node[T]) mutableChild(i int) *node[T] {\n\tc := n.children[i].mutableFor(n.cow)\n\tn.children[i] = c\n\treturn c\n}\n\n// split splits the given node at the given index.  The current node shrinks,\n// and this function returns the item that existed at that index and a new node\n// containing all items/children after it.\nfunc (n *node[T]) split(i int) (T, *node[T]) {\n\titem := n.items[i]\n\tnext := n.cow.newNode()\n\tnext.items = append(next.items, n.items[i+1:]...)\n\tn.items.truncate(i)\n\tif len(n.children) > 0 {\n\t\tnext.children = append(next.children, n.children[i+1:]...)\n\t\tn.children.truncate(i + 1)\n\t}\n\treturn item, next\n}\n\n// maybeSplitChild checks if a child should be split, and if so splits it.\n// Returns whether or not a split occurred.\nfunc (n *node[T]) maybeSplitChild(i, maxItems int) bool {\n\tif len(n.children[i].items) < maxItems {\n\t\treturn false\n\t}\n\tfirst := n.mutableChild(i)\n\titem, second := first.split(maxItems / 2)\n\tn.items.insertAt(i, item)\n\tn.children.insertAt(i+1, second)\n\treturn true\n}\n\n// insert inserts an item into the subtree rooted at this node, making sure\n// no nodes in the subtree exceed maxItems items.  Should an equivalent item be\n// be found/replaced by insert, it will be returned.\nfunc (n *node[T]) insert(item T, maxItems int) (_ T, _ bool) {\n\ti, found := n.items.find(item, n.cow.less)\n\tif found {\n\t\tout := n.items[i]\n\t\tn.items[i] = item\n\t\treturn out, true\n\t}\n\tif len(n.children) == 0 {\n\t\tn.items.insertAt(i, item)\n\t\treturn\n\t}\n\tif n.maybeSplitChild(i, maxItems) {\n\t\tinTree := n.items[i]\n\t\tswitch {\n\t\tcase n.cow.less(item, inTree):\n\t\t\t// no change, we want first split node\n\t\tcase n.cow.less(inTree, item):\n\t\t\ti++ // we want second split node\n\t\tdefault:\n\t\t\tout := n.items[i]\n\t\t\tn.items[i] = item\n\t\t\treturn out, true\n\t\t}\n\t}\n\treturn n.mutableChild(i).insert(item, maxItems)\n}\n\n// get finds the given key in the subtree and returns it.\nfunc (n *node[T]) get(key T) (_ T, _ bool) {\n\ti, found := n.items.find(key, n.cow.less)\n\tif found {\n\t\treturn n.items[i], true\n\t} else if len(n.children) > 0 {\n\t\treturn n.children[i].get(key)\n\t}\n\treturn\n}\n\n// min returns the first item in the subtree.\nfunc min[T any](n *node[T]) (_ T, found bool) {\n\tif n == nil {\n\t\treturn\n\t}\n\tfor len(n.children) > 0 {\n\t\tn = n.children[0]\n\t}\n\tif len(n.items) == 0 {\n\t\treturn\n\t}\n\treturn n.items[0], true\n}\n\n// max returns the last item in the subtree.\nfunc max[T any](n *node[T]) (_ T, found bool) {\n\tif n == nil {\n\t\treturn\n\t}\n\tfor len(n.children) > 0 {\n\t\tn = n.children[len(n.children)-1]\n\t}\n\tif len(n.items) == 0 {\n\t\treturn\n\t}\n\treturn n.items[len(n.items)-1], true\n}\n\n// toRemove details what item to remove in a node.remove call.\ntype toRemove int\n\nconst (\n\tremoveItem toRemove = iota // removes the given item\n\tremoveMin                  // removes smallest item in the subtree\n\tremoveMax                  // removes largest item in the subtree\n)\n\n// remove removes an item from the subtree rooted at this node.\nfunc (n *node[T]) remove(item T, minItems int, typ toRemove) (_ T, _ bool) {\n\tvar i int\n\tvar found bool\n\tswitch typ {\n\tcase removeMax:\n\t\tif len(n.children) == 0 {\n\t\t\treturn n.items.pop(), true\n\t\t}\n\t\ti = len(n.items)\n\tcase removeMin:\n\t\tif len(n.children) == 0 {\n\t\t\treturn n.items.removeAt(0), true\n\t\t}\n\t\ti = 0\n\tcase removeItem:\n\t\ti, found = n.items.find(item, n.cow.less)\n\t\tif len(n.children) == 0 {\n\t\t\tif found {\n\t\t\t\treturn n.items.removeAt(i), true\n\t\t\t}\n\t\t\treturn\n\t\t}\n\tdefault:\n\t\tpanic(\"invalid type\")\n\t}\n\t// If we get to here, we have children.\n\tif len(n.children[i].items) <= minItems {\n\t\treturn n.growChildAndRemove(i, item, minItems, typ)\n\t}\n\tchild := n.mutableChild(i)\n\t// Either we had enough items to begin with, or we've done some\n\t// merging/stealing, because we've got enough now and we're ready to return\n\t// stuff.\n\tif found {\n\t\t// The item exists at index 'i', and the child we've selected can give us a\n\t\t// predecessor, since if we've gotten here it's got > minItems items in it.\n\t\tout := n.items[i]\n\t\t// We use our special-case 'remove' call with typ=maxItem to pull the\n\t\t// predecessor of item i (the rightmost leaf of our immediate left child)\n\t\t// and set it into where we pulled the item from.\n\t\tvar zero T\n\t\tn.items[i], _ = child.remove(zero, minItems, removeMax)\n\t\treturn out, true\n\t}\n\t// Final recursive call.  Once we're here, we know that the item isn't in this\n\t// node and that the child is big enough to remove from.\n\treturn child.remove(item, minItems, typ)\n}\n\n// growChildAndRemove grows child 'i' to make sure it's possible to remove an\n// item from it while keeping it at minItems, then calls remove to actually\n// remove it.\n//\n// Most documentation says we have to do two sets of special casing:\n//   1) item is in this node\n//   2) item is in child\n// In both cases, we need to handle the two subcases:\n//   A) node has enough values that it can spare one\n//   B) node doesn't have enough values\n// For the latter, we have to check:\n//   a) left sibling has node to spare\n//   b) right sibling has node to spare\n//   c) we must merge\n// To simplify our code here, we handle cases #1 and #2 the same:\n// If a node doesn't have enough items, we make sure it does (using a,b,c).\n// We then simply redo our remove call, and the second time (regardless of\n// whether we're in case 1 or 2), we'll have enough items and can guarantee\n// that we hit case A.\nfunc (n *node[T]) growChildAndRemove(i int, item T, minItems int, typ toRemove) (T, bool) {\n\tif i > 0 && len(n.children[i-1].items) > minItems {\n\t\t// Steal from left child\n\t\tchild := n.mutableChild(i)\n\t\tstealFrom := n.mutableChild(i - 1)\n\t\tstolenItem := stealFrom.items.pop()\n\t\tchild.items.insertAt(0, n.items[i-1])\n\t\tn.items[i-1] = stolenItem\n\t\tif len(stealFrom.children) > 0 {\n\t\t\tchild.children.insertAt(0, stealFrom.children.pop())\n\t\t}\n\t} else if i < len(n.items) && len(n.children[i+1].items) > minItems {\n\t\t// steal from right child\n\t\tchild := n.mutableChild(i)\n\t\tstealFrom := n.mutableChild(i + 1)\n\t\tstolenItem := stealFrom.items.removeAt(0)\n\t\tchild.items = append(child.items, n.items[i])\n\t\tn.items[i] = stolenItem\n\t\tif len(stealFrom.children) > 0 {\n\t\t\tchild.children = append(child.children, stealFrom.children.removeAt(0))\n\t\t}\n\t} else {\n\t\tif i >= len(n.items) {\n\t\t\ti--\n\t\t}\n\t\tchild := n.mutableChild(i)\n\t\t// merge with right child\n\t\tmergeItem := n.items.removeAt(i)\n\t\tmergeChild := n.children.removeAt(i + 1)\n\t\tchild.items = append(child.items, mergeItem)\n\t\tchild.items = append(child.items, mergeChild.items...)\n\t\tchild.children = append(child.children, mergeChild.children...)\n\t\tn.cow.freeNode(mergeChild)\n\t}\n\treturn n.remove(item, minItems, typ)\n}\n\ntype direction int\n\nconst (\n\tdescend = direction(-1)\n\tascend  = direction(+1)\n)\n\ntype optionalItem[T any] struct {\n\titem  T\n\tvalid bool\n}\n\nfunc optional[T any](item T) optionalItem[T] {\n\treturn optionalItem[T]{item: item, valid: true}\n}\nfunc empty[T any]() optionalItem[T] {\n\treturn optionalItem[T]{}\n}\n\n// iterate provides a simple method for iterating over elements in the tree.\n//\n// When ascending, the 'start' should be less than 'stop' and when descending,\n// the 'start' should be greater than 'stop'. Setting 'includeStart' to true\n// will force the iterator to include the first item when it equals 'start',\n// thus creating a \"greaterOrEqual\" or \"lessThanEqual\" rather than just a\n// \"greaterThan\" or \"lessThan\" queries.\nfunc (n *node[T]) iterate(dir direction, start, stop optionalItem[T], includeStart bool, hit bool, iter ItemIteratorG[T]) (bool, bool) {\n\tvar ok, found bool\n\tvar index int\n\tswitch dir {\n\tcase ascend:\n\t\tif start.valid {\n\t\t\tindex, _ = n.items.find(start.item, n.cow.less)\n\t\t}\n\t\tfor i := index; i < len(n.items); i++ {\n\t\t\tif len(n.children) > 0 {\n\t\t\t\tif hit, ok = n.children[i].iterate(dir, start, stop, includeStart, hit, iter); !ok {\n\t\t\t\t\treturn hit, false\n\t\t\t\t}\n\t\t\t}\n\t\t\tif !includeStart && !hit && start.valid && !n.cow.less(start.item, n.items[i]) {\n\t\t\t\thit = true\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\thit = true\n\t\t\tif stop.valid && !n.cow.less(n.items[i], stop.item) {\n\t\t\t\treturn hit, false\n\t\t\t}\n\t\t\tif !iter(n.items[i]) {\n\t\t\t\treturn hit, false\n\t\t\t}\n\t\t}\n\t\tif len(n.children) > 0 {\n\t\t\tif hit, ok = n.children[len(n.children)-1].iterate(dir, start, stop, includeStart, hit, iter); !ok {\n\t\t\t\treturn hit, false\n\t\t\t}\n\t\t}\n\tcase descend:\n\t\tif start.valid {\n\t\t\tindex, found = n.items.find(start.item, n.cow.less)\n\t\t\tif !found {\n\t\t\t\tindex = index - 1\n\t\t\t}\n\t\t} else {\n\t\t\tindex = len(n.items) - 1\n\t\t}\n\t\tfor i := index; i >= 0; i-- {\n\t\t\tif start.valid && !n.cow.less(n.items[i], start.item) {\n\t\t\t\tif !includeStart || hit || n.cow.less(start.item, n.items[i]) {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t}\n\t\t\tif len(n.children) > 0 {\n\t\t\t\tif hit, ok = n.children[i+1].iterate(dir, start, stop, includeStart, hit, iter); !ok {\n\t\t\t\t\treturn hit, false\n\t\t\t\t}\n\t\t\t}\n\t\t\tif stop.valid && !n.cow.less(stop.item, n.items[i]) {\n\t\t\t\treturn hit, false //\tcontinue\n\t\t\t}\n\t\t\thit = true\n\t\t\tif !iter(n.items[i]) {\n\t\t\t\treturn hit, false\n\t\t\t}\n\t\t}\n\t\tif len(n.children) > 0 {\n\t\t\tif hit, ok = n.children[0].iterate(dir, start, stop, includeStart, hit, iter); !ok {\n\t\t\t\treturn hit, false\n\t\t\t}\n\t\t}\n\t}\n\treturn hit, true\n}\n\n// print is used for testing/debugging purposes.\nfunc (n *node[T]) print(w io.Writer, level int) {\n\tfmt.Fprintf(w, \"%sNODE:%v\\n\", strings.Repeat(\"  \", level), n.items)\n\tfor _, c := range n.children {\n\t\tc.print(w, level+1)\n\t}\n}\n\n// BTreeG is a generic implementation of a B-Tree.\n//\n// BTreeG stores items of type T in an ordered structure, allowing easy insertion,\n// removal, and iteration.\n//\n// Write operations are not safe for concurrent mutation by multiple\n// goroutines, but Read operations are.\ntype BTreeG[T any] struct {\n\tdegree int\n\tlength int\n\troot   *node[T]\n\tcow    *copyOnWriteContext[T]\n}\n\n// LessFunc[T] determines how to order a type 'T'.  It should implement a strict\n// ordering, and should return true if within that ordering, 'a' < 'b'.\ntype LessFunc[T any] func(a, b T) bool\n\n// copyOnWriteContext pointers determine node ownership... a tree with a write\n// context equivalent to a node's write context is allowed to modify that node.\n// A tree whose write context does not match a node's is not allowed to modify\n// it, and must create a new, writable copy (IE: it's a Clone).\n//\n// When doing any write operation, we maintain the invariant that the current\n// node's context is equal to the context of the tree that requested the write.\n// We do this by, before we descend into any node, creating a copy with the\n// correct context if the contexts don't match.\n//\n// Since the node we're currently visiting on any write has the requesting\n// tree's context, that node is modifiable in place.  Children of that node may\n// not share context, but before we descend into them, we'll make a mutable\n// copy.\ntype copyOnWriteContext[T any] struct {\n\tfreelist *FreeListG[T]\n\tless     LessFunc[T]\n}\n\n// Clone clones the btree, lazily.  Clone should not be called concurrently,\n// but the original tree (t) and the new tree (t2) can be used concurrently\n// once the Clone call completes.\n//\n// The internal tree structure of b is marked read-only and shared between t and\n// t2.  Writes to both t and t2 use copy-on-write logic, creating new nodes\n// whenever one of b's original nodes would have been modified.  Read operations\n// should have no performance degredation.  Write operations for both t and t2\n// will initially experience minor slow-downs caused by additional allocs and\n// copies due to the aforementioned copy-on-write logic, but should converge to\n// the original performance characteristics of the original tree.\nfunc (t *BTreeG[T]) Clone() (t2 *BTreeG[T]) {\n\t// Create two entirely new copy-on-write contexts.\n\t// This operation effectively creates three trees:\n\t//   the original, shared nodes (old b.cow)\n\t//   the new b.cow nodes\n\t//   the new out.cow nodes\n\tcow1, cow2 := *t.cow, *t.cow\n\tout := *t\n\tt.cow = &cow1\n\tout.cow = &cow2\n\treturn &out\n}\n\n// maxItems returns the max number of items to allow per node.\nfunc (t *BTreeG[T]) maxItems() int {\n\treturn t.degree*2 - 1\n}\n\n// minItems returns the min number of items to allow per node (ignored for the\n// root node).\nfunc (t *BTreeG[T]) minItems() int {\n\treturn t.degree - 1\n}\n\nfunc (c *copyOnWriteContext[T]) newNode() (n *node[T]) {\n\tn = c.freelist.newNode()\n\tn.cow = c\n\treturn\n}\n\ntype freeType int\n\nconst (\n\tftFreelistFull freeType = iota // node was freed (available for GC, not stored in freelist)\n\tftStored                       // node was stored in the freelist for later use\n\tftNotOwned                     // node was ignored by COW, since it's owned by another one\n)\n\n// freeNode frees a node within a given COW context, if it's owned by that\n// context.  It returns what happened to the node (see freeType const\n// documentation).\nfunc (c *copyOnWriteContext[T]) freeNode(n *node[T]) freeType {\n\tif n.cow == c {\n\t\t// clear to allow GC\n\t\tn.items.truncate(0)\n\t\tn.children.truncate(0)\n\t\tn.cow = nil\n\t\tif c.freelist.freeNode(n) {\n\t\t\treturn ftStored\n\t\t} else {\n\t\t\treturn ftFreelistFull\n\t\t}\n\t} else {\n\t\treturn ftNotOwned\n\t}\n}\n\n// ReplaceOrInsert adds the given item to the tree.  If an item in the tree\n// already equals the given one, it is removed from the tree and returned,\n// and the second return value is true.  Otherwise, (zeroValue, false)\n//\n// nil cannot be added to the tree (will panic).\nfunc (t *BTreeG[T]) ReplaceOrInsert(item T) (_ T, _ bool) {\n\tif t.root == nil {\n\t\tt.root = t.cow.newNode()\n\t\tt.root.items = append(t.root.items, item)\n\t\tt.length++\n\t\treturn\n\t} else {\n\t\tt.root = t.root.mutableFor(t.cow)\n\t\tif len(t.root.items) >= t.maxItems() {\n\t\t\titem2, second := t.root.split(t.maxItems() / 2)\n\t\t\toldroot := t.root\n\t\t\tt.root = t.cow.newNode()\n\t\t\tt.root.items = append(t.root.items, item2)\n\t\t\tt.root.children = append(t.root.children, oldroot, second)\n\t\t}\n\t}\n\tout, outb := t.root.insert(item, t.maxItems())\n\tif !outb {\n\t\tt.length++\n\t}\n\treturn out, outb\n}\n\n// Delete removes an item equal to the passed in item from the tree, returning\n// it.  If no such item exists, returns (zeroValue, false).\nfunc (t *BTreeG[T]) Delete(item T) (T, bool) {\n\treturn t.deleteItem(item, removeItem)\n}\n\n// DeleteMin removes the smallest item in the tree and returns it.\n// If no such item exists, returns (zeroValue, false).\nfunc (t *BTreeG[T]) DeleteMin() (T, bool) {\n\tvar zero T\n\treturn t.deleteItem(zero, removeMin)\n}\n\n// DeleteMax removes the largest item in the tree and returns it.\n// If no such item exists, returns (zeroValue, false).\nfunc (t *BTreeG[T]) DeleteMax() (T, bool) {\n\tvar zero T\n\treturn t.deleteItem(zero, removeMax)\n}\n\nfunc (t *BTreeG[T]) deleteItem(item T, typ toRemove) (_ T, _ bool) {\n\tif t.root == nil || len(t.root.items) == 0 {\n\t\treturn\n\t}\n\tt.root = t.root.mutableFor(t.cow)\n\tout, outb := t.root.remove(item, t.minItems(), typ)\n\tif len(t.root.items) == 0 && len(t.root.children) > 0 {\n\t\toldroot := t.root\n\t\tt.root = t.root.children[0]\n\t\tt.cow.freeNode(oldroot)\n\t}\n\tif outb {\n\t\tt.length--\n\t}\n\treturn out, outb\n}\n\n// AscendRange calls the iterator for every value in the tree within the range\n// [greaterOrEqual, lessThan), until iterator returns false.\nfunc (t *BTreeG[T]) AscendRange(greaterOrEqual, lessThan T, iterator ItemIteratorG[T]) {\n\tif t.root == nil {\n\t\treturn\n\t}\n\tt.root.iterate(ascend, optional[T](greaterOrEqual), optional[T](lessThan), true, false, iterator)\n}\n\n// AscendLessThan calls the iterator for every value in the tree within the range\n// [first, pivot), until iterator returns false.\nfunc (t *BTreeG[T]) AscendLessThan(pivot T, iterator ItemIteratorG[T]) {\n\tif t.root == nil {\n\t\treturn\n\t}\n\tt.root.iterate(ascend, empty[T](), optional(pivot), false, false, iterator)\n}\n\n// AscendGreaterOrEqual calls the iterator for every value in the tree within\n// the range [pivot, last], until iterator returns false.\nfunc (t *BTreeG[T]) AscendGreaterOrEqual(pivot T, iterator ItemIteratorG[T]) {\n\tif t.root == nil {\n\t\treturn\n\t}\n\tt.root.iterate(ascend, optional[T](pivot), empty[T](), true, false, iterator)\n}\n\n// Ascend calls the iterator for every value in the tree within the range\n// [first, last], until iterator returns false.\nfunc (t *BTreeG[T]) Ascend(iterator ItemIteratorG[T]) {\n\tif t.root == nil {\n\t\treturn\n\t}\n\tt.root.iterate(ascend, empty[T](), empty[T](), false, false, iterator)\n}\n\n// DescendRange calls the iterator for every value in the tree within the range\n// [lessOrEqual, greaterThan), until iterator returns false.\nfunc (t *BTreeG[T]) DescendRange(lessOrEqual, greaterThan T, iterator ItemIteratorG[T]) {\n\tif t.root == nil {\n\t\treturn\n\t}\n\tt.root.iterate(descend, optional[T](lessOrEqual), optional[T](greaterThan), true, false, iterator)\n}\n\n// DescendLessOrEqual calls the iterator for every value in the tree within the range\n// [pivot, first], until iterator returns false.\nfunc (t *BTreeG[T]) DescendLessOrEqual(pivot T, iterator ItemIteratorG[T]) {\n\tif t.root == nil {\n\t\treturn\n\t}\n\tt.root.iterate(descend, optional[T](pivot), empty[T](), true, false, iterator)\n}\n\n// DescendGreaterThan calls the iterator for every value in the tree within\n// the range [last, pivot), until iterator returns false.\nfunc (t *BTreeG[T]) DescendGreaterThan(pivot T, iterator ItemIteratorG[T]) {\n\tif t.root == nil {\n\t\treturn\n\t}\n\tt.root.iterate(descend, empty[T](), optional[T](pivot), false, false, iterator)\n}\n\n// Descend calls the iterator for every value in the tree within the range\n// [last, first], until iterator returns false.\nfunc (t *BTreeG[T]) Descend(iterator ItemIteratorG[T]) {\n\tif t.root == nil {\n\t\treturn\n\t}\n\tt.root.iterate(descend, empty[T](), empty[T](), false, false, iterator)\n}\n\n// Get looks for the key item in the tree, returning it.  It returns\n// (zeroValue, false) if unable to find that item.\nfunc (t *BTreeG[T]) Get(key T) (_ T, _ bool) {\n\tif t.root == nil {\n\t\treturn\n\t}\n\treturn t.root.get(key)\n}\n\n// Min returns the smallest item in the tree, or (zeroValue, false) if the tree is empty.\nfunc (t *BTreeG[T]) Min() (_ T, _ bool) {\n\treturn min(t.root)\n}\n\n// Max returns the largest item in the tree, or (zeroValue, false) if the tree is empty.\nfunc (t *BTreeG[T]) Max() (_ T, _ bool) {\n\treturn max(t.root)\n}\n\n// Has returns true if the given key is in the tree.\nfunc (t *BTreeG[T]) Has(key T) bool {\n\t_, ok := t.Get(key)\n\treturn ok\n}\n\n// Len returns the number of items currently in the tree.\nfunc (t *BTreeG[T]) Len() int {\n\treturn t.length\n}\n\n// Clear removes all items from the btree.  If addNodesToFreelist is true,\n// t's nodes are added to its freelist as part of this call, until the freelist\n// is full.  Otherwise, the root node is simply dereferenced and the subtree\n// left to Go's normal GC processes.\n//\n// This can be much faster\n// than calling Delete on all elements, because that requires finding/removing\n// each element in the tree and updating the tree accordingly.  It also is\n// somewhat faster than creating a new tree to replace the old one, because\n// nodes from the old tree are reclaimed into the freelist for use by the new\n// one, instead of being lost to the garbage collector.\n//\n// This call takes:\n//   O(1): when addNodesToFreelist is false, this is a single operation.\n//   O(1): when the freelist is already full, it breaks out immediately\n//   O(freelist size):  when the freelist is empty and the nodes are all owned\n//       by this tree, nodes are added to the freelist until full.\n//   O(tree size):  when all nodes are owned by another tree, all nodes are\n//       iterated over looking for nodes to add to the freelist, and due to\n//       ownership, none are.\nfunc (t *BTreeG[T]) Clear(addNodesToFreelist bool) {\n\tif t.root != nil && addNodesToFreelist {\n\t\tt.root.reset(t.cow)\n\t}\n\tt.root, t.length = nil, 0\n}\n\n// reset returns a subtree to the freelist.  It breaks out immediately if the\n// freelist is full, since the only benefit of iterating is to fill that\n// freelist up.  Returns true if parent reset call should continue.\nfunc (n *node[T]) reset(c *copyOnWriteContext[T]) bool {\n\tfor _, child := range n.children {\n\t\tif !child.reset(c) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn c.freeNode(n) != ftFreelistFull\n}\n\n// Int implements the Item interface for integers.\ntype Int int\n\n// Less returns true if int(a) < int(b).\nfunc (a Int) Less(b Item) bool {\n\treturn a < b.(Int)\n}\n\n// BTree is an implementation of a B-Tree.\n//\n// BTree stores Item instances in an ordered structure, allowing easy insertion,\n// removal, and iteration.\n//\n// Write operations are not safe for concurrent mutation by multiple\n// goroutines, but Read operations are.\ntype BTree BTreeG[Item]\n\nvar itemLess LessFunc[Item] = func(a, b Item) bool {\n\treturn a.Less(b)\n}\n\n// New creates a new B-Tree with the given degree.\n//\n// New(2), for example, will create a 2-3-4 tree (each node contains 1-3 items\n// and 2-4 children).\nfunc New(degree int) *BTree {\n\treturn (*BTree)(NewG[Item](degree, itemLess))\n}\n\n// FreeList represents a free list of btree nodes. By default each\n// BTree has its own FreeList, but multiple BTrees can share the same\n// FreeList.\n// Two Btrees using the same freelist are safe for concurrent write access.\ntype FreeList FreeListG[Item]\n\n// NewFreeList creates a new free list.\n// size is the maximum size of the returned free list.\nfunc NewFreeList(size int) *FreeList {\n\treturn (*FreeList)(NewFreeListG[Item](size))\n}\n\n// NewWithFreeList creates a new B-Tree that uses the given node free list.\nfunc NewWithFreeList(degree int, f *FreeList) *BTree {\n\treturn (*BTree)(NewWithFreeListG[Item](degree, itemLess, (*FreeListG[Item])(f)))\n}\n\n// ItemIterator allows callers of Ascend* to iterate in-order over portions of\n// the tree.  When this function returns false, iteration will stop and the\n// associated Ascend* function will immediately return.\ntype ItemIterator ItemIteratorG[Item]\n\n// Clone clones the btree, lazily.  Clone should not be called concurrently,\n// but the original tree (t) and the new tree (t2) can be used concurrently\n// once the Clone call completes.\n//\n// The internal tree structure of b is marked read-only and shared between t and\n// t2.  Writes to both t and t2 use copy-on-write logic, creating new nodes\n// whenever one of b's original nodes would have been modified.  Read operations\n// should have no performance degredation.  Write operations for both t and t2\n// will initially experience minor slow-downs caused by additional allocs and\n// copies due to the aforementioned copy-on-write logic, but should converge to\n// the original performance characteristics of the original tree.\nfunc (t *BTree) Clone() (t2 *BTree) {\n\treturn (*BTree)((*BTreeG[Item])(t).Clone())\n}\n\n// Delete removes an item equal to the passed in item from the tree, returning\n// it.  If no such item exists, returns nil.\nfunc (t *BTree) Delete(item Item) Item {\n\ti, _ := (*BTreeG[Item])(t).Delete(item)\n\treturn i\n}\n\n// DeleteMax removes the largest item in the tree and returns it.\n// If no such item exists, returns nil.\nfunc (t *BTree) DeleteMax() Item {\n\ti, _ := (*BTreeG[Item])(t).DeleteMax()\n\treturn i\n}\n\n// DeleteMin removes the smallest item in the tree and returns it.\n// If no such item exists, returns nil.\nfunc (t *BTree) DeleteMin() Item {\n\ti, _ := (*BTreeG[Item])(t).DeleteMin()\n\treturn i\n}\n\n// Get looks for the key item in the tree, returning it.  It returns nil if\n// unable to find that item.\nfunc (t *BTree) Get(key Item) Item {\n\ti, _ := (*BTreeG[Item])(t).Get(key)\n\treturn i\n}\n\n// Max returns the largest item in the tree, or nil if the tree is empty.\nfunc (t *BTree) Max() Item {\n\ti, _ := (*BTreeG[Item])(t).Max()\n\treturn i\n}\n\n// Min returns the smallest item in the tree, or nil if the tree is empty.\nfunc (t *BTree) Min() Item {\n\ti, _ := (*BTreeG[Item])(t).Min()\n\treturn i\n}\n\n// Has returns true if the given key is in the tree.\nfunc (t *BTree) Has(key Item) bool {\n\treturn (*BTreeG[Item])(t).Has(key)\n}\n\n// ReplaceOrInsert adds the given item to the tree.  If an item in the tree\n// already equals the given one, it is removed from the tree and returned.\n// Otherwise, nil is returned.\n//\n// nil cannot be added to the tree (will panic).\nfunc (t *BTree) ReplaceOrInsert(item Item) Item {\n\ti, _ := (*BTreeG[Item])(t).ReplaceOrInsert(item)\n\treturn i\n}\n\n// AscendRange calls the iterator for every value in the tree within the range\n// [greaterOrEqual, lessThan), until iterator returns false.\nfunc (t *BTree) AscendRange(greaterOrEqual, lessThan Item, iterator ItemIterator) {\n\t(*BTreeG[Item])(t).AscendRange(greaterOrEqual, lessThan, (ItemIteratorG[Item])(iterator))\n}\n\n// AscendLessThan calls the iterator for every value in the tree within the range\n// [first, pivot), until iterator returns false.\nfunc (t *BTree) AscendLessThan(pivot Item, iterator ItemIterator) {\n\t(*BTreeG[Item])(t).AscendLessThan(pivot, (ItemIteratorG[Item])(iterator))\n}\n\n// AscendGreaterOrEqual calls the iterator for every value in the tree within\n// the range [pivot, last], until iterator returns false.\nfunc (t *BTree) AscendGreaterOrEqual(pivot Item, iterator ItemIterator) {\n\t(*BTreeG[Item])(t).AscendGreaterOrEqual(pivot, (ItemIteratorG[Item])(iterator))\n}\n\n// Ascend calls the iterator for every value in the tree within the range\n// [first, last], until iterator returns false.\nfunc (t *BTree) Ascend(iterator ItemIterator) {\n\t(*BTreeG[Item])(t).Ascend((ItemIteratorG[Item])(iterator))\n}\n\n// DescendRange calls the iterator for every value in the tree within the range\n// [lessOrEqual, greaterThan), until iterator returns false.\nfunc (t *BTree) DescendRange(lessOrEqual, greaterThan Item, iterator ItemIterator) {\n\t(*BTreeG[Item])(t).DescendRange(lessOrEqual, greaterThan, (ItemIteratorG[Item])(iterator))\n}\n\n// DescendLessOrEqual calls the iterator for every value in the tree within the range\n// [pivot, first], until iterator returns false.\nfunc (t *BTree) DescendLessOrEqual(pivot Item, iterator ItemIterator) {\n\t(*BTreeG[Item])(t).DescendLessOrEqual(pivot, (ItemIteratorG[Item])(iterator))\n}\n\n// DescendGreaterThan calls the iterator for every value in the tree within\n// the range [last, pivot), until iterator returns false.\nfunc (t *BTree) DescendGreaterThan(pivot Item, iterator ItemIterator) {\n\t(*BTreeG[Item])(t).DescendGreaterThan(pivot, (ItemIteratorG[Item])(iterator))\n}\n\n// Descend calls the iterator for every value in the tree within the range\n// [last, first], until iterator returns false.\nfunc (t *BTree) Descend(iterator ItemIterator) {\n\t(*BTreeG[Item])(t).Descend((ItemIteratorG[Item])(iterator))\n}\n\n// Len returns the number of items currently in the tree.\nfunc (t *BTree) Len() int {\n\treturn (*BTreeG[Item])(t).Len()\n}\n\n// Clear removes all items from the btree.  If addNodesToFreelist is true,\n// t's nodes are added to its freelist as part of this call, until the freelist\n// is full.  Otherwise, the root node is simply dereferenced and the subtree\n// left to Go's normal GC processes.\n//\n// This can be much faster\n// than calling Delete on all elements, because that requires finding/removing\n// each element in the tree and updating the tree accordingly.  It also is\n// somewhat faster than creating a new tree to replace the old one, because\n// nodes from the old tree are reclaimed into the freelist for use by the new\n// one, instead of being lost to the garbage collector.\n//\n// This call takes:\n//   O(1): when addNodesToFreelist is false, this is a single operation.\n//   O(1): when the freelist is already full, it breaks out immediately\n//   O(freelist size):  when the freelist is empty and the nodes are all owned\n//       by this tree, nodes are added to the freelist until full.\n//   O(tree size):  when all nodes are owned by another tree, all nodes are\n//       iterated over looking for nodes to add to the freelist, and due to\n//       ownership, none are.\nfunc (t *BTree) Clear(addNodesToFreelist bool) {\n\t(*BTreeG[Item])(t).Clear(addNodesToFreelist)\n}\n"
        },
        {
          "name": "btree_generic_test.go",
          "type": "blob",
          "size": 17.2236328125,
          "content": "// Copyright 2014-2022 Google Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n//go:build go1.18\n// +build go1.18\n\npackage btree\n\nimport (\n\t\"fmt\"\n\t\"math/rand\"\n\t\"reflect\"\n\t\"sort\"\n\t\"sync\"\n\t\"testing\"\n)\n\nfunc intRange(s int, reverse bool) []int {\n\tout := make([]int, s)\n\tfor i := 0; i < s; i++ {\n\t\tv := i\n\t\tif reverse {\n\t\t\tv = s - i - 1\n\t\t}\n\t\tout[i] = v\n\t}\n\treturn out\n}\n\nfunc intAll(t *BTreeG[int]) (out []int) {\n\tt.Ascend(func(a int) bool {\n\t\tout = append(out, a)\n\t\treturn true\n\t})\n\treturn\n}\n\nfunc intAllRev(t *BTreeG[int]) (out []int) {\n\tt.Descend(func(a int) bool {\n\t\tout = append(out, a)\n\t\treturn true\n\t})\n\treturn\n}\n\nfunc TestBTreeG(t *testing.T) {\n\ttr := NewOrderedG[int](*btreeDegree)\n\tconst treeSize = 10000\n\tfor i := 0; i < 10; i++ {\n\t\tif min, ok := tr.Min(); ok || min != 0 {\n\t\t\tt.Fatalf(\"empty min, got %+v\", min)\n\t\t}\n\t\tif max, ok := tr.Max(); ok || max != 0 {\n\t\t\tt.Fatalf(\"empty max, got %+v\", max)\n\t\t}\n\t\tfor _, item := range rand.Perm(treeSize) {\n\t\t\tif x, ok := tr.ReplaceOrInsert(item); ok || x != 0 {\n\t\t\t\tt.Fatal(\"insert found item\", item)\n\t\t\t}\n\t\t}\n\t\tfor _, item := range rand.Perm(treeSize) {\n\t\t\tif x, ok := tr.ReplaceOrInsert(item); !ok || x != item {\n\t\t\t\tt.Fatal(\"insert didn't find item\", item)\n\t\t\t}\n\t\t}\n\t\twant := 0\n\t\tif min, ok := tr.Min(); !ok || min != want {\n\t\t\tt.Fatalf(\"min: ok %v want %+v, got %+v\", ok, want, min)\n\t\t}\n\t\twant = treeSize - 1\n\t\tif max, ok := tr.Max(); !ok || max != want {\n\t\t\tt.Fatalf(\"max: ok %v want %+v, got %+v\", ok, want, max)\n\t\t}\n\t\tgot := intAll(tr)\n\t\twantRange := intRange(treeSize, false)\n\t\tif !reflect.DeepEqual(got, wantRange) {\n\t\t\tt.Fatalf(\"mismatch:\\n got: %v\\nwant: %v\", got, wantRange)\n\t\t}\n\n\t\tgotrev := intAllRev(tr)\n\t\twantrev := intRange(treeSize, true)\n\t\tif !reflect.DeepEqual(gotrev, wantrev) {\n\t\t\tt.Fatalf(\"mismatch:\\n got: %v\\nwant: %v\", gotrev, wantrev)\n\t\t}\n\n\t\tfor _, item := range rand.Perm(treeSize) {\n\t\t\tif x, ok := tr.Delete(item); !ok || x != item {\n\t\t\t\tt.Fatalf(\"didn't find %v\", item)\n\t\t\t}\n\t\t}\n\t\tif got = intAll(tr); len(got) > 0 {\n\t\t\tt.Fatalf(\"some left!: %v\", got)\n\t\t}\n\t\tif got = intAllRev(tr); len(got) > 0 {\n\t\t\tt.Fatalf(\"some left!: %v\", got)\n\t\t}\n\t}\n}\n\nfunc ExampleBTreeG() {\n\ttr := NewOrderedG[int](*btreeDegree)\n\tfor i := 0; i < 10; i++ {\n\t\ttr.ReplaceOrInsert(i)\n\t}\n\tfmt.Println(\"len:       \", tr.Len())\n\tv, ok := tr.Get(3)\n\tfmt.Println(\"get3:      \", v, ok)\n\tv, ok = tr.Get(100)\n\tfmt.Println(\"get100:    \", v, ok)\n\tv, ok = tr.Delete(4)\n\tfmt.Println(\"del4:      \", v, ok)\n\tv, ok = tr.Delete(100)\n\tfmt.Println(\"del100:    \", v, ok)\n\tv, ok = tr.ReplaceOrInsert(5)\n\tfmt.Println(\"replace5:  \", v, ok)\n\tv, ok = tr.ReplaceOrInsert(100)\n\tfmt.Println(\"replace100:\", v, ok)\n\tv, ok = tr.Min()\n\tfmt.Println(\"min:       \", v, ok)\n\tv, ok = tr.DeleteMin()\n\tfmt.Println(\"delmin:    \", v, ok)\n\tv, ok = tr.Max()\n\tfmt.Println(\"max:       \", v, ok)\n\tv, ok = tr.DeleteMax()\n\tfmt.Println(\"delmax:    \", v, ok)\n\tfmt.Println(\"len:       \", tr.Len())\n\t// Output:\n\t// len:        10\n\t// get3:       3 true\n\t// get100:     0 false\n\t// del4:       4 true\n\t// del100:     0 false\n\t// replace5:   5 true\n\t// replace100: 0 false\n\t// min:        0 true\n\t// delmin:     0 true\n\t// max:        100 true\n\t// delmax:     100 true\n\t// len:        8\n}\n\nfunc TestDeleteMinG(t *testing.T) {\n\ttr := NewOrderedG[int](3)\n\tfor _, v := range rand.Perm(100) {\n\t\ttr.ReplaceOrInsert(v)\n\t}\n\tvar got []int\n\tfor v, ok := tr.DeleteMin(); ok; v, ok = tr.DeleteMin() {\n\t\tgot = append(got, v)\n\t}\n\tif want := intRange(100, false); !reflect.DeepEqual(got, want) {\n\t\tt.Fatalf(\"ascendrange:\\n got: %v\\nwant: %v\", got, want)\n\t}\n}\n\nfunc TestDeleteMaxG(t *testing.T) {\n\ttr := NewOrderedG[int](3)\n\tfor _, v := range rand.Perm(100) {\n\t\ttr.ReplaceOrInsert(v)\n\t}\n\tvar got []int\n\tfor v, ok := tr.DeleteMax(); ok; v, ok = tr.DeleteMax() {\n\t\tgot = append(got, v)\n\t}\n\tif want := intRange(100, true); !reflect.DeepEqual(got, want) {\n\t\tt.Fatalf(\"ascendrange:\\n got: %v\\nwant: %v\", got, want)\n\t}\n}\n\nfunc TestAscendRangeG(t *testing.T) {\n\ttr := NewOrderedG[int](2)\n\tfor _, v := range rand.Perm(100) {\n\t\ttr.ReplaceOrInsert(v)\n\t}\n\tvar got []int\n\ttr.AscendRange(40, 60, func(a int) bool {\n\t\tgot = append(got, a)\n\t\treturn true\n\t})\n\tif want := intRange(100, false)[40:60]; !reflect.DeepEqual(got, want) {\n\t\tt.Fatalf(\"ascendrange:\\n got: %v\\nwant: %v\", got, want)\n\t}\n\tgot = got[:0]\n\ttr.AscendRange(40, 60, func(a int) bool {\n\t\tif a > 50 {\n\t\t\treturn false\n\t\t}\n\t\tgot = append(got, a)\n\t\treturn true\n\t})\n\tif want := intRange(100, false)[40:51]; !reflect.DeepEqual(got, want) {\n\t\tt.Fatalf(\"ascendrange:\\n got: %v\\nwant: %v\", got, want)\n\t}\n}\n\nfunc TestDescendRangeG(t *testing.T) {\n\ttr := NewOrderedG[int](2)\n\tfor _, v := range rand.Perm(100) {\n\t\ttr.ReplaceOrInsert(v)\n\t}\n\tvar got []int\n\ttr.DescendRange(60, 40, func(a int) bool {\n\t\tgot = append(got, a)\n\t\treturn true\n\t})\n\tif want := intRange(100, true)[39:59]; !reflect.DeepEqual(got, want) {\n\t\tt.Fatalf(\"descendrange:\\n got: %v\\nwant: %v\", got, want)\n\t}\n\tgot = got[:0]\n\ttr.DescendRange(60, 40, func(a int) bool {\n\t\tif a < 50 {\n\t\t\treturn false\n\t\t}\n\t\tgot = append(got, a)\n\t\treturn true\n\t})\n\tif want := intRange(100, true)[39:50]; !reflect.DeepEqual(got, want) {\n\t\tt.Fatalf(\"descendrange:\\n got: %v\\nwant: %v\", got, want)\n\t}\n}\n\nfunc TestAscendLessThanG(t *testing.T) {\n\ttr := NewOrderedG[int](*btreeDegree)\n\tfor _, v := range rand.Perm(100) {\n\t\ttr.ReplaceOrInsert(v)\n\t}\n\tvar got []int\n\ttr.AscendLessThan(60, func(a int) bool {\n\t\tgot = append(got, a)\n\t\treturn true\n\t})\n\tif want := intRange(100, false)[:60]; !reflect.DeepEqual(got, want) {\n\t\tt.Fatalf(\"ascendrange:\\n got: %v\\nwant: %v\", got, want)\n\t}\n\tgot = got[:0]\n\ttr.AscendLessThan(60, func(a int) bool {\n\t\tif a > 50 {\n\t\t\treturn false\n\t\t}\n\t\tgot = append(got, a)\n\t\treturn true\n\t})\n\tif want := intRange(100, false)[:51]; !reflect.DeepEqual(got, want) {\n\t\tt.Fatalf(\"ascendrange:\\n got: %v\\nwant: %v\", got, want)\n\t}\n}\n\nfunc TestDescendLessOrEqualG(t *testing.T) {\n\ttr := NewOrderedG[int](*btreeDegree)\n\tfor _, v := range rand.Perm(100) {\n\t\ttr.ReplaceOrInsert(v)\n\t}\n\tvar got []int\n\ttr.DescendLessOrEqual(40, func(a int) bool {\n\t\tgot = append(got, a)\n\t\treturn true\n\t})\n\tif want := intRange(100, true)[59:]; !reflect.DeepEqual(got, want) {\n\t\tt.Fatalf(\"descendlessorequal:\\n got: %v\\nwant: %v\", got, want)\n\t}\n\tgot = got[:0]\n\ttr.DescendLessOrEqual(60, func(a int) bool {\n\t\tif a < 50 {\n\t\t\treturn false\n\t\t}\n\t\tgot = append(got, a)\n\t\treturn true\n\t})\n\tif want := intRange(100, true)[39:50]; !reflect.DeepEqual(got, want) {\n\t\tt.Fatalf(\"descendlessorequal:\\n got: %v\\nwant: %v\", got, want)\n\t}\n}\n\nfunc TestAscendGreaterOrEqualG(t *testing.T) {\n\ttr := NewOrderedG[int](*btreeDegree)\n\tfor _, v := range rand.Perm(100) {\n\t\ttr.ReplaceOrInsert(v)\n\t}\n\tvar got []int\n\ttr.AscendGreaterOrEqual(40, func(a int) bool {\n\t\tgot = append(got, a)\n\t\treturn true\n\t})\n\tif want := intRange(100, false)[40:]; !reflect.DeepEqual(got, want) {\n\t\tt.Fatalf(\"ascendrange:\\n got: %v\\nwant: %v\", got, want)\n\t}\n\tgot = got[:0]\n\ttr.AscendGreaterOrEqual(40, func(a int) bool {\n\t\tif a > 50 {\n\t\t\treturn false\n\t\t}\n\t\tgot = append(got, a)\n\t\treturn true\n\t})\n\tif want := intRange(100, false)[40:51]; !reflect.DeepEqual(got, want) {\n\t\tt.Fatalf(\"ascendrange:\\n got: %v\\nwant: %v\", got, want)\n\t}\n}\n\nfunc TestDescendGreaterThanG(t *testing.T) {\n\ttr := NewOrderedG[int](*btreeDegree)\n\tfor _, v := range rand.Perm(100) {\n\t\ttr.ReplaceOrInsert(v)\n\t}\n\tvar got []int\n\ttr.DescendGreaterThan(40, func(a int) bool {\n\t\tgot = append(got, a)\n\t\treturn true\n\t})\n\tif want := intRange(100, true)[:59]; !reflect.DeepEqual(got, want) {\n\t\tt.Fatalf(\"descendgreaterthan:\\n got: %v\\nwant: %v\", got, want)\n\t}\n\tgot = got[:0]\n\ttr.DescendGreaterThan(40, func(a int) bool {\n\t\tif a < 50 {\n\t\t\treturn false\n\t\t}\n\t\tgot = append(got, a)\n\t\treturn true\n\t})\n\tif want := intRange(100, true)[:50]; !reflect.DeepEqual(got, want) {\n\t\tt.Fatalf(\"descendgreaterthan:\\n got: %v\\nwant: %v\", got, want)\n\t}\n}\n\nfunc BenchmarkInsertG(b *testing.B) {\n\tb.StopTimer()\n\tinsertP := rand.Perm(benchmarkTreeSize)\n\tb.StartTimer()\n\ti := 0\n\tfor i < b.N {\n\t\ttr := NewOrderedG[int](*btreeDegree)\n\t\tfor _, item := range insertP {\n\t\t\ttr.ReplaceOrInsert(item)\n\t\t\ti++\n\t\t\tif i >= b.N {\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc BenchmarkSeekG(b *testing.B) {\n\tb.StopTimer()\n\tsize := 100000\n\tinsertP := rand.Perm(size)\n\ttr := NewOrderedG[int](*btreeDegree)\n\tfor _, item := range insertP {\n\t\ttr.ReplaceOrInsert(item)\n\t}\n\tb.StartTimer()\n\n\tfor i := 0; i < b.N; i++ {\n\t\ttr.AscendGreaterOrEqual(i%size, func(i int) bool { return false })\n\t}\n}\n\nfunc BenchmarkDeleteInsertG(b *testing.B) {\n\tb.StopTimer()\n\tinsertP := rand.Perm(benchmarkTreeSize)\n\ttr := NewOrderedG[int](*btreeDegree)\n\tfor _, item := range insertP {\n\t\ttr.ReplaceOrInsert(item)\n\t}\n\tb.StartTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\ttr.Delete(insertP[i%benchmarkTreeSize])\n\t\ttr.ReplaceOrInsert(insertP[i%benchmarkTreeSize])\n\t}\n}\n\nfunc BenchmarkDeleteInsertCloneOnceG(b *testing.B) {\n\tb.StopTimer()\n\tinsertP := rand.Perm(benchmarkTreeSize)\n\ttr := NewOrderedG[int](*btreeDegree)\n\tfor _, item := range insertP {\n\t\ttr.ReplaceOrInsert(item)\n\t}\n\ttr = tr.Clone()\n\tb.StartTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\ttr.Delete(insertP[i%benchmarkTreeSize])\n\t\ttr.ReplaceOrInsert(insertP[i%benchmarkTreeSize])\n\t}\n}\n\nfunc BenchmarkDeleteInsertCloneEachTimeG(b *testing.B) {\n\tb.StopTimer()\n\tinsertP := rand.Perm(benchmarkTreeSize)\n\ttr := NewOrderedG[int](*btreeDegree)\n\tfor _, item := range insertP {\n\t\ttr.ReplaceOrInsert(item)\n\t}\n\tb.StartTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\ttr = tr.Clone()\n\t\ttr.Delete(insertP[i%benchmarkTreeSize])\n\t\ttr.ReplaceOrInsert(insertP[i%benchmarkTreeSize])\n\t}\n}\n\nfunc BenchmarkDeleteG(b *testing.B) {\n\tb.StopTimer()\n\tinsertP := rand.Perm(benchmarkTreeSize)\n\tremoveP := rand.Perm(benchmarkTreeSize)\n\tb.StartTimer()\n\ti := 0\n\tfor i < b.N {\n\t\tb.StopTimer()\n\t\ttr := NewOrderedG[int](*btreeDegree)\n\t\tfor _, v := range insertP {\n\t\t\ttr.ReplaceOrInsert(v)\n\t\t}\n\t\tb.StartTimer()\n\t\tfor _, item := range removeP {\n\t\t\ttr.Delete(item)\n\t\t\ti++\n\t\t\tif i >= b.N {\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t\tif tr.Len() > 0 {\n\t\t\tpanic(tr.Len())\n\t\t}\n\t}\n}\n\nfunc BenchmarkGetG(b *testing.B) {\n\tb.StopTimer()\n\tinsertP := rand.Perm(benchmarkTreeSize)\n\tremoveP := rand.Perm(benchmarkTreeSize)\n\tb.StartTimer()\n\ti := 0\n\tfor i < b.N {\n\t\tb.StopTimer()\n\t\ttr := NewOrderedG[int](*btreeDegree)\n\t\tfor _, v := range insertP {\n\t\t\ttr.ReplaceOrInsert(v)\n\t\t}\n\t\tb.StartTimer()\n\t\tfor _, item := range removeP {\n\t\t\ttr.Get(item)\n\t\t\ti++\n\t\t\tif i >= b.N {\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc BenchmarkGetCloneEachTimeG(b *testing.B) {\n\tb.StopTimer()\n\tinsertP := rand.Perm(benchmarkTreeSize)\n\tremoveP := rand.Perm(benchmarkTreeSize)\n\tb.StartTimer()\n\ti := 0\n\tfor i < b.N {\n\t\tb.StopTimer()\n\t\ttr := NewOrderedG[int](*btreeDegree)\n\t\tfor _, v := range insertP {\n\t\t\ttr.ReplaceOrInsert(v)\n\t\t}\n\t\tb.StartTimer()\n\t\tfor _, item := range removeP {\n\t\t\ttr = tr.Clone()\n\t\t\ttr.Get(item)\n\t\t\ti++\n\t\t\tif i >= b.N {\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc BenchmarkAscendG(b *testing.B) {\n\tarr := rand.Perm(benchmarkTreeSize)\n\ttr := NewOrderedG[int](*btreeDegree)\n\tfor _, v := range arr {\n\t\ttr.ReplaceOrInsert(v)\n\t}\n\tsort.Ints(arr)\n\tb.ResetTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\tj := 0\n\t\ttr.Ascend(func(item int) bool {\n\t\t\tif item != arr[j] {\n\t\t\t\tb.Fatalf(\"mismatch: expected: %v, got %v\", arr[j], item)\n\t\t\t}\n\t\t\tj++\n\t\t\treturn true\n\t\t})\n\t}\n}\n\nfunc BenchmarkDescendG(b *testing.B) {\n\tarr := rand.Perm(benchmarkTreeSize)\n\ttr := NewOrderedG[int](*btreeDegree)\n\tfor _, v := range arr {\n\t\ttr.ReplaceOrInsert(v)\n\t}\n\tsort.Ints(arr)\n\tb.ResetTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\tj := len(arr) - 1\n\t\ttr.Descend(func(item int) bool {\n\t\t\tif item != arr[j] {\n\t\t\t\tb.Fatalf(\"mismatch: expected: %v, got %v\", arr[j], item)\n\t\t\t}\n\t\t\tj--\n\t\t\treturn true\n\t\t})\n\t}\n}\n\nfunc BenchmarkAscendRangeG(b *testing.B) {\n\tarr := rand.Perm(benchmarkTreeSize)\n\ttr := NewOrderedG[int](*btreeDegree)\n\tfor _, v := range arr {\n\t\ttr.ReplaceOrInsert(v)\n\t}\n\tsort.Ints(arr)\n\tb.ResetTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\tj := 100\n\t\ttr.AscendRange(100, arr[len(arr)-100], func(item int) bool {\n\t\t\tif item != arr[j] {\n\t\t\t\tb.Fatalf(\"mismatch: expected: %v, got %v\", arr[j], item)\n\t\t\t}\n\t\t\tj++\n\t\t\treturn true\n\t\t})\n\t\tif j != len(arr)-100 {\n\t\t\tb.Fatalf(\"expected: %v, got %v\", len(arr)-100, j)\n\t\t}\n\t}\n}\n\nfunc BenchmarkDescendRangeG(b *testing.B) {\n\tarr := rand.Perm(benchmarkTreeSize)\n\ttr := NewOrderedG[int](*btreeDegree)\n\tfor _, v := range arr {\n\t\ttr.ReplaceOrInsert(v)\n\t}\n\tsort.Ints(arr)\n\tb.ResetTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\tj := len(arr) - 100\n\t\ttr.DescendRange(arr[len(arr)-100], 100, func(item int) bool {\n\t\t\tif item != arr[j] {\n\t\t\t\tb.Fatalf(\"mismatch: expected: %v, got %v\", arr[j], item)\n\t\t\t}\n\t\t\tj--\n\t\t\treturn true\n\t\t})\n\t\tif j != 100 {\n\t\t\tb.Fatalf(\"expected: %v, got %v\", len(arr)-100, j)\n\t\t}\n\t}\n}\n\nfunc BenchmarkAscendGreaterOrEqualG(b *testing.B) {\n\tarr := rand.Perm(benchmarkTreeSize)\n\ttr := NewOrderedG[int](*btreeDegree)\n\tfor _, v := range arr {\n\t\ttr.ReplaceOrInsert(v)\n\t}\n\tsort.Ints(arr)\n\tb.ResetTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\tj := 100\n\t\tk := 0\n\t\ttr.AscendGreaterOrEqual(100, func(item int) bool {\n\t\t\tif item != arr[j] {\n\t\t\t\tb.Fatalf(\"mismatch: expected: %v, got %v\", arr[j], item)\n\t\t\t}\n\t\t\tj++\n\t\t\tk++\n\t\t\treturn true\n\t\t})\n\t\tif j != len(arr) {\n\t\t\tb.Fatalf(\"expected: %v, got %v\", len(arr), j)\n\t\t}\n\t\tif k != len(arr)-100 {\n\t\t\tb.Fatalf(\"expected: %v, got %v\", len(arr)-100, k)\n\t\t}\n\t}\n}\n\nfunc BenchmarkDescendLessOrEqualG(b *testing.B) {\n\tarr := rand.Perm(benchmarkTreeSize)\n\ttr := NewOrderedG[int](*btreeDegree)\n\tfor _, v := range arr {\n\t\ttr.ReplaceOrInsert(v)\n\t}\n\tsort.Ints(arr)\n\tb.ResetTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\tj := len(arr) - 100\n\t\tk := len(arr)\n\t\ttr.DescendLessOrEqual(arr[len(arr)-100], func(item int) bool {\n\t\t\tif item != arr[j] {\n\t\t\t\tb.Fatalf(\"mismatch: expected: %v, got %v\", arr[j], item)\n\t\t\t}\n\t\t\tj--\n\t\t\tk--\n\t\t\treturn true\n\t\t})\n\t\tif j != -1 {\n\t\t\tb.Fatalf(\"expected: %v, got %v\", -1, j)\n\t\t}\n\t\tif k != 99 {\n\t\t\tb.Fatalf(\"expected: %v, got %v\", 99, k)\n\t\t}\n\t}\n}\n\nfunc cloneTestG(t *testing.T, b *BTreeG[int], start int, p []int, wg *sync.WaitGroup, trees *[]*BTreeG[int], lock *sync.Mutex) {\n\tt.Logf(\"Starting new clone at %v\", start)\n\tlock.Lock()\n\t*trees = append(*trees, b)\n\tlock.Unlock()\n\tfor i := start; i < cloneTestSize; i++ {\n\t\tb.ReplaceOrInsert(p[i])\n\t\tif i%(cloneTestSize/5) == 0 {\n\t\t\twg.Add(1)\n\t\t\tgo cloneTestG(t, b.Clone(), i+1, p, wg, trees, lock)\n\t\t}\n\t}\n\twg.Done()\n}\n\nfunc TestCloneConcurrentOperationsG(t *testing.T) {\n\tb := NewOrderedG[int](*btreeDegree)\n\ttrees := []*BTreeG[int]{}\n\tp := rand.Perm(cloneTestSize)\n\tvar wg sync.WaitGroup\n\twg.Add(1)\n\tgo cloneTestG(t, b, 0, p, &wg, &trees, &sync.Mutex{})\n\twg.Wait()\n\twant := intRange(cloneTestSize, false)\n\tt.Logf(\"Starting equality checks on %d trees\", len(trees))\n\tfor i, tree := range trees {\n\t\tif !reflect.DeepEqual(want, intAll(tree)) {\n\t\t\tt.Errorf(\"tree %v mismatch\", i)\n\t\t}\n\t}\n\tt.Log(\"Removing half from first half\")\n\ttoRemove := intRange(cloneTestSize, false)[cloneTestSize/2:]\n\tfor i := 0; i < len(trees)/2; i++ {\n\t\ttree := trees[i]\n\t\twg.Add(1)\n\t\tgo func() {\n\t\t\tfor _, item := range toRemove {\n\t\t\t\ttree.Delete(item)\n\t\t\t}\n\t\t\twg.Done()\n\t\t}()\n\t}\n\twg.Wait()\n\tt.Log(\"Checking all values again\")\n\tfor i, tree := range trees {\n\t\tvar wantpart []int\n\t\tif i < len(trees)/2 {\n\t\t\twantpart = want[:cloneTestSize/2]\n\t\t} else {\n\t\t\twantpart = want\n\t\t}\n\t\tif got := intAll(tree); !reflect.DeepEqual(wantpart, got) {\n\t\t\tt.Errorf(\"tree %v mismatch, want %v got %v\", i, len(want), len(got))\n\t\t}\n\t}\n}\n\nfunc BenchmarkDeleteAndRestoreG(b *testing.B) {\n\titems := rand.Perm(16392)\n\tb.ResetTimer()\n\tb.Run(`CopyBigFreeList`, func(b *testing.B) {\n\t\tfl := NewFreeListG[int](16392)\n\t\ttr := NewWithFreeListG[int](*btreeDegree, Less[int](), fl)\n\t\tfor _, v := range items {\n\t\t\ttr.ReplaceOrInsert(v)\n\t\t}\n\t\tb.ReportAllocs()\n\t\tb.ResetTimer()\n\t\tfor i := 0; i < b.N; i++ {\n\t\t\tdels := make([]int, 0, tr.Len())\n\t\t\ttr.Ascend(func(b int) bool {\n\t\t\t\tdels = append(dels, b)\n\t\t\t\treturn true\n\t\t\t})\n\t\t\tfor _, del := range dels {\n\t\t\t\ttr.Delete(del)\n\t\t\t}\n\t\t\t// tr is now empty, we make a new empty copy of it.\n\t\t\ttr = NewWithFreeListG[int](*btreeDegree, Less[int](), fl)\n\t\t\tfor _, v := range items {\n\t\t\t\ttr.ReplaceOrInsert(v)\n\t\t\t}\n\t\t}\n\t})\n\tb.Run(`Copy`, func(b *testing.B) {\n\t\ttr := NewOrderedG[int](*btreeDegree)\n\t\tfor _, v := range items {\n\t\t\ttr.ReplaceOrInsert(v)\n\t\t}\n\t\tb.ReportAllocs()\n\t\tb.ResetTimer()\n\t\tfor i := 0; i < b.N; i++ {\n\t\t\tdels := make([]int, 0, tr.Len())\n\t\t\ttr.Ascend(func(b int) bool {\n\t\t\t\tdels = append(dels, b)\n\t\t\t\treturn true\n\t\t\t})\n\t\t\tfor _, del := range dels {\n\t\t\t\ttr.Delete(del)\n\t\t\t}\n\t\t\t// tr is now empty, we make a new empty copy of it.\n\t\t\ttr = NewOrderedG[int](*btreeDegree)\n\t\t\tfor _, v := range items {\n\t\t\t\ttr.ReplaceOrInsert(v)\n\t\t\t}\n\t\t}\n\t})\n\tb.Run(`ClearBigFreelist`, func(b *testing.B) {\n\t\tfl := NewFreeListG[int](16392)\n\t\ttr := NewWithFreeListG[int](*btreeDegree, Less[int](), fl)\n\t\tfor _, v := range items {\n\t\t\ttr.ReplaceOrInsert(v)\n\t\t}\n\t\tb.ReportAllocs()\n\t\tb.ResetTimer()\n\t\tfor i := 0; i < b.N; i++ {\n\t\t\ttr.Clear(true)\n\t\t\tfor _, v := range items {\n\t\t\t\ttr.ReplaceOrInsert(v)\n\t\t\t}\n\t\t}\n\t})\n\tb.Run(`Clear`, func(b *testing.B) {\n\t\ttr := NewOrderedG[int](*btreeDegree)\n\t\tfor _, v := range items {\n\t\t\ttr.ReplaceOrInsert(v)\n\t\t}\n\t\tb.ReportAllocs()\n\t\tb.ResetTimer()\n\t\tfor i := 0; i < b.N; i++ {\n\t\t\ttr.Clear(true)\n\t\t\tfor _, v := range items {\n\t\t\t\ttr.ReplaceOrInsert(v)\n\t\t\t}\n\t\t}\n\t})\n}\n"
        },
        {
          "name": "btree_mem.go",
          "type": "blob",
          "size": 1.8701171875,
          "content": "// Copyright 2014 Google Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n// +build ignore\n\n// This binary compares memory usage between btree and gollrb.\npackage main\n\nimport (\n\t\"flag\"\n\t\"fmt\"\n\t\"math/rand\"\n\t\"runtime\"\n\t\"time\"\n\n\t\"github.com/google/btree\"\n\t\"github.com/petar/GoLLRB/llrb\"\n)\n\nvar (\n\tsize   = flag.Int(\"size\", 1000000, \"size of the tree to build\")\n\tdegree = flag.Int(\"degree\", 8, \"degree of btree\")\n\tgollrb = flag.Bool(\"llrb\", false, \"use llrb instead of btree\")\n)\n\nfunc main() {\n\tflag.Parse()\n\tvals := rand.Perm(*size)\n\tvar t, v interface{}\n\tv = vals\n\tvar stats runtime.MemStats\n\tfor i := 0; i < 10; i++ {\n\t\truntime.GC()\n\t}\n\tfmt.Println(\"-------- BEFORE ----------\")\n\truntime.ReadMemStats(&stats)\n\tfmt.Printf(\"%+v\\n\", stats)\n\tstart := time.Now()\n\tif *gollrb {\n\t\ttr := llrb.New()\n\t\tfor _, v := range vals {\n\t\t\ttr.ReplaceOrInsert(llrb.Int(v))\n\t\t}\n\t\tt = tr // keep it around\n\t} else {\n\t\ttr := btree.New(*degree)\n\t\tfor _, v := range vals {\n\t\t\ttr.ReplaceOrInsert(btree.Int(v))\n\t\t}\n\t\tt = tr // keep it around\n\t}\n\tfmt.Printf(\"%v inserts in %v\\n\", *size, time.Since(start))\n\tfmt.Println(\"-------- AFTER ----------\")\n\truntime.ReadMemStats(&stats)\n\tfmt.Printf(\"%+v\\n\", stats)\n\tfor i := 0; i < 10; i++ {\n\t\truntime.GC()\n\t}\n\tfmt.Println(\"-------- AFTER GC ----------\")\n\truntime.ReadMemStats(&stats)\n\tfmt.Printf(\"%+v\\n\", stats)\n\tif t == v {\n\t\tfmt.Println(\"to make sure vals and tree aren't GC'd\")\n\t}\n}\n"
        },
        {
          "name": "btree_test.go",
          "type": "blob",
          "size": 17.53515625,
          "content": "// Copyright 2014 Google Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage btree\n\nimport (\n\t\"flag\"\n\t\"fmt\"\n\t\"math/rand\"\n\t\"reflect\"\n\t\"sort\"\n\t\"sync\"\n\t\"testing\"\n\t\"time\"\n)\n\nfunc init() {\n\tseed := time.Now().Unix()\n\tfmt.Println(seed)\n\trand.Seed(seed)\n}\n\n// perm returns a random permutation of n Int items in the range [0, n).\nfunc perm(n int) (out []Item) {\n\tfor _, v := range rand.Perm(n) {\n\t\tout = append(out, Int(v))\n\t}\n\treturn\n}\n\n// rang returns an ordered list of Int items in the range [0, n).\nfunc rang(n int) (out []Item) {\n\tfor i := 0; i < n; i++ {\n\t\tout = append(out, Int(i))\n\t}\n\treturn\n}\n\n// all extracts all items from a tree in order as a slice.\nfunc all(t *BTree) (out []Item) {\n\tt.Ascend(func(a Item) bool {\n\t\tout = append(out, a)\n\t\treturn true\n\t})\n\treturn\n}\n\n// rangerev returns a reversed ordered list of Int items in the range [0, n).\nfunc rangrev(n int) (out []Item) {\n\tfor i := n - 1; i >= 0; i-- {\n\t\tout = append(out, Int(i))\n\t}\n\treturn\n}\n\n// allrev extracts all items from a tree in reverse order as a slice.\nfunc allrev(t *BTree) (out []Item) {\n\tt.Descend(func(a Item) bool {\n\t\tout = append(out, a)\n\t\treturn true\n\t})\n\treturn\n}\n\nvar btreeDegree = flag.Int(\"degree\", 32, \"B-Tree degree\")\n\nfunc TestBTree(t *testing.T) {\n\ttr := New(*btreeDegree)\n\tconst treeSize = 10000\n\tfor i := 0; i < 10; i++ {\n\t\tif min := tr.Min(); min != nil {\n\t\t\tt.Fatalf(\"empty min, got %+v\", min)\n\t\t}\n\t\tif max := tr.Max(); max != nil {\n\t\t\tt.Fatalf(\"empty max, got %+v\", max)\n\t\t}\n\t\tfor _, item := range perm(treeSize) {\n\t\t\tif x := tr.ReplaceOrInsert(item); x != nil {\n\t\t\t\tt.Fatal(\"insert found item\", item)\n\t\t\t}\n\t\t}\n\t\tfor _, item := range perm(treeSize) {\n\t\t\tif !tr.Has(item) {\n\t\t\t\tt.Fatal(\"has did not find item\", item)\n\t\t\t}\n\t\t}\n\t\tfor _, item := range perm(treeSize) {\n\t\t\tif x := tr.ReplaceOrInsert(item); x == nil {\n\t\t\t\tt.Fatal(\"insert didn't find item\", item)\n\t\t\t}\n\t\t}\n\t\tif min, want := tr.Min(), Item(Int(0)); min != want {\n\t\t\tt.Fatalf(\"min: want %+v, got %+v\", want, min)\n\t\t}\n\t\tif max, want := tr.Max(), Item(Int(treeSize-1)); max != want {\n\t\t\tt.Fatalf(\"max: want %+v, got %+v\", want, max)\n\t\t}\n\t\tgot := all(tr)\n\t\twant := rang(treeSize)\n\t\tif !reflect.DeepEqual(got, want) {\n\t\t\tt.Fatalf(\"mismatch:\\n got: %v\\nwant: %v\", got, want)\n\t\t}\n\n\t\tgotrev := allrev(tr)\n\t\twantrev := rangrev(treeSize)\n\t\tif !reflect.DeepEqual(gotrev, wantrev) {\n\t\t\tt.Fatalf(\"mismatch:\\n got: %v\\nwant: %v\", got, want)\n\t\t}\n\n\t\tfor _, item := range perm(treeSize) {\n\t\t\tif x := tr.Delete(item); x == nil {\n\t\t\t\tt.Fatalf(\"didn't find %v\", item)\n\t\t\t}\n\t\t}\n\t\tif got = all(tr); len(got) > 0 {\n\t\t\tt.Fatalf(\"some left!: %v\", got)\n\t\t}\n\t}\n}\n\nfunc ExampleBTree() {\n\ttr := New(*btreeDegree)\n\tfor i := Int(0); i < 10; i++ {\n\t\ttr.ReplaceOrInsert(i)\n\t}\n\tfmt.Println(\"len:       \", tr.Len())\n\tfmt.Println(\"get3:      \", tr.Get(Int(3)))\n\tfmt.Println(\"get100:    \", tr.Get(Int(100)))\n\tfmt.Println(\"del4:      \", tr.Delete(Int(4)))\n\tfmt.Println(\"del100:    \", tr.Delete(Int(100)))\n\tfmt.Println(\"replace5:  \", tr.ReplaceOrInsert(Int(5)))\n\tfmt.Println(\"replace100:\", tr.ReplaceOrInsert(Int(100)))\n\tfmt.Println(\"min:       \", tr.Min())\n\tfmt.Println(\"delmin:    \", tr.DeleteMin())\n\tfmt.Println(\"max:       \", tr.Max())\n\tfmt.Println(\"delmax:    \", tr.DeleteMax())\n\tfmt.Println(\"len:       \", tr.Len())\n\t// Output:\n\t// len:        10\n\t// get3:       3\n\t// get100:     <nil>\n\t// del4:       4\n\t// del100:     <nil>\n\t// replace5:   5\n\t// replace100: <nil>\n\t// min:        0\n\t// delmin:     0\n\t// max:        100\n\t// delmax:     100\n\t// len:        8\n}\n\nfunc TestDeleteMin(t *testing.T) {\n\ttr := New(3)\n\tfor _, v := range perm(100) {\n\t\ttr.ReplaceOrInsert(v)\n\t}\n\tvar got []Item\n\tfor v := tr.DeleteMin(); v != nil; v = tr.DeleteMin() {\n\t\tgot = append(got, v)\n\t}\n\tif want := rang(100); !reflect.DeepEqual(got, want) {\n\t\tt.Fatalf(\"ascendrange:\\n got: %v\\nwant: %v\", got, want)\n\t}\n}\n\nfunc TestDeleteMax(t *testing.T) {\n\ttr := New(3)\n\tfor _, v := range perm(100) {\n\t\ttr.ReplaceOrInsert(v)\n\t}\n\tvar got []Item\n\tfor v := tr.DeleteMax(); v != nil; v = tr.DeleteMax() {\n\t\tgot = append(got, v)\n\t}\n\t// Reverse our list.\n\tfor i := 0; i < len(got)/2; i++ {\n\t\tgot[i], got[len(got)-i-1] = got[len(got)-i-1], got[i]\n\t}\n\tif want := rang(100); !reflect.DeepEqual(got, want) {\n\t\tt.Fatalf(\"ascendrange:\\n got: %v\\nwant: %v\", got, want)\n\t}\n}\n\nfunc TestAscendRange(t *testing.T) {\n\ttr := New(2)\n\tfor _, v := range perm(100) {\n\t\ttr.ReplaceOrInsert(v)\n\t}\n\tvar got []Item\n\ttr.AscendRange(Int(40), Int(60), func(a Item) bool {\n\t\tgot = append(got, a)\n\t\treturn true\n\t})\n\tif want := rang(100)[40:60]; !reflect.DeepEqual(got, want) {\n\t\tt.Fatalf(\"ascendrange:\\n got: %v\\nwant: %v\", got, want)\n\t}\n\tgot = got[:0]\n\ttr.AscendRange(Int(40), Int(60), func(a Item) bool {\n\t\tif a.(Int) > 50 {\n\t\t\treturn false\n\t\t}\n\t\tgot = append(got, a)\n\t\treturn true\n\t})\n\tif want := rang(100)[40:51]; !reflect.DeepEqual(got, want) {\n\t\tt.Fatalf(\"ascendrange:\\n got: %v\\nwant: %v\", got, want)\n\t}\n}\n\nfunc TestDescendRange(t *testing.T) {\n\ttr := New(2)\n\tfor _, v := range perm(100) {\n\t\ttr.ReplaceOrInsert(v)\n\t}\n\tvar got []Item\n\ttr.DescendRange(Int(60), Int(40), func(a Item) bool {\n\t\tgot = append(got, a)\n\t\treturn true\n\t})\n\tif want := rangrev(100)[39:59]; !reflect.DeepEqual(got, want) {\n\t\tt.Fatalf(\"descendrange:\\n got: %v\\nwant: %v\", got, want)\n\t}\n\tgot = got[:0]\n\ttr.DescendRange(Int(60), Int(40), func(a Item) bool {\n\t\tif a.(Int) < 50 {\n\t\t\treturn false\n\t\t}\n\t\tgot = append(got, a)\n\t\treturn true\n\t})\n\tif want := rangrev(100)[39:50]; !reflect.DeepEqual(got, want) {\n\t\tt.Fatalf(\"descendrange:\\n got: %v\\nwant: %v\", got, want)\n\t}\n}\nfunc TestAscendLessThan(t *testing.T) {\n\ttr := New(*btreeDegree)\n\tfor _, v := range perm(100) {\n\t\ttr.ReplaceOrInsert(v)\n\t}\n\tvar got []Item\n\ttr.AscendLessThan(Int(60), func(a Item) bool {\n\t\tgot = append(got, a)\n\t\treturn true\n\t})\n\tif want := rang(100)[:60]; !reflect.DeepEqual(got, want) {\n\t\tt.Fatalf(\"ascendrange:\\n got: %v\\nwant: %v\", got, want)\n\t}\n\tgot = got[:0]\n\ttr.AscendLessThan(Int(60), func(a Item) bool {\n\t\tif a.(Int) > 50 {\n\t\t\treturn false\n\t\t}\n\t\tgot = append(got, a)\n\t\treturn true\n\t})\n\tif want := rang(100)[:51]; !reflect.DeepEqual(got, want) {\n\t\tt.Fatalf(\"ascendrange:\\n got: %v\\nwant: %v\", got, want)\n\t}\n}\n\nfunc TestDescendLessOrEqual(t *testing.T) {\n\ttr := New(*btreeDegree)\n\tfor _, v := range perm(100) {\n\t\ttr.ReplaceOrInsert(v)\n\t}\n\tvar got []Item\n\ttr.DescendLessOrEqual(Int(40), func(a Item) bool {\n\t\tgot = append(got, a)\n\t\treturn true\n\t})\n\tif want := rangrev(100)[59:]; !reflect.DeepEqual(got, want) {\n\t\tt.Fatalf(\"descendlessorequal:\\n got: %v\\nwant: %v\", got, want)\n\t}\n\tgot = got[:0]\n\ttr.DescendLessOrEqual(Int(60), func(a Item) bool {\n\t\tif a.(Int) < 50 {\n\t\t\treturn false\n\t\t}\n\t\tgot = append(got, a)\n\t\treturn true\n\t})\n\tif want := rangrev(100)[39:50]; !reflect.DeepEqual(got, want) {\n\t\tt.Fatalf(\"descendlessorequal:\\n got: %v\\nwant: %v\", got, want)\n\t}\n}\nfunc TestAscendGreaterOrEqual(t *testing.T) {\n\ttr := New(*btreeDegree)\n\tfor _, v := range perm(100) {\n\t\ttr.ReplaceOrInsert(v)\n\t}\n\tvar got []Item\n\ttr.AscendGreaterOrEqual(Int(40), func(a Item) bool {\n\t\tgot = append(got, a)\n\t\treturn true\n\t})\n\tif want := rang(100)[40:]; !reflect.DeepEqual(got, want) {\n\t\tt.Fatalf(\"ascendrange:\\n got: %v\\nwant: %v\", got, want)\n\t}\n\tgot = got[:0]\n\ttr.AscendGreaterOrEqual(Int(40), func(a Item) bool {\n\t\tif a.(Int) > 50 {\n\t\t\treturn false\n\t\t}\n\t\tgot = append(got, a)\n\t\treturn true\n\t})\n\tif want := rang(100)[40:51]; !reflect.DeepEqual(got, want) {\n\t\tt.Fatalf(\"ascendrange:\\n got: %v\\nwant: %v\", got, want)\n\t}\n}\n\nfunc TestDescendGreaterThan(t *testing.T) {\n\ttr := New(*btreeDegree)\n\tfor _, v := range perm(100) {\n\t\ttr.ReplaceOrInsert(v)\n\t}\n\tvar got []Item\n\ttr.DescendGreaterThan(Int(40), func(a Item) bool {\n\t\tgot = append(got, a)\n\t\treturn true\n\t})\n\tif want := rangrev(100)[:59]; !reflect.DeepEqual(got, want) {\n\t\tt.Fatalf(\"descendgreaterthan:\\n got: %v\\nwant: %v\", got, want)\n\t}\n\tgot = got[:0]\n\ttr.DescendGreaterThan(Int(40), func(a Item) bool {\n\t\tif a.(Int) < 50 {\n\t\t\treturn false\n\t\t}\n\t\tgot = append(got, a)\n\t\treturn true\n\t})\n\tif want := rangrev(100)[:50]; !reflect.DeepEqual(got, want) {\n\t\tt.Fatalf(\"descendgreaterthan:\\n got: %v\\nwant: %v\", got, want)\n\t}\n}\n\nconst benchmarkTreeSize = 10000\n\nfunc BenchmarkInsert(b *testing.B) {\n\tb.StopTimer()\n\tinsertP := perm(benchmarkTreeSize)\n\tb.StartTimer()\n\ti := 0\n\tfor i < b.N {\n\t\ttr := New(*btreeDegree)\n\t\tfor _, item := range insertP {\n\t\t\ttr.ReplaceOrInsert(item)\n\t\t\ti++\n\t\t\tif i >= b.N {\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc BenchmarkSeek(b *testing.B) {\n\tb.StopTimer()\n\tsize := 100000\n\tinsertP := perm(size)\n\ttr := New(*btreeDegree)\n\tfor _, item := range insertP {\n\t\ttr.ReplaceOrInsert(item)\n\t}\n\tb.StartTimer()\n\n\tfor i := 0; i < b.N; i++ {\n\t\ttr.AscendGreaterOrEqual(Int(i%size), func(i Item) bool { return false })\n\t}\n}\n\nfunc BenchmarkDeleteInsert(b *testing.B) {\n\tb.StopTimer()\n\tinsertP := perm(benchmarkTreeSize)\n\ttr := New(*btreeDegree)\n\tfor _, item := range insertP {\n\t\ttr.ReplaceOrInsert(item)\n\t}\n\tb.StartTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\ttr.Delete(insertP[i%benchmarkTreeSize])\n\t\ttr.ReplaceOrInsert(insertP[i%benchmarkTreeSize])\n\t}\n}\n\nfunc BenchmarkDeleteInsertCloneOnce(b *testing.B) {\n\tb.StopTimer()\n\tinsertP := perm(benchmarkTreeSize)\n\ttr := New(*btreeDegree)\n\tfor _, item := range insertP {\n\t\ttr.ReplaceOrInsert(item)\n\t}\n\ttr = tr.Clone()\n\tb.StartTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\ttr.Delete(insertP[i%benchmarkTreeSize])\n\t\ttr.ReplaceOrInsert(insertP[i%benchmarkTreeSize])\n\t}\n}\n\nfunc BenchmarkDeleteInsertCloneEachTime(b *testing.B) {\n\tb.StopTimer()\n\tinsertP := perm(benchmarkTreeSize)\n\ttr := New(*btreeDegree)\n\tfor _, item := range insertP {\n\t\ttr.ReplaceOrInsert(item)\n\t}\n\tb.StartTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\ttr = tr.Clone()\n\t\ttr.Delete(insertP[i%benchmarkTreeSize])\n\t\ttr.ReplaceOrInsert(insertP[i%benchmarkTreeSize])\n\t}\n}\n\nfunc BenchmarkDelete(b *testing.B) {\n\tb.StopTimer()\n\tinsertP := perm(benchmarkTreeSize)\n\tremoveP := perm(benchmarkTreeSize)\n\tb.StartTimer()\n\ti := 0\n\tfor i < b.N {\n\t\tb.StopTimer()\n\t\ttr := New(*btreeDegree)\n\t\tfor _, v := range insertP {\n\t\t\ttr.ReplaceOrInsert(v)\n\t\t}\n\t\tb.StartTimer()\n\t\tfor _, item := range removeP {\n\t\t\ttr.Delete(item)\n\t\t\ti++\n\t\t\tif i >= b.N {\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t\tif tr.Len() > 0 {\n\t\t\tpanic(tr.Len())\n\t\t}\n\t}\n}\n\nfunc BenchmarkGet(b *testing.B) {\n\tb.StopTimer()\n\tinsertP := perm(benchmarkTreeSize)\n\tremoveP := perm(benchmarkTreeSize)\n\tb.StartTimer()\n\ti := 0\n\tfor i < b.N {\n\t\tb.StopTimer()\n\t\ttr := New(*btreeDegree)\n\t\tfor _, v := range insertP {\n\t\t\ttr.ReplaceOrInsert(v)\n\t\t}\n\t\tb.StartTimer()\n\t\tfor _, item := range removeP {\n\t\t\ttr.Get(item)\n\t\t\ti++\n\t\t\tif i >= b.N {\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc BenchmarkGetCloneEachTime(b *testing.B) {\n\tb.StopTimer()\n\tinsertP := perm(benchmarkTreeSize)\n\tremoveP := perm(benchmarkTreeSize)\n\tb.StartTimer()\n\ti := 0\n\tfor i < b.N {\n\t\tb.StopTimer()\n\t\ttr := New(*btreeDegree)\n\t\tfor _, v := range insertP {\n\t\t\ttr.ReplaceOrInsert(v)\n\t\t}\n\t\tb.StartTimer()\n\t\tfor _, item := range removeP {\n\t\t\ttr = tr.Clone()\n\t\t\ttr.Get(item)\n\t\t\ti++\n\t\t\tif i >= b.N {\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t}\n}\n\ntype byInts []Item\n\nfunc (a byInts) Len() int {\n\treturn len(a)\n}\n\nfunc (a byInts) Less(i, j int) bool {\n\treturn a[i].(Int) < a[j].(Int)\n}\n\nfunc (a byInts) Swap(i, j int) {\n\ta[i], a[j] = a[j], a[i]\n}\n\nfunc BenchmarkAscend(b *testing.B) {\n\tarr := perm(benchmarkTreeSize)\n\ttr := New(*btreeDegree)\n\tfor _, v := range arr {\n\t\ttr.ReplaceOrInsert(v)\n\t}\n\tsort.Sort(byInts(arr))\n\tb.ResetTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\tj := 0\n\t\ttr.Ascend(func(item Item) bool {\n\t\t\tif item.(Int) != arr[j].(Int) {\n\t\t\t\tb.Fatalf(\"mismatch: expected: %v, got %v\", arr[j].(Int), item.(Int))\n\t\t\t}\n\t\t\tj++\n\t\t\treturn true\n\t\t})\n\t}\n}\n\nfunc BenchmarkDescend(b *testing.B) {\n\tarr := perm(benchmarkTreeSize)\n\ttr := New(*btreeDegree)\n\tfor _, v := range arr {\n\t\ttr.ReplaceOrInsert(v)\n\t}\n\tsort.Sort(byInts(arr))\n\tb.ResetTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\tj := len(arr) - 1\n\t\ttr.Descend(func(item Item) bool {\n\t\t\tif item.(Int) != arr[j].(Int) {\n\t\t\t\tb.Fatalf(\"mismatch: expected: %v, got %v\", arr[j].(Int), item.(Int))\n\t\t\t}\n\t\t\tj--\n\t\t\treturn true\n\t\t})\n\t}\n}\nfunc BenchmarkAscendRange(b *testing.B) {\n\tarr := perm(benchmarkTreeSize)\n\ttr := New(*btreeDegree)\n\tfor _, v := range arr {\n\t\ttr.ReplaceOrInsert(v)\n\t}\n\tsort.Sort(byInts(arr))\n\tb.ResetTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\tj := 100\n\t\ttr.AscendRange(Int(100), arr[len(arr)-100], func(item Item) bool {\n\t\t\tif item.(Int) != arr[j].(Int) {\n\t\t\t\tb.Fatalf(\"mismatch: expected: %v, got %v\", arr[j].(Int), item.(Int))\n\t\t\t}\n\t\t\tj++\n\t\t\treturn true\n\t\t})\n\t\tif j != len(arr)-100 {\n\t\t\tb.Fatalf(\"expected: %v, got %v\", len(arr)-100, j)\n\t\t}\n\t}\n}\n\nfunc BenchmarkDescendRange(b *testing.B) {\n\tarr := perm(benchmarkTreeSize)\n\ttr := New(*btreeDegree)\n\tfor _, v := range arr {\n\t\ttr.ReplaceOrInsert(v)\n\t}\n\tsort.Sort(byInts(arr))\n\tb.ResetTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\tj := len(arr) - 100\n\t\ttr.DescendRange(arr[len(arr)-100], Int(100), func(item Item) bool {\n\t\t\tif item.(Int) != arr[j].(Int) {\n\t\t\t\tb.Fatalf(\"mismatch: expected: %v, got %v\", arr[j].(Int), item.(Int))\n\t\t\t}\n\t\t\tj--\n\t\t\treturn true\n\t\t})\n\t\tif j != 100 {\n\t\t\tb.Fatalf(\"expected: %v, got %v\", len(arr)-100, j)\n\t\t}\n\t}\n}\nfunc BenchmarkAscendGreaterOrEqual(b *testing.B) {\n\tarr := perm(benchmarkTreeSize)\n\ttr := New(*btreeDegree)\n\tfor _, v := range arr {\n\t\ttr.ReplaceOrInsert(v)\n\t}\n\tsort.Sort(byInts(arr))\n\tb.ResetTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\tj := 100\n\t\tk := 0\n\t\ttr.AscendGreaterOrEqual(Int(100), func(item Item) bool {\n\t\t\tif item.(Int) != arr[j].(Int) {\n\t\t\t\tb.Fatalf(\"mismatch: expected: %v, got %v\", arr[j].(Int), item.(Int))\n\t\t\t}\n\t\t\tj++\n\t\t\tk++\n\t\t\treturn true\n\t\t})\n\t\tif j != len(arr) {\n\t\t\tb.Fatalf(\"expected: %v, got %v\", len(arr), j)\n\t\t}\n\t\tif k != len(arr)-100 {\n\t\t\tb.Fatalf(\"expected: %v, got %v\", len(arr)-100, k)\n\t\t}\n\t}\n}\nfunc BenchmarkDescendLessOrEqual(b *testing.B) {\n\tarr := perm(benchmarkTreeSize)\n\ttr := New(*btreeDegree)\n\tfor _, v := range arr {\n\t\ttr.ReplaceOrInsert(v)\n\t}\n\tsort.Sort(byInts(arr))\n\tb.ResetTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\tj := len(arr) - 100\n\t\tk := len(arr)\n\t\ttr.DescendLessOrEqual(arr[len(arr)-100], func(item Item) bool {\n\t\t\tif item.(Int) != arr[j].(Int) {\n\t\t\t\tb.Fatalf(\"mismatch: expected: %v, got %v\", arr[j].(Int), item.(Int))\n\t\t\t}\n\t\t\tj--\n\t\t\tk--\n\t\t\treturn true\n\t\t})\n\t\tif j != -1 {\n\t\t\tb.Fatalf(\"expected: %v, got %v\", -1, j)\n\t\t}\n\t\tif k != 99 {\n\t\t\tb.Fatalf(\"expected: %v, got %v\", 99, k)\n\t\t}\n\t}\n}\n\nconst cloneTestSize = 10000\n\nfunc cloneTest(t *testing.T, b *BTree, start int, p []Item, wg *sync.WaitGroup, trees *[]*BTree, lock *sync.Mutex) {\n\tt.Logf(\"Starting new clone at %v\", start)\n\tlock.Lock()\n\t*trees = append(*trees, b)\n\tlock.Unlock()\n\tfor i := start; i < cloneTestSize; i++ {\n\t\tb.ReplaceOrInsert(p[i])\n\t\tif i%(cloneTestSize/5) == 0 {\n\t\t\twg.Add(1)\n\t\t\tgo cloneTest(t, b.Clone(), i+1, p, wg, trees, lock)\n\t\t}\n\t}\n\twg.Done()\n}\n\nfunc TestCloneConcurrentOperations(t *testing.T) {\n\tb := New(*btreeDegree)\n\ttrees := []*BTree{}\n\tp := perm(cloneTestSize)\n\tvar wg sync.WaitGroup\n\twg.Add(1)\n\tgo cloneTest(t, b, 0, p, &wg, &trees, &sync.Mutex{})\n\twg.Wait()\n\twant := rang(cloneTestSize)\n\tt.Logf(\"Starting equality checks on %d trees\", len(trees))\n\tfor i, tree := range trees {\n\t\tif !reflect.DeepEqual(want, all(tree)) {\n\t\t\tt.Errorf(\"tree %v mismatch\", i)\n\t\t}\n\t}\n\tt.Log(\"Removing half from first half\")\n\ttoRemove := rang(cloneTestSize)[cloneTestSize/2:]\n\tfor i := 0; i < len(trees)/2; i++ {\n\t\ttree := trees[i]\n\t\twg.Add(1)\n\t\tgo func() {\n\t\t\tfor _, item := range toRemove {\n\t\t\t\ttree.Delete(item)\n\t\t\t}\n\t\t\twg.Done()\n\t\t}()\n\t}\n\twg.Wait()\n\tt.Log(\"Checking all values again\")\n\tfor i, tree := range trees {\n\t\tvar wantpart []Item\n\t\tif i < len(trees)/2 {\n\t\t\twantpart = want[:cloneTestSize/2]\n\t\t} else {\n\t\t\twantpart = want\n\t\t}\n\t\tif got := all(tree); !reflect.DeepEqual(wantpart, got) {\n\t\t\tt.Errorf(\"tree %v mismatch, want %v got %v\", i, len(want), len(got))\n\t\t}\n\t}\n}\n\nfunc BenchmarkDeleteAndRestore(b *testing.B) {\n\titems := perm(16392)\n\tb.ResetTimer()\n\tb.Run(`CopyBigFreeList`, func(b *testing.B) {\n\t\tfl := NewFreeList(16392)\n\t\ttr := NewWithFreeList(*btreeDegree, fl)\n\t\tfor _, v := range items {\n\t\t\ttr.ReplaceOrInsert(v)\n\t\t}\n\t\tb.ReportAllocs()\n\t\tb.ResetTimer()\n\t\tfor i := 0; i < b.N; i++ {\n\t\t\tdels := make([]Item, 0, tr.Len())\n\t\t\ttr.Ascend(ItemIterator(func(b Item) bool {\n\t\t\t\tdels = append(dels, b)\n\t\t\t\treturn true\n\t\t\t}))\n\t\t\tfor _, del := range dels {\n\t\t\t\ttr.Delete(del)\n\t\t\t}\n\t\t\t// tr is now empty, we make a new empty copy of it.\n\t\t\ttr = NewWithFreeList(*btreeDegree, fl)\n\t\t\tfor _, v := range items {\n\t\t\t\ttr.ReplaceOrInsert(v)\n\t\t\t}\n\t\t}\n\t})\n\tb.Run(`Copy`, func(b *testing.B) {\n\t\ttr := New(*btreeDegree)\n\t\tfor _, v := range items {\n\t\t\ttr.ReplaceOrInsert(v)\n\t\t}\n\t\tb.ReportAllocs()\n\t\tb.ResetTimer()\n\t\tfor i := 0; i < b.N; i++ {\n\t\t\tdels := make([]Item, 0, tr.Len())\n\t\t\ttr.Ascend(ItemIterator(func(b Item) bool {\n\t\t\t\tdels = append(dels, b)\n\t\t\t\treturn true\n\t\t\t}))\n\t\t\tfor _, del := range dels {\n\t\t\t\ttr.Delete(del)\n\t\t\t}\n\t\t\t// tr is now empty, we make a new empty copy of it.\n\t\t\ttr = New(*btreeDegree)\n\t\t\tfor _, v := range items {\n\t\t\t\ttr.ReplaceOrInsert(v)\n\t\t\t}\n\t\t}\n\t})\n\tb.Run(`ClearBigFreelist`, func(b *testing.B) {\n\t\tfl := NewFreeList(16392)\n\t\ttr := NewWithFreeList(*btreeDegree, fl)\n\t\tfor _, v := range items {\n\t\t\ttr.ReplaceOrInsert(v)\n\t\t}\n\t\tb.ReportAllocs()\n\t\tb.ResetTimer()\n\t\tfor i := 0; i < b.N; i++ {\n\t\t\ttr.Clear(true)\n\t\t\tfor _, v := range items {\n\t\t\t\ttr.ReplaceOrInsert(v)\n\t\t\t}\n\t\t}\n\t})\n\tb.Run(`Clear`, func(b *testing.B) {\n\t\ttr := New(*btreeDegree)\n\t\tfor _, v := range items {\n\t\t\ttr.ReplaceOrInsert(v)\n\t\t}\n\t\tb.ReportAllocs()\n\t\tb.ResetTimer()\n\t\tfor i := 0; i < b.N; i++ {\n\t\t\ttr.Clear(true)\n\t\t\tfor _, v := range items {\n\t\t\t\ttr.ReplaceOrInsert(v)\n\t\t\t}\n\t\t}\n\t})\n}\n"
        },
        {
          "name": "go.mod",
          "type": "blob",
          "size": 0.6142578125,
          "content": "// Copyright 2014 Google Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nmodule github.com/google/btree\n\ngo 1.18\n"
        }
      ]
    }
  ]
}