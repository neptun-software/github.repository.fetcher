{
  "metadata": {
    "timestamp": 1736566588252,
    "page": 141,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjE1MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "jung-kurt/gofpdf",
      "stars": 4361,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".gitattribute",
          "type": "blob",
          "size": 0.0126953125,
          "content": "*.pdf binary\n"
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.2880859375,
          "content": "*.0\ncoverage\nfont/CalligrapherRegular.json\nfont/CalligrapherRegular.z\nfont/Ubuntu-*\ninternal/files/bin/bin\nlook\nmakefont/makefont\nopen\n**/*.out\npdf/*.pdf\npdf.txt\nprivate\n*.sublime*\n*.swp\n**/*.test\n.idea/\ndoc/body.html\ndoc/body.md\ndoc/index.html\ndoc/index.html.ok\ncoverage.html\n\n# macOS\n.DS_Store"
        },
        {
          "name": ".travis.yml",
          "type": "blob",
          "size": 0.1171875,
          "content": "language: go\n\nsudo: false\n\ngo:\n  - master\n\nos:\n  - linux\n            \nscript: go test -v\n\nnotifications:\n  email: false\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.0908203125,
          "content": "MIT License\n\nCopyright (c) 2017 Kurt Jung and contributors acknowledged in the documentation\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n"
        },
        {
          "name": "Makefile",
          "type": "blob",
          "size": 0.7294921875,
          "content": "all : documentation\n\ndocumentation : doc/index.html doc.go README.md \n\ncov : all\n\tgo test -v -coverprofile=coverage && go tool cover -html=coverage -o=coverage.html\n\ncheck :\n\tgolint .\n\tgo vet -all .\n\tgofmt -s -l .\n\tgoreportcard-cli -v | grep -v cyclomatic\n\nREADME.md : doc/document.md\n\tpandoc --read=markdown --write=gfm < $< > $@\n\ndoc/index.html : doc/document.md doc/html.txt\n\tpandoc --read=markdown --write=html --template=doc/html.txt \\\n\t\t--metadata pagetitle=\"GoFPDF Document Generator\" < $< > $@\n\ndoc.go : doc/document.md doc/go.awk\n\tpandoc --read=markdown --write=plain $< | awk --assign=package_name=gofpdf --file=doc/go.awk > $@\n\tgofmt -s -w $@\n\nbuild :\n\tgo build -v\n\nclean :\n\trm -f coverage.html coverage doc/index.html doc.go README.md\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 12.4375,
          "content": "# GoFPDF document generator\n\n[![No Maintenance\nIntended](http://unmaintained.tech/badge.svg)](http://unmaintained.tech/)\n[![MIT\nlicensed](https://img.shields.io/badge/license-MIT-blue.svg)](https://raw.githubusercontent.com/jung-kurt/gofpdf/master/LICENSE)\n[![GoDoc](https://img.shields.io/badge/godoc-GoFPDF-blue.svg)](https://pkg.go.dev/github.com/jung-kurt/gofpdf)\n\n![](https://raw.githubusercontent.com/jung-kurt/gofpdf/master/image/logo_gofpdf.jpg)\n\nPackage gofpdf implements a PDF document generator with high level\nsupport for text, drawing and images.\n\n## Features\n\n  - UTF-8 support\n  - Choice of measurement unit, page format and margins\n  - Page header and footer management\n  - Automatic page breaks, line breaks, and text justification\n  - Inclusion of JPEG, PNG, GIF, TIFF and basic path-only SVG images\n  - Colors, gradients and alpha channel transparency\n  - Outline bookmarks\n  - Internal and external links\n  - TrueType, Type1 and encoding support\n  - Page compression\n  - Lines, Bézier curves, arcs, and ellipses\n  - Rotation, scaling, skewing, translation, and mirroring\n  - Clipping\n  - Document protection\n  - Layers\n  - Templates\n  - Barcodes\n  - Charting facility\n  - Import PDFs as templates\n\ngofpdf has no dependencies other than the Go standard library. All tests\npass on Linux, Mac and Windows platforms.\n\ngofpdf supports UTF-8 TrueType fonts and “right-to-left” languages. Note\nthat Chinese, Japanese, and Korean characters may not be included in\nmany general purpose fonts. For these languages, a specialized font (for\nexample,\n[NotoSansSC](https://github.com/jsntn/webfonts/blob/master/NotoSansSC-Regular.ttf)\nfor simplified Chinese) can be used.\n\nAlso, support is provided to automatically translate UTF-8 runes to code\npage encodings for languages that have fewer than 256 glyphs.\n\n## We Are Closed\n\nThis repository will not be maintained, at least for some unknown\nduration. But it is hoped that gofpdf has a bright future in the open\nsource world. Due to Go’s promise of compatibility, gofpdf should\ncontinue to function without modification for a longer time than would\nbe the case with many other languages.\n\nForks should be based on the [last viable\ncommit](https://github.com/jung-kurt/gofpdf/commit/603f56990463f011cb1dbb64ef7f872c1adc009a).\nTools such as\n[active-forks](https://techgaun.github.io/active-forks/index.html#jung-kurt/gofpdf)\ncan be used to select a fork that looks promising for your needs. If a\nparticular fork looks like it has taken the lead in attracting\nfollowers, this README will be updated to point people in that\ndirection.\n\nThe efforts of all contributors to this project have been deeply\nappreciated. Best wishes to all of you.\n\n## Installation\n\nTo install the package on your system, run\n\n``` shell\ngo get github.com/jung-kurt/gofpdf\n```\n\nLater, to receive updates, run\n\n``` shell\ngo get -u -v github.com/jung-kurt/gofpdf/...\n```\n\n## Quick Start\n\nThe following Go code generates a simple PDF file.\n\n``` go\npdf := gofpdf.New(\"P\", \"mm\", \"A4\", \"\")\npdf.AddPage()\npdf.SetFont(\"Arial\", \"B\", 16)\npdf.Cell(40, 10, \"Hello, world\")\nerr := pdf.OutputFileAndClose(\"hello.pdf\")\n```\n\nSee the functions in the\n[fpdf\\_test.go](https://github.com/jung-kurt/gofpdf/blob/master/fpdf_test.go)\nfile (shown as examples in this documentation) for more advanced PDF\nexamples.\n\n## Errors\n\nIf an error occurs in an Fpdf method, an internal error field is set.\nAfter this occurs, Fpdf method calls typically return without performing\nany operations and the error state is retained. This error management\nscheme facilitates PDF generation since individual method calls do not\nneed to be examined for failure; it is generally sufficient to wait\nuntil after `Output()` is called. For the same reason, if an error\noccurs in the calling application during PDF generation, it may be\ndesirable for the application to transfer the error to the Fpdf instance\nby calling the `SetError()` method or the `SetErrorf()` method. At any\ntime during the life cycle of the Fpdf instance, the error state can be\ndetermined with a call to `Ok()` or `Err()`. The error itself can be\nretrieved with a call to `Error()`.\n\n## Conversion Notes\n\nThis package is a relatively straightforward translation from the\noriginal [FPDF](http://www.fpdf.org/) library written in PHP (despite\nthe caveat in the introduction to [Effective\nGo](https://golang.org/doc/effective_go.html)). The API names have been\nretained even though the Go idiom would suggest otherwise (for example,\n`pdf.GetX()` is used rather than simply `pdf.X()`). The similarity of\nthe two libraries makes the original FPDF website a good source of\ninformation. It includes a forum and FAQ.\n\nHowever, some internal changes have been made. Page content is built up\nusing buffers (of type bytes.Buffer) rather than repeated string\nconcatenation. Errors are handled as explained above rather than\npanicking. Output is generated through an interface of type io.Writer or\nio.WriteCloser. A number of the original PHP methods behave differently\nbased on the type of the arguments that are passed to them; in these\ncases additional methods have been exported to provide similar\nfunctionality. Font definition files are produced in JSON rather than\nPHP.\n\n## Example PDFs\n\nA side effect of running `go test ./...` is the production of a number\nof example PDFs. These can be found in the gofpdf/pdf directory after\nthe tests complete.\n\nPlease note that these examples run in the context of a test. In order\nrun an example as a standalone application, you’ll need to examine\n[fpdf\\_test.go](https://github.com/jung-kurt/gofpdf/blob/master/fpdf_test.go)\nfor some helper routines, for example `exampleFilename()` and\n`summary()`.\n\nExample PDFs can be compared with reference copies in order to verify\nthat they have been generated as expected. This comparison will be\nperformed if a PDF with the same name as the example PDF is placed in\nthe gofpdf/pdf/reference directory and if the third argument to\n`ComparePDFFiles()` in internal/example/example.go is true. (By default\nit is false.) The routine that summarizes an example will look for this\nfile and, if found, will call `ComparePDFFiles()` to check the example\nPDF for equality with its reference PDF. If differences exist between\nthe two files they will be printed to standard output and the test will\nfail. If the reference file is missing, the comparison is considered to\nsucceed. In order to successfully compare two PDFs, the placement of\ninternal resources must be consistent and the internal creation\ntimestamps must be the same. To do this, the methods `SetCatalogSort()`\nand `SetCreationDate()` need to be called for both files. This is done\nautomatically for all examples.\n\n## Nonstandard Fonts\n\nNothing special is required to use the standard PDF fonts (courier,\nhelvetica, times, zapfdingbats) in your documents other than calling\n`SetFont()`.\n\nYou should use `AddUTF8Font()` or `AddUTF8FontFromBytes()` to add a\nTrueType UTF-8 encoded font. Use `RTL()` and `LTR()` methods switch\nbetween “right-to-left” and “left-to-right” mode.\n\nIn order to use a different non-UTF-8 TrueType or Type1 font, you will\nneed to generate a font definition file and, if the font will be\nembedded into PDFs, a compressed version of the font file. This is done\nby calling the MakeFont function or using the included makefont command\nline utility. To create the utility, cd into the makefont subdirectory\nand run “go build”. This will produce a standalone executable named\nmakefont. Select the appropriate encoding file from the font\nsubdirectory and run the command as in the following example.\n\n``` shell\n./makefont --embed --enc=../font/cp1252.map --dst=../font ../font/calligra.ttf\n```\n\nIn your PDF generation code, call `AddFont()` to load the font and, as\nwith the standard fonts, SetFont() to begin using it. Most examples,\nincluding the package example, demonstrate this method. Good sources of\nfree, open-source fonts include [Google\nFonts](https://fonts.google.com/) and [DejaVu\nFonts](http://dejavu-fonts.org/).\n\n## Related Packages\n\nThe [draw2d](https://github.com/llgcode/draw2d) package is a two\ndimensional vector graphics library that can generate output in\ndifferent forms. It uses gofpdf for its document production mode.\n\n## Contributing Changes\n\ngofpdf is a global community effort and you are invited to make it even\nbetter. If you have implemented a new feature or corrected a problem,\nplease consider contributing your change to the project. A contribution\nthat does not directly pertain to the core functionality of gofpdf\nshould be placed in its own directory directly beneath the `contrib`\ndirectory.\n\nHere are guidelines for making submissions. Your change should\n\n  - be compatible with the MIT License\n  - be properly documented\n  - be formatted with `go fmt`\n  - include an example in\n    [fpdf\\_test.go](https://github.com/jung-kurt/gofpdf/blob/master/fpdf_test.go)\n    if appropriate\n  - conform to the standards of [golint](https://github.com/golang/lint)\n    and [go vet](https://golang.org/cmd/vet/), that is, `golint .` and\n    `go vet .` should not generate any warnings\n  - not diminish [test coverage](https://blog.golang.org/cover)\n\n[Pull requests](https://help.github.com/articles/using-pull-requests/)\nare the preferred means of accepting your changes.\n\n## License\n\ngofpdf is released under the MIT License. It is copyrighted by Kurt Jung\nand the contributors acknowledged below.\n\n## Acknowledgments\n\nThis package’s code and documentation are closely derived from the\n[FPDF](http://www.fpdf.org/) library created by Olivier Plathey, and a\nnumber of font and image resources are copied directly from it. Bruno\nMichel has provided valuable assistance with the code. Drawing support\nis adapted from the FPDF geometric figures script by David Hernández\nSanz. Transparency support is adapted from the FPDF transparency script\nby Martin Hall-May. Support for gradients and clipping is adapted from\nFPDF scripts by Andreas Würmser. Support for outline bookmarks is\nadapted from Olivier Plathey by Manuel Cornes. Layer support is adapted\nfrom Olivier Plathey. Support for transformations is adapted from the\nFPDF transformation script by Moritz Wagner and Andreas Würmser. PDF\nprotection is adapted from the work of Klemen Vodopivec for the FPDF\nproduct. Lawrence Kesteloot provided code to allow an image’s extent to\nbe determined prior to placement. Support for vertical alignment within\na cell was provided by Stefan Schroeder. Ivan Daniluk generalized the\nfont and image loading code to use the Reader interface while\nmaintaining backward compatibility. Anthony Starks provided code for the\nPolygon function. Robert Lillack provided the Beziergon function and\ncorrected some naming issues with the internal curve function. Claudio\nFelber provided implementations for dashed line drawing and generalized\nfont loading. Stani Michiels provided support for multi-segment path\ndrawing with smooth line joins, line join styles, enhanced fill modes,\nand has helped greatly with package presentation and tests. Templating\nis adapted by Marcus Downing from the FPDF\\_Tpl library created by Jan\nSlabon and Setasign. Jelmer Snoeck contributed packages that generate a\nvariety of barcodes and help with registering images on the web. Jelmer\nSnoek and Guillermo Pascual augmented the basic HTML functionality with\naligned text. Kent Quirk implemented backwards-compatible support for\nreading DPI from images that support it, and for setting DPI manually\nand then having it properly taken into account when calculating image\nsize. Paulo Coutinho provided support for static embedded fonts. Dan\nMeyers added support for embedded JavaScript. David Fish added a generic\nalias-replacement function to enable, among other things, table of\ncontents functionality. Andy Bakun identified and corrected a problem in\nwhich the internal catalogs were not sorted stably. Paul Montag added\nencoding and decoding functionality for templates, including images that\nare embedded in templates; this allows templates to be stored\nindependently of gofpdf. Paul also added support for page boxes used in\nprinting PDF documents. Wojciech Matusiak added supported for word\nspacing. Artem Korotkiy added support of UTF-8 fonts. Dave Barnes added\nsupport for imported objects and templates. Brigham Thompson added\nsupport for rounded rectangles. Joe Westcott added underline\nfunctionality and optimized image storage. Benoit KUGLER contributed\nsupport for rectangles with corners of unequal radius, modification\ntimes, and for file attachments and annotations.\n\n## Roadmap\n\n  - Remove all legacy code page font support; use UTF-8 exclusively\n  - Improve test coverage as reported by the coverage tool.\n"
        },
        {
          "name": "attachments.go",
          "type": "blob",
          "size": 5.1162109375,
          "content": "package gofpdf\n\nimport (\n\t\"crypto/md5\"\n\t\"encoding/hex\"\n\t\"fmt\"\n\t\"strings\"\n)\n\n// Attachment defines a content to be included in the pdf, in one\n// of the following ways :\n// \t- associated with the document as a whole : see SetAttachments()\n//\t- accessible via a link localized on a page : see AddAttachmentAnnotation()\ntype Attachment struct {\n\tContent []byte\n\n\t// Filename is the displayed name of the attachment\n\tFilename string\n\n\t// Description is only displayed when using AddAttachmentAnnotation(),\n\t// and might be modified by the pdf reader.\n\tDescription string\n\n\tobjectNumber int // filled when content is included\n}\n\n// return the hex encoded checksum of `data`\nfunc checksum(data []byte) string {\n\ttmp := md5.Sum(data)\n\tsl := make([]byte, len(tmp))\n\tfor i, v := range tmp {\n\t\tsl[i] = v\n\t}\n\treturn hex.EncodeToString(sl)\n}\n\n// Writes a compressed file like object as ``/EmbeddedFile``. Compressing is\n// done with deflate. Includes length, compressed length and MD5 checksum.\nfunc (f *Fpdf) writeCompressedFileObject(content []byte) {\n\tlenUncompressed := len(content)\n\tsum := checksum(content)\n\tcompressed := sliceCompress(content)\n\tlenCompressed := len(compressed)\n\tf.newobj()\n\tf.outf(\"<< /Type /EmbeddedFile /Length %d /Filter /FlateDecode /Params << /CheckSum <%s> /Size %d >> >>\\n\",\n\t\tlenCompressed, sum, lenUncompressed)\n\tf.putstream(compressed)\n\tf.out(\"endobj\")\n}\n\n// Embed includes the content of `a`, and update its internal reference.\nfunc (f *Fpdf) embed(a *Attachment) {\n\tif a.objectNumber != 0 { // already embedded (objectNumber start at 2)\n\t\treturn\n\t}\n\toldState := f.state\n\tf.state = 1 // we write file content in the main buffer\n\tf.writeCompressedFileObject(a.Content)\n\tstreamID := f.n\n\tf.newobj()\n\tf.outf(\"<< /Type /Filespec /F () /UF %s /EF << /F %d 0 R >> /Desc %s\\n>>\",\n\t\tf.textstring(utf8toutf16(a.Filename)),\n\t\tstreamID,\n\t\tf.textstring(utf8toutf16(a.Description)))\n\tf.out(\"endobj\")\n\ta.objectNumber = f.n\n\tf.state = oldState\n}\n\n// SetAttachments writes attachments as embedded files (document attachment).\n// These attachments are global, see AddAttachmentAnnotation() for a link\n// anchored in a page. Note that only the last call of SetAttachments is\n// useful, previous calls are discarded. Be aware that not all PDF readers\n// support document attachments. See the SetAttachment example for a\n// demonstration of this method.\nfunc (f *Fpdf) SetAttachments(as []Attachment) {\n\tf.attachments = as\n}\n\n// embed current attachments. store object numbers\n// for later use by getEmbeddedFiles()\nfunc (f *Fpdf) putAttachments() {\n\tfor i, a := range f.attachments {\n\t\tf.embed(&a)\n\t\tf.attachments[i] = a\n\t}\n}\n\n// return /EmbeddedFiles tree name catalog entry.\nfunc (f Fpdf) getEmbeddedFiles() string {\n\tnames := make([]string, len(f.attachments))\n\tfor i, as := range f.attachments {\n\t\tnames[i] = fmt.Sprintf(\"(Attachement%d) %d 0 R \", i+1, as.objectNumber)\n\t}\n\tnameTree := fmt.Sprintf(\"<< /Names [\\n %s \\n] >>\", strings.Join(names, \"\\n\"))\n\treturn nameTree\n}\n\n// ---------------------------------- Annotations ----------------------------------\n\ntype annotationAttach struct {\n\t*Attachment\n\n\tx, y, w, h float64 // fpdf coordinates (y diff and scaling done)\n}\n\n// AddAttachmentAnnotation puts a link on the current page, on the rectangle\n// defined by `x`, `y`, `w`, `h`. This link points towards the content defined\n// in `a`, which is embedded in the document. Note than no drawing is done by\n// this method : a method like `Cell()` or `Rect()` should be called to\n// indicate to the reader that there is a link here. Requiring a pointer to an\n// Attachment avoids useless copies in the resulting pdf: attachment pointing\n// to the same data will have their content only be included once, and be\n// shared amongst all links. Be aware that not all PDF readers support\n// annotated attachments. See the AddAttachmentAnnotation example for a\n// demonstration of this method.\nfunc (f *Fpdf) AddAttachmentAnnotation(a *Attachment, x, y, w, h float64) {\n\tif a == nil {\n\t\treturn\n\t}\n\tf.pageAttachments[f.page] = append(f.pageAttachments[f.page], annotationAttach{\n\t\tAttachment: a,\n\t\tx:          x * f.k, y: f.hPt - y*f.k, w: w * f.k, h: h * f.k,\n\t})\n}\n\n// embed current annotations attachments. store object numbers\n// for later use by putAttachmentAnnotationLinks(), which is\n// called for each page.\nfunc (f *Fpdf) putAnnotationsAttachments() {\n\t// avoid duplication\n\tm := map[*Attachment]bool{}\n\tfor _, l := range f.pageAttachments {\n\t\tfor _, an := range l {\n\t\t\tif m[an.Attachment] { // already embedded\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tf.embed(an.Attachment)\n\t\t}\n\t}\n}\n\nfunc (f *Fpdf) putAttachmentAnnotationLinks(out *fmtBuffer, page int) {\n\tfor _, an := range f.pageAttachments[page] {\n\t\tx1, y1, x2, y2 := an.x, an.y, an.x+an.w, an.y-an.h\n\t\tas := fmt.Sprintf(\"<< /Type /XObject /Subtype /Form /BBox [%.2f %.2f %.2f %.2f] /Length 0 >>\",\n\t\t\tx1, y1, x2, y2)\n\t\tas += \"\\nstream\\nendstream\"\n\n\t\tout.printf(\"<< /Type /Annot /Subtype /FileAttachment /Rect [%.2f %.2f %.2f %.2f] /Border [0 0 0]\\n\",\n\t\t\tx1, y1, x2, y2)\n\t\tout.printf(\"/Contents %s \", f.textstring(utf8toutf16(an.Description)))\n\t\tout.printf(\"/T %s \", f.textstring(utf8toutf16(an.Filename)))\n\t\tout.printf(\"/AP << /N %s>>\", as)\n\t\tout.printf(\"/FS %d 0 R >>\\n\", an.objectNumber)\n\t}\n}\n"
        },
        {
          "name": "compare.go",
          "type": "blob",
          "size": 3.470703125,
          "content": "/*\n * Copyright (c) 2015 Kurt Jung (Gmail: kurt.w.jung)\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\n * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\n * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\npackage gofpdf\n\nimport (\n\t\"bytes\"\n\t\"fmt\"\n\t\"io\"\n\t\"io/ioutil\"\n\t\"sort\"\n)\n\ntype sortType struct {\n\tlength int\n\tless   func(int, int) bool\n\tswap   func(int, int)\n}\n\nfunc (s *sortType) Len() int {\n\treturn s.length\n}\n\nfunc (s *sortType) Less(i, j int) bool {\n\treturn s.less(i, j)\n}\n\nfunc (s *sortType) Swap(i, j int) {\n\ts.swap(i, j)\n}\n\nfunc gensort(Len int, Less func(int, int) bool, Swap func(int, int)) {\n\tsort.Sort(&sortType{length: Len, less: Less, swap: Swap})\n}\n\nfunc writeBytes(leadStr string, startPos int, sl []byte) {\n\tvar pos, max int\n\tvar b byte\n\tfmt.Printf(\"%s %07x\", leadStr, startPos)\n\tmax = len(sl)\n\tfor pos < max {\n\t\tfmt.Printf(\" \")\n\t\tfor k := 0; k < 8; k++ {\n\t\t\tif pos < max {\n\t\t\t\tfmt.Printf(\" %02x\", sl[pos])\n\t\t\t} else {\n\t\t\t\tfmt.Printf(\"   \")\n\t\t\t}\n\t\t\tpos++\n\t\t}\n\t}\n\tfmt.Printf(\"  |\")\n\tpos = 0\n\tfor pos < max {\n\t\tb = sl[pos]\n\t\tif b < 32 || b >= 128 {\n\t\t\tb = '.'\n\t\t}\n\t\tfmt.Printf(\"%c\", b)\n\t\tpos++\n\t}\n\tfmt.Printf(\"|\\n\")\n}\n\nfunc checkBytes(pos int, sl1, sl2 []byte, printDiff bool) (eq bool) {\n\teq = bytes.Equal(sl1, sl2)\n\tif !eq && printDiff {\n\t\twriteBytes(\"<\", pos, sl1)\n\t\twriteBytes(\">\", pos, sl2)\n\t}\n\treturn\n}\n\n// CompareBytes compares the bytes referred to by sl1 with those referred to by\n// sl2. Nil is returned if the buffers are equal, otherwise an error.\nfunc CompareBytes(sl1, sl2 []byte, printDiff bool) (err error) {\n\tvar posStart, posEnd, len1, len2, length int\n\tvar diffs bool\n\n\tlen1 = len(sl1)\n\tlen2 = len(sl2)\n\tlength = len1\n\tif length > len2 {\n\t\tlength = len2\n\t}\n\tfor posStart < length-1 {\n\t\tposEnd = posStart + 16\n\t\tif posEnd > length {\n\t\t\tposEnd = length\n\t\t}\n\t\tif !checkBytes(posStart, sl1[posStart:posEnd], sl2[posStart:posEnd], printDiff) {\n\t\t\tdiffs = true\n\t\t}\n\t\tposStart = posEnd\n\t}\n\tif diffs {\n\t\terr = fmt.Errorf(\"documents are different\")\n\t}\n\treturn\n}\n\n// ComparePDFs reads and compares the full contents of the two specified\n// readers byte-for-byte. Nil is returned if the buffers are equal, otherwise\n// an error.\nfunc ComparePDFs(rdr1, rdr2 io.Reader, printDiff bool) (err error) {\n\tvar b1, b2 *bytes.Buffer\n\t_, err = b1.ReadFrom(rdr1)\n\tif err == nil {\n\t\t_, err = b2.ReadFrom(rdr2)\n\t\tif err == nil {\n\t\t\terr = CompareBytes(b1.Bytes(), b2.Bytes(), printDiff)\n\t\t}\n\t}\n\treturn\n}\n\n// ComparePDFFiles reads and compares the full contents of the two specified\n// files byte-for-byte. Nil is returned if the file contents are equal, or if\n// the second file is missing, otherwise an error.\nfunc ComparePDFFiles(file1Str, file2Str string, printDiff bool) (err error) {\n\tvar sl1, sl2 []byte\n\tsl1, err = ioutil.ReadFile(file1Str)\n\tif err == nil {\n\t\tsl2, err = ioutil.ReadFile(file2Str)\n\t\tif err == nil {\n\t\t\terr = CompareBytes(sl1, sl2, printDiff)\n\t\t} else {\n\t\t\t// Second file is missing; treat this as success\n\t\t\terr = nil\n\t\t}\n\t}\n\treturn\n}\n"
        },
        {
          "name": "contrib",
          "type": "tree",
          "content": null
        },
        {
          "name": "def.go",
          "type": "blob",
          "size": 29.271484375,
          "content": "/*\n * Copyright (c) 2013-2014 Kurt Jung (Gmail: kurt.w.jung)\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\n * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\n * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\npackage gofpdf\n\nimport (\n\t\"bytes\"\n\t\"crypto/sha1\"\n\t\"encoding/gob\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"io\"\n\t\"time\"\n)\n\n// Version of FPDF from which this package is derived\nconst (\n\tcnFpdfVersion = \"1.7\"\n)\n\ntype blendModeType struct {\n\tstrokeStr, fillStr, modeStr string\n\tobjNum                      int\n}\n\ntype gradientType struct {\n\ttp                int // 2: linear, 3: radial\n\tclr1Str, clr2Str  string\n\tx1, y1, x2, y2, r float64\n\tobjNum            int\n}\n\nconst (\n\t// OrientationPortrait represents the portrait orientation.\n\tOrientationPortrait = \"portrait\"\n\n\t// OrientationLandscape represents the landscape orientation.\n\tOrientationLandscape = \"landscape\"\n)\n\nconst (\n\t// UnitPoint represents the size unit point\n\tUnitPoint = \"pt\"\n\t// UnitMillimeter represents the size unit millimeter\n\tUnitMillimeter = \"mm\"\n\t// UnitCentimeter represents the size unit centimeter\n\tUnitCentimeter = \"cm\"\n\t// UnitInch represents the size unit inch\n\tUnitInch = \"inch\"\n)\n\nconst (\n\t// PageSizeA3 represents DIN/ISO A3 page size\n\tPageSizeA3 = \"A3\"\n\t// PageSizeA4 represents DIN/ISO A4 page size\n\tPageSizeA4 = \"A4\"\n\t// PageSizeA5 represents DIN/ISO A5 page size\n\tPageSizeA5 = \"A5\"\n\t// PageSizeLetter represents US Letter page size\n\tPageSizeLetter = \"Letter\"\n\t// PageSizeLegal represents US Legal page size\n\tPageSizeLegal = \"Legal\"\n)\n\nconst (\n\t// BorderNone set no border\n\tBorderNone = \"\"\n\t// BorderFull sets a full border\n\tBorderFull = \"1\"\n\t// BorderLeft sets the border on the left side\n\tBorderLeft = \"L\"\n\t// BorderTop sets the border at the top\n\tBorderTop = \"T\"\n\t// BorderRight sets the border on the right side\n\tBorderRight = \"R\"\n\t// BorderBottom sets the border on the bottom\n\tBorderBottom = \"B\"\n)\n\nconst (\n\t// LineBreakNone disables linebreak\n\tLineBreakNone = 0\n\t// LineBreakNormal enables normal linebreak\n\tLineBreakNormal = 1\n\t// LineBreakBelow enables linebreak below\n\tLineBreakBelow = 2\n)\n\nconst (\n\t// AlignLeft left aligns the cell\n\tAlignLeft = \"L\"\n\t// AlignRight right aligns the cell\n\tAlignRight = \"R\"\n\t// AlignCenter centers the cell\n\tAlignCenter = \"C\"\n\t// AlignTop aligns the cell to the top\n\tAlignTop = \"T\"\n\t// AlignBottom aligns the cell to the bottom\n\tAlignBottom = \"B\"\n\t// AlignMiddle aligns the cell to the middle\n\tAlignMiddle = \"M\"\n\t// AlignBaseline aligns the cell to the baseline\n\tAlignBaseline = \"B\"\n)\n\ntype colorMode int\n\nconst (\n\tcolorModeRGB colorMode = iota\n\tcolorModeSpot\n\tcolorModeCMYK\n)\n\ntype colorType struct {\n\tr, g, b    float64\n\tir, ig, ib int\n\tmode       colorMode\n\tspotStr    string // name of current spot color\n\tgray       bool\n\tstr        string\n}\n\n// SpotColorType specifies a named spot color value\ntype spotColorType struct {\n\tid, objID int\n\tval       cmykColorType\n}\n\n// CMYKColorType specifies an ink-based CMYK color value\ntype cmykColorType struct {\n\tc, m, y, k byte // 0% to 100%\n}\n\n// SizeType fields Wd and Ht specify the horizontal and vertical extents of a\n// document element such as a page.\ntype SizeType struct {\n\tWd, Ht float64\n}\n\n// PointType fields X and Y specify the horizontal and vertical coordinates of\n// a point, typically used in drawing.\ntype PointType struct {\n\tX, Y float64\n}\n\n// XY returns the X and Y components of the receiver point.\nfunc (p PointType) XY() (float64, float64) {\n\treturn p.X, p.Y\n}\n\n// ImageInfoType contains size, color and other information about an image.\n// Changes to this structure should be reflected in its GobEncode and GobDecode\n// methods.\ntype ImageInfoType struct {\n\tdata  []byte  // Raw image data\n\tsmask []byte  // Soft Mask, an 8bit per-pixel transparency mask\n\tn     int     // Image object number\n\tw     float64 // Width\n\th     float64 // Height\n\tcs    string  // Color space\n\tpal   []byte  // Image color palette\n\tbpc   int     // Bits Per Component\n\tf     string  // Image filter\n\tdp    string  // DecodeParms\n\ttrns  []int   // Transparency mask\n\tscale float64 // Document scale factor\n\tdpi   float64 // Dots-per-inch found from image file (png only)\n\ti     string  // SHA-1 checksum of the above values.\n}\n\nfunc generateImageID(info *ImageInfoType) (string, error) {\n\tb, err := info.GobEncode()\n\treturn fmt.Sprintf(\"%x\", sha1.Sum(b)), err\n}\n\n// GobEncode encodes the receiving image to a byte slice.\nfunc (info *ImageInfoType) GobEncode() (buf []byte, err error) {\n\tfields := []interface{}{info.data, info.smask, info.n, info.w, info.h, info.cs,\n\t\tinfo.pal, info.bpc, info.f, info.dp, info.trns, info.scale, info.dpi}\n\tw := new(bytes.Buffer)\n\tencoder := gob.NewEncoder(w)\n\tfor j := 0; j < len(fields) && err == nil; j++ {\n\t\terr = encoder.Encode(fields[j])\n\t}\n\tif err == nil {\n\t\tbuf = w.Bytes()\n\t}\n\treturn\n}\n\n// GobDecode decodes the specified byte buffer (generated by GobEncode) into\n// the receiving image.\nfunc (info *ImageInfoType) GobDecode(buf []byte) (err error) {\n\tfields := []interface{}{&info.data, &info.smask, &info.n, &info.w, &info.h,\n\t\t&info.cs, &info.pal, &info.bpc, &info.f, &info.dp, &info.trns, &info.scale, &info.dpi}\n\tr := bytes.NewBuffer(buf)\n\tdecoder := gob.NewDecoder(r)\n\tfor j := 0; j < len(fields) && err == nil; j++ {\n\t\terr = decoder.Decode(fields[j])\n\t}\n\n\tinfo.i, err = generateImageID(info)\n\treturn\n}\n\n// PointConvert returns the value of pt, expressed in points (1/72 inch), as a\n// value expressed in the unit of measure specified in New(). Since font\n// management in Fpdf uses points, this method can help with line height\n// calculations and other methods that require user units.\nfunc (f *Fpdf) PointConvert(pt float64) (u float64) {\n\treturn pt / f.k\n}\n\n// PointToUnitConvert is an alias for PointConvert.\nfunc (f *Fpdf) PointToUnitConvert(pt float64) (u float64) {\n\treturn pt / f.k\n}\n\n// UnitToPointConvert returns the value of u, expressed in the unit of measure\n// specified in New(), as a value expressed in points (1/72 inch). Since font\n// management in Fpdf uses points, this method can help with setting font sizes\n// based on the sizes of other non-font page elements.\nfunc (f *Fpdf) UnitToPointConvert(u float64) (pt float64) {\n\treturn u * f.k\n}\n\n// Extent returns the width and height of the image in the units of the Fpdf\n// object.\nfunc (info *ImageInfoType) Extent() (wd, ht float64) {\n\treturn info.Width(), info.Height()\n}\n\n// Width returns the width of the image in the units of the Fpdf object.\nfunc (info *ImageInfoType) Width() float64 {\n\treturn info.w / (info.scale * info.dpi / 72)\n}\n\n// Height returns the height of the image in the units of the Fpdf object.\nfunc (info *ImageInfoType) Height() float64 {\n\treturn info.h / (info.scale * info.dpi / 72)\n}\n\n// SetDpi sets the dots per inch for an image. PNG images MAY have their dpi\n// set automatically, if the image specifies it. DPI information is not\n// currently available automatically for JPG and GIF images, so if it's\n// important to you, you can set it here. It defaults to 72 dpi.\nfunc (info *ImageInfoType) SetDpi(dpi float64) {\n\tinfo.dpi = dpi\n}\n\ntype fontFileType struct {\n\tlength1, length2 int64\n\tn                int\n\tembedded         bool\n\tcontent          []byte\n\tfontType         string\n}\n\ntype linkType struct {\n\tx, y, wd, ht float64\n\tlink         int    // Auto-generated internal link ID or...\n\tlinkStr      string // ...application-provided external link string\n}\n\ntype intLinkType struct {\n\tpage int\n\ty    float64\n}\n\n// outlineType is used for a sidebar outline of bookmarks\ntype outlineType struct {\n\ttext                                   string\n\tlevel, parent, first, last, next, prev int\n\ty                                      float64\n\tp                                      int\n}\n\n// InitType is used with NewCustom() to customize an Fpdf instance.\n// OrientationStr, UnitStr, SizeStr and FontDirStr correspond to the arguments\n// accepted by New(). If the Wd and Ht fields of Size are each greater than\n// zero, Size will be used to set the default page size rather than SizeStr. Wd\n// and Ht are specified in the units of measure indicated by UnitStr.\ntype InitType struct {\n\tOrientationStr string\n\tUnitStr        string\n\tSizeStr        string\n\tSize           SizeType\n\tFontDirStr     string\n}\n\n// FontLoader is used to read fonts (JSON font specification and zlib compressed font binaries)\n// from arbitrary locations (e.g. files, zip files, embedded font resources).\n//\n// Open provides an io.Reader for the specified font file (.json or .z). The file name\n// never includes a path. Open returns an error if the specified file cannot be opened.\ntype FontLoader interface {\n\tOpen(name string) (io.Reader, error)\n}\n\n// Pdf defines the interface used for various methods. It is implemented by the\n// main FPDF instance as well as templates.\ntype Pdf interface {\n\tAddFont(familyStr, styleStr, fileStr string)\n\tAddFontFromBytes(familyStr, styleStr string, jsonFileBytes, zFileBytes []byte)\n\tAddFontFromReader(familyStr, styleStr string, r io.Reader)\n\tAddLayer(name string, visible bool) (layerID int)\n\tAddLink() int\n\tAddPage()\n\tAddPageFormat(orientationStr string, size SizeType)\n\tAddSpotColor(nameStr string, c, m, y, k byte)\n\tAliasNbPages(aliasStr string)\n\tArcTo(x, y, rx, ry, degRotate, degStart, degEnd float64)\n\tArc(x, y, rx, ry, degRotate, degStart, degEnd float64, styleStr string)\n\tBeginLayer(id int)\n\tBeziergon(points []PointType, styleStr string)\n\tBookmark(txtStr string, level int, y float64)\n\tCellFormat(w, h float64, txtStr, borderStr string, ln int, alignStr string, fill bool, link int, linkStr string)\n\tCellf(w, h float64, fmtStr string, args ...interface{})\n\tCell(w, h float64, txtStr string)\n\tCircle(x, y, r float64, styleStr string)\n\tClearError()\n\tClipCircle(x, y, r float64, outline bool)\n\tClipEllipse(x, y, rx, ry float64, outline bool)\n\tClipEnd()\n\tClipPolygon(points []PointType, outline bool)\n\tClipRect(x, y, w, h float64, outline bool)\n\tClipRoundedRect(x, y, w, h, r float64, outline bool)\n\tClipText(x, y float64, txtStr string, outline bool)\n\tClose()\n\tClosePath()\n\tCreateTemplateCustom(corner PointType, size SizeType, fn func(*Tpl)) Template\n\tCreateTemplate(fn func(*Tpl)) Template\n\tCurveBezierCubicTo(cx0, cy0, cx1, cy1, x, y float64)\n\tCurveBezierCubic(x0, y0, cx0, cy0, cx1, cy1, x1, y1 float64, styleStr string)\n\tCurveCubic(x0, y0, cx0, cy0, x1, y1, cx1, cy1 float64, styleStr string)\n\tCurveTo(cx, cy, x, y float64)\n\tCurve(x0, y0, cx, cy, x1, y1 float64, styleStr string)\n\tDrawPath(styleStr string)\n\tEllipse(x, y, rx, ry, degRotate float64, styleStr string)\n\tEndLayer()\n\tErr() bool\n\tError() error\n\tGetAlpha() (alpha float64, blendModeStr string)\n\tGetAutoPageBreak() (auto bool, margin float64)\n\tGetCellMargin() float64\n\tGetConversionRatio() float64\n\tGetDrawColor() (int, int, int)\n\tGetDrawSpotColor() (name string, c, m, y, k byte)\n\tGetFillColor() (int, int, int)\n\tGetFillSpotColor() (name string, c, m, y, k byte)\n\tGetFontDesc(familyStr, styleStr string) FontDescType\n\tGetFontSize() (ptSize, unitSize float64)\n\tGetImageInfo(imageStr string) (info *ImageInfoType)\n\tGetLineWidth() float64\n\tGetMargins() (left, top, right, bottom float64)\n\tGetPageSizeStr(sizeStr string) (size SizeType)\n\tGetPageSize() (width, height float64)\n\tGetStringWidth(s string) float64\n\tGetTextColor() (int, int, int)\n\tGetTextSpotColor() (name string, c, m, y, k byte)\n\tGetX() float64\n\tGetXY() (float64, float64)\n\tGetY() float64\n\tHTMLBasicNew() (html HTMLBasicType)\n\tImage(imageNameStr string, x, y, w, h float64, flow bool, tp string, link int, linkStr string)\n\tImageOptions(imageNameStr string, x, y, w, h float64, flow bool, options ImageOptions, link int, linkStr string)\n\tImageTypeFromMime(mimeStr string) (tp string)\n\tLinearGradient(x, y, w, h float64, r1, g1, b1, r2, g2, b2 int, x1, y1, x2, y2 float64)\n\tLineTo(x, y float64)\n\tLine(x1, y1, x2, y2 float64)\n\tLinkString(x, y, w, h float64, linkStr string)\n\tLink(x, y, w, h float64, link int)\n\tLn(h float64)\n\tMoveTo(x, y float64)\n\tMultiCell(w, h float64, txtStr, borderStr, alignStr string, fill bool)\n\tOk() bool\n\tOpenLayerPane()\n\tOutputAndClose(w io.WriteCloser) error\n\tOutputFileAndClose(fileStr string) error\n\tOutput(w io.Writer) error\n\tPageCount() int\n\tPageNo() int\n\tPageSize(pageNum int) (wd, ht float64, unitStr string)\n\tPointConvert(pt float64) (u float64)\n\tPointToUnitConvert(pt float64) (u float64)\n\tPolygon(points []PointType, styleStr string)\n\tRadialGradient(x, y, w, h float64, r1, g1, b1, r2, g2, b2 int, x1, y1, x2, y2, r float64)\n\tRawWriteBuf(r io.Reader)\n\tRawWriteStr(str string)\n\tRect(x, y, w, h float64, styleStr string)\n\tRegisterAlias(alias, replacement string)\n\tRegisterImage(fileStr, tp string) (info *ImageInfoType)\n\tRegisterImageOptions(fileStr string, options ImageOptions) (info *ImageInfoType)\n\tRegisterImageOptionsReader(imgName string, options ImageOptions, r io.Reader) (info *ImageInfoType)\n\tRegisterImageReader(imgName, tp string, r io.Reader) (info *ImageInfoType)\n\tSetAcceptPageBreakFunc(fnc func() bool)\n\tSetAlpha(alpha float64, blendModeStr string)\n\tSetAuthor(authorStr string, isUTF8 bool)\n\tSetAutoPageBreak(auto bool, margin float64)\n\tSetCatalogSort(flag bool)\n\tSetCellMargin(margin float64)\n\tSetCompression(compress bool)\n\tSetCreationDate(tm time.Time)\n\tSetCreator(creatorStr string, isUTF8 bool)\n\tSetDashPattern(dashArray []float64, dashPhase float64)\n\tSetDisplayMode(zoomStr, layoutStr string)\n\tSetDrawColor(r, g, b int)\n\tSetDrawSpotColor(nameStr string, tint byte)\n\tSetError(err error)\n\tSetErrorf(fmtStr string, args ...interface{})\n\tSetFillColor(r, g, b int)\n\tSetFillSpotColor(nameStr string, tint byte)\n\tSetFont(familyStr, styleStr string, size float64)\n\tSetFontLoader(loader FontLoader)\n\tSetFontLocation(fontDirStr string)\n\tSetFontSize(size float64)\n\tSetFontStyle(styleStr string)\n\tSetFontUnitSize(size float64)\n\tSetFooterFunc(fnc func())\n\tSetFooterFuncLpi(fnc func(lastPage bool))\n\tSetHeaderFunc(fnc func())\n\tSetHeaderFuncMode(fnc func(), homeMode bool)\n\tSetHomeXY()\n\tSetJavascript(script string)\n\tSetKeywords(keywordsStr string, isUTF8 bool)\n\tSetLeftMargin(margin float64)\n\tSetLineCapStyle(styleStr string)\n\tSetLineJoinStyle(styleStr string)\n\tSetLineWidth(width float64)\n\tSetLink(link int, y float64, page int)\n\tSetMargins(left, top, right float64)\n\tSetPageBoxRec(t string, pb PageBox)\n\tSetPageBox(t string, x, y, wd, ht float64)\n\tSetPage(pageNum int)\n\tSetProtection(actionFlag byte, userPassStr, ownerPassStr string)\n\tSetRightMargin(margin float64)\n\tSetSubject(subjectStr string, isUTF8 bool)\n\tSetTextColor(r, g, b int)\n\tSetTextSpotColor(nameStr string, tint byte)\n\tSetTitle(titleStr string, isUTF8 bool)\n\tSetTopMargin(margin float64)\n\tSetUnderlineThickness(thickness float64)\n\tSetXmpMetadata(xmpStream []byte)\n\tSetX(x float64)\n\tSetXY(x, y float64)\n\tSetY(y float64)\n\tSplitLines(txt []byte, w float64) [][]byte\n\tString() string\n\tSVGBasicWrite(sb *SVGBasicType, scale float64)\n\tText(x, y float64, txtStr string)\n\tTransformBegin()\n\tTransformEnd()\n\tTransformMirrorHorizontal(x float64)\n\tTransformMirrorLine(angle, x, y float64)\n\tTransformMirrorPoint(x, y float64)\n\tTransformMirrorVertical(y float64)\n\tTransformRotate(angle, x, y float64)\n\tTransformScale(scaleWd, scaleHt, x, y float64)\n\tTransformScaleX(scaleWd, x, y float64)\n\tTransformScaleXY(s, x, y float64)\n\tTransformScaleY(scaleHt, x, y float64)\n\tTransformSkew(angleX, angleY, x, y float64)\n\tTransformSkewX(angleX, x, y float64)\n\tTransformSkewY(angleY, x, y float64)\n\tTransform(tm TransformMatrix)\n\tTransformTranslate(tx, ty float64)\n\tTransformTranslateX(tx float64)\n\tTransformTranslateY(ty float64)\n\tUnicodeTranslatorFromDescriptor(cpStr string) (rep func(string) string)\n\tUnitToPointConvert(u float64) (pt float64)\n\tUseTemplateScaled(t Template, corner PointType, size SizeType)\n\tUseTemplate(t Template)\n\tWriteAligned(width, lineHeight float64, textStr, alignStr string)\n\tWritef(h float64, fmtStr string, args ...interface{})\n\tWrite(h float64, txtStr string)\n\tWriteLinkID(h float64, displayStr string, linkID int)\n\tWriteLinkString(h float64, displayStr, targetStr string)\n}\n\n// PageBox defines the coordinates and extent of the various page box types\ntype PageBox struct {\n\tSizeType\n\tPointType\n}\n\n// Fpdf is the principal structure for creating a single PDF document\ntype Fpdf struct {\n\tisCurrentUTF8    bool                       // is current font used in utf-8 mode\n\tisRTL            bool                       // is is right to left mode enabled\n\tpage             int                        // current page number\n\tn                int                        // current object number\n\toffsets          []int                      // array of object offsets\n\ttemplates        map[string]Template        // templates used in this document\n\ttemplateObjects  map[string]int             // template object IDs within this document\n\timportedObjs     map[string][]byte          // imported template objects (gofpdi)\n\timportedObjPos   map[string]map[int]string  // imported template objects hashes and their positions (gofpdi)\n\timportedTplObjs  map[string]string          // imported template names and IDs (hashed) (gofpdi)\n\timportedTplIDs   map[string]int             // imported template ids hash to object id int (gofpdi)\n\tbuffer           fmtBuffer                  // buffer holding in-memory PDF\n\tpages            []*bytes.Buffer            // slice[page] of page content; 1-based\n\tstate            int                        // current document state\n\tcompress         bool                       // compression flag\n\tk                float64                    // scale factor (number of points in user unit)\n\tdefOrientation   string                     // default orientation\n\tcurOrientation   string                     // current orientation\n\tstdPageSizes     map[string]SizeType        // standard page sizes\n\tdefPageSize      SizeType                   // default page size\n\tdefPageBoxes     map[string]PageBox         // default page size\n\tcurPageSize      SizeType                   // current page size\n\tpageSizes        map[int]SizeType           // used for pages with non default sizes or orientations\n\tpageBoxes        map[int]map[string]PageBox // used to define the crop, trim, bleed and art boxes\n\tunitStr          string                     // unit of measure for all rendered objects except fonts\n\twPt, hPt         float64                    // dimensions of current page in points\n\tw, h             float64                    // dimensions of current page in user unit\n\tlMargin          float64                    // left margin\n\ttMargin          float64                    // top margin\n\trMargin          float64                    // right margin\n\tbMargin          float64                    // page break margin\n\tcMargin          float64                    // cell margin\n\tx, y             float64                    // current position in user unit\n\tlasth            float64                    // height of last printed cell\n\tlineWidth        float64                    // line width in user unit\n\tfontpath         string                     // path containing fonts\n\tfontLoader       FontLoader                 // used to load font files from arbitrary locations\n\tcoreFonts        map[string]bool            // array of core font names\n\tfonts            map[string]fontDefType     // array of used fonts\n\tfontFiles        map[string]fontFileType    // array of font files\n\tdiffs            []string                   // array of encoding differences\n\tfontFamily       string                     // current font family\n\tfontStyle        string                     // current font style\n\tunderline        bool                       // underlining flag\n\tstrikeout        bool                       // strike out flag\n\tcurrentFont      fontDefType                // current font info\n\tfontSizePt       float64                    // current font size in points\n\tfontSize         float64                    // current font size in user unit\n\tws               float64                    // word spacing\n\timages           map[string]*ImageInfoType  // array of used images\n\taliasMap         map[string]string          // map of alias->replacement\n\tpageLinks        [][]linkType               // pageLinks[page][link], both 1-based\n\tlinks            []intLinkType              // array of internal links\n\tattachments      []Attachment               // slice of content to embed globally\n\tpageAttachments  [][]annotationAttach       // 1-based array of annotation for file attachments (per page)\n\toutlines         []outlineType              // array of outlines\n\toutlineRoot      int                        // root of outlines\n\tautoPageBreak    bool                       // automatic page breaking\n\tacceptPageBreak  func() bool                // returns true to accept page break\n\tpageBreakTrigger float64                    // threshold used to trigger page breaks\n\tinHeader         bool                       // flag set when processing header\n\theaderFnc        func()                     // function provided by app and called to write header\n\theaderHomeMode   bool                       // set position to home after headerFnc is called\n\tinFooter         bool                       // flag set when processing footer\n\tfooterFnc        func()                     // function provided by app and called to write footer\n\tfooterFncLpi     func(bool)                 // function provided by app and called to write footer with last page flag\n\tzoomMode         string                     // zoom display mode\n\tlayoutMode       string                     // layout display mode\n\txmp              []byte                     // XMP metadata\n\tproducer         string                     // producer\n\ttitle            string                     // title\n\tsubject          string                     // subject\n\tauthor           string                     // author\n\tkeywords         string                     // keywords\n\tcreator          string                     // creator\n\tcreationDate     time.Time                  // override for document CreationDate value\n\tmodDate          time.Time                  // override for document ModDate value\n\taliasNbPagesStr  string                     // alias for total number of pages\n\tpdfVersion       string                     // PDF version number\n\tfontDirStr       string                     // location of font definition files\n\tcapStyle         int                        // line cap style: butt 0, round 1, square 2\n\tjoinStyle        int                        // line segment join style: miter 0, round 1, bevel 2\n\tdashArray        []float64                  // dash array\n\tdashPhase        float64                    // dash phase\n\tblendList        []blendModeType            // slice[idx] of alpha transparency modes, 1-based\n\tblendMap         map[string]int             // map into blendList\n\tblendMode        string                     // current blend mode\n\talpha            float64                    // current transpacency\n\tgradientList     []gradientType             // slice[idx] of gradient records\n\tclipNest         int                        // Number of active clipping contexts\n\ttransformNest    int                        // Number of active transformation contexts\n\terr              error                      // Set if error occurs during life cycle of instance\n\tprotect          protectType                // document protection structure\n\tlayer            layerRecType               // manages optional layers in document\n\tcatalogSort      bool                       // sort resource catalogs in document\n\tnJs              int                        // JavaScript object number\n\tjavascript       *string                    // JavaScript code to include in the PDF\n\tcolorFlag        bool                       // indicates whether fill and text colors are different\n\tcolor            struct {\n\t\t// Composite values of colors\n\t\tdraw, fill, text colorType\n\t}\n\tspotColorMap           map[string]spotColorType // Map of named ink-based colors\n\tuserUnderlineThickness float64                  // A custom user underline thickness multiplier.\n}\n\ntype encType struct {\n\tuv   int\n\tname string\n}\n\ntype encListType [256]encType\n\ntype fontBoxType struct {\n\tXmin, Ymin, Xmax, Ymax int\n}\n\n// Font flags for FontDescType.Flags as defined in the pdf specification.\nconst (\n\t// FontFlagFixedPitch is set if all glyphs have the same width (as\n\t// opposed to proportional or variable-pitch fonts, which have\n\t// different widths).\n\tFontFlagFixedPitch = 1 << 0\n\t// FontFlagSerif is set if glyphs have serifs, which are short\n\t// strokes drawn at an angle on the top and bottom of glyph stems.\n\t// (Sans serif fonts do not have serifs.)\n\tFontFlagSerif = 1 << 1\n\t// FontFlagSymbolic is set if font contains glyphs outside the\n\t// Adobe standard Latin character set. This flag and the\n\t// Nonsymbolic flag shall not both be set or both be clear.\n\tFontFlagSymbolic = 1 << 2\n\t// FontFlagScript is set if glyphs resemble cursive handwriting.\n\tFontFlagScript = 1 << 3\n\t// FontFlagNonsymbolic is set if font uses the Adobe standard\n\t// Latin character set or a subset of it.\n\tFontFlagNonsymbolic = 1 << 5\n\t// FontFlagItalic is set if glyphs have dominant vertical strokes\n\t// that are slanted.\n\tFontFlagItalic = 1 << 6\n\t// FontFlagAllCap is set if font contains no lowercase letters;\n\t// typically used for display purposes, such as for titles or\n\t// headlines.\n\tFontFlagAllCap = 1 << 16\n\t// SmallCap is set if font contains both uppercase and lowercase\n\t// letters. The uppercase letters are similar to those in the\n\t// regular version of the same typeface family. The glyphs for the\n\t// lowercase letters have the same shapes as the corresponding\n\t// uppercase letters, but they are sized and their proportions\n\t// adjusted so that they have the same size and stroke weight as\n\t// lowercase glyphs in the same typeface family.\n\tSmallCap = 1 << 18\n\t// ForceBold determines whether bold glyphs shall be painted with\n\t// extra pixels even at very small text sizes by a conforming\n\t// reader. If the ForceBold flag is set, features of bold glyphs\n\t// may be thickened at small text sizes.\n\tForceBold = 1 << 18\n)\n\n// FontDescType (font descriptor) specifies metrics and other\n// attributes of a font, as distinct from the metrics of individual\n// glyphs (as defined in the pdf specification).\ntype FontDescType struct {\n\t// The maximum height above the baseline reached by glyphs in this\n\t// font (for example for \"S\"). The height of glyphs for accented\n\t// characters shall be excluded.\n\tAscent int\n\t// The maximum depth below the baseline reached by glyphs in this\n\t// font. The value shall be a negative number.\n\tDescent int\n\t// The vertical coordinate of the top of flat capital letters,\n\t// measured from the baseline (for example \"H\").\n\tCapHeight int\n\t// A collection of flags defining various characteristics of the\n\t// font. (See the FontFlag* constants.)\n\tFlags int\n\t// A rectangle, expressed in the glyph coordinate system, that\n\t// shall specify the font bounding box. This should be the smallest\n\t// rectangle enclosing the shape that would result if all of the\n\t// glyphs of the font were placed with their origins coincident\n\t// and then filled.\n\tFontBBox fontBoxType\n\t// The angle, expressed in degrees counterclockwise from the\n\t// vertical, of the dominant vertical strokes of the font. (The\n\t// 9-o’clock position is 90 degrees, and the 3-o’clock position\n\t// is –90 degrees.) The value shall be negative for fonts that\n\t// slope to the right, as almost all italic fonts do.\n\tItalicAngle int\n\t// The thickness, measured horizontally, of the dominant vertical\n\t// stems of glyphs in the font.\n\tStemV int\n\t// The width to use for character codes whose widths are not\n\t// specified in a font dictionary’s Widths array. This shall have\n\t// a predictable effect only if all such codes map to glyphs whose\n\t// actual widths are the same as the value of the MissingWidth\n\t// entry. (Default value: 0.)\n\tMissingWidth int\n}\n\ntype fontDefType struct {\n\tTp           string        // \"Core\", \"TrueType\", ...\n\tName         string        // \"Courier-Bold\", ...\n\tDesc         FontDescType  // Font descriptor\n\tUp           int           // Underline position\n\tUt           int           // Underline thickness\n\tCw           []int         // Character width by ordinal\n\tEnc          string        // \"cp1252\", ...\n\tDiff         string        // Differences from reference encoding\n\tFile         string        // \"Redressed.z\"\n\tSize1, Size2 int           // Type1 values\n\tOriginalSize int           // Size of uncompressed font file\n\tN            int           // Set by font loader\n\tDiffN        int           // Position of diff in app array, set by font loader\n\ti            string        // 1-based position in font list, set by font loader, not this program\n\tutf8File     *utf8FontFile // UTF-8 font\n\tusedRunes    map[int]int   // Array of used runes\n}\n\n// generateFontID generates a font Id from the font definition\nfunc generateFontID(fdt fontDefType) (string, error) {\n\t// file can be different if generated in different instance\n\tfdt.File = \"\"\n\tb, err := json.Marshal(&fdt)\n\treturn fmt.Sprintf(\"%x\", sha1.Sum(b)), err\n}\n\ntype fontInfoType struct {\n\tData               []byte\n\tFile               string\n\tOriginalSize       int\n\tFontName           string\n\tBold               bool\n\tIsFixedPitch       bool\n\tUnderlineThickness int\n\tUnderlinePosition  int\n\tWidths             []int\n\tSize1, Size2       uint32\n\tDesc               FontDescType\n}\n"
        },
        {
          "name": "doc.go",
          "type": "blob",
          "size": 11.16796875,
          "content": "/*\nPackage gofpdf implements a PDF document generator with high level\nsupport for text, drawing and images.\n\nFeatures\n\n\n-   UTF-8 support\n\n-   Choice of measurement unit, page format and margins\n\n-   Page header and footer management\n\n-   Automatic page breaks, line breaks, and text justification\n\n-   Inclusion of JPEG, PNG, GIF, TIFF and basic path-only SVG images\n\n-   Colors, gradients and alpha channel transparency\n\n-   Outline bookmarks\n\n-   Internal and external links\n\n-   TrueType, Type1 and encoding support\n\n-   Page compression\n\n-   Lines, Bézier curves, arcs, and ellipses\n\n-   Rotation, scaling, skewing, translation, and mirroring\n\n-   Clipping\n\n-   Document protection\n\n-   Layers\n\n-   Templates\n\n-   Barcodes\n\n-   Charting facility\n\n-   Import PDFs as templates\n\ngofpdf has no dependencies other than the Go standard library. All tests\npass on Linux, Mac and Windows platforms.\n\ngofpdf supports UTF-8 TrueType fonts and “right-to-left” languages. Note\nthat Chinese, Japanese, and Korean characters may not be included in\nmany general purpose fonts. For these languages, a specialized font (for\nexample, NotoSansSC for simplified Chinese) can be used.\n\nAlso, support is provided to automatically translate UTF-8 runes to code\npage encodings for languages that have fewer than 256 glyphs.\n\nWe Are Closed\n\nThis repository will not be maintained, at least for some unknown\nduration. But it is hoped that gofpdf has a bright future in the open\nsource world. Due to Go’s promise of compatibility, gofpdf should\ncontinue to function without modification for a longer time than would\nbe the case with many other languages.\n\nForks should be based on the last viable commit. Tools such as\nactive-forks can be used to select a fork that looks promising for your\nneeds. If a particular fork looks like it has taken the lead in\nattracting followers, this README will be updated to point people in\nthat direction.\n\nThe efforts of all contributors to this project have been deeply\nappreciated. Best wishes to all of you.\n\nInstallation\n\nTo install the package on your system, run\n\n    go get github.com/jung-kurt/gofpdf\n\nLater, to receive updates, run\n\n    go get -u -v github.com/jung-kurt/gofpdf/...\n\nQuick Start\n\nThe following Go code generates a simple PDF file.\n\n    pdf := gofpdf.New(\"P\", \"mm\", \"A4\", \"\")\n    pdf.AddPage()\n    pdf.SetFont(\"Arial\", \"B\", 16)\n    pdf.Cell(40, 10, \"Hello, world\")\n    err := pdf.OutputFileAndClose(\"hello.pdf\")\n\nSee the functions in the fpdf_test.go file (shown as examples in this\ndocumentation) for more advanced PDF examples.\n\nErrors\n\nIf an error occurs in an Fpdf method, an internal error field is set.\nAfter this occurs, Fpdf method calls typically return without performing\nany operations and the error state is retained. This error management\nscheme facilitates PDF generation since individual method calls do not\nneed to be examined for failure; it is generally sufficient to wait\nuntil after Output() is called. For the same reason, if an error occurs\nin the calling application during PDF generation, it may be desirable\nfor the application to transfer the error to the Fpdf instance by\ncalling the SetError() method or the SetErrorf() method. At any time\nduring the life cycle of the Fpdf instance, the error state can be\ndetermined with a call to Ok() or Err(). The error itself can be\nretrieved with a call to Error().\n\nConversion Notes\n\nThis package is a relatively straightforward translation from the\noriginal FPDF library written in PHP (despite the caveat in the\nintroduction to Effective Go). The API names have been retained even\nthough the Go idiom would suggest otherwise (for example, pdf.GetX() is\nused rather than simply pdf.X()). The similarity of the two libraries\nmakes the original FPDF website a good source of information. It\nincludes a forum and FAQ.\n\nHowever, some internal changes have been made. Page content is built up\nusing buffers (of type bytes.Buffer) rather than repeated string\nconcatenation. Errors are handled as explained above rather than\npanicking. Output is generated through an interface of type io.Writer or\nio.WriteCloser. A number of the original PHP methods behave differently\nbased on the type of the arguments that are passed to them; in these\ncases additional methods have been exported to provide similar\nfunctionality. Font definition files are produced in JSON rather than\nPHP.\n\nExample PDFs\n\nA side effect of running go test ./... is the production of a number of\nexample PDFs. These can be found in the gofpdf/pdf directory after the\ntests complete.\n\nPlease note that these examples run in the context of a test. In order\nrun an example as a standalone application, you’ll need to examine\nfpdf_test.go for some helper routines, for example exampleFilename() and\nsummary().\n\nExample PDFs can be compared with reference copies in order to verify\nthat they have been generated as expected. This comparison will be\nperformed if a PDF with the same name as the example PDF is placed in\nthe gofpdf/pdf/reference directory and if the third argument to\nComparePDFFiles() in internal/example/example.go is true. (By default it\nis false.) The routine that summarizes an example will look for this\nfile and, if found, will call ComparePDFFiles() to check the example PDF\nfor equality with its reference PDF. If differences exist between the\ntwo files they will be printed to standard output and the test will\nfail. If the reference file is missing, the comparison is considered to\nsucceed. In order to successfully compare two PDFs, the placement of\ninternal resources must be consistent and the internal creation\ntimestamps must be the same. To do this, the methods SetCatalogSort()\nand SetCreationDate() need to be called for both files. This is done\nautomatically for all examples.\n\nNonstandard Fonts\n\nNothing special is required to use the standard PDF fonts (courier,\nhelvetica, times, zapfdingbats) in your documents other than calling\nSetFont().\n\nYou should use AddUTF8Font() or AddUTF8FontFromBytes() to add a TrueType\nUTF-8 encoded font. Use RTL() and LTR() methods switch between\n“right-to-left” and “left-to-right” mode.\n\nIn order to use a different non-UTF-8 TrueType or Type1 font, you will\nneed to generate a font definition file and, if the font will be\nembedded into PDFs, a compressed version of the font file. This is done\nby calling the MakeFont function or using the included makefont command\nline utility. To create the utility, cd into the makefont subdirectory\nand run “go build”. This will produce a standalone executable named\nmakefont. Select the appropriate encoding file from the font\nsubdirectory and run the command as in the following example.\n\n    ./makefont --embed --enc=../font/cp1252.map --dst=../font ../font/calligra.ttf\n\nIn your PDF generation code, call AddFont() to load the font and, as\nwith the standard fonts, SetFont() to begin using it. Most examples,\nincluding the package example, demonstrate this method. Good sources of\nfree, open-source fonts include Google Fonts and DejaVu Fonts.\n\nRelated Packages\n\nThe draw2d package is a two dimensional vector graphics library that can\ngenerate output in different forms. It uses gofpdf for its document\nproduction mode.\n\nContributing Changes\n\ngofpdf is a global community effort and you are invited to make it even\nbetter. If you have implemented a new feature or corrected a problem,\nplease consider contributing your change to the project. A contribution\nthat does not directly pertain to the core functionality of gofpdf\nshould be placed in its own directory directly beneath the contrib\ndirectory.\n\nHere are guidelines for making submissions. Your change should\n\n\n-   be compatible with the MIT License\n\n-   be properly documented\n\n-   be formatted with go fmt\n\n-   include an example in fpdf_test.go if appropriate\n\n-   conform to the standards of golint and go vet, that is, golint . and\ngo vet . should not generate any warnings\n\n-   not diminish test coverage\n\nPull requests are the preferred means of accepting your changes.\n\nLicense\n\ngofpdf is released under the MIT License. It is copyrighted by Kurt Jung\nand the contributors acknowledged below.\n\nAcknowledgments\n\nThis package’s code and documentation are closely derived from the FPDF\nlibrary created by Olivier Plathey, and a number of font and image\nresources are copied directly from it. Bruno Michel has provided\nvaluable assistance with the code. Drawing support is adapted from the\nFPDF geometric figures script by David Hernández Sanz. Transparency\nsupport is adapted from the FPDF transparency script by Martin Hall-May.\nSupport for gradients and clipping is adapted from FPDF scripts by\nAndreas Würmser. Support for outline bookmarks is adapted from Olivier\nPlathey by Manuel Cornes. Layer support is adapted from Olivier Plathey.\nSupport for transformations is adapted from the FPDF transformation\nscript by Moritz Wagner and Andreas Würmser. PDF protection is adapted\nfrom the work of Klemen Vodopivec for the FPDF product. Lawrence\nKesteloot provided code to allow an image’s extent to be determined\nprior to placement. Support for vertical alignment within a cell was\nprovided by Stefan Schroeder. Ivan Daniluk generalized the font and\nimage loading code to use the Reader interface while maintaining\nbackward compatibility. Anthony Starks provided code for the Polygon\nfunction. Robert Lillack provided the Beziergon function and corrected\nsome naming issues with the internal curve function. Claudio Felber\nprovided implementations for dashed line drawing and generalized font\nloading. Stani Michiels provided support for multi-segment path drawing\nwith smooth line joins, line join styles, enhanced fill modes, and has\nhelped greatly with package presentation and tests. Templating is\nadapted by Marcus Downing from the FPDF_Tpl library created by Jan\nSlabon and Setasign. Jelmer Snoeck contributed packages that generate a\nvariety of barcodes and help with registering images on the web. Jelmer\nSnoek and Guillermo Pascual augmented the basic HTML functionality with\naligned text. Kent Quirk implemented backwards-compatible support for\nreading DPI from images that support it, and for setting DPI manually\nand then having it properly taken into account when calculating image\nsize. Paulo Coutinho provided support for static embedded fonts. Dan\nMeyers added support for embedded JavaScript. David Fish added a generic\nalias-replacement function to enable, among other things, table of\ncontents functionality. Andy Bakun identified and corrected a problem in\nwhich the internal catalogs were not sorted stably. Paul Montag added\nencoding and decoding functionality for templates, including images that\nare embedded in templates; this allows templates to be stored\nindependently of gofpdf. Paul also added support for page boxes used in\nprinting PDF documents. Wojciech Matusiak added supported for word\nspacing. Artem Korotkiy added support of UTF-8 fonts. Dave Barnes added\nsupport for imported objects and templates. Brigham Thompson added\nsupport for rounded rectangles. Joe Westcott added underline\nfunctionality and optimized image storage. Benoit KUGLER contributed\nsupport for rectangles with corners of unequal radius, modification\ntimes, and for file attachments and annotations.\n\nRoadmap\n\n\n-   Remove all legacy code page font support; use UTF-8 exclusively\n\n-   Improve test coverage as reported by the coverage tool.\n*/\npackage gofpdf\n"
        },
        {
          "name": "doc",
          "type": "tree",
          "content": null
        },
        {
          "name": "embedded.go",
          "type": "blob",
          "size": 24.130859375,
          "content": "/*\n * Copyright (c) 2014 Kurt Jung (Gmail: kurt.w.jung)\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\n * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\n * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\npackage gofpdf\n\n// Embedded standard fonts\n\nimport (\n\t\"strings\"\n)\n\nvar embeddedFontList = map[string]string{\n\t\"courierBI\":    `{\"Tp\":\"Core\",\"Name\":\"Courier-BoldOblique\",\"Up\":-100,\"Ut\":50,\"I\":256,\"Cw\":[600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600]}`,\n\t\"courierB\":     `{\"Tp\":\"Core\",\"Name\":\"Courier-Bold\",\"Up\":-100,\"Ut\":50,\"I\":256,\"Cw\":[600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600]}`,\n\t\"courierI\":     `{\"Tp\":\"Core\",\"Name\":\"Courier-Oblique\",\"Up\":-100,\"Ut\":50,\"I\":256,\"Cw\":[600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600]}`,\n\t\"courier\":      `{\"Tp\":\"Core\",\"Name\":\"Courier\",\"Up\":-100,\"Ut\":50,\"I\":256,\"Cw\":[600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600,600]}`,\n\t\"helveticaBI\":  `{\"Tp\":\"Core\",\"Name\":\"Helvetica-BoldOblique\",\"Up\":-100,\"Ut\":50,\"Cw\":[278,278,278,278,278,278,278,278,278,278,278,278,278,278,278,278,278,278,278,278,278,278,278,278,278,278,278,278,278,278,278,278,278,333,474,556,556,889,722,238,333,333,389,584,278,333,278,278,556,556,556,556,556,556,556,556,556,556,333,333,584,584,584,611,975,722,722,722,722,667,611,778,722,278,556,722,611,833,722,778,667,778,722,667,611,722,667,944,667,667,611,333,278,333,584,556,333,556,611,556,611,556,333,611,611,278,278,556,278,889,611,611,611,611,389,556,333,611,556,778,556,556,500,389,280,389,584,350,556,350,278,556,500,1000,556,556,333,1000,667,333,1000,350,611,350,350,278,278,500,500,350,556,1000,333,1000,556,333,944,350,500,667,278,333,556,556,556,556,280,556,333,737,370,556,584,333,737,333,400,584,333,333,333,611,556,278,333,333,365,556,834,834,834,611,722,722,722,722,722,722,1000,722,667,667,667,667,278,278,278,278,722,722,778,778,778,778,778,584,778,722,722,722,722,667,667,611,556,556,556,556,556,556,889,556,556,556,556,556,278,278,278,278,611,611,611,611,611,611,611,584,611,611,611,611,611,556,611,556]}`,\n\t\"helveticaB\":   `{\"Tp\":\"Core\",\"Name\":\"Helvetica-Bold\",\"Up\":-100,\"Ut\":50,\"Cw\":[278,278,278,278,278,278,278,278,278,278,278,278,278,278,278,278,278,278,278,278,278,278,278,278,278,278,278,278,278,278,278,278,278,333,474,556,556,889,722,238,333,333,389,584,278,333,278,278,556,556,556,556,556,556,556,556,556,556,333,333,584,584,584,611,975,722,722,722,722,667,611,778,722,278,556,722,611,833,722,778,667,778,722,667,611,722,667,944,667,667,611,333,278,333,584,556,333,556,611,556,611,556,333,611,611,278,278,556,278,889,611,611,611,611,389,556,333,611,556,778,556,556,500,389,280,389,584,350,556,350,278,556,500,1000,556,556,333,1000,667,333,1000,350,611,350,350,278,278,500,500,350,556,1000,333,1000,556,333,944,350,500,667,278,333,556,556,556,556,280,556,333,737,370,556,584,333,737,333,400,584,333,333,333,611,556,278,333,333,365,556,834,834,834,611,722,722,722,722,722,722,1000,722,667,667,667,667,278,278,278,278,722,722,778,778,778,778,778,584,778,722,722,722,722,667,667,611,556,556,556,556,556,556,889,556,556,556,556,556,278,278,278,278,611,611,611,611,611,611,611,584,611,611,611,611,611,556,611,556]}`,\n\t\"helveticaI\":   `{\"Tp\":\"Core\",\"Name\":\"Helvetica-Oblique\",\"Up\":-100,\"Ut\":50,\"Cw\":[278,278,278,278,278,278,278,278,278,278,278,278,278,278,278,278,278,278,278,278,278,278,278,278,278,278,278,278,278,278,278,278,278,278,355,556,556,889,667,191,333,333,389,584,278,333,278,278,556,556,556,556,556,556,556,556,556,556,278,278,584,584,584,556,1015,667,667,722,722,667,611,778,722,278,500,667,556,833,722,778,667,778,722,667,611,722,667,944,667,667,611,278,278,278,469,556,333,556,556,500,556,556,278,556,556,222,222,500,222,833,556,556,556,556,333,500,278,556,500,722,500,500,500,334,260,334,584,350,556,350,222,556,333,1000,556,556,333,1000,667,333,1000,350,611,350,350,222,222,333,333,350,556,1000,333,1000,500,333,944,350,500,667,278,333,556,556,556,556,260,556,333,737,370,556,584,333,737,333,400,584,333,333,333,556,537,278,333,333,365,556,834,834,834,611,667,667,667,667,667,667,1000,722,667,667,667,667,278,278,278,278,722,722,778,778,778,778,778,584,778,722,722,722,722,667,667,611,556,556,556,556,556,556,889,500,556,556,556,556,278,278,278,278,556,556,556,556,556,556,556,584,611,556,556,556,556,500,556,500]}`,\n\t\"helvetica\":    `{\"Tp\":\"Core\",\"Name\":\"Helvetica\",\"Up\":-100,\"Ut\":50,\"Cw\":[278,278,278,278,278,278,278,278,278,278,278,278,278,278,278,278,278,278,278,278,278,278,278,278,278,278,278,278,278,278,278,278,278,278,355,556,556,889,667,191,333,333,389,584,278,333,278,278,556,556,556,556,556,556,556,556,556,556,278,278,584,584,584,556,1015,667,667,722,722,667,611,778,722,278,500,667,556,833,722,778,667,778,722,667,611,722,667,944,667,667,611,278,278,278,469,556,333,556,556,500,556,556,278,556,556,222,222,500,222,833,556,556,556,556,333,500,278,556,500,722,500,500,500,334,260,334,584,350,556,350,222,556,333,1000,556,556,333,1000,667,333,1000,350,611,350,350,222,222,333,333,350,556,1000,333,1000,500,333,944,350,500,667,278,333,556,556,556,556,260,556,333,737,370,556,584,333,737,333,400,584,333,333,333,556,537,278,333,333,365,556,834,834,834,611,667,667,667,667,667,667,1000,722,667,667,667,667,278,278,278,278,722,722,778,778,778,778,778,584,778,722,722,722,722,667,667,611,556,556,556,556,556,556,889,500,556,556,556,556,278,278,278,278,556,556,556,556,556,556,556,584,611,556,556,556,556,500,556,500]}`,\n\t\"timesBI\":      `{\"Tp\":\"Core\",\"Name\":\"Times-BoldItalic\",\"Up\":-100,\"Ut\":50,\"Cw\":[250,250,250,250,250,250,250,250,250,250,250,250,250,250,250,250,250,250,250,250,250,250,250,250,250,250,250,250,250,250,250,250,250,389,555,500,500,833,778,278,333,333,500,570,250,333,250,278,500,500,500,500,500,500,500,500,500,500,333,333,570,570,570,500,832,667,667,667,722,667,667,722,778,389,500,667,611,889,722,722,611,722,667,556,611,722,667,889,667,611,611,333,278,333,570,500,333,500,500,444,500,444,333,500,556,278,278,500,278,778,556,500,500,500,389,389,278,556,444,667,500,444,389,348,220,348,570,350,500,350,333,500,500,1000,500,500,333,1000,556,333,944,350,611,350,350,333,333,500,500,350,500,1000,333,1000,389,333,722,350,389,611,250,389,500,500,500,500,220,500,333,747,266,500,606,333,747,333,400,570,300,300,333,576,500,250,333,300,300,500,750,750,750,500,667,667,667,667,667,667,944,667,667,667,667,667,389,389,389,389,722,722,722,722,722,722,722,570,722,722,722,722,722,611,611,500,500,500,500,500,500,500,722,444,444,444,444,444,278,278,278,278,500,556,500,500,500,500,500,570,500,556,556,556,556,444,500,444]}`,\n\t\"timesB\":       `{\"Tp\":\"Core\",\"Name\":\"Times-Bold\",\"Up\":-100,\"Ut\":50,\"Cw\":[250,250,250,250,250,250,250,250,250,250,250,250,250,250,250,250,250,250,250,250,250,250,250,250,250,250,250,250,250,250,250,250,250,333,555,500,500,1000,833,278,333,333,500,570,250,333,250,278,500,500,500,500,500,500,500,500,500,500,333,333,570,570,570,500,930,722,667,722,722,667,611,778,778,389,500,778,667,944,722,778,611,778,722,556,667,722,722,1000,722,722,667,333,278,333,581,500,333,500,556,444,556,444,333,500,556,278,333,556,278,833,556,500,556,556,444,389,333,556,500,722,500,500,444,394,220,394,520,350,500,350,333,500,500,1000,500,500,333,1000,556,333,1000,350,667,350,350,333,333,500,500,350,500,1000,333,1000,389,333,722,350,444,722,250,333,500,500,500,500,220,500,333,747,300,500,570,333,747,333,400,570,300,300,333,556,540,250,333,300,330,500,750,750,750,500,722,722,722,722,722,722,1000,722,667,667,667,667,389,389,389,389,722,722,778,778,778,778,778,570,778,722,722,722,722,722,611,556,500,500,500,500,500,500,722,444,444,444,444,444,278,278,278,278,500,556,500,500,500,500,500,570,500,556,556,556,556,500,556,500]}`,\n\t\"timesI\":       `{\"Tp\":\"Core\",\"Name\":\"Times-Italic\",\"Up\":-100,\"Ut\":50,\"Cw\":[250,250,250,250,250,250,250,250,250,250,250,250,250,250,250,250,250,250,250,250,250,250,250,250,250,250,250,250,250,250,250,250,250,333,420,500,500,833,778,214,333,333,500,675,250,333,250,278,500,500,500,500,500,500,500,500,500,500,333,333,675,675,675,500,920,611,611,667,722,611,611,722,722,333,444,667,556,833,667,722,611,722,611,500,556,722,611,833,611,556,556,389,278,389,422,500,333,500,500,444,500,444,278,500,500,278,278,444,278,722,500,500,500,500,389,389,278,500,444,667,444,444,389,400,275,400,541,350,500,350,333,500,556,889,500,500,333,1000,500,333,944,350,556,350,350,333,333,556,556,350,500,889,333,980,389,333,667,350,389,556,250,389,500,500,500,500,275,500,333,760,276,500,675,333,760,333,400,675,300,300,333,500,523,250,333,300,310,500,750,750,750,500,611,611,611,611,611,611,889,667,611,611,611,611,333,333,333,333,722,667,722,722,722,722,722,675,722,722,722,722,722,556,611,500,500,500,500,500,500,500,667,444,444,444,444,444,278,278,278,278,500,500,500,500,500,500,500,675,500,500,500,500,500,444,500,444]}`,\n\t\"times\":        `{\"Tp\":\"Core\",\"Name\":\"Times-Roman\",\"Up\":-100,\"Ut\":50,\"Cw\":[250,250,250,250,250,250,250,250,250,250,250,250,250,250,250,250,250,250,250,250,250,250,250,250,250,250,250,250,250,250,250,250,250,333,408,500,500,833,778,180,333,333,500,564,250,333,250,278,500,500,500,500,500,500,500,500,500,500,278,278,564,564,564,444,921,722,667,667,722,611,556,722,722,333,389,722,611,889,722,722,556,722,667,556,611,722,722,944,722,722,611,333,278,333,469,500,333,444,500,444,500,444,333,500,500,278,278,500,278,778,500,500,500,500,333,389,278,500,500,722,500,500,444,480,200,480,541,350,500,350,333,500,444,1000,500,500,333,1000,556,333,889,350,611,350,350,333,333,444,444,350,500,1000,333,980,389,333,722,350,444,722,250,333,500,500,500,500,200,500,333,760,276,500,564,333,760,333,400,564,300,300,333,500,453,250,333,300,310,500,750,750,750,444,722,722,722,722,722,722,889,667,611,611,611,611,333,333,333,333,722,722,722,722,722,722,722,564,722,722,722,722,722,722,556,500,444,444,444,444,444,444,667,444,444,444,444,444,278,278,278,278,500,500,500,500,500,500,500,564,500,500,500,500,500,500,500,500]}`,\n\t\"zapfdingbats\": `{\"Tp\":\"Core\",\"Name\":\"ZapfDingbats\",\"Up\":-100,\"Ut\":50,\"Cw\":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,278,974,961,974,980,719,789,790,791,690,960,939,549,855,911,933,911,945,974,755,846,762,761,571,677,763,760,759,754,494,552,537,577,692,786,788,788,790,793,794,816,823,789,841,823,833,816,831,923,744,723,749,790,792,695,776,768,792,759,707,708,682,701,826,815,789,789,707,687,696,689,786,787,713,791,785,791,873,761,762,762,759,759,892,892,788,784,438,138,277,415,392,392,668,668,0,390,390,317,317,276,276,509,509,410,410,234,234,334,334,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,732,544,544,910,667,760,760,776,595,694,626,788,788,788,788,788,788,788,788,788,788,788,788,788,788,788,788,788,788,788,788,788,788,788,788,788,788,788,788,788,788,788,788,788,788,788,788,788,788,788,788,894,838,1016,458,748,924,748,918,927,928,928,834,873,828,924,924,917,930,931,463,883,836,836,867,867,696,696,874,0,874,760,946,771,865,771,888,967,888,831,873,927,970,918,0]}`,\n}\n\nfunc (f *Fpdf) coreFontReader(familyStr, styleStr string) (r *strings.Reader) {\n\tkey := familyStr + styleStr\n\tstr, ok := embeddedFontList[key]\n\tif ok {\n\t\tr = strings.NewReader(str)\n\t} else {\n\t\tf.SetErrorf(\"could not locate \\\"%s\\\" among embedded core font definition files\", key)\n\t}\n\treturn\n}\n\nvar embeddedMapList = map[string]string{\n\t\"cp1250\": `\n!00 U+0000 .notdef\n!01 U+0001 .notdef\n!02 U+0002 .notdef\n!03 U+0003 .notdef\n!04 U+0004 .notdef\n!05 U+0005 .notdef\n!06 U+0006 .notdef\n!07 U+0007 .notdef\n!08 U+0008 .notdef\n!09 U+0009 .notdef\n!0A U+000A .notdef\n!0B U+000B .notdef\n!0C U+000C .notdef\n!0D U+000D .notdef\n!0E U+000E .notdef\n!0F U+000F .notdef\n!10 U+0010 .notdef\n!11 U+0011 .notdef\n!12 U+0012 .notdef\n!13 U+0013 .notdef\n!14 U+0014 .notdef\n!15 U+0015 .notdef\n!16 U+0016 .notdef\n!17 U+0017 .notdef\n!18 U+0018 .notdef\n!19 U+0019 .notdef\n!1A U+001A .notdef\n!1B U+001B .notdef\n!1C U+001C .notdef\n!1D U+001D .notdef\n!1E U+001E .notdef\n!1F U+001F .notdef\n!20 U+0020 space\n!21 U+0021 exclam\n!22 U+0022 quotedbl\n!23 U+0023 numbersign\n!24 U+0024 dollar\n!25 U+0025 percent\n!26 U+0026 ampersand\n!27 U+0027 quotesingle\n!28 U+0028 parenleft\n!29 U+0029 parenright\n!2A U+002A asterisk\n!2B U+002B plus\n!2C U+002C comma\n!2D U+002D hyphen\n!2E U+002E period\n!2F U+002F slash\n!30 U+0030 zero\n!31 U+0031 one\n!32 U+0032 two\n!33 U+0033 three\n!34 U+0034 four\n!35 U+0035 five\n!36 U+0036 six\n!37 U+0037 seven\n!38 U+0038 eight\n!39 U+0039 nine\n!3A U+003A colon\n!3B U+003B semicolon\n!3C U+003C less\n!3D U+003D equal\n!3E U+003E greater\n!3F U+003F question\n!40 U+0040 at\n!41 U+0041 A\n!42 U+0042 B\n!43 U+0043 C\n!44 U+0044 D\n!45 U+0045 E\n!46 U+0046 F\n!47 U+0047 G\n!48 U+0048 H\n!49 U+0049 I\n!4A U+004A J\n!4B U+004B K\n!4C U+004C L\n!4D U+004D M\n!4E U+004E N\n!4F U+004F O\n!50 U+0050 P\n!51 U+0051 Q\n!52 U+0052 R\n!53 U+0053 S\n!54 U+0054 T\n!55 U+0055 U\n!56 U+0056 V\n!57 U+0057 W\n!58 U+0058 X\n!59 U+0059 Y\n!5A U+005A Z\n!5B U+005B bracketleft\n!5C U+005C backslash\n!5D U+005D bracketright\n!5E U+005E asciicircum\n!5F U+005F underscore\n!60 U+0060 grave\n!61 U+0061 a\n!62 U+0062 b\n!63 U+0063 c\n!64 U+0064 d\n!65 U+0065 e\n!66 U+0066 f\n!67 U+0067 g\n!68 U+0068 h\n!69 U+0069 i\n!6A U+006A j\n!6B U+006B k\n!6C U+006C l\n!6D U+006D m\n!6E U+006E n\n!6F U+006F o\n!70 U+0070 p\n!71 U+0071 q\n!72 U+0072 r\n!73 U+0073 s\n!74 U+0074 t\n!75 U+0075 u\n!76 U+0076 v\n!77 U+0077 w\n!78 U+0078 x\n!79 U+0079 y\n!7A U+007A z\n!7B U+007B braceleft\n!7C U+007C bar\n!7D U+007D braceright\n!7E U+007E asciitilde\n!7F U+007F .notdef\n!80 U+20AC Euro\n!82 U+201A quotesinglbase\n!84 U+201E quotedblbase\n!85 U+2026 ellipsis\n!86 U+2020 dagger\n!87 U+2021 daggerdbl\n!89 U+2030 perthousand\n!8A U+0160 Scaron\n!8B U+2039 guilsinglleft\n!8C U+015A Sacute\n!8D U+0164 Tcaron\n!8E U+017D Zcaron\n!8F U+0179 Zacute\n!91 U+2018 quoteleft\n!92 U+2019 quoteright\n!93 U+201C quotedblleft\n!94 U+201D quotedblright\n!95 U+2022 bullet\n!96 U+2013 endash\n!97 U+2014 emdash\n!99 U+2122 trademark\n!9A U+0161 scaron\n!9B U+203A guilsinglright\n!9C U+015B sacute\n!9D U+0165 tcaron\n!9E U+017E zcaron\n!9F U+017A zacute\n!A0 U+00A0 space\n!A1 U+02C7 caron\n!A2 U+02D8 breve\n!A3 U+0141 Lslash\n!A4 U+00A4 currency\n!A5 U+0104 Aogonek\n!A6 U+00A6 brokenbar\n!A7 U+00A7 section\n!A8 U+00A8 dieresis\n!A9 U+00A9 copyright\n!AA U+015E Scedilla\n!AB U+00AB guillemotleft\n!AC U+00AC logicalnot\n!AD U+00AD hyphen\n!AE U+00AE registered\n!AF U+017B Zdotaccent\n!B0 U+00B0 degree\n!B1 U+00B1 plusminus\n!B2 U+02DB ogonek\n!B3 U+0142 lslash\n!B4 U+00B4 acute\n!B5 U+00B5 mu\n!B6 U+00B6 paragraph\n!B7 U+00B7 periodcentered\n!B8 U+00B8 cedilla\n!B9 U+0105 aogonek\n!BA U+015F scedilla\n!BB U+00BB guillemotright\n!BC U+013D Lcaron\n!BD U+02DD hungarumlaut\n!BE U+013E lcaron\n!BF U+017C zdotaccent\n!C0 U+0154 Racute\n!C1 U+00C1 Aacute\n!C2 U+00C2 Acircumflex\n!C3 U+0102 Abreve\n!C4 U+00C4 Adieresis\n!C5 U+0139 Lacute\n!C6 U+0106 Cacute\n!C7 U+00C7 Ccedilla\n!C8 U+010C Ccaron\n!C9 U+00C9 Eacute\n!CA U+0118 Eogonek\n!CB U+00CB Edieresis\n!CC U+011A Ecaron\n!CD U+00CD Iacute\n!CE U+00CE Icircumflex\n!CF U+010E Dcaron\n!D0 U+0110 Dcroat\n!D1 U+0143 Nacute\n!D2 U+0147 Ncaron\n!D3 U+00D3 Oacute\n!D4 U+00D4 Ocircumflex\n!D5 U+0150 Ohungarumlaut\n!D6 U+00D6 Odieresis\n!D7 U+00D7 multiply\n!D8 U+0158 Rcaron\n!D9 U+016E Uring\n!DA U+00DA Uacute\n!DB U+0170 Uhungarumlaut\n!DC U+00DC Udieresis\n!DD U+00DD Yacute\n!DE U+0162 Tcommaaccent\n!DF U+00DF germandbls\n!E0 U+0155 racute\n!E1 U+00E1 aacute\n!E2 U+00E2 acircumflex\n!E3 U+0103 abreve\n!E4 U+00E4 adieresis\n!E5 U+013A lacute\n!E6 U+0107 cacute\n!E7 U+00E7 ccedilla\n!E8 U+010D ccaron\n!E9 U+00E9 eacute\n!EA U+0119 eogonek\n!EB U+00EB edieresis\n!EC U+011B ecaron\n!ED U+00ED iacute\n!EE U+00EE icircumflex\n!EF U+010F dcaron\n!F0 U+0111 dcroat\n!F1 U+0144 nacute\n!F2 U+0148 ncaron\n!F3 U+00F3 oacute\n!F4 U+00F4 ocircumflex\n!F5 U+0151 ohungarumlaut\n!F6 U+00F6 odieresis\n!F7 U+00F7 divide\n!F8 U+0159 rcaron\n!F9 U+016F uring\n!FA U+00FA uacute\n!FB U+0171 uhungarumlaut\n!FC U+00FC udieresis\n!FD U+00FD yacute\n!FE U+0163 tcommaaccent\n!FF U+02D9 dotaccent\n\t`,\n\t\"cp1252\": `\n!00 U+0000 .notdef\n!01 U+0001 .notdef\n!02 U+0002 .notdef\n!03 U+0003 .notdef\n!04 U+0004 .notdef\n!05 U+0005 .notdef\n!06 U+0006 .notdef\n!07 U+0007 .notdef\n!08 U+0008 .notdef\n!09 U+0009 .notdef\n!0A U+000A .notdef\n!0B U+000B .notdef\n!0C U+000C .notdef\n!0D U+000D .notdef\n!0E U+000E .notdef\n!0F U+000F .notdef\n!10 U+0010 .notdef\n!11 U+0011 .notdef\n!12 U+0012 .notdef\n!13 U+0013 .notdef\n!14 U+0014 .notdef\n!15 U+0015 .notdef\n!16 U+0016 .notdef\n!17 U+0017 .notdef\n!18 U+0018 .notdef\n!19 U+0019 .notdef\n!1A U+001A .notdef\n!1B U+001B .notdef\n!1C U+001C .notdef\n!1D U+001D .notdef\n!1E U+001E .notdef\n!1F U+001F .notdef\n!20 U+0020 space\n!21 U+0021 exclam\n!22 U+0022 quotedbl\n!23 U+0023 numbersign\n!24 U+0024 dollar\n!25 U+0025 percent\n!26 U+0026 ampersand\n!27 U+0027 quotesingle\n!28 U+0028 parenleft\n!29 U+0029 parenright\n!2A U+002A asterisk\n!2B U+002B plus\n!2C U+002C comma\n!2D U+002D hyphen\n!2E U+002E period\n!2F U+002F slash\n!30 U+0030 zero\n!31 U+0031 one\n!32 U+0032 two\n!33 U+0033 three\n!34 U+0034 four\n!35 U+0035 five\n!36 U+0036 six\n!37 U+0037 seven\n!38 U+0038 eight\n!39 U+0039 nine\n!3A U+003A colon\n!3B U+003B semicolon\n!3C U+003C less\n!3D U+003D equal\n!3E U+003E greater\n!3F U+003F question\n!40 U+0040 at\n!41 U+0041 A\n!42 U+0042 B\n!43 U+0043 C\n!44 U+0044 D\n!45 U+0045 E\n!46 U+0046 F\n!47 U+0047 G\n!48 U+0048 H\n!49 U+0049 I\n!4A U+004A J\n!4B U+004B K\n!4C U+004C L\n!4D U+004D M\n!4E U+004E N\n!4F U+004F O\n!50 U+0050 P\n!51 U+0051 Q\n!52 U+0052 R\n!53 U+0053 S\n!54 U+0054 T\n!55 U+0055 U\n!56 U+0056 V\n!57 U+0057 W\n!58 U+0058 X\n!59 U+0059 Y\n!5A U+005A Z\n!5B U+005B bracketleft\n!5C U+005C backslash\n!5D U+005D bracketright\n!5E U+005E asciicircum\n!5F U+005F underscore\n!60 U+0060 grave\n!61 U+0061 a\n!62 U+0062 b\n!63 U+0063 c\n!64 U+0064 d\n!65 U+0065 e\n!66 U+0066 f\n!67 U+0067 g\n!68 U+0068 h\n!69 U+0069 i\n!6A U+006A j\n!6B U+006B k\n!6C U+006C l\n!6D U+006D m\n!6E U+006E n\n!6F U+006F o\n!70 U+0070 p\n!71 U+0071 q\n!72 U+0072 r\n!73 U+0073 s\n!74 U+0074 t\n!75 U+0075 u\n!76 U+0076 v\n!77 U+0077 w\n!78 U+0078 x\n!79 U+0079 y\n!7A U+007A z\n!7B U+007B braceleft\n!7C U+007C bar\n!7D U+007D braceright\n!7E U+007E asciitilde\n!7F U+007F .notdef\n!80 U+20AC Euro\n!82 U+201A quotesinglbase\n!83 U+0192 florin\n!84 U+201E quotedblbase\n!85 U+2026 ellipsis\n!86 U+2020 dagger\n!87 U+2021 daggerdbl\n!88 U+02C6 circumflex\n!89 U+2030 perthousand\n!8A U+0160 Scaron\n!8B U+2039 guilsinglleft\n!8C U+0152 OE\n!8E U+017D Zcaron\n!91 U+2018 quoteleft\n!92 U+2019 quoteright\n!93 U+201C quotedblleft\n!94 U+201D quotedblright\n!95 U+2022 bullet\n!96 U+2013 endash\n!97 U+2014 emdash\n!98 U+02DC tilde\n!99 U+2122 trademark\n!9A U+0161 scaron\n!9B U+203A guilsinglright\n!9C U+0153 oe\n!9E U+017E zcaron\n!9F U+0178 Ydieresis\n!A0 U+00A0 space\n!A1 U+00A1 exclamdown\n!A2 U+00A2 cent\n!A3 U+00A3 sterling\n!A4 U+00A4 currency\n!A5 U+00A5 yen\n!A6 U+00A6 brokenbar\n!A7 U+00A7 section\n!A8 U+00A8 dieresis\n!A9 U+00A9 copyright\n!AA U+00AA ordfeminine\n!AB U+00AB guillemotleft\n!AC U+00AC logicalnot\n!AD U+00AD hyphen\n!AE U+00AE registered\n!AF U+00AF macron\n!B0 U+00B0 degree\n!B1 U+00B1 plusminus\n!B2 U+00B2 twosuperior\n!B3 U+00B3 threesuperior\n!B4 U+00B4 acute\n!B5 U+00B5 mu\n!B6 U+00B6 paragraph\n!B7 U+00B7 periodcentered\n!B8 U+00B8 cedilla\n!B9 U+00B9 onesuperior\n!BA U+00BA ordmasculine\n!BB U+00BB guillemotright\n!BC U+00BC onequarter\n!BD U+00BD onehalf\n!BE U+00BE threequarters\n!BF U+00BF questiondown\n!C0 U+00C0 Agrave\n!C1 U+00C1 Aacute\n!C2 U+00C2 Acircumflex\n!C3 U+00C3 Atilde\n!C4 U+00C4 Adieresis\n!C5 U+00C5 Aring\n!C6 U+00C6 AE\n!C7 U+00C7 Ccedilla\n!C8 U+00C8 Egrave\n!C9 U+00C9 Eacute\n!CA U+00CA Ecircumflex\n!CB U+00CB Edieresis\n!CC U+00CC Igrave\n!CD U+00CD Iacute\n!CE U+00CE Icircumflex\n!CF U+00CF Idieresis\n!D0 U+00D0 Eth\n!D1 U+00D1 Ntilde\n!D2 U+00D2 Ograve\n!D3 U+00D3 Oacute\n!D4 U+00D4 Ocircumflex\n!D5 U+00D5 Otilde\n!D6 U+00D6 Odieresis\n!D7 U+00D7 multiply\n!D8 U+00D8 Oslash\n!D9 U+00D9 Ugrave\n!DA U+00DA Uacute\n!DB U+00DB Ucircumflex\n!DC U+00DC Udieresis\n!DD U+00DD Yacute\n!DE U+00DE Thorn\n!DF U+00DF germandbls\n!E0 U+00E0 agrave\n!E1 U+00E1 aacute\n!E2 U+00E2 acircumflex\n!E3 U+00E3 atilde\n!E4 U+00E4 adieresis\n!E5 U+00E5 aring\n!E6 U+00E6 ae\n!E7 U+00E7 ccedilla\n!E8 U+00E8 egrave\n!E9 U+00E9 eacute\n!EA U+00EA ecircumflex\n!EB U+00EB edieresis\n!EC U+00EC igrave\n!ED U+00ED iacute\n!EE U+00EE icircumflex\n!EF U+00EF idieresis\n!F0 U+00F0 eth\n!F1 U+00F1 ntilde\n!F2 U+00F2 ograve\n!F3 U+00F3 oacute\n!F4 U+00F4 ocircumflex\n!F5 U+00F5 otilde\n!F6 U+00F6 odieresis\n!F7 U+00F7 divide\n!F8 U+00F8 oslash\n!F9 U+00F9 ugrave\n!FA U+00FA uacute\n!FB U+00FB ucircumflex\n!FC U+00FC udieresis\n!FD U+00FD yacute\n!FE U+00FE thorn\n!FF U+00FF ydieresis\n\t`,\n}\n"
        },
        {
          "name": "font.go",
          "type": "blob",
          "size": 12.5859375,
          "content": "/*\n * Copyright (c) 2013 Kurt Jung (Gmail: kurt.w.jung)\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\n * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\n * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\npackage gofpdf\n\n// Utility to generate font definition files\n\n// Version: 1.2\n// Date:    2011-06-18\n// Author:  Olivier PLATHEY\n// Port to Go: Kurt Jung, 2013-07-15\n\nimport (\n\t\"bufio\"\n\t\"compress/zlib\"\n\t\"encoding/binary\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"io\"\n\t\"io/ioutil\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"strconv\"\n\t\"strings\"\n)\n\nfunc baseNoExt(fileStr string) string {\n\tstr := filepath.Base(fileStr)\n\textLen := len(filepath.Ext(str))\n\tif extLen > 0 {\n\t\tstr = str[:len(str)-extLen]\n\t}\n\treturn str\n}\n\nfunc loadMap(encodingFileStr string) (encList encListType, err error) {\n\t// printf(\"Encoding file string [%s]\\n\", encodingFileStr)\n\tvar f *os.File\n\t// f, err = os.Open(encodingFilepath(encodingFileStr))\n\tf, err = os.Open(encodingFileStr)\n\tif err == nil {\n\t\tdefer f.Close()\n\t\tfor j := range encList {\n\t\t\tencList[j].uv = -1\n\t\t\tencList[j].name = \".notdef\"\n\t\t}\n\t\tscanner := bufio.NewScanner(f)\n\t\tvar enc encType\n\t\tvar pos int\n\t\tfor scanner.Scan() {\n\t\t\t// \"!3F U+003F question\"\n\t\t\t_, err = fmt.Sscanf(scanner.Text(), \"!%x U+%x %s\", &pos, &enc.uv, &enc.name)\n\t\t\tif err == nil {\n\t\t\t\tif pos < 256 {\n\t\t\t\t\tencList[pos] = enc\n\t\t\t\t} else {\n\t\t\t\t\terr = fmt.Errorf(\"map position 0x%2X exceeds 0xFF\", pos)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t\tif err = scanner.Err(); err != nil {\n\t\t\treturn\n\t\t}\n\t}\n\treturn\n}\n\n// getInfoFromTrueType returns information from a TrueType font\nfunc getInfoFromTrueType(fileStr string, msgWriter io.Writer, embed bool, encList encListType) (info fontInfoType, err error) {\n\tinfo.Widths = make([]int, 256)\n\tvar ttf TtfType\n\tttf, err = TtfParse(fileStr)\n\tif err != nil {\n\t\treturn\n\t}\n\tif embed {\n\t\tif !ttf.Embeddable {\n\t\t\terr = fmt.Errorf(\"font license does not allow embedding\")\n\t\t\treturn\n\t\t}\n\t\tinfo.Data, err = ioutil.ReadFile(fileStr)\n\t\tif err != nil {\n\t\t\treturn\n\t\t}\n\t\tinfo.OriginalSize = len(info.Data)\n\t}\n\tk := 1000.0 / float64(ttf.UnitsPerEm)\n\tinfo.FontName = ttf.PostScriptName\n\tinfo.Bold = ttf.Bold\n\tinfo.Desc.ItalicAngle = int(ttf.ItalicAngle)\n\tinfo.IsFixedPitch = ttf.IsFixedPitch\n\tinfo.Desc.Ascent = round(k * float64(ttf.TypoAscender))\n\tinfo.Desc.Descent = round(k * float64(ttf.TypoDescender))\n\tinfo.UnderlineThickness = round(k * float64(ttf.UnderlineThickness))\n\tinfo.UnderlinePosition = round(k * float64(ttf.UnderlinePosition))\n\tinfo.Desc.FontBBox = fontBoxType{\n\t\tround(k * float64(ttf.Xmin)),\n\t\tround(k * float64(ttf.Ymin)),\n\t\tround(k * float64(ttf.Xmax)),\n\t\tround(k * float64(ttf.Ymax)),\n\t}\n\t// printf(\"FontBBox\\n\")\n\t// dump(info.Desc.FontBBox)\n\tinfo.Desc.CapHeight = round(k * float64(ttf.CapHeight))\n\tinfo.Desc.MissingWidth = round(k * float64(ttf.Widths[0]))\n\tvar wd int\n\tfor j := 0; j < len(info.Widths); j++ {\n\t\twd = info.Desc.MissingWidth\n\t\tif encList[j].name != \".notdef\" {\n\t\t\tuv := encList[j].uv\n\t\t\tpos, ok := ttf.Chars[uint16(uv)]\n\t\t\tif ok {\n\t\t\t\twd = round(k * float64(ttf.Widths[pos]))\n\t\t\t} else {\n\t\t\t\tfmt.Fprintf(msgWriter, \"Character %s is missing\\n\", encList[j].name)\n\t\t\t}\n\t\t}\n\t\tinfo.Widths[j] = wd\n\t}\n\t// printf(\"getInfoFromTrueType/FontBBox\\n\")\n\t// dump(info.Desc.FontBBox)\n\treturn\n}\n\ntype segmentType struct {\n\tmarker uint8\n\ttp     uint8\n\tsize   uint32\n\tdata   []byte\n}\n\nfunc segmentRead(r io.Reader) (s segmentType, err error) {\n\tif err = binary.Read(r, binary.LittleEndian, &s.marker); err != nil {\n\t\treturn\n\t}\n\tif s.marker != 128 {\n\t\terr = fmt.Errorf(\"font file is not a valid binary Type1\")\n\t\treturn\n\t}\n\tif err = binary.Read(r, binary.LittleEndian, &s.tp); err != nil {\n\t\treturn\n\t}\n\tif err = binary.Read(r, binary.LittleEndian, &s.size); err != nil {\n\t\treturn\n\t}\n\ts.data = make([]byte, s.size)\n\t_, err = r.Read(s.data)\n\treturn\n}\n\n// -rw-r--r-- 1 root root  9532 2010-04-22 11:27 /usr/share/fonts/type1/mathml/Symbol.afm\n// -rw-r--r-- 1 root root 37744 2010-04-22 11:27 /usr/share/fonts/type1/mathml/Symbol.pfb\n\n// getInfoFromType1 return information from a Type1 font\nfunc getInfoFromType1(fileStr string, msgWriter io.Writer, embed bool, encList encListType) (info fontInfoType, err error) {\n\tinfo.Widths = make([]int, 256)\n\tif embed {\n\t\tvar f *os.File\n\t\tf, err = os.Open(fileStr)\n\t\tif err != nil {\n\t\t\treturn\n\t\t}\n\t\tdefer f.Close()\n\t\t// Read first segment\n\t\tvar s1, s2 segmentType\n\t\ts1, err = segmentRead(f)\n\t\tif err != nil {\n\t\t\treturn\n\t\t}\n\t\ts2, err = segmentRead(f)\n\t\tif err != nil {\n\t\t\treturn\n\t\t}\n\t\tinfo.Data = s1.data\n\t\tinfo.Data = append(info.Data, s2.data...)\n\t\tinfo.Size1 = s1.size\n\t\tinfo.Size2 = s2.size\n\t}\n\tafmFileStr := fileStr[0:len(fileStr)-3] + \"afm\"\n\tsize, ok := fileSize(afmFileStr)\n\tif !ok {\n\t\terr = fmt.Errorf(\"font file (ATM) %s not found\", afmFileStr)\n\t\treturn\n\t} else if size == 0 {\n\t\terr = fmt.Errorf(\"font file (AFM) %s empty or not readable\", afmFileStr)\n\t\treturn\n\t}\n\tvar f *os.File\n\tf, err = os.Open(afmFileStr)\n\tif err != nil {\n\t\treturn\n\t}\n\tdefer f.Close()\n\tscanner := bufio.NewScanner(f)\n\tvar fields []string\n\tvar wd int\n\tvar wt, name string\n\twdMap := make(map[string]int)\n\tfor scanner.Scan() {\n\t\tfields = strings.Fields(strings.TrimSpace(scanner.Text()))\n\t\t// Comment Generated by FontForge 20080203\n\t\t// FontName Symbol\n\t\t// C 32 ; WX 250 ; N space ; B 0 0 0 0 ;\n\t\tif len(fields) >= 2 {\n\t\t\tswitch fields[0] {\n\t\t\tcase \"C\":\n\t\t\t\tif wd, err = strconv.Atoi(fields[4]); err == nil {\n\t\t\t\t\tname = fields[7]\n\t\t\t\t\twdMap[name] = wd\n\t\t\t\t}\n\t\t\tcase \"FontName\":\n\t\t\t\tinfo.FontName = fields[1]\n\t\t\tcase \"Weight\":\n\t\t\t\twt = strings.ToLower(fields[1])\n\t\t\tcase \"ItalicAngle\":\n\t\t\t\tinfo.Desc.ItalicAngle, err = strconv.Atoi(fields[1])\n\t\t\tcase \"Ascender\":\n\t\t\t\tinfo.Desc.Ascent, err = strconv.Atoi(fields[1])\n\t\t\tcase \"Descender\":\n\t\t\t\tinfo.Desc.Descent, err = strconv.Atoi(fields[1])\n\t\t\tcase \"UnderlineThickness\":\n\t\t\t\tinfo.UnderlineThickness, err = strconv.Atoi(fields[1])\n\t\t\tcase \"UnderlinePosition\":\n\t\t\t\tinfo.UnderlinePosition, err = strconv.Atoi(fields[1])\n\t\t\tcase \"IsFixedPitch\":\n\t\t\t\tinfo.IsFixedPitch = fields[1] == \"true\"\n\t\t\tcase \"FontBBox\":\n\t\t\t\tif info.Desc.FontBBox.Xmin, err = strconv.Atoi(fields[1]); err == nil {\n\t\t\t\t\tif info.Desc.FontBBox.Ymin, err = strconv.Atoi(fields[2]); err == nil {\n\t\t\t\t\t\tif info.Desc.FontBBox.Xmax, err = strconv.Atoi(fields[3]); err == nil {\n\t\t\t\t\t\t\tinfo.Desc.FontBBox.Ymax, err = strconv.Atoi(fields[4])\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\tcase \"CapHeight\":\n\t\t\t\tinfo.Desc.CapHeight, err = strconv.Atoi(fields[1])\n\t\t\tcase \"StdVW\":\n\t\t\t\tinfo.Desc.StemV, err = strconv.Atoi(fields[1])\n\t\t\t}\n\t\t}\n\t\tif err != nil {\n\t\t\treturn\n\t\t}\n\t}\n\tif err = scanner.Err(); err != nil {\n\t\treturn\n\t}\n\tif info.FontName == \"\" {\n\t\terr = fmt.Errorf(\"the field FontName missing in AFM file %s\", afmFileStr)\n\t\treturn\n\t}\n\tinfo.Bold = wt == \"bold\" || wt == \"black\"\n\tvar missingWd int\n\tmissingWd, ok = wdMap[\".notdef\"]\n\tif ok {\n\t\tinfo.Desc.MissingWidth = missingWd\n\t}\n\tfor j := 0; j < len(info.Widths); j++ {\n\t\tinfo.Widths[j] = info.Desc.MissingWidth\n\t}\n\tfor j := 0; j < len(info.Widths); j++ {\n\t\tname = encList[j].name\n\t\tif name != \".notdef\" {\n\t\t\twd, ok = wdMap[name]\n\t\t\tif ok {\n\t\t\t\tinfo.Widths[j] = wd\n\t\t\t} else {\n\t\t\t\tfmt.Fprintf(msgWriter, \"Character %s is missing\\n\", name)\n\t\t\t}\n\t\t}\n\t}\n\t// printf(\"getInfoFromType1/FontBBox\\n\")\n\t// dump(info.Desc.FontBBox)\n\treturn\n}\n\nfunc makeFontDescriptor(info *fontInfoType) {\n\tif info.Desc.CapHeight == 0 {\n\t\tinfo.Desc.CapHeight = info.Desc.Ascent\n\t}\n\tinfo.Desc.Flags = 1 << 5\n\tif info.IsFixedPitch {\n\t\tinfo.Desc.Flags |= 1\n\t}\n\tif info.Desc.ItalicAngle != 0 {\n\t\tinfo.Desc.Flags |= 1 << 6\n\t}\n\tif info.Desc.StemV == 0 {\n\t\tif info.Bold {\n\t\t\tinfo.Desc.StemV = 120\n\t\t} else {\n\t\t\tinfo.Desc.StemV = 70\n\t\t}\n\t}\n\t// printf(\"makeFontDescriptor/FontBBox\\n\")\n\t// dump(info.Desc.FontBBox)\n}\n\n// makeFontEncoding builds differences from reference encoding\nfunc makeFontEncoding(encList encListType, refEncFileStr string) (diffStr string, err error) {\n\tvar refList encListType\n\tif refList, err = loadMap(refEncFileStr); err != nil {\n\t\treturn\n\t}\n\tvar buf fmtBuffer\n\tlast := 0\n\tfor j := 32; j < 256; j++ {\n\t\tif encList[j].name != refList[j].name {\n\t\t\tif j != last+1 {\n\t\t\t\tbuf.printf(\"%d \", j)\n\t\t\t}\n\t\t\tlast = j\n\t\t\tbuf.printf(\"/%s \", encList[j].name)\n\t\t}\n\t}\n\tdiffStr = strings.TrimSpace(buf.String())\n\treturn\n}\n\nfunc makeDefinitionFile(fileStr, tpStr, encodingFileStr string, embed bool, encList encListType, info fontInfoType) error {\n\tvar err error\n\tvar def fontDefType\n\tdef.Tp = tpStr\n\tdef.Name = info.FontName\n\tmakeFontDescriptor(&info)\n\tdef.Desc = info.Desc\n\t// printf(\"makeDefinitionFile/FontBBox\\n\")\n\t// dump(def.Desc.FontBBox)\n\tdef.Up = info.UnderlinePosition\n\tdef.Ut = info.UnderlineThickness\n\tdef.Cw = info.Widths\n\tdef.Enc = baseNoExt(encodingFileStr)\n\t// fmt.Printf(\"encodingFileStr [%s], def.Enc [%s]\\n\", encodingFileStr, def.Enc)\n\t// fmt.Printf(\"reference [%s]\\n\", filepath.Join(filepath.Dir(encodingFileStr), \"cp1252.map\"))\n\tdef.Diff, err = makeFontEncoding(encList, filepath.Join(filepath.Dir(encodingFileStr), \"cp1252.map\"))\n\tif err != nil {\n\t\treturn err\n\t}\n\tdef.File = info.File\n\tdef.Size1 = int(info.Size1)\n\tdef.Size2 = int(info.Size2)\n\tdef.OriginalSize = info.OriginalSize\n\t// printf(\"Font definition file [%s]\\n\", fileStr)\n\tvar buf []byte\n\tbuf, err = json.Marshal(def)\n\tif err != nil {\n\t\treturn err\n\t}\n\tvar f *os.File\n\tf, err = os.Create(fileStr)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer f.Close()\n\t_, err = f.Write(buf)\n\tif err != nil {\n\t\treturn err\n\t}\n\terr = f.Close()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn err\n}\n\n// MakeFont generates a font definition file in JSON format. A definition file\n// of this type is required to use non-core fonts in the PDF documents that\n// gofpdf generates. See the makefont utility in the gofpdf package for a\n// command line interface to this function.\n//\n// fontFileStr is the name of the TrueType file (extension .ttf), OpenType file\n// (extension .otf) or binary Type1 file (extension .pfb) from which to\n// generate a definition file. If an OpenType file is specified, it must be one\n// that is based on TrueType outlines, not PostScript outlines; this cannot be\n// determined from the file extension alone. If a Type1 file is specified, a\n// metric file with the same pathname except with the extension .afm must be\n// present.\n//\n// encodingFileStr is the name of the encoding file that corresponds to the\n// font.\n//\n// dstDirStr is the name of the directory in which to save the definition file\n// and, if embed is true, the compressed font file.\n//\n// msgWriter is the writer that is called to display messages throughout the\n// process. Use nil to turn off messages.\n//\n// embed is true if the font is to be embedded in the PDF files.\nfunc MakeFont(fontFileStr, encodingFileStr, dstDirStr string, msgWriter io.Writer, embed bool) error {\n\tif msgWriter == nil {\n\t\tmsgWriter = ioutil.Discard\n\t}\n\tif !fileExist(fontFileStr) {\n\t\treturn fmt.Errorf(\"font file not found: %s\", fontFileStr)\n\t}\n\textStr := strings.ToLower(fontFileStr[len(fontFileStr)-3:])\n\t// printf(\"Font file extension [%s]\\n\", extStr)\n\tvar tpStr string\n\tswitch extStr {\n\tcase \"ttf\":\n\t\tfallthrough\n\tcase \"otf\":\n\t\ttpStr = \"TrueType\"\n\tcase \"pfb\":\n\t\ttpStr = \"Type1\"\n\tdefault:\n\t\treturn fmt.Errorf(\"unrecognized font file extension: %s\", extStr)\n\t}\n\n\tvar info fontInfoType\n\tencList, err := loadMap(encodingFileStr)\n\tif err != nil {\n\t\treturn err\n\t}\n\t// printf(\"Encoding table\\n\")\n\t// dump(encList)\n\tif tpStr == \"TrueType\" {\n\t\tinfo, err = getInfoFromTrueType(fontFileStr, msgWriter, embed, encList)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t} else {\n\t\tinfo, err = getInfoFromType1(fontFileStr, msgWriter, embed, encList)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\tbaseStr := baseNoExt(fontFileStr)\n\t// fmt.Printf(\"Base [%s]\\n\", baseStr)\n\tif embed {\n\t\tvar f *os.File\n\t\tinfo.File = baseStr + \".z\"\n\t\tzFileStr := filepath.Join(dstDirStr, info.File)\n\t\tf, err = os.Create(zFileStr)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tdefer f.Close()\n\t\tcmp := zlib.NewWriter(f)\n\t\t_, err = cmp.Write(info.Data)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\terr = cmp.Close()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tfmt.Fprintf(msgWriter, \"Font file compressed: %s\\n\", zFileStr)\n\t}\n\tdefFileStr := filepath.Join(dstDirStr, baseStr+\".json\")\n\terr = makeDefinitionFile(defFileStr, tpStr, encodingFileStr, embed, encList, info)\n\tif err != nil {\n\t\treturn err\n\t}\n\tfmt.Fprintf(msgWriter, \"Font definition file successfully generated: %s\\n\", defFileStr)\n\treturn nil\n}\n"
        },
        {
          "name": "font",
          "type": "tree",
          "content": null
        },
        {
          "name": "fpdf.go",
          "type": "blob",
          "size": 146.7314453125,
          "content": "/*\n * Copyright (c) 2013-2014 Kurt Jung (Gmail: kurt.w.jung)\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\n * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\n * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\npackage gofpdf\n\n// Version: 1.7\n// Date:    2011-06-18\n// Author:  Olivier PLATHEY\n// Port to Go: Kurt Jung, 2013-07-15\n\nimport (\n\t\"bytes\"\n\t\"encoding/binary\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"image\"\n\t\"image/color\"\n\t\"image/gif\"\n\t\"image/jpeg\"\n\t\"image/png\"\n\t\"io\"\n\t\"io/ioutil\"\n\t\"math\"\n\t\"os\"\n\t\"path\"\n\t\"sort\"\n\t\"strconv\"\n\t\"strings\"\n\t\"time\"\n)\n\nvar gl struct {\n\tcatalogSort  bool\n\tnoCompress   bool // Initial zero value indicates compression\n\tcreationDate time.Time\n\tmodDate      time.Time\n}\n\ntype fmtBuffer struct {\n\tbytes.Buffer\n}\n\nfunc (b *fmtBuffer) printf(fmtStr string, args ...interface{}) {\n\tb.Buffer.WriteString(fmt.Sprintf(fmtStr, args...))\n}\n\nfunc fpdfNew(orientationStr, unitStr, sizeStr, fontDirStr string, size SizeType) (f *Fpdf) {\n\tf = new(Fpdf)\n\tif orientationStr == \"\" {\n\t\torientationStr = \"p\"\n\t} else {\n\t\torientationStr = strings.ToLower(orientationStr)\n\t}\n\tif unitStr == \"\" {\n\t\tunitStr = \"mm\"\n\t}\n\tif sizeStr == \"\" {\n\t\tsizeStr = \"A4\"\n\t}\n\tif fontDirStr == \"\" {\n\t\tfontDirStr = \".\"\n\t}\n\tf.page = 0\n\tf.n = 2\n\tf.pages = make([]*bytes.Buffer, 0, 8)\n\tf.pages = append(f.pages, bytes.NewBufferString(\"\")) // pages[0] is unused (1-based)\n\tf.pageSizes = make(map[int]SizeType)\n\tf.pageBoxes = make(map[int]map[string]PageBox)\n\tf.defPageBoxes = make(map[string]PageBox)\n\tf.state = 0\n\tf.fonts = make(map[string]fontDefType)\n\tf.fontFiles = make(map[string]fontFileType)\n\tf.diffs = make([]string, 0, 8)\n\tf.templates = make(map[string]Template)\n\tf.templateObjects = make(map[string]int)\n\tf.importedObjs = make(map[string][]byte, 0)\n\tf.importedObjPos = make(map[string]map[int]string, 0)\n\tf.importedTplObjs = make(map[string]string)\n\tf.importedTplIDs = make(map[string]int, 0)\n\tf.images = make(map[string]*ImageInfoType)\n\tf.pageLinks = make([][]linkType, 0, 8)\n\tf.pageLinks = append(f.pageLinks, make([]linkType, 0, 0)) // pageLinks[0] is unused (1-based)\n\tf.links = make([]intLinkType, 0, 8)\n\tf.links = append(f.links, intLinkType{}) // links[0] is unused (1-based)\n\tf.pageAttachments = make([][]annotationAttach, 0, 8)\n\tf.pageAttachments = append(f.pageAttachments, []annotationAttach{}) //\n\tf.aliasMap = make(map[string]string)\n\tf.inHeader = false\n\tf.inFooter = false\n\tf.lasth = 0\n\tf.fontFamily = \"\"\n\tf.fontStyle = \"\"\n\tf.SetFontSize(12)\n\tf.underline = false\n\tf.strikeout = false\n\tf.setDrawColor(0, 0, 0)\n\tf.setFillColor(0, 0, 0)\n\tf.setTextColor(0, 0, 0)\n\tf.colorFlag = false\n\tf.ws = 0\n\tf.fontpath = fontDirStr\n\t// Core fonts\n\tf.coreFonts = map[string]bool{\n\t\t\"courier\":      true,\n\t\t\"helvetica\":    true,\n\t\t\"times\":        true,\n\t\t\"symbol\":       true,\n\t\t\"zapfdingbats\": true,\n\t}\n\t// Scale factor\n\tswitch unitStr {\n\tcase \"pt\", \"point\":\n\t\tf.k = 1.0\n\tcase \"mm\":\n\t\tf.k = 72.0 / 25.4\n\tcase \"cm\":\n\t\tf.k = 72.0 / 2.54\n\tcase \"in\", \"inch\":\n\t\tf.k = 72.0\n\tdefault:\n\t\tf.err = fmt.Errorf(\"incorrect unit %s\", unitStr)\n\t\treturn\n\t}\n\tf.unitStr = unitStr\n\t// Page sizes\n\tf.stdPageSizes = make(map[string]SizeType)\n\tf.stdPageSizes[\"a3\"] = SizeType{841.89, 1190.55}\n\tf.stdPageSizes[\"a4\"] = SizeType{595.28, 841.89}\n\tf.stdPageSizes[\"a5\"] = SizeType{420.94, 595.28}\n\tf.stdPageSizes[\"a6\"] = SizeType{297.64, 420.94}\n\tf.stdPageSizes[\"a2\"] = SizeType{1190.55, 1683.78}\n\tf.stdPageSizes[\"a1\"] = SizeType{1683.78, 2383.94}\n\tf.stdPageSizes[\"letter\"] = SizeType{612, 792}\n\tf.stdPageSizes[\"legal\"] = SizeType{612, 1008}\n\tf.stdPageSizes[\"tabloid\"] = SizeType{792, 1224}\n\tif size.Wd > 0 && size.Ht > 0 {\n\t\tf.defPageSize = size\n\t} else {\n\t\tf.defPageSize = f.getpagesizestr(sizeStr)\n\t\tif f.err != nil {\n\t\t\treturn\n\t\t}\n\t}\n\tf.curPageSize = f.defPageSize\n\t// Page orientation\n\tswitch orientationStr {\n\tcase \"p\", \"portrait\":\n\t\tf.defOrientation = \"P\"\n\t\tf.w = f.defPageSize.Wd\n\t\tf.h = f.defPageSize.Ht\n\t\t// dbg(\"Assign h: %8.2f\", f.h)\n\tcase \"l\", \"landscape\":\n\t\tf.defOrientation = \"L\"\n\t\tf.w = f.defPageSize.Ht\n\t\tf.h = f.defPageSize.Wd\n\tdefault:\n\t\tf.err = fmt.Errorf(\"incorrect orientation: %s\", orientationStr)\n\t\treturn\n\t}\n\tf.curOrientation = f.defOrientation\n\tf.wPt = f.w * f.k\n\tf.hPt = f.h * f.k\n\t// Page margins (1 cm)\n\tmargin := 28.35 / f.k\n\tf.SetMargins(margin, margin, margin)\n\t// Interior cell margin (1 mm)\n\tf.cMargin = margin / 10\n\t// Line width (0.2 mm)\n\tf.lineWidth = 0.567 / f.k\n\t// \tAutomatic page break\n\tf.SetAutoPageBreak(true, 2*margin)\n\t// Default display mode\n\tf.SetDisplayMode(\"default\", \"default\")\n\tif f.err != nil {\n\t\treturn\n\t}\n\tf.acceptPageBreak = func() bool {\n\t\treturn f.autoPageBreak\n\t}\n\t// Enable compression\n\tf.SetCompression(!gl.noCompress)\n\tf.spotColorMap = make(map[string]spotColorType)\n\tf.blendList = make([]blendModeType, 0, 8)\n\tf.blendList = append(f.blendList, blendModeType{}) // blendList[0] is unused (1-based)\n\tf.blendMap = make(map[string]int)\n\tf.blendMode = \"Normal\"\n\tf.alpha = 1\n\tf.gradientList = make([]gradientType, 0, 8)\n\tf.gradientList = append(f.gradientList, gradientType{}) // gradientList[0] is unused\n\t// Set default PDF version number\n\tf.pdfVersion = \"1.3\"\n\tf.SetProducer(\"FPDF \"+cnFpdfVersion, true)\n\tf.layerInit()\n\tf.catalogSort = gl.catalogSort\n\tf.creationDate = gl.creationDate\n\tf.modDate = gl.modDate\n\tf.userUnderlineThickness = 1\n\treturn\n}\n\n// NewCustom returns a pointer to a new Fpdf instance. Its methods are\n// subsequently called to produce a single PDF document. NewCustom() is an\n// alternative to New() that provides additional customization. The PageSize()\n// example demonstrates this method.\nfunc NewCustom(init *InitType) (f *Fpdf) {\n\treturn fpdfNew(init.OrientationStr, init.UnitStr, init.SizeStr, init.FontDirStr, init.Size)\n}\n\n// New returns a pointer to a new Fpdf instance. Its methods are subsequently\n// called to produce a single PDF document.\n//\n// orientationStr specifies the default page orientation. For portrait mode,\n// specify \"P\" or \"Portrait\". For landscape mode, specify \"L\" or \"Landscape\".\n// An empty string will be replaced with \"P\".\n//\n// unitStr specifies the unit of length used in size parameters for elements\n// other than fonts, which are always measured in points. Specify \"pt\" for\n// point, \"mm\" for millimeter, \"cm\" for centimeter, or \"in\" for inch. An empty\n// string will be replaced with \"mm\".\n//\n// sizeStr specifies the page size. Acceptable values are \"A3\", \"A4\", \"A5\",\n// \"Letter\", \"Legal\", or \"Tabloid\". An empty string will be replaced with \"A4\".\n//\n// fontDirStr specifies the file system location in which font resources will\n// be found. An empty string is replaced with \".\". This argument only needs to\n// reference an actual directory if a font other than one of the core\n// fonts is used. The core fonts are \"courier\", \"helvetica\" (also called\n// \"arial\"), \"times\", and \"zapfdingbats\" (also called \"symbol\").\nfunc New(orientationStr, unitStr, sizeStr, fontDirStr string) (f *Fpdf) {\n\treturn fpdfNew(orientationStr, unitStr, sizeStr, fontDirStr, SizeType{0, 0})\n}\n\n// Ok returns true if no processing errors have occurred.\nfunc (f *Fpdf) Ok() bool {\n\treturn f.err == nil\n}\n\n// Err returns true if a processing error has occurred.\nfunc (f *Fpdf) Err() bool {\n\treturn f.err != nil\n}\n\n// ClearError unsets the internal Fpdf error. This method should be used with\n// care, as an internal error condition usually indicates an unrecoverable\n// problem with the generation of a document. It is intended to deal with cases\n// in which an error is used to select an alternate form of the document.\nfunc (f *Fpdf) ClearError() {\n\tf.err = nil\n}\n\n// SetErrorf sets the internal Fpdf error with formatted text to halt PDF\n// generation; this may facilitate error handling by application. If an error\n// condition is already set, this call is ignored.\n//\n// See the documentation for printing in the standard fmt package for details\n// about fmtStr and args.\nfunc (f *Fpdf) SetErrorf(fmtStr string, args ...interface{}) {\n\tif f.err == nil {\n\t\tf.err = fmt.Errorf(fmtStr, args...)\n\t}\n}\n\n// String satisfies the fmt.Stringer interface and summarizes the Fpdf\n// instance.\nfunc (f *Fpdf) String() string {\n\treturn \"Fpdf \" + cnFpdfVersion\n}\n\n// SetError sets an error to halt PDF generation. This may facilitate error\n// handling by application. See also Ok(), Err() and Error().\nfunc (f *Fpdf) SetError(err error) {\n\tif f.err == nil && err != nil {\n\t\tf.err = err\n\t}\n}\n\n// Error returns the internal Fpdf error; this will be nil if no error has occurred.\nfunc (f *Fpdf) Error() error {\n\treturn f.err\n}\n\n// GetPageSize returns the current page's width and height. This is the paper's\n// size. To compute the size of the area being used, subtract the margins (see\n// GetMargins()).\nfunc (f *Fpdf) GetPageSize() (width, height float64) {\n\twidth = f.w\n\theight = f.h\n\treturn\n}\n\n// GetMargins returns the left, top, right, and bottom margins. The first three\n// are set with the SetMargins() method. The bottom margin is set with the\n// SetAutoPageBreak() method.\nfunc (f *Fpdf) GetMargins() (left, top, right, bottom float64) {\n\tleft = f.lMargin\n\ttop = f.tMargin\n\tright = f.rMargin\n\tbottom = f.bMargin\n\treturn\n}\n\n// SetMargins defines the left, top and right margins. By default, they equal 1\n// cm. Call this method to change them. If the value of the right margin is\n// less than zero, it is set to the same as the left margin.\nfunc (f *Fpdf) SetMargins(left, top, right float64) {\n\tf.lMargin = left\n\tf.tMargin = top\n\tif right < 0 {\n\t\tright = left\n\t}\n\tf.rMargin = right\n}\n\n// SetLeftMargin defines the left margin. The method can be called before\n// creating the first page. If the current abscissa gets out of page, it is\n// brought back to the margin.\nfunc (f *Fpdf) SetLeftMargin(margin float64) {\n\tf.lMargin = margin\n\tif f.page > 0 && f.x < margin {\n\t\tf.x = margin\n\t}\n}\n\n// GetCellMargin returns the cell margin. This is the amount of space before\n// and after the text within a cell that's left blank, and is in units passed\n// to New(). It defaults to 1mm.\nfunc (f *Fpdf) GetCellMargin() float64 {\n\treturn f.cMargin\n}\n\n// SetCellMargin sets the cell margin. This is the amount of space before and\n// after the text within a cell that's left blank, and is in units passed to\n// New().\nfunc (f *Fpdf) SetCellMargin(margin float64) {\n\tf.cMargin = margin\n}\n\n// SetPageBoxRec sets the page box for the current page, and any following\n// pages. Allowable types are trim, trimbox, crop, cropbox, bleed, bleedbox,\n// art and artbox box types are case insensitive. See SetPageBox() for a method\n// that specifies the coordinates and extent of the page box individually.\nfunc (f *Fpdf) SetPageBoxRec(t string, pb PageBox) {\n\tswitch strings.ToLower(t) {\n\tcase \"trim\":\n\t\tfallthrough\n\tcase \"trimbox\":\n\t\tt = \"TrimBox\"\n\tcase \"crop\":\n\t\tfallthrough\n\tcase \"cropbox\":\n\t\tt = \"CropBox\"\n\tcase \"bleed\":\n\t\tfallthrough\n\tcase \"bleedbox\":\n\t\tt = \"BleedBox\"\n\tcase \"art\":\n\t\tfallthrough\n\tcase \"artbox\":\n\t\tt = \"ArtBox\"\n\tdefault:\n\t\tf.err = fmt.Errorf(\"%s is not a valid page box type\", t)\n\t\treturn\n\t}\n\n\tpb.X = pb.X * f.k\n\tpb.Y = pb.Y * f.k\n\tpb.Wd = (pb.Wd * f.k) + pb.X\n\tpb.Ht = (pb.Ht * f.k) + pb.Y\n\n\tif f.page > 0 {\n\t\tf.pageBoxes[f.page][t] = pb\n\t}\n\n\t// always override. page defaults are supplied in addPage function\n\tf.defPageBoxes[t] = pb\n}\n\n// SetPageBox sets the page box for the current page, and any following pages.\n// Allowable types are trim, trimbox, crop, cropbox, bleed, bleedbox, art and\n// artbox box types are case insensitive.\nfunc (f *Fpdf) SetPageBox(t string, x, y, wd, ht float64) {\n\tf.SetPageBoxRec(t, PageBox{SizeType{Wd: wd, Ht: ht}, PointType{X: x, Y: y}})\n}\n\n// SetPage sets the current page to that of a valid page in the PDF document.\n// pageNum is one-based. The SetPage() example demonstrates this method.\nfunc (f *Fpdf) SetPage(pageNum int) {\n\tif (pageNum > 0) && (pageNum < len(f.pages)) {\n\t\tf.page = pageNum\n\t}\n}\n\n// PageCount returns the number of pages currently in the document. Since page\n// numbers in gofpdf are one-based, the page count is the same as the page\n// number of the current last page.\nfunc (f *Fpdf) PageCount() int {\n\treturn len(f.pages) - 1\n}\n\n// SetFontLocation sets the location in the file system of the font and font\n// definition files.\nfunc (f *Fpdf) SetFontLocation(fontDirStr string) {\n\tf.fontpath = fontDirStr\n}\n\n// SetFontLoader sets a loader used to read font files (.json and .z) from an\n// arbitrary source. If a font loader has been specified, it is used to load\n// the named font resources when AddFont() is called. If this operation fails,\n// an attempt is made to load the resources from the configured font directory\n// (see SetFontLocation()).\nfunc (f *Fpdf) SetFontLoader(loader FontLoader) {\n\tf.fontLoader = loader\n}\n\n// SetHeaderFuncMode sets the function that lets the application render the\n// page header. See SetHeaderFunc() for more details. The value for homeMode\n// should be set to true to have the current position set to the left and top\n// margin after the header function is called.\nfunc (f *Fpdf) SetHeaderFuncMode(fnc func(), homeMode bool) {\n\tf.headerFnc = fnc\n\tf.headerHomeMode = homeMode\n}\n\n// SetHeaderFunc sets the function that lets the application render the page\n// header. The specified function is automatically called by AddPage() and\n// should not be called directly by the application. The implementation in Fpdf\n// is empty, so you have to provide an appropriate function if you want page\n// headers. fnc will typically be a closure that has access to the Fpdf\n// instance and other document generation variables.\n//\n// A header is a convenient place to put background content that repeats on\n// each page such as a watermark. When this is done, remember to reset the X\n// and Y values so the normal content begins where expected. Including a\n// watermark on each page is demonstrated in the example for TransformRotate.\n//\n// This method is demonstrated in the example for AddPage().\nfunc (f *Fpdf) SetHeaderFunc(fnc func()) {\n\tf.headerFnc = fnc\n}\n\n// SetFooterFunc sets the function that lets the application render the page\n// footer. The specified function is automatically called by AddPage() and\n// Close() and should not be called directly by the application. The\n// implementation in Fpdf is empty, so you have to provide an appropriate\n// function if you want page footers. fnc will typically be a closure that has\n// access to the Fpdf instance and other document generation variables. See\n// SetFooterFuncLpi for a similar function that passes a last page indicator.\n//\n// This method is demonstrated in the example for AddPage().\nfunc (f *Fpdf) SetFooterFunc(fnc func()) {\n\tf.footerFnc = fnc\n\tf.footerFncLpi = nil\n}\n\n// SetFooterFuncLpi sets the function that lets the application render the page\n// footer. The specified function is automatically called by AddPage() and\n// Close() and should not be called directly by the application. It is passed a\n// boolean that is true if the last page of the document is being rendered. The\n// implementation in Fpdf is empty, so you have to provide an appropriate\n// function if you want page footers. fnc will typically be a closure that has\n// access to the Fpdf instance and other document generation variables.\nfunc (f *Fpdf) SetFooterFuncLpi(fnc func(lastPage bool)) {\n\tf.footerFncLpi = fnc\n\tf.footerFnc = nil\n}\n\n// SetTopMargin defines the top margin. The method can be called before\n// creating the first page.\nfunc (f *Fpdf) SetTopMargin(margin float64) {\n\tf.tMargin = margin\n}\n\n// SetRightMargin defines the right margin. The method can be called before\n// creating the first page.\nfunc (f *Fpdf) SetRightMargin(margin float64) {\n\tf.rMargin = margin\n}\n\n// GetAutoPageBreak returns true if automatic pages breaks are enabled, false\n// otherwise. This is followed by the triggering limit from the bottom of the\n// page. This value applies only if automatic page breaks are enabled.\nfunc (f *Fpdf) GetAutoPageBreak() (auto bool, margin float64) {\n\tauto = f.autoPageBreak\n\tmargin = f.bMargin\n\treturn\n}\n\n// SetAutoPageBreak enables or disables the automatic page breaking mode. When\n// enabling, the second parameter is the distance from the bottom of the page\n// that defines the triggering limit. By default, the mode is on and the margin\n// is 2 cm.\nfunc (f *Fpdf) SetAutoPageBreak(auto bool, margin float64) {\n\tf.autoPageBreak = auto\n\tf.bMargin = margin\n\tf.pageBreakTrigger = f.h - margin\n}\n\n// SetDisplayMode sets advisory display directives for the document viewer.\n// Pages can be displayed entirely on screen, occupy the full width of the\n// window, use real size, be scaled by a specific zooming factor or use viewer\n// default (configured in the Preferences menu of Adobe Reader). The page\n// layout can be specified so that pages are displayed individually or in\n// pairs.\n//\n// zoomStr can be \"fullpage\" to display the entire page on screen, \"fullwidth\"\n// to use maximum width of window, \"real\" to use real size (equivalent to 100%\n// zoom) or \"default\" to use viewer default mode.\n//\n// layoutStr can be \"single\" (or \"SinglePage\") to display one page at once,\n// \"continuous\" (or \"OneColumn\") to display pages continuously, \"two\" (or\n// \"TwoColumnLeft\") to display two pages on two columns with odd-numbered pages\n// on the left, or \"TwoColumnRight\" to display two pages on two columns with\n// odd-numbered pages on the right, or \"TwoPageLeft\" to display pages two at a\n// time with odd-numbered pages on the left, or \"TwoPageRight\" to display pages\n// two at a time with odd-numbered pages on the right, or \"default\" to use\n// viewer default mode.\nfunc (f *Fpdf) SetDisplayMode(zoomStr, layoutStr string) {\n\tif f.err != nil {\n\t\treturn\n\t}\n\tif layoutStr == \"\" {\n\t\tlayoutStr = \"default\"\n\t}\n\tswitch zoomStr {\n\tcase \"fullpage\", \"fullwidth\", \"real\", \"default\":\n\t\tf.zoomMode = zoomStr\n\tdefault:\n\t\tf.err = fmt.Errorf(\"incorrect zoom display mode: %s\", zoomStr)\n\t\treturn\n\t}\n\tswitch layoutStr {\n\tcase \"single\", \"continuous\", \"two\", \"default\", \"SinglePage\", \"OneColumn\",\n\t\t\"TwoColumnLeft\", \"TwoColumnRight\", \"TwoPageLeft\", \"TwoPageRight\":\n\t\tf.layoutMode = layoutStr\n\tdefault:\n\t\tf.err = fmt.Errorf(\"incorrect layout display mode: %s\", layoutStr)\n\t\treturn\n\t}\n}\n\n// SetDefaultCompression controls the default setting of the internal\n// compression flag. See SetCompression() for more details. Compression is on\n// by default.\nfunc SetDefaultCompression(compress bool) {\n\tgl.noCompress = !compress\n}\n\n// SetCompression activates or deactivates page compression with zlib. When\n// activated, the internal representation of each page is compressed, which\n// leads to a compression ratio of about 2 for the resulting document.\n// Compression is on by default.\nfunc (f *Fpdf) SetCompression(compress bool) {\n\tf.compress = compress\n}\n\n// SetProducer defines the producer of the document. isUTF8 indicates if the string\n// is encoded in ISO-8859-1 (false) or UTF-8 (true).\nfunc (f *Fpdf) SetProducer(producerStr string, isUTF8 bool) {\n\tif isUTF8 {\n\t\tproducerStr = utf8toutf16(producerStr)\n\t}\n\tf.producer = producerStr\n}\n\n// SetTitle defines the title of the document. isUTF8 indicates if the string\n// is encoded in ISO-8859-1 (false) or UTF-8 (true).\nfunc (f *Fpdf) SetTitle(titleStr string, isUTF8 bool) {\n\tif isUTF8 {\n\t\ttitleStr = utf8toutf16(titleStr)\n\t}\n\tf.title = titleStr\n}\n\n// SetSubject defines the subject of the document. isUTF8 indicates if the\n// string is encoded in ISO-8859-1 (false) or UTF-8 (true).\nfunc (f *Fpdf) SetSubject(subjectStr string, isUTF8 bool) {\n\tif isUTF8 {\n\t\tsubjectStr = utf8toutf16(subjectStr)\n\t}\n\tf.subject = subjectStr\n}\n\n// SetAuthor defines the author of the document. isUTF8 indicates if the string\n// is encoded in ISO-8859-1 (false) or UTF-8 (true).\nfunc (f *Fpdf) SetAuthor(authorStr string, isUTF8 bool) {\n\tif isUTF8 {\n\t\tauthorStr = utf8toutf16(authorStr)\n\t}\n\tf.author = authorStr\n}\n\n// SetKeywords defines the keywords of the document. keywordStr is a\n// space-delimited string, for example \"invoice August\". isUTF8 indicates if\n// the string is encoded\nfunc (f *Fpdf) SetKeywords(keywordsStr string, isUTF8 bool) {\n\tif isUTF8 {\n\t\tkeywordsStr = utf8toutf16(keywordsStr)\n\t}\n\tf.keywords = keywordsStr\n}\n\n// SetCreator defines the creator of the document. isUTF8 indicates if the\n// string is encoded in ISO-8859-1 (false) or UTF-8 (true).\nfunc (f *Fpdf) SetCreator(creatorStr string, isUTF8 bool) {\n\tif isUTF8 {\n\t\tcreatorStr = utf8toutf16(creatorStr)\n\t}\n\tf.creator = creatorStr\n}\n\n// SetXmpMetadata defines XMP metadata that will be embedded with the document.\nfunc (f *Fpdf) SetXmpMetadata(xmpStream []byte) {\n\tf.xmp = xmpStream\n}\n\n// AliasNbPages defines an alias for the total number of pages. It will be\n// substituted as the document is closed. An empty string is replaced with the\n// string \"{nb}\".\n//\n// See the example for AddPage() for a demonstration of this method.\nfunc (f *Fpdf) AliasNbPages(aliasStr string) {\n\tif aliasStr == \"\" {\n\t\taliasStr = \"{nb}\"\n\t}\n\tf.aliasNbPagesStr = aliasStr\n}\n\n// RTL enables right-to-left mode\nfunc (f *Fpdf) RTL() {\n\tf.isRTL = true\n}\n\n// LTR disables right-to-left mode\nfunc (f *Fpdf) LTR() {\n\tf.isRTL = false\n}\n\n// open begins a document\nfunc (f *Fpdf) open() {\n\tf.state = 1\n}\n\n// Close terminates the PDF document. It is not necessary to call this method\n// explicitly because Output(), OutputAndClose() and OutputFileAndClose() do it\n// automatically. If the document contains no page, AddPage() is called to\n// prevent the generation of an invalid document.\nfunc (f *Fpdf) Close() {\n\tif f.err == nil {\n\t\tif f.clipNest > 0 {\n\t\t\tf.err = fmt.Errorf(\"clip procedure must be explicitly ended\")\n\t\t} else if f.transformNest > 0 {\n\t\t\tf.err = fmt.Errorf(\"transformation procedure must be explicitly ended\")\n\t\t}\n\t}\n\tif f.err != nil {\n\t\treturn\n\t}\n\tif f.state == 3 {\n\t\treturn\n\t}\n\tif f.page == 0 {\n\t\tf.AddPage()\n\t\tif f.err != nil {\n\t\t\treturn\n\t\t}\n\t}\n\t// Page footer\n\tf.inFooter = true\n\tif f.footerFnc != nil {\n\t\tf.footerFnc()\n\t} else if f.footerFncLpi != nil {\n\t\tf.footerFncLpi(true)\n\t}\n\tf.inFooter = false\n\n\t// Close page\n\tf.endpage()\n\t// Close document\n\tf.enddoc()\n\treturn\n}\n\n// PageSize returns the width and height of the specified page in the units\n// established in New(). These return values are followed by the unit of\n// measure itself. If pageNum is zero or otherwise out of bounds, it returns\n// the default page size, that is, the size of the page that would be added by\n// AddPage().\nfunc (f *Fpdf) PageSize(pageNum int) (wd, ht float64, unitStr string) {\n\tsz, ok := f.pageSizes[pageNum]\n\tif ok {\n\t\tsz.Wd, sz.Ht = sz.Wd/f.k, sz.Ht/f.k\n\t} else {\n\t\tsz = f.defPageSize // user units\n\t}\n\treturn sz.Wd, sz.Ht, f.unitStr\n}\n\n// AddPageFormat adds a new page with non-default orientation or size. See\n// AddPage() for more details.\n//\n// See New() for a description of orientationStr.\n//\n// size specifies the size of the new page in the units established in New().\n//\n// The PageSize() example demonstrates this method.\nfunc (f *Fpdf) AddPageFormat(orientationStr string, size SizeType) {\n\tif f.err != nil {\n\t\treturn\n\t}\n\tif f.page != len(f.pages)-1 {\n\t\tf.page = len(f.pages) - 1\n\t}\n\tif f.state == 0 {\n\t\tf.open()\n\t}\n\tfamilyStr := f.fontFamily\n\tstyle := f.fontStyle\n\tif f.underline {\n\t\tstyle += \"U\"\n\t}\n\tif f.strikeout {\n\t\tstyle += \"S\"\n\t}\n\tfontsize := f.fontSizePt\n\tlw := f.lineWidth\n\tdc := f.color.draw\n\tfc := f.color.fill\n\ttc := f.color.text\n\tcf := f.colorFlag\n\n\tif f.page > 0 {\n\t\tf.inFooter = true\n\t\t// Page footer avoid double call on footer.\n\t\tif f.footerFnc != nil {\n\t\t\tf.footerFnc()\n\n\t\t} else if f.footerFncLpi != nil {\n\t\t\tf.footerFncLpi(false) // not last page.\n\t\t}\n\t\tf.inFooter = false\n\t\t// Close page\n\t\tf.endpage()\n\t}\n\t// Start new page\n\tf.beginpage(orientationStr, size)\n\t// \tSet line cap style to current value\n\t// f.out(\"2 J\")\n\tf.outf(\"%d J\", f.capStyle)\n\t// \tSet line join style to current value\n\tf.outf(\"%d j\", f.joinStyle)\n\t// Set line width\n\tf.lineWidth = lw\n\tf.outf(\"%.2f w\", lw*f.k)\n\t// Set dash pattern\n\tif len(f.dashArray) > 0 {\n\t\tf.outputDashPattern()\n\t}\n\t// \tSet font\n\tif familyStr != \"\" {\n\t\tf.SetFont(familyStr, style, fontsize)\n\t\tif f.err != nil {\n\t\t\treturn\n\t\t}\n\t}\n\t// \tSet colors\n\tf.color.draw = dc\n\tif dc.str != \"0 G\" {\n\t\tf.out(dc.str)\n\t}\n\tf.color.fill = fc\n\tif fc.str != \"0 g\" {\n\t\tf.out(fc.str)\n\t}\n\tf.color.text = tc\n\tf.colorFlag = cf\n\t// \tPage header\n\tif f.headerFnc != nil {\n\t\tf.inHeader = true\n\t\tf.headerFnc()\n\t\tf.inHeader = false\n\t\tif f.headerHomeMode {\n\t\t\tf.SetHomeXY()\n\t\t}\n\t}\n\t// \tRestore line width\n\tif f.lineWidth != lw {\n\t\tf.lineWidth = lw\n\t\tf.outf(\"%.2f w\", lw*f.k)\n\t}\n\t// Restore font\n\tif familyStr != \"\" {\n\t\tf.SetFont(familyStr, style, fontsize)\n\t\tif f.err != nil {\n\t\t\treturn\n\t\t}\n\t}\n\t// Restore colors\n\tif f.color.draw.str != dc.str {\n\t\tf.color.draw = dc\n\t\tf.out(dc.str)\n\t}\n\tif f.color.fill.str != fc.str {\n\t\tf.color.fill = fc\n\t\tf.out(fc.str)\n\t}\n\tf.color.text = tc\n\tf.colorFlag = cf\n\treturn\n}\n\n// AddPage adds a new page to the document. If a page is already present, the\n// Footer() method is called first to output the footer. Then the page is\n// added, the current position set to the top-left corner according to the left\n// and top margins, and Header() is called to display the header.\n//\n// The font which was set before calling is automatically restored. There is no\n// need to call SetFont() again if you want to continue with the same font. The\n// same is true for colors and line width.\n//\n// The origin of the coordinate system is at the top-left corner and increasing\n// ordinates go downwards.\n//\n// See AddPageFormat() for a version of this method that allows the page size\n// and orientation to be different than the default.\nfunc (f *Fpdf) AddPage() {\n\tif f.err != nil {\n\t\treturn\n\t}\n\t// dbg(\"AddPage\")\n\tf.AddPageFormat(f.defOrientation, f.defPageSize)\n\treturn\n}\n\n// PageNo returns the current page number.\n//\n// See the example for AddPage() for a demonstration of this method.\nfunc (f *Fpdf) PageNo() int {\n\treturn f.page\n}\n\nfunc colorComp(v int) (int, float64) {\n\tif v < 0 {\n\t\tv = 0\n\t} else if v > 255 {\n\t\tv = 255\n\t}\n\treturn v, float64(v) / 255.0\n}\n\nfunc rgbColorValue(r, g, b int, grayStr, fullStr string) (clr colorType) {\n\tclr.ir, clr.r = colorComp(r)\n\tclr.ig, clr.g = colorComp(g)\n\tclr.ib, clr.b = colorComp(b)\n\tclr.mode = colorModeRGB\n\tclr.gray = clr.ir == clr.ig && clr.r == clr.b\n\tif len(grayStr) > 0 {\n\t\tif clr.gray {\n\t\t\tclr.str = sprintf(\"%.3f %s\", clr.r, grayStr)\n\t\t} else {\n\t\t\tclr.str = sprintf(\"%.3f %.3f %.3f %s\", clr.r, clr.g, clr.b, fullStr)\n\t\t}\n\t} else {\n\t\tclr.str = sprintf(\"%.3f %.3f %.3f\", clr.r, clr.g, clr.b)\n\t}\n\treturn\n}\n\n// SetDrawColor defines the color used for all drawing operations (lines,\n// rectangles and cell borders). It is expressed in RGB components (0 - 255).\n// The method can be called before the first page is created. The value is\n// retained from page to page.\nfunc (f *Fpdf) SetDrawColor(r, g, b int) {\n\tf.setDrawColor(r, g, b)\n}\n\nfunc (f *Fpdf) setDrawColor(r, g, b int) {\n\tf.color.draw = rgbColorValue(r, g, b, \"G\", \"RG\")\n\tif f.page > 0 {\n\t\tf.out(f.color.draw.str)\n\t}\n}\n\n// GetDrawColor returns the most recently set draw color as RGB components (0 -\n// 255). This will not be the current value if a draw color of some other type\n// (for example, spot) has been more recently set.\nfunc (f *Fpdf) GetDrawColor() (int, int, int) {\n\treturn f.color.draw.ir, f.color.draw.ig, f.color.draw.ib\n}\n\n// SetFillColor defines the color used for all filling operations (filled\n// rectangles and cell backgrounds). It is expressed in RGB components (0\n// -255). The method can be called before the first page is created and the\n// value is retained from page to page.\nfunc (f *Fpdf) SetFillColor(r, g, b int) {\n\tf.setFillColor(r, g, b)\n}\n\nfunc (f *Fpdf) setFillColor(r, g, b int) {\n\tf.color.fill = rgbColorValue(r, g, b, \"g\", \"rg\")\n\tf.colorFlag = f.color.fill.str != f.color.text.str\n\tif f.page > 0 {\n\t\tf.out(f.color.fill.str)\n\t}\n}\n\n// GetFillColor returns the most recently set fill color as RGB components (0 -\n// 255). This will not be the current value if a fill color of some other type\n// (for example, spot) has been more recently set.\nfunc (f *Fpdf) GetFillColor() (int, int, int) {\n\treturn f.color.fill.ir, f.color.fill.ig, f.color.fill.ib\n}\n\n// SetTextColor defines the color used for text. It is expressed in RGB\n// components (0 - 255). The method can be called before the first page is\n// created. The value is retained from page to page.\nfunc (f *Fpdf) SetTextColor(r, g, b int) {\n\tf.setTextColor(r, g, b)\n}\n\nfunc (f *Fpdf) setTextColor(r, g, b int) {\n\tf.color.text = rgbColorValue(r, g, b, \"g\", \"rg\")\n\tf.colorFlag = f.color.fill.str != f.color.text.str\n}\n\n// GetTextColor returns the most recently set text color as RGB components (0 -\n// 255). This will not be the current value if a text color of some other type\n// (for example, spot) has been more recently set.\nfunc (f *Fpdf) GetTextColor() (int, int, int) {\n\treturn f.color.text.ir, f.color.text.ig, f.color.text.ib\n}\n\n// GetStringWidth returns the length of a string in user units. A font must be\n// currently selected.\nfunc (f *Fpdf) GetStringWidth(s string) float64 {\n\tif f.err != nil {\n\t\treturn 0\n\t}\n\tw := f.GetStringSymbolWidth(s)\n\treturn float64(w) * f.fontSize / 1000\n}\n\n// GetStringSymbolWidth returns the length of a string in glyf units. A font must be\n// currently selected.\nfunc (f *Fpdf) GetStringSymbolWidth(s string) int {\n\tif f.err != nil {\n\t\treturn 0\n\t}\n\tw := 0\n\tif f.isCurrentUTF8 {\n\t\tunicode := []rune(s)\n\t\tfor _, char := range unicode {\n\t\t\tintChar := int(char)\n\t\t\tif len(f.currentFont.Cw) >= intChar && f.currentFont.Cw[intChar] > 0 {\n\t\t\t\tif f.currentFont.Cw[intChar] != 65535 {\n\t\t\t\t\tw += f.currentFont.Cw[intChar]\n\t\t\t\t}\n\t\t\t} else if f.currentFont.Desc.MissingWidth != 0 {\n\t\t\t\tw += f.currentFont.Desc.MissingWidth\n\t\t\t} else {\n\t\t\t\tw += 500\n\t\t\t}\n\t\t}\n\t} else {\n\t\tfor _, ch := range []byte(s) {\n\t\t\tif ch == 0 {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tw += f.currentFont.Cw[ch]\n\t\t}\n\t}\n\treturn w\n}\n\n// SetLineWidth defines the line width. By default, the value equals 0.2 mm.\n// The method can be called before the first page is created. The value is\n// retained from page to page.\nfunc (f *Fpdf) SetLineWidth(width float64) {\n\tf.setLineWidth(width)\n}\n\nfunc (f *Fpdf) setLineWidth(width float64) {\n\tf.lineWidth = width\n\tif f.page > 0 {\n\t\tf.outf(\"%.2f w\", width*f.k)\n\t}\n}\n\n// GetLineWidth returns the current line thickness.\nfunc (f *Fpdf) GetLineWidth() float64 {\n\treturn f.lineWidth\n}\n\n// SetLineCapStyle defines the line cap style. styleStr should be \"butt\",\n// \"round\" or \"square\". A square style projects from the end of the line. The\n// method can be called before the first page is created. The value is\n// retained from page to page.\nfunc (f *Fpdf) SetLineCapStyle(styleStr string) {\n\tvar capStyle int\n\tswitch styleStr {\n\tcase \"round\":\n\t\tcapStyle = 1\n\tcase \"square\":\n\t\tcapStyle = 2\n\tdefault:\n\t\tcapStyle = 0\n\t}\n\tf.capStyle = capStyle\n\tif f.page > 0 {\n\t\tf.outf(\"%d J\", f.capStyle)\n\t}\n}\n\n// SetLineJoinStyle defines the line cap style. styleStr should be \"miter\",\n// \"round\" or \"bevel\". The method can be called before the first page\n// is created. The value is retained from page to page.\nfunc (f *Fpdf) SetLineJoinStyle(styleStr string) {\n\tvar joinStyle int\n\tswitch styleStr {\n\tcase \"round\":\n\t\tjoinStyle = 1\n\tcase \"bevel\":\n\t\tjoinStyle = 2\n\tdefault:\n\t\tjoinStyle = 0\n\t}\n\tf.joinStyle = joinStyle\n\tif f.page > 0 {\n\t\tf.outf(\"%d j\", f.joinStyle)\n\t}\n}\n\n// SetDashPattern sets the dash pattern that is used to draw lines. The\n// dashArray elements are numbers that specify the lengths, in units\n// established in New(), of alternating dashes and gaps. The dash phase\n// specifies the distance into the dash pattern at which to start the dash. The\n// dash pattern is retained from page to page. Call this method with an empty\n// array to restore solid line drawing.\n//\n// The Beziergon() example demonstrates this method.\nfunc (f *Fpdf) SetDashPattern(dashArray []float64, dashPhase float64) {\n\tscaled := make([]float64, len(dashArray))\n\tfor i, value := range dashArray {\n\t\tscaled[i] = value * f.k\n\t}\n\tdashPhase *= f.k\n\n\tf.dashArray = scaled\n\tf.dashPhase = dashPhase\n\tif f.page > 0 {\n\t\tf.outputDashPattern()\n\t}\n\n}\n\nfunc (f *Fpdf) outputDashPattern() {\n\tvar buf bytes.Buffer\n\tbuf.WriteByte('[')\n\tfor i, value := range f.dashArray {\n\t\tif i > 0 {\n\t\t\tbuf.WriteByte(' ')\n\t\t}\n\t\tbuf.WriteString(strconv.FormatFloat(value, 'f', 2, 64))\n\t}\n\tbuf.WriteString(\"] \")\n\tbuf.WriteString(strconv.FormatFloat(f.dashPhase, 'f', 2, 64))\n\tbuf.WriteString(\" d\")\n\tf.outbuf(&buf)\n}\n\n// Line draws a line between points (x1, y1) and (x2, y2) using the current\n// draw color, line width and cap style.\nfunc (f *Fpdf) Line(x1, y1, x2, y2 float64) {\n\tf.outf(\"%.2f %.2f m %.2f %.2f l S\", x1*f.k, (f.h-y1)*f.k, x2*f.k, (f.h-y2)*f.k)\n}\n\n// fillDrawOp corrects path painting operators\nfunc fillDrawOp(styleStr string) (opStr string) {\n\tswitch strings.ToUpper(styleStr) {\n\tcase \"\", \"D\":\n\t\t// Stroke the path.\n\t\topStr = \"S\"\n\tcase \"F\":\n\t\t// fill the path, using the nonzero winding number rule\n\t\topStr = \"f\"\n\tcase \"F*\":\n\t\t// fill the path, using the even-odd rule\n\t\topStr = \"f*\"\n\tcase \"FD\", \"DF\":\n\t\t// fill and then stroke the path, using the nonzero winding number rule\n\t\topStr = \"B\"\n\tcase \"FD*\", \"DF*\":\n\t\t// fill and then stroke the path, using the even-odd rule\n\t\topStr = \"B*\"\n\tdefault:\n\t\topStr = styleStr\n\t}\n\treturn\n}\n\n// Rect outputs a rectangle of width w and height h with the upper left corner\n// positioned at point (x, y).\n//\n// It can be drawn (border only), filled (with no border) or both. styleStr can\n// be \"F\" for filled, \"D\" for outlined only, or \"DF\" or \"FD\" for outlined and\n// filled. An empty string will be replaced with \"D\". Drawing uses the current\n// draw color and line width centered on the rectangle's perimeter. Filling\n// uses the current fill color.\nfunc (f *Fpdf) Rect(x, y, w, h float64, styleStr string) {\n\tf.outf(\"%.2f %.2f %.2f %.2f re %s\", x*f.k, (f.h-y)*f.k, w*f.k, -h*f.k, fillDrawOp(styleStr))\n}\n\n// RoundedRect outputs a rectangle of width w and height h with the upper left\n// corner positioned at point (x, y). It can be drawn (border only), filled\n// (with no border) or both. styleStr can be \"F\" for filled, \"D\" for outlined\n// only, or \"DF\" or \"FD\" for outlined and filled. An empty string will be\n// replaced with \"D\". Drawing uses the current draw color and line width\n// centered on the rectangle's perimeter. Filling uses the current fill color.\n// The rounded corners of the rectangle are specified by radius r. corners is a\n// string that includes \"1\" to round the upper left corner, \"2\" to round the\n// upper right corner, \"3\" to round the lower right corner, and \"4\" to round\n// the lower left corner. The RoundedRect example demonstrates this method.\nfunc (f *Fpdf) RoundedRect(x, y, w, h, r float64, corners string, stylestr string) {\n\t// This routine was adapted by Brigham Thompson from a script by Christophe Prugnaud\n\tvar rTL, rTR, rBR, rBL float64 // zero means no rounded corner\n\tif strings.Contains(corners, \"1\") {\n\t\trTL = r\n\t}\n\tif strings.Contains(corners, \"2\") {\n\t\trTR = r\n\t}\n\tif strings.Contains(corners, \"3\") {\n\t\trBR = r\n\t}\n\tif strings.Contains(corners, \"4\") {\n\t\trBL = r\n\t}\n\tf.RoundedRectExt(x, y, w, h, rTL, rTR, rBR, rBL, stylestr)\n}\n\n// RoundedRectExt behaves the same as RoundedRect() but supports a different\n// radius for each corner. A zero radius means squared corner. See\n// RoundedRect() for more details. This method is demonstrated in the\n// RoundedRect() example.\nfunc (f *Fpdf) RoundedRectExt(x, y, w, h, rTL, rTR, rBR, rBL float64, stylestr string) {\n\tf.roundedRectPath(x, y, w, h, rTL, rTR, rBR, rBL)\n\tf.out(fillDrawOp(stylestr))\n}\n\n// Circle draws a circle centered on point (x, y) with radius r.\n//\n// styleStr can be \"F\" for filled, \"D\" for outlined only, or \"DF\" or \"FD\" for\n// outlined and filled. An empty string will be replaced with \"D\". Drawing uses\n// the current draw color and line width centered on the circle's perimeter.\n// Filling uses the current fill color.\nfunc (f *Fpdf) Circle(x, y, r float64, styleStr string) {\n\tf.Ellipse(x, y, r, r, 0, styleStr)\n}\n\n// Ellipse draws an ellipse centered at point (x, y). rx and ry specify its\n// horizontal and vertical radii.\n//\n// degRotate specifies the counter-clockwise angle in degrees that the ellipse\n// will be rotated.\n//\n// styleStr can be \"F\" for filled, \"D\" for outlined only, or \"DF\" or \"FD\" for\n// outlined and filled. An empty string will be replaced with \"D\". Drawing uses\n// the current draw color and line width centered on the ellipse's perimeter.\n// Filling uses the current fill color.\n//\n// The Circle() example demonstrates this method.\nfunc (f *Fpdf) Ellipse(x, y, rx, ry, degRotate float64, styleStr string) {\n\tf.arc(x, y, rx, ry, degRotate, 0, 360, styleStr, false)\n}\n\n// Polygon draws a closed figure defined by a series of vertices specified by\n// points. The x and y fields of the points use the units established in New().\n// The last point in the slice will be implicitly joined to the first to close\n// the polygon.\n//\n// styleStr can be \"F\" for filled, \"D\" for outlined only, or \"DF\" or \"FD\" for\n// outlined and filled. An empty string will be replaced with \"D\". Drawing uses\n// the current draw color and line width centered on the ellipse's perimeter.\n// Filling uses the current fill color.\nfunc (f *Fpdf) Polygon(points []PointType, styleStr string) {\n\tif len(points) > 2 {\n\t\tfor j, pt := range points {\n\t\t\tif j == 0 {\n\t\t\t\tf.point(pt.X, pt.Y)\n\t\t\t} else {\n\t\t\t\tf.outf(\"%.5f %.5f l \", pt.X*f.k, (f.h-pt.Y)*f.k)\n\t\t\t}\n\t\t}\n\t\tf.outf(\"%.5f %.5f l \", points[0].X*f.k, (f.h-points[0].Y)*f.k)\n\t\tf.DrawPath(styleStr)\n\t}\n}\n\n// Beziergon draws a closed figure defined by a series of cubic Bézier curve\n// segments. The first point in the slice defines the starting point of the\n// figure. Each three following points p1, p2, p3 represent a curve segment to\n// the point p3 using p1 and p2 as the Bézier control points.\n//\n// The x and y fields of the points use the units established in New().\n//\n// styleStr can be \"F\" for filled, \"D\" for outlined only, or \"DF\" or \"FD\" for\n// outlined and filled. An empty string will be replaced with \"D\". Drawing uses\n// the current draw color and line width centered on the ellipse's perimeter.\n// Filling uses the current fill color.\nfunc (f *Fpdf) Beziergon(points []PointType, styleStr string) {\n\n\t// Thanks, Robert Lillack, for contributing this function.\n\n\tif len(points) < 4 {\n\t\treturn\n\t}\n\tf.point(points[0].XY())\n\n\tpoints = points[1:]\n\tfor len(points) >= 3 {\n\t\tcx0, cy0 := points[0].XY()\n\t\tcx1, cy1 := points[1].XY()\n\t\tx1, y1 := points[2].XY()\n\t\tf.curve(cx0, cy0, cx1, cy1, x1, y1)\n\t\tpoints = points[3:]\n\t}\n\n\tf.DrawPath(styleStr)\n}\n\n// point outputs current point\nfunc (f *Fpdf) point(x, y float64) {\n\tf.outf(\"%.2f %.2f m\", x*f.k, (f.h-y)*f.k)\n}\n\n// curve outputs a single cubic Bézier curve segment from current point\nfunc (f *Fpdf) curve(cx0, cy0, cx1, cy1, x, y float64) {\n\t// Thanks, Robert Lillack, for straightening this out\n\tf.outf(\"%.5f %.5f %.5f %.5f %.5f %.5f c\", cx0*f.k, (f.h-cy0)*f.k, cx1*f.k,\n\t\t(f.h-cy1)*f.k, x*f.k, (f.h-y)*f.k)\n}\n\n// Curve draws a single-segment quadratic Bézier curve. The curve starts at\n// the point (x0, y0) and ends at the point (x1, y1). The control point (cx,\n// cy) specifies the curvature. At the start point, the curve is tangent to the\n// straight line between the start point and the control point. At the end\n// point, the curve is tangent to the straight line between the end point and\n// the control point.\n//\n// styleStr can be \"F\" for filled, \"D\" for outlined only, or \"DF\" or \"FD\" for\n// outlined and filled. An empty string will be replaced with \"D\". Drawing uses\n// the current draw color, line width, and cap style centered on the curve's\n// path. Filling uses the current fill color.\n//\n// The Circle() example demonstrates this method.\nfunc (f *Fpdf) Curve(x0, y0, cx, cy, x1, y1 float64, styleStr string) {\n\tf.point(x0, y0)\n\tf.outf(\"%.5f %.5f %.5f %.5f v %s\", cx*f.k, (f.h-cy)*f.k, x1*f.k, (f.h-y1)*f.k,\n\t\tfillDrawOp(styleStr))\n}\n\n// CurveCubic draws a single-segment cubic Bézier curve. This routine performs\n// the same function as CurveBezierCubic() but has a nonstandard argument order.\n// It is retained to preserve backward compatibility.\nfunc (f *Fpdf) CurveCubic(x0, y0, cx0, cy0, x1, y1, cx1, cy1 float64, styleStr string) {\n\t// f.point(x0, y0)\n\t// f.outf(\"%.5f %.5f %.5f %.5f %.5f %.5f c %s\", cx0*f.k, (f.h-cy0)*f.k,\n\t// cx1*f.k, (f.h-cy1)*f.k, x1*f.k, (f.h-y1)*f.k, fillDrawOp(styleStr))\n\tf.CurveBezierCubic(x0, y0, cx0, cy0, cx1, cy1, x1, y1, styleStr)\n}\n\n// CurveBezierCubic draws a single-segment cubic Bézier curve. The curve starts at\n// the point (x0, y0) and ends at the point (x1, y1). The control points (cx0,\n// cy0) and (cx1, cy1) specify the curvature. At the start point, the curve is\n// tangent to the straight line between the start point and the control point\n// (cx0, cy0). At the end point, the curve is tangent to the straight line\n// between the end point and the control point (cx1, cy1).\n//\n// styleStr can be \"F\" for filled, \"D\" for outlined only, or \"DF\" or \"FD\" for\n// outlined and filled. An empty string will be replaced with \"D\". Drawing uses\n// the current draw color, line width, and cap style centered on the curve's\n// path. Filling uses the current fill color.\n//\n// This routine performs the same function as CurveCubic() but uses standard\n// argument order.\n//\n// The Circle() example demonstrates this method.\nfunc (f *Fpdf) CurveBezierCubic(x0, y0, cx0, cy0, cx1, cy1, x1, y1 float64, styleStr string) {\n\tf.point(x0, y0)\n\tf.outf(\"%.5f %.5f %.5f %.5f %.5f %.5f c %s\", cx0*f.k, (f.h-cy0)*f.k,\n\t\tcx1*f.k, (f.h-cy1)*f.k, x1*f.k, (f.h-y1)*f.k, fillDrawOp(styleStr))\n}\n\n// Arc draws an elliptical arc centered at point (x, y). rx and ry specify its\n// horizontal and vertical radii.\n//\n// degRotate specifies the angle that the arc will be rotated. degStart and\n// degEnd specify the starting and ending angle of the arc. All angles are\n// specified in degrees and measured counter-clockwise from the 3 o'clock\n// position.\n//\n// styleStr can be \"F\" for filled, \"D\" for outlined only, or \"DF\" or \"FD\" for\n// outlined and filled. An empty string will be replaced with \"D\". Drawing uses\n// the current draw color, line width, and cap style centered on the arc's\n// path. Filling uses the current fill color.\n//\n// The Circle() example demonstrates this method.\nfunc (f *Fpdf) Arc(x, y, rx, ry, degRotate, degStart, degEnd float64, styleStr string) {\n\tf.arc(x, y, rx, ry, degRotate, degStart, degEnd, styleStr, false)\n}\n\n// GetAlpha returns the alpha blending channel, which consists of the\n// alpha transparency value and the blend mode. See SetAlpha for more\n// details.\nfunc (f *Fpdf) GetAlpha() (alpha float64, blendModeStr string) {\n\treturn f.alpha, f.blendMode\n}\n\n// SetAlpha sets the alpha blending channel. The blending effect applies to\n// text, drawings and images.\n//\n// alpha must be a value between 0.0 (fully transparent) to 1.0 (fully opaque).\n// Values outside of this range result in an error.\n//\n// blendModeStr must be one of \"Normal\", \"Multiply\", \"Screen\", \"Overlay\",\n// \"Darken\", \"Lighten\", \"ColorDodge\", \"ColorBurn\",\"HardLight\", \"SoftLight\",\n// \"Difference\", \"Exclusion\", \"Hue\", \"Saturation\", \"Color\", or \"Luminosity\". An\n// empty string is replaced with \"Normal\".\n//\n// To reset normal rendering after applying a blending mode, call this method\n// with alpha set to 1.0 and blendModeStr set to \"Normal\".\nfunc (f *Fpdf) SetAlpha(alpha float64, blendModeStr string) {\n\tif f.err != nil {\n\t\treturn\n\t}\n\tvar bl blendModeType\n\tswitch blendModeStr {\n\tcase \"Normal\", \"Multiply\", \"Screen\", \"Overlay\",\n\t\t\"Darken\", \"Lighten\", \"ColorDodge\", \"ColorBurn\", \"HardLight\", \"SoftLight\",\n\t\t\"Difference\", \"Exclusion\", \"Hue\", \"Saturation\", \"Color\", \"Luminosity\":\n\t\tbl.modeStr = blendModeStr\n\tcase \"\":\n\t\tbl.modeStr = \"Normal\"\n\tdefault:\n\t\tf.err = fmt.Errorf(\"unrecognized blend mode \\\"%s\\\"\", blendModeStr)\n\t\treturn\n\t}\n\tif alpha < 0.0 || alpha > 1.0 {\n\t\tf.err = fmt.Errorf(\"alpha value (0.0 - 1.0) is out of range: %.3f\", alpha)\n\t\treturn\n\t}\n\tf.alpha = alpha\n\tf.blendMode = blendModeStr\n\talphaStr := sprintf(\"%.3f\", alpha)\n\tkeyStr := sprintf(\"%s %s\", alphaStr, blendModeStr)\n\tpos, ok := f.blendMap[keyStr]\n\tif !ok {\n\t\tpos = len(f.blendList) // at least 1\n\t\tf.blendList = append(f.blendList, blendModeType{alphaStr, alphaStr, blendModeStr, 0})\n\t\tf.blendMap[keyStr] = pos\n\t}\n\tf.outf(\"/GS%d gs\", pos)\n}\n\nfunc (f *Fpdf) gradientClipStart(x, y, w, h float64) {\n\t// Save current graphic state and set clipping area\n\tf.outf(\"q %.2f %.2f %.2f %.2f re W n\", x*f.k, (f.h-y)*f.k, w*f.k, -h*f.k)\n\t// Set up transformation matrix for gradient\n\tf.outf(\"%.5f 0 0 %.5f %.5f %.5f cm\", w*f.k, h*f.k, x*f.k, (f.h-(y+h))*f.k)\n}\n\nfunc (f *Fpdf) gradientClipEnd() {\n\t// Restore previous graphic state\n\tf.out(\"Q\")\n}\n\nfunc (f *Fpdf) gradient(tp, r1, g1, b1, r2, g2, b2 int, x1, y1, x2, y2, r float64) {\n\tpos := len(f.gradientList)\n\tclr1 := rgbColorValue(r1, g1, b1, \"\", \"\")\n\tclr2 := rgbColorValue(r2, g2, b2, \"\", \"\")\n\tf.gradientList = append(f.gradientList, gradientType{tp, clr1.str, clr2.str,\n\t\tx1, y1, x2, y2, r, 0})\n\tf.outf(\"/Sh%d sh\", pos)\n}\n\n// LinearGradient draws a rectangular area with a blending of one color to\n// another. The rectangle is of width w and height h. Its upper left corner is\n// positioned at point (x, y).\n//\n// Each color is specified with three component values, one each for red, green\n// and blue. The values range from 0 to 255. The first color is specified by\n// (r1, g1, b1) and the second color by (r2, g2, b2).\n//\n// The blending is controlled with a gradient vector that uses normalized\n// coordinates in which the lower left corner is position (0, 0) and the upper\n// right corner is (1, 1). The vector's origin and destination are specified by\n// the points (x1, y1) and (x2, y2). In a linear gradient, blending occurs\n// perpendicularly to the vector. The vector does not necessarily need to be\n// anchored on the rectangle edge. Color 1 is used up to the origin of the\n// vector and color 2 is used beyond the vector's end point. Between the points\n// the colors are gradually blended.\nfunc (f *Fpdf) LinearGradient(x, y, w, h float64, r1, g1, b1, r2, g2, b2 int, x1, y1, x2, y2 float64) {\n\tf.gradientClipStart(x, y, w, h)\n\tf.gradient(2, r1, g1, b1, r2, g2, b2, x1, y1, x2, y2, 0)\n\tf.gradientClipEnd()\n}\n\n// RadialGradient draws a rectangular area with a blending of one color to\n// another. The rectangle is of width w and height h. Its upper left corner is\n// positioned at point (x, y).\n//\n// Each color is specified with three component values, one each for red, green\n// and blue. The values range from 0 to 255. The first color is specified by\n// (r1, g1, b1) and the second color by (r2, g2, b2).\n//\n// The blending is controlled with a point and a circle, both specified with\n// normalized coordinates in which the lower left corner of the rendered\n// rectangle is position (0, 0) and the upper right corner is (1, 1). Color 1\n// begins at the origin point specified by (x1, y1). Color 2 begins at the\n// circle specified by the center point (x2, y2) and radius r. Colors are\n// gradually blended from the origin to the circle. The origin and the circle's\n// center do not necessarily have to coincide, but the origin must be within\n// the circle to avoid rendering problems.\n//\n// The LinearGradient() example demonstrates this method.\nfunc (f *Fpdf) RadialGradient(x, y, w, h float64, r1, g1, b1, r2, g2, b2 int, x1, y1, x2, y2, r float64) {\n\tf.gradientClipStart(x, y, w, h)\n\tf.gradient(3, r1, g1, b1, r2, g2, b2, x1, y1, x2, y2, r)\n\tf.gradientClipEnd()\n}\n\n// ClipRect begins a rectangular clipping operation. The rectangle is of width\n// w and height h. Its upper left corner is positioned at point (x, y). outline\n// is true to draw a border with the current draw color and line width centered\n// on the rectangle's perimeter. Only the outer half of the border will be\n// shown. After calling this method, all rendering operations (for example,\n// Image(), LinearGradient(), etc) will be clipped by the specified rectangle.\n// Call ClipEnd() to restore unclipped operations.\n//\n// This ClipText() example demonstrates this method.\nfunc (f *Fpdf) ClipRect(x, y, w, h float64, outline bool) {\n\tf.clipNest++\n\tf.outf(\"q %.2f %.2f %.2f %.2f re W %s\", x*f.k, (f.h-y)*f.k, w*f.k, -h*f.k, strIf(outline, \"S\", \"n\"))\n}\n\n// ClipText begins a clipping operation in which rendering is confined to the\n// character string specified by txtStr. The origin (x, y) is on the left of\n// the first character at the baseline. The current font is used. outline is\n// true to draw a border with the current draw color and line width centered on\n// the perimeters of the text characters. Only the outer half of the border\n// will be shown. After calling this method, all rendering operations (for\n// example, Image(), LinearGradient(), etc) will be clipped. Call ClipEnd() to\n// restore unclipped operations.\nfunc (f *Fpdf) ClipText(x, y float64, txtStr string, outline bool) {\n\tf.clipNest++\n\tf.outf(\"q BT %.5f %.5f Td %d Tr (%s) Tj ET\", x*f.k, (f.h-y)*f.k, intIf(outline, 5, 7), f.escape(txtStr))\n}\n\nfunc (f *Fpdf) clipArc(x1, y1, x2, y2, x3, y3 float64) {\n\th := f.h\n\tf.outf(\"%.5f %.5f %.5f %.5f %.5f %.5f c \", x1*f.k, (h-y1)*f.k,\n\t\tx2*f.k, (h-y2)*f.k, x3*f.k, (h-y3)*f.k)\n}\n\n// ClipRoundedRect begins a rectangular clipping operation. The rectangle is of\n// width w and height h. Its upper left corner is positioned at point (x, y).\n// The rounded corners of the rectangle are specified by radius r. outline is\n// true to draw a border with the current draw color and line width centered on\n// the rectangle's perimeter. Only the outer half of the border will be shown.\n// After calling this method, all rendering operations (for example, Image(),\n// LinearGradient(), etc) will be clipped by the specified rectangle. Call\n// ClipEnd() to restore unclipped operations.\n//\n// This ClipText() example demonstrates this method.\nfunc (f *Fpdf) ClipRoundedRect(x, y, w, h, r float64, outline bool) {\n\tf.ClipRoundedRectExt(x, y, w, h, r, r, r, r, outline)\n}\n\n// ClipRoundedRectExt behaves the same as ClipRoundedRect() but supports a\n// different radius for each corner, given by rTL (top-left), rTR (top-right)\n// rBR (bottom-right), rBL (bottom-left). See ClipRoundedRect() for more\n// details. This method is demonstrated in the ClipText() example.\nfunc (f *Fpdf) ClipRoundedRectExt(x, y, w, h, rTL, rTR, rBR, rBL float64, outline bool) {\n\tf.clipNest++\n\tf.roundedRectPath(x, y, w, h, rTL, rTR, rBR, rBL)\n\tf.outf(\" W %s\", strIf(outline, \"S\", \"n\"))\n}\n\n// add a rectangle path with rounded corners.\n// routine shared by RoundedRect() and ClipRoundedRect(), which add the\n// drawing operation\nfunc (f *Fpdf) roundedRectPath(x, y, w, h, rTL, rTR, rBR, rBL float64) {\n\tk := f.k\n\thp := f.h\n\tmyArc := (4.0 / 3.0) * (math.Sqrt2 - 1.0)\n\tf.outf(\"q %.5f %.5f m\", (x+rTL)*k, (hp-y)*k)\n\txc := x + w - rTR\n\tyc := y + rTR\n\tf.outf(\"%.5f %.5f l\", xc*k, (hp-y)*k)\n\tif rTR != 0 {\n\t\tf.clipArc(xc+rTR*myArc, yc-rTR, xc+rTR, yc-rTR*myArc, xc+rTR, yc)\n\t}\n\txc = x + w - rBR\n\tyc = y + h - rBR\n\tf.outf(\"%.5f %.5f l\", (x+w)*k, (hp-yc)*k)\n\tif rBR != 0 {\n\t\tf.clipArc(xc+rBR, yc+rBR*myArc, xc+rBR*myArc, yc+rBR, xc, yc+rBR)\n\t}\n\txc = x + rBL\n\tyc = y + h - rBL\n\tf.outf(\"%.5f %.5f l\", xc*k, (hp-(y+h))*k)\n\tif rBL != 0 {\n\t\tf.clipArc(xc-rBL*myArc, yc+rBL, xc-rBL, yc+rBL*myArc, xc-rBL, yc)\n\t}\n\txc = x + rTL\n\tyc = y + rTL\n\tf.outf(\"%.5f %.5f l\", x*k, (hp-yc)*k)\n\tif rTL != 0 {\n\t\tf.clipArc(xc-rTL, yc-rTL*myArc, xc-rTL*myArc, yc-rTL, xc, yc-rTL)\n\t}\n}\n\n// ClipEllipse begins an elliptical clipping operation. The ellipse is centered\n// at (x, y). Its horizontal and vertical radii are specified by rx and ry.\n// outline is true to draw a border with the current draw color and line width\n// centered on the ellipse's perimeter. Only the outer half of the border will\n// be shown. After calling this method, all rendering operations (for example,\n// Image(), LinearGradient(), etc) will be clipped by the specified ellipse.\n// Call ClipEnd() to restore unclipped operations.\n//\n// This ClipText() example demonstrates this method.\nfunc (f *Fpdf) ClipEllipse(x, y, rx, ry float64, outline bool) {\n\tf.clipNest++\n\tlx := (4.0 / 3.0) * rx * (math.Sqrt2 - 1)\n\tly := (4.0 / 3.0) * ry * (math.Sqrt2 - 1)\n\tk := f.k\n\th := f.h\n\tf.outf(\"q %.5f %.5f m %.5f %.5f %.5f %.5f %.5f %.5f c\",\n\t\t(x+rx)*k, (h-y)*k,\n\t\t(x+rx)*k, (h-(y-ly))*k,\n\t\t(x+lx)*k, (h-(y-ry))*k,\n\t\tx*k, (h-(y-ry))*k)\n\tf.outf(\"%.5f %.5f %.5f %.5f %.5f %.5f c\",\n\t\t(x-lx)*k, (h-(y-ry))*k,\n\t\t(x-rx)*k, (h-(y-ly))*k,\n\t\t(x-rx)*k, (h-y)*k)\n\tf.outf(\"%.5f %.5f %.5f %.5f %.5f %.5f c\",\n\t\t(x-rx)*k, (h-(y+ly))*k,\n\t\t(x-lx)*k, (h-(y+ry))*k,\n\t\tx*k, (h-(y+ry))*k)\n\tf.outf(\"%.5f %.5f %.5f %.5f %.5f %.5f c W %s\",\n\t\t(x+lx)*k, (h-(y+ry))*k,\n\t\t(x+rx)*k, (h-(y+ly))*k,\n\t\t(x+rx)*k, (h-y)*k,\n\t\tstrIf(outline, \"S\", \"n\"))\n}\n\n// ClipCircle begins a circular clipping operation. The circle is centered at\n// (x, y) and has radius r. outline is true to draw a border with the current\n// draw color and line width centered on the circle's perimeter. Only the outer\n// half of the border will be shown. After calling this method, all rendering\n// operations (for example, Image(), LinearGradient(), etc) will be clipped by\n// the specified circle. Call ClipEnd() to restore unclipped operations.\n//\n// The ClipText() example demonstrates this method.\nfunc (f *Fpdf) ClipCircle(x, y, r float64, outline bool) {\n\tf.ClipEllipse(x, y, r, r, outline)\n}\n\n// ClipPolygon begins a clipping operation within a polygon. The figure is\n// defined by a series of vertices specified by points. The x and y fields of\n// the points use the units established in New(). The last point in the slice\n// will be implicitly joined to the first to close the polygon. outline is true\n// to draw a border with the current draw color and line width centered on the\n// polygon's perimeter. Only the outer half of the border will be shown. After\n// calling this method, all rendering operations (for example, Image(),\n// LinearGradient(), etc) will be clipped by the specified polygon. Call\n// ClipEnd() to restore unclipped operations.\n//\n// The ClipText() example demonstrates this method.\nfunc (f *Fpdf) ClipPolygon(points []PointType, outline bool) {\n\tf.clipNest++\n\tvar s fmtBuffer\n\th := f.h\n\tk := f.k\n\ts.printf(\"q \")\n\tfor j, pt := range points {\n\t\ts.printf(\"%.5f %.5f %s \", pt.X*k, (h-pt.Y)*k, strIf(j == 0, \"m\", \"l\"))\n\t}\n\ts.printf(\"h W %s\", strIf(outline, \"S\", \"n\"))\n\tf.out(s.String())\n}\n\n// ClipEnd ends a clipping operation that was started with a call to\n// ClipRect(), ClipRoundedRect(), ClipText(), ClipEllipse(), ClipCircle() or\n// ClipPolygon(). Clipping operations can be nested. The document cannot be\n// successfully output while a clipping operation is active.\n//\n// The ClipText() example demonstrates this method.\nfunc (f *Fpdf) ClipEnd() {\n\tif f.err == nil {\n\t\tif f.clipNest > 0 {\n\t\t\tf.clipNest--\n\t\t\tf.out(\"Q\")\n\t\t} else {\n\t\t\tf.err = fmt.Errorf(\"error attempting to end clip operation out of sequence\")\n\t\t}\n\t}\n}\n\n// AddFont imports a TrueType, OpenType or Type1 font and makes it available.\n// It is necessary to generate a font definition file first with the makefont\n// utility. It is not necessary to call this function for the core PDF fonts\n// (courier, helvetica, times, zapfdingbats).\n//\n// The JSON definition file (and the font file itself when embedding) must be\n// present in the font directory. If it is not found, the error \"Could not\n// include font definition file\" is set.\n//\n// family specifies the font family. The name can be chosen arbitrarily. If it\n// is a standard family name, it will override the corresponding font. This\n// string is used to subsequently set the font with the SetFont method.\n//\n// style specifies the font style. Acceptable values are (case insensitive) the\n// empty string for regular style, \"B\" for bold, \"I\" for italic, or \"BI\" or\n// \"IB\" for bold and italic combined.\n//\n// fileStr specifies the base name with \".json\" extension of the font\n// definition file to be added. The file will be loaded from the font directory\n// specified in the call to New() or SetFontLocation().\nfunc (f *Fpdf) AddFont(familyStr, styleStr, fileStr string) {\n\tf.addFont(fontFamilyEscape(familyStr), styleStr, fileStr, false)\n}\n\n// AddUTF8Font imports a TrueType font with utf-8 symbols and makes it available.\n// It is necessary to generate a font definition file first with the makefont\n// utility. It is not necessary to call this function for the core PDF fonts\n// (courier, helvetica, times, zapfdingbats).\n//\n// The JSON definition file (and the font file itself when embedding) must be\n// present in the font directory. If it is not found, the error \"Could not\n// include font definition file\" is set.\n//\n// family specifies the font family. The name can be chosen arbitrarily. If it\n// is a standard family name, it will override the corresponding font. This\n// string is used to subsequently set the font with the SetFont method.\n//\n// style specifies the font style. Acceptable values are (case insensitive) the\n// empty string for regular style, \"B\" for bold, \"I\" for italic, or \"BI\" or\n// \"IB\" for bold and italic combined.\n//\n// fileStr specifies the base name with \".json\" extension of the font\n// definition file to be added. The file will be loaded from the font directory\n// specified in the call to New() or SetFontLocation().\nfunc (f *Fpdf) AddUTF8Font(familyStr, styleStr, fileStr string) {\n\tf.addFont(fontFamilyEscape(familyStr), styleStr, fileStr, true)\n}\n\nfunc (f *Fpdf) addFont(familyStr, styleStr, fileStr string, isUTF8 bool) {\n\tif fileStr == \"\" {\n\t\tif isUTF8 {\n\t\t\tfileStr = strings.Replace(familyStr, \" \", \"\", -1) + strings.ToLower(styleStr) + \".ttf\"\n\t\t} else {\n\t\t\tfileStr = strings.Replace(familyStr, \" \", \"\", -1) + strings.ToLower(styleStr) + \".json\"\n\t\t}\n\t}\n\tif isUTF8 {\n\t\tfontKey := getFontKey(familyStr, styleStr)\n\t\t_, ok := f.fonts[fontKey]\n\t\tif ok {\n\t\t\treturn\n\t\t}\n\t\tvar ttfStat os.FileInfo\n\t\tvar err error\n\t\tfileStr = path.Join(f.fontpath, fileStr)\n\t\tttfStat, err = os.Stat(fileStr)\n\t\tif err != nil {\n\t\t\tf.SetError(err)\n\t\t\treturn\n\t\t}\n\t\toriginalSize := ttfStat.Size()\n\t\tType := \"UTF8\"\n\t\tvar utf8Bytes []byte\n\t\tutf8Bytes, err = ioutil.ReadFile(fileStr)\n\t\tif err != nil {\n\t\t\tf.SetError(err)\n\t\t\treturn\n\t\t}\n\t\treader := fileReader{readerPosition: 0, array: utf8Bytes}\n\t\tutf8File := newUTF8Font(&reader)\n\t\terr = utf8File.parseFile()\n\t\tif err != nil {\n\t\t\tf.SetError(err)\n\t\t\treturn\n\t\t}\n\n\t\tdesc := FontDescType{\n\t\t\tAscent:       int(utf8File.Ascent),\n\t\t\tDescent:      int(utf8File.Descent),\n\t\t\tCapHeight:    utf8File.CapHeight,\n\t\t\tFlags:        utf8File.Flags,\n\t\t\tFontBBox:     utf8File.Bbox,\n\t\t\tItalicAngle:  utf8File.ItalicAngle,\n\t\t\tStemV:        utf8File.StemV,\n\t\t\tMissingWidth: round(utf8File.DefaultWidth),\n\t\t}\n\n\t\tvar sbarr map[int]int\n\t\tif f.aliasNbPagesStr == \"\" {\n\t\t\tsbarr = makeSubsetRange(57)\n\t\t} else {\n\t\t\tsbarr = makeSubsetRange(32)\n\t\t}\n\t\tdef := fontDefType{\n\t\t\tTp:        Type,\n\t\t\tName:      fontKey,\n\t\t\tDesc:      desc,\n\t\t\tUp:        int(round(utf8File.UnderlinePosition)),\n\t\t\tUt:        round(utf8File.UnderlineThickness),\n\t\t\tCw:        utf8File.CharWidths,\n\t\t\tusedRunes: sbarr,\n\t\t\tFile:      fileStr,\n\t\t\tutf8File:  utf8File,\n\t\t}\n\t\tdef.i, _ = generateFontID(def)\n\t\tf.fonts[fontKey] = def\n\t\tf.fontFiles[fontKey] = fontFileType{\n\t\t\tlength1:  originalSize,\n\t\t\tfontType: \"UTF8\",\n\t\t}\n\t\tf.fontFiles[fileStr] = fontFileType{\n\t\t\tfontType: \"UTF8\",\n\t\t}\n\t} else {\n\t\tif f.fontLoader != nil {\n\t\t\treader, err := f.fontLoader.Open(fileStr)\n\t\t\tif err == nil {\n\t\t\t\tf.AddFontFromReader(familyStr, styleStr, reader)\n\t\t\t\tif closer, ok := reader.(io.Closer); ok {\n\t\t\t\t\tcloser.Close()\n\t\t\t\t}\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\n\t\tfileStr = path.Join(f.fontpath, fileStr)\n\t\tfile, err := os.Open(fileStr)\n\t\tif err != nil {\n\t\t\tf.err = err\n\t\t\treturn\n\t\t}\n\t\tdefer file.Close()\n\n\t\tf.AddFontFromReader(familyStr, styleStr, file)\n\t}\n}\n\nfunc makeSubsetRange(end int) map[int]int {\n\tanswer := make(map[int]int)\n\tfor i := 0; i < end; i++ {\n\t\tanswer[i] = 0\n\t}\n\treturn answer\n}\n\n// AddFontFromBytes imports a TrueType, OpenType or Type1 font from static\n// bytes within the executable and makes it available for use in the generated\n// document.\n//\n// family specifies the font family. The name can be chosen arbitrarily. If it\n// is a standard family name, it will override the corresponding font. This\n// string is used to subsequently set the font with the SetFont method.\n//\n// style specifies the font style. Acceptable values are (case insensitive) the\n// empty string for regular style, \"B\" for bold, \"I\" for italic, or \"BI\" or\n// \"IB\" for bold and italic combined.\n//\n// jsonFileBytes contain all bytes of JSON file.\n//\n// zFileBytes contain all bytes of Z file.\nfunc (f *Fpdf) AddFontFromBytes(familyStr, styleStr string, jsonFileBytes, zFileBytes []byte) {\n\tf.addFontFromBytes(fontFamilyEscape(familyStr), styleStr, jsonFileBytes, zFileBytes, nil)\n}\n\n// AddUTF8FontFromBytes  imports a TrueType font with utf-8 symbols from static\n// bytes within the executable and makes it available for use in the generated\n// document.\n//\n// family specifies the font family. The name can be chosen arbitrarily. If it\n// is a standard family name, it will override the corresponding font. This\n// string is used to subsequently set the font with the SetFont method.\n//\n// style specifies the font style. Acceptable values are (case insensitive) the\n// empty string for regular style, \"B\" for bold, \"I\" for italic, or \"BI\" or\n// \"IB\" for bold and italic combined.\n//\n// jsonFileBytes contain all bytes of JSON file.\n//\n// zFileBytes contain all bytes of Z file.\nfunc (f *Fpdf) AddUTF8FontFromBytes(familyStr, styleStr string, utf8Bytes []byte) {\n\tf.addFontFromBytes(fontFamilyEscape(familyStr), styleStr, nil, nil, utf8Bytes)\n}\n\nfunc (f *Fpdf) addFontFromBytes(familyStr, styleStr string, jsonFileBytes, zFileBytes, utf8Bytes []byte) {\n\tif f.err != nil {\n\t\treturn\n\t}\n\n\t// load font key\n\tvar ok bool\n\tfontkey := getFontKey(familyStr, styleStr)\n\t_, ok = f.fonts[fontkey]\n\n\tif ok {\n\t\treturn\n\t}\n\n\tif utf8Bytes != nil {\n\n\t\t// if styleStr == \"IB\" {\n\t\t// \tstyleStr = \"BI\"\n\t\t// }\n\n\t\tType := \"UTF8\"\n\t\treader := fileReader{readerPosition: 0, array: utf8Bytes}\n\n\t\tutf8File := newUTF8Font(&reader)\n\n\t\terr := utf8File.parseFile()\n\t\tif err != nil {\n\t\t\tfmt.Printf(\"get metrics Error: %e\\n\", err)\n\t\t\treturn\n\t\t}\n\t\tdesc := FontDescType{\n\t\t\tAscent:       int(utf8File.Ascent),\n\t\t\tDescent:      int(utf8File.Descent),\n\t\t\tCapHeight:    utf8File.CapHeight,\n\t\t\tFlags:        utf8File.Flags,\n\t\t\tFontBBox:     utf8File.Bbox,\n\t\t\tItalicAngle:  utf8File.ItalicAngle,\n\t\t\tStemV:        utf8File.StemV,\n\t\t\tMissingWidth: round(utf8File.DefaultWidth),\n\t\t}\n\n\t\tvar sbarr map[int]int\n\t\tif f.aliasNbPagesStr == \"\" {\n\t\t\tsbarr = makeSubsetRange(57)\n\t\t} else {\n\t\t\tsbarr = makeSubsetRange(32)\n\t\t}\n\t\tdef := fontDefType{\n\t\t\tTp:        Type,\n\t\t\tName:      fontkey,\n\t\t\tDesc:      desc,\n\t\t\tUp:        int(round(utf8File.UnderlinePosition)),\n\t\t\tUt:        round(utf8File.UnderlineThickness),\n\t\t\tCw:        utf8File.CharWidths,\n\t\t\tutf8File:  utf8File,\n\t\t\tusedRunes: sbarr,\n\t\t}\n\t\tdef.i, _ = generateFontID(def)\n\t\tf.fonts[fontkey] = def\n\t} else {\n\t\t// load font definitions\n\t\tvar info fontDefType\n\t\terr := json.Unmarshal(jsonFileBytes, &info)\n\n\t\tif err != nil {\n\t\t\tf.err = err\n\t\t}\n\n\t\tif f.err != nil {\n\t\t\treturn\n\t\t}\n\n\t\tif info.i, err = generateFontID(info); err != nil {\n\t\t\tf.err = err\n\t\t\treturn\n\t\t}\n\n\t\t// search existing encodings\n\t\tif len(info.Diff) > 0 {\n\t\t\tn := -1\n\n\t\t\tfor j, str := range f.diffs {\n\t\t\t\tif str == info.Diff {\n\t\t\t\t\tn = j + 1\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif n < 0 {\n\t\t\t\tf.diffs = append(f.diffs, info.Diff)\n\t\t\t\tn = len(f.diffs)\n\t\t\t}\n\n\t\t\tinfo.DiffN = n\n\t\t}\n\n\t\t// embed font\n\t\tif len(info.File) > 0 {\n\t\t\tif info.Tp == \"TrueType\" {\n\t\t\t\tf.fontFiles[info.File] = fontFileType{\n\t\t\t\t\tlength1:  int64(info.OriginalSize),\n\t\t\t\t\tembedded: true,\n\t\t\t\t\tcontent:  zFileBytes,\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tf.fontFiles[info.File] = fontFileType{\n\t\t\t\t\tlength1:  int64(info.Size1),\n\t\t\t\t\tlength2:  int64(info.Size2),\n\t\t\t\t\tembedded: true,\n\t\t\t\t\tcontent:  zFileBytes,\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tf.fonts[fontkey] = info\n\t}\n}\n\n// getFontKey is used by AddFontFromReader and GetFontDesc\nfunc getFontKey(familyStr, styleStr string) string {\n\tfamilyStr = strings.ToLower(familyStr)\n\tstyleStr = strings.ToUpper(styleStr)\n\tif styleStr == \"IB\" {\n\t\tstyleStr = \"BI\"\n\t}\n\treturn familyStr + styleStr\n}\n\n// AddFontFromReader imports a TrueType, OpenType or Type1 font and makes it\n// available using a reader that satisifies the io.Reader interface. See\n// AddFont for details about familyStr and styleStr.\nfunc (f *Fpdf) AddFontFromReader(familyStr, styleStr string, r io.Reader) {\n\tif f.err != nil {\n\t\treturn\n\t}\n\t// dbg(\"Adding family [%s], style [%s]\", familyStr, styleStr)\n\tfamilyStr = fontFamilyEscape(familyStr)\n\tvar ok bool\n\tfontkey := getFontKey(familyStr, styleStr)\n\t_, ok = f.fonts[fontkey]\n\tif ok {\n\t\treturn\n\t}\n\tvar info fontDefType\n\tinfo = f.loadfont(r)\n\tif f.err != nil {\n\t\treturn\n\t}\n\tif len(info.Diff) > 0 {\n\t\t// Search existing encodings\n\t\tn := -1\n\t\tfor j, str := range f.diffs {\n\t\t\tif str == info.Diff {\n\t\t\t\tn = j + 1\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif n < 0 {\n\t\t\tf.diffs = append(f.diffs, info.Diff)\n\t\t\tn = len(f.diffs)\n\t\t}\n\t\tinfo.DiffN = n\n\t}\n\t// dbg(\"font [%s], type [%s]\", info.File, info.Tp)\n\tif len(info.File) > 0 {\n\t\t// Embedded font\n\t\tif info.Tp == \"TrueType\" {\n\t\t\tf.fontFiles[info.File] = fontFileType{length1: int64(info.OriginalSize)}\n\t\t} else {\n\t\t\tf.fontFiles[info.File] = fontFileType{length1: int64(info.Size1), length2: int64(info.Size2)}\n\t\t}\n\t}\n\tf.fonts[fontkey] = info\n\treturn\n}\n\n// GetFontDesc returns the font descriptor, which can be used for\n// example to find the baseline of a font. If familyStr is empty\n// current font descriptor will be returned.\n// See FontDescType for documentation about the font descriptor.\n// See AddFont for details about familyStr and styleStr.\nfunc (f *Fpdf) GetFontDesc(familyStr, styleStr string) FontDescType {\n\tif familyStr == \"\" {\n\t\treturn f.currentFont.Desc\n\t}\n\treturn f.fonts[getFontKey(fontFamilyEscape(familyStr), styleStr)].Desc\n}\n\n// SetFont sets the font used to print character strings. It is mandatory to\n// call this method at least once before printing text or the resulting\n// document will not be valid.\n//\n// The font can be either a standard one or a font added via the AddFont()\n// method or AddFontFromReader() method. Standard fonts use the Windows\n// encoding cp1252 (Western Europe).\n//\n// The method can be called before the first page is created and the font is\n// kept from page to page. If you just wish to change the current font size, it\n// is simpler to call SetFontSize().\n//\n// Note: the font definition file must be accessible. An error is set if the\n// file cannot be read.\n//\n// familyStr specifies the font family. It can be either a name defined by\n// AddFont(), AddFontFromReader() or one of the standard families (case\n// insensitive): \"Courier\" for fixed-width, \"Helvetica\" or \"Arial\" for sans\n// serif, \"Times\" for serif, \"Symbol\" or \"ZapfDingbats\" for symbolic.\n//\n// styleStr can be \"B\" (bold), \"I\" (italic), \"U\" (underscore), \"S\" (strike-out)\n// or any combination. The default value (specified with an empty string) is\n// regular. Bold and italic styles do not apply to Symbol and ZapfDingbats.\n//\n// size is the font size measured in points. The default value is the current\n// size. If no size has been specified since the beginning of the document, the\n// value taken is 12.\nfunc (f *Fpdf) SetFont(familyStr, styleStr string, size float64) {\n\t// dbg(\"SetFont x %.2f, lMargin %.2f\", f.x, f.lMargin)\n\n\tif f.err != nil {\n\t\treturn\n\t}\n\t// dbg(\"SetFont\")\n\tfamilyStr = fontFamilyEscape(familyStr)\n\tvar ok bool\n\tif familyStr == \"\" {\n\t\tfamilyStr = f.fontFamily\n\t} else {\n\t\tfamilyStr = strings.ToLower(familyStr)\n\t}\n\tstyleStr = strings.ToUpper(styleStr)\n\tf.underline = strings.Contains(styleStr, \"U\")\n\tif f.underline {\n\t\tstyleStr = strings.Replace(styleStr, \"U\", \"\", -1)\n\t}\n\tf.strikeout = strings.Contains(styleStr, \"S\")\n\tif f.strikeout {\n\t\tstyleStr = strings.Replace(styleStr, \"S\", \"\", -1)\n\t}\n\tif styleStr == \"IB\" {\n\t\tstyleStr = \"BI\"\n\t}\n\tif size == 0.0 {\n\t\tsize = f.fontSizePt\n\t}\n\n\t// Test if font is already loaded\n\tfontKey := familyStr + styleStr\n\t_, ok = f.fonts[fontKey]\n\tif !ok {\n\t\t// Test if one of the core fonts\n\t\tif familyStr == \"arial\" {\n\t\t\tfamilyStr = \"helvetica\"\n\t\t}\n\t\t_, ok = f.coreFonts[familyStr]\n\t\tif ok {\n\t\t\tif familyStr == \"symbol\" {\n\t\t\t\tfamilyStr = \"zapfdingbats\"\n\t\t\t}\n\t\t\tif familyStr == \"zapfdingbats\" {\n\t\t\t\tstyleStr = \"\"\n\t\t\t}\n\t\t\tfontKey = familyStr + styleStr\n\t\t\t_, ok = f.fonts[fontKey]\n\t\t\tif !ok {\n\t\t\t\trdr := f.coreFontReader(familyStr, styleStr)\n\t\t\t\tif f.err == nil {\n\t\t\t\t\tf.AddFontFromReader(familyStr, styleStr, rdr)\n\t\t\t\t}\n\t\t\t\tif f.err != nil {\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tf.err = fmt.Errorf(\"undefined font: %s %s\", familyStr, styleStr)\n\t\t\treturn\n\t\t}\n\t}\n\t// Select it\n\tf.fontFamily = familyStr\n\tf.fontStyle = styleStr\n\tf.fontSizePt = size\n\tf.fontSize = size / f.k\n\tf.currentFont = f.fonts[fontKey]\n\tif f.currentFont.Tp == \"UTF8\" {\n\t\tf.isCurrentUTF8 = true\n\t} else {\n\t\tf.isCurrentUTF8 = false\n\t}\n\tif f.page > 0 {\n\t\tf.outf(\"BT /F%s %.2f Tf ET\", f.currentFont.i, f.fontSizePt)\n\t}\n\treturn\n}\n\n// SetFontStyle sets the style of the current font. See also SetFont()\nfunc (f *Fpdf) SetFontStyle(styleStr string) {\n\tf.SetFont(f.fontFamily, styleStr, f.fontSizePt)\n}\n\n// SetFontSize defines the size of the current font. Size is specified in\n// points (1/ 72 inch). See also SetFontUnitSize().\nfunc (f *Fpdf) SetFontSize(size float64) {\n\tf.fontSizePt = size\n\tf.fontSize = size / f.k\n\tif f.page > 0 {\n\t\tf.outf(\"BT /F%s %.2f Tf ET\", f.currentFont.i, f.fontSizePt)\n\t}\n}\n\n// SetFontUnitSize defines the size of the current font. Size is specified in\n// the unit of measure specified in New(). See also SetFontSize().\nfunc (f *Fpdf) SetFontUnitSize(size float64) {\n\tf.fontSizePt = size * f.k\n\tf.fontSize = size\n\tif f.page > 0 {\n\t\tf.outf(\"BT /F%s %.2f Tf ET\", f.currentFont.i, f.fontSizePt)\n\t}\n}\n\n// GetFontSize returns the size of the current font in points followed by the\n// size in the unit of measure specified in New(). The second value can be used\n// as a line height value in drawing operations.\nfunc (f *Fpdf) GetFontSize() (ptSize, unitSize float64) {\n\treturn f.fontSizePt, f.fontSize\n}\n\n// AddLink creates a new internal link and returns its identifier. An internal\n// link is a clickable area which directs to another place within the document.\n// The identifier can then be passed to Cell(), Write(), Image() or Link(). The\n// destination is defined with SetLink().\nfunc (f *Fpdf) AddLink() int {\n\tf.links = append(f.links, intLinkType{})\n\treturn len(f.links) - 1\n}\n\n// SetLink defines the page and position a link points to. See AddLink().\nfunc (f *Fpdf) SetLink(link int, y float64, page int) {\n\tif y == -1 {\n\t\ty = f.y\n\t}\n\tif page == -1 {\n\t\tpage = f.page\n\t}\n\tf.links[link] = intLinkType{page, y}\n}\n\n// newLink adds a new clickable link on current page\nfunc (f *Fpdf) newLink(x, y, w, h float64, link int, linkStr string) {\n\t// linkList, ok := f.pageLinks[f.page]\n\t// if !ok {\n\t// linkList = make([]linkType, 0, 8)\n\t// f.pageLinks[f.page] = linkList\n\t// }\n\tf.pageLinks[f.page] = append(f.pageLinks[f.page],\n\t\tlinkType{x * f.k, f.hPt - y*f.k, w * f.k, h * f.k, link, linkStr})\n}\n\n// Link puts a link on a rectangular area of the page. Text or image links are\n// generally put via Cell(), Write() or Image(), but this method can be useful\n// for instance to define a clickable area inside an image. link is the value\n// returned by AddLink().\nfunc (f *Fpdf) Link(x, y, w, h float64, link int) {\n\tf.newLink(x, y, w, h, link, \"\")\n}\n\n// LinkString puts a link on a rectangular area of the page. Text or image\n// links are generally put via Cell(), Write() or Image(), but this method can\n// be useful for instance to define a clickable area inside an image. linkStr\n// is the target URL.\nfunc (f *Fpdf) LinkString(x, y, w, h float64, linkStr string) {\n\tf.newLink(x, y, w, h, 0, linkStr)\n}\n\n// Bookmark sets a bookmark that will be displayed in a sidebar outline. txtStr\n// is the title of the bookmark. level specifies the level of the bookmark in\n// the outline; 0 is the top level, 1 is just below, and so on. y specifies the\n// vertical position of the bookmark destination in the current page; -1\n// indicates the current position.\nfunc (f *Fpdf) Bookmark(txtStr string, level int, y float64) {\n\tif y == -1 {\n\t\ty = f.y\n\t}\n\tif f.isCurrentUTF8 {\n\t\ttxtStr = utf8toutf16(txtStr)\n\t}\n\tf.outlines = append(f.outlines, outlineType{text: txtStr, level: level, y: y, p: f.PageNo(), prev: -1, last: -1, next: -1, first: -1})\n}\n\n// Text prints a character string. The origin (x, y) is on the left of the\n// first character at the baseline. This method permits a string to be placed\n// precisely on the page, but it is usually easier to use Cell(), MultiCell()\n// or Write() which are the standard methods to print text.\nfunc (f *Fpdf) Text(x, y float64, txtStr string) {\n\tvar txt2 string\n\tif f.isCurrentUTF8 {\n\t\tif f.isRTL {\n\t\t\ttxtStr = reverseText(txtStr)\n\t\t\tx -= f.GetStringWidth(txtStr)\n\t\t}\n\t\ttxt2 = f.escape(utf8toutf16(txtStr, false))\n\t\tfor _, uni := range []rune(txtStr) {\n\t\t\tf.currentFont.usedRunes[int(uni)] = int(uni)\n\t\t}\n\t} else {\n\t\ttxt2 = f.escape(txtStr)\n\t}\n\ts := sprintf(\"BT %.2f %.2f Td (%s) Tj ET\", x*f.k, (f.h-y)*f.k, txt2)\n\tif f.underline && txtStr != \"\" {\n\t\ts += \" \" + f.dounderline(x, y, txtStr)\n\t}\n\tif f.strikeout && txtStr != \"\" {\n\t\ts += \" \" + f.dostrikeout(x, y, txtStr)\n\t}\n\tif f.colorFlag {\n\t\ts = sprintf(\"q %s %s Q\", f.color.text.str, s)\n\t}\n\tf.out(s)\n}\n\n// SetWordSpacing sets spacing between words of following text. See the\n// WriteAligned() example for a demonstration of its use.\nfunc (f *Fpdf) SetWordSpacing(space float64) {\n\tf.out(sprintf(\"%.5f Tw\", space*f.k))\n}\n\n// SetTextRenderingMode sets the rendering mode of following text.\n// The mode can be as follows:\n// 0: Fill text\n// 1: Stroke text\n// 2: Fill, then stroke text\n// 3: Neither fill nor stroke text (invisible)\n// 4: Fill text and add to path for clipping\n// 5: Stroke text and add to path for clipping\n// 6: Fills then stroke text and add to path for clipping\n// 7: Add text to path for clipping\n// This method is demonstrated in the SetTextRenderingMode example.\nfunc (f *Fpdf) SetTextRenderingMode(mode int) {\n\tif mode >= 0 && mode <= 7 {\n\t\tf.out(sprintf(\"%d Tr\", mode))\n\t}\n}\n\n// SetAcceptPageBreakFunc allows the application to control where page breaks\n// occur.\n//\n// fnc is an application function (typically a closure) that is called by the\n// library whenever a page break condition is met. The break is issued if true\n// is returned. The default implementation returns a value according to the\n// mode selected by SetAutoPageBreak. The function provided should not be\n// called by the application.\n//\n// See the example for SetLeftMargin() to see how this function can be used to\n// manage multiple columns.\nfunc (f *Fpdf) SetAcceptPageBreakFunc(fnc func() bool) {\n\tf.acceptPageBreak = fnc\n}\n\n// CellFormat prints a rectangular cell with optional borders, background color\n// and character string. The upper-left corner of the cell corresponds to the\n// current position. The text can be aligned or centered. After the call, the\n// current position moves to the right or to the next line. It is possible to\n// put a link on the text.\n//\n// An error will be returned if a call to SetFont() has not already taken\n// place before this method is called.\n//\n// If automatic page breaking is enabled and the cell goes beyond the limit, a\n// page break is done before outputting.\n//\n// w and h specify the width and height of the cell. If w is 0, the cell\n// extends up to the right margin. Specifying 0 for h will result in no output,\n// but the current position will be advanced by w.\n//\n// txtStr specifies the text to display.\n//\n// borderStr specifies how the cell border will be drawn. An empty string\n// indicates no border, \"1\" indicates a full border, and one or more of \"L\",\n// \"T\", \"R\" and \"B\" indicate the left, top, right and bottom sides of the\n// border.\n//\n// ln indicates where the current position should go after the call. Possible\n// values are 0 (to the right), 1 (to the beginning of the next line), and 2\n// (below). Putting 1 is equivalent to putting 0 and calling Ln() just after.\n//\n// alignStr specifies how the text is to be positioned within the cell.\n// Horizontal alignment is controlled by including \"L\", \"C\" or \"R\" (left,\n// center, right) in alignStr. Vertical alignment is controlled by including\n// \"T\", \"M\", \"B\" or \"A\" (top, middle, bottom, baseline) in alignStr. The default\n// alignment is left middle.\n//\n// fill is true to paint the cell background or false to leave it transparent.\n//\n// link is the identifier returned by AddLink() or 0 for no internal link.\n//\n// linkStr is a target URL or empty for no external link. A non--zero value for\n// link takes precedence over linkStr.\nfunc (f *Fpdf) CellFormat(w, h float64, txtStr, borderStr string, ln int,\n\talignStr string, fill bool, link int, linkStr string) {\n\t// dbg(\"CellFormat. h = %.2f, borderStr = %s\", h, borderStr)\n\tif f.err != nil {\n\t\treturn\n\t}\n\n\tif f.currentFont.Name == \"\" {\n\t\tf.err = fmt.Errorf(\"font has not been set; unable to render text\")\n\t\treturn\n\t}\n\n\tborderStr = strings.ToUpper(borderStr)\n\tk := f.k\n\tif f.y+h > f.pageBreakTrigger && !f.inHeader && !f.inFooter && f.acceptPageBreak() {\n\t\t// Automatic page break\n\t\tx := f.x\n\t\tws := f.ws\n\t\t// dbg(\"auto page break, x %.2f, ws %.2f\", x, ws)\n\t\tif ws > 0 {\n\t\t\tf.ws = 0\n\t\t\tf.out(\"0 Tw\")\n\t\t}\n\t\tf.AddPageFormat(f.curOrientation, f.curPageSize)\n\t\tif f.err != nil {\n\t\t\treturn\n\t\t}\n\t\tf.x = x\n\t\tif ws > 0 {\n\t\t\tf.ws = ws\n\t\t\tf.outf(\"%.3f Tw\", ws*k)\n\t\t}\n\t}\n\tif w == 0 {\n\t\tw = f.w - f.rMargin - f.x\n\t}\n\tvar s fmtBuffer\n\tif fill || borderStr == \"1\" {\n\t\tvar op string\n\t\tif fill {\n\t\t\tif borderStr == \"1\" {\n\t\t\t\top = \"B\"\n\t\t\t\t// dbg(\"border is '1', fill\")\n\t\t\t} else {\n\t\t\t\top = \"f\"\n\t\t\t\t// dbg(\"border is empty, fill\")\n\t\t\t}\n\t\t} else {\n\t\t\t// dbg(\"border is '1', no fill\")\n\t\t\top = \"S\"\n\t\t}\n\t\t/// dbg(\"(CellFormat) f.x %.2f f.k %.2f\", f.x, f.k)\n\t\ts.printf(\"%.2f %.2f %.2f %.2f re %s \", f.x*k, (f.h-f.y)*k, w*k, -h*k, op)\n\t}\n\tif len(borderStr) > 0 && borderStr != \"1\" {\n\t\t// fmt.Printf(\"border is '%s', no fill\\n\", borderStr)\n\t\tx := f.x\n\t\ty := f.y\n\t\tleft := x * k\n\t\ttop := (f.h - y) * k\n\t\tright := (x + w) * k\n\t\tbottom := (f.h - (y + h)) * k\n\t\tif strings.Contains(borderStr, \"L\") {\n\t\t\ts.printf(\"%.2f %.2f m %.2f %.2f l S \", left, top, left, bottom)\n\t\t}\n\t\tif strings.Contains(borderStr, \"T\") {\n\t\t\ts.printf(\"%.2f %.2f m %.2f %.2f l S \", left, top, right, top)\n\t\t}\n\t\tif strings.Contains(borderStr, \"R\") {\n\t\t\ts.printf(\"%.2f %.2f m %.2f %.2f l S \", right, top, right, bottom)\n\t\t}\n\t\tif strings.Contains(borderStr, \"B\") {\n\t\t\ts.printf(\"%.2f %.2f m %.2f %.2f l S \", left, bottom, right, bottom)\n\t\t}\n\t}\n\tif len(txtStr) > 0 {\n\t\tvar dx, dy float64\n\t\t// Horizontal alignment\n\t\tswitch {\n\t\tcase strings.Contains(alignStr, \"R\"):\n\t\t\tdx = w - f.cMargin - f.GetStringWidth(txtStr)\n\t\tcase strings.Contains(alignStr, \"C\"):\n\t\t\tdx = (w - f.GetStringWidth(txtStr)) / 2\n\t\tdefault:\n\t\t\tdx = f.cMargin\n\t\t}\n\n\t\t// Vertical alignment\n\t\tswitch {\n\t\tcase strings.Contains(alignStr, \"T\"):\n\t\t\tdy = (f.fontSize - h) / 2.0\n\t\tcase strings.Contains(alignStr, \"B\"):\n\t\t\tdy = (h - f.fontSize) / 2.0\n\t\tcase strings.Contains(alignStr, \"A\"):\n\t\t\tvar descent float64\n\t\t\td := f.currentFont.Desc\n\t\t\tif d.Descent == 0 {\n\t\t\t\t// not defined (standard font?), use average of 19%\n\t\t\t\tdescent = -0.19 * f.fontSize\n\t\t\t} else {\n\t\t\t\tdescent = float64(d.Descent) * f.fontSize / float64(d.Ascent-d.Descent)\n\t\t\t}\n\t\t\tdy = (h-f.fontSize)/2.0 - descent\n\t\tdefault:\n\t\t\tdy = 0\n\t\t}\n\t\tif f.colorFlag {\n\t\t\ts.printf(\"q %s \", f.color.text.str)\n\t\t}\n\t\t//If multibyte, Tw has no effect - do word spacing using an adjustment before each space\n\t\tif (f.ws != 0 || alignStr == \"J\") && f.isCurrentUTF8 { // && f.ws != 0\n\t\t\tif f.isRTL {\n\t\t\t\ttxtStr = reverseText(txtStr)\n\t\t\t}\n\t\t\twmax := int(math.Ceil((w - 2*f.cMargin) * 1000 / f.fontSize))\n\t\t\tfor _, uni := range []rune(txtStr) {\n\t\t\t\tf.currentFont.usedRunes[int(uni)] = int(uni)\n\t\t\t}\n\t\t\tspace := f.escape(utf8toutf16(\" \", false))\n\t\t\tstrSize := f.GetStringSymbolWidth(txtStr)\n\t\t\ts.printf(\"BT 0 Tw %.2f %.2f Td [\", (f.x+dx)*k, (f.h-(f.y+.5*h+.3*f.fontSize))*k)\n\t\t\tt := strings.Split(txtStr, \" \")\n\t\t\tshift := float64((wmax - strSize)) / float64(len(t)-1)\n\t\t\tnumt := len(t)\n\t\t\tfor i := 0; i < numt; i++ {\n\t\t\t\ttx := t[i]\n\t\t\t\ttx = \"(\" + f.escape(utf8toutf16(tx, false)) + \")\"\n\t\t\t\ts.printf(\"%s \", tx)\n\t\t\t\tif (i + 1) < numt {\n\t\t\t\t\ts.printf(\"%.3f(%s) \", -shift, space)\n\t\t\t\t}\n\t\t\t}\n\t\t\ts.printf(\"] TJ ET\")\n\t\t} else {\n\t\t\tvar txt2 string\n\t\t\tif f.isCurrentUTF8 {\n\t\t\t\tif f.isRTL {\n\t\t\t\t\ttxtStr = reverseText(txtStr)\n\t\t\t\t}\n\t\t\t\ttxt2 = f.escape(utf8toutf16(txtStr, false))\n\t\t\t\tfor _, uni := range []rune(txtStr) {\n\t\t\t\t\tf.currentFont.usedRunes[int(uni)] = int(uni)\n\t\t\t\t}\n\t\t\t} else {\n\n\t\t\t\ttxt2 = strings.Replace(txtStr, \"\\\\\", \"\\\\\\\\\", -1)\n\t\t\t\ttxt2 = strings.Replace(txt2, \"(\", \"\\\\(\", -1)\n\t\t\t\ttxt2 = strings.Replace(txt2, \")\", \"\\\\)\", -1)\n\t\t\t}\n\t\t\tbt := (f.x + dx) * k\n\t\t\ttd := (f.h - (f.y + dy + .5*h + .3*f.fontSize)) * k\n\t\t\ts.printf(\"BT %.2f %.2f Td (%s)Tj ET\", bt, td, txt2)\n\t\t\t//BT %.2F %.2F Td (%s) Tj ET',(f.x+dx)*k,(f.h-(f.y+.5*h+.3*f.FontSize))*k,txt2);\n\t\t}\n\n\t\tif f.underline {\n\t\t\ts.printf(\" %s\", f.dounderline(f.x+dx, f.y+dy+.5*h+.3*f.fontSize, txtStr))\n\t\t}\n\t\tif f.strikeout {\n\t\t\ts.printf(\" %s\", f.dostrikeout(f.x+dx, f.y+dy+.5*h+.3*f.fontSize, txtStr))\n\t\t}\n\t\tif f.colorFlag {\n\t\t\ts.printf(\" Q\")\n\t\t}\n\t\tif link > 0 || len(linkStr) > 0 {\n\t\t\tf.newLink(f.x+dx, f.y+dy+.5*h-.5*f.fontSize, f.GetStringWidth(txtStr), f.fontSize, link, linkStr)\n\t\t}\n\t}\n\tstr := s.String()\n\tif len(str) > 0 {\n\t\tf.out(str)\n\t}\n\tf.lasth = h\n\tif ln > 0 {\n\t\t// Go to next line\n\t\tf.y += h\n\t\tif ln == 1 {\n\t\t\tf.x = f.lMargin\n\t\t}\n\t} else {\n\t\tf.x += w\n\t}\n\treturn\n}\n\n// Revert string to use in RTL languages\nfunc reverseText(text string) string {\n\toldText := []rune(text)\n\tnewText := make([]rune, len(oldText))\n\tlength := len(oldText) - 1\n\tfor i, r := range oldText {\n\t\tnewText[length-i] = r\n\t}\n\treturn string(newText)\n}\n\n// Cell is a simpler version of CellFormat with no fill, border, links or\n// special alignment. The Cell_strikeout() example demonstrates this method.\nfunc (f *Fpdf) Cell(w, h float64, txtStr string) {\n\tf.CellFormat(w, h, txtStr, \"\", 0, \"L\", false, 0, \"\")\n}\n\n// Cellf is a simpler printf-style version of CellFormat with no fill, border,\n// links or special alignment. See documentation for the fmt package for\n// details on fmtStr and args.\nfunc (f *Fpdf) Cellf(w, h float64, fmtStr string, args ...interface{}) {\n\tf.CellFormat(w, h, sprintf(fmtStr, args...), \"\", 0, \"L\", false, 0, \"\")\n}\n\n// SplitLines splits text into several lines using the current font. Each line\n// has its length limited to a maximum width given by w. This function can be\n// used to determine the total height of wrapped text for vertical placement\n// purposes.\n//\n// This method is useful for codepage-based fonts only. For UTF-8 encoded text,\n// use SplitText().\n//\n// You can use MultiCell if you want to print a text on several lines in a\n// simple way.\nfunc (f *Fpdf) SplitLines(txt []byte, w float64) [][]byte {\n\t// Function contributed by Bruno Michel\n\tlines := [][]byte{}\n\tcw := f.currentFont.Cw\n\twmax := int(math.Ceil((w - 2*f.cMargin) * 1000 / f.fontSize))\n\ts := bytes.Replace(txt, []byte(\"\\r\"), []byte{}, -1)\n\tnb := len(s)\n\tfor nb > 0 && s[nb-1] == '\\n' {\n\t\tnb--\n\t}\n\ts = s[0:nb]\n\tsep := -1\n\ti := 0\n\tj := 0\n\tl := 0\n\tfor i < nb {\n\t\tc := s[i]\n\t\tl += cw[c]\n\t\tif c == ' ' || c == '\\t' || c == '\\n' {\n\t\t\tsep = i\n\t\t}\n\t\tif c == '\\n' || l > wmax {\n\t\t\tif sep == -1 {\n\t\t\t\tif i == j {\n\t\t\t\t\ti++\n\t\t\t\t}\n\t\t\t\tsep = i\n\t\t\t} else {\n\t\t\t\ti = sep + 1\n\t\t\t}\n\t\t\tlines = append(lines, s[j:sep])\n\t\t\tsep = -1\n\t\t\tj = i\n\t\t\tl = 0\n\t\t} else {\n\t\t\ti++\n\t\t}\n\t}\n\tif i != j {\n\t\tlines = append(lines, s[j:i])\n\t}\n\treturn lines\n}\n\n// MultiCell supports printing text with line breaks. They can be automatic (as\n// soon as the text reaches the right border of the cell) or explicit (via the\n// \\n character). As many cells as necessary are output, one below the other.\n//\n// Text can be aligned, centered or justified. The cell block can be framed and\n// the background painted. See CellFormat() for more details.\n//\n// The current position after calling MultiCell() is the beginning of the next\n// line, equivalent to calling CellFormat with ln equal to 1.\n//\n// w is the width of the cells. A value of zero indicates cells that reach to\n// the right margin.\n//\n// h indicates the line height of each cell in the unit of measure specified in New().\n//\n// Note: this method has a known bug that treats UTF-8 fonts differently than\n// non-UTF-8 fonts. With UTF-8 fonts, all trailing newlines in txtStr are\n// removed. With a non-UTF-8 font, if txtStr has one or more trailing newlines,\n// only the last is removed. In the next major module version, the UTF-8 logic\n// will be changed to match the non-UTF-8 logic. To prepare for that change,\n// applications that use UTF-8 fonts and depend on having all trailing newlines\n// removed should call strings.TrimRight(txtStr, \"\\r\\n\") before calling this\n// method.\nfunc (f *Fpdf) MultiCell(w, h float64, txtStr, borderStr, alignStr string, fill bool) {\n\tif f.err != nil {\n\t\treturn\n\t}\n\t// dbg(\"MultiCell\")\n\tif alignStr == \"\" {\n\t\talignStr = \"J\"\n\t}\n\tcw := f.currentFont.Cw\n\tif w == 0 {\n\t\tw = f.w - f.rMargin - f.x\n\t}\n\twmax := int(math.Ceil((w - 2*f.cMargin) * 1000 / f.fontSize))\n\ts := strings.Replace(txtStr, \"\\r\", \"\", -1)\n\tsrune := []rune(s)\n\n\t// remove extra line breaks\n\tvar nb int\n\tif f.isCurrentUTF8 {\n\t\tnb = len(srune)\n\t\tfor nb > 0 && srune[nb-1] == '\\n' {\n\t\t\tnb--\n\t\t}\n\t\tsrune = srune[0:nb]\n\t} else {\n\t\tnb = len(s)\n\t\tbytes2 := []byte(s)\n\n\t\t// for nb > 0 && bytes2[nb-1] == '\\n' {\n\n\t\t// Prior to August 2019, if s ended with a newline, this code stripped it.\n\t\t// After that date, to be compatible with the UTF-8 code above, *all*\n\t\t// trailing newlines were removed. Because this regression caused at least\n\t\t// one application to break (see issue #333), the original behavior has been\n\t\t// reinstated with a caveat included in the documentation.\n\t\tif nb > 0 && bytes2[nb-1] == '\\n' {\n\t\t\tnb--\n\t\t}\n\t\ts = s[0:nb]\n\t}\n\t// dbg(\"[%s]\\n\", s)\n\tvar b, b2 string\n\tb = \"0\"\n\tif len(borderStr) > 0 {\n\t\tif borderStr == \"1\" {\n\t\t\tborderStr = \"LTRB\"\n\t\t\tb = \"LRT\"\n\t\t\tb2 = \"LR\"\n\t\t} else {\n\t\t\tb2 = \"\"\n\t\t\tif strings.Contains(borderStr, \"L\") {\n\t\t\t\tb2 += \"L\"\n\t\t\t}\n\t\t\tif strings.Contains(borderStr, \"R\") {\n\t\t\t\tb2 += \"R\"\n\t\t\t}\n\t\t\tif strings.Contains(borderStr, \"T\") {\n\t\t\t\tb = b2 + \"T\"\n\t\t\t} else {\n\t\t\t\tb = b2\n\t\t\t}\n\t\t}\n\t}\n\tsep := -1\n\ti := 0\n\tj := 0\n\tl := 0\n\tls := 0\n\tns := 0\n\tnl := 1\n\tfor i < nb {\n\t\t// Get next character\n\t\tvar c rune\n\t\tif f.isCurrentUTF8 {\n\t\t\tc = srune[i]\n\t\t} else {\n\t\t\tc = rune(s[i])\n\t\t}\n\t\tif c == '\\n' {\n\t\t\t// Explicit line break\n\t\t\tif f.ws > 0 {\n\t\t\t\tf.ws = 0\n\t\t\t\tf.out(\"0 Tw\")\n\t\t\t}\n\n\t\t\tif f.isCurrentUTF8 {\n\t\t\t\tnewAlignStr := alignStr\n\t\t\t\tif newAlignStr == \"J\" {\n\t\t\t\t\tif f.isRTL {\n\t\t\t\t\t\tnewAlignStr = \"R\"\n\t\t\t\t\t} else {\n\t\t\t\t\t\tnewAlignStr = \"L\"\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tf.CellFormat(w, h, string(srune[j:i]), b, 2, newAlignStr, fill, 0, \"\")\n\t\t\t} else {\n\t\t\t\tf.CellFormat(w, h, s[j:i], b, 2, alignStr, fill, 0, \"\")\n\t\t\t}\n\t\t\ti++\n\t\t\tsep = -1\n\t\t\tj = i\n\t\t\tl = 0\n\t\t\tns = 0\n\t\t\tnl++\n\t\t\tif len(borderStr) > 0 && nl == 2 {\n\t\t\t\tb = b2\n\t\t\t}\n\t\t\tcontinue\n\t\t}\n\t\tif c == ' ' || isChinese(c) {\n\t\t\tsep = i\n\t\t\tls = l\n\t\t\tns++\n\t\t}\n\t\tif int(c) >= len(cw) {\n\t\t\tf.err = fmt.Errorf(\"character outside the supported range: %s\", string(c))\n\t\t\treturn\n\t\t}\n\t\tif cw[int(c)] == 0 { //Marker width 0 used for missing symbols\n\t\t\tl += f.currentFont.Desc.MissingWidth\n\t\t} else if cw[int(c)] != 65535 { //Marker width 65535 used for zero width symbols\n\t\t\tl += cw[int(c)]\n\t\t}\n\t\tif l > wmax {\n\t\t\t// Automatic line break\n\t\t\tif sep == -1 {\n\t\t\t\tif i == j {\n\t\t\t\t\ti++\n\t\t\t\t}\n\t\t\t\tif f.ws > 0 {\n\t\t\t\t\tf.ws = 0\n\t\t\t\t\tf.out(\"0 Tw\")\n\t\t\t\t}\n\t\t\t\tif f.isCurrentUTF8 {\n\t\t\t\t\tf.CellFormat(w, h, string(srune[j:i]), b, 2, alignStr, fill, 0, \"\")\n\t\t\t\t} else {\n\t\t\t\t\tf.CellFormat(w, h, s[j:i], b, 2, alignStr, fill, 0, \"\")\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif alignStr == \"J\" {\n\t\t\t\t\tif ns > 1 {\n\t\t\t\t\t\tf.ws = float64((wmax-ls)/1000) * f.fontSize / float64(ns-1)\n\t\t\t\t\t} else {\n\t\t\t\t\t\tf.ws = 0\n\t\t\t\t\t}\n\t\t\t\t\tf.outf(\"%.3f Tw\", f.ws*f.k)\n\t\t\t\t}\n\t\t\t\tif f.isCurrentUTF8 {\n\t\t\t\t\tf.CellFormat(w, h, string(srune[j:sep]), b, 2, alignStr, fill, 0, \"\")\n\t\t\t\t} else {\n\t\t\t\t\tf.CellFormat(w, h, s[j:sep], b, 2, alignStr, fill, 0, \"\")\n\t\t\t\t}\n\t\t\t\ti = sep + 1\n\t\t\t}\n\t\t\tsep = -1\n\t\t\tj = i\n\t\t\tl = 0\n\t\t\tns = 0\n\t\t\tnl++\n\t\t\tif len(borderStr) > 0 && nl == 2 {\n\t\t\t\tb = b2\n\t\t\t}\n\t\t} else {\n\t\t\ti++\n\t\t}\n\t}\n\t// Last chunk\n\tif f.ws > 0 {\n\t\tf.ws = 0\n\t\tf.out(\"0 Tw\")\n\t}\n\tif len(borderStr) > 0 && strings.Contains(borderStr, \"B\") {\n\t\tb += \"B\"\n\t}\n\tif f.isCurrentUTF8 {\n\t\tif alignStr == \"J\" {\n\t\t\tif f.isRTL {\n\t\t\t\talignStr = \"R\"\n\t\t\t} else {\n\t\t\t\talignStr = \"\"\n\t\t\t}\n\t\t}\n\t\tf.CellFormat(w, h, string(srune[j:i]), b, 2, alignStr, fill, 0, \"\")\n\t} else {\n\t\tf.CellFormat(w, h, s[j:i], b, 2, alignStr, fill, 0, \"\")\n\t}\n\tf.x = f.lMargin\n}\n\n// write outputs text in flowing mode\nfunc (f *Fpdf) write(h float64, txtStr string, link int, linkStr string) {\n\t// dbg(\"Write\")\n\tcw := f.currentFont.Cw\n\tw := f.w - f.rMargin - f.x\n\twmax := (w - 2*f.cMargin) * 1000 / f.fontSize\n\ts := strings.Replace(txtStr, \"\\r\", \"\", -1)\n\tvar nb int\n\tif f.isCurrentUTF8 {\n\t\tnb = len([]rune(s))\n\t\tif nb == 1 && s == \" \" {\n\t\t\tf.x += f.GetStringWidth(s)\n\t\t\treturn\n\t\t}\n\t} else {\n\t\tnb = len(s)\n\t}\n\tsep := -1\n\ti := 0\n\tj := 0\n\tl := 0.0\n\tnl := 1\n\tfor i < nb {\n\t\t// Get next character\n\t\tvar c rune\n\t\tif f.isCurrentUTF8 {\n\t\t\tc = []rune(s)[i]\n\t\t} else {\n\t\t\tc = rune(byte(s[i]))\n\t\t}\n\t\tif c == '\\n' {\n\t\t\t// Explicit line break\n\t\t\tif f.isCurrentUTF8 {\n\t\t\t\tf.CellFormat(w, h, string([]rune(s)[j:i]), \"\", 2, \"\", false, link, linkStr)\n\t\t\t} else {\n\t\t\t\tf.CellFormat(w, h, s[j:i], \"\", 2, \"\", false, link, linkStr)\n\t\t\t}\n\t\t\ti++\n\t\t\tsep = -1\n\t\t\tj = i\n\t\t\tl = 0.0\n\t\t\tif nl == 1 {\n\t\t\t\tf.x = f.lMargin\n\t\t\t\tw = f.w - f.rMargin - f.x\n\t\t\t\twmax = (w - 2*f.cMargin) * 1000 / f.fontSize\n\t\t\t}\n\t\t\tnl++\n\t\t\tcontinue\n\t\t}\n\t\tif c == ' ' {\n\t\t\tsep = i\n\t\t}\n\t\tl += float64(cw[int(c)])\n\t\tif l > wmax {\n\t\t\t// Automatic line break\n\t\t\tif sep == -1 {\n\t\t\t\tif f.x > f.lMargin {\n\t\t\t\t\t// Move to next line\n\t\t\t\t\tf.x = f.lMargin\n\t\t\t\t\tf.y += h\n\t\t\t\t\tw = f.w - f.rMargin - f.x\n\t\t\t\t\twmax = (w - 2*f.cMargin) * 1000 / f.fontSize\n\t\t\t\t\ti++\n\t\t\t\t\tnl++\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\tif i == j {\n\t\t\t\t\ti++\n\t\t\t\t}\n\t\t\t\tif f.isCurrentUTF8 {\n\t\t\t\t\tf.CellFormat(w, h, string([]rune(s)[j:i]), \"\", 2, \"\", false, link, linkStr)\n\t\t\t\t} else {\n\t\t\t\t\tf.CellFormat(w, h, s[j:i], \"\", 2, \"\", false, link, linkStr)\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif f.isCurrentUTF8 {\n\t\t\t\t\tf.CellFormat(w, h, string([]rune(s)[j:sep]), \"\", 2, \"\", false, link, linkStr)\n\t\t\t\t} else {\n\t\t\t\t\tf.CellFormat(w, h, s[j:sep], \"\", 2, \"\", false, link, linkStr)\n\t\t\t\t}\n\t\t\t\ti = sep + 1\n\t\t\t}\n\t\t\tsep = -1\n\t\t\tj = i\n\t\t\tl = 0.0\n\t\t\tif nl == 1 {\n\t\t\t\tf.x = f.lMargin\n\t\t\t\tw = f.w - f.rMargin - f.x\n\t\t\t\twmax = (w - 2*f.cMargin) * 1000 / f.fontSize\n\t\t\t}\n\t\t\tnl++\n\t\t} else {\n\t\t\ti++\n\t\t}\n\t}\n\t// Last chunk\n\tif i != j {\n\t\tif f.isCurrentUTF8 {\n\t\t\tf.CellFormat(l/1000*f.fontSize, h, string([]rune(s)[j:]), \"\", 0, \"\", false, link, linkStr)\n\t\t} else {\n\t\t\tf.CellFormat(l/1000*f.fontSize, h, s[j:], \"\", 0, \"\", false, link, linkStr)\n\t\t}\n\t}\n}\n\n// Write prints text from the current position. When the right margin is\n// reached (or the \\n character is met) a line break occurs and text continues\n// from the left margin. Upon method exit, the current position is left just at\n// the end of the text.\n//\n// It is possible to put a link on the text.\n//\n// h indicates the line height in the unit of measure specified in New().\nfunc (f *Fpdf) Write(h float64, txtStr string) {\n\tf.write(h, txtStr, 0, \"\")\n}\n\n// Writef is like Write but uses printf-style formatting. See the documentation\n// for package fmt for more details on fmtStr and args.\nfunc (f *Fpdf) Writef(h float64, fmtStr string, args ...interface{}) {\n\tf.write(h, sprintf(fmtStr, args...), 0, \"\")\n}\n\n// WriteLinkString writes text that when clicked launches an external URL. See\n// Write() for argument details.\nfunc (f *Fpdf) WriteLinkString(h float64, displayStr, targetStr string) {\n\tf.write(h, displayStr, 0, targetStr)\n}\n\n// WriteLinkID writes text that when clicked jumps to another location in the\n// PDF. linkID is an identifier returned by AddLink(). See Write() for argument\n// details.\nfunc (f *Fpdf) WriteLinkID(h float64, displayStr string, linkID int) {\n\tf.write(h, displayStr, linkID, \"\")\n}\n\n// WriteAligned is an implementation of Write that makes it possible to align\n// text.\n//\n// width indicates the width of the box the text will be drawn in. This is in\n// the unit of measure specified in New(). If it is set to 0, the bounding box\n//of the page will be taken (pageWidth - leftMargin - rightMargin).\n//\n// lineHeight indicates the line height in the unit of measure specified in\n// New().\n//\n// alignStr sees to horizontal alignment of the given textStr. The options are\n// \"L\", \"C\" and \"R\" (Left, Center, Right). The default is \"L\".\nfunc (f *Fpdf) WriteAligned(width, lineHeight float64, textStr, alignStr string) {\n\tlMargin, _, rMargin, _ := f.GetMargins()\n\n\tpageWidth, _ := f.GetPageSize()\n\tif width == 0 {\n\t\twidth = pageWidth - (lMargin + rMargin)\n\t}\n\n\tvar lines []string\n\n\tif f.isCurrentUTF8 {\n\t\tlines = f.SplitText(textStr, width)\n\t} else {\n\t\tfor _, line := range f.SplitLines([]byte(textStr), width) {\n\t\t\tlines = append(lines, string(line))\n\t\t}\n\t}\n\n\tfor _, lineBt := range lines {\n\t\tlineStr := string(lineBt)\n\t\tlineWidth := f.GetStringWidth(lineStr)\n\n\t\tswitch alignStr {\n\t\tcase \"C\":\n\t\t\tf.SetLeftMargin(lMargin + ((width - lineWidth) / 2))\n\t\t\tf.Write(lineHeight, lineStr)\n\t\t\tf.SetLeftMargin(lMargin)\n\t\tcase \"R\":\n\t\t\tf.SetLeftMargin(lMargin + (width - lineWidth) - 2.01*f.cMargin)\n\t\t\tf.Write(lineHeight, lineStr)\n\t\t\tf.SetLeftMargin(lMargin)\n\t\tdefault:\n\t\t\tf.SetRightMargin(pageWidth - lMargin - width)\n\t\t\tf.Write(lineHeight, lineStr)\n\t\t\tf.SetRightMargin(rMargin)\n\t\t}\n\t}\n}\n\n// Ln performs a line break. The current abscissa goes back to the left margin\n// and the ordinate increases by the amount passed in parameter. A negative\n// value of h indicates the height of the last printed cell.\n//\n// This method is demonstrated in the example for MultiCell.\nfunc (f *Fpdf) Ln(h float64) {\n\tf.x = f.lMargin\n\tif h < 0 {\n\t\tf.y += f.lasth\n\t} else {\n\t\tf.y += h\n\t}\n}\n\n// ImageTypeFromMime returns the image type used in various image-related\n// functions (for example, Image()) that is associated with the specified MIME\n// type. For example, \"jpg\" is returned if mimeStr is \"image/jpeg\". An error is\n// set if the specified MIME type is not supported.\nfunc (f *Fpdf) ImageTypeFromMime(mimeStr string) (tp string) {\n\tswitch mimeStr {\n\tcase \"image/png\":\n\t\ttp = \"png\"\n\tcase \"image/jpg\":\n\t\ttp = \"jpg\"\n\tcase \"image/jpeg\":\n\t\ttp = \"jpg\"\n\tcase \"image/gif\":\n\t\ttp = \"gif\"\n\tdefault:\n\t\tf.SetErrorf(\"unsupported image type: %s\", mimeStr)\n\t}\n\treturn\n}\n\nfunc (f *Fpdf) imageOut(info *ImageInfoType, x, y, w, h float64, allowNegativeX, flow bool, link int, linkStr string) {\n\t// Automatic width and height calculation if needed\n\tif w == 0 && h == 0 {\n\t\t// Put image at 96 dpi\n\t\tw = -96\n\t\th = -96\n\t}\n\tif w == -1 {\n\t\t// Set image width to whatever value for dpi we read\n\t\t// from the image or that was set manually\n\t\tw = -info.dpi\n\t}\n\tif h == -1 {\n\t\t// Set image height to whatever value for dpi we read\n\t\t// from the image or that was set manually\n\t\th = -info.dpi\n\t}\n\tif w < 0 {\n\t\tw = -info.w * 72.0 / w / f.k\n\t}\n\tif h < 0 {\n\t\th = -info.h * 72.0 / h / f.k\n\t}\n\tif w == 0 {\n\t\tw = h * info.w / info.h\n\t}\n\tif h == 0 {\n\t\th = w * info.h / info.w\n\t}\n\t// Flowing mode\n\tif flow {\n\t\tif f.y+h > f.pageBreakTrigger && !f.inHeader && !f.inFooter && f.acceptPageBreak() {\n\t\t\t// Automatic page break\n\t\t\tx2 := f.x\n\t\t\tf.AddPageFormat(f.curOrientation, f.curPageSize)\n\t\t\tif f.err != nil {\n\t\t\t\treturn\n\t\t\t}\n\t\t\tf.x = x2\n\t\t}\n\t\ty = f.y\n\t\tf.y += h\n\t}\n\tif !allowNegativeX {\n\t\tif x < 0 {\n\t\t\tx = f.x\n\t\t}\n\t}\n\t// dbg(\"h %.2f\", h)\n\t// q 85.04 0 0 NaN 28.35 NaN cm /I2 Do Q\n\tf.outf(\"q %.5f 0 0 %.5f %.5f %.5f cm /I%s Do Q\", w*f.k, h*f.k, x*f.k, (f.h-(y+h))*f.k, info.i)\n\tif link > 0 || len(linkStr) > 0 {\n\t\tf.newLink(x, y, w, h, link, linkStr)\n\t}\n}\n\n// Image puts a JPEG, PNG or GIF image in the current page.\n//\n// Deprecated in favor of ImageOptions -- see that function for\n// details on the behavior of arguments\nfunc (f *Fpdf) Image(imageNameStr string, x, y, w, h float64, flow bool, tp string, link int, linkStr string) {\n\toptions := ImageOptions{\n\t\tReadDpi:   false,\n\t\tImageType: tp,\n\t}\n\tf.ImageOptions(imageNameStr, x, y, w, h, flow, options, link, linkStr)\n}\n\n// ImageOptions puts a JPEG, PNG or GIF image in the current page. The size it\n// will take on the page can be specified in different ways. If both w and h\n// are 0, the image is rendered at 96 dpi. If either w or h is zero, it will be\n// calculated from the other dimension so that the aspect ratio is maintained.\n// If w and/or h are -1, the dpi for that dimension will be read from the\n// ImageInfoType object. PNG files can contain dpi information, and if present,\n// this information will be populated in the ImageInfoType object and used in\n// Width, Height, and Extent calculations. Otherwise, the SetDpi function can\n// be used to change the dpi from the default of 72.\n//\n// If w and h are any other negative value, their absolute values\n// indicate their dpi extents.\n//\n// Supported JPEG formats are 24 bit, 32 bit and gray scale. Supported PNG\n// formats are 24 bit, indexed color, and 8 bit indexed gray scale. If a GIF\n// image is animated, only the first frame is rendered. Transparency is\n// supported. It is possible to put a link on the image.\n//\n// imageNameStr may be the name of an image as registered with a call to either\n// RegisterImageReader() or RegisterImage(). In the first case, the image is\n// loaded using an io.Reader. This is generally useful when the image is\n// obtained from some other means than as a disk-based file. In the second\n// case, the image is loaded as a file. Alternatively, imageNameStr may\n// directly specify a sufficiently qualified filename.\n//\n// However the image is loaded, if it is used more than once only one copy is\n// embedded in the file.\n//\n// If x is negative, the current abscissa is used.\n//\n// If flow is true, the current y value is advanced after placing the image and\n// a page break may be made if necessary.\n//\n// If link refers to an internal page anchor (that is, it is non-zero; see\n// AddLink()), the image will be a clickable internal link. Otherwise, if\n// linkStr specifies a URL, the image will be a clickable external link.\nfunc (f *Fpdf) ImageOptions(imageNameStr string, x, y, w, h float64, flow bool, options ImageOptions, link int, linkStr string) {\n\tif f.err != nil {\n\t\treturn\n\t}\n\tinfo := f.RegisterImageOptions(imageNameStr, options)\n\tif f.err != nil {\n\t\treturn\n\t}\n\tf.imageOut(info, x, y, w, h, options.AllowNegativePosition, flow, link, linkStr)\n\treturn\n}\n\n// RegisterImageReader registers an image, reading it from Reader r, adding it\n// to the PDF file but not adding it to the page.\n//\n// This function is now deprecated in favor of RegisterImageOptionsReader\nfunc (f *Fpdf) RegisterImageReader(imgName, tp string, r io.Reader) (info *ImageInfoType) {\n\toptions := ImageOptions{\n\t\tReadDpi:   false,\n\t\tImageType: tp,\n\t}\n\treturn f.RegisterImageOptionsReader(imgName, options, r)\n}\n\n// ImageOptions provides a place to hang any options we want to use while\n// parsing an image.\n//\n// ImageType's possible values are (case insensitive):\n// \"JPG\", \"JPEG\", \"PNG\" and \"GIF\". If empty, the type is inferred from\n// the file extension.\n//\n// ReadDpi defines whether to attempt to automatically read the image\n// dpi information from the image file. Normally, this should be set\n// to true (understanding that not all images will have this info\n// available). However, for backwards compatibility with previous\n// versions of the API, it defaults to false.\n//\n// AllowNegativePosition can be set to true in order to prevent the default\n// coercion of negative x values to the current x position.\ntype ImageOptions struct {\n\tImageType             string\n\tReadDpi               bool\n\tAllowNegativePosition bool\n}\n\n// RegisterImageOptionsReader registers an image, reading it from Reader r, adding it\n// to the PDF file but not adding it to the page. Use Image() with the same\n// name to add the image to the page. Note that tp should be specified in this\n// case.\n//\n// See Image() for restrictions on the image and the options parameters.\nfunc (f *Fpdf) RegisterImageOptionsReader(imgName string, options ImageOptions, r io.Reader) (info *ImageInfoType) {\n\t// Thanks, Ivan Daniluk, for generalizing this code to use the Reader interface.\n\tif f.err != nil {\n\t\treturn\n\t}\n\tinfo, ok := f.images[imgName]\n\tif ok {\n\t\treturn\n\t}\n\n\t// First use of this image, get info\n\tif options.ImageType == \"\" {\n\t\tf.err = fmt.Errorf(\"image type should be specified if reading from custom reader\")\n\t\treturn\n\t}\n\toptions.ImageType = strings.ToLower(options.ImageType)\n\tif options.ImageType == \"jpeg\" {\n\t\toptions.ImageType = \"jpg\"\n\t}\n\tswitch options.ImageType {\n\tcase \"jpg\":\n\t\tinfo = f.parsejpg(r)\n\tcase \"png\":\n\t\tinfo = f.parsepng(r, options.ReadDpi)\n\tcase \"gif\":\n\t\tinfo = f.parsegif(r)\n\tdefault:\n\t\tf.err = fmt.Errorf(\"unsupported image type: %s\", options.ImageType)\n\t}\n\tif f.err != nil {\n\t\treturn\n\t}\n\n\tif info.i, f.err = generateImageID(info); f.err != nil {\n\t\treturn\n\t}\n\tf.images[imgName] = info\n\n\treturn\n}\n\n// RegisterImage registers an image, adding it to the PDF file but not adding\n// it to the page. Use Image() with the same filename to add the image to the\n// page. Note that Image() calls this function, so this function is only\n// necessary if you need information about the image before placing it.\n//\n// This function is now deprecated in favor of RegisterImageOptions.\n// See Image() for restrictions on the image and the \"tp\" parameters.\nfunc (f *Fpdf) RegisterImage(fileStr, tp string) (info *ImageInfoType) {\n\toptions := ImageOptions{\n\t\tReadDpi:   false,\n\t\tImageType: tp,\n\t}\n\treturn f.RegisterImageOptions(fileStr, options)\n}\n\n// RegisterImageOptions registers an image, adding it to the PDF file but not\n// adding it to the page. Use Image() with the same filename to add the image\n// to the page. Note that Image() calls this function, so this function is only\n// necessary if you need information about the image before placing it. See\n// Image() for restrictions on the image and the \"tp\" parameters.\nfunc (f *Fpdf) RegisterImageOptions(fileStr string, options ImageOptions) (info *ImageInfoType) {\n\tinfo, ok := f.images[fileStr]\n\tif ok {\n\t\treturn\n\t}\n\n\tfile, err := os.Open(fileStr)\n\tif err != nil {\n\t\tf.err = err\n\t\treturn\n\t}\n\tdefer file.Close()\n\n\t// First use of this image, get info\n\tif options.ImageType == \"\" {\n\t\tpos := strings.LastIndex(fileStr, \".\")\n\t\tif pos < 0 {\n\t\t\tf.err = fmt.Errorf(\"image file has no extension and no type was specified: %s\", fileStr)\n\t\t\treturn\n\t\t}\n\t\toptions.ImageType = fileStr[pos+1:]\n\t}\n\n\treturn f.RegisterImageOptionsReader(fileStr, options, file)\n}\n\n// GetImageInfo returns information about the registered image specified by\n// imageStr. If the image has not been registered, nil is returned. The\n// internal error is not modified by this method.\nfunc (f *Fpdf) GetImageInfo(imageStr string) (info *ImageInfoType) {\n\treturn f.images[imageStr]\n}\n\n// ImportObjects imports objects from gofpdi into current document\nfunc (f *Fpdf) ImportObjects(objs map[string][]byte) {\n\tfor k, v := range objs {\n\t\tf.importedObjs[k] = v\n\t}\n}\n\n// ImportObjPos imports object hash positions from gofpdi\nfunc (f *Fpdf) ImportObjPos(objPos map[string]map[int]string) {\n\tfor k, v := range objPos {\n\t\tf.importedObjPos[k] = v\n\t}\n}\n\n// putImportedTemplates writes the imported template objects to the PDF\nfunc (f *Fpdf) putImportedTemplates() {\n\tnOffset := f.n + 1\n\n\t// keep track of list of sha1 hashes (to be replaced with integers)\n\tobjsIDHash := make([]string, len(f.importedObjs))\n\n\t// actual object data with new id\n\tobjsIDData := make([][]byte, len(f.importedObjs))\n\n\t// Populate hash slice and data slice\n\ti := 0\n\tfor k, v := range f.importedObjs {\n\t\tobjsIDHash[i] = k\n\t\tobjsIDData[i] = v\n\n\t\ti++\n\t}\n\n\t// Populate a lookup table to get an object id from a hash\n\thashToObjID := make(map[string]int, len(f.importedObjs))\n\tfor i = 0; i < len(objsIDHash); i++ {\n\t\thashToObjID[objsIDHash[i]] = i + nOffset\n\t}\n\n\t// Now, replace hashes inside data with %040d object id\n\tfor i = 0; i < len(objsIDData); i++ {\n\t\t// get hash\n\t\thash := objsIDHash[i]\n\n\t\tfor pos, h := range f.importedObjPos[hash] {\n\t\t\t// Convert object id into a 40 character string padded with spaces\n\t\t\tobjIDPadded := fmt.Sprintf(\"%40s\", fmt.Sprintf(\"%d\", hashToObjID[h]))\n\n\t\t\t// Convert objIDPadded into []byte\n\t\t\tobjIDBytes := []byte(objIDPadded)\n\n\t\t\t// Replace sha1 hash with object id padded\n\t\t\tfor j := pos; j < pos+40; j++ {\n\t\t\t\tobjsIDData[i][j] = objIDBytes[j-pos]\n\t\t\t}\n\t\t}\n\n\t\t// Save objsIDHash so that procset dictionary has the correct object ids\n\t\tf.importedTplIDs[hash] = i + nOffset\n\t}\n\n\t// Now, put objects\n\tfor i = 0; i < len(objsIDData); i++ {\n\t\tf.newobj()\n\t\tf.out(string(objsIDData[i]))\n\t}\n}\n\n// UseImportedTemplate uses imported template from gofpdi. It draws imported\n// PDF page onto page.\nfunc (f *Fpdf) UseImportedTemplate(tplName string, scaleX float64, scaleY float64, tX float64, tY float64) {\n\tf.outf(\"q 0 J 1 w 0 j 0 G 0 g q %.4F 0 0 %.4F %.4F %.4F cm %s Do Q Q\\n\", scaleX*f.k, scaleY*f.k, tX*f.k, (tY+f.h)*f.k, tplName)\n}\n\n// ImportTemplates imports gofpdi template names into importedTplObjs for\n// inclusion in the procset dictionary\nfunc (f *Fpdf) ImportTemplates(tpls map[string]string) {\n\tfor tplName, tplID := range tpls {\n\t\tf.importedTplObjs[tplName] = tplID\n\t}\n}\n\n// GetConversionRatio returns the conversion ratio based on the unit given when\n// creating the PDF.\nfunc (f *Fpdf) GetConversionRatio() float64 {\n\treturn f.k\n}\n\n// GetXY returns the abscissa and ordinate of the current position.\n//\n// Note: the value returned for the abscissa will be affected by the current\n// cell margin. To account for this, you may need to either add the value\n// returned by GetCellMargin() to it or call SetCellMargin(0) to remove the\n// cell margin.\nfunc (f *Fpdf) GetXY() (float64, float64) {\n\treturn f.x, f.y\n}\n\n// GetX returns the abscissa of the current position.\n//\n// Note: the value returned will be affected by the current cell margin. To\n// account for this, you may need to either add the value returned by\n// GetCellMargin() to it or call SetCellMargin(0) to remove the cell margin.\nfunc (f *Fpdf) GetX() float64 {\n\treturn f.x\n}\n\n// SetX defines the abscissa of the current position. If the passed value is\n// negative, it is relative to the right of the page.\nfunc (f *Fpdf) SetX(x float64) {\n\tif x >= 0 {\n\t\tf.x = x\n\t} else {\n\t\tf.x = f.w + x\n\t}\n}\n\n// GetY returns the ordinate of the current position.\nfunc (f *Fpdf) GetY() float64 {\n\treturn f.y\n}\n\n// SetY moves the current abscissa back to the left margin and sets the\n// ordinate. If the passed value is negative, it is relative to the bottom of\n// the page.\nfunc (f *Fpdf) SetY(y float64) {\n\t// dbg(\"SetY x %.2f, lMargin %.2f\", f.x, f.lMargin)\n\tf.x = f.lMargin\n\tif y >= 0 {\n\t\tf.y = y\n\t} else {\n\t\tf.y = f.h + y\n\t}\n}\n\n// SetHomeXY is a convenience method that sets the current position to the left\n// and top margins.\nfunc (f *Fpdf) SetHomeXY() {\n\tf.SetY(f.tMargin)\n\tf.SetX(f.lMargin)\n}\n\n// SetXY defines the abscissa and ordinate of the current position. If the\n// passed values are negative, they are relative respectively to the right and\n// bottom of the page.\nfunc (f *Fpdf) SetXY(x, y float64) {\n\tf.SetY(y)\n\tf.SetX(x)\n}\n\n// SetProtection applies certain constraints on the finished PDF document.\n//\n// actionFlag is a bitflag that controls various document operations.\n// CnProtectPrint allows the document to be printed. CnProtectModify allows a\n// document to be modified by a PDF editor. CnProtectCopy allows text and\n// images to be copied into the system clipboard. CnProtectAnnotForms allows\n// annotations and forms to be added by a PDF editor. These values can be\n// combined by or-ing them together, for example,\n// CnProtectCopy|CnProtectModify. This flag is advisory; not all PDF readers\n// implement the constraints that this argument attempts to control.\n//\n// userPassStr specifies the password that will need to be provided to view the\n// contents of the PDF. The permissions specified by actionFlag will apply.\n//\n// ownerPassStr specifies the password that will need to be provided to gain\n// full access to the document regardless of the actionFlag value. An empty\n// string for this argument will be replaced with a random value, effectively\n// prohibiting full access to the document.\nfunc (f *Fpdf) SetProtection(actionFlag byte, userPassStr, ownerPassStr string) {\n\tif f.err != nil {\n\t\treturn\n\t}\n\tf.protect.setProtection(actionFlag, userPassStr, ownerPassStr)\n}\n\n// OutputAndClose sends the PDF document to the writer specified by w. This\n// method will close both f and w, even if an error is detected and no document\n// is produced.\nfunc (f *Fpdf) OutputAndClose(w io.WriteCloser) error {\n\tf.Output(w)\n\tw.Close()\n\treturn f.err\n}\n\n// OutputFileAndClose creates or truncates the file specified by fileStr and\n// writes the PDF document to it. This method will close f and the newly\n// written file, even if an error is detected and no document is produced.\n//\n// Most examples demonstrate the use of this method.\nfunc (f *Fpdf) OutputFileAndClose(fileStr string) error {\n\tif f.err == nil {\n\t\tpdfFile, err := os.Create(fileStr)\n\t\tif err == nil {\n\t\t\tf.Output(pdfFile)\n\t\t\tpdfFile.Close()\n\t\t} else {\n\t\t\tf.err = err\n\t\t}\n\t}\n\treturn f.err\n}\n\n// Output sends the PDF document to the writer specified by w. No output will\n// take place if an error has occurred in the document generation process. w\n// remains open after this function returns. After returning, f is in a closed\n// state and its methods should not be called.\nfunc (f *Fpdf) Output(w io.Writer) error {\n\tif f.err != nil {\n\t\treturn f.err\n\t}\n\t// dbg(\"Output\")\n\tif f.state < 3 {\n\t\tf.Close()\n\t}\n\t_, err := f.buffer.WriteTo(w)\n\tif err != nil {\n\t\tf.err = err\n\t}\n\treturn f.err\n}\n\nfunc (f *Fpdf) getpagesizestr(sizeStr string) (size SizeType) {\n\tif f.err != nil {\n\t\treturn\n\t}\n\tsizeStr = strings.ToLower(sizeStr)\n\t// dbg(\"Size [%s]\", sizeStr)\n\tvar ok bool\n\tsize, ok = f.stdPageSizes[sizeStr]\n\tif ok {\n\t\t// dbg(\"found %s\", sizeStr)\n\t\tsize.Wd /= f.k\n\t\tsize.Ht /= f.k\n\n\t} else {\n\t\tf.err = fmt.Errorf(\"unknown page size %s\", sizeStr)\n\t}\n\treturn\n}\n\n// GetPageSizeStr returns the SizeType for the given sizeStr (that is A4, A3, etc..)\nfunc (f *Fpdf) GetPageSizeStr(sizeStr string) (size SizeType) {\n\treturn f.getpagesizestr(sizeStr)\n}\n\nfunc (f *Fpdf) _getpagesize(size SizeType) SizeType {\n\tif size.Wd > size.Ht {\n\t\tsize.Wd, size.Ht = size.Ht, size.Wd\n\t}\n\treturn size\n}\n\nfunc (f *Fpdf) beginpage(orientationStr string, size SizeType) {\n\tif f.err != nil {\n\t\treturn\n\t}\n\tf.page++\n\t// add the default page boxes, if any exist, to the page\n\tf.pageBoxes[f.page] = make(map[string]PageBox)\n\tfor box, pb := range f.defPageBoxes {\n\t\tf.pageBoxes[f.page][box] = pb\n\t}\n\tf.pages = append(f.pages, bytes.NewBufferString(\"\"))\n\tf.pageLinks = append(f.pageLinks, make([]linkType, 0, 0))\n\tf.pageAttachments = append(f.pageAttachments, []annotationAttach{})\n\tf.state = 2\n\tf.x = f.lMargin\n\tf.y = f.tMargin\n\tf.fontFamily = \"\"\n\t// Check page size and orientation\n\tif orientationStr == \"\" {\n\t\torientationStr = f.defOrientation\n\t} else {\n\t\torientationStr = strings.ToUpper(orientationStr[0:1])\n\t}\n\tif orientationStr != f.curOrientation || size.Wd != f.curPageSize.Wd || size.Ht != f.curPageSize.Ht {\n\t\t// New size or orientation\n\t\tif orientationStr == \"P\" {\n\t\t\tf.w = size.Wd\n\t\t\tf.h = size.Ht\n\t\t} else {\n\t\t\tf.w = size.Ht\n\t\t\tf.h = size.Wd\n\t\t}\n\t\tf.wPt = f.w * f.k\n\t\tf.hPt = f.h * f.k\n\t\tf.pageBreakTrigger = f.h - f.bMargin\n\t\tf.curOrientation = orientationStr\n\t\tf.curPageSize = size\n\t}\n\tif orientationStr != f.defOrientation || size.Wd != f.defPageSize.Wd || size.Ht != f.defPageSize.Ht {\n\t\tf.pageSizes[f.page] = SizeType{f.wPt, f.hPt}\n\t}\n\treturn\n}\n\nfunc (f *Fpdf) endpage() {\n\tf.EndLayer()\n\tf.state = 1\n}\n\n// Load a font definition file from the given Reader\nfunc (f *Fpdf) loadfont(r io.Reader) (def fontDefType) {\n\tif f.err != nil {\n\t\treturn\n\t}\n\t// dbg(\"Loading font [%s]\", fontStr)\n\tvar buf bytes.Buffer\n\t_, err := buf.ReadFrom(r)\n\tif err != nil {\n\t\tf.err = err\n\t\treturn\n\t}\n\terr = json.Unmarshal(buf.Bytes(), &def)\n\tif err != nil {\n\t\tf.err = err\n\t\treturn\n\t}\n\n\tif def.i, err = generateFontID(def); err != nil {\n\t\tf.err = err\n\t}\n\t// dump(def)\n\treturn\n}\n\n// Escape special characters in strings\nfunc (f *Fpdf) escape(s string) string {\n\ts = strings.Replace(s, \"\\\\\", \"\\\\\\\\\", -1)\n\ts = strings.Replace(s, \"(\", \"\\\\(\", -1)\n\ts = strings.Replace(s, \")\", \"\\\\)\", -1)\n\ts = strings.Replace(s, \"\\r\", \"\\\\r\", -1)\n\treturn s\n}\n\n// textstring formats a text string\nfunc (f *Fpdf) textstring(s string) string {\n\tif f.protect.encrypted {\n\t\tb := []byte(s)\n\t\tf.protect.rc4(uint32(f.n), &b)\n\t\ts = string(b)\n\t}\n\treturn \"(\" + f.escape(s) + \")\"\n}\n\nfunc blankCount(str string) (count int) {\n\tl := len(str)\n\tfor j := 0; j < l; j++ {\n\t\tif byte(' ') == str[j] {\n\t\t\tcount++\n\t\t}\n\t}\n\treturn\n}\n\n// SetUnderlineThickness accepts a multiplier for adjusting the text underline\n// thickness, defaulting to 1. See SetUnderlineThickness example.\nfunc (f *Fpdf) SetUnderlineThickness(thickness float64) {\n\tf.userUnderlineThickness = thickness\n}\n\n// Underline text\nfunc (f *Fpdf) dounderline(x, y float64, txt string) string {\n\tup := float64(f.currentFont.Up)\n\tut := float64(f.currentFont.Ut) * f.userUnderlineThickness\n\tw := f.GetStringWidth(txt) + f.ws*float64(blankCount(txt))\n\treturn sprintf(\"%.2f %.2f %.2f %.2f re f\", x*f.k,\n\t\t(f.h-(y-up/1000*f.fontSize))*f.k, w*f.k, -ut/1000*f.fontSizePt)\n}\n\nfunc (f *Fpdf) dostrikeout(x, y float64, txt string) string {\n\tup := float64(f.currentFont.Up)\n\tut := float64(f.currentFont.Ut)\n\tw := f.GetStringWidth(txt) + f.ws*float64(blankCount(txt))\n\treturn sprintf(\"%.2f %.2f %.2f %.2f re f\", x*f.k,\n\t\t(f.h-(y+4*up/1000*f.fontSize))*f.k, w*f.k, -ut/1000*f.fontSizePt)\n}\n\nfunc bufEqual(buf []byte, str string) bool {\n\treturn string(buf[0:len(str)]) == str\n}\n\nfunc be16(buf []byte) int {\n\treturn 256*int(buf[0]) + int(buf[1])\n}\n\nfunc (f *Fpdf) newImageInfo() *ImageInfoType {\n\t// default dpi to 72 unless told otherwise\n\treturn &ImageInfoType{scale: f.k, dpi: 72}\n}\n\n// parsejpg extracts info from io.Reader with JPEG data\n// Thank you, Bruno Michel, for providing this code.\nfunc (f *Fpdf) parsejpg(r io.Reader) (info *ImageInfoType) {\n\tinfo = f.newImageInfo()\n\tvar (\n\t\tdata bytes.Buffer\n\t\terr  error\n\t)\n\t_, err = data.ReadFrom(r)\n\tif err != nil {\n\t\tf.err = err\n\t\treturn\n\t}\n\tinfo.data = data.Bytes()\n\n\tconfig, err := jpeg.DecodeConfig(bytes.NewReader(info.data))\n\tif err != nil {\n\t\tf.err = err\n\t\treturn\n\t}\n\tinfo.w = float64(config.Width)\n\tinfo.h = float64(config.Height)\n\tinfo.f = \"DCTDecode\"\n\tinfo.bpc = 8\n\tswitch config.ColorModel {\n\tcase color.GrayModel:\n\t\tinfo.cs = \"DeviceGray\"\n\tcase color.YCbCrModel:\n\t\tinfo.cs = \"DeviceRGB\"\n\tcase color.CMYKModel:\n\t\tinfo.cs = \"DeviceCMYK\"\n\tdefault:\n\t\tf.err = fmt.Errorf(\"image JPEG buffer has unsupported color space (%v)\", config.ColorModel)\n\t\treturn\n\t}\n\treturn\n}\n\n// parsepng extracts info from a PNG data\nfunc (f *Fpdf) parsepng(r io.Reader, readdpi bool) (info *ImageInfoType) {\n\tbuf, err := bufferFromReader(r)\n\tif err != nil {\n\t\tf.err = err\n\t\treturn\n\t}\n\treturn f.parsepngstream(buf, readdpi)\n}\n\nfunc (f *Fpdf) readBeInt32(r io.Reader) (val int32) {\n\terr := binary.Read(r, binary.BigEndian, &val)\n\tif err != nil && err != io.EOF {\n\t\tf.err = err\n\t}\n\treturn\n}\n\nfunc (f *Fpdf) readByte(r io.Reader) (val byte) {\n\terr := binary.Read(r, binary.BigEndian, &val)\n\tif err != nil {\n\t\tf.err = err\n\t}\n\treturn\n}\n\n// parsegif extracts info from a GIF data (via PNG conversion)\nfunc (f *Fpdf) parsegif(r io.Reader) (info *ImageInfoType) {\n\tdata, err := bufferFromReader(r)\n\tif err != nil {\n\t\tf.err = err\n\t\treturn\n\t}\n\tvar img image.Image\n\timg, err = gif.Decode(data)\n\tif err != nil {\n\t\tf.err = err\n\t\treturn\n\t}\n\tpngBuf := new(bytes.Buffer)\n\terr = png.Encode(pngBuf, img)\n\tif err != nil {\n\t\tf.err = err\n\t\treturn\n\t}\n\treturn f.parsepngstream(pngBuf, false)\n}\n\n// newobj begins a new object\nfunc (f *Fpdf) newobj() {\n\t// dbg(\"newobj\")\n\tf.n++\n\tfor j := len(f.offsets); j <= f.n; j++ {\n\t\tf.offsets = append(f.offsets, 0)\n\t}\n\tf.offsets[f.n] = f.buffer.Len()\n\tf.outf(\"%d 0 obj\", f.n)\n}\n\nfunc (f *Fpdf) putstream(b []byte) {\n\t// dbg(\"putstream\")\n\tif f.protect.encrypted {\n\t\tf.protect.rc4(uint32(f.n), &b)\n\t}\n\tf.out(\"stream\")\n\tf.out(string(b))\n\tf.out(\"endstream\")\n}\n\n// out; Add a line to the document\nfunc (f *Fpdf) out(s string) {\n\tif f.state == 2 {\n\t\tf.pages[f.page].WriteString(s)\n\t\tf.pages[f.page].WriteString(\"\\n\")\n\t} else {\n\t\tf.buffer.WriteString(s)\n\t\tf.buffer.WriteString(\"\\n\")\n\t}\n}\n\n// outbuf adds a buffered line to the document\nfunc (f *Fpdf) outbuf(r io.Reader) {\n\tif f.state == 2 {\n\t\tf.pages[f.page].ReadFrom(r)\n\t\tf.pages[f.page].WriteString(\"\\n\")\n\t} else {\n\t\tf.buffer.ReadFrom(r)\n\t\tf.buffer.WriteString(\"\\n\")\n\t}\n}\n\n// RawWriteStr writes a string directly to the PDF generation buffer. This is a\n// low-level function that is not required for normal PDF construction. An\n// understanding of the PDF specification is needed to use this method\n// correctly.\nfunc (f *Fpdf) RawWriteStr(str string) {\n\tf.out(str)\n}\n\n// RawWriteBuf writes the contents of the specified buffer directly to the PDF\n// generation buffer. This is a low-level function that is not required for\n// normal PDF construction. An understanding of the PDF specification is needed\n// to use this method correctly.\nfunc (f *Fpdf) RawWriteBuf(r io.Reader) {\n\tf.outbuf(r)\n}\n\n// outf adds a formatted line to the document\nfunc (f *Fpdf) outf(fmtStr string, args ...interface{}) {\n\tf.out(sprintf(fmtStr, args...))\n}\n\n// SetDefaultCatalogSort sets the default value of the catalog sort flag that\n// will be used when initializing a new Fpdf instance. See SetCatalogSort() for\n// more details.\nfunc SetDefaultCatalogSort(flag bool) {\n\tgl.catalogSort = flag\n}\n\n// SetCatalogSort sets a flag that will be used, if true, to consistently order\n// the document's internal resource catalogs. This method is typically only\n// used for test purposes to facilitate PDF comparison.\nfunc (f *Fpdf) SetCatalogSort(flag bool) {\n\tf.catalogSort = flag\n}\n\n// SetDefaultCreationDate sets the default value of the document creation date\n// that will be used when initializing a new Fpdf instance. See\n// SetCreationDate() for more details.\nfunc SetDefaultCreationDate(tm time.Time) {\n\tgl.creationDate = tm\n}\n\n// SetDefaultModificationDate sets the default value of the document modification date\n// that will be used when initializing a new Fpdf instance. See\n// SetCreationDate() for more details.\nfunc SetDefaultModificationDate(tm time.Time) {\n\tgl.modDate = tm\n}\n\n// SetCreationDate fixes the document's internal CreationDate value. By\n// default, the time when the document is generated is used for this value.\n// This method is typically only used for testing purposes to facilitate PDF\n// comparison. Specify a zero-value time to revert to the default behavior.\nfunc (f *Fpdf) SetCreationDate(tm time.Time) {\n\tf.creationDate = tm\n}\n\n// SetModificationDate fixes the document's internal ModDate value.\n// See `SetCreationDate` for more details.\nfunc (f *Fpdf) SetModificationDate(tm time.Time) {\n\tf.modDate = tm\n}\n\n// SetJavascript adds Adobe JavaScript to the document.\nfunc (f *Fpdf) SetJavascript(script string) {\n\tf.javascript = &script\n}\n\n// RegisterAlias adds an (alias, replacement) pair to the document so we can\n// replace all occurrences of that alias after writing but before the document\n// is closed. Functions ExampleFpdf_RegisterAlias() and\n// ExampleFpdf_RegisterAlias_utf8() in fpdf_test.go demonstrate this method.\nfunc (f *Fpdf) RegisterAlias(alias, replacement string) {\n\t// Note: map[string]string assignments embed literal escape (\"\\00\") sequences\n\t// into utf16 key and value strings. Consequently, subsequent search/replace\n\t// operations will fail unexpectedly if utf8toutf16() conversions take place\n\t// here. Instead, conversions are deferred until the actual search/replace\n\t// operation takes place when the PDF output is generated.\n\tf.aliasMap[alias] = replacement\n}\n\nfunc (f *Fpdf) replaceAliases() {\n\tfor mode := 0; mode < 2; mode++ {\n\t\tfor alias, replacement := range f.aliasMap {\n\t\t\tif mode == 1 {\n\t\t\t\talias = utf8toutf16(alias, false)\n\t\t\t\treplacement = utf8toutf16(replacement, false)\n\t\t\t}\n\t\t\tfor n := 1; n <= f.page; n++ {\n\t\t\t\ts := f.pages[n].String()\n\t\t\t\tif strings.Contains(s, alias) {\n\t\t\t\t\ts = strings.Replace(s, alias, replacement, -1)\n\t\t\t\t\tf.pages[n].Truncate(0)\n\t\t\t\t\tf.pages[n].WriteString(s)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc (f *Fpdf) putpages() {\n\tvar wPt, hPt float64\n\tvar pageSize SizeType\n\tvar ok bool\n\tnb := f.page\n\tif len(f.aliasNbPagesStr) > 0 {\n\t\t// Replace number of pages\n\t\tf.RegisterAlias(f.aliasNbPagesStr, sprintf(\"%d\", nb))\n\t}\n\tf.replaceAliases()\n\tif f.defOrientation == \"P\" {\n\t\twPt = f.defPageSize.Wd * f.k\n\t\thPt = f.defPageSize.Ht * f.k\n\t} else {\n\t\twPt = f.defPageSize.Ht * f.k\n\t\thPt = f.defPageSize.Wd * f.k\n\t}\n\tpagesObjectNumbers := make([]int, nb+1) // 1-based\n\tfor n := 1; n <= nb; n++ {\n\t\t// Page\n\t\tf.newobj()\n\t\tpagesObjectNumbers[n] = f.n // save for /Kids\n\t\tf.out(\"<</Type /Page\")\n\t\tf.out(\"/Parent 1 0 R\")\n\t\tpageSize, ok = f.pageSizes[n]\n\t\tif ok {\n\t\t\tf.outf(\"/MediaBox [0 0 %.2f %.2f]\", pageSize.Wd, pageSize.Ht)\n\t\t}\n\t\tfor t, pb := range f.pageBoxes[n] {\n\t\t\tf.outf(\"/%s [%.2f %.2f %.2f %.2f]\", t, pb.X, pb.Y, pb.Wd, pb.Ht)\n\t\t}\n\t\tf.out(\"/Resources 2 0 R\")\n\t\t// Links\n\t\tif len(f.pageLinks[n])+len(f.pageAttachments[n]) > 0 {\n\t\t\tvar annots fmtBuffer\n\t\t\tannots.printf(\"/Annots [\")\n\t\t\tfor _, pl := range f.pageLinks[n] {\n\t\t\t\tannots.printf(\"<</Type /Annot /Subtype /Link /Rect [%.2f %.2f %.2f %.2f] /Border [0 0 0] \",\n\t\t\t\t\tpl.x, pl.y, pl.x+pl.wd, pl.y-pl.ht)\n\t\t\t\tif pl.link == 0 {\n\t\t\t\t\tannots.printf(\"/A <</S /URI /URI %s>>>>\", f.textstring(pl.linkStr))\n\t\t\t\t} else {\n\t\t\t\t\tl := f.links[pl.link]\n\t\t\t\t\tvar sz SizeType\n\t\t\t\t\tvar h float64\n\t\t\t\t\tsz, ok = f.pageSizes[l.page]\n\t\t\t\t\tif ok {\n\t\t\t\t\t\th = sz.Ht\n\t\t\t\t\t} else {\n\t\t\t\t\t\th = hPt\n\t\t\t\t\t}\n\t\t\t\t\t// dbg(\"h [%.2f], l.y [%.2f] f.k [%.2f]\\n\", h, l.y, f.k)\n\t\t\t\t\tannots.printf(\"/Dest [%d 0 R /XYZ 0 %.2f null]>>\", 1+2*l.page, h-l.y*f.k)\n\t\t\t\t}\n\t\t\t}\n\t\t\tf.putAttachmentAnnotationLinks(&annots, n)\n\t\t\tannots.printf(\"]\")\n\t\t\tf.out(annots.String())\n\t\t}\n\t\tif f.pdfVersion > \"1.3\" {\n\t\t\tf.out(\"/Group <</Type /Group /S /Transparency /CS /DeviceRGB>>\")\n\t\t}\n\t\tf.outf(\"/Contents %d 0 R>>\", f.n+1)\n\t\tf.out(\"endobj\")\n\t\t// Page content\n\t\tf.newobj()\n\t\tif f.compress {\n\t\t\tdata := sliceCompress(f.pages[n].Bytes())\n\t\t\tf.outf(\"<</Filter /FlateDecode /Length %d>>\", len(data))\n\t\t\tf.putstream(data)\n\t\t} else {\n\t\t\tf.outf(\"<</Length %d>>\", f.pages[n].Len())\n\t\t\tf.putstream(f.pages[n].Bytes())\n\t\t}\n\t\tf.out(\"endobj\")\n\t}\n\t// Pages root\n\tf.offsets[1] = f.buffer.Len()\n\tf.out(\"1 0 obj\")\n\tf.out(\"<</Type /Pages\")\n\tvar kids fmtBuffer\n\tkids.printf(\"/Kids [\")\n\tfor i := 1; i <= nb; i++ {\n\t\tkids.printf(\"%d 0 R \", pagesObjectNumbers[i])\n\t}\n\tkids.printf(\"]\")\n\tf.out(kids.String())\n\tf.outf(\"/Count %d\", nb)\n\tf.outf(\"/MediaBox [0 0 %.2f %.2f]\", wPt, hPt)\n\tf.out(\">>\")\n\tf.out(\"endobj\")\n}\n\nfunc (f *Fpdf) putfonts() {\n\tif f.err != nil {\n\t\treturn\n\t}\n\tnf := f.n\n\tfor _, diff := range f.diffs {\n\t\t// Encodings\n\t\tf.newobj()\n\t\tf.outf(\"<</Type /Encoding /BaseEncoding /WinAnsiEncoding /Differences [%s]>>\", diff)\n\t\tf.out(\"endobj\")\n\t}\n\t{\n\t\tvar fileList []string\n\t\tvar info fontFileType\n\t\tvar file string\n\t\tfor file = range f.fontFiles {\n\t\t\tfileList = append(fileList, file)\n\t\t}\n\t\tif f.catalogSort {\n\t\t\tsort.SliceStable(fileList, func(i, j int) bool { return fileList[i] < fileList[j] })\n\t\t}\n\t\tfor _, file = range fileList {\n\t\t\tinfo = f.fontFiles[file]\n\t\t\tif info.fontType != \"UTF8\" {\n\t\t\t\tf.newobj()\n\t\t\t\tinfo.n = f.n\n\t\t\t\tf.fontFiles[file] = info\n\n\t\t\t\tvar font []byte\n\n\t\t\t\tif info.embedded {\n\t\t\t\t\tfont = info.content\n\t\t\t\t} else {\n\t\t\t\t\tvar err error\n\t\t\t\t\tfont, err = f.loadFontFile(file)\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\tf.err = err\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcompressed := file[len(file)-2:] == \".z\"\n\t\t\t\tif !compressed && info.length2 > 0 {\n\t\t\t\t\tbuf := font[6:info.length1]\n\t\t\t\t\tbuf = append(buf, font[6+info.length1+6:info.length2]...)\n\t\t\t\t\tfont = buf\n\t\t\t\t}\n\t\t\t\tf.outf(\"<</Length %d\", len(font))\n\t\t\t\tif compressed {\n\t\t\t\t\tf.out(\"/Filter /FlateDecode\")\n\t\t\t\t}\n\t\t\t\tf.outf(\"/Length1 %d\", info.length1)\n\t\t\t\tif info.length2 > 0 {\n\t\t\t\t\tf.outf(\"/Length2 %d /Length3 0\", info.length2)\n\t\t\t\t}\n\t\t\t\tf.out(\">>\")\n\t\t\t\tf.putstream(font)\n\t\t\t\tf.out(\"endobj\")\n\t\t\t}\n\t\t}\n\t}\n\t{\n\t\tvar keyList []string\n\t\tvar font fontDefType\n\t\tvar key string\n\t\tfor key = range f.fonts {\n\t\t\tkeyList = append(keyList, key)\n\t\t}\n\t\tif f.catalogSort {\n\t\t\tsort.SliceStable(keyList, func(i, j int) bool { return keyList[i] < keyList[j] })\n\t\t}\n\t\tfor _, key = range keyList {\n\t\t\tfont = f.fonts[key]\n\t\t\t// Font objects\n\t\t\tfont.N = f.n + 1\n\t\t\tf.fonts[key] = font\n\t\t\ttp := font.Tp\n\t\t\tname := font.Name\n\t\t\tswitch tp {\n\t\t\tcase \"Core\":\n\t\t\t\t// Core font\n\t\t\t\tf.newobj()\n\t\t\t\tf.out(\"<</Type /Font\")\n\t\t\t\tf.outf(\"/BaseFont /%s\", name)\n\t\t\t\tf.out(\"/Subtype /Type1\")\n\t\t\t\tif name != \"Symbol\" && name != \"ZapfDingbats\" {\n\t\t\t\t\tf.out(\"/Encoding /WinAnsiEncoding\")\n\t\t\t\t}\n\t\t\t\tf.out(\">>\")\n\t\t\t\tf.out(\"endobj\")\n\t\t\tcase \"Type1\":\n\t\t\t\tfallthrough\n\t\t\tcase \"TrueType\":\n\t\t\t\t// Additional Type1 or TrueType/OpenType font\n\t\t\t\tf.newobj()\n\t\t\t\tf.out(\"<</Type /Font\")\n\t\t\t\tf.outf(\"/BaseFont /%s\", name)\n\t\t\t\tf.outf(\"/Subtype /%s\", tp)\n\t\t\t\tf.out(\"/FirstChar 32 /LastChar 255\")\n\t\t\t\tf.outf(\"/Widths %d 0 R\", f.n+1)\n\t\t\t\tf.outf(\"/FontDescriptor %d 0 R\", f.n+2)\n\t\t\t\tif font.DiffN > 0 {\n\t\t\t\t\tf.outf(\"/Encoding %d 0 R\", nf+font.DiffN)\n\t\t\t\t} else {\n\t\t\t\t\tf.out(\"/Encoding /WinAnsiEncoding\")\n\t\t\t\t}\n\t\t\t\tf.out(\">>\")\n\t\t\t\tf.out(\"endobj\")\n\t\t\t\t// Widths\n\t\t\t\tf.newobj()\n\t\t\t\tvar s fmtBuffer\n\t\t\t\ts.WriteString(\"[\")\n\t\t\t\tfor j := 32; j < 256; j++ {\n\t\t\t\t\ts.printf(\"%d \", font.Cw[j])\n\t\t\t\t}\n\t\t\t\ts.WriteString(\"]\")\n\t\t\t\tf.out(s.String())\n\t\t\t\tf.out(\"endobj\")\n\t\t\t\t// Descriptor\n\t\t\t\tf.newobj()\n\t\t\t\ts.Truncate(0)\n\t\t\t\ts.printf(\"<</Type /FontDescriptor /FontName /%s \", name)\n\t\t\t\ts.printf(\"/Ascent %d \", font.Desc.Ascent)\n\t\t\t\ts.printf(\"/Descent %d \", font.Desc.Descent)\n\t\t\t\ts.printf(\"/CapHeight %d \", font.Desc.CapHeight)\n\t\t\t\ts.printf(\"/Flags %d \", font.Desc.Flags)\n\t\t\t\ts.printf(\"/FontBBox [%d %d %d %d] \", font.Desc.FontBBox.Xmin, font.Desc.FontBBox.Ymin,\n\t\t\t\t\tfont.Desc.FontBBox.Xmax, font.Desc.FontBBox.Ymax)\n\t\t\t\ts.printf(\"/ItalicAngle %d \", font.Desc.ItalicAngle)\n\t\t\t\ts.printf(\"/StemV %d \", font.Desc.StemV)\n\t\t\t\ts.printf(\"/MissingWidth %d \", font.Desc.MissingWidth)\n\t\t\t\tvar suffix string\n\t\t\t\tif tp != \"Type1\" {\n\t\t\t\t\tsuffix = \"2\"\n\t\t\t\t}\n\t\t\t\ts.printf(\"/FontFile%s %d 0 R>>\", suffix, f.fontFiles[font.File].n)\n\t\t\t\tf.out(s.String())\n\t\t\t\tf.out(\"endobj\")\n\t\t\tcase \"UTF8\":\n\t\t\t\tfontName := \"utf8\" + font.Name\n\t\t\t\tusedRunes := font.usedRunes\n\t\t\t\tdelete(usedRunes, 0)\n\t\t\t\tutf8FontStream := font.utf8File.GenerateCutFont(usedRunes)\n\t\t\t\tutf8FontSize := len(utf8FontStream)\n\t\t\t\tcompressedFontStream := sliceCompress(utf8FontStream)\n\t\t\t\tCodeSignDictionary := font.utf8File.CodeSymbolDictionary\n\t\t\t\tdelete(CodeSignDictionary, 0)\n\n\t\t\t\tf.newobj()\n\t\t\t\tf.out(fmt.Sprintf(\"<</Type /Font\\n/Subtype /Type0\\n/BaseFont /%s\\n/Encoding /Identity-H\\n/DescendantFonts [%d 0 R]\\n/ToUnicode %d 0 R>>\\n\"+\"endobj\", fontName, f.n+1, f.n+2))\n\n\t\t\t\tf.newobj()\n\t\t\t\tf.out(\"<</Type /Font\\n/Subtype /CIDFontType2\\n/BaseFont /\" + fontName + \"\\n\" +\n\t\t\t\t\t\"/CIDSystemInfo \" + strconv.Itoa(f.n+2) + \" 0 R\\n/FontDescriptor \" + strconv.Itoa(f.n+3) + \" 0 R\")\n\t\t\t\tif font.Desc.MissingWidth != 0 {\n\t\t\t\t\tf.out(\"/DW \" + strconv.Itoa(font.Desc.MissingWidth) + \"\")\n\t\t\t\t}\n\t\t\t\tf.generateCIDFontMap(&font, font.utf8File.LastRune)\n\t\t\t\tf.out(\"/CIDToGIDMap \" + strconv.Itoa(f.n+4) + \" 0 R>>\")\n\t\t\t\tf.out(\"endobj\")\n\n\t\t\t\tf.newobj()\n\t\t\t\tf.out(\"<</Length \" + strconv.Itoa(len(toUnicode)) + \">>\")\n\t\t\t\tf.putstream([]byte(toUnicode))\n\t\t\t\tf.out(\"endobj\")\n\n\t\t\t\t// CIDInfo\n\t\t\t\tf.newobj()\n\t\t\t\tf.out(\"<</Registry (Adobe)\\n/Ordering (UCS)\\n/Supplement 0>>\")\n\t\t\t\tf.out(\"endobj\")\n\n\t\t\t\t// Font descriptor\n\t\t\t\tf.newobj()\n\t\t\t\tvar s fmtBuffer\n\t\t\t\ts.printf(\"<</Type /FontDescriptor /FontName /%s\\n /Ascent %d\", fontName, font.Desc.Ascent)\n\t\t\t\ts.printf(\" /Descent %d\", font.Desc.Descent)\n\t\t\t\ts.printf(\" /CapHeight %d\", font.Desc.CapHeight)\n\t\t\t\tv := font.Desc.Flags\n\t\t\t\tv = v | 4\n\t\t\t\tv = v &^ 32\n\t\t\t\ts.printf(\" /Flags %d\", v)\n\t\t\t\ts.printf(\"/FontBBox [%d %d %d %d] \", font.Desc.FontBBox.Xmin, font.Desc.FontBBox.Ymin,\n\t\t\t\t\tfont.Desc.FontBBox.Xmax, font.Desc.FontBBox.Ymax)\n\t\t\t\ts.printf(\" /ItalicAngle %d\", font.Desc.ItalicAngle)\n\t\t\t\ts.printf(\" /StemV %d\", font.Desc.StemV)\n\t\t\t\ts.printf(\" /MissingWidth %d\", font.Desc.MissingWidth)\n\t\t\t\ts.printf(\"/FontFile2 %d 0 R\", f.n+2)\n\t\t\t\ts.printf(\">>\")\n\t\t\t\tf.out(s.String())\n\t\t\t\tf.out(\"endobj\")\n\n\t\t\t\t// Embed CIDToGIDMap\n\t\t\t\tcidToGidMap := make([]byte, 256*256*2)\n\n\t\t\t\tfor cc, glyph := range CodeSignDictionary {\n\t\t\t\t\tcidToGidMap[cc*2] = byte(glyph >> 8)\n\t\t\t\t\tcidToGidMap[cc*2+1] = byte(glyph & 0xFF)\n\t\t\t\t}\n\n\t\t\t\tcidToGidMap = sliceCompress(cidToGidMap)\n\t\t\t\tf.newobj()\n\t\t\t\tf.out(\"<</Length \" + strconv.Itoa(len(cidToGidMap)) + \"/Filter /FlateDecode>>\")\n\t\t\t\tf.putstream(cidToGidMap)\n\t\t\t\tf.out(\"endobj\")\n\n\t\t\t\t//Font file\n\t\t\t\tf.newobj()\n\t\t\t\tf.out(\"<</Length \" + strconv.Itoa(len(compressedFontStream)))\n\t\t\t\tf.out(\"/Filter /FlateDecode\")\n\t\t\t\tf.out(\"/Length1 \" + strconv.Itoa(utf8FontSize))\n\t\t\t\tf.out(\">>\")\n\t\t\t\tf.putstream(compressedFontStream)\n\t\t\t\tf.out(\"endobj\")\n\t\t\tdefault:\n\t\t\t\tf.err = fmt.Errorf(\"unsupported font type: %s\", tp)\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t}\n\treturn\n}\n\nfunc (f *Fpdf) generateCIDFontMap(font *fontDefType, LastRune int) {\n\trangeID := 0\n\tcidArray := make(map[int]*untypedKeyMap)\n\tcidArrayKeys := make([]int, 0)\n\tprevCid := -2\n\tprevWidth := -1\n\tinterval := false\n\tstartCid := 1\n\tcwLen := LastRune + 1\n\n\t// for each character\n\tfor cid := startCid; cid < cwLen; cid++ {\n\t\tif font.Cw[cid] == 0x00 {\n\t\t\tcontinue\n\t\t}\n\t\twidth := font.Cw[cid]\n\t\tif width == 65535 {\n\t\t\twidth = 0\n\t\t}\n\t\tif numb, OK := font.usedRunes[cid]; cid > 255 && (!OK || numb == 0) {\n\t\t\tcontinue\n\t\t}\n\n\t\tif cid == prevCid+1 {\n\t\t\tif width == prevWidth {\n\n\t\t\t\tif width == cidArray[rangeID].get(0) {\n\t\t\t\t\tcidArray[rangeID].put(nil, width)\n\t\t\t\t} else {\n\t\t\t\t\tcidArray[rangeID].pop()\n\t\t\t\t\trangeID = prevCid\n\t\t\t\t\tr := untypedKeyMap{\n\t\t\t\t\t\tvalueSet: make([]int, 0),\n\t\t\t\t\t\tkeySet:   make([]interface{}, 0),\n\t\t\t\t\t}\n\t\t\t\t\tcidArray[rangeID] = &r\n\t\t\t\t\tcidArrayKeys = append(cidArrayKeys, rangeID)\n\t\t\t\t\tcidArray[rangeID].put(nil, prevWidth)\n\t\t\t\t\tcidArray[rangeID].put(nil, width)\n\t\t\t\t}\n\t\t\t\tinterval = true\n\t\t\t\tcidArray[rangeID].put(\"interval\", 1)\n\t\t\t} else {\n\t\t\t\tif interval {\n\t\t\t\t\t// new range\n\t\t\t\t\trangeID = cid\n\t\t\t\t\tr := untypedKeyMap{\n\t\t\t\t\t\tvalueSet: make([]int, 0),\n\t\t\t\t\t\tkeySet:   make([]interface{}, 0),\n\t\t\t\t\t}\n\t\t\t\t\tcidArray[rangeID] = &r\n\t\t\t\t\tcidArrayKeys = append(cidArrayKeys, rangeID)\n\t\t\t\t\tcidArray[rangeID].put(nil, width)\n\t\t\t\t} else {\n\t\t\t\t\tcidArray[rangeID].put(nil, width)\n\t\t\t\t}\n\t\t\t\tinterval = false\n\t\t\t}\n\t\t} else {\n\t\t\trangeID = cid\n\t\t\tr := untypedKeyMap{\n\t\t\t\tvalueSet: make([]int, 0),\n\t\t\t\tkeySet:   make([]interface{}, 0),\n\t\t\t}\n\t\t\tcidArray[rangeID] = &r\n\t\t\tcidArrayKeys = append(cidArrayKeys, rangeID)\n\t\t\tcidArray[rangeID].put(nil, width)\n\t\t\tinterval = false\n\t\t}\n\t\tprevCid = cid\n\t\tprevWidth = width\n\n\t}\n\tpreviousKey := -1\n\tnextKey := -1\n\tisInterval := false\n\tfor g := 0; g < len(cidArrayKeys); {\n\t\tkey := cidArrayKeys[g]\n\t\tws := *cidArray[key]\n\t\tcws := len(ws.keySet)\n\t\tif (key == nextKey) && (!isInterval) && (ws.getIndex(\"interval\") < 0 || cws < 4) {\n\t\t\tif cidArray[key].getIndex(\"interval\") >= 0 {\n\t\t\t\tcidArray[key].delete(\"interval\")\n\t\t\t}\n\t\t\tcidArray[previousKey] = arrayMerge(cidArray[previousKey], cidArray[key])\n\t\t\tcidArrayKeys = remove(cidArrayKeys, key)\n\t\t} else {\n\t\t\tg++\n\t\t\tpreviousKey = key\n\t\t}\n\t\tnextKey = key + cws\n\t\t// ui := ws.getIndex(\"interval\")\n\t\t// ui = ui + 1\n\t\tif ws.getIndex(\"interval\") >= 0 {\n\t\t\tif cws > 3 {\n\t\t\t\tisInterval = true\n\t\t\t} else {\n\t\t\t\tisInterval = false\n\t\t\t}\n\t\t\tcidArray[key].delete(\"interval\")\n\t\t\tnextKey--\n\t\t} else {\n\t\t\tisInterval = false\n\t\t}\n\t}\n\tvar w fmtBuffer\n\tfor _, k := range cidArrayKeys {\n\t\tws := cidArray[k]\n\t\tif len(arrayCountValues(ws.valueSet)) == 1 {\n\t\t\tw.printf(\" %d %d %d\", k, k+len(ws.valueSet)-1, ws.get(0))\n\t\t} else {\n\t\t\tw.printf(\" %d [ %s ]\\n\", k, implode(\" \", ws.valueSet))\n\t\t}\n\t}\n\tf.out(\"/W [\" + w.String() + \" ]\")\n}\n\nfunc implode(sep string, arr []int) string {\n\tvar s fmtBuffer\n\tfor i := 0; i < len(arr)-1; i++ {\n\t\ts.printf(\"%v\", arr[i])\n\t\ts.printf(sep)\n\t}\n\tif len(arr) > 0 {\n\t\ts.printf(\"%v\", arr[len(arr)-1])\n\t}\n\treturn s.String()\n}\n\n// arrayCountValues counts the occurrences of each item in the $mp array.\nfunc arrayCountValues(mp []int) map[int]int {\n\tanswer := make(map[int]int)\n\tfor _, v := range mp {\n\t\tanswer[v] = answer[v] + 1\n\t}\n\treturn answer\n}\n\nfunc (f *Fpdf) loadFontFile(name string) ([]byte, error) {\n\tif f.fontLoader != nil {\n\t\treader, err := f.fontLoader.Open(name)\n\t\tif err == nil {\n\t\t\tdata, err := ioutil.ReadAll(reader)\n\t\t\tif closer, ok := reader.(io.Closer); ok {\n\t\t\t\tcloser.Close()\n\t\t\t}\n\t\t\treturn data, err\n\t\t}\n\t}\n\treturn ioutil.ReadFile(path.Join(f.fontpath, name))\n}\n\nfunc (f *Fpdf) putimages() {\n\tvar keyList []string\n\tvar key string\n\tfor key = range f.images {\n\t\tkeyList = append(keyList, key)\n\t}\n\n\t// Sort the keyList []string by the corresponding image's width.\n\tif f.catalogSort {\n\t\tsort.SliceStable(keyList, func(i, j int) bool { return f.images[keyList[i]].w < f.images[keyList[j]].w })\n\t}\n\n\t// Maintain a list of inserted image SHA-1 hashes, with their\n\t// corresponding object ID number.\n\tinsertedImages := map[string]int{}\n\n\tfor _, key = range keyList {\n\t\timage := f.images[key]\n\n\t\t// Check if this image has already been inserted using it's SHA-1 hash.\n\t\tinsertedImageObjN, isFound := insertedImages[image.i]\n\n\t\t// If found, skip inserting the image as a new object, and\n\t\t// use the object ID from the insertedImages map.\n\t\t// If not, insert the image into the PDF and store the object ID.\n\t\tif isFound {\n\t\t\timage.n = insertedImageObjN\n\t\t} else {\n\t\t\tf.putimage(image)\n\t\t\tinsertedImages[image.i] = image.n\n\t\t}\n\t}\n}\n\nfunc (f *Fpdf) putimage(info *ImageInfoType) {\n\tf.newobj()\n\tinfo.n = f.n\n\tf.out(\"<</Type /XObject\")\n\tf.out(\"/Subtype /Image\")\n\tf.outf(\"/Width %d\", int(info.w))\n\tf.outf(\"/Height %d\", int(info.h))\n\tif info.cs == \"Indexed\" {\n\t\tf.outf(\"/ColorSpace [/Indexed /DeviceRGB %d %d 0 R]\", len(info.pal)/3-1, f.n+1)\n\t} else {\n\t\tf.outf(\"/ColorSpace /%s\", info.cs)\n\t\tif info.cs == \"DeviceCMYK\" {\n\t\t\tf.out(\"/Decode [1 0 1 0 1 0 1 0]\")\n\t\t}\n\t}\n\tf.outf(\"/BitsPerComponent %d\", info.bpc)\n\tif len(info.f) > 0 {\n\t\tf.outf(\"/Filter /%s\", info.f)\n\t}\n\tif len(info.dp) > 0 {\n\t\tf.outf(\"/DecodeParms <<%s>>\", info.dp)\n\t}\n\tif len(info.trns) > 0 {\n\t\tvar trns fmtBuffer\n\t\tfor _, v := range info.trns {\n\t\t\ttrns.printf(\"%d %d \", v, v)\n\t\t}\n\t\tf.outf(\"/Mask [%s]\", trns.String())\n\t}\n\tif info.smask != nil {\n\t\tf.outf(\"/SMask %d 0 R\", f.n+1)\n\t}\n\tf.outf(\"/Length %d>>\", len(info.data))\n\tf.putstream(info.data)\n\tf.out(\"endobj\")\n\t// \tSoft mask\n\tif len(info.smask) > 0 {\n\t\tsmask := &ImageInfoType{\n\t\t\tw:     info.w,\n\t\t\th:     info.h,\n\t\t\tcs:    \"DeviceGray\",\n\t\t\tbpc:   8,\n\t\t\tf:     info.f,\n\t\t\tdp:    sprintf(\"/Predictor 15 /Colors 1 /BitsPerComponent 8 /Columns %d\", int(info.w)),\n\t\t\tdata:  info.smask,\n\t\t\tscale: f.k,\n\t\t}\n\t\tf.putimage(smask)\n\t}\n\t// \tPalette\n\tif info.cs == \"Indexed\" {\n\t\tf.newobj()\n\t\tif f.compress {\n\t\t\tpal := sliceCompress(info.pal)\n\t\t\tf.outf(\"<</Filter /FlateDecode /Length %d>>\", len(pal))\n\t\t\tf.putstream(pal)\n\t\t} else {\n\t\t\tf.outf(\"<</Length %d>>\", len(info.pal))\n\t\t\tf.putstream(info.pal)\n\t\t}\n\t\tf.out(\"endobj\")\n\t}\n}\n\nfunc (f *Fpdf) putxobjectdict() {\n\t{\n\t\tvar image *ImageInfoType\n\t\tvar key string\n\t\tvar keyList []string\n\t\tfor key = range f.images {\n\t\t\tkeyList = append(keyList, key)\n\t\t}\n\t\tif f.catalogSort {\n\t\t\tsort.SliceStable(keyList, func(i, j int) bool { return f.images[keyList[i]].i < f.images[keyList[j]].i })\n\t\t}\n\t\tfor _, key = range keyList {\n\t\t\timage = f.images[key]\n\t\t\tf.outf(\"/I%s %d 0 R\", image.i, image.n)\n\t\t}\n\t}\n\t{\n\t\tvar keyList []string\n\t\tvar key string\n\t\tvar tpl Template\n\t\tkeyList = templateKeyList(f.templates, f.catalogSort)\n\t\tfor _, key = range keyList {\n\t\t\ttpl = f.templates[key]\n\t\t\t// for _, tpl := range f.templates {\n\t\t\tid := tpl.ID()\n\t\t\tif objID, ok := f.templateObjects[id]; ok {\n\t\t\t\tf.outf(\"/TPL%s %d 0 R\", id, objID)\n\t\t\t}\n\t\t}\n\t}\n\t{\n\t\tfor tplName, objID := range f.importedTplObjs {\n\t\t\t// here replace obj id hash with n\n\t\t\tf.outf(\"%s %d 0 R\", tplName, f.importedTplIDs[objID])\n\t\t}\n\t}\n}\n\nfunc (f *Fpdf) putresourcedict() {\n\tf.out(\"/ProcSet [/PDF /Text /ImageB /ImageC /ImageI]\")\n\tf.out(\"/Font <<\")\n\t{\n\t\tvar keyList []string\n\t\tvar font fontDefType\n\t\tvar key string\n\t\tfor key = range f.fonts {\n\t\t\tkeyList = append(keyList, key)\n\t\t}\n\t\tif f.catalogSort {\n\t\t\tsort.SliceStable(keyList, func(i, j int) bool { return f.fonts[keyList[i]].i < f.fonts[keyList[j]].i })\n\t\t}\n\t\tfor _, key = range keyList {\n\t\t\tfont = f.fonts[key]\n\t\t\tf.outf(\"/F%s %d 0 R\", font.i, font.N)\n\t\t}\n\t}\n\tf.out(\">>\")\n\tf.out(\"/XObject <<\")\n\tf.putxobjectdict()\n\tf.out(\">>\")\n\tcount := len(f.blendList)\n\tif count > 1 {\n\t\tf.out(\"/ExtGState <<\")\n\t\tfor j := 1; j < count; j++ {\n\t\t\tf.outf(\"/GS%d %d 0 R\", j, f.blendList[j].objNum)\n\t\t}\n\t\tf.out(\">>\")\n\t}\n\tcount = len(f.gradientList)\n\tif count > 1 {\n\t\tf.out(\"/Shading <<\")\n\t\tfor j := 1; j < count; j++ {\n\t\t\tf.outf(\"/Sh%d %d 0 R\", j, f.gradientList[j].objNum)\n\t\t}\n\t\tf.out(\">>\")\n\t}\n\t// Layers\n\tf.layerPutResourceDict()\n\tf.spotColorPutResourceDict()\n}\n\nfunc (f *Fpdf) putBlendModes() {\n\tcount := len(f.blendList)\n\tfor j := 1; j < count; j++ {\n\t\tbl := f.blendList[j]\n\t\tf.newobj()\n\t\tf.blendList[j].objNum = f.n\n\t\tf.outf(\"<</Type /ExtGState /ca %s /CA %s /BM /%s>>\",\n\t\t\tbl.fillStr, bl.strokeStr, bl.modeStr)\n\t\tf.out(\"endobj\")\n\t}\n}\n\nfunc (f *Fpdf) putGradients() {\n\tcount := len(f.gradientList)\n\tfor j := 1; j < count; j++ {\n\t\tvar f1 int\n\t\tgr := f.gradientList[j]\n\t\tif gr.tp == 2 || gr.tp == 3 {\n\t\t\tf.newobj()\n\t\t\tf.outf(\"<</FunctionType 2 /Domain [0.0 1.0] /C0 [%s] /C1 [%s] /N 1>>\", gr.clr1Str, gr.clr2Str)\n\t\t\tf.out(\"endobj\")\n\t\t\tf1 = f.n\n\t\t}\n\t\tf.newobj()\n\t\tf.outf(\"<</ShadingType %d /ColorSpace /DeviceRGB\", gr.tp)\n\t\tif gr.tp == 2 {\n\t\t\tf.outf(\"/Coords [%.5f %.5f %.5f %.5f] /Function %d 0 R /Extend [true true]>>\",\n\t\t\t\tgr.x1, gr.y1, gr.x2, gr.y2, f1)\n\t\t} else if gr.tp == 3 {\n\t\t\tf.outf(\"/Coords [%.5f %.5f 0 %.5f %.5f %.5f] /Function %d 0 R /Extend [true true]>>\",\n\t\t\t\tgr.x1, gr.y1, gr.x2, gr.y2, gr.r, f1)\n\t\t}\n\t\tf.out(\"endobj\")\n\t\tf.gradientList[j].objNum = f.n\n\t}\n}\n\nfunc (f *Fpdf) putjavascript() {\n\tif f.javascript == nil {\n\t\treturn\n\t}\n\n\tf.newobj()\n\tf.nJs = f.n\n\tf.out(\"<<\")\n\tf.outf(\"/Names [(EmbeddedJS) %d 0 R]\", f.n+1)\n\tf.out(\">>\")\n\tf.out(\"endobj\")\n\tf.newobj()\n\tf.out(\"<<\")\n\tf.out(\"/S /JavaScript\")\n\tf.outf(\"/JS %s\", f.textstring(*f.javascript))\n\tf.out(\">>\")\n\tf.out(\"endobj\")\n}\n\nfunc (f *Fpdf) putresources() {\n\tif f.err != nil {\n\t\treturn\n\t}\n\tf.layerPutLayers()\n\tf.putBlendModes()\n\tf.putGradients()\n\tf.putSpotColors()\n\tf.putfonts()\n\tif f.err != nil {\n\t\treturn\n\t}\n\tf.putimages()\n\tf.putTemplates()\n\tf.putImportedTemplates() // gofpdi\n\t// \tResource dictionary\n\tf.offsets[2] = f.buffer.Len()\n\tf.out(\"2 0 obj\")\n\tf.out(\"<<\")\n\tf.putresourcedict()\n\tf.out(\">>\")\n\tf.out(\"endobj\")\n\tf.putjavascript()\n\tif f.protect.encrypted {\n\t\tf.newobj()\n\t\tf.protect.objNum = f.n\n\t\tf.out(\"<<\")\n\t\tf.out(\"/Filter /Standard\")\n\t\tf.out(\"/V 1\")\n\t\tf.out(\"/R 2\")\n\t\tf.outf(\"/O (%s)\", f.escape(string(f.protect.oValue)))\n\t\tf.outf(\"/U (%s)\", f.escape(string(f.protect.uValue)))\n\t\tf.outf(\"/P %d\", f.protect.pValue)\n\t\tf.out(\">>\")\n\t\tf.out(\"endobj\")\n\t}\n\treturn\n}\n\n// returns Now() if tm is zero\nfunc timeOrNow(tm time.Time) time.Time {\n\tif tm.IsZero() {\n\t\treturn time.Now()\n\t}\n\treturn tm\n}\n\nfunc (f *Fpdf) putinfo() {\n\tif len(f.producer) > 0 {\n\t\tf.outf(\"/Producer %s\", f.textstring(f.producer))\n\t}\n\tif len(f.title) > 0 {\n\t\tf.outf(\"/Title %s\", f.textstring(f.title))\n\t}\n\tif len(f.subject) > 0 {\n\t\tf.outf(\"/Subject %s\", f.textstring(f.subject))\n\t}\n\tif len(f.author) > 0 {\n\t\tf.outf(\"/Author %s\", f.textstring(f.author))\n\t}\n\tif len(f.keywords) > 0 {\n\t\tf.outf(\"/Keywords %s\", f.textstring(f.keywords))\n\t}\n\tif len(f.creator) > 0 {\n\t\tf.outf(\"/Creator %s\", f.textstring(f.creator))\n\t}\n\tcreation := timeOrNow(f.creationDate)\n\tf.outf(\"/CreationDate %s\", f.textstring(\"D:\"+creation.Format(\"20060102150405\")))\n\tmod := timeOrNow(f.modDate)\n\tf.outf(\"/ModDate %s\", f.textstring(\"D:\"+mod.Format(\"20060102150405\")))\n}\n\nfunc (f *Fpdf) putcatalog() {\n\tf.out(\"/Type /Catalog\")\n\tf.out(\"/Pages 1 0 R\")\n\tswitch f.zoomMode {\n\tcase \"fullpage\":\n\t\tf.out(\"/OpenAction [3 0 R /Fit]\")\n\tcase \"fullwidth\":\n\t\tf.out(\"/OpenAction [3 0 R /FitH null]\")\n\tcase \"real\":\n\t\tf.out(\"/OpenAction [3 0 R /XYZ null null 1]\")\n\t}\n\t// } \telse if !is_string($this->zoomMode))\n\t// \t\t$this->out('/OpenAction [3 0 R /XYZ null null '.sprintf('%.2f',$this->zoomMode/100).']');\n\tswitch f.layoutMode {\n\tcase \"single\", \"SinglePage\":\n\t\tf.out(\"/PageLayout /SinglePage\")\n\tcase \"continuous\", \"OneColumn\":\n\t\tf.out(\"/PageLayout /OneColumn\")\n\tcase \"two\", \"TwoColumnLeft\":\n\t\tf.out(\"/PageLayout /TwoColumnLeft\")\n\tcase \"TwoColumnRight\":\n\t\tf.out(\"/PageLayout /TwoColumnRight\")\n\tcase \"TwoPageLeft\", \"TwoPageRight\":\n\t\tif f.pdfVersion < \"1.5\" {\n\t\t\tf.pdfVersion = \"1.5\"\n\t\t}\n\t\tf.out(\"/PageLayout /\" + f.layoutMode)\n\t}\n\t// Bookmarks\n\tif len(f.outlines) > 0 {\n\t\tf.outf(\"/Outlines %d 0 R\", f.outlineRoot)\n\t\tf.out(\"/PageMode /UseOutlines\")\n\t}\n\t// Layers\n\tf.layerPutCatalog()\n\t// Name dictionary :\n\t//\t-> Javascript\n\t//\t-> Embedded files\n\tf.out(\"/Names <<\")\n\t// JavaScript\n\tif f.javascript != nil {\n\t\tf.outf(\"/JavaScript %d 0 R\", f.nJs)\n\t}\n\t// Embedded files\n\tf.outf(\"/EmbeddedFiles %s\", f.getEmbeddedFiles())\n\tf.out(\">>\")\n}\n\nfunc (f *Fpdf) putheader() {\n\tif len(f.blendMap) > 0 && f.pdfVersion < \"1.4\" {\n\t\tf.pdfVersion = \"1.4\"\n\t}\n\tf.outf(\"%%PDF-%s\", f.pdfVersion)\n}\n\nfunc (f *Fpdf) puttrailer() {\n\tf.outf(\"/Size %d\", f.n+1)\n\tf.outf(\"/Root %d 0 R\", f.n)\n\tf.outf(\"/Info %d 0 R\", f.n-1)\n\tif f.protect.encrypted {\n\t\tf.outf(\"/Encrypt %d 0 R\", f.protect.objNum)\n\t\tf.out(\"/ID [()()]\")\n\t}\n}\n\nfunc (f *Fpdf) putxmp() {\n\tif len(f.xmp) == 0 {\n\t\treturn\n\t}\n\tf.newobj()\n\tf.outf(\"<< /Type /Metadata /Subtype /XML /Length %d >>\", len(f.xmp))\n\tf.putstream(f.xmp)\n\tf.out(\"endobj\")\n}\n\nfunc (f *Fpdf) putbookmarks() {\n\tnb := len(f.outlines)\n\tif nb > 0 {\n\t\tlru := make(map[int]int)\n\t\tlevel := 0\n\t\tfor i, o := range f.outlines {\n\t\t\tif o.level > 0 {\n\t\t\t\tparent := lru[o.level-1]\n\t\t\t\tf.outlines[i].parent = parent\n\t\t\t\tf.outlines[parent].last = i\n\t\t\t\tif o.level > level {\n\t\t\t\t\tf.outlines[parent].first = i\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tf.outlines[i].parent = nb\n\t\t\t}\n\t\t\tif o.level <= level && i > 0 {\n\t\t\t\tprev := lru[o.level]\n\t\t\t\tf.outlines[prev].next = i\n\t\t\t\tf.outlines[i].prev = prev\n\t\t\t}\n\t\t\tlru[o.level] = i\n\t\t\tlevel = o.level\n\t\t}\n\t\tn := f.n + 1\n\t\tfor _, o := range f.outlines {\n\t\t\tf.newobj()\n\t\t\tf.outf(\"<</Title %s\", f.textstring(o.text))\n\t\t\tf.outf(\"/Parent %d 0 R\", n+o.parent)\n\t\t\tif o.prev != -1 {\n\t\t\t\tf.outf(\"/Prev %d 0 R\", n+o.prev)\n\t\t\t}\n\t\t\tif o.next != -1 {\n\t\t\t\tf.outf(\"/Next %d 0 R\", n+o.next)\n\t\t\t}\n\t\t\tif o.first != -1 {\n\t\t\t\tf.outf(\"/First %d 0 R\", n+o.first)\n\t\t\t}\n\t\t\tif o.last != -1 {\n\t\t\t\tf.outf(\"/Last %d 0 R\", n+o.last)\n\t\t\t}\n\t\t\tf.outf(\"/Dest [%d 0 R /XYZ 0 %.2f null]\", 1+2*o.p, (f.h-o.y)*f.k)\n\t\t\tf.out(\"/Count 0>>\")\n\t\t\tf.out(\"endobj\")\n\t\t}\n\t\tf.newobj()\n\t\tf.outlineRoot = f.n\n\t\tf.outf(\"<</Type /Outlines /First %d 0 R\", n)\n\t\tf.outf(\"/Last %d 0 R>>\", n+lru[0])\n\t\tf.out(\"endobj\")\n\t}\n}\n\nfunc (f *Fpdf) enddoc() {\n\tif f.err != nil {\n\t\treturn\n\t}\n\tf.layerEndDoc()\n\tf.putheader()\n\t// Embedded files\n\tf.putAttachments()\n\tf.putAnnotationsAttachments()\n\tf.putpages()\n\tf.putresources()\n\tif f.err != nil {\n\t\treturn\n\t}\n\t// Bookmarks\n\tf.putbookmarks()\n\t// Metadata\n\tf.putxmp()\n\t// \tInfo\n\tf.newobj()\n\tf.out(\"<<\")\n\tf.putinfo()\n\tf.out(\">>\")\n\tf.out(\"endobj\")\n\t// \tCatalog\n\tf.newobj()\n\tf.out(\"<<\")\n\tf.putcatalog()\n\tf.out(\">>\")\n\tf.out(\"endobj\")\n\t// Cross-ref\n\to := f.buffer.Len()\n\tf.out(\"xref\")\n\tf.outf(\"0 %d\", f.n+1)\n\tf.out(\"0000000000 65535 f \")\n\tfor j := 1; j <= f.n; j++ {\n\t\tf.outf(\"%010d 00000 n \", f.offsets[j])\n\t}\n\t// Trailer\n\tf.out(\"trailer\")\n\tf.out(\"<<\")\n\tf.puttrailer()\n\tf.out(\">>\")\n\tf.out(\"startxref\")\n\tf.outf(\"%d\", o)\n\tf.out(\"%%EOF\")\n\tf.state = 3\n\treturn\n}\n\n// Path Drawing\n\n// MoveTo moves the stylus to (x, y) without drawing the path from the\n// previous point. Paths must start with a MoveTo to set the original\n// stylus location or the result is undefined.\n//\n// Create a \"path\" by moving a virtual stylus around the page (with\n// MoveTo, LineTo, CurveTo, CurveBezierCubicTo, ArcTo & ClosePath)\n// then draw it or  fill it in (with DrawPath). The main advantage of\n// using the path drawing routines rather than multiple Fpdf.Line is\n// that PDF creates nice line joins at the angles, rather than just\n// overlaying the lines.\nfunc (f *Fpdf) MoveTo(x, y float64) {\n\tf.point(x, y)\n\tf.x, f.y = x, y\n}\n\n// LineTo creates a line from the current stylus location to (x, y), which\n// becomes the new stylus location. Note that this only creates the line in\n// the path; it does not actually draw the line on the page.\n//\n// The MoveTo() example demonstrates this method.\nfunc (f *Fpdf) LineTo(x, y float64) {\n\tf.outf(\"%.2f %.2f l\", x*f.k, (f.h-y)*f.k)\n\tf.x, f.y = x, y\n}\n\n// CurveTo creates a single-segment quadratic Bézier curve. The curve starts at\n// the current stylus location and ends at the point (x, y). The control point\n// (cx, cy) specifies the curvature. At the start point, the curve is tangent\n// to the straight line between the current stylus location and the control\n// point. At the end point, the curve is tangent to the straight line between\n// the end point and the control point.\n//\n// The MoveTo() example demonstrates this method.\nfunc (f *Fpdf) CurveTo(cx, cy, x, y float64) {\n\tf.outf(\"%.5f %.5f %.5f %.5f v\", cx*f.k, (f.h-cy)*f.k, x*f.k, (f.h-y)*f.k)\n\tf.x, f.y = x, y\n}\n\n// CurveBezierCubicTo creates a single-segment cubic Bézier curve. The curve\n// starts at the current stylus location and ends at the point (x, y). The\n// control points (cx0, cy0) and (cx1, cy1) specify the curvature. At the\n// current stylus, the curve is tangent to the straight line between the\n// current stylus location and the control point (cx0, cy0). At the end point,\n// the curve is tangent to the straight line between the end point and the\n// control point (cx1, cy1).\n//\n// The MoveTo() example demonstrates this method.\nfunc (f *Fpdf) CurveBezierCubicTo(cx0, cy0, cx1, cy1, x, y float64) {\n\tf.curve(cx0, cy0, cx1, cy1, x, y)\n\tf.x, f.y = x, y\n}\n\n// ClosePath creates a line from the current location to the last MoveTo point\n// (if not the same) and mark the path as closed so the first and last lines\n// join nicely.\n//\n// The MoveTo() example demonstrates this method.\nfunc (f *Fpdf) ClosePath() {\n\tf.outf(\"h\")\n}\n\n// DrawPath actually draws the path on the page.\n//\n// styleStr can be \"F\" for filled, \"D\" for outlined only, or \"DF\" or \"FD\" for\n// outlined and filled. An empty string will be replaced with \"D\".\n// Path-painting operators as defined in the PDF specification are also\n// allowed: \"S\" (Stroke the path), \"s\" (Close and stroke the path),\n// \"f\" (fill the path, using the nonzero winding number), \"f*\"\n// (Fill the path, using the even-odd rule), \"B\" (Fill and then stroke\n// the path, using the nonzero winding number rule), \"B*\" (Fill and\n// then stroke the path, using the even-odd rule), \"b\" (Close, fill,\n// and then stroke the path, using the nonzero winding number rule) and\n// \"b*\" (Close, fill, and then stroke the path, using the even-odd\n// rule).\n// Drawing uses the current draw color, line width, and cap style\n// centered on the\n// path. Filling uses the current fill color.\n//\n// The MoveTo() example demonstrates this method.\nfunc (f *Fpdf) DrawPath(styleStr string) {\n\tf.outf(fillDrawOp(styleStr))\n}\n\n// ArcTo draws an elliptical arc centered at point (x, y). rx and ry specify its\n// horizontal and vertical radii. If the start of the arc is not at\n// the current position, a connecting line will be drawn.\n//\n// degRotate specifies the angle that the arc will be rotated. degStart and\n// degEnd specify the starting and ending angle of the arc. All angles are\n// specified in degrees and measured counter-clockwise from the 3 o'clock\n// position.\n//\n// styleStr can be \"F\" for filled, \"D\" for outlined only, or \"DF\" or \"FD\" for\n// outlined and filled. An empty string will be replaced with \"D\". Drawing uses\n// the current draw color, line width, and cap style centered on the arc's\n// path. Filling uses the current fill color.\n//\n// The MoveTo() example demonstrates this method.\nfunc (f *Fpdf) ArcTo(x, y, rx, ry, degRotate, degStart, degEnd float64) {\n\tf.arc(x, y, rx, ry, degRotate, degStart, degEnd, \"\", true)\n}\n\nfunc (f *Fpdf) arc(x, y, rx, ry, degRotate, degStart, degEnd float64,\n\tstyleStr string, path bool) {\n\tx *= f.k\n\ty = (f.h - y) * f.k\n\trx *= f.k\n\try *= f.k\n\tsegments := int(degEnd-degStart) / 60\n\tif segments < 2 {\n\t\tsegments = 2\n\t}\n\tangleStart := degStart * math.Pi / 180\n\tangleEnd := degEnd * math.Pi / 180\n\tangleTotal := angleEnd - angleStart\n\tdt := angleTotal / float64(segments)\n\tdtm := dt / 3\n\tif degRotate != 0 {\n\t\ta := -degRotate * math.Pi / 180\n\t\tf.outf(\"q %.5f %.5f %.5f %.5f %.5f %.5f cm\",\n\t\t\tmath.Cos(a), -1*math.Sin(a),\n\t\t\tmath.Sin(a), math.Cos(a), x, y)\n\t\tx = 0\n\t\ty = 0\n\t}\n\tt := angleStart\n\ta0 := x + rx*math.Cos(t)\n\tb0 := y + ry*math.Sin(t)\n\tc0 := -rx * math.Sin(t)\n\td0 := ry * math.Cos(t)\n\tsx := a0 / f.k // start point of arc\n\tsy := f.h - (b0 / f.k)\n\tif path {\n\t\tif f.x != sx || f.y != sy {\n\t\t\t// Draw connecting line to start point\n\t\t\tf.LineTo(sx, sy)\n\t\t}\n\t} else {\n\t\tf.point(sx, sy)\n\t}\n\tfor j := 1; j <= segments; j++ {\n\t\t// Draw this bit of the total curve\n\t\tt = (float64(j) * dt) + angleStart\n\t\ta1 := x + rx*math.Cos(t)\n\t\tb1 := y + ry*math.Sin(t)\n\t\tc1 := -rx * math.Sin(t)\n\t\td1 := ry * math.Cos(t)\n\t\tf.curve((a0+(c0*dtm))/f.k,\n\t\t\tf.h-((b0+(d0*dtm))/f.k),\n\t\t\t(a1-(c1*dtm))/f.k,\n\t\t\tf.h-((b1-(d1*dtm))/f.k),\n\t\t\ta1/f.k,\n\t\t\tf.h-(b1/f.k))\n\t\ta0 = a1\n\t\tb0 = b1\n\t\tc0 = c1\n\t\td0 = d1\n\t\tif path {\n\t\t\tf.x = a1 / f.k\n\t\t\tf.y = f.h - (b1 / f.k)\n\t\t}\n\t}\n\tif !path {\n\t\tf.out(fillDrawOp(styleStr))\n\t}\n\tif degRotate != 0 {\n\t\tf.out(\"Q\")\n\t}\n}\n"
        },
        {
          "name": "fpdf_test.go",
          "type": "blob",
          "size": 85.8466796875,
          "content": "/*\n * Copyright (c) 2013-2015 Kurt Jung (Gmail: kurt.w.jung)\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\n * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\n * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\npackage gofpdf_test\n\nimport (\n\t\"bufio\"\n\t\"bytes\"\n\t\"fmt\"\n\t\"io\"\n\t\"io/ioutil\"\n\t\"math\"\n\t\"math/rand\"\n\t\"net/http\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"strconv\"\n\t\"strings\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/jung-kurt/gofpdf\"\n\t\"github.com/jung-kurt/gofpdf/internal/example\"\n\t\"github.com/jung-kurt/gofpdf/internal/files\"\n)\n\nfunc init() {\n\tcleanup()\n}\n\nfunc cleanup() {\n\tfilepath.Walk(example.PdfDir(),\n\t\tfunc(path string, info os.FileInfo, err error) (reterr error) {\n\t\t\tif info.Mode().IsRegular() {\n\t\t\t\tdir, _ := filepath.Split(path)\n\t\t\t\tif \"reference\" != filepath.Base(dir) {\n\t\t\t\t\tif len(path) > 3 {\n\t\t\t\t\t\tif path[len(path)-4:] == \".pdf\" {\n\t\t\t\t\t\t\tos.Remove(path)\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn\n\t\t})\n}\n\nfunc TestFpdfImplementPdf(t *testing.T) {\n\t// this will not compile if Fpdf and Tpl\n\t// do not implement Pdf\n\tvar _ gofpdf.Pdf = (*gofpdf.Fpdf)(nil)\n\tvar _ gofpdf.Pdf = (*gofpdf.Tpl)(nil)\n}\n\n// TestPagedTemplate ensures new paged templates work\nfunc TestPagedTemplate(t *testing.T) {\n\tpdf := gofpdf.New(\"P\", \"mm\", \"A4\", \"\")\n\ttpl := pdf.CreateTemplate(func(t *gofpdf.Tpl) {\n\t\t// this will be the second page, as a page is already\n\t\t// created by default\n\t\tt.AddPage()\n\t\tt.AddPage()\n\t\tt.AddPage()\n\t})\n\n\tif tpl.NumPages() != 4 {\n\t\tt.Fatalf(\"The template does not have the correct number of pages %d\", tpl.NumPages())\n\t}\n\n\ttplPages := tpl.FromPages()\n\tfor x := 0; x < len(tplPages); x++ {\n\t\tpdf.AddPage()\n\t\tpdf.UseTemplate(tplPages[x])\n\t}\n\n\t// get the last template\n\ttpl2, err := tpl.FromPage(tpl.NumPages())\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t// the objects should be the exact same, as the\n\t// template will represent the last page by default\n\t// therefore no new id should be set, and the object\n\t// should be the same object\n\tif fmt.Sprintf(\"%p\", tpl2) != fmt.Sprintf(\"%p\", tpl) {\n\t\tt.Fatal(\"Template no longer respecting initial template object\")\n\t}\n}\n\n// TestIssue0116 addresses issue 116 in which library silently fails after\n// calling CellFormat when no font has been set.\nfunc TestIssue0116(t *testing.T) {\n\tvar pdf *gofpdf.Fpdf\n\n\tpdf = gofpdf.New(\"P\", \"mm\", \"A4\", \"\")\n\tpdf.AddPage()\n\tpdf.SetFont(\"Arial\", \"B\", 16)\n\tpdf.Cell(40, 10, \"OK\")\n\tif pdf.Error() != nil {\n\t\tt.Fatalf(\"not expecting error when rendering text\")\n\t}\n\n\tpdf = gofpdf.New(\"P\", \"mm\", \"A4\", \"\")\n\tpdf.AddPage()\n\tpdf.Cell(40, 10, \"Not OK\") // Font not set\n\tif pdf.Error() == nil {\n\t\tt.Fatalf(\"expecting error when rendering text without having set font\")\n\t}\n}\n\n// TestIssue0193 addresses issue 193 in which the error io.EOF is incorrectly\n// assigned to the FPDF instance error.\nfunc TestIssue0193(t *testing.T) {\n\tvar png []byte\n\tvar pdf *gofpdf.Fpdf\n\tvar err error\n\tvar rdr *bytes.Reader\n\n\tpng, err = ioutil.ReadFile(example.ImageFile(\"sweden.png\"))\n\tif err == nil {\n\t\trdr = bytes.NewReader(png)\n\t\tpdf = gofpdf.New(\"P\", \"mm\", \"A4\", \"\")\n\t\tpdf.AddPage()\n\t\t_ = pdf.RegisterImageOptionsReader(\"sweden\", gofpdf.ImageOptions{ImageType: \"png\", ReadDpi: true}, rdr)\n\t\terr = pdf.Error()\n\t}\n\tif err != nil {\n\t\tt.Fatalf(\"issue 193 error: %s\", err)\n\t}\n\n}\n\n// TestIssue0209SplitLinesEqualMultiCell addresses issue 209\n// make SplitLines and MultiCell split at the same place\nfunc TestIssue0209SplitLinesEqualMultiCell(t *testing.T) {\n\tvar pdf *gofpdf.Fpdf\n\n\tpdf = gofpdf.New(\"P\", \"mm\", \"A4\", \"\")\n\tpdf.AddPage()\n\tpdf.SetFont(\"Arial\", \"\", 8)\n\t// this sentence should not be splited\n\tstr := \"Guochin Amandine\"\n\tlines := pdf.SplitLines([]byte(str), 26)\n\t_, FontSize := pdf.GetFontSize()\n\ty_start := pdf.GetY()\n\tpdf.MultiCell(26, FontSize, str, \"\", \"L\", false)\n\ty_end := pdf.GetY()\n\n\tif len(lines) != 1 {\n\t\tt.Fatalf(\"expect SplitLines split in one line\")\n\t}\n\tif int(y_end-y_start) != int(FontSize) {\n\t\tt.Fatalf(\"expect MultiCell split in one line %.2f != %.2f\", y_end-y_start, FontSize)\n\t}\n\n\t// this sentence should be splited in two lines\n\tstr = \"Guiochini Amandine\"\n\tlines = pdf.SplitLines([]byte(str), 26)\n\ty_start = pdf.GetY()\n\tpdf.MultiCell(26, FontSize, str, \"\", \"L\", false)\n\ty_end = pdf.GetY()\n\n\tif len(lines) != 2 {\n\t\tt.Fatalf(\"expect SplitLines split in two lines\")\n\t}\n\tif int(y_end-y_start) != int(FontSize*2) {\n\t\tt.Fatalf(\"expect MultiCell split in two lines %.2f != %.2f\", y_end-y_start, FontSize*2)\n\t}\n}\n\n// TestFooterFuncLpi tests to make sure the footer is not call twice and SetFooterFuncLpi can work\n// without SetFooterFunc.\nfunc TestFooterFuncLpi(t *testing.T) {\n\tpdf := gofpdf.New(\"P\", \"mm\", \"A4\", \"\")\n\tvar (\n\t\toldFooterFnc  = \"oldFooterFnc\"\n\t\tbothPages     = \"bothPages\"\n\t\tfirstPageOnly = \"firstPageOnly\"\n\t\tlastPageOnly  = \"lastPageOnly\"\n\t)\n\n\t// This set just for testing, only set SetFooterFuncLpi.\n\tpdf.SetFooterFunc(func() {\n\t\tpdf.SetY(-15)\n\t\tpdf.SetFont(\"Arial\", \"I\", 8)\n\t\tpdf.CellFormat(0, 10, oldFooterFnc,\n\t\t\t\"\", 0, \"C\", false, 0, \"\")\n\t})\n\tpdf.SetFooterFuncLpi(func(lastPage bool) {\n\t\tpdf.SetY(-15)\n\t\tpdf.SetFont(\"Arial\", \"I\", 8)\n\t\tpdf.CellFormat(0, 10, bothPages, \"\", 0, \"L\", false, 0, \"\")\n\t\tif !lastPage {\n\t\t\tpdf.CellFormat(0, 10, firstPageOnly, \"\", 0, \"C\", false, 0, \"\")\n\t\t} else {\n\t\t\tpdf.CellFormat(0, 10, lastPageOnly, \"\", 0, \"C\", false, 0, \"\")\n\t\t}\n\t})\n\tpdf.AddPage()\n\tpdf.SetFont(\"Arial\", \"B\", 16)\n\tfor j := 1; j <= 40; j++ {\n\t\tpdf.CellFormat(0, 10, fmt.Sprintf(\"Printing line number %d\", j),\n\t\t\t\"\", 1, \"\", false, 0, \"\")\n\t}\n\tif pdf.Error() != nil {\n\t\tt.Fatalf(\"not expecting error when rendering text\")\n\t}\n\tw := &bytes.Buffer{}\n\tif err := pdf.Output(w); err != nil {\n\t\tt.Errorf(\"unexpected err: %s\", err)\n\t}\n\tb := w.Bytes()\n\tif bytes.Contains(b, []byte(oldFooterFnc)) {\n\t\tt.Errorf(\"not expecting %s render on pdf when FooterFncLpi is set\", oldFooterFnc)\n\t}\n\tgot := bytes.Count(b, []byte(\"bothPages\"))\n\tif got != 2 {\n\t\tt.Errorf(\"footer %s should render on two page got:%d\", bothPages, got)\n\t}\n\tgot = bytes.Count(b, []byte(firstPageOnly))\n\tif got != 1 {\n\t\tt.Errorf(\"footer %s should render only on first page got: %d\", firstPageOnly, got)\n\t}\n\tgot = bytes.Count(b, []byte(lastPageOnly))\n\tif got != 1 {\n\t\tt.Errorf(\"footer %s should render only on first page got: %d\", lastPageOnly, got)\n\t}\n\tf := bytes.Index(b, []byte(firstPageOnly))\n\tl := bytes.Index(b, []byte(lastPageOnly))\n\tif f > l {\n\t\tt.Errorf(\"index %d (%s) should less than index %d (%s)\", f, firstPageOnly, l, lastPageOnly)\n\t}\n}\n\ntype fontResourceType struct {\n}\n\nfunc (f fontResourceType) Open(name string) (rdr io.Reader, err error) {\n\tvar buf []byte\n\tbuf, err = ioutil.ReadFile(example.FontFile(name))\n\tif err == nil {\n\t\trdr = bytes.NewReader(buf)\n\t\tfmt.Printf(\"Generalized font loader reading %s\\n\", name)\n\t}\n\treturn\n}\n\n// strDelimit converts 'ABCDEFG' to, for example, 'A,BCD,EFG'\nfunc strDelimit(str string, sepstr string, sepcount int) string {\n\tpos := len(str) - sepcount\n\tfor pos > 0 {\n\t\tstr = str[:pos] + sepstr + str[pos:]\n\t\tpos = pos - sepcount\n\t}\n\treturn str\n}\n\nfunc loremList() []string {\n\treturn []string{\n\t\t\"Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod \" +\n\t\t\t\"tempor incididunt ut labore et dolore magna aliqua.\",\n\t\t\"Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut \" +\n\t\t\t\"aliquip ex ea commodo consequat.\",\n\t\t\"Duis aute irure dolor in reprehenderit in voluptate velit esse cillum \" +\n\t\t\t\"dolore eu fugiat nulla pariatur.\",\n\t\t\"Excepteur sint occaecat cupidatat non proident, sunt in culpa qui \" +\n\t\t\t\"officia deserunt mollit anim id est laborum.\",\n\t}\n}\n\nfunc lorem() string {\n\treturn strings.Join(loremList(), \" \")\n}\n\n// Example demonstrates the generation of a simple PDF document. Note that\n// since only core fonts are used (in this case Arial, a synonym for\n// Helvetica), an empty string can be specified for the font directory in the\n// call to New(). Note also that the example.Filename() and example.Summary()\n// functions belong to a separate, internal package and are not part of the\n// gofpdf library. If an error occurs at some point during the construction of\n// the document, subsequent method calls exit immediately and the error is\n// finally retrieved with the output call where it can be handled by the\n// application.\nfunc Example() {\n\tpdf := gofpdf.New(gofpdf.OrientationPortrait, \"mm\", \"A4\", \"\")\n\tpdf.AddPage()\n\tpdf.SetFont(\"Arial\", \"B\", 16)\n\tpdf.Cell(40, 10, \"Hello World!\")\n\tfileStr := example.Filename(\"basic\")\n\terr := pdf.OutputFileAndClose(fileStr)\n\texample.Summary(err, fileStr)\n\t// Output:\n\t// Successfully generated pdf/basic.pdf\n}\n\n// ExampleFpdf_AddPage demonsrates the generation of headers, footers and page breaks.\nfunc ExampleFpdf_AddPage() {\n\tpdf := gofpdf.New(\"P\", \"mm\", \"A4\", \"\")\n\tpdf.SetTopMargin(30)\n\tpdf.SetHeaderFuncMode(func() {\n\t\tpdf.Image(example.ImageFile(\"logo.png\"), 10, 6, 30, 0, false, \"\", 0, \"\")\n\t\tpdf.SetY(5)\n\t\tpdf.SetFont(\"Arial\", \"B\", 15)\n\t\tpdf.Cell(80, 0, \"\")\n\t\tpdf.CellFormat(30, 10, \"Title\", \"1\", 0, \"C\", false, 0, \"\")\n\t\tpdf.Ln(20)\n\t}, true)\n\tpdf.SetFooterFunc(func() {\n\t\tpdf.SetY(-15)\n\t\tpdf.SetFont(\"Arial\", \"I\", 8)\n\t\tpdf.CellFormat(0, 10, fmt.Sprintf(\"Page %d/{nb}\", pdf.PageNo()),\n\t\t\t\"\", 0, \"C\", false, 0, \"\")\n\t})\n\tpdf.AliasNbPages(\"\")\n\tpdf.AddPage()\n\tpdf.SetFont(\"Times\", \"\", 12)\n\tfor j := 1; j <= 40; j++ {\n\t\tpdf.CellFormat(0, 10, fmt.Sprintf(\"Printing line number %d\", j),\n\t\t\t\"\", 1, \"\", false, 0, \"\")\n\t}\n\tfileStr := example.Filename(\"Fpdf_AddPage\")\n\terr := pdf.OutputFileAndClose(fileStr)\n\texample.Summary(err, fileStr)\n\t// Output:\n\t// Successfully generated pdf/Fpdf_AddPage.pdf\n}\n\n// ExampleFpdf_MultiCell demonstrates word-wrapping, line justification and\n// page-breaking.\nfunc ExampleFpdf_MultiCell() {\n\tpdf := gofpdf.New(\"P\", \"mm\", \"A4\", \"\")\n\ttitleStr := \"20000 Leagues Under the Seas\"\n\tpdf.SetTitle(titleStr, false)\n\tpdf.SetAuthor(\"Jules Verne\", false)\n\tpdf.SetHeaderFunc(func() {\n\t\t// Arial bold 15\n\t\tpdf.SetFont(\"Arial\", \"B\", 15)\n\t\t// Calculate width of title and position\n\t\twd := pdf.GetStringWidth(titleStr) + 6\n\t\tpdf.SetX((210 - wd) / 2)\n\t\t// Colors of frame, background and text\n\t\tpdf.SetDrawColor(0, 80, 180)\n\t\tpdf.SetFillColor(230, 230, 0)\n\t\tpdf.SetTextColor(220, 50, 50)\n\t\t// Thickness of frame (1 mm)\n\t\tpdf.SetLineWidth(1)\n\t\t// Title\n\t\tpdf.CellFormat(wd, 9, titleStr, \"1\", 1, \"C\", true, 0, \"\")\n\t\t// Line break\n\t\tpdf.Ln(10)\n\t})\n\tpdf.SetFooterFunc(func() {\n\t\t// Position at 1.5 cm from bottom\n\t\tpdf.SetY(-15)\n\t\t// Arial italic 8\n\t\tpdf.SetFont(\"Arial\", \"I\", 8)\n\t\t// Text color in gray\n\t\tpdf.SetTextColor(128, 128, 128)\n\t\t// Page number\n\t\tpdf.CellFormat(0, 10, fmt.Sprintf(\"Page %d\", pdf.PageNo()),\n\t\t\t\"\", 0, \"C\", false, 0, \"\")\n\t})\n\tchapterTitle := func(chapNum int, titleStr string) {\n\t\t// \t// Arial 12\n\t\tpdf.SetFont(\"Arial\", \"\", 12)\n\t\t// Background color\n\t\tpdf.SetFillColor(200, 220, 255)\n\t\t// Title\n\t\tpdf.CellFormat(0, 6, fmt.Sprintf(\"Chapter %d : %s\", chapNum, titleStr),\n\t\t\t\"\", 1, \"L\", true, 0, \"\")\n\t\t// Line break\n\t\tpdf.Ln(4)\n\t}\n\tchapterBody := func(fileStr string) {\n\t\t// Read text file\n\t\ttxtStr, err := ioutil.ReadFile(fileStr)\n\t\tif err != nil {\n\t\t\tpdf.SetError(err)\n\t\t}\n\t\t// Times 12\n\t\tpdf.SetFont(\"Times\", \"\", 12)\n\t\t// Output justified text\n\t\tpdf.MultiCell(0, 5, string(txtStr), \"\", \"\", false)\n\t\t// Line break\n\t\tpdf.Ln(-1)\n\t\t// Mention in italics\n\t\tpdf.SetFont(\"\", \"I\", 0)\n\t\tpdf.Cell(0, 5, \"(end of excerpt)\")\n\t}\n\tprintChapter := func(chapNum int, titleStr, fileStr string) {\n\t\tpdf.AddPage()\n\t\tchapterTitle(chapNum, titleStr)\n\t\tchapterBody(fileStr)\n\t}\n\tprintChapter(1, \"A RUNAWAY REEF\", example.TextFile(\"20k_c1.txt\"))\n\tprintChapter(2, \"THE PROS AND CONS\", example.TextFile(\"20k_c2.txt\"))\n\tfileStr := example.Filename(\"Fpdf_MultiCell\")\n\terr := pdf.OutputFileAndClose(fileStr)\n\texample.Summary(err, fileStr)\n\t// Output:\n\t// Successfully generated pdf/Fpdf_MultiCell.pdf\n}\n\n// ExampleFpdf_SetLeftMargin demonstrates the generation of a PDF document that has multiple\n// columns. This is accomplished with the SetLeftMargin() and Cell() methods.\nfunc ExampleFpdf_SetLeftMargin() {\n\tvar y0 float64\n\tvar crrntCol int\n\tpdf := gofpdf.New(\"P\", \"mm\", \"A4\", \"\")\n\tpdf.SetDisplayMode(\"fullpage\", \"TwoColumnLeft\")\n\ttitleStr := \"20000 Leagues Under the Seas\"\n\tpdf.SetTitle(titleStr, false)\n\tpdf.SetAuthor(\"Jules Verne\", false)\n\tsetCol := func(col int) {\n\t\t// Set position at a given column\n\t\tcrrntCol = col\n\t\tx := 10.0 + float64(col)*65.0\n\t\tpdf.SetLeftMargin(x)\n\t\tpdf.SetX(x)\n\t}\n\tchapterTitle := func(chapNum int, titleStr string) {\n\t\t// Arial 12\n\t\tpdf.SetFont(\"Arial\", \"\", 12)\n\t\t// Background color\n\t\tpdf.SetFillColor(200, 220, 255)\n\t\t// Title\n\t\tpdf.CellFormat(0, 6, fmt.Sprintf(\"Chapter %d : %s\", chapNum, titleStr),\n\t\t\t\"\", 1, \"L\", true, 0, \"\")\n\t\t// Line break\n\t\tpdf.Ln(4)\n\t\ty0 = pdf.GetY()\n\t}\n\tchapterBody := func(fileStr string) {\n\t\t// Read text file\n\t\ttxtStr, err := ioutil.ReadFile(fileStr)\n\t\tif err != nil {\n\t\t\tpdf.SetError(err)\n\t\t}\n\t\t// Font\n\t\tpdf.SetFont(\"Times\", \"\", 12)\n\t\t// Output text in a 6 cm width column\n\t\tpdf.MultiCell(60, 5, string(txtStr), \"\", \"\", false)\n\t\tpdf.Ln(-1)\n\t\t// Mention\n\t\tpdf.SetFont(\"\", \"I\", 0)\n\t\tpdf.Cell(0, 5, \"(end of excerpt)\")\n\t\t// Go back to first column\n\t\tsetCol(0)\n\t}\n\tprintChapter := func(num int, titleStr, fileStr string) {\n\t\t// Add chapter\n\t\tpdf.AddPage()\n\t\tchapterTitle(num, titleStr)\n\t\tchapterBody(fileStr)\n\t}\n\tpdf.SetAcceptPageBreakFunc(func() bool {\n\t\t// Method accepting or not automatic page break\n\t\tif crrntCol < 2 {\n\t\t\t// Go to next column\n\t\t\tsetCol(crrntCol + 1)\n\t\t\t// Set ordinate to top\n\t\t\tpdf.SetY(y0)\n\t\t\t// Keep on page\n\t\t\treturn false\n\t\t}\n\t\t// Go back to first column\n\t\tsetCol(0)\n\t\t// Page break\n\t\treturn true\n\t})\n\tpdf.SetHeaderFunc(func() {\n\t\t// Arial bold 15\n\t\tpdf.SetFont(\"Arial\", \"B\", 15)\n\t\t// Calculate width of title and position\n\t\twd := pdf.GetStringWidth(titleStr) + 6\n\t\tpdf.SetX((210 - wd) / 2)\n\t\t// Colors of frame, background and text\n\t\tpdf.SetDrawColor(0, 80, 180)\n\t\tpdf.SetFillColor(230, 230, 0)\n\t\tpdf.SetTextColor(220, 50, 50)\n\t\t// Thickness of frame (1 mm)\n\t\tpdf.SetLineWidth(1)\n\t\t// Title\n\t\tpdf.CellFormat(wd, 9, titleStr, \"1\", 1, \"C\", true, 0, \"\")\n\t\t// Line break\n\t\tpdf.Ln(10)\n\t\t// Save ordinate\n\t\ty0 = pdf.GetY()\n\t})\n\tpdf.SetFooterFunc(func() {\n\t\t// Position at 1.5 cm from bottom\n\t\tpdf.SetY(-15)\n\t\t// Arial italic 8\n\t\tpdf.SetFont(\"Arial\", \"I\", 8)\n\t\t// Text color in gray\n\t\tpdf.SetTextColor(128, 128, 128)\n\t\t// Page number\n\t\tpdf.CellFormat(0, 10, fmt.Sprintf(\"Page %d\", pdf.PageNo()),\n\t\t\t\"\", 0, \"C\", false, 0, \"\")\n\t})\n\tprintChapter(1, \"A RUNAWAY REEF\", example.TextFile(\"20k_c1.txt\"))\n\tprintChapter(2, \"THE PROS AND CONS\", example.TextFile(\"20k_c2.txt\"))\n\tfileStr := example.Filename(\"Fpdf_SetLeftMargin_multicolumn\")\n\terr := pdf.OutputFileAndClose(fileStr)\n\texample.Summary(err, fileStr)\n\t// Output:\n\t// Successfully generated pdf/Fpdf_SetLeftMargin_multicolumn.pdf\n}\n\n// ExampleFpdf_SplitLines_tables demonstrates word-wrapped table cells\nfunc ExampleFpdf_SplitLines_tables() {\n\tconst (\n\t\tcolCount = 3\n\t\tcolWd    = 60.0\n\t\tmarginH  = 15.0\n\t\tlineHt   = 5.5\n\t\tcellGap  = 2.0\n\t)\n\t// var colStrList [colCount]string\n\ttype cellType struct {\n\t\tstr  string\n\t\tlist [][]byte\n\t\tht   float64\n\t}\n\tvar (\n\t\tcellList [colCount]cellType\n\t\tcell     cellType\n\t)\n\n\tpdf := gofpdf.New(\"P\", \"mm\", \"A4\", \"\") // 210 x 297\n\theader := [colCount]string{\"Column A\", \"Column B\", \"Column C\"}\n\talignList := [colCount]string{\"L\", \"C\", \"R\"}\n\tstrList := loremList()\n\tpdf.SetMargins(marginH, 15, marginH)\n\tpdf.SetFont(\"Arial\", \"\", 14)\n\tpdf.AddPage()\n\n\t// Headers\n\tpdf.SetTextColor(224, 224, 224)\n\tpdf.SetFillColor(64, 64, 64)\n\tfor colJ := 0; colJ < colCount; colJ++ {\n\t\tpdf.CellFormat(colWd, 10, header[colJ], \"1\", 0, \"CM\", true, 0, \"\")\n\t}\n\tpdf.Ln(-1)\n\tpdf.SetTextColor(24, 24, 24)\n\tpdf.SetFillColor(255, 255, 255)\n\n\t// Rows\n\ty := pdf.GetY()\n\tcount := 0\n\tfor rowJ := 0; rowJ < 2; rowJ++ {\n\t\tmaxHt := lineHt\n\t\t// Cell height calculation loop\n\t\tfor colJ := 0; colJ < colCount; colJ++ {\n\t\t\tcount++\n\t\t\tif count > len(strList) {\n\t\t\t\tcount = 1\n\t\t\t}\n\t\t\tcell.str = strings.Join(strList[0:count], \" \")\n\t\t\tcell.list = pdf.SplitLines([]byte(cell.str), colWd-cellGap-cellGap)\n\t\t\tcell.ht = float64(len(cell.list)) * lineHt\n\t\t\tif cell.ht > maxHt {\n\t\t\t\tmaxHt = cell.ht\n\t\t\t}\n\t\t\tcellList[colJ] = cell\n\t\t}\n\t\t// Cell render loop\n\t\tx := marginH\n\t\tfor colJ := 0; colJ < colCount; colJ++ {\n\t\t\tpdf.Rect(x, y, colWd, maxHt+cellGap+cellGap, \"D\")\n\t\t\tcell = cellList[colJ]\n\t\t\tcellY := y + cellGap + (maxHt-cell.ht)/2\n\t\t\tfor splitJ := 0; splitJ < len(cell.list); splitJ++ {\n\t\t\t\tpdf.SetXY(x+cellGap, cellY)\n\t\t\t\tpdf.CellFormat(colWd-cellGap-cellGap, lineHt, string(cell.list[splitJ]), \"\", 0,\n\t\t\t\t\talignList[colJ], false, 0, \"\")\n\t\t\t\tcellY += lineHt\n\t\t\t}\n\t\t\tx += colWd\n\t\t}\n\t\ty += maxHt + cellGap + cellGap\n\t}\n\n\tfileStr := example.Filename(\"Fpdf_SplitLines_tables\")\n\terr := pdf.OutputFileAndClose(fileStr)\n\texample.Summary(err, fileStr)\n\t// Output:\n\t// Successfully generated pdf/Fpdf_SplitLines_tables.pdf\n}\n\n// ExampleFpdf_CellFormat_tables demonstrates various table styles.\nfunc ExampleFpdf_CellFormat_tables() {\n\tpdf := gofpdf.New(\"P\", \"mm\", \"A4\", \"\")\n\ttype countryType struct {\n\t\tnameStr, capitalStr, areaStr, popStr string\n\t}\n\tcountryList := make([]countryType, 0, 8)\n\theader := []string{\"Country\", \"Capital\", \"Area (sq km)\", \"Pop. (thousands)\"}\n\tloadData := func(fileStr string) {\n\t\tfl, err := os.Open(fileStr)\n\t\tif err == nil {\n\t\t\tscanner := bufio.NewScanner(fl)\n\t\t\tvar c countryType\n\t\t\tfor scanner.Scan() {\n\t\t\t\t// Austria;Vienna;83859;8075\n\t\t\t\tlineStr := scanner.Text()\n\t\t\t\tlist := strings.Split(lineStr, \";\")\n\t\t\t\tif len(list) == 4 {\n\t\t\t\t\tc.nameStr = list[0]\n\t\t\t\t\tc.capitalStr = list[1]\n\t\t\t\t\tc.areaStr = list[2]\n\t\t\t\t\tc.popStr = list[3]\n\t\t\t\t\tcountryList = append(countryList, c)\n\t\t\t\t} else {\n\t\t\t\t\terr = fmt.Errorf(\"error tokenizing %s\", lineStr)\n\t\t\t\t}\n\t\t\t}\n\t\t\tfl.Close()\n\t\t\tif len(countryList) == 0 {\n\t\t\t\terr = fmt.Errorf(\"error loading data from %s\", fileStr)\n\t\t\t}\n\t\t}\n\t\tif err != nil {\n\t\t\tpdf.SetError(err)\n\t\t}\n\t}\n\t// Simple table\n\tbasicTable := func() {\n\t\tleft := (210.0 - 4*40) / 2\n\t\tpdf.SetX(left)\n\t\tfor _, str := range header {\n\t\t\tpdf.CellFormat(40, 7, str, \"1\", 0, \"\", false, 0, \"\")\n\t\t}\n\t\tpdf.Ln(-1)\n\t\tfor _, c := range countryList {\n\t\t\tpdf.SetX(left)\n\t\t\tpdf.CellFormat(40, 6, c.nameStr, \"1\", 0, \"\", false, 0, \"\")\n\t\t\tpdf.CellFormat(40, 6, c.capitalStr, \"1\", 0, \"\", false, 0, \"\")\n\t\t\tpdf.CellFormat(40, 6, c.areaStr, \"1\", 0, \"\", false, 0, \"\")\n\t\t\tpdf.CellFormat(40, 6, c.popStr, \"1\", 0, \"\", false, 0, \"\")\n\t\t\tpdf.Ln(-1)\n\t\t}\n\t}\n\t// Better table\n\timprovedTable := func() {\n\t\t// Column widths\n\t\tw := []float64{40.0, 35.0, 40.0, 45.0}\n\t\twSum := 0.0\n\t\tfor _, v := range w {\n\t\t\twSum += v\n\t\t}\n\t\tleft := (210 - wSum) / 2\n\t\t// \tHeader\n\t\tpdf.SetX(left)\n\t\tfor j, str := range header {\n\t\t\tpdf.CellFormat(w[j], 7, str, \"1\", 0, \"C\", false, 0, \"\")\n\t\t}\n\t\tpdf.Ln(-1)\n\t\t// Data\n\t\tfor _, c := range countryList {\n\t\t\tpdf.SetX(left)\n\t\t\tpdf.CellFormat(w[0], 6, c.nameStr, \"LR\", 0, \"\", false, 0, \"\")\n\t\t\tpdf.CellFormat(w[1], 6, c.capitalStr, \"LR\", 0, \"\", false, 0, \"\")\n\t\t\tpdf.CellFormat(w[2], 6, strDelimit(c.areaStr, \",\", 3),\n\t\t\t\t\"LR\", 0, \"R\", false, 0, \"\")\n\t\t\tpdf.CellFormat(w[3], 6, strDelimit(c.popStr, \",\", 3),\n\t\t\t\t\"LR\", 0, \"R\", false, 0, \"\")\n\t\t\tpdf.Ln(-1)\n\t\t}\n\t\tpdf.SetX(left)\n\t\tpdf.CellFormat(wSum, 0, \"\", \"T\", 0, \"\", false, 0, \"\")\n\t}\n\t// Colored table\n\tfancyTable := func() {\n\t\t// Colors, line width and bold font\n\t\tpdf.SetFillColor(255, 0, 0)\n\t\tpdf.SetTextColor(255, 255, 255)\n\t\tpdf.SetDrawColor(128, 0, 0)\n\t\tpdf.SetLineWidth(.3)\n\t\tpdf.SetFont(\"\", \"B\", 0)\n\t\t// \tHeader\n\t\tw := []float64{40, 35, 40, 45}\n\t\twSum := 0.0\n\t\tfor _, v := range w {\n\t\t\twSum += v\n\t\t}\n\t\tleft := (210 - wSum) / 2\n\t\tpdf.SetX(left)\n\t\tfor j, str := range header {\n\t\t\tpdf.CellFormat(w[j], 7, str, \"1\", 0, \"C\", true, 0, \"\")\n\t\t}\n\t\tpdf.Ln(-1)\n\t\t// Color and font restoration\n\t\tpdf.SetFillColor(224, 235, 255)\n\t\tpdf.SetTextColor(0, 0, 0)\n\t\tpdf.SetFont(\"\", \"\", 0)\n\t\t// \tData\n\t\tfill := false\n\t\tfor _, c := range countryList {\n\t\t\tpdf.SetX(left)\n\t\t\tpdf.CellFormat(w[0], 6, c.nameStr, \"LR\", 0, \"\", fill, 0, \"\")\n\t\t\tpdf.CellFormat(w[1], 6, c.capitalStr, \"LR\", 0, \"\", fill, 0, \"\")\n\t\t\tpdf.CellFormat(w[2], 6, strDelimit(c.areaStr, \",\", 3),\n\t\t\t\t\"LR\", 0, \"R\", fill, 0, \"\")\n\t\t\tpdf.CellFormat(w[3], 6, strDelimit(c.popStr, \",\", 3),\n\t\t\t\t\"LR\", 0, \"R\", fill, 0, \"\")\n\t\t\tpdf.Ln(-1)\n\t\t\tfill = !fill\n\t\t}\n\t\tpdf.SetX(left)\n\t\tpdf.CellFormat(wSum, 0, \"\", \"T\", 0, \"\", false, 0, \"\")\n\t}\n\tloadData(example.TextFile(\"countries.txt\"))\n\tpdf.SetFont(\"Arial\", \"\", 14)\n\tpdf.AddPage()\n\tbasicTable()\n\tpdf.AddPage()\n\timprovedTable()\n\tpdf.AddPage()\n\tfancyTable()\n\tfileStr := example.Filename(\"Fpdf_CellFormat_tables\")\n\terr := pdf.OutputFileAndClose(fileStr)\n\texample.Summary(err, fileStr)\n\t// Output:\n\t// Successfully generated pdf/Fpdf_CellFormat_tables.pdf\n}\n\n// ExampleFpdf_HTMLBasicNew demonstrates internal and external links with and without basic\n// HTML.\nfunc ExampleFpdf_HTMLBasicNew() {\n\tpdf := gofpdf.New(\"P\", \"mm\", \"A4\", \"\")\n\t// First page: manual local link\n\tpdf.AddPage()\n\tpdf.SetFont(\"Helvetica\", \"\", 20)\n\t_, lineHt := pdf.GetFontSize()\n\tpdf.Write(lineHt, \"To find out what's new in this tutorial, click \")\n\tpdf.SetFont(\"\", \"U\", 0)\n\tlink := pdf.AddLink()\n\tpdf.WriteLinkID(lineHt, \"here\", link)\n\tpdf.SetFont(\"\", \"\", 0)\n\t// Second page: image link and basic HTML with link\n\tpdf.AddPage()\n\tpdf.SetLink(link, 0, -1)\n\tpdf.Image(example.ImageFile(\"logo.png\"), 10, 12, 30, 0, false, \"\", 0, \"http://www.fpdf.org\")\n\tpdf.SetLeftMargin(45)\n\tpdf.SetFontSize(14)\n\t_, lineHt = pdf.GetFontSize()\n\thtmlStr := `You can now easily print text mixing different styles: <b>bold</b>, ` +\n\t\t`<i>italic</i>, <u>underlined</u>, or <b><i><u>all at once</u></i></b>!<br><br>` +\n\t\t`<center>You can also center text.</center>` +\n\t\t`<right>Or align it to the right.</right>` +\n\t\t`You can also insert links on text, such as ` +\n\t\t`<a href=\"http://www.fpdf.org\">www.fpdf.org</a>, or on an image: click on the logo.`\n\thtml := pdf.HTMLBasicNew()\n\thtml.Write(lineHt, htmlStr)\n\tfileStr := example.Filename(\"Fpdf_HTMLBasicNew\")\n\terr := pdf.OutputFileAndClose(fileStr)\n\texample.Summary(err, fileStr)\n\t// Output:\n\t// Successfully generated pdf/Fpdf_HTMLBasicNew.pdf\n}\n\n// ExampleFpdf_AddFont demonstrates the use of a non-standard font.\nfunc ExampleFpdf_AddFont() {\n\tpdf := gofpdf.New(\"P\", \"mm\", \"A4\", example.FontDir())\n\tpdf.AddFont(\"Calligrapher\", \"\", \"calligra.json\")\n\tpdf.AddPage()\n\tpdf.SetFont(\"Calligrapher\", \"\", 35)\n\tpdf.Cell(0, 10, \"Enjoy new fonts with FPDF!\")\n\tfileStr := example.Filename(\"Fpdf_AddFont\")\n\terr := pdf.OutputFileAndClose(fileStr)\n\texample.Summary(err, fileStr)\n\t// Output:\n\t// Successfully generated pdf/Fpdf_AddFont.pdf\n}\n\n// ExampleFpdf_WriteAligned demonstrates how to align text with the Write function.\nfunc ExampleFpdf_WriteAligned() {\n\tpdf := gofpdf.New(\"P\", \"mm\", \"A4\", example.FontDir())\n\tpdf.SetLeftMargin(50.0)\n\tpdf.SetRightMargin(50.0)\n\tpdf.AddPage()\n\tpdf.SetFont(\"Helvetica\", \"\", 12)\n\tpdf.WriteAligned(0, 35, \"This text is the default alignment, Left\", \"\")\n\tpdf.Ln(35)\n\tpdf.WriteAligned(0, 35, \"This text is aligned Left\", \"L\")\n\tpdf.Ln(35)\n\tpdf.WriteAligned(0, 35, \"This text is aligned Center\", \"C\")\n\tpdf.Ln(35)\n\tpdf.WriteAligned(0, 35, \"This text is aligned Right\", \"R\")\n\tpdf.Ln(35)\n\tline := \"This can by used to write justified text\"\n\tleftMargin, _, rightMargin, _ := pdf.GetMargins()\n\tpageWidth, _ := pdf.GetPageSize()\n\tpageWidth -= leftMargin + rightMargin\n\tpdf.SetWordSpacing((pageWidth - pdf.GetStringWidth(line)) / float64(strings.Count(line, \" \")))\n\tpdf.WriteAligned(pageWidth, 35, line, \"L\")\n\tfileStr := example.Filename(\"Fpdf_WriteAligned\")\n\terr := pdf.OutputFileAndClose(fileStr)\n\texample.Summary(err, fileStr)\n\t// Output:\n\t// Successfully generated pdf/Fpdf_WriteAligned.pdf\n}\n\n// ExampleFpdf_Image demonstrates how images are included in documents.\nfunc ExampleFpdf_Image() {\n\tpdf := gofpdf.New(\"P\", \"mm\", \"A4\", \"\")\n\tpdf.AddPage()\n\tpdf.SetFont(\"Arial\", \"\", 11)\n\tpdf.Image(example.ImageFile(\"logo.png\"), 10, 10, 30, 0, false, \"\", 0, \"\")\n\tpdf.Text(50, 20, \"logo.png\")\n\tpdf.Image(example.ImageFile(\"logo.gif\"), 10, 40, 30, 0, false, \"\", 0, \"\")\n\tpdf.Text(50, 50, \"logo.gif\")\n\tpdf.Image(example.ImageFile(\"logo-gray.png\"), 10, 70, 30, 0, false, \"\", 0, \"\")\n\tpdf.Text(50, 80, \"logo-gray.png\")\n\tpdf.Image(example.ImageFile(\"logo-rgb.png\"), 10, 100, 30, 0, false, \"\", 0, \"\")\n\tpdf.Text(50, 110, \"logo-rgb.png\")\n\tpdf.Image(example.ImageFile(\"logo.jpg\"), 10, 130, 30, 0, false, \"\", 0, \"\")\n\tpdf.Text(50, 140, \"logo.jpg\")\n\tfileStr := example.Filename(\"Fpdf_Image\")\n\terr := pdf.OutputFileAndClose(fileStr)\n\texample.Summary(err, fileStr)\n\t// Output:\n\t// Successfully generated pdf/Fpdf_Image.pdf\n}\n\n// ExampleFpdf_ImageOptions demonstrates how the AllowNegativePosition field of the\n// ImageOption struct can be used to affect horizontal image placement.\nfunc ExampleFpdf_ImageOptions() {\n\tvar opt gofpdf.ImageOptions\n\n\tpdf := gofpdf.New(\"P\", \"mm\", \"A4\", \"\")\n\tpdf.AddPage()\n\tpdf.SetFont(\"Arial\", \"\", 11)\n\tpdf.SetX(60)\n\topt.ImageType = \"png\"\n\tpdf.ImageOptions(example.ImageFile(\"logo.png\"), -10, 10, 30, 0, false, opt, 0, \"\")\n\topt.AllowNegativePosition = true\n\tpdf.ImageOptions(example.ImageFile(\"logo.png\"), -10, 50, 30, 0, false, opt, 0, \"\")\n\tfileStr := example.Filename(\"Fpdf_ImageOptions\")\n\terr := pdf.OutputFileAndClose(fileStr)\n\texample.Summary(err, fileStr)\n\t// Output:\n\t// Successfully generated pdf/Fpdf_ImageOptions.pdf\n}\n\n// ExampleFpdf_RegisterImageOptionsReader demonstrates how to load an image\n// from a io.Reader (in this case, a file) and register it with options.\nfunc ExampleFpdf_RegisterImageOptionsReader() {\n\tvar (\n\t\topt    gofpdf.ImageOptions\n\t\tpdfStr string\n\t\tfl     *os.File\n\t\terr    error\n\t)\n\n\tpdfStr = example.Filename(\"Fpdf_RegisterImageOptionsReader\")\n\tpdf := gofpdf.New(\"P\", \"mm\", \"A4\", \"\")\n\tpdf.AddPage()\n\tpdf.SetFont(\"Arial\", \"\", 11)\n\tfl, err = os.Open(example.ImageFile(\"logo.png\"))\n\tif err == nil {\n\t\topt.ImageType = \"png\"\n\t\topt.AllowNegativePosition = true\n\t\t_ = pdf.RegisterImageOptionsReader(\"logo\", opt, fl)\n\t\tfl.Close()\n\t\tfor x := -20.0; x <= 40.0; x += 5 {\n\t\t\tpdf.ImageOptions(\"logo\", x, x+30, 0, 0, false, opt, 0, \"\")\n\t\t}\n\t\terr = pdf.OutputFileAndClose(pdfStr)\n\t}\n\texample.Summary(err, pdfStr)\n\t// Output:\n\t// Successfully generated pdf/Fpdf_RegisterImageOptionsReader.pdf\n}\n\n// This example demonstrates Landscape mode with images.\nfunc ExampleFpdf_SetAcceptPageBreakFunc() {\n\tvar y0 float64\n\tvar crrntCol int\n\tloremStr := lorem()\n\tpdf := gofpdf.New(\"L\", \"mm\", \"A4\", \"\")\n\tconst (\n\t\tpageWd = 297.0 // A4 210.0 x 297.0\n\t\tmargin = 10.0\n\t\tgutter = 4\n\t\tcolNum = 3\n\t\tcolWd  = (pageWd - 2*margin - (colNum-1)*gutter) / colNum\n\t)\n\tsetCol := func(col int) {\n\t\tcrrntCol = col\n\t\tx := margin + float64(col)*(colWd+gutter)\n\t\tpdf.SetLeftMargin(x)\n\t\tpdf.SetX(x)\n\t}\n\tpdf.SetHeaderFunc(func() {\n\t\ttitleStr := \"gofpdf\"\n\t\tpdf.SetFont(\"Helvetica\", \"B\", 48)\n\t\twd := pdf.GetStringWidth(titleStr) + 6\n\t\tpdf.SetX((pageWd - wd) / 2)\n\t\tpdf.SetTextColor(128, 128, 160)\n\t\tpdf.Write(12, titleStr[:2])\n\t\tpdf.SetTextColor(128, 128, 128)\n\t\tpdf.Write(12, titleStr[2:])\n\t\tpdf.Ln(20)\n\t\ty0 = pdf.GetY()\n\t})\n\tpdf.SetAcceptPageBreakFunc(func() bool {\n\t\tif crrntCol < colNum-1 {\n\t\t\tsetCol(crrntCol + 1)\n\t\t\tpdf.SetY(y0)\n\t\t\t// Start new column, not new page\n\t\t\treturn false\n\t\t}\n\t\tsetCol(0)\n\t\treturn true\n\t})\n\tpdf.AddPage()\n\tpdf.SetFont(\"Times\", \"\", 12)\n\tfor j := 0; j < 20; j++ {\n\t\tif j == 1 {\n\t\t\tpdf.Image(example.ImageFile(\"fpdf.png\"), -1, 0, colWd, 0, true, \"\", 0, \"\")\n\t\t} else if j == 5 {\n\t\t\tpdf.Image(example.ImageFile(\"golang-gopher.png\"),\n\t\t\t\t-1, 0, colWd, 0, true, \"\", 0, \"\")\n\t\t}\n\t\tpdf.MultiCell(colWd, 5, loremStr, \"\", \"\", false)\n\t\tpdf.Ln(-1)\n\t}\n\tfileStr := example.Filename(\"Fpdf_SetAcceptPageBreakFunc_landscape\")\n\terr := pdf.OutputFileAndClose(fileStr)\n\texample.Summary(err, fileStr)\n\t// Output:\n\t// Successfully generated pdf/Fpdf_SetAcceptPageBreakFunc_landscape.pdf\n}\n\n// This example tests corner cases as reported by the gocov tool.\nfunc ExampleFpdf_SetKeywords() {\n\tvar err error\n\tfileStr := example.Filename(\"Fpdf_SetKeywords\")\n\terr = gofpdf.MakeFont(example.FontFile(\"CalligrapherRegular.pfb\"),\n\t\texample.FontFile(\"cp1252.map\"), example.FontDir(), nil, true)\n\tif err == nil {\n\t\tpdf := gofpdf.New(\"\", \"\", \"\", \"\")\n\t\tpdf.SetFontLocation(example.FontDir())\n\t\tpdf.SetTitle(\"世界\", true)\n\t\tpdf.SetAuthor(\"世界\", true)\n\t\tpdf.SetSubject(\"世界\", true)\n\t\tpdf.SetCreator(\"世界\", true)\n\t\tpdf.SetKeywords(\"世界\", true)\n\t\tpdf.AddFont(\"Calligrapher\", \"\", \"CalligrapherRegular.json\")\n\t\tpdf.AddPage()\n\t\tpdf.SetFont(\"Calligrapher\", \"\", 16)\n\t\tpdf.Writef(5, \"\\x95 %s \\x95\", pdf)\n\t\terr = pdf.OutputFileAndClose(fileStr)\n\t}\n\texample.Summary(err, fileStr)\n\t// Output:\n\t// Successfully generated pdf/Fpdf_SetKeywords.pdf\n}\n\n// ExampleFpdf_Circle demonstrates the construction of various geometric figures,\nfunc ExampleFpdf_Circle() {\n\tconst (\n\t\tthin  = 0.2\n\t\tthick = 3.0\n\t)\n\tpdf := gofpdf.New(\"\", \"\", \"\", \"\")\n\tpdf.SetFont(\"Helvetica\", \"\", 12)\n\tpdf.SetFillColor(200, 200, 220)\n\tpdf.AddPage()\n\n\ty := 15.0\n\tpdf.Text(10, y, \"Circles\")\n\tpdf.SetFillColor(200, 200, 220)\n\tpdf.SetLineWidth(thin)\n\tpdf.Circle(20, y+15, 10, \"D\")\n\tpdf.Circle(45, y+15, 10, \"F\")\n\tpdf.Circle(70, y+15, 10, \"FD\")\n\tpdf.SetLineWidth(thick)\n\tpdf.Circle(95, y+15, 10, \"FD\")\n\tpdf.SetLineWidth(thin)\n\n\ty += 40.0\n\tpdf.Text(10, y, \"Ellipses\")\n\tpdf.SetFillColor(220, 200, 200)\n\tpdf.Ellipse(30, y+15, 20, 10, 0, \"D\")\n\tpdf.Ellipse(75, y+15, 20, 10, 0, \"F\")\n\tpdf.Ellipse(120, y+15, 20, 10, 0, \"FD\")\n\tpdf.SetLineWidth(thick)\n\tpdf.Ellipse(165, y+15, 20, 10, 0, \"FD\")\n\tpdf.SetLineWidth(thin)\n\n\ty += 40.0\n\tpdf.Text(10, y, \"Curves (quadratic)\")\n\tpdf.SetFillColor(220, 220, 200)\n\tpdf.Curve(10, y+30, 15, y-20, 40, y+30, \"D\")\n\tpdf.Curve(45, y+30, 50, y-20, 75, y+30, \"F\")\n\tpdf.Curve(80, y+30, 85, y-20, 110, y+30, \"FD\")\n\tpdf.SetLineWidth(thick)\n\tpdf.Curve(115, y+30, 120, y-20, 145, y+30, \"FD\")\n\tpdf.SetLineCapStyle(\"round\")\n\tpdf.Curve(150, y+30, 155, y-20, 180, y+30, \"FD\")\n\tpdf.SetLineWidth(thin)\n\tpdf.SetLineCapStyle(\"butt\")\n\n\ty += 40.0\n\tpdf.Text(10, y, \"Curves (cubic)\")\n\tpdf.SetFillColor(220, 200, 220)\n\tpdf.CurveBezierCubic(10, y+30, 15, y-20, 10, y+30, 40, y+30, \"D\")\n\tpdf.CurveBezierCubic(45, y+30, 50, y-20, 45, y+30, 75, y+30, \"F\")\n\tpdf.CurveBezierCubic(80, y+30, 85, y-20, 80, y+30, 110, y+30, \"FD\")\n\tpdf.SetLineWidth(thick)\n\tpdf.CurveBezierCubic(115, y+30, 120, y-20, 115, y+30, 145, y+30, \"FD\")\n\tpdf.SetLineCapStyle(\"round\")\n\tpdf.CurveBezierCubic(150, y+30, 155, y-20, 150, y+30, 180, y+30, \"FD\")\n\tpdf.SetLineWidth(thin)\n\tpdf.SetLineCapStyle(\"butt\")\n\n\ty += 40.0\n\tpdf.Text(10, y, \"Arcs\")\n\tpdf.SetFillColor(200, 220, 220)\n\tpdf.SetLineWidth(thick)\n\tpdf.Arc(45, y+35, 20, 10, 0, 0, 180, \"FD\")\n\tpdf.SetLineWidth(thin)\n\tpdf.Arc(45, y+35, 25, 15, 0, 90, 270, \"D\")\n\tpdf.SetLineWidth(thick)\n\tpdf.Arc(45, y+35, 30, 20, 0, 0, 360, \"D\")\n\tpdf.SetLineCapStyle(\"round\")\n\tpdf.Arc(135, y+35, 20, 10, 135, 0, 180, \"FD\")\n\tpdf.SetLineWidth(thin)\n\tpdf.Arc(135, y+35, 25, 15, 135, 90, 270, \"D\")\n\tpdf.SetLineWidth(thick)\n\tpdf.Arc(135, y+35, 30, 20, 135, 0, 360, \"D\")\n\tpdf.SetLineWidth(thin)\n\tpdf.SetLineCapStyle(\"butt\")\n\n\tfileStr := example.Filename(\"Fpdf_Circle_figures\")\n\terr := pdf.OutputFileAndClose(fileStr)\n\texample.Summary(err, fileStr)\n\t// Output:\n\t// Successfully generated pdf/Fpdf_Circle_figures.pdf\n}\n\n// ExampleFpdf_SetAlpha demonstrates alpha transparency.\nfunc ExampleFpdf_SetAlpha() {\n\tconst (\n\t\tgapX  = 10.0\n\t\tgapY  = 9.0\n\t\trectW = 40.0\n\t\trectH = 58.0\n\t\tpageW = 210\n\t\tpageH = 297\n\t)\n\tmodeList := []string{\"Normal\", \"Multiply\", \"Screen\", \"Overlay\",\n\t\t\"Darken\", \"Lighten\", \"ColorDodge\", \"ColorBurn\", \"HardLight\", \"SoftLight\",\n\t\t\"Difference\", \"Exclusion\", \"Hue\", \"Saturation\", \"Color\", \"Luminosity\"}\n\tpdf := gofpdf.New(\"\", \"\", \"\", \"\")\n\tpdf.SetLineWidth(2)\n\tpdf.SetAutoPageBreak(false, 0)\n\tpdf.AddPage()\n\tpdf.SetFont(\"Helvetica\", \"\", 18)\n\tpdf.SetXY(0, gapY)\n\tpdf.SetTextColor(0, 0, 0)\n\tpdf.CellFormat(pageW, gapY, \"Alpha Blending Modes\", \"\", 0, \"C\", false, 0, \"\")\n\tj := 0\n\ty := 3 * gapY\n\tfor col := 0; col < 4; col++ {\n\t\tx := gapX\n\t\tfor row := 0; row < 4; row++ {\n\t\t\tpdf.Rect(x, y, rectW, rectH, \"D\")\n\t\t\tpdf.SetFont(\"Helvetica\", \"B\", 12)\n\t\t\tpdf.SetFillColor(0, 0, 0)\n\t\t\tpdf.SetTextColor(250, 250, 230)\n\t\t\tpdf.SetXY(x, y+rectH-4)\n\t\t\tpdf.CellFormat(rectW, 5, modeList[j], \"\", 0, \"C\", true, 0, \"\")\n\t\t\tpdf.SetFont(\"Helvetica\", \"I\", 150)\n\t\t\tpdf.SetTextColor(80, 80, 120)\n\t\t\tpdf.SetXY(x, y+2)\n\t\t\tpdf.CellFormat(rectW, rectH, \"A\", \"\", 0, \"C\", false, 0, \"\")\n\t\t\tpdf.SetAlpha(0.5, modeList[j])\n\t\t\tpdf.Image(example.ImageFile(\"golang-gopher.png\"),\n\t\t\t\tx-gapX, y, rectW+2*gapX, 0, false, \"\", 0, \"\")\n\t\t\tpdf.SetAlpha(1.0, \"Normal\")\n\t\t\tx += rectW + gapX\n\t\t\tj++\n\t\t}\n\t\ty += rectH + gapY\n\t}\n\tfileStr := example.Filename(\"Fpdf_SetAlpha_transparency\")\n\terr := pdf.OutputFileAndClose(fileStr)\n\texample.Summary(err, fileStr)\n\t// Output:\n\t// Successfully generated pdf/Fpdf_SetAlpha_transparency.pdf\n}\n\n// ExampleFpdf_LinearGradient deomstrates various gradients.\nfunc ExampleFpdf_LinearGradient() {\n\tpdf := gofpdf.New(\"\", \"\", \"\", \"\")\n\tpdf.SetFont(\"Helvetica\", \"\", 12)\n\tpdf.AddPage()\n\tpdf.LinearGradient(0, 0, 210, 100, 250, 250, 255, 220, 220, 225, 0, 0, 0, .5)\n\tpdf.LinearGradient(20, 25, 75, 75, 220, 220, 250, 80, 80, 220, 0, .2, 0, .8)\n\tpdf.Rect(20, 25, 75, 75, \"D\")\n\tpdf.LinearGradient(115, 25, 75, 75, 220, 220, 250, 80, 80, 220, 0, 0, 1, 1)\n\tpdf.Rect(115, 25, 75, 75, \"D\")\n\tpdf.RadialGradient(20, 120, 75, 75, 220, 220, 250, 80, 80, 220,\n\t\t0.25, 0.75, 0.25, 0.75, 1)\n\tpdf.Rect(20, 120, 75, 75, \"D\")\n\tpdf.RadialGradient(115, 120, 75, 75, 220, 220, 250, 80, 80, 220,\n\t\t0.25, 0.75, 0.75, 0.75, 0.75)\n\tpdf.Rect(115, 120, 75, 75, \"D\")\n\tfileStr := example.Filename(\"Fpdf_LinearGradient_gradient\")\n\terr := pdf.OutputFileAndClose(fileStr)\n\texample.Summary(err, fileStr)\n\t// Output:\n\t// Successfully generated pdf/Fpdf_LinearGradient_gradient.pdf\n}\n\n// ExampleFpdf_ClipText demonstrates clipping.\nfunc ExampleFpdf_ClipText() {\n\tpdf := gofpdf.New(\"\", \"\", \"\", \"\")\n\ty := 10.0\n\tpdf.AddPage()\n\n\tpdf.SetFont(\"Helvetica\", \"\", 24)\n\tpdf.SetXY(0, y)\n\tpdf.ClipText(10, y+12, \"Clipping examples\", false)\n\tpdf.RadialGradient(10, y, 100, 20, 128, 128, 160, 32, 32, 48,\n\t\t0.25, 0.5, 0.25, 0.5, 0.2)\n\tpdf.ClipEnd()\n\n\ty += 12\n\tpdf.SetFont(\"Helvetica\", \"B\", 120)\n\tpdf.SetDrawColor(64, 80, 80)\n\tpdf.SetLineWidth(.5)\n\tpdf.ClipText(10, y+40, pdf.String(), true)\n\tpdf.RadialGradient(10, y, 200, 50, 220, 220, 250, 80, 80, 220,\n\t\t0.25, 0.5, 0.25, 0.5, 1)\n\tpdf.ClipEnd()\n\n\ty += 55\n\tpdf.ClipRect(10, y, 105, 20, true)\n\tpdf.SetFillColor(255, 255, 255)\n\tpdf.Rect(10, y, 105, 20, \"F\")\n\tpdf.ClipCircle(40, y+10, 15, false)\n\tpdf.RadialGradient(25, y, 30, 30, 220, 250, 220, 40, 60, 40, 0.3,\n\t\t0.85, 0.3, 0.85, 0.5)\n\tpdf.ClipEnd()\n\tpdf.ClipEllipse(80, y+10, 20, 15, false)\n\tpdf.RadialGradient(60, y, 40, 30, 250, 220, 220, 60, 40, 40, 0.3,\n\t\t0.85, 0.3, 0.85, 0.5)\n\tpdf.ClipEnd()\n\tpdf.ClipEnd()\n\n\ty += 28\n\tpdf.ClipEllipse(26, y+10, 16, 10, true)\n\tpdf.Image(example.ImageFile(\"logo.jpg\"), 10, y, 32, 0, false, \"JPG\", 0, \"\")\n\tpdf.ClipEnd()\n\n\tpdf.ClipCircle(60, y+10, 10, true)\n\tpdf.RadialGradient(50, y, 20, 20, 220, 220, 250, 40, 40, 60, 0.3,\n\t\t0.7, 0.3, 0.7, 0.5)\n\tpdf.ClipEnd()\n\n\tpdf.ClipPolygon([]gofpdf.PointType{{X: 80, Y: y + 20}, {X: 90, Y: y},\n\t\t{X: 100, Y: y + 20}}, true)\n\tpdf.LinearGradient(80, y, 20, 20, 250, 220, 250, 60, 40, 60, 0.5,\n\t\t1, 0.5, 0.5)\n\tpdf.ClipEnd()\n\n\ty += 30\n\tpdf.SetLineWidth(.1)\n\tpdf.SetDrawColor(180, 180, 180)\n\tpdf.ClipRoundedRect(10, y, 120, 20, 5, true)\n\tpdf.RadialGradient(10, y, 120, 20, 255, 255, 255, 240, 240, 220,\n\t\t0.25, 0.75, 0.25, 0.75, 0.5)\n\tpdf.SetXY(5, y-5)\n\tpdf.SetFont(\"Times\", \"\", 12)\n\tpdf.MultiCell(130, 5, lorem(), \"\", \"\", false)\n\tpdf.ClipEnd()\n\n\ty += 30\n\tpdf.SetDrawColor(180, 100, 180)\n\tpdf.ClipRoundedRectExt(10, y, 120, 20, 5, 10, 5, 10, true)\n\tpdf.RadialGradient(10, y, 120, 20, 255, 255, 255, 240, 240, 220,\n\t\t0.25, 0.75, 0.25, 0.75, 0.5)\n\tpdf.SetXY(5, y-5)\n\tpdf.SetFont(\"Times\", \"\", 12)\n\tpdf.MultiCell(130, 5, lorem(), \"\", \"\", false)\n\tpdf.ClipEnd()\n\n\tfileStr := example.Filename(\"Fpdf_ClipText\")\n\terr := pdf.OutputFileAndClose(fileStr)\n\texample.Summary(err, fileStr)\n\t// Output:\n\t// Successfully generated pdf/Fpdf_ClipText.pdf\n}\n\n// ExampleFpdf_PageSize generates a PDF document with various page sizes.\nfunc ExampleFpdf_PageSize() {\n\tpdf := gofpdf.NewCustom(&gofpdf.InitType{\n\t\tUnitStr:    \"in\",\n\t\tSize:       gofpdf.SizeType{Wd: 6, Ht: 6},\n\t\tFontDirStr: example.FontDir(),\n\t})\n\tpdf.SetMargins(0.5, 1, 0.5)\n\tpdf.SetFont(\"Times\", \"\", 14)\n\tpdf.AddPageFormat(\"L\", gofpdf.SizeType{Wd: 3, Ht: 12})\n\tpdf.SetXY(0.5, 1.5)\n\tpdf.CellFormat(11, 0.2, \"12 in x 3 in\", \"\", 0, \"C\", false, 0, \"\")\n\tpdf.AddPage() // Default size established in NewCustom()\n\tpdf.SetXY(0.5, 3)\n\tpdf.CellFormat(5, 0.2, \"6 in x 6 in\", \"\", 0, \"C\", false, 0, \"\")\n\tpdf.AddPageFormat(\"P\", gofpdf.SizeType{Wd: 3, Ht: 12})\n\tpdf.SetXY(0.5, 6)\n\tpdf.CellFormat(2, 0.2, \"3 in x 12 in\", \"\", 0, \"C\", false, 0, \"\")\n\tfor j := 0; j <= 3; j++ {\n\t\twd, ht, u := pdf.PageSize(j)\n\t\tfmt.Printf(\"%d: %6.2f %s, %6.2f %s\\n\", j, wd, u, ht, u)\n\t}\n\tfileStr := example.Filename(\"Fpdf_PageSize\")\n\terr := pdf.OutputFileAndClose(fileStr)\n\texample.Summary(err, fileStr)\n\t// Output:\n\t// 0:   6.00 in,   6.00 in\n\t// 1:  12.00 in,   3.00 in\n\t// 2:   6.00 in,   6.00 in\n\t// 3:   3.00 in,  12.00 in\n\t// Successfully generated pdf/Fpdf_PageSize.pdf\n}\n\n// ExampleFpdf_Bookmark demonstrates the Bookmark method.\nfunc ExampleFpdf_Bookmark() {\n\tpdf := gofpdf.New(\"P\", \"mm\", \"A4\", \"\")\n\tpdf.AddPage()\n\tpdf.SetFont(\"Arial\", \"\", 15)\n\tpdf.Bookmark(\"Page 1\", 0, 0)\n\tpdf.Bookmark(\"Paragraph 1\", 1, -1)\n\tpdf.Cell(0, 6, \"Paragraph 1\")\n\tpdf.Ln(50)\n\tpdf.Bookmark(\"Paragraph 2\", 1, -1)\n\tpdf.Cell(0, 6, \"Paragraph 2\")\n\tpdf.AddPage()\n\tpdf.Bookmark(\"Page 2\", 0, 0)\n\tpdf.Bookmark(\"Paragraph 3\", 1, -1)\n\tpdf.Cell(0, 6, \"Paragraph 3\")\n\tfileStr := example.Filename(\"Fpdf_Bookmark\")\n\terr := pdf.OutputFileAndClose(fileStr)\n\texample.Summary(err, fileStr)\n\t// Output:\n\t// Successfully generated pdf/Fpdf_Bookmark.pdf\n}\n\n// ExampleFpdf_TransformBegin demonstrates various transformations. It is adapted from an\n// example script by Moritz Wagner and Andreas Würmser.\nfunc ExampleFpdf_TransformBegin() {\n\tconst (\n\t\tlight = 200\n\t\tdark  = 0\n\t)\n\tvar refX, refY float64\n\tvar refStr string\n\tpdf := gofpdf.New(\"P\", \"mm\", \"A4\", \"\")\n\tpdf.AddPage()\n\tcolor := func(val int) {\n\t\tpdf.SetDrawColor(val, val, val)\n\t\tpdf.SetTextColor(val, val, val)\n\t}\n\treference := func(str string, x, y float64, val int) {\n\t\tcolor(val)\n\t\tpdf.Rect(x, y, 40, 10, \"D\")\n\t\tpdf.Text(x, y-1, str)\n\t}\n\trefDraw := func(str string, x, y float64) {\n\t\trefStr = str\n\t\trefX = x\n\t\trefY = y\n\t\treference(str, x, y, light)\n\t}\n\trefDupe := func() {\n\t\treference(refStr, refX, refY, dark)\n\t}\n\n\ttitleStr := \"Transformations\"\n\ttitlePt := 36.0\n\ttitleHt := pdf.PointConvert(titlePt)\n\tpdf.SetFont(\"Helvetica\", \"\", titlePt)\n\ttitleWd := pdf.GetStringWidth(titleStr)\n\ttitleX := (210 - titleWd) / 2\n\tpdf.Text(titleX, 10+titleHt, titleStr)\n\tpdf.TransformBegin()\n\tpdf.TransformMirrorVertical(10 + titleHt + 0.5)\n\tpdf.ClipText(titleX, 10+titleHt, titleStr, false)\n\t// Remember that the transform will mirror the gradient box too\n\tpdf.LinearGradient(titleX, 10, titleWd, titleHt+4, 120, 120, 120,\n\t\t255, 255, 255, 0, 0, 0, 0.6)\n\tpdf.ClipEnd()\n\tpdf.TransformEnd()\n\n\tpdf.SetFont(\"Helvetica\", \"\", 12)\n\n\t// Scale by 150% centered by lower left corner of the rectangle\n\trefDraw(\"Scale\", 50, 60)\n\tpdf.TransformBegin()\n\tpdf.TransformScaleXY(150, 50, 70)\n\trefDupe()\n\tpdf.TransformEnd()\n\n\t// Translate 7 to the right, 5 to the bottom\n\trefDraw(\"Translate\", 125, 60)\n\tpdf.TransformBegin()\n\tpdf.TransformTranslate(7, 5)\n\trefDupe()\n\tpdf.TransformEnd()\n\n\t// Rotate 20 degrees counter-clockwise centered by the lower left corner of\n\t// the rectangle\n\trefDraw(\"Rotate\", 50, 110)\n\tpdf.TransformBegin()\n\tpdf.TransformRotate(20, 50, 120)\n\trefDupe()\n\tpdf.TransformEnd()\n\n\t// Skew 30 degrees along the x-axis centered by the lower left corner of the\n\t// rectangle\n\trefDraw(\"Skew\", 125, 110)\n\tpdf.TransformBegin()\n\tpdf.TransformSkewX(30, 125, 110)\n\trefDupe()\n\tpdf.TransformEnd()\n\n\t// Mirror horizontally with axis of reflection at left side of the rectangle\n\trefDraw(\"Mirror horizontal\", 50, 160)\n\tpdf.TransformBegin()\n\tpdf.TransformMirrorHorizontal(50)\n\trefDupe()\n\tpdf.TransformEnd()\n\n\t// Mirror vertically with axis of reflection at bottom side of the rectangle\n\trefDraw(\"Mirror vertical\", 125, 160)\n\tpdf.TransformBegin()\n\tpdf.TransformMirrorVertical(170)\n\trefDupe()\n\tpdf.TransformEnd()\n\n\t// Reflect against a point at the lower left point of rectangle\n\trefDraw(\"Mirror point\", 50, 210)\n\tpdf.TransformBegin()\n\tpdf.TransformMirrorPoint(50, 220)\n\trefDupe()\n\tpdf.TransformEnd()\n\n\t// Mirror against a straight line described by a point and an angle\n\tangle := -20.0\n\tpx := 120.0\n\tpy := 220.0\n\trefDraw(\"Mirror line\", 125, 210)\n\tpdf.TransformBegin()\n\tpdf.TransformRotate(angle, px, py)\n\tpdf.Line(px-1, py-1, px+1, py+1)\n\tpdf.Line(px-1, py+1, px+1, py-1)\n\tpdf.Line(px-5, py, px+60, py)\n\tpdf.TransformEnd()\n\tpdf.TransformBegin()\n\tpdf.TransformMirrorLine(angle, px, py)\n\trefDupe()\n\tpdf.TransformEnd()\n\n\tfileStr := example.Filename(\"Fpdf_TransformBegin\")\n\terr := pdf.OutputFileAndClose(fileStr)\n\texample.Summary(err, fileStr)\n\t// Output:\n\t// Successfully generated pdf/Fpdf_TransformBegin.pdf\n}\n\n// ExampleFpdf_RegisterImage demonstrates Lawrence Kesteloot's image registration code.\nfunc ExampleFpdf_RegisterImage() {\n\tconst (\n\t\tmargin = 10\n\t\twd     = 210\n\t\tht     = 297\n\t)\n\tfileList := []string{\n\t\t\"logo-gray.png\",\n\t\t\"logo.jpg\",\n\t\t\"logo.png\",\n\t\t\"logo-rgb.png\",\n\t\t\"logo-progressive.jpg\",\n\t}\n\tvar infoPtr *gofpdf.ImageInfoType\n\tvar imageFileStr string\n\tvar imgWd, imgHt, lf, tp float64\n\tpdf := gofpdf.New(\"P\", \"mm\", \"A4\", \"\")\n\tpdf.AddPage()\n\tpdf.SetMargins(10, 10, 10)\n\tpdf.SetFont(\"Helvetica\", \"\", 15)\n\tfor j, str := range fileList {\n\t\timageFileStr = example.ImageFile(str)\n\t\tinfoPtr = pdf.RegisterImage(imageFileStr, \"\")\n\t\timgWd, imgHt = infoPtr.Extent()\n\t\tswitch j {\n\t\tcase 0:\n\t\t\tlf = margin\n\t\t\ttp = margin\n\t\tcase 1:\n\t\t\tlf = wd - margin - imgWd\n\t\t\ttp = margin\n\t\tcase 2:\n\t\t\tlf = (wd - imgWd) / 2.0\n\t\t\ttp = (ht - imgHt) / 2.0\n\t\tcase 3:\n\t\t\tlf = margin\n\t\t\ttp = ht - imgHt - margin\n\t\tcase 4:\n\t\t\tlf = wd - imgWd - margin\n\t\t\ttp = ht - imgHt - margin\n\t\t}\n\t\tpdf.Image(imageFileStr, lf, tp, imgWd, imgHt, false, \"\", 0, \"\")\n\t}\n\tfileStr := example.Filename(\"Fpdf_RegisterImage\")\n\t// Test the image information retrieval method\n\tinfoShow := func(imageStr string) {\n\t\timageStr = example.ImageFile(imageStr)\n\t\tinfo := pdf.GetImageInfo(imageStr)\n\t\tif info != nil {\n\t\t\tif info.Width() > 0.0 {\n\t\t\t\tfmt.Printf(\"Image %s is registered\\n\", filepath.ToSlash(imageStr))\n\t\t\t} else {\n\t\t\t\tfmt.Printf(\"Incorrect information for image %s\\n\", filepath.ToSlash(imageStr))\n\t\t\t}\n\t\t} else {\n\t\t\tfmt.Printf(\"Image %s is not registered\\n\", filepath.ToSlash(imageStr))\n\t\t}\n\t}\n\tinfoShow(fileList[0])\n\tinfoShow(\"foo.png\")\n\terr := pdf.OutputFileAndClose(fileStr)\n\texample.Summary(err, fileStr)\n\t// Output:\n\t// Image image/logo-gray.png is registered\n\t// Image image/foo.png is not registered\n\t// Successfully generated pdf/Fpdf_RegisterImage.pdf\n}\n\n// ExampleFpdf_SplitLines demonstrates Bruno Michel's line splitting function.\nfunc ExampleFpdf_SplitLines() {\n\tconst (\n\t\tfontPtSize = 18.0\n\t\twd         = 100.0\n\t)\n\tpdf := gofpdf.New(\"P\", \"mm\", \"A4\", \"\") // A4 210.0 x 297.0\n\tpdf.SetFont(\"Times\", \"\", fontPtSize)\n\t_, lineHt := pdf.GetFontSize()\n\tpdf.AddPage()\n\tpdf.SetMargins(10, 10, 10)\n\tlines := pdf.SplitLines([]byte(lorem()), wd)\n\tht := float64(len(lines)) * lineHt\n\ty := (297.0 - ht) / 2.0\n\tpdf.SetDrawColor(128, 128, 128)\n\tpdf.SetFillColor(255, 255, 210)\n\tx := (210.0 - (wd + 40.0)) / 2.0\n\tpdf.Rect(x, y-20.0, wd+40.0, ht+40.0, \"FD\")\n\tpdf.SetY(y)\n\tfor _, line := range lines {\n\t\tpdf.CellFormat(190.0, lineHt, string(line), \"\", 1, \"C\", false, 0, \"\")\n\t}\n\tfileStr := example.Filename(\"Fpdf_Splitlines\")\n\terr := pdf.OutputFileAndClose(fileStr)\n\texample.Summary(err, fileStr)\n\t// Output:\n\t// Successfully generated pdf/Fpdf_Splitlines.pdf\n}\n\n// ExampleFpdf_SVGBasicWrite demonstrates how to render a simple path-only SVG image of the\n// type generated by the jSignature web control.\nfunc ExampleFpdf_SVGBasicWrite() {\n\tconst (\n\t\tfontPtSize = 16.0\n\t\twd         = 100.0\n\t\tsigFileStr = \"signature.svg\"\n\t)\n\tvar (\n\t\tsig gofpdf.SVGBasicType\n\t\terr error\n\t)\n\tpdf := gofpdf.New(\"P\", \"mm\", \"A4\", \"\") // A4 210.0 x 297.0\n\tpdf.SetFont(\"Times\", \"\", fontPtSize)\n\tlineHt := pdf.PointConvert(fontPtSize)\n\tpdf.AddPage()\n\tpdf.SetMargins(10, 10, 10)\n\thtmlStr := `This example renders a simple ` +\n\t\t`<a href=\"http://www.w3.org/TR/SVG/\">SVG</a> (scalable vector graphics) ` +\n\t\t`image that contains only basic path commands without any styling, ` +\n\t\t`color fill, reflection or endpoint closures. In particular, the ` +\n\t\t`type of vector graphic returned from a ` +\n\t\t`<a href=\"http://willowsystems.github.io/jSignature/#/demo/\">jSignature</a> ` +\n\t\t`web control is supported and is used in this example.`\n\thtml := pdf.HTMLBasicNew()\n\thtml.Write(lineHt, htmlStr)\n\tsig, err = gofpdf.SVGBasicFileParse(example.ImageFile(sigFileStr))\n\tif err == nil {\n\t\tscale := 100 / sig.Wd\n\t\tscaleY := 30 / sig.Ht\n\t\tif scale > scaleY {\n\t\t\tscale = scaleY\n\t\t}\n\t\tpdf.SetLineCapStyle(\"round\")\n\t\tpdf.SetLineWidth(0.25)\n\t\tpdf.SetDrawColor(0, 0, 128)\n\t\tpdf.SetXY((210.0-scale*sig.Wd)/2.0, pdf.GetY()+10)\n\t\tpdf.SVGBasicWrite(&sig, scale)\n\t} else {\n\t\tpdf.SetError(err)\n\t}\n\tfileStr := example.Filename(\"Fpdf_SVGBasicWrite\")\n\terr = pdf.OutputFileAndClose(fileStr)\n\texample.Summary(err, fileStr)\n\t// Output:\n\t// Successfully generated pdf/Fpdf_SVGBasicWrite.pdf\n}\n\n// ExampleFpdf_CellFormat_align demonstrates Stefan Schroeder's code to control vertical\n// alignment.\nfunc ExampleFpdf_CellFormat_align() {\n\ttype recType struct {\n\t\talign, txt string\n\t}\n\trecList := []recType{\n\t\t{\"TL\", \"top left\"},\n\t\t{\"TC\", \"top center\"},\n\t\t{\"TR\", \"top right\"},\n\t\t{\"LM\", \"middle left\"},\n\t\t{\"CM\", \"middle center\"},\n\t\t{\"RM\", \"middle right\"},\n\t\t{\"BL\", \"bottom left\"},\n\t\t{\"BC\", \"bottom center\"},\n\t\t{\"BR\", \"bottom right\"},\n\t}\n\trecListBaseline := []recType{\n\t\t{\"AL\", \"baseline left\"},\n\t\t{\"AC\", \"baseline center\"},\n\t\t{\"AR\", \"baseline right\"},\n\t}\n\tvar formatRect = func(pdf *gofpdf.Fpdf, recList []recType) {\n\t\tlinkStr := \"\"\n\t\tfor pageJ := 0; pageJ < 2; pageJ++ {\n\t\t\tpdf.AddPage()\n\t\t\tpdf.SetMargins(10, 10, 10)\n\t\t\tpdf.SetAutoPageBreak(false, 0)\n\t\t\tborderStr := \"1\"\n\t\t\tfor _, rec := range recList {\n\t\t\t\tpdf.SetXY(20, 20)\n\t\t\t\tpdf.CellFormat(170, 257, rec.txt, borderStr, 0, rec.align, false, 0, linkStr)\n\t\t\t\tborderStr = \"\"\n\t\t\t}\n\t\t\tlinkStr = \"https://github.com/jung-kurt/gofpdf\"\n\t\t}\n\t}\n\tpdf := gofpdf.New(\"P\", \"mm\", \"A4\", \"\") // A4 210.0 x 297.0\n\tpdf.SetFont(\"Helvetica\", \"\", 16)\n\tformatRect(pdf, recList)\n\tformatRect(pdf, recListBaseline)\n\tvar fr fontResourceType\n\tpdf.SetFontLoader(fr)\n\tpdf.AddFont(\"Calligrapher\", \"\", \"calligra.json\")\n\tpdf.SetFont(\"Calligrapher\", \"\", 16)\n\tformatRect(pdf, recListBaseline)\n\tfileStr := example.Filename(\"Fpdf_CellFormat_align\")\n\terr := pdf.OutputFileAndClose(fileStr)\n\texample.Summary(err, fileStr)\n\t// Output:\n\t// Generalized font loader reading calligra.json\n\t// Generalized font loader reading calligra.z\n\t// Successfully generated pdf/Fpdf_CellFormat_align.pdf\n}\n\n// ExampleFpdf_CellFormat_codepageescape demonstrates the use of characters in the high range of the\n// Windows-1252 code page (gofdpf default). See the example for CellFormat (4)\n// for a way to do this automatically.\nfunc ExampleFpdf_CellFormat_codepageescape() {\n\tpdf := gofpdf.New(\"P\", \"mm\", \"A4\", \"\") // A4 210.0 x 297.0\n\tfontSize := 16.0\n\tpdf.SetFont(\"Helvetica\", \"\", fontSize)\n\tht := pdf.PointConvert(fontSize)\n\twrite := func(str string) {\n\t\tpdf.CellFormat(190, ht, str, \"\", 1, \"C\", false, 0, \"\")\n\t\tpdf.Ln(ht)\n\t}\n\tpdf.AddPage()\n\thtmlStr := `Until gofpdf supports UTF-8 encoded source text, source text needs ` +\n\t\t`to be specified with all special characters escaped to match the code page ` +\n\t\t`layout of the currently selected font. By default, gofdpf uses code page 1252.` +\n\t\t` See <a href=\"http://en.wikipedia.org/wiki/Windows-1252\">Wikipedia</a> for ` +\n\t\t`a table of this layout.`\n\thtml := pdf.HTMLBasicNew()\n\thtml.Write(ht, htmlStr)\n\tpdf.Ln(2 * ht)\n\twrite(\"Voix ambigu\\xeb d'un c\\x9cur qui au z\\xe9phyr pr\\xe9f\\xe8re les jattes de kiwi.\")\n\twrite(\"Falsches \\xdcben von Xylophonmusik qu\\xe4lt jeden gr\\xf6\\xdferen Zwerg.\")\n\twrite(\"Heiz\\xf6lr\\xfccksto\\xdfabd\\xe4mpfung\")\n\twrite(\"For\\xe5rsj\\xe6vnd\\xf8gn / Efter\\xe5rsj\\xe6vnd\\xf8gn\")\n\tfileStr := example.Filename(\"Fpdf_CellFormat_codepageescape\")\n\terr := pdf.OutputFileAndClose(fileStr)\n\texample.Summary(err, fileStr)\n\t// Output:\n\t// Successfully generated pdf/Fpdf_CellFormat_codepageescape.pdf\n}\n\n// ExampleFpdf_CellFormat_codepage demonstrates the automatic conversion of UTF-8 strings to an\n// 8-bit font encoding.\nfunc ExampleFpdf_CellFormat_codepage() {\n\tpdf := gofpdf.New(\"P\", \"mm\", \"A4\", example.FontDir()) // A4 210.0 x 297.0\n\t// See documentation for details on how to generate fonts\n\tpdf.AddFont(\"Helvetica-1251\", \"\", \"helvetica_1251.json\")\n\tpdf.AddFont(\"Helvetica-1253\", \"\", \"helvetica_1253.json\")\n\tfontSize := 16.0\n\tpdf.SetFont(\"Helvetica\", \"\", fontSize)\n\tht := pdf.PointConvert(fontSize)\n\ttr := pdf.UnicodeTranslatorFromDescriptor(\"\") // \"\" defaults to \"cp1252\"\n\twrite := func(str string) {\n\t\t// pdf.CellFormat(190, ht, tr(str), \"\", 1, \"C\", false, 0, \"\")\n\t\tpdf.MultiCell(190, ht, tr(str), \"\", \"C\", false)\n\t\tpdf.Ln(ht)\n\t}\n\tpdf.AddPage()\n\tstr := `Gofpdf provides a translator that will convert any UTF-8 code point ` +\n\t\t`that is present in the specified code page.`\n\tpdf.MultiCell(190, ht, str, \"\", \"L\", false)\n\tpdf.Ln(2 * ht)\n\twrite(\"Voix ambiguë d'un cœur qui au zéphyr préfère les jattes de kiwi.\")\n\twrite(\"Falsches Üben von Xylophonmusik quält jeden größeren Zwerg.\")\n\twrite(\"Heizölrückstoßabdämpfung\")\n\twrite(\"Forårsjævndøgn / Efterårsjævndøgn\")\n\twrite(\"À noite, vovô Kowalsky vê o ímã cair no pé do pingüim queixoso e vovó\" +\n\t\t\"põe açúcar no chá de tâmaras do jabuti feliz.\")\n\tpdf.SetFont(\"Helvetica-1251\", \"\", fontSize) // Name matches one specified in AddFont()\n\ttr = pdf.UnicodeTranslatorFromDescriptor(\"cp1251\")\n\twrite(\"Съешь же ещё этих мягких французских булок, да выпей чаю.\")\n\n\tpdf.SetFont(\"Helvetica-1253\", \"\", fontSize)\n\ttr = pdf.UnicodeTranslatorFromDescriptor(\"cp1253\")\n\twrite(\"Θέλει αρετή και τόλμη η ελευθερία. (Ανδρέας Κάλβος)\")\n\n\tfileStr := example.Filename(\"Fpdf_CellFormat_codepage\")\n\terr := pdf.OutputFileAndClose(fileStr)\n\texample.Summary(err, fileStr)\n\t// Output:\n\t// Successfully generated pdf/Fpdf_CellFormat_codepage.pdf\n}\n\n// ExampleFpdf_SetProtection demonstrates password protection for documents.\nfunc ExampleFpdf_SetProtection() {\n\tpdf := gofpdf.New(\"P\", \"mm\", \"A4\", \"\")\n\tpdf.SetProtection(gofpdf.CnProtectPrint, \"123\", \"abc\")\n\tpdf.AddPage()\n\tpdf.SetFont(\"Arial\", \"\", 12)\n\tpdf.Write(10, \"Password-protected.\")\n\tfileStr := example.Filename(\"Fpdf_SetProtection\")\n\terr := pdf.OutputFileAndClose(fileStr)\n\texample.Summary(err, fileStr)\n\t// Output:\n\t// Successfully generated pdf/Fpdf_SetProtection.pdf\n}\n\n// ExampleFpdf_Polygon displays equilateral polygons in a demonstration of the Polygon\n// function.\nfunc ExampleFpdf_Polygon() {\n\tconst rowCount = 5\n\tconst colCount = 4\n\tconst ptSize = 36\n\tvar x, y, radius, gap, advance float64\n\tvar rgVal int\n\tvar pts []gofpdf.PointType\n\tvertices := func(count int) (res []gofpdf.PointType) {\n\t\tvar pt gofpdf.PointType\n\t\tres = make([]gofpdf.PointType, 0, count)\n\t\tmlt := 2.0 * math.Pi / float64(count)\n\t\tfor j := 0; j < count; j++ {\n\t\t\tpt.Y, pt.X = math.Sincos(float64(j) * mlt)\n\t\t\tres = append(res, gofpdf.PointType{\n\t\t\t\tX: x + radius*pt.X,\n\t\t\t\tY: y + radius*pt.Y})\n\t\t}\n\t\treturn\n\t}\n\tpdf := gofpdf.New(\"P\", \"mm\", \"A4\", \"\") // A4 210.0 x 297.0\n\tpdf.AddPage()\n\tpdf.SetFont(\"Helvetica\", \"\", ptSize)\n\tpdf.SetDrawColor(0, 80, 180)\n\tgap = 12.0\n\tpdf.SetY(gap)\n\tpdf.CellFormat(190.0, gap, \"Equilateral polygons\", \"\", 1, \"C\", false, 0, \"\")\n\tradius = (210.0 - float64(colCount+1)*gap) / (2.0 * float64(colCount))\n\tadvance = gap + 2.0*radius\n\ty = 2*gap + pdf.PointConvert(ptSize) + radius\n\trgVal = 230\n\tfor row := 0; row < rowCount; row++ {\n\t\tpdf.SetFillColor(rgVal, rgVal, 0)\n\t\trgVal -= 12\n\t\tx = gap + radius\n\t\tfor col := 0; col < colCount; col++ {\n\t\t\tpts = vertices(row*colCount + col + 3)\n\t\t\tpdf.Polygon(pts, \"FD\")\n\t\t\tx += advance\n\t\t}\n\t\ty += advance\n\t}\n\tfileStr := example.Filename(\"Fpdf_Polygon\")\n\terr := pdf.OutputFileAndClose(fileStr)\n\texample.Summary(err, fileStr)\n\t// Output:\n\t// Successfully generated pdf/Fpdf_Polygon.pdf\n}\n\n// ExampleFpdf_AddLayer demonstrates document layers. The initial visibility of a layer\n// is specified with the second parameter to AddLayer(). The layer list\n// displayed by the document reader allows layer visibility to be controlled\n// interactively.\nfunc ExampleFpdf_AddLayer() {\n\n\tpdf := gofpdf.New(\"P\", \"mm\", \"A4\", \"\")\n\tpdf.AddPage()\n\tpdf.SetFont(\"Arial\", \"\", 15)\n\tpdf.Write(8, \"This line doesn't belong to any layer.\\n\")\n\n\t// Define layers\n\tl1 := pdf.AddLayer(\"Layer 1\", true)\n\tl2 := pdf.AddLayer(\"Layer 2\", true)\n\n\t// Open layer pane in PDF viewer\n\tpdf.OpenLayerPane()\n\n\t// First layer\n\tpdf.BeginLayer(l1)\n\tpdf.Write(8, \"This line belongs to layer 1.\\n\")\n\tpdf.EndLayer()\n\n\t// Second layer\n\tpdf.BeginLayer(l2)\n\tpdf.Write(8, \"This line belongs to layer 2.\\n\")\n\tpdf.EndLayer()\n\n\t// First layer again\n\tpdf.BeginLayer(l1)\n\tpdf.Write(8, \"This line belongs to layer 1 again.\\n\")\n\tpdf.EndLayer()\n\n\tfileStr := example.Filename(\"Fpdf_AddLayer\")\n\terr := pdf.OutputFileAndClose(fileStr)\n\texample.Summary(err, fileStr)\n\t// Output:\n\t// Successfully generated pdf/Fpdf_AddLayer.pdf\n}\n\n// ExampleFpdf_RegisterImageReader demonstrates the use of an image that is retrieved from a web\n// server.\nfunc ExampleFpdf_RegisterImageReader() {\n\n\tconst (\n\t\tmargin   = 10\n\t\twd       = 210\n\t\tht       = 297\n\t\tfontSize = 15\n\t\turlStr   = \"https://github.com/jung-kurt/gofpdf/blob/master/image/gofpdf.png?raw=true\"\n\t\tmsgStr   = `Images from the web can be easily embedded when a PDF document is generated.`\n\t)\n\n\tvar (\n\t\trsp *http.Response\n\t\terr error\n\t\ttp  string\n\t)\n\n\tpdf := gofpdf.New(\"P\", \"mm\", \"A4\", \"\")\n\tpdf.AddPage()\n\tpdf.SetFont(\"Helvetica\", \"\", fontSize)\n\tln := pdf.PointConvert(fontSize)\n\tpdf.MultiCell(wd-margin-margin, ln, msgStr, \"\", \"L\", false)\n\trsp, err = http.Get(urlStr)\n\tif err == nil {\n\t\ttp = pdf.ImageTypeFromMime(rsp.Header[\"Content-Type\"][0])\n\t\tinfoPtr := pdf.RegisterImageReader(urlStr, tp, rsp.Body)\n\t\tif pdf.Ok() {\n\t\t\timgWd, imgHt := infoPtr.Extent()\n\t\t\tpdf.Image(urlStr, (wd-imgWd)/2.0, pdf.GetY()+ln,\n\t\t\t\timgWd, imgHt, false, tp, 0, \"\")\n\t\t}\n\t} else {\n\t\tpdf.SetError(err)\n\t}\n\tfileStr := example.Filename(\"Fpdf_RegisterImageReader_url\")\n\terr = pdf.OutputFileAndClose(fileStr)\n\texample.Summary(err, fileStr)\n\t// Output:\n\t// Successfully generated pdf/Fpdf_RegisterImageReader_url.pdf\n\n}\n\n// ExampleFpdf_Beziergon demonstrates the Beziergon function.\nfunc ExampleFpdf_Beziergon() {\n\n\tconst (\n\t\tmargin      = 10\n\t\twd          = 210\n\t\tunit        = (wd - 2*margin) / 6\n\t\tht          = 297\n\t\tfontSize    = 15\n\t\tmsgStr      = `Demonstration of Beziergon function`\n\t\tcoefficient = 0.6\n\t\tdelta       = coefficient * unit\n\t\tln          = fontSize * 25.4 / 72\n\t\toffsetX     = (wd - 4*unit) / 2.0\n\t\toffsetY     = offsetX + 2*ln\n\t)\n\n\tsrcList := []gofpdf.PointType{\n\t\t{X: 0, Y: 0},\n\t\t{X: 1, Y: 0},\n\t\t{X: 1, Y: 1},\n\t\t{X: 2, Y: 1},\n\t\t{X: 2, Y: 2},\n\t\t{X: 3, Y: 2},\n\t\t{X: 3, Y: 3},\n\t\t{X: 4, Y: 3},\n\t\t{X: 4, Y: 4},\n\t\t{X: 1, Y: 4},\n\t\t{X: 1, Y: 3},\n\t\t{X: 0, Y: 3},\n\t}\n\n\tctrlList := []gofpdf.PointType{\n\t\t{X: 1, Y: -1},\n\t\t{X: 1, Y: 1},\n\t\t{X: 1, Y: 1},\n\t\t{X: 1, Y: 1},\n\t\t{X: 1, Y: 1},\n\t\t{X: 1, Y: 1},\n\t\t{X: 1, Y: 1},\n\t\t{X: 1, Y: 1},\n\t\t{X: -1, Y: 1},\n\t\t{X: -1, Y: -1},\n\t\t{X: -1, Y: -1},\n\t\t{X: -1, Y: -1},\n\t}\n\n\tpdf := gofpdf.New(\"P\", \"mm\", \"A4\", \"\")\n\tpdf.AddPage()\n\tpdf.SetFont(\"Helvetica\", \"\", fontSize)\n\tfor j, src := range srcList {\n\t\tsrcList[j].X = offsetX + src.X*unit\n\t\tsrcList[j].Y = offsetY + src.Y*unit\n\t}\n\tfor j, ctrl := range ctrlList {\n\t\tctrlList[j].X = ctrl.X * delta\n\t\tctrlList[j].Y = ctrl.Y * delta\n\t}\n\tjPrev := len(srcList) - 1\n\tsrcPrev := srcList[jPrev]\n\tcurveList := []gofpdf.PointType{srcPrev} // point [, control 0, control 1, point]*\n\tcontrol := func(x, y float64) {\n\t\tcurveList = append(curveList, gofpdf.PointType{X: x, Y: y})\n\t}\n\tfor j, src := range srcList {\n\t\tctrl := ctrlList[jPrev]\n\t\tcontrol(srcPrev.X+ctrl.X, srcPrev.Y+ctrl.Y) // Control 0\n\t\tctrl = ctrlList[j]\n\t\tcontrol(src.X-ctrl.X, src.Y-ctrl.Y) // Control 1\n\t\tcurveList = append(curveList, src)  // Destination\n\t\tjPrev = j\n\t\tsrcPrev = src\n\t}\n\tpdf.MultiCell(wd-margin-margin, ln, msgStr, \"\", \"C\", false)\n\tpdf.SetDashPattern([]float64{0.8, 0.8}, 0)\n\tpdf.SetDrawColor(160, 160, 160)\n\tpdf.Polygon(srcList, \"D\")\n\tpdf.SetDashPattern([]float64{}, 0)\n\tpdf.SetDrawColor(64, 64, 128)\n\tpdf.SetLineWidth(pdf.GetLineWidth() * 3)\n\tpdf.Beziergon(curveList, \"D\")\n\tfileStr := example.Filename(\"Fpdf_Beziergon\")\n\terr := pdf.OutputFileAndClose(fileStr)\n\texample.Summary(err, fileStr)\n\t// Output:\n\t// Successfully generated pdf/Fpdf_Beziergon.pdf\n\n}\n\n// ExampleFpdf_SetFontLoader demonstrates loading a non-standard font using a generalized\n// font loader. fontResourceType implements the FontLoader interface and is\n// defined locally in the test source code.\nfunc ExampleFpdf_SetFontLoader() {\n\tvar fr fontResourceType\n\tpdf := gofpdf.New(\"P\", \"mm\", \"A4\", \"\")\n\tpdf.SetFontLoader(fr)\n\tpdf.AddFont(\"Calligrapher\", \"\", \"calligra.json\")\n\tpdf.AddPage()\n\tpdf.SetFont(\"Calligrapher\", \"\", 35)\n\tpdf.Cell(0, 10, \"Load fonts from any source\")\n\tfileStr := example.Filename(\"Fpdf_SetFontLoader\")\n\terr := pdf.OutputFileAndClose(fileStr)\n\texample.Summary(err, fileStr)\n\t// Output:\n\t// Generalized font loader reading calligra.json\n\t// Generalized font loader reading calligra.z\n\t// Successfully generated pdf/Fpdf_SetFontLoader.pdf\n}\n\n// ExampleFpdf_MoveTo demonstrates the Path Drawing functions, such as: MoveTo,\n// LineTo, CurveTo, ..., ClosePath and DrawPath.\nfunc ExampleFpdf_MoveTo() {\n\tpdf := gofpdf.New(\"P\", \"mm\", \"A4\", \"\")\n\tpdf.AddPage()\n\tpdf.MoveTo(20, 20)\n\tpdf.LineTo(170, 20)\n\tpdf.ArcTo(170, 40, 20, 20, 0, 90, 0)\n\tpdf.CurveTo(190, 100, 105, 100)\n\tpdf.CurveBezierCubicTo(20, 100, 105, 200, 20, 200)\n\tpdf.ClosePath()\n\tpdf.SetFillColor(200, 200, 200)\n\tpdf.SetLineWidth(3)\n\tpdf.DrawPath(\"DF\")\n\tfileStr := example.Filename(\"Fpdf_MoveTo_path\")\n\terr := pdf.OutputFileAndClose(fileStr)\n\texample.Summary(err, fileStr)\n\t// Output:\n\t// Successfully generated pdf/Fpdf_MoveTo_path.pdf\n}\n\n// ExampleFpdf_SetLineJoinStyle demonstrates various line cap and line join styles.\nfunc ExampleFpdf_SetLineJoinStyle() {\n\tconst offset = 75.0\n\tpdf := gofpdf.New(\"L\", \"mm\", \"A4\", \"\")\n\tpdf.AddPage()\n\tvar draw = func(cap, join string, x0, y0, x1, y1 float64) {\n\t\t// transform begin & end needed to isolate caps and joins\n\t\tpdf.SetLineCapStyle(cap)\n\t\tpdf.SetLineJoinStyle(join)\n\n\t\t// Draw thick line\n\t\tpdf.SetDrawColor(0x33, 0x33, 0x33)\n\t\tpdf.SetLineWidth(30.0)\n\t\tpdf.MoveTo(x0, y0)\n\t\tpdf.LineTo((x0+x1)/2+offset, (y0+y1)/2)\n\t\tpdf.LineTo(x1, y1)\n\t\tpdf.DrawPath(\"D\")\n\n\t\t// Draw thin helping line\n\t\tpdf.SetDrawColor(0xFF, 0x33, 0x33)\n\t\tpdf.SetLineWidth(2.56)\n\t\tpdf.MoveTo(x0, y0)\n\t\tpdf.LineTo((x0+x1)/2+offset, (y0+y1)/2)\n\t\tpdf.LineTo(x1, y1)\n\t\tpdf.DrawPath(\"D\")\n\n\t}\n\tx := 35.0\n\tcaps := []string{\"butt\", \"square\", \"round\"}\n\tjoins := []string{\"bevel\", \"miter\", \"round\"}\n\tfor i := range caps {\n\t\tdraw(caps[i], joins[i], x, 50, x, 160)\n\t\tx += offset\n\t}\n\tfileStr := example.Filename(\"Fpdf_SetLineJoinStyle_caps\")\n\terr := pdf.OutputFileAndClose(fileStr)\n\texample.Summary(err, fileStr)\n\t// Output:\n\t// Successfully generated pdf/Fpdf_SetLineJoinStyle_caps.pdf\n}\n\n// ExampleFpdf_DrawPath demonstrates various fill modes.\nfunc ExampleFpdf_DrawPath() {\n\tpdf := gofpdf.New(\"P\", \"mm\", \"A4\", \"\")\n\tpdf.SetDrawColor(0xff, 0x00, 0x00)\n\tpdf.SetFillColor(0x99, 0x99, 0x99)\n\tpdf.SetFont(\"Helvetica\", \"\", 15)\n\tpdf.AddPage()\n\tpdf.SetAlpha(1, \"Multiply\")\n\tvar (\n\t\tpolygon = func(cx, cy, r, n, dir float64) {\n\t\t\tda := 2 * math.Pi / n\n\t\t\tpdf.MoveTo(cx+r, cy)\n\t\t\tpdf.Text(cx+r, cy, \"0\")\n\t\t\ti := 1\n\t\t\tfor a := da; a < 2*math.Pi; a += da {\n\t\t\t\tx, y := cx+r*math.Cos(dir*a), cy+r*math.Sin(dir*a)\n\t\t\t\tpdf.LineTo(x, y)\n\t\t\t\tpdf.Text(x, y, strconv.Itoa(i))\n\t\t\t\ti++\n\t\t\t}\n\t\t\tpdf.ClosePath()\n\t\t}\n\t\tpolygons = func(cx, cy, r, n, dir float64) {\n\t\t\td := 1.0\n\t\t\tfor rf := r; rf > 0; rf -= 10 {\n\t\t\t\tpolygon(cx, cy, rf, n, d)\n\t\t\t\td *= dir\n\t\t\t}\n\t\t}\n\t\tstar = func(cx, cy, r, n float64) {\n\t\t\tda := 4 * math.Pi / n\n\t\t\tpdf.MoveTo(cx+r, cy)\n\t\t\tfor a := da; a < 4*math.Pi+da; a += da {\n\t\t\t\tx, y := cx+r*math.Cos(a), cy+r*math.Sin(a)\n\t\t\t\tpdf.LineTo(x, y)\n\t\t\t}\n\t\t\tpdf.ClosePath()\n\t\t}\n\t)\n\t// triangle\n\tpolygons(55, 45, 40, 3, 1)\n\tpdf.DrawPath(\"B\")\n\tpdf.Text(15, 95, \"B (same direction, non zero winding)\")\n\n\t// square\n\tpolygons(155, 45, 40, 4, 1)\n\tpdf.DrawPath(\"B*\")\n\tpdf.Text(115, 95, \"B* (same direction, even odd)\")\n\n\t// pentagon\n\tpolygons(55, 145, 40, 5, -1)\n\tpdf.DrawPath(\"B\")\n\tpdf.Text(15, 195, \"B (different direction, non zero winding)\")\n\n\t// hexagon\n\tpolygons(155, 145, 40, 6, -1)\n\tpdf.DrawPath(\"B*\")\n\tpdf.Text(115, 195, \"B* (different direction, even odd)\")\n\n\t// star\n\tstar(55, 245, 40, 5)\n\tpdf.DrawPath(\"B\")\n\tpdf.Text(15, 290, \"B (non zero winding)\")\n\n\t// star\n\tstar(155, 245, 40, 5)\n\tpdf.DrawPath(\"B*\")\n\tpdf.Text(115, 290, \"B* (even odd)\")\n\n\tfileStr := example.Filename(\"Fpdf_DrawPath_fill\")\n\terr := pdf.OutputFileAndClose(fileStr)\n\texample.Summary(err, fileStr)\n\t// Output:\n\t// Successfully generated pdf/Fpdf_DrawPath_fill.pdf\n}\n\n// ExampleFpdf_CreateTemplate demonstrates creating and using templates\nfunc ExampleFpdf_CreateTemplate() {\n\tpdf := gofpdf.New(\"P\", \"mm\", \"A4\", \"\")\n\tpdf.SetCompression(false)\n\t// pdf.SetFont(\"Times\", \"\", 12)\n\ttemplate := pdf.CreateTemplate(func(tpl *gofpdf.Tpl) {\n\t\ttpl.Image(example.ImageFile(\"logo.png\"), 6, 6, 30, 0, false, \"\", 0, \"\")\n\t\ttpl.SetFont(\"Arial\", \"B\", 16)\n\t\ttpl.Text(40, 20, \"Template says hello\")\n\t\ttpl.SetDrawColor(0, 100, 200)\n\t\ttpl.SetLineWidth(2.5)\n\t\ttpl.Line(95, 12, 105, 22)\n\t})\n\t_, tplSize := template.Size()\n\t// fmt.Println(\"Size:\", tplSize)\n\t// fmt.Println(\"Scaled:\", tplSize.ScaleBy(1.5))\n\n\ttemplate2 := pdf.CreateTemplate(func(tpl *gofpdf.Tpl) {\n\t\ttpl.UseTemplate(template)\n\t\tsubtemplate := tpl.CreateTemplate(func(tpl2 *gofpdf.Tpl) {\n\t\t\ttpl2.Image(example.ImageFile(\"logo.png\"), 6, 86, 30, 0, false, \"\", 0, \"\")\n\t\t\ttpl2.SetFont(\"Arial\", \"B\", 16)\n\t\t\ttpl2.Text(40, 100, \"Subtemplate says hello\")\n\t\t\ttpl2.SetDrawColor(0, 200, 100)\n\t\t\ttpl2.SetLineWidth(2.5)\n\t\t\ttpl2.Line(102, 92, 112, 102)\n\t\t})\n\t\ttpl.UseTemplate(subtemplate)\n\t})\n\n\tpdf.SetDrawColor(200, 100, 0)\n\tpdf.SetLineWidth(2.5)\n\tpdf.SetFont(\"Arial\", \"B\", 16)\n\n\t// serialize and deserialize template\n\tb, _ := template2.Serialize()\n\ttemplate3, _ := gofpdf.DeserializeTemplate(b)\n\n\tpdf.AddPage()\n\tpdf.UseTemplate(template3)\n\tpdf.UseTemplateScaled(template3, gofpdf.PointType{X: 0, Y: 30}, tplSize)\n\tpdf.Line(40, 210, 60, 210)\n\tpdf.Text(40, 200, \"Template example page 1\")\n\n\tpdf.AddPage()\n\tpdf.UseTemplate(template2)\n\tpdf.UseTemplateScaled(template3, gofpdf.PointType{X: 0, Y: 30}, tplSize.ScaleBy(1.4))\n\tpdf.Line(60, 210, 80, 210)\n\tpdf.Text(40, 200, \"Template example page 2\")\n\n\tfileStr := example.Filename(\"Fpdf_CreateTemplate\")\n\terr := pdf.OutputFileAndClose(fileStr)\n\texample.Summary(err, fileStr)\n\t// Output:\n\t// Successfully generated pdf/Fpdf_CreateTemplate.pdf\n}\n\n// ExampleFpdf_AddFontFromBytes demonstrate how to use embedded fonts from byte array\nfunc ExampleFpdf_AddFontFromBytes() {\n\tpdf := gofpdf.New(\"P\", \"mm\", \"A4\", \"\")\n\tpdf.AddPage()\n\tpdf.AddFontFromBytes(\"calligra\", \"\", files.CalligraJson, files.CalligraZ)\n\tpdf.SetFont(\"calligra\", \"\", 16)\n\tpdf.Cell(40, 10, \"Hello World With Embedded Font!\")\n\tfileStr := example.Filename(\"Fpdf_EmbeddedFont\")\n\terr := pdf.OutputFileAndClose(fileStr)\n\texample.Summary(err, fileStr)\n\t// Output:\n\t// Successfully generated pdf/Fpdf_EmbeddedFont.pdf\n}\n\n// This example demonstrate Clipped table cells\nfunc ExampleFpdf_ClipRect() {\n\tmarginCell := 2. // margin of top/bottom of cell\n\tpdf := gofpdf.New(\"P\", \"mm\", \"A4\", \"\")\n\tpdf.SetFont(\"Arial\", \"\", 12)\n\tpdf.AddPage()\n\tpagew, pageh := pdf.GetPageSize()\n\tmleft, mright, _, mbottom := pdf.GetMargins()\n\n\tcols := []float64{60, 100, pagew - mleft - mright - 100 - 60}\n\trows := [][]string{}\n\tfor i := 1; i <= 50; i++ {\n\t\tword := fmt.Sprintf(\"%d:%s\", i, strings.Repeat(\"A\", i%100))\n\t\trows = append(rows, []string{word, word, word})\n\t}\n\n\tfor _, row := range rows {\n\t\t_, lineHt := pdf.GetFontSize()\n\t\theight := lineHt + marginCell\n\n\t\tx, y := pdf.GetXY()\n\t\t// add a new page if the height of the row doesn't fit on the page\n\t\tif y+height >= pageh-mbottom {\n\t\t\tpdf.AddPage()\n\t\t\tx, y = pdf.GetXY()\n\t\t}\n\t\tfor i, txt := range row {\n\t\t\twidth := cols[i]\n\t\t\tpdf.Rect(x, y, width, height, \"\")\n\t\t\tpdf.ClipRect(x, y, width, height, false)\n\t\t\tpdf.Cell(width, height, txt)\n\t\t\tpdf.ClipEnd()\n\t\t\tx += width\n\t\t}\n\t\tpdf.Ln(-1)\n\t}\n\tfileStr := example.Filename(\"Fpdf_ClippedTableCells\")\n\terr := pdf.OutputFileAndClose(fileStr)\n\texample.Summary(err, fileStr)\n\t// Output:\n\t// Successfully generated pdf/Fpdf_ClippedTableCells.pdf\n}\n\n// This example demonstrate wrapped table cells\nfunc ExampleFpdf_Rect() {\n\tmarginCell := 2. // margin of top/bottom of cell\n\tpdf := gofpdf.New(\"P\", \"mm\", \"A4\", \"\")\n\tpdf.SetFont(\"Arial\", \"\", 12)\n\tpdf.AddPage()\n\tpagew, pageh := pdf.GetPageSize()\n\tmleft, mright, _, mbottom := pdf.GetMargins()\n\n\tcols := []float64{60, 100, pagew - mleft - mright - 100 - 60}\n\trows := [][]string{}\n\tfor i := 1; i <= 30; i++ {\n\t\tword := fmt.Sprintf(\"%d:%s\", i, strings.Repeat(\"A\", i%100))\n\t\trows = append(rows, []string{word, word, word})\n\t}\n\n\tfor _, row := range rows {\n\t\tcurx, y := pdf.GetXY()\n\t\tx := curx\n\n\t\theight := 0.\n\t\t_, lineHt := pdf.GetFontSize()\n\n\t\tfor i, txt := range row {\n\t\t\tlines := pdf.SplitLines([]byte(txt), cols[i])\n\t\t\th := float64(len(lines))*lineHt + marginCell*float64(len(lines))\n\t\t\tif h > height {\n\t\t\t\theight = h\n\t\t\t}\n\t\t}\n\t\t// add a new page if the height of the row doesn't fit on the page\n\t\tif pdf.GetY()+height > pageh-mbottom {\n\t\t\tpdf.AddPage()\n\t\t\ty = pdf.GetY()\n\t\t}\n\t\tfor i, txt := range row {\n\t\t\twidth := cols[i]\n\t\t\tpdf.Rect(x, y, width, height, \"\")\n\t\t\tpdf.MultiCell(width, lineHt+marginCell, txt, \"\", \"\", false)\n\t\t\tx += width\n\t\t\tpdf.SetXY(x, y)\n\t\t}\n\t\tpdf.SetXY(curx, y+height)\n\t}\n\tfileStr := example.Filename(\"Fpdf_WrappedTableCells\")\n\terr := pdf.OutputFileAndClose(fileStr)\n\texample.Summary(err, fileStr)\n\t// Output:\n\t// Successfully generated pdf/Fpdf_WrappedTableCells.pdf\n}\n\n// ExampleFpdf_SetJavascript demonstrates including JavaScript in the document.\nfunc ExampleFpdf_SetJavascript() {\n\tpdf := gofpdf.New(\"P\", \"mm\", \"A4\", \"\")\n\tpdf.SetJavascript(\"print(true);\")\n\tpdf.AddPage()\n\tpdf.SetFont(\"Arial\", \"\", 12)\n\tpdf.Write(10, \"Auto-print.\")\n\tfileStr := example.Filename(\"Fpdf_SetJavascript\")\n\terr := pdf.OutputFileAndClose(fileStr)\n\texample.Summary(err, fileStr)\n\t// Output:\n\t// Successfully generated pdf/Fpdf_SetJavascript.pdf\n}\n\n// ExampleFpdf_AddSpotColor demonstrates spot color use\nfunc ExampleFpdf_AddSpotColor() {\n\tpdf := gofpdf.New(\"P\", \"mm\", \"A4\", \"\")\n\tpdf.AddSpotColor(\"PANTONE 145 CVC\", 0, 42, 100, 25)\n\tpdf.AddPage()\n\tpdf.SetFillSpotColor(\"PANTONE 145 CVC\", 90)\n\tpdf.Rect(80, 40, 50, 50, \"F\")\n\tfileStr := example.Filename(\"Fpdf_AddSpotColor\")\n\terr := pdf.OutputFileAndClose(fileStr)\n\texample.Summary(err, fileStr)\n\t// Output:\n\t// Successfully generated pdf/Fpdf_AddSpotColor.pdf\n}\n\n// ExampleFpdf_RegisterAlias demonstrates how to use `RegisterAlias` to create a table of\n// contents.\nfunc ExampleFpdf_RegisterAlias() {\n\tpdf := gofpdf.New(\"P\", \"mm\", \"A4\", \"\")\n\tpdf.SetFont(\"Arial\", \"\", 12)\n\tpdf.AliasNbPages(\"\")\n\tpdf.AddPage()\n\n\t// Write the table of contents. We use aliases instead of the page number\n\t// because we don't know which page the section will begin on.\n\tnumSections := 3\n\tfor i := 1; i <= numSections; i++ {\n\t\tpdf.Cell(0, 10, fmt.Sprintf(\"Section %d begins on page {mark %d}\", i, i))\n\t\tpdf.Ln(10)\n\t}\n\n\t// Write the sections. Before we start writing, we use `RegisterAlias` to\n\t// ensure that the alias written in the table of contents will be replaced\n\t// by the current page number.\n\tfor i := 1; i <= numSections; i++ {\n\t\tpdf.AddPage()\n\t\tpdf.RegisterAlias(fmt.Sprintf(\"{mark %d}\", i), fmt.Sprintf(\"%d\", pdf.PageNo()))\n\t\tpdf.Write(10, fmt.Sprintf(\"Section %d, page %d of {nb}\", i, pdf.PageNo()))\n\t}\n\n\tfileStr := example.Filename(\"Fpdf_RegisterAlias\")\n\terr := pdf.OutputFileAndClose(fileStr)\n\texample.Summary(err, fileStr)\n\t// Output:\n\t// Successfully generated pdf/Fpdf_RegisterAlias.pdf\n}\n\n// ExampleFpdf_RegisterAlias_utf8 demonstrates how to use `RegisterAlias` to\n// create a table of contents. This particular example demonstrates the use of\n// UTF-8 aliases.\nfunc ExampleFpdf_RegisterAlias_utf8() {\n\tpdf := gofpdf.New(\"P\", \"mm\", \"A4\", \"\")\n\tpdf.AddUTF8Font(\"dejavu\", \"\", example.FontFile(\"DejaVuSansCondensed.ttf\"))\n\tpdf.SetFont(\"dejavu\", \"\", 12)\n\tpdf.AliasNbPages(\"{entute}\")\n\tpdf.AddPage()\n\n\t// Write the table of contents. We use aliases instead of the page number\n\t// because we don't know which page the section will begin on.\n\tnumSections := 3\n\tfor i := 1; i <= numSections; i++ {\n\t\tpdf.Cell(0, 10, fmt.Sprintf(\"Sekcio %d komenciĝas ĉe paĝo {ĉi tiu marko %d}\", i, i))\n\t\tpdf.Ln(10)\n\t}\n\n\t// Write the sections. Before we start writing, we use `RegisterAlias` to\n\t// ensure that the alias written in the table of contents will be replaced\n\t// by the current page number.\n\tfor i := 1; i <= numSections; i++ {\n\t\tpdf.AddPage()\n\t\tpdf.RegisterAlias(fmt.Sprintf(\"{ĉi tiu marko %d}\", i), fmt.Sprintf(\"%d\", pdf.PageNo()))\n\t\tpdf.Write(10, fmt.Sprintf(\"Sekcio %d, paĝo %d de {entute}\", i, pdf.PageNo()))\n\t}\n\n\tfileStr := example.Filename(\"Fpdf_RegisterAliasUTF8\")\n\terr := pdf.OutputFileAndClose(fileStr)\n\texample.Summary(err, fileStr)\n\t// Output:\n\t// Successfully generated pdf/Fpdf_RegisterAliasUTF8.pdf\n}\n\n// ExampleNewGrid demonstrates the generation of graph grids.\nfunc ExampleNewGrid() {\n\tpdf := gofpdf.New(\"P\", \"mm\", \"A4\", \"\")\n\tpdf.SetFont(\"Arial\", \"\", 12)\n\tpdf.AddPage()\n\n\tgr := gofpdf.NewGrid(13, 10, 187, 130)\n\tgr.TickmarksExtentX(0, 10, 4)\n\tgr.TickmarksExtentY(0, 10, 3)\n\tgr.Grid(pdf)\n\n\tgr = gofpdf.NewGrid(13, 154, 187, 128)\n\tgr.XLabelRotate = true\n\tgr.TickmarksExtentX(0, 1, 12)\n\tgr.XDiv = 5\n\tgr.TickmarksContainY(0, 1.1)\n\tgr.YDiv = 20\n\t// Replace X label formatter with month abbreviation\n\tgr.XTickStr = func(val float64, precision int) string {\n\t\treturn time.Month(math.Mod(val, 12) + 1).String()[0:3]\n\t}\n\tgr.Grid(pdf)\n\tdot := func(x, y float64) {\n\t\tpdf.Circle(gr.X(x), gr.Y(y), 0.5, \"F\")\n\t}\n\tpts := []float64{0.39, 0.457, 0.612, 0.84, 0.998, 1.037, 1.015, 0.918, 0.772, 0.659, 0.593, 0.164}\n\tfor month, val := range pts {\n\t\tdot(float64(month)+0.5, val)\n\t}\n\tpdf.SetDrawColor(255, 64, 64)\n\tpdf.SetAlpha(0.5, \"Normal\")\n\tpdf.SetLineWidth(1.2)\n\tgr.Plot(pdf, 0.5, 11.5, 50, func(x float64) float64 {\n\t\t// http://www.xuru.org/rt/PR.asp\n\t\treturn 0.227 * math.Exp(-0.0373*x*x+0.471*x)\n\t})\n\tpdf.SetAlpha(1.0, \"Normal\")\n\tpdf.SetXY(gr.X(0.5), gr.Y(1.35))\n\tpdf.SetFontSize(14)\n\tpdf.Write(0, \"Solar energy (MWh) per month, 2016\")\n\tpdf.AddPage()\n\n\tgr = gofpdf.NewGrid(13, 10, 187, 274)\n\tgr.TickmarksContainX(2.3, 3.4)\n\tgr.TickmarksContainY(10.4, 56.8)\n\tgr.Grid(pdf)\n\n\tfileStr := example.Filename(\"Fpdf_Grid\")\n\terr := pdf.OutputFileAndClose(fileStr)\n\texample.Summary(err, fileStr)\n\t// Output:\n\t// Successfully generated pdf/Fpdf_Grid.pdf\n}\n\n// ExampleFpdf_SetPageBox demonstrates the use of a page box\nfunc ExampleFpdf_SetPageBox() {\n\t// pdfinfo (from http://www.xpdfreader.com) reports the following for this example:\n\t// ~ pdfinfo -box pdf/Fpdf_PageBox.pdf\n\t// Producer:       FPDF 1.7\n\t// CreationDate:   Sat Jan  1 00:00:00 2000\n\t// ModDate:   \t   Sat Jan  1 00:00:00 2000\n\t// Tagged:         no\n\t// Form:           none\n\t// Pages:          1\n\t// Encrypted:      no\n\t// Page size:      493.23 x 739.85 pts (rotated 0 degrees)\n\t// MediaBox:           0.00     0.00   595.28   841.89\n\t// CropBox:           51.02    51.02   544.25   790.87\n\t// BleedBox:          51.02    51.02   544.25   790.87\n\t// TrimBox:           51.02    51.02   544.25   790.87\n\t// ArtBox:            51.02    51.02   544.25   790.87\n\t// File size:      1053 bytes\n\t// Optimized:      no\n\t// PDF version:    1.3\n\tconst (\n\t\twd        = 210\n\t\tht        = 297\n\t\tfontsize  = 6\n\t\tboxmargin = 3 * fontsize\n\t)\n\tpdf := gofpdf.New(\"P\", \"mm\", \"A4\", \"\") // 210mm x 297mm\n\tpdf.SetPageBox(\"crop\", boxmargin, boxmargin, wd-2*boxmargin, ht-2*boxmargin)\n\tpdf.SetFont(\"Arial\", \"\", pdf.UnitToPointConvert(fontsize))\n\tpdf.AddPage()\n\tpdf.MoveTo(fontsize, fontsize)\n\tpdf.Write(fontsize, \"This will be cropped from printed output\")\n\tpdf.MoveTo(boxmargin+fontsize, boxmargin+fontsize)\n\tpdf.Write(fontsize, \"This will be displayed in cropped output\")\n\tfileStr := example.Filename(\"Fpdf_PageBox\")\n\terr := pdf.OutputFileAndClose(fileStr)\n\texample.Summary(err, fileStr)\n\t// Output:\n\t// Successfully generated pdf/Fpdf_PageBox.pdf\n}\n\n// ExampleFpdf_SubWrite demonstrates subscripted and superscripted text\n// Adapted from http://www.fpdf.org/en/script/script61.php\nfunc ExampleFpdf_SubWrite() {\n\n\tconst (\n\t\tfontSize = 12\n\t\thalfX    = 105\n\t)\n\n\tpdf := gofpdf.New(\"P\", \"mm\", \"A4\", \"\") // 210mm x 297mm\n\tpdf.AddPage()\n\tpdf.SetFont(\"Arial\", \"\", fontSize)\n\t_, lineHt := pdf.GetFontSize()\n\n\tpdf.Write(lineHt, \"Hello World!\")\n\tpdf.SetX(halfX)\n\tpdf.Write(lineHt, \"This is standard text.\\n\")\n\tpdf.Ln(lineHt * 2)\n\n\tpdf.SubWrite(10, \"H\", 33, 0, 0, \"\")\n\tpdf.Write(10, \"ello World!\")\n\tpdf.SetX(halfX)\n\tpdf.Write(10, \"This is text with a capital first letter.\\n\")\n\tpdf.Ln(lineHt * 2)\n\n\tpdf.SubWrite(lineHt, \"Y\", 6, 0, 0, \"\")\n\tpdf.Write(lineHt, \"ou can also begin the sentence with a small letter. And word wrap also works if the line is too long, like this one is.\")\n\tpdf.SetX(halfX)\n\tpdf.Write(lineHt, \"This is text with a small first letter.\\n\")\n\tpdf.Ln(lineHt * 2)\n\n\tpdf.Write(lineHt, \"The world has a lot of km\")\n\tpdf.SubWrite(lineHt, \"2\", 6, 4, 0, \"\")\n\tpdf.SetX(halfX)\n\tpdf.Write(lineHt, \"This is text with a superscripted letter.\\n\")\n\tpdf.Ln(lineHt * 2)\n\n\tpdf.Write(lineHt, \"The world has a lot of H\")\n\tpdf.SubWrite(lineHt, \"2\", 6, -3, 0, \"\")\n\tpdf.Write(lineHt, \"O\")\n\tpdf.SetX(halfX)\n\tpdf.Write(lineHt, \"This is text with a subscripted letter.\\n\")\n\n\tfileStr := example.Filename(\"Fpdf_SubWrite\")\n\terr := pdf.OutputFileAndClose(fileStr)\n\texample.Summary(err, fileStr)\n\t// Output:\n\t// Successfully generated pdf/Fpdf_SubWrite.pdf\n}\n\n// ExampleFpdf_SetPage demomstrates the SetPage() method, allowing content\n// generation to be deferred until all pages have been added.\nfunc ExampleFpdf_SetPage() {\n\trnd := rand.New(rand.NewSource(0)) // Make reproducible documents\n\tpdf := gofpdf.New(\"L\", \"cm\", \"A4\", \"\")\n\tpdf.SetFont(\"Times\", \"\", 12)\n\n\tvar time []float64\n\ttemperaturesFromSensors := make([][]float64, 5)\n\tmaxs := []float64{25, 41, 89, 62, 11}\n\tfor i := range temperaturesFromSensors {\n\t\ttemperaturesFromSensors[i] = make([]float64, 0)\n\t}\n\n\tfor i := 0.0; i < 100; i += 0.5 {\n\t\ttime = append(time, i)\n\t\tfor j, sensor := range temperaturesFromSensors {\n\t\t\tdataValue := rnd.Float64() * maxs[j]\n\t\t\tsensor = append(sensor, dataValue)\n\t\t\ttemperaturesFromSensors[j] = sensor\n\t\t}\n\t}\n\tvar graphs []gofpdf.GridType\n\tvar pageNums []int\n\txMax := time[len(time)-1]\n\tfor i := range temperaturesFromSensors {\n\t\t//Create a new page and graph for each sensor we want to graph.\n\t\tpdf.AddPage()\n\t\tpdf.Ln(1)\n\t\t//Custom label per sensor\n\t\tpdf.WriteAligned(0, 0, \"Temperature Sensor \"+strconv.Itoa(i+1)+\" (C) vs Time (min)\", \"C\")\n\t\tpdf.Ln(0.5)\n\t\tgraph := gofpdf.NewGrid(pdf.GetX(), pdf.GetY(), 20, 10)\n\t\tgraph.TickmarksContainX(0, xMax)\n\t\t//Custom Y axis\n\t\tgraph.TickmarksContainY(0, maxs[i])\n\t\tgraph.Grid(pdf)\n\t\t//Save references and locations.\n\t\tgraphs = append(graphs, graph)\n\t\tpageNums = append(pageNums, pdf.PageNo())\n\t}\n\t// For each X, graph the Y in each sensor.\n\tfor i, currTime := range time {\n\t\tfor j, sensor := range temperaturesFromSensors {\n\t\t\tpdf.SetPage(pageNums[j])\n\t\t\tgraph := graphs[j]\n\t\t\ttemperature := sensor[i]\n\t\t\tpdf.Circle(graph.X(currTime), graph.Y(temperature), 0.04, \"D\")\n\t\t}\n\t}\n\n\tfileStr := example.Filename(\"Fpdf_SetPage\")\n\terr := pdf.OutputFileAndClose(fileStr)\n\texample.Summary(err, fileStr)\n\t// Output:\n\t// Successfully generated pdf/Fpdf_SetPage.pdf\n}\n\n// ExampleFpdf_SetFillColor demonstrates how graphic attributes are properly\n// assigned within multiple transformations. See issue #234.\nfunc ExampleFpdf_SetFillColor() {\n\tpdf := gofpdf.New(\"P\", \"mm\", \"A4\", \"\")\n\n\tpdf.AddPage()\n\tpdf.SetFont(\"Arial\", \"\", 8)\n\n\tdraw := func(trX, trY float64) {\n\t\tpdf.TransformBegin()\n\t\tpdf.TransformTranslateX(trX)\n\t\tpdf.TransformTranslateY(trY)\n\t\tpdf.SetLineJoinStyle(\"round\")\n\t\tpdf.SetLineWidth(0.5)\n\t\tpdf.SetDrawColor(128, 64, 0)\n\t\tpdf.SetFillColor(255, 127, 0)\n\t\tpdf.SetAlpha(0.5, \"Normal\")\n\t\tpdf.SetDashPattern([]float64{5, 10}, 0)\n\t\tpdf.Rect(0, 0, 40, 40, \"FD\")\n\t\tpdf.SetFontSize(12)\n\t\tpdf.SetXY(5, 5)\n\t\tpdf.Write(0, \"Test\")\n\t\tpdf.TransformEnd()\n\t}\n\n\tdraw(5, 5)\n\tdraw(50, 50)\n\n\tfileStr := example.Filename(\"Fpdf_SetFillColor\")\n\terr := pdf.OutputFileAndClose(fileStr)\n\texample.Summary(err, fileStr)\n\t// Output:\n\t// Successfully generated pdf/Fpdf_SetFillColor.pdf\n}\n\n// ExampleFpdf_TransformRotate demonstrates how to rotate text within a header\n// to make a watermark that appears on each page.\nfunc ExampleFpdf_TransformRotate() {\n\n\tloremStr := lorem() + \"\\n\\n\"\n\tpdf := gofpdf.New(\"P\", \"mm\", \"A4\", \"\")\n\tmargin := 25.0\n\tpdf.SetMargins(margin, margin, margin)\n\n\tfontHt := 13.0\n\tlineHt := pdf.PointToUnitConvert(fontHt)\n\tmarkFontHt := 50.0\n\tmarkLineHt := pdf.PointToUnitConvert(markFontHt)\n\tmarkY := (297.0 - markLineHt) / 2.0\n\tctrX := 210.0 / 2.0\n\tctrY := 297.0 / 2.0\n\n\tpdf.SetHeaderFunc(func() {\n\t\tpdf.SetFont(\"Arial\", \"B\", markFontHt)\n\t\tpdf.SetTextColor(206, 216, 232)\n\t\tpdf.SetXY(margin, markY)\n\t\tpdf.TransformBegin()\n\t\tpdf.TransformRotate(45, ctrX, ctrY)\n\t\tpdf.CellFormat(0, markLineHt, \"W A T E R M A R K   D E M O\", \"\", 0, \"C\", false, 0, \"\")\n\t\tpdf.TransformEnd()\n\t\tpdf.SetXY(margin, margin)\n\t})\n\n\tpdf.AddPage()\n\tpdf.SetFont(\"Arial\", \"\", 8)\n\tfor j := 0; j < 25; j++ {\n\t\tpdf.MultiCell(0, lineHt, loremStr, \"\", \"L\", false)\n\t}\n\n\tfileStr := example.Filename(\"Fpdf_RotateText\")\n\terr := pdf.OutputFileAndClose(fileStr)\n\texample.Summary(err, fileStr)\n\t// Output:\n\t// Successfully generated pdf/Fpdf_RotateText.pdf\n}\n\n// ExampleFpdf_AddUTF8Font demonstrates how use the font\n// with utf-8 mode\nfunc ExampleFpdf_AddUTF8Font() {\n\tvar fileStr string\n\tvar txtStr []byte\n\tvar err error\n\n\tpdf := gofpdf.New(\"P\", \"mm\", \"A4\", \"\")\n\n\tpdf.AddPage()\n\n\tpdf.AddUTF8Font(\"dejavu\", \"\", example.FontFile(\"DejaVuSansCondensed.ttf\"))\n\tpdf.AddUTF8Font(\"dejavu\", \"B\", example.FontFile(\"DejaVuSansCondensed-Bold.ttf\"))\n\tpdf.AddUTF8Font(\"dejavu\", \"I\", example.FontFile(\"DejaVuSansCondensed-Oblique.ttf\"))\n\tpdf.AddUTF8Font(\"dejavu\", \"BI\", example.FontFile(\"DejaVuSansCondensed-BoldOblique.ttf\"))\n\n\tfileStr = example.Filename(\"Fpdf_AddUTF8Font\")\n\ttxtStr, err = ioutil.ReadFile(example.TextFile(\"utf-8test.txt\"))\n\tif err == nil {\n\n\t\tpdf.SetFont(\"dejavu\", \"B\", 17)\n\t\tpdf.MultiCell(100, 8, \"Text in different languages :\", \"\", \"C\", false)\n\t\tpdf.SetFont(\"dejavu\", \"\", 14)\n\t\tpdf.MultiCell(100, 5, string(txtStr), \"\", \"C\", false)\n\t\tpdf.Ln(15)\n\n\t\ttxtStr, err = ioutil.ReadFile(example.TextFile(\"utf-8test2.txt\"))\n\t\tif err == nil {\n\n\t\t\tpdf.SetFont(\"dejavu\", \"BI\", 17)\n\t\t\tpdf.MultiCell(100, 8, \"Greek text with alignStr = \\\"J\\\":\", \"\", \"C\", false)\n\t\t\tpdf.SetFont(\"dejavu\", \"I\", 14)\n\t\t\tpdf.MultiCell(100, 5, string(txtStr), \"\", \"J\", false)\n\t\t\terr = pdf.OutputFileAndClose(fileStr)\n\n\t\t}\n\t}\n\texample.Summary(err, fileStr)\n\t// Output:\n\t// Successfully generated pdf/Fpdf_AddUTF8Font.pdf\n}\n\n// ExampleUTF8CutFont demonstrates how generate a TrueType font subset.\nfunc ExampleUTF8CutFont() {\n\tvar pdfFileStr, fullFontFileStr, subFontFileStr string\n\tvar subFont, fullFont []byte\n\tvar err error\n\n\tpdfFileStr = example.Filename(\"Fpdf_UTF8CutFont\")\n\tfullFontFileStr = example.FontFile(\"calligra.ttf\")\n\tfullFont, err = ioutil.ReadFile(fullFontFileStr)\n\tif err == nil {\n\t\tsubFontFileStr = \"calligra_abcde.ttf\"\n\t\tsubFont = gofpdf.UTF8CutFont(fullFont, \"abcde\")\n\t\terr = ioutil.WriteFile(subFontFileStr, subFont, 0600)\n\t\tif err == nil {\n\t\t\ty := 24.0\n\t\t\tpdf := gofpdf.New(\"P\", \"mm\", \"A4\", \"\")\n\t\t\tfontHt := 17.0\n\t\t\tlineHt := pdf.PointConvert(fontHt)\n\t\t\twrite := func(format string, args ...interface{}) {\n\t\t\t\tpdf.SetXY(24.0, y)\n\t\t\t\tpdf.Cell(200.0, lineHt, fmt.Sprintf(format, args...))\n\t\t\t\ty += lineHt\n\t\t\t}\n\t\t\twriteSize := func(fileStr string) {\n\t\t\t\tvar info os.FileInfo\n\t\t\t\tvar err error\n\t\t\t\tinfo, err = os.Stat(fileStr)\n\t\t\t\tif err == nil {\n\t\t\t\t\twrite(\"%6d: size of %s\", info.Size(), fileStr)\n\t\t\t\t}\n\t\t\t}\n\t\t\tpdf.AddPage()\n\t\t\tpdf.AddUTF8Font(\"calligra\", \"\", subFontFileStr)\n\t\t\tpdf.SetFont(\"calligra\", \"\", fontHt)\n\t\t\twrite(\"cabbed\")\n\t\t\twrite(\"vwxyz\")\n\t\t\tpdf.SetFont(\"courier\", \"\", fontHt)\n\t\t\twriteSize(fullFontFileStr)\n\t\t\twriteSize(subFontFileStr)\n\t\t\terr = pdf.OutputFileAndClose(pdfFileStr)\n\t\t\tos.Remove(subFontFileStr)\n\t\t}\n\t}\n\texample.Summary(err, pdfFileStr)\n\t// Output:\n\t// Successfully generated pdf/Fpdf_UTF8CutFont.pdf\n}\n\nfunc ExampleFpdf_RoundedRect() {\n\tconst (\n\t\twd     = 40.0\n\t\thgap   = 10.0\n\t\tradius = 10.0\n\t\tht     = 60.0\n\t\tvgap   = 10.0\n\t)\n\tcorner := func(b1, b2, b3, b4 bool) (cstr string) {\n\t\tif b1 {\n\t\t\tcstr = \"1\"\n\t\t}\n\t\tif b2 {\n\t\t\tcstr += \"2\"\n\t\t}\n\t\tif b3 {\n\t\t\tcstr += \"3\"\n\t\t}\n\t\tif b4 {\n\t\t\tcstr += \"4\"\n\t\t}\n\t\treturn\n\t}\n\tpdf := gofpdf.New(\"P\", \"mm\", \"A4\", \"\") // 210 x 297\n\tpdf.AddPage()\n\tpdf.SetLineWidth(0.5)\n\ty := vgap\n\tr := 40\n\tg := 30\n\tb := 20\n\tfor row := 0; row < 4; row++ {\n\t\tx := hgap\n\t\tfor col := 0; col < 4; col++ {\n\t\t\tpdf.SetFillColor(r, g, b)\n\t\t\tpdf.RoundedRect(x, y, wd, ht, radius, corner(row&1 == 1, row&2 == 2, col&1 == 1, col&2 == 2), \"FD\")\n\t\t\tr += 8\n\t\t\tg += 10\n\t\t\tb += 12\n\t\t\tx += wd + hgap\n\t\t}\n\t\ty += ht + vgap\n\t}\n\tpdf.AddPage()\n\tpdf.RoundedRectExt(10, 20, 40, 80, 4., 0., 20, 0., \"FD\")\n\n\tfileStr := example.Filename(\"Fpdf_RoundedRect\")\n\terr := pdf.OutputFileAndClose(fileStr)\n\texample.Summary(err, fileStr)\n\t// Output:\n\t// Successfully generated pdf/Fpdf_RoundedRect.pdf\n}\n\n// ExampleFpdf_SetUnderlineThickness demonstrates how to adjust the text\n// underline thickness.\nfunc ExampleFpdf_SetUnderlineThickness() {\n\tpdf := gofpdf.New(\"P\", \"mm\", \"A4\", \"\") // 210mm x 297mm\n\tpdf.AddPage()\n\tpdf.SetFont(\"Arial\", \"U\", 12)\n\n\tpdf.SetUnderlineThickness(0.5)\n\tpdf.CellFormat(0, 10, \"Thin underline\", \"\", 1, \"\", false, 0, \"\")\n\n\tpdf.SetUnderlineThickness(1)\n\tpdf.CellFormat(0, 10, \"Normal underline\", \"\", 1, \"\", false, 0, \"\")\n\n\tpdf.SetUnderlineThickness(2)\n\tpdf.CellFormat(0, 10, \"Thicker underline\", \"\", 1, \"\", false, 0, \"\")\n\n\tfileStr := example.Filename(\"Fpdf_UnderlineThickness\")\n\terr := pdf.OutputFileAndClose(fileStr)\n\texample.Summary(err, fileStr)\n\t// Output:\n\t// Successfully generated pdf/Fpdf_UnderlineThickness.pdf\n}\n\n// ExampleFpdf_Cell_strikeout demonstrates striked-out text\nfunc ExampleFpdf_Cell_strikeout() {\n\n\tpdf := gofpdf.New(\"P\", \"mm\", \"A4\", \"\") // 210mm x 297mm\n\tpdf.AddPage()\n\n\tfor fontSize := 4; fontSize < 40; fontSize += 10 {\n\t\tpdf.SetFont(\"Arial\", \"S\", float64(fontSize))\n\t\tpdf.SetXY(0, float64(fontSize))\n\t\tpdf.Cell(40, 10, \"Hello World\")\n\t}\n\n\tfileStr := example.Filename(\"Fpdf_Cell_strikeout\")\n\terr := pdf.OutputFileAndClose(fileStr)\n\texample.Summary(err, fileStr)\n\t// Output:\n\t// Successfully generated pdf/Fpdf_Cell_strikeout.pdf\n}\n\n// ExampleFpdf_SetTextRenderingMode demonstrates rendering modes in PDFs.\nfunc ExampleFpdf_SetTextRenderingMode() {\n\n\tpdf := gofpdf.New(\"P\", \"mm\", \"A4\", \"\") // 210mm x 297mm\n\tpdf.AddPage()\n\tfontSz := float64(16)\n\tlineSz := pdf.PointToUnitConvert(fontSz)\n\tpdf.SetFont(\"Times\", \"\", fontSz)\n\tpdf.Write(lineSz, \"This document demonstrates various modes of text rendering. Search for \\\"Mode 3\\\" \"+\n\t\t\"to locate text that has been rendered invisibly. This selection can be copied \"+\n\t\t\"into the clipboard as usual and is useful for overlaying onto non-textual elements such \"+\n\t\t\"as images to make them searchable.\\n\\n\")\n\tfontSz = float64(125)\n\tlineSz = pdf.PointToUnitConvert(fontSz)\n\tpdf.SetFontSize(fontSz)\n\tpdf.SetTextColor(170, 170, 190)\n\tpdf.SetDrawColor(50, 60, 90)\n\n\twrite := func(mode int) {\n\t\tpdf.SetTextRenderingMode(mode)\n\t\tpdf.CellFormat(210, lineSz, fmt.Sprintf(\"Mode %d\", mode), \"\", 1, \"\", false, 0, \"\")\n\t}\n\n\tfor mode := 0; mode < 4; mode++ {\n\t\twrite(mode)\n\t}\n\twrite(0)\n\n\tfileStr := example.Filename(\"Fpdf_TextRenderingMode\")\n\terr := pdf.OutputFileAndClose(fileStr)\n\texample.Summary(err, fileStr)\n\t// Output:\n\t// Successfully generated pdf/Fpdf_TextRenderingMode.pdf\n}\n\n// TestIssue0316 addresses issue 316 in which AddUTF8FromBytes modifies its argument\n// utf8bytes resulting in a panic if you generate two PDFs with the \"same\" font bytes.\nfunc TestIssue0316(t *testing.T) {\n\tpdf := gofpdf.New(gofpdf.OrientationPortrait, \"mm\", \"A4\", \"\")\n\tpdf.AddPage()\n\tfontBytes, _ := ioutil.ReadFile(example.FontFile(\"DejaVuSansCondensed.ttf\"))\n\tofontBytes := append([]byte{}, fontBytes...)\n\tpdf.AddUTF8FontFromBytes(\"dejavu\", \"\", fontBytes)\n\tpdf.SetFont(\"dejavu\", \"\", 16)\n\tpdf.Cell(40, 10, \"Hello World!\")\n\tfileStr := example.Filename(\"TestIssue0316\")\n\terr := pdf.OutputFileAndClose(fileStr)\n\texample.Summary(err, fileStr)\n\tpdf.AddPage()\n\tif !bytes.Equal(fontBytes, ofontBytes) {\n\t\tt.Fatal(\"Font data changed during pdf generation\")\n\t}\n}\n\nfunc TestMultiCellUnsupportedChar(t *testing.T) {\n\tpdf := gofpdf.New(\"P\", \"mm\", \"A4\", \"\")\n\tpdf.AddPage()\n\tfontBytes, _ := ioutil.ReadFile(example.FontFile(\"DejaVuSansCondensed.ttf\"))\n\tpdf.AddUTF8FontFromBytes(\"dejavu\", \"\", fontBytes)\n\tpdf.SetFont(\"dejavu\", \"\", 16)\n\n\tdefer func() {\n\t\tif r := recover(); r != nil {\n\t\t\tt.Errorf(\"unexpected panic: %v\", r)\n\t\t}\n\t}()\n\n\tpdf.MultiCell(0, 5, \"😀\", \"\", \"\", false)\n\n\tfileStr := example.Filename(\"TestMultiCellUnsupportedChar\")\n\tpdf.OutputFileAndClose(fileStr)\n}\n\n// ExampleFpdf_SetTextRenderingMode demonstrates embedding files in PDFs,\n// at the top-level.\nfunc ExampleFpdf_SetAttachments() {\n\tpdf := gofpdf.New(\"P\", \"mm\", \"A4\", \"\")\n\n\t// Global attachments\n\tfile, err := ioutil.ReadFile(\"grid.go\")\n\tif err != nil {\n\t\tpdf.SetError(err)\n\t}\n\ta1 := gofpdf.Attachment{Content: file, Filename: \"grid.go\"}\n\tfile, err = ioutil.ReadFile(\"LICENSE\")\n\tif err != nil {\n\t\tpdf.SetError(err)\n\t}\n\ta2 := gofpdf.Attachment{Content: file, Filename: \"License\"}\n\tpdf.SetAttachments([]gofpdf.Attachment{a1, a2})\n\n\tfileStr := example.Filename(\"Fpdf_EmbeddedFiles\")\n\terr = pdf.OutputFileAndClose(fileStr)\n\texample.Summary(err, fileStr)\n\t// Output:\n\t// Successfully generated pdf/Fpdf_EmbeddedFiles.pdf\n}\n\nfunc ExampleFpdf_AddAttachmentAnnotation() {\n\tpdf := gofpdf.New(\"P\", \"mm\", \"A4\", \"\")\n\tpdf.SetFont(\"Arial\", \"\", 12)\n\tpdf.AddPage()\n\n\t// Per page attachment\n\tfile, err := ioutil.ReadFile(\"grid.go\")\n\tif err != nil {\n\t\tpdf.SetError(err)\n\t}\n\ta := gofpdf.Attachment{Content: file, Filename: \"grid.go\", Description: \"Some amazing code !\"}\n\n\tpdf.SetXY(5, 10)\n\tpdf.Rect(2, 10, 50, 15, \"D\")\n\tpdf.AddAttachmentAnnotation(&a, 2, 10, 50, 15)\n\tpdf.Cell(50, 15, \"A first link\")\n\n\tpdf.SetXY(5, 80)\n\tpdf.Rect(2, 80, 50, 15, \"D\")\n\tpdf.AddAttachmentAnnotation(&a, 2, 80, 50, 15)\n\tpdf.Cell(50, 15, \"A second link (no copy)\")\n\n\tfileStr := example.Filename(\"Fpdf_FileAnnotations\")\n\terr = pdf.OutputFileAndClose(fileStr)\n\texample.Summary(err, fileStr)\n\t// Output:\n\t// Successfully generated pdf/Fpdf_FileAnnotations.pdf\n}\n\nfunc ExampleFpdf_SetModificationDate() {\n\t// pdfinfo (from http://www.xpdfreader.com) reports the following for this example :\n\t// ~ pdfinfo -box pdf/Fpdf_PageBox.pdf\n\t// Producer:       FPDF 1.7\n\t// CreationDate:   Sat Jan  1 00:00:00 2000\n\t// ModDate:        Sun Jan  2 10:22:30 2000\n\tpdf := gofpdf.New(\"\", \"\", \"\", \"\")\n\tpdf.AddPage()\n\tpdf.SetModificationDate(time.Date(2000, 1, 2, 10, 22, 30, 0, time.UTC))\n\tfileStr := example.Filename(\"Fpdf_SetModificationDate\")\n\terr := pdf.OutputFileAndClose(fileStr)\n\texample.Summary(err, fileStr)\n\t// Output:\n\t// Successfully generated pdf/Fpdf_SetModificationDate.pdf\n}\n"
        },
        {
          "name": "fpdftrans.go",
          "type": "blob",
          "size": 7.1279296875,
          "content": "package gofpdf\n\nimport (\n\t\"fmt\"\n\t\"math\"\n)\n\n// Routines in this file are translated from the work of Moritz Wagner and\n// Andreas Würmser.\n\n// TransformMatrix is used for generalized transformations of text, drawings\n// and images.\ntype TransformMatrix struct {\n\tA, B, C, D, E, F float64\n}\n\n// TransformBegin sets up a transformation context for subsequent text,\n// drawings and images. The typical usage is to immediately follow a call to\n// this method with a call to one or more of the transformation methods such as\n// TransformScale(), TransformSkew(), etc. This is followed by text, drawing or\n// image output and finally a call to TransformEnd(). All transformation\n// contexts must be properly ended prior to outputting the document.\nfunc (f *Fpdf) TransformBegin() {\n\tf.transformNest++\n\tf.out(\"q\")\n}\n\n// TransformScaleX scales the width of the following text, drawings and images.\n// scaleWd is the percentage scaling factor. (x, y) is center of scaling.\n//\n// The TransformBegin() example demonstrates this method.\nfunc (f *Fpdf) TransformScaleX(scaleWd, x, y float64) {\n\tf.TransformScale(scaleWd, 100, x, y)\n}\n\n// TransformScaleY scales the height of the following text, drawings and\n// images. scaleHt is the percentage scaling factor. (x, y) is center of\n// scaling.\n//\n// The TransformBegin() example demonstrates this method.\nfunc (f *Fpdf) TransformScaleY(scaleHt, x, y float64) {\n\tf.TransformScale(100, scaleHt, x, y)\n}\n\n// TransformScaleXY uniformly scales the width and height of the following\n// text, drawings and images. s is the percentage scaling factor for both width\n// and height. (x, y) is center of scaling.\n//\n// The TransformBegin() example demonstrates this method.\nfunc (f *Fpdf) TransformScaleXY(s, x, y float64) {\n\tf.TransformScale(s, s, x, y)\n}\n\n// TransformScale generally scales the following text, drawings and images.\n// scaleWd and scaleHt are the percentage scaling factors for width and height.\n// (x, y) is center of scaling.\n//\n// The TransformBegin() example demonstrates this method.\nfunc (f *Fpdf) TransformScale(scaleWd, scaleHt, x, y float64) {\n\tif scaleWd == 0 || scaleHt == 0 {\n\t\tf.err = fmt.Errorf(\"scale factor cannot be zero\")\n\t\treturn\n\t}\n\ty = (f.h - y) * f.k\n\tx *= f.k\n\tscaleWd /= 100\n\tscaleHt /= 100\n\tf.Transform(TransformMatrix{scaleWd, 0, 0,\n\t\tscaleHt, x * (1 - scaleWd), y * (1 - scaleHt)})\n}\n\n// TransformMirrorHorizontal horizontally mirrors the following text, drawings\n// and images. x is the axis of reflection.\n//\n// The TransformBegin() example demonstrates this method.\nfunc (f *Fpdf) TransformMirrorHorizontal(x float64) {\n\tf.TransformScale(-100, 100, x, f.y)\n}\n\n// TransformMirrorVertical vertically mirrors the following text, drawings and\n// images. y is the axis of reflection.\n//\n// The TransformBegin() example demonstrates this method.\nfunc (f *Fpdf) TransformMirrorVertical(y float64) {\n\tf.TransformScale(100, -100, f.x, y)\n}\n\n// TransformMirrorPoint symmetrically mirrors the following text, drawings and\n// images on the point specified by (x, y).\n//\n// The TransformBegin() example demonstrates this method.\nfunc (f *Fpdf) TransformMirrorPoint(x, y float64) {\n\tf.TransformScale(-100, -100, x, y)\n}\n\n// TransformMirrorLine symmetrically mirrors the following text, drawings and\n// images on the line defined by angle and the point (x, y). angles is\n// specified in degrees and measured counter-clockwise from the 3 o'clock\n// position.\n//\n// The TransformBegin() example demonstrates this method.\nfunc (f *Fpdf) TransformMirrorLine(angle, x, y float64) {\n\tf.TransformScale(-100, 100, x, y)\n\tf.TransformRotate(-2*(angle-90), x, y)\n}\n\n// TransformTranslateX moves the following text, drawings and images\n// horizontally by the amount specified by tx.\n//\n// The TransformBegin() example demonstrates this method.\nfunc (f *Fpdf) TransformTranslateX(tx float64) {\n\tf.TransformTranslate(tx, 0)\n}\n\n// TransformTranslateY moves the following text, drawings and images vertically\n// by the amount specified by ty.\n//\n// The TransformBegin() example demonstrates this method.\nfunc (f *Fpdf) TransformTranslateY(ty float64) {\n\tf.TransformTranslate(0, ty)\n}\n\n// TransformTranslate moves the following text, drawings and images\n// horizontally and vertically by the amounts specified by tx and ty.\n//\n// The TransformBegin() example demonstrates this method.\nfunc (f *Fpdf) TransformTranslate(tx, ty float64) {\n\tf.Transform(TransformMatrix{1, 0, 0, 1, tx * f.k, -ty * f.k})\n}\n\n// TransformRotate rotates the following text, drawings and images around the\n// center point (x, y). angle is specified in degrees and measured\n// counter-clockwise from the 3 o'clock position.\n//\n// The TransformBegin() example demonstrates this method.\nfunc (f *Fpdf) TransformRotate(angle, x, y float64) {\n\ty = (f.h - y) * f.k\n\tx *= f.k\n\tangle = angle * math.Pi / 180\n\tvar tm TransformMatrix\n\ttm.A = math.Cos(angle)\n\ttm.B = math.Sin(angle)\n\ttm.C = -tm.B\n\ttm.D = tm.A\n\ttm.E = x + tm.B*y - tm.A*x\n\ttm.F = y - tm.A*y - tm.B*x\n\tf.Transform(tm)\n}\n\n// TransformSkewX horizontally skews the following text, drawings and images\n// keeping the point (x, y) stationary. angleX ranges from -90 degrees (skew to\n// the left) to 90 degrees (skew to the right).\n//\n// The TransformBegin() example demonstrates this method.\nfunc (f *Fpdf) TransformSkewX(angleX, x, y float64) {\n\tf.TransformSkew(angleX, 0, x, y)\n}\n\n// TransformSkewY vertically skews the following text, drawings and images\n// keeping the point (x, y) stationary. angleY ranges from -90 degrees (skew to\n// the bottom) to 90 degrees (skew to the top).\n//\n// The TransformBegin() example demonstrates this method.\nfunc (f *Fpdf) TransformSkewY(angleY, x, y float64) {\n\tf.TransformSkew(0, angleY, x, y)\n}\n\n// TransformSkew generally skews the following text, drawings and images\n// keeping the point (x, y) stationary. angleX ranges from -90 degrees (skew to\n// the left) to 90 degrees (skew to the right). angleY ranges from -90 degrees\n// (skew to the bottom) to 90 degrees (skew to the top).\n//\n// The TransformBegin() example demonstrates this method.\nfunc (f *Fpdf) TransformSkew(angleX, angleY, x, y float64) {\n\tif angleX <= -90 || angleX >= 90 || angleY <= -90 || angleY >= 90 {\n\t\tf.err = fmt.Errorf(\"skew values must be between -90° and 90°\")\n\t\treturn\n\t}\n\tx *= f.k\n\ty = (f.h - y) * f.k\n\tvar tm TransformMatrix\n\ttm.A = 1\n\ttm.B = math.Tan(angleY * math.Pi / 180)\n\ttm.C = math.Tan(angleX * math.Pi / 180)\n\ttm.D = 1\n\ttm.E = -tm.C * y\n\ttm.F = -tm.B * x\n\tf.Transform(tm)\n}\n\n// Transform generally transforms the following text, drawings and images\n// according to the specified matrix. It is typically easier to use the various\n// methods such as TransformRotate() and TransformMirrorVertical() instead.\nfunc (f *Fpdf) Transform(tm TransformMatrix) {\n\tif f.transformNest > 0 {\n\t\tf.outf(\"%.5f %.5f %.5f %.5f %.5f %.5f cm\",\n\t\t\ttm.A, tm.B, tm.C, tm.D, tm.E, tm.F)\n\t} else if f.err == nil {\n\t\tf.err = fmt.Errorf(\"transformation context is not active\")\n\t}\n}\n\n// TransformEnd applies a transformation that was begun with a call to TransformBegin().\n//\n// The TransformBegin() example demonstrates this method.\nfunc (f *Fpdf) TransformEnd() {\n\tif f.transformNest > 0 {\n\t\tf.transformNest--\n\t\tf.out(\"Q\")\n\t} else {\n\t\tf.err = fmt.Errorf(\"error attempting to end transformation operation out of sequence\")\n\t}\n}\n"
        },
        {
          "name": "go.mod",
          "type": "blob",
          "size": 0.267578125,
          "content": "module github.com/jung-kurt/gofpdf\n\ngo 1.12\n\nrequire (\n\tgithub.com/boombuler/barcode v1.0.0\n\tgithub.com/phpdave11/gofpdi v1.0.7\n\tgithub.com/ruudk/golang-pdf417 v0.0.0-20181029194003-1af4ab5afa58\n\tgolang.org/x/image v0.0.0-20190910094157-69e4b8554b2a\n)\n\nreplace gofpdf => ./\n"
        },
        {
          "name": "go.sum",
          "type": "blob",
          "size": 1.8134765625,
          "content": "github.com/boombuler/barcode v1.0.0 h1:s1TvRnXwL2xJRaccrdcBQMZxq6X7DvsMogtmJeHDdrc=\ngithub.com/boombuler/barcode v1.0.0/go.mod h1:paBWMcWSl3LHKBqUq+rly7CNSldXjb2rDl3JlRe0mD8=\ngithub.com/davecgh/go-spew v1.1.0 h1:ZDRjVQ15GmhC3fiQ8ni8+OwkZQO4DARzQgrnXU1Liz8=\ngithub.com/davecgh/go-spew v1.1.0/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=\ngithub.com/jung-kurt/gofpdf v1.0.0/go.mod h1:7Id9E/uU8ce6rXgefFLlgrJj/GYY22cpxn+r32jIOes=\ngithub.com/phpdave11/gofpdi v1.0.7 h1:k2oy4yhkQopCK+qW8KjCla0iU2RpDow+QUDmH9DDt44=\ngithub.com/phpdave11/gofpdi v1.0.7/go.mod h1:vBmVV0Do6hSBHC8uKUQ71JGW+ZGQq74llk/7bXwjDoI=\ngithub.com/pkg/errors v0.8.1 h1:iURUrRGxPUNPdy5/HRSm+Yj6okJ6UtLINN0Q9M4+h3I=\ngithub.com/pkg/errors v0.8.1/go.mod h1:bwawxfHBFNV+L2hUp1rHADufV3IMtnDRdf1r5NINEl0=\ngithub.com/pmezard/go-difflib v1.0.0 h1:4DBwDE0NGyQoBHbLQYPwSUPoCMWR5BEzIk/f1lZbAQM=\ngithub.com/pmezard/go-difflib v1.0.0/go.mod h1:iKH77koFhYxTK1pcRnkKkqfTogsbg7gZNVY4sRDYZ/4=\ngithub.com/ruudk/golang-pdf417 v0.0.0-20181029194003-1af4ab5afa58 h1:nlG4Wa5+minh3S9LVFtNoY+GVRiudA2e3EVfcCi3RCA=\ngithub.com/ruudk/golang-pdf417 v0.0.0-20181029194003-1af4ab5afa58/go.mod h1:6lfFZQK844Gfx8o5WFuvpxWRwnSoipWe/p622j1v06w=\ngithub.com/stretchr/testify v1.2.2 h1:bSDNvY7ZPG5RlJ8otE/7V6gMiyenm9RtJ7IUVIAoJ1w=\ngithub.com/stretchr/testify v1.2.2/go.mod h1:a8OnRcib4nhh0OaRAV+Yts87kKdq0PP7pXfy6kDkUVs=\ngolang.org/x/image v0.0.0-20190902063713-cb417be4ba39 h1:4dQcAORh9oYBwVSBVIkP489LUPC+f1HBkTYXgmqfR+o=\ngolang.org/x/image v0.0.0-20190902063713-cb417be4ba39/go.mod h1:FeLwcggjj3mMvU+oOTbSwawSJRM1uh48EjtB4UJZlP0=\ngolang.org/x/image v0.0.0-20190910094157-69e4b8554b2a h1:gHevYm0pO4QUbwy8Dmdr01R5r1BuKtfYqRqF0h/Cbh0=\ngolang.org/x/image v0.0.0-20190910094157-69e4b8554b2a/go.mod h1:FeLwcggjj3mMvU+oOTbSwawSJRM1uh48EjtB4UJZlP0=\ngolang.org/x/text v0.3.0/go.mod h1:NqM8EUOU14njkJ3fqMW+pc6Ldnwhi/IjpwHt7yyuwOQ=\n"
        },
        {
          "name": "grid.go",
          "type": "blob",
          "size": 13.6396484375,
          "content": "package gofpdf\n\nimport (\n\t\"math\"\n\t\"strconv\"\n)\n\nfunc unused(args ...interface{}) {\n}\n\n// RGBType holds fields for red, green and blue color components (0..255)\ntype RGBType struct {\n\tR, G, B int\n}\n\n// RGBAType holds fields for red, green and blue color components (0..255) and\n// an alpha transparency value (0..1)\ntype RGBAType struct {\n\tR, G, B int\n\tAlpha   float64\n}\n\n// StateType holds various commonly used drawing values for convenient\n// retrieval (StateGet()) and restore (Put) methods.\ntype StateType struct {\n\tclrDraw, clrText, clrFill RGBType\n\tlineWd                    float64\n\tfontSize                  float64\n\talpha                     float64\n\tblendStr                  string\n\tcellMargin                float64\n}\n\n// StateGet returns a variable that contains common state values.\nfunc StateGet(pdf *Fpdf) (st StateType) {\n\tst.clrDraw.R, st.clrDraw.G, st.clrDraw.B = pdf.GetDrawColor()\n\tst.clrFill.R, st.clrFill.G, st.clrFill.B = pdf.GetFillColor()\n\tst.clrText.R, st.clrText.G, st.clrText.B = pdf.GetTextColor()\n\tst.lineWd = pdf.GetLineWidth()\n\t_, st.fontSize = pdf.GetFontSize()\n\tst.alpha, st.blendStr = pdf.GetAlpha()\n\tst.cellMargin = pdf.GetCellMargin()\n\treturn\n}\n\n// Put sets the common state values contained in the state structure\n// specified by st.\nfunc (st StateType) Put(pdf *Fpdf) {\n\tpdf.SetDrawColor(st.clrDraw.R, st.clrDraw.G, st.clrDraw.B)\n\tpdf.SetFillColor(st.clrFill.R, st.clrFill.G, st.clrFill.B)\n\tpdf.SetTextColor(st.clrText.R, st.clrText.G, st.clrText.B)\n\tpdf.SetLineWidth(st.lineWd)\n\tpdf.SetFontUnitSize(st.fontSize)\n\tpdf.SetAlpha(st.alpha, st.blendStr)\n\tpdf.SetCellMargin(st.cellMargin)\n}\n\n// TickFormatFncType defines a callback for label drawing.\ntype TickFormatFncType func(val float64, precision int) string\n\n// defaultFormatter returns the string form of val with precision decimal places.\nfunc defaultFormatter(val float64, precision int) string {\n\treturn strconv.FormatFloat(val, 'f', precision, 64)\n}\n\n// GridType assists with the generation of graphs. It allows the application to\n// work with logical data coordinates rather than page coordinates and assists\n// with the drawing of a background grid.\ntype GridType struct {\n\t// Chart coordinates in page units\n\tx, y, w, h float64\n\t// X, Y, Wd, Ht float64\n\t// Slopes and intercepts scale data points to graph coordinates linearly\n\txm, xb, ym, yb float64\n\t// Tickmarks\n\txTicks, yTicks []float64\n\t// Labels are inside of graph boundary\n\tXLabelIn, YLabelIn bool\n\t// Labels on X-axis should be rotated\n\tXLabelRotate bool\n\t// Formatters; use nil to eliminate labels\n\tXTickStr, YTickStr TickFormatFncType\n\t// Subdivisions between tickmarks\n\tXDiv, YDiv int\n\t// Formatting precision\n\txPrecision, yPrecision int\n\t// Line and label colors\n\tClrText, ClrMain, ClrSub RGBAType\n\t// Line thickness\n\tWdMain, WdSub float64\n\t// Label height in points\n\tTextSize float64\n}\n\n// linear returns the slope and y-intercept of the straight line joining the\n// two specified points. For scaling purposes, associate the arguments as\n// follows: x1: observed low value, y1: desired low value, x2: observed high\n// value, y2: desired high value.\nfunc linear(x1, y1, x2, y2 float64) (slope, intercept float64) {\n\tif x2 != x1 {\n\t\tslope = (y2 - y1) / (x2 - x1)\n\t\tintercept = y2 - x2*slope\n\t}\n\treturn\n}\n\n// linearTickmark returns the slope and intercept that will linearly map data\n// values (the range of which is specified by the tickmark slice tm) to page\n// values (the range of which is specified by lo and hi).\nfunc linearTickmark(tm []float64, lo, hi float64) (slope, intercept float64) {\n\tln := len(tm)\n\tif ln > 0 {\n\t\tslope, intercept = linear(tm[0], lo, tm[ln-1], hi)\n\t}\n\treturn\n}\n\n// NewGrid returns a variable of type GridType that is initialized to draw on a\n// rectangle of width w and height h with the upper left corner positioned at\n// point (x, y). The coordinates are in page units, that is, the same as those\n// specified in New().\n//\n// The returned variable is initialized with a very simple default tickmark\n// layout that ranges from 0 to 1 in both axes. Prior to calling Grid(), the\n// application may establish a more suitable tickmark layout by calling the\n// methods TickmarksContainX() and TickmarksContainY(). These methods bound the\n// data range with appropriate boundaries and divisions. Alternatively, if the\n// exact extent and divisions of the tickmark layout are known, the methods\n// TickmarksExtentX() and TickmarksExtentY may be called instead.\nfunc NewGrid(x, y, w, h float64) (grid GridType) {\n\tgrid.x = x\n\tgrid.y = y\n\tgrid.w = w\n\tgrid.h = h\n\tgrid.TextSize = 7 // Points\n\tgrid.TickmarksExtentX(0, 1, 1)\n\tgrid.TickmarksExtentY(0, 1, 1)\n\tgrid.XLabelIn = false\n\tgrid.YLabelIn = false\n\tgrid.XLabelRotate = false\n\tgrid.XDiv = 10\n\tgrid.YDiv = 10\n\tgrid.ClrText = RGBAType{R: 0, G: 0, B: 0, Alpha: 1}\n\tgrid.ClrMain = RGBAType{R: 128, G: 160, B: 128, Alpha: 1}\n\tgrid.ClrSub = RGBAType{R: 192, G: 224, B: 192, Alpha: 1}\n\tgrid.WdMain = 0.1\n\tgrid.WdSub = 0.1\n\tgrid.YTickStr = defaultFormatter\n\tgrid.XTickStr = defaultFormatter\n\treturn\n}\n\n// WdAbs returns the absolute value of dataWd, specified in logical data units,\n// that has been converted to the unit of measure specified in New().\nfunc (g GridType) WdAbs(dataWd float64) float64 {\n\treturn math.Abs(g.xm * dataWd)\n}\n\n// Wd converts dataWd, specified in logical data units, to the unit of measure\n// specified in New().\nfunc (g GridType) Wd(dataWd float64) float64 {\n\treturn g.xm * dataWd\n}\n\n// XY converts dataX and dataY, specified in logical data units, to the X and Y\n// position on the current page.\nfunc (g GridType) XY(dataX, dataY float64) (x, y float64) {\n\treturn g.xm*dataX + g.xb, g.ym*dataY + g.yb\n}\n\n// Pos returns the point, in page units, indicated by the relative positions\n// xRel and yRel. These are values between 0 and 1. xRel specifies the relative\n// position between the grid's left and right edges. yRel specifies the\n// relative position between the grid's bottom and top edges.\nfunc (g GridType) Pos(xRel, yRel float64) (x, y float64) {\n\tx = g.w*xRel + g.x\n\ty = g.h*(1-yRel) + g.y\n\treturn\n}\n\n// X converts dataX, specified in logical data units, to the X position on the\n// current page.\nfunc (g GridType) X(dataX float64) float64 {\n\treturn g.xm*dataX + g.xb\n}\n\n// HtAbs returns the absolute value of dataHt, specified in logical data units,\n// that has been converted to the unit of measure specified in New().\nfunc (g GridType) HtAbs(dataHt float64) float64 {\n\treturn math.Abs(g.ym * dataHt)\n}\n\n// Ht converts dataHt, specified in logical data units, to the unit of measure\n// specified in New().\nfunc (g GridType) Ht(dataHt float64) float64 {\n\treturn g.ym * dataHt\n}\n\n// Y converts dataY, specified in logical data units, to the Y position on the\n// current page.\nfunc (g GridType) Y(dataY float64) float64 {\n\treturn g.ym*dataY + g.yb\n}\n\n// XRange returns the minimum and maximum values for the current tickmark\n// sequence. These correspond to the data values of the graph's left and right\n// edges.\nfunc (g GridType) XRange() (min, max float64) {\n\tmin = g.xTicks[0]\n\tmax = g.xTicks[len(g.xTicks)-1]\n\treturn\n}\n\n// YRange returns the minimum and maximum values for the current tickmark\n// sequence. These correspond to the data values of the graph's bottom and top\n// edges.\nfunc (g GridType) YRange() (min, max float64) {\n\tmin = g.yTicks[0]\n\tmax = g.yTicks[len(g.yTicks)-1]\n\treturn\n}\n\n// TickmarksContainX sets the tickmarks to be shown by Grid() in the horizontal\n// dimension. The argument min and max specify the minimum and maximum values\n// to be contained within the grid. The tickmark values that are generated are\n// suitable for general purpose graphs.\n//\n// See TickmarkExtentX() for an alternative to this method to be used when the\n// exact values of the tickmarks are to be set by the application.\nfunc (g *GridType) TickmarksContainX(min, max float64) {\n\tg.xTicks, g.xPrecision = Tickmarks(min, max)\n\tg.xm, g.xb = linearTickmark(g.xTicks, g.x, g.x+g.w)\n}\n\n// TickmarksContainY sets the tickmarks to be shown by Grid() in the vertical\n// dimension. The argument min and max specify the minimum and maximum values\n// to be contained within the grid. The tickmark values that are generated are\n// suitable for general purpose graphs.\n//\n// See TickmarkExtentY() for an alternative to this method to be used when the\n// exact values of the tickmarks are to be set by the application.\nfunc (g *GridType) TickmarksContainY(min, max float64) {\n\tg.yTicks, g.yPrecision = Tickmarks(min, max)\n\tg.ym, g.yb = linearTickmark(g.yTicks, g.y+g.h, g.y)\n}\n\nfunc extent(min, div float64, count int) (tm []float64, precision int) {\n\ttm = make([]float64, count+1)\n\tfor j := 0; j <= count; j++ {\n\t\ttm[j] = min\n\t\tmin += div\n\t}\n\tprecision = TickmarkPrecision(div)\n\treturn\n}\n\n// TickmarksExtentX sets the tickmarks to be shown by Grid() in the horizontal\n// dimension. count specifies number of major tickmark subdivisions to be\n// graphed. min specifies the leftmost data value. div specifies, in data\n// units, the extent of each major tickmark subdivision.\n//\n// See TickmarkContainX() for an alternative to this method to be used when\n// viewer-friendly tickmarks are to be determined automatically.\nfunc (g *GridType) TickmarksExtentX(min, div float64, count int) {\n\tg.xTicks, g.xPrecision = extent(min, div, count)\n\tg.xm, g.xb = linearTickmark(g.xTicks, g.x, g.x+g.w)\n}\n\n// TickmarksExtentY sets the tickmarks to be shown by Grid() in the vertical\n// dimension. count specifies number of major tickmark subdivisions to be\n// graphed. min specifies the bottommost data value. div specifies, in data\n// units, the extent of each major tickmark subdivision.\n//\n// See TickmarkContainY() for an alternative to this method to be used when\n// viewer-friendly tickmarks are to be determined automatically.\nfunc (g *GridType) TickmarksExtentY(min, div float64, count int) {\n\tg.yTicks, g.yPrecision = extent(min, div, count)\n\tg.ym, g.yb = linearTickmark(g.yTicks, g.y+g.h, g.y)\n}\n\n// func (g *GridType) SetXExtent(dataLf, paperLf, dataRt, paperRt float64) {\n// \tg.xm, g.xb = linear(dataLf, paperLf, dataRt, paperRt)\n// }\n\n// func (g *GridType) SetYExtent(dataTp, paperTp, dataBt, paperBt float64) {\n// \tg.ym, g.yb = linear(dataTp, paperTp, dataBt, paperBt)\n// }\n\nfunc lineAttr(pdf *Fpdf, clr RGBAType, lineWd float64) {\n\tpdf.SetLineWidth(lineWd)\n\tpdf.SetAlpha(clr.Alpha, \"Normal\")\n\tpdf.SetDrawColor(clr.R, clr.G, clr.B)\n}\n\n// Grid generates a graph-paperlike set of grid lines on the current page.\nfunc (g GridType) Grid(pdf *Fpdf) {\n\tvar st StateType\n\tvar yLen, xLen int\n\tvar textSz, halfTextSz, yMin, yMax, xMin, xMax, yDiv, xDiv float64\n\tvar str string\n\tvar strOfs, strWd, tp, bt, lf, rt, drawX, drawY float64\n\n\txLen = len(g.xTicks)\n\tyLen = len(g.yTicks)\n\tif xLen > 1 && yLen > 1 {\n\n\t\tst = StateGet(pdf)\n\n\t\tline := func(x1, y1, x2, y2 float64, heavy bool) {\n\t\t\tif heavy {\n\t\t\t\tlineAttr(pdf, g.ClrMain, g.WdMain)\n\t\t\t} else {\n\t\t\t\tlineAttr(pdf, g.ClrSub, g.WdSub)\n\t\t\t}\n\t\t\tpdf.Line(x1, y1, x2, y2)\n\t\t}\n\n\t\ttextSz = pdf.PointToUnitConvert(g.TextSize)\n\t\thalfTextSz = textSz / 2\n\n\t\tpdf.SetAutoPageBreak(false, 0)\n\t\tpdf.SetFontUnitSize(textSz)\n\t\tstrOfs = pdf.GetStringWidth(\"0\")\n\t\tpdf.SetFillColor(255, 255, 255)\n\t\tpdf.SetCellMargin(0)\n\n\t\txMin = g.xTicks[0]\n\t\txMax = g.xTicks[xLen-1]\n\n\t\tyMin = g.yTicks[0]\n\t\tyMax = g.yTicks[yLen-1]\n\n\t\tlf = g.X(xMin)\n\t\trt = g.X(xMax)\n\t\tbt = g.Y(yMin)\n\t\ttp = g.Y(yMax)\n\n\t\t// Verticals along X axis\n\t\txDiv = g.xTicks[1] - g.xTicks[0]\n\t\tif g.XDiv > 0 {\n\t\t\txDiv = xDiv / float64(g.XDiv)\n\t\t}\n\t\txDiv = g.Wd(xDiv)\n\t\tfor j, x := range g.xTicks {\n\t\t\tdrawX = g.X(x)\n\t\t\tline(drawX, tp, drawX, bt, true)\n\t\t\tif j < xLen-1 {\n\t\t\t\tfor k := 1; k < g.XDiv; k++ {\n\t\t\t\t\tdrawX += xDiv\n\t\t\t\t\tline(drawX, tp, drawX, bt, false)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Horizontals along Y axis\n\t\tyDiv = g.yTicks[1] - g.yTicks[0]\n\t\tif g.YDiv > 0 {\n\t\t\tyDiv = yDiv / float64(g.YDiv)\n\t\t}\n\t\tyDiv = g.Ht(yDiv)\n\t\tfor j, y := range g.yTicks {\n\t\t\tdrawY = g.Y(y)\n\t\t\tline(lf, drawY, rt, drawY, true)\n\t\t\tif j < yLen-1 {\n\t\t\t\tfor k := 1; k < g.YDiv; k++ {\n\t\t\t\t\tdrawY += yDiv\n\t\t\t\t\tline(lf, drawY, rt, drawY, false)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// X labels\n\t\tif g.XTickStr != nil {\n\t\t\tdrawY = bt\n\t\t\tfor _, x := range g.xTicks {\n\t\t\t\tstr = g.XTickStr(x, g.xPrecision)\n\t\t\t\tstrWd = pdf.GetStringWidth(str)\n\t\t\t\tdrawX = g.X(x)\n\t\t\t\tif g.XLabelRotate {\n\t\t\t\t\tpdf.TransformBegin()\n\t\t\t\t\tpdf.TransformRotate(90, drawX, drawY)\n\t\t\t\t\tif g.XLabelIn {\n\t\t\t\t\t\tpdf.SetXY(drawX+strOfs, drawY-halfTextSz)\n\t\t\t\t\t} else {\n\t\t\t\t\t\tpdf.SetXY(drawX-strOfs-strWd, drawY-halfTextSz)\n\t\t\t\t\t}\n\t\t\t\t\tpdf.CellFormat(strWd, textSz, str, \"\", 0, \"L\", true, 0, \"\")\n\t\t\t\t\tpdf.TransformEnd()\n\t\t\t\t} else {\n\t\t\t\t\tdrawX -= strWd / 2.0\n\t\t\t\t\tif g.XLabelIn {\n\t\t\t\t\t\tpdf.SetXY(drawX, drawY-textSz-strOfs)\n\t\t\t\t\t} else {\n\t\t\t\t\t\tpdf.SetXY(drawX, drawY+strOfs)\n\t\t\t\t\t}\n\t\t\t\t\tpdf.CellFormat(strWd, textSz, str, \"\", 0, \"L\", true, 0, \"\")\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Y labels\n\t\tif g.YTickStr != nil {\n\t\t\tdrawX = lf\n\t\t\tfor _, y := range g.yTicks {\n\t\t\t\t// str = strconv.FormatFloat(y, 'f', g.yPrecision, 64)\n\t\t\t\tstr = g.YTickStr(y, g.yPrecision)\n\t\t\t\tstrWd = pdf.GetStringWidth(str)\n\t\t\t\tif g.YLabelIn {\n\t\t\t\t\tpdf.SetXY(drawX+strOfs, g.Y(y)-halfTextSz)\n\t\t\t\t} else {\n\t\t\t\t\tpdf.SetXY(lf-strOfs-strWd, g.Y(y)-halfTextSz)\n\t\t\t\t}\n\t\t\t\tpdf.CellFormat(strWd, textSz, str, \"\", 0, \"L\", true, 0, \"\")\n\t\t\t}\n\t\t}\n\n\t\t// Restore drawing attributes\n\t\tst.Put(pdf)\n\n\t}\n\n}\n\n// Plot plots a series of count line segments from xMin to xMax. It repeatedly\n// calls fnc(x) to retrieve the y value associate with x. The currently\n// selected line drawing attributes are used.\nfunc (g GridType) Plot(pdf *Fpdf, xMin, xMax float64, count int, fnc func(x float64) (y float64)) {\n\tif count > 0 {\n\t\tvar x, delta, drawX0, drawY0, drawX1, drawY1 float64\n\t\tdelta = (xMax - xMin) / float64(count)\n\t\tx = xMin\n\t\tfor j := 0; j <= count; j++ {\n\t\t\tif j == 0 {\n\t\t\t\tdrawX1 = g.X(x)\n\t\t\t\tdrawY1 = g.Y(fnc(x))\n\t\t\t} else {\n\t\t\t\tpdf.Line(drawX0, drawY0, drawX1, drawY1)\n\t\t\t}\n\t\t\tx += delta\n\t\t\tdrawX0 = drawX1\n\t\t\tdrawY0 = drawY1\n\t\t\tdrawX1 = g.X(x)\n\t\t\tdrawY1 = g.Y(fnc(x))\n\t\t}\n\t}\n}\n"
        },
        {
          "name": "htmlbasic.go",
          "type": "blob",
          "size": 6.2900390625,
          "content": "/*\n * Copyright (c) 2014 Kurt Jung (Gmail: kurt.w.jung)\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\n * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\n * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\npackage gofpdf\n\nimport (\n\t\"regexp\"\n\t\"strings\"\n)\n\n// HTMLBasicSegmentType defines a segment of literal text in which the current\n// attributes do not vary, or an open tag or a close tag.\ntype HTMLBasicSegmentType struct {\n\tCat  byte              // 'O' open tag, 'C' close tag, 'T' text\n\tStr  string            // Literal text unchanged, tags are lower case\n\tAttr map[string]string // Attribute keys are lower case\n}\n\n// HTMLBasicTokenize returns a list of HTML tags and literal elements. This is\n// done with regular expressions, so the result is only marginally better than\n// useless.\nfunc HTMLBasicTokenize(htmlStr string) (list []HTMLBasicSegmentType) {\n\t// This routine is adapted from http://www.fpdf.org/\n\tlist = make([]HTMLBasicSegmentType, 0, 16)\n\thtmlStr = strings.Replace(htmlStr, \"\\n\", \" \", -1)\n\thtmlStr = strings.Replace(htmlStr, \"\\r\", \"\", -1)\n\ttagRe, _ := regexp.Compile(`(?U)<.*>`)\n\tattrRe, _ := regexp.Compile(`([^=]+)=[\"']?([^\"']+)`)\n\tcapList := tagRe.FindAllStringIndex(htmlStr, -1)\n\tif capList != nil {\n\t\tvar seg HTMLBasicSegmentType\n\t\tvar parts []string\n\t\tpos := 0\n\t\tfor _, cap := range capList {\n\t\t\tif pos < cap[0] {\n\t\t\t\tseg.Cat = 'T'\n\t\t\t\tseg.Str = htmlStr[pos:cap[0]]\n\t\t\t\tseg.Attr = nil\n\t\t\t\tlist = append(list, seg)\n\t\t\t}\n\t\t\tif htmlStr[cap[0]+1] == '/' {\n\t\t\t\tseg.Cat = 'C'\n\t\t\t\tseg.Str = strings.ToLower(htmlStr[cap[0]+2 : cap[1]-1])\n\t\t\t\tseg.Attr = nil\n\t\t\t\tlist = append(list, seg)\n\t\t\t} else {\n\t\t\t\t// Extract attributes\n\t\t\t\tparts = strings.Split(htmlStr[cap[0]+1:cap[1]-1], \" \")\n\t\t\t\tif len(parts) > 0 {\n\t\t\t\t\tfor j, part := range parts {\n\t\t\t\t\t\tif j == 0 {\n\t\t\t\t\t\t\tseg.Cat = 'O'\n\t\t\t\t\t\t\tseg.Str = strings.ToLower(parts[0])\n\t\t\t\t\t\t\tseg.Attr = make(map[string]string)\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tattrList := attrRe.FindAllStringSubmatch(part, -1)\n\t\t\t\t\t\t\tif attrList != nil {\n\t\t\t\t\t\t\t\tfor _, attr := range attrList {\n\t\t\t\t\t\t\t\t\tseg.Attr[strings.ToLower(attr[1])] = attr[2]\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tlist = append(list, seg)\n\t\t\t\t}\n\t\t\t}\n\t\t\tpos = cap[1]\n\t\t}\n\t\tif len(htmlStr) > pos {\n\t\t\tseg.Cat = 'T'\n\t\t\tseg.Str = htmlStr[pos:]\n\t\t\tseg.Attr = nil\n\t\t\tlist = append(list, seg)\n\t\t}\n\t} else {\n\t\tlist = append(list, HTMLBasicSegmentType{Cat: 'T', Str: htmlStr, Attr: nil})\n\t}\n\treturn\n}\n\n// HTMLBasicType is used for rendering a very basic subset of HTML. It supports\n// only hyperlinks and bold, italic and underscore attributes. In the Link\n// structure, the ClrR, ClrG and ClrB fields (0 through 255) define the color\n// of hyperlinks. The Bold, Italic and Underscore values define the hyperlink\n// style.\ntype HTMLBasicType struct {\n\tpdf  *Fpdf\n\tLink struct {\n\t\tClrR, ClrG, ClrB         int\n\t\tBold, Italic, Underscore bool\n\t}\n}\n\n// HTMLBasicNew returns an instance that facilitates writing basic HTML in the\n// specified PDF file.\nfunc (f *Fpdf) HTMLBasicNew() (html HTMLBasicType) {\n\thtml.pdf = f\n\thtml.Link.ClrR, html.Link.ClrG, html.Link.ClrB = 0, 0, 128\n\thtml.Link.Bold, html.Link.Italic, html.Link.Underscore = false, false, true\n\treturn\n}\n\n// Write prints text from the current position using the currently selected\n// font. See HTMLBasicNew() to create a receiver that is associated with the\n// PDF document instance. The text can be encoded with a basic subset of HTML\n// that includes hyperlinks and tags for italic (I), bold (B), underscore\n// (U) and center (CENTER) attributes. When the right margin is reached a line\n// break occurs and text continues from the left margin. Upon method exit, the\n// current position is left at the end of the text.\n//\n// lineHt indicates the line height in the unit of measure specified in New().\nfunc (html *HTMLBasicType) Write(lineHt float64, htmlStr string) {\n\tvar boldLvl, italicLvl, underscoreLvl, linkBold, linkItalic, linkUnderscore int\n\tvar textR, textG, textB = html.pdf.GetTextColor()\n\tvar hrefStr string\n\tif html.Link.Bold {\n\t\tlinkBold = 1\n\t}\n\tif html.Link.Italic {\n\t\tlinkItalic = 1\n\t}\n\tif html.Link.Underscore {\n\t\tlinkUnderscore = 1\n\t}\n\tsetStyle := func(boldAdj, italicAdj, underscoreAdj int) {\n\t\tstyleStr := \"\"\n\t\tboldLvl += boldAdj\n\t\tif boldLvl > 0 {\n\t\t\tstyleStr += \"B\"\n\t\t}\n\t\titalicLvl += italicAdj\n\t\tif italicLvl > 0 {\n\t\t\tstyleStr += \"I\"\n\t\t}\n\t\tunderscoreLvl += underscoreAdj\n\t\tif underscoreLvl > 0 {\n\t\t\tstyleStr += \"U\"\n\t\t}\n\t\thtml.pdf.SetFont(\"\", styleStr, 0)\n\t}\n\tputLink := func(urlStr, txtStr string) {\n\t\t// Put a hyperlink\n\t\thtml.pdf.SetTextColor(html.Link.ClrR, html.Link.ClrG, html.Link.ClrB)\n\t\tsetStyle(linkBold, linkItalic, linkUnderscore)\n\t\thtml.pdf.WriteLinkString(lineHt, txtStr, urlStr)\n\t\tsetStyle(-linkBold, -linkItalic, -linkUnderscore)\n\t\thtml.pdf.SetTextColor(textR, textG, textB)\n\t}\n\tlist := HTMLBasicTokenize(htmlStr)\n\tvar ok bool\n\talignStr := \"L\"\n\tfor _, el := range list {\n\t\tswitch el.Cat {\n\t\tcase 'T':\n\t\t\tif len(hrefStr) > 0 {\n\t\t\t\tputLink(hrefStr, el.Str)\n\t\t\t\threfStr = \"\"\n\t\t\t} else {\n\t\t\t\tif alignStr == \"C\" || alignStr == \"R\" {\n\t\t\t\t\thtml.pdf.WriteAligned(0, lineHt, el.Str, alignStr)\n\t\t\t\t} else {\n\t\t\t\t\thtml.pdf.Write(lineHt, el.Str)\n\t\t\t\t}\n\t\t\t}\n\t\tcase 'O':\n\t\t\tswitch el.Str {\n\t\t\tcase \"b\":\n\t\t\t\tsetStyle(1, 0, 0)\n\t\t\tcase \"i\":\n\t\t\t\tsetStyle(0, 1, 0)\n\t\t\tcase \"u\":\n\t\t\t\tsetStyle(0, 0, 1)\n\t\t\tcase \"br\":\n\t\t\t\thtml.pdf.Ln(lineHt)\n\t\t\tcase \"center\":\n\t\t\t\thtml.pdf.Ln(lineHt)\n\t\t\t\talignStr = \"C\"\n\t\t\tcase \"right\":\n\t\t\t\thtml.pdf.Ln(lineHt)\n\t\t\t\talignStr = \"R\"\n\t\t\tcase \"left\":\n\t\t\t\thtml.pdf.Ln(lineHt)\n\t\t\t\talignStr = \"L\"\n\t\t\tcase \"a\":\n\t\t\t\threfStr, ok = el.Attr[\"href\"]\n\t\t\t\tif !ok {\n\t\t\t\t\threfStr = \"\"\n\t\t\t\t}\n\t\t\t}\n\t\tcase 'C':\n\t\t\tswitch el.Str {\n\t\t\tcase \"b\":\n\t\t\t\tsetStyle(-1, 0, 0)\n\t\t\tcase \"i\":\n\t\t\t\tsetStyle(0, -1, 0)\n\t\t\tcase \"u\":\n\t\t\t\tsetStyle(0, 0, -1)\n\t\t\tcase \"center\":\n\t\t\t\thtml.pdf.Ln(lineHt)\n\t\t\t\talignStr = \"L\"\n\t\t\tcase \"right\":\n\t\t\t\thtml.pdf.Ln(lineHt)\n\t\t\t\talignStr = \"L\"\n\t\t\t}\n\t\t}\n\t}\n}\n"
        },
        {
          "name": "image",
          "type": "tree",
          "content": null
        },
        {
          "name": "internal",
          "type": "tree",
          "content": null
        },
        {
          "name": "label.go",
          "type": "blob",
          "size": 2.205078125,
          "content": "package gofpdf\n\n// Adapted from Nice Numbers for Graph Labels by Paul Heckbert from \"Graphics\n// Gems\", Academic Press, 1990\n\n// Paul Heckbert\t2 Dec 88\n\n// https://github.com/erich666/GraphicsGems\n\n// LICENSE\n\n// This code repository predates the concept of Open Source, and predates most\n// licenses along such lines. As such, the official license truly is:\n\n// EULA: The Graphics Gems code is copyright-protected. In other words, you\n// cannot claim the text of the code as your own and resell it. Using the code\n// is permitted in any program, product, or library, non-commercial or\n// commercial. Giving credit is not required, though is a nice gesture. The\n// code comes as-is, and if there are any flaws or problems with any Gems code,\n// nobody involved with Gems - authors, editors, publishers, or webmasters -\n// are to be held responsible. Basically, don't be a jerk, and remember that\n// anything free comes with no guarantee.\n\nimport (\n\t\"math\"\n)\n\n// niceNum returns a \"nice\" number approximately equal to x. The number is\n// rounded if round is true, converted to its ceiling otherwise.\nfunc niceNum(val float64, round bool) float64 {\n\tvar nf float64\n\n\texp := int(math.Floor(math.Log10(val)))\n\tf := val / math.Pow10(exp)\n\tif round {\n\t\tswitch {\n\t\tcase f < 1.5:\n\t\t\tnf = 1\n\t\tcase f < 3.0:\n\t\t\tnf = 2\n\t\tcase f < 7.0:\n\t\t\tnf = 5\n\t\tdefault:\n\t\t\tnf = 10\n\t\t}\n\t} else {\n\t\tswitch {\n\t\tcase f <= 1:\n\t\t\tnf = 1\n\t\tcase f <= 2.0:\n\t\t\tnf = 2\n\t\tcase f <= 5.0:\n\t\t\tnf = 5\n\t\tdefault:\n\t\t\tnf = 10\n\t\t}\n\t}\n\treturn nf * math.Pow10(exp)\n}\n\n// TickmarkPrecision returns an appropriate precision value for label\n// formatting.\nfunc TickmarkPrecision(div float64) int {\n\treturn int(math.Max(-math.Floor(math.Log10(div)), 0))\n}\n\n// Tickmarks returns a slice of tickmarks appropriate for a chart axis and an\n// appropriate precision for formatting purposes. The values min and max will\n// be contained within the tickmark range.\nfunc Tickmarks(min, max float64) (list []float64, precision int) {\n\tif max > min {\n\t\tspread := niceNum(max-min, false)\n\t\td := niceNum((spread / 4), true)\n\t\tgraphMin := math.Floor(min/d) * d\n\t\tgraphMax := math.Ceil(max/d) * d\n\t\tprecision = TickmarkPrecision(d)\n\t\tfor x := graphMin; x < graphMax+0.5*d; x += d {\n\t\t\tlist = append(list, x)\n\t\t}\n\t}\n\treturn\n}\n"
        },
        {
          "name": "layer.go",
          "type": "blob",
          "size": 3.3662109375,
          "content": "/*\n * Copyright (c) 2014 Kurt Jung (Gmail: kurt.w.jung)\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\n * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\n * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\npackage gofpdf\n\n// Routines in this file are translated from\n// http://www.fpdf.org/en/script/script97.php\n\ntype layerType struct {\n\tname    string\n\tvisible bool\n\tobjNum  int // object number\n}\n\ntype layerRecType struct {\n\tlist          []layerType\n\tcurrentLayer  int\n\topenLayerPane bool\n}\n\nfunc (f *Fpdf) layerInit() {\n\tf.layer.list = make([]layerType, 0)\n\tf.layer.currentLayer = -1\n\tf.layer.openLayerPane = false\n}\n\n// AddLayer defines a layer that can be shown or hidden when the document is\n// displayed. name specifies the layer name that the document reader will\n// display in the layer list. visible specifies whether the layer will be\n// initially visible. The return value is an integer ID that is used in a call\n// to BeginLayer().\nfunc (f *Fpdf) AddLayer(name string, visible bool) (layerID int) {\n\tlayerID = len(f.layer.list)\n\tf.layer.list = append(f.layer.list, layerType{name: name, visible: visible})\n\treturn\n}\n\n// BeginLayer is called to begin adding content to the specified layer. All\n// content added to the page between a call to BeginLayer and a call to\n// EndLayer is added to the layer specified by id. See AddLayer for more\n// details.\nfunc (f *Fpdf) BeginLayer(id int) {\n\tf.EndLayer()\n\tif id >= 0 && id < len(f.layer.list) {\n\t\tf.outf(\"/OC /OC%d BDC\", id)\n\t\tf.layer.currentLayer = id\n\t}\n}\n\n// EndLayer is called to stop adding content to the currently active layer. See\n// BeginLayer for more details.\nfunc (f *Fpdf) EndLayer() {\n\tif f.layer.currentLayer >= 0 {\n\t\tf.out(\"EMC\")\n\t\tf.layer.currentLayer = -1\n\t}\n}\n\n// OpenLayerPane advises the document reader to open the layer pane when the\n// document is initially displayed.\nfunc (f *Fpdf) OpenLayerPane() {\n\tf.layer.openLayerPane = true\n}\n\nfunc (f *Fpdf) layerEndDoc() {\n\tif len(f.layer.list) > 0 {\n\t\tif f.pdfVersion < \"1.5\" {\n\t\t\tf.pdfVersion = \"1.5\"\n\t\t}\n\t}\n}\n\nfunc (f *Fpdf) layerPutLayers() {\n\tfor j, l := range f.layer.list {\n\t\tf.newobj()\n\t\tf.layer.list[j].objNum = f.n\n\t\tf.outf(\"<</Type /OCG /Name %s>>\", f.textstring(utf8toutf16(l.name)))\n\t\tf.out(\"endobj\")\n\t}\n}\n\nfunc (f *Fpdf) layerPutResourceDict() {\n\tif len(f.layer.list) > 0 {\n\t\tf.out(\"/Properties <<\")\n\t\tfor j, layer := range f.layer.list {\n\t\t\tf.outf(\"/OC%d %d 0 R\", j, layer.objNum)\n\t\t}\n\t\tf.out(\">>\")\n\t}\n\n}\n\nfunc (f *Fpdf) layerPutCatalog() {\n\tif len(f.layer.list) > 0 {\n\t\tonStr := \"\"\n\t\toffStr := \"\"\n\t\tfor _, layer := range f.layer.list {\n\t\t\tonStr += sprintf(\"%d 0 R \", layer.objNum)\n\t\t\tif !layer.visible {\n\t\t\t\toffStr += sprintf(\"%d 0 R \", layer.objNum)\n\t\t\t}\n\t\t}\n\t\tf.outf(\"/OCProperties <</OCGs [%s] /D <</OFF [%s] /Order [%s]>>>>\", onStr, offStr, onStr)\n\t\tif f.layer.openLayerPane {\n\t\t\tf.out(\"/PageMode /UseOC\")\n\t\t}\n\t}\n}\n"
        },
        {
          "name": "list",
          "type": "tree",
          "content": null
        },
        {
          "name": "makefont",
          "type": "tree",
          "content": null
        },
        {
          "name": "pdf",
          "type": "tree",
          "content": null
        },
        {
          "name": "png.go",
          "type": "blob",
          "size": 5.2587890625,
          "content": "/*\n * Copyright (c) 2013-2016 Kurt Jung (Gmail: kurt.w.jung)\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\n * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\n * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\npackage gofpdf\n\nimport (\n\t\"bytes\"\n\t\"fmt\"\n\t\"strings\"\n)\n\nfunc (f *Fpdf) pngColorSpace(ct byte) (colspace string, colorVal int) {\n\tcolorVal = 1\n\tswitch ct {\n\tcase 0, 4:\n\t\tcolspace = \"DeviceGray\"\n\tcase 2, 6:\n\t\tcolspace = \"DeviceRGB\"\n\t\tcolorVal = 3\n\tcase 3:\n\t\tcolspace = \"Indexed\"\n\tdefault:\n\t\tf.err = fmt.Errorf(\"unknown color type in PNG buffer: %d\", ct)\n\t}\n\treturn\n}\n\nfunc (f *Fpdf) parsepngstream(buf *bytes.Buffer, readdpi bool) (info *ImageInfoType) {\n\tinfo = f.newImageInfo()\n\t// \tCheck signature\n\tif string(buf.Next(8)) != \"\\x89PNG\\x0d\\x0a\\x1a\\x0a\" {\n\t\tf.err = fmt.Errorf(\"not a PNG buffer\")\n\t\treturn\n\t}\n\t// Read header chunk\n\t_ = buf.Next(4)\n\tif string(buf.Next(4)) != \"IHDR\" {\n\t\tf.err = fmt.Errorf(\"incorrect PNG buffer\")\n\t\treturn\n\t}\n\tw := f.readBeInt32(buf)\n\th := f.readBeInt32(buf)\n\tbpc := f.readByte(buf)\n\tif bpc > 8 {\n\t\tf.err = fmt.Errorf(\"16-bit depth not supported in PNG file\")\n\t}\n\tct := f.readByte(buf)\n\tvar colspace string\n\tvar colorVal int\n\tcolspace, colorVal = f.pngColorSpace(ct)\n\tif f.err != nil {\n\t\treturn\n\t}\n\tif f.readByte(buf) != 0 {\n\t\tf.err = fmt.Errorf(\"'unknown compression method in PNG buffer\")\n\t\treturn\n\t}\n\tif f.readByte(buf) != 0 {\n\t\tf.err = fmt.Errorf(\"'unknown filter method in PNG buffer\")\n\t\treturn\n\t}\n\tif f.readByte(buf) != 0 {\n\t\tf.err = fmt.Errorf(\"interlacing not supported in PNG buffer\")\n\t\treturn\n\t}\n\t_ = buf.Next(4)\n\tdp := sprintf(\"/Predictor 15 /Colors %d /BitsPerComponent %d /Columns %d\", colorVal, bpc, w)\n\t// Scan chunks looking for palette, transparency and image data\n\tpal := make([]byte, 0, 32)\n\tvar trns []int\n\tdata := make([]byte, 0, 32)\n\tloop := true\n\tfor loop {\n\t\tn := int(f.readBeInt32(buf))\n\t\t// dbg(\"Loop [%d]\", n)\n\t\tswitch string(buf.Next(4)) {\n\t\tcase \"PLTE\":\n\t\t\t// dbg(\"PLTE\")\n\t\t\t// Read palette\n\t\t\tpal = buf.Next(n)\n\t\t\t_ = buf.Next(4)\n\t\tcase \"tRNS\":\n\t\t\t// dbg(\"tRNS\")\n\t\t\t// Read transparency info\n\t\t\tt := buf.Next(n)\n\t\t\tswitch ct {\n\t\t\tcase 0:\n\t\t\t\ttrns = []int{int(t[1])} // ord(substr($t,1,1)));\n\t\t\tcase 2:\n\t\t\t\ttrns = []int{int(t[1]), int(t[3]), int(t[5])} // array(ord(substr($t,1,1)), ord(substr($t,3,1)), ord(substr($t,5,1)));\n\t\t\tdefault:\n\t\t\t\tpos := strings.Index(string(t), \"\\x00\")\n\t\t\t\tif pos >= 0 {\n\t\t\t\t\ttrns = []int{pos} // array($pos);\n\t\t\t\t}\n\t\t\t}\n\t\t\t_ = buf.Next(4)\n\t\tcase \"IDAT\":\n\t\t\t// dbg(\"IDAT\")\n\t\t\t// Read image data block\n\t\t\tdata = append(data, buf.Next(n)...)\n\t\t\t_ = buf.Next(4)\n\t\tcase \"IEND\":\n\t\t\t// dbg(\"IEND\")\n\t\t\tloop = false\n\t\tcase \"pHYs\":\n\t\t\t// dbg(\"pHYs\")\n\t\t\t// png files theoretically support different x/y dpi\n\t\t\t// but we ignore files like this\n\t\t\t// but if they're the same then we can stamp our info\n\t\t\t// object with it\n\t\t\tx := int(f.readBeInt32(buf))\n\t\t\ty := int(f.readBeInt32(buf))\n\t\t\tunits := buf.Next(1)[0]\n\t\t\t// fmt.Printf(\"got a pHYs block, x=%d, y=%d, u=%d, readdpi=%t\\n\",\n\t\t\t// x, y, int(units), readdpi)\n\t\t\t// only modify the info block if the user wants us to\n\t\t\tif x == y && readdpi {\n\t\t\t\tswitch units {\n\t\t\t\t// if units is 1 then measurement is px/meter\n\t\t\t\tcase 1:\n\t\t\t\t\tinfo.dpi = float64(x) / 39.3701 // inches per meter\n\t\t\t\tdefault:\n\t\t\t\t\tinfo.dpi = float64(x)\n\t\t\t\t}\n\t\t\t}\n\t\t\t_ = buf.Next(4)\n\t\tdefault:\n\t\t\t// dbg(\"default\")\n\t\t\t_ = buf.Next(n + 4)\n\t\t}\n\t\tif loop {\n\t\t\tloop = n > 0\n\t\t}\n\t}\n\tif colspace == \"Indexed\" && len(pal) == 0 {\n\t\tf.err = fmt.Errorf(\"missing palette in PNG buffer\")\n\t}\n\tinfo.w = float64(w)\n\tinfo.h = float64(h)\n\tinfo.cs = colspace\n\tinfo.bpc = int(bpc)\n\tinfo.f = \"FlateDecode\"\n\tinfo.dp = dp\n\tinfo.pal = pal\n\tinfo.trns = trns\n\t// dbg(\"ct [%d]\", ct)\n\tif ct >= 4 {\n\t\t// Separate alpha and color channels\n\t\tvar err error\n\t\tdata, err = sliceUncompress(data)\n\t\tif err != nil {\n\t\t\tf.err = err\n\t\t\treturn\n\t\t}\n\t\tvar color, alpha bytes.Buffer\n\t\tif ct == 4 {\n\t\t\t// Gray image\n\t\t\twidth := int(w)\n\t\t\theight := int(h)\n\t\t\tlength := 2 * width\n\t\t\tvar pos, elPos int\n\t\t\tfor i := 0; i < height; i++ {\n\t\t\t\tpos = (1 + length) * i\n\t\t\t\tcolor.WriteByte(data[pos])\n\t\t\t\talpha.WriteByte(data[pos])\n\t\t\t\telPos = pos + 1\n\t\t\t\tfor k := 0; k < width; k++ {\n\t\t\t\t\tcolor.WriteByte(data[elPos])\n\t\t\t\t\talpha.WriteByte(data[elPos+1])\n\t\t\t\t\telPos += 2\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\t// RGB image\n\t\t\twidth := int(w)\n\t\t\theight := int(h)\n\t\t\tlength := 4 * width\n\t\t\tvar pos, elPos int\n\t\t\tfor i := 0; i < height; i++ {\n\t\t\t\tpos = (1 + length) * i\n\t\t\t\tcolor.WriteByte(data[pos])\n\t\t\t\talpha.WriteByte(data[pos])\n\t\t\t\telPos = pos + 1\n\t\t\t\tfor k := 0; k < width; k++ {\n\t\t\t\t\tcolor.Write(data[elPos : elPos+3])\n\t\t\t\t\talpha.WriteByte(data[elPos+3])\n\t\t\t\t\telPos += 4\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tdata = sliceCompress(color.Bytes())\n\t\tinfo.smask = sliceCompress(alpha.Bytes())\n\t\tif f.pdfVersion < \"1.4\" {\n\t\t\tf.pdfVersion = \"1.4\"\n\t\t}\n\t}\n\tinfo.data = data\n\treturn\n}\n"
        },
        {
          "name": "protect.go",
          "type": "blob",
          "size": 3.263671875,
          "content": "/*\n * Copyright (c) 2013-2014 Kurt Jung (Gmail: kurt.w.jung)\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\n * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\n * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n// PDF protection is adapted from the work of Klemen VODOPIVEC for the fpdf\n// product.\n\npackage gofpdf\n\nimport (\n\t\"crypto/md5\"\n\t\"crypto/rc4\"\n\t\"encoding/binary\"\n\t\"math/rand\"\n)\n\n// Advisory bitflag constants that control document activities\nconst (\n\tCnProtectPrint      = 4\n\tCnProtectModify     = 8\n\tCnProtectCopy       = 16\n\tCnProtectAnnotForms = 32\n)\n\ntype protectType struct {\n\tencrypted     bool\n\tuValue        []byte\n\toValue        []byte\n\tpValue        int\n\tpadding       []byte\n\tencryptionKey []byte\n\tobjNum        int\n\trc4cipher     *rc4.Cipher\n\trc4n          uint32 // Object number associated with rc4 cipher\n}\n\nfunc (p *protectType) rc4(n uint32, buf *[]byte) {\n\tif p.rc4cipher == nil || p.rc4n != n {\n\t\tp.rc4cipher, _ = rc4.NewCipher(p.objectKey(n))\n\t\tp.rc4n = n\n\t}\n\tp.rc4cipher.XORKeyStream(*buf, *buf)\n}\n\nfunc (p *protectType) objectKey(n uint32) []byte {\n\tvar nbuf, b []byte\n\tnbuf = make([]byte, 8, 8)\n\tbinary.LittleEndian.PutUint32(nbuf, n)\n\tb = append(b, p.encryptionKey...)\n\tb = append(b, nbuf[0], nbuf[1], nbuf[2], 0, 0)\n\ts := md5.Sum(b)\n\treturn s[0:10]\n}\n\nfunc oValueGen(userPass, ownerPass []byte) (v []byte) {\n\tvar c *rc4.Cipher\n\ttmp := md5.Sum(ownerPass)\n\tc, _ = rc4.NewCipher(tmp[0:5])\n\tsize := len(userPass)\n\tv = make([]byte, size, size)\n\tc.XORKeyStream(v, userPass)\n\treturn\n}\n\nfunc (p *protectType) uValueGen() (v []byte) {\n\tvar c *rc4.Cipher\n\tc, _ = rc4.NewCipher(p.encryptionKey)\n\tsize := len(p.padding)\n\tv = make([]byte, size, size)\n\tc.XORKeyStream(v, p.padding)\n\treturn\n}\n\nfunc (p *protectType) setProtection(privFlag byte, userPassStr, ownerPassStr string) {\n\tprivFlag = 192 | (privFlag & (CnProtectCopy | CnProtectModify | CnProtectPrint | CnProtectAnnotForms))\n\tp.padding = []byte{\n\t\t0x28, 0xBF, 0x4E, 0x5E, 0x4E, 0x75, 0x8A, 0x41,\n\t\t0x64, 0x00, 0x4E, 0x56, 0xFF, 0xFA, 0x01, 0x08,\n\t\t0x2E, 0x2E, 0x00, 0xB6, 0xD0, 0x68, 0x3E, 0x80,\n\t\t0x2F, 0x0C, 0xA9, 0xFE, 0x64, 0x53, 0x69, 0x7A,\n\t}\n\tuserPass := []byte(userPassStr)\n\tvar ownerPass []byte\n\tif ownerPassStr == \"\" {\n\t\townerPass = make([]byte, 8, 8)\n\t\tbinary.LittleEndian.PutUint64(ownerPass, uint64(rand.Int63()))\n\t} else {\n\t\townerPass = []byte(ownerPassStr)\n\t}\n\tuserPass = append(userPass, p.padding...)[0:32]\n\townerPass = append(ownerPass, p.padding...)[0:32]\n\tp.encrypted = true\n\tp.oValue = oValueGen(userPass, ownerPass)\n\tvar buf []byte\n\tbuf = append(buf, userPass...)\n\tbuf = append(buf, p.oValue...)\n\tbuf = append(buf, privFlag, 0xff, 0xff, 0xff)\n\tsum := md5.Sum(buf)\n\tp.encryptionKey = sum[0:5]\n\tp.uValue = p.uValueGen()\n\tp.pValue = -(int(privFlag^255) + 1)\n}\n"
        },
        {
          "name": "splittext.go",
          "type": "blob",
          "size": 0.994140625,
          "content": "package gofpdf\n\nimport (\n\t\"math\"\n\t//\t\"strings\"\n\t\"unicode\"\n)\n\n// SplitText splits UTF-8 encoded text into several lines using the current\n// font. Each line has its length limited to a maximum width given by w. This\n// function can be used to determine the total height of wrapped text for\n// vertical placement purposes.\nfunc (f *Fpdf) SplitText(txt string, w float64) (lines []string) {\n\tcw := f.currentFont.Cw\n\twmax := int(math.Ceil((w - 2*f.cMargin) * 1000 / f.fontSize))\n\ts := []rune(txt) // Return slice of UTF-8 runes\n\tnb := len(s)\n\tfor nb > 0 && s[nb-1] == '\\n' {\n\t\tnb--\n\t}\n\ts = s[0:nb]\n\tsep := -1\n\ti := 0\n\tj := 0\n\tl := 0\n\tfor i < nb {\n\t\tc := s[i]\n\t\tl += cw[c]\n\t\tif unicode.IsSpace(c) || isChinese(c) {\n\t\t\tsep = i\n\t\t}\n\t\tif c == '\\n' || l > wmax {\n\t\t\tif sep == -1 {\n\t\t\t\tif i == j {\n\t\t\t\t\ti++\n\t\t\t\t}\n\t\t\t\tsep = i\n\t\t\t} else {\n\t\t\t\ti = sep + 1\n\t\t\t}\n\t\t\tlines = append(lines, string(s[j:sep]))\n\t\t\tsep = -1\n\t\t\tj = i\n\t\t\tl = 0\n\t\t} else {\n\t\t\ti++\n\t\t}\n\t}\n\tif i != j {\n\t\tlines = append(lines, string(s[j:i]))\n\t}\n\treturn lines\n}\n"
        },
        {
          "name": "spotcolor.go",
          "type": "blob",
          "size": 5.791015625,
          "content": "// Copyright (c) Kurt Jung (Gmail: kurt.w.jung)\n//\n// Permission to use, copy, modify, and distribute this software for any\n// purpose with or without fee is hereby granted, provided that the above\n// copyright notice and this permission notice appear in all copies.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n// WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n// MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY\n// SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n// WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION\n// OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN\n// CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n\n// Adapted from http://www.fpdf.org/en/script/script89.php by Olivier PLATHEY\n\npackage gofpdf\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n)\n\nfunc byteBound(v byte) byte {\n\tif v > 100 {\n\t\treturn 100\n\t}\n\treturn v\n}\n\n// AddSpotColor adds an ink-based CMYK color to the gofpdf instance and\n// associates it with the specified name. The individual components specify\n// percentages ranging from 0 to 100. Values above this are quietly capped to\n// 100. An error occurs if the specified name is already associated with a\n// color.\nfunc (f *Fpdf) AddSpotColor(nameStr string, c, m, y, k byte) {\n\tif f.err == nil {\n\t\t_, ok := f.spotColorMap[nameStr]\n\t\tif !ok {\n\t\t\tid := len(f.spotColorMap) + 1\n\t\t\tf.spotColorMap[nameStr] = spotColorType{\n\t\t\t\tid: id,\n\t\t\t\tval: cmykColorType{\n\t\t\t\t\tc: byteBound(c),\n\t\t\t\t\tm: byteBound(m),\n\t\t\t\t\ty: byteBound(y),\n\t\t\t\t\tk: byteBound(k),\n\t\t\t\t},\n\t\t\t}\n\t\t} else {\n\t\t\tf.err = fmt.Errorf(\"name \\\"%s\\\" is already associated with a spot color\", nameStr)\n\t\t}\n\t}\n}\n\nfunc (f *Fpdf) getSpotColor(nameStr string) (clr spotColorType, ok bool) {\n\tif f.err == nil {\n\t\tclr, ok = f.spotColorMap[nameStr]\n\t\tif !ok {\n\t\t\tf.err = fmt.Errorf(\"spot color name \\\"%s\\\" is not registered\", nameStr)\n\t\t}\n\t}\n\treturn\n}\n\n// SetDrawSpotColor sets the current draw color to the spot color associated\n// with nameStr. An error occurs if the name is not associated with a color.\n// The value for tint ranges from 0 (no intensity) to 100 (full intensity). It\n// is quietly bounded to this range.\nfunc (f *Fpdf) SetDrawSpotColor(nameStr string, tint byte) {\n\tvar clr spotColorType\n\tvar ok bool\n\n\tclr, ok = f.getSpotColor(nameStr)\n\tif ok {\n\t\tf.color.draw.mode = colorModeSpot\n\t\tf.color.draw.spotStr = nameStr\n\t\tf.color.draw.str = sprintf(\"/CS%d CS %.3f SCN\", clr.id, float64(byteBound(tint))/100)\n\t\tif f.page > 0 {\n\t\t\tf.out(f.color.draw.str)\n\t\t}\n\t}\n}\n\n// SetFillSpotColor sets the current fill color to the spot color associated\n// with nameStr. An error occurs if the name is not associated with a color.\n// The value for tint ranges from 0 (no intensity) to 100 (full intensity). It\n// is quietly bounded to this range.\nfunc (f *Fpdf) SetFillSpotColor(nameStr string, tint byte) {\n\tvar clr spotColorType\n\tvar ok bool\n\n\tclr, ok = f.getSpotColor(nameStr)\n\tif ok {\n\t\tf.color.fill.mode = colorModeSpot\n\t\tf.color.fill.spotStr = nameStr\n\t\tf.color.fill.str = sprintf(\"/CS%d cs %.3f scn\", clr.id, float64(byteBound(tint))/100)\n\t\tf.colorFlag = f.color.fill.str != f.color.text.str\n\t\tif f.page > 0 {\n\t\t\tf.out(f.color.fill.str)\n\t\t}\n\t}\n}\n\n// SetTextSpotColor sets the current text color to the spot color associated\n// with nameStr. An error occurs if the name is not associated with a color.\n// The value for tint ranges from 0 (no intensity) to 100 (full intensity). It\n// is quietly bounded to this range.\nfunc (f *Fpdf) SetTextSpotColor(nameStr string, tint byte) {\n\tvar clr spotColorType\n\tvar ok bool\n\n\tclr, ok = f.getSpotColor(nameStr)\n\tif ok {\n\t\tf.color.text.mode = colorModeSpot\n\t\tf.color.text.spotStr = nameStr\n\t\tf.color.text.str = sprintf(\"/CS%d cs %.3f scn\", clr.id, float64(byteBound(tint))/100)\n\t\tf.colorFlag = f.color.text.str != f.color.text.str\n\t}\n}\n\nfunc (f *Fpdf) returnSpotColor(clr colorType) (name string, c, m, y, k byte) {\n\tvar spotClr spotColorType\n\tvar ok bool\n\n\tname = clr.spotStr\n\tif name != \"\" {\n\t\tspotClr, ok = f.getSpotColor(name)\n\t\tif ok {\n\t\t\tc = spotClr.val.c\n\t\t\tm = spotClr.val.m\n\t\t\ty = spotClr.val.y\n\t\t\tk = spotClr.val.k\n\t\t}\n\t}\n\treturn\n}\n\n// GetDrawSpotColor returns the most recently used spot color information for\n// drawing. This will not be the current drawing color if some other color type\n// such as RGB is active. If no spot color has been set for drawing, zero\n// values are returned.\nfunc (f *Fpdf) GetDrawSpotColor() (name string, c, m, y, k byte) {\n\treturn f.returnSpotColor(f.color.draw)\n}\n\n// GetTextSpotColor returns the most recently used spot color information for\n// text output. This will not be the current text color if some other color\n// type such as RGB is active. If no spot color has been set for text, zero\n// values are returned.\nfunc (f *Fpdf) GetTextSpotColor() (name string, c, m, y, k byte) {\n\treturn f.returnSpotColor(f.color.text)\n}\n\n// GetFillSpotColor returns the most recently used spot color information for\n// fill output. This will not be the current fill color if some other color\n// type such as RGB is active. If no fill spot color has been set, zero values\n// are returned.\nfunc (f *Fpdf) GetFillSpotColor() (name string, c, m, y, k byte) {\n\treturn f.returnSpotColor(f.color.fill)\n}\n\nfunc (f *Fpdf) putSpotColors() {\n\tfor k, v := range f.spotColorMap {\n\t\tf.newobj()\n\t\tf.outf(\"[/Separation /%s\", strings.Replace(k, \" \", \"#20\", -1))\n\t\tf.out(\"/DeviceCMYK <<\")\n\t\tf.out(\"/Range [0 1 0 1 0 1 0 1] /C0 [0 0 0 0] \")\n\t\tf.outf(\"/C1 [%.3f %.3f %.3f %.3f] \", float64(v.val.c)/100, float64(v.val.m)/100,\n\t\t\tfloat64(v.val.y)/100, float64(v.val.k)/100)\n\t\tf.out(\"/FunctionType 2 /Domain [0 1] /N 1>>]\")\n\t\tf.out(\"endobj\")\n\t\tv.objID = f.n\n\t\tf.spotColorMap[k] = v\n\t}\n}\n\nfunc (f *Fpdf) spotColorPutResourceDict() {\n\tf.out(\"/ColorSpace <<\")\n\tfor _, clr := range f.spotColorMap {\n\t\tf.outf(\"/CS%d %d 0 R\", clr.id, clr.objID)\n\t}\n\tf.out(\">>\")\n}\n"
        },
        {
          "name": "subwrite.go",
          "type": "blob",
          "size": 1.2607421875,
          "content": "package gofpdf\n\n// Adapted from http://www.fpdf.org/en/script/script61.php by Wirus and released with the FPDF license.\n\n// SubWrite prints text from the current position in the same way as Write().\n// ht is the line height in the unit of measure specified in New(). str\n// specifies the text to write. subFontSize is the size of the font in points.\n// subOffset is the vertical offset of the text in points; a positive value\n// indicates a superscript, a negative value indicates a subscript. link is the\n// identifier returned by AddLink() or 0 for no internal link. linkStr is a\n// target URL or empty for no external link. A non--zero value for link takes\n// precedence over linkStr.\n//\n// The SubWrite example demonstrates this method.\nfunc (f *Fpdf) SubWrite(ht float64, str string, subFontSize, subOffset float64, link int, linkStr string) {\n\tif f.err != nil {\n\t\treturn\n\t}\n\t// resize font\n\tsubFontSizeOld := f.fontSizePt\n\tf.SetFontSize(subFontSize)\n\t// reposition y\n\tsubOffset = (((subFontSize - subFontSizeOld) / f.k) * 0.3) + (subOffset / f.k)\n\tsubX := f.x\n\tsubY := f.y\n\tf.SetXY(subX, subY-subOffset)\n\t//Output text\n\tf.write(ht, str, link, linkStr)\n\t// restore y position\n\tsubX = f.x\n\tsubY = f.y\n\tf.SetXY(subX, subY+subOffset)\n\t// restore font size\n\tf.SetFontSize(subFontSizeOld)\n}\n"
        },
        {
          "name": "svgbasic.go",
          "type": "blob",
          "size": 6.2763671875,
          "content": "/*\n * Copyright (c) 2014 Kurt Jung (Gmail: kurt.w.jung)\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\n * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\n * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\npackage gofpdf\n\nimport (\n\t\"encoding/xml\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"strconv\"\n\t\"strings\"\n)\n\nvar pathCmdSub *strings.Replacer\n\nfunc init() {\n\t// Handle permitted constructions like \"100L200,230\"\n\tpathCmdSub = strings.NewReplacer(\",\", \" \",\n\t\t\"L\", \" L \", \"l\", \" l \",\n\t\t\"C\", \" C \", \"c\", \" c \",\n\t\t\"M\", \" M \", \"m\", \" m \",\n\t\t\"H\", \" H \", \"h\", \" h \",\n\t\t\"V\", \" V \", \"v\", \" v \",\n\t\t\"Q\", \" Q \", \"q\", \" q \",\n\t\t\"Z\", \" Z \", \"z\", \" z \")\n}\n\n// SVGBasicSegmentType describes a single curve or position segment\ntype SVGBasicSegmentType struct {\n\tCmd byte // See http://www.w3.org/TR/SVG/paths.html for path command structure\n\tArg [6]float64\n}\n\nfunc absolutizePath(segs []SVGBasicSegmentType) {\n\tvar x, y float64\n\tvar segPtr *SVGBasicSegmentType\n\tadjust := func(pos int, adjX, adjY float64) {\n\t\tsegPtr.Arg[pos] += adjX\n\t\tsegPtr.Arg[pos+1] += adjY\n\t}\n\tfor j, seg := range segs {\n\t\tsegPtr = &segs[j]\n\t\tif j == 0 && seg.Cmd == 'm' {\n\t\t\tsegPtr.Cmd = 'M'\n\t\t}\n\t\tswitch segPtr.Cmd {\n\t\tcase 'M':\n\t\t\tx = seg.Arg[0]\n\t\t\ty = seg.Arg[1]\n\t\tcase 'm':\n\t\t\tadjust(0, x, y)\n\t\t\tsegPtr.Cmd = 'M'\n\t\t\tx = segPtr.Arg[0]\n\t\t\ty = segPtr.Arg[1]\n\t\tcase 'L':\n\t\t\tx = seg.Arg[0]\n\t\t\ty = seg.Arg[1]\n\t\tcase 'l':\n\t\t\tadjust(0, x, y)\n\t\t\tsegPtr.Cmd = 'L'\n\t\t\tx = segPtr.Arg[0]\n\t\t\ty = segPtr.Arg[1]\n\t\tcase 'C':\n\t\t\tx = seg.Arg[4]\n\t\t\ty = seg.Arg[5]\n\t\tcase 'c':\n\t\t\tadjust(0, x, y)\n\t\t\tadjust(2, x, y)\n\t\t\tadjust(4, x, y)\n\t\t\tsegPtr.Cmd = 'C'\n\t\t\tx = segPtr.Arg[4]\n\t\t\ty = segPtr.Arg[5]\n\t\tcase 'Q':\n\t\t\tx = seg.Arg[2]\n\t\t\ty = seg.Arg[3]\n\t\tcase 'q':\n\t\t\tadjust(0, x, y)\n\t\t\tadjust(2, x, y)\n\t\t\tsegPtr.Cmd = 'Q'\n\t\t\tx = segPtr.Arg[2]\n\t\t\ty = segPtr.Arg[3]\n\t\tcase 'H':\n\t\t\tx = seg.Arg[0]\n\t\tcase 'h':\n\t\t\tsegPtr.Arg[0] += x\n\t\t\tsegPtr.Cmd = 'H'\n\t\t\tx += seg.Arg[0]\n\t\tcase 'V':\n\t\t\ty = seg.Arg[0]\n\t\tcase 'v':\n\t\t\tsegPtr.Arg[0] += y\n\t\t\tsegPtr.Cmd = 'V'\n\t\t\ty += seg.Arg[0]\n\t\tcase 'z':\n\t\t\tsegPtr.Cmd = 'Z'\n\t\t}\n\t}\n}\n\nfunc pathParse(pathStr string) (segs []SVGBasicSegmentType, err error) {\n\tvar seg SVGBasicSegmentType\n\tvar j, argJ, argCount, prevArgCount int\n\tsetup := func(n int) {\n\t\t// It is not strictly necessary to clear arguments, but result may be clearer\n\t\t// to caller\n\t\tfor j := 0; j < len(seg.Arg); j++ {\n\t\t\tseg.Arg[j] = 0.0\n\t\t}\n\t\targJ = 0\n\t\targCount = n\n\t\tprevArgCount = n\n\t}\n\tvar str string\n\tvar c byte\n\tpathStr = pathCmdSub.Replace(pathStr)\n\tstrList := strings.Fields(pathStr)\n\tcount := len(strList)\n\tfor j = 0; j < count && err == nil; j++ {\n\t\tstr = strList[j]\n\t\tif argCount == 0 { // Look for path command or argument continuation\n\t\t\tc = str[0]\n\t\t\tif c == '-' || (c >= '0' && c <= '9') { // More arguments\n\t\t\t\tif j > 0 {\n\t\t\t\t\tsetup(prevArgCount)\n\t\t\t\t\t// Repeat previous action\n\t\t\t\t\tif seg.Cmd == 'M' {\n\t\t\t\t\t\tseg.Cmd = 'L'\n\t\t\t\t\t} else if seg.Cmd == 'm' {\n\t\t\t\t\t\tseg.Cmd = 'l'\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\terr = fmt.Errorf(\"expecting SVG path command at first position, got %s\", str)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif err == nil {\n\t\t\tif argCount == 0 {\n\t\t\t\tseg.Cmd = str[0]\n\t\t\t\tswitch seg.Cmd {\n\t\t\t\tcase 'M', 'm': // Absolute/relative moveto: x, y\n\t\t\t\t\tsetup(2)\n\t\t\t\tcase 'C', 'c': // Absolute/relative Bézier curve: cx0, cy0, cx1, cy1, x1, y1\n\t\t\t\t\tsetup(6)\n\t\t\t\tcase 'H', 'h': // Absolute/relative horizontal line to: x\n\t\t\t\t\tsetup(1)\n\t\t\t\tcase 'L', 'l': // Absolute/relative lineto: x, y\n\t\t\t\t\tsetup(2)\n\t\t\t\tcase 'Q', 'q': // Absolute/relative quadratic curve: x0, y0, x1, y1\n\t\t\t\t\tsetup(4)\n\t\t\t\tcase 'V', 'v': // Absolute/relative vertical line to: y\n\t\t\t\t\tsetup(1)\n\t\t\t\tcase 'Z', 'z': // closepath instruction (takes no arguments)\n\t\t\t\t\tsegs = append(segs, seg)\n\t\t\t\tdefault:\n\t\t\t\t\terr = fmt.Errorf(\"expecting SVG path command at position %d, got %s\", j, str)\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tseg.Arg[argJ], err = strconv.ParseFloat(str, 64)\n\t\t\t\tif err == nil {\n\t\t\t\t\targJ++\n\t\t\t\t\targCount--\n\t\t\t\t\tif argCount == 0 {\n\t\t\t\t\t\tsegs = append(segs, seg)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif err == nil {\n\t\tif argCount == 0 {\n\t\t\tabsolutizePath(segs)\n\t\t} else {\n\t\t\terr = fmt.Errorf(\"expecting additional (%d) numeric arguments\", argCount)\n\t\t}\n\t}\n\treturn\n}\n\n// SVGBasicType aggregates the information needed to describe a multi-segment\n// basic vector image\ntype SVGBasicType struct {\n\tWd, Ht   float64\n\tSegments [][]SVGBasicSegmentType\n}\n\n// SVGBasicParse parses a simple scalable vector graphics (SVG) buffer into a\n// descriptor. Only a small subset of the SVG standard, in particular the path\n// information generated by jSignature, is supported. The returned path data\n// includes only the commands 'M' (absolute moveto: x, y), 'L' (absolute\n// lineto: x, y), 'C' (absolute cubic Bézier curve: cx0, cy0, cx1, cy1,\n// x1,y1), 'Q' (absolute quadratic Bézier curve: x0, y0, x1, y1) and 'Z'\n// (closepath).\nfunc SVGBasicParse(buf []byte) (sig SVGBasicType, err error) {\n\ttype pathType struct {\n\t\tD string `xml:\"d,attr\"`\n\t}\n\ttype srcType struct {\n\t\tWd    float64    `xml:\"width,attr\"`\n\t\tHt    float64    `xml:\"height,attr\"`\n\t\tPaths []pathType `xml:\"path\"`\n\t}\n\tvar src srcType\n\terr = xml.Unmarshal(buf, &src)\n\tif err == nil {\n\t\tif src.Wd > 0 && src.Ht > 0 {\n\t\t\tsig.Wd, sig.Ht = src.Wd, src.Ht\n\t\t\tvar segs []SVGBasicSegmentType\n\t\t\tfor _, path := range src.Paths {\n\t\t\t\tif err == nil {\n\t\t\t\t\tsegs, err = pathParse(path.D)\n\t\t\t\t\tif err == nil {\n\t\t\t\t\t\tsig.Segments = append(sig.Segments, segs)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\terr = fmt.Errorf(\"unacceptable values for basic SVG extent: %.2f x %.2f\",\n\t\t\t\tsig.Wd, sig.Ht)\n\t\t}\n\t}\n\treturn\n}\n\n// SVGBasicFileParse parses a simple scalable vector graphics (SVG) file into a\n// basic descriptor. The SVGBasicWrite() example demonstrates this method.\nfunc SVGBasicFileParse(svgFileStr string) (sig SVGBasicType, err error) {\n\tvar buf []byte\n\tbuf, err = ioutil.ReadFile(svgFileStr)\n\tif err == nil {\n\t\tsig, err = SVGBasicParse(buf)\n\t}\n\treturn\n}\n"
        },
        {
          "name": "svgwrite.go",
          "type": "blob",
          "size": 2.6689453125,
          "content": "/*\n * Copyright (c) 2014 Kurt Jung (Gmail: kurt.w.jung)\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\n * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\n * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\npackage gofpdf\n\n// SVGBasicWrite renders the paths encoded in the basic SVG image specified by\n// sb. The scale value is used to convert the coordinates in the path to the\n// unit of measure specified in New(). The current position (as set with a call\n// to SetXY()) is used as the origin of the image. The current line cap style\n// (as set with SetLineCapStyle()), line width (as set with SetLineWidth()),\n// and draw color (as set with SetDrawColor()) are used in drawing the image\n// paths.\nfunc (f *Fpdf) SVGBasicWrite(sb *SVGBasicType, scale float64) {\n\toriginX, originY := f.GetXY()\n\tvar x, y, newX, newY float64\n\tvar cx0, cy0, cx1, cy1 float64\n\tvar path []SVGBasicSegmentType\n\tvar seg SVGBasicSegmentType\n\tvar startX, startY float64\n\tsval := func(origin float64, arg int) float64 {\n\t\treturn origin + scale*seg.Arg[arg]\n\t}\n\txval := func(arg int) float64 {\n\t\treturn sval(originX, arg)\n\t}\n\tyval := func(arg int) float64 {\n\t\treturn sval(originY, arg)\n\t}\n\tval := func(arg int) (float64, float64) {\n\t\treturn xval(arg), yval(arg + 1)\n\t}\n\tfor j := 0; j < len(sb.Segments) && f.Ok(); j++ {\n\t\tpath = sb.Segments[j]\n\t\tfor k := 0; k < len(path) && f.Ok(); k++ {\n\t\t\tseg = path[k]\n\t\t\tswitch seg.Cmd {\n\t\t\tcase 'M':\n\t\t\t\tx, y = val(0)\n\t\t\t\tstartX, startY = x, y\n\t\t\t\tf.SetXY(x, y)\n\t\t\tcase 'L':\n\t\t\t\tnewX, newY = val(0)\n\t\t\t\tf.Line(x, y, newX, newY)\n\t\t\t\tx, y = newX, newY\n\t\t\tcase 'C':\n\t\t\t\tcx0, cy0 = val(0)\n\t\t\t\tcx1, cy1 = val(2)\n\t\t\t\tnewX, newY = val(4)\n\t\t\t\tf.CurveCubic(x, y, cx0, cy0, newX, newY, cx1, cy1, \"D\")\n\t\t\t\tx, y = newX, newY\n\t\t\tcase 'Q':\n\t\t\t\tcx0, cy0 = val(0)\n\t\t\t\tnewX, newY = val(2)\n\t\t\t\tf.Curve(x, y, cx0, cy0, newX, newY, \"D\")\n\t\t\t\tx, y = newX, newY\n\t\t\tcase 'H':\n\t\t\t\tnewX = xval(0)\n\t\t\t\tf.Line(x, y, newX, y)\n\t\t\t\tx = newX\n\t\t\tcase 'V':\n\t\t\t\tnewY = yval(0)\n\t\t\t\tf.Line(x, y, x, newY)\n\t\t\t\ty = newY\n\t\t\tcase 'Z':\n\t\t\t\tf.Line(x, y, startX, startY)\n\t\t\t\tx, y = startX, startY\n\t\t\tdefault:\n\t\t\t\tf.SetErrorf(\"Unexpected path command '%c'\", seg.Cmd)\n\t\t\t}\n\t\t}\n\t}\n}\n"
        },
        {
          "name": "template.go",
          "type": "blob",
          "size": 8.048828125,
          "content": "package gofpdf\n\n/*\n * Copyright (c) 2015 Kurt Jung (Gmail: kurt.w.jung),\n *   Marcus Downing, Jan Slabon (Setasign)\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\n * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\n * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\nimport (\n\t\"encoding/gob\"\n\t\"sort\"\n)\n\n// CreateTemplate defines a new template using the current page size.\nfunc (f *Fpdf) CreateTemplate(fn func(*Tpl)) Template {\n\treturn newTpl(PointType{0, 0}, f.curPageSize, f.defOrientation, f.unitStr, f.fontDirStr, fn, f)\n}\n\n// CreateTemplateCustom starts a template, using the given bounds.\nfunc (f *Fpdf) CreateTemplateCustom(corner PointType, size SizeType, fn func(*Tpl)) Template {\n\treturn newTpl(corner, size, f.defOrientation, f.unitStr, f.fontDirStr, fn, f)\n}\n\n// CreateTemplate creates a template that is not attached to any document.\n//\n// This function is deprecated; it incorrectly assumes that a page with a width\n// smaller than its height is oriented in portrait mode, otherwise it assumes\n// landscape mode. This causes problems when placing the template in a master\n// document where this condition does not apply. CreateTpl() is a similar\n// function that lets you specify the orientation to avoid this problem.\nfunc CreateTemplate(corner PointType, size SizeType, unitStr, fontDirStr string, fn func(*Tpl)) Template {\n\torientationStr := \"p\"\n\tif size.Wd > size.Ht {\n\t\torientationStr = \"l\"\n\t}\n\n\treturn CreateTpl(corner, size, orientationStr, unitStr, fontDirStr, fn)\n}\n\n// CreateTpl creates a template not attached to any document\nfunc CreateTpl(corner PointType, size SizeType, orientationStr, unitStr, fontDirStr string, fn func(*Tpl)) Template {\n\treturn newTpl(corner, size, orientationStr, unitStr, fontDirStr, fn, nil)\n}\n\n// UseTemplate adds a template to the current page or another template,\n// using the size and position at which it was originally written.\nfunc (f *Fpdf) UseTemplate(t Template) {\n\tif t == nil {\n\t\tf.SetErrorf(\"template is nil\")\n\t\treturn\n\t}\n\tcorner, size := t.Size()\n\tf.UseTemplateScaled(t, corner, size)\n}\n\n// UseTemplateScaled adds a template to the current page or another template,\n// using the given page coordinates.\nfunc (f *Fpdf) UseTemplateScaled(t Template, corner PointType, size SizeType) {\n\tif t == nil {\n\t\tf.SetErrorf(\"template is nil\")\n\t\treturn\n\t}\n\n\t// You have to add at least a page first\n\tif f.page <= 0 {\n\t\tf.SetErrorf(\"cannot use a template without first adding a page\")\n\t\treturn\n\t}\n\n\t// make a note of the fact that we actually use this template, as well as any other templates,\n\t// images or fonts it uses\n\tf.templates[t.ID()] = t\n\tfor _, tt := range t.Templates() {\n\t\tf.templates[tt.ID()] = tt\n\t}\n\n\t// Create a list of existing image SHA-1 hashes.\n\texistingImages := map[string]bool{}\n\tfor _, image := range f.images {\n\t\texistingImages[image.i] = true\n\t}\n\n\t// Add each template image to $f, unless already present.\n\tfor name, ti := range t.Images() {\n\t\tif _, found := existingImages[ti.i]; found {\n\t\t\tcontinue\n\t\t}\n\t\tname = sprintf(\"t%s-%s\", t.ID(), name)\n\t\tf.images[name] = ti\n\t}\n\n\t// template data\n\t_, templateSize := t.Size()\n\tscaleX := size.Wd / templateSize.Wd\n\tscaleY := size.Ht / templateSize.Ht\n\ttx := corner.X * f.k\n\tty := (f.curPageSize.Ht - corner.Y - size.Ht) * f.k\n\n\tf.outf(\"q %.4f 0 0 %.4f %.4f %.4f cm\", scaleX, scaleY, tx, ty) // Translate\n\tf.outf(\"/TPL%s Do Q\", t.ID())\n}\n\n// Template is an object that can be written to, then used and re-used any number of times within a document.\ntype Template interface {\n\tID() string\n\tSize() (PointType, SizeType)\n\tBytes() []byte\n\tImages() map[string]*ImageInfoType\n\tTemplates() []Template\n\tNumPages() int\n\tFromPage(int) (Template, error)\n\tFromPages() []Template\n\tSerialize() ([]byte, error)\n\tgob.GobDecoder\n\tgob.GobEncoder\n}\n\nfunc (f *Fpdf) templateFontCatalog() {\n\tvar keyList []string\n\tvar font fontDefType\n\tvar key string\n\tf.out(\"/Font <<\")\n\tfor key = range f.fonts {\n\t\tkeyList = append(keyList, key)\n\t}\n\tif f.catalogSort {\n\t\tsort.Strings(keyList)\n\t}\n\tfor _, key = range keyList {\n\t\tfont = f.fonts[key]\n\t\tf.outf(\"/F%s %d 0 R\", font.i, font.N)\n\t}\n\tf.out(\">>\")\n}\n\n// putTemplates writes the templates to the PDF\nfunc (f *Fpdf) putTemplates() {\n\tfilter := \"\"\n\tif f.compress {\n\t\tfilter = \"/Filter /FlateDecode \"\n\t}\n\n\ttemplates := sortTemplates(f.templates, f.catalogSort)\n\tvar t Template\n\tfor _, t = range templates {\n\t\tcorner, size := t.Size()\n\n\t\tf.newobj()\n\t\tf.templateObjects[t.ID()] = f.n\n\t\tf.outf(\"<<%s/Type /XObject\", filter)\n\t\tf.out(\"/Subtype /Form\")\n\t\tf.out(\"/Formtype 1\")\n\t\tf.outf(\"/BBox [%.2f %.2f %.2f %.2f]\", corner.X*f.k, corner.Y*f.k, (corner.X+size.Wd)*f.k, (corner.Y+size.Ht)*f.k)\n\t\tif corner.X != 0 || corner.Y != 0 {\n\t\t\tf.outf(\"/Matrix [1 0 0 1 %.5f %.5f]\", -corner.X*f.k*2, corner.Y*f.k*2)\n\t\t}\n\n\t\t// Template's resource dictionary\n\t\tf.out(\"/Resources \")\n\t\tf.out(\"<</ProcSet [/PDF /Text /ImageB /ImageC /ImageI]\")\n\n\t\tf.templateFontCatalog()\n\n\t\ttImages := t.Images()\n\t\ttTemplates := t.Templates()\n\t\tif len(tImages) > 0 || len(tTemplates) > 0 {\n\t\t\tf.out(\"/XObject <<\")\n\t\t\t{\n\t\t\t\tvar key string\n\t\t\t\tvar keyList []string\n\t\t\t\tvar ti *ImageInfoType\n\t\t\t\tfor key = range tImages {\n\t\t\t\t\tkeyList = append(keyList, key)\n\t\t\t\t}\n\t\t\t\tif gl.catalogSort {\n\t\t\t\t\tsort.Strings(keyList)\n\t\t\t\t}\n\t\t\t\tfor _, key = range keyList {\n\t\t\t\t\t// for _, ti := range tImages {\n\t\t\t\t\tti = tImages[key]\n\t\t\t\t\tf.outf(\"/I%s %d 0 R\", ti.i, ti.n)\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor _, tt := range tTemplates {\n\t\t\t\tid := tt.ID()\n\t\t\t\tif objID, ok := f.templateObjects[id]; ok {\n\t\t\t\t\tf.outf(\"/TPL%s %d 0 R\", id, objID)\n\t\t\t\t}\n\t\t\t}\n\t\t\tf.out(\">>\")\n\t\t}\n\n\t\tf.out(\">>\")\n\n\t\t//  Write the template's byte stream\n\t\tbuffer := t.Bytes()\n\t\t// fmt.Println(\"Put template bytes\", string(buffer[:]))\n\t\tif f.compress {\n\t\t\tbuffer = sliceCompress(buffer)\n\t\t}\n\t\tf.outf(\"/Length %d >>\", len(buffer))\n\t\tf.putstream(buffer)\n\t\tf.out(\"endobj\")\n\t}\n}\n\nfunc templateKeyList(mp map[string]Template, sort bool) (keyList []string) {\n\tvar key string\n\tfor key = range mp {\n\t\tkeyList = append(keyList, key)\n\t}\n\tif sort {\n\t\tgensort(len(keyList),\n\t\t\tfunc(a, b int) bool {\n\t\t\t\treturn keyList[a] < keyList[b]\n\t\t\t},\n\t\t\tfunc(a, b int) {\n\t\t\t\tkeyList[a], keyList[b] = keyList[b], keyList[a]\n\t\t\t})\n\t}\n\treturn\n}\n\n// sortTemplates puts templates in a suitable order based on dependices\nfunc sortTemplates(templates map[string]Template, catalogSort bool) []Template {\n\tchain := make([]Template, 0, len(templates)*2)\n\n\t// build a full set of dependency chains\n\tvar keyList []string\n\tvar key string\n\tvar t Template\n\tkeyList = templateKeyList(templates, catalogSort)\n\tfor _, key = range keyList {\n\t\tt = templates[key]\n\t\ttlist := templateChainDependencies(t)\n\t\tfor _, tt := range tlist {\n\t\t\tif tt != nil {\n\t\t\t\tchain = append(chain, tt)\n\t\t\t}\n\t\t}\n\t}\n\n\t// reduce that to make a simple list\n\tsorted := make([]Template, 0, len(templates))\nchain:\n\tfor _, t := range chain {\n\t\tfor _, already := range sorted {\n\t\t\tif t == already {\n\t\t\t\tcontinue chain\n\t\t\t}\n\t\t}\n\t\tsorted = append(sorted, t)\n\t}\n\n\treturn sorted\n}\n\n//  templateChainDependencies is a recursive function for determining the full chain of template dependencies\nfunc templateChainDependencies(template Template) []Template {\n\trequires := template.Templates()\n\tchain := make([]Template, len(requires)*2)\n\tfor _, req := range requires {\n\t\tchain = append(chain, templateChainDependencies(req)...)\n\t}\n\tchain = append(chain, template)\n\treturn chain\n}\n\n// < 0002640  31 20 31 32 20 30 20 52  0a 2f 54 50 4c 32 20 31  |1 12 0 R./TPL2 1|\n// < 0002650  35 20 30 20 52 0a 2f 54  50 4c 31 20 31 34 20 30  |5 0 R./TPL1 14 0|\n\n// > 0002640  31 20 31 32 20 30 20 52  0a 2f 54 50 4c 31 20 31  |1 12 0 R./TPL1 1|\n// > 0002650  34 20 30 20 52 0a 2f 54  50 4c 32 20 31 35 20 30  |4 0 R./TPL2 15 0|\n"
        },
        {
          "name": "template_impl.go",
          "type": "blob",
          "size": 7.8466796875,
          "content": "package gofpdf\n\nimport (\n\t\"bytes\"\n\t\"crypto/sha1\"\n\t\"encoding/gob\"\n\t\"errors\"\n\t\"fmt\"\n)\n\n/*\n * Copyright (c) 2015 Kurt Jung (Gmail: kurt.w.jung),\n *   Marcus Downing, Jan Slabon (Setasign)\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\n * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\n * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n// newTpl creates a template, copying graphics settings from a template if one is given\nfunc newTpl(corner PointType, size SizeType, orientationStr, unitStr, fontDirStr string, fn func(*Tpl), copyFrom *Fpdf) Template {\n\tsizeStr := \"\"\n\n\tfpdf := fpdfNew(orientationStr, unitStr, sizeStr, fontDirStr, size)\n\ttpl := Tpl{*fpdf}\n\tif copyFrom != nil {\n\t\ttpl.loadParamsFromFpdf(copyFrom)\n\t}\n\ttpl.Fpdf.AddPage()\n\tfn(&tpl)\n\n\tbytes := make([][]byte, len(tpl.Fpdf.pages))\n\t// skip the first page as it will always be empty\n\tfor x := 1; x < len(bytes); x++ {\n\t\tbytes[x] = tpl.Fpdf.pages[x].Bytes()\n\t}\n\n\ttemplates := make([]Template, 0, len(tpl.Fpdf.templates))\n\tfor _, key := range templateKeyList(tpl.Fpdf.templates, true) {\n\t\ttemplates = append(templates, tpl.Fpdf.templates[key])\n\t}\n\timages := tpl.Fpdf.images\n\n\ttemplate := FpdfTpl{corner, size, bytes, images, templates, tpl.Fpdf.page}\n\treturn &template\n}\n\n// FpdfTpl is a concrete implementation of the Template interface.\ntype FpdfTpl struct {\n\tcorner    PointType\n\tsize      SizeType\n\tbytes     [][]byte\n\timages    map[string]*ImageInfoType\n\ttemplates []Template\n\tpage      int\n}\n\n// ID returns the global template identifier\nfunc (t *FpdfTpl) ID() string {\n\treturn fmt.Sprintf(\"%x\", sha1.Sum(t.Bytes()))\n}\n\n// Size gives the bounding dimensions of this template\nfunc (t *FpdfTpl) Size() (corner PointType, size SizeType) {\n\treturn t.corner, t.size\n}\n\n// Bytes returns the actual template data, not including resources\nfunc (t *FpdfTpl) Bytes() []byte {\n\treturn t.bytes[t.page]\n}\n\n// FromPage creates a new template from a specific Page\nfunc (t *FpdfTpl) FromPage(page int) (Template, error) {\n\t// pages start at 1\n\tif page == 0 {\n\t\treturn nil, errors.New(\"Pages start at 1 No template will have a page 0\")\n\t}\n\n\tif page > t.NumPages() {\n\t\treturn nil, fmt.Errorf(\"The template does not have a page %d\", page)\n\t}\n\t// if it is already pointing to the correct page\n\t// there is no need to create a new template\n\tif t.page == page {\n\t\treturn t, nil\n\t}\n\n\tt2 := *t\n\tt2.page = page\n\treturn &t2, nil\n}\n\n// FromPages creates a template slice with all the pages within a template.\nfunc (t *FpdfTpl) FromPages() []Template {\n\tp := make([]Template, t.NumPages())\n\tfor x := 1; x <= t.NumPages(); x++ {\n\t\t// the only error is when accessing a\n\t\t// non existing template... that can't happen\n\t\t// here\n\t\tp[x-1], _ = t.FromPage(x)\n\t}\n\n\treturn p\n}\n\n// Images returns a list of the images used in this template\nfunc (t *FpdfTpl) Images() map[string]*ImageInfoType {\n\treturn t.images\n}\n\n// Templates returns a list of templates used in this template\nfunc (t *FpdfTpl) Templates() []Template {\n\treturn t.templates\n}\n\n// NumPages returns the number of available pages within the template. Look at FromPage and FromPages on access to that content.\nfunc (t *FpdfTpl) NumPages() int {\n\t// the first page is empty to\n\t// make the pages begin at one\n\treturn len(t.bytes) - 1\n}\n\n// Serialize turns a template into a byte string for later deserialization\nfunc (t *FpdfTpl) Serialize() ([]byte, error) {\n\tb := new(bytes.Buffer)\n\tenc := gob.NewEncoder(b)\n\terr := enc.Encode(t)\n\n\treturn b.Bytes(), err\n}\n\n// DeserializeTemplate creaties a template from a previously serialized\n// template\nfunc DeserializeTemplate(b []byte) (Template, error) {\n\ttpl := new(FpdfTpl)\n\tdec := gob.NewDecoder(bytes.NewBuffer(b))\n\terr := dec.Decode(tpl)\n\treturn tpl, err\n}\n\n// childrenImages returns the next layer of children images, it doesn't dig into\n// children of children. Applies template namespace to keys to ensure\n// no collisions. See UseTemplateScaled\nfunc (t *FpdfTpl) childrenImages() map[string]*ImageInfoType {\n\tchildrenImgs := make(map[string]*ImageInfoType)\n\n\tfor x := 0; x < len(t.templates); x++ {\n\t\timgs := t.templates[x].Images()\n\t\tfor key, val := range imgs {\n\t\t\tname := sprintf(\"t%s-%s\", t.templates[x].ID(), key)\n\t\t\tchildrenImgs[name] = val\n\t\t}\n\t}\n\n\treturn childrenImgs\n}\n\n// childrensTemplates returns the next layer of children templates, it doesn't dig into\n// children of children.\nfunc (t *FpdfTpl) childrensTemplates() []Template {\n\tchildrenTmpls := make([]Template, 0)\n\n\tfor x := 0; x < len(t.templates); x++ {\n\t\ttmpls := t.templates[x].Templates()\n\t\tchildrenTmpls = append(childrenTmpls, tmpls...)\n\t}\n\n\treturn childrenTmpls\n}\n\n// GobEncode encodes the receiving template into a byte buffer. Use GobDecode\n// to decode the byte buffer back to a template.\nfunc (t *FpdfTpl) GobEncode() ([]byte, error) {\n\tw := new(bytes.Buffer)\n\tencoder := gob.NewEncoder(w)\n\n\tchildrensTemplates := t.childrensTemplates()\n\tfirstClassTemplates := make([]Template, 0)\n\nfound_continue:\n\tfor x := 0; x < len(t.templates); x++ {\n\t\tfor y := 0; y < len(childrensTemplates); y++ {\n\t\t\tif childrensTemplates[y].ID() == t.templates[x].ID() {\n\t\t\t\tcontinue found_continue\n\t\t\t}\n\t\t}\n\n\t\tfirstClassTemplates = append(firstClassTemplates, t.templates[x])\n\t}\n\terr := encoder.Encode(firstClassTemplates)\n\n\tchildrenImgs := t.childrenImages()\n\tfirstClassImgs := make(map[string]*ImageInfoType)\n\n\tfor key, img := range t.images {\n\t\tif _, ok := childrenImgs[key]; !ok {\n\t\t\tfirstClassImgs[key] = img\n\t\t}\n\t}\n\n\tif err == nil {\n\t\terr = encoder.Encode(firstClassImgs)\n\t}\n\tif err == nil {\n\t\terr = encoder.Encode(t.corner)\n\t}\n\tif err == nil {\n\t\terr = encoder.Encode(t.size)\n\t}\n\tif err == nil {\n\t\terr = encoder.Encode(t.bytes)\n\t}\n\tif err == nil {\n\t\terr = encoder.Encode(t.page)\n\t}\n\n\treturn w.Bytes(), err\n}\n\n// GobDecode decodes the specified byte buffer into the receiving template.\nfunc (t *FpdfTpl) GobDecode(buf []byte) error {\n\tr := bytes.NewBuffer(buf)\n\tdecoder := gob.NewDecoder(r)\n\n\tfirstClassTemplates := make([]*FpdfTpl, 0)\n\terr := decoder.Decode(&firstClassTemplates)\n\tt.templates = make([]Template, len(firstClassTemplates))\n\n\tfor x := 0; x < len(t.templates); x++ {\n\t\tt.templates[x] = Template(firstClassTemplates[x])\n\t}\n\n\tfirstClassImages := t.childrenImages()\n\n\tt.templates = append(t.childrensTemplates(), t.templates...)\n\n\tt.images = make(map[string]*ImageInfoType)\n\tif err == nil {\n\t\terr = decoder.Decode(&t.images)\n\t}\n\n\tfor k, v := range firstClassImages {\n\t\tt.images[k] = v\n\t}\n\n\tif err == nil {\n\t\terr = decoder.Decode(&t.corner)\n\t}\n\tif err == nil {\n\t\terr = decoder.Decode(&t.size)\n\t}\n\tif err == nil {\n\t\terr = decoder.Decode(&t.bytes)\n\t}\n\tif err == nil {\n\t\terr = decoder.Decode(&t.page)\n\t}\n\n\treturn err\n}\n\n// Tpl is an Fpdf used for writing a template. It has most of the facilities of\n// an Fpdf, but cannot add more pages. Tpl is used directly only during the\n// limited time a template is writable.\ntype Tpl struct {\n\tFpdf\n}\n\nfunc (t *Tpl) loadParamsFromFpdf(f *Fpdf) {\n\tt.Fpdf.compress = false\n\n\tt.Fpdf.k = f.k\n\tt.Fpdf.x = f.x\n\tt.Fpdf.y = f.y\n\tt.Fpdf.lineWidth = f.lineWidth\n\tt.Fpdf.capStyle = f.capStyle\n\tt.Fpdf.joinStyle = f.joinStyle\n\n\tt.Fpdf.color.draw = f.color.draw\n\tt.Fpdf.color.fill = f.color.fill\n\tt.Fpdf.color.text = f.color.text\n\n\tt.Fpdf.fonts = f.fonts\n\tt.Fpdf.currentFont = f.currentFont\n\tt.Fpdf.fontFamily = f.fontFamily\n\tt.Fpdf.fontSize = f.fontSize\n\tt.Fpdf.fontSizePt = f.fontSizePt\n\tt.Fpdf.fontStyle = f.fontStyle\n\tt.Fpdf.ws = f.ws\n\n\tfor key, value := range f.images {\n\t\tt.Fpdf.images[key] = value\n\t}\n}\n"
        },
        {
          "name": "text",
          "type": "tree",
          "content": null
        },
        {
          "name": "ttfparser.go",
          "type": "blob",
          "size": 8.697265625,
          "content": "/*\n * Copyright (c) 2013 Kurt Jung (Gmail: kurt.w.jung)\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\n * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\n * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\npackage gofpdf\n\n// Utility to parse TTF font files\n// Version:    1.0\n// Date:       2011-06-18\n// Author:     Olivier PLATHEY\n// Port to Go: Kurt Jung, 2013-07-15\n\nimport (\n\t\"encoding/binary\"\n\t\"fmt\"\n\t\"os\"\n\t\"regexp\"\n\t\"strings\"\n)\n\n// TtfType contains metrics of a TrueType font.\ntype TtfType struct {\n\tEmbeddable             bool\n\tUnitsPerEm             uint16\n\tPostScriptName         string\n\tBold                   bool\n\tItalicAngle            int16\n\tIsFixedPitch           bool\n\tTypoAscender           int16\n\tTypoDescender          int16\n\tUnderlinePosition      int16\n\tUnderlineThickness     int16\n\tXmin, Ymin, Xmax, Ymax int16\n\tCapHeight              int16\n\tWidths                 []uint16\n\tChars                  map[uint16]uint16\n}\n\ntype ttfParser struct {\n\trec              TtfType\n\tf                *os.File\n\ttables           map[string]uint32\n\tnumberOfHMetrics uint16\n\tnumGlyphs        uint16\n}\n\n// TtfParse extracts various metrics from a TrueType font file.\nfunc TtfParse(fileStr string) (TtfRec TtfType, err error) {\n\tvar t ttfParser\n\tt.f, err = os.Open(fileStr)\n\tif err != nil {\n\t\treturn\n\t}\n\tversion, err := t.ReadStr(4)\n\tif err != nil {\n\t\treturn\n\t}\n\tif version == \"OTTO\" {\n\t\terr = fmt.Errorf(\"fonts based on PostScript outlines are not supported\")\n\t\treturn\n\t}\n\tif version != \"\\x00\\x01\\x00\\x00\" {\n\t\terr = fmt.Errorf(\"unrecognized file format\")\n\t\treturn\n\t}\n\tnumTables := int(t.ReadUShort())\n\tt.Skip(3 * 2) // searchRange, entrySelector, rangeShift\n\tt.tables = make(map[string]uint32)\n\tvar tag string\n\tfor j := 0; j < numTables; j++ {\n\t\ttag, err = t.ReadStr(4)\n\t\tif err != nil {\n\t\t\treturn\n\t\t}\n\t\tt.Skip(4) // checkSum\n\t\toffset := t.ReadULong()\n\t\tt.Skip(4) // length\n\t\tt.tables[tag] = offset\n\t}\n\terr = t.ParseComponents()\n\tif err != nil {\n\t\treturn\n\t}\n\tt.f.Close()\n\tTtfRec = t.rec\n\treturn\n}\n\nfunc (t *ttfParser) ParseComponents() (err error) {\n\terr = t.ParseHead()\n\tif err == nil {\n\t\terr = t.ParseHhea()\n\t\tif err == nil {\n\t\t\terr = t.ParseMaxp()\n\t\t\tif err == nil {\n\t\t\t\terr = t.ParseHmtx()\n\t\t\t\tif err == nil {\n\t\t\t\t\terr = t.ParseCmap()\n\t\t\t\t\tif err == nil {\n\t\t\t\t\t\terr = t.ParseName()\n\t\t\t\t\t\tif err == nil {\n\t\t\t\t\t\t\terr = t.ParseOS2()\n\t\t\t\t\t\t\tif err == nil {\n\t\t\t\t\t\t\t\terr = t.ParsePost()\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn\n}\n\nfunc (t *ttfParser) ParseHead() (err error) {\n\terr = t.Seek(\"head\")\n\tt.Skip(3 * 4) // version, fontRevision, checkSumAdjustment\n\tmagicNumber := t.ReadULong()\n\tif magicNumber != 0x5F0F3CF5 {\n\t\terr = fmt.Errorf(\"incorrect magic number\")\n\t\treturn\n\t}\n\tt.Skip(2) // flags\n\tt.rec.UnitsPerEm = t.ReadUShort()\n\tt.Skip(2 * 8) // created, modified\n\tt.rec.Xmin = t.ReadShort()\n\tt.rec.Ymin = t.ReadShort()\n\tt.rec.Xmax = t.ReadShort()\n\tt.rec.Ymax = t.ReadShort()\n\treturn\n}\n\nfunc (t *ttfParser) ParseHhea() (err error) {\n\terr = t.Seek(\"hhea\")\n\tif err == nil {\n\t\tt.Skip(4 + 15*2)\n\t\tt.numberOfHMetrics = t.ReadUShort()\n\t}\n\treturn\n}\n\nfunc (t *ttfParser) ParseMaxp() (err error) {\n\terr = t.Seek(\"maxp\")\n\tif err == nil {\n\t\tt.Skip(4)\n\t\tt.numGlyphs = t.ReadUShort()\n\t}\n\treturn\n}\n\nfunc (t *ttfParser) ParseHmtx() (err error) {\n\terr = t.Seek(\"hmtx\")\n\tif err == nil {\n\t\tt.rec.Widths = make([]uint16, 0, 8)\n\t\tfor j := uint16(0); j < t.numberOfHMetrics; j++ {\n\t\t\tt.rec.Widths = append(t.rec.Widths, t.ReadUShort())\n\t\t\tt.Skip(2) // lsb\n\t\t}\n\t\tif t.numberOfHMetrics < t.numGlyphs {\n\t\t\tlastWidth := t.rec.Widths[t.numberOfHMetrics-1]\n\t\t\tfor j := t.numberOfHMetrics; j < t.numGlyphs; j++ {\n\t\t\t\tt.rec.Widths = append(t.rec.Widths, lastWidth)\n\t\t\t}\n\t\t}\n\t}\n\treturn\n}\n\nfunc (t *ttfParser) ParseCmap() (err error) {\n\tvar offset int64\n\tif err = t.Seek(\"cmap\"); err != nil {\n\t\treturn\n\t}\n\tt.Skip(2) // version\n\tnumTables := int(t.ReadUShort())\n\toffset31 := int64(0)\n\tfor j := 0; j < numTables; j++ {\n\t\tplatformID := t.ReadUShort()\n\t\tencodingID := t.ReadUShort()\n\t\toffset = int64(t.ReadULong())\n\t\tif platformID == 3 && encodingID == 1 {\n\t\t\toffset31 = offset\n\t\t}\n\t}\n\tif offset31 == 0 {\n\t\terr = fmt.Errorf(\"no Unicode encoding found\")\n\t\treturn\n\t}\n\tstartCount := make([]uint16, 0, 8)\n\tendCount := make([]uint16, 0, 8)\n\tidDelta := make([]int16, 0, 8)\n\tidRangeOffset := make([]uint16, 0, 8)\n\tt.rec.Chars = make(map[uint16]uint16)\n\tt.f.Seek(int64(t.tables[\"cmap\"])+offset31, os.SEEK_SET)\n\tformat := t.ReadUShort()\n\tif format != 4 {\n\t\terr = fmt.Errorf(\"unexpected subtable format: %d\", format)\n\t\treturn\n\t}\n\tt.Skip(2 * 2) // length, language\n\tsegCount := int(t.ReadUShort() / 2)\n\tt.Skip(3 * 2) // searchRange, entrySelector, rangeShift\n\tfor j := 0; j < segCount; j++ {\n\t\tendCount = append(endCount, t.ReadUShort())\n\t}\n\tt.Skip(2) // reservedPad\n\tfor j := 0; j < segCount; j++ {\n\t\tstartCount = append(startCount, t.ReadUShort())\n\t}\n\tfor j := 0; j < segCount; j++ {\n\t\tidDelta = append(idDelta, t.ReadShort())\n\t}\n\toffset, _ = t.f.Seek(int64(0), os.SEEK_CUR)\n\tfor j := 0; j < segCount; j++ {\n\t\tidRangeOffset = append(idRangeOffset, t.ReadUShort())\n\t}\n\tfor j := 0; j < segCount; j++ {\n\t\tc1 := startCount[j]\n\t\tc2 := endCount[j]\n\t\td := idDelta[j]\n\t\tro := idRangeOffset[j]\n\t\tif ro > 0 {\n\t\t\tt.f.Seek(offset+2*int64(j)+int64(ro), os.SEEK_SET)\n\t\t}\n\t\tfor c := c1; c <= c2; c++ {\n\t\t\tif c == 0xFFFF {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tvar gid int32\n\t\t\tif ro > 0 {\n\t\t\t\tgid = int32(t.ReadUShort())\n\t\t\t\tif gid > 0 {\n\t\t\t\t\tgid += int32(d)\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tgid = int32(c) + int32(d)\n\t\t\t}\n\t\t\tif gid >= 65536 {\n\t\t\t\tgid -= 65536\n\t\t\t}\n\t\t\tif gid > 0 {\n\t\t\t\tt.rec.Chars[c] = uint16(gid)\n\t\t\t}\n\t\t}\n\t}\n\treturn\n}\n\nfunc (t *ttfParser) ParseName() (err error) {\n\terr = t.Seek(\"name\")\n\tif err == nil {\n\t\ttableOffset, _ := t.f.Seek(0, os.SEEK_CUR)\n\t\tt.rec.PostScriptName = \"\"\n\t\tt.Skip(2) // format\n\t\tcount := t.ReadUShort()\n\t\tstringOffset := t.ReadUShort()\n\t\tfor j := uint16(0); j < count && t.rec.PostScriptName == \"\"; j++ {\n\t\t\tt.Skip(3 * 2) // platformID, encodingID, languageID\n\t\t\tnameID := t.ReadUShort()\n\t\t\tlength := t.ReadUShort()\n\t\t\toffset := t.ReadUShort()\n\t\t\tif nameID == 6 {\n\t\t\t\t// PostScript name\n\t\t\t\tt.f.Seek(int64(tableOffset)+int64(stringOffset)+int64(offset), os.SEEK_SET)\n\t\t\t\tvar s string\n\t\t\t\ts, err = t.ReadStr(int(length))\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\ts = strings.Replace(s, \"\\x00\", \"\", -1)\n\t\t\t\tvar re *regexp.Regexp\n\t\t\t\tif re, err = regexp.Compile(\"[(){}<> /%[\\\\]]\"); err != nil {\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tt.rec.PostScriptName = re.ReplaceAllString(s, \"\")\n\t\t\t}\n\t\t}\n\t\tif t.rec.PostScriptName == \"\" {\n\t\t\terr = fmt.Errorf(\"the name PostScript was not found\")\n\t\t}\n\t}\n\treturn\n}\n\nfunc (t *ttfParser) ParseOS2() (err error) {\n\terr = t.Seek(\"OS/2\")\n\tif err == nil {\n\t\tversion := t.ReadUShort()\n\t\tt.Skip(3 * 2) // xAvgCharWidth, usWeightClass, usWidthClass\n\t\tfsType := t.ReadUShort()\n\t\tt.rec.Embeddable = (fsType != 2) && (fsType&0x200) == 0\n\t\tt.Skip(11*2 + 10 + 4*4 + 4)\n\t\tfsSelection := t.ReadUShort()\n\t\tt.rec.Bold = (fsSelection & 32) != 0\n\t\tt.Skip(2 * 2) // usFirstCharIndex, usLastCharIndex\n\t\tt.rec.TypoAscender = t.ReadShort()\n\t\tt.rec.TypoDescender = t.ReadShort()\n\t\tif version >= 2 {\n\t\t\tt.Skip(3*2 + 2*4 + 2)\n\t\t\tt.rec.CapHeight = t.ReadShort()\n\t\t} else {\n\t\t\tt.rec.CapHeight = 0\n\t\t}\n\t}\n\treturn\n}\n\nfunc (t *ttfParser) ParsePost() (err error) {\n\terr = t.Seek(\"post\")\n\tif err == nil {\n\t\tt.Skip(4) // version\n\t\tt.rec.ItalicAngle = t.ReadShort()\n\t\tt.Skip(2) // Skip decimal part\n\t\tt.rec.UnderlinePosition = t.ReadShort()\n\t\tt.rec.UnderlineThickness = t.ReadShort()\n\t\tt.rec.IsFixedPitch = t.ReadULong() != 0\n\t}\n\treturn\n}\n\nfunc (t *ttfParser) Seek(tag string) (err error) {\n\tofs, ok := t.tables[tag]\n\tif ok {\n\t\tt.f.Seek(int64(ofs), os.SEEK_SET)\n\t} else {\n\t\terr = fmt.Errorf(\"table not found: %s\", tag)\n\t}\n\treturn\n}\n\nfunc (t *ttfParser) Skip(n int) {\n\tt.f.Seek(int64(n), os.SEEK_CUR)\n}\n\nfunc (t *ttfParser) ReadStr(length int) (str string, err error) {\n\tvar n int\n\tbuf := make([]byte, length)\n\tn, err = t.f.Read(buf)\n\tif err == nil {\n\t\tif n == length {\n\t\t\tstr = string(buf)\n\t\t} else {\n\t\t\terr = fmt.Errorf(\"unable to read %d bytes\", length)\n\t\t}\n\t}\n\treturn\n}\n\nfunc (t *ttfParser) ReadUShort() (val uint16) {\n\tbinary.Read(t.f, binary.BigEndian, &val)\n\treturn\n}\n\nfunc (t *ttfParser) ReadShort() (val int16) {\n\tbinary.Read(t.f, binary.BigEndian, &val)\n\treturn\n}\n\nfunc (t *ttfParser) ReadULong() (val uint32) {\n\tbinary.Read(t.f, binary.BigEndian, &val)\n\treturn\n}\n"
        },
        {
          "name": "ttfparser_test.go",
          "type": "blob",
          "size": 2.3388671875,
          "content": "/*\n * Copyright (c) 2013-2015 Kurt Jung (Gmail: kurt.w.jung)\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\n * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\n * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\npackage gofpdf_test\n\nimport (\n\t\"bytes\"\n\t\"fmt\"\n\n\t\"github.com/jung-kurt/gofpdf\"\n\t\"github.com/jung-kurt/gofpdf/internal/example\"\n)\n\nfunc ExampleTtfParse() {\n\tttf, err := gofpdf.TtfParse(example.FontDir() + \"/calligra.ttf\")\n\tif err == nil {\n\t\tfmt.Printf(\"Postscript name:  %s\\n\", ttf.PostScriptName)\n\t\tfmt.Printf(\"unitsPerEm:       %8d\\n\", ttf.UnitsPerEm)\n\t\tfmt.Printf(\"Xmin:             %8d\\n\", ttf.Xmin)\n\t\tfmt.Printf(\"Ymin:             %8d\\n\", ttf.Ymin)\n\t\tfmt.Printf(\"Xmax:             %8d\\n\", ttf.Xmax)\n\t\tfmt.Printf(\"Ymax:             %8d\\n\", ttf.Ymax)\n\t} else {\n\t\tfmt.Printf(\"%s\\n\", err)\n\t}\n\t// Output:\n\t// Postscript name:  CalligrapherRegular\n\t// unitsPerEm:           1000\n\t// Xmin:                 -173\n\t// Ymin:                 -234\n\t// Xmax:                 1328\n\t// Ymax:                  899\n}\n\nfunc hexStr(s string) string {\n\tvar b bytes.Buffer\n\tb.WriteString(\"\\\"\")\n\tfor _, ch := range []byte(s) {\n\t\tb.WriteString(fmt.Sprintf(\"\\\\x%02x\", ch))\n\t}\n\tb.WriteString(\"\\\":\")\n\treturn b.String()\n}\n\nfunc ExampleFpdf_GetStringWidth() {\n\tpdf := gofpdf.New(\"\", \"\", \"\", example.FontDir())\n\tpdf.SetFont(\"Helvetica\", \"\", 12)\n\tpdf.AddPage()\n\tfor _, s := range []string{\"Hello\", \"世界\", \"\\xe7a va?\"} {\n\t\tfmt.Printf(\"%-32s width %5.2f, bytes %2d, runes %2d\\n\",\n\t\t\thexStr(s), pdf.GetStringWidth(s), len(s), len([]rune(s)))\n\t\tif pdf.Err() {\n\t\t\tfmt.Println(pdf.Error())\n\t\t}\n\t}\n\tpdf.Close()\n\t// Output:\n\t// \"\\x48\\x65\\x6c\\x6c\\x6f\":          width  9.64, bytes  5, runes  5\n\t// \"\\xe4\\xb8\\x96\\xe7\\x95\\x8c\":      width 13.95, bytes  6, runes  2\n\t// \"\\xe7\\x61\\x20\\x76\\x61\\x3f\":      width 12.47, bytes  6, runes  6\n}\n"
        },
        {
          "name": "utf8fontfile.go",
          "type": "blob",
          "size": 30.9111328125,
          "content": "/*\n * Copyright (c) 2019 Arteom Korotkiy (Gmail: arteomkorotkiy)\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\n * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\n * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\npackage gofpdf\n\nimport (\n\t\"bytes\"\n\t\"encoding/binary\"\n\t\"fmt\"\n\t\"math\"\n\t\"sort\"\n)\n\n// flags\nconst symbolWords = 1 << 0\nconst symbolScale = 1 << 3\nconst symbolContinue = 1 << 5\nconst symbolAllScale = 1 << 6\nconst symbol2x2 = 1 << 7\n\n// CID map Init\nconst toUnicode = \"/CIDInit /ProcSet findresource begin\\n12 dict begin\\nbegincmap\\n/CIDSystemInfo\\n<</Registry (Adobe)\\n/Ordering (UCS)\\n/Supplement 0\\n>> def\\n/CMapName /Adobe-Identity-UCS def\\n/CMapType 2 def\\n1 begincodespacerange\\n<0000> <FFFF>\\nendcodespacerange\\n1 beginbfrange\\n<0000> <FFFF> <0000>\\nendbfrange\\nendcmap\\nCMapName currentdict /CMap defineresource pop\\nend\\nend\"\n\ntype utf8FontFile struct {\n\tfileReader           *fileReader\n\tLastRune             int\n\ttableDescriptions    map[string]*tableDescription\n\toutTablesData        map[string][]byte\n\tsymbolPosition       []int\n\tcharSymbolDictionary map[int]int\n\tAscent               int\n\tDescent              int\n\tfontElementSize      int\n\tBbox                 fontBoxType\n\tCapHeight            int\n\tStemV                int\n\tItalicAngle          int\n\tFlags                int\n\tUnderlinePosition    float64\n\tUnderlineThickness   float64\n\tCharWidths           []int\n\tDefaultWidth         float64\n\tsymbolData           map[int]map[string][]int\n\tCodeSymbolDictionary map[int]int\n}\n\ntype tableDescription struct {\n\tname     string\n\tchecksum []int\n\tposition int\n\tsize     int\n}\n\ntype fileReader struct {\n\treaderPosition int64\n\tarray          []byte\n}\n\nfunc (fr *fileReader) Read(s int) []byte {\n\tb := fr.array[fr.readerPosition : fr.readerPosition+int64(s)]\n\tfr.readerPosition += int64(s)\n\treturn b\n}\n\nfunc (fr *fileReader) seek(shift int64, flag int) (int64, error) {\n\tif flag == 0 {\n\t\tfr.readerPosition = shift\n\t} else if flag == 1 {\n\t\tfr.readerPosition += shift\n\t} else if flag == 2 {\n\t\tfr.readerPosition = int64(len(fr.array)) - shift\n\t}\n\treturn int64(fr.readerPosition), nil\n}\n\nfunc newUTF8Font(reader *fileReader) *utf8FontFile {\n\tutf := utf8FontFile{\n\t\tfileReader: reader,\n\t}\n\treturn &utf\n}\n\nfunc (utf *utf8FontFile) parseFile() error {\n\tutf.fileReader.readerPosition = 0\n\tutf.symbolPosition = make([]int, 0)\n\tutf.charSymbolDictionary = make(map[int]int)\n\tutf.tableDescriptions = make(map[string]*tableDescription)\n\tutf.outTablesData = make(map[string][]byte)\n\tutf.Ascent = 0\n\tutf.Descent = 0\n\tcodeType := uint32(utf.readUint32())\n\tif codeType == 0x4F54544F {\n\t\treturn fmt.Errorf(\"not supported\\n \")\n\t}\n\tif codeType == 0x74746366 {\n\t\treturn fmt.Errorf(\"not supported\\n \")\n\t}\n\tif codeType != 0x00010000 && codeType != 0x74727565 {\n\t\treturn fmt.Errorf(\"Not a TrueType font: codeType=%v\\n \", codeType)\n\t}\n\tutf.generateTableDescriptions()\n\tutf.parseTables()\n\treturn nil\n}\n\nfunc (utf *utf8FontFile) generateTableDescriptions() {\n\n\ttablesCount := utf.readUint16()\n\t_ = utf.readUint16()\n\t_ = utf.readUint16()\n\t_ = utf.readUint16()\n\tutf.tableDescriptions = make(map[string]*tableDescription)\n\n\tfor i := 0; i < tablesCount; i++ {\n\t\trecord := tableDescription{\n\t\t\tname:     utf.readTableName(),\n\t\t\tchecksum: []int{utf.readUint16(), utf.readUint16()},\n\t\t\tposition: utf.readUint32(),\n\t\t\tsize:     utf.readUint32(),\n\t\t}\n\t\tutf.tableDescriptions[record.name] = &record\n\t}\n}\n\nfunc (utf *utf8FontFile) readTableName() string {\n\treturn string(utf.fileReader.Read(4))\n}\n\nfunc (utf *utf8FontFile) readUint16() int {\n\ts := utf.fileReader.Read(2)\n\treturn (int(s[0]) << 8) + int(s[1])\n}\n\nfunc (utf *utf8FontFile) readUint32() int {\n\ts := utf.fileReader.Read(4)\n\treturn (int(s[0]) * 16777216) + (int(s[1]) << 16) + (int(s[2]) << 8) + int(s[3]) // \t16777216  = 1<<24\n}\n\nfunc (utf *utf8FontFile) calcInt32(x, y []int) []int {\n\tanswer := make([]int, 2)\n\tif y[1] > x[1] {\n\t\tx[1] += 1 << 16\n\t\tx[0]++\n\t}\n\tanswer[1] = x[1] - y[1]\n\tif y[0] > x[0] {\n\t\tx[0] += 1 << 16\n\t}\n\tanswer[0] = x[0] - y[0]\n\tanswer[0] = answer[0] & 0xFFFF\n\treturn answer\n}\n\nfunc (utf *utf8FontFile) generateChecksum(data []byte) []int {\n\tif (len(data) % 4) != 0 {\n\t\tfor i := 0; (len(data) % 4) != 0; i++ {\n\t\t\tdata = append(data, 0)\n\t\t}\n\t}\n\tanswer := []int{0x0000, 0x0000}\n\tfor i := 0; i < len(data); i += 4 {\n\t\tanswer[0] += (int(data[i]) << 8) + int(data[i+1])\n\t\tanswer[1] += (int(data[i+2]) << 8) + int(data[i+3])\n\t\tanswer[0] += answer[1] >> 16\n\t\tanswer[1] = answer[1] & 0xFFFF\n\t\tanswer[0] = answer[0] & 0xFFFF\n\t}\n\treturn answer\n}\n\nfunc (utf *utf8FontFile) seek(shift int) {\n\t_, _ = utf.fileReader.seek(int64(shift), 0)\n}\n\nfunc (utf *utf8FontFile) skip(delta int) {\n\t_, _ = utf.fileReader.seek(int64(delta), 1)\n}\n\n//SeekTable position\nfunc (utf *utf8FontFile) SeekTable(name string) int {\n\treturn utf.seekTable(name, 0)\n}\n\nfunc (utf *utf8FontFile) seekTable(name string, offsetInTable int) int {\n\t_, _ = utf.fileReader.seek(int64(utf.tableDescriptions[name].position+offsetInTable), 0)\n\treturn int(utf.fileReader.readerPosition)\n}\n\nfunc (utf *utf8FontFile) readInt16() int16 {\n\ts := utf.fileReader.Read(2)\n\ta := (int16(s[0]) << 8) + int16(s[1])\n\tif (int(a) & (1 << 15)) == 0 {\n\t\ta = int16(int(a) - (1 << 16))\n\t}\n\treturn a\n}\n\nfunc (utf *utf8FontFile) getUint16(pos int) int {\n\t_, _ = utf.fileReader.seek(int64(pos), 0)\n\ts := utf.fileReader.Read(2)\n\treturn (int(s[0]) << 8) + int(s[1])\n}\n\nfunc (utf *utf8FontFile) splice(stream []byte, offset int, value []byte) []byte {\n\tstream = append([]byte{}, stream...)\n\treturn append(append(stream[:offset], value...), stream[offset+len(value):]...)\n}\n\nfunc (utf *utf8FontFile) insertUint16(stream []byte, offset int, value int) []byte {\n\tup := make([]byte, 2)\n\tbinary.BigEndian.PutUint16(up, uint16(value))\n\treturn utf.splice(stream, offset, up)\n}\n\nfunc (utf *utf8FontFile) getRange(pos, length int) []byte {\n\t_, _ = utf.fileReader.seek(int64(pos), 0)\n\tif length < 1 {\n\t\treturn make([]byte, 0)\n\t}\n\ts := utf.fileReader.Read(length)\n\treturn s\n}\n\nfunc (utf *utf8FontFile) getTableData(name string) []byte {\n\tdesckrip := utf.tableDescriptions[name]\n\tif desckrip == nil {\n\t\treturn nil\n\t}\n\tif desckrip.size == 0 {\n\t\treturn nil\n\t}\n\t_, _ = utf.fileReader.seek(int64(desckrip.position), 0)\n\ts := utf.fileReader.Read(desckrip.size)\n\treturn s\n}\n\nfunc (utf *utf8FontFile) setOutTable(name string, data []byte) {\n\tif data == nil {\n\t\treturn\n\t}\n\tif name == \"head\" {\n\t\tdata = utf.splice(data, 8, []byte{0, 0, 0, 0})\n\t}\n\tutf.outTablesData[name] = data\n}\n\nfunc arrayKeys(arr map[int]string) []int {\n\tanswer := make([]int, len(arr))\n\ti := 0\n\tfor key := range arr {\n\t\tanswer[i] = key\n\t\ti++\n\t}\n\treturn answer\n}\n\nfunc inArray(s int, arr []int) bool {\n\tfor _, i := range arr {\n\t\tif s == i {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\nfunc (utf *utf8FontFile) parseNAMETable() int {\n\tnamePosition := utf.SeekTable(\"name\")\n\tformat := utf.readUint16()\n\tif format != 0 {\n\t\tfmt.Printf(\"Illegal format %d\\n\", format)\n\t\treturn format\n\t}\n\tnameCount := utf.readUint16()\n\tstringDataPosition := namePosition + utf.readUint16()\n\tnames := map[int]string{1: \"\", 2: \"\", 3: \"\", 4: \"\", 6: \"\"}\n\tkeys := arrayKeys(names)\n\tcounter := len(names)\n\tfor i := 0; i < nameCount; i++ {\n\t\tsystem := utf.readUint16()\n\t\tcode := utf.readUint16()\n\t\tlocal := utf.readUint16()\n\t\tnameID := utf.readUint16()\n\t\tsize := utf.readUint16()\n\t\tposition := utf.readUint16()\n\t\tif !inArray(nameID, keys) {\n\t\t\tcontinue\n\t\t}\n\t\tcurrentName := \"\"\n\t\tif system == 3 && code == 1 && local == 0x409 {\n\t\t\toldPos := utf.fileReader.readerPosition\n\t\t\tutf.seek(stringDataPosition + position)\n\t\t\tif size%2 != 0 {\n\t\t\t\tfmt.Printf(\"name is not binar byte format\\n\")\n\t\t\t\treturn format\n\t\t\t}\n\t\t\tsize /= 2\n\t\t\tcurrentName = \"\"\n\t\t\tfor size > 0 {\n\t\t\t\tchar := utf.readUint16()\n\t\t\t\tcurrentName += string(rune(char))\n\t\t\t\tsize--\n\t\t\t}\n\t\t\tutf.fileReader.readerPosition = oldPos\n\t\t\tutf.seek(int(oldPos))\n\t\t} else if system == 1 && code == 0 && local == 0 {\n\t\t\toldPos := utf.fileReader.readerPosition\n\t\t\tcurrentName = string(utf.getRange(stringDataPosition+position, size))\n\t\t\tutf.fileReader.readerPosition = oldPos\n\t\t\tutf.seek(int(oldPos))\n\t\t}\n\t\tif currentName != \"\" && names[nameID] == \"\" {\n\t\t\tnames[nameID] = currentName\n\t\t\tcounter--\n\t\t\tif counter == 0 {\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}\n\treturn format\n}\n\nfunc (utf *utf8FontFile) parseHEADTable() {\n\tutf.SeekTable(\"head\")\n\tutf.skip(18)\n\tutf.fontElementSize = utf.readUint16()\n\tscale := 1000.0 / float64(utf.fontElementSize)\n\tutf.skip(16)\n\txMin := utf.readInt16()\n\tyMin := utf.readInt16()\n\txMax := utf.readInt16()\n\tyMax := utf.readInt16()\n\tutf.Bbox = fontBoxType{int(float64(xMin) * scale), int(float64(yMin) * scale), int(float64(xMax) * scale), int(float64(yMax) * scale)}\n\tutf.skip(3 * 2)\n\t_ = utf.readUint16()\n\tsymbolDataFormat := utf.readUint16()\n\tif symbolDataFormat != 0 {\n\t\tfmt.Printf(\"Unknown symbol data format %d\\n\", symbolDataFormat)\n\t\treturn\n\t}\n}\n\nfunc (utf *utf8FontFile) parseHHEATable() int {\n\tmetricsCount := 0\n\tif _, OK := utf.tableDescriptions[\"hhea\"]; OK {\n\t\tscale := 1000.0 / float64(utf.fontElementSize)\n\t\tutf.SeekTable(\"hhea\")\n\t\tutf.skip(4)\n\t\thheaAscender := utf.readInt16()\n\t\thheaDescender := utf.readInt16()\n\t\tutf.Ascent = int(float64(hheaAscender) * scale)\n\t\tutf.Descent = int(float64(hheaDescender) * scale)\n\t\tutf.skip(24)\n\t\tmetricDataFormat := utf.readUint16()\n\t\tif metricDataFormat != 0 {\n\t\t\tfmt.Printf(\"Unknown horizontal metric data format %d\\n\", metricDataFormat)\n\t\t\treturn 0\n\t\t}\n\t\tmetricsCount = utf.readUint16()\n\t\tif metricsCount == 0 {\n\t\t\tfmt.Printf(\"Number of horizontal metrics is 0\\n\")\n\t\t\treturn 0\n\t\t}\n\t}\n\treturn metricsCount\n}\n\nfunc (utf *utf8FontFile) parseOS2Table() int {\n\tvar weightType int\n\tscale := 1000.0 / float64(utf.fontElementSize)\n\tif _, OK := utf.tableDescriptions[\"OS/2\"]; OK {\n\t\tutf.SeekTable(\"OS/2\")\n\t\tversion := utf.readUint16()\n\t\tutf.skip(2)\n\t\tweightType = utf.readUint16()\n\t\tutf.skip(2)\n\t\tfsType := utf.readUint16()\n\t\tif fsType == 0x0002 || (fsType&0x0300) != 0 {\n\t\t\tfmt.Printf(\"ERROR - copyright restrictions.\\n\")\n\t\t\treturn 0\n\t\t}\n\t\tutf.skip(20)\n\t\t_ = utf.readInt16()\n\n\t\tutf.skip(36)\n\t\tsTypoAscender := utf.readInt16()\n\t\tsTypoDescender := utf.readInt16()\n\t\tif utf.Ascent == 0 {\n\t\t\tutf.Ascent = int(float64(sTypoAscender) * scale)\n\t\t}\n\t\tif utf.Descent == 0 {\n\t\t\tutf.Descent = int(float64(sTypoDescender) * scale)\n\t\t}\n\t\tif version > 1 {\n\t\t\tutf.skip(16)\n\t\t\tsCapHeight := utf.readInt16()\n\t\t\tutf.CapHeight = int(float64(sCapHeight) * scale)\n\t\t} else {\n\t\t\tutf.CapHeight = utf.Ascent\n\t\t}\n\t} else {\n\t\tweightType = 500\n\t\tif utf.Ascent == 0 {\n\t\t\tutf.Ascent = int(float64(utf.Bbox.Ymax) * scale)\n\t\t}\n\t\tif utf.Descent == 0 {\n\t\t\tutf.Descent = int(float64(utf.Bbox.Ymin) * scale)\n\t\t}\n\t\tutf.CapHeight = utf.Ascent\n\t}\n\tutf.StemV = 50 + int(math.Pow(float64(weightType)/65.0, 2))\n\treturn weightType\n}\n\nfunc (utf *utf8FontFile) parsePOSTTable(weight int) {\n\tutf.SeekTable(\"post\")\n\tutf.skip(4)\n\tutf.ItalicAngle = int(utf.readInt16()) + utf.readUint16()/65536.0\n\tscale := 1000.0 / float64(utf.fontElementSize)\n\tutf.UnderlinePosition = float64(utf.readInt16()) * scale\n\tutf.UnderlineThickness = float64(utf.readInt16()) * scale\n\tfixed := utf.readUint32()\n\n\tutf.Flags = 4\n\n\tif utf.ItalicAngle != 0 {\n\t\tutf.Flags = utf.Flags | 64\n\t}\n\tif weight >= 600 {\n\t\tutf.Flags = utf.Flags | 262144\n\t}\n\tif fixed != 0 {\n\t\tutf.Flags = utf.Flags | 1\n\t}\n}\n\nfunc (utf *utf8FontFile) parseCMAPTable(format int) int {\n\tcmapPosition := utf.SeekTable(\"cmap\")\n\tutf.skip(2)\n\tcmapTableCount := utf.readUint16()\n\tcidCMAPPosition := 0\n\tfor i := 0; i < cmapTableCount; i++ {\n\t\tsystem := utf.readUint16()\n\t\tcoded := utf.readUint16()\n\t\tposition := utf.readUint32()\n\t\toldReaderPosition := utf.fileReader.readerPosition\n\t\tif (system == 3 && coded == 1) || system == 0 { // Microsoft, Unicode\n\t\t\tformat = utf.getUint16(cmapPosition + position)\n\t\t\tif format == 4 {\n\t\t\t\tif cidCMAPPosition == 0 {\n\t\t\t\t\tcidCMAPPosition = cmapPosition + position\n\t\t\t\t}\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tutf.seek(int(oldReaderPosition))\n\t}\n\tif cidCMAPPosition == 0 {\n\t\tfmt.Printf(\"Font does not have cmap for Unicode\\n\")\n\t\treturn cidCMAPPosition\n\t}\n\treturn cidCMAPPosition\n}\n\nfunc (utf *utf8FontFile) parseTables() {\n\tf := utf.parseNAMETable()\n\tutf.parseHEADTable()\n\tn := utf.parseHHEATable()\n\tw := utf.parseOS2Table()\n\tutf.parsePOSTTable(w)\n\truneCMAPPosition := utf.parseCMAPTable(f)\n\n\tutf.SeekTable(\"maxp\")\n\tutf.skip(4)\n\tnumSymbols := utf.readUint16()\n\n\tsymbolCharDictionary := make(map[int][]int)\n\tcharSymbolDictionary := make(map[int]int)\n\tutf.generateSCCSDictionaries(runeCMAPPosition, symbolCharDictionary, charSymbolDictionary)\n\n\tscale := 1000.0 / float64(utf.fontElementSize)\n\tutf.parseHMTXTable(n, numSymbols, symbolCharDictionary, scale)\n}\n\nfunc (utf *utf8FontFile) generateCMAP() map[int][]int {\n\tcmapPosition := utf.SeekTable(\"cmap\")\n\tutf.skip(2)\n\tcmapTableCount := utf.readUint16()\n\truneCmapPosition := 0\n\tfor i := 0; i < cmapTableCount; i++ {\n\t\tsystem := utf.readUint16()\n\t\tcoder := utf.readUint16()\n\t\tposition := utf.readUint32()\n\t\toldPosition := utf.fileReader.readerPosition\n\t\tif (system == 3 && coder == 1) || system == 0 {\n\t\t\tformat := utf.getUint16(cmapPosition + position)\n\t\t\tif format == 4 {\n\t\t\t\truneCmapPosition = cmapPosition + position\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tutf.seek(int(oldPosition))\n\t}\n\n\tif runeCmapPosition == 0 {\n\t\tfmt.Printf(\"Font does not have cmap for Unicode\\n\")\n\t\treturn nil\n\t}\n\n\tsymbolCharDictionary := make(map[int][]int)\n\tcharSymbolDictionary := make(map[int]int)\n\tutf.generateSCCSDictionaries(runeCmapPosition, symbolCharDictionary, charSymbolDictionary)\n\n\tutf.charSymbolDictionary = charSymbolDictionary\n\n\treturn symbolCharDictionary\n}\n\nfunc (utf *utf8FontFile) parseSymbols(usedRunes map[int]int) (map[int]int, map[int]int, map[int]int, []int) {\n\tsymbolCollection := map[int]int{0: 0}\n\tcharSymbolPairCollection := make(map[int]int)\n\tfor _, char := range usedRunes {\n\t\tif _, OK := utf.charSymbolDictionary[char]; OK {\n\t\t\tsymbolCollection[utf.charSymbolDictionary[char]] = char\n\t\t\tcharSymbolPairCollection[char] = utf.charSymbolDictionary[char]\n\n\t\t}\n\t\tutf.LastRune = max(utf.LastRune, char)\n\t}\n\n\tbegin := utf.tableDescriptions[\"glyf\"].position\n\n\tsymbolArray := make(map[int]int)\n\tsymbolCollectionKeys := keySortInt(symbolCollection)\n\n\tsymbolCounter := 0\n\tmaxRune := 0\n\tfor _, oldSymbolIndex := range symbolCollectionKeys {\n\t\tmaxRune = max(maxRune, symbolCollection[oldSymbolIndex])\n\t\tsymbolArray[oldSymbolIndex] = symbolCounter\n\t\tsymbolCounter++\n\t}\n\tcharSymbolPairCollectionKeys := keySortInt(charSymbolPairCollection)\n\truneSymbolPairCollection := make(map[int]int)\n\tfor _, runa := range charSymbolPairCollectionKeys {\n\t\truneSymbolPairCollection[runa] = symbolArray[charSymbolPairCollection[runa]]\n\t}\n\tutf.CodeSymbolDictionary = runeSymbolPairCollection\n\n\tsymbolCollectionKeys = keySortInt(symbolCollection)\n\tfor _, oldSymbolIndex := range symbolCollectionKeys {\n\t\t_, symbolArray, symbolCollection, symbolCollectionKeys = utf.getSymbols(oldSymbolIndex, &begin, symbolArray, symbolCollection, symbolCollectionKeys)\n\t}\n\n\treturn runeSymbolPairCollection, symbolArray, symbolCollection, symbolCollectionKeys\n}\n\nfunc (utf *utf8FontFile) generateCMAPTable(cidSymbolPairCollection map[int]int, numSymbols int) []byte {\n\tcidSymbolPairCollectionKeys := keySortInt(cidSymbolPairCollection)\n\tcidID := 0\n\tcidArray := make(map[int][]int)\n\tprevCid := -2\n\tprevSymbol := -1\n\tfor _, cid := range cidSymbolPairCollectionKeys {\n\t\tif cid == (prevCid+1) && cidSymbolPairCollection[cid] == (prevSymbol+1) {\n\t\t\tif n, OK := cidArray[cidID]; !OK || n == nil {\n\t\t\t\tcidArray[cidID] = make([]int, 0)\n\t\t\t}\n\t\t\tcidArray[cidID] = append(cidArray[cidID], cidSymbolPairCollection[cid])\n\t\t} else {\n\t\t\tcidID = cid\n\t\t\tcidArray[cidID] = make([]int, 0)\n\t\t\tcidArray[cidID] = append(cidArray[cidID], cidSymbolPairCollection[cid])\n\t\t}\n\t\tprevCid = cid\n\t\tprevSymbol = cidSymbolPairCollection[cid]\n\t}\n\tcidArrayKeys := keySortArrayRangeMap(cidArray)\n\tsegCount := len(cidArray) + 1\n\n\tsearchRange := 1\n\tentrySelector := 0\n\tfor searchRange*2 <= segCount {\n\t\tsearchRange = searchRange * 2\n\t\tentrySelector = entrySelector + 1\n\t}\n\tsearchRange = searchRange * 2\n\trangeShift := segCount*2 - searchRange\n\tlength := 16 + (8 * segCount) + (numSymbols + 1)\n\tcmap := []int{0, 1, 3, 1, 0, 12, 4, length, 0, segCount * 2, searchRange, entrySelector, rangeShift}\n\n\tfor _, start := range cidArrayKeys {\n\t\tendCode := start + (len(cidArray[start]) - 1)\n\t\tcmap = append(cmap, endCode)\n\t}\n\tcmap = append(cmap, 0xFFFF)\n\tcmap = append(cmap, 0)\n\n\tfor _, cidKey := range cidArrayKeys {\n\t\tcmap = append(cmap, cidKey)\n\t}\n\tcmap = append(cmap, 0xFFFF)\n\tfor _, cidKey := range cidArrayKeys {\n\t\tidDelta := -(cidKey - cidArray[cidKey][0])\n\t\tcmap = append(cmap, idDelta)\n\t}\n\tcmap = append(cmap, 1)\n\tfor range cidArray {\n\t\tcmap = append(cmap, 0)\n\n\t}\n\tcmap = append(cmap, 0)\n\tfor _, start := range cidArrayKeys {\n\t\tfor _, glidx := range cidArray[start] {\n\t\t\tcmap = append(cmap, glidx)\n\t\t}\n\t}\n\tcmap = append(cmap, 0)\n\tcmapstr := make([]byte, 0)\n\tfor _, cm := range cmap {\n\t\tcmapstr = append(cmapstr, packUint16(cm)...)\n\t}\n\treturn cmapstr\n}\n\n//GenerateCutFont fill utf8FontFile from .utf file, only with runes from usedRunes\nfunc (utf *utf8FontFile) GenerateCutFont(usedRunes map[int]int) []byte {\n\tutf.fileReader.readerPosition = 0\n\tutf.symbolPosition = make([]int, 0)\n\tutf.charSymbolDictionary = make(map[int]int)\n\tutf.tableDescriptions = make(map[string]*tableDescription)\n\tutf.outTablesData = make(map[string][]byte)\n\tutf.Ascent = 0\n\tutf.Descent = 0\n\tutf.skip(4)\n\tutf.LastRune = 0\n\tutf.generateTableDescriptions()\n\n\tutf.SeekTable(\"head\")\n\tutf.skip(50)\n\tLocaFormat := utf.readUint16()\n\n\tutf.SeekTable(\"hhea\")\n\tutf.skip(34)\n\tmetricsCount := utf.readUint16()\n\toldMetrics := metricsCount\n\n\tutf.SeekTable(\"maxp\")\n\tutf.skip(4)\n\tnumSymbols := utf.readUint16()\n\n\tsymbolCharDictionary := utf.generateCMAP()\n\tif symbolCharDictionary == nil {\n\t\treturn nil\n\t}\n\n\tutf.parseHMTXTable(metricsCount, numSymbols, symbolCharDictionary, 1.0)\n\n\tutf.parseLOCATable(LocaFormat, numSymbols)\n\n\tcidSymbolPairCollection, symbolArray, symbolCollection, symbolCollectionKeys := utf.parseSymbols(usedRunes)\n\n\tmetricsCount = len(symbolCollection)\n\tnumSymbols = metricsCount\n\n\tutf.setOutTable(\"name\", utf.getTableData(\"name\"))\n\tutf.setOutTable(\"cvt \", utf.getTableData(\"cvt \"))\n\tutf.setOutTable(\"fpgm\", utf.getTableData(\"fpgm\"))\n\tutf.setOutTable(\"prep\", utf.getTableData(\"prep\"))\n\tutf.setOutTable(\"gasp\", utf.getTableData(\"gasp\"))\n\n\tpostTable := utf.getTableData(\"post\")\n\tpostTable = append(append([]byte{0x00, 0x03, 0x00, 0x00}, postTable[4:16]...), []byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}...)\n\tutf.setOutTable(\"post\", postTable)\n\n\tdelete(cidSymbolPairCollection, 0)\n\n\tutf.setOutTable(\"cmap\", utf.generateCMAPTable(cidSymbolPairCollection, numSymbols))\n\n\tsymbolData := utf.getTableData(\"glyf\")\n\n\toffsets := make([]int, 0)\n\tglyfData := make([]byte, 0)\n\tpos := 0\n\thmtxData := make([]byte, 0)\n\tutf.symbolData = make(map[int]map[string][]int, 0)\n\n\tfor _, originalSymbolIdx := range symbolCollectionKeys {\n\t\thm := utf.getMetrics(oldMetrics, originalSymbolIdx)\n\t\thmtxData = append(hmtxData, hm...)\n\n\t\toffsets = append(offsets, pos)\n\t\tsymbolPos := utf.symbolPosition[originalSymbolIdx]\n\t\tsymbolLen := utf.symbolPosition[originalSymbolIdx+1] - symbolPos\n\t\tdata := symbolData[symbolPos : symbolPos+symbolLen]\n\t\tvar up int\n\t\tif symbolLen > 0 {\n\t\t\tup = unpackUint16(data[0:2])\n\t\t}\n\n\t\tif symbolLen > 2 && (up&(1<<15)) != 0 {\n\t\t\tposInSymbol := 10\n\t\t\tflags := symbolContinue\n\t\t\tnComponentElements := 0\n\t\t\tfor (flags & symbolContinue) != 0 {\n\t\t\t\tnComponentElements++\n\t\t\t\tup = unpackUint16(data[posInSymbol : posInSymbol+2])\n\t\t\t\tflags = up\n\t\t\t\tup = unpackUint16(data[posInSymbol+2 : posInSymbol+4])\n\t\t\t\tsymbolIdx := up\n\t\t\t\tif _, OK := utf.symbolData[originalSymbolIdx]; !OK {\n\t\t\t\t\tutf.symbolData[originalSymbolIdx] = make(map[string][]int)\n\t\t\t\t}\n\t\t\t\tif _, OK := utf.symbolData[originalSymbolIdx][\"compSymbols\"]; !OK {\n\t\t\t\t\tutf.symbolData[originalSymbolIdx][\"compSymbols\"] = make([]int, 0)\n\t\t\t\t}\n\t\t\t\tutf.symbolData[originalSymbolIdx][\"compSymbols\"] = append(utf.symbolData[originalSymbolIdx][\"compSymbols\"], symbolIdx)\n\t\t\t\tdata = utf.insertUint16(data, posInSymbol+2, symbolArray[symbolIdx])\n\t\t\t\tposInSymbol += 4\n\t\t\t\tif (flags & symbolWords) != 0 {\n\t\t\t\t\tposInSymbol += 4\n\t\t\t\t} else {\n\t\t\t\t\tposInSymbol += 2\n\t\t\t\t}\n\t\t\t\tif (flags & symbolScale) != 0 {\n\t\t\t\t\tposInSymbol += 2\n\t\t\t\t} else if (flags & symbolAllScale) != 0 {\n\t\t\t\t\tposInSymbol += 4\n\t\t\t\t} else if (flags & symbol2x2) != 0 {\n\t\t\t\t\tposInSymbol += 8\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tglyfData = append(glyfData, data...)\n\t\tpos += symbolLen\n\t\tif pos%4 != 0 {\n\t\t\tpadding := 4 - (pos % 4)\n\t\t\tglyfData = append(glyfData, make([]byte, padding)...)\n\t\t\tpos += padding\n\t\t}\n\t}\n\n\toffsets = append(offsets, pos)\n\tutf.setOutTable(\"glyf\", glyfData)\n\n\tutf.setOutTable(\"hmtx\", hmtxData)\n\n\tlocaData := make([]byte, 0)\n\tif ((pos + 1) >> 1) > 0xFFFF {\n\t\tLocaFormat = 1\n\t\tfor _, offset := range offsets {\n\t\t\tlocaData = append(locaData, packUint32(offset)...)\n\t\t}\n\t} else {\n\t\tLocaFormat = 0\n\t\tfor _, offset := range offsets {\n\t\t\tlocaData = append(locaData, packUint16(offset/2)...)\n\t\t}\n\t}\n\tutf.setOutTable(\"loca\", locaData)\n\n\theadData := utf.getTableData(\"head\")\n\theadData = utf.insertUint16(headData, 50, LocaFormat)\n\tutf.setOutTable(\"head\", headData)\n\n\thheaData := utf.getTableData(\"hhea\")\n\thheaData = utf.insertUint16(hheaData, 34, metricsCount)\n\tutf.setOutTable(\"hhea\", hheaData)\n\n\tmaxp := utf.getTableData(\"maxp\")\n\tmaxp = utf.insertUint16(maxp, 4, numSymbols)\n\tutf.setOutTable(\"maxp\", maxp)\n\n\tos2Data := utf.getTableData(\"OS/2\")\n\tutf.setOutTable(\"OS/2\", os2Data)\n\n\treturn utf.assembleTables()\n}\n\nfunc (utf *utf8FontFile) getSymbols(originalSymbolIdx int, start *int, symbolSet map[int]int, SymbolsCollection map[int]int, SymbolsCollectionKeys []int) (*int, map[int]int, map[int]int, []int) {\n\tsymbolPos := utf.symbolPosition[originalSymbolIdx]\n\tsymbolSize := utf.symbolPosition[originalSymbolIdx+1] - symbolPos\n\tif symbolSize == 0 {\n\t\treturn start, symbolSet, SymbolsCollection, SymbolsCollectionKeys\n\t}\n\tutf.seek(*start + symbolPos)\n\n\tlineCount := utf.readInt16()\n\n\tif lineCount < 0 {\n\t\tutf.skip(8)\n\t\tflags := symbolContinue\n\t\tfor flags&symbolContinue != 0 {\n\t\t\tflags = utf.readUint16()\n\t\t\tsymbolIndex := utf.readUint16()\n\t\t\tif _, OK := symbolSet[symbolIndex]; !OK {\n\t\t\t\tsymbolSet[symbolIndex] = len(SymbolsCollection)\n\t\t\t\tSymbolsCollection[symbolIndex] = 1\n\t\t\t\tSymbolsCollectionKeys = append(SymbolsCollectionKeys, symbolIndex)\n\t\t\t}\n\t\t\toldPosition, _ := utf.fileReader.seek(0, 1)\n\t\t\t_, _, _, SymbolsCollectionKeys = utf.getSymbols(symbolIndex, start, symbolSet, SymbolsCollection, SymbolsCollectionKeys)\n\t\t\tutf.seek(int(oldPosition))\n\t\t\tif flags&symbolWords != 0 {\n\t\t\t\tutf.skip(4)\n\t\t\t} else {\n\t\t\t\tutf.skip(2)\n\t\t\t}\n\t\t\tif flags&symbolScale != 0 {\n\t\t\t\tutf.skip(2)\n\t\t\t} else if flags&symbolAllScale != 0 {\n\t\t\t\tutf.skip(4)\n\t\t\t} else if flags&symbol2x2 != 0 {\n\t\t\t\tutf.skip(8)\n\t\t\t}\n\t\t}\n\t}\n\treturn start, symbolSet, SymbolsCollection, SymbolsCollectionKeys\n}\n\nfunc (utf *utf8FontFile) parseHMTXTable(numberOfHMetrics, numSymbols int, symbolToChar map[int][]int, scale float64) {\n\tvar widths int\n\tstart := utf.SeekTable(\"hmtx\")\n\tarrayWidths := 0\n\tvar arr []int\n\tutf.CharWidths = make([]int, 256*256)\n\tcharCount := 0\n\tarr = unpackUint16Array(utf.getRange(start, numberOfHMetrics*4))\n\tfor symbol := 0; symbol < numberOfHMetrics; symbol++ {\n\t\tarrayWidths = arr[(symbol*2)+1]\n\t\tif _, OK := symbolToChar[symbol]; OK || symbol == 0 {\n\n\t\t\tif arrayWidths >= (1 << 15) {\n\t\t\t\tarrayWidths = 0\n\t\t\t}\n\t\t\tif symbol == 0 {\n\t\t\t\tutf.DefaultWidth = scale * float64(arrayWidths)\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tfor _, char := range symbolToChar[symbol] {\n\t\t\t\tif char != 0 && char != 65535 {\n\t\t\t\t\twidths = int(math.Round(scale * float64(arrayWidths)))\n\t\t\t\t\tif widths == 0 {\n\t\t\t\t\t\twidths = 65535\n\t\t\t\t\t}\n\t\t\t\t\tif char < 196608 {\n\t\t\t\t\t\tutf.CharWidths[char] = widths\n\t\t\t\t\t\tcharCount++\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tdiff := numSymbols - numberOfHMetrics\n\tfor pos := 0; pos < diff; pos++ {\n\t\tsymbol := pos + numberOfHMetrics\n\t\tif _, OK := symbolToChar[symbol]; OK {\n\t\t\tfor _, char := range symbolToChar[symbol] {\n\t\t\t\tif char != 0 && char != 65535 {\n\t\t\t\t\twidths = int(math.Round(scale * float64(arrayWidths)))\n\t\t\t\t\tif widths == 0 {\n\t\t\t\t\t\twidths = 65535\n\t\t\t\t\t}\n\t\t\t\t\tif char < 196608 {\n\t\t\t\t\t\tutf.CharWidths[char] = widths\n\t\t\t\t\t\tcharCount++\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tutf.CharWidths[0] = charCount\n}\n\nfunc (utf *utf8FontFile) getMetrics(metricCount, gid int) []byte {\n\tstart := utf.SeekTable(\"hmtx\")\n\tvar metrics []byte\n\tif gid < metricCount {\n\t\tutf.seek(start + (gid * 4))\n\t\tmetrics = utf.fileReader.Read(4)\n\t} else {\n\t\tutf.seek(start + ((metricCount - 1) * 4))\n\t\tmetrics = utf.fileReader.Read(2)\n\t\tutf.seek(start + (metricCount * 2) + (gid * 2))\n\t\tmetrics = append(metrics, utf.fileReader.Read(2)...)\n\t}\n\treturn metrics\n}\n\nfunc (utf *utf8FontFile) parseLOCATable(format, numSymbols int) {\n\tstart := utf.SeekTable(\"loca\")\n\tutf.symbolPosition = make([]int, 0)\n\tif format == 0 {\n\t\tdata := utf.getRange(start, (numSymbols*2)+2)\n\t\tarr := unpackUint16Array(data)\n\t\tfor n := 0; n <= numSymbols; n++ {\n\t\t\tutf.symbolPosition = append(utf.symbolPosition, arr[n+1]*2)\n\t\t}\n\t} else if format == 1 {\n\t\tdata := utf.getRange(start, (numSymbols*4)+4)\n\t\tarr := unpackUint32Array(data)\n\t\tfor n := 0; n <= numSymbols; n++ {\n\t\t\tutf.symbolPosition = append(utf.symbolPosition, arr[n+1])\n\t\t}\n\t} else {\n\t\tfmt.Printf(\"Unknown loca table format %d\\n\", format)\n\t\treturn\n\t}\n}\n\nfunc (utf *utf8FontFile) generateSCCSDictionaries(runeCmapPosition int, symbolCharDictionary map[int][]int, charSymbolDictionary map[int]int) {\n\tmaxRune := 0\n\tutf.seek(runeCmapPosition + 2)\n\tsize := utf.readUint16()\n\trim := runeCmapPosition + size\n\tutf.skip(2)\n\n\tsegmentSize := utf.readUint16() / 2\n\tutf.skip(6)\n\tcompleters := make([]int, 0)\n\tfor i := 0; i < segmentSize; i++ {\n\t\tcompleters = append(completers, utf.readUint16())\n\t}\n\tutf.skip(2)\n\tbeginners := make([]int, 0)\n\tfor i := 0; i < segmentSize; i++ {\n\t\tbeginners = append(beginners, utf.readUint16())\n\t}\n\tsizes := make([]int, 0)\n\tfor i := 0; i < segmentSize; i++ {\n\t\tsizes = append(sizes, int(utf.readInt16()))\n\t}\n\treaderPositionStart := utf.fileReader.readerPosition\n\tpositions := make([]int, 0)\n\tfor i := 0; i < segmentSize; i++ {\n\t\tpositions = append(positions, utf.readUint16())\n\t}\n\tvar symbol int\n\tfor n := 0; n < segmentSize; n++ {\n\t\tcompletePosition := completers[n] + 1\n\t\tfor char := beginners[n]; char < completePosition; char++ {\n\t\t\tif positions[n] == 0 {\n\t\t\t\tsymbol = (char + sizes[n]) & 0xFFFF\n\t\t\t} else {\n\t\t\t\tposition := (char-beginners[n])*2 + positions[n]\n\t\t\t\tposition = int(readerPositionStart) + 2*n + position\n\t\t\t\tif position >= rim {\n\t\t\t\t\tsymbol = 0\n\t\t\t\t} else {\n\t\t\t\t\tsymbol = utf.getUint16(position)\n\t\t\t\t\tif symbol != 0 {\n\t\t\t\t\t\tsymbol = (symbol + sizes[n]) & 0xFFFF\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tcharSymbolDictionary[char] = symbol\n\t\t\tif char < 196608 {\n\t\t\t\tmaxRune = max(char, maxRune)\n\t\t\t}\n\t\t\tsymbolCharDictionary[symbol] = append(symbolCharDictionary[symbol], char)\n\t\t}\n\t}\n}\n\nfunc max(i, n int) int {\n\tif n > i {\n\t\treturn n\n\t}\n\treturn i\n}\n\nfunc (utf *utf8FontFile) assembleTables() []byte {\n\tanswer := make([]byte, 0)\n\ttablesCount := len(utf.outTablesData)\n\tfindSize := 1\n\twriter := 0\n\tfor findSize*2 <= tablesCount {\n\t\tfindSize = findSize * 2\n\t\twriter = writer + 1\n\t}\n\tfindSize = findSize * 16\n\trOffset := tablesCount*16 - findSize\n\n\tanswer = append(answer, packHeader(0x00010000, tablesCount, findSize, writer, rOffset)...)\n\n\ttables := utf.outTablesData\n\ttablesNames := keySortStrings(tables)\n\n\toffset := 12 + tablesCount*16\n\tbegin := 0\n\n\tfor _, name := range tablesNames {\n\t\tif name == \"head\" {\n\t\t\tbegin = offset\n\t\t}\n\t\tanswer = append(answer, []byte(name)...)\n\t\tchecksum := utf.generateChecksum(tables[name])\n\t\tanswer = append(answer, pack2Uint16(checksum[0], checksum[1])...)\n\t\tanswer = append(answer, pack2Uint32(offset, len(tables[name]))...)\n\t\tpaddedLength := (len(tables[name]) + 3) &^ 3\n\t\toffset = offset + paddedLength\n\t}\n\n\tfor _, key := range tablesNames {\n\t\tdata := append([]byte{}, tables[key]...)\n\t\tdata = append(data, []byte{0, 0, 0}...)\n\t\tanswer = append(answer, data[:(len(data)&^3)]...)\n\t}\n\n\tchecksum := utf.generateChecksum([]byte(answer))\n\tchecksum = utf.calcInt32([]int{0xB1B0, 0xAFBA}, checksum)\n\tanswer = utf.splice(answer, (begin + 8), pack2Uint16(checksum[0], checksum[1]))\n\treturn answer\n}\n\nfunc unpackUint16Array(data []byte) []int {\n\tanswer := make([]int, 1)\n\tr := bytes.NewReader(data)\n\tbs := make([]byte, 2)\n\tvar e error\n\tvar c int\n\tc, e = r.Read(bs)\n\tfor e == nil && c > 0 {\n\t\tanswer = append(answer, int(binary.BigEndian.Uint16(bs)))\n\t\tc, e = r.Read(bs)\n\t}\n\treturn answer\n}\n\nfunc unpackUint32Array(data []byte) []int {\n\tanswer := make([]int, 1)\n\tr := bytes.NewReader(data)\n\tbs := make([]byte, 4)\n\tvar e error\n\tvar c int\n\tc, e = r.Read(bs)\n\tfor e == nil && c > 0 {\n\t\tanswer = append(answer, int(binary.BigEndian.Uint32(bs)))\n\t\tc, e = r.Read(bs)\n\t}\n\treturn answer\n}\n\nfunc unpackUint16(data []byte) int {\n\treturn int(binary.BigEndian.Uint16(data))\n}\n\nfunc packHeader(N uint32, n1, n2, n3, n4 int) []byte {\n\tanswer := make([]byte, 0)\n\tbs4 := make([]byte, 4)\n\tbinary.BigEndian.PutUint32(bs4, N)\n\tanswer = append(answer, bs4...)\n\tbs := make([]byte, 2)\n\tbinary.BigEndian.PutUint16(bs, uint16(n1))\n\tanswer = append(answer, bs...)\n\tbinary.BigEndian.PutUint16(bs, uint16(n2))\n\tanswer = append(answer, bs...)\n\tbinary.BigEndian.PutUint16(bs, uint16(n3))\n\tanswer = append(answer, bs...)\n\tbinary.BigEndian.PutUint16(bs, uint16(n4))\n\tanswer = append(answer, bs...)\n\treturn answer\n}\n\nfunc pack2Uint16(n1, n2 int) []byte {\n\tanswer := make([]byte, 0)\n\tbs := make([]byte, 2)\n\tbinary.BigEndian.PutUint16(bs, uint16(n1))\n\tanswer = append(answer, bs...)\n\tbinary.BigEndian.PutUint16(bs, uint16(n2))\n\tanswer = append(answer, bs...)\n\treturn answer\n}\n\nfunc pack2Uint32(n1, n2 int) []byte {\n\tanswer := make([]byte, 0)\n\tbs := make([]byte, 4)\n\tbinary.BigEndian.PutUint32(bs, uint32(n1))\n\tanswer = append(answer, bs...)\n\tbinary.BigEndian.PutUint32(bs, uint32(n2))\n\tanswer = append(answer, bs...)\n\treturn answer\n}\n\nfunc packUint32(n1 int) []byte {\n\tbs := make([]byte, 4)\n\tbinary.BigEndian.PutUint32(bs, uint32(n1))\n\treturn bs\n}\n\nfunc packUint16(n1 int) []byte {\n\tbs := make([]byte, 2)\n\tbinary.BigEndian.PutUint16(bs, uint16(n1))\n\treturn bs\n}\n\nfunc keySortStrings(s map[string][]byte) []string {\n\tkeys := make([]string, len(s))\n\ti := 0\n\tfor key := range s {\n\t\tkeys[i] = key\n\t\ti++\n\t}\n\tsort.Strings(keys)\n\treturn keys\n}\n\nfunc keySortInt(s map[int]int) []int {\n\tkeys := make([]int, len(s))\n\ti := 0\n\tfor key := range s {\n\t\tkeys[i] = key\n\t\ti++\n\t}\n\tsort.Ints(keys)\n\treturn keys\n}\n\nfunc keySortArrayRangeMap(s map[int][]int) []int {\n\tkeys := make([]int, len(s))\n\ti := 0\n\tfor key := range s {\n\t\tkeys[i] = key\n\t\ti++\n\t}\n\tsort.Ints(keys)\n\treturn keys\n}\n\n// UTF8CutFont is a utility function that generates a TrueType font composed\n// only of the runes included in cutset. The rune glyphs are copied from This\n// function is demonstrated in ExampleUTF8CutFont().\nfunc UTF8CutFont(inBuf []byte, cutset string) (outBuf []byte) {\n\tf := newUTF8Font(&fileReader{readerPosition: 0, array: inBuf})\n\trunes := map[int]int{}\n\tfor i, r := range cutset {\n\t\trunes[i] = int(r)\n\t}\n\toutBuf = f.GenerateCutFont(runes)\n\treturn\n}\n"
        },
        {
          "name": "util.go",
          "type": "blob",
          "size": 11.5263671875,
          "content": "/*\n * Copyright (c) 2013 Kurt Jung (Gmail: kurt.w.jung)\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\n * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\n * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\npackage gofpdf\n\nimport (\n\t\"bufio\"\n\t\"bytes\"\n\t\"compress/zlib\"\n\t\"fmt\"\n\t\"io\"\n\t\"math\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"strings\"\n)\n\nfunc round(f float64) int {\n\tif f < 0 {\n\t\treturn -int(math.Floor(-f + 0.5))\n\t}\n\treturn int(math.Floor(f + 0.5))\n}\n\nfunc sprintf(fmtStr string, args ...interface{}) string {\n\treturn fmt.Sprintf(fmtStr, args...)\n}\n\n// fileExist returns true if the specified normal file exists\nfunc fileExist(filename string) (ok bool) {\n\tinfo, err := os.Stat(filename)\n\tif err == nil {\n\t\tif ^os.ModePerm&info.Mode() == 0 {\n\t\t\tok = true\n\t\t}\n\t}\n\treturn ok\n}\n\n// fileSize returns the size of the specified file; ok will be false\n// if the file does not exist or is not an ordinary file\nfunc fileSize(filename string) (size int64, ok bool) {\n\tinfo, err := os.Stat(filename)\n\tok = err == nil\n\tif ok {\n\t\tsize = info.Size()\n\t}\n\treturn\n}\n\n// bufferFromReader returns a new buffer populated with the contents of the specified Reader\nfunc bufferFromReader(r io.Reader) (b *bytes.Buffer, err error) {\n\tb = new(bytes.Buffer)\n\t_, err = b.ReadFrom(r)\n\treturn\n}\n\n// slicesEqual returns true if the two specified float slices are equal\nfunc slicesEqual(a, b []float64) bool {\n\tif len(a) != len(b) {\n\t\treturn false\n\t}\n\tfor i := range a {\n\t\tif a[i] != b[i] {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\n// sliceCompress returns a zlib-compressed copy of the specified byte array\nfunc sliceCompress(data []byte) []byte {\n\tvar buf bytes.Buffer\n\tcmp, _ := zlib.NewWriterLevel(&buf, zlib.BestSpeed)\n\tcmp.Write(data)\n\tcmp.Close()\n\treturn buf.Bytes()\n}\n\n// sliceUncompress returns an uncompressed copy of the specified zlib-compressed byte array\nfunc sliceUncompress(data []byte) (outData []byte, err error) {\n\tinBuf := bytes.NewReader(data)\n\tr, err := zlib.NewReader(inBuf)\n\tdefer r.Close()\n\tif err == nil {\n\t\tvar outBuf bytes.Buffer\n\t\t_, err = outBuf.ReadFrom(r)\n\t\tif err == nil {\n\t\t\toutData = outBuf.Bytes()\n\t\t}\n\t}\n\treturn\n}\n\n// utf8toutf16 converts UTF-8 to UTF-16BE; from http://www.fpdf.org/\nfunc utf8toutf16(s string, withBOM ...bool) string {\n\tbom := true\n\tif len(withBOM) > 0 {\n\t\tbom = withBOM[0]\n\t}\n\tres := make([]byte, 0, 8)\n\tif bom {\n\t\tres = append(res, 0xFE, 0xFF)\n\t}\n\tnb := len(s)\n\ti := 0\n\tfor i < nb {\n\t\tc1 := byte(s[i])\n\t\ti++\n\t\tswitch {\n\t\tcase c1 >= 224:\n\t\t\t// 3-byte character\n\t\t\tc2 := byte(s[i])\n\t\t\ti++\n\t\t\tc3 := byte(s[i])\n\t\t\ti++\n\t\t\tres = append(res, ((c1&0x0F)<<4)+((c2&0x3C)>>2),\n\t\t\t\t((c2&0x03)<<6)+(c3&0x3F))\n\t\tcase c1 >= 192:\n\t\t\t// 2-byte character\n\t\t\tc2 := byte(s[i])\n\t\t\ti++\n\t\t\tres = append(res, ((c1 & 0x1C) >> 2),\n\t\t\t\t((c1&0x03)<<6)+(c2&0x3F))\n\t\tdefault:\n\t\t\t// Single-byte character\n\t\t\tres = append(res, 0, c1)\n\t\t}\n\t}\n\treturn string(res)\n}\n\n// intIf returns a if cnd is true, otherwise b\nfunc intIf(cnd bool, a, b int) int {\n\tif cnd {\n\t\treturn a\n\t}\n\treturn b\n}\n\n// strIf returns aStr if cnd is true, otherwise bStr\nfunc strIf(cnd bool, aStr, bStr string) string {\n\tif cnd {\n\t\treturn aStr\n\t}\n\treturn bStr\n}\n\n// doNothing returns the passed string with no translation.\nfunc doNothing(s string) string {\n\treturn s\n}\n\n// Dump the internals of the specified values\n// func dump(fileStr string, a ...interface{}) {\n// \tfl, err := os.OpenFile(fileStr, os.O_CREATE|os.O_APPEND|os.O_WRONLY, 0600)\n// \tif err == nil {\n// \t\tfmt.Fprintf(fl, \"----------------\\n\")\n// \t\tspew.Fdump(fl, a...)\n// \t\tfl.Close()\n// \t}\n// }\n\nfunc repClosure(m map[rune]byte) func(string) string {\n\tvar buf bytes.Buffer\n\treturn func(str string) string {\n\t\tvar ch byte\n\t\tvar ok bool\n\t\tbuf.Truncate(0)\n\t\tfor _, r := range str {\n\t\t\tif r < 0x80 {\n\t\t\t\tch = byte(r)\n\t\t\t} else {\n\t\t\t\tch, ok = m[r]\n\t\t\t\tif !ok {\n\t\t\t\t\tch = byte('.')\n\t\t\t\t}\n\t\t\t}\n\t\t\tbuf.WriteByte(ch)\n\t\t}\n\t\treturn buf.String()\n\t}\n}\n\n// UnicodeTranslator returns a function that can be used to translate, where\n// possible, utf-8 strings to a form that is compatible with the specified code\n// page. The returned function accepts a string and returns a string.\n//\n// r is a reader that should read a buffer made up of content lines that\n// pertain to the code page of interest. Each line is made up of three\n// whitespace separated fields. The first begins with \"!\" and is followed by\n// two hexadecimal digits that identify the glyph position in the code page of\n// interest. The second field begins with \"U+\" and is followed by the unicode\n// code point value. The third is the glyph name. A number of these code page\n// map files are packaged with the gfpdf library in the font directory.\n//\n// An error occurs only if a line is read that does not conform to the expected\n// format. In this case, the returned function is valid but does not perform\n// any rune translation.\nfunc UnicodeTranslator(r io.Reader) (f func(string) string, err error) {\n\tm := make(map[rune]byte)\n\tvar uPos, cPos uint32\n\tvar lineStr, nameStr string\n\tsc := bufio.NewScanner(r)\n\tfor sc.Scan() {\n\t\tlineStr = sc.Text()\n\t\tlineStr = strings.TrimSpace(lineStr)\n\t\tif len(lineStr) > 0 {\n\t\t\t_, err = fmt.Sscanf(lineStr, \"!%2X U+%4X %s\", &cPos, &uPos, &nameStr)\n\t\t\tif err == nil {\n\t\t\t\tif cPos >= 0x80 {\n\t\t\t\t\tm[rune(uPos)] = byte(cPos)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif err == nil {\n\t\tf = repClosure(m)\n\t} else {\n\t\tf = doNothing\n\t}\n\treturn\n}\n\n// UnicodeTranslatorFromFile returns a function that can be used to translate,\n// where possible, utf-8 strings to a form that is compatible with the\n// specified code page. See UnicodeTranslator for more details.\n//\n// fileStr identifies a font descriptor file that maps glyph positions to names.\n//\n// If an error occurs reading the file, the returned function is valid but does\n// not perform any rune translation.\nfunc UnicodeTranslatorFromFile(fileStr string) (f func(string) string, err error) {\n\tvar fl *os.File\n\tfl, err = os.Open(fileStr)\n\tif err == nil {\n\t\tf, err = UnicodeTranslator(fl)\n\t\tfl.Close()\n\t} else {\n\t\tf = doNothing\n\t}\n\treturn\n}\n\n// UnicodeTranslatorFromDescriptor returns a function that can be used to\n// translate, where possible, utf-8 strings to a form that is compatible with\n// the specified code page. See UnicodeTranslator for more details.\n//\n// cpStr identifies a code page. A descriptor file in the font directory, set\n// with the fontDirStr argument in the call to New(), should have this name\n// plus the extension \".map\". If cpStr is empty, it will be replaced with\n// \"cp1252\", the gofpdf code page default.\n//\n// If an error occurs reading the descriptor, the returned function is valid\n// but does not perform any rune translation.\n//\n// The CellFormat_codepage example demonstrates this method.\nfunc (f *Fpdf) UnicodeTranslatorFromDescriptor(cpStr string) (rep func(string) string) {\n\tvar str string\n\tvar ok bool\n\tif f.err == nil {\n\t\tif len(cpStr) == 0 {\n\t\t\tcpStr = \"cp1252\"\n\t\t}\n\t\tstr, ok = embeddedMapList[cpStr]\n\t\tif ok {\n\t\t\trep, f.err = UnicodeTranslator(strings.NewReader(str))\n\t\t} else {\n\t\t\trep, f.err = UnicodeTranslatorFromFile(filepath.Join(f.fontpath, cpStr) + \".map\")\n\t\t}\n\t} else {\n\t\trep = doNothing\n\t}\n\treturn\n}\n\n// Transform moves a point by given X, Y offset\nfunc (p *PointType) Transform(x, y float64) PointType {\n\treturn PointType{p.X + x, p.Y + y}\n}\n\n// Orientation returns the orientation of a given size:\n// \"P\" for portrait, \"L\" for landscape\nfunc (s *SizeType) Orientation() string {\n\tif s == nil || s.Ht == s.Wd {\n\t\treturn \"\"\n\t}\n\tif s.Wd > s.Ht {\n\t\treturn \"L\"\n\t}\n\treturn \"P\"\n}\n\n// ScaleBy expands a size by a certain factor\nfunc (s *SizeType) ScaleBy(factor float64) SizeType {\n\treturn SizeType{s.Wd * factor, s.Ht * factor}\n}\n\n// ScaleToWidth adjusts the height of a size to match the given width\nfunc (s *SizeType) ScaleToWidth(width float64) SizeType {\n\theight := s.Ht * width / s.Wd\n\treturn SizeType{width, height}\n}\n\n// ScaleToHeight adjusts the width of a size to match the given height\nfunc (s *SizeType) ScaleToHeight(height float64) SizeType {\n\twidth := s.Wd * height / s.Ht\n\treturn SizeType{width, height}\n}\n\n//The untypedKeyMap structure and its methods are copyrighted 2019 by Arteom Korotkiy (Gmail: arteomkorotkiy).\n//Imitation of untyped Map Array\ntype untypedKeyMap struct {\n\tkeySet   []interface{}\n\tvalueSet []int\n}\n\n//Get position of key=>value in PHP Array\nfunc (pa *untypedKeyMap) getIndex(key interface{}) int {\n\tif key != nil {\n\t\tfor i, mKey := range pa.keySet {\n\t\t\tif mKey == key {\n\t\t\t\treturn i\n\t\t\t}\n\t\t}\n\t\treturn -1\n\t}\n\treturn -1\n}\n\n//Put key=>value in PHP Array\nfunc (pa *untypedKeyMap) put(key interface{}, value int) {\n\tif key == nil {\n\t\tvar i int\n\t\tfor n := 0; ; n++ {\n\t\t\ti = pa.getIndex(n)\n\t\t\tif i < 0 {\n\t\t\t\tkey = n\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tpa.keySet = append(pa.keySet, key)\n\t\tpa.valueSet = append(pa.valueSet, value)\n\t} else {\n\t\ti := pa.getIndex(key)\n\t\tif i < 0 {\n\t\t\tpa.keySet = append(pa.keySet, key)\n\t\t\tpa.valueSet = append(pa.valueSet, value)\n\t\t} else {\n\t\t\tpa.valueSet[i] = value\n\t\t}\n\t}\n}\n\n//Delete value in PHP Array\nfunc (pa *untypedKeyMap) delete(key interface{}) {\n\tif pa == nil || pa.keySet == nil || pa.valueSet == nil {\n\t\treturn\n\t}\n\ti := pa.getIndex(key)\n\tif i >= 0 {\n\t\tif i == 0 {\n\t\t\tpa.keySet = pa.keySet[1:]\n\t\t\tpa.valueSet = pa.valueSet[1:]\n\t\t} else if i == len(pa.keySet)-1 {\n\t\t\tpa.keySet = pa.keySet[:len(pa.keySet)-1]\n\t\t\tpa.valueSet = pa.valueSet[:len(pa.valueSet)-1]\n\t\t} else {\n\t\t\tpa.keySet = append(pa.keySet[:i], pa.keySet[i+1:]...)\n\t\t\tpa.valueSet = append(pa.valueSet[:i], pa.valueSet[i+1:]...)\n\t\t}\n\t}\n}\n\n//Get value from PHP Array\nfunc (pa *untypedKeyMap) get(key interface{}) int {\n\ti := pa.getIndex(key)\n\tif i >= 0 {\n\t\treturn pa.valueSet[i]\n\t}\n\treturn 0\n}\n\n//Imitation of PHP function pop()\nfunc (pa *untypedKeyMap) pop() {\n\tpa.keySet = pa.keySet[:len(pa.keySet)-1]\n\tpa.valueSet = pa.valueSet[:len(pa.valueSet)-1]\n}\n\n//Imitation of PHP function array_merge()\nfunc arrayMerge(arr1, arr2 *untypedKeyMap) *untypedKeyMap {\n\tanswer := untypedKeyMap{}\n\tif arr1 == nil && arr2 == nil {\n\t\tanswer = untypedKeyMap{\n\t\t\tmake([]interface{}, 0),\n\t\t\tmake([]int, 0),\n\t\t}\n\t} else if arr2 == nil {\n\t\tanswer.keySet = arr1.keySet[:]\n\t\tanswer.valueSet = arr1.valueSet[:]\n\t} else if arr1 == nil {\n\t\tanswer.keySet = arr2.keySet[:]\n\t\tanswer.valueSet = arr2.valueSet[:]\n\t} else {\n\t\tanswer.keySet = arr1.keySet[:]\n\t\tanswer.valueSet = arr1.valueSet[:]\n\t\tfor i := 0; i < len(arr2.keySet); i++ {\n\t\t\tif arr2.keySet[i] == \"interval\" {\n\t\t\t\tif arr1.getIndex(\"interval\") < 0 {\n\t\t\t\t\tanswer.put(\"interval\", arr2.valueSet[i])\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tanswer.put(nil, arr2.valueSet[i])\n\t\t\t}\n\t\t}\n\t}\n\treturn &answer\n}\n\nfunc remove(arr []int, key int) []int {\n\tn := 0\n\tfor i, mKey := range arr {\n\t\tif mKey == key {\n\t\t\tn = i\n\t\t}\n\t}\n\tif n == 0 {\n\t\treturn arr[1:]\n\t} else if n == len(arr)-1 {\n\t\treturn arr[:len(arr)-1]\n\t}\n\treturn append(arr[:n], arr[n+1:]...)\n}\n\nfunc isChinese(rune2 rune) bool {\n\t// chinese unicode: 4e00-9fa5\n\tif rune2 >= rune(0x4e00) && rune2 <= rune(0x9fa5) {\n\t\treturn true\n\t}\n\treturn false\n}\n\n// Condition font family string to PDF name compliance. See section 5.3 (Names)\n// in https://resources.infosecinstitute.com/pdf-file-format-basic-structure/\nfunc fontFamilyEscape(familyStr string) (escStr string) {\n\tescStr = strings.Replace(familyStr, \" \", \"#20\", -1)\n\t// Additional replacements can take place here\n\treturn\n}\n"
        }
      ]
    }
  ]
}