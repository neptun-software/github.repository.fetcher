{
  "metadata": {
    "timestamp": 1736567165463,
    "page": 759,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjc2MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "mattn/goreman",
      "stars": 2519,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.0205078125,
          "content": "/goreman\n/goxz\n*.exe\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.0498046875,
          "content": "MIT License\n\nCopyright (c) 2018 Yasuhiro MATSUMOTO\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n"
        },
        {
          "name": "Makefile",
          "type": "blob",
          "size": 1.2607421875,
          "content": "BIN := goreman\nVERSION := $$(make -s show-version)\nCURRENT_REVISION := $(shell git rev-parse --short HEAD)\nBUILD_LDFLAGS := \"-s -w -X main.revision=$(CURRENT_REVISION)\"\nGOBIN ?= $(shell go env GOPATH)/bin\nexport GO111MODULE=on\n\n.PHONY: all\nall: clean build\n\n.PHONY: build\nbuild:\n\tgo build -ldflags=$(BUILD_LDFLAGS) -o $(BIN) .\n\n.PHONY: install\ninstall:\n\tgo install -ldflags=$(BUILD_LDFLAGS) .\n\n.PHONY: show-version\nshow-version: $(GOBIN)/gobump\n\tgobump show -r .\n\n$(GOBIN)/gobump:\n\tgo install github.com/x-motemen/gobump/cmd/gobump@latest\n\n.PHONY: cross\ncross: $(GOBIN)/goxz\n\tgoxz -n $(BIN) -pv=v$(VERSION) -build-ldflags=$(BUILD_LDFLAGS) .\n\n$(GOBIN)/goxz:\n\tgo install github.com/Songmu/goxz/cmd/goxz@latest\n\n.PHONY: test\ntest: build\n\tgo test -v ./...\n\n.PHONY: clean\nclean:\n\trm -rf $(BIN) goxz\n\tgo clean\n\n.PHONY: bump\nbump: $(GOBIN)/gobump\nifneq ($(shell git status --porcelain),)\n\t$(error git workspace is dirty)\nendif\nifneq ($(shell git rev-parse --abbrev-ref HEAD),master)\n\t$(error current branch is not master)\nendif\n\t@gobump up -w .\n\tgit commit -am \"bump up version to $(VERSION)\"\n\tgit tag \"v$(VERSION)\"\n\tgit push origin master\n\tgit push origin \"refs/tags/v$(VERSION)\"\n\n.PHONY: upload\nupload: $(GOBIN)/ghr\n\tghr \"v$(VERSION)\" goxz\n\n$(GOBIN)/ghr:\n\tgo install github.com/tcnksm/ghr@latest\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 0.8134765625,
          "content": "# Goreman\n\nClone of foreman written in golang.\n\nhttps://github.com/ddollar/foreman\n\n## Getting Started\n\n    go install github.com/mattn/goreman@latest\n\n## Usage\n\n    goreman start\n\nWill start all commands defined in the `Procfile` and display their outputs.\nAny signals are forwarded to each process.\n\n## Example\n\nSee [`_example`](_example/) directory\n\n## License\n\nMIT\n\n## Design\n\nThe main goroutine loads `Procfile` and starts each command in the file. Afterwards, it is driven by the following two kinds of events, and then take proper action against the managed processes.\n\n1. It receives a signal, which could be one of `SIGINT`, `SIGTERM`, and `SIGHUP`;\n2. It receives an RPC call, which is triggered by the command `goreman run COMMAND [PROCESS...]`.\n\n![design](images/design.png)\n\n## Authors\n\nYasuhiro Matsumoto (a.k.a mattn)\n"
        },
        {
          "name": "_example",
          "type": "tree",
          "content": null
        },
        {
          "name": "export.go",
          "type": "blob",
          "size": 1.6318359375,
          "content": "package main\n\nimport (\n\t\"fmt\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"strings\"\n)\n\nfunc exportUpstart(cfg *config, path string) error {\n\tfor i, proc := range procs {\n\t\tf, err := os.Create(filepath.Join(path, \"app-\"+proc.name+\".conf\"))\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tfmt.Fprintf(f, \"start on starting app-%s\\n\", proc.name)\n\t\tfmt.Fprintf(f, \"stop on stopping app-%s\\n\", proc.name)\n\t\tfmt.Fprintf(f, \"respawn\\n\")\n\t\tfmt.Fprintf(f, \"\\n\")\n\n\t\tenv := map[string]string{}\n\t\tprocfile, err := filepath.Abs(cfg.Procfile)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tb, err := os.ReadFile(filepath.Join(filepath.Dir(procfile), \".env\"))\n\t\tif err == nil {\n\t\t\tfor _, line := range strings.Split(string(b), \"\\n\") {\n\t\t\t\ttoken := strings.SplitN(line, \"=\", 2)\n\t\t\t\tif len(token) != 2 {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\tif strings.HasPrefix(token[0], \"export \") {\n\t\t\t\t\ttoken[0] = token[0][7:]\n\t\t\t\t}\n\t\t\t\ttoken[0] = strings.TrimSpace(token[0])\n\t\t\t\ttoken[1] = strings.TrimSpace(token[1])\n\t\t\t\tenv[token[0]] = token[1]\n\t\t\t}\n\t\t}\n\n\t\tfmt.Fprintf(f, \"env PORT=%d\\n\", cfg.BasePort+uint(i))\n\t\tfor k, v := range env {\n\t\t\tfmt.Fprintf(f, \"env %s='%s'\\n\", k, strings.Replace(v, \"'\", \"\\\\'\", -1))\n\t\t}\n\t\tfmt.Fprintf(f, \"\\n\")\n\t\tfmt.Fprintf(f, \"setuid app\\n\")\n\t\tfmt.Fprintf(f, \"\\n\")\n\t\tfmt.Fprintf(f, \"chdir %s\\n\", filepath.ToSlash(filepath.Dir(procfile)))\n\t\tfmt.Fprintf(f, \"\\n\")\n\t\tfmt.Fprintf(f, \"exec %s\\n\", proc.cmdline)\n\n\t\tf.Close()\n\t}\n\treturn nil\n}\n\n// command: export.\nfunc export(cfg *config, format, path string) error {\n\terr := readProcfile(cfg)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\terr = os.MkdirAll(path, 0755)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tswitch format {\n\tcase \"upstart\":\n\t\treturn exportUpstart(cfg, path)\n\t}\n\treturn nil\n}\n"
        },
        {
          "name": "go.mod",
          "type": "blob",
          "size": 0.2275390625,
          "content": "module github.com/mattn/goreman\n\ngo 1.23\n\nrequire (\n\tgithub.com/joho/godotenv v1.5.1\n\tgithub.com/mattn/go-colorable v0.1.13\n\tgolang.org/x/sys v0.27.0\n\tgopkg.in/yaml.v3 v3.0.1\n)\n\nrequire github.com/mattn/go-isatty v0.0.20 // indirect\n"
        },
        {
          "name": "go.sum",
          "type": "blob",
          "size": 1.27734375,
          "content": "github.com/joho/godotenv v1.5.1 h1:7eLL/+HRGLY0ldzfGMeQkb7vMd0as4CfYvUVzLqw0N0=\ngithub.com/joho/godotenv v1.5.1/go.mod h1:f4LDr5Voq0i2e/R5DDNOoa2zzDfwtkZa6DnEwAbqwq4=\ngithub.com/mattn/go-colorable v0.1.13 h1:fFA4WZxdEF4tXPZVKMLwD8oUnCTTo08duU7wxecdEvA=\ngithub.com/mattn/go-colorable v0.1.13/go.mod h1:7S9/ev0klgBDR4GtXTXX8a3vIGJpMovkB8vQcUbaXHg=\ngithub.com/mattn/go-isatty v0.0.16/go.mod h1:kYGgaQfpe5nmfYZH+SKPsOc2e4SrIfOl2e/yFXSvRLM=\ngithub.com/mattn/go-isatty v0.0.20 h1:xfD0iDuEKnDkl03q4limB+vH+GxLEtL/jb4xVJSWWEY=\ngithub.com/mattn/go-isatty v0.0.20/go.mod h1:W+V8PltTTMOvKvAeJH7IuucS94S2C6jfK/D7dTCTo3Y=\ngolang.org/x/sys v0.0.0-20220811171246-fbc7d0a398ab/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\ngolang.org/x/sys v0.6.0/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\ngolang.org/x/sys v0.27.0 h1:wBqf8DvsY9Y/2P8gAfPDEYNuS30J4lPHJxXSb/nJZ+s=\ngolang.org/x/sys v0.27.0/go.mod h1:/VUhepiaJMQUp4+oa/7Zr1D23ma6VTLIYjOOTFZPUcA=\ngopkg.in/check.v1 v0.0.0-20161208181325-20d25e280405 h1:yhCVgyC4o1eVCa2tZl7eS0r+SDo693bJlVdllGtEeKM=\ngopkg.in/check.v1 v0.0.0-20161208181325-20d25e280405/go.mod h1:Co6ibVJAznAaIkqp8huTwlJQCZ016jof/cbN4VW5Yz0=\ngopkg.in/yaml.v3 v3.0.1 h1:fxVm/GzAzEWqLHuvctI91KS9hhNmmWOoWu0XTYJS7CA=\ngopkg.in/yaml.v3 v3.0.1/go.mod h1:K4uyk7z7BCEPqu6E+C64Yfv1cQ7kz7rIZviUmN+EgEM=\n"
        },
        {
          "name": "goreman_test.go",
          "type": "blob",
          "size": 3.9638671875,
          "content": "package main\n\nimport (\n\t\"context\"\n\t\"os\"\n\t\"os/exec\"\n\t\"path/filepath\"\n\t\"runtime\"\n\t\"testing\"\n\t\"time\"\n)\n\nvar sleep string\n\nfunc TestMain(m *testing.M) {\n\tvar dir string\n\tvar err error\n\tsleep, err = exec.LookPath(\"sleep\")\n\tif err != nil {\n\t\tif runtime.GOOS != \"windows\" {\n\t\t\tpanic(err)\n\t\t}\n\n\t\tcode := `package main;import (\"os\";\"strconv\";\"time\");func main(){i,_:=strconv.ParseFloat(os.Args[1]);time.Sleep(time.Duration(i)*time.Second)}`\n\t\tdir, err := os.MkdirTemp(\"\", \"goreman-test\")\n\t\tif err != nil {\n\t\t\tpanic(err)\n\t\t}\n\t\tsleep = filepath.Join(dir, \"sleep.exe\")\n\t\tsrc := filepath.Join(dir, \"sleep.go\")\n\t\terr = os.WriteFile(src, []byte(code), 0644)\n\t\tif err != nil {\n\t\t\tpanic(err)\n\t\t}\n\t\tb, err := exec.Command(\"go\", \"build\", \"-o\", sleep, src).CombinedOutput()\n\t\tif err != nil {\n\t\t\tpanic(string(b))\n\t\t}\n\t\toldpath := os.Getenv(\"PATH\")\n\t\tos.Setenv(\"PATH\", dir+\";\"+oldpath)\n\t\tdefer os.Setenv(\"PATH\", oldpath)\n\t}\n\tr := m.Run()\n\n\tif dir != \"\" {\n\t\tos.RemoveAll(dir)\n\t}\n\tos.Exit(r)\n}\n\nfunc startGoreman(ctx context.Context, t *testing.T, ch <-chan os.Signal, file []byte) error {\n\tt.Helper()\n\tf, err := os.CreateTemp(\"\", \"\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif _, err := f.Write(file); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tcfg := &config{\n\t\tExitOnError: true,\n\t\tProcfile:    f.Name(),\n\t}\n\tif ch == nil {\n\t\tch = notifyCh()\n\t}\n\treturn start(ctx, ch, cfg)\n}\n\nfunc TestGoreman(t *testing.T) {\n\tvar file = []byte(`\nweb1: sleep 0.1\nweb2: sleep 0.1\nweb3: sleep 0.1\nweb4: sleep 0.1\n`)\n\tif err := startGoreman(context.TODO(), t, nil, file); err != nil {\n\t\tt.Fatal(err)\n\t}\n}\n\nfunc TestGoremanSignal(t *testing.T) {\n\tvar file = []byte(`\nweb1: sleep 10\nweb2: sleep 10\nweb3: sleep 10\nweb4: sleep 10\n`)\n\tnow := time.Now()\n\tsc := make(chan os.Signal, 1)\n\tgo func() {\n\t\ttime.Sleep(100 * time.Millisecond)\n\t\tsc <- os.Interrupt\n\t}()\n\tif err := startGoreman(context.TODO(), t, sc, file); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif dur := time.Since(now); dur > 500*time.Millisecond {\n\t\tt.Errorf(\"test took too much time; should have canceled after about 10ms, got %s\", dur)\n\t}\n}\n\nfunc TestGoremanExitsOnError(t *testing.T) {\n\tvar file = []byte(`\nweb1: sleep 10\nweb2: sleep 0.01 && foobarbangbazunknownproc\nweb3: sleep 10\nweb4: sleep 10\n`)\n\tnow := time.Now()\n\t// process 2 should exit which should trigger exit of entire program.\n\tif err := startGoreman(context.TODO(), t, nil, file); err == nil {\n\t\tt.Fatal(\"got nil err, should have received error\")\n\t}\n\tif dur := time.Since(now); dur > time.Second {\n\t\tt.Errorf(\"test took too much time; should have canceled after 1s, got %s\", dur)\n\t}\n}\n\nfunc TestGoremanExitsOnErrorOtherWay(t *testing.T) {\n\tvar file = []byte(`\nweb1: sleep 10\nweb2: sleep 0.01 && exit 2\nweb3: sleep 10\nweb4: sleep 10\n`)\n\t// process 2 should exit which should trigger exit of entire program.\n\tnow := time.Now()\n\tif err := startGoreman(context.TODO(), t, nil, file); err == nil {\n\t\tt.Fatal(\"got nil err, should have received error\")\n\t}\n\tif dur := time.Since(now); dur > time.Second {\n\t\tt.Errorf(\"test took too much time; should have canceled after 1s, got %s\", dur)\n\t}\n}\n\nfunc TestGoremanStopProcDoesntStopOtherProcs(t *testing.T) {\n\tvar file = []byte(`\nweb1: sleep 10\nweb2: sleep 10\nweb3: sleep 10\nweb4: sleep 10\n`)\n\tgoremanStopped := make(chan struct{}, 1)\n\tsc := make(chan os.Signal, 1)\n\tgo func() {\n\t\tstartGoreman(context.TODO(), t, sc, file)\n\t\tgoremanStopped <- struct{}{}\n\t}()\n\tfor {\n\t\tmu.Lock()\n\t\tisEmpty := procs == nil\n\t\tmu.Unlock()\n\t\tif isEmpty {\n\t\t\ttime.Sleep(5 * time.Millisecond)\n\t\t\tcontinue\n\t\t}\n\t\tproc := findProc(\"web2\")\n\t\tif proc == nil {\n\t\t\ttime.Sleep(5 * time.Millisecond)\n\t\t\tcontinue\n\t\t}\n\t\tproc.mu.Lock()\n\t\tcmd := proc.cmd\n\t\tproc.mu.Unlock()\n\t\tif cmd == nil || cmd.Process == nil {\n\t\t\ttime.Sleep(5 * time.Millisecond)\n\t\t\tcontinue\n\t\t}\n\t\t// call Sleep that shell will start sleep command\n\t\ttime.Sleep(time.Second)\n\t\tif err := stopProc(\"web2\", nil); err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tbreak\n\t}\n\tselect {\n\tcase <-goremanStopped:\n\t\tt.Errorf(\"stopping web2 subprocess should not have stopped supervisor\")\n\tcase <-time.After(30 * time.Millisecond):\n\t}\n\tsc <- os.Interrupt\n}\n"
        },
        {
          "name": "images",
          "type": "tree",
          "content": null
        },
        {
          "name": "log.go",
          "type": "blob",
          "size": 2.7080078125,
          "content": "package main\n\nimport (\n\t\"bytes\"\n\t\"fmt\"\n\t\"io\"\n\t\"sync\"\n\t\"time\"\n\n\t\"github.com/mattn/go-colorable\"\n)\n\ntype clogger struct {\n\tidx     int\n\tname    string\n\twrites  chan []byte\n\tdone    chan struct{}\n\ttimeout time.Duration // how long to wait before printing partial lines\n\tbuffers buffers       // partial lines awaiting printing\n}\n\nvar colors = []int{\n\t32, // green\n\t36, // cyan\n\t35, // magenta\n\t33, // yellow\n\t34, // blue\n\t31, // red\n}\nvar mutex = new(sync.Mutex)\n\nvar out = colorable.NewColorableStdout()\n\ntype buffers [][]byte\n\nfunc (v *buffers) consume(n int64) {\n\tfor len(*v) > 0 {\n\t\tln0 := int64(len((*v)[0]))\n\t\tif ln0 > n {\n\t\t\t(*v)[0] = (*v)[0][n:]\n\t\t\treturn\n\t\t}\n\t\tn -= ln0\n\t\t*v = (*v)[1:]\n\t}\n}\n\nfunc (v *buffers) WriteTo(w io.Writer) (n int64, err error) {\n\tfor _, b := range *v {\n\t\tnb, err := w.Write(b)\n\t\tn += int64(nb)\n\t\tif err != nil {\n\t\t\tv.consume(n)\n\t\t\treturn n, err\n\t\t}\n\t}\n\tv.consume(n)\n\treturn n, nil\n}\n\n// write any stored buffers, plus the given line, then empty out\n// the buffers.\nfunc (l *clogger) writeBuffers(line []byte) {\n\tmutex.Lock()\n\tfmt.Fprintf(out, \"\\x1b[%dm\", colors[l.idx])\n\tif *logTime {\n\t\tnow := time.Now().Format(\"15:04:05\")\n\t\tfmt.Fprintf(out, \"%s %*s | \", now, maxProcNameLength, l.name)\n\t} else {\n\t\tfmt.Fprintf(out, \"%*s | \", maxProcNameLength, l.name)\n\t}\n\tfmt.Fprintf(out, \"\\x1b[m\")\n\tl.buffers = append(l.buffers, line)\n\tl.buffers.WriteTo(out)\n\tl.buffers = l.buffers[0:0]\n\tmutex.Unlock()\n}\n\n// bundle writes into lines, waiting briefly for completion of lines\nfunc (l *clogger) writeLines() {\n\tvar tick <-chan time.Time\n\tfor {\n\t\tselect {\n\t\tcase w, ok := <-l.writes:\n\t\t\tif !ok {\n\t\t\t\tif len(l.buffers) > 0 {\n\t\t\t\t\tl.writeBuffers([]byte(\"\\n\"))\n\t\t\t\t}\n\t\t\t\treturn\n\t\t\t}\n\t\t\tbuf := bytes.NewBuffer(w)\n\t\t\tfor {\n\t\t\t\tline, err := buf.ReadBytes('\\n')\n\t\t\t\tif len(line) > 0 {\n\t\t\t\t\tif line[len(line)-1] == '\\n' {\n\t\t\t\t\t\t// any text followed by a newline should flush\n\t\t\t\t\t\t// existing buffers. a bare newline should flush\n\t\t\t\t\t\t// existing buffers, but only if there are any.\n\t\t\t\t\t\tif len(line) != 1 || len(l.buffers) > 0 {\n\t\t\t\t\t\t\tl.writeBuffers(line)\n\t\t\t\t\t\t}\n\t\t\t\t\t\ttick = nil\n\t\t\t\t\t} else {\n\t\t\t\t\t\tl.buffers = append(l.buffers, line)\n\t\t\t\t\t\ttick = time.After(l.timeout)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif err != nil {\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t\tl.done <- struct{}{}\n\t\tcase <-tick:\n\t\t\tif len(l.buffers) > 0 {\n\t\t\t\tl.writeBuffers([]byte(\"\\n\"))\n\t\t\t}\n\t\t\ttick = nil\n\t\t}\n\t}\n\n}\n\n// write handler of logger.\nfunc (l *clogger) Write(p []byte) (int, error) {\n\tl.writes <- p\n\t<-l.done\n\treturn len(p), nil\n}\n\n// create logger instance.\nfunc createLogger(name string, colorIndex int) *clogger {\n\tmutex.Lock()\n\tdefer mutex.Unlock()\n\tl := &clogger{idx: colorIndex, name: name, writes: make(chan []byte), done: make(chan struct{}), timeout: 2 * time.Millisecond}\n\tgo l.writeLines()\n\treturn l\n}\n"
        },
        {
          "name": "main.go",
          "type": "blob",
          "size": 7.029296875,
          "content": "package main\n\nimport (\n\t\"context\"\n\t\"errors\"\n\t\"flag\"\n\t\"fmt\"\n\t\"os\"\n\t\"os/exec\"\n\t\"regexp\"\n\t\"runtime\"\n\t\"sort\"\n\t\"strconv\"\n\t\"strings\"\n\t\"sync\"\n\n\t\"github.com/joho/godotenv\"\n\t\"gopkg.in/yaml.v3\"\n)\n\n// version is the git tag at the time of build and is used to denote the\n// binary's current version. This value is supplied as an ldflag at compile\n// time by goreleaser (see .goreleaser.yml).\nconst (\n\tname     = \"goreman\"\n\tversion  = \"0.3.16\"\n\trevision = \"HEAD\"\n)\n\nfunc usage() {\n\tfmt.Fprint(os.Stderr, `Tasks:\n  goreman check                      # Show entries in Procfile\n  goreman help [TASK]                # Show this help\n  goreman export [FORMAT] [LOCATION] # Export the apps to another process\n                                       (upstart)\n  goreman run COMMAND [PROCESS...]   # Run a command\n                                       start\n                                       stop\n                                       stop-all\n                                       restart\n                                       restart-all\n                                       list\n                                       status\n  goreman start [PROCESS]            # Start the application\n  goreman version                    # Display Goreman version\n\nOptions:\n`)\n\tflag.PrintDefaults()\n\tos.Exit(0)\n}\n\n// -- process information structure.\ntype procInfo struct {\n\tname       string\n\tcmdline    string\n\tcmd        *exec.Cmd\n\tport       uint\n\tsetPort    bool\n\tcolorIndex int\n\n\t// True if we called stopProc to kill the process, in which case an\n\t// *os.ExitError is not the fault of the subprocess\n\tstoppedBySupervisor bool\n\n\tmu      sync.Mutex\n\tcond    *sync.Cond\n\twaitErr error\n}\n\nvar mu sync.Mutex\n\n// process informations named with proc.\nvar procs []*procInfo\n\n// filename of Procfile.\nvar procfile = flag.String(\"f\", \"Procfile\", \"proc file\")\n\n// rpc port number.\nvar port = flag.Uint(\"p\", defaultPort(), \"port\")\n\nvar startRPCServer = flag.Bool(\"rpc-server\", true, \"Start an RPC server listening on \"+defaultAddr())\n\n// base directory\nvar basedir = flag.String(\"basedir\", \"\", \"base directory\")\n\n// base of port numbers for app\nvar baseport = flag.Uint(\"b\", 5000, \"base number of port\")\n\nvar setPorts = flag.Bool(\"set-ports\", true, \"False to avoid setting PORT env var for each subprocess\")\n\n// true to exit the supervisor\nvar exitOnError = flag.Bool(\"exit-on-error\", false, \"Exit goreman if a subprocess quits with a nonzero return code\")\n\n// true to exit the supervisor when all processes stop\nvar exitOnStop = flag.Bool(\"exit-on-stop\", true, \"Exit goreman if all subprocesses stop\")\n\n// show timestamp in log\nvar logTime = flag.Bool(\"logtime\", true, \"show timestamp in log\")\n\nvar maxProcNameLength = 0\n\nvar re = regexp.MustCompile(`\\$([a-zA-Z]+[a-zA-Z0-9_]+)`)\n\ntype config struct {\n\tProcfile string `yaml:\"procfile\"`\n\t// Port for RPC server\n\tPort     uint   `yaml:\"port\"`\n\tBaseDir  string `yaml:\"basedir\"`\n\tBasePort uint   `yaml:\"baseport\"`\n\tArgs     []string\n\t// If true, exit the supervisor process if a subprocess exits with an error.\n\tExitOnError bool `yaml:\"exit_on_error\"`\n}\n\nfunc readConfig() *config {\n\tvar cfg config\n\n\tflag.Parse()\n\tif flag.NArg() == 0 {\n\t\tusage()\n\t}\n\n\tcfg.Procfile = *procfile\n\tcfg.Port = *port\n\tcfg.BaseDir = *basedir\n\tcfg.BasePort = *baseport\n\tcfg.ExitOnError = *exitOnError\n\tcfg.Args = flag.Args()\n\n\tb, err := os.ReadFile(\".goreman\")\n\tif err == nil {\n\t\tyaml.Unmarshal(b, &cfg)\n\t}\n\treturn &cfg\n}\n\n// read Procfile and parse it.\nfunc readProcfile(cfg *config) error {\n\tcontent, err := os.ReadFile(cfg.Procfile)\n\tif err != nil {\n\t\treturn err\n\t}\n\tmu.Lock()\n\tdefer mu.Unlock()\n\n\tprocs = []*procInfo{}\n\tindex := 0\n\tfor _, line := range strings.Split(string(content), \"\\n\") {\n\t\ttokens := strings.SplitN(line, \":\", 2)\n\t\tif len(tokens) != 2 || tokens[0][0] == '#' {\n\t\t\tcontinue\n\t\t}\n\t\tk, v := strings.TrimSpace(tokens[0]), strings.TrimSpace(tokens[1])\n\t\tif runtime.GOOS == \"windows\" {\n\t\t\tv = re.ReplaceAllStringFunc(v, func(s string) string {\n\t\t\t\treturn \"%\" + s[1:] + \"%\"\n\t\t\t})\n\t\t}\n\t\tproc := &procInfo{name: k, cmdline: v, colorIndex: index}\n\t\tif *setPorts {\n\t\t\tproc.setPort = true\n\t\t\tproc.port = cfg.BasePort\n\t\t\tcfg.BasePort += 100\n\t\t}\n\t\tproc.cond = sync.NewCond(&proc.mu)\n\t\tprocs = append(procs, proc)\n\t\tif len(k) > maxProcNameLength {\n\t\t\tmaxProcNameLength = len(k)\n\t\t}\n\t\tindex = (index + 1) % len(colors)\n\t}\n\tif len(procs) == 0 {\n\t\treturn errors.New(\"no valid entry\")\n\t}\n\treturn nil\n}\n\nfunc defaultServer(serverPort uint) string {\n\tif s, ok := os.LookupEnv(\"GOREMAN_RPC_SERVER\"); ok {\n\t\treturn s\n\t}\n\treturn fmt.Sprintf(\"127.0.0.1:%d\", defaultPort())\n}\n\nfunc defaultAddr() string {\n\tif s, ok := os.LookupEnv(\"GOREMAN_RPC_ADDR\"); ok {\n\t\treturn s\n\t}\n\treturn \"0.0.0.0\"\n}\n\n// default port\nfunc defaultPort() uint {\n\ts := os.Getenv(\"GOREMAN_RPC_PORT\")\n\tif s != \"\" {\n\t\ti, err := strconv.Atoi(s)\n\t\tif err == nil {\n\t\t\treturn uint(i)\n\t\t}\n\t}\n\treturn 8555\n}\n\n// command: check. show Procfile entries.\nfunc check(cfg *config) error {\n\terr := readProcfile(cfg)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tmu.Lock()\n\tdefer mu.Unlock()\n\n\tkeys := make([]string, len(procs))\n\ti := 0\n\tfor _, proc := range procs {\n\t\tkeys[i] = proc.name\n\t\ti++\n\t}\n\tsort.Strings(keys)\n\tfmt.Printf(\"valid procfile detected (%s)\\n\", strings.Join(keys, \", \"))\n\treturn nil\n}\n\nfunc findProc(name string) *procInfo {\n\tmu.Lock()\n\tdefer mu.Unlock()\n\n\tfor _, proc := range procs {\n\t\tif proc.name == name {\n\t\t\treturn proc\n\t\t}\n\t}\n\treturn nil\n}\n\n// command: start. spawn procs.\nfunc start(ctx context.Context, sig <-chan os.Signal, cfg *config) error {\n\terr := readProcfile(cfg)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tctx, cancel := context.WithCancel(ctx)\n\t// Cancel the RPC server when procs have returned/errored, cancel the\n\t// context anyway in case of early return.\n\tdefer cancel()\n\tif len(cfg.Args) > 1 {\n\t\ttmp := make([]*procInfo, 0, len(cfg.Args[1:]))\n\t\tmaxProcNameLength = 0\n\t\tfor _, v := range cfg.Args[1:] {\n\t\t\tproc := findProc(v)\n\t\t\tif proc == nil {\n\t\t\t\treturn errors.New(\"unknown proc: \" + v)\n\t\t\t}\n\t\t\ttmp = append(tmp, proc)\n\t\t\tif len(v) > maxProcNameLength {\n\t\t\t\tmaxProcNameLength = len(v)\n\t\t\t}\n\t\t}\n\t\tmu.Lock()\n\t\tprocs = tmp\n\t\tmu.Unlock()\n\t}\n\tgodotenv.Load()\n\trpcChan := make(chan *rpcMessage, 10)\n\tif *startRPCServer {\n\t\tgo startServer(ctx, rpcChan, cfg.Port)\n\t}\n\tprocsErr := startProcs(sig, rpcChan, cfg.ExitOnError)\n\treturn procsErr\n}\n\nfunc showVersion() {\n\tfmt.Fprintf(os.Stdout, \"%s\\n\", version)\n\tos.Exit(0)\n}\n\nfunc main() {\n\tvar err error\n\tcfg := readConfig()\n\n\tif cfg.BaseDir != \"\" {\n\t\terr = os.Chdir(cfg.BaseDir)\n\t\tif err != nil {\n\t\t\tfmt.Fprintf(os.Stderr, \"goreman: %s\\n\", err.Error())\n\t\t\tos.Exit(1)\n\t\t}\n\t}\n\n\tcmd := cfg.Args[0]\n\tswitch cmd {\n\tcase \"check\":\n\t\terr = check(cfg)\n\tcase \"help\":\n\t\tusage()\n\tcase \"run\":\n\t\tif len(cfg.Args) >= 2 {\n\t\t\tcmd, args := cfg.Args[1], cfg.Args[2:]\n\t\t\terr = run(cmd, args, cfg.Port)\n\t\t} else {\n\t\t\tusage()\n\t\t}\n\tcase \"export\":\n\t\tif len(cfg.Args) == 3 {\n\t\t\tformat, path := cfg.Args[1], cfg.Args[2]\n\t\t\terr = export(cfg, format, path)\n\t\t} else {\n\t\t\tusage()\n\t\t}\n\tcase \"start\":\n\t\tc := notifyCh()\n\t\terr = start(context.Background(), c, cfg)\n\tcase \"version\":\n\t\tshowVersion()\n\tdefault:\n\t\tusage()\n\t}\n\n\tif err != nil {\n\t\tfmt.Fprintf(os.Stderr, \"%s: %v\\n\", os.Args[0], err.Error())\n\t\tos.Exit(1)\n\t}\n}\n"
        },
        {
          "name": "proc.go",
          "type": "blob",
          "size": 3.5732421875,
          "content": "package main\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"os\"\n\t\"os/exec\"\n\t\"sync\"\n\t\"time\"\n)\n\n// spawnProc starts the specified proc, and returns any error from running it.\nfunc spawnProc(name string, errCh chan<- error) {\n\tproc := findProc(name)\n\tlogger := createLogger(name, proc.colorIndex)\n\n\tcs := append(cmdStart, proc.cmdline)\n\tcmd := exec.Command(cs[0], cs[1:]...)\n\tcmd.Stdin = nil\n\tcmd.Stdout = logger\n\tcmd.Stderr = logger\n\tcmd.SysProcAttr = procAttrs\n\n\tif proc.setPort {\n\t\tcmd.Env = append(os.Environ(), fmt.Sprintf(\"PORT=%d\", proc.port))\n\t\tfmt.Fprintf(logger, \"Starting %s on port %d\\n\", name, proc.port)\n\t}\n\tif err := cmd.Start(); err != nil {\n\t\tselect {\n\t\tcase errCh <- err:\n\t\tdefault:\n\t\t}\n\t\tfmt.Fprintf(logger, \"Failed to start %s: %s\\n\", name, err)\n\t\treturn\n\t}\n\tproc.cmd = cmd\n\tproc.stoppedBySupervisor = false\n\tproc.mu.Unlock()\n\terr := cmd.Wait()\n\tproc.mu.Lock()\n\tproc.cond.Broadcast()\n\tif err != nil && !proc.stoppedBySupervisor {\n\t\tselect {\n\t\tcase errCh <- err:\n\t\tdefault:\n\t\t}\n\t}\n\tproc.waitErr = err\n\tproc.cmd = nil\n\tfmt.Fprintf(logger, \"Terminating %s\\n\", name)\n}\n\n// Stop the specified proc, issuing os.Kill if it does not terminate within 10\n// seconds. If signal is nil, os.Interrupt is used.\nfunc stopProc(name string, signal os.Signal) error {\n\tif signal == nil {\n\t\tsignal = os.Interrupt\n\t}\n\tproc := findProc(name)\n\tif proc == nil {\n\t\treturn errors.New(\"unknown proc: \" + name)\n\t}\n\n\tproc.mu.Lock()\n\tdefer proc.mu.Unlock()\n\n\tif proc.cmd == nil {\n\t\treturn nil\n\t}\n\tproc.stoppedBySupervisor = true\n\n\terr := terminateProc(proc, signal)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\ttimeout := time.AfterFunc(10*time.Second, func() {\n\t\tproc.mu.Lock()\n\t\tdefer proc.mu.Unlock()\n\t\tif proc.cmd != nil {\n\t\t\terr = killProc(proc.cmd.Process)\n\t\t}\n\t})\n\tproc.cond.Wait()\n\ttimeout.Stop()\n\treturn err\n}\n\n// start specified proc. if proc is started already, return nil.\nfunc startProc(name string, wg *sync.WaitGroup, errCh chan<- error) error {\n\tproc := findProc(name)\n\tif proc == nil {\n\t\treturn errors.New(\"unknown name: \" + name)\n\t}\n\n\tproc.mu.Lock()\n\tif proc.cmd != nil {\n\t\tproc.mu.Unlock()\n\t\treturn nil\n\t}\n\n\tif wg != nil {\n\t\twg.Add(1)\n\t}\n\tgo func() {\n\t\tspawnProc(name, errCh)\n\t\tif wg != nil {\n\t\t\twg.Done()\n\t\t}\n\t\tproc.mu.Unlock()\n\t}()\n\treturn nil\n}\n\n// restart specified proc.\nfunc restartProc(name string) error {\n\terr := stopProc(name, nil)\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn startProc(name, nil, nil)\n}\n\n// stopProcs attempts to stop every running process and returns any non-nil\n// error, if one exists. stopProcs will wait until all procs have had an\n// opportunity to stop.\nfunc stopProcs(sig os.Signal) error {\n\tvar err error\n\tfor _, proc := range procs {\n\t\tstopErr := stopProc(proc.name, sig)\n\t\tif stopErr != nil {\n\t\t\terr = stopErr\n\t\t}\n\t}\n\treturn err\n}\n\n// spawn all procs.\nfunc startProcs(sc <-chan os.Signal, rpcCh <-chan *rpcMessage, exitOnError bool) error {\n\tvar wg sync.WaitGroup\n\terrCh := make(chan error, 1)\n\n\tfor _, proc := range procs {\n\t\tstartProc(proc.name, &wg, errCh)\n\t}\n\n\tallProcsDone := make(chan struct{}, 1)\n\tif *exitOnStop {\n\t\tgo func() {\n\t\t\twg.Wait()\n\t\t\tallProcsDone <- struct{}{}\n\t\t}()\n\t}\n\tfor {\n\t\tselect {\n\t\tcase rpcMsg := <-rpcCh:\n\t\t\tswitch rpcMsg.Msg {\n\t\t\t// TODO: add more events here.\n\t\t\tcase \"stop\":\n\t\t\t\tfor _, proc := range rpcMsg.Args {\n\t\t\t\t\tif err := stopProc(proc, nil); err != nil {\n\t\t\t\t\t\trpcMsg.ErrCh <- err\n\t\t\t\t\t\tbreak\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tclose(rpcMsg.ErrCh)\n\t\t\tdefault:\n\t\t\t\tpanic(\"unimplemented rpc message type \" + rpcMsg.Msg)\n\t\t\t}\n\t\tcase err := <-errCh:\n\t\t\tif exitOnError {\n\t\t\t\tstopProcs(os.Interrupt)\n\t\t\t\treturn err\n\t\t\t}\n\t\tcase <-allProcsDone:\n\t\t\treturn stopProcs(os.Interrupt)\n\t\tcase sig := <-sc:\n\t\t\treturn stopProcs(sig)\n\t\t}\n\t}\n}\n"
        },
        {
          "name": "proc_posix.go",
          "type": "blob",
          "size": 0.97265625,
          "content": "//go:build !windows\n// +build !windows\n\npackage main\n\nimport (\n\t\"os\"\n\t\"os/signal\"\n\n\t\"golang.org/x/sys/unix\"\n)\n\nconst sigint = unix.SIGINT\nconst sigterm = unix.SIGTERM\nconst sighup = unix.SIGHUP\n\nvar cmdStart = []string{\"/bin/sh\", \"-c\"}\nvar procAttrs = &unix.SysProcAttr{Setpgid: true}\n\nfunc terminateProc(proc *procInfo, signal os.Signal) error {\n\tp := proc.cmd.Process\n\tif p == nil {\n\t\treturn nil\n\t}\n\n\tpgid, err := unix.Getpgid(p.Pid)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// use pgid, ref: http://unix.stackexchange.com/questions/14815/process-descendants\n\tpid := p.Pid\n\tif pgid == p.Pid {\n\t\tpid = -1 * pid\n\t}\n\n\ttarget, err := os.FindProcess(pid)\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn target.Signal(signal)\n}\n\n// killProc kills the proc with pid pid, as well as its children.\nfunc killProc(process *os.Process) error {\n\treturn unix.Kill(-1*process.Pid, unix.SIGKILL)\n}\n\nfunc notifyCh() <-chan os.Signal {\n\tsc := make(chan os.Signal, 10)\n\tsignal.Notify(sc, sigterm, sigint, sighup)\n\treturn sc\n}\n"
        },
        {
          "name": "proc_windows.go",
          "type": "blob",
          "size": 1.18359375,
          "content": "package main\n\nimport (\n\t\"os\"\n\t\"os/signal\"\n\t\"syscall\"\n\n\t\"golang.org/x/sys/windows\"\n)\n\nvar cmdStart = []string{\"cmd\", \"/c\"}\nvar procAttrs = &windows.SysProcAttr{\n\tCreationFlags: windows.CREATE_UNICODE_ENVIRONMENT | windows.CREATE_NEW_PROCESS_GROUP,\n}\n\nfunc terminateProc(proc *procInfo, _ os.Signal) error {\n\tdll, err := windows.LoadDLL(\"kernel32.dll\")\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer dll.Release()\n\n\tpid := proc.cmd.Process.Pid\n\n\tf, err := dll.FindProc(\"AttachConsole\")\n\tif err != nil {\n\t\treturn err\n\t}\n\tr1, _, err := f.Call(uintptr(pid))\n\tif r1 == 0 && err != syscall.ERROR_ACCESS_DENIED {\n\t\treturn err\n\t}\n\n\tf, err = dll.FindProc(\"SetConsoleCtrlHandler\")\n\tif err != nil {\n\t\treturn err\n\t}\n\tr1, _, err = f.Call(0, 1)\n\tif r1 == 0 {\n\t\treturn err\n\t}\n\tf, err = dll.FindProc(\"GenerateConsoleCtrlEvent\")\n\tif err != nil {\n\t\treturn err\n\t}\n\tr1, _, err = f.Call(windows.CTRL_BREAK_EVENT, uintptr(pid))\n\tif r1 == 0 {\n\t\treturn err\n\t}\n\tr1, _, err = f.Call(windows.CTRL_C_EVENT, uintptr(pid))\n\tif r1 == 0 {\n\t\treturn err\n\t}\n\treturn nil\n}\n\nfunc killProc(process *os.Process) error {\n\treturn process.Kill()\n}\n\nfunc notifyCh() <-chan os.Signal {\n\tsc := make(chan os.Signal, 10)\n\tsignal.Notify(sc, os.Interrupt)\n\treturn sc\n}\n"
        },
        {
          "name": "rpc.go",
          "type": "blob",
          "size": 3.90625,
          "content": "package main\n\nimport (\n\t\"context\"\n\t\"errors\"\n\t\"fmt\"\n\t\"net\"\n\t\"net/rpc\"\n\t\"sync\"\n\t\"time\"\n)\n\n// Goreman is RPC server\ntype Goreman struct {\n\trpcChan chan<- *rpcMessage\n}\n\ntype rpcMessage struct {\n\tMsg  string\n\tArgs []string\n\t// sending error (if any) when the task completes\n\tErrCh chan error\n}\n\n// Start do start\nfunc (r *Goreman) Start(args []string, ret *string) (err error) {\n\tdefer func() {\n\t\tif r := recover(); r != nil {\n\t\t\terr = r.(error)\n\t\t}\n\t}()\n\tfor _, arg := range args {\n\t\tif err = startProc(arg, nil, nil); err != nil {\n\t\t\tbreak\n\t\t}\n\t}\n\treturn err\n}\n\n// Stop do stop\nfunc (r *Goreman) Stop(args []string, ret *string) (err error) {\n\tdefer func() {\n\t\tif r := recover(); r != nil {\n\t\t\terr = r.(error)\n\t\t}\n\t}()\n\terrChan := make(chan error, 1)\n\tr.rpcChan <- &rpcMessage{\n\t\tMsg:   \"stop\",\n\t\tArgs:  args,\n\t\tErrCh: errChan,\n\t}\n\terr = <-errChan\n\treturn\n}\n\n// StopAll do stop all\nfunc (r *Goreman) StopAll(args []string, ret *string) (err error) {\n\tdefer func() {\n\t\tif r := recover(); r != nil {\n\t\t\terr = r.(error)\n\t\t}\n\t}()\n\tfor _, proc := range procs {\n\t\tif err = stopProc(proc.name, nil); err != nil {\n\t\t\tbreak\n\t\t}\n\t}\n\treturn err\n}\n\n// Restart do restart\nfunc (r *Goreman) Restart(args []string, ret *string) (err error) {\n\tdefer func() {\n\t\tif r := recover(); r != nil {\n\t\t\terr = r.(error)\n\t\t}\n\t}()\n\tfor _, arg := range args {\n\t\tif err = restartProc(arg); err != nil {\n\t\t\tbreak\n\t\t}\n\t}\n\treturn err\n}\n\n// RestartAll do restart all\nfunc (r *Goreman) RestartAll(args []string, ret *string) (err error) {\n\tdefer func() {\n\t\tif r := recover(); r != nil {\n\t\t\terr = r.(error)\n\t\t}\n\t}()\n\tfor _, proc := range procs {\n\t\tif err = restartProc(proc.name); err != nil {\n\t\t\tbreak\n\t\t}\n\t}\n\treturn err\n}\n\n// List do list\nfunc (r *Goreman) List(args []string, ret *string) (err error) {\n\tdefer func() {\n\t\tif r := recover(); r != nil {\n\t\t\terr = r.(error)\n\t\t}\n\t}()\n\t*ret = \"\"\n\tfor _, proc := range procs {\n\t\t*ret += proc.name + \"\\n\"\n\t}\n\treturn err\n}\n\n// Status do status\nfunc (r *Goreman) Status(args []string, ret *string) (err error) {\n\tdefer func() {\n\t\tif r := recover(); r != nil {\n\t\t\terr = r.(error)\n\t\t}\n\t}()\n\t*ret = \"\"\n\tfor _, proc := range procs {\n\t\tif proc.cmd != nil {\n\t\t\t*ret += \"*\" + proc.name + \"\\n\"\n\t\t} else {\n\t\t\t*ret += \" \" + proc.name + \"\\n\"\n\t\t}\n\t}\n\treturn err\n}\n\n// command: run.\nfunc run(cmd string, args []string, serverPort uint) error {\n\tclient, err := rpc.Dial(\"tcp\", defaultServer(serverPort))\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer client.Close()\n\tvar ret string\n\tswitch cmd {\n\tcase \"start\":\n\t\treturn client.Call(\"Goreman.Start\", args, &ret)\n\tcase \"stop\":\n\t\treturn client.Call(\"Goreman.Stop\", args, &ret)\n\tcase \"stop-all\":\n\t\treturn client.Call(\"Goreman.StopAll\", args, &ret)\n\tcase \"restart\":\n\t\treturn client.Call(\"Goreman.Restart\", args, &ret)\n\tcase \"restart-all\":\n\t\treturn client.Call(\"Goreman.RestartAll\", args, &ret)\n\tcase \"list\":\n\t\terr := client.Call(\"Goreman.List\", args, &ret)\n\t\tfmt.Print(ret)\n\t\treturn err\n\tcase \"status\":\n\t\terr := client.Call(\"Goreman.Status\", args, &ret)\n\t\tfmt.Print(ret)\n\t\treturn err\n\t}\n\treturn errors.New(\"unknown command\")\n}\n\n// start rpc server.\nfunc startServer(ctx context.Context, rpcChan chan<- *rpcMessage, listenPort uint) error {\n\tgm := &Goreman{\n\t\trpcChan: rpcChan,\n\t}\n\trpc.Register(gm)\n\tserver, err := net.Listen(\"tcp\", fmt.Sprintf(\"%s:%d\", defaultAddr(), listenPort))\n\tif err != nil {\n\t\treturn err\n\t}\n\tvar wg sync.WaitGroup\n\tvar acceptingConns = true\n\tfor acceptingConns {\n\t\tconns := make(chan net.Conn, 1)\n\t\tgo func() {\n\t\t\tconn, err := server.Accept()\n\t\t\tif err != nil {\n\t\t\t\treturn\n\t\t\t}\n\t\t\tconns <- conn\n\t\t}()\n\t\tselect {\n\t\tcase <-ctx.Done():\n\t\t\tacceptingConns = false\n\t\t\tbreak\n\t\tcase client := <-conns: // server is not canceled.\n\t\t\twg.Add(1)\n\t\t\tgo func() {\n\t\t\t\tdefer wg.Done()\n\t\t\t\trpc.ServeConn(client)\n\t\t\t}()\n\t\t}\n\t}\n\tdone := make(chan struct{}, 1)\n\tgo func() {\n\t\twg.Wait()\n\t\tdone <- struct{}{}\n\t}()\n\tselect {\n\tcase <-done:\n\t\treturn nil\n\tcase <-time.After(10 * time.Second):\n\t\treturn errors.New(\"RPC server did not shut down in 10 seconds, quitting\")\n\t}\n}\n"
        }
      ]
    }
  ]
}