{
  "metadata": {
    "timestamp": 1736567141084,
    "page": 738,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjc0MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "xeipuuv/gojsonschema",
      "stars": 2585,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.0244140625,
          "content": "*.sw[nop]\n*.iml\n.vscode/\n"
        },
        {
          "name": ".travis.yml",
          "type": "blob",
          "size": 0.197265625,
          "content": "language: go\ngo:\n  - \"1.11\"\n  - \"1.12\"\n  - \"1.13\"\nbefore_install:\n  - go get github.com/xeipuuv/gojsonreference\n  - go get github.com/xeipuuv/gojsonpointer\n  - go get github.com/stretchr/testify/assert\n"
        },
        {
          "name": "LICENSE-APACHE-2.0.txt",
          "type": "blob",
          "size": 11.072265625,
          "content": "\n                                 Apache License\n                           Version 2.0, January 2004\n                        http://www.apache.org/licenses/\n\n   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION\n\n   1. Definitions.\n\n      \"License\" shall mean the terms and conditions for use, reproduction,\n      and distribution as defined by Sections 1 through 9 of this document.\n\n      \"Licensor\" shall mean the copyright owner or entity authorized by\n      the copyright owner that is granting the License.\n\n      \"Legal Entity\" shall mean the union of the acting entity and all\n      other entities that control, are controlled by, or are under common\n      control with that entity. For the purposes of this definition,\n      \"control\" means (i) the power, direct or indirect, to cause the\n      direction or management of such entity, whether by contract or\n      otherwise, or (ii) ownership of fifty percent (50%) or more of the\n      outstanding shares, or (iii) beneficial ownership of such entity.\n\n      \"You\" (or \"Your\") shall mean an individual or Legal Entity\n      exercising permissions granted by this License.\n\n      \"Source\" form shall mean the preferred form for making modifications,\n      including but not limited to software source code, documentation\n      source, and configuration files.\n\n      \"Object\" form shall mean any form resulting from mechanical\n      transformation or translation of a Source form, including but\n      not limited to compiled object code, generated documentation,\n      and conversions to other media types.\n\n      \"Work\" shall mean the work of authorship, whether in Source or\n      Object form, made available under the License, as indicated by a\n      copyright notice that is included in or attached to the work\n      (an example is provided in the Appendix below).\n\n      \"Derivative Works\" shall mean any work, whether in Source or Object\n      form, that is based on (or derived from) the Work and for which the\n      editorial revisions, annotations, elaborations, or other modifications\n      represent, as a whole, an original work of authorship. For the purposes\n      of this License, Derivative Works shall not include works that remain\n      separable from, or merely link (or bind by name) to the interfaces of,\n      the Work and Derivative Works thereof.\n\n      \"Contribution\" shall mean any work of authorship, including\n      the original version of the Work and any modifications or additions\n      to that Work or Derivative Works thereof, that is intentionally\n      submitted to Licensor for inclusion in the Work by the copyright owner\n      or by an individual or Legal Entity authorized to submit on behalf of\n      the copyright owner. For the purposes of this definition, \"submitted\"\n      means any form of electronic, verbal, or written communication sent\n      to the Licensor or its representatives, including but not limited to\n      communication on electronic mailing lists, source code control systems,\n      and issue tracking systems that are managed by, or on behalf of, the\n      Licensor for the purpose of discussing and improving the Work, but\n      excluding communication that is conspicuously marked or otherwise\n      designated in writing by the copyright owner as \"Not a Contribution.\"\n\n      \"Contributor\" shall mean Licensor and any individual or Legal Entity\n      on behalf of whom a Contribution has been received by Licensor and\n      subsequently incorporated within the Work.\n\n   2. Grant of Copyright License. Subject to the terms and conditions of\n      this License, each Contributor hereby grants to You a perpetual,\n      worldwide, non-exclusive, no-charge, royalty-free, irrevocable\n      copyright license to reproduce, prepare Derivative Works of,\n      publicly display, publicly perform, sublicense, and distribute the\n      Work and such Derivative Works in Source or Object form.\n\n   3. Grant of Patent License. Subject to the terms and conditions of\n      this License, each Contributor hereby grants to You a perpetual,\n      worldwide, non-exclusive, no-charge, royalty-free, irrevocable\n      (except as stated in this section) patent license to make, have made,\n      use, offer to sell, sell, import, and otherwise transfer the Work,\n      where such license applies only to those patent claims licensable\n      by such Contributor that are necessarily infringed by their\n      Contribution(s) alone or by combination of their Contribution(s)\n      with the Work to which such Contribution(s) was submitted. If You\n      institute patent litigation against any entity (including a\n      cross-claim or counterclaim in a lawsuit) alleging that the Work\n      or a Contribution incorporated within the Work constitutes direct\n      or contributory patent infringement, then any patent licenses\n      granted to You under this License for that Work shall terminate\n      as of the date such litigation is filed.\n\n   4. Redistribution. You may reproduce and distribute copies of the\n      Work or Derivative Works thereof in any medium, with or without\n      modifications, and in Source or Object form, provided that You\n      meet the following conditions:\n\n      (a) You must give any other recipients of the Work or\n          Derivative Works a copy of this License; and\n\n      (b) You must cause any modified files to carry prominent notices\n          stating that You changed the files; and\n\n      (c) You must retain, in the Source form of any Derivative Works\n          that You distribute, all copyright, patent, trademark, and\n          attribution notices from the Source form of the Work,\n          excluding those notices that do not pertain to any part of\n          the Derivative Works; and\n\n      (d) If the Work includes a \"NOTICE\" text file as part of its\n          distribution, then any Derivative Works that You distribute must\n          include a readable copy of the attribution notices contained\n          within such NOTICE file, excluding those notices that do not\n          pertain to any part of the Derivative Works, in at least one\n          of the following places: within a NOTICE text file distributed\n          as part of the Derivative Works; within the Source form or\n          documentation, if provided along with the Derivative Works; or,\n          within a display generated by the Derivative Works, if and\n          wherever such third-party notices normally appear. The contents\n          of the NOTICE file are for informational purposes only and\n          do not modify the License. You may add Your own attribution\n          notices within Derivative Works that You distribute, alongside\n          or as an addendum to the NOTICE text from the Work, provided\n          that such additional attribution notices cannot be construed\n          as modifying the License.\n\n      You may add Your own copyright statement to Your modifications and\n      may provide additional or different license terms and conditions\n      for use, reproduction, or distribution of Your modifications, or\n      for any such Derivative Works as a whole, provided Your use,\n      reproduction, and distribution of the Work otherwise complies with\n      the conditions stated in this License.\n\n   5. Submission of Contributions. Unless You explicitly state otherwise,\n      any Contribution intentionally submitted for inclusion in the Work\n      by You to the Licensor shall be under the terms and conditions of\n      this License, without any additional terms or conditions.\n      Notwithstanding the above, nothing herein shall supersede or modify\n      the terms of any separate license agreement you may have executed\n      with Licensor regarding such Contributions.\n\n   6. Trademarks. This License does not grant permission to use the trade\n      names, trademarks, service marks, or product names of the Licensor,\n      except as required for reasonable and customary use in describing the\n      origin of the Work and reproducing the content of the NOTICE file.\n\n   7. Disclaimer of Warranty. Unless required by applicable law or\n      agreed to in writing, Licensor provides the Work (and each\n      Contributor provides its Contributions) on an \"AS IS\" BASIS,\n      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n      implied, including, without limitation, any warranties or conditions\n      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A\n      PARTICULAR PURPOSE. You are solely responsible for determining the\n      appropriateness of using or redistributing the Work and assume any\n      risks associated with Your exercise of permissions under this License.\n\n   8. Limitation of Liability. In no event and under no legal theory,\n      whether in tort (including negligence), contract, or otherwise,\n      unless required by applicable law (such as deliberate and grossly\n      negligent acts) or agreed to in writing, shall any Contributor be\n      liable to You for damages, including any direct, indirect, special,\n      incidental, or consequential damages of any character arising as a\n      result of this License or out of the use or inability to use the\n      Work (including but not limited to damages for loss of goodwill,\n      work stoppage, computer failure or malfunction, or any and all\n      other commercial damages or losses), even if such Contributor\n      has been advised of the possibility of such damages.\n\n   9. Accepting Warranty or Additional Liability. While redistributing\n      the Work or Derivative Works thereof, You may choose to offer,\n      and charge a fee for, acceptance of support, warranty, indemnity,\n      or other liability obligations and/or rights consistent with this\n      License. However, in accepting such obligations, You may act only\n      on Your own behalf and on Your sole responsibility, not on behalf\n      of any other Contributor, and only if You agree to indemnify,\n      defend, and hold each Contributor harmless for any liability\n      incurred by, or claims asserted against, such Contributor by reason\n      of your accepting any such warranty or additional liability.\n\n   END OF TERMS AND CONDITIONS\n\n   APPENDIX: How to apply the Apache License to your work.\n\n      To apply the Apache License to your work, attach the following\n      boilerplate notice, with the fields enclosed by brackets \"[]\"\n      replaced with your own identifying information. (Don't include\n      the brackets!)  The text should be enclosed in the appropriate\n      comment syntax for the file format. We also recommend that a\n      file or class name and description of purpose be included on the\n      same \"printed page\" as the copyright notice for easier\n      identification within third-party archives.\n\n   Copyright 2015 xeipuuv\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n       http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 15.1455078125,
          "content": "[![GoDoc](https://godoc.org/github.com/xeipuuv/gojsonschema?status.svg)](https://godoc.org/github.com/xeipuuv/gojsonschema)\n[![Build Status](https://travis-ci.org/xeipuuv/gojsonschema.svg)](https://travis-ci.org/xeipuuv/gojsonschema)\n[![Go Report Card](https://goreportcard.com/badge/github.com/xeipuuv/gojsonschema)](https://goreportcard.com/report/github.com/xeipuuv/gojsonschema)\n\n# gojsonschema\n\n## Description\n\nAn implementation of JSON Schema for the Go  programming language. Supports draft-04, draft-06 and draft-07.\n\nReferences :\n\n* http://json-schema.org\n* http://json-schema.org/latest/json-schema-core.html\n* http://json-schema.org/latest/json-schema-validation.html\n\n## Installation\n\n```\ngo get github.com/xeipuuv/gojsonschema\n```\n\nDependencies :\n* [github.com/xeipuuv/gojsonpointer](https://github.com/xeipuuv/gojsonpointer)\n* [github.com/xeipuuv/gojsonreference](https://github.com/xeipuuv/gojsonreference)\n* [github.com/stretchr/testify/assert](https://github.com/stretchr/testify#assert-package)\n\n## Usage\n\n### Example\n\n```go\n\npackage main\n\nimport (\n    \"fmt\"\n    \"github.com/xeipuuv/gojsonschema\"\n)\n\nfunc main() {\n\n    schemaLoader := gojsonschema.NewReferenceLoader(\"file:///home/me/schema.json\")\n    documentLoader := gojsonschema.NewReferenceLoader(\"file:///home/me/document.json\")\n\n    result, err := gojsonschema.Validate(schemaLoader, documentLoader)\n    if err != nil {\n        panic(err.Error())\n    }\n\n    if result.Valid() {\n        fmt.Printf(\"The document is valid\\n\")\n    } else {\n        fmt.Printf(\"The document is not valid. see errors :\\n\")\n        for _, desc := range result.Errors() {\n            fmt.Printf(\"- %s\\n\", desc)\n        }\n    }\n}\n\n\n```\n\n#### Loaders\n\nThere are various ways to load your JSON data.\nIn order to load your schemas and documents,\nfirst declare an appropriate loader :\n\n* Web / HTTP, using a reference :\n\n```go\nloader := gojsonschema.NewReferenceLoader(\"http://www.some_host.com/schema.json\")\n```\n\n* Local file, using a reference :\n\n```go\nloader := gojsonschema.NewReferenceLoader(\"file:///home/me/schema.json\")\n```\n\nReferences use the URI scheme, the prefix (file://) and a full path to the file are required.\n\n* JSON strings :\n\n```go\nloader := gojsonschema.NewStringLoader(`{\"type\": \"string\"}`)\n```\n\n* Custom Go types :\n\n```go\nm := map[string]interface{}{\"type\": \"string\"}\nloader := gojsonschema.NewGoLoader(m)\n```\n\nAnd\n\n```go\ntype Root struct {\n\tUsers []User `json:\"users\"`\n}\n\ntype User struct {\n\tName string `json:\"name\"`\n}\n\n...\n\ndata := Root{}\ndata.Users = append(data.Users, User{\"John\"})\ndata.Users = append(data.Users, User{\"Sophia\"})\ndata.Users = append(data.Users, User{\"Bill\"})\n\nloader := gojsonschema.NewGoLoader(data)\n```\n\n#### Validation\n\nOnce the loaders are set, validation is easy :\n\n```go\nresult, err := gojsonschema.Validate(schemaLoader, documentLoader)\n```\n\nAlternatively, you might want to load a schema only once and process to multiple validations :\n\n```go\nschema, err := gojsonschema.NewSchema(schemaLoader)\n...\nresult1, err := schema.Validate(documentLoader1)\n...\nresult2, err := schema.Validate(documentLoader2)\n...\n// etc ...\n```\n\nTo check the result :\n\n```go\n    if result.Valid() {\n    \tfmt.Printf(\"The document is valid\\n\")\n    } else {\n        fmt.Printf(\"The document is not valid. see errors :\\n\")\n        for _, err := range result.Errors() {\n        \t// Err implements the ResultError interface\n            fmt.Printf(\"- %s\\n\", err)\n        }\n    }\n```\n\n\n## Loading local schemas\n\nBy default `file` and `http(s)` references to external schemas are loaded automatically via the file system or via http(s). An external schema can also be loaded using a `SchemaLoader`.\n\n```go\n\tsl := gojsonschema.NewSchemaLoader()\n\tloader1 := gojsonschema.NewStringLoader(`{ \"type\" : \"string\" }`)\n\terr := sl.AddSchema(\"http://some_host.com/string.json\", loader1)\n```\n\nAlternatively if your schema already has an `$id` you can use the `AddSchemas` function\n```go\n\tloader2 := gojsonschema.NewStringLoader(`{\n\t\t\t\"$id\" : \"http://some_host.com/maxlength.json\",\n\t\t\t\"maxLength\" : 5\n\t\t}`)\n\terr = sl.AddSchemas(loader2)\n```\n\nThe main schema should be passed to the `Compile` function. This main schema can then directly reference the added schemas without needing to download them.\n```go\n\tloader3 := gojsonschema.NewStringLoader(`{\n\t\t\"$id\" : \"http://some_host.com/main.json\",\n\t\t\"allOf\" : [\n\t\t\t{ \"$ref\" : \"http://some_host.com/string.json\" },\n\t\t\t{ \"$ref\" : \"http://some_host.com/maxlength.json\" }\n\t\t]\n\t}`)\n\n\tschema, err := sl.Compile(loader3)\n\n\tdocumentLoader := gojsonschema.NewStringLoader(`\"hello world\"`)\n\n\tresult, err := schema.Validate(documentLoader)\n```\n\nIt's also possible to pass a `ReferenceLoader` to the `Compile` function that references a loaded schema.\n\n```go\nerr = sl.AddSchemas(loader3)\nschema, err := sl.Compile(gojsonschema.NewReferenceLoader(\"http://some_host.com/main.json\"))\n``` \n\nSchemas added by `AddSchema` and `AddSchemas` are only validated when the entire schema is compiled, unless meta-schema validation is used.\n\n## Using a specific draft\nBy default `gojsonschema` will try to detect the draft of a schema by using the `$schema` keyword and parse it in a strict draft-04, draft-06 or draft-07 mode. If `$schema` is missing, or the draft version is not explicitely set, a hybrid mode is used which merges together functionality of all drafts into one mode.\n\nAutodectection can be turned off with the `AutoDetect` property. Specific draft versions can be specified with the `Draft` property.\n\n```go\nsl := gojsonschema.NewSchemaLoader()\nsl.Draft = gojsonschema.Draft7\nsl.AutoDetect = false\n```\n\nIf autodetection is on (default), a draft-07 schema can savely reference draft-04 schemas and vice-versa, as long as `$schema` is specified in all schemas.\n\n## Meta-schema validation\nSchemas that are added using the `AddSchema`, `AddSchemas` and `Compile` can be validated against their meta-schema by setting the `Validate` property.\n\nThe following example will produce an error as `multipleOf` must be a number. If `Validate` is off (default), this error is only returned at the `Compile` step. \n\n```go\nsl := gojsonschema.NewSchemaLoader()\nsl.Validate = true\nerr := sl.AddSchemas(gojsonschema.NewStringLoader(`{\n     \"$id\" : \"http://some_host.com/invalid.json\",\n    \"$schema\": \"http://json-schema.org/draft-07/schema#\",\n    \"multipleOf\" : true\n}`))\n ```\n``` \n ```\n\nErrors returned by meta-schema validation are more readable and contain more information, which helps significantly if you are developing a schema.\n\nMeta-schema validation also works with a custom `$schema`. In case `$schema` is missing, or `AutoDetect` is set to `false`, the meta-schema of the used draft is used.\n\n\n## Working with Errors\n\nThe library handles string error codes which you can customize by creating your own gojsonschema.locale and setting it\n```go\ngojsonschema.Locale = YourCustomLocale{}\n```\n\nHowever, each error contains additional contextual information. \n\nNewer versions of `gojsonschema` may have new additional errors, so code that uses a custom locale will need to be updated when this happens.\n\n**err.Type()**: *string* Returns the \"type\" of error that occurred. Note you can also type check. See below\n\nNote: An error of RequiredType has an err.Type() return value of \"required\"\n\n    \"required\": RequiredError\n    \"invalid_type\": InvalidTypeError\n    \"number_any_of\": NumberAnyOfError\n    \"number_one_of\": NumberOneOfError\n    \"number_all_of\": NumberAllOfError\n    \"number_not\": NumberNotError\n    \"missing_dependency\": MissingDependencyError\n    \"internal\": InternalError\n    \"const\": ConstEror\n    \"enum\": EnumError\n    \"array_no_additional_items\": ArrayNoAdditionalItemsError\n    \"array_min_items\": ArrayMinItemsError\n    \"array_max_items\": ArrayMaxItemsError\n    \"unique\": ItemsMustBeUniqueError\n    \"contains\" : ArrayContainsError\n    \"array_min_properties\": ArrayMinPropertiesError\n    \"array_max_properties\": ArrayMaxPropertiesError\n    \"additional_property_not_allowed\": AdditionalPropertyNotAllowedError\n    \"invalid_property_pattern\": InvalidPropertyPatternError\n    \"invalid_property_name\":  InvalidPropertyNameError\n    \"string_gte\": StringLengthGTEError\n    \"string_lte\": StringLengthLTEError\n    \"pattern\": DoesNotMatchPatternError\n    \"multiple_of\": MultipleOfError\n    \"number_gte\": NumberGTEError\n    \"number_gt\": NumberGTError\n    \"number_lte\": NumberLTEError\n    \"number_lt\": NumberLTError\n    \"condition_then\" : ConditionThenError\n    \"condition_else\" : ConditionElseError\n\n**err.Value()**: *interface{}* Returns the value given\n\n**err.Context()**: *gojsonschema.JsonContext* Returns the context. This has a String() method that will print something like this: (root).firstName\n\n**err.Field()**: *string* Returns the fieldname in the format firstName, or for embedded properties, person.firstName. This returns the same as the String() method on *err.Context()* but removes the (root). prefix.\n\n**err.Description()**: *string* The error description. This is based on the locale you are using. See the beginning of this section for overwriting the locale with a custom implementation.\n\n**err.DescriptionFormat()**: *string* The error description format. This is relevant if you are adding custom validation errors afterwards to the result.\n\n**err.Details()**: *gojsonschema.ErrorDetails* Returns a map[string]interface{} of additional error details specific to the error. For example, GTE errors will have a \"min\" value, LTE will have a \"max\" value. See errors.go for a full description of all the error details. Every error always contains a \"field\" key that holds the value of *err.Field()*\n\nNote in most cases, the err.Details() will be used to generate replacement strings in your locales, and not used directly. These strings follow the text/template format i.e.\n```\n{{.field}} must be greater than or equal to {{.min}}\n```\n\nThe library allows you to specify custom template functions, should you require more complex error message handling.\n```go\ngojsonschema.ErrorTemplateFuncs = map[string]interface{}{\n\t\"allcaps\": func(s string) string {\n\t\treturn strings.ToUpper(s)\n\t},\n}\n```\n\nGiven the above definition, you can use the custom function `\"allcaps\"` in your localization templates:\n```\n{{allcaps .field}} must be greater than or equal to {{.min}}\n```\n\nThe above error message would then be rendered with the `field` value in capital letters. For example:\n```\n\"PASSWORD must be greater than or equal to 8\"\n```\n\nLearn more about what types of template functions you can use in `ErrorTemplateFuncs` by referring to Go's [text/template FuncMap](https://golang.org/pkg/text/template/#FuncMap) type.\n\n## Formats\nJSON Schema allows for optional \"format\" property to validate instances against well-known formats. gojsonschema ships with all of the formats defined in the spec that you can use like this:\n\n````json\n{\"type\": \"string\", \"format\": \"email\"}\n````\n\nNot all formats defined in draft-07 are available. Implemented formats are:\n\n* `date`\n* `time`\n* `date-time`\n* `hostname`. Subdomains that start with a number are also supported, but this means that it doesn't strictly follow [RFC1034](http://tools.ietf.org/html/rfc1034#section-3.5) and has the implication that ipv4 addresses are also recognized as valid hostnames.\n* `email`. Go's email parser deviates slightly from [RFC5322](https://tools.ietf.org/html/rfc5322). Includes unicode support.\n* `idn-email`. Same caveat as `email`.\n* `ipv4`\n* `ipv6`\n* `uri`. Includes unicode support.\n* `uri-reference`. Includes unicode support.\n* `iri`\n* `iri-reference`\n* `uri-template`\n* `uuid`\n* `regex`. Go uses the [RE2](https://github.com/google/re2/wiki/Syntax) engine and is not [ECMA262](http://www.ecma-international.org/publications/files/ECMA-ST/Ecma-262.pdf) compatible.\n* `json-pointer`\n* `relative-json-pointer`\n\n`email`, `uri` and `uri-reference` use the same validation code as their unicode counterparts `idn-email`, `iri` and `iri-reference`. If you rely on unicode support you should use the specific \nunicode enabled formats for the sake of interoperability as other implementations might not support unicode in the regular formats.\n\nThe validation code for `uri`, `idn-email` and their relatives use mostly standard library code.\n\nFor repetitive or more complex formats, you can create custom format checkers and add them to gojsonschema like this:\n\n```go\n// Define the format checker\ntype RoleFormatChecker struct {}\n\n// Ensure it meets the gojsonschema.FormatChecker interface\nfunc (f RoleFormatChecker) IsFormat(input interface{}) bool {\n\n    asString, ok := input.(string)\n    if ok == false {\n        return false\n    }\n\n    return strings.HasPrefix(\"ROLE_\", asString)\n}\n\n// Add it to the library\ngojsonschema.FormatCheckers.Add(\"role\", RoleFormatChecker{})\n````\n\nNow to use in your json schema:\n````json\n{\"type\": \"string\", \"format\": \"role\"}\n````\n\nAnother example would be to check if the provided integer matches an id on database:\n\nJSON schema:\n```json\n{\"type\": \"integer\", \"format\": \"ValidUserId\"}\n```\n\n```go\n// Define the format checker\ntype ValidUserIdFormatChecker struct {}\n\n// Ensure it meets the gojsonschema.FormatChecker interface\nfunc (f ValidUserIdFormatChecker) IsFormat(input interface{}) bool {\n\n    asFloat64, ok := input.(float64) // Numbers are always float64 here\n    if ok == false {\n        return false\n    }\n\n    // XXX\n    // do the magic on the database looking for the int(asFloat64)\n\n    return true\n}\n\n// Add it to the library\ngojsonschema.FormatCheckers.Add(\"ValidUserId\", ValidUserIdFormatChecker{})\n````\n\nFormats can also be removed, for example if you want to override one of the formats that is defined by default.\n\n```go\ngojsonschema.FormatCheckers.Remove(\"hostname\")\n```\n\n\n## Additional custom validation\nAfter the validation has run and you have the results, you may add additional\nerrors using `Result.AddError`. This is useful to maintain the same format within the resultset instead\nof having to add special exceptions for your own errors. Below is an example.\n\n```go\ntype AnswerInvalidError struct {\n    gojsonschema.ResultErrorFields\n}\n\nfunc newAnswerInvalidError(context *gojsonschema.JsonContext, value interface{}, details gojsonschema.ErrorDetails) *AnswerInvalidError {\n    err := AnswerInvalidError{}\n    err.SetContext(context)\n    err.SetType(\"custom_invalid_error\")\n    // it is important to use SetDescriptionFormat() as this is used to call SetDescription() after it has been parsed\n    // using the description of err will be overridden by this.\n    err.SetDescriptionFormat(\"Answer to the Ultimate Question of Life, the Universe, and Everything is {{.answer}}\")\n    err.SetValue(value)\n    err.SetDetails(details)\n\n    return &err\n}\n\nfunc main() {\n    // ...\n    schema, err := gojsonschema.NewSchema(schemaLoader)\n    result, err := gojsonschema.Validate(schemaLoader, documentLoader)\n\n    if true { // some validation\n        jsonContext := gojsonschema.NewJsonContext(\"question\", nil)\n        errDetail := gojsonschema.ErrorDetails{\n            \"answer\": 42,\n        }\n        result.AddError(\n            newAnswerInvalidError(\n                gojsonschema.NewJsonContext(\"answer\", jsonContext),\n                52,\n                errDetail,\n            ),\n            errDetail,\n        )\n    }\n\n    return result, err\n\n}\n```\n\nThis is especially useful if you want to add validation beyond what the\njson schema drafts can provide such business specific logic.\n\n## Uses\n\ngojsonschema uses the following test suite :\n\nhttps://github.com/json-schema/JSON-Schema-Test-Suite\n"
        },
        {
          "name": "draft.go",
          "type": "blob",
          "size": 10.2685546875,
          "content": "// Copyright 2018 johandorland ( https://github.com/johandorland )\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage gojsonschema\n\nimport (\n\t\"errors\"\n\t\"math\"\n\t\"reflect\"\n\n\t\"github.com/xeipuuv/gojsonreference\"\n)\n\n// Draft is a JSON-schema draft version\ntype Draft int\n\n// Supported Draft versions\nconst (\n\tDraft4 Draft = 4\n\tDraft6 Draft = 6\n\tDraft7 Draft = 7\n\tHybrid Draft = math.MaxInt32\n)\n\ntype draftConfig struct {\n\tVersion       Draft\n\tMetaSchemaURL string\n\tMetaSchema    string\n}\ntype draftConfigs []draftConfig\n\nvar drafts draftConfigs\n\nfunc init() {\n\tdrafts = []draftConfig{\n\t\t{\n\t\t\tVersion:       Draft4,\n\t\t\tMetaSchemaURL: \"http://json-schema.org/draft-04/schema\",\n\t\t\tMetaSchema:    `{\"id\":\"http://json-schema.org/draft-04/schema#\",\"$schema\":\"http://json-schema.org/draft-04/schema#\",\"description\":\"Core schema meta-schema\",\"definitions\":{\"schemaArray\":{\"type\":\"array\",\"minItems\":1,\"items\":{\"$ref\":\"#\"}},\"positiveInteger\":{\"type\":\"integer\",\"minimum\":0},\"positiveIntegerDefault0\":{\"allOf\":[{\"$ref\":\"#/definitions/positiveInteger\"},{\"default\":0}]},\"simpleTypes\":{\"enum\":[\"array\",\"boolean\",\"integer\",\"null\",\"number\",\"object\",\"string\"]},\"stringArray\":{\"type\":\"array\",\"items\":{\"type\":\"string\"},\"minItems\":1,\"uniqueItems\":true}},\"type\":\"object\",\"properties\":{\"id\":{\"type\":\"string\"},\"$schema\":{\"type\":\"string\"},\"title\":{\"type\":\"string\"},\"description\":{\"type\":\"string\"},\"default\":{},\"multipleOf\":{\"type\":\"number\",\"minimum\":0,\"exclusiveMinimum\":true},\"maximum\":{\"type\":\"number\"},\"exclusiveMaximum\":{\"type\":\"boolean\",\"default\":false},\"minimum\":{\"type\":\"number\"},\"exclusiveMinimum\":{\"type\":\"boolean\",\"default\":false},\"maxLength\":{\"$ref\":\"#/definitions/positiveInteger\"},\"minLength\":{\"$ref\":\"#/definitions/positiveIntegerDefault0\"},\"pattern\":{\"type\":\"string\",\"format\":\"regex\"},\"additionalItems\":{\"anyOf\":[{\"type\":\"boolean\"},{\"$ref\":\"#\"}],\"default\":{}},\"items\":{\"anyOf\":[{\"$ref\":\"#\"},{\"$ref\":\"#/definitions/schemaArray\"}],\"default\":{}},\"maxItems\":{\"$ref\":\"#/definitions/positiveInteger\"},\"minItems\":{\"$ref\":\"#/definitions/positiveIntegerDefault0\"},\"uniqueItems\":{\"type\":\"boolean\",\"default\":false},\"maxProperties\":{\"$ref\":\"#/definitions/positiveInteger\"},\"minProperties\":{\"$ref\":\"#/definitions/positiveIntegerDefault0\"},\"required\":{\"$ref\":\"#/definitions/stringArray\"},\"additionalProperties\":{\"anyOf\":[{\"type\":\"boolean\"},{\"$ref\":\"#\"}],\"default\":{}},\"definitions\":{\"type\":\"object\",\"additionalProperties\":{\"$ref\":\"#\"},\"default\":{}},\"properties\":{\"type\":\"object\",\"additionalProperties\":{\"$ref\":\"#\"},\"default\":{}},\"patternProperties\":{\"type\":\"object\",\"additionalProperties\":{\"$ref\":\"#\"},\"default\":{}},\"dependencies\":{\"type\":\"object\",\"additionalProperties\":{\"anyOf\":[{\"$ref\":\"#\"},{\"$ref\":\"#/definitions/stringArray\"}]}},\"enum\":{\"type\":\"array\",\"minItems\":1,\"uniqueItems\":true},\"type\":{\"anyOf\":[{\"$ref\":\"#/definitions/simpleTypes\"},{\"type\":\"array\",\"items\":{\"$ref\":\"#/definitions/simpleTypes\"},\"minItems\":1,\"uniqueItems\":true}]},\"format\":{\"type\":\"string\"},\"allOf\":{\"$ref\":\"#/definitions/schemaArray\"},\"anyOf\":{\"$ref\":\"#/definitions/schemaArray\"},\"oneOf\":{\"$ref\":\"#/definitions/schemaArray\"},\"not\":{\"$ref\":\"#\"}},\"dependencies\":{\"exclusiveMaximum\":[\"maximum\"],\"exclusiveMinimum\":[\"minimum\"]},\"default\":{}}`,\n\t\t},\n\t\t{\n\t\t\tVersion:       Draft6,\n\t\t\tMetaSchemaURL: \"http://json-schema.org/draft-06/schema\",\n\t\t\tMetaSchema:    `{\"$schema\":\"http://json-schema.org/draft-06/schema#\",\"$id\":\"http://json-schema.org/draft-06/schema#\",\"title\":\"Core schema meta-schema\",\"definitions\":{\"schemaArray\":{\"type\":\"array\",\"minItems\":1,\"items\":{\"$ref\":\"#\"}},\"nonNegativeInteger\":{\"type\":\"integer\",\"minimum\":0},\"nonNegativeIntegerDefault0\":{\"allOf\":[{\"$ref\":\"#/definitions/nonNegativeInteger\"},{\"default\":0}]},\"simpleTypes\":{\"enum\":[\"array\",\"boolean\",\"integer\",\"null\",\"number\",\"object\",\"string\"]},\"stringArray\":{\"type\":\"array\",\"items\":{\"type\":\"string\"},\"uniqueItems\":true,\"default\":[]}},\"type\":[\"object\",\"boolean\"],\"properties\":{\"$id\":{\"type\":\"string\",\"format\":\"uri-reference\"},\"$schema\":{\"type\":\"string\",\"format\":\"uri\"},\"$ref\":{\"type\":\"string\",\"format\":\"uri-reference\"},\"title\":{\"type\":\"string\"},\"description\":{\"type\":\"string\"},\"default\":{},\"examples\":{\"type\":\"array\",\"items\":{}},\"multipleOf\":{\"type\":\"number\",\"exclusiveMinimum\":0},\"maximum\":{\"type\":\"number\"},\"exclusiveMaximum\":{\"type\":\"number\"},\"minimum\":{\"type\":\"number\"},\"exclusiveMinimum\":{\"type\":\"number\"},\"maxLength\":{\"$ref\":\"#/definitions/nonNegativeInteger\"},\"minLength\":{\"$ref\":\"#/definitions/nonNegativeIntegerDefault0\"},\"pattern\":{\"type\":\"string\",\"format\":\"regex\"},\"additionalItems\":{\"$ref\":\"#\"},\"items\":{\"anyOf\":[{\"$ref\":\"#\"},{\"$ref\":\"#/definitions/schemaArray\"}],\"default\":{}},\"maxItems\":{\"$ref\":\"#/definitions/nonNegativeInteger\"},\"minItems\":{\"$ref\":\"#/definitions/nonNegativeIntegerDefault0\"},\"uniqueItems\":{\"type\":\"boolean\",\"default\":false},\"contains\":{\"$ref\":\"#\"},\"maxProperties\":{\"$ref\":\"#/definitions/nonNegativeInteger\"},\"minProperties\":{\"$ref\":\"#/definitions/nonNegativeIntegerDefault0\"},\"required\":{\"$ref\":\"#/definitions/stringArray\"},\"additionalProperties\":{\"$ref\":\"#\"},\"definitions\":{\"type\":\"object\",\"additionalProperties\":{\"$ref\":\"#\"},\"default\":{}},\"properties\":{\"type\":\"object\",\"additionalProperties\":{\"$ref\":\"#\"},\"default\":{}},\"patternProperties\":{\"type\":\"object\",\"additionalProperties\":{\"$ref\":\"#\"},\"default\":{}},\"dependencies\":{\"type\":\"object\",\"additionalProperties\":{\"anyOf\":[{\"$ref\":\"#\"},{\"$ref\":\"#/definitions/stringArray\"}]}},\"propertyNames\":{\"$ref\":\"#\"},\"const\":{},\"enum\":{\"type\":\"array\",\"minItems\":1,\"uniqueItems\":true},\"type\":{\"anyOf\":[{\"$ref\":\"#/definitions/simpleTypes\"},{\"type\":\"array\",\"items\":{\"$ref\":\"#/definitions/simpleTypes\"},\"minItems\":1,\"uniqueItems\":true}]},\"format\":{\"type\":\"string\"},\"allOf\":{\"$ref\":\"#/definitions/schemaArray\"},\"anyOf\":{\"$ref\":\"#/definitions/schemaArray\"},\"oneOf\":{\"$ref\":\"#/definitions/schemaArray\"},\"not\":{\"$ref\":\"#\"}},\"default\":{}}`,\n\t\t},\n\t\t{\n\t\t\tVersion:       Draft7,\n\t\t\tMetaSchemaURL: \"http://json-schema.org/draft-07/schema\",\n\t\t\tMetaSchema:    `{\"$schema\":\"http://json-schema.org/draft-07/schema#\",\"$id\":\"http://json-schema.org/draft-07/schema#\",\"title\":\"Core schema meta-schema\",\"definitions\":{\"schemaArray\":{\"type\":\"array\",\"minItems\":1,\"items\":{\"$ref\":\"#\"}},\"nonNegativeInteger\":{\"type\":\"integer\",\"minimum\":0},\"nonNegativeIntegerDefault0\":{\"allOf\":[{\"$ref\":\"#/definitions/nonNegativeInteger\"},{\"default\":0}]},\"simpleTypes\":{\"enum\":[\"array\",\"boolean\",\"integer\",\"null\",\"number\",\"object\",\"string\"]},\"stringArray\":{\"type\":\"array\",\"items\":{\"type\":\"string\"},\"uniqueItems\":true,\"default\":[]}},\"type\":[\"object\",\"boolean\"],\"properties\":{\"$id\":{\"type\":\"string\",\"format\":\"uri-reference\"},\"$schema\":{\"type\":\"string\",\"format\":\"uri\"},\"$ref\":{\"type\":\"string\",\"format\":\"uri-reference\"},\"$comment\":{\"type\":\"string\"},\"title\":{\"type\":\"string\"},\"description\":{\"type\":\"string\"},\"default\":true,\"readOnly\":{\"type\":\"boolean\",\"default\":false},\"examples\":{\"type\":\"array\",\"items\":true},\"multipleOf\":{\"type\":\"number\",\"exclusiveMinimum\":0},\"maximum\":{\"type\":\"number\"},\"exclusiveMaximum\":{\"type\":\"number\"},\"minimum\":{\"type\":\"number\"},\"exclusiveMinimum\":{\"type\":\"number\"},\"maxLength\":{\"$ref\":\"#/definitions/nonNegativeInteger\"},\"minLength\":{\"$ref\":\"#/definitions/nonNegativeIntegerDefault0\"},\"pattern\":{\"type\":\"string\",\"format\":\"regex\"},\"additionalItems\":{\"$ref\":\"#\"},\"items\":{\"anyOf\":[{\"$ref\":\"#\"},{\"$ref\":\"#/definitions/schemaArray\"}],\"default\":true},\"maxItems\":{\"$ref\":\"#/definitions/nonNegativeInteger\"},\"minItems\":{\"$ref\":\"#/definitions/nonNegativeIntegerDefault0\"},\"uniqueItems\":{\"type\":\"boolean\",\"default\":false},\"contains\":{\"$ref\":\"#\"},\"maxProperties\":{\"$ref\":\"#/definitions/nonNegativeInteger\"},\"minProperties\":{\"$ref\":\"#/definitions/nonNegativeIntegerDefault0\"},\"required\":{\"$ref\":\"#/definitions/stringArray\"},\"additionalProperties\":{\"$ref\":\"#\"},\"definitions\":{\"type\":\"object\",\"additionalProperties\":{\"$ref\":\"#\"},\"default\":{}},\"properties\":{\"type\":\"object\",\"additionalProperties\":{\"$ref\":\"#\"},\"default\":{}},\"patternProperties\":{\"type\":\"object\",\"additionalProperties\":{\"$ref\":\"#\"},\"propertyNames\":{\"format\":\"regex\"},\"default\":{}},\"dependencies\":{\"type\":\"object\",\"additionalProperties\":{\"anyOf\":[{\"$ref\":\"#\"},{\"$ref\":\"#/definitions/stringArray\"}]}},\"propertyNames\":{\"$ref\":\"#\"},\"const\":true,\"enum\":{\"type\":\"array\",\"items\":true,\"minItems\":1,\"uniqueItems\":true},\"type\":{\"anyOf\":[{\"$ref\":\"#/definitions/simpleTypes\"},{\"type\":\"array\",\"items\":{\"$ref\":\"#/definitions/simpleTypes\"},\"minItems\":1,\"uniqueItems\":true}]},\"format\":{\"type\":\"string\"},\"contentMediaType\":{\"type\":\"string\"},\"contentEncoding\":{\"type\":\"string\"},\"if\":{\"$ref\":\"#\"},\"then\":{\"$ref\":\"#\"},\"else\":{\"$ref\":\"#\"},\"allOf\":{\"$ref\":\"#/definitions/schemaArray\"},\"anyOf\":{\"$ref\":\"#/definitions/schemaArray\"},\"oneOf\":{\"$ref\":\"#/definitions/schemaArray\"},\"not\":{\"$ref\":\"#\"}},\"default\":true}`,\n\t\t},\n\t}\n}\n\nfunc (dc draftConfigs) GetMetaSchema(url string) string {\n\tfor _, config := range dc {\n\t\tif config.MetaSchemaURL == url {\n\t\t\treturn config.MetaSchema\n\t\t}\n\t}\n\treturn \"\"\n}\nfunc (dc draftConfigs) GetDraftVersion(url string) *Draft {\n\tfor _, config := range dc {\n\t\tif config.MetaSchemaURL == url {\n\t\t\treturn &config.Version\n\t\t}\n\t}\n\treturn nil\n}\nfunc (dc draftConfigs) GetSchemaURL(draft Draft) string {\n\tfor _, config := range dc {\n\t\tif config.Version == draft {\n\t\t\treturn config.MetaSchemaURL\n\t\t}\n\t}\n\treturn \"\"\n}\n\nfunc parseSchemaURL(documentNode interface{}) (string, *Draft, error) {\n\n\tif isKind(documentNode, reflect.Bool) {\n\t\treturn \"\", nil, nil\n\t}\n\n\tif !isKind(documentNode, reflect.Map) {\n\t\treturn \"\", nil, errors.New(\"schema is invalid\")\n\t}\n\n\tm := documentNode.(map[string]interface{})\n\n\tif existsMapKey(m, KEY_SCHEMA) {\n\t\tif !isKind(m[KEY_SCHEMA], reflect.String) {\n\t\t\treturn \"\", nil, errors.New(formatErrorDescription(\n\t\t\t\tLocale.MustBeOfType(),\n\t\t\t\tErrorDetails{\n\t\t\t\t\t\"key\":  KEY_SCHEMA,\n\t\t\t\t\t\"type\": TYPE_STRING,\n\t\t\t\t},\n\t\t\t))\n\t\t}\n\n\t\tschemaReference, err := gojsonreference.NewJsonReference(m[KEY_SCHEMA].(string))\n\n\t\tif err != nil {\n\t\t\treturn \"\", nil, err\n\t\t}\n\n\t\tschema := schemaReference.String()\n\n\t\treturn schema, drafts.GetDraftVersion(schema), nil\n\t}\n\n\treturn \"\", nil, nil\n}\n"
        },
        {
          "name": "errors.go",
          "type": "blob",
          "size": 9.0419921875,
          "content": "package gojsonschema\n\nimport (\n\t\"bytes\"\n\t\"sync\"\n\t\"text/template\"\n)\n\nvar errorTemplates = errorTemplate{template.New(\"errors-new\"), sync.RWMutex{}}\n\n// template.Template is not thread-safe for writing, so some locking is done\n// sync.RWMutex is used for efficiently locking when new templates are created\ntype errorTemplate struct {\n\t*template.Template\n\tsync.RWMutex\n}\n\ntype (\n\n\t// FalseError. ErrorDetails: -\n\tFalseError struct {\n\t\tResultErrorFields\n\t}\n\n\t// RequiredError indicates that a required field is missing\n\t// ErrorDetails: property string\n\tRequiredError struct {\n\t\tResultErrorFields\n\t}\n\n\t// InvalidTypeError indicates that a field has the incorrect type\n\t// ErrorDetails: expected, given\n\tInvalidTypeError struct {\n\t\tResultErrorFields\n\t}\n\n\t// NumberAnyOfError is produced in case of a failing \"anyOf\" validation\n\t// ErrorDetails: -\n\tNumberAnyOfError struct {\n\t\tResultErrorFields\n\t}\n\n\t// NumberOneOfError is produced in case of a failing \"oneOf\" validation\n\t// ErrorDetails: -\n\tNumberOneOfError struct {\n\t\tResultErrorFields\n\t}\n\n\t// NumberAllOfError is produced in case of a failing \"allOf\" validation\n\t// ErrorDetails: -\n\tNumberAllOfError struct {\n\t\tResultErrorFields\n\t}\n\n\t// NumberNotError is produced if a \"not\" validation failed\n\t// ErrorDetails: -\n\tNumberNotError struct {\n\t\tResultErrorFields\n\t}\n\n\t// MissingDependencyError is produced in case of a \"missing dependency\" problem\n\t// ErrorDetails: dependency\n\tMissingDependencyError struct {\n\t\tResultErrorFields\n\t}\n\n\t// InternalError indicates an internal error\n\t// ErrorDetails: error\n\tInternalError struct {\n\t\tResultErrorFields\n\t}\n\n\t// ConstError indicates a const error\n\t// ErrorDetails: allowed\n\tConstError struct {\n\t\tResultErrorFields\n\t}\n\n\t// EnumError indicates an enum error\n\t// ErrorDetails: allowed\n\tEnumError struct {\n\t\tResultErrorFields\n\t}\n\n\t// ArrayNoAdditionalItemsError is produced if additional items were found, but not allowed\n\t// ErrorDetails: -\n\tArrayNoAdditionalItemsError struct {\n\t\tResultErrorFields\n\t}\n\n\t// ArrayMinItemsError is produced if an array contains less items than the allowed minimum\n\t// ErrorDetails: min\n\tArrayMinItemsError struct {\n\t\tResultErrorFields\n\t}\n\n\t// ArrayMaxItemsError is produced if an array contains more items than the allowed maximum\n\t// ErrorDetails: max\n\tArrayMaxItemsError struct {\n\t\tResultErrorFields\n\t}\n\n\t// ItemsMustBeUniqueError is produced if an array requires unique items, but contains non-unique items\n\t// ErrorDetails: type, i, j\n\tItemsMustBeUniqueError struct {\n\t\tResultErrorFields\n\t}\n\n\t// ArrayContainsError is produced if an array contains invalid items\n\t// ErrorDetails:\n\tArrayContainsError struct {\n\t\tResultErrorFields\n\t}\n\n\t// ArrayMinPropertiesError is produced if an object contains less properties than the allowed minimum\n\t// ErrorDetails: min\n\tArrayMinPropertiesError struct {\n\t\tResultErrorFields\n\t}\n\n\t// ArrayMaxPropertiesError is produced if an object contains more properties than the allowed maximum\n\t// ErrorDetails: max\n\tArrayMaxPropertiesError struct {\n\t\tResultErrorFields\n\t}\n\n\t// AdditionalPropertyNotAllowedError is produced if an object has additional properties, but not allowed\n\t// ErrorDetails: property\n\tAdditionalPropertyNotAllowedError struct {\n\t\tResultErrorFields\n\t}\n\n\t// InvalidPropertyPatternError is produced if an pattern was found\n\t// ErrorDetails: property, pattern\n\tInvalidPropertyPatternError struct {\n\t\tResultErrorFields\n\t}\n\n\t// InvalidPropertyNameError is produced if an invalid-named property was found\n\t// ErrorDetails: property\n\tInvalidPropertyNameError struct {\n\t\tResultErrorFields\n\t}\n\n\t// StringLengthGTEError is produced if a string is shorter than the minimum required length\n\t// ErrorDetails: min\n\tStringLengthGTEError struct {\n\t\tResultErrorFields\n\t}\n\n\t// StringLengthLTEError is produced if a string is longer than the maximum allowed length\n\t// ErrorDetails: max\n\tStringLengthLTEError struct {\n\t\tResultErrorFields\n\t}\n\n\t// DoesNotMatchPatternError is produced if a string does not match the defined pattern\n\t// ErrorDetails: pattern\n\tDoesNotMatchPatternError struct {\n\t\tResultErrorFields\n\t}\n\n\t// DoesNotMatchFormatError is produced if a string does not match the defined format\n\t// ErrorDetails: format\n\tDoesNotMatchFormatError struct {\n\t\tResultErrorFields\n\t}\n\n\t// MultipleOfError is produced if a number is not a multiple of the defined multipleOf\n\t// ErrorDetails: multiple\n\tMultipleOfError struct {\n\t\tResultErrorFields\n\t}\n\n\t// NumberGTEError is produced if a number is lower than the allowed minimum\n\t// ErrorDetails: min\n\tNumberGTEError struct {\n\t\tResultErrorFields\n\t}\n\n\t// NumberGTError is produced if a number is lower than, or equal to the specified minimum, and exclusiveMinimum is set\n\t// ErrorDetails: min\n\tNumberGTError struct {\n\t\tResultErrorFields\n\t}\n\n\t// NumberLTEError is produced if a number is higher than the allowed maximum\n\t// ErrorDetails: max\n\tNumberLTEError struct {\n\t\tResultErrorFields\n\t}\n\n\t// NumberLTError is produced if a number is higher than, or equal to the specified maximum, and exclusiveMaximum is set\n\t// ErrorDetails: max\n\tNumberLTError struct {\n\t\tResultErrorFields\n\t}\n\n\t// ConditionThenError is produced if a condition's \"then\" validation is invalid\n\t// ErrorDetails: -\n\tConditionThenError struct {\n\t\tResultErrorFields\n\t}\n\n\t// ConditionElseError is produced if a condition's \"else\" condition is invalid\n\t// ErrorDetails: -\n\tConditionElseError struct {\n\t\tResultErrorFields\n\t}\n)\n\n// newError takes a ResultError type and sets the type, context, description, details, value, and field\nfunc newError(err ResultError, context *JsonContext, value interface{}, locale locale, details ErrorDetails) {\n\tvar t string\n\tvar d string\n\tswitch err.(type) {\n\tcase *FalseError:\n\t\tt = \"false\"\n\t\td = locale.False()\n\tcase *RequiredError:\n\t\tt = \"required\"\n\t\td = locale.Required()\n\tcase *InvalidTypeError:\n\t\tt = \"invalid_type\"\n\t\td = locale.InvalidType()\n\tcase *NumberAnyOfError:\n\t\tt = \"number_any_of\"\n\t\td = locale.NumberAnyOf()\n\tcase *NumberOneOfError:\n\t\tt = \"number_one_of\"\n\t\td = locale.NumberOneOf()\n\tcase *NumberAllOfError:\n\t\tt = \"number_all_of\"\n\t\td = locale.NumberAllOf()\n\tcase *NumberNotError:\n\t\tt = \"number_not\"\n\t\td = locale.NumberNot()\n\tcase *MissingDependencyError:\n\t\tt = \"missing_dependency\"\n\t\td = locale.MissingDependency()\n\tcase *InternalError:\n\t\tt = \"internal\"\n\t\td = locale.Internal()\n\tcase *ConstError:\n\t\tt = \"const\"\n\t\td = locale.Const()\n\tcase *EnumError:\n\t\tt = \"enum\"\n\t\td = locale.Enum()\n\tcase *ArrayNoAdditionalItemsError:\n\t\tt = \"array_no_additional_items\"\n\t\td = locale.ArrayNoAdditionalItems()\n\tcase *ArrayMinItemsError:\n\t\tt = \"array_min_items\"\n\t\td = locale.ArrayMinItems()\n\tcase *ArrayMaxItemsError:\n\t\tt = \"array_max_items\"\n\t\td = locale.ArrayMaxItems()\n\tcase *ItemsMustBeUniqueError:\n\t\tt = \"unique\"\n\t\td = locale.Unique()\n\tcase *ArrayContainsError:\n\t\tt = \"contains\"\n\t\td = locale.ArrayContains()\n\tcase *ArrayMinPropertiesError:\n\t\tt = \"array_min_properties\"\n\t\td = locale.ArrayMinProperties()\n\tcase *ArrayMaxPropertiesError:\n\t\tt = \"array_max_properties\"\n\t\td = locale.ArrayMaxProperties()\n\tcase *AdditionalPropertyNotAllowedError:\n\t\tt = \"additional_property_not_allowed\"\n\t\td = locale.AdditionalPropertyNotAllowed()\n\tcase *InvalidPropertyPatternError:\n\t\tt = \"invalid_property_pattern\"\n\t\td = locale.InvalidPropertyPattern()\n\tcase *InvalidPropertyNameError:\n\t\tt = \"invalid_property_name\"\n\t\td = locale.InvalidPropertyName()\n\tcase *StringLengthGTEError:\n\t\tt = \"string_gte\"\n\t\td = locale.StringGTE()\n\tcase *StringLengthLTEError:\n\t\tt = \"string_lte\"\n\t\td = locale.StringLTE()\n\tcase *DoesNotMatchPatternError:\n\t\tt = \"pattern\"\n\t\td = locale.DoesNotMatchPattern()\n\tcase *DoesNotMatchFormatError:\n\t\tt = \"format\"\n\t\td = locale.DoesNotMatchFormat()\n\tcase *MultipleOfError:\n\t\tt = \"multiple_of\"\n\t\td = locale.MultipleOf()\n\tcase *NumberGTEError:\n\t\tt = \"number_gte\"\n\t\td = locale.NumberGTE()\n\tcase *NumberGTError:\n\t\tt = \"number_gt\"\n\t\td = locale.NumberGT()\n\tcase *NumberLTEError:\n\t\tt = \"number_lte\"\n\t\td = locale.NumberLTE()\n\tcase *NumberLTError:\n\t\tt = \"number_lt\"\n\t\td = locale.NumberLT()\n\tcase *ConditionThenError:\n\t\tt = \"condition_then\"\n\t\td = locale.ConditionThen()\n\tcase *ConditionElseError:\n\t\tt = \"condition_else\"\n\t\td = locale.ConditionElse()\n\t}\n\n\terr.SetType(t)\n\terr.SetContext(context)\n\terr.SetValue(value)\n\terr.SetDetails(details)\n\terr.SetDescriptionFormat(d)\n\tdetails[\"field\"] = err.Field()\n\n\tif _, exists := details[\"context\"]; !exists && context != nil {\n\t\tdetails[\"context\"] = context.String()\n\t}\n\n\terr.SetDescription(formatErrorDescription(err.DescriptionFormat(), details))\n}\n\n// formatErrorDescription takes a string in the default text/template\n// format and converts it to a string with replacements. The fields come\n// from the ErrorDetails struct and vary for each type of error.\nfunc formatErrorDescription(s string, details ErrorDetails) string {\n\n\tvar tpl *template.Template\n\tvar descrAsBuffer bytes.Buffer\n\tvar err error\n\n\terrorTemplates.RLock()\n\ttpl = errorTemplates.Lookup(s)\n\terrorTemplates.RUnlock()\n\n\tif tpl == nil {\n\t\terrorTemplates.Lock()\n\t\ttpl = errorTemplates.New(s)\n\n\t\tif ErrorTemplateFuncs != nil {\n\t\t\ttpl.Funcs(ErrorTemplateFuncs)\n\t\t}\n\n\t\ttpl, err = tpl.Parse(s)\n\t\terrorTemplates.Unlock()\n\n\t\tif err != nil {\n\t\t\treturn err.Error()\n\t\t}\n\t}\n\n\terr = tpl.Execute(&descrAsBuffer, details)\n\tif err != nil {\n\t\treturn err.Error()\n\t}\n\n\treturn descrAsBuffer.String()\n}\n"
        },
        {
          "name": "format_checkers.go",
          "type": "blob",
          "size": 9.701171875,
          "content": "package gojsonschema\n\nimport (\n\t\"net\"\n\t\"net/mail\"\n\t\"net/url\"\n\t\"regexp\"\n\t\"strings\"\n\t\"sync\"\n\t\"time\"\n)\n\ntype (\n\t// FormatChecker is the interface all formatters added to FormatCheckerChain must implement\n\tFormatChecker interface {\n\t\t// IsFormat checks if input has the correct format\n\t\tIsFormat(input interface{}) bool\n\t}\n\n\t// FormatCheckerChain holds the formatters\n\tFormatCheckerChain struct {\n\t\tformatters map[string]FormatChecker\n\t}\n\n\t// EmailFormatChecker verifies email address formats\n\tEmailFormatChecker struct{}\n\n\t// IPV4FormatChecker verifies IP addresses in the IPv4 format\n\tIPV4FormatChecker struct{}\n\n\t// IPV6FormatChecker verifies IP addresses in the IPv6 format\n\tIPV6FormatChecker struct{}\n\n\t// DateTimeFormatChecker verifies date/time formats per RFC3339 5.6\n\t//\n\t// Valid formats:\n\t// \t\tPartial Time: HH:MM:SS\n\t//\t\tFull Date: YYYY-MM-DD\n\t// \t\tFull Time: HH:MM:SSZ-07:00\n\t//\t\tDate Time: YYYY-MM-DDTHH:MM:SSZ-0700\n\t//\n\t// \tWhere\n\t//\t\tYYYY = 4DIGIT year\n\t//\t\tMM = 2DIGIT month ; 01-12\n\t//\t\tDD = 2DIGIT day-month ; 01-28, 01-29, 01-30, 01-31 based on month/year\n\t//\t\tHH = 2DIGIT hour ; 00-23\n\t//\t\tMM = 2DIGIT ; 00-59\n\t//\t\tSS = 2DIGIT ; 00-58, 00-60 based on leap second rules\n\t//\t\tT = Literal\n\t//\t\tZ = Literal\n\t//\n\t//\tNote: Nanoseconds are also suported in all formats\n\t//\n\t// http://tools.ietf.org/html/rfc3339#section-5.6\n\tDateTimeFormatChecker struct{}\n\n\t// DateFormatChecker verifies date formats\n\t//\n\t// Valid format:\n\t//\t\tFull Date: YYYY-MM-DD\n\t//\n\t// \tWhere\n\t//\t\tYYYY = 4DIGIT year\n\t//\t\tMM = 2DIGIT month ; 01-12\n\t//\t\tDD = 2DIGIT day-month ; 01-28, 01-29, 01-30, 01-31 based on month/year\n\tDateFormatChecker struct{}\n\n\t// TimeFormatChecker verifies time formats\n\t//\n\t// Valid formats:\n\t// \t\tPartial Time: HH:MM:SS\n\t// \t\tFull Time: HH:MM:SSZ-07:00\n\t//\n\t// \tWhere\n\t//\t\tHH = 2DIGIT hour ; 00-23\n\t//\t\tMM = 2DIGIT ; 00-59\n\t//\t\tSS = 2DIGIT ; 00-58, 00-60 based on leap second rules\n\t//\t\tT = Literal\n\t//\t\tZ = Literal\n\tTimeFormatChecker struct{}\n\n\t// URIFormatChecker validates a URI with a valid Scheme per RFC3986\n\tURIFormatChecker struct{}\n\n\t// URIReferenceFormatChecker validates a URI or relative-reference per RFC3986\n\tURIReferenceFormatChecker struct{}\n\n\t// URITemplateFormatChecker validates a URI template per RFC6570\n\tURITemplateFormatChecker struct{}\n\n\t// HostnameFormatChecker validates a hostname is in the correct format\n\tHostnameFormatChecker struct{}\n\n\t// UUIDFormatChecker validates a UUID is in the correct format\n\tUUIDFormatChecker struct{}\n\n\t// RegexFormatChecker validates a regex is in the correct format\n\tRegexFormatChecker struct{}\n\n\t// JSONPointerFormatChecker validates a JSON Pointer per RFC6901\n\tJSONPointerFormatChecker struct{}\n\n\t// RelativeJSONPointerFormatChecker validates a relative JSON Pointer is in the correct format\n\tRelativeJSONPointerFormatChecker struct{}\n)\n\nvar (\n\t// FormatCheckers holds the valid formatters, and is a public variable\n\t// so library users can add custom formatters\n\tFormatCheckers = FormatCheckerChain{\n\t\tformatters: map[string]FormatChecker{\n\t\t\t\"date\":                  DateFormatChecker{},\n\t\t\t\"time\":                  TimeFormatChecker{},\n\t\t\t\"date-time\":             DateTimeFormatChecker{},\n\t\t\t\"hostname\":              HostnameFormatChecker{},\n\t\t\t\"email\":                 EmailFormatChecker{},\n\t\t\t\"idn-email\":             EmailFormatChecker{},\n\t\t\t\"ipv4\":                  IPV4FormatChecker{},\n\t\t\t\"ipv6\":                  IPV6FormatChecker{},\n\t\t\t\"uri\":                   URIFormatChecker{},\n\t\t\t\"uri-reference\":         URIReferenceFormatChecker{},\n\t\t\t\"iri\":                   URIFormatChecker{},\n\t\t\t\"iri-reference\":         URIReferenceFormatChecker{},\n\t\t\t\"uri-template\":          URITemplateFormatChecker{},\n\t\t\t\"uuid\":                  UUIDFormatChecker{},\n\t\t\t\"regex\":                 RegexFormatChecker{},\n\t\t\t\"json-pointer\":          JSONPointerFormatChecker{},\n\t\t\t\"relative-json-pointer\": RelativeJSONPointerFormatChecker{},\n\t\t},\n\t}\n\n\t// Regex credit: https://www.socketloop.com/tutorials/golang-validate-hostname\n\trxHostname = regexp.MustCompile(`^([a-zA-Z0-9]|[a-zA-Z0-9][a-zA-Z0-9\\-]{0,61}[a-zA-Z0-9])(\\.([a-zA-Z0-9]|[a-zA-Z0-9][a-zA-Z0-9\\-]{0,61}[a-zA-Z0-9]))*$`)\n\n\t// Use a regex to make sure curly brackets are balanced properly after validating it as a AURI\n\trxURITemplate = regexp.MustCompile(\"^([^{]*({[^}]*})?)*$\")\n\n\trxUUID = regexp.MustCompile(\"^(?i)[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$\")\n\n\trxJSONPointer = regexp.MustCompile(\"^(?:/(?:[^~/]|~0|~1)*)*$\")\n\n\trxRelJSONPointer = regexp.MustCompile(\"^(?:0|[1-9][0-9]*)(?:#|(?:/(?:[^~/]|~0|~1)*)*)$\")\n\n\tlock = new(sync.RWMutex)\n)\n\n// Add adds a FormatChecker to the FormatCheckerChain\n// The name used will be the value used for the format key in your json schema\nfunc (c *FormatCheckerChain) Add(name string, f FormatChecker) *FormatCheckerChain {\n\tlock.Lock()\n\tc.formatters[name] = f\n\tlock.Unlock()\n\n\treturn c\n}\n\n// Remove deletes a FormatChecker from the FormatCheckerChain (if it exists)\nfunc (c *FormatCheckerChain) Remove(name string) *FormatCheckerChain {\n\tlock.Lock()\n\tdelete(c.formatters, name)\n\tlock.Unlock()\n\n\treturn c\n}\n\n// Has checks to see if the FormatCheckerChain holds a FormatChecker with the given name\nfunc (c *FormatCheckerChain) Has(name string) bool {\n\tlock.RLock()\n\t_, ok := c.formatters[name]\n\tlock.RUnlock()\n\n\treturn ok\n}\n\n// IsFormat will check an input against a FormatChecker with the given name\n// to see if it is the correct format\nfunc (c *FormatCheckerChain) IsFormat(name string, input interface{}) bool {\n\tlock.RLock()\n\tf, ok := c.formatters[name]\n\tlock.RUnlock()\n\n\t// If a format is unrecognized it should always pass validation\n\tif !ok {\n\t\treturn true\n\t}\n\n\treturn f.IsFormat(input)\n}\n\n// IsFormat checks if input is a correctly formatted e-mail address\nfunc (f EmailFormatChecker) IsFormat(input interface{}) bool {\n\tasString, ok := input.(string)\n\tif !ok {\n\t\treturn true\n\t}\n\n\t_, err := mail.ParseAddress(asString)\n\treturn err == nil\n}\n\n// IsFormat checks if input is a correctly formatted IPv4-address\nfunc (f IPV4FormatChecker) IsFormat(input interface{}) bool {\n\tasString, ok := input.(string)\n\tif !ok {\n\t\treturn true\n\t}\n\n\t// Credit: https://github.com/asaskevich/govalidator\n\tip := net.ParseIP(asString)\n\treturn ip != nil && strings.Contains(asString, \".\")\n}\n\n// IsFormat checks if input is a correctly formatted IPv6=address\nfunc (f IPV6FormatChecker) IsFormat(input interface{}) bool {\n\tasString, ok := input.(string)\n\tif !ok {\n\t\treturn true\n\t}\n\n\t// Credit: https://github.com/asaskevich/govalidator\n\tip := net.ParseIP(asString)\n\treturn ip != nil && strings.Contains(asString, \":\")\n}\n\n// IsFormat checks if input is a correctly formatted  date/time per RFC3339 5.6\nfunc (f DateTimeFormatChecker) IsFormat(input interface{}) bool {\n\tasString, ok := input.(string)\n\tif !ok {\n\t\treturn true\n\t}\n\n\tformats := []string{\n\t\t\"15:04:05\",\n\t\t\"15:04:05Z07:00\",\n\t\t\"2006-01-02\",\n\t\ttime.RFC3339,\n\t\ttime.RFC3339Nano,\n\t}\n\n\tfor _, format := range formats {\n\t\tif _, err := time.Parse(format, asString); err == nil {\n\t\t\treturn true\n\t\t}\n\t}\n\n\treturn false\n}\n\n// IsFormat checks if input is a correctly formatted  date (YYYY-MM-DD)\nfunc (f DateFormatChecker) IsFormat(input interface{}) bool {\n\tasString, ok := input.(string)\n\tif !ok {\n\t\treturn true\n\t}\n\t_, err := time.Parse(\"2006-01-02\", asString)\n\treturn err == nil\n}\n\n// IsFormat checks if input correctly formatted time (HH:MM:SS or HH:MM:SSZ-07:00)\nfunc (f TimeFormatChecker) IsFormat(input interface{}) bool {\n\tasString, ok := input.(string)\n\tif !ok {\n\t\treturn true\n\t}\n\n\tif _, err := time.Parse(\"15:04:05Z07:00\", asString); err == nil {\n\t\treturn true\n\t}\n\n\t_, err := time.Parse(\"15:04:05\", asString)\n\treturn err == nil\n}\n\n// IsFormat checks if input is correctly formatted  URI with a valid Scheme per RFC3986\nfunc (f URIFormatChecker) IsFormat(input interface{}) bool {\n\tasString, ok := input.(string)\n\tif !ok {\n\t\treturn true\n\t}\n\n\tu, err := url.Parse(asString)\n\n\tif err != nil || u.Scheme == \"\" {\n\t\treturn false\n\t}\n\n\treturn !strings.Contains(asString, `\\`)\n}\n\n// IsFormat checks if input is a correctly formatted URI or relative-reference per RFC3986\nfunc (f URIReferenceFormatChecker) IsFormat(input interface{}) bool {\n\tasString, ok := input.(string)\n\tif !ok {\n\t\treturn true\n\t}\n\n\t_, err := url.Parse(asString)\n\treturn err == nil && !strings.Contains(asString, `\\`)\n}\n\n// IsFormat checks if input is a correctly formatted URI template per RFC6570\nfunc (f URITemplateFormatChecker) IsFormat(input interface{}) bool {\n\tasString, ok := input.(string)\n\tif !ok {\n\t\treturn true\n\t}\n\n\tu, err := url.Parse(asString)\n\tif err != nil || strings.Contains(asString, `\\`) {\n\t\treturn false\n\t}\n\n\treturn rxURITemplate.MatchString(u.Path)\n}\n\n// IsFormat checks if input is a correctly formatted hostname\nfunc (f HostnameFormatChecker) IsFormat(input interface{}) bool {\n\tasString, ok := input.(string)\n\tif !ok {\n\t\treturn true\n\t}\n\n\treturn rxHostname.MatchString(asString) && len(asString) < 256\n}\n\n// IsFormat checks if input is a correctly formatted UUID\nfunc (f UUIDFormatChecker) IsFormat(input interface{}) bool {\n\tasString, ok := input.(string)\n\tif !ok {\n\t\treturn true\n\t}\n\n\treturn rxUUID.MatchString(asString)\n}\n\n// IsFormat checks if input is a correctly formatted regular expression\nfunc (f RegexFormatChecker) IsFormat(input interface{}) bool {\n\tasString, ok := input.(string)\n\tif !ok {\n\t\treturn true\n\t}\n\n\tif asString == \"\" {\n\t\treturn true\n\t}\n\t_, err := regexp.Compile(asString)\n\treturn err == nil\n}\n\n// IsFormat checks if input is a correctly formatted JSON Pointer per RFC6901\nfunc (f JSONPointerFormatChecker) IsFormat(input interface{}) bool {\n\tasString, ok := input.(string)\n\tif !ok {\n\t\treturn true\n\t}\n\n\treturn rxJSONPointer.MatchString(asString)\n}\n\n// IsFormat checks if input is a correctly formatted relative JSON Pointer\nfunc (f RelativeJSONPointerFormatChecker) IsFormat(input interface{}) bool {\n\tasString, ok := input.(string)\n\tif !ok {\n\t\treturn true\n\t}\n\n\treturn rxRelJSONPointer.MatchString(asString)\n}\n"
        },
        {
          "name": "format_checkers_test.go",
          "type": "blob",
          "size": 3.123046875,
          "content": "package gojsonschema\n\nimport (\n\t\"encoding/json\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestUUIDFormatCheckerIsFormat(t *testing.T) {\n\tchecker := UUIDFormatChecker{}\n\n\tassert.True(t, checker.IsFormat(\"01234567-89ab-cdef-0123-456789abcdef\"))\n\tassert.True(t, checker.IsFormat(\"f1234567-89ab-cdef-0123-456789abcdef\"))\n\tassert.True(t, checker.IsFormat(\"01234567-89AB-CDEF-0123-456789ABCDEF\"))\n\tassert.True(t, checker.IsFormat(\"F1234567-89AB-CDEF-0123-456789ABCDEF\"))\n\n\tassert.False(t, checker.IsFormat(\"not-a-uuid\"))\n\tassert.False(t, checker.IsFormat(\"g1234567-89ab-cdef-0123-456789abcdef\"))\n}\n\nfunc TestURIReferenceFormatCheckerIsFormat(t *testing.T) {\n\tchecker := URIReferenceFormatChecker{}\n\n\tassert.True(t, checker.IsFormat(\"relative\"))\n\tassert.True(t, checker.IsFormat(\"https://dummyhost.com/dummy-path?dummy-qp-name=dummy-qp-value\"))\n}\n\nconst formatSchema = `{\n\t\"type\": \"object\",\n\t\"properties\": {\n\t\t\"arr\":  {\"type\": \"array\", \"items\": {\"type\": \"string\"}, \"format\": \"ArrayChecker\"},\n\t\t\"bool\": {\"type\": \"boolean\", \"format\": \"BoolChecker\"},\n\t\t\"int\":  {\"format\": \"IntegerChecker\"},\n\t\t\"name\": {\"type\": \"string\"},\n\t\t\"str\":  {\"type\": \"string\", \"format\": \"StringChecker\"}\n\t},\n\t\"format\": \"ObjectChecker\",\n\t\"required\": [\"name\"]\n}`\n\ntype arrayChecker struct{}\n\nfunc (c arrayChecker) IsFormat(input interface{}) bool {\n\tarr, ok := input.([]interface{})\n\tif !ok {\n\t\treturn true\n\t}\n\tfor _, v := range arr {\n\t\tif v == \"x\" {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\ntype boolChecker struct{}\n\nfunc (c boolChecker) IsFormat(input interface{}) bool {\n\tb, ok := input.(bool)\n\tif !ok {\n\t\treturn true\n\t}\n\treturn b\n}\n\ntype integerChecker struct{}\n\nfunc (c integerChecker) IsFormat(input interface{}) bool {\n\tnumber, ok := input.(json.Number)\n\tif !ok {\n\t\treturn true\n\t}\n\tf, _ := number.Float64()\n\treturn int(f)%2 == 0\n}\n\ntype objectChecker struct{}\n\nfunc (c objectChecker) IsFormat(input interface{}) bool {\n\tobj, ok := input.(map[string]interface{})\n\tif !ok {\n\t\treturn true\n\t}\n\treturn obj[\"name\"] == \"x\"\n}\n\ntype stringChecker struct{}\n\nfunc (c stringChecker) IsFormat(input interface{}) bool {\n\tstr, ok := input.(string)\n\tif !ok {\n\t\treturn true\n\t}\n\treturn str == \"o\"\n}\n\nfunc TestCustomFormat(t *testing.T) {\n\tFormatCheckers.\n\t\tAdd(\"ArrayChecker\", arrayChecker{}).\n\t\tAdd(\"BoolChecker\", boolChecker{}).\n\t\tAdd(\"IntegerChecker\", integerChecker{}).\n\t\tAdd(\"ObjectChecker\", objectChecker{}).\n\t\tAdd(\"StringChecker\", stringChecker{})\n\n\tsl := NewStringLoader(formatSchema)\n\tvalidResult, err := Validate(sl, NewGoLoader(map[string]interface{}{\n\t\t\"arr\":  []string{\"x\", \"y\", \"z\"},\n\t\t\"bool\": true,\n\t\t\"int\":  \"2\", // format not defined for string\n\t\t\"name\": \"x\",\n\t\t\"str\":  \"o\",\n\t}))\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n\n\tif !validResult.Valid() {\n\t\tfor _, desc := range validResult.Errors() {\n\t\t\tt.Error(desc)\n\t\t}\n\t}\n\n\tinvalidResult, err := Validate(sl, NewGoLoader(map[string]interface{}{\n\t\t\"arr\":  []string{\"a\", \"b\", \"c\"},\n\t\t\"bool\": false,\n\t\t\"int\":  1,\n\t\t\"name\": \"z\",\n\t\t\"str\":  \"a\",\n\t}))\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n\n\tassert.Len(t, invalidResult.Errors(), 5)\n\n\tFormatCheckers.\n\t\tRemove(\"ArrayChecker\").\n\t\tRemove(\"BoolChecker\").\n\t\tRemove(\"IntegerChecker\").\n\t\tRemove(\"ObjectChecker\").\n\t\tRemove(\"StringChecker\")\n}\n"
        },
        {
          "name": "glide.yaml",
          "type": "blob",
          "size": 0.275390625,
          "content": "package: github.com/xeipuuv/gojsonschema\nlicense: Apache 2.0\nimport:\n- package: github.com/xeipuuv/gojsonschema\n\n- package: github.com/xeipuuv/gojsonpointer\n\n- package: github.com/xeipuuv/gojsonreference\n\ntestImport:\n- package: github.com/stretchr/testify\n  subpackages:\n  - assert\n"
        },
        {
          "name": "go.mod",
          "type": "blob",
          "size": 0.234375,
          "content": "module github.com/xeipuuv/gojsonschema\n\nrequire (\n\tgithub.com/stretchr/testify v1.3.0\n\tgithub.com/xeipuuv/gojsonpointer v0.0.0-20180127040702-4e3ac2762d5f // indirect\n\tgithub.com/xeipuuv/gojsonreference v0.0.0-20180127040603-bd5ef7bd5415\n)\n"
        },
        {
          "name": "go.sum",
          "type": "blob",
          "size": 1.064453125,
          "content": "github.com/davecgh/go-spew v1.1.0 h1:ZDRjVQ15GmhC3fiQ8ni8+OwkZQO4DARzQgrnXU1Liz8=\ngithub.com/davecgh/go-spew v1.1.0/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=\ngithub.com/pmezard/go-difflib v1.0.0 h1:4DBwDE0NGyQoBHbLQYPwSUPoCMWR5BEzIk/f1lZbAQM=\ngithub.com/pmezard/go-difflib v1.0.0/go.mod h1:iKH77koFhYxTK1pcRnkKkqfTogsbg7gZNVY4sRDYZ/4=\ngithub.com/stretchr/objx v0.1.0/go.mod h1:HFkY916IF+rwdDfMAkV7OtwuqBVzrE8GR6GFx+wExME=\ngithub.com/stretchr/testify v1.3.0 h1:TivCn/peBQ7UY8ooIcPgZFpTNSz0Q2U6UrFlUfqbe0Q=\ngithub.com/stretchr/testify v1.3.0/go.mod h1:M5WIy9Dh21IEIfnGCwXGc5bZfKNJtfHm1UVUgZn+9EI=\ngithub.com/xeipuuv/gojsonpointer v0.0.0-20180127040702-4e3ac2762d5f h1:J9EGpcZtP0E/raorCMxlFGSTBrsSlaDGf3jU/qvAE2c=\ngithub.com/xeipuuv/gojsonpointer v0.0.0-20180127040702-4e3ac2762d5f/go.mod h1:N2zxlSyiKSe5eX1tZViRH5QA0qijqEDrYZiPEAiq3wU=\ngithub.com/xeipuuv/gojsonreference v0.0.0-20180127040603-bd5ef7bd5415 h1:EzJWgHovont7NscjpAxXsDA8S8BMYve8Y5+7cuRE7R0=\ngithub.com/xeipuuv/gojsonreference v0.0.0-20180127040603-bd5ef7bd5415/go.mod h1:GwrjFmJcFw6At/Gs6z4yjiIwzuJ1/+UwLxMQDVQXShQ=\n"
        },
        {
          "name": "internalLog.go",
          "type": "blob",
          "size": 1.1123046875,
          "content": "// Copyright 2015 xeipuuv ( https://github.com/xeipuuv )\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n// author           xeipuuv\n// author-github    https://github.com/xeipuuv\n// author-mail      xeipuuv@gmail.com\n//\n// repository-name  gojsonschema\n// repository-desc  An implementation of JSON Schema, based on IETF's draft v4 - Go language.\n//\n// description      Very simple log wrapper.\n//\t\t\t\t\tUsed for debugging/testing purposes.\n//\n// created          01-01-2015\n\npackage gojsonschema\n\nimport (\n\t\"log\"\n)\n\nconst internalLogEnabled = false\n\nfunc internalLog(format string, v ...interface{}) {\n\tlog.Printf(format, v...)\n}\n"
        },
        {
          "name": "jsonContext.go",
          "type": "blob",
          "size": 2.0048828125,
          "content": "// Copyright 2013 MongoDB, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n// author           tolsen\n// author-github    https://github.com/tolsen\n//\n// repository-name  gojsonschema\n// repository-desc  An implementation of JSON Schema, based on IETF's draft v4 - Go language.\n//\n// description      Implements a persistent (immutable w/ shared structure) singly-linked list of strings for the purpose of storing a json context\n//\n// created          04-09-2013\n\npackage gojsonschema\n\nimport \"bytes\"\n\n// JsonContext implements a persistent linked-list of strings\ntype JsonContext struct {\n\thead string\n\ttail *JsonContext\n}\n\n// NewJsonContext creates a new JsonContext\nfunc NewJsonContext(head string, tail *JsonContext) *JsonContext {\n\treturn &JsonContext{head, tail}\n}\n\n// String displays the context in reverse.\n// This plays well with the data structure's persistent nature with\n// Cons and a json document's tree structure.\nfunc (c *JsonContext) String(del ...string) string {\n\tbyteArr := make([]byte, 0, c.stringLen())\n\tbuf := bytes.NewBuffer(byteArr)\n\tc.writeStringToBuffer(buf, del)\n\n\treturn buf.String()\n}\n\nfunc (c *JsonContext) stringLen() int {\n\tlength := 0\n\tif c.tail != nil {\n\t\tlength = c.tail.stringLen() + 1 // add 1 for \".\"\n\t}\n\n\tlength += len(c.head)\n\treturn length\n}\n\nfunc (c *JsonContext) writeStringToBuffer(buf *bytes.Buffer, del []string) {\n\tif c.tail != nil {\n\t\tc.tail.writeStringToBuffer(buf, del)\n\n\t\tif len(del) > 0 {\n\t\t\tbuf.WriteString(del[0])\n\t\t} else {\n\t\t\tbuf.WriteString(\".\")\n\t\t}\n\t}\n\n\tbuf.WriteString(c.head)\n}\n"
        },
        {
          "name": "jsonLoader.go",
          "type": "blob",
          "size": 9.5283203125,
          "content": "// Copyright 2015 xeipuuv ( https://github.com/xeipuuv )\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n// author           xeipuuv\n// author-github    https://github.com/xeipuuv\n// author-mail      xeipuuv@gmail.com\n//\n// repository-name  gojsonschema\n// repository-desc  An implementation of JSON Schema, based on IETF's draft v4 - Go language.\n//\n// description\t\tDifferent strategies to load JSON files.\n// \t\t\t\t\tIncludes References (file and HTTP), JSON strings and Go types.\n//\n// created          01-02-2015\n\npackage gojsonschema\n\nimport (\n\t\"bytes\"\n\t\"encoding/json\"\n\t\"errors\"\n\t\"io\"\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"net/url\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"runtime\"\n\t\"strings\"\n\n\t\"github.com/xeipuuv/gojsonreference\"\n)\n\nvar osFS = osFileSystem(os.Open)\n\n// JSONLoader defines the JSON loader interface\ntype JSONLoader interface {\n\tJsonSource() interface{}\n\tLoadJSON() (interface{}, error)\n\tJsonReference() (gojsonreference.JsonReference, error)\n\tLoaderFactory() JSONLoaderFactory\n}\n\n// JSONLoaderFactory defines the JSON loader factory interface\ntype JSONLoaderFactory interface {\n\t// New creates a new JSON loader for the given source\n\tNew(source string) JSONLoader\n}\n\n// DefaultJSONLoaderFactory is the default JSON loader factory\ntype DefaultJSONLoaderFactory struct {\n}\n\n// FileSystemJSONLoaderFactory is a JSON loader factory that uses http.FileSystem\ntype FileSystemJSONLoaderFactory struct {\n\tfs http.FileSystem\n}\n\n// New creates a new JSON loader for the given source\nfunc (d DefaultJSONLoaderFactory) New(source string) JSONLoader {\n\treturn &jsonReferenceLoader{\n\t\tfs:     osFS,\n\t\tsource: source,\n\t}\n}\n\n// New creates a new JSON loader for the given source\nfunc (f FileSystemJSONLoaderFactory) New(source string) JSONLoader {\n\treturn &jsonReferenceLoader{\n\t\tfs:     f.fs,\n\t\tsource: source,\n\t}\n}\n\n// osFileSystem is a functional wrapper for os.Open that implements http.FileSystem.\ntype osFileSystem func(string) (*os.File, error)\n\n// Opens a file with the given name\nfunc (o osFileSystem) Open(name string) (http.File, error) {\n\treturn o(name)\n}\n\n// JSON Reference loader\n// references are used to load JSONs from files and HTTP\n\ntype jsonReferenceLoader struct {\n\tfs     http.FileSystem\n\tsource string\n}\n\nfunc (l *jsonReferenceLoader) JsonSource() interface{} {\n\treturn l.source\n}\n\nfunc (l *jsonReferenceLoader) JsonReference() (gojsonreference.JsonReference, error) {\n\treturn gojsonreference.NewJsonReference(l.JsonSource().(string))\n}\n\nfunc (l *jsonReferenceLoader) LoaderFactory() JSONLoaderFactory {\n\treturn &FileSystemJSONLoaderFactory{\n\t\tfs: l.fs,\n\t}\n}\n\n// NewReferenceLoader returns a JSON reference loader using the given source and the local OS file system.\nfunc NewReferenceLoader(source string) JSONLoader {\n\treturn &jsonReferenceLoader{\n\t\tfs:     osFS,\n\t\tsource: source,\n\t}\n}\n\n// NewReferenceLoaderFileSystem returns a JSON reference loader using the given source and file system.\nfunc NewReferenceLoaderFileSystem(source string, fs http.FileSystem) JSONLoader {\n\treturn &jsonReferenceLoader{\n\t\tfs:     fs,\n\t\tsource: source,\n\t}\n}\n\nfunc (l *jsonReferenceLoader) LoadJSON() (interface{}, error) {\n\n\tvar err error\n\n\treference, err := gojsonreference.NewJsonReference(l.JsonSource().(string))\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\trefToURL := reference\n\trefToURL.GetUrl().Fragment = \"\"\n\n\tvar document interface{}\n\n\tif reference.HasFileScheme {\n\n\t\tfilename := strings.TrimPrefix(refToURL.String(), \"file://\")\n\t\tfilename, err = url.QueryUnescape(filename)\n\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tif runtime.GOOS == \"windows\" {\n\t\t\t// on Windows, a file URL may have an extra leading slash, use slashes\n\t\t\t// instead of backslashes, and have spaces escaped\n\t\t\tfilename = strings.TrimPrefix(filename, \"/\")\n\t\t\tfilename = filepath.FromSlash(filename)\n\t\t}\n\n\t\tdocument, err = l.loadFromFile(filename)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t} else {\n\n\t\tdocument, err = l.loadFromHTTP(refToURL.String())\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t}\n\n\treturn document, nil\n\n}\n\nfunc (l *jsonReferenceLoader) loadFromHTTP(address string) (interface{}, error) {\n\n\t// returned cached versions for metaschemas for drafts 4, 6 and 7\n\t// for performance and allow for easier offline use\n\tif metaSchema := drafts.GetMetaSchema(address); metaSchema != \"\" {\n\t\treturn decodeJSONUsingNumber(strings.NewReader(metaSchema))\n\t}\n\n\tresp, err := http.Get(address)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// must return HTTP Status 200 OK\n\tif resp.StatusCode != http.StatusOK {\n\t\treturn nil, errors.New(formatErrorDescription(Locale.HttpBadStatus(), ErrorDetails{\"status\": resp.Status}))\n\t}\n\n\tbodyBuff, err := ioutil.ReadAll(resp.Body)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn decodeJSONUsingNumber(bytes.NewReader(bodyBuff))\n}\n\nfunc (l *jsonReferenceLoader) loadFromFile(path string) (interface{}, error) {\n\tf, err := l.fs.Open(path)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer f.Close()\n\n\tbodyBuff, err := ioutil.ReadAll(f)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn decodeJSONUsingNumber(bytes.NewReader(bodyBuff))\n\n}\n\n// JSON string loader\n\ntype jsonStringLoader struct {\n\tsource string\n}\n\nfunc (l *jsonStringLoader) JsonSource() interface{} {\n\treturn l.source\n}\n\nfunc (l *jsonStringLoader) JsonReference() (gojsonreference.JsonReference, error) {\n\treturn gojsonreference.NewJsonReference(\"#\")\n}\n\nfunc (l *jsonStringLoader) LoaderFactory() JSONLoaderFactory {\n\treturn &DefaultJSONLoaderFactory{}\n}\n\n// NewStringLoader creates a new JSONLoader, taking a string as source\nfunc NewStringLoader(source string) JSONLoader {\n\treturn &jsonStringLoader{source: source}\n}\n\nfunc (l *jsonStringLoader) LoadJSON() (interface{}, error) {\n\n\treturn decodeJSONUsingNumber(strings.NewReader(l.JsonSource().(string)))\n\n}\n\n// JSON bytes loader\n\ntype jsonBytesLoader struct {\n\tsource []byte\n}\n\nfunc (l *jsonBytesLoader) JsonSource() interface{} {\n\treturn l.source\n}\n\nfunc (l *jsonBytesLoader) JsonReference() (gojsonreference.JsonReference, error) {\n\treturn gojsonreference.NewJsonReference(\"#\")\n}\n\nfunc (l *jsonBytesLoader) LoaderFactory() JSONLoaderFactory {\n\treturn &DefaultJSONLoaderFactory{}\n}\n\n// NewBytesLoader creates a new JSONLoader, taking a `[]byte` as source\nfunc NewBytesLoader(source []byte) JSONLoader {\n\treturn &jsonBytesLoader{source: source}\n}\n\nfunc (l *jsonBytesLoader) LoadJSON() (interface{}, error) {\n\treturn decodeJSONUsingNumber(bytes.NewReader(l.JsonSource().([]byte)))\n}\n\n// JSON Go (types) loader\n// used to load JSONs from the code as maps, interface{}, structs ...\n\ntype jsonGoLoader struct {\n\tsource interface{}\n}\n\nfunc (l *jsonGoLoader) JsonSource() interface{} {\n\treturn l.source\n}\n\nfunc (l *jsonGoLoader) JsonReference() (gojsonreference.JsonReference, error) {\n\treturn gojsonreference.NewJsonReference(\"#\")\n}\n\nfunc (l *jsonGoLoader) LoaderFactory() JSONLoaderFactory {\n\treturn &DefaultJSONLoaderFactory{}\n}\n\n// NewGoLoader creates a new JSONLoader from a given Go struct\nfunc NewGoLoader(source interface{}) JSONLoader {\n\treturn &jsonGoLoader{source: source}\n}\n\nfunc (l *jsonGoLoader) LoadJSON() (interface{}, error) {\n\n\t// convert it to a compliant JSON first to avoid types \"mismatches\"\n\n\tjsonBytes, err := json.Marshal(l.JsonSource())\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn decodeJSONUsingNumber(bytes.NewReader(jsonBytes))\n\n}\n\ntype jsonIOLoader struct {\n\tbuf *bytes.Buffer\n}\n\n// NewReaderLoader creates a new JSON loader using the provided io.Reader\nfunc NewReaderLoader(source io.Reader) (JSONLoader, io.Reader) {\n\tbuf := &bytes.Buffer{}\n\treturn &jsonIOLoader{buf: buf}, io.TeeReader(source, buf)\n}\n\n// NewWriterLoader creates a new JSON loader using the provided io.Writer\nfunc NewWriterLoader(source io.Writer) (JSONLoader, io.Writer) {\n\tbuf := &bytes.Buffer{}\n\treturn &jsonIOLoader{buf: buf}, io.MultiWriter(source, buf)\n}\n\nfunc (l *jsonIOLoader) JsonSource() interface{} {\n\treturn l.buf.String()\n}\n\nfunc (l *jsonIOLoader) LoadJSON() (interface{}, error) {\n\treturn decodeJSONUsingNumber(l.buf)\n}\n\nfunc (l *jsonIOLoader) JsonReference() (gojsonreference.JsonReference, error) {\n\treturn gojsonreference.NewJsonReference(\"#\")\n}\n\nfunc (l *jsonIOLoader) LoaderFactory() JSONLoaderFactory {\n\treturn &DefaultJSONLoaderFactory{}\n}\n\n// JSON raw loader\n// In case the JSON is already marshalled to interface{} use this loader\n// This is used for testing as otherwise there is no guarantee the JSON is marshalled\n// \"properly\" by using https://golang.org/pkg/encoding/json/#Decoder.UseNumber\ntype jsonRawLoader struct {\n\tsource interface{}\n}\n\n// NewRawLoader creates a new JSON raw loader for the given source\nfunc NewRawLoader(source interface{}) JSONLoader {\n\treturn &jsonRawLoader{source: source}\n}\nfunc (l *jsonRawLoader) JsonSource() interface{} {\n\treturn l.source\n}\nfunc (l *jsonRawLoader) LoadJSON() (interface{}, error) {\n\treturn l.source, nil\n}\nfunc (l *jsonRawLoader) JsonReference() (gojsonreference.JsonReference, error) {\n\treturn gojsonreference.NewJsonReference(\"#\")\n}\nfunc (l *jsonRawLoader) LoaderFactory() JSONLoaderFactory {\n\treturn &DefaultJSONLoaderFactory{}\n}\n\nfunc decodeJSONUsingNumber(r io.Reader) (interface{}, error) {\n\n\tvar document interface{}\n\n\tdecoder := json.NewDecoder(r)\n\tdecoder.UseNumber()\n\n\terr := decoder.Decode(&document)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn document, nil\n\n}\n"
        },
        {
          "name": "jsonschema_test.go",
          "type": "blob",
          "size": 4.5126953125,
          "content": "// Copyright 2017 johandorland ( https://github.com/johandorland )\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage gojsonschema\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"regexp\"\n\t\"strings\"\n\t\"testing\"\n)\n\ntype jsonSchemaTest struct {\n\tDescription string `json:\"description\"`\n\t// Some tests may not always pass, so some tests are manually edited to include\n\t// an extra attribute whether that specific test should be disabled and skipped\n\tDisabled bool                 `json:\"disabled\"`\n\tSchema   interface{}          `json:\"schema\"`\n\tTests    []jsonSchemaTestCase `json:\"tests\"`\n}\ntype jsonSchemaTestCase struct {\n\tDescription string      `json:\"description\"`\n\tData        interface{} `json:\"data\"`\n\tValid       bool        `json:\"valid\"`\n}\n\n//Skip any directories not named appropiately\n// filepath.Walk will also visit files in the root of the test directory\nvar testDirectories = regexp.MustCompile(`(draft\\d+)`)\nvar draftMapping = map[string]Draft{\n\t\"draft4\": Draft4,\n\t\"draft6\": Draft6,\n\t\"draft7\": Draft7,\n}\n\nfunc executeTests(t *testing.T, path string) error {\n\tfile, err := os.Open(path)\n\tif err != nil {\n\t\tt.Errorf(\"Error (%s)\\n\", err.Error())\n\t}\n\tfmt.Println(file.Name())\n\n\tvar tests []jsonSchemaTest\n\td := json.NewDecoder(file)\n\td.UseNumber()\n\terr = d.Decode(&tests)\n\n\tif err != nil {\n\t\tt.Errorf(\"Error (%s)\\n\", err.Error())\n\t}\n\n\tdraft := Hybrid\n\tif m := testDirectories.FindString(path); m != \"\" {\n\t\tdraft = draftMapping[m]\n\t}\n\n\tfor _, test := range tests {\n\t\tfmt.Println(\"    \" + test.Description)\n\n\t\tif test.Disabled {\n\t\t\tcontinue\n\t\t}\n\n\t\ttestSchemaLoader := NewRawLoader(test.Schema)\n\t\tsl := NewSchemaLoader()\n\t\tsl.Draft = draft\n\t\tsl.Validate = true\n\t\ttestSchema, err := sl.Compile(testSchemaLoader)\n\n\t\tif err != nil {\n\t\t\tt.Errorf(\"Error (%s)\\n\", err.Error())\n\t\t}\n\n\t\tfor _, testCase := range test.Tests {\n\t\t\ttestDataLoader := NewRawLoader(testCase.Data)\n\t\t\tresult, err := testSchema.Validate(testDataLoader)\n\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"Error (%s)\\n\", err.Error())\n\t\t\t}\n\n\t\t\tif result.Valid() != testCase.Valid {\n\t\t\t\tschemaString, _ := marshalToJSONString(test.Schema)\n\t\t\t\ttestCaseString, _ := marshalToJSONString(testCase.Data)\n\n\t\t\t\tt.Errorf(\"Test failed : %s\\n\"+\n\t\t\t\t\t\"%s.\\n\"+\n\t\t\t\t\t\"%s.\\n\"+\n\t\t\t\t\t\"expects: %t, given %t\\n\"+\n\t\t\t\t\t\"Schema: %s\\n\"+\n\t\t\t\t\t\"Data: %s\\n\",\n\t\t\t\t\tfile.Name(),\n\t\t\t\t\ttest.Description,\n\t\t\t\t\ttestCase.Description,\n\t\t\t\t\ttestCase.Valid,\n\t\t\t\t\tresult.Valid(),\n\t\t\t\t\t*schemaString,\n\t\t\t\t\t*testCaseString)\n\t\t\t}\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc TestSuite(t *testing.T) {\n\n\twd, err := os.Getwd()\n\tif err != nil {\n\t\tpanic(err.Error())\n\t}\n\twd = filepath.Join(wd, \"testdata\")\n\n\tgo func() {\n\t\terr := http.ListenAndServe(\":1234\", http.FileServer(http.Dir(filepath.Join(wd, \"remotes\"))))\n\t\tif err != nil {\n\n\t\t\tpanic(err.Error())\n\t\t}\n\t}()\n\n\terr = filepath.Walk(wd, func(path string, fileInfo os.FileInfo, err error) error {\n\t\tif fileInfo.IsDir() && path != wd && !testDirectories.MatchString(fileInfo.Name()) {\n\t\t\treturn filepath.SkipDir\n\t\t}\n\t\tif !strings.HasSuffix(fileInfo.Name(), \".json\") {\n\t\t\treturn nil\n\t\t}\n\t\treturn executeTests(t, path)\n\t})\n\tif err != nil {\n\t\tt.Errorf(\"Error (%s)\\n\", err.Error())\n\t}\n}\n\nfunc TestFormats(t *testing.T) {\n\twd, err := os.Getwd()\n\tif err != nil {\n\t\tpanic(err.Error())\n\t}\n\twd = filepath.Join(wd, \"testdata\")\n\n\tdirs, err := ioutil.ReadDir(wd)\n\n\tif err != nil {\n\t\tpanic(err.Error())\n\t}\n\n\tfor _, dir := range dirs {\n\t\tif testDirectories.MatchString(dir.Name()) {\n\t\t\tformatJSONFile := filepath.Join(wd, dir.Name(), \"optional\", \"format.json\")\n\t\t\tif _, err = os.Stat(formatJSONFile); err == nil {\n\t\t\t\terr = executeTests(t, formatJSONFile)\n\t\t\t} else {\n\t\t\t\terr = nil\n\t\t\t}\n\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"Error (%s)\\n\", err.Error())\n\t\t\t}\n\n\t\t\tformatsDirectory := filepath.Join(wd, dir.Name(), \"optional\", \"format\")\n\t\t\terr = filepath.Walk(formatsDirectory, func(path string, fileInfo os.FileInfo, err error) error {\n\t\t\t\tif fileInfo == nil || !strings.HasSuffix(fileInfo.Name(), \".json\") {\n\t\t\t\t\treturn nil\n\t\t\t\t}\n\t\t\t\treturn executeTests(t, path)\n\t\t\t})\n\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"Error (%s)\\n\", err.Error())\n\t\t\t}\n\t\t}\n\t}\n}\n"
        },
        {
          "name": "locales.go",
          "type": "blob",
          "size": 16.7412109375,
          "content": "// Copyright 2015 xeipuuv ( https://github.com/xeipuuv )\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n// author           xeipuuv\n// author-github    https://github.com/xeipuuv\n// author-mail      xeipuuv@gmail.com\n//\n// repository-name  gojsonschema\n// repository-desc  An implementation of JSON Schema, based on IETF's draft v4 - Go language.\n//\n// description      Contains const string and messages.\n//\n// created          01-01-2015\n\npackage gojsonschema\n\ntype (\n\t// locale is an interface for defining custom error strings\n\tlocale interface {\n\n\t\t// False returns a format-string for \"false\" schema validation errors\n\t\tFalse() string\n\n\t\t// Required returns a format-string for \"required\" schema validation errors\n\t\tRequired() string\n\n\t\t// InvalidType returns a format-string for \"invalid type\" schema validation errors\n\t\tInvalidType() string\n\n\t\t// NumberAnyOf returns a format-string for \"anyOf\" schema validation errors\n\t\tNumberAnyOf() string\n\n\t\t// NumberOneOf returns a format-string for \"oneOf\" schema validation errors\n\t\tNumberOneOf() string\n\n\t\t// NumberAllOf returns a format-string for \"allOf\" schema validation errors\n\t\tNumberAllOf() string\n\n\t\t// NumberNot returns a format-string to format a NumberNotError\n\t\tNumberNot() string\n\n\t\t// MissingDependency returns a format-string for \"missing dependency\" schema validation errors\n\t\tMissingDependency() string\n\n\t\t// Internal returns a format-string for internal errors\n\t\tInternal() string\n\n\t\t// Const returns a format-string to format a ConstError\n\t\tConst() string\n\n\t\t// Enum returns a format-string to format an EnumError\n\t\tEnum() string\n\n\t\t// ArrayNotEnoughItems returns a format-string to format an error for arrays having not enough items to match positional list of schema\n\t\tArrayNotEnoughItems() string\n\n\t\t// ArrayNoAdditionalItems returns a format-string to format an ArrayNoAdditionalItemsError\n\t\tArrayNoAdditionalItems() string\n\n\t\t// ArrayMinItems returns a format-string to format an ArrayMinItemsError\n\t\tArrayMinItems() string\n\n\t\t// ArrayMaxItems returns a format-string to format an ArrayMaxItemsError\n\t\tArrayMaxItems() string\n\n\t\t// Unique returns a format-string  to format an ItemsMustBeUniqueError\n\t\tUnique() string\n\n\t\t// ArrayContains returns a format-string to format an ArrayContainsError\n\t\tArrayContains() string\n\n\t\t// ArrayMinProperties returns a format-string to format an ArrayMinPropertiesError\n\t\tArrayMinProperties() string\n\n\t\t// ArrayMaxProperties returns a format-string to format an ArrayMaxPropertiesError\n\t\tArrayMaxProperties() string\n\n\t\t// AdditionalPropertyNotAllowed returns a format-string to format an AdditionalPropertyNotAllowedError\n\t\tAdditionalPropertyNotAllowed() string\n\n\t\t// InvalidPropertyPattern returns a format-string to format an InvalidPropertyPatternError\n\t\tInvalidPropertyPattern() string\n\n\t\t// InvalidPropertyName returns a format-string to format an InvalidPropertyNameError\n\t\tInvalidPropertyName() string\n\n\t\t// StringGTE returns a format-string to format an StringLengthGTEError\n\t\tStringGTE() string\n\n\t\t// StringLTE returns a format-string to format an StringLengthLTEError\n\t\tStringLTE() string\n\n\t\t// DoesNotMatchPattern returns a format-string to format an DoesNotMatchPatternError\n\t\tDoesNotMatchPattern() string\n\n\t\t// DoesNotMatchFormat returns a format-string to format an DoesNotMatchFormatError\n\t\tDoesNotMatchFormat() string\n\n\t\t// MultipleOf returns a format-string to format an MultipleOfError\n\t\tMultipleOf() string\n\n\t\t// NumberGTE returns a format-string to format an NumberGTEError\n\t\tNumberGTE() string\n\n\t\t// NumberGT returns a format-string to format an NumberGTError\n\t\tNumberGT() string\n\n\t\t// NumberLTE returns a format-string to format an NumberLTEError\n\t\tNumberLTE() string\n\n\t\t// NumberLT returns a format-string to format an NumberLTError\n\t\tNumberLT() string\n\n\t\t// Schema validations\n\n\t\t// RegexPattern returns a format-string to format a regex-pattern error\n\t\tRegexPattern() string\n\n\t\t// GreaterThanZero returns a format-string to format an error where a number must be greater than zero\n\t\tGreaterThanZero() string\n\n\t\t// MustBeOfA returns a format-string to format an error where a value is of the wrong type\n\t\tMustBeOfA() string\n\n\t\t// MustBeOfAn returns a format-string to format an error where a value is of the wrong type\n\t\tMustBeOfAn() string\n\n\t\t// CannotBeUsedWithout returns a format-string to format a \"cannot be used without\" error\n\t\tCannotBeUsedWithout() string\n\n\t\t// CannotBeGT returns a format-string to format an error where a value are greater than allowed\n\t\tCannotBeGT() string\n\n\t\t// MustBeOfType returns a format-string to format an error where a value does not match the required type\n\t\tMustBeOfType() string\n\n\t\t// MustBeValidRegex returns a format-string to format an error where a regex is invalid\n\t\tMustBeValidRegex() string\n\n\t\t// MustBeValidFormat returns a format-string to format an error where a value does not match the expected format\n\t\tMustBeValidFormat() string\n\n\t\t// MustBeGTEZero returns a format-string to format an error where a value must be greater or equal than 0\n\t\tMustBeGTEZero() string\n\n\t\t// KeyCannotBeGreaterThan returns a format-string to format an error where a key is greater than the maximum  allowed\n\t\tKeyCannotBeGreaterThan() string\n\n\t\t// KeyItemsMustBeOfType returns a format-string to format an error where a key is of the wrong type\n\t\tKeyItemsMustBeOfType() string\n\n\t\t// KeyItemsMustBeUnique returns a format-string to format an error where keys are not unique\n\t\tKeyItemsMustBeUnique() string\n\n\t\t// ReferenceMustBeCanonical returns a format-string to format a \"reference must be canonical\" error\n\t\tReferenceMustBeCanonical() string\n\n\t\t// NotAValidType returns a format-string to format an invalid type error\n\t\tNotAValidType() string\n\n\t\t// Duplicated returns a format-string to format an error where types are duplicated\n\t\tDuplicated() string\n\n\t\t// HttpBadStatus returns a format-string for errors when loading a schema using HTTP\n\t\tHttpBadStatus() string\n\n\t\t// ParseError returns a format-string for JSON parsing errors\n\t\tParseError() string\n\n\t\t// ConditionThen returns a format-string for ConditionThenError errors\n\t\tConditionThen() string\n\n\t\t// ConditionElse returns a format-string for ConditionElseError errors\n\t\tConditionElse() string\n\n\t\t// ErrorFormat returns a format string for errors\n\t\tErrorFormat() string\n\t}\n\n\t// DefaultLocale is the default locale for this package\n\tDefaultLocale struct{}\n)\n\n// False returns a format-string for \"false\" schema validation errors\nfunc (l DefaultLocale) False() string {\n\treturn \"False always fails validation\"\n}\n\n// Required returns a format-string for \"required\" schema validation errors\nfunc (l DefaultLocale) Required() string {\n\treturn `{{.property}} is required`\n}\n\n// InvalidType returns a format-string for \"invalid type\" schema validation errors\nfunc (l DefaultLocale) InvalidType() string {\n\treturn `Invalid type. Expected: {{.expected}}, given: {{.given}}`\n}\n\n// NumberAnyOf returns a format-string for \"anyOf\" schema validation errors\nfunc (l DefaultLocale) NumberAnyOf() string {\n\treturn `Must validate at least one schema (anyOf)`\n}\n\n// NumberOneOf returns a format-string for \"oneOf\" schema validation errors\nfunc (l DefaultLocale) NumberOneOf() string {\n\treturn `Must validate one and only one schema (oneOf)`\n}\n\n// NumberAllOf returns a format-string for \"allOf\" schema validation errors\nfunc (l DefaultLocale) NumberAllOf() string {\n\treturn `Must validate all the schemas (allOf)`\n}\n\n// NumberNot returns a format-string to format a NumberNotError\nfunc (l DefaultLocale) NumberNot() string {\n\treturn `Must not validate the schema (not)`\n}\n\n// MissingDependency returns a format-string for \"missing dependency\" schema validation errors\nfunc (l DefaultLocale) MissingDependency() string {\n\treturn `Has a dependency on {{.dependency}}`\n}\n\n// Internal returns a format-string for internal errors\nfunc (l DefaultLocale) Internal() string {\n\treturn `Internal Error {{.error}}`\n}\n\n// Const returns a format-string to format a ConstError\nfunc (l DefaultLocale) Const() string {\n\treturn `{{.field}} does not match: {{.allowed}}`\n}\n\n// Enum returns a format-string to format an EnumError\nfunc (l DefaultLocale) Enum() string {\n\treturn `{{.field}} must be one of the following: {{.allowed}}`\n}\n\n// ArrayNoAdditionalItems returns a format-string to format an ArrayNoAdditionalItemsError\nfunc (l DefaultLocale) ArrayNoAdditionalItems() string {\n\treturn `No additional items allowed on array`\n}\n\n// ArrayNotEnoughItems returns a format-string to format an error for arrays having not enough items to match positional list of schema\nfunc (l DefaultLocale) ArrayNotEnoughItems() string {\n\treturn `Not enough items on array to match positional list of schema`\n}\n\n// ArrayMinItems returns a format-string to format an ArrayMinItemsError\nfunc (l DefaultLocale) ArrayMinItems() string {\n\treturn `Array must have at least {{.min}} items`\n}\n\n// ArrayMaxItems returns a format-string to format an ArrayMaxItemsError\nfunc (l DefaultLocale) ArrayMaxItems() string {\n\treturn `Array must have at most {{.max}} items`\n}\n\n// Unique returns a format-string  to format an ItemsMustBeUniqueError\nfunc (l DefaultLocale) Unique() string {\n\treturn `{{.type}} items[{{.i}},{{.j}}] must be unique`\n}\n\n// ArrayContains returns a format-string to format an ArrayContainsError\nfunc (l DefaultLocale) ArrayContains() string {\n\treturn `At least one of the items must match`\n}\n\n// ArrayMinProperties returns a format-string to format an ArrayMinPropertiesError\nfunc (l DefaultLocale) ArrayMinProperties() string {\n\treturn `Must have at least {{.min}} properties`\n}\n\n// ArrayMaxProperties returns a format-string to format an ArrayMaxPropertiesError\nfunc (l DefaultLocale) ArrayMaxProperties() string {\n\treturn `Must have at most {{.max}} properties`\n}\n\n// AdditionalPropertyNotAllowed returns a format-string to format an AdditionalPropertyNotAllowedError\nfunc (l DefaultLocale) AdditionalPropertyNotAllowed() string {\n\treturn `Additional property {{.property}} is not allowed`\n}\n\n// InvalidPropertyPattern returns a format-string to format an InvalidPropertyPatternError\nfunc (l DefaultLocale) InvalidPropertyPattern() string {\n\treturn `Property \"{{.property}}\" does not match pattern {{.pattern}}`\n}\n\n// InvalidPropertyName returns a format-string to format an InvalidPropertyNameError\nfunc (l DefaultLocale) InvalidPropertyName() string {\n\treturn `Property name of \"{{.property}}\" does not match`\n}\n\n// StringGTE returns a format-string to format an StringLengthGTEError\nfunc (l DefaultLocale) StringGTE() string {\n\treturn `String length must be greater than or equal to {{.min}}`\n}\n\n// StringLTE returns a format-string to format an StringLengthLTEError\nfunc (l DefaultLocale) StringLTE() string {\n\treturn `String length must be less than or equal to {{.max}}`\n}\n\n// DoesNotMatchPattern returns a format-string to format an DoesNotMatchPatternError\nfunc (l DefaultLocale) DoesNotMatchPattern() string {\n\treturn `Does not match pattern '{{.pattern}}'`\n}\n\n// DoesNotMatchFormat returns a format-string to format an DoesNotMatchFormatError\nfunc (l DefaultLocale) DoesNotMatchFormat() string {\n\treturn `Does not match format '{{.format}}'`\n}\n\n// MultipleOf returns a format-string to format an MultipleOfError\nfunc (l DefaultLocale) MultipleOf() string {\n\treturn `Must be a multiple of {{.multiple}}`\n}\n\n// NumberGTE returns the format string to format a NumberGTEError\nfunc (l DefaultLocale) NumberGTE() string {\n\treturn `Must be greater than or equal to {{.min}}`\n}\n\n// NumberGT returns the format string to format a NumberGTError\nfunc (l DefaultLocale) NumberGT() string {\n\treturn `Must be greater than {{.min}}`\n}\n\n// NumberLTE returns the format string to format a NumberLTEError\nfunc (l DefaultLocale) NumberLTE() string {\n\treturn `Must be less than or equal to {{.max}}`\n}\n\n// NumberLT returns the format string to format a NumberLTError\nfunc (l DefaultLocale) NumberLT() string {\n\treturn `Must be less than {{.max}}`\n}\n\n// Schema validators\n\n// RegexPattern returns a format-string to format a regex-pattern error\nfunc (l DefaultLocale) RegexPattern() string {\n\treturn `Invalid regex pattern '{{.pattern}}'`\n}\n\n// GreaterThanZero returns a format-string to format an error where a number must be greater than zero\nfunc (l DefaultLocale) GreaterThanZero() string {\n\treturn `{{.number}} must be strictly greater than 0`\n}\n\n// MustBeOfA returns a format-string to format an error where a value is of the wrong type\nfunc (l DefaultLocale) MustBeOfA() string {\n\treturn `{{.x}} must be of a {{.y}}`\n}\n\n// MustBeOfAn returns a format-string to format an error where a value is of the wrong type\nfunc (l DefaultLocale) MustBeOfAn() string {\n\treturn `{{.x}} must be of an {{.y}}`\n}\n\n// CannotBeUsedWithout returns a format-string to format a \"cannot be used without\" error\nfunc (l DefaultLocale) CannotBeUsedWithout() string {\n\treturn `{{.x}} cannot be used without {{.y}}`\n}\n\n// CannotBeGT returns a format-string to format an error where a value are greater than allowed\nfunc (l DefaultLocale) CannotBeGT() string {\n\treturn `{{.x}} cannot be greater than {{.y}}`\n}\n\n// MustBeOfType returns a format-string to format an error where a value does not match the required type\nfunc (l DefaultLocale) MustBeOfType() string {\n\treturn `{{.key}} must be of type {{.type}}`\n}\n\n// MustBeValidRegex returns a format-string to format an error where a regex is invalid\nfunc (l DefaultLocale) MustBeValidRegex() string {\n\treturn `{{.key}} must be a valid regex`\n}\n\n// MustBeValidFormat returns a format-string to format an error where a value does not match the expected format\nfunc (l DefaultLocale) MustBeValidFormat() string {\n\treturn `{{.key}} must be a valid format {{.given}}`\n}\n\n// MustBeGTEZero returns a format-string to format an error where a value must be greater or equal than 0\nfunc (l DefaultLocale) MustBeGTEZero() string {\n\treturn `{{.key}} must be greater than or equal to 0`\n}\n\n// KeyCannotBeGreaterThan returns a format-string to format an error where a value is greater than the maximum  allowed\nfunc (l DefaultLocale) KeyCannotBeGreaterThan() string {\n\treturn `{{.key}} cannot be greater than {{.y}}`\n}\n\n// KeyItemsMustBeOfType returns a format-string to format an error where a key is of the wrong type\nfunc (l DefaultLocale) KeyItemsMustBeOfType() string {\n\treturn `{{.key}} items must be {{.type}}`\n}\n\n// KeyItemsMustBeUnique returns a format-string to format an error where keys are not unique\nfunc (l DefaultLocale) KeyItemsMustBeUnique() string {\n\treturn `{{.key}} items must be unique`\n}\n\n// ReferenceMustBeCanonical returns a format-string to format a \"reference must be canonical\" error\nfunc (l DefaultLocale) ReferenceMustBeCanonical() string {\n\treturn `Reference {{.reference}} must be canonical`\n}\n\n// NotAValidType returns a format-string to format an invalid type error\nfunc (l DefaultLocale) NotAValidType() string {\n\treturn `has a primitive type that is NOT VALID -- given: {{.given}} Expected valid values are:{{.expected}}`\n}\n\n// Duplicated returns a format-string to format an error where types are duplicated\nfunc (l DefaultLocale) Duplicated() string {\n\treturn `{{.type}} type is duplicated`\n}\n\n// HttpBadStatus returns a format-string for errors when loading a schema using HTTP\nfunc (l DefaultLocale) HttpBadStatus() string {\n\treturn `Could not read schema from HTTP, response status is {{.status}}`\n}\n\n// ErrorFormat returns a format string for errors\n// Replacement options: field, description, context, value\nfunc (l DefaultLocale) ErrorFormat() string {\n\treturn `{{.field}}: {{.description}}`\n}\n\n// ParseError returns a format-string for JSON parsing errors\nfunc (l DefaultLocale) ParseError() string {\n\treturn `Expected: {{.expected}}, given: Invalid JSON`\n}\n\n// ConditionThen returns a format-string for ConditionThenError errors\n// If/Else\nfunc (l DefaultLocale) ConditionThen() string {\n\treturn `Must validate \"then\" as \"if\" was valid`\n}\n\n// ConditionElse returns a format-string for ConditionElseError errors\nfunc (l DefaultLocale) ConditionElse() string {\n\treturn `Must validate \"else\" as \"if\" was not valid`\n}\n\n// constants\nconst (\n\tSTRING_NUMBER                     = \"number\"\n\tSTRING_ARRAY_OF_STRINGS           = \"array of strings\"\n\tSTRING_ARRAY_OF_SCHEMAS           = \"array of schemas\"\n\tSTRING_SCHEMA                     = \"valid schema\"\n\tSTRING_SCHEMA_OR_ARRAY_OF_STRINGS = \"schema or array of strings\"\n\tSTRING_PROPERTIES                 = \"properties\"\n\tSTRING_DEPENDENCY                 = \"dependency\"\n\tSTRING_PROPERTY                   = \"property\"\n\tSTRING_UNDEFINED                  = \"undefined\"\n\tSTRING_CONTEXT_ROOT               = \"(root)\"\n\tSTRING_ROOT_SCHEMA_PROPERTY       = \"(root)\"\n)\n"
        },
        {
          "name": "result.go",
          "type": "blob",
          "size": 7.0322265625,
          "content": "// Copyright 2015 xeipuuv ( https://github.com/xeipuuv )\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n// author           xeipuuv\n// author-github    https://github.com/xeipuuv\n// author-mail      xeipuuv@gmail.com\n//\n// repository-name  gojsonschema\n// repository-desc  An implementation of JSON Schema, based on IETF's draft v4 - Go language.\n//\n// description      Result and ResultError implementations.\n//\n// created          01-01-2015\n\npackage gojsonschema\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n)\n\ntype (\n\t// ErrorDetails is a map of details specific to each error.\n\t// While the values will vary, every error will contain a \"field\" value\n\tErrorDetails map[string]interface{}\n\n\t// ResultError is the interface that library errors must implement\n\tResultError interface {\n\t\t// Field returns the field name without the root context\n\t\t// i.e. firstName or person.firstName instead of (root).firstName or (root).person.firstName\n\t\tField() string\n\t\t// SetType sets the error-type\n\t\tSetType(string)\n\t\t// Type returns the error-type\n\t\tType() string\n\t\t// SetContext sets the JSON-context for the error\n\t\tSetContext(*JsonContext)\n\t\t// Context returns the JSON-context of the error\n\t\tContext() *JsonContext\n\t\t// SetDescription sets a description for the error\n\t\tSetDescription(string)\n\t\t// Description returns the description of the error\n\t\tDescription() string\n\t\t// SetDescriptionFormat sets the format for the description in the default text/template format\n\t\tSetDescriptionFormat(string)\n\t\t// DescriptionFormat returns the format for the description in the default text/template format\n\t\tDescriptionFormat() string\n\t\t// SetValue sets the value related to the error\n\t\tSetValue(interface{})\n\t\t// Value returns the value related to the error\n\t\tValue() interface{}\n\t\t// SetDetails sets the details specific to the error\n\t\tSetDetails(ErrorDetails)\n\t\t// Details returns details about the error\n\t\tDetails() ErrorDetails\n\t\t// String returns a string representation of the error\n\t\tString() string\n\t}\n\n\t// ResultErrorFields holds the fields for each ResultError implementation.\n\t// ResultErrorFields implements the ResultError interface, so custom errors\n\t// can be defined by just embedding this type\n\tResultErrorFields struct {\n\t\terrorType         string       // A string with the type of error (i.e. invalid_type)\n\t\tcontext           *JsonContext // Tree like notation of the part that failed the validation. ex (root).a.b ...\n\t\tdescription       string       // A human readable error message\n\t\tdescriptionFormat string       // A format for human readable error message\n\t\tvalue             interface{}  // Value given by the JSON file that is the source of the error\n\t\tdetails           ErrorDetails\n\t}\n\n\t// Result holds the result of a validation\n\tResult struct {\n\t\terrors []ResultError\n\t\t// Scores how well the validation matched. Useful in generating\n\t\t// better error messages for anyOf and oneOf.\n\t\tscore int\n\t}\n)\n\n// Field returns the field name without the root context\n// i.e. firstName or person.firstName instead of (root).firstName or (root).person.firstName\nfunc (v *ResultErrorFields) Field() string {\n\treturn strings.TrimPrefix(v.context.String(), STRING_ROOT_SCHEMA_PROPERTY+\".\")\n}\n\n// SetType sets the error-type\nfunc (v *ResultErrorFields) SetType(errorType string) {\n\tv.errorType = errorType\n}\n\n// Type returns the error-type\nfunc (v *ResultErrorFields) Type() string {\n\treturn v.errorType\n}\n\n// SetContext sets the JSON-context for the error\nfunc (v *ResultErrorFields) SetContext(context *JsonContext) {\n\tv.context = context\n}\n\n// Context returns the JSON-context of the error\nfunc (v *ResultErrorFields) Context() *JsonContext {\n\treturn v.context\n}\n\n// SetDescription sets a description for the error\nfunc (v *ResultErrorFields) SetDescription(description string) {\n\tv.description = description\n}\n\n// Description returns the description of the error\nfunc (v *ResultErrorFields) Description() string {\n\treturn v.description\n}\n\n// SetDescriptionFormat sets the format for the description in the default text/template format\nfunc (v *ResultErrorFields) SetDescriptionFormat(descriptionFormat string) {\n\tv.descriptionFormat = descriptionFormat\n}\n\n// DescriptionFormat returns the format for the description in the default text/template format\nfunc (v *ResultErrorFields) DescriptionFormat() string {\n\treturn v.descriptionFormat\n}\n\n// SetValue sets the value related to the error\nfunc (v *ResultErrorFields) SetValue(value interface{}) {\n\tv.value = value\n}\n\n// Value returns the value related to the error\nfunc (v *ResultErrorFields) Value() interface{} {\n\treturn v.value\n}\n\n// SetDetails sets the details specific to the error\nfunc (v *ResultErrorFields) SetDetails(details ErrorDetails) {\n\tv.details = details\n}\n\n// Details returns details about the error\nfunc (v *ResultErrorFields) Details() ErrorDetails {\n\treturn v.details\n}\n\n// String returns a string representation of the error\nfunc (v ResultErrorFields) String() string {\n\t// as a fallback, the value is displayed go style\n\tvalueString := fmt.Sprintf(\"%v\", v.value)\n\n\t// marshal the go value value to json\n\tif v.value == nil {\n\t\tvalueString = TYPE_NULL\n\t} else {\n\t\tif vs, err := marshalToJSONString(v.value); err == nil {\n\t\t\tif vs == nil {\n\t\t\t\tvalueString = TYPE_NULL\n\t\t\t} else {\n\t\t\t\tvalueString = *vs\n\t\t\t}\n\t\t}\n\t}\n\n\treturn formatErrorDescription(Locale.ErrorFormat(), ErrorDetails{\n\t\t\"context\":     v.context.String(),\n\t\t\"description\": v.description,\n\t\t\"value\":       valueString,\n\t\t\"field\":       v.Field(),\n\t})\n}\n\n// Valid indicates if no errors were found\nfunc (v *Result) Valid() bool {\n\treturn len(v.errors) == 0\n}\n\n// Errors returns the errors that were found\nfunc (v *Result) Errors() []ResultError {\n\treturn v.errors\n}\n\n// AddError appends a fully filled error to the error set\n// SetDescription() will be called with the result of the parsed err.DescriptionFormat()\nfunc (v *Result) AddError(err ResultError, details ErrorDetails) {\n\tif _, exists := details[\"context\"]; !exists && err.Context() != nil {\n\t\tdetails[\"context\"] = err.Context().String()\n\t}\n\n\terr.SetDescription(formatErrorDescription(err.DescriptionFormat(), details))\n\n\tv.errors = append(v.errors, err)\n}\n\nfunc (v *Result) addInternalError(err ResultError, context *JsonContext, value interface{}, details ErrorDetails) {\n\tnewError(err, context, value, Locale, details)\n\tv.errors = append(v.errors, err)\n\tv.score -= 2 // results in a net -1 when added to the +1 we get at the end of the validation function\n}\n\n// Used to copy errors from a sub-schema to the main one\nfunc (v *Result) mergeErrors(otherResult *Result) {\n\tv.errors = append(v.errors, otherResult.Errors()...)\n\tv.score += otherResult.score\n}\n\nfunc (v *Result) incrementScore() {\n\tv.score++\n}\n"
        },
        {
          "name": "schema.go",
          "type": "blob",
          "size": 29.0732421875,
          "content": "// Copyright 2015 xeipuuv ( https://github.com/xeipuuv )\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n// author           xeipuuv\n// author-github    https://github.com/xeipuuv\n// author-mail      xeipuuv@gmail.com\n//\n// repository-name  gojsonschema\n// repository-desc  An implementation of JSON Schema, based on IETF's draft v4 - Go language.\n//\n// description      Defines Schema, the main entry to every subSchema.\n//                  Contains the parsing logic and error checking.\n//\n// created          26-02-2013\n\npackage gojsonschema\n\nimport (\n\t\"errors\"\n\t\"math/big\"\n\t\"reflect\"\n\t\"regexp\"\n\t\"text/template\"\n\n\t\"github.com/xeipuuv/gojsonreference\"\n)\n\nvar (\n\t// Locale is the default locale to use\n\t// Library users can overwrite with their own implementation\n\tLocale locale = DefaultLocale{}\n\n\t// ErrorTemplateFuncs allows you to define custom template funcs for use in localization.\n\tErrorTemplateFuncs template.FuncMap\n)\n\n// NewSchema instances a schema using the given JSONLoader\nfunc NewSchema(l JSONLoader) (*Schema, error) {\n\treturn NewSchemaLoader().Compile(l)\n}\n\n// Schema holds a schema\ntype Schema struct {\n\tdocumentReference gojsonreference.JsonReference\n\trootSchema        *subSchema\n\tpool              *schemaPool\n\treferencePool     *schemaReferencePool\n}\n\nfunc (d *Schema) parse(document interface{}, draft Draft) error {\n\td.rootSchema = &subSchema{property: STRING_ROOT_SCHEMA_PROPERTY, draft: &draft}\n\treturn d.parseSchema(document, d.rootSchema)\n}\n\n// SetRootSchemaName sets the root-schema name\nfunc (d *Schema) SetRootSchemaName(name string) {\n\td.rootSchema.property = name\n}\n\n// Parses a subSchema\n//\n// Pretty long function ( sorry :) )... but pretty straight forward, repetitive and boring\n// Not much magic involved here, most of the job is to validate the key names and their values,\n// then the values are copied into subSchema struct\n//\nfunc (d *Schema) parseSchema(documentNode interface{}, currentSchema *subSchema) error {\n\n\tif currentSchema.draft == nil {\n\t\tif currentSchema.parent == nil {\n\t\t\treturn errors.New(\"Draft not set\")\n\t\t}\n\t\tcurrentSchema.draft = currentSchema.parent.draft\n\t}\n\n\t// As of draft 6 \"true\" is equivalent to an empty schema \"{}\" and false equals \"{\"not\":{}}\"\n\tif *currentSchema.draft >= Draft6 && isKind(documentNode, reflect.Bool) {\n\t\tb := documentNode.(bool)\n\t\tcurrentSchema.pass = &b\n\t\treturn nil\n\t}\n\n\tif !isKind(documentNode, reflect.Map) {\n\t\treturn errors.New(formatErrorDescription(\n\t\t\tLocale.ParseError(),\n\t\t\tErrorDetails{\n\t\t\t\t\"expected\": STRING_SCHEMA,\n\t\t\t},\n\t\t))\n\t}\n\n\tm := documentNode.(map[string]interface{})\n\n\tif currentSchema.parent == nil {\n\t\tcurrentSchema.ref = &d.documentReference\n\t\tcurrentSchema.id = &d.documentReference\n\t}\n\n\tif currentSchema.id == nil && currentSchema.parent != nil {\n\t\tcurrentSchema.id = currentSchema.parent.id\n\t}\n\n\t// In draft 6 the id keyword was renamed to $id\n\t// Hybrid mode uses the old id by default\n\tvar keyID string\n\n\tswitch *currentSchema.draft {\n\tcase Draft4:\n\t\tkeyID = KEY_ID\n\tcase Hybrid:\n\t\tkeyID = KEY_ID_NEW\n\t\tif existsMapKey(m, KEY_ID) {\n\t\t\tkeyID = KEY_ID\n\t\t}\n\tdefault:\n\t\tkeyID = KEY_ID_NEW\n\t}\n\tif existsMapKey(m, keyID) && !isKind(m[keyID], reflect.String) {\n\t\treturn errors.New(formatErrorDescription(\n\t\t\tLocale.InvalidType(),\n\t\t\tErrorDetails{\n\t\t\t\t\"expected\": TYPE_STRING,\n\t\t\t\t\"given\":    keyID,\n\t\t\t},\n\t\t))\n\t}\n\tif k, ok := m[keyID].(string); ok {\n\t\tjsonReference, err := gojsonreference.NewJsonReference(k)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif currentSchema == d.rootSchema {\n\t\t\tcurrentSchema.id = &jsonReference\n\t\t} else {\n\t\t\tref, err := currentSchema.parent.id.Inherits(jsonReference)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tcurrentSchema.id = ref\n\t\t}\n\t}\n\n\t// definitions\n\tif existsMapKey(m, KEY_DEFINITIONS) {\n\t\tif isKind(m[KEY_DEFINITIONS], reflect.Map, reflect.Bool) {\n\t\t\tfor _, dv := range m[KEY_DEFINITIONS].(map[string]interface{}) {\n\t\t\t\tif isKind(dv, reflect.Map, reflect.Bool) {\n\n\t\t\t\t\tnewSchema := &subSchema{property: KEY_DEFINITIONS, parent: currentSchema}\n\n\t\t\t\t\terr := d.parseSchema(dv, newSchema)\n\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\treturn err\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\treturn errors.New(formatErrorDescription(\n\t\t\t\t\t\tLocale.InvalidType(),\n\t\t\t\t\t\tErrorDetails{\n\t\t\t\t\t\t\t\"expected\": STRING_ARRAY_OF_SCHEMAS,\n\t\t\t\t\t\t\t\"given\":    KEY_DEFINITIONS,\n\t\t\t\t\t\t},\n\t\t\t\t\t))\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\treturn errors.New(formatErrorDescription(\n\t\t\t\tLocale.InvalidType(),\n\t\t\t\tErrorDetails{\n\t\t\t\t\t\"expected\": STRING_ARRAY_OF_SCHEMAS,\n\t\t\t\t\t\"given\":    KEY_DEFINITIONS,\n\t\t\t\t},\n\t\t\t))\n\t\t}\n\n\t}\n\n\t// title\n\tif existsMapKey(m, KEY_TITLE) && !isKind(m[KEY_TITLE], reflect.String) {\n\t\treturn errors.New(formatErrorDescription(\n\t\t\tLocale.InvalidType(),\n\t\t\tErrorDetails{\n\t\t\t\t\"expected\": TYPE_STRING,\n\t\t\t\t\"given\":    KEY_TITLE,\n\t\t\t},\n\t\t))\n\t}\n\tif k, ok := m[KEY_TITLE].(string); ok {\n\t\tcurrentSchema.title = &k\n\t}\n\n\t// description\n\tif existsMapKey(m, KEY_DESCRIPTION) && !isKind(m[KEY_DESCRIPTION], reflect.String) {\n\t\treturn errors.New(formatErrorDescription(\n\t\t\tLocale.InvalidType(),\n\t\t\tErrorDetails{\n\t\t\t\t\"expected\": TYPE_STRING,\n\t\t\t\t\"given\":    KEY_DESCRIPTION,\n\t\t\t},\n\t\t))\n\t}\n\tif k, ok := m[KEY_DESCRIPTION].(string); ok {\n\t\tcurrentSchema.description = &k\n\t}\n\n\t// $ref\n\tif existsMapKey(m, KEY_REF) && !isKind(m[KEY_REF], reflect.String) {\n\t\treturn errors.New(formatErrorDescription(\n\t\t\tLocale.InvalidType(),\n\t\t\tErrorDetails{\n\t\t\t\t\"expected\": TYPE_STRING,\n\t\t\t\t\"given\":    KEY_REF,\n\t\t\t},\n\t\t))\n\t}\n\n\tif k, ok := m[KEY_REF].(string); ok {\n\n\t\tjsonReference, err := gojsonreference.NewJsonReference(k)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tcurrentSchema.ref = &jsonReference\n\n\t\tif sch, ok := d.referencePool.Get(currentSchema.ref.String()); ok {\n\t\t\tcurrentSchema.refSchema = sch\n\t\t} else {\n\t\t\terr := d.parseReference(documentNode, currentSchema)\n\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t\treturn nil\n\t\t}\n\t}\n\n\t// type\n\tif existsMapKey(m, KEY_TYPE) {\n\t\tif isKind(m[KEY_TYPE], reflect.String) {\n\t\t\tif k, ok := m[KEY_TYPE].(string); ok {\n\t\t\t\terr := currentSchema.types.Add(k)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tif isKind(m[KEY_TYPE], reflect.Slice) {\n\t\t\t\tarrayOfTypes := m[KEY_TYPE].([]interface{})\n\t\t\t\tfor _, typeInArray := range arrayOfTypes {\n\t\t\t\t\tif reflect.ValueOf(typeInArray).Kind() != reflect.String {\n\t\t\t\t\t\treturn errors.New(formatErrorDescription(\n\t\t\t\t\t\t\tLocale.InvalidType(),\n\t\t\t\t\t\t\tErrorDetails{\n\t\t\t\t\t\t\t\t\"expected\": TYPE_STRING + \"/\" + STRING_ARRAY_OF_STRINGS,\n\t\t\t\t\t\t\t\t\"given\":    KEY_TYPE,\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t))\n\t\t\t\t\t}\n\t\t\t\t\tif err := currentSchema.types.Add(typeInArray.(string)); err != nil {\n\t\t\t\t\t\treturn err\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t} else {\n\t\t\t\treturn errors.New(formatErrorDescription(\n\t\t\t\t\tLocale.InvalidType(),\n\t\t\t\t\tErrorDetails{\n\t\t\t\t\t\t\"expected\": TYPE_STRING + \"/\" + STRING_ARRAY_OF_STRINGS,\n\t\t\t\t\t\t\"given\":    KEY_TYPE,\n\t\t\t\t\t},\n\t\t\t\t))\n\t\t\t}\n\t\t}\n\t}\n\n\t// properties\n\tif existsMapKey(m, KEY_PROPERTIES) {\n\t\terr := d.parseProperties(m[KEY_PROPERTIES], currentSchema)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\t// additionalProperties\n\tif existsMapKey(m, KEY_ADDITIONAL_PROPERTIES) {\n\t\tif isKind(m[KEY_ADDITIONAL_PROPERTIES], reflect.Bool) {\n\t\t\tcurrentSchema.additionalProperties = m[KEY_ADDITIONAL_PROPERTIES].(bool)\n\t\t} else if isKind(m[KEY_ADDITIONAL_PROPERTIES], reflect.Map) {\n\t\t\tnewSchema := &subSchema{property: KEY_ADDITIONAL_PROPERTIES, parent: currentSchema, ref: currentSchema.ref}\n\t\t\tcurrentSchema.additionalProperties = newSchema\n\t\t\terr := d.parseSchema(m[KEY_ADDITIONAL_PROPERTIES], newSchema)\n\t\t\tif err != nil {\n\t\t\t\treturn errors.New(err.Error())\n\t\t\t}\n\t\t} else {\n\t\t\treturn errors.New(formatErrorDescription(\n\t\t\t\tLocale.InvalidType(),\n\t\t\t\tErrorDetails{\n\t\t\t\t\t\"expected\": TYPE_BOOLEAN + \"/\" + STRING_SCHEMA,\n\t\t\t\t\t\"given\":    KEY_ADDITIONAL_PROPERTIES,\n\t\t\t\t},\n\t\t\t))\n\t\t}\n\t}\n\n\t// patternProperties\n\tif existsMapKey(m, KEY_PATTERN_PROPERTIES) {\n\t\tif isKind(m[KEY_PATTERN_PROPERTIES], reflect.Map) {\n\t\t\tpatternPropertiesMap := m[KEY_PATTERN_PROPERTIES].(map[string]interface{})\n\t\t\tif len(patternPropertiesMap) > 0 {\n\t\t\t\tcurrentSchema.patternProperties = make(map[string]*subSchema)\n\t\t\t\tfor k, v := range patternPropertiesMap {\n\t\t\t\t\t_, err := regexp.MatchString(k, \"\")\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\treturn errors.New(formatErrorDescription(\n\t\t\t\t\t\t\tLocale.RegexPattern(),\n\t\t\t\t\t\t\tErrorDetails{\"pattern\": k},\n\t\t\t\t\t\t))\n\t\t\t\t\t}\n\t\t\t\t\tnewSchema := &subSchema{property: k, parent: currentSchema, ref: currentSchema.ref}\n\t\t\t\t\terr = d.parseSchema(v, newSchema)\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\treturn errors.New(err.Error())\n\t\t\t\t\t}\n\t\t\t\t\tcurrentSchema.patternProperties[k] = newSchema\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\treturn errors.New(formatErrorDescription(\n\t\t\t\tLocale.InvalidType(),\n\t\t\t\tErrorDetails{\n\t\t\t\t\t\"expected\": STRING_SCHEMA,\n\t\t\t\t\t\"given\":    KEY_PATTERN_PROPERTIES,\n\t\t\t\t},\n\t\t\t))\n\t\t}\n\t}\n\n\t// propertyNames\n\tif existsMapKey(m, KEY_PROPERTY_NAMES) && *currentSchema.draft >= Draft6 {\n\t\tif isKind(m[KEY_PROPERTY_NAMES], reflect.Map, reflect.Bool) {\n\t\t\tnewSchema := &subSchema{property: KEY_PROPERTY_NAMES, parent: currentSchema, ref: currentSchema.ref}\n\t\t\tcurrentSchema.propertyNames = newSchema\n\t\t\terr := d.parseSchema(m[KEY_PROPERTY_NAMES], newSchema)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t} else {\n\t\t\treturn errors.New(formatErrorDescription(\n\t\t\t\tLocale.InvalidType(),\n\t\t\t\tErrorDetails{\n\t\t\t\t\t\"expected\": STRING_SCHEMA,\n\t\t\t\t\t\"given\":    KEY_PATTERN_PROPERTIES,\n\t\t\t\t},\n\t\t\t))\n\t\t}\n\t}\n\n\t// dependencies\n\tif existsMapKey(m, KEY_DEPENDENCIES) {\n\t\terr := d.parseDependencies(m[KEY_DEPENDENCIES], currentSchema)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\t// items\n\tif existsMapKey(m, KEY_ITEMS) {\n\t\tif isKind(m[KEY_ITEMS], reflect.Slice) {\n\t\t\tfor _, itemElement := range m[KEY_ITEMS].([]interface{}) {\n\t\t\t\tif isKind(itemElement, reflect.Map, reflect.Bool) {\n\t\t\t\t\tnewSchema := &subSchema{parent: currentSchema, property: KEY_ITEMS}\n\t\t\t\t\tnewSchema.ref = currentSchema.ref\n\t\t\t\t\tcurrentSchema.itemsChildren = append(currentSchema.itemsChildren, newSchema)\n\t\t\t\t\terr := d.parseSchema(itemElement, newSchema)\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\treturn err\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\treturn errors.New(formatErrorDescription(\n\t\t\t\t\t\tLocale.InvalidType(),\n\t\t\t\t\t\tErrorDetails{\n\t\t\t\t\t\t\t\"expected\": STRING_SCHEMA + \"/\" + STRING_ARRAY_OF_SCHEMAS,\n\t\t\t\t\t\t\t\"given\":    KEY_ITEMS,\n\t\t\t\t\t\t},\n\t\t\t\t\t))\n\t\t\t\t}\n\t\t\t\tcurrentSchema.itemsChildrenIsSingleSchema = false\n\t\t\t}\n\t\t} else if isKind(m[KEY_ITEMS], reflect.Map, reflect.Bool) {\n\t\t\tnewSchema := &subSchema{parent: currentSchema, property: KEY_ITEMS}\n\t\t\tnewSchema.ref = currentSchema.ref\n\t\t\tcurrentSchema.itemsChildren = append(currentSchema.itemsChildren, newSchema)\n\t\t\terr := d.parseSchema(m[KEY_ITEMS], newSchema)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tcurrentSchema.itemsChildrenIsSingleSchema = true\n\t\t} else {\n\t\t\treturn errors.New(formatErrorDescription(\n\t\t\t\tLocale.InvalidType(),\n\t\t\t\tErrorDetails{\n\t\t\t\t\t\"expected\": STRING_SCHEMA + \"/\" + STRING_ARRAY_OF_SCHEMAS,\n\t\t\t\t\t\"given\":    KEY_ITEMS,\n\t\t\t\t},\n\t\t\t))\n\t\t}\n\t}\n\n\t// additionalItems\n\tif existsMapKey(m, KEY_ADDITIONAL_ITEMS) {\n\t\tif isKind(m[KEY_ADDITIONAL_ITEMS], reflect.Bool) {\n\t\t\tcurrentSchema.additionalItems = m[KEY_ADDITIONAL_ITEMS].(bool)\n\t\t} else if isKind(m[KEY_ADDITIONAL_ITEMS], reflect.Map) {\n\t\t\tnewSchema := &subSchema{property: KEY_ADDITIONAL_ITEMS, parent: currentSchema, ref: currentSchema.ref}\n\t\t\tcurrentSchema.additionalItems = newSchema\n\t\t\terr := d.parseSchema(m[KEY_ADDITIONAL_ITEMS], newSchema)\n\t\t\tif err != nil {\n\t\t\t\treturn errors.New(err.Error())\n\t\t\t}\n\t\t} else {\n\t\t\treturn errors.New(formatErrorDescription(\n\t\t\t\tLocale.InvalidType(),\n\t\t\t\tErrorDetails{\n\t\t\t\t\t\"expected\": TYPE_BOOLEAN + \"/\" + STRING_SCHEMA,\n\t\t\t\t\t\"given\":    KEY_ADDITIONAL_ITEMS,\n\t\t\t\t},\n\t\t\t))\n\t\t}\n\t}\n\n\t// validation : number / integer\n\n\tif existsMapKey(m, KEY_MULTIPLE_OF) {\n\t\tmultipleOfValue := mustBeNumber(m[KEY_MULTIPLE_OF])\n\t\tif multipleOfValue == nil {\n\t\t\treturn errors.New(formatErrorDescription(\n\t\t\t\tLocale.InvalidType(),\n\t\t\t\tErrorDetails{\n\t\t\t\t\t\"expected\": STRING_NUMBER,\n\t\t\t\t\t\"given\":    KEY_MULTIPLE_OF,\n\t\t\t\t},\n\t\t\t))\n\t\t}\n\t\tif multipleOfValue.Cmp(big.NewRat(0, 1)) <= 0 {\n\t\t\treturn errors.New(formatErrorDescription(\n\t\t\t\tLocale.GreaterThanZero(),\n\t\t\t\tErrorDetails{\"number\": KEY_MULTIPLE_OF},\n\t\t\t))\n\t\t}\n\t\tcurrentSchema.multipleOf = multipleOfValue\n\t}\n\n\tif existsMapKey(m, KEY_MINIMUM) {\n\t\tminimumValue := mustBeNumber(m[KEY_MINIMUM])\n\t\tif minimumValue == nil {\n\t\t\treturn errors.New(formatErrorDescription(\n\t\t\t\tLocale.MustBeOfA(),\n\t\t\t\tErrorDetails{\"x\": KEY_MINIMUM, \"y\": STRING_NUMBER},\n\t\t\t))\n\t\t}\n\t\tcurrentSchema.minimum = minimumValue\n\t}\n\n\tif existsMapKey(m, KEY_EXCLUSIVE_MINIMUM) {\n\t\tswitch *currentSchema.draft {\n\t\tcase Draft4:\n\t\t\tif !isKind(m[KEY_EXCLUSIVE_MINIMUM], reflect.Bool) {\n\t\t\t\treturn errors.New(formatErrorDescription(\n\t\t\t\t\tLocale.InvalidType(),\n\t\t\t\t\tErrorDetails{\n\t\t\t\t\t\t\"expected\": TYPE_BOOLEAN,\n\t\t\t\t\t\t\"given\":    KEY_EXCLUSIVE_MINIMUM,\n\t\t\t\t\t},\n\t\t\t\t))\n\t\t\t}\n\t\t\tif currentSchema.minimum == nil {\n\t\t\t\treturn errors.New(formatErrorDescription(\n\t\t\t\t\tLocale.CannotBeUsedWithout(),\n\t\t\t\t\tErrorDetails{\"x\": KEY_EXCLUSIVE_MINIMUM, \"y\": KEY_MINIMUM},\n\t\t\t\t))\n\t\t\t}\n\t\t\tif m[KEY_EXCLUSIVE_MINIMUM].(bool) {\n\t\t\t\tcurrentSchema.exclusiveMinimum = currentSchema.minimum\n\t\t\t\tcurrentSchema.minimum = nil\n\t\t\t}\n\t\tcase Hybrid:\n\t\t\tif isKind(m[KEY_EXCLUSIVE_MINIMUM], reflect.Bool) {\n\t\t\t\tif currentSchema.minimum == nil {\n\t\t\t\t\treturn errors.New(formatErrorDescription(\n\t\t\t\t\t\tLocale.CannotBeUsedWithout(),\n\t\t\t\t\t\tErrorDetails{\"x\": KEY_EXCLUSIVE_MINIMUM, \"y\": KEY_MINIMUM},\n\t\t\t\t\t))\n\t\t\t\t}\n\t\t\t\tif m[KEY_EXCLUSIVE_MINIMUM].(bool) {\n\t\t\t\t\tcurrentSchema.exclusiveMinimum = currentSchema.minimum\n\t\t\t\t\tcurrentSchema.minimum = nil\n\t\t\t\t}\n\t\t\t} else if isJSONNumber(m[KEY_EXCLUSIVE_MINIMUM]) {\n\t\t\t\tcurrentSchema.exclusiveMinimum = mustBeNumber(m[KEY_EXCLUSIVE_MINIMUM])\n\t\t\t} else {\n\t\t\t\treturn errors.New(formatErrorDescription(\n\t\t\t\t\tLocale.InvalidType(),\n\t\t\t\t\tErrorDetails{\n\t\t\t\t\t\t\"expected\": TYPE_BOOLEAN + \"/\" + TYPE_NUMBER,\n\t\t\t\t\t\t\"given\":    KEY_EXCLUSIVE_MINIMUM,\n\t\t\t\t\t},\n\t\t\t\t))\n\t\t\t}\n\t\tdefault:\n\t\t\tif isJSONNumber(m[KEY_EXCLUSIVE_MINIMUM]) {\n\t\t\t\tcurrentSchema.exclusiveMinimum = mustBeNumber(m[KEY_EXCLUSIVE_MINIMUM])\n\t\t\t} else {\n\t\t\t\treturn errors.New(formatErrorDescription(\n\t\t\t\t\tLocale.InvalidType(),\n\t\t\t\t\tErrorDetails{\n\t\t\t\t\t\t\"expected\": TYPE_NUMBER,\n\t\t\t\t\t\t\"given\":    KEY_EXCLUSIVE_MINIMUM,\n\t\t\t\t\t},\n\t\t\t\t))\n\t\t\t}\n\t\t}\n\t}\n\n\tif existsMapKey(m, KEY_MAXIMUM) {\n\t\tmaximumValue := mustBeNumber(m[KEY_MAXIMUM])\n\t\tif maximumValue == nil {\n\t\t\treturn errors.New(formatErrorDescription(\n\t\t\t\tLocale.MustBeOfA(),\n\t\t\t\tErrorDetails{\"x\": KEY_MAXIMUM, \"y\": STRING_NUMBER},\n\t\t\t))\n\t\t}\n\t\tcurrentSchema.maximum = maximumValue\n\t}\n\n\tif existsMapKey(m, KEY_EXCLUSIVE_MAXIMUM) {\n\t\tswitch *currentSchema.draft {\n\t\tcase Draft4:\n\t\t\tif !isKind(m[KEY_EXCLUSIVE_MAXIMUM], reflect.Bool) {\n\t\t\t\treturn errors.New(formatErrorDescription(\n\t\t\t\t\tLocale.InvalidType(),\n\t\t\t\t\tErrorDetails{\n\t\t\t\t\t\t\"expected\": TYPE_BOOLEAN,\n\t\t\t\t\t\t\"given\":    KEY_EXCLUSIVE_MAXIMUM,\n\t\t\t\t\t},\n\t\t\t\t))\n\t\t\t}\n\t\t\tif currentSchema.maximum == nil {\n\t\t\t\treturn errors.New(formatErrorDescription(\n\t\t\t\t\tLocale.CannotBeUsedWithout(),\n\t\t\t\t\tErrorDetails{\"x\": KEY_EXCLUSIVE_MAXIMUM, \"y\": KEY_MAXIMUM},\n\t\t\t\t))\n\t\t\t}\n\t\t\tif m[KEY_EXCLUSIVE_MAXIMUM].(bool) {\n\t\t\t\tcurrentSchema.exclusiveMaximum = currentSchema.maximum\n\t\t\t\tcurrentSchema.maximum = nil\n\t\t\t}\n\t\tcase Hybrid:\n\t\t\tif isKind(m[KEY_EXCLUSIVE_MAXIMUM], reflect.Bool) {\n\t\t\t\tif currentSchema.maximum == nil {\n\t\t\t\t\treturn errors.New(formatErrorDescription(\n\t\t\t\t\t\tLocale.CannotBeUsedWithout(),\n\t\t\t\t\t\tErrorDetails{\"x\": KEY_EXCLUSIVE_MAXIMUM, \"y\": KEY_MAXIMUM},\n\t\t\t\t\t))\n\t\t\t\t}\n\t\t\t\tif m[KEY_EXCLUSIVE_MAXIMUM].(bool) {\n\t\t\t\t\tcurrentSchema.exclusiveMaximum = currentSchema.maximum\n\t\t\t\t\tcurrentSchema.maximum = nil\n\t\t\t\t}\n\t\t\t} else if isJSONNumber(m[KEY_EXCLUSIVE_MAXIMUM]) {\n\t\t\t\tcurrentSchema.exclusiveMaximum = mustBeNumber(m[KEY_EXCLUSIVE_MAXIMUM])\n\t\t\t} else {\n\t\t\t\treturn errors.New(formatErrorDescription(\n\t\t\t\t\tLocale.InvalidType(),\n\t\t\t\t\tErrorDetails{\n\t\t\t\t\t\t\"expected\": TYPE_BOOLEAN + \"/\" + TYPE_NUMBER,\n\t\t\t\t\t\t\"given\":    KEY_EXCLUSIVE_MAXIMUM,\n\t\t\t\t\t},\n\t\t\t\t))\n\t\t\t}\n\t\tdefault:\n\t\t\tif isJSONNumber(m[KEY_EXCLUSIVE_MAXIMUM]) {\n\t\t\t\tcurrentSchema.exclusiveMaximum = mustBeNumber(m[KEY_EXCLUSIVE_MAXIMUM])\n\t\t\t} else {\n\t\t\t\treturn errors.New(formatErrorDescription(\n\t\t\t\t\tLocale.InvalidType(),\n\t\t\t\t\tErrorDetails{\n\t\t\t\t\t\t\"expected\": TYPE_NUMBER,\n\t\t\t\t\t\t\"given\":    KEY_EXCLUSIVE_MAXIMUM,\n\t\t\t\t\t},\n\t\t\t\t))\n\t\t\t}\n\t\t}\n\t}\n\n\t// validation : string\n\n\tif existsMapKey(m, KEY_MIN_LENGTH) {\n\t\tminLengthIntegerValue := mustBeInteger(m[KEY_MIN_LENGTH])\n\t\tif minLengthIntegerValue == nil {\n\t\t\treturn errors.New(formatErrorDescription(\n\t\t\t\tLocale.MustBeOfAn(),\n\t\t\t\tErrorDetails{\"x\": KEY_MIN_LENGTH, \"y\": TYPE_INTEGER},\n\t\t\t))\n\t\t}\n\t\tif *minLengthIntegerValue < 0 {\n\t\t\treturn errors.New(formatErrorDescription(\n\t\t\t\tLocale.MustBeGTEZero(),\n\t\t\t\tErrorDetails{\"key\": KEY_MIN_LENGTH},\n\t\t\t))\n\t\t}\n\t\tcurrentSchema.minLength = minLengthIntegerValue\n\t}\n\n\tif existsMapKey(m, KEY_MAX_LENGTH) {\n\t\tmaxLengthIntegerValue := mustBeInteger(m[KEY_MAX_LENGTH])\n\t\tif maxLengthIntegerValue == nil {\n\t\t\treturn errors.New(formatErrorDescription(\n\t\t\t\tLocale.MustBeOfAn(),\n\t\t\t\tErrorDetails{\"x\": KEY_MAX_LENGTH, \"y\": TYPE_INTEGER},\n\t\t\t))\n\t\t}\n\t\tif *maxLengthIntegerValue < 0 {\n\t\t\treturn errors.New(formatErrorDescription(\n\t\t\t\tLocale.MustBeGTEZero(),\n\t\t\t\tErrorDetails{\"key\": KEY_MAX_LENGTH},\n\t\t\t))\n\t\t}\n\t\tcurrentSchema.maxLength = maxLengthIntegerValue\n\t}\n\n\tif currentSchema.minLength != nil && currentSchema.maxLength != nil {\n\t\tif *currentSchema.minLength > *currentSchema.maxLength {\n\t\t\treturn errors.New(formatErrorDescription(\n\t\t\t\tLocale.CannotBeGT(),\n\t\t\t\tErrorDetails{\"x\": KEY_MIN_LENGTH, \"y\": KEY_MAX_LENGTH},\n\t\t\t))\n\t\t}\n\t}\n\n\tif existsMapKey(m, KEY_PATTERN) {\n\t\tif isKind(m[KEY_PATTERN], reflect.String) {\n\t\t\tregexpObject, err := regexp.Compile(m[KEY_PATTERN].(string))\n\t\t\tif err != nil {\n\t\t\t\treturn errors.New(formatErrorDescription(\n\t\t\t\t\tLocale.MustBeValidRegex(),\n\t\t\t\t\tErrorDetails{\"key\": KEY_PATTERN},\n\t\t\t\t))\n\t\t\t}\n\t\t\tcurrentSchema.pattern = regexpObject\n\t\t} else {\n\t\t\treturn errors.New(formatErrorDescription(\n\t\t\t\tLocale.MustBeOfA(),\n\t\t\t\tErrorDetails{\"x\": KEY_PATTERN, \"y\": TYPE_STRING},\n\t\t\t))\n\t\t}\n\t}\n\n\tif existsMapKey(m, KEY_FORMAT) {\n\t\tformatString, ok := m[KEY_FORMAT].(string)\n\t\tif !ok {\n\t\t\treturn errors.New(formatErrorDescription(\n\t\t\t\tLocale.MustBeOfType(),\n\t\t\t\tErrorDetails{\"key\": KEY_FORMAT, \"type\": TYPE_STRING},\n\t\t\t))\n\t\t}\n\t\tcurrentSchema.format = formatString\n\t}\n\n\t// validation : object\n\n\tif existsMapKey(m, KEY_MIN_PROPERTIES) {\n\t\tminPropertiesIntegerValue := mustBeInteger(m[KEY_MIN_PROPERTIES])\n\t\tif minPropertiesIntegerValue == nil {\n\t\t\treturn errors.New(formatErrorDescription(\n\t\t\t\tLocale.MustBeOfAn(),\n\t\t\t\tErrorDetails{\"x\": KEY_MIN_PROPERTIES, \"y\": TYPE_INTEGER},\n\t\t\t))\n\t\t}\n\t\tif *minPropertiesIntegerValue < 0 {\n\t\t\treturn errors.New(formatErrorDescription(\n\t\t\t\tLocale.MustBeGTEZero(),\n\t\t\t\tErrorDetails{\"key\": KEY_MIN_PROPERTIES},\n\t\t\t))\n\t\t}\n\t\tcurrentSchema.minProperties = minPropertiesIntegerValue\n\t}\n\n\tif existsMapKey(m, KEY_MAX_PROPERTIES) {\n\t\tmaxPropertiesIntegerValue := mustBeInteger(m[KEY_MAX_PROPERTIES])\n\t\tif maxPropertiesIntegerValue == nil {\n\t\t\treturn errors.New(formatErrorDescription(\n\t\t\t\tLocale.MustBeOfAn(),\n\t\t\t\tErrorDetails{\"x\": KEY_MAX_PROPERTIES, \"y\": TYPE_INTEGER},\n\t\t\t))\n\t\t}\n\t\tif *maxPropertiesIntegerValue < 0 {\n\t\t\treturn errors.New(formatErrorDescription(\n\t\t\t\tLocale.MustBeGTEZero(),\n\t\t\t\tErrorDetails{\"key\": KEY_MAX_PROPERTIES},\n\t\t\t))\n\t\t}\n\t\tcurrentSchema.maxProperties = maxPropertiesIntegerValue\n\t}\n\n\tif currentSchema.minProperties != nil && currentSchema.maxProperties != nil {\n\t\tif *currentSchema.minProperties > *currentSchema.maxProperties {\n\t\t\treturn errors.New(formatErrorDescription(\n\t\t\t\tLocale.KeyCannotBeGreaterThan(),\n\t\t\t\tErrorDetails{\"key\": KEY_MIN_PROPERTIES, \"y\": KEY_MAX_PROPERTIES},\n\t\t\t))\n\t\t}\n\t}\n\n\tif existsMapKey(m, KEY_REQUIRED) {\n\t\tif isKind(m[KEY_REQUIRED], reflect.Slice) {\n\t\t\trequiredValues := m[KEY_REQUIRED].([]interface{})\n\t\t\tfor _, requiredValue := range requiredValues {\n\t\t\t\tif isKind(requiredValue, reflect.String) {\n\t\t\t\t\tif isStringInSlice(currentSchema.required, requiredValue.(string)) {\n\t\t\t\t\t\treturn errors.New(formatErrorDescription(\n\t\t\t\t\t\t\tLocale.KeyItemsMustBeUnique(),\n\t\t\t\t\t\t\tErrorDetails{\"key\": KEY_REQUIRED},\n\t\t\t\t\t\t))\n\t\t\t\t\t}\n\t\t\t\t\tcurrentSchema.required = append(currentSchema.required, requiredValue.(string))\n\t\t\t\t} else {\n\t\t\t\t\treturn errors.New(formatErrorDescription(\n\t\t\t\t\t\tLocale.KeyItemsMustBeOfType(),\n\t\t\t\t\t\tErrorDetails{\"key\": KEY_REQUIRED, \"type\": TYPE_STRING},\n\t\t\t\t\t))\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\treturn errors.New(formatErrorDescription(\n\t\t\t\tLocale.MustBeOfAn(),\n\t\t\t\tErrorDetails{\"x\": KEY_REQUIRED, \"y\": TYPE_ARRAY},\n\t\t\t))\n\t\t}\n\t}\n\n\t// validation : array\n\n\tif existsMapKey(m, KEY_MIN_ITEMS) {\n\t\tminItemsIntegerValue := mustBeInteger(m[KEY_MIN_ITEMS])\n\t\tif minItemsIntegerValue == nil {\n\t\t\treturn errors.New(formatErrorDescription(\n\t\t\t\tLocale.MustBeOfAn(),\n\t\t\t\tErrorDetails{\"x\": KEY_MIN_ITEMS, \"y\": TYPE_INTEGER},\n\t\t\t))\n\t\t}\n\t\tif *minItemsIntegerValue < 0 {\n\t\t\treturn errors.New(formatErrorDescription(\n\t\t\t\tLocale.MustBeGTEZero(),\n\t\t\t\tErrorDetails{\"key\": KEY_MIN_ITEMS},\n\t\t\t))\n\t\t}\n\t\tcurrentSchema.minItems = minItemsIntegerValue\n\t}\n\n\tif existsMapKey(m, KEY_MAX_ITEMS) {\n\t\tmaxItemsIntegerValue := mustBeInteger(m[KEY_MAX_ITEMS])\n\t\tif maxItemsIntegerValue == nil {\n\t\t\treturn errors.New(formatErrorDescription(\n\t\t\t\tLocale.MustBeOfAn(),\n\t\t\t\tErrorDetails{\"x\": KEY_MAX_ITEMS, \"y\": TYPE_INTEGER},\n\t\t\t))\n\t\t}\n\t\tif *maxItemsIntegerValue < 0 {\n\t\t\treturn errors.New(formatErrorDescription(\n\t\t\t\tLocale.MustBeGTEZero(),\n\t\t\t\tErrorDetails{\"key\": KEY_MAX_ITEMS},\n\t\t\t))\n\t\t}\n\t\tcurrentSchema.maxItems = maxItemsIntegerValue\n\t}\n\n\tif existsMapKey(m, KEY_UNIQUE_ITEMS) {\n\t\tif isKind(m[KEY_UNIQUE_ITEMS], reflect.Bool) {\n\t\t\tcurrentSchema.uniqueItems = m[KEY_UNIQUE_ITEMS].(bool)\n\t\t} else {\n\t\t\treturn errors.New(formatErrorDescription(\n\t\t\t\tLocale.MustBeOfA(),\n\t\t\t\tErrorDetails{\"x\": KEY_UNIQUE_ITEMS, \"y\": TYPE_BOOLEAN},\n\t\t\t))\n\t\t}\n\t}\n\n\tif existsMapKey(m, KEY_CONTAINS) && *currentSchema.draft >= Draft6 {\n\t\tnewSchema := &subSchema{property: KEY_CONTAINS, parent: currentSchema, ref: currentSchema.ref}\n\t\tcurrentSchema.contains = newSchema\n\t\terr := d.parseSchema(m[KEY_CONTAINS], newSchema)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\t// validation : all\n\n\tif existsMapKey(m, KEY_CONST) && *currentSchema.draft >= Draft6 {\n\t\tis, err := marshalWithoutNumber(m[KEY_CONST])\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tcurrentSchema._const = is\n\t}\n\n\tif existsMapKey(m, KEY_ENUM) {\n\t\tif isKind(m[KEY_ENUM], reflect.Slice) {\n\t\t\tfor _, v := range m[KEY_ENUM].([]interface{}) {\n\t\t\t\tis, err := marshalWithoutNumber(v)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t\tif isStringInSlice(currentSchema.enum, *is) {\n\t\t\t\t\treturn errors.New(formatErrorDescription(\n\t\t\t\t\t\tLocale.KeyItemsMustBeUnique(),\n\t\t\t\t\t\tErrorDetails{\"key\": KEY_ENUM},\n\t\t\t\t\t))\n\t\t\t\t}\n\t\t\t\tcurrentSchema.enum = append(currentSchema.enum, *is)\n\t\t\t}\n\t\t} else {\n\t\t\treturn errors.New(formatErrorDescription(\n\t\t\t\tLocale.MustBeOfAn(),\n\t\t\t\tErrorDetails{\"x\": KEY_ENUM, \"y\": TYPE_ARRAY},\n\t\t\t))\n\t\t}\n\t}\n\n\t// validation : subSchema\n\n\tif existsMapKey(m, KEY_ONE_OF) {\n\t\tif isKind(m[KEY_ONE_OF], reflect.Slice) {\n\t\t\tfor _, v := range m[KEY_ONE_OF].([]interface{}) {\n\t\t\t\tnewSchema := &subSchema{property: KEY_ONE_OF, parent: currentSchema, ref: currentSchema.ref}\n\t\t\t\tcurrentSchema.oneOf = append(currentSchema.oneOf, newSchema)\n\t\t\t\terr := d.parseSchema(v, newSchema)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\treturn errors.New(formatErrorDescription(\n\t\t\t\tLocale.MustBeOfAn(),\n\t\t\t\tErrorDetails{\"x\": KEY_ONE_OF, \"y\": TYPE_ARRAY},\n\t\t\t))\n\t\t}\n\t}\n\n\tif existsMapKey(m, KEY_ANY_OF) {\n\t\tif isKind(m[KEY_ANY_OF], reflect.Slice) {\n\t\t\tfor _, v := range m[KEY_ANY_OF].([]interface{}) {\n\t\t\t\tnewSchema := &subSchema{property: KEY_ANY_OF, parent: currentSchema, ref: currentSchema.ref}\n\t\t\t\tcurrentSchema.anyOf = append(currentSchema.anyOf, newSchema)\n\t\t\t\terr := d.parseSchema(v, newSchema)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\treturn errors.New(formatErrorDescription(\n\t\t\t\tLocale.MustBeOfAn(),\n\t\t\t\tErrorDetails{\"x\": KEY_ANY_OF, \"y\": TYPE_ARRAY},\n\t\t\t))\n\t\t}\n\t}\n\n\tif existsMapKey(m, KEY_ALL_OF) {\n\t\tif isKind(m[KEY_ALL_OF], reflect.Slice) {\n\t\t\tfor _, v := range m[KEY_ALL_OF].([]interface{}) {\n\t\t\t\tnewSchema := &subSchema{property: KEY_ALL_OF, parent: currentSchema, ref: currentSchema.ref}\n\t\t\t\tcurrentSchema.allOf = append(currentSchema.allOf, newSchema)\n\t\t\t\terr := d.parseSchema(v, newSchema)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\treturn errors.New(formatErrorDescription(\n\t\t\t\tLocale.MustBeOfAn(),\n\t\t\t\tErrorDetails{\"x\": KEY_ANY_OF, \"y\": TYPE_ARRAY},\n\t\t\t))\n\t\t}\n\t}\n\n\tif existsMapKey(m, KEY_NOT) {\n\t\tif isKind(m[KEY_NOT], reflect.Map, reflect.Bool) {\n\t\t\tnewSchema := &subSchema{property: KEY_NOT, parent: currentSchema, ref: currentSchema.ref}\n\t\t\tcurrentSchema.not = newSchema\n\t\t\terr := d.parseSchema(m[KEY_NOT], newSchema)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t} else {\n\t\t\treturn errors.New(formatErrorDescription(\n\t\t\t\tLocale.MustBeOfAn(),\n\t\t\t\tErrorDetails{\"x\": KEY_NOT, \"y\": TYPE_OBJECT},\n\t\t\t))\n\t\t}\n\t}\n\n\tif *currentSchema.draft >= Draft7 {\n\t\tif existsMapKey(m, KEY_IF) {\n\t\t\tif isKind(m[KEY_IF], reflect.Map, reflect.Bool) {\n\t\t\t\tnewSchema := &subSchema{property: KEY_IF, parent: currentSchema, ref: currentSchema.ref}\n\t\t\t\tcurrentSchema._if = newSchema\n\t\t\t\terr := d.parseSchema(m[KEY_IF], newSchema)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\treturn errors.New(formatErrorDescription(\n\t\t\t\t\tLocale.MustBeOfAn(),\n\t\t\t\t\tErrorDetails{\"x\": KEY_IF, \"y\": TYPE_OBJECT},\n\t\t\t\t))\n\t\t\t}\n\t\t}\n\n\t\tif existsMapKey(m, KEY_THEN) {\n\t\t\tif isKind(m[KEY_THEN], reflect.Map, reflect.Bool) {\n\t\t\t\tnewSchema := &subSchema{property: KEY_THEN, parent: currentSchema, ref: currentSchema.ref}\n\t\t\t\tcurrentSchema._then = newSchema\n\t\t\t\terr := d.parseSchema(m[KEY_THEN], newSchema)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\treturn errors.New(formatErrorDescription(\n\t\t\t\t\tLocale.MustBeOfAn(),\n\t\t\t\t\tErrorDetails{\"x\": KEY_THEN, \"y\": TYPE_OBJECT},\n\t\t\t\t))\n\t\t\t}\n\t\t}\n\n\t\tif existsMapKey(m, KEY_ELSE) {\n\t\t\tif isKind(m[KEY_ELSE], reflect.Map, reflect.Bool) {\n\t\t\t\tnewSchema := &subSchema{property: KEY_ELSE, parent: currentSchema, ref: currentSchema.ref}\n\t\t\t\tcurrentSchema._else = newSchema\n\t\t\t\terr := d.parseSchema(m[KEY_ELSE], newSchema)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\treturn errors.New(formatErrorDescription(\n\t\t\t\t\tLocale.MustBeOfAn(),\n\t\t\t\t\tErrorDetails{\"x\": KEY_ELSE, \"y\": TYPE_OBJECT},\n\t\t\t\t))\n\t\t\t}\n\t\t}\n\t}\n\n\treturn nil\n}\n\nfunc (d *Schema) parseReference(documentNode interface{}, currentSchema *subSchema) error {\n\tvar (\n\t\trefdDocumentNode interface{}\n\t\tdsp              *schemaPoolDocument\n\t\terr              error\n\t)\n\n\tnewSchema := &subSchema{property: KEY_REF, parent: currentSchema, ref: currentSchema.ref}\n\n\td.referencePool.Add(currentSchema.ref.String(), newSchema)\n\n\tdsp, err = d.pool.GetDocument(*currentSchema.ref)\n\tif err != nil {\n\t\treturn err\n\t}\n\tnewSchema.id = currentSchema.ref\n\n\trefdDocumentNode = dsp.Document\n\tnewSchema.draft = dsp.Draft\n\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif !isKind(refdDocumentNode, reflect.Map, reflect.Bool) {\n\t\treturn errors.New(formatErrorDescription(\n\t\t\tLocale.MustBeOfType(),\n\t\t\tErrorDetails{\"key\": STRING_SCHEMA, \"type\": TYPE_OBJECT},\n\t\t))\n\t}\n\n\terr = d.parseSchema(refdDocumentNode, newSchema)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tcurrentSchema.refSchema = newSchema\n\n\treturn nil\n\n}\n\nfunc (d *Schema) parseProperties(documentNode interface{}, currentSchema *subSchema) error {\n\n\tif !isKind(documentNode, reflect.Map) {\n\t\treturn errors.New(formatErrorDescription(\n\t\t\tLocale.MustBeOfType(),\n\t\t\tErrorDetails{\"key\": STRING_PROPERTIES, \"type\": TYPE_OBJECT},\n\t\t))\n\t}\n\n\tm := documentNode.(map[string]interface{})\n\tfor k := range m {\n\t\tschemaProperty := k\n\t\tnewSchema := &subSchema{property: schemaProperty, parent: currentSchema, ref: currentSchema.ref}\n\t\tcurrentSchema.propertiesChildren = append(currentSchema.propertiesChildren, newSchema)\n\t\terr := d.parseSchema(m[k], newSchema)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\treturn nil\n}\n\nfunc (d *Schema) parseDependencies(documentNode interface{}, currentSchema *subSchema) error {\n\n\tif !isKind(documentNode, reflect.Map) {\n\t\treturn errors.New(formatErrorDescription(\n\t\t\tLocale.MustBeOfType(),\n\t\t\tErrorDetails{\"key\": KEY_DEPENDENCIES, \"type\": TYPE_OBJECT},\n\t\t))\n\t}\n\n\tm := documentNode.(map[string]interface{})\n\tcurrentSchema.dependencies = make(map[string]interface{})\n\n\tfor k := range m {\n\t\tswitch reflect.ValueOf(m[k]).Kind() {\n\n\t\tcase reflect.Slice:\n\t\t\tvalues := m[k].([]interface{})\n\t\t\tvar valuesToRegister []string\n\n\t\t\tfor _, value := range values {\n\t\t\t\tif !isKind(value, reflect.String) {\n\t\t\t\t\treturn errors.New(formatErrorDescription(\n\t\t\t\t\t\tLocale.MustBeOfType(),\n\t\t\t\t\t\tErrorDetails{\n\t\t\t\t\t\t\t\"key\":  STRING_DEPENDENCY,\n\t\t\t\t\t\t\t\"type\": STRING_SCHEMA_OR_ARRAY_OF_STRINGS,\n\t\t\t\t\t\t},\n\t\t\t\t\t))\n\t\t\t\t}\n\t\t\t\tvaluesToRegister = append(valuesToRegister, value.(string))\n\t\t\t\tcurrentSchema.dependencies[k] = valuesToRegister\n\t\t\t}\n\n\t\tcase reflect.Map, reflect.Bool:\n\t\t\tdepSchema := &subSchema{property: k, parent: currentSchema, ref: currentSchema.ref}\n\t\t\terr := d.parseSchema(m[k], depSchema)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tcurrentSchema.dependencies[k] = depSchema\n\n\t\tdefault:\n\t\t\treturn errors.New(formatErrorDescription(\n\t\t\t\tLocale.MustBeOfType(),\n\t\t\t\tErrorDetails{\n\t\t\t\t\t\"key\":  STRING_DEPENDENCY,\n\t\t\t\t\t\"type\": STRING_SCHEMA_OR_ARRAY_OF_STRINGS,\n\t\t\t\t},\n\t\t\t))\n\t\t}\n\n\t}\n\n\treturn nil\n}\n"
        },
        {
          "name": "schemaLoader.go",
          "type": "blob",
          "size": 4.4697265625,
          "content": "// Copyright 2018 johandorland ( https://github.com/johandorland )\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage gojsonschema\n\nimport (\n\t\"bytes\"\n\t\"errors\"\n\n\t\"github.com/xeipuuv/gojsonreference\"\n)\n\n// SchemaLoader is used to load schemas\ntype SchemaLoader struct {\n\tpool       *schemaPool\n\tAutoDetect bool\n\tValidate   bool\n\tDraft      Draft\n}\n\n// NewSchemaLoader creates a new NewSchemaLoader\nfunc NewSchemaLoader() *SchemaLoader {\n\n\tps := &SchemaLoader{\n\t\tpool: &schemaPool{\n\t\t\tschemaPoolDocuments: make(map[string]*schemaPoolDocument),\n\t\t},\n\t\tAutoDetect: true,\n\t\tValidate:   false,\n\t\tDraft:      Hybrid,\n\t}\n\tps.pool.autoDetect = &ps.AutoDetect\n\n\treturn ps\n}\n\nfunc (sl *SchemaLoader) validateMetaschema(documentNode interface{}) error {\n\n\tvar (\n\t\tschema string\n\t\terr    error\n\t)\n\tif sl.AutoDetect {\n\t\tschema, _, err = parseSchemaURL(documentNode)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\t// If no explicit \"$schema\" is used, use the default metaschema associated with the draft used\n\tif schema == \"\" {\n\t\tif sl.Draft == Hybrid {\n\t\t\treturn nil\n\t\t}\n\t\tschema = drafts.GetSchemaURL(sl.Draft)\n\t}\n\n\t//Disable validation when loading the metaschema to prevent an infinite recursive loop\n\tsl.Validate = false\n\n\tmetaSchema, err := sl.Compile(NewReferenceLoader(schema))\n\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tsl.Validate = true\n\n\tresult := metaSchema.validateDocument(documentNode)\n\n\tif !result.Valid() {\n\t\tvar res bytes.Buffer\n\t\tfor _, err := range result.Errors() {\n\t\t\tres.WriteString(err.String())\n\t\t\tres.WriteString(\"\\n\")\n\t\t}\n\t\treturn errors.New(res.String())\n\t}\n\n\treturn nil\n}\n\n// AddSchemas adds an arbritrary amount of schemas to the schema cache. As this function does not require\n// an explicit URL, every schema should contain an $id, so that it can be referenced by the main schema\nfunc (sl *SchemaLoader) AddSchemas(loaders ...JSONLoader) error {\n\temptyRef, _ := gojsonreference.NewJsonReference(\"\")\n\n\tfor _, loader := range loaders {\n\t\tdoc, err := loader.LoadJSON()\n\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tif sl.Validate {\n\t\t\tif err := sl.validateMetaschema(doc); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\n\t\t// Directly use the Recursive function, so that it get only added to the schema pool by $id\n\t\t// and not by the ref of the document as it's empty\n\t\tif err = sl.pool.parseReferences(doc, emptyRef, false); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\treturn nil\n}\n\n//AddSchema adds a schema under the provided URL to the schema cache\nfunc (sl *SchemaLoader) AddSchema(url string, loader JSONLoader) error {\n\n\tref, err := gojsonreference.NewJsonReference(url)\n\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tdoc, err := loader.LoadJSON()\n\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif sl.Validate {\n\t\tif err := sl.validateMetaschema(doc); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\treturn sl.pool.parseReferences(doc, ref, true)\n}\n\n// Compile loads and compiles a schema\nfunc (sl *SchemaLoader) Compile(rootSchema JSONLoader) (*Schema, error) {\n\n\tref, err := rootSchema.JsonReference()\n\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\td := Schema{}\n\td.pool = sl.pool\n\td.pool.jsonLoaderFactory = rootSchema.LoaderFactory()\n\td.documentReference = ref\n\td.referencePool = newSchemaReferencePool()\n\n\tvar doc interface{}\n\tif ref.String() != \"\" {\n\t\t// Get document from schema pool\n\t\tspd, err := d.pool.GetDocument(d.documentReference)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tdoc = spd.Document\n\t} else {\n\t\t// Load JSON directly\n\t\tdoc, err = rootSchema.LoadJSON()\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\t// References need only be parsed if loading JSON directly\n\t\t//  as pool.GetDocument already does this for us if loading by reference\n\t\terr = sl.pool.parseReferences(doc, ref, true)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\tif sl.Validate {\n\t\tif err := sl.validateMetaschema(doc); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\tdraft := sl.Draft\n\tif sl.AutoDetect {\n\t\t_, detectedDraft, err := parseSchemaURL(doc)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tif detectedDraft != nil {\n\t\t\tdraft = *detectedDraft\n\t\t}\n\t}\n\n\terr = d.parse(doc, draft)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn &d, nil\n}\n"
        },
        {
          "name": "schemaLoader_test.go",
          "type": "blob",
          "size": 4.990234375,
          "content": "// Copyright 2018 johandorland ( https://github.com/johandorland )\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage gojsonschema\n\nimport (\n\t\"github.com/stretchr/testify/require\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestSchemaLoaderWithReferenceToAddedSchema(t *testing.T) {\n\tsl := NewSchemaLoader()\n\terr := sl.AddSchemas(NewStringLoader(`{\n\t\t\"$id\" : \"http://localhost:1234/test1.json\",\n\t\t\"type\" : \"integer\"\n\t\t}`))\n\n\tassert.Nil(t, err)\n\tschema, err := sl.Compile(NewReferenceLoader(\"http://localhost:1234/test1.json\"))\n\tassert.Nil(t, err)\n\tresult, err := schema.Validate(NewStringLoader(`\"hello\"`))\n\tassert.Nil(t, err)\n\tif len(result.Errors()) != 1 || result.Errors()[0].Type() != \"invalid_type\" {\n\t\tt.Errorf(\"Expected invalid type erorr, instead got %v\", result.Errors())\n\t}\n}\n\nfunc TestCrossReference(t *testing.T) {\n\tschema1 := NewStringLoader(`{\n\t\t\"$ref\" : \"http://localhost:1234/test3.json\",\n\t\t\"definitions\" : {\n\t\t\t\"foo\" : {\n\t\t\t\t\"type\" : \"integer\"\n\t\t\t}\n\t\t}\n\t}`)\n\tschema2 := NewStringLoader(`{\n\t\t\"$ref\" : \"http://localhost:1234/test2.json#/definitions/foo\"\n\t}`)\n\n\tsl := NewSchemaLoader()\n\terr := sl.AddSchema(\"http://localhost:1234/test2.json\", schema1)\n\tassert.Nil(t, err)\n\terr = sl.AddSchema(\"http://localhost:1234/test3.json\", schema2)\n\tassert.Nil(t, err)\n\tschema, err := sl.Compile(NewStringLoader(`{\"$ref\" : \"http://localhost:1234/test2.json\"}`))\n\tassert.Nil(t, err)\n\tresult, err := schema.Validate(NewStringLoader(`\"hello\"`))\n\tassert.Nil(t, err)\n\tif len(result.Errors()) != 1 || result.Errors()[0].Type() != \"invalid_type\" {\n\t\tt.Errorf(\"Expected invalid type erorr, instead got %v\", result.Errors())\n\t}\n}\n\n// Multiple schemas identifying under the same $id should throw an error\nfunc TestDoubleIDReference(t *testing.T) {\n\tsl := NewSchemaLoader()\n\terr := sl.AddSchema(\"http://localhost:1234/test4.json\", NewStringLoader(\"{}\"))\n\tassert.Nil(t, err)\n\terr = sl.AddSchemas(NewStringLoader(`{ \"$id\" : \"http://localhost:1234/test4.json\"}`))\n\tassert.NotNil(t, err)\n}\n\nfunc TestCustomMetaSchema(t *testing.T) {\n\n\tloader := NewStringLoader(`{\n\t\t\"$id\" : \"http://localhost:1234/test5.json\",\n\t\t\"properties\" : {\n\t\t\t\"multipleOf\" : false\n\t\t}\n\t}`)\n\n\t// Test a custom metaschema in which we disallow the use of the keyword \"multipleOf\"\n\tsl := NewSchemaLoader()\n\tsl.Validate = true\n\n\terr := sl.AddSchemas(loader)\n\tassert.Nil(t, err)\n\t_, err = sl.Compile(NewStringLoader(`{\n\t\t\"$id\" : \"http://localhost:1234/test6.json\",\n\t\t\"$schema\" : \"http://localhost:1234/test5.json\",\n\t\t\"type\" : \"string\"\n\t}`))\n\tassert.Nil(t, err)\n\n\tsl = NewSchemaLoader()\n\tsl.Validate = true\n\terr = sl.AddSchemas(loader)\n\tassert.Nil(t, err)\n\t_, err = sl.Compile(NewStringLoader(`{\n\t\t\"$id\" : \"http://localhost:1234/test7.json\",\n\t\t\"$schema\" : \"http://localhost:1234/test5.json\",\n\t\t\"multipleOf\" : 5\n\t}`))\n\tassert.NotNil(t, err)\n}\n\nfunc TestSchemaDetection(t *testing.T) {\n\tloader := NewStringLoader(`{\n\t\t\"$schema\" : \"http://json-schema.org/draft-04/schema#\",\n\t\t\"exclusiveMinimum\" : 5\n\t}`)\n\n\t// The schema should produce an error in draft-04 mode\n\t_, err := NewSchema(loader)\n\tassert.NotNil(t, err)\n\n\t// With schema detection disabled the schema should not produce an error in hybrid mode\n\tsl := NewSchemaLoader()\n\tsl.AutoDetect = false\n\n\t_, err = sl.Compile(loader)\n\tassert.Nil(t, err)\n}\n\nfunc TestDraftCrossReferencing(t *testing.T) {\n\n\t// Tests the following cross referencing with any combination\n\t// of autodetection and preset draft version.\n\n\tloader1 := NewStringLoader(`{\n\t\t\"$schema\" : \"http://json-schema.org/draft-04/schema#\",\n\t\t\"id\" : \"http://localhost:1234/file.json\",\n\t\t\"$id\" : \"http://localhost:1234/file.json\",\n\t\t\"exclusiveMinimum\" : 5\n\t}`)\n\tloader2 := NewStringLoader(`{\n\t\t\"$schema\" : \"http://json-schema.org/draft-07/schema#\",\n\t\t\"id\" : \"http://localhost:1234/main.json\",\n\t\t\"$id\" : \"http://localhost:1234/main.json\",\n\t\t\"$ref\" : \"file.json\"\n\t}`)\n\n\tfor _, b := range []bool{true, false} {\n\t\tfor _, draft := range []Draft{Draft4, Draft6, Draft7} {\n\t\t\tsl := NewSchemaLoader()\n\t\t\tsl.Draft = draft\n\t\t\tsl.AutoDetect = b\n\n\t\t\terr := sl.AddSchemas(loader1)\n\t\t\tassert.Nil(t, err)\n\t\t\t_, err = sl.Compile(loader2)\n\n\t\t\t// It will always fail with autodetection on as \"exclusiveMinimum\" : 5\n\t\t\t// is only valid since draft-06. With autodetection off it will pass if\n\t\t\t// draft-06 or newer is used\n\n\t\t\tassert.Equal(t, err == nil, !b && draft >= Draft6)\n\t\t}\n\t}\n}\n\nconst not_map_interface = \"not map interface\"\n\nfunc TestParseSchemaURL_NotMap(t *testing.T) {\n\t//GIVEN\n\tsl := NewGoLoader(not_map_interface)\n\t//WHEN\n\t_, err := NewSchema(sl)\n\t//THEN\n\trequire.Error(t, err)\n\tassert.EqualError(t, err, \"schema is invalid\")\n}\n"
        },
        {
          "name": "schemaPool.go",
          "type": "blob",
          "size": 6.1845703125,
          "content": "// Copyright 2015 xeipuuv ( https://github.com/xeipuuv )\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n// author           xeipuuv\n// author-github    https://github.com/xeipuuv\n// author-mail      xeipuuv@gmail.com\n//\n// repository-name  gojsonschema\n// repository-desc  An implementation of JSON Schema, based on IETF's draft v4 - Go language.\n//\n// description\t\tDefines resources pooling.\n//                  Eases referencing and avoids downloading the same resource twice.\n//\n// created          26-02-2013\n\npackage gojsonschema\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"reflect\"\n\n\t\"github.com/xeipuuv/gojsonreference\"\n)\n\ntype schemaPoolDocument struct {\n\tDocument interface{}\n\tDraft    *Draft\n}\n\ntype schemaPool struct {\n\tschemaPoolDocuments map[string]*schemaPoolDocument\n\tjsonLoaderFactory   JSONLoaderFactory\n\tautoDetect          *bool\n}\n\nfunc (p *schemaPool) parseReferences(document interface{}, ref gojsonreference.JsonReference, pooled bool) error {\n\n\tvar (\n\t\tdraft     *Draft\n\t\terr       error\n\t\treference = ref.String()\n\t)\n\t// Only the root document should be added to the schema pool if pooled is true\n\tif _, ok := p.schemaPoolDocuments[reference]; pooled && ok {\n\t\treturn fmt.Errorf(\"Reference already exists: \\\"%s\\\"\", reference)\n\t}\n\n\tif *p.autoDetect {\n\t\t_, draft, err = parseSchemaURL(document)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\terr = p.parseReferencesRecursive(document, ref, draft)\n\n\tif pooled {\n\t\tp.schemaPoolDocuments[reference] = &schemaPoolDocument{Document: document, Draft: draft}\n\t}\n\n\treturn err\n}\n\nfunc (p *schemaPool) parseReferencesRecursive(document interface{}, ref gojsonreference.JsonReference, draft *Draft) error {\n\t// parseReferencesRecursive parses a JSON document and resolves all $id and $ref references.\n\t// For $ref references it takes into account the $id scope it is in and replaces\n\t// the reference by the absolute resolved reference\n\n\t// When encountering errors it fails silently. Error handling is done when the schema\n\t// is syntactically parsed and any error encountered here should also come up there.\n\tswitch m := document.(type) {\n\tcase []interface{}:\n\t\tfor _, v := range m {\n\t\t\tp.parseReferencesRecursive(v, ref, draft)\n\t\t}\n\tcase map[string]interface{}:\n\t\tlocalRef := &ref\n\n\t\tkeyID := KEY_ID_NEW\n\t\tif existsMapKey(m, KEY_ID) {\n\t\t\tkeyID = KEY_ID\n\t\t}\n\t\tif existsMapKey(m, keyID) && isKind(m[keyID], reflect.String) {\n\t\t\tjsonReference, err := gojsonreference.NewJsonReference(m[keyID].(string))\n\t\t\tif err == nil {\n\t\t\t\tlocalRef, err = ref.Inherits(jsonReference)\n\t\t\t\tif err == nil {\n\t\t\t\t\tif _, ok := p.schemaPoolDocuments[localRef.String()]; ok {\n\t\t\t\t\t\treturn fmt.Errorf(\"Reference already exists: \\\"%s\\\"\", localRef.String())\n\t\t\t\t\t}\n\t\t\t\t\tp.schemaPoolDocuments[localRef.String()] = &schemaPoolDocument{Document: document, Draft: draft}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif existsMapKey(m, KEY_REF) && isKind(m[KEY_REF], reflect.String) {\n\t\t\tjsonReference, err := gojsonreference.NewJsonReference(m[KEY_REF].(string))\n\t\t\tif err == nil {\n\t\t\t\tabsoluteRef, err := localRef.Inherits(jsonReference)\n\t\t\t\tif err == nil {\n\t\t\t\t\tm[KEY_REF] = absoluteRef.String()\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor k, v := range m {\n\t\t\t// const and enums should be interpreted literally, so ignore them\n\t\t\tif k == KEY_CONST || k == KEY_ENUM {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\t// Something like a property or a dependency is not a valid schema, as it might describe properties named \"$ref\", \"$id\" or \"const\", etc\n\t\t\t// Therefore don't treat it like a schema.\n\t\t\tif k == KEY_PROPERTIES || k == KEY_DEPENDENCIES || k == KEY_PATTERN_PROPERTIES {\n\t\t\t\tif child, ok := v.(map[string]interface{}); ok {\n\t\t\t\t\tfor _, v := range child {\n\t\t\t\t\t\tp.parseReferencesRecursive(v, *localRef, draft)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tp.parseReferencesRecursive(v, *localRef, draft)\n\t\t\t}\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc (p *schemaPool) GetDocument(reference gojsonreference.JsonReference) (*schemaPoolDocument, error) {\n\n\tvar (\n\t\tspd   *schemaPoolDocument\n\t\tdraft *Draft\n\t\tok    bool\n\t\terr   error\n\t)\n\n\tif internalLogEnabled {\n\t\tinternalLog(\"Get Document ( %s )\", reference.String())\n\t}\n\n\t// Create a deep copy, so we can remove the fragment part later on without altering the original\n\trefToURL, _ := gojsonreference.NewJsonReference(reference.String())\n\n\t// First check if the given fragment is a location independent identifier\n\t// http://json-schema.org/latest/json-schema-core.html#rfc.section.8.2.3\n\n\tif spd, ok = p.schemaPoolDocuments[refToURL.String()]; ok {\n\t\tif internalLogEnabled {\n\t\t\tinternalLog(\" From pool\")\n\t\t}\n\t\treturn spd, nil\n\t}\n\n\t// If the given reference is not a location independent identifier,\n\t// strip the fragment and look for a document with it's base URI\n\n\trefToURL.GetUrl().Fragment = \"\"\n\n\tif cachedSpd, ok := p.schemaPoolDocuments[refToURL.String()]; ok {\n\t\tdocument, _, err := reference.GetPointer().Get(cachedSpd.Document)\n\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tif internalLogEnabled {\n\t\t\tinternalLog(\" From pool\")\n\t\t}\n\n\t\tspd = &schemaPoolDocument{Document: document, Draft: cachedSpd.Draft}\n\t\tp.schemaPoolDocuments[reference.String()] = spd\n\n\t\treturn spd, nil\n\t}\n\n\t// It is not possible to load anything remotely that is not canonical...\n\tif !reference.IsCanonical() {\n\t\treturn nil, errors.New(formatErrorDescription(\n\t\t\tLocale.ReferenceMustBeCanonical(),\n\t\t\tErrorDetails{\"reference\": reference.String()},\n\t\t))\n\t}\n\n\tjsonReferenceLoader := p.jsonLoaderFactory.New(reference.String())\n\tdocument, err := jsonReferenceLoader.LoadJSON()\n\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// add the whole document to the pool for potential re-use\n\tp.parseReferences(document, refToURL, true)\n\n\t_, draft, _ = parseSchemaURL(document)\n\n\t// resolve the potential fragment and also cache it\n\tdocument, _, err = reference.GetPointer().Get(document)\n\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn &schemaPoolDocument{Document: document, Draft: draft}, nil\n}\n"
        },
        {
          "name": "schemaReferencePool.go",
          "type": "blob",
          "size": 1.6953125,
          "content": "// Copyright 2015 xeipuuv ( https://github.com/xeipuuv )\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n// author           xeipuuv\n// author-github    https://github.com/xeipuuv\n// author-mail      xeipuuv@gmail.com\n//\n// repository-name  gojsonschema\n// repository-desc  An implementation of JSON Schema, based on IETF's draft v4 - Go language.\n//\n// description      Pool of referenced schemas.\n//\n// created          25-06-2013\n\npackage gojsonschema\n\nimport (\n\t\"fmt\"\n)\n\ntype schemaReferencePool struct {\n\tdocuments map[string]*subSchema\n}\n\nfunc newSchemaReferencePool() *schemaReferencePool {\n\n\tp := &schemaReferencePool{}\n\tp.documents = make(map[string]*subSchema)\n\n\treturn p\n}\n\nfunc (p *schemaReferencePool) Get(ref string) (r *subSchema, o bool) {\n\n\tif internalLogEnabled {\n\t\tinternalLog(fmt.Sprintf(\"Schema Reference ( %s )\", ref))\n\t}\n\n\tif sch, ok := p.documents[ref]; ok {\n\t\tif internalLogEnabled {\n\t\t\tinternalLog(fmt.Sprintf(\" From pool\"))\n\t\t}\n\t\treturn sch, true\n\t}\n\n\treturn nil, false\n}\n\nfunc (p *schemaReferencePool) Add(ref string, sch *subSchema) {\n\n\tif internalLogEnabled {\n\t\tinternalLog(fmt.Sprintf(\"Add Schema Reference %s to pool\", ref))\n\t}\n\tif _, ok := p.documents[ref]; !ok {\n\t\tp.documents[ref] = sch\n\t}\n}\n"
        },
        {
          "name": "schemaType.go",
          "type": "blob",
          "size": 2.0849609375,
          "content": "// Copyright 2015 xeipuuv ( https://github.com/xeipuuv )\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n// author           xeipuuv\n// author-github    https://github.com/xeipuuv\n// author-mail      xeipuuv@gmail.com\n//\n// repository-name  gojsonschema\n// repository-desc  An implementation of JSON Schema, based on IETF's draft v4 - Go language.\n//\n// description      Helper structure to handle schema types, and the combination of them.\n//\n// created          28-02-2013\n\npackage gojsonschema\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"strings\"\n)\n\ntype jsonSchemaType struct {\n\ttypes []string\n}\n\n// Is the schema typed ? that is containing at least one type\n// When not typed, the schema does not need any type validation\nfunc (t *jsonSchemaType) IsTyped() bool {\n\treturn len(t.types) > 0\n}\n\nfunc (t *jsonSchemaType) Add(etype string) error {\n\n\tif !isStringInSlice(JSON_TYPES, etype) {\n\t\treturn errors.New(formatErrorDescription(Locale.NotAValidType(), ErrorDetails{\"given\": \"/\" + etype + \"/\", \"expected\": JSON_TYPES}))\n\t}\n\n\tif t.Contains(etype) {\n\t\treturn errors.New(formatErrorDescription(Locale.Duplicated(), ErrorDetails{\"type\": etype}))\n\t}\n\n\tt.types = append(t.types, etype)\n\n\treturn nil\n}\n\nfunc (t *jsonSchemaType) Contains(etype string) bool {\n\n\tfor _, v := range t.types {\n\t\tif v == etype {\n\t\t\treturn true\n\t\t}\n\t}\n\n\treturn false\n}\n\nfunc (t *jsonSchemaType) String() string {\n\n\tif len(t.types) == 0 {\n\t\treturn STRING_UNDEFINED // should never happen\n\t}\n\n\t// Displayed as a list [type1,type2,...]\n\tif len(t.types) > 1 {\n\t\treturn fmt.Sprintf(\"[%s]\", strings.Join(t.types, \",\"))\n\t}\n\n\t// Only one type: name only\n\treturn t.types[0]\n}\n"
        },
        {
          "name": "schema_test.go",
          "type": "blob",
          "size": 8.3681640625,
          "content": "// Copyright 2015 xeipuuv ( https://github.com/xeipuuv )\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n// author           xeipuuv\n// author-github    https://github.com/xeipuuv\n// author-mail      xeipuuv@gmail.com\n//\n// repository-name  gojsonschema\n// repository-desc  An implementation of JSON Schema, based on IETF's draft v4 - Go language.\n//\n// description      (Unit) Tests for schema validation.\n//\n// created          16-06-2013\n\npackage gojsonschema\n\nimport (\n\t\"bytes\"\n\t\"fmt\"\n\t\"io\"\n\t\"io/ioutil\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nconst displayErrorMessages = false\n\nconst circularReference = `{\n\t\"type\": \"object\",\n\t\"properties\": {\n\t\t\"games\": {\n\t\t\t\"type\": \"array\",\n\t\t\t\"items\": {\n\t\t\t\t\"$ref\": \"#/definitions/game\"\n\t\t\t}\n\t\t}\n\t},\n\t\"definitions\": {\n\t\t\"game\": {\n\t\t\t\"type\": \"object\",\n\t\t\t\"properties\": {\n\t\t\t\t\"winner\": {\n\t\t\t\t\t\"$ref\": \"#/definitions/player\"\n\t\t\t\t},\n\t\t\t\t\"loser\": {\n\t\t\t\t\t\"$ref\": \"#/definitions/player\"\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\t\"player\": {\n\t\t\t\"type\": \"object\",\n\t\t\t\"properties\": {\n\t\t\t\t\"user\": {\n\t\t\t\t\t\"$ref\": \"#/definitions/user\"\n\t\t\t\t},\n\t\t\t\t\"game\": {\n\t\t\t\t\t\"$ref\": \"#/definitions/game\"\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\t\"user\": {\n\t\t\t\"type\": \"object\",\n\t\t\t\"properties\": {\n\t\t\t\t\"fullName\": {\n\t\t\t\t\t\"type\": \"string\"\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}`\n\nfunc TestCircularReference(t *testing.T) {\n\tloader := NewStringLoader(circularReference)\n\t// call the target function\n\t_, err := NewSchema(loader)\n\tif err != nil {\n\t\tt.Errorf(\"Got error: %s\", err.Error())\n\t}\n}\n\n// From http://json-schema.org/examples.html\nconst simpleSchema = `{\n  \"title\": \"Example Schema\",\n  \"type\": \"object\",\n  \"properties\": {\n    \"firstName\": {\n      \"type\": \"string\"\n    },\n    \"lastName\": {\n      \"type\": \"string\"\n    },\n    \"age\": {\n      \"description\": \"Age in years\",\n      \"type\": \"integer\",\n      \"minimum\": 0\n    }\n  },\n  \"required\": [\"firstName\", \"lastName\"]\n}`\n\nfunc TestLoaders(t *testing.T) {\n\t// setup reader loader\n\treader := bytes.NewBufferString(simpleSchema)\n\treaderLoader, wrappedReader := NewReaderLoader(reader)\n\n\t// drain reader\n\tby, err := ioutil.ReadAll(wrappedReader)\n\tassert.Nil(t, err)\n\tassert.Equal(t, simpleSchema, string(by))\n\n\t// setup writer loaders\n\twriter := &bytes.Buffer{}\n\twriterLoader, wrappedWriter := NewWriterLoader(writer)\n\n\t// fill writer\n\tn, err := io.WriteString(wrappedWriter, simpleSchema)\n\tassert.Nil(t, err)\n\tassert.Equal(t, n, len(simpleSchema))\n\n\tloaders := []JSONLoader{\n\t\tNewStringLoader(simpleSchema),\n\t\treaderLoader,\n\t\twriterLoader,\n\t}\n\n\tfor _, l := range loaders {\n\t\t_, err := NewSchema(l)\n\t\tassert.Nil(t, err, \"loader: %T\", l)\n\t}\n}\n\nconst invalidPattern = `{\n  \"title\": \"Example Pattern\",\n  \"type\": \"object\",\n  \"properties\": {\n    \"invalid\": {\n      \"type\": \"string\",\n      \"pattern\": 99999\n    }\n  }\n}`\n\nfunc TestLoadersWithInvalidPattern(t *testing.T) {\n\t// setup reader loader\n\treader := bytes.NewBufferString(invalidPattern)\n\treaderLoader, wrappedReader := NewReaderLoader(reader)\n\n\t// drain reader\n\tby, err := ioutil.ReadAll(wrappedReader)\n\tassert.Nil(t, err)\n\tassert.Equal(t, invalidPattern, string(by))\n\n\t// setup writer loaders\n\twriter := &bytes.Buffer{}\n\twriterLoader, wrappedWriter := NewWriterLoader(writer)\n\n\t// fill writer\n\tn, err := io.WriteString(wrappedWriter, invalidPattern)\n\tassert.Nil(t, err)\n\tassert.Equal(t, n, len(invalidPattern))\n\n\tloaders := []JSONLoader{\n\t\tNewStringLoader(invalidPattern),\n\t\treaderLoader,\n\t\twriterLoader,\n\t}\n\n\tfor _, l := range loaders {\n\t\t_, err := NewSchema(l)\n\t\tassert.NotNil(t, err, \"expected error loading invalid pattern: %T\", l)\n\t}\n}\n\nconst refPropertySchema = `{\n\t\"$id\" : \"http://localhost/schema.json\",\n\t\"properties\" : {\n\t\t\"$id\" : {\n\t\t\t\"$id\": \"http://localhost/foo.json\"\n\t\t},\n\t\t\"$ref\" : {\n\t\t\t\"const\": {\n\t\t\t\t\"$ref\" : \"hello.world\"\n\t\t\t}\n\t\t},\n\t\t\"const\" : {\n\t\t\t\"$ref\" : \"#/definitions/$ref\"\n\t\t}\n\t},\n\t\"definitions\" : {\n\t\t\"$ref\" : {\n\t\t\t\"const\": {\n\t\t\t\t\"$ref\" : \"hello.world\"\n\t\t\t}\n\t\t}\n\t},\n\t\"dependencies\" : {\n\t\t\"$ref\" : [ \"const\" ],\n\t\t\"const\" : [ \"$ref\" ]\n\t}\n}`\n\nfunc TestRefProperty(t *testing.T) {\n\tschemaLoader := NewStringLoader(refPropertySchema)\n\tdocumentLoader := NewStringLoader(`{\n\t\t\"$ref\" : { \"$ref\" : \"hello.world\" },\n\t\t\"const\" : { \"$ref\" : \"hello.world\" }\n\t\t}`)\n\t// call the target function\n\ts, err := NewSchema(schemaLoader)\n\tif err != nil {\n\t\tt.Errorf(\"Got error: %s\", err.Error())\n\t}\n\tresult, err := s.Validate(documentLoader)\n\tif err != nil {\n\t\tt.Errorf(\"Got error: %s\", err.Error())\n\t}\n\tif !result.Valid() {\n\t\tfor _, err := range result.Errors() {\n\t\t\tfmt.Println(err.String())\n\t\t}\n\t\tt.Errorf(\"Got invalid validation result.\")\n\t}\n}\n\nfunc TestFragmentLoader(t *testing.T) {\n\twd, err := os.Getwd()\n\n\tif err != nil {\n\t\tpanic(err.Error())\n\t}\n\n\tfileName := filepath.Join(wd, \"testdata\", \"extra\", \"fragment_schema.json\")\n\n\tschemaLoader := NewReferenceLoader(\"file://\" + filepath.ToSlash(fileName) + \"#/definitions/x\")\n\tschema, err := NewSchema(schemaLoader)\n\n\tif err != nil {\n\t\tt.Errorf(\"Encountered error while loading schema: %s\", err.Error())\n\t}\n\n\tvalidDocument := NewStringLoader(`5`)\n\tinvalidDocument := NewStringLoader(`\"a\"`)\n\n\tresult, err := schema.Validate(validDocument)\n\n\tif assert.Nil(t, err, \"Unexpected error while validating document: %T\", err) {\n\t\tif !result.Valid() {\n\t\t\tt.Errorf(\"Got invalid validation result.\")\n\t\t}\n\t}\n\n\tresult, err = schema.Validate(invalidDocument)\n\n\tif assert.Nil(t, err, \"Unexpected error while validating document: %T\", err) {\n\t\tif len(result.Errors()) != 1 || result.Errors()[0].Type() != \"invalid_type\" {\n\t\t\tt.Errorf(\"Got invalid validation result.\")\n\t\t}\n\t}\n}\n\nfunc TestFileWithSpace(t *testing.T) {\n\twd, err := os.Getwd()\n\n\tif err != nil {\n\t\tpanic(err.Error())\n\t}\n\n\tfileName := filepath.Join(wd, \"testdata\", \"extra\", \"file with space.json\")\n\tloader := NewReferenceLoader(\"file://\" + filepath.ToSlash(fileName))\n\n\tjson, err := loader.LoadJSON()\n\n\tassert.Nil(t, err, \"Unexpected error when trying to load a filepath containing a space\")\n\tassert.Equal(t, map[string]interface{}{\"foo\": true}, json, \"Contents of the file do not match\")\n}\n\nfunc TestAdditionalPropertiesErrorMessage(t *testing.T) {\n\tschema := `{\n  \"$schema\": \"http://json-schema.org/draft-07/schema#\",\n  \"type\": \"object\",\n  \"properties\": {\n    \"Device\": {\n      \"type\": \"object\",\n      \"additionalProperties\": {\n        \"type\": \"string\"\n      }\n    }\n  }\n}`\n\ttext := `{\n\t\t\"Device\":{\n\t\t\t\"Color\" : true\n\t\t}\n\t}`\n\tloader := NewBytesLoader([]byte(schema))\n\tresult, err := Validate(loader, NewBytesLoader([]byte(text)))\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tif len(result.Errors()) != 1 {\n\t\tt.Fatal(\"Expected 1 error but got\", len(result.Errors()))\n\t}\n\n\texpected := \"Device.Color: Invalid type. Expected: string, given: boolean\"\n\tactual := result.Errors()[0].String()\n\tif actual != expected {\n\t\tt.Fatalf(\"Expected '%s' but got '%s'\", expected, actual)\n\t}\n}\n\n// Inspired by http://json-schema.org/latest/json-schema-core.html#rfc.section.8.2.3\nconst locationIndependentSchema = `{\n  \"definitions\": {\n    \"A\": {\n      \"$id\": \"#foo\"\n    },\n    \"B\": {\n      \"$id\": \"http://example.com/other.json\",\n      \"definitions\": {\n        \"X\": {\n          \"$id\": \"#bar\",\n          \"allOf\": [false]\n        },\n        \"Y\": {\n          \"$id\": \"t/inner.json\"\n        }\n      }\n    },\n    \"C\": {\n\t\t\t\"$id\" : \"#frag\",\n      \"$ref\": \"http://example.com/other.json#bar\"\n    }\n  },\n  \"$ref\": \"#frag\"\n}`\n\nfunc TestLocationIndependentIdentifier(t *testing.T) {\n\tschemaLoader := NewStringLoader(locationIndependentSchema)\n\tdocumentLoader := NewStringLoader(`{}`)\n\n\ts, err := NewSchema(schemaLoader)\n\tif err != nil {\n\t\tt.Errorf(\"Got error: %s\", err.Error())\n\t}\n\n\tresult, err := s.Validate(documentLoader)\n\tif err != nil {\n\t\tt.Errorf(\"Got error: %s\", err.Error())\n\t}\n\n\tif len(result.Errors()) != 2 || result.Errors()[0].Type() != \"false\" || result.Errors()[1].Type() != \"number_all_of\" {\n\t\tt.Errorf(\"Got invalid validation result.\")\n\t}\n}\n\nconst incorrectRefSchema = `{\n  \"$ref\" : \"#/fail\"\n}`\n\nfunc TestIncorrectRef(t *testing.T) {\n\n\tschemaLoader := NewStringLoader(incorrectRefSchema)\n\ts, err := NewSchema(schemaLoader)\n\n\tassert.Nil(t, s)\n\tassert.Equal(t, \"Object has no key 'fail'\", err.Error())\n}\n"
        },
        {
          "name": "subSchema.go",
          "type": "blob",
          "size": 4.146484375,
          "content": "// Copyright 2015 xeipuuv ( https://github.com/xeipuuv )\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n// author           xeipuuv\n// author-github    https://github.com/xeipuuv\n// author-mail      xeipuuv@gmail.com\n//\n// repository-name  gojsonschema\n// repository-desc  An implementation of JSON Schema, based on IETF's draft v4 - Go language.\n//\n// description      Defines the structure of a sub-subSchema.\n//                  A sub-subSchema can contain other sub-schemas.\n//\n// created          27-02-2013\n\npackage gojsonschema\n\nimport (\n\t\"github.com/xeipuuv/gojsonreference\"\n\t\"math/big\"\n\t\"regexp\"\n)\n\n// Constants\nconst (\n\tKEY_SCHEMA                = \"$schema\"\n\tKEY_ID                    = \"id\"\n\tKEY_ID_NEW                = \"$id\"\n\tKEY_REF                   = \"$ref\"\n\tKEY_TITLE                 = \"title\"\n\tKEY_DESCRIPTION           = \"description\"\n\tKEY_TYPE                  = \"type\"\n\tKEY_ITEMS                 = \"items\"\n\tKEY_ADDITIONAL_ITEMS      = \"additionalItems\"\n\tKEY_PROPERTIES            = \"properties\"\n\tKEY_PATTERN_PROPERTIES    = \"patternProperties\"\n\tKEY_ADDITIONAL_PROPERTIES = \"additionalProperties\"\n\tKEY_PROPERTY_NAMES        = \"propertyNames\"\n\tKEY_DEFINITIONS           = \"definitions\"\n\tKEY_MULTIPLE_OF           = \"multipleOf\"\n\tKEY_MINIMUM               = \"minimum\"\n\tKEY_MAXIMUM               = \"maximum\"\n\tKEY_EXCLUSIVE_MINIMUM     = \"exclusiveMinimum\"\n\tKEY_EXCLUSIVE_MAXIMUM     = \"exclusiveMaximum\"\n\tKEY_MIN_LENGTH            = \"minLength\"\n\tKEY_MAX_LENGTH            = \"maxLength\"\n\tKEY_PATTERN               = \"pattern\"\n\tKEY_FORMAT                = \"format\"\n\tKEY_MIN_PROPERTIES        = \"minProperties\"\n\tKEY_MAX_PROPERTIES        = \"maxProperties\"\n\tKEY_DEPENDENCIES          = \"dependencies\"\n\tKEY_REQUIRED              = \"required\"\n\tKEY_MIN_ITEMS             = \"minItems\"\n\tKEY_MAX_ITEMS             = \"maxItems\"\n\tKEY_UNIQUE_ITEMS          = \"uniqueItems\"\n\tKEY_CONTAINS              = \"contains\"\n\tKEY_CONST                 = \"const\"\n\tKEY_ENUM                  = \"enum\"\n\tKEY_ONE_OF                = \"oneOf\"\n\tKEY_ANY_OF                = \"anyOf\"\n\tKEY_ALL_OF                = \"allOf\"\n\tKEY_NOT                   = \"not\"\n\tKEY_IF                    = \"if\"\n\tKEY_THEN                  = \"then\"\n\tKEY_ELSE                  = \"else\"\n)\n\ntype subSchema struct {\n\tdraft *Draft\n\n\t// basic subSchema meta properties\n\tid          *gojsonreference.JsonReference\n\ttitle       *string\n\tdescription *string\n\n\tproperty string\n\n\t// Quick pass/fail for boolean schemas\n\tpass *bool\n\n\t// Types associated with the subSchema\n\ttypes jsonSchemaType\n\n\t// Reference url\n\tref *gojsonreference.JsonReference\n\t// Schema referenced\n\trefSchema *subSchema\n\n\t// hierarchy\n\tparent                      *subSchema\n\titemsChildren               []*subSchema\n\titemsChildrenIsSingleSchema bool\n\tpropertiesChildren          []*subSchema\n\n\t// validation : number / integer\n\tmultipleOf       *big.Rat\n\tmaximum          *big.Rat\n\texclusiveMaximum *big.Rat\n\tminimum          *big.Rat\n\texclusiveMinimum *big.Rat\n\n\t// validation : string\n\tminLength *int\n\tmaxLength *int\n\tpattern   *regexp.Regexp\n\tformat    string\n\n\t// validation : object\n\tminProperties *int\n\tmaxProperties *int\n\trequired      []string\n\n\tdependencies         map[string]interface{}\n\tadditionalProperties interface{}\n\tpatternProperties    map[string]*subSchema\n\tpropertyNames        *subSchema\n\n\t// validation : array\n\tminItems    *int\n\tmaxItems    *int\n\tuniqueItems bool\n\tcontains    *subSchema\n\n\tadditionalItems interface{}\n\n\t// validation : all\n\t_const *string //const is a golang keyword\n\tenum   []string\n\n\t// validation : subSchema\n\toneOf []*subSchema\n\tanyOf []*subSchema\n\tallOf []*subSchema\n\tnot   *subSchema\n\t_if   *subSchema // if/else are golang keywords\n\t_then *subSchema\n\t_else *subSchema\n}\n"
        },
        {
          "name": "testdata",
          "type": "tree",
          "content": null
        },
        {
          "name": "types.go",
          "type": "blob",
          "size": 1.5908203125,
          "content": "// Copyright 2015 xeipuuv ( https://github.com/xeipuuv )\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n// author           xeipuuv\n// author-github    https://github.com/xeipuuv\n// author-mail      xeipuuv@gmail.com\n//\n// repository-name  gojsonschema\n// repository-desc  An implementation of JSON Schema, based on IETF's draft v4 - Go language.\n//\n// description      Contains const types for schema and JSON.\n//\n// created          28-02-2013\n\npackage gojsonschema\n\n// Type constants\nconst (\n\tTYPE_ARRAY   = `array`\n\tTYPE_BOOLEAN = `boolean`\n\tTYPE_INTEGER = `integer`\n\tTYPE_NUMBER  = `number`\n\tTYPE_NULL    = `null`\n\tTYPE_OBJECT  = `object`\n\tTYPE_STRING  = `string`\n)\n\n// JSON_TYPES hosts the list of type that are supported in JSON\nvar JSON_TYPES []string\n\n// SCHEMA_TYPES hosts the list of type that are supported in schemas\nvar SCHEMA_TYPES []string\n\nfunc init() {\n\tJSON_TYPES = []string{\n\t\tTYPE_ARRAY,\n\t\tTYPE_BOOLEAN,\n\t\tTYPE_INTEGER,\n\t\tTYPE_NUMBER,\n\t\tTYPE_NULL,\n\t\tTYPE_OBJECT,\n\t\tTYPE_STRING}\n\n\tSCHEMA_TYPES = []string{\n\t\tTYPE_ARRAY,\n\t\tTYPE_BOOLEAN,\n\t\tTYPE_INTEGER,\n\t\tTYPE_NUMBER,\n\t\tTYPE_OBJECT,\n\t\tTYPE_STRING}\n}\n"
        },
        {
          "name": "utils.go",
          "type": "blob",
          "size": 4.0615234375,
          "content": "// Copyright 2015 xeipuuv ( https://github.com/xeipuuv )\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n// author           xeipuuv\n// author-github    https://github.com/xeipuuv\n// author-mail      xeipuuv@gmail.com\n//\n// repository-name  gojsonschema\n// repository-desc  An implementation of JSON Schema, based on IETF's draft v4 - Go language.\n//\n// description      Various utility functions.\n//\n// created          26-02-2013\n\npackage gojsonschema\n\nimport (\n\t\"encoding/json\"\n\t\"math/big\"\n\t\"reflect\"\n)\n\nfunc isKind(what interface{}, kinds ...reflect.Kind) bool {\n\ttarget := what\n\tif isJSONNumber(what) {\n\t\t// JSON Numbers are strings!\n\t\ttarget = *mustBeNumber(what)\n\t}\n\ttargetKind := reflect.ValueOf(target).Kind()\n\tfor _, kind := range kinds {\n\t\tif targetKind == kind {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\nfunc existsMapKey(m map[string]interface{}, k string) bool {\n\t_, ok := m[k]\n\treturn ok\n}\n\nfunc isStringInSlice(s []string, what string) bool {\n\tfor i := range s {\n\t\tif s[i] == what {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\n// indexStringInSlice returns the index of the first instance of 'what' in s or -1 if it is not found in s.\nfunc indexStringInSlice(s []string, what string) int {\n\tfor i := range s {\n\t\tif s[i] == what {\n\t\t\treturn i\n\t\t}\n\t}\n\treturn -1\n}\n\nfunc marshalToJSONString(value interface{}) (*string, error) {\n\n\tmBytes, err := json.Marshal(value)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tsBytes := string(mBytes)\n\treturn &sBytes, nil\n}\n\nfunc marshalWithoutNumber(value interface{}) (*string, error) {\n\n\t// The JSON is decoded using https://golang.org/pkg/encoding/json/#Decoder.UseNumber\n\t// This means the numbers are internally still represented as strings and therefore 1.00 is unequal to 1\n\t// One way to eliminate these differences is to decode and encode the JSON one more time without Decoder.UseNumber\n\t// so that these differences in representation are removed\n\n\tjsonString, err := marshalToJSONString(value)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tvar document interface{}\n\n\terr = json.Unmarshal([]byte(*jsonString), &document)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn marshalToJSONString(document)\n}\n\nfunc isJSONNumber(what interface{}) bool {\n\n\tswitch what.(type) {\n\n\tcase json.Number:\n\t\treturn true\n\t}\n\n\treturn false\n}\n\nfunc checkJSONInteger(what interface{}) (isInt bool) {\n\n\tjsonNumber := what.(json.Number)\n\n\tbigFloat, isValidNumber := new(big.Rat).SetString(string(jsonNumber))\n\n\treturn isValidNumber && bigFloat.IsInt()\n\n}\n\n// same as ECMA Number.MAX_SAFE_INTEGER and Number.MIN_SAFE_INTEGER\nconst (\n\tmaxJSONFloat = float64(1<<53 - 1)  // 9007199254740991.0 \t 2^53 - 1\n\tminJSONFloat = -float64(1<<53 - 1) //-9007199254740991.0\t-2^53 - 1\n)\n\nfunc mustBeInteger(what interface{}) *int {\n\n\tif isJSONNumber(what) {\n\n\t\tnumber := what.(json.Number)\n\n\t\tisInt := checkJSONInteger(number)\n\n\t\tif isInt {\n\n\t\t\tint64Value, err := number.Int64()\n\t\t\tif err != nil {\n\t\t\t\treturn nil\n\t\t\t}\n\n\t\t\tint32Value := int(int64Value)\n\t\t\treturn &int32Value\n\t\t}\n\n\t}\n\n\treturn nil\n}\n\nfunc mustBeNumber(what interface{}) *big.Rat {\n\n\tif isJSONNumber(what) {\n\t\tnumber := what.(json.Number)\n\t\tfloat64Value, success := new(big.Rat).SetString(string(number))\n\t\tif success {\n\t\t\treturn float64Value\n\t\t}\n\t}\n\n\treturn nil\n\n}\n\nfunc convertDocumentNode(val interface{}) interface{} {\n\n\tif lval, ok := val.([]interface{}); ok {\n\n\t\tres := []interface{}{}\n\t\tfor _, v := range lval {\n\t\t\tres = append(res, convertDocumentNode(v))\n\t\t}\n\n\t\treturn res\n\n\t}\n\n\tif mval, ok := val.(map[interface{}]interface{}); ok {\n\n\t\tres := map[string]interface{}{}\n\n\t\tfor k, v := range mval {\n\t\t\tres[k.(string)] = convertDocumentNode(v)\n\t\t}\n\n\t\treturn res\n\n\t}\n\n\treturn val\n}\n"
        },
        {
          "name": "utils_test.go",
          "type": "blob",
          "size": 1.625,
          "content": "// Copyright 2015 xeipuuv ( https://github.com/xeipuuv )\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n// author           janmentzel\n// author-github    https://github.com/janmentzel\n// author-mail      ? ( forward to xeipuuv@gmail.com )\n//\n// repository-name  gojsonschema\n// repository-desc  An implementation of JSON Schema, based on IETF's draft v4 - Go language.\n//\n// description     (Unit) Tests for utils ( Float / Integer conversion ).\n//\n// created          08-08-2013\n\npackage gojsonschema\n\nimport (\n\t\"encoding/json\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestCheckJsonNumber(t *testing.T) {\n\tvar testCases = []struct {\n\t\tisInt bool\n\t\tvalue json.Number\n\t}{\n\t\t{true, \"0\"},\n\t\t{true, \"2147483647\"},\n\t\t{true, \"-2147483648\"},\n\t\t{true, \"9223372036854775807\"},\n\t\t{true, \"-9223372036854775808\"},\n\t\t{true, \"1.0e+2\"},\n\t\t{true, \"1.0e+10\"},\n\t\t{true, \"-1.0e+2\"},\n\t\t{true, \"-1.0e+10\"},\n\t\t{false, \"1.0e-2\"},\n\t\t{false, \"number\"},\n\t\t{false, \"123number\"},\n\t}\n\n\tfor _, testCase := range testCases {\n\t\tassert.Equal(t, testCase.isInt, checkJSONInteger(testCase.value))\n\t\tassert.Equal(t, testCase.isInt, checkJSONInteger(testCase.value))\n\t}\n\n}\n"
        },
        {
          "name": "validation.go",
          "type": "blob",
          "size": 22.443359375,
          "content": "// Copyright 2015 xeipuuv ( https://github.com/xeipuuv )\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n// author           xeipuuv\n// author-github    https://github.com/xeipuuv\n// author-mail      xeipuuv@gmail.com\n//\n// repository-name  gojsonschema\n// repository-desc  An implementation of JSON Schema, based on IETF's draft v4 - Go language.\n//\n// description      Extends Schema and subSchema, implements the validation phase.\n//\n// created          28-02-2013\n\npackage gojsonschema\n\nimport (\n\t\"encoding/json\"\n\t\"math/big\"\n\t\"reflect\"\n\t\"regexp\"\n\t\"strconv\"\n\t\"strings\"\n\t\"unicode/utf8\"\n)\n\n// Validate loads and validates a JSON schema\nfunc Validate(ls JSONLoader, ld JSONLoader) (*Result, error) {\n\t// load schema\n\tschema, err := NewSchema(ls)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn schema.Validate(ld)\n}\n\n// Validate loads and validates a JSON document\nfunc (v *Schema) Validate(l JSONLoader) (*Result, error) {\n\troot, err := l.LoadJSON()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn v.validateDocument(root), nil\n}\n\nfunc (v *Schema) validateDocument(root interface{}) *Result {\n\tresult := &Result{}\n\tcontext := NewJsonContext(STRING_CONTEXT_ROOT, nil)\n\tv.rootSchema.validateRecursive(v.rootSchema, root, result, context)\n\treturn result\n}\n\nfunc (v *subSchema) subValidateWithContext(document interface{}, context *JsonContext) *Result {\n\tresult := &Result{}\n\tv.validateRecursive(v, document, result, context)\n\treturn result\n}\n\n// Walker function to validate the json recursively against the subSchema\nfunc (v *subSchema) validateRecursive(currentSubSchema *subSchema, currentNode interface{}, result *Result, context *JsonContext) {\n\n\tif internalLogEnabled {\n\t\tinternalLog(\"validateRecursive %s\", context.String())\n\t\tinternalLog(\" %v\", currentNode)\n\t}\n\n\t// Handle true/false schema as early as possible as all other fields will be nil\n\tif currentSubSchema.pass != nil {\n\t\tif !*currentSubSchema.pass {\n\t\t\tresult.addInternalError(\n\t\t\t\tnew(FalseError),\n\t\t\t\tcontext,\n\t\t\t\tcurrentNode,\n\t\t\t\tErrorDetails{},\n\t\t\t)\n\t\t}\n\t\treturn\n\t}\n\n\t// Handle referenced schemas, returns directly when a $ref is found\n\tif currentSubSchema.refSchema != nil {\n\t\tv.validateRecursive(currentSubSchema.refSchema, currentNode, result, context)\n\t\treturn\n\t}\n\n\t// Check for null value\n\tif currentNode == nil {\n\t\tif currentSubSchema.types.IsTyped() && !currentSubSchema.types.Contains(TYPE_NULL) {\n\t\t\tresult.addInternalError(\n\t\t\t\tnew(InvalidTypeError),\n\t\t\t\tcontext,\n\t\t\t\tcurrentNode,\n\t\t\t\tErrorDetails{\n\t\t\t\t\t\"expected\": currentSubSchema.types.String(),\n\t\t\t\t\t\"given\":    TYPE_NULL,\n\t\t\t\t},\n\t\t\t)\n\t\t\treturn\n\t\t}\n\n\t\tcurrentSubSchema.validateSchema(currentSubSchema, currentNode, result, context)\n\t\tv.validateCommon(currentSubSchema, currentNode, result, context)\n\n\t} else { // Not a null value\n\n\t\tif isJSONNumber(currentNode) {\n\n\t\t\tvalue := currentNode.(json.Number)\n\n\t\t\tisInt := checkJSONInteger(value)\n\n\t\t\tvalidType := currentSubSchema.types.Contains(TYPE_NUMBER) || (isInt && currentSubSchema.types.Contains(TYPE_INTEGER))\n\n\t\t\tif currentSubSchema.types.IsTyped() && !validType {\n\n\t\t\t\tgivenType := TYPE_INTEGER\n\t\t\t\tif !isInt {\n\t\t\t\t\tgivenType = TYPE_NUMBER\n\t\t\t\t}\n\n\t\t\t\tresult.addInternalError(\n\t\t\t\t\tnew(InvalidTypeError),\n\t\t\t\t\tcontext,\n\t\t\t\t\tcurrentNode,\n\t\t\t\t\tErrorDetails{\n\t\t\t\t\t\t\"expected\": currentSubSchema.types.String(),\n\t\t\t\t\t\t\"given\":    givenType,\n\t\t\t\t\t},\n\t\t\t\t)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tcurrentSubSchema.validateSchema(currentSubSchema, value, result, context)\n\t\t\tv.validateNumber(currentSubSchema, value, result, context)\n\t\t\tv.validateCommon(currentSubSchema, value, result, context)\n\t\t\tv.validateString(currentSubSchema, value, result, context)\n\n\t\t} else {\n\n\t\t\trValue := reflect.ValueOf(currentNode)\n\t\t\trKind := rValue.Kind()\n\n\t\t\tswitch rKind {\n\n\t\t\t// Slice => JSON array\n\n\t\t\tcase reflect.Slice:\n\n\t\t\t\tif currentSubSchema.types.IsTyped() && !currentSubSchema.types.Contains(TYPE_ARRAY) {\n\t\t\t\t\tresult.addInternalError(\n\t\t\t\t\t\tnew(InvalidTypeError),\n\t\t\t\t\t\tcontext,\n\t\t\t\t\t\tcurrentNode,\n\t\t\t\t\t\tErrorDetails{\n\t\t\t\t\t\t\t\"expected\": currentSubSchema.types.String(),\n\t\t\t\t\t\t\t\"given\":    TYPE_ARRAY,\n\t\t\t\t\t\t},\n\t\t\t\t\t)\n\t\t\t\t\treturn\n\t\t\t\t}\n\n\t\t\t\tcastCurrentNode := currentNode.([]interface{})\n\n\t\t\t\tcurrentSubSchema.validateSchema(currentSubSchema, castCurrentNode, result, context)\n\n\t\t\t\tv.validateArray(currentSubSchema, castCurrentNode, result, context)\n\t\t\t\tv.validateCommon(currentSubSchema, castCurrentNode, result, context)\n\n\t\t\t// Map => JSON object\n\n\t\t\tcase reflect.Map:\n\t\t\t\tif currentSubSchema.types.IsTyped() && !currentSubSchema.types.Contains(TYPE_OBJECT) {\n\t\t\t\t\tresult.addInternalError(\n\t\t\t\t\t\tnew(InvalidTypeError),\n\t\t\t\t\t\tcontext,\n\t\t\t\t\t\tcurrentNode,\n\t\t\t\t\t\tErrorDetails{\n\t\t\t\t\t\t\t\"expected\": currentSubSchema.types.String(),\n\t\t\t\t\t\t\t\"given\":    TYPE_OBJECT,\n\t\t\t\t\t\t},\n\t\t\t\t\t)\n\t\t\t\t\treturn\n\t\t\t\t}\n\n\t\t\t\tcastCurrentNode, ok := currentNode.(map[string]interface{})\n\t\t\t\tif !ok {\n\t\t\t\t\tcastCurrentNode = convertDocumentNode(currentNode).(map[string]interface{})\n\t\t\t\t}\n\n\t\t\t\tcurrentSubSchema.validateSchema(currentSubSchema, castCurrentNode, result, context)\n\n\t\t\t\tv.validateObject(currentSubSchema, castCurrentNode, result, context)\n\t\t\t\tv.validateCommon(currentSubSchema, castCurrentNode, result, context)\n\n\t\t\t\tfor _, pSchema := range currentSubSchema.propertiesChildren {\n\t\t\t\t\tnextNode, ok := castCurrentNode[pSchema.property]\n\t\t\t\t\tif ok {\n\t\t\t\t\t\tsubContext := NewJsonContext(pSchema.property, context)\n\t\t\t\t\t\tv.validateRecursive(pSchema, nextNode, result, subContext)\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t// Simple JSON values : string, number, boolean\n\n\t\t\tcase reflect.Bool:\n\n\t\t\t\tif currentSubSchema.types.IsTyped() && !currentSubSchema.types.Contains(TYPE_BOOLEAN) {\n\t\t\t\t\tresult.addInternalError(\n\t\t\t\t\t\tnew(InvalidTypeError),\n\t\t\t\t\t\tcontext,\n\t\t\t\t\t\tcurrentNode,\n\t\t\t\t\t\tErrorDetails{\n\t\t\t\t\t\t\t\"expected\": currentSubSchema.types.String(),\n\t\t\t\t\t\t\t\"given\":    TYPE_BOOLEAN,\n\t\t\t\t\t\t},\n\t\t\t\t\t)\n\t\t\t\t\treturn\n\t\t\t\t}\n\n\t\t\t\tvalue := currentNode.(bool)\n\n\t\t\t\tcurrentSubSchema.validateSchema(currentSubSchema, value, result, context)\n\t\t\t\tv.validateNumber(currentSubSchema, value, result, context)\n\t\t\t\tv.validateCommon(currentSubSchema, value, result, context)\n\t\t\t\tv.validateString(currentSubSchema, value, result, context)\n\n\t\t\tcase reflect.String:\n\n\t\t\t\tif currentSubSchema.types.IsTyped() && !currentSubSchema.types.Contains(TYPE_STRING) {\n\t\t\t\t\tresult.addInternalError(\n\t\t\t\t\t\tnew(InvalidTypeError),\n\t\t\t\t\t\tcontext,\n\t\t\t\t\t\tcurrentNode,\n\t\t\t\t\t\tErrorDetails{\n\t\t\t\t\t\t\t\"expected\": currentSubSchema.types.String(),\n\t\t\t\t\t\t\t\"given\":    TYPE_STRING,\n\t\t\t\t\t\t},\n\t\t\t\t\t)\n\t\t\t\t\treturn\n\t\t\t\t}\n\n\t\t\t\tvalue := currentNode.(string)\n\n\t\t\t\tcurrentSubSchema.validateSchema(currentSubSchema, value, result, context)\n\t\t\t\tv.validateNumber(currentSubSchema, value, result, context)\n\t\t\t\tv.validateCommon(currentSubSchema, value, result, context)\n\t\t\t\tv.validateString(currentSubSchema, value, result, context)\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tresult.incrementScore()\n}\n\n// Different kinds of validation there, subSchema / common / array / object / string...\nfunc (v *subSchema) validateSchema(currentSubSchema *subSchema, currentNode interface{}, result *Result, context *JsonContext) {\n\n\tif internalLogEnabled {\n\t\tinternalLog(\"validateSchema %s\", context.String())\n\t\tinternalLog(\" %v\", currentNode)\n\t}\n\n\tif len(currentSubSchema.anyOf) > 0 {\n\n\t\tvalidatedAnyOf := false\n\t\tvar bestValidationResult *Result\n\n\t\tfor _, anyOfSchema := range currentSubSchema.anyOf {\n\t\t\tif !validatedAnyOf {\n\t\t\t\tvalidationResult := anyOfSchema.subValidateWithContext(currentNode, context)\n\t\t\t\tvalidatedAnyOf = validationResult.Valid()\n\n\t\t\t\tif !validatedAnyOf && (bestValidationResult == nil || validationResult.score > bestValidationResult.score) {\n\t\t\t\t\tbestValidationResult = validationResult\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif !validatedAnyOf {\n\n\t\t\tresult.addInternalError(new(NumberAnyOfError), context, currentNode, ErrorDetails{})\n\n\t\t\tif bestValidationResult != nil {\n\t\t\t\t// add error messages of closest matching subSchema as\n\t\t\t\t// that's probably the one the user was trying to match\n\t\t\t\tresult.mergeErrors(bestValidationResult)\n\t\t\t}\n\t\t}\n\t}\n\n\tif len(currentSubSchema.oneOf) > 0 {\n\n\t\tnbValidated := 0\n\t\tvar bestValidationResult *Result\n\n\t\tfor _, oneOfSchema := range currentSubSchema.oneOf {\n\t\t\tvalidationResult := oneOfSchema.subValidateWithContext(currentNode, context)\n\t\t\tif validationResult.Valid() {\n\t\t\t\tnbValidated++\n\t\t\t} else if nbValidated == 0 && (bestValidationResult == nil || validationResult.score > bestValidationResult.score) {\n\t\t\t\tbestValidationResult = validationResult\n\t\t\t}\n\t\t}\n\n\t\tif nbValidated != 1 {\n\n\t\t\tresult.addInternalError(new(NumberOneOfError), context, currentNode, ErrorDetails{})\n\n\t\t\tif nbValidated == 0 {\n\t\t\t\t// add error messages of closest matching subSchema as\n\t\t\t\t// that's probably the one the user was trying to match\n\t\t\t\tresult.mergeErrors(bestValidationResult)\n\t\t\t}\n\t\t}\n\n\t}\n\n\tif len(currentSubSchema.allOf) > 0 {\n\t\tnbValidated := 0\n\n\t\tfor _, allOfSchema := range currentSubSchema.allOf {\n\t\t\tvalidationResult := allOfSchema.subValidateWithContext(currentNode, context)\n\t\t\tif validationResult.Valid() {\n\t\t\t\tnbValidated++\n\t\t\t}\n\t\t\tresult.mergeErrors(validationResult)\n\t\t}\n\n\t\tif nbValidated != len(currentSubSchema.allOf) {\n\t\t\tresult.addInternalError(new(NumberAllOfError), context, currentNode, ErrorDetails{})\n\t\t}\n\t}\n\n\tif currentSubSchema.not != nil {\n\t\tvalidationResult := currentSubSchema.not.subValidateWithContext(currentNode, context)\n\t\tif validationResult.Valid() {\n\t\t\tresult.addInternalError(new(NumberNotError), context, currentNode, ErrorDetails{})\n\t\t}\n\t}\n\n\tif currentSubSchema.dependencies != nil && len(currentSubSchema.dependencies) > 0 {\n\t\tif isKind(currentNode, reflect.Map) {\n\t\t\tfor elementKey := range currentNode.(map[string]interface{}) {\n\t\t\t\tif dependency, ok := currentSubSchema.dependencies[elementKey]; ok {\n\t\t\t\t\tswitch dependency := dependency.(type) {\n\n\t\t\t\t\tcase []string:\n\t\t\t\t\t\tfor _, dependOnKey := range dependency {\n\t\t\t\t\t\t\tif _, dependencyResolved := currentNode.(map[string]interface{})[dependOnKey]; !dependencyResolved {\n\t\t\t\t\t\t\t\tresult.addInternalError(\n\t\t\t\t\t\t\t\t\tnew(MissingDependencyError),\n\t\t\t\t\t\t\t\t\tcontext,\n\t\t\t\t\t\t\t\t\tcurrentNode,\n\t\t\t\t\t\t\t\t\tErrorDetails{\"dependency\": dependOnKey},\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\tcase *subSchema:\n\t\t\t\t\t\tdependency.validateRecursive(dependency, currentNode, result, context)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif currentSubSchema._if != nil {\n\t\tvalidationResultIf := currentSubSchema._if.subValidateWithContext(currentNode, context)\n\t\tif currentSubSchema._then != nil && validationResultIf.Valid() {\n\t\t\tvalidationResultThen := currentSubSchema._then.subValidateWithContext(currentNode, context)\n\t\t\tif !validationResultThen.Valid() {\n\t\t\t\tresult.addInternalError(new(ConditionThenError), context, currentNode, ErrorDetails{})\n\t\t\t\tresult.mergeErrors(validationResultThen)\n\t\t\t}\n\t\t}\n\t\tif currentSubSchema._else != nil && !validationResultIf.Valid() {\n\t\t\tvalidationResultElse := currentSubSchema._else.subValidateWithContext(currentNode, context)\n\t\t\tif !validationResultElse.Valid() {\n\t\t\t\tresult.addInternalError(new(ConditionElseError), context, currentNode, ErrorDetails{})\n\t\t\t\tresult.mergeErrors(validationResultElse)\n\t\t\t}\n\t\t}\n\t}\n\n\tresult.incrementScore()\n}\n\nfunc (v *subSchema) validateCommon(currentSubSchema *subSchema, value interface{}, result *Result, context *JsonContext) {\n\n\tif internalLogEnabled {\n\t\tinternalLog(\"validateCommon %s\", context.String())\n\t\tinternalLog(\" %v\", value)\n\t}\n\n\t// const:\n\tif currentSubSchema._const != nil {\n\t\tvString, err := marshalWithoutNumber(value)\n\t\tif err != nil {\n\t\t\tresult.addInternalError(new(InternalError), context, value, ErrorDetails{\"error\": err})\n\t\t}\n\t\tif *vString != *currentSubSchema._const {\n\t\t\tresult.addInternalError(new(ConstError),\n\t\t\t\tcontext,\n\t\t\t\tvalue,\n\t\t\t\tErrorDetails{\n\t\t\t\t\t\"allowed\": *currentSubSchema._const,\n\t\t\t\t},\n\t\t\t)\n\t\t}\n\t}\n\n\t// enum:\n\tif len(currentSubSchema.enum) > 0 {\n\t\tvString, err := marshalWithoutNumber(value)\n\t\tif err != nil {\n\t\t\tresult.addInternalError(new(InternalError), context, value, ErrorDetails{\"error\": err})\n\t\t}\n\t\tif !isStringInSlice(currentSubSchema.enum, *vString) {\n\t\t\tresult.addInternalError(\n\t\t\t\tnew(EnumError),\n\t\t\t\tcontext,\n\t\t\t\tvalue,\n\t\t\t\tErrorDetails{\n\t\t\t\t\t\"allowed\": strings.Join(currentSubSchema.enum, \", \"),\n\t\t\t\t},\n\t\t\t)\n\t\t}\n\t}\n\n\t// format:\n\tif currentSubSchema.format != \"\" {\n\t\tif !FormatCheckers.IsFormat(currentSubSchema.format, value) {\n\t\t\tresult.addInternalError(\n\t\t\t\tnew(DoesNotMatchFormatError),\n\t\t\t\tcontext,\n\t\t\t\tvalue,\n\t\t\t\tErrorDetails{\"format\": currentSubSchema.format},\n\t\t\t)\n\t\t}\n\t}\n\n\tresult.incrementScore()\n}\n\nfunc (v *subSchema) validateArray(currentSubSchema *subSchema, value []interface{}, result *Result, context *JsonContext) {\n\n\tif internalLogEnabled {\n\t\tinternalLog(\"validateArray %s\", context.String())\n\t\tinternalLog(\" %v\", value)\n\t}\n\n\tnbValues := len(value)\n\n\t// TODO explain\n\tif currentSubSchema.itemsChildrenIsSingleSchema {\n\t\tfor i := range value {\n\t\t\tsubContext := NewJsonContext(strconv.Itoa(i), context)\n\t\t\tvalidationResult := currentSubSchema.itemsChildren[0].subValidateWithContext(value[i], subContext)\n\t\t\tresult.mergeErrors(validationResult)\n\t\t}\n\t} else {\n\t\tif currentSubSchema.itemsChildren != nil && len(currentSubSchema.itemsChildren) > 0 {\n\n\t\t\tnbItems := len(currentSubSchema.itemsChildren)\n\n\t\t\t// while we have both schemas and values, check them against each other\n\t\t\tfor i := 0; i != nbItems && i != nbValues; i++ {\n\t\t\t\tsubContext := NewJsonContext(strconv.Itoa(i), context)\n\t\t\t\tvalidationResult := currentSubSchema.itemsChildren[i].subValidateWithContext(value[i], subContext)\n\t\t\t\tresult.mergeErrors(validationResult)\n\t\t\t}\n\n\t\t\tif nbItems < nbValues {\n\t\t\t\t// we have less schemas than elements in the instance array,\n\t\t\t\t// but that might be ok if \"additionalItems\" is specified.\n\n\t\t\t\tswitch currentSubSchema.additionalItems.(type) {\n\t\t\t\tcase bool:\n\t\t\t\t\tif !currentSubSchema.additionalItems.(bool) {\n\t\t\t\t\t\tresult.addInternalError(new(ArrayNoAdditionalItemsError), context, value, ErrorDetails{})\n\t\t\t\t\t}\n\t\t\t\tcase *subSchema:\n\t\t\t\t\tadditionalItemSchema := currentSubSchema.additionalItems.(*subSchema)\n\t\t\t\t\tfor i := nbItems; i != nbValues; i++ {\n\t\t\t\t\t\tsubContext := NewJsonContext(strconv.Itoa(i), context)\n\t\t\t\t\t\tvalidationResult := additionalItemSchema.subValidateWithContext(value[i], subContext)\n\t\t\t\t\t\tresult.mergeErrors(validationResult)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// minItems & maxItems\n\tif currentSubSchema.minItems != nil {\n\t\tif nbValues < int(*currentSubSchema.minItems) {\n\t\t\tresult.addInternalError(\n\t\t\t\tnew(ArrayMinItemsError),\n\t\t\t\tcontext,\n\t\t\t\tvalue,\n\t\t\t\tErrorDetails{\"min\": *currentSubSchema.minItems},\n\t\t\t)\n\t\t}\n\t}\n\tif currentSubSchema.maxItems != nil {\n\t\tif nbValues > int(*currentSubSchema.maxItems) {\n\t\t\tresult.addInternalError(\n\t\t\t\tnew(ArrayMaxItemsError),\n\t\t\t\tcontext,\n\t\t\t\tvalue,\n\t\t\t\tErrorDetails{\"max\": *currentSubSchema.maxItems},\n\t\t\t)\n\t\t}\n\t}\n\n\t// uniqueItems:\n\tif currentSubSchema.uniqueItems {\n\t\tvar stringifiedItems = make(map[string]int)\n\t\tfor j, v := range value {\n\t\t\tvString, err := marshalWithoutNumber(v)\n\t\t\tif err != nil {\n\t\t\t\tresult.addInternalError(new(InternalError), context, value, ErrorDetails{\"err\": err})\n\t\t\t}\n\t\t\tif i, ok := stringifiedItems[*vString]; ok {\n\t\t\t\tresult.addInternalError(\n\t\t\t\t\tnew(ItemsMustBeUniqueError),\n\t\t\t\t\tcontext,\n\t\t\t\t\tvalue,\n\t\t\t\t\tErrorDetails{\"type\": TYPE_ARRAY, \"i\": i, \"j\": j},\n\t\t\t\t)\n\t\t\t}\n\t\t\tstringifiedItems[*vString] = j\n\t\t}\n\t}\n\n\t// contains:\n\n\tif currentSubSchema.contains != nil {\n\t\tvalidatedOne := false\n\t\tvar bestValidationResult *Result\n\n\t\tfor i, v := range value {\n\t\t\tsubContext := NewJsonContext(strconv.Itoa(i), context)\n\n\t\t\tvalidationResult := currentSubSchema.contains.subValidateWithContext(v, subContext)\n\t\t\tif validationResult.Valid() {\n\t\t\t\tvalidatedOne = true\n\t\t\t\tbreak\n\t\t\t} else {\n\t\t\t\tif bestValidationResult == nil || validationResult.score > bestValidationResult.score {\n\t\t\t\t\tbestValidationResult = validationResult\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif !validatedOne {\n\t\t\tresult.addInternalError(\n\t\t\t\tnew(ArrayContainsError),\n\t\t\t\tcontext,\n\t\t\t\tvalue,\n\t\t\t\tErrorDetails{},\n\t\t\t)\n\t\t\tif bestValidationResult != nil {\n\t\t\t\tresult.mergeErrors(bestValidationResult)\n\t\t\t}\n\t\t}\n\t}\n\n\tresult.incrementScore()\n}\n\nfunc (v *subSchema) validateObject(currentSubSchema *subSchema, value map[string]interface{}, result *Result, context *JsonContext) {\n\n\tif internalLogEnabled {\n\t\tinternalLog(\"validateObject %s\", context.String())\n\t\tinternalLog(\" %v\", value)\n\t}\n\n\t// minProperties & maxProperties:\n\tif currentSubSchema.minProperties != nil {\n\t\tif len(value) < int(*currentSubSchema.minProperties) {\n\t\t\tresult.addInternalError(\n\t\t\t\tnew(ArrayMinPropertiesError),\n\t\t\t\tcontext,\n\t\t\t\tvalue,\n\t\t\t\tErrorDetails{\"min\": *currentSubSchema.minProperties},\n\t\t\t)\n\t\t}\n\t}\n\tif currentSubSchema.maxProperties != nil {\n\t\tif len(value) > int(*currentSubSchema.maxProperties) {\n\t\t\tresult.addInternalError(\n\t\t\t\tnew(ArrayMaxPropertiesError),\n\t\t\t\tcontext,\n\t\t\t\tvalue,\n\t\t\t\tErrorDetails{\"max\": *currentSubSchema.maxProperties},\n\t\t\t)\n\t\t}\n\t}\n\n\t// required:\n\tfor _, requiredProperty := range currentSubSchema.required {\n\t\t_, ok := value[requiredProperty]\n\t\tif ok {\n\t\t\tresult.incrementScore()\n\t\t} else {\n\t\t\tresult.addInternalError(\n\t\t\t\tnew(RequiredError),\n\t\t\t\tcontext,\n\t\t\t\tvalue,\n\t\t\t\tErrorDetails{\"property\": requiredProperty},\n\t\t\t)\n\t\t}\n\t}\n\n\t// additionalProperty & patternProperty:\n\tfor pk := range value {\n\n\t\t// Check whether this property is described by \"properties\"\n\t\tfound := false\n\t\tfor _, spValue := range currentSubSchema.propertiesChildren {\n\t\t\tif pk == spValue.property {\n\t\t\t\tfound = true\n\t\t\t}\n\t\t}\n\n\t\t//  Check whether this property is described by \"patternProperties\"\n\t\tppMatch := v.validatePatternProperty(currentSubSchema, pk, value[pk], result, context)\n\n\t\t// If it is not described by neither \"properties\" nor \"patternProperties\" it must pass \"additionalProperties\"\n\t\tif !found && !ppMatch {\n\t\t\tswitch ap := currentSubSchema.additionalProperties.(type) {\n\t\t\tcase bool:\n\t\t\t\t// Handle the boolean case separately as it's cleaner to return a specific error than failing to pass the false schema\n\t\t\t\tif !ap {\n\t\t\t\t\tresult.addInternalError(\n\t\t\t\t\t\tnew(AdditionalPropertyNotAllowedError),\n\t\t\t\t\t\tcontext,\n\t\t\t\t\t\tvalue[pk],\n\t\t\t\t\t\tErrorDetails{\"property\": pk},\n\t\t\t\t\t)\n\n\t\t\t\t}\n\t\t\tcase *subSchema:\n\t\t\t\tvalidationResult := ap.subValidateWithContext(value[pk], NewJsonContext(pk, context))\n\t\t\t\tresult.mergeErrors(validationResult)\n\t\t\t}\n\t\t}\n\t}\n\n\t// propertyNames:\n\tif currentSubSchema.propertyNames != nil {\n\t\tfor pk := range value {\n\t\t\tvalidationResult := currentSubSchema.propertyNames.subValidateWithContext(pk, context)\n\t\t\tif !validationResult.Valid() {\n\t\t\t\tresult.addInternalError(new(InvalidPropertyNameError),\n\t\t\t\t\tcontext,\n\t\t\t\t\tvalue, ErrorDetails{\n\t\t\t\t\t\t\"property\": pk,\n\t\t\t\t\t})\n\t\t\t\tresult.mergeErrors(validationResult)\n\t\t\t}\n\t\t}\n\t}\n\n\tresult.incrementScore()\n}\n\nfunc (v *subSchema) validatePatternProperty(currentSubSchema *subSchema, key string, value interface{}, result *Result, context *JsonContext) bool {\n\n\tif internalLogEnabled {\n\t\tinternalLog(\"validatePatternProperty %s\", context.String())\n\t\tinternalLog(\" %s %v\", key, value)\n\t}\n\n\tvalidated := false\n\n\tfor pk, pv := range currentSubSchema.patternProperties {\n\t\tif matches, _ := regexp.MatchString(pk, key); matches {\n\t\t\tvalidated = true\n\t\t\tsubContext := NewJsonContext(key, context)\n\t\t\tvalidationResult := pv.subValidateWithContext(value, subContext)\n\t\t\tresult.mergeErrors(validationResult)\n\t\t}\n\t}\n\n\tif !validated {\n\t\treturn false\n\t}\n\n\tresult.incrementScore()\n\treturn true\n}\n\nfunc (v *subSchema) validateString(currentSubSchema *subSchema, value interface{}, result *Result, context *JsonContext) {\n\n\t// Ignore JSON numbers\n\tif isJSONNumber(value) {\n\t\treturn\n\t}\n\n\t// Ignore non strings\n\tif !isKind(value, reflect.String) {\n\t\treturn\n\t}\n\n\tif internalLogEnabled {\n\t\tinternalLog(\"validateString %s\", context.String())\n\t\tinternalLog(\" %v\", value)\n\t}\n\n\tstringValue := value.(string)\n\n\t// minLength & maxLength:\n\tif currentSubSchema.minLength != nil {\n\t\tif utf8.RuneCount([]byte(stringValue)) < int(*currentSubSchema.minLength) {\n\t\t\tresult.addInternalError(\n\t\t\t\tnew(StringLengthGTEError),\n\t\t\t\tcontext,\n\t\t\t\tvalue,\n\t\t\t\tErrorDetails{\"min\": *currentSubSchema.minLength},\n\t\t\t)\n\t\t}\n\t}\n\tif currentSubSchema.maxLength != nil {\n\t\tif utf8.RuneCount([]byte(stringValue)) > int(*currentSubSchema.maxLength) {\n\t\t\tresult.addInternalError(\n\t\t\t\tnew(StringLengthLTEError),\n\t\t\t\tcontext,\n\t\t\t\tvalue,\n\t\t\t\tErrorDetails{\"max\": *currentSubSchema.maxLength},\n\t\t\t)\n\t\t}\n\t}\n\n\t// pattern:\n\tif currentSubSchema.pattern != nil {\n\t\tif !currentSubSchema.pattern.MatchString(stringValue) {\n\t\t\tresult.addInternalError(\n\t\t\t\tnew(DoesNotMatchPatternError),\n\t\t\t\tcontext,\n\t\t\t\tvalue,\n\t\t\t\tErrorDetails{\"pattern\": currentSubSchema.pattern},\n\t\t\t)\n\n\t\t}\n\t}\n\n\tresult.incrementScore()\n}\n\nfunc (v *subSchema) validateNumber(currentSubSchema *subSchema, value interface{}, result *Result, context *JsonContext) {\n\n\t// Ignore non numbers\n\tif !isJSONNumber(value) {\n\t\treturn\n\t}\n\n\tif internalLogEnabled {\n\t\tinternalLog(\"validateNumber %s\", context.String())\n\t\tinternalLog(\" %v\", value)\n\t}\n\n\tnumber := value.(json.Number)\n\tfloat64Value, _ := new(big.Rat).SetString(string(number))\n\n\t// multipleOf:\n\tif currentSubSchema.multipleOf != nil {\n\t\tif q := new(big.Rat).Quo(float64Value, currentSubSchema.multipleOf); !q.IsInt() {\n\t\t\tresult.addInternalError(\n\t\t\t\tnew(MultipleOfError),\n\t\t\t\tcontext,\n\t\t\t\tnumber,\n\t\t\t\tErrorDetails{\n\t\t\t\t\t\"multiple\": new(big.Float).SetRat(currentSubSchema.multipleOf),\n\t\t\t\t},\n\t\t\t)\n\t\t}\n\t}\n\n\t//maximum & exclusiveMaximum:\n\tif currentSubSchema.maximum != nil {\n\t\tif float64Value.Cmp(currentSubSchema.maximum) == 1 {\n\t\t\tresult.addInternalError(\n\t\t\t\tnew(NumberLTEError),\n\t\t\t\tcontext,\n\t\t\t\tnumber,\n\t\t\t\tErrorDetails{\n\t\t\t\t\t\"max\": new(big.Float).SetRat(currentSubSchema.maximum),\n\t\t\t\t},\n\t\t\t)\n\t\t}\n\t}\n\tif currentSubSchema.exclusiveMaximum != nil {\n\t\tif float64Value.Cmp(currentSubSchema.exclusiveMaximum) >= 0 {\n\t\t\tresult.addInternalError(\n\t\t\t\tnew(NumberLTError),\n\t\t\t\tcontext,\n\t\t\t\tnumber,\n\t\t\t\tErrorDetails{\n\t\t\t\t\t\"max\": new(big.Float).SetRat(currentSubSchema.exclusiveMaximum),\n\t\t\t\t},\n\t\t\t)\n\t\t}\n\t}\n\n\t//minimum & exclusiveMinimum:\n\tif currentSubSchema.minimum != nil {\n\t\tif float64Value.Cmp(currentSubSchema.minimum) == -1 {\n\t\t\tresult.addInternalError(\n\t\t\t\tnew(NumberGTEError),\n\t\t\t\tcontext,\n\t\t\t\tnumber,\n\t\t\t\tErrorDetails{\n\t\t\t\t\t\"min\": new(big.Float).SetRat(currentSubSchema.minimum),\n\t\t\t\t},\n\t\t\t)\n\t\t}\n\t}\n\tif currentSubSchema.exclusiveMinimum != nil {\n\t\tif float64Value.Cmp(currentSubSchema.exclusiveMinimum) <= 0 {\n\t\t\tresult.addInternalError(\n\t\t\t\tnew(NumberGTError),\n\t\t\t\tcontext,\n\t\t\t\tnumber,\n\t\t\t\tErrorDetails{\n\t\t\t\t\t\"min\": new(big.Float).SetRat(currentSubSchema.exclusiveMinimum),\n\t\t\t\t},\n\t\t\t)\n\t\t}\n\t}\n\n\tresult.incrementScore()\n}\n"
        }
      ]
    }
  ]
}