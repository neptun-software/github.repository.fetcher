{
  "metadata": {
    "timestamp": 1736567380659,
    "page": 986,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjk5MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "itsabot/itsabot",
      "stars": 2153,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.05078125,
          "content": "*.sw*\n.DS_Store\nclient_secret.json\nabot.env\npublic/\n"
        },
        {
          "name": ".travis.yml",
          "type": "blob",
          "size": 1.8447265625,
          "content": "language: go\nsudo: required\ngo:\n        - 1.6\nbefore_script:\n        # Install Postgres 9.5\n        - sudo /etc/init.d/postgresql stop\n        - sudo apt-get -y remove --purge postgresql-9.1\n        - sudo apt-get -y remove --purge postgresql-9.2\n        - sudo apt-get -y remove --purge postgresql-9.3\n        - sudo apt-get -y remove --purge postgresql-9.4\n        - sudo apt-get -y autoremove\n        - sudo apt-key adv --keyserver keys.gnupg.net --recv-keys 7FCC7D46ACCC4CF8\n        - sudo sh -c 'echo \"deb http://apt.postgresql.org/pub/repos/apt/ precise-pgdg main 9.5\" >> /etc/apt/sources.list.d/postgresql.list'\n        - sudo apt-get update\n        - sudo apt-get -y install postgresql-9.5\n        - sudo sh -c 'echo \"local all postgres trust\" > /etc/postgresql/9.5/main/pg_hba.conf'\n        - sudo sh -c 'echo -n \"host all all 127.0.0.1/32 trust\" >> /etc/postgresql/9.5/main/pg_hba.conf'\n        - sudo /etc/init.d/postgresql restart\n        - go vet ./...\n        - psql -c 'CREATE DATABASE abot_test;' -U postgres\n        - ls base/db/migrations/up/*.sql | xargs -I{} -- psql -U postgres abot_test -f {}\n        - cat base/data/cities.csv | psql -U postgres -d abot_test -c \"COPY cities(name, countrycode) FROM stdin DELIMITER ',' CSV;\"\ninstall:\n        - go get github.com/robfig/glock\n        - go install github.com/robfig/glock\n        - glock sync github.com/itsabot/abot\n        - go install ./...\n        - abot new abot\nscript:\n        - export PORT=4200\n        - export ITSABOT_URL=https://www.itsabot.org\n        - export ABOT_DATABASE_URL=\"postgres://postgres@127.0.0.1:5432/abot_test?sslmode=disable\"\n        - export ABOT_PATH=$GOPATH/src/github.com/itsabot/abot\n        - export ABOT_URL=http://localhost:$PORT\n        - go test\n        - cd core\n        - go test ./...\n        - cd ../shared\n        - go test ./...\n        - cd ../abot\n        - go test ./...\n"
        },
        {
          "name": ".vscode",
          "type": "tree",
          "content": null
        },
        {
          "name": "GLOCKFILE",
          "type": "blob",
          "size": 0.5810546875,
          "content": "github.com/codegangsta/cli 11c134509d89c2018675f369955218a180dc7428\ngithub.com/dchest/stemmer f1ab276e6cf5fad3f8db813f22e25b1939c8ef70\ngithub.com/itsabot/itsabot.org 9dcf65e3c7a6128a997b46f702b0113de7f952a5\ngithub.com/jbrukh/bayesian a65fd1effddb7bd71c6bb6ca1876e045a7aeac6e\ngithub.com/jmoiron/sqlx bdae0c3219c3bdb92f3d7c70825018712787c933\ngithub.com/julienschmidt/httprouter 77366a47451a56bb3ba682481eed85b64fea14e8\ngithub.com/lib/pq ee1442bda7bd1b6a84e913bdb421cb1874ec629d\ngolang.org/x/crypto f3241ce8505855877cc8a9717bd61a0f7c4ea83c\ngolang.org/x/net d7bf3545bb0dacf009c535b3d3fbf53ac0a339ab\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.05078125,
          "content": "The MIT License (MIT)\n\nCopyright (c) 2016 Evan Tann\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 4.333984375,
          "content": "![Abot](http://i.imgur.com/WBACSyP.png)\n\n[Getting Started](https://github.com/itsabot/abot/wiki/Getting-Started) |\n[Contributing](https://github.com/itsabot/abot/wiki/How-to-Contribute) |\n[Mailing List](https://groups.google.com/forum/#!forum/abot-discussion)\n\n[![GoDoc](http://img.shields.io/badge/go-documentation-blue.svg?style=flat-square)](https://godoc.org/github.com/itsabot/abot) [![Travis CI](https://img.shields.io/travis/itsabot/abot.svg?style=flat-square)](https://travis-ci.org/itsabot/abot)\n\n**Note: This project is no longer supported, as I no longer have the time to maintain it.**\n\nAbot (pronounced *Eh-Bot*, like the Canadians) is a digital assistant framework\nthat enables anyone to easily build a digital assistant similar to Apple's Siri,\nMicrosoft's Cortana, Google Now, or Amazon Alexa. Further, Abot supports a\nhuman-aided training backend enabling anyone to build services like Facebook M.\n\nUnlike those proprietary systems, Abot is open-sourced and extensible. By\nproviding an extensible platform onto which anyone can easily add functionality,\nAbot is the first A.I. framework that aims to be available everywhere and—\nultimately—to do everything.\n\n## Installation\n\n> **Dependencies**: Abot requires that the following programs are installed:\n>\n> * [Go](https://golang.org/dl/) >= 1.6\n> * [PostgreSQL](http://www.postgresql.org/download/) >= 9.5\n\nFetch Abot via `go get`\n\n```\n$ go get github.com/itsabot/abot\n```\n\nThen create a new project anywhere in your `$GOPATH`, passing in your Postgres\ncredentials/host if needed. Projects should be named with camelCasing.\n\n```\n$ abot new yourproject [username[:password]@host[:port]]\nSuccess! Created yourproject\n```\n\nIf you don't pass anything to the command, the Postgres parameters will default\nto `host = 127.0.0.1`, `port = 5432`, and `username = postgres`.  You may need\nto edit your\n[pg_hba.conf](http://www.postgresql.org/docs/9.5/static/auth-pg-hba-conf.html)\nfile if you want to use this password-less default.\n\nDuring setup, if the `psql` binary is unavailable, the script will skip the\ndatabase setup. To setup the database on an different machine, you can run\n`cmd/dbsetup.sh` on the host that has Postgres / `psql` available. This script\ntakes the same Postgres parameter as `abot new`.\n\nOnce the script completes, launch the server:\n\n```\n$ cd yourproject\n$ abot server\n```\n\nThen visit Abot at `localhost:4200`.\n\n## Usage\n\nFirst configure the plugins you want to import, such as `weather`. Add them\nto your plugins.json like so:\n\n```json\n{\n\t\"Version\": 0.2,\n\t\"Dependencies\": {\n\t\t\"github.com/itsabot/plugin_weather\": \"*\"\n\t}\n}\n```\n\nThen run the following in your terminal to download the plugins:\n\n```bash\n$ abot install\nFetching 1 plugin...\nInstalling plugin...\nSuccess!\n```\n\nThat will download the plugins into your `$GOPATH` and install them into your\nproject.  Once you've installed the plugins, boot the server again: `abot\nserver`. You can then use the included Abot console to communicate with Abot\nlocally:\n\n```bash\n$ abot console\n> Hi\nHello there!\n```\n\nYou can learn more in our\n[Getting Started](https://github.com/itsabot/abot/wiki/Getting-Started) guide.\n\n## Goals\n\nWe believe that A.I. will impact every business worldwide and dramatically\nchange our lives. While Apple, Google and others rush to build proprietary\ndigital assistants, there's a great need for an open approach that can be made\nto run anywhere and be customized to do anything you need.\n\nAbot enables any person or business to build digital assistants like Siri using\nplugins that are as easy to install and run as WordPress. Soon it'll be as easy\nto leverage A.I. in your business as it is to start a blog or an online store.\nImagine setting up an AI assistant to answer your phones, schedule meetings,\nand book travel for your company in 30 seconds or less. The future's almost\nhere, and Abot's going to lead the way.\n\nWe have a long road ahead of us, but \"nothing ever comes to one that is worth\nhaving except as a result of hard work.\" *-- Booker T. Washington*\n\nFollow our progress on our\n[Roadmap](https://github.com/itsabot/abot/wiki/Roadmap) or learn how you can\nget involved with our\n[Contributor's Guide](https://github.com/itsabot/abot/wiki#contributing).\n\n## License\n\nMIT, a copy of which you can find in the repo.\n\nThis project uses a Bayesian classifier library (github.com/jbrukh/bayesian),\nwhose BSD-style license you can find in `/core/training/LICENSE.md`.\n"
        },
        {
          "name": "abot.go",
          "type": "blob",
          "size": 26.6328125,
          "content": "package main\n\nimport (\n\t\"bufio\"\n\t\"bytes\"\n\t\"database/sql\"\n\t\"encoding/json\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"io/ioutil\"\n\tlg \"log\"\n\t\"math/rand\"\n\t\"net/http\"\n\t\"net/url\"\n\t\"os\"\n\t\"os/exec\"\n\t\"os/signal\"\n\t\"path/filepath\"\n\t\"strconv\"\n\t\"strings\"\n\t\"sync\"\n\t\"text/tabwriter\"\n\t\"time\"\n\t\"unicode\"\n\n\t\"golang.org/x/crypto/ssh/terminal\"\n\t\"golang.org/x/net/websocket\"\n\n\t\"github.com/codegangsta/cli\"\n\t\"github.com/itsabot/abot/core\"\n\t\"github.com/itsabot/abot/core/log\"\n\t\"github.com/itsabot/abot/shared/datatypes\"\n\t\"github.com/itsabot/abot/shared/plugin\"\n\t\"github.com/itsabot/itsabot.org/socket\"\n\t_ \"github.com/lib/pq\" // Postgres driver\n)\n\nfunc main() {\n\trand.Seed(time.Now().UnixNano())\n\tlog.SetDebug(os.Getenv(\"ABOT_DEBUG\") == \"true\")\n\tif err := core.LoadEnvVars(); err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tapp := cli.NewApp()\n\tapp.Commands = []cli.Command{\n\t\t{\n\t\t\tName:  \"new\",\n\t\t\tUsage: \"generate a new abot\",\n\t\t\tAction: func(c *cli.Context) error {\n\t\t\t\tl := log.New(\"\")\n\t\t\t\tl.SetFlags(0)\n\t\t\t\tif len(c.Args()) != 1 {\n\t\t\t\t\tl.Fatal(\"usage: abot new {name}\")\n\t\t\t\t}\n\t\t\t\tif strings.Contains(c.Args().First(), \" \") {\n\t\t\t\t\tl.Fatal(\"name cannot include a space. use camelCase\")\n\t\t\t\t}\n\t\t\t\terr := newAbot(l, c.Args().First(), c.Args().Get(1))\n\t\t\t\tif err != nil {\n\t\t\t\t\tl.Fatalf(\"could not build new abot. %s\", err)\n\t\t\t\t}\n\t\t\t\tl.Info(\"Success. Created \" + c.Args().First())\n\t\t\t\treturn nil\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tName:    \"server\",\n\t\t\tAliases: []string{\"s\"},\n\t\t\tUsage:   \"run server\",\n\t\t\tAction: func(c *cli.Context) error {\n\t\t\t\tl := log.New(\"\")\n\t\t\t\tl.SetFlags(0)\n\t\t\t\tcmd := exec.Command(\"/bin/sh\", \"-c\", \"go build\")\n\t\t\t\tout, err := cmd.CombinedOutput()\n\t\t\t\tif err != nil {\n\t\t\t\t\tl.Info(string(out))\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t\tdir, err := os.Getwd()\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t\t_, file := filepath.Split(dir)\n\t\t\t\tcmd = exec.Command(\"/bin/sh\", \"-c\", \"./\"+file)\n\t\t\t\tcmd.Stdout = os.Stdout\n\t\t\t\tcmd.Stderr = os.Stderr\n\t\t\t\tif err = cmd.Start(); err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t\treturn cmd.Wait()\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tName:    \"install\",\n\t\t\tAliases: []string{\"i\"},\n\t\t\tUsage:   \"download and install plugins listed in plugins.json\",\n\t\t\tAction: func(c *cli.Context) error {\n\t\t\t\terrChan := make(chan errMsg)\n\t\t\t\tl := log.New(\"\")\n\t\t\t\tl.SetFlags(0)\n\t\t\t\tl.SetDebug(os.Getenv(\"ABOT_DEBUG\") == \"true\")\n\t\t\t\tgo func() {\n\t\t\t\t\tselect {\n\t\t\t\t\tcase errC := <-errChan:\n\t\t\t\t\t\tif errC.err == nil {\n\t\t\t\t\t\t\t// Success\n\t\t\t\t\t\t\tl.Info(errC.msg)\n\t\t\t\t\t\t\tos.Exit(0)\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Plugins install failed, so remove incomplete plugins.go file\n\t\t\t\t\t\terrR := os.Remove(\"plugins.go\")\n\t\t\t\t\t\tif errR != nil && !os.IsNotExist(errR) {\n\t\t\t\t\t\t\tl.Info(\"could not remove plugins.go file.\", errR)\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif len(errC.msg) > 0 {\n\t\t\t\t\t\t\tl.Fatalf(\"could not install plugins.\\n%s\\n%s\", errC.msg, errC.err)\n\t\t\t\t\t\t}\n\t\t\t\t\t\tl.Fatalf(\"could not install plugins.\\n%s\", errC.err)\n\t\t\t\t\t}\n\t\t\t\t}()\n\t\t\t\tinstallPlugins(l, errChan)\n\t\t\t\tfor {\n\t\t\t\t\t// Keep process running until a message is received\n\t\t\t\t}\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tName:  \"search\",\n\t\t\tUsage: \"search plugins indexed on itsabot.org\",\n\t\t\tAction: func(c *cli.Context) error {\n\t\t\t\tl := log.New(\"\")\n\t\t\t\tl.SetFlags(0)\n\t\t\t\targs := c.Args()\n\t\t\t\tif len(args) == 0 || len(args) > 2 {\n\t\t\t\t\tl.Fatal(errors.New(`usage: abot plugin search {term}`))\n\t\t\t\t}\n\t\t\t\tif err := searchPlugins(args.First()); err != nil {\n\t\t\t\t\tl.Fatalf(\"could not start console\\n%s\", err)\n\t\t\t\t}\n\t\t\t\treturn nil\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tName:    \"update\",\n\t\t\tAliases: []string{\"u\", \"upgrade\"},\n\t\t\tUsage:   \"update and install plugins listed in plugins.json\",\n\t\t\tAction: func(c *cli.Context) error {\n\t\t\t\tupdatePlugins()\n\t\t\t\treturn nil\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tName:    \"publish\",\n\t\t\tAliases: []string{\"p\"},\n\t\t\tUsage:   \"publish a plugin to itsabot.org\",\n\t\t\tAction: func(c *cli.Context) error {\n\t\t\t\tpublishPlugin(c)\n\t\t\t\treturn nil\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tName:    \"test\",\n\t\t\tAliases: []string{\"t\"},\n\t\t\tUsage:   \"tests plugins\",\n\t\t\tAction: func(c *cli.Context) error {\n\t\t\t\tlg.SetFlags(0)\n\t\t\t\tcount, err := testPlugin()\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t\tif count == 0 {\n\t\t\t\t\tlg.Println(\"No tests found. Did you run \\\"abot install\\\"?\")\n\t\t\t\t\treturn nil\n\t\t\t\t}\n\t\t\t\tlg.Printf(\"Success (%d tests).\\n\", count)\n\t\t\t\treturn nil\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tName:    \"generate\",\n\t\t\tAliases: []string{\"g\"},\n\t\t\tUsage:   \"generate plugin scaffolding\",\n\t\t\tAction: func(c *cli.Context) error {\n\t\t\t\tl := log.New(\"\")\n\t\t\t\tl.SetFlags(0)\n\t\t\t\targs := c.Args()\n\t\t\t\tif len(args) != 1 {\n\t\t\t\t\tl.Fatal(errors.New(`usage: abot generate {name}`))\n\t\t\t\t}\n\t\t\t\tgeneratePlugin(l, args.First())\n\t\t\t\tl.Info(\"Created\", args.First(), \"in\",\n\t\t\t\t\tfilepath.Join(os.Getenv(\"PWD\"), args.First()))\n\t\t\t\treturn nil\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tName:    \"login\",\n\t\t\tAliases: []string{\"l\"},\n\t\t\tUsage:   \"log into itsabot.org to enable publishing plugins\",\n\t\t\tAction: func(c *cli.Context) error {\n\t\t\t\tlogin()\n\t\t\t\treturn nil\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tName:    \"console\",\n\t\t\tAliases: []string{\"c\"},\n\t\t\tUsage:   \"communicate with a running abot server\",\n\t\t\tAction: func(c *cli.Context) error {\n\t\t\t\tif err := startConsole(c); err != nil {\n\t\t\t\t\tl := log.New(\"\")\n\t\t\t\t\tl.SetFlags(0)\n\t\t\t\t\tl.Fatalf(\"could not start console\\n%s\", err)\n\t\t\t\t}\n\t\t\t\treturn nil\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tName:    \"dbconsole\",\n\t\t\tAliases: []string{\"dbc\"},\n\t\t\tUsage:   \"communicate with a running abot server\",\n\t\t\tAction: func(c *cli.Context) error {\n\t\t\t\tcmd := exec.Command(\"/bin/sh\", \"-c\", \"psql \"+os.Getenv(\"ABOT_DATABASE_URL\"))\n\t\t\t\tcmd.Stdout = os.Stdout\n\t\t\t\tcmd.Stdin = os.Stdin\n\t\t\t\tif err := cmd.Start(); err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t\treturn cmd.Wait()\n\t\t\t},\n\t\t},\n\t}\n\tapp.Action = func(c *cli.Context) error {\n\t\tcli.ShowAppHelp(c)\n\t\treturn nil\n\t}\n\tif err := app.Run(os.Args); err != nil {\n\t\tlog.Fatal(err)\n\t}\n}\n\nfunc searchPlugins(query string) error {\n\tbyt, err := searchItsAbot(query)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif err = outputPluginResults(os.Stdout, byt); err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}\n\nfunc outputPluginResults(w io.Writer, byt []byte) error {\n\tvar results []struct {\n\t\tID            uint64\n\t\tName          string\n\t\tDescription   sql.NullString\n\t\tPath          string\n\t\tDownloadCount uint64\n\t\tSimilarity    float64\n\t}\n\tif err := json.Unmarshal(byt, &results); err != nil {\n\t\treturn err\n\t}\n\twriter := tabwriter.Writer{}\n\twriter.Init(w, 0, 8, 1, '\\t', 0)\n\t_, err := writer.Write([]byte(\"NAME\\tDESCRIPTION\\tDOWNLOADS\\n\"))\n\tif err != nil {\n\t\treturn err\n\t}\n\tfor _, result := range results {\n\t\td := result.Description\n\t\tif len(d.String) >= 30 {\n\t\t\td.String = d.String[:27] + \"...\"\n\t\t}\n\t\t_, err = writer.Write([]byte(fmt.Sprintf(\"%s\\t%s\\t%d\\n\",\n\t\t\tresult.Name, d.String, result.DownloadCount)))\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn writer.Flush()\n}\n\nfunc searchItsAbot(q string) ([]byte, error) {\n\tu := fmt.Sprintf(\"%s/api/plugins/search/%s\", os.Getenv(\"ITSABOT_URL\"),\n\t\turl.QueryEscape(q))\n\tclient := http.Client{Timeout: 10 * time.Second}\n\tres, err := client.Get(u)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer func() {\n\t\tif err := res.Body.Close(); err != nil {\n\t\t\treturn\n\t\t}\n\t}()\n\treturn ioutil.ReadAll(res.Body)\n}\n\nfunc startConsole(c *cli.Context) error {\n\targs := c.Args()\n\tif len(args) >= 3 {\n\t\treturn errors.New(\"usage: abot console {abotAddress} {userPhone}\")\n\t}\n\tvar addr, phone string\n\tswitch len(args) {\n\tcase 0:\n\t\taddr = \"http://localhost:\" + os.Getenv(\"PORT\")\n\t\tphone = \"+15555551234\"\n\tcase 1:\n\t\taddr = \"http://localhost:\" + os.Getenv(\"PORT\")\n\t\tphone = args[0]\n\tcase 2:\n\t\taddr = args[0]\n\t\tphone = args[1]\n\t}\n\n\t// Capture ^C interrupt to add a newline\n\tsig := make(chan os.Signal, 1)\n\tsignal.Notify(sig, os.Interrupt)\n\tgo func() {\n\t\tfor range sig {\n\t\t\tfmt.Printf(\"\\n\")\n\t\t\tos.Exit(0)\n\t\t}\n\t}()\n\n\tbody := struct {\n\t\tCMD        string\n\t\tFlexID     string\n\t\tFlexIDType dt.FlexIDType\n\t}{\n\t\tFlexID:     phone,\n\t\tFlexIDType: 2,\n\t}\n\tscanner := bufio.NewScanner(os.Stdin)\n\n\t// Test connection\n\treq, err := http.NewRequest(\"GET\", addr, nil)\n\tclient := &http.Client{}\n\tresp, err := client.Do(req)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif err = resp.Body.Close(); err != nil {\n\t\treturn err\n\t}\n\tfmt.Print(\"> \")\n\n\t// Handle each user input\n\tfor scanner.Scan() {\n\t\tbody.CMD = scanner.Text()\n\t\tbyt, err := json.Marshal(body)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treq, err := http.NewRequest(\"POST\", addr, bytes.NewBuffer(byt))\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tclient := &http.Client{}\n\t\tresp, err := client.Do(req)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tbody, err := ioutil.ReadAll(resp.Body)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif err = resp.Body.Close(); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tfmt.Println(string(body))\n\t\tfmt.Print(\"> \")\n\t}\n\tif err := scanner.Err(); err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}\n\nfunc installPlugins(l *log.Logger, errChan chan errMsg) {\n\tif err := core.LoadConf(); err != nil {\n\t\terrChan <- errMsg{msg: \"\", err: err}\n\t\treturn\n\t}\n\tplugins := buildPluginFile(l)\n\n\t// Fetch all plugins\n\tif len(plugins.Dependencies) == 1 {\n\t\tl.Infof(\"Fetching 1 plugin...\\n\")\n\t} else {\n\t\tl.Infof(\"Fetching %d plugins...\\n\", len(plugins.Dependencies))\n\t}\n\toutC, err := exec.\n\t\tCommand(\"/bin/sh\", \"-c\", \"go get ./...\").\n\t\tCombinedOutput()\n\tif err == nil {\n\t\tsyncDependencies(plugins, l, errChan)\n\t\treturn\n\t}\n\n\t// Show errors only when it's not a private repo issue\n\tif !strings.Contains(string(outC), \"fatal: could not read Username for\") {\n\t\terrChan <- errMsg{msg: string(outC), err: err}\n\t\treturn\n\t}\n\n\t// TODO enable versioning for private repos\n\tl.Infof(\"Fetching private repos...\\n\\n\")\n\tl.Info(\"*** This will delete your local plugins to fetch remote copies.\")\n\t_, err = fmt.Print(\"Continue? [n]: \")\n\tif err != nil {\n\t\terrChan <- errMsg{msg: \"\", err: err}\n\t\treturn\n\t}\n\treader := bufio.NewReader(os.Stdin)\n\ttext, err := reader.ReadString('\\n')\n\tif err != nil {\n\t\terrChan <- errMsg{msg: \"\", err: errors.New(\"failed to read from stdin\")}\n\t\treturn\n\t}\n\tif text[0] != 'y' && text[0] != 'Y' {\n\t\terrChan <- errMsg{msg: \"Canceled\", err: nil}\n\t\treturn\n\t}\n\twg := &sync.WaitGroup{}\n\tfor name, _ := range plugins.Dependencies {\n\t\tgo clonePrivateRepo(name, errChan, wg)\n\t}\n\twg.Wait()\n\tsyncDependencies(plugins, l, errChan)\n}\n\nfunc clonePrivateRepo(name string, errChan chan errMsg, wg *sync.WaitGroup) {\n\twg.Add(1)\n\tdefer wg.Done()\n\n\tparts := strings.Split(name, \"/\")\n\tif len(parts) < 2 {\n\t\terrChan <- errMsg{msg: \"\", err: errors.New(\"invalid dependency path: too few parts\")}\n\t\treturn\n\t}\n\n\t// Ensure we don't delete a lower level directory\n\tp := filepath.Join(os.Getenv(\"GOPATH\"), \"src\")\n\ttmp := filepath.Join(p, name)\n\tif len(tmp)+4 <= len(p) {\n\t\terrChan <- errMsg{msg: \"\", err: errors.New(\"invalid dependency path: too short\")}\n\t\treturn\n\t}\n\tif strings.Contains(tmp, \"..\") {\n\t\terrChan <- errMsg{msg: name, err: errors.New(\"invalid dependency path: contains '..'\")}\n\t\treturn\n\t}\n\tcmd := fmt.Sprintf(\"rm -rf %s\", tmp)\n\tlog.Debug(\"running:\", cmd)\n\toutC, err := exec.\n\t\tCommand(\"/bin/sh\", \"-c\", cmd).\n\t\tCombinedOutput()\n\tif err != nil {\n\t\ttmp = fmt.Sprintf(\"failed to fetch %s\\n%s\", name, string(outC))\n\t\terrChan <- errMsg{msg: tmp, err: err}\n\t\treturn\n\t}\n\tname = strings.Join(parts[1:], \"/\")\n\tcmd = fmt.Sprintf(\"git clone git@github.com:%s.git %s\", name, tmp)\n\tlog.Debug(\"running:\", cmd)\n\toutC, err = exec.\n\t\tCommand(\"/bin/sh\", \"-c\", cmd).\n\t\tCombinedOutput()\n\tif err != nil {\n\t\ttmp = fmt.Sprintf(\"failed to fetch %s\\n%s\", name, string(outC))\n\t\terrChan <- errMsg{msg: tmp, err: err}\n\t}\n}\n\nfunc syncDependencies(plugins *core.PluginJSON, l *log.Logger,\n\terrChan chan errMsg) {\n\n\t// Sync each of them to get dependencies\n\twg := &sync.WaitGroup{}\n\trand.Seed(time.Now().UTC().UnixNano())\n\tfor url, version := range plugins.Dependencies {\n\t\twg.Add(1)\n\t\tgo func(url, version string) {\n\t\t\tdefer wg.Done()\n\t\t\t// Check out specific commit\n\t\t\tvar outB []byte\n\t\t\tvar errB error\n\t\t\tif version != \"*\" {\n\t\t\t\tl.Debug(\"checking out\", url, \"at\", version)\n\t\t\t\tp := filepath.Join(os.Getenv(\"GOPATH\"), \"src\",\n\t\t\t\t\turl)\n\t\t\t\tc := fmt.Sprintf(\"git -C %s checkout %s\", p, version)\n\t\t\t\toutB, errB = exec.\n\t\t\t\t\tCommand(\"/bin/sh\", \"-c\", c).\n\t\t\t\t\tCombinedOutput()\n\t\t\t\tif errB != nil {\n\t\t\t\t\tl.Debug(string(outB))\n\t\t\t\t\terrChan <- errMsg{msg: \"\", err: errB}\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Anonymously increment the plugin's download count\n\t\t\t// at itsabot.org\n\t\t\tl.Debug(\"incrementing download count\", url)\n\t\t\tp := struct{ Path string }{Path: url}\n\t\t\toutB, errB = json.Marshal(p)\n\t\t\tif errB != nil {\n\t\t\t\terrChan <- errMsg{msg: \"failed to build itsabot.org JSON.\", err: errB}\n\t\t\t\treturn\n\t\t\t}\n\t\t\tvar u string\n\t\t\tu = os.Getenv(\"ITSABOT_URL\") + \"/api/plugins.json\"\n\t\t\treq, errB := http.NewRequest(\"PUT\", u, bytes.NewBuffer(outB))\n\t\t\tif errB != nil {\n\t\t\t\terrChan <- errMsg{msg: \"failed to build request to itsabot.org.\", err: errB}\n\t\t\t\treturn\n\t\t\t}\n\t\t\tclient := &http.Client{Timeout: 10 * time.Second}\n\t\t\tresp, errB := client.Do(req)\n\t\t\tif errB != nil {\n\t\t\t\terrChan <- errMsg{msg: \"failed to update itsabot.org.\", err: errB}\n\t\t\t\treturn\n\t\t\t}\n\t\t\tdefer func() {\n\t\t\t\tif errB = resp.Body.Close(); errB != nil {\n\t\t\t\t\terrChan <- errMsg{msg: \"\", err: errB}\n\t\t\t\t}\n\t\t\t}()\n\t\t\tif resp.StatusCode != 200 {\n\t\t\t\tl.Infof(\"WARN: %d - %s\\n\", resp.StatusCode,\n\t\t\t\t\tresp.Status)\n\t\t\t}\n\t\t}(url, version)\n\t}\n\twg.Wait()\n\n\t// Ensure dependencies are still there with the latest checked out\n\t// versions, and install the plugins\n\tl.Info(\"Installing plugins...\")\n\toutC, err := exec.\n\t\tCommand(\"/bin/sh\", \"-c\", \"go get ./...\").\n\t\tCombinedOutput()\n\tif err != nil {\n\t\terrChan <- errMsg{msg: string(outC), err: err}\n\t\treturn\n\t}\n\tembedPluginConfs(plugins, l)\n\tupdateGlockfileAndInstall(l)\n\terrChan <- errMsg{msg: \"Success!\"}\n}\n\nfunc updatePlugins() {\n\tl := log.New(\"\")\n\tl.SetFlags(0)\n\tl.SetDebug(os.Getenv(\"ABOT_DEBUG\") == \"true\")\n\n\tif err := core.LoadConf(); err != nil {\n\t\tl.Fatal(err)\n\t}\n\tplugins := buildPluginFile(l)\n\n\tl.Info(\"Updating plugins...\")\n\tfor path, version := range plugins.Dependencies {\n\t\tif version != \"*\" {\n\t\t\tcontinue\n\t\t}\n\t\tl.Infof(\"Updating %s...\\n\", path)\n\t\toutC, err := exec.\n\t\t\tCommand(\"/bin/sh\", \"-c\", \"go get -u \"+path).\n\t\t\tCombinedOutput()\n\t\tif err != nil {\n\t\t\tl.Info(string(outC))\n\t\t\tl.Fatal(err)\n\t\t}\n\t}\n\tembedPluginConfs(plugins, l)\n\tupdateGlockfileAndInstall(l)\n\tl.Info(\"Success!\")\n}\n\nfunc updateGlockfileAndInstall(l *log.Logger) {\n\toutC, err := exec.\n\t\tCommand(\"/bin/sh\", \"-c\", `pwd | sed \"s|$GOPATH/src/||\"`).\n\t\tCombinedOutput()\n\tif err != nil {\n\t\tl.Info(string(outC))\n\t\tl.Fatal(err)\n\t}\n\n\t// Update plugin dependency versions in GLOCKFILE\n\tp := string(outC)\n\toutC, err = exec.\n\t\tCommand(\"/bin/sh\", \"-c\", \"glock save \"+p).\n\t\tCombinedOutput()\n\tif err != nil {\n\t\tl.Info(string(outC))\n\t\tl.Fatal(err)\n\t}\n\n\toutC, err = exec.\n\t\tCommand(\"/bin/sh\", \"-c\", \"go install\").\n\t\tCombinedOutput()\n\tif err != nil {\n\t\tl.Info(string(outC))\n\t\tl.Fatal(err)\n\t}\n}\n\nfunc embedPluginConfs(plugins *core.PluginJSON, l *log.Logger) {\n\tlog.Debug(\"embedding plugin confs\")\n\n\t// Open plugins.go file for writing\n\tfi, err := os.OpenFile(\"plugins.go\", os.O_WRONLY|os.O_APPEND, 0666)\n\tif err != nil {\n\t\tl.Fatal(err)\n\t}\n\tdefer func() {\n\t\tif err = fi.Close(); err != nil {\n\t\t\tl.Fatal(err)\n\t\t}\n\t}()\n\n\tp := os.Getenv(\"GOPATH\")\n\ttokenizedPath := strings.Split(p, string(os.PathListSeparator))\n\n\t// Insert plugin.json text as comments\n\ts := \"\\n\\n/*\\n\"\n\tfor u := range plugins.Dependencies {\n\t\ts += u + \"\\n\"\n\t\tlog.Debug(\"reading file\", p)\n\t\tp = filepath.Join(tokenizedPath[0], \"src\", u, \"plugin.json\")\n\t\tfi2, err2 := os.Open(p)\n\t\tif err2 != nil {\n\t\t\tl.Fatal(err2)\n\t\t}\n\t\tscn := bufio.NewScanner(fi2)\n\t\tvar tmp string\n\t\tfor scn.Scan() {\n\t\t\tline := scn.Text() + \"\\n\"\n\t\t\ts += line\n\t\t\ttmp += line\n\t\t}\n\t\tif err2 = scn.Err(); err2 != nil {\n\t\t\tl.Fatal(err2)\n\t\t}\n\t\tif err2 = fi2.Close(); err2 != nil {\n\t\t\tl.Fatal(err2)\n\t\t}\n\n\t\tvar plg struct{ Name string }\n\t\tif err2 = json.Unmarshal([]byte(tmp), &plg); err2 != nil {\n\t\t\tl.Fatal(err2)\n\t\t}\n\n\t\t// Fetch remote plugin IDs to be included in the plugin confs\n\t\tplg.Name = url.QueryEscape(plg.Name)\n\t\tul := os.Getenv(\"ITSABOT_URL\") + \"/api/plugins/by_name/\" + plg.Name\n\t\treq, err2 := http.NewRequest(\"GET\", ul, nil)\n\t\tif err2 != nil {\n\t\t\tl.Fatal(err2)\n\t\t}\n\t\tclient := &http.Client{Timeout: 10 * time.Second}\n\t\tresp, err2 := client.Do(req)\n\t\tif err2 != nil {\n\t\t\tl.Fatal(err2)\n\t\t}\n\t\tvar data struct{ ID uint64 }\n\t\tif err2 := json.NewDecoder(resp.Body).Decode(&data); err2 != nil {\n\t\t\tl.Fatal(err2)\n\t\t}\n\t\tid := strconv.FormatUint(data.ID, 10)\n\n\t\t// Remove closing characters to insert additional ID data\n\t\ts = s[:len(s)-3]\n\t\ts += \",\\n\\t\\\"ID\\\": \" + id + \"\\n}\\n\"\n\t}\n\ts += \"*/\"\n\t_, err = fi.WriteString(s)\n\tif err != nil {\n\t\tl.Fatal(err)\n\t}\n}\n\nfunc buildPluginFile(l *log.Logger) *core.PluginJSON {\n\t// Create plugins.go file, truncate if exists\n\tfi, err := os.Create(\"plugins.go\")\n\tif err != nil {\n\t\tl.Fatal(err)\n\t}\n\tdefer func() {\n\t\tif err = fi.Close(); err != nil {\n\t\t\tl.Fatal(err)\n\t\t}\n\t}()\n\n\ts := \"// This file is generated by `abot plugin install`. Do not edit.\\n\"\n\ts += \"package main\\n\\nimport (\\n\"\n\tfor url := range core.Conf().Dependencies {\n\t\t// Insert _ imports\n\t\ts += fmt.Sprintf(\"\\t_ \\\"%s\\\"\\n\", url)\n\t}\n\ts += \")\"\n\t_, err = fi.WriteString(s)\n\tif err != nil {\n\t\tl.Fatal(err)\n\t}\n\n\treturn core.Conf()\n}\n\nfunc login() {\n\treader := bufio.NewReader(os.Stdin)\n\tfmt.Print(\"Email: \")\n\temail, err := reader.ReadString('\\n')\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tfmt.Print(\"Password: \")\n\tpass, err := terminal.ReadPassword(0)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\temail = email[:len(email)-1]\n\treq := struct {\n\t\tEmail    string\n\t\tPassword string\n\t}{\n\t\tEmail:    email,\n\t\tPassword: string(pass),\n\t}\n\tfmt.Println()\n\tbyt, err := json.Marshal(req)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tu := os.Getenv(\"ITSABOT_URL\") + \"/api/users/login.json\"\n\tresp, err := http.Post(u, \"application/json\", bytes.NewBuffer(byt))\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tdefer func() {\n\t\tif err = resp.Body.Close(); err != nil {\n\t\t\tlog.Fatal(err)\n\t\t}\n\t}()\n\tvar data struct {\n\t\tID        uint64\n\t\tEmail     string\n\t\tScopes    []string\n\t\tAuthToken string\n\t\tIssuedAt  uint64\n\t}\n\tif err = json.NewDecoder(resp.Body).Decode(&data); err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tif resp.StatusCode == 401 {\n\t\tlog.Fatal(errors.New(\"invalid email/password combination\"))\n\t}\n\n\t// Create abot.conf file, truncate if exists\n\tfi, err := os.Create(filepath.Join(os.Getenv(\"HOME\"), \".abot.conf\"))\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tdefer func() {\n\t\tif err = fi.Close(); err != nil {\n\t\t\tlog.Fatal(err)\n\t\t}\n\t}()\n\n\t// Insert auth data\n\ts := fmt.Sprintf(\"%d\\n%s\\n%s\\n%d\", data.ID, data.Email, data.AuthToken,\n\t\tdata.IssuedAt)\n\t_, err = fi.WriteString(s)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tlog.Info(\"Success!\")\n}\n\nfunc publishPlugin(c *cli.Context) error {\n\tp := filepath.Join(os.Getenv(\"HOME\"), \".abot.conf\")\n\tfi, err := os.Open(p)\n\tif err != nil {\n\t\tif err.Error() == fmt.Sprintf(\"open %s: no such file or directory\", p) {\n\t\t\tlogin()\n\t\t\tpublishPlugin(c)\n\t\t\treturn nil\n\t\t}\n\t\tlog.Fatal(err)\n\t}\n\tdefer func() {\n\t\tif err = fi.Close(); err != nil {\n\t\t\tlog.Fatal(err)\n\t\t}\n\t}()\n\n\t// Prepare request\n\tif len(c.Args().First()) == 0 {\n\t\tlog.Fatal(\"missing plugin's `go get` path\")\n\t}\n\treqData := struct {\n\t\tPath   string\n\t\tSecret string\n\t}{\n\t\tPath:   c.Args().First(),\n\t\tSecret: core.RandSeq(24),\n\t}\n\tbyt, err := json.Marshal(reqData)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tu := os.Getenv(\"ITSABOT_URL\") + \"/api/plugins.json\"\n\treq, err := http.NewRequest(\"POST\", u, bytes.NewBuffer(byt))\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\t// Populate req with login credentials from ~/.abot.conf\n\tscn := bufio.NewScanner(fi)\n\tvar lineNum int\n\tfor scn.Scan() {\n\t\tline := scn.Text()\n\t\tcookie := &http.Cookie{}\n\t\tswitch lineNum {\n\t\tcase 0:\n\t\t\tcookie.Name = \"iaID\"\n\t\tcase 1:\n\t\t\tcookie.Name = \"iaEmail\"\n\t\tcase 2:\n\t\t\treq.Header.Set(\"Authorization\", \"Bearer \"+line)\n\t\tcase 3:\n\t\t\tcookie.Name = \"iaIssuedAt\"\n\t\tdefault:\n\t\t\tlog.Fatal(\"unknown line in abot.conf\")\n\t\t}\n\t\tif lineNum != 2 {\n\t\t\tcookie.Value = url.QueryEscape(line)\n\t\t\treq.AddCookie(cookie)\n\t\t}\n\t\tlineNum++\n\t}\n\tif err = scn.Err(); err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tcookie := &http.Cookie{}\n\tcookie.Name = \"iaScopes\"\n\treq.AddCookie(cookie)\n\n\tclient := &http.Client{}\n\tresp, err := client.Do(req)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tdefer func() {\n\t\tif err = resp.Body.Close(); err != nil {\n\t\t\tlog.Fatal(err)\n\t\t}\n\t}()\n\tif resp.StatusCode == 401 {\n\t\tlogin()\n\t\tpublishPlugin(c)\n\t} else if resp.StatusCode != 202 {\n\t\tlog.Info(\"something went wrong. status code\", resp.StatusCode)\n\t\tvar msg string\n\t\tif err = json.NewDecoder(resp.Body).Decode(&msg); err != nil {\n\t\t\tlog.Fatal(err)\n\t\t}\n\t\tlog.Fatal(msg)\n\t}\n\n\t// Make a websocket request to get updates about the publishing process\n\turi, err := url.Parse(os.Getenv(\"ITSABOT_URL\"))\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tws, err := websocket.Dial(\"ws://\"+uri.Host+\"/api/ws\", \"\",\n\t\tos.Getenv(\"ABOT_URL\"))\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tif err = websocket.Message.Send(ws, reqData.Secret); err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tvar msg socket.Msg\n\tl := log.New(\"\")\n\tl.SetFlags(0)\n\tl.Info(\"> Establishing connection with server...\")\n\tvar established bool\n\tvar lastMsg string\n\tfor {\n\t\twebsocket.JSON.Receive(ws, &msg)\n\t\tif !established {\n\t\t\tl.Info(\"OK\")\n\t\t\testablished = true\n\t\t}\n\t\tif msg.Content == lastMsg {\n\t\t\tlog.Info(\"server hung up. please try again\")\n\t\t\tif err = ws.Close(); err != nil {\n\t\t\t\tlog.Info(\"failed to close socket.\", err)\n\t\t\t}\n\t\t\treturn nil\n\t\t}\n\t\tlastMsg = msg.Content\n\t\tif msg.Type == socket.MsgTypeFinishedSuccess ||\n\t\t\tmsg.Type == socket.MsgTypeFinishedFailed {\n\t\t\tif err = ws.Close(); err != nil {\n\t\t\t\tlog.Info(\"failed to close socket.\", err)\n\t\t\t}\n\t\t\treturn nil\n\t\t}\n\t\tif len(msg.Content) < 2 {\n\t\t\tl.Info(msg.Content)\n\t\t\tcontinue\n\t\t}\n\t\ttmp := msg.Content[0:2]\n\t\tif tmp == \"> \" || tmp == \"==\" {\n\t\t\tl.Info(\"\")\n\t\t}\n\t\tl.Info(msg.Content)\n\t}\n}\n\nfunc generatePlugin(l *log.Logger, name string) error {\n\t// Log in to get the maintainer email\n\tif os.Getenv(\"ABOT_ENV\") != \"test\" {\n\t\tp := filepath.Join(os.Getenv(\"HOME\"), \".abot.conf\")\n\t\tif _, err := os.Stat(p); os.IsNotExist(err) {\n\t\t\tlogin()\n\t\t}\n\t}\n\n\t// Ensure the name and path are unique globally\n\tvar words []string\n\tvar lastIdx int\n\tname = strings.Replace(name, \" \", \"_\", -1)\n\tdirName := name\n\tfor i, letter := range name {\n\t\tif i == 0 {\n\t\t\tcontinue\n\t\t}\n\t\tif unicode.IsUpper(letter) {\n\t\t\twords = append(words, name[lastIdx:i])\n\t\t\tlastIdx = i\n\t\t}\n\t}\n\twords = append(words, name[lastIdx:])\n\tdirName = strings.Join(words, \"_\")\n\tdirName = strings.ToLower(dirName)\n\tname = strings.ToLower(name)\n\n\t// Create the directory\n\tif err := os.Mkdir(dirName, 0744); err != nil {\n\t\treturn err\n\t}\n\n\t// Generate a plugin.json file\n\tif err := buildPluginJSON(dirName, name); err != nil {\n\t\tlog.Info(\"failed to create plugin.json\")\n\t\treturn err\n\t}\n\n\t// Generate name.go and name_test.go files with starter keywords and\n\t// state machines\n\tif err := buildPluginScaffoldFile(dirName, name); err != nil {\n\t\tlog.Info(\"failed to create plugin scaffold file\")\n\t\treturn err\n\t}\n\treturn nil\n}\n\nfunc buildPluginJSON(dirName, name string) error {\n\tvar maintainer string\n\tif os.Getenv(\"ABOT_ENV\") == \"test\" {\n\t\tmaintainer = \"test@example.com\"\n\t} else {\n\t\tfi, err := os.Open(filepath.Join(os.Getenv(\"HOME\"), \".abot.conf\"))\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tdefer func() {\n\t\t\tif err = fi.Close(); err != nil {\n\t\t\t\tlog.Info(\"failed to close plugin.json file.\", err)\n\t\t\t}\n\t\t}()\n\t\tscn := bufio.NewScanner(fi)\n\t\tvar lineNum int\n\t\tfor scn.Scan() {\n\t\t\tif lineNum < 1 {\n\t\t\t\tlineNum++\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tmaintainer = scn.Text()\n\t\t\tbreak\n\t\t}\n\t\tif scn.Err() != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\tb := []byte(`{\n\t\"Name\": \"` + name + `\",\n\t\"Maintainer\": \"` + maintainer + `\",\n\t\"Usage\": [\"Show me a demo\"],\n\t\"Tests\": [\n\t\t{\"Show me a demo\": [\"demo\"]}\n\t]\n}`)\n\treturn ioutil.WriteFile(filepath.Join(dirName, \"plugin.json\"), b, 0744)\n}\n\nfunc buildPluginScaffoldFile(dirName, name string) error {\n\tfi, err := os.Create(filepath.Join(dirName, dirName+\".go\"))\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer func() {\n\t\terr = fi.Close()\n\t\tif err != nil {\n\t\t\tlog.Info(\"failed to close plugin.json.\", err)\n\t\t}\n\t}()\n\tdir, err := os.Getwd()\n\tif err != nil {\n\t\treturn err\n\t}\n\tdir = filepath.Join(dir, name)\n\t_, err = fi.WriteString(pluginScaffoldFile(dir, name))\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}\n\n// newAbot creates a new directory for a new Abot project. It's similar to\n// `rails new`.\nfunc newAbot(l *log.Logger, name, dbconnstr string) error {\n\t// Create a new directory for the project\n\tif err := os.Mkdir(name, 0777); err != nil {\n\t\treturn err\n\t}\n\tif err := os.Chdir(name); err != nil {\n\t\treturn err\n\t}\n\n\t// Generate abot.env\n\tfi, err := os.Create(\"abot.env\")\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer func() {\n\t\tif err = fi.Close(); err != nil {\n\t\t\tl.Info(\"failed to close abot.env.\", err)\n\t\t}\n\t}()\n\tdir, err := os.Getwd()\n\tif err != nil {\n\t\treturn err\n\t}\n\t_, err = fi.WriteString(serverAbotEnv(name, dir))\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Copy and modify base files\n\tp := filepath.Join(os.Getenv(\"ABOT_PATH\"), \"base\", \"plugins.json\")\n\tif err = core.CopyFileContents(p, \"plugins.json\"); err != nil {\n\t\treturn err\n\t}\n\tp = filepath.Join(os.Getenv(\"ABOT_PATH\"), \"base\", \"server.go.x\")\n\tif err = core.CopyFileContents(p, \"server.go\"); err != nil {\n\t\treturn err\n\t}\n\tp = filepath.Join(os.Getenv(\"ABOT_PATH\"), \"base\", \".gitignore\")\n\tif err = core.CopyFileContents(p, \".gitignore\"); err != nil {\n\t\treturn err\n\t}\n\tfi2, err := os.OpenFile(\".gitignore\", os.O_APPEND|os.O_WRONLY, 0666)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer func() {\n\t\tif err = fi2.Close(); err != nil {\n\t\t\tl.Info(\"failed to close .gitignore.\", err)\n\t\t}\n\t}()\n\t_, err = fi2.WriteString(name)\n\tif err != nil {\n\t\tl.Fatal(\"failed to write to .gitignore.\", err)\n\t}\n\n\t// Walk the base/assets dir, copying all files\n\tp = filepath.Join(os.Getenv(\"ABOT_PATH\"), \"base\", \"assets\")\n\tif err = filepath.Walk(p, recursiveCopy); err != nil {\n\t\treturn err\n\t}\n\tp = filepath.Join(os.Getenv(\"ABOT_PATH\"), \"base\", \"cmd\")\n\tif err = filepath.Walk(p, recursiveCopy); err != nil {\n\t\treturn err\n\t}\n\tp = filepath.Join(os.Getenv(\"ABOT_PATH\"), \"base\", \"data\")\n\tif err = filepath.Walk(p, recursiveCopy); err != nil {\n\t\treturn err\n\t}\n\tp = filepath.Join(os.Getenv(\"ABOT_PATH\"), \"base\", \"db\")\n\tif err = filepath.Walk(p, recursiveCopy); err != nil {\n\t\treturn err\n\t}\n\n\t// Run cmd/dbsetup.sh\n\tcmd := exec.Command(\"/bin/sh\", \"-c\", \"cmd/dbsetup.sh \"+dbconnstr)\n\tcmd.Stdout = os.Stdout\n\tcmd.Stderr = os.Stderr\n\tif err = cmd.Run(); err != nil {\n\t\tl.Info(\"Fix the errors above, then re-run cmd/dbsetup.sh\")\n\t\treturn err\n\t}\n\n\t// TODO analytics on a new Abot project\n\treturn nil\n}\n\nfunc recursiveCopy(pth string, info os.FileInfo, err error) error {\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tparts := strings.Split(pth, string(os.PathSeparator))\n\tpth = \"\"\n\tfor i := len(parts) - 1; i > 0; i-- {\n\t\tif parts[i] == \"base\" {\n\t\t\tbreak\n\t\t}\n\t\tpth = filepath.Join(parts[i], pth)\n\t}\n\n\t// Handle directories\n\tif info.IsDir() {\n\t\tif err = os.Mkdir(pth, 0777); err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t}\n\n\t// Handle files\n\tp := filepath.Join(os.Getenv(\"ABOT_PATH\"), \"base\", pth)\n\tcore.CopyFileContents(p, pth)\n\treturn nil\n}\n\nfunc testPlugin() (int, error) {\n\tif err := core.LoadPluginsGo(); err != nil {\n\t\treturn 0, err\n\t}\n\tr := plugin.TestPrepare()\n\tplugin.TestCleanup()\n\tvar count int\n\tfor _, plg := range core.PluginsGo {\n\t\tlog.Info(\"loading\", plg.Name)\n\t\tfor _, test := range plg.Tests {\n\t\t\tlog.Info(\"running\", test)\n\t\t\tcount++\n\t\t\tfor in, exps := range test {\n\t\t\t\terr := plugin.TestReq(r, in, exps)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn count, err\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tplugin.TestCleanup()\n\treturn count, nil\n}\n\ntype errMsg struct {\n\tmsg string\n\terr error\n}\n"
        },
        {
          "name": "abot_test.go",
          "type": "blob",
          "size": 1.345703125,
          "content": "package main\n\nimport (\n\t\"bytes\"\n\t\"os\"\n\t\"strings\"\n\t\"testing\"\n\n\t\"github.com/itsabot/abot/core\"\n\t\"github.com/itsabot/abot/core/log\"\n)\n\nfunc TestMain(m *testing.M) {\n\tif err := core.LoadEnvVars(); err != nil {\n\t\tlog.Info(\"failed to load env vars\", err)\n\t}\n\tif err := os.Setenv(\"ABOT_ENV\", \"test\"); err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tos.Exit(m.Run())\n}\n\nfunc TestPluginSearch(t *testing.T) {\n\tquery := \"weather\"\n\tvar byt []byte\n\tvar err error\n\tif testing.Short() {\n\t\tlog.Info(\"stubbing plugin search results in short mode.\")\n\t\tbyt = []byte(`[{\"Name\":\"Weather\",\"Valid\":true}]`)\n\t} else {\n\t\tbyt, err = searchItsAbot(query)\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t}\n\tvar b []byte\n\tbuf := bytes.NewBuffer(b)\n\tif err = outputPluginResults(buf, byt); err != nil {\n\t\tt.Fatal(err)\n\t}\n\ttmp := buf.String()\n\tif !strings.Contains(tmp, \"NAME\") {\n\t\tt.Fatal(err)\n\t}\n\tif !strings.Contains(tmp, \"Weather\") {\n\t\tt.Fatal(err)\n\t}\n}\n\nfunc TestPluginGenerate(t *testing.T) {\n\tdefer func() {\n\t\tif err := os.RemoveAll(\"__test\"); err != nil {\n\t\t\tlog.Info(\"failed to clean up __test dir.\", err)\n\t\t}\n\t\tif err := os.RemoveAll(\"test_here\"); err != nil {\n\t\t\tlog.Info(\"failed to clean up __test dir.\", err)\n\t\t}\n\t}()\n\n\t// generate plugin\n\tl := log.New(\"\")\n\tl.SetFlags(0)\n\tif err := generatePlugin(l, \"__test\"); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif err := generatePlugin(l, \"TestHere\"); err != nil {\n\t\tt.Fatal(err)\n\t}\n}\n"
        },
        {
          "name": "base",
          "type": "tree",
          "content": null
        },
        {
          "name": "core",
          "type": "tree",
          "content": null
        },
        {
          "name": "scaffold.go",
          "type": "blob",
          "size": 1.544921875,
          "content": "package main\n\nimport (\n\t\"os\"\n\n\t\"github.com/itsabot/abot/core\"\n)\n\nfunc pluginScaffoldFile(dir, name string) string {\n\treturn `package ` + name + `\n\nimport (\n\t\"github.com/itsabot/abot/core/log\"\n\t\"github.com/itsabot/abot/shared/datatypes\"\n\t\"github.com/itsabot/abot/shared/plugin\"\n)\n\nvar p *dt.Plugin\n\nconst memKey = \"firstToken\"\n\nfunc init() {\n\tvar err error\n\tp, err = plugin.New(\"` + dir + `\")\n\tif err != nil {\n\t\tlog.Fatal(\"failed to build plugin ` + name + `\", err)\n\t}\n\tplugin.SetKeywords(p,\n\t\tdt.KeywordHandler{\n\t\t\tFn: kwDemo,\n\t\t\tTrigger: &dt.StructuredInput{\n\t\t\t\tCommands: []string{\n\t\t\t\t\t\"show\",\n\t\t\t\t},\n\t\t\t\tObjects: []string{\n\t\t\t\t\t\"demo\",\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t)\n\tplugin.SetStates(p, [][]dt.State{[]dt.State{\n\t\t{\n\t\t\tOnEntry: func(in *dt.Msg) string {\n\t\t\t\treturn \"This is a demo.\"\n\t\t\t},\n\t\t\tOnInput: func(in *dt.Msg) {\n\t\t\t\tif len(in.Tokens) == 0 {\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tp.SetMemory(in, memKey, in.Tokens[0])\n\t\t\t},\n\t\t\tComplete: func(in *dt.Msg) (bool, string) {\n\t\t\t\treturn p.HasMemory(in, memKey), \"I didn't understand that.\"\n\t\t\t},\n\t\t},\n\t}})\n\tp.SM.SetOnReset(func(in *dt.Msg) {\n\t\tp.DeleteMemory(in, memKey)\n\t})\n\tif err = plugin.Register(p); err != nil {\n\t\tp.Log.Fatalf(\"failed to register plugin ` + name + `. %s\", err)\n\t}\n}\n\nfunc kwDemo(in *dt.Msg) string {\n\treturn \"It worked! You typed: \" + in.Sentence\n}`\n}\n\nfunc serverAbotEnv(name, curDir string) string {\n\treturn `PORT=` + os.Getenv(\"PORT\") + `\nABOT_ENV=development\nABOT_PATH=\"` + curDir + `\"\nABOT_DATABASE_URL=\"` + core.DBConnectionString(name) + `\"\nABOT_SECRET=` + core.RandAlphaNumSeq(64) + `\nABOT_URL=http://localhost:$PORT`\n}\n"
        },
        {
          "name": "shared",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}