{
  "metadata": {
    "timestamp": 1736567101556,
    "page": 693,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjcwMA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "git-jiadong/wechatDataBackup",
      "stars": 2676,
      "defaultBranch": "main",
      "files": [
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.7373046875,
          "content": "# After editing .gitignore to match the ignored files, you can do < git ls-files -ci --exclude-standard >\n# to see the files that are included in the exclude lists; you can then do\n# \n# @ Linux/MacOS: < git ls-files -ci --exclude-standard -z | xargs -0 git rm --cached >\n# @ Windows (PowerShell): < git ls-files -ci --exclude-standard | % { git rm --cached \"$_\" } >\n# @ Windows (cmd.exe): < for /F \"tokens=*\" %a in ('git ls-files -ci --exclude-standard') do @git rm --cached \"%a\" >\n# ...to re-init the ignore list\n\n# Wails directories\nbuild/bin\nfrontend/wailsjs\nfrontend/node_modules\n\n# Wails junk files\n.syso\n\n# Go files\ngo.sum\n\n# IDEs\n.idea\n.vscode\n\n# System enviroment variables\nenv\n*/.DS_Store\n\n\n# runtime\nUser\nconfig.json\nwechatDataBackup.exe\napp.log"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 11.0908203125,
          "content": "                                 Apache License\n                           Version 2.0, January 2004\n                        http://www.apache.org/licenses/\n\n   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION\n\n   1. Definitions.\n\n      \"License\" shall mean the terms and conditions for use, reproduction,\n      and distribution as defined by Sections 1 through 9 of this document.\n\n      \"Licensor\" shall mean the copyright owner or entity authorized by\n      the copyright owner that is granting the License.\n\n      \"Legal Entity\" shall mean the union of the acting entity and all\n      other entities that control, are controlled by, or are under common\n      control with that entity. For the purposes of this definition,\n      \"control\" means (i) the power, direct or indirect, to cause the\n      direction or management of such entity, whether by contract or\n      otherwise, or (ii) ownership of fifty percent (50%) or more of the\n      outstanding shares, or (iii) beneficial ownership of such entity.\n\n      \"You\" (or \"Your\") shall mean an individual or Legal Entity\n      exercising permissions granted by this License.\n\n      \"Source\" form shall mean the preferred form for making modifications,\n      including but not limited to software source code, documentation\n      source, and configuration files.\n\n      \"Object\" form shall mean any form resulting from mechanical\n      transformation or translation of a Source form, including but\n      not limited to compiled object code, generated documentation,\n      and conversions to other media types.\n\n      \"Work\" shall mean the work of authorship, whether in Source or\n      Object form, made available under the License, as indicated by a\n      copyright notice that is included in or attached to the work\n      (an example is provided in the Appendix below).\n\n      \"Derivative Works\" shall mean any work, whether in Source or Object\n      form, that is based on (or derived from) the Work and for which the\n      editorial revisions, annotations, elaborations, or other modifications\n      represent, as a whole, an original work of authorship. For the purposes\n      of this License, Derivative Works shall not include works that remain\n      separable from, or merely link (or bind by name) to the interfaces of,\n      the Work and Derivative Works thereof.\n\n      \"Contribution\" shall mean any work of authorship, including\n      the original version of the Work and any modifications or additions\n      to that Work or Derivative Works thereof, that is intentionally\n      submitted to Licensor for inclusion in the Work by the copyright owner\n      or by an individual or Legal Entity authorized to submit on behalf of\n      the copyright owner. For the purposes of this definition, \"submitted\"\n      means any form of electronic, verbal, or written communication sent\n      to the Licensor or its representatives, including but not limited to\n      communication on electronic mailing lists, source code control systems,\n      and issue tracking systems that are managed by, or on behalf of, the\n      Licensor for the purpose of discussing and improving the Work, but\n      excluding communication that is conspicuously marked or otherwise\n      designated in writing by the copyright owner as \"Not a Contribution.\"\n\n      \"Contributor\" shall mean Licensor and any individual or Legal Entity\n      on behalf of whom a Contribution has been received by Licensor and\n      subsequently incorporated within the Work.\n\n   2. Grant of Copyright License. Subject to the terms and conditions of\n      this License, each Contributor hereby grants to You a perpetual,\n      worldwide, non-exclusive, no-charge, royalty-free, irrevocable\n      copyright license to reproduce, prepare Derivative Works of,\n      publicly display, publicly perform, sublicense, and distribute the\n      Work and such Derivative Works in Source or Object form.\n\n   3. Grant of Patent License. Subject to the terms and conditions of\n      this License, each Contributor hereby grants to You a perpetual,\n      worldwide, non-exclusive, no-charge, royalty-free, irrevocable\n      (except as stated in this section) patent license to make, have made,\n      use, offer to sell, sell, import, and otherwise transfer the Work,\n      where such license applies only to those patent claims licensable\n      by such Contributor that are necessarily infringed by their\n      Contribution(s) alone or by combination of their Contribution(s)\n      with the Work to which such Contribution(s) was submitted. If You\n      institute patent litigation against any entity (including a\n      cross-claim or counterclaim in a lawsuit) alleging that the Work\n      or a Contribution incorporated within the Work constitutes direct\n      or contributory patent infringement, then any patent licenses\n      granted to You under this License for that Work shall terminate\n      as of the date such litigation is filed.\n\n   4. Redistribution. You may reproduce and distribute copies of the\n      Work or Derivative Works thereof in any medium, with or without\n      modifications, and in Source or Object form, provided that You\n      meet the following conditions:\n\n      (a) You must give any other recipients of the Work or\n          Derivative Works a copy of this License; and\n\n      (b) You must cause any modified files to carry prominent notices\n          stating that You changed the files; and\n\n      (c) You must retain, in the Source form of any Derivative Works\n          that You distribute, all copyright, patent, trademark, and\n          attribution notices from the Source form of the Work,\n          excluding those notices that do not pertain to any part of\n          the Derivative Works; and\n\n      (d) If the Work includes a \"NOTICE\" text file as part of its\n          distribution, then any Derivative Works that You distribute must\n          include a readable copy of the attribution notices contained\n          within such NOTICE file, excluding those notices that do not\n          pertain to any part of the Derivative Works, in at least one\n          of the following places: within a NOTICE text file distributed\n          as part of the Derivative Works; within the Source form or\n          documentation, if provided along with the Derivative Works; or,\n          within a display generated by the Derivative Works, if and\n          wherever such third-party notices normally appear. The contents\n          of the NOTICE file are for informational purposes only and\n          do not modify the License. You may add Your own attribution\n          notices within Derivative Works that You distribute, alongside\n          or as an addendum to the NOTICE text from the Work, provided\n          that such additional attribution notices cannot be construed\n          as modifying the License.\n\n      You may add Your own copyright statement to Your modifications and\n      may provide additional or different license terms and conditions\n      for use, reproduction, or distribution of Your modifications, or\n      for any such Derivative Works as a whole, provided Your use,\n      reproduction, and distribution of the Work otherwise complies with\n      the conditions stated in this License.\n\n   5. Submission of Contributions. Unless You explicitly state otherwise,\n      any Contribution intentionally submitted for inclusion in the Work\n      by You to the Licensor shall be under the terms and conditions of\n      this License, without any additional terms or conditions.\n      Notwithstanding the above, nothing herein shall supersede or modify\n      the terms of any separate license agreement you may have executed\n      with Licensor regarding such Contributions.\n\n   6. Trademarks. This License does not grant permission to use the trade\n      names, trademarks, service marks, or product names of the Licensor,\n      except as required for reasonable and customary use in describing the\n      origin of the Work and reproducing the content of the NOTICE file.\n\n   7. Disclaimer of Warranty. Unless required by applicable law or\n      agreed to in writing, Licensor provides the Work (and each\n      Contributor provides its Contributions) on an \"AS IS\" BASIS,\n      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n      implied, including, without limitation, any warranties or conditions\n      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A\n      PARTICULAR PURPOSE. You are solely responsible for determining the\n      appropriateness of using or redistributing the Work and assume any\n      risks associated with Your exercise of permissions under this License.\n\n   8. Limitation of Liability. In no event and under no legal theory,\n      whether in tort (including negligence), contract, or otherwise,\n      unless required by applicable law (such as deliberate and grossly\n      negligent acts) or agreed to in writing, shall any Contributor be\n      liable to You for damages, including any direct, indirect, special,\n      incidental, or consequential damages of any character arising as a\n      result of this License or out of the use or inability to use the\n      Work (including but not limited to damages for loss of goodwill,\n      work stoppage, computer failure or malfunction, or any and all\n      other commercial damages or losses), even if such Contributor\n      has been advised of the possibility of such damages.\n\n   9. Accepting Warranty or Additional Liability. While redistributing\n      the Work or Derivative Works thereof, You may choose to offer,\n      and charge a fee for, acceptance of support, warranty, indemnity,\n      or other liability obligations and/or rights consistent with this\n      License. However, in accepting such obligations, You may act only\n      on Your own behalf and on Your sole responsibility, not on behalf\n      of any other Contributor, and only if You agree to indemnify,\n      defend, and hold each Contributor harmless for any liability\n      incurred by, or claims asserted against, such Contributor by reason\n      of your accepting any such warranty or additional liability.\n\n   END OF TERMS AND CONDITIONS\n\n   APPENDIX: How to apply the Apache License to your work.\n\n      To apply the Apache License to your work, attach the following\n      boilerplate notice, with the fields enclosed by brackets \"[]\"\n      replaced with your own identifying information. (Don't include\n      the brackets!)  The text should be enclosed in the appropriate\n      comment syntax for the file format. We also recommend that a\n      file or class name and description of purpose be included on the\n      same \"printed page\" as the copyright notice for easier\n      identification within third-party archives.\n\n   Copyright [yyyy] [name of copyright owner]\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n       http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 4.3017578125,
          "content": "# wechatDataBackup\nPC微信聊天记录数据导出工具\n\n* 基于wails开发 + React前端，实现PC端微信聊天记录一键导出功能。\n* 导出后数据可以做永久化保存，即使微信停止支持，聊天记录也可以随时查看。\n* 前端界面尽量与微信界面保持一致，减少使用成本。\n* 理论上支持所有Windows 32/64位微信版本。\n\n效果图如下：\n\n![](./res/result.png)\n![](./res/result2.png)\n\n## 演示视频\n[演示视频](https://www.bilibili.com/video/BV1bPH1eWEEy/?share_source=copy_web&vd_source=b5cfa9258a9ad9900a00e9c1ce3cb4b6)\n## 使用方法\n1. 下载release可执行文件直接打开 国内朋友也可以使用 [网盘下载](https://pan.quark.cn/s/fa157b13e762)\n2. 下载源码自行编译可执行文件 [安装wails环境](https://wails.io/zh-Hans/docs/gettingstarted/installation)\n\n```shell\ngit clone https://github.com/git-jiadong/wechatDataBackup.git\ncd wechatDataBackup\nwails build\n```\n\n编译成功后在可执行二进制文件路径`build\\bin\\wechatDataBackup.exe`\n\n如果编译错误可能是没有gcc环境导致的，可以安装 [tdm-gcc](https://jmeubank.github.io/tdm-gcc/) 后在尝试。\n\n3. 导出聊天记录\n电脑登陆微信，然后打开`wechatDataBackup.exe`后按照如图提示导出\n![](./res/tips.png)\n\n## 功能\n\n本项目目前的规划与实现进度：\n- [x] 支持图片消息\n- [x] 支持视频消息\n- [x] 支持链接消息\n- [x] 支持语音消息\n- [x] 支持文件消息\n- [x] 支持原始表情显示\n- [x] 支持按类型检索\n- [x] 支持日期检索\n- [x] 支持按群成员检索\n- [x] 支持增量式导出\n- [x] 多开账号选择导出\n- [x] 多开账号数据切换\n- [x] 头像使用本地头像\n- [ ] 支持更多消息类型显示\n- [x] 图片查看器重绘\n- [ ] 实现表情预先下载（实现完全离线查看）\n- [ ] 聊天报告\n- [ ] AI本地模型应用\n- [ ] 导出数据本地加密\n- ...\n如果遇到什么问题，或者有更好的建议与优化点欢迎给作者提 [ISSUE](https://github.com/git-jiadong/wechatDataBackup/issues)\n\n\n### 常见问题\n**Q: 支持手机端的聊天记录备份吗？**<br>\nA: 手机端可以使用聊天数据迁移功能，将手机的数据迁移到电脑后再将数据导出。 [微信迁移聊天记录功能](https://www.bilibili.com/opus/974795819172495381)<br>\n**Q: 导出后界面是空白的、导出的数据比PC微信里面看到的少,数据不完整**<br>\nA: 这是由于可能数据存在于内存中还没有回写到磁盘导致的，退出微信时会将内存的数据全部回写到磁盘，导出数据时最好退出重新登陆一次微信，保证数据都在磁盘中再导出即可。<br>\n**Q: 有些图片、视频打不开**<br>\nA: 这是电脑端微信没有点开过这个消息，默认只加载了预览图而已，如果手机有打开过可以把手机的记录迁移到电脑，迁移后重新退出登陆一次微信导出即可。<br>\n**Q: Win7电脑不能使用**<br>\nA: Win7电脑需要安装WebView2运行时才能正常使用。github release版本做了Windows版本限制，[Win7用户请安装专属的版本](https://pan.quark.cn/s/fa157b13e762)\n## Star History\n\n[![Star History Chart](https://api.star-history.com/svg?repos=git-jiadong/wechatDataBackup&type=Date)](https://star-history.com/?utm_source=bestxtools.com#git-jiadong/wechatDataBackup&Date)\n\n## 免责声明\n**⚠️ 本项目仅供学习、研究使用，严禁商业使用**<br/>\n**⚠️ 用于网络安全用途的，请确保在国家法律法规下使用**<br/>\n**⚠️ 本项目完全免费，问你要钱的都是骗子**<br/>\n**⚠️ 使用本项目初衷是作者研究微信数据库的运行使用，您使用本软件导致的后果，包含但不限于数据损坏，记录丢失等问题，作者不承担相关责任。**<br/>\n**⚠️ 因软件特殊性质，请在使用时获得微信账号所有人授权，你当确保不侵犯他人个人隐私权，后果自行承担**<br/>\n\n## 前端代码\n由于前端代码不成熟，前端界面代码暂时不公开。\n\n## 参考/引用\n- 微信数据库解密和数据库的使用 [PyWxDump](https://github.com/xaoyaoo/PyWxDump/tree/master)\n- silk语音消息解码 [silk-v3-decoder](https://github.com/kn007/silk-v3-decoder)\n- PCM转MP3 [lame](https://github.com/viert/lame.git)\n- Dat图片解码 [wechatDatDecode](https://github.com/liuggchen/wechatDatDecode)"
        },
        {
          "name": "app.go",
          "type": "blob",
          "size": 17.52734375,
          "content": "package main\n\nimport (\n\t\"context\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"log\"\n\t\"mime\"\n\t\"net/http\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"strconv\"\n\t\"strings\"\n\t\"wechatDataBackup/pkg/utils\"\n\t\"wechatDataBackup/pkg/wechat\"\n\n\t\"github.com/spf13/viper\"\n\t\"github.com/wailsapp/wails/v2/pkg/runtime\"\n)\n\nconst (\n\tdefaultConfig        = \"config\"\n\tconfigDefaultUserKey = \"userConfig.defaultUser\"\n\tconfigUsersKey       = \"userConfig.users\"\n\tconfigExportPathKey  = \"exportPath\"\n\tappVersion           = \"v1.0.6\"\n)\n\ntype FileLoader struct {\n\thttp.Handler\n\tFilePrefix string\n}\n\nfunc NewFileLoader(prefix string) *FileLoader {\n\tmime.AddExtensionType(\".mp3\", \"audio/mpeg\")\n\treturn &FileLoader{FilePrefix: prefix}\n}\n\nfunc (h *FileLoader) SetFilePrefix(prefix string) {\n\th.FilePrefix = prefix\n\tlog.Println(\"SetFilePrefix\", h.FilePrefix)\n}\n\nfunc (h *FileLoader) ServeHTTP(res http.ResponseWriter, req *http.Request) {\n\trequestedFilename := h.FilePrefix + \"\\\\\" + strings.TrimPrefix(req.URL.Path, \"/\")\n\n\tfile, err := os.Open(requestedFilename)\n\tif err != nil {\n\t\thttp.Error(res, fmt.Sprintf(\"Could not load file %s\", requestedFilename), http.StatusBadRequest)\n\t\treturn\n\t}\n\tdefer file.Close()\n\n\tfileInfo, err := file.Stat()\n\tif err != nil {\n\t\thttp.Error(res, \"Could not retrieve file info\", http.StatusInternalServerError)\n\t\treturn\n\t}\n\n\tfileSize := fileInfo.Size()\n\trangeHeader := req.Header.Get(\"Range\")\n\tif rangeHeader == \"\" {\n\t\t// 无 Range 请求，直接返回整个文件\n\t\tres.Header().Set(\"Content-Length\", strconv.FormatInt(fileSize, 10))\n\t\thttp.ServeContent(res, req, requestedFilename, fileInfo.ModTime(), file)\n\t\treturn\n\t}\n\n\tvar start, end int64\n\tif strings.HasPrefix(rangeHeader, \"bytes=\") {\n\t\tranges := strings.Split(strings.TrimPrefix(rangeHeader, \"bytes=\"), \"-\")\n\t\tstart, _ = strconv.ParseInt(ranges[0], 10, 64)\n\n\t\tif len(ranges) > 1 && ranges[1] != \"\" {\n\t\t\tend, _ = strconv.ParseInt(ranges[1], 10, 64)\n\t\t} else {\n\t\t\tend = fileSize - 1\n\t\t}\n\t} else {\n\t\thttp.Error(res, \"Invalid Range header\", http.StatusRequestedRangeNotSatisfiable)\n\t\treturn\n\t}\n\n\tif start < 0 || end >= fileSize || start > end {\n\t\thttp.Error(res, \"Requested range not satisfiable\", http.StatusRequestedRangeNotSatisfiable)\n\t\treturn\n\t}\n\n\tcontentType := mime.TypeByExtension(filepath.Ext(requestedFilename))\n\tif contentType == \"\" {\n\t\tcontentType = \"application/octet-stream\"\n\t}\n\tres.Header().Set(\"Content-Type\", contentType)\n\tres.Header().Set(\"Content-Range\", fmt.Sprintf(\"bytes %d-%d/%d\", start, end, fileSize))\n\tres.Header().Set(\"Content-Length\", strconv.FormatInt(end-start+1, 10))\n\tres.WriteHeader(http.StatusPartialContent)\n\tbuffer := make([]byte, 102400)\n\tfile.Seek(start, 0)\n\tfor current := start; current <= end; {\n\t\treadSize := int64(len(buffer))\n\t\tif end-current+1 < readSize {\n\t\t\treadSize = end - current + 1\n\t\t}\n\n\t\tn, err := file.Read(buffer[:readSize])\n\t\tif err != nil {\n\t\t\tbreak\n\t\t}\n\n\t\tres.Write(buffer[:n])\n\t\tcurrent += int64(n)\n\t}\n}\n\n// App struct\ntype App struct {\n\tctx         context.Context\n\tinfoList    *wechat.WeChatInfoList\n\tprovider    *wechat.WechatDataProvider\n\tdefaultUser string\n\tusers       []string\n\tfirstStart  bool\n\tfirstInit   bool\n\tFLoader     *FileLoader\n}\n\ntype WeChatInfo struct {\n\tProcessID  uint32 `json:\"PID\"`\n\tFilePath   string `json:\"FilePath\"`\n\tAcountName string `json:\"AcountName\"`\n\tVersion    string `json:\"Version\"`\n\tIs64Bits   bool   `json:\"Is64Bits\"`\n\tDBKey      string `json:\"DBkey\"`\n}\n\ntype WeChatInfoList struct {\n\tInfo  []WeChatInfo `json:\"Info\"`\n\tTotal int          `json:\"Total\"`\n}\n\ntype WeChatAccountInfos struct {\n\tCurrentAccount string                     `json:\"CurrentAccount\"`\n\tInfo           []wechat.WeChatAccountInfo `json:\"Info\"`\n\tTotal          int                        `json:\"Total\"`\n}\n\ntype ErrorMessage struct {\n\tErrorStr string `json:\"error\"`\n}\n\n// NewApp creates a new App application struct\nfunc NewApp() *App {\n\ta := &App{}\n\tlog.Println(\"App version:\", appVersion)\n\ta.firstInit = true\n\ta.FLoader = NewFileLoader(\".\\\\\")\n\tviper.SetConfigName(defaultConfig)\n\tviper.SetConfigType(\"json\")\n\tviper.AddConfigPath(\".\")\n\tif err := viper.ReadInConfig(); err == nil {\n\t\ta.defaultUser = viper.GetString(configDefaultUserKey)\n\t\ta.users = viper.GetStringSlice(configUsersKey)\n\t\tprefix := viper.GetString(configExportPathKey)\n\t\tif prefix != \"\" {\n\t\t\tlog.Println(\"SetFilePrefix\", prefix)\n\t\t\ta.FLoader.SetFilePrefix(prefix)\n\t\t}\n\t} else {\n\t\tlog.Println(\"not config exist\")\n\t}\n\tlog.Printf(\"default: %s users: %v\\n\", a.defaultUser, a.users)\n\tif len(a.users) == 0 {\n\t\ta.firstStart = true\n\t}\n\n\treturn a\n}\n\n// startup is called when the app starts. The context is saved\n// so we can call the runtime methods\nfunc (a *App) startup(ctx context.Context) {\n\ta.ctx = ctx\n}\n\nfunc (a *App) beforeClose(ctx context.Context) (prevent bool) {\n\n\tif a.provider != nil {\n\t\ta.provider.WechatWechatDataProviderClose()\n\t\ta.provider = nil\n\t}\n\n\treturn false\n\n}\n\nfunc (a *App) GetWeChatAllInfo() string {\n\tinfoList := WeChatInfoList{}\n\tinfoList.Info = make([]WeChatInfo, 0)\n\tinfoList.Total = 0\n\n\tif a.provider != nil {\n\t\ta.provider.WechatWechatDataProviderClose()\n\t\ta.provider = nil\n\t}\n\n\ta.infoList = wechat.GetWeChatAllInfo()\n\tfor i := range a.infoList.Info {\n\t\tvar info WeChatInfo\n\t\tinfo.ProcessID = a.infoList.Info[i].ProcessID\n\t\tinfo.FilePath = a.infoList.Info[i].FilePath\n\t\tinfo.AcountName = a.infoList.Info[i].AcountName\n\t\tinfo.Version = a.infoList.Info[i].Version\n\t\tinfo.Is64Bits = a.infoList.Info[i].Is64Bits\n\t\tinfo.DBKey = a.infoList.Info[i].DBKey\n\t\tinfoList.Info = append(infoList.Info, info)\n\t\tinfoList.Total += 1\n\t\tlog.Printf(\"ProcessID %d, FilePath %s, AcountName %s, Version %s, Is64Bits %t\", info.ProcessID, info.FilePath, info.AcountName, info.Version, info.Is64Bits)\n\t}\n\tinfoStr, _ := json.Marshal(infoList)\n\t// log.Println(string(infoStr))\n\n\treturn string(infoStr)\n}\n\nfunc (a *App) ExportWeChatAllData(full bool, acountName string) {\n\n\tif a.provider != nil {\n\t\ta.provider.WechatWechatDataProviderClose()\n\t\ta.provider = nil\n\t}\n\n\tprogress := make(chan string)\n\tgo func() {\n\t\tvar pInfo *wechat.WeChatInfo\n\t\tfor i := range a.infoList.Info {\n\t\t\tif a.infoList.Info[i].AcountName == acountName {\n\t\t\t\tpInfo = &a.infoList.Info[i]\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\n\t\tif pInfo == nil {\n\t\t\tclose(progress)\n\t\t\truntime.EventsEmit(a.ctx, \"exportData\", fmt.Sprintf(\"{\\\"status\\\":\\\"error\\\", \\\"result\\\":\\\"%s error\\\"}\", acountName))\n\t\t\treturn\n\t\t}\n\n\t\tprefixExportPath := a.FLoader.FilePrefix + \"\\\\User\\\\\"\n\t\t_, err := os.Stat(prefixExportPath)\n\t\tif err != nil {\n\t\t\tos.Mkdir(prefixExportPath, os.ModeDir)\n\t\t}\n\n\t\texpPath := prefixExportPath + pInfo.AcountName\n\t\t_, err = os.Stat(expPath)\n\t\tif err == nil {\n\t\t\tif !full {\n\t\t\t\tos.RemoveAll(expPath + \"\\\\Msg\")\n\t\t\t} else {\n\t\t\t\tos.RemoveAll(expPath)\n\t\t\t}\n\t\t}\n\n\t\t_, err = os.Stat(expPath)\n\t\tif err != nil {\n\t\t\tos.Mkdir(expPath, os.ModeDir)\n\t\t}\n\n\t\tgo wechat.ExportWeChatAllData(*pInfo, expPath, progress)\n\n\t\tfor p := range progress {\n\t\t\tlog.Println(p)\n\t\t\truntime.EventsEmit(a.ctx, \"exportData\", p)\n\t\t}\n\n\t\ta.defaultUser = pInfo.AcountName\n\t\thasUser := false\n\t\tfor _, user := range a.users {\n\t\t\tif user == pInfo.AcountName {\n\t\t\t\thasUser = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif !hasUser {\n\t\t\ta.users = append(a.users, pInfo.AcountName)\n\t\t}\n\t\ta.setCurrentConfig()\n\t}()\n}\n\nfunc (a *App) createWechatDataProvider(resPath string, prefix string) error {\n\tif a.provider != nil && a.provider.SelfInfo != nil && filepath.Base(resPath) == a.provider.SelfInfo.UserName {\n\t\tlog.Println(\"WechatDataProvider not need create:\", a.provider.SelfInfo.UserName)\n\t\treturn nil\n\t}\n\n\tif a.provider != nil {\n\t\ta.provider.WechatWechatDataProviderClose()\n\t\ta.provider = nil\n\t\tlog.Println(\"createWechatDataProvider WechatWechatDataProviderClose\")\n\t}\n\n\tprovider, err := wechat.CreateWechatDataProvider(resPath, prefix)\n\tif err != nil {\n\t\tlog.Println(\"CreateWechatDataProvider failed:\", resPath)\n\t\treturn err\n\t}\n\n\ta.provider = provider\n\t// infoJson, _ := json.Marshal(a.provider.SelfInfo)\n\t// runtime.EventsEmit(a.ctx, \"selfInfo\", string(infoJson))\n\treturn nil\n}\n\nfunc (a *App) WeChatInit() {\n\n\tif a.firstInit {\n\t\ta.firstInit = false\n\t\ta.scanAccountByPath(a.FLoader.FilePrefix)\n\t\tlog.Println(\"scanAccountByPath:\", a.FLoader.FilePrefix)\n\t}\n\n\tif len(a.defaultUser) == 0 {\n\t\tlog.Println(\"not defaultUser\")\n\t\treturn\n\t}\n\n\texpPath := a.FLoader.FilePrefix + \"\\\\User\\\\\" + a.defaultUser\n\tprefixPath := \"\\\\User\\\\\" + a.defaultUser\n\twechat.ExportWeChatHeadImage(expPath)\n\tif a.createWechatDataProvider(expPath, prefixPath) == nil {\n\t\tinfoJson, _ := json.Marshal(a.provider.SelfInfo)\n\t\truntime.EventsEmit(a.ctx, \"selfInfo\", string(infoJson))\n\t}\n}\n\nfunc (a *App) GetWechatSessionList(pageIndex int, pageSize int) string {\n\tif a.provider == nil {\n\t\tlog.Println(\"provider not init\")\n\t\treturn \"{\\\"Total\\\":0}\"\n\t}\n\tlog.Printf(\"pageIndex: %d\\n\", pageIndex)\n\tlist, err := a.provider.WeChatGetSessionList(pageIndex, pageSize)\n\tif err != nil {\n\t\treturn \"{\\\"Total\\\":0}\"\n\t}\n\n\tlistStr, _ := json.Marshal(list)\n\tlog.Println(\"GetWechatSessionList:\", list.Total)\n\treturn string(listStr)\n}\n\nfunc (a *App) GetWechatContactList(pageIndex int, pageSize int) string {\n\tif a.provider == nil {\n\t\tlog.Println(\"provider not init\")\n\t\treturn \"{\\\"Total\\\":0}\"\n\t}\n\tlog.Printf(\"pageIndex: %d\\n\", pageIndex)\n\tlist, err := a.provider.WeChatGetContactList(pageIndex, pageSize)\n\tif err != nil {\n\t\treturn \"{\\\"Total\\\":0}\"\n\t}\n\n\tlistStr, _ := json.Marshal(list)\n\tlog.Println(\"WeChatGetContactList:\", list.Total)\n\treturn string(listStr)\n}\n\nfunc (a *App) GetWechatMessageListByTime(userName string, time int64, pageSize int, direction string) string {\n\tlog.Println(\"GetWechatMessageListByTime:\", userName, pageSize, time, direction)\n\tif len(userName) == 0 {\n\t\treturn \"{\\\"Total\\\":0, \\\"Rows\\\":[]}\"\n\t}\n\tdire := wechat.Message_Search_Forward\n\tif direction == \"backward\" {\n\t\tdire = wechat.Message_Search_Backward\n\t} else if direction == \"both\" {\n\t\tdire = wechat.Message_Search_Both\n\t}\n\tlist, err := a.provider.WeChatGetMessageListByTime(userName, time, pageSize, dire)\n\tif err != nil {\n\t\tlog.Println(\"GetWechatMessageListByTime failed:\", err)\n\t\treturn \"\"\n\t}\n\tlistStr, _ := json.Marshal(list)\n\tlog.Println(\"GetWechatMessageListByTime:\", list.Total)\n\n\treturn string(listStr)\n}\n\nfunc (a *App) GetWechatMessageListByType(userName string, time int64, pageSize int, msgType string, direction string) string {\n\tlog.Println(\"GetWechatMessageListByType:\", userName, pageSize, time, msgType, direction)\n\tif len(userName) == 0 {\n\t\treturn \"{\\\"Total\\\":0, \\\"Rows\\\":[]}\"\n\t}\n\tdire := wechat.Message_Search_Forward\n\tif direction == \"backward\" {\n\t\tdire = wechat.Message_Search_Backward\n\t} else if direction == \"both\" {\n\t\tdire = wechat.Message_Search_Both\n\t}\n\tlist, err := a.provider.WeChatGetMessageListByType(userName, time, pageSize, msgType, dire)\n\tif err != nil {\n\t\tlog.Println(\"WeChatGetMessageListByType failed:\", err)\n\t\treturn \"\"\n\t}\n\tlistStr, _ := json.Marshal(list)\n\tlog.Println(\"WeChatGetMessageListByType:\", list.Total)\n\n\treturn string(listStr)\n}\n\nfunc (a *App) GetWechatMessageListByKeyWord(userName string, time int64, keyword string, msgType string, pageSize int) string {\n\tlog.Println(\"GetWechatMessageListByKeyWord:\", userName, pageSize, time, msgType)\n\tif len(userName) == 0 {\n\t\treturn \"{\\\"Total\\\":0, \\\"Rows\\\":[]}\"\n\t}\n\tlist, err := a.provider.WeChatGetMessageListByKeyWord(userName, time, keyword, msgType, pageSize)\n\tif err != nil {\n\t\tlog.Println(\"WeChatGetMessageListByKeyWord failed:\", err)\n\t\treturn \"\"\n\t}\n\tlistStr, _ := json.Marshal(list)\n\tlog.Println(\"WeChatGetMessageListByKeyWord:\", list.Total, list.KeyWord)\n\n\treturn string(listStr)\n}\n\nfunc (a *App) GetWechatMessageDate(userName string) string {\n\tlog.Println(\"GetWechatMessageDate:\", userName)\n\tif len(userName) == 0 {\n\t\treturn \"{\\\"Total\\\":0, \\\"Date\\\":[]}\"\n\t}\n\n\tmessageData, err := a.provider.WeChatGetMessageDate(userName)\n\tif err != nil {\n\t\tlog.Println(\"GetWechatMessageDate:\", err)\n\t\treturn \"\"\n\t}\n\n\tmessageDataStr, _ := json.Marshal(messageData)\n\tlog.Println(\"GetWechatMessageDate:\", messageData.Total)\n\n\treturn string(messageDataStr)\n}\n\nfunc (a *App) setCurrentConfig() {\n\tviper.Set(configDefaultUserKey, a.defaultUser)\n\tviper.Set(configUsersKey, a.users)\n\tviper.Set(configExportPathKey, a.FLoader.FilePrefix)\n\terr := viper.SafeWriteConfig()\n\tif err != nil {\n\t\tlog.Println(err)\n\t\terr = viper.WriteConfig()\n\t\tif err != nil {\n\t\t\tlog.Println(err)\n\t\t}\n\t}\n}\n\ntype userList struct {\n\tUsers []string `json:\"Users\"`\n}\n\nfunc (a *App) GetWeChatUserList() string {\n\n\tl := userList{}\n\tl.Users = a.users\n\n\tusersStr, _ := json.Marshal(l)\n\tstr := string(usersStr)\n\tlog.Println(\"users:\", str)\n\treturn str\n}\n\nfunc (a *App) OpenFileOrExplorer(filePath string, explorer bool) string {\n\t// if root, err := os.Getwd(); err == nil {\n\t// \tfilePath = root + filePath[1:]\n\t// }\n\t// log.Println(\"OpenFileOrExplorer:\", filePath)\n\n\tpath := a.FLoader.FilePrefix + filePath\n\terr := utils.OpenFileOrExplorer(path, explorer)\n\tif err != nil {\n\t\treturn \"{\\\"result\\\": \\\"OpenFileOrExplorer failed\\\", \\\"status\\\":\\\"failed\\\"}\"\n\t}\n\n\treturn fmt.Sprintf(\"{\\\"result\\\": \\\"%s\\\", \\\"status\\\":\\\"OK\\\"}\", \"\")\n}\n\nfunc (a *App) GetWeChatRoomUserList(roomId string) string {\n\tuserlist, err := a.provider.WeChatGetChatRoomUserList(roomId)\n\tif err != nil {\n\t\tlog.Println(\"WeChatGetChatRoomUserList:\", err)\n\t\treturn \"\"\n\t}\n\n\tuserListStr, _ := json.Marshal(userlist)\n\n\treturn string(userListStr)\n}\n\nfunc (a *App) GetAppVersion() string {\n\treturn appVersion\n}\n\nfunc (a *App) GetAppIsFirstStart() bool {\n\tdefer func() { a.firstStart = false }()\n\treturn a.firstStart\n}\n\nfunc (a *App) GetWechatLocalAccountInfo() string {\n\tinfos := WeChatAccountInfos{}\n\tinfos.Info = make([]wechat.WeChatAccountInfo, 0)\n\tinfos.Total = 0\n\tinfos.CurrentAccount = a.defaultUser\n\tfor i := range a.users {\n\t\tresPath := a.FLoader.FilePrefix + \"\\\\User\\\\\" + a.users[i]\n\t\tif _, err := os.Stat(resPath); err != nil {\n\t\t\tlog.Println(\"GetWechatLocalAccountInfo:\", resPath, err)\n\t\t\tcontinue\n\t\t}\n\n\t\tprefixResPath := \"\\\\User\\\\\" + a.users[i]\n\t\tinfo, err := wechat.WechatGetAccountInfo(resPath, prefixResPath, a.users[i])\n\t\tif err != nil {\n\t\t\tlog.Println(\"GetWechatLocalAccountInfo\", err)\n\t\t\tcontinue\n\t\t}\n\n\t\tinfos.Info = append(infos.Info, *info)\n\t\tinfos.Total += 1\n\t}\n\n\tinfoString, _ := json.Marshal(infos)\n\tlog.Println(string(infoString))\n\n\treturn string(infoString)\n}\n\nfunc (a *App) WechatSwitchAccount(account string) bool {\n\tfor i := range a.users {\n\t\tif a.users[i] == account {\n\t\t\tif a.provider != nil {\n\t\t\t\ta.provider.WechatWechatDataProviderClose()\n\t\t\t\ta.provider = nil\n\t\t\t}\n\t\t\ta.defaultUser = account\n\t\t\ta.setCurrentConfig()\n\t\t\treturn true\n\t\t}\n\t}\n\n\treturn false\n}\n\nfunc (a *App) GetExportPathStat() string {\n\tpath := a.FLoader.FilePrefix\n\tlog.Println(\"utils.GetPathStat ++\")\n\tstat, err := utils.GetPathStat(path)\n\tlog.Println(\"utils.GetPathStat --\")\n\tif err != nil {\n\t\tlog.Println(\"GetPathStat error:\", path, err)\n\t\tvar msg ErrorMessage\n\t\tmsg.ErrorStr = fmt.Sprintf(\"%s:%v\", path, err)\n\t\tmsgStr, _ := json.Marshal(msg)\n\t\treturn string(msgStr)\n\t}\n\n\tstatString, _ := json.Marshal(stat)\n\n\treturn string(statString)\n}\n\nfunc (a *App) ExportPathIsCanWrite() bool {\n\tpath := a.FLoader.FilePrefix\n\treturn utils.PathIsCanWriteFile(path)\n}\n\nfunc (a *App) OpenExportPath() {\n\tpath := a.FLoader.FilePrefix\n\truntime.BrowserOpenURL(a.ctx, path)\n}\n\nfunc (a *App) OpenDirectoryDialog() string {\n\tdialogOptions := runtime.OpenDialogOptions{\n\t\tTitle: \"选择导出路径\",\n\t}\n\tselectedDir, err := runtime.OpenDirectoryDialog(a.ctx, dialogOptions)\n\tif err != nil {\n\t\tlog.Println(\"OpenDirectoryDialog:\", err)\n\t\treturn \"\"\n\t}\n\n\tif selectedDir == \"\" {\n\t\tlog.Println(\"Cancel selectedDir\")\n\t\treturn \"\"\n\t}\n\n\tif selectedDir == a.FLoader.FilePrefix {\n\t\tlog.Println(\"same path No need SetFilePrefix\")\n\t\treturn \"\"\n\t}\n\n\tif !utils.PathIsCanWriteFile(selectedDir) {\n\t\tlog.Println(\"PathIsCanWriteFile:\", selectedDir, \"error\")\n\t\treturn \"\"\n\t}\n\n\ta.FLoader.SetFilePrefix(selectedDir)\n\tlog.Println(\"OpenDirectoryDialog:\", selectedDir)\n\ta.scanAccountByPath(selectedDir)\n\treturn selectedDir\n}\n\nfunc (a *App) scanAccountByPath(path string) error {\n\tinfos := WeChatAccountInfos{}\n\tinfos.Info = make([]wechat.WeChatAccountInfo, 0)\n\tinfos.Total = 0\n\tinfos.CurrentAccount = \"\"\n\n\tuserPath := path + \"\\\\User\\\\\"\n\tif _, err := os.Stat(userPath); err != nil {\n\t\treturn err\n\t}\n\n\tdirs, err := os.ReadDir(userPath)\n\tif err != nil {\n\t\tlog.Println(\"ReadDir\", err)\n\t\treturn err\n\t}\n\n\tfor i := range dirs {\n\t\tif !dirs[i].Type().IsDir() {\n\t\t\tcontinue\n\t\t}\n\t\tlog.Println(\"dirs[i].Name():\", dirs[i].Name())\n\t\tresPath := path + \"\\\\User\\\\\" + dirs[i].Name()\n\t\tprefixResPath := \"\\\\User\\\\\" + dirs[i].Name()\n\t\tinfo, err := wechat.WechatGetAccountInfo(resPath, prefixResPath, dirs[i].Name())\n\t\tif err != nil {\n\t\t\tlog.Println(\"GetWechatLocalAccountInfo\", err)\n\t\t\tcontinue\n\t\t}\n\n\t\tinfos.Info = append(infos.Info, *info)\n\t\tinfos.Total += 1\n\t}\n\n\tusers := make([]string, 0)\n\tfor i := 0; i < infos.Total; i++ {\n\t\tusers = append(users, infos.Info[i].AccountName)\n\t}\n\n\ta.users = users\n\tfound := false\n\tfor i := range a.users {\n\t\tif a.defaultUser == a.users[i] {\n\t\t\tfound = true\n\t\t}\n\t}\n\n\tif !found {\n\t\ta.defaultUser = \"\"\n\t}\n\tif a.defaultUser == \"\" && len(a.users) > 0 {\n\t\ta.defaultUser = a.users[0]\n\t}\n\n\tif len(a.users) > 0 {\n\t\ta.setCurrentConfig()\n\t}\n\n\treturn nil\n}\n\nfunc (a *App) OepnLogFileExplorer() {\n\tutils.OpenFileOrExplorer(\".\\\\app.log\", true)\n}\n\nfunc (a *App) SaveFileDialog(file string, alisa string) string {\n\tfilePath := a.FLoader.FilePrefix + file\n\tif _, err := os.Stat(filePath); err != nil {\n\t\tlog.Println(\"SaveFileDialog:\", err)\n\t\treturn err.Error()\n\t}\n\n\tsavePath, err := runtime.SaveFileDialog(a.ctx, runtime.SaveDialogOptions{\n\t\tDefaultFilename: alisa,\n\t\tTitle:           \"选择保存路径\",\n\t})\n\tif err != nil {\n\t\tlog.Println(\"SaveFileDialog:\", err)\n\t\treturn err.Error()\n\t}\n\n\tif savePath == \"\" {\n\t\treturn \"\"\n\t}\n\n\tdirPath := filepath.Dir(savePath)\n\tif !utils.PathIsCanWriteFile(dirPath) {\n\t\terrStr := \"Path Is Can't Write File: \" + filepath.Dir(savePath)\n\t\tlog.Println(errStr)\n\t\treturn errStr\n\t}\n\n\t_, err = utils.CopyFile(filePath, savePath)\n\tif err != nil {\n\t\tlog.Println(\"Error CopyFile\", filePath, savePath, err)\n\t\treturn err.Error()\n\t}\n\n\treturn \"\"\n}\n"
        },
        {
          "name": "build",
          "type": "tree",
          "content": null
        },
        {
          "name": "changelog.md",
          "type": "blob",
          "size": 0.830078125,
          "content": "## v1.0.6\n1. 图片/视频查看重新实现，保持与微信一致\n2. 增加软件信息页面\n3. 修复企业联系人头像和名称不显示问题\n4. 修复撤回消息显示不正常的问题\n\n## v1.0.5\n1. 修复联系人搜索显示异常的问题\n2. 修复启动时界面加载显示慢的问题\n\n## v1.0.4\n1. 优化头像显示，优先使用本地头像显示\n2. 支持自定义导出路径、增加对导出路径的权限检测\n3. 增加联系人显示\n4. 滚动条滑块调整小大\n5. 支持已经打开日志所在文件夹、日志增加回滚功能\n\n## v1.0.3\n1. 增加首次使用的引导功能\n2. 增加多开微信可选择导出功能\n3. 增加多账号数据可以切换查看功能\n\n## v1.0.2\n1. 对话列表按照导出时微信显示顺序显示\n2. 增加版本更新检测按钮\n\n## v1.0.1\n1. 细化导出进度条的显示"
        },
        {
          "name": "frontend",
          "type": "tree",
          "content": null
        },
        {
          "name": "go.mod",
          "type": "blob",
          "size": 2.9453125,
          "content": "module wechatDataBackup\n\ngo 1.21.0\n\nrequire (\n\tgithub.com/beevik/etree v1.3.0\n\tgithub.com/git-jiadong/go-lame v0.0.0-20241215065806-397455857191\n\tgithub.com/git-jiadong/go-silk v0.0.0-20241215085148-b8734e30c24b\n\tgithub.com/mattn/go-sqlite3 v1.14.22\n\tgithub.com/pierrec/lz4 v2.6.1+incompatible\n\tgithub.com/pkg/browser v0.0.0-20210911075715-681adbf594b8\n\tgithub.com/shirou/gopsutil v2.21.11+incompatible\n\tgithub.com/shirou/gopsutil/v3 v3.24.2\n\tgithub.com/spf13/viper v1.18.2\n\tgithub.com/wailsapp/wails/v2 v2.9.1\n\tgolang.org/x/sys v0.20.0\n\tgoogle.golang.org/protobuf v1.31.0\n\tgopkg.in/natefinch/lumberjack.v2 v2.2.1\n)\n\nrequire (\n\tgithub.com/bep/debounce v1.2.1 // indirect\n\tgithub.com/fsnotify/fsnotify v1.7.0 // indirect\n\tgithub.com/go-ole/go-ole v1.2.6 // indirect\n\tgithub.com/godbus/dbus/v5 v5.1.0 // indirect\n\tgithub.com/google/uuid v1.4.0 // indirect\n\tgithub.com/hashicorp/hcl v1.0.0 // indirect\n\tgithub.com/jchv/go-winloader v0.0.0-20210711035445-715c2860da7e // indirect\n\tgithub.com/labstack/echo/v4 v4.10.2 // indirect\n\tgithub.com/labstack/gommon v0.4.0 // indirect\n\tgithub.com/leaanthony/go-ansi-parser v1.6.0 // indirect\n\tgithub.com/leaanthony/gosod v1.0.3 // indirect\n\tgithub.com/leaanthony/slicer v1.6.0 // indirect\n\tgithub.com/leaanthony/u v1.1.0 // indirect\n\tgithub.com/lufia/plan9stats v0.0.0-20211012122336-39d0f177ccd0 // indirect\n\tgithub.com/magiconair/properties v1.8.7 // indirect\n\tgithub.com/mattn/go-colorable v0.1.13 // indirect\n\tgithub.com/mattn/go-isatty v0.0.19 // indirect\n\tgithub.com/mitchellh/mapstructure v1.5.0 // indirect\n\tgithub.com/pelletier/go-toml/v2 v2.1.0 // indirect\n\tgithub.com/pkg/errors v0.9.1 // indirect\n\tgithub.com/power-devops/perfstat v0.0.0-20210106213030-5aafc221ea8c // indirect\n\tgithub.com/rivo/uniseg v0.4.4 // indirect\n\tgithub.com/sagikazarmark/locafero v0.4.0 // indirect\n\tgithub.com/sagikazarmark/slog-shim v0.1.0 // indirect\n\tgithub.com/samber/lo v1.38.1 // indirect\n\tgithub.com/shoenig/go-m1cpu v0.1.6 // indirect\n\tgithub.com/sourcegraph/conc v0.3.0 // indirect\n\tgithub.com/spf13/afero v1.11.0 // indirect\n\tgithub.com/spf13/cast v1.6.0 // indirect\n\tgithub.com/spf13/pflag v1.0.5 // indirect\n\tgithub.com/subosito/gotenv v1.6.0 // indirect\n\tgithub.com/tklauser/go-sysconf v0.3.13 // indirect\n\tgithub.com/tklauser/numcpus v0.7.0 // indirect\n\tgithub.com/tkrajina/go-reflector v0.5.6 // indirect\n\tgithub.com/valyala/bytebufferpool v1.0.0 // indirect\n\tgithub.com/valyala/fasttemplate v1.2.2 // indirect\n\tgithub.com/wailsapp/go-webview2 v1.0.10 // indirect\n\tgithub.com/wailsapp/mimetype v1.4.1 // indirect\n\tgithub.com/yusufpapurcu/wmi v1.2.4 // indirect\n\tgo.uber.org/atomic v1.9.0 // indirect\n\tgo.uber.org/multierr v1.9.0 // indirect\n\tgolang.org/x/crypto v0.23.0 // indirect\n\tgolang.org/x/exp v0.0.0-20230905200255-921286631fa9 // indirect\n\tgolang.org/x/net v0.25.0 // indirect\n\tgolang.org/x/text v0.15.0 // indirect\n\tgopkg.in/ini.v1 v1.67.0 // indirect\n\tgopkg.in/yaml.v3 v3.0.1 // indirect\n)\n\n// replace github.com/wailsapp/wails/v2 v2.8.0 => C:\\Users\\HAL\\go\\pkg\\mod\n"
        },
        {
          "name": "main.go",
          "type": "blob",
          "size": 1.2822265625,
          "content": "package main\n\nimport (\n\t\"embed\"\n\t\"io\"\n\t\"log\"\n\t\"os\"\n\n\t\"github.com/wailsapp/wails/v2\"\n\t\"github.com/wailsapp/wails/v2/pkg/options\"\n\t\"github.com/wailsapp/wails/v2/pkg/options/assetserver\"\n\t\"gopkg.in/natefinch/lumberjack.v2\"\n)\n\n//go:embed all:frontend/dist\nvar assets embed.FS\n\nfunc init() {\n\t// log output format\n\tlog.SetFlags(log.Ldate | log.Lmicroseconds | log.Lshortfile)\n}\n\nfunc main() {\n\tlogJack := &lumberjack.Logger{\n\t\tFilename:   \"./app.log\",\n\t\tMaxSize:    5,\n\t\tMaxBackups: 1,\n\t\tMaxAge:     30,\n\t\tCompress:   false,\n\t}\n\tdefer logJack.Close()\n\n\tmultiWriter := io.MultiWriter(logJack, os.Stdout)\n\t// 设置日志输出目标为文件\n\tlog.SetOutput(multiWriter)\n\tlog.Println(\"====================== wechatDataBackup ======================\")\n\t// Create an instance of the app structure\n\tapp := NewApp()\n\n\t// Create application with options\n\terr := wails.Run(&options.App{\n\t\tTitle:     \"wechatDataBackup\",\n\t\tMinWidth:  800,\n\t\tMinHeight: 600,\n\t\tWidth:     1024,\n\t\tHeight:    768,\n\t\tAssetServer: &assetserver.Options{\n\t\t\tAssets:  assets,\n\t\t\tHandler: app.FLoader,\n\t\t},\n\t\tBackgroundColour: &options.RGBA{R: 27, G: 38, B: 54, A: 1},\n\t\tOnStartup:        app.startup,\n\t\tOnBeforeClose:    app.beforeClose,\n\t\tBind: []interface{}{\n\t\t\tapp,\n\t\t},\n\t\tFrameless: true,\n\t})\n\n\tif err != nil {\n\t\tprintln(\"Error:\", err.Error())\n\t}\n}\n"
        },
        {
          "name": "pkg",
          "type": "tree",
          "content": null
        },
        {
          "name": "res",
          "type": "tree",
          "content": null
        },
        {
          "name": "wails.json",
          "type": "blob",
          "size": 0.3046875,
          "content": "{\n  \"$schema\": \"https://wails.io/schemas/config.v2.json\",\n  \"name\": \"wechatDataBackup\",\n  \"outputfilename\": \"wechatDataBackup\",\n  \"frontend:install\": \"\",\n  \"frontend:build\": \"\",\n  \"frontend:dev:watcher\": \"\",\n  \"frontend:dev:serverUrl\": \"\",\n  \"author\": {\n    \"name\": \"hal\",\n    \"email\": \"1174221722@qq.com\"\n  }\n}\n"
        }
      ]
    }
  ]
}