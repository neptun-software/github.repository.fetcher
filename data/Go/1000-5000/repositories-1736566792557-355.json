{
  "metadata": {
    "timestamp": 1736566792557,
    "page": 355,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjM2MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "loov/lensm",
      "stars": 3531,
      "defaultBranch": "main",
      "files": [
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.275390625,
          "content": "# Binaries for programs and plugins\n*.exe\n*.exe~\n*.dll\n*.so\n*.dylib\n\n# Test binary, built with `go test -c`\n*.test\n\n# Output of the go coverage tool, specifically when used with LiteIDE\n*.out\n\n# Dependency directories (remove the comment below to include it)\n# vendor/\n.idea/\n\nlensm"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.072265625,
          "content": "The MIT License (MIT)\n\nCopyright (c) 2022 Egon Elbre <egonelbre@gmail.com>\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE."
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 0.8740234375,
          "content": "# lensm\n\nA tool for viewing assembly and source.\n\n![Screenshot](./screenshot.gif)\n\nInstall with the usual Go commands:\n\n```\ngo install loov.dev/lensm@main\n```\n\n_For Linux you may need to add some [additional dependencies](https://gioui.org/doc/install/linux). You can use `go install --tags nowayland loov.dev/lensm@main` or `go install --tags nox11 loov.dev/lensm@main` respectively to skip building Wayland or X11 version._\n\nTo run the program provide a regular expression filter for the\nfunction you want to inspect. `-watch` allows to automatically\nreload the executable and information when it changes.\n\n```\nlensm -watch -filter Fibonacci lensm\n```\n\nNote: The program requires a binary that is built on your computer, otherwise the source code for the functions cannot be loaded.\n\n## Why?\n\nI wrote a blog post at https://www.storj.io/blog/lensm on why and how the core functionality works.\n"
        },
        {
          "name": "debug.go",
          "type": "blob",
          "size": 0.1435546875,
          "content": "package main\n\nconst N = 44\n\nfunc Fibonacci(n int) int {\n\tif n <= 1 {\n\t\treturn n\n\t}\n\treturn Fibonacci(n-1) + Fibonacci(n-2)\n}\n\nvar _ = Fibonacci(0)\n"
        },
        {
          "name": "fileui.go",
          "type": "blob",
          "size": 6.310546875,
          "content": "package main\n\nimport (\n\t\"image\"\n\t\"os\"\n\t\"time\"\n\n\t\"gioui.org/app\"\n\t\"gioui.org/font\"\n\t\"gioui.org/io/event\"\n\t\"gioui.org/layout\"\n\t\"gioui.org/op\"\n\t\"gioui.org/widget\"\n\t\"gioui.org/widget/material\"\n\n\t\"loov.dev/lensm/internal/disasm\"\n\t\"loov.dev/lensm/internal/goobj\"\n\t\"loov.dev/lensm/internal/wasmobj\"\n)\n\nvar workInProgressWASM bool\n\ntype FileUIConfig struct {\n\tPath    string\n\tWatch   bool\n\tContext int\n}\n\ntype FileUI struct {\n\tWindows *Windows\n\tTheme   *material.Theme\n\n\tConfig FileUIConfig\n\n\tLoadError error\n\n\t// Currently loaded executable.\n\tFile  disasm.File\n\tFuncs *FilterList[disasm.Func]\n\n\t// Active code view.\n\tCode CodeUI\n\n\t// Other FileUI elements.\n\tOpenInNew widget.Clickable\n}\n\nfunc NewExeUI(windows *Windows, theme *material.Theme) *FileUI {\n\tui := &FileUI{}\n\tui.Windows = windows\n\tui.Theme = theme\n\tui.Funcs = NewFilterList[disasm.Func](theme)\n\treturn ui\n}\n\nfunc (ui *FileUI) Run(w *app.Window) error {\n\tvar ops op.Ops\n\n\texited := make(chan struct{})\n\tdefer close(exited)\n\n\tfileLoaded := make(chan disasm.File, 1)\n\tfileLoadError := make(chan error, 1)\n\n\tloadFinished := func(exe disasm.File, err error) {\n\t\tif err == nil {\n\t\t\tselect {\n\t\t\tcase <-fileLoaded:\n\t\t\tdefault:\n\t\t\t}\n\t\t\tfileLoaded <- exe\n\t\t} else {\n\t\t\tselect {\n\t\t\tcase <-fileLoadError:\n\t\t\tdefault:\n\t\t\t}\n\t\t\tfileLoadError <- err\n\t\t}\n\t}\n\n\tgo func() {\n\t\tvar lastModTime time.Time\n\t\ttick := time.NewTicker(100 * time.Millisecond)\n\t\tdefer tick.Stop()\n\t\tfor {\n\t\t\tfunc() {\n\t\t\t\tstat, err := os.Stat(ui.Config.Path)\n\t\t\t\tif err != nil {\n\t\t\t\t\tloadFinished(nil, err)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tif stat.ModTime().Equal(lastModTime) {\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tlastModTime = stat.ModTime()\n\n\t\t\t\tif workInProgressWASM {\n\t\t\t\t\tloadFinished(wasmobj.Load(ui.Config.Path))\n\t\t\t\t} else {\n\t\t\t\t\tloadFinished(goobj.Load(ui.Config.Path))\n\t\t\t\t}\n\t\t\t}()\n\n\t\t\tif !ui.Config.Watch {\n\t\t\t\tbreak\n\t\t\t}\n\n\t\t\tselect {\n\t\t\tcase <-tick.C:\n\t\t\tcase <-exited:\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t}()\n\n\tevents := make(chan event.Event)\n\tacks := make(chan struct{})\n\n\tgo func() {\n\t\tfor {\n\t\t\tev := w.Event()\n\t\t\tevents <- ev\n\t\t\t<-acks\n\t\t\tif _, ok := ev.(app.DestroyEvent); ok {\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t}()\n\n\tfor {\n\t\tselect {\n\t\tcase err := <-fileLoadError:\n\t\t\tui.LoadError = err\n\t\t\tw.Invalidate()\n\t\tcase file := <-fileLoaded:\n\t\t\tui.SetFile(file)\n\t\t\tw.Invalidate()\n\t\tcase e := <-events:\n\t\t\tswitch e := e.(type) {\n\t\t\tcase app.FrameEvent:\n\t\t\t\tgtx := app.NewContext(&ops, e)\n\t\t\t\tui.Layout(gtx)\n\t\t\t\te.Frame(gtx.Ops)\n\n\t\t\tcase app.DestroyEvent:\n\t\t\t\tacks <- struct{}{}\n\t\t\t\treturn e.Err\n\t\t\t}\n\t\t\tacks <- struct{}{}\n\t\t}\n\t}\n}\n\nfunc (ui *FileUI) SetFile(file disasm.File) {\n\tif ui.File != nil {\n\t\t_ = ui.File.Close()\n\t}\n\tui.File = file\n\tui.Funcs.SetItems(file.Funcs())\n\tif ui.Funcs.Selected != \"\" {\n\t\tfor _, fn := range file.Funcs() {\n\t\t\tif fn.Name() == ui.Funcs.Selected {\n\t\t\t\tui.Code.Code = fn.Load(ui.loadOptions())\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc (ui *FileUI) loadOptions() disasm.Options {\n\treturn disasm.Options{Context: ui.Config.Context}\n}\n\nfunc (ui *FileUI) Layout(gtx layout.Context) {\n\tfor ui.OpenInNew.Clicked(gtx) {\n\t\tui.openInNew(gtx)\n\t}\n\n\tif ui.Funcs.Selected == \"\" {\n\t\tui.Funcs.SelectIndex(0)\n\t}\n\n\tif !ui.Code.Loaded() || ui.Code.Name != ui.Funcs.Selected {\n\t\tselected := ui.Funcs.SelectedItem\n\t\tif selected != nil {\n\t\t\tui.Code.Code = selected.Load(ui.loadOptions())\n\t\t}\n\t}\n\n\tlayout.Flex{\n\t\tAxis: layout.Horizontal,\n\t}.Layout(gtx,\n\t\tlayout.Rigid(func(gtx layout.Context) layout.Dimensions {\n\t\t\tgtx.Constraints = layout.Exact(image.Point{\n\t\t\t\tX: gtx.Metric.Sp(10 * 20),\n\t\t\t\tY: gtx.Constraints.Max.Y,\n\t\t\t})\n\t\t\treturn ui.Funcs.Layout(ui.Theme, gtx)\n\t\t}),\n\t\tlayout.Rigid(VerticalLine{Width: 1, Color: splitterColor}.Layout),\n\t\tlayout.Flexed(1, func(gtx layout.Context) layout.Dimensions {\n\t\t\treturn layout.Flex{Axis: layout.Vertical}.Layout(gtx,\n\t\t\t\tlayout.Rigid(func(gtx layout.Context) layout.Dimensions {\n\t\t\t\t\tif ui.LoadError != nil {\n\t\t\t\t\t\treturn material.Body1(ui.Theme, ui.LoadError.Error()).Layout(gtx)\n\t\t\t\t\t}\n\t\t\t\t\tif !ui.Code.Loaded() {\n\t\t\t\t\t\treturn layout.Dimensions{}\n\t\t\t\t\t}\n\t\t\t\t\ttxt := material.Body1(ui.Theme, ui.Code.Code.Name)\n\t\t\t\t\ttxt.TextSize *= 1.2\n\n\t\t\t\t\tinset := layout.Inset{Top: 4, Left: 4, Right: 4, Bottom: 2}\n\t\t\t\t\treturn inset.Layout(gtx, txt.Layout)\n\t\t\t\t}),\n\t\t\t\tlayout.Rigid(func(gtx layout.Context) layout.Dimensions {\n\t\t\t\t\tif ui.LoadError != nil || !ui.Code.Loaded() {\n\t\t\t\t\t\treturn layout.Dimensions{}\n\t\t\t\t\t}\n\t\t\t\t\ttxt := material.Body1(ui.Theme, \"file: \"+ui.Code.Code.File)\n\t\t\t\t\ttxt.Font.Style = font.Italic\n\n\t\t\t\t\tinset := layout.Inset{Top: 2, Left: 4, Right: 4, Bottom: 4}\n\t\t\t\t\treturn inset.Layout(gtx, txt.Layout)\n\t\t\t\t}),\n\t\t\t\tlayout.Rigid(HorizontalLine{Height: 1, Color: splitterColor}.Layout),\n\t\t\t\tlayout.Flexed(1, func(gtx layout.Context) layout.Dimensions {\n\t\t\t\t\tif ui.LoadError != nil {\n\t\t\t\t\t\treturn layout.Dimensions{}\n\t\t\t\t\t}\n\n\t\t\t\t\tgtx.Constraints = layout.Exact(gtx.Constraints.Max)\n\t\t\t\t\treturn layout.Stack{\n\t\t\t\t\t\tAlignment: layout.SE,\n\t\t\t\t\t}.Layout(gtx,\n\t\t\t\t\t\tlayout.Expanded(func(gtx layout.Context) layout.Dimensions {\n\t\t\t\t\t\t\treturn CodeUIStyle{\n\t\t\t\t\t\t\t\tCodeUI: &ui.Code,\n\n\t\t\t\t\t\t\t\tTryOpen: ui.tryOpen,\n\n\t\t\t\t\t\t\t\tTheme:      ui.Theme,\n\t\t\t\t\t\t\t\tTextHeight: ui.Theme.TextSize,\n\t\t\t\t\t\t\t\tLineHeight: ui.Theme.TextSize * 1.2,\n\t\t\t\t\t\t\t}.Layout(gtx)\n\t\t\t\t\t\t}),\n\t\t\t\t\t\tlayout.Stacked(func(gtx layout.Context) layout.Dimensions {\n\t\t\t\t\t\t\tbutton := material.IconButton(ui.Theme, &ui.OpenInNew, OpenInNewIcon, \"Open in separate window\")\n\t\t\t\t\t\t\tbutton.Size = 16\n\t\t\t\t\t\t\tbutton.Inset = layout.UniformInset(12)\n\t\t\t\t\t\t\treturn layout.UniformInset(2).Layout(gtx, button.Layout)\n\t\t\t\t\t\t}),\n\t\t\t\t\t)\n\t\t\t\t}),\n\t\t\t)\n\t\t}),\n\t)\n}\n\nfunc (ui *FileUI) tryOpen(gtx layout.Context, call string) {\n\tvar fn disasm.Func\n\tfor _, target := range ui.File.Funcs() {\n\t\tif target.Name() == call {\n\t\t\tfn = target\n\t\t\tbreak\n\t\t}\n\t}\n\tif fn == nil {\n\t\treturn\n\t}\n\n\tload := fn.Load(ui.loadOptions())\n\tui.Funcs.Selected = load.Name\n\tui.Funcs.SelectedItem = fn\n\tui.Funcs.List.Selected = -1\n\tfor i, fil := range ui.Funcs.Filtered {\n\t\tif fil == fn {\n\t\t\tui.Funcs.List.Selected = i\n\t\t\tbreak\n\t\t}\n\t}\n\n\tui.Code.Code = load\n\n\tif ui.Funcs.Selected == \"\" {\n\t\tui.Funcs.SelectIndex(0)\n\t}\n\n\tui.Code.ResetScroll()\n}\n\nfunc (ui *FileUI) openInNew(gtx layout.Context) {\n\tstate := ui.Code\n\tstyle := CodeUIStyle{\n\t\tTheme:  ui.Theme,\n\t\tCodeUI: &state,\n\n\t\tTextHeight: ui.Theme.TextSize,\n\t\tLineHeight: ui.Theme.TextSize * 14 / 12,\n\t}\n\n\tsize := gtx.Constraints.Max\n\tsize.X = int(float32(size.X) / gtx.Metric.PxPerDp)\n\tsize.Y = int(float32(size.Y) / gtx.Metric.PxPerDp)\n\tui.Windows.Open(ui.Code.Name, size, WidgetWindow(style.Layout))\n}\n"
        },
        {
          "name": "fileui_code.go",
          "type": "blob",
          "size": 11.251953125,
          "content": "package main\n\nimport (\n\t\"fmt\"\n\t\"image\"\n\t\"image/color\"\n\t\"math\"\n\t\"time\"\n\n\t\"gioui.org/f32\"\n\t\"gioui.org/gesture\"\n\t\"gioui.org/io/event\"\n\t\"gioui.org/io/pointer\"\n\t\"gioui.org/layout\"\n\t\"gioui.org/op\"\n\t\"gioui.org/op/clip\"\n\t\"gioui.org/op/paint\"\n\t\"gioui.org/unit\"\n\t\"gioui.org/widget\"\n\t\"gioui.org/widget/material\"\n\n\t\"loov.dev/lensm/internal/disasm\"\n\t\"loov.dev/lensm/internal/f32color\"\n)\n\ntype CodeUI struct {\n\t*disasm.Code\n\n\tasm struct {\n\t\tscroll  float32\n\t\tgesture gesture.Scroll\n\t\tbar     widget.Scrollbar\n\t\tanim    ScrollAnimation\n\t}\n\tsrc struct {\n\t\tscroll  float32\n\t\tgesture gesture.Scroll\n\t\tbar     widget.Scrollbar\n\t}\n\n\tmousePosition f32.Point\n}\n\nfunc (ui *CodeUI) Loaded() bool {\n\treturn ui.Code != nil\n}\n\nfunc (ui *CodeUI) ResetScroll() {\n\tui.asm.scroll = 100000\n\tui.src.scroll = 100000\n}\n\ntype CodeUIStyle struct {\n\t*CodeUI\n\n\tTryOpen func(gtx layout.Context, funcname string)\n\tTheme   *material.Theme\n\n\tTextHeight unit.Sp\n\tLineHeight unit.Sp\n}\n\nfunc (ui CodeUIStyle) Layout(gtx layout.Context) layout.Dimensions {\n\tgtx.Constraints = layout.Exact(gtx.Constraints.Max)\n\tif ui.Code == nil {\n\t\treturn layout.Dimensions{Size: gtx.Constraints.Max}\n\t}\n\n\tdefer clip.Rect{Max: gtx.Constraints.Max}.Push(gtx.Ops).Pop()\n\n\tmouseClicked := false\n\n\tevent.Op(gtx.Ops, ui.Code)\n\tfor {\n\t\tev, ok := gtx.Event(pointer.Filter{\n\t\t\tKinds: pointer.Move | pointer.Press,\n\t\t})\n\t\tif !ok {\n\t\t\tbreak\n\t\t}\n\t\tif ev, ok := ev.(pointer.Event); ok {\n\t\t\tswitch ev.Kind {\n\t\t\tcase pointer.Move:\n\t\t\t\tui.mousePosition = ev.Position\n\t\t\tcase pointer.Press:\n\t\t\t\tmouseClicked = true\n\t\t\t}\n\t\t}\n\t}\n\n\t// The layout has the following sections:\n\t// pad | Jump | pad/2 | Related | pad | Gutter | pad | Source | pad\n\n\tlineHeight := gtx.Metric.Sp(ui.LineHeight)\n\tpad := lineHeight\n\tjumpStep := lineHeight / 2\n\tjumpWidth := jumpStep * ui.Code.MaxJump\n\tgutterWidth := lineHeight * 8\n\tblocksWidth := gtx.Constraints.Max.X - gutterWidth - jumpWidth - 4*pad - pad/2\n\n\tjump := BoundsWidth(pad, jumpWidth)\n\tasm := BoundsWidth(int(jump.Max)+pad/2, blocksWidth*3/10)\n\tgutter := BoundsWidth(int(asm.Max)+pad, gutterWidth)\n\tsource := BoundsWidth(int(gutter.Max)+pad, blocksWidth*7/10)\n\n\t// draw gutter\n\tpaint.FillShape(gtx.Ops, f32color.Gray8(0xE8), clip.Rect{\n\t\tMin: image.Pt(int(gutter.Min), 0),\n\t\tMax: image.Pt(int(gutter.Max), gtx.Constraints.Max.Y),\n\t}.Op())\n\n\tif scroll, ok := ui.asm.anim.Update(gtx); ok {\n\t\tui.asm.scroll = scroll\n\t}\n\n\tmousePosition := ui.mousePosition\n\tmouseInAsm := asm.Contains(mousePosition.X)\n\tmouseInSource := source.Contains(mousePosition.X)\n\thighlightAsmIndex := -1\n\tif mouseInAsm {\n\t\thighlightAsmIndex = int(mousePosition.Y-ui.asm.scroll) / lineHeight\n\t}\n\tvar highlightRanges []disasm.LineRange\n\n\tif InRange(highlightAsmIndex, len(ui.Code.Insts)) {\n\t\tix := &ui.Code.Insts[highlightAsmIndex]\n\t\tif ui.TryOpen != nil && ix.Call != \"\" {\n\t\t\tpointer.CursorPointer.Add(gtx.Ops)\n\t\t\tif mouseClicked {\n\t\t\t\tui.TryOpen(gtx, ix.Call)\n\t\t\t}\n\t\t}\n\t\tif ix.Call == \"\" && ix.RefOffset != 0 {\n\t\t\tpointer.CursorPointer.Add(gtx.Ops)\n\t\t\tif mouseClicked {\n\t\t\t\t// TODO: smooth scroll\n\t\t\t\t// highlightAsmIndex -= ix.RefOffset\n\t\t\t\tui.asm.anim.Start(gtx, ui.asm.scroll, ui.asm.scroll-float32(ix.RefOffset*lineHeight), 150*time.Millisecond)\n\t\t\t}\n\t\t}\n\t}\n\n\t// relations underlay\n\ttop := int(ui.src.scroll)\n\tvar highlightPath *clip.PathSpec\n\tvar highlightColor color.NRGBA\n\tfor i, src := range ui.Code.Source {\n\t\tif i > 0 {\n\t\t\ttop += lineHeight\n\t\t}\n\t\ttop += lineHeight\n\t\tfor i, block := range src.Blocks {\n\t\t\tif i > 0 {\n\t\t\t\ttop += lineHeight\n\t\t\t}\n\t\t\tfor off, ranges := range block.Related {\n\t\t\t\tif len(ranges) > 0 {\n\t\t\t\t\thighlight := false\n\t\t\t\t\tif mouseInSource {\n\t\t\t\t\t\tif float32(top) <= mousePosition.Y && mousePosition.Y < float32(top+lineHeight) {\n\t\t\t\t\t\t\thighlight = true\n\t\t\t\t\t\t\thighlightRanges = ranges\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tvar p clip.Path\n\t\t\t\t\tp.Begin(gtx.Ops)\n\t\t\t\t\tp.MoveTo(f32.Pt(gutter.Max, float32(top+lineHeight)))\n\t\t\t\t\tp.LineTo(f32.Pt(source.Max, float32(top+lineHeight)))\n\t\t\t\t\tp.LineTo(f32.Pt(source.Max, float32(top)))\n\t\t\t\t\tp.LineTo(f32.Pt(gutter.Max, float32(top)))\n\t\t\t\t\tpin := float32(top)\n\t\t\t\t\tfor i, r := range ranges {\n\t\t\t\t\t\tif mouseInAsm {\n\t\t\t\t\t\t\tif float32(r.From*lineHeight)+ui.asm.scroll <= mousePosition.Y && mousePosition.Y < float32(r.To*lineHeight)+ui.asm.scroll {\n\t\t\t\t\t\t\t\thighlight = true\n\t\t\t\t\t\t\t\thighlightRanges = ranges\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tconst S = 0.1\n\t\t\t\t\t\tp.CubeTo(\n\t\t\t\t\t\t\tf32.Pt(gutter.Lerp(0.5-S), pin),\n\t\t\t\t\t\t\tf32.Pt(gutter.Lerp(0.5+S), float32(r.From*lineHeight)+ui.asm.scroll),\n\t\t\t\t\t\t\tf32.Pt(gutter.Min, float32(r.From*lineHeight)+ui.asm.scroll))\n\t\t\t\t\t\tp.LineTo(f32.Pt(asm.Min, float32(r.From*lineHeight)+ui.asm.scroll))\n\t\t\t\t\t\tp.LineTo(f32.Pt(asm.Min, float32(r.To*lineHeight)+ui.asm.scroll))\n\t\t\t\t\t\tp.LineTo(f32.Pt(gutter.Min, float32(r.To*lineHeight)+ui.asm.scroll))\n\t\t\t\t\t\tpin = float32(top) + float32(lineHeight)*float32(i+1)/float32(len(ranges))\n\t\t\t\t\t\tp.CubeTo(\n\t\t\t\t\t\t\tf32.Pt(gutter.Lerp(0.5+S), float32(r.To*lineHeight)+ui.asm.scroll),\n\t\t\t\t\t\t\tf32.Pt(gutter.Lerp(0.5-S), pin),\n\t\t\t\t\t\t\tf32.Pt(gutter.Max, pin))\n\t\t\t\t\t}\n\t\t\t\t\talpha := float32(0.4)\n\t\t\t\t\tpathSpec := p.End()\n\t\t\t\t\tif highlight {\n\t\t\t\t\t\talpha = 0.8\n\t\t\t\t\t}\n\t\t\t\t\trelationColor := f32color.HSLA(float32(math.Mod(float64((i+1)*(off+1))*math.Phi, 1)), 0.9, 0.8, alpha)\n\t\t\t\t\tif !highlight {\n\t\t\t\t\t\tpaint.FillShape(gtx.Ops, relationColor, clip.Outline{Path: pathSpec}.Op())\n\t\t\t\t\t} else {\n\t\t\t\t\t\thighlightPath = &pathSpec\n\t\t\t\t\t\thighlightColor = relationColor\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\ttop += lineHeight\n\t\t\t}\n\t\t}\n\t}\n\tif highlightPath != nil {\n\t\tpaint.FillShape(gtx.Ops, highlightColor, clip.Outline{Path: *highlightPath}.Op())\n\t\tpaint.FillShape(gtx.Ops, color.NRGBA{A: 0x40}, clip.Stroke{Path: *highlightPath, Width: 1}.Op())\n\t}\n\n\t// assembly\n\tasmClip := clip.Rect{\n\t\tMin: image.Pt(int(jump.Min), 0),\n\t\tMax: image.Pt(int(gutter.Min), gtx.Constraints.Max.Y),\n\t}.Push(gtx.Ops)\n\tfor i, ix := range ui.Code.Insts {\n\t\tSourceLine{\n\t\t\tTopLeft:    image.Pt(int(asm.Min)+pad/2, i*lineHeight+int(ui.asm.scroll)),\n\t\t\tText:       ix.Text,\n\t\t\tTextHeight: ui.TextHeight,\n\t\t\tItalic:     ix.Call != \"\",\n\t\t\tBold:       highlightAsmIndex == i,\n\t\t\tColor:      f32color.Black,\n\t\t}.Layout(ui.Theme, gtx)\n\n\t\t// jump line\n\t\tif ix.RefOffset != 0 {\n\t\t\tlineWidth := gtx.Metric.Dp(1)\n\t\t\talign := float32(lineWidth%2) / 2\n\t\t\tstack := op.Affine(f32.Affine2D{}.Offset(\n\t\t\t\tf32.Pt(jump.Max+align, float32(i*lineHeight)+align+ui.asm.scroll))).Push(gtx.Ops)\n\n\t\t\tvar path clip.Path\n\t\t\tpath.Begin(gtx.Ops)\n\t\t\tpath.MoveTo(f32.Pt(float32(pad/2), float32(lineHeight*2/3)))\n\t\t\tpath.LineTo(f32.Pt(float32(-jumpStep*ix.RefStack), float32(lineHeight*2/3)))\n\t\t\tpath.LineTo(f32.Pt(float32(-jumpStep*ix.RefStack), float32(lineHeight/3+ix.RefOffset*lineHeight)))\n\t\t\tpath.LineTo(f32.Pt(float32(-jumpStep/2), float32(lineHeight/3+ix.RefOffset*lineHeight)))\n\t\t\t// draw arrow\n\t\t\tpath.Line(f32.Pt(0, float32(lineHeight/4)))\n\t\t\tpath.Line(f32.Pt(float32(lineHeight/3), float32(-lineHeight/4)))\n\t\t\tpath.Line(f32.Pt(float32(-lineHeight/3), float32(-lineHeight/4)))\n\t\t\tpath.Line(f32.Pt(0, float32(lineHeight/4)))\n\n\t\t\twidth := float32(lineWidth)\n\t\t\talpha := float32(0.7)\n\t\t\tif highlightAsmIndex >= 0 && (highlightAsmIndex == i || highlightAsmIndex == i+ix.RefOffset) {\n\t\t\t\twidth *= 3\n\t\t\t\talpha = 1\n\t\t\t} else if disasm.LineRangesContain(highlightRanges, i, i+ix.RefOffset) {\n\t\t\t\twidth *= 3\n\t\t\t}\n\t\t\tjumpColor := f32color.HSLA(float32(math.Mod(float64(ix.PC)*math.Phi, 1)), 0.8, 0.4, alpha)\n\t\t\tpaint.FillShape(gtx.Ops, jumpColor, clip.Stroke{Path: path.End(), Width: width}.Op())\n\n\t\t\tstack.Pop()\n\t\t}\n\t}\n\tasmClip.Pop()\n\n\t// source\n\tsourceClip := clip.Rect{\n\t\tMin: image.Pt(int(source.Min), 0),\n\t\tMax: image.Pt(int(source.Max), gtx.Constraints.Max.Y),\n\t}.Push(gtx.Ops)\n\ttop = int(ui.src.scroll)\n\tfor i, src := range ui.Code.Source {\n\t\tif i > 0 {\n\t\t\ttop += lineHeight\n\t\t}\n\t\tSourceLine{\n\t\t\tTopLeft:    image.Pt(int(source.Min), top),\n\t\t\tText:       src.File,\n\t\t\tTextHeight: ui.TextHeight,\n\t\t\tBold:       highlightAsmIndex == i,\n\t\t\tColor:      f32color.Black,\n\t\t}.Layout(ui.Theme, gtx)\n\t\ttop += lineHeight\n\t\tfor i, block := range src.Blocks {\n\t\t\tif i > 0 {\n\t\t\t\ttop += lineHeight\n\t\t\t}\n\t\t\tfor off, line := range block.Lines {\n\t\t\t\thighlight := mouseInSource && float32(top) <= mousePosition.Y && mousePosition.Y < float32(top+lineHeight)\n\t\t\t\tSourceLine{\n\t\t\t\t\tTopLeft:    image.Pt(int(source.Min), top),\n\t\t\t\t\tText:       fmt.Sprintf(\"%-4d %s\", block.From+off, line),\n\t\t\t\t\tTextHeight: ui.TextHeight,\n\t\t\t\t\tBold:       highlight,\n\t\t\t\t\tColor:      f32color.Black,\n\t\t\t\t}.Layout(ui.Theme, gtx)\n\t\t\t\ttop += lineHeight\n\t\t\t}\n\t\t}\n\t}\n\tsourceClip.Pop()\n\tsourceContentHeight := top - int(ui.src.scroll)\n\n\t{\n\t\tstack := clip.Rect{\n\t\t\tMin: image.Pt(int(jump.Min)-pad, 0),\n\t\t\tMax: image.Pt(int(asm.Max), gtx.Constraints.Max.Y),\n\t\t}.Push(gtx.Ops)\n\n\t\t// overflow := gtx.Constraints.Max.Y / 3\n\t\toverflow := lineHeight\n\t\tcontentTop := float32(-overflow)\n\t\tcontentBot := float32(len(ui.Code.Insts)*lineHeight + overflow)\n\t\tviewTop := -ui.asm.scroll\n\t\tviewBot := -ui.asm.scroll + float32(gtx.Constraints.Max.Y)\n\n\t\t{\n\t\t\tstack := op.Offset(image.Pt(int(jump.Min)-pad, 0)).Push(gtx.Ops)\n\t\t\tgtx := gtx\n\t\t\tgtx.Constraints = layout.Exact(image.Pt(pad, gtx.Constraints.Max.Y))\n\t\t\tmaterial.Scrollbar(ui.Theme, &ui.asm.bar).Layout(gtx, layout.Vertical,\n\t\t\t\t(viewTop-contentTop)/(contentBot-contentTop),\n\t\t\t\t(viewBot-contentTop)/(contentBot-contentTop),\n\t\t\t)\n\t\t\tstack.Pop()\n\t\t}\n\n\t\tif distance := ui.asm.bar.ScrollDistance(); distance != 0 {\n\t\t\tui.asm.scroll -= distance * (contentBot - contentTop)\n\t\t}\n\t\timage.Rect(0, -1000, 1, 1000)\n\t\tif distance := ui.asm.gesture.Update(gtx.Metric, gtx.Source, gtx.Now, gesture.Vertical,\n\t\t\tpointer.ScrollRange{},\n\t\t\tpointer.ScrollRange{Min: -1000, Max: 1000},\n\t\t); distance != 0 {\n\t\t\tui.asm.scroll -= float32(distance)\n\t\t}\n\n\t\tif -ui.asm.scroll < contentTop {\n\t\t\tui.asm.scroll = -contentTop\n\t\t\tui.asm.anim.Stop()\n\t\t}\n\t\tif -ui.asm.scroll+float32(gtx.Constraints.Max.Y) > contentBot {\n\t\t\tif contentBot < float32(gtx.Constraints.Max.Y) {\n\t\t\t\tui.asm.scroll = -contentTop\n\t\t\t} else {\n\t\t\t\tui.asm.scroll = float32(gtx.Constraints.Max.Y) - contentBot\n\t\t\t}\n\t\t\tui.asm.anim.Stop()\n\t\t}\n\t\tstack.Pop()\n\t}\n\n\t{\n\t\tstack := clip.Rect{\n\t\t\tMin: image.Pt(int(source.Min), 0),\n\t\t\tMax: image.Pt(int(source.Max)+pad, gtx.Constraints.Max.Y),\n\t\t}.Push(gtx.Ops)\n\n\t\t// overflow := gtx.Constraints.Max.Y / 3\n\t\toverflow := lineHeight\n\t\tcontentTop := float32(-overflow)\n\t\tcontentBot := float32(sourceContentHeight + overflow)\n\t\tviewTop := -ui.src.scroll\n\t\tviewBot := -ui.src.scroll + float32(gtx.Constraints.Max.Y)\n\n\t\t{\n\t\t\tstack := op.Offset(image.Pt(int(source.Max), 0)).Push(gtx.Ops)\n\t\t\tgtx := gtx\n\t\t\tgtx.Constraints = layout.Exact(image.Pt(pad, gtx.Constraints.Max.Y))\n\t\t\tmaterial.Scrollbar(ui.Theme, &ui.src.bar).Layout(gtx, layout.Vertical,\n\t\t\t\t(viewTop-contentTop)/(contentBot-contentTop),\n\t\t\t\t(viewBot-contentTop)/(contentBot-contentTop),\n\t\t\t)\n\t\t\tstack.Pop()\n\t\t}\n\n\t\tif distance := ui.src.bar.ScrollDistance(); distance != 0 {\n\t\t\tui.src.scroll -= distance * (contentBot - contentTop)\n\t\t}\n\t\tif distance := ui.src.gesture.Update(gtx.Metric, gtx.Source, gtx.Now, gesture.Vertical,\n\t\t\tpointer.ScrollRange{},\n\t\t\tpointer.ScrollRange{Min: -1000, Max: 1000},\n\t\t); distance != 0 {\n\t\t\tui.src.scroll -= float32(distance)\n\t\t}\n\n\t\tif -ui.src.scroll < contentTop {\n\t\t\tui.src.scroll = -contentTop\n\t\t}\n\t\tif -ui.src.scroll+float32(gtx.Constraints.Max.Y) > contentBot {\n\t\t\tif contentBot < float32(gtx.Constraints.Max.Y) {\n\t\t\t\tui.src.scroll = -contentTop\n\t\t\t} else {\n\t\t\t\tui.src.scroll = float32(gtx.Constraints.Max.Y) - contentBot\n\t\t\t}\n\t\t}\n\t\tstack.Pop()\n\t}\n\n\treturn layout.Dimensions{\n\t\tSize: gtx.Constraints.Max,\n\t}\n}\n"
        },
        {
          "name": "filterlist.go",
          "type": "blob",
          "size": 3.171875,
          "content": "package main\n\nimport (\n\t\"fmt\"\n\t\"regexp\"\n\n\t\"gioui.org/layout\"\n\t\"gioui.org/op\"\n\t\"gioui.org/op/clip\"\n\t\"gioui.org/op/paint\"\n\t\"gioui.org/unit\"\n\t\"gioui.org/widget\"\n\t\"gioui.org/widget/material\"\n)\n\ntype FilterListItem interface {\n\tName() string\n}\n\n// FilterList lists symbols for filtering and selection.\ntype FilterList[T FilterListItem] struct {\n\tAll         []T\n\tFilter      widget.Editor\n\tFilterError string\n\tFiltered    []T\n\n\tSelected     string\n\tSelectedItem T\n\n\tList SelectList\n}\n\n// NewFilterList creates a new list with the specified theme.\nfunc NewFilterList[T FilterListItem](theme *material.Theme) *FilterList[T] {\n\tui := &FilterList[T]{}\n\tui.Filter.SingleLine = true\n\tui.List = NewVerticalSelectList(unit.Dp(theme.TextSize) + 4)\n\treturn ui\n}\n\n// SelectIndex selects the specified item.\nfunc (ui *FilterList[T]) SelectIndex(index int) {\n\tif !InRange(index, len(ui.Filtered)) {\n\t\treturn\n\t}\n\n\tui.List.Selected = index\n\tui.Selected = ui.Filtered[index].Name()\n\tui.SelectedItem = ui.Filtered[index]\n}\n\n// SetItems updates the full list.\nfunc (ui *FilterList[T]) SetItems(all []T) {\n\tui.All = all\n\tui.updateFiltered()\n}\n\n// SetFilter sets the filter.\nfunc (ui *FilterList[T]) SetFilter(filter string) {\n\tui.Filter.SetText(filter)\n\tui.updateFiltered()\n}\n\n// updateFiltered updates the filtered list from the unfiltered content.\nfunc (ui *FilterList[T]) updateFiltered() {\n\tdefer func() {\n\t\tui.List.Selected = -1\n\t\tfor i, item := range ui.Filtered {\n\t\t\tif item.Name() == ui.Selected {\n\t\t\t\tui.List.Selected = i\n\t\t\t\tui.SelectedItem = item\n\t\t\t\t// TODO, maybe scroll into view?\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}()\n\n\trx, err := regexp.Compile(\"(?i)\" + ui.Filter.Text())\n\tui.FilterError = \"\"\n\tif err != nil {\n\t\tui.FilterError = err.Error()\n\t\treturn\n\t}\n\n\tui.Filtered = ui.Filtered[:0]\n\tfor _, item := range ui.All {\n\t\tif rx.MatchString(item.Name()) {\n\t\t\tui.Filtered = append(ui.Filtered, item)\n\t\t}\n\t}\n}\n\n// Layout draws the list.\nfunc (ui *FilterList[T]) Layout(th *material.Theme, gtx layout.Context) layout.Dimensions {\n\tpaint.FillShape(gtx.Ops, secondaryBackground, clip.Rect{Max: gtx.Constraints.Min}.Op())\n\n\tui.SelectIndex(ui.List.Selected)\n\n\tchanged := false\n\tfor {\n\t\tev, ok := ui.Filter.Update(gtx)\n\t\tif !ok {\n\t\t\tbreak\n\t\t}\n\t\tif _, ok := ev.(widget.ChangeEvent); ok {\n\t\t\tchanged = true\n\t\t}\n\t}\n\n\tif changed {\n\t\tui.updateFiltered()\n\t\tgtx.Execute(op.InvalidateCmd{})\n\t}\n\n\treturn layout.Flex{\n\t\tAxis: layout.Vertical,\n\t}.Layout(gtx,\n\t\tlayout.Rigid(func(gtx layout.Context) layout.Dimensions {\n\t\t\treturn FocusBorder(th, gtx.Focused(&ui.Filter)).Layout(gtx,\n\t\t\t\tmaterial.Editor(th, &ui.Filter, \"Filter (regexp)\").Layout)\n\t\t}),\n\t\tlayout.Rigid(func(gtx layout.Context) layout.Dimensions {\n\t\t\tif ui.FilterError == \"\" {\n\t\t\t\treturn layout.Dimensions{}\n\t\t\t}\n\t\t\treturn material.Body1(th, ui.FilterError).Layout(gtx)\n\t\t}),\n\t\tlayout.Flexed(1, func(gtx layout.Context) layout.Dimensions {\n\t\t\treturn ui.List.Layout(th, gtx, len(ui.Filtered),\n\t\t\t\tStringListItem(th, &ui.List, func(index int) string {\n\t\t\t\t\treturn ui.Filtered[index].Name()\n\t\t\t\t}))\n\t\t}),\n\t\tlayout.Rigid(func(gtx layout.Context) layout.Dimensions {\n\t\t\tbody := material.Body1(th, fmt.Sprintf(\"%d / %d\", len(ui.Filtered), len(ui.All)))\n\t\t\tbody.TextSize *= 0.8\n\t\t\treturn layout.Center.Layout(gtx, body.Layout)\n\t\t}),\n\t)\n}\n"
        },
        {
          "name": "focus.go",
          "type": "blob",
          "size": 0.9169921875,
          "content": "package main\n\nimport (\n\t\"image/color\"\n\n\t\"gioui.org/layout\"\n\t\"gioui.org/unit\"\n\t\"gioui.org/widget\"\n\t\"gioui.org/widget/material\"\n)\n\n// FocusBorderStyle implements a styling a focused widget.\ntype FocusBorderStyle struct {\n\tFocused     bool\n\tBorderWidth unit.Dp\n\tColor       color.NRGBA\n}\n\n// FocusBorder creates a focus border for a focused widget.\nfunc FocusBorder(th *material.Theme, focused bool) FocusBorderStyle {\n\treturn FocusBorderStyle{\n\t\tFocused:     focused,\n\t\tBorderWidth: unit.Dp(2),\n\t\tColor:       th.ContrastBg,\n\t}\n}\n\n// Layout adds a focus border and styling.\nfunc (focus FocusBorderStyle) Layout(gtx layout.Context, w layout.Widget) layout.Dimensions {\n\tinset := layout.UniformInset(focus.BorderWidth)\n\tif !focus.Focused {\n\t\treturn inset.Layout(gtx, w)\n\t}\n\n\treturn widget.Border{\n\t\tColor: focus.Color,\n\t\tWidth: focus.BorderWidth,\n\t}.Layout(gtx, func(gtx layout.Context) layout.Dimensions {\n\t\treturn inset.Layout(gtx, w)\n\t})\n}\n"
        },
        {
          "name": "geom.go",
          "type": "blob",
          "size": 0.3642578125,
          "content": "package main\n\ntype Bounds struct{ Min, Max float32 }\n\nfunc BoundsWidth(min, width int) Bounds {\n\treturn Bounds{Min: float32(min), Max: float32(min + width)}\n}\n\nfunc (b Bounds) Width() float32 { return b.Max - b.Min }\n\nfunc (b Bounds) Lerp(p float32) float32 {\n\treturn b.Min + p*(b.Max-b.Min)\n}\n\nfunc (b Bounds) Contains(v float32) bool {\n\treturn b.Min <= v && v <= b.Max\n}\n"
        },
        {
          "name": "go.mod",
          "type": "blob",
          "size": 0.5341796875,
          "content": "module loov.dev/lensm\n\ngo 1.23.0\n\nrequire (\n\tgioui.org v0.7.1\n\tgithub.com/tetratelabs/wabin v0.0.0-20230304001439-f6f874872834\n\tgolang.org/x/arch v0.2.0\n\tgolang.org/x/exp v0.0.0-20240707233637-46b078467d37\n\tgolang.org/x/exp/shiny v0.0.0-20240707233637-46b078467d37\n)\n\nrequire (\n\tgioui.org/cpu v0.0.0-20210817075930-8d6a761490d2 // indirect\n\tgioui.org/shader v1.0.8 // indirect\n\tgithub.com/go-text/typesetting v0.1.1 // indirect\n\tgolang.org/x/image v0.18.0 // indirect\n\tgolang.org/x/sys v0.22.0 // indirect\n\tgolang.org/x/text v0.16.0 // indirect\n)\n"
        },
        {
          "name": "go.sum",
          "type": "blob",
          "size": 3.1025390625,
          "content": "eliasnaur.com/font v0.0.0-20230308162249-dd43949cb42d h1:ARo7NCVvN2NdhLlJE9xAbKweuI9L6UgfTbYb0YwPacY=\neliasnaur.com/font v0.0.0-20230308162249-dd43949cb42d/go.mod h1:OYVuxibdk9OSLX8vAqydtRPP87PyTFcT9uH3MlEGBQA=\ngioui.org v0.7.1 h1:l7OVj47n1z8acaszQ6Wlu+Rxme+HqF3q8b+Fs68+x3w=\ngioui.org v0.7.1/go.mod h1:5Kw/q7R1BWc5MKStuTNvhCgSrRqbfHc9Dzfjs4IGgZo=\ngioui.org/cpu v0.0.0-20210808092351-bfe733dd3334/go.mod h1:A8M0Cn5o+vY5LTMlnRoK3O5kG+rH0kWfJjeKd9QpBmQ=\ngioui.org/cpu v0.0.0-20210817075930-8d6a761490d2 h1:AGDDxsJE1RpcXTAxPG2B4jrwVUJGFDjINIPi1jtO6pc=\ngioui.org/cpu v0.0.0-20210817075930-8d6a761490d2/go.mod h1:A8M0Cn5o+vY5LTMlnRoK3O5kG+rH0kWfJjeKd9QpBmQ=\ngioui.org/shader v1.0.8 h1:6ks0o/A+b0ne7RzEqRZK5f4Gboz2CfG+mVliciy6+qA=\ngioui.org/shader v1.0.8/go.mod h1:mWdiME581d/kV7/iEhLmUgUK5iZ09XR5XpduXzbePVM=\ngithub.com/davecgh/go-spew v1.1.1 h1:vj9j/u1bqnvCEfJOwUhtlOARqs3+rkHYY13jYWTU97c=\ngithub.com/davecgh/go-spew v1.1.1/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=\ngithub.com/go-text/typesetting v0.1.1 h1:bGAesCuo85nXnEN5LmFMVGAGpGkCPtHrZLi//qD7EJo=\ngithub.com/go-text/typesetting v0.1.1/go.mod h1:d22AnmeKq/on0HNv73UFriMKc4Ez6EqZAofLhAzpSzI=\ngithub.com/go-text/typesetting-utils v0.0.0-20231211103740-d9332ae51f04 h1:zBx+p/W2aQYtNuyZNcTfinWvXBQwYtDfme051PR/lAY=\ngithub.com/go-text/typesetting-utils v0.0.0-20231211103740-d9332ae51f04/go.mod h1:DDxDdQEnB70R8owOx3LVpEFvpMK9eeH1o2r0yZhFI9o=\ngithub.com/pmezard/go-difflib v1.0.0 h1:4DBwDE0NGyQoBHbLQYPwSUPoCMWR5BEzIk/f1lZbAQM=\ngithub.com/pmezard/go-difflib v1.0.0/go.mod h1:iKH77koFhYxTK1pcRnkKkqfTogsbg7gZNVY4sRDYZ/4=\ngithub.com/stretchr/testify v1.8.0 h1:pSgiaMZlXftHpm5L7V1+rVB+AZJydKsMxsQBIJw4PKk=\ngithub.com/stretchr/testify v1.8.0/go.mod h1:yNjHg4UonilssWZ8iaSj1OCr/vHnekPRkoO+kdMU+MU=\ngithub.com/tetratelabs/wabin v0.0.0-20230304001439-f6f874872834 h1:ZF+QBjOI+tILZjBaFj3HgFonKXUcwgJ4djLb6i42S3Q=\ngithub.com/tetratelabs/wabin v0.0.0-20230304001439-f6f874872834/go.mod h1:m9ymHTgNSEjuxvw8E7WWe4Pl4hZQHXONY8wE6dMLaRk=\ngolang.org/x/arch v0.2.0 h1:W1sUEHXiJTfjaFJ5SLo0N6lZn+0eO5gWD1MFeTGqQEY=\ngolang.org/x/arch v0.2.0/go.mod h1:5om86z9Hs0C8fWVUuoMHwpExlXzs5Tkyp9hOrfG7pp8=\ngolang.org/x/exp v0.0.0-20240707233637-46b078467d37 h1:uLDX+AfeFCct3a2C7uIWBKMJIR3CJMhcgfrUAqjRK6w=\ngolang.org/x/exp v0.0.0-20240707233637-46b078467d37/go.mod h1:M4RDyNAINzryxdtnbRXRL/OHtkFuWGRjvuhBJpk2IlY=\ngolang.org/x/exp/shiny v0.0.0-20240707233637-46b078467d37 h1:SOSg7+sueresE4IbmmGM60GmlIys+zNX63d6/J4CMtU=\ngolang.org/x/exp/shiny v0.0.0-20240707233637-46b078467d37/go.mod h1:3F+MieQB7dRYLTmnncoFbb1crS5lfQoTfDgQy6K4N0o=\ngolang.org/x/image v0.18.0 h1:jGzIakQa/ZXI1I0Fxvaa9W7yP25TqT6cHIHn+6CqvSQ=\ngolang.org/x/image v0.18.0/go.mod h1:4yyo5vMFQjVjUcVk4jEQcU9MGy/rulF5WvUILseCM2E=\ngolang.org/x/sys v0.22.0 h1:RI27ohtqKCnwULzJLqkv897zojh5/DwS/ENaMzUOaWI=\ngolang.org/x/sys v0.22.0/go.mod h1:/VUhepiaJMQUp4+oa/7Zr1D23ma6VTLIYjOOTFZPUcA=\ngolang.org/x/text v0.16.0 h1:a94ExnEXNtEwYLGJSIUxnWoxoRz/ZcCsV63ROupILh4=\ngolang.org/x/text v0.16.0/go.mod h1:GhwF1Be+LQoKShO3cGOHzqOgRrGaYc9AvblQOmPVHnI=\ngopkg.in/yaml.v3 v3.0.1 h1:fxVm/GzAzEWqLHuvctI91KS9hhNmmWOoWu0XTYJS7CA=\ngopkg.in/yaml.v3 v3.0.1/go.mod h1:K4uyk7z7BCEPqu6E+C64Yfv1cQ7kz7rIZviUmN+EgEM=\n"
        },
        {
          "name": "icons.go",
          "type": "blob",
          "size": 0.2548828125,
          "content": "package main\n\nimport (\n\t\"gioui.org/widget\"\n\t\"golang.org/x/exp/shiny/materialdesign/icons\"\n)\n\n// OpenInNewIcon is used for opening Code in a new window.\nvar OpenInNewIcon = func() *widget.Icon {\n\ticon, _ := widget.NewIcon(icons.ActionOpenInNew)\n\treturn icon\n}()\n"
        },
        {
          "name": "internal",
          "type": "tree",
          "content": null
        },
        {
          "name": "main.go",
          "type": "blob",
          "size": 1.560546875,
          "content": "package main\n\nimport (\n\t\"flag\"\n\t\"fmt\"\n\t\"image\"\n\t\"image/color\"\n\t\"log\"\n\t\"os\"\n\t\"runtime/pprof\"\n\n\t\"gioui.org/app\"\n\t\"gioui.org/text\"\n\t\"gioui.org/unit\"\n\t\"gioui.org/widget/material\"\n)\n\nfunc main() {\n\tcpuprofile := flag.String(\"cpuprofile\", \"\", \"enable cpu profiling\")\n\ttextSize := flag.Int(\"text-size\", 12, \"default font size\")\n\tfilter := flag.String(\"filter\", \"\", \"filter the functions by regexp\")\n\twatch := flag.Bool(\"watch\", false, \"auto reload executable\")\n\tcontext := flag.Int(\"context\", 3, \"source line context\")\n\tfont := flag.String(\"font\", \"\", \"user font\")\n\n\tworkInProgressWASM = os.Getenv(\"LENSM_EXPERIMENT_WASM\") != \"\"\n\n\tflag.Parse()\n\texePath := flag.Arg(0)\n\n\tif exePath == \"\" {\n\t\tfmt.Fprintln(os.Stderr, \"lensm <exePath>\")\n\t\tflag.Usage()\n\t\tos.Exit(1)\n\t}\n\n\twindows := &Windows{}\n\n\ttheme := material.NewTheme()\n\ttheme.Shaper = text.NewShaper(text.WithCollection(LoadFonts(*font)))\n\ttheme.TextSize = unit.Sp(*textSize)\n\n\tui := NewExeUI(windows, theme)\n\tui.Config = FileUIConfig{\n\t\tPath:    exePath,\n\t\tWatch:   *watch,\n\t\tContext: *context,\n\t}\n\tui.Funcs.SetFilter(*filter)\n\n\twindows.Open(\"lensm\", image.Pt(1400, 900), ui.Run)\n\n\tgo func() {\n\t\tprofile(*cpuprofile, windows.Wait)\n\t\tos.Exit(0)\n\t}()\n\n\t// This starts Gio main.\n\tapp.Main()\n}\n\nvar (\n\tsecondaryBackground = color.NRGBA{R: 0xF0, G: 0xF0, B: 0xF0, A: 0xFF}\n\tsplitterColor       = color.NRGBA{R: 0x80, G: 0x80, B: 0x80, A: 0xFF}\n)\n\nfunc profile(cpuprofile string, fn func()) {\n\tif cpuprofile != \"\" {\n\t\tf, err := os.Create(cpuprofile)\n\t\tif err != nil {\n\t\t\tlog.Fatal(err)\n\t\t}\n\t\tpprof.StartCPUProfile(f)\n\t\tdefer pprof.StopCPUProfile()\n\t}\n\tfn()\n}\n"
        },
        {
          "name": "screenshot.gif",
          "type": "blob",
          "size": 180.2626953125,
          "content": null
        },
        {
          "name": "selectlist.go",
          "type": "blob",
          "size": 5.1279296875,
          "content": "package main\n\nimport (\n\t\"image\"\n\t\"image/color\"\n\n\t\"gioui.org/f32\"\n\t\"gioui.org/font\"\n\t\"gioui.org/io/event\"\n\t\"gioui.org/io/key\"\n\t\"gioui.org/io/pointer\"\n\t\"gioui.org/layout\"\n\t\"gioui.org/op\"\n\t\"gioui.org/op/clip\"\n\t\"gioui.org/op/paint\"\n\t\"gioui.org/unit\"\n\t\"gioui.org/widget\"\n\t\"gioui.org/widget/material\"\n)\n\n// NewVerticalSelectList creates a new select list with the specified item height.\nfunc NewVerticalSelectList(itemHeight unit.Dp) SelectList {\n\treturn SelectList{\n\t\tList: widget.List{\n\t\t\tList: layout.List{\n\t\t\t\tAxis: layout.Vertical,\n\t\t\t},\n\t\t},\n\t\tItemHeight: itemHeight,\n\t}\n}\n\n// SelectList draws a list where items can be selected.\ntype SelectList struct {\n\twidget.List\n\n\tSelected int\n\tHovered  int\n\n\tItemHeight unit.Dp\n}\n\n// Layout draws the list.\nfunc (list *SelectList) Layout(th *material.Theme, gtx layout.Context, length int, element layout.ListElement) layout.Dimensions {\n\treturn FocusBorder(th, gtx.Focused(list)).Layout(gtx, func(gtx layout.Context) layout.Dimensions {\n\t\tsize := gtx.Constraints.Max\n\t\tgtx.Constraints = layout.Exact(size)\n\t\tdefer clip.Rect{Max: size}.Push(gtx.Ops).Pop()\n\n\t\tevent.Op(gtx.Ops, list)\n\n\t\tchanged := false\n\t\tgrabbed := false\n\n\t\titemHeight := gtx.Metric.Dp(list.ItemHeight)\n\t\tif itemHeight == 0 {\n\t\t\titemHeight = gtx.Metric.Sp(th.TextSize)\n\t\t}\n\n\t\tpointerClicked := false\n\t\tpointerHovered := false\n\t\tpointerPosition := f32.Point{}\n\t\tfor {\n\t\t\t// TODO: fix navigation when in filter.\n\t\t\tev, ok := gtx.Event(\n\t\t\t\tkey.FocusFilter{Target: list},\n\t\t\t\tkey.Filter{Focus: list, Name: key.NameUpArrow},\n\t\t\t\tkey.Filter{Focus: list, Name: key.NameDownArrow},\n\t\t\t\tkey.Filter{Focus: list, Name: key.NameHome},\n\t\t\t\tkey.Filter{Focus: list, Name: key.NameEnd},\n\t\t\t\tkey.Filter{Focus: list, Name: key.NamePageUp},\n\t\t\t\tkey.Filter{Focus: list, Name: key.NamePageDown},\n\t\t\t\tpointer.Filter{\n\t\t\t\t\tTarget: list,\n\t\t\t\t\tKinds:  pointer.Press | pointer.Move,\n\t\t\t\t},\n\t\t\t)\n\t\t\tif !ok {\n\t\t\t\tbreak\n\t\t\t}\n\n\t\t\tswitch ev := ev.(type) {\n\t\t\tcase key.Event:\n\t\t\t\tif ev.State == key.Press {\n\t\t\t\t\toffset := 0\n\t\t\t\t\tswitch ev.Name {\n\t\t\t\t\tcase key.NameHome:\n\t\t\t\t\t\toffset = -length\n\t\t\t\t\tcase key.NameEnd:\n\t\t\t\t\t\toffset = length\n\t\t\t\t\tcase key.NameUpArrow:\n\t\t\t\t\t\toffset = -1\n\t\t\t\t\tcase key.NameDownArrow:\n\t\t\t\t\t\toffset = 1\n\t\t\t\t\tcase key.NamePageUp:\n\t\t\t\t\t\toffset = -list.List.Position.Count\n\t\t\t\t\tcase key.NamePageDown:\n\t\t\t\t\t\toffset = list.List.Position.Count\n\t\t\t\t\t}\n\n\t\t\t\t\tif offset != 0 {\n\t\t\t\t\t\ttarget := list.Selected + offset\n\t\t\t\t\t\tif target < 0 {\n\t\t\t\t\t\t\ttarget = 0\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif target >= length {\n\t\t\t\t\t\t\ttarget = length - 1\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif list.Selected != target {\n\t\t\t\t\t\t\tlist.Selected = target\n\t\t\t\t\t\t\tchanged = true\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// if we get input and don't have a focus, then grab it\n\t\t\t\t\tif !gtx.Focused(list) {\n\t\t\t\t\t\tgtx.Execute(op.InvalidateCmd{})\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\tcase pointer.Event:\n\t\t\t\tswitch ev.Kind {\n\t\t\t\tcase pointer.Press:\n\t\t\t\t\tif !gtx.Focused(list) && !grabbed {\n\t\t\t\t\t\tgrabbed = true\n\t\t\t\t\t\tgtx.Execute(key.FocusCmd{Tag: list})\n\t\t\t\t\t}\n\t\t\t\t\tpointerClicked = true\n\t\t\t\t\tpointerPosition = ev.Position\n\t\t\t\tcase pointer.Move:\n\t\t\t\t\tpointerHovered = true\n\t\t\t\t\tpointerPosition = ev.Position\n\t\t\t\tcase pointer.Cancel:\n\t\t\t\t\tlist.Hovered = -1\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif pointerClicked || pointerHovered {\n\t\t\t// TODO: make this independent of fixed item height\n\t\t\tclientClickY := list.Position.First*itemHeight + list.Position.Offset + int(pointerPosition.Y)\n\t\t\ttarget := clientClickY / itemHeight\n\t\t\tif 0 <= target && target <= length {\n\t\t\t\tif pointerClicked && list.Selected != target {\n\t\t\t\t\tlist.Selected = target\n\t\t\t\t}\n\t\t\t\tif pointerHovered && list.Hovered != target {\n\t\t\t\t\tlist.Hovered = target\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif changed {\n\t\t\tpos := &list.List.Position\n\t\t\tswitch {\n\t\t\tcase list.Selected < pos.First+1:\n\t\t\t\tlist.List.Position = layout.Position{First: list.Selected - 1}\n\t\t\tcase pos.First+pos.Count-1 <= list.Selected:\n\t\t\t\tlist.List.Position = layout.Position{First: list.Selected - pos.Count + 2}\n\t\t\t}\n\t\t}\n\n\t\tstyle := material.List(th, &list.List)\n\t\tstyle.AnchorStrategy = material.Overlay\n\t\treturn style.Layout(gtx, length,\n\t\t\tfunc(gtx layout.Context, index int) layout.Dimensions {\n\t\t\t\tgtx.Constraints = layout.Exact(image.Point{\n\t\t\t\t\tX: gtx.Constraints.Max.X,\n\t\t\t\t\tY: itemHeight,\n\t\t\t\t})\n\t\t\t\treturn element(gtx, index)\n\t\t\t})\n\t})\n}\n\n// StringListItem creates a string item drawer that reacts to hover and selection.\nfunc StringListItem(th *material.Theme, state *SelectList, item func(int) string) layout.ListElement {\n\treturn func(gtx layout.Context, index int) layout.Dimensions {\n\t\tdefer clip.Rect{Max: gtx.Constraints.Max}.Push(gtx.Ops).Pop()\n\n\t\tbg := color.NRGBA{}\n\t\tfg := th.Fg\n\t\tweight := font.Normal\n\n\t\tswitch {\n\t\tcase state.Selected == index:\n\t\t\tif gtx.Focused(state) {\n\t\t\t\tbg = th.ContrastBg\n\t\t\t\tfg = th.ContrastFg\n\t\t\t}\n\t\t\tweight = font.Black\n\t\tcase state.Hovered == index:\n\t\t\tbg = th.ContrastBg\n\t\t\tbg.A /= 4\n\t\t}\n\n\t\tif bg != (color.NRGBA{}) {\n\t\t\tpaint.Fill(gtx.Ops, bg)\n\t\t}\n\t\tinset := layout.Inset{Top: 1, Right: 4, Bottom: 1, Left: 4}\n\t\treturn inset.Layout(gtx, func(gtx layout.Context) layout.Dimensions {\n\t\t\tlabel := material.Body1(th, item(index))\n\t\t\tlabel.Color = fg\n\t\t\tlabel.MaxLines = 1\n\t\t\tlabel.TextSize = th.TextSize * 8 / 10\n\t\t\tlabel.Font.Weight = weight\n\t\t\tgtx.Constraints.Max.X = maxLineWidth\n\t\t\treturn label.Layout(gtx)\n\t\t})\n\t}\n}\n"
        },
        {
          "name": "testdata",
          "type": "tree",
          "content": null
        },
        {
          "name": "util.go",
          "type": "blob",
          "size": 0.1650390625,
          "content": "package main\n\nconst maxLineWidth = 10 * 1024\n\n// InRange checks whether v is in bounds for length.\nfunc InRange(v int, length int) bool {\n\treturn 0 <= v && v < length\n}\n"
        },
        {
          "name": "widgets.go",
          "type": "blob",
          "size": 2.7265625,
          "content": "package main\n\nimport (\n\t\"image\"\n\t\"image/color\"\n\t\"time\"\n\n\t\"gioui.org/font\"\n\t\"gioui.org/layout\"\n\t\"gioui.org/op\"\n\t\"gioui.org/op/clip\"\n\t\"gioui.org/op/paint\"\n\t\"gioui.org/unit\"\n\t\"gioui.org/widget\"\n\t\"gioui.org/widget/material\"\n)\n\n// SourceLine is a single-line of text.\ntype SourceLine struct {\n\tTopLeft    image.Point\n\tWidth      int\n\tText       string\n\tTextHeight unit.Sp\n\tItalic     bool\n\tBold       bool\n\tColor      color.NRGBA\n}\n\n// Layout draws the text.\nfunc (line SourceLine) Layout(th *material.Theme, gtx layout.Context) {\n\tgtx.Constraints.Min.X = 0\n\tgtx.Constraints.Max.X = maxLineWidth\n\tgtx.Constraints.Min.Y = 0\n\tgtx.Constraints.Max.Y = maxLineWidth\n\n\tdefer op.Offset(line.TopLeft).Push(gtx.Ops).Pop()\n\tif line.Width > 0 {\n\t\tmaxSize := image.Pt(line.Width, gtx.Metric.Sp(line.TextHeight))\n\t\tdefer clip.Rect{Max: maxSize}.Push(gtx.Ops).Pop()\n\t}\n\n\tf := font.Font{Typeface: \"override-monospace,Go,monospace\", Weight: font.Normal}\n\tif line.Italic {\n\t\tf.Style = font.Italic\n\t}\n\tif line.Bold {\n\t\tf.Weight = font.Black\n\t}\n\tpaint.ColorOp{Color: line.Color}.Add(gtx.Ops)\n\twidget.Label{MaxLines: 1}.Layout(gtx, th.Shaper, f, line.TextHeight, line.Text, op.CallOp{})\n}\n\ntype VerticalLine struct {\n\tWidth unit.Dp\n\tColor color.NRGBA\n}\n\nfunc (line VerticalLine) Layout(gtx layout.Context) layout.Dimensions {\n\tsize := image.Point{\n\t\tX: gtx.Metric.Dp(line.Width),\n\t\tY: gtx.Constraints.Min.Y,\n\t}\n\tpaint.FillShape(gtx.Ops, line.Color, clip.Rect{Max: size}.Op())\n\treturn layout.Dimensions{\n\t\tSize: size,\n\t}\n}\n\ntype HorizontalLine struct {\n\tHeight unit.Dp\n\tColor  color.NRGBA\n}\n\nfunc (line HorizontalLine) Layout(gtx layout.Context) layout.Dimensions {\n\tsize := image.Point{\n\t\tX: gtx.Constraints.Min.X,\n\t\tY: gtx.Metric.Dp(line.Height),\n\t}\n\tpaint.FillShape(gtx.Ops, line.Color, clip.Rect{Max: size}.Op())\n\treturn layout.Dimensions{\n\t\tSize: size,\n\t}\n}\n\ntype ScrollAnimation struct {\n\tactive   bool\n\tfrom, to float32\n\tduration time.Duration\n\tstart    time.Time\n}\n\nfunc (anim *ScrollAnimation) Start(gtx layout.Context, from, to float32, duration time.Duration) {\n\tanim.active = true\n\tanim.from = from\n\tanim.to = to\n\tanim.duration = duration\n\tanim.start = gtx.Now\n\tgtx.Execute(op.InvalidateCmd{})\n}\n\nfunc (anim *ScrollAnimation) Stop() { anim.active = false }\n\nfunc (anim *ScrollAnimation) Update(gtx layout.Context) (float32, bool) {\n\tif !anim.active {\n\t\treturn anim.to, false\n\t}\n\tgtx.Execute(op.InvalidateCmd{})\n\n\telapsed := gtx.Now.Sub(anim.start)\n\tif elapsed > anim.duration {\n\t\tanim.active = false\n\t\treturn anim.to, true\n\t}\n\n\tprogress := float32(elapsed) / float32(anim.duration)\n\tprogress = easeInOutCubic(progress)\n\n\tpos := anim.from + progress*(anim.to-anim.from)\n\treturn pos, true\n}\n\nfunc easeInOutCubic(t float32) float32 {\n\tif t < .5 {\n\t\treturn 4 * t * t * t\n\t}\n\treturn (t-1)*(2*t-2)*(2*t-2) + 1\n}\n"
        },
        {
          "name": "windows.go",
          "type": "blob",
          "size": 1.458984375,
          "content": "package main\n\nimport (\n\t\"fmt\"\n\t\"image\"\n\t\"log\"\n\t\"os\"\n\t\"sync\"\n\n\t\"gioui.org/app\"\n\t\"gioui.org/font\"\n\t\"gioui.org/font/gofont\"\n\t\"gioui.org/font/opentype\"\n\t\"gioui.org/layout\"\n\t\"gioui.org/op\"\n\t\"gioui.org/unit\"\n)\n\ntype Windows struct {\n\tactive sync.WaitGroup\n}\n\nfunc (windows *Windows) Open(title string, sizeDp image.Point, run func(*app.Window) error) {\n\twindows.active.Add(1)\n\tgo func() {\n\t\tdefer windows.active.Done()\n\n\t\twindow := new(app.Window)\n\t\twindow.Option(\n\t\t\tapp.Title(title),\n\t\t\tapp.Size(unit.Dp(sizeDp.X), unit.Dp(sizeDp.Y)),\n\t\t)\n\t\tif err := run(window); err != nil {\n\t\t\tlog.Println(err)\n\t\t}\n\t}()\n}\n\nfunc (windows *Windows) Wait() {\n\twindows.active.Wait()\n}\n\nfunc WidgetWindow(widget layout.Widget) func(*app.Window) error {\n\treturn func(w *app.Window) error {\n\t\tvar ops op.Ops\n\t\tfor {\n\t\t\te := w.Event()\n\t\t\tswitch e := e.(type) {\n\t\t\tcase app.FrameEvent:\n\t\t\t\tgtx := app.NewContext(&ops, e)\n\t\t\t\twidget(gtx)\n\t\t\t\te.Frame(gtx.Ops)\n\n\t\t\tcase app.DestroyEvent:\n\t\t\t\treturn e.Err\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc LoadFonts(userfont string) []font.FontFace {\n\tcollection := gofont.Collection()\n\tif userfont == \"\" {\n\t\treturn collection\n\t}\n\tb, err := os.ReadFile(userfont)\n\tif err != nil {\n\t\tpanic(fmt.Errorf(\"failed to parse font: %v\", err))\n\t}\n\tface, err := opentype.Parse(b)\n\tif err != nil {\n\t\tpanic(fmt.Errorf(\"failed to parse font: %v\", err))\n\t}\n\tfnt := font.Font{Typeface: \"override-monospace,monospace\", Weight: font.Normal}\n\tfface := font.FontFace{Font: fnt, Face: face}\n\treturn append(collection, fface)\n}\n"
        }
      ]
    }
  ]
}