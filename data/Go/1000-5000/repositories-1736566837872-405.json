{
  "metadata": {
    "timestamp": 1736566837872,
    "page": 405,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjQxMA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "itchyny/gojq",
      "stars": 3387,
      "defaultBranch": "main",
      "files": [
        {
          "name": ".dockerignore",
          "type": "blob",
          "size": 0.1181640625,
          "content": "/gojq\n/goxz\n/CREDITS\n/y.output\n*.exe\n*.test\n*.out\n*.md\n*.y\n**/*.jq\n**/*.json\n**/*.yaml\n**/*_test.go\n.github\n_gojq\n_tools\n"
        },
        {
          "name": ".gitattributes",
          "type": "blob",
          "size": 0.111328125,
          "content": "**/testdata/** binary\n/builtin.go    eol=lf linguist-generated=true\n/parser.go     eol=lf linguist-generated=true\n"
        },
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.048828125,
          "content": "/gojq\n/goxz\n/CREDITS\n/y.output\n*.exe\n*.test\n*.out\n"
        },
        {
          "name": "CHANGELOG.md",
          "type": "blob",
          "size": 22.1484375,
          "content": "# Changelog\n## [v0.12.17](https://github.com/itchyny/gojq/compare/v0.12.16..v0.12.17) (2024-12-01)\n* implement `add/1`, `skip/2` functions\n* implement `--library-path` option as the alias of `-L` option\n* fix `reduce` syntax to emit results for each initial value\n* fix `last/1` to yield no values when the argument yields no values\n* fix `limit/2` to emit an error on negative count\n* fix `@uri` and `@urid` formats not to convert space between plus sign\n* fix resolving search paths of import statements in the query\n* improve time functions to accept fewer element arrays\n\n## [v0.12.16](https://github.com/itchyny/gojq/compare/v0.12.15..v0.12.16) (2024-06-01)\n* fix offset of query parsing error on multi-byte characters\n* fix tests of `exp10` and `atan2` failing on some platforms\n* fix `debug/1` to be available only when `debug/0` is defined\n* improve parser to allow binary operators as object values\n* improve compiler to emit error if query is missing\n\n## [v0.12.15](https://github.com/itchyny/gojq/compare/v0.12.14..v0.12.15) (2024-04-01)\n* implement `ltrim`, `rtrim`, and `trim` functions\n* implement `gojq.ParseError` for getting the offset and token of query parsing error\n* implement `gojq.HaltError` for detecting halt errors and stopping outer iteration\n* fix object construction with duplicate keys (`{x:0,y:1} | {a:.x,a:.y}`)\n* fix `halt` and `halt_error` functions to stop the command execution immediately\n* fix variable scope of binding syntax (`\"a\" as $v | def f: $v; \"b\" as $v | f`)\n* fix pre-defined variables to be available in initial modules (`$ARGS` in `~/.jq`)\n* fix `ltrimstr` and `rtrimstr` functions to emit error on non-string input\n* fix `nearbyint` and `rint` functions to round ties to even\n* improve parser to allow `reduce`, `foreach`, `if`, `try`-`catch` syntax as object values\n* remove `pow10` in favor of `exp10`, define `scalbn` and `scalbln` by `ldexp`\n\n## [v0.12.14](https://github.com/itchyny/gojq/compare/v0.12.13..v0.12.14) (2023-12-01)\n* implement `abs`, `pick`, and `debug/1` functions\n* implement `--raw-output0` option, and remove `--nul-output` (`-0`) option\n* fix string multiplication by zero to emit an empty string\n* fix zero divided by zero to emit an error, not `nan`\n* fix modulo operator to emit `nan` if either side is `nan`\n* fix `implode` function to emit replacement characters on invalid code points\n* fix `stderr` function to output strings in raw format\n* fix `error` function to throw an error even for `null`\n* fix `walk` function on multiple outputs arguments\n* fix `--from-file` option to work with `--args` and `--jsonargs` options\n* fix the default module search path `../lib` relative to the executable\n* improve query parser to support comment continuation with backslash\n* improve `modulemeta` function to include defined function names in the module\n* improve search path of `import` and `include` directives to support `$ORIGIN` expansion\n* remove deprecated `leaf_paths` function\n\n## [v0.12.13](https://github.com/itchyny/gojq/compare/v0.12.12..v0.12.13) (2023-06-01)\n* implement `@urid` format string to decode URI values\n* fix functions returning arrays not to emit nil slices (`flatten`, `group_by`,\n  `unique`, `unique_by`, `nth`, `indices`, `path`, and `modulemeta.deps`)\n\n## [v0.12.12](https://github.com/itchyny/gojq/compare/v0.12.11..v0.12.12) (2023-03-01)\n* fix assignment operator (`=`) with overlapping paths and multiple values (`[[]] | .. = ..`)\n* fix crash on multiplying large numbers to an empty string (`9223372036854775807 * \"\"`)\n* improve zsh completion file\n\n## [v0.12.11](https://github.com/itchyny/gojq/compare/v0.12.10..v0.12.11) (2022-12-24)\n* fix crash on assignment operator (`=`) with multiple values (`. = (0,0)`)\n* fix `isnormal` and `normals` functions against subnormal numbers\n\n## [v0.12.10](https://github.com/itchyny/gojq/compare/v0.12.9..v0.12.10) (2022-12-01)\n* fix `break` in `try`-`catch` query (`label $x | try break $x catch .`)\n* fix path value validation for `getpath` function (`path(getpath([[0]][0]))`)\n* fix path value validation for custom iterator functions\n* fix `walk` function with argument emitting multiple values (`[1],{x:1} | walk(.,0)`)\n* fix `@csv`, `@tsv`, `@sh` to escape the null character (`[\"\\u0000\"] | @csv,@tsv,@sh`)\n* improve performance of assignment operator (`=`), update-assignment operator (`|=`),\n  `map_values`, `del`, `delpaths`, `walk`, `ascii_downcase`, and `ascii_upcase` functions\n\n## [v0.12.9](https://github.com/itchyny/gojq/compare/v0.12.8..v0.12.9) (2022-09-01)\n* fix `fromjson` to emit error on unexpected trailing string\n* fix path analyzer on variable argument evaluation (`def f($x): .y; path(f(.x))`)\n* fix raw input option `--raw-input` (`-R`) to keep carriage returns and support 64KiB+ lines\n\n## [v0.12.8](https://github.com/itchyny/gojq/compare/v0.12.7..v0.12.8) (2022-06-01)\n* implement `gojq.Compare` for comparing values in custom internal functions\n* implement `gojq.TypeOf` for obtaining type name of values in custom internal functions\n* implement `gojq.Preview` for previewing values for error messages of custom internal functions\n* fix query lexer to parse string literals as JSON to support surrogate pairs (`\"\\ud83d\\ude04\"`)\n* fix priority bug of declared and builtin functions (`def empty: .; null | select(.)`)\n* fix string indexing by index out of bounds to emit `null` (`\"abc\" | .[3]`)\n* fix array binding pattern not to match against strings (`\"abc\" as [$a] ?// $a | $a`)\n* fix `sub` and `gsub` functions to emit results in the same order of jq\n* fix `fromjson` to keep integer precision (`\"10000000000000000\" | fromjson + 1`)\n* fix stream option to raise error against incomplete JSON input\n* improve array updating index and string repetition to increase limitations\n* improve `mktime` to support nanoseconds, just like `gmtime` and `now`\n* improve query lexer to report unterminated string literals\n* improve performance of string indexing and slicing by reducing allocations\n* improve performance of object and array indexing, slicing, and iteration,\n  by validating path values by comparing data addresses. This change improves jq\n  compatibility of path value validation (`{} | {}.x = 0`, `[0] | [.[]][] = 1`).\n  Also optimize constant indexing and slicing by specialized instruction\n* improve performance of `add` (on array of strings), `flatten`, `min`, `max`,\n  `sort`, `unique`, `join`, `to_entries`, `from_entries`, `indices`, `index`,\n  `rindex`, `startswith`, `endswith`, `ltrimstr`, `rtrimstr`, `explode`,\n  `capture`, `sub`, and `gsub` functions\n\n## [v0.12.7](https://github.com/itchyny/gojq/compare/v0.12.6..v0.12.7) (2022-03-01)\n* fix precedence of try expression against operators (`try 0 * error(0)`)\n* fix iterator suffix with optional operator (`0 | .x[]?`)\n* fix stream option with slurp option or `input`, `inputs` functions\n* fix the command flag parser to support equal sign in short options with argument\n* fix string conversion of query including empty strings in module and import metadata\n* improve performance of `isempty` function\n\n## [v0.12.6](https://github.com/itchyny/gojq/compare/v0.12.5..v0.12.6) (2021-12-01)\n* implement options for consuming remaining arguments (`--args`, `--jsonargs`, `$ARGS.positional`)\n* fix `delpaths` function with overlapped paths\n* fix `--exit-status` flag with `halt`, `halt_error` functions\n* fix `input_filename` function with null input option\n* fix path value validation for `nan`\n* fix crash on branch optimization (`if 0 then . else 0|0 end`)\n* add validation on regular expression flags to reject unsupported ones\n* improve performance of `range`, `join`, `flatten` functions\n* improve constant value optimization for object with quoted keys\n* remove dependency on forked `go-flags` package\n\n## [v0.12.5](https://github.com/itchyny/gojq/compare/v0.12.4..v0.12.5) (2021-09-01)\n* implement `input_filename` function for the command\n* fix priority bug of declared functions and arguments (`def g: 1; def f(g): g; f(2)`)\n* fix label handling to catch the correct break error (`first((0, 0) | first(0))`)\n* fix `null|error` and `error(null)` to behave like `empty` (`null | [0, error, error(null), 1]`)\n* fix integer division to keep precision when divisible (`1 / 1 * 1000000000000000000000`)\n* fix modulo operator on negative number and large number (`(-1) % 10000000000`)\n* fix combination of slurp (`--slurp`) and raw input option (`--raw-input`) to keep newlines\n* change the default module paths to `~/.jq`, `$ORIGIN/../lib/gojq`, `$ORIGIN/lib`\n  where `$ORIGIN` is the directory where the executable is located in\n* improve command argument parser to recognize query with leading hyphen,\n  allow hyphen for standard input, and force posix style on Windows\n* improve `@base64d` to allow input without padding characters\n* improve `fromdate`, `fromdateiso8601` to parse date time strings with timezone offset\n* improve `halt_error` to print error values without prefix\n* improve `sub`, `gsub` to allow the replacement string emitting multiple values\n* improve encoding `\\b` and `\\f` in strings\n* improve module loader for search path in query, and absolute path\n* improve query lexer to support string literal including newlines\n* improve performance of `index`, `rindex`, `indices`, `transpose`, and `walk` functions\n* improve performance of value preview in errors and debug mode\n* improve runtime performance including tail call optimization\n* switch Docker base image to `distroless/static:debug`\n\n## [v0.12.4](https://github.com/itchyny/gojq/compare/v0.12.3..v0.12.4) (2021-06-01)\n* fix numeric conversion of large floating-point numbers in modulo operator\n* implement a compiler option for adding custom iterator functions\n* implement `gojq.NewIter` function for creating a new iterator from values\n* implement `$ARGS.named` for listing command line variables\n* remove `debug` and `stderr` functions from the library\n* stop printing newlines on `stderr` function for jq compatibility\n\n## [v0.12.3](https://github.com/itchyny/gojq/compare/v0.12.2..v0.12.3) (2021-04-01)\n* fix array slicing with infinities and large numbers (`[0][-infinite:infinite], [0][:1e20]`)\n* fix multiplying strings and modulo by infinities on MIPS 64 architecture\n* fix git revision information in Docker images\n* release multi-platform Docker images for ARM 64\n* switch to `distroless` image for Docker base image\n\n## [v0.12.2](https://github.com/itchyny/gojq/compare/v0.12.1..v0.12.2) (2021-03-01)\n* implement `GOJQ_COLORS` environment variable to configure individual colors\n* respect `--color-output` (`-C`) option even if `NO_COLOR` is set\n* implement `gojq.ValueError` interface for custom internal functions\n* fix crash on timestamps in YAML input\n* fix calculation on `infinite` (`infinite-infinite | isnan`)\n* fix comparison on `nan` (`nan < nan`)\n* fix validation of `implode` (`[-1] | implode`)\n* fix number normalization for custom JSON module loader\n* print error line numbers on invalid JSON and YAML\n* improve `strftime`, `strptime` for time zone offsets\n* improve performance on reading a large JSON file given by command line argument\n* improve performance and reduce memory allocation of the lexer, compiler and executor\n\n## [v0.12.1](https://github.com/itchyny/gojq/compare/v0.12.0..v0.12.1) (2021-01-17)\n* skip adding `$HOME/.jq` to module paths when `$HOME` is unset\n* fix optional operator followed by division operator (`1?/1`)\n* fix undefined format followed by optional operator (`@foo?`)\n* fix parsing invalid consecutive dots while scanning a number (`0..[empty]`)\n* fix panic on printing a query with `%#v`\n* improve performance and reduce memory allocation of `query.String()`\n* change all methods of `ModuleLoader` optional\n\n## [v0.12.0](https://github.com/itchyny/gojq/compare/v0.11.2..v0.12.0) (2020-12-24)\n* implement tab indentation option (`--tab`)\n* implement a compiler option for adding custom internal functions\n* implement `gojq.Marshal` function for jq-flavored encoding\n* fix slurp option with JSON file arguments\n* fix escaping characters in object keys\n* fix normalizing negative `int64` to `int` on 32-bit architecture\n* fix crash on continuing iteration after emitting an error\n* `iter.Next()` does not normalize `NaN` and infinities anymore. Library users\n  should take care of them. To handle them for encoding as JSON bytes, use\n  `gojq.Marshal`. Also, `iter.Next()` does not clone values deeply anymore for\n  performance reason. Users must not update the elements of the returned arrays\n  and objects\n* improve performance of outputting JSON values by about 3.5 times\n\n## [v0.11.2](https://github.com/itchyny/gojq/compare/v0.11.1..v0.11.2) (2020-10-01)\n* fix build for 32bit architecture\n* release to [GitHub Container Registry](https://github.com/users/itchyny/packages/container/package/gojq)\n\n## [v0.11.1](https://github.com/itchyny/gojq/compare/v0.11.0..v0.11.1) (2020-08-22)\n* improve compatibility of `strftime`, `strptime` functions with jq\n* fix YAML input with numbers in keys\n* fix crash on multiplying a large number or `infinite` to a string\n* fix crash on error while slicing a string (`\"\"[:{}]`)\n* fix crash on modulo by a number near 0.0 (`1 % 0.1`)\n* include `CREDITS` file in artifacts\n\n## [v0.11.0](https://github.com/itchyny/gojq/compare/v0.10.4..v0.11.0) (2020-07-08)\n* improve parsing performance significantly\n* rewrite the parser from `participle` library to `goyacc` generated parser\n* release to [itchyny/gojq - Docker Hub](https://hub.docker.com/r/itchyny/gojq)\n* support string interpolation for object pattern key\n\n## [v0.10.4](https://github.com/itchyny/gojq/compare/v0.10.3..v0.10.4) (2020-06-30)\n* implement variable in object key (`. as $x | { $x: 1 }`)\n* fix modify operator (`|=`) with `try` `catch` expression\n* fix optional operator (`?`) with alternative operator (`//`) in `map_values` function\n* fix normalizing numeric types for library users\n* export `gojq.NewModuleLoader` function for library users\n\n## [v0.10.3](https://github.com/itchyny/gojq/compare/v0.10.2..v0.10.3) (2020-06-06)\n* implement `add`, `unique_by`, `max_by`, `min_by`, `reverse` by internal\n  functions for performance and reducing the binary size\n* improve performance of `setpath`, `delpaths` functions\n* fix assignment against nested slicing (`[1,2,3] | .[1:][:1] = [5]`)\n* limit the array index of assignment operator\n* optimize constant arrays and objects\n\n## [v0.10.2](https://github.com/itchyny/gojq/compare/v0.10.1..v0.10.2) (2020-05-24)\n* implement `sort_by`, `group_by`, `bsearch` by internal functions for performance\n  and reducing the binary size\n* fix object construction and constant object to allow trailing commas\n* fix `tonumber` function to allow leading zeros\n* minify the builtin functions to reduce the binary size\n\n## [v0.10.1](https://github.com/itchyny/gojq/compare/v0.10.0..v0.10.1) (2020-04-24)\n* fix array addition not to modify the left hand side\n\n## [v0.10.0](https://github.com/itchyny/gojq/compare/v0.9.0..v0.10.0) (2020-04-02)\n* implement various functions (`format`, `significand`, `modulemeta`, `halt_error`)\n* implement `input`, `inputs` functions\n* implement stream option (`--stream`)\n* implement slicing with object (`.[{\"start\": 1, \"end\": 2}]`)\n* implement `NO_COLOR` environment variable support\n* implement `nul` output option (`-0`, `--nul-output`)\n* implement exit status option (`-e`, `--exit-status`)\n* implement `search` field of module meta object\n* implement combination of `--yaml-input` and `--slurp`\n* improve string token lexer and support nested string interpolation\n* improve the exit code for jq compatibility\n* improve default module search paths for jq compatibility\n* improve documentation for the usage as a library\n* change methods of `ModuleLoader` optional, implement `LoadModuleWithMeta` and `LoadJSONWithMeta`\n* fix number normalization for JSON arguments (`--argjson`, `--slurpfile`)\n* fix `0/0` and `infinite/infinite`\n* fix `error` function against `null`\n\n## [v0.9.0](https://github.com/itchyny/gojq/compare/v0.8.0..v0.9.0) (2020-03-15)\n* implement various functions (`infinite`, `isfinite`, `isinfinite`, `finites`, `isnormal`, `normals`)\n* implement environment variables loader as a compiler option\n* implement `$NAME::NAME` syntax for imported JSON variable\n* fix modify operator with empty against array (`[range(9)] | (.[] | select(. % 2 > 0)) |= empty`)\n* fix variable and function scopes (`{ x: 1 } | . as $x | (.x as $x | $x) | ., $x`)\n* fix path analyzer\n* fix type check in `startswith` and `endswith`\n* ignore type error of `ltrimstr` and `rtrimstr`\n* remove nano seconds from `mktime` output\n* trim newline at the end of error messages\n* improve documents and examples\n\n## [v0.8.0](https://github.com/itchyny/gojq/compare/v0.7.0..v0.8.0) (2020-03-02)\n* implement format strings (`@text`, `@json`, `@html`, `@uri`, `@csv`, `@tsv`,\n  `@sh`, `@base64`, `@base64d`)\n* implement modules feature (`-L` option for directory to search modules from)\n* implement options for binding variables from arguments (`--arg`, `--argjson`)\n* implement options for binding variables from files (`--slurpfile`, `--rawfile`)\n* implement an option for indentation count (`--indent`)\n* fix `isnan` for `null`\n* fix path analyzer\n* fix error after optional operator (`1? | .x`)\n* add `$ENV` variable\n* add zsh completion file\n\n## [v0.7.0](https://github.com/itchyny/gojq/compare/v0.6.0..v0.7.0) (2019-12-22)\n* implement YAML input (`--yaml-input`) and output (`--yaml-output`)\n* fix pipe in object value\n* fix precedence of `if`, `try`, `reduce` and `foreach` expressions\n* release from GitHub Actions\n\n## [v0.6.0](https://github.com/itchyny/gojq/compare/v0.5.0..v0.6.0) (2019-08-26)\n* implement arbitrary-precision integer calculation\n* implement various functions (`repeat`, `pow10`, `nan`, `isnan`, `nearbyint`,\n  `halt`, `INDEX`, `JOIN`, `IN`)\n* implement long options (`--compact-output`, `--raw-output`, `--join-output`,\n  `--color-output`, `--monochrome-output`, `--null-input`, `--raw-input`,\n  `--slurp`, `--from-file`, `--version`)\n* implement join output options (`-j`, `--join-output`)\n* implement color/monochrome output options (`-C`, `--color-output`,\n  `-M`, `--monochrome-output`)\n* refactor builtin functions\n\n## [v0.5.0](https://github.com/itchyny/gojq/compare/v0.4.0..v0.5.0) (2019-08-03)\n* implement various functions (`with_entries`, `from_entries`, `leaf_paths`,\n  `contains`, `inside`, `split`, `stream`, `fromstream`, `truncate_stream`,\n  `bsearch`, `path`, `paths`, `map_values`, `del`, `delpaths`, `getpath`,\n  `gmtime`, `localtime`, `mktime`, `strftime`, `strflocaltime`, `strptime`,\n  `todate`, `fromdate`, `now`, `match`, `test`, `capture`, `scan`, `splits`,\n  `sub`, `gsub`, `debug`, `stderr`)\n* implement assignment operator (`=`)\n* implement modify operator (`|=`)\n* implement update operators (`+=`, `-=`, `*=`, `/=`, `%=`, `//=`)\n* implement destructuring alternative operator (`?//`)\n* allow function declaration inside query\n* implement `-f` flag for loading query from file\n* improve error message for parsing multiple line query\n\n## [v0.4.0](https://github.com/itchyny/gojq/compare/v0.3.0..v0.4.0) (2019-07-20)\n* improve performance significantly\n* rewrite from recursive interpreter to stack machine based interpreter\n* allow debugging with `make install-debug` and `export GOJQ_DEBUG=1`\n* parse built-in functions and generate syntax trees before compilation\n* optimize tail recursion\n* fix behavior of optional operator\n* fix scopes of arguments of recursive function call\n* fix duplicate function argument names\n* implement `setpath` function\n\n## [v0.3.0](https://github.com/itchyny/gojq/compare/v0.2.0..v0.3.0) (2019-06-05)\n* implement `reduce`, `foreach`, `label`, `break` syntax\n* improve binding variable syntax to bind to an object or an array\n* implement string interpolation\n* implement object index by string (`.\"example\"`)\n* implement various functions (`add`, `flatten`, `min`, `min_by`, `max`,\n  `max_by`, `sort`, `sort_by`, `group_by`, `unique`, `unique_by`, `tostring`,\n  `indices`, `index`, `rindex`, `walk`, `transpose`, `first`, `last`, `nth`,\n  `limit`, `all`, `any`, `isempty`, `error`, `builtins`, `env`)\n* implement math functions (`sin`, `cos`, `tan`, `asin`, `acos`, `atan`,\n  `sinh`, `cosh`, `tanh`, `asinh`, `acosh`, `atanh`, `floor`, `round`,\n  `rint`, `ceil`, `trunc`, `fabs`, `sqrt`, `cbrt`, `exp`, `exp10`, `exp2`,\n  `expm1`, `frexp`, `modf`, `log`, `log10`, `log1p`, `log2`, `logb`,\n  `gamma`, `tgamma`, `lgamma`, `erf`, `erfc`, `j0`, `j1`, `y0`, `y1`,\n  `atan2/2`, `copysign/2`, `drem/2`, `fdim/2`, `fmax/2`, `fmin/2`, `fmod/2`,\n  `hypot/2`, `jn/2`, `ldexp/2`, `nextafter/2`, `nexttoward/2`, `remainder/2`,\n  `scalb/2`, `scalbln/2`, `pow/2`, `yn/2`, `fma/3`)\n* support object construction with variables\n* support indexing against strings\n* fix function evaluation for recursive call\n* fix error handling of `//` operator\n* fix string representation of NaN and Inf\n* implement `-R` flag for reading input as raw strings\n* implement `-c` flag for compact output\n* implement `-n` flag for using null as input value\n* implement `-r` flag for outputting raw string\n* implement `-s` flag for reading all inputs into an array\n\n## [v0.2.0](https://github.com/itchyny/gojq/compare/v0.1.0..v0.2.0) (2019-05-06)\n* implement binding variable syntax (`... as $var`)\n* implement `try` `catch` syntax\n* implement alternative operator (`//`)\n* implement various functions (`in`, `to_entries`, `startswith`, `endswith`,\n  `ltrimstr`, `rtrimstr`, `combinations`, `ascii_downcase`, `ascii_upcase`,\n  `tojson`, `fromjson`)\n* support query for object indexing\n* support object construction with variables\n* support indexing against strings\n\n## [v0.1.0](https://github.com/itchyny/gojq/compare/v0.0.1..v0.1.0) (2019-05-02)\n* implement binary operators (`+`, `-`, `*`, `/`, `%`, `==`, `!=`, `>`, `<`,\n  `>=`, `<=`, `and`, `or`)\n* implement unary operators (`+`, `-`)\n* implement booleans (`false`, `true`), `null`, number and string constant\n  values\n* implement `empty` value\n* implement conditional syntax (`if` `then` `elif` `else` `end`)\n* implement various functions (`length`, `utf8bytelength`, `not`, `keys`,\n  `has`, `map`, `select`, `recurse`, `while`, `until`, `range`, `tonumber`,\n  `type`, `arrays`, `objects`, `iterables`, `booleans`, `numbers`, `strings`,\n  `nulls`, `values`, `scalars`, `reverse`, `explode`, `implode`, `join`)\n* support function declaration\n* support iterators in object keys\n* support object construction shortcut\n* support query in array indices\n* support negative number indexing against arrays\n* support json file name arguments\n\n## [v0.0.1](https://github.com/itchyny/gojq/compare/0fa3241..v0.0.1) (2019-04-14)\n* initial implementation\n"
        },
        {
          "name": "Dockerfile",
          "type": "blob",
          "size": 0.2177734375,
          "content": "FROM golang:1.23 AS builder\n\nWORKDIR /app\nCOPY go.* ./\nRUN go mod download\nCOPY . .\nENV CGO_ENABLED=0\nRUN make build\n\nFROM gcr.io/distroless/static:debug\n\nCOPY --from=builder /app/gojq /\nENTRYPOINT [\"/gojq\"]\nCMD [\"--help\"]\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.0537109375,
          "content": "The MIT License (MIT)\n\nCopyright (c) 2019-2024 itchyny\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n"
        },
        {
          "name": "Makefile",
          "type": "blob",
          "size": 2.5146484375,
          "content": "BIN := gojq\nVERSION := $$(make -s show-version)\nVERSION_PATH := cli\nCURRENT_REVISION = $(shell git rev-parse --short HEAD)\nBUILD_LDFLAGS = \"-s -w -X github.com/itchyny/$(BIN)/cli.revision=$(CURRENT_REVISION)\"\nGOBIN ?= $(shell go env GOPATH)/bin\nSHELL := /bin/bash\n\n.PHONY: all\nall: build\n\n.PHONY: build\nbuild:\n\tgo build -ldflags=$(BUILD_LDFLAGS) -o $(BIN) ./cmd/$(BIN)\n\n.PHONY: build-dev\nbuild-dev: parser.go builtin.go\n\tgo build -ldflags=$(BUILD_LDFLAGS) -o $(BIN) ./cmd/$(BIN)\n\n.PHONY: build-debug\nbuild-debug: parser.go builtin.go\n\tgo build -tags gojq_debug -ldflags=$(BUILD_LDFLAGS) -o $(BIN) ./cmd/$(BIN)\n\nbuiltin.go: builtin.jq parser.go.y parser.go query.go operator.go _tools/*\n\tGOOS= GOARCH= go generate\n\n.SUFFIXES:\nparser.go: parser.go.y $(GOBIN)/goyacc\n\tgoyacc -o $@ $<\n\n$(GOBIN)/goyacc:\n\t@go install golang.org/x/tools/cmd/goyacc@latest\n\n.PHONY: install\ninstall:\n\tgo install -ldflags=$(BUILD_LDFLAGS) ./cmd/$(BIN)\n\n.PHONY: install-dev\ninstall-dev: parser.go builtin.go\n\tgo install -ldflags=$(BUILD_LDFLAGS) ./cmd/$(BIN)\n\n.PHONY: install-debug\ninstall-debug: parser.go builtin.go\n\tgo install -tags gojq_debug -ldflags=$(BUILD_LDFLAGS) ./cmd/$(BIN)\n\n.PHONY: show-version\nshow-version: $(GOBIN)/gobump\n\t@gobump show -r \"$(VERSION_PATH)\"\n\n$(GOBIN)/gobump:\n\t@go install github.com/x-motemen/gobump/cmd/gobump@latest\n\n.PHONY: cross\ncross: $(GOBIN)/goxz CREDITS\n\tgoxz -n $(BIN) -pv=v$(VERSION) -include _$(BIN) \\\n\t\t-build-ldflags=$(BUILD_LDFLAGS) ./cmd/$(BIN)\n\n$(GOBIN)/goxz:\n\tgo install github.com/Songmu/goxz/cmd/goxz@latest\n\nCREDITS: $(GOBIN)/gocredits go.sum\n\tgo mod tidy\n\tgocredits -w .\n\n$(GOBIN)/gocredits:\n\tgo install github.com/Songmu/gocredits/cmd/gocredits@latest\n\n.PHONY: test\ntest: build\n\tgo test -v -race ./...\n\n.PHONY: lint\nlint: $(GOBIN)/staticcheck\n\tgo vet ./...\n\tstaticcheck -checks all -tags gojq_debug ./...\n\n$(GOBIN)/staticcheck:\n\tgo install honnef.co/go/tools/cmd/staticcheck@latest\n\n.PHONY: check-tools\ncheck-tools:\n\tgo run _tools/print_builtin.go\n\n.PHONY: clean\nclean:\n\trm -rf $(BIN) goxz CREDITS\n\tgo clean\n\n.PHONY: update\nupdate: export GOPROXY=direct\nupdate:\n\tgo get -u ./... && go mod tidy\n\tgo mod edit -modfile=go.dev.mod -droprequire=github.com/itchyny/{astgen,timefmt}-go\n\tgo get -u -modfile=go.dev.mod github.com/itchyny/{astgen,timefmt}-go && go generate\n\n.PHONY: bump\nbump: $(GOBIN)/gobump\n\ttest -z \"$$(git status --porcelain || echo .)\"\n\ttest \"$$(git branch --show-current)\" = \"main\"\n\t@gobump up -w \"$(VERSION_PATH)\"\n\tgit commit -am \"bump up version to $(VERSION)\"\n\tgit tag \"v$(VERSION)\"\n\tgit push --atomic origin main tag \"v$(VERSION)\"\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 12.783203125,
          "content": "# gojq\n[![CI Status](https://github.com/itchyny/gojq/actions/workflows/ci.yaml/badge.svg?branch=main)](https://github.com/itchyny/gojq/actions?query=branch:main)\n[![Go Report Card](https://goreportcard.com/badge/github.com/itchyny/gojq)](https://goreportcard.com/report/github.com/itchyny/gojq)\n[![MIT License](https://img.shields.io/badge/license-MIT-blue.svg)](https://github.com/itchyny/gojq/blob/main/LICENSE)\n[![release](https://img.shields.io/github/release/itchyny/gojq/all.svg)](https://github.com/itchyny/gojq/releases)\n[![pkg.go.dev](https://pkg.go.dev/badge/github.com/itchyny/gojq)](https://pkg.go.dev/github.com/itchyny/gojq)\n\n### Pure Go implementation of [jq](https://github.com/jqlang/jq)\nThis is an implementation of jq command written in Go language.\nYou can also embed gojq as a library to your Go products.\n\n## Usage\n```sh\n $ echo '{\"foo\": 128}' | gojq '.foo'\n128\n $ echo '{\"a\": {\"b\": 42}}' | gojq '.a.b'\n42\n $ echo '{\"id\": \"sample\", \"10\": {\"b\": 42}}' | gojq '{(.id): .[\"10\"].b}'\n{\n  \"sample\": 42\n}\n $ echo '[{\"id\":1},{\"id\":2},{\"id\":3}]' | gojq '.[] | .id'\n1\n2\n3\n $ echo '{\"a\":1,\"b\":2}' | gojq '.a += 1 | .b *= 2'\n{\n  \"a\": 2,\n  \"b\": 4\n}\n $ echo '{\"a\":1} [2] 3' | gojq '. as {$a} ?// [$a] ?// $a | $a'\n1\n2\n3\n $ echo '{\"foo\": 4722366482869645213696}' | gojq .foo\n4722366482869645213696  # keeps the precision of large numbers\n $ gojq -n 'def fact($n): if $n < 1 then 1 else $n * fact($n - 1) end; fact(50)'\n30414093201713378043612608166064768844377641568960512000000000000 # arbitrary-precision integer calculation\n```\n\nNice error messages.\n```sh\n $ echo '[1,2,3]' | gojq '.foo & .bar'\ngojq: invalid query: .foo & .bar\n    .foo & .bar\n         ^  unexpected token \"&\"\n $ echo '{\"foo\": { bar: [] } }' | gojq '.'\ngojq: invalid json: <stdin>\n    {\"foo\": { bar: [] } }\n              ^  invalid character 'b' looking for beginning of object key string\n```\n\n## Installation\n### Homebrew\n```sh\nbrew install gojq\n```\n\n### Zero Install\n```sh\n0install add gojq https://apps.0install.net/utils/gojq.xml\n```\n\n### Build from source\n```sh\ngo install github.com/itchyny/gojq/cmd/gojq@latest\n```\n\n### Docker\n```sh\ndocker run -i --rm itchyny/gojq\ndocker run -i --rm ghcr.io/itchyny/gojq\n```\n\n## Difference to jq\n- gojq is purely implemented with Go language and is completely portable. jq depends on the C standard library so the availability of math functions depends on the library. jq also depends on the regular expression library and it makes build scripts complex.\n- gojq implements nice error messages for invalid query and JSON input. The error message of jq is sometimes difficult to tell where to fix the query.\n- gojq does not keep the order of object keys. I understand this might cause problems for some scripts but basically, we should not rely on the order of object keys. Due to this limitation, gojq does not have `keys_unsorted` function and `--sort-keys` (`-S`) option. I would implement when ordered map is implemented in the standard library of Go but I'm less motivated.\n- gojq supports arbitrary-precision integer calculation while jq does not; jq loses the precision of large integers when calculation is involved. Note that even with gojq, all mathematical functions, including `floor` and `round`, convert integers to floating-point numbers; only addition, subtraction, multiplication, modulo, and division operators (when divisible) keep the integer precision. To calculate floor division of integers without losing the precision, use `def idivide($n): (. - . % $n) / $n;`. To round down floating-point numbers to integers, use `def ifloor: floor | tostring | tonumber;`, but note that this function does not work with large floating-point numbers and also loses the precision of large integers.\n- gojq behaves differently than jq in some features, hoping that jq will fix the behaviors in the future. gojq consistently counts by characters (not by bytes) in `index`, `rindex`, and `indices` functions; `\"１２３４５\" | .[index(\"３\"):]` results in `\"３４５\"` ([jq#1430](https://github.com/jqlang/jq/issues/1430), [jq#1624](https://github.com/jqlang/jq/issues/1624)). gojq supports string indexing; `\"abcde\"[2]` ([jq#1520](https://github.com/jqlang/jq/issues/1520)). gojq fixes handling files with no newline characters at the end ([jq#2374](https://github.com/jqlang/jq/issues/2374)). gojq consistently truncates down floating-point number indices both in indexing (`[0] | .[0.5]` results in `0`), and slicing (`[0,1,2] | .[0.5:1.5]` results in `[0]`). gojq parses unary operators with higher precedence than variable binding (`[-1 as $x | 1,$x]` results in `[1,-1]` not `[-1,-1]`) ([jq#3053](https://github.com/jqlang/jq/pull/3053)). gojq fixes `@base64d` to allow binary string as the decoded string ([jq#1931](https://github.com/jqlang/jq/issues/1931)). gojq improves time formatting and parsing; deals with `%f` in `strftime` and `strptime` ([jq#1409](https://github.com/jqlang/jq/issues/1409)), parses timezone offsets with `fromdate` and `fromdateiso8601` ([jq#1053](https://github.com/jqlang/jq/issues/1053)), supports timezone name/offset with `%Z`/`%z` in `strptime` ([jq#929](https://github.com/jqlang/jq/issues/929), [jq#2195](https://github.com/jqlang/jq/issues/2195)), and looks up correct timezone during daylight saving time on formatting with `%Z` ([jq#1912](https://github.com/jqlang/jq/issues/1912)). gojq supports nanoseconds in date and time functions.\n- gojq does not support some functions intentionally; `get_jq_origin`, `get_prog_origin`, `get_search_list` (unstable, not listed in jq document), `input_line_number`, `$__loc__` (performance issue). gojq does not support some flags; `--ascii-output, -a` (performance issue), `--seq` (not used commonly), `--sort-keys, -S` (sorts by default because `map[string]any` does not keep the order), `--unbuffered` (unbuffered by default). gojq does not parse JSON extensions supported by jq; `NaN`, `Infinity`, and `[000]`. gojq normalizes floating-point numbers to fit to double-precision floating-point numbers. gojq does not support some regular expression metacharacters, backreferences, look-around assertions, and some flags (regular expression engine differences). gojq does not support BOM (`encoding/json` does not support this). gojq disallows using keywords for function names (`def true: .; true` is a confusing query), and module name prefixes in function declarations (using module prefixes like `def m::f: .;` is undocumented).\n- gojq supports reading from YAML input (`--yaml-input`) while jq does not. gojq also supports YAML output (`--yaml-output`). gojq supports `@urid` format string ([jq#798](https://github.com/jqlang/jq/issues/798), [jq#2261](https://github.com/jqlang/jq/issues/2261)).\n\n### Color configuration\nThe gojq command automatically disables coloring output when the output is not a tty.\nTo force coloring output, specify `--color-output` (`-C`) option.\nWhen [`NO_COLOR` environment variable](https://no-color.org/) is present or `--monochrome-output` (`-M`) option is specified, gojq disables coloring output.\n\nUse `GOJQ_COLORS` environment variable to configure individual colors.\nThe variable is a colon-separated list of ANSI escape sequences of `null`, `false`, `true`, numbers, strings, object keys, arrays, and objects.\nThe default configuration is `90:33:33:36:32:34;1`.\n\n## Usage as a library\nYou can use the gojq parser and interpreter from your Go products.\n\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"log\"\n\n\t\"github.com/itchyny/gojq\"\n)\n\nfunc main() {\n\tquery, err := gojq.Parse(\".foo | ..\")\n\tif err != nil {\n\t\tlog.Fatalln(err)\n\t}\n\tinput := map[string]any{\"foo\": []any{1, 2, 3}}\n\titer := query.Run(input) // or query.RunWithContext\n\tfor {\n\t\tv, ok := iter.Next()\n\t\tif !ok {\n\t\t\tbreak\n\t\t}\n\t\tif err, ok := v.(error); ok {\n\t\t\tif err, ok := err.(*gojq.HaltError); ok && err.Value() == nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tlog.Fatalln(err)\n\t\t}\n\t\tfmt.Printf(\"%#v\\n\", v)\n\t}\n}\n```\n\n- Firstly, use [`gojq.Parse(string) (*Query, error)`](https://pkg.go.dev/github.com/itchyny/gojq#Parse) to get the query from a string.\n  - Use [`gojq.ParseError`](https://pkg.go.dev/github.com/itchyny/gojq#ParseError) to get the error position and token of the parsing error.\n- Secondly, get the result iterator\n  - using [`query.Run`](https://pkg.go.dev/github.com/itchyny/gojq#Query.Run) or [`query.RunWithContext`](https://pkg.go.dev/github.com/itchyny/gojq#Query.RunWithContext)\n  - or alternatively, compile the query using [`gojq.Compile`](https://pkg.go.dev/github.com/itchyny/gojq#Compile) and then [`code.Run`](https://pkg.go.dev/github.com/itchyny/gojq#Code.Run) or [`code.RunWithContext`](https://pkg.go.dev/github.com/itchyny/gojq#Code.RunWithContext). You can reuse the `*Code` against multiple inputs to avoid compilation of the same query. But for arguments of `code.Run`, do not give values sharing same data between multiple calls.\n  - In either case, you cannot use custom type values as the query input. The type should be `[]any` for an array and `map[string]any` for a map (just like decoded to an `any` using the [encoding/json](https://golang.org/pkg/encoding/json/) package). You can't use `[]int` or `map[string]string`, for example. If you want to query your custom struct, marshal to JSON, unmarshal to `any` and use it as the query input.\n- Thirdly, iterate through the results using [`iter.Next() (any, bool)`](https://pkg.go.dev/github.com/itchyny/gojq#Iter). The iterator can emit an error so make sure to handle it. The method returns `true` with results, and `false` when the iterator terminates.\n  - The return type is not `(any, error)` because the iterator may emit multiple errors. The `jq` and `gojq` commands stop the iteration on the first error, but the library user can choose to stop the iteration on errors, or to continue until it terminates.\n    - In any case, it is recommended to stop the iteration on [`gojq.HaltError`](https://pkg.go.dev/github.com/itchyny/gojq#HaltError), which is emitted by `halt` and `halt_error` functions, although these functions are rarely used.\n      The error implements [`gojq.ValueError`](https://pkg.go.dev/github.com/itchyny/gojq#ValueError), and if the error value is `nil`, stop the iteration without handling the error.\n      Technically speaking, we can fix the iterator to terminate on the halting error, but it does not terminate at the moment.\n      The `halt` function in jq not only stops the iteration, but also terminates the command execution, even if there are still input values.\n      So, gojq leaves it up to the library user how to handle the halting error.\n  - Note that the result iterator may emit infinite number of values; `repeat(0)` and `range(infinite)`. It may stuck with no output value; `def f: f; f`. Use `RunWithContext` when you want to limit the execution time.\n\n[`gojq.Compile`](https://pkg.go.dev/github.com/itchyny/gojq#Compile) allows to configure the following compiler options.\n\n- [`gojq.WithModuleLoader`](https://pkg.go.dev/github.com/itchyny/gojq#WithModuleLoader) allows to load modules. By default, the module feature is disabled. If you want to load modules from the file system, use [`gojq.NewModuleLoader`](https://pkg.go.dev/github.com/itchyny/gojq#NewModuleLoader).\n- [`gojq.WithEnvironLoader`](https://pkg.go.dev/github.com/itchyny/gojq#WithEnvironLoader) allows to configure the environment variables referenced by `env` and `$ENV`. By default, OS environment variables are not accessible due to security reasons. You can use `gojq.WithEnvironLoader(os.Environ)` if you want.\n- [`gojq.WithVariables`](https://pkg.go.dev/github.com/itchyny/gojq#WithVariables) allows to configure the variables which can be used in the query. Pass the values of the variables to [`code.Run`](https://pkg.go.dev/github.com/itchyny/gojq#Code.Run) in the same order.\n- [`gojq.WithFunction`](https://pkg.go.dev/github.com/itchyny/gojq#WithFunction) allows to add a custom internal function. An internal function can return a single value (which can be an error) each invocation. To add a jq function (which may include a comma operator to emit multiple values, `empty` function, accept a filter for its argument, or call another built-in function), use `LoadInitModules` of the module loader.\n- [`gojq.WithIterFunction`](https://pkg.go.dev/github.com/itchyny/gojq#WithIterFunction) allows to add a custom iterator function. An iterator function returns an iterator to emit multiple values. You cannot define both iterator and non-iterator functions of the same name (with possibly different arities). You can use [`gojq.NewIter`](https://pkg.go.dev/github.com/itchyny/gojq#NewIter) to convert values or an error to a [`gojq.Iter`](https://pkg.go.dev/github.com/itchyny/gojq#Iter).\n- [`gojq.WithInputIter`](https://pkg.go.dev/github.com/itchyny/gojq#WithInputIter) allows to use `input` and `inputs` functions. By default, these functions are disabled.\n\n## Bug Tracker\nReport bug at [Issues・itchyny/gojq - GitHub](https://github.com/itchyny/gojq/issues).\n\n## Author\nitchyny (<https://github.com/itchyny>)\n\n## License\nThis software is released under the MIT License, see LICENSE.\n"
        },
        {
          "name": "_gojq",
          "type": "blob",
          "size": 2.5439453125,
          "content": "#compdef gojq\n\n_gojq()\n{\n  _arguments -s -S \\\n    '(-r --raw-output --raw-output0 -j --join-output)'{-r,--raw-output}'[output raw strings]' \\\n    '(-r --raw-output               -j --join-output)--raw-output0[implies -r with NUL character delimiter]' \\\n    '(-r --raw-output --raw-output0 -j --join-output)'{-j,--join-output}'[implies -r with no newline delimiter]' \\\n    '(-c --compact-output --indent --tab --yaml-output)'{-c,--compact-output}'[output without pretty-printing]' \\\n    '(-c --compact-output          --tab --yaml-output)--indent[number of spaces for indentation]:indentation count:(2 4 8)' \\\n    '(-c --compact-output --indent       --yaml-output)--tab[use tabs for indentation]' \\\n    '(-c --compact-output --indent --tab              )--yaml-output[output in YAML format]' \\\n    '(-C --color-output -M --monochrome-output)'{-C,--color-output}'[output with colors even if piped]' \\\n    '(-C --color-output -M --monochrome-output)'{-M,--monochrome-output}'[output without colors]' \\\n    '(-n --null-input)'{-n,--null-input}'[use null as input value]' \\\n    '(-R --raw-input --stream --yaml-input)'{-R,--raw-input}'[read input as raw strings]' \\\n    '(-R --raw-input          --yaml-input)--stream[parse input in stream fashion]' \\\n    '(-R --raw-input --stream             )--yaml-input[read input as YAML format]' \\\n    '(-s --slurp)'{-s,--slurp}'[read all inputs into an array]' \\\n    '(-f --from-file 1)'{-f,--from-file}'[load query from file]:filename of jq query:_files' \\\n    '*'{-L,--library-path}'[directory to search modules from]:module directory:_directories' \\\n    '*--arg[set a string value to a variable]:variable name: :string value' \\\n    '*--argjson[set a JSON value to a variable]:variable name: :JSON value' \\\n    '*--slurpfile[set the JSON contents of a file to a variable]:variable name: :JSON file:_files' \\\n    '*--rawfile[set the contents of a file to a variable]:variable name: :file:_files' \\\n    '*--args[consume remaining arguments as positional string values]' \\\n    '*--jsonargs[consume remaining arguments as positional JSON values]' \\\n    '(-e --exit-status)'{-e,--exit-status}'[exit 1 when the last value is false or null]' \\\n    '(- 1 *)'{-v,--version}'[display version information]' \\\n    '(- 1 *)'{-h,--help}'[display help information]' \\\n    '1: :_guard \"^-([[:alpha:]0]#|-*)\" \"jq query\"' \\\n    '*: :_gojq_args'\n}\n\n_gojq_args() {\n  if (($words[(I)--args] > $words[(I)--jsonargs])); then\n    _message 'string value'\n  elif (($words[(I)--args] < $words[(I)--jsonargs])); then\n    _message 'JSON value'\n  else\n    _arguments '*:input file:_files'\n  fi\n}\n"
        },
        {
          "name": "_tools",
          "type": "tree",
          "content": null
        },
        {
          "name": "builtin.go",
          "type": "blob",
          "size": 31.4326171875,
          "content": "// Code generated by _tools/gen_builtin.go; DO NOT EDIT.\n\npackage gojq\n\nfunc init() {\n\tbuiltinFuncDefs = map[string][]*FuncDef{\n\t\t\"IN\": {{Name: \"IN\", Args: []string{\"s\"}, Body: &Query{Term: &Term{Type: TermTypeFunc, Func: &Func{Name: \"any\", Args: []*Query{{Left: &Query{Func: \"s\"}, Op: OpEq, Right: &Query{Func: \".\"}}, {Func: \".\"}}}}}}, {Name: \"IN\", Args: []string{\"src\", \"s\"}, Body: &Query{Term: &Term{Type: TermTypeFunc, Func: &Func{Name: \"any\", Args: []*Query{{Left: &Query{Func: \"src\"}, Op: OpEq, Right: &Query{Func: \"s\"}}, {Func: \".\"}}}}}}},\n\t\t\"INDEX\": {{Name: \"INDEX\", Args: []string{\"stream\", \"idx_expr\"}, Body: &Query{Term: &Term{Type: TermTypeReduce, Reduce: &Reduce{Query: &Query{Func: \"stream\"}, Pattern: &Pattern{Name: \"$row\"}, Start: &Query{Term: &Term{Type: TermTypeObject, Object: &Object{}}}, Update: &Query{Left: &Query{Term: &Term{Type: TermTypeIndex, Index: &Index{Start: &Query{Left: &Query{Func: \"$row\"}, Op: OpPipe, Right: &Query{Left: &Query{Func: \"idx_expr\"}, Op: OpPipe, Right: &Query{Func: \"tostring\"}}}}}}, Op: OpAssign, Right: &Query{Func: \"$row\"}}}}}}, {Name: \"INDEX\", Args: []string{\"idx_expr\"}, Body: &Query{Term: &Term{Type: TermTypeFunc, Func: &Func{Name: \"INDEX\", Args: []*Query{{Term: &Term{Type: TermTypeIdentity, SuffixList: []*Suffix{{Iter: true}}}}, {Func: \"idx_expr\"}}}}}}},\n\t\t\"JOIN\": {{Name: \"JOIN\", Args: []string{\"$idx\", \"idx_expr\"}, Body: &Query{Term: &Term{Type: TermTypeArray, Array: &Array{Query: &Query{Left: &Query{Term: &Term{Type: TermTypeIdentity, SuffixList: []*Suffix{{Iter: true}}}}, Op: OpPipe, Right: &Query{Term: &Term{Type: TermTypeArray, Array: &Array{Query: &Query{Left: &Query{Func: \".\"}, Op: OpComma, Right: &Query{Term: &Term{Type: TermTypeFunc, Func: &Func{Name: \"$idx\"}, SuffixList: []*Suffix{{Index: &Index{Start: &Query{Func: \"idx_expr\"}}}}}}}}}}}}}}}, {Name: \"JOIN\", Args: []string{\"$idx\", \"stream\", \"idx_expr\"}, Body: &Query{Left: &Query{Func: \"stream\"}, Op: OpPipe, Right: &Query{Term: &Term{Type: TermTypeArray, Array: &Array{Query: &Query{Left: &Query{Func: \".\"}, Op: OpComma, Right: &Query{Term: &Term{Type: TermTypeFunc, Func: &Func{Name: \"$idx\"}, SuffixList: []*Suffix{{Index: &Index{Start: &Query{Func: \"idx_expr\"}}}}}}}}}}}}, {Name: \"JOIN\", Args: []string{\"$idx\", \"stream\", \"idx_expr\", \"join_expr\"}, Body: &Query{Left: &Query{Func: \"stream\"}, Op: OpPipe, Right: &Query{Left: &Query{Term: &Term{Type: TermTypeArray, Array: &Array{Query: &Query{Left: &Query{Func: \".\"}, Op: OpComma, Right: &Query{Term: &Term{Type: TermTypeFunc, Func: &Func{Name: \"$idx\"}, SuffixList: []*Suffix{{Index: &Index{Start: &Query{Func: \"idx_expr\"}}}}}}}}}}, Op: OpPipe, Right: &Query{Func: \"join_expr\"}}}}},\n\t\t\"_assign\": {},\n\t\t\"_modify\": {},\n\t\t\"add\": {{Name: \"add\", Args: []string{\"f\"}, Body: &Query{Left: &Query{Term: &Term{Type: TermTypeArray, Array: &Array{Query: &Query{Func: \"f\"}}}}, Op: OpPipe, Right: &Query{Func: \"add\"}}}},\n\t\t\"all\": {{Name: \"all\", Body: &Query{Term: &Term{Type: TermTypeFunc, Func: &Func{Name: \"all\", Args: []*Query{{Func: \".\"}}}}}}, {Name: \"all\", Args: []string{\"y\"}, Body: &Query{Term: &Term{Type: TermTypeFunc, Func: &Func{Name: \"all\", Args: []*Query{{Term: &Term{Type: TermTypeIdentity, SuffixList: []*Suffix{{Iter: true}}}}, {Func: \"y\"}}}}}}, {Name: \"all\", Args: []string{\"g\", \"y\"}, Body: &Query{Term: &Term{Type: TermTypeFunc, Func: &Func{Name: \"isempty\", Args: []*Query{{Left: &Query{Func: \"g\"}, Op: OpPipe, Right: &Query{Term: &Term{Type: TermTypeFunc, Func: &Func{Name: \"select\", Args: []*Query{{Left: &Query{Func: \"y\"}, Op: OpPipe, Right: &Query{Func: \"not\"}}}}}}}}}}}}},\n\t\t\"any\": {{Name: \"any\", Body: &Query{Term: &Term{Type: TermTypeFunc, Func: &Func{Name: \"any\", Args: []*Query{{Func: \".\"}}}}}}, {Name: \"any\", Args: []string{\"y\"}, Body: &Query{Term: &Term{Type: TermTypeFunc, Func: &Func{Name: \"any\", Args: []*Query{{Term: &Term{Type: TermTypeIdentity, SuffixList: []*Suffix{{Iter: true}}}}, {Func: \"y\"}}}}}}, {Name: \"any\", Args: []string{\"g\", \"y\"}, Body: &Query{Left: &Query{Term: &Term{Type: TermTypeFunc, Func: &Func{Name: \"isempty\", Args: []*Query{{Left: &Query{Func: \"g\"}, Op: OpPipe, Right: &Query{Term: &Term{Type: TermTypeFunc, Func: &Func{Name: \"select\", Args: []*Query{{Func: \"y\"}}}}}}}}}}, Op: OpPipe, Right: &Query{Func: \"not\"}}}},\n\t\t\"arrays\": {{Name: \"arrays\", Body: &Query{Term: &Term{Type: TermTypeFunc, Func: &Func{Name: \"select\", Args: []*Query{{Left: &Query{Func: \"type\"}, Op: OpEq, Right: &Query{Term: &Term{Type: TermTypeString, Str: &String{Str: \"array\"}}}}}}}}}},\n\t\t\"booleans\": {{Name: \"booleans\", Body: &Query{Term: &Term{Type: TermTypeFunc, Func: &Func{Name: \"select\", Args: []*Query{{Left: &Query{Func: \"type\"}, Op: OpEq, Right: &Query{Term: &Term{Type: TermTypeString, Str: &String{Str: \"boolean\"}}}}}}}}}},\n\t\t\"capture\": {{Name: \"capture\", Args: []string{\"$re\"}, Body: &Query{Term: &Term{Type: TermTypeFunc, Func: &Func{Name: \"capture\", Args: []*Query{{Func: \"$re\"}, {Func: \"null\"}}}}}}, {Name: \"capture\", Args: []string{\"$re\", \"$flags\"}, Body: &Query{Left: &Query{Term: &Term{Type: TermTypeFunc, Func: &Func{Name: \"match\", Args: []*Query{{Func: \"$re\"}, {Func: \"$flags\"}}}}}, Op: OpPipe, Right: &Query{Func: \"_capture\"}}}},\n\t\t\"combinations\": {{Name: \"combinations\", Body: &Query{Term: &Term{Type: TermTypeIf, If: &If{Cond: &Query{Left: &Query{Func: \"length\"}, Op: OpEq, Right: &Query{Term: &Term{Type: TermTypeNumber, Number: \"0\"}}}, Then: &Query{Term: &Term{Type: TermTypeArray, Array: &Array{}}}, Else: &Query{Term: &Term{Type: TermTypeIndex, Index: &Index{Start: &Query{Term: &Term{Type: TermTypeNumber, Number: \"0\"}}}, SuffixList: []*Suffix{{Iter: true}, {Bind: &Bind{Patterns: []*Pattern{{Name: \"$x\"}}, Body: &Query{Left: &Query{Term: &Term{Type: TermTypeArray, Array: &Array{Query: &Query{Func: \"$x\"}}}}, Op: OpAdd, Right: &Query{Term: &Term{Type: TermTypeQuery, Query: &Query{Left: &Query{Term: &Term{Type: TermTypeIndex, Index: &Index{Start: &Query{Term: &Term{Type: TermTypeNumber, Number: \"1\"}}, IsSlice: true}}}, Op: OpPipe, Right: &Query{Func: \"combinations\"}}}}}}}}}}}}}}, {Name: \"combinations\", Args: []string{\"n\"}, Body: &Query{Left: &Query{Term: &Term{Type: TermTypeArray, Array: &Array{Query: &Query{Term: &Term{Type: TermTypeFunc, Func: &Func{Name: \"limit\", Args: []*Query{{Func: \"n\"}, {Term: &Term{Type: TermTypeFunc, Func: &Func{Name: \"repeat\", Args: []*Query{{Func: \".\"}}}}}}}}}}}}, Op: OpPipe, Right: &Query{Func: \"combinations\"}}}},\n\t\t\"del\": {{Name: \"del\", Args: []string{\"f\"}, Body: &Query{Term: &Term{Type: TermTypeFunc, Func: &Func{Name: \"delpaths\", Args: []*Query{{Term: &Term{Type: TermTypeArray, Array: &Array{Query: &Query{Term: &Term{Type: TermTypeFunc, Func: &Func{Name: \"path\", Args: []*Query{{Func: \"f\"}}}}}}}}}}}}}},\n\t\t\"finites\": {{Name: \"finites\", Body: &Query{Term: &Term{Type: TermTypeFunc, Func: &Func{Name: \"select\", Args: []*Query{{Func: \"isfinite\"}}}}}}},\n\t\t\"first\": {{Name: \"first\", Body: &Query{Term: &Term{Type: TermTypeIndex, Index: &Index{Start: &Query{Term: &Term{Type: TermTypeNumber, Number: \"0\"}}}}}}, {Name: \"first\", Args: []string{\"g\"}, Body: &Query{Term: &Term{Type: TermTypeLabel, Label: &Label{Ident: \"$out\", Body: &Query{Left: &Query{Func: \"g\"}, Op: OpPipe, Right: &Query{Left: &Query{Func: \".\"}, Op: OpComma, Right: &Query{Term: &Term{Type: TermTypeBreak, Break: \"$out\"}}}}}}}}},\n\t\t\"fromdate\": {{Name: \"fromdate\", Body: &Query{Func: \"fromdateiso8601\"}}},\n\t\t\"fromdateiso8601\": {{Name: \"fromdateiso8601\", Body: &Query{Left: &Query{Term: &Term{Type: TermTypeFunc, Func: &Func{Name: \"strptime\", Args: []*Query{{Term: &Term{Type: TermTypeString, Str: &String{Str: \"%Y-%m-%dT%H:%M:%S%z\"}}}}}}}, Op: OpPipe, Right: &Query{Func: \"mktime\"}}}},\n\t\t\"fromstream\": {{Name: \"fromstream\", Args: []string{\"f\"}, Body: &Query{Term: &Term{Type: TermTypeForeach, Foreach: &Foreach{Query: &Query{Func: \"f\"}, Pattern: &Pattern{Name: \"$pv\"}, Start: &Query{Func: \"null\"}, Update: &Query{Left: &Query{Term: &Term{Type: TermTypeIf, If: &If{Cond: &Query{Term: &Term{Type: TermTypeIndex, Index: &Index{Name: \"e\"}}}, Then: &Query{Func: \"null\"}}}}, Op: OpPipe, Right: &Query{Term: &Term{Type: TermTypeFunc, Func: &Func{Name: \"$pv\"}, SuffixList: []*Suffix{{Bind: &Bind{Patterns: []*Pattern{{Array: []*Pattern{{Name: \"$p\"}, {Name: \"$v\"}}}}, Body: &Query{Term: &Term{Type: TermTypeIf, If: &If{Cond: &Query{Left: &Query{Func: \"$pv\"}, Op: OpPipe, Right: &Query{Left: &Query{Func: \"length\"}, Op: OpEq, Right: &Query{Term: &Term{Type: TermTypeNumber, Number: \"2\"}}}}, Then: &Query{Left: &Query{Term: &Term{Type: TermTypeFunc, Func: &Func{Name: \"setpath\", Args: []*Query{{Left: &Query{Term: &Term{Type: TermTypeArray, Array: &Array{Query: &Query{Term: &Term{Type: TermTypeString, Str: &String{Str: \"v\"}}}}}}, Op: OpAdd, Right: &Query{Func: \"$p\"}}, {Func: \"$v\"}}}}}, Op: OpPipe, Right: &Query{Term: &Term{Type: TermTypeFunc, Func: &Func{Name: \"setpath\", Args: []*Query{{Term: &Term{Type: TermTypeArray, Array: &Array{Query: &Query{Term: &Term{Type: TermTypeString, Str: &String{Str: \"e\"}}}}}}, {Left: &Query{Func: \"$p\"}, Op: OpPipe, Right: &Query{Left: &Query{Func: \"length\"}, Op: OpEq, Right: &Query{Term: &Term{Type: TermTypeNumber, Number: \"0\"}}}}}}}}}, Else: &Query{Term: &Term{Type: TermTypeFunc, Func: &Func{Name: \"setpath\", Args: []*Query{{Term: &Term{Type: TermTypeArray, Array: &Array{Query: &Query{Term: &Term{Type: TermTypeString, Str: &String{Str: \"e\"}}}}}}, {Left: &Query{Func: \"$p\"}, Op: OpPipe, Right: &Query{Left: &Query{Func: \"length\"}, Op: OpEq, Right: &Query{Term: &Term{Type: TermTypeNumber, Number: \"1\"}}}}}}}}}}}}}}}}}, Extract: &Query{Term: &Term{Type: TermTypeIf, If: &If{Cond: &Query{Term: &Term{Type: TermTypeIndex, Index: &Index{Name: \"e\"}}}, Then: &Query{Term: &Term{Type: TermTypeIndex, Index: &Index{Name: \"v\"}}}, Else: &Query{Func: \"empty\"}}}}}}}}},\n\t\t\"group_by\": {{Name: \"group_by\", Args: []string{\"f\"}, Body: &Query{Term: &Term{Type: TermTypeFunc, Func: &Func{Name: \"_group_by\", Args: []*Query{{Term: &Term{Type: TermTypeFunc, Func: &Func{Name: \"map\", Args: []*Query{{Term: &Term{Type: TermTypeArray, Array: &Array{Query: &Query{Func: \"f\"}}}}}}}}}}}}}},\n\t\t\"gsub\": {{Name: \"gsub\", Args: []string{\"$re\", \"str\"}, Body: &Query{Term: &Term{Type: TermTypeFunc, Func: &Func{Name: \"sub\", Args: []*Query{{Func: \"$re\"}, {Func: \"str\"}, {Term: &Term{Type: TermTypeString, Str: &String{Str: \"g\"}}}}}}}}, {Name: \"gsub\", Args: []string{\"$re\", \"str\", \"$flags\"}, Body: &Query{Term: &Term{Type: TermTypeFunc, Func: &Func{Name: \"sub\", Args: []*Query{{Func: \"$re\"}, {Func: \"str\"}, {Left: &Query{Func: \"$flags\"}, Op: OpAdd, Right: &Query{Term: &Term{Type: TermTypeString, Str: &String{Str: \"g\"}}}}}}}}}},\n\t\t\"in\": {{Name: \"in\", Args: []string{\"xs\"}, Body: &Query{Term: &Term{Type: TermTypeIdentity, SuffixList: []*Suffix{{Bind: &Bind{Patterns: []*Pattern{{Name: \"$x\"}}, Body: &Query{Left: &Query{Func: \"xs\"}, Op: OpPipe, Right: &Query{Term: &Term{Type: TermTypeFunc, Func: &Func{Name: \"has\", Args: []*Query{{Func: \"$x\"}}}}}}}}}}}}},\n\t\t\"inputs\": {{Name: \"inputs\", Body: &Query{Term: &Term{Type: TermTypeTry, Try: &Try{Body: &Query{Term: &Term{Type: TermTypeFunc, Func: &Func{Name: \"repeat\", Args: []*Query{{Func: \"input\"}}}}}, Catch: &Query{Term: &Term{Type: TermTypeIf, If: &If{Cond: &Query{Left: &Query{Func: \".\"}, Op: OpEq, Right: &Query{Term: &Term{Type: TermTypeString, Str: &String{Str: \"break\"}}}}, Then: &Query{Func: \"empty\"}, Else: &Query{Func: \"error\"}}}}}}}}},\n\t\t\"inside\": {{Name: \"inside\", Args: []string{\"xs\"}, Body: &Query{Term: &Term{Type: TermTypeIdentity, SuffixList: []*Suffix{{Bind: &Bind{Patterns: []*Pattern{{Name: \"$x\"}}, Body: &Query{Left: &Query{Func: \"xs\"}, Op: OpPipe, Right: &Query{Term: &Term{Type: TermTypeFunc, Func: &Func{Name: \"contains\", Args: []*Query{{Func: \"$x\"}}}}}}}}}}}}},\n\t\t\"isempty\": {{Name: \"isempty\", Args: []string{\"g\"}, Body: &Query{Term: &Term{Type: TermTypeLabel, Label: &Label{Ident: \"$out\", Body: &Query{Left: &Query{Term: &Term{Type: TermTypeQuery, Query: &Query{Left: &Query{Func: \"g\"}, Op: OpPipe, Right: &Query{Left: &Query{Func: \"false\"}, Op: OpComma, Right: &Query{Term: &Term{Type: TermTypeBreak, Break: \"$out\"}}}}}}, Op: OpComma, Right: &Query{Func: \"true\"}}}}}}},\n\t\t\"iterables\": {{Name: \"iterables\", Body: &Query{Term: &Term{Type: TermTypeFunc, Func: &Func{Name: \"select\", Args: []*Query{{Left: &Query{Func: \"type\"}, Op: OpPipe, Right: &Query{Left: &Query{Left: &Query{Func: \".\"}, Op: OpEq, Right: &Query{Term: &Term{Type: TermTypeString, Str: &String{Str: \"array\"}}}}, Op: OpOr, Right: &Query{Left: &Query{Func: \".\"}, Op: OpEq, Right: &Query{Term: &Term{Type: TermTypeString, Str: &String{Str: \"object\"}}}}}}}}}}}},\n\t\t\"last\": {{Name: \"last\", Body: &Query{Term: &Term{Type: TermTypeIndex, Index: &Index{Start: &Query{Term: &Term{Type: TermTypeUnary, Unary: &Unary{Op: OpSub, Term: &Term{Type: TermTypeNumber, Number: \"1\"}}}}}}}}},\n\t\t\"limit\": {{Name: \"limit\", Args: []string{\"$n\", \"g\"}, Body: &Query{Term: &Term{Type: TermTypeIf, If: &If{Cond: &Query{Left: &Query{Func: \"$n\"}, Op: OpGt, Right: &Query{Term: &Term{Type: TermTypeNumber, Number: \"0\"}}}, Then: &Query{Term: &Term{Type: TermTypeLabel, Label: &Label{Ident: \"$out\", Body: &Query{Term: &Term{Type: TermTypeForeach, Foreach: &Foreach{Query: &Query{Func: \"g\"}, Pattern: &Pattern{Name: \"$item\"}, Start: &Query{Func: \"$n\"}, Update: &Query{Left: &Query{Func: \".\"}, Op: OpSub, Right: &Query{Term: &Term{Type: TermTypeNumber, Number: \"1\"}}}, Extract: &Query{Left: &Query{Func: \"$item\"}, Op: OpComma, Right: &Query{Term: &Term{Type: TermTypeIf, If: &If{Cond: &Query{Left: &Query{Func: \".\"}, Op: OpLe, Right: &Query{Term: &Term{Type: TermTypeNumber, Number: \"0\"}}}, Then: &Query{Term: &Term{Type: TermTypeBreak, Break: \"$out\"}}, Else: &Query{Func: \"empty\"}}}}}}}}}}}, Elif: []*IfElif{{Cond: &Query{Left: &Query{Func: \"$n\"}, Op: OpEq, Right: &Query{Term: &Term{Type: TermTypeNumber, Number: \"0\"}}}, Then: &Query{Func: \"empty\"}}}, Else: &Query{Term: &Term{Type: TermTypeFunc, Func: &Func{Name: \"error\", Args: []*Query{{Term: &Term{Type: TermTypeString, Str: &String{Str: \"limit doesn't support negative count\"}}}}}}}}}}}},\n\t\t\"map\": {{Name: \"map\", Args: []string{\"f\"}, Body: &Query{Term: &Term{Type: TermTypeArray, Array: &Array{Query: &Query{Left: &Query{Term: &Term{Type: TermTypeIdentity, SuffixList: []*Suffix{{Iter: true}}}}, Op: OpPipe, Right: &Query{Func: \"f\"}}}}}}},\n\t\t\"map_values\": {{Name: \"map_values\", Args: []string{\"f\"}, Body: &Query{Left: &Query{Term: &Term{Type: TermTypeIdentity, SuffixList: []*Suffix{{Iter: true}}}}, Op: OpModify, Right: &Query{Func: \"f\"}}}},\n\t\t\"match\": {{Name: \"match\", Args: []string{\"$re\"}, Body: &Query{Term: &Term{Type: TermTypeFunc, Func: &Func{Name: \"match\", Args: []*Query{{Func: \"$re\"}, {Func: \"null\"}}}}}}, {Name: \"match\", Args: []string{\"$re\", \"$flags\"}, Body: &Query{Term: &Term{Type: TermTypeFunc, Func: &Func{Name: \"_match\", Args: []*Query{{Func: \"$re\"}, {Func: \"$flags\"}, {Func: \"false\"}}}, SuffixList: []*Suffix{{Iter: true}}}}}},\n\t\t\"max_by\": {{Name: \"max_by\", Args: []string{\"f\"}, Body: &Query{Term: &Term{Type: TermTypeFunc, Func: &Func{Name: \"_max_by\", Args: []*Query{{Term: &Term{Type: TermTypeFunc, Func: &Func{Name: \"map\", Args: []*Query{{Term: &Term{Type: TermTypeArray, Array: &Array{Query: &Query{Func: \"f\"}}}}}}}}}}}}}},\n\t\t\"min_by\": {{Name: \"min_by\", Args: []string{\"f\"}, Body: &Query{Term: &Term{Type: TermTypeFunc, Func: &Func{Name: \"_min_by\", Args: []*Query{{Term: &Term{Type: TermTypeFunc, Func: &Func{Name: \"map\", Args: []*Query{{Term: &Term{Type: TermTypeArray, Array: &Array{Query: &Query{Func: \"f\"}}}}}}}}}}}}}},\n\t\t\"normals\": {{Name: \"normals\", Body: &Query{Term: &Term{Type: TermTypeFunc, Func: &Func{Name: \"select\", Args: []*Query{{Func: \"isnormal\"}}}}}}},\n\t\t\"not\": {{Name: \"not\", Body: &Query{Term: &Term{Type: TermTypeIf, If: &If{Cond: &Query{Func: \".\"}, Then: &Query{Func: \"false\"}, Else: &Query{Func: \"true\"}}}}}},\n\t\t\"nth\": {{Name: \"nth\", Args: []string{\"$n\"}, Body: &Query{Term: &Term{Type: TermTypeIndex, Index: &Index{Start: &Query{Func: \"$n\"}}}}}, {Name: \"nth\", Args: []string{\"$n\", \"g\"}, Body: &Query{Term: &Term{Type: TermTypeIf, If: &If{Cond: &Query{Left: &Query{Func: \"$n\"}, Op: OpGe, Right: &Query{Term: &Term{Type: TermTypeNumber, Number: \"0\"}}}, Then: &Query{Term: &Term{Type: TermTypeFunc, Func: &Func{Name: \"first\", Args: []*Query{{Term: &Term{Type: TermTypeFunc, Func: &Func{Name: \"skip\", Args: []*Query{{Func: \"$n\"}, {Func: \"g\"}}}}}}}}}, Else: &Query{Term: &Term{Type: TermTypeFunc, Func: &Func{Name: \"error\", Args: []*Query{{Term: &Term{Type: TermTypeString, Str: &String{Str: \"nth doesn't support negative index\"}}}}}}}}}}}},\n\t\t\"nulls\": {{Name: \"nulls\", Body: &Query{Term: &Term{Type: TermTypeFunc, Func: &Func{Name: \"select\", Args: []*Query{{Left: &Query{Func: \".\"}, Op: OpEq, Right: &Query{Func: \"null\"}}}}}}}},\n\t\t\"numbers\": {{Name: \"numbers\", Body: &Query{Term: &Term{Type: TermTypeFunc, Func: &Func{Name: \"select\", Args: []*Query{{Left: &Query{Func: \"type\"}, Op: OpEq, Right: &Query{Term: &Term{Type: TermTypeString, Str: &String{Str: \"number\"}}}}}}}}}},\n\t\t\"objects\": {{Name: \"objects\", Body: &Query{Term: &Term{Type: TermTypeFunc, Func: &Func{Name: \"select\", Args: []*Query{{Left: &Query{Func: \"type\"}, Op: OpEq, Right: &Query{Term: &Term{Type: TermTypeString, Str: &String{Str: \"object\"}}}}}}}}}},\n\t\t\"paths\": {{Name: \"paths\", Body: &Query{Left: &Query{Term: &Term{Type: TermTypeFunc, Func: &Func{Name: \"path\", Args: []*Query{{Func: \"..\"}}}}}, Op: OpPipe, Right: &Query{Term: &Term{Type: TermTypeFunc, Func: &Func{Name: \"select\", Args: []*Query{{Left: &Query{Func: \".\"}, Op: OpNe, Right: &Query{Term: &Term{Type: TermTypeArray, Array: &Array{}}}}}}}}}}, {Name: \"paths\", Args: []string{\"f\"}, Body: &Query{Left: &Query{Term: &Term{Type: TermTypeFunc, Func: &Func{Name: \"path\", Args: []*Query{{Left: &Query{Func: \"..\"}, Op: OpPipe, Right: &Query{Term: &Term{Type: TermTypeFunc, Func: &Func{Name: \"select\", Args: []*Query{{Func: \"f\"}}}}}}}}}}, Op: OpPipe, Right: &Query{Term: &Term{Type: TermTypeFunc, Func: &Func{Name: \"select\", Args: []*Query{{Left: &Query{Func: \".\"}, Op: OpNe, Right: &Query{Term: &Term{Type: TermTypeArray, Array: &Array{}}}}}}}}}}},\n\t\t\"pick\": {{Name: \"pick\", Args: []string{\"f\"}, Body: &Query{Term: &Term{Type: TermTypeIdentity, SuffixList: []*Suffix{{Bind: &Bind{Patterns: []*Pattern{{Name: \"$v\"}}, Body: &Query{Term: &Term{Type: TermTypeReduce, Reduce: &Reduce{Query: &Query{Term: &Term{Type: TermTypeFunc, Func: &Func{Name: \"path\", Args: []*Query{{Func: \"f\"}}}}}, Pattern: &Pattern{Name: \"$p\"}, Start: &Query{Func: \"null\"}, Update: &Query{Term: &Term{Type: TermTypeFunc, Func: &Func{Name: \"setpath\", Args: []*Query{{Func: \"$p\"}, {Left: &Query{Func: \"$v\"}, Op: OpPipe, Right: &Query{Term: &Term{Type: TermTypeFunc, Func: &Func{Name: \"getpath\", Args: []*Query{{Func: \"$p\"}}}}}}}}}}}}}}}}}}}},\n\t\t\"range\": {{Name: \"range\", Args: []string{\"$end\"}, Body: &Query{Term: &Term{Type: TermTypeFunc, Func: &Func{Name: \"_range\", Args: []*Query{{Term: &Term{Type: TermTypeNumber, Number: \"0\"}}, {Func: \"$end\"}, {Term: &Term{Type: TermTypeNumber, Number: \"1\"}}}}}}}, {Name: \"range\", Args: []string{\"$start\", \"$end\"}, Body: &Query{Term: &Term{Type: TermTypeFunc, Func: &Func{Name: \"_range\", Args: []*Query{{Func: \"$start\"}, {Func: \"$end\"}, {Term: &Term{Type: TermTypeNumber, Number: \"1\"}}}}}}}, {Name: \"range\", Args: []string{\"$start\", \"$end\", \"$step\"}, Body: &Query{Term: &Term{Type: TermTypeFunc, Func: &Func{Name: \"_range\", Args: []*Query{{Func: \"$start\"}, {Func: \"$end\"}, {Func: \"$step\"}}}}}}},\n\t\t\"recurse\": {{Name: \"recurse\", Body: &Query{Term: &Term{Type: TermTypeFunc, Func: &Func{Name: \"recurse\", Args: []*Query{{Term: &Term{Type: TermTypeIdentity, SuffixList: []*Suffix{{Iter: true}, {Optional: true}}}}}}}}}, {Name: \"recurse\", Args: []string{\"f\"}, Body: &Query{FuncDefs: []*FuncDef{{Name: \"r\", Body: &Query{Left: &Query{Func: \".\"}, Op: OpComma, Right: &Query{Term: &Term{Type: TermTypeQuery, Query: &Query{Left: &Query{Func: \"f\"}, Op: OpPipe, Right: &Query{Func: \"r\"}}}}}}}, Func: \"r\"}}, {Name: \"recurse\", Args: []string{\"f\", \"cond\"}, Body: &Query{FuncDefs: []*FuncDef{{Name: \"r\", Body: &Query{Left: &Query{Func: \".\"}, Op: OpComma, Right: &Query{Term: &Term{Type: TermTypeQuery, Query: &Query{Left: &Query{Func: \"f\"}, Op: OpPipe, Right: &Query{Left: &Query{Term: &Term{Type: TermTypeFunc, Func: &Func{Name: \"select\", Args: []*Query{{Func: \"cond\"}}}}}, Op: OpPipe, Right: &Query{Func: \"r\"}}}}}}}}, Func: \"r\"}}},\n\t\t\"repeat\": {{Name: \"repeat\", Args: []string{\"f\"}, Body: &Query{FuncDefs: []*FuncDef{{Name: \"_repeat\", Body: &Query{Left: &Query{Func: \"f\"}, Op: OpComma, Right: &Query{Func: \"_repeat\"}}}}, Func: \"_repeat\"}}},\n\t\t\"scalars\": {{Name: \"scalars\", Body: &Query{Term: &Term{Type: TermTypeFunc, Func: &Func{Name: \"select\", Args: []*Query{{Left: &Query{Func: \"type\"}, Op: OpPipe, Right: &Query{Left: &Query{Left: &Query{Func: \".\"}, Op: OpNe, Right: &Query{Term: &Term{Type: TermTypeString, Str: &String{Str: \"array\"}}}}, Op: OpAnd, Right: &Query{Left: &Query{Func: \".\"}, Op: OpNe, Right: &Query{Term: &Term{Type: TermTypeString, Str: &String{Str: \"object\"}}}}}}}}}}}},\n\t\t\"scan\": {{Name: \"scan\", Args: []string{\"$re\"}, Body: &Query{Term: &Term{Type: TermTypeFunc, Func: &Func{Name: \"scan\", Args: []*Query{{Func: \"$re\"}, {Func: \"null\"}}}}}}, {Name: \"scan\", Args: []string{\"$re\", \"$flags\"}, Body: &Query{Left: &Query{Term: &Term{Type: TermTypeFunc, Func: &Func{Name: \"match\", Args: []*Query{{Func: \"$re\"}, {Left: &Query{Func: \"$flags\"}, Op: OpAdd, Right: &Query{Term: &Term{Type: TermTypeString, Str: &String{Str: \"g\"}}}}}}}}, Op: OpPipe, Right: &Query{Term: &Term{Type: TermTypeIf, If: &If{Cond: &Query{Left: &Query{Term: &Term{Type: TermTypeIndex, Index: &Index{Name: \"captures\"}}}, Op: OpEq, Right: &Query{Term: &Term{Type: TermTypeArray, Array: &Array{}}}}, Then: &Query{Term: &Term{Type: TermTypeIndex, Index: &Index{Name: \"string\"}}}, Else: &Query{Term: &Term{Type: TermTypeArray, Array: &Array{Query: &Query{Term: &Term{Type: TermTypeIndex, Index: &Index{Name: \"captures\"}, SuffixList: []*Suffix{{Iter: true}, {Index: &Index{Name: \"string\"}}}}}}}}}}}}}},\n\t\t\"select\": {{Name: \"select\", Args: []string{\"f\"}, Body: &Query{Term: &Term{Type: TermTypeIf, If: &If{Cond: &Query{Func: \"f\"}, Then: &Query{Func: \".\"}, Else: &Query{Func: \"empty\"}}}}}},\n\t\t\"skip\": {{Name: \"skip\", Args: []string{\"$n\", \"g\"}, Body: &Query{Term: &Term{Type: TermTypeIf, If: &If{Cond: &Query{Left: &Query{Func: \"$n\"}, Op: OpGt, Right: &Query{Term: &Term{Type: TermTypeNumber, Number: \"0\"}}}, Then: &Query{Term: &Term{Type: TermTypeForeach, Foreach: &Foreach{Query: &Query{Func: \"g\"}, Pattern: &Pattern{Name: \"$item\"}, Start: &Query{Func: \"$n\"}, Update: &Query{Left: &Query{Func: \".\"}, Op: OpSub, Right: &Query{Term: &Term{Type: TermTypeNumber, Number: \"1\"}}}, Extract: &Query{Term: &Term{Type: TermTypeIf, If: &If{Cond: &Query{Left: &Query{Func: \".\"}, Op: OpLt, Right: &Query{Term: &Term{Type: TermTypeNumber, Number: \"0\"}}}, Then: &Query{Func: \"$item\"}, Else: &Query{Func: \"empty\"}}}}}}}, Elif: []*IfElif{{Cond: &Query{Left: &Query{Func: \"$n\"}, Op: OpEq, Right: &Query{Term: &Term{Type: TermTypeNumber, Number: \"0\"}}}, Then: &Query{Func: \"g\"}}}, Else: &Query{Term: &Term{Type: TermTypeFunc, Func: &Func{Name: \"error\", Args: []*Query{{Term: &Term{Type: TermTypeString, Str: &String{Str: \"skip doesn't support negative count\"}}}}}}}}}}}},\n\t\t\"sort_by\": {{Name: \"sort_by\", Args: []string{\"f\"}, Body: &Query{Term: &Term{Type: TermTypeFunc, Func: &Func{Name: \"_sort_by\", Args: []*Query{{Term: &Term{Type: TermTypeFunc, Func: &Func{Name: \"map\", Args: []*Query{{Term: &Term{Type: TermTypeArray, Array: &Array{Query: &Query{Func: \"f\"}}}}}}}}}}}}}},\n\t\t\"splits\": {{Name: \"splits\", Args: []string{\"$re\"}, Body: &Query{Term: &Term{Type: TermTypeFunc, Func: &Func{Name: \"splits\", Args: []*Query{{Func: \"$re\"}, {Func: \"null\"}}}}}}, {Name: \"splits\", Args: []string{\"$re\", \"$flags\"}, Body: &Query{Term: &Term{Type: TermTypeFunc, Func: &Func{Name: \"split\", Args: []*Query{{Func: \"$re\"}, {Func: \"$flags\"}}}, SuffixList: []*Suffix{{Iter: true}}}}}},\n\t\t\"strings\": {{Name: \"strings\", Body: &Query{Term: &Term{Type: TermTypeFunc, Func: &Func{Name: \"select\", Args: []*Query{{Left: &Query{Func: \"type\"}, Op: OpEq, Right: &Query{Term: &Term{Type: TermTypeString, Str: &String{Str: \"string\"}}}}}}}}}},\n\t\t\"sub\": {{Name: \"sub\", Args: []string{\"$re\", \"str\"}, Body: &Query{Term: &Term{Type: TermTypeFunc, Func: &Func{Name: \"sub\", Args: []*Query{{Func: \"$re\"}, {Func: \"str\"}, {Func: \"null\"}}}}}}, {Name: \"sub\", Args: []string{\"$re\", \"str\", \"$flags\"}, Body: &Query{Term: &Term{Type: TermTypeIdentity, SuffixList: []*Suffix{{Bind: &Bind{Patterns: []*Pattern{{Name: \"$str\"}}, Body: &Query{FuncDefs: []*FuncDef{{Name: \"_sub\", Body: &Query{Term: &Term{Type: TermTypeIf, If: &If{Cond: &Query{Left: &Query{Term: &Term{Type: TermTypeIndex, Index: &Index{Name: \"matches\"}}}, Op: OpEq, Right: &Query{Term: &Term{Type: TermTypeArray, Array: &Array{}}}}, Then: &Query{Left: &Query{Term: &Term{Type: TermTypeFunc, Func: &Func{Name: \"$str\"}, SuffixList: []*Suffix{{Index: &Index{End: &Query{Term: &Term{Type: TermTypeIndex, Index: &Index{Name: \"offset\"}}}, IsSlice: true}}}}}, Op: OpAdd, Right: &Query{Term: &Term{Type: TermTypeIndex, Index: &Index{Name: \"string\"}}}}, Else: &Query{Term: &Term{Type: TermTypeIndex, Index: &Index{Name: \"matches\"}, SuffixList: []*Suffix{{Index: &Index{Start: &Query{Term: &Term{Type: TermTypeUnary, Unary: &Unary{Op: OpSub, Term: &Term{Type: TermTypeNumber, Number: \"1\"}}}}}}, {Bind: &Bind{Patterns: []*Pattern{{Name: \"$r\"}}, Body: &Query{Left: &Query{Term: &Term{Type: TermTypeObject, Object: &Object{KeyVals: []*ObjectKeyVal{{Key: \"string\", Val: &Query{Left: &Query{Left: &Query{Term: &Term{Type: TermTypeQuery, Query: &Query{Left: &Query{Func: \"$r\"}, Op: OpPipe, Right: &Query{Left: &Query{Func: \"_capture\"}, Op: OpPipe, Right: &Query{Func: \"str\"}}}}}, Op: OpAdd, Right: &Query{Term: &Term{Type: TermTypeFunc, Func: &Func{Name: \"$str\"}, SuffixList: []*Suffix{{Index: &Index{Start: &Query{Left: &Query{Term: &Term{Type: TermTypeFunc, Func: &Func{Name: \"$r\"}, SuffixList: []*Suffix{{Index: &Index{Name: \"offset\"}}}}}, Op: OpAdd, Right: &Query{Term: &Term{Type: TermTypeFunc, Func: &Func{Name: \"$r\"}, SuffixList: []*Suffix{{Index: &Index{Name: \"length\"}}}}}}, End: &Query{Term: &Term{Type: TermTypeIndex, Index: &Index{Name: \"offset\"}}}, IsSlice: true}}}}}}, Op: OpAdd, Right: &Query{Term: &Term{Type: TermTypeIndex, Index: &Index{Name: \"string\"}}}}}, {Key: \"offset\", Val: &Query{Term: &Term{Type: TermTypeFunc, Func: &Func{Name: \"$r\"}, SuffixList: []*Suffix{{Index: &Index{Name: \"offset\"}}}}}}, {Key: \"matches\", Val: &Query{Term: &Term{Type: TermTypeIndex, Index: &Index{Name: \"matches\"}, SuffixList: []*Suffix{{Index: &Index{End: &Query{Term: &Term{Type: TermTypeUnary, Unary: &Unary{Op: OpSub, Term: &Term{Type: TermTypeNumber, Number: \"1\"}}}}, IsSlice: true}}}}}}}}}}, Op: OpPipe, Right: &Query{Func: \"_sub\"}}}}}}}}}}}}, Left: &Query{Term: &Term{Type: TermTypeObject, Object: &Object{KeyVals: []*ObjectKeyVal{{Key: \"string\", Val: &Query{Term: &Term{Type: TermTypeString, Str: &String{}}}}, {Key: \"matches\", Val: &Query{Term: &Term{Type: TermTypeArray, Array: &Array{Query: &Query{Term: &Term{Type: TermTypeFunc, Func: &Func{Name: \"match\", Args: []*Query{{Func: \"$re\"}, {Func: \"$flags\"}}}}}}}}}}}}}, Op: OpPipe, Right: &Query{Func: \"_sub\"}}}}}}}}},\n\t\t\"test\": {{Name: \"test\", Args: []string{\"$re\"}, Body: &Query{Term: &Term{Type: TermTypeFunc, Func: &Func{Name: \"test\", Args: []*Query{{Func: \"$re\"}, {Func: \"null\"}}}}}}, {Name: \"test\", Args: []string{\"$re\", \"$flags\"}, Body: &Query{Term: &Term{Type: TermTypeFunc, Func: &Func{Name: \"_match\", Args: []*Query{{Func: \"$re\"}, {Func: \"$flags\"}, {Func: \"true\"}}}}}}},\n\t\t\"todate\": {{Name: \"todate\", Body: &Query{Func: \"todateiso8601\"}}},\n\t\t\"todateiso8601\": {{Name: \"todateiso8601\", Body: &Query{Term: &Term{Type: TermTypeFunc, Func: &Func{Name: \"strftime\", Args: []*Query{{Term: &Term{Type: TermTypeString, Str: &String{Str: \"%Y-%m-%dT%H:%M:%SZ\"}}}}}}}}},\n\t\t\"tostream\": {{Name: \"tostream\", Body: &Query{Term: &Term{Type: TermTypeFunc, Func: &Func{Name: \"path\", Args: []*Query{{FuncDefs: []*FuncDef{{Name: \"r\", Body: &Query{Left: &Query{Term: &Term{Type: TermTypeQuery, Query: &Query{Left: &Query{Term: &Term{Type: TermTypeIdentity, SuffixList: []*Suffix{{Iter: true}, {Optional: true}}}}, Op: OpPipe, Right: &Query{Func: \"r\"}}}}, Op: OpComma, Right: &Query{Func: \".\"}}}}, Func: \"r\"}}}, SuffixList: []*Suffix{{Bind: &Bind{Patterns: []*Pattern{{Name: \"$p\"}}, Body: &Query{Left: &Query{Term: &Term{Type: TermTypeFunc, Func: &Func{Name: \"getpath\", Args: []*Query{{Func: \"$p\"}}}}}, Op: OpPipe, Right: &Query{Term: &Term{Type: TermTypeReduce, Reduce: &Reduce{Query: &Query{Term: &Term{Type: TermTypeFunc, Func: &Func{Name: \"path\", Args: []*Query{{Term: &Term{Type: TermTypeIdentity, SuffixList: []*Suffix{{Iter: true}, {Optional: true}}}}}}}}, Pattern: &Pattern{Name: \"$q\"}, Start: &Query{Term: &Term{Type: TermTypeArray, Array: &Array{Query: &Query{Left: &Query{Func: \"$p\"}, Op: OpComma, Right: &Query{Func: \".\"}}}}}, Update: &Query{Term: &Term{Type: TermTypeArray, Array: &Array{Query: &Query{Left: &Query{Func: \"$p\"}, Op: OpAdd, Right: &Query{Func: \"$q\"}}}}}}}}}}}}}}}},\n\t\t\"truncate_stream\": {{Name: \"truncate_stream\", Args: []string{\"f\"}, Body: &Query{Term: &Term{Type: TermTypeIdentity, SuffixList: []*Suffix{{Bind: &Bind{Patterns: []*Pattern{{Name: \"$n\"}}, Body: &Query{Left: &Query{Func: \"null\"}, Op: OpPipe, Right: &Query{Left: &Query{Func: \"f\"}, Op: OpPipe, Right: &Query{Term: &Term{Type: TermTypeIf, If: &If{Cond: &Query{Left: &Query{Term: &Term{Type: TermTypeIndex, Index: &Index{Start: &Query{Term: &Term{Type: TermTypeNumber, Number: \"0\"}}}}}, Op: OpPipe, Right: &Query{Left: &Query{Func: \"length\"}, Op: OpGt, Right: &Query{Func: \"$n\"}}}, Then: &Query{Left: &Query{Term: &Term{Type: TermTypeIndex, Index: &Index{Start: &Query{Term: &Term{Type: TermTypeNumber, Number: \"0\"}}}}}, Op: OpModify, Right: &Query{Term: &Term{Type: TermTypeIndex, Index: &Index{Start: &Query{Func: \"$n\"}, IsSlice: true}}}}, Else: &Query{Func: \"empty\"}}}}}}}}}}}}},\n\t\t\"unique_by\": {{Name: \"unique_by\", Args: []string{\"f\"}, Body: &Query{Term: &Term{Type: TermTypeFunc, Func: &Func{Name: \"_unique_by\", Args: []*Query{{Term: &Term{Type: TermTypeFunc, Func: &Func{Name: \"map\", Args: []*Query{{Term: &Term{Type: TermTypeArray, Array: &Array{Query: &Query{Func: \"f\"}}}}}}}}}}}}}},\n\t\t\"until\": {{Name: \"until\", Args: []string{\"cond\", \"next\"}, Body: &Query{FuncDefs: []*FuncDef{{Name: \"_until\", Body: &Query{Term: &Term{Type: TermTypeIf, If: &If{Cond: &Query{Func: \"cond\"}, Then: &Query{Func: \".\"}, Else: &Query{Left: &Query{Func: \"next\"}, Op: OpPipe, Right: &Query{Func: \"_until\"}}}}}}}, Func: \"_until\"}}},\n\t\t\"values\": {{Name: \"values\", Body: &Query{Term: &Term{Type: TermTypeFunc, Func: &Func{Name: \"select\", Args: []*Query{{Left: &Query{Func: \".\"}, Op: OpNe, Right: &Query{Func: \"null\"}}}}}}}},\n\t\t\"walk\": {{Name: \"walk\", Args: []string{\"f\"}, Body: &Query{FuncDefs: []*FuncDef{{Name: \"_walk\", Body: &Query{Left: &Query{Term: &Term{Type: TermTypeIf, If: &If{Cond: &Query{Left: &Query{Func: \"type\"}, Op: OpEq, Right: &Query{Term: &Term{Type: TermTypeString, Str: &String{Str: \"array\"}}}}, Then: &Query{Term: &Term{Type: TermTypeFunc, Func: &Func{Name: \"map\", Args: []*Query{{Func: \"_walk\"}}}}}, Elif: []*IfElif{{Cond: &Query{Left: &Query{Func: \"type\"}, Op: OpEq, Right: &Query{Term: &Term{Type: TermTypeString, Str: &String{Str: \"object\"}}}}, Then: &Query{Term: &Term{Type: TermTypeFunc, Func: &Func{Name: \"map_values\", Args: []*Query{{Func: \"_walk\"}}}}}}}}}}, Op: OpPipe, Right: &Query{Func: \"f\"}}}}, Func: \"_walk\"}}},\n\t\t\"while\": {{Name: \"while\", Args: []string{\"cond\", \"update\"}, Body: &Query{FuncDefs: []*FuncDef{{Name: \"_while\", Body: &Query{Term: &Term{Type: TermTypeIf, If: &If{Cond: &Query{Func: \"cond\"}, Then: &Query{Left: &Query{Func: \".\"}, Op: OpComma, Right: &Query{Term: &Term{Type: TermTypeQuery, Query: &Query{Left: &Query{Func: \"update\"}, Op: OpPipe, Right: &Query{Func: \"_while\"}}}}}, Else: &Query{Func: \"empty\"}}}}}}, Func: \"_while\"}}},\n\t\t\"with_entries\": {{Name: \"with_entries\", Args: []string{\"f\"}, Body: &Query{Left: &Query{Func: \"to_entries\"}, Op: OpPipe, Right: &Query{Left: &Query{Term: &Term{Type: TermTypeFunc, Func: &Func{Name: \"map\", Args: []*Query{{Func: \"f\"}}}}}, Op: OpPipe, Right: &Query{Func: \"from_entries\"}}}}},\n\t}\n}\n"
        },
        {
          "name": "builtin.jq",
          "type": "blob",
          "size": 5,
          "content": "def not: if . then false else true end;\ndef in(xs): . as $x | xs | has($x);\ndef map(f): [.[] | f];\ndef with_entries(f): to_entries | map(f) | from_entries;\ndef select(f): if f then . else empty end;\ndef recurse: recurse(.[]?);\ndef recurse(f): def r: ., (f | r); r;\ndef recurse(f; cond): def r: ., (f | select(cond) | r); r;\n\ndef while(cond; update):\n  def _while: if cond then ., (update | _while) else empty end;\n  _while;\ndef until(cond; next):\n  def _until: if cond then . else next | _until end;\n  _until;\ndef repeat(f):\n  def _repeat: f, _repeat;\n  _repeat;\ndef range($end): _range(0; $end; 1);\ndef range($start; $end): _range($start; $end; 1);\ndef range($start; $end; $step): _range($start; $end; $step);\n\ndef add(f): [f] | add;\ndef min_by(f): _min_by(map([f]));\ndef max_by(f): _max_by(map([f]));\ndef sort_by(f): _sort_by(map([f]));\ndef group_by(f): _group_by(map([f]));\ndef unique_by(f): _unique_by(map([f]));\n\ndef arrays: select(type == \"array\");\ndef objects: select(type == \"object\");\ndef iterables: select(type | . == \"array\" or . == \"object\");\ndef booleans: select(type == \"boolean\");\ndef numbers: select(type == \"number\");\ndef finites: select(isfinite);\ndef normals: select(isnormal);\ndef strings: select(type == \"string\");\ndef nulls: select(. == null);\ndef values: select(. != null);\ndef scalars: select(type | . != \"array\" and . != \"object\");\n\ndef inside(xs): . as $x | xs | contains($x);\ndef combinations:\n  if length == 0 then\n    []\n  else\n    .[0][] as $x | [$x] + (.[1:] | combinations)\n  end;\ndef combinations(n): [limit(n; repeat(.))] | combinations;\ndef walk(f):\n  def _walk:\n    if type == \"array\" then\n      map(_walk)\n    elif type == \"object\" then\n      map_values(_walk)\n    end | f;\n  _walk;\n\ndef first: .[0];\ndef first(g): label $out | g | ., break $out;\ndef last: .[-1];\ndef isempty(g): label $out | (g | false, break $out), true;\ndef all: all(.);\ndef all(y): all(.[]; y);\ndef all(g; y): isempty(g | select(y | not));\ndef any: any(.);\ndef any(y): any(.[]; y);\ndef any(g; y): isempty(g | select(y)) | not;\ndef limit($n; g):\n  if $n > 0 then\n    label $out |\n    foreach g as $item (\n      $n;\n      . - 1;\n      $item, if . <= 0 then break $out else empty end\n    )\n  elif $n == 0 then\n    empty\n  else\n    error(\"limit doesn't support negative count\")\n  end;\ndef skip($n; g):\n  if $n > 0 then\n    foreach g as $item (\n      $n;\n      . - 1;\n      if . < 0 then $item else empty end\n    )\n  elif $n == 0 then\n    g\n  else\n    error(\"skip doesn't support negative count\")\n  end;\ndef nth($n): .[$n];\ndef nth($n; g):\n  if $n >= 0 then\n    first(skip($n; g))\n  else\n    error(\"nth doesn't support negative index\")\n  end;\n\ndef truncate_stream(f):\n  . as $n | null | f |\n  if .[0] | length > $n then .[0] |= .[$n:] else empty end;\ndef fromstream(f):\n  foreach f as $pv (\n    null;\n    if .e then null end |\n    $pv as [$p, $v] |\n    if $pv | length == 2 then\n      setpath([\"v\"] + $p; $v) |\n      setpath([\"e\"]; $p | length == 0)\n    else\n      setpath([\"e\"]; $p | length == 1)\n    end;\n    if .e then .v else empty end\n  );\ndef tostream:\n  path(def r: (.[]? | r), .; r) as $p |\n  getpath($p) |\n  reduce path(.[]?) as $q ([$p, .]; [$p + $q]);\n\ndef map_values(f): .[] |= f;\ndef del(f): delpaths([path(f)]);\ndef paths: path(..) | select(. != []);\ndef paths(f): path(.. | select(f)) | select(. != []);\ndef pick(f): . as $v |\n  reduce path(f) as $p (null; setpath($p; $v | getpath($p)));\n\ndef fromdateiso8601: strptime(\"%Y-%m-%dT%H:%M:%S%z\") | mktime;\ndef todateiso8601: strftime(\"%Y-%m-%dT%H:%M:%SZ\");\ndef fromdate: fromdateiso8601;\ndef todate: todateiso8601;\n\ndef match($re): match($re; null);\ndef match($re; $flags): _match($re; $flags; false)[];\ndef test($re): test($re; null);\ndef test($re; $flags): _match($re; $flags; true);\ndef capture($re): capture($re; null);\ndef capture($re; $flags): match($re; $flags) | _capture;\ndef scan($re): scan($re; null);\ndef scan($re; $flags):\n  match($re; $flags + \"g\") |\n  if .captures == [] then\n    .string\n  else\n    [.captures[].string]\n  end;\ndef splits($re): splits($re; null);\ndef splits($re; $flags): split($re; $flags)[];\ndef sub($re; str): sub($re; str; null);\ndef sub($re; str; $flags):\n  . as $str |\n  def _sub:\n    if .matches == [] then\n      $str[:.offset] + .string\n    else\n      .matches[-1] as $r |\n      {\n        string: ($r | _capture | str) + $str[$r.offset+$r.length:.offset] + .string,\n        offset: $r.offset,\n        matches: .matches[:-1],\n      } |\n      _sub\n    end;\n  { string: \"\", matches: [match($re; $flags)] } | _sub;\ndef gsub($re; str): sub($re; str; \"g\");\ndef gsub($re; str; $flags): sub($re; str; $flags + \"g\");\n\ndef inputs:\n  try\n    repeat(input)\n  catch\n    if . == \"break\" then empty else error end;\n\ndef INDEX(stream; idx_expr):\n  reduce stream as $row ({}; .[$row | idx_expr | tostring] = $row);\ndef INDEX(idx_expr):\n  INDEX(.[]; idx_expr);\ndef JOIN($idx; idx_expr):\n  [.[] | [., $idx[idx_expr]]];\ndef JOIN($idx; stream; idx_expr):\n  stream | [., $idx[idx_expr]];\ndef JOIN($idx; stream; idx_expr; join_expr):\n  stream | [., $idx[idx_expr]] | join_expr;\ndef IN(s): any(s == .; .);\ndef IN(src; s): any(src == s; .);\n"
        },
        {
          "name": "cli",
          "type": "tree",
          "content": null
        },
        {
          "name": "cmd",
          "type": "tree",
          "content": null
        },
        {
          "name": "code.go",
          "type": "blob",
          "size": 1.4658203125,
          "content": "package gojq\n\ntype code struct {\n\tv  any\n\top opcode\n}\n\ntype opcode int\n\nconst (\n\topnop opcode = iota\n\toppush\n\toppop\n\topdup\n\topconst\n\topload\n\topstore\n\topobject\n\topappend\n\topfork\n\topforktrybegin\n\topforktryend\n\topforkalt\n\topforklabel\n\topbacktrack\n\topjump\n\topjumpifnot\n\topindex\n\topindexarray\n\topcall\n\topcallrec\n\toppushpc\n\topcallpc\n\topscope\n\topret\n\topiter\n\topexpbegin\n\topexpend\n\toppathbegin\n\toppathend\n)\n\nfunc (op opcode) String() string {\n\tswitch op {\n\tcase opnop:\n\t\treturn \"nop\"\n\tcase oppush:\n\t\treturn \"push\"\n\tcase oppop:\n\t\treturn \"pop\"\n\tcase opdup:\n\t\treturn \"dup\"\n\tcase opconst:\n\t\treturn \"const\"\n\tcase opload:\n\t\treturn \"load\"\n\tcase opstore:\n\t\treturn \"store\"\n\tcase opobject:\n\t\treturn \"object\"\n\tcase opappend:\n\t\treturn \"append\"\n\tcase opfork:\n\t\treturn \"fork\"\n\tcase opforktrybegin:\n\t\treturn \"forktrybegin\"\n\tcase opforktryend:\n\t\treturn \"forktryend\"\n\tcase opforkalt:\n\t\treturn \"forkalt\"\n\tcase opforklabel:\n\t\treturn \"forklabel\"\n\tcase opbacktrack:\n\t\treturn \"backtrack\"\n\tcase opjump:\n\t\treturn \"jump\"\n\tcase opjumpifnot:\n\t\treturn \"jumpifnot\"\n\tcase opindex:\n\t\treturn \"index\"\n\tcase opindexarray:\n\t\treturn \"indexarray\"\n\tcase opcall:\n\t\treturn \"call\"\n\tcase opcallrec:\n\t\treturn \"callrec\"\n\tcase oppushpc:\n\t\treturn \"pushpc\"\n\tcase opcallpc:\n\t\treturn \"callpc\"\n\tcase opscope:\n\t\treturn \"scope\"\n\tcase opret:\n\t\treturn \"ret\"\n\tcase opiter:\n\t\treturn \"iter\"\n\tcase opexpbegin:\n\t\treturn \"expbegin\"\n\tcase opexpend:\n\t\treturn \"expend\"\n\tcase oppathbegin:\n\t\treturn \"pathbegin\"\n\tcase oppathend:\n\t\treturn \"pathend\"\n\tdefault:\n\t\tpanic(op)\n\t}\n}\n"
        },
        {
          "name": "compare.go",
          "type": "blob",
          "size": 1.5302734375,
          "content": "package gojq\n\nimport (\n\t\"math\"\n\t\"math/big\"\n)\n\n// Compare l and r, and returns jq-flavored comparison value.\n// The result will be 0 if l == r, -1 if l < r, and +1 if l > r.\n// This comparison is used by built-in operators and functions.\nfunc Compare(l, r any) int {\n\treturn binopTypeSwitch(l, r,\n\t\tcompareInt,\n\t\tfunc(l, r float64) any {\n\t\t\tswitch {\n\t\t\tcase l < r || math.IsNaN(l):\n\t\t\t\treturn -1\n\t\t\tcase l == r:\n\t\t\t\treturn 0\n\t\t\tdefault:\n\t\t\t\treturn 1\n\t\t\t}\n\t\t},\n\t\tfunc(l, r *big.Int) any {\n\t\t\treturn l.Cmp(r)\n\t\t},\n\t\tfunc(l, r string) any {\n\t\t\tswitch {\n\t\t\tcase l < r:\n\t\t\t\treturn -1\n\t\t\tcase l == r:\n\t\t\t\treturn 0\n\t\t\tdefault:\n\t\t\t\treturn 1\n\t\t\t}\n\t\t},\n\t\tfunc(l, r []any) any {\n\t\t\tfor i, n := 0, min(len(l), len(r)); i < n; i++ {\n\t\t\t\tif cmp := Compare(l[i], r[i]); cmp != 0 {\n\t\t\t\t\treturn cmp\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn compareInt(len(l), len(r))\n\t\t},\n\t\tfunc(l, r map[string]any) any {\n\t\t\tlk, rk := funcKeys(l), funcKeys(r)\n\t\t\tif cmp := Compare(lk, rk); cmp != 0 {\n\t\t\t\treturn cmp\n\t\t\t}\n\t\t\tfor _, k := range lk.([]any) {\n\t\t\t\tif cmp := Compare(l[k.(string)], r[k.(string)]); cmp != 0 {\n\t\t\t\t\treturn cmp\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn 0\n\t\t},\n\t\tfunc(l, r any) any {\n\t\t\treturn compareInt(typeIndex(l), typeIndex(r))\n\t\t},\n\t).(int)\n}\n\nfunc compareInt(l, r int) any {\n\tswitch {\n\tcase l < r:\n\t\treturn -1\n\tcase l == r:\n\t\treturn 0\n\tdefault:\n\t\treturn 1\n\t}\n}\n\nfunc typeIndex(v any) int {\n\tswitch v := v.(type) {\n\tdefault:\n\t\treturn 0\n\tcase bool:\n\t\tif !v {\n\t\t\treturn 1\n\t\t}\n\t\treturn 2\n\tcase int, float64, *big.Int:\n\t\treturn 3\n\tcase string:\n\t\treturn 4\n\tcase []any:\n\t\treturn 5\n\tcase map[string]any:\n\t\treturn 6\n\t}\n}\n"
        },
        {
          "name": "compare_test.go",
          "type": "blob",
          "size": 1.8564453125,
          "content": "package gojq_test\n\nimport (\n\t\"fmt\"\n\t\"math\"\n\t\"math/big\"\n\t\"testing\"\n\n\t\"github.com/itchyny/gojq\"\n)\n\nfunc TestCompare(t *testing.T) {\n\ttestCases := []struct {\n\t\tl, r     any\n\t\texpected int\n\t}{\n\t\t{nil, nil, 0},\n\t\t{nil, false, -1},\n\t\t{false, nil, 1},\n\t\t{false, false, 0},\n\t\t{false, true, -1},\n\t\t{true, false, 1},\n\t\t{true, true, 0},\n\t\t{true, 0, -1},\n\t\t{0, true, 1},\n\t\t{0, 0, 0},\n\t\t{0, 1, -1},\n\t\t{1, 0, 1},\n\t\t{1, 1, 0},\n\t\t{0, math.NaN(), 1},\n\t\t{math.NaN(), 0, -1},\n\t\t{math.NaN(), math.NaN(), -1},\n\t\t{1, 1.00, 0},\n\t\t{1.00, 1, 0},\n\t\t{1.00, 1.01, -1},\n\t\t{1.01, 1.00, 1},\n\t\t{1.01, 1.01, 0},\n\t\t{1, big.NewInt(0), 1},\n\t\t{big.NewInt(0), 1, -1},\n\t\t{0, big.NewInt(0), 0},\n\t\t{1, \"\", -1},\n\t\t{\"\", 1, 1},\n\t\t{\"\", \"\", 0},\n\t\t{\"\", \"abc\", -1},\n\t\t{\"abc\", \"\", 1},\n\t\t{\"abc\", \"abc\", 0},\n\t\t{\"\", []any{}, -1},\n\t\t{[]any{}, \"\", 1},\n\t\t{[]any{}, []any{}, 0},\n\t\t{[]any{}, []any{nil}, -1},\n\t\t{[]any{nil}, []any{}, 1},\n\t\t{[]any{nil}, []any{nil}, 0},\n\t\t{[]any{0, 1, 2}, []any{0, 1, nil}, 1},\n\t\t{[]any{0, 1, 2}, []any{0, 1, 2, nil}, -1},\n\t\t{[]any{0, 1, 2, false, nil}, []any{0, 1, 2, nil, false}, 1},\n\t\t{[]any{}, map[string]any{}, -1},\n\t\t{map[string]any{}, []any{}, 1},\n\t\t{map[string]any{}, map[string]any{}, 0},\n\t\t{map[string]any{\"a\": nil}, map[string]any{\"a\": nil}, 0},\n\t\t{map[string]any{\"a\": nil}, map[string]any{\"a\": nil, \"b\": nil}, -1},\n\t\t{map[string]any{\"a\": nil, \"b\": nil}, map[string]any{\"a\": nil, \"c\": nil}, -1},\n\t\t{map[string]any{\"a\": 0, \"b\": 0, \"c\": 0}, map[string]any{\"a\": 0, \"b\": 0, \"c\": 0}, 0},\n\t\t{map[string]any{\"a\": 0, \"b\": 0, \"d\": 0}, map[string]any{\"a\": 0, \"b\": 1, \"c\": 0}, 1},\n\t\t{map[string]any{\"a\": 0, \"b\": 1, \"c\": 2}, map[string]any{\"a\": 0, \"b\": 2, \"c\": 1}, -1},\n\t}\n\tfor _, tc := range testCases {\n\t\tt.Run(fmt.Sprintf(\"%v,%v\", tc.l, tc.r), func(t *testing.T) {\n\t\t\tgot := gojq.Compare(tc.l, tc.r)\n\t\t\tif got != tc.expected {\n\t\t\t\tt.Errorf(\"Compare(%v, %v): got %d, expected %d\", tc.l, tc.r, got, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}\n"
        },
        {
          "name": "compiler.go",
          "type": "blob",
          "size": 42.814453125,
          "content": "package gojq\n\nimport (\n\t\"context\"\n\t\"errors\"\n\t\"fmt\"\n\t\"sort\"\n\t\"strconv\"\n\t\"strings\"\n)\n\ntype compiler struct {\n\tmoduleLoader  ModuleLoader\n\tenvironLoader func() []string\n\tvariables     []string\n\tcustomFuncs   map[string]function\n\tinputIter     Iter\n\tcodes         []*code\n\tcodeinfos     []codeinfo\n\tbuiltinScope  *scopeinfo\n\tscopes        []*scopeinfo\n\tscopecnt      int\n}\n\n// Code is a compiled jq query.\ntype Code struct {\n\tvariables []string\n\tcodes     []*code\n\tcodeinfos []codeinfo\n}\n\n// Run runs the code with the variable values (which should be in the\n// same order as the given variables using [WithVariables]) and returns\n// a result iterator.\n//\n// It is safe to call this method in goroutines, to reuse a compiled [*Code].\n// But for arguments, do not give values sharing same data between goroutines.\nfunc (c *Code) Run(v any, values ...any) Iter {\n\treturn c.RunWithContext(context.Background(), v, values...)\n}\n\n// RunWithContext runs the code with context.\nfunc (c *Code) RunWithContext(ctx context.Context, v any, values ...any) Iter {\n\tif len(values) > len(c.variables) {\n\t\treturn NewIter(&tooManyVariableValuesError{})\n\t} else if len(values) < len(c.variables) {\n\t\treturn NewIter(&expectedVariableError{c.variables[len(values)]})\n\t}\n\tfor i, v := range values {\n\t\tvalues[i] = normalizeNumbers(v)\n\t}\n\treturn newEnv(ctx).execute(c, normalizeNumbers(v), values...)\n}\n\ntype scopeinfo struct {\n\tvariables   []*varinfo\n\tfuncs       []*funcinfo\n\tid          int\n\tdepth       int\n\tvariablecnt int\n}\n\ntype varinfo struct {\n\tname  string\n\tindex [2]int\n\tdepth int\n}\n\ntype funcinfo struct {\n\tname   string\n\tpc     int\n\targcnt int\n}\n\n// Compile compiles a query.\nfunc Compile(q *Query, options ...CompilerOption) (*Code, error) {\n\tc := &compiler{}\n\tfor _, opt := range options {\n\t\topt(c)\n\t}\n\tc.builtinScope = c.newScope()\n\tscope := c.newScope()\n\tc.scopes = []*scopeinfo{scope}\n\tsetscope := c.lazy(func() *code {\n\t\treturn &code{op: opscope, v: [3]int{scope.id, scope.variablecnt, 0}}\n\t})\n\tfor _, name := range c.variables {\n\t\tif !newLexer(name).validVarName() {\n\t\t\treturn nil, &variableNameError{name}\n\t\t}\n\t\tc.appendCodeInfo(name)\n\t\tc.append(&code{op: opstore, v: c.pushVariable(name)})\n\t}\n\tif c.moduleLoader != nil {\n\t\tif moduleLoader, ok := c.moduleLoader.(interface {\n\t\t\tLoadInitModules() ([]*Query, error)\n\t\t}); ok {\n\t\t\tqs, err := moduleLoader.LoadInitModules()\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\tfor _, q := range qs {\n\t\t\t\tif err := c.compileModule(q, \"\"); err != nil {\n\t\t\t\t\treturn nil, err\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif err := c.compile(q); err != nil {\n\t\treturn nil, err\n\t}\n\tsetscope()\n\tc.optimizeTailRec()\n\tc.optimizeCodeOps()\n\treturn &Code{\n\t\tvariables: c.variables,\n\t\tcodes:     c.codes,\n\t\tcodeinfos: c.codeinfos,\n\t}, nil\n}\n\nfunc (c *compiler) compile(q *Query) error {\n\tfor _, i := range q.Imports {\n\t\tif err := c.compileImport(i); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\tif err := c.compileQuery(q); err != nil {\n\t\treturn err\n\t}\n\tc.append(&code{op: opret})\n\treturn nil\n}\n\nfunc (c *compiler) compileImport(i *Import) error {\n\tvar path, alias string\n\tvar err error\n\tif i.ImportPath != \"\" {\n\t\tpath, alias = i.ImportPath, i.ImportAlias\n\t} else {\n\t\tpath = i.IncludePath\n\t}\n\tif c.moduleLoader == nil {\n\t\treturn fmt.Errorf(\"cannot load module: %q\", path)\n\t}\n\tif strings.HasPrefix(alias, \"$\") {\n\t\tvar vals any\n\t\tif moduleLoader, ok := c.moduleLoader.(interface {\n\t\t\tLoadJSONWithMeta(string, map[string]any) (any, error)\n\t\t}); ok {\n\t\t\tif vals, err = moduleLoader.LoadJSONWithMeta(path, i.Meta.ToValue()); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t} else if moduleLoader, ok := c.moduleLoader.(interface {\n\t\t\tLoadJSON(string) (any, error)\n\t\t}); ok {\n\t\t\tif vals, err = moduleLoader.LoadJSON(path); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t} else {\n\t\t\treturn fmt.Errorf(\"module not found: %q\", path)\n\t\t}\n\t\tvals = normalizeNumbers(vals)\n\t\tc.append(&code{op: oppush, v: vals})\n\t\tc.append(&code{op: opstore, v: c.pushVariable(alias)})\n\t\tc.append(&code{op: oppush, v: vals})\n\t\tc.append(&code{op: opstore, v: c.pushVariable(alias + \"::\" + alias[1:])})\n\t\treturn nil\n\t}\n\tvar q *Query\n\tif moduleLoader, ok := c.moduleLoader.(interface {\n\t\tLoadModuleWithMeta(string, map[string]any) (*Query, error)\n\t}); ok {\n\t\tif q, err = moduleLoader.LoadModuleWithMeta(path, i.Meta.ToValue()); err != nil {\n\t\t\treturn err\n\t\t}\n\t} else if moduleLoader, ok := c.moduleLoader.(interface {\n\t\tLoadModule(string) (*Query, error)\n\t}); ok {\n\t\tif q, err = moduleLoader.LoadModule(path); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\tc.appendCodeInfo(\"module \" + path)\n\tif err = c.compileModule(q, alias); err != nil {\n\t\treturn err\n\t}\n\tc.appendCodeInfo(\"end of module \" + path)\n\treturn nil\n}\n\nfunc (c *compiler) compileModule(q *Query, alias string) error {\n\tscope := c.scopes[len(c.scopes)-1]\n\tscope.depth++\n\tdefer func(l int) {\n\t\tscope.depth--\n\t\tscope.variables = scope.variables[:l]\n\t}(len(scope.variables))\n\tif alias != \"\" {\n\t\tdefer func(l int) {\n\t\t\tfor _, f := range scope.funcs[l:] {\n\t\t\t\tf.name = alias + \"::\" + f.name\n\t\t\t}\n\t\t}(len(scope.funcs))\n\t}\n\tfor _, i := range q.Imports {\n\t\tif err := c.compileImport(i); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\tfor _, fd := range q.FuncDefs {\n\t\tif err := c.compileFuncDef(fd, false); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc (c *compiler) newVariable() [2]int {\n\treturn c.createVariable(\"\")\n}\n\nfunc (c *compiler) pushVariable(name string) [2]int {\n\ts := c.scopes[len(c.scopes)-1]\n\tfor _, v := range s.variables {\n\t\tif v.name == name && v.depth == s.depth {\n\t\t\treturn v.index\n\t\t}\n\t}\n\treturn c.createVariable(name)\n}\n\nfunc (c *compiler) createVariable(name string) [2]int {\n\ts := c.scopes[len(c.scopes)-1]\n\tv := [2]int{s.id, s.variablecnt}\n\ts.variablecnt++\n\ts.variables = append(s.variables, &varinfo{name, v, s.depth})\n\treturn v\n}\n\nfunc (c *compiler) lookupVariable(name string) ([2]int, error) {\n\tfor i := len(c.scopes) - 1; i >= 0; i-- {\n\t\ts := c.scopes[i]\n\t\tfor j := len(s.variables) - 1; j >= 0; j-- {\n\t\t\tif w := s.variables[j]; w.name == name {\n\t\t\t\treturn w.index, nil\n\t\t\t}\n\t\t}\n\t}\n\treturn [2]int{}, &variableNotFoundError{name}\n}\n\nfunc (c *compiler) lookupFuncOrVariable(name string) (*funcinfo, *varinfo) {\n\tfor i, isFunc := len(c.scopes)-1, name[0] != '$'; i >= 0; i-- {\n\t\ts := c.scopes[i]\n\t\tif isFunc {\n\t\t\tfor j := len(s.funcs) - 1; j >= 0; j-- {\n\t\t\t\tif f := s.funcs[j]; f.name == name && f.argcnt == 0 {\n\t\t\t\t\treturn f, nil\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor j := len(s.variables) - 1; j >= 0; j-- {\n\t\t\tif v := s.variables[j]; v.name == name {\n\t\t\t\treturn nil, v\n\t\t\t}\n\t\t}\n\t}\n\treturn nil, nil\n}\n\nfunc (c *compiler) lookupBuiltin(name string, argcnt int) *funcinfo {\n\ts := c.builtinScope\n\tfor i := len(s.funcs) - 1; i >= 0; i-- {\n\t\tif f := s.funcs[i]; f.name == name && f.argcnt == argcnt {\n\t\t\treturn f\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc (c *compiler) appendBuiltin(name string, argcnt int) func() {\n\tsetjump := c.lazy(func() *code {\n\t\treturn &code{op: opjump, v: len(c.codes)}\n\t})\n\tc.appendCodeInfo(name)\n\tc.builtinScope.funcs = append(\n\t\tc.builtinScope.funcs,\n\t\t&funcinfo{name, len(c.codes), argcnt},\n\t)\n\treturn func() {\n\t\tsetjump()\n\t\tc.appendCodeInfo(\"end of \" + name)\n\t}\n}\n\nfunc (c *compiler) newScope() *scopeinfo {\n\ti := c.scopecnt // do not use len(c.scopes) because it pops\n\tc.scopecnt++\n\treturn &scopeinfo{id: i}\n}\n\nfunc (c *compiler) newScopeDepth() func() {\n\tscope := c.scopes[len(c.scopes)-1]\n\tl, m := len(scope.variables), len(scope.funcs)\n\tscope.depth++\n\treturn func() {\n\t\tscope.depth--\n\t\tscope.variables = scope.variables[:l]\n\t\tscope.funcs = scope.funcs[:m]\n\t}\n}\n\nfunc (c *compiler) compileFuncDef(e *FuncDef, builtin bool) error {\n\tvar scope *scopeinfo\n\tif builtin {\n\t\tscope = c.builtinScope\n\t} else {\n\t\tscope = c.scopes[len(c.scopes)-1]\n\t}\n\tdefer c.lazy(func() *code {\n\t\treturn &code{op: opjump, v: len(c.codes)}\n\t})()\n\tc.appendCodeInfo(e.Name)\n\tscope.funcs = append(scope.funcs, &funcinfo{e.Name, len(c.codes), len(e.Args)})\n\tdefer func(scopes []*scopeinfo, variables []string) {\n\t\tc.scopes, c.variables = scopes, variables\n\t}(c.scopes, c.variables)\n\tc.variables = c.variables[len(c.variables):]\n\tscope = c.newScope()\n\tif builtin {\n\t\tc.scopes = []*scopeinfo{c.builtinScope, scope}\n\t} else {\n\t\tc.scopes = append(c.scopes, scope)\n\t}\n\tdefer c.lazy(func() *code {\n\t\treturn &code{op: opscope, v: [3]int{scope.id, scope.variablecnt, len(e.Args)}}\n\t})()\n\tif len(e.Args) > 0 {\n\t\ttype varIndex struct {\n\t\t\tname  string\n\t\t\tindex [2]int\n\t\t}\n\t\tvis := make([]varIndex, 0, len(e.Args))\n\t\tv := c.newVariable()\n\t\tc.append(&code{op: opstore, v: v})\n\t\tfor _, arg := range e.Args {\n\t\t\tif arg[0] == '$' {\n\t\t\t\tc.appendCodeInfo(arg[1:])\n\t\t\t\tw := c.createVariable(arg[1:])\n\t\t\t\tc.append(&code{op: opstore, v: w})\n\t\t\t\tvis = append(vis, varIndex{arg, w})\n\t\t\t} else {\n\t\t\t\tc.appendCodeInfo(arg)\n\t\t\t\tc.append(&code{op: opstore, v: c.createVariable(arg)})\n\t\t\t}\n\t\t}\n\t\tfor _, w := range vis {\n\t\t\tc.append(&code{op: opload, v: v})\n\t\t\tc.append(&code{op: opexpbegin})\n\t\t\tc.append(&code{op: opload, v: w.index})\n\t\t\tc.append(&code{op: opcallpc})\n\t\t\tc.appendCodeInfo(w.name)\n\t\t\tc.append(&code{op: opstore, v: c.pushVariable(w.name)})\n\t\t\tc.append(&code{op: opexpend})\n\t\t}\n\t\tc.append(&code{op: opload, v: v})\n\t}\n\tif err := c.compile(e.Body); err != nil {\n\t\treturn err\n\t}\n\tc.appendCodeInfo(\"end of \" + e.Name)\n\treturn nil\n}\n\nfunc (c *compiler) compileQuery(e *Query) error {\n\tfor _, fd := range e.FuncDefs {\n\t\tif err := c.compileFuncDef(fd, false); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\tif e.Func != \"\" {\n\t\tswitch e.Func {\n\t\tcase \".\":\n\t\t\treturn c.compileTerm(&Term{Type: TermTypeIdentity})\n\t\tcase \"..\":\n\t\t\treturn c.compileTerm(&Term{Type: TermTypeRecurse})\n\t\tcase \"null\":\n\t\t\treturn c.compileTerm(&Term{Type: TermTypeNull})\n\t\tcase \"true\":\n\t\t\treturn c.compileTerm(&Term{Type: TermTypeTrue})\n\t\tcase \"false\":\n\t\t\treturn c.compileTerm(&Term{Type: TermTypeFalse})\n\t\tdefault:\n\t\t\treturn c.compileFunc(&Func{Name: e.Func})\n\t\t}\n\t} else if e.Term != nil {\n\t\treturn c.compileTerm(e.Term)\n\t}\n\tswitch e.Op {\n\tcase Operator(0):\n\t\treturn errors.New(`missing query (try \".\")`)\n\tcase OpPipe:\n\t\tif err := c.compileQuery(e.Left); err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn c.compileQuery(e.Right)\n\tcase OpComma:\n\t\treturn c.compileComma(e.Left, e.Right)\n\tcase OpAlt:\n\t\treturn c.compileAlt(e.Left, e.Right)\n\tcase OpAssign, OpModify, OpUpdateAdd, OpUpdateSub,\n\t\tOpUpdateMul, OpUpdateDiv, OpUpdateMod, OpUpdateAlt:\n\t\treturn c.compileQueryUpdate(e.Left, e.Right, e.Op)\n\tcase OpOr:\n\t\treturn c.compileIf(\n\t\t\t&If{\n\t\t\t\tCond: e.Left,\n\t\t\t\tThen: &Query{Term: &Term{Type: TermTypeTrue}},\n\t\t\t\tElse: &Query{Term: &Term{Type: TermTypeIf, If: &If{\n\t\t\t\t\tCond: e.Right,\n\t\t\t\t\tThen: &Query{Term: &Term{Type: TermTypeTrue}},\n\t\t\t\t\tElse: &Query{Term: &Term{Type: TermTypeFalse}},\n\t\t\t\t}}},\n\t\t\t},\n\t\t)\n\tcase OpAnd:\n\t\treturn c.compileIf(\n\t\t\t&If{\n\t\t\t\tCond: e.Left,\n\t\t\t\tThen: &Query{Term: &Term{Type: TermTypeIf, If: &If{\n\t\t\t\t\tCond: e.Right,\n\t\t\t\t\tThen: &Query{Term: &Term{Type: TermTypeTrue}},\n\t\t\t\t\tElse: &Query{Term: &Term{Type: TermTypeFalse}},\n\t\t\t\t}}},\n\t\t\t\tElse: &Query{Term: &Term{Type: TermTypeFalse}},\n\t\t\t},\n\t\t)\n\tdefault:\n\t\treturn c.compileCall(\n\t\t\te.Op.getFunc(),\n\t\t\t[]*Query{e.Left, e.Right},\n\t\t)\n\t}\n}\n\nfunc (c *compiler) compileComma(l, r *Query) error {\n\tsetfork := c.lazy(func() *code {\n\t\treturn &code{op: opfork, v: len(c.codes)}\n\t})\n\tif err := c.compileQuery(l); err != nil {\n\t\treturn err\n\t}\n\tdefer c.lazy(func() *code {\n\t\treturn &code{op: opjump, v: len(c.codes)}\n\t})()\n\tsetfork()\n\treturn c.compileQuery(r)\n}\n\nfunc (c *compiler) compileAlt(l, r *Query) error {\n\tc.append(&code{op: oppush, v: false})\n\tfound := c.newVariable()\n\tc.append(&code{op: opstore, v: found})\n\tsetfork := c.lazy(func() *code {\n\t\treturn &code{op: opfork, v: len(c.codes)} // opload found\n\t})\n\tif err := c.compileQuery(l); err != nil {\n\t\treturn err\n\t}\n\tc.append(&code{op: opdup})\n\tc.append(&code{op: opjumpifnot, v: len(c.codes) + 4}) // oppop\n\tc.append(&code{op: oppush, v: true})                  // found some value\n\tc.append(&code{op: opstore, v: found})\n\tdefer c.lazy(func() *code {\n\t\treturn &code{op: opjump, v: len(c.codes)}\n\t})()\n\tc.append(&code{op: oppop})\n\tc.append(&code{op: opbacktrack})\n\tsetfork()\n\tc.append(&code{op: opload, v: found})\n\tc.append(&code{op: opjumpifnot, v: len(c.codes) + 3})\n\tc.append(&code{op: opbacktrack}) // if found, backtrack\n\tc.append(&code{op: oppop})\n\treturn c.compileQuery(r)\n}\n\nfunc (c *compiler) compileQueryUpdate(l, r *Query, op Operator) error {\n\tswitch op {\n\tcase OpAssign:\n\t\t// optimize assignment operator with constant indexing and slicing\n\t\t//   .foo.[0].[1:2] = f => setpath([\"foo\",0,{\"start\":1,\"end\":2}]; f)\n\t\tif xs := l.toIndices(nil); xs != nil {\n\t\t\t// ref: compileCall\n\t\t\tv := c.newVariable()\n\t\t\tc.append(&code{op: opstore, v: v})\n\t\t\tc.append(&code{op: opload, v: v})\n\t\t\tif err := c.compileQuery(r); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tc.append(&code{op: oppush, v: xs})\n\t\t\tc.append(&code{op: opload, v: v})\n\t\t\tc.append(&code{op: opcall, v: [3]any{internalFuncs[\"setpath\"].callback, 2, \"setpath\"}})\n\t\t\treturn nil\n\t\t}\n\t\tfallthrough\n\tcase OpModify:\n\t\treturn c.compileFunc(\n\t\t\t&Func{\n\t\t\t\tName: op.getFunc(),\n\t\t\t\tArgs: []*Query{l, r},\n\t\t\t},\n\t\t)\n\tdefault:\n\t\tname := \"$%0\"\n\t\tc.append(&code{op: opdup})\n\t\tif err := c.compileQuery(r); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tc.append(&code{op: opstore, v: c.pushVariable(name)})\n\t\treturn c.compileFunc(\n\t\t\t&Func{\n\t\t\t\tName: \"_modify\",\n\t\t\t\tArgs: []*Query{\n\t\t\t\t\tl,\n\t\t\t\t\t{Term: &Term{\n\t\t\t\t\t\tType: TermTypeFunc,\n\t\t\t\t\t\tFunc: &Func{\n\t\t\t\t\t\t\tName: op.getFunc(),\n\t\t\t\t\t\t\tArgs: []*Query{\n\t\t\t\t\t\t\t\t{Term: &Term{Type: TermTypeIdentity}},\n\t\t\t\t\t\t\t\t{Func: name},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t}},\n\t\t\t\t},\n\t\t\t},\n\t\t)\n\t}\n}\n\nfunc (c *compiler) compileBind(e *Term, b *Bind) error {\n\tdefer c.newScopeDepth()()\n\tc.append(&code{op: opdup})\n\tc.append(&code{op: opexpbegin})\n\tif err := c.compileTerm(e); err != nil {\n\t\treturn err\n\t}\n\tvar pc int\n\tvar vs [][2]int\n\tfor i, p := range b.Patterns {\n\t\tvar pcc int\n\t\tvar err error\n\t\tif i < len(b.Patterns)-1 {\n\t\t\tdefer c.lazy(func() *code {\n\t\t\t\treturn &code{op: opforkalt, v: pcc}\n\t\t\t})()\n\t\t}\n\t\tif 0 < i {\n\t\t\tfor _, v := range vs {\n\t\t\t\tc.append(&code{op: oppush, v: nil})\n\t\t\t\tc.append(&code{op: opstore, v: v})\n\t\t\t}\n\t\t}\n\t\tif vs, err = c.compilePattern(vs[:0], p); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif i < len(b.Patterns)-1 {\n\t\t\tdefer c.lazy(func() *code {\n\t\t\t\treturn &code{op: opjump, v: pc}\n\t\t\t})()\n\t\t\tpcc = len(c.codes)\n\t\t}\n\t}\n\tif len(b.Patterns) > 1 {\n\t\tpc = len(c.codes)\n\t}\n\tif len(b.Patterns) == 1 && c.codes[len(c.codes)-2].op == opexpbegin {\n\t\tc.codes[len(c.codes)-2].op = opnop\n\t} else {\n\t\tc.append(&code{op: opexpend})\n\t}\n\treturn c.compileQuery(b.Body)\n}\n\nfunc (c *compiler) compilePattern(vs [][2]int, p *Pattern) ([][2]int, error) {\n\tvar err error\n\tc.appendCodeInfo(p)\n\tif p.Name != \"\" {\n\t\tv := c.pushVariable(p.Name)\n\t\tc.append(&code{op: opstore, v: v})\n\t\treturn append(vs, v), nil\n\t} else if len(p.Array) > 0 {\n\t\tv := c.newVariable()\n\t\tc.append(&code{op: opstore, v: v})\n\t\tfor i, p := range p.Array {\n\t\t\tc.append(&code{op: opload, v: v})\n\t\t\tc.append(&code{op: opindexarray, v: i})\n\t\t\tif vs, err = c.compilePattern(vs, p); err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t}\n\t\treturn vs, nil\n\t} else if len(p.Object) > 0 {\n\t\tv := c.newVariable()\n\t\tc.append(&code{op: opstore, v: v})\n\t\tfor _, kv := range p.Object {\n\t\t\tvar key, name string\n\t\t\tc.append(&code{op: opload, v: v})\n\t\t\tif key = kv.Key; key != \"\" {\n\t\t\t\tif key[0] == '$' {\n\t\t\t\t\tkey, name = key[1:], key\n\t\t\t\t}\n\t\t\t} else if kv.KeyString != nil {\n\t\t\t\tif key = kv.KeyString.Str; key == \"\" {\n\t\t\t\t\tif err := c.compileString(kv.KeyString, nil); err != nil {\n\t\t\t\t\t\treturn nil, err\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if kv.KeyQuery != nil {\n\t\t\t\tif err := c.compileQuery(kv.KeyQuery); err != nil {\n\t\t\t\t\treturn nil, err\n\t\t\t\t}\n\t\t\t}\n\t\t\tif key != \"\" {\n\t\t\t\tc.append(&code{op: opindex, v: key})\n\t\t\t} else {\n\t\t\t\tc.append(&code{op: opload, v: v})\n\t\t\t\tc.append(&code{op: oppush, v: nil})\n\t\t\t\t// ref: compileCall\n\t\t\t\tc.append(&code{op: opcall, v: [3]any{internalFuncs[\"_index\"].callback, 2, \"_index\"}})\n\t\t\t}\n\t\t\tif name != \"\" {\n\t\t\t\tif kv.Val != nil {\n\t\t\t\t\tc.append(&code{op: opdup})\n\t\t\t\t}\n\t\t\t\tif vs, err = c.compilePattern(vs, &Pattern{Name: name}); err != nil {\n\t\t\t\t\treturn nil, err\n\t\t\t\t}\n\t\t\t}\n\t\t\tif kv.Val != nil {\n\t\t\t\tif vs, err = c.compilePattern(vs, kv.Val); err != nil {\n\t\t\t\t\treturn nil, err\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn vs, nil\n\t} else {\n\t\treturn nil, fmt.Errorf(\"invalid pattern: %s\", p)\n\t}\n}\n\nfunc (c *compiler) compileIf(e *If) error {\n\tc.appendCodeInfo(e)\n\tc.append(&code{op: opdup}) // duplicate the value for then or else clause\n\tc.append(&code{op: opexpbegin})\n\tpc := len(c.codes)\n\tf := c.newScopeDepth()\n\tif err := c.compileQuery(e.Cond); err != nil {\n\t\treturn err\n\t}\n\tf()\n\tif pc == len(c.codes) {\n\t\tc.codes = c.codes[:pc-1]\n\t} else {\n\t\tc.append(&code{op: opexpend})\n\t}\n\tpcc := len(c.codes)\n\tsetjumpifnot := c.lazy(func() *code {\n\t\treturn &code{op: opjumpifnot, v: len(c.codes)} // skip then clause\n\t})\n\tf = c.newScopeDepth()\n\tif err := c.compileQuery(e.Then); err != nil {\n\t\treturn err\n\t}\n\tf()\n\tdefer c.lazy(func() *code {\n\t\treturn &code{op: opjump, v: len(c.codes)}\n\t})()\n\tsetjumpifnot()\n\tif len(e.Elif) > 0 {\n\t\treturn c.compileIf(&If{e.Elif[0].Cond, e.Elif[0].Then, e.Elif[1:], e.Else})\n\t}\n\tif e.Else != nil {\n\t\tdefer c.newScopeDepth()()\n\t\tdefer func() {\n\t\t\t// optimize constant results\n\t\t\t//    opdup, ..., opjumpifnot, opconst, opjump, opconst\n\t\t\t// => opnop, ..., opjumpifnot, oppush,  opjump, oppush\n\t\t\tif pcc+4 == len(c.codes) &&\n\t\t\t\tc.codes[pcc+1] != nil && c.codes[pcc+1].op == opconst &&\n\t\t\t\tc.codes[pcc+3] != nil && c.codes[pcc+3].op == opconst {\n\t\t\t\tc.codes[pc-2].op = opnop\n\t\t\t\tc.codes[pcc+1].op = oppush\n\t\t\t\tc.codes[pcc+3].op = oppush\n\t\t\t}\n\t\t}()\n\t\treturn c.compileQuery(e.Else)\n\t}\n\treturn nil\n}\n\nfunc (c *compiler) compileTry(e *Try) error {\n\tc.appendCodeInfo(e)\n\tsetforktrybegin := c.lazy(func() *code {\n\t\treturn &code{op: opforktrybegin, v: len(c.codes)}\n\t})\n\tf := c.newScopeDepth()\n\tif err := c.compileQuery(e.Body); err != nil {\n\t\treturn err\n\t}\n\tf()\n\tc.append(&code{op: opforktryend})\n\tdefer c.lazy(func() *code {\n\t\treturn &code{op: opjump, v: len(c.codes)}\n\t})()\n\tsetforktrybegin()\n\tif e.Catch != nil {\n\t\tdefer c.newScopeDepth()()\n\t\treturn c.compileQuery(e.Catch)\n\t}\n\tc.append(&code{op: opbacktrack})\n\treturn nil\n}\n\nfunc (c *compiler) compileReduce(e *Reduce) error {\n\tc.appendCodeInfo(e)\n\tdefer c.newScopeDepth()()\n\tc.append(&code{op: opdup})\n\tv := c.newVariable()\n\tf := c.newScopeDepth()\n\tif err := c.compileQuery(e.Start); err != nil {\n\t\treturn err\n\t}\n\tf()\n\tc.append(&code{op: opstore, v: v})\n\tsetfork := c.lazy(func() *code {\n\t\treturn &code{op: opfork, v: len(c.codes)}\n\t})\n\tif err := c.compileQuery(e.Query); err != nil {\n\t\treturn err\n\t}\n\tif _, err := c.compilePattern(nil, e.Pattern); err != nil {\n\t\treturn err\n\t}\n\tc.append(&code{op: opload, v: v})\n\tf = c.newScopeDepth()\n\tif err := c.compileQuery(e.Update); err != nil {\n\t\treturn err\n\t}\n\tf()\n\tc.append(&code{op: opstore, v: v})\n\tc.append(&code{op: opbacktrack})\n\tsetfork()\n\tc.append(&code{op: oppop})\n\tc.append(&code{op: opload, v: v})\n\treturn nil\n}\n\nfunc (c *compiler) compileForeach(e *Foreach) error {\n\tc.appendCodeInfo(e)\n\tdefer c.newScopeDepth()()\n\tc.append(&code{op: opdup})\n\tv := c.newVariable()\n\tf := c.newScopeDepth()\n\tif err := c.compileQuery(e.Start); err != nil {\n\t\treturn err\n\t}\n\tf()\n\tc.append(&code{op: opstore, v: v})\n\tif err := c.compileQuery(e.Query); err != nil {\n\t\treturn err\n\t}\n\tif _, err := c.compilePattern(nil, e.Pattern); err != nil {\n\t\treturn err\n\t}\n\tc.append(&code{op: opload, v: v})\n\tf = c.newScopeDepth()\n\tif err := c.compileQuery(e.Update); err != nil {\n\t\treturn err\n\t}\n\tf()\n\tc.append(&code{op: opdup})\n\tc.append(&code{op: opstore, v: v})\n\tif e.Extract != nil {\n\t\tdefer c.newScopeDepth()()\n\t\treturn c.compileQuery(e.Extract)\n\t}\n\treturn nil\n}\n\nfunc (c *compiler) compileLabel(e *Label) error {\n\tc.appendCodeInfo(e)\n\tv := c.pushVariable(\"$%\" + e.Ident[1:])\n\tc.append(&code{op: opforklabel, v: v})\n\treturn c.compileQuery(e.Body)\n}\n\nfunc (c *compiler) compileBreak(label string) error {\n\tv, err := c.lookupVariable(\"$%\" + label[1:])\n\tif err != nil {\n\t\treturn &breakError{label, nil}\n\t}\n\tc.append(&code{op: oppop})\n\tc.append(&code{op: opload, v: v})\n\tc.append(&code{op: opcall, v: [3]any{funcBreak(label), 0, \"_break\"}})\n\treturn nil\n}\n\nfunc funcBreak(label string) func(any, []any) any {\n\treturn func(v any, _ []any) any {\n\t\treturn &breakError{label, v}\n\t}\n}\n\nfunc (c *compiler) compileTerm(e *Term) error {\n\tif len(e.SuffixList) > 0 {\n\t\ts := e.SuffixList[len(e.SuffixList)-1]\n\t\tt := *e // clone without changing e\n\t\tt.SuffixList = t.SuffixList[:len(e.SuffixList)-1]\n\t\treturn c.compileTermSuffix(&t, s)\n\t}\n\tswitch e.Type {\n\tcase TermTypeIdentity:\n\t\treturn nil\n\tcase TermTypeRecurse:\n\t\treturn c.compileFunc(&Func{Name: \"recurse\"})\n\tcase TermTypeNull:\n\t\tc.append(&code{op: opconst, v: nil})\n\t\treturn nil\n\tcase TermTypeTrue:\n\t\tc.append(&code{op: opconst, v: true})\n\t\treturn nil\n\tcase TermTypeFalse:\n\t\tc.append(&code{op: opconst, v: false})\n\t\treturn nil\n\tcase TermTypeIndex:\n\t\treturn c.compileIndex(&Term{Type: TermTypeIdentity}, e.Index)\n\tcase TermTypeFunc:\n\t\treturn c.compileFunc(e.Func)\n\tcase TermTypeObject:\n\t\treturn c.compileObject(e.Object)\n\tcase TermTypeArray:\n\t\treturn c.compileArray(e.Array)\n\tcase TermTypeNumber:\n\t\tc.append(&code{op: opconst, v: toNumber(e.Number)})\n\t\treturn nil\n\tcase TermTypeUnary:\n\t\treturn c.compileUnary(e.Unary)\n\tcase TermTypeFormat:\n\t\treturn c.compileFormat(e.Format, e.Str)\n\tcase TermTypeString:\n\t\treturn c.compileString(e.Str, nil)\n\tcase TermTypeIf:\n\t\treturn c.compileIf(e.If)\n\tcase TermTypeTry:\n\t\treturn c.compileTry(e.Try)\n\tcase TermTypeReduce:\n\t\treturn c.compileReduce(e.Reduce)\n\tcase TermTypeForeach:\n\t\treturn c.compileForeach(e.Foreach)\n\tcase TermTypeLabel:\n\t\treturn c.compileLabel(e.Label)\n\tcase TermTypeBreak:\n\t\treturn c.compileBreak(e.Break)\n\tcase TermTypeQuery:\n\t\tdefer c.newScopeDepth()()\n\t\treturn c.compileQuery(e.Query)\n\tdefault:\n\t\tpanic(\"invalid term: \" + e.String())\n\t}\n}\n\nfunc (c *compiler) compileIndex(e *Term, x *Index) error {\n\tif k := x.toIndexKey(); k != nil {\n\t\tif err := c.compileTerm(e); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tc.appendCodeInfo(x)\n\t\tc.append(&code{op: opindex, v: k})\n\t\treturn nil\n\t}\n\tc.appendCodeInfo(x)\n\tif x.Str != nil {\n\t\treturn c.compileCall(\"_index\", []*Query{{Term: e}, {Term: &Term{Type: TermTypeString, Str: x.Str}}})\n\t}\n\tif !x.IsSlice {\n\t\treturn c.compileCall(\"_index\", []*Query{{Term: e}, x.Start})\n\t}\n\tif x.Start == nil {\n\t\treturn c.compileCall(\"_slice\", []*Query{{Term: e}, x.End, {Term: &Term{Type: TermTypeNull}}})\n\t}\n\tif x.End == nil {\n\t\treturn c.compileCall(\"_slice\", []*Query{{Term: e}, {Term: &Term{Type: TermTypeNull}}, x.Start})\n\t}\n\treturn c.compileCall(\"_slice\", []*Query{{Term: e}, x.End, x.Start})\n}\n\nfunc (c *compiler) compileFunc(e *Func) error {\n\tif len(e.Args) == 0 {\n\t\tif f, v := c.lookupFuncOrVariable(e.Name); f != nil {\n\t\t\treturn c.compileCallPc(f, e.Args)\n\t\t} else if v != nil {\n\t\t\tif e.Name[0] == '$' {\n\t\t\t\tc.append(&code{op: oppop})\n\t\t\t\tc.append(&code{op: opload, v: v.index})\n\t\t\t} else {\n\t\t\t\tc.append(&code{op: opload, v: v.index})\n\t\t\t\tc.append(&code{op: opcallpc})\n\t\t\t}\n\t\t\treturn nil\n\t\t} else if e.Name == \"$ENV\" || e.Name == \"env\" {\n\t\t\tenv := make(map[string]any)\n\t\t\tif c.environLoader != nil {\n\t\t\t\tfor _, kv := range c.environLoader() {\n\t\t\t\t\tif k, v, ok := strings.Cut(kv, \"=\"); ok && k != \"\" {\n\t\t\t\t\t\tenv[k] = v\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tc.append(&code{op: opconst, v: env})\n\t\t\treturn nil\n\t\t} else if e.Name[0] == '$' {\n\t\t\treturn &variableNotFoundError{e.Name}\n\t\t}\n\t} else {\n\t\tfor i := len(c.scopes) - 1; i >= 0; i-- {\n\t\t\ts := c.scopes[i]\n\t\t\tfor j := len(s.funcs) - 1; j >= 0; j-- {\n\t\t\t\tif f := s.funcs[j]; f.name == e.Name && f.argcnt == len(e.Args) {\n\t\t\t\t\treturn c.compileCallPc(f, e.Args)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif f := c.lookupBuiltin(e.Name, len(e.Args)); f != nil {\n\t\treturn c.compileCallPc(f, e.Args)\n\t}\n\tif fds, ok := builtinFuncDefs[e.Name]; ok {\n\t\tvar compiled bool\n\t\tfor _, fd := range fds {\n\t\t\tif len(fd.Args) == len(e.Args) {\n\t\t\t\tif err := c.compileFuncDef(fd, true); err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t\tcompiled = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif !compiled {\n\t\t\tswitch e.Name {\n\t\t\tcase \"_assign\":\n\t\t\t\tc.compileAssign()\n\t\t\tcase \"_modify\":\n\t\t\t\tc.compileModify()\n\t\t\tcase \"last\":\n\t\t\t\tc.compileLast()\n\t\t\t}\n\t\t}\n\t\tif f := c.lookupBuiltin(e.Name, len(e.Args)); f != nil {\n\t\t\treturn c.compileCallPc(f, e.Args)\n\t\t}\n\t}\n\tif fn, ok := internalFuncs[e.Name]; ok && fn.accept(len(e.Args)) {\n\t\tswitch e.Name {\n\t\tcase \"empty\":\n\t\t\tc.append(&code{op: opbacktrack})\n\t\t\treturn nil\n\t\tcase \"path\":\n\t\t\tc.append(&code{op: oppathbegin})\n\t\t\tif err := c.compileCall(e.Name, e.Args); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tc.codes[len(c.codes)-1] = &code{op: oppathend}\n\t\t\treturn nil\n\t\tcase \"builtins\":\n\t\t\treturn c.compileCallInternal(\n\t\t\t\t[3]any{c.funcBuiltins, 0, e.Name},\n\t\t\t\te.Args,\n\t\t\t\ttrue,\n\t\t\t\t-1,\n\t\t\t)\n\t\tcase \"input\":\n\t\t\tif c.inputIter == nil {\n\t\t\t\treturn &inputNotAllowedError{}\n\t\t\t}\n\t\t\treturn c.compileCallInternal(\n\t\t\t\t[3]any{c.funcInput, 0, e.Name},\n\t\t\t\te.Args,\n\t\t\t\ttrue,\n\t\t\t\t-1,\n\t\t\t)\n\t\tcase \"modulemeta\":\n\t\t\treturn c.compileCallInternal(\n\t\t\t\t[3]any{c.funcModulemeta, 0, e.Name},\n\t\t\t\te.Args,\n\t\t\t\ttrue,\n\t\t\t\t-1,\n\t\t\t)\n\t\tcase \"debug\":\n\t\t\tsetfork := c.lazy(func() *code {\n\t\t\t\treturn &code{op: opfork, v: len(c.codes)}\n\t\t\t})\n\t\t\tif err := c.compileQuery(e.Args[0]); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif err := c.compileFunc(&Func{Name: \"debug\"}); err != nil {\n\t\t\t\tif _, ok := err.(*funcNotFoundError); ok {\n\t\t\t\t\terr = &funcNotFoundError{e}\n\t\t\t\t}\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tc.append(&code{op: opbacktrack})\n\t\t\tsetfork()\n\t\t\treturn nil\n\t\tdefault:\n\t\t\treturn c.compileCall(e.Name, e.Args)\n\t\t}\n\t}\n\tif fn, ok := c.customFuncs[e.Name]; ok && fn.accept(len(e.Args)) {\n\t\tif err := c.compileCallInternal(\n\t\t\t[3]any{fn.callback, len(e.Args), e.Name},\n\t\t\te.Args,\n\t\t\ttrue,\n\t\t\t-1,\n\t\t); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif fn.iter {\n\t\t\tc.append(&code{op: opiter})\n\t\t}\n\t\treturn nil\n\t}\n\treturn &funcNotFoundError{e}\n}\n\n// Appends the compiled code for the assignment operator (`=`) to maximize\n// performance. Originally the operator was implemented as follows.\n//\n//\tdef _assign(p; $x): reduce path(p) as $q (.; setpath($q; $x));\n//\n// To overcome the difficulty of reducing allocations on `setpath`, we use the\n// `allocator` type and track the allocated addresses during the reduction.\nfunc (c *compiler) compileAssign() {\n\tdefer c.appendBuiltin(\"_assign\", 2)()\n\tscope := c.newScope()\n\tv, p := [2]int{scope.id, 0}, [2]int{scope.id, 1}\n\tx, a := [2]int{scope.id, 2}, [2]int{scope.id, 3}\n\t// Cannot reuse v, p due to backtracking in x.\n\tw, q := [2]int{scope.id, 4}, [2]int{scope.id, 5}\n\tc.appends(\n\t\t&code{op: opscope, v: [3]int{scope.id, 6, 2}},\n\t\t&code{op: opstore, v: v}, //                def _assign(p; $x):\n\t\t&code{op: opstore, v: p},\n\t\t&code{op: opstore, v: x},\n\t\t&code{op: opload, v: v},\n\t\t&code{op: opexpbegin},\n\t\t&code{op: opload, v: x},\n\t\t&code{op: opcallpc},\n\t\t&code{op: opstore, v: x},\n\t\t&code{op: opexpend},\n\t\t&code{op: oppush, v: nil},\n\t\t&code{op: opcall, v: [3]any{funcAllocator, 0, \"_allocator\"}},\n\t\t&code{op: opstore, v: a},\n\t\t&code{op: opload, v: v},\n\t\t&code{op: opfork, v: len(c.codes) + 30}, // reduce [L1]\n\t\t&code{op: opdup},\n\t\t&code{op: opstore, v: w},\n\t\t&code{op: oppathbegin}, //                  path(p)\n\t\t&code{op: opload, v: p},\n\t\t&code{op: opcallpc},\n\t\t&code{op: opload, v: w},\n\t\t&code{op: oppathend},\n\t\t&code{op: opstore, v: q}, //                as $q (.;\n\t\t&code{op: opload, v: a},  //                  setpath($q; $x)\n\t\t&code{op: opload, v: x},\n\t\t&code{op: opload, v: q},\n\t\t&code{op: opload, v: w},\n\t\t&code{op: opcall, v: [3]any{funcSetpathWithAllocator, 3, \"_setpath\"}},\n\t\t&code{op: opstore, v: w},\n\t\t&code{op: opbacktrack}, //                  );\n\t\t&code{op: oppop},       //                  [L1]\n\t\t&code{op: opload, v: w},\n\t\t&code{op: opret},\n\t)\n}\n\n// Appends the compiled code for the update-assignment operator (`|=`) to\n// maximize performance. We use the `allocator` type, just like `_assign/2`.\nfunc (c *compiler) compileModify() {\n\tdefer c.appendBuiltin(\"_modify\", 2)()\n\tscope := c.newScope()\n\tv, p := [2]int{scope.id, 0}, [2]int{scope.id, 1}\n\tf, d := [2]int{scope.id, 2}, [2]int{scope.id, 3}\n\ta, l := [2]int{scope.id, 4}, [2]int{scope.id, 5}\n\tc.appends(\n\t\t&code{op: opscope, v: [3]int{scope.id, 6, 2}},\n\t\t&code{op: opstore, v: v}, //                def _modify(p; f):\n\t\t&code{op: opstore, v: p},\n\t\t&code{op: opstore, v: f},\n\t\t&code{op: oppush, v: []any{}},\n\t\t&code{op: opstore, v: d},\n\t\t&code{op: oppush, v: nil},\n\t\t&code{op: opcall, v: [3]any{funcAllocator, 0, \"_allocator\"}},\n\t\t&code{op: opstore, v: a},\n\t\t&code{op: opload, v: v},\n\t\t&code{op: opfork, v: len(c.codes) + 39}, // reduce [L1]\n\t\t&code{op: oppathbegin},                  // path(p)\n\t\t&code{op: opload, v: p},\n\t\t&code{op: opcallpc},\n\t\t&code{op: opload, v: v},\n\t\t&code{op: oppathend},\n\t\t&code{op: opstore, v: p},                // as $p (.;\n\t\t&code{op: opforklabel, v: l},            // label $l |\n\t\t&code{op: opload, v: v},                 //\n\t\t&code{op: opfork, v: len(c.codes) + 36}, // [L2]\n\t\t&code{op: oppop},                        // (getpath($p) |\n\t\t&code{op: opload, v: a},\n\t\t&code{op: opload, v: p},\n\t\t&code{op: opload, v: v},\n\t\t&code{op: opcall, v: [3]any{internalFuncs[\"getpath\"].callback, 1, \"getpath\"}},\n\t\t&code{op: opload, v: f}, //                 f)\n\t\t&code{op: opcallpc},\n\t\t&code{op: opload, v: p}, //                 setpath($p; ...)\n\t\t&code{op: opload, v: v},\n\t\t&code{op: opcall, v: [3]any{funcSetpathWithAllocator, 3, \"_setpath\"}},\n\t\t&code{op: opstore, v: v},\n\t\t&code{op: opload, v: v},                 // ., break $l\n\t\t&code{op: opfork, v: len(c.codes) + 34}, // [L4]\n\t\t&code{op: opjump, v: len(c.codes) + 38}, // [L3]\n\t\t&code{op: opload, v: l},                 // [L4]\n\t\t&code{op: opcall, v: [3]any{funcBreak(\"\"), 0, \"_break\"}},\n\t\t&code{op: opload, v: p},   //               append $p to $d [L2]\n\t\t&code{op: opappend, v: d}, //\n\t\t&code{op: opbacktrack},    //               ) |           [L3]\n\t\t&code{op: oppop},          //               delpaths($d); [L1]\n\t\t&code{op: opload, v: a},\n\t\t&code{op: opload, v: d},\n\t\t&code{op: opload, v: v},\n\t\t&code{op: opcall, v: [3]any{funcDelpathsWithAllocator, 2, \"_delpaths\"}},\n\t\t&code{op: opret},\n\t)\n}\n\n// Appends the compiled code for the `last/1` function to\n// maximize performance avoiding unnecessary boxing.\nfunc (c *compiler) compileLast() {\n\tdefer c.appendBuiltin(\"last\", 1)()\n\tscope := c.newScope()\n\tv, g, x := [2]int{scope.id, 0}, [2]int{scope.id, 1}, [2]int{scope.id, 2}\n\tc.appends(\n\t\t&code{op: opscope, v: [3]int{scope.id, 3, 1}},\n\t\t&code{op: opstore, v: v},\n\t\t&code{op: opstore, v: g},\n\t\t&code{op: oppush, v: true}, //              $x = true\n\t\t&code{op: opstore, v: x},\n\t\t&code{op: opload, v: v},\n\t\t&code{op: opfork, v: len(c.codes) + 13}, // reduce [L1]\n\t\t&code{op: opload, v: g},                 // g\n\t\t&code{op: opcallpc},\n\t\t&code{op: opstore, v: v},    //             as $v (\n\t\t&code{op: oppush, v: false}, //               $x = false\n\t\t&code{op: opstore, v: x},\n\t\t&code{op: opbacktrack},  //                 );\n\t\t&code{op: oppop},        //                 [L1]\n\t\t&code{op: opload, v: x}, //                 if $x then $v else empty end\n\t\t&code{op: opjumpifnot, v: len(c.codes) + 17},\n\t\t&code{op: opbacktrack},\n\t\t&code{op: opload, v: v},\n\t\t&code{op: opret},\n\t)\n}\n\nfunc (c *compiler) funcBuiltins(any, []any) any {\n\ttype funcNameArity struct {\n\t\tname  string\n\t\tarity int\n\t}\n\tvar xs []*funcNameArity\n\tfor _, fds := range builtinFuncDefs {\n\t\tfor _, fd := range fds {\n\t\t\tif fd.Name[0] != '_' {\n\t\t\t\txs = append(xs, &funcNameArity{fd.Name, len(fd.Args)})\n\t\t\t}\n\t\t}\n\t}\n\tfor name, fn := range internalFuncs {\n\t\tif name[0] != '_' {\n\t\t\tfor i, cnt := 0, fn.argcount; cnt > 0; i, cnt = i+1, cnt>>1 {\n\t\t\t\tif cnt&1 > 0 {\n\t\t\t\t\txs = append(xs, &funcNameArity{name, i})\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor name, fn := range c.customFuncs {\n\t\tif name[0] != '_' {\n\t\t\tfor i, cnt := 0, fn.argcount; cnt > 0; i, cnt = i+1, cnt>>1 {\n\t\t\t\tif cnt&1 > 0 {\n\t\t\t\t\txs = append(xs, &funcNameArity{name, i})\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tsort.Slice(xs, func(i, j int) bool {\n\t\treturn xs[i].name < xs[j].name ||\n\t\t\txs[i].name == xs[j].name && xs[i].arity < xs[j].arity\n\t})\n\tys := make([]any, len(xs))\n\tfor i, x := range xs {\n\t\tys[i] = x.name + \"/\" + strconv.Itoa(x.arity)\n\t}\n\treturn ys\n}\n\nfunc (c *compiler) funcInput(any, []any) any {\n\tv, ok := c.inputIter.Next()\n\tif !ok {\n\t\treturn errors.New(\"break\")\n\t}\n\treturn normalizeNumbers(v)\n}\n\nfunc (c *compiler) funcModulemeta(v any, _ []any) any {\n\ts, ok := v.(string)\n\tif !ok {\n\t\treturn &func0TypeError{\"modulemeta\", v}\n\t}\n\tif c.moduleLoader == nil {\n\t\treturn fmt.Errorf(\"cannot load module: %q\", s)\n\t}\n\tvar q *Query\n\tvar err error\n\tif moduleLoader, ok := c.moduleLoader.(interface {\n\t\tLoadModuleWithMeta(string, map[string]any) (*Query, error)\n\t}); ok {\n\t\tif q, err = moduleLoader.LoadModuleWithMeta(s, nil); err != nil {\n\t\t\treturn err\n\t\t}\n\t} else if moduleLoader, ok := c.moduleLoader.(interface {\n\t\tLoadModule(string) (*Query, error)\n\t}); ok {\n\t\tif q, err = moduleLoader.LoadModule(s); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\tmeta := q.Meta.ToValue()\n\tif meta == nil {\n\t\tmeta = make(map[string]any)\n\t}\n\tmeta[\"defs\"] = listModuleDefs(q)\n\tmeta[\"deps\"] = listModuleDeps(q)\n\treturn meta\n}\n\nfunc listModuleDefs(q *Query) []any {\n\ttype funcNameArity struct {\n\t\tname  string\n\t\tarity int\n\t}\n\tvar xs []*funcNameArity\n\tfor _, fd := range q.FuncDefs {\n\t\tif fd.Name[0] != '_' {\n\t\t\txs = append(xs, &funcNameArity{fd.Name, len(fd.Args)})\n\t\t}\n\t}\n\tsort.Slice(xs, func(i, j int) bool {\n\t\treturn xs[i].name < xs[j].name ||\n\t\t\txs[i].name == xs[j].name && xs[i].arity < xs[j].arity\n\t})\n\tdefs := make([]any, len(xs))\n\tfor i, x := range xs {\n\t\tdefs[i] = x.name + \"/\" + strconv.Itoa(x.arity)\n\t}\n\treturn defs\n}\n\nfunc listModuleDeps(q *Query) []any {\n\tdeps := make([]any, len(q.Imports))\n\tfor j, i := range q.Imports {\n\t\tv := i.Meta.ToValue()\n\t\tif v == nil {\n\t\t\tv = make(map[string]any)\n\t\t}\n\t\trelpath := i.ImportPath\n\t\tif relpath == \"\" {\n\t\t\trelpath = i.IncludePath\n\t\t}\n\t\tv[\"relpath\"] = relpath\n\t\tif i.ImportAlias != \"\" {\n\t\t\tv[\"as\"] = strings.TrimPrefix(i.ImportAlias, \"$\")\n\t\t}\n\t\tv[\"is_data\"] = strings.HasPrefix(i.ImportAlias, \"$\")\n\t\tdeps[j] = v\n\t}\n\treturn deps\n}\n\nfunc (c *compiler) compileObject(e *Object) error {\n\tc.appendCodeInfo(e)\n\tif len(e.KeyVals) == 0 {\n\t\tc.append(&code{op: opconst, v: map[string]any{}})\n\t\treturn nil\n\t}\n\tdefer c.newScopeDepth()()\n\tv := c.newVariable()\n\tc.append(&code{op: opstore, v: v})\n\tpc := len(c.codes)\n\tfor _, kv := range e.KeyVals {\n\t\tif err := c.compileObjectKeyVal(v, kv); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\tc.append(&code{op: opobject, v: len(e.KeyVals)})\n\t// optimize constant objects\n\tl := len(e.KeyVals)\n\tif pc+l*3+1 != len(c.codes) {\n\t\treturn nil\n\t}\n\tfor i := 0; i < l; i++ {\n\t\tif c.codes[pc+i*3].op != oppush ||\n\t\t\tc.codes[pc+i*3+1].op != opload ||\n\t\t\tc.codes[pc+i*3+2].op != opconst {\n\t\t\treturn nil\n\t\t}\n\t}\n\tw := make(map[string]any, l)\n\tfor i := 0; i < l; i++ {\n\t\tw[c.codes[pc+i*3].v.(string)] = c.codes[pc+i*3+2].v\n\t}\n\tc.codes[pc-1] = &code{op: opconst, v: w}\n\tc.codes = c.codes[:pc]\n\treturn nil\n}\n\nfunc (c *compiler) compileObjectKeyVal(v [2]int, kv *ObjectKeyVal) error {\n\tif key := kv.Key; key != \"\" {\n\t\tif key[0] == '$' {\n\t\t\tif kv.Val == nil { // {$foo} == {foo:$foo}\n\t\t\t\tc.append(&code{op: oppush, v: key[1:]})\n\t\t\t}\n\t\t\tc.append(&code{op: opload, v: v})\n\t\t\tif err := c.compileFunc(&Func{Name: key}); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t} else {\n\t\t\tc.append(&code{op: oppush, v: key})\n\t\t\tif kv.Val == nil { // {foo} == {foo:.foo}\n\t\t\t\tc.append(&code{op: opload, v: v})\n\t\t\t\tc.append(&code{op: opindex, v: key})\n\t\t\t}\n\t\t}\n\t} else if key := kv.KeyString; key != nil {\n\t\tif key.Queries == nil {\n\t\t\tc.append(&code{op: oppush, v: key.Str})\n\t\t\tif kv.Val == nil { // {\"foo\"} == {\"foo\":.[\"foo\"]}\n\t\t\t\tc.append(&code{op: opload, v: v})\n\t\t\t\tc.append(&code{op: opindex, v: key.Str})\n\t\t\t}\n\t\t} else {\n\t\t\tc.append(&code{op: opload, v: v})\n\t\t\tif err := c.compileString(key, nil); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif kv.Val == nil {\n\t\t\t\tc.append(&code{op: opdup})\n\t\t\t\tc.append(&code{op: opload, v: v})\n\t\t\t\tc.append(&code{op: oppush, v: nil})\n\t\t\t\t// ref: compileCall\n\t\t\t\tc.append(&code{op: opcall, v: [3]any{internalFuncs[\"_index\"].callback, 2, \"_index\"}})\n\t\t\t}\n\t\t}\n\t} else if kv.KeyQuery != nil {\n\t\tc.append(&code{op: opload, v: v})\n\t\tf := c.newScopeDepth()\n\t\tif err := c.compileQuery(kv.KeyQuery); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tf()\n\t}\n\tif kv.Val != nil {\n\t\tc.append(&code{op: opload, v: v})\n\t\tif err := c.compileQuery(kv.Val); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc (c *compiler) compileArray(e *Array) error {\n\tc.appendCodeInfo(e)\n\tif e.Query == nil {\n\t\tc.append(&code{op: opconst, v: []any{}})\n\t\treturn nil\n\t}\n\tc.append(&code{op: oppush, v: []any{}})\n\tarr := c.newVariable()\n\tc.append(&code{op: opstore, v: arr})\n\tpc := len(c.codes)\n\tsetfork := c.lazy(func() *code {\n\t\treturn &code{op: opfork, v: len(c.codes)}\n\t})\n\tdefer c.newScopeDepth()()\n\tif err := c.compileQuery(e.Query); err != nil {\n\t\treturn err\n\t}\n\tc.append(&code{op: opappend, v: arr})\n\tc.append(&code{op: opbacktrack})\n\tsetfork()\n\tc.append(&code{op: oppop})\n\tc.append(&code{op: opload, v: arr})\n\tif e.Query.Op == OpPipe {\n\t\treturn nil\n\t}\n\t// optimize constant arrays\n\tif (len(c.codes)-pc)%3 != 0 {\n\t\treturn nil\n\t}\n\tl := (len(c.codes) - pc - 3) / 3\n\tfor i := 0; i < l; i++ {\n\t\tif c.codes[pc+i].op != opfork ||\n\t\t\tc.codes[pc+i*2+l].op != opconst ||\n\t\t\t(i < l-1 && c.codes[pc+i*2+l+1].op != opjump) {\n\t\t\treturn nil\n\t\t}\n\t}\n\tv := make([]any, l)\n\tfor i := 0; i < l; i++ {\n\t\tv[i] = c.codes[pc+i*2+l].v\n\t}\n\tc.codes[pc-2] = &code{op: opconst, v: v}\n\tc.codes = c.codes[:pc-1]\n\treturn nil\n}\n\nfunc (c *compiler) compileUnary(e *Unary) error {\n\tc.appendCodeInfo(e)\n\tif v := e.toNumber(); v != nil {\n\t\tc.append(&code{op: opconst, v: v})\n\t\treturn nil\n\t}\n\tif err := c.compileTerm(e.Term); err != nil {\n\t\treturn err\n\t}\n\tswitch e.Op {\n\tcase OpAdd:\n\t\treturn c.compileCall(\"_plus\", nil)\n\tcase OpSub:\n\t\treturn c.compileCall(\"_negate\", nil)\n\tdefault:\n\t\treturn fmt.Errorf(\"unexpected operator in Unary: %s\", e.Op)\n\t}\n}\n\nfunc (c *compiler) compileFormat(format string, str *String) error {\n\tf := formatToFunc(format)\n\tif f == nil {\n\t\tf = &Func{\n\t\t\tName: \"format\",\n\t\t\tArgs: []*Query{{Term: &Term{Type: TermTypeString, Str: &String{Str: format[1:]}}}},\n\t\t}\n\t}\n\tif str == nil {\n\t\treturn c.compileFunc(f)\n\t}\n\treturn c.compileString(str, f)\n}\n\nfunc formatToFunc(format string) *Func {\n\tswitch format {\n\tcase \"@text\":\n\t\treturn &Func{Name: \"tostring\"}\n\tcase \"@json\":\n\t\treturn &Func{Name: \"tojson\"}\n\tcase \"@html\":\n\t\treturn &Func{Name: \"_tohtml\"}\n\tcase \"@uri\":\n\t\treturn &Func{Name: \"_touri\"}\n\tcase \"@urid\":\n\t\treturn &Func{Name: \"_tourid\"}\n\tcase \"@csv\":\n\t\treturn &Func{Name: \"_tocsv\"}\n\tcase \"@tsv\":\n\t\treturn &Func{Name: \"_totsv\"}\n\tcase \"@sh\":\n\t\treturn &Func{Name: \"_tosh\"}\n\tcase \"@base64\":\n\t\treturn &Func{Name: \"_tobase64\"}\n\tcase \"@base64d\":\n\t\treturn &Func{Name: \"_tobase64d\"}\n\tdefault:\n\t\treturn nil\n\t}\n}\n\nfunc (c *compiler) compileString(s *String, f *Func) error {\n\tif s.Queries == nil {\n\t\tc.append(&code{op: opconst, v: s.Str})\n\t\treturn nil\n\t}\n\tif f == nil {\n\t\tf = &Func{Name: \"tostring\"}\n\t}\n\tvar q *Query\n\tfor _, e := range s.Queries {\n\t\tif e.Term.Str == nil {\n\t\t\te = &Query{Left: e, Op: OpPipe, Right: &Query{Term: &Term{Type: TermTypeFunc, Func: f}}}\n\t\t}\n\t\tif q == nil {\n\t\t\tq = e\n\t\t} else {\n\t\t\tq = &Query{Left: q, Op: OpAdd, Right: e}\n\t\t}\n\t}\n\treturn c.compileQuery(q)\n}\n\nfunc (c *compiler) compileTermSuffix(e *Term, s *Suffix) error {\n\tif s.Index != nil {\n\t\treturn c.compileIndex(e, s.Index)\n\t} else if s.Iter {\n\t\tif err := c.compileTerm(e); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tc.append(&code{op: opiter})\n\t\treturn nil\n\t} else if s.Optional {\n\t\tif len(e.SuffixList) > 0 {\n\t\t\tif u := e.SuffixList[len(e.SuffixList)-1].toTerm(); u != nil {\n\t\t\t\t// no need to clone (ref: compileTerm)\n\t\t\t\te.SuffixList = e.SuffixList[:len(e.SuffixList)-1]\n\t\t\t\tif err := c.compileTerm(e); err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t\te = u\n\t\t\t}\n\t\t}\n\t\treturn c.compileTry(&Try{Body: &Query{Term: e}})\n\t} else if s.Bind != nil {\n\t\treturn c.compileBind(e, s.Bind)\n\t} else {\n\t\treturn fmt.Errorf(\"invalid suffix: %s\", s)\n\t}\n}\n\nfunc (c *compiler) compileCall(name string, args []*Query) error {\n\tfn := internalFuncs[name]\n\tvar indexing int\n\tswitch name {\n\tcase \"_index\", \"_slice\":\n\t\tindexing = 1\n\tcase \"getpath\":\n\t\tindexing = 0\n\tdefault:\n\t\tindexing = -1\n\t}\n\tif err := c.compileCallInternal(\n\t\t[3]any{fn.callback, len(args), name},\n\t\targs,\n\t\ttrue,\n\t\tindexing,\n\t); err != nil {\n\t\treturn err\n\t}\n\tif fn.iter {\n\t\tc.append(&code{op: opiter})\n\t}\n\treturn nil\n}\n\nfunc (c *compiler) compileCallPc(fn *funcinfo, args []*Query) error {\n\treturn c.compileCallInternal(fn.pc, args, false, -1)\n}\n\nfunc (c *compiler) compileCallInternal(\n\tfn any, args []*Query, internal bool, indexing int,\n) error {\n\tif len(args) == 0 {\n\t\tc.append(&code{op: opcall, v: fn})\n\t\treturn nil\n\t}\n\tv := c.newVariable()\n\tc.append(&code{op: opstore, v: v})\n\tif indexing >= 0 {\n\t\tc.append(&code{op: opexpbegin})\n\t}\n\tfor i := len(args) - 1; i >= 0; i-- {\n\t\tpc := len(c.codes) + 1 // skip opjump (ref: compileFuncDef)\n\t\tname := \"lambda:\" + strconv.Itoa(pc)\n\t\tif err := c.compileFuncDef(&FuncDef{Name: name, Body: args[i]}, false); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif internal {\n\t\t\tswitch len(c.codes) - pc {\n\t\t\tcase 2: // optimize identity argument (opscope, opret)\n\t\t\t\tj := len(c.codes) - 3\n\t\t\t\tc.codes[j] = &code{op: opload, v: v}\n\t\t\t\tc.codes = c.codes[:j+1]\n\t\t\t\ts := c.scopes[len(c.scopes)-1]\n\t\t\t\ts.funcs = s.funcs[:len(s.funcs)-1]\n\t\t\t\tc.deleteCodeInfo(name)\n\t\t\tcase 3: // optimize one instruction argument (opscope, opX, opret)\n\t\t\t\tj := len(c.codes) - 4\n\t\t\t\tif c.codes[j+2].op == opconst {\n\t\t\t\t\tc.codes[j] = &code{op: oppush, v: c.codes[j+2].v}\n\t\t\t\t\tc.codes = c.codes[:j+1]\n\t\t\t\t} else {\n\t\t\t\t\tc.codes[j] = &code{op: opload, v: v}\n\t\t\t\t\tc.codes[j+1] = c.codes[j+2]\n\t\t\t\t\tc.codes = c.codes[:j+2]\n\t\t\t\t}\n\t\t\t\ts := c.scopes[len(c.scopes)-1]\n\t\t\t\ts.funcs = s.funcs[:len(s.funcs)-1]\n\t\t\t\tc.deleteCodeInfo(name)\n\t\t\tdefault:\n\t\t\t\tc.append(&code{op: opload, v: v})\n\t\t\t\tc.append(&code{op: oppushpc, v: pc})\n\t\t\t\tc.append(&code{op: opcallpc})\n\t\t\t}\n\t\t} else {\n\t\t\tc.append(&code{op: oppushpc, v: pc})\n\t\t}\n\t\tif i == indexing {\n\t\t\tif c.codes[len(c.codes)-2].op == opexpbegin {\n\t\t\t\tc.codes[len(c.codes)-2] = c.codes[len(c.codes)-1]\n\t\t\t\tc.codes = c.codes[:len(c.codes)-1]\n\t\t\t} else {\n\t\t\t\tc.append(&code{op: opexpend})\n\t\t\t}\n\t\t}\n\t}\n\tif indexing > 0 {\n\t\tc.append(&code{op: oppush, v: nil})\n\t} else {\n\t\tc.append(&code{op: opload, v: v})\n\t}\n\tc.append(&code{op: opcall, v: fn})\n\treturn nil\n}\n\nfunc (c *compiler) append(code *code) {\n\tc.codes = append(c.codes, code)\n}\n\nfunc (c *compiler) appends(codes ...*code) {\n\tc.codes = append(c.codes, codes...)\n}\n\nfunc (c *compiler) lazy(f func() *code) func() {\n\ti := len(c.codes)\n\tc.codes = append(c.codes, nil)\n\treturn func() { c.codes[i] = f() }\n}\n\nfunc (c *compiler) optimizeTailRec() {\n\tvar pcs []int\n\tscopes := map[int]bool{}\nL:\n\tfor i, l := 0, len(c.codes); i < l; i++ {\n\t\tswitch c.codes[i].op {\n\t\tcase opscope:\n\t\t\tpcs = append(pcs, i)\n\t\t\tif v := c.codes[i].v.([3]int); v[2] == 0 {\n\t\t\t\tscopes[i] = v[1] == 0\n\t\t\t}\n\t\tcase opcall:\n\t\t\tvar canjump bool\n\t\t\tif j, ok := c.codes[i].v.(int); !ok ||\n\t\t\t\tlen(pcs) == 0 || pcs[len(pcs)-1] != j {\n\t\t\t\tbreak\n\t\t\t} else if canjump, ok = scopes[j]; !ok {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tfor j := i + 1; j < l; {\n\t\t\t\tswitch c.codes[j].op {\n\t\t\t\tcase opjump:\n\t\t\t\t\tj = c.codes[j].v.(int)\n\t\t\t\tcase opret:\n\t\t\t\t\tif canjump {\n\t\t\t\t\t\tc.codes[i].op = opjump\n\t\t\t\t\t\tc.codes[i].v = pcs[len(pcs)-1] + 1\n\t\t\t\t\t} else {\n\t\t\t\t\t\tc.codes[i].op = opcallrec\n\t\t\t\t\t}\n\t\t\t\t\tcontinue L\n\t\t\t\tdefault:\n\t\t\t\t\tcontinue L\n\t\t\t\t}\n\t\t\t}\n\t\tcase opret:\n\t\t\tif len(pcs) == 0 {\n\t\t\t\tbreak L\n\t\t\t}\n\t\t\tpcs = pcs[:len(pcs)-1]\n\t\t}\n\t}\n}\n\nfunc (c *compiler) optimizeCodeOps() {\n\tfor i, next := len(c.codes)-1, (*code)(nil); i >= 0; i-- {\n\t\tcode := c.codes[i]\n\t\tswitch code.op {\n\t\tcase oppush, opdup, opload:\n\t\t\tswitch next.op {\n\t\t\tcase oppop:\n\t\t\t\tcode.op = opnop\n\t\t\t\tnext.op = opnop\n\t\t\tcase opconst:\n\t\t\t\tcode.op = opnop\n\t\t\t\tnext.op = oppush\n\t\t\t}\n\t\tcase opjump, opjumpifnot:\n\t\t\tif j := code.v.(int); j-1 == i {\n\t\t\t\tcode.op = opnop\n\t\t\t} else if next = c.codes[j]; next.op == opjump {\n\t\t\t\tcode.v = next.v\n\t\t\t}\n\t\t}\n\t\tnext = code\n\t}\n}\n"
        },
        {
          "name": "compiler_test.go",
          "type": "blob",
          "size": 7.4716796875,
          "content": "package gojq_test\n\nimport (\n\t\"context\"\n\t\"errors\"\n\t\"fmt\"\n\t\"log\"\n\t\"os\"\n\t\"reflect\"\n\t\"sync\"\n\t\"testing\"\n\t\"time\"\n\t\"unsafe\"\n\n\t\"github.com/itchyny/gojq\"\n)\n\nfunc ExampleCompile() {\n\tquery, err := gojq.Parse(\".[] | .foo\")\n\tif err != nil {\n\t\tlog.Fatalln(err)\n\t}\n\tcode, err := gojq.Compile(query)\n\tif err != nil {\n\t\tlog.Fatalln(err)\n\t}\n\titer := code.Run([]any{\n\t\tnil,\n\t\t\"string\",\n\t\t42,\n\t\t[]any{\"foo\"},\n\t\tmap[string]any{\"foo\": 42},\n\t})\n\tfor {\n\t\tv, ok := iter.Next()\n\t\tif !ok {\n\t\t\tbreak\n\t\t}\n\t\tif err, ok := v.(error); ok {\n\t\t\tfmt.Println(err)\n\t\t\tcontinue\n\t\t}\n\t\tfmt.Printf(\"%#v\\n\", v)\n\t}\n\n\t// Output:\n\t// <nil>\n\t// expected an object but got: string (\"string\")\n\t// expected an object but got: number (42)\n\t// expected an object but got: array ([\"foo\"])\n\t// 42\n}\n\nfunc ExampleCode_Run() {\n\tquery, err := gojq.Parse(\".foo\")\n\tif err != nil {\n\t\tlog.Fatalln(err)\n\t}\n\tcode, err := gojq.Compile(query)\n\tif err != nil {\n\t\tlog.Fatalln(err)\n\t}\n\tinput := map[string]any{\"foo\": 42}\n\titer := code.Run(input)\n\tfor {\n\t\tv, ok := iter.Next()\n\t\tif !ok {\n\t\t\tbreak\n\t\t}\n\t\tif err, ok := v.(error); ok {\n\t\t\tlog.Fatalln(err)\n\t\t}\n\t\tfmt.Printf(\"%#v\\n\", v)\n\t}\n\n\t// Output:\n\t// 42\n}\n\nfunc ExampleCode_RunWithContext() {\n\tquery, err := gojq.Parse(\"def f: f; f, f\")\n\tif err != nil {\n\t\tlog.Fatalln(err)\n\t}\n\tcode, err := gojq.Compile(query)\n\tif err != nil {\n\t\tlog.Fatalln(err)\n\t}\n\tctx, cancel := context.WithTimeout(context.Background(), 100*time.Millisecond)\n\tdefer cancel()\n\titer := code.RunWithContext(ctx, nil)\n\tfor {\n\t\tv, ok := iter.Next()\n\t\tif !ok {\n\t\t\tbreak\n\t\t}\n\t\tif err, ok := v.(error); ok {\n\t\t\tfmt.Println(err)\n\t\t\tcontinue\n\t\t}\n\t\t_ = v\n\t}\n\n\t// Output:\n\t// context deadline exceeded\n}\n\nfunc TestCodeCompile_OptimizeConstants(t *testing.T) {\n\tquery, err := gojq.Parse(`[1,{foo:2,\"bar\":+3},[-4]]`)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tcode, err := gojq.Compile(query)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tcodes := reflect.ValueOf(code).Elem().FieldByName(\"codes\")\n\tif got, expected := codes.Len(), 3; expected != got {\n\t\tt.Errorf(\"expected: %v, got: %v\", expected, got)\n\t}\n\titer := code.Run(nil)\n\tfor {\n\t\tgot, ok := iter.Next()\n\t\tif !ok {\n\t\t\tbreak\n\t\t}\n\t\tif expected := []any{\n\t\t\t1, map[string]any{\"foo\": 2, \"bar\": 3}, []any{-4},\n\t\t}; !reflect.DeepEqual(got, expected) {\n\t\t\tt.Errorf(\"expected: %v, got: %v\", expected, got)\n\t\t}\n\t}\n}\n\nfunc TestCodeCompile_OptimizeIndexSlice(t *testing.T) {\n\tquery, err := gojq.Parse(`.foo.\"bar\".[\"baz\"].[-1].\"\".[0:1]`)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tcode, err := gojq.Compile(query)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tcodes := reflect.ValueOf(code).Elem().FieldByName(\"codes\")\n\tif got, expected := codes.Len(), 8; expected != got {\n\t\tt.Errorf(\"expected: %v, got: %v\", expected, got)\n\t}\n\titer := code.Run(nil)\n\tfor {\n\t\tgot, ok := iter.Next()\n\t\tif !ok {\n\t\t\tbreak\n\t\t}\n\t\tif got != nil {\n\t\t\tt.Errorf(\"expected: %v, got: %v\", nil, got)\n\t\t}\n\t}\n}\n\nfunc TestCodeCompile_OptimizeIndexSliceAssign(t *testing.T) {\n\tquery, err := gojq.Parse(`.foo.\"bar\".[\"baz\"].[0].\"\".[0:1] = [0]`)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tcode, err := gojq.Compile(query)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tcodes := reflect.ValueOf(code).Elem().FieldByName(\"codes\")\n\tif got, expected := codes.Len(), 8; expected != got {\n\t\tt.Errorf(\"expected: %v, got: %v\", expected, got)\n\t}\n\titer := code.Run(nil)\n\tfor {\n\t\tgot, ok := iter.Next()\n\t\tif !ok {\n\t\t\tbreak\n\t\t}\n\t\tif expected := map[string]any{\n\t\t\t\"foo\": map[string]any{\n\t\t\t\t\"bar\": map[string]any{\n\t\t\t\t\t\"baz\": []any{map[string]any{\"\": []any{0}}},\n\t\t\t\t},\n\t\t\t},\n\t\t}; !reflect.DeepEqual(got, expected) {\n\t\t\tt.Errorf(\"expected: %v, got: %v\", expected, got)\n\t\t}\n\t}\n}\n\nfunc TestCodeCompile_OptimizeTailRec_While(t *testing.T) {\n\tquery, err := gojq.Parse(\"0 | while(. < 10; . + 1)\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tcode, err := gojq.Compile(query)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tcodes := reflect.ValueOf(code).Elem().FieldByName(\"codes\")\n\tif got, expected := codes.Len(), 48; expected != got {\n\t\tt.Errorf(\"expected: %v, got: %v\", expected, got)\n\t}\n\top1 := codes.Index(2).Elem().FieldByName(\"op\")\n\top2 := codes.Index(21).Elem().FieldByName(\"op\") // test jump of call _while\n\tif got, expected := *(*int)(unsafe.Pointer(op2.UnsafeAddr())),\n\t\t*(*int)(unsafe.Pointer(op1.UnsafeAddr())); expected != got {\n\t\tt.Errorf(\"expected: %v, got: %v\", expected, got)\n\t}\n\titer := code.Run(nil)\n\tn := 0\n\tfor {\n\t\tgot, ok := iter.Next()\n\t\tif !ok {\n\t\t\tbreak\n\t\t}\n\t\tif !reflect.DeepEqual(got, n) {\n\t\t\tt.Errorf(\"expected: %v, got: %v\", n, got)\n\t\t}\n\t\tn++\n\t}\n\tif expected := 10; n != expected {\n\t\tt.Errorf(\"expected: %v, got: %v\", expected, n)\n\t}\n}\n\nfunc TestCodeCompile_OptimizeTailRec_CallRec(t *testing.T) {\n\tquery, err := gojq.Parse(`\n\t\tdef f: . as $x | $x, (if $x < 3 then $x + 1 | f else empty end), $x; f\n\t`)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tcode, err := gojq.Compile(query)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tcodes := reflect.ValueOf(code).Elem().FieldByName(\"codes\")\n\tif got, expected := codes.Len(), 48; expected != got {\n\t\tt.Errorf(\"expected: %v, got: %v\", expected, got)\n\t}\n\top1 := codes.Index(39).Elem().FieldByName(\"op\") // callrec f\n\top2 := codes.Index(38).Elem().FieldByName(\"op\") // call _add/2\n\tif got, expected := *(*int)(unsafe.Pointer(op2.UnsafeAddr()))+1,\n\t\t*(*int)(unsafe.Pointer(op1.UnsafeAddr())); expected != got {\n\t\tt.Errorf(\"expected: %v, got: %v\", expected, got)\n\t}\n}\n\nfunc TestCodeCompile_OptimizeJumps(t *testing.T) {\n\tquery, err := gojq.Parse(\"def f: 1; def g: 2; def h: 3; f\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tcode, err := gojq.Compile(query)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tcodes := reflect.ValueOf(code).Elem().FieldByName(\"codes\")\n\tif got, expected := codes.Len(), 15; expected != got {\n\t\tt.Errorf(\"expected: %v, got: %v\", expected, got)\n\t}\n\tv := codes.Index(1).Elem().FieldByName(\"v\")\n\tif got, expected := *(*any)(unsafe.Pointer(v.UnsafeAddr())), 13; expected != got {\n\t\tt.Errorf(\"expected: %v, got: %v\", expected, got)\n\t}\n\titer := code.Run(nil)\n\tfor {\n\t\tgot, ok := iter.Next()\n\t\tif !ok {\n\t\t\tbreak\n\t\t}\n\t\tif expected := 1; !reflect.DeepEqual(got, expected) {\n\t\t\tt.Errorf(\"expected: %v, got: %v\", expected, got)\n\t\t}\n\t}\n}\n\nfunc TestParseErrorTokenOffset(t *testing.T) {\n\ttestCases := []struct {\n\t\tsrc    string\n\t\toffset int\n\t}{\n\t\t{src: \"^\", offset: 1},\n\t\t{src: \" ^\", offset: 2},\n\t\t{src: \" ^ \", offset: 2},\n\t\t{src: \"👍\", offset: 4},\n\t\t{src: \" 👍\", offset: 5},\n\t\t{src: \" 👍 \", offset: 5},\n\t\t{src: \"test👍\", offset: 8},\n\t}\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.src, func(t *testing.T) {\n\t\t\t_, err := gojq.Parse(tc.src)\n\t\t\tif err == nil {\n\t\t\t\tt.Fatal(\"expected: error\")\n\t\t\t}\n\t\t\tvar pe *gojq.ParseError\n\t\t\tif !errors.As(err, &pe) {\n\t\t\t\tt.Fatalf(\"expected: *gojq.ParseError, got %v\", err)\n\t\t\t}\n\t\t\tif pe.Offset != tc.offset {\n\t\t\t\tt.Fatalf(\"expected: %v, got %v\", tc.offset, pe.Offset)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestCodeRun_Race(t *testing.T) {\n\tquery, err := gojq.Parse(\"range(10)\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tcode, err := gojq.Compile(query)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tvar wg sync.WaitGroup\n\tfor i := 0; i < 10; i++ {\n\t\twg.Add(1)\n\t\tgo func() {\n\t\t\tdefer wg.Done()\n\t\t\titer := code.Run(nil)\n\t\t\tn := 0\n\t\t\tfor {\n\t\t\t\tgot, ok := iter.Next()\n\t\t\t\tif !ok {\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t\tif got != n {\n\t\t\t\t\tt.Errorf(\"expected: %v, got: %v\", n, got)\n\t\t\t\t}\n\t\t\t\tn++\n\t\t\t}\n\t\t\tif expected := 10; n != expected {\n\t\t\t\tt.Errorf(\"expected: %v, got: %v\", expected, n)\n\t\t\t}\n\t\t}()\n\t}\n\twg.Wait()\n}\n\nfunc BenchmarkCompile(b *testing.B) {\n\tcnt, err := os.ReadFile(\"builtin.jq\")\n\tif err != nil {\n\t\tb.Fatal(err)\n\t}\n\tquery, err := gojq.Parse(string(cnt) + \".\")\n\tif err != nil {\n\t\tb.Fatal(err)\n\t}\n\tfor i := 0; i < b.N; i++ {\n\t\t_, err := gojq.Compile(\n\t\t\tquery,\n\t\t\tgojq.WithInputIter(gojq.NewIter()),\n\t\t)\n\t\tif err != nil {\n\t\t\tb.Fatal(err)\n\t\t}\n\t}\n}\n"
        },
        {
          "name": "debug.go",
          "type": "blob",
          "size": 3.921875,
          "content": "//go:build gojq_debug\n\npackage gojq\n\nimport (\n\t\"fmt\"\n\t\"io\"\n\t\"os\"\n\t\"strconv\"\n\t\"strings\"\n)\n\nvar (\n\tdebug    bool\n\tdebugOut io.Writer\n)\n\nfunc init() {\n\tif out := os.Getenv(\"GOJQ_DEBUG\"); out != \"\" {\n\t\tdebug = true\n\t\tif out == \"stdout\" {\n\t\t\tdebugOut = os.Stdout\n\t\t} else {\n\t\t\tdebugOut = os.Stderr\n\t\t}\n\t}\n}\n\ntype codeinfo struct {\n\tname string\n\tpc   int\n}\n\nfunc (c *compiler) appendCodeInfo(x any) {\n\tif !debug {\n\t\treturn\n\t}\n\tvar name string\n\tswitch x := x.(type) {\n\tcase string:\n\t\tname = x\n\tdefault:\n\t\tname = fmt.Sprint(x)\n\t}\n\tvar diff int\n\tif c.codes[len(c.codes)-1] != nil && c.codes[len(c.codes)-1].op == opret && strings.HasPrefix(name, \"end of \") {\n\t\tdiff = -1\n\t}\n\tc.codeinfos = append(c.codeinfos, codeinfo{name, len(c.codes) + diff})\n}\n\nfunc (c *compiler) deleteCodeInfo(name string) {\n\tfor i := 0; i < len(c.codeinfos); i++ {\n\t\tif strings.HasSuffix(c.codeinfos[i].name, name) {\n\t\t\tcopy(c.codeinfos[i:], c.codeinfos[i+1:])\n\t\t\tc.codeinfos = c.codeinfos[:len(c.codeinfos)-1]\n\t\t\ti--\n\t\t}\n\t}\n}\n\nfunc (env *env) lookupInfoName(pc int) string {\n\tvar name string\n\tfor _, ci := range env.codeinfos {\n\t\tif ci.pc == pc {\n\t\t\tif name != \"\" {\n\t\t\t\tname += \", \"\n\t\t\t}\n\t\t\tname += ci.name\n\t\t}\n\t}\n\treturn name\n}\n\nfunc (env *env) debugCodes() {\n\tif !debug {\n\t\treturn\n\t}\n\tfor i, c := range env.codes {\n\t\tpc := i\n\t\tswitch c.op {\n\t\tcase opcall, opcallrec:\n\t\t\tif x, ok := c.v.(int); ok {\n\t\t\t\tpc = x\n\t\t\t}\n\t\tcase opjump:\n\t\t\tx := c.v.(int)\n\t\t\tif x > 0 && env.codes[x-1].op == opscope {\n\t\t\t\tpc = x - 1\n\t\t\t}\n\t\t}\n\t\tvar s string\n\t\tif name := env.lookupInfoName(pc); name != \"\" {\n\t\t\tswitch c.op {\n\t\t\tcase opcall, opcallrec, opjump:\n\t\t\t\tif !strings.HasPrefix(name, \"module \") {\n\t\t\t\t\ts = \"\\t## call \" + name\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t\tfallthrough\n\t\t\tdefault:\n\t\t\t\ts = \"\\t## \" + name\n\t\t\t}\n\t\t}\n\t\tfmt.Fprintf(debugOut, \"\\t%d\\t%-*s%s%s\\n\", i, 25, c.op, debugOperand(c), s)\n\t}\n\tfmt.Fprintln(debugOut, \"\\t\"+strings.Repeat(\"-\", 40)+\"+\")\n}\n\nfunc (env *env) debugState(pc int, backtrack bool) {\n\tif !debug {\n\t\treturn\n\t}\n\tvar sb strings.Builder\n\tc := env.codes[pc]\n\top := c.op.String()\n\tif backtrack {\n\t\top += \" <backtrack>\"\n\t}\n\tfmt.Fprintf(&sb, \"\\t%d\\t%-*s%s\\t|\", pc, 25, op, debugOperand(c))\n\tvar xs []int\n\tfor i := env.stack.index; i >= 0; i = env.stack.data[i].next {\n\t\txs = append(xs, i)\n\t}\n\tfor i := len(xs) - 1; i >= 0; i-- {\n\t\tsb.WriteString(\"\\t\")\n\t\tsb.WriteString(debugValue(env.stack.data[xs[i]].value))\n\t}\n\tswitch c.op {\n\tcase opcall, opcallrec:\n\t\tif x, ok := c.v.(int); ok {\n\t\t\tpc = x\n\t\t}\n\tcase opjump:\n\t\tx := c.v.(int)\n\t\tif x > 0 && env.codes[x-1].op == opscope {\n\t\t\tpc = x - 1\n\t\t}\n\t}\n\tif name := env.lookupInfoName(pc); name != \"\" {\n\t\tswitch c.op {\n\t\tcase opcall, opcallrec, opjump:\n\t\t\tif !strings.HasPrefix(name, \"module \") {\n\t\t\t\tsb.WriteString(\"\\t\\t\\t## call \" + name)\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tfallthrough\n\t\tdefault:\n\t\t\tsb.WriteString(\"\\t\\t\\t## \" + name)\n\t\t}\n\t}\n\tfmt.Fprintln(debugOut, sb.String())\n}\n\nfunc (env *env) debugForks(pc int, op string) {\n\tif !debug {\n\t\treturn\n\t}\n\tvar sb strings.Builder\n\tfor i, v := range env.forks {\n\t\tif i > 0 {\n\t\t\tsb.WriteByte('\\t')\n\t\t}\n\t\tif i == len(env.forks)-1 {\n\t\t\tsb.WriteByte('<')\n\t\t}\n\t\tfmt.Fprintf(&sb, \"%d, %s\", v.pc, debugValue(env.stack.data[v.stackindex].value))\n\t\tif i == len(env.forks)-1 {\n\t\t\tsb.WriteByte('>')\n\t\t}\n\t}\n\tfmt.Fprintf(debugOut, \"\\t-\\t%-*s%d\\t|\\t%s\\n\", 25, op, pc, sb.String())\n}\n\nfunc debugOperand(c *code) string {\n\tswitch c.op {\n\tcase opcall, opcallrec:\n\t\tswitch v := c.v.(type) {\n\t\tcase int:\n\t\t\treturn strconv.Itoa(v)\n\t\tcase [3]any:\n\t\t\treturn fmt.Sprintf(\"%s/%d\", v[2], v[1])\n\t\tdefault:\n\t\t\tpanic(c)\n\t\t}\n\tdefault:\n\t\treturn debugValue(c.v)\n\t}\n}\n\nfunc debugValue(v any) string {\n\tswitch v := v.(type) {\n\tcase Iter:\n\t\treturn fmt.Sprintf(\"gojq.Iter(%#v)\", v)\n\tcase []pathValue:\n\t\treturn fmt.Sprintf(\"[]gojq.pathValue(%v)\", v)\n\tcase [2]int:\n\t\treturn fmt.Sprintf(\"[%d,%d]\", v[0], v[1])\n\tcase [3]int:\n\t\treturn fmt.Sprintf(\"[%d,%d,%d]\", v[0], v[1], v[2])\n\tcase [3]any:\n\t\treturn fmt.Sprintf(\"[%v,%v,%v]\", v[0], v[1], v[2])\n\tcase allocator:\n\t\treturn fmt.Sprintf(\"%v\", v)\n\tdefault:\n\t\treturn Preview(v)\n\t}\n}\n"
        },
        {
          "name": "encoder.go",
          "type": "blob",
          "size": 3.798828125,
          "content": "package gojq\n\nimport (\n\t\"bytes\"\n\t\"fmt\"\n\t\"io\"\n\t\"math\"\n\t\"math/big\"\n\t\"sort\"\n\t\"strconv\"\n\t\"strings\"\n\t\"unicode/utf8\"\n)\n\n// Marshal returns the jq-flavored JSON encoding of v.\n//\n// This method accepts only limited types (nil, bool, int, float64, *big.Int,\n// string, []any, and map[string]any) because these are the possible types a\n// gojq iterator can emit. This method marshals NaN to null, truncates\n// infinities to (+|-) math.MaxFloat64, uses \\b and \\f in strings, and does not\n// escape '<', '>', '&', '\\u2028', and '\\u2029'. These behaviors are based on\n// the marshaler of jq command, and different from json.Marshal in the Go\n// standard library. Note that the result is not safe to embed in HTML.\nfunc Marshal(v any) ([]byte, error) {\n\tvar b bytes.Buffer\n\t(&encoder{w: &b}).encode(v)\n\treturn b.Bytes(), nil\n}\n\nfunc jsonMarshal(v any) string {\n\tvar sb strings.Builder\n\t(&encoder{w: &sb}).encode(v)\n\treturn sb.String()\n}\n\nfunc jsonEncodeString(sb *strings.Builder, v string) {\n\t(&encoder{w: sb}).encodeString(v)\n}\n\ntype encoder struct {\n\tw interface {\n\t\tio.Writer\n\t\tio.ByteWriter\n\t\tio.StringWriter\n\t}\n\tbuf [64]byte\n}\n\nfunc (e *encoder) encode(v any) {\n\tswitch v := v.(type) {\n\tcase nil:\n\t\te.w.WriteString(\"null\")\n\tcase bool:\n\t\tif v {\n\t\t\te.w.WriteString(\"true\")\n\t\t} else {\n\t\t\te.w.WriteString(\"false\")\n\t\t}\n\tcase int:\n\t\te.w.Write(strconv.AppendInt(e.buf[:0], int64(v), 10))\n\tcase float64:\n\t\te.encodeFloat64(v)\n\tcase *big.Int:\n\t\te.w.Write(v.Append(e.buf[:0], 10))\n\tcase string:\n\t\te.encodeString(v)\n\tcase []any:\n\t\te.encodeArray(v)\n\tcase map[string]any:\n\t\te.encodeObject(v)\n\tdefault:\n\t\tpanic(fmt.Sprintf(\"invalid type: %[1]T (%[1]v)\", v))\n\t}\n}\n\n// ref: floatEncoder in encoding/json\nfunc (e *encoder) encodeFloat64(f float64) {\n\tif math.IsNaN(f) {\n\t\te.w.WriteString(\"null\")\n\t\treturn\n\t}\n\tf = min(max(f, -math.MaxFloat64), math.MaxFloat64)\n\tformat := byte('f')\n\tif x := math.Abs(f); x != 0 && x < 1e-6 || x >= 1e21 {\n\t\tformat = 'e'\n\t}\n\tbuf := strconv.AppendFloat(e.buf[:0], f, format, -1, 64)\n\tif format == 'e' {\n\t\t// clean up e-09 to e-9\n\t\tif n := len(buf); n >= 4 && buf[n-4] == 'e' && buf[n-3] == '-' && buf[n-2] == '0' {\n\t\t\tbuf[n-2] = buf[n-1]\n\t\t\tbuf = buf[:n-1]\n\t\t}\n\t}\n\te.w.Write(buf)\n}\n\n// ref: encodeState#string in encoding/json\nfunc (e *encoder) encodeString(s string) {\n\te.w.WriteByte('\"')\n\tstart := 0\n\tfor i := 0; i < len(s); {\n\t\tif b := s[i]; b < utf8.RuneSelf {\n\t\t\tif ' ' <= b && b <= '~' && b != '\"' && b != '\\\\' {\n\t\t\t\ti++\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif start < i {\n\t\t\t\te.w.WriteString(s[start:i])\n\t\t\t}\n\t\t\tswitch b {\n\t\t\tcase '\"':\n\t\t\t\te.w.WriteString(`\\\"`)\n\t\t\tcase '\\\\':\n\t\t\t\te.w.WriteString(`\\\\`)\n\t\t\tcase '\\b':\n\t\t\t\te.w.WriteString(`\\b`)\n\t\t\tcase '\\f':\n\t\t\t\te.w.WriteString(`\\f`)\n\t\t\tcase '\\n':\n\t\t\t\te.w.WriteString(`\\n`)\n\t\t\tcase '\\r':\n\t\t\t\te.w.WriteString(`\\r`)\n\t\t\tcase '\\t':\n\t\t\t\te.w.WriteString(`\\t`)\n\t\t\tdefault:\n\t\t\t\tconst hex = \"0123456789abcdef\"\n\t\t\t\te.w.WriteString(`\\u00`)\n\t\t\t\te.w.WriteByte(hex[b>>4])\n\t\t\t\te.w.WriteByte(hex[b&0xF])\n\t\t\t}\n\t\t\ti++\n\t\t\tstart = i\n\t\t\tcontinue\n\t\t}\n\t\tc, size := utf8.DecodeRuneInString(s[i:])\n\t\tif c == utf8.RuneError && size == 1 {\n\t\t\tif start < i {\n\t\t\t\te.w.WriteString(s[start:i])\n\t\t\t}\n\t\t\te.w.WriteString(`\\ufffd`)\n\t\t\ti += size\n\t\t\tstart = i\n\t\t\tcontinue\n\t\t}\n\t\ti += size\n\t}\n\tif start < len(s) {\n\t\te.w.WriteString(s[start:])\n\t}\n\te.w.WriteByte('\"')\n}\n\nfunc (e *encoder) encodeArray(vs []any) {\n\te.w.WriteByte('[')\n\tfor i, v := range vs {\n\t\tif i > 0 {\n\t\t\te.w.WriteByte(',')\n\t\t}\n\t\te.encode(v)\n\t}\n\te.w.WriteByte(']')\n}\n\nfunc (e *encoder) encodeObject(vs map[string]any) {\n\te.w.WriteByte('{')\n\ttype keyVal struct {\n\t\tkey string\n\t\tval any\n\t}\n\tkvs := make([]keyVal, len(vs))\n\tvar i int\n\tfor k, v := range vs {\n\t\tkvs[i] = keyVal{k, v}\n\t\ti++\n\t}\n\tsort.Slice(kvs, func(i, j int) bool {\n\t\treturn kvs[i].key < kvs[j].key\n\t})\n\tfor i, kv := range kvs {\n\t\tif i > 0 {\n\t\t\te.w.WriteByte(',')\n\t\t}\n\t\te.encodeString(kv.key)\n\t\te.w.WriteByte(':')\n\t\te.encode(kv.val)\n\t}\n\te.w.WriteByte('}')\n}\n"
        },
        {
          "name": "encoder_test.go",
          "type": "blob",
          "size": 1.3291015625,
          "content": "package gojq_test\n\nimport (\n\t\"fmt\"\n\t\"math\"\n\t\"math/big\"\n\t\"testing\"\n\n\t\"github.com/itchyny/gojq\"\n)\n\nfunc TestMarshal(t *testing.T) {\n\ttestCases := []struct {\n\t\tvalue    any\n\t\texpected string\n\t}{\n\t\t{\n\t\t\tvalue:    nil,\n\t\t\texpected: \"null\",\n\t\t},\n\t\t{\n\t\t\tvalue:    []any{false, true},\n\t\t\texpected: \"[false,true]\",\n\t\t},\n\t\t{\n\t\t\tvalue: []any{\n\t\t\t\t42, 3.14, 1e-6, 1e-7, -1e-9, 1e-10, math.NaN(), math.Inf(1), math.Inf(-1),\n\t\t\t\tnew(big.Int).SetBytes([]byte(\"\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\")),\n\t\t\t},\n\t\t\texpected: \"[42,3.14,0.000001,1e-7,-1e-9,1e-10,null,1.7976931348623157e+308,-1.7976931348623157e+308,340282366920938463463374607431768211455]\",\n\t\t},\n\t\t{\n\t\t\tvalue:    []any{\"\", \"abcde\", \"foo\\x00\\x1f\\r\\n\\t\\f\\b<=>!\\\"#$%'& \\\\\\x7fbar\"},\n\t\t\texpected: `[\"\",\"abcde\",\"foo\\u0000\\u001f\\r\\n\\t\\f\\b<=>!\\\"#$%'& \\\\\\u007fbar\"]`,\n\t\t},\n\t\t{\n\t\t\tvalue:    []any{1, []any{2, []any{3, []any{map[string]any{}}}}},\n\t\t\texpected: `[1,[2,[3,[{}]]]]`,\n\t\t},\n\t\t{\n\t\t\tvalue:    map[string]any{\"x\": []any{100}, \"y\": map[string]any{\"z\": 42}},\n\t\t\texpected: `{\"x\":[100],\"y\":{\"z\":42}}`,\n\t\t},\n\t}\n\tfor _, tc := range testCases {\n\t\tt.Run(fmt.Sprintf(\"%v\", tc.value), func(t *testing.T) {\n\t\t\tgot, err := gojq.Marshal(tc.value)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\t\t\tif string(got) != tc.expected {\n\t\t\t\tt.Errorf(\"expected: %s, got: %s\", tc.expected, string(got))\n\t\t\t}\n\t\t})\n\t}\n}\n"
        },
        {
          "name": "env.go",
          "type": "blob",
          "size": 0.71875,
          "content": "package gojq\n\nimport \"context\"\n\ntype env struct {\n\tpc        int\n\tstack     *stack\n\tpaths     *stack\n\tscopes    *scopeStack\n\tvalues    []any\n\tcodes     []*code\n\tcodeinfos []codeinfo\n\tforks     []fork\n\tbacktrack bool\n\toffset    int\n\texpdepth  int\n\tlabel     int\n\targs      [32]any // len(env.args) > maxarity\n\tctx       context.Context\n}\n\nfunc newEnv(ctx context.Context) *env {\n\treturn &env{\n\t\tstack:  newStack(),\n\t\tpaths:  newStack(),\n\t\tscopes: newScopeStack(),\n\t\tctx:    ctx,\n\t}\n}\n\ntype scope struct {\n\tid         int\n\toffset     int\n\tpc         int\n\tsaveindex  int\n\touterindex int\n}\n\ntype fork struct {\n\tpc         int\n\tstackindex int\n\tstacklimit int\n\tscopeindex int\n\tscopelimit int\n\tpathindex  int\n\tpathlimit  int\n\texpdepth   int\n}\n"
        },
        {
          "name": "error.go",
          "type": "blob",
          "size": 8.1298828125,
          "content": "package gojq\n\nimport \"strconv\"\n\n// ValueError is an interface for errors with a value for internal function.\n// Return an error implementing this interface when you want to catch error\n// values (not error messages) by try-catch, just like built-in error function.\n// Refer to [WithFunction] to add a custom internal function.\ntype ValueError interface {\n\terror\n\tValue() any\n}\n\ntype expectedObjectError struct {\n\tv any\n}\n\nfunc (err *expectedObjectError) Error() string {\n\treturn \"expected an object but got: \" + typeErrorPreview(err.v)\n}\n\ntype expectedArrayError struct {\n\tv any\n}\n\nfunc (err *expectedArrayError) Error() string {\n\treturn \"expected an array but got: \" + typeErrorPreview(err.v)\n}\n\ntype iteratorError struct {\n\tv any\n}\n\nfunc (err *iteratorError) Error() string {\n\treturn \"cannot iterate over: \" + typeErrorPreview(err.v)\n}\n\ntype arrayIndexNegativeError struct {\n\tv int\n}\n\nfunc (err *arrayIndexNegativeError) Error() string {\n\treturn \"array index should not be negative: \" + Preview(err.v)\n}\n\ntype arrayIndexTooLargeError struct {\n\tv any\n}\n\nfunc (err *arrayIndexTooLargeError) Error() string {\n\treturn \"array index too large: \" + Preview(err.v)\n}\n\ntype objectKeyNotStringError struct {\n\tv any\n}\n\nfunc (err *objectKeyNotStringError) Error() string {\n\treturn \"expected a string for object key but got: \" + typeErrorPreview(err.v)\n}\n\ntype arrayIndexNotNumberError struct {\n\tv any\n}\n\nfunc (err *arrayIndexNotNumberError) Error() string {\n\treturn \"expected a number for indexing an array but got: \" + typeErrorPreview(err.v)\n}\n\ntype stringIndexNotNumberError struct {\n\tv any\n}\n\nfunc (err *stringIndexNotNumberError) Error() string {\n\treturn \"expected a number for indexing a string but got: \" + typeErrorPreview(err.v)\n}\n\ntype expectedStartEndError struct {\n\tv any\n}\n\nfunc (err *expectedStartEndError) Error() string {\n\treturn `expected \"start\" and \"end\" for slicing but got: ` + typeErrorPreview(err.v)\n}\n\ntype lengthMismatchError struct{}\n\nfunc (*lengthMismatchError) Error() string {\n\treturn \"length mismatch\"\n}\n\ntype inputNotAllowedError struct{}\n\nfunc (*inputNotAllowedError) Error() string {\n\treturn \"input(s)/0 is not allowed\"\n}\n\ntype funcNotFoundError struct {\n\tf *Func\n}\n\nfunc (err *funcNotFoundError) Error() string {\n\treturn \"function not defined: \" + err.f.Name + \"/\" + strconv.Itoa(len(err.f.Args))\n}\n\ntype func0TypeError struct {\n\tname string\n\tv    any\n}\n\nfunc (err *func0TypeError) Error() string {\n\treturn err.name + \" cannot be applied to: \" + typeErrorPreview(err.v)\n}\n\ntype func1TypeError struct {\n\tname string\n\tv, w any\n}\n\nfunc (err *func1TypeError) Error() string {\n\treturn err.name + \"(\" + Preview(err.w) + \") cannot be applied to: \" + typeErrorPreview(err.v)\n}\n\ntype func2TypeError struct {\n\tname    string\n\tv, w, x any\n}\n\nfunc (err *func2TypeError) Error() string {\n\treturn err.name + \"(\" + Preview(err.w) + \"; \" + Preview(err.x) + \") cannot be applied to: \" + typeErrorPreview(err.v)\n}\n\ntype func0WrapError struct {\n\tname string\n\tv    any\n\terr  error\n}\n\nfunc (err *func0WrapError) Error() string {\n\treturn err.name + \" cannot be applied to \" + Preview(err.v) + \": \" + err.err.Error()\n}\n\ntype func1WrapError struct {\n\tname string\n\tv, w any\n\terr  error\n}\n\nfunc (err *func1WrapError) Error() string {\n\treturn err.name + \"(\" + Preview(err.w) + \") cannot be applied to \" + Preview(err.v) + \": \" + err.err.Error()\n}\n\ntype func2WrapError struct {\n\tname    string\n\tv, w, x any\n\terr     error\n}\n\nfunc (err *func2WrapError) Error() string {\n\treturn err.name + \"(\" + Preview(err.w) + \"; \" + Preview(err.x) + \") cannot be applied to \" + Preview(err.v) + \": \" + err.err.Error()\n}\n\ntype exitCodeError struct {\n\tvalue any\n\tcode  int\n}\n\nfunc (err *exitCodeError) Error() string {\n\tif s, ok := err.value.(string); ok {\n\t\treturn \"error: \" + s\n\t}\n\treturn \"error: \" + jsonMarshal(err.value)\n}\n\nfunc (err *exitCodeError) Value() any {\n\treturn err.value\n}\n\nfunc (err *exitCodeError) ExitCode() int {\n\treturn err.code\n}\n\n// HaltError is an error emitted by halt and halt_error functions.\n// It implements [ValueError], and if the value is nil, discard the error\n// and stop the iteration. Consider a query like \"1, halt, 2\";\n// the first value is 1, and the second value is a HaltError with nil value.\n// You might think the iterator should not emit an error this case, but it\n// should so that we can recognize the halt error to stop the outer loop\n// of iterating input values; echo 1 2 3 | gojq \"., halt\".\ntype HaltError exitCodeError\n\nfunc (err *HaltError) Error() string {\n\treturn \"halt \" + (*exitCodeError)(err).Error()\n}\n\n// Value returns the value of the error. This implements [ValueError],\n// but halt error is not catchable by try-catch.\nfunc (err *HaltError) Value() any {\n\treturn (*exitCodeError)(err).Value()\n}\n\n// ExitCode returns the exit code of the error.\nfunc (err *HaltError) ExitCode() int {\n\treturn (*exitCodeError)(err).ExitCode()\n}\n\ntype flattenDepthError struct {\n\tv float64\n}\n\nfunc (err *flattenDepthError) Error() string {\n\treturn \"flatten depth should not be negative: \" + Preview(err.v)\n}\n\ntype joinTypeError struct {\n\tv any\n}\n\nfunc (err *joinTypeError) Error() string {\n\treturn \"join cannot be applied to an array including: \" + typeErrorPreview(err.v)\n}\n\ntype timeArrayError struct{}\n\nfunc (*timeArrayError) Error() string {\n\treturn \"expected an array of 8 numbers\"\n}\n\ntype unaryTypeError struct {\n\tname string\n\tv    any\n}\n\nfunc (err *unaryTypeError) Error() string {\n\treturn \"cannot \" + err.name + \": \" + typeErrorPreview(err.v)\n}\n\ntype binopTypeError struct {\n\tname string\n\tl, r any\n}\n\nfunc (err *binopTypeError) Error() string {\n\treturn \"cannot \" + err.name + \": \" + typeErrorPreview(err.l) + \" and \" + typeErrorPreview(err.r)\n}\n\ntype zeroDivisionError struct {\n\tl, r any\n}\n\nfunc (err *zeroDivisionError) Error() string {\n\treturn \"cannot divide \" + typeErrorPreview(err.l) + \" by: \" + typeErrorPreview(err.r)\n}\n\ntype zeroModuloError struct {\n\tl, r any\n}\n\nfunc (err *zeroModuloError) Error() string {\n\treturn \"cannot modulo \" + typeErrorPreview(err.l) + \" by: \" + typeErrorPreview(err.r)\n}\n\ntype formatNotFoundError struct {\n\tn string\n}\n\nfunc (err *formatNotFoundError) Error() string {\n\treturn \"format not defined: \" + err.n\n}\n\ntype formatRowError struct {\n\ttyp string\n\tv   any\n}\n\nfunc (err *formatRowError) Error() string {\n\treturn \"@\" + err.typ + \" cannot format an array including: \" + typeErrorPreview(err.v)\n}\n\ntype tooManyVariableValuesError struct{}\n\nfunc (*tooManyVariableValuesError) Error() string {\n\treturn \"too many variable values provided\"\n}\n\ntype expectedVariableError struct {\n\tn string\n}\n\nfunc (err *expectedVariableError) Error() string {\n\treturn \"variable defined but not bound: \" + err.n\n}\n\ntype variableNotFoundError struct {\n\tn string\n}\n\nfunc (err *variableNotFoundError) Error() string {\n\treturn \"variable not defined: \" + err.n\n}\n\ntype variableNameError struct {\n\tn string\n}\n\nfunc (err *variableNameError) Error() string {\n\treturn \"invalid variable name: \" + err.n\n}\n\ntype breakError struct {\n\tn string\n\tv any\n}\n\nfunc (err *breakError) Error() string {\n\treturn \"label not defined: \" + err.n\n}\n\nfunc (*breakError) ExitCode() int {\n\treturn 3\n}\n\ntype tryEndError struct {\n\terr error\n}\n\nfunc (err *tryEndError) Error() string {\n\treturn err.err.Error()\n}\n\ntype invalidPathError struct {\n\tv any\n}\n\nfunc (err *invalidPathError) Error() string {\n\treturn \"invalid path against: \" + typeErrorPreview(err.v)\n}\n\ntype invalidPathIterError struct {\n\tv any\n}\n\nfunc (err *invalidPathIterError) Error() string {\n\treturn \"invalid path on iterating against: \" + typeErrorPreview(err.v)\n}\n\ntype queryParseError struct {\n\tfname, contents string\n\terr             error\n}\n\nfunc (err *queryParseError) QueryParseError() (string, string, error) {\n\treturn err.fname, err.contents, err.err\n}\n\nfunc (err *queryParseError) Error() string {\n\treturn \"invalid query: \" + err.fname + \": \" + err.err.Error()\n}\n\ntype jsonParseError struct {\n\tfname, contents string\n\terr             error\n}\n\nfunc (err *jsonParseError) JSONParseError() (string, string, error) {\n\treturn err.fname, err.contents, err.err\n}\n\nfunc (err *jsonParseError) Error() string {\n\treturn \"invalid json: \" + err.fname + \": \" + err.err.Error()\n}\n\nfunc typeErrorPreview(v any) string {\n\tswitch v.(type) {\n\tcase nil:\n\t\treturn \"null\"\n\tcase Iter:\n\t\treturn \"gojq.Iter\"\n\tdefault:\n\t\treturn TypeOf(v) + \" (\" + Preview(v) + \")\"\n\t}\n}\n"
        },
        {
          "name": "execute.go",
          "type": "blob",
          "size": 9.2783203125,
          "content": "package gojq\n\nimport (\n\t\"context\"\n\t\"math\"\n\t\"reflect\"\n\t\"sort\"\n)\n\nfunc (env *env) execute(bc *Code, v any, vars ...any) Iter {\n\tenv.codes = bc.codes\n\tenv.codeinfos = bc.codeinfos\n\tenv.push(v)\n\tfor i := len(vars) - 1; i >= 0; i-- {\n\t\tenv.push(vars[i])\n\t}\n\tenv.debugCodes()\n\treturn env\n}\n\nfunc (env *env) Next() (any, bool) {\n\tvar err error\n\tpc, callpc, index := env.pc, len(env.codes)-1, -1\n\tbacktrack, hasCtx := env.backtrack, env.ctx != context.Background()\n\tdefer func() { env.pc, env.backtrack = pc, true }()\nloop:\n\tfor ; pc < len(env.codes); pc++ {\n\t\tenv.debugState(pc, backtrack)\n\t\tcode := env.codes[pc]\n\t\tif hasCtx {\n\t\t\tselect {\n\t\t\tcase <-env.ctx.Done():\n\t\t\t\tpc, env.forks = len(env.codes), nil\n\t\t\t\treturn env.ctx.Err(), true\n\t\t\tdefault:\n\t\t\t}\n\t\t}\n\t\tswitch code.op {\n\t\tcase opnop:\n\t\t\t// nop\n\t\tcase oppush:\n\t\t\tenv.push(code.v)\n\t\tcase oppop:\n\t\t\tenv.pop()\n\t\tcase opdup:\n\t\t\tv := env.pop()\n\t\t\tenv.push(v)\n\t\t\tenv.push(v)\n\t\tcase opconst:\n\t\t\tenv.pop()\n\t\t\tenv.push(code.v)\n\t\tcase opload:\n\t\t\tenv.push(env.values[env.index(code.v.([2]int))])\n\t\tcase opstore:\n\t\t\tenv.values[env.index(code.v.([2]int))] = env.pop()\n\t\tcase opobject:\n\t\t\tif backtrack {\n\t\t\t\tbreak loop\n\t\t\t}\n\t\t\tn := code.v.(int)\n\t\t\tm := make(map[string]any, n)\n\t\t\tfor i := 0; i < n; i++ {\n\t\t\t\tv, k := env.pop(), env.pop()\n\t\t\t\ts, ok := k.(string)\n\t\t\t\tif !ok {\n\t\t\t\t\terr = &objectKeyNotStringError{k}\n\t\t\t\t\tbreak loop\n\t\t\t\t}\n\t\t\t\tif _, ok := m[s]; !ok {\n\t\t\t\t\tm[s] = v\n\t\t\t\t}\n\t\t\t}\n\t\t\tenv.push(m)\n\t\tcase opappend:\n\t\t\ti := env.index(code.v.([2]int))\n\t\t\tenv.values[i] = append(env.values[i].([]any), env.pop())\n\t\tcase opfork:\n\t\t\tif backtrack {\n\t\t\t\tif err != nil {\n\t\t\t\t\tbreak loop\n\t\t\t\t}\n\t\t\t\tpc, backtrack = code.v.(int), false\n\t\t\t\tgoto loop\n\t\t\t}\n\t\t\tenv.pushfork(pc)\n\t\tcase opforktrybegin:\n\t\t\tif backtrack {\n\t\t\t\tif err == nil {\n\t\t\t\t\tbreak loop\n\t\t\t\t}\n\t\t\t\tswitch e := err.(type) {\n\t\t\t\tcase *tryEndError:\n\t\t\t\t\terr = e.err\n\t\t\t\t\tbreak loop\n\t\t\t\tcase *breakError, *HaltError:\n\t\t\t\t\tbreak loop\n\t\t\t\tcase ValueError:\n\t\t\t\t\tenv.pop()\n\t\t\t\t\tenv.push(e.Value())\n\t\t\t\tdefault:\n\t\t\t\t\tenv.pop()\n\t\t\t\t\tenv.push(err.Error())\n\t\t\t\t}\n\t\t\t\tpc, backtrack, err = code.v.(int), false, nil\n\t\t\t\tgoto loop\n\t\t\t}\n\t\t\tenv.pushfork(pc)\n\t\tcase opforktryend:\n\t\t\tif backtrack {\n\t\t\t\tif err != nil {\n\t\t\t\t\terr = &tryEndError{err}\n\t\t\t\t}\n\t\t\t\tbreak loop\n\t\t\t}\n\t\t\tenv.pushfork(pc)\n\t\tcase opforkalt:\n\t\t\tif backtrack {\n\t\t\t\tif err == nil {\n\t\t\t\t\tbreak loop\n\t\t\t\t}\n\t\t\t\tpc, backtrack, err = code.v.(int), false, nil\n\t\t\t\tgoto loop\n\t\t\t}\n\t\t\tenv.pushfork(pc)\n\t\tcase opforklabel:\n\t\t\tif backtrack {\n\t\t\t\tlabel := env.pop()\n\t\t\t\tif e, ok := err.(*breakError); ok && e.v == label {\n\t\t\t\t\terr = nil\n\t\t\t\t}\n\t\t\t\tbreak loop\n\t\t\t}\n\t\t\tenv.push(env.label)\n\t\t\tenv.pushfork(pc)\n\t\t\tenv.pop()\n\t\t\tenv.values[env.index(code.v.([2]int))] = env.label\n\t\t\tenv.label++\n\t\tcase opbacktrack:\n\t\t\tbreak loop\n\t\tcase opjump:\n\t\t\tpc = code.v.(int)\n\t\t\tgoto loop\n\t\tcase opjumpifnot:\n\t\t\tif v := env.pop(); v == nil || v == false {\n\t\t\t\tpc = code.v.(int)\n\t\t\t\tgoto loop\n\t\t\t}\n\t\tcase opindex, opindexarray:\n\t\t\tif backtrack {\n\t\t\t\tbreak loop\n\t\t\t}\n\t\t\tp, v := code.v, env.pop()\n\t\t\tif code.op == opindexarray && v != nil {\n\t\t\t\tif _, ok := v.([]any); !ok {\n\t\t\t\t\terr = &expectedArrayError{v}\n\t\t\t\t\tbreak loop\n\t\t\t\t}\n\t\t\t}\n\t\t\tw := funcIndex2(nil, v, p)\n\t\t\tif e, ok := w.(error); ok {\n\t\t\t\terr = e\n\t\t\t\tbreak loop\n\t\t\t}\n\t\t\tenv.push(w)\n\t\t\tif !env.paths.empty() && env.expdepth == 0 {\n\t\t\t\tif !env.pathIntact(v) {\n\t\t\t\t\terr = &invalidPathError{v}\n\t\t\t\t\tbreak loop\n\t\t\t\t}\n\t\t\t\tenv.paths.push(pathValue{path: p, value: w})\n\t\t\t}\n\t\tcase opcall:\n\t\t\tif backtrack {\n\t\t\t\tbreak loop\n\t\t\t}\n\t\t\tswitch v := code.v.(type) {\n\t\t\tcase int:\n\t\t\t\tpc, callpc, index = v, pc, env.scopes.index\n\t\t\t\tgoto loop\n\t\t\tcase [3]any:\n\t\t\t\targcnt := v[1].(int)\n\t\t\t\tx, args := env.pop(), env.args[:argcnt]\n\t\t\t\tfor i := 0; i < argcnt; i++ {\n\t\t\t\t\targs[i] = env.pop()\n\t\t\t\t}\n\t\t\t\tw := v[0].(func(any, []any) any)(x, args)\n\t\t\t\tif e, ok := w.(error); ok {\n\t\t\t\t\terr = e\n\t\t\t\t\tbreak loop\n\t\t\t\t}\n\t\t\t\tenv.push(w)\n\t\t\t\tif !env.paths.empty() && env.expdepth == 0 {\n\t\t\t\t\tswitch v[2].(string) {\n\t\t\t\t\tcase \"_index\":\n\t\t\t\t\t\tif x = args[0]; !env.pathIntact(x) {\n\t\t\t\t\t\t\terr = &invalidPathError{x}\n\t\t\t\t\t\t\tbreak loop\n\t\t\t\t\t\t}\n\t\t\t\t\t\tenv.paths.push(pathValue{path: args[1], value: w})\n\t\t\t\t\tcase \"_slice\":\n\t\t\t\t\t\tif x = args[0]; !env.pathIntact(x) {\n\t\t\t\t\t\t\terr = &invalidPathError{x}\n\t\t\t\t\t\t\tbreak loop\n\t\t\t\t\t\t}\n\t\t\t\t\t\tenv.paths.push(pathValue{\n\t\t\t\t\t\t\tpath:  map[string]any{\"start\": args[2], \"end\": args[1]},\n\t\t\t\t\t\t\tvalue: w,\n\t\t\t\t\t\t})\n\t\t\t\t\tcase \"getpath\":\n\t\t\t\t\t\tif !env.pathIntact(x) {\n\t\t\t\t\t\t\terr = &invalidPathError{x}\n\t\t\t\t\t\t\tbreak loop\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor _, p := range args[0].([]any) {\n\t\t\t\t\t\t\tenv.paths.push(pathValue{path: p, value: w})\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\tdefault:\n\t\t\t\tpanic(v)\n\t\t\t}\n\t\tcase opcallrec:\n\t\t\tpc, callpc, index = code.v.(int), -1, env.scopes.index\n\t\t\tgoto loop\n\t\tcase oppushpc:\n\t\t\tenv.push([2]int{code.v.(int), env.scopes.index})\n\t\tcase opcallpc:\n\t\t\txs := env.pop().([2]int)\n\t\t\tpc, callpc, index = xs[0], pc, xs[1]\n\t\t\tgoto loop\n\t\tcase opscope:\n\t\t\txs := code.v.([3]int)\n\t\t\tvar saveindex, outerindex int\n\t\t\tif index == env.scopes.index {\n\t\t\t\tif callpc >= 0 {\n\t\t\t\t\tsaveindex = index\n\t\t\t\t} else {\n\t\t\t\t\tcallpc, saveindex = env.popscope()\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tsaveindex, _ = env.scopes.save()\n\t\t\t\tenv.scopes.index = index\n\t\t\t}\n\t\t\tif outerindex = index; outerindex >= 0 {\n\t\t\t\tif s := env.scopes.data[outerindex].value; s.id == xs[0] {\n\t\t\t\t\touterindex = s.outerindex\n\t\t\t\t}\n\t\t\t}\n\t\t\tenv.scopes.push(scope{xs[0], env.offset, callpc, saveindex, outerindex})\n\t\t\tenv.offset += xs[1]\n\t\t\tif env.offset > len(env.values) {\n\t\t\t\tvs := make([]any, env.offset*2)\n\t\t\t\tcopy(vs, env.values)\n\t\t\t\tenv.values = vs\n\t\t\t}\n\t\tcase opret:\n\t\t\tif backtrack {\n\t\t\t\tbreak loop\n\t\t\t}\n\t\t\tpc, env.scopes.index = env.popscope()\n\t\t\tif env.scopes.empty() {\n\t\t\t\treturn env.pop(), true\n\t\t\t}\n\t\tcase opiter:\n\t\t\tif err != nil {\n\t\t\t\tbreak loop\n\t\t\t}\n\t\t\tbacktrack = false\n\t\t\tvar xs []pathValue\n\t\t\tswitch v := env.pop().(type) {\n\t\t\tcase []pathValue:\n\t\t\t\txs = v\n\t\t\tcase []any:\n\t\t\t\tif !env.paths.empty() && env.expdepth == 0 && !env.pathIntact(v) {\n\t\t\t\t\terr = &invalidPathIterError{v}\n\t\t\t\t\tbreak loop\n\t\t\t\t}\n\t\t\t\tif len(v) == 0 {\n\t\t\t\t\tbreak loop\n\t\t\t\t}\n\t\t\t\txs = make([]pathValue, len(v))\n\t\t\t\tfor i, v := range v {\n\t\t\t\t\txs[i] = pathValue{path: i, value: v}\n\t\t\t\t}\n\t\t\tcase map[string]any:\n\t\t\t\tif !env.paths.empty() && env.expdepth == 0 && !env.pathIntact(v) {\n\t\t\t\t\terr = &invalidPathIterError{v}\n\t\t\t\t\tbreak loop\n\t\t\t\t}\n\t\t\t\tif len(v) == 0 {\n\t\t\t\t\tbreak loop\n\t\t\t\t}\n\t\t\t\txs = make([]pathValue, len(v))\n\t\t\t\tvar i int\n\t\t\t\tfor k, v := range v {\n\t\t\t\t\txs[i] = pathValue{path: k, value: v}\n\t\t\t\t\ti++\n\t\t\t\t}\n\t\t\t\tsort.Slice(xs, func(i, j int) bool {\n\t\t\t\t\treturn xs[i].path.(string) < xs[j].path.(string)\n\t\t\t\t})\n\t\t\tcase Iter:\n\t\t\t\tif w, ok := v.Next(); ok {\n\t\t\t\t\tenv.push(v)\n\t\t\t\t\tenv.pushfork(pc)\n\t\t\t\t\tenv.pop()\n\t\t\t\t\tif e, ok := w.(error); ok {\n\t\t\t\t\t\terr = e\n\t\t\t\t\t\tbreak loop\n\t\t\t\t\t}\n\t\t\t\t\tenv.push(w)\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\tbreak loop\n\t\t\tdefault:\n\t\t\t\terr = &iteratorError{v}\n\t\t\t\tenv.push(emptyIter{})\n\t\t\t\tbreak loop\n\t\t\t}\n\t\t\tif len(xs) > 1 {\n\t\t\t\tenv.push(xs[1:])\n\t\t\t\tenv.pushfork(pc)\n\t\t\t\tenv.pop()\n\t\t\t}\n\t\t\tenv.push(xs[0].value)\n\t\t\tif !env.paths.empty() && env.expdepth == 0 {\n\t\t\t\tenv.paths.push(xs[0])\n\t\t\t}\n\t\tcase opexpbegin:\n\t\t\tenv.expdepth++\n\t\tcase opexpend:\n\t\t\tenv.expdepth--\n\t\tcase oppathbegin:\n\t\t\tenv.paths.push(env.expdepth)\n\t\t\tenv.paths.push(pathValue{value: env.stack.top()})\n\t\t\tenv.expdepth = 0\n\t\tcase oppathend:\n\t\t\tif backtrack {\n\t\t\t\tbreak loop\n\t\t\t}\n\t\t\tenv.pop()\n\t\t\tif v := env.pop(); !env.pathIntact(v) {\n\t\t\t\terr = &invalidPathError{v}\n\t\t\t\tbreak loop\n\t\t\t}\n\t\t\tenv.push(env.poppaths())\n\t\t\tenv.expdepth = env.paths.pop().(int)\n\t\tdefault:\n\t\t\tpanic(code.op)\n\t\t}\n\t}\n\tif len(env.forks) > 0 {\n\t\tpc, backtrack = env.popfork(), true\n\t\tgoto loop\n\t}\n\tif err != nil {\n\t\treturn err, true\n\t}\n\treturn nil, false\n}\n\nfunc (env *env) push(v any) {\n\tenv.stack.push(v)\n}\n\nfunc (env *env) pop() any {\n\treturn env.stack.pop()\n}\n\nfunc (env *env) popscope() (int, int) {\n\tfree := env.scopes.index > env.scopes.limit\n\ts := env.scopes.pop()\n\tif free {\n\t\tenv.offset = s.offset\n\t}\n\treturn s.pc, s.saveindex\n}\n\nfunc (env *env) pushfork(pc int) {\n\tf := fork{pc: pc, expdepth: env.expdepth}\n\tf.stackindex, f.stacklimit = env.stack.save()\n\tf.scopeindex, f.scopelimit = env.scopes.save()\n\tf.pathindex, f.pathlimit = env.paths.save()\n\tenv.forks = append(env.forks, f)\n\tenv.debugForks(pc, \">>>\")\n}\n\nfunc (env *env) popfork() int {\n\tf := env.forks[len(env.forks)-1]\n\tenv.debugForks(f.pc, \"<<<\")\n\tenv.forks, env.expdepth = env.forks[:len(env.forks)-1], f.expdepth\n\tenv.stack.restore(f.stackindex, f.stacklimit)\n\tenv.scopes.restore(f.scopeindex, f.scopelimit)\n\tenv.paths.restore(f.pathindex, f.pathlimit)\n\treturn f.pc\n}\n\nfunc (env *env) index(v [2]int) int {\n\tfor id, i := v[0], env.scopes.index; i >= 0; {\n\t\ts := env.scopes.data[i].value\n\t\tif s.id == id {\n\t\t\treturn s.offset + v[1]\n\t\t}\n\t\ti = s.outerindex\n\t}\n\tpanic(\"env.index\")\n}\n\ntype pathValue struct {\n\tpath, value any\n}\n\nfunc (env *env) pathIntact(v any) bool {\n\tw := env.paths.top().(pathValue).value\n\tswitch v := v.(type) {\n\tcase []any, map[string]any:\n\t\tswitch w.(type) {\n\t\tcase []any, map[string]any:\n\t\t\tv, w := reflect.ValueOf(v), reflect.ValueOf(w)\n\t\t\treturn v.Pointer() == w.Pointer() && v.Len() == w.Len()\n\t\t}\n\tcase float64:\n\t\tif w, ok := w.(float64); ok {\n\t\t\treturn v == w || math.IsNaN(v) && math.IsNaN(w)\n\t\t}\n\t}\n\treturn v == w\n}\n\nfunc (env *env) poppaths() []any {\n\txs := []any{}\n\tfor {\n\t\tp := env.paths.pop().(pathValue)\n\t\tif p.path == nil {\n\t\t\tbreak\n\t\t}\n\t\txs = append(xs, p.path)\n\t}\n\tfor i, j := 0, len(xs)-1; i < j; i, j = i+1, j-1 {\n\t\txs[i], xs[j] = xs[j], xs[i]\n\t}\n\treturn xs\n}\n"
        },
        {
          "name": "func.go",
          "type": "blob",
          "size": 43.4658203125,
          "content": "package gojq\n\nimport (\n\t\"encoding/base64\"\n\t\"encoding/json\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"math\"\n\t\"math/big\"\n\t\"net/url\"\n\t\"reflect\"\n\t\"regexp\"\n\t\"sort\"\n\t\"strconv\"\n\t\"strings\"\n\t\"time\"\n\t\"unicode\"\n\t\"unicode/utf8\"\n\n\t\"github.com/itchyny/timefmt-go\"\n)\n\n//go:generate go run -modfile=go.dev.mod _tools/gen_builtin.go -i builtin.jq -o builtin.go\nvar builtinFuncDefs map[string][]*FuncDef\n\nconst (\n\targcount0 = 1 << iota\n\targcount1\n\targcount2\n\targcount3\n)\n\ntype function struct {\n\targcount int\n\titer     bool\n\tcallback func(any, []any) any\n}\n\nfunc (fn function) accept(cnt int) bool {\n\treturn fn.argcount&(1<<cnt) != 0\n}\n\nvar internalFuncs map[string]function\n\nfunc init() {\n\tinternalFuncs = map[string]function{\n\t\t\"empty\":          argFunc0(nil),\n\t\t\"path\":           argFunc1(nil),\n\t\t\"env\":            argFunc0(nil),\n\t\t\"builtins\":       argFunc0(nil),\n\t\t\"input\":          argFunc0(nil),\n\t\t\"modulemeta\":     argFunc0(nil),\n\t\t\"debug\":          argFunc1(nil),\n\t\t\"abs\":            argFunc0(funcAbs),\n\t\t\"length\":         argFunc0(funcLength),\n\t\t\"utf8bytelength\": argFunc0(funcUtf8ByteLength),\n\t\t\"keys\":           argFunc0(funcKeys),\n\t\t\"has\":            argFunc1(funcHas),\n\t\t\"to_entries\":     argFunc0(funcToEntries),\n\t\t\"from_entries\":   argFunc0(funcFromEntries),\n\t\t\"add\":            argFunc0(funcAdd),\n\t\t\"tonumber\":       argFunc0(funcToNumber),\n\t\t\"tostring\":       argFunc0(funcToString),\n\t\t\"type\":           argFunc0(funcType),\n\t\t\"reverse\":        argFunc0(funcReverse),\n\t\t\"contains\":       argFunc1(funcContains),\n\t\t\"indices\":        argFunc1(funcIndices),\n\t\t\"index\":          argFunc1(funcIndex),\n\t\t\"rindex\":         argFunc1(funcRindex),\n\t\t\"startswith\":     argFunc1(funcStartsWith),\n\t\t\"endswith\":       argFunc1(funcEndsWith),\n\t\t\"ltrimstr\":       argFunc1(funcLtrimstr),\n\t\t\"rtrimstr\":       argFunc1(funcRtrimstr),\n\t\t\"ltrim\":          argFunc0(funcLtrim),\n\t\t\"rtrim\":          argFunc0(funcRtrim),\n\t\t\"trim\":           argFunc0(funcTrim),\n\t\t\"explode\":        argFunc0(funcExplode),\n\t\t\"implode\":        argFunc0(funcImplode),\n\t\t\"split\":          {argcount1 | argcount2, false, funcSplit},\n\t\t\"ascii_downcase\": argFunc0(funcASCIIDowncase),\n\t\t\"ascii_upcase\":   argFunc0(funcASCIIUpcase),\n\t\t\"tojson\":         argFunc0(funcToJSON),\n\t\t\"fromjson\":       argFunc0(funcFromJSON),\n\t\t\"format\":         argFunc1(funcFormat),\n\t\t\"_tohtml\":        argFunc0(funcToHTML),\n\t\t\"_touri\":         argFunc0(funcToURI),\n\t\t\"_tourid\":        argFunc0(funcToURId),\n\t\t\"_tocsv\":         argFunc0(funcToCSV),\n\t\t\"_totsv\":         argFunc0(funcToTSV),\n\t\t\"_tosh\":          argFunc0(funcToSh),\n\t\t\"_tobase64\":      argFunc0(funcToBase64),\n\t\t\"_tobase64d\":     argFunc0(funcToBase64d),\n\t\t\"_index\":         argFunc2(funcIndex2),\n\t\t\"_slice\":         argFunc3(funcSlice),\n\t\t\"_plus\":          argFunc0(funcOpPlus),\n\t\t\"_negate\":        argFunc0(funcOpNegate),\n\t\t\"_add\":           argFunc2(funcOpAdd),\n\t\t\"_subtract\":      argFunc2(funcOpSub),\n\t\t\"_multiply\":      argFunc2(funcOpMul),\n\t\t\"_divide\":        argFunc2(funcOpDiv),\n\t\t\"_modulo\":        argFunc2(funcOpMod),\n\t\t\"_alternative\":   argFunc2(funcOpAlt),\n\t\t\"_equal\":         argFunc2(funcOpEq),\n\t\t\"_notequal\":      argFunc2(funcOpNe),\n\t\t\"_greater\":       argFunc2(funcOpGt),\n\t\t\"_less\":          argFunc2(funcOpLt),\n\t\t\"_greatereq\":     argFunc2(funcOpGe),\n\t\t\"_lesseq\":        argFunc2(funcOpLe),\n\t\t\"flatten\":        {argcount0 | argcount1, false, funcFlatten},\n\t\t\"_range\":         {argcount3, true, funcRange},\n\t\t\"min\":            argFunc0(funcMin),\n\t\t\"_min_by\":        argFunc1(funcMinBy),\n\t\t\"max\":            argFunc0(funcMax),\n\t\t\"_max_by\":        argFunc1(funcMaxBy),\n\t\t\"sort\":           argFunc0(funcSort),\n\t\t\"_sort_by\":       argFunc1(funcSortBy),\n\t\t\"_group_by\":      argFunc1(funcGroupBy),\n\t\t\"unique\":         argFunc0(funcUnique),\n\t\t\"_unique_by\":     argFunc1(funcUniqueBy),\n\t\t\"join\":           argFunc1(funcJoin),\n\t\t\"sin\":            mathFunc(\"sin\", math.Sin),\n\t\t\"cos\":            mathFunc(\"cos\", math.Cos),\n\t\t\"tan\":            mathFunc(\"tan\", math.Tan),\n\t\t\"asin\":           mathFunc(\"asin\", math.Asin),\n\t\t\"acos\":           mathFunc(\"acos\", math.Acos),\n\t\t\"atan\":           mathFunc(\"atan\", math.Atan),\n\t\t\"sinh\":           mathFunc(\"sinh\", math.Sinh),\n\t\t\"cosh\":           mathFunc(\"cosh\", math.Cosh),\n\t\t\"tanh\":           mathFunc(\"tanh\", math.Tanh),\n\t\t\"asinh\":          mathFunc(\"asinh\", math.Asinh),\n\t\t\"acosh\":          mathFunc(\"acosh\", math.Acosh),\n\t\t\"atanh\":          mathFunc(\"atanh\", math.Atanh),\n\t\t\"floor\":          mathFunc(\"floor\", math.Floor),\n\t\t\"round\":          mathFunc(\"round\", math.Round),\n\t\t\"nearbyint\":      mathFunc(\"nearbyint\", math.RoundToEven),\n\t\t\"rint\":           mathFunc(\"rint\", math.RoundToEven),\n\t\t\"ceil\":           mathFunc(\"ceil\", math.Ceil),\n\t\t\"trunc\":          mathFunc(\"trunc\", math.Trunc),\n\t\t\"significand\":    mathFunc(\"significand\", funcSignificand),\n\t\t\"fabs\":           mathFunc(\"fabs\", math.Abs),\n\t\t\"sqrt\":           mathFunc(\"sqrt\", math.Sqrt),\n\t\t\"cbrt\":           mathFunc(\"cbrt\", math.Cbrt),\n\t\t\"exp\":            mathFunc(\"exp\", math.Exp),\n\t\t\"exp10\":          mathFunc(\"exp10\", funcExp10),\n\t\t\"exp2\":           mathFunc(\"exp2\", math.Exp2),\n\t\t\"expm1\":          mathFunc(\"expm1\", math.Expm1),\n\t\t\"frexp\":          argFunc0(funcFrexp),\n\t\t\"modf\":           argFunc0(funcModf),\n\t\t\"log\":            mathFunc(\"log\", math.Log),\n\t\t\"log10\":          mathFunc(\"log10\", math.Log10),\n\t\t\"log1p\":          mathFunc(\"log1p\", math.Log1p),\n\t\t\"log2\":           mathFunc(\"log2\", math.Log2),\n\t\t\"logb\":           mathFunc(\"logb\", math.Logb),\n\t\t\"gamma\":          mathFunc(\"gamma\", math.Gamma),\n\t\t\"tgamma\":         mathFunc(\"tgamma\", math.Gamma),\n\t\t\"lgamma\":         mathFunc(\"lgamma\", funcLgamma),\n\t\t\"erf\":            mathFunc(\"erf\", math.Erf),\n\t\t\"erfc\":           mathFunc(\"erfc\", math.Erfc),\n\t\t\"j0\":             mathFunc(\"j0\", math.J0),\n\t\t\"j1\":             mathFunc(\"j1\", math.J1),\n\t\t\"y0\":             mathFunc(\"y0\", math.Y0),\n\t\t\"y1\":             mathFunc(\"y1\", math.Y1),\n\t\t\"atan2\":          mathFunc2(\"atan2\", math.Atan2),\n\t\t\"copysign\":       mathFunc2(\"copysign\", math.Copysign),\n\t\t\"drem\":           mathFunc2(\"drem\", funcDrem),\n\t\t\"fdim\":           mathFunc2(\"fdim\", math.Dim),\n\t\t\"fmax\":           mathFunc2(\"fmax\", math.Max),\n\t\t\"fmin\":           mathFunc2(\"fmin\", math.Min),\n\t\t\"fmod\":           mathFunc2(\"fmod\", math.Mod),\n\t\t\"hypot\":          mathFunc2(\"hypot\", math.Hypot),\n\t\t\"jn\":             mathFunc2(\"jn\", funcJn),\n\t\t\"nextafter\":      mathFunc2(\"nextafter\", math.Nextafter),\n\t\t\"nexttoward\":     mathFunc2(\"nexttoward\", math.Nextafter),\n\t\t\"remainder\":      mathFunc2(\"remainder\", math.Remainder),\n\t\t\"ldexp\":          mathFunc2(\"ldexp\", funcLdexp),\n\t\t\"scalb\":          mathFunc2(\"scalb\", funcLdexp),\n\t\t\"scalbln\":        mathFunc2(\"scalbln\", funcLdexp),\n\t\t\"yn\":             mathFunc2(\"yn\", funcYn),\n\t\t\"pow\":            mathFunc2(\"pow\", math.Pow),\n\t\t\"fma\":            mathFunc3(\"fma\", math.FMA),\n\t\t\"infinite\":       argFunc0(funcInfinite),\n\t\t\"isfinite\":       argFunc0(funcIsfinite),\n\t\t\"isinfinite\":     argFunc0(funcIsinfinite),\n\t\t\"nan\":            argFunc0(funcNan),\n\t\t\"isnan\":          argFunc0(funcIsnan),\n\t\t\"isnormal\":       argFunc0(funcIsnormal),\n\t\t\"setpath\":        argFunc2(funcSetpath),\n\t\t\"delpaths\":       argFunc1(funcDelpaths),\n\t\t\"getpath\":        argFunc1(funcGetpath),\n\t\t\"transpose\":      argFunc0(funcTranspose),\n\t\t\"bsearch\":        argFunc1(funcBsearch),\n\t\t\"gmtime\":         argFunc0(funcGmtime),\n\t\t\"localtime\":      argFunc0(funcLocaltime),\n\t\t\"mktime\":         argFunc0(funcMktime),\n\t\t\"strftime\":       argFunc1(funcStrftime),\n\t\t\"strflocaltime\":  argFunc1(funcStrflocaltime),\n\t\t\"strptime\":       argFunc1(funcStrptime),\n\t\t\"now\":            argFunc0(funcNow),\n\t\t\"_match\":         argFunc3(funcMatch),\n\t\t\"_capture\":       argFunc0(funcCapture),\n\t\t\"error\":          {argcount0 | argcount1, false, funcError},\n\t\t\"halt\":           argFunc0(funcHalt),\n\t\t\"halt_error\":     {argcount0 | argcount1, false, funcHaltError},\n\t}\n}\n\nfunc argFunc0(f func(any) any) function {\n\treturn function{\n\t\targcount0, false, func(v any, _ []any) any {\n\t\t\treturn f(v)\n\t\t},\n\t}\n}\n\nfunc argFunc1(f func(_, _ any) any) function {\n\treturn function{\n\t\targcount1, false, func(v any, args []any) any {\n\t\t\treturn f(v, args[0])\n\t\t},\n\t}\n}\n\nfunc argFunc2(f func(_, _, _ any) any) function {\n\treturn function{\n\t\targcount2, false, func(v any, args []any) any {\n\t\t\treturn f(v, args[0], args[1])\n\t\t},\n\t}\n}\n\nfunc argFunc3(f func(_, _, _, _ any) any) function {\n\treturn function{\n\t\targcount3, false, func(v any, args []any) any {\n\t\t\treturn f(v, args[0], args[1], args[2])\n\t\t},\n\t}\n}\n\nfunc mathFunc(name string, f func(float64) float64) function {\n\treturn argFunc0(func(v any) any {\n\t\tx, ok := toFloat(v)\n\t\tif !ok {\n\t\t\treturn &func0TypeError{name, v}\n\t\t}\n\t\treturn f(x)\n\t})\n}\n\nfunc mathFunc2(name string, f func(_, _ float64) float64) function {\n\treturn argFunc2(func(_, x, y any) any {\n\t\tl, ok := toFloat(x)\n\t\tif !ok {\n\t\t\treturn &func0TypeError{name, x}\n\t\t}\n\t\tr, ok := toFloat(y)\n\t\tif !ok {\n\t\t\treturn &func0TypeError{name, y}\n\t\t}\n\t\treturn f(l, r)\n\t})\n}\n\nfunc mathFunc3(name string, f func(_, _, _ float64) float64) function {\n\treturn argFunc3(func(_, a, b, c any) any {\n\t\tx, ok := toFloat(a)\n\t\tif !ok {\n\t\t\treturn &func0TypeError{name, a}\n\t\t}\n\t\ty, ok := toFloat(b)\n\t\tif !ok {\n\t\t\treturn &func0TypeError{name, b}\n\t\t}\n\t\tz, ok := toFloat(c)\n\t\tif !ok {\n\t\t\treturn &func0TypeError{name, c}\n\t\t}\n\t\treturn f(x, y, z)\n\t})\n}\n\nfunc funcAbs(v any) any {\n\tswitch v := v.(type) {\n\tcase int:\n\t\tif v >= 0 {\n\t\t\treturn v\n\t\t}\n\t\treturn -v\n\tcase float64:\n\t\treturn math.Abs(v)\n\tcase *big.Int:\n\t\tif v.Sign() >= 0 {\n\t\t\treturn v\n\t\t}\n\t\treturn new(big.Int).Abs(v)\n\tdefault:\n\t\treturn &func0TypeError{\"abs\", v}\n\t}\n}\n\nfunc funcLength(v any) any {\n\tswitch v := v.(type) {\n\tcase nil:\n\t\treturn 0\n\tcase int:\n\t\tif v >= 0 {\n\t\t\treturn v\n\t\t}\n\t\treturn -v\n\tcase float64:\n\t\treturn math.Abs(v)\n\tcase *big.Int:\n\t\tif v.Sign() >= 0 {\n\t\t\treturn v\n\t\t}\n\t\treturn new(big.Int).Abs(v)\n\tcase string:\n\t\treturn len([]rune(v))\n\tcase []any:\n\t\treturn len(v)\n\tcase map[string]any:\n\t\treturn len(v)\n\tdefault:\n\t\treturn &func0TypeError{\"length\", v}\n\t}\n}\n\nfunc funcUtf8ByteLength(v any) any {\n\ts, ok := v.(string)\n\tif !ok {\n\t\treturn &func0TypeError{\"utf8bytelength\", v}\n\t}\n\treturn len(s)\n}\n\nfunc funcKeys(v any) any {\n\tswitch v := v.(type) {\n\tcase []any:\n\t\tw := make([]any, len(v))\n\t\tfor i := range v {\n\t\t\tw[i] = i\n\t\t}\n\t\treturn w\n\tcase map[string]any:\n\t\tw := make([]any, len(v))\n\t\tfor i, k := range keys(v) {\n\t\t\tw[i] = k\n\t\t}\n\t\treturn w\n\tdefault:\n\t\treturn &func0TypeError{\"keys\", v}\n\t}\n}\n\nfunc keys(v map[string]any) []string {\n\tw := make([]string, len(v))\n\tvar i int\n\tfor k := range v {\n\t\tw[i] = k\n\t\ti++\n\t}\n\tsort.Strings(w)\n\treturn w\n}\n\nfunc values(v any) ([]any, bool) {\n\tswitch v := v.(type) {\n\tcase []any:\n\t\treturn v, true\n\tcase map[string]any:\n\t\tvs := make([]any, len(v))\n\t\tfor i, k := range keys(v) {\n\t\t\tvs[i] = v[k]\n\t\t}\n\t\treturn vs, true\n\tdefault:\n\t\treturn nil, false\n\t}\n}\n\nfunc funcHas(v, x any) any {\n\tswitch v := v.(type) {\n\tcase []any:\n\t\tif x, ok := toInt(x); ok {\n\t\t\treturn 0 <= x && x < len(v)\n\t\t}\n\tcase map[string]any:\n\t\tif x, ok := x.(string); ok {\n\t\t\t_, ok := v[x]\n\t\t\treturn ok\n\t\t}\n\tcase nil:\n\t\treturn false\n\t}\n\treturn &func1TypeError{\"has\", v, x}\n}\n\nfunc funcToEntries(v any) any {\n\tswitch v := v.(type) {\n\tcase []any:\n\t\tw := make([]any, len(v))\n\t\tfor i, x := range v {\n\t\t\tw[i] = map[string]any{\"key\": i, \"value\": x}\n\t\t}\n\t\treturn w\n\tcase map[string]any:\n\t\tw := make([]any, len(v))\n\t\tfor i, k := range keys(v) {\n\t\t\tw[i] = map[string]any{\"key\": k, \"value\": v[k]}\n\t\t}\n\t\treturn w\n\tdefault:\n\t\treturn &func0TypeError{\"to_entries\", v}\n\t}\n}\n\nfunc funcFromEntries(v any) any {\n\tvs, ok := v.([]any)\n\tif !ok {\n\t\treturn &func0TypeError{\"from_entries\", v}\n\t}\n\tw := make(map[string]any, len(vs))\n\tfor _, v := range vs {\n\t\tswitch v := v.(type) {\n\t\tcase map[string]any:\n\t\t\tvar (\n\t\t\t\tkey   string\n\t\t\t\tvalue any\n\t\t\t\tok    bool\n\t\t\t)\n\t\t\tfor _, k := range [4]string{\"key\", \"Key\", \"name\", \"Name\"} {\n\t\t\t\tif k := v[k]; k != nil && k != false {\n\t\t\t\t\tif key, ok = k.(string); !ok {\n\t\t\t\t\t\treturn &func0WrapError{\"from_entries\", vs, &objectKeyNotStringError{k}}\n\t\t\t\t\t}\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t\tif !ok {\n\t\t\t\treturn &func0WrapError{\"from_entries\", vs, &objectKeyNotStringError{nil}}\n\t\t\t}\n\t\t\tfor _, k := range [2]string{\"value\", \"Value\"} {\n\t\t\t\tif value, ok = v[k]; ok {\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t\tw[key] = value\n\t\tdefault:\n\t\t\treturn &func0TypeError{\"from_entries\", v}\n\t\t}\n\t}\n\treturn w\n}\n\nfunc funcAdd(v any) any {\n\tvs, ok := values(v)\n\tif !ok {\n\t\treturn &func0TypeError{\"add\", v}\n\t}\n\tv = nil\n\tfor _, x := range vs {\n\t\tswitch x := x.(type) {\n\t\tcase nil:\n\t\t\tcontinue\n\t\tcase string:\n\t\t\tswitch w := v.(type) {\n\t\t\tcase nil:\n\t\t\t\tvar sb strings.Builder\n\t\t\t\tsb.WriteString(x)\n\t\t\t\tv = &sb\n\t\t\t\tcontinue\n\t\t\tcase *strings.Builder:\n\t\t\t\tw.WriteString(x)\n\t\t\t\tcontinue\n\t\t\t}\n\t\tcase []any:\n\t\t\tswitch w := v.(type) {\n\t\t\tcase nil:\n\t\t\t\ts := make([]any, len(x))\n\t\t\t\tcopy(s, x)\n\t\t\t\tv = s\n\t\t\t\tcontinue\n\t\t\tcase []any:\n\t\t\t\tv = append(w, x...)\n\t\t\t\tcontinue\n\t\t\t}\n\t\tcase map[string]any:\n\t\t\tswitch w := v.(type) {\n\t\t\tcase nil:\n\t\t\t\tm := make(map[string]any, len(x))\n\t\t\t\tfor k, e := range x {\n\t\t\t\t\tm[k] = e\n\t\t\t\t}\n\t\t\t\tv = m\n\t\t\t\tcontinue\n\t\t\tcase map[string]any:\n\t\t\t\tfor k, e := range x {\n\t\t\t\t\tw[k] = e\n\t\t\t\t}\n\t\t\t\tcontinue\n\t\t\t}\n\t\t}\n\t\tif sb, ok := v.(*strings.Builder); ok {\n\t\t\tv = sb.String()\n\t\t}\n\t\tv = funcOpAdd(nil, v, x)\n\t\tif err, ok := v.(error); ok {\n\t\t\treturn err\n\t\t}\n\t}\n\tif sb, ok := v.(*strings.Builder); ok {\n\t\tv = sb.String()\n\t}\n\treturn v\n}\n\nfunc funcToNumber(v any) any {\n\tswitch v := v.(type) {\n\tcase int, float64, *big.Int:\n\t\treturn v\n\tcase string:\n\t\tif !newLexer(v).validNumber() {\n\t\t\treturn &func0WrapError{\"tonumber\", v, errors.New(\"invalid number\")}\n\t\t}\n\t\treturn toNumber(v)\n\tdefault:\n\t\treturn &func0TypeError{\"tonumber\", v}\n\t}\n}\n\nfunc toNumber(v string) any {\n\treturn normalizeNumber(json.Number(v))\n}\n\nfunc funcToString(v any) any {\n\tif s, ok := v.(string); ok {\n\t\treturn s\n\t}\n\treturn funcToJSON(v)\n}\n\nfunc funcType(v any) any {\n\treturn TypeOf(v)\n}\n\nfunc funcReverse(v any) any {\n\tvs, ok := v.([]any)\n\tif !ok {\n\t\treturn &func0TypeError{\"reverse\", v}\n\t}\n\tws := make([]any, len(vs))\n\tfor i, v := range vs {\n\t\tws[len(ws)-i-1] = v\n\t}\n\treturn ws\n}\n\nfunc funcContains(v, x any) any {\n\treturn binopTypeSwitch(v, x,\n\t\tfunc(l, r int) any { return l == r },\n\t\tfunc(l, r float64) any { return l == r },\n\t\tfunc(l, r *big.Int) any { return l.Cmp(r) == 0 },\n\t\tfunc(l, r string) any { return strings.Contains(l, r) },\n\t\tfunc(l, r []any) any {\n\t\tR:\n\t\t\tfor _, r := range r {\n\t\t\t\tfor _, l := range l {\n\t\t\t\t\tif funcContains(l, r) == true {\n\t\t\t\t\t\tcontinue R\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn false\n\t\t\t}\n\t\t\treturn true\n\t\t},\n\t\tfunc(l, r map[string]any) any {\n\t\t\tif len(l) < len(r) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t\tfor k, r := range r {\n\t\t\t\tif l, ok := l[k]; !ok || funcContains(l, r) != true {\n\t\t\t\t\treturn false\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true\n\t\t},\n\t\tfunc(l, r any) any {\n\t\t\tif l == r {\n\t\t\t\treturn true\n\t\t\t}\n\t\t\treturn &func1TypeError{\"contains\", l, r}\n\t\t},\n\t)\n}\n\nfunc funcIndices(v, x any) any {\n\treturn indexFunc(\"indices\", v, x, indices)\n}\n\nfunc indices(vs, xs []any) any {\n\trs := []any{}\n\tif len(xs) == 0 {\n\t\treturn rs\n\t}\n\tfor i := 0; i <= len(vs)-len(xs); i++ {\n\t\tif Compare(vs[i:i+len(xs)], xs) == 0 {\n\t\t\trs = append(rs, i)\n\t\t}\n\t}\n\treturn rs\n}\n\nfunc funcIndex(v, x any) any {\n\treturn indexFunc(\"index\", v, x, func(vs, xs []any) any {\n\t\tif len(xs) == 0 {\n\t\t\treturn nil\n\t\t}\n\t\tfor i := 0; i <= len(vs)-len(xs); i++ {\n\t\t\tif Compare(vs[i:i+len(xs)], xs) == 0 {\n\t\t\t\treturn i\n\t\t\t}\n\t\t}\n\t\treturn nil\n\t})\n}\n\nfunc funcRindex(v, x any) any {\n\treturn indexFunc(\"rindex\", v, x, func(vs, xs []any) any {\n\t\tif len(xs) == 0 {\n\t\t\treturn nil\n\t\t}\n\t\tfor i := len(vs) - len(xs); i >= 0; i-- {\n\t\t\tif Compare(vs[i:i+len(xs)], xs) == 0 {\n\t\t\t\treturn i\n\t\t\t}\n\t\t}\n\t\treturn nil\n\t})\n}\n\nfunc indexFunc(name string, v, x any, f func(_, _ []any) any) any {\n\tswitch v := v.(type) {\n\tcase nil:\n\t\treturn nil\n\tcase []any:\n\t\tswitch x := x.(type) {\n\t\tcase []any:\n\t\t\treturn f(v, x)\n\t\tdefault:\n\t\t\treturn f(v, []any{x})\n\t\t}\n\tcase string:\n\t\tif x, ok := x.(string); ok {\n\t\t\treturn f(explode(v), explode(x))\n\t\t}\n\t\treturn &func1TypeError{name, v, x}\n\tdefault:\n\t\treturn &func1TypeError{name, v, x}\n\t}\n}\n\nfunc funcStartsWith(v, x any) any {\n\ts, ok := v.(string)\n\tif !ok {\n\t\treturn &func1TypeError{\"startswith\", v, x}\n\t}\n\tt, ok := x.(string)\n\tif !ok {\n\t\treturn &func1TypeError{\"startswith\", v, x}\n\t}\n\treturn strings.HasPrefix(s, t)\n}\n\nfunc funcEndsWith(v, x any) any {\n\ts, ok := v.(string)\n\tif !ok {\n\t\treturn &func1TypeError{\"endswith\", v, x}\n\t}\n\tt, ok := x.(string)\n\tif !ok {\n\t\treturn &func1TypeError{\"endswith\", v, x}\n\t}\n\treturn strings.HasSuffix(s, t)\n}\n\nfunc funcLtrimstr(v, x any) any {\n\ts, ok := v.(string)\n\tif !ok {\n\t\treturn &func1TypeError{\"ltrimstr\", v, x}\n\t}\n\tt, ok := x.(string)\n\tif !ok {\n\t\treturn &func1TypeError{\"ltrimstr\", v, x}\n\t}\n\treturn strings.TrimPrefix(s, t)\n}\n\nfunc funcRtrimstr(v, x any) any {\n\ts, ok := v.(string)\n\tif !ok {\n\t\treturn &func1TypeError{\"rtrimstr\", v, x}\n\t}\n\tt, ok := x.(string)\n\tif !ok {\n\t\treturn &func1TypeError{\"rtrimstr\", v, x}\n\t}\n\treturn strings.TrimSuffix(s, t)\n}\n\nfunc funcLtrim(v any) any {\n\ts, ok := v.(string)\n\tif !ok {\n\t\treturn &func0TypeError{\"ltrim\", v}\n\t}\n\treturn strings.TrimLeftFunc(s, unicode.IsSpace)\n}\n\nfunc funcRtrim(v any) any {\n\ts, ok := v.(string)\n\tif !ok {\n\t\treturn &func0TypeError{\"rtrim\", v}\n\t}\n\treturn strings.TrimRightFunc(s, unicode.IsSpace)\n}\n\nfunc funcTrim(v any) any {\n\ts, ok := v.(string)\n\tif !ok {\n\t\treturn &func0TypeError{\"trim\", v}\n\t}\n\treturn strings.TrimSpace(s)\n}\n\nfunc funcExplode(v any) any {\n\ts, ok := v.(string)\n\tif !ok {\n\t\treturn &func0TypeError{\"explode\", v}\n\t}\n\treturn explode(s)\n}\n\nfunc explode(s string) []any {\n\txs := make([]any, len([]rune(s)))\n\tvar i int\n\tfor _, r := range s {\n\t\txs[i] = int(r)\n\t\ti++\n\t}\n\treturn xs\n}\n\nfunc funcImplode(v any) any {\n\tvs, ok := v.([]any)\n\tif !ok {\n\t\treturn &func0TypeError{\"implode\", v}\n\t}\n\tvar sb strings.Builder\n\tsb.Grow(len(vs))\n\tfor _, v := range vs {\n\t\tif r, ok := toInt(v); ok {\n\t\t\tif 0 <= r && r <= utf8.MaxRune {\n\t\t\t\tsb.WriteRune(rune(r))\n\t\t\t} else {\n\t\t\t\tsb.WriteRune(utf8.RuneError)\n\t\t\t}\n\t\t} else {\n\t\t\treturn &func0TypeError{\"implode\", vs}\n\t\t}\n\t}\n\treturn sb.String()\n}\n\nfunc funcSplit(v any, args []any) any {\n\ts, ok := v.(string)\n\tif !ok {\n\t\treturn &func0TypeError{\"split\", v}\n\t}\n\tx, ok := args[0].(string)\n\tif !ok {\n\t\treturn &func0TypeError{\"split\", x}\n\t}\n\tvar ss []string\n\tif len(args) == 1 {\n\t\tss = strings.Split(s, x)\n\t} else {\n\t\tvar flags string\n\t\tif args[1] != nil {\n\t\t\tv, ok := args[1].(string)\n\t\t\tif !ok {\n\t\t\t\treturn &func0TypeError{\"split\", args[1]}\n\t\t\t}\n\t\t\tflags = v\n\t\t}\n\t\tr, err := compileRegexp(x, flags)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tss = r.Split(s, -1)\n\t}\n\txs := make([]any, len(ss))\n\tfor i, s := range ss {\n\t\txs[i] = s\n\t}\n\treturn xs\n}\n\nfunc funcASCIIDowncase(v any) any {\n\ts, ok := v.(string)\n\tif !ok {\n\t\treturn &func0TypeError{\"ascii_downcase\", v}\n\t}\n\treturn strings.Map(func(r rune) rune {\n\t\tif 'A' <= r && r <= 'Z' {\n\t\t\treturn r + ('a' - 'A')\n\t\t}\n\t\treturn r\n\t}, s)\n}\n\nfunc funcASCIIUpcase(v any) any {\n\ts, ok := v.(string)\n\tif !ok {\n\t\treturn &func0TypeError{\"ascii_upcase\", v}\n\t}\n\treturn strings.Map(func(r rune) rune {\n\t\tif 'a' <= r && r <= 'z' {\n\t\t\treturn r - ('a' - 'A')\n\t\t}\n\t\treturn r\n\t}, s)\n}\n\nfunc funcToJSON(v any) any {\n\treturn jsonMarshal(v)\n}\n\nfunc funcFromJSON(v any) any {\n\ts, ok := v.(string)\n\tif !ok {\n\t\treturn &func0TypeError{\"fromjson\", v}\n\t}\n\tvar w any\n\tdec := json.NewDecoder(strings.NewReader(s))\n\tdec.UseNumber()\n\tif err := dec.Decode(&w); err != nil {\n\t\treturn &func0WrapError{\"fromjson\", v, err}\n\t}\n\tif _, err := dec.Token(); err != io.EOF {\n\t\treturn &func0TypeError{\"fromjson\", v}\n\t}\n\treturn normalizeNumbers(w)\n}\n\nfunc funcFormat(v, x any) any {\n\ts, ok := x.(string)\n\tif !ok {\n\t\treturn &func0TypeError{\"format\", x}\n\t}\n\tformat := \"@\" + s\n\tf := formatToFunc(format)\n\tif f == nil {\n\t\treturn &formatNotFoundError{format}\n\t}\n\treturn internalFuncs[f.Name].callback(v, nil)\n}\n\nvar htmlEscaper = strings.NewReplacer(\n\t`<`, \"&lt;\",\n\t`>`, \"&gt;\",\n\t`&`, \"&amp;\",\n\t`'`, \"&apos;\",\n\t`\"`, \"&quot;\",\n)\n\nfunc funcToHTML(v any) any {\n\tswitch x := funcToString(v).(type) {\n\tcase string:\n\t\treturn htmlEscaper.Replace(x)\n\tdefault:\n\t\treturn x\n\t}\n}\n\nfunc funcToURI(v any) any {\n\tswitch x := funcToString(v).(type) {\n\tcase string:\n\t\treturn strings.ReplaceAll(url.QueryEscape(x), \"+\", \"%20\")\n\tdefault:\n\t\treturn x\n\t}\n}\n\nfunc funcToURId(v any) any {\n\tswitch x := funcToString(v).(type) {\n\tcase string:\n\t\tx, err := url.QueryUnescape(strings.ReplaceAll(x, \"+\", \"%2B\"))\n\t\tif err != nil {\n\t\t\treturn &func0WrapError{\"@urid\", v, err}\n\t\t}\n\t\treturn x\n\tdefault:\n\t\treturn x\n\t}\n}\n\nvar csvEscaper = strings.NewReplacer(\n\t`\"`, `\"\"`,\n\t\"\\x00\", `\\0`,\n)\n\nfunc funcToCSV(v any) any {\n\treturn formatJoin(\"csv\", v, \",\", func(s string) string {\n\t\treturn `\"` + csvEscaper.Replace(s) + `\"`\n\t})\n}\n\nvar tsvEscaper = strings.NewReplacer(\n\t\"\\t\", `\\t`,\n\t\"\\r\", `\\r`,\n\t\"\\n\", `\\n`,\n\t\"\\\\\", `\\\\`,\n\t\"\\x00\", `\\0`,\n)\n\nfunc funcToTSV(v any) any {\n\treturn formatJoin(\"tsv\", v, \"\\t\", tsvEscaper.Replace)\n}\n\nvar shEscaper = strings.NewReplacer(\n\t\"'\", `'\\''`,\n\t\"\\x00\", `\\0`,\n)\n\nfunc funcToSh(v any) any {\n\tif _, ok := v.([]any); !ok {\n\t\tv = []any{v}\n\t}\n\treturn formatJoin(\"sh\", v, \" \", func(s string) string {\n\t\treturn \"'\" + shEscaper.Replace(s) + \"'\"\n\t})\n}\n\nfunc formatJoin(typ string, v any, sep string, escape func(string) string) any {\n\tvs, ok := v.([]any)\n\tif !ok {\n\t\treturn &func0TypeError{\"@\" + typ, v}\n\t}\n\tss := make([]string, len(vs))\n\tfor i, v := range vs {\n\t\tswitch v := v.(type) {\n\t\tcase []any, map[string]any:\n\t\t\treturn &formatRowError{typ, v}\n\t\tcase string:\n\t\t\tss[i] = escape(v)\n\t\tdefault:\n\t\t\tif s := jsonMarshal(v); s != \"null\" || typ == \"sh\" {\n\t\t\t\tss[i] = s\n\t\t\t}\n\t\t}\n\t}\n\treturn strings.Join(ss, sep)\n}\n\nfunc funcToBase64(v any) any {\n\tswitch x := funcToString(v).(type) {\n\tcase string:\n\t\treturn base64.StdEncoding.EncodeToString([]byte(x))\n\tdefault:\n\t\treturn x\n\t}\n}\n\nfunc funcToBase64d(v any) any {\n\tswitch x := funcToString(v).(type) {\n\tcase string:\n\t\tif i := strings.IndexRune(x, base64.StdPadding); i >= 0 {\n\t\t\tx = x[:i]\n\t\t}\n\t\ty, err := base64.RawStdEncoding.DecodeString(x)\n\t\tif err != nil {\n\t\t\treturn &func0WrapError{\"@base64d\", v, err}\n\t\t}\n\t\treturn string(y)\n\tdefault:\n\t\treturn x\n\t}\n}\n\nfunc funcIndex2(_, v, x any) any {\n\tswitch x := x.(type) {\n\tcase string:\n\t\tswitch v := v.(type) {\n\t\tcase nil:\n\t\t\treturn nil\n\t\tcase map[string]any:\n\t\t\treturn v[x]\n\t\tdefault:\n\t\t\treturn &expectedObjectError{v}\n\t\t}\n\tcase int, float64, *big.Int:\n\t\ti, _ := toInt(x)\n\t\tswitch v := v.(type) {\n\t\tcase nil:\n\t\t\treturn nil\n\t\tcase []any:\n\t\t\treturn index(v, i)\n\t\tcase string:\n\t\t\treturn indexString(v, i)\n\t\tdefault:\n\t\t\treturn &expectedArrayError{v}\n\t\t}\n\tcase []any:\n\t\tswitch v := v.(type) {\n\t\tcase nil:\n\t\t\treturn nil\n\t\tcase []any:\n\t\t\treturn indices(v, x)\n\t\tdefault:\n\t\t\treturn &expectedArrayError{v}\n\t\t}\n\tcase map[string]any:\n\t\tif v == nil {\n\t\t\treturn nil\n\t\t}\n\t\tstart, ok := x[\"start\"]\n\t\tif !ok {\n\t\t\treturn &expectedStartEndError{x}\n\t\t}\n\t\tend, ok := x[\"end\"]\n\t\tif !ok {\n\t\t\treturn &expectedStartEndError{x}\n\t\t}\n\t\treturn funcSlice(nil, v, end, start)\n\tdefault:\n\t\tswitch v.(type) {\n\t\tcase []any:\n\t\t\treturn &arrayIndexNotNumberError{x}\n\t\tcase string:\n\t\t\treturn &stringIndexNotNumberError{x}\n\t\tdefault:\n\t\t\treturn &objectKeyNotStringError{x}\n\t\t}\n\t}\n}\n\nfunc index(vs []any, i int) any {\n\ti = clampIndex(i, -1, len(vs))\n\tif 0 <= i && i < len(vs) {\n\t\treturn vs[i]\n\t}\n\treturn nil\n}\n\nfunc indexString(s string, i int) any {\n\tl := len([]rune(s))\n\ti = clampIndex(i, -1, l)\n\tif 0 <= i && i < l {\n\t\tfor _, r := range s {\n\t\t\tif i--; i < 0 {\n\t\t\t\treturn string(r)\n\t\t\t}\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc funcSlice(_, v, e, s any) (r any) {\n\tswitch v := v.(type) {\n\tcase nil:\n\t\treturn nil\n\tcase []any:\n\t\treturn slice(v, e, s)\n\tcase string:\n\t\treturn sliceString(v, e, s)\n\tdefault:\n\t\treturn &expectedArrayError{v}\n\t}\n}\n\nfunc slice(vs []any, e, s any) any {\n\tvar start, end int\n\tif s != nil {\n\t\tif i, ok := toInt(s); ok {\n\t\t\tstart = clampIndex(i, 0, len(vs))\n\t\t} else {\n\t\t\treturn &arrayIndexNotNumberError{s}\n\t\t}\n\t}\n\tif e != nil {\n\t\tif i, ok := toInt(e); ok {\n\t\t\tend = clampIndex(i, start, len(vs))\n\t\t} else {\n\t\t\treturn &arrayIndexNotNumberError{e}\n\t\t}\n\t} else {\n\t\tend = len(vs)\n\t}\n\treturn vs[start:end]\n}\n\nfunc sliceString(v string, e, s any) any {\n\tvar start, end int\n\tl := len([]rune(v))\n\tif s != nil {\n\t\tif i, ok := toInt(s); ok {\n\t\t\tstart = clampIndex(i, 0, l)\n\t\t} else {\n\t\t\treturn &stringIndexNotNumberError{s}\n\t\t}\n\t}\n\tif e != nil {\n\t\tif i, ok := toInt(e); ok {\n\t\t\tend = clampIndex(i, start, l)\n\t\t} else {\n\t\t\treturn &stringIndexNotNumberError{e}\n\t\t}\n\t} else {\n\t\tend = l\n\t}\n\tif start < l {\n\t\tfor i := range v {\n\t\t\tif start--; start < 0 {\n\t\t\t\tstart = i\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t} else {\n\t\tstart = len(v)\n\t}\n\tif end < l {\n\t\tfor i := range v {\n\t\t\tif end--; end < 0 {\n\t\t\t\tend = i\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t} else {\n\t\tend = len(v)\n\t}\n\treturn v[start:end]\n}\n\nfunc clampIndex(i, min, max int) int {\n\tif i < 0 {\n\t\ti += max\n\t}\n\tif i < min {\n\t\treturn min\n\t} else if i < max {\n\t\treturn i\n\t} else {\n\t\treturn max\n\t}\n}\n\nfunc funcFlatten(v any, args []any) any {\n\tvs, ok := values(v)\n\tif !ok {\n\t\treturn &func0TypeError{\"flatten\", v}\n\t}\n\tvar depth float64\n\tif len(args) == 0 {\n\t\tdepth = -1\n\t} else {\n\t\tdepth, ok = toFloat(args[0])\n\t\tif !ok {\n\t\t\treturn &func0TypeError{\"flatten\", args[0]}\n\t\t}\n\t\tif depth < 0 {\n\t\t\treturn &flattenDepthError{depth}\n\t\t}\n\t}\n\treturn flatten([]any{}, vs, depth)\n}\n\nfunc flatten(xs, vs []any, depth float64) []any {\n\tfor _, v := range vs {\n\t\tif vs, ok := v.([]any); ok && depth != 0 {\n\t\t\txs = flatten(xs, vs, depth-1)\n\t\t} else {\n\t\t\txs = append(xs, v)\n\t\t}\n\t}\n\treturn xs\n}\n\ntype rangeIter struct {\n\tvalue, end, step any\n}\n\nfunc (iter *rangeIter) Next() (any, bool) {\n\tif Compare(iter.step, 0)*Compare(iter.value, iter.end) >= 0 {\n\t\treturn nil, false\n\t}\n\tv := iter.value\n\titer.value = funcOpAdd(nil, v, iter.step)\n\treturn v, true\n}\n\nfunc funcRange(_ any, xs []any) any {\n\tfor _, x := range xs {\n\t\tswitch x.(type) {\n\t\tcase int, float64, *big.Int:\n\t\tdefault:\n\t\t\treturn &func0TypeError{\"range\", x}\n\t\t}\n\t}\n\treturn &rangeIter{xs[0], xs[1], xs[2]}\n}\n\nfunc funcMin(v any) any {\n\tvs, ok := v.([]any)\n\tif !ok {\n\t\treturn &func0TypeError{\"min\", v}\n\t}\n\treturn minMaxBy(vs, vs, true)\n}\n\nfunc funcMinBy(v, x any) any {\n\tvs, ok := v.([]any)\n\tif !ok {\n\t\treturn &func1TypeError{\"min_by\", v, x}\n\t}\n\txs, ok := x.([]any)\n\tif !ok {\n\t\treturn &func1TypeError{\"min_by\", v, x}\n\t}\n\tif len(vs) != len(xs) {\n\t\treturn &func1WrapError{\"min_by\", v, x, &lengthMismatchError{}}\n\t}\n\treturn minMaxBy(vs, xs, true)\n}\n\nfunc funcMax(v any) any {\n\tvs, ok := v.([]any)\n\tif !ok {\n\t\treturn &func0TypeError{\"max\", v}\n\t}\n\treturn minMaxBy(vs, vs, false)\n}\n\nfunc funcMaxBy(v, x any) any {\n\tvs, ok := v.([]any)\n\tif !ok {\n\t\treturn &func1TypeError{\"max_by\", v, x}\n\t}\n\txs, ok := x.([]any)\n\tif !ok {\n\t\treturn &func1TypeError{\"max_by\", v, x}\n\t}\n\tif len(vs) != len(xs) {\n\t\treturn &func1WrapError{\"max_by\", v, x, &lengthMismatchError{}}\n\t}\n\treturn minMaxBy(vs, xs, false)\n}\n\nfunc minMaxBy(vs, xs []any, isMin bool) any {\n\tif len(vs) == 0 {\n\t\treturn nil\n\t}\n\ti, j, x := 0, 0, xs[0]\n\tfor i++; i < len(xs); i++ {\n\t\tif Compare(x, xs[i]) > 0 == isMin {\n\t\t\tj, x = i, xs[i]\n\t\t}\n\t}\n\treturn vs[j]\n}\n\ntype sortItem struct {\n\tvalue, key any\n}\n\nfunc sortItems(name string, v, x any) ([]*sortItem, error) {\n\tvs, ok := v.([]any)\n\tif !ok {\n\t\tif strings.HasSuffix(name, \"_by\") {\n\t\t\treturn nil, &func1TypeError{name, v, x}\n\t\t}\n\t\treturn nil, &func0TypeError{name, v}\n\t}\n\txs, ok := x.([]any)\n\tif !ok {\n\t\treturn nil, &func1TypeError{name, v, x}\n\t}\n\tif len(vs) != len(xs) {\n\t\treturn nil, &func1WrapError{name, v, x, &lengthMismatchError{}}\n\t}\n\titems := make([]*sortItem, len(vs))\n\tfor i, v := range vs {\n\t\titems[i] = &sortItem{v, xs[i]}\n\t}\n\tsort.SliceStable(items, func(i, j int) bool {\n\t\treturn Compare(items[i].key, items[j].key) < 0\n\t})\n\treturn items, nil\n}\n\nfunc funcSort(v any) any {\n\treturn sortBy(\"sort\", v, v)\n}\n\nfunc funcSortBy(v, x any) any {\n\treturn sortBy(\"sort_by\", v, x)\n}\n\nfunc sortBy(name string, v, x any) any {\n\titems, err := sortItems(name, v, x)\n\tif err != nil {\n\t\treturn err\n\t}\n\trs := make([]any, len(items))\n\tfor i, x := range items {\n\t\trs[i] = x.value\n\t}\n\treturn rs\n}\n\nfunc funcGroupBy(v, x any) any {\n\titems, err := sortItems(\"group_by\", v, x)\n\tif err != nil {\n\t\treturn err\n\t}\n\trs := []any{}\n\tvar last any\n\tfor i, r := range items {\n\t\tif i == 0 || Compare(last, r.key) != 0 {\n\t\t\trs, last = append(rs, []any{r.value}), r.key\n\t\t} else {\n\t\t\trs[len(rs)-1] = append(rs[len(rs)-1].([]any), r.value)\n\t\t}\n\t}\n\treturn rs\n}\n\nfunc funcUnique(v any) any {\n\treturn uniqueBy(\"unique\", v, v)\n}\n\nfunc funcUniqueBy(v, x any) any {\n\treturn uniqueBy(\"unique_by\", v, x)\n}\n\nfunc uniqueBy(name string, v, x any) any {\n\titems, err := sortItems(name, v, x)\n\tif err != nil {\n\t\treturn err\n\t}\n\trs := []any{}\n\tvar last any\n\tfor i, r := range items {\n\t\tif i == 0 || Compare(last, r.key) != 0 {\n\t\t\trs, last = append(rs, r.value), r.key\n\t\t}\n\t}\n\treturn rs\n}\n\nfunc funcJoin(v, x any) any {\n\tvs, ok := values(v)\n\tif !ok {\n\t\treturn &func1TypeError{\"join\", v, x}\n\t}\n\tif len(vs) == 0 {\n\t\treturn \"\"\n\t}\n\tsep, ok := x.(string)\n\tif len(vs) > 1 && !ok {\n\t\treturn &func1TypeError{\"join\", v, x}\n\t}\n\tss := make([]string, len(vs))\n\tfor i, v := range vs {\n\t\tswitch v := v.(type) {\n\t\tcase nil:\n\t\tcase string:\n\t\t\tss[i] = v\n\t\tcase bool:\n\t\t\tif v {\n\t\t\t\tss[i] = \"true\"\n\t\t\t} else {\n\t\t\t\tss[i] = \"false\"\n\t\t\t}\n\t\tcase int, float64, *big.Int:\n\t\t\tss[i] = jsonMarshal(v)\n\t\tdefault:\n\t\t\treturn &joinTypeError{v}\n\t\t}\n\t}\n\treturn strings.Join(ss, sep)\n}\n\nfunc funcSignificand(v float64) float64 {\n\tif math.IsNaN(v) || math.IsInf(v, 0) || v == 0.0 {\n\t\treturn v\n\t}\n\treturn math.Float64frombits((math.Float64bits(v) & 0x800fffffffffffff) | 0x3ff0000000000000)\n}\n\nfunc funcExp10(v float64) float64 {\n\treturn math.Pow(10, v)\n}\n\nfunc funcFrexp(v any) any {\n\tx, ok := toFloat(v)\n\tif !ok {\n\t\treturn &func0TypeError{\"frexp\", v}\n\t}\n\tf, e := math.Frexp(x)\n\treturn []any{f, e}\n}\n\nfunc funcModf(v any) any {\n\tx, ok := toFloat(v)\n\tif !ok {\n\t\treturn &func0TypeError{\"modf\", v}\n\t}\n\ti, f := math.Modf(x)\n\treturn []any{f, i}\n}\n\nfunc funcLgamma(v float64) float64 {\n\tv, _ = math.Lgamma(v)\n\treturn v\n}\n\nfunc funcDrem(l, r float64) float64 {\n\tx := math.Remainder(l, r)\n\tif x == 0.0 {\n\t\treturn math.Copysign(x, l)\n\t}\n\treturn x\n}\n\nfunc funcJn(l, r float64) float64 {\n\treturn math.Jn(int(l), r)\n}\n\nfunc funcLdexp(l, r float64) float64 {\n\treturn math.Ldexp(l, int(r))\n}\n\nfunc funcYn(l, r float64) float64 {\n\treturn math.Yn(int(l), r)\n}\n\nfunc funcInfinite(any) any {\n\treturn math.Inf(1)\n}\n\nfunc funcIsfinite(v any) any {\n\tx, ok := toFloat(v)\n\treturn ok && !math.IsInf(x, 0)\n}\n\nfunc funcIsinfinite(v any) any {\n\tx, ok := toFloat(v)\n\treturn ok && math.IsInf(x, 0)\n}\n\nfunc funcNan(any) any {\n\treturn math.NaN()\n}\n\nfunc funcIsnan(v any) any {\n\tx, ok := toFloat(v)\n\tif !ok {\n\t\tif v == nil {\n\t\t\treturn false\n\t\t}\n\t\treturn &func0TypeError{\"isnan\", v}\n\t}\n\treturn math.IsNaN(x)\n}\n\nfunc funcIsnormal(v any) any {\n\tif v, ok := toFloat(v); ok {\n\t\te := math.Float64bits(v) & 0x7ff0000000000000 >> 52\n\t\treturn 0 < e && e < 0x7ff\n\t}\n\treturn false\n}\n\n// An `allocator` creates new maps and slices, stores the allocated addresses.\n// This allocator is used to reduce allocations on assignment operator (`=`),\n// update-assignment operator (`|=`), and the `map_values`, `del`, `delpaths`\n// functions.\ntype allocator map[uintptr]struct{}\n\nfunc funcAllocator(any, []any) any {\n\treturn allocator{}\n}\n\nfunc (a allocator) allocated(v any) bool {\n\t_, ok := a[reflect.ValueOf(v).Pointer()]\n\treturn ok\n}\n\nfunc (a allocator) makeObject(l int) map[string]any {\n\tv := make(map[string]any, l)\n\tif a != nil {\n\t\ta[reflect.ValueOf(v).Pointer()] = struct{}{}\n\t}\n\treturn v\n}\n\nfunc (a allocator) makeArray(l, c int) []any {\n\tv := make([]any, l, max(l, c))\n\tif a != nil {\n\t\ta[reflect.ValueOf(v).Pointer()] = struct{}{}\n\t}\n\treturn v\n}\n\nfunc funcSetpath(v, p, n any) any {\n\t// There is no need to use an allocator on a single update.\n\treturn setpath(v, p, n, nil)\n}\n\n// Used in compiler#compileAssign and compiler#compileModify.\nfunc funcSetpathWithAllocator(v any, args []any) any {\n\treturn setpath(v, args[0], args[1], args[2].(allocator))\n}\n\nfunc setpath(v, p, n any, a allocator) any {\n\tpath, ok := p.([]any)\n\tif !ok {\n\t\treturn &func1TypeError{\"setpath\", v, p}\n\t}\n\tu, err := update(v, path, n, a)\n\tif err != nil {\n\t\treturn &func2WrapError{\"setpath\", v, p, n, err}\n\t}\n\treturn u\n}\n\nfunc funcDelpaths(v, p any) any {\n\treturn delpaths(v, p, allocator{})\n}\n\n// Used in compiler#compileAssign and compiler#compileModify.\nfunc funcDelpathsWithAllocator(v any, args []any) any {\n\treturn delpaths(v, args[0], args[1].(allocator))\n}\n\nfunc delpaths(v, p any, a allocator) any {\n\tpaths, ok := p.([]any)\n\tif !ok {\n\t\treturn &func1TypeError{\"delpaths\", v, p}\n\t}\n\tif len(paths) == 0 {\n\t\treturn v\n\t}\n\t// Fills the paths with an empty value and then delete them. We cannot delete\n\t// in each loop because array indices should not change. For example,\n\t//   jq -n \"[0, 1, 2, 3] | delpaths([[1], [2]])\" #=> [0, 3].\n\tvar empty struct{}\n\tvar err error\n\tu := v\n\tfor _, q := range paths {\n\t\tpath, ok := q.([]any)\n\t\tif !ok {\n\t\t\treturn &func1WrapError{\"delpaths\", v, p, &expectedArrayError{q}}\n\t\t}\n\t\tu, err = update(u, path, empty, a)\n\t\tif err != nil {\n\t\t\treturn &func1WrapError{\"delpaths\", v, p, err}\n\t\t}\n\t}\n\treturn deleteEmpty(u)\n}\n\nfunc update(v any, path []any, n any, a allocator) (any, error) {\n\tif len(path) == 0 {\n\t\treturn n, nil\n\t}\n\tswitch p := path[0].(type) {\n\tcase string:\n\t\tswitch v := v.(type) {\n\t\tcase nil:\n\t\t\treturn updateObject(nil, p, path[1:], n, a)\n\t\tcase map[string]any:\n\t\t\treturn updateObject(v, p, path[1:], n, a)\n\t\tcase struct{}:\n\t\t\treturn v, nil\n\t\tdefault:\n\t\t\treturn nil, &expectedObjectError{v}\n\t\t}\n\tcase int, float64, *big.Int:\n\t\ti, _ := toInt(p)\n\t\tswitch v := v.(type) {\n\t\tcase nil:\n\t\t\treturn updateArrayIndex(nil, i, path[1:], n, a)\n\t\tcase []any:\n\t\t\treturn updateArrayIndex(v, i, path[1:], n, a)\n\t\tcase struct{}:\n\t\t\treturn v, nil\n\t\tdefault:\n\t\t\treturn nil, &expectedArrayError{v}\n\t\t}\n\tcase map[string]any:\n\t\tswitch v := v.(type) {\n\t\tcase nil:\n\t\t\treturn updateArraySlice(nil, p, path[1:], n, a)\n\t\tcase []any:\n\t\t\treturn updateArraySlice(v, p, path[1:], n, a)\n\t\tcase struct{}:\n\t\t\treturn v, nil\n\t\tdefault:\n\t\t\treturn nil, &expectedArrayError{v}\n\t\t}\n\tdefault:\n\t\tswitch v.(type) {\n\t\tcase []any:\n\t\t\treturn nil, &arrayIndexNotNumberError{p}\n\t\tdefault:\n\t\t\treturn nil, &objectKeyNotStringError{p}\n\t\t}\n\t}\n}\n\nfunc updateObject(v map[string]any, k string, path []any, n any, a allocator) (any, error) {\n\tx, ok := v[k]\n\tif !ok && n == struct{}{} {\n\t\treturn v, nil\n\t}\n\tu, err := update(x, path, n, a)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif a.allocated(v) {\n\t\tv[k] = u\n\t\treturn v, nil\n\t}\n\tw := a.makeObject(len(v) + 1)\n\tfor k, v := range v {\n\t\tw[k] = v\n\t}\n\tw[k] = u\n\treturn w, nil\n}\n\nfunc updateArrayIndex(v []any, i int, path []any, n any, a allocator) (any, error) {\n\tvar x any\n\tif j := clampIndex(i, -1, len(v)); j < 0 {\n\t\tif n == struct{}{} {\n\t\t\treturn v, nil\n\t\t}\n\t\treturn nil, &arrayIndexNegativeError{i}\n\t} else if j < len(v) {\n\t\ti = j\n\t\tx = v[i]\n\t} else {\n\t\tif n == struct{}{} {\n\t\t\treturn v, nil\n\t\t}\n\t\tif i >= 0x8000000 {\n\t\t\treturn nil, &arrayIndexTooLargeError{i}\n\t\t}\n\t}\n\tu, err := update(x, path, n, a)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tl, c := len(v), cap(v)\n\tif a.allocated(v) {\n\t\tif i < c {\n\t\t\tif i >= l {\n\t\t\t\tv = v[:i+1]\n\t\t\t}\n\t\t\tv[i] = u\n\t\t\treturn v, nil\n\t\t}\n\t\tc *= 2\n\t}\n\tif i >= l {\n\t\tl = i + 1\n\t}\n\tw := a.makeArray(l, c)\n\tcopy(w, v)\n\tw[i] = u\n\treturn w, nil\n}\n\nfunc updateArraySlice(v []any, m map[string]any, path []any, n any, a allocator) (any, error) {\n\ts, ok := m[\"start\"]\n\tif !ok {\n\t\treturn nil, &expectedStartEndError{m}\n\t}\n\te, ok := m[\"end\"]\n\tif !ok {\n\t\treturn nil, &expectedStartEndError{m}\n\t}\n\tvar start, end int\n\tif i, ok := toInt(s); ok {\n\t\tstart = clampIndex(i, 0, len(v))\n\t}\n\tif i, ok := toInt(e); ok {\n\t\tend = clampIndex(i, start, len(v))\n\t} else {\n\t\tend = len(v)\n\t}\n\tif start == end && n == struct{}{} {\n\t\treturn v, nil\n\t}\n\tu, err := update(v[start:end], path, n, a)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tswitch u := u.(type) {\n\tcase []any:\n\t\tvar w []any\n\t\tif len(u) == end-start && a.allocated(v) {\n\t\t\tw = v\n\t\t} else {\n\t\t\tw = a.makeArray(len(v)-(end-start)+len(u), 0)\n\t\t\tcopy(w, v[:start])\n\t\t\tcopy(w[start+len(u):], v[end:])\n\t\t}\n\t\tcopy(w[start:], u)\n\t\treturn w, nil\n\tcase struct{}:\n\t\tvar w []any\n\t\tif a.allocated(v) {\n\t\t\tw = v\n\t\t} else {\n\t\t\tw = a.makeArray(len(v), 0)\n\t\t\tcopy(w, v)\n\t\t}\n\t\tfor i := start; i < end; i++ {\n\t\t\tw[i] = u\n\t\t}\n\t\treturn w, nil\n\tdefault:\n\t\treturn nil, &expectedArrayError{u}\n\t}\n}\n\nfunc deleteEmpty(v any) any {\n\tswitch v := v.(type) {\n\tcase struct{}:\n\t\treturn nil\n\tcase map[string]any:\n\t\tfor k, w := range v {\n\t\t\tif w == struct{}{} {\n\t\t\t\tdelete(v, k)\n\t\t\t} else {\n\t\t\t\tv[k] = deleteEmpty(w)\n\t\t\t}\n\t\t}\n\t\treturn v\n\tcase []any:\n\t\tvar j int\n\t\tfor _, w := range v {\n\t\t\tif w != struct{}{} {\n\t\t\t\tv[j] = deleteEmpty(w)\n\t\t\t\tj++\n\t\t\t}\n\t\t}\n\t\tfor i := j; i < len(v); i++ {\n\t\t\tv[i] = nil\n\t\t}\n\t\treturn v[:j]\n\tdefault:\n\t\treturn v\n\t}\n}\n\nfunc funcGetpath(v, p any) any {\n\tpath, ok := p.([]any)\n\tif !ok {\n\t\treturn &func1TypeError{\"getpath\", v, p}\n\t}\n\tu := v\n\tfor _, x := range path {\n\t\tswitch v.(type) {\n\t\tcase nil, []any, map[string]any:\n\t\t\tv = funcIndex2(nil, v, x)\n\t\t\tif err, ok := v.(error); ok {\n\t\t\t\treturn &func1WrapError{\"getpath\", u, p, err}\n\t\t\t}\n\t\tdefault:\n\t\t\treturn &func1TypeError{\"getpath\", u, p}\n\t\t}\n\t}\n\treturn v\n}\n\nfunc funcTranspose(v any) any {\n\tvss, ok := v.([]any)\n\tif !ok {\n\t\treturn &func0TypeError{\"transpose\", v}\n\t}\n\tif len(vss) == 0 {\n\t\treturn []any{}\n\t}\n\tvar l int\n\tfor _, vs := range vss {\n\t\tvs, ok := vs.([]any)\n\t\tif !ok {\n\t\t\treturn &func0TypeError{\"transpose\", v}\n\t\t}\n\t\tif k := len(vs); l < k {\n\t\t\tl = k\n\t\t}\n\t}\n\twss := make([][]any, l)\n\txs := make([]any, l)\n\tfor i, k := 0, len(vss); i < l; i++ {\n\t\ts := make([]any, k)\n\t\twss[i] = s\n\t\txs[i] = s\n\t}\n\tfor i, vs := range vss {\n\t\tfor j, v := range vs.([]any) {\n\t\t\twss[j][i] = v\n\t\t}\n\t}\n\treturn xs\n}\n\nfunc funcBsearch(v, t any) any {\n\tvs, ok := v.([]any)\n\tif !ok {\n\t\treturn &func1TypeError{\"bsearch\", v, t}\n\t}\n\ti := sort.Search(len(vs), func(i int) bool {\n\t\treturn Compare(vs[i], t) >= 0\n\t})\n\tif i < len(vs) && Compare(vs[i], t) == 0 {\n\t\treturn i\n\t}\n\treturn -i - 1\n}\n\nfunc funcGmtime(v any) any {\n\tif v, ok := toFloat(v); ok {\n\t\treturn epochToArray(v, time.UTC)\n\t}\n\treturn &func0TypeError{\"gmtime\", v}\n}\n\nfunc funcLocaltime(v any) any {\n\tif v, ok := toFloat(v); ok {\n\t\treturn epochToArray(v, time.Local)\n\t}\n\treturn &func0TypeError{\"localtime\", v}\n}\n\nfunc epochToArray(v float64, loc *time.Location) []any {\n\tt := time.Unix(int64(v), int64((v-math.Floor(v))*1e9)).In(loc)\n\treturn []any{\n\t\tt.Year(),\n\t\tint(t.Month()) - 1,\n\t\tt.Day(),\n\t\tt.Hour(),\n\t\tt.Minute(),\n\t\tfloat64(t.Second()) + float64(t.Nanosecond())/1e9,\n\t\tint(t.Weekday()),\n\t\tt.YearDay() - 1,\n\t}\n}\n\nfunc funcMktime(v any) any {\n\ta, ok := v.([]any)\n\tif !ok {\n\t\treturn &func0TypeError{\"mktime\", v}\n\t}\n\tt, err := arrayToTime(a, time.UTC)\n\tif err != nil {\n\t\treturn &func0WrapError{\"mktime\", v, err}\n\t}\n\treturn timeToEpoch(t)\n}\n\nfunc timeToEpoch(t time.Time) float64 {\n\treturn float64(t.Unix()) + float64(t.Nanosecond())/1e9\n}\n\nfunc funcStrftime(v, x any) any {\n\tif w, ok := toFloat(v); ok {\n\t\tv = epochToArray(w, time.UTC)\n\t}\n\ta, ok := v.([]any)\n\tif !ok {\n\t\treturn &func1TypeError{\"strftime\", v, x}\n\t}\n\tformat, ok := x.(string)\n\tif !ok {\n\t\treturn &func1TypeError{\"strftime\", v, x}\n\t}\n\tt, err := arrayToTime(a, time.UTC)\n\tif err != nil {\n\t\treturn &func1WrapError{\"strftime\", v, x, err}\n\t}\n\treturn timefmt.Format(t, format)\n}\n\nfunc funcStrflocaltime(v, x any) any {\n\tif w, ok := toFloat(v); ok {\n\t\tv = epochToArray(w, time.Local)\n\t}\n\ta, ok := v.([]any)\n\tif !ok {\n\t\treturn &func1TypeError{\"strflocaltime\", v, x}\n\t}\n\tformat, ok := x.(string)\n\tif !ok {\n\t\treturn &func1TypeError{\"strflocaltime\", v, x}\n\t}\n\tt, err := arrayToTime(a, time.Local)\n\tif err != nil {\n\t\treturn &func1WrapError{\"strflocaltime\", v, x, err}\n\t}\n\treturn timefmt.Format(t, format)\n}\n\nfunc funcStrptime(v, x any) any {\n\ts, ok := v.(string)\n\tif !ok {\n\t\treturn &func1TypeError{\"strptime\", v, x}\n\t}\n\tformat, ok := x.(string)\n\tif !ok {\n\t\treturn &func1TypeError{\"strptime\", v, x}\n\t}\n\tt, err := timefmt.Parse(s, format)\n\tif err != nil {\n\t\treturn &func1WrapError{\"strptime\", v, x, err}\n\t}\n\tvar u time.Time\n\tif t == u {\n\t\treturn &func1TypeError{\"strptime\", v, x}\n\t}\n\treturn epochToArray(timeToEpoch(t), time.UTC)\n}\n\nfunc arrayToTime(a []any, loc *time.Location) (time.Time, error) {\n\tvar t time.Time\n\tvar year, month, day, hour, minute,\n\t\tsecond, nanosecond, weekday, yearday int\n\tfor i, p := range []*int{\n\t\t&year, &month, &day, &hour, &minute,\n\t\t&second, &weekday, &yearday,\n\t} {\n\t\tif i >= len(a) {\n\t\t\tbreak\n\t\t}\n\t\tif i == 5 {\n\t\t\tif v, ok := toFloat(a[i]); ok {\n\t\t\t\t*p = int(v)\n\t\t\t\tnanosecond = int((v - math.Floor(v)) * 1e9)\n\t\t\t} else {\n\t\t\t\treturn t, &timeArrayError{}\n\t\t\t}\n\t\t} else if v, ok := toInt(a[i]); ok {\n\t\t\t*p = v\n\t\t} else {\n\t\t\treturn t, &timeArrayError{}\n\t\t}\n\t}\n\treturn time.Date(year, time.Month(month+1), day,\n\t\thour, minute, second, nanosecond, loc), nil\n}\n\nfunc funcNow(any) any {\n\treturn timeToEpoch(time.Now())\n}\n\nfunc funcMatch(v, re, fs, testing any) any {\n\tname := \"match\"\n\tif testing == true {\n\t\tname = \"test\"\n\t}\n\tvar flags string\n\tif fs != nil {\n\t\tv, ok := fs.(string)\n\t\tif !ok {\n\t\t\treturn &func2TypeError{name, v, re, fs}\n\t\t}\n\t\tflags = v\n\t}\n\ts, ok := v.(string)\n\tif !ok {\n\t\treturn &func2TypeError{name, v, re, fs}\n\t}\n\trestr, ok := re.(string)\n\tif !ok {\n\t\treturn &func2TypeError{name, v, re, fs}\n\t}\n\tr, err := compileRegexp(restr, flags)\n\tif err != nil {\n\t\treturn err\n\t}\n\tvar xs [][]int\n\tif strings.ContainsRune(flags, 'g') && testing != true {\n\t\txs = r.FindAllStringSubmatchIndex(s, -1)\n\t} else {\n\t\tgot := r.FindStringSubmatchIndex(s)\n\t\tif testing == true {\n\t\t\treturn got != nil\n\t\t}\n\t\tif got != nil {\n\t\t\txs = [][]int{got}\n\t\t}\n\t}\n\tres, names := make([]any, len(xs)), r.SubexpNames()\n\tfor i, x := range xs {\n\t\tcaptures := make([]any, (len(x)-2)/2)\n\t\tfor j := 1; j < len(x)/2; j++ {\n\t\t\tvar name any\n\t\t\tif n := names[j]; n != \"\" {\n\t\t\t\tname = n\n\t\t\t}\n\t\t\tif x[j*2] < 0 {\n\t\t\t\tcaptures[j-1] = map[string]any{\n\t\t\t\t\t\"name\":   name,\n\t\t\t\t\t\"offset\": -1,\n\t\t\t\t\t\"length\": 0,\n\t\t\t\t\t\"string\": nil,\n\t\t\t\t}\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tcaptures[j-1] = map[string]any{\n\t\t\t\t\"name\":   name,\n\t\t\t\t\"offset\": len([]rune(s[:x[j*2]])),\n\t\t\t\t\"length\": len([]rune(s[:x[j*2+1]])) - len([]rune(s[:x[j*2]])),\n\t\t\t\t\"string\": s[x[j*2]:x[j*2+1]],\n\t\t\t}\n\t\t}\n\t\tres[i] = map[string]any{\n\t\t\t\"offset\":   len([]rune(s[:x[0]])),\n\t\t\t\"length\":   len([]rune(s[:x[1]])) - len([]rune(s[:x[0]])),\n\t\t\t\"string\":   s[x[0]:x[1]],\n\t\t\t\"captures\": captures,\n\t\t}\n\t}\n\treturn res\n}\n\nfunc compileRegexp(re, flags string) (*regexp.Regexp, error) {\n\tif strings.IndexFunc(flags, func(r rune) bool {\n\t\treturn r != 'g' && r != 'i' && r != 'm'\n\t}) >= 0 {\n\t\treturn nil, fmt.Errorf(\"unsupported regular expression flag: %q\", flags)\n\t}\n\tre = strings.ReplaceAll(re, \"(?<\", \"(?P<\")\n\tif strings.ContainsRune(flags, 'i') {\n\t\tre = \"(?i)\" + re\n\t}\n\tif strings.ContainsRune(flags, 'm') {\n\t\tre = \"(?s)\" + re\n\t}\n\tr, err := regexp.Compile(re)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"invalid regular expression %q: %s\", re, err)\n\t}\n\treturn r, nil\n}\n\nfunc funcCapture(v any) any {\n\tvs, ok := v.(map[string]any)\n\tif !ok {\n\t\treturn &expectedObjectError{v}\n\t}\n\tv = vs[\"captures\"]\n\tcaptures, ok := v.([]any)\n\tif !ok {\n\t\treturn &expectedArrayError{v}\n\t}\n\tw := make(map[string]any, len(captures))\n\tfor _, capture := range captures {\n\t\tif capture, ok := capture.(map[string]any); ok {\n\t\t\tif name, ok := capture[\"name\"].(string); ok {\n\t\t\t\tw[name] = capture[\"string\"]\n\t\t\t}\n\t\t}\n\t}\n\treturn w\n}\n\nfunc funcError(v any, args []any) any {\n\tif len(args) > 0 {\n\t\tv = args[0]\n\t}\n\treturn &exitCodeError{v, 5}\n}\n\nfunc funcHalt(any) any {\n\treturn &HaltError{nil, 0}\n}\n\nfunc funcHaltError(v any, args []any) any {\n\tcode := 5\n\tif len(args) > 0 {\n\t\tvar ok bool\n\t\tif code, ok = toInt(args[0]); !ok {\n\t\t\treturn &func0TypeError{\"halt_error\", args[0]}\n\t\t}\n\t}\n\treturn &HaltError{v, code}\n}\n\nfunc toInt(x any) (int, bool) {\n\tswitch x := x.(type) {\n\tcase int:\n\t\treturn x, true\n\tcase float64:\n\t\treturn floatToInt(x), true\n\tcase *big.Int:\n\t\tif x.IsInt64() {\n\t\t\tif i := x.Int64(); math.MinInt <= i && i <= math.MaxInt {\n\t\t\t\treturn int(i), true\n\t\t\t}\n\t\t}\n\t\tif x.Sign() > 0 {\n\t\t\treturn math.MaxInt, true\n\t\t}\n\t\treturn math.MinInt, true\n\tdefault:\n\t\treturn 0, false\n\t}\n}\n\nfunc floatToInt(x float64) int {\n\tif math.MinInt <= x && x <= math.MaxInt {\n\t\treturn int(x)\n\t}\n\tif x > 0 {\n\t\treturn math.MaxInt\n\t}\n\treturn math.MinInt\n}\n\nfunc toFloat(x any) (float64, bool) {\n\tswitch x := x.(type) {\n\tcase int:\n\t\treturn float64(x), true\n\tcase float64:\n\t\treturn x, true\n\tcase *big.Int:\n\t\treturn bigToFloat(x), true\n\tdefault:\n\t\treturn 0.0, false\n\t}\n}\n\nfunc bigToFloat(x *big.Int) float64 {\n\tif x.IsInt64() {\n\t\treturn float64(x.Int64())\n\t}\n\tif f, err := strconv.ParseFloat(x.String(), 64); err == nil {\n\t\treturn f\n\t}\n\treturn math.Inf(x.Sign())\n}\n"
        },
        {
          "name": "go.dev.mod",
          "type": "blob",
          "size": 0.17578125,
          "content": "module github.com/itchyny/gojq\n\ngo 1.21\n\nrequire (\n\tgithub.com/itchyny/astgen-go v0.0.0-20231113225122-e1c22b9aaf7b // indirect\n\tgithub.com/itchyny/timefmt-go v0.1.6 // indirect\n)\n"
        },
        {
          "name": "go.dev.sum",
          "type": "blob",
          "size": 0.3984375,
          "content": "github.com/itchyny/astgen-go v0.0.0-20231113225122-e1c22b9aaf7b h1:72fDU7wad+r3iQObaxhlXVIpAIMRUIUMrNa3go1vb8s=\ngithub.com/itchyny/astgen-go v0.0.0-20231113225122-e1c22b9aaf7b/go.mod h1:Zp6xzEWVc2pQ/ObfLD6t/M6gDegsJWKdGKJSiT7qlu0=\ngithub.com/itchyny/timefmt-go v0.1.6 h1:ia3s54iciXDdzWzwaVKXZPbiXzxxnv1SPGFfM/myJ5Q=\ngithub.com/itchyny/timefmt-go v0.1.6/go.mod h1:RRDZYC5s9ErkjQvTvvU7keJjxUYzIISJGxm9/mAERQg=\n"
        },
        {
          "name": "go.mod",
          "type": "blob",
          "size": 0.310546875,
          "content": "module github.com/itchyny/gojq\n\ngo 1.21\n\nrequire (\n\tgithub.com/google/go-cmp v0.5.4\n\tgithub.com/itchyny/timefmt-go v0.1.6\n\tgithub.com/mattn/go-isatty v0.0.20\n\tgithub.com/mattn/go-runewidth v0.0.15\n\tgopkg.in/yaml.v3 v3.0.1\n)\n\nrequire (\n\tgithub.com/rivo/uniseg v0.4.7 // indirect\n\tgolang.org/x/sys v0.20.0 // indirect\n)\n"
        },
        {
          "name": "go.sum",
          "type": "blob",
          "size": 1.7099609375,
          "content": "github.com/google/go-cmp v0.5.4 h1:L8R9j+yAqZuZjsqh/z+F1NCffTKKLShY6zXTItVIZ8M=\ngithub.com/google/go-cmp v0.5.4/go.mod h1:v8dTdLbMG2kIc/vJvl+f65V22dbkXbowE6jgT/gNBxE=\ngithub.com/itchyny/timefmt-go v0.1.6 h1:ia3s54iciXDdzWzwaVKXZPbiXzxxnv1SPGFfM/myJ5Q=\ngithub.com/itchyny/timefmt-go v0.1.6/go.mod h1:RRDZYC5s9ErkjQvTvvU7keJjxUYzIISJGxm9/mAERQg=\ngithub.com/mattn/go-isatty v0.0.20 h1:xfD0iDuEKnDkl03q4limB+vH+GxLEtL/jb4xVJSWWEY=\ngithub.com/mattn/go-isatty v0.0.20/go.mod h1:W+V8PltTTMOvKvAeJH7IuucS94S2C6jfK/D7dTCTo3Y=\ngithub.com/mattn/go-runewidth v0.0.15 h1:UNAjwbU9l54TA3KzvqLGxwWjHmMgBUVhBiTjelZgg3U=\ngithub.com/mattn/go-runewidth v0.0.15/go.mod h1:Jdepj2loyihRzMpdS35Xk/zdY8IAYHsh153qUoGf23w=\ngithub.com/rivo/uniseg v0.2.0/go.mod h1:J6wj4VEh+S6ZtnVlnTBMWIodfgj8LQOQFoIToxlJtxc=\ngithub.com/rivo/uniseg v0.4.7 h1:WUdvkW8uEhrYfLC4ZzdpI2ztxP1I582+49Oc5Mq64VQ=\ngithub.com/rivo/uniseg v0.4.7/go.mod h1:FN3SvrM+Zdj16jyLfmOkMNblXMcoc8DfTHruCPUcx88=\ngolang.org/x/sys v0.6.0/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\ngolang.org/x/sys v0.20.0 h1:Od9JTbYCk261bKm4M/mw7AklTlFYIa0bIp9BgSm1S8Y=\ngolang.org/x/sys v0.20.0/go.mod h1:/VUhepiaJMQUp4+oa/7Zr1D23ma6VTLIYjOOTFZPUcA=\ngolang.org/x/xerrors v0.0.0-20191204190536-9bdfabe68543 h1:E7g+9GITq07hpfrRu66IVDexMakfv52eLZ2CXBWiKr4=\ngolang.org/x/xerrors v0.0.0-20191204190536-9bdfabe68543/go.mod h1:I/5z698sn9Ka8TeJc9MKroUUfqBBauWjQqLJ2OPfmY0=\ngopkg.in/check.v1 v0.0.0-20161208181325-20d25e280405 h1:yhCVgyC4o1eVCa2tZl7eS0r+SDo693bJlVdllGtEeKM=\ngopkg.in/check.v1 v0.0.0-20161208181325-20d25e280405/go.mod h1:Co6ibVJAznAaIkqp8huTwlJQCZ016jof/cbN4VW5Yz0=\ngopkg.in/yaml.v3 v3.0.1 h1:fxVm/GzAzEWqLHuvctI91KS9hhNmmWOoWu0XTYJS7CA=\ngopkg.in/yaml.v3 v3.0.1/go.mod h1:K4uyk7z7BCEPqu6E+C64Yfv1cQ7kz7rIZviUmN+EgEM=\n"
        },
        {
          "name": "gojq.go",
          "type": "blob",
          "size": 0.2099609375,
          "content": "// Package gojq provides the parser and the interpreter of gojq.\n// Please refer to [Usage as a library] for introduction.\n//\n// [Usage as a library]: https://github.com/itchyny/gojq#usage-as-a-library\npackage gojq\n"
        },
        {
          "name": "iter.go",
          "type": "blob",
          "size": 0.755859375,
          "content": "package gojq\n\n// Iter is an interface for an iterator.\ntype Iter interface {\n\tNext() (any, bool)\n}\n\n// NewIter creates a new [Iter] from values.\nfunc NewIter(values ...any) Iter {\n\tswitch len(values) {\n\tcase 0:\n\t\treturn emptyIter{}\n\tcase 1:\n\t\treturn &unitIter{value: values[0]}\n\tdefault:\n\t\titer := sliceIter(values)\n\t\treturn &iter\n\t}\n}\n\ntype emptyIter struct{}\n\nfunc (emptyIter) Next() (any, bool) {\n\treturn nil, false\n}\n\ntype unitIter struct {\n\tvalue any\n\tdone  bool\n}\n\nfunc (iter *unitIter) Next() (any, bool) {\n\tif iter.done {\n\t\treturn nil, false\n\t}\n\titer.done = true\n\treturn iter.value, true\n}\n\ntype sliceIter []any\n\nfunc (iter *sliceIter) Next() (any, bool) {\n\tif len(*iter) == 0 {\n\t\treturn nil, false\n\t}\n\tvalue := (*iter)[0]\n\t*iter = (*iter)[1:]\n\treturn value, true\n}\n"
        },
        {
          "name": "lexer.go",
          "type": "blob",
          "size": 10.7197265625,
          "content": "package gojq\n\nimport (\n\t\"encoding/json\"\n\t\"unicode/utf8\"\n)\n\ntype lexer struct {\n\tsource    string\n\toffset    int\n\tresult    *Query\n\ttoken     string\n\ttokenType int\n\tinString  bool\n\terr       error\n}\n\nfunc newLexer(src string) *lexer {\n\treturn &lexer{source: src}\n}\n\nconst eof = -1\n\nvar keywords = map[string]int{\n\t\"or\":      tokOrOp,\n\t\"and\":     tokAndOp,\n\t\"module\":  tokModule,\n\t\"import\":  tokImport,\n\t\"include\": tokInclude,\n\t\"def\":     tokDef,\n\t\"as\":      tokAs,\n\t\"label\":   tokLabel,\n\t\"break\":   tokBreak,\n\t\"null\":    tokNull,\n\t\"true\":    tokTrue,\n\t\"false\":   tokFalse,\n\t\"if\":      tokIf,\n\t\"then\":    tokThen,\n\t\"elif\":    tokElif,\n\t\"else\":    tokElse,\n\t\"end\":     tokEnd,\n\t\"try\":     tokTry,\n\t\"catch\":   tokCatch,\n\t\"reduce\":  tokReduce,\n\t\"foreach\": tokForeach,\n}\n\nfunc (l *lexer) Lex(lval *yySymType) (tokenType int) {\n\tdefer func() { l.tokenType = tokenType }()\n\tif len(l.source) == l.offset {\n\t\tl.token = \"\"\n\t\treturn eof\n\t}\n\tif l.inString {\n\t\ttok, str := l.scanString(l.offset)\n\t\tlval.token = str\n\t\treturn tok\n\t}\n\tch, iseof := l.next()\n\tif iseof {\n\t\tl.token = \"\"\n\t\treturn eof\n\t}\n\tswitch {\n\tcase isIdent(ch, false):\n\t\ti := l.offset - 1\n\t\tj, isModule := l.scanIdentOrModule()\n\t\tl.token = l.source[i:j]\n\t\tlval.token = l.token\n\t\tif isModule {\n\t\t\treturn tokModuleIdent\n\t\t}\n\t\tif tok, ok := keywords[l.token]; ok {\n\t\t\treturn tok\n\t\t}\n\t\treturn tokIdent\n\tcase isNumber(ch):\n\t\ti := l.offset - 1\n\t\tj := l.scanNumber(numberStateLead)\n\t\tif j < 0 {\n\t\t\tl.token = l.source[i:-j]\n\t\t\treturn tokInvalid\n\t\t}\n\t\tl.token = l.source[i:j]\n\t\tlval.token = l.token\n\t\treturn tokNumber\n\t}\n\tswitch ch {\n\tcase '.':\n\t\tch := l.peek()\n\t\tswitch {\n\t\tcase ch == '.':\n\t\t\tl.offset++\n\t\t\tl.token = \"..\"\n\t\t\treturn tokRecurse\n\t\tcase isIdent(ch, false):\n\t\t\tl.token = l.source[l.offset-1 : l.scanIdent()]\n\t\t\tlval.token = l.token[1:]\n\t\t\treturn tokIndex\n\t\tcase isNumber(ch):\n\t\t\ti := l.offset - 1\n\t\t\tj := l.scanNumber(numberStateFloat)\n\t\t\tif j < 0 {\n\t\t\t\tl.token = l.source[i:-j]\n\t\t\t\treturn tokInvalid\n\t\t\t}\n\t\t\tl.token = l.source[i:j]\n\t\t\tlval.token = l.token\n\t\t\treturn tokNumber\n\t\tdefault:\n\t\t\treturn '.'\n\t\t}\n\tcase '$':\n\t\tif isIdent(l.peek(), false) {\n\t\t\ti := l.offset - 1\n\t\t\tj, isModule := l.scanIdentOrModule()\n\t\t\tl.token = l.source[i:j]\n\t\t\tlval.token = l.token\n\t\t\tif isModule {\n\t\t\t\treturn tokModuleVariable\n\t\t\t}\n\t\t\treturn tokVariable\n\t\t}\n\tcase '|':\n\t\tif l.peek() == '=' {\n\t\t\tl.offset++\n\t\t\tl.token = \"|=\"\n\t\t\tlval.operator = OpModify\n\t\t\treturn tokUpdateOp\n\t\t}\n\tcase '?':\n\t\tif l.peek() == '/' {\n\t\t\tl.offset++\n\t\t\tif l.peek() == '/' {\n\t\t\t\tl.offset++\n\t\t\t\tl.token = \"?//\"\n\t\t\t\treturn tokDestAltOp\n\t\t\t}\n\t\t\tl.offset--\n\t\t}\n\tcase '+':\n\t\tif l.peek() == '=' {\n\t\t\tl.offset++\n\t\t\tl.token = \"+=\"\n\t\t\tlval.operator = OpUpdateAdd\n\t\t\treturn tokUpdateOp\n\t\t}\n\tcase '-':\n\t\tif l.peek() == '=' {\n\t\t\tl.offset++\n\t\t\tl.token = \"-=\"\n\t\t\tlval.operator = OpUpdateSub\n\t\t\treturn tokUpdateOp\n\t\t}\n\tcase '*':\n\t\tif l.peek() == '=' {\n\t\t\tl.offset++\n\t\t\tl.token = \"*=\"\n\t\t\tlval.operator = OpUpdateMul\n\t\t\treturn tokUpdateOp\n\t\t}\n\tcase '/':\n\t\tswitch l.peek() {\n\t\tcase '=':\n\t\t\tl.offset++\n\t\t\tl.token = \"/=\"\n\t\t\tlval.operator = OpUpdateDiv\n\t\t\treturn tokUpdateOp\n\t\tcase '/':\n\t\t\tl.offset++\n\t\t\tif l.peek() == '=' {\n\t\t\t\tl.offset++\n\t\t\t\tl.token = \"//=\"\n\t\t\t\tlval.operator = OpUpdateAlt\n\t\t\t\treturn tokUpdateOp\n\t\t\t}\n\t\t\tl.token = \"//\"\n\t\t\tlval.operator = OpAlt\n\t\t\treturn tokAltOp\n\t\t}\n\tcase '%':\n\t\tif l.peek() == '=' {\n\t\t\tl.offset++\n\t\t\tl.token = \"%=\"\n\t\t\tlval.operator = OpUpdateMod\n\t\t\treturn tokUpdateOp\n\t\t}\n\tcase '=':\n\t\tif l.peek() == '=' {\n\t\t\tl.offset++\n\t\t\tl.token = \"==\"\n\t\t\tlval.operator = OpEq\n\t\t\treturn tokCompareOp\n\t\t}\n\t\tl.token = \"=\"\n\t\tlval.operator = OpAssign\n\t\treturn tokUpdateOp\n\tcase '!':\n\t\tif l.peek() == '=' {\n\t\t\tl.offset++\n\t\t\tl.token = \"!=\"\n\t\t\tlval.operator = OpNe\n\t\t\treturn tokCompareOp\n\t\t}\n\tcase '>':\n\t\tif l.peek() == '=' {\n\t\t\tl.offset++\n\t\t\tl.token = \">=\"\n\t\t\tlval.operator = OpGe\n\t\t\treturn tokCompareOp\n\t\t}\n\t\tl.token = \">\"\n\t\tlval.operator = OpGt\n\t\treturn tokCompareOp\n\tcase '<':\n\t\tif l.peek() == '=' {\n\t\t\tl.offset++\n\t\t\tl.token = \"<=\"\n\t\t\tlval.operator = OpLe\n\t\t\treturn tokCompareOp\n\t\t}\n\t\tl.token = \"<\"\n\t\tlval.operator = OpLt\n\t\treturn tokCompareOp\n\tcase '@':\n\t\tif isIdent(l.peek(), true) {\n\t\t\tl.token = l.source[l.offset-1 : l.scanIdent()]\n\t\t\tlval.token = l.token\n\t\t\treturn tokFormat\n\t\t}\n\tcase '\"':\n\t\ttok, str := l.scanString(l.offset - 1)\n\t\tlval.token = str\n\t\treturn tok\n\tdefault:\n\t\tif ch >= utf8.RuneSelf {\n\t\t\tr, size := utf8.DecodeRuneInString(l.source[l.offset-1:])\n\t\t\t// -1 to adjust for first byte consumed by next()\n\t\t\tl.offset += size - 1\n\t\t\tl.token = string(r)\n\t\t}\n\t}\n\treturn int(ch)\n}\n\nfunc (l *lexer) next() (byte, bool) {\n\tfor {\n\t\tch := l.source[l.offset]\n\t\tl.offset++\n\t\tif ch == '#' {\n\t\t\tif l.skipComment() {\n\t\t\t\treturn 0, true\n\t\t\t}\n\t\t} else if !isWhite(ch) {\n\t\t\treturn ch, false\n\t\t} else if len(l.source) == l.offset {\n\t\t\treturn 0, true\n\t\t}\n\t}\n}\n\nfunc (l *lexer) skipComment() bool {\n\tfor {\n\t\tswitch l.peek() {\n\t\tcase 0:\n\t\t\treturn true\n\t\tcase '\\\\':\n\t\t\tswitch l.offset++; l.peek() {\n\t\t\tcase '\\\\', '\\n':\n\t\t\t\tl.offset++\n\t\t\tcase '\\r':\n\t\t\t\tif l.offset++; l.peek() == '\\n' {\n\t\t\t\t\tl.offset++\n\t\t\t\t}\n\t\t\t}\n\t\tcase '\\n', '\\r':\n\t\t\treturn false\n\t\tdefault:\n\t\t\tl.offset++\n\t\t}\n\t}\n}\n\nfunc (l *lexer) peek() byte {\n\tif len(l.source) == l.offset {\n\t\treturn 0\n\t}\n\treturn l.source[l.offset]\n}\n\nfunc (l *lexer) scanIdent() int {\n\tfor isIdent(l.peek(), true) {\n\t\tl.offset++\n\t}\n\treturn l.offset\n}\n\nfunc (l *lexer) scanIdentOrModule() (int, bool) {\n\tindex := l.scanIdent()\n\tvar isModule bool\n\tif l.peek() == ':' {\n\t\tl.offset++\n\t\tif l.peek() == ':' {\n\t\t\tl.offset++\n\t\t\tif isIdent(l.peek(), false) {\n\t\t\t\tl.offset++\n\t\t\t\tindex = l.scanIdent()\n\t\t\t\tisModule = true\n\t\t\t} else {\n\t\t\t\tl.offset -= 2\n\t\t\t}\n\t\t} else {\n\t\t\tl.offset--\n\t\t}\n\t}\n\treturn index, isModule\n}\n\nfunc (l *lexer) validVarName() bool {\n\tif l.peek() != '$' {\n\t\treturn false\n\t}\n\tl.offset++\n\treturn isIdent(l.peek(), false) && l.scanIdent() == len(l.source)\n}\n\nconst (\n\tnumberStateLead = iota\n\tnumberStateFloat\n\tnumberStateExpLead\n\tnumberStateExp\n)\n\nfunc (l *lexer) scanNumber(state int) int {\n\tfor {\n\t\tswitch state {\n\t\tcase numberStateLead, numberStateFloat:\n\t\t\tif ch := l.peek(); isNumber(ch) {\n\t\t\t\tl.offset++\n\t\t\t} else {\n\t\t\t\tswitch ch {\n\t\t\t\tcase '.':\n\t\t\t\t\tif state != numberStateLead {\n\t\t\t\t\t\tl.offset++\n\t\t\t\t\t\treturn -l.offset\n\t\t\t\t\t}\n\t\t\t\t\tl.offset++\n\t\t\t\t\tstate = numberStateFloat\n\t\t\t\tcase 'e', 'E':\n\t\t\t\t\tl.offset++\n\t\t\t\t\tswitch l.peek() {\n\t\t\t\t\tcase '-', '+':\n\t\t\t\t\t\tl.offset++\n\t\t\t\t\t}\n\t\t\t\t\tstate = numberStateExpLead\n\t\t\t\tdefault:\n\t\t\t\t\tif isIdent(ch, false) {\n\t\t\t\t\t\tl.offset++\n\t\t\t\t\t\treturn -l.offset\n\t\t\t\t\t}\n\t\t\t\t\treturn l.offset\n\t\t\t\t}\n\t\t\t}\n\t\tcase numberStateExpLead, numberStateExp:\n\t\t\tif ch := l.peek(); !isNumber(ch) {\n\t\t\t\tif isIdent(ch, false) {\n\t\t\t\t\tl.offset++\n\t\t\t\t\treturn -l.offset\n\t\t\t\t}\n\t\t\t\tif state == numberStateExpLead {\n\t\t\t\t\treturn -l.offset\n\t\t\t\t}\n\t\t\t\treturn l.offset\n\t\t\t}\n\t\t\tl.offset++\n\t\t\tstate = numberStateExp\n\t\tdefault:\n\t\t\tpanic(state)\n\t\t}\n\t}\n}\n\nfunc (l *lexer) validNumber() bool {\n\tch := l.peek()\n\tswitch ch {\n\tcase '+', '-':\n\t\tl.offset++\n\t\tch = l.peek()\n\t}\n\tstate := numberStateLead\n\tif ch == '.' {\n\t\tl.offset++\n\t\tch = l.peek()\n\t\tstate = numberStateFloat\n\t}\n\treturn isNumber(ch) && l.scanNumber(state) == len(l.source)\n}\n\nfunc (l *lexer) scanString(start int) (int, string) {\n\tvar decode bool\n\tvar controls int\n\tunquote := func(src string, quote bool) (string, error) {\n\t\tif !decode {\n\t\t\tif quote {\n\t\t\t\treturn src, nil\n\t\t\t}\n\t\t\treturn src[1 : len(src)-1], nil\n\t\t}\n\t\tvar buf []byte\n\t\tif !quote && controls == 0 {\n\t\t\tbuf = []byte(src)\n\t\t} else {\n\t\t\tbuf = quoteAndEscape(src, quote, controls)\n\t\t}\n\t\tif err := json.Unmarshal(buf, &src); err != nil {\n\t\t\treturn \"\", err\n\t\t}\n\t\treturn src, nil\n\t}\n\tfor i := l.offset; i < len(l.source); i++ {\n\t\tch := l.source[i]\n\t\tswitch ch {\n\t\tcase '\\\\':\n\t\t\tif i++; i >= len(l.source) {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tswitch l.source[i] {\n\t\t\tcase 'u':\n\t\t\t\tfor j := 1; j <= 4; j++ {\n\t\t\t\t\tif i+j >= len(l.source) || !isHex(l.source[i+j]) {\n\t\t\t\t\t\tl.offset = i + j\n\t\t\t\t\t\tl.token = l.source[i-1 : l.offset]\n\t\t\t\t\t\treturn tokInvalidEscapeSequence, \"\"\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\ti += 4\n\t\t\t\tfallthrough\n\t\t\tcase '\"', '/', '\\\\', 'b', 'f', 'n', 'r', 't':\n\t\t\t\tdecode = true\n\t\t\tcase '(':\n\t\t\t\tif !l.inString {\n\t\t\t\t\tl.inString = true\n\t\t\t\t\treturn tokStringStart, \"\"\n\t\t\t\t}\n\t\t\t\tif i == l.offset+1 {\n\t\t\t\t\tl.offset += 2\n\t\t\t\t\tl.inString = false\n\t\t\t\t\treturn tokStringQuery, \"\"\n\t\t\t\t}\n\t\t\t\tl.offset = i - 1\n\t\t\t\tl.token = l.source[start:l.offset]\n\t\t\t\tstr, err := unquote(l.token, true)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn tokInvalid, \"\"\n\t\t\t\t}\n\t\t\t\treturn tokString, str\n\t\t\tdefault:\n\t\t\t\tl.offset = i + 1\n\t\t\t\tl.token = l.source[l.offset-2 : l.offset]\n\t\t\t\treturn tokInvalidEscapeSequence, \"\"\n\t\t\t}\n\t\tcase '\"':\n\t\t\tif !l.inString {\n\t\t\t\tl.offset = i + 1\n\t\t\t\tl.token = l.source[start:l.offset]\n\t\t\t\tstr, err := unquote(l.token, false)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn tokInvalid, \"\"\n\t\t\t\t}\n\t\t\t\treturn tokString, str\n\t\t\t}\n\t\t\tif i > l.offset {\n\t\t\t\tl.offset = i\n\t\t\t\tl.token = l.source[start:l.offset]\n\t\t\t\tstr, err := unquote(l.token, true)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn tokInvalid, \"\"\n\t\t\t\t}\n\t\t\t\treturn tokString, str\n\t\t\t}\n\t\t\tl.inString = false\n\t\t\tl.offset = i + 1\n\t\t\treturn tokStringEnd, \"\"\n\t\tdefault:\n\t\t\tif !decode {\n\t\t\t\tdecode = ch > '~'\n\t\t\t}\n\t\t\tif ch < ' ' { // ref: unquoteBytes in encoding/json\n\t\t\t\tcontrols++\n\t\t\t}\n\t\t}\n\t}\n\tl.offset = len(l.source)\n\tl.token = \"\"\n\treturn tokUnterminatedString, \"\"\n}\n\nfunc quoteAndEscape(src string, quote bool, controls int) []byte {\n\tsize := len(src) + controls*5\n\tif quote {\n\t\tsize += 2\n\t}\n\tbuf := make([]byte, size)\n\tvar j int\n\tif quote {\n\t\tbuf[0] = '\"'\n\t\tbuf[len(buf)-1] = '\"'\n\t\tj++\n\t}\n\tfor i := 0; i < len(src); i++ {\n\t\tif ch := src[i]; ch < ' ' {\n\t\t\tconst hex = \"0123456789abcdef\"\n\t\t\tcopy(buf[j:], `\\u00`)\n\t\t\tbuf[j+4] = hex[ch>>4]\n\t\t\tbuf[j+5] = hex[ch&0xF]\n\t\t\tj += 6\n\t\t} else {\n\t\t\tbuf[j] = ch\n\t\t\tj++\n\t\t}\n\t}\n\treturn buf\n}\n\n// ParseError represents a description of a query parsing error.\ntype ParseError struct {\n\tOffset    int    // the error occurred after reading Offset bytes\n\tToken     string // the Token that caused the error (may be empty)\n\ttokenType int\n}\n\nfunc (err *ParseError) Error() string {\n\tswitch err.tokenType {\n\tcase eof:\n\t\treturn \"unexpected EOF\"\n\tcase tokInvalid:\n\t\treturn \"invalid token \" + jsonMarshal(err.Token)\n\tcase tokInvalidEscapeSequence:\n\t\treturn `invalid escape sequence \"` + err.Token + `\" in string literal`\n\tcase tokUnterminatedString:\n\t\treturn \"unterminated string literal\"\n\tdefault:\n\t\treturn \"unexpected token \" + jsonMarshal(err.Token)\n\t}\n}\n\nfunc (l *lexer) Error(string) {\n\toffset, token := l.offset, l.token\n\tif l.tokenType != eof && l.tokenType < utf8.RuneSelf {\n\t\ttoken = string(rune(l.tokenType))\n\t}\n\tl.err = &ParseError{offset, token, l.tokenType}\n}\n\nfunc isWhite(ch byte) bool {\n\tswitch ch {\n\tcase '\\t', '\\n', '\\r', ' ':\n\t\treturn true\n\tdefault:\n\t\treturn false\n\t}\n}\n\nfunc isIdent(ch byte, tail bool) bool {\n\treturn 'a' <= ch && ch <= 'z' ||\n\t\t'A' <= ch && ch <= 'Z' || ch == '_' ||\n\t\ttail && isNumber(ch)\n}\n\nfunc isHex(ch byte) bool {\n\treturn 'a' <= ch && ch <= 'f' ||\n\t\t'A' <= ch && ch <= 'F' ||\n\t\tisNumber(ch)\n}\n\nfunc isNumber(ch byte) bool {\n\treturn '0' <= ch && ch <= '9'\n}\n"
        },
        {
          "name": "module_loader.go",
          "type": "blob",
          "size": 4.1318359375,
          "content": "package gojq\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"io\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"strings\"\n)\n\n// ModuleLoader is the interface for loading modules.\n//\n// Implement following optional methods. Use [NewModuleLoader] to load local modules.\n//\n//\tLoadInitModules() ([]*Query, error)\n//\tLoadModule(string) (*Query, error)\n//\tLoadModuleWithMeta(string, map[string]any) (*Query, error)\n//\tLoadJSON(string) (any, error)\n//\tLoadJSONWithMeta(string, map[string]any) (any, error)\ntype ModuleLoader any\n\n// NewModuleLoader creates a new [ModuleLoader] loading local modules in the paths.\n// Note that user can load modules outside the paths using \"search\" path of metadata.\n// Empty paths are ignored, so specify \".\" for the current working directory.\nfunc NewModuleLoader(paths []string) ModuleLoader {\n\tps := make([]string, 0, len(paths))\n\tfor _, path := range paths {\n\t\tif path = resolvePath(path, \"\"); path != \"\" {\n\t\t\tps = append(ps, path)\n\t\t}\n\t}\n\treturn &moduleLoader{ps}\n}\n\ntype moduleLoader struct {\n\tpaths []string\n}\n\nfunc (l *moduleLoader) LoadInitModules() ([]*Query, error) {\n\tvar qs []*Query\n\tfor _, path := range l.paths {\n\t\tif filepath.Base(path) != \".jq\" {\n\t\t\tcontinue\n\t\t}\n\t\tfi, err := os.Stat(path)\n\t\tif err != nil {\n\t\t\tif os.IsNotExist(err) {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\treturn nil, err\n\t\t}\n\t\tif fi.IsDir() {\n\t\t\tcontinue\n\t\t}\n\t\tcnt, err := os.ReadFile(path)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tq, err := parseModule(string(cnt), filepath.Dir(path))\n\t\tif err != nil {\n\t\t\treturn nil, &queryParseError{path, string(cnt), err}\n\t\t}\n\t\tqs = append(qs, q)\n\t}\n\treturn qs, nil\n}\n\nfunc (l *moduleLoader) LoadModuleWithMeta(name string, meta map[string]any) (*Query, error) {\n\tpath, err := l.lookupModule(name, \".jq\", meta)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tcnt, err := os.ReadFile(path)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tq, err := parseModule(string(cnt), filepath.Dir(path))\n\tif err != nil {\n\t\treturn nil, &queryParseError{path, string(cnt), err}\n\t}\n\treturn q, nil\n}\n\nfunc (l *moduleLoader) LoadJSONWithMeta(name string, meta map[string]any) (any, error) {\n\tpath, err := l.lookupModule(name, \".json\", meta)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tf, err := os.Open(path)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer f.Close()\n\tvals := []any{}\n\tdec := json.NewDecoder(f)\n\tdec.UseNumber()\n\tfor {\n\t\tvar val any\n\t\tif err := dec.Decode(&val); err != nil {\n\t\t\tif err == io.EOF {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tif _, err := f.Seek(0, io.SeekStart); err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\tcnt, er := io.ReadAll(f)\n\t\t\tif er != nil {\n\t\t\t\treturn nil, er\n\t\t\t}\n\t\t\treturn nil, &jsonParseError{path, string(cnt), err}\n\t\t}\n\t\tvals = append(vals, val)\n\t}\n\treturn vals, nil\n}\n\nfunc (l *moduleLoader) lookupModule(name, extension string, meta map[string]any) (string, error) {\n\tpaths := l.paths\n\tif path, ok := meta[\"search\"].(string); ok {\n\t\tif path = resolvePath(path, \"\"); path != \"\" {\n\t\t\tpaths = append([]string{path}, paths...)\n\t\t}\n\t}\n\tfor _, base := range paths {\n\t\tpath := filepath.Join(base, name+extension)\n\t\tif _, err := os.Stat(path); err == nil {\n\t\t\treturn path, err\n\t\t}\n\t\tpath = filepath.Join(base, name, filepath.Base(name)+extension)\n\t\tif _, err := os.Stat(path); err == nil {\n\t\t\treturn path, err\n\t\t}\n\t}\n\treturn \"\", fmt.Errorf(\"module not found: %q\", name)\n}\n\nfunc parseModule(cnt, dir string) (*Query, error) {\n\tq, err := Parse(cnt)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tfor _, i := range q.Imports {\n\t\tif i.Meta != nil {\n\t\t\tfor _, e := range i.Meta.KeyVals {\n\t\t\t\tif e.Key == \"search\" || e.KeyString == \"search\" {\n\t\t\t\t\tif path, ok := e.Val.toString(); ok {\n\t\t\t\t\t\tif path = resolvePath(path, dir); path != \"\" {\n\t\t\t\t\t\t\te.Val.Str = path\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\te.Val.Null = true\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn q, nil\n}\n\nfunc resolvePath(path, dir string) string {\n\tswitch {\n\tcase filepath.IsAbs(path):\n\t\treturn path\n\tcase strings.HasPrefix(path, \"~/\"):\n\t\tdir, err := os.UserHomeDir()\n\t\tif err != nil {\n\t\t\treturn \"\"\n\t\t}\n\t\treturn filepath.Join(dir, path[2:])\n\tcase strings.HasPrefix(path, \"$ORIGIN/\"):\n\t\texe, err := os.Executable()\n\t\tif err != nil {\n\t\t\treturn \"\"\n\t\t}\n\t\texe, err = filepath.EvalSymlinks(exe)\n\t\tif err != nil {\n\t\t\treturn \"\"\n\t\t}\n\t\treturn filepath.Join(filepath.Dir(exe), path[8:])\n\tdefault:\n\t\treturn filepath.Join(dir, path)\n\t}\n}\n"
        },
        {
          "name": "normalize.go",
          "type": "blob",
          "size": 1.4697265625,
          "content": "package gojq\n\nimport (\n\t\"encoding/json\"\n\t\"math\"\n\t\"math/big\"\n\t\"strings\"\n)\n\nfunc normalizeNumber(v json.Number) any {\n\tif i, err := v.Int64(); err == nil && math.MinInt <= i && i <= math.MaxInt {\n\t\treturn int(i)\n\t}\n\tif strings.ContainsAny(v.String(), \".eE\") {\n\t\tif f, err := v.Float64(); err == nil {\n\t\t\treturn f\n\t\t}\n\t}\n\tif bi, ok := new(big.Int).SetString(v.String(), 10); ok {\n\t\treturn bi\n\t}\n\tif strings.HasPrefix(v.String(), \"-\") {\n\t\treturn math.Inf(-1)\n\t}\n\treturn math.Inf(1)\n}\n\nfunc normalizeNumbers(v any) any {\n\tswitch v := v.(type) {\n\tcase json.Number:\n\t\treturn normalizeNumber(v)\n\tcase *big.Int:\n\t\tif v.IsInt64() {\n\t\t\tif i := v.Int64(); math.MinInt <= i && i <= math.MaxInt {\n\t\t\t\treturn int(i)\n\t\t\t}\n\t\t}\n\t\treturn v\n\tcase int64:\n\t\tif math.MinInt <= v && v <= math.MaxInt {\n\t\t\treturn int(v)\n\t\t}\n\t\treturn big.NewInt(v)\n\tcase int32:\n\t\treturn int(v)\n\tcase int16:\n\t\treturn int(v)\n\tcase int8:\n\t\treturn int(v)\n\tcase uint:\n\t\tif v <= math.MaxInt {\n\t\t\treturn int(v)\n\t\t}\n\t\treturn new(big.Int).SetUint64(uint64(v))\n\tcase uint64:\n\t\tif v <= math.MaxInt {\n\t\t\treturn int(v)\n\t\t}\n\t\treturn new(big.Int).SetUint64(v)\n\tcase uint32:\n\t\tif uint64(v) <= math.MaxInt {\n\t\t\treturn int(v)\n\t\t}\n\t\treturn new(big.Int).SetUint64(uint64(v))\n\tcase uint16:\n\t\treturn int(v)\n\tcase uint8:\n\t\treturn int(v)\n\tcase float32:\n\t\treturn float64(v)\n\tcase []any:\n\t\tfor i, x := range v {\n\t\t\tv[i] = normalizeNumbers(x)\n\t\t}\n\t\treturn v\n\tcase map[string]any:\n\t\tfor k, x := range v {\n\t\t\tv[k] = normalizeNumbers(x)\n\t\t}\n\t\treturn v\n\tdefault:\n\t\treturn v\n\t}\n}\n"
        },
        {
          "name": "operator.go",
          "type": "blob",
          "size": 9.943359375,
          "content": "package gojq\n\nimport (\n\t\"math\"\n\t\"math/big\"\n\t\"strings\"\n)\n\n// Operator ...\ntype Operator int\n\n// Operators ...\nconst (\n\tOpPipe Operator = iota + 1\n\tOpComma\n\tOpAdd\n\tOpSub\n\tOpMul\n\tOpDiv\n\tOpMod\n\tOpEq\n\tOpNe\n\tOpGt\n\tOpLt\n\tOpGe\n\tOpLe\n\tOpAnd\n\tOpOr\n\tOpAlt\n\tOpAssign\n\tOpModify\n\tOpUpdateAdd\n\tOpUpdateSub\n\tOpUpdateMul\n\tOpUpdateDiv\n\tOpUpdateMod\n\tOpUpdateAlt\n)\n\n// String implements [fmt.Stringer].\nfunc (op Operator) String() string {\n\tswitch op {\n\tcase OpPipe:\n\t\treturn \"|\"\n\tcase OpComma:\n\t\treturn \",\"\n\tcase OpAdd:\n\t\treturn \"+\"\n\tcase OpSub:\n\t\treturn \"-\"\n\tcase OpMul:\n\t\treturn \"*\"\n\tcase OpDiv:\n\t\treturn \"/\"\n\tcase OpMod:\n\t\treturn \"%\"\n\tcase OpEq:\n\t\treturn \"==\"\n\tcase OpNe:\n\t\treturn \"!=\"\n\tcase OpGt:\n\t\treturn \">\"\n\tcase OpLt:\n\t\treturn \"<\"\n\tcase OpGe:\n\t\treturn \">=\"\n\tcase OpLe:\n\t\treturn \"<=\"\n\tcase OpAnd:\n\t\treturn \"and\"\n\tcase OpOr:\n\t\treturn \"or\"\n\tcase OpAlt:\n\t\treturn \"//\"\n\tcase OpAssign:\n\t\treturn \"=\"\n\tcase OpModify:\n\t\treturn \"|=\"\n\tcase OpUpdateAdd:\n\t\treturn \"+=\"\n\tcase OpUpdateSub:\n\t\treturn \"-=\"\n\tcase OpUpdateMul:\n\t\treturn \"*=\"\n\tcase OpUpdateDiv:\n\t\treturn \"/=\"\n\tcase OpUpdateMod:\n\t\treturn \"%=\"\n\tcase OpUpdateAlt:\n\t\treturn \"//=\"\n\tdefault:\n\t\tpanic(op)\n\t}\n}\n\n// GoString implements [fmt.GoStringer].\nfunc (op Operator) GoString() (str string) {\n\tdefer func() { str = \"gojq.\" + str }()\n\tswitch op {\n\tcase Operator(0):\n\t\treturn \"Operator(0)\"\n\tcase OpPipe:\n\t\treturn \"OpPipe\"\n\tcase OpComma:\n\t\treturn \"OpComma\"\n\tcase OpAdd:\n\t\treturn \"OpAdd\"\n\tcase OpSub:\n\t\treturn \"OpSub\"\n\tcase OpMul:\n\t\treturn \"OpMul\"\n\tcase OpDiv:\n\t\treturn \"OpDiv\"\n\tcase OpMod:\n\t\treturn \"OpMod\"\n\tcase OpEq:\n\t\treturn \"OpEq\"\n\tcase OpNe:\n\t\treturn \"OpNe\"\n\tcase OpGt:\n\t\treturn \"OpGt\"\n\tcase OpLt:\n\t\treturn \"OpLt\"\n\tcase OpGe:\n\t\treturn \"OpGe\"\n\tcase OpLe:\n\t\treturn \"OpLe\"\n\tcase OpAnd:\n\t\treturn \"OpAnd\"\n\tcase OpOr:\n\t\treturn \"OpOr\"\n\tcase OpAlt:\n\t\treturn \"OpAlt\"\n\tcase OpAssign:\n\t\treturn \"OpAssign\"\n\tcase OpModify:\n\t\treturn \"OpModify\"\n\tcase OpUpdateAdd:\n\t\treturn \"OpUpdateAdd\"\n\tcase OpUpdateSub:\n\t\treturn \"OpUpdateSub\"\n\tcase OpUpdateMul:\n\t\treturn \"OpUpdateMul\"\n\tcase OpUpdateDiv:\n\t\treturn \"OpUpdateDiv\"\n\tcase OpUpdateMod:\n\t\treturn \"OpUpdateMod\"\n\tcase OpUpdateAlt:\n\t\treturn \"OpUpdateAlt\"\n\tdefault:\n\t\tpanic(op)\n\t}\n}\n\nfunc (op Operator) getFunc() string {\n\tswitch op {\n\tcase OpPipe:\n\t\tpanic(\"unreachable\")\n\tcase OpComma:\n\t\tpanic(\"unreachable\")\n\tcase OpAdd:\n\t\treturn \"_add\"\n\tcase OpSub:\n\t\treturn \"_subtract\"\n\tcase OpMul:\n\t\treturn \"_multiply\"\n\tcase OpDiv:\n\t\treturn \"_divide\"\n\tcase OpMod:\n\t\treturn \"_modulo\"\n\tcase OpEq:\n\t\treturn \"_equal\"\n\tcase OpNe:\n\t\treturn \"_notequal\"\n\tcase OpGt:\n\t\treturn \"_greater\"\n\tcase OpLt:\n\t\treturn \"_less\"\n\tcase OpGe:\n\t\treturn \"_greatereq\"\n\tcase OpLe:\n\t\treturn \"_lesseq\"\n\tcase OpAnd:\n\t\tpanic(\"unreachable\")\n\tcase OpOr:\n\t\tpanic(\"unreachable\")\n\tcase OpAlt:\n\t\tpanic(\"unreachable\")\n\tcase OpAssign:\n\t\treturn \"_assign\"\n\tcase OpModify:\n\t\treturn \"_modify\"\n\tcase OpUpdateAdd:\n\t\treturn \"_add\"\n\tcase OpUpdateSub:\n\t\treturn \"_subtract\"\n\tcase OpUpdateMul:\n\t\treturn \"_multiply\"\n\tcase OpUpdateDiv:\n\t\treturn \"_divide\"\n\tcase OpUpdateMod:\n\t\treturn \"_modulo\"\n\tcase OpUpdateAlt:\n\t\treturn \"_alternative\"\n\tdefault:\n\t\tpanic(op)\n\t}\n}\n\nfunc binopTypeSwitch(\n\tl, r any,\n\tcallbackInts func(_, _ int) any,\n\tcallbackFloats func(_, _ float64) any,\n\tcallbackBigInts func(_, _ *big.Int) any,\n\tcallbackStrings func(_, _ string) any,\n\tcallbackArrays func(_, _ []any) any,\n\tcallbackMaps func(_, _ map[string]any) any,\n\tfallback func(_, _ any) any) any {\n\tswitch l := l.(type) {\n\tcase int:\n\t\tswitch r := r.(type) {\n\t\tcase int:\n\t\t\treturn callbackInts(l, r)\n\t\tcase float64:\n\t\t\treturn callbackFloats(float64(l), r)\n\t\tcase *big.Int:\n\t\t\treturn callbackBigInts(big.NewInt(int64(l)), r)\n\t\tdefault:\n\t\t\treturn fallback(l, r)\n\t\t}\n\tcase float64:\n\t\tswitch r := r.(type) {\n\t\tcase int:\n\t\t\treturn callbackFloats(l, float64(r))\n\t\tcase float64:\n\t\t\treturn callbackFloats(l, r)\n\t\tcase *big.Int:\n\t\t\treturn callbackFloats(l, bigToFloat(r))\n\t\tdefault:\n\t\t\treturn fallback(l, r)\n\t\t}\n\tcase *big.Int:\n\t\tswitch r := r.(type) {\n\t\tcase int:\n\t\t\treturn callbackBigInts(l, big.NewInt(int64(r)))\n\t\tcase float64:\n\t\t\treturn callbackFloats(bigToFloat(l), r)\n\t\tcase *big.Int:\n\t\t\treturn callbackBigInts(l, r)\n\t\tdefault:\n\t\t\treturn fallback(l, r)\n\t\t}\n\tcase string:\n\t\tswitch r := r.(type) {\n\t\tcase string:\n\t\t\treturn callbackStrings(l, r)\n\t\tdefault:\n\t\t\treturn fallback(l, r)\n\t\t}\n\tcase []any:\n\t\tswitch r := r.(type) {\n\t\tcase []any:\n\t\t\treturn callbackArrays(l, r)\n\t\tdefault:\n\t\t\treturn fallback(l, r)\n\t\t}\n\tcase map[string]any:\n\t\tswitch r := r.(type) {\n\t\tcase map[string]any:\n\t\t\treturn callbackMaps(l, r)\n\t\tdefault:\n\t\t\treturn fallback(l, r)\n\t\t}\n\tdefault:\n\t\treturn fallback(l, r)\n\t}\n}\n\nfunc funcOpPlus(v any) any {\n\tswitch v := v.(type) {\n\tcase int:\n\t\treturn v\n\tcase float64:\n\t\treturn v\n\tcase *big.Int:\n\t\treturn v\n\tdefault:\n\t\treturn &unaryTypeError{\"plus\", v}\n\t}\n}\n\nfunc funcOpNegate(v any) any {\n\tswitch v := v.(type) {\n\tcase int:\n\t\treturn -v\n\tcase float64:\n\t\treturn -v\n\tcase *big.Int:\n\t\treturn new(big.Int).Neg(v)\n\tdefault:\n\t\treturn &unaryTypeError{\"negate\", v}\n\t}\n}\n\nfunc funcOpAdd(_, l, r any) any {\n\treturn binopTypeSwitch(l, r,\n\t\tfunc(l, r int) any {\n\t\t\tif v := l + r; (v >= l) == (r >= 0) {\n\t\t\t\treturn v\n\t\t\t}\n\t\t\tx, y := big.NewInt(int64(l)), big.NewInt(int64(r))\n\t\t\treturn x.Add(x, y)\n\t\t},\n\t\tfunc(l, r float64) any { return l + r },\n\t\tfunc(l, r *big.Int) any { return new(big.Int).Add(l, r) },\n\t\tfunc(l, r string) any { return l + r },\n\t\tfunc(l, r []any) any {\n\t\t\tif len(l) == 0 {\n\t\t\t\treturn r\n\t\t\t}\n\t\t\tif len(r) == 0 {\n\t\t\t\treturn l\n\t\t\t}\n\t\t\tv := make([]any, len(l)+len(r))\n\t\t\tcopy(v, l)\n\t\t\tcopy(v[len(l):], r)\n\t\t\treturn v\n\t\t},\n\t\tfunc(l, r map[string]any) any {\n\t\t\tif len(l) == 0 {\n\t\t\t\treturn r\n\t\t\t}\n\t\t\tif len(r) == 0 {\n\t\t\t\treturn l\n\t\t\t}\n\t\t\tm := make(map[string]any, len(l)+len(r))\n\t\t\tfor k, v := range l {\n\t\t\t\tm[k] = v\n\t\t\t}\n\t\t\tfor k, v := range r {\n\t\t\t\tm[k] = v\n\t\t\t}\n\t\t\treturn m\n\t\t},\n\t\tfunc(l, r any) any {\n\t\t\tif l == nil {\n\t\t\t\treturn r\n\t\t\t}\n\t\t\tif r == nil {\n\t\t\t\treturn l\n\t\t\t}\n\t\t\treturn &binopTypeError{\"add\", l, r}\n\t\t},\n\t)\n}\n\nfunc funcOpSub(_, l, r any) any {\n\treturn binopTypeSwitch(l, r,\n\t\tfunc(l, r int) any {\n\t\t\tif v := l - r; (v <= l) == (r >= 0) {\n\t\t\t\treturn v\n\t\t\t}\n\t\t\tx, y := big.NewInt(int64(l)), big.NewInt(int64(r))\n\t\t\treturn x.Sub(x, y)\n\t\t},\n\t\tfunc(l, r float64) any { return l - r },\n\t\tfunc(l, r *big.Int) any { return new(big.Int).Sub(l, r) },\n\t\tfunc(l, r string) any { return &binopTypeError{\"subtract\", l, r} },\n\t\tfunc(l, r []any) any {\n\t\t\tv := make([]any, 0, len(l))\n\t\tL:\n\t\t\tfor _, l := range l {\n\t\t\t\tfor _, r := range r {\n\t\t\t\t\tif Compare(l, r) == 0 {\n\t\t\t\t\t\tcontinue L\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tv = append(v, l)\n\t\t\t}\n\t\t\treturn v\n\t\t},\n\t\tfunc(l, r map[string]any) any { return &binopTypeError{\"subtract\", l, r} },\n\t\tfunc(l, r any) any { return &binopTypeError{\"subtract\", l, r} },\n\t)\n}\n\nfunc funcOpMul(_, l, r any) any {\n\treturn binopTypeSwitch(l, r,\n\t\tfunc(l, r int) any {\n\t\t\tif v := l * r; r == 0 || v/r == l {\n\t\t\t\treturn v\n\t\t\t}\n\t\t\tx, y := big.NewInt(int64(l)), big.NewInt(int64(r))\n\t\t\treturn x.Mul(x, y)\n\t\t},\n\t\tfunc(l, r float64) any { return l * r },\n\t\tfunc(l, r *big.Int) any { return new(big.Int).Mul(l, r) },\n\t\tfunc(l, r string) any { return &binopTypeError{\"multiply\", l, r} },\n\t\tfunc(l, r []any) any { return &binopTypeError{\"multiply\", l, r} },\n\t\tdeepMergeObjects,\n\t\tfunc(l, r any) any {\n\t\t\tif l, ok := l.(string); ok {\n\t\t\t\tif r, ok := toFloat(r); ok {\n\t\t\t\t\treturn repeatString(l, r)\n\t\t\t\t}\n\t\t\t}\n\t\t\tif r, ok := r.(string); ok {\n\t\t\t\tif l, ok := toFloat(l); ok {\n\t\t\t\t\treturn repeatString(r, l)\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn &binopTypeError{\"multiply\", l, r}\n\t\t},\n\t)\n}\n\nfunc deepMergeObjects(l, r map[string]any) any {\n\tm := make(map[string]any, len(l)+len(r))\n\tfor k, v := range l {\n\t\tm[k] = v\n\t}\n\tfor k, v := range r {\n\t\tif mk, ok := m[k]; ok {\n\t\t\tif mk, ok := mk.(map[string]any); ok {\n\t\t\t\tif w, ok := v.(map[string]any); ok {\n\t\t\t\t\tv = deepMergeObjects(mk, w)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tm[k] = v\n\t}\n\treturn m\n}\n\nfunc repeatString(s string, n float64) any {\n\tif n < 0.0 || len(s) > 0 && n > float64(0x10000000/len(s)) || math.IsNaN(n) {\n\t\treturn nil\n\t}\n\tif s == \"\" {\n\t\treturn \"\"\n\t}\n\treturn strings.Repeat(s, int(n))\n}\n\nfunc funcOpDiv(_, l, r any) any {\n\treturn binopTypeSwitch(l, r,\n\t\tfunc(l, r int) any {\n\t\t\tif r == 0 {\n\t\t\t\treturn &zeroDivisionError{l, r}\n\t\t\t}\n\t\t\tif l%r == 0 {\n\t\t\t\treturn l / r\n\t\t\t}\n\t\t\treturn float64(l) / float64(r)\n\t\t},\n\t\tfunc(l, r float64) any {\n\t\t\tif r == 0.0 {\n\t\t\t\treturn &zeroDivisionError{l, r}\n\t\t\t}\n\t\t\treturn l / r\n\t\t},\n\t\tfunc(l, r *big.Int) any {\n\t\t\tif r.Sign() == 0 {\n\t\t\t\treturn &zeroDivisionError{l, r}\n\t\t\t}\n\t\t\td, m := new(big.Int).DivMod(l, r, new(big.Int))\n\t\t\tif m.Sign() == 0 {\n\t\t\t\treturn d\n\t\t\t}\n\t\t\treturn bigToFloat(l) / bigToFloat(r)\n\t\t},\n\t\tfunc(l, r string) any {\n\t\t\tif l == \"\" {\n\t\t\t\treturn []any{}\n\t\t\t}\n\t\t\txs := strings.Split(l, r)\n\t\t\tvs := make([]any, len(xs))\n\t\t\tfor i, x := range xs {\n\t\t\t\tvs[i] = x\n\t\t\t}\n\t\t\treturn vs\n\t\t},\n\t\tfunc(l, r []any) any { return &binopTypeError{\"divide\", l, r} },\n\t\tfunc(l, r map[string]any) any { return &binopTypeError{\"divide\", l, r} },\n\t\tfunc(l, r any) any { return &binopTypeError{\"divide\", l, r} },\n\t)\n}\n\nfunc funcOpMod(_, l, r any) any {\n\treturn binopTypeSwitch(l, r,\n\t\tfunc(l, r int) any {\n\t\t\tif r == 0 {\n\t\t\t\treturn &zeroModuloError{l, r}\n\t\t\t}\n\t\t\treturn l % r\n\t\t},\n\t\tfunc(l, r float64) any {\n\t\t\tri := floatToInt(r)\n\t\t\tif ri == 0 {\n\t\t\t\treturn &zeroModuloError{l, r}\n\t\t\t}\n\t\t\tif math.IsNaN(l) || math.IsNaN(r) {\n\t\t\t\treturn math.NaN()\n\t\t\t}\n\t\t\treturn floatToInt(l) % ri\n\t\t},\n\t\tfunc(l, r *big.Int) any {\n\t\t\tif r.Sign() == 0 {\n\t\t\t\treturn &zeroModuloError{l, r}\n\t\t\t}\n\t\t\treturn new(big.Int).Rem(l, r)\n\t\t},\n\t\tfunc(l, r string) any { return &binopTypeError{\"modulo\", l, r} },\n\t\tfunc(l, r []any) any { return &binopTypeError{\"modulo\", l, r} },\n\t\tfunc(l, r map[string]any) any { return &binopTypeError{\"modulo\", l, r} },\n\t\tfunc(l, r any) any { return &binopTypeError{\"modulo\", l, r} },\n\t)\n}\n\nfunc funcOpAlt(_, l, r any) any {\n\tif l == nil || l == false {\n\t\treturn r\n\t}\n\treturn l\n}\n\nfunc funcOpEq(_, l, r any) any {\n\treturn Compare(l, r) == 0\n}\n\nfunc funcOpNe(_, l, r any) any {\n\treturn Compare(l, r) != 0\n}\n\nfunc funcOpGt(_, l, r any) any {\n\treturn Compare(l, r) > 0\n}\n\nfunc funcOpLt(_, l, r any) any {\n\treturn Compare(l, r) < 0\n}\n\nfunc funcOpGe(_, l, r any) any {\n\treturn Compare(l, r) >= 0\n}\n\nfunc funcOpLe(_, l, r any) any {\n\treturn Compare(l, r) <= 0\n}\n"
        },
        {
          "name": "option.go",
          "type": "blob",
          "size": 3.6943359375,
          "content": "package gojq\n\nimport \"fmt\"\n\n// CompilerOption is a compiler option.\ntype CompilerOption func(*compiler)\n\n// WithModuleLoader is a compiler option for module loader.\n// If you want to load modules from the filesystem, use [NewModuleLoader].\nfunc WithModuleLoader(moduleLoader ModuleLoader) CompilerOption {\n\treturn func(c *compiler) {\n\t\tc.moduleLoader = moduleLoader\n\t}\n}\n\n// WithEnvironLoader is a compiler option for environment variables loader.\n// The OS environment variables are not accessible by default due to security\n// reasons. You can specify [os.Environ] as argument if you allow to access.\nfunc WithEnvironLoader(environLoader func() []string) CompilerOption {\n\treturn func(c *compiler) {\n\t\tc.environLoader = environLoader\n\t}\n}\n\n// WithVariables is a compiler option for variable names. The variables can be\n// used in the query. You have to give the values to [*Code.Run] in the same order.\nfunc WithVariables(variables []string) CompilerOption {\n\treturn func(c *compiler) {\n\t\tc.variables = variables\n\t}\n}\n\n// WithFunction is a compiler option for adding a custom internal function.\n// Specify the minimum and maximum count of the function arguments. These\n// values should satisfy 0 <= minarity <= maxarity <= 30, otherwise panics.\n// On handling numbers, you should take account to int, float64 and *big.Int.\n// These are the number types you are allowed to return, so do not return int64.\n// Refer to [ValueError] to return a value error just like built-in error\n// function. If you want to emit multiple values, call the empty function,\n// accept a filter for its argument, or call another built-in function, then\n// use LoadInitModules of the module loader.\nfunc WithFunction(name string, minarity, maxarity int, f func(any, []any) any) CompilerOption {\n\treturn withFunction(name, minarity, maxarity, false, f)\n}\n\n// WithIterFunction is a compiler option for adding a custom iterator function.\n// This is like the [WithFunction] option, but you can add a function which\n// returns an Iter to emit multiple values. You cannot define both iterator and\n// non-iterator functions of the same name (with possibly different arities).\n// See also [NewIter], which can be used to convert values or an error to an Iter.\nfunc WithIterFunction(name string, minarity, maxarity int, f func(any, []any) Iter) CompilerOption {\n\treturn withFunction(name, minarity, maxarity, true,\n\t\tfunc(v any, args []any) any {\n\t\t\treturn f(v, args)\n\t\t},\n\t)\n}\n\nfunc withFunction(name string, minarity, maxarity int, iter bool, f func(any, []any) any) CompilerOption {\n\tif !(0 <= minarity && minarity <= maxarity && maxarity <= 30) {\n\t\tpanic(fmt.Sprintf(\"invalid arity for %q: %d, %d\", name, minarity, maxarity))\n\t}\n\targcount := 1<<(maxarity+1) - 1<<minarity\n\treturn func(c *compiler) {\n\t\tif c.customFuncs == nil {\n\t\t\tc.customFuncs = make(map[string]function)\n\t\t}\n\t\tif fn, ok := c.customFuncs[name]; ok {\n\t\t\tif fn.iter != iter {\n\t\t\t\tpanic(fmt.Sprintf(\"cannot define both iterator and non-iterator functions for %q\", name))\n\t\t\t}\n\t\t\tc.customFuncs[name] = function{\n\t\t\t\targcount | fn.argcount, iter,\n\t\t\t\tfunc(x any, xs []any) any {\n\t\t\t\t\tif argcount&(1<<len(xs)) != 0 {\n\t\t\t\t\t\treturn f(x, xs)\n\t\t\t\t\t}\n\t\t\t\t\treturn fn.callback(x, xs)\n\t\t\t\t},\n\t\t\t}\n\t\t} else {\n\t\t\tc.customFuncs[name] = function{argcount, iter, f}\n\t\t}\n\t}\n}\n\n// WithInputIter is a compiler option for input iterator used by input(s)/0.\n// Note that input and inputs functions are not allowed by default. We have\n// to distinguish the query input and the values for input(s) functions. For\n// example, consider using inputs with --null-input. If you want to allow\n// input(s) functions, create an [Iter] and use WithInputIter option.\nfunc WithInputIter(inputIter Iter) CompilerOption {\n\treturn func(c *compiler) {\n\t\tc.inputIter = inputIter\n\t}\n}\n"
        },
        {
          "name": "option_environ_loader_test.go",
          "type": "blob",
          "size": 0.5390625,
          "content": "package gojq_test\n\nimport (\n\t\"fmt\"\n\t\"log\"\n\n\t\"github.com/itchyny/gojq\"\n)\n\nfunc ExampleWithEnvironLoader() {\n\tquery, err := gojq.Parse(\"env | keys[]\")\n\tif err != nil {\n\t\tlog.Fatalln(err)\n\t}\n\tcode, err := gojq.Compile(\n\t\tquery,\n\t\tgojq.WithEnvironLoader(func() []string {\n\t\t\treturn []string{\"foo=42\", \"bar=128\"}\n\t\t}),\n\t)\n\tif err != nil {\n\t\tlog.Fatalln(err)\n\t}\n\titer := code.Run(nil)\n\tfor {\n\t\tv, ok := iter.Next()\n\t\tif !ok {\n\t\t\tbreak\n\t\t}\n\t\tif err, ok := v.(error); ok {\n\t\t\tlog.Fatalln(err)\n\t\t}\n\t\tfmt.Printf(\"%#v\\n\", v)\n\t}\n\n\t// Output:\n\t// \"bar\"\n\t// \"foo\"\n}\n"
        },
        {
          "name": "option_function_test.go",
          "type": "blob",
          "size": 1.189453125,
          "content": "package gojq_test\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"log\"\n\t\"math/big\"\n\t\"strconv\"\n\n\t\"github.com/itchyny/gojq\"\n)\n\nfunc toFloat(x any) (float64, bool) {\n\tswitch x := x.(type) {\n\tcase int:\n\t\treturn float64(x), true\n\tcase float64:\n\t\treturn x, true\n\tcase *big.Int:\n\t\tf, err := strconv.ParseFloat(x.String(), 64)\n\t\treturn f, err == nil\n\tdefault:\n\t\treturn 0.0, false\n\t}\n}\n\nfunc ExampleWithFunction() {\n\tquery, err := gojq.Parse(\".[] | f | f(3)\")\n\tif err != nil {\n\t\tlog.Fatalln(err)\n\t}\n\tcode, err := gojq.Compile(\n\t\tquery,\n\t\tgojq.WithFunction(\"f\", 0, 1, func(x any, xs []any) any {\n\t\t\tif x, ok := toFloat(x); ok {\n\t\t\t\tif len(xs) == 1 {\n\t\t\t\t\tif y, ok := toFloat(xs[0]); ok {\n\t\t\t\t\t\tx *= y\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn fmt.Errorf(\"f cannot be applied to: %v, %v\", x, xs)\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tx += 2\n\t\t\t\t}\n\t\t\t\treturn x\n\t\t\t}\n\t\t\treturn fmt.Errorf(\"f cannot be applied to: %v, %v\", x, xs)\n\t\t}),\n\t)\n\tif err != nil {\n\t\tlog.Fatalln(err)\n\t}\n\tinput := []any{0, 1, 2.5, json.Number(\"10000000000000000000000000000000000000000\")}\n\titer := code.Run(input)\n\tfor {\n\t\tv, ok := iter.Next()\n\t\tif !ok {\n\t\t\tbreak\n\t\t}\n\t\tif err, ok := v.(error); ok {\n\t\t\tlog.Fatalln(err)\n\t\t}\n\t\tfmt.Printf(\"%#v\\n\", v)\n\t}\n\n\t// Output:\n\t// 6\n\t// 9\n\t// 13.5\n\t// 3e+40\n}\n"
        },
        {
          "name": "option_input_iter_test.go",
          "type": "blob",
          "size": 0.50390625,
          "content": "package gojq_test\n\nimport (\n\t\"fmt\"\n\t\"log\"\n\n\t\"github.com/itchyny/gojq\"\n)\n\nfunc ExampleWithInputIter() {\n\tquery, err := gojq.Parse(\"reduce inputs as $x (0; . + $x)\")\n\tif err != nil {\n\t\tlog.Fatalln(err)\n\t}\n\tcode, err := gojq.Compile(\n\t\tquery,\n\t\tgojq.WithInputIter(gojq.NewIter(1, 2, 3, 4, 5)),\n\t)\n\tif err != nil {\n\t\tlog.Fatalln(err)\n\t}\n\titer := code.Run(nil)\n\tfor {\n\t\tv, ok := iter.Next()\n\t\tif !ok {\n\t\t\tbreak\n\t\t}\n\t\tif err, ok := v.(error); ok {\n\t\t\tlog.Fatalln(err)\n\t\t}\n\t\tfmt.Printf(\"%#v\\n\", v)\n\t}\n\n\t// Output:\n\t// 15\n}\n"
        },
        {
          "name": "option_iter_function_test.go",
          "type": "blob",
          "size": 0.9384765625,
          "content": "package gojq_test\n\nimport (\n\t\"fmt\"\n\t\"log\"\n\n\t\"github.com/itchyny/gojq\"\n)\n\n// Implementation of range/2 using WithIterFunction option.\ntype rangeIter struct {\n\tvalue, max int\n}\n\nfunc (iter *rangeIter) Next() (any, bool) {\n\tif iter.value >= iter.max {\n\t\treturn nil, false\n\t}\n\tv := iter.value\n\titer.value++\n\treturn v, true\n}\n\nfunc ExampleWithIterFunction() {\n\tquery, err := gojq.Parse(\"f(3; 7)\")\n\tif err != nil {\n\t\tlog.Fatalln(err)\n\t}\n\tcode, err := gojq.Compile(\n\t\tquery,\n\t\tgojq.WithIterFunction(\"f\", 2, 2, func(_ any, xs []any) gojq.Iter {\n\t\t\tif x, ok := xs[0].(int); ok {\n\t\t\t\tif y, ok := xs[1].(int); ok {\n\t\t\t\t\treturn &rangeIter{x, y}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn gojq.NewIter(fmt.Errorf(\"f cannot be applied to: %v\", xs))\n\t\t}),\n\t)\n\tif err != nil {\n\t\tlog.Fatalln(err)\n\t}\n\titer := code.Run(nil)\n\tfor {\n\t\tv, ok := iter.Next()\n\t\tif !ok {\n\t\t\tbreak\n\t\t}\n\t\tif err, ok := v.(error); ok {\n\t\t\tlog.Fatalln(err)\n\t\t}\n\t\tfmt.Printf(\"%#v\\n\", v)\n\t}\n\n\t// Output:\n\t// 3\n\t// 4\n\t// 5\n\t// 6\n}\n"
        },
        {
          "name": "option_module_loader_test.go",
          "type": "blob",
          "size": 0.931640625,
          "content": "package gojq_test\n\nimport (\n\t\"fmt\"\n\t\"log\"\n\n\t\"github.com/itchyny/gojq\"\n)\n\ntype moduleLoader struct{}\n\nfunc (*moduleLoader) LoadModule(name string) (*gojq.Query, error) {\n\tswitch name {\n\tcase \"module1\":\n\t\treturn gojq.Parse(`\n\t\t\tmodule { name: \"module1\", test: 42 };\n\t\t\timport \"module2\" as foo;\n\t\t\tdef g: foo::f;\n\t\t`)\n\tcase \"module2\":\n\t\treturn gojq.Parse(`\n\t\t\tdef f: .foo;\n\t\t`)\n\tcase \"module3\":\n\t\treturn gojq.Parse(\"\")\n\t}\n\treturn nil, fmt.Errorf(\"module not found: %q\", name)\n}\n\nfunc ExampleWithModuleLoader() {\n\tquery, err := gojq.Parse(`\n\t\timport \"module1\" as m;\n\t\tm::g\n\t`)\n\tif err != nil {\n\t\tlog.Fatalln(err)\n\t}\n\tcode, err := gojq.Compile(\n\t\tquery,\n\t\tgojq.WithModuleLoader(&moduleLoader{}),\n\t)\n\tif err != nil {\n\t\tlog.Fatalln(err)\n\t}\n\tinput := map[string]any{\"foo\": 42}\n\titer := code.Run(input)\n\tfor {\n\t\tv, ok := iter.Next()\n\t\tif !ok {\n\t\t\tbreak\n\t\t}\n\t\tif err, ok := v.(error); ok {\n\t\t\tlog.Fatalln(err)\n\t\t}\n\t\tfmt.Printf(\"%#v\\n\", v)\n\t}\n\n\t// Output:\n\t// 42\n}\n"
        },
        {
          "name": "option_test.go",
          "type": "blob",
          "size": 19.40234375,
          "content": "package gojq_test\n\nimport (\n\t\"encoding/json\"\n\t\"errors\"\n\t\"fmt\"\n\t\"reflect\"\n\t\"testing\"\n\n\t\"github.com/itchyny/gojq\"\n)\n\nfunc TestWithModuleLoaderError(t *testing.T) {\n\tquery, err := gojq.Parse(`\n\t\timport \"module1\" as m;\n\t\tdef f: 42;\n\t\tm::f, f\n\t`)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\t_, err = gojq.Compile(query)\n\tif got, expected := err.Error(), `cannot load module: \"module1\"`; got != expected {\n\t\tt.Errorf(\"expected: %v, got: %v\", expected, got)\n\t}\n\n\tquery, err = gojq.Parse(\"modulemeta\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tcode, err := gojq.Compile(query)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\titer := code.Run(\"m\")\n\tv, ok := iter.Next()\n\tif !ok {\n\t\tt.Fatal(\"should emit an error but got no output\")\n\t}\n\tif err, ok := v.(error); ok {\n\t\tif expected := `cannot load module: \"m\"`; err.Error() != expected {\n\t\t\tt.Errorf(\"expected: %v, got: %v\", expected, err)\n\t\t}\n\t} else {\n\t\tt.Errorf(\"should emit an error but got: %v\", v)\n\t}\n\tv, ok = iter.Next()\n\tif ok {\n\t\tt.Errorf(\"should not emit a value but got: %v\", v)\n\t}\n}\n\nfunc TestWithModuleLoader_modulemeta(t *testing.T) {\n\tquery, err := gojq.Parse(`\n\t\t\"module1\", \"module2\", \"module3\" | modulemeta\n\t`)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tcode, err := gojq.Compile(\n\t\tquery,\n\t\tgojq.WithModuleLoader(&moduleLoader{}),\n\t)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\titer := code.Run(nil)\n\tn := 0\n\tfor {\n\t\tgot, ok := iter.Next()\n\t\tif !ok {\n\t\t\tbreak\n\t\t}\n\t\tswitch n {\n\t\tcase 0:\n\t\t\tif expected := map[string]any{\n\t\t\t\t\"defs\": []any{\"g/0\"},\n\t\t\t\t\"deps\": []any{\n\t\t\t\t\tmap[string]any{\n\t\t\t\t\t\t\"relpath\": \"module2\",\n\t\t\t\t\t\t\"as\":      \"foo\",\n\t\t\t\t\t\t\"is_data\": false,\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\t\"name\": \"module1\",\n\t\t\t\t\"test\": 42,\n\t\t\t}; !reflect.DeepEqual(got, expected) {\n\t\t\t\tt.Errorf(\"expected: %v, got: %v\", expected, got)\n\t\t\t}\n\t\tcase 1:\n\t\t\tif expected := map[string]any{\n\t\t\t\t\"defs\": []any{\"f/0\"},\n\t\t\t\t\"deps\": []any{}, // not a nil-slice\n\t\t\t}; !reflect.DeepEqual(got, expected) {\n\t\t\t\tt.Errorf(\"expected: %v, got: %v\", expected, got)\n\t\t\t}\n\t\tdefault:\n\t\t\tif expected := map[string]any{\n\t\t\t\t\"defs\": []any{}, // not a nil-slice\n\t\t\t\t\"deps\": []any{}, // not a nil-slice\n\t\t\t}; !reflect.DeepEqual(got, expected) {\n\t\t\t\tt.Errorf(\"expected: %v, got: %v\", expected, got)\n\t\t\t}\n\t\t}\n\t\tn++\n\t}\n}\n\ntype moduleLoaderJSON struct{}\n\nfunc (*moduleLoaderJSON) LoadJSON(name string) (any, error) {\n\tif name == \"module1\" {\n\t\treturn []any{1.0, 42, json.Number(\"123\")}, nil\n\t}\n\treturn nil, fmt.Errorf(\"module not found: %q\", name)\n}\n\nfunc TestWithModuleLoader_JSON(t *testing.T) {\n\tquery, err := gojq.Parse(`\n\t\timport \"module1\" as $m;\n\t\t[$m, $m[1]*$m[2]]\n\t`)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tcode, err := gojq.Compile(\n\t\tquery,\n\t\tgojq.WithModuleLoader(&moduleLoaderJSON{}),\n\t)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\titer := code.Run(nil)\n\tfor {\n\t\tgot, ok := iter.Next()\n\t\tif !ok {\n\t\t\tbreak\n\t\t}\n\t\tif expected := []any{[]any{1.0, 42, 123}, 5166}; !reflect.DeepEqual(got, expected) {\n\t\t\tt.Errorf(\"expected: %v, got: %v\", expected, got)\n\t\t}\n\t}\n}\n\ntype moduleLoaderInitModules struct{}\n\nfunc (*moduleLoaderInitModules) LoadInitModules() ([]*gojq.Query, error) {\n\tquery, err := gojq.Parse(`\n\t\tdef f: $x;\n\t\tdef g: f * f;\n\t`)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn []*gojq.Query{query}, nil\n}\n\nfunc TestWithModuleLoader_LoadInitModules(t *testing.T) {\n\tquery, err := gojq.Parse(\"g\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tcode, err := gojq.Compile(\n\t\tquery,\n\t\tgojq.WithVariables([]string{\"$x\"}),\n\t\tgojq.WithModuleLoader(&moduleLoaderInitModules{}),\n\t)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\titer := code.Run(nil, 42)\n\tfor {\n\t\tgot, ok := iter.Next()\n\t\tif !ok {\n\t\t\tbreak\n\t\t}\n\t\tif expected := 42 * 42; !reflect.DeepEqual(got, expected) {\n\t\t\tt.Errorf(\"expected: %v, got: %v\", expected, got)\n\t\t}\n\t}\n}\n\nfunc TestWithEnvironLoader(t *testing.T) {\n\tquery, err := gojq.Parse(\"env\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tcode, err := gojq.Compile(\n\t\tquery,\n\t\tgojq.WithEnvironLoader(func() []string {\n\t\t\treturn []string{\"foo=42\", \"bar=128\", \"baz\", \"qux=\", \"=0\"}\n\t\t}),\n\t)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\titer := code.Run(nil)\n\tfor {\n\t\tgot, ok := iter.Next()\n\t\tif !ok {\n\t\t\tbreak\n\t\t}\n\t\texpected := map[string]any{\"foo\": \"42\", \"bar\": \"128\", \"qux\": \"\"}\n\t\tif !reflect.DeepEqual(got, expected) {\n\t\t\tt.Errorf(\"expected: %v, got: %v\", expected, got)\n\t\t}\n\t}\n}\n\nfunc TestWithEnvironLoaderEmpty(t *testing.T) {\n\tquery, err := gojq.Parse(\"env\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tcode, err := gojq.Compile(query)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\titer := code.Run(nil)\n\tfor {\n\t\tgot, ok := iter.Next()\n\t\tif !ok {\n\t\t\tbreak\n\t\t}\n\t\tif expected := map[string]any{}; !reflect.DeepEqual(got, expected) {\n\t\t\tt.Errorf(\"expected: %v, got: %v\", expected, got)\n\t\t}\n\t}\n}\n\nfunc TestWithVariablesError0(t *testing.T) {\n\tquery, err := gojq.Parse(\".\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tfor _, name := range []string{\"\", \"$\", \"_x\", \"x\", \"$0x\", \"$$\", \"$x \", \" $x\"} {\n\t\t_, err = gojq.Compile(\n\t\t\tquery,\n\t\t\tgojq.WithVariables([]string{name}),\n\t\t)\n\t\tif err == nil {\n\t\t\tt.Fatalf(\"%q is not a valid variable name\", name)\n\t\t}\n\t\tif got, expected := err.Error(), \"invalid variable name: \"+name; got != expected {\n\t\t\tt.Errorf(\"expected: %v, got: %v\", expected, got)\n\t\t}\n\t}\n}\n\nfunc TestWithVariablesError1(t *testing.T) {\n\tquery, err := gojq.Parse(\".\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tcode, err := gojq.Compile(\n\t\tquery,\n\t\tgojq.WithVariables([]string{\"$x\"}),\n\t)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\titer := code.Run(nil)\n\tv, ok := iter.Next()\n\tif !ok {\n\t\tt.Fatal(\"should emit an error but got no output\")\n\t}\n\tif err, ok := v.(error); ok {\n\t\tif expected := \"variable defined but not bound: $x\"; err.Error() != expected {\n\t\t\tt.Errorf(\"expected: %v, got: %v\", expected, err)\n\t\t}\n\t} else {\n\t\tt.Errorf(\"should emit an error but got: %v\", v)\n\t}\n\tv, ok = iter.Next()\n\tif ok {\n\t\tt.Errorf(\"should not emit a value but got: %v\", v)\n\t}\n}\n\nfunc TestWithVariablesError2(t *testing.T) {\n\tquery, err := gojq.Parse(\".\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tcode, err := gojq.Compile(\n\t\tquery,\n\t\tgojq.WithVariables([]string{\"$x\"}),\n\t)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\titer := code.Run(nil, 1, 2)\n\tv, ok := iter.Next()\n\tif !ok {\n\t\tt.Fatal(\"should emit an error but got no output\")\n\t}\n\tif err, ok := v.(error); ok {\n\t\tif expected := \"too many variable values provided\"; err.Error() != expected {\n\t\t\tt.Errorf(\"expected: %v, got: %v\", expected, err)\n\t\t}\n\t} else {\n\t\tt.Errorf(\"should emit an error but got: %v\", v)\n\t}\n\tv, ok = iter.Next()\n\tif ok {\n\t\tt.Errorf(\"should not emit a value but got: %v\", v)\n\t}\n}\n\nfunc TestWithFunction(t *testing.T) {\n\toptions := []gojq.CompilerOption{\n\t\tgojq.WithFunction(\"f\", 0, 0, func(x any, _ []any) any {\n\t\t\tif x, ok := x.(int); ok {\n\t\t\t\treturn x * 2\n\t\t\t}\n\t\t\treturn fmt.Errorf(\"f cannot be applied to: %v\", x)\n\t\t}),\n\t\tgojq.WithFunction(\"g\", 1, 1, func(x any, xs []any) any {\n\t\t\tif x, ok := x.(int); ok {\n\t\t\t\tif y, ok := xs[0].(int); ok {\n\t\t\t\t\treturn x + y\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn fmt.Errorf(\"g cannot be applied to: %v, %v\", x, xs)\n\t\t}),\n\t}\n\tquery, err := gojq.Parse(\".[] | f | g(3)\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tcode, err := gojq.Compile(query, options...)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\titer := code.Run([]any{0, 1, 2, 3, 4})\n\tn := 0\n\tfor {\n\t\tv, ok := iter.Next()\n\t\tif !ok {\n\t\t\tbreak\n\t\t}\n\t\tif expected := n*2 + 3; v != expected {\n\t\t\tt.Errorf(\"expected: %v, got: %v\", expected, v)\n\t\t}\n\t\tn++\n\t}\n\tif expected := 5; n != expected {\n\t\tt.Errorf(\"expected: %v, got: %v\", expected, n)\n\t}\n\tquery, err = gojq.Parse(\n\t\t`(\"f/0\", \"f/1\", \"g/0\", \"g/1\") as $f | builtins | any(. == $f)`,\n\t)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tcode, err = gojq.Compile(query, options...)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\titer = code.Run(nil)\n\tn = 0\n\tfor {\n\t\tv, ok := iter.Next()\n\t\tif !ok {\n\t\t\tbreak\n\t\t}\n\t\tif expected := n == 0 || n == 3; v != expected {\n\t\t\tt.Errorf(\"expected: %v, got: %v (n = %d)\", expected, v, n)\n\t\t}\n\t\tn++\n\t}\n\tif expected := 4; n != expected {\n\t\tt.Errorf(\"expected: %v, got: %v\", expected, n)\n\t}\n}\n\nfunc TestWithFunctionDuplicateName(t *testing.T) {\n\toptions := []gojq.CompilerOption{\n\t\tgojq.WithFunction(\"f\", 0, 0, func(x any, _ []any) any {\n\t\t\tif x, ok := x.(int); ok {\n\t\t\t\treturn x * 2\n\t\t\t}\n\t\t\treturn fmt.Errorf(\"f cannot be applied to: %v\", x)\n\t\t}),\n\t\tgojq.WithFunction(\"f\", 1, 1, func(x any, xs []any) any {\n\t\t\tif x, ok := x.(int); ok {\n\t\t\t\tif y, ok := xs[0].(int); ok {\n\t\t\t\t\treturn x + y\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn fmt.Errorf(\"f cannot be applied to: %v, %v\", x, xs)\n\t\t}),\n\t\tgojq.WithFunction(\"f\", 0, 0, func(x any, _ []any) any {\n\t\t\tif x, ok := x.(int); ok {\n\t\t\t\treturn x * 4\n\t\t\t}\n\t\t\treturn fmt.Errorf(\"f cannot be applied to: %v\", x)\n\t\t}),\n\t\tgojq.WithFunction(\"f\", 2, 2, func(x any, xs []any) any {\n\t\t\tif x, ok := x.(int); ok {\n\t\t\t\tif y, ok := xs[0].(int); ok {\n\t\t\t\t\tif z, ok := xs[1].(int); ok {\n\t\t\t\t\t\treturn x * y * z\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn fmt.Errorf(\"f cannot be applied to: %v, %v\", x, xs)\n\t\t}),\n\t}\n\tquery, err := gojq.Parse(\".[] | f | f(3) | f(4; 5)\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tcode, err := gojq.Compile(query, options...)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\titer := code.Run([]any{0, 1, 2, 3, 4})\n\tn := 0\n\tfor {\n\t\tv, ok := iter.Next()\n\t\tif !ok {\n\t\t\tbreak\n\t\t}\n\t\tif expected := (n*4 + 3) * 4 * 5; v != expected {\n\t\t\tt.Errorf(\"expected: %v, got: %v\", expected, v)\n\t\t}\n\t\tn++\n\t}\n\tif expected := 5; n != expected {\n\t\tt.Errorf(\"expected: %v, got: %v\", expected, n)\n\t}\n\tquery, err = gojq.Parse(\n\t\t`(\"f/0\", \"f/1\", \"f/2\", \"f/3\") as $f | builtins | any(. == $f)`,\n\t)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tcode, err = gojq.Compile(query, options...)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\titer = code.Run(nil)\n\tn = 0\n\tfor {\n\t\tv, ok := iter.Next()\n\t\tif !ok {\n\t\t\tbreak\n\t\t}\n\t\tif expected := n < 3; v != expected {\n\t\t\tt.Errorf(\"expected: %v, got: %v (n = %d)\", expected, v, n)\n\t\t}\n\t\tn++\n\t}\n\tif expected := 4; n != expected {\n\t\tt.Errorf(\"expected: %v, got: %v\", expected, n)\n\t}\n}\n\nfunc TestWithFunctionMultipleArities(t *testing.T) {\n\toptions := []gojq.CompilerOption{\n\t\tgojq.WithFunction(\"f\", 0, 4, func(x any, xs []any) any {\n\t\t\tif x, ok := x.(int); ok {\n\t\t\t\tx *= 2\n\t\t\t\tfor _, y := range xs {\n\t\t\t\t\tif y, ok := y.(int); ok {\n\t\t\t\t\t\tx += y\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn x\n\t\t\t}\n\t\t\treturn fmt.Errorf(\"f cannot be applied to: %v, %v\", x, xs)\n\t\t}),\n\t\tgojq.WithFunction(\"f\", 2, 3, func(x any, xs []any) any {\n\t\t\tif x, ok := x.(int); ok {\n\t\t\t\tfor _, y := range xs {\n\t\t\t\t\tif y, ok := y.(int); ok {\n\t\t\t\t\t\tx *= y\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn x\n\t\t\t}\n\t\t\treturn fmt.Errorf(\"f cannot be applied to: %v, %v\", x, xs)\n\t\t}),\n\t\tgojq.WithFunction(\"g\", 0, 30, func(x any, xs []any) any {\n\t\t\treturn nil\n\t\t}),\n\t}\n\tquery, err := gojq.Parse(\".[] | f | f(1) | f(2; 3) | f(4; 5; 6) | f(7; 8; 9; 10)\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tcode, err := gojq.Compile(query, options...)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\titer := code.Run([]any{0, 1, 2, 3, 4})\n\tn := 0\n\tfor {\n\t\tv, ok := iter.Next()\n\t\tif !ok {\n\t\t\tbreak\n\t\t}\n\t\tif expected := (((n*2*2+1)*2*3)*4*5*6)*2 + 7 + 8 + 9 + 10; v != expected {\n\t\t\tt.Errorf(\"expected: %v, got: %v\", expected, v)\n\t\t}\n\t\tn++\n\t}\n\tif expected := 5; n != expected {\n\t\tt.Errorf(\"expected: %v, got: %v\", expected, n)\n\t}\n\tquery, err = gojq.Parse(\n\t\t`(\"f/0\", \"f/1\", \"f/2\", \"f/3\", \"f/4\", \"f/5\") as $f | builtins | any(. == $f)`,\n\t)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tcode, err = gojq.Compile(query, options...)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\titer = code.Run(nil)\n\tn = 0\n\tfor {\n\t\tv, ok := iter.Next()\n\t\tif !ok {\n\t\t\tbreak\n\t\t}\n\t\tif expected := n < 5; v != expected {\n\t\t\tt.Errorf(\"expected: %v, got: %v (n = %d)\", expected, v, n)\n\t\t}\n\t\tn++\n\t}\n\tif expected := 6; n != expected {\n\t\tt.Errorf(\"expected: %v, got: %v\", expected, n)\n\t}\n}\n\ntype valueError struct {\n\tv any\n}\n\nfunc (err *valueError) Error() string {\n\treturn \"error: \" + fmt.Sprint(err.v)\n}\n\nfunc (err *valueError) Value() any {\n\treturn err.v\n}\n\nfunc TestWithFunctionValueError(t *testing.T) {\n\texpected := map[string]any{\"foo\": 42}\n\tquery, err := gojq.Parse(\"try f catch .\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tcode, err := gojq.Compile(query,\n\t\tgojq.WithFunction(\"f\", 0, 0, func(x any, _ []any) any {\n\t\t\treturn &valueError{expected}\n\t\t}),\n\t)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\titer := code.Run(nil)\n\tfor {\n\t\tv, ok := iter.Next()\n\t\tif !ok {\n\t\t\tbreak\n\t\t}\n\t\tif !reflect.DeepEqual(v, expected) {\n\t\t\tt.Errorf(\"expected: %v, got: %v\", expected, v)\n\t\t}\n\t}\n}\n\nfunc TestWithFunctionCompileArgsError(t *testing.T) {\n\tquery, err := gojq.Parse(\"f(g)\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\t_, err = gojq.Compile(query,\n\t\tgojq.WithFunction(\"f\", 0, 1, func(any, []any) any {\n\t\t\treturn 0\n\t\t}),\n\t)\n\tif got, expected := err.Error(), \"function not defined: g/0\"; got != expected {\n\t\tt.Errorf(\"expected: %v, got: %v\", expected, got)\n\t}\n}\n\nfunc TestWithFunctionArityError(t *testing.T) {\n\tquery, err := gojq.Parse(\"f\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tfor _, tc := range []struct{ min, max int }{{3, 2}, {-1, 3}, {0, 31}, {-1, 31}} {\n\t\tfunc() {\n\t\t\tdefer func() {\n\t\t\t\texpected := fmt.Sprintf(`invalid arity for \"f\": %d, %d`, tc.min, tc.max)\n\t\t\t\tif got := recover(); got != expected {\n\t\t\t\t\tt.Errorf(\"expected: %v, got: %v\", expected, got)\n\t\t\t\t}\n\t\t\t}()\n\t\t\tt.Fatal(gojq.Compile(query,\n\t\t\t\tgojq.WithFunction(\"f\", tc.min, tc.max, func(any, []any) any {\n\t\t\t\t\treturn 0\n\t\t\t\t}),\n\t\t\t))\n\t\t}()\n\t}\n}\n\nfunc TestWithIterFunction(t *testing.T) {\n\tquery, err := gojq.Parse(\"f * g(5; 10), h, 10\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tcode, err := gojq.Compile(query,\n\t\tgojq.WithIterFunction(\"f\", 0, 0, func(any, []any) gojq.Iter {\n\t\t\treturn gojq.NewIter(1, 2, 3)\n\t\t}),\n\t\tgojq.WithIterFunction(\"g\", 2, 2, func(_ any, xs []any) gojq.Iter {\n\t\t\tif x, ok := xs[0].(int); ok {\n\t\t\t\tif y, ok := xs[1].(int); ok {\n\t\t\t\t\treturn &rangeIter{x, y}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn gojq.NewIter(fmt.Errorf(\"g cannot be applied to: %v\", xs))\n\t\t}),\n\t\tgojq.WithIterFunction(\"h\", 0, 0, func(any, []any) gojq.Iter {\n\t\t\treturn gojq.NewIter()\n\t\t}),\n\t)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\titer := code.Run(nil)\n\tn := 0\n\tfor {\n\t\tv, ok := iter.Next()\n\t\tif !ok {\n\t\t\tbreak\n\t\t}\n\t\tif expected := (1 + n%3) * (5 + n/3); v != expected {\n\t\t\tt.Errorf(\"expected: %v, got: %v\", expected, v)\n\t\t}\n\t\tn++\n\t}\n\tif expected := 16; n != expected {\n\t\tt.Errorf(\"expected: %v, got: %v\", expected, n)\n\t}\n}\n\nfunc TestWithIterFunctionError(t *testing.T) {\n\tquery, err := gojq.Parse(\"range(3) * (f, 0), f\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tcode, err := gojq.Compile(query,\n\t\tgojq.WithIterFunction(\"f\", 0, 0, func(any, []any) gojq.Iter {\n\t\t\treturn gojq.NewIter(1, errors.New(\"error\"), 3)\n\t\t}),\n\t)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\titer := code.Run(nil)\n\tn := 0\n\tfor {\n\t\tv, ok := iter.Next()\n\t\tif !ok {\n\t\t\tbreak\n\t\t}\n\t\tswitch n {\n\t\tcase 0, 1, 2:\n\t\t\tif expected := n; v != expected {\n\t\t\t\tt.Errorf(\"expected: %v, got: %v\", expected, v)\n\t\t\t}\n\t\tcase 3, 5:\n\t\t\tif expected := \"error\"; v.(error).Error() != expected {\n\t\t\t\tt.Errorf(\"expected: %v, got: %v\", expected, err)\n\t\t\t}\n\t\tdefault:\n\t\t\tif expected := n - 3; v != expected {\n\t\t\t\tt.Errorf(\"expected: %v, got: %v\", expected, v)\n\t\t\t}\n\t\t}\n\t\tn++\n\t}\n\tif expected := 7; n != expected {\n\t\tt.Errorf(\"expected: %v, got: %v\", expected, n)\n\t}\n}\n\nfunc TestWithIterFunctionPathIndexing(t *testing.T) {\n\tquery, err := gojq.Parse(\".[f] = 1\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tcode, err := gojq.Compile(query,\n\t\tgojq.WithIterFunction(\"f\", 0, 0, func(any, []any) gojq.Iter {\n\t\t\treturn gojq.NewIter(0, 1, 2)\n\t\t}),\n\t)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\titer := code.Run(nil)\n\tfor {\n\t\tv, ok := iter.Next()\n\t\tif !ok {\n\t\t\tbreak\n\t\t}\n\t\tif expected := []any{1, 1, 1}; !reflect.DeepEqual(v, expected) {\n\t\t\tt.Errorf(\"expected: %v, got: %v\", expected, v)\n\t\t}\n\t}\n}\n\nfunc TestWithIterFunctionPathInputValue(t *testing.T) {\n\tquery, err := gojq.Parse(\"{x: 0} | (f|.x) = 1\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tcode, err := gojq.Compile(query,\n\t\tgojq.WithIterFunction(\"f\", 0, 0, func(v any, _ []any) gojq.Iter {\n\t\t\treturn gojq.NewIter(v, v, v)\n\t\t}),\n\t)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\titer := code.Run(nil)\n\tfor {\n\t\tv, ok := iter.Next()\n\t\tif !ok {\n\t\t\tbreak\n\t\t}\n\t\tif expected := map[string]any{\"x\": 1}; !reflect.DeepEqual(v, expected) {\n\t\t\tt.Errorf(\"expected: %v, got: %v\", expected, v)\n\t\t}\n\t}\n}\n\nfunc TestWithIterFunctionPathEmpty(t *testing.T) {\n\tquery, err := gojq.Parse(\"{x: 0} | (f|.x) = 1\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tcode, err := gojq.Compile(query,\n\t\tgojq.WithIterFunction(\"f\", 0, 0, func(any, []any) gojq.Iter {\n\t\t\treturn gojq.NewIter()\n\t\t}),\n\t)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\titer := code.Run(nil)\n\tfor {\n\t\tv, ok := iter.Next()\n\t\tif !ok {\n\t\t\tbreak\n\t\t}\n\t\tif expected := map[string]any{\"x\": 0}; !reflect.DeepEqual(v, expected) {\n\t\t\tt.Errorf(\"expected: %v, got: %v\", expected, v)\n\t\t}\n\t}\n}\n\nfunc TestWithIterFunctionInvalidPathError(t *testing.T) {\n\tquery, err := gojq.Parse(\"{x: 0} | (f|.x) = 1\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tcode, err := gojq.Compile(query,\n\t\tgojq.WithIterFunction(\"f\", 0, 0, func(any, []any) gojq.Iter {\n\t\t\treturn gojq.NewIter(map[string]any{\"x\": 1})\n\t\t}),\n\t)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\titer := code.Run(nil)\n\tv, ok := iter.Next()\n\tif !ok {\n\t\tt.Fatal(\"should emit an error but got no output\")\n\t}\n\tif err, ok := v.(error); ok {\n\t\tif expected := `invalid path against: object ({\"x\":1})`; err.Error() != expected {\n\t\t\tt.Errorf(\"expected: %v, got: %v\", expected, err)\n\t\t}\n\t} else {\n\t\tt.Errorf(\"should emit an error but got: %v\", v)\n\t}\n}\n\nfunc TestWithIterFunctionPathError(t *testing.T) {\n\tquery, err := gojq.Parse(\"{x: 0} | (f|.x) = 1\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tcode, err := gojq.Compile(query,\n\t\tgojq.WithIterFunction(\"f\", 0, 0, func(any, []any) gojq.Iter {\n\t\t\treturn gojq.NewIter(errors.New(\"error\"))\n\t\t}),\n\t)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\titer := code.Run(nil)\n\tv, ok := iter.Next()\n\tif !ok {\n\t\tt.Fatal(\"should emit an error but got no output\")\n\t}\n\tif err, ok := v.(error); ok {\n\t\tif expected := \"error\"; err.Error() != expected {\n\t\t\tt.Errorf(\"expected: %v, got: %v\", expected, err)\n\t\t}\n\t} else {\n\t\tt.Errorf(\"should emit an error but got: %v\", v)\n\t}\n}\n\nfunc TestWithIterFunctionDefineError(t *testing.T) {\n\tquery, err := gojq.Parse(\"f\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer func() {\n\t\texpected := `cannot define both iterator and non-iterator functions for \"f\"`\n\t\tif got := recover(); got != expected {\n\t\t\tt.Errorf(\"expected: %v, got: %v\", expected, got)\n\t\t}\n\t}()\n\tt.Fatal(gojq.Compile(query,\n\t\tgojq.WithFunction(\"f\", 0, 0, func(any, []any) any {\n\t\t\treturn 0\n\t\t}),\n\t\tgojq.WithIterFunction(\"f\", 0, 0, func(any, []any) gojq.Iter {\n\t\t\treturn gojq.NewIter()\n\t\t}),\n\t))\n}\n\ntype moduleLoader2 struct{}\n\nfunc (*moduleLoader2) LoadModule(name string) (*gojq.Query, error) {\n\tif name == \"module1\" {\n\t\treturn gojq.Parse(`\n\t\t\tdef g: def h: f * 3; h * 4;\n\t\t`)\n\t}\n\treturn nil, fmt.Errorf(\"module not found: %q\", name)\n}\n\nfunc TestWithFunctionWithModuleLoader(t *testing.T) {\n\tquery, err := gojq.Parse(`include \"module1\"; .[] | g`)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tcode, err := gojq.Compile(query,\n\t\tgojq.WithFunction(\"f\", 0, 0, func(x any, _ []any) any {\n\t\t\tif x, ok := x.(int); ok {\n\t\t\t\treturn x * 2\n\t\t\t}\n\t\t\treturn fmt.Errorf(\"f cannot be applied to: %v\", x)\n\t\t}),\n\t\tgojq.WithModuleLoader(&moduleLoader2{}),\n\t)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\titer := code.Run([]any{0, 1, 2, 3, 4})\n\tn := 0\n\tfor {\n\t\tv, ok := iter.Next()\n\t\tif !ok {\n\t\t\tbreak\n\t\t}\n\t\tif expected := n * 2 * 3 * 4; v != expected {\n\t\t\tt.Errorf(\"expected: %v, got: %v\", expected, v)\n\t\t}\n\t\tn++\n\t}\n\tif expected := 5; n != expected {\n\t\tt.Errorf(\"expected: %v, got: %v\", expected, n)\n\t}\n}\n\nfunc TestWithInputIter(t *testing.T) {\n\tquery, err := gojq.Parse(\"range(10) | input\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tcode, err := gojq.Compile(\n\t\tquery,\n\t\tgojq.WithInputIter(gojq.NewIter(0, 1, 2, 3, 4)),\n\t)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\titer := code.Run(nil)\n\tn := 0\n\tfor {\n\t\tv, ok := iter.Next()\n\t\tif !ok {\n\t\t\tbreak\n\t\t}\n\t\tif err, ok := v.(error); ok {\n\t\t\tif expected := \"break\"; err.Error() != expected {\n\t\t\t\tt.Errorf(\"expected: %v, got: %v\", expected, err)\n\t\t\t}\n\t\t} else if v != n {\n\t\t\tt.Errorf(\"expected: %v, got: %v\", n, v)\n\t\t}\n\t\tn++\n\t}\n\tif expected := 10; n != expected {\n\t\tt.Errorf(\"expected: %v, got: %v\", expected, n)\n\t}\n}\n"
        },
        {
          "name": "option_variables_test.go",
          "type": "blob",
          "size": 0.51953125,
          "content": "package gojq_test\n\nimport (\n\t\"fmt\"\n\t\"log\"\n\n\t\"github.com/itchyny/gojq\"\n)\n\nfunc ExampleWithVariables() {\n\tquery, err := gojq.Parse(\"$x * 100 + $y, $z\")\n\tif err != nil {\n\t\tlog.Fatalln(err)\n\t}\n\tcode, err := gojq.Compile(\n\t\tquery,\n\t\tgojq.WithVariables([]string{\n\t\t\t\"$x\", \"$y\", \"$z\",\n\t\t}),\n\t)\n\tif err != nil {\n\t\tlog.Fatalln(err)\n\t}\n\titer := code.Run(nil, 12, 42, 128)\n\tfor {\n\t\tv, ok := iter.Next()\n\t\tif !ok {\n\t\t\tbreak\n\t\t}\n\t\tif err, ok := v.(error); ok {\n\t\t\tlog.Fatalln(err)\n\t\t}\n\t\tfmt.Printf(\"%#v\\n\", v)\n\t}\n\n\t// Output:\n\t// 1242\n\t// 128\n}\n"
        },
        {
          "name": "parser.go",
          "type": "blob",
          "size": 37.96875,
          "content": "// Code generated by goyacc -o parser.go parser.go.y. DO NOT EDIT.\n\n//line parser.go.y:2\npackage gojq\n\nimport __yyfmt__ \"fmt\"\n\n//line parser.go.y:2\n\nfunc reverseFuncDef(xs []*FuncDef) []*FuncDef {\n\tfor i, j := 0, len(xs)-1; i < j; i, j = i+1, j-1 {\n\t\txs[i], xs[j] = xs[j], xs[i]\n\t}\n\treturn xs\n}\n\nfunc prependFuncDef(xs []*FuncDef, x *FuncDef) []*FuncDef {\n\txs = append(xs, nil)\n\tcopy(xs[1:], xs)\n\txs[0] = x\n\treturn xs\n}\n\n//line parser.go.y:19\ntype yySymType struct {\n\tyys      int\n\tvalue    any\n\ttoken    string\n\toperator Operator\n}\n\nconst tokAltOp = 57346\nconst tokUpdateOp = 57347\nconst tokDestAltOp = 57348\nconst tokCompareOp = 57349\nconst tokOrOp = 57350\nconst tokAndOp = 57351\nconst tokModule = 57352\nconst tokImport = 57353\nconst tokInclude = 57354\nconst tokDef = 57355\nconst tokAs = 57356\nconst tokLabel = 57357\nconst tokBreak = 57358\nconst tokNull = 57359\nconst tokTrue = 57360\nconst tokFalse = 57361\nconst tokIf = 57362\nconst tokThen = 57363\nconst tokElif = 57364\nconst tokElse = 57365\nconst tokEnd = 57366\nconst tokTry = 57367\nconst tokCatch = 57368\nconst tokReduce = 57369\nconst tokForeach = 57370\nconst tokIdent = 57371\nconst tokVariable = 57372\nconst tokModuleIdent = 57373\nconst tokModuleVariable = 57374\nconst tokRecurse = 57375\nconst tokIndex = 57376\nconst tokNumber = 57377\nconst tokFormat = 57378\nconst tokString = 57379\nconst tokStringStart = 57380\nconst tokStringQuery = 57381\nconst tokStringEnd = 57382\nconst tokInvalid = 57383\nconst tokInvalidEscapeSequence = 57384\nconst tokUnterminatedString = 57385\nconst tokFuncDefQuery = 57386\nconst tokExpr = 57387\nconst tokTerm = 57388\nconst tokEmptyCatch = 57389\n\nvar yyToknames = [...]string{\n\t\"$end\",\n\t\"error\",\n\t\"$unk\",\n\t\"tokAltOp\",\n\t\"tokUpdateOp\",\n\t\"tokDestAltOp\",\n\t\"tokCompareOp\",\n\t\"tokOrOp\",\n\t\"tokAndOp\",\n\t\"tokModule\",\n\t\"tokImport\",\n\t\"tokInclude\",\n\t\"tokDef\",\n\t\"tokAs\",\n\t\"tokLabel\",\n\t\"tokBreak\",\n\t\"tokNull\",\n\t\"tokTrue\",\n\t\"tokFalse\",\n\t\"tokIf\",\n\t\"tokThen\",\n\t\"tokElif\",\n\t\"tokElse\",\n\t\"tokEnd\",\n\t\"tokTry\",\n\t\"tokCatch\",\n\t\"tokReduce\",\n\t\"tokForeach\",\n\t\"tokIdent\",\n\t\"tokVariable\",\n\t\"tokModuleIdent\",\n\t\"tokModuleVariable\",\n\t\"tokRecurse\",\n\t\"tokIndex\",\n\t\"tokNumber\",\n\t\"tokFormat\",\n\t\"tokString\",\n\t\"tokStringStart\",\n\t\"tokStringQuery\",\n\t\"tokStringEnd\",\n\t\"tokInvalid\",\n\t\"tokInvalidEscapeSequence\",\n\t\"tokUnterminatedString\",\n\t\"tokFuncDefQuery\",\n\t\"tokExpr\",\n\t\"tokTerm\",\n\t\"'|'\",\n\t\"','\",\n\t\"'+'\",\n\t\"'-'\",\n\t\"'*'\",\n\t\"'/'\",\n\t\"'%'\",\n\t\"'.'\",\n\t\"'?'\",\n\t\"tokEmptyCatch\",\n\t\"'['\",\n\t\"';'\",\n\t\"':'\",\n\t\"'('\",\n\t\"')'\",\n\t\"']'\",\n\t\"'{'\",\n\t\"'}'\",\n}\n\nvar yyStatenames = [...]string{}\n\nconst yyEofCode = 1\nconst yyErrCode = 2\nconst yyInitialStackSize = 16\n\n//line parser.go.y:671\n\n//line yacctab:1\nvar yyExca = [...]int16{\n\t-1, 1,\n\t1, -1,\n\t-2, 0,\n\t-1, 145,\n\t5, 0,\n\t-2, 27,\n\t-1, 148,\n\t7, 0,\n\t-2, 30,\n\t-1, 199,\n\t59, 114,\n\t-2, 49,\n}\n\nconst yyPrivate = 57344\n\nconst yyLast = 782\n\nvar yyAct = [...]int16{\n\t78, 134, 186, 102, 103, 10, 175, 195, 32, 211,\n\t48, 108, 81, 176, 131, 6, 229, 5, 50, 73,\n\t74, 159, 14, 180, 181, 182, 124, 98, 110, 135,\n\t280, 97, 228, 279, 115, 104, 16, 158, 265, 121,\n\t114, 178, 123, 179, 244, 73, 74, 180, 181, 182,\n\t73, 74, 112, 113, 154, 155, 136, 117, 117, 117,\n\t254, 243, 137, 183, 282, 178, 255, 179, 220, 6,\n\t247, 116, 118, 119, 128, 129, 73, 74, 99, 73,\n\t74, 227, 73, 74, 246, 141, 238, 183, 201, 237,\n\t132, 200, 139, 6, 235, 226, 138, 163, 208, 80,\n\t157, 207, 241, 231, 230, 161, 162, 73, 74, 117,\n\t117, 117, 117, 117, 117, 117, 117, 117, 117, 83,\n\t82, 278, 84, 144, 145, 146, 147, 148, 149, 150,\n\t151, 152, 153, 184, 185, 174, 50, 160, 193, 73,\n\t74, 127, 196, 202, 203, 126, 197, 73, 74, 125,\n\t73, 74, 248, 253, 189, 204, 45, 240, 206, 73,\n\t74, 245, 143, 210, 214, 215, 73, 74, 104, 217,\n\t218, 213, 79, 219, 86, 87, 76, 90, 88, 89,\n\t169, 43, 44, 117, 117, 73, 74, 75, 166, 117,\n\t222, 224, 80, 225, 73, 74, 273, 212, 212, 232,\n\t132, 223, 234, 216, 120, 271, 73, 74, 191, 239,\n\t43, 44, 83, 82, 85, 84, 274, 270, 96, 91,\n\t92, 93, 94, 95, 73, 74, 93, 94, 95, 249,\n\t84, 164, 251, 252, 196, 236, 267, 250, 197, 130,\n\t25, 256, 73, 74, 262, 263, 187, 188, 3, 190,\n\t257, 258, 260, 261, 264, 24, 266, 73, 74, 9,\n\t221, 268, 269, 117, 117, 111, 171, 272, 172, 170,\n\t13, 275, 276, 77, 90, 277, 89, 212, 212, 13,\n\t177, 281, 52, 53, 54, 55, 56, 57, 58, 59,\n\t60, 61, 62, 63, 64, 65, 66, 67, 68, 69,\n\t70, 71, 72, 106, 107, 91, 92, 93, 94, 95,\n\t47, 43, 44, 101, 165, 259, 91, 92, 93, 94,\n\t95, 242, 156, 122, 194, 17, 192, 15, 37, 21,\n\t22, 23, 33, 133, 105, 205, 7, 34, 209, 35,\n\t36, 39, 41, 40, 42, 19, 20, 28, 31, 43,\n\t44, 8, 4, 2, 86, 87, 1, 90, 88, 89,\n\t0, 29, 30, 0, 168, 90, 18, 0, 0, 27,\n\t0, 142, 38, 0, 140, 26, 52, 53, 54, 55,\n\t56, 57, 58, 59, 60, 61, 62, 63, 64, 65,\n\t66, 67, 68, 69, 70, 71, 72, 106, 107, 91,\n\t92, 93, 94, 95, 0, 43, 44, 91, 92, 93,\n\t94, 95, 0, 0, 0, 0, 0, 11, 12, 17,\n\t0, 15, 37, 21, 22, 23, 33, 0, 105, 0,\n\t0, 34, 100, 35, 36, 39, 41, 40, 42, 19,\n\t20, 28, 31, 43, 44, 0, 0, 0, 0, 86,\n\t87, 0, 90, 88, 89, 29, 30, 0, 0, 167,\n\t18, 0, 0, 27, 0, 0, 38, 0, 17, 26,\n\t15, 37, 21, 22, 23, 33, 0, 0, 0, 0,\n\t34, 0, 35, 36, 39, 41, 40, 42, 19, 20,\n\t28, 31, 43, 44, 91, 92, 93, 94, 95, 0,\n\t0, 0, 0, 0, 29, 30, 90, 88, 89, 18,\n\t0, 0, 27, 0, 0, 38, 0, 233, 26, 17,\n\t0, 15, 37, 21, 22, 23, 33, 0, 0, 0,\n\t0, 34, 0, 35, 36, 39, 41, 40, 42, 19,\n\t20, 28, 31, 43, 44, 0, 0, 0, 91, 92,\n\t93, 94, 95, 0, 0, 29, 30, 0, 0, 0,\n\t18, 0, 0, 27, 0, 0, 38, 0, 109, 26,\n\t17, 0, 15, 37, 21, 22, 23, 33, 0, 0,\n\t0, 0, 34, 0, 35, 36, 39, 41, 40, 42,\n\t19, 20, 28, 31, 43, 44, 0, 0, 0, 0,\n\t0, 0, 0, 0, 0, 0, 29, 30, 0, 0,\n\t0, 18, 0, 0, 27, 0, 0, 38, 0, 0,\n\t26, 52, 53, 54, 55, 56, 57, 58, 59, 60,\n\t61, 62, 63, 64, 65, 66, 67, 68, 69, 70,\n\t71, 72, 49, 0, 0, 0, 0, 0, 0, 0,\n\t51, 52, 53, 54, 55, 56, 57, 58, 59, 60,\n\t61, 62, 63, 64, 65, 66, 67, 68, 69, 70,\n\t71, 72, 49, 0, 0, 0, 0, 173, 0, 0,\n\t51, 37, 21, 22, 23, 33, 0, 0, 0, 0,\n\t34, 0, 35, 36, 39, 41, 40, 42, 19, 20,\n\t28, 31, 43, 44, 0, 0, 0, 46, 0, 0,\n\t0, 0, 0, 0, 29, 30, 0, 0, 0, 18,\n\t0, 0, 27, 0, 0, 38, 0, 0, 26, 52,\n\t53, 54, 55, 56, 57, 58, 59, 60, 61, 62,\n\t63, 64, 65, 66, 67, 68, 69, 70, 71, 72,\n\t106, 199, 0, 0, 0, 0, 0, 0, 43, 44,\n\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t0, 198,\n}\n\nvar yyPact = [...]int16{\n\t238, -1000, -1000, -48, 406, 98, 643, -1000, -1000, -1000,\n\t112, 150, 139, 557, 158, 184, 170, 189, 173, -1000,\n\t-1000, -1000, -1000, -1000, 18, -1000, 368, 506, -1000, 665,\n\t665, 144, -1000, 557, 665, 665, 665, 174, 557, -1000,\n\t-1000, -1000, -1000, -1000, -1000, -1000, -1000, -22, -1000, 90,\n\t86, 82, -1000, -1000, -1000, -1000, -1000, -1000, -1000, -1000,\n\t-1000, -1000, -1000, -1000, -1000, -1000, -1000, -1000, -1000, -1000,\n\t-1000, -1000, -1000, 557, 557, 225, -48, -1000, 112, -1,\n\t-1000, -1000, -1000, 173, 312, 115, 665, 665, 665, 665,\n\t665, 665, 665, 665, 665, 665, -5, -1000, -1000, 557,\n\t-1000, -27, -1000, 78, 46, 557, -1000, -1000, -1000, -1000,\n\t35, 557, 65, 65, -1000, 210, 162, 65, 445, 350,\n\t-1000, 119, 229, -1000, 613, 30, 30, 30, 112, -1000,\n\t217, 96, -1000, 202, -1000, -1000, -1, 721, -1000, -1000,\n\t-1000, 29, 557, 557, 170, 499, 267, 358, 256, 175,\n\t175, -1000, -1000, -1000, 557, 217, 40, 112, -1000, 274,\n\t665, 665, 103, -1000, 557, -1000, 665, -1, -1, -1000,\n\t-1000, -1000, 557, -1000, -1000, -1000, -1000, -1000, -1000, -1000,\n\t-1000, -1000, -1000, 6, -1000, -1000, -48, -1000, -1000, -1000,\n\t557, -1, 33, -1000, -32, -1000, 45, 44, 557, -1000,\n\t-1000, 455, 32, 112, 177, 28, -1000, -1000, 557, -1000,\n\t-1000, 110, 170, 110, 43, 112, -1000, 1, -16, 100,\n\t-1000, 22, -1000, 94, 112, -1000, -1000, -1, -1000, 721,\n\t-1, -1, 92, -1000, -2, -1000, -1000, 7, 217, 112,\n\t665, 665, 230, 557, 557, -1000, -1000, 30, -1000, -1000,\n\t-1000, -1000, -1000, -21, -1000, 557, -1000, 110, 110, 212,\n\t557, 557, 159, 147, -1000, -1, 138, -1000, 195, 112,\n\t557, 557, -1000, -1000, 557, 60, -28, 112, -1000, -1000,\n\t557, 3, -1000,\n}\n\nvar yyPgo = [...]int16{\n\t0, 356, 353, 352, 351, 14, 336, 259, 265, 335,\n\t0, 333, 1, 326, 324, 7, 36, 22, 8, 323,\n\t12, 322, 321, 315, 314, 313, 3, 9, 6, 13,\n\t310, 10, 280, 260, 2, 255, 240, 11, 4,\n}\n\nvar yyR1 = [...]int8{\n\t0, 1, 2, 2, 3, 3, 4, 4, 5, 5,\n\t6, 6, 7, 7, 8, 8, 9, 9, 34, 34,\n\t10, 10, 10, 10, 10, 10, 16, 16, 16, 16,\n\t16, 16, 16, 16, 16, 16, 16, 11, 11, 12,\n\t12, 12, 13, 13, 14, 14, 15, 15, 15, 15,\n\t17, 17, 17, 17, 17, 17, 17, 17, 17, 17,\n\t17, 17, 17, 17, 17, 17, 17, 17, 17, 17,\n\t17, 17, 17, 17, 17, 17, 17, 17, 17, 17,\n\t17, 17, 17, 17, 18, 18, 19, 19, 19, 35,\n\t35, 36, 36, 20, 20, 20, 20, 20, 21, 21,\n\t22, 22, 23, 23, 24, 24, 25, 25, 26, 26,\n\t26, 26, 26, 38, 38, 38, 27, 27, 28, 28,\n\t28, 28, 28, 28, 28, 29, 29, 29, 30, 30,\n\t31, 31, 31, 32, 32, 33, 33, 37, 37, 37,\n\t37, 37, 37, 37, 37, 37, 37, 37, 37, 37,\n\t37, 37, 37, 37, 37, 37, 37, 37,\n}\n\nvar yyR2 = [...]int8{\n\t0, 3, 0, 3, 0, 2, 6, 4, 0, 1,\n\t1, 1, 0, 2, 5, 8, 1, 3, 1, 1,\n\t2, 3, 5, 4, 3, 1, 3, 3, 3, 3,\n\t3, 3, 3, 3, 3, 3, 1, 1, 3, 1,\n\t3, 3, 1, 3, 1, 3, 3, 3, 5, 1,\n\t1, 1, 1, 2, 2, 1, 1, 1, 1, 4,\n\t1, 2, 3, 4, 2, 3, 1, 2, 2, 1,\n\t2, 1, 7, 3, 9, 9, 11, 2, 3, 2,\n\t2, 2, 3, 3, 1, 3, 0, 2, 4, 1,\n\t1, 1, 1, 2, 3, 4, 4, 5, 1, 3,\n\t0, 5, 0, 2, 0, 2, 1, 3, 3, 3,\n\t5, 1, 1, 1, 1, 1, 3, 1, 1, 1,\n\t1, 1, 1, 1, 1, 2, 3, 4, 1, 3,\n\t3, 3, 3, 2, 3, 1, 3, 1, 1, 1,\n\t1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n\t1, 1, 1, 1, 1, 1, 1, 1,\n}\n\nvar yyChk = [...]int16{\n\t-1000, -1, -2, 10, -3, -29, 63, -6, -4, -7,\n\t-10, 11, 12, -8, -17, 15, -16, 13, 54, 33,\n\t34, 17, 18, 19, -35, -36, 63, 57, 35, 49,\n\t50, 36, -18, 20, 25, 27, 28, 16, 60, 29,\n\t31, 30, 32, 37, 38, 58, 64, -30, -31, 29,\n\t-37, 37, 8, 9, 10, 11, 12, 13, 14, 15,\n\t16, 17, 18, 19, 20, 21, 22, 23, 24, 25,\n\t26, 27, 28, 47, 48, 37, 37, -7, -10, 14,\n\t34, -20, 55, 54, 57, 30, 4, 5, 8, 9,\n\t7, 49, 50, 51, 52, 53, 29, -20, -18, 60,\n\t64, -25, -26, -38, -18, 60, 29, 30, -37, 62,\n\t-10, -8, -17, -17, -18, -10, -16, -17, -16, -16,\n\t30, -10, -19, 64, 48, 59, 59, 59, -10, -10,\n\t14, -5, -29, -11, -12, 30, 57, 63, -20, -18,\n\t62, -10, 59, 47, -16, -16, -16, -16, -16, -16,\n\t-16, -16, -16, -16, 59, 60, -21, -10, 64, 48,\n\t59, 59, -10, 62, 21, -24, 26, 14, 14, 61,\n\t40, 37, 39, 64, -31, -28, -29, -32, 35, 37,\n\t17, 18, 19, 57, -28, -28, -34, 29, 30, 58,\n\t47, 6, -13, -12, -14, -15, -38, -18, 60, 30,\n\t62, 59, -10, -10, -10, -9, -34, 61, 58, 64,\n\t-26, -27, -16, -27, 61, -10, -16, -12, -12, -10,\n\t62, -33, -28, -5, -10, -12, 62, 48, 64, 48,\n\t59, 59, -10, 62, -10, 62, 58, 61, 58, -10,\n\t47, 59, -22, 60, 60, 61, 62, 48, 58, -12,\n\t-15, -12, -12, 61, 62, 59, -34, -27, -27, -23,\n\t22, 23, -10, -10, -28, 59, -10, 24, -10, -10,\n\t58, 58, -12, 58, 21, -10, -10, -10, 61, 61,\n\t58, -10, 61,\n}\n\nvar yyDef = [...]int16{\n\t2, -2, 4, 0, 12, 0, 0, 1, 5, 10,\n\t11, 0, 0, 12, 36, 0, 25, 0, 50, 51,\n\t52, 55, 56, 57, 58, 60, 0, 0, 66, 0,\n\t0, 69, 71, 0, 0, 0, 0, 0, 0, 89,\n\t90, 91, 92, 84, 86, 3, 125, 0, 128, 0,\n\t0, 0, 137, 138, 139, 140, 141, 142, 143, 144,\n\t145, 146, 147, 148, 149, 150, 151, 152, 153, 154,\n\t155, 156, 157, 0, 0, 0, 8, 13, 20, 0,\n\t79, 80, 81, 0, 0, 0, 0, 0, 0, 0,\n\t0, 0, 0, 0, 0, 0, 0, 53, 54, 0,\n\t61, 0, 106, 111, 112, 0, 113, 114, 115, 64,\n\t0, 0, 67, 68, 70, 0, 104, 36, 0, 0,\n\t77, 0, 0, 126, 0, 0, 0, 0, 21, 24,\n\t0, 0, 9, 0, 37, 39, 0, 0, 82, 83,\n\t93, 0, 0, 0, 26, -2, 28, 29, -2, 31,\n\t32, 33, 34, 35, 0, 0, 0, 98, 62, 0,\n\t0, 0, 0, 65, 0, 73, 0, 0, 0, 78,\n\t85, 87, 0, 127, 129, 130, 118, 119, 120, 121,\n\t122, 123, 124, 0, 131, 132, 8, 18, 19, 7,\n\t0, 0, 0, 42, 0, 44, 0, 0, 0, -2,\n\t94, 0, 0, 23, 0, 0, 16, 59, 0, 63,\n\t107, 108, 117, 109, 0, 100, 105, 0, 0, 0,\n\t133, 0, 135, 0, 22, 38, 40, 0, 41, 0,\n\t0, 0, 0, 95, 0, 96, 14, 0, 0, 99,\n\t0, 0, 102, 0, 0, 88, 134, 0, 6, 43,\n\t45, 46, 47, 0, 97, 0, 17, 116, 110, 0,\n\t0, 0, 0, 0, 136, 0, 0, 72, 0, 103,\n\t0, 0, 48, 15, 0, 0, 0, 101, 74, 75,\n\t0, 0, 76,\n}\n\nvar yyTok1 = [...]int8{\n\t1, 3, 3, 3, 3, 3, 3, 3, 3, 3,\n\t3, 3, 3, 3, 3, 3, 3, 3, 3, 3,\n\t3, 3, 3, 3, 3, 3, 3, 3, 3, 3,\n\t3, 3, 3, 3, 3, 3, 3, 53, 3, 3,\n\t60, 61, 51, 49, 48, 50, 54, 52, 3, 3,\n\t3, 3, 3, 3, 3, 3, 3, 3, 59, 58,\n\t3, 3, 3, 55, 3, 3, 3, 3, 3, 3,\n\t3, 3, 3, 3, 3, 3, 3, 3, 3, 3,\n\t3, 3, 3, 3, 3, 3, 3, 3, 3, 3,\n\t3, 57, 3, 62, 3, 3, 3, 3, 3, 3,\n\t3, 3, 3, 3, 3, 3, 3, 3, 3, 3,\n\t3, 3, 3, 3, 3, 3, 3, 3, 3, 3,\n\t3, 3, 3, 63, 47, 64,\n}\n\nvar yyTok2 = [...]int8{\n\t2, 3, 4, 5, 6, 7, 8, 9, 10, 11,\n\t12, 13, 14, 15, 16, 17, 18, 19, 20, 21,\n\t22, 23, 24, 25, 26, 27, 28, 29, 30, 31,\n\t32, 33, 34, 35, 36, 37, 38, 39, 40, 41,\n\t42, 43, 44, 45, 46, 56,\n}\n\nvar yyTok3 = [...]int8{\n\t0,\n}\n\nvar yyErrorMessages = [...]struct {\n\tstate int\n\ttoken int\n\tmsg   string\n}{}\n\n//line yaccpar:1\n\n/*\tparser for yacc output\t*/\n\nvar (\n\tyyDebug        = 0\n\tyyErrorVerbose = false\n)\n\ntype yyLexer interface {\n\tLex(lval *yySymType) int\n\tError(s string)\n}\n\ntype yyParser interface {\n\tParse(yyLexer) int\n\tLookahead() int\n}\n\ntype yyParserImpl struct {\n\tlval  yySymType\n\tstack [yyInitialStackSize]yySymType\n\tchar  int\n}\n\nfunc (p *yyParserImpl) Lookahead() int {\n\treturn p.char\n}\n\nfunc yyNewParser() yyParser {\n\treturn &yyParserImpl{}\n}\n\nconst yyFlag = -1000\n\nfunc yyTokname(c int) string {\n\tif c >= 1 && c-1 < len(yyToknames) {\n\t\tif yyToknames[c-1] != \"\" {\n\t\t\treturn yyToknames[c-1]\n\t\t}\n\t}\n\treturn __yyfmt__.Sprintf(\"tok-%v\", c)\n}\n\nfunc yyStatname(s int) string {\n\tif s >= 0 && s < len(yyStatenames) {\n\t\tif yyStatenames[s] != \"\" {\n\t\t\treturn yyStatenames[s]\n\t\t}\n\t}\n\treturn __yyfmt__.Sprintf(\"state-%v\", s)\n}\n\nfunc yyErrorMessage(state, lookAhead int) string {\n\tconst TOKSTART = 4\n\n\tif !yyErrorVerbose {\n\t\treturn \"syntax error\"\n\t}\n\n\tfor _, e := range yyErrorMessages {\n\t\tif e.state == state && e.token == lookAhead {\n\t\t\treturn \"syntax error: \" + e.msg\n\t\t}\n\t}\n\n\tres := \"syntax error: unexpected \" + yyTokname(lookAhead)\n\n\t// To match Bison, suggest at most four expected tokens.\n\texpected := make([]int, 0, 4)\n\n\t// Look for shiftable tokens.\n\tbase := int(yyPact[state])\n\tfor tok := TOKSTART; tok-1 < len(yyToknames); tok++ {\n\t\tif n := base + tok; n >= 0 && n < yyLast && int(yyChk[int(yyAct[n])]) == tok {\n\t\t\tif len(expected) == cap(expected) {\n\t\t\t\treturn res\n\t\t\t}\n\t\t\texpected = append(expected, tok)\n\t\t}\n\t}\n\n\tif yyDef[state] == -2 {\n\t\ti := 0\n\t\tfor yyExca[i] != -1 || int(yyExca[i+1]) != state {\n\t\t\ti += 2\n\t\t}\n\n\t\t// Look for tokens that we accept or reduce.\n\t\tfor i += 2; yyExca[i] >= 0; i += 2 {\n\t\t\ttok := int(yyExca[i])\n\t\t\tif tok < TOKSTART || yyExca[i+1] == 0 {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif len(expected) == cap(expected) {\n\t\t\t\treturn res\n\t\t\t}\n\t\t\texpected = append(expected, tok)\n\t\t}\n\n\t\t// If the default action is to accept or reduce, give up.\n\t\tif yyExca[i+1] != 0 {\n\t\t\treturn res\n\t\t}\n\t}\n\n\tfor i, tok := range expected {\n\t\tif i == 0 {\n\t\t\tres += \", expecting \"\n\t\t} else {\n\t\t\tres += \" or \"\n\t\t}\n\t\tres += yyTokname(tok)\n\t}\n\treturn res\n}\n\nfunc yylex1(lex yyLexer, lval *yySymType) (char, token int) {\n\ttoken = 0\n\tchar = lex.Lex(lval)\n\tif char <= 0 {\n\t\ttoken = int(yyTok1[0])\n\t\tgoto out\n\t}\n\tif char < len(yyTok1) {\n\t\ttoken = int(yyTok1[char])\n\t\tgoto out\n\t}\n\tif char >= yyPrivate {\n\t\tif char < yyPrivate+len(yyTok2) {\n\t\t\ttoken = int(yyTok2[char-yyPrivate])\n\t\t\tgoto out\n\t\t}\n\t}\n\tfor i := 0; i < len(yyTok3); i += 2 {\n\t\ttoken = int(yyTok3[i+0])\n\t\tif token == char {\n\t\t\ttoken = int(yyTok3[i+1])\n\t\t\tgoto out\n\t\t}\n\t}\n\nout:\n\tif token == 0 {\n\t\ttoken = int(yyTok2[1]) /* unknown char */\n\t}\n\tif yyDebug >= 3 {\n\t\t__yyfmt__.Printf(\"lex %s(%d)\\n\", yyTokname(token), uint(char))\n\t}\n\treturn char, token\n}\n\nfunc yyParse(yylex yyLexer) int {\n\treturn yyNewParser().Parse(yylex)\n}\n\nfunc (yyrcvr *yyParserImpl) Parse(yylex yyLexer) int {\n\tvar yyn int\n\tvar yyVAL yySymType\n\tvar yyDollar []yySymType\n\t_ = yyDollar // silence set and not used\n\tyyS := yyrcvr.stack[:]\n\n\tNerrs := 0   /* number of errors */\n\tErrflag := 0 /* error recovery flag */\n\tyystate := 0\n\tyyrcvr.char = -1\n\tyytoken := -1 // yyrcvr.char translated into internal numbering\n\tdefer func() {\n\t\t// Make sure we report no lookahead when not parsing.\n\t\tyystate = -1\n\t\tyyrcvr.char = -1\n\t\tyytoken = -1\n\t}()\n\tyyp := -1\n\tgoto yystack\n\nret0:\n\treturn 0\n\nret1:\n\treturn 1\n\nyystack:\n\t/* put a state and value onto the stack */\n\tif yyDebug >= 4 {\n\t\t__yyfmt__.Printf(\"char %v in %v\\n\", yyTokname(yytoken), yyStatname(yystate))\n\t}\n\n\tyyp++\n\tif yyp >= len(yyS) {\n\t\tnyys := make([]yySymType, len(yyS)*2)\n\t\tcopy(nyys, yyS)\n\t\tyyS = nyys\n\t}\n\tyyS[yyp] = yyVAL\n\tyyS[yyp].yys = yystate\n\nyynewstate:\n\tyyn = int(yyPact[yystate])\n\tif yyn <= yyFlag {\n\t\tgoto yydefault /* simple state */\n\t}\n\tif yyrcvr.char < 0 {\n\t\tyyrcvr.char, yytoken = yylex1(yylex, &yyrcvr.lval)\n\t}\n\tyyn += yytoken\n\tif yyn < 0 || yyn >= yyLast {\n\t\tgoto yydefault\n\t}\n\tyyn = int(yyAct[yyn])\n\tif int(yyChk[yyn]) == yytoken { /* valid shift */\n\t\tyyrcvr.char = -1\n\t\tyytoken = -1\n\t\tyyVAL = yyrcvr.lval\n\t\tyystate = yyn\n\t\tif Errflag > 0 {\n\t\t\tErrflag--\n\t\t}\n\t\tgoto yystack\n\t}\n\nyydefault:\n\t/* default state action */\n\tyyn = int(yyDef[yystate])\n\tif yyn == -2 {\n\t\tif yyrcvr.char < 0 {\n\t\t\tyyrcvr.char, yytoken = yylex1(yylex, &yyrcvr.lval)\n\t\t}\n\n\t\t/* look through exception table */\n\t\txi := 0\n\t\tfor {\n\t\t\tif yyExca[xi+0] == -1 && int(yyExca[xi+1]) == yystate {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\txi += 2\n\t\t}\n\t\tfor xi += 2; ; xi += 2 {\n\t\t\tyyn = int(yyExca[xi+0])\n\t\t\tif yyn < 0 || yyn == yytoken {\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tyyn = int(yyExca[xi+1])\n\t\tif yyn < 0 {\n\t\t\tgoto ret0\n\t\t}\n\t}\n\tif yyn == 0 {\n\t\t/* error ... attempt to resume parsing */\n\t\tswitch Errflag {\n\t\tcase 0: /* brand new error */\n\t\t\tyylex.Error(yyErrorMessage(yystate, yytoken))\n\t\t\tNerrs++\n\t\t\tif yyDebug >= 1 {\n\t\t\t\t__yyfmt__.Printf(\"%s\", yyStatname(yystate))\n\t\t\t\t__yyfmt__.Printf(\" saw %s\\n\", yyTokname(yytoken))\n\t\t\t}\n\t\t\tfallthrough\n\n\t\tcase 1, 2: /* incompletely recovered error ... try again */\n\t\t\tErrflag = 3\n\n\t\t\t/* find a state where \"error\" is a legal shift action */\n\t\t\tfor yyp >= 0 {\n\t\t\t\tyyn = int(yyPact[yyS[yyp].yys]) + yyErrCode\n\t\t\t\tif yyn >= 0 && yyn < yyLast {\n\t\t\t\t\tyystate = int(yyAct[yyn]) /* simulate a shift of \"error\" */\n\t\t\t\t\tif int(yyChk[yystate]) == yyErrCode {\n\t\t\t\t\t\tgoto yystack\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t/* the current p has no shift on \"error\", pop stack */\n\t\t\t\tif yyDebug >= 2 {\n\t\t\t\t\t__yyfmt__.Printf(\"error recovery pops state %d\\n\", yyS[yyp].yys)\n\t\t\t\t}\n\t\t\t\tyyp--\n\t\t\t}\n\t\t\t/* there is no state on the stack with an error shift ... abort */\n\t\t\tgoto ret1\n\n\t\tcase 3: /* no shift yet; clobber input char */\n\t\t\tif yyDebug >= 2 {\n\t\t\t\t__yyfmt__.Printf(\"error recovery discards %s\\n\", yyTokname(yytoken))\n\t\t\t}\n\t\t\tif yytoken == yyEofCode {\n\t\t\t\tgoto ret1\n\t\t\t}\n\t\t\tyyrcvr.char = -1\n\t\t\tyytoken = -1\n\t\t\tgoto yynewstate /* try again in the same state */\n\t\t}\n\t}\n\n\t/* reduction by production yyn */\n\tif yyDebug >= 2 {\n\t\t__yyfmt__.Printf(\"reduce %v in:\\n\\t%v\\n\", yyn, yyStatname(yystate))\n\t}\n\n\tyynt := yyn\n\tyypt := yyp\n\t_ = yypt // guard against \"declared and not used\"\n\n\tyyp -= int(yyR2[yyn])\n\t// yyp is now the index of $0. Perform the default action. Iff the\n\t// reduced production is ε, $1 is possibly out of range.\n\tif yyp+1 >= len(yyS) {\n\t\tnyys := make([]yySymType, len(yyS)*2)\n\t\tcopy(nyys, yyS)\n\t\tyyS = nyys\n\t}\n\tyyVAL = yyS[yyp+1]\n\n\t/* consult goto table to find next state */\n\tyyn = int(yyR1[yyn])\n\tyyg := int(yyPgo[yyn])\n\tyyj := yyg + yyS[yyp].yys + 1\n\n\tif yyj >= yyLast {\n\t\tyystate = int(yyAct[yyg])\n\t} else {\n\t\tyystate = int(yyAct[yyj])\n\t\tif int(yyChk[yystate]) != -yyn {\n\t\t\tyystate = int(yyAct[yyg])\n\t\t}\n\t}\n\t// dummy call; replaced with literal code\n\tswitch yynt {\n\n\tcase 1:\n\t\tyyDollar = yyS[yypt-3 : yypt+1]\n//line parser.go.y:58\n\t\t{\n\t\t\tquery := yyDollar[3].value.(*Query)\n\t\t\tquery.Meta = yyDollar[1].value.(*ConstObject)\n\t\t\tquery.Imports = yyDollar[2].value.([]*Import)\n\t\t\tyylex.(*lexer).result = query\n\t\t}\n\tcase 2:\n\t\tyyDollar = yyS[yypt-0 : yypt+1]\n//line parser.go.y:67\n\t\t{\n\t\t\tyyVAL.value = (*ConstObject)(nil)\n\t\t}\n\tcase 3:\n\t\tyyDollar = yyS[yypt-3 : yypt+1]\n//line parser.go.y:71\n\t\t{\n\t\t\tyyVAL.value = yyDollar[2].value\n\t\t}\n\tcase 4:\n\t\tyyDollar = yyS[yypt-0 : yypt+1]\n//line parser.go.y:77\n\t\t{\n\t\t\tyyVAL.value = []*Import(nil)\n\t\t}\n\tcase 5:\n\t\tyyDollar = yyS[yypt-2 : yypt+1]\n//line parser.go.y:81\n\t\t{\n\t\t\tyyVAL.value = append(yyDollar[1].value.([]*Import), yyDollar[2].value.(*Import))\n\t\t}\n\tcase 6:\n\t\tyyDollar = yyS[yypt-6 : yypt+1]\n//line parser.go.y:87\n\t\t{\n\t\t\tyyVAL.value = &Import{ImportPath: yyDollar[2].token, ImportAlias: yyDollar[4].token, Meta: yyDollar[5].value.(*ConstObject)}\n\t\t}\n\tcase 7:\n\t\tyyDollar = yyS[yypt-4 : yypt+1]\n//line parser.go.y:91\n\t\t{\n\t\t\tyyVAL.value = &Import{IncludePath: yyDollar[2].token, Meta: yyDollar[3].value.(*ConstObject)}\n\t\t}\n\tcase 8:\n\t\tyyDollar = yyS[yypt-0 : yypt+1]\n//line parser.go.y:97\n\t\t{\n\t\t\tyyVAL.value = (*ConstObject)(nil)\n\t\t}\n\tcase 10:\n\t\tyyDollar = yyS[yypt-1 : yypt+1]\n//line parser.go.y:104\n\t\t{\n\t\t\tyyVAL.value = &Query{FuncDefs: reverseFuncDef(yyDollar[1].value.([]*FuncDef))}\n\t\t}\n\tcase 12:\n\t\tyyDollar = yyS[yypt-0 : yypt+1]\n//line parser.go.y:111\n\t\t{\n\t\t\tyyVAL.value = []*FuncDef(nil)\n\t\t}\n\tcase 13:\n\t\tyyDollar = yyS[yypt-2 : yypt+1]\n//line parser.go.y:115\n\t\t{\n\t\t\tyyVAL.value = append(yyDollar[2].value.([]*FuncDef), yyDollar[1].value.(*FuncDef))\n\t\t}\n\tcase 14:\n\t\tyyDollar = yyS[yypt-5 : yypt+1]\n//line parser.go.y:121\n\t\t{\n\t\t\tyyVAL.value = &FuncDef{Name: yyDollar[2].token, Body: yyDollar[4].value.(*Query)}\n\t\t}\n\tcase 15:\n\t\tyyDollar = yyS[yypt-8 : yypt+1]\n//line parser.go.y:125\n\t\t{\n\t\t\tyyVAL.value = &FuncDef{yyDollar[2].token, yyDollar[4].value.([]string), yyDollar[7].value.(*Query)}\n\t\t}\n\tcase 16:\n\t\tyyDollar = yyS[yypt-1 : yypt+1]\n//line parser.go.y:131\n\t\t{\n\t\t\tyyVAL.value = []string{yyDollar[1].token}\n\t\t}\n\tcase 17:\n\t\tyyDollar = yyS[yypt-3 : yypt+1]\n//line parser.go.y:135\n\t\t{\n\t\t\tyyVAL.value = append(yyDollar[1].value.([]string), yyDollar[3].token)\n\t\t}\n\tcase 20:\n\t\tyyDollar = yyS[yypt-2 : yypt+1]\n//line parser.go.y:145\n\t\t{\n\t\t\tquery := yyDollar[2].value.(*Query)\n\t\t\tquery.FuncDefs = prependFuncDef(query.FuncDefs, yyDollar[1].value.(*FuncDef))\n\t\t\tyyVAL.value = query\n\t\t}\n\tcase 21:\n\t\tyyDollar = yyS[yypt-3 : yypt+1]\n//line parser.go.y:151\n\t\t{\n\t\t\tyyVAL.value = &Query{Left: yyDollar[1].value.(*Query), Op: OpPipe, Right: yyDollar[3].value.(*Query)}\n\t\t}\n\tcase 22:\n\t\tyyDollar = yyS[yypt-5 : yypt+1]\n//line parser.go.y:155\n\t\t{\n\t\t\tterm := yyDollar[1].value.(*Term)\n\t\t\tterm.SuffixList = append(term.SuffixList, &Suffix{Bind: &Bind{yyDollar[3].value.([]*Pattern), yyDollar[5].value.(*Query)}})\n\t\t\tyyVAL.value = &Query{Term: term}\n\t\t}\n\tcase 23:\n\t\tyyDollar = yyS[yypt-4 : yypt+1]\n//line parser.go.y:161\n\t\t{\n\t\t\tyyVAL.value = &Query{Term: &Term{Type: TermTypeLabel, Label: &Label{yyDollar[2].token, yyDollar[4].value.(*Query)}}}\n\t\t}\n\tcase 24:\n\t\tyyDollar = yyS[yypt-3 : yypt+1]\n//line parser.go.y:165\n\t\t{\n\t\t\tyyVAL.value = &Query{Left: yyDollar[1].value.(*Query), Op: OpComma, Right: yyDollar[3].value.(*Query)}\n\t\t}\n\tcase 26:\n\t\tyyDollar = yyS[yypt-3 : yypt+1]\n//line parser.go.y:172\n\t\t{\n\t\t\tyyVAL.value = &Query{Left: yyDollar[1].value.(*Query), Op: yyDollar[2].operator, Right: yyDollar[3].value.(*Query)}\n\t\t}\n\tcase 27:\n\t\tyyDollar = yyS[yypt-3 : yypt+1]\n//line parser.go.y:176\n\t\t{\n\t\t\tyyVAL.value = &Query{Left: yyDollar[1].value.(*Query), Op: yyDollar[2].operator, Right: yyDollar[3].value.(*Query)}\n\t\t}\n\tcase 28:\n\t\tyyDollar = yyS[yypt-3 : yypt+1]\n//line parser.go.y:180\n\t\t{\n\t\t\tyyVAL.value = &Query{Left: yyDollar[1].value.(*Query), Op: OpOr, Right: yyDollar[3].value.(*Query)}\n\t\t}\n\tcase 29:\n\t\tyyDollar = yyS[yypt-3 : yypt+1]\n//line parser.go.y:184\n\t\t{\n\t\t\tyyVAL.value = &Query{Left: yyDollar[1].value.(*Query), Op: OpAnd, Right: yyDollar[3].value.(*Query)}\n\t\t}\n\tcase 30:\n\t\tyyDollar = yyS[yypt-3 : yypt+1]\n//line parser.go.y:188\n\t\t{\n\t\t\tyyVAL.value = &Query{Left: yyDollar[1].value.(*Query), Op: yyDollar[2].operator, Right: yyDollar[3].value.(*Query)}\n\t\t}\n\tcase 31:\n\t\tyyDollar = yyS[yypt-3 : yypt+1]\n//line parser.go.y:192\n\t\t{\n\t\t\tyyVAL.value = &Query{Left: yyDollar[1].value.(*Query), Op: OpAdd, Right: yyDollar[3].value.(*Query)}\n\t\t}\n\tcase 32:\n\t\tyyDollar = yyS[yypt-3 : yypt+1]\n//line parser.go.y:196\n\t\t{\n\t\t\tyyVAL.value = &Query{Left: yyDollar[1].value.(*Query), Op: OpSub, Right: yyDollar[3].value.(*Query)}\n\t\t}\n\tcase 33:\n\t\tyyDollar = yyS[yypt-3 : yypt+1]\n//line parser.go.y:200\n\t\t{\n\t\t\tyyVAL.value = &Query{Left: yyDollar[1].value.(*Query), Op: OpMul, Right: yyDollar[3].value.(*Query)}\n\t\t}\n\tcase 34:\n\t\tyyDollar = yyS[yypt-3 : yypt+1]\n//line parser.go.y:204\n\t\t{\n\t\t\tyyVAL.value = &Query{Left: yyDollar[1].value.(*Query), Op: OpDiv, Right: yyDollar[3].value.(*Query)}\n\t\t}\n\tcase 35:\n\t\tyyDollar = yyS[yypt-3 : yypt+1]\n//line parser.go.y:208\n\t\t{\n\t\t\tyyVAL.value = &Query{Left: yyDollar[1].value.(*Query), Op: OpMod, Right: yyDollar[3].value.(*Query)}\n\t\t}\n\tcase 36:\n\t\tyyDollar = yyS[yypt-1 : yypt+1]\n//line parser.go.y:212\n\t\t{\n\t\t\tyyVAL.value = &Query{Term: yyDollar[1].value.(*Term)}\n\t\t}\n\tcase 37:\n\t\tyyDollar = yyS[yypt-1 : yypt+1]\n//line parser.go.y:218\n\t\t{\n\t\t\tyyVAL.value = []*Pattern{yyDollar[1].value.(*Pattern)}\n\t\t}\n\tcase 38:\n\t\tyyDollar = yyS[yypt-3 : yypt+1]\n//line parser.go.y:222\n\t\t{\n\t\t\tyyVAL.value = append(yyDollar[1].value.([]*Pattern), yyDollar[3].value.(*Pattern))\n\t\t}\n\tcase 39:\n\t\tyyDollar = yyS[yypt-1 : yypt+1]\n//line parser.go.y:228\n\t\t{\n\t\t\tyyVAL.value = &Pattern{Name: yyDollar[1].token}\n\t\t}\n\tcase 40:\n\t\tyyDollar = yyS[yypt-3 : yypt+1]\n//line parser.go.y:232\n\t\t{\n\t\t\tyyVAL.value = &Pattern{Array: yyDollar[2].value.([]*Pattern)}\n\t\t}\n\tcase 41:\n\t\tyyDollar = yyS[yypt-3 : yypt+1]\n//line parser.go.y:236\n\t\t{\n\t\t\tyyVAL.value = &Pattern{Object: yyDollar[2].value.([]*PatternObject)}\n\t\t}\n\tcase 42:\n\t\tyyDollar = yyS[yypt-1 : yypt+1]\n//line parser.go.y:242\n\t\t{\n\t\t\tyyVAL.value = []*Pattern{yyDollar[1].value.(*Pattern)}\n\t\t}\n\tcase 43:\n\t\tyyDollar = yyS[yypt-3 : yypt+1]\n//line parser.go.y:246\n\t\t{\n\t\t\tyyVAL.value = append(yyDollar[1].value.([]*Pattern), yyDollar[3].value.(*Pattern))\n\t\t}\n\tcase 44:\n\t\tyyDollar = yyS[yypt-1 : yypt+1]\n//line parser.go.y:252\n\t\t{\n\t\t\tyyVAL.value = []*PatternObject{yyDollar[1].value.(*PatternObject)}\n\t\t}\n\tcase 45:\n\t\tyyDollar = yyS[yypt-3 : yypt+1]\n//line parser.go.y:256\n\t\t{\n\t\t\tyyVAL.value = append(yyDollar[1].value.([]*PatternObject), yyDollar[3].value.(*PatternObject))\n\t\t}\n\tcase 46:\n\t\tyyDollar = yyS[yypt-3 : yypt+1]\n//line parser.go.y:262\n\t\t{\n\t\t\tyyVAL.value = &PatternObject{Key: yyDollar[1].token, Val: yyDollar[3].value.(*Pattern)}\n\t\t}\n\tcase 47:\n\t\tyyDollar = yyS[yypt-3 : yypt+1]\n//line parser.go.y:266\n\t\t{\n\t\t\tyyVAL.value = &PatternObject{KeyString: yyDollar[1].value.(*String), Val: yyDollar[3].value.(*Pattern)}\n\t\t}\n\tcase 48:\n\t\tyyDollar = yyS[yypt-5 : yypt+1]\n//line parser.go.y:270\n\t\t{\n\t\t\tyyVAL.value = &PatternObject{KeyQuery: yyDollar[2].value.(*Query), Val: yyDollar[5].value.(*Pattern)}\n\t\t}\n\tcase 49:\n\t\tyyDollar = yyS[yypt-1 : yypt+1]\n//line parser.go.y:274\n\t\t{\n\t\t\tyyVAL.value = &PatternObject{Key: yyDollar[1].token}\n\t\t}\n\tcase 50:\n\t\tyyDollar = yyS[yypt-1 : yypt+1]\n//line parser.go.y:280\n\t\t{\n\t\t\tyyVAL.value = &Term{Type: TermTypeIdentity}\n\t\t}\n\tcase 51:\n\t\tyyDollar = yyS[yypt-1 : yypt+1]\n//line parser.go.y:284\n\t\t{\n\t\t\tyyVAL.value = &Term{Type: TermTypeRecurse}\n\t\t}\n\tcase 52:\n\t\tyyDollar = yyS[yypt-1 : yypt+1]\n//line parser.go.y:288\n\t\t{\n\t\t\tyyVAL.value = &Term{Type: TermTypeIndex, Index: &Index{Name: yyDollar[1].token}}\n\t\t}\n\tcase 53:\n\t\tyyDollar = yyS[yypt-2 : yypt+1]\n//line parser.go.y:292\n\t\t{\n\t\t\tsuffix := yyDollar[2].value.(*Suffix)\n\t\t\tif suffix.Iter {\n\t\t\t\tyyVAL.value = &Term{Type: TermTypeIdentity, SuffixList: []*Suffix{suffix}}\n\t\t\t} else {\n\t\t\t\tyyVAL.value = &Term{Type: TermTypeIndex, Index: suffix.Index}\n\t\t\t}\n\t\t}\n\tcase 54:\n\t\tyyDollar = yyS[yypt-2 : yypt+1]\n//line parser.go.y:301\n\t\t{\n\t\t\tyyVAL.value = &Term{Type: TermTypeIndex, Index: &Index{Str: yyDollar[2].value.(*String)}}\n\t\t}\n\tcase 55:\n\t\tyyDollar = yyS[yypt-1 : yypt+1]\n//line parser.go.y:305\n\t\t{\n\t\t\tyyVAL.value = &Term{Type: TermTypeNull}\n\t\t}\n\tcase 56:\n\t\tyyDollar = yyS[yypt-1 : yypt+1]\n//line parser.go.y:309\n\t\t{\n\t\t\tyyVAL.value = &Term{Type: TermTypeTrue}\n\t\t}\n\tcase 57:\n\t\tyyDollar = yyS[yypt-1 : yypt+1]\n//line parser.go.y:313\n\t\t{\n\t\t\tyyVAL.value = &Term{Type: TermTypeFalse}\n\t\t}\n\tcase 58:\n\t\tyyDollar = yyS[yypt-1 : yypt+1]\n//line parser.go.y:317\n\t\t{\n\t\t\tyyVAL.value = &Term{Type: TermTypeFunc, Func: &Func{Name: yyDollar[1].token}}\n\t\t}\n\tcase 59:\n\t\tyyDollar = yyS[yypt-4 : yypt+1]\n//line parser.go.y:321\n\t\t{\n\t\t\tyyVAL.value = &Term{Type: TermTypeFunc, Func: &Func{Name: yyDollar[1].token, Args: yyDollar[3].value.([]*Query)}}\n\t\t}\n\tcase 60:\n\t\tyyDollar = yyS[yypt-1 : yypt+1]\n//line parser.go.y:325\n\t\t{\n\t\t\tyyVAL.value = &Term{Type: TermTypeFunc, Func: &Func{Name: yyDollar[1].token}}\n\t\t}\n\tcase 61:\n\t\tyyDollar = yyS[yypt-2 : yypt+1]\n//line parser.go.y:329\n\t\t{\n\t\t\tyyVAL.value = &Term{Type: TermTypeObject, Object: &Object{}}\n\t\t}\n\tcase 62:\n\t\tyyDollar = yyS[yypt-3 : yypt+1]\n//line parser.go.y:333\n\t\t{\n\t\t\tyyVAL.value = &Term{Type: TermTypeObject, Object: &Object{yyDollar[2].value.([]*ObjectKeyVal)}}\n\t\t}\n\tcase 63:\n\t\tyyDollar = yyS[yypt-4 : yypt+1]\n//line parser.go.y:337\n\t\t{\n\t\t\tyyVAL.value = &Term{Type: TermTypeObject, Object: &Object{yyDollar[2].value.([]*ObjectKeyVal)}}\n\t\t}\n\tcase 64:\n\t\tyyDollar = yyS[yypt-2 : yypt+1]\n//line parser.go.y:341\n\t\t{\n\t\t\tyyVAL.value = &Term{Type: TermTypeArray, Array: &Array{}}\n\t\t}\n\tcase 65:\n\t\tyyDollar = yyS[yypt-3 : yypt+1]\n//line parser.go.y:345\n\t\t{\n\t\t\tyyVAL.value = &Term{Type: TermTypeArray, Array: &Array{yyDollar[2].value.(*Query)}}\n\t\t}\n\tcase 66:\n\t\tyyDollar = yyS[yypt-1 : yypt+1]\n//line parser.go.y:349\n\t\t{\n\t\t\tyyVAL.value = &Term{Type: TermTypeNumber, Number: yyDollar[1].token}\n\t\t}\n\tcase 67:\n\t\tyyDollar = yyS[yypt-2 : yypt+1]\n//line parser.go.y:353\n\t\t{\n\t\t\tyyVAL.value = &Term{Type: TermTypeUnary, Unary: &Unary{OpAdd, yyDollar[2].value.(*Term)}}\n\t\t}\n\tcase 68:\n\t\tyyDollar = yyS[yypt-2 : yypt+1]\n//line parser.go.y:357\n\t\t{\n\t\t\tyyVAL.value = &Term{Type: TermTypeUnary, Unary: &Unary{OpSub, yyDollar[2].value.(*Term)}}\n\t\t}\n\tcase 69:\n\t\tyyDollar = yyS[yypt-1 : yypt+1]\n//line parser.go.y:361\n\t\t{\n\t\t\tyyVAL.value = &Term{Type: TermTypeFormat, Format: yyDollar[1].token}\n\t\t}\n\tcase 70:\n\t\tyyDollar = yyS[yypt-2 : yypt+1]\n//line parser.go.y:365\n\t\t{\n\t\t\tyyVAL.value = &Term{Type: TermTypeFormat, Format: yyDollar[1].token, Str: yyDollar[2].value.(*String)}\n\t\t}\n\tcase 71:\n\t\tyyDollar = yyS[yypt-1 : yypt+1]\n//line parser.go.y:369\n\t\t{\n\t\t\tyyVAL.value = &Term{Type: TermTypeString, Str: yyDollar[1].value.(*String)}\n\t\t}\n\tcase 72:\n\t\tyyDollar = yyS[yypt-7 : yypt+1]\n//line parser.go.y:373\n\t\t{\n\t\t\tyyVAL.value = &Term{Type: TermTypeIf, If: &If{yyDollar[2].value.(*Query), yyDollar[4].value.(*Query), yyDollar[5].value.([]*IfElif), yyDollar[6].value.(*Query)}}\n\t\t}\n\tcase 73:\n\t\tyyDollar = yyS[yypt-3 : yypt+1]\n//line parser.go.y:377\n\t\t{\n\t\t\tyyVAL.value = &Term{Type: TermTypeTry, Try: &Try{yyDollar[2].value.(*Query), yyDollar[3].value.(*Query)}}\n\t\t}\n\tcase 74:\n\t\tyyDollar = yyS[yypt-9 : yypt+1]\n//line parser.go.y:381\n\t\t{\n\t\t\tyyVAL.value = &Term{Type: TermTypeReduce, Reduce: &Reduce{yyDollar[2].value.(*Query), yyDollar[4].value.(*Pattern), yyDollar[6].value.(*Query), yyDollar[8].value.(*Query)}}\n\t\t}\n\tcase 75:\n\t\tyyDollar = yyS[yypt-9 : yypt+1]\n//line parser.go.y:385\n\t\t{\n\t\t\tyyVAL.value = &Term{Type: TermTypeForeach, Foreach: &Foreach{yyDollar[2].value.(*Query), yyDollar[4].value.(*Pattern), yyDollar[6].value.(*Query), yyDollar[8].value.(*Query), nil}}\n\t\t}\n\tcase 76:\n\t\tyyDollar = yyS[yypt-11 : yypt+1]\n//line parser.go.y:389\n\t\t{\n\t\t\tyyVAL.value = &Term{Type: TermTypeForeach, Foreach: &Foreach{yyDollar[2].value.(*Query), yyDollar[4].value.(*Pattern), yyDollar[6].value.(*Query), yyDollar[8].value.(*Query), yyDollar[10].value.(*Query)}}\n\t\t}\n\tcase 77:\n\t\tyyDollar = yyS[yypt-2 : yypt+1]\n//line parser.go.y:393\n\t\t{\n\t\t\tyyVAL.value = &Term{Type: TermTypeBreak, Break: yyDollar[2].token}\n\t\t}\n\tcase 78:\n\t\tyyDollar = yyS[yypt-3 : yypt+1]\n//line parser.go.y:397\n\t\t{\n\t\t\tyyVAL.value = &Term{Type: TermTypeQuery, Query: yyDollar[2].value.(*Query)}\n\t\t}\n\tcase 79:\n\t\tyyDollar = yyS[yypt-2 : yypt+1]\n//line parser.go.y:401\n\t\t{\n\t\t\tyyDollar[1].value.(*Term).SuffixList = append(yyDollar[1].value.(*Term).SuffixList, &Suffix{Index: &Index{Name: yyDollar[2].token}})\n\t\t}\n\tcase 80:\n\t\tyyDollar = yyS[yypt-2 : yypt+1]\n//line parser.go.y:405\n\t\t{\n\t\t\tyyDollar[1].value.(*Term).SuffixList = append(yyDollar[1].value.(*Term).SuffixList, yyDollar[2].value.(*Suffix))\n\t\t}\n\tcase 81:\n\t\tyyDollar = yyS[yypt-2 : yypt+1]\n//line parser.go.y:409\n\t\t{\n\t\t\tyyDollar[1].value.(*Term).SuffixList = append(yyDollar[1].value.(*Term).SuffixList, &Suffix{Optional: true})\n\t\t}\n\tcase 82:\n\t\tyyDollar = yyS[yypt-3 : yypt+1]\n//line parser.go.y:413\n\t\t{\n\t\t\tyyDollar[1].value.(*Term).SuffixList = append(yyDollar[1].value.(*Term).SuffixList, yyDollar[3].value.(*Suffix))\n\t\t}\n\tcase 83:\n\t\tyyDollar = yyS[yypt-3 : yypt+1]\n//line parser.go.y:417\n\t\t{\n\t\t\tyyDollar[1].value.(*Term).SuffixList = append(yyDollar[1].value.(*Term).SuffixList, &Suffix{Index: &Index{Str: yyDollar[3].value.(*String)}})\n\t\t}\n\tcase 84:\n\t\tyyDollar = yyS[yypt-1 : yypt+1]\n//line parser.go.y:423\n\t\t{\n\t\t\tyyVAL.value = &String{Str: yyDollar[1].token}\n\t\t}\n\tcase 85:\n\t\tyyDollar = yyS[yypt-3 : yypt+1]\n//line parser.go.y:427\n\t\t{\n\t\t\tyyVAL.value = &String{Queries: yyDollar[2].value.([]*Query)}\n\t\t}\n\tcase 86:\n\t\tyyDollar = yyS[yypt-0 : yypt+1]\n//line parser.go.y:433\n\t\t{\n\t\t\tyyVAL.value = []*Query{}\n\t\t}\n\tcase 87:\n\t\tyyDollar = yyS[yypt-2 : yypt+1]\n//line parser.go.y:437\n\t\t{\n\t\t\tyyVAL.value = append(yyDollar[1].value.([]*Query), &Query{Term: &Term{Type: TermTypeString, Str: &String{Str: yyDollar[2].token}}})\n\t\t}\n\tcase 88:\n\t\tyyDollar = yyS[yypt-4 : yypt+1]\n//line parser.go.y:441\n\t\t{\n\t\t\tyylex.(*lexer).inString = true\n\t\t\tyyVAL.value = append(yyDollar[1].value.([]*Query), &Query{Term: &Term{Type: TermTypeQuery, Query: yyDollar[3].value.(*Query)}})\n\t\t}\n\tcase 93:\n\t\tyyDollar = yyS[yypt-2 : yypt+1]\n//line parser.go.y:456\n\t\t{\n\t\t\tyyVAL.value = &Suffix{Iter: true}\n\t\t}\n\tcase 94:\n\t\tyyDollar = yyS[yypt-3 : yypt+1]\n//line parser.go.y:460\n\t\t{\n\t\t\tyyVAL.value = &Suffix{Index: &Index{Start: yyDollar[2].value.(*Query)}}\n\t\t}\n\tcase 95:\n\t\tyyDollar = yyS[yypt-4 : yypt+1]\n//line parser.go.y:464\n\t\t{\n\t\t\tyyVAL.value = &Suffix{Index: &Index{Start: yyDollar[2].value.(*Query), IsSlice: true}}\n\t\t}\n\tcase 96:\n\t\tyyDollar = yyS[yypt-4 : yypt+1]\n//line parser.go.y:468\n\t\t{\n\t\t\tyyVAL.value = &Suffix{Index: &Index{End: yyDollar[3].value.(*Query), IsSlice: true}}\n\t\t}\n\tcase 97:\n\t\tyyDollar = yyS[yypt-5 : yypt+1]\n//line parser.go.y:472\n\t\t{\n\t\t\tyyVAL.value = &Suffix{Index: &Index{Start: yyDollar[2].value.(*Query), End: yyDollar[4].value.(*Query), IsSlice: true}}\n\t\t}\n\tcase 98:\n\t\tyyDollar = yyS[yypt-1 : yypt+1]\n//line parser.go.y:478\n\t\t{\n\t\t\tyyVAL.value = []*Query{yyDollar[1].value.(*Query)}\n\t\t}\n\tcase 99:\n\t\tyyDollar = yyS[yypt-3 : yypt+1]\n//line parser.go.y:482\n\t\t{\n\t\t\tyyVAL.value = append(yyDollar[1].value.([]*Query), yyDollar[3].value.(*Query))\n\t\t}\n\tcase 100:\n\t\tyyDollar = yyS[yypt-0 : yypt+1]\n//line parser.go.y:488\n\t\t{\n\t\t\tyyVAL.value = []*IfElif(nil)\n\t\t}\n\tcase 101:\n\t\tyyDollar = yyS[yypt-5 : yypt+1]\n//line parser.go.y:492\n\t\t{\n\t\t\tyyVAL.value = append(yyDollar[1].value.([]*IfElif), &IfElif{yyDollar[3].value.(*Query), yyDollar[5].value.(*Query)})\n\t\t}\n\tcase 102:\n\t\tyyDollar = yyS[yypt-0 : yypt+1]\n//line parser.go.y:498\n\t\t{\n\t\t\tyyVAL.value = (*Query)(nil)\n\t\t}\n\tcase 103:\n\t\tyyDollar = yyS[yypt-2 : yypt+1]\n//line parser.go.y:502\n\t\t{\n\t\t\tyyVAL.value = yyDollar[2].value\n\t\t}\n\tcase 104:\n\t\tyyDollar = yyS[yypt-0 : yypt+1]\n//line parser.go.y:508\n\t\t{\n\t\t\tyyVAL.value = (*Query)(nil)\n\t\t}\n\tcase 105:\n\t\tyyDollar = yyS[yypt-2 : yypt+1]\n//line parser.go.y:512\n\t\t{\n\t\t\tyyVAL.value = yyDollar[2].value\n\t\t}\n\tcase 106:\n\t\tyyDollar = yyS[yypt-1 : yypt+1]\n//line parser.go.y:518\n\t\t{\n\t\t\tyyVAL.value = []*ObjectKeyVal{yyDollar[1].value.(*ObjectKeyVal)}\n\t\t}\n\tcase 107:\n\t\tyyDollar = yyS[yypt-3 : yypt+1]\n//line parser.go.y:522\n\t\t{\n\t\t\tyyVAL.value = append(yyDollar[1].value.([]*ObjectKeyVal), yyDollar[3].value.(*ObjectKeyVal))\n\t\t}\n\tcase 108:\n\t\tyyDollar = yyS[yypt-3 : yypt+1]\n//line parser.go.y:528\n\t\t{\n\t\t\tyyVAL.value = &ObjectKeyVal{Key: yyDollar[1].token, Val: yyDollar[3].value.(*Query)}\n\t\t}\n\tcase 109:\n\t\tyyDollar = yyS[yypt-3 : yypt+1]\n//line parser.go.y:532\n\t\t{\n\t\t\tyyVAL.value = &ObjectKeyVal{KeyString: yyDollar[1].value.(*String), Val: yyDollar[3].value.(*Query)}\n\t\t}\n\tcase 110:\n\t\tyyDollar = yyS[yypt-5 : yypt+1]\n//line parser.go.y:536\n\t\t{\n\t\t\tyyVAL.value = &ObjectKeyVal{KeyQuery: yyDollar[2].value.(*Query), Val: yyDollar[5].value.(*Query)}\n\t\t}\n\tcase 111:\n\t\tyyDollar = yyS[yypt-1 : yypt+1]\n//line parser.go.y:540\n\t\t{\n\t\t\tyyVAL.value = &ObjectKeyVal{Key: yyDollar[1].token}\n\t\t}\n\tcase 112:\n\t\tyyDollar = yyS[yypt-1 : yypt+1]\n//line parser.go.y:544\n\t\t{\n\t\t\tyyVAL.value = &ObjectKeyVal{KeyString: yyDollar[1].value.(*String)}\n\t\t}\n\tcase 116:\n\t\tyyDollar = yyS[yypt-3 : yypt+1]\n//line parser.go.y:555\n\t\t{\n\t\t\tyyVAL.value = &Query{Left: yyDollar[1].value.(*Query), Op: OpPipe, Right: yyDollar[3].value.(*Query)}\n\t\t}\n\tcase 118:\n\t\tyyDollar = yyS[yypt-1 : yypt+1]\n//line parser.go.y:562\n\t\t{\n\t\t\tyyVAL.value = &ConstTerm{Object: yyDollar[1].value.(*ConstObject)}\n\t\t}\n\tcase 119:\n\t\tyyDollar = yyS[yypt-1 : yypt+1]\n//line parser.go.y:566\n\t\t{\n\t\t\tyyVAL.value = &ConstTerm{Array: yyDollar[1].value.(*ConstArray)}\n\t\t}\n\tcase 120:\n\t\tyyDollar = yyS[yypt-1 : yypt+1]\n//line parser.go.y:570\n\t\t{\n\t\t\tyyVAL.value = &ConstTerm{Number: yyDollar[1].token}\n\t\t}\n\tcase 121:\n\t\tyyDollar = yyS[yypt-1 : yypt+1]\n//line parser.go.y:574\n\t\t{\n\t\t\tyyVAL.value = &ConstTerm{Str: yyDollar[1].token}\n\t\t}\n\tcase 122:\n\t\tyyDollar = yyS[yypt-1 : yypt+1]\n//line parser.go.y:578\n\t\t{\n\t\t\tyyVAL.value = &ConstTerm{Null: true}\n\t\t}\n\tcase 123:\n\t\tyyDollar = yyS[yypt-1 : yypt+1]\n//line parser.go.y:582\n\t\t{\n\t\t\tyyVAL.value = &ConstTerm{True: true}\n\t\t}\n\tcase 124:\n\t\tyyDollar = yyS[yypt-1 : yypt+1]\n//line parser.go.y:586\n\t\t{\n\t\t\tyyVAL.value = &ConstTerm{False: true}\n\t\t}\n\tcase 125:\n\t\tyyDollar = yyS[yypt-2 : yypt+1]\n//line parser.go.y:592\n\t\t{\n\t\t\tyyVAL.value = &ConstObject{}\n\t\t}\n\tcase 126:\n\t\tyyDollar = yyS[yypt-3 : yypt+1]\n//line parser.go.y:596\n\t\t{\n\t\t\tyyVAL.value = &ConstObject{yyDollar[2].value.([]*ConstObjectKeyVal)}\n\t\t}\n\tcase 127:\n\t\tyyDollar = yyS[yypt-4 : yypt+1]\n//line parser.go.y:600\n\t\t{\n\t\t\tyyVAL.value = &ConstObject{yyDollar[2].value.([]*ConstObjectKeyVal)}\n\t\t}\n\tcase 128:\n\t\tyyDollar = yyS[yypt-1 : yypt+1]\n//line parser.go.y:606\n\t\t{\n\t\t\tyyVAL.value = []*ConstObjectKeyVal{yyDollar[1].value.(*ConstObjectKeyVal)}\n\t\t}\n\tcase 129:\n\t\tyyDollar = yyS[yypt-3 : yypt+1]\n//line parser.go.y:610\n\t\t{\n\t\t\tyyVAL.value = append(yyDollar[1].value.([]*ConstObjectKeyVal), yyDollar[3].value.(*ConstObjectKeyVal))\n\t\t}\n\tcase 130:\n\t\tyyDollar = yyS[yypt-3 : yypt+1]\n//line parser.go.y:616\n\t\t{\n\t\t\tyyVAL.value = &ConstObjectKeyVal{Key: yyDollar[1].token, Val: yyDollar[3].value.(*ConstTerm)}\n\t\t}\n\tcase 131:\n\t\tyyDollar = yyS[yypt-3 : yypt+1]\n//line parser.go.y:620\n\t\t{\n\t\t\tyyVAL.value = &ConstObjectKeyVal{Key: yyDollar[1].token, Val: yyDollar[3].value.(*ConstTerm)}\n\t\t}\n\tcase 132:\n\t\tyyDollar = yyS[yypt-3 : yypt+1]\n//line parser.go.y:624\n\t\t{\n\t\t\tyyVAL.value = &ConstObjectKeyVal{KeyString: yyDollar[1].token, Val: yyDollar[3].value.(*ConstTerm)}\n\t\t}\n\tcase 133:\n\t\tyyDollar = yyS[yypt-2 : yypt+1]\n//line parser.go.y:630\n\t\t{\n\t\t\tyyVAL.value = &ConstArray{}\n\t\t}\n\tcase 134:\n\t\tyyDollar = yyS[yypt-3 : yypt+1]\n//line parser.go.y:634\n\t\t{\n\t\t\tyyVAL.value = &ConstArray{yyDollar[2].value.([]*ConstTerm)}\n\t\t}\n\tcase 135:\n\t\tyyDollar = yyS[yypt-1 : yypt+1]\n//line parser.go.y:640\n\t\t{\n\t\t\tyyVAL.value = []*ConstTerm{yyDollar[1].value.(*ConstTerm)}\n\t\t}\n\tcase 136:\n\t\tyyDollar = yyS[yypt-3 : yypt+1]\n//line parser.go.y:644\n\t\t{\n\t\t\tyyVAL.value = append(yyDollar[1].value.([]*ConstTerm), yyDollar[3].value.(*ConstTerm))\n\t\t}\n\t}\n\tgoto yystack /* stack new state and value */\n}\n"
        },
        {
          "name": "parser.go.y",
          "type": "blob",
          "size": 14.3681640625,
          "content": "%{\npackage gojq\n\nfunc reverseFuncDef(xs []*FuncDef) []*FuncDef {\n\tfor i, j := 0, len(xs)-1; i < j; i, j = i+1, j-1 {\n\t\txs[i], xs[j] = xs[j], xs[i]\n\t}\n\treturn xs\n}\n\nfunc prependFuncDef(xs []*FuncDef, x *FuncDef) []*FuncDef {\n\txs = append(xs, nil)\n\tcopy(xs[1:], xs)\n\txs[0] = x\n\treturn xs\n}\n%}\n\n%union {\n  value    any\n  token    string\n  operator Operator\n}\n\n%type<value> program header imports import meta body funcdefs funcdef funcargs query\n%type<value> bindpatterns pattern arraypatterns objectpatterns objectpattern\n%type<value> expr term string stringparts suffix args ifelifs ifelse trycatch\n%type<value> objectkeyvals objectkeyval objectval\n%type<value> constterm constobject constobjectkeyvals constobjectkeyval constarray constarrayelems\n%type<token> tokIdentVariable tokIdentModuleIdent tokVariableModuleVariable tokKeyword objectkey\n%token<operator> tokAltOp tokUpdateOp tokDestAltOp tokCompareOp\n%token<token> tokOrOp tokAndOp tokModule tokImport tokInclude tokDef tokAs tokLabel tokBreak\n%token<token> tokNull tokTrue tokFalse\n%token<token> tokIf tokThen tokElif tokElse tokEnd\n%token<token> tokTry tokCatch tokReduce tokForeach\n%token<token> tokIdent tokVariable tokModuleIdent tokModuleVariable\n%token<token> tokRecurse tokIndex tokNumber tokFormat\n%token<token> tokString tokStringStart tokStringQuery tokStringEnd\n%token<token> tokInvalid tokInvalidEscapeSequence tokUnterminatedString\n\n%nonassoc tokFuncDefQuery tokExpr tokTerm\n%right '|'\n%left ','\n%right tokAltOp\n%nonassoc tokUpdateOp\n%left tokOrOp\n%left tokAndOp\n%nonassoc tokCompareOp\n%left '+' '-'\n%left '*' '/' '%'\n%nonassoc tokAs tokIndex '.' '?' tokEmptyCatch\n%nonassoc '[' tokTry tokCatch\n\n%%\n\nprogram\n    : header imports body\n    {\n        query := $3.(*Query)\n        query.Meta = $1.(*ConstObject)\n        query.Imports = $2.([]*Import)\n        yylex.(*lexer).result = query\n    }\n\nheader\n    :\n    {\n        $$ = (*ConstObject)(nil)\n    }\n    | tokModule constobject ';'\n    {\n        $$ = $2;\n    }\n\nimports\n    :\n    {\n        $$ = []*Import(nil)\n    }\n    | imports import\n    {\n        $$ = append($1.([]*Import), $2.(*Import))\n    }\n\nimport\n    : tokImport tokString tokAs tokIdentVariable meta ';'\n    {\n        $$ = &Import{ImportPath: $2, ImportAlias: $4, Meta: $5.(*ConstObject)}\n    }\n    | tokInclude tokString meta ';'\n    {\n        $$ = &Import{IncludePath: $2, Meta: $3.(*ConstObject)}\n    }\n\nmeta\n    :\n    {\n        $$ = (*ConstObject)(nil)\n    }\n    | constobject\n\nbody\n    : funcdefs\n    {\n        $$ = &Query{FuncDefs: reverseFuncDef($1.([]*FuncDef))}\n    }\n    | query\n\nfuncdefs\n    :\n    {\n        $$ = []*FuncDef(nil)\n    }\n    | funcdef funcdefs\n    {\n        $$ = append($2.([]*FuncDef), $1.(*FuncDef))\n    }\n\nfuncdef\n    : tokDef tokIdent ':' query ';'\n    {\n        $$ = &FuncDef{Name: $2, Body: $4.(*Query)}\n    }\n    | tokDef tokIdent '(' funcargs ')' ':' query ';'\n    {\n        $$ = &FuncDef{$2, $4.([]string), $7.(*Query)}\n    }\n\nfuncargs\n    : tokIdentVariable\n    {\n        $$ = []string{$1}\n    }\n    | funcargs ';' tokIdentVariable\n    {\n        $$ = append($1.([]string), $3)\n    }\n\ntokIdentVariable\n    : tokIdent\n    | tokVariable\n\nquery\n    : funcdef query %prec tokFuncDefQuery\n    {\n        query := $2.(*Query)\n        query.FuncDefs = prependFuncDef(query.FuncDefs, $1.(*FuncDef))\n        $$ = query\n    }\n    | query '|' query\n    {\n        $$ = &Query{Left: $1.(*Query), Op: OpPipe, Right: $3.(*Query)}\n    }\n    | term tokAs bindpatterns '|' query\n    {\n        term := $1.(*Term)\n        term.SuffixList = append(term.SuffixList, &Suffix{Bind: &Bind{$3.([]*Pattern), $5.(*Query)}})\n        $$ = &Query{Term: term}\n    }\n    | tokLabel tokVariable '|' query\n    {\n        $$ = &Query{Term: &Term{Type: TermTypeLabel, Label: &Label{$2, $4.(*Query)}}}\n    }\n    | query ',' query\n    {\n        $$ = &Query{Left: $1.(*Query), Op: OpComma, Right: $3.(*Query)}\n    }\n    | expr %prec tokExpr\n\nexpr\n    : expr tokAltOp expr\n    {\n        $$ = &Query{Left: $1.(*Query), Op: $2, Right: $3.(*Query)}\n    }\n    | expr tokUpdateOp expr\n    {\n        $$ = &Query{Left: $1.(*Query), Op: $2, Right: $3.(*Query)}\n    }\n    | expr tokOrOp expr\n    {\n        $$ = &Query{Left: $1.(*Query), Op: OpOr, Right: $3.(*Query)}\n    }\n    | expr tokAndOp expr\n    {\n        $$ = &Query{Left: $1.(*Query), Op: OpAnd, Right: $3.(*Query)}\n    }\n    | expr tokCompareOp expr\n    {\n        $$ = &Query{Left: $1.(*Query), Op: $2, Right: $3.(*Query)}\n    }\n    | expr '+' expr\n    {\n        $$ = &Query{Left: $1.(*Query), Op: OpAdd, Right: $3.(*Query)}\n    }\n    | expr '-' expr\n    {\n        $$ = &Query{Left: $1.(*Query), Op: OpSub, Right: $3.(*Query)}\n    }\n    | expr '*' expr\n    {\n        $$ = &Query{Left: $1.(*Query), Op: OpMul, Right: $3.(*Query)}\n    }\n    | expr '/' expr\n    {\n        $$ = &Query{Left: $1.(*Query), Op: OpDiv, Right: $3.(*Query)}\n    }\n    | expr '%' expr\n    {\n        $$ = &Query{Left: $1.(*Query), Op: OpMod, Right: $3.(*Query)}\n    }\n    | term %prec tokTerm\n    {\n        $$ = &Query{Term: $1.(*Term)}\n    }\n\nbindpatterns\n    : pattern\n    {\n        $$ = []*Pattern{$1.(*Pattern)}\n    }\n    | bindpatterns tokDestAltOp pattern\n    {\n        $$ = append($1.([]*Pattern), $3.(*Pattern))\n    }\n\npattern\n    : tokVariable\n    {\n        $$ = &Pattern{Name: $1}\n    }\n    | '[' arraypatterns ']'\n    {\n        $$ = &Pattern{Array: $2.([]*Pattern)}\n    }\n    | '{' objectpatterns '}'\n    {\n        $$ = &Pattern{Object: $2.([]*PatternObject)}\n    }\n\narraypatterns\n    : pattern\n    {\n        $$ = []*Pattern{$1.(*Pattern)}\n    }\n    | arraypatterns ',' pattern\n    {\n        $$ = append($1.([]*Pattern), $3.(*Pattern))\n    }\n\nobjectpatterns\n    : objectpattern\n    {\n        $$ = []*PatternObject{$1.(*PatternObject)}\n    }\n    | objectpatterns ',' objectpattern\n    {\n        $$ = append($1.([]*PatternObject), $3.(*PatternObject))\n    }\n\nobjectpattern\n    : objectkey ':' pattern\n    {\n        $$ = &PatternObject{Key: $1, Val: $3.(*Pattern)}\n    }\n    | string ':' pattern\n    {\n        $$ = &PatternObject{KeyString: $1.(*String), Val: $3.(*Pattern)}\n    }\n    | '(' query ')' ':' pattern\n    {\n        $$ = &PatternObject{KeyQuery: $2.(*Query), Val: $5.(*Pattern)}\n    }\n    | tokVariable\n    {\n        $$ = &PatternObject{Key: $1}\n    }\n\nterm\n    : '.'\n    {\n        $$ = &Term{Type: TermTypeIdentity}\n    }\n    | tokRecurse\n    {\n        $$ = &Term{Type: TermTypeRecurse}\n    }\n    | tokIndex\n    {\n        $$ = &Term{Type: TermTypeIndex, Index: &Index{Name: $1}}\n    }\n    | '.' suffix\n    {\n        suffix := $2.(*Suffix)\n        if suffix.Iter {\n            $$ = &Term{Type: TermTypeIdentity, SuffixList: []*Suffix{suffix}}\n        } else {\n            $$ = &Term{Type: TermTypeIndex, Index: suffix.Index}\n        }\n    }\n    | '.' string\n    {\n        $$ = &Term{Type: TermTypeIndex, Index: &Index{Str: $2.(*String)}}\n    }\n    | tokNull\n    {\n        $$ = &Term{Type: TermTypeNull}\n    }\n    | tokTrue\n    {\n        $$ = &Term{Type: TermTypeTrue}\n    }\n    | tokFalse\n    {\n        $$ = &Term{Type: TermTypeFalse}\n    }\n    | tokIdentModuleIdent\n    {\n        $$ = &Term{Type: TermTypeFunc, Func: &Func{Name: $1}}\n    }\n    | tokIdentModuleIdent '(' args ')'\n    {\n        $$ = &Term{Type: TermTypeFunc, Func: &Func{Name: $1, Args: $3.([]*Query)}}\n    }\n    | tokVariableModuleVariable\n    {\n        $$ = &Term{Type: TermTypeFunc, Func: &Func{Name: $1}}\n    }\n    | '{' '}'\n    {\n        $$ = &Term{Type: TermTypeObject, Object: &Object{}}\n    }\n    | '{' objectkeyvals '}'\n    {\n        $$ = &Term{Type: TermTypeObject, Object: &Object{$2.([]*ObjectKeyVal)}}\n    }\n    | '{' objectkeyvals ',' '}'\n    {\n        $$ = &Term{Type: TermTypeObject, Object: &Object{$2.([]*ObjectKeyVal)}}\n    }\n    | '[' ']'\n    {\n        $$ = &Term{Type: TermTypeArray, Array: &Array{}}\n    }\n    | '[' query ']'\n    {\n        $$ = &Term{Type: TermTypeArray, Array: &Array{$2.(*Query)}}\n    }\n    | tokNumber\n    {\n        $$ = &Term{Type: TermTypeNumber, Number: $1}\n    }\n    | '+' term\n    {\n        $$ = &Term{Type: TermTypeUnary, Unary: &Unary{OpAdd, $2.(*Term)}}\n    }\n    | '-' term\n    {\n        $$ = &Term{Type: TermTypeUnary, Unary: &Unary{OpSub, $2.(*Term)}}\n    }\n    | tokFormat\n    {\n        $$ = &Term{Type: TermTypeFormat, Format: $1}\n    }\n    | tokFormat string\n    {\n        $$ = &Term{Type: TermTypeFormat, Format: $1, Str: $2.(*String)}\n    }\n    | string\n    {\n        $$ = &Term{Type: TermTypeString, Str: $1.(*String)}\n    }\n    | tokIf query tokThen query ifelifs ifelse tokEnd\n    {\n        $$ = &Term{Type: TermTypeIf, If: &If{$2.(*Query), $4.(*Query), $5.([]*IfElif), $6.(*Query)}}\n    }\n    | tokTry expr trycatch\n    {\n        $$ = &Term{Type: TermTypeTry, Try: &Try{$2.(*Query), $3.(*Query)}}\n    }\n    | tokReduce expr tokAs pattern '(' query ';' query ')'\n    {\n        $$ = &Term{Type: TermTypeReduce, Reduce: &Reduce{$2.(*Query), $4.(*Pattern), $6.(*Query), $8.(*Query)}}\n    }\n    | tokForeach expr tokAs pattern '(' query ';' query ')'\n    {\n        $$ = &Term{Type: TermTypeForeach, Foreach: &Foreach{$2.(*Query), $4.(*Pattern), $6.(*Query), $8.(*Query), nil}}\n    }\n    | tokForeach expr tokAs pattern '(' query ';' query ';' query ')'\n    {\n        $$ = &Term{Type: TermTypeForeach, Foreach: &Foreach{$2.(*Query), $4.(*Pattern), $6.(*Query), $8.(*Query), $10.(*Query)}}\n    }\n    | tokBreak tokVariable\n    {\n        $$ = &Term{Type: TermTypeBreak, Break: $2}\n    }\n    | '(' query ')'\n    {\n        $$ = &Term{Type: TermTypeQuery, Query: $2.(*Query)}\n    }\n    | term tokIndex\n    {\n        $1.(*Term).SuffixList = append($1.(*Term).SuffixList, &Suffix{Index: &Index{Name: $2}})\n    }\n    | term suffix\n    {\n        $1.(*Term).SuffixList = append($1.(*Term).SuffixList, $2.(*Suffix))\n    }\n    | term '?'\n    {\n        $1.(*Term).SuffixList = append($1.(*Term).SuffixList, &Suffix{Optional: true})\n    }\n    | term '.' suffix\n    {\n        $1.(*Term).SuffixList = append($1.(*Term).SuffixList, $3.(*Suffix))\n    }\n    | term '.' string\n    {\n        $1.(*Term).SuffixList = append($1.(*Term).SuffixList, &Suffix{Index: &Index{Str: $3.(*String)}})\n    }\n\nstring\n    : tokString\n    {\n        $$ = &String{Str: $1}\n    }\n    | tokStringStart stringparts tokStringEnd\n    {\n        $$ = &String{Queries: $2.([]*Query)}\n    }\n\nstringparts\n    :\n    {\n        $$ = []*Query{}\n    }\n    | stringparts tokString\n    {\n        $$ = append($1.([]*Query), &Query{Term: &Term{Type: TermTypeString, Str: &String{Str: $2}}})\n    }\n    | stringparts tokStringQuery query ')'\n    {\n        yylex.(*lexer).inString = true\n        $$ = append($1.([]*Query), &Query{Term: &Term{Type: TermTypeQuery, Query: $3.(*Query)}})\n    }\n\ntokIdentModuleIdent\n    : tokIdent\n    | tokModuleIdent\n\ntokVariableModuleVariable\n    : tokVariable\n    | tokModuleVariable\n\nsuffix\n    : '[' ']'\n    {\n        $$ = &Suffix{Iter: true}\n    }\n    | '[' query ']'\n    {\n        $$ = &Suffix{Index: &Index{Start: $2.(*Query)}}\n    }\n    | '[' query ':' ']'\n    {\n        $$ = &Suffix{Index: &Index{Start: $2.(*Query), IsSlice: true}}\n    }\n    | '[' ':' query ']'\n    {\n        $$ = &Suffix{Index: &Index{End: $3.(*Query), IsSlice: true}}\n    }\n    | '[' query ':' query ']'\n    {\n        $$ = &Suffix{Index: &Index{Start: $2.(*Query), End: $4.(*Query), IsSlice: true}}\n    }\n\nargs\n    : query\n    {\n        $$ = []*Query{$1.(*Query)}\n    }\n    | args ';' query\n    {\n        $$ = append($1.([]*Query), $3.(*Query))\n    }\n\nifelifs\n    :\n    {\n        $$ = []*IfElif(nil)\n    }\n    | ifelifs tokElif query tokThen query\n    {\n        $$ = append($1.([]*IfElif), &IfElif{$3.(*Query), $5.(*Query)})\n    }\n\nifelse\n    :\n    {\n        $$ = (*Query)(nil)\n    }\n    | tokElse query\n    {\n        $$ = $2\n    }\n\ntrycatch\n    : %prec tokEmptyCatch\n    {\n        $$ = (*Query)(nil)\n    }\n    | tokCatch expr\n    {\n        $$ = $2\n    }\n\nobjectkeyvals\n    : objectkeyval\n    {\n        $$ = []*ObjectKeyVal{$1.(*ObjectKeyVal)}\n    }\n    | objectkeyvals ',' objectkeyval\n    {\n        $$ = append($1.([]*ObjectKeyVal), $3.(*ObjectKeyVal))\n    }\n\nobjectkeyval\n    : objectkey ':' objectval\n    {\n        $$ = &ObjectKeyVal{Key: $1, Val: $3.(*Query)}\n    }\n    | string ':' objectval\n    {\n        $$ = &ObjectKeyVal{KeyString: $1.(*String), Val: $3.(*Query)}\n    }\n    | '(' query ')' ':' objectval\n    {\n        $$ = &ObjectKeyVal{KeyQuery: $2.(*Query), Val: $5.(*Query)}\n    }\n    | objectkey\n    {\n        $$ = &ObjectKeyVal{Key: $1}\n    }\n    | string\n    {\n        $$ = &ObjectKeyVal{KeyString: $1.(*String)}\n    }\n\nobjectkey\n    : tokIdent\n    | tokVariable\n    | tokKeyword\n\nobjectval\n    : objectval '|' objectval\n    {\n        $$ = &Query{Left: $1.(*Query), Op: OpPipe, Right: $3.(*Query)}\n    }\n    | expr\n\nconstterm\n    : constobject\n    {\n        $$ = &ConstTerm{Object: $1.(*ConstObject)}\n    }\n    | constarray\n    {\n        $$ = &ConstTerm{Array: $1.(*ConstArray)}\n    }\n    | tokNumber\n    {\n        $$ = &ConstTerm{Number: $1}\n    }\n    | tokString\n    {\n        $$ = &ConstTerm{Str: $1}\n    }\n    | tokNull\n    {\n        $$ = &ConstTerm{Null: true}\n    }\n    | tokTrue\n    {\n        $$ = &ConstTerm{True: true}\n    }\n    | tokFalse\n    {\n        $$ = &ConstTerm{False: true}\n    }\n\nconstobject\n    : '{' '}'\n    {\n        $$ = &ConstObject{}\n    }\n    | '{' constobjectkeyvals '}'\n    {\n        $$ = &ConstObject{$2.([]*ConstObjectKeyVal)}\n    }\n    | '{' constobjectkeyvals ',' '}'\n    {\n        $$ = &ConstObject{$2.([]*ConstObjectKeyVal)}\n    }\n\nconstobjectkeyvals\n    : constobjectkeyval\n    {\n        $$ = []*ConstObjectKeyVal{$1.(*ConstObjectKeyVal)}\n    }\n    | constobjectkeyvals ',' constobjectkeyval\n    {\n        $$ = append($1.([]*ConstObjectKeyVal), $3.(*ConstObjectKeyVal))\n    }\n\nconstobjectkeyval\n    : tokIdent ':' constterm\n    {\n        $$ = &ConstObjectKeyVal{Key: $1, Val: $3.(*ConstTerm)}\n    }\n    | tokKeyword ':' constterm\n    {\n        $$ = &ConstObjectKeyVal{Key: $1, Val: $3.(*ConstTerm)}\n    }\n    | tokString ':' constterm\n    {\n        $$ = &ConstObjectKeyVal{KeyString: $1, Val: $3.(*ConstTerm)}\n    }\n\nconstarray\n    : '[' ']'\n    {\n        $$ = &ConstArray{}\n    }\n    | '[' constarrayelems ']'\n    {\n        $$ = &ConstArray{$2.([]*ConstTerm)}\n    }\n\nconstarrayelems\n    : constterm\n    {\n        $$ = []*ConstTerm{$1.(*ConstTerm)}\n    }\n    | constarrayelems ',' constterm\n    {\n        $$ = append($1.([]*ConstTerm), $3.(*ConstTerm))\n    }\n\ntokKeyword\n    : tokOrOp\n    | tokAndOp\n    | tokModule\n    | tokImport\n    | tokInclude\n    | tokDef\n    | tokAs\n    | tokLabel\n    | tokBreak\n    | tokNull\n    | tokTrue\n    | tokFalse\n    | tokIf\n    | tokThen\n    | tokElif\n    | tokElse\n    | tokEnd\n    | tokTry\n    | tokCatch\n    | tokReduce\n    | tokForeach\n\n%%\n"
        },
        {
          "name": "preview.go",
          "type": "blob",
          "size": 1.7412109375,
          "content": "package gojq\n\nimport \"unicode/utf8\"\n\n// Preview returns the preview string of v. The preview string is basically the\n// same as the jq-flavored JSON encoding returned by [Marshal], but is truncated\n// by 30 bytes, and more efficient than truncating the result of [Marshal].\n//\n// This method is used by error messages of built-in operators and functions,\n// and accepts only limited types (nil, bool, int, float64, *big.Int, string,\n// []any, and map[string]any). Note that the maximum width and trailing strings\n// on truncation may be changed in the future.\nfunc Preview(v any) string {\n\tbs := jsonLimitedMarshal(v, 32)\n\tif l := 30; len(bs) > l {\n\t\tvar trailing string\n\t\tswitch v.(type) {\n\t\tcase string:\n\t\t\ttrailing = ` ...\"`\n\t\tcase []any:\n\t\t\ttrailing = \" ...]\"\n\t\tcase map[string]any:\n\t\t\ttrailing = \" ...}\"\n\t\tdefault:\n\t\t\ttrailing = \" ...\"\n\t\t}\n\t\tfor len(bs) > l-len(trailing) {\n\t\t\t_, size := utf8.DecodeLastRune(bs)\n\t\t\tbs = bs[:len(bs)-size]\n\t\t}\n\t\tbs = append(bs, trailing...)\n\t}\n\treturn string(bs)\n}\n\nfunc jsonLimitedMarshal(v any, n int) (bs []byte) {\n\tw := &limitedWriter{buf: make([]byte, n)}\n\tdefer func() {\n\t\t_ = recover()\n\t\tbs = w.Bytes()\n\t}()\n\t(&encoder{w: w}).encode(v)\n\treturn\n}\n\ntype limitedWriter struct {\n\tbuf []byte\n\toff int\n}\n\nfunc (w *limitedWriter) Write(bs []byte) (int, error) {\n\tn := copy(w.buf[w.off:], bs)\n\tif w.off += n; w.off == len(w.buf) {\n\t\tpanic(struct{}{})\n\t}\n\treturn n, nil\n}\n\nfunc (w *limitedWriter) WriteByte(b byte) error {\n\tw.buf[w.off] = b\n\tif w.off++; w.off == len(w.buf) {\n\t\tpanic(struct{}{})\n\t}\n\treturn nil\n}\n\nfunc (w *limitedWriter) WriteString(s string) (int, error) {\n\tn := copy(w.buf[w.off:], s)\n\tif w.off += n; w.off == len(w.buf) {\n\t\tpanic(struct{}{})\n\t}\n\treturn n, nil\n}\n\nfunc (w *limitedWriter) Bytes() []byte {\n\treturn w.buf[:w.off]\n}\n"
        },
        {
          "name": "preview_test.go",
          "type": "blob",
          "size": 2.095703125,
          "content": "package gojq_test\n\nimport (\n\t\"fmt\"\n\t\"math\"\n\t\"math/big\"\n\t\"testing\"\n\n\t\"github.com/itchyny/gojq\"\n)\n\nfunc TestPreview(t *testing.T) {\n\ttestCases := []struct {\n\t\tvalue    any\n\t\texpected string\n\t}{\n\t\t{\n\t\t\tnil,\n\t\t\t\"null\",\n\t\t},\n\t\t{\n\t\t\tfalse,\n\t\t\t\"false\",\n\t\t},\n\t\t{\n\t\t\ttrue,\n\t\t\t\"true\",\n\t\t},\n\t\t{\n\t\t\t0,\n\t\t\t\"0\",\n\t\t},\n\t\t{\n\t\t\t3.14,\n\t\t\t\"3.14\",\n\t\t},\n\t\t{\n\t\t\tmath.NaN(),\n\t\t\t\"null\",\n\t\t},\n\t\t{\n\t\t\tmath.Inf(1),\n\t\t\t\"1.7976931348623157e+308\",\n\t\t},\n\t\t{\n\t\t\tmath.Inf(-1),\n\t\t\t\"-1.7976931348623157e+308\",\n\t\t},\n\t\t{\n\t\t\tbig.NewInt(9223372036854775807),\n\t\t\t\"9223372036854775807\",\n\t\t},\n\t\t{\n\t\t\tnew(big.Int).SetBytes([]byte(\"\\x0c\\x9f\\x2c\\x9c\\xd0\\x46\\x74\\xed\\xea\\x3f\\xff\\xff\\xff\")),\n\t\t\t\"999999999999999999999999999999\",\n\t\t},\n\t\t{\n\t\t\tnew(big.Int).SetBytes([]byte(\"\\x0c\\x9f\\x2c\\x9c\\xd0\\x46\\x74\\xed\\xea\\x40\\x00\\x00\\x00\")),\n\t\t\t\"10000000000000000000000000 ...\",\n\t\t},\n\t\t{\n\t\t\t\"0 1 2 3 4 5 6 7 8 9 10 11 12\",\n\t\t\t`\"0 1 2 3 4 5 6 7 8 9 10 11 12\"`,\n\t\t},\n\t\t{\n\t\t\t\"0 1 2 3 4 5 6 7 8 9 10 11 12 13\",\n\t\t\t`\"0 1 2 3 4 5 6 7 8 9 10 1 ...\"`,\n\t\t},\n\t\t{\n\t\t\t\"０１２３４５６７８９\",\n\t\t\t`\"０１２３４５６７ ...\"`,\n\t\t},\n\t\t{\n\t\t\t[]any{},\n\t\t\t\"[]\",\n\t\t},\n\t\t{\n\t\t\t[]any{0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12},\n\t\t\t\"[0,1,2,3,4,5,6,7,8,9,10,11,12]\",\n\t\t},\n\t\t{\n\t\t\t[]any{0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13},\n\t\t\t\"[0,1,2,3,4,5,6,7,8,9,10,1 ...]\",\n\t\t},\n\t\t{\n\t\t\t[]any{[]any{[]any{[]any{[]any{[]any{[]any{[]any{nil, nil, nil}}}}}}}},\n\t\t\t\"[[[[[[[[null,null,null]]]]]]]]\",\n\t\t},\n\t\t{\n\t\t\t[]any{[]any{[]any{[]any{[]any{[]any{[]any{[]any{nil, nil, nil, nil}}}}}}}},\n\t\t\t\"[[[[[[[[null,null,null,nu ...]\",\n\t\t},\n\t\t{\n\t\t\tmap[string]any{},\n\t\t\t\"{}\",\n\t\t},\n\t\t{\n\t\t\tmap[string]any{\"0\": map[string]any{\"1\": map[string]any{\"2\": map[string]any{\"3\": []any{nil}}}}},\n\t\t\t`{\"0\":{\"1\":{\"2\":{\"3\":[null]}}}}`,\n\t\t},\n\t\t{\n\t\t\tmap[string]any{\"0\": map[string]any{\"1\": map[string]any{\"2\": map[string]any{\"3\": map[string]any{\"4\": map[string]any{}}}}}},\n\t\t\t`{\"0\":{\"1\":{\"2\":{\"3\":{\"4\": ...}`,\n\t\t},\n\t}\n\tfor _, tc := range testCases {\n\t\tt.Run(fmt.Sprintf(\"%v\", tc.value), func(t *testing.T) {\n\t\t\tgot := gojq.Preview(tc.value)\n\t\t\tif got != tc.expected {\n\t\t\t\tt.Errorf(\"Preview(%v): got %s, expected %s\", tc.value, got, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}\n"
        },
        {
          "name": "query.go",
          "type": "blob",
          "size": 19.3017578125,
          "content": "package gojq\n\nimport (\n\t\"context\"\n\t\"strings\"\n)\n\n// Parse a query string, and returns the query struct.\n//\n// If parsing failed, it returns an error of type [*ParseError], which has\n// the byte offset and the invalid token. The byte offset is the scanned bytes\n// when the error occurred. The token is empty if the error occurred after\n// scanning the entire query string.\nfunc Parse(src string) (*Query, error) {\n\tl := newLexer(src)\n\tif yyParse(l) > 0 {\n\t\treturn nil, l.err\n\t}\n\treturn l.result, nil\n}\n\n// Query represents the abstract syntax tree of a jq query.\ntype Query struct {\n\tMeta     *ConstObject\n\tImports  []*Import\n\tFuncDefs []*FuncDef\n\tTerm     *Term\n\tLeft     *Query\n\tOp       Operator\n\tRight    *Query\n\tFunc     string\n}\n\n// Run the query.\n//\n// It is safe to call this method in goroutines, to reuse a parsed [*Query].\n// But for arguments, do not give values sharing same data between goroutines.\nfunc (e *Query) Run(v any) Iter {\n\treturn e.RunWithContext(context.Background(), v)\n}\n\n// RunWithContext runs the query with context.\nfunc (e *Query) RunWithContext(ctx context.Context, v any) Iter {\n\tcode, err := Compile(e)\n\tif err != nil {\n\t\treturn NewIter(err)\n\t}\n\treturn code.RunWithContext(ctx, v)\n}\n\nfunc (e *Query) String() string {\n\tvar s strings.Builder\n\te.writeTo(&s)\n\treturn s.String()\n}\n\nfunc (e *Query) writeTo(s *strings.Builder) {\n\tif e.Meta != nil {\n\t\ts.WriteString(\"module \")\n\t\te.Meta.writeTo(s)\n\t\ts.WriteString(\";\\n\")\n\t}\n\tfor _, im := range e.Imports {\n\t\tim.writeTo(s)\n\t}\n\tfor _, fd := range e.FuncDefs {\n\t\tfd.writeTo(s)\n\t\ts.WriteByte(' ')\n\t}\n\tif e.Func != \"\" {\n\t\ts.WriteString(e.Func)\n\t} else if e.Term != nil {\n\t\te.Term.writeTo(s)\n\t} else if e.Right != nil {\n\t\te.Left.writeTo(s)\n\t\tif e.Op == OpComma {\n\t\t\ts.WriteString(\", \")\n\t\t} else {\n\t\t\ts.WriteByte(' ')\n\t\t\ts.WriteString(e.Op.String())\n\t\t\ts.WriteByte(' ')\n\t\t}\n\t\te.Right.writeTo(s)\n\t}\n}\n\nfunc (e *Query) minify() {\n\tfor _, e := range e.FuncDefs {\n\t\te.Minify()\n\t}\n\tif e.Term != nil {\n\t\tif name := e.Term.toFunc(); name != \"\" {\n\t\t\te.Term = nil\n\t\t\te.Func = name\n\t\t} else {\n\t\t\te.Term.minify()\n\t\t}\n\t} else if e.Right != nil {\n\t\te.Left.minify()\n\t\te.Right.minify()\n\t}\n}\n\nfunc (e *Query) toIndexKey() any {\n\tif e.Term == nil {\n\t\treturn nil\n\t}\n\treturn e.Term.toIndexKey()\n}\n\nfunc (e *Query) toIndices(xs []any) []any {\n\tif e.Term == nil {\n\t\treturn nil\n\t}\n\treturn e.Term.toIndices(xs)\n}\n\n// Import ...\ntype Import struct {\n\tImportPath  string\n\tImportAlias string\n\tIncludePath string\n\tMeta        *ConstObject\n}\n\nfunc (e *Import) String() string {\n\tvar s strings.Builder\n\te.writeTo(&s)\n\treturn s.String()\n}\n\nfunc (e *Import) writeTo(s *strings.Builder) {\n\tif e.ImportPath != \"\" {\n\t\ts.WriteString(\"import \")\n\t\tjsonEncodeString(s, e.ImportPath)\n\t\ts.WriteString(\" as \")\n\t\ts.WriteString(e.ImportAlias)\n\t} else {\n\t\ts.WriteString(\"include \")\n\t\tjsonEncodeString(s, e.IncludePath)\n\t}\n\tif e.Meta != nil {\n\t\ts.WriteByte(' ')\n\t\te.Meta.writeTo(s)\n\t}\n\ts.WriteString(\";\\n\")\n}\n\n// FuncDef ...\ntype FuncDef struct {\n\tName string\n\tArgs []string\n\tBody *Query\n}\n\nfunc (e *FuncDef) String() string {\n\tvar s strings.Builder\n\te.writeTo(&s)\n\treturn s.String()\n}\n\nfunc (e *FuncDef) writeTo(s *strings.Builder) {\n\ts.WriteString(\"def \")\n\ts.WriteString(e.Name)\n\tif len(e.Args) > 0 {\n\t\ts.WriteByte('(')\n\t\tfor i, e := range e.Args {\n\t\t\tif i > 0 {\n\t\t\t\ts.WriteString(\"; \")\n\t\t\t}\n\t\t\ts.WriteString(e)\n\t\t}\n\t\ts.WriteByte(')')\n\t}\n\ts.WriteString(\": \")\n\te.Body.writeTo(s)\n\ts.WriteByte(';')\n}\n\n// Minify ...\nfunc (e *FuncDef) Minify() {\n\te.Body.minify()\n}\n\n// Term ...\ntype Term struct {\n\tType       TermType\n\tIndex      *Index\n\tFunc       *Func\n\tObject     *Object\n\tArray      *Array\n\tNumber     string\n\tUnary      *Unary\n\tFormat     string\n\tStr        *String\n\tIf         *If\n\tTry        *Try\n\tReduce     *Reduce\n\tForeach    *Foreach\n\tLabel      *Label\n\tBreak      string\n\tQuery      *Query\n\tSuffixList []*Suffix\n}\n\nfunc (e *Term) String() string {\n\tvar s strings.Builder\n\te.writeTo(&s)\n\treturn s.String()\n}\n\nfunc (e *Term) writeTo(s *strings.Builder) {\n\tswitch e.Type {\n\tcase TermTypeIdentity:\n\t\ts.WriteByte('.')\n\tcase TermTypeRecurse:\n\t\ts.WriteString(\"..\")\n\tcase TermTypeNull:\n\t\ts.WriteString(\"null\")\n\tcase TermTypeTrue:\n\t\ts.WriteString(\"true\")\n\tcase TermTypeFalse:\n\t\ts.WriteString(\"false\")\n\tcase TermTypeIndex:\n\t\te.Index.writeTo(s)\n\tcase TermTypeFunc:\n\t\te.Func.writeTo(s)\n\tcase TermTypeObject:\n\t\te.Object.writeTo(s)\n\tcase TermTypeArray:\n\t\te.Array.writeTo(s)\n\tcase TermTypeNumber:\n\t\ts.WriteString(e.Number)\n\tcase TermTypeUnary:\n\t\te.Unary.writeTo(s)\n\tcase TermTypeFormat:\n\t\ts.WriteString(e.Format)\n\t\tif e.Str != nil {\n\t\t\ts.WriteByte(' ')\n\t\t\te.Str.writeTo(s)\n\t\t}\n\tcase TermTypeString:\n\t\te.Str.writeTo(s)\n\tcase TermTypeIf:\n\t\te.If.writeTo(s)\n\tcase TermTypeTry:\n\t\te.Try.writeTo(s)\n\tcase TermTypeReduce:\n\t\te.Reduce.writeTo(s)\n\tcase TermTypeForeach:\n\t\te.Foreach.writeTo(s)\n\tcase TermTypeLabel:\n\t\te.Label.writeTo(s)\n\tcase TermTypeBreak:\n\t\ts.WriteString(\"break \")\n\t\ts.WriteString(e.Break)\n\tcase TermTypeQuery:\n\t\ts.WriteByte('(')\n\t\te.Query.writeTo(s)\n\t\ts.WriteByte(')')\n\t}\n\tfor _, e := range e.SuffixList {\n\t\te.writeTo(s)\n\t}\n}\n\nfunc (e *Term) minify() {\n\tswitch e.Type {\n\tcase TermTypeIndex:\n\t\te.Index.minify()\n\tcase TermTypeFunc:\n\t\te.Func.minify()\n\tcase TermTypeObject:\n\t\te.Object.minify()\n\tcase TermTypeArray:\n\t\te.Array.minify()\n\tcase TermTypeUnary:\n\t\te.Unary.minify()\n\tcase TermTypeFormat:\n\t\tif e.Str != nil {\n\t\t\te.Str.minify()\n\t\t}\n\tcase TermTypeString:\n\t\te.Str.minify()\n\tcase TermTypeIf:\n\t\te.If.minify()\n\tcase TermTypeTry:\n\t\te.Try.minify()\n\tcase TermTypeReduce:\n\t\te.Reduce.minify()\n\tcase TermTypeForeach:\n\t\te.Foreach.minify()\n\tcase TermTypeLabel:\n\t\te.Label.minify()\n\tcase TermTypeQuery:\n\t\te.Query.minify()\n\t}\n\tfor _, e := range e.SuffixList {\n\t\te.minify()\n\t}\n}\n\nfunc (e *Term) toFunc() string {\n\tif len(e.SuffixList) != 0 {\n\t\treturn \"\"\n\t}\n\t// ref: compiler#compileQuery\n\tswitch e.Type {\n\tcase TermTypeIdentity:\n\t\treturn \".\"\n\tcase TermTypeRecurse:\n\t\treturn \"..\"\n\tcase TermTypeNull:\n\t\treturn \"null\"\n\tcase TermTypeTrue:\n\t\treturn \"true\"\n\tcase TermTypeFalse:\n\t\treturn \"false\"\n\tcase TermTypeFunc:\n\t\treturn e.Func.toFunc()\n\tdefault:\n\t\treturn \"\"\n\t}\n}\n\nfunc (e *Term) toIndexKey() any {\n\tswitch e.Type {\n\tcase TermTypeNumber:\n\t\treturn toNumber(e.Number)\n\tcase TermTypeUnary:\n\t\treturn e.Unary.toNumber()\n\tcase TermTypeString:\n\t\tif e.Str.Queries == nil {\n\t\t\treturn e.Str.Str\n\t\t}\n\t\treturn nil\n\tdefault:\n\t\treturn nil\n\t}\n}\n\nfunc (e *Term) toIndices(xs []any) []any {\n\tswitch e.Type {\n\tcase TermTypeIndex:\n\t\tif xs = e.Index.toIndices(xs); xs == nil {\n\t\t\treturn nil\n\t\t}\n\tcase TermTypeQuery:\n\t\tif xs = e.Query.toIndices(xs); xs == nil {\n\t\t\treturn nil\n\t\t}\n\tdefault:\n\t\treturn nil\n\t}\n\tfor _, s := range e.SuffixList {\n\t\tif xs = s.toIndices(xs); xs == nil {\n\t\t\treturn nil\n\t\t}\n\t}\n\treturn xs\n}\n\nfunc (e *Term) toNumber() any {\n\tif e.Type == TermTypeNumber {\n\t\treturn toNumber(e.Number)\n\t}\n\treturn nil\n}\n\n// Unary ...\ntype Unary struct {\n\tOp   Operator\n\tTerm *Term\n}\n\nfunc (e *Unary) String() string {\n\tvar s strings.Builder\n\te.writeTo(&s)\n\treturn s.String()\n}\n\nfunc (e *Unary) writeTo(s *strings.Builder) {\n\ts.WriteString(e.Op.String())\n\te.Term.writeTo(s)\n}\n\nfunc (e *Unary) minify() {\n\te.Term.minify()\n}\n\nfunc (e *Unary) toNumber() any {\n\tv := e.Term.toNumber()\n\tif v != nil && e.Op == OpSub {\n\t\tv = funcOpNegate(v)\n\t}\n\treturn v\n}\n\n// Pattern ...\ntype Pattern struct {\n\tName   string\n\tArray  []*Pattern\n\tObject []*PatternObject\n}\n\nfunc (e *Pattern) String() string {\n\tvar s strings.Builder\n\te.writeTo(&s)\n\treturn s.String()\n}\n\nfunc (e *Pattern) writeTo(s *strings.Builder) {\n\tif e.Name != \"\" {\n\t\ts.WriteString(e.Name)\n\t} else if len(e.Array) > 0 {\n\t\ts.WriteByte('[')\n\t\tfor i, e := range e.Array {\n\t\t\tif i > 0 {\n\t\t\t\ts.WriteString(\", \")\n\t\t\t}\n\t\t\te.writeTo(s)\n\t\t}\n\t\ts.WriteByte(']')\n\t} else if len(e.Object) > 0 {\n\t\ts.WriteByte('{')\n\t\tfor i, e := range e.Object {\n\t\t\tif i > 0 {\n\t\t\t\ts.WriteString(\", \")\n\t\t\t}\n\t\t\te.writeTo(s)\n\t\t}\n\t\ts.WriteByte('}')\n\t}\n}\n\n// PatternObject ...\ntype PatternObject struct {\n\tKey       string\n\tKeyString *String\n\tKeyQuery  *Query\n\tVal       *Pattern\n}\n\nfunc (e *PatternObject) String() string {\n\tvar s strings.Builder\n\te.writeTo(&s)\n\treturn s.String()\n}\n\nfunc (e *PatternObject) writeTo(s *strings.Builder) {\n\tif e.Key != \"\" {\n\t\ts.WriteString(e.Key)\n\t} else if e.KeyString != nil {\n\t\te.KeyString.writeTo(s)\n\t} else if e.KeyQuery != nil {\n\t\ts.WriteByte('(')\n\t\te.KeyQuery.writeTo(s)\n\t\ts.WriteByte(')')\n\t}\n\tif e.Val != nil {\n\t\ts.WriteString(\": \")\n\t\te.Val.writeTo(s)\n\t}\n}\n\n// Index ...\ntype Index struct {\n\tName    string\n\tStr     *String\n\tStart   *Query\n\tEnd     *Query\n\tIsSlice bool\n}\n\nfunc (e *Index) String() string {\n\tvar s strings.Builder\n\te.writeTo(&s)\n\treturn s.String()\n}\n\nfunc (e *Index) writeTo(s *strings.Builder) {\n\tif l := s.Len(); l > 0 {\n\t\t// \". .x\" != \"..x\" and \"0 .x\" != \"0.x\"\n\t\tif c := s.String()[l-1]; c == '.' || '0' <= c && c <= '9' {\n\t\t\ts.WriteByte(' ')\n\t\t}\n\t}\n\ts.WriteByte('.')\n\te.writeSuffixTo(s)\n}\n\nfunc (e *Index) writeSuffixTo(s *strings.Builder) {\n\tif e.Name != \"\" {\n\t\ts.WriteString(e.Name)\n\t} else if e.Str != nil {\n\t\te.Str.writeTo(s)\n\t} else {\n\t\ts.WriteByte('[')\n\t\tif e.IsSlice {\n\t\t\tif e.Start != nil {\n\t\t\t\te.Start.writeTo(s)\n\t\t\t}\n\t\t\ts.WriteByte(':')\n\t\t\tif e.End != nil {\n\t\t\t\te.End.writeTo(s)\n\t\t\t}\n\t\t} else {\n\t\t\te.Start.writeTo(s)\n\t\t}\n\t\ts.WriteByte(']')\n\t}\n}\n\nfunc (e *Index) minify() {\n\tif e.Str != nil {\n\t\te.Str.minify()\n\t}\n\tif e.Start != nil {\n\t\te.Start.minify()\n\t}\n\tif e.End != nil {\n\t\te.End.minify()\n\t}\n}\n\nfunc (e *Index) toIndexKey() any {\n\tif e.Name != \"\" {\n\t\treturn e.Name\n\t} else if e.Str != nil {\n\t\tif e.Str.Queries == nil {\n\t\t\treturn e.Str.Str\n\t\t}\n\t} else if !e.IsSlice {\n\t\treturn e.Start.toIndexKey()\n\t} else {\n\t\tvar start, end any\n\t\tok := true\n\t\tif e.Start != nil {\n\t\t\tstart = e.Start.toIndexKey()\n\t\t\tok = start != nil\n\t\t}\n\t\tif e.End != nil && ok {\n\t\t\tend = e.End.toIndexKey()\n\t\t\tok = end != nil\n\t\t}\n\t\tif ok {\n\t\t\treturn map[string]any{\"start\": start, \"end\": end}\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc (e *Index) toIndices(xs []any) []any {\n\tif k := e.toIndexKey(); k != nil {\n\t\treturn append(xs, k)\n\t}\n\treturn nil\n}\n\n// Func ...\ntype Func struct {\n\tName string\n\tArgs []*Query\n}\n\nfunc (e *Func) String() string {\n\tvar s strings.Builder\n\te.writeTo(&s)\n\treturn s.String()\n}\n\nfunc (e *Func) writeTo(s *strings.Builder) {\n\ts.WriteString(e.Name)\n\tif len(e.Args) > 0 {\n\t\ts.WriteByte('(')\n\t\tfor i, e := range e.Args {\n\t\t\tif i > 0 {\n\t\t\t\ts.WriteString(\"; \")\n\t\t\t}\n\t\t\te.writeTo(s)\n\t\t}\n\t\ts.WriteByte(')')\n\t}\n}\n\nfunc (e *Func) minify() {\n\tfor _, x := range e.Args {\n\t\tx.minify()\n\t}\n}\n\nfunc (e *Func) toFunc() string {\n\tif len(e.Args) != 0 {\n\t\treturn \"\"\n\t}\n\treturn e.Name\n}\n\n// String ...\ntype String struct {\n\tStr     string\n\tQueries []*Query\n}\n\nfunc (e *String) String() string {\n\tvar s strings.Builder\n\te.writeTo(&s)\n\treturn s.String()\n}\n\nfunc (e *String) writeTo(s *strings.Builder) {\n\tif e.Queries == nil {\n\t\tjsonEncodeString(s, e.Str)\n\t\treturn\n\t}\n\ts.WriteByte('\"')\n\tfor _, e := range e.Queries {\n\t\tif e.Term.Str == nil {\n\t\t\ts.WriteString(`\\`)\n\t\t\te.writeTo(s)\n\t\t} else {\n\t\t\tes := e.String()\n\t\t\ts.WriteString(es[1 : len(es)-1])\n\t\t}\n\t}\n\ts.WriteByte('\"')\n}\n\nfunc (e *String) minify() {\n\tfor _, e := range e.Queries {\n\t\te.minify()\n\t}\n}\n\n// Object ...\ntype Object struct {\n\tKeyVals []*ObjectKeyVal\n}\n\nfunc (e *Object) String() string {\n\tvar s strings.Builder\n\te.writeTo(&s)\n\treturn s.String()\n}\n\nfunc (e *Object) writeTo(s *strings.Builder) {\n\tif len(e.KeyVals) == 0 {\n\t\ts.WriteString(\"{}\")\n\t\treturn\n\t}\n\ts.WriteString(\"{ \")\n\tfor i, kv := range e.KeyVals {\n\t\tif i > 0 {\n\t\t\ts.WriteString(\", \")\n\t\t}\n\t\tkv.writeTo(s)\n\t}\n\ts.WriteString(\" }\")\n}\n\nfunc (e *Object) minify() {\n\tfor _, e := range e.KeyVals {\n\t\te.minify()\n\t}\n}\n\n// ObjectKeyVal ...\ntype ObjectKeyVal struct {\n\tKey       string\n\tKeyString *String\n\tKeyQuery  *Query\n\tVal       *Query\n}\n\nfunc (e *ObjectKeyVal) String() string {\n\tvar s strings.Builder\n\te.writeTo(&s)\n\treturn s.String()\n}\n\nfunc (e *ObjectKeyVal) writeTo(s *strings.Builder) {\n\tif e.Key != \"\" {\n\t\ts.WriteString(e.Key)\n\t} else if e.KeyString != nil {\n\t\te.KeyString.writeTo(s)\n\t} else if e.KeyQuery != nil {\n\t\ts.WriteByte('(')\n\t\te.KeyQuery.writeTo(s)\n\t\ts.WriteByte(')')\n\t}\n\tif e.Val != nil {\n\t\ts.WriteString(\": \")\n\t\te.Val.writeTo(s)\n\t}\n}\n\nfunc (e *ObjectKeyVal) minify() {\n\tif e.KeyString != nil {\n\t\te.KeyString.minify()\n\t} else if e.KeyQuery != nil {\n\t\te.KeyQuery.minify()\n\t}\n\tif e.Val != nil {\n\t\te.Val.minify()\n\t}\n}\n\n// Array ...\ntype Array struct {\n\tQuery *Query\n}\n\nfunc (e *Array) String() string {\n\tvar s strings.Builder\n\te.writeTo(&s)\n\treturn s.String()\n}\n\nfunc (e *Array) writeTo(s *strings.Builder) {\n\ts.WriteByte('[')\n\tif e.Query != nil {\n\t\te.Query.writeTo(s)\n\t}\n\ts.WriteByte(']')\n}\n\nfunc (e *Array) minify() {\n\tif e.Query != nil {\n\t\te.Query.minify()\n\t}\n}\n\n// Suffix ...\ntype Suffix struct {\n\tIndex    *Index\n\tIter     bool\n\tOptional bool\n\tBind     *Bind\n}\n\nfunc (e *Suffix) String() string {\n\tvar s strings.Builder\n\te.writeTo(&s)\n\treturn s.String()\n}\n\nfunc (e *Suffix) writeTo(s *strings.Builder) {\n\tif e.Index != nil {\n\t\tif e.Index.Name != \"\" || e.Index.Str != nil {\n\t\t\te.Index.writeTo(s)\n\t\t} else {\n\t\t\te.Index.writeSuffixTo(s)\n\t\t}\n\t} else if e.Iter {\n\t\ts.WriteString(\"[]\")\n\t} else if e.Optional {\n\t\ts.WriteByte('?')\n\t} else if e.Bind != nil {\n\t\te.Bind.writeTo(s)\n\t}\n}\n\nfunc (e *Suffix) minify() {\n\tif e.Index != nil {\n\t\te.Index.minify()\n\t} else if e.Bind != nil {\n\t\te.Bind.minify()\n\t}\n}\n\nfunc (e *Suffix) toTerm() *Term {\n\tif e.Index != nil {\n\t\treturn &Term{Type: TermTypeIndex, Index: e.Index}\n\t} else if e.Iter {\n\t\treturn &Term{Type: TermTypeIdentity, SuffixList: []*Suffix{{Iter: true}}}\n\t} else {\n\t\treturn nil\n\t}\n}\n\nfunc (e *Suffix) toIndices(xs []any) []any {\n\tif e.Index == nil {\n\t\treturn nil\n\t}\n\treturn e.Index.toIndices(xs)\n}\n\n// Bind ...\ntype Bind struct {\n\tPatterns []*Pattern\n\tBody     *Query\n}\n\nfunc (e *Bind) String() string {\n\tvar s strings.Builder\n\te.writeTo(&s)\n\treturn s.String()\n}\n\nfunc (e *Bind) writeTo(s *strings.Builder) {\n\tfor i, p := range e.Patterns {\n\t\tif i == 0 {\n\t\t\ts.WriteString(\" as \")\n\t\t\tp.writeTo(s)\n\t\t\ts.WriteByte(' ')\n\t\t} else {\n\t\t\ts.WriteString(\"?// \")\n\t\t\tp.writeTo(s)\n\t\t\ts.WriteByte(' ')\n\t\t}\n\t}\n\ts.WriteString(\"| \")\n\te.Body.writeTo(s)\n}\n\nfunc (e *Bind) minify() {\n\te.Body.minify()\n}\n\n// If ...\ntype If struct {\n\tCond *Query\n\tThen *Query\n\tElif []*IfElif\n\tElse *Query\n}\n\nfunc (e *If) String() string {\n\tvar s strings.Builder\n\te.writeTo(&s)\n\treturn s.String()\n}\n\nfunc (e *If) writeTo(s *strings.Builder) {\n\ts.WriteString(\"if \")\n\te.Cond.writeTo(s)\n\ts.WriteString(\" then \")\n\te.Then.writeTo(s)\n\tfor _, e := range e.Elif {\n\t\ts.WriteByte(' ')\n\t\te.writeTo(s)\n\t}\n\tif e.Else != nil {\n\t\ts.WriteString(\" else \")\n\t\te.Else.writeTo(s)\n\t}\n\ts.WriteString(\" end\")\n}\n\nfunc (e *If) minify() {\n\te.Cond.minify()\n\te.Then.minify()\n\tfor _, x := range e.Elif {\n\t\tx.minify()\n\t}\n\tif e.Else != nil {\n\t\te.Else.minify()\n\t}\n}\n\n// IfElif ...\ntype IfElif struct {\n\tCond *Query\n\tThen *Query\n}\n\nfunc (e *IfElif) String() string {\n\tvar s strings.Builder\n\te.writeTo(&s)\n\treturn s.String()\n}\n\nfunc (e *IfElif) writeTo(s *strings.Builder) {\n\ts.WriteString(\"elif \")\n\te.Cond.writeTo(s)\n\ts.WriteString(\" then \")\n\te.Then.writeTo(s)\n}\n\nfunc (e *IfElif) minify() {\n\te.Cond.minify()\n\te.Then.minify()\n}\n\n// Try ...\ntype Try struct {\n\tBody  *Query\n\tCatch *Query\n}\n\nfunc (e *Try) String() string {\n\tvar s strings.Builder\n\te.writeTo(&s)\n\treturn s.String()\n}\n\nfunc (e *Try) writeTo(s *strings.Builder) {\n\ts.WriteString(\"try \")\n\te.Body.writeTo(s)\n\tif e.Catch != nil {\n\t\ts.WriteString(\" catch \")\n\t\te.Catch.writeTo(s)\n\t}\n}\n\nfunc (e *Try) minify() {\n\te.Body.minify()\n\tif e.Catch != nil {\n\t\te.Catch.minify()\n\t}\n}\n\n// Reduce ...\ntype Reduce struct {\n\tQuery   *Query\n\tPattern *Pattern\n\tStart   *Query\n\tUpdate  *Query\n}\n\nfunc (e *Reduce) String() string {\n\tvar s strings.Builder\n\te.writeTo(&s)\n\treturn s.String()\n}\n\nfunc (e *Reduce) writeTo(s *strings.Builder) {\n\ts.WriteString(\"reduce \")\n\te.Query.writeTo(s)\n\ts.WriteString(\" as \")\n\te.Pattern.writeTo(s)\n\ts.WriteString(\" (\")\n\te.Start.writeTo(s)\n\ts.WriteString(\"; \")\n\te.Update.writeTo(s)\n\ts.WriteByte(')')\n}\n\nfunc (e *Reduce) minify() {\n\te.Query.minify()\n\te.Start.minify()\n\te.Update.minify()\n}\n\n// Foreach ...\ntype Foreach struct {\n\tQuery   *Query\n\tPattern *Pattern\n\tStart   *Query\n\tUpdate  *Query\n\tExtract *Query\n}\n\nfunc (e *Foreach) String() string {\n\tvar s strings.Builder\n\te.writeTo(&s)\n\treturn s.String()\n}\n\nfunc (e *Foreach) writeTo(s *strings.Builder) {\n\ts.WriteString(\"foreach \")\n\te.Query.writeTo(s)\n\ts.WriteString(\" as \")\n\te.Pattern.writeTo(s)\n\ts.WriteString(\" (\")\n\te.Start.writeTo(s)\n\ts.WriteString(\"; \")\n\te.Update.writeTo(s)\n\tif e.Extract != nil {\n\t\ts.WriteString(\"; \")\n\t\te.Extract.writeTo(s)\n\t}\n\ts.WriteByte(')')\n}\n\nfunc (e *Foreach) minify() {\n\te.Query.minify()\n\te.Start.minify()\n\te.Update.minify()\n\tif e.Extract != nil {\n\t\te.Extract.minify()\n\t}\n}\n\n// Label ...\ntype Label struct {\n\tIdent string\n\tBody  *Query\n}\n\nfunc (e *Label) String() string {\n\tvar s strings.Builder\n\te.writeTo(&s)\n\treturn s.String()\n}\n\nfunc (e *Label) writeTo(s *strings.Builder) {\n\ts.WriteString(\"label \")\n\ts.WriteString(e.Ident)\n\ts.WriteString(\" | \")\n\te.Body.writeTo(s)\n}\n\nfunc (e *Label) minify() {\n\te.Body.minify()\n}\n\n// ConstTerm ...\ntype ConstTerm struct {\n\tObject *ConstObject\n\tArray  *ConstArray\n\tNumber string\n\tStr    string\n\tNull   bool\n\tTrue   bool\n\tFalse  bool\n}\n\nfunc (e *ConstTerm) String() string {\n\tvar s strings.Builder\n\te.writeTo(&s)\n\treturn s.String()\n}\n\nfunc (e *ConstTerm) writeTo(s *strings.Builder) {\n\tif e.Object != nil {\n\t\te.Object.writeTo(s)\n\t} else if e.Array != nil {\n\t\te.Array.writeTo(s)\n\t} else if e.Number != \"\" {\n\t\ts.WriteString(e.Number)\n\t} else if e.Null {\n\t\ts.WriteString(\"null\")\n\t} else if e.True {\n\t\ts.WriteString(\"true\")\n\t} else if e.False {\n\t\ts.WriteString(\"false\")\n\t} else {\n\t\tjsonEncodeString(s, e.Str)\n\t}\n}\n\nfunc (e *ConstTerm) toValue() any {\n\tif e.Object != nil {\n\t\treturn e.Object.ToValue()\n\t} else if e.Array != nil {\n\t\treturn e.Array.toValue()\n\t} else if e.Number != \"\" {\n\t\treturn toNumber(e.Number)\n\t} else if e.Null {\n\t\treturn nil\n\t} else if e.True {\n\t\treturn true\n\t} else if e.False {\n\t\treturn false\n\t} else {\n\t\treturn e.Str\n\t}\n}\n\nfunc (e *ConstTerm) toString() (string, bool) {\n\tif e.Object != nil || e.Array != nil ||\n\t\te.Number != \"\" || e.Null || e.True || e.False {\n\t\treturn \"\", false\n\t}\n\treturn e.Str, true\n}\n\n// ConstObject ...\ntype ConstObject struct {\n\tKeyVals []*ConstObjectKeyVal\n}\n\nfunc (e *ConstObject) String() string {\n\tvar s strings.Builder\n\te.writeTo(&s)\n\treturn s.String()\n}\n\nfunc (e *ConstObject) writeTo(s *strings.Builder) {\n\tif len(e.KeyVals) == 0 {\n\t\ts.WriteString(\"{}\")\n\t\treturn\n\t}\n\ts.WriteString(\"{ \")\n\tfor i, kv := range e.KeyVals {\n\t\tif i > 0 {\n\t\t\ts.WriteString(\", \")\n\t\t}\n\t\tkv.writeTo(s)\n\t}\n\ts.WriteString(\" }\")\n}\n\n// ToValue converts the object to map[string]any.\nfunc (e *ConstObject) ToValue() map[string]any {\n\tif e == nil {\n\t\treturn nil\n\t}\n\tv := make(map[string]any, len(e.KeyVals))\n\tfor _, e := range e.KeyVals {\n\t\tkey := e.Key\n\t\tif key == \"\" {\n\t\t\tkey = e.KeyString\n\t\t}\n\t\tv[key] = e.Val.toValue()\n\t}\n\treturn v\n}\n\n// ConstObjectKeyVal ...\ntype ConstObjectKeyVal struct {\n\tKey       string\n\tKeyString string\n\tVal       *ConstTerm\n}\n\nfunc (e *ConstObjectKeyVal) String() string {\n\tvar s strings.Builder\n\te.writeTo(&s)\n\treturn s.String()\n}\n\nfunc (e *ConstObjectKeyVal) writeTo(s *strings.Builder) {\n\tif e.Key != \"\" {\n\t\ts.WriteString(e.Key)\n\t} else {\n\t\tjsonEncodeString(s, e.KeyString)\n\t}\n\ts.WriteString(\": \")\n\te.Val.writeTo(s)\n}\n\n// ConstArray ...\ntype ConstArray struct {\n\tElems []*ConstTerm\n}\n\nfunc (e *ConstArray) String() string {\n\tvar s strings.Builder\n\te.writeTo(&s)\n\treturn s.String()\n}\n\nfunc (e *ConstArray) writeTo(s *strings.Builder) {\n\ts.WriteByte('[')\n\tfor i, e := range e.Elems {\n\t\tif i > 0 {\n\t\t\ts.WriteString(\", \")\n\t\t}\n\t\te.writeTo(s)\n\t}\n\ts.WriteByte(']')\n}\n\nfunc (e *ConstArray) toValue() []any {\n\tv := make([]any, len(e.Elems))\n\tfor i, e := range e.Elems {\n\t\tv[i] = e.toValue()\n\t}\n\treturn v\n}\n"
        },
        {
          "name": "query_test.go",
          "type": "blob",
          "size": 8.5673828125,
          "content": "package gojq_test\n\nimport (\n\t\"context\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"log\"\n\t\"math\"\n\t\"math/big\"\n\t\"os\"\n\t\"reflect\"\n\t\"strconv\"\n\t\"strings\"\n\t\"sync\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/itchyny/gojq\"\n)\n\nfunc ExampleQuery_Run() {\n\tquery, err := gojq.Parse(\".foo | ..\")\n\tif err != nil {\n\t\tlog.Fatalln(err)\n\t}\n\tinput := map[string]any{\"foo\": []any{1, 2, 3}}\n\titer := query.Run(input)\n\tfor {\n\t\tv, ok := iter.Next()\n\t\tif !ok {\n\t\t\tbreak\n\t\t}\n\t\tif err, ok := v.(error); ok {\n\t\t\tlog.Fatalln(err)\n\t\t}\n\t\tfmt.Printf(\"%#v\\n\", v)\n\t}\n\n\t// Output:\n\t// []interface {}{1, 2, 3}\n\t// 1\n\t// 2\n\t// 3\n}\n\nfunc ExampleQuery_RunWithContext() {\n\tquery, err := gojq.Parse(\"def f: f; f, f\")\n\tif err != nil {\n\t\tlog.Fatalln(err)\n\t}\n\tctx, cancel := context.WithTimeout(context.Background(), 100*time.Millisecond)\n\tdefer cancel()\n\titer := query.RunWithContext(ctx, nil)\n\tfor {\n\t\tv, ok := iter.Next()\n\t\tif !ok {\n\t\t\tbreak\n\t\t}\n\t\tif err, ok := v.(error); ok {\n\t\t\tfmt.Println(err)\n\t\t\tcontinue\n\t\t}\n\t\t_ = v\n\t}\n\n\t// Output:\n\t// context deadline exceeded\n}\n\nfunc TestQueryRun_Errors(t *testing.T) {\n\tquery, err := gojq.Parse(\".[] | error\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\titer := query.Run([]any{0, 1, 2, 3, 4})\n\tn := 0\n\tfor {\n\t\tv, ok := iter.Next()\n\t\tif !ok {\n\t\t\tbreak\n\t\t}\n\t\tif err, ok := v.(error); ok {\n\t\t\tif expected := \"error: \" + strconv.Itoa(n); err.Error() != expected {\n\t\t\t\tt.Errorf(\"expected: %v, got: %v\", expected, err)\n\t\t\t}\n\t\t} else {\n\t\t\tt.Errorf(\"should emit an error but got: %v\", v)\n\t\t}\n\t\tn++\n\t}\n\tif expected := 5; n != expected {\n\t\tt.Errorf(\"expected: %v, got: %v\", expected, n)\n\t}\n}\n\nfunc TestQueryRun_Halt(t *testing.T) {\n\tquery, err := gojq.Parse(\"0, halt, 1\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\titer := query.Run(nil)\n\tfor {\n\t\tv, ok := iter.Next()\n\t\tif !ok {\n\t\t\tbreak\n\t\t}\n\t\tif err, ok := v.(error); ok {\n\t\t\tif _, ok := err.(*gojq.HaltError); ok {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tt.Errorf(\"should emit a halt error but got: %v\", err)\n\t\t} else if expected := 0; v != expected {\n\t\t\tt.Errorf(\"expected: %#v, got: %#v\", expected, v)\n\t\t}\n\t}\n}\n\nfunc TestQueryRun_HaltError(t *testing.T) {\n\tquery, err := gojq.Parse(\".[] | halt_error\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\titer := query.Run([]any{\"foo\", \"bar\", \"baz\"})\n\tfor {\n\t\tv, ok := iter.Next()\n\t\tif !ok {\n\t\t\tbreak\n\t\t}\n\t\tif err, ok := v.(error); ok {\n\t\t\tif _, ok := err.(*gojq.HaltError); ok {\n\t\t\t\tif expected := \"halt error: foo\"; err.Error() != expected {\n\t\t\t\t\tt.Errorf(\"expected: %v, got: %v\", expected, err)\n\t\t\t\t}\n\t\t\t\tbreak\n\t\t\t} else {\n\t\t\t\tt.Errorf(\"should emit a halt error but got: %v\", err)\n\t\t\t}\n\t\t} else {\n\t\t\tt.Errorf(\"should emit an error but got: %v\", v)\n\t\t}\n\t}\n}\n\nfunc TestQueryRun_ObjectError(t *testing.T) {\n\tquery, err := gojq.Parse(\".[] | {(.): 1}\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\titer := query.Run([]any{0, \"x\", []any{}})\n\tfor {\n\t\tv, ok := iter.Next()\n\t\tif !ok {\n\t\t\tbreak\n\t\t}\n\t\tif err, ok := v.(error); ok {\n\t\t\texpected := \"expected a string for object key but got\"\n\t\t\tif !strings.Contains(err.Error(), expected) {\n\t\t\t\tt.Errorf(\"expected: %v, got: %v\", expected, err)\n\t\t\t}\n\t\t} else if expected := map[string]any{\"x\": 1}; !reflect.DeepEqual(v, expected) {\n\t\t\tt.Errorf(\"expected: %v, got: %v\", expected, v)\n\t\t}\n\t}\n}\n\nfunc TestQueryRun_IndexError(t *testing.T) {\n\tquery, err := gojq.Parse(\".foo\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\titer := query.Run([]any{0})\n\tfor {\n\t\tv, ok := iter.Next()\n\t\tif !ok {\n\t\t\tbreak\n\t\t}\n\t\tif err, ok := v.(error); ok {\n\t\t\texpected := \"expected an object but got: array ([0])\"\n\t\t\tif !strings.Contains(err.Error(), expected) {\n\t\t\t\tt.Errorf(\"expected: %v, got: %v\", expected, err)\n\t\t\t}\n\t\t} else {\n\t\t\tt.Errorf(\"should emit an error but got: %v\", v)\n\t\t}\n\t}\n}\n\nfunc TestQueryRun_InvalidPathError(t *testing.T) {\n\tquery, err := gojq.Parse(\". + 1, path(. + 1)\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\titer := query.Run(0)\n\tfor {\n\t\tv, ok := iter.Next()\n\t\tif !ok {\n\t\t\tbreak\n\t\t}\n\t\tif err, ok := v.(error); ok {\n\t\t\tif expected := \"invalid path against: number (1)\"; err.Error() != expected {\n\t\t\t\tt.Errorf(\"expected: %v, got: %v\", expected, err)\n\t\t\t}\n\t\t} else if expected := 1; !reflect.DeepEqual(v, expected) {\n\t\t\tt.Errorf(\"expected: %v, got: %v\", expected, v)\n\t\t}\n\t}\n}\n\nfunc TestQueryRun_IteratorError(t *testing.T) {\n\tquery, err := gojq.Parse(\".[]\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\titer := query.Run(nil)\n\tfor {\n\t\tv, ok := iter.Next()\n\t\tif !ok {\n\t\t\tbreak\n\t\t}\n\t\tif err, ok := v.(error); ok {\n\t\t\tif expected := \"cannot iterate over: null\"; err.Error() != expected {\n\t\t\t\tt.Errorf(\"expected: %v, got: %v\", expected, err)\n\t\t\t}\n\t\t} else {\n\t\t\tt.Errorf(\"should emit an error but got: %v\", v)\n\t\t}\n\t}\n}\n\nfunc TestQueryRun_Strings(t *testing.T) {\n\tquery, err := gojq.Parse(\n\t\t\"[\\\"\\x00\\\\\\\\\\\", \\\"\\x1f\\\\\\\"\\\", \\\"\\n\\\\n\\n\\\\(\\\"\\\\n\\\")\\n\\\\n\\\", \" +\n\t\t\t\"\\\"\\\\/\\\", \\\"\\x7f\\\", \\\"\\x80\\\", \\\"\\\\ud83d\\\\ude04\\\" | explode[]]\",\n\t)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\titer := query.Run(nil)\n\tfor {\n\t\tv, ok := iter.Next()\n\t\tif !ok {\n\t\t\tbreak\n\t\t}\n\t\tif err, ok := v.(error); ok {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tif expected := []any{\n\t\t\t0x00, int('\\\\'), 0x1f, int('\"'), int('\\n'), int('\\n'), int('\\n'),\n\t\t\tint('\\n'), int('\\n'), int('\\n'), int('/'), 0x7f, 0xfffd, 128516,\n\t\t}; !reflect.DeepEqual(v, expected) {\n\t\t\tt.Errorf(\"expected: %v, got: %v\", expected, v)\n\t\t}\n\t}\n}\n\nfunc TestQueryRun_NumericTypes(t *testing.T) {\n\tquery, err := gojq.Parse(\".[] + 0 != 0\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\titer := query.Run([]any{\n\t\tint64(1), int32(1), int16(1), int8(1), uint64(1), uint32(1), uint16(1), uint8(1), uint(math.MaxUint),\n\t\tint64(math.MaxInt64), int64(math.MinInt64), uint64(math.MaxUint64), uint32(math.MaxUint32),\n\t\tnew(big.Int).SetUint64(math.MaxUint64), new(big.Int).SetUint64(math.MaxUint32),\n\t\tjson.Number(fmt.Sprint(uint64(math.MaxInt64))), json.Number(fmt.Sprint(uint64(math.MaxInt32))),\n\t\tfloat64(1.0), float32(1.0),\n\t})\n\tfor {\n\t\tv, ok := iter.Next()\n\t\tif !ok {\n\t\t\tbreak\n\t\t}\n\t\tif err, ok := v.(error); ok {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tif expected := true; expected != v {\n\t\t\tt.Errorf(\"expected: %v, got: %v\", expected, v)\n\t\t}\n\t}\n}\n\nfunc TestQueryRun_Input(t *testing.T) {\n\tquery, err := gojq.Parse(\"input\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\titer := query.Run(nil)\n\tv, ok := iter.Next()\n\tif !ok {\n\t\tt.Fatal(\"should emit an error but got no output\")\n\t}\n\tif err, ok := v.(error); ok {\n\t\tif expected := \"input(s)/0 is not allowed\"; err.Error() != expected {\n\t\t\tt.Errorf(\"expected: %v, got: %v\", expected, err)\n\t\t}\n\t} else {\n\t\tt.Errorf(\"should emit an error but got: %v\", v)\n\t}\n}\n\nfunc TestQueryRun_NonNilSlice(t *testing.T) {\n\tfor _, f := range []string{\"keys\", \"map(.)\", \"to_entries\", \"arrays\",\n\t\t\"reverse\", \"flatten\", \"sort\", \"sort_by(.)\", \"group_by(.)\", \"unique\",\n\t\t\"unique_by(.)\", \"transpose\", \"nth(.)\", \"indices([])\", \"path(.)\"} {\n\t\tt.Run(f, func(t *testing.T) {\n\t\t\tquery, err := gojq.Parse(\"[] | \" + f)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\t\t\titer := query.Run(nil)\n\t\t\tfor {\n\t\t\t\tv, ok := iter.Next()\n\t\t\t\tif !ok {\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t\tif err, ok := v.(error); ok {\n\t\t\t\t\tt.Fatal(err)\n\t\t\t\t}\n\t\t\t\tif expected := []any{}; !reflect.DeepEqual(v, expected) {\n\t\t\t\t\tt.Errorf(\"expected: %#v, got: %#v\", expected, v)\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestQueryRun_Race(t *testing.T) {\n\tquery, err := gojq.Parse(\"range(10)\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tvar wg sync.WaitGroup\n\tfor i := 0; i < 10; i++ {\n\t\twg.Add(1)\n\t\tgo func() {\n\t\t\tdefer wg.Done()\n\t\t\titer := query.Run(nil)\n\t\t\tn := 0\n\t\t\tfor {\n\t\t\t\tgot, ok := iter.Next()\n\t\t\t\tif !ok {\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t\tif got != n {\n\t\t\t\t\tt.Errorf(\"expected: %v, got: %v\", n, got)\n\t\t\t\t}\n\t\t\t\tn++\n\t\t\t}\n\t\t\tif expected := 10; n != expected {\n\t\t\t\tt.Errorf(\"expected: %v, got: %v\", expected, n)\n\t\t\t}\n\t\t}()\n\t}\n\twg.Wait()\n}\n\nfunc TestQueryString(t *testing.T) {\n\tcnt, err := os.ReadFile(\"builtin.jq\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tq, err := gojq.Parse(string(cnt))\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tr, err := gojq.Parse(q.String())\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif !reflect.DeepEqual(q, r) {\n\t\tt.Errorf(\"\\n%v\\n%v\", q, r)\n\t}\n}\n\nfunc BenchmarkRun(b *testing.B) {\n\tquery, err := gojq.Parse(\"range(1000)\")\n\tif err != nil {\n\t\tb.Fatal(err)\n\t}\n\tfor i := 0; i < b.N; i++ {\n\t\titer := query.Run(nil)\n\t\tfor {\n\t\t\t_, ok := iter.Next()\n\t\t\tif !ok {\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc BenchmarkParse(b *testing.B) {\n\tcnt, err := os.ReadFile(\"builtin.jq\")\n\tif err != nil {\n\t\tb.Fatal(err)\n\t}\n\tsrc := string(cnt)\n\tfor i := 0; i < b.N; i++ {\n\t\t_, err := gojq.Parse(src)\n\t\tif err != nil {\n\t\t\tb.Fatal(err)\n\t\t}\n\t}\n}\n\nfunc FuzzQueryRun(f *testing.F) {\n\tf.Fuzz(func(t *testing.T, src string) {\n\t\tif len(src) > 16 {\n\t\t\tt.SkipNow()\n\t\t}\n\t\tq, err := gojq.Parse(src)\n\t\tif err != nil {\n\t\t\tt.SkipNow()\n\t\t}\n\t\tcode, err := gojq.Compile(q)\n\t\tif err != nil {\n\t\t\tt.SkipNow()\n\t\t}\n\t\tctx, cancel := context.WithTimeout(context.Background(), 100*time.Millisecond)\n\t\tt.Cleanup(cancel)\n\t\titer := code.RunWithContext(ctx, nil)\n\t\tfor {\n\t\t\tif _, ok := iter.Next(); !ok {\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t})\n}\n"
        },
        {
          "name": "release.go",
          "type": "blob",
          "size": 0.2470703125,
          "content": "//go:build !gojq_debug\n\npackage gojq\n\ntype codeinfo struct{}\n\nfunc (*compiler) appendCodeInfo(any) {}\n\nfunc (*compiler) deleteCodeInfo(string) {}\n\nfunc (*env) debugCodes() {}\n\nfunc (*env) debugState(int, bool) {}\n\nfunc (*env) debugForks(int, string) {}\n"
        },
        {
          "name": "scope_stack.go",
          "type": "blob",
          "size": 0.7724609375,
          "content": "package gojq\n\ntype scopeStack struct {\n\tdata  []scopeBlock\n\tindex int\n\tlimit int\n}\n\ntype scopeBlock struct {\n\tvalue scope\n\tnext  int\n}\n\nfunc newScopeStack() *scopeStack {\n\treturn &scopeStack{index: -1, limit: -1}\n}\n\nfunc (s *scopeStack) push(v scope) {\n\tb := scopeBlock{v, s.index}\n\ts.index = max(s.index, s.limit) + 1\n\tif s.index < len(s.data) {\n\t\ts.data[s.index] = b\n\t} else {\n\t\ts.data = append(s.data, b)\n\t}\n}\n\nfunc (s *scopeStack) pop() scope {\n\tb := s.data[s.index]\n\ts.index = b.next\n\treturn b.value\n}\n\nfunc (s *scopeStack) empty() bool {\n\treturn s.index < 0\n}\n\nfunc (s *scopeStack) save() (index, limit int) {\n\tindex, limit = s.index, s.limit\n\tif s.index > s.limit {\n\t\ts.limit = s.index\n\t}\n\treturn\n}\n\nfunc (s *scopeStack) restore(index, limit int) {\n\ts.index, s.limit = index, limit\n}\n"
        },
        {
          "name": "stack.go",
          "type": "blob",
          "size": 0.767578125,
          "content": "package gojq\n\ntype stack struct {\n\tdata  []block\n\tindex int\n\tlimit int\n}\n\ntype block struct {\n\tvalue any\n\tnext  int\n}\n\nfunc newStack() *stack {\n\treturn &stack{index: -1, limit: -1}\n}\n\nfunc (s *stack) push(v any) {\n\tb := block{v, s.index}\n\ts.index = max(s.index, s.limit) + 1\n\tif s.index < len(s.data) {\n\t\ts.data[s.index] = b\n\t} else {\n\t\ts.data = append(s.data, b)\n\t}\n}\n\nfunc (s *stack) pop() any {\n\tb := s.data[s.index]\n\ts.index = b.next\n\treturn b.value\n}\n\nfunc (s *stack) top() any {\n\treturn s.data[s.index].value\n}\n\nfunc (s *stack) empty() bool {\n\treturn s.index < 0\n}\n\nfunc (s *stack) save() (index, limit int) {\n\tindex, limit = s.index, s.limit\n\tif s.index > s.limit {\n\t\ts.limit = s.index\n\t}\n\treturn\n}\n\nfunc (s *stack) restore(index, limit int) {\n\ts.index, s.limit = index, limit\n}\n"
        },
        {
          "name": "term_type.go",
          "type": "blob",
          "size": 1.5048828125,
          "content": "package gojq\n\n// TermType represents the type of [Term].\ntype TermType int\n\n// TermType list.\nconst (\n\tTermTypeIdentity TermType = iota + 1\n\tTermTypeRecurse\n\tTermTypeNull\n\tTermTypeTrue\n\tTermTypeFalse\n\tTermTypeIndex\n\tTermTypeFunc\n\tTermTypeObject\n\tTermTypeArray\n\tTermTypeNumber\n\tTermTypeUnary\n\tTermTypeFormat\n\tTermTypeString\n\tTermTypeIf\n\tTermTypeTry\n\tTermTypeReduce\n\tTermTypeForeach\n\tTermTypeLabel\n\tTermTypeBreak\n\tTermTypeQuery\n)\n\n// GoString implements [fmt.GoStringer].\nfunc (termType TermType) GoString() (str string) {\n\tdefer func() { str = \"gojq.\" + str }()\n\tswitch termType {\n\tcase TermTypeIdentity:\n\t\treturn \"TermTypeIdentity\"\n\tcase TermTypeRecurse:\n\t\treturn \"TermTypeRecurse\"\n\tcase TermTypeNull:\n\t\treturn \"TermTypeNull\"\n\tcase TermTypeTrue:\n\t\treturn \"TermTypeTrue\"\n\tcase TermTypeFalse:\n\t\treturn \"TermTypeFalse\"\n\tcase TermTypeIndex:\n\t\treturn \"TermTypeIndex\"\n\tcase TermTypeFunc:\n\t\treturn \"TermTypeFunc\"\n\tcase TermTypeObject:\n\t\treturn \"TermTypeObject\"\n\tcase TermTypeArray:\n\t\treturn \"TermTypeArray\"\n\tcase TermTypeNumber:\n\t\treturn \"TermTypeNumber\"\n\tcase TermTypeUnary:\n\t\treturn \"TermTypeUnary\"\n\tcase TermTypeFormat:\n\t\treturn \"TermTypeFormat\"\n\tcase TermTypeString:\n\t\treturn \"TermTypeString\"\n\tcase TermTypeIf:\n\t\treturn \"TermTypeIf\"\n\tcase TermTypeTry:\n\t\treturn \"TermTypeTry\"\n\tcase TermTypeReduce:\n\t\treturn \"TermTypeReduce\"\n\tcase TermTypeForeach:\n\t\treturn \"TermTypeForeach\"\n\tcase TermTypeLabel:\n\t\treturn \"TermTypeLabel\"\n\tcase TermTypeBreak:\n\t\treturn \"TermTypeBreak\"\n\tcase TermTypeQuery:\n\t\treturn \"TermTypeQuery\"\n\tdefault:\n\t\tpanic(termType)\n\t}\n}\n"
        },
        {
          "name": "type.go",
          "type": "blob",
          "size": 0.5673828125,
          "content": "package gojq\n\nimport (\n\t\"fmt\"\n\t\"math/big\"\n)\n\n// TypeOf returns the jq-flavored type name of v.\n//\n// This method is used by built-in type/0 function, and accepts only limited\n// types (nil, bool, int, float64, *big.Int, string, []any, and map[string]any).\nfunc TypeOf(v any) string {\n\tswitch v.(type) {\n\tcase nil:\n\t\treturn \"null\"\n\tcase bool:\n\t\treturn \"boolean\"\n\tcase int, float64, *big.Int:\n\t\treturn \"number\"\n\tcase string:\n\t\treturn \"string\"\n\tcase []any:\n\t\treturn \"array\"\n\tcase map[string]any:\n\t\treturn \"object\"\n\tdefault:\n\t\tpanic(fmt.Sprintf(\"invalid type: %[1]T (%[1]v)\", v))\n\t}\n}\n"
        },
        {
          "name": "type_test.go",
          "type": "blob",
          "size": 0.9375,
          "content": "package gojq_test\n\nimport (\n\t\"fmt\"\n\t\"math\"\n\t\"math/big\"\n\t\"testing\"\n\n\t\"github.com/itchyny/gojq\"\n)\n\nfunc TestTypeOf(t *testing.T) {\n\ttestCases := []struct {\n\t\tvalue    any\n\t\texpected string\n\t}{\n\t\t{nil, \"null\"},\n\t\t{false, \"boolean\"},\n\t\t{true, \"boolean\"},\n\t\t{0, \"number\"},\n\t\t{3.14, \"number\"},\n\t\t{math.NaN(), \"number\"},\n\t\t{math.Inf(1), \"number\"},\n\t\t{math.Inf(-1), \"number\"},\n\t\t{big.NewInt(10), \"number\"},\n\t\t{\"string\", \"string\"},\n\t\t{[]any{}, \"array\"},\n\t\t{map[string]any{}, \"object\"},\n\t}\n\tfor _, tc := range testCases {\n\t\tt.Run(fmt.Sprintf(\"%v\", tc.value), func(t *testing.T) {\n\t\t\tgot := gojq.TypeOf(tc.value)\n\t\t\tif got != tc.expected {\n\t\t\t\tt.Errorf(\"TypeOf(%v): got %s, expected %s\", tc.value, got, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n\tfunc() {\n\t\tv := []int{0}\n\t\tdefer func() {\n\t\t\tif got, expected := recover(), \"invalid type: []int ([0])\"; got != expected {\n\t\t\t\tt.Errorf(\"TypeOf(%v) should panic: got %v, expected %v\", v, got, expected)\n\t\t\t}\n\t\t}()\n\t\t_ = gojq.TypeOf(v)\n\t}()\n}\n"
        }
      ]
    }
  ]
}