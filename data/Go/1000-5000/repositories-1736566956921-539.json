{
  "metadata": {
    "timestamp": 1736566956921,
    "page": 539,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjU0MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "sideshow/apns2",
      "stars": 3026,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.296875,
          "content": "# Compiled Object files, Static and Dynamic libs (Shared Objects)\n*.o\n*.a\n*.so\n\n# Folders\n_obj\n_test\n\n# Architecture specific extensions/prefixes\n*.[568vq]\n[568vq].out\n\n*.cgo1.go\n*.cgo2.c\n_cgo_defun.c\n_cgo_gotypes.go\n_cgo_export.*\n\n_testmain.go\n\n*.exe\n*.test\n*.prof\n\n/*.p12\n/*.pem\n/*.cer\n/*.p8\n\n.DS_Store"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.052734375,
          "content": "The MIT License (MIT)\n\nCopyright (c) 2016 Adam Jones\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 9.0380859375,
          "content": "# APNS/2\n\nAPNS/2 is a go package designed for simple, flexible and fast Apple Push Notifications on iOS, OSX and Safari using the new HTTP/2 Push provider API.\n\n[![Build Status](https://github.com/sideshow/apns2/actions/workflows/tests.yml/badge.svg)](https://github.com/sideshow/apns2/actions/workflows/tests.yml) [![Coverage Status](https://coveralls.io/repos/sideshow/apns2/badge.svg?branch=master&service=github)](https://coveralls.io/github/sideshow/apns2?branch=master) [![GoDoc](https://godoc.org/github.com/sideshow/apns2?status.svg)](https://godoc.org/github.com/sideshow/apns2)\n\n## Features\n\n- Uses new Apple APNs HTTP/2 connection\n- Fast - See [notes on speed](https://github.com/sideshow/apns2/wiki/APNS-HTTP-2-Push-Speed)\n- Works with go 1.7 and later\n- Supports new Apple Token Based Authentication (JWT)\n- Supports new iOS 10 features such as Collapse IDs, Subtitles and Mutable Notifications\n- Supports new iOS 15 features interruptionLevel and relevanceScore\n- Supports persistent connections to APNs\n- Supports VoIP/PushKit notifications (iOS 8 and later)\n- Modular & easy to use\n- Tested and working in APNs production environment\n\n## Install\n\n- Make sure you have [Go](https://golang.org/doc/install) installed and have set your [GOPATH](https://golang.org/doc/code.html#GOPATH).\n- Install apns2:\n\n```sh\ngo get -u github.com/sideshow/apns2\n```\n\nIf you are running the test suite you will also need to install testify:\n\n```sh\ngo get -u github.com/stretchr/testify\n```\n\n## Example\n\n```go\npackage main\n\nimport (\n  \"log\"\n  \"fmt\"\n\n  \"github.com/sideshow/apns2\"\n  \"github.com/sideshow/apns2/certificate\"\n)\n\nfunc main() {\n\n  cert, err := certificate.FromP12File(\"../cert.p12\", \"\")\n  if err != nil {\n    log.Fatal(\"Cert Error:\", err)\n  }\n\n  notification := &apns2.Notification{}\n  notification.DeviceToken = \"11aa01229f15f0f0c52029d8cf8cd0aeaf2365fe4cebc4af26cd6d76b7919ef7\"\n  notification.Topic = \"com.sideshow.Apns2\"\n  notification.Payload = []byte(`{\"aps\":{\"alert\":\"Hello!\"}}`) // See Payload section below\n\n  // If you want to test push notifications for builds running directly from XCode (Development), use\n  // client := apns2.NewClient(cert).Development()\n  // For apps published to the app store or installed as an ad-hoc distribution use Production()\n\n  client := apns2.NewClient(cert).Production()\n  res, err := client.Push(notification)\n\n  if err != nil {\n    log.Fatal(\"Error:\", err)\n  }\n\n  fmt.Printf(\"%v %v %v\\n\", res.StatusCode, res.ApnsID, res.Reason)\n}\n```\n\n## JWT Token Example\n\nInstead of using a `.p12` or `.pem` certificate as above, you can optionally use\nAPNs JWT _Provider Authentication Tokens_. First you will need a signing key (`.p8` file), Key ID and Team ID [from Apple](http://help.apple.com/xcode/mac/current/#/dev54d690a66). Once you have these details, you can create a new client:\n\n```go\nauthKey, err := token.AuthKeyFromFile(\"../AuthKey_XXX.p8\")\nif err != nil {\n  log.Fatal(\"token error:\", err)\n}\n\ntoken := &token.Token{\n  AuthKey: authKey,\n  // KeyID from developer account (Certificates, Identifiers & Profiles -> Keys)\n  KeyID:   \"ABC123DEFG\",\n  // TeamID from developer account (View Account -> Membership)\n  TeamID:  \"DEF123GHIJ\",\n}\n...\n\nclient := apns2.NewTokenClient(token)\nres, err := client.Push(notification)\n```\n\n- You can use one APNs signing key to authenticate tokens for multiple apps.\n- A signing key works for both the development and production environments.\n- A signing key doesn’t expire but can be revoked.\n\n## Notification\n\nAt a minimum, a _Notification_ needs a _DeviceToken_, a _Topic_ and a _Payload_.\n\n```go\nnotification := &apns2.Notification{\n  DeviceToken: \"11aa01229f15f0f0c52029d8cf8cd0aeaf2365fe4cebc4af26cd6d76b7919ef7\",\n  Topic: \"com.sideshow.Apns2\",\n  Payload: []byte(`{\"aps\":{\"alert\":\"Hello!\"}}`),\n}\n```\n\nYou can also set an optional _ApnsID_, _Expiration_ or _Priority_.\n\n```go\nnotification.ApnsID =  \"40636A2C-C093-493E-936A-2A4333C06DEA\"\nnotification.Expiration = time.Now()\nnotification.Priority = apns2.PriorityLow\n```\n\n## Payload\n\nYou can use raw bytes for the `notification.Payload` as above, or you can use the payload builder package which makes it easy to construct APNs payloads.\n\n```go\n// {\"aps\":{\"alert\":\"hello\",\"badge\":1},\"key\":\"val\"}\n\npayload := payload.NewPayload().Alert(\"hello\").Badge(1).Custom(\"key\", \"val\")\n\nnotification.Payload = payload\nclient.Push(notification)\n```\n\nRefer to the [payload](https://godoc.org/github.com/sideshow/apns2/payload) docs for more info.\n\n## Response, Error handling\n\nAPNS/2 draws the distinction between a valid response from Apple indicating whether or not the _Notification_ was sent or not, and an unrecoverable or unexpected _Error_;\n\n- An `Error` is returned if a non-recoverable error occurs, i.e. if there is a problem with the underlying _http.Client_ connection or _Certificate_, the payload was not sent, or a valid _Response_ was not received.\n- A `Response` is returned if the payload was successfully sent to Apple and a documented response was received. This struct will contain more information about whether or not the push notification succeeded, its _apns-id_ and if applicable, more information around why it did not succeed.\n\nTo check if a `Notification` was successfully sent;\n\n```go\nres, err := client.Push(notification)\nif err != nil {\n  log.Println(\"There was an error\", err)\n  return\n}\n\nif res.Sent() {\n  log.Println(\"Sent:\", res.ApnsID)\n} else {\n  fmt.Printf(\"Not Sent: %v %v %v\\n\", res.StatusCode, res.ApnsID, res.Reason)\n}\n```\n\n## Context & Timeouts\n\nFor better control over request cancellations and timeouts APNS/2 supports\ncontexts. Using a context can be helpful if you want to cancel all pushes when\nthe parent process is cancelled, or need finer grained control over individual\npush timeouts. See the [Google post](https://blog.golang.org/context) for more\ninformation on contexts.\n\n```go\nctx, cancel = context.WithTimeout(context.Background(), 10 * time.Second)\nres, err := client.PushWithContext(ctx, notification)\ndefer cancel()\n```\n\n## Speed & Performance\n\nAlso see the wiki page on [APNS HTTP 2 Push Speed](https://github.com/sideshow/apns2/wiki/APNS-HTTP-2-Push-Speed).\n\nFor best performance, you should hold on to an `apns2.Client` instance and not re-create it every push. The underlying TLS connection itself can take a few seconds to connect and negotiate, so if you are setting up an `apns2.Client` and tearing it down every push, then this will greatly affect performance. (Apple suggest keeping the connection open all the time).\n\nYou should also limit the amount of `apns2.Client` instances. The underlying transport has a http connection pool itself, so a single client instance will be enough for most users (One instance can potentially do 4,000+ pushes per second). If you need more than this then one instance per CPU core is a good starting point.\n\nSpeed is greatly affected by the location of your server and the quality of your network connection. If you're just testing locally, behind a proxy or if your server is outside USA then you're not going to get great performance. With a good server located in AWS, you should be able to get [decent throughput](https://github.com/sideshow/apns2/wiki/APNS-HTTP-2-Push-Speed).\n\n## Command line tool\n\nAPNS/2 has a command line tool that can be installed with `go get github.com/sideshow/apns2/apns2`. Usage:\n\n```\napns2 --help\nusage: apns2 --certificate-path=CERTIFICATE-PATH --topic=TOPIC [<flags>]\n\nListens to STDIN to send notifications and writes APNS response code and reason to STDOUT.\n\nThe expected format is: <DeviceToken> <APNS Payload>\nExample: aff0c63d9eaa63ad161bafee732d5bc2c31f66d552054718ff19ce314371e5d0 {\"aps\": {\"alert\": \"hi\"}}\nFlags:\n      --help               Show context-sensitive help (also try --help-long and --help-man).\n  -c, --certificate-path=CERTIFICATE-PATH\n                           Path to certificate file.\n  -t, --topic=TOPIC        The topic of the remote notification, which is typically the bundle ID for your app\n  -m, --mode=\"production\"  APNS server to send notifications to. `production` or `development`. Defaults to `production`\n      --version            Show application version.\n```\n\n## License\n\nThe MIT License (MIT)\n\nCopyright (c) 2016 Adam Jones\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON INFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n"
        },
        {
          "name": "_example",
          "type": "tree",
          "content": null
        },
        {
          "name": "apns2",
          "type": "tree",
          "content": null
        },
        {
          "name": "certificate",
          "type": "tree",
          "content": null
        },
        {
          "name": "client.go",
          "type": "blob",
          "size": 7.3681640625,
          "content": "// Package apns2 is a go Apple Push Notification Service (APNs) provider that\n// allows you to send remote notifications to your iOS, tvOS, and OS X\n// apps, using the new APNs HTTP/2 network protocol.\npackage apns2\n\nimport (\n\t\"bytes\"\n\t\"context\"\n\t\"crypto/tls\"\n\t\"encoding/json\"\n\t\"io\"\n\t\"net\"\n\t\"net/http\"\n\t\"strconv\"\n\t\"time\"\n\n\t\"github.com/sideshow/apns2/token\"\n\t\"golang.org/x/net/http2\"\n)\n\n// Apple HTTP/2 Development & Production urls\nconst (\n\tHostDevelopment = \"https://api.sandbox.push.apple.com\"\n\tHostProduction  = \"https://api.push.apple.com\"\n)\n\n// DefaultHost is a mutable var for testing purposes\nvar DefaultHost = HostDevelopment\n\nvar (\n\t// HTTPClientTimeout specifies a time limit for requests made by the\n\t// HTTPClient. The timeout includes connection time, any redirects,\n\t// and reading the response body.\n\tHTTPClientTimeout = 60 * time.Second\n\n\t// ReadIdleTimeout is the timeout after which a health check using a ping\n\t// frame will be carried out if no frame is received on the connection. If\n\t// zero, no health check is performed.\n\tReadIdleTimeout = 15 * time.Second\n\n\t// TCPKeepAlive specifies the keep-alive period for an active network\n\t// connection. If zero, keep-alive probes are sent with a default value\n\t// (currently 15 seconds)\n\tTCPKeepAlive = 15 * time.Second\n\n\t// TLSDialTimeout is the maximum amount of time a dial will wait for a connect\n\t// to complete.\n\tTLSDialTimeout = 20 * time.Second\n)\n\n// DialTLS is the default dial function for creating TLS connections for\n// non-proxied HTTPS requests.\nvar DialTLS = func(network, addr string, cfg *tls.Config) (net.Conn, error) {\n\tdialer := &net.Dialer{\n\t\tTimeout:   TLSDialTimeout,\n\t\tKeepAlive: TCPKeepAlive,\n\t}\n\treturn tls.DialWithDialer(dialer, network, addr, cfg)\n}\n\n// Client represents a connection with the APNs\ntype Client struct {\n\tHost        string\n\tCertificate tls.Certificate\n\tToken       *token.Token\n\tHTTPClient  *http.Client\n}\n\n// A Context carries a deadline, a cancellation signal, and other values across\n// API boundaries. Context's methods may be called by multiple goroutines\n// simultaneously.\ntype Context interface {\n\tcontext.Context\n}\n\ntype connectionCloser interface {\n\tCloseIdleConnections()\n}\n\n// NewClient returns a new Client with an underlying http.Client configured with\n// the correct APNs HTTP/2 transport settings. It does not connect to the APNs\n// until the first Notification is sent via the Push method.\n//\n// As per the Apple APNs Provider API, you should keep a handle on this client\n// so that you can keep your connections with APNs open across multiple\n// notifications; don’t repeatedly open and close connections. APNs treats rapid\n// connection and disconnection as a denial-of-service attack.\n//\n// If your use case involves multiple long-lived connections, consider using\n// the ClientManager, which manages clients for you.\nfunc NewClient(certificate tls.Certificate) *Client {\n\ttlsConfig := &tls.Config{\n\t\tCertificates: []tls.Certificate{certificate},\n\t}\n\tif len(certificate.Certificate) > 0 {\n\t\ttlsConfig.BuildNameToCertificate()\n\t}\n\ttransport := &http2.Transport{\n\t\tTLSClientConfig: tlsConfig,\n\t\tDialTLS:         DialTLS,\n\t\tReadIdleTimeout: ReadIdleTimeout,\n\t}\n\treturn &Client{\n\t\tHTTPClient: &http.Client{\n\t\t\tTransport: transport,\n\t\t\tTimeout:   HTTPClientTimeout,\n\t\t},\n\t\tCertificate: certificate,\n\t\tHost:        DefaultHost,\n\t}\n}\n\n// NewTokenClient returns a new Client with an underlying http.Client configured\n// with the correct APNs HTTP/2 transport settings. It does not connect to the APNs\n// until the first Notification is sent via the Push method.\n//\n// As per the Apple APNs Provider API, you should keep a handle on this client\n// so that you can keep your connections with APNs open across multiple\n// notifications; don’t repeatedly open and close connections. APNs treats rapid\n// connection and disconnection as a denial-of-service attack.\nfunc NewTokenClient(token *token.Token) *Client {\n\ttransport := &http2.Transport{\n\t\tDialTLS:         DialTLS,\n\t\tReadIdleTimeout: ReadIdleTimeout,\n\t}\n\treturn &Client{\n\t\tToken: token,\n\t\tHTTPClient: &http.Client{\n\t\t\tTransport: transport,\n\t\t\tTimeout:   HTTPClientTimeout,\n\t\t},\n\t\tHost: DefaultHost,\n\t}\n}\n\n// Development sets the Client to use the APNs development push endpoint.\nfunc (c *Client) Development() *Client {\n\tc.Host = HostDevelopment\n\treturn c\n}\n\n// Production sets the Client to use the APNs production push endpoint.\nfunc (c *Client) Production() *Client {\n\tc.Host = HostProduction\n\treturn c\n}\n\n// Push sends a Notification to the APNs gateway. If the underlying http.Client\n// is not currently connected, this method will attempt to reconnect\n// transparently before sending the notification. It will return a Response\n// indicating whether the notification was accepted or rejected by the APNs\n// gateway, or an error if something goes wrong.\n//\n// Use PushWithContext if you need better cancellation and timeout control.\nfunc (c *Client) Push(n *Notification) (*Response, error) {\n\treturn c.PushWithContext(context.Background(), n)\n}\n\n// PushWithContext sends a Notification to the APNs gateway. Context carries a\n// deadline and a cancellation signal and allows you to close long running\n// requests when the context timeout is exceeded. Context can be nil, for\n// backwards compatibility.\n//\n// If the underlying http.Client is not currently connected, this method will\n// attempt to reconnect transparently before sending the notification. It will\n// return a Response indicating whether the notification was accepted or\n// rejected by the APNs gateway, or an error if something goes wrong.\nfunc (c *Client) PushWithContext(ctx Context, n *Notification) (*Response, error) {\n\tpayload, err := json.Marshal(n)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\turl := c.Host + \"/3/device/\" + n.DeviceToken\n\trequest, err := http.NewRequestWithContext(ctx, http.MethodPost, url, bytes.NewReader(payload))\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif c.Token != nil {\n\t\tc.setTokenHeader(request)\n\t}\n\n\tsetHeaders(request, n)\n\n\tresponse, err := c.HTTPClient.Do(request)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer response.Body.Close()\n\n\tr := &Response{}\n\tr.StatusCode = response.StatusCode\n\tr.ApnsID = response.Header.Get(\"apns-id\")\n\tr.ApnsUniqueID = response.Header.Get(\"apns-unique-id\")\n\n\tdecoder := json.NewDecoder(response.Body)\n\tif err := decoder.Decode(r); err != nil && err != io.EOF {\n\t\treturn &Response{}, err\n\t}\n\treturn r, nil\n}\n\n// CloseIdleConnections closes any underlying connections which were previously\n// connected from previous requests but are now sitting idle. It will not\n// interrupt any connections currently in use.\nfunc (c *Client) CloseIdleConnections() {\n\tc.HTTPClient.Transport.(connectionCloser).CloseIdleConnections()\n}\n\nfunc (c *Client) setTokenHeader(r *http.Request) {\n\tbearer := c.Token.GenerateIfExpired()\n\tr.Header.Set(\"authorization\", \"bearer \"+bearer)\n}\n\nfunc setHeaders(r *http.Request, n *Notification) {\n\tr.Header.Set(\"Content-Type\", \"application/json; charset=utf-8\")\n\tif n.Topic != \"\" {\n\t\tr.Header.Set(\"apns-topic\", n.Topic)\n\t}\n\tif n.ApnsID != \"\" {\n\t\tr.Header.Set(\"apns-id\", n.ApnsID)\n\t}\n\tif n.CollapseID != \"\" {\n\t\tr.Header.Set(\"apns-collapse-id\", n.CollapseID)\n\t}\n\tif n.Priority > 0 {\n\t\tr.Header.Set(\"apns-priority\", strconv.Itoa(n.Priority))\n\t}\n\tif n.Expiration.After(time.Unix(0, 0)) {\n\t\tr.Header.Set(\"apns-expiration\", strconv.FormatInt(n.Expiration.Unix(), 10))\n\t}\n\tif n.PushType != \"\" {\n\t\tr.Header.Set(\"apns-push-type\", string(n.PushType))\n\t} else {\n\t\tr.Header.Set(\"apns-push-type\", string(PushTypeAlert))\n\t}\n}\n"
        },
        {
          "name": "client_manager.go",
          "type": "blob",
          "size": 3.7744140625,
          "content": "package apns2\n\nimport (\n\t\"container/list\"\n\t\"crypto/sha1\"\n\t\"crypto/tls\"\n\t\"sync\"\n\t\"time\"\n)\n\ntype managerItem struct {\n\tkey      [sha1.Size]byte\n\tclient   *Client\n\tlastUsed time.Time\n}\n\n// ClientManager is a way to manage multiple connections to the APNs.\ntype ClientManager struct {\n\t// MaxSize is the maximum number of clients allowed in the manager. When\n\t// this limit is reached, the least recently used client is evicted. Set\n\t// zero for no limit.\n\tMaxSize int\n\n\t// MaxAge is the maximum age of clients in the manager. Upon retrieval, if\n\t// a client has remained unused in the manager for this duration or longer,\n\t// it is evicted and nil is returned. Set zero to disable this\n\t// functionality.\n\tMaxAge time.Duration\n\n\t// Factory is the function which constructs clients if not found in the\n\t// manager.\n\tFactory func(certificate tls.Certificate) *Client\n\n\tcache map[[sha1.Size]byte]*list.Element\n\tll    *list.List\n\tmu    sync.Mutex\n\tonce  sync.Once\n}\n\n// NewClientManager returns a new ClientManager for prolonged, concurrent usage\n// of multiple APNs clients. ClientManager is flexible enough to work best for\n// your use case. When a client is not found in the manager, Get will return\n// the result of calling Factory, which can be a Client or nil.\n//\n// Having multiple clients per certificate in the manager is not allowed.\n//\n// By default, MaxSize is 64, MaxAge is 10 minutes, and Factory always returns\n// a Client with default options.\nfunc NewClientManager() *ClientManager {\n\tmanager := &ClientManager{\n\t\tMaxSize: 64,\n\t\tMaxAge:  10 * time.Minute,\n\t\tFactory: NewClient,\n\t}\n\n\tmanager.initInternals()\n\n\treturn manager\n}\n\n// Add adds a Client to the manager. You can use this to individually configure\n// Clients in the manager.\nfunc (m *ClientManager) Add(client *Client) {\n\tm.initInternals()\n\tm.mu.Lock()\n\tdefer m.mu.Unlock()\n\n\tkey := cacheKey(client.Certificate)\n\tnow := time.Now()\n\tif ele, hit := m.cache[key]; hit {\n\t\titem := ele.Value.(*managerItem)\n\t\titem.client = client\n\t\titem.lastUsed = now\n\t\tm.ll.MoveToFront(ele)\n\t\treturn\n\t}\n\tele := m.ll.PushFront(&managerItem{key, client, now})\n\tm.cache[key] = ele\n\tif m.MaxSize != 0 && m.ll.Len() > m.MaxSize {\n\t\tm.mu.Unlock()\n\t\tm.removeOldest()\n\t\tm.mu.Lock()\n\t}\n}\n\n// Get gets a Client from the manager. If a Client is not found in the manager\n// or if a Client has remained in the manager longer than MaxAge, Get will call\n// the ClientManager's Factory function, store the result in the manager if\n// non-nil, and return it.\nfunc (m *ClientManager) Get(certificate tls.Certificate) *Client {\n\tm.initInternals()\n\tm.mu.Lock()\n\tdefer m.mu.Unlock()\n\n\tkey := cacheKey(certificate)\n\tnow := time.Now()\n\tif ele, hit := m.cache[key]; hit {\n\t\titem := ele.Value.(*managerItem)\n\t\tif m.MaxAge != 0 && item.lastUsed.Before(now.Add(-m.MaxAge)) {\n\t\t\tc := m.Factory(certificate)\n\t\t\tif c == nil {\n\t\t\t\treturn nil\n\t\t\t}\n\t\t\titem.client = c\n\t\t}\n\t\titem.lastUsed = now\n\t\tm.ll.MoveToFront(ele)\n\t\treturn item.client\n\t}\n\n\tc := m.Factory(certificate)\n\tif c == nil {\n\t\treturn nil\n\t}\n\tm.mu.Unlock()\n\tm.Add(c)\n\tm.mu.Lock()\n\treturn c\n}\n\n// Len returns the current size of the ClientManager.\nfunc (m *ClientManager) Len() int {\n\tif m.cache == nil {\n\t\treturn 0\n\t}\n\tm.mu.Lock()\n\tdefer m.mu.Unlock()\n\treturn m.ll.Len()\n}\n\nfunc (m *ClientManager) initInternals() {\n\tm.once.Do(func() {\n\t\tm.cache = map[[sha1.Size]byte]*list.Element{}\n\t\tm.ll = list.New()\n\t})\n}\n\nfunc (m *ClientManager) removeOldest() {\n\tm.mu.Lock()\n\tele := m.ll.Back()\n\tm.mu.Unlock()\n\tif ele != nil {\n\t\tm.removeElement(ele)\n\t}\n}\n\nfunc (m *ClientManager) removeElement(e *list.Element) {\n\tm.mu.Lock()\n\tdefer m.mu.Unlock()\n\tm.ll.Remove(e)\n\tdelete(m.cache, e.Value.(*managerItem).key)\n}\n\nfunc cacheKey(certificate tls.Certificate) [sha1.Size]byte {\n\tvar data []byte\n\n\tfor _, cert := range certificate.Certificate {\n\t\tdata = append(data, cert...)\n\t}\n\n\treturn sha1.Sum(data)\n}\n"
        },
        {
          "name": "client_manager_test.go",
          "type": "blob",
          "size": 3.6884765625,
          "content": "package apns2_test\n\nimport (\n\t\"bytes\"\n\t\"crypto/tls\"\n\t\"reflect\"\n\t\"sync\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/sideshow/apns2\"\n\t\"github.com/sideshow/apns2/certificate\"\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestNewClientManager(t *testing.T) {\n\tmanager := apns2.NewClientManager()\n\tassert.Equal(t, manager.MaxSize, 64)\n\tassert.Equal(t, manager.MaxAge, 10*time.Minute)\n}\n\nfunc TestClientManagerGetWithoutNew(t *testing.T) {\n\tmanager := apns2.ClientManager{\n\t\tMaxSize: 32,\n\t\tMaxAge:  5 * time.Minute,\n\t\tFactory: apns2.NewClient,\n\t}\n\n\tc1 := manager.Get(mockCert())\n\tc2 := manager.Get(mockCert())\n\tv1 := reflect.ValueOf(c1)\n\tv2 := reflect.ValueOf(c2)\n\tassert.NotNil(t, c1)\n\tassert.Equal(t, v1.Pointer(), v2.Pointer())\n\tassert.Equal(t, 1, manager.Len())\n}\n\nfunc TestClientManagerAddWithoutNew(t *testing.T) {\n\twg := sync.WaitGroup{}\n\n\tmanager := apns2.ClientManager{\n\t\tMaxSize: 1,\n\t\tMaxAge:  5 * time.Minute,\n\t\tFactory: apns2.NewClient,\n\t}\n\n\tfor i := 0; i < 2; i++ {\n\t\twg.Add(1)\n\t\tgo func() {\n\t\t\tmanager.Add(apns2.NewClient(mockCert()))\n\t\t\tassert.Equal(t, 1, manager.Len())\n\t\t\twg.Done()\n\t\t}()\n\t}\n\twg.Wait()\n}\n\nfunc TestClientManagerLenWithoutNew(t *testing.T) {\n\tmanager := apns2.ClientManager{\n\t\tMaxSize: 32,\n\t\tMaxAge:  5 * time.Minute,\n\t\tFactory: apns2.NewClient,\n\t}\n\n\tassert.Equal(t, 0, manager.Len())\n}\n\nfunc TestClientManagerGetDefaultOptions(t *testing.T) {\n\tmanager := apns2.NewClientManager()\n\tc1 := manager.Get(mockCert())\n\tc2 := manager.Get(mockCert())\n\tv1 := reflect.ValueOf(c1)\n\tv2 := reflect.ValueOf(c2)\n\tassert.NotNil(t, c1)\n\tassert.Equal(t, v1.Pointer(), v2.Pointer())\n\tassert.Equal(t, 1, manager.Len())\n}\n\nfunc TestClientManagerGetNilClientFactory(t *testing.T) {\n\tmanager := apns2.NewClientManager()\n\tmanager.Factory = func(certificate tls.Certificate) *apns2.Client {\n\t\treturn nil\n\t}\n\tc1 := manager.Get(mockCert())\n\tc2 := manager.Get(mockCert())\n\tassert.Nil(t, c1)\n\tassert.Nil(t, c2)\n\tassert.Equal(t, 0, manager.Len())\n}\n\nfunc TestClientManagerGetMaxAgeExpiration(t *testing.T) {\n\tmanager := apns2.NewClientManager()\n\tmanager.MaxAge = time.Nanosecond\n\tc1 := manager.Get(mockCert())\n\ttime.Sleep(time.Microsecond)\n\tc2 := manager.Get(mockCert())\n\tv1 := reflect.ValueOf(c1)\n\tv2 := reflect.ValueOf(c2)\n\tassert.NotNil(t, c1)\n\tassert.NotEqual(t, v1.Pointer(), v2.Pointer())\n\tassert.Equal(t, 1, manager.Len())\n}\n\nfunc TestClientManagerGetMaxAgeExpirationWithNilFactory(t *testing.T) {\n\tmanager := apns2.NewClientManager()\n\tmanager.Factory = func(certificate tls.Certificate) *apns2.Client {\n\t\treturn nil\n\t}\n\tmanager.MaxAge = time.Nanosecond\n\tmanager.Add(apns2.NewClient(mockCert()))\n\tc1 := manager.Get(mockCert())\n\ttime.Sleep(time.Microsecond)\n\tc2 := manager.Get(mockCert())\n\tassert.Nil(t, c1)\n\tassert.Nil(t, c2)\n\tassert.Equal(t, 1, manager.Len())\n}\n\nfunc TestClientManagerGetMaxSizeExceeded(t *testing.T) {\n\tmanager := apns2.NewClientManager()\n\tmanager.MaxSize = 1\n\tcert1 := mockCert()\n\t_ = manager.Get(cert1)\n\tcert2, _ := certificate.FromP12File(\"certificate/_fixtures/certificate-valid.p12\", \"\")\n\t_ = manager.Get(cert2)\n\tcert3, _ := certificate.FromP12File(\"certificate/_fixtures/certificate-valid-encrypted.p12\", \"password\")\n\tc := manager.Get(cert3)\n\tassert.True(t, bytes.Equal(cert3.Certificate[0], c.Certificate.Certificate[0]))\n\tassert.Equal(t, 1, manager.Len())\n}\n\nfunc TestClientManagerAdd(t *testing.T) {\n\tfn := func(certificate tls.Certificate) *apns2.Client {\n\t\tt.Fatal(\"factory should not have been called\")\n\t\treturn nil\n\t}\n\n\tmanager := apns2.NewClientManager()\n\tmanager.Factory = fn\n\tmanager.Add(apns2.NewClient(mockCert()))\n\tmanager.Get(mockCert())\n}\n\nfunc TestClientManagerAddTwice(t *testing.T) {\n\tmanager := apns2.NewClientManager()\n\tmanager.Add(apns2.NewClient(mockCert()))\n\tmanager.Add(apns2.NewClient(mockCert()))\n\tassert.Equal(t, 1, manager.Len())\n}\n"
        },
        {
          "name": "client_test.go",
          "type": "blob",
          "size": 14.9365234375,
          "content": "package apns2_test\n\nimport (\n\t\"context\"\n\t\"crypto/ecdsa\"\n\t\"crypto/elliptic\"\n\t\"crypto/rand\"\n\t\"crypto/tls\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"net\"\n\t\"net/http\"\n\t\"net/http/httptest\"\n\t\"strings\"\n\t\"testing\"\n\t\"time\"\n\n\t\"golang.org/x/net/http2\"\n\n\tapns \"github.com/sideshow/apns2\"\n\t\"github.com/sideshow/apns2/certificate\"\n\t\"github.com/sideshow/apns2/token\"\n\t\"github.com/stretchr/testify/assert\"\n)\n\n// Mocks\n\nfunc mockNotification() *apns.Notification {\n\tn := &apns.Notification{}\n\tn.DeviceToken = \"11aa01229f15f0f0c52029d8cf8cd0aeaf2365fe4cebc4af26cd6d76b7919ef7\"\n\tn.Payload = []byte(`{\"aps\":{\"alert\":\"Hello!\"}}`)\n\treturn n\n}\n\nfunc mockToken() *token.Token {\n\tpubkeyCurve := elliptic.P256()\n\tauthKey, _ := ecdsa.GenerateKey(pubkeyCurve, rand.Reader)\n\treturn &token.Token{AuthKey: authKey}\n}\n\nfunc mockCert() tls.Certificate {\n\treturn tls.Certificate{}\n}\n\nfunc mockClient(url string) *apns.Client {\n\treturn &apns.Client{Host: url, HTTPClient: http.DefaultClient}\n}\n\ntype mockTransport struct {\n\t*http2.Transport\n\tclosed bool\n}\n\nfunc (c *mockTransport) CloseIdleConnections() {\n\tc.closed = true\n}\n\n// Unit Tests\n\nfunc TestClientDefaultHost(t *testing.T) {\n\tclient := apns.NewClient(mockCert())\n\tassert.Equal(t, \"https://api.sandbox.push.apple.com\", client.Host)\n}\n\nfunc TestTokenDefaultHost(t *testing.T) {\n\tclient := apns.NewTokenClient(mockToken()).Development()\n\tassert.Equal(t, \"https://api.sandbox.push.apple.com\", client.Host)\n}\n\nfunc TestClientDevelopmentHost(t *testing.T) {\n\tclient := apns.NewClient(mockCert()).Development()\n\tassert.Equal(t, \"https://api.sandbox.push.apple.com\", client.Host)\n}\n\nfunc TestTokenClientDevelopmentHost(t *testing.T) {\n\tclient := apns.NewTokenClient(mockToken()).Development()\n\tassert.Equal(t, \"https://api.sandbox.push.apple.com\", client.Host)\n}\n\nfunc TestClientProductionHost(t *testing.T) {\n\tclient := apns.NewClient(mockCert()).Production()\n\tassert.Equal(t, \"https://api.push.apple.com\", client.Host)\n}\n\nfunc TestTokenClientProductionHost(t *testing.T) {\n\tclient := apns.NewTokenClient(mockToken()).Production()\n\tassert.Equal(t, \"https://api.push.apple.com\", client.Host)\n}\n\nfunc TestClientBadUrlError(t *testing.T) {\n\tn := mockNotification()\n\tres, err := mockClient(\"badurl://badurl.com\").Push(n)\n\tassert.Error(t, err)\n\tassert.Nil(t, res)\n}\n\nfunc TestClientBadTransportError(t *testing.T) {\n\tn := mockNotification()\n\tclient := mockClient(\"badurl://badurl.com\")\n\tclient.HTTPClient.Transport = nil\n\tres, err := client.Push(n)\n\tassert.Error(t, err)\n\tassert.Nil(t, res)\n}\n\nfunc TestClientBadDeviceToken(t *testing.T) {\n\tn := &apns.Notification{}\n\tn.DeviceToken = \"DGw\\aOoD+HwSroh#Ug]%xzd]\"\n\tn.Payload = []byte(`{\"aps\":{\"alert\":\"Hello!\"}}`)\n\tres, err := mockClient(\"https://api.push.apple.com\").Push(n)\n\tassert.Error(t, err)\n\tassert.Nil(t, res)\n}\n\nfunc TestClientNameToCertificate(t *testing.T) {\n\tcrt, _ := certificate.FromP12File(\"certificate/_fixtures/certificate-valid.p12\", \"\")\n\tclient := apns.NewClient(crt)\n\tname := client.HTTPClient.Transport.(*http2.Transport).TLSClientConfig.NameToCertificate\n\tassert.Len(t, name, 1)\n\n\tcertificate2 := tls.Certificate{}\n\tclient2 := apns.NewClient(certificate2)\n\tname2 := client2.HTTPClient.Transport.(*http2.Transport).TLSClientConfig.NameToCertificate\n\tassert.Len(t, name2, 0)\n}\n\nfunc TestDialTLSTimeout(t *testing.T) {\n\tapns.TLSDialTimeout = 10 * time.Millisecond\n\tcrt, _ := certificate.FromP12File(\"certificate/_fixtures/certificate-valid.p12\", \"\")\n\tclient := apns.NewClient(crt)\n\tdialTLS := client.HTTPClient.Transport.(*http2.Transport).DialTLS\n\tlistener, err := net.Listen(\"tcp\", \"127.0.0.1:0\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\taddress := listener.Addr().String()\n\tdefer listener.Close()\n\tvar e error\n\tif _, e = dialTLS(\"tcp\", address, nil); e == nil {\n\t\tt.Fatal(\"Dial completed successfully\")\n\t}\n\t// Go 1.7.x and later will return a context deadline exceeded error\n\t// Previous versions will return a time out\n\tif !strings.Contains(e.Error(), \"timed out\") && !errors.Is(e, context.DeadlineExceeded) {\n\t\tt.Errorf(\"Unexpected error: %s\", e)\n\t}\n}\n\n// Functional Tests\n\nfunc TestURL(t *testing.T) {\n\tn := mockNotification()\n\tserver := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tassert.Equal(t, \"POST\", r.Method)\n\t\tassert.Equal(t, fmt.Sprintf(\"/3/device/%s\", n.DeviceToken), r.URL.String())\n\t}))\n\tdefer server.Close()\n\t_, err := mockClient(server.URL).Push(n)\n\tassert.NoError(t, err)\n}\n\nfunc TestDefaultHeaders(t *testing.T) {\n\tn := mockNotification()\n\tserver := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tassert.Equal(t, \"application/json; charset=utf-8\", r.Header.Get(\"Content-Type\"))\n\t\tassert.Equal(t, \"\", r.Header.Get(\"apns-id\"))\n\t\tassert.Equal(t, \"\", r.Header.Get(\"apns-collapse-id\"))\n\t\tassert.Equal(t, \"\", r.Header.Get(\"apns-priority\"))\n\t\tassert.Equal(t, \"\", r.Header.Get(\"apns-topic\"))\n\t\tassert.Equal(t, \"\", r.Header.Get(\"apns-expiration\"))\n\t\tassert.Equal(t, \"\", r.Header.Get(\"thread-id\"))\n\t\tassert.Equal(t, \"alert\", r.Header.Get(\"apns-push-type\"))\n\t}))\n\tdefer server.Close()\n\t_, err := mockClient(server.URL).Push(n)\n\tassert.NoError(t, err)\n}\n\nfunc TestClientPushWithContextWithTimeout(t *testing.T) {\n\tconst timeout = time.Nanosecond\n\tn := mockNotification()\n\tvar apnsID = \"02ABC856-EF8D-4E49-8F15-7B8A61D978D6\"\n\tserver := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tw.Header().Set(\"Content-Type\", \"application/json; charset=utf-8\")\n\t\tw.Header().Set(\"apns-id\", apnsID)\n\t\tw.WriteHeader(http.StatusOK)\n\t}))\n\tdefer server.Close()\n\n\tctx, cancel := context.WithTimeout(context.Background(), timeout)\n\ttime.Sleep(timeout)\n\tres, err := mockClient(server.URL).PushWithContext(ctx, n)\n\tassert.Error(t, err)\n\tassert.Nil(t, res)\n\tcancel()\n}\n\nfunc TestClientPushWithContext(t *testing.T) {\n\tn := mockNotification()\n\tvar apnsID = \"02ABC856-EF8D-4E49-8F15-7B8A61D978D6\"\n\tserver := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tw.Header().Set(\"Content-Type\", \"application/json; charset=utf-8\")\n\t\tw.Header().Set(\"apns-id\", apnsID)\n\t\tw.WriteHeader(http.StatusOK)\n\t}))\n\tdefer server.Close()\n\n\tres, err := mockClient(server.URL).PushWithContext(context.Background(), n)\n\tassert.Nil(t, err)\n\tassert.Equal(t, res.ApnsID, apnsID)\n}\n\nfunc TestClientPushWithNilContext(t *testing.T) {\n\tn := mockNotification()\n\tvar apnsID = \"02ABC856-EF8D-4E49-8F15-7B8A61D978D6\"\n\tserver := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tw.Header().Set(\"Content-Type\", \"application/json; charset=utf-8\")\n\t\tw.Header().Set(\"apns-id\", apnsID)\n\t\tw.WriteHeader(http.StatusOK)\n\t}))\n\tdefer server.Close()\n\n\tres, err := mockClient(server.URL).PushWithContext(nil, n)\n\tassert.EqualError(t, err, \"net/http: nil Context\")\n\tassert.Nil(t, res)\n}\n\nfunc TestHeaders(t *testing.T) {\n\tn := mockNotification()\n\tn.ApnsID = \"84DB694F-464F-49BD-960A-D6DB028335C9\"\n\tn.CollapseID = \"game1.start.identifier\"\n\tn.Topic = \"com.testapp\"\n\tn.Priority = 10\n\tn.Expiration = time.Now()\n\tserver := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tassert.Equal(t, n.ApnsID, r.Header.Get(\"apns-id\"))\n\t\tassert.Equal(t, n.CollapseID, r.Header.Get(\"apns-collapse-id\"))\n\t\tassert.Equal(t, \"10\", r.Header.Get(\"apns-priority\"))\n\t\tassert.Equal(t, n.Topic, r.Header.Get(\"apns-topic\"))\n\t\tassert.Equal(t, fmt.Sprintf(\"%v\", n.Expiration.Unix()), r.Header.Get(\"apns-expiration\"))\n\t}))\n\tdefer server.Close()\n\t_, err := mockClient(server.URL).Push(n)\n\tassert.NoError(t, err)\n}\n\nfunc TestExpirationHeader(t *testing.T) {\n\tn := mockNotification()\n\tn.ApnsID = \"84DB694F-464F-49BD-960A-D6DB028335C9\"\n\tn.CollapseID = \"game1.start.identifier\"\n\tn.Topic = \"com.testapp\"\n\tn.Priority = 10\n\tn.Expiration = time.Unix(0, 0)\n\tserver := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tassert.Equal(t, n.ApnsID, r.Header.Get(\"apns-id\"))\n\t\tassert.Equal(t, n.CollapseID, r.Header.Get(\"apns-collapse-id\"))\n\t\tassert.Equal(t, \"10\", r.Header.Get(\"apns-priority\"))\n\t\tassert.Equal(t, n.Topic, r.Header.Get(\"apns-topic\"))\n\t\tassert.Equal(t, \"\", r.Header.Get(\"apns-expiration\"))\n\t}))\n\tdefer server.Close()\n\t_, err := mockClient(server.URL).Push(n)\n\tassert.NoError(t, err)\n}\n\nfunc TestPushTypeAlertHeader(t *testing.T) {\n\tn := mockNotification()\n\tn.PushType = apns.PushTypeAlert\n\tserver := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tassert.Equal(t, \"alert\", r.Header.Get(\"apns-push-type\"))\n\t}))\n\tdefer server.Close()\n\t_, err := mockClient(server.URL).Push(n)\n\tassert.NoError(t, err)\n}\n\nfunc TestPushTypeBackgroundHeader(t *testing.T) {\n\tn := mockNotification()\n\tn.PushType = apns.PushTypeBackground\n\tserver := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tassert.Equal(t, \"background\", r.Header.Get(\"apns-push-type\"))\n\t}))\n\tdefer server.Close()\n\t_, err := mockClient(server.URL).Push(n)\n\tassert.NoError(t, err)\n}\n\nfunc TestPushTypeLocationHeader(t *testing.T) {\n\tn := mockNotification()\n\tn.PushType = apns.PushTypeLocation\n\tserver := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tassert.Equal(t, \"location\", r.Header.Get(\"apns-push-type\"))\n\t}))\n\tdefer server.Close()\n\t_, err := mockClient(server.URL).Push(n)\n\tassert.NoError(t, err)\n}\n\nfunc TestPushTypeVOIPHeader(t *testing.T) {\n\tn := mockNotification()\n\tn.PushType = apns.PushTypeVOIP\n\tserver := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tassert.Equal(t, \"voip\", r.Header.Get(\"apns-push-type\"))\n\t}))\n\tdefer server.Close()\n\t_, err := mockClient(server.URL).Push(n)\n\tassert.NoError(t, err)\n}\n\nfunc TestPushTypeComplicationHeader(t *testing.T) {\n\tn := mockNotification()\n\tn.PushType = apns.PushTypeComplication\n\tserver := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tassert.Equal(t, \"complication\", r.Header.Get(\"apns-push-type\"))\n\t}))\n\tdefer server.Close()\n\t_, err := mockClient(server.URL).Push(n)\n\tassert.NoError(t, err)\n}\n\nfunc TestPushTypeFileProviderHeader(t *testing.T) {\n\tn := mockNotification()\n\tn.PushType = apns.PushTypeFileProvider\n\tserver := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tassert.Equal(t, \"fileprovider\", r.Header.Get(\"apns-push-type\"))\n\t}))\n\tdefer server.Close()\n\t_, err := mockClient(server.URL).Push(n)\n\tassert.NoError(t, err)\n}\n\nfunc TestPushTypeMDMHeader(t *testing.T) {\n\tn := mockNotification()\n\tn.PushType = apns.PushTypeMDM\n\tserver := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tassert.Equal(t, \"mdm\", r.Header.Get(\"apns-push-type\"))\n\t}))\n\tdefer server.Close()\n\t_, err := mockClient(server.URL).Push(n)\n\tassert.NoError(t, err)\n}\n\nfunc TestPushTypeLiveActivityHeader(t *testing.T) {\n\tn := mockNotification()\n\tn.PushType = apns.PushTypeLiveActivity\n\tserver := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tassert.Equal(t, \"liveactivity\", r.Header.Get(\"apns-push-type\"))\n\t}))\n\tdefer server.Close()\n\t_, err := mockClient(server.URL).Push(n)\n\tassert.NoError(t, err)\n}\n\nfunc TestPushTypePushToTalkHeader(t *testing.T) {\n\tn := mockNotification()\n\tn.PushType = apns.PushTypePushToTalk\n\tserver := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tassert.Equal(t, \"pushtotalk\", r.Header.Get(\"apns-push-type\"))\n\t}))\n\tdefer server.Close()\n\t_, err := mockClient(server.URL).Push(n)\n\tassert.NoError(t, err)\n}\n\nfunc TestAuthorizationHeader(t *testing.T) {\n\tn := mockNotification()\n\ttoken := mockToken()\n\tserver := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tassert.Equal(t, \"application/json; charset=utf-8\", r.Header.Get(\"Content-Type\"))\n\t\tassert.Equal(t, fmt.Sprintf(\"bearer %v\", token.Bearer), r.Header.Get(\"authorization\"))\n\t}))\n\tdefer server.Close()\n\n\tclient := mockClient(server.URL)\n\tclient.Token = token\n\t_, err := client.Push(n)\n\tassert.NoError(t, err)\n}\n\nfunc TestPayload(t *testing.T) {\n\tn := mockNotification()\n\tserver := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tbody, err := io.ReadAll(r.Body)\n\t\tassert.NoError(t, err)\n\t\tassert.Equal(t, n.Payload, body)\n\t}))\n\tdefer server.Close()\n\t_, err := mockClient(server.URL).Push(n)\n\tassert.NoError(t, err)\n}\n\nfunc TestBadPayload(t *testing.T) {\n\tn := mockNotification()\n\tn.Payload = func() {}\n\t_, err := mockClient(\"\").Push(n)\n\tassert.Error(t, err)\n}\n\nfunc Test200SuccessResponse(t *testing.T) {\n\tn := mockNotification()\n\tvar apnsID = \"02ABC856-EF8D-4E49-8F15-7B8A61D978D6\"\n\tvar apnsUniqueID = \"A6739D99-D92A-424B-A91E-BF012365BD4E\"\n\tserver := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tw.Header().Set(\"Content-Type\", \"application/json; charset=utf-8\")\n\t\tw.Header().Set(\"apns-id\", apnsID)\n\t\tw.Header().Set(\"apns-unique-id\", apnsUniqueID)\n\t\tw.WriteHeader(http.StatusOK)\n\t}))\n\tdefer server.Close()\n\tres, err := mockClient(server.URL).Push(n)\n\tassert.NoError(t, err)\n\tassert.Equal(t, http.StatusOK, res.StatusCode)\n\tassert.Equal(t, apnsID, res.ApnsID)\n\tassert.Equal(t, apnsUniqueID, res.ApnsUniqueID)\n\tassert.Equal(t, true, res.Sent())\n}\n\nfunc Test400BadRequestPayloadEmptyResponse(t *testing.T) {\n\tn := mockNotification()\n\tvar apnsID = \"02ABC856-EF8D-4E49-8F15-7B8A61D978D6\"\n\tserver := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tw.Header().Set(\"Content-Type\", \"application/json; charset=utf-8\")\n\t\tw.Header().Set(\"apns-id\", apnsID)\n\t\tw.WriteHeader(http.StatusBadRequest)\n\t\tw.Write([]byte(\"{\\\"reason\\\":\\\"PayloadEmpty\\\"}\"))\n\t}))\n\tdefer server.Close()\n\tres, err := mockClient(server.URL).Push(n)\n\tassert.NoError(t, err)\n\tassert.Equal(t, 400, res.StatusCode)\n\tassert.Equal(t, apnsID, res.ApnsID)\n\tassert.Equal(t, apns.ReasonPayloadEmpty, res.Reason)\n\tassert.Equal(t, false, res.Sent())\n}\n\nfunc Test410UnregisteredResponse(t *testing.T) {\n\tn := mockNotification()\n\tvar apnsID = \"9F595474-356C-485E-B67F-9870BAE68702\"\n\tserver := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tw.Header().Set(\"Content-Type\", \"application/json; charset=utf-8\")\n\t\tw.Header().Set(\"apns-id\", apnsID)\n\t\tw.WriteHeader(http.StatusGone)\n\t\tw.Write([]byte(\"{\\\"reason\\\":\\\"Unregistered\\\", \\\"timestamp\\\": 1458114061260 }\"))\n\t}))\n\tdefer server.Close()\n\tres, err := mockClient(server.URL).Push(n)\n\tassert.NoError(t, err)\n\tassert.Equal(t, 410, res.StatusCode)\n\tassert.Equal(t, apnsID, res.ApnsID)\n\tassert.Equal(t, apns.ReasonUnregistered, res.Reason)\n\tassert.Equal(t, int64(1458114061260)/1000, res.Timestamp.Unix())\n\tassert.Equal(t, false, res.Sent())\n}\n\nfunc TestMalformedJSONResponse(t *testing.T) {\n\tn := mockNotification()\n\tserver := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tw.Header().Set(\"Content-Type\", \"application/json; charset=utf-8\")\n\t\tw.Write([]byte(\"{{MalformedJSON}}\"))\n\t}))\n\tdefer server.Close()\n\tres, err := mockClient(server.URL).Push(n)\n\tassert.Error(t, err)\n\tassert.Equal(t, false, res.Sent())\n}\n\nfunc TestCloseIdleConnections(t *testing.T) {\n\ttransport := &mockTransport{}\n\n\tclient := mockClient(\"\")\n\tclient.HTTPClient.Transport = transport\n\n\tassert.Equal(t, false, transport.closed)\n\tclient.CloseIdleConnections()\n\tassert.Equal(t, true, transport.closed)\n}\n"
        },
        {
          "name": "go.mod",
          "type": "blob",
          "size": 0.4208984375,
          "content": "module github.com/sideshow/apns2\n\ngo 1.15\n\nrequire (\n\tgithub.com/alecthomas/template v0.0.0-20190718012654-fb15b899a751 // indirect\n\tgithub.com/alecthomas/units v0.0.0-20201120081800-1786d5ef83d4 // indirect\n\tgithub.com/golang-jwt/jwt/v4 v4.4.1\n\tgithub.com/stretchr/testify v1.7.0\n\tgolang.org/x/crypto v0.0.0-20170512130425-ab89591268e0\n\tgolang.org/x/net v0.0.0-20220403103023-749bd193bc2b\n\tgopkg.in/alecthomas/kingpin.v2 v2.2.6\n)\n"
        },
        {
          "name": "go.sum",
          "type": "blob",
          "size": 2.9443359375,
          "content": "github.com/alecthomas/template v0.0.0-20190718012654-fb15b899a751 h1:JYp7IbQjafoB+tBA3gMyHYHrpOtNuDiK/uB5uXxq5wM=\ngithub.com/alecthomas/template v0.0.0-20190718012654-fb15b899a751/go.mod h1:LOuyumcjzFXgccqObfd/Ljyb9UuFJ6TxHnclSeseNhc=\ngithub.com/alecthomas/units v0.0.0-20201120081800-1786d5ef83d4 h1:EBTWhcAX7rNQ80RLwLCpHZBBrJuzallFHnF+yMXo928=\ngithub.com/alecthomas/units v0.0.0-20201120081800-1786d5ef83d4/go.mod h1:OMCwj8VM1Kc9e19TLln2VL61YJF0x1XFtfdL4JdbSyE=\ngithub.com/davecgh/go-spew v1.1.0 h1:ZDRjVQ15GmhC3fiQ8ni8+OwkZQO4DARzQgrnXU1Liz8=\ngithub.com/davecgh/go-spew v1.1.0/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=\ngithub.com/golang-jwt/jwt/v4 v4.4.1 h1:pC5DB52sCeK48Wlb9oPcdhnjkz1TKt1D/P7WKJ0kUcQ=\ngithub.com/golang-jwt/jwt/v4 v4.4.1/go.mod h1:m21LjoU+eqJr34lmDMbreY2eSTRJ1cv77w39/MY0Ch0=\ngithub.com/pmezard/go-difflib v1.0.0 h1:4DBwDE0NGyQoBHbLQYPwSUPoCMWR5BEzIk/f1lZbAQM=\ngithub.com/pmezard/go-difflib v1.0.0/go.mod h1:iKH77koFhYxTK1pcRnkKkqfTogsbg7gZNVY4sRDYZ/4=\ngithub.com/stretchr/objx v0.1.0/go.mod h1:HFkY916IF+rwdDfMAkV7OtwuqBVzrE8GR6GFx+wExME=\ngithub.com/stretchr/testify v1.4.0/go.mod h1:j7eGeouHqKxXV5pUuKE4zz7dFj8WfuZ+81PSLYec5m4=\ngithub.com/stretchr/testify v1.7.0 h1:nwc3DEeHmmLAfoZucVR881uASk0Mfjw8xYJ99tb5CcY=\ngithub.com/stretchr/testify v1.7.0/go.mod h1:6Fq8oRcR53rry900zMqJjRRixrwX3KX962/h/Wwjteg=\ngolang.org/x/crypto v0.0.0-20170512130425-ab89591268e0 h1:Kv0JVjoWyBVkLETNHnV/PxoZcMP3J7+WTc6+QQnzZmY=\ngolang.org/x/crypto v0.0.0-20170512130425-ab89591268e0/go.mod h1:6SG95UA2DQfeDnfUPMdvaQW0Q7yPrPDi9nlGo2tz2b4=\ngolang.org/x/net v0.0.0-20220403103023-749bd193bc2b h1:vI32FkLJNAWtGD4BwkThwEy6XS7ZLLMHkSkYfF8M0W0=\ngolang.org/x/net v0.0.0-20220403103023-749bd193bc2b/go.mod h1:CfG3xpIq0wQ8r1q4Su4UZFWDARRcnwPjda9FqA0JpMk=\ngolang.org/x/sys v0.0.0-20210615035016-665e8c7367d1/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\ngolang.org/x/sys v0.0.0-20211216021012-1d35b9e2eb4e/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\ngolang.org/x/term v0.0.0-20210927222741-03fcf44c2211/go.mod h1:jbD1KX2456YbFQfuXm/mYQcufACuNUgVhRMnK/tPxf8=\ngolang.org/x/text v0.3.7 h1:olpwvP2KacW1ZWvsR7uQhoyTYvKAupfQrRGBFM352Gk=\ngolang.org/x/text v0.3.7/go.mod h1:u+2+/6zg+i71rQMx5EYifcz6MCKuco9NR6JIITiCfzQ=\ngolang.org/x/tools v0.0.0-20180917221912-90fa682c2a6e/go.mod h1:n7NCudcB/nEzxVGmLbDWY5pfWTLqBcC2KZ6jyYvM4mQ=\ngopkg.in/alecthomas/kingpin.v2 v2.2.6 h1:jMFz6MfLP0/4fUyZle81rXUoxOBFi19VUFKVDOQfozc=\ngopkg.in/alecthomas/kingpin.v2 v2.2.6/go.mod h1:FMv+mEhP44yOT+4EoQTLFTRgOQ1FBLkstjWtayDeSgw=\ngopkg.in/check.v1 v0.0.0-20161208181325-20d25e280405 h1:yhCVgyC4o1eVCa2tZl7eS0r+SDo693bJlVdllGtEeKM=\ngopkg.in/check.v1 v0.0.0-20161208181325-20d25e280405/go.mod h1:Co6ibVJAznAaIkqp8huTwlJQCZ016jof/cbN4VW5Yz0=\ngopkg.in/yaml.v2 v2.2.2/go.mod h1:hI93XBmqTisBFMUTm0b8Fm+jr3Dg1NNxqwp+5A1VGuI=\ngopkg.in/yaml.v3 v3.0.0-20200313102051-9f266ea9e77c h1:dUUwHk2QECo/6vqA44rthZ8ie2QXMNeKRTHCNY2nXvo=\ngopkg.in/yaml.v3 v3.0.0-20200313102051-9f266ea9e77c/go.mod h1:K4uyk7z7BCEPqu6E+C64Yfv1cQ7kz7rIZviUmN+EgEM=\n"
        },
        {
          "name": "notification.go",
          "type": "blob",
          "size": 7.1904296875,
          "content": "package apns2\n\nimport (\n\t\"encoding/json\"\n\t\"time\"\n)\n\n// EPushType defines the value for the apns-push-type header\ntype EPushType string\n\nconst (\n\t// PushTypeAlert is used for notifications that trigger a user interaction —\n\t// for example, an alert, badge, or sound. If you set this push type, the\n\t// topic field must use your app’s bundle ID as the topic. If the\n\t// notification requires immediate action from the user, set notification\n\t// priority to 10; otherwise use 5. The alert push type is required on\n\t// watchOS 6 and later. It is recommended on macOS, iOS, tvOS, and iPadOS.\n\tPushTypeAlert EPushType = \"alert\"\n\n\t// PushTypeBackground is used for notifications that deliver content in the\n\t// background, and don’t trigger any user interactions. If you set this push\n\t// type, the topic field must use your app’s bundle ID as the topic. Always\n\t// use priority 5. Using priority 10 is an error. The background push type\n\t// is required on watchOS 6 and later. It is recommended on macOS, iOS,\n\t// tvOS, and iPadOS.\n\tPushTypeBackground EPushType = \"background\"\n\n\t// PushTypeLocation is used for notifications that request a user’s\n\t// location. If you set this push type, the topic field must use your app’s\n\t// bundle ID with .location-query appended to the end. The location push\n\t// type is recommended for iOS and iPadOS. It isn’t available on macOS,\n\t// tvOS, and watchOS. If the location query requires an immediate response\n\t// from the Location Push Service Extension, set notification apns-priority\n\t// to 10; otherwise, use 5. The location push type supports only token-based\n\t// authentication.\n\tPushTypeLocation EPushType = \"location\"\n\n\t// PushTypeVOIP is used for notifications that provide information about an\n\t// incoming Voice-over-IP (VoIP) call. If you set this push type, the topic\n\t// field must use your app’s bundle ID with .voip appended to the end. If\n\t// you’re using certificate-based authentication, you must also register the\n\t// certificate for VoIP services. The voip push type is not available on\n\t// watchOS. It is recommended on macOS, iOS, tvOS, and iPadOS.\n\tPushTypeVOIP EPushType = \"voip\"\n\n\t// PushTypeComplication is used for notifications that contain update\n\t// information for a watchOS app’s complications. If you set this push type,\n\t// the topic field must use your app’s bundle ID with .complication appended\n\t// to the end. If you’re using certificate-based authentication, you must\n\t// also register the certificate for WatchKit services. The complication\n\t// push type is recommended for watchOS and iOS. It is not available on\n\t// macOS, tvOS, and iPadOS.\n\tPushTypeComplication EPushType = \"complication\"\n\n\t// PushTypeFileProvider is used to signal changes to a File Provider\n\t// extension. If you set this push type, the topic field must use your app’s\n\t// bundle ID with .pushkit.fileprovider appended to the end. The\n\t// fileprovider push type is not available on watchOS. It is recommended on\n\t// macOS, iOS, tvOS, and iPadOS.\n\tPushTypeFileProvider EPushType = \"fileprovider\"\n\n\t// PushTypeMDM is used for notifications that tell managed devices to\n\t// contact the MDM server. If you set this push type, you must use the topic\n\t// from the UID attribute in the subject of your MDM push certificate.\n\tPushTypeMDM EPushType = \"mdm\"\n\n\t// PushTypeLiveActivity is used for Live Activities that display various\n\t// real-time information. If you set this push type, the topic field must\n\t// use your app’s bundle ID with `push-type.liveactivity` appended to the end.\n\t// The live activity push supports only token-based authentication. This\n\t// push type is recommended for iOS. It is not available on macOS, tvOS,\n\t// watchOS and iPadOS.\n\tPushTypeLiveActivity EPushType = \"liveactivity\"\n\n\t// PushTypePushToTalk is used for notifications that provide information about the\n\t// push to talk. If you set this push type, the apns-topic header field\n\t// must use your app’s bundle ID with.voip-ptt appended to the end.\n\t// The pushtotalk push type isn’t available on watchOS, macOS, and tvOS. It’s recommended on iOS and iPadOS.\n\tPushTypePushToTalk EPushType = \"pushtotalk\"\n)\n\nconst (\n\t// PriorityLow will tell APNs to send the push message at a time that takes\n\t// into account power considerations for the device. Notifications with this\n\t// priority might be grouped and delivered in bursts. They are throttled,\n\t// and in some cases are not delivered.\n\tPriorityLow = 5\n\n\t// PriorityHigh will tell APNs to send the push message immediately.\n\t// Notifications with this priority must trigger an alert, sound, or badge\n\t// on the target device. It is an error to use this priority for a push\n\t// notification that contains only the content-available key.\n\tPriorityHigh = 10\n)\n\n// Notification represents the the data and metadata for a APNs Remote Notification.\ntype Notification struct {\n\n\t// An optional canonical UUID that identifies the notification. The\n\t// canonical form is 32 lowercase hexadecimal digits, displayed in five\n\t// groups separated by hyphens in the form 8-4-4-4-12. An example UUID is as\n\t// follows:\n\t//\n\t//  123e4567-e89b-12d3-a456-42665544000\n\t//\n\t// If you don't set this, a new UUID is created by APNs and returned in the\n\t// response.\n\tApnsID string\n\n\t// A string which allows multiple notifications with the same collapse\n\t// identifier to be displayed to the user as a single notification. The\n\t// value should not exceed 64 bytes.\n\tCollapseID string\n\n\t// A string containing hexadecimal bytes of the device token for the target\n\t// device.\n\tDeviceToken string\n\n\t// The topic of the remote notification, which is typically the bundle ID\n\t// for your app. The certificate you create in the Apple Developer Member\n\t// Center must include the capability for this topic. If your certificate\n\t// includes multiple topics, you must specify a value for this header. If\n\t// you omit this header and your APNs certificate does not specify multiple\n\t// topics, the APNs server uses the certificate’s Subject as the default\n\t// topic.\n\tTopic string\n\n\t// An optional time at which the notification is no longer valid and can be\n\t// discarded by APNs. If this value is in the past, APNs treats the\n\t// notification as if it expires immediately and does not store the\n\t// notification or attempt to redeliver it. If this value is left as the\n\t// default (ie, Expiration.IsZero()) an expiration header will not added to\n\t// the http request.\n\tExpiration time.Time\n\n\t// The priority of the notification. Specify ether apns.PriorityHigh (10) or\n\t// apns.PriorityLow (5) If you don't set this, the APNs server will set the\n\t// priority to 10.\n\tPriority int\n\n\t// A byte array containing the JSON-encoded payload of this push notification.\n\t// Refer to \"The Remote Notification Payload\" section in the Apple Local and\n\t// Remote Notification Programming Guide for more info.\n\tPayload interface{}\n\n\t// The pushtype of the push notification. If this values is left as the\n\t// default an apns-push-type header with value 'alert' will be added to the\n\t// http request.\n\tPushType EPushType\n}\n\n// MarshalJSON converts the notification payload to JSON.\nfunc (n *Notification) MarshalJSON() ([]byte, error) {\n\tswitch payload := n.Payload.(type) {\n\tcase string:\n\t\treturn []byte(payload), nil\n\tcase []byte:\n\t\treturn payload, nil\n\tdefault:\n\t\treturn json.Marshal(payload)\n\t}\n}\n"
        },
        {
          "name": "notification_test.go",
          "type": "blob",
          "size": 0.6328125,
          "content": "package apns2_test\n\nimport (\n\t\"testing\"\n\n\t\"github.com/sideshow/apns2\"\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestMarshalJSON(t *testing.T) {\n\tscenarios := []struct {\n\t\tin  interface{}\n\t\tout []byte\n\t\terr error\n\t}{\n\t\t{`{\"a\": \"b\"}`, []byte(`{\"a\": \"b\"}`), nil},\n\t\t{[]byte(`{\"a\": \"b\"}`), []byte(`{\"a\": \"b\"}`), nil},\n\t\t{struct {\n\t\t\tA string `json:\"a\"`\n\t\t}{\"b\"}, []byte(`{\"a\":\"b\"}`), nil},\n\t}\n\n\tnotification := &apns2.Notification{}\n\n\tfor _, scenario := range scenarios {\n\t\tnotification.Payload = scenario.in\n\t\tpayloadBytes, err := notification.MarshalJSON()\n\n\t\tassert.Equal(t, scenario.out, payloadBytes)\n\t\tassert.Equal(t, scenario.err, err)\n\t}\n}\n"
        },
        {
          "name": "payload",
          "type": "tree",
          "content": null
        },
        {
          "name": "response.go",
          "type": "blob",
          "size": 5.2822265625,
          "content": "package apns2\n\nimport (\n\t\"net/http\"\n\t\"strconv\"\n\t\"time\"\n)\n\n// StatusSent is a 200 response.\nconst StatusSent = http.StatusOK\n\n// The possible Reason error codes returned from APNs. From table 4 in the\n// Handling Notification Responses from APNs article\nconst (\n\t// 400 The collapse identifier exceeds the maximum allowed size\n\tReasonBadCollapseID = \"BadCollapseId\"\n\n\t// 400 The specified device token was bad. Verify that the request contains a\n\t// valid token and that the token matches the environment.\n\tReasonBadDeviceToken = \"BadDeviceToken\"\n\n\t// 400 The apns-expiration value is bad.\n\tReasonBadExpirationDate = \"BadExpirationDate\"\n\n\t// 400 The apns-id value is bad.\n\tReasonBadMessageID = \"BadMessageId\"\n\n\t// 400 The apns-priority value is bad.\n\tReasonBadPriority = \"BadPriority\"\n\n\t// 400 The apns-topic was invalid.\n\tReasonBadTopic = \"BadTopic\"\n\n\t// 400 The device token does not match the specified topic.\n\tReasonDeviceTokenNotForTopic = \"DeviceTokenNotForTopic\"\n\n\t// 400 One or more headers were repeated.\n\tReasonDuplicateHeaders = \"DuplicateHeaders\"\n\n\t// 400 Idle time out.\n\tReasonIdleTimeout = \"IdleTimeout\"\n\n\t// 400 The apns-push-type value is invalid.\n\tReasonInvalidPushType = \"InvalidPushType\"\n\n\t// 400 The device token is not specified in the request :path. Verify that the\n\t// :path header contains the device token.\n\tReasonMissingDeviceToken = \"MissingDeviceToken\"\n\n\t// 400 The apns-topic header of the request was not specified and was\n\t// required. The apns-topic header is mandatory when the client is connected\n\t// using a certificate that supports multiple topics.\n\tReasonMissingTopic = \"MissingTopic\"\n\n\t// 400 The message payload was empty.\n\tReasonPayloadEmpty = \"PayloadEmpty\"\n\n\t// 400 Pushing to this topic is not allowed.\n\tReasonTopicDisallowed = \"TopicDisallowed\"\n\n\t// 403 The certificate was bad.\n\tReasonBadCertificate = \"BadCertificate\"\n\n\t// 403 The client certificate was for the wrong environment.\n\tReasonBadCertificateEnvironment = \"BadCertificateEnvironment\"\n\n\t// 403 The provider token is stale and a new token should be generated.\n\tReasonExpiredProviderToken = \"ExpiredProviderToken\"\n\n\t// 403 The specified action is not allowed.\n\tReasonForbidden = \"Forbidden\"\n\n\t// 403 The provider token is not valid or the token signature could not be\n\t// verified.\n\tReasonInvalidProviderToken = \"InvalidProviderToken\"\n\n\t// 403 No provider certificate was used to connect to APNs and Authorization\n\t// header was missing or no provider token was specified.\n\tReasonMissingProviderToken = \"MissingProviderToken\"\n\n\t// 404 The request contained a bad :path value.\n\tReasonBadPath = \"BadPath\"\n\n\t// 405 The specified :method was not POST.\n\tReasonMethodNotAllowed = \"MethodNotAllowed\"\n\n\t// 410 The device token has expired.\n\tReasonExpiredToken = \"ExpiredToken\"\n\n\t// 410 The device token is inactive for the specified topic.\n\tReasonUnregistered = \"Unregistered\"\n\n\t// 413 The message payload was too large. See Creating the Remote Notification\n\t// Payload in the Apple Local and Remote Notification Programming Guide for\n\t// details on maximum payload size.\n\tReasonPayloadTooLarge = \"PayloadTooLarge\"\n\n\t// 429 The provider token is being updated too often.\n\tReasonTooManyProviderTokenUpdates = \"TooManyProviderTokenUpdates\"\n\n\t// 429 Too many requests were made consecutively to the same device token.\n\tReasonTooManyRequests = \"TooManyRequests\"\n\n\t// 500 An internal server error occurred.\n\tReasonInternalServerError = \"InternalServerError\"\n\n\t// 503 The service is unavailable.\n\tReasonServiceUnavailable = \"ServiceUnavailable\"\n\n\t// 503 The server is shutting down.\n\tReasonShutdown = \"Shutdown\"\n)\n\n// Response represents a result from the APNs gateway indicating whether a\n// notification was accepted or rejected and (if applicable) the metadata\n// surrounding the rejection.\ntype Response struct {\n\n\t// The HTTP status code returned by APNs.\n\t// A 200 value indicates that the notification was successfully sent.\n\t// For a list of other possible status codes, see table 6-4 in the Apple Local\n\t// and Remote Notification Programming Guide.\n\tStatusCode int\n\n\t// The APNs error string indicating the reason for the notification failure (if\n\t// any). The error code is specified as a string. For a list of possible\n\t// values, see the Reason constants above.\n\t// If the notification was accepted, this value will be \"\".\n\tReason string\n\n\t// The APNs ApnsID value from the Notification. If you didn't set an ApnsID on the\n\t// Notification, this will be a new unique UUID which has been created by APNs.\n\tApnsID string\n\n\t// If the value of StatusCode is 410, this is the last time at which APNs\n\t// confirmed that the device token was no longer valid for the topic.\n\tTimestamp Time\n\n\t// An identifier that is only available in the Developement enviroment. Use\n\t// this to query Delivery Log information for the corresponding notification\n\t// in Push Notifications Console.\n\tApnsUniqueID string\n}\n\n// Sent returns whether or not the notification was successfully sent.\n// This is the same as checking if the StatusCode == 200.\nfunc (c *Response) Sent() bool {\n\treturn c.StatusCode == StatusSent\n}\n\n// Time represents a device uninstall time\ntype Time struct {\n\ttime.Time\n}\n\n// UnmarshalJSON converts an epoch date into a Time struct.\nfunc (t *Time) UnmarshalJSON(b []byte) error {\n\tts, err := strconv.ParseInt(string(b), 10, 64)\n\tif err != nil {\n\t\treturn err\n\t}\n\tt.Time = time.Unix(ts/1000, 0)\n\treturn nil\n}\n"
        },
        {
          "name": "response_test.go",
          "type": "blob",
          "size": 0.8662109375,
          "content": "package apns2_test\n\nimport (\n\t\"encoding/json\"\n\t\"net/http\"\n\t\"testing\"\n\n\tapns \"github.com/sideshow/apns2\"\n\t\"github.com/stretchr/testify/assert\"\n)\n\n// Unit Tests\n\nfunc TestResponseSent(t *testing.T) {\n\tassert.Equal(t, http.StatusOK, apns.StatusSent)\n\tassert.Equal(t, true, (&apns.Response{StatusCode: 200}).Sent())\n\tassert.Equal(t, false, (&apns.Response{StatusCode: 400}).Sent())\n}\n\nfunc TestIntTimestampParse(t *testing.T) {\n\tresponse := &apns.Response{}\n\tpayload := \"{\\\"reason\\\":\\\"Unregistered\\\", \\\"timestamp\\\":1458114061260}\"\n\tjson.Unmarshal([]byte(payload), &response)\n\tassert.Equal(t, int64(1458114061260)/1000, response.Timestamp.Unix())\n}\n\nfunc TestInvalidTimestampParse(t *testing.T) {\n\tresponse := &apns.Response{}\n\tpayload := \"{\\\"reason\\\":\\\"Unregistered\\\", \\\"timestamp\\\": \\\"2016-01-16 17:44:04 +1300\\\"}\"\n\terr := json.Unmarshal([]byte(payload), &response)\n\tassert.Error(t, err)\n}\n"
        },
        {
          "name": "token",
          "type": "tree",
          "content": null
        },
        {
          "name": "vendor",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}