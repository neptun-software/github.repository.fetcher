{
  "metadata": {
    "timestamp": 1736567249713,
    "page": 847,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjg1MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "tulir/whatsmeow",
      "stars": 2374,
      "defaultBranch": "main",
      "files": [
        {
          "name": ".editorconfig",
          "type": "blob",
          "size": 0.193359375,
          "content": "root = true\n\n[*]\nindent_style = tab\nindent_size = 4\nend_of_line = lf\ncharset = utf-8\ntrim_trailing_whitespace = true\ninsert_final_newline = true\n\n[*.{yaml,yml}]\nindent_style = space\nindent_size = 2\n"
        },
        {
          "name": ".gitattributes",
          "type": "blob",
          "size": 0.0703125,
          "content": "*.pb.go linguist-generated=true\n*.pb.raw binary linguist-generated=true\n"
        },
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".pre-commit-config.yaml",
          "type": "blob",
          "size": 0.76171875,
          "content": "repos:\n  - repo: https://github.com/pre-commit/pre-commit-hooks\n    rev: v5.0.0\n    hooks:\n      - id: trailing-whitespace\n        exclude_types: [markdown]\n        exclude: LICENSE\n      - id: end-of-file-fixer\n        exclude: LICENSE\n      - id: check-yaml\n      - id: check-added-large-files\n\n  - repo: https://github.com/tekwizely/pre-commit-golang\n    rev: v1.0.0-rc.1\n    hooks:\n      - id: go-imports-repo\n        args:\n          - \"-local\"\n          - \"go.mau.fi/whatsmeow\"\n          - \"-w\"\n      - id: go-vet-repo-mod\n      # TODO enable this\n      #- id: go-staticcheck-repo-mod\n      - id: go-mod-tidy\n\n  - repo: https://github.com/beeper/pre-commit-go\n    rev: v0.3.1\n    hooks:\n      # TODO enable this\n      #- id: zerolog-ban-msgf\n      - id: zerolog-use-stringer\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 16.3349609375,
          "content": "Mozilla Public License Version 2.0\n==================================\n\n1. Definitions\n--------------\n\n1.1. \"Contributor\"\n    means each individual or legal entity that creates, contributes to\n    the creation of, or owns Covered Software.\n\n1.2. \"Contributor Version\"\n    means the combination of the Contributions of others (if any) used\n    by a Contributor and that particular Contributor's Contribution.\n\n1.3. \"Contribution\"\n    means Covered Software of a particular Contributor.\n\n1.4. \"Covered Software\"\n    means Source Code Form to which the initial Contributor has attached\n    the notice in Exhibit A, the Executable Form of such Source Code\n    Form, and Modifications of such Source Code Form, in each case\n    including portions thereof.\n\n1.5. \"Incompatible With Secondary Licenses\"\n    means\n\n    (a) that the initial Contributor has attached the notice described\n        in Exhibit B to the Covered Software; or\n\n    (b) that the Covered Software was made available under the terms of\n        version 1.1 or earlier of the License, but not also under the\n        terms of a Secondary License.\n\n1.6. \"Executable Form\"\n    means any form of the work other than Source Code Form.\n\n1.7. \"Larger Work\"\n    means a work that combines Covered Software with other material, in \n    a separate file or files, that is not Covered Software.\n\n1.8. \"License\"\n    means this document.\n\n1.9. \"Licensable\"\n    means having the right to grant, to the maximum extent possible,\n    whether at the time of the initial grant or subsequently, any and\n    all of the rights conveyed by this License.\n\n1.10. \"Modifications\"\n    means any of the following:\n\n    (a) any file in Source Code Form that results from an addition to,\n        deletion from, or modification of the contents of Covered\n        Software; or\n\n    (b) any new file in Source Code Form that contains any Covered\n        Software.\n\n1.11. \"Patent Claims\" of a Contributor\n    means any patent claim(s), including without limitation, method,\n    process, and apparatus claims, in any patent Licensable by such\n    Contributor that would be infringed, but for the grant of the\n    License, by the making, using, selling, offering for sale, having\n    made, import, or transfer of either its Contributions or its\n    Contributor Version.\n\n1.12. \"Secondary License\"\n    means either the GNU General Public License, Version 2.0, the GNU\n    Lesser General Public License, Version 2.1, the GNU Affero General\n    Public License, Version 3.0, or any later versions of those\n    licenses.\n\n1.13. \"Source Code Form\"\n    means the form of the work preferred for making modifications.\n\n1.14. \"You\" (or \"Your\")\n    means an individual or a legal entity exercising rights under this\n    License. For legal entities, \"You\" includes any entity that\n    controls, is controlled by, or is under common control with You. For\n    purposes of this definition, \"control\" means (a) the power, direct\n    or indirect, to cause the direction or management of such entity,\n    whether by contract or otherwise, or (b) ownership of more than\n    fifty percent (50%) of the outstanding shares or beneficial\n    ownership of such entity.\n\n2. License Grants and Conditions\n--------------------------------\n\n2.1. Grants\n\nEach Contributor hereby grants You a world-wide, royalty-free,\nnon-exclusive license:\n\n(a) under intellectual property rights (other than patent or trademark)\n    Licensable by such Contributor to use, reproduce, make available,\n    modify, display, perform, distribute, and otherwise exploit its\n    Contributions, either on an unmodified basis, with Modifications, or\n    as part of a Larger Work; and\n\n(b) under Patent Claims of such Contributor to make, use, sell, offer\n    for sale, have made, import, and otherwise transfer either its\n    Contributions or its Contributor Version.\n\n2.2. Effective Date\n\nThe licenses granted in Section 2.1 with respect to any Contribution\nbecome effective for each Contribution on the date the Contributor first\ndistributes such Contribution.\n\n2.3. Limitations on Grant Scope\n\nThe licenses granted in this Section 2 are the only rights granted under\nthis License. No additional rights or licenses will be implied from the\ndistribution or licensing of Covered Software under this License.\nNotwithstanding Section 2.1(b) above, no patent license is granted by a\nContributor:\n\n(a) for any code that a Contributor has removed from Covered Software;\n    or\n\n(b) for infringements caused by: (i) Your and any other third party's\n    modifications of Covered Software, or (ii) the combination of its\n    Contributions with other software (except as part of its Contributor\n    Version); or\n\n(c) under Patent Claims infringed by Covered Software in the absence of\n    its Contributions.\n\nThis License does not grant any rights in the trademarks, service marks,\nor logos of any Contributor (except as may be necessary to comply with\nthe notice requirements in Section 3.4).\n\n2.4. Subsequent Licenses\n\nNo Contributor makes additional grants as a result of Your choice to\ndistribute the Covered Software under a subsequent version of this\nLicense (see Section 10.2) or under the terms of a Secondary License (if\npermitted under the terms of Section 3.3).\n\n2.5. Representation\n\nEach Contributor represents that the Contributor believes its\nContributions are its original creation(s) or it has sufficient rights\nto grant the rights to its Contributions conveyed by this License.\n\n2.6. Fair Use\n\nThis License is not intended to limit any rights You have under\napplicable copyright doctrines of fair use, fair dealing, or other\nequivalents.\n\n2.7. Conditions\n\nSections 3.1, 3.2, 3.3, and 3.4 are conditions of the licenses granted\nin Section 2.1.\n\n3. Responsibilities\n-------------------\n\n3.1. Distribution of Source Form\n\nAll distribution of Covered Software in Source Code Form, including any\nModifications that You create or to which You contribute, must be under\nthe terms of this License. You must inform recipients that the Source\nCode Form of the Covered Software is governed by the terms of this\nLicense, and how they can obtain a copy of this License. You may not\nattempt to alter or restrict the recipients' rights in the Source Code\nForm.\n\n3.2. Distribution of Executable Form\n\nIf You distribute Covered Software in Executable Form then:\n\n(a) such Covered Software must also be made available in Source Code\n    Form, as described in Section 3.1, and You must inform recipients of\n    the Executable Form how they can obtain a copy of such Source Code\n    Form by reasonable means in a timely manner, at a charge no more\n    than the cost of distribution to the recipient; and\n\n(b) You may distribute such Executable Form under the terms of this\n    License, or sublicense it under different terms, provided that the\n    license for the Executable Form does not attempt to limit or alter\n    the recipients' rights in the Source Code Form under this License.\n\n3.3. Distribution of a Larger Work\n\nYou may create and distribute a Larger Work under terms of Your choice,\nprovided that You also comply with the requirements of this License for\nthe Covered Software. If the Larger Work is a combination of Covered\nSoftware with a work governed by one or more Secondary Licenses, and the\nCovered Software is not Incompatible With Secondary Licenses, this\nLicense permits You to additionally distribute such Covered Software\nunder the terms of such Secondary License(s), so that the recipient of\nthe Larger Work may, at their option, further distribute the Covered\nSoftware under the terms of either this License or such Secondary\nLicense(s).\n\n3.4. Notices\n\nYou may not remove or alter the substance of any license notices\n(including copyright notices, patent notices, disclaimers of warranty,\nor limitations of liability) contained within the Source Code Form of\nthe Covered Software, except that You may alter any license notices to\nthe extent required to remedy known factual inaccuracies.\n\n3.5. Application of Additional Terms\n\nYou may choose to offer, and to charge a fee for, warranty, support,\nindemnity or liability obligations to one or more recipients of Covered\nSoftware. However, You may do so only on Your own behalf, and not on\nbehalf of any Contributor. You must make it absolutely clear that any\nsuch warranty, support, indemnity, or liability obligation is offered by\nYou alone, and You hereby agree to indemnify every Contributor for any\nliability incurred by such Contributor as a result of warranty, support,\nindemnity or liability terms You offer. You may include additional\ndisclaimers of warranty and limitations of liability specific to any\njurisdiction.\n\n4. Inability to Comply Due to Statute or Regulation\n---------------------------------------------------\n\nIf it is impossible for You to comply with any of the terms of this\nLicense with respect to some or all of the Covered Software due to\nstatute, judicial order, or regulation then You must: (a) comply with\nthe terms of this License to the maximum extent possible; and (b)\ndescribe the limitations and the code they affect. Such description must\nbe placed in a text file included with all distributions of the Covered\nSoftware under this License. Except to the extent prohibited by statute\nor regulation, such description must be sufficiently detailed for a\nrecipient of ordinary skill to be able to understand it.\n\n5. Termination\n--------------\n\n5.1. The rights granted under this License will terminate automatically\nif You fail to comply with any of its terms. However, if You become\ncompliant, then the rights granted under this License from a particular\nContributor are reinstated (a) provisionally, unless and until such\nContributor explicitly and finally terminates Your grants, and (b) on an\nongoing basis, if such Contributor fails to notify You of the\nnon-compliance by some reasonable means prior to 60 days after You have\ncome back into compliance. Moreover, Your grants from a particular\nContributor are reinstated on an ongoing basis if such Contributor\nnotifies You of the non-compliance by some reasonable means, this is the\nfirst time You have received notice of non-compliance with this License\nfrom such Contributor, and You become compliant prior to 30 days after\nYour receipt of the notice.\n\n5.2. If You initiate litigation against any entity by asserting a patent\ninfringement claim (excluding declaratory judgment actions,\ncounter-claims, and cross-claims) alleging that a Contributor Version\ndirectly or indirectly infringes any patent, then the rights granted to\nYou by any and all Contributors for the Covered Software under Section\n2.1 of this License shall terminate.\n\n5.3. In the event of termination under Sections 5.1 or 5.2 above, all\nend user license agreements (excluding distributors and resellers) which\nhave been validly granted by You or Your distributors under this License\nprior to termination shall survive termination.\n\n************************************************************************\n*                                                                      *\n*  6. Disclaimer of Warranty                                           *\n*  -------------------------                                           *\n*                                                                      *\n*  Covered Software is provided under this License on an \"as is\"       *\n*  basis, without warranty of any kind, either expressed, implied, or  *\n*  statutory, including, without limitation, warranties that the       *\n*  Covered Software is free of defects, merchantable, fit for a        *\n*  particular purpose or non-infringing. The entire risk as to the     *\n*  quality and performance of the Covered Software is with You.        *\n*  Should any Covered Software prove defective in any respect, You     *\n*  (not any Contributor) assume the cost of any necessary servicing,   *\n*  repair, or correction. This disclaimer of warranty constitutes an   *\n*  essential part of this License. No use of any Covered Software is   *\n*  authorized under this License except under this disclaimer.         *\n*                                                                      *\n************************************************************************\n\n************************************************************************\n*                                                                      *\n*  7. Limitation of Liability                                          *\n*  --------------------------                                          *\n*                                                                      *\n*  Under no circumstances and under no legal theory, whether tort      *\n*  (including negligence), contract, or otherwise, shall any           *\n*  Contributor, or anyone who distributes Covered Software as          *\n*  permitted above, be liable to You for any direct, indirect,         *\n*  special, incidental, or consequential damages of any character      *\n*  including, without limitation, damages for lost profits, loss of    *\n*  goodwill, work stoppage, computer failure or malfunction, or any    *\n*  and all other commercial damages or losses, even if such party      *\n*  shall have been informed of the possibility of such damages. This   *\n*  limitation of liability shall not apply to liability for death or   *\n*  personal injury resulting from such party's negligence to the       *\n*  extent applicable law prohibits such limitation. Some               *\n*  jurisdictions do not allow the exclusion or limitation of           *\n*  incidental or consequential damages, so this exclusion and          *\n*  limitation may not apply to You.                                    *\n*                                                                      *\n************************************************************************\n\n8. Litigation\n-------------\n\nAny litigation relating to this License may be brought only in the\ncourts of a jurisdiction where the defendant maintains its principal\nplace of business and such litigation shall be governed by laws of that\njurisdiction, without reference to its conflict-of-law provisions.\nNothing in this Section shall prevent a party's ability to bring\ncross-claims or counter-claims.\n\n9. Miscellaneous\n----------------\n\nThis License represents the complete agreement concerning the subject\nmatter hereof. If any provision of this License is held to be\nunenforceable, such provision shall be reformed only to the extent\nnecessary to make it enforceable. Any law or regulation which provides\nthat the language of a contract shall be construed against the drafter\nshall not be used to construe this License against a Contributor.\n\n10. Versions of the License\n---------------------------\n\n10.1. New Versions\n\nMozilla Foundation is the license steward. Except as provided in Section\n10.3, no one other than the license steward has the right to modify or\npublish new versions of this License. Each version will be given a\ndistinguishing version number.\n\n10.2. Effect of New Versions\n\nYou may distribute the Covered Software under the terms of the version\nof the License under which You originally received the Covered Software,\nor under the terms of any subsequent version published by the license\nsteward.\n\n10.3. Modified Versions\n\nIf you create software not governed by this License, and you want to\ncreate a new license for such software, you may create and use a\nmodified version of this License if you rename the license and remove\nany references to the name of the license steward (except to note that\nsuch modified license differs from this License).\n\n10.4. Distributing Source Code Form that is Incompatible With Secondary\nLicenses\n\nIf You choose to distribute Source Code Form that is Incompatible With\nSecondary Licenses under the terms of this version of the License, the\nnotice described in Exhibit B of this License must be attached.\n\nExhibit A - Source Code Form License Notice\n-------------------------------------------\n\n  This Source Code Form is subject to the terms of the Mozilla Public\n  License, v. 2.0. If a copy of the MPL was not distributed with this\n  file, You can obtain one at http://mozilla.org/MPL/2.0/.\n\nIf it is not possible or desirable to put the notice in a particular\nfile, then You may include the notice in a location (such as a LICENSE\nfile in a relevant directory) where a recipient would be likely to look\nfor such a notice.\n\nYou may add additional accurate notices of copyright ownership.\n\nExhibit B - \"Incompatible With Secondary Licenses\" Notice\n---------------------------------------------------------\n\n  This Source Code Form is \"Incompatible With Secondary Licenses\", as\n  defined by the Mozilla Public License, v. 2.0.\n\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 1.4345703125,
          "content": "# whatsmeow\n[![Go Reference](https://pkg.go.dev/badge/go.mau.fi/whatsmeow.svg)](https://pkg.go.dev/go.mau.fi/whatsmeow)\n\nwhatsmeow is a Go library for the WhatsApp web multidevice API.\n\n## Discussion\nMatrix room: [#whatsmeow:maunium.net](https://matrix.to/#/#whatsmeow:maunium.net)\n\nFor questions about the WhatsApp protocol (like how to send a specific type of\nmessage), you can also use the [WhatsApp protocol Q&A] section on GitHub\ndiscussions.\n\n[WhatsApp protocol Q&A]: https://github.com/tulir/whatsmeow/discussions/categories/whatsapp-protocol-q-a\n\n## Usage\nThe [godoc](https://pkg.go.dev/go.mau.fi/whatsmeow) includes docs for all methods and event types.\nThere's also a [simple example](https://pkg.go.dev/go.mau.fi/whatsmeow#example-package) at the top.\n\n## Features\nMost core features are already present:\n\n* Sending messages to private chats and groups (both text and media)\n* Receiving all messages\n* Managing groups and receiving group change events\n* Joining via invite messages, using and creating invite links\n* Sending and receiving typing notifications\n* Sending and receiving delivery and read receipts\n* Reading and writing app state (contact list, chat pin/mute status, etc)\n* Sending and handling retry receipts if message decryption fails\n* Sending status messages (experimental, may not work for large contact lists)\n\nThings that are not yet implemented:\n\n* Sending broadcast list messages (this is not supported on WhatsApp web either)\n* Calls\n"
        },
        {
          "name": "appstate.go",
          "type": "blob",
          "size": 12.9921875,
          "content": "// Copyright (c) 2022 Tulir Asokan\n//\n// This Source Code Form is subject to the terms of the Mozilla Public\n// License, v. 2.0. If a copy of the MPL was not distributed with this\n// file, You can obtain one at http://mozilla.org/MPL/2.0/.\n\npackage whatsmeow\n\nimport (\n\t\"context\"\n\t\"encoding/hex\"\n\t\"errors\"\n\t\"fmt\"\n\t\"time\"\n\n\t\"go.mau.fi/whatsmeow/appstate\"\n\twaBinary \"go.mau.fi/whatsmeow/binary\"\n\twaProto \"go.mau.fi/whatsmeow/binary/proto\"\n\t\"go.mau.fi/whatsmeow/store\"\n\t\"go.mau.fi/whatsmeow/types\"\n\t\"go.mau.fi/whatsmeow/types/events\"\n)\n\n// FetchAppState fetches updates to the given type of app state. If fullSync is true, the current\n// cached state will be removed and all app state patches will be re-fetched from the server.\nfunc (cli *Client) FetchAppState(name appstate.WAPatchName, fullSync, onlyIfNotSynced bool) error {\n\tif cli == nil {\n\t\treturn ErrClientIsNil\n\t}\n\tcli.appStateSyncLock.Lock()\n\tdefer cli.appStateSyncLock.Unlock()\n\tif fullSync {\n\t\terr := cli.Store.AppState.DeleteAppStateVersion(string(name))\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"failed to reset app state %s version: %w\", name, err)\n\t\t}\n\t}\n\tversion, hash, err := cli.Store.AppState.GetAppStateVersion(string(name))\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to get app state %s version: %w\", name, err)\n\t}\n\tif version == 0 {\n\t\tfullSync = true\n\t} else if onlyIfNotSynced {\n\t\treturn nil\n\t}\n\n\tstate := appstate.HashState{Version: version, Hash: hash}\n\n\thasMore := true\n\twantSnapshot := fullSync\n\tfor hasMore {\n\t\tpatches, err := cli.fetchAppStatePatches(name, state.Version, wantSnapshot)\n\t\twantSnapshot = false\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"failed to fetch app state %s patches: %w\", name, err)\n\t\t}\n\t\thasMore = patches.HasMorePatches\n\n\t\tmutations, newState, err := cli.appStateProc.DecodePatches(patches, state, true)\n\t\tif err != nil {\n\t\t\tif errors.Is(err, appstate.ErrKeyNotFound) {\n\t\t\t\tgo cli.requestMissingAppStateKeys(context.TODO(), patches)\n\t\t\t}\n\t\t\treturn fmt.Errorf(\"failed to decode app state %s patches: %w\", name, err)\n\t\t}\n\t\twasFullSync := state.Version == 0 && patches.Snapshot != nil\n\t\tstate = newState\n\t\tif name == appstate.WAPatchCriticalUnblockLow && wasFullSync && !cli.EmitAppStateEventsOnFullSync {\n\t\t\tvar contacts []store.ContactEntry\n\t\t\tmutations, contacts = cli.filterContacts(mutations)\n\t\t\tcli.Log.Debugf(\"Mass inserting app state snapshot with %d contacts into the store\", len(contacts))\n\t\t\terr = cli.Store.Contacts.PutAllContactNames(contacts)\n\t\t\tif err != nil {\n\t\t\t\t// This is a fairly serious failure, so just abort the whole thing\n\t\t\t\treturn fmt.Errorf(\"failed to update contact store with data from snapshot: %v\", err)\n\t\t\t}\n\t\t}\n\t\tfor _, mutation := range mutations {\n\t\t\tcli.dispatchAppState(mutation, fullSync, cli.EmitAppStateEventsOnFullSync)\n\t\t}\n\t}\n\tif fullSync {\n\t\tcli.Log.Debugf(\"Full sync of app state %s completed. Current version: %d\", name, state.Version)\n\t\tcli.dispatchEvent(&events.AppStateSyncComplete{Name: name})\n\t} else {\n\t\tcli.Log.Debugf(\"Synced app state %s from version %d to %d\", name, version, state.Version)\n\t}\n\treturn nil\n}\n\nfunc (cli *Client) filterContacts(mutations []appstate.Mutation) ([]appstate.Mutation, []store.ContactEntry) {\n\tfilteredMutations := mutations[:0]\n\tcontacts := make([]store.ContactEntry, 0, len(mutations))\n\tfor _, mutation := range mutations {\n\t\tif mutation.Index[0] == \"contact\" && len(mutation.Index) > 1 {\n\t\t\tjid, _ := types.ParseJID(mutation.Index[1])\n\t\t\tact := mutation.Action.GetContactAction()\n\t\t\tcontacts = append(contacts, store.ContactEntry{\n\t\t\t\tJID:       jid,\n\t\t\t\tFirstName: act.GetFirstName(),\n\t\t\t\tFullName:  act.GetFullName(),\n\t\t\t})\n\t\t} else {\n\t\t\tfilteredMutations = append(filteredMutations, mutation)\n\t\t}\n\t}\n\treturn filteredMutations, contacts\n}\n\nfunc (cli *Client) dispatchAppState(mutation appstate.Mutation, fullSync bool, emitOnFullSync bool) {\n\n\tdispatchEvts := !fullSync || emitOnFullSync\n\n\tif mutation.Operation != waProto.SyncdMutation_SET {\n\t\treturn\n\t}\n\n\tif dispatchEvts {\n\t\tcli.dispatchEvent(&events.AppState{Index: mutation.Index, SyncActionValue: mutation.Action})\n\t}\n\n\tvar jid types.JID\n\tif len(mutation.Index) > 1 {\n\t\tjid, _ = types.ParseJID(mutation.Index[1])\n\t}\n\tts := time.UnixMilli(mutation.Action.GetTimestamp())\n\n\tvar storeUpdateError error\n\tvar eventToDispatch interface{}\n\tswitch mutation.Index[0] {\n\tcase appstate.IndexMute:\n\t\tact := mutation.Action.GetMuteAction()\n\t\teventToDispatch = &events.Mute{JID: jid, Timestamp: ts, Action: act, FromFullSync: fullSync}\n\t\tvar mutedUntil time.Time\n\t\tif act.GetMuted() {\n\t\t\tmutedUntil = time.UnixMilli(act.GetMuteEndTimestamp())\n\t\t}\n\t\tif cli.Store.ChatSettings != nil {\n\t\t\tstoreUpdateError = cli.Store.ChatSettings.PutMutedUntil(jid, mutedUntil)\n\t\t}\n\tcase appstate.IndexPin:\n\t\tact := mutation.Action.GetPinAction()\n\t\teventToDispatch = &events.Pin{JID: jid, Timestamp: ts, Action: act, FromFullSync: fullSync}\n\t\tif cli.Store.ChatSettings != nil {\n\t\t\tstoreUpdateError = cli.Store.ChatSettings.PutPinned(jid, act.GetPinned())\n\t\t}\n\tcase appstate.IndexArchive:\n\t\tact := mutation.Action.GetArchiveChatAction()\n\t\teventToDispatch = &events.Archive{JID: jid, Timestamp: ts, Action: act, FromFullSync: fullSync}\n\t\tif cli.Store.ChatSettings != nil {\n\t\t\tstoreUpdateError = cli.Store.ChatSettings.PutArchived(jid, act.GetArchived())\n\t\t}\n\tcase appstate.IndexContact:\n\t\tact := mutation.Action.GetContactAction()\n\t\teventToDispatch = &events.Contact{JID: jid, Timestamp: ts, Action: act, FromFullSync: fullSync}\n\t\tif cli.Store.Contacts != nil {\n\t\t\tstoreUpdateError = cli.Store.Contacts.PutContactName(jid, act.GetFirstName(), act.GetFullName())\n\t\t}\n\tcase appstate.IndexClearChat:\n\t\tact := mutation.Action.GetClearChatAction()\n\t\teventToDispatch = &events.ClearChat{JID: jid, Timestamp: ts, Action: act, FromFullSync: fullSync}\n\tcase appstate.IndexDeleteChat:\n\t\tact := mutation.Action.GetDeleteChatAction()\n\t\teventToDispatch = &events.DeleteChat{JID: jid, Timestamp: ts, Action: act, FromFullSync: fullSync}\n\tcase appstate.IndexStar:\n\t\tif len(mutation.Index) < 5 {\n\t\t\treturn\n\t\t}\n\t\tevt := events.Star{\n\t\t\tChatJID:      jid,\n\t\t\tMessageID:    mutation.Index[2],\n\t\t\tTimestamp:    ts,\n\t\t\tAction:       mutation.Action.GetStarAction(),\n\t\t\tIsFromMe:     mutation.Index[3] == \"1\",\n\t\t\tFromFullSync: fullSync,\n\t\t}\n\t\tif mutation.Index[4] != \"0\" {\n\t\t\tevt.SenderJID, _ = types.ParseJID(mutation.Index[4])\n\t\t}\n\t\teventToDispatch = &evt\n\tcase appstate.IndexDeleteMessageForMe:\n\t\tif len(mutation.Index) < 5 {\n\t\t\treturn\n\t\t}\n\t\tevt := events.DeleteForMe{\n\t\t\tChatJID:      jid,\n\t\t\tMessageID:    mutation.Index[2],\n\t\t\tTimestamp:    ts,\n\t\t\tAction:       mutation.Action.GetDeleteMessageForMeAction(),\n\t\t\tIsFromMe:     mutation.Index[3] == \"1\",\n\t\t\tFromFullSync: fullSync,\n\t\t}\n\t\tif mutation.Index[4] != \"0\" {\n\t\t\tevt.SenderJID, _ = types.ParseJID(mutation.Index[4])\n\t\t}\n\t\teventToDispatch = &evt\n\tcase appstate.IndexMarkChatAsRead:\n\t\teventToDispatch = &events.MarkChatAsRead{\n\t\t\tJID:          jid,\n\t\t\tTimestamp:    ts,\n\t\t\tAction:       mutation.Action.GetMarkChatAsReadAction(),\n\t\t\tFromFullSync: fullSync,\n\t\t}\n\tcase appstate.IndexSettingPushName:\n\t\teventToDispatch = &events.PushNameSetting{\n\t\t\tTimestamp:    ts,\n\t\t\tAction:       mutation.Action.GetPushNameSetting(),\n\t\t\tFromFullSync: fullSync,\n\t\t}\n\t\tcli.Store.PushName = mutation.Action.GetPushNameSetting().GetName()\n\t\terr := cli.Store.Save()\n\t\tif err != nil {\n\t\t\tcli.Log.Errorf(\"Failed to save device store after updating push name: %v\", err)\n\t\t}\n\tcase appstate.IndexSettingUnarchiveChats:\n\t\teventToDispatch = &events.UnarchiveChatsSetting{\n\t\t\tTimestamp:    ts,\n\t\t\tAction:       mutation.Action.GetUnarchiveChatsSetting(),\n\t\t\tFromFullSync: fullSync,\n\t\t}\n\tcase appstate.IndexUserStatusMute:\n\t\teventToDispatch = &events.UserStatusMute{\n\t\t\tJID:          jid,\n\t\t\tTimestamp:    ts,\n\t\t\tAction:       mutation.Action.GetUserStatusMuteAction(),\n\t\t\tFromFullSync: fullSync,\n\t\t}\n\tcase appstate.IndexLabelEdit:\n\t\tact := mutation.Action.GetLabelEditAction()\n\t\teventToDispatch = &events.LabelEdit{\n\t\t\tTimestamp:    ts,\n\t\t\tLabelID:      mutation.Index[1],\n\t\t\tAction:       act,\n\t\t\tFromFullSync: fullSync,\n\t\t}\n\tcase appstate.IndexLabelAssociationChat:\n\t\tif len(mutation.Index) < 3 {\n\t\t\treturn\n\t\t}\n\t\tjid, _ = types.ParseJID(mutation.Index[2])\n\t\tact := mutation.Action.GetLabelAssociationAction()\n\t\teventToDispatch = &events.LabelAssociationChat{\n\t\t\tJID:          jid,\n\t\t\tTimestamp:    ts,\n\t\t\tLabelID:      mutation.Index[1],\n\t\t\tAction:       act,\n\t\t\tFromFullSync: fullSync,\n\t\t}\n\tcase appstate.IndexLabelAssociationMessage:\n\t\tif len(mutation.Index) < 6 {\n\t\t\treturn\n\t\t}\n\t\tjid, _ = types.ParseJID(mutation.Index[2])\n\t\tact := mutation.Action.GetLabelAssociationAction()\n\t\teventToDispatch = &events.LabelAssociationMessage{\n\t\t\tJID:          jid,\n\t\t\tTimestamp:    ts,\n\t\t\tLabelID:      mutation.Index[1],\n\t\t\tMessageID:    mutation.Index[3],\n\t\t\tAction:       act,\n\t\t\tFromFullSync: fullSync,\n\t\t}\n\t}\n\tif storeUpdateError != nil {\n\t\tcli.Log.Errorf(\"Failed to update device store after app state mutation: %v\", storeUpdateError)\n\t}\n\tif dispatchEvts && eventToDispatch != nil {\n\t\tcli.dispatchEvent(eventToDispatch)\n\t}\n}\n\nfunc (cli *Client) downloadExternalAppStateBlob(ref *waProto.ExternalBlobReference) ([]byte, error) {\n\treturn cli.Download(ref)\n}\n\nfunc (cli *Client) fetchAppStatePatches(name appstate.WAPatchName, fromVersion uint64, snapshot bool) (*appstate.PatchList, error) {\n\tattrs := waBinary.Attrs{\n\t\t\"name\":            string(name),\n\t\t\"return_snapshot\": snapshot,\n\t}\n\tif !snapshot {\n\t\tattrs[\"version\"] = fromVersion\n\t}\n\tresp, err := cli.sendIQ(infoQuery{\n\t\tNamespace: \"w:sync:app:state\",\n\t\tType:      \"set\",\n\t\tTo:        types.ServerJID,\n\t\tContent: []waBinary.Node{{\n\t\t\tTag: \"sync\",\n\t\t\tContent: []waBinary.Node{{\n\t\t\t\tTag:   \"collection\",\n\t\t\t\tAttrs: attrs,\n\t\t\t}},\n\t\t}},\n\t})\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn appstate.ParsePatchList(resp, cli.downloadExternalAppStateBlob)\n}\n\nfunc (cli *Client) requestMissingAppStateKeys(ctx context.Context, patches *appstate.PatchList) {\n\tcli.appStateKeyRequestsLock.Lock()\n\trawKeyIDs := cli.appStateProc.GetMissingKeyIDs(patches)\n\tfilteredKeyIDs := make([][]byte, 0, len(rawKeyIDs))\n\tnow := time.Now()\n\tfor _, keyID := range rawKeyIDs {\n\t\tstringKeyID := hex.EncodeToString(keyID)\n\t\tlastRequestTime := cli.appStateKeyRequests[stringKeyID]\n\t\tif lastRequestTime.IsZero() || lastRequestTime.Add(24*time.Hour).Before(now) {\n\t\t\tcli.appStateKeyRequests[stringKeyID] = now\n\t\t\tfilteredKeyIDs = append(filteredKeyIDs, keyID)\n\t\t}\n\t}\n\tcli.appStateKeyRequestsLock.Unlock()\n\tcli.requestAppStateKeys(ctx, filteredKeyIDs)\n}\n\nfunc (cli *Client) requestAppStateKeys(ctx context.Context, rawKeyIDs [][]byte) {\n\tkeyIDs := make([]*waProto.AppStateSyncKeyId, len(rawKeyIDs))\n\tdebugKeyIDs := make([]string, len(rawKeyIDs))\n\tfor i, keyID := range rawKeyIDs {\n\t\tkeyIDs[i] = &waProto.AppStateSyncKeyId{KeyID: keyID}\n\t\tdebugKeyIDs[i] = hex.EncodeToString(keyID)\n\t}\n\tmsg := &waProto.Message{\n\t\tProtocolMessage: &waProto.ProtocolMessage{\n\t\t\tType: waProto.ProtocolMessage_APP_STATE_SYNC_KEY_REQUEST.Enum(),\n\t\t\tAppStateSyncKeyRequest: &waProto.AppStateSyncKeyRequest{\n\t\t\t\tKeyIDs: keyIDs,\n\t\t\t},\n\t\t},\n\t}\n\townID := cli.getOwnID().ToNonAD()\n\tif ownID.IsEmpty() || len(debugKeyIDs) == 0 {\n\t\treturn\n\t}\n\tcli.Log.Infof(\"Sending key request for app state keys %+v\", debugKeyIDs)\n\t_, err := cli.SendMessage(ctx, ownID, msg, SendRequestExtra{Peer: true})\n\tif err != nil {\n\t\tcli.Log.Warnf(\"Failed to send app state key request: %v\", err)\n\t}\n}\n\n// SendAppState sends the given app state patch, then resyncs that app state type from the server\n// to update local caches and send events for the updates.\n//\n// You can use the Build methods in the appstate package to build the parameter for this method, e.g.\n//\n//\tcli.SendAppState(appstate.BuildMute(targetJID, true, 24 * time.Hour))\nfunc (cli *Client) SendAppState(patch appstate.PatchInfo) error {\n\tif cli == nil {\n\t\treturn ErrClientIsNil\n\t}\n\tversion, hash, err := cli.Store.AppState.GetAppStateVersion(string(patch.Type))\n\tif err != nil {\n\t\treturn err\n\t}\n\t// TODO create new key instead of reusing the primary client's keys\n\tlatestKeyID, err := cli.Store.AppStateKeys.GetLatestAppStateSyncKeyID()\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to get latest app state key ID: %w\", err)\n\t} else if latestKeyID == nil {\n\t\treturn fmt.Errorf(\"no app state keys found, creating app state keys is not yet supported\")\n\t}\n\n\tstate := appstate.HashState{Version: version, Hash: hash}\n\n\tencodedPatch, err := cli.appStateProc.EncodePatch(latestKeyID, state, patch)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tresp, err := cli.sendIQ(infoQuery{\n\t\tNamespace: \"w:sync:app:state\",\n\t\tType:      iqSet,\n\t\tTo:        types.ServerJID,\n\t\tContent: []waBinary.Node{{\n\t\t\tTag: \"sync\",\n\t\t\tContent: []waBinary.Node{{\n\t\t\t\tTag: \"collection\",\n\t\t\t\tAttrs: waBinary.Attrs{\n\t\t\t\t\t\"name\":            string(patch.Type),\n\t\t\t\t\t\"version\":         version,\n\t\t\t\t\t\"return_snapshot\": false,\n\t\t\t\t},\n\t\t\t\tContent: []waBinary.Node{{\n\t\t\t\t\tTag:     \"patch\",\n\t\t\t\t\tContent: encodedPatch,\n\t\t\t\t}},\n\t\t\t}},\n\t\t}},\n\t})\n\tif err != nil {\n\t\treturn err\n\t}\n\n\trespCollection := resp.GetChildByTag(\"sync\", \"collection\")\n\trespCollectionAttr := respCollection.AttrGetter()\n\tif respCollectionAttr.OptionalString(\"type\") == \"error\" {\n\t\t// TODO parse error properly\n\t\treturn fmt.Errorf(\"%w: %s\", ErrAppStateUpdate, respCollection.XMLString())\n\t}\n\n\treturn cli.FetchAppState(patch.Type, false, false)\n}\n"
        },
        {
          "name": "appstate",
          "type": "tree",
          "content": null
        },
        {
          "name": "armadillomessage.go",
          "type": "blob",
          "size": 3.6708984375,
          "content": "// Copyright (c) 2024 Tulir Asokan\n//\n// This Source Code Form is subject to the terms of the Mozilla Public\n// License, v. 2.0. If a copy of the MPL was not distributed with this\n// file, You can obtain one at http://mozilla.org/MPL/2.0/.\n\npackage whatsmeow\n\nimport (\n\t\"fmt\"\n\n\t\"google.golang.org/protobuf/proto\"\n\n\tarmadillo \"go.mau.fi/whatsmeow/proto\"\n\t\"go.mau.fi/whatsmeow/proto/waCommon\"\n\t\"go.mau.fi/whatsmeow/proto/waMsgApplication\"\n\t\"go.mau.fi/whatsmeow/proto/waMsgTransport\"\n\t\"go.mau.fi/whatsmeow/types\"\n\t\"go.mau.fi/whatsmeow/types/events\"\n)\n\nfunc (cli *Client) handleDecryptedArmadillo(info *types.MessageInfo, decrypted []byte, retryCount int) bool {\n\tdec, err := decodeArmadillo(decrypted)\n\tif err != nil {\n\t\tcli.Log.Warnf(\"Failed to decode armadillo message from %s: %v\", info.SourceString(), err)\n\t\treturn false\n\t}\n\tdec.Info = *info\n\tdec.RetryCount = retryCount\n\tif dec.Transport.GetProtocol().GetAncillary().GetSkdm() != nil {\n\t\tif !info.IsGroup {\n\t\t\tcli.Log.Warnf(\"Got sender key distribution message in non-group chat from %s\", info.Sender)\n\t\t} else {\n\t\t\tskdm := dec.Transport.GetProtocol().GetAncillary().GetSkdm()\n\t\t\tcli.handleSenderKeyDistributionMessage(info.Chat, info.Sender, skdm.AxolotlSenderKeyDistributionMessage)\n\t\t}\n\t}\n\tif dec.Message != nil {\n\t\tcli.dispatchEvent(&dec)\n\t}\n\treturn true\n}\n\nfunc decodeArmadillo(data []byte) (dec events.FBMessage, err error) {\n\tvar transport waMsgTransport.MessageTransport\n\terr = proto.Unmarshal(data, &transport)\n\tif err != nil {\n\t\treturn dec, fmt.Errorf(\"failed to unmarshal transport: %w\", err)\n\t}\n\tdec.Transport = &transport\n\tif transport.GetPayload() == nil {\n\t\treturn\n\t}\n\tapplication, err := transport.GetPayload().Decode()\n\tif err != nil {\n\t\treturn dec, fmt.Errorf(\"failed to unmarshal application: %w\", err)\n\t}\n\tdec.Application = application\n\tif application.GetPayload() == nil {\n\t\treturn\n\t}\n\n\tswitch typedContent := application.GetPayload().GetContent().(type) {\n\tcase *waMsgApplication.MessageApplication_Payload_CoreContent:\n\t\terr = fmt.Errorf(\"unsupported core content payload\")\n\tcase *waMsgApplication.MessageApplication_Payload_Signal:\n\t\terr = fmt.Errorf(\"unsupported signal payload\")\n\tcase *waMsgApplication.MessageApplication_Payload_ApplicationData:\n\t\terr = fmt.Errorf(\"unsupported application data payload\")\n\tcase *waMsgApplication.MessageApplication_Payload_SubProtocol:\n\t\tvar protoMsg proto.Message\n\t\tvar subData *waCommon.SubProtocol\n\t\tswitch subProtocol := typedContent.SubProtocol.GetSubProtocol().(type) {\n\t\tcase *waMsgApplication.MessageApplication_SubProtocolPayload_ConsumerMessage:\n\t\t\tdec.Message, err = subProtocol.Decode()\n\t\tcase *waMsgApplication.MessageApplication_SubProtocolPayload_BusinessMessage:\n\t\t\tdec.Message = (*armadillo.Unsupported_BusinessApplication)(subProtocol.BusinessMessage)\n\t\tcase *waMsgApplication.MessageApplication_SubProtocolPayload_PaymentMessage:\n\t\t\tdec.Message = (*armadillo.Unsupported_PaymentApplication)(subProtocol.PaymentMessage)\n\t\tcase *waMsgApplication.MessageApplication_SubProtocolPayload_MultiDevice:\n\t\t\tdec.Message, err = subProtocol.Decode()\n\t\tcase *waMsgApplication.MessageApplication_SubProtocolPayload_Voip:\n\t\t\tdec.Message = (*armadillo.Unsupported_Voip)(subProtocol.Voip)\n\t\tcase *waMsgApplication.MessageApplication_SubProtocolPayload_Armadillo:\n\t\t\tdec.Message, err = subProtocol.Decode()\n\t\tdefault:\n\t\t\treturn dec, fmt.Errorf(\"unsupported subprotocol type: %T\", subProtocol)\n\t\t}\n\t\tif protoMsg != nil {\n\t\t\terr = proto.Unmarshal(subData.GetPayload(), protoMsg)\n\t\t\tif err != nil {\n\t\t\t\treturn dec, fmt.Errorf(\"failed to unmarshal application subprotocol payload (%T v%d): %w\", protoMsg, subData.GetVersion(), err)\n\t\t\t}\n\t\t}\n\tdefault:\n\t\terr = fmt.Errorf(\"unsupported application payload content type: %T\", typedContent)\n\t}\n\treturn\n}\n"
        },
        {
          "name": "binary",
          "type": "tree",
          "content": null
        },
        {
          "name": "broadcast.go",
          "type": "blob",
          "size": 3.6220703125,
          "content": "// Copyright (c) 2022 Tulir Asokan\n//\n// This Source Code Form is subject to the terms of the Mozilla Public\n// License, v. 2.0. If a copy of the MPL was not distributed with this\n// file, You can obtain one at http://mozilla.org/MPL/2.0/.\n\npackage whatsmeow\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\n\twaBinary \"go.mau.fi/whatsmeow/binary\"\n\t\"go.mau.fi/whatsmeow/types\"\n)\n\nfunc (cli *Client) getBroadcastListParticipants(jid types.JID) ([]types.JID, error) {\n\tvar list []types.JID\n\tvar err error\n\tif jid == types.StatusBroadcastJID {\n\t\tlist, err = cli.getStatusBroadcastRecipients()\n\t} else {\n\t\treturn nil, ErrBroadcastListUnsupported\n\t}\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\townID := cli.getOwnID().ToNonAD()\n\tif ownID.IsEmpty() {\n\t\treturn nil, ErrNotLoggedIn\n\t}\n\n\tselfIndex := -1\n\tfor i, participant := range list {\n\t\tif participant.User == ownID.User {\n\t\t\tselfIndex = i\n\t\t\tbreak\n\t\t}\n\t}\n\tif selfIndex < 0 {\n\t\tlist = append(list, ownID)\n\t}\n\treturn list, nil\n}\n\nfunc (cli *Client) getStatusBroadcastRecipients() ([]types.JID, error) {\n\tstatusPrivacyOptions, err := cli.GetStatusPrivacy()\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to get status privacy: %w\", err)\n\t}\n\tstatusPrivacy := statusPrivacyOptions[0]\n\tif statusPrivacy.Type == types.StatusPrivacyTypeWhitelist {\n\t\t// Whitelist mode, just return the list\n\t\treturn statusPrivacy.List, nil\n\t}\n\n\t// Blacklist or all contacts mode. Find all contacts from database, then filter them appropriately.\n\tcontacts, err := cli.Store.Contacts.GetAllContacts()\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to get contact list from db: %w\", err)\n\t}\n\n\tblacklist := make(map[types.JID]struct{})\n\tif statusPrivacy.Type == types.StatusPrivacyTypeBlacklist {\n\t\tfor _, jid := range statusPrivacy.List {\n\t\t\tblacklist[jid] = struct{}{}\n\t\t}\n\t}\n\n\tvar contactsArray []types.JID\n\tfor jid, contact := range contacts {\n\t\t_, isBlacklisted := blacklist[jid]\n\t\tif isBlacklisted {\n\t\t\tcontinue\n\t\t}\n\t\t// TODO should there be a better way to separate contacts and found push names in the db?\n\t\tif len(contact.FullName) > 0 {\n\t\t\tcontactsArray = append(contactsArray, jid)\n\t\t}\n\t}\n\treturn contactsArray, nil\n}\n\nvar DefaultStatusPrivacy = []types.StatusPrivacy{{\n\tType:      types.StatusPrivacyTypeContacts,\n\tIsDefault: true,\n}}\n\n// GetStatusPrivacy gets the user's status privacy settings (who to send status broadcasts to).\n//\n// There can be multiple different stored settings, the first one is always the default.\nfunc (cli *Client) GetStatusPrivacy() ([]types.StatusPrivacy, error) {\n\tresp, err := cli.sendIQ(infoQuery{\n\t\tNamespace: \"status\",\n\t\tType:      iqGet,\n\t\tTo:        types.ServerJID,\n\t\tContent: []waBinary.Node{{\n\t\t\tTag: \"privacy\",\n\t\t}},\n\t})\n\tif err != nil {\n\t\tif errors.Is(err, ErrIQNotFound) {\n\t\t\treturn DefaultStatusPrivacy, nil\n\t\t}\n\t\treturn nil, err\n\t}\n\tprivacyLists := resp.GetChildByTag(\"privacy\")\n\tvar outputs []types.StatusPrivacy\n\tfor _, list := range privacyLists.GetChildren() {\n\t\tif list.Tag != \"list\" {\n\t\t\tcontinue\n\t\t}\n\n\t\tag := list.AttrGetter()\n\t\tvar out types.StatusPrivacy\n\t\tout.IsDefault = ag.OptionalBool(\"default\")\n\t\tout.Type = types.StatusPrivacyType(ag.String(\"type\"))\n\t\tchildren := list.GetChildren()\n\t\tif len(children) > 0 {\n\t\t\tout.List = make([]types.JID, 0, len(children))\n\t\t\tfor _, child := range children {\n\t\t\t\tjid, ok := child.Attrs[\"jid\"].(types.JID)\n\t\t\t\tif child.Tag == \"user\" && ok {\n\t\t\t\t\tout.List = append(out.List, jid)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\toutputs = append(outputs, out)\n\t\tif out.IsDefault {\n\t\t\t// Move default to always be first in the list\n\t\t\toutputs[len(outputs)-1] = outputs[0]\n\t\t\toutputs[0] = out\n\t\t}\n\t\tif len(ag.Errors) > 0 {\n\t\t\treturn nil, ag.Error()\n\t\t}\n\t}\n\tif len(outputs) == 0 {\n\t\treturn DefaultStatusPrivacy, nil\n\t}\n\treturn outputs, nil\n}\n"
        },
        {
          "name": "call.go",
          "type": "blob",
          "size": 2.97265625,
          "content": "// Copyright (c) 2021 Tulir Asokan\n//\n// This Source Code Form is subject to the terms of the Mozilla Public\n// License, v. 2.0. If a copy of the MPL was not distributed with this\n// file, You can obtain one at http://mozilla.org/MPL/2.0/.\n\npackage whatsmeow\n\nimport (\n\twaBinary \"go.mau.fi/whatsmeow/binary\"\n\t\"go.mau.fi/whatsmeow/types\"\n\t\"go.mau.fi/whatsmeow/types/events\"\n)\n\nfunc (cli *Client) handleCallEvent(node *waBinary.Node) {\n\tgo cli.sendAck(node)\n\n\tif len(node.GetChildren()) != 1 {\n\t\tcli.dispatchEvent(&events.UnknownCallEvent{Node: node})\n\t\treturn\n\t}\n\tag := node.AttrGetter()\n\tchild := node.GetChildren()[0]\n\tcag := child.AttrGetter()\n\tbasicMeta := types.BasicCallMeta{\n\t\tFrom:        ag.JID(\"from\"),\n\t\tTimestamp:   ag.UnixTime(\"t\"),\n\t\tCallCreator: cag.JID(\"call-creator\"),\n\t\tCallID:      cag.String(\"call-id\"),\n\t}\n\tswitch child.Tag {\n\tcase \"offer\":\n\t\tcli.dispatchEvent(&events.CallOffer{\n\t\t\tBasicCallMeta: basicMeta,\n\t\t\tCallRemoteMeta: types.CallRemoteMeta{\n\t\t\t\tRemotePlatform: ag.String(\"platform\"),\n\t\t\t\tRemoteVersion:  ag.String(\"version\"),\n\t\t\t},\n\t\t\tData: &child,\n\t\t})\n\tcase \"offer_notice\":\n\t\tcli.dispatchEvent(&events.CallOfferNotice{\n\t\t\tBasicCallMeta: basicMeta,\n\t\t\tMedia:         cag.String(\"media\"),\n\t\t\tType:          cag.String(\"type\"),\n\t\t\tData:          &child,\n\t\t})\n\tcase \"relaylatency\":\n\t\tcli.dispatchEvent(&events.CallRelayLatency{\n\t\t\tBasicCallMeta: basicMeta,\n\t\t\tData:          &child,\n\t\t})\n\tcase \"accept\":\n\t\tcli.dispatchEvent(&events.CallAccept{\n\t\t\tBasicCallMeta: basicMeta,\n\t\t\tCallRemoteMeta: types.CallRemoteMeta{\n\t\t\t\tRemotePlatform: ag.String(\"platform\"),\n\t\t\t\tRemoteVersion:  ag.String(\"version\"),\n\t\t\t},\n\t\t\tData: &child,\n\t\t})\n\tcase \"preaccept\":\n\t\tcli.dispatchEvent(&events.CallPreAccept{\n\t\t\tBasicCallMeta: basicMeta,\n\t\t\tCallRemoteMeta: types.CallRemoteMeta{\n\t\t\t\tRemotePlatform: ag.String(\"platform\"),\n\t\t\t\tRemoteVersion:  ag.String(\"version\"),\n\t\t\t},\n\t\t\tData: &child,\n\t\t})\n\tcase \"transport\":\n\t\tcli.dispatchEvent(&events.CallTransport{\n\t\t\tBasicCallMeta: basicMeta,\n\t\t\tCallRemoteMeta: types.CallRemoteMeta{\n\t\t\t\tRemotePlatform: ag.String(\"platform\"),\n\t\t\t\tRemoteVersion:  ag.String(\"version\"),\n\t\t\t},\n\t\t\tData: &child,\n\t\t})\n\tcase \"terminate\":\n\t\tcli.dispatchEvent(&events.CallTerminate{\n\t\t\tBasicCallMeta: basicMeta,\n\t\t\tReason:        cag.String(\"reason\"),\n\t\t\tData:          &child,\n\t\t})\n\tcase \"reject\":\n\t\tcli.dispatchEvent(&events.CallReject{\n\t\t\tBasicCallMeta: basicMeta,\n\t\t\tData:          &child,\n\t\t})\n\tdefault:\n\t\tcli.dispatchEvent(&events.UnknownCallEvent{Node: node})\n\t}\n}\n\n// RejectCall reject an incoming call.\nfunc (cli *Client) RejectCall(callFrom types.JID, callID string) error {\n\townID := cli.getOwnID()\n\tif ownID.IsEmpty() {\n\t\treturn ErrNotLoggedIn\n\t}\n\townID, callFrom = ownID.ToNonAD(), callFrom.ToNonAD()\n\treturn cli.sendNode(waBinary.Node{\n\t\tTag:   \"call\",\n\t\tAttrs: waBinary.Attrs{\"id\": cli.GenerateMessageID(), \"from\": ownID, \"to\": callFrom},\n\t\tContent: []waBinary.Node{{\n\t\t\tTag:     \"reject\",\n\t\t\tAttrs:   waBinary.Attrs{\"call-id\": callID, \"call-creator\": callFrom, \"count\": \"0\"},\n\t\t\tContent: nil,\n\t\t}},\n\t})\n}\n"
        },
        {
          "name": "client.go",
          "type": "blob",
          "size": 26.0126953125,
          "content": "// Copyright (c) 2021 Tulir Asokan\n//\n// This Source Code Form is subject to the terms of the Mozilla Public\n// License, v. 2.0. If a copy of the MPL was not distributed with this\n// file, You can obtain one at http://mozilla.org/MPL/2.0/.\n\n// Package whatsmeow implements a client for interacting with the WhatsApp web multidevice API.\npackage whatsmeow\n\nimport (\n\t\"context\"\n\t\"encoding/hex\"\n\t\"errors\"\n\t\"fmt\"\n\t\"net/http\"\n\t\"net/url\"\n\t\"runtime/debug\"\n\t\"sync\"\n\t\"sync/atomic\"\n\t\"time\"\n\n\t\"github.com/gorilla/websocket\"\n\t\"go.mau.fi/util/random\"\n\t\"golang.org/x/net/proxy\"\n\n\t\"go.mau.fi/whatsmeow/appstate\"\n\twaBinary \"go.mau.fi/whatsmeow/binary\"\n\twaProto \"go.mau.fi/whatsmeow/binary/proto\"\n\t\"go.mau.fi/whatsmeow/proto/waE2E\"\n\t\"go.mau.fi/whatsmeow/proto/waWeb\"\n\t\"go.mau.fi/whatsmeow/socket\"\n\t\"go.mau.fi/whatsmeow/store\"\n\t\"go.mau.fi/whatsmeow/types\"\n\t\"go.mau.fi/whatsmeow/types/events\"\n\t\"go.mau.fi/whatsmeow/util/keys\"\n\twaLog \"go.mau.fi/whatsmeow/util/log\"\n)\n\n// EventHandler is a function that can handle events from WhatsApp.\ntype EventHandler func(evt interface{})\ntype nodeHandler func(node *waBinary.Node)\n\nvar nextHandlerID uint32\n\ntype wrappedEventHandler struct {\n\tfn EventHandler\n\tid uint32\n}\n\ntype deviceCache struct {\n\tdevices []types.JID\n\tdhash   string\n}\n\n// Client contains everything necessary to connect to and interact with the WhatsApp web API.\ntype Client struct {\n\tStore   *store.Device\n\tLog     waLog.Logger\n\trecvLog waLog.Logger\n\tsendLog waLog.Logger\n\n\tsocket     *socket.NoiseSocket\n\tsocketLock sync.RWMutex\n\tsocketWait chan struct{}\n\twsDialer   *websocket.Dialer\n\n\tisLoggedIn            atomic.Bool\n\texpectedDisconnect    atomic.Bool\n\tEnableAutoReconnect   bool\n\tLastSuccessfulConnect time.Time\n\tAutoReconnectErrors   int\n\t// AutoReconnectHook is called when auto-reconnection fails. If the function returns false,\n\t// the client will not attempt to reconnect. The number of retries can be read from AutoReconnectErrors.\n\tAutoReconnectHook func(error) bool\n\n\tDisableLoginAutoReconnect bool\n\n\tsendActiveReceipts atomic.Uint32\n\n\t// EmitAppStateEventsOnFullSync can be set to true if you want to get app state events emitted\n\t// even when re-syncing the whole state.\n\tEmitAppStateEventsOnFullSync bool\n\n\tAutomaticMessageRerequestFromPhone bool\n\tpendingPhoneRerequests             map[types.MessageID]context.CancelFunc\n\tpendingPhoneRerequestsLock         sync.RWMutex\n\n\tappStateProc     *appstate.Processor\n\tappStateSyncLock sync.Mutex\n\n\thistorySyncNotifications  chan *waProto.HistorySyncNotification\n\thistorySyncHandlerStarted atomic.Bool\n\n\tuploadPreKeysLock sync.Mutex\n\tlastPreKeyUpload  time.Time\n\n\tmediaConnCache *MediaConn\n\tmediaConnLock  sync.Mutex\n\n\tresponseWaiters     map[string]chan<- *waBinary.Node\n\tresponseWaitersLock sync.Mutex\n\n\tnodeHandlers      map[string]nodeHandler\n\thandlerQueue      chan *waBinary.Node\n\teventHandlers     []wrappedEventHandler\n\teventHandlersLock sync.RWMutex\n\n\tmessageRetries     map[string]int\n\tmessageRetriesLock sync.Mutex\n\n\tincomingRetryRequestCounter     map[incomingRetryKey]int\n\tincomingRetryRequestCounterLock sync.Mutex\n\n\tappStateKeyRequests     map[string]time.Time\n\tappStateKeyRequestsLock sync.RWMutex\n\n\tmessageSendLock sync.Mutex\n\n\tprivacySettingsCache atomic.Value\n\n\tgroupParticipantsCache     map[types.JID][]types.JID\n\tgroupParticipantsCacheLock sync.Mutex\n\tuserDevicesCache           map[types.JID]deviceCache\n\tuserDevicesCacheLock       sync.Mutex\n\n\trecentMessagesMap  map[recentMessageKey]RecentMessage\n\trecentMessagesList [recentMessagesSize]recentMessageKey\n\trecentMessagesPtr  int\n\trecentMessagesLock sync.RWMutex\n\n\tsessionRecreateHistory     map[types.JID]time.Time\n\tsessionRecreateHistoryLock sync.Mutex\n\t// GetMessageForRetry is used to find the source message for handling retry receipts\n\t// when the message is not found in the recently sent message cache.\n\tGetMessageForRetry func(requester, to types.JID, id types.MessageID) *waProto.Message\n\t// PreRetryCallback is called before a retry receipt is accepted.\n\t// If it returns false, the accepting will be cancelled and the retry receipt will be ignored.\n\tPreRetryCallback func(receipt *events.Receipt, id types.MessageID, retryCount int, msg *waProto.Message) bool\n\n\t// PrePairCallback is called before pairing is completed. If it returns false, the pairing will be cancelled and\n\t// the client will disconnect.\n\tPrePairCallback func(jid types.JID, platform, businessName string) bool\n\n\t// GetClientPayload is called to get the client payload for connecting to the server.\n\t// This should NOT be used for WhatsApp (to change the OS name, update fields in store.BaseClientPayload directly).\n\tGetClientPayload func() *waProto.ClientPayload\n\n\t// Should untrusted identity errors be handled automatically? If true, the stored identity and existing signal\n\t// sessions will be removed on untrusted identity errors, and an events.IdentityChange will be dispatched.\n\t// If false, decrypting a message from untrusted devices will fail.\n\tAutoTrustIdentity bool\n\n\t// Should SubscribePresence return an error if no privacy token is stored for the user?\n\tErrorOnSubscribePresenceWithoutToken bool\n\n\tphoneLinkingCache *phoneLinkingCache\n\n\tuniqueID  string\n\tidCounter atomic.Uint64\n\n\tproxy          Proxy\n\tsocksProxy     proxy.Dialer\n\tproxyOnlyLogin bool\n\thttp           *http.Client\n\n\t// This field changes the client to act like a Messenger client instead of a WhatsApp one.\n\t//\n\t// Note that you cannot use a Messenger account just by setting this field, you must use a\n\t// separate library for all the non-e2ee-related stuff like logging in.\n\t// The library is currently embedded in mautrix-meta (https://github.com/mautrix/meta), but may be separated later.\n\tMessengerConfig *MessengerConfig\n\tRefreshCAT      func() error\n}\n\ntype MessengerConfig struct {\n\tUserAgent    string\n\tBaseURL      string\n\tWebsocketURL string\n}\n\n// Size of buffer for the channel that all incoming XML nodes go through.\n// In general it shouldn't go past a few buffered messages, but the channel is big to be safe.\nconst handlerQueueSize = 2048\n\n// NewClient initializes a new WhatsApp web client.\n//\n// The logger can be nil, it will default to a no-op logger.\n//\n// The device store must be set. A default SQL-backed implementation is available in the store/sqlstore package.\n//\n//\tcontainer, err := sqlstore.New(\"sqlite3\", \"file:yoursqlitefile.db?_foreign_keys=on\", nil)\n//\tif err != nil {\n//\t\tpanic(err)\n//\t}\n//\t// If you want multiple sessions, remember their JIDs and use .GetDevice(jid) or .GetAllDevices() instead.\n//\tdeviceStore, err := container.GetFirstDevice()\n//\tif err != nil {\n//\t\tpanic(err)\n//\t}\n//\tclient := whatsmeow.NewClient(deviceStore, nil)\nfunc NewClient(deviceStore *store.Device, log waLog.Logger) *Client {\n\tif log == nil {\n\t\tlog = waLog.Noop\n\t}\n\tuniqueIDPrefix := random.Bytes(2)\n\tcli := &Client{\n\t\thttp: &http.Client{\n\t\t\tTransport: (http.DefaultTransport.(*http.Transport)).Clone(),\n\t\t},\n\t\tproxy:           http.ProxyFromEnvironment,\n\t\tStore:           deviceStore,\n\t\tLog:             log,\n\t\trecvLog:         log.Sub(\"Recv\"),\n\t\tsendLog:         log.Sub(\"Send\"),\n\t\tuniqueID:        fmt.Sprintf(\"%d.%d-\", uniqueIDPrefix[0], uniqueIDPrefix[1]),\n\t\tresponseWaiters: make(map[string]chan<- *waBinary.Node),\n\t\teventHandlers:   make([]wrappedEventHandler, 0, 1),\n\t\tmessageRetries:  make(map[string]int),\n\t\thandlerQueue:    make(chan *waBinary.Node, handlerQueueSize),\n\t\tappStateProc:    appstate.NewProcessor(deviceStore, log.Sub(\"AppState\")),\n\t\tsocketWait:      make(chan struct{}),\n\n\t\tincomingRetryRequestCounter: make(map[incomingRetryKey]int),\n\n\t\thistorySyncNotifications: make(chan *waProto.HistorySyncNotification, 32),\n\n\t\tgroupParticipantsCache: make(map[types.JID][]types.JID),\n\t\tuserDevicesCache:       make(map[types.JID]deviceCache),\n\n\t\trecentMessagesMap:      make(map[recentMessageKey]RecentMessage, recentMessagesSize),\n\t\tsessionRecreateHistory: make(map[types.JID]time.Time),\n\t\tGetMessageForRetry:     func(requester, to types.JID, id types.MessageID) *waProto.Message { return nil },\n\t\tappStateKeyRequests:    make(map[string]time.Time),\n\n\t\tpendingPhoneRerequests: make(map[types.MessageID]context.CancelFunc),\n\n\t\tEnableAutoReconnect: true,\n\t\tAutoTrustIdentity:   true,\n\t}\n\tcli.nodeHandlers = map[string]nodeHandler{\n\t\t\"message\":      cli.handleEncryptedMessage,\n\t\t\"appdata\":      cli.handleEncryptedMessage,\n\t\t\"receipt\":      cli.handleReceipt,\n\t\t\"call\":         cli.handleCallEvent,\n\t\t\"chatstate\":    cli.handleChatState,\n\t\t\"presence\":     cli.handlePresence,\n\t\t\"notification\": cli.handleNotification,\n\t\t\"success\":      cli.handleConnectSuccess,\n\t\t\"failure\":      cli.handleConnectFailure,\n\t\t\"stream:error\": cli.handleStreamError,\n\t\t\"iq\":           cli.handleIQ,\n\t\t\"ib\":           cli.handleIB,\n\t\t// Apparently there's also an <error> node which can have a code=479 and means \"Invalid stanza sent (smax-invalid)\"\n\t}\n\treturn cli\n}\n\n// SetProxyAddress is a helper method that parses a URL string and calls SetProxy or SetSOCKSProxy based on the URL scheme.\n//\n// Returns an error if url.Parse fails to parse the given address.\nfunc (cli *Client) SetProxyAddress(addr string, opts ...SetProxyOptions) error {\n\tif addr == \"\" {\n\t\tcli.SetProxy(nil, opts...)\n\t\treturn nil\n\t}\n\tparsed, err := url.Parse(addr)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif parsed.Scheme == \"http\" || parsed.Scheme == \"https\" {\n\t\tcli.SetProxy(http.ProxyURL(parsed), opts...)\n\t} else if parsed.Scheme == \"socks5\" {\n\t\tpx, err := proxy.FromURL(parsed, proxy.Direct)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tcli.SetSOCKSProxy(px, opts...)\n\t} else {\n\t\treturn fmt.Errorf(\"unsupported proxy scheme %q\", parsed.Scheme)\n\t}\n\treturn nil\n}\n\ntype Proxy = func(*http.Request) (*url.URL, error)\n\n// SetProxy sets a HTTP proxy to use for WhatsApp web websocket connections and media uploads/downloads.\n//\n// Must be called before Connect() to take effect in the websocket connection.\n// If you want to change the proxy after connecting, you must call Disconnect() and then Connect() again manually.\n//\n// By default, the client will find the proxy from the https_proxy environment variable like Go's net/http does.\n//\n// To disable reading proxy info from environment variables, explicitly set the proxy to nil:\n//\n//\tcli.SetProxy(nil)\n//\n// To use a different proxy for the websocket and media, pass a function that checks the request path or headers:\n//\n//\tcli.SetProxy(func(r *http.Request) (*url.URL, error) {\n//\t\tif r.URL.Host == \"web.whatsapp.com\" && r.URL.Path == \"/ws/chat\" {\n//\t\t\treturn websocketProxyURL, nil\n//\t\t} else {\n//\t\t\treturn mediaProxyURL, nil\n//\t\t}\n//\t})\nfunc (cli *Client) SetProxy(proxy Proxy, opts ...SetProxyOptions) {\n\tvar opt SetProxyOptions\n\tif len(opts) > 0 {\n\t\topt = opts[0]\n\t}\n\tif !opt.NoWebsocket {\n\t\tcli.proxy = proxy\n\t\tcli.socksProxy = nil\n\t}\n\tif !opt.NoMedia {\n\t\ttransport := cli.http.Transport.(*http.Transport)\n\t\ttransport.Proxy = proxy\n\t\ttransport.Dial = nil\n\t\ttransport.DialContext = nil\n\t}\n}\n\ntype SetProxyOptions struct {\n\t// If NoWebsocket is true, the proxy won't be used for the websocket\n\tNoWebsocket bool\n\t// If NoMedia is true, the proxy won't be used for media uploads/downloads\n\tNoMedia bool\n}\n\n// SetSOCKSProxy sets a SOCKS5 proxy to use for WhatsApp web websocket connections and media uploads/downloads.\n//\n// Same details as SetProxy apply, but using a different proxy for the websocket and media is not currently supported.\nfunc (cli *Client) SetSOCKSProxy(px proxy.Dialer, opts ...SetProxyOptions) {\n\tvar opt SetProxyOptions\n\tif len(opts) > 0 {\n\t\topt = opts[0]\n\t}\n\tif !opt.NoWebsocket {\n\t\tcli.socksProxy = px\n\t\tcli.proxy = nil\n\t}\n\tif !opt.NoMedia {\n\t\ttransport := cli.http.Transport.(*http.Transport)\n\t\ttransport.Proxy = nil\n\t\ttransport.Dial = cli.socksProxy.Dial\n\t\tcontextDialer, ok := cli.socksProxy.(proxy.ContextDialer)\n\t\tif ok {\n\t\t\ttransport.DialContext = contextDialer.DialContext\n\t\t} else {\n\t\t\ttransport.DialContext = nil\n\t\t}\n\t}\n}\n\n// ToggleProxyOnlyForLogin changes whether the proxy set with SetProxy or related methods\n// is only used for the pre-login websocket and not authenticated websockets.\nfunc (cli *Client) ToggleProxyOnlyForLogin(only bool) {\n\tcli.proxyOnlyLogin = only\n}\n\nfunc (cli *Client) getSocketWaitChan() <-chan struct{} {\n\tcli.socketLock.RLock()\n\tch := cli.socketWait\n\tcli.socketLock.RUnlock()\n\treturn ch\n}\n\nfunc (cli *Client) closeSocketWaitChan() {\n\tcli.socketLock.Lock()\n\tclose(cli.socketWait)\n\tcli.socketWait = make(chan struct{})\n\tcli.socketLock.Unlock()\n}\n\nfunc (cli *Client) getOwnID() types.JID {\n\tif cli == nil {\n\t\treturn types.EmptyJID\n\t}\n\tid := cli.Store.ID\n\tif id == nil {\n\t\treturn types.EmptyJID\n\t}\n\treturn *id\n}\n\nfunc (cli *Client) WaitForConnection(timeout time.Duration) bool {\n\tif cli == nil {\n\t\treturn false\n\t}\n\ttimeoutChan := time.After(timeout)\n\tcli.socketLock.RLock()\n\tfor cli.socket == nil || !cli.socket.IsConnected() || !cli.IsLoggedIn() {\n\t\tch := cli.socketWait\n\t\tcli.socketLock.RUnlock()\n\t\tselect {\n\t\tcase <-ch:\n\t\tcase <-timeoutChan:\n\t\t\treturn false\n\t\t}\n\t\tcli.socketLock.RLock()\n\t}\n\tcli.socketLock.RUnlock()\n\treturn true\n}\n\nfunc (cli *Client) SetWSDialer(dialer *websocket.Dialer) {\n\tcli.wsDialer = dialer\n}\n\n// Connect connects the client to the WhatsApp web websocket. After connection, it will either\n// authenticate if there's data in the device store, or emit a QREvent to set up a new link.\nfunc (cli *Client) Connect() error {\n\tif cli == nil {\n\t\treturn ErrClientIsNil\n\t}\n\tcli.socketLock.Lock()\n\tdefer cli.socketLock.Unlock()\n\tif cli.socket != nil {\n\t\tif !cli.socket.IsConnected() {\n\t\t\tcli.unlockedDisconnect()\n\t\t} else {\n\t\t\treturn ErrAlreadyConnected\n\t\t}\n\t}\n\n\tcli.resetExpectedDisconnect()\n\tvar wsDialer websocket.Dialer\n\tif cli.wsDialer != nil {\n\t\twsDialer = *cli.wsDialer\n\t} else if !cli.proxyOnlyLogin || cli.Store.ID == nil {\n\t\tif cli.proxy != nil {\n\t\t\twsDialer.Proxy = cli.proxy\n\t\t} else if cli.socksProxy != nil {\n\t\t\twsDialer.NetDial = cli.socksProxy.Dial\n\t\t\tcontextDialer, ok := cli.socksProxy.(proxy.ContextDialer)\n\t\t\tif ok {\n\t\t\t\twsDialer.NetDialContext = contextDialer.DialContext\n\t\t\t}\n\t\t}\n\t}\n\tfs := socket.NewFrameSocket(cli.Log.Sub(\"Socket\"), wsDialer)\n\tif cli.MessengerConfig != nil {\n\t\tfs.URL = cli.MessengerConfig.WebsocketURL\n\t\tfs.HTTPHeaders.Set(\"Origin\", cli.MessengerConfig.BaseURL)\n\t\tfs.HTTPHeaders.Set(\"User-Agent\", cli.MessengerConfig.UserAgent)\n\t\tfs.HTTPHeaders.Set(\"Cache-Control\", \"no-cache\")\n\t\tfs.HTTPHeaders.Set(\"Pragma\", \"no-cache\")\n\t\t//fs.HTTPHeaders.Set(\"Sec-Fetch-Dest\", \"empty\")\n\t\t//fs.HTTPHeaders.Set(\"Sec-Fetch-Mode\", \"websocket\")\n\t\t//fs.HTTPHeaders.Set(\"Sec-Fetch-Site\", \"cross-site\")\n\t}\n\tif err := fs.Connect(); err != nil {\n\t\tfs.Close(0)\n\t\treturn err\n\t} else if err = cli.doHandshake(fs, *keys.NewKeyPair()); err != nil {\n\t\tfs.Close(0)\n\t\treturn fmt.Errorf(\"noise handshake failed: %w\", err)\n\t}\n\tgo cli.keepAliveLoop(cli.socket.Context())\n\tgo cli.handlerQueueLoop(cli.socket.Context())\n\treturn nil\n}\n\n// IsLoggedIn returns true after the client is successfully connected and authenticated on WhatsApp.\nfunc (cli *Client) IsLoggedIn() bool {\n\treturn cli != nil && cli.isLoggedIn.Load()\n}\n\nfunc (cli *Client) onDisconnect(ns *socket.NoiseSocket, remote bool) {\n\tns.Stop(false)\n\tcli.socketLock.Lock()\n\tdefer cli.socketLock.Unlock()\n\tif cli.socket == ns {\n\t\tcli.socket = nil\n\t\tcli.clearResponseWaiters(xmlStreamEndNode)\n\t\tif !cli.isExpectedDisconnect() && remote {\n\t\t\tcli.Log.Debugf(\"Emitting Disconnected event\")\n\t\t\tgo cli.dispatchEvent(&events.Disconnected{})\n\t\t\tgo cli.autoReconnect()\n\t\t} else if remote {\n\t\t\tcli.Log.Debugf(\"OnDisconnect() called, but it was expected, so not emitting event\")\n\t\t} else {\n\t\t\tcli.Log.Debugf(\"OnDisconnect() called after manual disconnection\")\n\t\t}\n\t} else {\n\t\tcli.Log.Debugf(\"Ignoring OnDisconnect on different socket\")\n\t}\n}\n\nfunc (cli *Client) expectDisconnect() {\n\tcli.expectedDisconnect.Store(true)\n}\n\nfunc (cli *Client) resetExpectedDisconnect() {\n\tcli.expectedDisconnect.Store(false)\n}\n\nfunc (cli *Client) isExpectedDisconnect() bool {\n\treturn cli.expectedDisconnect.Load()\n}\n\nfunc (cli *Client) autoReconnect() {\n\tif !cli.EnableAutoReconnect || cli.Store.ID == nil {\n\t\treturn\n\t}\n\tfor {\n\t\tautoReconnectDelay := time.Duration(cli.AutoReconnectErrors) * 2 * time.Second\n\t\tcli.Log.Debugf(\"Automatically reconnecting after %v\", autoReconnectDelay)\n\t\tcli.AutoReconnectErrors++\n\t\ttime.Sleep(autoReconnectDelay)\n\t\terr := cli.Connect()\n\t\tif errors.Is(err, ErrAlreadyConnected) {\n\t\t\tcli.Log.Debugf(\"Connect() said we're already connected after autoreconnect sleep\")\n\t\t\treturn\n\t\t} else if err != nil {\n\t\t\tcli.Log.Errorf(\"Error reconnecting after autoreconnect sleep: %v\", err)\n\t\t\tif cli.AutoReconnectHook != nil && !cli.AutoReconnectHook(err) {\n\t\t\t\tcli.Log.Debugf(\"AutoReconnectHook returned false, not reconnecting\")\n\t\t\t\treturn\n\t\t\t}\n\t\t} else {\n\t\t\treturn\n\t\t}\n\t}\n}\n\n// IsConnected checks if the client is connected to the WhatsApp web websocket.\n// Note that this doesn't check if the client is authenticated. See the IsLoggedIn field for that.\nfunc (cli *Client) IsConnected() bool {\n\tif cli == nil {\n\t\treturn false\n\t}\n\tcli.socketLock.RLock()\n\tconnected := cli.socket != nil && cli.socket.IsConnected()\n\tcli.socketLock.RUnlock()\n\treturn connected\n}\n\n// Disconnect disconnects from the WhatsApp web websocket.\n//\n// This will not emit any events, the Disconnected event is only used when the\n// connection is closed by the server or a network error.\nfunc (cli *Client) Disconnect() {\n\tif cli == nil || cli.socket == nil {\n\t\treturn\n\t}\n\tcli.socketLock.Lock()\n\tcli.unlockedDisconnect()\n\tcli.socketLock.Unlock()\n}\n\n// Disconnect closes the websocket connection.\nfunc (cli *Client) unlockedDisconnect() {\n\tif cli.socket != nil {\n\t\tcli.socket.Stop(true)\n\t\tcli.socket = nil\n\t\tcli.clearResponseWaiters(xmlStreamEndNode)\n\t}\n}\n\n// Logout sends a request to unlink the device, then disconnects from the websocket and deletes the local device store.\n//\n// If the logout request fails, the disconnection and local data deletion will not happen either.\n// If an error is returned, but you want to force disconnect/clear data, call Client.Disconnect() and Client.Store.Delete() manually.\n//\n// Note that this will not emit any events. The LoggedOut event is only used for external logouts\n// (triggered by the user from the main device or by WhatsApp servers).\nfunc (cli *Client) Logout() error {\n\tif cli == nil {\n\t\treturn ErrClientIsNil\n\t} else if cli.MessengerConfig != nil {\n\t\treturn errors.New(\"can't logout with Messenger credentials\")\n\t}\n\townID := cli.getOwnID()\n\tif ownID.IsEmpty() {\n\t\treturn ErrNotLoggedIn\n\t}\n\t_, err := cli.sendIQ(infoQuery{\n\t\tNamespace: \"md\",\n\t\tType:      \"set\",\n\t\tTo:        types.ServerJID,\n\t\tContent: []waBinary.Node{{\n\t\t\tTag: \"remove-companion-device\",\n\t\t\tAttrs: waBinary.Attrs{\n\t\t\t\t\"jid\":    ownID,\n\t\t\t\t\"reason\": \"user_initiated\",\n\t\t\t},\n\t\t}},\n\t})\n\tif err != nil {\n\t\treturn fmt.Errorf(\"error sending logout request: %w\", err)\n\t}\n\tcli.Disconnect()\n\terr = cli.Store.Delete()\n\tif err != nil {\n\t\treturn fmt.Errorf(\"error deleting data from store: %w\", err)\n\t}\n\treturn nil\n}\n\n// AddEventHandler registers a new function to receive all events emitted by this client.\n//\n// The returned integer is the event handler ID, which can be passed to RemoveEventHandler to remove it.\n//\n// All registered event handlers will receive all events. You should use a type switch statement to\n// filter the events you want:\n//\n//\tfunc myEventHandler(evt interface{}) {\n//\t\tswitch v := evt.(type) {\n//\t\tcase *events.Message:\n//\t\t\tfmt.Println(\"Received a message!\")\n//\t\tcase *events.Receipt:\n//\t\t\tfmt.Println(\"Received a receipt!\")\n//\t\t}\n//\t}\n//\n// If you want to access the Client instance inside the event handler, the recommended way is to\n// wrap the whole handler in another struct:\n//\n//\ttype MyClient struct {\n//\t\tWAClient *whatsmeow.Client\n//\t\teventHandlerID uint32\n//\t}\n//\n//\tfunc (mycli *MyClient) register() {\n//\t\tmycli.eventHandlerID = mycli.WAClient.AddEventHandler(mycli.myEventHandler)\n//\t}\n//\n//\tfunc (mycli *MyClient) myEventHandler(evt interface{}) {\n//\t\t// Handle event and access mycli.WAClient\n//\t}\nfunc (cli *Client) AddEventHandler(handler EventHandler) uint32 {\n\tnextID := atomic.AddUint32(&nextHandlerID, 1)\n\tcli.eventHandlersLock.Lock()\n\tcli.eventHandlers = append(cli.eventHandlers, wrappedEventHandler{handler, nextID})\n\tcli.eventHandlersLock.Unlock()\n\treturn nextID\n}\n\n// RemoveEventHandler removes a previously registered event handler function.\n// If the function with the given ID is found, this returns true.\n//\n// N.B. Do not run this directly from an event handler. That would cause a deadlock because the\n// event dispatcher holds a read lock on the event handler list, and this method wants a write lock\n// on the same list. Instead run it in a goroutine:\n//\n//\tfunc (mycli *MyClient) myEventHandler(evt interface{}) {\n//\t\tif noLongerWantEvents {\n//\t\t\tgo mycli.WAClient.RemoveEventHandler(mycli.eventHandlerID)\n//\t\t}\n//\t}\nfunc (cli *Client) RemoveEventHandler(id uint32) bool {\n\tcli.eventHandlersLock.Lock()\n\tdefer cli.eventHandlersLock.Unlock()\n\tfor index := range cli.eventHandlers {\n\t\tif cli.eventHandlers[index].id == id {\n\t\t\tif index == 0 {\n\t\t\t\tcli.eventHandlers[0].fn = nil\n\t\t\t\tcli.eventHandlers = cli.eventHandlers[1:]\n\t\t\t\treturn true\n\t\t\t} else if index < len(cli.eventHandlers)-1 {\n\t\t\t\tcopy(cli.eventHandlers[index:], cli.eventHandlers[index+1:])\n\t\t\t}\n\t\t\tcli.eventHandlers[len(cli.eventHandlers)-1].fn = nil\n\t\t\tcli.eventHandlers = cli.eventHandlers[:len(cli.eventHandlers)-1]\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\n// RemoveEventHandlers removes all event handlers that have been registered with AddEventHandler\nfunc (cli *Client) RemoveEventHandlers() {\n\tcli.eventHandlersLock.Lock()\n\tcli.eventHandlers = make([]wrappedEventHandler, 0, 1)\n\tcli.eventHandlersLock.Unlock()\n}\n\nfunc (cli *Client) handleFrame(data []byte) {\n\tdecompressed, err := waBinary.Unpack(data)\n\tif err != nil {\n\t\tcli.Log.Warnf(\"Failed to decompress frame: %v\", err)\n\t\tcli.Log.Debugf(\"Errored frame hex: %s\", hex.EncodeToString(data))\n\t\treturn\n\t}\n\tnode, err := waBinary.Unmarshal(decompressed)\n\tif err != nil {\n\t\tcli.Log.Warnf(\"Failed to decode node in frame: %v\", err)\n\t\tcli.Log.Debugf(\"Errored frame hex: %s\", hex.EncodeToString(decompressed))\n\t\treturn\n\t}\n\tcli.recvLog.Debugf(\"%s\", node.XMLString())\n\tif node.Tag == \"xmlstreamend\" {\n\t\tif !cli.isExpectedDisconnect() {\n\t\t\tcli.Log.Warnf(\"Received stream end frame\")\n\t\t}\n\t\t// TODO should we do something else?\n\t} else if cli.receiveResponse(node) {\n\t\t// handled\n\t} else if _, ok := cli.nodeHandlers[node.Tag]; ok {\n\t\tselect {\n\t\tcase cli.handlerQueue <- node:\n\t\tdefault:\n\t\t\tcli.Log.Warnf(\"Handler queue is full, message ordering is no longer guaranteed\")\n\t\t\tgo func() {\n\t\t\t\tcli.handlerQueue <- node\n\t\t\t}()\n\t\t}\n\t} else if node.Tag != \"ack\" {\n\t\tcli.Log.Debugf(\"Didn't handle WhatsApp node %s\", node.Tag)\n\t}\n}\n\nfunc stopAndDrainTimer(timer *time.Timer) {\n\tif !timer.Stop() {\n\t\tselect {\n\t\tcase <-timer.C:\n\t\tdefault:\n\t\t}\n\t}\n}\n\nfunc (cli *Client) handlerQueueLoop(ctx context.Context) {\n\ttimer := time.NewTimer(5 * time.Minute)\n\tstopAndDrainTimer(timer)\n\tcli.Log.Debugf(\"Starting handler queue loop\")\n\tfor {\n\t\tselect {\n\t\tcase node := <-cli.handlerQueue:\n\t\t\tdoneChan := make(chan struct{}, 1)\n\t\t\tgo func() {\n\t\t\t\tstart := time.Now()\n\t\t\t\tcli.nodeHandlers[node.Tag](node)\n\t\t\t\tduration := time.Since(start)\n\t\t\t\tdoneChan <- struct{}{}\n\t\t\t\tif duration > 5*time.Second {\n\t\t\t\t\tcli.Log.Warnf(\"Node handling took %s for %s\", duration, node.XMLString())\n\t\t\t\t}\n\t\t\t}()\n\t\t\ttimer.Reset(5 * time.Minute)\n\t\t\tselect {\n\t\t\tcase <-doneChan:\n\t\t\t\tstopAndDrainTimer(timer)\n\t\t\tcase <-timer.C:\n\t\t\t\tcli.Log.Warnf(\"Node handling is taking long for %s - continuing in background\", node.XMLString())\n\t\t\t}\n\t\tcase <-ctx.Done():\n\t\t\tcli.Log.Debugf(\"Closing handler queue loop\")\n\t\t\treturn\n\t\t}\n\t}\n}\n\nfunc (cli *Client) sendNodeAndGetData(node waBinary.Node) ([]byte, error) {\n\tif cli == nil {\n\t\treturn nil, ErrClientIsNil\n\t}\n\tcli.socketLock.RLock()\n\tsock := cli.socket\n\tcli.socketLock.RUnlock()\n\tif sock == nil {\n\t\treturn nil, ErrNotConnected\n\t}\n\n\tpayload, err := waBinary.Marshal(node)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to marshal node: %w\", err)\n\t}\n\n\tcli.sendLog.Debugf(\"%s\", node.XMLString())\n\treturn payload, sock.SendFrame(payload)\n}\n\nfunc (cli *Client) sendNode(node waBinary.Node) error {\n\t_, err := cli.sendNodeAndGetData(node)\n\treturn err\n}\n\nfunc (cli *Client) dispatchEvent(evt interface{}) {\n\tcli.eventHandlersLock.RLock()\n\tdefer func() {\n\t\tcli.eventHandlersLock.RUnlock()\n\t\terr := recover()\n\t\tif err != nil {\n\t\t\tcli.Log.Errorf(\"Event handler panicked while handling a %T: %v\\n%s\", evt, err, debug.Stack())\n\t\t}\n\t}()\n\tfor _, handler := range cli.eventHandlers {\n\t\thandler.fn(evt)\n\t}\n}\n\n// ParseWebMessage parses a WebMessageInfo object into *events.Message to match what real-time messages have.\n//\n// The chat JID can be found in the Conversation data:\n//\n//\tchatJID, err := types.ParseJID(conv.GetId())\n//\tfor _, historyMsg := range conv.GetMessages() {\n//\t\tevt, err := cli.ParseWebMessage(chatJID, historyMsg.GetMessage())\n//\t\tyourNormalEventHandler(evt)\n//\t}\nfunc (cli *Client) ParseWebMessage(chatJID types.JID, webMsg *waWeb.WebMessageInfo) (*events.Message, error) {\n\tvar err error\n\tif chatJID.IsEmpty() {\n\t\tchatJID, err = types.ParseJID(webMsg.GetKey().GetRemoteJID())\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"no chat JID provided and failed to parse remote JID: %w\", err)\n\t\t}\n\t}\n\tinfo := types.MessageInfo{\n\t\tMessageSource: types.MessageSource{\n\t\t\tChat:     chatJID,\n\t\t\tIsFromMe: webMsg.GetKey().GetFromMe(),\n\t\t\tIsGroup:  chatJID.Server == types.GroupServer,\n\t\t},\n\t\tID:        webMsg.GetKey().GetID(),\n\t\tPushName:  webMsg.GetPushName(),\n\t\tTimestamp: time.Unix(int64(webMsg.GetMessageTimestamp()), 0),\n\t}\n\tif info.IsFromMe {\n\t\tinfo.Sender = cli.getOwnID().ToNonAD()\n\t\tif info.Sender.IsEmpty() {\n\t\t\treturn nil, ErrNotLoggedIn\n\t\t}\n\t} else if chatJID.Server == types.DefaultUserServer || chatJID.Server == types.NewsletterServer {\n\t\tinfo.Sender = chatJID\n\t} else if webMsg.GetParticipant() != \"\" {\n\t\tinfo.Sender, err = types.ParseJID(webMsg.GetParticipant())\n\t} else if webMsg.GetKey().GetParticipant() != \"\" {\n\t\tinfo.Sender, err = types.ParseJID(webMsg.GetKey().GetParticipant())\n\t} else {\n\t\treturn nil, fmt.Errorf(\"couldn't find sender of message %s\", info.ID)\n\t}\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to parse sender of message %s: %v\", info.ID, err)\n\t}\n\tevt := &events.Message{\n\t\tRawMessage:   webMsg.GetMessage(),\n\t\tSourceWebMsg: webMsg,\n\t\tInfo:         info,\n\t}\n\tevt.UnwrapRaw()\n\tif evt.Message.GetProtocolMessage().GetType() == waE2E.ProtocolMessage_MESSAGE_EDIT {\n\t\tevt.Info.ID = evt.Message.GetProtocolMessage().GetKey().GetID()\n\t\tevt.Message = evt.Message.GetProtocolMessage().GetEditedMessage()\n\t}\n\treturn evt, nil\n}\n"
        },
        {
          "name": "client_test.go",
          "type": "blob",
          "size": 2.2470703125,
          "content": "// Copyright (c) 2021 Tulir Asokan\n//\n// This Source Code Form is subject to the terms of the Mozilla Public\n// License, v. 2.0. If a copy of the MPL was not distributed with this\n// file, You can obtain one at http://mozilla.org/MPL/2.0/.\n\npackage whatsmeow_test\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"os\"\n\t\"os/signal\"\n\t\"syscall\"\n\n\t\"go.mau.fi/whatsmeow\"\n\t\"go.mau.fi/whatsmeow/store/sqlstore\"\n\t\"go.mau.fi/whatsmeow/types/events\"\n\twaLog \"go.mau.fi/whatsmeow/util/log\"\n)\n\nfunc eventHandler(evt interface{}) {\n\tswitch v := evt.(type) {\n\tcase *events.Message:\n\t\tfmt.Println(\"Received a message!\", v.Message.GetConversation())\n\t}\n}\n\nfunc Example() {\n\t// |------------------------------------------------------------------------------------------------------|\n\t// | NOTE: You must also import the appropriate DB connector, e.g. github.com/mattn/go-sqlite3 for SQLite |\n\t// |------------------------------------------------------------------------------------------------------|\n\n\tdbLog := waLog.Stdout(\"Database\", \"DEBUG\", true)\n\tcontainer, err := sqlstore.New(\"sqlite3\", \"file:examplestore.db?_foreign_keys=on\", dbLog)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\t// If you want multiple sessions, remember their JIDs and use .GetDevice(jid) or .GetAllDevices() instead.\n\tdeviceStore, err := container.GetFirstDevice()\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tclientLog := waLog.Stdout(\"Client\", \"DEBUG\", true)\n\tclient := whatsmeow.NewClient(deviceStore, clientLog)\n\tclient.AddEventHandler(eventHandler)\n\n\tif client.Store.ID == nil {\n\t\t// No ID stored, new login\n\t\tqrChan, _ := client.GetQRChannel(context.Background())\n\t\terr = client.Connect()\n\t\tif err != nil {\n\t\t\tpanic(err)\n\t\t}\n\t\tfor evt := range qrChan {\n\t\t\tif evt.Event == \"code\" {\n\t\t\t\t// Render the QR code here\n\t\t\t\t// e.g. qrterminal.GenerateHalfBlock(evt.Code, qrterminal.L, os.Stdout)\n\t\t\t\t// or just manually `echo 2@... | qrencode -t ansiutf8` in a terminal\n\t\t\t\tfmt.Println(\"QR code:\", evt.Code)\n\t\t\t} else {\n\t\t\t\tfmt.Println(\"Login event:\", evt.Event)\n\t\t\t}\n\t\t}\n\t} else {\n\t\t// Already logged in, just connect\n\t\terr = client.Connect()\n\t\tif err != nil {\n\t\t\tpanic(err)\n\t\t}\n\t}\n\n\t// Listen to Ctrl+C (you can also do something else that prevents the program from exiting)\n\tc := make(chan os.Signal, 1)\n\tsignal.Notify(c, os.Interrupt, syscall.SIGTERM)\n\t<-c\n\n\tclient.Disconnect()\n}\n"
        },
        {
          "name": "connectionevents.go",
          "type": "blob",
          "size": 7.197265625,
          "content": "// Copyright (c) 2021 Tulir Asokan\n//\n// This Source Code Form is subject to the terms of the Mozilla Public\n// License, v. 2.0. If a copy of the MPL was not distributed with this\n// file, You can obtain one at http://mozilla.org/MPL/2.0/.\n\npackage whatsmeow\n\nimport (\n\t\"time\"\n\n\twaBinary \"go.mau.fi/whatsmeow/binary\"\n\t\"go.mau.fi/whatsmeow/store\"\n\t\"go.mau.fi/whatsmeow/types\"\n\t\"go.mau.fi/whatsmeow/types/events\"\n)\n\nfunc (cli *Client) handleStreamError(node *waBinary.Node) {\n\tcli.isLoggedIn.Store(false)\n\tcli.clearResponseWaiters(node)\n\tcode, _ := node.Attrs[\"code\"].(string)\n\tconflict, _ := node.GetOptionalChildByTag(\"conflict\")\n\tconflictType := conflict.AttrGetter().OptionalString(\"type\")\n\tswitch {\n\tcase code == \"515\":\n\t\tif cli.DisableLoginAutoReconnect {\n\t\t\tcli.Log.Infof(\"Got 515 code, but login autoreconnect is disabled, not reconnecting\")\n\t\t\tcli.dispatchEvent(&events.ManualLoginReconnect{})\n\t\t\treturn\n\t\t}\n\t\tcli.Log.Infof(\"Got 515 code, reconnecting...\")\n\t\tgo func() {\n\t\t\tcli.Disconnect()\n\t\t\terr := cli.Connect()\n\t\t\tif err != nil {\n\t\t\t\tcli.Log.Errorf(\"Failed to reconnect after 515 code: %v\", err)\n\t\t\t}\n\t\t}()\n\tcase code == \"401\" && conflictType == \"device_removed\":\n\t\tcli.expectDisconnect()\n\t\tcli.Log.Infof(\"Got device removed stream error, sending LoggedOut event and deleting session\")\n\t\tgo cli.dispatchEvent(&events.LoggedOut{OnConnect: false, Reason: events.ConnectFailureLoggedOut})\n\t\terr := cli.Store.Delete()\n\t\tif err != nil {\n\t\t\tcli.Log.Warnf(\"Failed to delete store after device_removed error: %v\", err)\n\t\t}\n\tcase conflictType == \"replaced\":\n\t\tcli.expectDisconnect()\n\t\tcli.Log.Infof(\"Got replaced stream error, sending StreamReplaced event\")\n\t\tgo cli.dispatchEvent(&events.StreamReplaced{})\n\tcase code == \"503\":\n\t\t// This seems to happen when the server wants to restart or something.\n\t\t// The disconnection will be emitted as an events.Disconnected and then the auto-reconnect will do its thing.\n\t\tcli.Log.Warnf(\"Got 503 stream error, assuming automatic reconnect will handle it\")\n\tcase cli.RefreshCAT != nil && (code == events.ConnectFailureCATInvalid.NumberString() || code == events.ConnectFailureCATExpired.NumberString()):\n\t\tcli.Log.Infof(\"Got %s stream error, refreshing CAT before reconnecting...\", code)\n\t\tcli.socketLock.RLock()\n\t\tdefer cli.socketLock.RUnlock()\n\t\terr := cli.RefreshCAT()\n\t\tif err != nil {\n\t\t\tcli.Log.Errorf(\"Failed to refresh CAT: %v\", err)\n\t\t\tcli.expectDisconnect()\n\t\t\tgo cli.dispatchEvent(&events.CATRefreshError{Error: err})\n\t\t}\n\tdefault:\n\t\tcli.Log.Errorf(\"Unknown stream error: %s\", node.XMLString())\n\t\tgo cli.dispatchEvent(&events.StreamError{Code: code, Raw: node})\n\t}\n}\n\nfunc (cli *Client) handleIB(node *waBinary.Node) {\n\tchildren := node.GetChildren()\n\tfor _, child := range children {\n\t\tag := child.AttrGetter()\n\t\tswitch child.Tag {\n\t\tcase \"downgrade_webclient\":\n\t\t\tgo cli.dispatchEvent(&events.QRScannedWithoutMultidevice{})\n\t\tcase \"offline_preview\":\n\t\t\tcli.dispatchEvent(&events.OfflineSyncPreview{\n\t\t\t\tTotal:          ag.Int(\"count\"),\n\t\t\t\tAppDataChanges: ag.Int(\"appdata\"),\n\t\t\t\tMessages:       ag.Int(\"message\"),\n\t\t\t\tNotifications:  ag.Int(\"notification\"),\n\t\t\t\tReceipts:       ag.Int(\"receipt\"),\n\t\t\t})\n\t\tcase \"offline\":\n\t\t\tcli.dispatchEvent(&events.OfflineSyncCompleted{\n\t\t\t\tCount: ag.Int(\"count\"),\n\t\t\t})\n\t\t}\n\t}\n}\n\nfunc (cli *Client) handleConnectFailure(node *waBinary.Node) {\n\tag := node.AttrGetter()\n\treason := events.ConnectFailureReason(ag.Int(\"reason\"))\n\tmessage := ag.OptionalString(\"message\")\n\twillAutoReconnect := true\n\tswitch {\n\tdefault:\n\t\t// By default, expect a disconnect (i.e. prevent auto-reconnect)\n\t\tcli.expectDisconnect()\n\t\twillAutoReconnect = false\n\tcase reason == events.ConnectFailureServiceUnavailable:\n\t\t// Auto-reconnect for 503s\n\tcase reason == events.ConnectFailureCATInvalid || reason == events.ConnectFailureCATExpired:\n\t\t// Auto-reconnect when rotating CAT, lock socket to ensure refresh goes through before reconnect\n\t\tcli.socketLock.RLock()\n\t\tdefer cli.socketLock.RUnlock()\n\tcase reason == 500 && message == \"biz vname fetch error\":\n\t\t// These happen for business accounts randomly, also auto-reconnect\n\t}\n\tif reason == 403 {\n\t\tcli.Log.Debugf(\n\t\t\t\"Message for 403 connect failure: %s / %s\",\n\t\t\tag.OptionalString(\"logout_message_header\"),\n\t\t\tag.OptionalString(\"logout_message_subtext\"),\n\t\t)\n\t}\n\tif reason.IsLoggedOut() {\n\t\tcli.Log.Infof(\"Got %s connect failure, sending LoggedOut event and deleting session\", reason)\n\t\tgo cli.dispatchEvent(&events.LoggedOut{OnConnect: true, Reason: reason})\n\t\terr := cli.Store.Delete()\n\t\tif err != nil {\n\t\t\tcli.Log.Warnf(\"Failed to delete store after %d failure: %v\", int(reason), err)\n\t\t}\n\t} else if reason == events.ConnectFailureTempBanned {\n\t\tcli.Log.Warnf(\"Temporary ban connect failure: %s\", node.XMLString())\n\t\tgo cli.dispatchEvent(&events.TemporaryBan{\n\t\t\tCode:   events.TempBanReason(ag.Int(\"code\")),\n\t\t\tExpire: time.Duration(ag.Int(\"expire\")) * time.Second,\n\t\t})\n\t} else if reason == events.ConnectFailureClientOutdated {\n\t\tcli.Log.Errorf(\"Client outdated (405) connect failure (client version: %s)\", store.GetWAVersion().String())\n\t\tgo cli.dispatchEvent(&events.ClientOutdated{})\n\t} else if reason == events.ConnectFailureCATInvalid || reason == events.ConnectFailureCATExpired {\n\t\tcli.Log.Infof(\"Got %d/%s connect failure, refreshing CAT before reconnecting...\", int(reason), message)\n\t\terr := cli.RefreshCAT()\n\t\tif err != nil {\n\t\t\tcli.Log.Errorf(\"Failed to refresh CAT: %v\", err)\n\t\t\tcli.expectDisconnect()\n\t\t\tgo cli.dispatchEvent(&events.CATRefreshError{Error: err})\n\t\t}\n\t} else if willAutoReconnect {\n\t\tcli.Log.Warnf(\"Got %d/%s connect failure, assuming automatic reconnect will handle it\", int(reason), message)\n\t} else {\n\t\tcli.Log.Warnf(\"Unknown connect failure: %s\", node.XMLString())\n\t\tgo cli.dispatchEvent(&events.ConnectFailure{Reason: reason, Message: message, Raw: node})\n\t}\n}\n\nfunc (cli *Client) handleConnectSuccess(node *waBinary.Node) {\n\tcli.Log.Infof(\"Successfully authenticated\")\n\tcli.LastSuccessfulConnect = time.Now()\n\tcli.AutoReconnectErrors = 0\n\tcli.isLoggedIn.Store(true)\n\tgo func() {\n\t\tif dbCount, err := cli.Store.PreKeys.UploadedPreKeyCount(); err != nil {\n\t\t\tcli.Log.Errorf(\"Failed to get number of prekeys in database: %v\", err)\n\t\t} else if serverCount, err := cli.getServerPreKeyCount(); err != nil {\n\t\t\tcli.Log.Warnf(\"Failed to get number of prekeys on server: %v\", err)\n\t\t} else {\n\t\t\tcli.Log.Debugf(\"Database has %d prekeys, server says we have %d\", dbCount, serverCount)\n\t\t\tif serverCount < MinPreKeyCount || dbCount < MinPreKeyCount {\n\t\t\t\tcli.uploadPreKeys()\n\t\t\t\tsc, _ := cli.getServerPreKeyCount()\n\t\t\t\tcli.Log.Debugf(\"Prekey count after upload: %d\", sc)\n\t\t\t}\n\t\t}\n\t\terr := cli.SetPassive(false)\n\t\tif err != nil {\n\t\t\tcli.Log.Warnf(\"Failed to send post-connect passive IQ: %v\", err)\n\t\t}\n\t\tcli.dispatchEvent(&events.Connected{})\n\t\tcli.closeSocketWaitChan()\n\t}()\n}\n\n// SetPassive tells the WhatsApp server whether this device is passive or not.\n//\n// This seems to mostly affect whether the device receives certain events.\n// By default, whatsmeow will automatically do SetPassive(false) after connecting.\nfunc (cli *Client) SetPassive(passive bool) error {\n\ttag := \"active\"\n\tif passive {\n\t\ttag = \"passive\"\n\t}\n\t_, err := cli.sendIQ(infoQuery{\n\t\tNamespace: \"passive\",\n\t\tType:      \"set\",\n\t\tTo:        types.ServerJID,\n\t\tContent:   []waBinary.Node{{Tag: tag}},\n\t})\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}\n"
        },
        {
          "name": "download-to-file.go",
          "type": "blob",
          "size": 7.267578125,
          "content": "// Copyright (c) 2024 Tulir Asokan\n//\n// This Source Code Form is subject to the terms of the Mozilla Public\n// License, v. 2.0. If a copy of the MPL was not distributed with this\n// file, You can obtain one at http://mozilla.org/MPL/2.0/.\n\npackage whatsmeow\n\nimport (\n\t\"crypto/hmac\"\n\t\"crypto/sha256\"\n\t\"encoding/base64\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"os\"\n\t\"strings\"\n\t\"time\"\n\n\t\"go.mau.fi/util/fallocate\"\n\t\"go.mau.fi/util/retryafter\"\n\n\t\"go.mau.fi/whatsmeow/proto/waMediaTransport\"\n\t\"go.mau.fi/whatsmeow/util/cbcutil\"\n)\n\ntype File interface {\n\tio.Reader\n\tio.Writer\n\tio.Seeker\n\tio.ReaderAt\n\tio.WriterAt\n\tTruncate(size int64) error\n\tStat() (os.FileInfo, error)\n}\n\n// DownloadToFile downloads the attachment from the given protobuf message.\n//\n// This is otherwise identical to [Download], but writes the attachment to a file instead of returning it as a byte slice.\nfunc (cli *Client) DownloadToFile(msg DownloadableMessage, file File) error {\n\tmediaType := GetMediaType(msg)\n\tif mediaType == \"\" {\n\t\treturn fmt.Errorf(\"%w %T\", ErrUnknownMediaType, msg)\n\t}\n\turlable, ok := msg.(downloadableMessageWithURL)\n\tvar url string\n\tvar isWebWhatsappNetURL bool\n\tif ok {\n\t\turl = urlable.GetURL()\n\t\tisWebWhatsappNetURL = strings.HasPrefix(url, \"https://web.whatsapp.net\")\n\t}\n\tif len(url) > 0 && !isWebWhatsappNetURL {\n\t\treturn cli.downloadAndDecryptToFile(url, msg.GetMediaKey(), mediaType, getSize(msg), msg.GetFileEncSHA256(), msg.GetFileSHA256(), file)\n\t} else if len(msg.GetDirectPath()) > 0 {\n\t\treturn cli.DownloadMediaWithPathToFile(msg.GetDirectPath(), msg.GetFileEncSHA256(), msg.GetFileSHA256(), msg.GetMediaKey(), getSize(msg), mediaType, mediaTypeToMMSType[mediaType], file)\n\t} else {\n\t\tif isWebWhatsappNetURL {\n\t\t\tcli.Log.Warnf(\"Got a media message with a web.whatsapp.net URL (%s) and no direct path\", url)\n\t\t}\n\t\treturn ErrNoURLPresent\n\t}\n}\n\nfunc (cli *Client) DownloadFBToFile(transport *waMediaTransport.WAMediaTransport_Integral, mediaType MediaType, file File) error {\n\treturn cli.DownloadMediaWithPathToFile(transport.GetDirectPath(), transport.GetFileEncSHA256(), transport.GetFileSHA256(), transport.GetMediaKey(), -1, mediaType, mediaTypeToMMSType[mediaType], file)\n}\n\nfunc (cli *Client) DownloadMediaWithPathToFile(directPath string, encFileHash, fileHash, mediaKey []byte, fileLength int, mediaType MediaType, mmsType string, file File) error {\n\tmediaConn, err := cli.refreshMediaConn(false)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to refresh media connections: %w\", err)\n\t}\n\tif len(mmsType) == 0 {\n\t\tmmsType = mediaTypeToMMSType[mediaType]\n\t}\n\tfor i, host := range mediaConn.Hosts {\n\t\t// TODO omit hash for unencrypted media?\n\t\tmediaURL := fmt.Sprintf(\"https://%s%s&hash=%s&mms-type=%s&__wa-mms=\", host.Hostname, directPath, base64.URLEncoding.EncodeToString(encFileHash), mmsType)\n\t\terr = cli.downloadAndDecryptToFile(mediaURL, mediaKey, mediaType, fileLength, encFileHash, fileHash, file)\n\t\tif err == nil || errors.Is(err, ErrFileLengthMismatch) || errors.Is(err, ErrInvalidMediaSHA256) ||\n\t\t\terrors.Is(err, ErrMediaDownloadFailedWith403) || errors.Is(err, ErrMediaDownloadFailedWith404) || errors.Is(err, ErrMediaDownloadFailedWith410) {\n\t\t\treturn err\n\t\t} else if i >= len(mediaConn.Hosts)-1 {\n\t\t\treturn fmt.Errorf(\"failed to download media from last host: %w\", err)\n\t\t}\n\t\tcli.Log.Warnf(\"Failed to download media: %s, trying with next host...\", err)\n\t}\n\treturn err\n}\n\nfunc (cli *Client) downloadAndDecryptToFile(url string, mediaKey []byte, appInfo MediaType, fileLength int, fileEncSHA256, fileSHA256 []byte, file File) error {\n\tiv, cipherKey, macKey, _ := getMediaKeys(mediaKey, appInfo)\n\thasher := sha256.New()\n\tif mac, err := cli.downloadPossiblyEncryptedMediaWithRetriesToFile(url, fileEncSHA256, file); err != nil {\n\t\treturn err\n\t} else if mediaKey == nil && fileEncSHA256 == nil && mac == nil {\n\t\t// Unencrypted media, just return the downloaded data\n\t\treturn nil\n\t} else if err = validateMediaFile(file, iv, macKey, mac); err != nil {\n\t\treturn err\n\t} else if _, err = file.Seek(0, io.SeekStart); err != nil {\n\t\treturn fmt.Errorf(\"failed to seek to start of file after validating mac: %w\", err)\n\t} else if err = cbcutil.DecryptFile(cipherKey, iv, file); err != nil {\n\t\treturn fmt.Errorf(\"failed to decrypt file: %w\", err)\n\t} else if info, err := file.Stat(); err != nil {\n\t\treturn fmt.Errorf(\"failed to stat file: %w\", err)\n\t} else if info.Size() != int64(fileLength) {\n\t\treturn fmt.Errorf(\"%w: expected %d, got %d\", ErrFileLengthMismatch, fileLength, info.Size())\n\t} else if _, err = file.Seek(0, io.SeekStart); err != nil {\n\t\treturn fmt.Errorf(\"failed to seek to start of file after decrypting: %w\", err)\n\t} else if _, err = io.Copy(hasher, file); err != nil {\n\t\treturn fmt.Errorf(\"failed to hash file: %w\", err)\n\t} else if !hmac.Equal(fileSHA256, hasher.Sum(nil)) {\n\t\treturn ErrInvalidMediaSHA256\n\t}\n\treturn nil\n}\n\nfunc (cli *Client) downloadPossiblyEncryptedMediaWithRetriesToFile(url string, checksum []byte, file File) (mac []byte, err error) {\n\tfor retryNum := 0; retryNum < 5; retryNum++ {\n\t\tif checksum == nil {\n\t\t\t_, _, err = cli.downloadMediaToFile(url, file)\n\t\t} else {\n\t\t\tmac, err = cli.downloadEncryptedMediaToFile(url, checksum, file)\n\t\t}\n\t\tif err == nil || !shouldRetryMediaDownload(err) {\n\t\t\treturn\n\t\t}\n\t\tretryDuration := time.Duration(retryNum+1) * time.Second\n\t\tvar httpErr DownloadHTTPError\n\t\tif errors.As(err, &httpErr) {\n\t\t\tretryDuration = retryafter.Parse(httpErr.Response.Header.Get(\"Retry-After\"), retryDuration)\n\t\t}\n\t\tcli.Log.Warnf(\"Failed to download media due to network error: %v, retrying in %s...\", err, retryDuration)\n\t\t_, err = file.Seek(0, io.SeekStart)\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"failed to seek to start of file to retry download: %w\", err)\n\t\t}\n\t\ttime.Sleep(retryDuration)\n\t}\n\treturn\n}\n\nfunc (cli *Client) downloadMediaToFile(url string, file io.Writer) (int64, []byte, error) {\n\tresp, err := cli.doMediaDownloadRequest(url)\n\tif err != nil {\n\t\treturn 0, nil, err\n\t}\n\tdefer resp.Body.Close()\n\tosFile, ok := file.(*os.File)\n\tif ok && resp.ContentLength > 0 {\n\t\terr = fallocate.Fallocate(osFile, int(resp.ContentLength))\n\t\tif err != nil {\n\t\t\treturn 0, nil, fmt.Errorf(\"failed to preallocate file: %w\", err)\n\t\t}\n\t}\n\thasher := sha256.New()\n\tn, err := io.Copy(file, io.TeeReader(resp.Body, hasher))\n\treturn n, hasher.Sum(nil), err\n}\n\nfunc (cli *Client) downloadEncryptedMediaToFile(url string, checksum []byte, file File) ([]byte, error) {\n\tsize, hash, err := cli.downloadMediaToFile(url, file)\n\tif err != nil {\n\t\treturn nil, err\n\t} else if size <= mediaHMACLength {\n\t\treturn nil, ErrTooShortFile\n\t} else if len(checksum) == 32 && !hmac.Equal(checksum, hash) {\n\t\treturn nil, ErrInvalidMediaEncSHA256\n\t}\n\tmac := make([]byte, mediaHMACLength)\n\t_, err = file.ReadAt(mac, size-mediaHMACLength)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to read MAC from file: %w\", err)\n\t}\n\terr = file.Truncate(size - mediaHMACLength)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to truncate file to remove MAC: %w\", err)\n\t}\n\treturn mac, nil\n}\n\nfunc validateMediaFile(file io.ReadSeeker, iv, macKey, mac []byte) error {\n\th := hmac.New(sha256.New, macKey)\n\th.Write(iv)\n\t_, err := file.Seek(0, io.SeekStart)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to seek to start of file: %w\", err)\n\t}\n\t_, err = io.Copy(h, file)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to hash file: %w\", err)\n\t}\n\tif !hmac.Equal(h.Sum(nil)[:mediaHMACLength], mac) {\n\t\treturn ErrInvalidMediaHMAC\n\t}\n\treturn nil\n}\n"
        },
        {
          "name": "download.go",
          "type": "blob",
          "size": 12.3759765625,
          "content": "// Copyright (c) 2021 Tulir Asokan\n//\n// This Source Code Form is subject to the terms of the Mozilla Public\n// License, v. 2.0. If a copy of the MPL was not distributed with this\n// file, You can obtain one at http://mozilla.org/MPL/2.0/.\n\npackage whatsmeow\n\nimport (\n\t\"crypto/hmac\"\n\t\"crypto/sha256\"\n\t\"encoding/base64\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"net\"\n\t\"net/http\"\n\t\"strings\"\n\t\"time\"\n\n\t\"go.mau.fi/util/retryafter\"\n\t\"google.golang.org/protobuf/proto\"\n\t\"google.golang.org/protobuf/reflect/protoreflect\"\n\n\twaProto \"go.mau.fi/whatsmeow/binary/proto\"\n\t\"go.mau.fi/whatsmeow/proto/waMediaTransport\"\n\t\"go.mau.fi/whatsmeow/socket\"\n\t\"go.mau.fi/whatsmeow/util/cbcutil\"\n\t\"go.mau.fi/whatsmeow/util/hkdfutil\"\n)\n\n// MediaType represents a type of uploaded file on WhatsApp.\n// The value is the key which is used as a part of generating the encryption keys.\ntype MediaType string\n\n// The known media types\nconst (\n\tMediaImage    MediaType = \"WhatsApp Image Keys\"\n\tMediaVideo    MediaType = \"WhatsApp Video Keys\"\n\tMediaAudio    MediaType = \"WhatsApp Audio Keys\"\n\tMediaDocument MediaType = \"WhatsApp Document Keys\"\n\tMediaHistory  MediaType = \"WhatsApp History Keys\"\n\tMediaAppState MediaType = \"WhatsApp App State Keys\"\n\n\tMediaLinkThumbnail MediaType = \"WhatsApp Link Thumbnail Keys\"\n)\n\n// DownloadableMessage represents a protobuf message that contains attachment info.\n//\n// All of the downloadable messages inside a Message struct implement this interface\n// (ImageMessage, VideoMessage, AudioMessage, DocumentMessage, StickerMessage).\ntype DownloadableMessage interface {\n\tGetDirectPath() string\n\tGetMediaKey() []byte\n\tGetFileSHA256() []byte\n\tGetFileEncSHA256() []byte\n}\n\ntype MediaTypeable interface {\n\tGetMediaType() MediaType\n}\n\n// DownloadableThumbnail represents a protobuf message that contains a thumbnail attachment.\n//\n// This is primarily meant for link preview thumbnails in ExtendedTextMessage.\ntype DownloadableThumbnail interface {\n\tproto.Message\n\tGetThumbnailDirectPath() string\n\tGetThumbnailSHA256() []byte\n\tGetThumbnailEncSHA256() []byte\n\tGetMediaKey() []byte\n}\n\n// All the message types that are intended to be downloadable\nvar (\n\t_ DownloadableMessage   = (*waProto.ImageMessage)(nil)\n\t_ DownloadableMessage   = (*waProto.AudioMessage)(nil)\n\t_ DownloadableMessage   = (*waProto.VideoMessage)(nil)\n\t_ DownloadableMessage   = (*waProto.DocumentMessage)(nil)\n\t_ DownloadableMessage   = (*waProto.StickerMessage)(nil)\n\t_ DownloadableMessage   = (*waProto.StickerMetadata)(nil)\n\t_ DownloadableMessage   = (*waProto.HistorySyncNotification)(nil)\n\t_ DownloadableMessage   = (*waProto.ExternalBlobReference)(nil)\n\t_ DownloadableThumbnail = (*waProto.ExtendedTextMessage)(nil)\n)\n\ntype downloadableMessageWithLength interface {\n\tDownloadableMessage\n\tGetFileLength() uint64\n}\n\ntype downloadableMessageWithSizeBytes interface {\n\tDownloadableMessage\n\tGetFileSizeBytes() uint64\n}\n\ntype downloadableMessageWithURL interface {\n\tDownloadableMessage\n\tGetURL() string\n}\n\nvar classToMediaType = map[protoreflect.Name]MediaType{\n\t\"ImageMessage\":    MediaImage,\n\t\"AudioMessage\":    MediaAudio,\n\t\"VideoMessage\":    MediaVideo,\n\t\"DocumentMessage\": MediaDocument,\n\t\"StickerMessage\":  MediaImage,\n\t\"StickerMetadata\": MediaImage,\n\n\t\"HistorySyncNotification\": MediaHistory,\n\t\"ExternalBlobReference\":   MediaAppState,\n}\n\nvar classToThumbnailMediaType = map[protoreflect.Name]MediaType{\n\t\"ExtendedTextMessage\": MediaLinkThumbnail,\n}\n\nvar mediaTypeToMMSType = map[MediaType]string{\n\tMediaImage:    \"image\",\n\tMediaAudio:    \"audio\",\n\tMediaVideo:    \"video\",\n\tMediaDocument: \"document\",\n\tMediaHistory:  \"md-msg-hist\",\n\tMediaAppState: \"md-app-state\",\n\n\tMediaLinkThumbnail: \"thumbnail-link\",\n}\n\n// DownloadAny loops through the downloadable parts of the given message and downloads the first non-nil item.\nfunc (cli *Client) DownloadAny(msg *waProto.Message) (data []byte, err error) {\n\tif msg == nil {\n\t\treturn nil, ErrNothingDownloadableFound\n\t}\n\tswitch {\n\tcase msg.ImageMessage != nil:\n\t\treturn cli.Download(msg.ImageMessage)\n\tcase msg.VideoMessage != nil:\n\t\treturn cli.Download(msg.VideoMessage)\n\tcase msg.AudioMessage != nil:\n\t\treturn cli.Download(msg.AudioMessage)\n\tcase msg.DocumentMessage != nil:\n\t\treturn cli.Download(msg.DocumentMessage)\n\tcase msg.StickerMessage != nil:\n\t\treturn cli.Download(msg.StickerMessage)\n\tdefault:\n\t\treturn nil, ErrNothingDownloadableFound\n\t}\n}\n\nfunc getSize(msg DownloadableMessage) int {\n\tswitch sized := msg.(type) {\n\tcase downloadableMessageWithLength:\n\t\treturn int(sized.GetFileLength())\n\tcase downloadableMessageWithSizeBytes:\n\t\treturn int(sized.GetFileSizeBytes())\n\tdefault:\n\t\treturn -1\n\t}\n}\n\n// DownloadThumbnail downloads a thumbnail from a message.\n//\n// This is primarily intended for downloading link preview thumbnails, which are in ExtendedTextMessage:\n//\n//\tvar msg *waProto.Message\n//\t...\n//\tthumbnailImageBytes, err := cli.DownloadThumbnail(msg.GetExtendedTextMessage())\nfunc (cli *Client) DownloadThumbnail(msg DownloadableThumbnail) ([]byte, error) {\n\tmediaType, ok := classToThumbnailMediaType[msg.ProtoReflect().Descriptor().Name()]\n\tif !ok {\n\t\treturn nil, fmt.Errorf(\"%w '%s'\", ErrUnknownMediaType, string(msg.ProtoReflect().Descriptor().Name()))\n\t} else if len(msg.GetThumbnailDirectPath()) > 0 {\n\t\treturn cli.DownloadMediaWithPath(msg.GetThumbnailDirectPath(), msg.GetThumbnailEncSHA256(), msg.GetThumbnailSHA256(), msg.GetMediaKey(), -1, mediaType, mediaTypeToMMSType[mediaType])\n\t} else {\n\t\treturn nil, ErrNoURLPresent\n\t}\n}\n\n// GetMediaType returns the MediaType value corresponding to the given protobuf message.\nfunc GetMediaType(msg DownloadableMessage) MediaType {\n\tprotoReflecter, ok := msg.(proto.Message)\n\tif !ok {\n\t\tmediaTypeable, ok := msg.(MediaTypeable)\n\t\tif !ok {\n\t\t\treturn \"\"\n\t\t}\n\t\treturn mediaTypeable.GetMediaType()\n\t}\n\treturn classToMediaType[protoReflecter.ProtoReflect().Descriptor().Name()]\n}\n\n// Download downloads the attachment from the given protobuf message.\n//\n// The attachment is a specific part of a Message protobuf struct, not the message itself, e.g.\n//\n//\tvar msg *waProto.Message\n//\t...\n//\timageData, err := cli.Download(msg.GetImageMessage())\n//\n// You can also use DownloadAny to download the first non-nil sub-message.\nfunc (cli *Client) Download(msg DownloadableMessage) ([]byte, error) {\n\tmediaType := GetMediaType(msg)\n\tif mediaType == \"\" {\n\t\treturn nil, fmt.Errorf(\"%w %T\", ErrUnknownMediaType, msg)\n\t}\n\turlable, ok := msg.(downloadableMessageWithURL)\n\tvar url string\n\tvar isWebWhatsappNetURL bool\n\tif ok {\n\t\turl = urlable.GetURL()\n\t\tisWebWhatsappNetURL = strings.HasPrefix(url, \"https://web.whatsapp.net\")\n\t}\n\tif len(url) > 0 && !isWebWhatsappNetURL {\n\t\treturn cli.downloadAndDecrypt(url, msg.GetMediaKey(), mediaType, getSize(msg), msg.GetFileEncSHA256(), msg.GetFileSHA256())\n\t} else if len(msg.GetDirectPath()) > 0 {\n\t\treturn cli.DownloadMediaWithPath(msg.GetDirectPath(), msg.GetFileEncSHA256(), msg.GetFileSHA256(), msg.GetMediaKey(), getSize(msg), mediaType, mediaTypeToMMSType[mediaType])\n\t} else {\n\t\tif isWebWhatsappNetURL {\n\t\t\tcli.Log.Warnf(\"Got a media message with a web.whatsapp.net URL (%s) and no direct path\", url)\n\t\t}\n\t\treturn nil, ErrNoURLPresent\n\t}\n}\n\nfunc (cli *Client) DownloadFB(transport *waMediaTransport.WAMediaTransport_Integral, mediaType MediaType) ([]byte, error) {\n\treturn cli.DownloadMediaWithPath(transport.GetDirectPath(), transport.GetFileEncSHA256(), transport.GetFileSHA256(), transport.GetMediaKey(), -1, mediaType, mediaTypeToMMSType[mediaType])\n}\n\n// DownloadMediaWithPath downloads an attachment by manually specifying the path and encryption details.\nfunc (cli *Client) DownloadMediaWithPath(directPath string, encFileHash, fileHash, mediaKey []byte, fileLength int, mediaType MediaType, mmsType string) (data []byte, err error) {\n\tvar mediaConn *MediaConn\n\tmediaConn, err = cli.refreshMediaConn(false)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to refresh media connections: %w\", err)\n\t}\n\tif len(mmsType) == 0 {\n\t\tmmsType = mediaTypeToMMSType[mediaType]\n\t}\n\tfor i, host := range mediaConn.Hosts {\n\t\t// TODO omit hash for unencrypted media?\n\t\tmediaURL := fmt.Sprintf(\"https://%s%s&hash=%s&mms-type=%s&__wa-mms=\", host.Hostname, directPath, base64.URLEncoding.EncodeToString(encFileHash), mmsType)\n\t\tdata, err = cli.downloadAndDecrypt(mediaURL, mediaKey, mediaType, fileLength, encFileHash, fileHash)\n\t\tif err == nil || errors.Is(err, ErrFileLengthMismatch) || errors.Is(err, ErrInvalidMediaSHA256) ||\n\t\t\terrors.Is(err, ErrMediaDownloadFailedWith403) || errors.Is(err, ErrMediaDownloadFailedWith404) || errors.Is(err, ErrMediaDownloadFailedWith410) {\n\t\t\treturn\n\t\t} else if i >= len(mediaConn.Hosts)-1 {\n\t\t\treturn nil, fmt.Errorf(\"failed to download media from last host: %w\", err)\n\t\t}\n\t\tcli.Log.Warnf(\"Failed to download media: %s, trying with next host...\", err)\n\t}\n\treturn\n}\n\nfunc (cli *Client) downloadAndDecrypt(url string, mediaKey []byte, appInfo MediaType, fileLength int, fileEncSHA256, fileSHA256 []byte) (data []byte, err error) {\n\tiv, cipherKey, macKey, _ := getMediaKeys(mediaKey, appInfo)\n\tvar ciphertext, mac []byte\n\tif ciphertext, mac, err = cli.downloadPossiblyEncryptedMediaWithRetries(url, fileEncSHA256); err != nil {\n\n\t} else if mediaKey == nil && fileEncSHA256 == nil && mac == nil {\n\t\t// Unencrypted media, just return the downloaded data\n\t\tdata = ciphertext\n\t} else if err = validateMedia(iv, ciphertext, macKey, mac); err != nil {\n\n\t} else if data, err = cbcutil.Decrypt(cipherKey, iv, ciphertext); err != nil {\n\t\terr = fmt.Errorf(\"failed to decrypt file: %w\", err)\n\t} else if fileLength >= 0 && len(data) != fileLength {\n\t\terr = fmt.Errorf(\"%w: expected %d, got %d\", ErrFileLengthMismatch, fileLength, len(data))\n\t} else if len(fileSHA256) == 32 && sha256.Sum256(data) != *(*[32]byte)(fileSHA256) {\n\t\terr = ErrInvalidMediaSHA256\n\t}\n\treturn\n}\n\nfunc getMediaKeys(mediaKey []byte, appInfo MediaType) (iv, cipherKey, macKey, refKey []byte) {\n\tmediaKeyExpanded := hkdfutil.SHA256(mediaKey, nil, []byte(appInfo), 112)\n\treturn mediaKeyExpanded[:16], mediaKeyExpanded[16:48], mediaKeyExpanded[48:80], mediaKeyExpanded[80:]\n}\n\nfunc shouldRetryMediaDownload(err error) bool {\n\tvar netErr net.Error\n\tvar httpErr DownloadHTTPError\n\treturn errors.As(err, &netErr) ||\n\t\tstrings.HasPrefix(err.Error(), \"stream error:\") || // hacky check for http2 errors\n\t\t(errors.As(err, &httpErr) && retryafter.Should(httpErr.StatusCode, true))\n}\n\nfunc (cli *Client) downloadPossiblyEncryptedMediaWithRetries(url string, checksum []byte) (file, mac []byte, err error) {\n\tfor retryNum := 0; retryNum < 5; retryNum++ {\n\t\tif checksum == nil {\n\t\t\tfile, err = cli.downloadMedia(url)\n\t\t} else {\n\t\t\tfile, mac, err = cli.downloadEncryptedMedia(url, checksum)\n\t\t}\n\t\tif err == nil || !shouldRetryMediaDownload(err) {\n\t\t\treturn\n\t\t}\n\t\tretryDuration := time.Duration(retryNum+1) * time.Second\n\t\tvar httpErr DownloadHTTPError\n\t\tif errors.As(err, &httpErr) {\n\t\t\tretryDuration = retryafter.Parse(httpErr.Response.Header.Get(\"Retry-After\"), retryDuration)\n\t\t}\n\t\tcli.Log.Warnf(\"Failed to download media due to network error: %v, retrying in %s...\", err, retryDuration)\n\t\ttime.Sleep(retryDuration)\n\t}\n\treturn\n}\n\nfunc (cli *Client) doMediaDownloadRequest(url string) (*http.Response, error) {\n\treq, err := http.NewRequest(http.MethodGet, url, nil)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to prepare request: %w\", err)\n\t}\n\treq.Header.Set(\"Origin\", socket.Origin)\n\treq.Header.Set(\"Referer\", socket.Origin+\"/\")\n\tif cli.MessengerConfig != nil {\n\t\treq.Header.Set(\"User-Agent\", cli.MessengerConfig.UserAgent)\n\t}\n\t// TODO user agent for whatsapp downloads?\n\tresp, err := cli.http.Do(req)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif resp.StatusCode != http.StatusOK {\n\t\t_ = resp.Body.Close()\n\t\treturn nil, DownloadHTTPError{Response: resp}\n\t}\n\treturn resp, nil\n}\n\nfunc (cli *Client) downloadMedia(url string) ([]byte, error) {\n\tresp, err := cli.doMediaDownloadRequest(url)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdata, err := io.ReadAll(resp.Body)\n\t_ = resp.Body.Close()\n\treturn data, err\n}\n\nconst mediaHMACLength = 10\n\nfunc (cli *Client) downloadEncryptedMedia(url string, checksum []byte) (file, mac []byte, err error) {\n\tdata, err := cli.downloadMedia(url)\n\tif err != nil {\n\t\treturn\n\t} else if len(data) <= mediaHMACLength {\n\t\terr = ErrTooShortFile\n\t\treturn\n\t}\n\tfile, mac = data[:len(data)-mediaHMACLength], data[len(data)-mediaHMACLength:]\n\tif len(checksum) == 32 && sha256.Sum256(data) != *(*[32]byte)(checksum) {\n\t\terr = ErrInvalidMediaEncSHA256\n\t}\n\treturn\n}\n\nfunc validateMedia(iv, file, macKey, mac []byte) error {\n\th := hmac.New(sha256.New, macKey)\n\th.Write(iv)\n\th.Write(file)\n\tif !hmac.Equal(h.Sum(nil)[:mediaHMACLength], mac) {\n\t\treturn ErrInvalidMediaHMAC\n\t}\n\treturn nil\n}\n"
        },
        {
          "name": "errors.go",
          "type": "blob",
          "size": 10.5,
          "content": "// Copyright (c) 2021 Tulir Asokan\n//\n// This Source Code Form is subject to the terms of the Mozilla Public\n// License, v. 2.0. If a copy of the MPL was not distributed with this\n// file, You can obtain one at http://mozilla.org/MPL/2.0/.\n\npackage whatsmeow\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"net/http\"\n\n\twaBinary \"go.mau.fi/whatsmeow/binary\"\n)\n\n// Miscellaneous errors\nvar (\n\tErrClientIsNil     = errors.New(\"client is nil\")\n\tErrNoSession       = errors.New(\"can't encrypt message for device: no signal session established\")\n\tErrIQTimedOut      = errors.New(\"info query timed out\")\n\tErrNotConnected    = errors.New(\"websocket not connected\")\n\tErrNotLoggedIn     = errors.New(\"the store doesn't contain a device JID\")\n\tErrMessageTimedOut = errors.New(\"timed out waiting for message send response\")\n\n\tErrAlreadyConnected = errors.New(\"websocket is already connected\")\n\n\tErrQRAlreadyConnected = errors.New(\"GetQRChannel must be called before connecting\")\n\tErrQRStoreContainsID  = errors.New(\"GetQRChannel can only be called when there's no user ID in the client's Store\")\n\n\tErrNoPushName = errors.New(\"can't send presence without PushName set\")\n\n\tErrNoPrivacyToken = errors.New(\"no privacy token stored\")\n\n\tErrAppStateUpdate = errors.New(\"server returned error updating app state\")\n)\n\n// Errors that happen while confirming device pairing\nvar (\n\tErrPairInvalidDeviceIdentityHMAC = errors.New(\"invalid device identity HMAC in pair success message\")\n\tErrPairInvalidDeviceSignature    = errors.New(\"invalid device signature in pair success message\")\n\tErrPairRejectedLocally           = errors.New(\"local PrePairCallback rejected pairing\")\n)\n\n// PairProtoError is included in an events.PairError if the pairing failed due to a protobuf error.\ntype PairProtoError struct {\n\tMessage  string\n\tProtoErr error\n}\n\nfunc (err *PairProtoError) Error() string {\n\treturn fmt.Sprintf(\"%s: %v\", err.Message, err.ProtoErr)\n}\n\nfunc (err *PairProtoError) Unwrap() error {\n\treturn err.ProtoErr\n}\n\n// PairDatabaseError is included in an events.PairError if the pairing failed due to being unable to save the credentials to the device store.\ntype PairDatabaseError struct {\n\tMessage string\n\tDBErr   error\n}\n\nfunc (err *PairDatabaseError) Error() string {\n\treturn fmt.Sprintf(\"%s: %v\", err.Message, err.DBErr)\n}\n\nfunc (err *PairDatabaseError) Unwrap() error {\n\treturn err.DBErr\n}\n\nvar (\n\t// ErrProfilePictureUnauthorized is returned by GetProfilePictureInfo when trying to get the profile picture of a user\n\t// whose privacy settings prevent you from seeing their profile picture (status code 401).\n\tErrProfilePictureUnauthorized = errors.New(\"the user has hidden their profile picture from you\")\n\t// ErrProfilePictureNotSet is returned by GetProfilePictureInfo when the given user or group doesn't have a profile\n\t// picture (status code 404).\n\tErrProfilePictureNotSet = errors.New(\"that user or group does not have a profile picture\")\n\t// ErrGroupInviteLinkUnauthorized is returned by GetGroupInviteLink if you don't have the permission to get the link (status code 401).\n\tErrGroupInviteLinkUnauthorized = errors.New(\"you don't have the permission to get the group's invite link\")\n\t// ErrNotInGroup is returned by group info getting methods if you're not in the group (status code 403).\n\tErrNotInGroup = errors.New(\"you're not participating in that group\")\n\t// ErrGroupNotFound is returned by group info getting methods if the group doesn't exist (status code 404).\n\tErrGroupNotFound = errors.New(\"that group does not exist\")\n\t// ErrInviteLinkInvalid is returned by methods that use group invite links if the invite link is malformed.\n\tErrInviteLinkInvalid = errors.New(\"that group invite link is not valid\")\n\t// ErrInviteLinkRevoked is returned by methods that use group invite links if the invite link was valid, but has been revoked and can no longer be used.\n\tErrInviteLinkRevoked = errors.New(\"that group invite link has been revoked\")\n\t// ErrBusinessMessageLinkNotFound is returned by ResolveBusinessMessageLink if the link doesn't exist or has been revoked.\n\tErrBusinessMessageLinkNotFound = errors.New(\"that business message link does not exist or has been revoked\")\n\t// ErrContactQRLinkNotFound is returned by ResolveContactQRLink if the link doesn't exist or has been revoked.\n\tErrContactQRLinkNotFound = errors.New(\"that contact QR link does not exist or has been revoked\")\n\t// ErrInvalidImageFormat is returned by SetGroupPhoto if the given photo is not in the correct format.\n\tErrInvalidImageFormat = errors.New(\"the given data is not a valid image\")\n\t// ErrMediaNotAvailableOnPhone is returned by DecryptMediaRetryNotification if the given event contains error code 2.\n\tErrMediaNotAvailableOnPhone = errors.New(\"media no longer available on phone\")\n\t// ErrUnknownMediaRetryError is returned by DecryptMediaRetryNotification if the given event contains an unknown error code.\n\tErrUnknownMediaRetryError = errors.New(\"unknown media retry error\")\n\t// ErrInvalidDisappearingTimer is returned by SetDisappearingTimer if the given timer is not one of the allowed values.\n\tErrInvalidDisappearingTimer = errors.New(\"invalid disappearing timer provided\")\n)\n\n// Some errors that Client.SendMessage can return\nvar (\n\tErrBroadcastListUnsupported = errors.New(\"sending to non-status broadcast lists is not yet supported\")\n\tErrUnknownServer            = errors.New(\"can't send message to unknown server\")\n\tErrRecipientADJID           = errors.New(\"message recipient must be a user JID with no device part\")\n\tErrServerReturnedError      = errors.New(\"server returned error\")\n\tErrInvalidInlineBotID       = errors.New(\"invalid inline bot ID\")\n)\n\ntype DownloadHTTPError struct {\n\t*http.Response\n}\n\nfunc (dhe DownloadHTTPError) Error() string {\n\treturn fmt.Sprintf(\"download failed with status code %d\", dhe.StatusCode)\n}\n\nfunc (dhe DownloadHTTPError) Is(other error) bool {\n\tvar otherDHE DownloadHTTPError\n\treturn errors.As(other, &otherDHE) && dhe.StatusCode == otherDHE.StatusCode\n}\n\n// Some errors that Client.Download can return\nvar (\n\tErrMediaDownloadFailedWith403 = DownloadHTTPError{Response: &http.Response{StatusCode: 403}}\n\tErrMediaDownloadFailedWith404 = DownloadHTTPError{Response: &http.Response{StatusCode: 404}}\n\tErrMediaDownloadFailedWith410 = DownloadHTTPError{Response: &http.Response{StatusCode: 410}}\n\tErrNoURLPresent               = errors.New(\"no url present\")\n\tErrFileLengthMismatch         = errors.New(\"file length does not match\")\n\tErrTooShortFile               = errors.New(\"file too short\")\n\tErrInvalidMediaHMAC           = errors.New(\"invalid media hmac\")\n\tErrInvalidMediaEncSHA256      = errors.New(\"hash of media ciphertext doesn't match\")\n\tErrInvalidMediaSHA256         = errors.New(\"hash of media plaintext doesn't match\")\n\tErrUnknownMediaType           = errors.New(\"unknown media type\")\n\tErrNothingDownloadableFound   = errors.New(\"didn't find any attachments in message\")\n)\n\nvar (\n\tErrOriginalMessageSecretNotFound = errors.New(\"original message secret key not found\")\n\tErrNotEncryptedReactionMessage   = errors.New(\"given message isn't an encrypted reaction message\")\n\tErrNotPollUpdateMessage          = errors.New(\"given message isn't a poll update message\")\n)\n\ntype wrappedIQError struct {\n\tHumanError error\n\tIQError    error\n}\n\nfunc (err *wrappedIQError) Error() string {\n\treturn err.HumanError.Error()\n}\n\nfunc (err *wrappedIQError) Is(other error) bool {\n\treturn errors.Is(other, err.HumanError)\n}\n\nfunc (err *wrappedIQError) Unwrap() error {\n\treturn err.IQError\n}\n\nfunc wrapIQError(human, iq error) error {\n\treturn &wrappedIQError{human, iq}\n}\n\n// IQError is a generic error container for info queries\ntype IQError struct {\n\tCode      int\n\tText      string\n\tErrorNode *waBinary.Node\n\tRawNode   *waBinary.Node\n}\n\n// Common errors returned by info queries for use with errors.Is\nvar (\n\tErrIQBadRequest          error = &IQError{Code: 400, Text: \"bad-request\"}\n\tErrIQNotAuthorized       error = &IQError{Code: 401, Text: \"not-authorized\"}\n\tErrIQForbidden           error = &IQError{Code: 403, Text: \"forbidden\"}\n\tErrIQNotFound            error = &IQError{Code: 404, Text: \"item-not-found\"}\n\tErrIQNotAllowed          error = &IQError{Code: 405, Text: \"not-allowed\"}\n\tErrIQNotAcceptable       error = &IQError{Code: 406, Text: \"not-acceptable\"}\n\tErrIQGone                error = &IQError{Code: 410, Text: \"gone\"}\n\tErrIQResourceLimit       error = &IQError{Code: 419, Text: \"resource-limit\"}\n\tErrIQLocked              error = &IQError{Code: 423, Text: \"locked\"}\n\tErrIQRateOverLimit       error = &IQError{Code: 429, Text: \"rate-overlimit\"}\n\tErrIQInternalServerError error = &IQError{Code: 500, Text: \"internal-server-error\"}\n\tErrIQServiceUnavailable  error = &IQError{Code: 503, Text: \"service-unavailable\"}\n\tErrIQPartialServerError  error = &IQError{Code: 530, Text: \"partial-server-error\"}\n)\n\nfunc parseIQError(node *waBinary.Node) error {\n\tvar err IQError\n\terr.RawNode = node\n\tval, ok := node.GetOptionalChildByTag(\"error\")\n\tif ok {\n\t\terr.ErrorNode = &val\n\t\tag := val.AttrGetter()\n\t\terr.Code = ag.OptionalInt(\"code\")\n\t\terr.Text = ag.OptionalString(\"text\")\n\t}\n\treturn &err\n}\n\nfunc (iqe *IQError) Error() string {\n\tif iqe.Code == 0 {\n\t\tif iqe.ErrorNode != nil {\n\t\t\treturn fmt.Sprintf(\"info query returned unknown error: %s\", iqe.ErrorNode.XMLString())\n\t\t} else if iqe.RawNode != nil {\n\t\t\treturn fmt.Sprintf(\"info query returned unexpected response: %s\", iqe.RawNode.XMLString())\n\t\t} else {\n\t\t\treturn \"unknown info query error\"\n\t\t}\n\t}\n\treturn fmt.Sprintf(\"info query returned status %d: %s\", iqe.Code, iqe.Text)\n}\n\nfunc (iqe *IQError) Is(other error) bool {\n\totherIQE, ok := other.(*IQError)\n\tif !ok {\n\t\treturn false\n\t} else if iqe.Code != 0 && otherIQE.Code != 0 {\n\t\treturn otherIQE.Code == iqe.Code && otherIQE.Text == iqe.Text\n\t} else if iqe.ErrorNode != nil && otherIQE.ErrorNode != nil {\n\t\treturn iqe.ErrorNode.XMLString() == otherIQE.ErrorNode.XMLString()\n\t} else {\n\t\treturn false\n\t}\n}\n\n// ElementMissingError is returned by various functions that parse XML elements when a required element is missing.\ntype ElementMissingError struct {\n\tTag string\n\tIn  string\n}\n\nfunc (eme *ElementMissingError) Error() string {\n\treturn fmt.Sprintf(\"missing <%s> element in %s\", eme.Tag, eme.In)\n}\n\nvar ErrIQDisconnected = &DisconnectedError{Action: \"info query\"}\n\n// DisconnectedError is returned if the websocket disconnects before an info query or other request gets a response.\ntype DisconnectedError struct {\n\tAction string\n\tNode   *waBinary.Node\n}\n\nfunc (err *DisconnectedError) Error() string {\n\treturn fmt.Sprintf(\"websocket disconnected before %s returned response\", err.Action)\n}\n\nfunc (err *DisconnectedError) Is(other error) bool {\n\totherDisc, ok := other.(*DisconnectedError)\n\tif !ok {\n\t\treturn false\n\t}\n\treturn otherDisc.Action == err.Action\n}\n"
        },
        {
          "name": "go.mod",
          "type": "blob",
          "size": 0.494140625,
          "content": "module go.mau.fi/whatsmeow\n\ngo 1.22.0\n\ntoolchain go1.23.4\n\nrequire (\n\tgithub.com/google/uuid v1.6.0\n\tgithub.com/gorilla/websocket v1.5.0\n\tgithub.com/rs/zerolog v1.33.0\n\tgo.mau.fi/libsignal v0.1.1\n\tgo.mau.fi/util v0.8.3\n\tgolang.org/x/crypto v0.31.0\n\tgolang.org/x/net v0.33.0\n\tgoogle.golang.org/protobuf v1.36.1\n)\n\nrequire (\n\tfilippo.io/edwards25519 v1.1.0 // indirect\n\tgithub.com/mattn/go-colorable v0.1.13 // indirect\n\tgithub.com/mattn/go-isatty v0.0.19 // indirect\n\tgolang.org/x/sys v0.28.0 // indirect\n)\n"
        },
        {
          "name": "go.sum",
          "type": "blob",
          "size": 3.6328125,
          "content": "filippo.io/edwards25519 v1.1.0 h1:FNf4tywRC1HmFuKW5xopWpigGjJKiJSV0Cqo0cJWDaA=\nfilippo.io/edwards25519 v1.1.0/go.mod h1:BxyFTGdWcka3PhytdK4V28tE5sGfRvvvRV7EaN4VDT4=\ngithub.com/coreos/go-systemd/v22 v22.5.0/go.mod h1:Y58oyj3AT4RCenI/lSvhwexgC+NSVTIJ3seZv2GcEnc=\ngithub.com/davecgh/go-spew v1.1.1 h1:vj9j/u1bqnvCEfJOwUhtlOARqs3+rkHYY13jYWTU97c=\ngithub.com/davecgh/go-spew v1.1.1/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=\ngithub.com/godbus/dbus/v5 v5.0.4/go.mod h1:xhWf0FNVPg57R7Z0UbKHbJfkEywrmjJnf7w5xrFpKfA=\ngithub.com/google/go-cmp v0.5.5 h1:Khx7svrCpmxxtHBq5j2mp/xVjsi8hQMfNLvJFAlrGgU=\ngithub.com/google/go-cmp v0.5.5/go.mod h1:v8dTdLbMG2kIc/vJvl+f65V22dbkXbowE6jgT/gNBxE=\ngithub.com/google/uuid v1.6.0 h1:NIvaJDMOsjHA8n1jAhLSgzrAzy1Hgr+hNrb57e+94F0=\ngithub.com/google/uuid v1.6.0/go.mod h1:TIyPZe4MgqvfeYDBFedMoGGpEw/LqOeaOT+nhxU+yHo=\ngithub.com/gorilla/websocket v1.5.0 h1:PPwGk2jz7EePpoHN/+ClbZu8SPxiqlu12wZP/3sWmnc=\ngithub.com/gorilla/websocket v1.5.0/go.mod h1:YR8l580nyteQvAITg2hZ9XVh4b55+EU/adAjf1fMHhE=\ngithub.com/mattn/go-colorable v0.1.13 h1:fFA4WZxdEF4tXPZVKMLwD8oUnCTTo08duU7wxecdEvA=\ngithub.com/mattn/go-colorable v0.1.13/go.mod h1:7S9/ev0klgBDR4GtXTXX8a3vIGJpMovkB8vQcUbaXHg=\ngithub.com/mattn/go-isatty v0.0.16/go.mod h1:kYGgaQfpe5nmfYZH+SKPsOc2e4SrIfOl2e/yFXSvRLM=\ngithub.com/mattn/go-isatty v0.0.19 h1:JITubQf0MOLdlGRuRq+jtsDlekdYPia9ZFsB8h/APPA=\ngithub.com/mattn/go-isatty v0.0.19/go.mod h1:W+V8PltTTMOvKvAeJH7IuucS94S2C6jfK/D7dTCTo3Y=\ngithub.com/pkg/errors v0.9.1/go.mod h1:bwawxfHBFNV+L2hUp1rHADufV3IMtnDRdf1r5NINEl0=\ngithub.com/pmezard/go-difflib v1.0.0 h1:4DBwDE0NGyQoBHbLQYPwSUPoCMWR5BEzIk/f1lZbAQM=\ngithub.com/pmezard/go-difflib v1.0.0/go.mod h1:iKH77koFhYxTK1pcRnkKkqfTogsbg7gZNVY4sRDYZ/4=\ngithub.com/rs/xid v1.5.0/go.mod h1:trrq9SKmegXys3aeAKXMUTdJsYXVwGY3RLcfgqegfbg=\ngithub.com/rs/zerolog v1.33.0 h1:1cU2KZkvPxNyfgEmhHAz/1A9Bz+llsdYzklWFzgp0r8=\ngithub.com/rs/zerolog v1.33.0/go.mod h1:/7mN4D5sKwJLZQ2b/znpjC3/GQWY/xaDXUM0kKWRHss=\ngithub.com/stretchr/testify v1.10.0 h1:Xv5erBjTwe/5IxqUQTdXv5kgmIvbHo3QQyRwhJsOfJA=\ngithub.com/stretchr/testify v1.10.0/go.mod h1:r2ic/lqez/lEtzL7wO/rwa5dbSLXVDPFyf8C91i36aY=\ngo.mau.fi/libsignal v0.1.1 h1:m/0PGBh4QKP/I1MQ44ti4C0fMbLMuHb95cmDw01FIpI=\ngo.mau.fi/libsignal v0.1.1/go.mod h1:QLs89F/OA3ThdSL2Wz2p+o+fi8uuQUz0e1BRa6ExdBw=\ngo.mau.fi/util v0.8.3 h1:sulhXtfquMrQjsOP67x9CzWVBYUwhYeoo8hNQIpCWZ4=\ngo.mau.fi/util v0.8.3/go.mod h1:c00Db8xog70JeIsEvhdHooylTkTkakgnAOsZ04hplQY=\ngolang.org/x/crypto v0.31.0 h1:ihbySMvVjLAeSH1IbfcRTkD/iNscyz8rGzjF/E5hV6U=\ngolang.org/x/crypto v0.31.0/go.mod h1:kDsLvtWBEx7MV9tJOj9bnXsPbxwJQ6csT/x4KIN4Ssk=\ngolang.org/x/net v0.33.0 h1:74SYHlV8BIgHIFC/LrYkOGIwL19eTYXQ5wc6TBuO36I=\ngolang.org/x/net v0.33.0/go.mod h1:HXLR5J+9DxmrqMwG9qjGCxZ+zKXxBru04zlTvWlWuN4=\ngolang.org/x/sys v0.0.0-20220811171246-fbc7d0a398ab/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\ngolang.org/x/sys v0.6.0/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\ngolang.org/x/sys v0.12.0/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\ngolang.org/x/sys v0.28.0 h1:Fksou7UEQUWlKvIdsqzJmUmCX3cZuD2+P3XyyzwMhlA=\ngolang.org/x/sys v0.28.0/go.mod h1:/VUhepiaJMQUp4+oa/7Zr1D23ma6VTLIYjOOTFZPUcA=\ngolang.org/x/xerrors v0.0.0-20191204190536-9bdfabe68543 h1:E7g+9GITq07hpfrRu66IVDexMakfv52eLZ2CXBWiKr4=\ngolang.org/x/xerrors v0.0.0-20191204190536-9bdfabe68543/go.mod h1:I/5z698sn9Ka8TeJc9MKroUUfqBBauWjQqLJ2OPfmY0=\ngoogle.golang.org/protobuf v1.36.1 h1:yBPeRvTftaleIgM3PZ/WBIZ7XM/eEYAaEyCwvyjq/gk=\ngoogle.golang.org/protobuf v1.36.1/go.mod h1:9fA7Ob0pmnwhb644+1+CVWFRbNajQ6iRojtC/QF5bRE=\ngopkg.in/yaml.v3 v3.0.1 h1:fxVm/GzAzEWqLHuvctI91KS9hhNmmWOoWu0XTYJS7CA=\ngopkg.in/yaml.v3 v3.0.1/go.mod h1:K4uyk7z7BCEPqu6E+C64Yfv1cQ7kz7rIZviUmN+EgEM=\n"
        },
        {
          "name": "group.go",
          "type": "blob",
          "size": 29.890625,
          "content": "// Copyright (c) 2021 Tulir Asokan\n//\n// This Source Code Form is subject to the terms of the Mozilla Public\n// License, v. 2.0. If a copy of the MPL was not distributed with this\n// file, You can obtain one at http://mozilla.org/MPL/2.0/.\n\npackage whatsmeow\n\nimport (\n\t\"context\"\n\t\"errors\"\n\t\"fmt\"\n\t\"strings\"\n\n\twaBinary \"go.mau.fi/whatsmeow/binary\"\n\t\"go.mau.fi/whatsmeow/types\"\n\t\"go.mau.fi/whatsmeow/types/events\"\n)\n\nconst InviteLinkPrefix = \"https://chat.whatsapp.com/\"\n\nfunc (cli *Client) sendGroupIQ(ctx context.Context, iqType infoQueryType, jid types.JID, content waBinary.Node) (*waBinary.Node, error) {\n\treturn cli.sendIQ(infoQuery{\n\t\tContext:   ctx,\n\t\tNamespace: \"w:g2\",\n\t\tType:      iqType,\n\t\tTo:        jid,\n\t\tContent:   []waBinary.Node{content},\n\t})\n}\n\n// ReqCreateGroup contains the request data for CreateGroup.\ntype ReqCreateGroup struct {\n\t// Group names are limited to 25 characters. A longer group name will cause a 406 not acceptable error.\n\tName string\n\t// You don't need to include your own JID in the participants array, the WhatsApp servers will add it implicitly.\n\tParticipants []types.JID\n\t// A create key can be provided to deduplicate the group create notification that will be triggered\n\t// when the group is created. If provided, the JoinedGroup event will contain the same key.\n\tCreateKey types.MessageID\n\t// Set IsParent to true to create a community instead of a normal group.\n\t// When creating a community, the linked announcement group will be created automatically by the server.\n\ttypes.GroupParent\n\t// Set LinkedParentJID to create a group inside a community.\n\ttypes.GroupLinkedParent\n}\n\n// CreateGroup creates a group on WhatsApp with the given name and participants.\n//\n// See ReqCreateGroup for parameters.\nfunc (cli *Client) CreateGroup(req ReqCreateGroup) (*types.GroupInfo, error) {\n\tparticipantNodes := make([]waBinary.Node, len(req.Participants), len(req.Participants)+1)\n\tfor i, participant := range req.Participants {\n\t\tparticipantNodes[i] = waBinary.Node{\n\t\t\tTag:   \"participant\",\n\t\t\tAttrs: waBinary.Attrs{\"jid\": participant},\n\t\t}\n\t}\n\tif req.CreateKey == \"\" {\n\t\treq.CreateKey = cli.GenerateMessageID()\n\t}\n\tif req.IsParent {\n\t\tif req.DefaultMembershipApprovalMode == \"\" {\n\t\t\treq.DefaultMembershipApprovalMode = \"request_required\"\n\t\t}\n\t\tparticipantNodes = append(participantNodes, waBinary.Node{\n\t\t\tTag: \"parent\",\n\t\t\tAttrs: waBinary.Attrs{\n\t\t\t\t\"default_membership_approval_mode\": req.DefaultMembershipApprovalMode,\n\t\t\t},\n\t\t})\n\t} else if !req.LinkedParentJID.IsEmpty() {\n\t\tparticipantNodes = append(participantNodes, waBinary.Node{\n\t\t\tTag:   \"linked_parent\",\n\t\t\tAttrs: waBinary.Attrs{\"jid\": req.LinkedParentJID},\n\t\t})\n\t}\n\t// WhatsApp web doesn't seem to include the static prefix for these\n\tkey := strings.TrimPrefix(req.CreateKey, \"3EB0\")\n\tresp, err := cli.sendGroupIQ(context.TODO(), iqSet, types.GroupServerJID, waBinary.Node{\n\t\tTag: \"create\",\n\t\tAttrs: waBinary.Attrs{\n\t\t\t\"subject\": req.Name,\n\t\t\t\"key\":     key,\n\t\t},\n\t\tContent: participantNodes,\n\t})\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tgroupNode, ok := resp.GetOptionalChildByTag(\"group\")\n\tif !ok {\n\t\treturn nil, &ElementMissingError{Tag: \"group\", In: \"response to create group query\"}\n\t}\n\treturn cli.parseGroupNode(&groupNode)\n}\n\n// UnlinkGroup removes a child group from a parent community.\nfunc (cli *Client) UnlinkGroup(parent, child types.JID) error {\n\t_, err := cli.sendGroupIQ(context.TODO(), iqSet, parent, waBinary.Node{\n\t\tTag:   \"unlink\",\n\t\tAttrs: waBinary.Attrs{\"unlink_type\": string(types.GroupLinkChangeTypeSub)},\n\t\tContent: []waBinary.Node{{\n\t\t\tTag:   \"group\",\n\t\t\tAttrs: waBinary.Attrs{\"jid\": child},\n\t\t}},\n\t})\n\treturn err\n}\n\n// LinkGroup adds an existing group as a child group in a community.\n//\n// To create a new group within a community, set LinkedParentJID in the CreateGroup request.\nfunc (cli *Client) LinkGroup(parent, child types.JID) error {\n\t_, err := cli.sendGroupIQ(context.TODO(), iqSet, parent, waBinary.Node{\n\t\tTag: \"links\",\n\t\tContent: []waBinary.Node{{\n\t\t\tTag:   \"link\",\n\t\t\tAttrs: waBinary.Attrs{\"link_type\": string(types.GroupLinkChangeTypeSub)},\n\t\t\tContent: []waBinary.Node{{\n\t\t\t\tTag:   \"group\",\n\t\t\t\tAttrs: waBinary.Attrs{\"jid\": child},\n\t\t\t}},\n\t\t}},\n\t})\n\treturn err\n}\n\n// LeaveGroup leaves the specified group on WhatsApp.\nfunc (cli *Client) LeaveGroup(jid types.JID) error {\n\t_, err := cli.sendGroupIQ(context.TODO(), iqSet, types.GroupServerJID, waBinary.Node{\n\t\tTag: \"leave\",\n\t\tContent: []waBinary.Node{{\n\t\t\tTag:   \"group\",\n\t\t\tAttrs: waBinary.Attrs{\"id\": jid},\n\t\t}},\n\t})\n\treturn err\n}\n\ntype ParticipantChange string\n\nconst (\n\tParticipantChangeAdd     ParticipantChange = \"add\"\n\tParticipantChangeRemove  ParticipantChange = \"remove\"\n\tParticipantChangePromote ParticipantChange = \"promote\"\n\tParticipantChangeDemote  ParticipantChange = \"demote\"\n)\n\n// UpdateGroupParticipants can be used to add, remove, promote and demote members in a WhatsApp group.\nfunc (cli *Client) UpdateGroupParticipants(jid types.JID, participantChanges []types.JID, action ParticipantChange) ([]types.GroupParticipant, error) {\n\tcontent := make([]waBinary.Node, len(participantChanges))\n\tfor i, participantJID := range participantChanges {\n\t\tcontent[i] = waBinary.Node{\n\t\t\tTag:   \"participant\",\n\t\t\tAttrs: waBinary.Attrs{\"jid\": participantJID},\n\t\t}\n\t}\n\tresp, err := cli.sendGroupIQ(context.TODO(), iqSet, jid, waBinary.Node{\n\t\tTag:     string(action),\n\t\tContent: content,\n\t})\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\trequestAction, ok := resp.GetOptionalChildByTag(string(action))\n\tif !ok {\n\t\treturn nil, &ElementMissingError{Tag: string(action), In: \"response to group participants update\"}\n\t}\n\trequestParticipants := requestAction.GetChildrenByTag(\"participant\")\n\tparticipants := make([]types.GroupParticipant, len(requestParticipants))\n\tfor i, child := range requestParticipants {\n\t\tparticipants[i] = parseParticipant(child.AttrGetter(), &child)\n\t}\n\treturn participants, nil\n}\n\n// GetGroupRequestParticipants gets the list of participants that have requested to join the group.\nfunc (cli *Client) GetGroupRequestParticipants(jid types.JID) ([]types.JID, error) {\n\tresp, err := cli.sendGroupIQ(context.TODO(), iqGet, jid, waBinary.Node{\n\t\tTag: \"membership_approval_requests\",\n\t})\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\trequest, ok := resp.GetOptionalChildByTag(\"membership_approval_requests\")\n\tif !ok {\n\t\treturn nil, &ElementMissingError{Tag: \"membership_approval_requests\", In: \"response to group request participants query\"}\n\t}\n\trequestParticipants := request.GetChildrenByTag(\"membership_approval_request\")\n\tparticipants := make([]types.JID, len(requestParticipants))\n\tfor i, req := range requestParticipants {\n\t\tparticipants[i] = req.AttrGetter().JID(\"jid\")\n\t}\n\treturn participants, nil\n}\n\ntype ParticipantRequestChange string\n\nconst (\n\tParticipantChangeApprove ParticipantRequestChange = \"approve\"\n\tParticipantChangeReject  ParticipantRequestChange = \"reject\"\n)\n\n// UpdateGroupRequestParticipants can be used to approve or reject requests to join the group.\nfunc (cli *Client) UpdateGroupRequestParticipants(jid types.JID, participantChanges []types.JID, action ParticipantRequestChange) ([]types.GroupParticipant, error) {\n\tcontent := make([]waBinary.Node, len(participantChanges))\n\tfor i, participantJID := range participantChanges {\n\t\tcontent[i] = waBinary.Node{\n\t\t\tTag:   \"participant\",\n\t\t\tAttrs: waBinary.Attrs{\"jid\": participantJID},\n\t\t}\n\t}\n\tresp, err := cli.sendGroupIQ(context.TODO(), iqSet, jid, waBinary.Node{\n\t\tTag: \"membership_requests_action\",\n\t\tContent: []waBinary.Node{{\n\t\t\tTag:     string(action),\n\t\t\tContent: content,\n\t\t}},\n\t})\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\trequest, ok := resp.GetOptionalChildByTag(\"membership_requests_action\")\n\tif !ok {\n\t\treturn nil, &ElementMissingError{Tag: \"membership_requests_action\", In: \"response to group request participants update\"}\n\t}\n\trequestAction, ok := request.GetOptionalChildByTag(string(action))\n\tif !ok {\n\t\treturn nil, &ElementMissingError{Tag: string(action), In: \"response to group request participants update\"}\n\t}\n\trequestParticipants := requestAction.GetChildrenByTag(\"participant\")\n\tparticipants := make([]types.GroupParticipant, len(requestParticipants))\n\tfor i, child := range requestParticipants {\n\t\tparticipants[i] = parseParticipant(child.AttrGetter(), &child)\n\t}\n\treturn participants, nil\n}\n\n// SetGroupPhoto updates the group picture/icon of the given group on WhatsApp.\n// The avatar should be a JPEG photo, other formats may be rejected with ErrInvalidImageFormat.\n// The bytes can be nil to remove the photo. Returns the new picture ID.\nfunc (cli *Client) SetGroupPhoto(jid types.JID, avatar []byte) (string, error) {\n\tvar content interface{}\n\tif avatar != nil {\n\t\tcontent = []waBinary.Node{{\n\t\t\tTag:     \"picture\",\n\t\t\tAttrs:   waBinary.Attrs{\"type\": \"image\"},\n\t\t\tContent: avatar,\n\t\t}}\n\t}\n\tresp, err := cli.sendIQ(infoQuery{\n\t\tNamespace: \"w:profile:picture\",\n\t\tType:      iqSet,\n\t\tTo:        types.ServerJID,\n\t\tTarget:    jid,\n\t\tContent:   content,\n\t})\n\tif errors.Is(err, ErrIQNotAcceptable) {\n\t\treturn \"\", wrapIQError(ErrInvalidImageFormat, err)\n\t} else if err != nil {\n\t\treturn \"\", err\n\t}\n\tif avatar == nil {\n\t\treturn \"remove\", nil\n\t}\n\tpictureID, ok := resp.GetChildByTag(\"picture\").Attrs[\"id\"].(string)\n\tif !ok {\n\t\treturn \"\", fmt.Errorf(\"didn't find picture ID in response\")\n\t}\n\treturn pictureID, nil\n}\n\n// SetGroupName updates the name (subject) of the given group on WhatsApp.\nfunc (cli *Client) SetGroupName(jid types.JID, name string) error {\n\t_, err := cli.sendGroupIQ(context.TODO(), iqSet, jid, waBinary.Node{\n\t\tTag:     \"subject\",\n\t\tContent: []byte(name),\n\t})\n\treturn err\n}\n\n// SetGroupTopic updates the topic (description) of the given group on WhatsApp.\n//\n// The previousID and newID fields are optional. If the previous ID is not specified, this will\n// automatically fetch the current group info to find the previous topic ID. If the new ID is not\n// specified, one will be generated with Client.GenerateMessageID().\nfunc (cli *Client) SetGroupTopic(jid types.JID, previousID, newID, topic string) error {\n\tif previousID == \"\" {\n\t\toldInfo, err := cli.GetGroupInfo(jid)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"failed to get old group info to update topic: %v\", err)\n\t\t}\n\t\tpreviousID = oldInfo.TopicID\n\t}\n\tif newID == \"\" {\n\t\tnewID = cli.GenerateMessageID()\n\t}\n\tattrs := waBinary.Attrs{\n\t\t\"id\": newID,\n\t}\n\tif previousID != \"\" {\n\t\tattrs[\"prev\"] = previousID\n\t}\n\tcontent := []waBinary.Node{{\n\t\tTag:     \"body\",\n\t\tContent: []byte(topic),\n\t}}\n\tif len(topic) == 0 {\n\t\tattrs[\"delete\"] = \"true\"\n\t\tcontent = nil\n\t}\n\t_, err := cli.sendGroupIQ(context.TODO(), iqSet, jid, waBinary.Node{\n\t\tTag:     \"description\",\n\t\tAttrs:   attrs,\n\t\tContent: content,\n\t})\n\treturn err\n}\n\n// SetGroupLocked changes whether the group is locked (i.e. whether only admins can modify group info).\nfunc (cli *Client) SetGroupLocked(jid types.JID, locked bool) error {\n\ttag := \"locked\"\n\tif !locked {\n\t\ttag = \"unlocked\"\n\t}\n\t_, err := cli.sendGroupIQ(context.TODO(), iqSet, jid, waBinary.Node{Tag: tag})\n\treturn err\n}\n\n// SetGroupAnnounce changes whether the group is in announce mode (i.e. whether only admins can send messages).\nfunc (cli *Client) SetGroupAnnounce(jid types.JID, announce bool) error {\n\ttag := \"announcement\"\n\tif !announce {\n\t\ttag = \"not_announcement\"\n\t}\n\t_, err := cli.sendGroupIQ(context.TODO(), iqSet, jid, waBinary.Node{Tag: tag})\n\treturn err\n}\n\n// GetGroupInviteLink requests the invite link to the group from the WhatsApp servers.\n//\n// If reset is true, then the old invite link will be revoked and a new one generated.\nfunc (cli *Client) GetGroupInviteLink(jid types.JID, reset bool) (string, error) {\n\tiqType := iqGet\n\tif reset {\n\t\tiqType = iqSet\n\t}\n\tresp, err := cli.sendGroupIQ(context.TODO(), iqType, jid, waBinary.Node{Tag: \"invite\"})\n\tif errors.Is(err, ErrIQNotAuthorized) {\n\t\treturn \"\", wrapIQError(ErrGroupInviteLinkUnauthorized, err)\n\t} else if errors.Is(err, ErrIQNotFound) {\n\t\treturn \"\", wrapIQError(ErrGroupNotFound, err)\n\t} else if errors.Is(err, ErrIQForbidden) {\n\t\treturn \"\", wrapIQError(ErrNotInGroup, err)\n\t} else if err != nil {\n\t\treturn \"\", err\n\t}\n\tcode, ok := resp.GetChildByTag(\"invite\").Attrs[\"code\"].(string)\n\tif !ok {\n\t\treturn \"\", fmt.Errorf(\"didn't find invite code in response\")\n\t}\n\treturn InviteLinkPrefix + code, nil\n}\n\n// GetGroupInfoFromInvite gets the group info from an invite message.\n//\n// Note that this is specifically for invite messages, not invite links. Use GetGroupInfoFromLink for resolving chat.whatsapp.com links.\nfunc (cli *Client) GetGroupInfoFromInvite(jid, inviter types.JID, code string, expiration int64) (*types.GroupInfo, error) {\n\tresp, err := cli.sendGroupIQ(context.TODO(), iqGet, jid, waBinary.Node{\n\t\tTag: \"query\",\n\t\tContent: []waBinary.Node{{\n\t\t\tTag: \"add_request\",\n\t\t\tAttrs: waBinary.Attrs{\n\t\t\t\t\"code\":       code,\n\t\t\t\t\"expiration\": expiration,\n\t\t\t\t\"admin\":      inviter,\n\t\t\t},\n\t\t}},\n\t})\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tgroupNode, ok := resp.GetOptionalChildByTag(\"group\")\n\tif !ok {\n\t\treturn nil, &ElementMissingError{Tag: \"group\", In: \"response to invite group info query\"}\n\t}\n\treturn cli.parseGroupNode(&groupNode)\n}\n\n// JoinGroupWithInvite joins a group using an invite message.\n//\n// Note that this is specifically for invite messages, not invite links. Use JoinGroupWithLink for joining with chat.whatsapp.com links.\nfunc (cli *Client) JoinGroupWithInvite(jid, inviter types.JID, code string, expiration int64) error {\n\t_, err := cli.sendGroupIQ(context.TODO(), iqSet, jid, waBinary.Node{\n\t\tTag: \"accept\",\n\t\tAttrs: waBinary.Attrs{\n\t\t\t\"code\":       code,\n\t\t\t\"expiration\": expiration,\n\t\t\t\"admin\":      inviter,\n\t\t},\n\t})\n\treturn err\n}\n\n// GetGroupInfoFromLink resolves the given invite link and asks the WhatsApp servers for info about the group.\n// This will not cause the user to join the group.\nfunc (cli *Client) GetGroupInfoFromLink(code string) (*types.GroupInfo, error) {\n\tcode = strings.TrimPrefix(code, InviteLinkPrefix)\n\tresp, err := cli.sendGroupIQ(context.TODO(), iqGet, types.GroupServerJID, waBinary.Node{\n\t\tTag:   \"invite\",\n\t\tAttrs: waBinary.Attrs{\"code\": code},\n\t})\n\tif errors.Is(err, ErrIQGone) {\n\t\treturn nil, wrapIQError(ErrInviteLinkRevoked, err)\n\t} else if errors.Is(err, ErrIQNotAcceptable) {\n\t\treturn nil, wrapIQError(ErrInviteLinkInvalid, err)\n\t} else if err != nil {\n\t\treturn nil, err\n\t}\n\tgroupNode, ok := resp.GetOptionalChildByTag(\"group\")\n\tif !ok {\n\t\treturn nil, &ElementMissingError{Tag: \"group\", In: \"response to group link info query\"}\n\t}\n\treturn cli.parseGroupNode(&groupNode)\n}\n\n// JoinGroupWithLink joins the group using the given invite link.\nfunc (cli *Client) JoinGroupWithLink(code string) (types.JID, error) {\n\tcode = strings.TrimPrefix(code, InviteLinkPrefix)\n\tresp, err := cli.sendGroupIQ(context.TODO(), iqSet, types.GroupServerJID, waBinary.Node{\n\t\tTag:   \"invite\",\n\t\tAttrs: waBinary.Attrs{\"code\": code},\n\t})\n\tif errors.Is(err, ErrIQGone) {\n\t\treturn types.EmptyJID, wrapIQError(ErrInviteLinkRevoked, err)\n\t} else if errors.Is(err, ErrIQNotAcceptable) {\n\t\treturn types.EmptyJID, wrapIQError(ErrInviteLinkInvalid, err)\n\t} else if err != nil {\n\t\treturn types.EmptyJID, err\n\t}\n\tmembershipApprovalModeNode, ok := resp.GetOptionalChildByTag(\"membership_approval_request\")\n\tif ok {\n\t\treturn membershipApprovalModeNode.AttrGetter().JID(\"jid\"), nil\n\t}\n\tgroupNode, ok := resp.GetOptionalChildByTag(\"group\")\n\tif !ok {\n\t\treturn types.EmptyJID, &ElementMissingError{Tag: \"group\", In: \"response to group link join query\"}\n\t}\n\treturn groupNode.AttrGetter().JID(\"jid\"), nil\n}\n\n// GetJoinedGroups returns the list of groups the user is participating in.\nfunc (cli *Client) GetJoinedGroups() ([]*types.GroupInfo, error) {\n\tresp, err := cli.sendGroupIQ(context.TODO(), iqGet, types.GroupServerJID, waBinary.Node{\n\t\tTag: \"participating\",\n\t\tContent: []waBinary.Node{\n\t\t\t{Tag: \"participants\"},\n\t\t\t{Tag: \"description\"},\n\t\t},\n\t})\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tgroups, ok := resp.GetOptionalChildByTag(\"groups\")\n\tif !ok {\n\t\treturn nil, &ElementMissingError{Tag: \"groups\", In: \"response to group list query\"}\n\t}\n\tchildren := groups.GetChildren()\n\tinfos := make([]*types.GroupInfo, 0, len(children))\n\tfor _, child := range children {\n\t\tif child.Tag != \"group\" {\n\t\t\tcli.Log.Debugf(\"Unexpected child in group list response: %s\", child.XMLString())\n\t\t\tcontinue\n\t\t}\n\t\tparsed, parseErr := cli.parseGroupNode(&child)\n\t\tif parseErr != nil {\n\t\t\tcli.Log.Warnf(\"Error parsing group %s: %v\", parsed.JID, parseErr)\n\t\t}\n\t\tinfos = append(infos, parsed)\n\t}\n\treturn infos, nil\n}\n\n// GetSubGroups gets the subgroups of the given community.\nfunc (cli *Client) GetSubGroups(community types.JID) ([]*types.GroupLinkTarget, error) {\n\tres, err := cli.sendGroupIQ(context.TODO(), iqGet, community, waBinary.Node{Tag: \"sub_groups\"})\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tgroups, ok := res.GetOptionalChildByTag(\"sub_groups\")\n\tif !ok {\n\t\treturn nil, &ElementMissingError{Tag: \"sub_groups\", In: \"response to subgroups query\"}\n\t}\n\tvar parsedGroups []*types.GroupLinkTarget\n\tfor _, child := range groups.GetChildren() {\n\t\tif child.Tag == \"group\" {\n\t\t\tparsedGroup, err := parseGroupLinkTargetNode(&child)\n\t\t\tif err != nil {\n\t\t\t\treturn parsedGroups, fmt.Errorf(\"failed to parse group in subgroups list: %w\", err)\n\t\t\t}\n\t\t\tparsedGroups = append(parsedGroups, &parsedGroup)\n\t\t}\n\t}\n\treturn parsedGroups, nil\n}\n\n// GetLinkedGroupsParticipants gets all the participants in the groups of the given community.\nfunc (cli *Client) GetLinkedGroupsParticipants(community types.JID) ([]types.JID, error) {\n\tres, err := cli.sendGroupIQ(context.TODO(), iqGet, community, waBinary.Node{Tag: \"linked_groups_participants\"})\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tparticipants, ok := res.GetOptionalChildByTag(\"linked_groups_participants\")\n\tif !ok {\n\t\treturn nil, &ElementMissingError{Tag: \"linked_groups_participants\", In: \"response to community participants query\"}\n\t}\n\treturn parseParticipantList(&participants), nil\n}\n\n// GetGroupInfo requests basic info about a group chat from the WhatsApp servers.\nfunc (cli *Client) GetGroupInfo(jid types.JID) (*types.GroupInfo, error) {\n\treturn cli.getGroupInfo(context.TODO(), jid, true)\n}\n\nfunc (cli *Client) getGroupInfo(ctx context.Context, jid types.JID, lockParticipantCache bool) (*types.GroupInfo, error) {\n\tres, err := cli.sendGroupIQ(ctx, iqGet, jid, waBinary.Node{\n\t\tTag:   \"query\",\n\t\tAttrs: waBinary.Attrs{\"request\": \"interactive\"},\n\t})\n\tif errors.Is(err, ErrIQNotFound) {\n\t\treturn nil, wrapIQError(ErrGroupNotFound, err)\n\t} else if errors.Is(err, ErrIQForbidden) {\n\t\treturn nil, wrapIQError(ErrNotInGroup, err)\n\t} else if err != nil {\n\t\treturn nil, err\n\t}\n\n\tgroupNode, ok := res.GetOptionalChildByTag(\"group\")\n\tif !ok {\n\t\treturn nil, &ElementMissingError{Tag: \"groups\", In: \"response to group info query\"}\n\t}\n\tgroupInfo, err := cli.parseGroupNode(&groupNode)\n\tif err != nil {\n\t\treturn groupInfo, err\n\t}\n\tif lockParticipantCache {\n\t\tcli.groupParticipantsCacheLock.Lock()\n\t\tdefer cli.groupParticipantsCacheLock.Unlock()\n\t}\n\tparticipants := make([]types.JID, len(groupInfo.Participants))\n\tfor i, part := range groupInfo.Participants {\n\t\tparticipants[i] = part.JID\n\t}\n\tcli.groupParticipantsCache[jid] = participants\n\treturn groupInfo, nil\n}\n\nfunc (cli *Client) getGroupMembers(ctx context.Context, jid types.JID) ([]types.JID, error) {\n\tcli.groupParticipantsCacheLock.Lock()\n\tdefer cli.groupParticipantsCacheLock.Unlock()\n\tif _, ok := cli.groupParticipantsCache[jid]; !ok {\n\t\t_, err := cli.getGroupInfo(ctx, jid, false)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\treturn cli.groupParticipantsCache[jid], nil\n}\n\nfunc parseParticipant(childAG *waBinary.AttrUtility, child *waBinary.Node) types.GroupParticipant {\n\tpcpType := childAG.OptionalString(\"type\")\n\tparticipant := types.GroupParticipant{\n\t\tIsAdmin:      pcpType == \"admin\" || pcpType == \"superadmin\",\n\t\tIsSuperAdmin: pcpType == \"superadmin\",\n\t\tJID:          childAG.JID(\"jid\"),\n\t\tLID:          childAG.OptionalJIDOrEmpty(\"lid\"),\n\t\tDisplayName:  childAG.OptionalString(\"display_name\"),\n\t}\n\tif participant.JID.Server == types.HiddenUserServer && participant.LID.IsEmpty() {\n\t\tparticipant.LID = participant.JID\n\t\t//participant.JID = types.EmptyJID\n\t}\n\tif errorCode := childAG.OptionalInt(\"error\"); errorCode != 0 {\n\t\tparticipant.Error = errorCode\n\t\taddRequest, ok := child.GetOptionalChildByTag(\"add_request\")\n\t\tif ok {\n\t\t\taddAG := addRequest.AttrGetter()\n\t\t\tparticipant.AddRequest = &types.GroupParticipantAddRequest{\n\t\t\t\tCode:       addAG.String(\"code\"),\n\t\t\t\tExpiration: addAG.UnixTime(\"expiration\"),\n\t\t\t}\n\t\t}\n\t}\n\treturn participant\n}\n\nfunc (cli *Client) parseGroupNode(groupNode *waBinary.Node) (*types.GroupInfo, error) {\n\tvar group types.GroupInfo\n\tag := groupNode.AttrGetter()\n\n\tgroup.JID = types.NewJID(ag.String(\"id\"), types.GroupServer)\n\tgroup.OwnerJID = ag.OptionalJIDOrEmpty(\"creator\")\n\n\tgroup.Name = ag.String(\"subject\")\n\tgroup.NameSetAt = ag.UnixTime(\"s_t\")\n\tgroup.NameSetBy = ag.OptionalJIDOrEmpty(\"s_o\")\n\n\tgroup.GroupCreated = ag.UnixTime(\"creation\")\n\n\tgroup.AnnounceVersionID = ag.OptionalString(\"a_v_id\")\n\tgroup.ParticipantVersionID = ag.OptionalString(\"p_v_id\")\n\n\tfor _, child := range groupNode.GetChildren() {\n\t\tchildAG := child.AttrGetter()\n\t\tswitch child.Tag {\n\t\tcase \"participant\":\n\t\t\tgroup.Participants = append(group.Participants, parseParticipant(childAG, &child))\n\t\tcase \"description\":\n\t\t\tbody, bodyOK := child.GetOptionalChildByTag(\"body\")\n\t\t\tif bodyOK {\n\t\t\t\ttopicBytes, _ := body.Content.([]byte)\n\t\t\t\tgroup.Topic = string(topicBytes)\n\t\t\t\tgroup.TopicID = childAG.String(\"id\")\n\t\t\t\tgroup.TopicSetBy = childAG.OptionalJIDOrEmpty(\"participant\")\n\t\t\t\tgroup.TopicSetAt = childAG.UnixTime(\"t\")\n\t\t\t}\n\t\tcase \"announcement\":\n\t\t\tgroup.IsAnnounce = true\n\t\tcase \"locked\":\n\t\t\tgroup.IsLocked = true\n\t\tcase \"ephemeral\":\n\t\t\tgroup.IsEphemeral = true\n\t\t\tgroup.DisappearingTimer = uint32(childAG.Uint64(\"expiration\"))\n\t\tcase \"member_add_mode\":\n\t\t\tmodeBytes, _ := child.Content.([]byte)\n\t\t\tgroup.MemberAddMode = types.GroupMemberAddMode(modeBytes)\n\t\tcase \"linked_parent\":\n\t\t\tgroup.LinkedParentJID = childAG.JID(\"jid\")\n\t\tcase \"default_sub_group\":\n\t\t\tgroup.IsDefaultSubGroup = true\n\t\tcase \"parent\":\n\t\t\tgroup.IsParent = true\n\t\t\tgroup.DefaultMembershipApprovalMode = childAG.OptionalString(\"default_membership_approval_mode\")\n\t\tcase \"incognito\":\n\t\t\tgroup.IsIncognito = true\n\t\tcase \"membership_approval_mode\":\n\t\t\tgroup.IsJoinApprovalRequired = true\n\t\tdefault:\n\t\t\tcli.Log.Debugf(\"Unknown element in group node %s: %s\", group.JID.String(), child.XMLString())\n\t\t}\n\t\tif !childAG.OK() {\n\t\t\tcli.Log.Warnf(\"Possibly failed to parse %s element in group node: %+v\", child.Tag, childAG.Errors)\n\t\t}\n\t}\n\n\treturn &group, ag.Error()\n}\n\nfunc parseGroupLinkTargetNode(groupNode *waBinary.Node) (types.GroupLinkTarget, error) {\n\tag := groupNode.AttrGetter()\n\tjidKey := ag.OptionalJIDOrEmpty(\"jid\")\n\tif jidKey.IsEmpty() {\n\t\tjidKey = types.NewJID(ag.String(\"id\"), types.GroupServer)\n\t}\n\treturn types.GroupLinkTarget{\n\t\tJID: jidKey,\n\t\tGroupName: types.GroupName{\n\t\t\tName:      ag.String(\"subject\"),\n\t\t\tNameSetAt: ag.UnixTime(\"s_t\"),\n\t\t},\n\t\tGroupIsDefaultSub: types.GroupIsDefaultSub{\n\t\t\tIsDefaultSubGroup: groupNode.GetChildByTag(\"default_sub_group\").Tag == \"default_sub_group\",\n\t\t},\n\t}, ag.Error()\n}\n\nfunc parseParticipantList(node *waBinary.Node) (participants []types.JID) {\n\tchildren := node.GetChildren()\n\tparticipants = make([]types.JID, 0, len(children))\n\tfor _, child := range children {\n\t\tjid, ok := child.Attrs[\"jid\"].(types.JID)\n\t\tif child.Tag != \"participant\" || !ok {\n\t\t\tcontinue\n\t\t}\n\t\tparticipants = append(participants, jid)\n\t}\n\treturn\n}\n\nfunc (cli *Client) parseGroupCreate(node *waBinary.Node) (*events.JoinedGroup, error) {\n\tgroupNode, ok := node.GetOptionalChildByTag(\"group\")\n\tif !ok {\n\t\treturn nil, fmt.Errorf(\"group create notification didn't contain group info\")\n\t}\n\tvar evt events.JoinedGroup\n\tag := node.AttrGetter()\n\tevt.Reason = ag.OptionalString(\"reason\")\n\tevt.CreateKey = ag.OptionalString(\"key\")\n\tevt.Type = ag.OptionalString(\"type\")\n\tinfo, err := cli.parseGroupNode(&groupNode)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to parse group info in create notification: %w\", err)\n\t}\n\tevt.GroupInfo = *info\n\treturn &evt, nil\n}\n\nfunc (cli *Client) parseGroupChange(node *waBinary.Node) (*events.GroupInfo, error) {\n\tvar evt events.GroupInfo\n\tag := node.AttrGetter()\n\tevt.JID = ag.JID(\"from\")\n\tevt.Notify = ag.OptionalString(\"notify\")\n\tevt.Sender = ag.OptionalJID(\"participant\")\n\tevt.Timestamp = ag.UnixTime(\"t\")\n\tif !ag.OK() {\n\t\treturn nil, fmt.Errorf(\"group change doesn't contain required attributes: %w\", ag.Error())\n\t}\n\n\tfor _, child := range node.GetChildren() {\n\t\tcag := child.AttrGetter()\n\t\tif child.Tag == \"add\" || child.Tag == \"remove\" || child.Tag == \"promote\" || child.Tag == \"demote\" {\n\t\t\tevt.PrevParticipantVersionID = cag.String(\"prev_v_id\")\n\t\t\tevt.ParticipantVersionID = cag.String(\"v_id\")\n\t\t}\n\t\tswitch child.Tag {\n\t\tcase \"add\":\n\t\t\tevt.JoinReason = cag.OptionalString(\"reason\")\n\t\t\tevt.Join = parseParticipantList(&child)\n\t\tcase \"remove\":\n\t\t\tevt.Leave = parseParticipantList(&child)\n\t\tcase \"promote\":\n\t\t\tevt.Promote = parseParticipantList(&child)\n\t\tcase \"demote\":\n\t\t\tevt.Demote = parseParticipantList(&child)\n\t\tcase \"locked\":\n\t\t\tevt.Locked = &types.GroupLocked{IsLocked: true}\n\t\tcase \"unlocked\":\n\t\t\tevt.Locked = &types.GroupLocked{IsLocked: false}\n\t\tcase \"delete\":\n\t\t\tevt.Delete = &types.GroupDelete{Deleted: true, DeleteReason: cag.String(\"reason\")}\n\t\tcase \"subject\":\n\t\t\tevt.Name = &types.GroupName{\n\t\t\t\tName:      cag.String(\"subject\"),\n\t\t\t\tNameSetAt: cag.UnixTime(\"s_t\"),\n\t\t\t\tNameSetBy: cag.OptionalJIDOrEmpty(\"s_o\"),\n\t\t\t}\n\t\tcase \"description\":\n\t\t\tvar topicStr string\n\t\t\t_, isDelete := child.GetOptionalChildByTag(\"delete\")\n\t\t\tif !isDelete {\n\t\t\t\ttopicChild := child.GetChildByTag(\"body\")\n\t\t\t\ttopicBytes, ok := topicChild.Content.([]byte)\n\t\t\t\tif !ok {\n\t\t\t\t\treturn nil, fmt.Errorf(\"group change description has unexpected body: %s\", topicChild.XMLString())\n\t\t\t\t}\n\t\t\t\ttopicStr = string(topicBytes)\n\t\t\t}\n\t\t\tvar setBy types.JID\n\t\t\tif evt.Sender != nil {\n\t\t\t\tsetBy = *evt.Sender\n\t\t\t}\n\t\t\tevt.Topic = &types.GroupTopic{\n\t\t\t\tTopic:        topicStr,\n\t\t\t\tTopicID:      cag.String(\"id\"),\n\t\t\t\tTopicSetAt:   evt.Timestamp,\n\t\t\t\tTopicSetBy:   setBy,\n\t\t\t\tTopicDeleted: isDelete,\n\t\t\t}\n\t\tcase \"announcement\":\n\t\t\tevt.Announce = &types.GroupAnnounce{\n\t\t\t\tIsAnnounce:        true,\n\t\t\t\tAnnounceVersionID: cag.String(\"v_id\"),\n\t\t\t}\n\t\tcase \"not_announcement\":\n\t\t\tevt.Announce = &types.GroupAnnounce{\n\t\t\t\tIsAnnounce:        false,\n\t\t\t\tAnnounceVersionID: cag.String(\"v_id\"),\n\t\t\t}\n\t\tcase \"invite\":\n\t\t\tlink := InviteLinkPrefix + cag.String(\"code\")\n\t\t\tevt.NewInviteLink = &link\n\t\tcase \"ephemeral\":\n\t\t\ttimer := uint32(cag.Uint64(\"expiration\"))\n\t\t\tevt.Ephemeral = &types.GroupEphemeral{\n\t\t\t\tIsEphemeral:       true,\n\t\t\t\tDisappearingTimer: timer,\n\t\t\t}\n\t\tcase \"not_ephemeral\":\n\t\t\tevt.Ephemeral = &types.GroupEphemeral{IsEphemeral: false}\n\t\tcase \"link\":\n\t\t\tevt.Link = &types.GroupLinkChange{\n\t\t\t\tType: types.GroupLinkChangeType(cag.String(\"link_type\")),\n\t\t\t}\n\t\t\tgroupNode, ok := child.GetOptionalChildByTag(\"group\")\n\t\t\tif !ok {\n\t\t\t\treturn nil, &ElementMissingError{Tag: \"group\", In: \"group link\"}\n\t\t\t}\n\t\t\tvar err error\n\t\t\tevt.Link.Group, err = parseGroupLinkTargetNode(&groupNode)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, fmt.Errorf(\"failed to parse group link node in group change: %w\", err)\n\t\t\t}\n\t\tcase \"unlink\":\n\t\t\tevt.Unlink = &types.GroupLinkChange{\n\t\t\t\tType:         types.GroupLinkChangeType(cag.String(\"unlink_type\")),\n\t\t\t\tUnlinkReason: types.GroupUnlinkReason(cag.String(\"unlink_reason\")),\n\t\t\t}\n\t\t\tgroupNode, ok := child.GetOptionalChildByTag(\"group\")\n\t\t\tif !ok {\n\t\t\t\treturn nil, &ElementMissingError{Tag: \"group\", In: \"group unlink\"}\n\t\t\t}\n\t\t\tvar err error\n\t\t\tevt.Unlink.Group, err = parseGroupLinkTargetNode(&groupNode)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, fmt.Errorf(\"failed to parse group unlink node in group change: %w\", err)\n\t\t\t}\n\t\tcase \"membership_approval_mode\":\n\t\t\tevt.MembershipApprovalMode = &types.GroupMembershipApprovalMode{\n\t\t\t\tIsJoinApprovalRequired: true,\n\t\t\t}\n\t\tdefault:\n\t\t\tevt.UnknownChanges = append(evt.UnknownChanges, &child)\n\t\t}\n\t\tif !cag.OK() {\n\t\t\treturn nil, fmt.Errorf(\"group change %s element doesn't contain required attributes: %w\", child.Tag, cag.Error())\n\t\t}\n\t}\n\treturn &evt, nil\n}\n\nfunc (cli *Client) updateGroupParticipantCache(evt *events.GroupInfo) {\n\tif len(evt.Join) == 0 && len(evt.Leave) == 0 {\n\t\treturn\n\t}\n\tcli.groupParticipantsCacheLock.Lock()\n\tdefer cli.groupParticipantsCacheLock.Unlock()\n\tcached, ok := cli.groupParticipantsCache[evt.JID]\n\tif !ok {\n\t\treturn\n\t}\nOuter:\n\tfor _, jid := range evt.Join {\n\t\tfor _, existingJID := range cached {\n\t\t\tif jid == existingJID {\n\t\t\t\tcontinue Outer\n\t\t\t}\n\t\t}\n\t\tcached = append(cached, jid)\n\t}\n\tfor _, jid := range evt.Leave {\n\t\tfor i, existingJID := range cached {\n\t\t\tif existingJID == jid {\n\t\t\t\tcached[i] = cached[len(cached)-1]\n\t\t\t\tcached = cached[:len(cached)-1]\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}\n\tcli.groupParticipantsCache[evt.JID] = cached\n}\n\nfunc (cli *Client) parseGroupNotification(node *waBinary.Node) (interface{}, error) {\n\tchildren := node.GetChildren()\n\tif len(children) == 1 && children[0].Tag == \"create\" {\n\t\treturn cli.parseGroupCreate(&children[0])\n\t} else {\n\t\tgroupChange, err := cli.parseGroupChange(node)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tcli.updateGroupParticipantCache(groupChange)\n\t\treturn groupChange, nil\n\t}\n}\n\n// SetGroupJoinApprovalMode sets the group join approval mode to 'on' or 'off'.\nfunc (cli *Client) SetGroupJoinApprovalMode(jid types.JID, mode bool) error {\n\tmodeStr := \"off\"\n\tif mode {\n\t\tmodeStr = \"on\"\n\t}\n\n\tcontent := waBinary.Node{\n\t\tTag: \"membership_approval_mode\",\n\t\tContent: []waBinary.Node{\n\t\t\t{\n\t\t\t\tTag:   \"group_join\",\n\t\t\t\tAttrs: waBinary.Attrs{\"state\": modeStr},\n\t\t\t},\n\t\t},\n\t}\n\n\t_, err := cli.sendGroupIQ(context.TODO(), iqSet, jid, content)\n\treturn err\n}\n\n// SetGroupMemberAddMode sets the group member add mode to 'admin_add' or 'all_member_add'.\nfunc (cli *Client) SetGroupMemberAddMode(jid types.JID, mode types.GroupMemberAddMode) error {\n\tif mode != types.GroupMemberAddModeAdmin && mode != types.GroupMemberAddModeAllMember {\n\t\treturn errors.New(\"invalid mode, must be 'admin_add' or 'all_member_add'\")\n\t}\n\n\tcontent := waBinary.Node{\n\t\tTag:     \"member_add_mode\",\n\t\tContent: []byte(mode),\n\t}\n\n\t_, err := cli.sendGroupIQ(context.TODO(), iqSet, jid, content)\n\treturn err\n}\n\n// SetGroupDescription updates the group description.\nfunc (cli *Client) SetGroupDescription(jid types.JID, description string) error {\n\tcontent := waBinary.Node{\n\t\tTag: \"description\",\n\t\tContent: []waBinary.Node{\n\t\t\t{\n\t\t\t\tTag:     \"body\",\n\t\t\t\tContent: []byte(description),\n\t\t\t},\n\t\t},\n\t}\n\n\t_, err := cli.sendGroupIQ(context.TODO(), iqSet, jid, content)\n\treturn err\n}\n"
        },
        {
          "name": "handshake.go",
          "type": "blob",
          "size": 6.8515625,
          "content": "// Copyright (c) 2021 Tulir Asokan\n//\n// This Source Code Form is subject to the terms of the Mozilla Public\n// License, v. 2.0. If a copy of the MPL was not distributed with this\n// file, You can obtain one at http://mozilla.org/MPL/2.0/.\n\npackage whatsmeow\n\nimport (\n\t\"bytes\"\n\t\"fmt\"\n\t\"time\"\n\n\t\"go.mau.fi/libsignal/ecc\"\n\t\"google.golang.org/protobuf/proto\"\n\n\twaProto \"go.mau.fi/whatsmeow/binary/proto\"\n\t\"go.mau.fi/whatsmeow/socket\"\n\t\"go.mau.fi/whatsmeow/util/keys\"\n)\n\nconst NoiseHandshakeResponseTimeout = 20 * time.Second\nconst WACertIssuerSerial = 0\n\nvar WACertPubKey = [...]byte{0x14, 0x23, 0x75, 0x57, 0x4d, 0xa, 0x58, 0x71, 0x66, 0xaa, 0xe7, 0x1e, 0xbe, 0x51, 0x64, 0x37, 0xc4, 0xa2, 0x8b, 0x73, 0xe3, 0x69, 0x5c, 0x6c, 0xe1, 0xf7, 0xf9, 0x54, 0x5d, 0xa8, 0xee, 0x6b}\n\n// doHandshake implements the Noise_XX_25519_AESGCM_SHA256 handshake for the WhatsApp web API.\nfunc (cli *Client) doHandshake(fs *socket.FrameSocket, ephemeralKP keys.KeyPair) error {\n\tnh := socket.NewNoiseHandshake()\n\tnh.Start(socket.NoiseStartPattern, fs.Header)\n\tnh.Authenticate(ephemeralKP.Pub[:])\n\tdata, err := proto.Marshal(&waProto.HandshakeMessage{\n\t\tClientHello: &waProto.HandshakeClientHello{\n\t\t\tEphemeral: ephemeralKP.Pub[:],\n\t\t},\n\t})\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to marshal handshake message: %w\", err)\n\t}\n\terr = fs.SendFrame(data)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to send handshake message: %w\", err)\n\t}\n\tvar resp []byte\n\tselect {\n\tcase resp = <-fs.Frames:\n\tcase <-time.After(NoiseHandshakeResponseTimeout):\n\t\treturn fmt.Errorf(\"timed out waiting for handshake response\")\n\t}\n\tvar handshakeResponse waProto.HandshakeMessage\n\terr = proto.Unmarshal(resp, &handshakeResponse)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to unmarshal handshake response: %w\", err)\n\t}\n\tserverEphemeral := handshakeResponse.GetServerHello().GetEphemeral()\n\tserverStaticCiphertext := handshakeResponse.GetServerHello().GetStatic()\n\tcertificateCiphertext := handshakeResponse.GetServerHello().GetPayload()\n\tif len(serverEphemeral) != 32 || serverStaticCiphertext == nil || certificateCiphertext == nil {\n\t\treturn fmt.Errorf(\"missing parts of handshake response\")\n\t}\n\tserverEphemeralArr := *(*[32]byte)(serverEphemeral)\n\n\tnh.Authenticate(serverEphemeral)\n\terr = nh.MixSharedSecretIntoKey(*ephemeralKP.Priv, serverEphemeralArr)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to mix server ephemeral key in: %w\", err)\n\t}\n\n\tstaticDecrypted, err := nh.Decrypt(serverStaticCiphertext)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to decrypt server static ciphertext: %w\", err)\n\t} else if len(staticDecrypted) != 32 {\n\t\treturn fmt.Errorf(\"unexpected length of server static plaintext %d (expected 32)\", len(staticDecrypted))\n\t}\n\terr = nh.MixSharedSecretIntoKey(*ephemeralKP.Priv, *(*[32]byte)(staticDecrypted))\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to mix server static key in: %w\", err)\n\t}\n\n\tcertDecrypted, err := nh.Decrypt(certificateCiphertext)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to decrypt noise certificate ciphertext: %w\", err)\n\t} else if err = verifyServerCert(certDecrypted, staticDecrypted); err != nil {\n\t\treturn fmt.Errorf(\"failed to verify server cert: %w\", err)\n\t}\n\n\tencryptedPubkey := nh.Encrypt(cli.Store.NoiseKey.Pub[:])\n\terr = nh.MixSharedSecretIntoKey(*cli.Store.NoiseKey.Priv, serverEphemeralArr)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to mix noise private key in: %w\", err)\n\t}\n\n\tvar clientPayload *waProto.ClientPayload\n\tif cli.GetClientPayload != nil {\n\t\tclientPayload = cli.GetClientPayload()\n\t} else {\n\t\tclientPayload = cli.Store.GetClientPayload()\n\t}\n\n\tclientFinishPayloadBytes, err := proto.Marshal(clientPayload)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to marshal client finish payload: %w\", err)\n\t}\n\tencryptedClientFinishPayload := nh.Encrypt(clientFinishPayloadBytes)\n\tdata, err = proto.Marshal(&waProto.HandshakeMessage{\n\t\tClientFinish: &waProto.HandshakeClientFinish{\n\t\t\tStatic:  encryptedPubkey,\n\t\t\tPayload: encryptedClientFinishPayload,\n\t\t},\n\t})\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to marshal handshake finish message: %w\", err)\n\t}\n\terr = fs.SendFrame(data)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to send handshake finish message: %w\", err)\n\t}\n\n\tns, err := nh.Finish(fs, cli.handleFrame, cli.onDisconnect)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to create noise socket: %w\", err)\n\t}\n\n\tcli.socket = ns\n\n\treturn nil\n}\n\nfunc verifyServerCert(certDecrypted, staticDecrypted []byte) error {\n\tvar certChain waProto.CertChain\n\terr := proto.Unmarshal(certDecrypted, &certChain)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to unmarshal noise certificate: %w\", err)\n\t}\n\tvar intermediateCertDetails, leafCertDetails waProto.CertChain_NoiseCertificate_Details\n\tintermediateCertDetailsRaw := certChain.GetIntermediate().GetDetails()\n\tintermediateCertSignature := certChain.GetIntermediate().GetSignature()\n\tleafCertDetailsRaw := certChain.GetLeaf().GetDetails()\n\tleafCertSignature := certChain.GetLeaf().GetSignature()\n\tif intermediateCertDetailsRaw == nil || intermediateCertSignature == nil || leafCertDetailsRaw == nil || leafCertSignature == nil {\n\t\treturn fmt.Errorf(\"missing parts of noise certificate\")\n\t} else if len(intermediateCertSignature) != 64 {\n\t\treturn fmt.Errorf(\"unexpected length of intermediate cert signature %d (expected 64)\", len(intermediateCertSignature))\n\t} else if len(leafCertSignature) != 64 {\n\t\treturn fmt.Errorf(\"unexpected length of leaf cert signature %d (expected 64)\", len(leafCertSignature))\n\t} else if !ecc.VerifySignature(ecc.NewDjbECPublicKey(WACertPubKey), intermediateCertDetailsRaw, [64]byte(intermediateCertSignature)) {\n\t\treturn fmt.Errorf(\"failed to verify intermediate cert signature\")\n\t} else if err = proto.Unmarshal(intermediateCertDetailsRaw, &intermediateCertDetails); err != nil {\n\t\treturn fmt.Errorf(\"failed to unmarshal noise certificate details: %w\", err)\n\t} else if intermediateCertDetails.GetIssuerSerial() != WACertIssuerSerial {\n\t\treturn fmt.Errorf(\"unexpected intermediate issuer serial %d (expected %d)\", intermediateCertDetails.GetIssuerSerial(), WACertIssuerSerial)\n\t} else if len(intermediateCertDetails.GetKey()) != 32 {\n\t\treturn fmt.Errorf(\"unexpected length of intermediate cert key %d (expected 32)\", len(intermediateCertDetails.GetKey()))\n\t} else if !ecc.VerifySignature(ecc.NewDjbECPublicKey([32]byte(intermediateCertDetails.GetKey())), leafCertDetailsRaw, [64]byte(leafCertSignature)) {\n\t\treturn fmt.Errorf(\"failed to verify intermediate cert signature\")\n\t} else if err = proto.Unmarshal(leafCertDetailsRaw, &leafCertDetails); err != nil {\n\t\treturn fmt.Errorf(\"failed to unmarshal noise certificate details: %w\", err)\n\t} else if leafCertDetails.GetIssuerSerial() != intermediateCertDetails.GetSerial() {\n\t\treturn fmt.Errorf(\"unexpected leaf issuer serial %d (expected %d)\", leafCertDetails.GetIssuerSerial(), intermediateCertDetails.GetSerial())\n\t} else if !bytes.Equal(leafCertDetails.GetKey(), staticDecrypted) {\n\t\treturn fmt.Errorf(\"cert key doesn't match decrypted static\")\n\t}\n\treturn nil\n}\n"
        },
        {
          "name": "internals.go",
          "type": "blob",
          "size": 2.5927734375,
          "content": "// Copyright (c) 2022 Tulir Asokan\n//\n// This Source Code Form is subject to the terms of the Mozilla Public\n// License, v. 2.0. If a copy of the MPL was not distributed with this\n// file, You can obtain one at http://mozilla.org/MPL/2.0/.\n\npackage whatsmeow\n\nimport (\n\t\"context\"\n\n\t\"go.mau.fi/libsignal/keys/prekey\"\n\n\twaBinary \"go.mau.fi/whatsmeow/binary\"\n\t\"go.mau.fi/whatsmeow/types\"\n)\n\ntype DangerousInternalClient struct {\n\tc *Client\n}\n\n// DangerousInternals allows access to some unexported methods in Client.\n//\n// Deprecated: dangerous\nfunc (cli *Client) DangerousInternals() *DangerousInternalClient {\n\treturn &DangerousInternalClient{cli}\n}\n\ntype DangerousInfoQuery = infoQuery\ntype DangerousInfoQueryType = infoQueryType\n\nfunc (int *DangerousInternalClient) SendIQ(query DangerousInfoQuery) (*waBinary.Node, error) {\n\treturn int.c.sendIQ(query)\n}\n\nfunc (int *DangerousInternalClient) SendIQAsync(query DangerousInfoQuery) (<-chan *waBinary.Node, error) {\n\treturn int.c.sendIQAsync(query)\n}\n\nfunc (int *DangerousInternalClient) SendNode(node waBinary.Node) error {\n\treturn int.c.sendNode(node)\n}\n\nfunc (int *DangerousInternalClient) WaitResponse(reqID string) chan *waBinary.Node {\n\treturn int.c.waitResponse(reqID)\n}\n\nfunc (int *DangerousInternalClient) CancelResponse(reqID string, ch chan *waBinary.Node) {\n\tint.c.cancelResponse(reqID, ch)\n}\n\nfunc (int *DangerousInternalClient) QueryMediaConn() (*MediaConn, error) {\n\treturn int.c.queryMediaConn()\n}\n\nfunc (int *DangerousInternalClient) RefreshMediaConn(force bool) (*MediaConn, error) {\n\treturn int.c.refreshMediaConn(force)\n}\n\nfunc (int *DangerousInternalClient) GetServerPreKeyCount() (int, error) {\n\treturn int.c.getServerPreKeyCount()\n}\n\nfunc (int *DangerousInternalClient) RequestAppStateKeys(ctx context.Context, keyIDs [][]byte) {\n\tint.c.requestAppStateKeys(ctx, keyIDs)\n}\n\nfunc (int *DangerousInternalClient) SendRetryReceipt(node *waBinary.Node, info *types.MessageInfo, forceIncludeIdentity bool) {\n\tint.c.sendRetryReceipt(node, info, forceIncludeIdentity)\n}\n\nfunc (int *DangerousInternalClient) EncryptMessageForDevice(plaintext []byte, to types.JID, bundle *prekey.Bundle, extraAttrs waBinary.Attrs) (*waBinary.Node, bool, error) {\n\treturn int.c.encryptMessageForDevice(plaintext, to, bundle, extraAttrs)\n}\n\nfunc (int *DangerousInternalClient) GetOwnID() types.JID {\n\treturn int.c.getOwnID()\n}\n\nfunc (int *DangerousInternalClient) DecryptDM(child *waBinary.Node, from types.JID, isPreKey bool) ([]byte, error) {\n\treturn int.c.decryptDM(child, from, isPreKey)\n}\n\nfunc (int *DangerousInternalClient) MakeDeviceIdentityNode() waBinary.Node {\n\treturn int.c.makeDeviceIdentityNode()\n}\n"
        },
        {
          "name": "keepalive.go",
          "type": "blob",
          "size": 2.375,
          "content": "// Copyright (c) 2021 Tulir Asokan\n//\n// This Source Code Form is subject to the terms of the Mozilla Public\n// License, v. 2.0. If a copy of the MPL was not distributed with this\n// file, You can obtain one at http://mozilla.org/MPL/2.0/.\n\npackage whatsmeow\n\nimport (\n\t\"context\"\n\t\"math/rand\"\n\t\"time\"\n\n\t\"go.mau.fi/whatsmeow/types\"\n\t\"go.mau.fi/whatsmeow/types/events\"\n)\n\nvar (\n\t// KeepAliveResponseDeadline specifies the duration to wait for a response to websocket keepalive pings.\n\tKeepAliveResponseDeadline = 10 * time.Second\n\t// KeepAliveIntervalMin specifies the minimum interval for websocket keepalive pings.\n\tKeepAliveIntervalMin = 20 * time.Second\n\t// KeepAliveIntervalMax specifies the maximum interval for websocket keepalive pings.\n\tKeepAliveIntervalMax = 30 * time.Second\n\n\t// KeepAliveMaxFailTime specifies the maximum time to wait before forcing a reconnect if keepalives fail repeatedly.\n\tKeepAliveMaxFailTime = 3 * time.Minute\n)\n\nfunc (cli *Client) keepAliveLoop(ctx context.Context) {\n\tlastSuccess := time.Now()\n\tvar errorCount int\n\tfor {\n\t\tinterval := rand.Int63n(KeepAliveIntervalMax.Milliseconds()-KeepAliveIntervalMin.Milliseconds()) + KeepAliveIntervalMin.Milliseconds()\n\t\tselect {\n\t\tcase <-time.After(time.Duration(interval) * time.Millisecond):\n\t\t\tisSuccess, shouldContinue := cli.sendKeepAlive(ctx)\n\t\t\tif !shouldContinue {\n\t\t\t\treturn\n\t\t\t} else if !isSuccess {\n\t\t\t\terrorCount++\n\t\t\t\tgo cli.dispatchEvent(&events.KeepAliveTimeout{\n\t\t\t\t\tErrorCount:  errorCount,\n\t\t\t\t\tLastSuccess: lastSuccess,\n\t\t\t\t})\n\t\t\t\tif cli.EnableAutoReconnect && time.Since(lastSuccess) > KeepAliveMaxFailTime {\n\t\t\t\t\tcli.Log.Debugf(\"Forcing reconnect due to keepalive failure\")\n\t\t\t\t\tcli.Disconnect()\n\t\t\t\t\tgo cli.autoReconnect()\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif errorCount > 0 {\n\t\t\t\t\terrorCount = 0\n\t\t\t\t\tgo cli.dispatchEvent(&events.KeepAliveRestored{})\n\t\t\t\t}\n\t\t\t\tlastSuccess = time.Now()\n\t\t\t}\n\t\tcase <-ctx.Done():\n\t\t\treturn\n\t\t}\n\t}\n}\n\nfunc (cli *Client) sendKeepAlive(ctx context.Context) (isSuccess, shouldContinue bool) {\n\trespCh, err := cli.sendIQAsync(infoQuery{\n\t\tNamespace: \"w:p\",\n\t\tType:      \"get\",\n\t\tTo:        types.ServerJID,\n\t})\n\tif err != nil {\n\t\tcli.Log.Warnf(\"Failed to send keepalive: %v\", err)\n\t\treturn false, true\n\t}\n\tselect {\n\tcase <-respCh:\n\t\t// All good\n\t\treturn true, true\n\tcase <-time.After(KeepAliveResponseDeadline):\n\t\tcli.Log.Warnf(\"Keepalive timed out\")\n\t\treturn false, true\n\tcase <-ctx.Done():\n\t\treturn false, false\n\t}\n}\n"
        },
        {
          "name": "mediaconn.go",
          "type": "blob",
          "size": 2.5302734375,
          "content": "// Copyright (c) 2021 Tulir Asokan\n//\n// This Source Code Form is subject to the terms of the Mozilla Public\n// License, v. 2.0. If a copy of the MPL was not distributed with this\n// file, You can obtain one at http://mozilla.org/MPL/2.0/.\n\npackage whatsmeow\n\nimport (\n\t\"fmt\"\n\t\"time\"\n\n\twaBinary \"go.mau.fi/whatsmeow/binary\"\n\t\"go.mau.fi/whatsmeow/types\"\n)\n\n//type MediaConnIP struct {\n//\tIP4 net.IP\n//\tIP6 net.IP\n//}\n\n// MediaConnHost represents a single host to download media from.\ntype MediaConnHost struct {\n\tHostname string\n\t//IPs      []MediaConnIP\n}\n\n// MediaConn contains a list of WhatsApp servers from which attachments can be downloaded from.\ntype MediaConn struct {\n\tAuth       string\n\tAuthTTL    int\n\tTTL        int\n\tMaxBuckets int\n\tFetchedAt  time.Time\n\tHosts      []MediaConnHost\n}\n\n// Expiry returns the time when the MediaConn expires.\nfunc (mc *MediaConn) Expiry() time.Time {\n\treturn mc.FetchedAt.Add(time.Duration(mc.TTL) * time.Second)\n}\n\nfunc (cli *Client) refreshMediaConn(force bool) (*MediaConn, error) {\n\tif cli == nil {\n\t\treturn nil, ErrClientIsNil\n\t}\n\tcli.mediaConnLock.Lock()\n\tdefer cli.mediaConnLock.Unlock()\n\tif cli.mediaConnCache == nil || force || time.Now().After(cli.mediaConnCache.Expiry()) {\n\t\tvar err error\n\t\tcli.mediaConnCache, err = cli.queryMediaConn()\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\treturn cli.mediaConnCache, nil\n}\n\nfunc (cli *Client) queryMediaConn() (*MediaConn, error) {\n\tresp, err := cli.sendIQ(infoQuery{\n\t\tNamespace: \"w:m\",\n\t\tType:      \"set\",\n\t\tTo:        types.ServerJID,\n\t\tContent:   []waBinary.Node{{Tag: \"media_conn\"}},\n\t})\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to query media connections: %w\", err)\n\t} else if len(resp.GetChildren()) == 0 || resp.GetChildren()[0].Tag != \"media_conn\" {\n\t\treturn nil, fmt.Errorf(\"failed to query media connections: unexpected child tag\")\n\t}\n\trespMC := resp.GetChildren()[0]\n\tvar mc MediaConn\n\tag := respMC.AttrGetter()\n\tmc.FetchedAt = time.Now()\n\tmc.Auth = ag.String(\"auth\")\n\tmc.TTL = ag.Int(\"ttl\")\n\tmc.AuthTTL = ag.Int(\"auth_ttl\")\n\tmc.MaxBuckets = ag.Int(\"max_buckets\")\n\tif !ag.OK() {\n\t\treturn nil, fmt.Errorf(\"failed to parse media connections: %+v\", ag.Errors)\n\t}\n\tfor _, child := range respMC.GetChildren() {\n\t\tif child.Tag != \"host\" {\n\t\t\tcli.Log.Warnf(\"Unexpected child in media_conn element: %s\", child.XMLString())\n\t\t\tcontinue\n\t\t}\n\t\tcag := child.AttrGetter()\n\t\tmc.Hosts = append(mc.Hosts, MediaConnHost{\n\t\t\tHostname: cag.String(\"hostname\"),\n\t\t})\n\t\tif !cag.OK() {\n\t\t\treturn nil, fmt.Errorf(\"failed to parse media connection host: %+v\", ag.Errors)\n\t\t}\n\t}\n\treturn &mc, nil\n}\n"
        },
        {
          "name": "mediaretry.go",
          "type": "blob",
          "size": 6.2734375,
          "content": "// Copyright (c) 2022 Tulir Asokan\n//\n// This Source Code Form is subject to the terms of the Mozilla Public\n// License, v. 2.0. If a copy of the MPL was not distributed with this\n// file, You can obtain one at http://mozilla.org/MPL/2.0/.\n\npackage whatsmeow\n\nimport (\n\t\"fmt\"\n\n\t\"go.mau.fi/util/random\"\n\t\"google.golang.org/protobuf/proto\"\n\n\twaBinary \"go.mau.fi/whatsmeow/binary\"\n\twaProto \"go.mau.fi/whatsmeow/binary/proto\"\n\t\"go.mau.fi/whatsmeow/types\"\n\t\"go.mau.fi/whatsmeow/types/events\"\n\t\"go.mau.fi/whatsmeow/util/gcmutil\"\n\t\"go.mau.fi/whatsmeow/util/hkdfutil\"\n)\n\nfunc getMediaRetryKey(mediaKey []byte) (cipherKey []byte) {\n\treturn hkdfutil.SHA256(mediaKey, nil, []byte(\"WhatsApp Media Retry Notification\"), 32)\n}\n\nfunc encryptMediaRetryReceipt(messageID types.MessageID, mediaKey []byte) (ciphertext, iv []byte, err error) {\n\treceipt := &waProto.ServerErrorReceipt{\n\t\tStanzaID: proto.String(messageID),\n\t}\n\tvar plaintext []byte\n\tplaintext, err = proto.Marshal(receipt)\n\tif err != nil {\n\t\terr = fmt.Errorf(\"failed to marshal payload: %w\", err)\n\t\treturn\n\t}\n\tiv = random.Bytes(12)\n\tciphertext, err = gcmutil.Encrypt(getMediaRetryKey(mediaKey), iv, plaintext, []byte(messageID))\n\treturn\n}\n\n// SendMediaRetryReceipt sends a request to the phone to re-upload the media in a message.\n//\n// This is mostly relevant when handling history syncs and getting a 404 or 410 error downloading media.\n// Rough example on how to use it (will not work out of the box, you must adjust it depending on what you need exactly):\n//\n//\tvar mediaRetryCache map[types.MessageID]*waProto.ImageMessage\n//\n//\tevt, err := cli.ParseWebMessage(chatJID, historyMsg.GetMessage())\n//\timageMsg := evt.Message.GetImageMessage() // replace this with the part of the message you want to download\n//\tdata, err := cli.Download(imageMsg)\n//\tif errors.Is(err, whatsmeow.ErrMediaDownloadFailedWith404) || errors.Is(err, whatsmeow.ErrMediaDownloadFailedWith410) {\n//\t  err = cli.SendMediaRetryReceipt(&evt.Info, imageMsg.GetMediaKey())\n//\t  // You need to store the event data somewhere as it's necessary for handling the retry response.\n//\t  mediaRetryCache[evt.Info.ID] = imageMsg\n//\t}\n//\n// The response will come as an *events.MediaRetry. The response will then have to be decrypted\n// using DecryptMediaRetryNotification and the same media key passed here. If the media retry was successful,\n// the decrypted notification should contain an updated DirectPath, which can be used to download the file.\n//\n//\tfunc eventHandler(rawEvt interface{}) {\n//\t  switch evt := rawEvt.(type) {\n//\t  case *events.MediaRetry:\n//\t    imageMsg := mediaRetryCache[evt.MessageID]\n//\t    retryData, err := whatsmeow.DecryptMediaRetryNotification(evt, imageMsg.GetMediaKey())\n//\t    if err != nil || retryData.GetResult != waProto.MediaRetryNotification_SUCCESS {\n//\t      return\n//\t    }\n//\t    // Use the new path to download the attachment\n//\t    imageMsg.DirectPath = retryData.DirectPath\n//\t    data, err := cli.Download(imageMsg)\n//\t    // Alternatively, you can use cli.DownloadMediaWithPath and provide the individual fields manually.\n//\t  }\n//\t}\nfunc (cli *Client) SendMediaRetryReceipt(message *types.MessageInfo, mediaKey []byte) error {\n\tciphertext, iv, err := encryptMediaRetryReceipt(message.ID, mediaKey)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to prepare encrypted retry receipt: %w\", err)\n\t}\n\townID := cli.getOwnID().ToNonAD()\n\tif ownID.IsEmpty() {\n\t\treturn ErrNotLoggedIn\n\t}\n\n\trmrAttrs := waBinary.Attrs{\n\t\t\"jid\":     message.Chat,\n\t\t\"from_me\": message.IsFromMe,\n\t}\n\tif message.IsGroup {\n\t\trmrAttrs[\"participant\"] = message.Sender\n\t}\n\n\tencryptedRequest := []waBinary.Node{\n\t\t{Tag: \"enc_p\", Content: ciphertext},\n\t\t{Tag: \"enc_iv\", Content: iv},\n\t}\n\n\terr = cli.sendNode(waBinary.Node{\n\t\tTag: \"receipt\",\n\t\tAttrs: waBinary.Attrs{\n\t\t\t\"id\":   message.ID,\n\t\t\t\"to\":   ownID,\n\t\t\t\"type\": \"server-error\",\n\t\t},\n\t\tContent: []waBinary.Node{\n\t\t\t{Tag: \"encrypt\", Content: encryptedRequest},\n\t\t\t{Tag: \"rmr\", Attrs: rmrAttrs},\n\t\t},\n\t})\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}\n\n// DecryptMediaRetryNotification decrypts a media retry notification using the media key.\n// See Client.SendMediaRetryReceipt for more info on how to use this.\nfunc DecryptMediaRetryNotification(evt *events.MediaRetry, mediaKey []byte) (*waProto.MediaRetryNotification, error) {\n\tvar notif waProto.MediaRetryNotification\n\tif evt.Error != nil && evt.Ciphertext == nil {\n\t\tif evt.Error.Code == 2 {\n\t\t\treturn nil, ErrMediaNotAvailableOnPhone\n\t\t}\n\t\treturn nil, fmt.Errorf(\"%w (code: %d)\", ErrUnknownMediaRetryError, evt.Error.Code)\n\t} else if plaintext, err := gcmutil.Decrypt(getMediaRetryKey(mediaKey), evt.IV, evt.Ciphertext, []byte(evt.MessageID)); err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to decrypt notification: %w\", err)\n\t} else if err = proto.Unmarshal(plaintext, &notif); err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to unmarshal notification (invalid encryption key?): %w\", err)\n\t} else {\n\t\treturn &notif, nil\n\t}\n}\n\nfunc parseMediaRetryNotification(node *waBinary.Node) (*events.MediaRetry, error) {\n\tag := node.AttrGetter()\n\tvar evt events.MediaRetry\n\tevt.Timestamp = ag.UnixTime(\"t\")\n\tevt.MessageID = types.MessageID(ag.String(\"id\"))\n\tif !ag.OK() {\n\t\treturn nil, ag.Error()\n\t}\n\trmr, ok := node.GetOptionalChildByTag(\"rmr\")\n\tif !ok {\n\t\treturn nil, &ElementMissingError{Tag: \"rmr\", In: \"retry notification\"}\n\t}\n\trmrAG := rmr.AttrGetter()\n\tevt.ChatID = rmrAG.JID(\"jid\")\n\tevt.FromMe = rmrAG.Bool(\"from_me\")\n\tevt.SenderID = rmrAG.OptionalJIDOrEmpty(\"participant\")\n\tif !rmrAG.OK() {\n\t\treturn nil, fmt.Errorf(\"missing attributes in <rmr> tag: %w\", rmrAG.Error())\n\t}\n\n\terrNode, ok := node.GetOptionalChildByTag(\"error\")\n\tif ok {\n\t\tevt.Error = &events.MediaRetryError{\n\t\t\tCode: errNode.AttrGetter().Int(\"code\"),\n\t\t}\n\t\treturn &evt, nil\n\t}\n\n\tevt.Ciphertext, ok = node.GetChildByTag(\"encrypt\", \"enc_p\").Content.([]byte)\n\tif !ok {\n\t\treturn nil, &ElementMissingError{Tag: \"enc_p\", In: fmt.Sprintf(\"retry notification %s\", evt.MessageID)}\n\t}\n\tevt.IV, ok = node.GetChildByTag(\"encrypt\", \"enc_iv\").Content.([]byte)\n\tif !ok {\n\t\treturn nil, &ElementMissingError{Tag: \"enc_iv\", In: fmt.Sprintf(\"retry notification %s\", evt.MessageID)}\n\t}\n\treturn &evt, nil\n}\n\nfunc (cli *Client) handleMediaRetryNotification(node *waBinary.Node) {\n\tevt, err := parseMediaRetryNotification(node)\n\tif err != nil {\n\t\tcli.Log.Warnf(\"Failed to parse media retry notification: %v\", err)\n\t\treturn\n\t}\n\tcli.dispatchEvent(evt)\n}\n"
        },
        {
          "name": "message.go",
          "type": "blob",
          "size": 23.189453125,
          "content": "// Copyright (c) 2021 Tulir Asokan\n//\n// This Source Code Form is subject to the terms of the Mozilla Public\n// License, v. 2.0. If a copy of the MPL was not distributed with this\n// file, You can obtain one at http://mozilla.org/MPL/2.0/.\n\npackage whatsmeow\n\nimport (\n\t\"bytes\"\n\t\"compress/zlib\"\n\t\"encoding/hex\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"runtime/debug\"\n\t\"time\"\n\n\t\"go.mau.fi/whatsmeow/proto/waE2E\"\n\n\t\"go.mau.fi/libsignal/groups\"\n\t\"go.mau.fi/libsignal/protocol\"\n\t\"go.mau.fi/libsignal/session\"\n\t\"go.mau.fi/libsignal/signalerror\"\n\t\"go.mau.fi/util/random\"\n\t\"google.golang.org/protobuf/proto\"\n\n\t\"go.mau.fi/whatsmeow/appstate\"\n\twaBinary \"go.mau.fi/whatsmeow/binary\"\n\twaProto \"go.mau.fi/whatsmeow/binary/proto\"\n\t\"go.mau.fi/whatsmeow/store\"\n\t\"go.mau.fi/whatsmeow/types\"\n\t\"go.mau.fi/whatsmeow/types/events\"\n)\n\nvar pbSerializer = store.SignalProtobufSerializer\n\nfunc (cli *Client) handleEncryptedMessage(node *waBinary.Node) {\n\tinfo, err := cli.parseMessageInfo(node)\n\tif err != nil {\n\t\tcli.Log.Warnf(\"Failed to parse message: %v\", err)\n\t} else {\n\t\tif info.VerifiedName != nil && len(info.VerifiedName.Details.GetVerifiedName()) > 0 {\n\t\t\tgo cli.updateBusinessName(info.Sender, info, info.VerifiedName.Details.GetVerifiedName())\n\t\t}\n\t\tif len(info.PushName) > 0 && info.PushName != \"-\" {\n\t\t\tgo cli.updatePushName(info.Sender, info, info.PushName)\n\t\t}\n\t\tgo cli.sendAck(node)\n\t\tif info.Sender.Server == types.NewsletterServer {\n\t\t\tcli.handlePlaintextMessage(info, node)\n\t\t} else {\n\t\t\tcli.decryptMessages(info, node)\n\t\t}\n\t}\n}\n\nfunc (cli *Client) parseMessageSource(node *waBinary.Node, requireParticipant bool) (source types.MessageSource, err error) {\n\tclientID := cli.getOwnID()\n\tif clientID.IsEmpty() {\n\t\terr = ErrNotLoggedIn\n\t\treturn\n\t}\n\tag := node.AttrGetter()\n\tfrom := ag.JID(\"from\")\n\tif from.Server == types.GroupServer || from.Server == types.BroadcastServer {\n\t\tsource.IsGroup = true\n\t\tsource.Chat = from\n\t\tif requireParticipant {\n\t\t\tsource.Sender = ag.JID(\"participant\")\n\t\t} else {\n\t\t\tsource.Sender = ag.OptionalJIDOrEmpty(\"participant\")\n\t\t}\n\t\tif source.Sender.User == clientID.User {\n\t\t\tsource.IsFromMe = true\n\t\t}\n\t\tif from.Server == types.BroadcastServer {\n\t\t\tsource.BroadcastListOwner = ag.OptionalJIDOrEmpty(\"recipient\")\n\t\t}\n\t} else if from.Server == types.NewsletterServer {\n\t\tsource.Chat = from\n\t\tsource.Sender = from\n\t\t// TODO IsFromMe?\n\t} else if from.User == clientID.User {\n\t\tsource.IsFromMe = true\n\t\tsource.Sender = from\n\t\trecipient := ag.OptionalJID(\"recipient\")\n\t\tif recipient != nil {\n\t\t\tsource.Chat = *recipient\n\t\t} else {\n\t\t\tsource.Chat = from.ToNonAD()\n\t\t}\n\t} else if from.IsBot() {\n\t\tsource.Sender = from\n\t\tmeta := node.GetChildByTag(\"meta\")\n\t\tag = meta.AttrGetter()\n\t\ttargetChatJID := ag.OptionalJID(\"target_chat_jid\")\n\t\tif targetChatJID != nil {\n\t\t\tsource.Chat = targetChatJID.ToNonAD()\n\t\t} else {\n\t\t\tsource.Chat = from\n\t\t}\n\t} else {\n\t\tsource.Chat = from.ToNonAD()\n\t\tsource.Sender = from\n\t}\n\terr = ag.Error()\n\treturn\n}\n\nfunc (cli *Client) parseMsgBotInfo(node waBinary.Node) (botInfo types.MsgBotInfo, err error) {\n\tbotNode := node.GetChildByTag(\"bot\")\n\n\tag := botNode.AttrGetter()\n\tbotInfo.EditType = types.BotEditType(ag.String(\"edit\"))\n\tif botInfo.EditType == types.EditTypeInner || botInfo.EditType == types.EditTypeLast {\n\t\tbotInfo.EditTargetID = types.MessageID(ag.String(\"edit_target_id\"))\n\t\tbotInfo.EditSenderTimestampMS = ag.UnixMilli(\"sender_timestamp_ms\")\n\t}\n\terr = ag.Error()\n\treturn\n}\n\nfunc (cli *Client) parseMsgMetaInfo(node waBinary.Node) (metaInfo types.MsgMetaInfo, err error) {\n\tmetaNode := node.GetChildByTag(\"meta\")\n\n\tag := metaNode.AttrGetter()\n\tmetaInfo.TargetID = types.MessageID(ag.String(\"target_id\"))\n\ttargetSenderJID := ag.OptionalJIDOrEmpty(\"target_sender_jid\")\n\tif targetSenderJID.User != \"\" {\n\t\tmetaInfo.TargetSender = targetSenderJID\n\t}\n\terr = ag.Error()\n\treturn\n}\n\nfunc (cli *Client) parseMessageInfo(node *waBinary.Node) (*types.MessageInfo, error) {\n\tvar info types.MessageInfo\n\tvar err error\n\tinfo.MessageSource, err = cli.parseMessageSource(node, true)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tag := node.AttrGetter()\n\tinfo.ID = types.MessageID(ag.String(\"id\"))\n\tinfo.ServerID = types.MessageServerID(ag.OptionalInt(\"server_id\"))\n\tinfo.Timestamp = ag.UnixTime(\"t\")\n\tinfo.PushName = ag.OptionalString(\"notify\")\n\tinfo.Category = ag.OptionalString(\"category\")\n\tinfo.Type = ag.OptionalString(\"type\")\n\tinfo.Edit = types.EditAttribute(ag.OptionalString(\"edit\"))\n\tif !ag.OK() {\n\t\treturn nil, ag.Error()\n\t}\n\n\tfor _, child := range node.GetChildren() {\n\t\tswitch child.Tag {\n\t\tcase \"multicast\":\n\t\t\tinfo.Multicast = true\n\t\tcase \"verified_name\":\n\t\t\tinfo.VerifiedName, err = parseVerifiedNameContent(child)\n\t\t\tif err != nil {\n\t\t\t\tcli.Log.Warnf(\"Failed to parse verified_name node in %s: %v\", info.ID, err)\n\t\t\t}\n\t\tcase \"bot\":\n\t\t\tinfo.MsgBotInfo, err = cli.parseMsgBotInfo(child)\n\t\t\tif err != nil {\n\t\t\t\tcli.Log.Warnf(\"Failed to parse <bot> node in %s: %v\", info.ID, err)\n\t\t\t}\n\t\tcase \"meta\":\n\t\t\t// TODO parse non-bot metadata too\n\t\t\tinfo.MsgMetaInfo, _ = cli.parseMsgMetaInfo(child)\n\t\tcase \"franking\":\n\t\t\t// TODO\n\t\tcase \"trace\":\n\t\t\t// TODO\n\t\tdefault:\n\t\t\tif mediaType, ok := child.AttrGetter().GetString(\"mediatype\", false); ok {\n\t\t\t\tinfo.MediaType = mediaType\n\t\t\t}\n\t\t}\n\t}\n\n\treturn &info, nil\n}\n\nfunc (cli *Client) handlePlaintextMessage(info *types.MessageInfo, node *waBinary.Node) {\n\t// TODO edits have an additional <meta msg_edit_t=\"1696321271735\" original_msg_t=\"1696321248\"/> node\n\tplaintext, ok := node.GetOptionalChildByTag(\"plaintext\")\n\tif !ok {\n\t\t// 3:\n\t\treturn\n\t}\n\tplaintextBody, ok := plaintext.Content.([]byte)\n\tif !ok {\n\t\tcli.Log.Warnf(\"Plaintext message from %s doesn't have byte content\", info.SourceString())\n\t\treturn\n\t}\n\tvar msg waProto.Message\n\terr := proto.Unmarshal(plaintextBody, &msg)\n\tif err != nil {\n\t\tcli.Log.Warnf(\"Error unmarshaling plaintext message from %s: %v\", info.SourceString(), err)\n\t\treturn\n\t}\n\tcli.storeMessageSecret(info, &msg)\n\tevt := &events.Message{\n\t\tInfo:       *info,\n\t\tRawMessage: &msg,\n\t}\n\tmeta, ok := node.GetOptionalChildByTag(\"meta\")\n\tif ok {\n\t\tevt.NewsletterMeta = &events.NewsletterMessageMeta{\n\t\t\tEditTS:     meta.AttrGetter().UnixMilli(\"msg_edit_t\"),\n\t\t\tOriginalTS: meta.AttrGetter().UnixTime(\"original_msg_t\"),\n\t\t}\n\t}\n\tcli.dispatchEvent(evt.UnwrapRaw())\n\treturn\n}\n\nfunc (cli *Client) decryptMessages(info *types.MessageInfo, node *waBinary.Node) {\n\tunavailableNode, ok := node.GetOptionalChildByTag(\"unavailable\")\n\tif ok && len(node.GetChildrenByTag(\"enc\")) == 0 {\n\t\tuType := events.UnavailableType(unavailableNode.AttrGetter().String(\"type\"))\n\t\tcli.Log.Warnf(\"Unavailable message %s from %s (type: %q)\", info.ID, info.SourceString(), uType)\n\t\tgo cli.delayedRequestMessageFromPhone(info)\n\t\tcli.dispatchEvent(&events.UndecryptableMessage{Info: *info, IsUnavailable: true, UnavailableType: uType})\n\t\treturn\n\t}\n\n\tchildren := node.GetChildren()\n\tcli.Log.Debugf(\"Decrypting message from %s\", info.SourceString())\n\thandled := false\n\tcontainsDirectMsg := false\n\tfor _, child := range children {\n\t\tif child.Tag != \"enc\" {\n\t\t\tcontinue\n\t\t}\n\t\tag := child.AttrGetter()\n\t\tencType, ok := ag.GetString(\"type\", false)\n\t\tif !ok {\n\t\t\tcontinue\n\t\t}\n\t\tvar decrypted []byte\n\t\tvar err error\n\t\tif encType == \"pkmsg\" || encType == \"msg\" {\n\t\t\tdecrypted, err = cli.decryptDM(&child, info.Sender, encType == \"pkmsg\")\n\t\t\tcontainsDirectMsg = true\n\t\t} else if info.IsGroup && encType == \"skmsg\" {\n\t\t\tdecrypted, err = cli.decryptGroupMsg(&child, info.Sender, info.Chat)\n\t\t} else if encType == \"msmsg\" && info.Sender.IsBot() {\n\t\t\t// Meta AI / other bots (biz?):\n\n\t\t\t// step 1: get message secret\n\t\t\ttargetSenderJID := info.MsgMetaInfo.TargetSender\n\t\t\tif targetSenderJID.User == \"\" {\n\t\t\t\t// if no targetSenderJID in <meta> this must be ourselves (one-one-one mode)\n\t\t\t\ttargetSenderJID = cli.getOwnID()\n\t\t\t}\n\n\t\t\tmessageSecret, err := cli.Store.MsgSecrets.GetMessageSecret(info.Chat, targetSenderJID, info.MsgMetaInfo.TargetID)\n\t\t\tif err != nil || messageSecret == nil {\n\t\t\t\tcli.Log.Warnf(\"Error getting message secret for bot msg with id %s\", node.AttrGetter().String(\"id\"))\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\t// step 2: get MessageSecretMessage\n\t\t\tbyteContents := child.Content.([]byte) // <enc> contents\n\t\t\tvar msMsg waE2E.MessageSecretMessage\n\n\t\t\terr = proto.Unmarshal(byteContents, &msMsg)\n\t\t\tif err != nil {\n\t\t\t\tcli.Log.Warnf(\"Error decoding MessageSecretMesage protobuf %v\", err)\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\t// step 3: determine best message id for decryption\n\t\t\tvar messageID string\n\t\t\tif info.MsgBotInfo.EditType == types.EditTypeInner || info.MsgBotInfo.EditType == types.EditTypeLast {\n\t\t\t\tmessageID = info.MsgBotInfo.EditTargetID\n\t\t\t} else {\n\t\t\t\tmessageID = info.ID\n\t\t\t}\n\n\t\t\t// step 4: decrypt and voila\n\t\t\tdecrypted, err = cli.decryptBotMessage(messageSecret, &msMsg, messageID, targetSenderJID, info)\n\t\t} else {\n\t\t\tcli.Log.Warnf(\"Unhandled encrypted message (type %s) from %s\", encType, info.SourceString())\n\t\t\tcontinue\n\t\t}\n\n\t\tif err != nil {\n\t\t\tcli.Log.Warnf(\"Error decrypting message from %s: %v\", info.SourceString(), err)\n\t\t\tisUnavailable := encType == \"skmsg\" && !containsDirectMsg && errors.Is(err, signalerror.ErrNoSenderKeyForUser)\n\t\t\tgo cli.sendRetryReceipt(node, info, isUnavailable)\n\t\t\tcli.dispatchEvent(&events.UndecryptableMessage{\n\t\t\t\tInfo:            *info,\n\t\t\t\tIsUnavailable:   isUnavailable,\n\t\t\t\tDecryptFailMode: events.DecryptFailMode(ag.OptionalString(\"decrypt-fail\")),\n\t\t\t})\n\t\t\treturn\n\t\t}\n\t\tretryCount := ag.OptionalInt(\"count\")\n\t\tcli.cancelDelayedRequestFromPhone(info.ID)\n\n\t\tvar msg waE2E.Message\n\t\tswitch ag.Int(\"v\") {\n\t\tcase 2:\n\t\t\terr = proto.Unmarshal(decrypted, &msg)\n\t\t\tif err != nil {\n\t\t\t\tcli.Log.Warnf(\"Error unmarshaling decrypted message from %s: %v\", info.SourceString(), err)\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tcli.handleDecryptedMessage(info, &msg, retryCount)\n\t\t\thandled = true\n\t\tcase 3:\n\t\t\thandled = cli.handleDecryptedArmadillo(info, decrypted, retryCount)\n\t\tdefault:\n\t\t\tcli.Log.Warnf(\"Unknown version %d in decrypted message from %s\", ag.Int(\"v\"), info.SourceString())\n\t\t}\n\t}\n\tif handled {\n\t\tgo cli.sendMessageReceipt(info)\n\t}\n}\n\nfunc (cli *Client) clearUntrustedIdentity(target types.JID) {\n\terr := cli.Store.Identities.DeleteIdentity(target.SignalAddress().String())\n\tif err != nil {\n\t\tcli.Log.Warnf(\"Failed to delete untrusted identity of %s from store: %v\", target, err)\n\t}\n\terr = cli.Store.Sessions.DeleteSession(target.SignalAddress().String())\n\tif err != nil {\n\t\tcli.Log.Warnf(\"Failed to delete session with %s (untrusted identity) from store: %v\", target, err)\n\t}\n\tcli.dispatchEvent(&events.IdentityChange{JID: target, Timestamp: time.Now(), Implicit: true})\n}\n\nfunc (cli *Client) decryptDM(child *waBinary.Node, from types.JID, isPreKey bool) ([]byte, error) {\n\tcontent, _ := child.Content.([]byte)\n\n\tbuilder := session.NewBuilderFromSignal(cli.Store, from.SignalAddress(), pbSerializer)\n\tcipher := session.NewCipher(builder, from.SignalAddress())\n\tvar plaintext []byte\n\tif isPreKey {\n\t\tpreKeyMsg, err := protocol.NewPreKeySignalMessageFromBytes(content, pbSerializer.PreKeySignalMessage, pbSerializer.SignalMessage)\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"failed to parse prekey message: %w\", err)\n\t\t}\n\t\tplaintext, _, err = cipher.DecryptMessageReturnKey(preKeyMsg)\n\t\tif cli.AutoTrustIdentity && errors.Is(err, signalerror.ErrUntrustedIdentity) {\n\t\t\tcli.Log.Warnf(\"Got %v error while trying to decrypt prekey message from %s, clearing stored identity and retrying\", err, from)\n\t\t\tcli.clearUntrustedIdentity(from)\n\t\t\tplaintext, _, err = cipher.DecryptMessageReturnKey(preKeyMsg)\n\t\t}\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"failed to decrypt prekey message: %w\", err)\n\t\t}\n\t} else {\n\t\tmsg, err := protocol.NewSignalMessageFromBytes(content, pbSerializer.SignalMessage)\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"failed to parse normal message: %w\", err)\n\t\t}\n\t\tplaintext, err = cipher.Decrypt(msg)\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"failed to decrypt normal message: %w\", err)\n\t\t}\n\t}\n\tif child.AttrGetter().Int(\"v\") == 3 {\n\t\treturn plaintext, nil\n\t}\n\treturn unpadMessage(plaintext)\n}\n\nfunc (cli *Client) decryptGroupMsg(child *waBinary.Node, from types.JID, chat types.JID) ([]byte, error) {\n\tcontent, _ := child.Content.([]byte)\n\n\tsenderKeyName := protocol.NewSenderKeyName(chat.String(), from.SignalAddress())\n\tbuilder := groups.NewGroupSessionBuilder(cli.Store, pbSerializer)\n\tcipher := groups.NewGroupCipher(builder, senderKeyName, cli.Store)\n\tmsg, err := protocol.NewSenderKeyMessageFromBytes(content, pbSerializer.SenderKeyMessage)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to parse group message: %w\", err)\n\t}\n\tplaintext, err := cipher.Decrypt(msg)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to decrypt group message: %w\", err)\n\t}\n\tif child.AttrGetter().Int(\"v\") == 3 {\n\t\treturn plaintext, nil\n\t}\n\treturn unpadMessage(plaintext)\n}\n\nconst checkPadding = true\n\nfunc isValidPadding(plaintext []byte) bool {\n\tlastByte := plaintext[len(plaintext)-1]\n\texpectedPadding := bytes.Repeat([]byte{lastByte}, int(lastByte))\n\treturn bytes.HasSuffix(plaintext, expectedPadding)\n}\n\nfunc unpadMessage(plaintext []byte) ([]byte, error) {\n\tif len(plaintext) == 0 {\n\t\treturn nil, fmt.Errorf(\"plaintext is empty\")\n\t}\n\tif checkPadding && !isValidPadding(plaintext) {\n\t\treturn nil, fmt.Errorf(\"plaintext doesn't have expected padding\")\n\t}\n\treturn plaintext[:len(plaintext)-int(plaintext[len(plaintext)-1])], nil\n}\n\nfunc padMessage(plaintext []byte) []byte {\n\tpad := random.Bytes(1)\n\tpad[0] &= 0xf\n\tif pad[0] == 0 {\n\t\tpad[0] = 0xf\n\t}\n\tplaintext = append(plaintext, bytes.Repeat(pad, int(pad[0]))...)\n\treturn plaintext\n}\n\nfunc (cli *Client) handleSenderKeyDistributionMessage(chat, from types.JID, axolotlSKDM []byte) {\n\tbuilder := groups.NewGroupSessionBuilder(cli.Store, pbSerializer)\n\tsenderKeyName := protocol.NewSenderKeyName(chat.String(), from.SignalAddress())\n\tsdkMsg, err := protocol.NewSenderKeyDistributionMessageFromBytes(axolotlSKDM, pbSerializer.SenderKeyDistributionMessage)\n\tif err != nil {\n\t\tcli.Log.Errorf(\"Failed to parse sender key distribution message from %s for %s: %v\", from, chat, err)\n\t\treturn\n\t}\n\tbuilder.Process(senderKeyName, sdkMsg)\n\tcli.Log.Debugf(\"Processed sender key distribution message from %s in %s\", senderKeyName.Sender().String(), senderKeyName.GroupID())\n}\n\nfunc (cli *Client) handleHistorySyncNotificationLoop() {\n\tdefer func() {\n\t\tcli.historySyncHandlerStarted.Store(false)\n\t\terr := recover()\n\t\tif err != nil {\n\t\t\tcli.Log.Errorf(\"History sync handler panicked: %v\\n%s\", err, debug.Stack())\n\t\t}\n\n\t\t// Check in case something new appeared in the channel between the loop stopping\n\t\t// and the atomic variable being updated. If yes, restart the loop.\n\t\tif len(cli.historySyncNotifications) > 0 && cli.historySyncHandlerStarted.CompareAndSwap(false, true) {\n\t\t\tcli.Log.Warnf(\"New history sync notifications appeared after loop stopped, restarting loop...\")\n\t\t\tgo cli.handleHistorySyncNotificationLoop()\n\t\t}\n\t}()\n\tfor notif := range cli.historySyncNotifications {\n\t\tcli.handleHistorySyncNotification(notif)\n\t}\n}\n\nfunc (cli *Client) handleHistorySyncNotification(notif *waProto.HistorySyncNotification) {\n\tvar historySync waProto.HistorySync\n\tif data, err := cli.Download(notif); err != nil {\n\t\tcli.Log.Errorf(\"Failed to download history sync data: %v\", err)\n\t} else if reader, err := zlib.NewReader(bytes.NewReader(data)); err != nil {\n\t\tcli.Log.Errorf(\"Failed to create zlib reader for history sync data: %v\", err)\n\t} else if rawData, err := io.ReadAll(reader); err != nil {\n\t\tcli.Log.Errorf(\"Failed to decompress history sync data: %v\", err)\n\t} else if err = proto.Unmarshal(rawData, &historySync); err != nil {\n\t\tcli.Log.Errorf(\"Failed to unmarshal history sync data: %v\", err)\n\t} else {\n\t\tcli.Log.Debugf(\"Received history sync (type %s, chunk %d)\", historySync.GetSyncType(), historySync.GetChunkOrder())\n\t\tif historySync.GetSyncType() == waProto.HistorySync_PUSH_NAME {\n\t\t\tgo cli.handleHistoricalPushNames(historySync.GetPushnames())\n\t\t} else if len(historySync.GetConversations()) > 0 {\n\t\t\tgo cli.storeHistoricalMessageSecrets(historySync.GetConversations())\n\t\t}\n\t\tcli.dispatchEvent(&events.HistorySync{\n\t\t\tData: &historySync,\n\t\t})\n\t}\n}\n\nfunc (cli *Client) handleAppStateSyncKeyShare(keys *waProto.AppStateSyncKeyShare) {\n\tonlyResyncIfNotSynced := true\n\n\tcli.Log.Debugf(\"Got %d new app state keys\", len(keys.GetKeys()))\n\tcli.appStateKeyRequestsLock.RLock()\n\tfor _, key := range keys.GetKeys() {\n\t\tmarshaledFingerprint, err := proto.Marshal(key.GetKeyData().GetFingerprint())\n\t\tif err != nil {\n\t\t\tcli.Log.Errorf(\"Failed to marshal fingerprint of app state sync key %X\", key.GetKeyId().GetKeyId())\n\t\t\tcontinue\n\t\t}\n\t\t_, isReRequest := cli.appStateKeyRequests[hex.EncodeToString(key.GetKeyId().GetKeyId())]\n\t\tif isReRequest {\n\t\t\tonlyResyncIfNotSynced = false\n\t\t}\n\t\terr = cli.Store.AppStateKeys.PutAppStateSyncKey(key.GetKeyId().GetKeyId(), store.AppStateSyncKey{\n\t\t\tData:        key.GetKeyData().GetKeyData(),\n\t\t\tFingerprint: marshaledFingerprint,\n\t\t\tTimestamp:   key.GetKeyData().GetTimestamp(),\n\t\t})\n\t\tif err != nil {\n\t\t\tcli.Log.Errorf(\"Failed to store app state sync key %X: %v\", key.GetKeyId().GetKeyId(), err)\n\t\t\tcontinue\n\t\t}\n\t\tcli.Log.Debugf(\"Received app state sync key %X (ts: %d)\", key.GetKeyId().GetKeyId(), key.GetKeyData().GetTimestamp())\n\t}\n\tcli.appStateKeyRequestsLock.RUnlock()\n\n\tfor _, name := range appstate.AllPatchNames {\n\t\terr := cli.FetchAppState(name, false, onlyResyncIfNotSynced)\n\t\tif err != nil {\n\t\t\tcli.Log.Errorf(\"Failed to do initial fetch of app state %s: %v\", name, err)\n\t\t}\n\t}\n}\n\nfunc (cli *Client) handlePlaceholderResendResponse(msg *waProto.PeerDataOperationRequestResponseMessage) {\n\treqID := msg.GetStanzaId()\n\tparts := msg.GetPeerDataOperationResult()\n\tcli.Log.Debugf(\"Handling response to placeholder resend request %s with %d items\", reqID, len(parts))\n\tfor i, part := range parts {\n\t\tvar webMsg waProto.WebMessageInfo\n\t\tif resp := part.GetPlaceholderMessageResendResponse(); resp == nil {\n\t\t\tcli.Log.Warnf(\"Missing response in item #%d of response to %s\", i+1, reqID)\n\t\t} else if err := proto.Unmarshal(resp.GetWebMessageInfoBytes(), &webMsg); err != nil {\n\t\t\tcli.Log.Warnf(\"Failed to unmarshal protobuf web message in item #%d of response to %s: %v\", i+1, reqID, err)\n\t\t} else if msgEvt, err := cli.ParseWebMessage(types.EmptyJID, &webMsg); err != nil {\n\t\t\tcli.Log.Warnf(\"Failed to parse web message info in item #%d of response to %s: %v\", i+1, reqID, err)\n\t\t} else {\n\t\t\tmsgEvt.UnavailableRequestID = reqID\n\t\t\tcli.dispatchEvent(msgEvt)\n\t\t}\n\t}\n}\n\nfunc (cli *Client) handleProtocolMessage(info *types.MessageInfo, msg *waProto.Message) {\n\tprotoMsg := msg.GetProtocolMessage()\n\n\tif protoMsg.GetHistorySyncNotification() != nil && info.IsFromMe {\n\t\tcli.historySyncNotifications <- protoMsg.HistorySyncNotification\n\t\tif cli.historySyncHandlerStarted.CompareAndSwap(false, true) {\n\t\t\tgo cli.handleHistorySyncNotificationLoop()\n\t\t}\n\t\tgo cli.sendProtocolMessageReceipt(info.ID, types.ReceiptTypeHistorySync)\n\t}\n\n\tif protoMsg.GetPeerDataOperationRequestResponseMessage().GetPeerDataOperationRequestType() == waProto.PeerDataOperationRequestType_PLACEHOLDER_MESSAGE_RESEND {\n\t\tgo cli.handlePlaceholderResendResponse(protoMsg.GetPeerDataOperationRequestResponseMessage())\n\t}\n\n\tif protoMsg.GetAppStateSyncKeyShare() != nil && info.IsFromMe {\n\t\tgo cli.handleAppStateSyncKeyShare(protoMsg.AppStateSyncKeyShare)\n\t}\n\n\tif info.Category == \"peer\" {\n\t\tgo cli.sendProtocolMessageReceipt(info.ID, types.ReceiptTypePeerMsg)\n\t}\n}\n\nfunc (cli *Client) processProtocolParts(info *types.MessageInfo, msg *waProto.Message) {\n\t// Hopefully sender key distribution messages and protocol messages can't be inside ephemeral messages\n\tif msg.GetDeviceSentMessage().GetMessage() != nil {\n\t\tmsg = msg.GetDeviceSentMessage().GetMessage()\n\t}\n\tif msg.GetSenderKeyDistributionMessage() != nil {\n\t\tif !info.IsGroup {\n\t\t\tcli.Log.Warnf(\"Got sender key distribution message in non-group chat from %s\", info.Sender)\n\t\t} else {\n\t\t\tcli.handleSenderKeyDistributionMessage(info.Chat, info.Sender, msg.SenderKeyDistributionMessage.AxolotlSenderKeyDistributionMessage)\n\t\t}\n\t}\n\t// N.B. Edits are protocol messages, but they're also wrapped inside EditedMessage,\n\t// which is only unwrapped after processProtocolParts, so this won't trigger for edits.\n\tif msg.GetProtocolMessage() != nil {\n\t\tcli.handleProtocolMessage(info, msg)\n\t}\n\tcli.storeMessageSecret(info, msg)\n}\n\nfunc (cli *Client) storeMessageSecret(info *types.MessageInfo, msg *waProto.Message) {\n\tif msgSecret := msg.GetMessageContextInfo().GetMessageSecret(); len(msgSecret) > 0 {\n\t\terr := cli.Store.MsgSecrets.PutMessageSecret(info.Chat, info.Sender, info.ID, msgSecret)\n\t\tif err != nil {\n\t\t\tcli.Log.Errorf(\"Failed to store message secret key for %s: %v\", info.ID, err)\n\t\t} else {\n\t\t\tcli.Log.Debugf(\"Stored message secret key for %s\", info.ID)\n\t\t}\n\t}\n}\n\nfunc (cli *Client) storeHistoricalMessageSecrets(conversations []*waProto.Conversation) {\n\tvar secrets []store.MessageSecretInsert\n\tvar privacyTokens []store.PrivacyToken\n\townID := cli.getOwnID().ToNonAD()\n\tif ownID.IsEmpty() {\n\t\treturn\n\t}\n\tfor _, conv := range conversations {\n\t\tchatJID, _ := types.ParseJID(conv.GetId())\n\t\tif chatJID.IsEmpty() {\n\t\t\tcontinue\n\t\t}\n\t\tif chatJID.Server == types.DefaultUserServer && conv.GetTcToken() != nil {\n\t\t\tts := conv.GetTcTokenSenderTimestamp()\n\t\t\tif ts == 0 {\n\t\t\t\tts = conv.GetTcTokenTimestamp()\n\t\t\t}\n\t\t\tprivacyTokens = append(privacyTokens, store.PrivacyToken{\n\t\t\t\tUser:      chatJID,\n\t\t\t\tToken:     conv.GetTcToken(),\n\t\t\t\tTimestamp: time.Unix(int64(ts), 0),\n\t\t\t})\n\t\t}\n\t\tfor _, msg := range conv.GetMessages() {\n\t\t\tif secret := msg.GetMessage().GetMessageSecret(); secret != nil {\n\t\t\t\tvar senderJID types.JID\n\t\t\t\tmsgKey := msg.GetMessage().GetKey()\n\t\t\t\tif msgKey.GetFromMe() {\n\t\t\t\t\tsenderJID = ownID\n\t\t\t\t} else if chatJID.Server == types.DefaultUserServer {\n\t\t\t\t\tsenderJID = chatJID\n\t\t\t\t} else if msgKey.GetParticipant() != \"\" {\n\t\t\t\t\tsenderJID, _ = types.ParseJID(msgKey.GetParticipant())\n\t\t\t\t} else if msg.GetMessage().GetParticipant() != \"\" {\n\t\t\t\t\tsenderJID, _ = types.ParseJID(msg.GetMessage().GetParticipant())\n\t\t\t\t}\n\t\t\t\tif senderJID.IsEmpty() || msgKey.GetId() == \"\" {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\tsecrets = append(secrets, store.MessageSecretInsert{\n\t\t\t\t\tChat:   chatJID,\n\t\t\t\t\tSender: senderJID,\n\t\t\t\t\tID:     msgKey.GetId(),\n\t\t\t\t\tSecret: secret,\n\t\t\t\t})\n\t\t\t}\n\t\t}\n\t}\n\tif len(secrets) > 0 {\n\t\tcli.Log.Debugf(\"Storing %d message secret keys in history sync\", len(secrets))\n\t\terr := cli.Store.MsgSecrets.PutMessageSecrets(secrets)\n\t\tif err != nil {\n\t\t\tcli.Log.Errorf(\"Failed to store message secret keys in history sync: %v\", err)\n\t\t} else {\n\t\t\tcli.Log.Infof(\"Stored %d message secret keys from history sync\", len(secrets))\n\t\t}\n\t}\n\tif len(privacyTokens) > 0 {\n\t\tcli.Log.Debugf(\"Storing %d privacy tokens in history sync\", len(privacyTokens))\n\t\terr := cli.Store.PrivacyTokens.PutPrivacyTokens(privacyTokens...)\n\t\tif err != nil {\n\t\t\tcli.Log.Errorf(\"Failed to store privacy tokens in history sync: %v\", err)\n\t\t} else {\n\t\t\tcli.Log.Infof(\"Stored %d privacy tokens from history sync\", len(privacyTokens))\n\t\t}\n\t}\n}\n\nfunc (cli *Client) handleDecryptedMessage(info *types.MessageInfo, msg *waProto.Message, retryCount int) {\n\tcli.processProtocolParts(info, msg)\n\tevt := &events.Message{Info: *info, RawMessage: msg, RetryCount: retryCount}\n\tcli.dispatchEvent(evt.UnwrapRaw())\n}\n\nfunc (cli *Client) sendProtocolMessageReceipt(id types.MessageID, msgType types.ReceiptType) {\n\tclientID := cli.Store.ID\n\tif len(id) == 0 || clientID == nil {\n\t\treturn\n\t}\n\terr := cli.sendNode(waBinary.Node{\n\t\tTag: \"receipt\",\n\t\tAttrs: waBinary.Attrs{\n\t\t\t\"id\":   string(id),\n\t\t\t\"type\": string(msgType),\n\t\t\t\"to\":   types.NewJID(clientID.User, types.LegacyUserServer),\n\t\t},\n\t\tContent: nil,\n\t})\n\tif err != nil {\n\t\tcli.Log.Warnf(\"Failed to send acknowledgement for protocol message %s: %v\", id, err)\n\t}\n}\n"
        },
        {
          "name": "msgsecret.go",
          "type": "blob",
          "size": 10.46484375,
          "content": "// Copyright (c) 2022 Tulir Asokan\n//\n// This Source Code Form is subject to the terms of the Mozilla Public\n// License, v. 2.0. If a copy of the MPL was not distributed with this\n// file, You can obtain one at http://mozilla.org/MPL/2.0/.\n\npackage whatsmeow\n\nimport (\n\t\"crypto/sha256\"\n\t\"fmt\"\n\t\"time\"\n\n\t\"go.mau.fi/whatsmeow/proto/waCommon\"\n\t\"go.mau.fi/whatsmeow/proto/waE2E\"\n\n\t\"go.mau.fi/util/random\"\n\t\"google.golang.org/protobuf/proto\"\n\n\twaProto \"go.mau.fi/whatsmeow/binary/proto\"\n\t\"go.mau.fi/whatsmeow/types\"\n\t\"go.mau.fi/whatsmeow/types/events\"\n\t\"go.mau.fi/whatsmeow/util/gcmutil\"\n\t\"go.mau.fi/whatsmeow/util/hkdfutil\"\n)\n\ntype MsgSecretType string\n\nconst (\n\tEncSecretPollVote MsgSecretType = \"Poll Vote\"\n\tEncSecretReaction MsgSecretType = \"Enc Reaction\"\n\tEncSecretBotMsg   MsgSecretType = \"Bot Message\"\n)\n\nfunc applyBotMessageHKDF(messageSecret []byte) []byte {\n\treturn hkdfutil.SHA256(messageSecret, nil, []byte(EncSecretBotMsg), 32)\n}\n\nfunc generateMsgSecretKey(\n\tmodificationType MsgSecretType, modificationSender types.JID,\n\torigMsgID types.MessageID, origMsgSender types.JID, origMsgSecret []byte,\n) ([]byte, []byte) {\n\torigMsgSenderStr := origMsgSender.ToNonAD().String()\n\tmodificationSenderStr := modificationSender.ToNonAD().String()\n\n\tuseCaseSecret := make([]byte, 0, len(origMsgID)+len(origMsgSenderStr)+len(modificationSenderStr)+len(modificationType))\n\tuseCaseSecret = append(useCaseSecret, origMsgID...)\n\tuseCaseSecret = append(useCaseSecret, origMsgSenderStr...)\n\tuseCaseSecret = append(useCaseSecret, modificationSenderStr...)\n\tuseCaseSecret = append(useCaseSecret, modificationType...)\n\n\tsecretKey := hkdfutil.SHA256(origMsgSecret, nil, useCaseSecret, 32)\n\tadditionalData := []byte(fmt.Sprintf(\"%s\\x00%s\", origMsgID, modificationSenderStr))\n\n\treturn secretKey, additionalData\n}\n\nfunc getOrigSenderFromKey(msg *events.Message, key *waCommon.MessageKey) (types.JID, error) {\n\tif key.GetFromMe() {\n\t\t// fromMe always means the poll and vote were sent by the same user\n\t\treturn msg.Info.Sender, nil\n\t} else if msg.Info.Chat.Server == types.DefaultUserServer {\n\t\tsender, err := types.ParseJID(key.GetRemoteJid())\n\t\tif err != nil {\n\t\t\treturn types.EmptyJID, fmt.Errorf(\"failed to parse JID %q of original message sender: %w\", key.GetRemoteJid(), err)\n\t\t}\n\t\treturn sender, nil\n\t} else {\n\t\tsender, err := types.ParseJID(key.GetParticipant())\n\t\tif sender.Server != types.DefaultUserServer {\n\t\t\terr = fmt.Errorf(\"unexpected server\")\n\t\t}\n\t\tif err != nil {\n\t\t\treturn types.EmptyJID, fmt.Errorf(\"failed to parse JID %q of original message sender: %w\", key.GetParticipant(), err)\n\t\t}\n\t\treturn sender, nil\n\t}\n}\n\ntype messageEncryptedSecret interface {\n\tGetEncIV() []byte\n\tGetEncPayload() []byte\n}\n\nfunc (cli *Client) decryptMsgSecret(msg *events.Message, useCase MsgSecretType, encrypted messageEncryptedSecret, origMsgKey *waCommon.MessageKey) ([]byte, error) {\n\tif cli == nil {\n\t\treturn nil, ErrClientIsNil\n\t}\n\tpollSender, err := getOrigSenderFromKey(msg, origMsgKey)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tbaseEncKey, err := cli.Store.MsgSecrets.GetMessageSecret(msg.Info.Chat, pollSender, origMsgKey.GetID())\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to get original message secret key: %w\", err)\n\t} else if baseEncKey == nil {\n\t\treturn nil, ErrOriginalMessageSecretNotFound\n\t}\n\tsecretKey, additionalData := generateMsgSecretKey(useCase, msg.Info.Sender, origMsgKey.GetID(), pollSender, baseEncKey)\n\tplaintext, err := gcmutil.Decrypt(secretKey, encrypted.GetEncIV(), encrypted.GetEncPayload(), additionalData)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to decrypt secret message: %w\", err)\n\t}\n\treturn plaintext, nil\n}\n\nfunc (cli *Client) encryptMsgSecret(chat, origSender types.JID, origMsgID types.MessageID, useCase MsgSecretType, plaintext []byte) (ciphertext, iv []byte, err error) {\n\tif cli == nil {\n\t\treturn nil, nil, ErrClientIsNil\n\t}\n\townID := cli.getOwnID()\n\tif ownID.IsEmpty() {\n\t\treturn nil, nil, ErrNotLoggedIn\n\t}\n\n\tbaseEncKey, err := cli.Store.MsgSecrets.GetMessageSecret(chat, origSender, origMsgID)\n\tif err != nil {\n\t\treturn nil, nil, fmt.Errorf(\"failed to get original message secret key: %w\", err)\n\t} else if baseEncKey == nil {\n\t\treturn nil, nil, ErrOriginalMessageSecretNotFound\n\t}\n\tsecretKey, additionalData := generateMsgSecretKey(useCase, ownID, origMsgID, origSender, baseEncKey)\n\n\tiv = random.Bytes(12)\n\tciphertext, err = gcmutil.Encrypt(secretKey, iv, plaintext, additionalData)\n\tif err != nil {\n\t\treturn nil, nil, fmt.Errorf(\"failed to encrypt secret message: %w\", err)\n\t}\n\treturn ciphertext, iv, nil\n}\n\nfunc (cli *Client) decryptBotMessage(messageSecret []byte, msMsg messageEncryptedSecret, messageID types.MessageID, targetSenderJID types.JID, info *types.MessageInfo) ([]byte, error) {\n\t// gcm decrypt key generation\n\tnewKey, additionalData := generateMsgSecretKey(\"\", info.Sender, messageID, targetSenderJID, applyBotMessageHKDF(messageSecret))\n\n\tplaintext, err := gcmutil.Decrypt(newKey, msMsg.GetEncIV(), msMsg.GetEncPayload(), additionalData)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to decrypt secret message: %w\", err)\n\t}\n\n\treturn plaintext, nil\n}\n\n// DecryptReaction decrypts a reaction update message. This form of reactions hasn't been rolled out yet,\n// so this function is likely not of much use.\n//\n//\tif evt.Message.GetEncReactionMessage() != nil {\n//\t\treaction, err := cli.DecryptReaction(evt)\n//\t\tif err != nil {\n//\t\t\tfmt.Println(\":(\", err)\n//\t\t\treturn\n//\t\t}\n//\t\tfmt.Printf(\"Reaction message: %+v\\n\", reaction)\n//\t}\nfunc (cli *Client) DecryptReaction(reaction *events.Message) (*waE2E.ReactionMessage, error) {\n\tencReaction := reaction.Message.GetEncReactionMessage()\n\tif encReaction == nil {\n\t\treturn nil, ErrNotEncryptedReactionMessage\n\t}\n\tplaintext, err := cli.decryptMsgSecret(reaction, EncSecretReaction, encReaction, encReaction.GetTargetMessageKey())\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to decrypt reaction: %w\", err)\n\t}\n\tvar msg waE2E.ReactionMessage\n\terr = proto.Unmarshal(plaintext, &msg)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to decode reaction protobuf: %w\", err)\n\t}\n\treturn &msg, nil\n}\n\n// DecryptPollVote decrypts a poll update message. The vote itself includes SHA-256 hashes of the selected options.\n//\n//\tif evt.Message.GetPollUpdateMessage() != nil {\n//\t\tpollVote, err := cli.DecryptPollVote(evt)\n//\t\tif err != nil {\n//\t\t\tfmt.Println(\":(\", err)\n//\t\t\treturn\n//\t\t}\n//\t\tfmt.Println(\"Selected hashes:\")\n//\t\tfor _, hash := range pollVote.GetSelectedOptions() {\n//\t\t\tfmt.Printf(\"- %X\\n\", hash)\n//\t\t}\n//\t}\nfunc (cli *Client) DecryptPollVote(vote *events.Message) (*waE2E.PollVoteMessage, error) {\n\tpollUpdate := vote.Message.GetPollUpdateMessage()\n\tif pollUpdate == nil {\n\t\treturn nil, ErrNotPollUpdateMessage\n\t}\n\tplaintext, err := cli.decryptMsgSecret(vote, EncSecretPollVote, pollUpdate.GetVote(), pollUpdate.GetPollCreationMessageKey())\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to decrypt poll vote: %w\", err)\n\t}\n\tvar msg waE2E.PollVoteMessage\n\terr = proto.Unmarshal(plaintext, &msg)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to decode poll vote protobuf: %w\", err)\n\t}\n\treturn &msg, nil\n}\n\nfunc getKeyFromInfo(msgInfo *types.MessageInfo) *waCommon.MessageKey {\n\tcreationKey := &waCommon.MessageKey{\n\t\tRemoteJID: proto.String(msgInfo.Chat.String()),\n\t\tFromMe:    proto.Bool(msgInfo.IsFromMe),\n\t\tID:        proto.String(msgInfo.ID),\n\t}\n\tif msgInfo.IsGroup {\n\t\tcreationKey.Participant = proto.String(msgInfo.Sender.String())\n\t}\n\treturn creationKey\n}\n\n// HashPollOptions hashes poll option names using SHA-256 for voting.\n// This is used by BuildPollVote to convert selected option names to hashes.\nfunc HashPollOptions(optionNames []string) [][]byte {\n\toptionHashes := make([][]byte, len(optionNames))\n\tfor i, option := range optionNames {\n\t\toptionHash := sha256.Sum256([]byte(option))\n\t\toptionHashes[i] = optionHash[:]\n\t}\n\treturn optionHashes\n}\n\n// BuildPollVote builds a poll vote message using the given poll message info and option names.\n// The built message can be sent normally using Client.SendMessage.\n//\n// For example, to vote for the first option after receiving a message event (*events.Message):\n//\n//\tif evt.Message.GetPollCreationMessage() != nil {\n//\t\tpollVoteMsg, err := cli.BuildPollVote(&evt.Info, []string{evt.Message.GetPollCreationMessage().GetOptions()[0].GetOptionName()})\n//\t\tif err != nil {\n//\t\t\tfmt.Println(\":(\", err)\n//\t\t\treturn\n//\t\t}\n//\t\tresp, err := cli.SendMessage(context.Background(), evt.Info.Chat, pollVoteMsg)\n//\t}\nfunc (cli *Client) BuildPollVote(pollInfo *types.MessageInfo, optionNames []string) (*waProto.Message, error) {\n\tpollUpdate, err := cli.EncryptPollVote(pollInfo, &waProto.PollVoteMessage{\n\t\tSelectedOptions: HashPollOptions(optionNames),\n\t})\n\treturn &waProto.Message{PollUpdateMessage: pollUpdate}, err\n}\n\n// BuildPollCreation builds a poll creation message with the given poll name, options and maximum number of selections.\n// The built message can be sent normally using Client.SendMessage.\n//\n//\tresp, err := cli.SendMessage(context.Background(), chat, cli.BuildPollCreation(\"meow?\", []string{\"yes\", \"no\"}, 1))\nfunc (cli *Client) BuildPollCreation(name string, optionNames []string, selectableOptionCount int) *waProto.Message {\n\tmsgSecret := random.Bytes(32)\n\tif selectableOptionCount < 0 || selectableOptionCount > len(optionNames) {\n\t\tselectableOptionCount = 0\n\t}\n\toptions := make([]*waProto.PollCreationMessage_Option, len(optionNames))\n\tfor i, option := range optionNames {\n\t\toptions[i] = &waProto.PollCreationMessage_Option{OptionName: proto.String(option)}\n\t}\n\treturn &waProto.Message{\n\t\tPollCreationMessage: &waProto.PollCreationMessage{\n\t\t\tName:                   proto.String(name),\n\t\t\tOptions:                options,\n\t\t\tSelectableOptionsCount: proto.Uint32(uint32(selectableOptionCount)),\n\t\t},\n\t\tMessageContextInfo: &waProto.MessageContextInfo{\n\t\t\tMessageSecret: msgSecret,\n\t\t},\n\t}\n}\n\n// EncryptPollVote encrypts a poll vote message. This is a slightly lower-level function, using BuildPollVote is recommended.\nfunc (cli *Client) EncryptPollVote(pollInfo *types.MessageInfo, vote *waProto.PollVoteMessage) (*waProto.PollUpdateMessage, error) {\n\tplaintext, err := proto.Marshal(vote)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to marshal poll vote protobuf: %w\", err)\n\t}\n\tciphertext, iv, err := cli.encryptMsgSecret(pollInfo.Chat, pollInfo.Sender, pollInfo.ID, EncSecretPollVote, plaintext)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to encrypt poll vote: %w\", err)\n\t}\n\treturn &waProto.PollUpdateMessage{\n\t\tPollCreationMessageKey: getKeyFromInfo(pollInfo),\n\t\tVote: &waProto.PollEncValue{\n\t\t\tEncPayload: ciphertext,\n\t\t\tEncIV:      iv,\n\t\t},\n\t\tSenderTimestampMS: proto.Int64(time.Now().UnixMilli()),\n\t}, nil\n}\n"
        },
        {
          "name": "newsletter.go",
          "type": "blob",
          "size": 11.095703125,
          "content": "// Copyright (c) 2023 Tulir Asokan\n//\n// This Source Code Form is subject to the terms of the Mozilla Public\n// License, v. 2.0. If a copy of the MPL was not distributed with this\n// file, You can obtain one at http://mozilla.org/MPL/2.0/.\n\npackage whatsmeow\n\nimport (\n\t\"context\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"strings\"\n\t\"time\"\n\n\twaBinary \"go.mau.fi/whatsmeow/binary\"\n\t\"go.mau.fi/whatsmeow/types\"\n)\n\n// NewsletterSubscribeLiveUpdates subscribes to receive live updates from a WhatsApp channel temporarily (for the duration returned).\nfunc (cli *Client) NewsletterSubscribeLiveUpdates(ctx context.Context, jid types.JID) (time.Duration, error) {\n\tresp, err := cli.sendIQ(infoQuery{\n\t\tContext:   ctx,\n\t\tNamespace: \"newsletter\",\n\t\tType:      iqSet,\n\t\tTo:        jid,\n\t\tContent: []waBinary.Node{{\n\t\t\tTag: \"live_updates\",\n\t\t}},\n\t})\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\tchild := resp.GetChildByTag(\"live_updates\")\n\tdur := child.AttrGetter().Int(\"duration\")\n\treturn time.Duration(dur) * time.Second, nil\n}\n\n// NewsletterMarkViewed marks a channel message as viewed, incrementing the view counter.\n//\n// This is not the same as marking the channel as read on your other devices, use the usual MarkRead function for that.\nfunc (cli *Client) NewsletterMarkViewed(jid types.JID, serverIDs []types.MessageServerID) error {\n\tif cli == nil {\n\t\treturn ErrClientIsNil\n\t}\n\titems := make([]waBinary.Node, len(serverIDs))\n\tfor i, id := range serverIDs {\n\t\titems[i] = waBinary.Node{\n\t\t\tTag: \"item\",\n\t\t\tAttrs: waBinary.Attrs{\n\t\t\t\t\"server_id\": id,\n\t\t\t},\n\t\t}\n\t}\n\treqID := cli.generateRequestID()\n\tresp := cli.waitResponse(reqID)\n\terr := cli.sendNode(waBinary.Node{\n\t\tTag: \"receipt\",\n\t\tAttrs: waBinary.Attrs{\n\t\t\t\"to\":   jid,\n\t\t\t\"type\": \"view\",\n\t\t\t\"id\":   reqID,\n\t\t},\n\t\tContent: []waBinary.Node{{\n\t\t\tTag:     \"list\",\n\t\t\tContent: items,\n\t\t}},\n\t})\n\tif err != nil {\n\t\tcli.cancelResponse(reqID, resp)\n\t\treturn err\n\t}\n\t// TODO handle response?\n\t<-resp\n\treturn nil\n}\n\n// NewsletterSendReaction sends a reaction to a channel message.\n// To remove a reaction sent earlier, set reaction to an empty string.\n//\n// The last parameter is the message ID of the reaction itself. It can be left empty to let whatsmeow generate a random one.\nfunc (cli *Client) NewsletterSendReaction(jid types.JID, serverID types.MessageServerID, reaction string, messageID types.MessageID) error {\n\tif messageID == \"\" {\n\t\tmessageID = cli.GenerateMessageID()\n\t}\n\treactionAttrs := waBinary.Attrs{}\n\tmessageAttrs := waBinary.Attrs{\n\t\t\"to\":        jid,\n\t\t\"id\":        messageID,\n\t\t\"server_id\": serverID,\n\t\t\"type\":      \"reaction\",\n\t}\n\tif reaction != \"\" {\n\t\treactionAttrs[\"code\"] = reaction\n\t} else {\n\t\tmessageAttrs[\"edit\"] = string(types.EditAttributeSenderRevoke)\n\t}\n\treturn cli.sendNode(waBinary.Node{\n\t\tTag:   \"message\",\n\t\tAttrs: messageAttrs,\n\t\tContent: []waBinary.Node{{\n\t\t\tTag:   \"reaction\",\n\t\t\tAttrs: reactionAttrs,\n\t\t}},\n\t})\n}\n\nconst (\n\tqueryFetchNewsletter           = \"6563316087068696\"\n\tqueryFetchNewsletterDehydrated = \"7272540469429201\"\n\tqueryRecommendedNewsletters    = \"7263823273662354\" //variables -> input -> {limit: 20, country_codes: [string]}, output: xwa2_newsletters_recommended\n\tqueryNewslettersDirectory      = \"6190824427689257\" // variables -> input -> {view: \"RECOMMENDED\", limit: 50, start_cursor: base64, filters: {country_codes: [string]}}\n\tquerySubscribedNewsletters     = \"6388546374527196\" // variables -> empty, output: xwa2_newsletter_subscribed\n\tqueryNewsletterSubscribers     = \"9800646650009898\" //variables -> input -> {newsletter_id, count}, output: xwa2_newsletter_subscribers -> subscribers -> edges\n\tmutationMuteNewsletter         = \"6274038279359549\" //variables -> {newsletter_id, updates->{description, settings}}, output: xwa2_newsletter_update -> NewsletterMetadata without viewer meta\n\tmutationUnmuteNewsletter       = \"6068417879924485\"\n\tmutationUpdateNewsletter       = \"7150902998257522\"\n\tmutationCreateNewsletter       = \"6234210096708695\"\n\tmutationUnfollowNewsletter     = \"6392786840836363\"\n\tmutationFollowNewsletter       = \"9926858900719341\"\n)\n\nfunc (cli *Client) sendMexIQ(ctx context.Context, queryID string, variables any) (json.RawMessage, error) {\n\tpayload, err := json.Marshal(map[string]any{\n\t\t\"variables\": variables,\n\t})\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tresp, err := cli.sendIQ(infoQuery{\n\t\tNamespace: \"w:mex\",\n\t\tType:      iqGet,\n\t\tTo:        types.ServerJID,\n\t\tContent: []waBinary.Node{{\n\t\t\tTag: \"query\",\n\t\t\tAttrs: waBinary.Attrs{\n\t\t\t\t\"query_id\": queryID,\n\t\t\t},\n\t\t\tContent: payload,\n\t\t}},\n\t\tContext: ctx,\n\t})\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tresult, ok := resp.GetOptionalChildByTag(\"result\")\n\tif !ok {\n\t\treturn nil, &ElementMissingError{Tag: \"result\", In: \"mex response\"}\n\t}\n\tresultContent, ok := result.Content.([]byte)\n\tif !ok {\n\t\treturn nil, fmt.Errorf(\"unexpected content type %T in mex response\", result.Content)\n\t}\n\tvar gqlResp types.GraphQLResponse\n\terr = json.Unmarshal(resultContent, &gqlResp)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to unmarshal graphql response: %w\", err)\n\t} else if len(gqlResp.Errors) > 0 {\n\t\treturn gqlResp.Data, fmt.Errorf(\"graphql error: %w\", gqlResp.Errors)\n\t}\n\treturn gqlResp.Data, nil\n}\n\ntype respGetNewsletterInfo struct {\n\tNewsletter *types.NewsletterMetadata `json:\"xwa2_newsletter\"`\n}\n\nfunc (cli *Client) getNewsletterInfo(input map[string]any, fetchViewerMeta bool) (*types.NewsletterMetadata, error) {\n\tdata, err := cli.sendMexIQ(context.TODO(), queryFetchNewsletter, map[string]any{\n\t\t\"fetch_creation_time\":   true,\n\t\t\"fetch_full_image\":      true,\n\t\t\"fetch_viewer_metadata\": fetchViewerMeta,\n\t\t\"input\":                 input,\n\t})\n\tvar respData respGetNewsletterInfo\n\tif data != nil {\n\t\tjsonErr := json.Unmarshal(data, &respData)\n\t\tif err == nil && jsonErr != nil {\n\t\t\terr = jsonErr\n\t\t}\n\t}\n\treturn respData.Newsletter, err\n}\n\n// GetNewsletterInfo gets the info of a newsletter that you're joined to.\nfunc (cli *Client) GetNewsletterInfo(jid types.JID) (*types.NewsletterMetadata, error) {\n\treturn cli.getNewsletterInfo(map[string]any{\n\t\t\"key\":  jid.String(),\n\t\t\"type\": types.NewsletterKeyTypeJID,\n\t}, true)\n}\n\n// GetNewsletterInfoWithInvite gets the info of a newsletter with an invite link.\n//\n// You can either pass the full link (https://whatsapp.com/channel/...) or just the `...` part.\n//\n// Note that the ViewerMeta field of the returned NewsletterMetadata will be nil.\nfunc (cli *Client) GetNewsletterInfoWithInvite(key string) (*types.NewsletterMetadata, error) {\n\treturn cli.getNewsletterInfo(map[string]any{\n\t\t\"key\":  strings.TrimPrefix(key, NewsletterLinkPrefix),\n\t\t\"type\": types.NewsletterKeyTypeInvite,\n\t}, false)\n}\n\ntype respGetSubscribedNewsletters struct {\n\tNewsletters []*types.NewsletterMetadata `json:\"xwa2_newsletter_subscribed\"`\n}\n\n// GetSubscribedNewsletters gets the info of all newsletters that you're joined to.\nfunc (cli *Client) GetSubscribedNewsletters() ([]*types.NewsletterMetadata, error) {\n\tdata, err := cli.sendMexIQ(context.TODO(), querySubscribedNewsletters, map[string]any{})\n\tvar respData respGetSubscribedNewsletters\n\tif data != nil {\n\t\tjsonErr := json.Unmarshal(data, &respData)\n\t\tif err == nil && jsonErr != nil {\n\t\t\terr = jsonErr\n\t\t}\n\t}\n\treturn respData.Newsletters, err\n}\n\ntype CreateNewsletterParams struct {\n\tName        string `json:\"name\"`\n\tDescription string `json:\"description,omitempty\"`\n\tPicture     []byte `json:\"picture,omitempty\"`\n}\n\ntype respCreateNewsletter struct {\n\tNewsletter *types.NewsletterMetadata `json:\"xwa2_newsletter_create\"`\n}\n\n// CreateNewsletter creates a new WhatsApp channel.\nfunc (cli *Client) CreateNewsletter(params CreateNewsletterParams) (*types.NewsletterMetadata, error) {\n\tresp, err := cli.sendMexIQ(context.TODO(), mutationCreateNewsletter, map[string]any{\n\t\t\"newsletter_input\": &params,\n\t})\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tvar respData respCreateNewsletter\n\terr = json.Unmarshal(resp, &respData)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn respData.Newsletter, nil\n}\n\n// AcceptTOSNotice accepts a ToS notice.\n//\n// To accept the terms for creating newsletters, use\n//\n//\tcli.AcceptTOSNotice(\"20601218\", \"5\")\nfunc (cli *Client) AcceptTOSNotice(noticeID, stage string) error {\n\t_, err := cli.sendIQ(infoQuery{\n\t\tNamespace: \"tos\",\n\t\tType:      iqSet,\n\t\tTo:        types.ServerJID,\n\t\tContent: []waBinary.Node{{\n\t\t\tTag: \"notice\",\n\t\t\tAttrs: waBinary.Attrs{\n\t\t\t\t\"id\":    noticeID,\n\t\t\t\t\"stage\": stage,\n\t\t\t},\n\t\t}},\n\t})\n\treturn err\n}\n\n// NewsletterToggleMute changes the mute status of a newsletter.\nfunc (cli *Client) NewsletterToggleMute(jid types.JID, mute bool) error {\n\tquery := mutationUnmuteNewsletter\n\tif mute {\n\t\tquery = mutationMuteNewsletter\n\t}\n\t_, err := cli.sendMexIQ(context.TODO(), query, map[string]any{\n\t\t\"newsletter_id\": jid.String(),\n\t})\n\treturn err\n}\n\n// FollowNewsletter makes the user follow (join) a WhatsApp channel.\nfunc (cli *Client) FollowNewsletter(jid types.JID) error {\n\t_, err := cli.sendMexIQ(context.TODO(), mutationFollowNewsletter, map[string]any{\n\t\t\"newsletter_id\": jid.String(),\n\t})\n\treturn err\n}\n\n// UnfollowNewsletter makes the user unfollow (leave) a WhatsApp channel.\nfunc (cli *Client) UnfollowNewsletter(jid types.JID) error {\n\t_, err := cli.sendMexIQ(context.TODO(), mutationUnfollowNewsletter, map[string]any{\n\t\t\"newsletter_id\": jid.String(),\n\t})\n\treturn err\n}\n\ntype GetNewsletterMessagesParams struct {\n\tCount  int\n\tBefore types.MessageServerID\n}\n\n// GetNewsletterMessages gets messages in a WhatsApp channel.\nfunc (cli *Client) GetNewsletterMessages(jid types.JID, params *GetNewsletterMessagesParams) ([]*types.NewsletterMessage, error) {\n\tattrs := waBinary.Attrs{\n\t\t\"type\": \"jid\",\n\t\t\"jid\":  jid,\n\t}\n\tif params != nil {\n\t\tif params.Count != 0 {\n\t\t\tattrs[\"count\"] = params.Count\n\t\t}\n\t\tif params.Before != 0 {\n\t\t\tattrs[\"before\"] = params.Before\n\t\t}\n\t}\n\tresp, err := cli.sendIQ(infoQuery{\n\t\tNamespace: \"newsletter\",\n\t\tType:      iqGet,\n\t\tTo:        types.ServerJID,\n\t\tContent: []waBinary.Node{{\n\t\t\tTag:   \"messages\",\n\t\t\tAttrs: attrs,\n\t\t}},\n\t\tContext: context.TODO(),\n\t})\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tmessages, ok := resp.GetOptionalChildByTag(\"messages\")\n\tif !ok {\n\t\treturn nil, &ElementMissingError{Tag: \"messages\", In: \"newsletter messages response\"}\n\t}\n\treturn cli.parseNewsletterMessages(&messages), nil\n}\n\ntype GetNewsletterUpdatesParams struct {\n\tCount int\n\tSince time.Time\n\tAfter types.MessageServerID\n}\n\n// GetNewsletterMessageUpdates gets updates in a WhatsApp channel.\n//\n// These are the same kind of updates that NewsletterSubscribeLiveUpdates triggers (reaction and view counts).\nfunc (cli *Client) GetNewsletterMessageUpdates(jid types.JID, params *GetNewsletterUpdatesParams) ([]*types.NewsletterMessage, error) {\n\tattrs := waBinary.Attrs{}\n\tif params != nil {\n\t\tif params.Count != 0 {\n\t\t\tattrs[\"count\"] = params.Count\n\t\t}\n\t\tif !params.Since.IsZero() {\n\t\t\tattrs[\"since\"] = params.Since.Unix()\n\t\t}\n\t\tif params.After != 0 {\n\t\t\tattrs[\"after\"] = params.After\n\t\t}\n\t}\n\tresp, err := cli.sendIQ(infoQuery{\n\t\tNamespace: \"newsletter\",\n\t\tType:      iqGet,\n\t\tTo:        jid,\n\t\tContent: []waBinary.Node{{\n\t\t\tTag:   \"message_updates\",\n\t\t\tAttrs: attrs,\n\t\t}},\n\t\tContext: context.TODO(),\n\t})\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tmessages, ok := resp.GetOptionalChildByTag(\"message_updates\", \"messages\")\n\tif !ok {\n\t\treturn nil, &ElementMissingError{Tag: \"messages\", In: \"newsletter messages response\"}\n\t}\n\treturn cli.parseNewsletterMessages(&messages), nil\n}\n"
        },
        {
          "name": "notification.go",
          "type": "blob",
          "size": 13.474609375,
          "content": "// Copyright (c) 2021 Tulir Asokan\n//\n// This Source Code Form is subject to the terms of the Mozilla Public\n// License, v. 2.0. If a copy of the MPL was not distributed with this\n// file, You can obtain one at http://mozilla.org/MPL/2.0/.\n\npackage whatsmeow\n\nimport (\n\t\"encoding/json\"\n\t\"errors\"\n\n\t\"google.golang.org/protobuf/proto\"\n\n\t\"go.mau.fi/whatsmeow/appstate\"\n\twaBinary \"go.mau.fi/whatsmeow/binary\"\n\twaProto \"go.mau.fi/whatsmeow/binary/proto\"\n\t\"go.mau.fi/whatsmeow/store\"\n\t\"go.mau.fi/whatsmeow/types\"\n\t\"go.mau.fi/whatsmeow/types/events\"\n)\n\nfunc (cli *Client) handleEncryptNotification(node *waBinary.Node) {\n\tfrom := node.AttrGetter().JID(\"from\")\n\tif from == types.ServerJID {\n\t\tcount := node.GetChildByTag(\"count\")\n\t\tag := count.AttrGetter()\n\t\totksLeft := ag.Int(\"value\")\n\t\tif !ag.OK() {\n\t\t\tcli.Log.Warnf(\"Didn't get number of OTKs left in encryption notification %s\", node.XMLString())\n\t\t\treturn\n\t\t}\n\t\tcli.Log.Infof(\"Got prekey count from server: %s\", node.XMLString())\n\t\tif otksLeft < MinPreKeyCount {\n\t\t\tcli.uploadPreKeys()\n\t\t}\n\t} else if _, ok := node.GetOptionalChildByTag(\"identity\"); ok {\n\t\tcli.Log.Debugf(\"Got identity change for %s: %s, deleting all identities/sessions for that number\", from, node.XMLString())\n\t\terr := cli.Store.Identities.DeleteAllIdentities(from.User)\n\t\tif err != nil {\n\t\t\tcli.Log.Warnf(\"Failed to delete all identities of %s from store after identity change: %v\", from, err)\n\t\t}\n\t\terr = cli.Store.Sessions.DeleteAllSessions(from.User)\n\t\tif err != nil {\n\t\t\tcli.Log.Warnf(\"Failed to delete all sessions of %s from store after identity change: %v\", from, err)\n\t\t}\n\t\tts := node.AttrGetter().UnixTime(\"t\")\n\t\tcli.dispatchEvent(&events.IdentityChange{JID: from, Timestamp: ts})\n\t} else {\n\t\tcli.Log.Debugf(\"Got unknown encryption notification from server: %s\", node.XMLString())\n\t}\n}\n\nfunc (cli *Client) handleAppStateNotification(node *waBinary.Node) {\n\tfor _, collection := range node.GetChildrenByTag(\"collection\") {\n\t\tag := collection.AttrGetter()\n\t\tname := appstate.WAPatchName(ag.String(\"name\"))\n\t\tversion := ag.Uint64(\"version\")\n\t\tcli.Log.Debugf(\"Got server sync notification that app state %s has updated to version %d\", name, version)\n\t\terr := cli.FetchAppState(name, false, false)\n\t\tif errors.Is(err, ErrIQDisconnected) || errors.Is(err, ErrNotConnected) {\n\t\t\t// There are some app state changes right before a remote logout, so stop syncing if we're disconnected.\n\t\t\tcli.Log.Debugf(\"Failed to sync app state after notification: %v, not trying to sync other states\", err)\n\t\t\treturn\n\t\t} else if err != nil {\n\t\t\tcli.Log.Errorf(\"Failed to sync app state after notification: %v\", err)\n\t\t}\n\t}\n}\n\nfunc (cli *Client) handlePictureNotification(node *waBinary.Node) {\n\tts := node.AttrGetter().UnixTime(\"t\")\n\tfor _, child := range node.GetChildren() {\n\t\tag := child.AttrGetter()\n\t\tvar evt events.Picture\n\t\tevt.Timestamp = ts\n\t\tevt.JID = ag.JID(\"jid\")\n\t\tevt.Author = ag.OptionalJIDOrEmpty(\"author\")\n\t\tif child.Tag == \"delete\" {\n\t\t\tevt.Remove = true\n\t\t} else if child.Tag == \"add\" {\n\t\t\tevt.PictureID = ag.String(\"id\")\n\t\t} else if child.Tag == \"set\" {\n\t\t\t// TODO sometimes there's a hash and no ID?\n\t\t\tevt.PictureID = ag.String(\"id\")\n\t\t} else {\n\t\t\tcontinue\n\t\t}\n\t\tif !ag.OK() {\n\t\t\tcli.Log.Debugf(\"Ignoring picture change notification with unexpected attributes: %v\", ag.Error())\n\t\t\tcontinue\n\t\t}\n\t\tcli.dispatchEvent(&evt)\n\t}\n}\n\nfunc (cli *Client) handleDeviceNotification(node *waBinary.Node) {\n\tcli.userDevicesCacheLock.Lock()\n\tdefer cli.userDevicesCacheLock.Unlock()\n\tag := node.AttrGetter()\n\tfrom := ag.JID(\"from\")\n\tcached, ok := cli.userDevicesCache[from]\n\tif !ok {\n\t\tcli.Log.Debugf(\"No device list cached for %s, ignoring device list notification\", from)\n\t\treturn\n\t}\n\tcachedParticipantHash := participantListHashV2(cached.devices)\n\tfor _, child := range node.GetChildren() {\n\t\tif child.Tag != \"add\" && child.Tag != \"remove\" {\n\t\t\tcli.Log.Debugf(\"Unknown device list change tag %s\", child.Tag)\n\t\t\tcontinue\n\t\t}\n\t\tcag := child.AttrGetter()\n\t\tdeviceHash := cag.String(\"device_hash\")\n\t\tdeviceChild, _ := child.GetOptionalChildByTag(\"device\")\n\t\tchangedDeviceJID := deviceChild.AttrGetter().JID(\"jid\")\n\t\tswitch child.Tag {\n\t\tcase \"add\":\n\t\t\tcached.devices = append(cached.devices, changedDeviceJID)\n\t\tcase \"remove\":\n\t\t\tfor i, jid := range cached.devices {\n\t\t\t\tif jid == changedDeviceJID {\n\t\t\t\t\tcached.devices = append(cached.devices[:i], cached.devices[i+1:]...)\n\t\t\t\t}\n\t\t\t}\n\t\tcase \"update\":\n\t\t\t// ???\n\t\t}\n\t\tnewParticipantHash := participantListHashV2(cached.devices)\n\t\tif newParticipantHash == deviceHash {\n\t\t\tcli.Log.Debugf(\"%s's device list hash changed from %s to %s (%s). New hash matches\", from, cachedParticipantHash, deviceHash, child.Tag)\n\t\t\tcli.userDevicesCache[from] = cached\n\t\t} else {\n\t\t\tcli.Log.Warnf(\"%s's device list hash changed from %s to %s (%s). New hash doesn't match (%s)\", from, cachedParticipantHash, deviceHash, child.Tag, newParticipantHash)\n\t\t\tdelete(cli.userDevicesCache, from)\n\t\t}\n\t}\n}\n\nfunc (cli *Client) handleFBDeviceNotification(node *waBinary.Node) {\n\tcli.userDevicesCacheLock.Lock()\n\tdefer cli.userDevicesCacheLock.Unlock()\n\tjid := node.AttrGetter().JID(\"from\")\n\tuserDevices := parseFBDeviceList(jid, node.GetChildByTag(\"devices\"))\n\tcli.userDevicesCache[jid] = userDevices\n}\n\nfunc (cli *Client) handleOwnDevicesNotification(node *waBinary.Node) {\n\tcli.userDevicesCacheLock.Lock()\n\tdefer cli.userDevicesCacheLock.Unlock()\n\townID := cli.getOwnID().ToNonAD()\n\tif ownID.IsEmpty() {\n\t\tcli.Log.Debugf(\"Ignoring own device change notification, session was deleted\")\n\t\treturn\n\t}\n\tcached, ok := cli.userDevicesCache[ownID]\n\tif !ok {\n\t\tcli.Log.Debugf(\"Ignoring own device change notification, device list not cached\")\n\t\treturn\n\t}\n\toldHash := participantListHashV2(cached.devices)\n\texpectedNewHash := node.AttrGetter().String(\"dhash\")\n\tvar newDeviceList []types.JID\n\tfor _, child := range node.GetChildren() {\n\t\tjid := child.AttrGetter().JID(\"jid\")\n\t\tif child.Tag == \"device\" && !jid.IsEmpty() {\n\t\t\tnewDeviceList = append(newDeviceList, jid)\n\t\t}\n\t}\n\tnewHash := participantListHashV2(newDeviceList)\n\tif newHash != expectedNewHash {\n\t\tcli.Log.Debugf(\"Received own device list change notification %s -> %s, but expected hash was %s\", oldHash, newHash, expectedNewHash)\n\t\tdelete(cli.userDevicesCache, ownID)\n\t} else {\n\t\tcli.Log.Debugf(\"Received own device list change notification %s -> %s\", oldHash, newHash)\n\t\tcli.userDevicesCache[ownID] = deviceCache{devices: newDeviceList, dhash: expectedNewHash}\n\t}\n}\n\nfunc (cli *Client) handleBlocklist(node *waBinary.Node) {\n\tag := node.AttrGetter()\n\tevt := events.Blocklist{\n\t\tAction:    events.BlocklistAction(ag.OptionalString(\"action\")),\n\t\tDHash:     ag.String(\"dhash\"),\n\t\tPrevDHash: ag.OptionalString(\"prev_dhash\"),\n\t}\n\tfor _, child := range node.GetChildren() {\n\t\tag := child.AttrGetter()\n\t\tchange := events.BlocklistChange{\n\t\t\tJID:    ag.JID(\"jid\"),\n\t\t\tAction: events.BlocklistChangeAction(ag.String(\"action\")),\n\t\t}\n\t\tif !ag.OK() {\n\t\t\tcli.Log.Warnf(\"Unexpected data in blocklist event child %v: %v\", child.XMLString(), ag.Error())\n\t\t\tcontinue\n\t\t}\n\t\tevt.Changes = append(evt.Changes, change)\n\t}\n\tcli.dispatchEvent(&evt)\n}\n\nfunc (cli *Client) handleAccountSyncNotification(node *waBinary.Node) {\n\tfor _, child := range node.GetChildren() {\n\t\tswitch child.Tag {\n\t\tcase \"privacy\":\n\t\t\tcli.handlePrivacySettingsNotification(&child)\n\t\tcase \"devices\":\n\t\t\tcli.handleOwnDevicesNotification(&child)\n\t\tcase \"picture\":\n\t\t\tcli.dispatchEvent(&events.Picture{\n\t\t\t\tTimestamp: node.AttrGetter().UnixTime(\"t\"),\n\t\t\t\tJID:       cli.getOwnID().ToNonAD(),\n\t\t\t})\n\t\tcase \"blocklist\":\n\t\t\tcli.handleBlocklist(&child)\n\t\tdefault:\n\t\t\tcli.Log.Debugf(\"Unhandled account sync item %s\", child.Tag)\n\t\t}\n\t}\n}\n\nfunc (cli *Client) handlePrivacyTokenNotification(node *waBinary.Node) {\n\townID := cli.getOwnID().ToNonAD()\n\tif ownID.IsEmpty() {\n\t\tcli.Log.Debugf(\"Ignoring privacy token notification, session was deleted\")\n\t\treturn\n\t}\n\ttokens := node.GetChildByTag(\"tokens\")\n\tif tokens.Tag != \"tokens\" {\n\t\tcli.Log.Warnf(\"privacy_token notification didn't contain <tokens> tag\")\n\t\treturn\n\t}\n\tparentAG := node.AttrGetter()\n\tsender := parentAG.JID(\"from\")\n\tif !parentAG.OK() {\n\t\tcli.Log.Warnf(\"privacy_token notification didn't have a sender (%v)\", parentAG.Error())\n\t\treturn\n\t}\n\tfor _, child := range tokens.GetChildren() {\n\t\tag := child.AttrGetter()\n\t\tif child.Tag != \"token\" {\n\t\t\tcli.Log.Warnf(\"privacy_token notification contained unexpected <%s> tag\", child.Tag)\n\t\t} else if targetUser := ag.JID(\"jid\"); targetUser != ownID {\n\t\t\tcli.Log.Warnf(\"privacy_token notification contained token for different user %s\", targetUser)\n\t\t} else if tokenType := ag.String(\"type\"); tokenType != \"trusted_contact\" {\n\t\t\tcli.Log.Warnf(\"privacy_token notification contained unexpected token type %s\", tokenType)\n\t\t} else if token, ok := child.Content.([]byte); !ok {\n\t\t\tcli.Log.Warnf(\"privacy_token notification contained non-binary token\")\n\t\t} else {\n\t\t\ttimestamp := ag.UnixTime(\"t\")\n\t\t\tif !ag.OK() {\n\t\t\t\tcli.Log.Warnf(\"privacy_token notification is missing some fields: %v\", ag.Error())\n\t\t\t}\n\t\t\terr := cli.Store.PrivacyTokens.PutPrivacyTokens(store.PrivacyToken{\n\t\t\t\tUser:      sender,\n\t\t\t\tToken:     token,\n\t\t\t\tTimestamp: timestamp,\n\t\t\t})\n\t\t\tif err != nil {\n\t\t\t\tcli.Log.Errorf(\"Failed to save privacy token from %s: %v\", sender, err)\n\t\t\t} else {\n\t\t\t\tcli.Log.Debugf(\"Stored privacy token from %s (ts: %v)\", sender, timestamp)\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc (cli *Client) parseNewsletterMessages(node *waBinary.Node) []*types.NewsletterMessage {\n\tchildren := node.GetChildren()\n\toutput := make([]*types.NewsletterMessage, 0, len(children))\n\tfor _, child := range children {\n\t\tif child.Tag != \"message\" {\n\t\t\tcontinue\n\t\t}\n\t\tmsg := types.NewsletterMessage{\n\t\t\tMessageServerID: child.AttrGetter().Int(\"server_id\"),\n\t\t\tViewsCount:      0,\n\t\t\tReactionCounts:  nil,\n\t\t}\n\t\tfor _, subchild := range child.GetChildren() {\n\t\t\tswitch subchild.Tag {\n\t\t\tcase \"plaintext\":\n\t\t\t\tbyteContent, ok := subchild.Content.([]byte)\n\t\t\t\tif ok {\n\t\t\t\t\tmsg.Message = new(waProto.Message)\n\t\t\t\t\terr := proto.Unmarshal(byteContent, msg.Message)\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\tcli.Log.Warnf(\"Failed to unmarshal newsletter message: %v\", err)\n\t\t\t\t\t\tmsg.Message = nil\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\tcase \"views_count\":\n\t\t\t\tmsg.ViewsCount = subchild.AttrGetter().Int(\"count\")\n\t\t\tcase \"reactions\":\n\t\t\t\tmsg.ReactionCounts = make(map[string]int)\n\t\t\t\tfor _, reaction := range subchild.GetChildren() {\n\t\t\t\t\trag := reaction.AttrGetter()\n\t\t\t\t\tmsg.ReactionCounts[rag.String(\"code\")] = rag.Int(\"count\")\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\toutput = append(output, &msg)\n\t}\n\treturn output\n}\n\nfunc (cli *Client) handleNewsletterNotification(node *waBinary.Node) {\n\tag := node.AttrGetter()\n\tliveUpdates := node.GetChildByTag(\"live_updates\")\n\tcli.dispatchEvent(&events.NewsletterLiveUpdate{\n\t\tJID:      ag.JID(\"from\"),\n\t\tTime:     ag.UnixTime(\"t\"),\n\t\tMessages: cli.parseNewsletterMessages(&liveUpdates),\n\t})\n}\n\ntype newsLetterEventWrapper struct {\n\tData newsletterEvent `json:\"data\"`\n}\n\ntype newsletterEvent struct {\n\tJoin       *events.NewsletterJoin       `json:\"xwa2_notify_newsletter_on_join\"`\n\tLeave      *events.NewsletterLeave      `json:\"xwa2_notify_newsletter_on_leave\"`\n\tMuteChange *events.NewsletterMuteChange `json:\"xwa2_notify_newsletter_on_mute_change\"`\n\t// _on_admin_metadata_update -> id, thread_metadata, messages\n\t// _on_metadata_update\n\t// _on_state_change -> id, is_requestor, state\n}\n\nfunc (cli *Client) handleMexNotification(node *waBinary.Node) {\n\tfor _, child := range node.GetChildren() {\n\t\tif child.Tag != \"update\" {\n\t\t\tcontinue\n\t\t}\n\t\tchildData, ok := child.Content.([]byte)\n\t\tif !ok {\n\t\t\tcontinue\n\t\t}\n\t\tvar wrapper newsLetterEventWrapper\n\t\terr := json.Unmarshal(childData, &wrapper)\n\t\tif err != nil {\n\t\t\tcli.Log.Errorf(\"Failed to unmarshal JSON in mex event: %v\", err)\n\t\t\tcontinue\n\t\t}\n\t\tif wrapper.Data.Join != nil {\n\t\t\tcli.dispatchEvent(wrapper.Data.Join)\n\t\t} else if wrapper.Data.Leave != nil {\n\t\t\tcli.dispatchEvent(wrapper.Data.Leave)\n\t\t} else if wrapper.Data.MuteChange != nil {\n\t\t\tcli.dispatchEvent(wrapper.Data.MuteChange)\n\t\t}\n\t}\n}\n\nfunc (cli *Client) handleStatusNotification(node *waBinary.Node) {\n\tag := node.AttrGetter()\n\tchild, found := node.GetOptionalChildByTag(\"set\")\n\tif !found {\n\t\tcli.Log.Debugf(\"Status notifcation did not contain child with tag 'set'\")\n\t\treturn\n\t}\n\tstatus, ok := child.Content.([]byte)\n\tif !ok {\n\t\tcli.Log.Warnf(\"Set status notification has unexpected content (%T)\", child.Content)\n\t\treturn\n\t}\n\tcli.dispatchEvent(&events.UserAbout{\n\t\tJID:       ag.JID(\"from\"),\n\t\tTimestamp: ag.UnixTime(\"t\"),\n\t\tStatus:    string(status),\n\t})\n}\n\nfunc (cli *Client) handleNotification(node *waBinary.Node) {\n\tag := node.AttrGetter()\n\tnotifType := ag.String(\"type\")\n\tif !ag.OK() {\n\t\treturn\n\t}\n\tgo cli.sendAck(node)\n\tswitch notifType {\n\tcase \"encrypt\":\n\t\tgo cli.handleEncryptNotification(node)\n\tcase \"server_sync\":\n\t\tgo cli.handleAppStateNotification(node)\n\tcase \"account_sync\":\n\t\tgo cli.handleAccountSyncNotification(node)\n\tcase \"devices\":\n\t\tgo cli.handleDeviceNotification(node)\n\tcase \"fbid:devices\":\n\t\tgo cli.handleFBDeviceNotification(node)\n\tcase \"w:gp2\":\n\t\tevt, err := cli.parseGroupNotification(node)\n\t\tif err != nil {\n\t\t\tcli.Log.Errorf(\"Failed to parse group notification: %v\", err)\n\t\t} else {\n\t\t\tgo cli.dispatchEvent(evt)\n\t\t}\n\tcase \"picture\":\n\t\tgo cli.handlePictureNotification(node)\n\tcase \"mediaretry\":\n\t\tgo cli.handleMediaRetryNotification(node)\n\tcase \"privacy_token\":\n\t\tgo cli.handlePrivacyTokenNotification(node)\n\tcase \"link_code_companion_reg\":\n\t\tgo cli.tryHandleCodePairNotification(node)\n\tcase \"newsletter\":\n\t\tgo cli.handleNewsletterNotification(node)\n\tcase \"mex\":\n\t\tgo cli.handleMexNotification(node)\n\tcase \"status\":\n\t\tgo cli.handleStatusNotification(node)\n\t// Other types: business, disappearing_mode, server, status, pay, psa\n\tdefault:\n\t\tcli.Log.Debugf(\"Unhandled notification with type %s\", notifType)\n\t}\n}\n"
        },
        {
          "name": "pair-code.go",
          "type": "blob",
          "size": 9.1513671875,
          "content": "// Copyright (c) 2023 Tulir Asokan\n//\n// This Source Code Form is subject to the terms of the Mozilla Public\n// License, v. 2.0. If a copy of the MPL was not distributed with this\n// file, You can obtain one at http://mozilla.org/MPL/2.0/.\n\npackage whatsmeow\n\nimport (\n\t\"crypto/aes\"\n\t\"crypto/cipher\"\n\t\"crypto/sha256\"\n\t\"encoding/base32\"\n\t\"fmt\"\n\t\"regexp\"\n\t\"strconv\"\n\t\"strings\"\n\n\t\"go.mau.fi/util/random\"\n\t\"golang.org/x/crypto/curve25519\"\n\t\"golang.org/x/crypto/pbkdf2\"\n\n\twaBinary \"go.mau.fi/whatsmeow/binary\"\n\t\"go.mau.fi/whatsmeow/types\"\n\t\"go.mau.fi/whatsmeow/util/hkdfutil\"\n\t\"go.mau.fi/whatsmeow/util/keys\"\n)\n\n// PairClientType is the type of client to use with PairCode.\n// The type is automatically filled based on store.DeviceProps.PlatformType (which is what QR login uses).\ntype PairClientType int\n\nconst (\n\tPairClientUnknown PairClientType = iota\n\tPairClientChrome\n\tPairClientEdge\n\tPairClientFirefox\n\tPairClientIE\n\tPairClientOpera\n\tPairClientSafari\n\tPairClientElectron\n\tPairClientUWP\n\tPairClientOtherWebClient\n)\n\nvar notNumbers = regexp.MustCompile(\"[^0-9]\")\nvar linkingBase32 = base32.NewEncoding(\"123456789ABCDEFGHJKLMNPQRSTVWXYZ\")\n\ntype phoneLinkingCache struct {\n\tjid         types.JID\n\tkeyPair     *keys.KeyPair\n\tlinkingCode string\n\tpairingRef  string\n}\n\nfunc generateCompanionEphemeralKey() (ephemeralKeyPair *keys.KeyPair, ephemeralKey []byte, encodedLinkingCode string) {\n\tephemeralKeyPair = keys.NewKeyPair()\n\tsalt := random.Bytes(32)\n\tiv := random.Bytes(16)\n\tlinkingCode := random.Bytes(5)\n\tencodedLinkingCode = linkingBase32.EncodeToString(linkingCode)\n\tlinkCodeKey := pbkdf2.Key([]byte(encodedLinkingCode), salt, 2<<16, 32, sha256.New)\n\tlinkCipherBlock, _ := aes.NewCipher(linkCodeKey)\n\tencryptedPubkey := ephemeralKeyPair.Pub[:]\n\tcipher.NewCTR(linkCipherBlock, iv).XORKeyStream(encryptedPubkey, encryptedPubkey)\n\tephemeralKey = make([]byte, 80)\n\tcopy(ephemeralKey[0:32], salt)\n\tcopy(ephemeralKey[32:48], iv)\n\tcopy(ephemeralKey[48:80], encryptedPubkey)\n\treturn\n}\n\n// PairPhone generates a pairing code that can be used to link to a phone without scanning a QR code.\n//\n// You must connect the client normally before calling this (which means you'll also receive a QR code\n// event, but that can be ignored when doing code pairing). You should also wait for `*events.QR` before\n// calling this to ensure the connection is fully established. If using [Client.GetQRChannel], wait for\n// the first item in the channel. Alternatively, sleeping for a second after calling Connect will probably work too.\n//\n// The exact expiry of pairing codes is unknown, but QR codes are always generated and the login websocket is closed\n// after the QR codes run out, which means there's a 160-second time limit. It is recommended to generate the pairing\n// code immediately after connecting to the websocket to have the maximum time.\n//\n// The clientType parameter must be one of the PairClient* constants, but which one doesn't matter.\n// The client display name must be formatted as `Browser (OS)`, and only common browsers/OSes are allowed\n// (the server will validate it and return 400 if it's wrong).\n//\n// See https://faq.whatsapp.com/1324084875126592 for more info\nfunc (cli *Client) PairPhone(phone string, showPushNotification bool, clientType PairClientType, clientDisplayName string) (string, error) {\n\tif cli == nil {\n\t\treturn \"\", ErrClientIsNil\n\t}\n\tephemeralKeyPair, ephemeralKey, encodedLinkingCode := generateCompanionEphemeralKey()\n\tphone = notNumbers.ReplaceAllString(phone, \"\")\n\tif len(phone) <= 6 {\n\t\treturn \"\", fmt.Errorf(\"phone number too short\")\n\t} else if strings.HasPrefix(phone, \"0\") {\n\t\treturn \"\", fmt.Errorf(\"international phone number required (must not start with 0)\")\n\t}\n\tjid := types.NewJID(phone, types.DefaultUserServer)\n\tresp, err := cli.sendIQ(infoQuery{\n\t\tNamespace: \"md\",\n\t\tType:      iqSet,\n\t\tTo:        types.ServerJID,\n\t\tContent: []waBinary.Node{{\n\t\t\tTag: \"link_code_companion_reg\",\n\t\t\tAttrs: waBinary.Attrs{\n\t\t\t\t\"jid\":   jid,\n\t\t\t\t\"stage\": \"companion_hello\",\n\n\t\t\t\t\"should_show_push_notification\": strconv.FormatBool(showPushNotification),\n\t\t\t},\n\t\t\tContent: []waBinary.Node{\n\t\t\t\t{Tag: \"link_code_pairing_wrapped_companion_ephemeral_pub\", Content: ephemeralKey},\n\t\t\t\t{Tag: \"companion_server_auth_key_pub\", Content: cli.Store.NoiseKey.Pub[:]},\n\t\t\t\t{Tag: \"companion_platform_id\", Content: strconv.Itoa(int(clientType))},\n\t\t\t\t{Tag: \"companion_platform_display\", Content: clientDisplayName},\n\t\t\t\t{Tag: \"link_code_pairing_nonce\", Content: []byte{0}},\n\t\t\t},\n\t\t}},\n\t})\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\tpairingRefNode, ok := resp.GetOptionalChildByTag(\"link_code_companion_reg\", \"link_code_pairing_ref\")\n\tif !ok {\n\t\treturn \"\", &ElementMissingError{Tag: \"link_code_pairing_ref\", In: \"code link registration response\"}\n\t}\n\tpairingRef, ok := pairingRefNode.Content.([]byte)\n\tif !ok {\n\t\treturn \"\", fmt.Errorf(\"unexpected type %T in content of link_code_pairing_ref tag\", pairingRefNode.Content)\n\t}\n\tcli.phoneLinkingCache = &phoneLinkingCache{\n\t\tjid:         jid,\n\t\tkeyPair:     ephemeralKeyPair,\n\t\tlinkingCode: encodedLinkingCode,\n\t\tpairingRef:  string(pairingRef),\n\t}\n\treturn encodedLinkingCode[0:4] + \"-\" + encodedLinkingCode[4:], nil\n}\n\nfunc (cli *Client) tryHandleCodePairNotification(parentNode *waBinary.Node) {\n\terr := cli.handleCodePairNotification(parentNode)\n\tif err != nil {\n\t\tcli.Log.Errorf(\"Failed to handle code pair notification: %s\", err)\n\t}\n}\n\nfunc (cli *Client) handleCodePairNotification(parentNode *waBinary.Node) error {\n\tnode, ok := parentNode.GetOptionalChildByTag(\"link_code_companion_reg\")\n\tif !ok {\n\t\treturn &ElementMissingError{\n\t\t\tTag: \"link_code_companion_reg\",\n\t\t\tIn:  \"notification\",\n\t\t}\n\t}\n\tlinkCache := cli.phoneLinkingCache\n\tif linkCache == nil {\n\t\treturn fmt.Errorf(\"received code pair notification without a pending pairing\")\n\t}\n\tlinkCodePairingRef, _ := node.GetChildByTag(\"link_code_pairing_ref\").Content.([]byte)\n\tif string(linkCodePairingRef) != linkCache.pairingRef {\n\t\treturn fmt.Errorf(\"pairing ref mismatch in code pair notification\")\n\t}\n\twrappedPrimaryEphemeralPub, ok := node.GetChildByTag(\"link_code_pairing_wrapped_primary_ephemeral_pub\").Content.([]byte)\n\tif !ok {\n\t\treturn &ElementMissingError{\n\t\t\tTag: \"link_code_pairing_wrapped_primary_ephemeral_pub\",\n\t\t\tIn:  \"notification\",\n\t\t}\n\t}\n\tprimaryIdentityPub, ok := node.GetChildByTag(\"primary_identity_pub\").Content.([]byte)\n\tif !ok {\n\t\treturn &ElementMissingError{\n\t\t\tTag: \"primary_identity_pub\",\n\t\t\tIn:  \"notification\",\n\t\t}\n\t}\n\n\tadvSecretRandom := random.Bytes(32)\n\tkeyBundleSalt := random.Bytes(32)\n\tkeyBundleNonce := random.Bytes(12)\n\n\t// Decrypt the primary device's ephemeral public key, which was encrypted with the 8-character pairing code,\n\t// then compute the DH shared secret using our ephemeral private key we generated earlier.\n\tprimarySalt := wrappedPrimaryEphemeralPub[0:32]\n\tprimaryIV := wrappedPrimaryEphemeralPub[32:48]\n\tprimaryEncryptedPubkey := wrappedPrimaryEphemeralPub[48:80]\n\tlinkCodeKey := pbkdf2.Key([]byte(linkCache.linkingCode), primarySalt, 2<<16, 32, sha256.New)\n\tlinkCipherBlock, err := aes.NewCipher(linkCodeKey)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to create link cipher: %w\", err)\n\t}\n\tprimaryDecryptedPubkey := make([]byte, 32)\n\tcipher.NewCTR(linkCipherBlock, primaryIV).XORKeyStream(primaryDecryptedPubkey, primaryEncryptedPubkey)\n\tephemeralSharedSecret, err := curve25519.X25519(linkCache.keyPair.Priv[:], primaryDecryptedPubkey)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to compute ephemeral shared secret: %w\", err)\n\t}\n\n\t// Encrypt and wrap key bundle containing our identity key, the primary device's identity key and the randomness used for the adv key.\n\tkeyBundleEncryptionKey := hkdfutil.SHA256(ephemeralSharedSecret, keyBundleSalt, []byte(\"link_code_pairing_key_bundle_encryption_key\"), 32)\n\tkeyBundleCipherBlock, err := aes.NewCipher(keyBundleEncryptionKey)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to create key bundle cipher: %w\", err)\n\t}\n\tkeyBundleGCM, err := cipher.NewGCM(keyBundleCipherBlock)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to create key bundle GCM: %w\", err)\n\t}\n\tplaintextKeyBundle := concatBytes(cli.Store.IdentityKey.Pub[:], primaryIdentityPub, advSecretRandom)\n\tencryptedKeyBundle := keyBundleGCM.Seal(nil, keyBundleNonce, plaintextKeyBundle, nil)\n\twrappedKeyBundle := concatBytes(keyBundleSalt, keyBundleNonce, encryptedKeyBundle)\n\n\t// Compute the adv secret key (which is used to authenticate the pair-success event later)\n\tidentitySharedKey, err := curve25519.X25519(cli.Store.IdentityKey.Priv[:], primaryIdentityPub)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to compute identity shared key: %w\", err)\n\t}\n\tadvSecretInput := append(append(ephemeralSharedSecret, identitySharedKey...), advSecretRandom...)\n\tadvSecret := hkdfutil.SHA256(advSecretInput, nil, []byte(\"adv_secret\"), 32)\n\tcli.Store.AdvSecretKey = advSecret\n\n\t_, err = cli.sendIQ(infoQuery{\n\t\tNamespace: \"md\",\n\t\tType:      iqSet,\n\t\tTo:        types.ServerJID,\n\t\tContent: []waBinary.Node{{\n\t\t\tTag: \"link_code_companion_reg\",\n\t\t\tAttrs: waBinary.Attrs{\n\t\t\t\t\"jid\":   linkCache.jid,\n\t\t\t\t\"stage\": \"companion_finish\",\n\t\t\t},\n\t\t\tContent: []waBinary.Node{\n\t\t\t\t{Tag: \"link_code_pairing_wrapped_key_bundle\", Content: wrappedKeyBundle},\n\t\t\t\t{Tag: \"companion_identity_public\", Content: cli.Store.IdentityKey.Pub[:]},\n\t\t\t\t{Tag: \"link_code_pairing_ref\", Content: linkCodePairingRef},\n\t\t\t},\n\t\t}},\n\t})\n\treturn err\n}\n"
        },
        {
          "name": "pair.go",
          "type": "blob",
          "size": 7.7578125,
          "content": "// Copyright (c) 2021 Tulir Asokan\n//\n// This Source Code Form is subject to the terms of the Mozilla Public\n// License, v. 2.0. If a copy of the MPL was not distributed with this\n// file, You can obtain one at http://mozilla.org/MPL/2.0/.\n\npackage whatsmeow\n\nimport (\n\t\"bytes\"\n\t\"crypto/hmac\"\n\t\"crypto/sha256\"\n\t\"encoding/base64\"\n\t\"fmt\"\n\t\"strings\"\n\n\t\"go.mau.fi/libsignal/ecc\"\n\t\"google.golang.org/protobuf/proto\"\n\n\twaBinary \"go.mau.fi/whatsmeow/binary\"\n\twaProto \"go.mau.fi/whatsmeow/binary/proto\"\n\t\"go.mau.fi/whatsmeow/types\"\n\t\"go.mau.fi/whatsmeow/types/events\"\n\t\"go.mau.fi/whatsmeow/util/keys\"\n)\n\nfunc (cli *Client) handleIQ(node *waBinary.Node) {\n\tchildren := node.GetChildren()\n\tif len(children) != 1 || node.Attrs[\"from\"] != types.ServerJID {\n\t\treturn\n\t}\n\tswitch children[0].Tag {\n\tcase \"pair-device\":\n\t\tcli.handlePairDevice(node)\n\tcase \"pair-success\":\n\t\tcli.handlePairSuccess(node)\n\t}\n}\n\nfunc (cli *Client) handlePairDevice(node *waBinary.Node) {\n\tpairDevice := node.GetChildByTag(\"pair-device\")\n\terr := cli.sendNode(waBinary.Node{\n\t\tTag: \"iq\",\n\t\tAttrs: waBinary.Attrs{\n\t\t\t\"to\":   node.Attrs[\"from\"],\n\t\t\t\"id\":   node.Attrs[\"id\"],\n\t\t\t\"type\": \"result\",\n\t\t},\n\t})\n\tif err != nil {\n\t\tcli.Log.Warnf(\"Failed to send acknowledgement for pair-device request: %v\", err)\n\t}\n\n\tevt := &events.QR{Codes: make([]string, 0, len(pairDevice.GetChildren()))}\n\tfor i, child := range pairDevice.GetChildren() {\n\t\tif child.Tag != \"ref\" {\n\t\t\tcli.Log.Warnf(\"pair-device node contains unexpected child tag %s at index %d\", child.Tag, i)\n\t\t\tcontinue\n\t\t}\n\t\tcontent, ok := child.Content.([]byte)\n\t\tif !ok {\n\t\t\tcli.Log.Warnf(\"pair-device node contains unexpected child content type %T at index %d\", child, i)\n\t\t\tcontinue\n\t\t}\n\t\tevt.Codes = append(evt.Codes, cli.makeQRData(string(content)))\n\t}\n\n\tcli.dispatchEvent(evt)\n}\n\nfunc (cli *Client) makeQRData(ref string) string {\n\tnoise := base64.StdEncoding.EncodeToString(cli.Store.NoiseKey.Pub[:])\n\tidentity := base64.StdEncoding.EncodeToString(cli.Store.IdentityKey.Pub[:])\n\tadv := base64.StdEncoding.EncodeToString(cli.Store.AdvSecretKey)\n\treturn strings.Join([]string{ref, noise, identity, adv}, \",\")\n}\n\nfunc (cli *Client) handlePairSuccess(node *waBinary.Node) {\n\tid := node.Attrs[\"id\"].(string)\n\tpairSuccess := node.GetChildByTag(\"pair-success\")\n\n\tdeviceIdentityBytes, _ := pairSuccess.GetChildByTag(\"device-identity\").Content.([]byte)\n\tbusinessName, _ := pairSuccess.GetChildByTag(\"biz\").Attrs[\"name\"].(string)\n\tjid, _ := pairSuccess.GetChildByTag(\"device\").Attrs[\"jid\"].(types.JID)\n\tplatform, _ := pairSuccess.GetChildByTag(\"platform\").Attrs[\"name\"].(string)\n\n\tgo func() {\n\t\terr := cli.handlePair(deviceIdentityBytes, id, businessName, platform, jid)\n\t\tif err != nil {\n\t\t\tcli.Log.Errorf(\"Failed to pair device: %v\", err)\n\t\t\tcli.Disconnect()\n\t\t\tcli.dispatchEvent(&events.PairError{ID: jid, BusinessName: businessName, Platform: platform, Error: err})\n\t\t} else {\n\t\t\tcli.Log.Infof(\"Successfully paired %s\", cli.Store.ID)\n\t\t\tcli.dispatchEvent(&events.PairSuccess{ID: jid, BusinessName: businessName, Platform: platform})\n\t\t}\n\t}()\n}\n\nfunc (cli *Client) handlePair(deviceIdentityBytes []byte, reqID, businessName, platform string, jid types.JID) error {\n\tvar deviceIdentityContainer waProto.ADVSignedDeviceIdentityHMAC\n\terr := proto.Unmarshal(deviceIdentityBytes, &deviceIdentityContainer)\n\tif err != nil {\n\t\tcli.sendPairError(reqID, 500, \"internal-error\")\n\t\treturn &PairProtoError{\"failed to parse device identity container in pair success message\", err}\n\t}\n\n\th := hmac.New(sha256.New, cli.Store.AdvSecretKey)\n\th.Write(deviceIdentityContainer.Details)\n\tif !bytes.Equal(h.Sum(nil), deviceIdentityContainer.HMAC) {\n\t\tcli.Log.Warnf(\"Invalid HMAC from pair success message\")\n\t\tcli.sendPairError(reqID, 401, \"not-authorized\")\n\t\treturn ErrPairInvalidDeviceIdentityHMAC\n\t}\n\n\tvar deviceIdentity waProto.ADVSignedDeviceIdentity\n\terr = proto.Unmarshal(deviceIdentityContainer.Details, &deviceIdentity)\n\tif err != nil {\n\t\tcli.sendPairError(reqID, 500, \"internal-error\")\n\t\treturn &PairProtoError{\"failed to parse signed device identity in pair success message\", err}\n\t}\n\n\tif !verifyDeviceIdentityAccountSignature(&deviceIdentity, cli.Store.IdentityKey) {\n\t\tcli.sendPairError(reqID, 401, \"not-authorized\")\n\t\treturn ErrPairInvalidDeviceSignature\n\t}\n\n\tdeviceIdentity.DeviceSignature = generateDeviceSignature(&deviceIdentity, cli.Store.IdentityKey)[:]\n\n\tvar deviceIdentityDetails waProto.ADVDeviceIdentity\n\terr = proto.Unmarshal(deviceIdentity.Details, &deviceIdentityDetails)\n\tif err != nil {\n\t\tcli.sendPairError(reqID, 500, \"internal-error\")\n\t\treturn &PairProtoError{\"failed to parse device identity details in pair success message\", err}\n\t}\n\n\tif cli.PrePairCallback != nil && !cli.PrePairCallback(jid, platform, businessName) {\n\t\tcli.sendPairError(reqID, 500, \"internal-error\")\n\t\treturn ErrPairRejectedLocally\n\t}\n\n\tcli.Store.Account = proto.Clone(&deviceIdentity).(*waProto.ADVSignedDeviceIdentity)\n\n\tmainDeviceJID := jid\n\tmainDeviceJID.Device = 0\n\tmainDeviceIdentity := *(*[32]byte)(deviceIdentity.AccountSignatureKey)\n\tdeviceIdentity.AccountSignatureKey = nil\n\n\tselfSignedDeviceIdentity, err := proto.Marshal(&deviceIdentity)\n\tif err != nil {\n\t\tcli.sendPairError(reqID, 500, \"internal-error\")\n\t\treturn &PairProtoError{\"failed to marshal self-signed device identity\", err}\n\t}\n\n\tcli.Store.ID = &jid\n\tcli.Store.BusinessName = businessName\n\tcli.Store.Platform = platform\n\terr = cli.Store.Save()\n\tif err != nil {\n\t\tcli.sendPairError(reqID, 500, \"internal-error\")\n\t\treturn &PairDatabaseError{\"failed to save device store\", err}\n\t}\n\terr = cli.Store.Identities.PutIdentity(mainDeviceJID.SignalAddress().String(), mainDeviceIdentity)\n\tif err != nil {\n\t\t_ = cli.Store.Delete()\n\t\tcli.sendPairError(reqID, 500, \"internal-error\")\n\t\treturn &PairDatabaseError{\"failed to store main device identity\", err}\n\t}\n\n\t// Expect a disconnect after this and don't dispatch the usual Disconnected event\n\tcli.expectDisconnect()\n\n\terr = cli.sendNode(waBinary.Node{\n\t\tTag: \"iq\",\n\t\tAttrs: waBinary.Attrs{\n\t\t\t\"to\":   types.ServerJID,\n\t\t\t\"type\": \"result\",\n\t\t\t\"id\":   reqID,\n\t\t},\n\t\tContent: []waBinary.Node{{\n\t\t\tTag: \"pair-device-sign\",\n\t\t\tContent: []waBinary.Node{{\n\t\t\t\tTag: \"device-identity\",\n\t\t\t\tAttrs: waBinary.Attrs{\n\t\t\t\t\t\"key-index\": deviceIdentityDetails.GetKeyIndex(),\n\t\t\t\t},\n\t\t\t\tContent: selfSignedDeviceIdentity,\n\t\t\t}},\n\t\t}},\n\t})\n\tif err != nil {\n\t\t_ = cli.Store.Delete()\n\t\treturn fmt.Errorf(\"failed to send pairing confirmation: %w\", err)\n\t}\n\treturn nil\n}\n\nfunc concatBytes(data ...[]byte) []byte {\n\tlength := 0\n\tfor _, item := range data {\n\t\tlength += len(item)\n\t}\n\toutput := make([]byte, length)\n\tptr := 0\n\tfor _, item := range data {\n\t\tptr += copy(output[ptr:ptr+len(item)], item)\n\t}\n\treturn output\n}\n\nfunc verifyDeviceIdentityAccountSignature(deviceIdentity *waProto.ADVSignedDeviceIdentity, ikp *keys.KeyPair) bool {\n\tif len(deviceIdentity.AccountSignatureKey) != 32 || len(deviceIdentity.AccountSignature) != 64 {\n\t\treturn false\n\t}\n\n\tsignatureKey := ecc.NewDjbECPublicKey(*(*[32]byte)(deviceIdentity.AccountSignatureKey))\n\tsignature := *(*[64]byte)(deviceIdentity.AccountSignature)\n\n\tmessage := concatBytes([]byte{6, 0}, deviceIdentity.Details, ikp.Pub[:])\n\treturn ecc.VerifySignature(signatureKey, message, signature)\n}\n\nfunc generateDeviceSignature(deviceIdentity *waProto.ADVSignedDeviceIdentity, ikp *keys.KeyPair) *[64]byte {\n\tmessage := concatBytes([]byte{6, 1}, deviceIdentity.Details, ikp.Pub[:], deviceIdentity.AccountSignatureKey)\n\tsig := ecc.CalculateSignature(ecc.NewDjbECPrivateKey(*ikp.Priv), message)\n\treturn &sig\n}\n\nfunc (cli *Client) sendPairError(id string, code int, text string) {\n\terr := cli.sendNode(waBinary.Node{\n\t\tTag: \"iq\",\n\t\tAttrs: waBinary.Attrs{\n\t\t\t\"to\":   types.ServerJID,\n\t\t\t\"type\": \"error\",\n\t\t\t\"id\":   id,\n\t\t},\n\t\tContent: []waBinary.Node{{\n\t\t\tTag: \"error\",\n\t\t\tAttrs: waBinary.Attrs{\n\t\t\t\t\"code\": code,\n\t\t\t\t\"text\": text,\n\t\t\t},\n\t\t}},\n\t})\n\tif err != nil {\n\t\tcli.Log.Errorf(\"Failed to send pair error node: %v\", err)\n\t}\n}\n"
        },
        {
          "name": "prekeys.go",
          "type": "blob",
          "size": 7.744140625,
          "content": "// Copyright (c) 2021 Tulir Asokan\n//\n// This Source Code Form is subject to the terms of the Mozilla Public\n// License, v. 2.0. If a copy of the MPL was not distributed with this\n// file, You can obtain one at http://mozilla.org/MPL/2.0/.\n\npackage whatsmeow\n\nimport (\n\t\"context\"\n\t\"encoding/binary\"\n\t\"fmt\"\n\t\"time\"\n\n\t\"go.mau.fi/libsignal/ecc\"\n\t\"go.mau.fi/libsignal/keys/identity\"\n\t\"go.mau.fi/libsignal/keys/prekey\"\n\t\"go.mau.fi/libsignal/util/optional\"\n\n\twaBinary \"go.mau.fi/whatsmeow/binary\"\n\t\"go.mau.fi/whatsmeow/types\"\n\t\"go.mau.fi/whatsmeow/util/keys\"\n)\n\nconst (\n\t// WantedPreKeyCount is the number of prekeys that the client should upload to the WhatsApp servers in a single batch.\n\tWantedPreKeyCount = 50\n\t// MinPreKeyCount is the number of prekeys when the client will upload a new batch of prekeys to the WhatsApp servers.\n\tMinPreKeyCount = 5\n)\n\nfunc (cli *Client) getServerPreKeyCount() (int, error) {\n\tresp, err := cli.sendIQ(infoQuery{\n\t\tNamespace: \"encrypt\",\n\t\tType:      \"get\",\n\t\tTo:        types.ServerJID,\n\t\tContent: []waBinary.Node{\n\t\t\t{Tag: \"count\"},\n\t\t},\n\t})\n\tif err != nil {\n\t\treturn 0, fmt.Errorf(\"failed to get prekey count on server: %w\", err)\n\t}\n\tcount := resp.GetChildByTag(\"count\")\n\tag := count.AttrGetter()\n\tval := ag.Int(\"value\")\n\treturn val, ag.Error()\n}\n\nfunc (cli *Client) uploadPreKeys() {\n\tcli.uploadPreKeysLock.Lock()\n\tdefer cli.uploadPreKeysLock.Unlock()\n\tif cli.lastPreKeyUpload.Add(10 * time.Minute).After(time.Now()) {\n\t\tsc, _ := cli.getServerPreKeyCount()\n\t\tif sc >= WantedPreKeyCount {\n\t\t\tcli.Log.Debugf(\"Canceling prekey upload request due to likely race condition\")\n\t\t\treturn\n\t\t}\n\t}\n\tvar registrationIDBytes [4]byte\n\tbinary.BigEndian.PutUint32(registrationIDBytes[:], cli.Store.RegistrationID)\n\tpreKeys, err := cli.Store.PreKeys.GetOrGenPreKeys(WantedPreKeyCount)\n\tif err != nil {\n\t\tcli.Log.Errorf(\"Failed to get prekeys to upload: %v\", err)\n\t\treturn\n\t}\n\tcli.Log.Infof(\"Uploading %d new prekeys to server\", len(preKeys))\n\t_, err = cli.sendIQ(infoQuery{\n\t\tNamespace: \"encrypt\",\n\t\tType:      \"set\",\n\t\tTo:        types.ServerJID,\n\t\tContent: []waBinary.Node{\n\t\t\t{Tag: \"registration\", Content: registrationIDBytes[:]},\n\t\t\t{Tag: \"type\", Content: []byte{ecc.DjbType}},\n\t\t\t{Tag: \"identity\", Content: cli.Store.IdentityKey.Pub[:]},\n\t\t\t{Tag: \"list\", Content: preKeysToNodes(preKeys)},\n\t\t\tpreKeyToNode(cli.Store.SignedPreKey),\n\t\t},\n\t})\n\tif err != nil {\n\t\tcli.Log.Errorf(\"Failed to send request to upload prekeys: %v\", err)\n\t\treturn\n\t}\n\tcli.Log.Debugf(\"Got response to uploading prekeys\")\n\terr = cli.Store.PreKeys.MarkPreKeysAsUploaded(preKeys[len(preKeys)-1].KeyID)\n\tif err != nil {\n\t\tcli.Log.Warnf(\"Failed to mark prekeys as uploaded: %v\", err)\n\t}\n\tcli.lastPreKeyUpload = time.Now()\n}\n\ntype preKeyResp struct {\n\tbundle *prekey.Bundle\n\terr    error\n}\n\nfunc (cli *Client) fetchPreKeys(ctx context.Context, users []types.JID) (map[types.JID]preKeyResp, error) {\n\trequests := make([]waBinary.Node, len(users))\n\tfor i, user := range users {\n\t\trequests[i].Tag = \"user\"\n\t\trequests[i].Attrs = waBinary.Attrs{\n\t\t\t\"jid\":    user,\n\t\t\t\"reason\": \"identity\",\n\t\t}\n\t}\n\tresp, err := cli.sendIQ(infoQuery{\n\t\tContext:   ctx,\n\t\tNamespace: \"encrypt\",\n\t\tType:      \"get\",\n\t\tTo:        types.ServerJID,\n\t\tContent: []waBinary.Node{{\n\t\t\tTag:     \"key\",\n\t\t\tContent: requests,\n\t\t}},\n\t})\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to send prekey request: %w\", err)\n\t} else if len(resp.GetChildren()) == 0 {\n\t\treturn nil, fmt.Errorf(\"got empty response to prekey request\")\n\t}\n\tlist := resp.GetChildByTag(\"list\")\n\trespData := make(map[types.JID]preKeyResp)\n\tfor _, child := range list.GetChildren() {\n\t\tif child.Tag != \"user\" {\n\t\t\tcontinue\n\t\t}\n\t\tjid := child.AttrGetter().JID(\"jid\")\n\t\tbundle, err := nodeToPreKeyBundle(uint32(jid.Device), child)\n\t\trespData[jid] = preKeyResp{bundle, err}\n\t}\n\treturn respData, nil\n}\n\nfunc preKeyToNode(key *keys.PreKey) waBinary.Node {\n\tvar keyID [4]byte\n\tbinary.BigEndian.PutUint32(keyID[:], key.KeyID)\n\tnode := waBinary.Node{\n\t\tTag: \"key\",\n\t\tContent: []waBinary.Node{\n\t\t\t{Tag: \"id\", Content: keyID[1:]},\n\t\t\t{Tag: \"value\", Content: key.Pub[:]},\n\t\t},\n\t}\n\tif key.Signature != nil {\n\t\tnode.Tag = \"skey\"\n\t\tnode.Content = append(node.GetChildren(), waBinary.Node{\n\t\t\tTag:     \"signature\",\n\t\t\tContent: key.Signature[:],\n\t\t})\n\t}\n\treturn node\n}\n\nfunc nodeToPreKeyBundle(deviceID uint32, node waBinary.Node) (*prekey.Bundle, error) {\n\terrorNode, ok := node.GetOptionalChildByTag(\"error\")\n\tif ok && errorNode.Tag == \"error\" {\n\t\treturn nil, fmt.Errorf(\"got error getting prekeys: %s\", errorNode.XMLString())\n\t}\n\n\tregistrationBytes, ok := node.GetChildByTag(\"registration\").Content.([]byte)\n\tif !ok || len(registrationBytes) != 4 {\n\t\treturn nil, fmt.Errorf(\"invalid registration ID in prekey response\")\n\t}\n\tregistrationID := binary.BigEndian.Uint32(registrationBytes)\n\n\tkeysNode, ok := node.GetOptionalChildByTag(\"keys\")\n\tif !ok {\n\t\tkeysNode = node\n\t}\n\n\tidentityKeyRaw, ok := keysNode.GetChildByTag(\"identity\").Content.([]byte)\n\tif !ok || len(identityKeyRaw) != 32 {\n\t\treturn nil, fmt.Errorf(\"invalid identity key in prekey response\")\n\t}\n\tidentityKeyPub := *(*[32]byte)(identityKeyRaw)\n\n\tpreKeyNode, ok := keysNode.GetOptionalChildByTag(\"key\")\n\tpreKey := &keys.PreKey{}\n\tif ok {\n\t\tvar err error\n\t\tpreKey, err = nodeToPreKey(preKeyNode)\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"invalid prekey in prekey response: %w\", err)\n\t\t}\n\t}\n\n\tsignedPreKey, err := nodeToPreKey(keysNode.GetChildByTag(\"skey\"))\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"invalid signed prekey in prekey response: %w\", err)\n\t}\n\n\tvar bundle *prekey.Bundle\n\tif ok {\n\t\tbundle = prekey.NewBundle(registrationID, deviceID,\n\t\t\toptional.NewOptionalUint32(preKey.KeyID), signedPreKey.KeyID,\n\t\t\tecc.NewDjbECPublicKey(*preKey.Pub), ecc.NewDjbECPublicKey(*signedPreKey.Pub), *signedPreKey.Signature,\n\t\t\tidentity.NewKey(ecc.NewDjbECPublicKey(identityKeyPub)))\n\t} else {\n\t\tbundle = prekey.NewBundle(registrationID, deviceID, optional.NewEmptyUint32(), signedPreKey.KeyID,\n\t\t\tnil, ecc.NewDjbECPublicKey(*signedPreKey.Pub), *signedPreKey.Signature,\n\t\t\tidentity.NewKey(ecc.NewDjbECPublicKey(identityKeyPub)))\n\t}\n\n\treturn bundle, nil\n}\n\nfunc nodeToPreKey(node waBinary.Node) (*keys.PreKey, error) {\n\tkey := keys.PreKey{\n\t\tKeyPair:   keys.KeyPair{},\n\t\tKeyID:     0,\n\t\tSignature: nil,\n\t}\n\tif id := node.GetChildByTag(\"id\"); id.Tag != \"id\" {\n\t\treturn nil, fmt.Errorf(\"prekey node doesn't contain ID tag\")\n\t} else if idBytes, ok := id.Content.([]byte); !ok {\n\t\treturn nil, fmt.Errorf(\"prekey ID has unexpected content (%T)\", id.Content)\n\t} else if len(idBytes) != 3 {\n\t\treturn nil, fmt.Errorf(\"prekey ID has unexpected number of bytes (%d, expected 3)\", len(idBytes))\n\t} else {\n\t\tkey.KeyID = binary.BigEndian.Uint32(append([]byte{0}, idBytes...))\n\t}\n\tif pubkey := node.GetChildByTag(\"value\"); pubkey.Tag != \"value\" {\n\t\treturn nil, fmt.Errorf(\"prekey node doesn't contain value tag\")\n\t} else if pubkeyBytes, ok := pubkey.Content.([]byte); !ok {\n\t\treturn nil, fmt.Errorf(\"prekey value has unexpected content (%T)\", pubkey.Content)\n\t} else if len(pubkeyBytes) != 32 {\n\t\treturn nil, fmt.Errorf(\"prekey value has unexpected number of bytes (%d, expected 32)\", len(pubkeyBytes))\n\t} else {\n\t\tkey.KeyPair.Pub = (*[32]byte)(pubkeyBytes)\n\t}\n\tif node.Tag == \"skey\" {\n\t\tif sig := node.GetChildByTag(\"signature\"); sig.Tag != \"signature\" {\n\t\t\treturn nil, fmt.Errorf(\"prekey node doesn't contain signature tag\")\n\t\t} else if sigBytes, ok := sig.Content.([]byte); !ok {\n\t\t\treturn nil, fmt.Errorf(\"prekey signature has unexpected content (%T)\", sig.Content)\n\t\t} else if len(sigBytes) != 64 {\n\t\t\treturn nil, fmt.Errorf(\"prekey signature has unexpected number of bytes (%d, expected 64)\", len(sigBytes))\n\t\t} else {\n\t\t\tkey.Signature = (*[64]byte)(sigBytes)\n\t\t}\n\t}\n\treturn &key, nil\n}\n\nfunc preKeysToNodes(prekeys []*keys.PreKey) []waBinary.Node {\n\tnodes := make([]waBinary.Node, len(prekeys))\n\tfor i, key := range prekeys {\n\t\tnodes[i] = preKeyToNode(key)\n\t}\n\treturn nodes\n}\n"
        },
        {
          "name": "presence.go",
          "type": "blob",
          "size": 4.2607421875,
          "content": "// Copyright (c) 2021 Tulir Asokan\n//\n// This Source Code Form is subject to the terms of the Mozilla Public\n// License, v. 2.0. If a copy of the MPL was not distributed with this\n// file, You can obtain one at http://mozilla.org/MPL/2.0/.\n\npackage whatsmeow\n\nimport (\n\t\"fmt\"\n\n\twaBinary \"go.mau.fi/whatsmeow/binary\"\n\t\"go.mau.fi/whatsmeow/types\"\n\t\"go.mau.fi/whatsmeow/types/events\"\n)\n\nfunc (cli *Client) handleChatState(node *waBinary.Node) {\n\tsource, err := cli.parseMessageSource(node, true)\n\tif err != nil {\n\t\tcli.Log.Warnf(\"Failed to parse chat state update: %v\", err)\n\t} else if len(node.GetChildren()) != 1 {\n\t\tcli.Log.Warnf(\"Failed to parse chat state update: unexpected number of children in element (%d)\", len(node.GetChildren()))\n\t} else {\n\t\tchild := node.GetChildren()[0]\n\t\tpresence := types.ChatPresence(child.Tag)\n\t\tif presence != types.ChatPresenceComposing && presence != types.ChatPresencePaused {\n\t\t\tcli.Log.Warnf(\"Unrecognized chat presence state %s\", child.Tag)\n\t\t}\n\t\tmedia := types.ChatPresenceMedia(child.AttrGetter().OptionalString(\"media\"))\n\t\tcli.dispatchEvent(&events.ChatPresence{\n\t\t\tMessageSource: source,\n\t\t\tState:         presence,\n\t\t\tMedia:         media,\n\t\t})\n\t}\n}\n\nfunc (cli *Client) handlePresence(node *waBinary.Node) {\n\tvar evt events.Presence\n\tag := node.AttrGetter()\n\tevt.From = ag.JID(\"from\")\n\tpresenceType := ag.OptionalString(\"type\")\n\tif presenceType == \"unavailable\" {\n\t\tevt.Unavailable = true\n\t} else if presenceType != \"\" {\n\t\tcli.Log.Debugf(\"Unrecognized presence type '%s' in presence event from %s\", presenceType, evt.From)\n\t}\n\tlastSeen := ag.OptionalString(\"last\")\n\tif lastSeen != \"\" && lastSeen != \"deny\" {\n\t\tevt.LastSeen = ag.UnixTime(\"last\")\n\t}\n\tif !ag.OK() {\n\t\tcli.Log.Warnf(\"Error parsing presence event: %+v\", ag.Errors)\n\t} else {\n\t\tcli.dispatchEvent(&evt)\n\t}\n}\n\n// SendPresence updates the user's presence status on WhatsApp.\n//\n// You should call this at least once after connecting so that the server has your pushname.\n// Otherwise, other users will see \"-\" as the name.\nfunc (cli *Client) SendPresence(state types.Presence) error {\n\tif len(cli.Store.PushName) == 0 {\n\t\treturn ErrNoPushName\n\t}\n\tif state == types.PresenceAvailable {\n\t\tcli.sendActiveReceipts.CompareAndSwap(0, 1)\n\t} else {\n\t\tcli.sendActiveReceipts.CompareAndSwap(1, 0)\n\t}\n\treturn cli.sendNode(waBinary.Node{\n\t\tTag: \"presence\",\n\t\tAttrs: waBinary.Attrs{\n\t\t\t\"name\": cli.Store.PushName,\n\t\t\t\"type\": string(state),\n\t\t},\n\t})\n}\n\n// SubscribePresence asks the WhatsApp servers to send presence updates of a specific user to this client.\n//\n// After subscribing to this event, you should start receiving *events.Presence for that user in normal event handlers.\n//\n// Also, it seems that the WhatsApp servers require you to be online to receive presence status from other users,\n// so you should mark yourself as online before trying to use this function:\n//\n//\tcli.SendPresence(types.PresenceAvailable)\nfunc (cli *Client) SubscribePresence(jid types.JID) error {\n\tprivacyToken, err := cli.Store.PrivacyTokens.GetPrivacyToken(jid)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to get privacy token: %w\", err)\n\t} else if privacyToken == nil {\n\t\tif cli.ErrorOnSubscribePresenceWithoutToken {\n\t\t\treturn fmt.Errorf(\"%w for %v\", ErrNoPrivacyToken, jid.ToNonAD())\n\t\t} else {\n\t\t\tcli.Log.Debugf(\"Trying to subscribe to presence of %s without privacy token\", jid)\n\t\t}\n\t}\n\treq := waBinary.Node{\n\t\tTag: \"presence\",\n\t\tAttrs: waBinary.Attrs{\n\t\t\t\"type\": \"subscribe\",\n\t\t\t\"to\":   jid,\n\t\t},\n\t}\n\tif privacyToken != nil {\n\t\treq.Content = []waBinary.Node{{\n\t\t\tTag:     \"tctoken\",\n\t\t\tContent: privacyToken.Token,\n\t\t}}\n\t}\n\treturn cli.sendNode(req)\n}\n\n// SendChatPresence updates the user's typing status in a specific chat.\n//\n// The media parameter can be set to indicate the user is recording media (like a voice message) rather than typing a text message.\nfunc (cli *Client) SendChatPresence(jid types.JID, state types.ChatPresence, media types.ChatPresenceMedia) error {\n\townID := cli.getOwnID()\n\tif ownID.IsEmpty() {\n\t\treturn ErrNotLoggedIn\n\t}\n\tcontent := []waBinary.Node{{Tag: string(state)}}\n\tif state == types.ChatPresenceComposing && len(media) > 0 {\n\t\tcontent[0].Attrs = waBinary.Attrs{\n\t\t\t\"media\": string(media),\n\t\t}\n\t}\n\treturn cli.sendNode(waBinary.Node{\n\t\tTag: \"chatstate\",\n\t\tAttrs: waBinary.Attrs{\n\t\t\t\"from\": ownID,\n\t\t\t\"to\":   jid,\n\t\t},\n\t\tContent: content,\n\t})\n}\n"
        },
        {
          "name": "privacysettings.go",
          "type": "blob",
          "size": 5.1650390625,
          "content": "// Copyright (c) 2021 Tulir Asokan\n//\n// This Source Code Form is subject to the terms of the Mozilla Public\n// License, v. 2.0. If a copy of the MPL was not distributed with this\n// file, You can obtain one at http://mozilla.org/MPL/2.0/.\n\npackage whatsmeow\n\nimport (\n\t\"strconv\"\n\t\"time\"\n\n\twaBinary \"go.mau.fi/whatsmeow/binary\"\n\t\"go.mau.fi/whatsmeow/types\"\n\t\"go.mau.fi/whatsmeow/types/events\"\n)\n\n// TryFetchPrivacySettings will fetch the user's privacy settings, either from the in-memory cache or from the server.\nfunc (cli *Client) TryFetchPrivacySettings(ignoreCache bool) (*types.PrivacySettings, error) {\n\tif val := cli.privacySettingsCache.Load(); val != nil && !ignoreCache {\n\t\treturn val.(*types.PrivacySettings), nil\n\t}\n\tresp, err := cli.sendIQ(infoQuery{\n\t\tNamespace: \"privacy\",\n\t\tType:      iqGet,\n\t\tTo:        types.ServerJID,\n\t\tContent:   []waBinary.Node{{Tag: \"privacy\"}},\n\t})\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tprivacyNode, ok := resp.GetOptionalChildByTag(\"privacy\")\n\tif !ok {\n\t\treturn nil, &ElementMissingError{Tag: \"privacy\", In: \"response to privacy settings query\"}\n\t}\n\tvar settings types.PrivacySettings\n\tcli.parsePrivacySettings(&privacyNode, &settings)\n\tcli.privacySettingsCache.Store(&settings)\n\treturn &settings, nil\n}\n\n// GetPrivacySettings will get the user's privacy settings. If an error occurs while fetching them, the error will be\n// logged, but the method will just return an empty struct.\nfunc (cli *Client) GetPrivacySettings() (settings types.PrivacySettings) {\n\tif cli == nil || cli.MessengerConfig != nil {\n\t\treturn\n\t}\n\tsettingsPtr, err := cli.TryFetchPrivacySettings(false)\n\tif err != nil {\n\t\tcli.Log.Errorf(\"Failed to fetch privacy settings: %v\", err)\n\t} else {\n\t\tsettings = *settingsPtr\n\t}\n\treturn\n}\n\n// SetPrivacySetting will set the given privacy setting to the given value.\n// The privacy settings will be fetched from the server after the change and the new settings will be returned.\n// If an error occurs while fetching the new settings, will return an empty struct.\nfunc (cli *Client) SetPrivacySetting(name types.PrivacySettingType, value types.PrivacySetting) (settings types.PrivacySettings, err error) {\n\tsettingsPtr, err := cli.TryFetchPrivacySettings(false)\n\tif err != nil {\n\t\treturn settings, err\n\t}\n\t_, err = cli.sendIQ(infoQuery{\n\t\tNamespace: \"privacy\",\n\t\tType:      iqSet,\n\t\tTo:        types.ServerJID,\n\t\tContent: []waBinary.Node{{\n\t\t\tTag: \"privacy\",\n\t\t\tContent: []waBinary.Node{{\n\t\t\t\tTag: \"category\",\n\t\t\t\tAttrs: waBinary.Attrs{\n\t\t\t\t\t\"name\":  string(name),\n\t\t\t\t\t\"value\": string(value),\n\t\t\t\t},\n\t\t\t}},\n\t\t}},\n\t})\n\tif err != nil {\n\t\treturn settings, err\n\t}\n\tsettings = *settingsPtr\n\tswitch name {\n\tcase types.PrivacySettingTypeGroupAdd:\n\t\tsettings.GroupAdd = value\n\tcase types.PrivacySettingTypeLastSeen:\n\t\tsettings.LastSeen = value\n\tcase types.PrivacySettingTypeStatus:\n\t\tsettings.Status = value\n\tcase types.PrivacySettingTypeProfile:\n\t\tsettings.Profile = value\n\tcase types.PrivacySettingTypeReadReceipts:\n\t\tsettings.ReadReceipts = value\n\tcase types.PrivacySettingTypeOnline:\n\t\tsettings.Online = value\n\tcase types.PrivacySettingTypeCallAdd:\n\t\tsettings.CallAdd = value\n\t}\n\tcli.privacySettingsCache.Store(&settings)\n\treturn\n}\n\n// SetDefaultDisappearingTimer will set the default disappearing message timer.\nfunc (cli *Client) SetDefaultDisappearingTimer(timer time.Duration) (err error) {\n\t_, err = cli.sendIQ(infoQuery{\n\t\tNamespace: \"disappearing_mode\",\n\t\tType:      iqSet,\n\t\tTo:        types.ServerJID,\n\t\tContent: []waBinary.Node{{\n\t\t\tTag: \"disappearing_mode\",\n\t\t\tAttrs: waBinary.Attrs{\n\t\t\t\t\"duration\": strconv.Itoa(int(timer.Seconds())),\n\t\t\t},\n\t\t}},\n\t})\n\treturn\n}\n\nfunc (cli *Client) parsePrivacySettings(privacyNode *waBinary.Node, settings *types.PrivacySettings) *events.PrivacySettings {\n\tvar evt events.PrivacySettings\n\tfor _, child := range privacyNode.GetChildren() {\n\t\tif child.Tag != \"category\" {\n\t\t\tcontinue\n\t\t}\n\t\tag := child.AttrGetter()\n\t\tname := types.PrivacySettingType(ag.String(\"name\"))\n\t\tvalue := types.PrivacySetting(ag.String(\"value\"))\n\t\tswitch name {\n\t\tcase types.PrivacySettingTypeGroupAdd:\n\t\t\tsettings.GroupAdd = value\n\t\t\tevt.GroupAddChanged = true\n\t\tcase types.PrivacySettingTypeLastSeen:\n\t\t\tsettings.LastSeen = value\n\t\t\tevt.LastSeenChanged = true\n\t\tcase types.PrivacySettingTypeStatus:\n\t\t\tsettings.Status = value\n\t\t\tevt.StatusChanged = true\n\t\tcase types.PrivacySettingTypeProfile:\n\t\t\tsettings.Profile = value\n\t\t\tevt.ProfileChanged = true\n\t\tcase types.PrivacySettingTypeReadReceipts:\n\t\t\tsettings.ReadReceipts = value\n\t\t\tevt.ReadReceiptsChanged = true\n\t\tcase types.PrivacySettingTypeOnline:\n\t\t\tsettings.Online = value\n\t\t\tevt.OnlineChanged = true\n\t\tcase types.PrivacySettingTypeCallAdd:\n\t\t\tsettings.CallAdd = value\n\t\t\tevt.CallAddChanged = true\n\t\t}\n\t}\n\treturn &evt\n}\n\nfunc (cli *Client) handlePrivacySettingsNotification(privacyNode *waBinary.Node) {\n\tcli.Log.Debugf(\"Parsing privacy settings change notification\")\n\tsettings, err := cli.TryFetchPrivacySettings(false)\n\tif err != nil {\n\t\tcli.Log.Errorf(\"Failed to fetch privacy settings when handling change: %v\", err)\n\t\treturn\n\t}\n\tevt := cli.parsePrivacySettings(privacyNode, settings)\n\t// The data isn't be reliable if the fetch failed, so only cache if it didn't fail\n\tif err == nil {\n\t\tcli.privacySettingsCache.Store(settings)\n\t}\n\tcli.dispatchEvent(evt)\n}\n"
        },
        {
          "name": "proto",
          "type": "tree",
          "content": null
        },
        {
          "name": "push.go",
          "type": "blob",
          "size": 1.8681640625,
          "content": "// Copyright (c) 2024 Tulir Asokan\n//\n// This Source Code Form is subject to the terms of the Mozilla Public\n// License, v. 2.0. If a copy of the MPL was not distributed with this\n// file, You can obtain one at http://mozilla.org/MPL/2.0/.\n\npackage whatsmeow\n\nimport (\n\t\"context\"\n\t\"encoding/base64\"\n\n\twaBinary \"go.mau.fi/whatsmeow/binary\"\n\t\"go.mau.fi/whatsmeow/types\"\n)\n\ntype PushConfig interface {\n\tGetPushConfigAttrs() waBinary.Attrs\n}\n\ntype FCMPushConfig struct {\n\tToken string `json:\"token\"`\n}\n\nfunc (fpc *FCMPushConfig) GetPushConfigAttrs() waBinary.Attrs {\n\treturn waBinary.Attrs{\n\t\t\"id\":       fpc.Token,\n\t\t\"num_acc\":  1,\n\t\t\"platform\": \"gcm\",\n\t}\n}\n\ntype WebPushConfig struct {\n\tEndpoint string `json:\"endpoint\"`\n\tAuth     []byte `json:\"auth\"`\n\tP256DH   []byte `json:\"p256dh\"`\n}\n\nfunc (wpc *WebPushConfig) GetPushConfigAttrs() waBinary.Attrs {\n\treturn waBinary.Attrs{\n\t\t\"platform\": \"web\",\n\t\t\"endpoint\": wpc.Endpoint,\n\t\t\"auth\":     base64.StdEncoding.EncodeToString(wpc.Auth),\n\t\t\"p256dh\":   base64.StdEncoding.EncodeToString(wpc.P256DH),\n\t}\n}\n\nfunc (cli *Client) GetServerPushNotificationConfig(ctx context.Context) (*waBinary.Node, error) {\n\tresp, err := cli.sendIQ(infoQuery{\n\t\tNamespace: \"urn:xmpp:whatsapp:push\",\n\t\tType:      iqGet,\n\t\tTo:        types.ServerJID,\n\t\tContent:   []waBinary.Node{{Tag: \"settings\"}},\n\t\tContext:   ctx,\n\t})\n\treturn resp, err\n}\n\n// RegisterForPushNotifications registers a token to receive push notifications for new WhatsApp messages.\n//\n// This is generally not necessary for anything. Don't use this if you don't know what you're doing.\nfunc (cli *Client) RegisterForPushNotifications(ctx context.Context, pc PushConfig) error {\n\t_, err := cli.sendIQ(infoQuery{\n\t\tNamespace: \"urn:xmpp:whatsapp:push\",\n\t\tType:      iqSet,\n\t\tTo:        types.ServerJID,\n\t\tContent: []waBinary.Node{{\n\t\t\tTag:   \"config\",\n\t\t\tAttrs: pc.GetPushConfigAttrs(),\n\t\t}},\n\t\tContext: ctx,\n\t})\n\treturn err\n}\n"
        },
        {
          "name": "qrchan.go",
          "type": "blob",
          "size": 6.1357421875,
          "content": "// Copyright (c) 2022 Tulir Asokan\n//\n// This Source Code Form is subject to the terms of the Mozilla Public\n// License, v. 2.0. If a copy of the MPL was not distributed with this\n// file, You can obtain one at http://mozilla.org/MPL/2.0/.\n\npackage whatsmeow\n\nimport (\n\t\"context\"\n\t\"sync\"\n\t\"sync/atomic\"\n\t\"time\"\n\n\t\"go.mau.fi/whatsmeow/types/events\"\n\twaLog \"go.mau.fi/whatsmeow/util/log\"\n)\n\ntype QRChannelItem struct {\n\t// The type of event, \"code\" for new QR codes (see Code field) and \"error\" for pairing errors (see Error) field.\n\t// For non-code/error events, you can just compare the whole item to the event variables (like QRChannelSuccess).\n\tEvent string\n\t// If the item is a pair error, then this field contains the error message.\n\tError error\n\t// If the item is a new code, then this field contains the raw data.\n\tCode string\n\t// The timeout after which the next code will be sent down the channel.\n\tTimeout time.Duration\n}\n\nconst QRChannelEventCode = \"code\"\nconst QRChannelEventError = \"error\"\n\n// Possible final items in the QR channel. In addition to these, an `error` event may be emitted,\n// in which case the Error field will have the error that occurred during pairing.\nvar (\n\t// QRChannelSuccess is emitted from GetQRChannel when the pairing is successful.\n\tQRChannelSuccess = QRChannelItem{Event: \"success\"}\n\t// QRChannelTimeout is emitted from GetQRChannel if the socket gets disconnected by the server before the pairing is successful.\n\tQRChannelTimeout = QRChannelItem{Event: \"timeout\"}\n\t// QRChannelErrUnexpectedEvent is emitted from GetQRChannel if an unexpected connection event is received,\n\t// as that likely means that the pairing has already happened before the channel was set up.\n\tQRChannelErrUnexpectedEvent = QRChannelItem{Event: \"err-unexpected-state\"}\n\t// QRChannelClientOutdated is emitted from GetQRChannel if events.ClientOutdated is received.\n\tQRChannelClientOutdated = QRChannelItem{Event: \"err-client-outdated\"}\n\t// QRChannelScannedWithoutMultidevice is emitted from GetQRChannel if events.QRScannedWithoutMultidevice is received.\n\tQRChannelScannedWithoutMultidevice = QRChannelItem{Event: \"err-scanned-without-multidevice\"}\n)\n\ntype qrChannel struct {\n\tsync.Mutex\n\tcli       *Client\n\tlog       waLog.Logger\n\tctx       context.Context\n\thandlerID uint32\n\tclosed    uint32\n\toutput    chan<- QRChannelItem\n\tstopQRs   chan struct{}\n}\n\nfunc (qrc *qrChannel) emitQRs(evt *events.QR) {\n\tvar nextCode string\n\tfor {\n\t\tif len(evt.Codes) == 0 {\n\t\t\tif atomic.CompareAndSwapUint32(&qrc.closed, 0, 1) {\n\t\t\t\tqrc.log.Debugf(\"Ran out of QR codes, closing channel with status %s and disconnecting client\", QRChannelTimeout)\n\t\t\t\tqrc.output <- QRChannelTimeout\n\t\t\t\tclose(qrc.output)\n\t\t\t\tgo qrc.cli.RemoveEventHandler(qrc.handlerID)\n\t\t\t\tqrc.cli.Disconnect()\n\t\t\t} else {\n\t\t\t\tqrc.log.Debugf(\"Ran out of QR codes, but channel is already closed\")\n\t\t\t}\n\t\t\treturn\n\t\t} else if atomic.LoadUint32(&qrc.closed) == 1 {\n\t\t\tqrc.log.Debugf(\"QR code channel is closed, exiting QR emitter\")\n\t\t\treturn\n\t\t}\n\t\ttimeout := 20 * time.Second\n\t\tif len(evt.Codes) == 6 {\n\t\t\ttimeout = 60 * time.Second\n\t\t}\n\t\tnextCode, evt.Codes = evt.Codes[0], evt.Codes[1:]\n\t\tqrc.log.Debugf(\"Emitting QR code %s\", nextCode)\n\t\tselect {\n\t\tcase qrc.output <- QRChannelItem{Code: nextCode, Timeout: timeout, Event: QRChannelEventCode}:\n\t\tdefault:\n\t\t\tqrc.log.Debugf(\"Output channel didn't accept code, exiting QR emitter\")\n\t\t\tif atomic.CompareAndSwapUint32(&qrc.closed, 0, 1) {\n\t\t\t\tclose(qrc.output)\n\t\t\t\tgo qrc.cli.RemoveEventHandler(qrc.handlerID)\n\t\t\t\tqrc.cli.Disconnect()\n\t\t\t}\n\t\t\treturn\n\t\t}\n\t\tselect {\n\t\tcase <-time.After(timeout):\n\t\tcase <-qrc.stopQRs:\n\t\t\tqrc.log.Debugf(\"Got signal to stop QR emitter\")\n\t\t\treturn\n\t\tcase <-qrc.ctx.Done():\n\t\t\tqrc.log.Debugf(\"Context is done, stopping QR emitter\")\n\t\t\tif atomic.CompareAndSwapUint32(&qrc.closed, 0, 1) {\n\t\t\t\tclose(qrc.output)\n\t\t\t\tgo qrc.cli.RemoveEventHandler(qrc.handlerID)\n\t\t\t\tqrc.cli.Disconnect()\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc (qrc *qrChannel) handleEvent(rawEvt interface{}) {\n\tif atomic.LoadUint32(&qrc.closed) == 1 {\n\t\tqrc.log.Debugf(\"Dropping event of type %T, channel is closed\", rawEvt)\n\t\treturn\n\t}\n\tvar outputType QRChannelItem\n\tswitch evt := rawEvt.(type) {\n\tcase *events.QR:\n\t\tqrc.log.Debugf(\"Received QR code event, starting to emit codes to channel\")\n\t\tgo qrc.emitQRs(evt)\n\t\treturn\n\tcase *events.QRScannedWithoutMultidevice:\n\t\tqrc.log.Debugf(\"QR code scanned without multidevice enabled\")\n\t\tqrc.output <- QRChannelScannedWithoutMultidevice\n\t\treturn\n\tcase *events.ClientOutdated:\n\t\toutputType = QRChannelClientOutdated\n\tcase *events.PairSuccess:\n\t\toutputType = QRChannelSuccess\n\tcase *events.PairError:\n\t\toutputType = QRChannelItem{\n\t\t\tEvent: QRChannelEventError,\n\t\t\tError: evt.Error,\n\t\t}\n\tcase *events.Disconnected:\n\t\toutputType = QRChannelTimeout\n\tcase *events.Connected, *events.ConnectFailure, *events.LoggedOut, *events.TemporaryBan:\n\t\toutputType = QRChannelErrUnexpectedEvent\n\tdefault:\n\t\treturn\n\t}\n\tclose(qrc.stopQRs)\n\tif atomic.CompareAndSwapUint32(&qrc.closed, 0, 1) {\n\t\tqrc.log.Debugf(\"Closing channel with status %+v\", outputType)\n\t\tqrc.output <- outputType\n\t\tclose(qrc.output)\n\t} else {\n\t\tqrc.log.Debugf(\"Got status %+v, but channel is already closed\", outputType)\n\t}\n\t// Has to be done in background because otherwise there's a deadlock with eventHandlersLock\n\tgo qrc.cli.RemoveEventHandler(qrc.handlerID)\n}\n\n// GetQRChannel returns a channel that automatically outputs a new QR code when the previous one expires.\n//\n// This must be called *before* Connect(). It will then listen to all the relevant events from the client.\n//\n// The last value to be emitted will be a special event like \"success\", \"timeout\" or another error code\n// depending on the result of the pairing. The channel will be closed immediately after one of those.\nfunc (cli *Client) GetQRChannel(ctx context.Context) (<-chan QRChannelItem, error) {\n\tif cli == nil {\n\t\treturn nil, ErrClientIsNil\n\t} else if cli.IsConnected() {\n\t\treturn nil, ErrQRAlreadyConnected\n\t} else if cli.Store.ID != nil {\n\t\treturn nil, ErrQRStoreContainsID\n\t}\n\tch := make(chan QRChannelItem, 8)\n\tqrc := qrChannel{\n\t\toutput:  ch,\n\t\tstopQRs: make(chan struct{}),\n\t\tcli:     cli,\n\t\tlog:     cli.Log.Sub(\"QRChannel\"),\n\t\tctx:     ctx,\n\t}\n\tqrc.handlerID = cli.AddEventHandler(qrc.handleEvent)\n\treturn ch, nil\n}\n"
        },
        {
          "name": "receipt.go",
          "type": "blob",
          "size": 7.1904296875,
          "content": "// Copyright (c) 2021 Tulir Asokan\n//\n// This Source Code Form is subject to the terms of the Mozilla Public\n// License, v. 2.0. If a copy of the MPL was not distributed with this\n// file, You can obtain one at http://mozilla.org/MPL/2.0/.\n\npackage whatsmeow\n\nimport (\n\t\"fmt\"\n\t\"time\"\n\n\twaBinary \"go.mau.fi/whatsmeow/binary\"\n\t\"go.mau.fi/whatsmeow/types\"\n\t\"go.mau.fi/whatsmeow/types/events\"\n)\n\nfunc (cli *Client) handleReceipt(node *waBinary.Node) {\n\treceipt, err := cli.parseReceipt(node)\n\tif err != nil {\n\t\tcli.Log.Warnf(\"Failed to parse receipt: %v\", err)\n\t} else if receipt != nil {\n\t\tif receipt.Type == types.ReceiptTypeRetry {\n\t\t\tgo func() {\n\t\t\t\terr := cli.handleRetryReceipt(receipt, node)\n\t\t\t\tif err != nil {\n\t\t\t\t\tcli.Log.Errorf(\"Failed to handle retry receipt for %s/%s from %s: %v\", receipt.Chat, receipt.MessageIDs[0], receipt.Sender, err)\n\t\t\t\t}\n\t\t\t}()\n\t\t}\n\t\tgo cli.dispatchEvent(receipt)\n\t}\n\tgo cli.sendAck(node)\n}\n\nfunc (cli *Client) handleGroupedReceipt(partialReceipt events.Receipt, participants *waBinary.Node) {\n\tpag := participants.AttrGetter()\n\tpartialReceipt.MessageIDs = []types.MessageID{pag.String(\"key\")}\n\tfor _, child := range participants.GetChildren() {\n\t\tif child.Tag != \"user\" {\n\t\t\tcli.Log.Warnf(\"Unexpected node in grouped receipt participants: %s\", child.XMLString())\n\t\t\tcontinue\n\t\t}\n\t\tag := child.AttrGetter()\n\t\treceipt := partialReceipt\n\t\treceipt.Timestamp = ag.UnixTime(\"t\")\n\t\treceipt.MessageSource.Sender = ag.JID(\"jid\")\n\t\tif !ag.OK() {\n\t\t\tcli.Log.Warnf(\"Failed to parse user node %s in grouped receipt: %v\", child.XMLString(), ag.Error())\n\t\t\tcontinue\n\t\t}\n\t\tgo cli.dispatchEvent(&receipt)\n\t}\n}\n\nfunc (cli *Client) parseReceipt(node *waBinary.Node) (*events.Receipt, error) {\n\tag := node.AttrGetter()\n\tsource, err := cli.parseMessageSource(node, false)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treceipt := events.Receipt{\n\t\tMessageSource: source,\n\t\tTimestamp:     ag.UnixTime(\"t\"),\n\t\tType:          types.ReceiptType(ag.OptionalString(\"type\")),\n\t\tMessageSender: ag.OptionalJIDOrEmpty(\"recipient\"),\n\t}\n\tif source.IsGroup && source.Sender.IsEmpty() {\n\t\tparticipantTags := node.GetChildrenByTag(\"participants\")\n\t\tif len(participantTags) == 0 {\n\t\t\treturn nil, &ElementMissingError{Tag: \"participants\", In: \"grouped receipt\"}\n\t\t}\n\t\tfor _, pcp := range participantTags {\n\t\t\tcli.handleGroupedReceipt(receipt, &pcp)\n\t\t}\n\t\treturn nil, nil\n\t}\n\tmainMessageID := ag.String(\"id\")\n\tif !ag.OK() {\n\t\treturn nil, fmt.Errorf(\"failed to parse read receipt attrs: %+v\", ag.Errors)\n\t}\n\n\treceiptChildren := node.GetChildren()\n\tif len(receiptChildren) == 1 && receiptChildren[0].Tag == \"list\" {\n\t\tlistChildren := receiptChildren[0].GetChildren()\n\t\treceipt.MessageIDs = make([]string, 1, len(listChildren)+1)\n\t\treceipt.MessageIDs[0] = mainMessageID\n\t\tfor _, item := range listChildren {\n\t\t\tif id, ok := item.Attrs[\"id\"].(string); ok && item.Tag == \"item\" {\n\t\t\t\treceipt.MessageIDs = append(receipt.MessageIDs, id)\n\t\t\t}\n\t\t}\n\t} else {\n\t\treceipt.MessageIDs = []types.MessageID{mainMessageID}\n\t}\n\treturn &receipt, nil\n}\n\nfunc (cli *Client) sendAck(node *waBinary.Node) {\n\tattrs := waBinary.Attrs{\n\t\t\"class\": node.Tag,\n\t\t\"id\":    node.Attrs[\"id\"],\n\t}\n\tattrs[\"to\"] = node.Attrs[\"from\"]\n\tif participant, ok := node.Attrs[\"participant\"]; ok {\n\t\tattrs[\"participant\"] = participant\n\t}\n\tif recipient, ok := node.Attrs[\"recipient\"]; ok {\n\t\tattrs[\"recipient\"] = recipient\n\t}\n\tif receiptType, ok := node.Attrs[\"type\"]; node.Tag != \"message\" && ok {\n\t\tattrs[\"type\"] = receiptType\n\t}\n\terr := cli.sendNode(waBinary.Node{\n\t\tTag:   \"ack\",\n\t\tAttrs: attrs,\n\t})\n\tif err != nil {\n\t\tcli.Log.Warnf(\"Failed to send acknowledgement for %s %s: %v\", node.Tag, node.Attrs[\"id\"], err)\n\t}\n}\n\n// MarkRead sends a read receipt for the given message IDs including the given timestamp as the read at time.\n//\n// The first JID parameter (chat) must always be set to the chat ID (user ID in DMs and group ID in group chats).\n// The second JID parameter (sender) must be set in group chats and must be the user ID who sent the message.\n//\n// You can mark multiple messages as read at the same time, but only if the messages were sent by the same user.\n// To mark messages by different users as read, you must call MarkRead multiple times (once for each user).\n//\n// To mark a voice message as played, specify types.ReceiptTypePlayed as the last parameter.\n// Providing more than one receipt type will panic: the parameter is only a vararg for backwards compatibility.\nfunc (cli *Client) MarkRead(ids []types.MessageID, timestamp time.Time, chat, sender types.JID, receiptTypeExtra ...types.ReceiptType) error {\n\tif len(ids) == 0 {\n\t\treturn fmt.Errorf(\"no message IDs specified\")\n\t}\n\treceiptType := types.ReceiptTypeRead\n\tif len(receiptTypeExtra) == 1 {\n\t\treceiptType = receiptTypeExtra[0]\n\t} else if len(receiptTypeExtra) > 1 {\n\t\tpanic(fmt.Errorf(\"too many receipt types specified\"))\n\t}\n\tnode := waBinary.Node{\n\t\tTag: \"receipt\",\n\t\tAttrs: waBinary.Attrs{\n\t\t\t\"id\":   ids[0],\n\t\t\t\"type\": string(receiptType),\n\t\t\t\"to\":   chat,\n\t\t\t\"t\":    timestamp.Unix(),\n\t\t},\n\t}\n\tif chat.Server == types.NewsletterServer || cli.GetPrivacySettings().ReadReceipts == types.PrivacySettingNone {\n\t\tswitch receiptType {\n\t\tcase types.ReceiptTypeRead:\n\t\t\tnode.Attrs[\"type\"] = string(types.ReceiptTypeReadSelf)\n\t\t\t// TODO change played to played-self?\n\t\t}\n\t}\n\tif !sender.IsEmpty() && chat.Server != types.DefaultUserServer && chat.Server != types.MessengerServer {\n\t\tnode.Attrs[\"participant\"] = sender.ToNonAD()\n\t}\n\tif len(ids) > 1 {\n\t\tchildren := make([]waBinary.Node, len(ids)-1)\n\t\tfor i := 1; i < len(ids); i++ {\n\t\t\tchildren[i-1].Tag = \"item\"\n\t\t\tchildren[i-1].Attrs = waBinary.Attrs{\"id\": ids[i]}\n\t\t}\n\t\tnode.Content = []waBinary.Node{{\n\t\t\tTag:     \"list\",\n\t\t\tContent: children,\n\t\t}}\n\t}\n\treturn cli.sendNode(node)\n}\n\n// SetForceActiveDeliveryReceipts will force the client to send normal delivery\n// receipts (which will show up as the two gray ticks on WhatsApp), even if the\n// client isn't marked as online.\n//\n// By default, clients that haven't been marked as online will send delivery\n// receipts with type=\"inactive\", which is transmitted to the sender, but not\n// rendered in the official WhatsApp apps. This is consistent with how WhatsApp\n// web works when it's not in the foreground.\n//\n// To mark the client as online, use\n//\n//\tcli.SendPresence(types.PresenceAvailable)\n//\n// Note that if you turn this off (i.e. call SetForceActiveDeliveryReceipts(false)),\n// receipts will act like the client is offline until SendPresence is called again.\nfunc (cli *Client) SetForceActiveDeliveryReceipts(active bool) {\n\tif active {\n\t\tcli.sendActiveReceipts.Store(2)\n\t} else {\n\t\tcli.sendActiveReceipts.Store(0)\n\t}\n}\n\nfunc (cli *Client) sendMessageReceipt(info *types.MessageInfo) {\n\tattrs := waBinary.Attrs{\n\t\t\"id\": info.ID,\n\t}\n\tif info.IsFromMe {\n\t\tattrs[\"type\"] = string(types.ReceiptTypeSender)\n\t} else if cli.sendActiveReceipts.Load() == 0 {\n\t\tattrs[\"type\"] = string(types.ReceiptTypeInactive)\n\t}\n\tattrs[\"to\"] = info.Chat\n\tif info.IsGroup {\n\t\tattrs[\"participant\"] = info.Sender\n\t} else if info.IsFromMe {\n\t\tattrs[\"recipient\"] = info.Sender\n\t} else {\n\t\t// Override the to attribute with the JID version with a device number\n\t\tattrs[\"to\"] = info.Sender\n\t}\n\terr := cli.sendNode(waBinary.Node{\n\t\tTag:   \"receipt\",\n\t\tAttrs: attrs,\n\t})\n\tif err != nil {\n\t\tcli.Log.Warnf(\"Failed to send receipt for %s: %v\", info.ID, err)\n\t}\n}\n"
        },
        {
          "name": "request.go",
          "type": "blob",
          "size": 6.013671875,
          "content": "// Copyright (c) 2021 Tulir Asokan\n//\n// This Source Code Form is subject to the terms of the Mozilla Public\n// License, v. 2.0. If a copy of the MPL was not distributed with this\n// file, You can obtain one at http://mozilla.org/MPL/2.0/.\n\npackage whatsmeow\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"strconv\"\n\t\"time\"\n\n\twaBinary \"go.mau.fi/whatsmeow/binary\"\n\t\"go.mau.fi/whatsmeow/types\"\n)\n\nfunc (cli *Client) generateRequestID() string {\n\treturn cli.uniqueID + strconv.FormatUint(cli.idCounter.Add(1), 10)\n}\n\nvar xmlStreamEndNode = &waBinary.Node{Tag: \"xmlstreamend\"}\n\nfunc isDisconnectNode(node *waBinary.Node) bool {\n\treturn node == xmlStreamEndNode || node.Tag == \"stream:error\"\n}\n\n// isAuthErrorDisconnect checks if the given disconnect node is an error that shouldn't cause retrying.\nfunc isAuthErrorDisconnect(node *waBinary.Node) bool {\n\tif node.Tag != \"stream:error\" {\n\t\treturn false\n\t}\n\tcode, _ := node.Attrs[\"code\"].(string)\n\tconflict, _ := node.GetOptionalChildByTag(\"conflict\")\n\tconflictType := conflict.AttrGetter().OptionalString(\"type\")\n\tif code == \"401\" || conflictType == \"replaced\" || conflictType == \"device_removed\" {\n\t\treturn true\n\t}\n\treturn false\n}\n\nfunc (cli *Client) clearResponseWaiters(node *waBinary.Node) {\n\tcli.responseWaitersLock.Lock()\n\tfor _, waiter := range cli.responseWaiters {\n\t\tselect {\n\t\tcase waiter <- node:\n\t\tdefault:\n\t\t\tclose(waiter)\n\t\t}\n\t}\n\tcli.responseWaiters = make(map[string]chan<- *waBinary.Node)\n\tcli.responseWaitersLock.Unlock()\n}\n\nfunc (cli *Client) waitResponse(reqID string) chan *waBinary.Node {\n\tch := make(chan *waBinary.Node, 1)\n\tcli.responseWaitersLock.Lock()\n\tcli.responseWaiters[reqID] = ch\n\tcli.responseWaitersLock.Unlock()\n\treturn ch\n}\n\nfunc (cli *Client) cancelResponse(reqID string, ch chan *waBinary.Node) {\n\tcli.responseWaitersLock.Lock()\n\tclose(ch)\n\tdelete(cli.responseWaiters, reqID)\n\tcli.responseWaitersLock.Unlock()\n}\n\nfunc (cli *Client) receiveResponse(data *waBinary.Node) bool {\n\tid, ok := data.Attrs[\"id\"].(string)\n\tif !ok || (data.Tag != \"iq\" && data.Tag != \"ack\") {\n\t\treturn false\n\t}\n\tcli.responseWaitersLock.Lock()\n\twaiter, ok := cli.responseWaiters[id]\n\tif !ok {\n\t\tcli.responseWaitersLock.Unlock()\n\t\treturn false\n\t}\n\tdelete(cli.responseWaiters, id)\n\tcli.responseWaitersLock.Unlock()\n\twaiter <- data\n\treturn true\n}\n\ntype infoQueryType string\n\nconst (\n\tiqSet infoQueryType = \"set\"\n\tiqGet infoQueryType = \"get\"\n)\n\ntype infoQuery struct {\n\tNamespace string\n\tType      infoQueryType\n\tTo        types.JID\n\tTarget    types.JID\n\tID        string\n\tContent   interface{}\n\n\tTimeout time.Duration\n\tNoRetry bool\n\tContext context.Context\n}\n\nfunc (cli *Client) sendIQAsyncAndGetData(query *infoQuery) (<-chan *waBinary.Node, []byte, error) {\n\tif cli == nil {\n\t\treturn nil, nil, ErrClientIsNil\n\t}\n\tif len(query.ID) == 0 {\n\t\tquery.ID = cli.generateRequestID()\n\t}\n\twaiter := cli.waitResponse(query.ID)\n\tattrs := waBinary.Attrs{\n\t\t\"id\":    query.ID,\n\t\t\"xmlns\": query.Namespace,\n\t\t\"type\":  string(query.Type),\n\t}\n\tif !query.To.IsEmpty() {\n\t\tattrs[\"to\"] = query.To\n\t}\n\tif !query.Target.IsEmpty() {\n\t\tattrs[\"target\"] = query.Target\n\t}\n\tdata, err := cli.sendNodeAndGetData(waBinary.Node{\n\t\tTag:     \"iq\",\n\t\tAttrs:   attrs,\n\t\tContent: query.Content,\n\t})\n\tif err != nil {\n\t\tcli.cancelResponse(query.ID, waiter)\n\t\treturn nil, data, err\n\t}\n\treturn waiter, data, nil\n}\n\nfunc (cli *Client) sendIQAsync(query infoQuery) (<-chan *waBinary.Node, error) {\n\tch, _, err := cli.sendIQAsyncAndGetData(&query)\n\treturn ch, err\n}\n\nconst defaultRequestTimeout = 75 * time.Second\n\nfunc (cli *Client) sendIQ(query infoQuery) (*waBinary.Node, error) {\n\tresChan, data, err := cli.sendIQAsyncAndGetData(&query)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif query.Timeout == 0 {\n\t\tquery.Timeout = defaultRequestTimeout\n\t}\n\tif query.Context == nil {\n\t\tquery.Context = context.Background()\n\t}\n\tselect {\n\tcase res := <-resChan:\n\t\tif isDisconnectNode(res) {\n\t\t\tif query.NoRetry {\n\t\t\t\treturn nil, &DisconnectedError{Action: \"info query\", Node: res}\n\t\t\t}\n\t\t\tres, err = cli.retryFrame(\"info query\", query.ID, data, res, query.Context, query.Timeout)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t}\n\t\tresType, _ := res.Attrs[\"type\"].(string)\n\t\tif res.Tag != \"iq\" || (resType != \"result\" && resType != \"error\") {\n\t\t\treturn res, &IQError{RawNode: res}\n\t\t} else if resType == \"error\" {\n\t\t\treturn res, parseIQError(res)\n\t\t}\n\t\treturn res, nil\n\tcase <-query.Context.Done():\n\t\treturn nil, query.Context.Err()\n\tcase <-time.After(query.Timeout):\n\t\treturn nil, ErrIQTimedOut\n\t}\n}\n\nfunc (cli *Client) retryFrame(reqType, id string, data []byte, origResp *waBinary.Node, ctx context.Context, timeout time.Duration) (*waBinary.Node, error) {\n\tif isAuthErrorDisconnect(origResp) {\n\t\tcli.Log.Debugf(\"%s (%s) was interrupted by websocket disconnection (%s), not retrying as it looks like an auth error\", id, reqType, origResp.XMLString())\n\t\treturn nil, &DisconnectedError{Action: reqType, Node: origResp}\n\t}\n\n\tcli.Log.Debugf(\"%s (%s) was interrupted by websocket disconnection (%s), waiting for reconnect to retry...\", id, reqType, origResp.XMLString())\n\tif !cli.WaitForConnection(5 * time.Second) {\n\t\tcli.Log.Debugf(\"Websocket didn't reconnect within 5 seconds of failed %s (%s)\", reqType, id)\n\t\treturn nil, &DisconnectedError{Action: reqType, Node: origResp}\n\t}\n\n\tcli.socketLock.RLock()\n\tsock := cli.socket\n\tcli.socketLock.RUnlock()\n\tif sock == nil {\n\t\treturn nil, ErrNotConnected\n\t}\n\n\trespChan := cli.waitResponse(id)\n\terr := sock.SendFrame(data)\n\tif err != nil {\n\t\tcli.cancelResponse(id, respChan)\n\t\treturn nil, err\n\t}\n\tvar resp *waBinary.Node\n\ttimeoutChan := make(<-chan time.Time, 1)\n\tif timeout > 0 {\n\t\ttimeoutChan = time.After(timeout)\n\t}\n\tselect {\n\tcase resp = <-respChan:\n\tcase <-ctx.Done():\n\t\treturn nil, ctx.Err()\n\tcase <-timeoutChan:\n\t\t// FIXME this error isn't technically correct (but works for now - the timeout param is only used from sendIQ)\n\t\treturn nil, ErrIQTimedOut\n\t}\n\tif isDisconnectNode(resp) {\n\t\tcli.Log.Debugf(\"Retrying %s %s was interrupted by websocket disconnection (%v), not retrying anymore\", reqType, id, resp.XMLString())\n\t\treturn nil, &DisconnectedError{Action: fmt.Sprintf(\"%s (retry)\", reqType), Node: resp}\n\t}\n\treturn resp, nil\n}\n"
        },
        {
          "name": "retry.go",
          "type": "blob",
          "size": 14.0302734375,
          "content": "// Copyright (c) 2021 Tulir Asokan\n//\n// This Source Code Form is subject to the terms of the Mozilla Public\n// License, v. 2.0. If a copy of the MPL was not distributed with this\n// file, You can obtain one at http://mozilla.org/MPL/2.0/.\n\npackage whatsmeow\n\nimport (\n\t\"context\"\n\t\"crypto/hmac\"\n\t\"crypto/sha256\"\n\t\"encoding/binary\"\n\t\"fmt\"\n\t\"time\"\n\n\t\"go.mau.fi/libsignal/ecc\"\n\t\"go.mau.fi/libsignal/groups\"\n\t\"go.mau.fi/libsignal/keys/prekey\"\n\t\"go.mau.fi/libsignal/protocol\"\n\t\"google.golang.org/protobuf/proto\"\n\n\twaBinary \"go.mau.fi/whatsmeow/binary\"\n\twaProto \"go.mau.fi/whatsmeow/binary/proto\"\n\t\"go.mau.fi/whatsmeow/proto/waCommon\"\n\t\"go.mau.fi/whatsmeow/proto/waConsumerApplication\"\n\t\"go.mau.fi/whatsmeow/proto/waMsgApplication\"\n\t\"go.mau.fi/whatsmeow/proto/waMsgTransport\"\n\t\"go.mau.fi/whatsmeow/types\"\n\t\"go.mau.fi/whatsmeow/types/events\"\n)\n\n// Number of sent messages to cache in memory for handling retry receipts.\nconst recentMessagesSize = 256\n\ntype recentMessageKey struct {\n\tTo types.JID\n\tID types.MessageID\n}\n\ntype RecentMessage struct {\n\twa *waProto.Message\n\tfb *waMsgApplication.MessageApplication\n}\n\nfunc (rm RecentMessage) IsEmpty() bool {\n\treturn rm.wa == nil && rm.fb == nil\n}\n\nfunc (cli *Client) addRecentMessage(to types.JID, id types.MessageID, wa *waProto.Message, fb *waMsgApplication.MessageApplication) {\n\tcli.recentMessagesLock.Lock()\n\tkey := recentMessageKey{to, id}\n\tif cli.recentMessagesList[cli.recentMessagesPtr].ID != \"\" {\n\t\tdelete(cli.recentMessagesMap, cli.recentMessagesList[cli.recentMessagesPtr])\n\t}\n\tcli.recentMessagesMap[key] = RecentMessage{wa: wa, fb: fb}\n\tcli.recentMessagesList[cli.recentMessagesPtr] = key\n\tcli.recentMessagesPtr++\n\tif cli.recentMessagesPtr >= len(cli.recentMessagesList) {\n\t\tcli.recentMessagesPtr = 0\n\t}\n\tcli.recentMessagesLock.Unlock()\n}\n\nfunc (cli *Client) getRecentMessage(to types.JID, id types.MessageID) RecentMessage {\n\tcli.recentMessagesLock.RLock()\n\tmsg, _ := cli.recentMessagesMap[recentMessageKey{to, id}]\n\tcli.recentMessagesLock.RUnlock()\n\treturn msg\n}\n\nfunc (cli *Client) getMessageForRetry(receipt *events.Receipt, messageID types.MessageID) (RecentMessage, error) {\n\tmsg := cli.getRecentMessage(receipt.Chat, messageID)\n\tif msg.IsEmpty() {\n\t\twaMsg := cli.GetMessageForRetry(receipt.Sender, receipt.Chat, messageID)\n\t\tif waMsg == nil {\n\t\t\treturn RecentMessage{}, fmt.Errorf(\"couldn't find message %s\", messageID)\n\t\t} else {\n\t\t\tcli.Log.Debugf(\"Found message in GetMessageForRetry to accept retry receipt for %s/%s from %s\", receipt.Chat, messageID, receipt.Sender)\n\t\t}\n\t\tmsg = RecentMessage{wa: waMsg}\n\t} else {\n\t\tcli.Log.Debugf(\"Found message in local cache to accept retry receipt for %s/%s from %s\", receipt.Chat, messageID, receipt.Sender)\n\t}\n\treturn msg, nil\n}\n\nconst recreateSessionTimeout = 1 * time.Hour\n\nfunc (cli *Client) shouldRecreateSession(retryCount int, jid types.JID) (reason string, recreate bool) {\n\tcli.sessionRecreateHistoryLock.Lock()\n\tdefer cli.sessionRecreateHistoryLock.Unlock()\n\tif !cli.Store.ContainsSession(jid.SignalAddress()) {\n\t\tcli.sessionRecreateHistory[jid] = time.Now()\n\t\treturn \"we don't have a Signal session with them\", true\n\t} else if retryCount < 2 {\n\t\treturn \"\", false\n\t}\n\tprevTime, ok := cli.sessionRecreateHistory[jid]\n\tif !ok || prevTime.Add(recreateSessionTimeout).Before(time.Now()) {\n\t\tcli.sessionRecreateHistory[jid] = time.Now()\n\t\treturn \"retry count > 1 and over an hour since last recreation\", true\n\t}\n\treturn \"\", false\n}\n\ntype incomingRetryKey struct {\n\tjid       types.JID\n\tmessageID types.MessageID\n}\n\n// handleRetryReceipt handles an incoming retry receipt for an outgoing message.\nfunc (cli *Client) handleRetryReceipt(receipt *events.Receipt, node *waBinary.Node) error {\n\tretryChild, ok := node.GetOptionalChildByTag(\"retry\")\n\tif !ok {\n\t\treturn &ElementMissingError{Tag: \"retry\", In: \"retry receipt\"}\n\t}\n\tag := retryChild.AttrGetter()\n\tmessageID := ag.String(\"id\")\n\ttimestamp := ag.UnixTime(\"t\")\n\tretryCount := ag.Int(\"count\")\n\tif !ag.OK() {\n\t\treturn ag.Error()\n\t}\n\tmsg, err := cli.getMessageForRetry(receipt, messageID)\n\tif err != nil {\n\t\treturn err\n\t}\n\tvar fbConsumerMsg *waConsumerApplication.ConsumerApplication\n\tif msg.fb != nil {\n\t\tsubProto, ok := msg.fb.GetPayload().GetSubProtocol().GetSubProtocol().(*waMsgApplication.MessageApplication_SubProtocolPayload_ConsumerMessage)\n\t\tif ok {\n\t\t\tfbConsumerMsg, err = subProto.Decode()\n\t\t\tif err != nil {\n\t\t\t\treturn fmt.Errorf(\"failed to decode consumer message for retry: %w\", err)\n\t\t\t}\n\t\t}\n\t}\n\n\tretryKey := incomingRetryKey{receipt.Sender, messageID}\n\tcli.incomingRetryRequestCounterLock.Lock()\n\tcli.incomingRetryRequestCounter[retryKey]++\n\tinternalCounter := cli.incomingRetryRequestCounter[retryKey]\n\tcli.incomingRetryRequestCounterLock.Unlock()\n\tif internalCounter >= 10 {\n\t\tcli.Log.Warnf(\"Dropping retry request from %s for %s: internal retry counter is %d\", messageID, receipt.Sender, internalCounter)\n\t\treturn nil\n\t}\n\n\townID := cli.getOwnID()\n\tif ownID.IsEmpty() {\n\t\treturn ErrNotLoggedIn\n\t}\n\n\tvar fbSKDM *waMsgTransport.MessageTransport_Protocol_Ancillary_SenderKeyDistributionMessage\n\tvar fbDSM *waMsgTransport.MessageTransport_Protocol_Integral_DeviceSentMessage\n\tif receipt.IsGroup {\n\t\tbuilder := groups.NewGroupSessionBuilder(cli.Store, pbSerializer)\n\t\tsenderKeyName := protocol.NewSenderKeyName(receipt.Chat.String(), ownID.SignalAddress())\n\t\tsignalSKDMessage, err := builder.Create(senderKeyName)\n\t\tif err != nil {\n\t\t\tcli.Log.Warnf(\"Failed to create sender key distribution message to include in retry of %s in %s to %s: %v\", messageID, receipt.Chat, receipt.Sender, err)\n\t\t}\n\t\tif msg.wa != nil {\n\t\t\tmsg.wa.SenderKeyDistributionMessage = &waProto.SenderKeyDistributionMessage{\n\t\t\t\tGroupID:                             proto.String(receipt.Chat.String()),\n\t\t\t\tAxolotlSenderKeyDistributionMessage: signalSKDMessage.Serialize(),\n\t\t\t}\n\t\t} else {\n\t\t\tfbSKDM = &waMsgTransport.MessageTransport_Protocol_Ancillary_SenderKeyDistributionMessage{\n\t\t\t\tGroupID:                             proto.String(receipt.Chat.String()),\n\t\t\t\tAxolotlSenderKeyDistributionMessage: signalSKDMessage.Serialize(),\n\t\t\t}\n\t\t}\n\t} else if receipt.IsFromMe {\n\t\tif msg.wa != nil {\n\t\t\tmsg.wa = &waProto.Message{\n\t\t\t\tDeviceSentMessage: &waProto.DeviceSentMessage{\n\t\t\t\t\tDestinationJID: proto.String(receipt.Chat.String()),\n\t\t\t\t\tMessage:        msg.wa,\n\t\t\t\t},\n\t\t\t}\n\t\t} else {\n\t\t\tfbDSM = &waMsgTransport.MessageTransport_Protocol_Integral_DeviceSentMessage{\n\t\t\t\tDestinationJID: proto.String(receipt.Chat.String()),\n\t\t\t}\n\t\t}\n\t}\n\n\t// TODO pre-retry callback for fb\n\tif cli.PreRetryCallback != nil && !cli.PreRetryCallback(receipt, messageID, retryCount, msg.wa) {\n\t\tcli.Log.Debugf(\"Cancelled retry receipt in PreRetryCallback\")\n\t\treturn nil\n\t}\n\n\tvar plaintext, frankingTag []byte\n\tif msg.wa != nil {\n\t\tplaintext, err = proto.Marshal(msg.wa)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"failed to marshal message: %w\", err)\n\t\t}\n\t} else {\n\t\tplaintext, err = proto.Marshal(msg.fb)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"failed to marshal consumer message: %w\", err)\n\t\t}\n\t\tfrankingHash := hmac.New(sha256.New, msg.fb.GetMetadata().GetFrankingKey())\n\t\tfrankingHash.Write(plaintext)\n\t\tfrankingTag = frankingHash.Sum(nil)\n\t}\n\t_, hasKeys := node.GetOptionalChildByTag(\"keys\")\n\tvar bundle *prekey.Bundle\n\tif hasKeys {\n\t\tbundle, err = nodeToPreKeyBundle(uint32(receipt.Sender.Device), *node)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"failed to read prekey bundle in retry receipt: %w\", err)\n\t\t}\n\t} else if reason, recreate := cli.shouldRecreateSession(retryCount, receipt.Sender); recreate {\n\t\tcli.Log.Debugf(\"Fetching prekeys for %s for handling retry receipt with no prekey bundle because %s\", receipt.Sender, reason)\n\t\tvar keys map[types.JID]preKeyResp\n\t\tkeys, err = cli.fetchPreKeys(context.TODO(), []types.JID{receipt.Sender})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tbundle, err = keys[receipt.Sender].bundle, keys[receipt.Sender].err\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"failed to fetch prekeys: %w\", err)\n\t\t} else if bundle == nil {\n\t\t\treturn fmt.Errorf(\"didn't get prekey bundle for %s (response size: %d)\", receipt.Sender, len(keys))\n\t\t}\n\t}\n\tencAttrs := waBinary.Attrs{}\n\tvar msgAttrs messageAttrs\n\tif msg.wa != nil {\n\t\tmsgAttrs.MediaType = getMediaTypeFromMessage(msg.wa)\n\t\tmsgAttrs.Type = getTypeFromMessage(msg.wa)\n\t} else if fbConsumerMsg != nil {\n\t\tmsgAttrs = getAttrsFromFBMessage(fbConsumerMsg)\n\t} else {\n\t\tmsgAttrs.Type = \"text\"\n\t}\n\tif msgAttrs.MediaType != \"\" {\n\t\tencAttrs[\"mediatype\"] = msgAttrs.MediaType\n\t}\n\tvar encrypted *waBinary.Node\n\tvar includeDeviceIdentity bool\n\tif msg.wa != nil {\n\t\tencrypted, includeDeviceIdentity, err = cli.encryptMessageForDevice(plaintext, receipt.Sender, bundle, encAttrs)\n\t} else {\n\t\tencrypted, err = cli.encryptMessageForDeviceV3(&waMsgTransport.MessageTransport_Payload{\n\t\t\tApplicationPayload: &waCommon.SubProtocol{\n\t\t\t\tPayload: plaintext,\n\t\t\t\tVersion: proto.Int32(FBMessageApplicationVersion),\n\t\t\t},\n\t\t\tFutureProof: waCommon.FutureProofBehavior_PLACEHOLDER.Enum(),\n\t\t}, fbSKDM, fbDSM, receipt.Sender, bundle, encAttrs)\n\t}\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to encrypt message for retry: %w\", err)\n\t}\n\tencrypted.Attrs[\"count\"] = retryCount\n\n\tattrs := waBinary.Attrs{\n\t\t\"to\":   node.Attrs[\"from\"],\n\t\t\"type\": msgAttrs.Type,\n\t\t\"id\":   messageID,\n\t\t\"t\":    timestamp.Unix(),\n\t}\n\tif !receipt.IsGroup {\n\t\tattrs[\"device_fanout\"] = false\n\t}\n\tif participant, ok := node.Attrs[\"participant\"]; ok {\n\t\tattrs[\"participant\"] = participant\n\t}\n\tif recipient, ok := node.Attrs[\"recipient\"]; ok {\n\t\tattrs[\"recipient\"] = recipient\n\t}\n\tif edit, ok := node.Attrs[\"edit\"]; ok {\n\t\tattrs[\"edit\"] = edit\n\t}\n\tvar content []waBinary.Node\n\tif msg.wa != nil {\n\t\tcontent = cli.getMessageContent(*encrypted, msg.wa, attrs, includeDeviceIdentity, nil)\n\t} else {\n\t\tcontent = []waBinary.Node{\n\t\t\t*encrypted,\n\t\t\t{Tag: \"franking\", Content: []waBinary.Node{{Tag: \"franking_tag\", Content: frankingTag}}},\n\t\t}\n\t}\n\terr = cli.sendNode(waBinary.Node{\n\t\tTag:     \"message\",\n\t\tAttrs:   attrs,\n\t\tContent: content,\n\t})\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to send retry message: %w\", err)\n\t}\n\tcli.Log.Debugf(\"Sent retry #%d for %s/%s to %s\", retryCount, receipt.Chat, messageID, receipt.Sender)\n\treturn nil\n}\n\nfunc (cli *Client) cancelDelayedRequestFromPhone(msgID types.MessageID) {\n\tif !cli.AutomaticMessageRerequestFromPhone || cli.MessengerConfig != nil {\n\t\treturn\n\t}\n\tcli.pendingPhoneRerequestsLock.RLock()\n\tcancelPendingRequest, ok := cli.pendingPhoneRerequests[msgID]\n\tif ok {\n\t\tcancelPendingRequest()\n\t}\n\tcli.pendingPhoneRerequestsLock.RUnlock()\n}\n\n// RequestFromPhoneDelay specifies how long to wait for the sender to resend the message before requesting from your phone.\n// This is only used if Client.AutomaticMessageRerequestFromPhone is true.\nvar RequestFromPhoneDelay = 5 * time.Second\n\nfunc (cli *Client) delayedRequestMessageFromPhone(info *types.MessageInfo) {\n\tif !cli.AutomaticMessageRerequestFromPhone || cli.MessengerConfig != nil {\n\t\treturn\n\t}\n\tcli.pendingPhoneRerequestsLock.Lock()\n\t_, alreadyRequesting := cli.pendingPhoneRerequests[info.ID]\n\tif alreadyRequesting {\n\t\tcli.pendingPhoneRerequestsLock.Unlock()\n\t\treturn\n\t}\n\tctx, cancel := context.WithCancel(context.Background())\n\tdefer cancel()\n\tcli.pendingPhoneRerequests[info.ID] = cancel\n\tcli.pendingPhoneRerequestsLock.Unlock()\n\n\tdefer func() {\n\t\tcli.pendingPhoneRerequestsLock.Lock()\n\t\tdelete(cli.pendingPhoneRerequests, info.ID)\n\t\tcli.pendingPhoneRerequestsLock.Unlock()\n\t}()\n\tselect {\n\tcase <-time.After(RequestFromPhoneDelay):\n\tcase <-ctx.Done():\n\t\tcli.Log.Debugf(\"Cancelled delayed request for message %s from phone\", info.ID)\n\t\treturn\n\t}\n\t_, err := cli.SendMessage(\n\t\tctx,\n\t\tcli.getOwnID().ToNonAD(),\n\t\tcli.BuildUnavailableMessageRequest(info.Chat, info.Sender, info.ID),\n\t\tSendRequestExtra{Peer: true},\n\t)\n\tif err != nil {\n\t\tcli.Log.Warnf(\"Failed to send request for unavailable message %s to phone: %v\", info.ID, err)\n\t} else {\n\t\tcli.Log.Debugf(\"Requested message %s from phone\", info.ID)\n\t}\n}\n\n// sendRetryReceipt sends a retry receipt for an incoming message.\nfunc (cli *Client) sendRetryReceipt(node *waBinary.Node, info *types.MessageInfo, forceIncludeIdentity bool) {\n\tid, _ := node.Attrs[\"id\"].(string)\n\tchildren := node.GetChildren()\n\tvar retryCountInMsg int\n\tif len(children) == 1 && children[0].Tag == \"enc\" {\n\t\tretryCountInMsg = children[0].AttrGetter().OptionalInt(\"count\")\n\t}\n\n\tcli.messageRetriesLock.Lock()\n\tcli.messageRetries[id]++\n\tretryCount := cli.messageRetries[id]\n\t// In case the message is a retry response, and we restarted in between, find the count from the message\n\tif retryCount == 1 && retryCountInMsg > 0 {\n\t\tretryCount = retryCountInMsg + 1\n\t\tcli.messageRetries[id] = retryCount\n\t}\n\tcli.messageRetriesLock.Unlock()\n\tif retryCount >= 5 {\n\t\tcli.Log.Warnf(\"Not sending any more retry receipts for %s\", id)\n\t\treturn\n\t}\n\tif retryCount == 1 {\n\t\tgo cli.delayedRequestMessageFromPhone(info)\n\t}\n\n\tvar registrationIDBytes [4]byte\n\tbinary.BigEndian.PutUint32(registrationIDBytes[:], cli.Store.RegistrationID)\n\tattrs := waBinary.Attrs{\n\t\t\"id\":   id,\n\t\t\"type\": \"retry\",\n\t\t\"to\":   node.Attrs[\"from\"],\n\t}\n\tif recipient, ok := node.Attrs[\"recipient\"]; ok {\n\t\tattrs[\"recipient\"] = recipient\n\t}\n\tif participant, ok := node.Attrs[\"participant\"]; ok {\n\t\tattrs[\"participant\"] = participant\n\t}\n\tpayload := waBinary.Node{\n\t\tTag:   \"receipt\",\n\t\tAttrs: attrs,\n\t\tContent: []waBinary.Node{\n\t\t\t{Tag: \"retry\", Attrs: waBinary.Attrs{\n\t\t\t\t\"count\": retryCount,\n\t\t\t\t\"id\":    id,\n\t\t\t\t\"t\":     node.Attrs[\"t\"],\n\t\t\t\t\"v\":     1,\n\t\t\t}},\n\t\t\t{Tag: \"registration\", Content: registrationIDBytes[:]},\n\t\t},\n\t}\n\tif retryCount > 1 || forceIncludeIdentity {\n\t\tif key, err := cli.Store.PreKeys.GenOnePreKey(); err != nil {\n\t\t\tcli.Log.Errorf(\"Failed to get prekey for retry receipt: %v\", err)\n\t\t} else if deviceIdentity, err := proto.Marshal(cli.Store.Account); err != nil {\n\t\t\tcli.Log.Errorf(\"Failed to marshal account info: %v\", err)\n\t\t\treturn\n\t\t} else {\n\t\t\tpayload.Content = append(payload.GetChildren(), waBinary.Node{\n\t\t\t\tTag: \"keys\",\n\t\t\t\tContent: []waBinary.Node{\n\t\t\t\t\t{Tag: \"type\", Content: []byte{ecc.DjbType}},\n\t\t\t\t\t{Tag: \"identity\", Content: cli.Store.IdentityKey.Pub[:]},\n\t\t\t\t\tpreKeyToNode(key),\n\t\t\t\t\tpreKeyToNode(cli.Store.SignedPreKey),\n\t\t\t\t\t{Tag: \"device-identity\", Content: deviceIdentity},\n\t\t\t\t},\n\t\t\t})\n\t\t}\n\t}\n\terr := cli.sendNode(payload)\n\tif err != nil {\n\t\tcli.Log.Errorf(\"Failed to send retry receipt for %s: %v\", id, err)\n\t}\n}\n"
        },
        {
          "name": "send.go",
          "type": "blob",
          "size": 38.65625,
          "content": "// Copyright (c) 2022 Tulir Asokan\n//\n// This Source Code Form is subject to the terms of the Mozilla Public\n// License, v. 2.0. If a copy of the MPL was not distributed with this\n// file, You can obtain one at http://mozilla.org/MPL/2.0/.\n\npackage whatsmeow\n\nimport (\n\t\"context\"\n\t\"crypto/sha256\"\n\t\"encoding/base64\"\n\t\"encoding/binary\"\n\t\"encoding/hex\"\n\t\"errors\"\n\t\"fmt\"\n\t\"sort\"\n\t\"strconv\"\n\t\"strings\"\n\t\"time\"\n\n\t\"github.com/rs/zerolog\"\n\t\"go.mau.fi/libsignal/groups\"\n\t\"go.mau.fi/libsignal/keys/prekey\"\n\t\"go.mau.fi/libsignal/protocol\"\n\t\"go.mau.fi/libsignal/session\"\n\t\"go.mau.fi/libsignal/signalerror\"\n\t\"go.mau.fi/util/random\"\n\t\"google.golang.org/protobuf/proto\"\n\n\twaBinary \"go.mau.fi/whatsmeow/binary\"\n\twaProto \"go.mau.fi/whatsmeow/binary/proto\"\n\t\"go.mau.fi/whatsmeow/proto/waE2E\"\n\t\"go.mau.fi/whatsmeow/types\"\n\t\"go.mau.fi/whatsmeow/types/events\"\n)\n\n// GenerateMessageID generates a random string that can be used as a message ID on WhatsApp.\n//\n//\tmsgID := cli.GenerateMessageID()\n//\tcli.SendMessage(context.Background(), targetJID, &waProto.Message{...}, whatsmeow.SendRequestExtra{ID: msgID})\nfunc (cli *Client) GenerateMessageID() types.MessageID {\n\tif cli != nil && cli.MessengerConfig != nil {\n\t\treturn types.MessageID(strconv.FormatInt(GenerateFacebookMessageID(), 10))\n\t}\n\tdata := make([]byte, 8, 8+20+16)\n\tbinary.BigEndian.PutUint64(data, uint64(time.Now().Unix()))\n\townID := cli.getOwnID()\n\tif !ownID.IsEmpty() {\n\t\tdata = append(data, []byte(ownID.User)...)\n\t\tdata = append(data, []byte(\"@c.us\")...)\n\t}\n\tdata = append(data, random.Bytes(16)...)\n\thash := sha256.Sum256(data)\n\treturn \"3EB0\" + strings.ToUpper(hex.EncodeToString(hash[:9]))\n}\n\nfunc GenerateFacebookMessageID() int64 {\n\tconst randomMask = (1 << 22) - 1\n\treturn (time.Now().UnixMilli() << 22) | (int64(binary.BigEndian.Uint32(random.Bytes(4))) & randomMask)\n}\n\n// GenerateMessageID generates a random string that can be used as a message ID on WhatsApp.\n//\n//\tmsgID := whatsmeow.GenerateMessageID()\n//\tcli.SendMessage(context.Background(), targetJID, &waProto.Message{...}, whatsmeow.SendRequestExtra{ID: msgID})\n//\n// Deprecated: WhatsApp web has switched to using a hash of the current timestamp, user id and random bytes. Use Client.GenerateMessageID instead.\nfunc GenerateMessageID() types.MessageID {\n\treturn \"3EB0\" + strings.ToUpper(hex.EncodeToString(random.Bytes(8)))\n}\n\ntype MessageDebugTimings struct {\n\tQueue time.Duration\n\n\tMarshal         time.Duration\n\tGetParticipants time.Duration\n\tGetDevices      time.Duration\n\tGroupEncrypt    time.Duration\n\tPeerEncrypt     time.Duration\n\n\tSend  time.Duration\n\tResp  time.Duration\n\tRetry time.Duration\n}\n\nfunc (mdt MessageDebugTimings) MarshalZerologObject(evt *zerolog.Event) {\n\tevt.Dur(\"queue\", mdt.Queue)\n\tevt.Dur(\"marshal\", mdt.Marshal)\n\tif mdt.GetParticipants != 0 {\n\t\tevt.Dur(\"get_participants\", mdt.GetParticipants)\n\t}\n\tevt.Dur(\"get_devices\", mdt.GetDevices)\n\tif mdt.GroupEncrypt != 0 {\n\t\tevt.Dur(\"group_encrypt\", mdt.GroupEncrypt)\n\t}\n\tevt.Dur(\"peer_encrypt\", mdt.PeerEncrypt)\n\tevt.Dur(\"send\", mdt.Send)\n\tevt.Dur(\"resp\", mdt.Resp)\n\tif mdt.Retry != 0 {\n\t\tevt.Dur(\"retry\", mdt.Retry)\n\t}\n}\n\ntype SendResponse struct {\n\t// The message timestamp returned by the server\n\tTimestamp time.Time\n\n\t// The ID of the sent message\n\tID types.MessageID\n\n\t// The server-specified ID of the sent message. Only present for newsletter messages.\n\tServerID types.MessageServerID\n\n\t// Message handling duration, used for debugging\n\tDebugTimings MessageDebugTimings\n}\n\n// SendRequestExtra contains the optional parameters for SendMessage.\n//\n// By default, optional parameters don't have to be provided at all, e.g.\n//\n//\tcli.SendMessage(ctx, to, message)\n//\n// When providing optional parameters, add a single instance of this struct as the last parameter:\n//\n//\tcli.SendMessage(ctx, to, message, whatsmeow.SendRequestExtra{...})\n//\n// Trying to add multiple extra parameters will return an error.\ntype SendRequestExtra struct {\n\t// The message ID to use when sending. If this is not provided, a random message ID will be generated\n\tID types.MessageID\n\t// JID of the bot to be invoked (optional)\n\tInlineBotJID types.JID\n\t// Should the message be sent as a peer message (protocol messages to your own devices, e.g. app state key requests)\n\tPeer bool\n\t// A timeout for the send request. Unlike timeouts using the context parameter, this only applies\n\t// to the actual response waiting and not preparing/encrypting the message.\n\t// Defaults to 75 seconds. The timeout can be disabled by using a negative value.\n\tTimeout time.Duration\n\t// When sending media to newsletters, the Handle field returned by the file upload.\n\tMediaHandle string\n}\n\n// SendMessage sends the given message.\n//\n// This method will wait for the server to acknowledge the message before returning.\n// The return value is the timestamp of the message from the server.\n//\n// Optional parameters like the message ID can be specified with the SendRequestExtra struct.\n// Only one extra parameter is allowed, put all necessary parameters in the same struct.\n//\n// The message itself can contain anything you want (within the protobuf schema).\n// e.g. for a simple text message, use the Conversation field:\n//\n//\tcli.SendMessage(context.Background(), targetJID, &waProto.Message{\n//\t\tConversation: proto.String(\"Hello, World!\"),\n//\t})\n//\n// Things like replies, mentioning users and the \"forwarded\" flag are stored in ContextInfo,\n// which can be put in ExtendedTextMessage and any of the media message types.\n//\n// For uploading and sending media/attachments, see the Upload method.\n//\n// For other message types, you'll have to figure it out yourself. Looking at the protobuf schema\n// in binary/proto/def.proto may be useful to find out all the allowed fields. Printing the RawMessage\n// field in incoming message events to figure out what it contains is also a good way to learn how to\n// send the same kind of message.\nfunc (cli *Client) SendMessage(ctx context.Context, to types.JID, message *waE2E.Message, extra ...SendRequestExtra) (resp SendResponse, err error) {\n\tif cli == nil {\n\t\terr = ErrClientIsNil\n\t\treturn\n\t}\n\tvar req SendRequestExtra\n\tif len(extra) > 1 {\n\t\terr = errors.New(\"only one extra parameter may be provided to SendMessage\")\n\t\treturn\n\t} else if len(extra) == 1 {\n\t\treq = extra[0]\n\t}\n\tif to.Device > 0 && !req.Peer {\n\t\terr = ErrRecipientADJID\n\t\treturn\n\t}\n\townID := cli.getOwnID()\n\tif ownID.IsEmpty() {\n\t\terr = ErrNotLoggedIn\n\t\treturn\n\t}\n\n\tif req.Timeout == 0 {\n\t\treq.Timeout = defaultRequestTimeout\n\t}\n\tif len(req.ID) == 0 {\n\t\treq.ID = cli.GenerateMessageID()\n\t}\n\tif to.Server == types.NewsletterServer {\n\t\t// TODO somehow deduplicate this with the code in sendNewsletter?\n\t\tif message.EditedMessage != nil {\n\t\t\treq.ID = types.MessageID(message.GetEditedMessage().GetMessage().GetProtocolMessage().GetKey().GetId())\n\t\t} else if message.ProtocolMessage != nil && message.ProtocolMessage.GetType() == waProto.ProtocolMessage_REVOKE {\n\t\t\treq.ID = types.MessageID(message.GetProtocolMessage().GetKey().GetId())\n\t\t}\n\t}\n\tresp.ID = req.ID\n\n\tisInlineBotMode := false\n\n\tif !req.InlineBotJID.IsEmpty() {\n\t\tif !req.InlineBotJID.IsBot() {\n\t\t\terr = ErrInvalidInlineBotID\n\t\t\treturn\n\t\t}\n\t\tisInlineBotMode = true\n\t}\n\n\tisBotMode := isInlineBotMode || to.IsBot()\n\tvar botNode *waBinary.Node\n\n\tif isBotMode {\n\t\tif message.MessageContextInfo == nil {\n\t\t\tmessage.MessageContextInfo = &waE2E.MessageContextInfo{}\n\t\t}\n\n\t\tif message.MessageContextInfo.MessageSecret == nil {\n\t\t\tmessage.MessageContextInfo.MessageSecret = random.Bytes(32)\n\t\t}\n\n\t\tif message.MessageContextInfo.BotMetadata == nil {\n\t\t\tmessage.MessageContextInfo.BotMetadata = &waE2E.BotMetadata{\n\t\t\t\tPersonaID: proto.String(\"867051314767696$760019659443059\"),\n\t\t\t}\n\t\t}\n\n\t\tif isInlineBotMode {\n\t\t\t// inline mode specific code\n\t\t\tmessageSecret := message.GetMessageContextInfo().GetMessageSecret()\n\t\t\tmessage = &waE2E.Message{\n\t\t\t\tBotInvokeMessage: &waE2E.FutureProofMessage{\n\t\t\t\t\tMessage: &waE2E.Message{\n\t\t\t\t\t\tExtendedTextMessage: message.ExtendedTextMessage,\n\t\t\t\t\t\tMessageContextInfo: &waE2E.MessageContextInfo{\n\t\t\t\t\t\t\tBotMetadata: message.MessageContextInfo.BotMetadata,\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tMessageContextInfo: message.MessageContextInfo,\n\t\t\t}\n\n\t\t\tbotMessage := &waE2E.Message{\n\t\t\t\tBotInvokeMessage: message.BotInvokeMessage,\n\t\t\t\tMessageContextInfo: &waE2E.MessageContextInfo{\n\t\t\t\t\tBotMetadata:      message.MessageContextInfo.BotMetadata,\n\t\t\t\t\tBotMessageSecret: applyBotMessageHKDF(messageSecret),\n\t\t\t\t},\n\t\t\t}\n\n\t\t\tmessagePlaintext, _, marshalErr := marshalMessage(req.InlineBotJID, botMessage)\n\t\t\tif marshalErr != nil {\n\t\t\t\terr = marshalErr\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tparticipantNodes, _ := cli.encryptMessageForDevices(ctx, []types.JID{req.InlineBotJID}, ownID, resp.ID, messagePlaintext, nil, waBinary.Attrs{})\n\t\t\tbotNode = &waBinary.Node{\n\t\t\t\tTag:     \"bot\",\n\t\t\t\tAttrs:   nil,\n\t\t\t\tContent: participantNodes,\n\t\t\t}\n\t\t}\n\t}\n\n\tstart := time.Now()\n\t// Sending multiple messages at a time can cause weird issues and makes it harder to retry safely\n\tcli.messageSendLock.Lock()\n\tresp.DebugTimings.Queue = time.Since(start)\n\tdefer cli.messageSendLock.Unlock()\n\n\trespChan := cli.waitResponse(req.ID)\n\t// Peer message retries aren't implemented yet\n\tif !req.Peer {\n\t\tcli.addRecentMessage(to, req.ID, message, nil)\n\t}\n\n\tif message.GetMessageContextInfo().GetMessageSecret() != nil {\n\t\terr = cli.Store.MsgSecrets.PutMessageSecret(to, ownID, req.ID, message.GetMessageContextInfo().GetMessageSecret())\n\t\tif err != nil {\n\t\t\tcli.Log.Warnf(\"Failed to store message secret key for outgoing message %s: %v\", req.ID, err)\n\t\t} else {\n\t\t\tcli.Log.Debugf(\"Stored message secret key for outgoing message %s\", req.ID)\n\t\t}\n\t}\n\tvar phash string\n\tvar data []byte\n\tswitch to.Server {\n\tcase types.GroupServer, types.BroadcastServer:\n\t\tphash, data, err = cli.sendGroup(ctx, to, ownID, req.ID, message, &resp.DebugTimings, botNode)\n\tcase types.DefaultUserServer:\n\t\tif req.Peer {\n\t\t\tdata, err = cli.sendPeerMessage(to, req.ID, message, &resp.DebugTimings)\n\t\t} else {\n\t\t\tdata, err = cli.sendDM(ctx, to, ownID, req.ID, message, &resp.DebugTimings, botNode)\n\t\t}\n\tcase types.NewsletterServer:\n\t\tdata, err = cli.sendNewsletter(to, req.ID, message, req.MediaHandle, &resp.DebugTimings)\n\tdefault:\n\t\terr = fmt.Errorf(\"%w %s\", ErrUnknownServer, to.Server)\n\t}\n\tstart = time.Now()\n\tif err != nil {\n\t\tcli.cancelResponse(req.ID, respChan)\n\t\treturn\n\t}\n\tvar respNode *waBinary.Node\n\tvar timeoutChan <-chan time.Time\n\tif req.Timeout > 0 {\n\t\ttimeoutChan = time.After(req.Timeout)\n\t} else {\n\t\ttimeoutChan = make(<-chan time.Time)\n\t}\n\tselect {\n\tcase respNode = <-respChan:\n\tcase <-timeoutChan:\n\t\tcli.cancelResponse(req.ID, respChan)\n\t\terr = ErrMessageTimedOut\n\t\treturn\n\tcase <-ctx.Done():\n\t\tcli.cancelResponse(req.ID, respChan)\n\t\terr = ctx.Err()\n\t\treturn\n\t}\n\tresp.DebugTimings.Resp = time.Since(start)\n\tif isDisconnectNode(respNode) {\n\t\tstart = time.Now()\n\t\trespNode, err = cli.retryFrame(\"message send\", req.ID, data, respNode, ctx, 0)\n\t\tresp.DebugTimings.Retry = time.Since(start)\n\t\tif err != nil {\n\t\t\treturn\n\t\t}\n\t}\n\tag := respNode.AttrGetter()\n\tresp.ServerID = types.MessageServerID(ag.OptionalInt(\"server_id\"))\n\tresp.Timestamp = ag.UnixTime(\"t\")\n\tif errorCode := ag.Int(\"error\"); errorCode != 0 {\n\t\terr = fmt.Errorf(\"%w %d\", ErrServerReturnedError, errorCode)\n\t}\n\texpectedPHash := ag.OptionalString(\"phash\")\n\tif len(expectedPHash) > 0 && phash != expectedPHash {\n\t\tcli.Log.Warnf(\"Server returned different participant list hash when sending to %s. Some devices may not have received the message.\", to)\n\t\t// TODO also invalidate device list caches\n\t\tcli.groupParticipantsCacheLock.Lock()\n\t\tdelete(cli.groupParticipantsCache, to)\n\t\tcli.groupParticipantsCacheLock.Unlock()\n\t}\n\treturn\n}\n\n// RevokeMessage deletes the given message from everyone in the chat.\n//\n// This method will wait for the server to acknowledge the revocation message before returning.\n// The return value is the timestamp of the message from the server.\n//\n// Deprecated: This method is deprecated in favor of BuildRevoke\nfunc (cli *Client) RevokeMessage(chat types.JID, id types.MessageID) (SendResponse, error) {\n\treturn cli.SendMessage(context.TODO(), chat, cli.BuildRevoke(chat, types.EmptyJID, id))\n}\n\n// BuildMessageKey builds a MessageKey object, which is used to refer to previous messages\n// for things such as replies, revocations and reactions.\nfunc (cli *Client) BuildMessageKey(chat, sender types.JID, id types.MessageID) *waProto.MessageKey {\n\tkey := &waProto.MessageKey{\n\t\tFromMe:    proto.Bool(true),\n\t\tID:        proto.String(id),\n\t\tRemoteJID: proto.String(chat.String()),\n\t}\n\tif !sender.IsEmpty() && sender.User != cli.getOwnID().User {\n\t\tkey.FromMe = proto.Bool(false)\n\t\tif chat.Server != types.DefaultUserServer && chat.Server != types.MessengerServer {\n\t\t\tkey.Participant = proto.String(sender.ToNonAD().String())\n\t\t}\n\t}\n\treturn key\n}\n\n// BuildRevoke builds a message revocation message using the given variables.\n// The built message can be sent normally using Client.SendMessage.\n//\n// To revoke your own messages, pass your JID or an empty JID as the second parameter (sender).\n//\n//\tresp, err := cli.SendMessage(context.Background(), chat, cli.BuildRevoke(chat, types.EmptyJID, originalMessageID)\n//\n// To revoke someone else's messages when you are group admin, pass the message sender's JID as the second parameter.\n//\n//\tresp, err := cli.SendMessage(context.Background(), chat, cli.BuildRevoke(chat, senderJID, originalMessageID)\nfunc (cli *Client) BuildRevoke(chat, sender types.JID, id types.MessageID) *waProto.Message {\n\treturn &waProto.Message{\n\t\tProtocolMessage: &waProto.ProtocolMessage{\n\t\t\tType: waProto.ProtocolMessage_REVOKE.Enum(),\n\t\t\tKey:  cli.BuildMessageKey(chat, sender, id),\n\t\t},\n\t}\n}\n\n// BuildReaction builds a message reaction message using the given variables.\n// The built message can be sent normally using Client.SendMessage.\n//\n//\tresp, err := cli.SendMessage(context.Background(), chat, cli.BuildReaction(chat, senderJID, targetMessageID, \"🐈️\")\n//\n// Note that for newsletter messages, you need to use NewsletterSendReaction instead of BuildReaction + SendMessage.\nfunc (cli *Client) BuildReaction(chat, sender types.JID, id types.MessageID, reaction string) *waProto.Message {\n\treturn &waProto.Message{\n\t\tReactionMessage: &waProto.ReactionMessage{\n\t\t\tKey:               cli.BuildMessageKey(chat, sender, id),\n\t\t\tText:              proto.String(reaction),\n\t\t\tSenderTimestampMS: proto.Int64(time.Now().UnixMilli()),\n\t\t},\n\t}\n}\n\n// BuildUnavailableMessageRequest builds a message to request the user's primary device to send\n// the copy of a message that this client was unable to decrypt.\n//\n// The built message can be sent using Client.SendMessage, but you must pass whatsmeow.SendRequestExtra{Peer: true} as the last parameter.\n// The full response will come as a ProtocolMessage with type `PEER_DATA_OPERATION_REQUEST_RESPONSE_MESSAGE`.\n// The response events will also be dispatched as normal *events.Message's with UnavailableRequestID set to the request message ID.\nfunc (cli *Client) BuildUnavailableMessageRequest(chat, sender types.JID, id string) *waProto.Message {\n\treturn &waProto.Message{\n\t\tProtocolMessage: &waProto.ProtocolMessage{\n\t\t\tType: waProto.ProtocolMessage_PEER_DATA_OPERATION_REQUEST_MESSAGE.Enum(),\n\t\t\tPeerDataOperationRequestMessage: &waProto.PeerDataOperationRequestMessage{\n\t\t\t\tPeerDataOperationRequestType: waProto.PeerDataOperationRequestType_PLACEHOLDER_MESSAGE_RESEND.Enum(),\n\t\t\t\tPlaceholderMessageResendRequest: []*waProto.PeerDataOperationRequestMessage_PlaceholderMessageResendRequest{{\n\t\t\t\t\tMessageKey: cli.BuildMessageKey(chat, sender, id),\n\t\t\t\t}},\n\t\t\t},\n\t\t},\n\t}\n}\n\n// BuildHistorySyncRequest builds a message to request additional history from the user's primary device.\n//\n// The built message can be sent using Client.SendMessage, but you must pass whatsmeow.SendRequestExtra{Peer: true} as the last parameter.\n// The response will come as an *events.HistorySync with type `ON_DEMAND`.\n//\n// The response will contain to `count` messages immediately before the given message.\n// The recommended number of messages to request at a time is 50.\nfunc (cli *Client) BuildHistorySyncRequest(lastKnownMessageInfo *types.MessageInfo, count int) *waProto.Message {\n\treturn &waProto.Message{\n\t\tProtocolMessage: &waProto.ProtocolMessage{\n\t\t\tType: waProto.ProtocolMessage_PEER_DATA_OPERATION_REQUEST_MESSAGE.Enum(),\n\t\t\tPeerDataOperationRequestMessage: &waProto.PeerDataOperationRequestMessage{\n\t\t\t\tPeerDataOperationRequestType: waProto.PeerDataOperationRequestType_HISTORY_SYNC_ON_DEMAND.Enum(),\n\t\t\t\tHistorySyncOnDemandRequest: &waProto.PeerDataOperationRequestMessage_HistorySyncOnDemandRequest{\n\t\t\t\t\tChatJID:              proto.String(lastKnownMessageInfo.Chat.String()),\n\t\t\t\t\tOldestMsgID:          proto.String(lastKnownMessageInfo.ID),\n\t\t\t\t\tOldestMsgFromMe:      proto.Bool(lastKnownMessageInfo.IsFromMe),\n\t\t\t\t\tOnDemandMsgCount:     proto.Int32(int32(count)),\n\t\t\t\t\tOldestMsgTimestampMS: proto.Int64(lastKnownMessageInfo.Timestamp.UnixMilli()),\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}\n}\n\n// EditWindow specifies how long a message can be edited for after it was sent.\nconst EditWindow = 20 * time.Minute\n\n// BuildEdit builds a message edit message using the given variables.\n// The built message can be sent normally using Client.SendMessage.\n//\n//\tresp, err := cli.SendMessage(context.Background(), chat, cli.BuildEdit(chat, originalMessageID, &waProto.Message{\n//\t\tConversation: proto.String(\"edited message\"),\n//\t})\nfunc (cli *Client) BuildEdit(chat types.JID, id types.MessageID, newContent *waProto.Message) *waProto.Message {\n\treturn &waProto.Message{\n\t\tEditedMessage: &waProto.FutureProofMessage{\n\t\t\tMessage: &waProto.Message{\n\t\t\t\tProtocolMessage: &waProto.ProtocolMessage{\n\t\t\t\t\tKey: &waProto.MessageKey{\n\t\t\t\t\t\tFromMe:    proto.Bool(true),\n\t\t\t\t\t\tID:        proto.String(id),\n\t\t\t\t\t\tRemoteJID: proto.String(chat.String()),\n\t\t\t\t\t},\n\t\t\t\t\tType:          waProto.ProtocolMessage_MESSAGE_EDIT.Enum(),\n\t\t\t\t\tEditedMessage: newContent,\n\t\t\t\t\tTimestampMS:   proto.Int64(time.Now().UnixMilli()),\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}\n}\n\nconst (\n\tDisappearingTimerOff     = time.Duration(0)\n\tDisappearingTimer24Hours = 24 * time.Hour\n\tDisappearingTimer7Days   = 7 * 24 * time.Hour\n\tDisappearingTimer90Days  = 90 * 24 * time.Hour\n)\n\n// ParseDisappearingTimerString parses common human-readable disappearing message timer strings into Duration values.\n// If the string doesn't look like one of the allowed values (0, 24h, 7d, 90d), the second return value is false.\nfunc ParseDisappearingTimerString(val string) (time.Duration, bool) {\n\tswitch strings.ReplaceAll(strings.ToLower(val), \" \", \"\") {\n\tcase \"0d\", \"0h\", \"0s\", \"0\", \"off\":\n\t\treturn DisappearingTimerOff, true\n\tcase \"1day\", \"day\", \"1d\", \"1\", \"24h\", \"24\", \"86400s\", \"86400\":\n\t\treturn DisappearingTimer24Hours, true\n\tcase \"1week\", \"week\", \"7d\", \"7\", \"168h\", \"168\", \"604800s\", \"604800\":\n\t\treturn DisappearingTimer7Days, true\n\tcase \"3months\", \"3m\", \"3mo\", \"90d\", \"90\", \"2160h\", \"2160\", \"7776000s\", \"7776000\":\n\t\treturn DisappearingTimer90Days, true\n\tdefault:\n\t\treturn 0, false\n\t}\n}\n\n// SetDisappearingTimer sets the disappearing timer in a chat. Both private chats and groups are supported, but they're\n// set with different methods.\n//\n// Note that while this function allows passing non-standard durations, official WhatsApp apps will ignore those,\n// and in groups the server will just reject the change. You can use the DisappearingTimer<Duration> constants for convenience.\n//\n// In groups, the server will echo the change as a notification, so it'll show up as a *events.GroupInfo update.\nfunc (cli *Client) SetDisappearingTimer(chat types.JID, timer time.Duration) (err error) {\n\tswitch chat.Server {\n\tcase types.DefaultUserServer:\n\t\t_, err = cli.SendMessage(context.TODO(), chat, &waProto.Message{\n\t\t\tProtocolMessage: &waProto.ProtocolMessage{\n\t\t\t\tType:                waProto.ProtocolMessage_EPHEMERAL_SETTING.Enum(),\n\t\t\t\tEphemeralExpiration: proto.Uint32(uint32(timer.Seconds())),\n\t\t\t},\n\t\t})\n\tcase types.GroupServer:\n\t\tif timer == 0 {\n\t\t\t_, err = cli.sendGroupIQ(context.TODO(), iqSet, chat, waBinary.Node{Tag: \"not_ephemeral\"})\n\t\t} else {\n\t\t\t_, err = cli.sendGroupIQ(context.TODO(), iqSet, chat, waBinary.Node{\n\t\t\t\tTag: \"ephemeral\",\n\t\t\t\tAttrs: waBinary.Attrs{\n\t\t\t\t\t\"expiration\": strconv.Itoa(int(timer.Seconds())),\n\t\t\t\t},\n\t\t\t})\n\t\t\tif errors.Is(err, ErrIQBadRequest) {\n\t\t\t\terr = wrapIQError(ErrInvalidDisappearingTimer, err)\n\t\t\t}\n\t\t}\n\tdefault:\n\t\terr = fmt.Errorf(\"can't set disappearing time in a %s chat\", chat.Server)\n\t}\n\treturn\n}\n\nfunc participantListHashV2(participants []types.JID) string {\n\tparticipantsStrings := make([]string, len(participants))\n\tfor i, part := range participants {\n\t\tparticipantsStrings[i] = part.ADString()\n\t}\n\n\tsort.Strings(participantsStrings)\n\thash := sha256.Sum256([]byte(strings.Join(participantsStrings, \"\")))\n\treturn fmt.Sprintf(\"2:%s\", base64.RawStdEncoding.EncodeToString(hash[:6]))\n}\n\nfunc (cli *Client) sendNewsletter(to types.JID, id types.MessageID, message *waProto.Message, mediaID string, timings *MessageDebugTimings) ([]byte, error) {\n\tattrs := waBinary.Attrs{\n\t\t\"to\":   to,\n\t\t\"id\":   id,\n\t\t\"type\": getTypeFromMessage(message),\n\t}\n\tif mediaID != \"\" {\n\t\tattrs[\"media_id\"] = mediaID\n\t}\n\tif message.EditedMessage != nil {\n\t\tattrs[\"edit\"] = string(types.EditAttributeAdminEdit)\n\t\tmessage = message.GetEditedMessage().GetMessage().GetProtocolMessage().GetEditedMessage()\n\t} else if message.ProtocolMessage != nil && message.ProtocolMessage.GetType() == waProto.ProtocolMessage_REVOKE {\n\t\tattrs[\"edit\"] = string(types.EditAttributeAdminRevoke)\n\t\tmessage = nil\n\t}\n\tstart := time.Now()\n\tplaintext, _, err := marshalMessage(to, message)\n\ttimings.Marshal = time.Since(start)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tplaintextNode := waBinary.Node{\n\t\tTag:     \"plaintext\",\n\t\tContent: plaintext,\n\t\tAttrs:   waBinary.Attrs{},\n\t}\n\tif mediaType := getMediaTypeFromMessage(message); mediaType != \"\" {\n\t\tplaintextNode.Attrs[\"mediatype\"] = mediaType\n\t}\n\tnode := waBinary.Node{\n\t\tTag:     \"message\",\n\t\tAttrs:   attrs,\n\t\tContent: []waBinary.Node{plaintextNode},\n\t}\n\tstart = time.Now()\n\tdata, err := cli.sendNodeAndGetData(node)\n\ttimings.Send = time.Since(start)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to send message node: %w\", err)\n\t}\n\treturn data, nil\n}\n\nfunc (cli *Client) sendGroup(ctx context.Context, to, ownID types.JID, id types.MessageID, message *waProto.Message, timings *MessageDebugTimings, botNode *waBinary.Node) (string, []byte, error) {\n\tvar participants []types.JID\n\tvar err error\n\tstart := time.Now()\n\tif to.Server == types.GroupServer {\n\t\tparticipants, err = cli.getGroupMembers(ctx, to)\n\t\tif err != nil {\n\t\t\treturn \"\", nil, fmt.Errorf(\"failed to get group members: %w\", err)\n\t\t}\n\t} else {\n\t\t// TODO use context\n\t\tparticipants, err = cli.getBroadcastListParticipants(to)\n\t\tif err != nil {\n\t\t\treturn \"\", nil, fmt.Errorf(\"failed to get broadcast list members: %w\", err)\n\t\t}\n\t}\n\ttimings.GetParticipants = time.Since(start)\n\tstart = time.Now()\n\tplaintext, _, err := marshalMessage(to, message)\n\ttimings.Marshal = time.Since(start)\n\tif err != nil {\n\t\treturn \"\", nil, err\n\t}\n\n\tstart = time.Now()\n\tbuilder := groups.NewGroupSessionBuilder(cli.Store, pbSerializer)\n\tsenderKeyName := protocol.NewSenderKeyName(to.String(), ownID.SignalAddress())\n\tsignalSKDMessage, err := builder.Create(senderKeyName)\n\tif err != nil {\n\t\treturn \"\", nil, fmt.Errorf(\"failed to create sender key distribution message to send %s to %s: %w\", id, to, err)\n\t}\n\tskdMessage := &waE2E.Message{\n\t\tSenderKeyDistributionMessage: &waE2E.SenderKeyDistributionMessage{\n\t\t\tGroupID:                             proto.String(to.String()),\n\t\t\tAxolotlSenderKeyDistributionMessage: signalSKDMessage.Serialize(),\n\t\t},\n\t}\n\tskdPlaintext, err := proto.Marshal(skdMessage)\n\tif err != nil {\n\t\treturn \"\", nil, fmt.Errorf(\"failed to marshal sender key distribution message to send %s to %s: %w\", id, to, err)\n\t}\n\n\tcipher := groups.NewGroupCipher(builder, senderKeyName, cli.Store)\n\tencrypted, err := cipher.Encrypt(padMessage(plaintext))\n\tif err != nil {\n\t\treturn \"\", nil, fmt.Errorf(\"failed to encrypt group message to send %s to %s: %w\", id, to, err)\n\t}\n\tciphertext := encrypted.SignedSerialize()\n\ttimings.GroupEncrypt = time.Since(start)\n\n\tnode, allDevices, err := cli.prepareMessageNode(ctx, to, ownID, id, message, participants, skdPlaintext, nil, timings, botNode)\n\tif err != nil {\n\t\treturn \"\", nil, err\n\t}\n\n\tphash := participantListHashV2(allDevices)\n\tnode.Attrs[\"phash\"] = phash\n\tskMsg := waBinary.Node{\n\t\tTag:     \"enc\",\n\t\tContent: ciphertext,\n\t\tAttrs:   waBinary.Attrs{\"v\": \"2\", \"type\": \"skmsg\"},\n\t}\n\tif mediaType := getMediaTypeFromMessage(message); mediaType != \"\" {\n\t\tskMsg.Attrs[\"mediatype\"] = mediaType\n\t}\n\tnode.Content = append(node.GetChildren(), skMsg)\n\n\tstart = time.Now()\n\tdata, err := cli.sendNodeAndGetData(*node)\n\ttimings.Send = time.Since(start)\n\tif err != nil {\n\t\treturn \"\", nil, fmt.Errorf(\"failed to send message node: %w\", err)\n\t}\n\treturn phash, data, nil\n}\n\nfunc (cli *Client) sendPeerMessage(to types.JID, id types.MessageID, message *waE2E.Message, timings *MessageDebugTimings) ([]byte, error) {\n\tnode, err := cli.preparePeerMessageNode(to, id, message, timings)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tstart := time.Now()\n\tdata, err := cli.sendNodeAndGetData(*node)\n\ttimings.Send = time.Since(start)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to send message node: %w\", err)\n\t}\n\treturn data, nil\n}\n\nfunc (cli *Client) sendDM(ctx context.Context, to, ownID types.JID, id types.MessageID, message *waE2E.Message, timings *MessageDebugTimings, botNode *waBinary.Node) ([]byte, error) {\n\tstart := time.Now()\n\tmessagePlaintext, deviceSentMessagePlaintext, err := marshalMessage(to, message)\n\ttimings.Marshal = time.Since(start)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tnode, _, err := cli.prepareMessageNode(ctx, to, ownID, id, message, []types.JID{to, ownID.ToNonAD()}, messagePlaintext, deviceSentMessagePlaintext, timings, botNode)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tstart = time.Now()\n\tdata, err := cli.sendNodeAndGetData(*node)\n\ttimings.Send = time.Since(start)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to send message node: %w\", err)\n\t}\n\treturn data, nil\n}\n\nfunc getTypeFromMessage(msg *waProto.Message) string {\n\tswitch {\n\tcase msg.ViewOnceMessage != nil:\n\t\treturn getTypeFromMessage(msg.ViewOnceMessage.Message)\n\tcase msg.ViewOnceMessageV2 != nil:\n\t\treturn getTypeFromMessage(msg.ViewOnceMessageV2.Message)\n\tcase msg.ViewOnceMessageV2Extension != nil:\n\t\treturn getTypeFromMessage(msg.ViewOnceMessageV2Extension.Message)\n\tcase msg.LottieStickerMessage != nil:\n\t\treturn getTypeFromMessage(msg.LottieStickerMessage.Message)\n\tcase msg.EphemeralMessage != nil:\n\t\treturn getTypeFromMessage(msg.EphemeralMessage.Message)\n\tcase msg.DocumentWithCaptionMessage != nil:\n\t\treturn getTypeFromMessage(msg.DocumentWithCaptionMessage.Message)\n\tcase msg.ReactionMessage != nil:\n\t\treturn \"reaction\"\n\tcase msg.PollCreationMessage != nil, msg.PollUpdateMessage != nil:\n\t\treturn \"poll\"\n\tcase getMediaTypeFromMessage(msg) != \"\":\n\t\treturn \"media\"\n\tcase msg.Conversation != nil, msg.ExtendedTextMessage != nil, msg.ProtocolMessage != nil:\n\t\treturn \"text\"\n\tdefault:\n\t\treturn \"text\"\n\t}\n}\n\nfunc getMediaTypeFromMessage(msg *waProto.Message) string {\n\tswitch {\n\tcase msg.ViewOnceMessage != nil:\n\t\treturn getMediaTypeFromMessage(msg.ViewOnceMessage.Message)\n\tcase msg.ViewOnceMessageV2 != nil:\n\t\treturn getMediaTypeFromMessage(msg.ViewOnceMessageV2.Message)\n\tcase msg.ViewOnceMessageV2Extension != nil:\n\t\treturn getMediaTypeFromMessage(msg.ViewOnceMessageV2Extension.Message)\n\tcase msg.LottieStickerMessage != nil:\n\t\treturn getMediaTypeFromMessage(msg.LottieStickerMessage.Message)\n\tcase msg.EphemeralMessage != nil:\n\t\treturn getMediaTypeFromMessage(msg.EphemeralMessage.Message)\n\tcase msg.DocumentWithCaptionMessage != nil:\n\t\treturn getMediaTypeFromMessage(msg.DocumentWithCaptionMessage.Message)\n\tcase msg.ExtendedTextMessage != nil && msg.ExtendedTextMessage.Title != nil:\n\t\treturn \"url\"\n\tcase msg.ImageMessage != nil:\n\t\treturn \"image\"\n\tcase msg.StickerMessage != nil:\n\t\treturn \"sticker\"\n\tcase msg.DocumentMessage != nil:\n\t\treturn \"document\"\n\tcase msg.AudioMessage != nil:\n\t\tif msg.AudioMessage.GetPTT() {\n\t\t\treturn \"ptt\"\n\t\t} else {\n\t\t\treturn \"audio\"\n\t\t}\n\tcase msg.VideoMessage != nil:\n\t\tif msg.VideoMessage.GetGifPlayback() {\n\t\t\treturn \"gif\"\n\t\t} else {\n\t\t\treturn \"video\"\n\t\t}\n\tcase msg.ContactMessage != nil:\n\t\treturn \"vcard\"\n\tcase msg.ContactsArrayMessage != nil:\n\t\treturn \"contact_array\"\n\tcase msg.ListMessage != nil:\n\t\treturn \"list\"\n\tcase msg.ListResponseMessage != nil:\n\t\treturn \"list_response\"\n\tcase msg.ButtonsResponseMessage != nil:\n\t\treturn \"buttons_response\"\n\tcase msg.OrderMessage != nil:\n\t\treturn \"order\"\n\tcase msg.ProductMessage != nil:\n\t\treturn \"product\"\n\tcase msg.InteractiveResponseMessage != nil:\n\t\treturn \"native_flow_response\"\n\tdefault:\n\t\treturn \"\"\n\t}\n}\n\nfunc getButtonTypeFromMessage(msg *waProto.Message) string {\n\tswitch {\n\tcase msg.ViewOnceMessage != nil:\n\t\treturn getButtonTypeFromMessage(msg.ViewOnceMessage.Message)\n\tcase msg.ViewOnceMessageV2 != nil:\n\t\treturn getButtonTypeFromMessage(msg.ViewOnceMessageV2.Message)\n\tcase msg.EphemeralMessage != nil:\n\t\treturn getButtonTypeFromMessage(msg.EphemeralMessage.Message)\n\tcase msg.ButtonsMessage != nil:\n\t\treturn \"buttons\"\n\tcase msg.ButtonsResponseMessage != nil:\n\t\treturn \"buttons_response\"\n\tcase msg.ListMessage != nil:\n\t\treturn \"list\"\n\tcase msg.ListResponseMessage != nil:\n\t\treturn \"list_response\"\n\tcase msg.InteractiveResponseMessage != nil:\n\t\treturn \"interactive_response\"\n\tdefault:\n\t\treturn \"\"\n\t}\n}\n\nfunc getButtonAttributes(msg *waProto.Message) waBinary.Attrs {\n\tswitch {\n\tcase msg.ViewOnceMessage != nil:\n\t\treturn getButtonAttributes(msg.ViewOnceMessage.Message)\n\tcase msg.ViewOnceMessageV2 != nil:\n\t\treturn getButtonAttributes(msg.ViewOnceMessageV2.Message)\n\tcase msg.EphemeralMessage != nil:\n\t\treturn getButtonAttributes(msg.EphemeralMessage.Message)\n\tcase msg.TemplateMessage != nil:\n\t\treturn waBinary.Attrs{}\n\tcase msg.ListMessage != nil:\n\t\treturn waBinary.Attrs{\n\t\t\t\"v\":    \"2\",\n\t\t\t\"type\": strings.ToLower(waE2E.ListMessage_ListType_name[int32(msg.ListMessage.GetListType())]),\n\t\t}\n\tdefault:\n\t\treturn waBinary.Attrs{}\n\t}\n}\n\nconst RemoveReactionText = \"\"\n\nfunc getEditAttribute(msg *waProto.Message) types.EditAttribute {\n\tswitch {\n\tcase msg.EditedMessage != nil && msg.EditedMessage.Message != nil:\n\t\treturn getEditAttribute(msg.EditedMessage.Message)\n\tcase msg.ProtocolMessage != nil && msg.ProtocolMessage.GetKey() != nil:\n\t\tswitch msg.ProtocolMessage.GetType() {\n\t\tcase waProto.ProtocolMessage_REVOKE:\n\t\t\tif msg.ProtocolMessage.GetKey().GetFromMe() {\n\t\t\t\treturn types.EditAttributeSenderRevoke\n\t\t\t} else {\n\t\t\t\treturn types.EditAttributeAdminRevoke\n\t\t\t}\n\t\tcase waProto.ProtocolMessage_MESSAGE_EDIT:\n\t\t\tif msg.ProtocolMessage.EditedMessage != nil {\n\t\t\t\treturn types.EditAttributeMessageEdit\n\t\t\t}\n\t\t}\n\tcase msg.ReactionMessage != nil && msg.ReactionMessage.GetText() == RemoveReactionText:\n\t\treturn types.EditAttributeSenderRevoke\n\tcase msg.KeepInChatMessage != nil && msg.KeepInChatMessage.GetKey().GetFromMe() && msg.KeepInChatMessage.GetKeepType() == waProto.KeepType_UNDO_KEEP_FOR_ALL:\n\t\treturn types.EditAttributeSenderRevoke\n\t}\n\treturn types.EditAttributeEmpty\n}\n\nfunc (cli *Client) preparePeerMessageNode(to types.JID, id types.MessageID, message *waProto.Message, timings *MessageDebugTimings) (*waBinary.Node, error) {\n\tattrs := waBinary.Attrs{\n\t\t\"id\":       id,\n\t\t\"type\":     \"text\",\n\t\t\"category\": \"peer\",\n\t\t\"to\":       to,\n\t}\n\tif message.GetProtocolMessage().GetType() == waProto.ProtocolMessage_APP_STATE_SYNC_KEY_REQUEST {\n\t\tattrs[\"push_priority\"] = \"high\"\n\t}\n\tstart := time.Now()\n\tplaintext, err := proto.Marshal(message)\n\ttimings.Marshal = time.Since(start)\n\tif err != nil {\n\t\terr = fmt.Errorf(\"failed to marshal message: %w\", err)\n\t\treturn nil, err\n\t}\n\tstart = time.Now()\n\tencrypted, isPreKey, err := cli.encryptMessageForDevice(plaintext, to, nil, nil)\n\ttimings.PeerEncrypt = time.Since(start)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to encrypt peer message for %s: %v\", to, err)\n\t}\n\tcontent := []waBinary.Node{*encrypted}\n\tif isPreKey && cli.MessengerConfig == nil {\n\t\tcontent = append(content, cli.makeDeviceIdentityNode())\n\t}\n\treturn &waBinary.Node{\n\t\tTag:     \"message\",\n\t\tAttrs:   attrs,\n\t\tContent: content,\n\t}, nil\n}\n\nfunc (cli *Client) getMessageContent(baseNode waBinary.Node, message *waE2E.Message, msgAttrs waBinary.Attrs, includeIdentity bool, botNode *waBinary.Node) []waBinary.Node {\n\tcontent := []waBinary.Node{baseNode}\n\tif includeIdentity {\n\t\tcontent = append(content, cli.makeDeviceIdentityNode())\n\t}\n\tif msgAttrs[\"type\"] == \"poll\" {\n\t\tpollType := \"creation\"\n\t\tif message.PollUpdateMessage != nil {\n\t\t\tpollType = \"vote\"\n\t\t}\n\t\tcontent = append(content, waBinary.Node{\n\t\t\tTag: \"meta\",\n\t\t\tAttrs: waBinary.Attrs{\n\t\t\t\t\"polltype\": pollType,\n\t\t\t},\n\t\t})\n\t}\n\n\tif botNode != nil {\n\t\tcontent = append(content, *botNode)\n\t}\n\n\tif buttonType := getButtonTypeFromMessage(message); buttonType != \"\" {\n\t\tcontent = append(content, waBinary.Node{\n\t\t\tTag: \"biz\",\n\t\t\tContent: []waBinary.Node{{\n\t\t\t\tTag:   buttonType,\n\t\t\t\tAttrs: getButtonAttributes(message),\n\t\t\t}},\n\t\t})\n\t}\n\treturn content\n}\n\nfunc (cli *Client) prepareMessageNode(ctx context.Context, to, ownID types.JID, id types.MessageID, message *waE2E.Message, participants []types.JID, plaintext, dsmPlaintext []byte, timings *MessageDebugTimings, botNode *waBinary.Node) (*waBinary.Node, []types.JID, error) {\n\tstart := time.Now()\n\tallDevices, err := cli.GetUserDevicesContext(ctx, participants)\n\ttimings.GetDevices = time.Since(start)\n\tif err != nil {\n\t\treturn nil, nil, fmt.Errorf(\"failed to get device list: %w\", err)\n\t}\n\n\tmsgType := getTypeFromMessage(message)\n\tencAttrs := waBinary.Attrs{}\n\t// Only include encMediaType for 1:1 messages (groups don't have a device-sent message plaintext)\n\tif encMediaType := getMediaTypeFromMessage(message); dsmPlaintext != nil && encMediaType != \"\" {\n\t\tencAttrs[\"mediatype\"] = encMediaType\n\t}\n\tattrs := waBinary.Attrs{\n\t\t\"id\":   id,\n\t\t\"type\": msgType,\n\t\t\"to\":   to,\n\t}\n\tif editAttr := getEditAttribute(message); editAttr != \"\" {\n\t\tattrs[\"edit\"] = string(editAttr)\n\t\tencAttrs[\"decrypt-fail\"] = string(events.DecryptFailHide)\n\t}\n\tif msgType == \"reaction\" || message.GetPollUpdateMessage() != nil {\n\t\tencAttrs[\"decrypt-fail\"] = string(events.DecryptFailHide)\n\t}\n\n\tstart = time.Now()\n\tparticipantNodes, includeIdentity := cli.encryptMessageForDevices(ctx, allDevices, ownID, id, plaintext, dsmPlaintext, encAttrs)\n\ttimings.PeerEncrypt = time.Since(start)\n\tparticipantNode := waBinary.Node{\n\t\tTag:     \"participants\",\n\t\tContent: participantNodes,\n\t}\n\treturn &waBinary.Node{\n\t\tTag:     \"message\",\n\t\tAttrs:   attrs,\n\t\tContent: cli.getMessageContent(participantNode, message, attrs, includeIdentity, botNode),\n\t}, allDevices, nil\n}\n\nfunc marshalMessage(to types.JID, message *waProto.Message) (plaintext, dsmPlaintext []byte, err error) {\n\tif message == nil && to.Server == types.NewsletterServer {\n\t\treturn\n\t}\n\tplaintext, err = proto.Marshal(message)\n\tif err != nil {\n\t\terr = fmt.Errorf(\"failed to marshal message: %w\", err)\n\t\treturn\n\t}\n\n\tif to.Server != types.GroupServer && to.Server != types.NewsletterServer {\n\t\tdsmPlaintext, err = proto.Marshal(&waProto.Message{\n\t\t\tDeviceSentMessage: &waProto.DeviceSentMessage{\n\t\t\t\tDestinationJID: proto.String(to.String()),\n\t\t\t\tMessage:        message,\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\terr = fmt.Errorf(\"failed to marshal message (for own devices): %w\", err)\n\t\t\treturn\n\t\t}\n\t}\n\n\treturn\n}\n\nfunc (cli *Client) makeDeviceIdentityNode() waBinary.Node {\n\tdeviceIdentity, err := proto.Marshal(cli.Store.Account)\n\tif err != nil {\n\t\tpanic(fmt.Errorf(\"failed to marshal device identity: %w\", err))\n\t}\n\treturn waBinary.Node{\n\t\tTag:     \"device-identity\",\n\t\tContent: deviceIdentity,\n\t}\n}\n\nfunc (cli *Client) encryptMessageForDevices(ctx context.Context, allDevices []types.JID, ownID types.JID, id string, msgPlaintext, dsmPlaintext []byte, encAttrs waBinary.Attrs) ([]waBinary.Node, bool) {\n\tincludeIdentity := false\n\tparticipantNodes := make([]waBinary.Node, 0, len(allDevices))\n\tvar retryDevices []types.JID\n\tfor _, jid := range allDevices {\n\t\tplaintext := msgPlaintext\n\t\tif jid.User == ownID.User && dsmPlaintext != nil {\n\t\t\tif jid == ownID {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tplaintext = dsmPlaintext\n\t\t}\n\t\tencrypted, isPreKey, err := cli.encryptMessageForDeviceAndWrap(plaintext, jid, nil, encAttrs)\n\t\tif errors.Is(err, ErrNoSession) {\n\t\t\tretryDevices = append(retryDevices, jid)\n\t\t\tcontinue\n\t\t} else if err != nil {\n\t\t\tcli.Log.Warnf(\"Failed to encrypt %s for %s: %v\", id, jid, err)\n\t\t\tcontinue\n\t\t}\n\n\t\tparticipantNodes = append(participantNodes, *encrypted)\n\t\tif isPreKey {\n\t\t\tincludeIdentity = true\n\t\t}\n\t}\n\tif len(retryDevices) > 0 {\n\t\tbundles, err := cli.fetchPreKeys(ctx, retryDevices)\n\t\tif err != nil {\n\t\t\tcli.Log.Warnf(\"Failed to fetch prekeys for %v to retry encryption: %v\", retryDevices, err)\n\t\t} else {\n\t\t\tfor _, jid := range retryDevices {\n\t\t\t\tresp := bundles[jid]\n\t\t\t\tif resp.err != nil {\n\t\t\t\t\tcli.Log.Warnf(\"Failed to fetch prekey for %s: %v\", jid, resp.err)\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\tplaintext := msgPlaintext\n\t\t\t\tif jid.User == ownID.User && dsmPlaintext != nil {\n\t\t\t\t\tplaintext = dsmPlaintext\n\t\t\t\t}\n\t\t\t\tencrypted, isPreKey, err := cli.encryptMessageForDeviceAndWrap(plaintext, jid, resp.bundle, encAttrs)\n\t\t\t\tif err != nil {\n\t\t\t\t\tcli.Log.Warnf(\"Failed to encrypt %s for %s (retry): %v\", id, jid, err)\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\tparticipantNodes = append(participantNodes, *encrypted)\n\t\t\t\tif isPreKey {\n\t\t\t\t\tincludeIdentity = true\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn participantNodes, includeIdentity\n}\n\nfunc (cli *Client) encryptMessageForDeviceAndWrap(plaintext []byte, to types.JID, bundle *prekey.Bundle, encAttrs waBinary.Attrs) (*waBinary.Node, bool, error) {\n\tnode, includeDeviceIdentity, err := cli.encryptMessageForDevice(plaintext, to, bundle, encAttrs)\n\tif err != nil {\n\t\treturn nil, false, err\n\t}\n\treturn &waBinary.Node{\n\t\tTag:     \"to\",\n\t\tAttrs:   waBinary.Attrs{\"jid\": to},\n\t\tContent: []waBinary.Node{*node},\n\t}, includeDeviceIdentity, nil\n}\n\nfunc copyAttrs(from, to waBinary.Attrs) {\n\tfor k, v := range from {\n\t\tto[k] = v\n\t}\n}\n\nfunc (cli *Client) encryptMessageForDevice(plaintext []byte, to types.JID, bundle *prekey.Bundle, extraAttrs waBinary.Attrs) (*waBinary.Node, bool, error) {\n\tbuilder := session.NewBuilderFromSignal(cli.Store, to.SignalAddress(), pbSerializer)\n\tif bundle != nil {\n\t\tcli.Log.Debugf(\"Processing prekey bundle for %s\", to)\n\t\terr := builder.ProcessBundle(bundle)\n\t\tif cli.AutoTrustIdentity && errors.Is(err, signalerror.ErrUntrustedIdentity) {\n\t\t\tcli.Log.Warnf(\"Got %v error while trying to process prekey bundle for %s, clearing stored identity and retrying\", err, to)\n\t\t\tcli.clearUntrustedIdentity(to)\n\t\t\terr = builder.ProcessBundle(bundle)\n\t\t}\n\t\tif err != nil {\n\t\t\treturn nil, false, fmt.Errorf(\"failed to process prekey bundle: %w\", err)\n\t\t}\n\t} else if !cli.Store.ContainsSession(to.SignalAddress()) {\n\t\treturn nil, false, ErrNoSession\n\t}\n\tcipher := session.NewCipher(builder, to.SignalAddress())\n\tciphertext, err := cipher.Encrypt(padMessage(plaintext))\n\tif err != nil {\n\t\treturn nil, false, fmt.Errorf(\"cipher encryption failed: %w\", err)\n\t}\n\n\tencAttrs := waBinary.Attrs{\n\t\t\"v\":    \"2\",\n\t\t\"type\": \"msg\",\n\t}\n\tif ciphertext.Type() == protocol.PREKEY_TYPE {\n\t\tencAttrs[\"type\"] = \"pkmsg\"\n\t}\n\tcopyAttrs(extraAttrs, encAttrs)\n\n\tincludeDeviceIdentity := encAttrs[\"type\"] == \"pkmsg\" && cli.MessengerConfig == nil\n\treturn &waBinary.Node{\n\t\tTag:     \"enc\",\n\t\tAttrs:   encAttrs,\n\t\tContent: ciphertext.Serialize(),\n\t}, includeDeviceIdentity, nil\n}\n"
        },
        {
          "name": "sendfb.go",
          "type": "blob",
          "size": 20.3359375,
          "content": "// Copyright (c) 2024 Tulir Asokan\n//\n// This Source Code Form is subject to the terms of the Mozilla Public\n// License, v. 2.0. If a copy of the MPL was not distributed with this\n// file, You can obtain one at http://mozilla.org/MPL/2.0/.\n\npackage whatsmeow\n\nimport (\n\t\"context\"\n\t\"crypto/hmac\"\n\t\"crypto/sha256\"\n\t\"errors\"\n\t\"fmt\"\n\t\"time\"\n\n\t\"github.com/google/uuid\"\n\t\"go.mau.fi/libsignal/groups\"\n\t\"go.mau.fi/libsignal/keys/prekey\"\n\t\"go.mau.fi/libsignal/protocol\"\n\t\"go.mau.fi/libsignal/session\"\n\t\"go.mau.fi/libsignal/signalerror\"\n\t\"go.mau.fi/util/random\"\n\t\"google.golang.org/protobuf/proto\"\n\n\twaBinary \"go.mau.fi/whatsmeow/binary\"\n\tarmadillo \"go.mau.fi/whatsmeow/proto\"\n\t\"go.mau.fi/whatsmeow/proto/waArmadilloApplication\"\n\t\"go.mau.fi/whatsmeow/proto/waCommon\"\n\t\"go.mau.fi/whatsmeow/proto/waConsumerApplication\"\n\t\"go.mau.fi/whatsmeow/proto/waMsgApplication\"\n\t\"go.mau.fi/whatsmeow/proto/waMsgTransport\"\n\t\"go.mau.fi/whatsmeow/types\"\n\t\"go.mau.fi/whatsmeow/types/events\"\n)\n\nconst FBMessageVersion = 3\nconst FBMessageApplicationVersion = 2\nconst FBConsumerMessageVersion = 1\nconst FBArmadilloMessageVersion = 1\n\n// SendFBMessage sends the given v3 message to the given JID.\nfunc (cli *Client) SendFBMessage(\n\tctx context.Context,\n\tto types.JID,\n\tmessage armadillo.RealMessageApplicationSub,\n\tmetadata *waMsgApplication.MessageApplication_Metadata,\n\textra ...SendRequestExtra,\n) (resp SendResponse, err error) {\n\tif cli == nil {\n\t\terr = ErrClientIsNil\n\t\treturn\n\t}\n\tvar req SendRequestExtra\n\tif len(extra) > 1 {\n\t\terr = errors.New(\"only one extra parameter may be provided to SendMessage\")\n\t\treturn\n\t} else if len(extra) == 1 {\n\t\treq = extra[0]\n\t}\n\tvar subproto waMsgApplication.MessageApplication_SubProtocolPayload\n\tsubproto.FutureProof = waCommon.FutureProofBehavior_PLACEHOLDER.Enum()\n\tswitch typedMsg := message.(type) {\n\tcase *waConsumerApplication.ConsumerApplication:\n\t\tvar consumerMessage []byte\n\t\tconsumerMessage, err = proto.Marshal(typedMsg)\n\t\tif err != nil {\n\t\t\terr = fmt.Errorf(\"failed to marshal consumer message: %w\", err)\n\t\t\treturn\n\t\t}\n\t\tsubproto.SubProtocol = &waMsgApplication.MessageApplication_SubProtocolPayload_ConsumerMessage{\n\t\t\tConsumerMessage: &waCommon.SubProtocol{\n\t\t\t\tPayload: consumerMessage,\n\t\t\t\tVersion: proto.Int32(FBConsumerMessageVersion),\n\t\t\t},\n\t\t}\n\tcase *waArmadilloApplication.Armadillo:\n\t\tvar armadilloMessage []byte\n\t\tarmadilloMessage, err = proto.Marshal(typedMsg)\n\t\tif err != nil {\n\t\t\terr = fmt.Errorf(\"failed to marshal armadillo message: %w\", err)\n\t\t\treturn\n\t\t}\n\t\tsubproto.SubProtocol = &waMsgApplication.MessageApplication_SubProtocolPayload_Armadillo{\n\t\t\tArmadillo: &waCommon.SubProtocol{\n\t\t\t\tPayload: armadilloMessage,\n\t\t\t\tVersion: proto.Int32(FBArmadilloMessageVersion),\n\t\t\t},\n\t\t}\n\tdefault:\n\t\terr = fmt.Errorf(\"unsupported message type %T\", message)\n\t\treturn\n\t}\n\tif metadata == nil {\n\t\tmetadata = &waMsgApplication.MessageApplication_Metadata{}\n\t}\n\tmetadata.FrankingVersion = proto.Int32(0)\n\tmetadata.FrankingKey = random.Bytes(32)\n\tmsgAttrs := getAttrsFromFBMessage(message)\n\tmessageAppProto := &waMsgApplication.MessageApplication{\n\t\tPayload: &waMsgApplication.MessageApplication_Payload{\n\t\t\tContent: &waMsgApplication.MessageApplication_Payload_SubProtocol{\n\t\t\t\tSubProtocol: &subproto,\n\t\t\t},\n\t\t},\n\t\tMetadata: metadata,\n\t}\n\tmessageApp, err := proto.Marshal(messageAppProto)\n\tif err != nil {\n\t\treturn resp, fmt.Errorf(\"failed to marshal message application: %w\", err)\n\t}\n\tfrankingHash := hmac.New(sha256.New, metadata.FrankingKey)\n\tfrankingHash.Write(messageApp)\n\tfrankingTag := frankingHash.Sum(nil)\n\tif to.Device > 0 && !req.Peer {\n\t\terr = ErrRecipientADJID\n\t\treturn\n\t}\n\townID := cli.getOwnID()\n\tif ownID.IsEmpty() {\n\t\terr = ErrNotLoggedIn\n\t\treturn\n\t}\n\n\tif req.Timeout == 0 {\n\t\treq.Timeout = defaultRequestTimeout\n\t}\n\tif len(req.ID) == 0 {\n\t\treq.ID = cli.GenerateMessageID()\n\t}\n\tresp.ID = req.ID\n\n\tstart := time.Now()\n\t// Sending multiple messages at a time can cause weird issues and makes it harder to retry safely\n\tcli.messageSendLock.Lock()\n\tresp.DebugTimings.Queue = time.Since(start)\n\tdefer cli.messageSendLock.Unlock()\n\n\trespChan := cli.waitResponse(req.ID)\n\tif !req.Peer {\n\t\tcli.addRecentMessage(to, req.ID, nil, messageAppProto)\n\t}\n\tvar phash string\n\tvar data []byte\n\tswitch to.Server {\n\tcase types.GroupServer:\n\t\tphash, data, err = cli.sendGroupV3(ctx, to, ownID, req.ID, messageApp, msgAttrs, frankingTag, &resp.DebugTimings)\n\tcase types.DefaultUserServer, types.MessengerServer:\n\t\tif req.Peer {\n\t\t\terr = fmt.Errorf(\"peer messages to fb are not yet supported\")\n\t\t\t//data, err = cli.sendPeerMessage(to, req.ID, message, &resp.DebugTimings)\n\t\t} else {\n\t\t\tdata, phash, err = cli.sendDMV3(ctx, to, ownID, req.ID, messageApp, msgAttrs, frankingTag, &resp.DebugTimings)\n\t\t}\n\tdefault:\n\t\terr = fmt.Errorf(\"%w %s\", ErrUnknownServer, to.Server)\n\t}\n\tstart = time.Now()\n\tif err != nil {\n\t\tcli.cancelResponse(req.ID, respChan)\n\t\treturn\n\t}\n\tvar respNode *waBinary.Node\n\tvar timeoutChan <-chan time.Time\n\tif req.Timeout > 0 {\n\t\ttimeoutChan = time.After(req.Timeout)\n\t} else {\n\t\ttimeoutChan = make(<-chan time.Time)\n\t}\n\tselect {\n\tcase respNode = <-respChan:\n\tcase <-timeoutChan:\n\t\tcli.cancelResponse(req.ID, respChan)\n\t\terr = ErrMessageTimedOut\n\t\treturn\n\tcase <-ctx.Done():\n\t\tcli.cancelResponse(req.ID, respChan)\n\t\terr = ctx.Err()\n\t\treturn\n\t}\n\tresp.DebugTimings.Resp = time.Since(start)\n\tif isDisconnectNode(respNode) {\n\t\tstart = time.Now()\n\t\trespNode, err = cli.retryFrame(\"message send\", req.ID, data, respNode, ctx, 0)\n\t\tresp.DebugTimings.Retry = time.Since(start)\n\t\tif err != nil {\n\t\t\treturn\n\t\t}\n\t}\n\tag := respNode.AttrGetter()\n\tresp.ServerID = types.MessageServerID(ag.OptionalInt(\"server_id\"))\n\tresp.Timestamp = ag.UnixTime(\"t\")\n\tif errorCode := ag.Int(\"error\"); errorCode != 0 {\n\t\terr = fmt.Errorf(\"%w %d\", ErrServerReturnedError, errorCode)\n\t}\n\texpectedPHash := ag.OptionalString(\"phash\")\n\tif len(expectedPHash) > 0 && phash != expectedPHash {\n\t\tcli.Log.Warnf(\"Server returned different participant list hash when sending to %s. Some devices may not have received the message.\", to)\n\t\t// TODO also invalidate device list caches\n\t\tcli.groupParticipantsCacheLock.Lock()\n\t\tdelete(cli.groupParticipantsCache, to)\n\t\tcli.groupParticipantsCacheLock.Unlock()\n\t}\n\treturn\n}\n\nfunc (cli *Client) sendGroupV3(\n\tctx context.Context,\n\tto,\n\townID types.JID,\n\tid types.MessageID,\n\tmessageApp []byte,\n\tmsgAttrs messageAttrs,\n\tfrankingTag []byte,\n\ttimings *MessageDebugTimings,\n) (string, []byte, error) {\n\tvar participants []types.JID\n\tvar err error\n\tstart := time.Now()\n\tif to.Server == types.GroupServer {\n\t\tparticipants, err = cli.getGroupMembers(ctx, to)\n\t\tif err != nil {\n\t\t\treturn \"\", nil, fmt.Errorf(\"failed to get group members: %w\", err)\n\t\t}\n\t}\n\ttimings.GetParticipants = time.Since(start)\n\n\tstart = time.Now()\n\tbuilder := groups.NewGroupSessionBuilder(cli.Store, pbSerializer)\n\tsenderKeyName := protocol.NewSenderKeyName(to.String(), ownID.SignalAddress())\n\tsignalSKDMessage, err := builder.Create(senderKeyName)\n\tif err != nil {\n\t\treturn \"\", nil, fmt.Errorf(\"failed to create sender key distribution message to send %s to %s: %w\", id, to, err)\n\t}\n\tskdm := &waMsgTransport.MessageTransport_Protocol_Ancillary_SenderKeyDistributionMessage{\n\t\tGroupID:                             proto.String(to.String()),\n\t\tAxolotlSenderKeyDistributionMessage: signalSKDMessage.Serialize(),\n\t}\n\n\tcipher := groups.NewGroupCipher(builder, senderKeyName, cli.Store)\n\tplaintext, err := proto.Marshal(&waMsgTransport.MessageTransport{\n\t\tPayload: &waMsgTransport.MessageTransport_Payload{\n\t\t\tApplicationPayload: &waCommon.SubProtocol{\n\t\t\t\tPayload: messageApp,\n\t\t\t\tVersion: proto.Int32(FBMessageApplicationVersion),\n\t\t\t},\n\t\t\tFutureProof: waCommon.FutureProofBehavior_PLACEHOLDER.Enum(),\n\t\t},\n\t\tProtocol: &waMsgTransport.MessageTransport_Protocol{\n\t\t\tIntegral: &waMsgTransport.MessageTransport_Protocol_Integral{\n\t\t\t\tPadding: padMessage(nil),\n\t\t\t\tDSM:     nil,\n\t\t\t},\n\t\t\tAncillary: &waMsgTransport.MessageTransport_Protocol_Ancillary{\n\t\t\t\tSkdm:               nil,\n\t\t\t\tDeviceListMetadata: nil,\n\t\t\t\tIcdc:               nil,\n\t\t\t\tBackupDirective: &waMsgTransport.MessageTransport_Protocol_Ancillary_BackupDirective{\n\t\t\t\t\tMessageID:  &id,\n\t\t\t\t\tActionType: waMsgTransport.MessageTransport_Protocol_Ancillary_BackupDirective_UPSERT.Enum(),\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t})\n\tif err != nil {\n\t\treturn \"\", nil, fmt.Errorf(\"failed to marshal message transport: %w\", err)\n\t}\n\tencrypted, err := cipher.Encrypt(plaintext)\n\tif err != nil {\n\t\treturn \"\", nil, fmt.Errorf(\"failed to encrypt group message to send %s to %s: %w\", id, to, err)\n\t}\n\tciphertext := encrypted.SignedSerialize()\n\ttimings.GroupEncrypt = time.Since(start)\n\n\tnode, allDevices, err := cli.prepareMessageNodeV3(ctx, to, ownID, id, nil, skdm, msgAttrs, frankingTag, participants, timings)\n\tif err != nil {\n\t\treturn \"\", nil, err\n\t}\n\n\tphash := participantListHashV2(allDevices)\n\tnode.Attrs[\"phash\"] = phash\n\tskMsg := waBinary.Node{\n\t\tTag:     \"enc\",\n\t\tContent: ciphertext,\n\t\tAttrs:   waBinary.Attrs{\"v\": \"3\", \"type\": \"skmsg\"},\n\t}\n\tif msgAttrs.MediaType != \"\" {\n\t\tskMsg.Attrs[\"mediatype\"] = msgAttrs.MediaType\n\t}\n\tnode.Content = append(node.GetChildren(), skMsg)\n\n\tstart = time.Now()\n\tdata, err := cli.sendNodeAndGetData(*node)\n\ttimings.Send = time.Since(start)\n\tif err != nil {\n\t\treturn \"\", nil, fmt.Errorf(\"failed to send message node: %w\", err)\n\t}\n\treturn phash, data, nil\n}\n\nfunc (cli *Client) sendDMV3(\n\tctx context.Context,\n\tto,\n\townID types.JID,\n\tid types.MessageID,\n\tmessageApp []byte,\n\tmsgAttrs messageAttrs,\n\tfrankingTag []byte,\n\ttimings *MessageDebugTimings,\n) ([]byte, string, error) {\n\tpayload := &waMsgTransport.MessageTransport_Payload{\n\t\tApplicationPayload: &waCommon.SubProtocol{\n\t\t\tPayload: messageApp,\n\t\t\tVersion: proto.Int32(FBMessageApplicationVersion),\n\t\t},\n\t\tFutureProof: waCommon.FutureProofBehavior_PLACEHOLDER.Enum(),\n\t}\n\n\tnode, allDevices, err := cli.prepareMessageNodeV3(ctx, to, ownID, id, payload, nil, msgAttrs, frankingTag, []types.JID{to, ownID.ToNonAD()}, timings)\n\tif err != nil {\n\t\treturn nil, \"\", err\n\t}\n\tstart := time.Now()\n\tdata, err := cli.sendNodeAndGetData(*node)\n\ttimings.Send = time.Since(start)\n\tif err != nil {\n\t\treturn nil, \"\", fmt.Errorf(\"failed to send message node: %w\", err)\n\t}\n\treturn data, participantListHashV2(allDevices), nil\n}\n\ntype messageAttrs struct {\n\tType        string\n\tMediaType   string\n\tEdit        types.EditAttribute\n\tDecryptFail events.DecryptFailMode\n\tPollType    string\n}\n\nfunc getAttrsFromFBMessage(msg armadillo.MessageApplicationSub) (attrs messageAttrs) {\n\tswitch typedMsg := msg.(type) {\n\tcase *waConsumerApplication.ConsumerApplication:\n\t\treturn getAttrsFromFBConsumerMessage(typedMsg)\n\tcase *waArmadilloApplication.Armadillo:\n\t\tattrs.Type = \"media\"\n\t\tattrs.MediaType = \"document\"\n\tdefault:\n\t\tattrs.Type = \"text\"\n\t}\n\treturn\n}\n\nfunc getAttrsFromFBConsumerMessage(msg *waConsumerApplication.ConsumerApplication) (attrs messageAttrs) {\n\tswitch payload := msg.GetPayload().GetPayload().(type) {\n\tcase *waConsumerApplication.ConsumerApplication_Payload_Content:\n\t\tswitch content := payload.Content.GetContent().(type) {\n\t\tcase *waConsumerApplication.ConsumerApplication_Content_MessageText,\n\t\t\t*waConsumerApplication.ConsumerApplication_Content_ExtendedTextMessage:\n\t\t\tattrs.Type = \"text\"\n\t\tcase *waConsumerApplication.ConsumerApplication_Content_ImageMessage:\n\t\t\tattrs.MediaType = \"image\"\n\t\tcase *waConsumerApplication.ConsumerApplication_Content_StickerMessage:\n\t\t\tattrs.MediaType = \"sticker\"\n\t\tcase *waConsumerApplication.ConsumerApplication_Content_ViewOnceMessage:\n\t\t\tswitch content.ViewOnceMessage.GetViewOnceContent().(type) {\n\t\t\tcase *waConsumerApplication.ConsumerApplication_ViewOnceMessage_ImageMessage:\n\t\t\t\tattrs.MediaType = \"image\"\n\t\t\tcase *waConsumerApplication.ConsumerApplication_ViewOnceMessage_VideoMessage:\n\t\t\t\tattrs.MediaType = \"video\"\n\t\t\t}\n\t\tcase *waConsumerApplication.ConsumerApplication_Content_DocumentMessage:\n\t\t\tattrs.MediaType = \"document\"\n\t\tcase *waConsumerApplication.ConsumerApplication_Content_AudioMessage:\n\t\t\tif content.AudioMessage.GetPTT() {\n\t\t\t\tattrs.MediaType = \"ptt\"\n\t\t\t} else {\n\t\t\t\tattrs.MediaType = \"audio\"\n\t\t\t}\n\t\tcase *waConsumerApplication.ConsumerApplication_Content_VideoMessage:\n\t\t\t// TODO gifPlayback?\n\t\t\tattrs.MediaType = \"video\"\n\t\tcase *waConsumerApplication.ConsumerApplication_Content_LocationMessage:\n\t\t\tattrs.MediaType = \"location\"\n\t\tcase *waConsumerApplication.ConsumerApplication_Content_LiveLocationMessage:\n\t\t\tattrs.MediaType = \"location\"\n\t\tcase *waConsumerApplication.ConsumerApplication_Content_ContactMessage:\n\t\t\tattrs.MediaType = \"vcard\"\n\t\tcase *waConsumerApplication.ConsumerApplication_Content_ContactsArrayMessage:\n\t\t\tattrs.MediaType = \"contact_array\"\n\t\tcase *waConsumerApplication.ConsumerApplication_Content_PollCreationMessage:\n\t\t\tattrs.PollType = \"creation\"\n\t\t\tattrs.Type = \"poll\"\n\t\tcase *waConsumerApplication.ConsumerApplication_Content_PollUpdateMessage:\n\t\t\tattrs.PollType = \"vote\"\n\t\t\tattrs.Type = \"poll\"\n\t\t\tattrs.DecryptFail = events.DecryptFailHide\n\t\tcase *waConsumerApplication.ConsumerApplication_Content_ReactionMessage:\n\t\t\tattrs.Type = \"reaction\"\n\t\t\tattrs.DecryptFail = events.DecryptFailHide\n\t\tcase *waConsumerApplication.ConsumerApplication_Content_EditMessage:\n\t\t\tattrs.Edit = types.EditAttributeMessageEdit\n\t\t\tattrs.DecryptFail = events.DecryptFailHide\n\t\t}\n\t\tif attrs.MediaType != \"\" && attrs.Type == \"\" {\n\t\t\tattrs.Type = \"media\"\n\t\t}\n\tcase *waConsumerApplication.ConsumerApplication_Payload_ApplicationData:\n\t\tswitch content := payload.ApplicationData.GetApplicationContent().(type) {\n\t\tcase *waConsumerApplication.ConsumerApplication_ApplicationData_Revoke:\n\t\t\tif content.Revoke.GetKey().GetFromMe() {\n\t\t\t\tattrs.Edit = types.EditAttributeSenderRevoke\n\t\t\t} else {\n\t\t\t\tattrs.Edit = types.EditAttributeAdminRevoke\n\t\t\t}\n\t\t\tattrs.DecryptFail = events.DecryptFailHide\n\t\t}\n\tcase *waConsumerApplication.ConsumerApplication_Payload_Signal:\n\tcase *waConsumerApplication.ConsumerApplication_Payload_SubProtocol:\n\t}\n\tif attrs.Type == \"\" {\n\t\tattrs.Type = \"text\"\n\t}\n\treturn\n}\n\nfunc (cli *Client) prepareMessageNodeV3(\n\tctx context.Context,\n\tto,\n\townID types.JID,\n\tid types.MessageID,\n\tpayload *waMsgTransport.MessageTransport_Payload,\n\tskdm *waMsgTransport.MessageTransport_Protocol_Ancillary_SenderKeyDistributionMessage,\n\tmsgAttrs messageAttrs,\n\tfrankingTag []byte,\n\tparticipants []types.JID,\n\ttimings *MessageDebugTimings,\n) (*waBinary.Node, []types.JID, error) {\n\tstart := time.Now()\n\tallDevices, err := cli.GetUserDevicesContext(ctx, participants)\n\ttimings.GetDevices = time.Since(start)\n\tif err != nil {\n\t\treturn nil, nil, fmt.Errorf(\"failed to get device list: %w\", err)\n\t}\n\n\tencAttrs := waBinary.Attrs{}\n\tattrs := waBinary.Attrs{\n\t\t\"id\":   id,\n\t\t\"type\": msgAttrs.Type,\n\t\t\"to\":   to,\n\t}\n\t// Only include mediatype on DMs, for groups it's in the skmsg node\n\tif payload != nil && msgAttrs.MediaType != \"\" {\n\t\tencAttrs[\"mediatype\"] = msgAttrs.MediaType\n\t}\n\tif msgAttrs.Edit != \"\" {\n\t\tattrs[\"edit\"] = string(msgAttrs.Edit)\n\t}\n\tif msgAttrs.DecryptFail != \"\" {\n\t\tencAttrs[\"decrypt-fail\"] = string(msgAttrs.DecryptFail)\n\t}\n\n\tdsm := &waMsgTransport.MessageTransport_Protocol_Integral_DeviceSentMessage{\n\t\tDestinationJID: proto.String(to.String()),\n\t\tPhash:          proto.String(\"\"),\n\t}\n\n\tstart = time.Now()\n\tparticipantNodes := cli.encryptMessageForDevicesV3(ctx, allDevices, ownID, id, payload, skdm, dsm, encAttrs)\n\ttimings.PeerEncrypt = time.Since(start)\n\tcontent := make([]waBinary.Node, 0, 4)\n\tcontent = append(content, waBinary.Node{\n\t\tTag:     \"participants\",\n\t\tContent: participantNodes,\n\t})\n\tmetaAttrs := make(waBinary.Attrs)\n\tif msgAttrs.PollType != \"\" {\n\t\tmetaAttrs[\"polltype\"] = msgAttrs.PollType\n\t}\n\tif msgAttrs.DecryptFail != \"\" {\n\t\tmetaAttrs[\"decrypt-fail\"] = string(msgAttrs.DecryptFail)\n\t}\n\tif len(metaAttrs) > 0 {\n\t\tcontent = append(content, waBinary.Node{\n\t\t\tTag:   \"meta\",\n\t\t\tAttrs: metaAttrs,\n\t\t})\n\t}\n\ttraceRequestID := uuid.New()\n\tcontent = append(content, waBinary.Node{\n\t\tTag: \"franking\",\n\t\tContent: []waBinary.Node{{\n\t\t\tTag:     \"franking_tag\",\n\t\t\tContent: frankingTag,\n\t\t}},\n\t}, waBinary.Node{\n\t\tTag: \"trace\",\n\t\tContent: []waBinary.Node{{\n\t\t\tTag:     \"request_id\",\n\t\t\tContent: traceRequestID[:],\n\t\t}},\n\t})\n\treturn &waBinary.Node{\n\t\tTag:     \"message\",\n\t\tAttrs:   attrs,\n\t\tContent: content,\n\t}, allDevices, nil\n}\n\nfunc (cli *Client) encryptMessageForDevicesV3(\n\tctx context.Context,\n\tallDevices []types.JID,\n\townID types.JID,\n\tid string,\n\tpayload *waMsgTransport.MessageTransport_Payload,\n\tskdm *waMsgTransport.MessageTransport_Protocol_Ancillary_SenderKeyDistributionMessage,\n\tdsm *waMsgTransport.MessageTransport_Protocol_Integral_DeviceSentMessage,\n\tencAttrs waBinary.Attrs,\n) []waBinary.Node {\n\tparticipantNodes := make([]waBinary.Node, 0, len(allDevices))\n\tvar retryDevices []types.JID\n\tfor _, jid := range allDevices {\n\t\tvar dsmForDevice *waMsgTransport.MessageTransport_Protocol_Integral_DeviceSentMessage\n\t\tif jid.User == ownID.User {\n\t\t\tif jid == ownID {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tdsmForDevice = dsm\n\t\t}\n\t\tencrypted, err := cli.encryptMessageForDeviceAndWrapV3(payload, skdm, dsmForDevice, jid, nil, encAttrs)\n\t\tif errors.Is(err, ErrNoSession) {\n\t\t\tretryDevices = append(retryDevices, jid)\n\t\t\tcontinue\n\t\t} else if err != nil {\n\t\t\tcli.Log.Warnf(\"Failed to encrypt %s for %s: %v\", id, jid, err)\n\t\t\tcontinue\n\t\t}\n\t\tparticipantNodes = append(participantNodes, *encrypted)\n\t}\n\tif len(retryDevices) > 0 {\n\t\tbundles, err := cli.fetchPreKeys(ctx, retryDevices)\n\t\tif err != nil {\n\t\t\tcli.Log.Warnf(\"Failed to fetch prekeys for %v to retry encryption: %v\", retryDevices, err)\n\t\t} else {\n\t\t\tfor _, jid := range retryDevices {\n\t\t\t\tresp := bundles[jid]\n\t\t\t\tif resp.err != nil {\n\t\t\t\t\tcli.Log.Warnf(\"Failed to fetch prekey for %s: %v\", jid, resp.err)\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\tvar dsmForDevice *waMsgTransport.MessageTransport_Protocol_Integral_DeviceSentMessage\n\t\t\t\tif jid.User == ownID.User {\n\t\t\t\t\tdsmForDevice = dsm\n\t\t\t\t}\n\t\t\t\tencrypted, err := cli.encryptMessageForDeviceAndWrapV3(payload, skdm, dsmForDevice, jid, resp.bundle, encAttrs)\n\t\t\t\tif err != nil {\n\t\t\t\t\tcli.Log.Warnf(\"Failed to encrypt %s for %s (retry): %v\", id, jid, err)\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\tparticipantNodes = append(participantNodes, *encrypted)\n\t\t\t}\n\t\t}\n\t}\n\treturn participantNodes\n}\n\nfunc (cli *Client) encryptMessageForDeviceAndWrapV3(\n\tpayload *waMsgTransport.MessageTransport_Payload,\n\tskdm *waMsgTransport.MessageTransport_Protocol_Ancillary_SenderKeyDistributionMessage,\n\tdsm *waMsgTransport.MessageTransport_Protocol_Integral_DeviceSentMessage,\n\tto types.JID,\n\tbundle *prekey.Bundle,\n\tencAttrs waBinary.Attrs,\n) (*waBinary.Node, error) {\n\tnode, err := cli.encryptMessageForDeviceV3(payload, skdm, dsm, to, bundle, encAttrs)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn &waBinary.Node{\n\t\tTag:     \"to\",\n\t\tAttrs:   waBinary.Attrs{\"jid\": to},\n\t\tContent: []waBinary.Node{*node},\n\t}, nil\n}\n\nfunc (cli *Client) encryptMessageForDeviceV3(\n\tpayload *waMsgTransport.MessageTransport_Payload,\n\tskdm *waMsgTransport.MessageTransport_Protocol_Ancillary_SenderKeyDistributionMessage,\n\tdsm *waMsgTransport.MessageTransport_Protocol_Integral_DeviceSentMessage,\n\tto types.JID,\n\tbundle *prekey.Bundle,\n\textraAttrs waBinary.Attrs,\n) (*waBinary.Node, error) {\n\tbuilder := session.NewBuilderFromSignal(cli.Store, to.SignalAddress(), pbSerializer)\n\tif bundle != nil {\n\t\tcli.Log.Debugf(\"Processing prekey bundle for %s\", to)\n\t\terr := builder.ProcessBundle(bundle)\n\t\tif cli.AutoTrustIdentity && errors.Is(err, signalerror.ErrUntrustedIdentity) {\n\t\t\tcli.Log.Warnf(\"Got %v error while trying to process prekey bundle for %s, clearing stored identity and retrying\", err, to)\n\t\t\tcli.clearUntrustedIdentity(to)\n\t\t\terr = builder.ProcessBundle(bundle)\n\t\t}\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"failed to process prekey bundle: %w\", err)\n\t\t}\n\t} else if !cli.Store.ContainsSession(to.SignalAddress()) {\n\t\treturn nil, ErrNoSession\n\t}\n\tcipher := session.NewCipher(builder, to.SignalAddress())\n\tplaintext, err := proto.Marshal(&waMsgTransport.MessageTransport{\n\t\tPayload: payload,\n\t\tProtocol: &waMsgTransport.MessageTransport_Protocol{\n\t\t\tIntegral: &waMsgTransport.MessageTransport_Protocol_Integral{\n\t\t\t\tPadding: padMessage(nil),\n\t\t\t\tDSM:     dsm,\n\t\t\t},\n\t\t\tAncillary: &waMsgTransport.MessageTransport_Protocol_Ancillary{\n\t\t\t\tSkdm:               skdm,\n\t\t\t\tDeviceListMetadata: nil,\n\t\t\t\tIcdc:               nil,\n\t\t\t\tBackupDirective:    nil,\n\t\t\t},\n\t\t},\n\t})\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to marshal message transport: %w\", err)\n\t}\n\tciphertext, err := cipher.Encrypt(plaintext)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"cipher encryption failed: %w\", err)\n\t}\n\n\tencAttrs := waBinary.Attrs{\n\t\t\"v\":    FBMessageVersion,\n\t\t\"type\": \"msg\",\n\t}\n\tif ciphertext.Type() == protocol.PREKEY_TYPE {\n\t\tencAttrs[\"type\"] = \"pkmsg\"\n\t}\n\tcopyAttrs(extraAttrs, encAttrs)\n\n\treturn &waBinary.Node{\n\t\tTag:     \"enc\",\n\t\tAttrs:   encAttrs,\n\t\tContent: ciphertext.Serialize(),\n\t}, nil\n}\n"
        },
        {
          "name": "socket",
          "type": "tree",
          "content": null
        },
        {
          "name": "store",
          "type": "tree",
          "content": null
        },
        {
          "name": "types",
          "type": "tree",
          "content": null
        },
        {
          "name": "update.go",
          "type": "blob",
          "size": 2.2431640625,
          "content": "// Copyright (c) 2024 Tulir Asokan\n//\n// This Source Code Form is subject to the terms of the Mozilla Public\n// License, v. 2.0. If a copy of the MPL was not distributed with this\n// file, You can obtain one at http://mozilla.org/MPL/2.0/.\n\npackage whatsmeow\n\nimport (\n\t\"fmt\"\n\t\"io\"\n\t\"net/http\"\n\t\"regexp\"\n\t\"strconv\"\n\n\t\"go.mau.fi/whatsmeow/socket\"\n\t\"go.mau.fi/whatsmeow/store\"\n)\n\nvar clientVersionRegex = regexp.MustCompile(`\"client_revision\":(\\d+),`)\n\n// GetLatestVersion returns the latest version number from web.whatsapp.com.\n//\n// After fetching, you can update the version to use using store.SetWAVersion, e.g.\n//\n//\tlatestVer, err := GetLatestVersion(nil)\n//\tif err != nil {\n//\t\treturn err\n//\t}\n//\tstore.SetWAVersion(*latestVer)\nfunc GetLatestVersion(httpClient *http.Client) (*store.WAVersionContainer, error) {\n\treq, err := http.NewRequest(http.MethodGet, socket.Origin, nil)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to prepare request: %w\", err)\n\t}\n\treq.Header.Set(\"User-Agent\", \"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/125.0.0.0 Safari/537.36\")\n\treq.Header.Set(\"Sec-Fetch-Dest\", \"document\")\n\treq.Header.Set(\"Sec-Fetch-Mode\", \"navigate\")\n\treq.Header.Set(\"Sec-Fetch-Site\", \"none\")\n\treq.Header.Set(\"Sec-Fetch-User\", \"?1\")\n\treq.Header.Set(\"Accept\", \"text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7\")\n\treq.Header.Set(\"Accept-Language\", \"en-US,en;q=0.9\")\n\tif httpClient == nil {\n\t\thttpClient = http.DefaultClient\n\t}\n\tresp, err := httpClient.Do(req)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to send request: %w\", err)\n\t}\n\tdata, err := io.ReadAll(resp.Body)\n\t_ = resp.Body.Close()\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to read response: %w\", err)\n\t} else if resp.StatusCode != 200 {\n\t\treturn nil, fmt.Errorf(\"unexpected response with status %d: %s\", resp.StatusCode, data)\n\t} else if match := clientVersionRegex.FindSubmatch(data); len(match) == 0 {\n\t\treturn nil, fmt.Errorf(\"version number not found\")\n\t} else if parsedVer, err := strconv.ParseInt(string(match[1]), 10, 64); err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to parse version number: %w\", err)\n\t} else {\n\t\treturn &store.WAVersionContainer{2, 3000, uint32(parsedVer)}, nil\n\t}\n}\n"
        },
        {
          "name": "upload.go",
          "type": "blob",
          "size": 8.701171875,
          "content": "// Copyright (c) 2024 Tulir Asokan\n//\n// This Source Code Form is subject to the terms of the Mozilla Public\n// License, v. 2.0. If a copy of the MPL was not distributed with this\n// file, You can obtain one at http://mozilla.org/MPL/2.0/.\n\npackage whatsmeow\n\nimport (\n\t\"bytes\"\n\t\"context\"\n\t\"crypto/hmac\"\n\t\"crypto/sha256\"\n\t\"encoding/base64\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"io\"\n\t\"net/http\"\n\t\"net/url\"\n\t\"os\"\n\n\t\"go.mau.fi/util/random\"\n\n\t\"go.mau.fi/whatsmeow/socket\"\n\t\"go.mau.fi/whatsmeow/util/cbcutil\"\n)\n\n// UploadResponse contains the data from the attachment upload, which can be put into a message to send the attachment.\ntype UploadResponse struct {\n\tURL        string `json:\"url\"`\n\tDirectPath string `json:\"direct_path\"`\n\tHandle     string `json:\"handle\"`\n\tObjectID   string `json:\"object_id\"`\n\n\tMediaKey      []byte `json:\"-\"`\n\tFileEncSHA256 []byte `json:\"-\"`\n\tFileSHA256    []byte `json:\"-\"`\n\tFileLength    uint64 `json:\"-\"`\n}\n\n// Upload uploads the given attachment to WhatsApp servers.\n//\n// You should copy the fields in the response to the corresponding fields in a protobuf message.\n//\n// For example, to send an image:\n//\n//\tresp, err := cli.Upload(context.Background(), yourImageBytes, whatsmeow.MediaImage)\n//\t// handle error\n//\n//\timageMsg := &waE2E.ImageMessage{\n//\t\tCaption:  proto.String(\"Hello, world!\"),\n//\t\tMimetype: proto.String(\"image/png\"), // replace this with the actual mime type\n//\t\t// you can also optionally add other fields like ContextInfo and JpegThumbnail here\n//\n//\t\tURL:           &resp.URL,\n//\t\tDirectPath:    &resp.DirectPath,\n//\t\tMediaKey:      resp.MediaKey,\n//\t\tFileEncSHA256: resp.FileEncSHA256,\n//\t\tFileSHA256:    resp.FileSHA256,\n//\t\tFileLength:    &resp.FileLength,\n//\t}\n//\t_, err = cli.SendMessage(context.Background(), targetJID, &waE2E.Message{\n//\t\tImageMessage: imageMsg,\n//\t})\n//\t// handle error again\n//\n// The same applies to the other message types like DocumentMessage, just replace the struct type and Message field name.\nfunc (cli *Client) Upload(ctx context.Context, plaintext []byte, appInfo MediaType) (resp UploadResponse, err error) {\n\tresp.FileLength = uint64(len(plaintext))\n\tresp.MediaKey = random.Bytes(32)\n\n\tplaintextSHA256 := sha256.Sum256(plaintext)\n\tresp.FileSHA256 = plaintextSHA256[:]\n\n\tiv, cipherKey, macKey, _ := getMediaKeys(resp.MediaKey, appInfo)\n\n\tvar ciphertext []byte\n\tciphertext, err = cbcutil.Encrypt(cipherKey, iv, plaintext)\n\tif err != nil {\n\t\terr = fmt.Errorf(\"failed to encrypt file: %w\", err)\n\t\treturn\n\t}\n\n\th := hmac.New(sha256.New, macKey)\n\th.Write(iv)\n\th.Write(ciphertext)\n\tdataToUpload := append(ciphertext, h.Sum(nil)[:10]...)\n\n\tdataHash := sha256.Sum256(dataToUpload)\n\tresp.FileEncSHA256 = dataHash[:]\n\n\terr = cli.rawUpload(ctx, bytes.NewReader(dataToUpload), uint64(len(dataToUpload)), resp.FileEncSHA256, appInfo, false, &resp)\n\treturn\n}\n\n// UploadReader uploads the given attachment to WhatsApp servers.\n//\n// This is otherwise identical to [Upload], but it reads the plaintext from an [io.Reader] instead of a byte slice.\n// A temporary file is required for the encryption process. If tempFile is nil, a temporary file will be created\n// and deleted after the upload.\n//\n// To use only one file, pass the same file as both plaintext and tempFile. This will cause the file to be overwritten with encrypted data.\nfunc (cli *Client) UploadReader(ctx context.Context, plaintext io.Reader, tempFile io.ReadWriteSeeker, appInfo MediaType) (resp UploadResponse, err error) {\n\tresp.MediaKey = random.Bytes(32)\n\tiv, cipherKey, macKey, _ := getMediaKeys(resp.MediaKey, appInfo)\n\tif tempFile == nil {\n\t\ttempFile, err = os.CreateTemp(\"\", \"whatsmeow-upload-*\")\n\t\tif err != nil {\n\t\t\terr = fmt.Errorf(\"failed to create temporary file: %w\", err)\n\t\t\treturn\n\t\t}\n\t\tdefer func() {\n\t\t\ttempFileFile := tempFile.(*os.File)\n\t\t\t_ = tempFileFile.Close()\n\t\t\t_ = os.Remove(tempFileFile.Name())\n\t\t}()\n\t}\n\tvar uploadSize uint64\n\tresp.FileSHA256, resp.FileEncSHA256, resp.FileLength, uploadSize, err = cbcutil.EncryptStream(cipherKey, iv, macKey, plaintext, tempFile)\n\tif err != nil {\n\t\terr = fmt.Errorf(\"failed to encrypt file: %w\", err)\n\t\treturn\n\t}\n\t_, err = tempFile.Seek(0, io.SeekStart)\n\tif err != nil {\n\t\terr = fmt.Errorf(\"failed to seek to start of temporary file: %w\", err)\n\t\treturn\n\t}\n\terr = cli.rawUpload(ctx, tempFile, uploadSize, resp.FileEncSHA256, appInfo, false, &resp)\n\treturn\n}\n\n// UploadNewsletter uploads the given attachment to WhatsApp servers without encrypting it first.\n//\n// Newsletter media works mostly the same way as normal media, with a few differences:\n// * Since it's unencrypted, there's no MediaKey or FileEncSHA256 fields.\n// * There's a \"media handle\" that needs to be passed in SendRequestExtra.\n//\n// Example:\n//\n//\tresp, err := cli.UploadNewsletter(context.Background(), yourImageBytes, whatsmeow.MediaImage)\n//\t// handle error\n//\n//\timageMsg := &waE2E.ImageMessage{\n//\t\t// Caption, mime type and other such fields work like normal\n//\t\tCaption:  proto.String(\"Hello, world!\"),\n//\t\tMimetype: proto.String(\"image/png\"),\n//\n//\t\t// URL and direct path are also there like normal media\n//\t\tURL:        &resp.URL,\n//\t\tDirectPath: &resp.DirectPath,\n//\t\tFileSHA256: resp.FileSHA256,\n//\t\tFileLength: &resp.FileLength,\n//\t\t// Newsletter media isn't encrypted, so the media key and file enc sha fields are not applicable\n//\t}\n//\t_, err = cli.SendMessage(context.Background(), newsletterJID, &waE2E.Message{\n//\t\tImageMessage: imageMsg,\n//\t}, whatsmeow.SendRequestExtra{\n//\t\t// Unlike normal media, newsletters also include a \"media handle\" in the send request.\n//\t\tMediaHandle: resp.Handle,\n//\t})\n//\t// handle error again\nfunc (cli *Client) UploadNewsletter(ctx context.Context, data []byte, appInfo MediaType) (resp UploadResponse, err error) {\n\tresp.FileLength = uint64(len(data))\n\thash := sha256.Sum256(data)\n\tresp.FileSHA256 = hash[:]\n\terr = cli.rawUpload(ctx, bytes.NewReader(data), resp.FileLength, resp.FileSHA256, appInfo, true, &resp)\n\treturn\n}\n\n// UploadNewsletterReader uploads the given attachment to WhatsApp servers without encrypting it first.\n//\n// This is otherwise identical to [UploadNewsletter], but it reads the plaintext from an [io.Reader] instead of a byte slice.\n// Unlike [UploadReader], this does not require a temporary file. However, the data needs to be hashed first,\n// so an [io.ReadSeeker] is required to be able to read the data twice.\nfunc (cli *Client) UploadNewsletterReader(ctx context.Context, data io.ReadSeeker, appInfo MediaType) (resp UploadResponse, err error) {\n\thasher := sha256.New()\n\tvar fileLength int64\n\tfileLength, err = io.Copy(hasher, data)\n\tresp.FileLength = uint64(fileLength)\n\tresp.FileSHA256 = hasher.Sum(nil)\n\t_, err = data.Seek(0, io.SeekStart)\n\tif err != nil {\n\t\terr = fmt.Errorf(\"failed to seek to start of data: %w\", err)\n\t\treturn\n\t}\n\terr = cli.rawUpload(ctx, data, resp.FileLength, resp.FileSHA256, appInfo, true, &resp)\n\treturn\n}\n\nfunc (cli *Client) rawUpload(ctx context.Context, dataToUpload io.Reader, uploadSize uint64, fileHash []byte, appInfo MediaType, newsletter bool, resp *UploadResponse) error {\n\tmediaConn, err := cli.refreshMediaConn(false)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to refresh media connections: %w\", err)\n\t}\n\n\ttoken := base64.URLEncoding.EncodeToString(fileHash)\n\tq := url.Values{\n\t\t\"auth\":  []string{mediaConn.Auth},\n\t\t\"token\": []string{token},\n\t}\n\tmmsType := mediaTypeToMMSType[appInfo]\n\tuploadPrefix := \"mms\"\n\tif cli.MessengerConfig != nil {\n\t\tuploadPrefix = \"wa-msgr/mms\"\n\t\t// Messenger upload only allows voice messages, not audio files\n\t\tif mmsType == \"audio\" {\n\t\t\tmmsType = \"ptt\"\n\t\t}\n\t}\n\tif newsletter {\n\t\tmmsType = fmt.Sprintf(\"newsletter-%s\", mmsType)\n\t\tuploadPrefix = \"newsletter\"\n\t}\n\tvar host string\n\t// Hacky hack to prefer last option (rupload.facebook.com) for messenger uploads.\n\t// For some reason, the primary host doesn't work, even though it has the <upload/> tag.\n\tif cli.MessengerConfig != nil {\n\t\thost = mediaConn.Hosts[len(mediaConn.Hosts)-1].Hostname\n\t} else {\n\t\thost = mediaConn.Hosts[0].Hostname\n\t}\n\tuploadURL := url.URL{\n\t\tScheme:   \"https\",\n\t\tHost:     host,\n\t\tPath:     fmt.Sprintf(\"/%s/%s/%s\", uploadPrefix, mmsType, token),\n\t\tRawQuery: q.Encode(),\n\t}\n\n\treq, err := http.NewRequestWithContext(ctx, http.MethodPost, uploadURL.String(), dataToUpload)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to prepare request: %w\", err)\n\t}\n\n\treq.ContentLength = int64(uploadSize)\n\treq.Header.Set(\"Origin\", socket.Origin)\n\treq.Header.Set(\"Referer\", socket.Origin+\"/\")\n\n\thttpResp, err := cli.http.Do(req)\n\tif err != nil {\n\t\terr = fmt.Errorf(\"failed to execute request: %w\", err)\n\t} else if httpResp.StatusCode != http.StatusOK {\n\t\terr = fmt.Errorf(\"upload failed with status code %d\", httpResp.StatusCode)\n\t} else if err = json.NewDecoder(httpResp.Body).Decode(&resp); err != nil {\n\t\terr = fmt.Errorf(\"failed to parse upload response: %w\", err)\n\t}\n\tif httpResp != nil {\n\t\t_ = httpResp.Body.Close()\n\t}\n\treturn err\n}\n"
        },
        {
          "name": "user.go",
          "type": "blob",
          "size": 25.98046875,
          "content": "// Copyright (c) 2021 Tulir Asokan\n//\n// This Source Code Form is subject to the terms of the Mozilla Public\n// License, v. 2.0. If a copy of the MPL was not distributed with this\n// file, You can obtain one at http://mozilla.org/MPL/2.0/.\n\npackage whatsmeow\n\nimport (\n\t\"context\"\n\t\"errors\"\n\t\"fmt\"\n\t\"strings\"\n\n\t\"google.golang.org/protobuf/proto\"\n\n\twaBinary \"go.mau.fi/whatsmeow/binary\"\n\twaProto \"go.mau.fi/whatsmeow/binary/proto\"\n\t\"go.mau.fi/whatsmeow/types\"\n\t\"go.mau.fi/whatsmeow/types/events\"\n)\n\nconst BusinessMessageLinkPrefix = \"https://wa.me/message/\"\nconst ContactQRLinkPrefix = \"https://wa.me/qr/\"\nconst BusinessMessageLinkDirectPrefix = \"https://api.whatsapp.com/message/\"\nconst ContactQRLinkDirectPrefix = \"https://api.whatsapp.com/qr/\"\nconst NewsletterLinkPrefix = \"https://whatsapp.com/channel/\"\n\n// ResolveBusinessMessageLink resolves a business message short link and returns the target JID, business name and\n// text to prefill in the input field (if any).\n//\n// The links look like https://wa.me/message/<code> or https://api.whatsapp.com/message/<code>. You can either provide\n// the full link, or just the <code> part.\nfunc (cli *Client) ResolveBusinessMessageLink(code string) (*types.BusinessMessageLinkTarget, error) {\n\tcode = strings.TrimPrefix(code, BusinessMessageLinkPrefix)\n\tcode = strings.TrimPrefix(code, BusinessMessageLinkDirectPrefix)\n\n\tresp, err := cli.sendIQ(infoQuery{\n\t\tNamespace: \"w:qr\",\n\t\tType:      iqGet,\n\t\t// WhatsApp android doesn't seem to have a \"to\" field for this one at all, not sure why but it works\n\t\tContent: []waBinary.Node{{\n\t\t\tTag: \"qr\",\n\t\t\tAttrs: waBinary.Attrs{\n\t\t\t\t\"code\": code,\n\t\t\t},\n\t\t}},\n\t})\n\tif errors.Is(err, ErrIQNotFound) {\n\t\treturn nil, wrapIQError(ErrBusinessMessageLinkNotFound, err)\n\t} else if err != nil {\n\t\treturn nil, err\n\t}\n\tqrChild, ok := resp.GetOptionalChildByTag(\"qr\")\n\tif !ok {\n\t\treturn nil, &ElementMissingError{Tag: \"qr\", In: \"response to business message link query\"}\n\t}\n\tvar target types.BusinessMessageLinkTarget\n\tag := qrChild.AttrGetter()\n\ttarget.JID = ag.JID(\"jid\")\n\ttarget.PushName = ag.String(\"notify\")\n\tmessageChild, ok := qrChild.GetOptionalChildByTag(\"message\")\n\tif ok {\n\t\tmessageBytes, _ := messageChild.Content.([]byte)\n\t\ttarget.Message = string(messageBytes)\n\t}\n\tbusinessChild, ok := qrChild.GetOptionalChildByTag(\"business\")\n\tif ok {\n\t\tbag := businessChild.AttrGetter()\n\t\ttarget.IsSigned = bag.OptionalBool(\"is_signed\")\n\t\ttarget.VerifiedName = bag.OptionalString(\"verified_name\")\n\t\ttarget.VerifiedLevel = bag.OptionalString(\"verified_level\")\n\t}\n\treturn &target, ag.Error()\n}\n\n// ResolveContactQRLink resolves a link from a contact share QR code and returns the target JID and push name.\n//\n// The links look like https://wa.me/qr/<code> or https://api.whatsapp.com/qr/<code>. You can either provide\n// the full link, or just the <code> part.\nfunc (cli *Client) ResolveContactQRLink(code string) (*types.ContactQRLinkTarget, error) {\n\tcode = strings.TrimPrefix(code, ContactQRLinkPrefix)\n\tcode = strings.TrimPrefix(code, ContactQRLinkDirectPrefix)\n\n\tresp, err := cli.sendIQ(infoQuery{\n\t\tNamespace: \"w:qr\",\n\t\tType:      iqGet,\n\t\tContent: []waBinary.Node{{\n\t\t\tTag: \"qr\",\n\t\t\tAttrs: waBinary.Attrs{\n\t\t\t\t\"code\": code,\n\t\t\t},\n\t\t}},\n\t})\n\tif errors.Is(err, ErrIQNotFound) {\n\t\treturn nil, wrapIQError(ErrContactQRLinkNotFound, err)\n\t} else if err != nil {\n\t\treturn nil, err\n\t}\n\tqrChild, ok := resp.GetOptionalChildByTag(\"qr\")\n\tif !ok {\n\t\treturn nil, &ElementMissingError{Tag: \"qr\", In: \"response to contact link query\"}\n\t}\n\tvar target types.ContactQRLinkTarget\n\tag := qrChild.AttrGetter()\n\ttarget.JID = ag.JID(\"jid\")\n\ttarget.PushName = ag.OptionalString(\"notify\")\n\ttarget.Type = ag.String(\"type\")\n\treturn &target, ag.Error()\n}\n\n// GetContactQRLink gets your own contact share QR link that can be resolved using ResolveContactQRLink\n// (or scanned with the official apps when encoded as a QR code).\n//\n// If the revoke parameter is set to true, it will ask the server to revoke the previous link and generate a new one.\nfunc (cli *Client) GetContactQRLink(revoke bool) (string, error) {\n\taction := \"get\"\n\tif revoke {\n\t\taction = \"revoke\"\n\t}\n\tresp, err := cli.sendIQ(infoQuery{\n\t\tNamespace: \"w:qr\",\n\t\tType:      iqSet,\n\t\tContent: []waBinary.Node{{\n\t\t\tTag: \"qr\",\n\t\t\tAttrs: waBinary.Attrs{\n\t\t\t\t\"type\":   \"contact\",\n\t\t\t\t\"action\": action,\n\t\t\t},\n\t\t}},\n\t})\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\tqrChild, ok := resp.GetOptionalChildByTag(\"qr\")\n\tif !ok {\n\t\treturn \"\", &ElementMissingError{Tag: \"qr\", In: \"response to own contact link fetch\"}\n\t}\n\tag := qrChild.AttrGetter()\n\treturn ag.String(\"code\"), ag.Error()\n}\n\n// SetStatusMessage updates the current user's status text, which is shown in the \"About\" section in the user profile.\n//\n// This is different from the ephemeral status broadcast messages. Use SendMessage to types.StatusBroadcastJID to send\n// such messages.\nfunc (cli *Client) SetStatusMessage(msg string) error {\n\t_, err := cli.sendIQ(infoQuery{\n\t\tNamespace: \"status\",\n\t\tType:      iqSet,\n\t\tTo:        types.ServerJID,\n\t\tContent: []waBinary.Node{{\n\t\t\tTag:     \"status\",\n\t\t\tContent: msg,\n\t\t}},\n\t})\n\treturn err\n}\n\n// IsOnWhatsApp checks if the given phone numbers are registered on WhatsApp.\n// The phone numbers should be in international format, including the `+` prefix.\nfunc (cli *Client) IsOnWhatsApp(phones []string) ([]types.IsOnWhatsAppResponse, error) {\n\tjids := make([]types.JID, len(phones))\n\tfor i := range jids {\n\t\tjids[i] = types.NewJID(phones[i], types.LegacyUserServer)\n\t}\n\tlist, err := cli.usync(context.TODO(), jids, \"query\", \"interactive\", []waBinary.Node{\n\t\t{Tag: \"business\", Content: []waBinary.Node{{Tag: \"verified_name\"}}},\n\t\t{Tag: \"contact\"},\n\t})\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\toutput := make([]types.IsOnWhatsAppResponse, 0, len(jids))\n\tquerySuffix := \"@\" + types.LegacyUserServer\n\tfor _, child := range list.GetChildren() {\n\t\tjid, jidOK := child.Attrs[\"jid\"].(types.JID)\n\t\tif child.Tag != \"user\" || !jidOK {\n\t\t\tcontinue\n\t\t}\n\t\tvar info types.IsOnWhatsAppResponse\n\t\tinfo.JID = jid\n\t\tinfo.VerifiedName, err = parseVerifiedName(child.GetChildByTag(\"business\"))\n\t\tif err != nil {\n\t\t\tcli.Log.Warnf(\"Failed to parse %s's verified name details: %v\", jid, err)\n\t\t}\n\t\tcontactNode := child.GetChildByTag(\"contact\")\n\t\tinfo.IsIn = contactNode.AttrGetter().String(\"type\") == \"in\"\n\t\tcontactQuery, _ := contactNode.Content.([]byte)\n\t\tinfo.Query = strings.TrimSuffix(string(contactQuery), querySuffix)\n\t\toutput = append(output, info)\n\t}\n\treturn output, nil\n}\n\n// GetUserInfo gets basic user info (avatar, status, verified business name, device list).\nfunc (cli *Client) GetUserInfo(jids []types.JID) (map[types.JID]types.UserInfo, error) {\n\tlist, err := cli.usync(context.TODO(), jids, \"full\", \"background\", []waBinary.Node{\n\t\t{Tag: \"business\", Content: []waBinary.Node{{Tag: \"verified_name\"}}},\n\t\t{Tag: \"status\"},\n\t\t{Tag: \"picture\"},\n\t\t{Tag: \"devices\", Attrs: waBinary.Attrs{\"version\": \"2\"}},\n\t})\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\trespData := make(map[types.JID]types.UserInfo, len(jids))\n\tfor _, child := range list.GetChildren() {\n\t\tjid, jidOK := child.Attrs[\"jid\"].(types.JID)\n\t\tif child.Tag != \"user\" || !jidOK {\n\t\t\tcontinue\n\t\t}\n\t\tvar info types.UserInfo\n\t\tverifiedName, err := parseVerifiedName(child.GetChildByTag(\"business\"))\n\t\tif err != nil {\n\t\t\tcli.Log.Warnf(\"Failed to parse %s's verified name details: %v\", jid, err)\n\t\t}\n\t\tstatus, _ := child.GetChildByTag(\"status\").Content.([]byte)\n\t\tinfo.Status = string(status)\n\t\tinfo.PictureID, _ = child.GetChildByTag(\"picture\").Attrs[\"id\"].(string)\n\t\tinfo.Devices = parseDeviceList(jid.User, child.GetChildByTag(\"devices\"))\n\t\tif verifiedName != nil {\n\t\t\tcli.updateBusinessName(jid, nil, verifiedName.Details.GetVerifiedName())\n\t\t}\n\t\trespData[jid] = info\n\t}\n\treturn respData, nil\n}\n\nfunc (cli *Client) GetBotListV2() ([]types.BotListInfo, error) {\n\tresp, err := cli.sendIQ(infoQuery{\n\t\tTo:        types.ServerJID,\n\t\tNamespace: \"bot\",\n\t\tType:      iqGet,\n\t\tContent: []waBinary.Node{\n\t\t\t{Tag: \"bot\", Attrs: waBinary.Attrs{\"v\": \"2\"}},\n\t\t},\n\t})\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tbotNode, ok := resp.GetOptionalChildByTag(\"bot\")\n\tif !ok {\n\t\treturn nil, &ElementMissingError{Tag: \"bot\", In: \"response to bot list query\"}\n\t}\n\n\tvar list []types.BotListInfo\n\n\tfor _, section := range botNode.GetChildrenByTag(\"section\") {\n\t\tif section.AttrGetter().String(\"type\") == \"all\" {\n\t\t\tfor _, bot := range section.GetChildrenByTag(\"bot\") {\n\t\t\t\tag := bot.AttrGetter()\n\t\t\t\tlist = append(list, types.BotListInfo{\n\t\t\t\t\tPersonaID: ag.String(\"persona_id\"),\n\t\t\t\t\tBotJID:    ag.JID(\"jid\"),\n\t\t\t\t})\n\t\t\t}\n\t\t}\n\t}\n\n\treturn list, nil\n}\n\nfunc (cli *Client) GetBotProfiles(botInfo []types.BotListInfo) ([]types.BotProfileInfo, error) {\n\tjids := make([]types.JID, len(botInfo))\n\tfor i, bot := range botInfo {\n\t\tjids[i] = bot.BotJID\n\t}\n\n\tlist, err := cli.usync(context.TODO(), jids, \"query\", \"interactive\", []waBinary.Node{\n\t\t{Tag: \"bot\", Content: []waBinary.Node{{Tag: \"profile\", Attrs: waBinary.Attrs{\"v\": \"1\"}}}},\n\t}, UsyncQueryExtras{\n\t\tBotListInfo: botInfo,\n\t})\n\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tvar profiles []types.BotProfileInfo\n\tfor _, user := range list.GetChildren() {\n\t\tjid := user.AttrGetter().JID(\"jid\")\n\t\tbot := user.GetChildByTag(\"bot\")\n\t\tprofile := bot.GetChildByTag(\"profile\")\n\t\tname := string(profile.GetChildByTag(\"name\").Content.([]byte))\n\t\tattributes := string(profile.GetChildByTag(\"attributes\").Content.([]byte))\n\t\tdescription := string(profile.GetChildByTag(\"description\").Content.([]byte))\n\t\tcategory := string(profile.GetChildByTag(\"category\").Content.([]byte))\n\t\t_, isDefault := profile.GetOptionalChildByTag(\"default\")\n\t\tpersonaID := profile.AttrGetter().String(\"persona_id\")\n\t\tcommandsNode := profile.GetChildByTag(\"commands\")\n\t\tcommandDescription := string(commandsNode.GetChildByTag(\"description\").Content.([]byte))\n\t\tvar commands []types.BotProfileCommand\n\t\tfor _, commandNode := range commandsNode.GetChildrenByTag(\"command\") {\n\t\t\tcommands = append(commands, types.BotProfileCommand{\n\t\t\t\tName:        string(commandNode.GetChildByTag(\"name\").Content.([]byte)),\n\t\t\t\tDescription: string(commandNode.GetChildByTag(\"description\").Content.([]byte)),\n\t\t\t})\n\t\t}\n\n\t\tpromptsNode := profile.GetChildByTag(\"prompts\")\n\t\tvar prompts []string\n\t\tfor _, promptNode := range promptsNode.GetChildrenByTag(\"prompt\") {\n\t\t\tprompts = append(\n\t\t\t\tprompts,\n\t\t\t\tfmt.Sprintf(\n\t\t\t\t\t\"%s %s\",\n\t\t\t\t\tstring(promptNode.GetChildByTag(\"emoji\").Content.([]byte)),\n\t\t\t\t\tstring(promptNode.GetChildByTag(\"text\").Content.([]byte)),\n\t\t\t\t),\n\t\t\t)\n\t\t}\n\n\t\tprofiles = append(profiles, types.BotProfileInfo{\n\t\t\tJID:                 jid,\n\t\t\tName:                name,\n\t\t\tAttributes:          attributes,\n\t\t\tDescription:         description,\n\t\t\tCategory:            category,\n\t\t\tIsDefault:           isDefault,\n\t\t\tPrompts:             prompts,\n\t\t\tPersonaID:           personaID,\n\t\t\tCommands:            commands,\n\t\t\tCommandsDescription: commandDescription,\n\t\t})\n\t}\n\n\treturn profiles, nil\n}\n\nfunc (cli *Client) parseBusinessProfile(node *waBinary.Node) (*types.BusinessProfile, error) {\n\tprofileNode := node.GetChildByTag(\"profile\")\n\tjid, ok := profileNode.AttrGetter().GetJID(\"jid\", true)\n\tif !ok {\n\t\treturn nil, errors.New(\"missing jid in business profile\")\n\t}\n\taddress := string(profileNode.GetChildByTag(\"address\").Content.([]byte))\n\temail := string(profileNode.GetChildByTag(\"email\").Content.([]byte))\n\tbusinessHour := profileNode.GetChildByTag(\"business_hours\")\n\tbusinessHourTimezone := businessHour.AttrGetter().String(\"timezone\")\n\tbusinessHoursConfigs := businessHour.GetChildren()\n\tbusinessHours := make([]types.BusinessHoursConfig, 0)\n\tfor _, config := range businessHoursConfigs {\n\t\tif config.Tag != \"business_hours_config\" {\n\t\t\tcontinue\n\t\t}\n\t\tdow := config.AttrGetter().String(\"dow\")\n\t\tmode := config.AttrGetter().String(\"mode\")\n\t\topenTime := config.AttrGetter().String(\"open_time\")\n\t\tcloseTime := config.AttrGetter().String(\"close_time\")\n\t\tbusinessHours = append(businessHours, types.BusinessHoursConfig{\n\t\t\tDayOfWeek: dow,\n\t\t\tMode:      mode,\n\t\t\tOpenTime:  openTime,\n\t\t\tCloseTime: closeTime,\n\t\t})\n\t}\n\tcategoriesNode := profileNode.GetChildByTag(\"categories\")\n\tcategories := make([]types.Category, 0)\n\tfor _, category := range categoriesNode.GetChildren() {\n\t\tif category.Tag != \"category\" {\n\t\t\tcontinue\n\t\t}\n\t\tid := category.AttrGetter().String(\"id\")\n\t\tname := string(category.Content.([]byte))\n\t\tcategories = append(categories, types.Category{\n\t\t\tID:   id,\n\t\t\tName: name,\n\t\t})\n\t}\n\tprofileOptionsNode := profileNode.GetChildByTag(\"profile_options\")\n\tprofileOptions := make(map[string]string)\n\tfor _, option := range profileOptionsNode.GetChildren() {\n\t\tprofileOptions[option.Tag] = string(option.Content.([]byte))\n\t}\n\treturn &types.BusinessProfile{\n\t\tJID:                   jid,\n\t\tEmail:                 email,\n\t\tAddress:               address,\n\t\tCategories:            categories,\n\t\tProfileOptions:        profileOptions,\n\t\tBusinessHoursTimeZone: businessHourTimezone,\n\t\tBusinessHours:         businessHours,\n\t}, nil\n}\n\n// GetBusinessProfile gets the profile info of a WhatsApp business account\nfunc (cli *Client) GetBusinessProfile(jid types.JID) (*types.BusinessProfile, error) {\n\tresp, err := cli.sendIQ(infoQuery{\n\t\tType:      iqGet,\n\t\tTo:        types.ServerJID,\n\t\tNamespace: \"w:biz\",\n\t\tContent: []waBinary.Node{{\n\t\t\tTag: \"business_profile\",\n\t\t\tAttrs: waBinary.Attrs{\n\t\t\t\t\"v\": \"244\",\n\t\t\t},\n\t\t\tContent: []waBinary.Node{{\n\t\t\t\tTag: \"profile\",\n\t\t\t\tAttrs: waBinary.Attrs{\n\t\t\t\t\t\"jid\": jid,\n\t\t\t\t},\n\t\t\t}},\n\t\t}},\n\t})\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tnode, ok := resp.GetOptionalChildByTag(\"business_profile\")\n\tif !ok {\n\t\treturn nil, &ElementMissingError{Tag: \"business_profile\", In: \"response to business profile query\"}\n\t}\n\treturn cli.parseBusinessProfile(&node)\n}\n\n// GetUserDevices gets the list of devices that the given user has. The input should be a list of\n// regular JIDs, and the output will be a list of AD JIDs. The local device will not be included in\n// the output even if the user's JID is included in the input. All other devices will be included.\nfunc (cli *Client) GetUserDevices(jids []types.JID) ([]types.JID, error) {\n\treturn cli.GetUserDevicesContext(context.Background(), jids)\n}\n\nfunc (cli *Client) GetUserDevicesContext(ctx context.Context, jids []types.JID) ([]types.JID, error) {\n\tcli.userDevicesCacheLock.Lock()\n\tdefer cli.userDevicesCacheLock.Unlock()\n\n\tvar devices, jidsToSync, fbJIDsToSync []types.JID\n\tfor _, jid := range jids {\n\t\tcached, ok := cli.userDevicesCache[jid]\n\t\tif ok && len(cached.devices) > 0 {\n\t\t\tdevices = append(devices, cached.devices...)\n\t\t} else if jid.Server == types.MessengerServer {\n\t\t\tfbJIDsToSync = append(fbJIDsToSync, jid)\n\t\t} else if jid.IsBot() {\n\t\t\t// Bot JIDs do not have devices, the usync query is empty\n\t\t\tdevices = append(devices, jid)\n\t\t} else {\n\t\t\tjidsToSync = append(jidsToSync, jid)\n\t\t}\n\t}\n\tif len(jidsToSync) > 0 {\n\t\tlist, err := cli.usync(ctx, jidsToSync, \"query\", \"message\", []waBinary.Node{\n\t\t\t{Tag: \"devices\", Attrs: waBinary.Attrs{\"version\": \"2\"}},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tfor _, user := range list.GetChildren() {\n\t\t\tjid, jidOK := user.Attrs[\"jid\"].(types.JID)\n\t\t\tif user.Tag != \"user\" || !jidOK {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tuserDevices := parseDeviceList(jid.User, user.GetChildByTag(\"devices\"))\n\t\t\tcli.userDevicesCache[jid] = deviceCache{devices: userDevices, dhash: participantListHashV2(userDevices)}\n\t\t\tdevices = append(devices, userDevices...)\n\t\t}\n\t}\n\n\tif len(fbJIDsToSync) > 0 {\n\t\tlist, err := cli.getFBIDDevices(ctx, fbJIDsToSync)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tfor _, user := range list.GetChildren() {\n\t\t\tjid, jidOK := user.Attrs[\"jid\"].(types.JID)\n\t\t\tif user.Tag != \"user\" || !jidOK {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tuserDevices := parseFBDeviceList(jid, user.GetChildByTag(\"devices\"))\n\t\t\tcli.userDevicesCache[jid] = userDevices\n\t\t\tdevices = append(devices, userDevices.devices...)\n\t\t}\n\t}\n\n\treturn devices, nil\n}\n\ntype GetProfilePictureParams struct {\n\tPreview     bool\n\tExistingID  string\n\tIsCommunity bool\n}\n\n// GetProfilePictureInfo gets the URL where you can download a WhatsApp user's profile picture or group's photo.\n//\n// Optionally, you can pass the last known profile picture ID.\n// If the profile picture hasn't changed, this will return nil with no error.\n//\n// To get a community photo, you should pass `IsCommunity: true`, as otherwise you may get a 401 error.\nfunc (cli *Client) GetProfilePictureInfo(jid types.JID, params *GetProfilePictureParams) (*types.ProfilePictureInfo, error) {\n\tattrs := waBinary.Attrs{\n\t\t\"query\": \"url\",\n\t}\n\tvar target, to types.JID\n\tif params == nil {\n\t\tparams = &GetProfilePictureParams{}\n\t}\n\tif params.Preview {\n\t\tattrs[\"type\"] = \"preview\"\n\t} else {\n\t\tattrs[\"type\"] = \"image\"\n\t}\n\tif params.ExistingID != \"\" {\n\t\tattrs[\"id\"] = params.ExistingID\n\t}\n\tvar expectWrapped bool\n\tvar content []waBinary.Node\n\tnamespace := \"w:profile:picture\"\n\tif params.IsCommunity {\n\t\ttarget = types.EmptyJID\n\t\tnamespace = \"w:g2\"\n\t\tto = jid\n\t\tattrs[\"parent_group_jid\"] = jid\n\t\texpectWrapped = true\n\t\tcontent = []waBinary.Node{{\n\t\t\tTag: \"pictures\",\n\t\t\tContent: []waBinary.Node{{\n\t\t\t\tTag:   \"picture\",\n\t\t\t\tAttrs: attrs,\n\t\t\t}},\n\t\t}}\n\t} else {\n\t\tto = types.ServerJID\n\t\ttarget = jid\n\t\tcontent = []waBinary.Node{{\n\t\t\tTag:   \"picture\",\n\t\t\tAttrs: attrs,\n\t\t}}\n\t}\n\tresp, err := cli.sendIQ(infoQuery{\n\t\tNamespace: namespace,\n\t\tType:      \"get\",\n\t\tTo:        to,\n\t\tTarget:    target,\n\t\tContent:   content,\n\t})\n\tif errors.Is(err, ErrIQNotAuthorized) {\n\t\treturn nil, wrapIQError(ErrProfilePictureUnauthorized, err)\n\t} else if errors.Is(err, ErrIQNotFound) {\n\t\treturn nil, wrapIQError(ErrProfilePictureNotSet, err)\n\t} else if err != nil {\n\t\treturn nil, err\n\t}\n\tif expectWrapped {\n\t\tpics, ok := resp.GetOptionalChildByTag(\"pictures\")\n\t\tif !ok {\n\t\t\treturn nil, &ElementMissingError{Tag: \"pictures\", In: \"response to profile picture query\"}\n\t\t}\n\t\tresp = &pics\n\t}\n\tpicture, ok := resp.GetOptionalChildByTag(\"picture\")\n\tif !ok {\n\t\tif params.ExistingID != \"\" {\n\t\t\treturn nil, nil\n\t\t}\n\t\treturn nil, &ElementMissingError{Tag: \"picture\", In: \"response to profile picture query\"}\n\t}\n\tvar info types.ProfilePictureInfo\n\tag := picture.AttrGetter()\n\tif ag.OptionalInt(\"status\") == 304 {\n\t\treturn nil, nil\n\t}\n\tinfo.ID = ag.String(\"id\")\n\tinfo.URL = ag.String(\"url\")\n\tinfo.Type = ag.String(\"type\")\n\tinfo.DirectPath = ag.String(\"direct_path\")\n\tif !ag.OK() {\n\t\treturn &info, ag.Error()\n\t}\n\treturn &info, nil\n}\n\nfunc (cli *Client) handleHistoricalPushNames(names []*waProto.Pushname) {\n\tif cli.Store.Contacts == nil {\n\t\treturn\n\t}\n\tcli.Log.Infof(\"Updating contact store with %d push names from history sync\", len(names))\n\tfor _, user := range names {\n\t\tif user.GetPushname() == \"-\" {\n\t\t\tcontinue\n\t\t}\n\t\tvar changed bool\n\t\tif jid, err := types.ParseJID(user.GetId()); err != nil {\n\t\t\tcli.Log.Warnf(\"Failed to parse user ID '%s' in push name history sync: %v\", user.GetId(), err)\n\t\t} else if changed, _, err = cli.Store.Contacts.PutPushName(jid, user.GetPushname()); err != nil {\n\t\t\tcli.Log.Warnf(\"Failed to store push name of %s from history sync: %v\", err)\n\t\t} else if changed {\n\t\t\tcli.Log.Debugf(\"Got push name %s for %s in history sync\", user.GetPushname(), jid)\n\t\t}\n\t}\n}\n\nfunc (cli *Client) updatePushName(user types.JID, messageInfo *types.MessageInfo, name string) {\n\tif cli.Store.Contacts == nil {\n\t\treturn\n\t}\n\tuser = user.ToNonAD()\n\tchanged, previousName, err := cli.Store.Contacts.PutPushName(user, name)\n\tif err != nil {\n\t\tcli.Log.Errorf(\"Failed to save push name of %s in device store: %v\", user, err)\n\t} else if changed {\n\t\tcli.Log.Debugf(\"Push name of %s changed from %s to %s, dispatching event\", user, previousName, name)\n\t\tcli.dispatchEvent(&events.PushName{\n\t\t\tJID:         user,\n\t\t\tMessage:     messageInfo,\n\t\t\tOldPushName: previousName,\n\t\t\tNewPushName: name,\n\t\t})\n\t}\n}\n\nfunc (cli *Client) updateBusinessName(user types.JID, messageInfo *types.MessageInfo, name string) {\n\tif cli.Store.Contacts == nil {\n\t\treturn\n\t}\n\tchanged, previousName, err := cli.Store.Contacts.PutBusinessName(user, name)\n\tif err != nil {\n\t\tcli.Log.Errorf(\"Failed to save business name of %s in device store: %v\", user, err)\n\t} else if changed {\n\t\tcli.Log.Debugf(\"Business name of %s changed from %s to %s, dispatching event\", user, previousName, name)\n\t\tcli.dispatchEvent(&events.BusinessName{\n\t\t\tJID:             user,\n\t\t\tMessage:         messageInfo,\n\t\t\tOldBusinessName: previousName,\n\t\t\tNewBusinessName: name,\n\t\t})\n\t}\n}\n\nfunc parseVerifiedName(businessNode waBinary.Node) (*types.VerifiedName, error) {\n\tif businessNode.Tag != \"business\" {\n\t\treturn nil, nil\n\t}\n\tverifiedNameNode, ok := businessNode.GetOptionalChildByTag(\"verified_name\")\n\tif !ok {\n\t\treturn nil, nil\n\t}\n\treturn parseVerifiedNameContent(verifiedNameNode)\n}\n\nfunc parseVerifiedNameContent(verifiedNameNode waBinary.Node) (*types.VerifiedName, error) {\n\trawCert, ok := verifiedNameNode.Content.([]byte)\n\tif !ok {\n\t\treturn nil, nil\n\t}\n\n\tvar cert waProto.VerifiedNameCertificate\n\terr := proto.Unmarshal(rawCert, &cert)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tvar certDetails waProto.VerifiedNameCertificate_Details\n\terr = proto.Unmarshal(cert.GetDetails(), &certDetails)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn &types.VerifiedName{\n\t\tCertificate: &cert,\n\t\tDetails:     &certDetails,\n\t}, nil\n}\n\nfunc parseDeviceList(user string, deviceNode waBinary.Node) []types.JID {\n\tdeviceList := deviceNode.GetChildByTag(\"device-list\")\n\tif deviceNode.Tag != \"devices\" || deviceList.Tag != \"device-list\" {\n\t\treturn nil\n\t}\n\tchildren := deviceList.GetChildren()\n\tdevices := make([]types.JID, 0, len(children))\n\tfor _, device := range children {\n\t\tdeviceID, ok := device.AttrGetter().GetInt64(\"id\", true)\n\t\tif device.Tag != \"device\" || !ok {\n\t\t\tcontinue\n\t\t}\n\t\tdevices = append(devices, types.NewADJID(user, 0, byte(deviceID)))\n\t}\n\treturn devices\n}\n\nfunc parseFBDeviceList(user types.JID, deviceList waBinary.Node) deviceCache {\n\tchildren := deviceList.GetChildren()\n\tdevices := make([]types.JID, 0, len(children))\n\tfor _, device := range children {\n\t\tdeviceID, ok := device.AttrGetter().GetInt64(\"id\", true)\n\t\tif device.Tag != \"device\" || !ok {\n\t\t\tcontinue\n\t\t}\n\t\tuser.Device = uint16(deviceID)\n\t\tdevices = append(devices, user)\n\t\t// TODO take identities here too?\n\t}\n\t// TODO do something with the icdc blob?\n\treturn deviceCache{\n\t\tdevices: devices,\n\t\tdhash:   deviceList.AttrGetter().String(\"dhash\"),\n\t}\n}\n\nfunc (cli *Client) getFBIDDevices(ctx context.Context, jids []types.JID) (*waBinary.Node, error) {\n\tusers := make([]waBinary.Node, len(jids))\n\tfor i, jid := range jids {\n\t\tusers[i].Tag = \"user\"\n\t\tusers[i].Attrs = waBinary.Attrs{\"jid\": jid}\n\t\t// TODO include dhash for users\n\t}\n\tresp, err := cli.sendIQ(infoQuery{\n\t\tContext:   ctx,\n\t\tNamespace: \"fbid:devices\",\n\t\tType:      iqGet,\n\t\tTo:        types.ServerJID,\n\t\tContent: []waBinary.Node{{\n\t\t\tTag:     \"users\",\n\t\t\tContent: users,\n\t\t}},\n\t})\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to send usync query: %w\", err)\n\t} else if list, ok := resp.GetOptionalChildByTag(\"users\"); !ok {\n\t\treturn nil, &ElementMissingError{Tag: \"users\", In: \"response to fbid devices query\"}\n\t} else {\n\t\treturn &list, err\n\t}\n}\n\ntype UsyncQueryExtras struct {\n\tBotListInfo []types.BotListInfo\n}\n\nfunc (cli *Client) usync(ctx context.Context, jids []types.JID, mode, context string, query []waBinary.Node, extra ...UsyncQueryExtras) (*waBinary.Node, error) {\n\tif cli == nil {\n\t\treturn nil, ErrClientIsNil\n\t}\n\tvar extras UsyncQueryExtras\n\tif len(extra) > 1 {\n\t\treturn nil, errors.New(\"only one extra parameter may be provided to usync()\")\n\t} else if len(extra) == 1 {\n\t\textras = extra[0]\n\t}\n\n\tuserList := make([]waBinary.Node, len(jids))\n\tfor i, jid := range jids {\n\t\tuserList[i].Tag = \"user\"\n\t\tjid = jid.ToNonAD()\n\n\t\tswitch jid.Server {\n\t\tcase types.LegacyUserServer:\n\t\t\tuserList[i].Content = []waBinary.Node{{\n\t\t\t\tTag:     \"contact\",\n\t\t\t\tContent: jid.String(),\n\t\t\t}}\n\t\tcase types.DefaultUserServer:\n\t\t\tuserList[i].Attrs = waBinary.Attrs{\"jid\": jid}\n\t\t\tif jid.IsBot() {\n\t\t\t\tvar personaId string\n\t\t\t\tfor _, bot := range extras.BotListInfo {\n\t\t\t\t\tif bot.BotJID.User == jid.User {\n\t\t\t\t\t\tpersonaId = bot.PersonaID\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tuserList[i].Content = []waBinary.Node{{\n\t\t\t\t\tTag: \"bot\",\n\t\t\t\t\tContent: []waBinary.Node{{\n\t\t\t\t\t\tTag:   \"profile\",\n\t\t\t\t\t\tAttrs: waBinary.Attrs{\"persona_id\": personaId},\n\t\t\t\t\t}},\n\t\t\t\t}}\n\t\t\t}\n\t\tdefault:\n\t\t\treturn nil, fmt.Errorf(\"unknown user server '%s'\", jid.Server)\n\t\t}\n\t}\n\tresp, err := cli.sendIQ(infoQuery{\n\t\tContext:   ctx,\n\t\tNamespace: \"usync\",\n\t\tType:      \"get\",\n\t\tTo:        types.ServerJID,\n\t\tContent: []waBinary.Node{{\n\t\t\tTag: \"usync\",\n\t\t\tAttrs: waBinary.Attrs{\n\t\t\t\t\"sid\":     cli.generateRequestID(),\n\t\t\t\t\"mode\":    mode,\n\t\t\t\t\"last\":    \"true\",\n\t\t\t\t\"index\":   \"0\",\n\t\t\t\t\"context\": context,\n\t\t\t},\n\t\t\tContent: []waBinary.Node{\n\t\t\t\t{Tag: \"query\", Content: query},\n\t\t\t\t{Tag: \"list\", Content: userList},\n\t\t\t},\n\t\t}},\n\t})\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to send usync query: %w\", err)\n\t} else if list, ok := resp.GetOptionalChildByTag(\"usync\", \"list\"); !ok {\n\t\treturn nil, &ElementMissingError{Tag: \"list\", In: \"response to usync query\"}\n\t} else {\n\t\treturn &list, err\n\t}\n}\n\nfunc (cli *Client) parseBlocklist(node *waBinary.Node) *types.Blocklist {\n\toutput := &types.Blocklist{\n\t\tDHash: node.AttrGetter().String(\"dhash\"),\n\t}\n\tfor _, child := range node.GetChildren() {\n\t\tag := child.AttrGetter()\n\t\tblockedJID := ag.JID(\"jid\")\n\t\tif !ag.OK() {\n\t\t\tcli.Log.Debugf(\"Ignoring contact blocked data with unexpected attributes: %v\", ag.Error())\n\t\t\tcontinue\n\t\t}\n\n\t\toutput.JIDs = append(output.JIDs, blockedJID)\n\t}\n\treturn output\n}\n\n// GetBlocklist gets the list of users that this user has blocked.\nfunc (cli *Client) GetBlocklist() (*types.Blocklist, error) {\n\tresp, err := cli.sendIQ(infoQuery{\n\t\tNamespace: \"blocklist\",\n\t\tType:      iqGet,\n\t\tTo:        types.ServerJID,\n\t})\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tlist, ok := resp.GetOptionalChildByTag(\"list\")\n\tif !ok {\n\t\treturn nil, &ElementMissingError{Tag: \"list\", In: \"response to blocklist query\"}\n\t}\n\treturn cli.parseBlocklist(&list), nil\n}\n\n// UpdateBlocklist updates the user's block list and returns the updated list.\nfunc (cli *Client) UpdateBlocklist(jid types.JID, action events.BlocklistChangeAction) (*types.Blocklist, error) {\n\tresp, err := cli.sendIQ(infoQuery{\n\t\tNamespace: \"blocklist\",\n\t\tType:      iqSet,\n\t\tTo:        types.ServerJID,\n\t\tContent: []waBinary.Node{{\n\t\t\tTag: \"item\",\n\t\t\tAttrs: waBinary.Attrs{\n\t\t\t\t\"jid\":    jid,\n\t\t\t\t\"action\": string(action),\n\t\t\t},\n\t\t}},\n\t})\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tlist, ok := resp.GetOptionalChildByTag(\"list\")\n\tif !ok {\n\t\treturn nil, &ElementMissingError{Tag: \"list\", In: \"response to blocklist update\"}\n\t}\n\treturn cli.parseBlocklist(&list), err\n}\n"
        },
        {
          "name": "util",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}